{"id":0,"predictions":["a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( min ( [ a , b ] , d [ a ] ) ) NEW_LINE"],"references":["x , y = map ( int , str ( input ( ) ) . split ( ' ▁ ' ) ) NEW_LINE print ( ' { } ' . format ( x if x > y else y ) ) NEW_LINE","X , Y = ( int ( i ) for i in input ( ) . split ( ) ) NEW_LINE if X > Y : NEW_LINE INDENT print ( X ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( Y ) NEW_LINE DEDENT","def return_max ( x , y ) : NEW_LINE INDENT return x if x > y else y NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x , y , = map ( int , input ( ) . split ( ) ) NEW_LINE print ( return_max ( x , y ) ) NEW_LINE DEDENT"],"bleu":0.41633534727137295,"rouge_l":0.551355792933443}
{"id":1,"predictions":["import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE inf = 10 ** 20 NEW_LINE gosa = 1.0 \/ 10 ** 10 NEW_LINE mod = 10 ** 9 + 7 NEW_LINE dd = [ ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) ] NEW_LINE ddn = [ ( - 1 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) , ( 1 , 0 ) , ( 1 , - 1 ) , ( 0 , - 1 ) , ( - 1 , - 1 ) ] NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def F ( ) : return float ( sys . stdin . readline ( ) ) NEW_LINE def S ( ) : return input ( ) NEW_LINE def pf ( s ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def pf ( s ) : return map ( float , sys . stdin . readline ( ) . split ( ) ) NEW_LINE def pf ( s ) : return map ( float , sys . stdin . readline ( ) . split ( ) ) NEW_LINE def ls ( ) : return stdin . readline ( ) . split ( ) NEW_LINE def ns ( ) : return stdin . readline ( ) . rstrip ( ) NEW_LINE def ri ( ) : return 1 NEW_LINE s = sys . stdin . readline ( ) ) NEW_LINE def yi ( )"],"references":["s = input ( ) NEW_LINE if len ( s ) != 26 : NEW_LINE INDENT se = set ( [ ] ) NEW_LINE for w in s : NEW_LINE INDENT se . add ( w ) NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT w = chr ( ord ( ' a ' ) + i ) NEW_LINE if w not in se : NEW_LINE INDENT print ( s + w ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT DEDENT if s == \" zyxwvutsrqponmlkjihgfedcba \" : NEW_LINE INDENT print ( - 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT se = set ( [ ] ) NEW_LINE for i in reversed ( range ( 26 ) ) : NEW_LINE INDENT se . add ( s [ i ] ) NEW_LINE for j in range ( ord ( s [ i ] ) - ord ( ' a ' ) + 1 , 26 ) : NEW_LINE INDENT if chr ( ord ( ' a ' ) + j ) in se : NEW_LINE INDENT print ( s [ : i ] + chr ( ord ( ' a ' ) + j ) ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT DEDENT","import numpy as np NEW_LINE alpha = list ( ' abcdefghijklmnopqrstuvwxyz ' ) NEW_LINE alpha_num = [ num for num in range ( 26 ) ] NEW_LINE d = { char : num for ( char , num ) in zip ( alpha , range ( 26 ) ) } NEW_LINE S = input ( ) NEW_LINE S_num = np . array ( [ d [ char ] for char in S ] ) NEW_LINE last = S_num [ - 1 ] NEW_LINE flag = True NEW_LINE if len ( S ) < 26 : NEW_LINE INDENT S_num . sort ( ) NEW_LINE for k in range ( len ( S_num ) ) : NEW_LINE INDENT if S_num [ k ] != alpha_num [ k ] : NEW_LINE INDENT print ( S + alpha [ k ] ) NEW_LINE flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if flag : NEW_LINE INDENT print ( S + alpha [ len ( S ) ] ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for k in reversed ( range ( 1 , 26 ) ) : NEW_LINE INDENT if S_num [ k ] > S_num [ k - 1 ] : NEW_LINE INDENT A = S_num [ k : ] NEW_LINE A = A [ A > S_num [ k - 1 ] ] NEW_LINE A . sort ( ) NEW_LINE print ( S [ : k - 1 ] + alpha [ A [ 0 ] ] ) NEW_LINE flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if flag : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT","import string NEW_LINE alphabet = string . ascii_lowercase NEW_LINE S = input ( ) NEW_LINE count = list ( map ( lambda x : S . count ( x ) , alphabet ) ) NEW_LINE for a in alphabet : NEW_LINE INDENT if count [ alphabet . index ( a ) ] == 0 : NEW_LINE INDENT print ( S + a ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT count = [ 0 for _ in range ( len ( alphabet ) ) ] NEW_LINE cand = \" \" NEW_LINE for i , s in enumerate ( S [ : : - 1 ] ) : NEW_LINE INDENT cand += s NEW_LINE if i == len ( S ) - 1 : NEW_LINE INDENT print ( - 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT res = \" \" NEW_LINE for a in cand : NEW_LINE INDENT if ord ( S [ - ( i + 2 ) ] ) < ord ( a ) : NEW_LINE INDENT if res and res < S [ : len ( S ) - i - 2 ] + a : NEW_LINE INDENT exit NEW_LINE DEDENT else : NEW_LINE INDENT res = S [ : len ( S ) - i - 2 ] + a NEW_LINE DEDENT DEDENT DEDENT if res : NEW_LINE INDENT print ( res ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT"],"bleu":0.050885036627024115,"rouge_l":0.2666143873314612}
{"id":2,"predictions":["def autodoor ( N : int , T : int , A : list ) -> int : NEW_LINE INDENT open_time , close_time = 0 , 0 NEW_LINE total_opening_time = 0 NEW_LINE for a in A : NEW_LINE INDENT if a > close_time : NEW_LINE INDENT total_opening_time += close_time - open_time NEW_LINE open_time = a NEW_LINE DEDENT close_time = a + T NEW_LINE DEDENT else : NEW_LINE INDENT total_opening_time += close_time - open_time NEW_LINE DEDENT return total_opening_time NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 0 NEW_LINE N , T = map ( int , input ( ) . split ( ) ) NEW_LINE A = [ int ( input ( ) ) for _ in range ( N ) ] NEW_LINE ans = autodoor ( N , T , A ) NEW_LINE print ( ans ) NEW_LINE DEDENT"],"references":["def getInt ( ) : return int ( input ( ) ) NEW_LINE def getIntList ( ) : return [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE def dmp ( x ) : NEW_LINE INDENT global debug NEW_LINE if debug : NEW_LINE INDENT print ( x ) NEW_LINE DEDENT DEDENT def probC ( ) : NEW_LINE INDENT N , T = getIntList ( ) NEW_LINE Ts = getIntList ( ) NEW_LINE dmp ( ( N , T , Ts ) ) NEW_LINE total = Ts [ 0 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT total += min ( T , Ts [ i ] - Ts [ i - 1 ] ) NEW_LINE DEDENT return total + T NEW_LINE DEDENT debug = False NEW_LINE print ( probC ( ) ) NEW_LINE","import array NEW_LINE from bisect import * NEW_LINE from collections import * NEW_LINE import fractions NEW_LINE import heapq NEW_LINE from itertools import * NEW_LINE import math NEW_LINE import random NEW_LINE import re NEW_LINE import string NEW_LINE import sys NEW_LINE N , T = map ( int , input ( ) . split ( ) ) NEW_LINE prev = None NEW_LINE ans = 0 NEW_LINE for t in map ( int , input ( ) . split ( ) ) : NEW_LINE INDENT if prev is not None : NEW_LINE INDENT if t - prev < T : NEW_LINE INDENT ans += t - prev NEW_LINE DEDENT else : NEW_LINE INDENT ans += T NEW_LINE DEDENT DEDENT prev = t NEW_LINE DEDENT ans += T NEW_LINE print ( ans ) NEW_LINE","n , T = map ( int , input ( ) . split ( ) ) NEW_LINE t = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE t = [ 0 ] + t NEW_LINE time = t [ - 1 ] NEW_LINE for a in range ( 1 , n + 1 ) : NEW_LINE INDENT if t [ a ] - t [ a - 1 ] > T : NEW_LINE INDENT time -= ( t [ a ] - t [ a - 1 ] ) - T NEW_LINE DEDENT DEDENT print ( time + T ) NEW_LINE"],"bleu":0.39140599141009674,"rouge_l":0.35275800711743766}
{"id":3,"predictions":["n = int ( input ( ) ) NEW_LINE ans = 0 NEW_LINE if n % 2 == 1 : NEW_LINE INDENT ans = n + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = n - 1 NEW_LINE DEDENT print ( ans ) NEW_LINE"],"references":["n = int ( input ( ) ) NEW_LINE if n % 2 == 0 : NEW_LINE INDENT print ( n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n + 1 ) NEW_LINE DEDENT","def pair ( N : int ) -> int : NEW_LINE INDENT if N % 2 == 0 : NEW_LINE INDENT return N - 1 NEW_LINE DEDENT return N + 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE ans = pair ( N ) NEW_LINE print ( ans ) NEW_LINE DEDENT","a = int ( input ( ) ) NEW_LINE print ( a + 1 if a % 2 else a - 1 ) NEW_LINE"],"bleu":0.6596608835562316,"rouge_l":0.7095868431608504}
{"id":4,"predictions":["def Elements ( K , N ) : NEW_LINE INDENT mid = int ( K ) NEW_LINE arr = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def E ( K , N ) : NEW_LINE INDENT mid = [ N for i in range ( N ) ] NEW_LINE arr [ 0 ] = K \/\/ 2 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT arr [ i ] = int ( K \/ 2 ) NEW_LINE arr [ i ] = ( K + 1 ) \/\/ 2 NEW_LINE DEDENT for i in range ( N \/\/ 2 ) : NEW_LINE INDENT arr [ i ] = ( K + 1 ) \/\/ 2 NEW_LINE DEDENT for i in range ( N \/\/ 2 ) : NEW_LINE INDENT arr [ i ] = ( K + 1 ) \/\/ 2 NEW_LINE DEDENT for i in range ( N \/\/ 2 ) : NEW_LINE INDENT arr [ i ] = arr [ K + 1 ] \/ 2 NEW_LINE DEDENT for i in range ( N \/\/ 2 ) : NEW_LINE INDENT arr [ i ] = E [ N \/\/ 2 ] NEW_LINE DEDENT print ( * arr ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def main ( ) : NEW_LINE INDENT [ K , N ] = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE r = [ ] NEW_LINE if K == 1 : NEW_LINE INDENT r = [ 1 ] * ( ( N + 1 ) \/\/ 2 ) NEW_LINE DEDENT elif K % 2 == 0 : NEW_LINE INDENT r = [ K \/\/ 2 ] NEW_LINE r += [ K ] * ( N - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT t = N \/\/ 2 NEW_LINE x = int ( math . log ( N * ( K - 1 ) + 1 , K ) - 1 ) NEW_LINE while t < ( ( K ** ( x + 1 ) - 1 ) \/ ( K - 1 ) + x ) \/\/ 2 : NEW_LINE INDENT x -= 1 NEW_LINE DEDENT x += 1 NEW_LINE r = [ ( K + 1 ) \/\/ 2 ] * ( N - x ) NEW_LINE r += [ 0 ] * x NEW_LINE t = ( ( K ** ( x + 1 ) - 1 ) \/ ( K - 1 ) + x ) \/\/ 2 - t NEW_LINE for i in range ( x , 0 , - 1 ) : NEW_LINE INDENT r [ N - i ] = 1 NEW_LINE t -= 1 NEW_LINE for j in range ( K - 1 ) : NEW_LINE INDENT if t == 0 : NEW_LINE INDENT break NEW_LINE DEDENT if K ** i - 1 <= t * ( K - 1 ) : NEW_LINE INDENT r [ N - i ] += 1 NEW_LINE t -= ( K ** i - 1 ) \/\/ ( K - 1 ) NEW_LINE DEDENT DEDENT if t == 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in range ( len ( r ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if r [ i ] == 0 : NEW_LINE INDENT r . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT print ( ' ▁ ' . join ( list ( map ( str , r ) ) ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT","from itertools import chain , repeat NEW_LINE K , N = map ( int , input ( ) . split ( ) ) NEW_LINE def solve ( ) : NEW_LINE INDENT if K % 2 == 0 : NEW_LINE INDENT return ' ▁ ' . join ( map ( str , chain ( ( K \/\/ 2 , ) , repeat ( K , N - 1 ) ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT seq = [ K \/\/ 2 + 1 ] * N NEW_LINE d = N \/\/ 2 NEW_LINE for _ in range ( d ) : NEW_LINE INDENT if seq [ - 1 ] == 1 : NEW_LINE INDENT seq . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT seq [ - 1 ] -= 1 NEW_LINE seq . extend ( repeat ( K , N - len ( seq ) ) ) NEW_LINE DEDENT DEDENT return ' ▁ ' . join ( map ( str , seq ) ) NEW_LINE DEDENT DEDENT def naive ( ) : NEW_LINE INDENT from itertools import product NEW_LINE s = sorted ( chain . from_iterable ( product ( range ( 1 , K + 1 ) , repeat = i ) for i in range ( 1 , N + 1 ) ) ) NEW_LINE return ' ▁ ' . join ( map ( str , s [ ( len ( s ) - 1 ) \/\/ 2 ] ) ) NEW_LINE DEDENT print ( solve ( ) ) NEW_LINE NEW_LINE","import math NEW_LINE def main ( K , N ) : NEW_LINE INDENT ans = [ ] NEW_LINE if K % 2 == 0 : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT ans . append ( K \/\/ 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( K ) NEW_LINE DEDENT DEDENT DEDENT elif K == 1 : NEW_LINE INDENT n2 = math . ceil ( N \/ 2 ) NEW_LINE for i in range ( n2 ) : NEW_LINE INDENT ans . append ( 1 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT K2 = math . ceil ( K \/ 2 ) NEW_LINE ans = [ K2 ] * N NEW_LINE n = N \/\/ 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ans [ - 1 ] == 1 : NEW_LINE INDENT ans . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT ans [ - 1 ] -= 1 NEW_LINE while len ( ans ) < N : NEW_LINE INDENT ans . append ( K ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return ' ▁ ' . join ( map ( str , ans ) ) NEW_LINE DEDENT K , N = map ( int , input ( ) . split ( ) ) NEW_LINE print ( main ( K , N ) ) NEW_LINE"],"bleu":0.398375670380248,"rouge_l":0.4608620262571216}
{"id":5,"predictions":["print ( ' YY YNEOS ' [ len ( map ( int , input ( ) . split ( ) ) ) : : 2 ] ) NEW_LINE"],"references":["A , B = map ( int , input ( ) . split ( ) ) NEW_LINE if A <= 8 and B <= 8 : NEW_LINE INDENT print ( ' Yay ! ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' : ( ' ) NEW_LINE DEDENT","i = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE A = i [ 0 ] NEW_LINE B = i [ 1 ] NEW_LINE if ( A - B > 1 or B - A > 1 ) : NEW_LINE INDENT print ( ' : ( ' ) NEW_LINE DEDENT if ( ( A - B ) == 0 or ( A - B ) == 1 or ( B - A ) == 0 or ( B - A ) == 1 ) : NEW_LINE INDENT print ( ' Yay ! ' ) NEW_LINE DEDENT","print ( ' Yay ! ' if max ( [ int ( i ) for i in input ( ) . split ( ) ] ) <= 8 else ' : ( ' ) NEW_LINE"],"bleu":0.47638032571206046,"rouge_l":0.5397917871602083}
{"id":6,"predictions":["import sys NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE def solve ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE A , B = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if A == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT ans = 1 NEW_LINE if B % N == 0 : NEW_LINE INDENT ans *= MOD NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT ans *= A NEW_LINE ans *= ( B \/\/ i ) % MOD NEW_LINE DEDENT ans %= MOD NEW_LINE DEDENT print ( ans ) NEW_LINE"],"references":["import heapq NEW_LINE N , A , B = map ( int , input ( ) . split ( ) ) NEW_LINE src = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if A == 1 : NEW_LINE INDENT for v in sorted ( src ) : NEW_LINE INDENT print ( v ) NEW_LINE DEDENT exit ( ) NEW_LINE DEDENT mem = [ ] NEW_LINE maxv = 0 NEW_LINE for i , v in enumerate ( src ) : NEW_LINE INDENT mem . append ( ( v , i ) ) NEW_LINE if v > maxv : maxv = v NEW_LINE DEDENT heapq . heapify ( mem ) NEW_LINE while True : NEW_LINE INDENT v , i = heapq . heappop ( mem ) NEW_LINE if B == 0 or ( v * A > maxv and B % N == 0 ) : NEW_LINE INDENT heapq . heappush ( mem , ( v , i ) ) NEW_LINE break NEW_LINE DEDENT maxv = max ( maxv , v * A ) NEW_LINE heapq . heappush ( mem , ( v * A , i ) ) NEW_LINE B -= 1 NEW_LINE DEDENT MOD = 10 ** 9 + 7 NEW_LINE p = pow ( A , B \/\/ N , MOD ) NEW_LINE while mem : NEW_LINE INDENT v , i = heapq . heappop ( mem ) NEW_LINE print ( ( v * p ) % MOD ) NEW_LINE DEDENT","def pow_mod ( a , b ) : NEW_LINE INDENT res = 1 NEW_LINE while b > 0 : NEW_LINE INDENT if b & 1 : NEW_LINE INDENT res = ( res * a ) % MOD NEW_LINE DEDENT b >>= 1 NEW_LINE a = ( a * a ) % MOD NEW_LINE DEDENT return res ; NEW_LINE DEDENT MOD = 1000000007 NEW_LINE N , A , B = map ( int , input ( ) . split ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE arr . sort ( ) NEW_LINE if A == 1 : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT print ( arr [ i ] % MOD ) NEW_LINE DEDENT exit ( ) NEW_LINE DEDENT count = 0 NEW_LINE num_max = arr [ N - 1 ] NEW_LINE for i in range ( B ) : NEW_LINE INDENT if arr [ 0 ] * A > arr [ N - 1 ] : NEW_LINE INDENT break NEW_LINE DEDENT count += 1 NEW_LINE arr [ 0 ] *= A NEW_LINE arr . sort ( ) NEW_LINE DEDENT B -= count NEW_LINE for i in range ( B % N ) : NEW_LINE INDENT arr [ i ] *= A NEW_LINE DEDENT arr . sort ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT arr [ i ] %= MOD NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT arr [ i ] *= pow_mod ( A % MOD , B \/\/ N ) NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT print ( arr [ i ] % MOD ) NEW_LINE DEDENT exit ( ) NEW_LINE DEDENT","import sys NEW_LINE import heapq NEW_LINE import bisect NEW_LINE import operator NEW_LINE from itertools import * NEW_LINE sys . setrecursionlimit ( 100000 ) NEW_LINE def read ( ) : NEW_LINE INDENT return int ( input ( ) ) NEW_LINE DEDENT def reads ( ) : NEW_LINE INDENT return [ int ( s ) for s in input ( ) . split ( ) ] NEW_LINE DEDENT M = 10 ** 9 + 7 NEW_LINE ( N , A , B ) = reads ( ) NEW_LINE aa = reads ( ) NEW_LINE aa . sort ( ) NEW_LINE if A == 1 : NEW_LINE INDENT for a in aa : NEW_LINE INDENT print ( a ) NEW_LINE DEDENT sys . exit ( ) NEW_LINE DEDENT aa = [ ( aa [ i ] , i ) for i in range ( N ) ] NEW_LINE count = B NEW_LINE while B > 0 : NEW_LINE INDENT ( a , i ) = aa [ 0 ] NEW_LINE if i == N - 1 : NEW_LINE INDENT break NEW_LINE DEDENT aa . pop ( 0 ) NEW_LINE aa . append ( ( a * A , i ) ) NEW_LINE aa . sort ( ) NEW_LINE B -= 1 NEW_LINE DEDENT aa = [ a % M for ( a , i ) in aa ] NEW_LINE Q = B \/\/ N NEW_LINE R = B % N NEW_LINE aa = [ ( a * pow ( A , Q , M ) ) % M for a in aa ] NEW_LINE for _ in range ( R ) : NEW_LINE INDENT a = aa . pop ( 0 ) NEW_LINE aa . append ( ( a * A ) % M ) NEW_LINE DEDENT for a in aa : NEW_LINE INDENT print ( a ) NEW_LINE DEDENT"],"bleu":0.18764450754675335,"rouge_l":0.3394560669456067}
{"id":7,"predictions":["def main ( ) : NEW_LINE INDENT m , n = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE n , m = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE ans = 0 NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT ans += n % m NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"references":["m , n , N = [ int ( _ ) for _ in input ( ) . split ( ) ] NEW_LINE result = N NEW_LINE s = N NEW_LINE while s >= m : NEW_LINE INDENT x , s = divmod ( s , m ) NEW_LINE s += x * n NEW_LINE result += x * n NEW_LINE DEDENT print ( result ) NEW_LINE","m , n , N = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( N - n ) \/\/ ( m - n ) * n + N ) NEW_LINE","m , n , N = map ( int , input ( ) . split ( ) ) NEW_LINE res = N NEW_LINE tmp = N NEW_LINE g = 0 NEW_LINE while True : NEW_LINE INDENT e = 0 NEW_LINE flag = False NEW_LINE for i in range ( tmp ) : NEW_LINE INDENT g += 1 NEW_LINE if g == m : NEW_LINE INDENT res += n NEW_LINE g = 0 NEW_LINE e += n NEW_LINE flag = True NEW_LINE DEDENT DEDENT if flag == False : NEW_LINE INDENT break NEW_LINE DEDENT tmp = e NEW_LINE DEDENT print ( res ) NEW_LINE"],"bleu":0.3155986543003275,"rouge_l":0.4992559523809523}
{"id":8,"predictions":["import sys NEW_LINE def solve ( obstacles ) : NEW_LINE INDENT offset = 0 NEW_LINE obstacles . sort ( ) NEW_LINE for x , y in obstacles : NEW_LINE INDENT if x > y + offset : NEW_LINE INDENT return x - x NEW_LINE DEDENT if x == y + offset : NEW_LINE INDENT offset += 1 NEW_LINE DEDENT DEDENT return h NEW_LINE DEDENT h , w , n = map ( int , input ( ) . split ( ) ) NEW_LINE print ( solve ( obstacles ) ) NEW_LINE"],"references":["w , h , n = map ( int , input ( ) . split ( ) ) NEW_LINE x1 = [ ] NEW_LINE x2 = [ ] NEW_LINE y3 = [ ] NEW_LINE y4 = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT x , y , a = map ( int , input ( ) . split ( ) ) NEW_LINE if a == 1 : NEW_LINE INDENT x1 . append ( x ) NEW_LINE DEDENT elif a == 2 : NEW_LINE INDENT x2 . append ( x ) NEW_LINE DEDENT elif a == 3 : NEW_LINE INDENT y3 . append ( y ) NEW_LINE DEDENT else : NEW_LINE INDENT y4 . append ( y ) NEW_LINE DEDENT DEDENT for t in [ x1 , y3 ] : NEW_LINE INDENT if not t : NEW_LINE INDENT t . append ( 0 ) NEW_LINE DEDENT DEDENT if not x2 : NEW_LINE INDENT x2 . append ( w ) NEW_LINE DEDENT if not y4 : NEW_LINE INDENT y4 . append ( h ) NEW_LINE DEDENT if max ( x1 ) >= min ( x2 ) or max ( y3 ) >= min ( y4 ) : NEW_LINE INDENT print ( 0 ) NEW_LINE exit ( ) NEW_LINE DEDENT print ( ( min ( x2 ) - max ( x1 ) ) * ( min ( y4 ) - max ( y3 ) ) ) NEW_LINE","import sys , re NEW_LINE from collections import deque , defaultdict , Counter NEW_LINE from math import ceil , sqrt , hypot , factorial , pi , sin , cos , radians NEW_LINE from itertools import permutations , combinations , product NEW_LINE from operator import itemgetter , mul NEW_LINE from copy import deepcopy NEW_LINE from string import ascii_lowercase , ascii_uppercase , digits NEW_LINE def input ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def INT ( ) : return int ( input ( ) ) NEW_LINE def MAP ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE INF = float ( ' inf ' ) NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE W , H , N = MAP ( ) NEW_LINE xya = [ LIST ( ) for _ in range ( N ) ] NEW_LINE right = W NEW_LINE left = 0 NEW_LINE top = H NEW_LINE bottom = 0 NEW_LINE for x , y , a in xya : NEW_LINE INDENT if a == 1 and left < x < right : NEW_LINE INDENT left = x NEW_LINE DEDENT elif a == 1 and right <= x : NEW_LINE INDENT S = 0 NEW_LINE break NEW_LINE DEDENT elif a == 2 and left < x < right : NEW_LINE INDENT right = x NEW_LINE DEDENT elif a == 2 and x <= left : NEW_LINE INDENT S = 0 NEW_LINE break NEW_LINE DEDENT elif a == 3 and bottom < y < top : NEW_LINE INDENT bottom = y NEW_LINE DEDENT elif a == 3 and top <= y : NEW_LINE INDENT S = 0 NEW_LINE break NEW_LINE DEDENT elif a == 4 and bottom < y < top : NEW_LINE INDENT top = y NEW_LINE DEDENT elif a == 4 and y <= bottom : NEW_LINE INDENT S = 0 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT pass NEW_LINE DEDENT S = ( right - left ) * ( top - bottom ) NEW_LINE DEDENT if S <= 0 : NEW_LINE INDENT S = 0 NEW_LINE DEDENT print ( S ) NEW_LINE","w , h , n = [ int ( i ) for i in input ( ) . split ( ' ▁ ' ) ] NEW_LINE x1 , x2 , y1 , y2 = 0 , w , 0 , h NEW_LINE for i in range ( n ) : NEW_LINE INDENT x , y , a = [ int ( i ) for i in input ( ) . split ( ' ▁ ' ) ] NEW_LINE if a == 1 : NEW_LINE INDENT x1 = max ( x1 , x ) NEW_LINE DEDENT if a == 2 : NEW_LINE INDENT x2 = min ( x2 , x ) NEW_LINE DEDENT if a == 3 : NEW_LINE INDENT y1 = max ( y1 , y ) NEW_LINE DEDENT if a == 4 : NEW_LINE INDENT y2 = min ( y2 , y ) NEW_LINE DEDENT DEDENT if y2 <= y1 or x2 <= x1 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( max ( 0 , ( y2 - y1 ) * ( x2 - x1 ) ) ) NEW_LINE DEDENT"],"bleu":0.1438513813909631,"rouge_l":0.3061569567706842}
{"id":9,"predictions":["s = input ( ) NEW_LINE l = len ( s ) NEW_LINE if l % 2 == 1 : NEW_LINE INDENT print ( \" First \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Second \" ) NEW_LINE DEDENT"],"references":["S = input ( ) NEW_LINE if S [ 0 ] == S [ - 1 ] : NEW_LINE INDENT if len ( S ) % 2 == 0 : NEW_LINE INDENT print ( \" First \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Second \" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if len ( S ) % 2 == 1 : NEW_LINE INDENT print ( \" First \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Second \" ) NEW_LINE DEDENT DEDENT","ar = list ( input ( ) ) NEW_LINE b = 0 NEW_LINE while True : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , len ( ar ) - 1 ) : NEW_LINE INDENT if ar [ i - 1 ] != ar [ i + 1 ] : NEW_LINE INDENT count += 1 NEW_LINE del ar [ i ] NEW_LINE b += 1 NEW_LINE break NEW_LINE DEDENT DEDENT if count == 0 : NEW_LINE INDENT if b % 2 == 1 : NEW_LINE INDENT print ( \" First \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Second \" ) NEW_LINE DEDENT break NEW_LINE DEDENT DEDENT","s = input ( ) ; print ( [ ' Second ' , ' First ' ] [ ( len ( s ) + ( s [ 0 ] == s [ - 1 ] ) ) % 2 ] ) NEW_LINE"],"bleu":0.8367273811895829,"rouge_l":0.5295178119404828}
{"id":10,"predictions":["import sys NEW_LINE ns = lambda : sys . stdin . readline ( ) . rstrip ( ) NEW_LINE ni = lambda : int ( ns ( ) ) NEW_LINE nm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE nl = lambda : list ( nm ( ) ) NEW_LINE s = list ( ns ( ) ) NEW_LINE c = collections . Counter ( s ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += s [ i ] NEW_LINE DEDENT print ( ans ) NEW_LINE"],"references":["print ( ( lambda S : sum ( eval ( ' ' . join ( ' ' . join ( i ) for i in zip ( S , ( [ ' ' , ' + ' ] [ int ( i ) ] for i in ' { :0 > { } b } 0' . format ( i , len ( S ) - 1 ) ) ) ) ) for i in range ( 1 << len ( S ) - 1 ) ) ) ( input ( ) ) ) NEW_LINE","import numpy as np NEW_LINE S = str ( input ( ) ) NEW_LINE N = len ( S ) - 1 NEW_LINE def honyaku ( ini , n ) : NEW_LINE INDENT ans = np . zeros ( n ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT ans [ i ] = ini % 2 NEW_LINE ini = ini \/\/ 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT def sum_list ( list_domain , list_S ) : NEW_LINE INDENT tmp = list_S [ 0 ] NEW_LINE ans = 0 NEW_LINE for i in range ( len ( list_domain ) ) : NEW_LINE INDENT if list_domain [ i ] == 0 : NEW_LINE INDENT tmp = tmp * 10 + list_S [ i + 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT ans += tmp NEW_LINE tmp = list_S [ i + 1 ] NEW_LINE DEDENT DEDENT return tmp + ans NEW_LINE DEDENT list_S = np . zeros ( N + 1 ) NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT list_S [ i ] = int ( S [ i ] ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 2 ** N ) : NEW_LINE INDENT list_domain = honyaku ( i , N ) NEW_LINE ans += sum_list ( list_domain , list_S ) NEW_LINE DEDENT print ( int ( ans ) ) NEW_LINE","ans = 0 NEW_LINE def dfs ( x , len_x , i = 0 ) : NEW_LINE INDENT global ans NEW_LINE if i < len_x : NEW_LINE INDENT dfs ( x , len_x , i = i + 1 ) NEW_LINE DEDENT if i < len_x : NEW_LINE INDENT x = x [ : i + 1 ] + \" + \" + x [ i + 1 : ] NEW_LINE dfs ( x , len_x + 1 , i = i + 2 ) NEW_LINE ans += sum ( [ int ( k ) for k in x . split ( \" + \" ) ] ) NEW_LINE DEDENT if i == len_x : NEW_LINE INDENT return sum ( [ int ( k ) for k in x . split ( \" + \" ) ] ) NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT s = input ( ) NEW_LINE dfs ( s , len ( s ) - 1 ) NEW_LINE print ( ans + int ( s ) ) NEW_LINE"],"bleu":0.330318049750424,"rouge_l":0.3700089903308075}
{"id":11,"predictions":["def gcd ( a , b ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return gcd NEW_LINE DEDENT DEDENT n , l = map ( int , input ( ) . split ( ) ) NEW_LINE s = gcd ( l , s ) NEW_LINE count = 0 NEW_LINE if n * gcd ( s , n ) == 1 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( n \/\/ gcd ( s , l \/\/ g ) + 1 ) : NEW_LINE INDENT count = gcd ( s , n ) NEW_LINE DEDENT DEDENT"],"references":["N , M = ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE S = input ( ) NEW_LINE T = input ( ) NEW_LINE def gcd ( x , y ) : NEW_LINE INDENT x , y = min ( x , y ) , max ( x , y ) NEW_LINE if y % x == 0 : NEW_LINE INDENT return x NEW_LINE DEDENT return gcd ( x , y % x ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT if S [ 0 ] != T [ 0 ] : NEW_LINE INDENT return - 1 NEW_LINE DEDENT g = gcd ( N , M ) NEW_LINE n = N \/\/ g NEW_LINE m = M \/\/ g NEW_LINE for i in range ( g ) : NEW_LINE INDENT if S [ n * i ] != T [ m * i ] : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT return N * M \/\/ g NEW_LINE DEDENT print ( main ( ) ) NEW_LINE","def main28 ( ) : NEW_LINE INDENT import sys NEW_LINE N , M = ( int ( x ) for x in input ( ) . split ( ) ) NEW_LINE if N >= M : NEW_LINE INDENT S = input ( ) NEW_LINE T = input ( ) NEW_LINE DEDENT else : NEW_LINE INDENT T = input ( ) NEW_LINE S = input ( ) NEW_LINE DEDENT def lcm ( n , m ) : NEW_LINE INDENT gcd = 0 NEW_LINE for i in range ( 1 , min ( n , m ) + 1 ) : NEW_LINE INDENT if n % i == 0 and m % i == 0 : NEW_LINE INDENT gcd = i NEW_LINE DEDENT DEDENT return int ( n * m \/ gcd ) NEW_LINE DEDENT LCM = lcm ( N , M ) NEW_LINE a = int ( LCM \/ max ( N , M ) ) NEW_LINE b = int ( LCM \/ min ( N , M ) ) NEW_LINE for i in range ( min ( N , M ) ) : NEW_LINE INDENT small_index = i * b NEW_LINE if int ( small_index % a ) == 0 : NEW_LINE INDENT if S [ int ( small_index \/ a ) ] != T [ i ] : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE sys . exit ( ) NEW_LINE DEDENT DEDENT DEDENT print ( LCM ) NEW_LINE DEDENT main28 ( ) NEW_LINE","def gcm ( a , b ) : NEW_LINE INDENT while ( b ) : NEW_LINE INDENT a , b = b , a % b NEW_LINE DEDENT return a NEW_LINE DEDENT def lcm ( a , b ) : NEW_LINE INDENT return int ( a * b \/ gcm ( a , b ) ) NEW_LINE DEDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE s = list ( str ( input ( ) ) ) NEW_LINE t = list ( str ( input ( ) ) ) NEW_LINE s_out = [ ] NEW_LINE t_out = [ ] NEW_LINE for i in range ( int ( gcm ( n , m ) ) ) : NEW_LINE INDENT s_out . append ( s [ i * int ( n \/ gcm ( n , m ) ) ] ) NEW_LINE DEDENT for i in range ( int ( gcm ( n , m ) ) ) : NEW_LINE INDENT t_out . append ( t [ i * int ( m \/ gcm ( n , m ) ) ] ) NEW_LINE DEDENT if ( s_out == t_out ) : print ( lcm ( n , m ) ) NEW_LINE else : print ( - 1 ) NEW_LINE"],"bleu":0.33452336601277854,"rouge_l":0.4161293337071301}
{"id":12,"predictions":["s = input ( ) . split ( ) NEW_LINE a = [ int ( i ) for i in s ] NEW_LINE a . sort ( ) NEW_LINE print ( len ( a ) ) NEW_LINE"],"references":["print ( len ( set ( map ( int , input ( ) . split ( ) ) ) ) ) NEW_LINE","a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if a [ 0 ] != a [ 1 ] and a [ 0 ] != a [ 2 ] and a [ 1 ] != a [ 2 ] : NEW_LINE INDENT print ( 3 ) NEW_LINE DEDENT elif a [ 0 ] == a [ 1 ] and a [ 0 ] != a [ 2 ] : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT elif a [ 0 ] != a [ 1 ] and a [ 0 ] == a [ 2 ] : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT elif a [ 0 ] != a [ 1 ] and a [ 1 ] == a [ 2 ] : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT elif a [ 0 ] == a [ 1 ] == a [ 2 ] : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT","def atcodeer_and_paint_cans ( a : int , b : int , c : int ) -> int : NEW_LINE INDENT return len ( set ( [ a , b , c ] ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE ans = atcodeer_and_paint_cans ( a , b , c ) NEW_LINE print ( ans ) NEW_LINE DEDENT"],"bleu":0.38585688937177753,"rouge_l":0.5834994021522518}
{"id":13,"predictions":["N = input ( ) NEW_LINE print ( N ) NEW_LINE"],"references":["a , b , c = input ( ) . split ( ' , ' ) NEW_LINE print ( a , b , c ) NEW_LINE","s = str ( input ( ) ) NEW_LINE s1 = s [ : 5 ] NEW_LINE s2 = s [ 6 : 13 ] NEW_LINE s3 = s [ 14 : ] NEW_LINE print ( ' { } ▁ { } ▁ { } ' . format ( s1 , s2 , s3 ) ) NEW_LINE","print ( input ( ) . replace ( \" , \" , \" ▁ \" ) ) NEW_LINE"],"bleu":0.2983472132346446,"rouge_l":0.4533443435177539}
{"id":14,"predictions":["a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a < b : NEW_LINE INDENT print ( int ( ( x ) ** 2 \/ 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT"],"references":["x , y = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 1 NEW_LINE a = x NEW_LINE for _ in range ( 61 ) : NEW_LINE INDENT a *= 2 NEW_LINE if a <= y : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE","a , b = map ( int , input ( ) . split ( \" ▁ \" ) ) NEW_LINE count = 0 NEW_LINE while a <= b : NEW_LINE INDENT count += 1 NEW_LINE a *= 2 NEW_LINE DEDENT print ( count ) NEW_LINE","def create_Row ( S , E ) : NEW_LINE INDENT list = [ ] NEW_LINE start = S NEW_LINE while start <= E : NEW_LINE INDENT list . append ( start ) NEW_LINE start += start NEW_LINE DEDENT return list NEW_LINE DEDENT X , Y = map ( int , input ( ) . split ( ) ) NEW_LINE A = len ( create_Row ( X , Y ) ) NEW_LINE print ( A ) NEW_LINE"],"bleu":0.5838020013171389,"rouge_l":0.6308469539375928}
{"id":15,"predictions":["from itertools import accumulate NEW_LINE N , K = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ int ( input ( ) ) for _ in [ 0 ] * N ] NEW_LINE r = 0 NEW_LINE for i , c in enumerate ( a ) : NEW_LINE INDENT if c == K : NEW_LINE INDENT r += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r += K NEW_LINE DEDENT DEDENT print ( r ) NEW_LINE"],"references":["from sys import exit , setrecursionlimit NEW_LINE from itertools import product NEW_LINE def read ( ) : NEW_LINE INDENT return int ( input ( ) ) NEW_LINE DEDENT def reads ( ) : NEW_LINE INDENT return [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE DEDENT def argmin ( ll ) : NEW_LINE INDENT ll = list ( ll ) NEW_LINE return ll . index ( min ( ll ) ) NEW_LINE DEDENT setrecursionlimit ( 1000000 ) NEW_LINE ( N , K ) = reads ( ) NEW_LINE parent = [ x - 1 for x in reads ( ) ] NEW_LINE result = 0 NEW_LINE if parent [ 0 ] != 0 : NEW_LINE INDENT parent [ 0 ] = 0 NEW_LINE result += 1 NEW_LINE DEDENT children = [ [ ] for _ in range ( N ) ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT children [ parent [ i ] ] . append ( i ) NEW_LINE DEDENT color = [ 0 ] * N NEW_LINE def walk ( i ) : NEW_LINE INDENT global result NEW_LINE for x in children [ i ] : NEW_LINE INDENT walk ( x ) NEW_LINE if color [ x ] == 1 and parent [ x ] != 0 : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT color [ i ] = min ( [ K ] + [ color [ x ] - 1 for x in children [ i ] if color [ x ] >= 2 ] ) NEW_LINE DEDENT walk ( 0 ) NEW_LINE print ( result ) NEW_LINE","import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE inf = 10 ** 20 NEW_LINE eps = 1.0 \/ 10 ** 15 NEW_LINE mod = 10 ** 9 + 7 NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def F ( ) : return float ( sys . stdin . readline ( ) ) NEW_LINE def S ( ) : return input ( ) NEW_LINE def pf ( s ) : return print ( s , flush = True ) NEW_LINE def main ( ) : NEW_LINE INDENT n , k = LI ( ) NEW_LINE a = LI_ ( ) NEW_LINE r = 0 NEW_LINE if a [ 0 ] != 0 : NEW_LINE INDENT r += 1 NEW_LINE DEDENT e = collections . defaultdict ( set ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT e [ a [ i ] ] . add ( i ) NEW_LINE DEDENT def f ( i , p ) : NEW_LINE INDENT m = 0 NEW_LINE r = 0 NEW_LINE for c in e [ i ] : NEW_LINE INDENT ct , cr = f ( c , i ) NEW_LINE r += cr NEW_LINE if ct > m : NEW_LINE INDENT m = ct NEW_LINE DEDENT DEDENT if ( m == k - 1 and p != 0 ) or ( m == k and p == 0 ) : NEW_LINE INDENT r += 1 NEW_LINE m = - 1 NEW_LINE DEDENT return ( m + 1 , r ) NEW_LINE DEDENT for c in e [ 0 ] : NEW_LINE INDENT m , t = f ( c , 0 ) NEW_LINE r += t NEW_LINE DEDENT return r NEW_LINE DEDENT print ( main ( ) ) NEW_LINE","import sys NEW_LINE sys . setrecursionlimit ( 200000 ) NEW_LINE n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE if a [ 0 ] != 1 : NEW_LINE INDENT a [ 0 ] = 1 NEW_LINE ans += 1 NEW_LINE DEDENT b = [ [ ] for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT b [ a [ i ] - 1 ] . append ( i ) NEW_LINE DEDENT b [ 0 ] . remove ( 0 ) NEW_LINE huka = 0 NEW_LINE kyo = [ float ( \" inf \" ) ] * n NEW_LINE def dfs ( x , y ) : NEW_LINE INDENT kyo [ x ] = y NEW_LINE for i in b [ x ] : NEW_LINE INDENT dfs ( i , y + 1 ) NEW_LINE DEDENT DEDENT dfs ( 0 , 0 ) NEW_LINE def dfs2 ( x , y ) : NEW_LINE INDENT if kyo [ x ] <= k - y : NEW_LINE INDENT return NEW_LINE DEDENT if y == k - 1 and x != 0 : NEW_LINE INDENT kyo [ x ] = 0 NEW_LINE global ans NEW_LINE ans += 1 NEW_LINE return NEW_LINE DEDENT kyo [ x ] = 0 NEW_LINE dfs2 ( a [ x ] - 1 , y + 1 ) NEW_LINE DEDENT hukai = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT hukai . append ( [ kyo [ i ] , i ] ) NEW_LINE DEDENT hukai . sort ( key = lambda x : - x [ 0 ] ) NEW_LINE for j , i in hukai : NEW_LINE INDENT if j <= k : NEW_LINE INDENT continue NEW_LINE DEDENT dfs2 ( i , 0 ) NEW_LINE DEDENT print ( ans ) NEW_LINE"],"bleu":0.06152453180043249,"rouge_l":0.2717035044961762}
{"id":16,"predictions":["import math NEW_LINE import numpy as np NEW_LINE import copy NEW_LINE from collections import defaultdict , Counter NEW_LINE from itertools import product NEW_LINE from bisect import bisect_left , bisect_right NEW_LINE def s_inpl ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE def inpl ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE N , M , Q = s_inpl ( ) NEW_LINE l = [ ] NEW_LINE for _ in range ( M ) : NEW_LINE INDENT l , r = s_inpl ( ) NEW_LINE for i in range ( Q ) : NEW_LINE INDENT l1 , r2 = s_inpl ( ) NEW_LINE r2 = s_inpl ( ) NEW_LINE l2 , r2 = s_inpl ( ) NEW_LINE for s in l2 : NEW_LINE INDENT c += s [ r2 ] [ l3 ] += s NEW_LINE DEDENT DEDENT Q -= 1 NEW_LINE ans = [ 0 ] * Q NEW_LINE for _ in range ( Q ) : NEW_LINE INDENT x , y = s_inpl ( ) NEW_LINE print ( ans [ x ] [ y ] ) NEW_LINE DEDENT DEDENT"],"references":["from itertools import accumulate NEW_LINE N , M , Q = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ [ 0 ] * ( N + 1 ) for i in range ( N + 1 ) ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT L , R = map ( int , input ( ) . split ( ) ) NEW_LINE a [ L ] [ R ] += 1 NEW_LINE DEDENT b = [ list ( accumulate ( a [ i ] ) ) for i in range ( N + 1 ) ] NEW_LINE k = [ [ b [ j ] [ i ] for j in range ( i + 1 ) ] for i in range ( N + 1 ) ] NEW_LINE ans = [ list ( accumulate ( reversed ( k [ i ] ) ) ) [ : : - 1 ] for i in range ( N + 1 ) ] NEW_LINE for i in range ( Q ) : NEW_LINE INDENT p , q = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ans [ q ] [ p - q - 1 ] ) NEW_LINE DEDENT","from collections import Counter NEW_LINE from functools import lru_cache NEW_LINE import sys NEW_LINE sys . setrecursionlimit ( 2 * 10 ** 5 ) NEW_LINE N , M , Q = map ( int , input ( ) . split ( ) ) NEW_LINE L , R = zip ( * ( map ( int , input ( ) . split ( ) ) for _ in range ( M ) ) ) NEW_LINE p , q = zip ( * ( map ( int , input ( ) . split ( ) ) for _ in range ( Q ) ) ) NEW_LINE c = Counter ( zip ( L , R ) ) NEW_LINE @ lru_cache ( maxsize = None ) NEW_LINE def f ( x , y ) : NEW_LINE INDENT return ( 0 if x > y else c [ x , y ] + f ( x + 1 , y ) + f ( x , y - 1 ) - f ( x + 1 , y - 1 ) ) NEW_LINE DEDENT ans = ' \\n ' . join ( map ( str , ( f ( x , y ) for x , y in zip ( p , q ) ) ) ) NEW_LINE print ( ans ) NEW_LINE","n , m , q = [ int ( item ) for item in input ( ) . split ( ) ] NEW_LINE lr = [ [ int ( item ) for item in input ( ) . split ( ) ] for _ in range ( m ) ] NEW_LINE pq = [ [ int ( item ) for item in input ( ) . split ( ) ] for _ in range ( q ) ] NEW_LINE field = [ [ 0 ] * ( n + 1 ) for _ in range ( n + 1 ) ] NEW_LINE cumsum = [ [ 0 ] * ( n + 1 ) for _ in range ( n + 1 ) ] NEW_LINE for item in lr : NEW_LINE INDENT field [ item [ 0 ] ] [ item [ 1 ] ] += 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT cumsum [ i ] [ j ] = field [ i ] [ j ] + cumsum [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT cumsum [ i ] [ j ] += cumsum [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT for p , q in pq : NEW_LINE INDENT print ( cumsum [ q ] [ q ] - cumsum [ p - 1 ] [ q ] - cumsum [ q ] [ p - 1 ] + cumsum [ p - 1 ] [ p - 1 ] ) NEW_LINE DEDENT"],"bleu":0.4024610336894743,"rouge_l":0.4273038605230386}
{"id":17,"predictions":["n , m , x = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE a = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE b = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE print ( min ( b ) ) NEW_LINE"],"references":["N , M , X = ( int ( x ) for x in input ( ) . split ( ) ) NEW_LINE A = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE Z = [ 0 ] * N NEW_LINE for a in A : NEW_LINE INDENT Z [ a ] = 1 NEW_LINE DEDENT lower = 0 NEW_LINE for i in range ( 0 , X + 1 ) : NEW_LINE INDENT lower += Z [ i ] NEW_LINE DEDENT higher = 0 NEW_LINE for i in range ( X , N ) : NEW_LINE INDENT higher += Z [ i ] NEW_LINE DEDENT print ( min ( lower , higher ) ) NEW_LINE","N , M , X = map ( int , input ( ) . split ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE cnt = 0 NEW_LINE min = 0 NEW_LINE cnt_2 = 0 NEW_LINE lists = list ( range ( N + 1 ) ) NEW_LINE for i in range ( X , N + 1 ) : NEW_LINE INDENT for j in range ( len ( A ) ) : NEW_LINE INDENT if i == 0 or i == N or i == X : NEW_LINE INDENT continue NEW_LINE DEDENT elif i == A [ j ] : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT for m in range ( X , - 1 , - 1 ) : NEW_LINE INDENT for n in range ( len ( A ) ) : NEW_LINE INDENT if m == 0 or m == N or m == X : NEW_LINE INDENT continue NEW_LINE DEDENT elif m == A [ n ] : NEW_LINE INDENT cnt_2 += 1 NEW_LINE DEDENT DEDENT DEDENT if cnt > cnt_2 : NEW_LINE INDENT min = cnt_2 NEW_LINE DEDENT elif cnt_2 > cnt : NEW_LINE INDENT min = cnt NEW_LINE DEDENT print ( min ) NEW_LINE","N , M , X = map ( int , input ( ) . strip ( ) . split ( ) ) NEW_LINE As = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) NEW_LINE left = list ( filter ( lambda x : x < X , As ) ) NEW_LINE right = list ( filter ( lambda x : x > X , As ) ) NEW_LINE print ( min ( len ( left ) , len ( right ) ) ) NEW_LINE"],"bleu":0.31341086187164924,"rouge_l":0.48995983935742965}
{"id":18,"predictions":["from collections import deque NEW_LINE def inpl ( ) : return [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE N = int ( input ( ) ) NEW_LINE edges = [ [ ] for _ in range ( N ) ] NEW_LINE for _ in range ( N - 1 ) : NEW_LINE INDENT a , b = inpl ( ) NEW_LINE v -= 1 NEW_LINE edges [ b ] . append ( ( a , b ) ) NEW_LINE edges [ a ] . append ( ( b , a ) ) NEW_LINE DEDENT visited = [ False ] * N NEW_LINE Q = [ N ] * N NEW_LINE val = 0 NEW_LINE while Q : NEW_LINE INDENT v , l = map ( int , input ( ) . split ( ) ) NEW_LINE used [ v ] = [ False ] * N NEW_LINE for u , v in edges [ v ] : NEW_LINE INDENT if used [ u ] > v : NEW_LINE INDENT used [ v ] = True NEW_LINE DEDENT else : NEW_LINE INDENT used [ v ] = True NEW_LINE visited [ v ] = True NEW_LINE DEDENT if not used [ u ] : NEW_LINE INDENT used [ v ] = True NEW_LINE DEDENT DEDENT for u , v in edges : NEW_LINE INDENT if not used [ v ] : NEW_LINE INDENT d [ v ] = True NEW_LINE break NEW_LINE DEDENT DEDENT if not used [ v ] : NEW_LINE INDENT dfs ( v , v ) NEW_LINE DEDENT DEDENT print ( max ( dfs ( s ) ) NEW_LINE"],"references":["import sys NEW_LINE from collections import deque NEW_LINE def dfs ( edges , start ) : NEW_LINE INDENT visited = [ 0 ] * len ( edges ) NEW_LINE visited [ start ] = 1 NEW_LINE ans , dist = 0 , 0 NEW_LINE stack = deque ( [ ( start , 0 ) ] ) NEW_LINE pop , append = stack . pop , stack . append NEW_LINE while stack : NEW_LINE INDENT v , _dist = pop ( ) NEW_LINE if _dist > dist : NEW_LINE INDENT ans , dist = v , _dist NEW_LINE DEDENT for e in edges [ v ] : NEW_LINE INDENT if visited [ e ] : NEW_LINE INDENT continue NEW_LINE DEDENT visited [ e ] = 1 NEW_LINE append ( ( e , _dist + 1 ) ) NEW_LINE DEDENT DEDENT return ans , dist NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE edges = [ [ ] for _ in [ 0 ] * N ] NEW_LINE for ( a , b ) in ( map ( int , l . split ( ) ) for l in sys . stdin ) : NEW_LINE INDENT edges [ a - 1 ] . append ( b - 1 ) NEW_LINE edges [ b - 1 ] . append ( a - 1 ) NEW_LINE DEDENT v , _ = dfs ( edges , 0 ) NEW_LINE print ( v + 1 , dfs ( edges , v ) [ 0 ] + 1 ) NEW_LINE DEDENT","from collections import defaultdict NEW_LINE import sys NEW_LINE sys . setrecursionlimit ( 10 ** 6 ) NEW_LINE def dfs ( i , g , dist ) : NEW_LINE INDENT for node in g [ i ] : NEW_LINE INDENT if dist [ node ] is None : NEW_LINE INDENT dist [ node ] = dist [ i ] + 1 NEW_LINE dfs ( node , g , dist ) NEW_LINE DEDENT DEDENT DEDENT def main ( ) : NEW_LINE INDENT g = defaultdict ( list ) NEW_LINE N = int ( input ( ) ) NEW_LINE for _ in range ( N - 1 ) : NEW_LINE INDENT A , B = map ( int , input ( ) . split ( ) ) NEW_LINE g [ A ] . append ( B ) NEW_LINE g [ B ] . append ( A ) NEW_LINE DEDENT dist = [ None ] * ( N + 1 ) NEW_LINE dist [ 0 ] = - 1 NEW_LINE dist [ 1 ] = 0 NEW_LINE dfs ( 1 , g , dist ) NEW_LINE ans1 = dist . index ( max ( dist ) ) NEW_LINE dist = [ None ] * ( N + 1 ) NEW_LINE dist [ 0 ] = - 1 NEW_LINE dist [ ans1 ] = 0 NEW_LINE dfs ( ans1 , g , dist ) NEW_LINE ans2 = dist . index ( max ( dist ) ) NEW_LINE print ( ans1 , ans2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT","from heapq import heappush , heappop NEW_LINE def dijkstra ( num , start ) : NEW_LINE INDENT dist = [ float ( \" inf \" ) for i in range ( num ) ] NEW_LINE dist [ start ] = 0 NEW_LINE q = [ [ dist [ start ] , start ] ] NEW_LINE while q : NEW_LINE INDENT du , u = heappop ( q ) NEW_LINE for j , k in adj [ u ] : NEW_LINE INDENT if dist [ j ] > du + k : NEW_LINE INDENT dist [ j ] = du + k NEW_LINE heappush ( q , [ dist [ j ] , j ] ) NEW_LINE DEDENT DEDENT DEDENT return dist NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE adj = [ [ ] for i in range ( n ) ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE a -= 1 NEW_LINE b -= 1 NEW_LINE adj [ a ] . append ( [ b , 1 ] ) NEW_LINE adj [ b ] . append ( [ a , 1 ] ) NEW_LINE DEDENT di = dijkstra ( n , 0 ) NEW_LINE ma = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if di [ i ] > di [ ma ] : NEW_LINE INDENT ma = i NEW_LINE DEDENT DEDENT dis = dijkstra ( n , ma ) NEW_LINE mi = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if dis [ i ] > dis [ mi ] : NEW_LINE INDENT mi = i NEW_LINE DEDENT DEDENT print ( ma + 1 , mi + 1 ) NEW_LINE"],"bleu":0.47055326292134286,"rouge_l":0.41168335453891686}
{"id":19,"predictions":["def gcd ( a , b , c ) : if b == 0 : return a , b , c = map ( int , input ( ) . split ( ) ) if a % b == 0 : print ( \" YES \" ) else : print ( \" NO \" )   NEW_LINE"],"references":["T = int ( input ( ) ) NEW_LINE ABCD = [ [ int ( _ ) for _ in input ( ) . split ( ) ] for _ in range ( T ) ] NEW_LINE def gcd ( x , y ) : NEW_LINE INDENT if x < y : NEW_LINE INDENT return gcd ( y , x ) NEW_LINE DEDENT elif x % y == 0 : NEW_LINE INDENT return y NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( y , x % y ) NEW_LINE DEDENT DEDENT for a , b , c , d in ABCD : NEW_LINE INDENT if a < b or d < b : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT else : NEW_LINE INDENT g = gcd ( b , d ) NEW_LINE x = g * ( c \/\/ g ) + ( a % g ) NEW_LINE if x <= c : NEW_LINE INDENT x += g NEW_LINE DEDENT if x >= b : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE NEW_LINE DEDENT DEDENT DEDENT","import sys NEW_LINE YES = \" Yes \" NEW_LINE NO = \" No \" NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT if b > a : NEW_LINE INDENT a , b = b , a NEW_LINE DEDENT while b > 0 : NEW_LINE INDENT a , b = b , a % b NEW_LINE DEDENT return a NEW_LINE DEDENT def solve ( T : int , A : \" List [ int ] \" , B : \" List [ int ] \" , C : \" List [ int ] \" , D : \" List [ int ] \" ) : NEW_LINE INDENT for i in range ( T ) : NEW_LINE INDENT a , b , c , d = A [ i ] , B [ i ] , C [ i ] , D [ i ] NEW_LINE if a < b or b > d : NEW_LINE INDENT print ( ' No ' ) NEW_LINE continue NEW_LINE DEDENT x = ( c - a + 1 ) % b NEW_LINE g = gcd ( b , d ) NEW_LINE print ( ' No ' if - ( - x \/\/ g * g ) - x + c + 1 < b else ' Yes ' ) NEW_LINE DEDENT return NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT def iterate_tokens ( ) : NEW_LINE INDENT for line in sys . stdin : NEW_LINE INDENT for word in line . split ( ) : NEW_LINE INDENT yield word NEW_LINE DEDENT DEDENT DEDENT tokens = iterate_tokens ( ) NEW_LINE T = int ( next ( tokens ) ) NEW_LINE A = [ int ( ) ] * ( T ) NEW_LINE B = [ int ( ) ] * ( T ) NEW_LINE C = [ int ( ) ] * ( T ) NEW_LINE D = [ int ( ) ] * ( T ) NEW_LINE for i in range ( T ) : NEW_LINE INDENT A [ i ] = int ( next ( tokens ) ) NEW_LINE B [ i ] = int ( next ( tokens ) ) NEW_LINE C [ i ] = int ( next ( tokens ) ) NEW_LINE D [ i ] = int ( next ( tokens ) ) NEW_LINE DEDENT solve ( T , A , B , C , D ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT","def g ( a , b ) : NEW_LINE INDENT if a % b == 0 : return b NEW_LINE return g ( b , a % b ) NEW_LINE DEDENT def f ( a , b , c , d ) : NEW_LINE INDENT yes = \" Yes \" NEW_LINE no = \" No \" NEW_LINE if a < b or d < b : return no NEW_LINE if c >= b or a <= c : return yes NEW_LINE if ( a - c ) % b > 0 and ( a - c ) % b < b - c : return no NEW_LINE e = d % b NEW_LINE if e == 0 or b - c == 1 : return yes NEW_LINE if e == 1 : return no NEW_LINE h = g ( b , e ) NEW_LINE if h < b - c : return no NEW_LINE if ( a - c ) % h > 0 and ( a - c ) % h < b - c : return no NEW_LINE return yes NEW_LINE DEDENT t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE ans = f ( a , b , c , d ) NEW_LINE print ( ans ) NEW_LINE DEDENT"],"bleu":0.05226991561751912,"rouge_l":0.2582596204732744}
{"id":20,"predictions":["k = int ( input ( ) ) NEW_LINE k = int ( input ( ) ) NEW_LINE if k == 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 2 * k \/\/ 4 ) : NEW_LINE INDENT print ( 1 , end = \" ▁ \" ) NEW_LINE DEDENT for i in range ( k - 1 , 2 * n + 1 ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT for j in range ( k - k + 1 ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE"],"references":["import math NEW_LINE k = int ( input ( ) ) NEW_LINE if k == 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE print ( 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT n = math . ceil ( k \/ 4 ) * 2 NEW_LINE ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT tmp = [ ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT tmp . append ( ( i + j ) % n + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT tmp . append ( n + ( i + j ) % n + 1 ) NEW_LINE DEDENT DEDENT ans . append ( tmp ) NEW_LINE DEDENT kazu = n * 2 NEW_LINE while kazu != k : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ans [ i ] [ j ] == kazu : NEW_LINE INDENT ans [ i ] [ j ] -= n NEW_LINE DEDENT DEDENT DEDENT kazu -= 1 NEW_LINE DEDENT print ( n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( * ans [ i ] ) NEW_LINE DEDENT","K = int ( input ( ) ) NEW_LINE n = 0 NEW_LINE n1 = 0 NEW_LINE n2 = 0 NEW_LINE n3 = 0 NEW_LINE n4 = 0 NEW_LINE n5 = 0 NEW_LINE if K <= 499 : NEW_LINE INDENT n = K NEW_LINE mat = [ [ 0 for n1 in range ( K ) ] for n2 in range ( K ) ] NEW_LINE for n1 in range ( K ) : NEW_LINE INDENT for n2 in range ( K - n1 ) : NEW_LINE INDENT mat [ n1 ] [ n1 + n2 ] = n2 + 1 NEW_LINE DEDENT DEDENT for n1 in range ( K ) : NEW_LINE INDENT for n2 in range ( n1 ) : NEW_LINE INDENT mat [ n1 ] [ n2 ] = K + n2 - n1 + 1 NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT n = 500 NEW_LINE mat = [ [ 0 for n1 in range ( 500 ) ] for n2 in range ( 500 ) ] NEW_LINE for n1 in range ( 500 ) : NEW_LINE INDENT for n2 in range ( 500 - n1 ) : NEW_LINE INDENT mat [ n1 ] [ n1 + n2 ] = n2 + 1 NEW_LINE DEDENT DEDENT for n1 in range ( 500 ) : NEW_LINE INDENT for n2 in range ( n1 ) : NEW_LINE INDENT mat [ n1 ] [ n2 ] = 500 + n2 - n1 + 1 NEW_LINE DEDENT DEDENT for n2 in range ( K - 500 ) : NEW_LINE INDENT for n1 in range ( 250 ) : NEW_LINE INDENT kari = n1 * 2 + n2 NEW_LINE if kari >= 500 : NEW_LINE INDENT kari = kari - 500 NEW_LINE DEDENT mat [ n1 * 2 ] [ kari ] = n2 + 501 NEW_LINE DEDENT DEDENT DEDENT print ( n ) NEW_LINE if K <= 500 : NEW_LINE INDENT out = \" \" NEW_LINE for n1 in range ( K ) : NEW_LINE INDENT out = \" \" NEW_LINE for n2 in range ( K ) : NEW_LINE INDENT out = out + \" ▁ \" + str ( mat [ n1 ] [ n2 ] ) NEW_LINE DEDENT print ( out ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT out = \" \" NEW_LINE for n1 in range ( 500 ) : NEW_LINE INDENT out = \" \" NEW_LINE for n2 in range ( 500 ) : NEW_LINE INDENT out = out + \" ▁ \" + str ( mat [ n1 ] [ n2 ] ) NEW_LINE DEDENT print ( out ) NEW_LINE DEDENT DEDENT","def run ( K ) : NEW_LINE INDENT n_max = 500 NEW_LINE n = 0 NEW_LINE trouts = [ ] NEW_LINE if K <= n_max : NEW_LINE INDENT n = K NEW_LINE for i in range ( K ) : NEW_LINE INDENT trouts . append ( [ i + 1 ] * K ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT n = n_max NEW_LINE change = n_max * 2 - K NEW_LINE c1 = [ i for i in range ( 1 , n_max + 1 ) ] NEW_LINE c2 = [ i for i in range ( 2 , change + 1 ) ] + [ i for i in range ( n_max + 1 , n_max * 2 + 1 - change ) ] NEW_LINE if change > 0 : NEW_LINE INDENT c2 += [ 1 ] NEW_LINE DEDENT for i in range ( n_max ) : NEW_LINE INDENT shift = ( i \/\/ 2 ) * 2 NEW_LINE if i % 2 == 0 : NEW_LINE INDENT trouts . append ( c1 [ shift : ] + c1 [ : shift ] ) NEW_LINE DEDENT else : NEW_LINE INDENT trouts . append ( c2 [ shift : ] + c2 [ : shift ] ) NEW_LINE DEDENT DEDENT DEDENT return ( n , trouts ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT K = int ( input ( ) ) NEW_LINE n , trouts = run ( K ) NEW_LINE print ( n ) NEW_LINE for i in range ( len ( trouts ) ) : NEW_LINE INDENT print ( ' ▁ ' . join ( map ( str , trouts [ i ] ) ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"bleu":0.28915353233301566,"rouge_l":0.4185032474022476}
{"id":21,"predictions":["n = int ( input ( ) ) poles = [ ] for i in range ( n ) : poles . append ( input ( ) ) num_groups = 1 for i in range ( n - 1 ) : if not int ( poles [ i ] [ 1 ] ) ^ int ( poles [ i + 1 ] [ 0 ] ) : num_groups += 1 print ( num_groups ) NEW_LINE"],"references":["n = int ( input ( ) ) NEW_LINE a = [ int ( input ( ) ) for i in range ( n ) ] NEW_LINE b = list ( set ( a ) ) NEW_LINE print ( len ( a ) - len ( b ) ) NEW_LINE","N = int ( input ( ) ) NEW_LINE already = set ( ) NEW_LINE count = 0 NEW_LINE for n in range ( N ) : NEW_LINE INDENT A = input ( ) NEW_LINE if A in already : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT already . add ( A ) NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE","import collections NEW_LINE n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT a . append ( int ( input ( ) ) ) NEW_LINE DEDENT l = collections . Counter ( a ) NEW_LINE b = 0 NEW_LINE for k in l . keys ( ) : NEW_LINE INDENT if l [ k ] >= 2 : NEW_LINE INDENT b += l [ k ] - 1 NEW_LINE DEDENT DEDENT print ( b ) NEW_LINE"],"bleu":0.3271876789241303,"rouge_l":0.565859176906573}
{"id":22,"predictions":["import bisect NEW_LINE N = int ( input ( ) ) NEW_LINE S = [ ] NEW_LINE for p in range ( N ) : NEW_LINE INDENT S . append ( input ( ) ) NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( i , N ) : NEW_LINE INDENT if S [ j ] > T [ i ] : NEW_LINE INDENT DEDENT DEDENT DEDENT print ( max ( S ) , min ( S ) ) NEW_LINE"],"references":["def main ( ) : NEW_LINE INDENT n = input ( ) NEW_LINE a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE ai = max ( a ) NEW_LINE a . remove ( ai ) NEW_LINE aj = float ( ' inf ' ) NEW_LINE tmp = float ( ' inf ' ) NEW_LINE for aa in a : NEW_LINE INDENT diff = abs ( ai \/ 2 - aa ) NEW_LINE if diff < tmp : NEW_LINE INDENT tmp = diff NEW_LINE aj = aa NEW_LINE DEDENT DEDENT print ( ai , aj ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT","def upperbound ( zs , left , right , ok ) : NEW_LINE INDENT if left + 1 >= right : NEW_LINE INDENT return left NEW_LINE DEDENT m = ( left + right ) \/\/ 2 NEW_LINE if ok ( zs [ m ] ) : NEW_LINE INDENT return upperbound ( zs , m , right , ok ) NEW_LINE DEDENT else : NEW_LINE INDENT return upperbound ( zs , left , m , ok ) NEW_LINE DEDENT DEDENT n = int ( input ( ) ) NEW_LINE xs = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ds = sorted ( xs ) NEW_LINE a = ds [ - 1 ] NEW_LINE c = a \/ 2 NEW_LINE zs = [ d - c for d in ds [ : - 1 ] ] NEW_LINE i = upperbound ( zs , 0 , len ( zs ) - 1 , lambda z : z <= 0 ) NEW_LINE j = i + 1 if i < len ( zs ) - 1 else i NEW_LINE b = ds [ i ] if abs ( zs [ i ] ) < abs ( zs [ j ] ) else ds [ j ] NEW_LINE print ( a , b ) NEW_LINE","import math NEW_LINE N = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE A . sort ( ) NEW_LINE def combinations_count ( n , r ) : NEW_LINE INDENT return math . factorial ( n ) \/\/ ( math . factorial ( n - r ) * math . factorial ( r ) ) NEW_LINE DEDENT if len ( A ) == 2 : NEW_LINE INDENT print ( A [ 1 ] ) NEW_LINE print ( A [ 0 ] ) NEW_LINE DEDENT half = A [ - 1 ] \/ 2 NEW_LINE for i in range ( N - 2 ) : NEW_LINE INDENT if abs ( A [ i ] - half ) >= abs ( A [ i + 1 ] - half ) <= abs ( A [ i + 2 ] - half ) : NEW_LINE INDENT print ( A [ - 1 ] ) NEW_LINE print ( A [ i + 1 ] ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT"],"bleu":0.2670439196416234,"rouge_l":0.3783535137701805}
{"id":23,"predictions":["N , M = map ( int , input ( ) . split ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT l . append ( int ( input ( ) ) ) NEW_LINE DEDENT l . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( M - 1 ) : NEW_LINE INDENT ans += l [ i + 1 ] - l [ i ] NEW_LINE DEDENT print ( ans ) NEW_LINE"],"references":["N , M = map ( int , input ( ) . split ( ) ) NEW_LINE zahyo = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE zahyo . sort ( ) NEW_LINE sa = [ 0 for _ in range ( M - 1 ) ] NEW_LINE for i in range ( M - 1 ) : NEW_LINE INDENT sa [ i ] = zahyo [ i + 1 ] - zahyo [ i ] NEW_LINE DEDENT sa . sort ( reverse = True ) NEW_LINE sa = sa [ N - 1 : ] NEW_LINE print ( sum ( sa ) ) NEW_LINE","import sys NEW_LINE def solve ( N : int , M : int , X : \" List [ int ] \" ) : NEW_LINE INDENT if N >= M : NEW_LINE INDENT print ( 0 ) NEW_LINE return NEW_LINE DEDENT X . sort ( ) NEW_LINE dist = [ ] NEW_LINE for i in range ( 1 , len ( X ) ) : NEW_LINE INDENT dist . append ( abs ( X [ i ] - X [ i - 1 ] ) ) NEW_LINE DEDENT distIndices = [ ( dist [ i ] , i ) for i in range ( len ( dist ) ) ] NEW_LINE distIndices . sort ( reverse = True ) NEW_LINE splitIndex = [ ] NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT splitIndex . append ( distIndices [ i ] [ 1 ] ) NEW_LINE DEDENT splitIndex . sort ( ) NEW_LINE ranges = [ ] NEW_LINE begin = 0 NEW_LINE for next in splitIndex : NEW_LINE INDENT ranges . append ( X [ begin : next + 1 ] ) NEW_LINE begin = next + 1 NEW_LINE DEDENT ranges . append ( X [ begin : ] ) NEW_LINE cost = 0 NEW_LINE for R in ranges : NEW_LINE INDENT if len ( R ) == 1 : NEW_LINE INDENT continue NEW_LINE DEDENT cost += R [ - 1 ] - R [ 0 ] NEW_LINE DEDENT print ( cost ) NEW_LINE return NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT def iterate_tokens ( ) : NEW_LINE INDENT for line in sys . stdin : NEW_LINE INDENT for word in line . split ( ) : NEW_LINE INDENT yield word NEW_LINE DEDENT DEDENT DEDENT tokens = iterate_tokens ( ) NEW_LINE N = int ( next ( tokens ) ) NEW_LINE M = int ( next ( tokens ) ) NEW_LINE X = [ int ( next ( tokens ) ) for _ in range ( M ) ] NEW_LINE solve ( N , M , X ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT","def gcd_core ( a , b ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return gcd_core ( b , a % b ) NEW_LINE DEDENT DEDENT def gcd ( arr ) : NEW_LINE INDENT g = gcd_core ( arr [ 0 ] , arr [ 1 ] ) NEW_LINE for i in range ( 2 , len ( arr ) ) : NEW_LINE INDENT g = gcd_core ( g , arr [ i ] ) NEW_LINE DEDENT return g NEW_LINE DEDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE arr . sort ( ) NEW_LINE temp = [ ] NEW_LINE for i in range ( m - 1 ) : NEW_LINE INDENT temp . append ( arr [ i + 1 ] - arr [ i ] ) NEW_LINE DEDENT temp . sort ( ) NEW_LINE temp [ : : - 1 ] NEW_LINE ans = 0 NEW_LINE for i in range ( m - n ) : NEW_LINE INDENT ans += temp [ i ] NEW_LINE DEDENT print ( ans ) NEW_LINE"],"bleu":0.5839952186867874,"rouge_l":0.6156986500363163}
{"id":24,"predictions":["import sys NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE input = sys . stdin . readline NEW_LINE a , b , k = map ( int , input ( ) . split ( ) ) NEW_LINE x = ( int ( input ( ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( a + b + 1 ) : NEW_LINE INDENT if k % i == 0 : NEW_LINE INDENT ans = min ( ans , a * b * k \/\/ i ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["import sys NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE input = sys . stdin . readline NEW_LINE A , B , K , L = map ( int , input ( ) . split ( ) ) NEW_LINE s = K \/\/ L NEW_LINE print ( min ( K * A , s * B + ( K - s * L ) * A , ( s + 1 ) * B ) ) NEW_LINE","def main ( ) : NEW_LINE INDENT a , b , k , l = map ( int , input ( ) . split ( ) ) NEW_LINE res = min ( a * k , b * ( ( k - 1 ) \/\/ l + 1 ) , b * ( k \/\/ l ) + a * ( k % l ) ) NEW_LINE print ( res ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT","a , b , k , l = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE ans = b * ( k \/\/ l ) NEW_LINE k -= l * ( k \/\/ l ) NEW_LINE if a * k <= b : NEW_LINE INDENT ans += a * k NEW_LINE DEDENT else : NEW_LINE INDENT ans += b NEW_LINE DEDENT print ( ans ) NEW_LINE"],"bleu":0.5816446949573147,"rouge_l":0.5646014355874575}
{"id":25,"predictions":["import sys NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE input = sys . stdin . readline NEW_LINE N = int ( input ( ) ) NEW_LINE A = [ int ( input ( ) for _ in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT A [ i ] = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE DEDENT S = [ 0 ] * ( N + 1 ) NEW_LINE for s in range ( N ) : NEW_LINE INDENT S [ i ] = 0 NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT S [ j ] = A [ i ] NEW_LINE DEDENT DEDENT ans = - 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT S [ i ] = S [ i ] [ j ] NEW_LINE ans = max ( ans , S [ i ] ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["N = input ( ) NEW_LINE L = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def aoki ( i , array ) : NEW_LINE INDENT maxi = - 100000000 NEW_LINE for j in range ( len ( array ) ) : NEW_LINE INDENT tmp = 0 NEW_LINE if j != i : NEW_LINE INDENT if j < i : NEW_LINE INDENT T = array [ j : i + 1 ] NEW_LINE DEDENT elif j > i : NEW_LINE INDENT T = array [ i : j + 1 ] NEW_LINE DEDENT for k in range ( len ( T ) ) : NEW_LINE INDENT if k % 2 == 1 : NEW_LINE INDENT tmp += T [ k ] NEW_LINE DEDENT DEDENT if maxi < tmp : NEW_LINE INDENT choice = j NEW_LINE maxi = tmp NEW_LINE DEDENT DEDENT DEDENT return choice NEW_LINE DEDENT maxi = - 10000000000000 NEW_LINE for i in range ( len ( L ) ) : NEW_LINE INDENT aoki_choice = aoki ( i , L ) NEW_LINE tmp = 0 NEW_LINE if i < aoki_choice : NEW_LINE INDENT T = L [ i : aoki_choice + 1 ] NEW_LINE for j in range ( len ( T ) ) : NEW_LINE INDENT if j % 2 == 0 : NEW_LINE INDENT tmp += T [ j ] NEW_LINE DEDENT DEDENT DEDENT elif i > aoki_choice : NEW_LINE INDENT T = L [ aoki_choice : i + 1 ] NEW_LINE for j in range ( len ( T ) ) : NEW_LINE INDENT if j % 2 == 0 : NEW_LINE INDENT tmp += T [ j ] NEW_LINE DEDENT DEDENT DEDENT maxi = max ( tmp , maxi ) NEW_LINE DEDENT print ( maxi ) NEW_LINE","def seq_game ( N : int , A : list ) -> int : NEW_LINE INDENT Tmax = - float ( ' inf ' ) NEW_LINE for ti in range ( N ) : NEW_LINE INDENT Amax = - float ( ' inf ' ) NEW_LINE Aidx = - 1 NEW_LINE for ai in range ( N ) : NEW_LINE INDENT if ti == ai : NEW_LINE INDENT continue NEW_LINE DEDENT if ti < ai : NEW_LINE INDENT ap = sum ( A [ ti + 1 : ai + 1 : 2 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT ap = sum ( A [ ai + 1 : ti + 1 : 2 ] ) NEW_LINE DEDENT if Amax < ap : NEW_LINE INDENT Amax = ap NEW_LINE Aidx = ai NEW_LINE DEDENT DEDENT if ti < Aidx : NEW_LINE INDENT Tmax = max ( Tmax , sum ( A [ ti : Aidx + 1 : 2 ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT Tmax = max ( Tmax , sum ( A [ Aidx : ti + 1 : 2 ] ) ) NEW_LINE DEDENT DEDENT return Tmax NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE A = [ int ( s ) for s in input ( ) . split ( ) ] NEW_LINE ans = seq_game ( N , A ) NEW_LINE print ( ans ) NEW_LINE DEDENT","import sys NEW_LINE input = sys . stdin . readline NEW_LINE N = int ( input ( ) ) NEW_LINE a = [ int ( _ ) for _ in input ( ) . split ( ) ] NEW_LINE Tmax = - float ( ' inf ' ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT Amax = - float ( ' inf ' ) NEW_LINE Aindex = - 1 NEW_LINE for j in range ( N ) : NEW_LINE INDENT if i == j : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT if i < j : NEW_LINE INDENT tmp = sum ( a [ i + 1 : j + 1 : 2 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT tmp = sum ( a [ j + 1 : i + 1 : 2 ] ) NEW_LINE DEDENT if tmp > Amax : NEW_LINE INDENT Amax = tmp NEW_LINE Aindex = j NEW_LINE DEDENT DEDENT DEDENT if i < Aindex : NEW_LINE INDENT tmp = sum ( a [ i : Aindex + 1 : 2 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT tmp = sum ( a [ Aindex : i + 1 : 2 ] ) NEW_LINE DEDENT if tmp > Tmax : NEW_LINE INDENT Tmax = tmp NEW_LINE DEDENT DEDENT print ( Tmax ) NEW_LINE"],"bleu":0.4876327711634819,"rouge_l":0.4849621240531013}
{"id":26,"predictions":["N , K = map ( int , input ( ) . split ( ) ) NEW_LINE r = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT x = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if l [ i ] > abs ( l [ i ] ) : NEW_LINE INDENT ans += 2 * x NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["N = int ( input ( ) ) NEW_LINE K = int ( input ( ) ) NEW_LINE X = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE sum_len = 0 NEW_LINE for i in range ( len ( X ) ) : NEW_LINE INDENT if X [ i ] < abs ( K - X [ i ] ) : NEW_LINE INDENT sum_len += X [ i ] * 2 NEW_LINE DEDENT else : NEW_LINE INDENT sum_len += abs ( K - X [ i ] ) * 2 NEW_LINE DEDENT DEDENT print ( sum_len ) NEW_LINE","_ , k , t = open ( 0 ) ; print ( sum ( min ( x , int ( k ) - x ) * 2 for x in map ( int , t . split ( ) ) ) ) NEW_LINE","n = int ( input ( ) ) NEW_LINE k = int ( input ( ) ) NEW_LINE x = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE s = 0 NEW_LINE for x_ in x : NEW_LINE INDENT s += ( min ( x_ , abs ( k - x_ ) ) * 2 ) NEW_LINE DEDENT print ( s ) NEW_LINE"],"bleu":0.517829800640147,"rouge_l":0.6541554959785524}
{"id":27,"predictions":["import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE inf = 10 ** 20 NEW_LINE eps = 1.0 \/ 10 ** 10 NEW_LINE mod = 10 ** 9 + 7 NEW_LINE dd = [ ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) ] NEW_LINE ddn = [ ( - 1 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) , ( 1 , 0 ) , ( 1 , - 1 ) , ( 0 , - 1 ) , ( - 1 , - 1 ) ] NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def F ( ) : return float ( sys . stdin . readline ( ) ) NEW_LINE def S ( ) : return input ( ) NEW_LINE def pf ( s ) : return print ( s , flush = True ) NEW_LINE def main ( ) : NEW_LINE INDENT n = II ( ) NEW_LINE a = L . copy ( ) NEW_LINE g = [ 1 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT g = gcd ( a [ i ] , a [ i ] ) NEW_LINE DEDENT return ' First ' NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( main ( ) ) NEW_LINE DEDENT"],"references":["from fractions import gcd NEW_LINE def gcdL ( L ) : NEW_LINE INDENT g = L [ 0 ] NEW_LINE for i in range ( 1 , len ( L ) ) : NEW_LINE INDENT if g == 1 : NEW_LINE INDENT return ( g ) NEW_LINE DEDENT g = gcd ( g , L [ i ] ) NEW_LINE DEDENT return g NEW_LINE DEDENT def play ( A , i ) : NEW_LINE INDENT A [ i ] -= 1 NEW_LINE g = gcdL ( A ) NEW_LINE return [ x \/\/ g for x in A ] NEW_LINE DEDENT def cnt ( A ) : NEW_LINE INDENT odd , even = 0 , 0 NEW_LINE for a in A : NEW_LINE INDENT if a % 2 : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even += 1 NEW_LINE DEDENT DEDENT return odd , even NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE First = 1 NEW_LINE while True : NEW_LINE INDENT odd , even = cnt ( A ) NEW_LINE if even % 2 : NEW_LINE INDENT print ( ' First ' if First else ' Second ' ) NEW_LINE break NEW_LINE DEDENT elif odd > 1 : NEW_LINE INDENT print ( ' Second ' if First else ' First ' ) NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if A [ i ] % 2 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if A [ i ] == 1 : NEW_LINE INDENT print ( ' Second ' if First else ' First ' ) NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT A = play ( A , i ) NEW_LINE First ^= 1 NEW_LINE DEDENT DEDENT DEDENT","from fractions import gcd NEW_LINE def readln ( ch ) : NEW_LINE INDENT _res = list ( map ( int , str ( input ( ) ) . split ( ch ) ) ) NEW_LINE return _res NEW_LINE DEDENT def count ( a ) : NEW_LINE INDENT odd , even = 0 , 0 NEW_LINE for x in a : NEW_LINE INDENT if x % 2 == 1 : odd = odd + 1 NEW_LINE else : even = even + 1 NEW_LINE DEDENT return odd , even NEW_LINE DEDENT def deal ( n , a ) : NEW_LINE INDENT odd , even = count ( a ) NEW_LINE if even == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT if even % 2 == 1 : NEW_LINE INDENT return True NEW_LINE DEDENT if odd > 1 : NEW_LINE INDENT return False NEW_LINE DEDENT if a [ 0 ] % 2 == 0 : NEW_LINE INDENT res = a [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT res = a [ 1 ] NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if a [ i ] % 2 == 1 : NEW_LINE INDENT if a [ i ] == 1 : return False NEW_LINE a [ i ] = a [ i ] - 1 NEW_LINE DEDENT res = gcd ( a [ i ] , res ) NEW_LINE DEDENT return not deal ( n , list ( map ( lambda x : x \/\/ res , a ) ) ) NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE a = readln ( ' ▁ ' ) NEW_LINE if deal ( n , a ) : NEW_LINE INDENT print ( ' First ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' Second ' ) NEW_LINE DEDENT"],"bleu":0.19538651366159432,"rouge_l":0.32477115636091913}
{"id":28,"predictions":["s = input ( ) NEW_LINE print ( \" YES \" if len ( set ( s ) ) == 1 else \" NO \" ) NEW_LINE"],"references":["s = input ( ) NEW_LINE t = s [ : : - 1 ] NEW_LINE for x , y in zip ( s , t ) : NEW_LINE INDENT if x != ' * ' and y != ' * ' and x != y : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT print ( ' YES ' ) NEW_LINE","S = [ str ( _ ) for _ in input ( ) ] NEW_LINE revS = S [ : : - 1 ] NEW_LINE for i in range ( len ( S ) ) : NEW_LINE INDENT if S [ i ] == \" * \" : NEW_LINE INDENT revS [ i ] = \" * \" NEW_LINE DEDENT elif revS [ i ] == \" * \" : NEW_LINE INDENT S [ i ] = \" * \" NEW_LINE DEDENT DEDENT print ( \" YES \" if S == revS else \" NO \" ) NEW_LINE","S = input ( ) NEW_LINE if len ( S ) % 2 == 0 : NEW_LINE INDENT S1 = S [ : len ( S ) \/\/ 2 ] NEW_LINE S2 = S [ len ( S ) \/\/ 2 : ] NEW_LINE S2 = S2 [ : : - 1 ] NEW_LINE for i in range ( len ( S ) \/\/ 2 ) : NEW_LINE INDENT if S1 [ i ] == ' * ' or S2 [ i ] == ' * ' : NEW_LINE INDENT continue NEW_LINE DEDENT elif S1 [ i ] == S2 [ i ] : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT S1 = S [ : len ( S ) \/\/ 2 ] NEW_LINE S2 = S [ len ( S ) \/\/ 2 + 1 : ] NEW_LINE S2 = S2 [ : : - 1 ] NEW_LINE for i in range ( len ( S ) \/\/ 2 ) : NEW_LINE INDENT if S1 [ i ] == ' * ' or S2 [ i ] == ' * ' : NEW_LINE INDENT continue NEW_LINE DEDENT elif S1 [ i ] == S2 [ i ] : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT DEDENT"],"bleu":0.13219117618028203,"rouge_l":0.2668685848897863}
{"id":29,"predictions":["N , T = map ( int , input ( ) . split ( ) ) NEW_LINE A = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] NEW_LINE B = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] NEW_LINE flag = True NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT if A [ i ] [ j ] <= T [ i ] [ j ] : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if flag : NEW_LINE INDENT print ( ' yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' no ' ) NEW_LINE DEDENT"],"references":["t = int ( input ( ) ) NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE m = int ( input ( ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if n < m : NEW_LINE INDENT print ( \" no \" ) NEW_LINE exit ( ) NEW_LINE DEDENT for i in b : NEW_LINE INDENT for l in range ( len ( a ) ) : NEW_LINE INDENT if i - t - 1 < a [ l ] < i + 1 : NEW_LINE INDENT a . pop ( l ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if len ( a ) == n - m : NEW_LINE INDENT print ( \" yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" no \" ) NEW_LINE DEDENT","import sys NEW_LINE limit = int ( input ( ) ) NEW_LINE int ( input ( ) ) NEW_LINE takoyaki = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE int ( input ( ) ) NEW_LINE customer = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in customer : NEW_LINE INDENT index = [ j for j in takoyaki if i - limit <= j <= i ] NEW_LINE if len ( index ) == 0 : NEW_LINE INDENT print ( ' no ' ) NEW_LINE sys . exit ( ) NEW_LINE DEDENT takoyaki . remove ( index [ 0 ] ) NEW_LINE DEDENT print ( ' yes ' ) NEW_LINE","T = int ( input ( ) ) NEW_LINE N = int ( input ( ) ) NEW_LINE A = [ int ( _ ) for _ in input ( ) . split ( ) ] NEW_LINE M = int ( input ( ) ) NEW_LINE B = [ int ( _ ) for _ in input ( ) . split ( ) ] NEW_LINE can = True NEW_LINE a_idx = 0 NEW_LINE for b in B : NEW_LINE INDENT while True : NEW_LINE INDENT if a_idx == N : NEW_LINE INDENT can = False NEW_LINE break NEW_LINE DEDENT if b - A [ a_idx ] < 0 : NEW_LINE INDENT can = False NEW_LINE break NEW_LINE DEDENT if b - A [ a_idx ] <= T : NEW_LINE INDENT a_idx += 1 NEW_LINE break NEW_LINE DEDENT a_idx += 1 NEW_LINE DEDENT if not can : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if can : NEW_LINE INDENT print ( \" yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" no \" ) NEW_LINE DEDENT"],"bleu":0.6090190433947653,"rouge_l":0.6267564799410398}
{"id":30,"predictions":["n , d , x = map ( int , input ( ) . split ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE counter = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( d <= d ) : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT else : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT DEDENT print ( counter ) NEW_LINE"],"references":["N = int ( input ( ) ) NEW_LINE D , X = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT A = int ( input ( ) ) NEW_LINE ans += ( D - 1 ) \/\/ A + 1 NEW_LINE DEDENT print ( ans + X ) NEW_LINE","import math NEW_LINE N = int ( input ( ) ) NEW_LINE D , X = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE A = [ int ( input ( ) ) for _ in range ( N ) ] NEW_LINE Ans = X NEW_LINE for i in A : NEW_LINE INDENT Ans += math . ceil ( D \/ i ) NEW_LINE DEDENT print ( Ans ) NEW_LINE","N = int ( input ( ) ) NEW_LINE D , X , = map ( int , input ( ) . split ( ) ) NEW_LINE An = [ int ( input ( ) ) for _ in range ( N ) ] NEW_LINE c = 0 NEW_LINE for n in range ( N ) : NEW_LINE INDENT i = 0 NEW_LINE while True : NEW_LINE INDENT d = i * An [ n ] + 1 NEW_LINE if d > D : NEW_LINE INDENT break NEW_LINE DEDENT c += 1 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT print ( c + X ) NEW_LINE"],"bleu":0.530064999476612,"rouge_l":0.651281208935611}
{"id":31,"predictions":["import sys NEW_LINE ns = lambda : sys . stdin . readline ( ) . rstrip ( ) NEW_LINE ni = lambda : int ( ns ( ) ) NEW_LINE nm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE nl = lambda : list ( nm ( ) ) NEW_LINE ns = lambda : map ( str , sys . stdin . readline ( ) . split ( ) ) NEW_LINE s = ns ( ) NEW_LINE nl = ni ( ) NEW_LINE s = ns ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' R ' : NEW_LINE INDENT n = ni ( ) NEW_LINE DEDENT if s [ i ] == ' D ' : NEW_LINE INDENT print ( ' DRAW ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' DRAW ' ) NEW_LINE DEDENT"],"references":["* a , = open ( 0 ) . read ( ) ; s , t = map ( a . count , \" RB \" ) ; print ( [ \" ADORKAIW \" [ s == t : : 2 ] , \" TAKAHASHI \" ] [ s > t ] ) NEW_LINE","N = int ( input ( ) ) NEW_LINE L = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT L . append ( input ( ) ) NEW_LINE DEDENT r = 0 NEW_LINE b = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if L [ i ] [ j ] == ' R ' : NEW_LINE INDENT r += 1 NEW_LINE DEDENT elif L [ i ] [ j ] == ' B ' : NEW_LINE INDENT b += 1 NEW_LINE DEDENT else : NEW_LINE INDENT None NEW_LINE DEDENT DEDENT DEDENT if r > b : NEW_LINE INDENT print ( ' TAKAHASHI ' ) NEW_LINE DEDENT elif r < b : NEW_LINE INDENT print ( ' AOKI ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' DRAW ' ) NEW_LINE DEDENT","def a_paint ( N , S ) : NEW_LINE INDENT takahashi , aoki = 0 , 0 NEW_LINE for row in S : NEW_LINE INDENT for c in row : NEW_LINE INDENT if c == ' R ' : NEW_LINE INDENT takahashi += 1 NEW_LINE DEDENT elif c == ' B ' : NEW_LINE INDENT aoki += 1 NEW_LINE DEDENT DEDENT DEDENT if takahashi > aoki : NEW_LINE INDENT ans = ' TAKAHASHI ' NEW_LINE DEDENT elif takahashi == aoki : NEW_LINE INDENT ans = ' DRAW ' NEW_LINE DEDENT else : NEW_LINE INDENT ans = ' AOKI ' NEW_LINE DEDENT return ans NEW_LINE DEDENT N = int ( input ( ) ) NEW_LINE S = [ input ( ) for _ in [ 0 ] * N ] NEW_LINE print ( a_paint ( N , S ) ) NEW_LINE"],"bleu":0.3131785914686072,"rouge_l":0.47227453442142703}
{"id":32,"predictions":["import sys NEW_LINE stdin = sys . stdin NEW_LINE sys . setrecursionlimit ( 10 ** 5 ) NEW_LINE def li ( ) : return map ( int , stdin . readline ( ) . split ( ) ) NEW_LINE def li_ ( ) : return map ( lambda x : int ( x ) - 1 , stdin . readline ( ) . split ( ) ) NEW_LINE def lf ( ) : return map ( float , stdin . readline ( ) . split ( ) ) NEW_LINE def ls ( ) : return stdin . readline ( ) . split ( ) NEW_LINE def ns ( ) : return stdin . readline ( ) . rstrip ( ) NEW_LINE def lc ( ) : return list ( ns ( ) ) NEW_LINE def ni ( ) : return int ( stdin . readline ( ) ) NEW_LINE def nf ( ) : return float ( stdin . readline ( ) ) NEW_LINE from collections import Counter NEW_LINE a = li ( ) NEW_LINE b , c , t = ns ( ) NEW_LINE print ( main ( ) ) NEW_LINE"],"references":["a , b , c , k = map ( int , input ( ) . split ( ) ) NEW_LINE s , t = map ( int , input ( ) . split ( ) ) NEW_LINE total = s + t NEW_LINE discount = 0 NEW_LINE if total >= k : NEW_LINE INDENT discount = total * c NEW_LINE DEDENT adm = ( s * a ) + ( t * b ) NEW_LINE print ( adm - discount ) NEW_LINE","child_price , adult_price , discount_price , discount_min = map ( int , input ( ) . split ( ) ) NEW_LINE child_num , adult_num = map ( int , input ( ) . split ( ) ) NEW_LINE person_sum = child_num + adult_num NEW_LINE print ( child_price * child_num + adult_price * adult_num - ( discount_price * person_sum if person_sum >= discount_min else 0 ) ) NEW_LINE","def zoo ( A : int , B : int , C : int , K : int , S : int , T : int ) -> int : NEW_LINE INDENT total = A * S + B * T NEW_LINE if S + T >= K : NEW_LINE INDENT total -= C * ( S + T ) NEW_LINE DEDENT return total NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A , B , C , K = map ( int , input ( ) . split ( ) ) NEW_LINE S , T = map ( int , input ( ) . split ( ) ) NEW_LINE ans = zoo ( A , B , C , K , S , T ) NEW_LINE print ( ans ) NEW_LINE DEDENT"],"bleu":0.14542928317295348,"rouge_l":0.3437806290653123}
{"id":33,"predictions":["n , w = map ( int , input ( ) . split ( ) ) NEW_LINE d = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT w , v = map ( int , input ( ) . split ( ) ) NEW_LINE if w in d : NEW_LINE INDENT d [ w ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ w ] = 1 NEW_LINE DEDENT DEDENT s = 0 NEW_LINE for i in d : NEW_LINE INDENT s += w NEW_LINE DEDENT print ( max ( d ) ) NEW_LINE"],"references":["n , W = map ( int , input ( ) . split ( ) ) NEW_LINE iw , v = map ( int , input ( ) . split ( ) ) NEW_LINE d = { 0 : [ v ] , 1 : [ ] , 2 : [ ] , 3 : [ ] } NEW_LINE for _ in range ( 1 , n ) : NEW_LINE INDENT w , v = map ( int , input ( ) . split ( ) ) NEW_LINE d [ w - iw ] . append ( v ) NEW_LINE DEDENT for i in range ( 4 ) : NEW_LINE INDENT d [ i ] = sorted ( d [ i ] , reverse = True ) NEW_LINE DEDENT ret = - 1 NEW_LINE for i in range ( min ( n , len ( d [ 0 ] ) ) + 1 ) : NEW_LINE INDENT if i * iw > W : NEW_LINE INDENT break NEW_LINE DEDENT for j in range ( min ( n - i , len ( d [ 1 ] ) ) + 1 ) : NEW_LINE INDENT if i * iw + j * ( iw + 1 ) > W : NEW_LINE INDENT break NEW_LINE DEDENT for k in range ( min ( n - ( i + j ) , len ( d [ 2 ] ) ) + 1 ) : NEW_LINE INDENT if i * iw + j * ( iw + 1 ) + k * ( iw + 2 ) > W : NEW_LINE INDENT break NEW_LINE DEDENT for l in range ( min ( n - ( i + j + k ) , len ( d [ 3 ] ) ) + 1 ) : NEW_LINE INDENT if i * iw + j * ( iw + 1 ) + k * ( iw + 2 ) + l * ( iw + 3 ) > W : NEW_LINE INDENT continue NEW_LINE DEDENT V = sum ( d [ 0 ] [ : i ] ) + sum ( d [ 1 ] [ : j ] ) + sum ( d [ 2 ] [ : k ] ) + sum ( d [ 3 ] [ : l ] ) NEW_LINE ret = max ( ret , V ) NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( ret ) NEW_LINE","N , W = [ int ( _ ) for _ in input ( ) . split ( ) ] NEW_LINE WV = [ [ int ( _ ) for _ in input ( ) . split ( ) ] for i in range ( N ) ] NEW_LINE from collections import defaultdict NEW_LINE from itertools import accumulate NEW_LINE cs = defaultdict ( list ) NEW_LINE for w , v in WV : NEW_LINE INDENT cs [ w ] . append ( v ) NEW_LINE DEDENT minw = min ( cs . keys ( ) ) NEW_LINE for k in range ( minw , minw + 4 ) : NEW_LINE INDENT cs [ k ] = [ 0 ] + list ( accumulate ( sorted ( cs [ k ] , reverse = True ) ) ) NEW_LINE DEDENT result = 0 NEW_LINE for w0 , t0 in enumerate ( cs [ minw ] ) : NEW_LINE INDENT for w1 , t1 in enumerate ( cs [ minw + 1 ] ) : NEW_LINE INDENT tw1 = w0 * minw + w1 * ( minw + 1 ) NEW_LINE tv1 = t0 + t1 NEW_LINE if tw1 > W : NEW_LINE INDENT break NEW_LINE DEDENT for w2 , t2 in enumerate ( cs [ minw + 2 ] ) : NEW_LINE INDENT tw2 = tw1 + w2 * ( minw + 2 ) NEW_LINE tv2 = tv1 + t2 NEW_LINE if tw2 > W : NEW_LINE INDENT break NEW_LINE DEDENT for w3 , t3 in enumerate ( cs [ minw + 3 ] ) : NEW_LINE INDENT tw3 = tw2 + w3 * ( minw + 3 ) NEW_LINE tv3 = tv2 + t3 NEW_LINE if tw3 > W : NEW_LINE INDENT break NEW_LINE DEDENT result = max ( result , tv3 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( result ) NEW_LINE","import sys , collections NEW_LINE from collections import defaultdict NEW_LINE def solve ( ) : NEW_LINE INDENT N , W = map ( int , input ( ) . split ( ) ) NEW_LINE DP = [ defaultdict ( lambda : 0 ) for i in range ( N + 1 ) ] NEW_LINE DP [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT w , v = map ( int , input ( ) . split ( ) ) NEW_LINE for DPw in DP [ i ] : NEW_LINE INDENT DPv = DP [ i ] [ DPw ] NEW_LINE DP [ i + 1 ] [ DPw ] = max ( DP [ i + 1 ] [ DPw ] , DPv ) NEW_LINE if DPw + w <= W : NEW_LINE INDENT DP [ i + 1 ] [ DPw + w ] = max ( DP [ i + 1 ] [ DPw + w ] , DPv + v ) NEW_LINE DEDENT DEDENT DEDENT print ( max ( DP [ N ] . values ( ) ) - 1 ) NEW_LINE DEDENT solve ( ) NEW_LINE"],"bleu":0.24447010379472453,"rouge_l":0.45338237645929963}
{"id":34,"predictions":["from collections import defaultdict NEW_LINE from heapq import heappush , heappop NEW_LINE import sys NEW_LINE import math NEW_LINE import bisect NEW_LINE import random NEW_LINE def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def S ( ) : return list ( sys . stdin . readline ( ) ) NEW_LINE def IR ( n ) : return [ I ( ) for i in range ( n ) ] NEW_LINE def LIR ( n ) : return [ LI ( ) for i in range ( n ) ] NEW_LINE def SR ( n ) : return [ S ( ) for i in range ( n ) ] NEW_LINE def LSR ( n ) : return [ LS ( ) for i in range ( n ) ] NEW_LINE mod = 1000000007 NEW_LINE def mul ( a , b ) : NEW_LINE INDENT c = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if c [ i ] [ 0 ] > d [ i ] [ j ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def lcm ( a , r , d ) : NEW_LINE INDENT a , b = LI ( ) NEW_LINE if d [ a ] [ b ] : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT c = [ ] NEW_LINE b = [ ] NEW_LINE d = LI ( ) NEW_LINE f = False NEW_LINE for i in range ( n ) : NEW_LINE INDENT l , r , d = LI ( ) NEW_LINE if abs ( a - b ) : NEW_LINE INDENT f = False NEW_LINE DEDENT if f : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \""],"references":["def inpl ( ) : return [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE def find ( x ) : NEW_LINE INDENT if par [ x ] == x : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT par [ x ] , dist [ x ] = find ( par [ x ] ) , dist [ x ] + dist [ par [ x ] ] NEW_LINE return par [ x ] NEW_LINE DEDENT DEDENT N , M = inpl ( ) NEW_LINE par = list ( range ( N + 1 ) ) NEW_LINE dist = [ 0 for _ in range ( N + 1 ) ] NEW_LINE for _ in range ( M ) : NEW_LINE INDENT l , r , d = inpl ( ) NEW_LINE fl = find ( l ) NEW_LINE fr = find ( r ) NEW_LINE if fl != fr : NEW_LINE INDENT par [ fr ] = fl NEW_LINE dist [ fr ] = d + dist [ l ] - dist [ r ] NEW_LINE DEDENT elif d + dist [ l ] - dist [ r ] != 0 : NEW_LINE INDENT print ( ' No ' ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT","import itertools NEW_LINE import math NEW_LINE from collections import deque NEW_LINE from collections import defaultdict NEW_LINE from itertools import permutations NEW_LINE import heapq NEW_LINE import bisect NEW_LINE from scipy . sparse . csgraph import floyd_warshall as wf NEW_LINE INF = float ( \" inf \" ) NEW_LINE N , M = map ( int , input ( ) . split ( ) ) NEW_LINE Adj_list = defaultdict ( set ) NEW_LINE for i in range ( M ) : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE Adj_list [ a - 1 ] . add ( ( b - 1 , c ) ) NEW_LINE Adj_list [ b - 1 ] . add ( ( a - 1 , - c ) ) NEW_LINE DEDENT visited = [ None ] * ( N ) NEW_LINE ok = True NEW_LINE stack = [ ] NEW_LINE for x in range ( N ) : NEW_LINE INDENT if visited [ x ] is not None : continue NEW_LINE visited [ x ] = 0 NEW_LINE stack = [ x ] NEW_LINE while stack : NEW_LINE INDENT v = stack . pop ( ) NEW_LINE for to , d in Adj_list [ v ] : NEW_LINE INDENT if visited [ to ] is None : NEW_LINE INDENT visited [ to ] = visited [ v ] + d NEW_LINE stack . append ( to ) NEW_LINE DEDENT else : NEW_LINE INDENT if visited [ to ] != visited [ v ] + d : NEW_LINE INDENT ok = False NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT if ok == False : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( \" Yes \" if ok else \" No \" ) NEW_LINE","import sys NEW_LINE sys . setrecursionlimit ( 10 ** 5 ) NEW_LINE N , M = map ( int , input ( ) . split ( ) ) NEW_LINE input = sys . stdin . readline NEW_LINE LRD = [ [ int ( j ) for j in input ( ) . split ( ) ] for _ in range ( M ) ] NEW_LINE data = [ x for x in range ( N + 1 ) ] NEW_LINE rank = [ 0 ] * ( N + 1 ) NEW_LINE diff_weight = [ 0 ] * ( N + 1 ) NEW_LINE def root ( x ) : NEW_LINE INDENT if data [ x ] == x : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT r = root ( data [ x ] ) NEW_LINE diff_weight [ x ] += diff_weight [ data [ x ] ] NEW_LINE data [ x ] = r NEW_LINE return r NEW_LINE DEDENT DEDENT def weight ( x ) : NEW_LINE INDENT return diff_weight [ x ] NEW_LINE DEDENT def diff ( x , y ) : NEW_LINE INDENT return weight ( y ) - weight ( x ) NEW_LINE DEDENT def merge ( x , y , w ) : NEW_LINE INDENT w += weight ( x ) ; w -= weight ( y ) NEW_LINE x = root ( x ) NEW_LINE y = root ( y ) NEW_LINE if x == y : return False NEW_LINE if rank [ x ] < rank [ y ] : x , y = y , x ; w = - w NEW_LINE if rank [ x ] == rank [ y ] : rank [ x ] += 1 NEW_LINE data [ y ] = x NEW_LINE diff_weight [ y ] = w NEW_LINE return True NEW_LINE DEDENT def issame ( x , y ) : NEW_LINE INDENT return root ( x ) == root ( y ) NEW_LINE DEDENT for i in range ( M ) : NEW_LINE INDENT L , R , D = LRD [ i ] NEW_LINE if not issame ( L , R ) : NEW_LINE INDENT _ = merge ( L , R , D ) NEW_LINE DEDENT else : NEW_LINE INDENT if diff ( L , R ) != D : NEW_LINE INDENT print ( \" No \" ) NEW_LINE exit ( 0 ) NEW_LINE DEDENT DEDENT DEDENT print ( \" Yes \" ) NEW_LINE"],"bleu":0.35820508704745696,"rouge_l":0.42429101943491165}
{"id":35,"predictions":["a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE if a == b : NEW_LINE INDENT print ( int ( c ) ) NEW_LINE DEDENT elif b == c : NEW_LINE INDENT print ( int ( a ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( int ( b ) ) NEW_LINE DEDENT"],"references":["A , B , C = map ( int , input ( ) . split ( ) ) NEW_LINE if A == B : NEW_LINE INDENT print ( C ) NEW_LINE DEDENT elif A == C : NEW_LINE INDENT print ( B ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( A ) NEW_LINE DEDENT","a = [ int ( i ) for i in input ( ) . split ( ' ▁ ' ) ] NEW_LINE a . sort ( ) NEW_LINE print ( sum ( a ) - 2 * a [ 1 ] ) NEW_LINE","a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT if a . count ( a [ i ] ) == 1 : NEW_LINE INDENT print ( a [ i ] ) NEW_LINE DEDENT DEDENT"],"bleu":0.5562568212766869,"rouge_l":0.766759776536313}
{"id":36,"predictions":["def inpl ( ) : return [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE Y , m , d = inpl ( ) NEW_LINE print ( ( 7 * ( - 1 ) \/\/ 4 + ( m * d - 1 ) ) NEW_LINE"],"references":["y = int ( input ( ) ) NEW_LINE m = int ( input ( ) ) NEW_LINE d = int ( input ( ) ) NEW_LINE def f ( x ) : NEW_LINE INDENT return int ( x \/\/ 1 ) NEW_LINE DEDENT def F ( y , m , d ) : NEW_LINE INDENT if m == 1 or m == 2 : NEW_LINE INDENT y -= 1 NEW_LINE m += 12 NEW_LINE DEDENT return int ( 365 * y + f ( y \/ 4 ) - f ( y \/ 100 ) + f ( y \/ 400 ) + f ( 306 * ( m + 1 ) \/ 10 ) + d - 429 ) NEW_LINE DEDENT print ( F ( 2014 , 5 , 17 ) - F ( y , m , d ) ) NEW_LINE","from datetime import date , timedelta NEW_LINE x = [ ] NEW_LINE ans = 0 NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT x . append ( int ( input ( ) ) ) NEW_LINE DEDENT dt = date ( year = x [ 0 ] , month = x [ 1 ] , day = x [ 2 ] ) NEW_LINE q = 1 NEW_LINE while q : NEW_LINE INDENT if dt . year != 2014 or dt . month != 5 or dt . day != 17 : NEW_LINE INDENT dt += timedelta ( days = 1 ) NEW_LINE ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE","import sys NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE input = sys . stdin . readline NEW_LINE def ceil ( x ) : NEW_LINE INDENT return ( - x ) \/\/ 1 * ( - 1 ) NEW_LINE DEDENT def calc ( y , m , d ) : NEW_LINE INDENT return 365 * y + y \/\/ 4 - y \/\/ 100 + y \/\/ 400 + ( 306 * ( m + 1 ) ) \/\/ 10 + d - 429 NEW_LINE DEDENT y = int ( input ( ) ) NEW_LINE m = int ( input ( ) ) NEW_LINE d = int ( input ( ) ) NEW_LINE if m == 1 : NEW_LINE INDENT m = 13 NEW_LINE y -= 1 NEW_LINE DEDENT elif m == 2 : NEW_LINE INDENT m = 14 NEW_LINE y -= 1 NEW_LINE DEDENT de = calc ( 2014 , 5 , 17 ) NEW_LINE print ( de - calc ( y , m , d ) ) NEW_LINE"],"bleu":0.09068554531328087,"rouge_l":0.2800734618916437}
{"id":37,"predictions":["from itertools import product NEW_LINE K = int ( input ( ) . strip ( ) ) NEW_LINE ans = [ ] NEW_LINE while K > 0 : NEW_LINE INDENT N \/\/= 10 NEW_LINE DEDENT idx = input ( ) . strip ( ) NEW_LINE dp = [ [ 0 ] * ( N + 1 ) for _ in range ( N + 1 ) ] NEW_LINE for i in range ( K + 1 ) : NEW_LINE INDENT for j in range ( K + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j ] ) NEW_LINE i = i + 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["f = lambda x : sum ( map ( int , str ( x ) ) ) NEW_LINE ans = [ ] NEW_LINE def check ( x ) : NEW_LINE INDENT y = f ( x ) NEW_LINE while ans : NEW_LINE INDENT p = ans [ - 1 ] NEW_LINE if p * y > x * f ( p ) : ans . pop ( - 1 ) NEW_LINE else : break NEW_LINE DEDENT ans . append ( x ) NEW_LINE DEDENT k = int ( input ( ) ) NEW_LINE for i in range ( 1 , 100 ) : NEW_LINE INDENT check ( i ) NEW_LINE DEDENT a , b = 0 , 1 NEW_LINE while a < 1e12 : NEW_LINE INDENT for i in range ( 100 , 1000 ) : NEW_LINE INDENT check ( i * b + a ) NEW_LINE DEDENT a = a * 10 + 9 NEW_LINE b *= 10 NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT print ( ans [ i ] ) NEW_LINE DEDENT","def digit_sum ( num ) : NEW_LINE INDENT ds = 0 NEW_LINE while num > 0 : NEW_LINE INDENT ds += num % 10 NEW_LINE num \/\/= 10 NEW_LINE DEDENT return ds NEW_LINE DEDENT K = int ( input ( ) ) NEW_LINE candidates = [ ] NEW_LINE digit_sums = [ ] NEW_LINE for i in range ( 15 ) : NEW_LINE INDENT base = 10 ** i NEW_LINE for j in range ( 1 , 150 ) : NEW_LINE INDENT candidate = j * base + ( base - 1 ) NEW_LINE candidates . append ( candidate ) NEW_LINE DEDENT DEDENT candidates = sorted ( list ( set ( candidates ) ) ) NEW_LINE digit_sums = [ digit_sum ( candidate ) for candidate in candidates ] NEW_LINE snuke_nums = [ ] NEW_LINE smaller_as_snuke = lambda n , m , ds_n , ds_m : True if n * ds_m <= m * ds_n else False NEW_LINE for i , candidate in enumerate ( candidates ) : NEW_LINE INDENT ds_cand = digit_sums [ i ] NEW_LINE for j in range ( i + 1 , len ( candidates ) ) : NEW_LINE INDENT other_num = candidates [ j ] NEW_LINE ds_other = digit_sums [ j ] NEW_LINE if not smaller_as_snuke ( candidate , other_num , ds_cand , ds_other ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT snuke_nums . append ( candidate ) NEW_LINE DEDENT DEDENT for snuke_num in snuke_nums [ : K ] : NEW_LINE INDENT print ( snuke_num ) NEW_LINE DEDENT","import sys NEW_LINE stdin = sys . stdin NEW_LINE sys . setrecursionlimit ( 10 ** 5 ) NEW_LINE def li ( ) : return map ( int , stdin . readline ( ) . split ( ) ) NEW_LINE def li_ ( ) : return map ( lambda x : int ( x ) - 1 , stdin . readline ( ) . split ( ) ) NEW_LINE def lf ( ) : return map ( float , stdin . readline ( ) . split ( ) ) NEW_LINE def ls ( ) : return stdin . readline ( ) . split ( ) NEW_LINE def ns ( ) : return stdin . readline ( ) . rstrip ( ) NEW_LINE def lc ( ) : return list ( ns ( ) ) NEW_LINE def ni ( ) : return int ( stdin . readline ( ) ) NEW_LINE def nf ( ) : return float ( stdin . readline ( ) ) NEW_LINE def digit_sum ( num : int , base : int ) -> int : NEW_LINE INDENT if num < base : NEW_LINE INDENT return num NEW_LINE DEDENT else : NEW_LINE INDENT return digit_sum ( int ( num \/ base ) , base ) + ( num % base ) NEW_LINE DEDENT DEDENT def snuke ( num : int ) : NEW_LINE INDENT return num \/ digit_sum ( num , 10 ) NEW_LINE DEDENT k = ni ( ) NEW_LINE snuke_nums = [ i for i in range ( 1 , 10 ) ] NEW_LINE res = 9 NEW_LINE cur = 9 NEW_LINE if k <= res : NEW_LINE INDENT for s in snuke_nums [ : k ] : NEW_LINE INDENT print ( s ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT while res != k : NEW_LINE INDENT cur += 1 NEW_LINE cands = [ ] NEW_LINE for i in range ( len ( str ( cur ) ) ) : NEW_LINE INDENT cands . append ( int ( str ( cur ) [ : - i - 1 ] + \"9\" * ( i + 1 ) ) ) NEW_LINE DEDENT mi = float ( \" inf \" ) NEW_LINE for c in cands : NEW_LINE INDENT if snuke ( c ) < mi : NEW_LINE INDENT cur = c NEW_LINE mi = snuke ( c ) NEW_LINE DEDENT DEDENT snuke_nums . append ( cur ) NEW_LINE res += 1 NEW_LINE DEDENT for s in snuke_nums : NEW_LINE INDENT print ( s ) NEW_LINE DEDENT DEDENT"],"bleu":0.2945812244345642,"rouge_l":0.39298496778811737}
{"id":38,"predictions":["import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE inf = 10 ** 20 NEW_LINE mod = 10 ** 9 + 7 NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def F ( ) : return float ( sys . stdin . readline ( ) ) NEW_LINE def S ( ) : return input ( ) NEW_LINE def main ( ) : NEW_LINE INDENT s = sys . stdin . readline ( ) NEW_LINE N = s . count ( ' \\n ' ) NEW_LINE ss = [ ] NEW_LINE for _ in range ( N ) : NEW_LINE INDENT s1 , ss = S ( ) NEW_LINE if s1 == ss : NEW_LINE INDENT ss = s1 [ : - 1 ] , s2 = ss [ : - 1 ] , s2 = ss , s2 NEW_LINE DEDENT return s1 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"references":["def solve ( ) : NEW_LINE INDENT s = input ( ) NEW_LINE n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT l , r = ( int ( i ) for i in input ( ) . split ( ) ) NEW_LINE tmp = s [ l - 1 : r ] NEW_LINE s = s [ 0 : l - 1 ] + tmp [ : : - 1 ] + s [ r : : ] NEW_LINE DEDENT print ( s ) NEW_LINE DEDENT solve ( ) NEW_LINE","hoge = list ( input ( ) ) NEW_LINE n = int ( input ( ) ) NEW_LINE kari = \" \" NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE huga = hoge [ a - 1 : b ] NEW_LINE huga = huga [ : : - 1 ] NEW_LINE hoge [ a - 1 : b ] = huga NEW_LINE DEDENT for i in range ( len ( hoge ) ) : NEW_LINE INDENT print ( hoge [ i ] , end = \" \" ) NEW_LINE DEDENT print ( \" \" ) NEW_LINE","s = [ i for i in input ( ) ] NEW_LINE n = int ( input ( ) ) NEW_LINE for _ in range ( n ) : NEW_LINE INDENT r , l = map ( int , input ( ) . split ( ) ) NEW_LINE r , l = r - 1 , l - 1 NEW_LINE for i in range ( ( l - r + 1 ) \/\/ 2 ) : NEW_LINE INDENT s [ r + i ] , s [ l - i ] = s [ l - i ] , s [ r + i ] NEW_LINE DEDENT DEDENT ans = \" \" NEW_LINE for i in s : NEW_LINE INDENT ans += i NEW_LINE DEDENT print ( ans ) NEW_LINE"],"bleu":0.13480562280065664,"rouge_l":0.30621379802502763}
{"id":39,"predictions":["a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( min ( a , b ) - a ) NEW_LINE"],"references":["a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a - b > 0 : NEW_LINE INDENT print ( a - b ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT","import sys NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE input = sys . stdin . readline NEW_LINE def ii ( ) : return int ( input ( ) ) NEW_LINE def mi ( ) : return map ( int , input ( ) . rstrip ( ) . split ( ) ) NEW_LINE def lmi ( ) : return list ( map ( int , input ( ) . rstrip ( ) . split ( ) ) ) NEW_LINE def li ( ) : return list ( input ( ) . rstrip ( ) ) NEW_LINE X , t = mi ( ) NEW_LINE print ( max ( X - t , 0 ) ) NEW_LINE","x , t = [ int ( n ) for n in input ( ) . split ( ) ] NEW_LINE print ( x - t if x >= t else 0 ) NEW_LINE"],"bleu":0.6118777635439964,"rouge_l":0.6340407102641835}
{"id":40,"predictions":["import math NEW_LINE def solve ( ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE if abs ( x ) > y : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT return x NEW_LINE DEDENT DEDENT def solve ( ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a == b : NEW_LINE INDENT print ( solve ( a - b , b ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( solve ( a , b ) ) NEW_LINE DEDENT DEDENT"],"references":["import math NEW_LINE q = int ( input ( ) ) NEW_LINE for j in range ( q ) : NEW_LINE INDENT AB = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE AB . sort ( ) NEW_LINE ab = AB [ 0 ] * AB [ 1 ] NEW_LINE for i in range ( int ( math . sqrt ( ab ) ) , AB [ 1 ] + 1 ) : NEW_LINE INDENT if i * i >= ab : NEW_LINE INDENT x = i - 1 NEW_LINE break NEW_LINE DEDENT DEDENT if x == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE continue NEW_LINE DEDENT for i in range ( int ( ab \/ x ) , ab + 1 ) : NEW_LINE INDENT if x * i >= ab : NEW_LINE INDENT y = i - 1 NEW_LINE break NEW_LINE DEDENT DEDENT cnt1 = 2 * x NEW_LINE cnts = 1 if x == y else 0 NEW_LINE cntdd = 1 if x - AB [ 0 ] >= 0 else 0 NEW_LINE cntdu = 1 if AB [ 1 ] - y >= 0 and ( AB [ 1 ] + 1 ) * ( x - AB [ 1 ] + y ) >= ab else 0 NEW_LINE print ( cnt1 - cnts - cntdd - cntdu ) NEW_LINE DEDENT","from math import sqrt NEW_LINE Q = int ( input ( ) ) NEW_LINE table = [ ] NEW_LINE for i in range ( Q ) : NEW_LINE INDENT A , B = map ( int , input ( ) . split ( ) ) NEW_LINE if A > B : NEW_LINE INDENT table . append ( [ B , A ] ) NEW_LINE DEDENT else : NEW_LINE INDENT table . append ( [ A , B ] ) NEW_LINE DEDENT DEDENT def f ( a , b ) : NEW_LINE INDENT if a == b : NEW_LINE INDENT return 2 * a - 2 NEW_LINE DEDENT if a + 1 == b : NEW_LINE INDENT return 2 * a - 2 NEW_LINE DEDENT m = int ( sqrt ( a * b ) ) NEW_LINE if m ** 2 == a * b : NEW_LINE INDENT return 2 * m - 3 NEW_LINE DEDENT if m * ( m + 1 ) >= a * b : NEW_LINE INDENT return 2 * m - 2 NEW_LINE DEDENT return 2 * m - 1 NEW_LINE DEDENT ans = [ ] NEW_LINE for a , b in table : NEW_LINE INDENT ans . append ( f ( a , b ) ) NEW_LINE DEDENT print ( ' \\n ' . join ( map ( str , ans ) ) ) NEW_LINE","def inpl ( ) : return [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE Q = int ( input ( ) ) NEW_LINE for _ in range ( Q ) : NEW_LINE INDENT A , B = sorted ( inpl ( ) ) NEW_LINE c = int ( - ( - ( A * B ) ** 0.5 \/\/ 1 ) - 1 ) NEW_LINE ans = A - 1 + max ( 0 , c - A ) + ( - ( ( - A * B ) \/\/ ( c + 1 ) ) - 1 ) NEW_LINE print ( ans ) NEW_LINE DEDENT"],"bleu":0.5556396353365347,"rouge_l":0.44158812722197044}
{"id":41,"predictions":["from statistics import mean , median , variance , stdev NEW_LINE import numpy as np NEW_LINE import sys NEW_LINE import math NEW_LINE import fractions NEW_LINE import itertools NEW_LINE import copy NEW_LINE from operator import itemgetter NEW_LINE def j ( q ) : NEW_LINE INDENT if q == 1 : print ( \" Yes \" ) NEW_LINE else : print ( \" No \" ) NEW_LINE exit ( 0 ) NEW_LINE DEDENT def ct ( x , y ) : NEW_LINE INDENT if ( x > y ) : print ( \" + \" ) NEW_LINE elif ( x < y ) : print ( \" - \" ) NEW_LINE else : print ( \" ? \" ) NEW_LINE DEDENT def ip ( ) : NEW_LINE INDENT return int ( input ( ) ) NEW_LINE DEDENT def pne ( n ) : NEW_LINE INDENT print ( n , end = ' ' ) NEW_LINE DEDENT rem = pow ( 10 , 9 ) + 7 NEW_LINE x , y , a , b = ( int ( i ) for i in input ( ) . split ( ) ) NEW_LINE x , y , mod = 1000000007 , 998244353 NEW_LINE def solve ( ) : NEW_LINE INDENT H , W , a , b = b - a , b - 1 , c - 1 NEW_LINE if x + y == b : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif y == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT h , w , a , b = ( int ( i ) for i in input ( ) . split ( ) ) ) NEW_LINE print ( ( solve ( h , w , b ) ) NEW_LINE"],"references":["H , W , A , B = map ( int , input ( ) . split ( ) ) NEW_LINE P = 10 ** 9 + 7 NEW_LINE N = H + W NEW_LINE def fact ( N , P ) : NEW_LINE INDENT ret = [ 1 ] * ( N + 1 ) NEW_LINE for n in range ( 2 , N + 1 ) : NEW_LINE INDENT ret [ n ] = ( ret [ n - 1 ] * n ) % P NEW_LINE DEDENT return ret NEW_LINE DEDENT def pow_r ( a , b , P ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if b % 2 == 0 : NEW_LINE INDENT return pow_r ( ( a ** 2 ) % P , b \/\/ 2 , P ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( a * pow_r ( ( a ** 2 ) % P , ( b - 1 ) \/\/ 2 , P ) ) % P NEW_LINE DEDENT DEDENT def inv_fact ( N , P ) : NEW_LINE INDENT ret = [ 1 ] * ( N + 1 ) NEW_LINE fac = fact ( N , P ) NEW_LINE ret [ N ] = pow_r ( fac [ N ] , P - 2 , P ) NEW_LINE for n in reversed ( range ( 2 , N ) ) : NEW_LINE INDENT ret [ n ] = ( ret [ n + 1 ] * ( n + 1 ) ) % P NEW_LINE DEDENT return ret NEW_LINE DEDENT fac = fact ( N , P ) NEW_LINE inv = inv_fact ( N , P ) NEW_LINE def combination ( n , r , P ) : NEW_LINE INDENT return ( fac [ n ] * inv [ r ] * inv [ n - r ] ) % P NEW_LINE DEDENT sub = 0 NEW_LINE for a in range ( A ) : NEW_LINE INDENT sub = ( sub + combination ( ( H - 1 - a ) + ( B - 1 ) , B - 1 , P ) * combination ( a + ( W - 1 - B ) , a , P ) ) % P NEW_LINE DEDENT print ( ( combination ( ( H - 1 ) + ( W - 1 ) , H - 1 , P ) - sub ) % P ) NEW_LINE","MOD = 1000000007 NEW_LINE H , W , A , B = map ( int , input ( ) . split ( ) ) NEW_LINE if H - A > W - B : NEW_LINE INDENT H , W = W , H NEW_LINE A , B = B , A NEW_LINE DEDENT ans1 = [ 1 ] NEW_LINE for i in range ( H - A - 1 ) : NEW_LINE INDENT ans1 . append ( ( ans1 [ - 1 ] * ( H - A - 1 + B - i ) * pow ( i + 1 , MOD - 2 , MOD ) ) % MOD ) NEW_LINE DEDENT c = 1 NEW_LINE for i in range ( W - H + A - B ) : NEW_LINE INDENT c = ( c * ( W - B - 1 + A - i ) * pow ( i + 1 , MOD - 2 , MOD ) ) % MOD NEW_LINE DEDENT ans = c NEW_LINE for i in range ( H - A - 1 ) : NEW_LINE INDENT c = ( c * ( H - 1 - i ) * pow ( W - H + A - B + 1 + i , MOD - 2 , MOD ) ) % MOD NEW_LINE ans = ( ans + c * ans1 [ i + 1 ] ) % MOD NEW_LINE DEDENT print ( ans ) NEW_LINE","class BigCombination ( object ) : NEW_LINE INDENT __slots__ = [ \" mod \" , \" inverse _ mod \" , \" factorial \" , \" inverse _ memo \" ] NEW_LINE def __init__ ( self , mod : int = 10 ** 9 + 7 , max_n : int = 10 ** 6 ) : NEW_LINE INDENT from itertools import accumulate NEW_LINE self . mod = mod NEW_LINE self . inverse_mod = tuple ( map ( int , bin ( mod - 2 ) [ : 1 : - 1 ] ) ) NEW_LINE self . factorial = [ 1 ] + list ( accumulate ( range ( 1 , max_n + 1 ) , lambda x , y : x * y % mod ) ) NEW_LINE self . inverse_memo = { } NEW_LINE DEDENT def get_inverse ( self , x : int ) : NEW_LINE INDENT x = self . factorial [ x ] NEW_LINE if x not in self . inverse_memo : NEW_LINE INDENT result , _x , mod = 1 , x , self . mod NEW_LINE for bit in self . inverse_mod : NEW_LINE INDENT if bit : NEW_LINE INDENT result = result * _x % mod NEW_LINE DEDENT _x = _x * _x % mod NEW_LINE DEDENT self . inverse_memo [ x ] = result NEW_LINE DEDENT return self . inverse_memo [ x ] NEW_LINE DEDENT def get_combination ( self , n , r ) : NEW_LINE INDENT return self . factorial [ n ] * self . get_inverse ( r ) * self . get_inverse ( n - r ) % self . mod NEW_LINE DEDENT DEDENT H , W , A , B = map ( int , input ( ) . split ( ) ) NEW_LINE mod = 10 ** 9 + 7 NEW_LINE big_comb = BigCombination ( max_n = 2 * 10 ** 5 ) NEW_LINE comb = big_comb . get_combination NEW_LINE _A = H - A - 1 NEW_LINE print ( sum ( comb ( x + _A , x ) * comb ( W - x - 1 + A - 1 , A - 1 ) % mod for x in range ( B , W ) ) % mod ) NEW_LINE"],"bleu":0.2735983146410702,"rouge_l":0.3136274705688021}
{"id":42,"predictions":["n , l = map ( int , input ( ) . split ( ) ) NEW_LINE R = [ 0 ] * n NEW_LINE L = [ 0 ] * n NEW_LINE for i in range ( l , r ) : NEW_LINE INDENT R [ i ] = i NEW_LINE DEDENT s = set ( ) NEW_LINE for i in range ( l - 1 , - 1 , - 1 ) : NEW_LINE INDENT L [ s . index ( i ) ] = l . index ( i ) NEW_LINE DEDENT print ( len ( L ) ) NEW_LINE"],"references":["from collections import Counter NEW_LINE L , R = map ( int , input ( ) . split ( ) ) NEW_LINE inputs_l = Counter ( [ int ( i ) for i in input ( ) . split ( ) ] ) NEW_LINE inputs_r = Counter ( [ int ( i ) for i in input ( ) . split ( ) ] ) NEW_LINE print ( sum ( [ min ( inputs_r [ key ] , value ) for key , value in inputs_l . items ( ) ] ) ) NEW_LINE","import sys NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE input = sys . stdin . readline NEW_LINE L , R = map ( int , input ( ) . split ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE r = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l = sorted ( l ) NEW_LINE r = sorted ( r ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE ans = 0 NEW_LINE while i < L and j < R : NEW_LINE INDENT if l [ i ] == r [ j ] : NEW_LINE INDENT ans += 1 NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT elif l [ i ] > r [ j ] : NEW_LINE INDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE","d = input ( ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE r = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = 0 NEW_LINE for i in range ( 10 , 41 ) : NEW_LINE INDENT c += min ( l . count ( i ) , r . count ( i ) ) NEW_LINE DEDENT print ( c ) NEW_LINE"],"bleu":0.37683256938744647,"rouge_l":0.5044040985079994}
{"id":43,"predictions":["import sys NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE input = sys . stdin . readline NEW_LINE N = int ( input ( ) ) NEW_LINE ans = 1 NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT ans = max ( ans , i - 1 ) NEW_LINE DEDENT print ( ans ) NEW_LINE"],"references":["x = int ( input ( ) ) NEW_LINE y = [ ] NEW_LINE for i in range ( 1 , 33 ) : NEW_LINE INDENT for j in range ( 2 , 11 ) : NEW_LINE INDENT y . append ( i ** j ) NEW_LINE DEDENT DEDENT ans = 1 NEW_LINE for i in y : NEW_LINE INDENT if i <= x : NEW_LINE INDENT ans = max ( ans , i ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE","x = int ( input ( ) ) NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if n % 2 == 0 or n % 3 == 0 : return True NEW_LINE if n < 3 : return False NEW_LINE for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : NEW_LINE INDENT if n % i == 0 : return False NEW_LINE DEDENT return True NEW_LINE DEDENT primes = [ i for i in range ( 1 , 32 ) if isPrime ( i ) ] NEW_LINE def isExp ( n ) : NEW_LINE INDENT if n == 1 : return True NEW_LINE for i in [ p for p in primes if p < int ( n ** 0.5 ) + 1 ] : NEW_LINE INDENT p = 0 NEW_LINE while i ** p <= n : NEW_LINE INDENT if i ** p == n : return True NEW_LINE p += 1 NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT for i in range ( x , 0 , - 1 ) : NEW_LINE INDENT if isExp ( i ) : return i NEW_LINE DEDENT DEDENT print ( solve ( ) ) NEW_LINE","X = int ( input ( ) ) NEW_LINE r = int ( X ** 0.5 ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , r + 1 ) : NEW_LINE INDENT a = 0 NEW_LINE for j in range ( 1 , 11 ) : NEW_LINE INDENT if i ** j <= X : NEW_LINE INDENT a = i ** j NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT ans = max ( ans , a ) NEW_LINE DEDENT print ( ans ) NEW_LINE"],"bleu":0.4537398053125331,"rouge_l":0.4831941768357953}
{"id":44,"predictions":["import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE inf = 10 ** 20 NEW_LINE eps = 1.0 \/ 10 ** 10 NEW_LINE mod = 10 ** 9 + 7 NEW_LINE dd = [ ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) ] NEW_LINE ddn = [ ( - 1 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) , ( 1 , 0 ) , ( 1 , - 1 ) , ( 0 , - 1 ) , ( - 1 , - 1 ) ] NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def F ( ) : return float ( sys . stdin . readline ( ) ) NEW_LINE def pf ( s ) : return print ( s , flush = True ) NEW_LINE N = I ( ) NEW_LINE A = [ I ( ) for i in range ( N ) ] NEW_LINE counts = collections . Counter ( A ) NEW_LINE ans = - 1 \/ 2 NEW_LINE if N == 1 : NEW_LINE INDENT ans = 1 NEW_LINE break NEW_LINE DEDENT if ans == - 1 : NEW_LINE INDENT ans = - 1 NEW_LINE print ( ans ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT"],"references":["a = [ int ( input ( ) ) for _ in [ 0 ] * int ( input ( ) ) ] * 2 NEW_LINE if len ( set ( a ) ) < 2 : NEW_LINE INDENT print ( - 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT b = c = m = 0 NEW_LINE for i in a : NEW_LINE INDENT if i : NEW_LINE INDENT b += 1 NEW_LINE m = max ( m , b , c ) NEW_LINE c = 0 NEW_LINE DEDENT else : NEW_LINE INDENT c += 1 NEW_LINE m = max ( m , b , c ) NEW_LINE b = 0 NEW_LINE DEDENT DEDENT print ( ~ - m \/\/ 2 + 1 ) NEW_LINE","def b_trees ( N , Color ) : NEW_LINE INDENT if len ( set ( Color ) ) == 1 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT color_cycle = Color + Color NEW_LINE color_continuity = 1 NEW_LINE tmp_continuity = 1 NEW_LINE for k in range ( N * 2 ) : NEW_LINE INDENT if color_cycle [ k ] == color_cycle [ k - 1 ] : NEW_LINE INDENT tmp_continuity += 1 NEW_LINE DEDENT else : NEW_LINE INDENT color_continuity = max ( color_continuity , tmp_continuity ) NEW_LINE tmp_continuity = 1 NEW_LINE DEDENT DEDENT ans = ( ( color_continuity - 1 ) \/\/ 2 ) + 1 NEW_LINE return ans NEW_LINE DEDENT N = int ( input ( ) ) NEW_LINE Color = [ int ( input ( ) ) for _ in [ 0 ] * N ] NEW_LINE print ( b_trees ( N , Color ) ) NEW_LINE","N = int ( input ( ) ) NEW_LINE cl = [ int ( input ( ) ) for i in range ( N ) ] NEW_LINE ans = 1 NEW_LINE renzoku1 = 1 NEW_LINE score = 1 NEW_LINE renzoku = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT if ( cl [ 0 ] == cl [ 1 ] ) : NEW_LINE INDENT renzoku1 = 2 NEW_LINE renzoku = 1 NEW_LINE DEDENT DEDENT elif ( renzoku == 1 ) : NEW_LINE INDENT if ( i == N - 1 ) : NEW_LINE INDENT if ( cl [ i ] == cl [ 0 ] ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( N \/\/ 2 ) NEW_LINE DEDENT quit ( ) NEW_LINE DEDENT if ( cl [ i ] == cl [ i + 1 ] ) : NEW_LINE INDENT renzoku1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT renzoku = 0 NEW_LINE DEDENT DEDENT elif ( renzoku == 0 ) : NEW_LINE INDENT if ( i == N - 1 ) : NEW_LINE INDENT if ( cl [ i ] == cl [ 0 ] ) : NEW_LINE INDENT score += renzoku1 NEW_LINE ans = max ( ans , score ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( score , max ( ans , renzoku1 ) ) NEW_LINE DEDENT DEDENT elif ( cl [ i ] == cl [ i + 1 ] ) : NEW_LINE INDENT score += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( ans , score ) NEW_LINE score = 1 NEW_LINE DEDENT DEDENT DEDENT if ( ans == 2 ) : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( ans + 1 ) \/\/ 2 ) NEW_LINE DEDENT"],"bleu":0.16999400100405215,"rouge_l":0.36888573440058775}
{"id":45,"predictions":["def inpl ( ) : return [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE N , A = inpl ( ) NEW_LINE if A [ 0 ] in A : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE N = int ( input ( ) ) NEW_LINE NG1 = int ( input ( ) ) NEW_LINE NG2 = int ( input ( ) ) NEW_LINE NG3 = int ( input ( ) ) NEW_LINE if N == NG1 or N == NG2 or N == NG3 : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE sys . exit ( ) NEW_LINE DEDENT queue = [ ] NEW_LINE queue . append ( ( 0 , N ) ) NEW_LINE judge = [ ] NEW_LINE while queue : NEW_LINE INDENT a = queue . pop ( 0 ) NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT b = a [ 1 ] - [ 1 , 2 , 3 ] [ i ] NEW_LINE if b != NG1 and b != NG2 and b != NG3 and a [ 0 ] < 100 : NEW_LINE INDENT num = ( a [ 0 ] + 1 , b ) NEW_LINE if b > 0 and num [ 0 ] < 100 and num not in judge and ( 100 - num [ 0 ] ) * 3 >= b : NEW_LINE INDENT queue . append ( num ) NEW_LINE judge . append ( num ) NEW_LINE DEDENT elif b == 0 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE sys . exit ( ) NEW_LINE DEDENT else : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( ' NO ' ) NEW_LINE","n = int ( input ( ) ) NEW_LINE ng = list ( [ int ( input ( ) ) for i in range ( 3 ) ] ) NEW_LINE dp = [ float ( \" inf \" ) ] * 301 NEW_LINE dp [ n ] = 0 NEW_LINE for i in range ( n , - 1 , - 1 ) : NEW_LINE INDENT if i in ng : NEW_LINE INDENT continue NEW_LINE DEDENT for j in range ( 1 , 4 ) : NEW_LINE INDENT dp [ i - j ] = min ( dp [ i ] + 1 , dp [ i - j ] ) NEW_LINE DEDENT DEDENT print ( \" YES \" if dp [ 0 ] <= 100 else \" NO \" ) NEW_LINE","n = int ( input ( ) ) NEW_LINE m = [ ] NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT m . append ( int ( input ( ) ) ) NEW_LINE DEDENT ret = \" YES \" NEW_LINE if n in m : NEW_LINE INDENT ret = \" NO \" NEW_LINE DEDENT else : NEW_LINE INDENT m . sort ( ) NEW_LINE if n == 300 : NEW_LINE INDENT if [ i for i in m if i % 3 == 0 ] : NEW_LINE INDENT ret = \" NO \" NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT tmp = ( m [ 2 ] - m [ 1 ] ) * ( m [ 1 ] - m [ 0 ] ) NEW_LINE if m [ 2 ] < n and tmp == 1 : NEW_LINE INDENT ret = \" NO \" NEW_LINE DEDENT elif n == 299 : NEW_LINE INDENT if tmp == 4 : NEW_LINE INDENT ret = \" NO \" NEW_LINE DEDENT elif max ( m [ 2 ] % 3 , m [ 1 ] % 3 ) == 2 and m [ 1 ] % 3 * m [ 0 ] % 3 == 0 : NEW_LINE INDENT ret = \" NO \" NEW_LINE DEDENT elif m [ 2 ] % 3 == 0 and m [ 2 ] - m [ 1 ] == 1 : NEW_LINE INDENT ret = \" NO \" NEW_LINE DEDENT elif m [ 1 ] % 3 == 0 and m [ 1 ] - m [ 0 ] == 1 : NEW_LINE INDENT ret = \" NO \" NEW_LINE DEDENT DEDENT elif n == 298 : NEW_LINE INDENT if m [ 0 ] - m [ 1 ] == 1 and m [ 0 ] % 3 == 0 : NEW_LINE INDENT ret = \" NO \" NEW_LINE DEDENT elif m [ 2 ] % 3 == 1 and tmp == 4 : NEW_LINE INDENT ret = \" NO \" NEW_LINE DEDENT elif m [ 2 ] % 3 == 1 and m [ 1 ] % 3 == 0 and m [ 1 ] - m [ 0 ] == 1 : NEW_LINE INDENT ret = \" NO \" NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( ret ) NEW_LINE"],"bleu":0.15582270020061242,"rouge_l":0.3624275003536568}
{"id":46,"predictions":["n , m = [ int ( item ) for item in input ( ) . split ( ) ] NEW_LINE edge = [ [ ] for _ in range ( n ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT a , b = [ int ( item ) for item in input ( ) . split ( ) ] NEW_LINE edge [ a ] . append ( b ) NEW_LINE edge [ b ] . append ( a ) NEW_LINE DEDENT def dfs ( s , v ) : NEW_LINE INDENT visited = [ False ] * n NEW_LINE visited [ s ] = True NEW_LINE for edge [ s ] [ 0 ] : NEW_LINE INDENT if not visited [ s ] : NEW_LINE INDENT dfs ( edge [ s ] ) NEW_LINE DEDENT if not visited [ s ] : NEW_LINE INDENT dfs ( edge [ s ] ) NEW_LINE visited [ s ] = True NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT edge = [ [ ] for _ in range ( n ) ] NEW_LINE ans = 0 NEW_LINE for i in edge [ s ] : NEW_LINE INDENT if visited [ s ] : NEW_LINE INDENT dfs ( i , graph [ s ] ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["N , M = ( int ( _ ) for _ in input ( ) . split ( ) ) NEW_LINE E = [ ] NEW_LINE V = [ [ i + 1 , 0 ] for i in range ( N ) ] NEW_LINE searched_vertex = [ ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT u , v = ( int ( _ ) for _ in input ( ) . split ( ) ) NEW_LINE E . append ( [ u , v , True ] ) NEW_LINE DEDENT cnt_trees = 0 NEW_LINE def find_tree ( vertex ) : NEW_LINE INDENT flag = True NEW_LINE index , reached = vertex NEW_LINE if reached == 0 : NEW_LINE INDENT V [ index - 1 ] [ 1 ] = 1 NEW_LINE DEDENT searched_vertex . append ( index ) NEW_LINE while searched_vertex : NEW_LINE INDENT i = searched_vertex [ len ( searched_vertex ) - 1 ] NEW_LINE for edge_index in range ( len ( E ) ) : NEW_LINE INDENT u , v , unused = E [ edge_index ] NEW_LINE if unused : NEW_LINE INDENT if u == i : NEW_LINE INDENT E [ edge_index ] [ 2 ] = False NEW_LINE for ind in range ( len ( searched_vertex ) ) : NEW_LINE INDENT if v == searched_vertex [ ind ] : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT V [ v - 1 ] [ 1 ] = 1 NEW_LINE searched_vertex . append ( v ) NEW_LINE break NEW_LINE DEDENT DEDENT elif v == i : NEW_LINE INDENT E [ edge_index ] [ 2 ] = False NEW_LINE for ind in range ( len ( searched_vertex ) ) : NEW_LINE INDENT if u == searched_vertex [ ind ] : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT V [ u - 1 ] [ 1 ] = 1 NEW_LINE searched_vertex . append ( u ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT else : NEW_LINE INDENT searched_vertex . pop ( ) NEW_LINE DEDENT DEDENT return flag NEW_LINE DEDENT for index , reached in V : NEW_LINE INDENT if reached == 0 : NEW_LINE INDENT for j in range ( len ( E ) ) : NEW_LINE INDENT E [ j ] [ 2 ] = True NEW_LINE DEDENT if find_tree ( ( index , reached ) ) : NEW_LINE INDENT cnt_trees += 1 NEW_LINE DEDENT DEDENT DEDENT print ( cnt_trees ) NEW_LINE","import sys NEW_LINE input = sys . stdin . readline NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE par = [ ] NEW_LINE rank = [ 0 ] * n NEW_LINE judge = [ True ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT par . append ( i ) NEW_LINE DEDENT def find ( x , par ) : NEW_LINE INDENT if par [ x ] == x : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT return find ( par [ x ] , par ) NEW_LINE DEDENT DEDENT def unite ( x , y , par , rank ) : NEW_LINE INDENT x = find ( x , par ) NEW_LINE y = find ( y , par ) NEW_LINE if x == y : NEW_LINE INDENT judge [ x ] = False NEW_LINE DEDENT if x != y : NEW_LINE INDENT if rank [ x ] < rank [ y ] : NEW_LINE INDENT if not judge [ x ] : NEW_LINE INDENT judge [ y ] = False NEW_LINE DEDENT par [ x ] = y NEW_LINE judge [ x ] = False NEW_LINE DEDENT else : NEW_LINE INDENT if not judge [ y ] : NEW_LINE INDENT judge [ x ] = False NEW_LINE DEDENT par [ y ] = x NEW_LINE judge [ y ] = False NEW_LINE if rank [ x ] == rank [ y ] : NEW_LINE INDENT rank [ x ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT def same ( x , y , par ) : NEW_LINE INDENT return find ( x , par ) == find ( y , par ) NEW_LINE DEDENT def same ( x , y , par ) : NEW_LINE INDENT return find ( x , par ) == find ( y , par ) NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT u , v = map ( int , input ( ) . split ( ) ) NEW_LINE u , v = u - 1 , v - 1 NEW_LINE unite ( u , v , par , rank ) NEW_LINE DEDENT res = 0 NEW_LINE for e in judge : NEW_LINE INDENT if e : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE","import sys NEW_LINE read = sys . stdin . readline NEW_LINE sys . setrecursionlimit ( 1 << 25 ) NEW_LINE def readln ( ) : NEW_LINE INDENT return list ( map ( int , read ( ) . split ( ) ) ) NEW_LINE DEDENT N , M = readln ( ) NEW_LINE visited = [ False ] * N NEW_LINE from collections import defaultdict NEW_LINE edge = defaultdict ( lambda : set ( ) ) NEW_LINE for _ in range ( M ) : NEW_LINE INDENT u , v = readln ( ) NEW_LINE edge [ v - 1 ] . add ( u - 1 ) NEW_LINE edge [ u - 1 ] . add ( v - 1 ) NEW_LINE DEDENT def dfs ( node , prev ) : NEW_LINE INDENT if visited [ node ] : NEW_LINE INDENT return 0 NEW_LINE DEDENT visited [ node ] = True NEW_LINE for n in edge [ node ] : NEW_LINE INDENT if n == prev : NEW_LINE INDENT continue NEW_LINE DEDENT if dfs ( n , node ) == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if not visited [ i ] : NEW_LINE INDENT ans += dfs ( i , - 1 ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"bleu":0.482293898593506,"rouge_l":0.533162094807964}
{"id":47,"predictions":["a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( b - a + b ) ) NEW_LINE"],"references":["R = int ( input ( ) ) NEW_LINE G = int ( input ( ) ) NEW_LINE print ( 2 * G - R ) NEW_LINE","r , g = map ( int , open ( 0 ) ) ; print ( 2 * g - r ) NEW_LINE","current_rate = int ( input ( ) ) NEW_LINE target = int ( input ( ) ) NEW_LINE print ( target * 2 - current_rate ) NEW_LINE"],"bleu":0.4194221477808667,"rouge_l":0.5589005235602095}
{"id":48,"predictions":["a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( - 1 ) * b * 1 ) NEW_LINE"],"references":["a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( a - 1 ) * ( b - 1 ) ) NEW_LINE","import numpy as np NEW_LINE class Calculator : NEW_LINE INDENT def __init__ ( self , arr ) : NEW_LINE INDENT self . arr = arr NEW_LINE DEDENT def get_result ( self ) : NEW_LINE INDENT return ( self . arr [ 0 ] - 1 ) * ( self . arr [ 1 ] - 1 ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT A , B , = map ( int , input ( ) . split ( ) ) NEW_LINE arr = np . array ( [ A , B ] , dtype = int ) NEW_LINE calc = Calculator ( arr ) NEW_LINE print ( calc . get_result ( ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT","def main ( ) : NEW_LINE INDENT A , B = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( A - 1 ) * ( B - 1 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"bleu":0.7429187078320055,"rouge_l":0.9099627064464572}
{"id":49,"predictions":["H , W = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE for i in range ( H ) : NEW_LINE INDENT for j in range ( W ) : NEW_LINE INDENT s [ i ] = s [ j ] NEW_LINE DEDENT DEDENT for i in range ( H ) : NEW_LINE INDENT for j in range ( i + 1 , W ) : NEW_LINE INDENT print ( s [ i ] [ j ] , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT"],"references":["import sys , re NEW_LINE from collections import deque , defaultdict , Counter NEW_LINE from math import ceil , sqrt , hypot , factorial , pi , sin , cos , radians NEW_LINE from itertools import permutations , combinations , product NEW_LINE from operator import itemgetter , mul NEW_LINE from copy import deepcopy NEW_LINE from string import ascii_lowercase , ascii_uppercase , digits NEW_LINE def input ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def INT ( ) : return int ( input ( ) ) NEW_LINE def MAP ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE INF = float ( ' inf ' ) NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE H , W = MAP ( ) NEW_LINE C = [ input ( ) for _ in range ( H ) ] NEW_LINE for x in C : NEW_LINE INDENT print ( x ) NEW_LINE print ( x ) NEW_LINE DEDENT","_ , * t = open ( 0 ) NEW_LINE for i in t : print ( i + i ) NEW_LINE","import sys , os NEW_LINE f = lambda : list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def init ( ) : NEW_LINE INDENT if ' local ' in os . environ : NEW_LINE INDENT sys . stdin = open ( ' . \/ input . txt ' , ' r ' ) NEW_LINE DEDENT DEDENT def solve ( ) : NEW_LINE INDENT n , m = f ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT a = input ( ) NEW_LINE print ( a ) NEW_LINE print ( a ) NEW_LINE DEDENT DEDENT init ( ) NEW_LINE solve ( ) NEW_LINE"],"bleu":0.43428588993138756,"rouge_l":0.5962282954501896}
{"id":50,"predictions":["import math NEW_LINE N = int ( input ( ) ) NEW_LINE A = [ set ( ) for _ in range ( N ) ] NEW_LINE print ( len ( set ( A ) ) ) NEW_LINE"],"references":["print ( len ( set ( [ input ( ) for _ in range ( int ( input ( ) ) ) ] ) ) ) NEW_LINE","N = int ( input ( ) ) NEW_LINE di = [ int ( input ( ) ) for n in range ( N ) ] NEW_LINE di = sorted ( di , reverse = True ) NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if i < N - 1 and di [ i ] == di [ i + 1 ] : NEW_LINE INDENT i = i + 1 NEW_LINE continue NEW_LINE DEDENT ans += 1 NEW_LINE DEDENT print ( ans ) NEW_LINE","import sys NEW_LINE unique_list = [ ] NEW_LINE input_list = sys . stdin . readlines ( ) [ 1 : ] NEW_LINE for i in input_list : NEW_LINE INDENT if i not in unique_list : NEW_LINE INDENT unique_list . append ( i ) NEW_LINE DEDENT DEDENT print ( len ( unique_list ) ) NEW_LINE"],"bleu":0.6749358273702123,"rouge_l":0.6270013836726626}
{"id":51,"predictions":["import sys NEW_LINE ns = lambda : sys . stdin . readline ( ) . rstrip ( ) NEW_LINE ni = lambda : int ( ns ( ) ) NEW_LINE nm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE nl = lambda : list ( nm ( ) ) NEW_LINE s = ns ( ) NEW_LINE ans = [ ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT ans . append ( s [ : - 1 ] ) NEW_LINE DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT ans . append ( s [ i ] ) NEW_LINE DEDENT for i in range ( len ( ans ) ) : NEW_LINE INDENT if ans [ i ] == 0 : NEW_LINE INDENT ans [ i ] = i - 1 NEW_LINE DEDENT DEDENT print ( ans [ : - 1 ] ) NEW_LINE"],"references":["n = int ( input ( ) ) NEW_LINE print ( 111 + 999 - n ) NEW_LINE","n = input ( ) NEW_LINE num_list = list ( n ) NEW_LINE num_list = [ int ( i ) for i in num_list ] NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT if num_list [ i ] == 1 : NEW_LINE INDENT num_list [ i ] = 9 NEW_LINE DEDENT elif num_list [ i ] == 9 : NEW_LINE INDENT num_list [ i ] = 1 NEW_LINE DEDENT DEDENT print ( ' ' . join ( [ str ( i ) for i in num_list ] ) ) NEW_LINE","S = input ( ) NEW_LINE res = \" \" NEW_LINE for i in S : NEW_LINE INDENT if i == \"9\" : NEW_LINE INDENT res += \"1\" NEW_LINE DEDENT elif i == \"1\" : NEW_LINE INDENT res += \"9\" NEW_LINE DEDENT else : NEW_LINE INDENT res += i NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE"],"bleu":0.19758343824264313,"rouge_l":0.4645325059935129}
{"id":52,"predictions":["def gcd ( x , y ) : NEW_LINE INDENT if y == 0 : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( x , y ) NEW_LINE DEDENT DEDENT def gcd ( x , y ) : NEW_LINE INDENT if x < 0 : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( x , y ) NEW_LINE DEDENT DEDENT X = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE Y = gcd ( X , Y ) NEW_LINE if X == 0 : NEW_LINE INDENT print ( \" Impossible \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Impossible \" ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE from collections import defaultdict , Counter NEW_LINE from itertools import product , groupby , count , permutations , combinations NEW_LINE from math import pi , sqrt , ceil , floor NEW_LINE from collections import deque NEW_LINE from bisect import bisect , bisect_left , bisect_right NEW_LINE from string import ascii_lowercase NEW_LINE INF = float ( \" inf \" ) NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE dy = [ 0 , - 1 , 0 , 1 ] NEW_LINE dx = [ 1 , 0 , - 1 , 0 ] NEW_LINE def inside ( y : int , x : int , H : int , W : int ) -> bool : return 0 <= y < H and 0 <= x < W NEW_LINE def main ( ) : NEW_LINE INDENT X , Y = map ( int , input ( ) . split ( \" \/ \" ) ) NEW_LINE ans_list = [ ] NEW_LINE for n in range ( max ( 0 , 2 * X \/\/ Y - 10 ) , 2 * X \/\/ Y + 10 ) : NEW_LINE INDENT a = n * ( Y + n * Y - 2 * X ) NEW_LINE if a % ( 2 * Y ) == 0 : NEW_LINE INDENT m = a \/\/ ( 2 * Y ) NEW_LINE if 0 < m <= n : NEW_LINE INDENT ans_list . append ( \" { 0 } ▁ { 1 } \" . format ( n , m ) ) NEW_LINE DEDENT DEDENT DEDENT if ans_list : NEW_LINE INDENT print ( * ans_list , sep = \" \\n \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Impossible \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT","def gcd ( a , b ) : NEW_LINE INDENT return a if b == 0 else gcd ( b , a % b ) NEW_LINE DEDENT x , y = map ( int , input ( ) . split ( \" \/ \" ) ) NEW_LINE k = gcd ( x , y ) NEW_LINE x \/\/= k ; y \/\/= k ; NEW_LINE flag = False NEW_LINE for i in range ( ( 2 * x ) \/\/ ( y ** 2 ) - 1 , 10000000000000 ) : NEW_LINE INDENT n = i * y NEW_LINE m = ( n * ( n + 1 ) ) \/\/ 2 - i * x NEW_LINE if ( n <= 0 or m <= 0 ) : continue NEW_LINE if ( n < m ) : break NEW_LINE print ( n , m ) NEW_LINE flag = True NEW_LINE DEDENT if ( not flag ) : print ( \" Impossible \" ) NEW_LINE","import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE inf = 10 ** 20 NEW_LINE gosa = 1.0 \/ 10 ** 10 NEW_LINE mod = 10 ** 9 + 7 NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def F ( ) : return float ( sys . stdin . readline ( ) ) NEW_LINE def S ( ) : return input ( ) NEW_LINE def main ( ) : NEW_LINE INDENT x , y = [ int ( x ) for x in sys . stdin . readline ( ) . split ( ' \/ ' ) ] NEW_LINE g = fractions . gcd ( x , y ) NEW_LINE x \/\/= g NEW_LINE y \/\/= g NEW_LINE it = int ( x \/ y ) * 2 NEW_LINE r = [ ] NEW_LINE for i in range ( max ( 1 , it - 10 ) , it + 10 ) : NEW_LINE INDENT k = ( i + 1 ) * i \/\/ 2 NEW_LINE if i % y != 0 : NEW_LINE INDENT continue NEW_LINE DEDENT t = k - ( i \/\/ y ) * x NEW_LINE if 0 < t <= i : NEW_LINE INDENT r . append ( [ i , t ] ) NEW_LINE DEDENT DEDENT if r : NEW_LINE INDENT return ' \\n ' . join ( [ ' ▁ ' . join ( map ( str , _ ) ) for _ in r ] ) NEW_LINE DEDENT return ' Impossible ' NEW_LINE DEDENT print ( main ( ) ) NEW_LINE"],"bleu":0.3823334155042095,"rouge_l":0.4205684414167816}
{"id":53,"predictions":["import sys NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE input = sys . stdin . readline NEW_LINE N , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE for l in range ( N ) : NEW_LINE INDENT if a < b : NEW_LINE INDENT ans += l * 10 NEW_LINE DEDENT else : NEW_LINE INDENT ans += b NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["N , A , B = map ( int , input ( ) . split ( \" ▁ \" ) ) NEW_LINE total = 0 NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT sum = 0 NEW_LINE temp = i NEW_LINE for m in range ( 5 ) : NEW_LINE INDENT sum += temp % 10 NEW_LINE temp = temp \/\/ 10 NEW_LINE DEDENT if A <= sum and sum <= B : NEW_LINE INDENT total += i NEW_LINE DEDENT DEDENT print ( total ) NEW_LINE","import sys NEW_LINE input = sys . stdin . readline NEW_LINE def io_generator ( ) : NEW_LINE INDENT return input ( ) NEW_LINE DEDENT def bbs ( v ) : NEW_LINE INDENT s = [ int ( ci ) for ci in list ( str ( v ) ) ] NEW_LINE return sum ( s ) NEW_LINE DEDENT def main ( io ) : NEW_LINE INDENT n , a , b = map ( int , io ( ) . split ( ) ) NEW_LINE return sum ( [ x for x in range ( 1 , n + 1 ) if a <= bbs ( x ) and bbs ( x ) <= b ] ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT io = lambda : io_generator ( ) NEW_LINE print ( main ( io ) ) NEW_LINE DEDENT","listNAB = input ( ) . split ( ) NEW_LINE listNABint = [ int ( s ) for s in listNAB ] NEW_LINE def Placesum ( x ) : NEW_LINE INDENT y = str ( x ) NEW_LINE counter = 0 NEW_LINE for i in range ( len ( y ) ) : NEW_LINE INDENT counter += int ( y [ i ] ) NEW_LINE DEDENT return counter NEW_LINE DEDENT sumcounter = 0 NEW_LINE for i in range ( listNABint [ 0 ] ) : NEW_LINE INDENT if listNABint [ 1 ] <= Placesum ( i + 1 ) & Placesum ( i + 1 ) <= listNABint [ 2 ] : NEW_LINE INDENT sumcounter += i + 1 NEW_LINE DEDENT DEDENT print ( sumcounter ) NEW_LINE"],"bleu":0.4842618601284665,"rouge_l":0.5383026661659782}
{"id":54,"predictions":["print ( input ( ) . replace ( \" ▁ \" , \" \" ) ) NEW_LINE"],"references":["s = input ( ) NEW_LINE a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE print ( s [ 0 : a ] + ' \" ' + s [ a : b ] + ' \" ' + s [ b : c ] + ' \" ' + s [ c : d ] + ' \" ' + s [ d : ] ) NEW_LINE","def main ( ) : NEW_LINE INDENT s = input ( ) NEW_LINE a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE l = [ c for c in s ] NEW_LINE l . insert ( d , ' \" ' ) NEW_LINE l . insert ( c , ' \" ' ) NEW_LINE l . insert ( b , ' \" ' ) NEW_LINE l . insert ( a , ' \" ' ) NEW_LINE print ( \" \" . join ( l ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT","s = input ( ) + \" ▁ \" NEW_LINE num = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE t = \" \" NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if i in num : NEW_LINE INDENT t += \" \\ \" \" NEW_LINE DEDENT t += s [ i ] NEW_LINE DEDENT print ( t [ : - 1 ] ) NEW_LINE"],"bleu":0.01041309216632418,"rouge_l":0.22815923056371895}
{"id":55,"predictions":["import sys NEW_LINE def main ( ) : NEW_LINE INDENT input = sys . stdin . readline NEW_LINE N = int ( input ( ) ) NEW_LINE tmp = 0 NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT for j in range ( 4 ) : NEW_LINE INDENT if i + j == N : NEW_LINE INDENT tmp += 1 NEW_LINE DEDENT DEDENT DEDENT if tmp == N : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"references":["N = int ( input ( ) ) NEW_LINE for cake in range ( 26 ) : NEW_LINE INDENT flag = False NEW_LINE for donut in range ( 15 ) : NEW_LINE INDENT if 4 * cake + 7 * donut == N : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE flag = True NEW_LINE break NEW_LINE DEDENT DEDENT if flag : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT","from collections import defaultdict NEW_LINE from string import ascii_uppercase NEW_LINE import sys , bisect , math NEW_LINE stdin = sys . stdin NEW_LINE read_int = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) NEW_LINE read_str = lambda : stdin . readline ( ) . rstrip ( ) NEW_LINE N = read_int ( ) [ 0 ] NEW_LINE l = [ False for _ in range ( N + 1 ) ] NEW_LINE def solve ( ) : NEW_LINE INDENT ans = 0 NEW_LINE l [ 0 ] = True NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT if l [ i ] and i + 4 < N + 1 : NEW_LINE INDENT l [ i + 4 ] = True NEW_LINE DEDENT DEDENT for i in range ( N + 1 ) : NEW_LINE INDENT if l [ i ] and i + 7 < N + 1 : NEW_LINE INDENT l [ i + 7 ] = True NEW_LINE DEDENT DEDENT return l [ N ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT if solve ( ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT","def main ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE dp = [ False ] * ( 101 ) NEW_LINE dp [ 0 ] = True NEW_LINE dp [ 4 ] = True NEW_LINE dp [ 7 ] = True NEW_LINE for i in range ( 4 , 101 ) : NEW_LINE INDENT if i + 7 <= 100 : NEW_LINE INDENT dp [ i + 7 ] = dp [ i + 7 ] or dp [ i ] NEW_LINE DEDENT if i + 4 <= 100 : NEW_LINE INDENT dp [ i + 4 ] = dp [ i + 4 ] or dp [ i ] NEW_LINE DEDENT DEDENT if dp [ N ] : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"bleu":0.7555105748853088,"rouge_l":0.6703634003240513}
{"id":56,"predictions":["a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a > b : NEW_LINE INDENT print ( \" strange \" ) NEW_LINE DEDENT elif a + b < a : NEW_LINE INDENT print ( \" strange \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" perfect \" ) NEW_LINE DEDENT"],"references":["x , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if 0 < b - a <= x : print ( \" safe \" ) NEW_LINE else : print ( \" ddealnigceiroouuss \" [ b - a > x : : 2 ] ) NEW_LINE","x , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if b - a > x : NEW_LINE INDENT print ( ' dangerous ' ) NEW_LINE DEDENT elif b > a : NEW_LINE INDENT print ( ' safe ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' delicious ' ) NEW_LINE DEDENT","x , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( \" delicious \" if b <= a else \" dangerous \" if x + a < b else \" safe \" ) NEW_LINE"],"bleu":0.6666208756344433,"rouge_l":0.7719483258634325}
{"id":57,"predictions":["n , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ' Alice ' if ( ( - 1 ) % 2 == 0 else ' Bob ' ) NEW_LINE"],"references":["n , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if ( ( b - a ) % 2 == 0 ) : NEW_LINE INDENT print ( \" Alice \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Borys \" ) NEW_LINE DEDENT","n , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE M = [ 1 ] + [ 0 ] * n + [ 1 ] NEW_LINE a -= 1 NEW_LINE b -= 1 NEW_LINE M [ a ] = 1 NEW_LINE M [ b ] = 1 NEW_LINE turn = 1 NEW_LINE while True : NEW_LINE INDENT if turn == 1 : NEW_LINE INDENT if M [ a + 1 ] == 1 and M [ a - 1 ] == 0 : NEW_LINE INDENT M [ a - 1 ] = 1 NEW_LINE M [ a ] = 0 NEW_LINE a -= 1 NEW_LINE turn *= - 1 NEW_LINE DEDENT elif M [ a - 1 ] == 1 and M [ a + 1 ] == 0 : NEW_LINE INDENT M [ a + 1 ] = 1 NEW_LINE M [ a ] = 0 NEW_LINE a += 1 NEW_LINE turn *= - 1 NEW_LINE DEDENT elif M [ a - 1 ] == 0 and M [ a + 1 ] == 0 : NEW_LINE INDENT M [ a + 1 ] = 1 NEW_LINE M [ a ] = 0 NEW_LINE a += 1 NEW_LINE turn *= - 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Borys \" ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if M [ b + 1 ] == 1 and M [ b - 1 ] == 0 : NEW_LINE INDENT M [ b - 1 ] = 1 NEW_LINE M [ b ] = 0 NEW_LINE b -= 1 NEW_LINE turn *= - 1 NEW_LINE DEDENT elif M [ b - 1 ] == 1 and M [ b + 1 ] == 0 : NEW_LINE INDENT M [ b + 1 ] = 1 NEW_LINE M [ b ] = 0 NEW_LINE b += 1 NEW_LINE turn *= - 1 NEW_LINE DEDENT elif M [ b - 1 ] == 0 and M [ b + 1 ] == 0 : NEW_LINE INDENT M [ b - 1 ] = 1 NEW_LINE M [ b ] = 0 NEW_LINE b -= 1 NEW_LINE turn *= - 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Alice \" ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT DEDENT","import sys NEW_LINE input = sys . stdin . readline NEW_LINE N , A , B = map ( int , input ( ) . split ( ) ) NEW_LINE print ( \" Alice \" if ( B - A + 1 ) % 2 == 1 else \" Borys \" ) NEW_LINE"],"bleu":0.5080165861259724,"rouge_l":0.6423233695652174}
{"id":58,"predictions":["from collections import defaultdict , deque , Counterfrom sys import stdin , stdoutfrom heapq import heappush , heappopimport mathimport ioimport osimport mathimport bisect   NEW_LINE"],"references":["S = str ( input ( ) ) NEW_LINE ascii_letters = \" abcdefghijklmnopqrstuvwxyz \" NEW_LINE for letter in ascii_letters : NEW_LINE INDENT if letter not in S : NEW_LINE INDENT print ( letter ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT print ( \" None \" ) NEW_LINE","print ( min ( set ( map ( chr , range ( 97 , 123 ) ) ) - set ( input ( ) ) or [ None ] ) ) NEW_LINE","from collections import defaultdict NEW_LINE import string NEW_LINE S = input ( ) NEW_LINE letters = defaultdict ( lambda : False ) NEW_LINE for s in S : NEW_LINE INDENT letters [ s ] = True NEW_LINE DEDENT ans = ' None ' NEW_LINE for l in string . ascii_lowercase : NEW_LINE INDENT if letters [ l ] == False : NEW_LINE INDENT ans = l NEW_LINE break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"bleu":0.11702352306696498,"rouge_l":0.12495732331853877}
{"id":59,"predictions":["n = int ( input ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT l . append ( int ( input ( ) ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT t = l [ i ] NEW_LINE if t <= l [ i + 1 ] : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT DEDENT"],"references":["N = int ( input ( ) ) NEW_LINE L = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE L . sort ( reverse = 1 ) NEW_LINE length = 0 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT length += L [ i ] NEW_LINE DEDENT if L [ 0 ] < length : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT","import numpy as np NEW_LINE N = int ( input ( ) ) NEW_LINE L = np . array ( [ int ( s ) for s in input ( ) . split ( ' ▁ ' ) ] ) NEW_LINE print ( ' Yes ' if np . max ( L ) < np . sum ( L ) - np . max ( L ) else ' No ' ) NEW_LINE","import sys NEW_LINE def ii2ss ( n ) : NEW_LINE INDENT return [ sys . stdin . readline ( ) for _ in range ( n ) ] NEW_LINE DEDENT def sp2nn ( sp , sep = ' ▁ ' ) : NEW_LINE INDENT return [ int ( s ) for s in sp . split ( sep ) ] NEW_LINE DEDENT def ss2nn ( ss ) : NEW_LINE INDENT return [ int ( s ) for s in list ( ss ) ] NEW_LINE DEDENT import functools as ft NEW_LINE def main2 ( L ) : NEW_LINE INDENT L . sort ( ) NEW_LINE lmax = L [ - 1 ] NEW_LINE lothers = ft . reduce ( lambda x , y : x + y , L [ : - 1 ] ) NEW_LINE b = lmax < lothers NEW_LINE return ' Yes ' if b else ' No ' NEW_LINE DEDENT def main ( ss ) : NEW_LINE INDENT L = sp2nn ( ss [ 1 ] ) NEW_LINE s = main2 ( L ) NEW_LINE print ( s ) NEW_LINE DEDENT main ( ii2ss ( 2 ) ) NEW_LINE"],"bleu":0.5612717803749016,"rouge_l":0.5970452446906741}
{"id":60,"predictions":["import sys NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE input = sys . stdin . readline NEW_LINE N = input ( ) [ : - 1 ] NEW_LINE arr = [ 0 ] * ( N + 1 ) NEW_LINE dp = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT dp [ i ] = 1 NEW_LINE for j in range ( 2 , N + 1 ) : NEW_LINE INDENT if dp [ i ] [ j ] == 0 : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i ] [ j ] NEW_LINE DEDENT DEDENT result = [ ] NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT ans . append ( dp [ i ] ) [ : - 1 ] NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT print ( len ( ans ) ) NEW_LINE DEDENT"],"references":["n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( max ( 1 , n - 200 ) , n ) : NEW_LINE INDENT if i + sum ( [ int ( x ) for x in list ( str ( i ) ) ] ) == n : NEW_LINE INDENT a . append ( i ) NEW_LINE DEDENT DEDENT print ( len ( a ) ) NEW_LINE for x in a : NEW_LINE INDENT print ( x ) NEW_LINE DEDENT","def f ( x ) : NEW_LINE INDENT res = 0 NEW_LINE while x > 0 : NEW_LINE INDENT res += x % 10 NEW_LINE x \/\/= 10 NEW_LINE DEDENT return res NEW_LINE DEDENT N = int ( input ( ) ) NEW_LINE ans = [ ] NEW_LINE for i in range ( N ) [ - 154 : ] : NEW_LINE INDENT j = i + 1 NEW_LINE if j + f ( j ) == N : NEW_LINE INDENT ans . append ( j ) NEW_LINE DEDENT DEDENT print ( len ( ans ) ) NEW_LINE for x in ans : NEW_LINE INDENT print ( x ) NEW_LINE DEDENT","def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE keta = len ( str ( n ) ) NEW_LINE li = [ ] NEW_LINE for i in range ( 1 , 9 * keta + 1 ) : NEW_LINE INDENT x = n - i NEW_LINE if f ( x ) == i : NEW_LINE INDENT li . append ( x ) NEW_LINE DEDENT DEDENT li . sort ( ) NEW_LINE print ( len ( li ) ) NEW_LINE for x in li : NEW_LINE INDENT print ( x ) NEW_LINE DEDENT DEDENT def f ( x ) : NEW_LINE INDENT if x < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT sx = str ( x ) NEW_LINE res = 0 NEW_LINE for c in sx : NEW_LINE INDENT res += int ( c ) NEW_LINE DEDENT return res NEW_LINE DEDENT main ( ) NEW_LINE"],"bleu":0.2922026306740032,"rouge_l":0.4638848116306703}
{"id":61,"predictions":["N = int ( input ( ) ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE DEDENT print ( sum ( l ) - abs ( l ) + 1 ) NEW_LINE"],"references":["N = int ( input ( ) ) NEW_LINE lr = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( N ) ] NEW_LINE print ( sum ( list ( zip ( * lr ) ) [ 1 ] ) - sum ( list ( zip ( * lr ) ) [ 0 ] ) + N ) NEW_LINE","_ , * t = open ( 0 ) ; print ( sum ( 1 - eval ( s . replace ( ' ▁ ' , ' - ' ) ) for s in t ) ) NEW_LINE","import sys NEW_LINE ns = lambda : sys . stdin . readline ( ) . rstrip ( ) NEW_LINE ni = lambda : int ( ns ( ) ) NEW_LINE nm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE nl = lambda : list ( nm ( ) ) NEW_LINE n = ni ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT l , r = nm ( ) NEW_LINE ans += r - l + 1 NEW_LINE DEDENT print ( ans ) NEW_LINE"],"bleu":0.7372414365019312,"rouge_l":0.5815511466116979}
{"id":62,"predictions":["from collections import Counter NEW_LINE from functools import reduce NEW_LINE import fractions NEW_LINE import math NEW_LINE import statistics NEW_LINE import sys NEW_LINE import time NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE INF = 10 ** 18 NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def MI ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE def II ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def IS ( ) : return input ( ) NEW_LINE def P ( x ) : return print ( x ) NEW_LINE def C ( x ) : return Counter ( x ) NEW_LINE def GCD_LIST ( numbers ) : NEW_LINE INDENT return reduce ( fractions . gcd , numbers ) NEW_LINE DEDENT def LCM_LIST ( numbers ) : NEW_LINE INDENT return reduce ( LCM , numbers ) NEW_LINE DEDENT def LCM ( m , n ) : NEW_LINE INDENT return ( m * n \/\/ fractions . gcd ( m , n ) ) NEW_LINE DEDENT N = int ( input ( ) ) NEW_LINE S = LI ( ) NEW_LINE ans = ' S ' NEW_LINE for i in range ( N ) : NEW_LINE INDENT if S [ i ] == ' W ' : NEW_LINE INDENT ans = ' W ' NEW_LINE DEDENT if ans == - 1 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT"],"references":["n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE s = list ( map ( lambda x : 1 if x == \" o \" else - 1 , list ( s ) ) ) NEW_LINE flag = False NEW_LINE for start in [ [ 1 , 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] , [ - 1 , - 1 ] ] : NEW_LINE INDENT circle = start + [ 0 ] * ( n - 2 ) NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT circle [ i + 1 ] = circle [ i ] * s [ i ] * circle [ i - 1 ] NEW_LINE DEDENT if circle [ - 2 ] == circle [ - 1 ] * s [ - 1 ] * circle [ 0 ] and circle [ - 1 ] == circle [ 0 ] * s [ 0 ] * circle [ 1 ] : NEW_LINE INDENT flag = True NEW_LINE break NEW_LINE DEDENT DEDENT if flag : NEW_LINE INDENT ans = \" \" NEW_LINE for i in circle : NEW_LINE INDENT if i == 1 : NEW_LINE INDENT ans += \" S \" NEW_LINE DEDENT else : NEW_LINE INDENT ans += \" W \" NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT","N = int ( input ( ) ) NEW_LINE S = input ( ) NEW_LINE start_set = [ ] NEW_LINE start_set . append ( \" SS \" ) NEW_LINE start_set . append ( \" SW \" ) NEW_LINE start_set . append ( \" WS \" ) NEW_LINE start_set . append ( \" WW \" ) NEW_LINE def listed_goal_set ( i ) : NEW_LINE INDENT goal_set = [ ] NEW_LINE if S [ i ] == \" o \" : NEW_LINE INDENT goal_set . append ( \" SSS \" ) NEW_LINE goal_set . append ( \" WSW \" ) NEW_LINE goal_set . append ( \" WWS \" ) NEW_LINE goal_set . append ( \" SWW \" ) NEW_LINE DEDENT else : NEW_LINE INDENT goal_set . append ( \" WSS \" ) NEW_LINE goal_set . append ( \" SSW \" ) NEW_LINE goal_set . append ( \" WWW \" ) NEW_LINE goal_set . append ( \" SWS \" ) NEW_LINE DEDENT return goal_set NEW_LINE DEDENT goal_set1 = listed_goal_set ( 0 ) NEW_LINE goal_set2 = listed_goal_set ( - 1 ) NEW_LINE isok = False NEW_LINE for st in start_set : NEW_LINE INDENT O = [ ] NEW_LINE O . append ( st [ 0 ] ) NEW_LINE O . append ( st [ 1 ] ) NEW_LINE for i in range ( 1 , N - 1 ) : NEW_LINE INDENT if O [ i - 1 ] == \" S \" : NEW_LINE INDENT if O [ i ] == \" S \" : NEW_LINE INDENT if S [ i ] == \" o \" : NEW_LINE INDENT O . append ( \" S \" ) NEW_LINE DEDENT else : NEW_LINE INDENT O . append ( \" W \" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if S [ i ] == \" o \" : NEW_LINE INDENT O . append ( \" W \" ) NEW_LINE DEDENT else : NEW_LINE INDENT O . append ( \" S \" ) NEW_LINE DEDENT DEDENT DEDENT if O [ i - 1 ] == \" W \" : NEW_LINE INDENT if O [ i ] == \" S \" : NEW_LINE INDENT if S [ i ] == \" o \" : NEW_LINE INDENT O . append ( \" W \" ) NEW_LINE DEDENT else : NEW_LINE INDENT O . append ( \" S \" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if S [ i ] == \" o \" : NEW_LINE INDENT O . append ( \" S \" ) NEW_LINE DEDENT else : NEW_LINE INDENT O . append ( \" W \" ) NEW_LINE DEDENT DEDENT DEDENT DEDENT goals1 = O [ - 1 ] + O [ 0 ] + O [ 1 ] NEW_LINE goals2 = O [ - 2 ] + O [ - 1 ] + O [ 0 ] NEW_LINE if goals1 in goal_set1 and goals2 in goal_set2 : NEW_LINE INDENT isok = True NEW_LINE break NEW_LINE DEDENT DEDENT if isok : NEW_LINE INDENT print ( \" \" . join ( O ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT","import sys NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE input = sys . stdin . readline NEW_LINE N = int ( input ( ) ) NEW_LINE s = input ( ) [ : - 1 ] NEW_LINE ans = [ 1 ] * ( N + 2 ) NEW_LINE def print_ans ( l : list ) : NEW_LINE INDENT ret = \" \" NEW_LINE for a in l [ 1 : - 1 ] : NEW_LINE INDENT ret += \" S \" if a else \" W \" NEW_LINE DEDENT print ( ret ) NEW_LINE DEDENT def next ( ind : int , isSame : bool , isSheep : bool ) -> bool : NEW_LINE INDENT if isSame : NEW_LINE INDENT if isSheep : NEW_LINE INDENT return ans [ ind - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT return not ans [ ind - 1 ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if isSheep : NEW_LINE INDENT return not ans [ ind - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT return ans [ ind - 1 ] NEW_LINE DEDENT DEDENT return isSame ^ isSheep ^ ans [ ind - 1 ] NEW_LINE DEDENT def check ( first : bool , last : bool ) -> list : NEW_LINE INDENT ans [ 0 ] = last NEW_LINE ans [ 1 ] = first NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT ans [ i + 1 ] = next ( i , s [ i - 1 ] == \" o \" , ans [ i ] ) NEW_LINE DEDENT return ans [ 0 ] == ans [ N ] and ans [ 1 ] == ans [ N + 1 ] NEW_LINE DEDENT for first in [ True , False ] : NEW_LINE INDENT for last in [ True , False ] : NEW_LINE INDENT if check ( first , last ) : NEW_LINE INDENT print_ans ( ans ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT DEDENT print ( \" - 1\" ) NEW_LINE"],"bleu":0.2860445924892708,"rouge_l":0.344244783972352}
{"id":63,"predictions":["m , d = map ( int , input ( ) . split ( ) ) NEW_LINE if m <= d : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"],"references":["print ( \" YNEOS \" [ eval ( input ( ) . replace ( ' ▁ ' , ' % ' ) ) > 0 : : 2 ] ) NEW_LINE","s = input ( ) . split ( ) NEW_LINE A = int ( s [ 0 ] ) NEW_LINE B = int ( s [ 1 ] ) NEW_LINE if A % B == 0 : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT elif A % B != 0 : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT","l = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE print ( ' YES ' if l [ 0 ] % l [ 1 ] == 0 else ' NO ' ) NEW_LINE"],"bleu":0.6396174514688775,"rouge_l":0.5913631022326674}
{"id":64,"predictions":["import sys NEW_LINE import collections NEW_LINE ns = lambda : sys . stdin . readline ( ) . rstrip ( ) NEW_LINE ni = lambda : int ( ns ( ) ) NEW_LINE nm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE nl = lambda : list ( nm ( ) ) NEW_LINE nsl = lambda : map ( str , sys . stdin . readline ( ) . split ( ) ) NEW_LINE n = ni ( ) NEW_LINE a = nl ( ) NEW_LINE b = nl ( ) NEW_LINE dp = [ 0 ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ i + 1 ] [ 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if i == 1 : NEW_LINE INDENT dp [ i + 1 ] [ j ] += dp [ i ] [ j ] *= dp [ i ] [ j ] NEW_LINE DEDENT dp [ i + 1 ] [ j ] += dp [ i ] [ j ] NEW_LINE DEDENT ans %= 10 ** 9 + 7 NEW_LINE DEDENT print ( dp [ n ] [ 0 ] ) NEW_LINE"],"references":["from bisect import bisect NEW_LINE n = int ( input ( ) ) NEW_LINE d = [ int ( input ( ) ) for i in range ( n ) ] NEW_LINE a , d , mod , ans = [ ] , sorted ( d ) , 10 ** 9 + 7 , 0 NEW_LINE for i in range ( n ) : a . append ( n - bisect ( d , d [ i ] * 2 - 1 ) ) NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : a [ i ] += a [ i + 1 ] NEW_LINE for i in range ( n ) : ans = ( ans + bisect ( d , d [ i ] \/\/ 2 ) * a [ min ( n - 1 , bisect ( d , d [ i ] * 2 - 1 ) ) ] ) % mod NEW_LINE print ( ans ) NEW_LINE","import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE inf = 10 ** 20 NEW_LINE mod = 10 ** 9 + 7 NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def F ( ) : return float ( sys . stdin . readline ( ) ) NEW_LINE def S ( ) : return input ( ) NEW_LINE def main ( ) : NEW_LINE INDENT n = I ( ) NEW_LINE d = sorted ( [ I ( ) for _ in range ( n ) ] ) NEW_LINE a = [ 1 ] * n NEW_LINE for _ in range ( 3 ) : NEW_LINE INDENT j = 1 NEW_LINE t = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT i2 = d [ i ] * 2 NEW_LINE while j < n and d [ j ] < i2 : NEW_LINE INDENT j += 1 NEW_LINE DEDENT if j == n : NEW_LINE INDENT break NEW_LINE DEDENT t [ j ] += a [ i ] NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT t [ i ] += t [ i - 1 ] NEW_LINE DEDENT a = t NEW_LINE DEDENT return sum ( a ) % mod NEW_LINE DEDENT print ( main ( ) ) NEW_LINE","from bisect import bisect_left NEW_LINE def inpl ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE N = int ( input ( ) ) NEW_LINE D = sorted ( [ int ( input ( ) ) for _ in range ( N ) ] ) NEW_LINE S = [ 1 ] * ( N ) NEW_LINE for _ in range ( 3 ) : NEW_LINE INDENT DP = [ 0 ] * ( N ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT j = bisect_left ( D , D [ i ] * 2 ) NEW_LINE if j != N : NEW_LINE INDENT DP [ j ] = ( DP [ j ] + S [ i ] ) % MOD NEW_LINE DEDENT DEDENT S = [ 0 ] * ( N ) NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT S [ i ] = ( DP [ i ] + S [ i - 1 ] ) % MOD NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT ans = ( ans + S [ i ] ) % MOD NEW_LINE DEDENT print ( ans ) NEW_LINE"],"bleu":0.44293933338221597,"rouge_l":0.4797081978175629}
{"id":65,"predictions":["import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE inf = 10 ** 20 NEW_LINE eps = 1.0 \/ 10 ** 10 NEW_LINE mod = 10 ** 9 + 7 NEW_LINE dd = [ ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) ] NEW_LINE ddn = [ ( - 1 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) , ( 1 , 0 ) , ( 1 , - 1 ) , ( 0 , - 1 ) , ( - 1 , - 1 ) ] NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def F ( ) : return float ( sys . stdin . readline ( ) ) NEW_LINE def pf ( s ) : return print ( s , flush = True ) NEW_LINE N = I ( ) NEW_LINE A = [ I ( ) for i in range ( N ) ] NEW_LINE counts = collections . Counter ( A ) NEW_LINE ans = 0 NEW_LINE for i in counts . values ( ) : NEW_LINE INDENT if i % 2 == 1 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans \/\/ 2 ) NEW_LINE"],"references":["import bisect NEW_LINE n = int ( input ( ) ) NEW_LINE l = [ ] NEW_LINE e = [ ] NEW_LINE for i in range ( n \/\/ 2 ) : NEW_LINE INDENT j = int ( input ( ) ) NEW_LINE e . append ( j ) NEW_LINE l . append ( j ) NEW_LINE j = int ( input ( ) ) NEW_LINE l . append ( j ) NEW_LINE DEDENT if n % 2 == 1 : NEW_LINE INDENT j = int ( input ( ) ) NEW_LINE e . append ( j ) NEW_LINE l . append ( j ) NEW_LINE DEDENT l . sort ( ) NEW_LINE e . sort ( ) NEW_LINE res = 0 NEW_LINE for i in range ( 0 , n , 2 ) : NEW_LINE INDENT if e [ min ( len ( e ) - 1 , bisect . bisect_left ( e , l [ i ] ) ) ] != l [ i ] : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE","import sys NEW_LINE INF = float ( ' inf ' ) NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def II ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def SI ( ) : return input ( ) NEW_LINE def main ( ) : NEW_LINE INDENT n = II ( ) NEW_LINE A = [ II ( ) for _ in range ( n ) ] NEW_LINE B = A [ : ] NEW_LINE A . sort ( ) NEW_LINE return ( n + 1 ) \/\/ 2 - len ( set ( A [ : : 2 ] ) & set ( B [ : : 2 ] ) ) NEW_LINE DEDENT print ( main ( ) ) NEW_LINE","from collections import defaultdict , deque NEW_LINE import sys , heapq , bisect , math , itertools , string , queue , datetime NEW_LINE sys . setrecursionlimit ( 10 ** 8 ) NEW_LINE INF = float ( ' inf ' ) NEW_LINE mod = 10 ** 9 + 7 NEW_LINE eps = 10 ** - 7 NEW_LINE def inpl ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def inpls ( ) : return list ( input ( ) . split ( ) ) NEW_LINE N = int ( input ( ) ) NEW_LINE aa = [ int ( input ( ) ) for i in range ( N ) ] NEW_LINE cnt = defaultdict ( lambda : [ 0 , 0 ] ) NEW_LINE for i , a in enumerate ( aa ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT cnt [ a ] [ 0 ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt [ a ] [ 1 ] += 1 NEW_LINE DEDENT DEDENT aa . sort ( ) NEW_LINE ans = 0 NEW_LINE for i , a in enumerate ( aa ) : NEW_LINE INDENT ev , od = cnt [ a ] NEW_LINE if i % 2 == 0 : NEW_LINE INDENT if ev == 0 : NEW_LINE INDENT ans += 1 NEW_LINE cnt [ a ] [ 0 ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt [ a ] [ 1 ] -= 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if od == 0 : NEW_LINE INDENT ans += 1 NEW_LINE cnt [ a ] [ 0 ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt [ a ] [ 1 ] -= 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans \/\/ 2 ) NEW_LINE"],"bleu":0.5630727230943433,"rouge_l":0.6137173738070598}
{"id":66,"predictions":["def inpl ( ) : return [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE N = int ( input ( ) ) NEW_LINE L = [ ] NEW_LINE for _ in range ( N ) : NEW_LINE INDENT L . append ( input ( ) ) NEW_LINE DEDENT L . sort ( ) NEW_LINE R = sorted ( L ) NEW_LINE ans = 0 NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT ans += R [ i ] - L [ i ] NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT ans += R [ i ] - L [ i ] NEW_LINE DEDENT print ( ans ) NEW_LINE"],"references":["import sys NEW_LINE from operator import itemgetter NEW_LINE N = int ( input ( ) ) NEW_LINE sorted_l = sorted ( ( tuple ( map ( int , l . split ( ) ) ) for l in sys . stdin ) , reverse = True ) NEW_LINE sorted_r = sorted ( sorted_l , key = itemgetter ( 1 ) ) NEW_LINE pos1 , ans1 = 0 , 0 NEW_LINE pos2 , ans2 = 0 , 0 NEW_LINE for i , j in enumerate ( i \/\/ 2 for i in range ( N ) ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT dist1 , dist2 = max ( sorted_l [ j ] [ 0 ] - pos1 , 0 ) , max ( pos2 - sorted_r [ j ] [ 1 ] , 0 ) NEW_LINE pos1 , ans1 = pos1 + dist1 , ans1 + dist1 NEW_LINE pos2 , ans2 = pos2 - dist2 , ans2 + dist2 NEW_LINE DEDENT else : NEW_LINE INDENT dist1 , dist2 = max ( pos1 - sorted_r [ j ] [ 1 ] , 0 ) , max ( sorted_l [ j ] [ 0 ] - pos2 , 0 ) NEW_LINE pos1 , ans1 = pos1 - dist1 , ans1 + dist1 NEW_LINE pos2 , ans2 = pos2 + dist2 , ans2 + dist2 NEW_LINE DEDENT DEDENT print ( max ( ans1 + abs ( pos1 ) , ans2 + abs ( pos2 ) ) ) NEW_LINE","from sys import stdin NEW_LINE in_strings = lambda : stdin . readline ( ) [ : - 1 ] NEW_LINE in_int = lambda : int ( stdin . readline ( ) ) NEW_LINE in_intlist = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) NEW_LINE N = in_int ( ) NEW_LINE L_list = [ ] NEW_LINE R_list = [ ] NEW_LINE for _ in range ( N ) : NEW_LINE INDENT temp = in_intlist ( ) NEW_LINE L_list . append ( temp [ 0 ] ) NEW_LINE R_list . append ( temp [ 1 ] ) NEW_LINE DEDENT L_list . sort ( reverse = True ) NEW_LINE R_list . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( L_list [ i ] - R_list [ i ] ) > 0 : NEW_LINE INDENT ans += 2 * ( L_list [ i ] - R_list [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( L_list [ i ] <= 0 ) and ( R_list [ i ] >= 0 ) : NEW_LINE INDENT pass NEW_LINE DEDENT elif L_list [ i ] > 0 : NEW_LINE INDENT if ( i > 0 ) and ( L_list [ i ] < R_list [ i - 1 ] ) : NEW_LINE INDENT ans += 2 * R_list [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT ans += 2 * L_list [ i ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( i > 0 ) and ( R_list [ i ] > L_list [ i - 1 ] ) : NEW_LINE INDENT ans -= 2 * L_list [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT ans -= 2 * R_list [ i ] NEW_LINE DEDENT DEDENT break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE","from sys import exit , setrecursionlimit , stderr NEW_LINE from functools import reduce NEW_LINE from itertools import * NEW_LINE from collections import defaultdict NEW_LINE from bisect import bisect NEW_LINE def read ( ) : NEW_LINE INDENT return int ( input ( ) ) NEW_LINE DEDENT def reads ( ) : NEW_LINE INDENT return [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE DEDENT N = read ( ) NEW_LINE L = [ ] NEW_LINE R = [ ] NEW_LINE for _ in range ( N ) : NEW_LINE INDENT ( l , r ) = reads ( ) NEW_LINE L . append ( l ) NEW_LINE R . append ( - r ) NEW_LINE DEDENT L . sort ( ) ; L . reverse ( ) NEW_LINE R . sort ( ) ; R . reverse ( ) NEW_LINE psumL = [ 0 ] * ( N + 1 ) NEW_LINE psumR = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT psumL [ i + 1 ] = psumL [ i ] + L [ i ] NEW_LINE psumR [ i + 1 ] = psumR [ i ] + R [ i ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT ans = max ( ans , psumL [ i ] + psumR [ i ] ) NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT ans = max ( ans , psumL [ i ] + psumR [ i + 1 ] ) NEW_LINE ans = max ( ans , psumL [ i + 1 ] + psumR [ i ] ) NEW_LINE DEDENT print ( ans * 2 ) NEW_LINE"],"bleu":0.2961395471113415,"rouge_l":0.4599393982101332}
{"id":67,"predictions":["N , A , B = map ( int , input ( ) . split ( ) ) NEW_LINE S = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] NEW_LINE T = [ int ( input ( ) ) for _ in range ( N ) ] NEW_LINE if S == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( B \/ S , T ) NEW_LINE DEDENT"],"references":["n , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE s = [ int ( input ( ) ) for i in range ( n ) ] NEW_LINE d = max ( s ) - min ( s ) NEW_LINE if d != 0 : NEW_LINE INDENT print ( b \/ d , a - ( sum ( s ) \/ n ) * ( b \/ d ) ) NEW_LINE DEDENT else : NEW_LINE INDENT if b != 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 , a - s [ 0 ] ) NEW_LINE DEDENT DEDENT","def a_transformation ( N , A , B , S ) : NEW_LINE INDENT e = sum ( S ) \/ N NEW_LINE d = max ( S ) - min ( S ) NEW_LINE if d == 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT p = B \/ d NEW_LINE q = A - ( e * B ) \/ d NEW_LINE ans = ' { 0 : . 09f } ▁ { 1 : . 09f } ' . format ( p , q ) NEW_LINE return ans NEW_LINE DEDENT N , A , B = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE S = [ int ( input ( ) ) for _ in [ 0 ] * N ] NEW_LINE print ( a_transformation ( N , A , B , S ) ) NEW_LINE","n , a , b , * s = map ( int , open ( 0 ) . read ( ) . split ( ) ) NEW_LINE M , m = max ( s ) , min ( s ) NEW_LINE d = M - m NEW_LINE if not d : NEW_LINE INDENT print ( - 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT p = b \/ d NEW_LINE q = a - sum ( map ( lambda x : p * x , s ) ) \/ n NEW_LINE print ( p , q ) NEW_LINE"],"bleu":0.5806939603991,"rouge_l":0.562039312039312}
{"id":68,"predictions":["N = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE b = [ ] NEW_LINE c = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE c . sort ( ) NEW_LINE res = len ( b ) NEW_LINE print ( res ) NEW_LINE"],"references":["n = int ( input ( ) ) NEW_LINE k = 1000000 NEW_LINE nums = [ 0 for _ in range ( k + 2 ) ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE nums [ a ] += 1 NEW_LINE nums [ b + 1 ] -= 1 NEW_LINE DEDENT for i in range ( 1 , k + 1 ) : NEW_LINE INDENT nums [ i ] += nums [ i - 1 ] NEW_LINE DEDENT print ( max ( nums ) ) NEW_LINE","import numpy as np NEW_LINE n = int ( input ( ) ) NEW_LINE memo = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT a , b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE memo . append ( ( a , - 1 ) ) NEW_LINE memo . append ( ( b , + 1 ) ) NEW_LINE DEDENT memo . sort ( ) NEW_LINE print ( - np . array ( [ x [ 1 ] for x in memo ] ) . cumsum ( ) . min ( ) ) NEW_LINE","from statistics import mean , median , variance , stdev NEW_LINE import numpy as np NEW_LINE import sys NEW_LINE import math NEW_LINE import fractions NEW_LINE import itertools NEW_LINE import copy NEW_LINE from operator import itemgetter NEW_LINE def j ( q ) : NEW_LINE INDENT if q == 1 : print ( \" Yes \" ) NEW_LINE else : print ( \" No \" ) NEW_LINE exit ( 0 ) NEW_LINE DEDENT def ct ( x , y ) : NEW_LINE INDENT if ( x > y ) : print ( \" + \" ) NEW_LINE elif ( x < y ) : print ( \" - \" ) NEW_LINE else : print ( \" ? \" ) NEW_LINE DEDENT def ip ( ) : NEW_LINE INDENT return int ( input ( ) ) NEW_LINE DEDENT def pne ( n ) : NEW_LINE INDENT print ( n , end = ' ' ) NEW_LINE DEDENT rem = pow ( 10 , 9 ) + 7 NEW_LINE n = ip ( ) NEW_LINE add = [ 0 for i in range ( 1000002 ) ] NEW_LINE subtract = [ 0 for i in range ( 1000002 ) ] NEW_LINE a = [ ] NEW_LINE s = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT left , right = ( int ( i ) for i in input ( ) . split ( ) ) NEW_LINE add [ left ] += 1 NEW_LINE subtract [ right ] += 1 NEW_LINE s . add ( left ) NEW_LINE s . add ( right ) NEW_LINE DEDENT t = \"01\" NEW_LINE c = 0 NEW_LINE ans = 0 NEW_LINE l = list ( s ) NEW_LINE l . sort ( ) NEW_LINE for i in range ( len ( l ) ) : NEW_LINE INDENT k = l [ i ] NEW_LINE c += add [ k ] NEW_LINE ans = max ( c , ans ) NEW_LINE c -= subtract [ k ] NEW_LINE DEDENT print ( ans ) NEW_LINE"],"bleu":0.549857313943143,"rouge_l":0.5738164843455301}
{"id":69,"predictions":["from collections import Counter NEW_LINE from functools import reduce NEW_LINE import fractions NEW_LINE import math NEW_LINE import statistics NEW_LINE import sys NEW_LINE import time NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE INF = 10 ** 18 NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def MI ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE def II ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def IS ( ) : return input ( ) NEW_LINE def P ( x ) : return print ( x ) NEW_LINE def C ( s ) : return Counter ( s ) NEW_LINE def GCD_LIST ( numbers ) : NEW_LINE INDENT return reduce ( fractions . gcd , numbers ) NEW_LINE DEDENT def LCM_LIST ( numbers ) : NEW_LINE INDENT return reduce ( LCM , numbers ) NEW_LINE DEDENT def LCM ( m , n ) : NEW_LINE INDENT return ( m * n \/\/ fractions . gcd ( m , n ) ) NEW_LINE DEDENT s = IS ( ) NEW_LINE ans = [ ] NEW_LINE for x in s : NEW_LINE INDENT ans . append ( x ) NEW_LINE DEDENT for y in range ( 4 ) : NEW_LINE INDENT ans . append ( s [ x ] + y ) NEW_LINE DEDENT for x in range ( 4 ) : NEW_LINE INDENT ans . append ( s [ x + 1 ] ) NEW_LINE DEDENT print ( ' ' . join ( ans ) ) NEW_LINE"],"references":["x , y , w = input ( ) . split ( ) NEW_LINE x , y = int ( x ) + 7 , int ( y ) + 7 NEW_LINE A = [ input ( ) for i in range ( 9 ) ] NEW_LINE B = [ a [ 1 : ] [ : : - 1 ] + a + a [ : - 1 ] [ : : - 1 ] for a in A ] NEW_LINE C = B [ 1 : ] [ : : - 1 ] + B + B [ : - 1 ] [ : : - 1 ] NEW_LINE D = { ' R ' : ( 1 , 0 ) , ' L ' : ( - 1 , 0 ) , ' U ' : ( 0 , - 1 ) , ' D ' : ( 0 , 1 ) , ' RU ' : ( 1 , - 1 ) , ' RD ' : ( 1 , 1 ) , ' LU ' : ( - 1 , - 1 ) , ' LD ' : ( - 1 , 1 ) } NEW_LINE ans = C [ y ] [ x ] NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT dx , dy = D [ w ] NEW_LINE x += dx NEW_LINE y += dy NEW_LINE ans += C [ y ] [ x ] NEW_LINE DEDENT print ( ans ) NEW_LINE","def b_card ( X , Y , W , C ) : NEW_LINE INDENT h , w = Y - 1 , X - 1 NEW_LINE if ' R ' in W : NEW_LINE INDENT dw = 1 NEW_LINE DEDENT elif ' L ' in W : NEW_LINE INDENT dw = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT dw = 0 NEW_LINE DEDENT if ' U ' in W : NEW_LINE INDENT dh = - 1 NEW_LINE DEDENT elif ' D ' in W : NEW_LINE INDENT dh = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dh = 0 NEW_LINE DEDENT ans = ' ' NEW_LINE for k in range ( 4 ) : NEW_LINE INDENT ans += C [ h ] [ w ] NEW_LINE is_changed = False NEW_LINE nh , nw = h + dh , w + dw NEW_LINE move_tmp = ' ' NEW_LINE if not ( 0 <= nh < 9 ) : NEW_LINE INDENT is_changed = True NEW_LINE dh *= - 1 NEW_LINE DEDENT if not ( 0 <= nw < 9 ) : NEW_LINE INDENT is_changed = True NEW_LINE dw *= - 1 NEW_LINE DEDENT if is_changed : NEW_LINE INDENT nh , nw = h + dh , w + dw NEW_LINE DEDENT h , w = nh , nw NEW_LINE DEDENT return ans NEW_LINE DEDENT X , Y , W = [ int ( i ) if i . isdigit ( ) else i for i in input ( ) . split ( ) ] NEW_LINE C = [ input ( ) for _ in range ( 9 ) ] NEW_LINE print ( b_card ( X , Y , W , C ) ) NEW_LINE","x , y , W = [ ( int ( x ) , int ( y ) , W ) for x , y , W in [ input ( ) . split ( ) ] ] [ 0 ] NEW_LINE c = [ input ( ) for _ in range ( 9 ) ] NEW_LINE def f ( k , i , j , di , dj ) : NEW_LINE INDENT return ( ' ' if k == 4 else c [ i ] [ j ] + f ( k + 1 , i + di , j + dj , di if 0 < i + di < 8 else - di , dj if 0 < j + dj < 8 else - dj ) ) NEW_LINE DEDENT ans = f ( 0 , y - 1 , x - 1 , ( 1 if ( ' D ' in W and y - 1 < 8 ) or ( ' U ' in W and y - 1 == 0 ) else - 1 if ( ' U ' in W and 0 < y - 1 ) or ( ' D ' in W and y - 1 == 8 ) else 0 ) , ( 1 if ( ' R ' in W and x - 1 < 8 ) or ( ' L ' in W and x - 1 == 0 ) else - 1 if ( ' L ' in W and 0 < x - 1 ) or ( ' R ' in W and x - 1 == 8 ) else 0 ) ) NEW_LINE print ( ans ) NEW_LINE"],"bleu":0.17581875909228517,"rouge_l":0.2973248696440716}
{"id":70,"predictions":["N , K = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( K * ( N - K ) * ( N - K ) + 1 \/ N ) * N ) NEW_LINE"],"references":["N , K = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( ( K - 1 ) * ( N - K ) * 6 + ( N - 1 ) * 3 + 1 ) \/ N ** 3 ) NEW_LINE","def gen_random ( N : int , K : int ) -> float : NEW_LINE INDENT res = 0 NEW_LINE res += ( K - 1 ) * 1 * ( N - K ) * 6 NEW_LINE res += 1 * 1 * ( N - K ) * 3 NEW_LINE res += ( K - 1 ) * 1 * 1 * 3 NEW_LINE res += 1 * 1 * 1 NEW_LINE return res \/ ( N * N * N ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N , K = map ( int , input ( ) . split ( ) ) NEW_LINE ans = gen_random ( N , K ) NEW_LINE print ( ans ) NEW_LINE DEDENT","n , k = ( int ( i ) for i in input ( ) . split ( ) ) NEW_LINE zentoori = n ** 3 NEW_LINE ryoutan = ( 3 * n - 2 ) \/ zentoori NEW_LINE if n == k or k == 1 : NEW_LINE INDENT print ( ryoutan ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" { 0 : . 20f } \" . format ( ( ( 3 * n - 2 ) + 6 * ( k - 1 ) * ( n - k ) ) \/ zentoori ) ) NEW_LINE DEDENT"],"bleu":0.6912713285902483,"rouge_l":0.8133333333333335}
{"id":71,"predictions":["from collections import defaultdict NEW_LINE from bisect import bisect_left NEW_LINE def inpl ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def inpl ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE INF = 10 ** 9 + 7 NEW_LINE def inpl ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def inpl_s ( ) : return list ( input ( ) . split ( ) ) NEW_LINE INF = 10 ** 9 NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE cnt = 0 NEW_LINE for i in range ( 1 , 10 ** 9 + 7 ) : NEW_LINE INDENT for i in range ( 10 ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT if d [ i ] [ j ] == \" x \" : NEW_LINE INDENT continue NEW_LINE DEDENT if d [ i ] [ j ] == 0 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT if cnt == 1 : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT print ( \" YES \" ) NEW_LINE"],"references":["H , W = ( 10 , 10 ) NEW_LINE field = [ list ( input ( ) ) for _ in range ( H ) ] NEW_LINE Around = [ [ 0 ] * W for _ in range ( H ) ] NEW_LINE cnt_islands = 0 NEW_LINE def dfs ( x , y ) : NEW_LINE INDENT if x < 0 or x >= W or y < 0 or y >= H or field [ y ] [ x ] == \" r \" : NEW_LINE INDENT return NEW_LINE DEDENT if field [ y ] [ x ] == \" x \" : NEW_LINE INDENT field [ y ] [ x ] = \" r \" NEW_LINE Around [ y ] [ x ] += 1 NEW_LINE return NEW_LINE DEDENT field [ y ] [ x ] = \" r \" NEW_LINE dfs ( x + 1 , y ) NEW_LINE dfs ( x - 1 , y ) NEW_LINE dfs ( x , y + 1 ) NEW_LINE dfs ( x , y - 1 ) NEW_LINE DEDENT for y in range ( H ) : NEW_LINE INDENT for x in range ( W ) : NEW_LINE INDENT if field [ y ] [ x ] == \" o \" : NEW_LINE INDENT for yr in range ( H ) : NEW_LINE INDENT for xr in range ( W ) : NEW_LINE INDENT if field [ yr ] [ xr ] == \" r \" : NEW_LINE INDENT field [ yr ] [ xr ] = \" x \" NEW_LINE DEDENT DEDENT DEDENT dfs ( x , y ) NEW_LINE cnt_islands += 1 NEW_LINE DEDENT DEDENT DEDENT if cnt_islands == 1 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT f = False NEW_LINE for y in range ( H ) : NEW_LINE INDENT for x in range ( W ) : NEW_LINE INDENT if Around [ y ] [ x ] == cnt_islands : NEW_LINE INDENT f = True NEW_LINE print ( ' YES ' ) NEW_LINE break NEW_LINE DEDENT DEDENT if f : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if not f : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT","a = [ [ \" x \" ] * 12 ] + [ list ( \" x \" + input ( ) + \" x \" ) for i in range ( 10 ) ] + [ [ \" x \" ] * 12 ] NEW_LINE b = sum ( [ i . count ( \" o \" ) for i in a ] ) NEW_LINE for i in range ( 1 , 11 ) : NEW_LINE INDENT for j in range ( 1 , 11 ) : NEW_LINE INDENT if a [ i ] [ j ] != \" o \" : NEW_LINE INDENT s = [ i [ : ] for i in a ] NEW_LINE n = 0 NEW_LINE d = [ [ i , j ] ] NEW_LINE while len ( d ) > 0 : NEW_LINE INDENT l = [ ] NEW_LINE for p , q in d : NEW_LINE INDENT if s [ p - 1 ] [ q ] == \" o \" : NEW_LINE INDENT s [ p - 1 ] [ q ] = \" x \" NEW_LINE n += 1 NEW_LINE l . append ( [ p - 1 , q ] ) NEW_LINE DEDENT if s [ p + 1 ] [ q ] == \" o \" : NEW_LINE INDENT s [ p + 1 ] [ q ] = \" x \" NEW_LINE n += 1 NEW_LINE l . append ( [ p + 1 , q ] ) NEW_LINE DEDENT if s [ p ] [ q + 1 ] == \" o \" : NEW_LINE INDENT s [ p ] [ q + 1 ] = \" x \" NEW_LINE n += 1 NEW_LINE l . append ( [ p , q + 1 ] ) NEW_LINE DEDENT if s [ p ] [ q - 1 ] == \" o \" : NEW_LINE INDENT s [ p ] [ q - 1 ] = \" x \" NEW_LINE n += 1 NEW_LINE l . append ( [ p , q - 1 ] ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT d = l NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if n == b : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT","import sys NEW_LINE sys . setrecursionlimit ( 100000 ) NEW_LINE ans_flag = 0 NEW_LINE field = [ input ( ) for x in range ( 10 ) ] NEW_LINE field_u = [ [ 1 if field [ y ] [ x ] == ' x ' else 0 for x in range ( 10 ) ] for y in range ( 10 ) ] NEW_LINE reached = [ [ 0 for x in range ( 10 ) ] for y in range ( 10 ) ] NEW_LINE flag = 0 NEW_LINE def dfs ( x , y ) : NEW_LINE INDENT global flag , reached NEW_LINE if x >= 10 or y >= 10 or x < 0 or y < 0 : NEW_LINE INDENT return NEW_LINE DEDENT if field_u [ x ] [ y ] == 1 : NEW_LINE INDENT return NEW_LINE DEDENT if reached [ x ] [ y ] == 1 : NEW_LINE INDENT return NEW_LINE DEDENT reached [ x ] [ y ] = 1 NEW_LINE dfs ( x + 1 , y ) NEW_LINE dfs ( x - 1 , y ) NEW_LINE dfs ( x , y + 1 ) NEW_LINE dfs ( x , y - 1 ) NEW_LINE DEDENT counter = 1 NEW_LINE for y in range ( 10 ) : NEW_LINE INDENT for x in range ( 10 ) : NEW_LINE INDENT if field [ y ] [ x ] == ' o ' : NEW_LINE INDENT counter += 1 NEW_LINE first = [ y , x ] NEW_LINE DEDENT DEDENT DEDENT for y in range ( 10 ) : NEW_LINE INDENT for x in range ( 10 ) : NEW_LINE INDENT if field_u [ y ] [ x ] == 1 : NEW_LINE INDENT field_u [ y ] [ x ] = 0 NEW_LINE dfs ( first [ 0 ] , first [ 1 ] ) NEW_LINE ans = [ sum ( i ) for i in reached ] NEW_LINE ans = sum ( ans ) NEW_LINE if counter == ans : NEW_LINE INDENT ans_flag = 1 NEW_LINE DEDENT reached = [ [ 0 for x in range ( 10 ) ] for y in range ( 10 ) ] NEW_LINE field_u [ y ] [ x ] = 1 NEW_LINE DEDENT DEDENT DEDENT if ans_flag == 1 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT"],"bleu":0.20711973748718684,"rouge_l":0.32020425653478074}
{"id":72,"predictions":["s = input ( ) NEW_LINE print ( \" Yes \" if len ( s ) % 2 == 0 else \" No \" ) NEW_LINE"],"references":["import collections NEW_LINE letter = collections . Counter ( input ( ) ) NEW_LINE counter = 0 NEW_LINE for v in letter . values ( ) : NEW_LINE INDENT if v % 2 == 1 : NEW_LINE INDENT counter += 1 NEW_LINE break NEW_LINE DEDENT DEDENT print ( \" Yes \" ) if counter == 0 else print ( \" No \" ) NEW_LINE","hoge = input ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( len ( hoge ) ) : NEW_LINE INDENT ans += hoge . count ( hoge [ i ] ) % 2 NEW_LINE DEDENT if ( ans == 0 ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT","w = input ( ) NEW_LINE dct_str = dict . fromkeys ( w , 0 ) NEW_LINE for alp in w : NEW_LINE INDENT dct_str [ alp ] += 1 NEW_LINE DEDENT flag = True NEW_LINE for alp in dct_str . keys ( ) : NEW_LINE INDENT if dct_str [ alp ] % 2 != 0 : NEW_LINE INDENT flag = False NEW_LINE DEDENT DEDENT if flag == True : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.1312422208854525,"rouge_l":0.39234935680433314}
{"id":73,"predictions":["def solve ( ) : NEW_LINE INDENT l = int ( input ( ) ) NEW_LINE n = int ( input ( ) ) NEW_LINE x1 = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE x2 = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE dp = [ 0 ] * n NEW_LINE p = [ 0 ] * n NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT dp [ i + 1 ] = p [ i ] + x1 [ i ] + x1 [ i - 1 ] NEW_LINE dp [ i ] = dp [ i + 1 ] + x2 [ i ] NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i + 1 ] , dp [ i ] ) , max ( dp [ i ] , dp [ i + 1 ] ) NEW_LINE DEDENT return max ( dp [ n ] , dp [ n - 1 ] ) NEW_LINE DEDENT print ( solve ( ) ) NEW_LINE"],"references":["L , N = map ( int , input ( ) . split ( ) ) NEW_LINE X = [ 0 ] NEW_LINE for _ in range ( N ) : NEW_LINE INDENT X . append ( int ( input ( ) ) ) NEW_LINE DEDENT s = [ 0 ] * ( N + 1 ) NEW_LINE t = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT s [ i ] = s [ i - 1 ] + X [ i ] NEW_LINE t [ i ] = t [ i - 1 ] + ( L - X [ N - i + 1 ] ) NEW_LINE DEDENT Y = [ 0 ] + [ L - X [ N - i ] for i in range ( N ) ] NEW_LINE def get_d ( s , x , i ) : NEW_LINE INDENT if i == N : NEW_LINE INDENT return x [ N ] NEW_LINE DEDENT a = i + ( N - i ) \/\/ 2 NEW_LINE return ( 2 * ( s [ a ] - s [ i - 1 ] + L * ( N - a ) - s [ N ] + s [ a ] ) - ( x [ a ] if ( N - i ) % 2 == 0 else ( L - x [ a + 1 ] ) ) ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT ans = max ( ans , get_d ( s , X , i ) , get_d ( t , Y , i ) ) NEW_LINE DEDENT print ( ans ) NEW_LINE","def is_even ( num ) : NEW_LINE INDENT return num % 2 == 0 NEW_LINE DEDENT def goback ( M , x , Sx ) : NEW_LINE INDENT k = M \/\/ 2 NEW_LINE if M == 0 : NEW_LINE INDENT return L - x [ 0 ] NEW_LINE DEDENT elif M == 1 : NEW_LINE INDENT return 2 * ( L - x [ 1 ] ) + x [ 0 ] NEW_LINE DEDENT elif is_even ( M ) : NEW_LINE INDENT return 2 * Sx [ k - 1 ] - 2 * ( Sx [ M ] - Sx [ M - k ] ) - x [ M - k ] + L * ( 2 * k + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return 2 * Sx [ k - 1 ] + x [ k ] - 2 * ( Sx [ M ] - Sx [ M - k - 1 ] ) + L * 2 * ( k + 1 ) NEW_LINE DEDENT DEDENT L , N = ( int ( i ) for i in input ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE pl = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT pl . append ( int ( input ( ) ) ) NEW_LINE DEDENT sumpl = [ pl [ 0 ] ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT sumpl . append ( sumpl [ i - 1 ] + pl [ i ] ) NEW_LINE DEDENT for i in range ( 0 , N ) : NEW_LINE INDENT ans = max ( ans , goback ( i , pl , sumpl ) ) NEW_LINE DEDENT revpl = [ L - p for p in pl [ : : - 1 ] ] NEW_LINE sumrevpl = [ revpl [ 0 ] ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT sumrevpl . append ( sumrevpl [ i - 1 ] + revpl [ i ] ) NEW_LINE DEDENT for i in range ( 0 , N ) : NEW_LINE INDENT ans = max ( ans , goback ( i , revpl , sumrevpl ) ) NEW_LINE DEDENT print ( ans ) NEW_LINE","import sys NEW_LINE from itertools import accumulate NEW_LINE circumference , n = map ( int , input ( ) . split ( ) ) NEW_LINE lll = list ( map ( int , sys . stdin . readlines ( ) ) ) NEW_LINE rrr = [ circumference - l for l in lll ] NEW_LINE rrr . reverse ( ) NEW_LINE lll = [ 0 ] + lll NEW_LINE rrr = [ 0 ] + rrr NEW_LINE acc_l = list ( accumulate ( lll ) ) NEW_LINE acc_r = list ( accumulate ( rrr ) ) NEW_LINE ans = max ( lll [ - 1 ] , rrr [ - 1 ] ) NEW_LINE for take_l in range ( 1 , n ) : NEW_LINE INDENT take_r = n - take_l NEW_LINE tmp_l = lll [ take_l ] + 2 * ( acc_l [ take_l - 1 ] + acc_r [ take_r ] ) NEW_LINE tmp_r = rrr [ take_r ] + 2 * ( acc_r [ take_r - 1 ] + acc_l [ take_l ] ) NEW_LINE if take_l < take_r : NEW_LINE INDENT tmp_l -= 2 * acc_r [ take_r - take_l ] NEW_LINE tmp_r -= 2 * acc_r [ take_r - 1 - take_l ] NEW_LINE DEDENT elif take_l > take_r : NEW_LINE INDENT tmp_l -= 2 * acc_l [ take_l - 1 - take_r ] NEW_LINE tmp_r -= 2 * acc_l [ take_l - take_r ] NEW_LINE DEDENT ans = max ( ans , tmp_l , tmp_r ) NEW_LINE DEDENT print ( ans ) NEW_LINE"],"bleu":0.3673926369847742,"rouge_l":0.4336050003063914}
{"id":74,"predictions":["from collections import defaultdict NEW_LINE from heapq import heappush , heappop NEW_LINE import sys NEW_LINE import math NEW_LINE import bisect NEW_LINE import random NEW_LINE def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def S ( ) : return list ( sys . stdin . readline ( ) ) [ : - 1 ] NEW_LINE def IR ( n ) : return [ I ( ) for i in range ( n ) ] NEW_LINE def LIR ( n ) : return [ LI ( ) for i in range ( n ) ] NEW_LINE def SR ( n ) : return [ S ( ) for i in range ( n ) ] NEW_LINE def LSR ( n ) : return [ LS ( ) for i in range ( n ) ] NEW_LINE mod = 1000000007 NEW_LINE def score ( x ) : NEW_LINE INDENT res = 0 NEW_LINE for i in d . keys ( ) : NEW_LINE INDENT res += [ i ] * ( x - i ) NEW_LINE DEDENT return res NEW_LINE DEDENT print ( main ( ) ) NEW_LINE"],"references":["from collections import Counter NEW_LINE input ( ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE A . sort ( reverse = True ) NEW_LINE C = Counter ( A ) NEW_LINE ans = 0 NEW_LINE for a in A : NEW_LINE INDENT if not C [ a ] : NEW_LINE INDENT continue NEW_LINE DEDENT C [ a ] -= 1 NEW_LINE t = 2 ** a . bit_length ( ) - a NEW_LINE if C [ t ] : NEW_LINE INDENT C [ t ] -= 1 NEW_LINE ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE","import bisect NEW_LINE inpl = lambda : list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE _ = int ( input ( ) ) NEW_LINE A = sorted ( inpl ( ) ) NEW_LINE Anlist = [ ] NEW_LINE ap = 0 NEW_LINE for a in A : NEW_LINE INDENT if a > ap : NEW_LINE INDENT Anlist . append ( [ a , 1 ] ) NEW_LINE ap = a NEW_LINE DEDENT else : NEW_LINE INDENT Anlist [ - 1 ] [ 1 ] += 1 NEW_LINE DEDENT DEDENT A = [ a for a , n in Anlist ] NEW_LINE N = len ( Anlist ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if Anlist [ - i ] [ 1 ] == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT p = len ( bin ( A [ - i ] ) ) - 3 NEW_LINE B = ( 1 << ( p + 1 ) ) - A [ - i ] NEW_LINE if A [ - i ] == B : NEW_LINE INDENT ans += Anlist [ - i ] [ 1 ] \/\/ 2 NEW_LINE DEDENT else : NEW_LINE INDENT m = bisect . bisect_left ( A , B , 0 , N - i ) NEW_LINE if m < N - i and A [ m ] == B : NEW_LINE INDENT pairs = min ( Anlist [ m ] [ 1 ] , Anlist [ - i ] [ 1 ] ) NEW_LINE ans += pairs NEW_LINE Anlist [ m ] [ 1 ] -= pairs NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE","import collections NEW_LINE N = int ( input ( ) ) NEW_LINE A = collections . deque ( sorted ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE def func1 ( a , r , rnext ) : NEW_LINE INDENT p = a . popleft ( ) NEW_LINE q = a . pop ( ) NEW_LINE ans = 0 NEW_LINE a1 = collections . deque ( ) NEW_LINE while True : NEW_LINE INDENT if p + q == r : NEW_LINE INDENT ans += 1 NEW_LINE try : NEW_LINE INDENT p = a . popleft ( ) NEW_LINE DEDENT except : NEW_LINE INDENT break NEW_LINE DEDENT try : NEW_LINE INDENT q = a . pop ( ) NEW_LINE DEDENT except : NEW_LINE INDENT if p < rnext : NEW_LINE INDENT a1 . append ( p ) NEW_LINE DEDENT break NEW_LINE DEDENT DEDENT elif p + q > r : NEW_LINE INDENT try : NEW_LINE INDENT q = a . pop ( ) NEW_LINE DEDENT except : NEW_LINE INDENT if p < rnext : NEW_LINE INDENT a1 . append ( p ) NEW_LINE DEDENT break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT a1 . append ( p ) NEW_LINE try : NEW_LINE INDENT p = a . popleft ( ) NEW_LINE DEDENT except : NEW_LINE INDENT if q < rnext : NEW_LINE INDENT a1 . append ( q ) NEW_LINE DEDENT break NEW_LINE DEDENT DEDENT DEDENT return ans , a1 NEW_LINE DEDENT if N == 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE exit ( 0 ) NEW_LINE DEDENT t = int . bit_length ( A [ - 1 ] + A [ - 2 ] ) NEW_LINE r = 2 ** t NEW_LINE rnext = 2 ** ( t - 1 ) NEW_LINE anser = 0 NEW_LINE a = A NEW_LINE while True : NEW_LINE INDENT ans , a1 = func1 ( a , r , rnext ) NEW_LINE anser += ans NEW_LINE if len ( a1 ) < 2 : NEW_LINE INDENT break NEW_LINE DEDENT a = a1 NEW_LINE t -= 1 NEW_LINE r = rnext NEW_LINE rnext = 2 ** ( t - 1 ) NEW_LINE DEDENT print ( anser ) NEW_LINE"],"bleu":0.23310064991942683,"rouge_l":0.44971037388099006}
{"id":75,"predictions":["def solve ( arr , n , c ) : NEW_LINE INDENT ret = [ 0 ] * n NEW_LINE d = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT t = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE res = [ 0 ] * n NEW_LINE c [ 1 ] = t NEW_LINE for l in range ( n ) : NEW_LINE INDENT if l == 0 : NEW_LINE INDENT res . append ( max ( d [ l - 1 ] , c [ l - 1 ] + d [ l - 1 ] ) ) NEW_LINE d [ l ] = max ( d [ l - 1 ] , c [ l - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT res . append ( max ( d [ l ] , c [ l - 1 ] ) ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 0 NEW_LINE N , C = map ( int , input ( ) . split ( ) ) NEW_LINE data = [ list ( map ( int , input ( ) . split ( ) ) for _ in range ( N - 1 ) ] NEW_LINE print ( solve ( N , C , C , d ) ) NEW_LINE DEDENT"],"references":["N , C = [ int ( _ ) for _ in input ( ) . split ( ) ] NEW_LINE X = [ 0 ] * N NEW_LINE V = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT X [ i ] , V [ i ] = [ int ( _ ) for _ in input ( ) . split ( ) ] NEW_LINE DEDENT def calc ( X , V ) : NEW_LINE INDENT Vcumsum = [ 0 ] NEW_LINE for v in V : NEW_LINE INDENT Vcumsum += [ Vcumsum [ - 1 ] + v ] NEW_LINE DEDENT cumsum = [ 0 ] * ( N + 1 ) NEW_LINE cumsum_r = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT cumsum [ i + 1 ] = Vcumsum [ i + 1 ] - X [ i ] NEW_LINE cumsum_r [ i + 1 ] = Vcumsum [ N ] - Vcumsum [ N - i - 1 ] - ( C - X [ - 1 - i ] ) NEW_LINE DEDENT cumsum_max = [ 0 ] * ( N + 1 ) NEW_LINE cumsum_r_max = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT cumsum_max [ i + 1 ] = max ( cumsum [ i + 1 ] , cumsum_max [ i ] ) NEW_LINE cumsum_r_max [ i + 1 ] = max ( cumsum_r [ i + 1 ] , cumsum_r_max [ i ] ) NEW_LINE DEDENT res = max ( cumsum_max [ - 1 ] , cumsum_r_max [ - 1 ] ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT res = max ( res , cumsum_max [ i + 1 ] + cumsum_r_max [ N - i - 1 ] - X [ i ] , cumsum_r_max [ i + 1 ] + cumsum_max [ N - i - 1 ] - ( C - X [ - 1 - i ] ) ) NEW_LINE DEDENT return res NEW_LINE DEDENT print ( calc ( X , V ) ) NEW_LINE","import sys NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE input = sys . stdin . readline NEW_LINE N , C = map ( int , input ( ) . split ( ) ) NEW_LINE sushis = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] NEW_LINE valA = [ ] NEW_LINE valArev = [ ] NEW_LINE sumV = 0 NEW_LINE tmpMax = - float ( ' inf ' ) NEW_LINE for d , v in sushis : NEW_LINE INDENT sumV += v NEW_LINE valArev . append ( sumV - 2 * d ) NEW_LINE tmpMax = max ( tmpMax , sumV - d ) NEW_LINE valA . append ( tmpMax ) NEW_LINE DEDENT valB = [ ] NEW_LINE valBrev = [ ] NEW_LINE sumV = 0 NEW_LINE tmpMax = - float ( ' inf ' ) NEW_LINE for d , v in reversed ( sushis ) : NEW_LINE INDENT sumV += v NEW_LINE revD = C - d NEW_LINE valBrev . append ( sumV - 2 * revD ) NEW_LINE tmpMax = max ( tmpMax , sumV - revD ) NEW_LINE valB . append ( tmpMax ) NEW_LINE DEDENT ans = max ( valA + valB + [ 0 ] ) NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT ans = max ( ans , valArev [ i ] + valB [ N - i - 2 ] ) NEW_LINE DEDENT for i in range ( N - 1 ) : NEW_LINE INDENT ans = max ( ans , valBrev [ i ] + valA [ N - i - 2 ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE","def inpl ( ) : return [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE import numpy as np NEW_LINE N , C = inpl ( ) NEW_LINE x , v = np . array ( [ inpl ( ) for _ in range ( N ) ] ) . T NEW_LINE cwo = np . cumsum ( v ) - x NEW_LINE cwr = np . hstack ( ( [ 0 ] , cwo - x ) ) NEW_LINE cwo = np . hstack ( ( [ 0 ] , cwo ) ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT cwr [ i + 1 ] = max ( cwr [ i ] , cwr [ i + 1 ] ) NEW_LINE DEDENT av = v [ : : - 1 ] NEW_LINE ax = C - x [ : : - 1 ] NEW_LINE acwo = np . cumsum ( av ) - ax NEW_LINE acwr = np . hstack ( ( [ 0 ] , acwo - ax ) ) NEW_LINE acwo = np . hstack ( ( [ 0 ] , acwo ) ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT acwr [ i + 1 ] = max ( acwr [ i ] , acwr [ i + 1 ] ) NEW_LINE DEDENT ans1 = cwo + acwr [ : : - 1 ] NEW_LINE ans2 = acwo + cwr [ : : - 1 ] NEW_LINE print ( max ( np . max ( ans1 ) , np . max ( ans2 ) , 0 ) ) NEW_LINE"],"bleu":0.39870672218967096,"rouge_l":0.39491169288432054}
{"id":76,"predictions":["def inpl ( ) : return [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE N , M = inpl ( ) NEW_LINE if M < N : NEW_LINE INDENT N == 1 : NEW_LINE INDENT print ( M - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( M - 1 ) NEW_LINE DEDENT DEDENT"],"references":["n , m = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( n - 1 ) * ( m - 1 ) ) NEW_LINE","n , m = [ int ( item ) for item in input ( ) . split ( ) ] NEW_LINE print ( ( n - 1 ) * ( m - 1 ) ) NEW_LINE","[ n , m ] = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( ( n - 1 ) * ( m - 1 ) ) NEW_LINE"],"bleu":0.24412842419996195,"rouge_l":0.5220814789455666}
{"id":77,"predictions":["import sys NEW_LINE stdin = sys . stdin NEW_LINE sys . setrecursionlimit ( 10 ** 5 ) NEW_LINE def li ( ) : return map ( int , stdin . readline ( ) . split ( ) ) NEW_LINE def li_ ( ) : return map ( lambda x : int ( x ) - 1 , stdin . readline ( ) . split ( ) ) NEW_LINE def lf ( ) : return map ( float , stdin . readline ( ) . split ( ) ) NEW_LINE def ls ( ) : return stdin . readline ( ) . split ( ) NEW_LINE def ns ( ) : return stdin . readline ( ) . rstrip ( ) NEW_LINE def lc ( ) : return list ( ns ( ) ) NEW_LINE def ni ( ) : return int ( stdin . readline ( ) ) NEW_LINE def nf ( ) : return float ( stdin . readline ( ) ) NEW_LINE n , a , b , c = li ( ) = [ 0 ] * n NEW_LINE for _ in range ( n ) : NEW_LINE INDENT a , b , c , d = li ( ) NEW_LINE if a != b : NEW_LINE INDENT return min ( b , c , d ) NEW_LINE DEDENT q = li ( ) NEW_LINE b , c , d = li ( ) , li ( ) NEW_LINE if f ( a , b , c ) > d : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT DEDENT"],"references":["NM = 40 NEW_LINE ABM = 10 NEW_LINE MM = 400 NEW_LINE N , M1 , M2 = map ( int , input ( ) . split ( ) ) NEW_LINE A = [ ] NEW_LINE B = [ ] NEW_LINE C = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE A . append ( a ) NEW_LINE B . append ( b ) NEW_LINE C . append ( c ) NEW_LINE DEDENT cmax = max ( C ) NEW_LINE CM = N * cmax + 10 NEW_LINE dp = [ [ [ CM for broop in range ( 401 ) ] for aroop in range ( 401 ) ] for nroop in range ( N + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] [ 0 ] = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for cb in range ( 401 ) : NEW_LINE INDENT for ca in range ( 401 ) : NEW_LINE INDENT if dp [ i ] [ ca ] [ cb ] == CM : NEW_LINE INDENT continue NEW_LINE DEDENT dp [ i + 1 ] [ ca ] [ cb ] = min ( dp [ i + 1 ] [ ca ] [ cb ] , dp [ i ] [ ca ] [ cb ] ) NEW_LINE if ca + A [ i ] < 401 and cb + B [ i ] < 401 : NEW_LINE INDENT dp [ i + 1 ] [ ca + A [ i ] ] [ cb + B [ i ] ] = min ( dp [ i + 1 ] [ ca + A [ i ] ] [ cb + B [ i ] ] , dp [ i ] [ ca ] [ cb ] + C [ i ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = CM NEW_LINE for cb in range ( 400 ) : NEW_LINE INDENT for ca in range ( 400 ) : NEW_LINE INDENT CB = cb + 1 NEW_LINE CA = ca + 1 NEW_LINE if CA * M2 == CB * M1 : NEW_LINE INDENT ans = min ( ans , dp [ N ] [ CA ] [ CB ] ) NEW_LINE DEDENT DEDENT DEDENT if ans == CM : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT","def push ( k , v ) : NEW_LINE INDENT if k in dic : NEW_LINE INDENT dic [ k ] = min ( dic [ k ] , v ) NEW_LINE DEDENT else : NEW_LINE INDENT dic [ k ] = v NEW_LINE DEDENT DEDENT n , x , y = map ( int , str ( input ( ) ) . split ( ' ▁ ' ) ) NEW_LINE dic = { } NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT a = list ( map ( int , str ( input ( ) ) . split ( ' ▁ ' ) ) ) NEW_LINE k , v = a [ 0 ] * y - a [ 1 ] * x , a [ 2 ] NEW_LINE l = [ ] NEW_LINE for j in dic : NEW_LINE INDENT l . append ( [ j , dic [ j ] ] ) NEW_LINE DEDENT for jj in l : NEW_LINE INDENT push ( jj [ 0 ] + k , jj [ 1 ] + v ) NEW_LINE DEDENT push ( k , v ) NEW_LINE DEDENT if 0 in dic : NEW_LINE INDENT print ( dic [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' - 1' ) NEW_LINE DEDENT","import itertools NEW_LINE import sys NEW_LINE import math NEW_LINE from functools import lru_cache NEW_LINE from queue import Queue NEW_LINE n , a , b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ll = [ [ - 1 for i in range ( 401 ) ] for j in range ( 401 ) ] NEW_LINE ll [ 0 ] [ 0 ] = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ap , bp , price = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for aa in reversed ( range ( 390 ) ) : NEW_LINE INDENT for bb in reversed ( range ( 390 ) ) : NEW_LINE INDENT if ll [ aa ] [ bb ] >= 0 : NEW_LINE INDENT if ll [ aa + ap ] [ bb + bp ] < 0 : NEW_LINE INDENT ll [ aa + ap ] [ bb + bp ] = 99999 NEW_LINE DEDENT ll [ aa + ap ] [ bb + bp ] = min ( ll [ aa + ap ] [ bb + bp ] , ll [ aa ] [ bb ] + price ) NEW_LINE DEDENT DEDENT DEDENT DEDENT ret = 9999999 NEW_LINE for aa in range ( 401 ) : NEW_LINE INDENT for bb in range ( 1 , 401 ) : NEW_LINE INDENT if abs ( float ( aa ) \/ bb - float ( a ) \/ b ) < 0.001 and ll [ aa ] [ bb ] > 0 : NEW_LINE INDENT ret = min ( ret , ll [ aa ] [ bb ] ) NEW_LINE DEDENT DEDENT DEDENT if ret > 900000 : NEW_LINE INDENT print ( ' - 1' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ret ) NEW_LINE DEDENT"],"bleu":0.26816444017377483,"rouge_l":0.3964050482981601}
{"id":78,"predictions":["a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( 100 * ( 100 * a \/ 100 ) ) NEW_LINE"],"references":["D , N = map ( int , input ( ) . split ( ) ) NEW_LINE count = 0 NEW_LINE x = 0 NEW_LINE while count != N : NEW_LINE INDENT x += 1 NEW_LINE if x % 100 ** D == 0 and x % 100 ** ( D + 1 ) != 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( x ) NEW_LINE","d , n = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE if n == 100 : NEW_LINE INDENT print ( pow ( 100 , d ) * 101 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( pow ( 100 , d ) * n ) NEW_LINE DEDENT","import sys NEW_LINE INF = float ( \" inf \" ) NEW_LINE def solve ( D : int , N : int ) : NEW_LINE INDENT if N != 100 : NEW_LINE INDENT print ( str ( N ) + \"00\" * D ) NEW_LINE DEDENT else : NEW_LINE INDENT N = \"101\" NEW_LINE print ( str ( N ) + \"00\" * D ) NEW_LINE DEDENT return NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT def iterate_tokens ( ) : NEW_LINE INDENT for line in sys . stdin : NEW_LINE INDENT for word in line . split ( ) : NEW_LINE INDENT yield word NEW_LINE DEDENT DEDENT DEDENT tokens = iterate_tokens ( ) NEW_LINE D = int ( next ( tokens ) ) NEW_LINE N = int ( next ( tokens ) ) NEW_LINE solve ( D , N ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"bleu":0.23554034418785538,"rouge_l":0.42988019732205773}
{"id":79,"predictions":["N = input ( ) NEW_LINE print ( int ( N ) \/\/ 3 ) NEW_LINE"],"references":["print ( int ( input ( ) ) \/\/ 3 ) NEW_LINE","import math NEW_LINE n = int ( input ( ) ) NEW_LINE ans = math . floor ( n \/ 3 ) NEW_LINE print ( ans ) NEW_LINE","n = int ( input ( ) ) NEW_LINE import math NEW_LINE print ( math . floor ( n \/ 3 ) ) NEW_LINE"],"bleu":0.6136548980820371,"rouge_l":0.7230603448275862}
{"id":80,"predictions":["s = input ( ) NEW_LINE print ( s [ 0 ] + s [ 1 : ] ) NEW_LINE"],"references":["print ( \" A \" + input ( ) [ 8 ] + \" C \" ) NEW_LINE","import sys , re NEW_LINE from collections import deque , defaultdict , Counter NEW_LINE from math import ceil , sqrt , hypot , factorial , pi , sin , cos , radians NEW_LINE from itertools import permutations , combinations , product NEW_LINE from operator import itemgetter , mul NEW_LINE from copy import deepcopy NEW_LINE from string import ascii_lowercase , ascii_uppercase , digits NEW_LINE def input ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def INT ( ) : return int ( input ( ) ) NEW_LINE def MAP ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE INF = float ( ' inf ' ) NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE s = input ( ) . split ( ) NEW_LINE print ( s [ 0 ] [ 0 ] , s [ 1 ] [ 0 ] , s [ 2 ] [ 0 ] , sep = \" \" ) NEW_LINE","from sys import stdin NEW_LINE A , B , C = stdin . readline ( ) . rstrip ( ) . split ( ) NEW_LINE str = B NEW_LINE slice = str [ 0 : 1 ] NEW_LINE a = ' A ' NEW_LINE b = slice NEW_LINE c = ' C ' NEW_LINE print ( a + b + c ) NEW_LINE"],"bleu":0.7089602879922363,"rouge_l":0.5607763023493361}
{"id":81,"predictions":["s = input ( ) NEW_LINE t = [ ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT t . append ( s [ i ] ) NEW_LINE DEDENT flag = False NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if t [ i ] == ' T ' : NEW_LINE INDENT flag = True NEW_LINE break NEW_LINE DEDENT DEDENT if flag : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT"],"references":["s = input ( ) NEW_LINE if ( s [ - 1 ] == \" T \" ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT","def tea ( S : str ) -> bool : NEW_LINE INDENT return S . endswith ( ' T ' ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = input ( ) NEW_LINE yes = tea ( S ) NEW_LINE print ( ' YES ' if yes else ' NO ' ) NEW_LINE DEDENT","print ( [ \" YES \" , \" NO \" ] [ not ( input ( ) [ - 1 ] == \" T \" ) ] ) NEW_LINE"],"bleu":0.3250679513513411,"rouge_l":0.48474750064086125}
{"id":82,"predictions":["def inpl ( ) : return [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE N = int ( input ( ) ) NEW_LINE A = [ inpl ( ) ] NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if A [ i ] == A [ i ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if a [ i ] == a [ i - 1 ] : NEW_LINE INDENT ans += 1 NEW_LINE a [ i ] = ' x ' NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE","import numpy as np NEW_LINE N = int ( input ( ) ) NEW_LINE a = [ int ( _ ) for _ in input ( ) . split ( ) ] NEW_LINE List = np . array ( [ ] ) NEW_LINE tmp = 0 NEW_LINE cnt = 0 NEW_LINE for i in a : NEW_LINE INDENT if i == tmp : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT List = np . append ( List , cnt ) NEW_LINE cnt = 1 NEW_LINE tmp = i NEW_LINE DEDENT DEDENT List = np . append ( List , cnt ) NEW_LINE print ( int ( sum ( List \/\/ 2 ) ) ) NEW_LINE","N = int ( input ( ) ) NEW_LINE a = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE counter = 0 NEW_LINE i = 0 NEW_LINE while i < N - 1 : NEW_LINE INDENT if ( a [ i ] == a [ i + 1 ] ) : NEW_LINE INDENT counter += 1 NEW_LINE i += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print ( counter ) NEW_LINE"],"bleu":0.6975015313849454,"rouge_l":0.6398382065608611}
{"id":83,"predictions":["import sys NEW_LINE INF = float ( ' inf ' ) NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def II ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def SI ( ) : return input ( ) NEW_LINE def main ( ) : NEW_LINE INDENT n , x = LI ( ) NEW_LINE x , y = LI ( ) NEW_LINE total = X * ( n - 1 ) + 5 * ( n - 1 ) NEW_LINE val = [ 0 ] * ( n - 1 ) NEW_LINE for i in range ( total ) : NEW_LINE INDENT if ( val [ i ] > val [ 0 ] ) : NEW_LINE INDENT val [ i ] = val [ i ] + x NEW_LINE DEDENT else : NEW_LINE INDENT val [ i ] = val [ i ] NEW_LINE arr [ i + 1 ] = val [ i ] + x NEW_LINE arr [ i + 1 ] = val [ i ] NEW_LINE DEDENT return val NEW_LINE DEDENT print ( main ( ) ) NEW_LINE"],"references":["iN , iX = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE aX = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE aCum = [ 0 ] * iN NEW_LINE aCum [ 0 ] = aX [ 0 ] NEW_LINE for i in range ( 1 , iN ) : NEW_LINE INDENT aCum [ i ] = aCum [ i - 1 ] + aX [ i ] NEW_LINE DEDENT def fCeil ( iT , iR ) : NEW_LINE INDENT return - 1 * iT \/\/ iR * - 1 NEW_LINE DEDENT def fCalcCost ( iN , iX , aCum , iK ) : NEW_LINE INDENT return ( iN + iK ) * iX + 5 * aCum [ - 1 ] + sum ( 2 * aCum [ - i * iK - 1 ] for i in range ( 2 , fCeil ( iN , iK ) ) ) NEW_LINE DEDENT iTotalCost = fCalcCost ( iN , iX , aCum , 1 ) NEW_LINE iULim = fCeil ( iN , 2 ) + 1 NEW_LINE for iK in range ( 2 , fCeil ( iN , 2 ) + 1 ) : NEW_LINE INDENT iThisCost = fCalcCost ( iN , iX , aCum , iK ) NEW_LINE if iThisCost > iTotalCost : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT iTotalCost = iThisCost NEW_LINE DEDENT DEDENT print ( iTotalCost ) NEW_LINE","from collections import defaultdict , deque NEW_LINE import sys , heapq , bisect , math , itertools , string , queue , datetime NEW_LINE sys . setrecursionlimit ( 10 ** 8 ) NEW_LINE INF = float ( ' inf ' ) NEW_LINE mod = 10 ** 9 + 7 NEW_LINE def inpl ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def inpls ( ) : return list ( input ( ) . split ( ) ) NEW_LINE N , X = inpl ( ) NEW_LINE xx = inpl ( ) NEW_LINE sum_xx = [ 0 ] NEW_LINE tmp = 0 NEW_LINE for x in xx : NEW_LINE INDENT tmp += x NEW_LINE sum_xx . append ( tmp ) NEW_LINE DEDENT ans = INF NEW_LINE for k in range ( 1 , N + 1 ) : NEW_LINE INDENT tmp = X * ( k + N ) NEW_LINE i = 0 NEW_LINE l = N - k NEW_LINE r = N NEW_LINE while True : NEW_LINE INDENT if i <= 1 : cost = 5 NEW_LINE else : cost = 3 + i * 2 NEW_LINE if l >= 0 : NEW_LINE INDENT tmp += ( sum_xx [ r ] - sum_xx [ l ] ) * cost NEW_LINE DEDENT else : NEW_LINE INDENT tmp += ( sum_xx [ r ] - sum_xx [ 0 ] ) * cost NEW_LINE break NEW_LINE DEDENT l -= k NEW_LINE r -= k NEW_LINE i += 1 NEW_LINE DEDENT ans = min ( ans , tmp ) NEW_LINE DEDENT print ( ans ) NEW_LINE","from itertools import accumulate NEW_LINE N , X = map ( int , input ( ) . split ( ) ) NEW_LINE dust_acc = [ 0 ] + list ( accumulate ( list ( map ( int , input ( ) . split ( ) ) ) [ : : - 1 ] ) ) NEW_LINE dust_acc += [ dust_acc [ - 1 ] ] * N NEW_LINE coef = [ 5 ] + [ 5 + i * 2 for i in range ( N - 1 ) ] NEW_LINE ans = float ( \" inf \" ) NEW_LINE for robot_count in range ( 1 , N + 1 ) : NEW_LINE INDENT cost = sum ( ( plus - minus ) * c for plus , minus , c in zip ( dust_acc [ robot_count : : robot_count ] , dust_acc [ : N : robot_count ] , coef ) ) + robot_count * X NEW_LINE if ans > cost : NEW_LINE INDENT ans = cost NEW_LINE DEDENT DEDENT print ( ans + N * X ) NEW_LINE"],"bleu":0.34902605563787265,"rouge_l":0.39589545693737943}
{"id":84,"predictions":["a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( c * ( a + b ) - ( ( a + b ) * c ) \/\/ 2 ) NEW_LINE"],"references":["a , b , h = map ( int , open ( 0 ) . read ( ) . split ( ) ) NEW_LINE S = int ( ( a + b ) * h \/ 2 ) NEW_LINE print ( S ) NEW_LINE","def trapezoids ( a : int , b : int , h : int ) -> int : NEW_LINE INDENT return ( a + b ) * h \/\/ 2 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a , b , h = [ int ( input ( ) ) for _ in range ( 3 ) ] NEW_LINE ans = trapezoids ( a , b , h ) NEW_LINE print ( ans ) NEW_LINE DEDENT","a = int ( input ( ) ) NEW_LINE b = int ( input ( ) ) NEW_LINE h = int ( input ( ) ) NEW_LINE print ( int ( ( a + b ) * h \/ 2 ) ) NEW_LINE"],"bleu":0.5663363997592706,"rouge_l":0.6194057916509966}
{"id":85,"predictions":["import sys NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE input = sys . stdin . readline NEW_LINE N = int ( input ( ) ) NEW_LINE S = [ input ( ) for _ in range ( N ) ] NEW_LINE def main ( ) : NEW_LINE INDENT S = [ list ( input ( ) ) for _ in range ( N ) ] NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if S [ i ] [ j ] == \" . \" : NEW_LINE INDENT S [ i ] [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if S [ i ] [ j ] == \" o \" : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"references":["field = [ ] NEW_LINE n = int ( input ( ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT field . append ( list ( map ( str , input ( ) ) ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ' . ' in field [ i ] : NEW_LINE INDENT j = n - field [ i ] [ : : - 1 ] . index ( ' . ' ) - 1 NEW_LINE field [ i ] = [ ' o ' ] * n NEW_LINE if i != n - 1 : NEW_LINE INDENT field [ i + 1 ] [ j : ] = [ ' O ' ] * len ( field [ i + 1 ] [ j : ] ) NEW_LINE DEDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE","import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE inf = 10 ** 20 NEW_LINE mod = 10 ** 9 + 7 NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def F ( ) : return float ( sys . stdin . readline ( ) ) NEW_LINE def S ( ) : return input ( ) NEW_LINE def main ( ) : NEW_LINE INDENT n = I ( ) NEW_LINE k = inf NEW_LINE r = 0 NEW_LINE for _ in range ( n ) : NEW_LINE INDENT s = S ( ) [ : k ] NEW_LINE if ' . ' not in s : NEW_LINE INDENT k = inf NEW_LINE continue NEW_LINE DEDENT ri = s . rindex ( ' . ' ) NEW_LINE r += 1 NEW_LINE k = ri NEW_LINE DEDENT return r NEW_LINE DEDENT print ( main ( ) ) NEW_LINE","N = int ( input ( ) ) NEW_LINE lines = [ input ( ) for i in range ( N ) ] NEW_LINE count = 0 ; y = - 1 ; flag = False NEW_LINE while y < N - 1 : NEW_LINE INDENT y += 1 NEW_LINE x = N NEW_LINE while x > 0 : NEW_LINE INDENT x -= 1 NEW_LINE if ( lines [ y ] [ x ] == ' . ' ) : NEW_LINE INDENT count += 1 NEW_LINE if y + 1 <= N - 1 : y += 1 NEW_LINE else : flag = True ; break NEW_LINE DEDENT DEDENT if flag : break NEW_LINE DEDENT print ( count ) NEW_LINE"],"bleu":0.46036827922059004,"rouge_l":0.47506827146758374}
{"id":86,"predictions":["import sys NEW_LINE input = sys . stdin . readline NEW_LINE N = int ( input ( ) ) NEW_LINE l = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] NEW_LINE T = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] NEW_LINE f = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT f [ i ] = max ( f [ i + 1 ] , f [ i ] ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT s = max ( f [ i ] , s ) - f [ i ] ) NEW_LINE if s < 0 : NEW_LINE INDENT ans += l [ i ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["n = int ( input ( ) ) NEW_LINE t = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE v = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE maxspeed = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT maxspeed [ i ] = min ( v [ i ] , v [ i - 1 ] , t [ i ] + maxspeed [ i + 1 ] ) NEW_LINE DEDENT def dist ( i , first ) : NEW_LINE INDENT ta = v [ i ] - first NEW_LINE tb = v [ i ] - maxspeed [ i + 1 ] NEW_LINE if ta + tb <= t [ i ] : NEW_LINE INDENT c = ( first + v [ i ] ) * ta \/ 2 + v [ i ] * ( t [ i ] - ta - tb ) + ( maxspeed [ i + 1 ] + v [ i ] ) * tb \/ 2 NEW_LINE lastspeed = maxspeed [ i + 1 ] NEW_LINE DEDENT elif maxspeed [ i + 1 ] - first > t [ i ] : NEW_LINE INDENT c = ( first + first + t [ i ] ) * t [ i ] \/ 2 NEW_LINE lastspeed = first + t [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT a = ( maxspeed [ i + 1 ] + t [ i ] - first ) \/ 2 NEW_LINE c = ( first + first + a ) * a \/ 2 + ( first + a + maxspeed [ i + 1 ] ) * ( t [ i ] - a ) \/ 2 NEW_LINE lastspeed = maxspeed [ i + 1 ] NEW_LINE DEDENT return c , lastspeed NEW_LINE DEDENT ans = 0 NEW_LINE firstspeed = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT d , firstspeed = dist ( i , firstspeed ) NEW_LINE ans += d NEW_LINE DEDENT print ( ans ) NEW_LINE","def atcoder_express ( N : int , T : list , V : list ) -> float : NEW_LINE INDENT MAXT = sum ( T ) NEW_LINE graph = [ 0 ] * ( 2 * MAXT + 1 ) NEW_LINE T = [ 0 , 0 ] + T + [ 0 ] NEW_LINE for i in range ( N + 2 ) : NEW_LINE INDENT T [ i + 1 ] += T [ i ] NEW_LINE DEDENT V = [ 0 ] + V + [ 0 ] NEW_LINE conditions = [ ] NEW_LINE for i in range ( N + 2 ) : NEW_LINE INDENT v , l , r = V [ i ] , T [ i ] , T [ i + 1 ] NEW_LINE conditions . append ( ( l , r , v ) ) NEW_LINE DEDENT total = 0.0 NEW_LINE prev_v = 0.0 NEW_LINE for t in range ( MAXT * 2 + 1 ) : NEW_LINE INDENT min_v = float ( ' inf ' ) NEW_LINE x = t \/ 2 NEW_LINE for l , r , v in conditions : NEW_LINE INDENT if x < l : NEW_LINE INDENT min_v = min ( min_v , v + ( l - x ) ) NEW_LINE DEDENT elif r < x : NEW_LINE INDENT min_v = min ( min_v , v + ( x - r ) ) NEW_LINE DEDENT else : NEW_LINE INDENT min_v = min ( min_v , v ) NEW_LINE DEDENT DEDENT total += ( prev_v + min_v ) * 0.5 \/ 2 NEW_LINE prev_v = min_v NEW_LINE DEDENT return total NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE T = [ int ( s ) for s in input ( ) . split ( ) ] NEW_LINE V = [ int ( s ) for s in input ( ) . split ( ) ] NEW_LINE ans = atcoder_express ( N , T , V ) NEW_LINE print ( ans ) NEW_LINE DEDENT","import sys , collections , bisect , math , itertools NEW_LINE from fractions import gcd NEW_LINE input = sys . stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE t = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE v = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE maxspeed = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT maxspeed [ i ] = min ( v [ i ] , v [ i - 1 ] , t [ i ] + maxspeed [ i + 1 ] ) NEW_LINE DEDENT def dist ( first , i ) : NEW_LINE INDENT ti = t [ i ] NEW_LINE vi = v [ i ] NEW_LINE mi1 = maxspeed [ i + 1 ] NEW_LINE ta = vi - first NEW_LINE tb = vi - mi1 NEW_LINE if ta + tb <= ti : NEW_LINE INDENT c = ( first + vi ) * ta \/ 2 + vi * ( ti - ta - tb ) + ( mi1 + vi ) * tb \/ 2 NEW_LINE lastspeed = mi1 NEW_LINE DEDENT elif mi1 - first > ti : NEW_LINE INDENT c = ( first + first + ti ) * ti \/ 2 NEW_LINE lastspeed = first + ti NEW_LINE DEDENT else : NEW_LINE INDENT a = ( mi1 + ti - first ) \/ 2 NEW_LINE c = ( first + first + a ) * a \/ 2 + ( first + a + mi1 ) * ( ti - a ) \/ 2 NEW_LINE lastspeed = mi1 NEW_LINE DEDENT return c , lastspeed NEW_LINE DEDENT ans = 0 NEW_LINE firstspeed = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT d , firstspeed = dist ( firstspeed , i ) NEW_LINE ans += d NEW_LINE DEDENT print ( ans ) NEW_LINE"],"bleu":0.17882270761690208,"rouge_l":0.3751044776119403}
{"id":87,"predictions":["N , M = map ( int , input ( ) . split ( ) ) NEW_LINE src = [ ] NEW_LINE imos = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT l , r , s = map ( int , input ( ) . split ( ) ) NEW_LINE src . append ( ( s , l , r ) ) NEW_LINE imos [ l ] [ s ] -= imos [ s - 1 ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT l , r , s , s , e = map ( int , input ( ) . split ( ) ) NEW_LINE if ( r - l + 1 ) % s == M : NEW_LINE INDENT ans = min ( ans , l - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT l -= s NEW_LINE l -= l NEW_LINE r -= s NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["import itertools NEW_LINE N , M = map ( int , input ( ) . split ( ) ) NEW_LINE score = [ 0 ] * ( M + 1 ) NEW_LINE s_sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT l , r , s = map ( int , input ( ) . split ( ) ) NEW_LINE score [ ( l - 1 ) ] += s NEW_LINE score [ r ] += - s NEW_LINE s_sum += s NEW_LINE DEDENT score_list = list ( itertools . accumulate ( score ) ) NEW_LINE ans = s_sum - min ( score_list [ : - 1 ] ) NEW_LINE print ( ans ) NEW_LINE","import sys NEW_LINE input = sys . stdin . readline NEW_LINE inf = 10 ** 18 NEW_LINE N , M = map ( int , input ( ) . split ( ) ) NEW_LINE lrs = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] NEW_LINE imos = [ 0 ] * ( M + 1 ) NEW_LINE for li , ri , si in lrs : NEW_LINE INDENT imos [ li - 1 ] += si NEW_LINE imos [ ri ] -= si NEW_LINE DEDENT tmp = 0 NEW_LINE loss = [ 0 ] * M NEW_LINE for i , imosi in enumerate ( imos ) : NEW_LINE INDENT if i == M : break NEW_LINE tmp += imosi NEW_LINE loss [ i ] = tmp NEW_LINE DEDENT print ( sum ( [ si for li , ri , si in lrs ] ) - min ( loss ) ) NEW_LINE","N , m = map ( int , input ( ) . split ( ) ) NEW_LINE cry = [ 0 for i in range ( m + 1 ) ] NEW_LINE data = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT li , ri , si = map ( int , input ( ) . split ( ) ) NEW_LINE if not ( li == 1 and ri == N ) : NEW_LINE INDENT cry [ li - 1 ] += 1 NEW_LINE cry [ ri ] -= 1 NEW_LINE data . append ( [ li , ri , si ] ) NEW_LINE DEDENT DEDENT cur = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT cur += cry [ i ] NEW_LINE cry [ i ] = cur NEW_LINE DEDENT cry . remove ( cry [ - 1 ] ) NEW_LINE res = [ ] NEW_LINE small = min ( cry ) NEW_LINE if small == 0 : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( data ) ) : NEW_LINE INDENT count += data [ i ] [ 2 ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT while small in cry : NEW_LINE INDENT count = 0 NEW_LINE ind = cry . index ( small ) NEW_LINE for i in range ( len ( data ) ) : NEW_LINE INDENT if not ( data [ i ] [ 0 ] <= ind + 1 <= data [ i ] [ 1 ] ) : NEW_LINE INDENT count += data [ i ] [ 2 ] NEW_LINE DEDENT DEDENT cry [ ind ] = 10 ** 6 NEW_LINE res . append ( count ) NEW_LINE DEDENT count = max ( res ) NEW_LINE DEDENT print ( count ) NEW_LINE"],"bleu":0.5417593272673871,"rouge_l":0.65091064923934}
{"id":88,"predictions":["import math NEW_LINE n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if ( l [ 1 ] == [ 0 , 1 ] ) : NEW_LINE INDENT if ( l [ 2 ] == [ 0 , 1 ] ) : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT"],"references":["D = int ( input ( ) ) NEW_LINE print ( \" Christmas \" + \" ▁ Eve \" * ( 25 - D ) ) NEW_LINE","d = int ( input ( ) ) NEW_LINE if d == 25 : NEW_LINE INDENT print ( ' Christmas ' ) NEW_LINE DEDENT if d == 24 : NEW_LINE INDENT print ( ' Christmas ▁ Eve ' ) NEW_LINE DEDENT if d == 23 : NEW_LINE INDENT print ( ' Christmas ▁ Eve ▁ Eve ' ) NEW_LINE DEDENT if d == 22 : NEW_LINE INDENT print ( ' Christmas ▁ Eve ▁ Eve ▁ Eve ' ) NEW_LINE DEDENT","def main ( ) : NEW_LINE INDENT a = 25 - int ( input ( ) ) NEW_LINE print ( ' Christmas ' , end = ' ' ) NEW_LINE for i in range ( a ) : NEW_LINE INDENT print ( ' ▁ Eve ' , end = ' ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"bleu":0.3497242988066828,"rouge_l":0.4739093511150253}
{"id":89,"predictions":["a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE if a > b : NEW_LINE INDENT print ( \" Pair \" ) NEW_LINE DEDENT elif a < 0 : NEW_LINE INDENT print ( \" Prime \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Odd \" ) NEW_LINE DEDENT"],"references":["n , a , b = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE num = n % ( a + b ) NEW_LINE if num == 0 : NEW_LINE INDENT print ( \" Bug \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Ant \" if num <= a else \" Bug \" ) NEW_LINE DEDENT","N , A , B = map ( int , input ( ) . split ( ) ) NEW_LINE while True : NEW_LINE INDENT N -= A NEW_LINE if N <= 0 : NEW_LINE INDENT res = ' Ant ' NEW_LINE break NEW_LINE DEDENT N -= B NEW_LINE if N <= 0 : NEW_LINE INDENT res = ' Bug ' NEW_LINE break NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE","n , a , b = map ( int , input ( ) . split ( ) ) ; print ( ' BAungt ' [ 0 < n % ( a + b ) <= a : : 2 ] ) NEW_LINE"],"bleu":0.5944671649902151,"rouge_l":0.5987918449534356}
{"id":90,"predictions":["s = input ( ) NEW_LINE temp = \" \" NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == \" : NEW_LINE INDENT temp = \" \" NEW_LINE DEDENT DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] != \" < \" : NEW_LINE INDENT continue NEW_LINE DEDENT elif s [ i ] == \" ▁ \" : NEW_LINE INDENT temp = \" \" NEW_LINE DEDENT elif s [ i ] == \" & \" : NEW_LINE INDENT temp = s [ i ] + \" > \" NEW_LINE DEDENT elif s [ i ] == \" < \" : NEW_LINE INDENT temp = s [ i ] + \" < \" NEW_LINE DEDENT DEDENT print ( temp ) NEW_LINE"],"references":["n = input ( ) NEW_LINE print ( n . replace ( \" Right \" , \" > \" ) . replace ( \" AtCoder \" , \" A \" ) . replace ( \" Left \" , \" < \" ) ) NEW_LINE","a = list ( input ( ) . split ( ) ) NEW_LINE c = \" \" NEW_LINE for i in a : NEW_LINE INDENT if i [ 0 ] == \" A \" : NEW_LINE INDENT c += \" A \" NEW_LINE DEDENT else : NEW_LINE INDENT if i [ 0 ] != \" L \" : NEW_LINE INDENT c += \" > \" NEW_LINE DEDENT else : NEW_LINE INDENT c += \" < \" NEW_LINE DEDENT DEDENT c += \" ▁ \" NEW_LINE DEDENT print ( c [ : - 1 ] ) NEW_LINE","print ( * [ \" < \" * ( i [ 0 ] == \" L \" ) + \" > \" * ( i [ 0 ] == \" R \" ) + \" A \" * ( i [ 0 ] == \" A \" ) for i in input ( ) . split ( ) ] ) NEW_LINE"],"bleu":0.2864096508361266,"rouge_l":0.5068041827818364}
{"id":91,"predictions":["print ( \" YNeos \" [ len ( set ( input ( ) [ 0 : 3 : 2 ] ) ) - 1 : : 2 ] ) NEW_LINE"],"references":["num = input ( ) NEW_LINE print ( \" Yes \" if num [ 0 ] == num [ 1 ] == num [ 2 ] or num [ 1 ] == num [ 2 ] == num [ 3 ] else \" No \" ) NEW_LINE","N = input ( ) NEW_LINE if N [ 0 : 3 ] . count ( N [ 0 ] ) == 3 or N [ 1 : 4 ] . count ( N [ 1 ] ) == 3 : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT","n = input ( ) NEW_LINE count = 1 NEW_LINE prev = \"0\" NEW_LINE for c in n : NEW_LINE INDENT if prev == c : NEW_LINE INDENT count += 1 NEW_LINE if count == 3 : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT count = 1 NEW_LINE DEDENT prev = c NEW_LINE DEDENT print ( \" No \" ) NEW_LINE"],"bleu":0.15355140865520414,"rouge_l":0.3320174651593995}
{"id":92,"predictions":["import sys NEW_LINE ns = lambda : sys . stdin . readline ( ) . rstrip ( ) NEW_LINE ni = lambda : int ( ns ( ) ) NEW_LINE nm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE nl = lambda : list ( nm ( ) ) NEW_LINE n , k = nm ( ) NEW_LINE a = nl ( ) NEW_LINE b = list ( accumulate ( a ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT ans += a [ i ] NEW_LINE DEDENT print ( ans ) NEW_LINE"],"references":["def main ( ) : NEW_LINE INDENT from collections import Counter NEW_LINE n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for index , ( key , value ) in enumerate ( sorted ( Counter ( a ) . items ( ) , key = lambda x : x [ 1 ] , reverse = True ) , 1 ) : NEW_LINE INDENT if index > k : NEW_LINE INDENT ans += value NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT","from collections import defaultdict NEW_LINE N , K = map ( int , input ( ) . split ( ) ) NEW_LINE As = map ( int , input ( ) . split ( ) ) NEW_LINE counts = defaultdict ( int ) NEW_LINE for a in As : NEW_LINE INDENT counts [ a ] += 1 NEW_LINE DEDENT counts = sorted ( counts . values ( ) ) NEW_LINE if len ( counts ) <= K : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT total = 0 NEW_LINE for i in range ( len ( counts ) - K ) : NEW_LINE INDENT total += counts [ i ] NEW_LINE DEDENT print ( total ) NEW_LINE DEDENT","import collections NEW_LINE def inpl ( ) : return [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE N , K = inpl ( ) NEW_LINE A = list ( sorted ( collections . Counter ( inpl ( ) ) . values ( ) ) ) NEW_LINE if len ( A ) <= K : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( sum ( A [ : len ( A ) - K ] ) ) NEW_LINE DEDENT"],"bleu":0.45200599779278505,"rouge_l":0.49620846546256725}
{"id":93,"predictions":["l = sorted ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print = l [ 0 ] * l [ 1 ] * l [ 2 ] NEW_LINE"],"references":["a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if a [ 0 ] * a [ 1 ] == a [ 2 ] * a [ 3 ] : NEW_LINE INDENT print ( a [ 0 ] * a [ 1 ] ) NEW_LINE DEDENT elif a [ 0 ] * a [ 1 ] > a [ 2 ] * a [ 3 ] : NEW_LINE INDENT print ( a [ 0 ] * a [ 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a [ 2 ] * a [ 3 ] ) NEW_LINE DEDENT","from functools import reduce NEW_LINE def main ( ) : NEW_LINE INDENT a , b , c , d = ( int ( _ ) for _ in input ( ) . split ( ) ) NEW_LINE print ( max ( a * b , c * d ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT","A , B , C , D = map ( int , input ( ) . split ( ) ) NEW_LINE men_1 = A * B NEW_LINE men_2 = C * D NEW_LINE print ( max ( men_1 , men_2 ) ) NEW_LINE"],"bleu":0.4951608368287787,"rouge_l":0.5250816265954289}
{"id":94,"predictions":["a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( b - a % b ) % a ) NEW_LINE"],"references":["a = int ( input ( ) ) NEW_LINE b = int ( input ( ) ) NEW_LINE print ( b - a % b if a % b != 0 else 0 ) NEW_LINE","a , b = map ( int , open ( 0 ) ) ; print ( - a % b ) NEW_LINE","a = int ( input ( ) ) NEW_LINE b = int ( input ( ) ) NEW_LINE if 1 <= a <= 100 and 1 <= b <= 100 : NEW_LINE INDENT if b <= a : NEW_LINE INDENT if a % b == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif a % b != 0 : NEW_LINE INDENT print ( b - ( a % b ) ) NEW_LINE DEDENT DEDENT elif a < b : NEW_LINE INDENT print ( b - a ) NEW_LINE DEDENT DEDENT"],"bleu":0.6742573329828824,"rouge_l":0.8050135758034982}
{"id":95,"predictions":["def way ( H , W , B ) : NEW_LINE INDENT if W == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if W == H - 1 : NEW_LINE INDENT return W - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT H , W = map ( int , input ( ) . split ( ) ) NEW_LINE dp = [ [ 0 ] * W for i in range ( W + H + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( H - 1 ) : NEW_LINE INDENT for j in range ( W ) : NEW_LINE INDENT if dp [ i + j ] [ i ] == 1 : NEW_LINE INDENT dp [ i + 1 ] [ j + 1 ] = 1 NEW_LINE DEDENT DEDENT DEDENT print ( dp [ H ] [ W - 1 ] ) NEW_LINE"],"references":["x , y = map ( int , input ( ) . split ( ) ) NEW_LINE x , y = x - 1 , y - 1 NEW_LINE mod = 1000000007 NEW_LINE c = 1 NEW_LINE for i in range ( min ( x , y ) ) : NEW_LINE INDENT c = ( c * ( x + y - i ) * pow ( i + 1 , mod - 2 , mod ) % mod ) NEW_LINE DEDENT print ( c % mod ) NEW_LINE","import math NEW_LINE import numpy as np NEW_LINE import copy NEW_LINE from collections import defaultdict , Counter NEW_LINE from itertools import product NEW_LINE from bisect import bisect_left , bisect_right NEW_LINE def s_inpl ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE def inpl ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE W , H = s_inpl ( ) NEW_LINE W -= 1 NEW_LINE H -= 1 NEW_LINE MOD = 1000000007 NEW_LINE def power ( a , b ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif b % 2 == 0 : NEW_LINE INDENT d = power ( a , b \/ 2 ) NEW_LINE return ( d * d ) % MOD NEW_LINE DEDENT elif b % 2 == 1 : NEW_LINE INDENT return ( a * power ( a , b - 1 ) ) % MOD NEW_LINE DEDENT DEDENT def div ( a , b ) : NEW_LINE INDENT return ( a * power ( b , MOD - 2 ) ) % MOD NEW_LINE DEDENT print ( div ( math . factorial ( W + H ) , ( math . factorial ( W ) % MOD ) * ( math . factorial ( H ) % MOD ) ) ) NEW_LINE","W , H = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if W > H : NEW_LINE INDENT W , H = H , W NEW_LINE DEDENT mod = int ( 1e9 + 7 ) NEW_LINE def prodmod ( a , b ) : NEW_LINE INDENT return a * b % mod NEW_LINE DEDENT def divmod ( a ) : NEW_LINE INDENT return powermod ( a , mod - 2 ) NEW_LINE DEDENT def powermod ( a , n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return a % mod NEW_LINE DEDENT if n % 2 : NEW_LINE INDENT return powermod ( a , n \/\/ 2 ) ** 2 * a % mod NEW_LINE DEDENT else : NEW_LINE INDENT return powermod ( a , n \/\/ 2 ) ** 2 % mod NEW_LINE DEDENT DEDENT from functools import reduce NEW_LINE print ( prodmod ( reduce ( prodmod , list ( range ( H , H + W - 1 ) ) ) , reduce ( prodmod , [ divmod ( a ) for a in range ( 1 , W ) ] ) ) ) NEW_LINE"],"bleu":0.3927961216814549,"rouge_l":0.4092488319156583}
{"id":96,"predictions":["from functools import reduce NEW_LINE import math NEW_LINE def main ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE K = [ int ( _ ) for _ in input ( ) . split ( ) ] NEW_LINE a = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT a , b = [ int ( _ ) for _ in input ( ) . split ( ) ] NEW_LINE if a % K == 0 : NEW_LINE INDENT print ( ' Aoki ' ) NEW_LINE break NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"references":["def extgcd ( a , b ) : NEW_LINE INDENT if b : NEW_LINE INDENT d , y , x = extgcd ( b , a % b ) NEW_LINE y -= ( a \/ b ) * x NEW_LINE return d , x , y NEW_LINE DEDENT else : NEW_LINE INDENT return a , 1 , 0 NEW_LINE DEDENT DEDENT N = int ( input ( ) ) NEW_LINE grundy = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT a , k = map ( int , input ( ) . split ( ) ) NEW_LINE while a % k : NEW_LINE INDENT p , q = divmod ( a , k ) NEW_LINE a -= ( p + 1 ) * ( ( q + p ) \/\/ ( p + 1 ) ) NEW_LINE DEDENT grundy ^= a \/\/ k NEW_LINE DEDENT print ( ' Takahashi ' if grundy else ' Aoki ' ) NEW_LINE","N = int ( input ( ) ) NEW_LINE grundy = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT a , k = map ( int , input ( ) . split ( ) ) NEW_LINE while a % k : NEW_LINE INDENT p , q = divmod ( a , k ) NEW_LINE a -= ( p + 1 ) * ( ( p + q ) \/\/ ( p + 1 ) ) NEW_LINE DEDENT grundy ^= a \/\/ k NEW_LINE DEDENT print ( ' Takahashi ' if grundy else ' Aoki ' ) NEW_LINE","N = int ( input ( ) ) NEW_LINE grundy = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT a , k = map ( int , input ( ) . split ( ) ) NEW_LINE while a % k : NEW_LINE INDENT p , q = divmod ( a , k ) NEW_LINE a -= ( p + 1 ) * ( ( p + q ) \/\/ ( p + 1 ) ) NEW_LINE DEDENT grundy ^= a \/\/ k NEW_LINE DEDENT print ( ' Takahashi ' if grundy else ' Aoki ' ) NEW_LINE"],"bleu":0.3839145886000569,"rouge_l":0.5039101222601607}
{"id":97,"predictions":["N , M = map ( int , input ( ) . split ( ) ) NEW_LINE matrix = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT matrix . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT point = 0 NEW_LINE for i in range ( M ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT if matrix [ i ] [ j ] != matrix [ i ] [ j ] : NEW_LINE INDENT row += 1 NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if matrix [ i ] [ j ] != matrix [ j ] [ i ] : NEW_LINE INDENT row += 1 NEW_LINE DEDENT DEDENT DEDENT ans = [ ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT ans . append ( str ( i ) ) NEW_LINE for j in range ( M ) : NEW_LINE INDENT print ( \" { } \" . format ( ans ) , end = \" ▁ \" ) NEW_LINE DEDENT print ( \" { } \" . format ( ans ) ) NEW_LINE DEDENT"],"references":["N , M = map ( int , input ( ) . split ( ) ) NEW_LINE py = [ ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT py . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE py [ i ] . append ( i ) NEW_LINE DEDENT py . sort ( key = lambda x : ( x [ 0 ] , x [ 1 ] ) ) NEW_LINE number = [ ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT ct = 1 NEW_LINE number . append ( ( str ( py [ i ] [ 0 ] ) . zfill ( 6 ) + str ( ct ) . zfill ( 6 ) , py [ i ] [ 2 ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT if py [ i - 1 ] [ 0 ] == py [ i ] [ 0 ] : NEW_LINE INDENT ct += 1 NEW_LINE number . append ( ( str ( py [ i ] [ 0 ] ) . zfill ( 6 ) + str ( ct ) . zfill ( 6 ) , py [ i ] [ 2 ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT ct = 1 NEW_LINE number . append ( ( str ( py [ i ] [ 0 ] ) . zfill ( 6 ) + str ( ct ) . zfill ( 6 ) , py [ i ] [ 2 ] ) ) NEW_LINE DEDENT DEDENT DEDENT number . sort ( key = lambda x : x [ 1 ] ) NEW_LINE for i in number : NEW_LINE INDENT print ( i [ 0 ] ) NEW_LINE DEDENT","import sys NEW_LINE from collections import defaultdict NEW_LINE from operator import itemgetter NEW_LINE INF = float ( \" inf \" ) NEW_LINE def solve ( N : int , M : int , iPY ) : NEW_LINE INDENT d = defaultdict ( list ) NEW_LINE iPY . sort ( key = itemgetter ( 2 ) ) NEW_LINE for i , p , y in iPY : NEW_LINE INDENT d [ p ] . append ( [ i , p , y ] ) NEW_LINE DEDENT ans = [ ] NEW_LINE for k in d : NEW_LINE INDENT for j , ( i , p , y ) in enumerate ( d [ k ] ) : NEW_LINE INDENT ans . append ( [ i , \" { 0:06d } {1:06d } \" . format ( p , j + 1 ) ] ) NEW_LINE DEDENT DEDENT ans . sort ( ) NEW_LINE for a in ans : NEW_LINE INDENT print ( a [ 1 ] ) NEW_LINE DEDENT return NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT def iterate_tokens ( ) : NEW_LINE INDENT for line in sys . stdin : NEW_LINE INDENT for word in line . split ( ) : NEW_LINE INDENT yield word NEW_LINE DEDENT DEDENT DEDENT tokens = iterate_tokens ( ) NEW_LINE N = int ( next ( tokens ) ) NEW_LINE M = int ( next ( tokens ) ) NEW_LINE iPY = [ [ ] ] * ( M ) NEW_LINE for i in range ( M ) : NEW_LINE INDENT iPY [ i ] = [ i , int ( next ( tokens ) ) , int ( next ( tokens ) ) ] NEW_LINE DEDENT solve ( N , M , iPY ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT","N , M = map ( int , input ( ) . split ( ) ) NEW_LINE py_list = [ ] NEW_LINE d = dict ( ) NEW_LINE for i in range ( M ) : NEW_LINE INDENT p , y = map ( int , input ( ) . split ( ) ) NEW_LINE py_list . append ( [ p , y ] ) NEW_LINE DEDENT py_sorted = sorted ( py_list ) NEW_LINE p_temp = py_sorted [ 0 ] [ 0 ] NEW_LINE count = 1 NEW_LINE for p , y in py_sorted : NEW_LINE INDENT if p_temp != p : NEW_LINE INDENT p_temp = p NEW_LINE count = 1 NEW_LINE DEDENT d [ ( p , y ) ] = count NEW_LINE count += 1 NEW_LINE DEDENT for i in range ( M ) : NEW_LINE INDENT s = d [ ( py_list [ i ] [ 0 ] , py_list [ i ] [ - 1 ] ) ] NEW_LINE s = str ( s ) NEW_LINE ss = str ( py_list [ i ] [ 0 ] ) . zfill ( 6 ) + s . zfill ( 6 ) NEW_LINE print ( ss . strip ( ) ) NEW_LINE DEDENT"],"bleu":0.5793139442613457,"rouge_l":0.5404742598342661}
{"id":98,"predictions":["import bisect NEW_LINE N , K , Q = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ ] NEW_LINE b = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT l = [ ] NEW_LINE t = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT j = bisect . bisect_right ( t , l [ N - 1 ] ) NEW_LINE l . append ( t ) NEW_LINE if j <= N : NEW_LINE INDENT l [ j ] = t NEW_LINE DEDENT else : NEW_LINE INDENT l . append ( t ) NEW_LINE t = bisect_right ( t , t ) NEW_LINE ans = max ( l [ j ] , t ) NEW_LINE if l [ j ] <= t : NEW_LINE INDENT ans = l [ j ] NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT ans = min ( ans , t ) NEW_LINE DEDENT print ( ans ) NEW_LINE"],"references":["N , K , Q = map ( int , input ( ) . split ( ) ) NEW_LINE As = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 10 ** 9 NEW_LINE for Y in sorted ( As ) [ : N - Q - K + 2 ] : NEW_LINE INDENT cands = [ ] NEW_LINE cs = [ ] NEW_LINE for A in As + [ 0 ] : NEW_LINE INDENT if A < Y : NEW_LINE INDENT if len ( cs ) >= K : NEW_LINE INDENT cands += sorted ( cs ) [ : len ( cs ) - K + 1 ] NEW_LINE DEDENT cs = [ ] NEW_LINE DEDENT else : NEW_LINE INDENT cs += [ A ] NEW_LINE DEDENT DEDENT if len ( cands ) < Q : continue NEW_LINE X = sorted ( cands ) [ Q - 1 ] NEW_LINE ans = min ( ans , X - Y ) NEW_LINE DEDENT print ( ans ) NEW_LINE","def solve ( n , k , q , a ) : NEW_LINE INDENT sorted_pairs = [ ( ai , i ) for i , ai in enumerate ( a ) ] NEW_LINE sorted_pairs . sort ( ) NEW_LINE ans = 10 ** 10 NEW_LINE segments = [ ( 0 , n ) ] NEW_LINE ly = 0 NEW_LINE for i in range ( n - q + 1 ) : NEW_LINE INDENT y , _ = sorted_pairs [ i ] NEW_LINE if y == ly : NEW_LINE INDENT continue NEW_LINE DEDENT ly = y NEW_LINE b = [ ] NEW_LINE for left , right in segments : NEW_LINE INDENT if k <= right - left : NEW_LINE INDENT c = a [ left : right ] . copy ( ) NEW_LINE c . sort ( ) NEW_LINE b += c [ : right - left - k + 1 ] NEW_LINE DEDENT DEDENT if q <= len ( b ) : NEW_LINE INDENT b . sort ( ) NEW_LINE x = b [ q - 1 ] NEW_LINE ans = min ( ans , x - y ) NEW_LINE DEDENT i_end = n - q + 1 NEW_LINE for i2 in range ( i + 1 , n - q + 1 ) : NEW_LINE INDENT if sorted_pairs [ i2 ] [ 0 ] != y : NEW_LINE INDENT i_end = i2 NEW_LINE break NEW_LINE DEDENT DEDENT for i2 in range ( i , i_end ) : NEW_LINE INDENT _ , j = sorted_pairs [ i2 ] NEW_LINE for h , seg in enumerate ( segments ) : NEW_LINE INDENT left , right = seg NEW_LINE if left <= j and j < right : NEW_LINE INDENT segments . pop ( h ) NEW_LINE segments . append ( ( left , j ) ) NEW_LINE segments . append ( ( j + 1 , right ) ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n , k , q = input ( ) . split ( ) NEW_LINE n = int ( n ) NEW_LINE k = int ( k ) NEW_LINE q = int ( q ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( solve ( n , k , q , a ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT","import bisect NEW_LINE N , K , Q = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE A = [ ( int ( v ) , i ) for i , v in enumerate ( input ( ) . split ( ) ) ] NEW_LINE A . sort ( ) NEW_LINE B = [ 0 ] * ( N ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT B [ A [ i ] [ 1 ] ] = i NEW_LINE DEDENT C = [ A [ B [ i ] ] [ 0 ] for i in range ( N ) ] NEW_LINE Candi = set ( range ( N ) ) NEW_LINE ctr = 0 NEW_LINE ans = [ ] NEW_LINE rng = [ - 1 , N ] NEW_LINE while len ( Candi ) >= Q : NEW_LINE INDENT T = sorted ( Candi ) NEW_LINE ans . append ( ( list ( T ) [ 0 ] , list ( T ) [ Q - 1 ] ) ) NEW_LINE x = B . index ( ctr ) NEW_LINE st = bisect . bisect_left ( rng , x ) NEW_LINE Candi = Candi - set ( sorted ( B [ rng [ st - 1 ] + 1 : x ] + [ 2002 ] , reverse = 1 ) [ : K ] ) - set ( sorted ( B [ x : rng [ st ] ] + [ 2002 ] , reverse = 1 ) [ : K ] ) - set ( [ B [ x ] ] ) NEW_LINE bisect . insort_left ( rng , x ) NEW_LINE ctr += 1 NEW_LINE DEDENT print ( min ( [ A [ j ] [ 0 ] - A [ i ] [ 0 ] for i , j in ans ] ) ) NEW_LINE"],"bleu":0.5793614925040298,"rouge_l":0.5147207190681463}
{"id":99,"predictions":["a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( \" { } ▁ { } \" . format ( a , b ) ) NEW_LINE"],"references":["a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( b , a ) NEW_LINE","s = input ( ) . split ( ) NEW_LINE A = int ( s [ 0 ] ) NEW_LINE B = int ( s [ 1 ] ) NEW_LINE if 1 <= A and B <= 100 : NEW_LINE INDENT print ( B , A ) NEW_LINE DEDENT","print ( ' { 0[1 ] } ▁ { 0[0 ] } ' . format ( [ i for i in input ( ) . split ( ) ] ) ) NEW_LINE"],"bleu":0.6655817702055792,"rouge_l":0.7717078780908567}
{"id":100,"predictions":["n = int ( input ( ) ) NEW_LINE s = list ( input ( ) ) NEW_LINE ans = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if s [ i ] [ j ] == ' B ' : NEW_LINE INDENT ans = min ( ans , s [ i ] + s [ j ] ) NEW_LINE DEDENT elif s [ i ] == ' U ' : NEW_LINE INDENT ans = min ( ans , ans ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["from itertools import product NEW_LINE import re NEW_LINE def inpl ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE N = int ( input ( ) ) NEW_LINE C = input ( ) NEW_LINE ans = 2000 NEW_LINE for X in product ( \" ABXY \" , repeat = 4 ) : NEW_LINE INDENT L = \" \" . join ( X [ : 2 ] ) NEW_LINE R = \" \" . join ( X [ 2 : ] ) NEW_LINE ans = min ( ans , len ( C . replace ( L , \" L \" ) . replace ( R , \" R \" ) ) ) NEW_LINE DEDENT print ( ans ) NEW_LINE","BUTTONS = ' ABXY ' NEW_LINE def main ( ) : NEW_LINE INDENT _ = int ( input ( ) ) NEW_LINE c = input ( ) NEW_LINE print ( solve ( c ) ) NEW_LINE DEDENT def solve ( c ) : NEW_LINE INDENT m = float ( ' inf ' ) NEW_LINE for a in shortcuts ( ) : NEW_LINE INDENT for b in shortcuts ( ) : NEW_LINE INDENT if b <= a : NEW_LINE INDENT continue NEW_LINE DEDENT m = min ( m , min_step ( c , a , b ) ) NEW_LINE DEDENT DEDENT return m NEW_LINE DEDENT def min_step ( c , a , b ) : NEW_LINE INDENT dp = [ 0 , 1 ] NEW_LINE for i in range ( len ( c ) - 1 ) : NEW_LINE INDENT if c [ i : i + 2 ] in ( a , b ) : NEW_LINE INDENT dp . append ( min ( dp [ - 2 ] + 1 , dp [ - 1 ] + 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT dp . append ( dp [ - 1 ] + 1 ) NEW_LINE DEDENT DEDENT return dp [ - 1 ] NEW_LINE DEDENT def shortcuts ( ) : NEW_LINE INDENT for a in BUTTONS : NEW_LINE INDENT for b in BUTTONS : NEW_LINE INDENT yield a + b NEW_LINE DEDENT DEDENT DEDENT main ( ) NEW_LINE","import itertools NEW_LINE n = int ( input ( ) ) NEW_LINE s = ' S ' + input ( ) NEW_LINE rr = list ( itertools . product ( [ ' A ' , ' B ' , ' X ' , ' Y ' ] , repeat = 2 ) ) NEW_LINE ll = list ( itertools . product ( [ ' A ' , ' B ' , ' X ' , ' Y ' ] , repeat = 2 ) ) NEW_LINE def count ( l , r ) : NEW_LINE INDENT k = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( s [ i - 1 ] == l [ 0 ] and s [ i ] == l [ 1 ] ) or ( s [ i - 1 ] == r [ 0 ] and s [ i ] == r [ 1 ] ) : NEW_LINE INDENT k [ i ] = min ( k [ i - 1 ] + 1 , k [ i - 2 ] + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT k [ i ] = k [ i - 1 ] + 1 NEW_LINE DEDENT DEDENT return k [ n ] NEW_LINE DEDENT ans = 10 ** 10 NEW_LINE for ri in rr : NEW_LINE INDENT for li in ll : NEW_LINE INDENT ans = min ( ans , count ( li , ri ) ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"bleu":0.45878614122273303,"rouge_l":0.4589937271682021}
{"id":101,"predictions":["import math NEW_LINE n = int ( input ( ) ) NEW_LINE l = sorted ( list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( sum ( l [ : : - 1 ] ) ) NEW_LINE"],"references":["N = int ( input ( ) ) NEW_LINE A = sorted ( [ int ( i ) for i in input ( ) . split ( ) ] , reverse = True ) NEW_LINE print ( sum ( A [ : : 2 ] ) ) NEW_LINE","import math NEW_LINE N = int ( input ( ) ) NEW_LINE A = input ( ) . split ( \" ▁ \" ) NEW_LINE A = [ int ( i ) for i in A ] NEW_LINE A = sorted ( A , reverse = True ) NEW_LINE listA = [ ] NEW_LINE listB = [ ] NEW_LINE c = 0 NEW_LINE for i in range ( math . ceil ( N \/ 2 ) ) : NEW_LINE INDENT listA . append ( A [ i + c ] ) NEW_LINE if N % 2 != 0 and i + c + 1 > N - 1 : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT listB . append ( A [ i + c + 1 ] ) NEW_LINE DEDENT c += 1 NEW_LINE DEDENT print ( sum ( listA ) ) NEW_LINE","_ , a = open ( 0 ) ; print ( sum ( sorted ( map ( int , a . split ( ) ) ) [ : : - 2 ] ) ) NEW_LINE"],"bleu":0.6562840664505553,"rouge_l":0.6782487838776928}
{"id":102,"predictions":["def inpl ( ) : return [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE N = int ( input ( ) ) NEW_LINE s = [ input ( ) for _ in range ( N ) ] NEW_LINE f = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if s [ i ] == \" x \" : NEW_LINE INDENT f += 1 NEW_LINE DEDENT DEDENT print ( f ) NEW_LINE"],"references":["n = int ( input ( ) ) NEW_LINE l = [ input ( ) for i in range ( n ) ] NEW_LINE sum = 0 NEW_LINE for i in range ( len ( l ) ) : NEW_LINE INDENT for j in range ( 9 ) : NEW_LINE INDENT if l [ i ] [ j ] == ' x ' : NEW_LINE INDENT sum += 1 NEW_LINE DEDENT elif l [ i ] [ j ] == ' o ' and ( i + 1 == len ( l ) or l [ i + 1 ] [ j ] != ' o ' ) : NEW_LINE INDENT sum += 1 NEW_LINE DEDENT DEDENT DEDENT print ( sum ) NEW_LINE","def b_music ( N , Music ) : NEW_LINE INDENT import re NEW_LINE def rotate_counterclockwise ( matrix ) : NEW_LINE INDENT return [ ' ' . join ( s ) for s in list ( map ( list , zip ( * matrix ) ) ) [ : : - 1 ] ] NEW_LINE DEDENT music_rotate = rotate_counterclockwise ( Music ) NEW_LINE ans = 0 NEW_LINE for row in music_rotate : NEW_LINE INDENT ans += row . count ( ' x ' ) NEW_LINE row = re . split ( ' [ . x ] ' , row ) NEW_LINE for element in row : NEW_LINE INDENT if element : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT N = int ( input ( ) ) NEW_LINE Music = [ input ( ) for _ in range ( N ) ] NEW_LINE print ( b_music ( N , Music ) ) NEW_LINE","def inpl ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE N = int ( input ( ) ) NEW_LINE B = [ \" . \" for i in range ( 9 ) ] NEW_LINE for _ in range ( N ) : NEW_LINE INDENT L = input ( ) NEW_LINE for i in range ( 9 ) : NEW_LINE INDENT B [ i ] += L [ i ] NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 9 ) : NEW_LINE INDENT ans += B [ i ] . count ( \" x \" ) + B [ i ] . count ( \" . o \" ) + B [ i ] . count ( \" xo \" ) NEW_LINE DEDENT print ( ans ) NEW_LINE"],"bleu":0.42910525878679256,"rouge_l":0.5133830022075055}
{"id":103,"predictions":["class Node ( object ) : NEW_LINE INDENT def __init__ ( self , num ) : NEW_LINE INDENT self . parent = [ - 1 for i in range ( num + 1 ) ] NEW_LINE DEDENT def find ( self , x ) : NEW_LINE INDENT if self . parent [ x ] in self . parent [ x ] : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT self . parent [ x ] = self . find ( self . parent [ x ] ) NEW_LINE return NEW_LINE DEDENT DEDENT def unite ( self , x , y ) : NEW_LINE INDENT x , y = self . find ( x ) NEW_LINE y = self . find ( y ) NEW_LINE if x == y : NEW_LINE INDENT return NEW_LINE DEDENT if self . size ( x ) > self . size ( y ) : NEW_LINE INDENT self . parent [ x ] += self . parent [ y ] NEW_LINE self . parent [ y ] = x NEW_LINE DEDENT else : NEW_LINE INDENT self . parent [ y ] += self . parent [ x ] NEW_LINE self . parent [ x ] = y NEW_LINE DEDENT DEDENT def size ( self , x ) : NEW_LINE INDENT return - self . parent [ self . find ( x ) ] NEW_LINE DEDENT def same ( self , x , y ) : NEW_LINE INDENT return self . find ( x ) == self . find ( y ) NEW_LINE DEDENT DEDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE lis = [ ] NEW_LINE count = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT lis . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) ) NEW_LINE lis . append ( [ x , y ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) NEW_LINE X = [ [ ] for _ in range ( n ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE X [ a - 1 ] . append ( b - 1 ) NEW_LINE X [ b - 1 ] . append ( a - 1 ) NEW_LINE DEDENT path = [ i for i in range ( 2 , n + 1 ) ] NEW_LINE visited = [ 1 ] + [ 0 ] * ( n - 1 ) NEW_LINE def dfs ( v ) : NEW_LINE INDENT if visited == [ 1 ] * n : NEW_LINE INDENT return 1 NEW_LINE DEDENT res = 0 NEW_LINE for x in X [ v ] : NEW_LINE INDENT if visited [ x ] == 0 : NEW_LINE INDENT visited [ x ] = 1 NEW_LINE res += dfs ( x ) NEW_LINE visited [ x ] = 0 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT print ( dfs ( 0 ) ) NEW_LINE","from itertools import permutations NEW_LINE N , M = map ( int , input ( ) . split ( ) ) NEW_LINE E = [ ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT a , b = ( int ( _ ) for _ in input ( ) . split ( ) ) NEW_LINE E . append ( ( a , b ) ) NEW_LINE DEDENT V = ( i + 1 for i in range ( N ) ) NEW_LINE one_strike_cnt = 0 NEW_LINE for vertexs in permutations ( V ) : NEW_LINE INDENT if vertexs [ 0 ] != 1 : NEW_LINE INDENT continue NEW_LINE DEDENT one_strike = True NEW_LINE for vertex_index in range ( len ( vertexs ) - 1 ) : NEW_LINE INDENT flag = False NEW_LINE for i in range ( M ) : NEW_LINE INDENT a , b = E [ i ] NEW_LINE if ( a == vertexs [ vertex_index ] and b == vertexs [ vertex_index + 1 ] ) or ( a == vertexs [ vertex_index + 1 ] and b == vertexs [ vertex_index ] ) : NEW_LINE INDENT flag = True NEW_LINE break NEW_LINE DEDENT DEDENT if not flag : NEW_LINE INDENT one_strike = False NEW_LINE break NEW_LINE DEDENT DEDENT if one_strike : NEW_LINE INDENT one_strike_cnt += 1 NEW_LINE DEDENT DEDENT print ( one_strike_cnt ) NEW_LINE","def one_stroke_path ( N : int , M : int , edges : list ) -> int : NEW_LINE INDENT g = [ [ ] for _ in range ( N ) ] NEW_LINE for u , v in edges : NEW_LINE INDENT g [ u - 1 ] . append ( v - 1 ) NEW_LINE g [ v - 1 ] . append ( u - 1 ) NEW_LINE DEDENT visited = [ False ] * N NEW_LINE visited [ 0 ] = True NEW_LINE def dfs ( current : int , visited_num : int ) -> int : NEW_LINE INDENT if not visited [ current ] and visited_num + 1 == N : NEW_LINE INDENT return 1 NEW_LINE DEDENT visited [ current ] = True NEW_LINE total = sum ( dfs ( to , visited_num + 1 ) for to in g [ current ] if not visited [ to ] ) NEW_LINE visited [ current ] = False NEW_LINE return total NEW_LINE DEDENT return dfs ( 0 , 0 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT M = 0 NEW_LINE N , M = map ( int , input ( ) . split ( ) ) NEW_LINE edges = [ tuple ( int ( s ) for s in input ( ) . split ( ) ) for _ in range ( M ) ] NEW_LINE ans = one_stroke_path ( N , M , edges ) NEW_LINE print ( ans ) NEW_LINE DEDENT"],"bleu":0.2879994589241104,"rouge_l":0.37760642919200693}
{"id":104,"predictions":["import sys NEW_LINE import collections NEW_LINE ns = lambda : sys . stdin . readline ( ) . rstrip ( ) NEW_LINE ni = lambda : int ( ns ( ) ) NEW_LINE nm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE nl = lambda : list ( nm ( ) ) NEW_LINE nsl = lambda : map ( str , sys . stdin . readline ( ) . split ( ) ) NEW_LINE n , m = nm ( ) NEW_LINE if nl == 1 : NEW_LINE INDENT print ( nl . count ( m ) ) NEW_LINE exit ( 0 ) NEW_LINE DEDENT if n == 2 : NEW_LINE INDENT if m == 3 : NEW_LINE INDENT print ( n + 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT if m == 4 * m : NEW_LINE INDENT print ( 0 ) NEW_LINE exit ( 0 ) NEW_LINE DEDENT if not 4 * m : NEW_LINE INDENT print ( n * m ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT print ( - 1 ) NEW_LINE"],"references":["N , M = map ( int , input ( ) . split ( ) ) NEW_LINE S_num = N NEW_LINE cc_num = M \/\/ 2 NEW_LINE if ( S_num <= cc_num ) : NEW_LINE INDENT ans = ( S_num + cc_num ) \/\/ 2 NEW_LINE DEDENT else : NEW_LINE INDENT ans = cc_num NEW_LINE DEDENT print ( ans ) NEW_LINE","def getIntList ( ) : return [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE def db ( x ) : NEW_LINE INDENT global debug NEW_LINE if debug : NEW_LINE INDENT print ( x ) NEW_LINE DEDENT DEDENT def solve ( ) : NEW_LINE INDENT if N >= M \/\/ 2 : NEW_LINE INDENT return M \/\/ 2 NEW_LINE DEDENT return N + ( M - N * 2 ) \/\/ 4 NEW_LINE DEDENT debug = False NEW_LINE N , M = getIntList ( ) NEW_LINE db ( ( N , M ) ) NEW_LINE print ( solve ( ) ) NEW_LINE","def inpl ( ) : return [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE N , M = inpl ( ) NEW_LINE a = ( 2 * N + M ) \/\/ 4 NEW_LINE print ( min ( a , M \/\/ 2 ) ) NEW_LINE"],"bleu":0.15538038496091772,"rouge_l":0.40946744346849767}
{"id":105,"predictions":["s = input ( ) NEW_LINE k = int ( input ( ) ) NEW_LINE plist = [ ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == '1' : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT DEDENT if k <= 0 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT"],"references":["s = input ( ) NEW_LINE K = int ( input ( ) ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if i == K - 1 : NEW_LINE INDENT print ( s [ i ] ) NEW_LINE break NEW_LINE DEDENT if s [ i ] == '1' : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT print ( s [ i ] ) NEW_LINE break NEW_LINE DEDENT DEDENT","def solve ( s , k ) : NEW_LINE INDENT for i , d in enumerate ( map ( int , list ( s ) ) ) : NEW_LINE INDENT if i == k - 1 : NEW_LINE INDENT return s [ k - 1 ] NEW_LINE DEDENT if d > 1 : NEW_LINE INDENT return d NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT s = input ( ) NEW_LINE k = int ( input ( ) ) NEW_LINE print ( solve ( s , k ) ) NEW_LINE","import sys NEW_LINE import itertools NEW_LINE import collections NEW_LINE import functools NEW_LINE import math NEW_LINE from queue import Queue NEW_LINE INF = float ( \" inf \" ) NEW_LINE def solve ( S : int , K : int ) : NEW_LINE INDENT n = - 1 NEW_LINE nc = 1 NEW_LINE for i , c in enumerate ( str ( S ) ) : NEW_LINE INDENT if c != \"1\" : NEW_LINE INDENT n = i + 1 NEW_LINE nc = c NEW_LINE break NEW_LINE DEDENT DEDENT if n == - 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE return NEW_LINE DEDENT if K < n : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( nc ) NEW_LINE DEDENT return NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT def iterate_tokens ( ) : NEW_LINE INDENT for line in sys . stdin : NEW_LINE INDENT for word in line . split ( ) : NEW_LINE INDENT yield word NEW_LINE DEDENT DEDENT DEDENT tokens = iterate_tokens ( ) NEW_LINE S = int ( next ( tokens ) ) NEW_LINE K = int ( next ( tokens ) ) NEW_LINE solve ( S , K ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"bleu":0.7534135693788339,"rouge_l":0.6671041119860017}
{"id":106,"predictions":["import sys NEW_LINE ns = lambda : sys . stdin . readline ( ) . rstrip ( ) NEW_LINE ni = lambda : int ( ns ( ) ) NEW_LINE nm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE nl = lambda : list ( nm ( ) ) NEW_LINE n = ni ( ) NEW_LINE a = nl ( ) NEW_LINE a . sort ( ) NEW_LINE print ( a [ - 1 ] ) NEW_LINE"],"references":["n = int ( input ( ) ) NEW_LINE a = [ int ( input ( ) ) for i in range ( n ) ] NEW_LINE a = sorted ( set ( a ) , reverse = True ) NEW_LINE if len ( a ) > 1 : NEW_LINE INDENT print ( a [ 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a [ 0 ] ) NEW_LINE DEDENT","_ , * a = map ( int , open ( 0 ) ) ; print ( sorted ( set ( a ) ) [ - 2 ] ) NEW_LINE","n = input ( ) NEW_LINE list = [ ] NEW_LINE for i in range ( int ( n ) ) : NEW_LINE INDENT temp = input ( ) NEW_LINE list . append ( int ( temp ) ) NEW_LINE DEDENT list . sort ( ) NEW_LINE for i in reversed ( range ( len ( list ) ) ) : NEW_LINE INDENT if list [ i ] == list [ i - 1 ] : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT print ( list [ i - 1 ] ) NEW_LINE break NEW_LINE DEDENT DEDENT"],"bleu":0.2570622809715448,"rouge_l":0.506587574149235}
{"id":107,"predictions":["a = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE b = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE c = math . floor ( a \/ b ) * c NEW_LINE print ( c ) NEW_LINE"],"references":["A , B , C = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( A * B * C ) % 1000000007 ) NEW_LINE","def rectangular ( A : int , B : int , C : int ) -> int : NEW_LINE INDENT MOD = 10 ** 9 + 7 NEW_LINE return ( A * B * C ) % MOD NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A , B , C = map ( int , input ( ) . split ( ) ) NEW_LINE ans = rectangular ( A , B , C ) NEW_LINE print ( ans ) NEW_LINE DEDENT","A , B , C = map ( int , input ( ) . split ( ) ) NEW_LINE d = 10 ** 9 + 7 NEW_LINE A %= d NEW_LINE B %= d NEW_LINE C %= d NEW_LINE print ( A * B * C % d ) NEW_LINE"],"bleu":0.18088879994254162,"rouge_l":0.4590968586387434}
{"id":108,"predictions":["def inpl ( ) : return [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE N , K = inpl ( ) NEW_LINE a = inpl ( ) NEW_LINE if 2 == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 2 ** ( N - 1 ) ** ( N - 1 ) ) NEW_LINE DEDENT"],"references":["N , P = map ( int , input ( ) . split ( ) ) NEW_LINE lst_A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE lst_odd_even = [ x % 2 for x in lst_A ] NEW_LINE if 1 in lst_odd_even : NEW_LINE INDENT ans = 2 ** ( N - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT if P == 0 : NEW_LINE INDENT ans = 2 ** N NEW_LINE DEDENT else : NEW_LINE INDENT ans = 0 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE","import sys NEW_LINE INF = float ( ' inf ' ) NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def II ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def SI ( ) : return input ( ) NEW_LINE def main ( ) : NEW_LINE INDENT n , p = LI ( ) NEW_LINE A = LI ( ) NEW_LINE sum_a = sum ( A ) NEW_LINE dp = [ 0 ] * ( sum_a + 1 ) NEW_LINE dp [ 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( sum_a + 1 ) [ : : - 1 ] : NEW_LINE INDENT if j - A [ i ] < 0 : NEW_LINE INDENT break NEW_LINE DEDENT if dp [ j - A [ i ] ] : NEW_LINE INDENT dp [ j ] += dp [ j - A [ i ] ] NEW_LINE DEDENT DEDENT DEDENT return sum ( [ dp [ i ] if i % 2 == p else 0 for i in range ( sum_a + 1 ) ] ) NEW_LINE DEDENT print ( main ( ) ) NEW_LINE","from math import factorial as fact NEW_LINE N , P = map ( int , input ( ) . split ( ) ) NEW_LINE A = [ int ( _ ) for _ in input ( ) . split ( ) ] NEW_LINE oddcnt = 0 NEW_LINE evencnt = 0 NEW_LINE for i in A : NEW_LINE INDENT if i % 2 == 1 : NEW_LINE INDENT oddcnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT evencnt += 1 NEW_LINE DEDENT DEDENT even = 2 ** evencnt NEW_LINE odd = 0 NEW_LINE if P == 0 : NEW_LINE INDENT for i in range ( 0 , oddcnt + 1 , 2 ) : NEW_LINE INDENT odd += fact ( oddcnt ) \/\/ ( fact ( i ) * fact ( oddcnt - i ) ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( 1 , oddcnt + 1 , 2 ) : NEW_LINE INDENT odd += fact ( oddcnt ) \/\/ ( fact ( i ) * fact ( oddcnt - i ) ) NEW_LINE DEDENT DEDENT print ( even * odd ) NEW_LINE"],"bleu":0.39604061442974775,"rouge_l":0.43181344992712883}
{"id":109,"predictions":["import array NEW_LINE from bisect import * NEW_LINE from collections import * NEW_LINE import fractions NEW_LINE import heapq NEW_LINE from itertools import * NEW_LINE import math NEW_LINE import random NEW_LINE import re NEW_LINE import string NEW_LINE import sys NEW_LINE MOD = 1000000007 NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def MI ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE def II ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def IS ( ) : return input ( ) NEW_LINE def P ( x ) : return print ( x ) NEW_LINE def C ( x ) : return Counter ( x ) NEW_LINE def GCD_LIST ( numbers ) : NEW_LINE INDENT return reduce ( fractions . Fraction , numbers ) NEW_LINE DEDENT def LCM_LIST ( numbers ) : NEW_LINE INDENT return reduce ( LCM , numbers ) NEW_LINE DEDENT def LCM ( m , n ) : NEW_LINE INDENT return ( m * n \/\/ fractions . gcd ( m , n ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"references":["s = input ( ) . split ( ) NEW_LINE t = input ( ) NEW_LINE r = input ( ) . split ( ) NEW_LINE if s == r : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT elif len ( set ( s + [ t ] ) & set ( r ) ) == 6 : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT f = 8 - len ( set ( s ) & set ( r ) ) NEW_LINE if f < 6 : NEW_LINE INDENT print ( f ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT","E = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE B = int ( input ( ) ) NEW_LINE L = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE bonus = 0 NEW_LINE count = 0 NEW_LINE for i in range ( 6 ) : NEW_LINE INDENT if L [ i ] in E : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if L [ i ] == B : NEW_LINE INDENT bonus = 1 NEW_LINE DEDENT DEDENT if count == 6 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT elif count == 5 : NEW_LINE INDENT if bonus == 1 : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 3 ) NEW_LINE DEDENT DEDENT elif count == 4 : NEW_LINE INDENT print ( 4 ) NEW_LINE DEDENT elif count == 3 : NEW_LINE INDENT print ( 5 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT","e , b , l = eval ( ' set ( input ( ) ) , ' * 3 ) ; print ( 2 * ( l - e == b ) or ( ~ - len ( l - e ) % 5 + 3 ) % 6 ) NEW_LINE"],"bleu":0.14115015497392075,"rouge_l":0.3823189840013195}
{"id":110,"predictions":["from scipy . sparse import floyd_warshall NEW_LINE T = int ( input ( ) ) NEW_LINE for _ in range ( T ) : NEW_LINE INDENT s , l = [ ( int ( _ ) for _ in input ( ) . split ( ) ] NEW_LINE t = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE INF = float ( \" inf \" ) NEW_LINE for s in l : NEW_LINE INDENT x , y = - l [ x ] , float ( \" inf \" ) NEW_LINE dx = [ - 1 , 0 , 0 ] NEW_LINE dy = [ - 1 , 1 ] NEW_LINE dx = - 1 NEW_LINE dy = [ abs ( x - 1 ) , abs ( y - x ) , abs ( y - y ) ] + abs ( x - y ) NEW_LINE DEDENT for i in range ( T ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE if x > y : NEW_LINE INDENT dy [ x ] = y NEW_LINE DEDENT DEDENT l = [ ] NEW_LINE for i in range ( T ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE l . append ( x ) NEW_LINE d [ x ] . append ( y ) NEW_LINE DEDENT dist = 0 NEW_LINE st = [ ] NEW_LINE for i in range ( B ) : NEW_LINE INDENT x , y = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if dist [ x ] >= dist [ 2 ] - dist [ x ] + 1 : NEW_LINE INDENT dist += 1 NEW_LINE DEDENT DEDENT print ( dist ) NEW_LINE"],"references":["def LIS ( L ) : NEW_LINE INDENT from bisect import bisect NEW_LINE best = [ ] NEW_LINE for i in L : NEW_LINE INDENT pos = bisect ( best , i ) NEW_LINE if len ( best ) <= pos : NEW_LINE INDENT best . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT best [ pos ] = i NEW_LINE DEDENT DEDENT return len ( best ) NEW_LINE DEDENT import math NEW_LINE x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) NEW_LINE N = int ( input ( ) ) NEW_LINE W = abs ( x2 - x1 ) NEW_LINE H = abs ( y2 - y1 ) NEW_LINE xsgn = 2 * ( x2 > x1 ) - 1 NEW_LINE ysgn = 2 * ( y2 > y1 ) - 1 NEW_LINE XY = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE if ( x - x1 ) * ( x - x2 ) <= 0 and ( y - y1 ) * ( y - y2 ) <= 0 : NEW_LINE INDENT XY += [ [ xsgn * ( x - x1 ) , ysgn * ( y - y1 ) ] ] NEW_LINE DEDENT DEDENT N = len ( XY ) NEW_LINE short = 20 - 5 * math . pi NEW_LINE long = 10 * math . pi - 20 NEW_LINE straight = 100 * ( W + H ) NEW_LINE XY . sort ( ) NEW_LINE Y = [ y for x , y in XY ] NEW_LINE fountain = LIS ( Y ) NEW_LINE if fountain < min ( W , H ) + 1 : NEW_LINE INDENT print ( straight - short * fountain ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( straight - short * ( fountain - 1 ) + long ) NEW_LINE DEDENT","from decimal import Decimal as D NEW_LINE from bisect import bisect_left as bl NEW_LINE def LIS ( L ) : NEW_LINE INDENT best = [ ] NEW_LINE for i in L : NEW_LINE INDENT pos = bl ( best , i ) NEW_LINE if len ( best ) <= pos : NEW_LINE INDENT best . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT best [ pos ] = i NEW_LINE DEDENT DEDENT return len ( best ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT xflip = 1 NEW_LINE yflip = 1 NEW_LINE x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) NEW_LINE if x1 > x2 : NEW_LINE INDENT xflip = - 1 NEW_LINE x1 , x2 = x2 , x1 NEW_LINE DEDENT if y1 > y2 : NEW_LINE INDENT yflip = - 1 NEW_LINE y1 , y2 = y2 , y1 NEW_LINE DEDENT points = [ ] NEW_LINE n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE if x1 <= x <= x2 and y1 <= y <= y2 : NEW_LINE INDENT points . append ( ( x * xflip , y * yflip ) ) NEW_LINE DEDENT DEDENT points = [ y for x , y in sorted ( points ) ] NEW_LINE foun = LIS ( points ) NEW_LINE dist = D ( 100 ) * ( x2 - x1 + y2 - y1 ) NEW_LINE dx = D ( ' - 4.2920367320510338076867835' ) * foun NEW_LINE if foun == min ( x2 - x1 + 1 , y2 - y1 + 1 ) : NEW_LINE INDENT dx += D ( '15.7079632679489661923132165' ) NEW_LINE DEDENT print ( dist + dx ) NEW_LINE DEDENT","import operator NEW_LINE from bisect import bisect_left NEW_LINE from math import pi NEW_LINE import decimal NEW_LINE def lis ( A ) : NEW_LINE INDENT L = [ A [ 0 ] ] NEW_LINE for a in A [ 1 : ] : NEW_LINE INDENT if a > L [ - 1 ] : NEW_LINE INDENT L . append ( a ) NEW_LINE DEDENT else : NEW_LINE INDENT L [ bisect_left ( L , a ) ] = a NEW_LINE DEDENT DEDENT return len ( L ) NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) NEW_LINE if x1 > x2 : NEW_LINE INDENT x1 , y1 , x2 , y2 = x2 , y2 , x1 , y1 NEW_LINE DEDENT is_down = y1 > y2 NEW_LINE if is_down : NEW_LINE INDENT y1 , y2 = - y1 , - y2 NEW_LINE DEDENT base = decimal . Decimal ( 100 ) * ( x2 - x1 + y2 - y1 ) NEW_LINE n = int ( input ( ) ) NEW_LINE fountains = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE if is_down : NEW_LINE INDENT y = - y NEW_LINE DEDENT if x < x1 or x2 < x or y < y1 or y2 < y : NEW_LINE INDENT continue NEW_LINE DEDENT fountains . append ( ( x , y ) ) NEW_LINE DEDENT if not fountains : NEW_LINE INDENT return str ( base ) NEW_LINE DEDENT dpi = decimal . Decimal ( pi ) NEW_LINE fountains . sort ( ) NEW_LINE fountains_y = list ( map ( operator . itemgetter ( 1 ) , fountains ) ) NEW_LINE mc = lis ( fountains_y ) NEW_LINE if mc == min ( x2 - x1 , y2 - y1 ) + 1 : NEW_LINE INDENT dist = base + ( dpi * 5 - 20 ) * ( mc - 1 ) + dpi * 10 - 20 NEW_LINE DEDENT else : NEW_LINE INDENT dist = base + ( dpi * 5 - 20 ) * mc NEW_LINE DEDENT return str ( dist ) NEW_LINE DEDENT print ( solve ( ) ) NEW_LINE"],"bleu":0.3767886977029843,"rouge_l":0.4206438467321393}
{"id":111,"predictions":["def inpl ( ) : return [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE n , m = inpl ( ) NEW_LINE if n - m in n : NEW_LINE INDENT print ( \" - 1 ▁ - 1\" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" - 1 ▁ - 1\" ) NEW_LINE DEDENT"],"references":["def find ( n , y ) : NEW_LINE INDENT for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( n + 1 - i ) : NEW_LINE INDENT if 10000 * i + 5000 * j + 1000 * ( n - i - j ) == y : NEW_LINE INDENT return i , j , n - i - j NEW_LINE DEDENT DEDENT DEDENT return - 1 , - 1 , - 1 NEW_LINE DEDENT N , Y = map ( int , input ( ) . split ( ) ) NEW_LINE i , j , k = find ( N , Y ) NEW_LINE print ( \" { } ▁ { } ▁ { } \" . format ( i , j , k ) ) NEW_LINE","n , y = [ int ( i ) for i in input ( ) . split ( \" ▁ \" ) ] NEW_LINE a = 0 NEW_LINE f = False NEW_LINE while y - 1000 * n - 9000 * a >= 0 : NEW_LINE INDENT r = ( y - 1000 * n - 9000 * a ) NEW_LINE b = r \/\/ 4000 NEW_LINE if r % 4000 == 0 and n - a - b >= 0 : NEW_LINE INDENT print ( a , b , n - a - b ) NEW_LINE f = True NEW_LINE break NEW_LINE DEDENT a += 1 NEW_LINE DEDENT if not f : NEW_LINE INDENT print ( - 1 , - 1 , - 1 ) NEW_LINE DEDENT","N , Y = map ( int , input ( ) . split ( ) ) NEW_LINE flag = 0 NEW_LINE for x in range ( N + 1 ) : NEW_LINE INDENT for y in range ( N + 1 ) : NEW_LINE INDENT if x + y > N : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT z = N - ( x + y ) NEW_LINE if 10000 * x + 5000 * y + 1000 * z == Y : NEW_LINE INDENT flag = 1 NEW_LINE X , Y , Z = x , y , z NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if flag == 1 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if flag == 0 : NEW_LINE INDENT print ( - 1 , - 1 , - 1 , ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( X , Y , Z ) NEW_LINE DEDENT"],"bleu":0.20525385404373392,"rouge_l":0.4483860658357303}
{"id":112,"predictions":["a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE l = [ a , b , c ] NEW_LINE l . sort ( ) NEW_LINE print ( l [ 1 ] + l [ 2 ] * b [ 1 ] ) NEW_LINE"],"references":["A , B , C = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE print ( A * B * 2 + B * C * 2 + A * C * 2 ) NEW_LINE","def takahashi_rect ( A : int , B : int , C : int ) -> int : NEW_LINE INDENT return 2 * ( A * B + B * C + C * A ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A , B , C = map ( int , input ( ) . split ( ) ) NEW_LINE ans = takahashi_rect ( A , B , C ) NEW_LINE print ( ans ) NEW_LINE DEDENT","A = list ( map ( int , input ( ) . split ( ) ) ) ; s = 0 NEW_LINE for i in range ( len ( A ) ) : NEW_LINE INDENT s += A [ i - 1 ] * A [ i ] NEW_LINE DEDENT print ( s * 2 ) NEW_LINE"],"bleu":0.37768449913341945,"rouge_l":0.46964761622742074}
{"id":113,"predictions":["n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE t = input ( ) NEW_LINE print ( 2 * n + 1 ) NEW_LINE"],"references":["N = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE t = input ( ) NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT if s [ i : ] == t [ : N - i ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( len ( s + t [ N - i : ] ) ) NEW_LINE","I = input ; n = i = int ( I ( ) ) ; s , t = I ( ) , I ( ) ; j = 0 ; exec ( ' j = max ( i * ( s [ - i : ] = = t [ : i ] ) , j ) ; i - = 1 ; ' * n ) ; print ( 2 * n - j ) NEW_LINE","N = int ( input ( ) ) NEW_LINE s = str ( input ( ) ) NEW_LINE t = str ( input ( ) ) NEW_LINE m = 0 NEW_LINE for i in range ( N , 0 , - 1 ) : NEW_LINE INDENT unity = True NEW_LINE for j in range ( i ) : NEW_LINE INDENT if s [ - ( j + 1 ) ] == t [ i - j - 1 ] : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT unity = False NEW_LINE DEDENT DEDENT if unity : NEW_LINE INDENT m = i NEW_LINE break NEW_LINE DEDENT DEDENT print ( str ( 2 * N - m ) ) NEW_LINE"],"bleu":0.22477620552473832,"rouge_l":0.47051145128752814}
{"id":114,"predictions":["import sysimport mathdef input ( ) : return sys . stdin . readline ( ) . strip ( ) def iinput ( ) : return int ( input ( ) ) def rinput ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) def get_list ( ) : return list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) def get_list ( ) : return list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) def get_list ( ) : return list ( map ( float , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) NEW_LINE"],"references":["import math NEW_LINE A , B = map ( int , input ( ) . split ( ) ) NEW_LINE N = int ( input ( ) ) NEW_LINE C = [ 0 ] * N NEW_LINE D = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT C [ i ] , D [ i ] = map ( int , input ( ) . split ( ) ) NEW_LINE DEDENT res = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT curr = False NEW_LINE if A <= C [ i ] and B <= D [ i ] : NEW_LINE INDENT curr = True NEW_LINE DEDENT if B <= C [ i ] and A <= D [ i ] : NEW_LINE INDENT curr = True NEW_LINE DEDENT if curr == False : NEW_LINE INDENT for j in range ( 2 ) : NEW_LINE INDENT if j == 1 : NEW_LINE INDENT temp = A NEW_LINE A = B NEW_LINE B = temp NEW_LINE DEDENT lo = math . atan ( B \/ A ) NEW_LINE hi = math . pi \/ 2 NEW_LINE mid = 0 NEW_LINE cnt = 0 NEW_LINE while lo < hi and cnt < 50 : NEW_LINE INDENT mid = ( lo + hi ) \/ 2 NEW_LINE if A * math . sin ( mid ) + B * math . cos ( mid ) < max ( C [ i ] , D [ i ] ) : NEW_LINE INDENT lo = mid NEW_LINE DEDENT else : NEW_LINE INDENT hi = mid NEW_LINE DEDENT cnt += 1 NEW_LINE DEDENT if A * math . cos ( lo ) + B * math . sin ( lo ) <= min ( C [ i ] , D [ i ] ) : NEW_LINE INDENT curr |= True NEW_LINE DEDENT DEDENT DEDENT if curr == True : NEW_LINE INDENT res . append ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT res . append ( \" NO \" ) NEW_LINE DEDENT DEDENT print ( \" \\n \" . join ( map ( str , res ) ) ) NEW_LINE","from collections import defaultdict NEW_LINE import sys , heapq , bisect , math , itertools , string , queue , datetime NEW_LINE sys . setrecursionlimit ( 10 ** 8 ) NEW_LINE INF = float ( ' inf ' ) NEW_LINE mod = 10 ** 9 + 7 NEW_LINE eps = 10 ** - 7 NEW_LINE PI = math . pi NEW_LINE AtoZ = [ chr ( i ) for i in range ( 65 , 65 + 26 ) ] NEW_LINE atoz = [ chr ( i ) for i in range ( 97 , 97 + 26 ) ] NEW_LINE def inpl ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def inpl_s ( ) : return list ( input ( ) . split ( ) ) NEW_LINE A , B = inpl ( ) NEW_LINE A , B = min ( A , B ) , max ( A , B ) NEW_LINE N = int ( input ( ) ) NEW_LINE phi = math . atan ( A \/ B ) NEW_LINE r = math . sqrt ( A ** 2 + B ** 2 ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT C , D = inpl ( ) NEW_LINE C , D = min ( C , D ) , max ( C , D ) NEW_LINE if A <= C and B <= D : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT elif C < A and B < D : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT else : NEW_LINE INDENT OK = 0 NEW_LINE NG = PI - phi NEW_LINE for _ in range ( 100 ) : NEW_LINE INDENT mid = ( OK + NG ) \/ 2 NEW_LINE h = r * math . sin ( mid + phi ) NEW_LINE if h <= D : OK = mid NEW_LINE else : NG = mid NEW_LINE DEDENT w = r * math . cos ( OK - phi ) NEW_LINE if w <= C : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT DEDENT","import sys NEW_LINE from math import sin , cos , radians NEW_LINE H , W = sorted ( map ( int , input ( ) . split ( ) ) ) NEW_LINE input ( ) NEW_LINE for ( box_h , box_w ) in ( sorted ( map ( int , l . split ( ) ) ) for l in sys . stdin ) : NEW_LINE INDENT if H <= box_h and W <= box_w : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE continue NEW_LINE DEDENT ok , ng = 0.0 , radians ( 90 ) NEW_LINE while ng - ok > 1e-12 : NEW_LINE INDENT mid = ( ok + ng ) \/ 2 NEW_LINE if W * sin ( mid ) + H * cos ( mid ) <= box_h : NEW_LINE INDENT ok = mid NEW_LINE DEDENT else : NEW_LINE INDENT ng = mid NEW_LINE DEDENT DEDENT _w = W * cos ( ok ) + H * cos ( radians ( 90 ) - ok ) NEW_LINE _h = W * sin ( ok ) + H * cos ( ok ) NEW_LINE if _w <= box_w and _h <= box_h : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.1862505103937216,"rouge_l":0.3040344850811612}
{"id":115,"predictions":["from collections import Counter NEW_LINE N , M = map ( int , input ( ) . split ( ) ) NEW_LINE A = [ [ ] for _ in range ( M ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT A [ i ] = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE DEDENT A = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( M - 2 ) : NEW_LINE INDENT A [ i ] [ A [ i ] ] += 1 NEW_LINE DEDENT ans = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT ans . append ( A [ i ] ) NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT print ( i + 1 ) NEW_LINE DEDENT"],"references":["n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ 0 ] * n NEW_LINE for i in range ( m ) : NEW_LINE INDENT b , c = map ( int , input ( ) . split ( ) ) NEW_LINE a [ b - 1 ] += 1 NEW_LINE a [ c - 1 ] += 1 NEW_LINE DEDENT for i in a : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT","I = lambda : map ( int , input ( ) . split ( ) ) NEW_LINE N , M = I ( ) NEW_LINE r = range ( N ) NEW_LINE m = { i : 0 for i in r } NEW_LINE for _ in [ 0 ] * M : NEW_LINE INDENT a , b = I ( ) NEW_LINE m [ a - 1 ] += 1 NEW_LINE m [ b - 1 ] += 1 NEW_LINE DEDENT for i in r : print ( m [ i ] ) NEW_LINE","from collections import OrderedDict NEW_LINE N , M = map ( int , input ( ) . split ( ) ) NEW_LINE L = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] NEW_LINE X = OrderedDict ( [ ( i + 1 , [ ] ) for i in range ( N ) ] ) NEW_LINE for a , b in L : NEW_LINE INDENT X [ a ] . append ( b ) NEW_LINE X [ b ] . append ( a ) NEW_LINE DEDENT for _ , x in X . items ( ) : NEW_LINE INDENT print ( len ( x ) ) NEW_LINE DEDENT"],"bleu":0.5077513550713252,"rouge_l":0.6480743691899069}
{"id":116,"predictions":["import sys NEW_LINE INF = float ( ' inf ' ) NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def II ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def SI ( ) : return input ( ) . split ( ) NEW_LINE def main ( ) : NEW_LINE INDENT A , B , C = LI ( ) NEW_LINE A , B , C = LI ( ) NEW_LINE mod = 998244353 NEW_LINE for x , y in zip ( A , A , B , C ) : NEW_LINE INDENT print ( ' { } ▁ { } ' . format ( x [ 0 ] , x [ 1 ] ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"references":["A = int ( input ( ) ) NEW_LINE C = int ( input ( ) ) NEW_LINE B = int ( input ( ) ) NEW_LINE mod = 10 ** 9 + 7 NEW_LINE def power ( x , y ) : NEW_LINE INDENT if y == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif y == 1 : NEW_LINE INDENT return x % mod NEW_LINE DEDENT elif y % 2 == 0 : NEW_LINE INDENT return power ( x , y \/\/ 2 ) ** 2 % mod NEW_LINE DEDENT else : NEW_LINE INDENT return ( power ( x , y \/\/ 2 ) ** 2 ) * x % mod NEW_LINE DEDENT DEDENT inv = power ( A * B + A * C - B * C , mod - 2 ) NEW_LINE i = ( ( ( 2 * B * C - A * B - A * C ) % mod ) * inv ) % mod NEW_LINE j = A * B * inv - 1 NEW_LINE print ( ( i - j ) % mod , j % mod ) NEW_LINE","def mod_inv ( n : int , mod : int ) -> int : NEW_LINE INDENT b , u , v = mod , 1 , 0 NEW_LINE while b > 0 : NEW_LINE INDENT t = n \/\/ b NEW_LINE n -= t * b NEW_LINE u -= t * v NEW_LINE n , b = b , n NEW_LINE u , v = v , u NEW_LINE DEDENT return ( u + mod ) % mod NEW_LINE DEDENT def dp ( A : int , B : int , C : int ) -> tuple : NEW_LINE INDENT MOD = 10 ** 9 + 7 NEW_LINE r = ( ( B * C - A * C ) % MOD * mod_inv ( A * C - ( B * C - A * B ) , MOD ) ) % MOD NEW_LINE c = ( ( B * C - A * B ) % MOD * mod_inv ( A * C - ( B * C - A * B ) , MOD ) ) % MOD NEW_LINE return r , c NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A , B , C = [ int ( input ( ) ) for _ in range ( 3 ) ] NEW_LINE r , c = dp ( A , B , C ) NEW_LINE print ( r , c ) NEW_LINE DEDENT","mod = 10 ** 9 + 7 NEW_LINE A = int ( input ( ) ) NEW_LINE B = int ( input ( ) ) NEW_LINE C = int ( input ( ) ) NEW_LINE def INV ( i ) : NEW_LINE INDENT return pow ( i , mod - 2 , mod ) NEW_LINE DEDENT print ( ( ( C * B - C * A ) * INV ( A * B - C * B + C * A ) ) % mod , ( ( B * C - B * A ) * INV ( A * C - B * C + B * A ) ) % mod ) NEW_LINE"],"bleu":0.24644898598269546,"rouge_l":0.37169939065673663}
{"id":117,"predictions":["N = int ( input ( ) ) NEW_LINE T = [ int ( input ( ) ) for i in range ( N ) ] NEW_LINE def gcd ( T ) : NEW_LINE INDENT if T == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return T NEW_LINE DEDENT DEDENT for T in range ( N - 1 ) : NEW_LINE INDENT print ( gcd ( T , T ) ) NEW_LINE DEDENT"],"references":["from fractions import gcd NEW_LINE from functools import reduce NEW_LINE N = int ( input ( ) ) NEW_LINE T = map ( int , [ input ( ) for _ in range ( N ) ] ) NEW_LINE def lcm_base ( x , y ) : NEW_LINE INDENT return ( x * y ) \/\/ gcd ( x , y ) NEW_LINE DEDENT def lcm ( numbers ) : NEW_LINE INDENT return reduce ( lcm_base , numbers , 1 ) NEW_LINE DEDENT print ( lcm ( T ) ) NEW_LINE","def gcd ( a , b ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT def lcm ( a , b ) : NEW_LINE INDENT return a * b \/\/ gcd ( a , b ) NEW_LINE DEDENT import sys NEW_LINE input = sys . stdin . readline NEW_LINE N = int ( input ( ) ) NEW_LINE if N == 1 : NEW_LINE INDENT print ( input ( ) ) NEW_LINE DEDENT else : NEW_LINE INDENT T = [ int ( input ( ) ) for _ in range ( N ) ] NEW_LINE ans = lcm ( T [ 0 ] , T [ 1 ] ) NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT ans = lcm ( ans , T [ i ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT","import fractions NEW_LINE def lcm ( a , b ) : NEW_LINE INDENT return a * b \/\/ fractions . gcd ( a , b ) NEW_LINE DEDENT def list_lcm ( number_list ) : NEW_LINE INDENT lcm_number = 1 NEW_LINE for j in range ( len ( number_list ) ) : NEW_LINE INDENT lcm_number = lcm ( lcm_number , number_list [ j ] ) NEW_LINE DEDENT return lcm_number NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT number_count = int ( input ( ) ) NEW_LINE numbers = [ ] NEW_LINE for i in range ( number_count ) : NEW_LINE INDENT numbers . append ( int ( input ( ) ) ) NEW_LINE DEDENT print ( int ( list_lcm ( numbers ) ) ) NEW_LINE DEDENT"],"bleu":0.5785280377076474,"rouge_l":0.548603138155377}
{"id":118,"predictions":["N = int ( input ( ) ) NEW_LINE print ( ( N \/\/ 2 ) * N \/\/ 2 ) NEW_LINE"],"references":["k = int ( input ( ) ) NEW_LINE if k % 2 == 0 : NEW_LINE INDENT even = k \/\/ 2 NEW_LINE odd = k \/\/ 2 NEW_LINE DEDENT else : NEW_LINE INDENT even = k \/\/ 2 NEW_LINE odd = k \/\/ 2 + 1 NEW_LINE DEDENT print ( even * odd ) NEW_LINE","import numpy as np NEW_LINE import itertools NEW_LINE a = int ( input ( ) ) NEW_LINE odd_list = np . arange ( 1 , a + 1 , 2 ) NEW_LINE even_list = np . arange ( 2 , a + 1 , 2 ) NEW_LINE count = 0 NEW_LINE for odd , even in itertools . product ( odd_list , even_list ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT print ( count ) NEW_LINE","import sys NEW_LINE K = int ( input ( ) ) NEW_LINE kumi = list ( range ( 0 , K + 1 ) ) NEW_LINE l_even = [ i for i in kumi if i % 2 == 0 and i != 0 ] NEW_LINE l_kisu = [ i for i in kumi if i % 2 != 0 ] NEW_LINE answer = len ( l_even ) * len ( l_kisu ) NEW_LINE print ( answer ) NEW_LINE"],"bleu":0.11608845021379771,"rouge_l":0.3329002079002079}
{"id":119,"predictions":["def inpl ( ) : return [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE C = [ inpl ( ) for _ in range ( 3 ) ] NEW_LINE s = inpl ( ) : NEW_LINE INDENT for i in range ( 2 ) : NEW_LINE INDENT s [ i ] [ 0 ] = s [ i ] [ 0 ] - s [ i ] [ 1 ] NEW_LINE DEDENT for i in range ( s ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT s [ i ] [ j ] = s [ i ] [ 1 ] - s [ j ] [ 0 ] + s [ i ] [ 1 ] NEW_LINE DEDENT DEDENT DEDENT flag = True NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT for l in range ( 4 ) : NEW_LINE INDENT if s [ i ] [ j ] != s [ i ] [ 1 ] or s [ i ] [ j ] != s [ i ] [ 2 ] : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if flag : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["c = [ [ 0 , 0 , 0 ] , [ 0 , 0 , 0 ] , [ 0 , 0 , 0 ] ] NEW_LINE for i in range ( 0 , 3 ) : NEW_LINE INDENT c [ i ] = [ int ( j ) for j in input ( ) . split ( \" ▁ \" ) ] NEW_LINE DEDENT f = True NEW_LINE for i in range ( 0 , 2 ) : NEW_LINE INDENT f = f and c [ i ] [ 0 ] - c [ i ] [ 1 ] == c [ i + 1 ] [ 0 ] - c [ i + 1 ] [ 1 ] NEW_LINE f = f and c [ i ] [ 1 ] - c [ i ] [ 2 ] == c [ i + 1 ] [ 1 ] - c [ i + 1 ] [ 2 ] NEW_LINE DEDENT for i in range ( 0 , 2 ) : NEW_LINE INDENT f = f and c [ 0 ] [ i ] - c [ 1 ] [ i ] == c [ 0 ] [ i + 1 ] - c [ 1 ] [ i + 1 ] NEW_LINE f = f and c [ 1 ] [ i ] - c [ 2 ] [ i ] == c [ 1 ] [ i + 1 ] - c [ 2 ] [ i + 1 ] NEW_LINE DEDENT if f : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT","def main ( ) : NEW_LINE INDENT C1n = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE C2n = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE C3n = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE C = [ C1n , C2n , C3n ] NEW_LINE a_s = [ 0 ] NEW_LINE b_s = [ C [ 0 ] [ 0 ] , C [ 0 ] [ 1 ] , C [ 0 ] [ 2 ] ] NEW_LINE a_s . append ( C [ 1 ] [ 0 ] - b_s [ 0 ] ) NEW_LINE a_s . append ( C [ 2 ] [ 0 ] - b_s [ 0 ] ) NEW_LINE for i , a_i in enumerate ( a_s ) : NEW_LINE INDENT for j , b_j in enumerate ( b_s ) : NEW_LINE INDENT if not ( ( a_i + b_j ) == C [ i ] [ j ] ) : NEW_LINE INDENT print ( \" No \" ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( \" Yes \" ) NEW_LINE DEDENT main ( ) NEW_LINE","matrix = [ [ x for x in map ( int , input ( ) . split ( ) ) ] for _ in range ( 3 ) ] NEW_LINE matrix = sorted ( matrix ) NEW_LINE for i in range ( 1 , 3 ) : NEW_LINE INDENT diff = matrix [ i ] [ 0 ] - matrix [ 0 ] [ 0 ] NEW_LINE for j in range ( 3 ) : NEW_LINE INDENT if matrix [ i ] [ j ] != matrix [ 0 ] [ j ] + diff : NEW_LINE INDENT print ( ' No ' ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT DEDENT print ( ' Yes ' ) NEW_LINE"],"bleu":0.5258725423601875,"rouge_l":0.6283497770839033}
{"id":120,"predictions":["a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE l = [ a , b , c ] NEW_LINE l . sort ( ) NEW_LINE print ( l [ 1 ] ) NEW_LINE"],"references":["A = [ int ( input ( ) ) for i in range ( 3 ) ] NEW_LINE s = sorted ( A ) [ : : - 1 ] NEW_LINE for i in A : NEW_LINE INDENT print ( s . index ( i ) + 1 ) NEW_LINE DEDENT","def min_index ( array ) : NEW_LINE INDENT index = 0 NEW_LINE figure = 100 NEW_LINE for i in range ( len ( array ) ) : NEW_LINE INDENT if ( inputs [ i ] < 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( array [ i ] < figure ) : NEW_LINE INDENT figure = array [ i ] NEW_LINE index = i NEW_LINE DEDENT DEDENT return index NEW_LINE DEDENT def max_index ( array ) : NEW_LINE INDENT index = 0 NEW_LINE figure = 1 NEW_LINE for i in range ( len ( array ) ) : NEW_LINE INDENT if ( inputs [ i ] < 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( array [ i ] > figure ) : NEW_LINE INDENT figure = array [ i ] NEW_LINE index = i NEW_LINE DEDENT DEDENT return index NEW_LINE DEDENT inputs = [ ] NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT inputs . append ( int ( input ( ) ) ) NEW_LINE DEDENT inputs [ min_index ( inputs ) ] = - 3 NEW_LINE inputs [ max_index ( inputs ) ] = - 1 NEW_LINE for i in range ( len ( inputs ) ) : NEW_LINE INDENT if ( inputs [ i ] > 0 ) : NEW_LINE INDENT inputs [ i ] = - 2 NEW_LINE DEDENT DEDENT for i in range ( len ( inputs ) ) : NEW_LINE INDENT print ( inputs [ i ] * - 1 ) NEW_LINE DEDENT","A = int ( input ( ) ) NEW_LINE B = int ( input ( ) ) NEW_LINE C = int ( input ( ) ) NEW_LINE if A < B < C : NEW_LINE INDENT print ( 3 ) NEW_LINE print ( 2 ) NEW_LINE print ( 1 ) NEW_LINE DEDENT elif A < C < B : NEW_LINE INDENT print ( 3 ) NEW_LINE print ( 1 ) NEW_LINE print ( 2 ) NEW_LINE DEDENT elif B < A < C : NEW_LINE INDENT print ( 2 ) NEW_LINE print ( 3 ) NEW_LINE print ( 1 ) NEW_LINE DEDENT elif B < C < A : NEW_LINE INDENT print ( 1 ) NEW_LINE print ( 3 ) NEW_LINE print ( 2 ) NEW_LINE DEDENT elif C < B < A : NEW_LINE INDENT print ( 1 ) NEW_LINE print ( 2 ) NEW_LINE print ( 3 ) NEW_LINE DEDENT elif C < A < B : NEW_LINE INDENT print ( 2 ) NEW_LINE print ( 1 ) NEW_LINE print ( 3 ) NEW_LINE DEDENT"],"bleu":0.17887380066193953,"rouge_l":0.4043386562217536}
{"id":121,"predictions":["import sys NEW_LINE stdin = sys . stdin NEW_LINE sys . setrecursionlimit ( 10 ** 5 ) NEW_LINE def li ( ) : return map ( int , stdin . readline ( ) . split ( ) ) NEW_LINE def li_ ( ) : return map ( lambda x : int ( x ) - 1 , stdin . readline ( ) . split ( ) ) NEW_LINE def lf ( ) : return map ( float , stdin . readline ( ) . split ( ) ) NEW_LINE def ls ( ) : return stdin . readline ( ) . split ( ) NEW_LINE def ns ( ) : return stdin . readline ( ) . rstrip ( ) NEW_LINE def lc ( ) : return list ( ns ( ) ) NEW_LINE def ni ( ) : return int ( stdin . readline ( ) ) NEW_LINE def nf ( ) : return float ( stdin . readline ( ) ) NEW_LINE n = ni ( ) NEW_LINE graph = { } NEW_LINE for _ in range ( n ) : NEW_LINE INDENT a , b = li ( ) NEW_LINE graph [ a ] . append ( b ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT a , b = li ( ) NEW_LINE graph [ b ] . append ( a ) NEW_LINE DEDENT graph [ a ] . append ( ( a , b ) ) NEW_LINE ans = 0 NEW_LINE for v in graph [ a ] : NEW_LINE INDENT if v != 1 : NEW_LINE INDENT ans ^= 2 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE inf = 10 ** 20 NEW_LINE gosa = 1.0 \/ 10 ** 10 NEW_LINE mod = 10 ** 9 + 7 NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def F ( ) : return float ( sys . stdin . readline ( ) ) NEW_LINE def S ( ) : return input ( ) NEW_LINE def main ( ) : NEW_LINE INDENT n = I ( ) NEW_LINE e = collections . defaultdict ( set ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT a , b = LI ( ) NEW_LINE e [ a ] . add ( b ) NEW_LINE e [ b ] . add ( a ) NEW_LINE DEDENT def f ( i , c ) : NEW_LINE INDENT r = 0 NEW_LINE for j in e [ i ] : NEW_LINE INDENT if j == c : NEW_LINE INDENT continue NEW_LINE DEDENT t = f ( j , i ) NEW_LINE r ^= t NEW_LINE DEDENT return r + 1 NEW_LINE DEDENT if f ( 1 , - 1 ) == 1 : NEW_LINE INDENT return ' Bob ' NEW_LINE DEDENT return ' Alice ' NEW_LINE DEDENT print ( main ( ) ) NEW_LINE","import sys NEW_LINE from collections import defaultdict , Counter NEW_LINE from itertools import product , groupby , count , permutations , combinations NEW_LINE from math import pi , sqrt , ceil , floor NEW_LINE from collections import deque NEW_LINE from bisect import bisect , bisect_left , bisect_right NEW_LINE from string import ascii_lowercase NEW_LINE from functools import lru_cache , reduce NEW_LINE INF = float ( \" inf \" ) NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE dy = [ 0 , - 1 , 0 , 1 ] NEW_LINE dx = [ 1 , 0 , - 1 , 0 ] NEW_LINE def inside ( y : int , x : int , H : int , W : int ) -> bool : return 0 <= y < H and 0 <= x < W NEW_LINE def dfs ( n , p , grundy , graph ) : NEW_LINE INDENT g = 0 NEW_LINE for x in graph [ n ] : NEW_LINE INDENT if x != p : NEW_LINE INDENT g ^= dfs ( x , n , grundy , graph ) + 1 NEW_LINE DEDENT DEDENT grundy [ n ] = g NEW_LINE return g NEW_LINE DEDENT def solve ( N , graph ) : NEW_LINE INDENT grundy = [ None ] * ( N + 1 ) NEW_LINE dfs ( 1 , 0 , grundy , graph ) NEW_LINE return grundy [ 1 ] != 0 NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE graph = defaultdict ( list ) NEW_LINE for _ in range ( N - 1 ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE graph [ a ] . append ( b ) NEW_LINE graph [ b ] . append ( a ) NEW_LINE DEDENT print ( \" Alice \" if solve ( N , graph ) else \" Bob \" ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT","import sys NEW_LINE import random NEW_LINE sys . setrecursionlimit ( 10 ** 5 + 5 ) NEW_LINE random . seed = 1 NEW_LINE def read_int_list ( ) : NEW_LINE INDENT return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE DEDENT def read_int ( ) : NEW_LINE INDENT return int ( input ( ) ) NEW_LINE DEDENT def read_str_list ( ) : NEW_LINE INDENT return input ( ) . split ( ) NEW_LINE DEDENT def read_str ( ) : NEW_LINE INDENT return input ( ) NEW_LINE DEDENT a = None NEW_LINE def dfs ( root , parent ) : NEW_LINE INDENT res = 0 NEW_LINE for i in a [ root ] : NEW_LINE INDENT if i != parent : NEW_LINE INDENT res ^= 1 + dfs ( i , root ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT def read_tree ( check = False ) : NEW_LINE INDENT if check : NEW_LINE INDENT n , p = gen ( ) NEW_LINE DEDENT else : NEW_LINE INDENT n = read_int ( ) NEW_LINE p = [ read_int_list ( ) for i in range ( n - 1 ) ] NEW_LINE DEDENT global a NEW_LINE a = [ [ ] for _ in range ( n ) ] NEW_LINE for x , y in p : NEW_LINE INDENT x -= 1 NEW_LINE y -= 1 NEW_LINE a [ x ] . append ( y ) NEW_LINE a [ y ] . append ( x ) NEW_LINE DEDENT DEDENT def gen ( ) : NEW_LINE INDENT n = random . randint ( 5 , 30 ) NEW_LINE inside = [ 1 ] NEW_LINE outside = list ( range ( 2 , n + 1 ) ) NEW_LINE p = [ ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT x = random . choice ( inside ) NEW_LINE y = random . choice ( outside ) NEW_LINE p . append ( [ x , y ] ) NEW_LINE outside . remove ( y ) NEW_LINE inside . append ( y ) NEW_LINE DEDENT return n , p NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT read_tree ( check = False ) NEW_LINE return [ ' Bob ' , ' Alice ' ] [ dfs ( 0 , - 1 ) > 0 ] NEW_LINE DEDENT def check ( ) : NEW_LINE INDENT for i in range ( 1000 ) : NEW_LINE INDENT res = solve ( ) NEW_LINE print ( i , res ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT res = solve ( ) NEW_LINE print ( res ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"bleu":0.4373160975445702,"rouge_l":0.5568233683249658}
{"id":122,"predictions":["import sys NEW_LINE from collections import defaultdict NEW_LINE from heapq import heappush , heappop NEW_LINE import math NEW_LINE import bisect NEW_LINE import random NEW_LINE def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def S ( ) : return list ( sys . stdin . readline ( ) ) NEW_LINE def IR ( n ) : return [ I ( ) for i in range ( n ) ] NEW_LINE def LIR ( n ) : return [ LI ( ) for i in range ( n ) ] NEW_LINE def SR ( n ) : return [ S ( ) for i in range ( n ) ] NEW_LINE def SR ( n ) : return [ S ( ) for i in range ( n ) ] NEW_LINE d = [ S ( ) for i in range ( n ) ] NEW_LINE def LSR ( n ) : return [ LS ( ) for i in range ( n ) ] NEW_LINE mod = 1000000007 NEW_LINE INF = 1000000007 NEW_LINE N , G = LI ( ) NEW_LINE p = [ set ( ) for i in range ( N ) ] NEW_LINE d = [ 0 for i in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT x , y = LI ( ) NEW_LINE if i not in d [ x ] : NEW_LINE INDENT d [ x ] = L [ i ] NEW_LINE d [ y ] = [ x ] NEW_LINE L [ x ] . add ( x ) NEW_LINE DEDENT DEDENT print ( 0 ) NEW_LINE"],"references":["class Ford_Fulkerson : NEW_LINE INDENT def __init__ ( self , N ) : NEW_LINE INDENT self . used = [ False ] * ( N + 1 ) NEW_LINE self . G = [ [ 0 ] * ( N + 1 ) for i in range ( N + 1 ) ] NEW_LINE DEDENT def add_edge ( self , fr , to , cap ) : NEW_LINE INDENT self . G [ fr ] [ to ] = cap NEW_LINE DEDENT def dfs ( self , v , t , f ) : NEW_LINE INDENT if v == t : NEW_LINE INDENT return f NEW_LINE DEDENT self . used [ v ] = True NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT if v == i : NEW_LINE INDENT continue NEW_LINE DEDENT if ( not self . used [ i ] ) and self . G [ v ] [ i ] > 0 : NEW_LINE INDENT d = self . dfs ( i , t , min ( f , self . G [ v ] [ i ] ) ) NEW_LINE if d > 0 : NEW_LINE INDENT self . G [ v ] [ i ] -= d NEW_LINE self . G [ i ] [ v ] += d NEW_LINE return d NEW_LINE DEDENT DEDENT DEDENT return 0 NEW_LINE DEDENT DEDENT N , G , E = map ( int , input ( ) . split ( ) ) NEW_LINE p = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE F = Ford_Fulkerson ( N ) NEW_LINE for i in range ( G ) : NEW_LINE INDENT F . add_edge ( p [ i ] , N , 1 ) NEW_LINE DEDENT for i in range ( E ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE F . add_edge ( a , b , 1 ) NEW_LINE F . add_edge ( b , a , 1 ) NEW_LINE DEDENT num = 0 NEW_LINE while True : NEW_LINE INDENT F . used = [ False ] * ( N + 1 ) NEW_LINE f = F . dfs ( 0 , N , 10 ** 9 ) NEW_LINE if f == 0 : NEW_LINE INDENT break NEW_LINE DEDENT num += f NEW_LINE DEDENT print ( num ) NEW_LINE","import queue NEW_LINE G = [ [ 0 for _ in range ( 101 ) ] for __ in range ( 101 ) ] NEW_LINE n , g , e = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE for x in input ( ) . split ( ) : NEW_LINE INDENT pi = int ( x ) NEW_LINE G [ pi ] [ 100 ] = G [ 100 ] [ pi ] = 1 NEW_LINE DEDENT for _ in range ( e ) : NEW_LINE INDENT ai , bi = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE G [ ai ] [ bi ] = G [ bi ] [ ai ] = 1 NEW_LINE DEDENT def find_path ( ) : NEW_LINE INDENT q = queue . Queue ( ) NEW_LINE visited = { 0 : 0 } NEW_LINE q . put ( 0 ) NEW_LINE while not q . empty ( ) : NEW_LINE INDENT last = q . get ( ) NEW_LINE if last == 100 : NEW_LINE INDENT path = [ last ] NEW_LINE while last != 0 : NEW_LINE INDENT prev = visited [ last ] NEW_LINE path . insert ( 0 , prev ) NEW_LINE last = prev NEW_LINE DEDENT return path NEW_LINE DEDENT for to , gij in enumerate ( G [ last ] ) : NEW_LINE INDENT if gij > 0 and to not in visited : NEW_LINE INDENT visited [ to ] = last NEW_LINE q . put ( to ) NEW_LINE DEDENT DEDENT DEDENT return None NEW_LINE DEDENT while True : NEW_LINE INDENT path = find_path ( ) NEW_LINE if path is None : NEW_LINE INDENT break NEW_LINE DEDENT for i , j in zip ( path [ : - 1 ] , path [ 1 : ] ) : NEW_LINE INDENT G [ i ] [ j ] -= 1 NEW_LINE G [ j ] [ i ] += 1 NEW_LINE DEDENT DEDENT print ( sum ( Gi [ 0 ] == 2 for Gi in G ) ) NEW_LINE","import sys NEW_LINE input = sys . stdin . readline NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE class FordFulkerson : NEW_LINE INDENT def __init__ ( self , n ) : NEW_LINE INDENT self . visited = [ False ] * n NEW_LINE self . G = [ [ 0 ] * n for _ in range ( n ) ] NEW_LINE self . n = n NEW_LINE DEDENT def add_edge ( self , fr , to , cap ) : NEW_LINE INDENT self . G [ fr ] [ to ] = cap NEW_LINE self . G [ to ] [ fr ] = cap NEW_LINE DEDENT def dfs ( self , start , goal , f ) : NEW_LINE INDENT if start == goal : NEW_LINE INDENT return f NEW_LINE DEDENT self . visited [ start ] = True NEW_LINE for i in range ( self . n ) : NEW_LINE INDENT if i == start : NEW_LINE INDENT continue NEW_LINE DEDENT if ( not self . visited [ i ] ) and self . G [ start ] [ i ] > 0 : NEW_LINE INDENT d = self . dfs ( i , goal , min ( f , self . G [ start ] [ i ] ) ) NEW_LINE if d > 0 : NEW_LINE INDENT self . G [ start ] [ i ] -= d NEW_LINE self . G [ i ] [ start ] += d NEW_LINE return d NEW_LINE DEDENT DEDENT DEDENT return 0 NEW_LINE DEDENT def maxflow ( self ) : NEW_LINE INDENT flow = 0 NEW_LINE while True : NEW_LINE INDENT self . visited = [ False ] * self . n NEW_LINE f = self . dfs ( 0 , self . n - 1 , float ( ' inf ' ) ) NEW_LINE if f == 0 : NEW_LINE INDENT break NEW_LINE DEDENT flow += f NEW_LINE DEDENT return flow NEW_LINE DEDENT DEDENT n , g , e = map ( int , input ( ) . split ( ) ) NEW_LINE P = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE AB = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( e ) ] NEW_LINE FF = FordFulkerson ( n + 1 ) NEW_LINE for a , b in AB : NEW_LINE INDENT FF . add_edge ( a , b , 1 ) NEW_LINE DEDENT for p in P : NEW_LINE INDENT FF . add_edge ( p , n , 1 ) NEW_LINE DEDENT print ( FF . maxflow ( ) ) NEW_LINE"],"bleu":0.27302505220510975,"rouge_l":0.3313836995075939}
{"id":123,"predictions":["a , b , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a > b : NEW_LINE INDENT print ( \" B \" ) NEW_LINE DEDENT elif a < b : NEW_LINE INDENT print ( \" A \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" B \" ) NEW_LINE DEDENT"],"references":["X , A , B = map ( int , input ( ) . split ( ) ) NEW_LINE print ( [ \" A \" , \" B \" ] [ not ( abs ( X - A ) < abs ( X - B ) ) ] ) NEW_LINE","x , a , b = [ int ( item ) for item in input ( ) . split ( ) ] NEW_LINE if abs ( x - a ) > abs ( x - b ) : NEW_LINE INDENT print ( \" B \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" A \" ) NEW_LINE DEDENT","[ x , a , b ] = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if abs ( a - x ) < abs ( b - x ) : NEW_LINE INDENT print ( \" A \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" B \" ) NEW_LINE DEDENT"],"bleu":0.653514485311193,"rouge_l":0.7377049180327868}
{"id":124,"predictions":["from operator import itemgetter NEW_LINE from functools import reduce NEW_LINE import math NEW_LINE def main ( ) : NEW_LINE INDENT input = sys . stdin . readline NEW_LINE N , M = map ( int , input ( ) . split ( ) ) NEW_LINE r = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE r . append ( ( a , b ) ) NEW_LINE DEDENT c = [ sorted ( c . items ( ) , key = lambda x : x [ 0 ] , reverse = True ) NEW_LINE c . sort ( reverse = True ) NEW_LINE t = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE T [ i ] = - a NEW_LINE b = c [ 0 ] * N NEW_LINE for j in range ( N ) : NEW_LINE INDENT prev = c [ j ] [ 0 ] * N NEW_LINE c [ i ] = t [ i ] NEW_LINE DEDENT if all ( p [ i ] [ 0 ] <= b and p [ i ] [ 1 ] <= T [ i ] [ 1 ] ) : NEW_LINE INDENT c [ i ] = max ( c [ i ] [ 0 ] , p [ i ] [ 1 ] ) \/ a NEW_LINE DEDENT DEDENT print ( c [ 0 ] ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"references":["import math NEW_LINE N , Q = map ( int , input ( ) . split ( ) ) NEW_LINE X = [ 0 ] * N NEW_LINE R = [ 0 ] * N NEW_LINE H = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT X [ i ] , R [ i ] , H [ i ] = map ( int , input ( ) . split ( ) ) NEW_LINE DEDENT A = [ 0 ] * Q NEW_LINE B = [ 0 ] * Q NEW_LINE for i in range ( Q ) : NEW_LINE INDENT A [ i ] , B [ i ] = map ( int , input ( ) . split ( ) ) NEW_LINE DEDENT MAX_X = 3 * 10 ** 4 NEW_LINE V = [ 0 ] * MAX_X NEW_LINE for x in range ( MAX_X ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT if X [ i ] > x or X [ i ] + H [ i ] < x : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT Rleft = ( X [ i ] + H [ i ] - x ) * R [ i ] \/ H [ i ] NEW_LINE Rright = max ( 0 , ( X [ i ] + H [ i ] - ( x + 1 ) ) * R [ i ] \/ H [ i ] ) NEW_LINE Vleft = math . pi * Rleft ** 2 * ( X [ i ] + H [ i ] - x ) \/ 3 NEW_LINE Vright = math . pi * Rright ** 2 * ( X [ i ] + H [ i ] - ( x + 1 ) ) \/ 3 NEW_LINE V [ x ] += Vleft - Vright NEW_LINE DEDENT DEDENT DEDENT cum_sum = [ 0 ] * ( MAX_X + 1 ) NEW_LINE for x in range ( MAX_X ) : NEW_LINE INDENT cum_sum [ x + 1 ] = V [ x ] + cum_sum [ x ] NEW_LINE DEDENT for i in range ( Q ) : NEW_LINE INDENT res = cum_sum [ B [ i ] ] - cum_sum [ A [ i ] ] NEW_LINE print ( res ) NEW_LINE DEDENT","import numpy as P NEW_LINE def I ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE M , G , V = P . maximum , range , list ; N , Q = I ( ) ; X , R , H = P . array ( [ V ( I ( ) ) for _ in G ( N ) ] ) . T NEW_LINE for _ in G ( Q ) : K , L = M ( X + H - M ( X , V ( zip ( * [ I ( ) ] ) ) ) , 0 ) ; print ( P . sum ( P . pi * ( K ** 3 - L ** 3 ) * ( R \/ H ) ** 2 \/ 3 ) ) NEW_LINE","def b_cone ( N , Q , Cones , Queries ) : NEW_LINE INDENT import math NEW_LINE ans_tmp = [ ] NEW_LINE for a , b in Queries : NEW_LINE INDENT volume_sum = 0 NEW_LINE for x , r , h in Cones : NEW_LINE INDENT if x <= a <= x + h : NEW_LINE INDENT v1 = ( ( x + h - a ) ** 3 ) \/ ( h ** 2 ) * math . pi * ( r ** 2 ) \/ 3 NEW_LINE DEDENT elif a < x : NEW_LINE INDENT v1 = math . pi * ( r ** 2 ) * h \/ 3 NEW_LINE DEDENT else : NEW_LINE INDENT v1 = 0 NEW_LINE DEDENT if x <= b <= x + h : NEW_LINE INDENT v2 = ( ( x + h - b ) ** 3 ) \/ ( h ** 2 ) * math . pi * ( r ** 2 ) \/ 3 NEW_LINE DEDENT elif b < x : NEW_LINE INDENT v2 = math . pi * ( r ** 2 ) * h \/ 3 NEW_LINE DEDENT else : NEW_LINE INDENT v2 = 0 NEW_LINE DEDENT volume_sum += v1 - v2 NEW_LINE DEDENT ans_tmp . append ( str ( round ( volume_sum , 6 ) ) ) NEW_LINE DEDENT ans = ' \\n ' . join ( ans_tmp ) NEW_LINE return ans NEW_LINE DEDENT N , Q = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE Cones = [ [ int ( i ) for i in input ( ) . split ( ) ] for j in range ( N ) ] NEW_LINE Queries = [ [ int ( i ) for i in input ( ) . split ( ) ] for j in range ( Q ) ] NEW_LINE print ( b_cone ( N , Q , Cones , Queries ) ) NEW_LINE"],"bleu":0.4545678924299126,"rouge_l":0.4714381720430108}
{"id":125,"predictions":["def solve ( ) : NEW_LINE INDENT h , m = map ( int , input ( ) . split ( ) ) NEW_LINE if ( h , m ) : NEW_LINE INDENT print ( \" { } \" . format ( h , 60 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" { 0:02d } \" . format ( h , 60 ) ) NEW_LINE DEDENT return 0 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"references":["n = int ( input ( ) ) NEW_LINE h = n \/\/ ( 60 * 60 ) NEW_LINE m = ( n % ( 60 * 60 ) ) \/\/ 60 NEW_LINE s = ( n % ( 60 * 60 ) ) % 60 NEW_LINE print ( ' { :02 } : { : 02 } : { : 02 } ' . format ( h , m , s ) ) NEW_LINE","n = int ( input ( ) ) NEW_LINE x = n \/ 3600 NEW_LINE if x >= 1 : NEW_LINE INDENT a = int ( x ) NEW_LINE DEDENT else : NEW_LINE INDENT a = 0 NEW_LINE DEDENT if ( n % 3600 ) \/ 60 >= 1 : NEW_LINE INDENT b = int ( ( n % 3600 ) \/ 60 ) NEW_LINE DEDENT else : NEW_LINE INDENT b = 0 NEW_LINE DEDENT c = ( n % 3600 ) % 60 NEW_LINE if len ( str ( a ) ) == 1 : NEW_LINE INDENT a = \"0\" + str ( a ) NEW_LINE DEDENT if len ( str ( b ) ) == 1 : NEW_LINE INDENT b = \"0\" + str ( b ) NEW_LINE DEDENT if len ( str ( c ) ) == 1 : NEW_LINE INDENT c = \"0\" + str ( c ) NEW_LINE DEDENT print ( str ( a ) + \" : \" + str ( b ) + \" : \" + str ( c ) ) NEW_LINE","from datetime import datetime NEW_LINE from datetime import timedelta NEW_LINE n = int ( input ( ) ) NEW_LINE dt = datetime ( 1970 , 1 , 1 , 0 , 0 , 0 ) NEW_LINE td = timedelta ( seconds = n ) NEW_LINE dt += td NEW_LINE print ( dt . strftime ( \" % H : % M : % S \" ) ) NEW_LINE"],"bleu":0.30984362531358267,"rouge_l":0.4161214442013129}
{"id":126,"predictions":["import sys NEW_LINE INF = float ( ' inf ' ) NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def II ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def SI ( ) : return input ( ) NEW_LINE def main ( ) : NEW_LINE INDENT n , k = LI ( ) NEW_LINE A = LI ( ) NEW_LINE t = 1 NEW_LINE for i in range ( k ) : NEW_LINE INDENT A [ i ] = 0 NEW_LINE for i in range ( k + 1 ) : NEW_LINE INDENT if A [ i ] == 1 : NEW_LINE INDENT t = i NEW_LINE DEDENT A [ i ] = 1 NEW_LINE if t < A [ i + k ] : NEW_LINE INDENT A [ i + k ] = t NEW_LINE l = i + k NEW_LINE DEDENT else : NEW_LINE INDENT A [ l ] = t NEW_LINE DEDENT DEDENT ans = min ( ans , t ) NEW_LINE return ans NEW_LINE DEDENT print ( main ( ) ) NEW_LINE"],"references":["import math NEW_LINE N , K = map ( int , input ( ) . split ( ) ) NEW_LINE A_ = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = math . ceil ( ( N - 1 ) \/ ( K - 1 ) ) NEW_LINE print ( ans ) NEW_LINE","import sys NEW_LINE input = sys . stdin . readline NEW_LINE N , K = map ( int , input ( ) . split ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE min_index = A . index ( 1 ) NEW_LINE if ( min_index > N \/\/ 2 ) : NEW_LINE INDENT A . reverse ( ) NEW_LINE DEDENT count = 0 NEW_LINE while ( 1 ) : NEW_LINE INDENT min_index = A . index ( 1 ) NEW_LINE if ( min_index == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( ( min_index - ( K - 1 ) ) >= 0 ) : NEW_LINE INDENT del A [ min_index - ( K - 1 ) : min_index ] NEW_LINE DEDENT elif ( ( min_index - ( K - 1 ) ) < 0 ) : NEW_LINE INDENT x = min_index - 1 NEW_LINE del A [ 0 : x + 1 ] NEW_LINE y = K - min_index - 1 NEW_LINE del A [ 1 : y + 1 ] NEW_LINE DEDENT count += 1 NEW_LINE DEDENT if ( ( len ( A ) - 1 ) % ( K - 1 ) == 0 ) : NEW_LINE INDENT count += ( len ( A ) - 1 ) \/\/ ( K - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT count += ( len ( A ) - 1 ) \/\/ ( K - 1 ) + 1 NEW_LINE DEDENT print ( count ) NEW_LINE","n , k , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) NEW_LINE print ( ( ( n - 1 ) - 1 ) \/\/ ( k - 1 ) + 1 ) NEW_LINE"],"bleu":0.20188713230796365,"rouge_l":0.47183896231624683}
{"id":127,"predictions":["def inpl ( ) : return [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE N = int ( input ( ) ) NEW_LINE S = [ input ( ) for _ in range ( N ) ] NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if S [ i ] == \" o \" : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["import copy as co NEW_LINE class circle ( ) : NEW_LINE INDENT def __init__ ( self , numlist , amount_of_can ) : NEW_LINE INDENT self . numcircle = numlist NEW_LINE self . til = 0 NEW_LINE self . cansee = amount_of_can NEW_LINE self . times = 1 NEW_LINE DEDENT def right_rotation ( self , num , length ) : NEW_LINE INDENT a = self . numcircle [ : length - num ] NEW_LINE b = self . numcircle [ length - num : ] NEW_LINE return b + a NEW_LINE DEDENT DEDENT def sup_and ( str1 , str2 , length ) : NEW_LINE INDENT count = 0 NEW_LINE for x in range ( 0 , length ) : NEW_LINE INDENT str1 [ x ] = str1 [ x ] or str2 [ x ] NEW_LINE count += str1 [ x ] NEW_LINE DEDENT return count NEW_LINE DEDENT def search ( circlelist , length , TV ) : NEW_LINE INDENT list1 = [ ] NEW_LINE for x in range ( circlelist . til + 1 , length ) : NEW_LINE INDENT circlelist2 = co . deepcopy ( circlelist ) NEW_LINE circlelist2 . cansee = sup_and ( circlelist2 . numcircle , TV . right_rotation ( x , length ) , length ) NEW_LINE circlelist2 . til = x NEW_LINE circlelist2 . times += 1 NEW_LINE list1 . append ( circlelist2 ) NEW_LINE DEDENT return list1 NEW_LINE DEDENT inp1 = input ( ) NEW_LINE amount_of_can = 0 NEW_LINE numlist = [ ] NEW_LINE for x in inp1 : NEW_LINE INDENT if x == ' x ' : NEW_LINE INDENT numlist . append ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT numlist . append ( 1 ) NEW_LINE amount_of_can += 1 NEW_LINE DEDENT DEDENT length = len ( numlist ) NEW_LINE if amount_of_can == length : NEW_LINE INDENT print ( 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT else : NEW_LINE INDENT circlelist = circle ( numlist , amount_of_can ) NEW_LINE alllist1 = [ circlelist ] NEW_LINE TV = co . deepcopy ( circlelist ) NEW_LINE while True : NEW_LINE INDENT alllist2 = [ ] NEW_LINE while alllist1 : NEW_LINE INDENT alllist2 . extend ( search ( alllist1 . pop ( ) , length , TV ) ) NEW_LINE DEDENT alllist1 = alllist2 NEW_LINE for x in alllist1 : NEW_LINE INDENT if x . cansee == length : NEW_LINE INDENT print ( x . times ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT DEDENT DEDENT","C = input ( ) . replace ( ' o ' , '1' ) . replace ( ' x ' , '0' ) NEW_LINE P = int ( C , 2 ) NEW_LINE N = len ( C ) NEW_LINE ans = N NEW_LINE mask = 2 ** ( 2 * N - 1 ) - 2 ** ( N - 1 ) NEW_LINE for b in range ( 1 , 2 ** N ) : NEW_LINE INDENT ptn = cnt = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if b & ( 1 << i ) == 0 : continue NEW_LINE cnt += 1 NEW_LINE ptn |= ( P << i ) NEW_LINE ptn |= ( P << ( i + N ) ) NEW_LINE DEDENT if ptn & mask == mask : NEW_LINE INDENT ans = min ( ans , cnt ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE","from itertools import combinations NEW_LINE def solve ( ) : NEW_LINE INDENT s = input ( ) NEW_LINE patlen = len ( s ) NEW_LINE pat = [ ( i == ' o ' ) for i in s ] NEW_LINE pat = pat * 2 NEW_LINE for i in range ( patlen + 1 ) : NEW_LINE INDENT for j in combinations ( list ( range ( patlen ) ) , i ) : NEW_LINE INDENT zure = [ [ ] for _ in range ( i ) ] NEW_LINE for k in range ( i ) : NEW_LINE INDENT zure [ k ] = pat [ j [ k ] : j [ k ] + patlen ] NEW_LINE DEDENT newpat = [ False ] * patlen NEW_LINE for pl in range ( patlen ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT newpat [ pl ] |= zure [ j ] [ pl ] NEW_LINE DEDENT DEDENT if not False in newpat : return i NEW_LINE DEDENT DEDENT DEDENT print ( solve ( ) ) NEW_LINE"],"bleu":0.30326639393782434,"rouge_l":0.42853037286187184}
{"id":128,"predictions":["import sys NEW_LINE input = sys . stdin . readline NEW_LINE sys . setrecursionlimit ( 1000000 ) NEW_LINE N = int ( input ( ) ) NEW_LINE T = [ int ( input ( ) ) for _ in range ( N ) ] NEW_LINE d = { } NEW_LINE for _ in range ( N ) : NEW_LINE INDENT k , m = map ( int , input ( ) . split ( ) ) NEW_LINE if k not in d : NEW_LINE INDENT d [ k ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ k ] = 0 NEW_LINE DEDENT DEDENT L = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT L . append ( r ) NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE L . append ( t ) NEW_LINE DEDENT L . sort ( reverse = True ) NEW_LINE t = 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if t [ i ] * L [ i ] > r : NEW_LINE INDENT L [ i ] = t NEW_LINE DEDENT print ( 1 ) NEW_LINE DEDENT"],"references":["n = int ( input ( ) ) NEW_LINE t = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT t [ i ] = int ( input ( ) ) NEW_LINE DEDENT t . sort ( ) NEW_LINE m = 10 ** 9 + 7 NEW_LINE res = 0 NEW_LINE ass = 1 NEW_LINE p = [ 1 ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT p . append ( p [ - 1 ] * i % m ) NEW_LINE DEDENT c = 0 NEW_LINE k = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT c += t [ i ] NEW_LINE res += c NEW_LINE if i != n - 1 : NEW_LINE INDENT if t [ i ] != t [ i + 1 ] : NEW_LINE INDENT ass = ass * p [ k ] % m NEW_LINE k = 1 NEW_LINE DEDENT else : NEW_LINE INDENT k += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT ass = ass * p [ k ] % m NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE print ( ass ) NEW_LINE","a = sorted ( map ( int , open ( 0 ) . read ( ) . split ( ) [ 1 : ] ) ) ; c = t = 0 NEW_LINE for b in a : t += b ; c += t NEW_LINE print ( c ) ; c = 1 NEW_LINE for s in set ( a ) : c = c * __import__ ( ' math ' ) . factorial ( a . count ( s ) ) % ( 10 ** 9 + 7 ) NEW_LINE print ( c ) NEW_LINE","from itertools import accumulate NEW_LINE from collections import Counter NEW_LINE from math import factorial NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE N = int ( input ( ) ) NEW_LINE T = [ int ( input ( ) ) for _ in range ( N ) ] NEW_LINE T . sort ( ) NEW_LINE cs = list ( accumulate ( T ) ) NEW_LINE print ( list ( accumulate ( cs ) ) [ - 1 ] ) NEW_LINE way = 1 NEW_LINE cnt = Counter ( T ) NEW_LINE for v in cnt . values ( ) : NEW_LINE INDENT way *= factorial ( v ) NEW_LINE way %= MOD NEW_LINE DEDENT print ( way ) NEW_LINE"],"bleu":0.4787905073194425,"rouge_l":0.4924060026385225}
{"id":129,"predictions":["n , c , k = map ( int , input ( ) . split ( ) ) NEW_LINE t = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . append ( int ( input ( ) ) ) NEW_LINE DEDENT t . sort ( reverse = True ) NEW_LINE t . sort ( reverse = True ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if t [ i ] <= c : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += 1 NEW_LINE t [ i ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["from math import ceil NEW_LINE def main ( ) : NEW_LINE INDENT N , C , K = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE Ts = [ ] NEW_LINE for _ in range ( N ) : NEW_LINE INDENT Ts . append ( int ( input ( ) ) ) NEW_LINE DEDENT Ts . sort ( ) NEW_LINE bus_ct = 0 NEW_LINE in_bus = 1 NEW_LINE st = Ts . pop ( 0 ) + K NEW_LINE for Ti in Ts : NEW_LINE INDENT if Ti > st : NEW_LINE INDENT bus_ct += 1 NEW_LINE in_bus = 1 NEW_LINE st = Ti + K NEW_LINE DEDENT elif Ti <= st : NEW_LINE INDENT in_bus += 1 NEW_LINE DEDENT if in_bus > C : NEW_LINE INDENT bus_ct += 1 NEW_LINE in_bus = 1 NEW_LINE st = Ti + K NEW_LINE DEDENT DEDENT if in_bus : NEW_LINE INDENT bus_ct += 1 NEW_LINE DEDENT print ( bus_ct ) NEW_LINE DEDENT main ( ) NEW_LINE","from collections import defaultdict NEW_LINE N , C , K = map ( int , input ( ) . split ( ) ) NEW_LINE ps = defaultdict ( int ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT T = int ( input ( ) ) NEW_LINE ps [ T ] += 1 NEW_LINE DEDENT count = 0 NEW_LINE current_ps = 0 NEW_LINE time_limit = 10 ** 9 + K + 1 NEW_LINE for t in sorted ( ps . keys ( ) ) : NEW_LINE INDENT if t > time_limit and current_ps > 0 : NEW_LINE INDENT count += 1 NEW_LINE current_ps = 0 NEW_LINE DEDENT if current_ps == 0 : NEW_LINE INDENT time_limit = t + K NEW_LINE DEDENT current_ps += ps [ t ] NEW_LINE while current_ps >= C : NEW_LINE INDENT count += 1 NEW_LINE current_ps -= C NEW_LINE time_limit = t + K NEW_LINE DEDENT DEDENT if current_ps > 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT print ( count ) NEW_LINE","n , c , k = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE people = list ( reversed ( sorted ( [ int ( input ( ) ) for _ in range ( n ) ] ) ) ) NEW_LINE start = people [ 0 ] NEW_LINE cnt = 1 NEW_LINE ans = 1 NEW_LINE for i in people [ 1 : ] : NEW_LINE INDENT if start - i <= k and i >= start - k and cnt < c : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt = 1 NEW_LINE ans += 1 NEW_LINE start = i NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"bleu":0.5740637901182942,"rouge_l":0.5972742708824211}
{"id":130,"predictions":["import bisect NEW_LINE N , A , B = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE X = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE H = sorted ( [ int ( i ) for i in input ( ) . split ( ) ] ) NEW_LINE if K == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT c = bisect . bisect_left ( A , X [ i ] + X [ i - 1 ] ) \/ ( A - B [ i ] ) NEW_LINE if c < 0 : NEW_LINE INDENT ans = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT c = bisect . bisect_left ( B , X [ i ] + X [ i - 1 ] ) NEW_LINE ans = i + 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["import heapq NEW_LINE n , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE h = [ int ( input ( ) ) for i in range ( n ) ] NEW_LINE h . sort ( ) NEW_LINE p = a - b NEW_LINE def c ( w ) : NEW_LINE INDENT k = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT l [ i ] = l [ i ] - b * w NEW_LINE if l [ i ] > 0 : NEW_LINE INDENT k += l [ i ] \/\/ p NEW_LINE if l [ i ] % p != 0 : NEW_LINE INDENT k += 1 NEW_LINE DEDENT DEDENT DEDENT if w >= k : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT s = 0 NEW_LINE f = 10 ** 14 NEW_LINE while f - s >= 2 : NEW_LINE INDENT m = ( f + s ) \/\/ 2 NEW_LINE l = h [ : : ] NEW_LINE if c ( m ) : NEW_LINE INDENT f = m NEW_LINE DEDENT else : NEW_LINE INDENT s = m NEW_LINE DEDENT DEDENT l = h [ : : ] NEW_LINE if c ( s ) : NEW_LINE INDENT print ( s ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( f ) NEW_LINE DEDENT","import sys NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE input = sys . stdin . readline NEW_LINE def ceil ( x ) : NEW_LINE INDENT return int ( ( - x ) \/\/ 1 * ( - 1 ) ) NEW_LINE DEDENT N , A , B = map ( int , input ( ) . split ( ) ) NEW_LINE hp = [ int ( input ( ) ) for _ in range ( N ) ] NEW_LINE diff = A - B NEW_LINE def check ( x , HP ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if HP [ i ] - B * x <= 0 : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT cnt += ceil ( ( HP [ i ] - B * x ) \/ diff ) NEW_LINE DEDENT DEDENT return cnt <= x NEW_LINE DEDENT def solve2 ( ) : NEW_LINE INDENT HP = sorted ( hp , reverse = True ) NEW_LINE mi = HP [ 0 ] \/\/ A NEW_LINE ma = ceil ( HP [ 0 ] \/ B ) NEW_LINE while mi <= ma : NEW_LINE INDENT mid = ( mi + ma ) \/\/ 2 NEW_LINE if check ( mid , HP ) : NEW_LINE INDENT ma = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT mi = mid + 1 NEW_LINE DEDENT DEDENT print ( mi ) NEW_LINE DEDENT def check2 ( x , hp ) : NEW_LINE INDENT l = [ a - B * x for a in hp ] NEW_LINE ret = 0 NEW_LINE for a in l : NEW_LINE INDENT if a <= 0 : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT ret += ceil ( a \/ diff ) NEW_LINE DEDENT DEDENT return ret <= x NEW_LINE DEDENT def solve3 ( ) : NEW_LINE INDENT mi = max ( hp ) \/\/ A NEW_LINE ma = ceil ( max ( hp ) \/ B ) NEW_LINE while mi <= ma : NEW_LINE INDENT mid = ( mi + ma ) \/\/ 2 NEW_LINE if check2 ( mid , hp ) : NEW_LINE INDENT ma = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT mi = mid + 1 NEW_LINE DEDENT DEDENT print ( mi ) NEW_LINE DEDENT solve3 ( ) NEW_LINE","def inpl ( ) : return [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE N , A , B = inpl ( ) NEW_LINE C = A - B NEW_LINE h = [ int ( input ( ) ) for _ in range ( N ) ] NEW_LINE lo = - ( - sum ( h ) \/\/ ( ( N - 1 ) * B + A ) ) - 1 NEW_LINE hi = sum ( [ - ( - i \/\/ A ) for i in h ] ) NEW_LINE while hi - lo > 1 : NEW_LINE INDENT me = ( hi + lo ) \/\/ 2 NEW_LINE hprime = [ h [ i ] - me * B for i in range ( N ) if h [ i ] - me * B > 0 ] NEW_LINE hans = 0 NEW_LINE for j in hprime : NEW_LINE INDENT hans += - ( - j \/\/ C ) NEW_LINE DEDENT if hans <= me : NEW_LINE INDENT hi = me NEW_LINE DEDENT else : NEW_LINE INDENT lo = me NEW_LINE DEDENT DEDENT print ( hi ) NEW_LINE"],"bleu":0.4098187554113711,"rouge_l":0.456401654198225}
{"id":131,"predictions":["from itertools import product NEW_LINE N , K = map ( int , input ( ) . split ( ) ) NEW_LINE S = input ( ) NEW_LINE f = \" \" . join ( [ str ( i ) for i in range ( N ) ] ) NEW_LINE cnt = 0 NEW_LINE for s in S : NEW_LINE INDENT if s [ s ] == \" A \" : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT elif s [ s [ s ] == \" B \" : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT ans = \" \" . join ( [ cnt for c in ans ] ) NEW_LINE print ( ans ) NEW_LINE"],"references":["import sys NEW_LINE from itertools import accumulate NEW_LINE from collections import deque NEW_LINE def solve ( ) : NEW_LINE INDENT N , K = map ( int , input ( ) . split ( ) ) NEW_LINE S = input ( ) NEW_LINE q = deque ( [ 1 if c == ' A ' else 0 for c in S ] ) NEW_LINE cb = 0 NEW_LINE for i in range ( min ( K , 2 * N + K % 2 ) ) : NEW_LINE INDENT if q [ 0 ] == ( cb ^ 1 ) : NEW_LINE INDENT q [ 0 ] ^= 1 NEW_LINE DEDENT else : NEW_LINE INDENT q . popleft ( ) NEW_LINE q . append ( cb ) NEW_LINE cb ^= 1 NEW_LINE DEDENT DEDENT ans = [ ' A ' if ( c ^ cb ) else ' B ' for c in q ] NEW_LINE print ( ' ' . join ( ans ) ) NEW_LINE DEDENT def debug ( x , table ) : NEW_LINE INDENT for name , val in table . items ( ) : NEW_LINE INDENT if x is val : NEW_LINE INDENT print ( ' DEBUG : { } ▁ - > ▁ { } ' . format ( name , val ) , file = sys . stderr ) NEW_LINE return None NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT"],"bleu":0.16708920582574144,"rouge_l":0.3788819875776398}
{"id":132,"predictions":["a , b = input ( ) . split ( ) NEW_LINE if ( b == ' + ' ) : NEW_LINE INDENT print ( a + ' ) NEW_LINE DEDENT elif ( a > b ) : NEW_LINE INDENT print ( b - a ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a - b ) NEW_LINE DEDENT"],"references":["print ( eval ( input ( ) ) ) NEW_LINE","import sys , re NEW_LINE from collections import deque , defaultdict , Counter NEW_LINE from math import ceil , sqrt , hypot , factorial , pi , sin , cos , radians NEW_LINE from itertools import permutations , combinations , product NEW_LINE from operator import itemgetter , mul NEW_LINE from copy import deepcopy NEW_LINE from string import ascii_lowercase , ascii_uppercase , digits NEW_LINE def input ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def INT ( ) : return int ( input ( ) ) NEW_LINE def MAP ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE INF = float ( ' inf ' ) NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE s = input ( ) NEW_LINE print ( eval ( s ) ) NEW_LINE","import sys , os NEW_LINE f = lambda : list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if ' local ' in os . environ : NEW_LINE INDENT sys . stdin = open ( ' . \/ input . txt ' , ' r ' ) NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT a , op , b = input ( ) . split ( ) NEW_LINE a = int ( a ) NEW_LINE b = int ( b ) NEW_LINE if op == ' + ' : NEW_LINE INDENT print ( a + b ) NEW_LINE DEDENT elif op == ' - ' : NEW_LINE INDENT print ( a - b ) NEW_LINE DEDENT DEDENT solve ( ) NEW_LINE"],"bleu":0.6523203319195973,"rouge_l":0.7196629213483146}
{"id":133,"predictions":["S = input ( ) NEW_LINE left_sum = 0 NEW_LINE right_sum = 0 NEW_LINE for i in range ( len ( S ) ) : NEW_LINE INDENT if S [ i ] == ' U ' : NEW_LINE INDENT left_sum += 1 NEW_LINE DEDENT elif S [ i ] == ' D ' : NEW_LINE INDENT left_sum += 1 NEW_LINE DEDENT print ( right_sum ) NEW_LINE"],"references":["import sys NEW_LINE stdin = sys . stdin NEW_LINE def li ( ) : return map ( int , stdin . readline ( ) . split ( ) ) NEW_LINE def li_ ( ) : return map ( lambda x : int ( x ) - 1 , stdin . readline ( ) . split ( ) ) NEW_LINE def lf ( ) : return map ( float , stdin . readline ( ) . split ( ) ) NEW_LINE def ls ( ) : return stdin . readline ( ) . split ( ) NEW_LINE def ns ( ) : return stdin . readline ( ) . rstrip ( ) NEW_LINE def lc ( ) : return list ( ns ( ) ) NEW_LINE def ni ( ) : return int ( stdin . readline ( ) ) NEW_LINE def nf ( ) : return float ( stdin . readline ( ) ) NEW_LINE s = ns ( ) NEW_LINE n = len ( s ) NEW_LINE ans = 0 NEW_LINE for idx , si in enumerate ( s ) : NEW_LINE INDENT if si == ' U ' : NEW_LINE INDENT ans += ( n - idx - 1 ) + 2 * idx NEW_LINE DEDENT else : NEW_LINE INDENT ans += 2 * ( n - idx - 1 ) + idx NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE","s = input ( ) ; print ( sum ( [ ( i * 2 + ( len ( s ) - i - 1 ) if h != \" D \" else i + ( len ( s ) - i - 1 ) * 2 ) for i , h in enumerate ( list ( s ) ) ] ) ) NEW_LINE","s = input ( ) NEW_LINE m = len ( s ) NEW_LINE ans = 2 * ( m - 1 ) NEW_LINE for i in range ( 1 , m - 1 ) : NEW_LINE INDENT ans += i + ( m - i - 1 ) NEW_LINE if s [ i ] == ' D ' : NEW_LINE INDENT ans += m - i - 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += i NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"bleu":0.4865621636558734,"rouge_l":0.5439490445859873}
{"id":134,"predictions":["import sys NEW_LINE INF = float ( ' inf ' ) NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def II ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def SI ( ) : return input ( ) NEW_LINE def main ( ) : NEW_LINE INDENT n , x = LI ( ) NEW_LINE x , x = LI ( ) NEW_LINE min_a = [ INF ] , x NEW_LINE for i in range ( n ) : NEW_LINE INDENT c = LI ( ) NEW_LINE min_a = A [ : - 1 ] NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT min_a . append ( min_a [ i + 1 ] ) NEW_LINE DEDENT return min_a NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"references":["def gcd ( a , b ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( b , a % b ) NEW_LINE DEDENT DEDENT N , A = map ( int , input ( ) . split ( ) ) NEW_LINE X = sorted ( map ( int , input ( ) . split ( ) ) ) NEW_LINE Y = [ ] NEW_LINE for x in X : NEW_LINE INDENT Y . append ( abs ( A - x ) ) NEW_LINE DEDENT ans = max ( Y ) NEW_LINE for y in Y : NEW_LINE INDENT ans = gcd ( y , ans ) NEW_LINE DEDENT print ( ans ) NEW_LINE","import sys NEW_LINE import fractions NEW_LINE def solve ( N : int , X : int , x : \" List [ int ] \" ) : NEW_LINE INDENT x . sort ( ) NEW_LINE gMax = None NEW_LINE last = None NEW_LINE begin = 0 NEW_LINE if abs ( X - x [ 0 ] ) > 0 : NEW_LINE INDENT last = abs ( X - x [ 0 ] ) NEW_LINE gMax = last NEW_LINE DEDENT else : NEW_LINE INDENT begin = 1 NEW_LINE last = x [ 1 ] - x [ 0 ] NEW_LINE gMax = last NEW_LINE DEDENT for i in range ( begin , N - 1 ) : NEW_LINE INDENT next = x [ i + 1 ] - x [ i ] NEW_LINE gMax = fractions . gcd ( gMax , next ) NEW_LINE DEDENT print ( gMax ) NEW_LINE return NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT def iterate_tokens ( ) : NEW_LINE INDENT for line in sys . stdin : NEW_LINE INDENT for word in line . split ( ) : NEW_LINE INDENT yield word NEW_LINE DEDENT DEDENT DEDENT tokens = iterate_tokens ( ) NEW_LINE N = int ( next ( tokens ) ) NEW_LINE X = int ( next ( tokens ) ) NEW_LINE x = [ int ( next ( tokens ) ) for _ in range ( N ) ] NEW_LINE solve ( N , X , x ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT","import fractions NEW_LINE from functools import reduce NEW_LINE from sys import stdin NEW_LINE N , X = [ int ( _ ) for _ in stdin . readline ( ) . rstrip ( ) . split ( ) ] NEW_LINE xs = [ int ( _ ) for _ in stdin . readline ( ) . rstrip ( ) . split ( ) ] NEW_LINE xs . sort ( ) NEW_LINE diff = [ xs [ i ] - xs [ i - 1 ] if i > 0 else abs ( xs [ i ] - X ) for i in range ( N ) ] NEW_LINE gcd = reduce ( fractions . gcd , diff ) NEW_LINE print ( gcd ) NEW_LINE"],"bleu":0.3587660771550346,"rouge_l":0.4579662504265706}
{"id":135,"predictions":["N , K = map ( int , input ( ) . split ( ) ) NEW_LINE if K == 1 : NEW_LINE INDENT print ( N - K + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( N - K + 1 ) NEW_LINE DEDENT"],"references":["N , i = map ( int , input ( ) . split ( ) ) NEW_LINE print ( N - i + 1 ) NEW_LINE","import numpy as np NEW_LINE class Calculator : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . num = 0 NEW_LINE DEDENT def set_num ( self , N , i ) : NEW_LINE INDENT self . N = N NEW_LINE self . i = i NEW_LINE DEDENT def calc ( self ) : NEW_LINE INDENT self . num = self . N - self . i + 1 ; NEW_LINE DEDENT def get_num ( self ) : NEW_LINE INDENT return self . num NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT N , i , = map ( int , input ( ) . split ( ) ) NEW_LINE c = Calculator ( ) NEW_LINE c . set_num ( N , i ) NEW_LINE c . calc ( ) NEW_LINE ans = c . get_num ( ) NEW_LINE print ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT","a = list ( map ( int , input ( ) . split ( \" ▁ \" ) ) ) NEW_LINE print ( a [ 0 ] - a [ 1 ] + 1 ) NEW_LINE"],"bleu":0.5044499537067701,"rouge_l":0.7589017589017589}
{"id":136,"predictions":["import math NEW_LINE N , A , B = map ( int , input ( ) . split ( ) ) NEW_LINE p = math . sqrt ( N ) + 1 NEW_LINE if A * B == N : NEW_LINE INDENT for i in range ( B ) : NEW_LINE INDENT print ( ' ▁ ' . join ( [ str ( i ) for i in range ( B ) ] ) ) NEW_LINE print ( ' ▁ ' . join ( [ str ( N ) for i in p ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' ▁ ' . join ( [ str ( i ) for i in range ( 1 , B ) ] ) ) NEW_LINE DEDENT"],"references":["N , A , B = map ( int , input ( ) . split ( ) ) NEW_LINE ans = list ( range ( A ) ) NEW_LINE m = 0 NEW_LINE rest = N - A NEW_LINE B -= 1 NEW_LINE if rest < B : NEW_LINE INDENT print ( - 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT if rest \/ A > B : NEW_LINE INDENT print ( - 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT while rest > B : NEW_LINE INDENT s = min ( A , rest - B + 1 ) NEW_LINE ans += list ( range ( m - s , m ) ) NEW_LINE m -= s NEW_LINE rest -= s NEW_LINE B -= 1 NEW_LINE DEDENT ans += list ( range ( m - B , m ) ) [ : : - 1 ] NEW_LINE m -= B NEW_LINE print ( \" ▁ \" . join ( [ str ( x - m + 1 ) for x in ans ] ) ) NEW_LINE","def solve ( n , a , b ) : NEW_LINE INDENT if n < a + b - 1 : NEW_LINE INDENT return [ - 1 ] NEW_LINE DEDENT if n > a * b : NEW_LINE INDENT return [ - 1 ] NEW_LINE DEDENT if b == 1 : NEW_LINE INDENT return list ( range ( 1 , n + 1 ) ) NEW_LINE DEDENT if a == 1 : NEW_LINE INDENT return list ( range ( n , 0 , - 1 ) ) NEW_LINE DEDENT ans = list ( range ( b , 0 , - 1 ) ) NEW_LINE ans . extend ( range ( n - a + 2 , n + 1 ) ) NEW_LINE t = b NEW_LINE for t in range ( 2 * b - 1 , n - a + 1 , b - 1 ) : NEW_LINE INDENT ans . extend ( range ( t , t - b + 1 , - 1 ) ) NEW_LINE DEDENT ans . extend ( range ( n - a + 1 , t , - 1 ) ) NEW_LINE return ans NEW_LINE DEDENT n , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( * solve ( n , a , b ) ) NEW_LINE","import sys NEW_LINE def inpl ( ) : return [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE N , A , B = inpl ( ) NEW_LINE rev = ( A < B ) NEW_LINE B , A = sorted ( [ B , A ] ) NEW_LINE if B < - ( - N \/\/ A ) or A + B - 1 > N : NEW_LINE INDENT print ( - 1 ) NEW_LINE sys . exit ( ) NEW_LINE DEDENT st = list ( range ( 1 , N + 1 ) ) NEW_LINE if B == 1 : NEW_LINE INDENT ans = st NEW_LINE DEDENT elif 2 * A > N : NEW_LINE INDENT ans = st [ A : N - B + 1 ] + st [ N - 1 : N - B : - 1 ] + st [ 0 : A ] NEW_LINE DEDENT else : NEW_LINE INDENT n = N \/\/ A NEW_LINE x = B + ( - N \/\/ A ) + 1 NEW_LINE ans = st [ n * A : N ] + st [ ( n - 1 ) * A : n * A - x ] + st [ n * A - 1 : n * A - x - 1 : - 1 ] NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT ans += st [ ( n - i ) * A : ( n - i + 1 ) * A ] NEW_LINE DEDENT DEDENT if rev : NEW_LINE INDENT ans = [ N + 1 - i for i in ans ] NEW_LINE DEDENT print ( * ans ) NEW_LINE"],"bleu":0.35363364757918664,"rouge_l":0.41950609565489216}
{"id":137,"predictions":["s = input ( ) NEW_LINE dp = [ [ 0 ] * len ( s ) for s in s ] NEW_LINE i = 0 NEW_LINE while i < len ( s ) and i < len ( s ) : NEW_LINE INDENT if s [ i ] == s [ i + 1 ] : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + 1 NEW_LINE dp [ i ] = min ( dp [ i - 1 ] + 1 , dp [ i ] ) ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT print ( dp [ i ] ) NEW_LINE"],"references":["from string import ascii_lowercase NEW_LINE s = input ( ) NEW_LINE ans = 100 NEW_LINE for c in ascii_lowercase : NEW_LINE INDENT ans = min ( ans , max ( [ len ( x ) for x in s . split ( c ) ] ) ) NEW_LINE DEDENT print ( ans ) NEW_LINE","L = [ chr ( i ) for i in range ( 97 , 123 ) ] NEW_LINE s = list ( input ( ) ) NEW_LINE N = len ( s ) NEW_LINE ans = float ( \" inf \" ) NEW_LINE for i in L : NEW_LINE INDENT c = 0 NEW_LINE X = s NEW_LINE while True : NEW_LINE INDENT if X . count ( i ) == N - c : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT Y = [ ] NEW_LINE for j in range ( N - c - 1 ) : NEW_LINE INDENT if X [ j ] == i or X [ j + 1 ] == i : NEW_LINE INDENT Y . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT Y . append ( \" . \" ) NEW_LINE DEDENT DEDENT X = Y NEW_LINE DEDENT c += 1 NEW_LINE DEDENT if c < ans : NEW_LINE INDENT ans = c NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE","from collections import Counter NEW_LINE S = input ( ) NEW_LINE A = Counter ( list ( S ) ) . most_common ( ) NEW_LINE ans = float ( ' inf ' ) NEW_LINE for a in A : NEW_LINE INDENT posi = - 1 NEW_LINE interval = 0 NEW_LINE for i in range ( len ( S ) ) : NEW_LINE INDENT if S [ i ] == a [ 0 ] : NEW_LINE INDENT interval = max ( interval , i - posi - 1 ) NEW_LINE posi = i NEW_LINE DEDENT if i == len ( S ) - 1 : NEW_LINE INDENT interval = max ( interval , i - posi ) NEW_LINE posi = i NEW_LINE DEDENT DEDENT ans = min ( ans , interval ) NEW_LINE DEDENT print ( ans ) NEW_LINE"],"bleu":0.29677993844387984,"rouge_l":0.48161941649668827}
{"id":138,"predictions":["def solve ( l , r , n ) : NEW_LINE INDENT if l < r : NEW_LINE INDENT return - l NEW_LINE DEDENT else : NEW_LINE INDENT return r + l NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT l , r = map ( int , input ( ) . split ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( solve ( l , r , p , x ) ) NEW_LINE DEDENT"],"references":["l , h = map ( int , input ( ) . split ( ) ) NEW_LINE n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT a = int ( input ( ) ) NEW_LINE if a < l : NEW_LINE INDENT print ( l - a ) NEW_LINE DEDENT elif l <= a <= h : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT","import math NEW_LINE def getInt ( ) : return int ( input ( ) ) NEW_LINE def getIntList ( ) : return [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE def zeros ( n ) : return [ 0 ] * n NEW_LINE def zeros2 ( n , m ) : return [ zeros ( m ) for i in range ( n ) ] NEW_LINE class Debug ( ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . debug = True NEW_LINE DEDENT def off ( self ) : NEW_LINE INDENT self . debug = False NEW_LINE DEDENT def dmp ( self , x , cmt = ' ' ) : NEW_LINE INDENT if self . debug : NEW_LINE INDENT if cmt != ' ' : NEW_LINE INDENT w = cmt + ' : ▁ ' + str ( x ) NEW_LINE DEDENT else : NEW_LINE INDENT w = str ( x ) NEW_LINE DEDENT print ( w ) NEW_LINE DEDENT return x NEW_LINE DEDENT DEDENT def prob ( ) : NEW_LINE INDENT d = Debug ( ) NEW_LINE d . off ( ) NEW_LINE L , H = getIntList ( ) NEW_LINE d . dmp ( ( L , H ) , ' L , ▁ H ' ) NEW_LINE N = getInt ( ) NEW_LINE d . dmp ( ( N ) , ' N ' ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT a = getInt ( ) NEW_LINE if a > H : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT elif a >= L : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( L - a ) NEW_LINE DEDENT DEDENT return NEW_LINE DEDENT ans = prob ( ) NEW_LINE","def manage ( L : int , H : int , N : int , A : list ) -> list : NEW_LINE INDENT ret = [ ] NEW_LINE for a in A : NEW_LINE INDENT if a < L : NEW_LINE INDENT ret . append ( L - a ) NEW_LINE DEDENT elif H < a : NEW_LINE INDENT ret . append ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ret . append ( 0 ) NEW_LINE DEDENT DEDENT return ret NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT L , H = map ( int , input ( ) . split ( ) ) NEW_LINE N = int ( input ( ) ) NEW_LINE A = [ int ( input ( ) ) for _ in range ( N ) ] NEW_LINE ans = manage ( L , H , N , A ) NEW_LINE for a in ans : NEW_LINE INDENT print ( a ) NEW_LINE DEDENT DEDENT"],"bleu":0.44184716277745256,"rouge_l":0.4768961493582264}
{"id":139,"predictions":["from collections import defaultdict NEW_LINE from heapq import heappush , heappop NEW_LINE import sys NEW_LINE import math NEW_LINE import bisect NEW_LINE import random NEW_LINE def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def LS ( ) : return list ( map ( list , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def S ( ) : return list ( sys . stdin . readline ( ) ) NEW_LINE def IR ( n ) : return [ I ( ) for i in range ( n ) ] NEW_LINE def LIR ( n ) : return [ LI ( ) for i in range ( n ) ] NEW_LINE def SR ( n ) : return [ S ( ) for i in range ( n ) ] NEW_LINE def A ( n ) : return [ S ( ) for i in range ( n ) ] NEW_LINE def LIR ( n ) : return [ S ( ) for i in range ( n ) ] NEW_LINE def LSR ( n ) : return [ I ( ) for i in range ( n ) ] NEW_LINE def SR ( n ) : return [ LS ( ) for i in range ( n ) ] NEW_LINE def SR ( n ) : return [ LS ( ) for i in range ( n ) ] NEW_LINE mod = 1000000007 NEW_LINE N , M = LI ( ) NEW_LINE XY = [ ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT x , y = LI ( ) NEW_LINE T = [ int ( i ) for i in range ( M ) ] NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if C [ i ] [ x ] == - 1 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["from collections import Counter NEW_LINE N , M = map ( int , input ( ) . split ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE src = [ tuple ( map ( int , input ( ) . split ( ) ) ) for i in range ( M ) ] NEW_LINE ctr = Counter ( A ) NEW_LINE cover = [ 0 ] * ( 2 * N + 1 ) NEW_LINE for k , v in ctr . items ( ) : NEW_LINE INDENT for i in range ( k , k - v , - 1 ) : NEW_LINE INDENT cover [ i + N ] += 1 NEW_LINE DEDENT DEDENT ans = cover [ N + 1 : ] . count ( 0 ) NEW_LINE for x , y in src : NEW_LINE INDENT ctr [ A [ x - 1 ] ] -= 1 NEW_LINE ai = A [ x - 1 ] + N - ctr [ A [ x - 1 ] ] NEW_LINE cover [ ai ] -= 1 NEW_LINE if ai > N and cover [ ai ] == 0 : ans += 1 NEW_LINE A [ x - 1 ] = y NEW_LINE bi = y + N - ctr [ y ] NEW_LINE if bi > N and cover [ bi ] == 0 : ans -= 1 NEW_LINE cover [ bi ] += 1 NEW_LINE ctr [ y ] += 1 NEW_LINE print ( ans ) NEW_LINE DEDENT","from collections import Counter NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE an = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ac_ = Counter ( an ) NEW_LINE ac = { i : ac_ [ i ] if i in ac_ else 0 for i in range ( 1 , n + 1 ) } NEW_LINE ad = [ 0 ] * n NEW_LINE for a , c in ac . items ( ) : NEW_LINE INDENT for i in range ( max ( 0 , a - c ) , a ) : NEW_LINE INDENT ad [ i ] += 1 NEW_LINE DEDENT DEDENT ans = ad . count ( 0 ) NEW_LINE anss = [ ] NEW_LINE for x , y in ( map ( int , input ( ) . split ( ) ) for _ in range ( m ) ) : NEW_LINE INDENT ax = an [ x - 1 ] NEW_LINE xdi = ax - ac [ ax ] NEW_LINE if xdi >= 0 : NEW_LINE INDENT ad [ xdi ] -= 1 NEW_LINE if ad [ xdi ] == 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT ac [ ax ] -= 1 NEW_LINE ac [ y ] += 1 NEW_LINE ydi = y - ac [ y ] NEW_LINE if ydi >= 0 : NEW_LINE INDENT ad [ ydi ] += 1 NEW_LINE if ad [ ydi ] == 1 : NEW_LINE INDENT ans -= 1 NEW_LINE DEDENT DEDENT an [ x - 1 ] = y NEW_LINE anss . append ( ans ) NEW_LINE DEDENT print ( ' \\n ' . join ( map ( str , anss ) ) ) NEW_LINE"],"bleu":0.23355536453218573,"rouge_l":0.3748550954226927}
{"id":140,"predictions":["N , K = ( int ( i ) for i in input ( ) . split ( ) ) NEW_LINE ans = [ ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT ans . append ( ans [ i ] ) NEW_LINE DEDENT N , K = ( int ( i ) for i in input ( ) . split ( ) ) NEW_LINE ans . append ( ans [ : ] ) NEW_LINE for a in ans : NEW_LINE INDENT print ( a [ 0 ] ) NEW_LINE DEDENT"],"references":["import heapq NEW_LINE N , K = map ( int , input ( ) . split ( ) ) NEW_LINE src = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE hq = [ ] NEW_LINE heapq . heapify ( hq ) NEW_LINE for i , a in enumerate ( src [ : K ] ) : NEW_LINE INDENT heapq . heappush ( hq , ( - a , i + 1 ) ) NEW_LINE DEDENT for i , a in enumerate ( src [ K : ] ) : NEW_LINE INDENT b , j = hq [ 0 ] NEW_LINE print ( j ) NEW_LINE if a < - b : NEW_LINE INDENT heapq . heappop ( hq ) NEW_LINE heapq . heappush ( hq , ( - a , K + i + 1 ) ) NEW_LINE DEDENT DEDENT b , j = hq [ 0 ] NEW_LINE print ( j ) NEW_LINE","from heapq import heappushpop NEW_LINE n , k = ( int ( i ) for i in input ( ) . split ( ) ) NEW_LINE x = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE a = [ ] NEW_LINE for i in range ( k ) : a . append ( [ - x [ i ] , i + 1 ] ) NEW_LINE a . sort ( ) NEW_LINE print ( a [ 0 ] [ 1 ] ) NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT heappushpop ( a , [ - x [ i ] , i + 1 ] ) NEW_LINE print ( a [ 0 ] [ 1 ] ) NEW_LINE DEDENT","def main ( ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE ages = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE indices = [ - 1 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a0 = ages [ i ] - 1 NEW_LINE indices [ a0 ] = i NEW_LINE DEDENT activated = [ False for i in range ( n ) ] NEW_LINE cursor = n NEW_LINE for i in range ( n ) : NEW_LINE INDENT a0 = ages [ i ] - 1 NEW_LINE activated [ a0 ] = True NEW_LINE if i >= k - 1 : NEW_LINE INDENT if cursor > a0 : NEW_LINE INDENT while True : NEW_LINE INDENT cursor -= 1 NEW_LINE if activated [ cursor ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT print ( indices [ cursor ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT main ( ) NEW_LINE"],"bleu":0.4398846678754885,"rouge_l":0.5261547022815805}
{"id":141,"predictions":["N = int ( input ( ) ) NEW_LINE l = [ ] NEW_LINE for n in [ int ( i ) for i in input ( ) . split ( ) ] : NEW_LINE INDENT l . append ( n ) NEW_LINE DEDENT l . sort ( ) NEW_LINE print ( sum ( l [ : : - 1 ] ) - l [ : : - 1 ] ) NEW_LINE"],"references":["n = int ( input ( ) ) NEW_LINE list = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE list . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans += ( - 1 ) ** ( i - 1 ) * list [ - i ] NEW_LINE DEDENT print ( ans ) NEW_LINE","import sys NEW_LINE l1 , l2 = [ sys . stdin . readline ( ) . strip ( ) for i in range ( 2 ) ] NEW_LINE input_list = [ int ( i ) for i in l2 . split ( ) ] NEW_LINE input_list . sort ( reverse = True ) NEW_LINE odd_index = [ j for i , j in enumerate ( input_list ) if i % 2 != 0 ] NEW_LINE even_index = [ j for i , j in enumerate ( input_list ) if i % 2 == 0 ] NEW_LINE print ( sum ( even_index ) - sum ( odd_index ) ) NEW_LINE","input ( ) NEW_LINE numbers = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE alice = bob = 0 NEW_LINE while ( len ( numbers ) ) : NEW_LINE INDENT if len ( numbers ) == 1 : NEW_LINE INDENT alice += numbers . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT alice += numbers . pop ( ) NEW_LINE bob += numbers . pop ( ) NEW_LINE DEDENT DEDENT print ( alice - bob ) NEW_LINE"],"bleu":0.4537096576521195,"rouge_l":0.47592510031208207}
{"id":142,"predictions":["s = list ( input ( ) ) NEW_LINE a = s [ 0 ] NEW_LINE b = s [ 1 ] * 7 NEW_LINE if int ( s [ 0 ] ) == 7 : NEW_LINE INDENT print ( \" First \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Second \" ) NEW_LINE DEDENT"],"references":["day = input ( ) NEW_LINE if day == \" Monday \" : NEW_LINE INDENT print ( 5 ) NEW_LINE DEDENT elif day == \" Tuesday \" : NEW_LINE INDENT print ( 4 ) NEW_LINE DEDENT elif day == \" Wednesday \" : NEW_LINE INDENT print ( 3 ) NEW_LINE DEDENT elif day == \" Thursday \" : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT elif day == \" Friday \" : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT","print ( int ( \" SaFrThWeTuMo \" . find ( input ( ) [ : 2 ] ) \/ 2 ) ) NEW_LINE","def ans ( ) : NEW_LINE INDENT day = input ( ) NEW_LINE if ( day == \" Sunday \" or day == \" Saturday \" ) : NEW_LINE INDENT res = 0 NEW_LINE DEDENT elif ( day == \" Monday \" ) : NEW_LINE INDENT res = 5 NEW_LINE DEDENT elif ( day == \" Tuesday \" ) : NEW_LINE INDENT res = 4 NEW_LINE DEDENT elif ( day == \" Wednesday \" ) : NEW_LINE INDENT res = 3 NEW_LINE DEDENT elif ( day == \" Thursday \" ) : NEW_LINE INDENT res = 2 NEW_LINE DEDENT elif ( day == \" Friday \" ) : NEW_LINE INDENT res = 1 NEW_LINE DEDENT print ( res ) NEW_LINE DEDENT ans ( ) NEW_LINE"],"bleu":0.3499393271046884,"rouge_l":0.4707727544313882}
{"id":143,"predictions":["from __future__ import division NEW_LINE import collections NEW_LINE import itertools NEW_LINE import sys NEW_LINE class gcj : NEW_LINE INDENT IN = sys . stdin NEW_LINE number = 0 NEW_LINE @ classmethod NEW_LINE def case ( cls ) : NEW_LINE INDENT cls . number += 1 NEW_LINE return ' Case ▁ # % s : ' % cls . number NEW_LINE DEDENT @ classmethod NEW_LINE def line ( cls , type = str ) : NEW_LINE INDENT line = cls . IN . readline ( ) NEW_LINE return type ( line . strip ( ' \\n ' ) ) NEW_LINE DEDENT @ classmethod NEW_LINE def splitline ( cls , type = str ) : NEW_LINE INDENT line = cls . IN . readline ( ) NEW_LINE return [ type ( x ) for x in line . split ( ) ] NEW_LINE DEDENT DEDENT def go ( ) : NEW_LINE INDENT t = gcj . line ( int ) NEW_LINE for _ in xrange ( t ) : NEW_LINE INDENT n = gcj . line ( int ) NEW_LINE data = [ ] NEW_LINE for _ in xrange ( n ) : NEW_LINE INDENT data . append ( [ int ( x ) for x in gcj . line ( ) ] ) NEW_LINE assert len ( data [ - 1 ] ) == n NEW_LINE DEDENT print gcj . case ( ) , solve ( data ) ) NEW_LINE DEDENT DEDENT def solve ( data ) : NEW_LINE INDENT res = 0 NEW_LINE n = len ( data ) NEW_LINE res = 0 NEW_LINE while n > 1 : NEW_LINE INDENT m = data [ n ] NEW_LINE assert len ( data [ - 1 ] ) == n NEW_LINE if m == 2 : NEW_LINE INDENT res += 1 NEW_LINE DEDENT else : NEW_LINE INDENT res += 1 NEW_LINE DEDENT print \" Case ▁ # % d : ▁ % d \" % ( i + 1 , res ) NEW_LINE DEDENT DEDENT def solve ( data ) : NEW_LINE INDENT res += 1 NEW_LINE print g"],"references":["def solve ( ) : NEW_LINE INDENT N = input ( ) NEW_LINE ar = [ int ( _ ) for _ in raw_input ( ) . split ( ) ] NEW_LINE diffs = [ a - b for a , b in zip ( ar , ar [ 1 : ] ) ] NEW_LINE eat1 = sum ( max ( x , 0 ) for x in diffs ) NEW_LINE rate = max ( diffs + [ 0 ] ) NEW_LINE eat2 = sum ( min ( x , rate ) for x in ar [ : - 1 ] ) NEW_LINE return eat1 , eat2 NEW_LINE DEDENT T = input ( ) NEW_LINE for t in range ( 1 , T + 1 ) : NEW_LINE INDENT a , b = solve ( ) NEW_LINE print ' Case ▁ # % d : ▁ % d ▁ % d ' % ( t , a , b ) NEW_LINE DEDENT","cases = int ( raw_input ( ) ) NEW_LINE for i in xrange ( cases ) : NEW_LINE INDENT sample_count = int ( raw_input ( ) ) NEW_LINE samples = map ( int , raw_input ( ) . split ( ) ) NEW_LINE max_dec = 0 NEW_LINE prev = 0 NEW_LINE eaten1 = 0 NEW_LINE for x in samples : NEW_LINE INDENT eaten1 += max ( 0 , prev - x ) NEW_LINE max_dec = max ( max_dec , prev - x ) NEW_LINE prev = x NEW_LINE DEDENT prev = 0 NEW_LINE eaten2 = 0 NEW_LINE for x in samples : NEW_LINE INDENT eaten2 += min ( prev , max_dec ) NEW_LINE prev = x NEW_LINE DEDENT print \" Case ▁ # { } : ▁ { } ▁ { } \" . format ( i + 1 , eaten1 , eaten2 ) NEW_LINE DEDENT","import imp NEW_LINE __mod = imp . new_module ( \" utils \" ) NEW_LINE exec \"\"\" # ! \/ usr \/ bin \/ python STRNEWLINE STRNEWLINE from ▁ itertools ▁ import ▁ chain , ▁ repeat , ▁ izip STRNEWLINE STRNEWLINE def ▁ line ( * args ) : STRNEWLINE TABSYMBOL L ▁ = ▁ raw _ input ( ) . strip ( ) . split ( ) STRNEWLINE TABSYMBOL L ▁ = ▁ izip ( ▁ L , ▁ chain ( ▁ args , ▁ repeat ( str ) ▁ ) ▁ ) STRNEWLINE TABSYMBOL return ▁ [ ▁ type ( data ) ▁ for ▁ data , ▁ type ▁ in ▁ L ▁ ] TABSYMBOL STRNEWLINE TABSYMBOL STRNEWLINE def ▁ iline ( ) : ▁ return ▁ map ( ▁ int , ▁ raw _ input ( ) . strip ( ) . split ( ) ▁ ) STRNEWLINE def ▁ fline ( ) : ▁ return ▁ map ( ▁ float , ▁ raw _ input ( ) . strip ( ) . split ( ) ▁ ) \"\"\" in vars ( __mod ) NEW_LINE from utils import iline NEW_LINE from itertools import izip NEW_LINE def test ( ) : NEW_LINE INDENT iline ( ) NEW_LINE M = iline ( ) NEW_LINE def solve ( ) : NEW_LINE INDENT diffs = [ max ( 0 , a - b ) for a , b in izip ( M [ : - 1 ] , M [ 1 : ] ) ] NEW_LINE A = sum ( diffs ) NEW_LINE rate = max ( diffs ) NEW_LINE B = sum ( min ( a , rate ) for a in M [ : - 1 ] ) NEW_LINE print A , B NEW_LINE DEDENT return solve NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT T = input ( ) NEW_LINE for i in xrange ( 1 , T + 1 ) : NEW_LINE INDENT print ' Case ▁ # % d : ' % i , NEW_LINE test ( ) ( ) NEW_LINE DEDENT DEDENT"],"bleu":0.2132323345540343,"rouge_l":0.4154281398415198}
{"id":144,"predictions":["inFile = open ( \" C - large . in \" , \" r \" ) NEW_LINE outFile = open ( \" C - large - out . out \" , \" w \" ) NEW_LINE cases = int ( inFile . readline ( ) ) NEW_LINE for caseNum in range ( 1 , cases + 1 ) : NEW_LINE INDENT shipCount = int ( inFile . readline ( ) ) NEW_LINE shipList = [ ] NEW_LINE for i in range ( shipCount ) : NEW_LINE INDENT ship = inFile . readline ( ) . rstrip ( ) NEW_LINE ship = ship . split ( \" ▁ \" ) NEW_LINE ship = map ( float , ship ) NEW_LINE shipList . append ( ship ) NEW_LINE DEDENT maxPower = 0.0 NEW_LINE for i in range ( shipCount ) : NEW_LINE INDENT for j in range ( i + 1 , shipCount ) : NEW_LINE INDENT taxiDist = abs ( shipList [ i ] [ 0 ] - shipList [ j ] [ 0 ] ) + abs ( shipList [ i ] [ 1 ] - shipList [ j ] [ 1 ] ) + abs ( shipList [ i ] [ 2 ] - shipList [ j ] [ 2 ] ) NEW_LINE powerSum = shipList [ i ] [ 3 ] + shipList [ j ] [ 3 ] NEW_LINE power = taxiDist \/ powerSum NEW_LINE if power > maxPower : NEW_LINE INDENT maxPower = power NEW_LINE DEDENT DEDENT DEDENT outputString = \" Case ▁ # \" + str ( caseNum ) + \" : ▁ \" + str ( maxPower ) + \" \\n \" NEW_LINE print outputString . rstrip ( ) NEW_LINE outFile . write ( outputString ) NEW_LINE DEDENT inFile . close ( ) NEW_LINE outFile . close ( ) NEW_LINE"],"references":["import sys NEW_LINE from math import sqrt NEW_LINE class Obj : NEW_LINE INDENT pass NEW_LINE DEDENT def dist ( o1 , o2 ) : NEW_LINE INDENT return ( sqrt ( ( o1 . x - o2 . x ) ** 2 + ( o1 . y - o2 . y ) ** 2 ) + o2 . r + o1 . r ) \/ 2.0 NEW_LINE DEDENT def solve ( a ) : NEW_LINE INDENT n = len ( a ) NEW_LINE if n == 1 : NEW_LINE INDENT return a [ 0 ] . r NEW_LINE DEDENT if n == 2 : NEW_LINE INDENT return max ( a [ 0 ] . r , a [ 1 ] . r ) NEW_LINE DEDENT res = max ( dist ( a [ 0 ] , a [ 1 ] ) , a [ 2 ] . r ) NEW_LINE res = min ( res , max ( dist ( a [ 0 ] , a [ 2 ] ) , a [ 1 ] . r ) ) NEW_LINE res = min ( res , max ( dist ( a [ 1 ] , a [ 2 ] ) , a [ 0 ] . r ) ) NEW_LINE return res NEW_LINE DEDENT nCases = int ( sys . stdin . readline ( ) ) NEW_LINE for c in xrange ( 1 , nCases + 1 ) : NEW_LINE INDENT n = int ( sys . stdin . readline ( ) ) NEW_LINE a = [ ] NEW_LINE for i in xrange ( n ) : NEW_LINE INDENT o = Obj ( ) ; NEW_LINE ( o . x , o . y , o . r ) = [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE a . append ( o ) NEW_LINE DEDENT print \" Case ▁ # \" + str ( c ) + \" : ▁ \" + repr ( solve ( a ) ) NEW_LINE DEDENT","from pprint import pprint NEW_LINE import time NEW_LINE from sys import stdout , stdin , stderr NEW_LINE import sys NEW_LINE from math import sqrt NEW_LINE def read_int ( strLine ) : NEW_LINE INDENT return map ( int , strLine . split ( ' ▁ ' ) ) NEW_LINE DEDENT def rsreadline ( ) : NEW_LINE INDENT return inputfile . readline ( ) . rstrip ( ' \\n ' ) NEW_LINE DEDENT def solve ( rgPlants , fixed ) : NEW_LINE INDENT r = list ( rgPlants ) NEW_LINE del r [ fixed ] NEW_LINE return max ( rgPlants [ fixed ] [ 2 ] , ( sqrt ( ( r [ 0 ] [ 0 ] - r [ 1 ] [ 0 ] ) ** 2 + ( r [ 0 ] [ 1 ] - r [ 1 ] [ 1 ] ) ** 2 ) + r [ 0 ] [ 2 ] + r [ 1 ] [ 2 ] ) \/ 2 ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT cCase = int ( rsreadline ( ) ) NEW_LINE for iCase in range ( 0 , cCase ) : NEW_LINE INDENT cPlants = int ( rsreadline ( ) ) NEW_LINE rgPlants = [ ] NEW_LINE for i in range ( 0 , cPlants ) : NEW_LINE INDENT rgPlants . append ( read_int ( rsreadline ( ) ) ) NEW_LINE DEDENT ret = - 1.0 NEW_LINE if cPlants == 1 : NEW_LINE INDENT ret = rgPlants [ 0 ] [ 2 ] NEW_LINE DEDENT if cPlants == 2 : NEW_LINE INDENT ret = max ( rgPlants [ 0 ] [ 2 ] , rgPlants [ 1 ] [ 2 ] ) NEW_LINE DEDENT if cPlants == 3 : NEW_LINE INDENT ret = min ( solve ( rgPlants , 0 ) , solve ( rgPlants , 1 ) , solve ( rgPlants , 2 ) ) NEW_LINE DEDENT print ' Case ▁ # % d : ▁ % .8f ' % ( iCase + 1 , ret ) NEW_LINE stdout . flush ( ) NEW_LINE DEDENT DEDENT inputfile = stdin NEW_LINE if __name__ == ' _ _ main _ _ ' and not sys . argv [ 0 ] == ' - c ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT elif sys . argv [ 0 ] == ' - c ' : NEW_LINE INDENT print time . strftime ( ' % Y % m % d ▁ % H % M % S ' ) + ' ▁ loaded ' NEW_LINE print ' - - ' NEW_LINE inputfile = file ( ' input ' ) NEW_LINE main ( ) NEW_LINE print ' - - ' NEW_LINE DEDENT","problem = ' a ' NEW_LINE input_file_name = problem + \" . in \" NEW_LINE output_file_name = problem + \" . out \" NEW_LINE test_data = \"\"\" STRNEWLINE \"\"\" NEW_LINE test_data = None NEW_LINE def process ( input ) : NEW_LINE INDENT output = [ ] NEW_LINE iLine = 0 NEW_LINE N = int ( input [ iLine ] . strip ( ) ) NEW_LINE iLine += 1 NEW_LINE for case in range ( 1 , N + 1 ) : NEW_LINE INDENT print \" Case ▁ % d \" % case NEW_LINE nn = int ( input [ iLine ] . strip ( ) ) NEW_LINE iLine += 1 NEW_LINE for i in range ( nn ) : NEW_LINE INDENT input [ iLine ] . strip ( ) NEW_LINE iLine += 1 NEW_LINE DEDENT result = 0 NEW_LINE output . append ( result ) NEW_LINE DEDENT return output NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT input = None NEW_LINE if test_data is None : NEW_LINE INDENT ifile = open ( input_file_name ) NEW_LINE input = ifile . readlines ( ) NEW_LINE ifile . close ( ) NEW_LINE DEDENT else : NEW_LINE INDENT input = test_data . split ( ' \\n ' ) NEW_LINE DEDENT output = process ( input ) NEW_LINE if test_data is None : NEW_LINE INDENT ofile = open ( output_file_name , ' w ' ) NEW_LINE for i in range ( len ( output ) ) : NEW_LINE INDENT print >> ofile , \" Case ▁ # % d : \" % ( i + 1 ) , output [ i ] NEW_LINE DEDENT ofile . close ( ) NEW_LINE DEDENT for i in range ( len ( output ) ) : NEW_LINE INDENT print \" Case ▁ # % d : \" % ( i + 1 ) , output [ i ] NEW_LINE DEDENT return len ( output ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT import time NEW_LINE start = time . time ( ) NEW_LINE N = main ( ) NEW_LINE print \" Done ▁ in ▁ % f ▁ seconds \" % ( time . time ( ) - start ) NEW_LINE print \" Average ▁ % f ▁ milliseconds \" % ( ( time . time ( ) - start ) * 1000 \/ N ) NEW_LINE DEDENT"],"bleu":0.33505802502081244,"rouge_l":0.35248885248885253}
{"id":145,"predictions":["f_in = open ( ' a - large . in ' ) NEW_LINE f_out = open ( ' a - large . out ' , ' w ' ) NEW_LINE n = int ( f_in . readline ( ) ) NEW_LINE cases = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] != s [ i ] : NEW_LINE INDENT fractions . append ( f_out . write ( str ( i ) ) + ' \\n ' ) NEW_LINE break NEW_LINE DEDENT s = f_in . readline ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s [ f_in . append ( s [ i ] ) NEW_LINE DEDENT c = 0 NEW_LINE for j in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] != s [ j ] : NEW_LINE INDENT f_out . write ( \" Case ▁ # \" + str ( i ) + \" : ▁ \" + str ( i ) + \" : ▁ \" + str ( c ) ) NEW_LINE DEDENT DEDENT"],"references":["import sys NEW_LINE sys . setrecursionlimit ( 100000 ) NEW_LINE inp = sys . stdin NEW_LINE outp = sys . stdout NEW_LINE words = [ \" ZERO \" , \" ONE \" , \" TWO \" , \" THREE \" , \" FOUR \" , \" FIVE \" , \" SIX \" , \" SEVEN \" , \" EIGHT \" , \" NINE \" ] NEW_LINE m = [ ( 0 , ' Z ' ) , ( 2 , ' W ' ) , ( 4 , ' U ' ) , ( 6 , ' X ' ) , ( 7 , ' S ' ) , ( 5 , ' V ' ) , ( 1 , ' O ' ) , ( 3 , ' R ' ) , ( 8 , ' H ' ) , ( 9 , ' E ' ) ] NEW_LINE def solve ( ) : NEW_LINE INDENT x = sys . stdin . readline ( ) . strip ( ) NEW_LINE f = [ 0 ] * 10 NEW_LINE for ( d , c ) in m : NEW_LINE INDENT cnt = x . count ( c ) NEW_LINE f [ d ] += cnt NEW_LINE for c2 in words [ d ] : NEW_LINE INDENT x = x . replace ( c2 , ' ' , cnt ) NEW_LINE DEDENT DEDENT assert x == ' ' NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT outp . write ( ( ' % d ' % i ) * f [ i ] ) NEW_LINE DEDENT print NEW_LINE DEDENT T = int ( inp . readline ( ) ) NEW_LINE for i in range ( T ) : NEW_LINE INDENT outp . write ( ' Case ▁ # % d : ▁ ' % ( i + 1 ) ) NEW_LINE solve ( ) NEW_LINE DEDENT","from collections import Counter NEW_LINE T = int ( input ( ) ) NEW_LINE for t in range ( T ) : NEW_LINE INDENT c = Counter ( input ( ) ) NEW_LINE res = { d : 0 for d in range ( 10 ) } NEW_LINE res [ 8 ] = c [ ' G ' ] NEW_LINE for let in ' EIGHT ' : NEW_LINE INDENT c [ let ] -= res [ 8 ] NEW_LINE DEDENT res [ 3 ] = c [ ' H ' ] NEW_LINE for let in ' THREE ' : NEW_LINE INDENT c [ let ] -= res [ 3 ] NEW_LINE DEDENT res [ 4 ] = c [ ' U ' ] NEW_LINE for let in ' FOUR ' : NEW_LINE INDENT c [ let ] -= res [ 4 ] NEW_LINE DEDENT res [ 2 ] = c [ ' W ' ] NEW_LINE for let in ' TWO ' : NEW_LINE INDENT c [ let ] -= res [ 2 ] NEW_LINE DEDENT res [ 6 ] = c [ ' X ' ] NEW_LINE for let in ' SIX ' : NEW_LINE INDENT c [ let ] -= res [ 6 ] NEW_LINE DEDENT res [ 5 ] = c [ ' F ' ] NEW_LINE for let in ' FIVE ' : NEW_LINE INDENT c [ let ] -= res [ 5 ] NEW_LINE DEDENT res [ 7 ] = c [ ' V ' ] NEW_LINE for let in ' SEVEN ' : NEW_LINE INDENT c [ let ] -= res [ 7 ] NEW_LINE DEDENT res [ 0 ] = c [ ' Z ' ] NEW_LINE for let in ' ZERO ' : NEW_LINE INDENT c [ let ] -= res [ 0 ] NEW_LINE DEDENT res [ 1 ] = c [ ' O ' ] NEW_LINE for let in ' ONE ' : NEW_LINE INDENT c [ let ] -= res [ 1 ] NEW_LINE DEDENT res [ 9 ] = c [ ' I ' ] NEW_LINE for let in ' NINE ' : NEW_LINE INDENT c [ let ] -= res [ 9 ] NEW_LINE DEDENT ans = ' ' . join ( str ( d ) * res [ d ] for d in range ( 10 ) ) NEW_LINE print ( ' Case ▁ # { } : ▁ { } ' . format ( t + 1 , ans ) ) NEW_LINE DEDENT","import sys NEW_LINE from collections import defaultdict NEW_LINE alpha = ' ABCDEFGHIJKLMNOPQRSTUVWXYZ ' NEW_LINE assert len ( alpha ) == 26 NEW_LINE def run ( S ) : NEW_LINE INDENT lcounts = defaultdict ( int ) NEW_LINE ncounts = [ 0 ] * 10 NEW_LINE for l in S : NEW_LINE INDENT lcounts [ l ] += 1 NEW_LINE DEDENT def setk ( k , kstr , l ) : NEW_LINE INDENT xxx = lcounts [ l ] NEW_LINE ncounts [ k ] = xxx NEW_LINE for lete in kstr : NEW_LINE INDENT lcounts [ lete ] -= xxx NEW_LINE DEDENT DEDENT setk ( 0 , ' ZERO ' , ' Z ' ) NEW_LINE setk ( 2 , ' TWO ' , ' W ' ) NEW_LINE setk ( 6 , ' SIX ' , ' X ' ) NEW_LINE setk ( 8 , ' EIGHT ' , ' G ' ) NEW_LINE setk ( 7 , ' SEVEN ' , ' S ' ) NEW_LINE setk ( 5 , ' FIVE ' , ' V ' ) NEW_LINE setk ( 9 , ' NINE ' , ' I ' ) NEW_LINE setk ( 1 , ' ONE ' , ' N ' ) NEW_LINE setk ( 4 , ' FOUR ' , ' U ' ) NEW_LINE setk ( 3 , ' THREE ' , ' R ' ) NEW_LINE assert not sum ( lcounts . values ( ) ) NEW_LINE return ' ' . join ( a * b for a , b in zip ( list ( '0123456789' ) , ncounts ) ) NEW_LINE DEDENT f = file ( sys . argv [ 1 ] , ' r ' ) NEW_LINE T = int ( f . readline ( ) . strip ( ) ) NEW_LINE for case in range ( 1 , T + 1 ) : NEW_LINE INDENT S = f . readline ( ) . strip ( ) NEW_LINE ans = run ( S ) NEW_LINE print ' Case ▁ # % d : ▁ % s ' % ( case , ans ) NEW_LINE DEDENT"],"bleu":0.15324648168092114,"rouge_l":0.3276330411161872}
{"id":146,"predictions":["from itertools import combinations NEW_LINE from random import randint NEW_LINE from collections import defaultdict NEW_LINE from time import time NEW_LINE def solve ( numbers ) : NEW_LINE INDENT nnum = len ( numbers ) NEW_LINE sums = defaultdict ( list ) NEW_LINE t0 = time ( ) NEW_LINE for i in range ( 2 , nnum ) : NEW_LINE INDENT for subset in combinations ( numbers , i ) : NEW_LINE INDENT if time ( ) - t0 > 30 : return None NEW_LINE s = set ( subset ) NEW_LINE s_sum = sum ( s ) NEW_LINE for subset in sums [ s_sum ] : NEW_LINE INDENT if len ( s & other ) == 0 : NEW_LINE INDENT return s , other NEW_LINE DEDENT DEDENT sums [ s_sum ] . append ( s ) NEW_LINE DEDENT DEDENT return None NEW_LINE DEDENT def test ( ) : NEW_LINE INDENT nums = set ( ) NEW_LINE while len ( nums ) < 500 : NEW_LINE INDENT draw = 500 - len ( nums ) NEW_LINE [ nums . add ( randint ( 1 , 10 ** 12 ) ) for i in range ( draw ) ] NEW_LINE DEDENT result = solve ( nums ) NEW_LINE print result NEW_LINE print result NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT def iterate_tokens ( ) : NEW_LINE INDENT for line in sys . stdin : NEW_LINE INDENT for word in line . split ( ) : NEW_LINE INDENT yield word NEW_LINE DEDENT DEDENT tokens = iterate_tokens ( ) . split ( ) NEW_LINE N = int ( next ( tokens ) ) NEW_LINE solve ( N ) NEW_LINE DEDENT tokens = iterate_tokens ( ) NEW_LINE solve ( N ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"references":["import os , sys NEW_LINE def convertToBase ( number , base ) : NEW_LINE INDENT digits = [ ] NEW_LINE mod = base NEW_LINE prevMod = 1 NEW_LINE while number > 0 : NEW_LINE INDENT digit = ( number % mod ) \/ prevMod NEW_LINE digits . append ( digit ) NEW_LINE number = number - digit * prevMod NEW_LINE prevMod = mod NEW_LINE mod *= base NEW_LINE DEDENT if len ( digits ) == 0 : NEW_LINE INDENT digits = [ 0 ] NEW_LINE DEDENT return digits NEW_LINE DEDENT def squareDigits ( digits ) : NEW_LINE INDENT return sum ( [ x * x for x in digits ] ) NEW_LINE DEDENT def isHappy ( number , base ) : NEW_LINE INDENT foundNums = set ( ) NEW_LINE while True : NEW_LINE INDENT digits = convertToBase ( number , base ) NEW_LINE number = squareDigits ( digits ) NEW_LINE if number == 1 : NEW_LINE INDENT return True NEW_LINE DEDENT if number in foundNums : NEW_LINE INDENT return False NEW_LINE DEDENT foundNums . add ( number ) NEW_LINE DEDENT DEDENT def main ( filename ) : NEW_LINE INDENT fileLines = open ( filename , ' r ' ) . readlines ( ) NEW_LINE index = 0 NEW_LINE words = [ ] NEW_LINE numCases = int ( fileLines [ index ] [ : - 1 ] ) NEW_LINE index += 1 NEW_LINE for caseNum in range ( numCases ) : NEW_LINE INDENT bases = [ int ( x ) for x in fileLines [ index ] [ : - 1 ] . split ( ' ▁ ' ) ] NEW_LINE index += 1 NEW_LINE i = 2 NEW_LINE while True : NEW_LINE INDENT happy = True NEW_LINE for base in bases : NEW_LINE INDENT if ( not isHappy ( i , base ) ) : NEW_LINE INDENT happy = False NEW_LINE break NEW_LINE DEDENT DEDENT if happy : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print \" Case ▁ # % d : ▁ % d \" % ( caseNum + 1 , i ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 ] ) NEW_LINE DEDENT","f = open ( \" data \" , \" r \" ) NEW_LINE allmins = eval ( f . read ( ) ) NEW_LINE f . close ( ) NEW_LINE for case in range ( input ( ) ) : NEW_LINE INDENT print \" Case ▁ # \" + str ( case + 1 ) + \" : \" , NEW_LINE bases = tuple ( map ( int , raw_input ( ) . split ( ) ) ) NEW_LINE print allmins [ bases ] NEW_LINE DEDENT","import sys NEW_LINE fin = file ( sys . argv [ 1 ] , ' r ' ) NEW_LINE T = int ( fin . readline ( ) ) NEW_LINE def happy ( x , b ) : NEW_LINE INDENT prev = x NEW_LINE prev = [ 0 ] NEW_LINE while True : NEW_LINE INDENT v = 0 NEW_LINE while x > 0 : NEW_LINE INDENT v += ( x % b ) * ( x % b ) NEW_LINE x = x \/ b NEW_LINE DEDENT if v == 1 : return True NEW_LINE if v in prev : return False NEW_LINE prev . append ( v ) NEW_LINE x = v NEW_LINE DEDENT DEDENT for t in xrange ( 1 , T + 1 ) : NEW_LINE INDENT bases = [ int ( x ) for x in fin . readline ( ) . split ( ) ] NEW_LINE m = 2 NEW_LINE while True : NEW_LINE INDENT if all ( happy ( m , b ) for b in bases ) : NEW_LINE INDENT break NEW_LINE DEDENT m += 1 NEW_LINE DEDENT print ' Case ▁ # % d : ▁ % d ' % ( t , m ) NEW_LINE DEDENT"],"bleu":0.27876707083853114,"rouge_l":0.4634940585009141}
{"id":147,"predictions":["import operator NEW_LINE import itertools NEW_LINE import functools NEW_LINE import math NEW_LINE from collections import deque NEW_LINE def bfs ( i ) : NEW_LINE INDENT res = 0 NEW_LINE visited = [ 0 ] * ( N + 1 ) NEW_LINE q = deque ( [ node [ i ] ] ) NEW_LINE while len ( q ) : NEW_LINE INDENT n = q . popleft ( ) NEW_LINE if visited [ n [ 0 ] ] : NEW_LINE INDENT res = 1 NEW_LINE DEDENT else : NEW_LINE INDENT q . append ( node [ x ] ) NEW_LINE DEDENT DEDENT N = int ( - 1 ) NEW_LINE edges = [ ] NEW_LINE for i in xrange ( N ) : NEW_LINE INDENT a , b = map ( int , raw_input ( ) . split ( ) ) NEW_LINE edges . append ( [ a , b ] ) NEW_LINE DEDENT q = [ ] NEW_LINE for i in xrange ( N ) : NEW_LINE INDENT x = q . pop ( ) NEW_LINE edges . append ( x ) NEW_LINE DEDENT for i in xrange ( N ) : NEW_LINE INDENT v = map ( int , raw_input ( ) . split ( ) ) NEW_LINE edges . append ( ( x [ - 1 ] , v [ 1 ] ) ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in xrange ( N ) : NEW_LINE INDENT if edges [ i ] [ v [ i ] > 0 : NEW_LINE INDENT q . append ( edges [ i ] [ i ] ) NEW_LINE DEDENT ans = 0 NEW_LINE DEDENT for j in xrange ( N ) : NEW_LINE INDENT if edges [ j ] [ i ] > 0 : NEW_LINE INDENT ans = edges [ j ] [ i ] - 1 NEW_LINE DEDENT DEDENT print \" Case ▁ # % d : ▁ % d \" % ( j , ans ) NEW_LINE DEDENT"],"references":["from collections import defaultdict NEW_LINE from heapq import nlargest NEW_LINE def maxSize ( adj , node , parent ) : NEW_LINE INDENT children = adj [ node ] - { parent } NEW_LINE if len ( children ) == 1 : return 1 NEW_LINE return sum ( nlargest ( 2 , ( maxSize ( adj , child , node ) for child in children ) ) ) + 1 NEW_LINE DEDENT for t in range ( int ( input ( ) ) ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE adj = defaultdict ( set ) NEW_LINE for _ in range ( N - 1 ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE adj [ a ] . add ( b ) NEW_LINE adj [ b ] . add ( a ) NEW_LINE DEDENT result = N - max ( maxSize ( adj , root , None ) for root in range ( 1 , N + 1 ) ) NEW_LINE assert 0 <= result <= N NEW_LINE print ( ' Case ▁ # { } : ▁ { } ' . format ( t + 1 , result ) ) NEW_LINE DEDENT","from sys import stdin NEW_LINE import sys NEW_LINE sys . setrecursionlimit ( 100000 ) NEW_LINE tt = stdin . readline ( ) NEW_LINE tt = eval ( tt ) NEW_LINE edge = [ ] NEW_LINE visit = set ( ) NEW_LINE def dfs ( i ) : NEW_LINE INDENT global edge NEW_LINE global visit NEW_LINE visit . add ( i ) NEW_LINE sum0 = 0 NEW_LINE sum1 = 1 NEW_LINE be = [ ] NEW_LINE for h in edge [ i ] : NEW_LINE INDENT if not h in visit : NEW_LINE INDENT ret = dfs ( h ) NEW_LINE sum0 += ret [ 1 ] NEW_LINE sum1 += ret [ 1 ] NEW_LINE be . append ( ret [ 1 ] - ret [ 0 ] ) NEW_LINE DEDENT DEDENT be = sorted ( be ) NEW_LINE if len ( be ) == 0 : NEW_LINE INDENT return ( 0 , 1 ) NEW_LINE DEDENT elif len ( be ) == 1 : NEW_LINE INDENT return ( sum1 - 1 , sum1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ll = len ( be ) NEW_LINE return ( sum0 - be [ ll - 1 ] - be [ ll - 2 ] , sum1 ) NEW_LINE DEDENT DEDENT for cc in range ( 1 , tt + 1 ) : NEW_LINE INDENT tmp = stdin . readline ( ) NEW_LINE n = eval ( tmp ) NEW_LINE edge = [ ] NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT edge . append ( [ ] ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT tmp = stdin . readline ( ) NEW_LINE tmp = tmp . split ( ) NEW_LINE j = eval ( tmp [ 0 ] ) NEW_LINE k = eval ( tmp [ 1 ] ) NEW_LINE edge [ j ] . append ( k ) NEW_LINE edge [ k ] . append ( j ) NEW_LINE DEDENT res = n NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT visit = set ( ) NEW_LINE tmp = dfs ( i ) NEW_LINE if tmp [ 0 ] < res : NEW_LINE INDENT res = tmp [ 0 ] NEW_LINE DEDENT DEDENT print \" Case ▁ # % d : ▁ % d \" % ( cc , res ) NEW_LINE DEDENT","import sys , collections NEW_LINE def read ( ) : sys . stdout . flush ( ) ; return sys . stdin . readline ( ) . strip ( ) NEW_LINE def max_size_of_full_tree ( tree , root , seen ) : NEW_LINE INDENT seen = seen | set ( [ root ] ) NEW_LINE subtree_sizes = [ ] NEW_LINE for neighbor in tree [ root ] : NEW_LINE INDENT if neighbor in seen : continue NEW_LINE subsize = max_size_of_full_tree ( tree , neighbor , seen ) NEW_LINE subtree_sizes . append ( subsize ) NEW_LINE DEDENT if len ( subtree_sizes ) < 2 : NEW_LINE INDENT return 1 NEW_LINE DEDENT subtree_sizes . sort ( reverse = True ) NEW_LINE return 1 + subtree_sizes [ 0 ] + subtree_sizes [ 1 ] NEW_LINE DEDENT tests = int ( read ( ) ) NEW_LINE for test in xrange ( tests ) : NEW_LINE INDENT N = int ( read ( ) ) NEW_LINE tree = collections . defaultdict ( list ) NEW_LINE for i in xrange ( N - 1 ) : NEW_LINE INDENT a , b = read ( ) . split ( \" ▁ \" ) NEW_LINE a , b = int ( a ) , int ( b ) NEW_LINE tree [ a ] += [ b ] NEW_LINE tree [ b ] += [ a ] NEW_LINE DEDENT biggest_full_tree_size = 1 NEW_LINE for node in tree : NEW_LINE INDENT size = max_size_of_full_tree ( tree , node , set ( ) ) NEW_LINE if size > biggest_full_tree_size : NEW_LINE INDENT biggest_full_tree_size = size NEW_LINE DEDENT DEDENT answer = N - biggest_full_tree_size NEW_LINE print \" Case ▁ # % d : ▁ % d \" % ( test + 1 , answer ) NEW_LINE DEDENT"],"bleu":0.4108124631383824,"rouge_l":0.4813679240743629}
{"id":148,"predictions":["from sys import stdin , stdout NEW_LINE nCk = [ [ int ( ) ] * 501 for i in range ( 501 ) ] NEW_LINE for n in range ( 0 , 501 ) : NEW_LINE INDENT nCk [ n ] [ 0 ] = 1 NEW_LINE for k in range ( 1 , n + 1 ) : NEW_LINE INDENT nCk [ n ] [ k ] = nCk [ n ] [ k - 1 ] * ( n + 1 - k ) \/ 3 NEW_LINE DEDENT DEDENT for n in range ( 0 , 501 ) : NEW_LINE INDENT for k in range ( 1 , n + 1 ) : NEW_LINE INDENT nCk [ n ] [ k ] %= 100000000 NEW_LINE DEDENT DEDENT Y = [ [ int ( ) ] * 501 for i in range ( 501 ) ] NEW_LINE y = [ int ( ) ] * 501 NEW_LINE for i in range ( 2 , 501 ) : NEW_LINE INDENT Y [ i ] [ 1 ] = 1 NEW_LINE y [ i ] = 1 NEW_LINE for j in range ( 2 , i ) : NEW_LINE INDENT for k in range ( 1 , j ) : NEW_LINE INDENT Y [ i ] [ j ] += Y [ j ] [ k ] * nCk [ i - j - 1 ] [ k - j - k ] NEW_LINE DEDENT y [ i ] += Y [ i ] [ j ] NEW_LINE DEDENT y [ i ] %= 1000000007 NEW_LINE DEDENT for x in range ( 1 , int ( stdin . readline ( ) ) + 1 ) : NEW_LINE INDENT n = int ( stdin . readline ( ) ) NEW_LINE stdout . write ( \" Case ▁ # % i : ▁ % i \\n \" % ( x , \" % ( x , y ) ) NEW_LINE DEDENT"],"references":["ops = [ int . __add__ , int . __sub__ ] NEW_LINE ugly_count = 0 NEW_LINE def is_ugly ( num ) : NEW_LINE INDENT return num % 2 == 0 or num % 3 == 0 or num % 5 == 0 or num % 7 == 0 NEW_LINE DEDENT def count_ugly ( left_slice_num , right_slice , op ) : NEW_LINE INDENT global ugly_count NEW_LINE if is_ugly ( op ( left_slice_num , int ( right_slice ) ) ) : NEW_LINE INDENT ugly_count += 1 NEW_LINE DEDENT if len ( right_slice ) > 1 : NEW_LINE INDENT for i in xrange ( - 1 , - len ( right_slice ) , - 1 ) : NEW_LINE INDENT for sub_op in ops : NEW_LINE INDENT count_ugly ( op ( left_slice_num , int ( right_slice [ : i ] ) ) , right_slice [ i : ] , sub_op ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT testsCount = int ( raw_input ( ) ) NEW_LINE for i in xrange ( testsCount ) : NEW_LINE INDENT ugly_count = 0 NEW_LINE count_ugly ( 0 , raw_input ( ) , int . __add__ ) NEW_LINE print \" Case ▁ # % d : ▁ % d \" % ( i + 1 , ugly_count ) NEW_LINE DEDENT DEDENT","FNAME = \" B - small - attempt0 . in \" NEW_LINE PRIMDIV = 2 , 3 , 5 , 7 NEW_LINE class Case ( object ) : NEW_LINE INDENT def __init__ ( self , num ) : NEW_LINE INDENT self . num = num NEW_LINE DEDENT DEDENT def isugly ( n ) : NEW_LINE INDENT for i in PRIMDIV : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def getvals ( s ) : NEW_LINE INDENT vals = [ ] NEW_LINE for i in xrange ( len ( s ) ) : NEW_LINE INDENT v = int ( s [ : i + 1 ] ) NEW_LINE if not s [ i + 1 : ] : NEW_LINE INDENT prevvals = [ 0 ] NEW_LINE vals . append ( v ) NEW_LINE DEDENT else : NEW_LINE INDENT prevvals = getvals ( s [ i + 1 : ] ) NEW_LINE vals . extend ( [ v + val for val in prevvals ] ) NEW_LINE vals . extend ( [ v - val for val in prevvals ] ) NEW_LINE DEDENT DEDENT return vals NEW_LINE DEDENT def getnugly ( s ) : NEW_LINE INDENT return len ( [ val for val in getvals ( s ) if isugly ( val ) ] ) NEW_LINE DEDENT def parse ( lines ) : NEW_LINE INDENT cases = [ ] NEW_LINE i = 1 NEW_LINE while i < len ( lines ) : NEW_LINE INDENT cases . append ( Case ( lines [ i ] ) ) NEW_LINE i += 1 NEW_LINE DEDENT return cases NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT lines = file ( FNAME ) . read ( ) . splitlines ( ) NEW_LINE answers = [ getnugly ( case . num ) for case in parse ( lines ) ] NEW_LINE outlines = [ \" Case ▁ # % d : ▁ % d \\n \" % ( i + 1 , answer ) for i , answer in enumerate ( answers ) ] NEW_LINE file ( FNAME + \" . out \" , \" w \" ) . writelines ( outlines ) NEW_LINE DEDENT","fin = open ( \" c . in \" , \" r \" ) NEW_LINE n = int ( fin . readline ( ) ) NEW_LINE fout = open ( \" c . out \" , \" w \" ) NEW_LINE def ugly ( n ) : NEW_LINE INDENT if n % 2 == 0 or n % 3 == 0 or n % 5 == 0 or n % 7 == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT def count ( n , k , s , pos ) : NEW_LINE INDENT if len ( n ) == 0 : NEW_LINE INDENT return ugly ( k + s ) NEW_LINE DEDENT a = 0 NEW_LINE if pos : NEW_LINE INDENT a += count ( n [ 1 : ] , k , s * 10 + int ( n [ 0 ] ) , True ) NEW_LINE DEDENT else : NEW_LINE INDENT a += count ( n [ 1 : ] , k , s * 10 - int ( n [ 0 ] ) , False ) NEW_LINE DEDENT a += count ( n [ 1 : ] , k + s , int ( n [ 0 ] ) , True ) NEW_LINE a += count ( n [ 1 : ] , k + s , - int ( n [ 0 ] ) , False ) NEW_LINE return a NEW_LINE DEDENT for i in xrange ( 1 , n + 1 ) : NEW_LINE INDENT d = fin . readline ( ) . strip ( ) NEW_LINE c = count ( d [ 1 : ] , 0 , int ( d [ 0 ] ) , True ) NEW_LINE print c NEW_LINE print >> fout , \" Case ▁ # % d : ▁ % d \" % ( i , c ) NEW_LINE DEDENT"],"bleu":0.23532541330002277,"rouge_l":0.38329004150720264}
{"id":149,"predictions":["inp_file = file ( \" C - small . in \" ) NEW_LINE out_file = file ( \" C - small . out \" , \" w \" ) NEW_LINE def solve ( line ) : NEW_LINE INDENT line = [ int ( c1 ) for c1 in line . split ( \" ▁ \" ) ] NEW_LINE card_num , indices = line [ : 2 ] NEW_LINE line = line [ 2 : ] NEW_LINE positions = range ( card_num ) NEW_LINE result = [ 0 for c1 in range ( card_num ) ] NEW_LINE c1 = 1 NEW_LINE c2 = 0 NEW_LINE while c1 < card_num : NEW_LINE INDENT result [ positions [ c2 ] ] = c1 NEW_LINE positions . pop ( c2 ) NEW_LINE c2 = ( c2 + c1 ) % len ( positions ) NEW_LINE c1 += 1 NEW_LINE c2 += 1 NEW_LINE c1 = 0 NEW_LINE c1 = 0 NEW_LINE while c1 : NEW_LINE INDENT c2 += 1 NEW_LINE c2 += 1 NEW_LINE c2 += 1 NEW_LINE DEDENT result [ c1 ] = c1 NEW_LINE c2 = 0 NEW_LINE while c1 > 0 : NEW_LINE INDENT result [ result . append ( c1 ) NEW_LINE c2 += 1 NEW_LINE DEDENT print \" Case ▁ # \" + str ( case_num ) + \" : ▁ \" + str ( case_num ) NEW_LINE DEDENT"],"references":["inp_file = file ( \" B - small . in \" ) NEW_LINE out_file = file ( \" B - small . out \" , \" w \" ) NEW_LINE def solve ( line ) : NEW_LINE INDENT A , B , P = [ int ( c1 ) for c1 in line . split ( \" ▁ \" ) ] NEW_LINE numbers = range ( A , B + 1 ) NEW_LINE sets = range ( B - A + 1 ) NEW_LINE for c1 in primes : NEW_LINE INDENT if c1 < P : continue NEW_LINE if c1 > B \/ 2 + 1 : break NEW_LINE same = [ ] NEW_LINE for c2 in numbers : NEW_LINE INDENT if not c2 % c1 : same . append ( c2 - A ) NEW_LINE DEDENT sets = merge_sets ( sets , same ) NEW_LINE DEDENT counted = [ ] NEW_LINE c2 = 0 NEW_LINE for c1 in sets : NEW_LINE INDENT if not c1 in counted : NEW_LINE INDENT counted . append ( c1 ) NEW_LINE c2 += 1 NEW_LINE DEDENT DEDENT return str ( c2 ) NEW_LINE DEDENT def merge_sets ( sets , same ) : NEW_LINE INDENT to_change = [ sets [ c1 ] for c1 in same ] NEW_LINE for c1 in range ( len ( sets ) ) : NEW_LINE INDENT if sets [ c1 ] in to_change : NEW_LINE INDENT sets [ c1 ] = to_change [ 0 ] NEW_LINE DEDENT DEDENT return sets NEW_LINE DEDENT p_file = file ( \" primes1000 . txt \" ) NEW_LINE primes = [ int ( c1 ) for c1 in p_file . read ( ) . split ( \" \\n \" ) ] NEW_LINE p_file . close ( ) NEW_LINE num = int ( inp_file . readline ( ) ) NEW_LINE for case in range ( num ) : NEW_LINE INDENT line = inp_file . readline ( ) [ : - 1 ] NEW_LINE out_file . write ( \" Case ▁ # % s : ▁ \" % ( case + 1 ) + solve ( line ) + \" \\n \" ) NEW_LINE DEDENT inp_file . close ( ) NEW_LINE out_file . close ( ) NEW_LINE","from time import time NEW_LINE import psyco NEW_LINE import re NEW_LINE import math NEW_LINE psyco . full ( ) NEW_LINE fin = open ( \"2 _ input . txt \" , \" r \" ) NEW_LINE fout = open ( \"2 _ output . txt \" , \" w \" ) NEW_LINE cases = int ( fin . readline ( ) ) NEW_LINE cached = { } NEW_LINE def isprime ( n ) : NEW_LINE INDENT global cached NEW_LINE if n in cached : NEW_LINE INDENT return cached [ n ] NEW_LINE DEDENT if n == 2 : return True NEW_LINE for x in range ( 2 , int ( n ** 0.5 ) + 1 ) : NEW_LINE INDENT if n % x == 0 : NEW_LINE INDENT cached [ n ] = False NEW_LINE return False NEW_LINE DEDENT DEDENT cached [ n ] = True NEW_LINE return True NEW_LINE DEDENT def check_for_p ( a , b , p ) : NEW_LINE INDENT for num in range ( p , b ) : NEW_LINE INDENT if isprime ( num ) and ( a % num == 0 and b % num == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT t0 = time ( ) NEW_LINE for casenr in range ( cases ) : NEW_LINE INDENT ( A , B , P ) = map ( int , [ e for e in fin . readline ( ) . split ( ) ] ) NEW_LINE n = B - A NEW_LINE set_id = { } NEW_LINE for i in range ( A , B + 1 ) : NEW_LINE INDENT set_id [ i ] = i - A NEW_LINE DEDENT set_count = n + 1 NEW_LINE for p0 in range ( A , B + 1 ) : NEW_LINE INDENT for p1 in range ( p0 + 1 , B + 1 ) : NEW_LINE INDENT if ( set_id [ p0 ] == set_id [ p1 ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT if check_for_p ( p0 , p1 , P ) : NEW_LINE INDENT set_count -= 1 NEW_LINE ex = set_id [ p1 ] NEW_LINE for k in set_id . keys ( ) : NEW_LINE INDENT if set_id [ k ] == ex : NEW_LINE INDENT set_id [ k ] = set_id [ p0 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT print set_count NEW_LINE fout . write ( \" Case ▁ # % d : ▁ % d \\n \" % ( casenr + 1 , set_count ) ) NEW_LINE DEDENT","from sys import stdin NEW_LINE from collections import deque NEW_LINE MAX = 1000000 NEW_LINE primes = set ( xrange ( 2 , MAX ) , ) NEW_LINE for p in xrange ( 2 , MAX ) : NEW_LINE INDENT if p in primes : NEW_LINE INDENT for i in xrange ( 2 * p , MAX , p ) : NEW_LINE INDENT if i in primes : NEW_LINE INDENT primes . remove ( i ) NEW_LINE DEDENT DEDENT DEDENT DEDENT tno = int ( stdin . readline ( ) ) NEW_LINE for j in xrange ( tno ) : NEW_LINE INDENT A , B , P = map ( long , stdin . readline ( ) . strip ( ) . split ( ) ) NEW_LINE tab = [ - 1 ] * ( B - A + 1 ) NEW_LINE pr = [ x for x in primes if x >= P and x <= B - A ] NEW_LINE hm = 0 NEW_LINE ed = [ [ ] for _ in xrange ( 0 , B - A + 1 ) ] NEW_LINE for p in pr : NEW_LINE INDENT f = ( ( A + p - 1 ) \/\/ p ) * p - A NEW_LINE for x in xrange ( f , B - A + 1 , p ) : NEW_LINE INDENT if x != f : NEW_LINE INDENT ed [ x - p ] . append ( x ) NEW_LINE ed [ x ] . append ( x - p ) NEW_LINE DEDENT DEDENT DEDENT for i in xrange ( B - A + 1 ) : NEW_LINE INDENT if tab [ i ] != - 1 : NEW_LINE INDENT continue NEW_LINE DEDENT q = deque ( ( i , ) ) NEW_LINE tab [ i ] = - 1 NEW_LINE while q : NEW_LINE INDENT x = q . popleft ( ) NEW_LINE for e in ed [ x ] : NEW_LINE INDENT if tab [ e ] == - 1 : NEW_LINE INDENT tab [ e ] = i NEW_LINE q . append ( e ) NEW_LINE DEDENT DEDENT DEDENT hm += 1 NEW_LINE del q NEW_LINE DEDENT del pr NEW_LINE del ed NEW_LINE print \" Case ▁ # % d : ▁ % d \" % ( j + 1 , hm , ) NEW_LINE DEDENT"],"bleu":0.24642411186339785,"rouge_l":0.4342091489584423}
{"id":150,"predictions":["import math NEW_LINE class Point : NEW_LINE INDENT def __init__ ( self , x , y ) : NEW_LINE INDENT self . x = x NEW_LINE self . y = y NEW_LINE DEDENT def dot ( self , x , y ) : NEW_LINE INDENT return self . dot ( self . x , y ) == self . dot ( self . x , y ) NEW_LINE DEDENT def dot ( self , x , y ) : NEW_LINE INDENT return self . dot ( self . x , y - x ) ** 2 NEW_LINE DEDENT def dot ( self , x , y ) : NEW_LINE INDENT return self . dot ( self . x * x + y * y NEW_LINE DEDENT DEDENT"],"references":["import math NEW_LINE eps = 0.0000001 NEW_LINE def Solve ( H , W , D , c ) : NEW_LINE INDENT angles = [ ] NEW_LINE W = W - 2 NEW_LINE H = H - 2 NEW_LINE found = False NEW_LINE y = - 0.5 NEW_LINE for line in c : NEW_LINE INDENT x = - 0.5 NEW_LINE for char in line : NEW_LINE INDENT if char == \" X \" : NEW_LINE INDENT found = True NEW_LINE break NEW_LINE DEDENT x = x + 1 NEW_LINE DEDENT if found : NEW_LINE INDENT break NEW_LINE DEDENT y = y + 1 NEW_LINE DEDENT mx = x NEW_LINE my = y NEW_LINE co = 0 NEW_LINE for xcopy in range ( - 50 , 50 ) : NEW_LINE INDENT for ycopy in range ( - 50 , 50 ) : NEW_LINE INDENT if ( xcopy == 0 and ycopy == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if xcopy % 2 != 0 : NEW_LINE INDENT mx = ( xcopy + 1 ) * ( W ) - x NEW_LINE DEDENT else : NEW_LINE INDENT mx = xcopy * ( W ) + x NEW_LINE DEDENT if ycopy % 2 != 0 : NEW_LINE INDENT my = ( ycopy + 1 ) * ( H ) - y NEW_LINE DEDENT else : NEW_LINE INDENT my = ycopy * ( H ) + y NEW_LINE DEDENT dist = math . sqrt ( ( mx - x ) ** 2 + ( my - y ) ** 2 ) NEW_LINE if dist <= D : NEW_LINE INDENT a = 0 NEW_LINE a = math . atan2 ( ( my - y ) , ( mx - x ) ) NEW_LINE if not hasAngle ( a , angles ) : NEW_LINE INDENT co = co + 1 NEW_LINE angles . append ( a ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return co NEW_LINE DEDENT def hasAngle ( a , angles ) : NEW_LINE INDENT for an in angles : NEW_LINE INDENT if abs ( an - a ) < eps : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT f = open ( ' d . in ' ) NEW_LINE T = int ( f . readline ( ) ) NEW_LINE for t in range ( T ) : NEW_LINE INDENT H , W , D = map ( int , f . readline ( ) . split ( ) ) NEW_LINE c = [ ] NEW_LINE for x in range ( H ) : NEW_LINE INDENT c . append ( f . readline ( ) ) NEW_LINE DEDENT result = Solve ( H , W , D , c ) NEW_LINE print \" Case ▁ # % d : ▁ % s \" % ( t + 1 , result ) NEW_LINE DEDENT","import d NEW_LINE ri = raw_input NEW_LINE t = int ( ri ( ) ) NEW_LINE for case in xrange ( 1 , t + 1 ) : NEW_LINE INDENT h , w , ddd = map ( int , ri ( ) . split ( ) ) NEW_LINE X = list ( ) NEW_LINE for i in xrange ( h ) : NEW_LINE INDENT line = ri ( ) NEW_LINE X . append ( line ) NEW_LINE DEDENT print ' Case ▁ # % d : ▁ % d ' % ( case , d . blah ( ddd , X ) ) NEW_LINE DEDENT","import fractions NEW_LINE def distance2 ( p ) : NEW_LINE INDENT return p [ 0 ] ** 2 + p [ 1 ] ** 2 NEW_LINE DEDENT def normalize ( p ) : NEW_LINE INDENT g = fractions . gcd ( abs ( p [ 0 ] ) , abs ( p [ 1 ] ) ) NEW_LINE return p [ 0 ] \/ g , p [ 1 ] \/ g NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT H , W , D = map ( int , raw_input ( ) . split ( ) ) NEW_LINE for j in xrange ( H ) : NEW_LINE INDENT raw = raw_input ( ) NEW_LINE for i in xrange ( W ) : NEW_LINE INDENT if raw [ i ] == ' X ' : NEW_LINE INDENT place = ( i , j ) NEW_LINE DEDENT DEDENT DEDENT dx = ( W - place [ 0 ] - 1 ) * 2 - 1 NEW_LINE dy = ( H - place [ 1 ] - 1 ) * 2 - 1 NEW_LINE H2 = ( H - 2 ) * 2 NEW_LINE W2 = ( W - 2 ) * 2 NEW_LINE D2 = D ** 2 NEW_LINE points = set ( ) NEW_LINE for j in xrange ( - ( D \/ H2 + 1 ) , D \/ H2 + 1 ) : NEW_LINE INDENT for i in xrange ( - ( D \/ W2 + 1 ) , D \/ W2 + 1 ) : NEW_LINE INDENT p0 = ( i * W2 , j * H2 ) NEW_LINE if p0 != ( 0 , 0 ) and distance2 ( p0 ) <= D2 : NEW_LINE INDENT points . add ( normalize ( p0 ) ) NEW_LINE DEDENT p1 = ( i * W2 + dx , j * H2 ) NEW_LINE if distance2 ( p1 ) <= D2 : NEW_LINE INDENT points . add ( normalize ( p1 ) ) NEW_LINE DEDENT p2 = ( i * W2 , j * H2 + dy ) NEW_LINE if distance2 ( p2 ) <= D2 : NEW_LINE INDENT points . add ( normalize ( p2 ) ) NEW_LINE DEDENT p3 = ( i * W2 + dx , j * H2 + dy ) NEW_LINE if distance2 ( p3 ) <= D2 : NEW_LINE INDENT points . add ( normalize ( p3 ) ) NEW_LINE DEDENT DEDENT DEDENT return len ( points ) NEW_LINE DEDENT T = int ( raw_input ( ) ) NEW_LINE for i in range ( T ) : NEW_LINE INDENT print \" Case ▁ # % d : \" % ( i + 1 ) , solve ( ) NEW_LINE DEDENT"],"bleu":0.25535684843019124,"rouge_l":0.389984105649719}
{"id":151,"predictions":["def solve ( a ) : NEW_LINE INDENT if len ( a ) == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT b = [ ] NEW_LINE cur = a [ 0 ] - 1 NEW_LINE cnt = 0 NEW_LINE for x in a : NEW_LINE INDENT if x == cur : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT b . append ( cnt ) NEW_LINE cnt = 1 NEW_LINE cur = x NEW_LINE DEDENT DEDENT b . append ( cnt ) NEW_LINE res = 0 NEW_LINE b . sort ( ) NEW_LINE for i in range ( len ( b ) ) : NEW_LINE INDENT if b [ i ] > b [ i ] : NEW_LINE INDENT res += 1 NEW_LINE DEDENT else : NEW_LINE INDENT res += b [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT t = int ( raw_input ( ) ) NEW_LINE for t in range ( t ) : NEW_LINE INDENT print \" Case ▁ # % d : ▁ % d \" % ( t + 1 , solve ( a ) ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE def solve ( n , s ) : NEW_LINE INDENT cnt = 0 NEW_LINE while n > 0 : NEW_LINE INDENT m = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if s [ i ] < s [ m ] : NEW_LINE INDENT m = i NEW_LINE DEDENT DEDENT cnt += min ( m , n - 1 - m ) NEW_LINE n = n - 1 NEW_LINE del s [ m ] NEW_LINE DEDENT return cnt NEW_LINE DEDENT t = int ( sys . stdin . readline ( ) ) NEW_LINE for test_case in range ( 1 , t + 1 ) : NEW_LINE INDENT n = int ( sys . stdin . readline ( ) ) NEW_LINE s = [ int ( y ) for y in sys . stdin . readline ( ) . split ( ) ] NEW_LINE print ( ' Case ▁ # % d : ▁ % d ' % ( test_case , solve ( n , s ) ) ) NEW_LINE DEDENT","from __future__ import division NEW_LINE import sys NEW_LINE import math NEW_LINE from collections import deque NEW_LINE import itertools NEW_LINE sys . stdin = open ( ' large . in ' ) NEW_LINE sys . stdout = open ( ' large . out ' , ' w ' ) NEW_LINE def sequences ( integers ) : NEW_LINE INDENT integers = sorted ( integers ) NEW_LINE def sequences_rec ( ints ) : NEW_LINE INDENT if len ( ints ) == 1 : NEW_LINE INDENT yield ints NEW_LINE DEDENT else : NEW_LINE INDENT for s in sequences_rec ( ints [ 1 : ] ) : NEW_LINE INDENT yield ints [ : 1 ] + s NEW_LINE yield s + ints [ : 1 ] NEW_LINE DEDENT DEDENT DEDENT return sequences_rec ( integers ) NEW_LINE DEDENT def swaps ( before , after ) : NEW_LINE INDENT before = before [ : ] NEW_LINE n = 0 NEW_LINE for i , value in enumerate ( after ) : NEW_LINE INDENT while True : NEW_LINE INDENT i2 = before . index ( value ) NEW_LINE if i2 == i : NEW_LINE INDENT break NEW_LINE DEDENT before [ i2 - 1 ] , before [ i2 ] = before [ i2 ] , before [ i2 - 1 ] NEW_LINE n += 1 NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT def solve_bad ( integers ) : NEW_LINE INDENT return min ( swaps ( result , integers ) for result in sequences ( integers ) ) NEW_LINE DEDENT def solve ( integers ) : NEW_LINE INDENT start = 0 NEW_LINE end = len ( integers ) NEW_LINE swaps = 0 NEW_LINE while start != end : NEW_LINE INDENT m = min ( integers [ start : end ] ) NEW_LINE mi = integers . index ( m ) NEW_LINE to_start = mi - start NEW_LINE to_end = end - mi - 1 NEW_LINE if to_start <= to_end : NEW_LINE INDENT integers = integers [ : start ] + [ m ] + integers [ start : mi ] + integers [ mi + 1 : ] NEW_LINE start += 1 NEW_LINE swaps += to_start NEW_LINE DEDENT else : NEW_LINE INDENT integers = integers [ : mi ] + integers [ mi + 1 : end ] + [ m ] + integers [ end : ] NEW_LINE end -= 1 NEW_LINE swaps += to_end NEW_LINE DEDENT DEDENT return swaps NEW_LINE DEDENT t = int ( raw_input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( raw_input ( ) ) NEW_LINE integers = map ( int , raw_input ( ) . split ( ) ) NEW_LINE assert len ( integers ) == n NEW_LINE print \" Case ▁ # { } : ▁ { } \" . format ( i + 1 , solve ( integers ) ) NEW_LINE DEDENT","class BIT : NEW_LINE INDENT def __init__ ( self , n ) : NEW_LINE INDENT self . S = [ 0 ] * ( n + 1 ) NEW_LINE self . N = n NEW_LINE DEDENT def tot ( self , k ) : NEW_LINE INDENT i = k NEW_LINE a = 0 NEW_LINE while i > 0 : NEW_LINE INDENT a += self . S [ i ] NEW_LINE i -= ( i & - i ) NEW_LINE DEDENT return a NEW_LINE DEDENT def inc ( self , k , v ) : NEW_LINE INDENT i = k NEW_LINE while i <= self . N : NEW_LINE INDENT self . S [ i ] += v NEW_LINE i += ( i & - i ) NEW_LINE DEDENT DEDENT DEDENT def reader ( inFile ) : NEW_LINE INDENT dummy = inFile . getInts ( ) NEW_LINE return inFile . getInts ( ) NEW_LINE DEDENT from fractions import gcd NEW_LINE def solver ( nums ) : NEW_LINE INDENT sn = sorted ( nums ) NEW_LINE n = len ( nums ) NEW_LINE nl = { sn [ i ] : i for i in xrange ( n ) } NEW_LINE nums = [ nl [ i ] for i in nums ] NEW_LINE nl = { nums [ i ] : i + 1 for i in xrange ( n ) } NEW_LINE bit = BIT ( n ) NEW_LINE print n NEW_LINE for i in xrange ( n ) : NEW_LINE INDENT bit . inc ( i + 1 , 1 ) NEW_LINE DEDENT lower = 1 NEW_LINE upper = n NEW_LINE tot = 0 NEW_LINE for i in xrange ( n ) : NEW_LINE INDENT v = nl [ i ] NEW_LINE cur = bit . tot ( v ) NEW_LINE if ( cur - lower ) > ( upper - cur ) : NEW_LINE INDENT tot += upper - cur NEW_LINE bit . inc ( v + 1 , - 1 ) NEW_LINE upper -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT tot += cur - lower NEW_LINE bit . inc ( 1 , 1 ) NEW_LINE bit . inc ( v , - 1 ) NEW_LINE lower += 1 NEW_LINE DEDENT DEDENT return tot NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT from GCJ import GCJ NEW_LINE GCJ ( reader , solver , \" \/ Users \/ luke \/ gcj \/ 2014\/2 \/ b \/ \" , \" b \" ) . run ( ) NEW_LINE DEDENT"],"bleu":0.5132037617227443,"rouge_l":0.5185533605100868}
{"id":152,"predictions":["import sys NEW_LINE def foo ( ifile ) : NEW_LINE INDENT a = [ int ( x ) for x in ifile . readline ( ) . split ( ) ] [ 1 : ] NEW_LINE a . sort ( ) NEW_LINE if len ( a ) == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT b = [ ] NEW_LINE for i in range ( 1 , len ( b ) ) : NEW_LINE INDENT v = [ ] NEW_LINE for v in a : NEW_LINE INDENT if v [ i ] != 0 : NEW_LINE INDENT v [ i ] = v [ i ] NEW_LINE DEDENT DEDENT if len ( b ) > a : NEW_LINE INDENT b . append ( b [ i ] ) NEW_LINE b . append ( i ) NEW_LINE DEDENT DEDENT return a NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT f = open ( sys . argv [ 1 ] ) NEW_LINE T = int ( f . readline ( ) ) NEW_LINE for t in xrange ( 1 , T + 1 ) : NEW_LINE INDENT N = int ( f . readline ( ) ) NEW_LINE data = [ ] NEW_LINE for i in xrange ( N ) : NEW_LINE INDENT data . append ( [ int ( x ) for x in f . readline ( ) . split ( ) ] ) NEW_LINE DEDENT pairs = [ ] NEW_LINE for i in xrange ( N ) : NEW_LINE INDENT pairs . append ( ( i , pairs ) ) NEW_LINE DEDENT pairs = set ( ) NEW_LINE f . write ( ' Case ▁ # % d : ▁ % s ' % ( t , pairs ) ) NEW_LINE DEDENT print ' Case ▁ # % d : ▁ % s ' % ( t + 1 , res ) NEW_LINE DEDENT DEDENT"],"references":["inf = 2 * 10 ** 20 NEW_LINE def inv ( x ) : NEW_LINE INDENT return P - int ( x ) NEW_LINE DEDENT def xl ( l ) : NEW_LINE INDENT return xrange ( len ( l ) ) NEW_LINE DEDENT debug = False NEW_LINE for case in range ( input ( ) ) : NEW_LINE INDENT print \" Case ▁ # \" + str ( case + 1 ) + \" : \" , NEW_LINE P = input ( ) NEW_LINE need = map ( inv , raw_input ( ) . split ( ) ) NEW_LINE costs = [ ] NEW_LINE for i in xrange ( P ) : NEW_LINE INDENT costs = map ( int , raw_input ( ) . split ( ) ) + costs NEW_LINE DEDENT v = [ [ inf for i in xrange ( P + 1 ) ] for j in xrange ( 2 ** ( P + 1 ) - 1 ) ] NEW_LINE if debug : print len ( v ) , 2 ** ( P + 1 ) - 1 , 2 ** P NEW_LINE leaves = 2 ** P - 1 NEW_LINE for ( i , x ) in enumerate ( need ) : NEW_LINE INDENT for j in xrange ( x , P + 1 ) : NEW_LINE INDENT v [ leaves + i ] [ j ] = 0 NEW_LINE DEDENT DEDENT for n in xrange ( leaves - 1 , - 1 , - 1 ) : NEW_LINE INDENT if debug : print n , 2 * n + 1 , 2 * n + 2 NEW_LINE for i in xrange ( P + 1 ) : NEW_LINE INDENT if i == P : NEW_LINE INDENT buy = inf NEW_LINE DEDENT else : NEW_LINE INDENT buy = v [ 2 * n + 1 ] [ i + 1 ] + v [ 2 * n + 2 ] [ i + 1 ] + costs [ n ] NEW_LINE DEDENT skip = v [ 2 * n + 1 ] [ i ] + v [ 2 * n + 2 ] [ i ] NEW_LINE v [ n ] [ i ] = min ( buy , skip ) NEW_LINE DEDENT DEDENT print v [ 0 ] [ 0 ] NEW_LINE if debug : NEW_LINE INDENT print costs NEW_LINE for ( i , x ) in enumerate ( v ) : print i , x NEW_LINE DEDENT DEDENT","from sys import stdin NEW_LINE def main ( ) : NEW_LINE INDENT p = int ( stdin . readline ( ) ) NEW_LINE m = map ( int , stdin . readline ( ) . split ( ) ) NEW_LINE m . reverse ( ) NEW_LINE c = [ ] NEW_LINE for i in xrange ( p ) : NEW_LINE INDENT c += map ( int , stdin . readline ( ) . split ( ) ) NEW_LINE DEDENT c . reverse ( ) NEW_LINE n = 2 ** p NEW_LINE v = [ None ] * ( 2 * n - 1 ) NEW_LINE for i in xrange ( n - 1 , 2 * n - 1 ) : NEW_LINE INDENT v [ i ] = ( [ 0 ] * ( m [ i - n + 1 ] + 1 ) ) NEW_LINE DEDENT for i in xrange ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT vl = v [ 2 * i + 1 ] NEW_LINE vr = v [ 2 * i + 2 ] NEW_LINE vv = [ 0 ] * min ( len ( vl ) , len ( vr ) ) NEW_LINE for j in range ( len ( vv ) ) : NEW_LINE INDENT vv [ j ] = vl [ j ] + vr [ j ] + c [ i ] NEW_LINE DEDENT for j in range ( len ( vv ) - 1 ) : NEW_LINE INDENT vv [ j ] = min ( vl [ j + 1 ] + vr [ j + 1 ] , vv [ j ] ) NEW_LINE DEDENT v [ i ] = vv NEW_LINE DEDENT return str ( v [ 0 ] [ 0 ] ) NEW_LINE DEDENT tno = int ( stdin . readline ( ) ) NEW_LINE for i in xrange ( 0 , tno ) : NEW_LINE INDENT print \" Case ▁ # % d : ▁ % s \" % ( i + 1 , main ( ) ) NEW_LINE DEDENT","import sys NEW_LINE import re NEW_LINE from subprocess import Popen , PIPE , STDOUT NEW_LINE stdin = sys . stdin NEW_LINE cases = int ( stdin . readline ( ) ) NEW_LINE solved_re = re . compile ( r ' . * Value ▁ of ▁ objective ▁ function : ▁ ( [0-9 . e + ] + ) $ ' ) NEW_LINE for case in range ( 1 , cases + 1 ) : NEW_LINE INDENT p = int ( stdin . readline ( ) ) NEW_LINE misses = [ p - int ( x ) for x in stdin . readline ( ) . split ( ) ] NEW_LINE assert len ( misses ) == 1 << p NEW_LINE rounds = [ ] NEW_LINE lp = ' min : \\n ' NEW_LINE for i in range ( p ) : NEW_LINE INDENT r = [ int ( x ) for x in stdin . readline ( ) . split ( ) ] NEW_LINE rounds . append ( r ) NEW_LINE for j , cost in enumerate ( r ) : NEW_LINE INDENT lp += ' \\t % d ▁ * ▁ r % d % d ▁ + ▁ \\n ' % ( cost , i , j ) NEW_LINE DEDENT DEDENT lp += ' \\t0 ; \\n \\n ' NEW_LINE for i in range ( 1 << p ) : NEW_LINE INDENT v = i NEW_LINE for j in range ( len ( rounds ) ) : NEW_LINE INDENT v >>= 1 NEW_LINE lp += ' r % d % d ▁ + ▁ ' % ( j , v ) NEW_LINE DEDENT lp += '0 ▁ > = ▁ % d ; \\n ' % misses [ i ] NEW_LINE DEDENT lp += ' \\n \\n ' NEW_LINE for i , r in enumerate ( rounds ) : NEW_LINE INDENT for j in range ( len ( r ) ) : NEW_LINE INDENT lp += ' r % d % d ▁ > = ▁ 0 ; \\n ' % ( i , j ) NEW_LINE lp += ' r % d % d ▁ < = ▁ 1 ; \\n ' % ( i , j ) NEW_LINE DEDENT DEDENT for i , r in enumerate ( rounds ) : NEW_LINE INDENT for j in range ( len ( r ) ) : NEW_LINE INDENT lp += ' int ▁ r % d % d ; \\n ' % ( i , j ) NEW_LINE DEDENT DEDENT result = Popen ( [ ' lp _ solve ' , ' - S1' ] , stdin = PIPE , stdout = PIPE , stderr = STDOUT ) . communicate ( lp ) [ 0 ] NEW_LINE g = solved_re . search ( result ) NEW_LINE assert g is not None NEW_LINE print ' Case ▁ # % d : ▁ % d ' % ( case , int ( round ( float ( g . group ( 1 ) ) ) ) ) NEW_LINE DEDENT"],"bleu":0.4302000958268967,"rouge_l":0.4151116844976733}
{"id":153,"predictions":["from math import * NEW_LINE T = int ( raw_input ( ) ) NEW_LINE for t in xrange ( 1 , T + 1 ) : NEW_LINE INDENT P , Q , R = map ( int , raw_input ( ) . split ( ) ) NEW_LINE P = map ( int , raw_input ( ) . split ( ) ) NEW_LINE def gcd ( p , q ) : NEW_LINE INDENT if p * q == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT def gcd ( p , q ) : NEW_LINE INDENT if p % q == 0 : NEW_LINE INDENT return q \/\/ gcd ( p , q ) NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( q , q \/ x ) NEW_LINE DEDENT DEDENT print \" Case ▁ # { } : ▁ { } \" . format ( t ) NEW_LINE DEDENT"],"references":["import functools NEW_LINE import multiprocessing NEW_LINE import fractions NEW_LINE def pow2 ( x ) : NEW_LINE INDENT return x != 0 and ( ( x & ( x - 1 ) ) == 0 ) NEW_LINE DEDENT def solve ( cs , f ) : NEW_LINE INDENT if not pow2 ( f . denominator ) : NEW_LINE INDENT return cs , ' impossible ' NEW_LINE DEDENT ret = 1 NEW_LINE while f < fractions . Fraction ( 1 , 2 ) : NEW_LINE INDENT ret += 1 NEW_LINE f *= 2 NEW_LINE DEDENT return cs , ret NEW_LINE DEDENT def reducer ( l , result ) : NEW_LINE INDENT l . append ( result ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT T = int ( input ( ) ) NEW_LINE l = [ ] NEW_LINE with multiprocessing . Pool ( processes = 8 ) as pool : NEW_LINE INDENT for cs in range ( T ) : NEW_LINE INDENT f = fractions . Fraction ( input ( ) ) NEW_LINE solve ( cs , f ) NEW_LINE pool . apply_async ( solve , args = ( cs + 1 , f , ) , callback = functools . partial ( reducer , l ) ) NEW_LINE DEDENT pool . close ( ) NEW_LINE pool . join ( ) NEW_LINE DEDENT for cs , result in sorted ( l , key = lambda x : x [ 0 ] ) : NEW_LINE INDENT print ( ' Case ▁ # { } : ▁ { } ' . format ( cs , result ) ) NEW_LINE DEDENT DEDENT","import sys NEW_LINE from fractions import gcd NEW_LINE def debug ( * args ) : NEW_LINE INDENT print ( * args , file = sys . stderr ) NEW_LINE DEDENT fin = sys . stdin NEW_LINE T = int ( fin . readline ( ) ) NEW_LINE for case in range ( 1 , T + 1 ) : NEW_LINE INDENT p , q = map ( int , fin . readline ( ) . split ( ' \/ ' ) ) NEW_LINE g = gcd ( p , q ) NEW_LINE p \/\/= g NEW_LINE q \/\/= g NEW_LINE result = None NEW_LINE if p > q : NEW_LINE INDENT result = \" impossible \" NEW_LINE DEDENT else : NEW_LINE INDENT is_power = None NEW_LINE for i in range ( 0 , 41 ) : NEW_LINE INDENT power = 2 ** i NEW_LINE if q == power : NEW_LINE INDENT is_power = power NEW_LINE DEDENT DEDENT if is_power is None : NEW_LINE INDENT result = \" impossible \" NEW_LINE DEDENT else : NEW_LINE INDENT result = \" broken \" NEW_LINE for i in range ( 1 , 41 ) : NEW_LINE INDENT qq = 2 ** i NEW_LINE if p * qq >= q : NEW_LINE INDENT result = str ( i ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( \" Case ▁ # % d : ▁ % s \" % ( case , result ) ) NEW_LINE DEDENT","T = int ( raw_input ( ) ) NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT r = a % b NEW_LINE if r == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( b , r ) NEW_LINE DEDENT DEDENT def p2 ( x ) : NEW_LINE INDENT if x == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 * p2 ( x - 1 ) NEW_LINE DEDENT DEDENT for t in range ( T ) : NEW_LINE INDENT inpArr = raw_input ( ) . strip ( ) . split ( ' \/ ' ) NEW_LINE P = int ( inpArr [ 0 ] ) NEW_LINE Q = int ( inpArr [ 1 ] ) NEW_LINE g = gcd ( P , Q ) NEW_LINE P \/= g NEW_LINE Q \/= g NEW_LINE if ( P * p2 ( 40 ) ) % Q == 0 : NEW_LINE INDENT gen = 0 NEW_LINE while P < Q : NEW_LINE INDENT gen += 1 NEW_LINE P *= 2 NEW_LINE DEDENT print ( \" Case ▁ # \" + str ( t + 1 ) + \" : ▁ \" + str ( gen ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Case ▁ # \" + str ( t + 1 ) + \" : ▁ impossible \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.37068698744658723,"rouge_l":0.4602688045272341}
{"id":154,"predictions":["def check ( num , g , l ) : NEW_LINE INDENT if g < 0 or g > l : NEW_LINE INDENT return \" Bad \" NEW_LINE DEDENT return \" Bad \" NEW_LINE DEDENT l = [ ] NEW_LINE for x in xrange ( input ( ) ) : NEW_LINE INDENT n , m = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE p = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE if p != 100 : NEW_LINE INDENT print \" Case ▁ # \" + str ( x ) + \" : ▁ \" + str ( n ) + 1 NEW_LINE DEDENT else : NEW_LINE INDENT print \" Impossible \" NEW_LINE DEDENT DEDENT"],"references":["import sys , time NEW_LINE start_time = time . time ( ) NEW_LINE try : NEW_LINE INDENT if len ( sys . argv ) > 1 : NEW_LINE INDENT inname = sys . argv [ 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT inname = input ( \" Enter ▁ input ▁ filename : ▁ \" ) NEW_LINE DEDENT assert inname . endswith ( ' . in ' ) NEW_LINE outname = inname . replace ( ' . in ' , ' . out ' ) NEW_LINE with open ( inname ) as fin : NEW_LINE INDENT with open ( outname , ' w ' ) as fout : NEW_LINE INDENT num_cases = int ( fin . readline ( ) ) NEW_LINE for case_idx in range ( 1 , 1 + num_cases ) : NEW_LINE INDENT if time . time ( ) >= start_time + 5 : NEW_LINE INDENT print ( \" [ = = ▁ Case ▁ % d ▁ of ▁ % d ▁ = = ] \" % ( case_idx , num_cases ) ) NEW_LINE DEDENT N , pD , pG = [ int ( x ) for x in fin . readline ( ) . split ( ) ] NEW_LINE answer = True NEW_LINE N = min ( N , 100 ) NEW_LINE if pG == 100 and pD != 100 : answer = False NEW_LINE if pG == 0 and pD != 0 : answer = False NEW_LINE if all ( ( pD * D ) % 100 for D in range ( 1 , 1 + N ) ) : answer = False NEW_LINE print ( \" Case ▁ # { } : ▁ { } \" . format ( case_idx , ' Possible ' if answer else ' Broken ' ) , file = fout ) NEW_LINE DEDENT DEDENT DEDENT DEDENT except : NEW_LINE INDENT import traceback NEW_LINE print ( \" Exception ▁ caught : \" , file = sys . stderr ) NEW_LINE print ( ' - ' * 60 , file = sys . stderr ) NEW_LINE traceback . print_exc ( file = sys . stderr ) NEW_LINE print ( ' - ' * 60 , file = sys . stderr ) NEW_LINE input ( \" Press ▁ Enter ▁ to ▁ close \" ) NEW_LINE DEDENT else : NEW_LINE INDENT total_time = time . time ( ) - start_time NEW_LINE print ( \" Completed ▁ in ▁ % .1f ▁ seconds \" % total_time , file = sys . stderr ) NEW_LINE time . sleep ( 3 ) NEW_LINE DEDENT","gcds = { } NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT end = max ( a , b ) NEW_LINE sor = min ( a , b ) NEW_LINE if end in gcds : NEW_LINE INDENT if sor in gcds [ end ] : NEW_LINE INDENT return gcds [ end ] [ sor ] NEW_LINE DEDENT DEDENT rem = end % sor NEW_LINE if rem == 0 : NEW_LINE INDENT if end not in gcds : NEW_LINE INDENT gcds [ end ] = { } NEW_LINE DEDENT gcds [ end ] [ sor ] = sor NEW_LINE return sor NEW_LINE DEDENT else : NEW_LINE INDENT answer = gcd ( sor , rem ) NEW_LINE if end not in gcds : NEW_LINE INDENT gcds [ end ] = { } NEW_LINE DEDENT gcds [ end ] [ sor ] = answer NEW_LINE return answer NEW_LINE DEDENT DEDENT def solver ( n , pd , pg ) : NEW_LINE INDENT if pd == 0 : NEW_LINE INDENT if pg == 100 : NEW_LINE INDENT return \" Broken \" NEW_LINE DEDENT else : NEW_LINE INDENT return \" Possible \" NEW_LINE DEDENT DEDENT if pg == 0 : NEW_LINE INDENT if pd == 0 : NEW_LINE INDENT return \" Possible \" NEW_LINE DEDENT else : NEW_LINE INDENT return \" Broken \" NEW_LINE DEDENT DEDENT min_played = 100 \/ gcd ( pd , 100 ) NEW_LINE if min_played > n : NEW_LINE INDENT return \" Broken \" NEW_LINE DEDENT if pg == 100 and not pd == 100 : NEW_LINE INDENT return \" Broken \" NEW_LINE DEDENT return \" Possible \" NEW_LINE DEDENT def ssi ( s ) : NEW_LINE INDENT return map ( int , s . strip ( ' \\n ' ) . split ( ) ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT input_file = open ( ' infile . txt ' ) NEW_LINE cases = int ( input_file . readline ( ) ) NEW_LINE output = [ ] NEW_LINE for c in range ( cases ) : NEW_LINE INDENT [ n , pd , pg ] = ssi ( input_file . readline ( ) ) NEW_LINE answer = solver ( n , pd , pg ) NEW_LINE output . append ( ' Case ▁ # % d : ▁ % s \\n ' % ( c + 1 , str ( answer ) ) ) NEW_LINE DEDENT input_file . close ( ) NEW_LINE output_file = open ( ' outfile . txt ' , ' w ' ) NEW_LINE output_file . writelines ( output ) NEW_LINE output_file . close ( ) NEW_LINE print ' Done ! ' NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT","def whole_num ( frac ) : NEW_LINE INDENT a = int ( frac * 100 ) NEW_LINE from_100 = 1 NEW_LINE for i in range ( 2 ) : NEW_LINE INDENT if a % 2 == 0 : NEW_LINE INDENT a \/= 2 NEW_LINE from_100 *= 2 NEW_LINE DEDENT if a % 5 == 0 : NEW_LINE INDENT a \/= 5 NEW_LINE from_100 *= 5 NEW_LINE DEDENT DEDENT return 100 \/ from_100 NEW_LINE DEDENT def possible ( n , pd , pg ) : NEW_LINE INDENT if pg == 0 : NEW_LINE INDENT return pd == 0 NEW_LINE DEDENT if pg == 100 : NEW_LINE INDENT return pd == 100 NEW_LINE DEDENT pd = float ( pd ) \/ 100 NEW_LINE pg = float ( pg ) \/ 100 NEW_LINE a , b = map ( whole_num , ( pd , pg ) ) NEW_LINE return a <= n NEW_LINE DEDENT def solve ( case ) : NEW_LINE INDENT n , pd , pg = map ( int , case . strip ( ) . split ( ) ) NEW_LINE solution = ' Broken ' NEW_LINE if possible ( n , pd , pg ) : NEW_LINE INDENT solution = ' Possible ' NEW_LINE DEDENT return solution NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT T = int ( raw_input ( ) ) NEW_LINE for i in range ( 1 , T + 1 ) : NEW_LINE INDENT sol = solve ( raw_input ( ) ) NEW_LINE print \" Case ▁ # % d : ▁ % s \" % ( i , sol ) NEW_LINE DEDENT DEDENT"],"bleu":0.1532347139104631,"rouge_l":0.3083837285185991}
{"id":155,"predictions":["import sys NEW_LINE N = int ( sys . stdin . readline ( ) ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT D , h , m = [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE H = 1000000 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if H [ i ] > H [ i ] : NEW_LINE INDENT H [ i ] = max ( 0 , H [ i ] ) NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i , N ) : NEW_LINE INDENT if H [ j ] > 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if H [ j ] > h : NEW_LINE INDENT break NEW_LINE DEDENT H [ j ] = H [ j ] NEW_LINE DEDENT ans = 10 ** 18 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if H [ j ] > 0 : NEW_LINE INDENT if H [ j ] > 0 : NEW_LINE INDENT ans = min ( ans , j ) NEW_LINE DEDENT DEDENT DEDENT if ans : NEW_LINE INDENT DEDENT DEDENT print \" Case ▁ # % d : ▁ % s \" % ( i + 1 , ans ) NEW_LINE DEDENT"],"references":["import os , sys , time , random NEW_LINE time . clock ( ) NEW_LINE sys . stdin = open ( ' C - small - 1 - attempt0 . in ' ) NEW_LINE sys . stdout = open ( ' C - small - 1 - attempt0 . out ' , ' w ' ) NEW_LINE def Work ( ) : NEW_LINE INDENT n = int ( input ( ) . strip ( ) ) NEW_LINE sb = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT d , h , m = map ( int , input ( ) . strip ( ) . split ( ) ) NEW_LINE for j in range ( h ) : NEW_LINE INDENT sb . append ( ( d , 360 \/ ( m + j ) ) ) NEW_LINE DEDENT DEDENT sb . sort ( key = lambda d : d [ - 1 ] , reverse = True ) NEW_LINE if sb [ 0 ] [ 1 ] == sb [ 1 ] [ 1 ] : return 0 NEW_LINE ar1 = ( 360 - sb [ 1 ] [ 0 ] ) \/ sb [ 1 ] [ 1 ] NEW_LINE meet = ( 360 + sb [ 1 ] [ 0 ] - sb [ 0 ] [ 0 ] ) \/ ( sb [ 0 ] [ 1 ] - sb [ 1 ] [ 1 ] ) NEW_LINE if meet <= ar1 + 1e-8 : return 1 NEW_LINE return 0 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT T = int ( input ( ) ) NEW_LINE for i in range ( T ) : NEW_LINE INDENT print ( ' Case ▁ # % d : ▁ % d ' % ( i + 1 , Work ( ) ) ) NEW_LINE DEDENT sys . stderr . write ( ' completed ▁ % .3f \\n ' % time . clock ( ) ) NEW_LINE DEDENT","import sys NEW_LINE infile = None NEW_LINE outfile = None NEW_LINE def readline ( ) : NEW_LINE INDENT x = infile . readline ( ) NEW_LINE if len ( x ) > 0 and x [ - 1 ] == ' \\n ' : NEW_LINE INDENT return x [ : - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT return x NEW_LINE DEDENT DEDENT def readint ( ) : NEW_LINE INDENT return int ( readline ( ) ) NEW_LINE DEDENT def readfloat ( ) : NEW_LINE INDENT return float ( readline ( ) ) NEW_LINE DEDENT def readints ( ) : NEW_LINE INDENT return [ int ( x ) for x in readline ( ) . split ( ) ] NEW_LINE DEDENT def readfloats ( ) : NEW_LINE INDENT return [ float ( x ) for x in readline ( ) . split ( ) ] NEW_LINE DEDENT def writeline ( x ) : NEW_LINE INDENT outfile . write ( x + ' \\n ' ) NEW_LINE DEDENT def writecase ( casenum , answer ) : NEW_LINE INDENT outfile . write ( ' Case ▁ # { : d } : ▁ { } \\n ' . format ( casenum , answer ) ) NEW_LINE DEDENT def run ( main ) : NEW_LINE INDENT global infile , outfile NEW_LINE args = sys . argv NEW_LINE infile = sys . stdin NEW_LINE outfile = sys . stdout NEW_LINE if len ( args ) == 2 : NEW_LINE INDENT if args [ 1 ] != ' - ' : NEW_LINE INDENT infile = open ( args [ 1 ] , ' r ' ) NEW_LINE if args [ 1 ] . endswith ( ' . in ' ) : NEW_LINE INDENT outfile = open ( args [ 1 ] [ : - 3 ] + ' . out ' , ' w ' ) NEW_LINE DEDENT DEDENT DEDENT elif len ( args ) == 3 : NEW_LINE INDENT if args [ 1 ] != ' - ' : NEW_LINE INDENT infile = open ( args [ 1 ] , ' r ' ) NEW_LINE DEDENT if args [ 2 ] != ' - ' : NEW_LINE INDENT outfile = open ( args [ 2 ] , ' w ' ) NEW_LINE DEDENT DEDENT elif len ( args ) > 3 : NEW_LINE INDENT print ( \" Expected ▁ 0 , ▁ 1 , ▁ or ▁ 2 ▁ arguments , ▁ not ▁ { } \" . format ( len ( args ) - 1 ) ) NEW_LINE print ( args ) NEW_LINE return NEW_LINE DEDENT t = readint ( ) NEW_LINE for casenum in range ( 1 , t + 1 ) : NEW_LINE INDENT main ( casenum ) NEW_LINE DEDENT if infile is not sys . stdin : NEW_LINE INDENT infile . close ( ) NEW_LINE DEDENT if outfile is not sys . stdout : NEW_LINE INDENT outfile . close ( ) NEW_LINE DEDENT DEDENT","from sys import stdin , stdout , stderr NEW_LINE import heapq NEW_LINE def solve ( N , hikers ) : NEW_LINE INDENT N = len ( hikers ) NEW_LINE D = [ h [ 0 ] for h in hikers ] NEW_LINE M = [ h [ 1 ] for h in hikers ] NEW_LINE intersects = [ ( ( 360 - D [ i ] ) * M [ i ] , M [ i ] , i ) for i in range ( N ) ] NEW_LINE heapq . heapify ( intersects ) NEW_LINE best = N NEW_LINE current = best NEW_LINE seen = set ( ) NEW_LINE while current <= 2 * N : NEW_LINE INDENT ( m , M , i ) = heapq . heappop ( intersects ) NEW_LINE if i not in seen : NEW_LINE INDENT current -= 1 NEW_LINE best = min ( best , current ) NEW_LINE seen . add ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT current += 1 NEW_LINE DEDENT heapq . heappush ( intersects , ( m + M * 360 , M , i ) ) NEW_LINE DEDENT return best NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT T = int ( input ( ) ) NEW_LINE for case in range ( 1 , T + 1 ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE hikers = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT D , H , M = map ( int , input ( ) . split ( ) ) NEW_LINE for j in range ( H ) : NEW_LINE INDENT hikers . append ( ( D , M + j ) ) NEW_LINE DEDENT DEDENT answer = solve ( N , hikers ) NEW_LINE print ( \" Case ▁ # % d : ▁ % s \" % ( case , answer ) ) NEW_LINE DEDENT DEDENT main ( ) NEW_LINE"],"bleu":0.33668587064938105,"rouge_l":0.37918066683897644}
{"id":156,"predictions":["import sys NEW_LINE def load_case ( path ) : NEW_LINE INDENT case_list = [ ] NEW_LINE with open ( path , ' r ' ) as fh : NEW_LINE INDENT case_num = int ( fh . readline ( ) . strip ( \" \\n \" ) ) NEW_LINE for i in range ( 0 , case_num ) : NEW_LINE INDENT case = [ ] NEW_LINE s_max , digits = filter ( None , fh . readline ( ) . split ( \" ▁ \" ) ) NEW_LINE s_max = int ( s_max ) NEW_LINE for j in range ( 0 , s_max + 1 ) : NEW_LINE INDENT case . append ( ord ( digits [ j ] ) - ord ( \"0\" ) ) NEW_LINE DEDENT case_list . append ( case ) NEW_LINE DEDENT DEDENT return case_list NEW_LINE DEDENT def calculate_case ( case ) : NEW_LINE INDENT people_num = 0 NEW_LINE num_to_invite = 0 NEW_LINE for k in range ( 0 , len ( case ) ) : NEW_LINE INDENT new_invite = k - people_num NEW_LINE new_invite = new_invite if new_invite > 0 else False NEW_LINE num_to_invite += new_invite NEW_LINE people_num += ( case [ k ] + new_invite ) NEW_LINE DEDENT return num_to_invite NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT if len ( sys . argv ) != 3 : NEW_LINE INDENT print \" Case ▁ # { } : ▁ { } \" . format ( case , num_list ) NEW_LINE DEDENT DEDENT"],"references":["import sys NEW_LINE def sheep ( N ) : NEW_LINE INDENT if N == 0 : return \" INSOMNIA \" NEW_LINE d = 0 ; t = N NEW_LINE while 1 : NEW_LINE INDENT for x in str ( t ) : d |= 1 << int ( x ) NEW_LINE if d == 1023 : return t NEW_LINE t += N NEW_LINE DEDENT DEDENT case = 0 NEW_LINE for x in sys . stdin : NEW_LINE INDENT if case > 0 : NEW_LINE INDENT N = int ( x . strip ( ) ) NEW_LINE print \" Case ▁ # % d : \" % case , sheep ( N ) NEW_LINE DEDENT case += 1 NEW_LINE DEDENT","limit = 1000000 NEW_LINE with open ( ' \/ home \/ gauravjs \/ Documents \/ Google ▁ Code ▁ Jam \/ 2016Q \/ A - large . in ' , ' r ' ) as f : NEW_LINE INDENT cases = int ( f . readline ( ) ) NEW_LINE lines = f . readlines ( ) NEW_LINE DEDENT inputs = [ ] NEW_LINE for i in range ( cases ) : NEW_LINE INDENT n = int ( lines [ i ] ) NEW_LINE m = n NEW_LINE digits = set ( ) NEW_LINE while ( m < n * limit ) and len ( digits ) < 10 : NEW_LINE INDENT q = m NEW_LINE while q > 0 : NEW_LINE INDENT digits . add ( q % 10 ) NEW_LINE q = q \/ 10 NEW_LINE DEDENT m += n NEW_LINE DEDENT if len ( digits ) == 10 : NEW_LINE INDENT print \" Case ▁ # \" + str ( i + 1 ) + \" : ▁ \" + str ( m - n ) NEW_LINE DEDENT else : NEW_LINE INDENT print \" Case ▁ # \" + str ( i + 1 ) + \" : ▁ INSOMNIA \" NEW_LINE DEDENT DEDENT","import os , inspect NEW_LINE problemName = ' counting _ sheep ' NEW_LINE runOnRealData = False NEW_LINE def digits ( N ) : NEW_LINE INDENT return set ( map ( int , str ( N ) ) ) NEW_LINE DEDENT def solution ( N ) : NEW_LINE INDENT if N == 0 : NEW_LINE INDENT return ' INSOMNIA ' NEW_LINE DEDENT allDigits = set ( range ( 10 ) ) NEW_LINE multiple = 0 NEW_LINE while len ( allDigits ) > 0 : NEW_LINE INDENT multiple += N NEW_LINE allDigits = allDigits . difference ( digits ( multiple ) ) NEW_LINE DEDENT return multiple NEW_LINE DEDENT currentDir = os . path . dirname ( os . path . abspath ( inspect . getfile ( inspect . currentframe ( ) ) ) ) NEW_LINE inputString = ' A - large . in ' NEW_LINE outputString = problemName + ' _ output ' NEW_LINE inFile = os . path . join ( currentDir , ' inputfiles ' , inputString ) NEW_LINE outFile = os . path . join ( currentDir , ' outputfiles ' , ' % s . txt ' % outputString ) NEW_LINE if os . path . exists ( outFile ) : NEW_LINE INDENT os . remove ( outFile ) NEW_LINE DEDENT with open ( inFile , ' r ' ) as inputfile : NEW_LINE INDENT numberOfCases = int ( inputfile . readline ( ) ) NEW_LINE for case in xrange ( 1 , numberOfCases + 1 ) : NEW_LINE INDENT N = int ( inputfile . readline ( ) ) NEW_LINE result = solution ( N ) NEW_LINE with open ( outFile , ' a ' ) as f : NEW_LINE INDENT f . write ( ' Case ▁ # % d : ▁ % s \\n ' % ( case , str ( result ) ) ) NEW_LINE DEDENT DEDENT DEDENT"],"bleu":0.2966000079621371,"rouge_l":0.43440567235346933}
{"id":157,"predictions":["def solve ( ) : NEW_LINE INDENT n , m = [ int ( x ) for x in raw_input ( ) . split ( ) ] NEW_LINE a = [ int ( x ) for x in raw_input ( ) . split ( ) ] NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] = [ int ( x ) for x in raw_input ( ) . split ( ) ] NEW_LINE res = max ( res , i - res ) NEW_LINE DEDENT print \" Case ▁ # { } : ▁ { } \" . format ( i , res ) NEW_LINE DEDENT"],"references":["import collections NEW_LINE import sys NEW_LINE if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT f = sys . stdin NEW_LINE if len ( sys . argv ) >= 2 : NEW_LINE INDENT fn = sys . argv [ 1 ] NEW_LINE if fn != ' - ' : NEW_LINE INDENT f = open ( fn ) NEW_LINE DEDENT DEDENT T = int ( f . readline ( ) ) NEW_LINE for _T in xrange ( T ) : NEW_LINE INDENT N , X = map ( int , f . readline ( ) . split ( ) ) NEW_LINE disks = map ( int , f . readline ( ) . split ( ) ) NEW_LINE assert len ( disks ) == N NEW_LINE disks . sort ( ) NEW_LINE disks = collections . deque ( disks ) NEW_LINE r = 0 NEW_LINE while disks : NEW_LINE INDENT x1 = disks . pop ( ) NEW_LINE if disks and x1 + disks [ 0 ] <= X : NEW_LINE INDENT disks . popleft ( ) NEW_LINE DEDENT r += 1 NEW_LINE DEDENT print \" Case ▁ # % d : ▁ % d \" % ( _T + 1 , r ) NEW_LINE DEDENT DEDENT","__author__ = ' Pavel ▁ Mavrin ' NEW_LINE fin = open ( \" A . in \" ) NEW_LINE fout = open ( \" A . out \" , \" w \" ) NEW_LINE test_num = int ( fin . readline ( ) ) NEW_LINE def solve_test ( ) : NEW_LINE INDENT n , x = [ int ( x ) for x in fin . readline ( ) . split ( ) ] NEW_LINE s = [ int ( x ) for x in fin . readline ( ) . split ( ) ] NEW_LINE s . sort ( ) NEW_LINE res = 0 NEW_LINE j = n - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while j > i and s [ i ] + s [ j ] > x : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT if j > i : NEW_LINE INDENT res += 1 NEW_LINE j -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return str ( res + ( n - 2 * res ) ) NEW_LINE DEDENT for test_i in range ( test_num ) : NEW_LINE INDENT s = \" Case ▁ # \" + str ( test_i + 1 ) + \" : ▁ \" + solve_test ( ) NEW_LINE print ( s ) NEW_LINE print ( s , file = fout ) NEW_LINE DEDENT fin . close ( ) NEW_LINE fout . close ( ) NEW_LINE","import sys NEW_LINE def rl ( T ) : NEW_LINE INDENT return list ( map ( T , input ( ) . split ( ) ) ) NEW_LINE DEDENT def solve ( X , S ) : NEW_LINE INDENT if len ( S ) == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if len ( S ) == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if S [ 0 ] + S [ - 1 ] <= X : NEW_LINE INDENT return 1 + solve ( X , S [ 1 : len ( S ) - 1 ] ) NEW_LINE DEDENT if S [ - 1 ] <= X : NEW_LINE INDENT return 1 + solve ( X , S [ 0 : len ( S ) - 1 ] ) NEW_LINE DEDENT raise Exception NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT sys . setrecursionlimit ( 100000 ) NEW_LINE T , = rl ( int ) NEW_LINE for C in range ( 1 , T + 1 ) : NEW_LINE INDENT N , X = rl ( int ) NEW_LINE S = rl ( int ) NEW_LINE S . sort ( ) NEW_LINE ans = solve ( X , S ) NEW_LINE print ( ' Case ▁ # % d : ▁ % d ' % ( C , ans ) ) NEW_LINE DEDENT pass NEW_LINE DEDENT main ( ) NEW_LINE"],"bleu":0.2422472329378151,"rouge_l":0.4254848587955087}
{"id":158,"predictions":["import sys NEW_LINE def c ( ) : NEW_LINE INDENT t = int ( sys . stdin . readline ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( sys . stdin . readline ( ) ) NEW_LINE arr = [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE arr = [ x for x in arr ] NEW_LINE c ( i ) = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i & 1 == 1 : NEW_LINE INDENT arr [ i ] = - 1 NEW_LINE DEDENT elif arr [ i ] > 0 : NEW_LINE INDENT arr [ i ] = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = arr [ i ] + 1 NEW_LINE DEDENT DEDENT print ( \" Case ▁ # { } : \" . format ( i + 1 , end = ' ▁ ' ) ) NEW_LINE DEDENT"],"references":["t = int ( raw_input ( ) ) NEW_LINE for cas in xrange ( 1 , t + 1 ) : NEW_LINE INDENT n = int ( raw_input ( ) ) NEW_LINE ct = dict ( zip ( xrange ( 1 , 2501 ) , [ 0 for i in xrange ( 1 , 2501 ) ] ) ) NEW_LINE for i in xrange ( 1 , 2 * n ) : NEW_LINE INDENT nums = map ( int , raw_input ( ) . split ( ) ) NEW_LINE for num in nums : NEW_LINE INDENT ct [ num ] += 1 NEW_LINE DEDENT DEDENT ans = [ ] NEW_LINE for i in ct : NEW_LINE INDENT if ct [ i ] % 2 == 1 : NEW_LINE INDENT ans . append ( i ) NEW_LINE DEDENT DEDENT ans . sort ( ) NEW_LINE ans = \" ▁ \" . join ( map ( str , ans ) ) NEW_LINE print \" Case ▁ # { } : ▁ { } \" . format ( cas , ans ) NEW_LINE DEDENT","import jam NEW_LINE import sys NEW_LINE sys . setrecursionlimit ( 10000 ) NEW_LINE def solve ( case ) : NEW_LINE INDENT N = case . readInt ( ) NEW_LINE lists = [ ] NEW_LINE for i in range ( 2 * N - 1 ) : NEW_LINE INDENT lists . append ( [ case . readInt ( ) for i2 in range ( N ) ] ) NEW_LINE DEDENT count = { } NEW_LINE for q in lists : NEW_LINE INDENT for h in q : NEW_LINE INDENT if h in count : NEW_LINE INDENT count [ h ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count [ h ] = 1 NEW_LINE DEDENT DEDENT DEDENT result = [ ] NEW_LINE for h in count : NEW_LINE INDENT if count [ h ] % 2 == 1 : NEW_LINE INDENT result . append ( h ) NEW_LINE DEDENT DEDENT result . sort ( ) NEW_LINE return \" ▁ \" . join ( str ( h ) for h in result ) NEW_LINE DEDENT jam . run ( \" B - large . in \" , solve ) NEW_LINE","task = ' B ' NEW_LINE type = 2 NEW_LINE from collections import Counter NEW_LINE if type == 0 : NEW_LINE INDENT inp = open ( ' sample . in ' , ' r ' ) NEW_LINE DEDENT elif type == 1 : NEW_LINE INDENT inp = open ( ' % s - small . in ' % ( task , ) ) NEW_LINE DEDENT else : NEW_LINE INDENT inp = open ( ' % s - large . in ' % ( task ) , ) NEW_LINE DEDENT outp = open ( ' % s . out ' % ( task , ) , ' w ' ) NEW_LINE T = int ( inp . readline ( ) [ : - 1 ] ) NEW_LINE for i in range ( T ) : NEW_LINE INDENT ans = [ ] NEW_LINE N = int ( inp . readline ( ) [ : - 1 ] ) NEW_LINE c = Counter ( ) NEW_LINE for j in range ( 2 * N - 1 ) : NEW_LINE INDENT s = inp . readline ( ) [ : - 1 ] . split ( ) NEW_LINE for k in s : NEW_LINE INDENT c [ k ] += 1 NEW_LINE DEDENT DEDENT for val in c . items ( ) : NEW_LINE INDENT if val [ 1 ] % 2 == 1 : NEW_LINE INDENT ans . append ( val [ 0 ] ) NEW_LINE DEDENT DEDENT ans . sort ( key = int ) NEW_LINE outp . write ( \" Case ▁ # % s : ▁ % s \\n \" % ( i + 1 , \" ▁ \" . join ( ans ) ) ) NEW_LINE DEDENT"],"bleu":0.45452180338848724,"rouge_l":0.4854011441845522}
{"id":159,"predictions":["def solve ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = map ( int , input ( ) . split ( ) ) NEW_LINE mx = max ( l , r ) NEW_LINE if mx < n : return \" NO \" NEW_LINE if 2 * mx > 2 * m : NEW_LINE INDENT return \" YES \" NEW_LINE DEDENT else : NEW_LINE INDENT return \" NO \" NEW_LINE DEDENT DEDENT t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT s = map ( int , input ( ) . split ( ) ) NEW_LINE res = solve ( l , s ) NEW_LINE if solve ( res ) < t : NEW_LINE INDENT print ( \" Case ▁ # % d : ▁ % s \" % ( i + 1 , solve ( res ) ) NEW_LINE DEDENT else : NEW_LINE INDENT res = s NEW_LINE print \" Case ▁ # % d : ▁ % d \" % ( i + 1 , res ) NEW_LINE DEDENT DEDENT"],"references":["A = 3 NEW_LINE B = 1 NEW_LINE n = 1 NEW_LINE tmp = 0 NEW_LINE X = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] NEW_LINE Y = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] NEW_LINE while n < 31 : NEW_LINE INDENT X [ n ] = A NEW_LINE Y [ n ] = B NEW_LINE tmp = 3 * A + B * 5 NEW_LINE B = A + 3 * B NEW_LINE A = tmp NEW_LINE n = n + 1 NEW_LINE DEDENT d = 22360679774997896964091736687312762354406183596115257242708972454105209256378048 NEW_LINE N = input ( ) NEW_LINE n = 0 NEW_LINE while n < N : NEW_LINE INDENT n = n + 1 NEW_LINE f = input ( ) NEW_LINE p = X [ f ] + int ( Y [ f ] * d \/ 10000000000000000000000000000000000000000000000000000000000000000000000000000000 ) NEW_LINE print \" Case ▁ # % d : ▁ % .3d \" % ( n , int ( p ) % 1000 ) NEW_LINE DEDENT","from __future__ import division NEW_LINE from operator import itemgetter NEW_LINE from math import sqrt NEW_LINE from mpmath import * NEW_LINE def main ( ) : NEW_LINE INDENT entrada = open ( ' C - large . in ' , ' r ' ) NEW_LINE saida = open ( ' grade . out ' , ' w ' ) NEW_LINE casos = int ( entrada . readline ( ) ) NEW_LINE mp . dps = 100 NEW_LINE calculo = [ '143' , '751' , '935' , '607' , '903' , '991' , '335' , '047' , '943' , '471' , '055' , '447' , '463' , '991' , '095' , '607' , '263' , '151' , '855' , '527' , '743' , '351' , '135' , '407' , '903' , '791' , '135' , '647' , '343' , '471' , '455' , '847' , '263' , '191' , '095' , '807' , '463' , '551' , '455' , '527' , '343' , '951' , '335' , '207' , '903' , '591' , '935' , '247' , '743' , '471' , '855' , '247' , '063' , '391' , '095' , '007' , '663' , '951' , '055' , '527' , '943' , '551' , '535' , '007' , '903' , '391' , '735' , '847' , '143' , '471' , '255' , '647' , '863' , '591' , '095' , '207' , '863' , '351' , '655' , '527' , '543' , '151' , '735' , '807' , '903' , '191' , '535' , '447' , '543' , '471' , '655' , '047' , '663' , '791' , '095' , '407' , '063' , '751' , '255' , '527' ] NEW_LINE for caso in range ( 1 , casos + 1 ) : NEW_LINE INDENT numero = int ( entrada . readline ( ) ) NEW_LINE if numero == 0 : NEW_LINE INDENT saida . write ( \" Case ▁ # % i : ▁ 001 \\n \" % ( caso ) ) NEW_LINE continue NEW_LINE DEDENT if numero == 1 : NEW_LINE INDENT saida . write ( \" Case ▁ # % i : ▁ 005 \\n \" % ( caso ) ) NEW_LINE continue NEW_LINE DEDENT if numero == 2 : NEW_LINE INDENT saida . write ( \" Case ▁ # % i : ▁ 027 \\n \" % ( caso ) ) NEW_LINE continue NEW_LINE DEDENT print calculo [ numero % len ( calculo ) - 3 ] NEW_LINE saida . write ( \" Case ▁ # % i : ▁ % s \\n \" % ( caso , calculo [ numero % len ( calculo ) - 3 ] ) ) NEW_LINE DEDENT entrada . close ( ) NEW_LINE saida . close ( ) NEW_LINE print \" Tchau ▁ e ▁ obrigado ▁ pelos ▁ peixes ! \" NEW_LINE DEDENT main ( ) NEW_LINE","import sys NEW_LINE import psyco NEW_LINE psyco . full ( ) NEW_LINE class EOF ( Exception ) : NEW_LINE INDENT pass NEW_LINE DEDENT class CodeJam ( object ) : NEW_LINE INDENT def __init__ ( self , file = None , debug = False ) : NEW_LINE INDENT if not file : NEW_LINE INDENT if len ( sys . argv ) > 1 : NEW_LINE INDENT file = sys . argv [ 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT raise ValueError ( ' You ▁ MUST ▁ specify ▁ one ▁ input ▁ file ' ) NEW_LINE DEDENT DEDENT self . _debug = debug NEW_LINE self . _file = open ( file ) NEW_LINE self . _outfile = open ( \" % s . out \" % file , ' w ' ) NEW_LINE self . _current_case = - 1 NEW_LINE self . pos = 0 NEW_LINE DEDENT def get_lines ( self , count = 1 ) : NEW_LINE INDENT try : NEW_LINE INDENT value = [ self . _file . next ( ) [ : - 1 ] for i in xrange ( count ) ] NEW_LINE self . debug ( \" Getting ▁ % d ▁ line ( s ) \" % count ) NEW_LINE DEDENT except StopIteration : NEW_LINE INDENT raise EOF ( ' End ▁ of ▁ file ' ) NEW_LINE DEDENT self . pos += 1 NEW_LINE return value NEW_LINE DEDENT def get_int ( self ) : NEW_LINE INDENT try : NEW_LINE INDENT value = int ( self . _file . next ( ) ) NEW_LINE DEDENT except StopIteration : NEW_LINE INDENT raise EOF ( ' End ▁ of ▁ file ' ) NEW_LINE DEDENT except ValueError : NEW_LINE INDENT raise ValueError ( ' This ▁ line ▁ is ▁ not ▁ a ▁ number ' ) NEW_LINE DEDENT self . pos += 1 NEW_LINE self . debug ( \" Getting ▁ int : ▁ % d \" % value ) NEW_LINE return value NEW_LINE DEDENT def write_case ( self , text , tpl = ' Case ▁ # % d : ▁ % s \\n ' ) : NEW_LINE INDENT assert self . _current_case > - 1 , text = tpl % ( self . _current_case + 1 , text ) NEW_LINE self . _outfile . write ( text ) NEW_LINE self . debug ( \" Writing ▁ % s ▁ into ▁ output ▁ file \" % repr ( text ) ) NEW_LINE DEDENT def debug ( self , text ) : NEW_LINE INDENT if self . _debug : NEW_LINE INDENT print text NEW_LINE DEDENT DEDENT def get_cases ( self ) : NEW_LINE INDENT for self . _current_case in xrange ( self . get_int ( ) ) : NEW_LINE INDENT yield self . _current_case NEW_LINE DEDENT DEDENT cases = property ( get_cases ) NEW_LINE def __del__ ( self ) : NEW_LINE INDENT if hasattr ( self , ' _ file ' ) : NEW_LINE INDENT self . _outfile . close ( ) NEW_LINE self . _file . close ( ) NEW_LINE DEDENT DEDENT DEDENT"],"bleu":0.1843577330217627,"rouge_l":0.2508352608583912}
{"id":160,"predictions":["inp = open ( \" C - large . in \" , \" r \" ) NEW_LINE outfile = open ( \" C - large - out . out \" , \" w \" ) NEW_LINE cases = int ( inp . readline ( ) ) NEW_LINE for case in range ( 1 , cases + 1 ) : NEW_LINE INDENT c = inp . readline ( ) NEW_LINE C = inp . readline ( ) . split ( ) NEW_LINE C = int ( inp [ 0 ] ) NEW_LINE V = int ( inp [ 1 ] ) NEW_LINE V = int ( inp . readline ( ) ) NEW_LINE ans = 0 NEW_LINE C = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT C , C , V [ i ] = map ( int , inp . readline ( ) . split ( ) ) NEW_LINE V [ i ] = C * V [ i ] + C * ( V [ i ] + C ) NEW_LINE ans += 1 NEW_LINE D *= C NEW_LINE DEDENT ans += C * C NEW_LINE print \" Case ▁ # % s : ▁ % s \" % ( case + 1 , ans ) NEW_LINE DEDENT"],"references":["testSum = input ( ) NEW_LINE for test in xrange ( testSum ) : NEW_LINE INDENT c , d , v = map ( int , raw_input ( ) . split ( ) ) NEW_LINE coins = map ( int , raw_input ( ) . split ( ) ) NEW_LINE ansCoins = [ ] NEW_LINE now = 0 NEW_LINE ans = 0 NEW_LINE i = 0 NEW_LINE while now < v : NEW_LINE INDENT if i < len ( coins ) and ( coins [ i ] <= now + 1 ) : NEW_LINE INDENT ansCoins . append ( coins [ i ] ) NEW_LINE now = now + coins [ i ] * c NEW_LINE i = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ansCoins . append ( now + 1 ) NEW_LINE ans = ans + 1 NEW_LINE now = now + ( now + 1 ) * c NEW_LINE DEDENT DEDENT print \" Case ▁ # \" + str ( test + 1 ) + \" : \" , ans NEW_LINE DEDENT","def pr ( * a ) : NEW_LINE INDENT return NEW_LINE for x in a : print x , NEW_LINE print NEW_LINE DEDENT def maxcan ( C , ds ) : NEW_LINE INDENT m = [ 0 ] * len ( ds ) NEW_LINE if ds [ 0 ] == 1 : NEW_LINE INDENT m [ 0 ] = C NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( 1 , len ( ds ) ) : NEW_LINE INDENT d = ds [ i ] NEW_LINE if d > m [ i - 1 ] + 1 : NEW_LINE INDENT return m [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT m [ i ] = C * d + m [ i - 1 ] NEW_LINE DEDENT DEDENT return m [ - 1 ] NEW_LINE DEDENT def solve ( C , ds , V ) : NEW_LINE INDENT mx = maxcan ( C , ds ) NEW_LINE newd = 0 NEW_LINE while mx < V : NEW_LINE INDENT ds . append ( mx + 1 ) NEW_LINE ds . sort ( ) NEW_LINE pr ( ds ) NEW_LINE newd += 1 NEW_LINE mx = maxcan ( C , ds ) NEW_LINE DEDENT return newd NEW_LINE DEDENT import sys NEW_LINE f = open ( sys . argv [ 1 ] ) NEW_LINE out_fname = sys . argv [ 1 ] [ : - 2 ] + \" out \" NEW_LINE out = open ( out_fname , \" w \" ) NEW_LINE T = int ( f . readline ( ) . strip ( ) ) NEW_LINE for tc in range ( 1 , T + 1 ) : NEW_LINE INDENT C , D , V = [ int ( x ) for x in f . readline ( ) . strip ( ) . split ( ) ] NEW_LINE pr ( C , D , V ) NEW_LINE ds = [ int ( x ) for x in f . readline ( ) . strip ( ) . split ( ) ] NEW_LINE pr ( ds ) NEW_LINE assert len ( ds ) == D NEW_LINE rt = solve ( C , ds , V ) NEW_LINE pr ( \" Case ▁ # % d : ▁ % s \" % ( tc , str ( rt ) ) ) NEW_LINE pr ( \" = \" * 20 ) NEW_LINE print >> out , \" Case ▁ # % d : ▁ % s \" % ( tc , str ( rt ) ) NEW_LINE DEDENT out . close ( ) NEW_LINE","T = int ( raw_input ( ) ) NEW_LINE for testcase in range ( T ) : NEW_LINE INDENT [ c , d , v ] = [ int ( x ) for x in raw_input ( ) . split ( ) ] NEW_LINE old_denominations = [ int ( x ) for x in raw_input ( ) . split ( ) ] NEW_LINE old_denominations . sort ( ) NEW_LINE cashmoneys = 0 NEW_LINE new_denominations = [ ] NEW_LINE while cashmoneys < v : NEW_LINE INDENT if not old_denominations or old_denominations [ 0 ] > cashmoneys + 1 : NEW_LINE INDENT new_denominations . append ( cashmoneys + 1 ) NEW_LINE cashmoneys += c * ( cashmoneys + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT while old_denominations and old_denominations [ 0 ] <= cashmoneys + 1 : NEW_LINE INDENT cashmoneys += c * ( old_denominations [ 0 ] ) NEW_LINE old_denominations . pop ( 0 ) NEW_LINE DEDENT DEDENT DEDENT print \" Case ▁ # % s : ▁ % s \" % ( testcase + 1 , len ( new_denominations ) ) NEW_LINE DEDENT"],"bleu":0.47075126363875947,"rouge_l":0.4801057515042241}
{"id":161,"predictions":["def solve ( ) : NEW_LINE INDENT r = [ ] NEW_LINE for i in range ( r ) : NEW_LINE INDENT row = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE b . append ( row ) NEW_LINE DEDENT for i in range ( r ) : NEW_LINE INDENT for j in range ( b [ i ] ) : NEW_LINE INDENT if d [ i ] [ j ] >= 0 : NEW_LINE INDENT b [ i ] [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT return b NEW_LINE DEDENT t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT print ( \" Case ▁ # \" + str ( i ) + \" : ▁ \" + str ( i ) ) NEW_LINE DEDENT"],"references":["from __future__ import division NEW_LINE import collections NEW_LINE import itertools NEW_LINE import sys NEW_LINE import copy NEW_LINE class gcj : NEW_LINE INDENT IN = sys . stdin NEW_LINE number = 0 NEW_LINE @ classmethod NEW_LINE def case ( cls ) : NEW_LINE INDENT cls . number += 1 NEW_LINE return ' Case ▁ # % d : ' % cls . number NEW_LINE DEDENT @ classmethod NEW_LINE def line ( cls , type = str ) : NEW_LINE INDENT line = cls . IN . readline ( ) NEW_LINE return type ( line . strip ( ' \\n ' ) ) NEW_LINE DEDENT @ classmethod NEW_LINE def splitline ( cls , type = str ) : NEW_LINE INDENT line = cls . IN . readline ( ) NEW_LINE return [ type ( x ) for x in line . split ( ) ] NEW_LINE DEDENT DEDENT def go ( ) : NEW_LINE INDENT c = gcj . line ( int ) NEW_LINE for _ in xrange ( c ) : NEW_LINE INDENT r = gcj . line ( int ) NEW_LINE grid = [ [ 0 ] * 101 for _ in xrange ( 101 ) ] NEW_LINE for _ in xrange ( r ) : NEW_LINE INDENT x1 , y1 , x2 , y2 = gcj . splitline ( int ) NEW_LINE for x in xrange ( x1 , x2 + 1 ) : NEW_LINE INDENT for y in xrange ( y1 , y2 + 1 ) : NEW_LINE INDENT grid [ x ] [ y ] = 1 NEW_LINE DEDENT DEDENT DEDENT print gcj . case ( ) , solve ( grid ) NEW_LINE DEDENT DEDENT def solve ( grid ) : NEW_LINE INDENT t = 0 NEW_LINE while True : NEW_LINE INDENT done = True NEW_LINE for x in xrange ( 100 , 0 , - 1 ) : NEW_LINE INDENT for y in xrange ( 100 , 0 , - 1 ) : NEW_LINE INDENT if grid [ x ] [ y ] == 1 : NEW_LINE INDENT done = False NEW_LINE DEDENT if grid [ x - 1 ] [ y ] == grid [ x ] [ y - 1 ] : NEW_LINE INDENT grid [ x ] [ y ] = grid [ x ] [ y - 1 ] NEW_LINE DEDENT DEDENT DEDENT if done : NEW_LINE INDENT return t NEW_LINE DEDENT t += 1 NEW_LINE DEDENT DEDENT go ( ) NEW_LINE","filename = ' C - small ' NEW_LINE N = 110 NEW_LINE fin = open ( filename + ' . in ' ) NEW_LINE fout = open ( filename + ' . out ' , ' w ' ) NEW_LINE cases = int ( fin . readline ( ) . strip ( ) ) NEW_LINE for case in xrange ( 1 , cases + 1 ) : NEW_LINE INDENT map1 = [ ] NEW_LINE map2 = [ ] NEW_LINE for p in xrange ( N ) : NEW_LINE INDENT map1 . append ( [ False ] * N ) NEW_LINE map2 . append ( [ False ] * N ) NEW_LINE DEDENT r = int ( fin . readline ( ) . strip ( ) ) NEW_LINE for p in xrange ( r ) : NEW_LINE INDENT x1 , y1 , x2 , y2 = [ int ( x ) for x in fin . readline ( ) . strip ( ) . split ( ) ] NEW_LINE for i in xrange ( x1 , x2 + 1 ) : NEW_LINE INDENT for j in xrange ( y1 , y2 + 1 ) : NEW_LINE INDENT map1 [ i ] [ j ] = True NEW_LINE map2 [ i ] [ j ] = True NEW_LINE DEDENT DEDENT DEDENT r = 0 NEW_LINE while True : NEW_LINE INDENT s = 0 NEW_LINE r += 1 NEW_LINE for i in xrange ( 1 , N ) : NEW_LINE INDENT for j in xrange ( 1 , N ) : NEW_LINE INDENT if map1 [ i ] [ j ] : NEW_LINE INDENT if not map1 [ i - 1 ] [ j ] and not map1 [ i ] [ j - 1 ] : NEW_LINE INDENT map2 [ i ] [ j ] = False NEW_LINE DEDENT else : NEW_LINE INDENT map2 [ i ] [ j ] = True NEW_LINE s += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if map1 [ i - 1 ] [ j ] and map1 [ i ] [ j - 1 ] : NEW_LINE INDENT map2 [ i ] [ j ] = True NEW_LINE s += 1 NEW_LINE DEDENT else : NEW_LINE INDENT map2 [ i ] [ j ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT map1 , map2 = map2 , map1 NEW_LINE if s == 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print r NEW_LINE fout . write ( ' Case ▁ # % d : ▁ % d \\n ' % ( case , r ) ) NEW_LINE DEDENT fin . close ( ) NEW_LINE fout . close ( ) NEW_LINE","import sys NEW_LINE import psyco NEW_LINE psyco . full ( ) NEW_LINE def dbg ( a ) : sys . stderr . write ( str ( a ) ) NEW_LINE def readint ( ) : return int ( raw_input ( ) ) NEW_LINE def readfloat ( ) : return float ( raw_input ( ) ) NEW_LINE def readarray ( foo ) : return [ foo ( x ) for x in raw_input ( ) . split ( ) ] NEW_LINE def run_test ( test ) : NEW_LINE INDENT R = readint ( ) NEW_LINE xy = [ readarray ( int ) for i in xrange ( R ) ] NEW_LINE cur = { } NEW_LINE for ( x1 , y1 , x2 , y2 ) in xy : NEW_LINE INDENT for x in xrange ( x1 , x2 + 1 ) : NEW_LINE INDENT for y in xrange ( y1 , y2 + 1 ) : NEW_LINE INDENT cur [ ( x , y ) ] = True NEW_LINE DEDENT DEDENT DEDENT res = - 1 NEW_LINE for T in xrange ( 10000 ) : NEW_LINE INDENT next = { } NEW_LINE for ( x , y ) in cur : NEW_LINE INDENT if ( x - 1 , y ) in cur or ( x , y - 1 ) in cur : NEW_LINE INDENT next [ ( x , y ) ] = True NEW_LINE DEDENT if ( x - 1 , y + 1 ) in cur : NEW_LINE INDENT next [ ( x , y + 1 ) ] = True NEW_LINE DEDENT DEDENT if len ( next ) == 0 : NEW_LINE INDENT res = T + 1 NEW_LINE break NEW_LINE DEDENT cur = next NEW_LINE DEDENT print \" Case ▁ # % d : ▁ % d \" % ( test + 1 , res ) NEW_LINE DEDENT for test in range ( readint ( ) ) : NEW_LINE INDENT dbg ( \" Test ▁ % d \\n \" % ( test + 1 ) ) NEW_LINE run_test ( test ) NEW_LINE DEDENT"],"bleu":0.13986314638247535,"rouge_l":0.32274729275566516}
{"id":162,"predictions":["import sys NEW_LINE def readline ( ) : NEW_LINE INDENT return sys . stdin . readline ( ) [ : - 1 ] NEW_LINE DEDENT def readnlines ( n ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s += readline ( ) [ : - 1 ] NEW_LINE DEDENT if s < s : NEW_LINE INDENT return s NEW_LINE DEDENT else : NEW_LINE INDENT return s NEW_LINE DEDENT DEDENT def solve ( n ) : NEW_LINE INDENT if n < 100 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT t = int ( readline ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT s = [ : - 1 ] + [ : - 1 ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT t [ i ] = s [ i : ] + s [ i + 1 : ] NEW_LINE if t [ i ] == '0' : NEW_LINE INDENT t [ i ] = s [ i + 1 : ] NEW_LINE DEDENT DEDENT print ' Case ▁ # % d : ' % ( i + 1 , t [ i + 1 : ] ) , solve ( ) NEW_LINE DEDENT DEDENT"],"references":["import os , sys , time , random NEW_LINE time . clock ( ) NEW_LINE sys . stdin = open ( ' A - large . in ' ) NEW_LINE sys . stdout = open ( ' A - large . out ' , ' w ' ) NEW_LINE def flip ( x ) : NEW_LINE INDENT return int ( str ( x ) [ : : - 1 ] . lstrip ( '0' ) ) NEW_LINE DEDENT def Preprocess ( ) : NEW_LINE INDENT global f NEW_LINE n = 100002 NEW_LINE f = [ n ] * n NEW_LINE f [ 1 ] = 1 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT f [ i + 1 ] = min ( f [ i + 1 ] , f [ i ] + 1 ) NEW_LINE if flip ( i ) < n : NEW_LINE INDENT f [ flip ( i ) ] = min ( f [ flip ( i ) ] , f [ i ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT def GetCheckPoint ( x ) : NEW_LINE INDENT l = len ( str ( x ) ) NEW_LINE if str ( x ) . endswith ( '0' * ( l - l \/\/ 2 ) ) : NEW_LINE INDENT return GetCheckPoint ( x - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ret = int ( str ( x ) [ : l \/\/ 2 ] + '0' * ( l - l \/\/ 2 - 1 ) + '1' ) NEW_LINE if str ( x ) [ : l \/\/ 2 ] == '1' + '0' * ( l \/\/ 2 - 1 ) : NEW_LINE INDENT return GetCheckPoint ( ret - 2 ) NEW_LINE DEDENT return ret NEW_LINE DEDENT DEDENT def Calc ( n ) : NEW_LINE INDENT if n < 100 : return f [ n ] NEW_LINE cp = GetCheckPoint ( n ) NEW_LINE return Calc ( flip ( cp ) ) + 1 + n - cp NEW_LINE DEDENT def Work ( ) : NEW_LINE INDENT n = int ( input ( ) . strip ( ) ) NEW_LINE return Calc ( n ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT Preprocess ( ) NEW_LINE T = int ( input ( ) ) NEW_LINE for i in range ( T ) : NEW_LINE INDENT print ( ' Case ▁ # % d : ▁ % d ' % ( i + 1 , Work ( ) ) ) NEW_LINE DEDENT sys . stderr . write ( ' completed ▁ % .3f \\n ' % time . clock ( ) ) NEW_LINE DEDENT","from queue import Queue NEW_LINE def minsteps ( start , goal ) : NEW_LINE INDENT if start == goal : return 0 NEW_LINE best = int ( goal ) - int ( start ) NEW_LINE bmedzi = ' ' NEW_LINE C = len ( start ) NEW_LINE for cif in range ( C ) : NEW_LINE INDENT rgoal = goal [ : : - 1 ] NEW_LINE medzi = start [ : C - cif ] + rgoal [ C - cif : ] NEW_LINE if medzi [ : : - 1 ] > goal : continue NEW_LINE toto = int ( medzi ) - int ( start ) + 1 NEW_LINE toto += int ( goal ) - int ( medzi [ : : - 1 ] ) NEW_LINE if toto < best : NEW_LINE INDENT best = toto NEW_LINE bmedzi = medzi NEW_LINE DEDENT DEDENT return best NEW_LINE DEDENT def solve ( goal ) : NEW_LINE INDENT start = '1' NEW_LINE answer = 1 NEW_LINE while len ( start ) < len ( goal ) : NEW_LINE INDENT answer += minsteps ( start , '9' * len ( start ) ) + 1 NEW_LINE start += '0' NEW_LINE DEDENT answer += minsteps ( start , goal ) NEW_LINE return answer NEW_LINE DEDENT T = int ( input ( ) ) NEW_LINE for t in range ( 1 , T + 1 ) : NEW_LINE INDENT goal = input ( ) . strip ( ) NEW_LINE answer = solve ( goal ) NEW_LINE if goal != '1' : NEW_LINE INDENT goal = str ( int ( goal ) - 1 ) NEW_LINE answer = min ( answer , 1 + solve ( goal ) ) NEW_LINE DEDENT print ( ' Case ▁ # { } : ▁ { } ' . format ( t , answer ) ) NEW_LINE DEDENT","def previously ( x ) : NEW_LINE INDENT if x == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif x == 1 : NEW_LINE INDENT return 10 NEW_LINE DEDENT else : NEW_LINE INDENT x1 = ( x + 1 ) \/\/ 2 NEW_LINE x2 = x \/\/ 2 NEW_LINE gain = 10 ** x1 + 10 ** x2 - 1 NEW_LINE return gain + previously ( x - 1 ) NEW_LINE DEDENT DEDENT def Next ( N ) : NEW_LINE INDENT count = 0 NEW_LINE s = str ( N ) NEW_LINE x = len ( s ) NEW_LINE if x < 2 : NEW_LINE INDENT return N NEW_LINE DEDENT tl = ( x + 1 ) \/\/ 2 NEW_LINE tail = N % 10 ** tl NEW_LINE if tail == 0 : NEW_LINE INDENT return 1 + Next ( N - 1 ) NEW_LINE DEDENT count += tail - 1 NEW_LINE N -= tail - 1 NEW_LINE revstr = str ( N ) [ : : - 1 ] NEW_LINE count += 1 NEW_LINE if str ( N ) == revstr : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT count += int ( revstr ) % 10 ** tl NEW_LINE return count + previously ( x - 1 ) NEW_LINE DEDENT input = open ( r ' . \/ A - large . in ' ) NEW_LINE X = list ( input ) NEW_LINE C = int ( X [ 0 ] ) NEW_LINE Y = [ [ int ( j ) for j in x . split ( ) ] for x in X [ 1 : ] ] NEW_LINE sol = [ ] NEW_LINE j = 0 NEW_LINE for i in xrange ( C ) : NEW_LINE INDENT s = Y [ i ] [ 0 ] NEW_LINE sol += [ Next ( s ) ] NEW_LINE if not i % 10 : print ' case ▁ ' , i + 1 , ' done ' NEW_LINE DEDENT tofile = True NEW_LINE if tofile : NEW_LINE INDENT with open ( r ' . \/ outputA . txt ' , ' w ' ) as output : NEW_LINE INDENT for i in range ( len ( sol ) ) : NEW_LINE INDENT output . write ( ' Case ▁ # % s : ▁ % s \\n ' % ( i + 1 , sol [ i ] ) ) NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT print sol NEW_LINE DEDENT"],"bleu":0.3435321990842041,"rouge_l":0.3935364262426987}
{"id":163,"predictions":["import sys NEW_LINE def dbg ( a ) : sys . stderr . write ( str ( a ) ) NEW_LINE def readint ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def readfloat ( ) : return float ( sys . stdin . readline ( ) ) NEW_LINE def readfloat ( ) : return float ( sys . stdin . readline ( ) ) NEW_LINE def readline ( ) : return float ( sys . stdin . readline ( ) ) NEW_LINE def readline ( ) : return float ( sys . stdin . readline ( ) ) NEW_LINE def readline ( ) . strip ( ) : return float ( sys . stdin . readline ( ) ) NEW_LINE def readline ( ) : return float ( sys . stdin . readline ( ) ) NEW_LINE def readline ( ) : return float ( sys . stdin . readline ( ) ) NEW_LINE def readline ( ) : return float ( sys . stdin . readline ( ) ) NEW_LINE def ws ( ) : return map ( float , sys . stdin . readline ( ) . split ( ) ) NEW_LINE def ws ( s ) : return stdin . readline ( ) . strip ( ) NEW_LINE def ws ( a ) : return float ( sile . readline ( ) ) NEW_LINE def readline ( ) : return float ( sys . stdin . readline ( ) ) NEW_LINE def ws ( ) : return stdin . readline ( ) . strip ( ) NEW_LINE def ws ( v ) : return stdin . readline ( ) . strip ( ) ) NEW_LINE ( ) : return input ( ) NEW_LINE def ws ( a , b , k = readline ( ) : NEW_LINE INDENT ( a , b , k = readline ( ) . strip ( ) NEW_LINE if a == b : NEW_LINE INDENT return w NEW_LINE DEDENT else : NEW_LINE INDENT return w NEW_LINE DEDENT DEDENT for tc in range ( 1 , t + 1 ) : NEW_LINE INDENT a , b , k = readline ( ) . strip ( ) NEW_LINE res = 0 NEW_LINE for i in range ( 1 , 10000 +"],"references":["import sys NEW_LINE from itertools import zip_longest as zip NEW_LINE T = int ( sys . stdin . readline ( ) . strip ( ) ) NEW_LINE for t in range ( T ) : NEW_LINE INDENT A , B , K = tuple ( int ( i ) for i in sys . stdin . readline ( ) . strip ( ) . split ( ) ) NEW_LINE cnt = 0 NEW_LINE for a in range ( A ) : NEW_LINE INDENT for b in range ( B ) : NEW_LINE INDENT if a & b < K : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT print ( \" Case ▁ # % d : ▁ % d \" % ( t + 1 , cnt ) ) NEW_LINE DEDENT","cache = { } NEW_LINE A , B , K = 0 , 0 , 0 NEW_LINE def f ( upto , abound , bbound , kbound ) : NEW_LINE INDENT if upto >= len ( A ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( upto , abound , bbound , kbound ) in cache : NEW_LINE INDENT return cache [ ( upto , abound , bbound , kbound ) ] NEW_LINE DEDENT a = int ( A [ upto ] ) NEW_LINE b = int ( B [ upto ] ) NEW_LINE k = int ( K [ upto ] ) NEW_LINE ans = 0 NEW_LINE for ma in ( 0 , 1 ) : NEW_LINE INDENT for mb in ( 0 , 1 ) : NEW_LINE INDENT mk = ma & mb NEW_LINE if abound and ma > a : NEW_LINE INDENT continue NEW_LINE DEDENT if bbound and mb > b : NEW_LINE INDENT continue NEW_LINE DEDENT if kbound and mk > k : NEW_LINE INDENT continue NEW_LINE DEDENT ans += f ( upto + 1 , abound and ma == a , bbound and mb == b , kbound and mk == k ) NEW_LINE DEDENT DEDENT cache [ ( upto , abound , bbound , kbound ) ] = ans NEW_LINE return ans NEW_LINE DEDENT def do ( ) : NEW_LINE INDENT global A , B , K , cache NEW_LINE cache = { } NEW_LINE A , B , K = map ( lambda x : bin ( int ( x ) - 1 ) [ 2 : ] . zfill ( 100 ) , raw_input ( ) . split ( ) ) NEW_LINE return str ( f ( 0 , True , True , True ) ) NEW_LINE DEDENT T = input ( ) NEW_LINE for i in xrange ( T ) : NEW_LINE INDENT print \" Case ▁ # % s : ▁ % s \" % ( i + 1 , do ( ) ) NEW_LINE DEDENT","import itertools NEW_LINE from collections import defaultdict NEW_LINE from random import randint NEW_LINE def getzip ( zipcode , lst ) : NEW_LINE INDENT res = ' ' NEW_LINE for elm in lst : NEW_LINE INDENT res += zipcode [ elm ] NEW_LINE DEDENT return res NEW_LINE DEDENT def ok ( lst , mp ) : NEW_LINE INDENT n = len ( lst ) NEW_LINE stack = [ ] NEW_LINE vis = [ 0 ] * n NEW_LINE cur = lst [ 0 ] NEW_LINE vis [ cur ] = 1 NEW_LINE stack . append ( cur ) NEW_LINE for i in xrange ( 1 , n ) : NEW_LINE INDENT nxt = lst [ i ] NEW_LINE while stack : NEW_LINE INDENT now = stack [ - 1 ] NEW_LINE if ( now , nxt ) in mp : break NEW_LINE stack . pop ( ) NEW_LINE DEDENT if not stack : NEW_LINE INDENT return False NEW_LINE DEDENT stack . append ( nxt ) NEW_LINE DEDENT return True NEW_LINE DEDENT def solve ( tcase ) : NEW_LINE INDENT n , m = ( int ( e ) for e in raw_input ( ' ' ) . split ( ) ) NEW_LINE zipcode = [ raw_input ( ' ' ) for i in xrange ( n ) ] NEW_LINE road = [ raw_input ( ' ' ) . split ( ) for i in xrange ( m ) ] NEW_LINE mp = defaultdict ( int ) NEW_LINE for r in road : NEW_LINE INDENT key = ( int ( r [ 0 ] ) - 1 , int ( r [ 1 ] ) - 1 ) NEW_LINE mp [ key ] = 1 NEW_LINE key = ( int ( r [ 1 ] ) - 1 , int ( r [ 0 ] ) - 1 ) NEW_LINE mp [ key ] = 1 NEW_LINE DEDENT opt = range ( n ) NEW_LINE res = ' z ' * 100 NEW_LINE for elm in itertools . permutations ( opt ) : NEW_LINE INDENT if ok ( elm , mp ) : NEW_LINE INDENT res = min ( res , getzip ( zipcode , elm ) ) NEW_LINE DEDENT DEDENT print ' Case ▁ # % d : ▁ % s ' % ( tcase , res ) NEW_LINE DEDENT T = int ( raw_input ( ' ' ) ) NEW_LINE for tcase in xrange ( 1 , T + 1 ) : NEW_LINE INDENT solve ( tcase ) NEW_LINE DEDENT"],"bleu":0.2048299483163323,"rouge_l":0.4182699118805429}
{"id":164,"predictions":["inp = open ( \" C - large . in \" , \" r \" ) NEW_LINE out = open ( \" C - large . out \" , \" w \" ) NEW_LINE num = int ( inp . readline ( ) ) NEW_LINE for case in range ( num ) : NEW_LINE INDENT l , c = [ int ( x ) for x inp . readline ( ) . split ( ) ] NEW_LINE P = int ( l ) NEW_LINE C = [ int ( x ) for x inp . readline ( ) . split ( ) ] NEW_LINE poss = 0 NEW_LINE for i in xrange ( N ) : NEW_LINE INDENT poss = 0 NEW_LINE print \" Case ▁ # % s : ▁ \" % ( case , ans ) NEW_LINE DEDENT DEDENT"],"references":["import sys NEW_LINE def ntests ( L , P , C ) : NEW_LINE INDENT ratio = P * 1.0 \/ L NEW_LINE if ratio <= C : return 0 NEW_LINE if L == 1 and P == 3 : return 1 NEW_LINE testpoint = int ( L * ( ratio ** 0.5 ) ) NEW_LINE count = max ( 1 + ntests ( L , testpoint , C ) , 1 + ntests ( testpoint , P , C ) ) NEW_LINE if ( testpoint * testpoint == L * P or testpoint + 1 == P ) : NEW_LINE INDENT return count NEW_LINE DEDENT count2 = max ( 1 + ntests ( L , testpoint + 1 , C ) , 1 + ntests ( testpoint + 1 , P , C ) ) NEW_LINE return min ( count , count2 ) NEW_LINE DEDENT infile = sys . stdin NEW_LINE T = int ( infile . readline ( ) . strip ( ) ) NEW_LINE for i in xrange ( T ) : NEW_LINE INDENT L , P , C = map ( int , infile . readline ( ) . strip ( ) . split ( ) ) NEW_LINE result = ntests ( L , P , C ) NEW_LINE print ( \" Case ▁ # % d : ▁ % s \" % ( i + 1 , str ( result ) ) ) NEW_LINE DEDENT","read_int = lambda : int ( raw_input ( ) . strip ( ) ) NEW_LINE read_ints = lambda : [ int ( x ) for x in raw_input ( ) . split ( ) ] NEW_LINE count_to = lambda n : xrange ( 1 , n + 1 ) NEW_LINE def solve_all ( solve ) : NEW_LINE INDENT num_cases = read_int ( ) NEW_LINE for i in count_to ( num_cases ) : NEW_LINE INDENT print \" Case ▁ # { 0 } : \" . format ( i ) , NEW_LINE solve ( ) NEW_LINE DEDENT DEDENT import math NEW_LINE def solve_case ( ) : NEW_LINE INDENT l , p , c = read_ints ( ) NEW_LINE count = 0 NEW_LINE while l * c < p : NEW_LINE INDENT l *= c NEW_LINE count += 1 NEW_LINE DEDENT tests = 0 NEW_LINE while count != 0 : NEW_LINE INDENT count >>= 1 NEW_LINE tests += 1 NEW_LINE DEDENT print tests NEW_LINE DEDENT solve_all ( solve_case ) NEW_LINE","import math NEW_LINE T = int ( input ( ) ) NEW_LINE for testCase in range ( 0 , T ) : NEW_LINE INDENT line = input ( ) . split ( ) NEW_LINE L = int ( line [ 0 ] ) NEW_LINE P = int ( line [ 1 ] ) NEW_LINE C = int ( line [ 2 ] ) NEW_LINE a = math . log ( P \/ L , C ) NEW_LINE a = math . ceil ( a ) NEW_LINE b = math . ceil ( math . log ( a , 2 ) ) NEW_LINE print ( ' Case ▁ # { 0 } : ▁ { 1 } ' . format ( testCase + 1 , b ) ) NEW_LINE DEDENT"],"bleu":0.40431059938671554,"rouge_l":0.4570039573033971}
{"id":165,"predictions":["inp_file = file ( \" B - large . in \" ) NEW_LINE out_file = open ( \" B - large . out \" , \" w \" ) NEW_LINE num_cases = int ( inp_file . readline ( ) ) NEW_LINE for case in range ( numcases ) : NEW_LINE INDENT N = int ( inp_file . readline ( ) ) NEW_LINE out_file . write ( \" Case ▁ # \" + str ( case ) : ▁ \" + str ( case ) + \" ▁ # \" + str ( case ) + \" \\n \" ) NEW_LINE N = int ( inp_file . readline ( ) ) NEW_LINE l = inp_file . readline ( ) NEW_LINE for i in xrange ( N ) : NEW_LINE INDENT out_file . write ( \" Case ▁ # \" + str ( case ) + \" : ▁ \" + str ( case ) + \" \\n \" ) NEW_LINE break NEW_LINE DEDENT"],"references":["def war ( n , k ) : NEW_LINE INDENT n = [ float ( block ) for block in n . split ( \" ▁ \" ) ] NEW_LINE k = [ float ( block ) for block in k . split ( \" ▁ \" ) ] NEW_LINE points = 0 NEW_LINE n = reversed ( sorted ( n ) ) NEW_LINE for nblock in n : NEW_LINE INDENT if nblock > max ( k ) : NEW_LINE INDENT points += 1 NEW_LINE k . remove ( min ( k ) ) NEW_LINE DEDENT else : NEW_LINE INDENT k . remove ( min ( [ block for block in k if block > nblock ] ) ) NEW_LINE DEDENT DEDENT return str ( points ) NEW_LINE DEDENT def dwar ( n , k ) : NEW_LINE INDENT n = [ float ( block ) for block in n . split ( \" ▁ \" ) ] NEW_LINE k = [ float ( block ) for block in k . split ( \" ▁ \" ) ] NEW_LINE points = 0 NEW_LINE n = sorted ( n ) NEW_LINE for nblock in n : NEW_LINE INDENT if nblock > min ( k ) : NEW_LINE INDENT points += 1 NEW_LINE k . remove ( min ( k ) ) NEW_LINE DEDENT else : NEW_LINE INDENT k . remove ( max ( k ) ) NEW_LINE DEDENT DEDENT return str ( points ) NEW_LINE DEDENT input_text = open ( \" input . in \" ) NEW_LINE lines = input_text . readlines ( ) NEW_LINE input_text . close ( ) NEW_LINE with open ( \" output \" , \" a \" ) as outputfile : NEW_LINE INDENT for num in range ( 0 , int ( lines [ 0 ] ) ) : NEW_LINE INDENT outputfile . write ( \" Case ▁ # \" + str ( num + 1 ) + \" : ▁ \" + dwar ( lines [ num * 3 + 2 ] , lines [ num * 3 + 3 ] ) + \" ▁ \" + war ( lines [ num * 3 + 2 ] , lines [ num * 3 + 3 ] ) + \" \\n \" ) NEW_LINE DEDENT DEDENT","import fileinput NEW_LINE def readCase ( f ) : NEW_LINE INDENT f . readline ( ) NEW_LINE return map ( float , f . readline ( ) . split ( ) ) , map ( float , f . readline ( ) . split ( ) ) NEW_LINE DEDENT def printResult ( i , out ) : NEW_LINE INDENT print \" Case ▁ # % d : ▁ % s \" % ( i + 1 , out ) NEW_LINE DEDENT def solve ( naomi , ken ) : NEW_LINE INDENT naomi . sort ( ) NEW_LINE ken . sort ( ) NEW_LINE return \" % d ▁ % d \" % ( solveDeceitful ( list ( naomi ) , list ( ken ) ) , solveWar ( list ( naomi ) , list ( ken ) ) ) NEW_LINE DEDENT def solveWar ( naomi , ken ) : NEW_LINE INDENT while len ( naomi ) and naomi [ 0 ] < ken [ - 1 ] : NEW_LINE INDENT n = naomi . pop ( 0 ) NEW_LINE ken . pop ( next ( index for index , value in enumerate ( ken ) if value > n ) ) NEW_LINE DEDENT return len ( naomi ) NEW_LINE DEDENT def solveDeceitful ( naomi , ken ) : NEW_LINE INDENT delay = 0 NEW_LINE score = 0 NEW_LINE while len ( naomi ) : NEW_LINE INDENT if naomi [ 0 ] < ken [ 0 ] : NEW_LINE INDENT naomi . pop ( 0 ) NEW_LINE ken . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT score += 1 NEW_LINE ken . pop ( 0 ) NEW_LINE naomi . pop ( 0 ) NEW_LINE DEDENT DEDENT return score NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT f = fileinput . input ( ) NEW_LINE N = int ( f . readline ( ) ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT printResult ( i , solve ( * readCase ( f ) ) ) NEW_LINE DEDENT DEDENT","from collections import * NEW_LINE from sys import argv , stdin , stdout , stderr NEW_LINE Case = namedtuple ( ' Case ' , ' naomi , ▁ ken ' ) NEW_LINE def readcase ( f ) : NEW_LINE INDENT blocks = int ( next ( f ) ) NEW_LINE naomi = sorted ( readfloats ( f ) ) NEW_LINE ken = sorted ( readfloats ( f ) ) NEW_LINE assert blocks == len ( ken ) == len ( naomi ) NEW_LINE return Case ( naomi , ken ) NEW_LINE DEDENT def solvecase ( case ) : NEW_LINE INDENT naomi , ken = case NEW_LINE return ' % d ▁ % d ' % ( liewar ( ken = ken , naomi = naomi ) , war ( ken = ken , naomi = naomi ) ) NEW_LINE DEDENT def war ( ken , naomi ) : NEW_LINE INDENT kenwins = 0 NEW_LINE kencursor = 0 NEW_LINE for nweight in naomi : NEW_LINE INDENT while kencursor < len ( ken ) : NEW_LINE INDENT if ken [ kencursor ] > nweight : NEW_LINE INDENT kenwins += 1 NEW_LINE kencursor += 1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT kencursor += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return len ( ken ) - kenwins NEW_LINE DEDENT def liewar ( ken , naomi ) : NEW_LINE INDENT return len ( ken ) - war ( naomi , ken ) NEW_LINE DEDENT def readfloats ( f ) : NEW_LINE INDENT return list ( map ( float , next ( f ) . split ( ' ▁ ' ) ) ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT with open ( argv [ 1 ] ) as f , open ( argv [ 2 ] , ' w ' ) as out : NEW_LINE INDENT cases = int ( next ( f ) ) NEW_LINE for case in range ( 1 , cases + 1 ) : NEW_LINE INDENT print ( ' Case ▁ # % d : ▁ % s ' % ( case , solvecase ( readcase ( f ) ) ) , file = out ) NEW_LINE DEDENT DEDENT DEDENT main ( ) NEW_LINE"],"bleu":0.1536899089663513,"rouge_l":0.324064654685204}
{"id":166,"predictions":["def solve ( ) : NEW_LINE INDENT l , t , c , n = map ( int , raw_input ( ) . split ( ) ) NEW_LINE arr = [ int ( x ) for x in raw_input ( ) . split ( ) ] NEW_LINE t = [ int ( x ) for x in raw_input ( ) . split ( ) ] NEW_LINE ans = 1 NEW_LINE while True : NEW_LINE INDENT if t > 0 : NEW_LINE INDENT break NEW_LINE DEDENT if t < 0 : NEW_LINE INDENT ans = 1 NEW_LINE for x in arr : NEW_LINE INDENT if t < 0 : NEW_LINE INDENT t += 1 NEW_LINE DEDENT else : NEW_LINE INDENT t -= t NEW_LINE DEDENT DEDENT if t % 2 == 0 : NEW_LINE INDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if t <= ( t ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT print \" Case ▁ # { } : ▁ { } \" . format ( x + 1 , ans ) ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE from itertools import islice NEW_LINE def solve ( L , t , N , C , a ) : NEW_LINE INDENT tot_dist = 0 NEW_LINE eff_dists = [ ] NEW_LINE for s in xrange ( N ) : NEW_LINE INDENT d = a [ s % len ( a ) ] NEW_LINE if tot_dist + d <= t : NEW_LINE INDENT eff_dists . append ( ( d , 0 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT if tot_dist >= t : NEW_LINE INDENT eff_dists . append ( ( d , d ) ) NEW_LINE DEDENT else : NEW_LINE INDENT eff_dists . append ( ( d , d - ( t - tot_dist ) ) ) NEW_LINE DEDENT DEDENT tot_dist += d NEW_LINE DEDENT tot_time = 0 NEW_LINE for dist , eff_dist in sorted ( eff_dists , key = lambda x : x [ 1 ] , reverse = True ) : NEW_LINE INDENT if L > 0 : NEW_LINE INDENT tot_time += eff_dist + 2 * ( dist - eff_dist ) NEW_LINE L -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT tot_time += dist * 2 NEW_LINE DEDENT DEDENT return tot_time \/\/ 2 NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT T = int ( next ( sys . stdin ) ) NEW_LINE for test in xrange ( 1 , T + 1 ) : NEW_LINE INDENT print >> sys . stderr , test NEW_LINE line = next ( sys . stdin ) NEW_LINE L , t , N , C , a = line . split ( None , 4 ) NEW_LINE L , t , N , C = map ( int , ( L , t , N , C ) ) NEW_LINE a = list ( int ( ai ) * 2 for ai in a . split ( ) ) NEW_LINE print \" Case ▁ # % s : ▁ % s \" % ( test , solve ( L , t , N , C , a ) ) NEW_LINE DEDENT DEDENT main ( ) NEW_LINE","class streamreader : NEW_LINE INDENT def __init__ ( _ , s ) : _ . t = ( t for t in s . read ( ) . split ( ) ) NEW_LINE def __div__ ( _ , t ) : return ( t ) ( _ . t . next ( ) ) NEW_LINE DEDENT import sys NEW_LINE sr = streamreader ( sys . stdin ) NEW_LINE for tc in xrange ( sr \/ int ) : NEW_LINE INDENT L , t , N , C = sr \/ int , sr \/ int , sr \/ int , sr \/ int NEW_LINE a = [ sr \/ int for i in xrange ( C ) ] NEW_LINE A = [ a [ i % C ] for i in xrange ( N ) ] NEW_LINE time = 0 NEW_LINE for i in xrange ( N ) : NEW_LINE INDENT if time <= t and time + A [ i ] * 2 > t : NEW_LINE INDENT f = ( t - time ) \/ 2 NEW_LINE s = A [ i ] - f NEW_LINE A [ i ] = f NEW_LINE A . insert ( i + 1 , s ) NEW_LINE i += 1 NEW_LINE break NEW_LINE DEDENT time += A [ i ] * 2 NEW_LINE DEDENT A0 = A [ : i ] NEW_LINE B = A [ i : ] NEW_LINE B . sort ( ) NEW_LINE if L == 0 : NEW_LINE INDENT B1 = B NEW_LINE B2 = [ ] NEW_LINE DEDENT else : NEW_LINE INDENT B1 = B [ : - L ] NEW_LINE B2 = B [ - L : ] NEW_LINE DEDENT time = 0 NEW_LINE for i in A0 + B1 : NEW_LINE INDENT time += i * 2 NEW_LINE DEDENT for i in B2 : NEW_LINE INDENT time += i NEW_LINE DEDENT print ' Case ▁ # % d : ' % ( tc + 1 ) , time NEW_LINE DEDENT","from __future__ import division NEW_LINE import sys NEW_LINE from itertools import cycle , islice NEW_LINE def do_case ( l , t , n , c , _as ) : NEW_LINE INDENT distances = list ( islice ( cycle ( _as ) , n ) ) NEW_LINE total = sum ( distances ) NEW_LINE if total * 2 <= t or l == 0 : NEW_LINE INDENT return total * 2 NEW_LINE DEDENT traveled = t * .5 NEW_LINE left = 0 NEW_LINE index = 0 NEW_LINE for i , dist in enumerate ( distances ) : NEW_LINE INDENT if traveled >= dist : NEW_LINE INDENT traveled -= dist NEW_LINE DEDENT else : NEW_LINE INDENT index = i + 1 NEW_LINE left = dist - traveled NEW_LINE break NEW_LINE DEDENT DEDENT remaining = distances [ index : ] + [ left ] NEW_LINE return t + sum ( remaining ) * 2 - sum ( islice ( sorted ( remaining , reverse = True ) , l ) ) NEW_LINE DEDENT in_ , out_f = sys . argv [ 1 ] , sys . argv [ 1 ] + \" . out \" NEW_LINE out = open ( out_f , ' w ' ) NEW_LINE with open ( in_ , ' r ' ) as file : NEW_LINE INDENT num = 1 NEW_LINE num_cases = int ( file . next ( ) . rstrip ( ) ) NEW_LINE for num in range ( 1 , num_cases + 1 ) : NEW_LINE INDENT s = map ( int , file . next ( ) . rstrip ( ) . split ( ' ▁ ' ) ) NEW_LINE l , t , n , c = s [ 0 : 4 ] NEW_LINE _as = s [ 4 : ] NEW_LINE ret = do_case ( l , t , n , c , _as ) NEW_LINE out . write ( \" Case ▁ # % d : ▁ % d \\n \" % ( num , ret ) ) NEW_LINE print \" Case ▁ # % d : ▁ % d \" % ( num , ret ) NEW_LINE DEDENT DEDENT"],"bleu":0.1885474833886527,"rouge_l":0.3368779742670818}
{"id":167,"predictions":["T = int ( raw_input ( ) ) NEW_LINE for testcase in xrange ( 1 , T + 1 ) : NEW_LINE INDENT K , L , S , K = [ int ( x ) for x in raw_input ( ) . split ( ) ] NEW_LINE T = [ int ( x ) for x in raw_input ( ) . split ( ) ] NEW_LINE s = raw_input ( ) . split ( \" ▁ \" ) NEW_LINE for i in xrange ( 1 , K + 1 ) : NEW_LINE INDENT k , s = [ int ( x ) for x in raw_input ( ) . split ( ) ] NEW_LINE ans = 1 NEW_LINE for j in xrange ( L - 1 ) : NEW_LINE INDENT k = s [ j ] NEW_LINE if s [ k ] == s [ j - 1 ] : NEW_LINE INDENT ans = ans + 1 NEW_LINE DEDENT DEDENT if ans : NEW_LINE INDENT print ' Case ▁ # % d : ▁ % d ' % ( i + 1 , ans ) NEW_LINE DEDENT else : NEW_LINE INDENT print ' Case ▁ # % d : ▁ % s ' % ( testcase + 1 , ans ) NEW_LINE DEDENT DEDENT"],"references":["import sys NEW_LINE import math NEW_LINE from collections import defaultdict NEW_LINE f = open ( ' B - large . in ' ) NEW_LINE tests = int ( f . readline ( ) ) NEW_LINE def getOffset ( keys , target ) : NEW_LINE INDENT s = set ( list ( keys ) ) NEW_LINE for c in target : NEW_LINE INDENT if c not in s : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT offset = 1 NEW_LINE while offset < len ( target ) : NEW_LINE INDENT if target [ : len ( target ) - offset ] == target [ offset : ] : NEW_LINE INDENT break NEW_LINE DEDENT offset += 1 NEW_LINE DEDENT return offset NEW_LINE DEDENT def getExp ( keys , target , s ) : NEW_LINE INDENT d = defaultdict ( lambda : 0.0 ) NEW_LINE for c in keys : NEW_LINE INDENT d [ c ] += 1.0 \/ len ( keys ) NEW_LINE DEDENT tot = 1.0 NEW_LINE for c in target : NEW_LINE INDENT tot *= d [ c ] NEW_LINE DEDENT return tot * ( s - len ( target ) + 1 ) NEW_LINE DEDENT for t in xrange ( tests ) : NEW_LINE INDENT k , l , s = map ( int , f . readline ( ) . rstrip ( ) . split ( ) ) NEW_LINE keys = f . readline ( ) . rstrip ( ) NEW_LINE target = f . readline ( ) . rstrip ( ) NEW_LINE offset = getOffset ( keys , target ) NEW_LINE if offset == 0 : NEW_LINE INDENT print \" Case ▁ # \" + str ( t + 1 ) + \" : ▁ 0.0\" NEW_LINE continue NEW_LINE DEDENT needed = 1 + ( s - len ( target ) ) \/\/ offset NEW_LINE ans = max ( 0.0 , needed - getExp ( keys , target , s ) ) NEW_LINE if ans < 0.000000001 : NEW_LINE INDENT ans = 0.0 NEW_LINE DEDENT print \" Case ▁ # \" + str ( t + 1 ) + \" : ▁ \" + str ( ans ) NEW_LINE DEDENT","from __future__ import print_function , division NEW_LINE from collections import Counter NEW_LINE def overlap_shift ( s ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if s . startswith ( s [ i + 1 : ] ) : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT DEDENT def tc ( tci ) : NEW_LINE INDENT [ klen , tlen , s ] = map ( int , raw_input ( ) . split ( ) ) NEW_LINE keyboard = raw_input ( ) NEW_LINE target = raw_input ( ) NEW_LINE assert klen == len ( keyboard ) NEW_LINE assert tlen == len ( target ) NEW_LINE assert s >= tlen NEW_LINE sol = 0.0 NEW_LINE counter = Counter ( keyboard ) NEW_LINE if all ( t in counter for t in target ) : NEW_LINE INDENT sh = overlap_shift ( target ) NEW_LINE occs = 1 + ( s - tlen ) \/\/ sh NEW_LINE p = 1.0 NEW_LINE for t in target : NEW_LINE INDENT p *= counter [ t ] \/ klen NEW_LINE DEDENT sol = occs - p * ( s - tlen + 1 ) NEW_LINE DEDENT print ( \" Case ▁ # { } : ▁ { : . 15f } \" . format ( tci , sol ) ) NEW_LINE DEDENT tcn = int ( raw_input ( ) ) NEW_LINE for tci in range ( 1 , tcn + 1 ) : tc ( tci ) NEW_LINE","import re NEW_LINE fin = open ( \" smallB . in \" , \" r \" ) NEW_LINE fout = open ( \" smallB . out \" , \" w + \" ) NEW_LINE for tc in xrange ( int ( fin . readline ( ) ) ) : NEW_LINE INDENT K , L , S = [ int ( x ) for x in fin . readline ( ) . split ( ) ] NEW_LINE KEYS = [ x for x in fin . readline ( ) . strip ( ) ] NEW_LINE TW = fin . readline ( ) . strip ( ) NEW_LINE pos = [ \" \" ] NEW_LINE for i in xrange ( S ) : NEW_LINE INDENT pos_next = [ ] NEW_LINE for p in pos : NEW_LINE INDENT for key in KEYS : NEW_LINE INDENT pos_next . append ( p + key ) NEW_LINE DEDENT DEDENT pos = pos_next NEW_LINE DEDENT to_pay = [ len ( re . findall ( \" ( ? = % s ) \" % TW , word ) ) for word in pos ] NEW_LINE to_bring = max ( to_pay ) NEW_LINE med_pay = sum ( to_pay ) * 1. \/ len ( to_pay ) NEW_LINE ans = to_bring - med_pay NEW_LINE print \" Case ▁ # % i : ▁ % f \" % ( tc + 1 , ans ) NEW_LINE fout . write ( \" Case ▁ # % i : ▁ % f \\n \" % ( tc + 1 , ans ) ) NEW_LINE DEDENT"],"bleu":0.3964218312952761,"rouge_l":0.48200175592625116}
{"id":168,"predictions":["import sys NEW_LINE def readline ( ) : NEW_LINE INDENT return sys . stdin . readline ( ) [ : - 1 ] NEW_LINE DEDENT def readnums ( ) : NEW_LINE INDENT n = readline ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT ls = [ i ] . split ( ) NEW_LINE if ns == 1 : NEW_LINE INDENT ls . append ( ns ) NEW_LINE DEDENT else : NEW_LINE INDENT ls = ns NEW_LINE DEDENT DEDENT T = int ( raw_input ( ) ) NEW_LINE for i in range ( 1 , T + 1 ) : NEW_LINE INDENT N , m = readline ( ) . split ( ) NEW_LINE ls = [ line [ i ] for i in range ( N ) ] NEW_LINE if ls [ 0 ] . ls [ 0 ] . split ( ls [ 1 ] ) > 1 : NEW_LINE INDENT print \" Case ▁ # % d : ▁ % d \" % ( i + 1 , sep = \" ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print \" Case ▁ # % d : ▁ % d \" % ( i + 1 , sep = \" \" ) NEW_LINE DEDENT DEDENT"],"references":["import sys NEW_LINE T = int ( sys . stdin . readline ( ) ) NEW_LINE for ca in xrange ( 1 , T + 1 ) : NEW_LINE INDENT [ X , Y ] = [ int ( v ) for v in sys . stdin . readline ( ) . split ( \" ▁ \" ) ] NEW_LINE print \" Case ▁ # % d : ▁ \" % ca , NEW_LINE if X > 0 : NEW_LINE INDENT for i in range ( X ) : NEW_LINE INDENT sys . stdout . write ( \" W \" ) , NEW_LINE sys . stdout . write ( \" E \" ) , NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT X = - X NEW_LINE for i in range ( X ) : NEW_LINE INDENT sys . stdout . write ( \" E \" ) , NEW_LINE sys . stdout . write ( \" W \" ) , NEW_LINE DEDENT DEDENT if Y > 0 : NEW_LINE INDENT for i in range ( Y ) : NEW_LINE INDENT sys . stdout . write ( \" S \" ) , NEW_LINE sys . stdout . write ( \" N \" ) , NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT Y = - Y NEW_LINE for i in range ( Y ) : NEW_LINE INDENT sys . stdout . write ( \" N \" ) , NEW_LINE sys . stdout . write ( \" S \" ) , NEW_LINE DEDENT DEDENT print \" \" NEW_LINE DEDENT","def check ( xx , yy ) : NEW_LINE INDENT points = set ( [ ( 0 , 0 ) ] ) NEW_LINE for step in range ( 30 ) : NEW_LINE INDENT t1 = ( 0 , 0 ) in points NEW_LINE t2 = step % 4 in ( 0 , 3 ) NEW_LINE d = step + 1 NEW_LINE if ( xx , yy ) in points : NEW_LINE INDENT return step NEW_LINE DEDENT points = set ( [ a for b in [ [ ( x + d , y ) , ( x - d , y ) , ( x , y + d ) , ( x , y - d ) ] for x , y in points ] for a in b ] ) NEW_LINE DEDENT DEDENT def calc ( x , y ) : NEW_LINE INDENT d = s = 0 NEW_LINE while s < abs ( x ) + abs ( y ) : NEW_LINE INDENT d += 1 NEW_LINE s += d NEW_LINE DEDENT add_zero = d % 4 in ( 0 , 3 ) NEW_LINE while ( ( abs ( x ) + abs ( y ) ) % 2 == 0 ) != ( d % 4 in ( 0 , 3 ) ) : NEW_LINE INDENT d += 1 NEW_LINE s += d NEW_LINE DEDENT res = ' ' NEW_LINE for i in range ( d , 0 , - 1 ) : NEW_LINE INDENT if abs ( x ) > abs ( y ) and x > 0 : NEW_LINE INDENT x -= i NEW_LINE res = ' E ' + res NEW_LINE DEDENT elif abs ( x ) > abs ( y ) : NEW_LINE INDENT x += i NEW_LINE res = ' W ' + res NEW_LINE DEDENT elif y > 0 : NEW_LINE INDENT y -= i NEW_LINE res = ' N ' + res NEW_LINE DEDENT else : NEW_LINE INDENT y += i NEW_LINE res = ' S ' + res NEW_LINE DEDENT DEDENT assert ( x , y ) == ( 0 , 0 ) , ( x , y , d ) NEW_LINE return res NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE res = calc ( x , y ) NEW_LINE print ( res ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT T = int ( input ( ) ) NEW_LINE for t in range ( 1 , T + 1 ) : NEW_LINE INDENT print ( \" Case ▁ # % d : \" % t , end = ' ▁ ' ) NEW_LINE solve ( ) NEW_LINE DEDENT DEDENT","import sys NEW_LINE import math NEW_LINE import string NEW_LINE import pdb NEW_LINE def docase ( f , casenum ) : NEW_LINE INDENT data = f . next ( ) . split ( ) NEW_LINE X = int ( data [ 0 ] ) NEW_LINE Y = int ( data [ 1 ] ) NEW_LINE abssum = abs ( X ) + abs ( Y ) NEW_LINE n = int ( math . sqrt ( 2 * abssum ) ) NEW_LINE found = False NEW_LINE while not found : NEW_LINE INDENT val = n * ( n + 1 ) \/ 2 NEW_LINE if val >= abssum and ( val - abssum ) % 2 == 0 : NEW_LINE INDENT found = True NEW_LINE break NEW_LINE DEDENT n += 1 NEW_LINE DEDENT result = \" \" NEW_LINE result = [ ] NEW_LINE for i in xrange ( n , 0 , - 1 ) : NEW_LINE INDENT if abs ( X ) > abs ( Y ) : NEW_LINE INDENT if X > 0 : NEW_LINE INDENT result . append ( \" E \" ) NEW_LINE X -= i NEW_LINE DEDENT else : NEW_LINE INDENT result . append ( \" W \" ) NEW_LINE X += i NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if Y > 0 : NEW_LINE INDENT result . append ( \" N \" ) NEW_LINE Y -= i NEW_LINE DEDENT else : NEW_LINE INDENT result . append ( \" S \" ) NEW_LINE Y += i NEW_LINE DEDENT DEDENT DEDENT result . reverse ( ) NEW_LINE strres = \" \" . join ( result ) NEW_LINE print \" Case ▁ # \" + str ( casenum ) + \" : ▁ \" + strres NEW_LINE DEDENT with open ( sys . argv [ 1 ] , \" r \" ) as f : NEW_LINE INDENT T = int ( f . next ( ) ) NEW_LINE for k in xrange ( T ) : NEW_LINE INDENT docase ( f , k + 1 ) NEW_LINE DEDENT DEDENT"],"bleu":0.3750992366419014,"rouge_l":0.39998588647077093}
{"id":169,"predictions":["n = input ( ) if ( len ( n ) == 0 ) : print ( \" No \" ) else : print ( \" Yes \" ) print ( n ) NEW_LINE"],"references":["import re     def is_int ( s : str ) -> bool : if len ( s ) > 0 and ( s [ 0 ] == \"0\" and len ( s ) > 1 ) : return False else : try : int ( s ) return True except : return False     def partition ( pred , iterable ) : trues = [ ] falses = [ ] for item in iterable : if pred ( item ) : trues . append ( item ) else : falses . append ( item ) return trues , falses     def print_ans ( s ) : if len ( s ) > 0 : print ( \" \\ \" { } \\ \" \" . format ( \" , \" . join ( s ) ) ) else : print ( \" - \" )     s = re . split ( \" ; | , \" , input ( ) ) s_int , s_str = partition ( is_int , s ) print_ans ( s_int ) print_ans ( s_str ) NEW_LINE","s = input ( ) . replace ( \" ; \" , \" , \" ) . split ( \" , \" ) a = [ ] b = [ ] for w in s : if w . isdigit ( ) and ( w == \"0\" or w [ 0 ] != \"0\" ) : a . append ( w ) else : b . append ( w )   for v in a , b : print ( ' \" { } \" ' . format ( ' , ' . join ( v ) ) if v else ' - ' ) NEW_LINE","s = input ( ) . replace ( \" ; \" , \" , \" ) . split ( \" , \" ) fs = [ ] ss = [ ] for i in s : if ( i . isdecimal ( ) ) : if ( len ( i ) == 1 and i [ 0 ] == '0' ) : fs . append ( i ) elif ( len ( i ) != 1 and i [ 0 ] == '0' ) : ss . append ( i ) else : fs . append ( i ) else : ss . append ( i ) if fs : print ( ' \" ' + ' , ' . join ( fs ) + ' \" ' ) else : print ( ' - ' )   if ss : print ( ' \" ' + ' , ' . join ( ss ) + ' \" ' ) else : print ( ' - ' ) NEW_LINE"],"bleu":0.055564432120404614,"rouge_l":0.3008410376920937}
{"id":170,"predictions":["for _ in range ( int ( input ( ) ) ) : a , b , c , n = map ( int , input ( ) . split ( ) ) if ( a <= n ) : print ( - 1 ) else : if ( b <= a and c <= b ) : print ( ( 0 ) else : print ( 1 ) NEW_LINE"],"references":["def solve ( ) : b , p , f = map ( int , input ( ) . split ( ) ) h , c = map ( int , input ( ) . split ( ) )   NEW_LINE","for _ in range ( int ( input ( ) ) ) : b , p , f = map ( int , input ( ) . split ( ) ) h , c = map ( int , input ( ) . split ( ) )   if h > c : r = min ( b \/\/ 2 , p ) ans = r * h + min ( ( b - 2 * r ) \/\/ 2 , f ) * c else : r = min ( b \/\/ 2 , f ) ans = r * c + min ( ( b - 2 * r ) \/\/ 2 , p ) * h   print ( ans ) NEW_LINE","import sys   T = int ( sys . stdin . readline ( ) )   for i in range ( T ) : b , p , f = map ( int , sys . stdin . readline ( ) . split ( ) ) h , c = map ( int , sys . stdin . readline ( ) . split ( ) ) answer = 0 if b < 2 : print ( 0 ) else : big_price = max ( h , c ) small_price = min ( h , c ) if big_price == c : big = f small = p else : big = p small = f while True : if b < 2 : break if big > 0 : b -= 2 big -= 1 answer += big_price elif big == 0 : b -= 2 small -= 1 answer += small_price if big == 0 and small == 0 : break print ( answer ) NEW_LINE"],"bleu":0.517042973367039,"rouge_l":0.648913573368619}
{"id":171,"predictions":["h , m = [ y for y in input ( ) . split ( \" : \" ) ] h , m = int ( h ) , int ( m [ 0 ] ) , int ( m [ 1 ] ) , int ( m [ 2 ] ) m = int ( m [ 0 ] ) , int ( m [ 0 ] ) = int ( m [ 0 ] ) , int ( m [ 1 ] ) for i in range ( h ) : s = input ( ) . split ( \" : \" ) s [ s [ 0 ] ] += s [ 1 ] + m [ 1 ] ans = ( h - s [ r ] ) print ( ans ) NEW_LINE"],"references":["a = input ( ) . split ( ' : ' ) b = input ( ) . split ( ' : ' )       x = int ( a [ 0 ] ) * 60 + int ( a [ 1 ] ) y = int ( b [ 0 ] ) * 60 + int ( b [ 1 ] )     if y > x : x = ( ( int ( a [ 0 ] ) + 24 ) * 60 ) + int ( a [ 1 ] )     z = x - y   hr = str ( z \/\/ 60 ) . rjust ( 2 , '0' ) z %= 60 mi = str ( z ) . rjust ( 2 , '0' )   print ( f \" { hr } : { mi } \" )   NEW_LINE","def time ( h , m ) : if h < 0 : h += 24 if h < 10 : h = f ' {0 } { h } ' if m < 10 : m = f ' {0 } { m } ' return f ' { h } : { m } '   def solve ( s , t ) : sh , sm = map ( int , s . split ( ' : ' ) ) th , tm = map ( int , t . split ( ' : ' ) ) tot_s = sh * 60 + sm tot_t = th * 60 + tm res = tot_s - tot_t return time ( res \/\/ 60 , res % 60 )             def main ( ) : NEW_LINE","woke_hr , woke_min = map ( int , input ( ) . split ( \" : \" ) ) dur_hr , dur_min = map ( int , input ( ) . split ( \" : \" ) ) st_sleep_hr , st_sleep_min = 0 , 0   if woke_min < dur_min : st_sleep_min = ( 60 + woke_min ) - dur_min ; dur_hr += 1 else : st_sleep_min = woke_min - dur_min   if st_sleep_min in range ( 0 , 10 ) : st_sleep_min = \"0\" + str ( st_sleep_min ) else : st_sleep_min = str ( st_sleep_min )   st_sleep_hr = ( woke_hr - dur_hr ) % 24   if st_sleep_hr in range ( 0 , 10 ) : st_sleep_hr = \"0\" + str ( st_sleep_hr ) else : st_sleep_hr = str ( st_sleep_hr )   print ( \" \" . join ( [ st_sleep_hr , \" : \" , st_sleep_min ] ) ) NEW_LINE"],"bleu":0.33309837117011976,"rouge_l":0.42508710801393723}
{"id":172,"predictions":["import sys   def main ( ) : inp = sys . stdin . read ( ) . strip ( ) . split ( ' \\n ' ) out = [ ] for i in range ( 2 , len ( inp ) , 3 ) : a , b = map ( int , inp [ i ] . split ( ) ) b = list ( map ( int , inp [ i ] . split ( ) ) ) out . append ( ( a , b ) ) return out   print ( main ( ) ) NEW_LINE"],"references":["n = int ( input ( ) ) nn = list ( map ( int , input ( ) . split ( ) ) ) m = int ( input ( ) ) mm = list ( map ( int , input ( ) . split ( ) ) ) nn . sort ( ) mm . sort ( ) i = 0j = 0 count = 0   while i < n and j < m : if abs ( nn [ i ] - mm [ j ] ) <= 1 : count += 1 i += 1 j += 1 elif nn [ i ] < mm [ j ] : i += 1 else : j += 1 print ( count ) NEW_LINE","n = int ( input ( ) ) b = list ( map ( int , input ( ) . split ( ) ) ) m = int ( input ( ) ) g = list ( map ( int , input ( ) . split ( ) ) ) b . sort ( ) g . sort ( ) i , j = 0 , 0 ans = 0 while i < n and j < m : if abs ( b [ i ] - g [ j ] ) <= 1 : ans += 1 i += 1 j += 1 else : if b [ i ] < g [ j ] : i += 1 else : j += 1 print ( ans ) NEW_LINE","n = int ( input ( ) ) list_n = list ( map ( int , input ( ) . split ( ) ) ) m = int ( input ( ) ) list_m = list ( map ( int , input ( ) . split ( ) ) ) x = 0 z = 0 cnt = 0 if n > m : list_m , list_n = list_n , list_mlist_n . sort ( ) list_m . sort ( ) while len ( list_n ) != 0 : if abs ( list_n [ x ] - list_m [ z ] ) <= 1 : cnt += 1 del list_n [ x ] del list_m [ z ] z = 0 else : z += 1 if z == len ( list_m ) : del list_n [ x ] z = 0 print ( cnt ) NEW_LINE"],"bleu":0.24576608207591844,"rouge_l":0.33748271092669435}
{"id":173,"predictions":["import math , sys , bisect , heapq , osfrom collections import defaultdict , Counter , dequefrom itertools import groupby , accumulatefrom functools import lru_cache NEW_LINE"],"references":["n = int ( input ( ) )     if n == 1 : print ( ' Ehab ' ) elif n % 2 == 0 : print ( ' Mahmoud ' ) else : print ( ' Ehab ' ) NEW_LINE","from __future__ import division , print_functionfrom collections import * from math import * from itertools import * from time import timeimport osimport sysfrom io import BytesIO , IOBase   if sys . version_info [ 0 ] < 3 : from __builtin__ import xrange as range from future_builtins import ascii , filter , hex , map , oct , zip   def main ( ) : n = int ( input ( ) ) if n % 2 == 0 : print ( ' Mahmoud ' ) else : print ( ' Ehab ' )     NEW_LINE","n = int ( input ( ) )   if ( n % 2 ) == 0 : print ( ' Mahmoud ' ) else : print ( ' Ehab ' ) NEW_LINE"],"bleu":0.08328152131270573,"rouge_l":0.14727184934814097}
{"id":174,"predictions":["import sysinput = sys . stdin . readlinefrom math import * import bisect as bsn = int ( input ( ) ) a = [ int ( x ) for x in input ( ) . split ( ) ] b = [ int ( x ) for x in input ( ) . split ( ) ] d = { } for i in range ( n ) : d [ b [ i ] [ i ] ] = i   c = 0 u = [ 0 for i in range ( n ) ] for i in range ( n ) : u [ i ] = d [ u [ i ] NEW_LINE"],"references":["import sysinput = sys . stdin . buffer . readline   n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) )   ''' diffs ▁ = [ ] miss ▁ = ▁ set ( list ( range ( 1 , n + 1 ) ) ) for ▁ i ▁ in ▁ range ( n ) : ▁ ▁ ▁ ▁ if ▁ a [ i ] ▁ ! = ▁ b [ i ] : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ diffs . append ( i ) ▁ ▁ ▁ ▁ miss . discard ( a [ i ] )  if ▁ len ( diffs ) ▁ = = ▁ 1 : ▁ ▁ ▁ ▁ # ▁ no ▁ other ▁ option ▁ ▁ ▁ ▁ a [ diffs [ 0 ] ] ▁ = ▁ list ( miss ) [0 ] else : ▁ ▁ ▁ ▁ # ▁ must ▁ be ▁ 2 ▁ ▁ ▁ ▁ if ▁ { a [ diffs [ 0 ] ] , b [ diffs [ 1 ] ] } ▁ = = ▁ miss : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ a [ diffs [ 1 ] ] ▁ = ▁ b [ diffs [ 1 ] ] ▁ ▁ ▁ ▁ else : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ a [ diffs [ 0 ] ] ▁ = ▁ b [ diffs [ 0 ] ] '''   two = - 1 missing = - 1   counts = [ [ ] for i in range ( n + 1 ) ] for i in range ( n ) : counts [ a [ i ] ] . append ( i ) if len ( counts [ a [ i ] ] ) == 2 : two = a [ i ]   for i in range ( 1 , n + 1 ) : if len ( counts [ i ] ) == 0 : missing = i break   def diff ( a , b ) : diffs = 0 for i in range ( n ) : diffs += a [ i ] != b [ i ] return diffs   for i in range ( 2 ) : perm = a . copy ( ) perm [ counts [ two ] [ i ] ] = missing   if diff ( perm , b ) == 1 : print ( * perm ) break NEW_LINE","def STR ( ) : return list ( input ( ) ) def INT ( ) : return int ( input ( ) ) def MAP ( ) : return map ( int , input ( ) . split ( ) ) def MAP2 ( ) : return map ( float , input ( ) . split ( ) ) def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) def STRING ( ) : return input ( ) import stringimport sysfrom heapq import heappop , heappushfrom bisect import * from collections import deque , Counterfrom math import * from itertools import permutations , accumulatedx = [ - 1 , 1 , 0 , 0 ] dy = [ 0 , 0 , 1 , - 1 ] NEW_LINE","from collections import Countern = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) lst = [ - 1 ] * ncf = Counter ( a ) cs = Counter ( b ) miss1 = 0 miss2 = 0 for i in range ( 1 , n + 1 ) : if cf [ i ] == 0 : miss1 = i if cs [ i ] == 0 : miss2 = is = 0 cnt = 0 for i in range ( n ) : if a [ i ] == b [ i ] : lst [ i ] = a [ i ] s += a [ i ] else : cnt += 1 if cnt == 1 : for i in range ( n ) : if lst [ i ] == - 1 : print ( ( ( n * ( n + 1 ) ) \/\/ 2 ) - s , end = \" ▁ \" ) else : print ( lst [ i ] , end = \" ▁ \" ) elif cnt == 0 : for i in range ( n ) : if cf [ a [ i ] ] != 2 : print ( a [ i ] , end = \" ▁ \" ) else : print ( miss1 , end = \" \" ) else : pp = [ ] f = 0 qq = [ ] l = [ miss1 , miss2 ] for i in range ( n ) : if lst [ i ] != - 1 : pp . append ( lst [ i ] ) qq . append ( lst [ i ] ) else : if f == 0 : pp . append ( miss1 ) qq . append ( miss2 ) f = 1 else : pp . append ( miss2 ) qq . append ( miss1 ) first = 0 second = 0 for i in range ( n ) : if pp [ i ] not in [ a [ i ] , b [ i ] ] : first = 1 if qq [ i ] not in [ a [ i ] , b [ i ] ] : second = 1 if first == 0 : print ( * pp ) else : print ( * qq )   NEW_LINE"],"bleu":0.45154745661135626,"rouge_l":0.36453283996299723}
{"id":175,"predictions":["def solve ( l , v , g , b , c ) :   NEW_LINE"],"references":["import sysimport mathdef fn ( l , d , v , g , r ) : t = float ( d ) \/ float ( v ) if t < g : return float ( l ) \/ float ( v ) elif t <= g + r : t = g + r return t + ( float ( l ) - float ( d ) ) \/ float ( v ) elif t > g + r : t1 = t k = t \/\/ ( g + r ) t = t - k * ( g + r ) if t < g : return float ( l ) \/ float ( v ) elif t <= g + r : t = g + r return ( k + 1 ) * t + ( float ( l ) - float ( d ) ) \/ float ( v ) if __name__ == ' _ _ main _ _ ' : input = sys . stdin . read ( ) data = list ( map ( int , input . split ( ) ) ) l = ( data [ 0 ] ) d = data [ 1 ] v = data [ 2 ] g = data [ 3 ] r = data [ 4 ] print ( fn ( l , d , v , g , r ) ) NEW_LINE","l , d , v , g , r = map ( int , input ( ) . split ( ) ) time = d \/ vif time < g : print ( l \/ v ) elif time == g : print ( d \/ v + r - ( d \/ v - g ) + ( l - d ) \/ v ) else : time = d \/ v c = time % ( g + r ) if c == 0 or c < g : print ( l \/ v ) else : print ( d \/ v + r - ( time % ( g + r ) - g ) + ( l - d ) \/ v )   NEW_LINE","def solve ( ) : l , d , v , g , r = [ int ( x ) for x in input ( ) . split ( ' ▁ ' ) ] NEW_LINE"],"bleu":0.13143498333498477,"rouge_l":0.41250000000000003}
{"id":176,"predictions":["f = lambda : map ( int , input ( ) . split ( ) ) s , q = f ( ) t = [ input ( ) for _ in range ( h ) ] for i in range ( w ) : print ( ' ' . join ( s ) [ i ] . join ( s [ i : ] ) ) ) NEW_LINE"],"references":["from itertools import permutationsfrom sys import stdin , stdoutly , lx = map ( int , input ( ) . split ( ) ) grid = [ [ c for c in inp ] for inp in stdin . read ( ) . splitlines ( ) ]   first = set ( ) bl = [ ] bpattern = [ ] bcost = 1e6 flip_row = False   for l in permutations ( ' AGCT ' ) : if bcost == 0 : break if ' ' . join ( l [ : 2 ] ) in first : continue   first |= set ( [ ' ' . join ( l [ : 2 ] ) , ' ' . join ( l [ 1 : : - 1 ] ) ] ) NEW_LINE","from itertools import permutationsfrom sys import stdin , stdoutly , lx = map ( int , input ( ) . split ( ) ) grid = [ [ c for c in inp ] for inp in stdin . read ( ) . splitlines ( ) ]   first = set ( ) bl = [ ] bpattern = [ ] bcost = 1e6 flip_row = False   for l in permutations ( ' AGCT ' ) : if bcost == 0 : break if ' ' . join ( l [ : 2 ] ) in first : continue   first |= set ( [ ' ' . join ( l [ : 2 ] ) , ' ' . join ( l [ 1 : : - 1 ] ) ] ) NEW_LINE","from itertools import permutationsfrom sys import stdin , stdoutly , lx = map ( int , input ( ) . split ( ) ) grid = [ [ c for c in inp ] for inp in stdin . read ( ) . splitlines ( ) ]   first = set ( ) bl = [ ] bpattern = [ ] bcost = 1e6 flip_row = False   for l in permutations ( ' AGCT ' ) : if bcost == 0 : break if ' ' . join ( l [ : 2 ] ) in first : continue   first |= set ( [ ' ' . join ( l [ : 2 ] ) , ' ' . join ( l [ 1 : : - 1 ] ) ] ) NEW_LINE"],"bleu":0.13137037733530488,"rouge_l":0.39832953682612}
{"id":177,"predictions":["a , b , c , d = map ( int , input ( ) . split ( ) ) result = ( a * d ) \/ ( b * c ) print ( result ) NEW_LINE"],"references":["line1 = input ( ) . split ( \" ▁ \" ) line2 = input ( ) . split ( \" ▁ \" ) A1 = int ( line1 [ 0 ] ) A2 = int ( line2 [ 0 ] ) B1 = int ( line1 [ 1 ] ) B2 = int ( line2 [ 1 ] ) C1 = int ( line1 [ 2 ] ) C2 = int ( line2 [ 2 ] )   Z = lambda x , y , z : not x and not y and z   if A1 * B2 - A2 * B1 : print ( 1 ) elif Z ( A1 , B1 , C1 ) or Z ( A2 , B2 , C2 ) or ( C1 * B2 - C2 * B1 ) or ( A1 * C2 - A2 * C1 ) : print ( 0 ) else : print ( - 1 )   NEW_LINE","def plane ( a , b , c ) : if a == b == 0 != c : return 0 else : return - 1   def hline ( b1 , c1 , a2 , b2 , c2 ) : if b1 == 0 : if c1 == 0 : return plane ( a2 , b2 , c2 ) else : return - 1 elif a2 == 0 : if b2 == 0 != c2 : return 0 elif c2 * b1 == c1 * b2 : return - 1 else : return 0 else : return 1   def vline ( a1 , c1 , a2 , b2 , c2 ) : return hline ( a1 , c1 , b2 , a2 , c2 )     def intersect ( a1 , b1 , c1 , a2 , b2 , c2 ) : if a1 == b1 == 0 : if c1 == 0 : return plane ( a2 , b2 , c2 ) else : return 0 if a1 == 0 : return hline ( b1 , c1 , a2 , b2 , c2 ) if b1 == 0 : return vline ( a1 , c1 , a2 , b2 , c2 ) if a2 == b2 == 0 : if c2 == 0 : return plane ( a1 , b1 , c1 ) else : return 0 if a2 == 0 : return hline ( b2 , c2 , a1 , b1 , c1 ) if b2 == 0 : return vline ( a2 , c2 , a1 , b1 , c1 ) else : if a1 * b2 == a2 * b1 : if c1 * a2 == c2 * a1 : return - 1 else : return 0 else : return 1         a1 , b1 , c1 = map ( int , input ( ) . split ( ) ) a2 , b2 , c2 = map ( int , input ( ) . split ( ) )   print ( intersect ( a1 , b1 , c1 , a2 , b2 , c2 ) )     NEW_LINE","a , b , c = map ( int , input ( ) . split ( ) ) d , e , f = map ( int , input ( ) . split ( ) ) def F ( i , j , k ) : return not i and not j and kprint ( 1 if d * b - a * e else 0 if F ( a , b , c ) or F ( d , e , f ) or c * e - b * f or a * f - c * d else - 1 ) NEW_LINE"],"bleu":0.09517187150584061,"rouge_l":0.38689217758985206}
{"id":178,"predictions":["from sys import stdin , stdoutfrom os import pathrd = lambda : stdin . readline ( ) . strip ( ) wr = stdout . writeif ( path . exists ( ' input . txt ' ) ) : stdin = open ( \" input . txt \" , \" r \" ) import time , math NEW_LINE"],"references":["import sysinput = sys . stdin . readline   from bisect import bisect_left as bs   '''   '''   def solve ( n , a ) : b = a [ : : ] b . sort ( ) done = [ 0 ] * n   res = [ ] for i in range ( n ) : if not done [ i ] : if a [ i ] == b [ i ] : res . append ( [ i + 1 ] ) done [ i ] = 1 else : r = [ ] while not done [ i ] : r . append ( i + 1 ) done [ i ] = 1 i = bs ( b , a [ i ] ) res . append ( r ) return res                                   n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) )   res = solve ( n , a ) print ( len ( res ) ) for r in res : print ( len ( r ) , * r ) NEW_LINE","from sys import stdin , stdout   def find ( node ) : x = [ ] while dsu [ node ] > 0 : x . append ( node ) node = dsu [ node ] for i in x : dsu [ i ] = node return node   def union ( node1 , node2 ) : if node1 != node2 : if dsu [ node1 ] > dsu [ node2 ] : node1 , node2 = node2 , node1 dsu [ node1 ] += dsu [ node2 ] dsu [ node2 ] = node1     n = int ( stdin . readline ( ) . strip ( ) ) arr = [ ( int ( j ) , i ) for i , j in enumerate ( stdin . readline ( ) . strip ( ) . split ( ) ) ] arr = sorted ( arr , key = lambda t : t [ 0 ] , reverse = False ) dsu = [ - 1 ] * ( n + 1 ) for i in range ( n ) : p_a = find ( arr [ i ] [ 1 ] + 1 ) p_b = find ( i + 1 ) union ( p_a , p_b ) k = 0 outputs = [ [ ] for __ in range ( n + 1 ) ] for i in range ( 1 , n + 1 ) : if dsu [ i ] < 0 : k += 1 outputs [ find ( i ) ] . append ( f ' { i } ' ) stdout . write ( f ' { k } \\n ' ) for output in outputs : if output : stdout . write ( f ' { len ( output ) } ▁ ' ) stdout . write ( ' ▁ ' . join ( output ) + ' \\n ' )                 NEW_LINE","from sys import stdin , stdout   def find ( node ) : x = [ ] while dsu [ node ] > 0 : x . append ( node ) node = dsu [ node ] for i in x : dsu [ i ] = node return node   def union ( node1 , node2 ) : if node1 != node2 : if dsu [ node1 ] > dsu [ node2 ] : node1 , node2 = node2 , node1 dsu [ node1 ] += dsu [ node2 ] dsu [ node2 ] = node1     n = int ( stdin . readline ( ) . strip ( ) ) arr = [ ( int ( j ) , i ) for i , j in enumerate ( stdin . readline ( ) . strip ( ) . split ( ) ) ] arr = sorted ( arr , key = lambda t : t [ 0 ] , reverse = False ) dsu = [ - 1 ] * ( n + 1 ) for i in range ( n ) : p_a = find ( arr [ i ] [ 1 ] + 1 ) p_b = find ( i + 1 ) union ( p_a , p_b ) k = 0 outputs = [ [ ] for __ in range ( n + 1 ) ] for i in range ( 1 , n + 1 ) : if dsu [ i ] < 0 : k += 1 outputs [ find ( i ) ] . append ( f ' { i } ' ) stdout . write ( f ' { k } \\n ' ) for output in outputs : if output : stdout . write ( f ' { len ( output ) } ▁ ' ) stdout . write ( ' ▁ ' . join ( output ) + ' \\n ' )                 NEW_LINE"],"bleu":0.029440258940253643,"rouge_l":0.17810818083961252}
{"id":179,"predictions":["for _ in range ( int ( input ( ) ) ) : k , x = map ( int , input ( ) . split ( ) ) print ( 9 * ( k - 1 ) + x ) NEW_LINE"],"references":["for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) s = input ( ) m = n - 1 for i in range ( n ) : if s [ i ] == ' > ' or s [ n - 1 - i ] == ' < ' : m = min ( m , i ) print ( m ) NEW_LINE","for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) s = input ( ) if n == 1 : print ( 0 ) else : if s [ 0 ] == ' > ' or s [ - 1 ] == ' < ' : print ( 0 ) else : a = s . index ( ' > ' ) b = s [ : : - 1 ] . index ( ' < ' ) print ( min ( a , b ) ) NEW_LINE","t = int ( input ( ) ) for _ in range ( t ) : n = int ( input ( ) ) s = input ( ) ind1 = - 1 ind2 = - 1 g = l = 0 for i in range ( n ) : if s [ i ] == ' > ' : if ind1 == - 1 : ind1 = i + 1 g += 1 else : ind2 = i l += 1 if ind1 == - 1 : ind1 = n if ind2 == - 1 : ind2 = n ans = min ( s [ : ind1 ] . count ( ' < ' ) , s [ ind2 : ] . count ( ' > ' ) , g , l ) print ( ans ) NEW_LINE"],"bleu":0.205031714663312,"rouge_l":0.4355492424242424}
{"id":180,"predictions":["t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : n , m , r = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE p = [ 0 ] * m NEW_LINE f = 0 NEW_LINE for i in range ( n ) : l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if not p [ l ] : NEW_LINE INDENT p [ l ] = l NEW_LINE DEDENT f = 1 NEW_LINE for i in range ( r ) : NEW_LINE INDENT if s [ i ] == s [ r [ i ] : NEW_LINE INDENT f = 1 NEW_LINE break NEW_LINE DEDENT if s [ r ] == s [ r [ l ] : NEW_LINE INDENT p [ l ] = r [ l ] NEW_LINE DEDENT f = 1 NEW_LINE break NEW_LINE DEDENT print ( f + 1 ) NEW_LINE"],"references":["import sys , io , os NEW_LINE if os . environ [ ' USERNAME ' ] == ' kissz ' : inp1 = inp2 = open ( ' in . txt ' , ' r ' ) . readline NEW_LINE def debug ( * args ) : print ( * args , file = sys . stderr ) NEW_LINE else : NEW_LINE","import osimport NEW_LINE sysfrom NEW_LINE io NEW_LINE import BytesIO , IOBase NEW_LINE","import osimport NEW_LINE sysfrom NEW_LINE io NEW_LINE import BytesIO , IOBase NEW_LINE"],"bleu":0.023005567083893563,"rouge_l":0.19424798042436228}
{"id":181,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["import sys , os , ioimport math , bisect , operatorinf , mod = float ( ' inf ' ) , 10 ** 9 + 7 NEW_LINE","import sys   n = int ( input ( ) ) a = list ( map ( lambda x : int ( x ) , sys . stdin . readline ( ) . split ( ) ) ) matrix = [ ] for _ in range ( n ) : row = input ( ) row = list ( row ) row = list ( map ( lambda x : int ( x ) , row ) ) matrix . append ( row )   class DisjSet : def __init__ ( self , n ) : NEW_LINE","from bisect import * from collections import * from math import gcd , ceil , sqrt , floor , inffrom heapq import * from itertools import * from operator import add , mul , sub , xor , truediv , floordivfrom functools import *   NEW_LINE"],"bleu":0.4646770361393315,"rouge_l":0.43132633383329766}
{"id":182,"predictions":["s = input ( ) j = len ( s ) - 1 i = 0 while i <= j : c = 0 p = s [ i ] if p != s [ j ] : exit ( print ( 0 ) ) while i <= j and s [ i ] == p : i += 1 c += 1 while i <= j and s [ j ] == p : j -= 1 c += 1 if c <= 2 and i < j : exit ( print ( 0 ) ) if c > 1 : print ( c + 1 ) else : print ( 0 ) NEW_LINE"],"references":["n , k = map ( int , input ( ) . split ( ) ) ; s = [ i for i in str ( n ) ] ; i = 0 n = len ( s ) for i in range ( n ) : x = i for j in range ( i + 1 , min ( n , i + k + 1 ) ) : if s [ x ] < s [ j ] : x = j NEW_LINE","a , k = map ( int , input ( ) . split ( ) ) a = list ( str ( a ) ) b = \" \" while ( len ( a ) > 0 ) : m = a . index ( max ( a [ : k + 1 ] ) ) k -= m b += a [ m ] a . pop ( m ) print ( b ) NEW_LINE","arr = list ( input ( ) . split ( ) ) s = list ( arr [ 0 ] ) k = int ( arr [ 1 ] ) ans = [ ]   while s : x = s . index ( max ( s [ : k + 1 ] ) ) ans . append ( s [ x ] ) s . pop ( x ) k -= xprint ( ' ' . join ( ans ) ) NEW_LINE"],"bleu":0.144825710498311,"rouge_l":0.3017226675763261}
{"id":183,"predictions":["import sys , mathfrom collections import deque , defaultdictimport operator as opfrom functools import reducefrom itertools import permutations   NEW_LINE"],"references":["for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) if ( n * ( n - 1 ) \/ 2 ) % 2 == 0 : a = list ( range ( 2 , n + 1 , 2 ) ) b = list ( range ( 1 , n - 1 , 2 ) ) print ( \" YES \" ) print ( * list ( a + b + [ sum ( a ) - sum ( b ) ] ) ) else : print ( \" NO \" ) NEW_LINE","t = int ( input ( ) ) for _ in range ( t ) : n = int ( input ( ) ) a = [ 0 ] * n if ( n % 4 == 0 ) : print ( \" YES \" ) q = 2 for i in range ( 0 , n \/\/ 2 ) : a [ i ] = q q += 2 q = 1 for i in range ( n \/\/ 2 , n ) : a [ i ] = q q += 2 a [ - 1 ] += n \/\/ 2 print ( * a ) else : print ( \" NO \" ) NEW_LINE","if __name__ == ' _ _ main _ _ ' : t = int ( input ( ) ) for i in range ( t ) : n = int ( input ( ) ) times = int ( n \/ 2 ) if times % 2 == 1 : print ( \" NO \" ) continue else : a = [ ] a1 = [ ] a2 = [ ] k = 2 h = 1 for i in range ( times ) : a1 . append ( k ) k += 2   diff = 0 for j in range ( times ) : if j == ( times - 1 ) : a2 . append ( a1 [ j ] + diff ) break a2 . append ( h ) h += 2 diff += 1 a = a1 + a2 print ( \" YES \" ) print ( \" ▁ \" . join ( str ( i ) for i in a ) )   NEW_LINE"],"bleu":0.0008286760196313601,"rouge_l":0.042757009345794385}
{"id":184,"predictions":["S = input ( ) best = 0 s = set ( ) for i in range ( len ( S ) ) : s . add ( s [ i ] ) for i in range ( len ( S ) ) : if s [ i ] not in s : best = max ( best , s [ i ] ) print ( best ) NEW_LINE"],"references":["word = input ( ) ans = 0 num = { }   for i in word : num [ i ] = num . get ( i , 0 ) + 1   for j in num . values ( ) : ans += j ** 2   print ( ans ) NEW_LINE","m = input ( ) n = { } s = 0 for each in m : n [ each ] = n . get ( each , 0 ) + 1 for i in n : s += n [ i ] * n [ i ] print ( s ) NEW_LINE","n = input ( ) m = list ( str ( n ) ) a = [ ] for x in set ( m ) : a . append ( m . count ( x ) ) b = 0 for y in range ( len ( a ) ) : b += ( a [ y ] ) ** 2 print ( b ) NEW_LINE"],"bleu":0.22256954010314334,"rouge_l":0.4997988221953985}
{"id":185,"predictions":["n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l . sort ( ) s = set ( ) for i in l : if i in s : print ( i ) break NEW_LINE"],"references":["from sys import stdin , stdoutfrom os import pathif path . exists ( \" input . txt \" ) : stdin = open ( \" input . txt \" , ' r ' ) wr = stdout . writerd = lambda : stdin . readline ( ) . strip ( ) NEW_LINE","def subset ( s1 , s2 ) : d = { } for i in s1 : d [ i ] = 1 flag = 0 for i in s2 : if i not in d : flag = 1 break if flag == 0 : return True else : return False n = int ( input ( ) ) l = [ ] for i in range ( n ) : l . append ( list ( map ( int , input ( ) . split ( ) ) ) [ 1 : ] ) for i in range ( n ) : ans = ' YES ' for j in range ( n ) : if i != j : if subset ( l [ i ] , l [ j ] ) : ans = \" NO \" break print ( ans ) NEW_LINE","a = int ( input ( ) ) ; l = [ list ( map ( int , input ( ) . split ( ) [ 1 : ] ) ) for _ in \" ▁ \" * a ] for i in range ( a ) : for j in range ( a ) : if i != j and all ( k in l [ i ] for k in l [ j ] ) : print ( \" NO \" ) ; break else : print ( \" YES \" ) NEW_LINE"],"bleu":0.5967297912435404,"rouge_l":0.5067092651757189}
{"id":186,"predictions":["from collections import defaultdict , deque , Counterfrom sys import stdin , stdoutfrom heapq import heappush , heappopimport mathimport ioimport osimport mathimport bisect   NEW_LINE"],"references":["for _ in range ( int ( input ( ) ) ) : n , k = map ( int , input ( ) . split ( ) ) NEW_LINE l = list ( ) NEW_LINE for i in range ( n ) : x = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l . append ( x ) NEW_LINE for i in l : c = 1 NEW_LINE for j in l : if NEW_LINE abs ( i [ 0 ] - j [ 0 ] ) + abs ( i [ 1 ] - j [ 1 ] ) > k : c = 0 NEW_LINE break NEW_LINE if c == 1 : print ( 1 ) NEW_LINE break NEW_LINE if c == 0 : print ( - 1 )   NEW_LINE","def is_ok ( points ) :     NEW_LINE for i in range ( len ( points ) ) : poss = True NEW_LINE for j in range ( len ( points ) ) : if NEW_LINE abs ( points [ i ] [ 0 ] - points [ j ] [ 0 ] ) + abs ( points [ i ] [ 1 ] - points [ j ] [ 1 ] ) > k : NEW_LINE","def solve ( ) : n , k = map ( int , input ( ) . split ( ) ) NEW_LINE p = [ None ] * n NEW_LINE for i in range ( n ) : a , b = map ( int , input ( ) . split ( ) ) NEW_LINE p [ i ] = ( a , b ) NEW_LINE for i in range ( n ) : for NEW_LINE j in range ( n ) : NEW_LINE if abs ( p [ i ] [ 0 ] - p [ j ] [ 0 ] ) + abs ( p [ i ] [ 1 ] - p [ j ] [ 1 ] ) > k : NEW_LINE INDENT break else : NEW_LINE print ( 1 ) NEW_LINE DEDENT return print ( - 1 )   for _ in range ( int ( input ( ) ) ) : solve ( ) NEW_LINE"],"bleu":0.007638199428440589,"rouge_l":0.057000467216944406}
{"id":187,"predictions":["n = int ( input ( ) ) if n == 1 : print ( 1 ) print ( 0 ) else : ans = [ ] for i in range ( n , 0 , - 1 ) : if i % 2 == 0 : ans . append ( 2 ) else : ans . append ( 4 ) print ( * ans ) NEW_LINE"],"references":["n = int ( input ( ) ) if n % 2 == 0 : print ( n \/\/ 2 ) print ( '2 ▁ ' * ( n \/\/ 2 ) ) else : n = n - 3 print ( n \/\/ 2 + 1 ) print ( '2 ▁ ' * ( n \/\/ 2 ) + '3' ) NEW_LINE","n = int ( input ( ) ) ans = [ 2 for i in range ( n \/\/ 2 ) ] if n % 2 : ans [ - 1 ] = 3 print ( n \/\/ 2 ) for x in ans : print ( x , end = \" ▁ \" )     NEW_LINE","n = int ( input ( ) ) if n % 2 == 0 : print ( n \/\/ 2 ) print ( '2 ▁ ' * ( n \/\/ 2 ) , sep = ' ▁ ' ) else : print ( ( n - 3 ) \/\/ 2 + 1 ) print ( '3' , '2 ▁ ' * ( ( n - 3 ) \/\/ 2 ) , sep = ' ▁ ' ) NEW_LINE"],"bleu":0.4065740917628216,"rouge_l":0.50252458145097}
{"id":188,"predictions":["n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) map = { } for i in arr : if i not in map : map [ i ] = 1 else : map [ i ] += 1 max = 0 for i in map : if map [ i ] > max : max = map [ i ] print ( n - max ) NEW_LINE"],"references":["import mathinfo = [ int ( x ) for x in input ( ) . split ( ) ] lanes = info [ 0 ] desks = info [ 1 ] location = info [ 2 ] seats_in_lane = 2 * deskslane = math . ceil ( location \/ seats_in_lane ) starting_group = ( ( lane - 1 ) * seats_in_lane ) + 1 NEW_LINE","s = input ( ) . split ( ) n = int ( s [ 0 ] ) m = int ( s [ 1 ] ) k = int ( s [ 2 ] ) if k % 2 == 0 : k = int ( k \/ 2 ) a = int ( k \/ m ) b = k % m if b != 0 : print ( a + 1 , b , ' R ' ) else : print ( a , m , ' R ' ) else : k = int ( ( k + 1 ) \/ 2 ) a = int ( k \/ m ) b = k % m if b != 0 : print ( a + 1 , b , ' L ' ) else : print ( a , m , ' L ' )                     NEW_LINE","n , m , k = map ( int , input ( ) . split ( ) ) print ( ( k - 1 ) \/\/ ( m * 2 ) + 1 , ( k - 1 ) % ( 2 * m ) \/\/ 2 + 1 , ' R ' if k % 2 == 0 else ' L ' ) NEW_LINE"],"bleu":0.23614421705024763,"rouge_l":0.3693573307721218}
{"id":189,"predictions":["import sysinput = sys . stdin . readline   '''   '''     def read_input ( ) : return sys . stdin . readline ( ) . strip ( )     def get_input ( ) : return map ( int , input ( ) . split ( ) )     s = get_ints_input ( ) a = s [ : : - 1 ] b = s [ : : - 1 ] t = s [ : : - 1 ]   print ( t ) NEW_LINE"],"references":["for _ in range ( int ( input ( ) ) ) : input ( ) NEW_LINE n = [ i for i in input ( ) ] NEW_LINE n . sort ( ) NEW_LINE print ( \" \" . join ( n ) ) NEW_LINE","for nt in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEW_LINE a = list ( input ( ) ) NEW_LINE print ( \" \" . join ( sorted ( a ) ) ) NEW_LINE","t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE i = 0 NEW_LINE j = n - 1 NEW_LINE while ( i < j ) : if NEW_LINE s [ j ] == ' t ' : j -= 1 NEW_LINE if s [ i ] == ' t ' : a = ' ' + s [ i ] NEW_LINE b = ' ' + s [ j ] NEW_LINE s = s [ : i ] + b + s [ i + 1 : ] NEW_LINE s = s [ : j ] + a + s [ j + 1 : ] else : i += 1 NEW_LINE print ( s ) NEW_LINE"],"bleu":0.16777467898166648,"rouge_l":0.4153191489361702}
{"id":190,"predictions":["b = int ( input ( ) ) def make_divisors ( n ) : divisors = [ ] for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : if n % i == 0 : divisors . append ( i ) if i != n \/\/ i : divisors . append ( n \/\/ i ) NEW_LINE"],"references":["def gcd ( a , b ) : while a % b : a , b = b , a % b return ba , b = map ( int , input ( ) . split ( ) ) g = gcd ( a , b ) a \/\/= gb \/\/= gcnt = 0 for i in [ 2 , 3 , 5 ] : while a % i == 0 : a \/\/= i cnt += 1 while b % i == 0 : b \/\/= i cnt += 1 if a == 1 and b == 1 : print ( cnt ) else : print ( - 1 ) NEW_LINE","def reduceToSmallest ( a , table ) : while True : if a % 2 == 0 : table [ 0 ] += 1 a = a \/\/ 2 elif a % 3 == 0 : table [ 1 ] += 1 a = a \/\/ 3 elif a % 5 == 0 : table [ 2 ] += 1 a = a \/\/ 5 else : break return a                                       a , b = list ( map ( int , input ( ) . split ( ) ) ) if a == b : print ( 0 ) else : table = [ 0 ] * 3 table2 = [ 0 ] * 3 smallA = reduceToSmallest ( a , table ) smallB = reduceToSmallest ( b , table2 ) if smallA != smallB : print ( - 1 ) else : print ( abs ( table [ 0 ] - table2 [ 0 ] ) + abs ( table [ 1 ] - table2 [ 1 ] ) + abs ( table [ 2 ] - table2 [ 2 ] ) ) NEW_LINE","import math   def gcd ( a , b ) : if a < b : a , b = b , a while a % b != 0 : a , b = b , a % b return b   a , b = map ( int , input ( ) . split ( ) )   res = 0   for i in [ 2 , 3 , 5 ] : r = 0 while a % i == 0 : a \/\/= i r += 1 while b % i == 0 : b \/\/= i r -= 1 res += abs ( r )   if gcd ( a , b ) == 1 and a != b : print ( - 1 ) else : print ( res )       NEW_LINE"],"bleu":0.08927996107072807,"rouge_l":0.29243607954545453}
{"id":191,"predictions":["from sys import stdin , stdoutstdin . readlinedef mp ( ) : return list ( map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) ) def it ( ) : return int ( stdin . readline ( ) . strip ( ) ) from math import ceilfrom collections import defaultdict as ddfrom collections import Counter as Cn = it ( ) l = sorted ( mp ( ) ) NEW_LINE"],"references":["n , t = list ( map ( int , input ( ) . split ( ) ) ) a = list ( map ( int , input ( ) . split ( ) ) ) i = 1 while i < t : i += a [ i - 1 ] print ( ' YES ' if i == t else ' NO ' ) NEW_LINE","n , k = [ int ( i ) for i in input ( ) . split ( ) ] a = [ int ( i ) for i in input ( ) . split ( ) ] i = 0 while i < n : if i == k - 1 : print ( \" YES \" ) break else : if i == n - 1 : i = i + 1 else : i = i + a [ i ] else : print ( \" NO \" ) NEW_LINE","n , t = ( int ( x ) for x in input ( ) . strip ( ) . split ( \" ▁ \" ) ) a = [ 0 ] + [ int ( x ) for x in input ( ) . strip ( ) . split ( \" ▁ \" ) ]   out = [ 1 ] j = 1 while j < n : j = j + a [ j ] out . append ( j )   if t in out : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.3103202127475329,"rouge_l":0.40137866207112644}
{"id":192,"predictions":["n , l = map ( int , input ( ) . split ( ) ) ar = list ( map ( int , input ( ) . split ( ) ) ) ar = sorted ( ar ) ; ans = 0 NEW_LINE for i in range ( n - 1 ) : ; NEW_LINE"],"references":["n , l = map ( int , input ( ) . split ( ) ) lights = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True )   max_dif = 0   for i in range ( len ( lights ) - 1 ) : max_dif = max ( max_dif , lights [ i ] - lights [ i + 1 ] )   print ( format ( max ( max_dif \/ 2 , lights [ - 1 ] , l - lights [ 0 ] ) , ' . 10f ' ) ) NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) arr . sort ( ) count = arr [ 0 ] for i in range ( 1 , n ) : if ( ( arr [ i ] - arr [ i - 1 ] ) \/ 2 > count ) : count = ( arr [ i ] - arr [ i - 1 ] ) \/ 2 if ( m - arr [ - 1 ] > count ) : count = m - arr [ - 1 ] print ( count ) NEW_LINE","import sys   def input ( ) : return sys . stdin . readline ( ) . strip ( ) def iinput ( ) : return int ( input ( ) ) def rinput ( ) : return map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) def get_list ( ) : return list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) )     n , l = rinput ( ) a = get_list ( ) a . sort ( )   maxi = max ( a [ 0 ] - 0 , l - a [ - 1 ] )   for i in range ( 1 , n ) : l = ( a [ i ] - a [ i - 1 ] ) \/ 2 maxi = max ( maxi , l )   print ( maxi ) NEW_LINE"],"bleu":0.287755269501644,"rouge_l":0.5306354009077155}
{"id":193,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) PI = float ( ' inf ' ) for _ in range ( 1 ) : NEW_LINE"],"references":["n = [ int ( i ) for i in input ( ) ] for x in [ 1 , 6 , 8 , 9 ] : for i in range ( len ( n ) ) : if n [ i ] == x : del n [ i ] break   prefix = [ 1869 , 6189 , 1689 , 6198 , 1698 , 9861 , 1896 ] res = sum ( [ n [ i ] * pow ( 10 , len ( n ) - i - 1 , 7 ) for i in range ( len ( n ) ) ] ) print ( prefix [ - res * pow ( 10 , 5 * len ( n ) , 7 ) % 7 ] , end = ' ' ) print ( * n , sep = ' ' ) NEW_LINE","''' ▁ ▁ ▁ ▁ Auther : ▁ ghoshashis545 ▁ Ashis ▁ Ghosh ▁ ▁ ▁ ▁ College : ▁ jalpaiguri ▁ Govt ▁ Enggineering ▁ College  ''' from os import pathimport sysfrom heapq import heappush , heappopfrom functools import cmp_to_key as ctkfrom collections import deque , defaultdict as dd from bisect import bisect , bisect_left , bisect_right , insort , insort_left , insort_rightfrom itertools import permutationsfrom datetime import datetimefrom math import sqrt , log , gcddef ii ( ) : return int ( input ( ) ) def si ( ) : return input ( ) . rstrip ( ) def mi ( ) : return map ( int , input ( ) . split ( ) ) def li ( ) : return list ( mi ( ) ) def ceil ( a , b ) : return ( a + b - 1 ) \/\/ babc = ' abcdefghijklmnopqrstuvwxyz ' mod = 1000000007 NEW_LINE"],"bleu":0.052896087830681913,"rouge_l":0.2517432759356767}
{"id":194,"predictions":["t = int ( input ( ) ) for i in range ( t ) : n , m = map ( int , input ( ) . split ( ) ) l = [ ] for i in range ( n ) : l . append ( list ( map ( int , input ( ) . split ( ) ) ) f = 1 for i in l : if i not in l [ i ] : f = 1 breakif f == 1 : print ( ' First ' ) else : print ( ' Second ' ) NEW_LINE"],"references":["t = int ( input ( ) ) s = [ ] for i in range ( t ) : k = 0 x = list ( map ( int , input ( ) . split ( ) ) ) n = x [ 0 ] m = x [ 1 ] indices1 = [ ] mylist = [ ] for j in range ( n ) : y = list ( map ( str , input ( ) . split ( ) ) ) indices = [ o for o , z in enumerate ( y ) if z == \"1\" ] NEW_LINE","import matht = int ( input ( ) ) for i in range ( t ) : n , m = map ( int , input ( ) . split ( ) ) l = [ ] for i in range ( n ) : x = list ( map ( int , input ( ) . split ( ) ) ) l . append ( x ) res = 0 for i in range ( n ) : for j in range ( m ) : if l [ i ] [ j ] == 1 : res += 1 break ans = 0 for i in range ( m ) : for j in range ( n ) : if l [ j ] [ i ] == 1 : ans += 1 break ans = m - ans res = n - res r = min ( ans , res )               if r % 2 == 0 : print ( \" Vivek \" ) else : print ( \" Ashish \" )                                                                             NEW_LINE","for i in range ( int ( input ( ) ) ) : n , m = [ int ( i ) for i in input ( ) . split ( ) ] l = [ ] count = 0 row = 0 for i in range ( n ) : k = [ int ( j ) for j in input ( ) . split ( ) ] if 1 not in k : row += 1 l . append ( k ) col = 0 for i in range ( m ) : flag = False for j in range ( n ) : if l [ j ] [ i ] == 1 : flag = True break if not flag : col += 1 ans = min ( row , col ) if ans % 2 == 0 : print ( \" Vivek \" ) else : print ( \" Ashish \" ) NEW_LINE"],"bleu":0.7010244224827344,"rouge_l":0.6456275112011186}
{"id":195,"predictions":["n = int ( input ( ) ) s = input ( ) ans = 0 for i in range ( 1 , n ) : if ( s [ i ] == '1' ) : ans += 1 print ( ans ) NEW_LINE"],"references":["n = int ( input ( ) ) s = str ( input ( ) ) ans = 0 for i in range ( n ) : if int ( s [ i ] ) % 2 == 0 : ans += ( i + 1 ) print ( ans ) NEW_LINE","n = int ( input ( ) ) s = input ( ) l = [ ] c = 0 ans = 0 for i in range ( n ) : if ( int ( s [ i ] ) % 2 == 0 ) : c += 1 l . append ( i ) NEW_LINE","import sys   def main ( ) : _ , s = sys . stdin . read ( ) . strip ( ) . split ( ) return sum ( i + 1 for i , j in enumerate ( map ( int , s ) ) if not j % 2 ) print ( main ( ) ) NEW_LINE"],"bleu":0.6153761158190014,"rouge_l":0.8209959623149395}
{"id":196,"predictions":["import bisectimport collectionsimport copyimport functoolsimport heapqimport itertoolsimport mathimport randomimport reimport sysimport timeimport stringfrom typing import List NEW_LINE"],"references":["from math import log2   def main ( ) : t = int ( input ( ) ) allAns = [ ] MOD = 10 ** 9 + 7 for _ in range ( t ) : n , p = readIntArr ( ) a = readIntArr ( ) if p == 1 : NEW_LINE"],"bleu":0.009069179133789363,"rouge_l":0.050727650727650724}
{"id":197,"predictions":["import sys NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE input = sys . stdin . readline NEW_LINE N = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE score = [ 0 ] * ( N ** 2 + 1 ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT score [ A [ i ] ] = score [ A [ i ] ] + score [ B [ i ] ] NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT print ( score [ i ] ) NEW_LINE DEDENT"],"references":["def isquare ( n ) : h = n l = 1 while h - l > 1 : m = ( h + l ) \/\/ 2 if m * m <= n : l = m elif m * m > n : h = m return la , b = map ( int , input ( ) . split ( ) ) lsta = [ ] lstb = [ ] for i in range ( 3 , a ) : if isquare ( a * a - i * i ) ** 2 == a * a - i * i : lsta . append ( [ i , isquare ( a * a - i * i ) ] ) for i in range ( 3 , b ) : if isquare ( b * b - i * i ) ** 2 == b * b - i * i : lstb . append ( [ i , isquare ( b * b - i * i ) ] ) flag = Falsefor p , q in lsta : for r , s in lstb : if p * r == q * s : if q == s : p , q , r , s = p , q , r , - s else : p , q , r , s = p , q , - r , s flag = True break if flag : breakif flag : print ( \" YES \\n \" , 0 , 0 , ' \\n ' , p , q , ' \\n ' , r , s ) else : print ( \" NO \" ) NEW_LINE","from collections import defaultdict , deque , Counterfrom sys import stdin , stdoutfrom heapq import heappush , heappopimport mathimport ioimport osimport mathimport bisect   NEW_LINE"],"bleu":0.22406697122691205,"rouge_l":0.28776412776412774}
{"id":198,"predictions":["import sys , math , itertoolsfrom collections import Counter , deque , defaultdictfrom bisect import bisect_left , bisect_right from heapq import heappop , heappush , heapifymod = 10 ** 9 + 7 INF = float ( ' inf ' ) def inp ( ) : return int ( sys . stdin . readline ( ) ) def inpl ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) def inpl_1 ( ) : return list ( map ( lambda x : int ( x ) - 1 , sys . stdin . readline ( ) . split ( ) ) ) def inps ( ) : return sys . stdin . readline ( ) def inpsl ( x ) : tmp = sys . stdin . readline ( ) ; return list ( tmp [ : x ] ) def err ( x ) : print ( x ) ; exit ( )   for _ in range ( inp ( ) ) : n , k = inpl ( ) a = inpl ( ) cnt = 0 for i in range ( n ) : NEW_LINE"],"references":["m , k = [ int ( i ) for i in input ( ) . split ( ) ]   days = [ int ( i ) for i in input ( ) . split ( ) ]     s1 = 0 for q in range ( 1 , m ) : if days [ q ] + days [ q - 1 ] < k : s1 += k - ( days [ q ] + days [ q - 1 ] ) days [ q ] += k - ( days [ q ] + days [ q - 1 ] )   print ( s1 ) print ( * days ) NEW_LINE","n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) count = sum ( a ) for i in range ( n - 1 ) : if ( a [ i ] + a [ i + 1 ] < k ) : add = k - a [ i ] a [ i + 1 ] = addcount1 = sum ( a ) print ( count1 - count ) print ( * a , sep = \" ▁ \" ) NEW_LINE","n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in range ( 1 , n ) : if k - a [ i - 1 ] > a [ i ] : c += k - a [ i - 1 ] - a [ i ] a [ i ] = k - a [ i - 1 ] print ( c ) print ( * a ) NEW_LINE"],"bleu":0.17147229628319072,"rouge_l":0.325610448608745}
{"id":199,"predictions":["def STR ( ) : return list ( input ( ) ) def INT ( ) : return int ( input ( ) ) def MAP ( ) : return map ( int , input ( ) . split ( ) ) def MAP2 ( ) : return map ( float , input ( ) . split ( ) ) def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) def STRING ( ) : return input ( ) import stringimport sysfrom heapq import heappop , heappushfrom bisect import * from collections import deque , Counter , defaultdictfrom math import * from itertools import permutations , accumulatedx = [ - 1 , 1 , 0 , 0 ] dy = [ 0 , 0 , 1 , - 1 ] NEW_LINE"],"references":["n = int ( input ( ) ) A = [ int ( d ) for d in input ( ) ] f = [ int ( x ) for x in input ( ) . split ( ) ] flag = Falsefor i in range ( n ) : d = A [ i ] x = f [ A [ i ] - 1 ] if x > d : flag = True A [ i ] = x elif x == d : continue else : if flag : breakA = list ( map ( str , A ) ) print ( ' ' . join ( A ) ) NEW_LINE","def solve ( n , x , f ) : start = None end = None for i in range ( n ) : if start is None : if f [ int ( x [ i ] ) ] > x [ i ] : start , end = i , i if start is not None : if f [ int ( x [ i ] ) ] < x [ i ] : break end = i if start is None : return x NEW_LINE","n = int ( input ( ) )   string = input ( )   lst = list ( map ( int , input ( ) . split ( ) ) )   pos = - 1   for i in range ( n ) : x = ord ( string [ i ] ) - 48 if x < lst [ x - 1 ] : pos = i break   if pos == - 1 :   print ( string )   else : lstrs = [ ]   for i in range ( pos ) : lstrs . append ( string [ i ] )   pos2 = n   for i in range ( pos , n ) : x = ord ( string [ i ] ) - 48 if x > lst [ x - 1 ] : pos2 = i break lstrs . append ( str ( lst [ x - 1 ] ) )   for i in range ( pos2 , n ) : lstrs . append ( string [ i ] )   print ( \" \" . join ( lstrs ) ) NEW_LINE"],"bleu":0.21450528259446813,"rouge_l":0.3158087732600778}
{"id":200,"predictions":["s = input ( ) st = [ '0' ] c = 0 for i in s : NEW_LINE"],"references":["import sysfrom math import gcd , sqrt , ceil , log2from collections import defaultdict , Counter , dequefrom bisect import bisect_left , bisect_rightimport mathimport heapqfrom itertools import permutations   NEW_LINE","s = input ( ) st , v , vi , vj , vc = [ ] , [ ] , 0 , 0 , 0 for i , c in enumerate ( s ) : if c in ' [ ( ' : st . append ( i ) continue if st and s [ st [ - 1 ] ] + c in ( ' ( ) ' , ' [ ] ' ) : b = ( st [ - 1 ] , i + 1 ) if v and v [ - 1 ] [ 1 ] == i : v [ - 1 ] = b else : v . append ( b ) if len ( v ) >= 2 and v [ - 2 ] [ 1 ] == v [ - 1 ] [ 0 ] : v [ - 2 : ] = [ ( v [ - 2 ] [ 0 ] , v [ - 1 ] [ 1 ] ) ] st . pop ( ) else : st = [ ] for b in v : c = s . count ( ' [ ' , b [ 0 ] , b [ 1 ] ) if c > vc : vi , vj , vc = b [ 0 ] , b [ 1 ] , cprint ( vc ) print ( s [ vi : vj ] ) NEW_LINE"],"bleu":0.27981679665859505,"rouge_l":0.11199913597580731}
{"id":201,"predictions":["for _ in range ( int ( input ( ) ) ) : a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE if a == 0 : NEW_LINE INDENT print ( 0 ) elif b == 0 : NEW_LINE print ( 1 ) else : NEW_LINE print ( 3 ) NEW_LINE DEDENT"],"references":["t = int ( input ( ) ) for i in range ( t ) : a , b , c = map ( int , input ( ) . split ( ) ) count = 0 if b > 0 and c > 1 : while b > 0 and c > 1 : b = b - 1 c = c - 2 count += 1 if a > 0 and b > 1 : while a > 0 and b > 1 : a = a - 1 b = b - 2 count += 1 print ( count * 3 )       NEW_LINE","t = int ( input ( ) )   for _ in range ( t ) : a , b , c = map ( int , input ( ) . split ( ) )   stones = 0 while ( c >= 2 and b >= 1 ) : stones += 3 c -= 2 b -= 1   while ( b >= 2 and a >= 1 ) : stones += 3 b -= 2 a -= 1   print ( stones ) NEW_LINE","t = int ( input ( ) ) for i in range ( t ) : temp = [ int ( x ) for x in input ( ) . split ( ) ] a = temp [ 0 ] b = temp [ 1 ] c = temp [ 2 ] result = 0 result += min ( b , c \/\/ 2 ) b -= result result += min ( a , b \/\/ 2 ) print ( result * 3 ) NEW_LINE"],"bleu":0.37943452760856095,"rouge_l":0.5073875451461093}
{"id":202,"predictions":["n , k = map ( int , input ( ) . split ( ) ) a = [ int ( x ) for x in input ( ) . split ( ) ] a . insert ( 0 , 0 ) a = sorted ( list ( set ( a ) ) ) for i in range ( 1 , n + 1 ) : print ( a [ i ] ) NEW_LINE"],"references":["f = lambda : map ( int , input ( ) . split ( ) ) n , m = f ( ) t = list ( f ( ) ) p = [ 1e9 ] + [ abs ( b - a ) for a , b in zip ( t , t [ 1 : ] ) ] + [ 1e9 ] L , R = [ 0 ] * n , [ 0 ] * nfor i in range ( 1 , n ) : j = n - i x , y = i - 1 , j + 1 a , b = p [ i ] , p [ j ] while a > p [ x ] : x = L [ x ] while b >= p [ y ] : y = R [ y ] L [ i ] , R [ j ] = x , yfor k in range ( m ) : l , r = f ( ) print ( sum ( ( i - max ( l - 1 , L [ i ] ) ) * ( min ( r , R [ i ] ) - i ) * p [ i ] for i in range ( l , r ) ) ) NEW_LINE","f = lambda : map ( int , input ( ) . split ( ) ) n , m = f ( ) t = list ( f ( ) ) p = [ 1e9 ] + [ abs ( b - a ) for a , b in zip ( t , t [ 1 : ] ) ] + [ 1e9 ] L , R = [ 0 ] * n , [ 0 ] * nfor i in range ( 1 , n ) : j = n - i x , y = i - 1 , j + 1 a , b = p [ i ] , p [ j ] while a > p [ x ] : x = L [ x ] while b >= p [ y ] : y = R [ y ] L [ i ] , R [ j ] = x , yfor k in range ( m ) : l , r = f ( ) print ( sum ( ( i - max ( l - 1 , L [ i ] ) ) * ( min ( r , R [ i ] ) - i ) * p [ i ] for i in range ( l , r ) ) ) NEW_LINE","f = lambda : map ( int , input ( ) . split ( ) ) n , m = f ( ) t = list ( f ( ) ) p = [ 1e9 ] + [ abs ( b - a ) for a , b in zip ( t , t [ 1 : ] ) ] + [ 1e9 ] L , R = [ 0 ] * n , [ 0 ] * nfor i in range ( 1 , n ) : j = n - i x , y = i - 1 , j + 1 a , b = p [ i ] , p [ j ] while a > p [ x ] : x = L [ x ] while b >= p [ y ] : y = R [ y ] L [ i ] , R [ j ] = x , yfor k in range ( m ) : l , r = f ( ) print ( sum ( ( i - max ( l - 1 , L [ i ] ) ) * ( min ( r , R [ i ] ) - i ) * p [ i ] for i in range ( l , r ) ) ) NEW_LINE"],"bleu":0.054377978032612885,"rouge_l":0.26651087177402966}
{"id":203,"predictions":["for _ in range ( int ( input ( ) ) ) : n , m = map ( int , input ( ) . split ( ) ) NEW_LINE p = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = 0 NEW_LINE r = [ ] NEW_LINE for i in range ( n ) : if NEW_LINE j % 2 == 1 : if NEW_LINE s += s * ( m - r [ i ] ) - 1 else : s = s + 1 NEW_LINE print ( s ) NEW_LINE"],"references":["cases = int ( input ( ) ) while cases : cases -= 1 x = int ( input ( ) ) arrx = list ( map ( int , input ( ) . split ( ) ) ) y = int ( input ( ) ) arry = list ( map ( int , input ( ) . split ( ) ) )   ans = sum ( 1 for i in arrx if i % 2 == 0 ) * sum ( 1 for i in arry if i % 2 == 0 ) + sum ( 1 for i in arrx if i % 2 != 0 ) * sum ( 1 for i in arry if i % 2 != 0 ) print ( ans ) NEW_LINE","t = int ( input ( ) ) for _ in range ( t ) : r = 0 pc = int ( input ( ) ) p = list ( map ( int , input ( ) . split ( ) ) ) pe = 0 po = 0 qc = int ( input ( ) ) q = list ( map ( int , input ( ) . split ( ) ) ) qe = 0 qo = 0 for i in p : if i % 2 == 0 : pe += 1 else : po += 1 for j in q : if j % 2 == 0 : qe += 1 else : qo += 1 print ( qe * pe + qo * po )   NEW_LINE","test = int ( input ( ) ) while test : n = int ( input ( ) ) p = list ( map ( int , input ( ) . split ( \" ▁ \" ) ) ) m = int ( input ( ) ) q = list ( map ( int , input ( ) . split ( \" ▁ \" ) ) ) even1 , even2 , odd1 , odd2 = 0 , 0 , 0 , 0 for i in range ( n ) : if p [ i ] % 2 == 0 : even1 += 1 else : odd1 += 1 for i in range ( m ) : if q [ i ] % 2 == 0 : even2 += 1 else : odd2 += 1 print ( even1 * even2 + odd1 * odd2 ) test -= 1 NEW_LINE"],"bleu":0.4115387407309416,"rouge_l":0.5348076419785397}
{"id":204,"predictions":["nama = input ( ) nama = list ( nama ) if nama == 0 : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"references":["MAX_LEN = int ( 1e5 ) n = int ( input ( ) ) a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] m = int ( input ( ) ) b = list ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) curr , k , c , res = 0 , 0 , [ ] , [ ] for i in range ( n ) : t = a [ i ] last = curr if t [ 0 ] == 1 : curr += 1 if len ( c ) < MAX_LEN : c . append ( t [ 1 ] ) if k < m and b [ k ] == curr - 1 : res . append ( t [ 1 ] ) k += 1 else : curr += t [ 1 ] * t [ 2 ] while t [ 2 ] > 0 and len ( c ) < MAX_LEN : c . extend ( c [ : t [ 1 ] ] ) t [ 2 ] -= 1 while k < m and last <= b [ k ] < curr : res . append ( c [ ( b [ k ] - last ) % t [ 1 ] ] ) k += 1 print ( ' ▁ ' . join ( map ( str , res [ : m ] ) ) ) NEW_LINE","from bisect import bisect_leftdef fun ( ind , alr , ll , sll ) : if ind in alr : return alr [ ind ] k = bisect_left ( sll , ind ) md = ll [ k ] return fun ( ( ind - sll [ k ] ) % md , alr , ll , sll ) pos = { } m = int ( input ( ) ) l = 0 cp = [ ] cpl = [ ] known = [ ] for _ in range ( 0 , m ) : q = [ int ( i ) for i in input ( ) . split ( ) ] if q [ 0 ] == 1 : pos [ l ] = q [ 1 ] l += 1 else : cp . append ( q [ 1 ] ) l += q [ 1 ] * q [ 2 ] cpl . append ( l ) n = int ( input ( ) ) qq = [ int ( i ) - 1 for i in input ( ) . split ( ) ] ans = [ fun ( i , pos , cp , cpl ) for i in qq ] print ( * ans )         NEW_LINE","from bisect import bisect_leftdef fun ( ind , alr , ll , sll ) : if ind in alr : return alr [ ind ] k = bisect_left ( sll , ind ) md = ll [ k ] return fun ( ( ind - sll [ k ] ) % md , alr , ll , sll ) pos = { } m = int ( input ( ) ) l = 0 cp = [ ] cpl = [ ] for _ in range ( 0 , m ) : q = [ int ( i ) for i in input ( ) . split ( ) ] if q [ 0 ] == 1 : pos [ l ] = q [ 1 ] l += 1 else : cp . append ( q [ 1 ] ) l += q [ 1 ] * q [ 2 ] cpl . append ( l ) n = int ( input ( ) ) qq = [ int ( i ) - 1 for i in input ( ) . split ( ) ] ans = [ fun ( i , pos , cp , cpl ) for i in qq ] print ( * ans )         NEW_LINE"],"bleu":0.0004973792212537863,"rouge_l":0.11679347004585075}
{"id":205,"predictions":["import sysfrom collections import Counter   def main ( ) : _ , x , * l = map ( int , sys . stdin . read ( ) . strip ( ) . split ( ) ) s , c = set ( l ) , Counter ( ) if len ( s ) < l : return 0 , sys . stdin . readline ( ) . strip ( ) ) if list ( s ) [ : : - 1 ] : return - 1 , sys . stdout . write ( \" \\n \" ) if len ( s ) == 1 : print ( \" YES \" ) else : print ( \" NO \" ) main ( ) NEW_LINE"],"references":["def get_key ( my_dict , val ) : for key , value in my_dict . items ( ) : if val == value : return key return - 1   n = int ( input ( ) ) arr = { } for _ in range ( n ) : a , b = input ( ) . split ( ) x = get_key ( arr , a ) if x == - 1 : arr [ a ] = b   else : arr [ x ] = b   print ( len ( arr ) ) for i , j in arr . items ( ) : print ( i , j ) NEW_LINE","nr_user = int ( input ( ) )   handles = list ( ) flag_add = Truefor i in range ( nr_user ) : new_handle = input ( ) . split ( ) for handle in handles : if ( new_handle [ 0 ] == handle [ 1 ] ) : handle [ 1 ] = new_handle [ 1 ] flag_add = False   if ( flag_add ) : handles . append ( new_handle ) flag_add = True     print ( len ( handles ) ) for handle in handles : print ( * handle ) NEW_LINE","n = int ( input ( ) ) old_names = [ ] new_names = [ ] records = { } count = 0 for i in range ( n ) : name1 , name2 = input ( ) . split ( ) old_names . append ( name1 ) new_names . append ( name2 )   for i in range ( n ) : if old_names [ i ] not in records : records [ new_names [ i ] ] = old_names [ i ] elif old_names [ i ] in records : records [ new_names [ i ] ] = records [ old_names [ i ] ] del records [ old_names [ i ] ] print ( len ( records ) ) for key in records : root_names = records [ key ] print ( root_names + \" ▁ \" + key )     NEW_LINE"],"bleu":0.12955205673301787,"rouge_l":0.3424499784079459}
{"id":206,"predictions":["a , b = map ( int , input ( ) . split ( ) ) if a % b == 0 : print ( \" Yes \" ) else : print ( \" No \" ) NEW_LINE"],"references":["a , b = map ( int , input ( ) . split ( ) ) print ( ' VVlaaldeirka ' [ ( ( 4 * b + 1 ) ** .5 - 1 ) \/\/ 2 < a ** .5 \/\/ 1 : : 2 ] ) NEW_LINE","a , b = map ( int , input ( ) . split ( ) ) s = int ( a ** 0.5 ) if ( s * ( s + 1 ) > b ) : print ( \" Valera \" ) else : print ( \" Vladik \" ) NEW_LINE","a , b = map ( int , input ( ) . split ( ) ) i = 0 d = 0 while a >= 0 and b >= 0 : if i % 2 == 0 and i > 0 : if b - d >= 0 : b -= d i += 1 d += 1 else : print ( ' Valera ' ) break elif a - d >= 0 : a -= d i += 1 d += 1 else : print ( ' Vladik ' ) break                   NEW_LINE"],"bleu":0.527103831515343,"rouge_l":0.6917080085046067}
{"id":207,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["def main ( ) : n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) a . sort ( ) c = [ ] for i in range ( n - 1 ) : c += [ a [ i + 1 ] - a [ i ] ] print ( min ( c ) , c . count ( min ( c ) ) )   if __name__ == ' _ _ main _ _ ' : main ( ) NEW_LINE","num = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) arr . sort ( ) lst = [ ] for i in range ( num - 1 ) : lst . append ( abs ( arr [ i + 1 ] - arr [ i ] ) )   print ( min ( lst ) , lst . count ( min ( lst ) ) )     NEW_LINE","import mathn = int ( input ( ) ) li = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) [ : n ] li . sort ( ) mindiff = li [ 1 ] - li [ 0 ] for i in range ( 2 , n ) : diff = li [ i ] - li [ i - 1 ] if ( diff < mindiff ) : mindiff = diffprint ( mindiff , end = \" ▁ \" ) count = 0 for i in range ( 1 , n ) : if ( li [ i ] - li [ i - 1 ] == mindiff ) : count += 1 print ( count ) NEW_LINE"],"bleu":0.2017948216254815,"rouge_l":0.42903637174441983}
{"id":208,"predictions":["n = int ( input ( ) ) print ( [ 1 , 0 ] [ n % 2 == 0 ] ) NEW_LINE"],"references":["n , L = map ( int , input ( ) . split ( ) ) kefa = list ( map ( int , input ( ) . split ( ) ) ) sasha = list ( map ( int , input ( ) . split ( ) ) ) def check ( kefa , sasha ) : X = [ ( kefa [ i ] - sasha [ i ] + L ) % L for i in range ( n ) ] if len ( set ( X ) ) == 1 : return True else : return Falsedef rotate ( arr , n ) : x = arr [ n - 1 ] for i in range ( n - 1 , 0 , - 1 ) : arr [ i ] = arr [ i - 1 ] arr [ 0 ] = x return arrok = Falsefor l in range ( n + 1 ) : sasha = rotate ( sasha , n ) if check ( kefa , sasha ) == True : ok = Trueif ok == True : print ( \" Yes \" ) else : print ( \" No \" ) NEW_LINE","n , l = [ int ( x ) for x in input ( ) . split ( ' ▁ ' ) ] k = [ int ( x ) for x in input ( ) . split ( ' ▁ ' ) ] s = [ int ( x ) for x in input ( ) . split ( ' ▁ ' ) ]   kd = [ ( k [ i % n ] - k [ i - 1 ] ) % l for i in range ( 1 , n + 1 ) ] sd = [ ( s [ i % n ] - s [ i - 1 ] ) % l for i in range ( 1 , n + 1 ) ]   ans = Falsefor i in range ( n ) : if kd == sd [ i : ] + sd [ : i ] : ans = True breakif ans : print ( ' YES ' ) else : print ( ' NO ' ) NEW_LINE","n , L = map ( int , input ( ) . split ( ) ) kefa = list ( map ( int , input ( ) . split ( ) ) ) sasha = list ( map ( int , input ( ) . split ( ) ) ) def check ( kefa , sasha ) : X = [ ( kefa [ i ] - sasha [ i ] + L ) % L for i in range ( n ) ] if len ( set ( X ) ) == 1 : return True else : return Falsedef rotate ( arr , n ) : x = arr [ n - 1 ] for i in range ( n - 1 , 0 , - 1 ) : arr [ i ] = arr [ i - 1 ] arr [ 0 ] = x return arrok = Falsefor l in range ( n + 1 ) : sasha = rotate ( sasha , n ) if check ( kefa , sasha ) == True : ok = Trueif ok == True : print ( \" Yes \" ) else : print ( \" No \" ) NEW_LINE"],"bleu":0.0004595698854719302,"rouge_l":0.17498565691336773}
{"id":209,"predictions":["from math import sqrtn = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) d = { } for i in arr : if i in d : d [ i ] += 1 else : d [ i ] += 1 if n > 1 : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"references":["n = 1000000 a = [ 1 ] * ns = set ( ) for i in range ( 2 , n ) : if a [ i ] : s . add ( i * i ) for j in range ( i * i , n , i ) : a [ j ] = 0 input ( ) for x in map ( int , input ( ) . split ( ) ) : print ( [ \" NO \" , \" YES \" ] [ x in s ] ) NEW_LINE","import math     _ = int ( input ( ) )   n = 1_000_000 d = { 1 : True } for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : if i not in d : for m in range ( i * 2 , n + 1 , i ) : d [ m ] = True     for n in map ( int , input ( ) . split ( ) ) : sq = math . sqrt ( n ) if sq == int ( sq ) : if int ( sq ) not in d : print ( \" YES \" ) else : print ( \" NO \" ) else : print ( \" NO \" ) NEW_LINE","def isprime ( n ) : if n == 1 : return False if n < 4 : return True if n % 2 == 0 or n % 3 == 0 : return False   for i in range ( 3 , int ( n ** 0.5 ) + 1 , 2 ) : if n % i == 0 : return False return True     num = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) )   for i in arr : root = int ( i ** 0.5 ) if root * root == i and isprime ( root ) : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.5362317613560111,"rouge_l":0.4263831052944676}
{"id":210,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) neg , neg1 = 0 , [ ] pos , pos1 = 0 , [ ] for i in range ( n ) : if l [ i ] >= 0 : l [ i ] = - l [ i ] - 1 if n % 2 == 0 : print ( * l ) else : l1 = sorted ( l ) l [ l . index ( l1 [ 0 ] ) ] = - l1 [ 0 ] - 1 print ( * l ) NEW_LINE","from sys import stdin , stdoutfrom math import floor , gcd , fabs , factorial , fmod , sqrt , inf , logfrom collections import defaultdict as dd , dequefrom heapq import merge , heapify , heappop , heappush , nsmallestfrom bisect import bisect_left as bl , bisect_right as br , bisect mod = pow ( 10 , 9 ) + 7 mod2 = 998244353 def inp ( ) : return stdin . readline ( ) . strip ( ) def iinp ( ) : return int ( inp ( ) ) def out ( var , end = \" \\n \" ) : stdout . write ( str ( var ) + \" \\n \" ) def outa ( * var , end = \" \\n \" ) : stdout . write ( ' ▁ ' . join ( map ( str , var ) ) + end ) def lmp ( ) : return list ( mp ( ) ) def mp ( ) : return map ( int , inp ( ) . split ( ) ) def smp ( ) : return map ( str , inp ( ) . split ( ) ) def l1d ( n , val = 0 ) : return [ val for i in range ( n ) ] def l2d ( n , m , val = 0 ) : return [ l1d ( m , val ) for j in range ( n ) ] def remadd ( x , y ) : return 1 if x % y else 0 def ceil ( a , b ) : return ( a + b - 1 ) \/\/ b def isprime ( x ) : if x <= 1 : return False if x in ( 2 , 3 ) : return True if x % 2 == 0 : return False for i in range ( 3 , int ( sqrt ( x ) ) + 1 , 2 ) : if x % i == 0 : return False return True n = iinp ( ) arr = lmp ( ) arr = [ - i - 1 if i < 0 else i for i in arr ] if n % 2 == 0 : print ( * [ - i - 1 for i in arr ] ) else : ind = arr . index ( max ( arr ) ) for i in range ( n ) : if i == ind : continue arr [ i ] = - arr [ i ] - 1 print ( * arr ) NEW_LINE","import sysn = int ( input ( ) ) a = list ( ) for i in input ( ) . split ( ) : if not int ( i ) : a . append ( - 1 ) else : a . append ( int ( i ) ) if n == 1 : print ( max ( a [ 0 ] , - a [ 0 ] - 1 ) ) ; sys . exit ( ) if n & 1 : f = False mx , mn = max ( a ) , min ( a ) k = a . count ( mx ) if abs ( mn ) > abs ( mx ) or mx < 0 : mx = mn ; k = 2 NEW_LINE"],"bleu":0.12053319457384602,"rouge_l":0.35122129627210746}
{"id":211,"predictions":["n , k = map ( int , input ( ) . split ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) [ : : - 1 ] high = arr [ 0 ] for i in range ( k , n ) : high = max ( high , arr [ i ] + arr [ 2 * k - i - 1 ] ) print ( high ) NEW_LINE"],"references":["    n , b = map ( int , input ( ) . split ( ) )   t = list ( map ( int , input ( ) . split ( ) ) )   ans = 0   ma = 999999999 mi = 0 for i in range ( n ) :   if t [ i ] < ma : ma = t [ i ] elif t [ i ] > ma : temp = b \/\/ ma   rest = b - ( b \/\/ ma ) * ma rest += ( temp ) * t [ i ]   ans = max ( rest , ans )   print ( max ( ans , b ) )                             NEW_LINE","n , b = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) print ( max ( b \/\/ a [ i ] * a [ j ] + b % a [ i ] for j in range ( n ) for i in range ( j + 1 ) ) ) NEW_LINE","n , b = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) )   NEW_LINE"],"bleu":0.4911854364762989,"rouge_l":0.7887458844657289}
{"id":212,"predictions":["s = input ( ) ans = [ ] for i in range ( len ( s ) ) : if s [ i ] == ' r ' : ans . append ( i + 1 ) elif s [ i ] == ' l ' : NEW_LINE"],"references":["import osimport sysfrom io import BytesIO , IOBase   sys . setrecursionlimit ( 95000 )     def main ( ) : pass     NEW_LINE","from sys import stdin , stdoutfrom math import floor , gcd , fabs , factorial , fmod , sqrt , inf , logfrom collections import defaultdict as dd , dequefrom heapq import merge , heapify , heappop , heappush , nsmallestfrom bisect import bisect_left as bl , bisect_right as br , bisect mod = pow ( 10 , 9 ) + 7 mod2 = 998244353 def inp ( ) : return stdin . readline ( ) . strip ( ) def iinp ( ) : return int ( inp ( ) ) def out ( var , end = \" \\n \" ) : stdout . write ( str ( var ) + \" \\n \" ) def outa ( * var , end = \" \\n \" ) : stdout . write ( ' ▁ ' . join ( map ( str , var ) ) + end ) def lmp ( ) : return list ( mp ( ) ) def mp ( ) : return map ( int , inp ( ) . split ( ) ) def smp ( ) : return map ( str , inp ( ) . split ( ) ) def l1d ( n , val = 0 ) : return [ val for i in range ( n ) ] def l2d ( n , m , val = 0 ) : return [ l1d ( m , val ) for j in range ( n ) ] def remadd ( x , y ) : return 1 if x % y else 0 def ceil ( a , b ) : return ( a + b - 1 ) \/\/ b def isprime ( x ) : if x <= 1 : return False if x in ( 2 , 3 ) : return True if x % 2 == 0 : return False for i in range ( 3 , int ( sqrt ( x ) ) + 1 , 2 ) : if x % i == 0 : return False return True s = inp ( ) a1 , a2 = [ ] , [ ] for i in range ( len ( s ) ) : if s [ i ] == ' l ' : a1 . append ( i + 1 ) else : a2 . append ( i + 1 ) print ( * a2 , sep = ' \\n ' ) print ( * a1 [ : : - 1 ] , sep = ' \\n ' ) NEW_LINE","class LN : data = None left = None right = None   def __init__ ( self , data , left , right ) : self . data = data self . left = left self . right = right   inst = input ( )   root = LN ( 1 , None , None ) ptr = rooti = 2   for j in range ( len ( inst ) - 1 ) : if inst [ j ] == ' l ' : ptr . left = LN ( i , ptr . left , ptr ) if ptr . left . left : ptr . left . left . right = ptr . left ptr = ptr . left if root . left : root = root . left else : ptr . right = LN ( i , ptr , ptr . right ) if ptr . right . right : ptr . right . right . left = ptr . right ptr = ptr . right   i += 1   trav = rootprint ( root . data )   while trav . right : trav = trav . right print ( trav . data ) NEW_LINE"],"bleu":0.681663772078717,"rouge_l":0.3254891229990423}
{"id":213,"predictions":["x , y , a , b , c = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if a * b > x * a : NEW_LINE INDENT print ( ' NO ' ) elif a * b < x * b : NEW_LINE INDENT print ( ' YES ' ) else : NEW_LINE print ( ' NO ' ) NEW_LINE DEDENT"],"references":["x , t , a , b , da , db = [ int ( i ) for i in input ( ) . split ( ) ]   if x == 0 : print ( \" YES \" ) exit ( 0 )   for i in range ( t ) : for j in range ( t ) : if ( a - i * da + b - j * db == x ) or ( a - i * da == x ) or ( b - j * db == x ) : print ( \" YES \" ) exit ( 0 )   print ( \" NO \" ) NEW_LINE","def STR ( ) : return list ( input ( ) ) def INT ( ) : return int ( input ( ) ) def MAP ( ) : return map ( int , input ( ) . split ( ) ) def MAP2 ( ) : return map ( float , input ( ) . split ( ) ) def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) def STRING ( ) : return input ( ) import stringimport sysfrom heapq import heappop , heappushfrom bisect import * from collections import deque , Counterfrom math import * from itertools import permutations , accumulatedx = [ - 1 , 1 , 0 , 0 ] dy = [ 0 , 0 , 1 , - 1 ] NEW_LINE","def STR ( ) : return list ( input ( ) ) def INT ( ) : return int ( input ( ) ) def MAP ( ) : return map ( int , input ( ) . split ( ) ) def MAP2 ( ) : return map ( float , input ( ) . split ( ) ) def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) def STRING ( ) : return input ( ) import stringimport sysfrom heapq import heappop , heappushfrom bisect import * from collections import deque , Counterfrom math import * from itertools import permutations , accumulatedx = [ - 1 , 1 , 0 , 0 ] dy = [ 0 , 0 , 1 , - 1 ] NEW_LINE"],"bleu":0.18466698885228597,"rouge_l":0.38951436733322126}
{"id":214,"predictions":["from sys import stdinn = int ( stdin . readline ( ) ) a = list ( map ( int , stdin . readline ( ) . split ( ) ) ) ans = [ ] for i in range ( n - 1 ) : if a [ i ] >= a [ i + 1 ] : ans . append ( \" NO \" ) ans . append ( \" YES \" ) print ( max ( ans ) ) NEW_LINE"],"references":["from itertools import combinations   def solve ( ) : n = int ( input ( ) ) ls = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) for x , y , z in zip ( ls , ls [ 1 : ] , ls [ 2 : ] ) : if x > z - y and x <= y + z : print ( ' YES ' ) return print ( ' NO ' )   if __name__ == ' _ _ main _ _ ' : solve ( ) NEW_LINE","n = int ( input ( ) ) a = sorted ( [ int ( x ) for x in input ( ) . split ( ) ] ) for i in range ( 1 , n - 1 ) : if ( a [ i - 1 ] + a [ i ] > a [ i + 1 ] ) : print ( \" YES \" ) exit ( ) print ( \" NO \" ) NEW_LINE","def ok ( a , b , c ) : return ( a + b > c ) and ( a + c > b ) and ( b + c > a )   n = int ( input ( ) ) a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) ye = 0 for i in range ( n - 2 ) : ye |= ok ( a [ i ] , a [ i + 1 ] , a [ i + 2 ] ) if ye : print ( \" YES \" ) else : print ( \" NO \" )   ''' * ▁ So ▁ I ▁ drown ▁ it ▁ out ▁ * ▁ Like ▁ I ▁ always ▁ do * ▁ Dancing ▁ through ▁ our ▁ house * ▁ With ▁ the ▁ ghost ▁ of ▁ you ''' NEW_LINE"],"bleu":0.5091136128187226,"rouge_l":0.6228006555458943}
{"id":215,"predictions":["s = input ( ) st = [ ] cnt = 0 for i in s : if i == ' s ' : st . append ( i ) cnt += 1 else : st . append ( i ) cnt = 0 for i in st : if i == ' s ' : cnt += 1 print ( cnt ) NEW_LINE"],"references":["def solution ( s ) : s = sorted ( s , reverse = True ) n = len ( s ) ans = s [ 0 ] for i in range ( 1 , n ) : if ( s [ i - 1 ] == s [ i ] ) : ans += ( s [ i ] ) else : return ans return ans   s = input ( ) print ( solution ( s ) ) NEW_LINE","s = str ( input ( ) ) l = [ ] for i in s : if i not in l : l . append ( i ) l . sort ( ) char = l [ len ( l ) - 1 ] h = s . count ( char ) string = \" \" for i in range ( h ) : string = string + charprint ( string ) NEW_LINE","a = input ( ) c = max ( a ) print ( c * a . count ( c ) ) NEW_LINE"],"bleu":0.294343929356381,"rouge_l":0.5192158885736394}
{"id":216,"predictions":["n = int ( input ( ) ) print ( 9 , 0 , n ) NEW_LINE"],"references":["n = int ( input ( ) ) if n % 2 == 0 : print ( 4 , n - 4 ) else : print ( 9 , n - 9 ) NEW_LINE","n = int ( input ( ) ) if ( n % 2 == 0 ) : print ( 4 , n - 4 ) else : print ( 9 , n - 9 ) NEW_LINE","def isPrime ( n ) : if n % 2 == 0 : return n == 2 d = 3 while d * d <= n and n % d != 0 : d += 2 return d * d > n   n = int ( input ( ) ) a = 4 b = n - awhile isPrime ( b ) or isPrime ( a ) : a += 1 b = n - aprint ( a , b ) NEW_LINE"],"bleu":0.25084625614286693,"rouge_l":0.5548817465130381}
{"id":217,"predictions":["def STR ( ) : return list ( input ( ) ) def INT ( ) : return int ( input ( ) ) def MAP ( ) : return map ( int , input ( ) . split ( ) ) def MAP2 ( ) : return map ( float , input ( ) . split ( ) ) def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) def STRING ( ) : return input ( ) import stringimport sysfrom heapq import heappop , heappushfrom bisect import * from collections import deque , Counter , defaultdictfrom math import * from itertools import permutations , accumulatedx = [ - 1 , 1 , 0 , 0 ] dy = [ 0 , 0 , 1 , - 1 ] NEW_LINE"],"references":["raw = input ( ) R , C = ( int ( token ) for token in raw . split ( ' ▁ ' ) ) mat = list ( ) for i in range ( R ) : row = input ( ) mat . append ( row )   count = 0 for i in range ( 1 , R ) : for j in range ( 1 , C ) : sq = [ mat [ i - 1 ] [ j - 1 ] , mat [ i - 1 ] [ j ] , mat [ i ] [ j - 1 ] , mat [ i ] [ j ] ] sq . sort ( ) if ' ' . join ( sq ) == ' acef ' : count += 1 print ( count )   NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) s = list ( ) a = [ ' f ' , ' a ' , ' c ' , ' e ' ] result = 0 for i in range ( n ) : s . append ( input ( ) ) for i in range ( n - 1 ) : for j in range ( m - 1 ) : if s [ i ] [ j ] in a : a . remove ( s [ i ] [ j ] ) if s [ i ] [ j + 1 ] in a : a . remove ( s [ i ] [ j + 1 ] ) if s [ i + 1 ] [ j ] in a : a . remove ( s [ i + 1 ] [ j ] ) if s [ i + 1 ] [ j + 1 ] in a : result += 1 a = [ ' f ' , ' a ' , ' c ' , ' e ' ] else : a = [ ' f ' , ' a ' , ' c ' , ' e ' ] else : a = [ ' f ' , ' a ' , ' c ' , ' e ' ] else : a = [ ' f ' , ' a ' , ' c ' , ' e ' ] else : a = [ ' f ' , ' a ' , ' c ' , ' e ' ] print ( result ) NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) l = [ ] p = 0 for i in range ( n ) : lprime = list ( input ( ) ) l . append ( lprime )   for i in range ( 0 , n - 1 ) : for j in range ( 0 , m - 1 ) : u = l [ i ] [ j ] + l [ i ] [ j + 1 ] + l [ i + 1 ] [ j ] + l [ i + 1 ] [ j + 1 ] if \" f \" in u and \" a \" in u and \" c \" in u and \" e \" in u : p += 1   print ( p )   NEW_LINE"],"bleu":0.18383489942563347,"rouge_l":0.311150087575073}
{"id":218,"predictions":["for _ in range ( int ( input ( ) ) ) : n , k = [ int ( i ) for i in input ( ) . split ( ) ] ; print ( max ( n , k ) ) NEW_LINE"],"references":["import sys   def answer ( n , k , a ) : peaks = [ False ] * n NEW_LINE","t = int ( input ( ) ) for l in range ( 0 , t ) : n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) bin = [ 0 ] * n for i in range ( 1 , n - 1 ) : if ( a [ i ] > a [ i - 1 ] and a [ i ] > a [ i + 1 ] ) : bin [ i ] = 1 l = 0 r = l + k peaks = 0 m , ml = 0 , 0 for i in range ( 0 , r ) : if ( bin [ i ] == 1 ) : peaks += 1 if ( i == r - 1 and bin [ i ] == 1 ) : m = peaks - 1 else : m = peaks for l in range ( 1 , n - k + 1 ) : if ( bin [ l ] == 1 ) : peaks -= 1 if ( m < peaks ) : m = peaks ml = l if ( bin [ r ] == 1 ) : peaks += 1 r += 1 print ( m + 1 , ml + 1 ) NEW_LINE","t = int ( input ( ) ) for h in range ( t ) : n , k = map ( int , input ( ) . split ( ) ) x = list ( map ( int , input ( ) . split ( ) ) ) k -= 2 j = n - 1 i = j - k s = 1 for l in range ( i , j ) : if x [ l ] > x [ l - 1 ] and x [ l ] > x [ l + 1 ] : s += 1 m = s ind = i - 1 j -= 1 i -= 1 while i > 0 : if x [ i ] > x [ i - 1 ] and x [ i ] > x [ i + 1 ] : s += 1 if x [ j ] > x [ j - 1 ] and x [ j ] > x [ j + 1 ] : s -= 1 if s >= m : ind = i - 1 m = s   i -= 1 j -= 1 print ( m , ind + 1 ) NEW_LINE"],"bleu":0.5358594161635483,"rouge_l":0.5105291576673865}
{"id":219,"predictions":["n = int ( input ( ) ) s = input ( ) ans = 1 for i in range ( 1 , n ) : if s [ i ] != s [ i - 1 ] : ans = s [ i ] + s [ i + 1 ] breakfor i in range ( n - 1 ) : if s [ i ] != s [ i + 1 ] : ans = ans + 1 print ( ans ) NEW_LINE"],"references":["n = int ( input ( ) ) s = input ( ) k = [ s [ i : i + 2 ] for i in range ( n - 1 ) ] print ( max ( k , key = k . count ) ) NEW_LINE","n = int ( input ( ) ) string = input ( ) d = dict ( ) for i in range ( n - 1 ) : new_str = string [ i : i + 2 ] if new_str in d . keys ( ) : d [ new_str ] += 1 else : d [ new_str ] = 1 ans = max ( d , key = d . get ) print ( ans ) NEW_LINE","from sys import stdin , stdout   def main ( ) : n = int ( stdin . readline ( ) ) s = stdin . readline ( ) [ : - 1 ] c = { } for i in range ( n - 1 ) : c [ s [ i : i + 2 ] ] = c . get ( s [ i : i + 2 ] , 0 ) + 1 x = max ( c , key = c . get ) stdout . write ( str ( x ) + ' \\n ' )   if __name__ == \" _ _ main _ _ \" : main ( ) NEW_LINE"],"bleu":0.39375489752567766,"rouge_l":0.6174711963357299}
{"id":220,"predictions":["from sys import stdin , stdoutstdin . readlinedef mp ( ) : return list ( map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) ) def it ( ) : return int ( stdin . readline ( ) . strip ( ) ) from math import ceilfrom collections import defaultdict as ddfrom collections import Counter as Cn = it ( ) l = sorted ( mp ( ) ) NEW_LINE"],"references":["def main ( ) : t = int ( input ( ) ) allans = [ ] for _ in range ( t ) : x = int ( input ( ) ) arr = [ int ( z ) for z in input ( ) ] n = len ( arr ) j = 1 for i in range ( x ) : if j == n : break for yy in range ( arr [ i ] - 1 ) : if len ( arr ) > x : break for zz in range ( i + 1 , n ) : if len ( arr ) > x : break arr . append ( arr [ zz ] ) n += ( ( n - j + MOD ) % MOD ) * ( arr [ i ] - 1 ) j += 1 n %= MOD NEW_LINE","t = int ( input ( ) ) mod = 10 ** 9 + 7 for _ in range ( t ) : x = int ( input ( ) ) s = input ( ) i = 1 while len ( s ) < x : s += s [ i : ] * ( ord ( s [ i - 1 ] ) - 49 ) i += 1 l = len ( s ) while i <= x : l = ( l + ( l - i ) * ( ord ( s [ i - 1 ] ) - 49 ) ) % mod i += 1 print ( l ) NEW_LINE","t = int ( input ( ) ) mod = 10 ** 9 + 7 for _ in range ( t ) : x = int ( input ( ) ) s = input ( ) i = 1 while len ( s ) < x : s += s [ i : ] * ( ord ( s [ i - 1 ] ) - 49 ) i += 1 l = len ( s ) while i <= x : l = ( l + ( l - i ) * ( ord ( s [ i - 1 ] ) - 49 ) ) % mod i += 1 print ( l ) NEW_LINE"],"bleu":0.0525073366952538,"rouge_l":0.2650981567510865}
{"id":221,"predictions":["li = list ( input ( ) ) i = 0j = len ( li ) - 1 while i <= j : tmp = li [ i ] res = 0 if li [ i ] != li [ j ] : print ( 0 ) exit ( ) while i <= j and li [ i ] == tmp : res += 1 i += 1 while i <= j and li [ j ] != tmp : res += 1 j -= 1 if res <= 2 and i <= j : print ( 0 ) exit ( ) if res > 1 : print ( res + 1 ) else : print ( 0 ) NEW_LINE"],"references":["a = input ( ) b = input ( )   def dfs ( sa , sb ) : if sa == sb : return True if len ( sa ) & 1 : return False n = len ( sa ) \/\/ 2 sa1 = sa [ : n ] sa2 = sa [ n : ] sb1 = sb [ : n ] sb2 = sb [ n : ] if dfs ( sa1 , sb2 ) and dfs ( sa2 , sb1 ) : return True if dfs ( sa1 , sb1 ) and dfs ( sa2 , sb2 ) : return True return False   if dfs ( a , b ) : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE","def verificar_compatibilidade ( string1 , string2 ) : if ( string1 == string2 ) : return True NEW_LINE","def equivalent ( a , b ) :   NEW_LINE"],"bleu":0.09349898659837426,"rouge_l":0.4201948924731183}
{"id":222,"predictions":["import math , sys , bisect , heapq , osfrom collections import defaultdict , Counter , dequefrom itertools import groupby , accumulatefrom functools import lru_cache NEW_LINE"],"references":["n , m , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) a1 = [ ] for i in range ( n ) : a1 . append ( ( a [ i ] , i ) ) a1 . sort ( reverse = True ) _max = [ 0 ] * nans = 0 for i in range ( m * k ) : _max [ a1 [ i ] [ 1 ] ] = 1 ans += a1 [ i ] [ 0 ] print ( ans ) _sum = 0 ans_ar = [ ] for i in range ( n ) : _sum += _max [ i ] if _sum == m : ans_ar . append ( i + 1 ) _sum = 0 ans_ar . pop ( ) print ( * ans_ar )           NEW_LINE","import sysimport bisectinput = lambda : sys . stdin . readline ( ) . strip ( \" \\n \" ) from math import logsa = lambda : input ( ) sb = lambda : int ( input ( ) ) sc = lambda : input ( ) . split ( ) sd = lambda : list ( map ( int , input ( ) . split ( ) ) ) se = lambda : float ( input ( ) ) sf = lambda : list ( input ( ) ) flsh = lambda : sys . stdout . flush ( ) mod = 10 ** 9 + 7 def hnbhai ( ) : n , m , k = sd ( ) a = sd ( ) ans = [ ] for i in range ( n ) : ans . append ( [ a [ i ] , i + 1 ] ) ans . sort ( reverse = True ) query = ans [ : m * k ] query . sort ( key = lambda k : k [ 1 ] ) total = 0 for i in query : total += i [ 0 ] print ( total ) for i in range ( m * k - 1 ) : if ( i + 1 ) % m == 0 : print ( query [ i ] [ 1 ] , end = \" ▁ \" )   for _ in range ( 1 ) : hnbhai ( ) NEW_LINE","n , m , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = a . copy ( ) b . sort ( reverse = True ) d = { } tot = 0 for i in range ( k * m ) : tot += b [ i ] if b [ i ] in d : d [ b [ i ] ] += 1 else : d [ b [ i ] ] = 1 print ( tot ) c = mans = [ ] for i in range ( n ) : if a [ i ] in d and d [ a [ i ] ] > 0 : c -= 1 d [ a [ i ] ] -= 1 if c == 0 : ans . append ( i + 1 ) k -= 1 c = m if k == 0 : breakans . pop ( ) print ( * ans ) NEW_LINE"],"bleu":0.0004129896191880408,"rouge_l":0.05742677824267783}
{"id":223,"predictions":["n = int ( input ( ) ) count = n \/\/ 7 ans = float ( ' inf ' ) val = Nonefor i in range ( count , - 1 , - 1 ) : remaining = n - 7 * i if remaining % 4 == 0 : if ans > i + remaining \/\/ 4 : ans = i + remaining \/\/ 4 val = ( remaining \/\/ 4 , i ) NEW_LINE"],"references":["import reimport sysexit = sys . exitfrom bisect import bisect_left as bsl , bisect_right as bsrfrom collections import Counter , defaultdict as ddict , dequefrom functools import lru_cachecache = lru_cache ( None ) from heapq import * from itertools import * from math import inffrom pprint import pprint as ppenum = enumerateri = lambda : int ( rln ( ) ) ris = lambda : list ( map ( int , rfs ( ) ) ) rln = sys . stdin . readlinerl = lambda : rln ( ) . rstrip ( ' \\n ' ) rfs = lambda : rln ( ) . split ( ) mod = 1000000007 d4 = [ ( 0 , - 1 ) , ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 0 ) ] d8 = [ ( - 1 , - 1 ) , ( 0 , - 1 ) , ( 1 , - 1 ) , ( - 1 , 0 ) , ( 1 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) ] NEW_LINE","import sysreadline = sys . stdin . readline   N = int ( readline ( ) ) A = list ( map ( int , readline ( ) . split ( ) ) ) res = [ ] mini = min ( A ) for i in range ( N ) : if A [ i ] == mini : res . append ( i )   print ( min ( i - j for i , j in zip ( res [ 1 : ] , res ) ) ) NEW_LINE","import sys , math , itertoolsfrom collections import Counter , deque , defaultdictfrom bisect import bisect_left , bisect_right from heapq import heappop , heappush , heapify , nlargestfrom copy import deepcopymod = 10 ** 9 + 7 INF = float ( ' inf ' ) def inp ( ) : return int ( sys . stdin . readline ( ) ) def inpl ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) def inpl_1 ( ) : return list ( map ( lambda x : int ( x ) - 1 , sys . stdin . readline ( ) . split ( ) ) ) def inps ( ) : return sys . stdin . readline ( ) def inpsl ( x ) : tmp = sys . stdin . readline ( ) ; return list ( tmp [ : x ] ) def err ( x ) : print ( x ) ; exit ( )   n = inp ( ) a = inpl ( ) mi = min ( a ) pre = - INFres = INFfor i , x in enumerate ( a ) : if x == mi : res = min ( res , i - pre ) pre = iprint ( res ) NEW_LINE"],"bleu":0.22487351491498325,"rouge_l":0.3067495300784474}
{"id":224,"predictions":["t = int ( input ( ) ) for _ in range ( t ) : s = input ( ) r = 0 a = 0   for i in range ( len ( s ) ) : if s [ i ] == ' P ' : a += 1 elif s [ i ] == ' R ' : if s [ i ] == ' P ' : a += 1 elif s [ i ] == ' S ' : a += 1   print ( a ) NEW_LINE"],"references":["from sys import stdin , stdoutstdin . readlinedef mp ( ) : return list ( map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) ) def it ( ) : return int ( stdin . readline ( ) . strip ( ) ) from collections import defaultdict as dd , Counter as C , dequefrom math import ceil , gcd     NEW_LINE","for _ in range ( int ( input ( ) ) ) : s = input ( ) a = s . count ( ' S ' ) b = s . count ( ' P ' ) c = s . count ( ' R ' ) x = max ( a , b , c ) if a == x : print ( ' R ' * len ( s ) ) elif b == x : print ( ' S ' * len ( s ) ) else : print ( ' P ' * len ( s ) ) NEW_LINE","from collections import Counterd = { ' R ' : ' P ' , ' S ' : ' R ' , ' P ' : ' S ' } for _ in range ( int ( input ( ) ) ) : s = input ( ) . strip ( ) z = Counter ( s )   for i in z : if z [ i ] == max ( z . values ( ) ) : print ( d [ i ] * len ( s ) ) break NEW_LINE"],"bleu":0.3753584829669757,"rouge_l":0.39038398424680015}
{"id":225,"predictions":["def STR ( ) : return list ( input ( ) ) def INT ( ) : return int ( input ( ) ) def MAP ( ) : return map ( int , input ( ) . split ( ) ) def MAP2 ( ) : return map ( float , input ( ) . split ( ) ) def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) def STRING ( ) : return input ( ) import stringimport sysfrom heapq import heappop , heappushfrom bisect import * from collections import deque , Counter , defaultdictfrom math import * from itertools import permutations , accumulatedx = [ - 1 , 1 , 0 , 0 ] dy = [ 0 , 0 , 1 , - 1 ] NEW_LINE"],"references":["import sysimport mathfrom collections import OrderedDictdef input ( ) : return sys . stdin . readline ( ) . strip ( ) def iinput ( ) : return int ( input ( ) ) def minput ( ) : return map ( int , input ( ) . split ( ) ) def listinput ( ) : return list ( map ( int , input ( ) . split ( ) ) ) n , p = minput ( ) s = input ( ) s1 = s [ : ( n - p ) ] s2 = s [ p : ] if ( s1 == s2 and s1 . count ( ' . ' ) == 0 and s2 . count ( ' . ' ) == 0 ) or n == 1 or n == p : print ( ' NO ' ) else : for i in range ( n - p ) : if s [ i ] == ' . ' : if s [ p + i ] == '0' or s [ p + i ] == ' . ' : s = s [ : i ] + '1' + s [ i + 1 : ] else : s = s [ : i ] + '0' + s [ i + 1 : ] break elif s [ p + i ] == ' . ' : if s [ i ] == '0' or s [ i ] == ' . ' : s = s [ : p + i ] + '1' + s [ p + i + 1 : ] else : s = s [ : p + i ] + '0' + s [ p + i + 1 : ] break s = s . replace ( ' . ' , '0' ) print ( s ) NEW_LINE","n , p = map ( int , input ( ) . split ( ) ) s = str ( input ( ) ) t = [ 0 ] * nfor i in range ( n ) : if s [ i ] != ' . ' : t [ i ] = s [ i ] else : if i - p >= 0 : t [ i ] = str ( 1 - int ( t [ i - p ] ) ) else : if i + p <= n - 1 : if s [ i + p ] != ' . ' : t [ i ] = str ( 1 - int ( s [ i + p ] ) ) else : t [ i ] = '0' else : t [ i ] = '0' NEW_LINE","n , p = list ( map ( int , input ( ) . split ( ) ) ) s = list ( input ( ) ) f = 1 for i in range ( n - p ) : if s [ i ] == ' . ' : if s [ i + p ] == ' . ' : s [ i ] = '1' s [ i + p ] = '0' else : s [ i ] = '0' if s [ i + p ] == '1' else '1' else : if s [ i + p ] == ' . ' : s [ i + p ] = '0' if s [ i ] == '1' else '1' for i in range ( n ) : if s [ i ] == ' . ' : s [ i ] = '1' for i in range ( n - p ) : if s [ i + p ] != s [ i ] : f = 0 breakif f : print ( ' No ' ) else : print ( ' ' . join ( s ) ) NEW_LINE"],"bleu":0.41142267500886265,"rouge_l":0.3180056142226975}
{"id":226,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["for _ in range ( int ( input ( ) ) ) : a , b = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE print ( a ^ b ) NEW_LINE","t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( a ^ b ) NEW_LINE","import sys , functools , collections , bisect , math , NEW_LINE INDENT heapqinput = sys . stdin . readline NEW_LINE DEDENT"],"bleu":0.3752641791980672,"rouge_l":0.48321388155413053}
{"id":227,"predictions":["import sys , os , ioimport math , bisect , operatorinf , mod = float ( ' inf ' ) , 10 ** 9 + 7 NEW_LINE"],"references":["    n , r = map ( int , input ( ) . split ( ) )     t = list ( map ( int , input ( ) . split ( ) ) )       arr = [ 0 ] * ( n + 1 )     for i in range ( n ) :   if t [ i ] == 1 : arr [ max ( i - r + 1 , 0 ) ] += 1 arr [ min ( n , i + r ) ] -= 1         for j in range ( 1 , n + 1 ) : arr [ j ] += arr [ j - 1 ]         if 0 in arr [ : n ] : print ( - 1 ) else : ans = 0   for i in range ( n ) : st = max ( 0 , i - r + 1 ) en = min ( i + r , n )   h = 0   for j in range ( st , en ) : if arr [ j ] == 1 : h += 1 if h == 0 : ans += 1 for j in range ( st , en ) : arr [ j ] -= 1   print ( sum ( t ) - ans )                     NEW_LINE","for _ in range ( 1 ) : n , r = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) dp = [ 0 ] * n for i in range ( n ) : if l [ i ] == 1 : for j in range ( max ( 0 , i - r + 1 ) , min ( n , i + r ) ) : dp [ j ] += 1 if 0 in dp : print ( - 1 ) break ans = l . count ( 1 ) for i in range ( n ) : if l [ i ] == 1 : flag = 0 for j in range ( max ( 0 , i - r + 1 ) , min ( n , i + r ) ) : if dp [ j ] == 1 : flag = 1 if flag == 0 : ans += - 1 for j in range ( max ( 0 , i - r + 1 ) , min ( n , i + r ) ) : dp [ j ] -= 1 print ( ans ) NEW_LINE","p = list ( map ( int , input ( ) . split ( ) ) ) n = p [ 0 ] m = p [ 1 ] a = list ( map ( int , input ( ) . split ( ) ) ) c = { } l = int ( 0 ) r = int ( 0 ) ans = int ( 0 ) flag = int ( 0 ) for i in range ( 0 , n ) : c [ i ] = 0 ; while l < n : if c [ l ] == 1 : l = l + 1 continue ff = int ( 0 ) ans = ans + 1 for i in range ( l , min ( n , l + m ) ) : if a [ i ] == 1 : ff = 1 r = i + m if ff == 0 : for i in range ( max ( 0 , l - m + 1 ) , l ) : if a [ i ] == 1 : ff = 1 r = i + m if ff == 0 : flag = 1 break for i in range ( l , r ) : c [ i ] = 1 l = rif flag == 1 : print ( - 1 ) else : print ( ans ) NEW_LINE"],"bleu":7.345944929855182e-5,"rouge_l":0.0790620949687758}
{"id":228,"predictions":["from collections import defaultdict , deque , Counterfrom sys import stdin , stdoutfrom heapq import heappush , heappopimport mathimport ioimport osimport mathimport bisect   NEW_LINE"],"references":["ans = [ ] for i in range ( 27 ) : for j in range ( 27 ) : for t in range ( 27 ) : tempa = [ i , j , t ] s = ' ' for q in range ( len ( tempa ) ) : if ( tempa [ q ] == 26 ) : continue ; else : s += chr ( tempa [ q ] + 97 ) ans . append ( [ len ( s ) , s ] )   ans . sort ( ) pg = [ ]   x = int ( input ( ) ) for i in range ( x ) : s = input ( ) pg . append ( s ) for i in range ( len ( ans ) ) : flag = 0 for j in range ( len ( pg ) ) : if ( ans [ i ] [ 1 ] in pg [ j ] ) : flag += 1 if ( flag == 0 ) : print ( ans [ i ] [ 1 ] ) exit ( )                                               NEW_LINE","import strings = ' ▁ ' . join ( input ( ) for i in range ( int ( input ( ) ) ) ) alph = string . ascii_lowercasefor i in alph : if i not in s : print ( i ) ; exit ( ) for i in alph : for j in alph : if i + j not in s : print ( i + j ) ; exit ( ) NEW_LINE","import stringn = int ( input ( ) ) ; s = ' . ' . join ( input ( ) for _ in range ( n ) ) a = string . ascii_lowercasefor i in a : if i not in s : print ( i ) ; exit ( ) for i in a : for j in a : if i + j not in s : print ( i + j ) ; exit ( ) NEW_LINE"],"bleu":0.0073264803630572585,"rouge_l":0.04037061548643283}
{"id":229,"predictions":["for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE count = 0 NEW_LINE while True : if NEW_LINE s . count ( '1' ) == 0 : NEW_LINE INDENT count += 1 else : NEW_LINE count += 1 NEW_LINE DEDENT print ( count ) NEW_LINE"],"references":["for t in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE r = [ int ( i ) for i in s [ 0 : : 2 ] ] NEW_LINE b = [ int ( i ) for i in s [ 1 : : 2 ] ] NEW_LINE win = 0 NEW_LINE if n % 2 == 1 : win = 2 NEW_LINE for i in r : if NEW_LINE i % 2 == 1 : win = 1 NEW_LINE break else : win = 1 NEW_LINE for i in b : if NEW_LINE i % 2 == 0 : win = 2 NEW_LINE break NEW_LINE print ( win ) NEW_LINE","t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE ali = [ ] NEW_LINE for i in s : ali . append ( int ( i ) ) NEW_LINE","import sys   input = sys . stdin . buffer . readline   t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : n = int ( input ( ) ) NEW_LINE s = input ( ) . strip ( )   if n % 2 == 1 : any_winners = any ( int ( a ) % 2 == 1 for i , a in enumerate ( s ) if i % 2 == 0 ) NEW_LINE print ( 1 if any_winners else 2 ) else : any_winners = any ( int ( a ) % 2 == 0 for i , a in enumerate ( s ) if i % 2 == 1 ) NEW_LINE print ( 2 if any_winners else 1 ) NEW_LINE"],"bleu":0.557612017303538,"rouge_l":0.6357964734010759}
{"id":230,"predictions":["s = input ( ) a , b = map ( str , input ( ) . split ( ) ) NEW_LINE"],"references":["from itertools import permutations   flag = 0 a = input ( ) a_list = list ( permutations ( \" ABC \" ) ) a_list = [ \" \" . join ( x ) for x in a_list ] for x in a_list : if x in a : flag = 1 if flag == 1 : print ( \" Yes \" ) else : print ( \" No \" ) NEW_LINE","s = str ( input ( ) ) n = len ( s ) flag = 0 for i in range ( 1 , n - 1 ) : if ( s [ i ] != ' . ' and s [ i - 1 ] != ' . ' and s [ i + 1 ] != ' . ' ) : if ( s [ i - 1 ] != s [ i ] and s [ i ] != s [ i + 1 ] and s [ i - 1 ] != s [ i + 1 ] ) : flag = 1 if ( flag == 1 ) : print ( \" Yes \" ) else : print ( \" No \" ) NEW_LINE","def solve ( s ) : x = [ ' ABC ' , ' ACB ' , ' BAC ' , ' BCA ' , ' CAB ' , ' CBA ' ] for i in range ( 0 , len ( s ) - 2 ) : if ' ' . join ( s [ i : i + 3 ] ) in x : return ' Yes ' return ' No '                 def main ( ) : NEW_LINE"],"bleu":0.02868092805140797,"rouge_l":0.25558266955200515}
{"id":231,"predictions":["from collections import defaultdictimport sysinput = sys . stdin . readline   n = int ( input ( ) ) s = input ( ) l = [ 0 ] * nfor i in range ( n ) : s += input ( ) l [ s . index ( ' + ' ) ] += 1 NEW_LINE"],"references":["from sys import stdin NEW_LINE input = stdin . readline NEW_LINE input ( ) NEW_LINE * a , = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s , r = [ 0 ] * 2 NEW_LINE cnt = [ 0 ] * 100002 NEW_LINE for i in a : NEW_LINE INDENT cnt [ i ] += 1 NEW_LINE if cnt [ i ] % 4 == 0 : NEW_LINE INDENT s += 1 NEW_LINE DEDENT if cnt [ i ] % 2 == 0 : NEW_LINE INDENT r += 1 NEW_LINE DEDENT DEDENT q = int ( input ( ) ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT sign , n = input ( ) . split ( ) NEW_LINE n = int ( n ) NEW_LINE if sign == ' + ' : NEW_LINE INDENT cnt [ n ] += 1 NEW_LINE if cnt [ n ] % 4 == 0 : NEW_LINE INDENT s += 1 NEW_LINE DEDENT if cnt [ n ] % 2 == 0 : NEW_LINE INDENT r += 1 NEW_LINE DEDENT DEDENT elif sign == ' - ' : NEW_LINE INDENT if cnt [ n ] % 4 == 0 : NEW_LINE INDENT s -= 1 NEW_LINE DEDENT if cnt [ n ] % 2 == 0 : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT cnt [ n ] -= 1 NEW_LINE DEDENT print ( ' YES ' if s > 1 or ( s == 1 and r > 3 ) else ' NO ' ) NEW_LINE DEDENT","from sys import stdin NEW_LINE input = stdin . readline NEW_LINE input ( ) NEW_LINE * a , = map ( int , input ( ) . split ( ) ) NEW_LINE s , r = [ 0 ] * 2 NEW_LINE cnt = [ 0 ] * 100002 NEW_LINE for i in a : NEW_LINE INDENT cnt [ i ] += 1 NEW_LINE if cnt [ i ] % 4 == 0 : NEW_LINE INDENT s += 1 NEW_LINE DEDENT if cnt [ i ] % 2 == 0 : NEW_LINE INDENT r += 1 NEW_LINE DEDENT DEDENT q = int ( input ( ) ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT sign , n = input ( ) . split ( ) NEW_LINE n = int ( n ) NEW_LINE if sign == ' + ' : NEW_LINE INDENT cnt [ n ] += 1 NEW_LINE if cnt [ n ] % 4 == 0 : NEW_LINE INDENT s += 1 NEW_LINE DEDENT if cnt [ n ] % 2 == 0 : NEW_LINE INDENT r += 1 NEW_LINE DEDENT DEDENT elif sign == ' - ' : NEW_LINE INDENT if cnt [ n ] % 4 == 0 : NEW_LINE INDENT s -= 1 NEW_LINE DEDENT if cnt [ n ] % 2 == 0 : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT cnt [ n ] -= 1 NEW_LINE DEDENT print ( ' YES ' if s > 1 or ( s == 1 and r > 3 ) else ' NO ' ) NEW_LINE DEDENT","_ , s , _ , * l = open ( 0 ) NEW_LINE a , b , * d = [ 0 ] * 7 ** 6 NEW_LINE for s in s . split ( ) + l : f = s [ 0 ] < '0' ; t = int ( s [ f : ] ) ; e = s [ 0 ] == ' - ' ; k = 1 - 2 * e ; m = d [ t ] - e ; d [ t ] += k ; a += m % 2 * k ; b += m % 4 \/\/ 3 * k ; print ( ' NYOE ▁ S ' [ a - 3 > 0 < b : f * 6 : 2 ] ) NEW_LINE"],"bleu":0.10994921735811047,"rouge_l":0.23161243376371377}
{"id":232,"predictions":["from math import ceil , sqrt , floor   def isPerfectSquare ( x ) : NEW_LINE"],"references":["k , s , o = int ( input ( ) ) , \" z \" , 97 while k : q = int ( ( ( 1 + 8 * k ) ** .5 - 1 ) \/ 2 ) + 1 k -= q * ( q - 1 ) \/\/ 2 s += chr ( o ) * q o += 1 print ( s ) NEW_LINE","k , s , o = int ( input ( ) ) , \" \" , 97 if k == 0 : s = \" a \" while k : q = int ( ( ( 1 + 8 * k ) ** .5 - 1 ) \/ 2 ) + 1 k -= q * ( q - 1 ) \/\/ 2 s += chr ( o ) * q o += 1 print ( s ) NEW_LINE"],"bleu":0.0028760123872917215,"rouge_l":0.12534246575342464}
{"id":233,"predictions":["import sysfrom math import gcd , sqrt , ceil , log2from collections import defaultdict , Counter , dequefrom bisect import bisect_left , bisect_rightimport mathsys . setrecursionlimit ( 2 * 10 ** 5 + 10 ) import heapqfrom itertools import permutations   NEW_LINE"],"references":["n , c = map ( int , input ( ) . split ( ) ) prices = list ( map ( int , input ( ) . split ( ) ) )   max_i = Nonemax_p = Nonefor i , p in enumerate ( prices ) : if max_p is None or ( i < len ( prices ) - 1 and p - prices [ i + 1 ] > max_p ) : max_i = i max_p = p - prices [ i + 1 ]   print ( max ( 0 , prices [ max_i ] - c - prices [ max_i + 1 ] ) ) NEW_LINE","n , k = map ( int , input ( ) . split ( ) ) x = list ( map ( int , input ( ) . split ( ) ) ) c = 0 l = len ( x ) for i in range ( 1 , l ) : c = max ( c , x [ i - 1 ] - x [ i ] ) c = max ( 0 , c - k ) print ( c )   NEW_LINE","try : n , c = map ( int , input ( ) . split ( ) ) k = [ int ( i ) for i in input ( ) . split ( ) ] a = [ ] for i in range ( n - 1 ) : if ( k [ i ] <= k [ i + 1 ] ) : a . append ( 0 ) else : a . append ( k [ i ] - k [ i + 1 ] ) if ( max ( a ) == 0 or max ( a ) < c ) : print ( 0 ) else : print ( max ( a ) - c ) except : pass NEW_LINE"],"bleu":0.015719319753929945,"rouge_l":0.14712976362759286}
{"id":234,"predictions":["def main_function ( ) : n , k = [ int ( i ) for i in input ( ) . split ( \" ▁ \" ) ] s = set ( s ) ans = 0 for i in s : if i not in s : ans += 1 print ( ans ) main_function ( ) NEW_LINE"],"references":["import sysinput = sys . stdin . readlineimport math   def inpit ( ) : NEW_LINE","from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE","  def getTheGoodNumbersCount ( n , k , nums ) : ''' ▁ a ▁ good ▁ number ▁ is ▁ the ▁ number ▁ that ▁ contain ▁ all ▁ the ▁ digits ▁ for ▁ 0 ▁ to ▁ k ▁ '''   counter = 0   for num in nums : range_list = list ( range ( k + 1 ) ) for digit in num : if int ( digit ) in range_list : range_list . remove ( int ( digit ) ) else : continue if len ( range_list ) == 0 : counter += 1   return counter   if __name__ == ' _ _ main _ _ ' :   n , k = input ( ) . split ( ) n = int ( n ) k = int ( k )   numbers = [ None ] * n for i in range ( n ) : numbers [ i ] = input ( )   print ( getTheGoodNumbersCount ( n , k , numbers ) ) NEW_LINE"],"bleu":0.27936075447971026,"rouge_l":0.4248483486856886}
{"id":235,"predictions":["for i in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEW_LINE a = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE print ( * sorted ( a ) ) NEW_LINE"],"references":["from sys import stdin ''' class ▁ PriorityQueueBase : ▁ ▁ ▁ ▁ class ▁ _ Item : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ _ _ slots _ _ ▁ = ▁ ' _ key ' , ' _ value '   ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ def ▁ _ _ init _ _ ( self , k , v ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ self . _ key ▁ = ▁ k ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ self . _ value ▁ = ▁ v  ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ def ▁ _ _ lt _ _ ( self , other ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ return ▁ self . _ key ▁ < ▁ other . _ key  ▁ ▁ ▁ ▁ def ▁ is _ empty ( self ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ return ▁ len ( self ) ▁ = = ▁ 0 def ▁ queue _ time ( customers , n ) : ▁ ▁ ▁ ▁ for ▁ i ▁ in ▁ range ( 1 , len ( customers ) ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ i ▁ = ▁ i % n ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ while ▁ i % n < n ▁ and ▁ customers [ i % n ] > customers [ ( i + 1 ) % n ] : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ i + = 1 ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ customers [ i % n ] ▁ = customers [ i % n ] ▁ + ▁ customers [ i ] ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ customers [ i ] ▁ = ▁ 0 ▁ ▁ ▁ ▁ return ▁ customers def ▁ phi ( n ) : ▁ ▁ ▁ ▁ result ▁ = ▁ n ▁ ▁ ▁ ▁ for ▁ i ▁ in ▁ range ( 2 , int ( pow ( n , 0.5 ) ) + 1 ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ while ▁ n % i ▁ = = ▁ 0 : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ n \/ = i ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ result - = result \/ i ▁ ▁ ▁ ▁ if ▁ n > 1 : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ result ▁ - = ▁ result \/ n ▁ ▁ ▁ ▁ return ▁ result ''' def main ( ) : input = stdin . buffer . readline for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) a . sort ( ) cur = 0 ans = 0 for i in range ( n ) : cur += 1 if cur == a [ i ] : ans += 1 cur = 0 print ( ans ) main ( ) NEW_LINE","for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) exps = sorted ( list ( map ( int , input ( ) . split ( ) ) ) )   i = 1 count = 0 for exp in exps : if i == exp : count += 1 i = 0 i += 1   print ( count )             NEW_LINE","t = int ( input ( ) ) for i in range ( t ) : n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l . sort ( ) ans = i = 0 for x in l : i += 1 if i == x : ans += 1 i = 0 print ( ans ) NEW_LINE"],"bleu":0.42484001059029847,"rouge_l":0.4906327813129916}
{"id":236,"predictions":["import mathn = int ( input ( ) ) s = input ( ) l = [ ] for i in range ( n ) : if ( s [ i ] != s [ i ] ) : l . append ( s [ i ] ) i = math . ceil ( s [ i ] \/ 2 ) print ( ' ' . join ( l ) ) NEW_LINE"],"references":["n = int ( input ( ) ) s = list ( str ( input ( ) ) ) r = [ \" \" ] * nif n % 2 != 0 : j = n \/\/ 2 for i in range ( n ) : if i % 2 == 0 : r [ j + i ] = s [ i ] j += i else : r [ j - i ] = s [ i ] j -= ielse : j = ( n \/\/ 2 ) - 1 for i in range ( n ) : if i % 2 != 0 : r [ j + i ] = s [ i ] j += i else : r [ j - i ] = s [ i ] j -= i   print ( \" \" . join ( r ) ) NEW_LINE","n = int ( input ( ) ) s = list ( input ( ) )   ans = [ ] if n % 2 == 0 : while s : let = s . pop ( 0 ) ans . insert ( 0 , let ) if not s : break let2 = s . pop ( 0 ) ans . append ( let2 ) else : while s : let2 = s . pop ( 0 ) ans . append ( let2 ) if not s : break let = s . pop ( 0 ) ans . insert ( 0 , let )   print ( \" \" . join ( ans ) )   NEW_LINE","l = int ( input ( ) ) s = input ( ) i = 0 ans = \" \" while ( l > 0 ) : ch = s [ i ] i += 1 if l % 2 == 1 : ans += ch else : ans = ch + ans l -= 1 print ( ans ) NEW_LINE"],"bleu":0.5278230481681019,"rouge_l":0.52609464838567}
{"id":237,"predictions":["def find_cover_all_seg ( n , l , r ) : min = l [ 0 ] index_min = [ ] max = r [ 0 ] index_max = [ ] for i in range ( n ) : if min >= l [ i ] : min = l [ i ] index_min . append ( i ) if max <= r [ i ] : max = r [ i ] index_min . append ( i ) common_index_list = list ( set ( index_min ) . intersection ( index_max ) ) NEW_LINE"],"references":["mod = 1000000007 eps = 10 ** - 9     def main ( ) : import sys from bisect import bisect_left input = sys . stdin . buffer . readline   def calc ( r , g , b ) : return ( r - g ) ** 2 + ( g - b ) ** 2 + ( b - r ) ** 2   for _ in range ( int ( input ( ) ) ) : NR , NG , NB = map ( int , input ( ) . split ( ) ) R = list ( map ( int , input ( ) . split ( ) ) ) G = list ( map ( int , input ( ) . split ( ) ) ) B = list ( map ( int , input ( ) . split ( ) ) ) R . sort ( ) B . sort ( ) G . sort ( ) ans = float ( ' inf ' )   NEW_LINE","import sys , heapq as hinput = sys . stdin . readline   def getInts ( ) : return [ int ( s ) for s in input ( ) . split ( ) ]   def getInt ( ) : return int ( input ( ) )   def getStrs ( ) : return [ s for s in input ( ) . split ( ) ]   def getStr ( ) : return input ( ) . strip ( )   def listStr ( ) : return list ( input ( ) . strip ( ) )   import collections as colimport math   \"\"\" pick ▁ any ▁ triple , ▁ immediately ▁ we ▁ have ▁ an ▁ upper ▁ boundfor ▁ a ▁ given ▁ value ▁ D , ▁ is ▁ it ▁ possible ▁ to ▁ find ▁ a ▁ triple ▁ that ▁ satisfies ▁ ( x - y ) * * 2 ▁ + ▁ ( y - z ) * * 2 ▁ + ▁ ( z - x ) * * 2 ▁ < = ▁ D ? if ▁ the ▁ same ▁ element ▁ appears ▁ in ▁ all ▁ three ▁ arrays , ▁ return ▁ 0can ▁ immediately ▁ discard ▁ any ▁ pairs ▁ s . t . ▁ ( x - y ) * * 2 ▁ > = ▁ D Given ▁ ( x0 , ▁ y0 ) ▁ as ▁ a ▁ candidate ▁ pair , ▁ if ▁ there ▁ are ▁ any ▁ values ▁ of ▁ z ▁ between ▁ x0 ▁ and ▁ y0 , ▁ they ▁ are ▁ the ▁ only ▁ candidates , ▁ with ▁ preference ▁ to ▁ the ▁ one ▁ closest ▁ to ▁ ( x0 + y0 ) \/ 2Otherwise ▁ we ▁ are ▁ interested ▁ in ▁ the ▁ values ▁ of ▁ z ▁ immediately ▁ either ▁ side ▁ of ▁ x0 ▁ and ▁ y0 One ▁ element ▁ has ▁ to ▁ be ▁ in ▁ the ▁ middle ; ▁ given ▁ this , ▁ pick ▁ the ▁ two ▁ immediately ▁ either ▁ side ▁ of ▁ it R ▁ < = ▁ G ▁ < = ▁ BR ▁ < = ▁ B ▁ < = ▁ GG ▁ < = ▁ R ▁ < = ▁ BG ▁ < = ▁ B ▁ < = ▁ RB ▁ < = ▁ R ▁ < = ▁ GB ▁ < = ▁ G ▁ < = ▁ R \"\"\"   def sq_sum ( a , b , c ) : return ( a - b ) ** 2 + ( b - c ) ** 2 + ( c - a ) ** 2   def solve ( ) : NR , NG , NB = getInts ( ) Cols = [ ] for j in range ( 3 ) : Cols . append ( getInts ( ) ) Cols [ j ] . sort ( ) best = 3 * 10 ** 18 + 1 for i in range ( 3 ) : for j in range ( 3 ) : for k in range ( 3 ) : if len ( set ( [ i , j , k ] ) ) == 3 : NEW_LINE","from sys import stdin , stdoutfrom math import gcd , sqrt , factorial , pi , inffrom collections import deque , defaultdictinput = stdin . readlineR = lambda : map ( int , input ( ) . split ( ) ) I = lambda : int ( input ( ) ) S = lambda : input ( ) . rstrip ( ' \\n ' ) L = lambda : list ( R ( ) ) P = lambda x : stdout . write ( str ( x ) + ' \\n ' ) lcm = lambda x , y : ( x * y ) \/\/ gcd ( x , y ) hg = lambda x , y : ( ( y + x - 1 ) \/\/ x ) * xpw = lambda x : 1 if x == 1 else 1 + pw ( x \/\/ 2 ) chk = lambda x : chk ( x \/\/ 2 ) if not x % 2 else True if x == 1 else Falsesm = lambda x : ( x ** 2 + x ) \/\/ 2 N = 10 ** 9 + 7   def lower ( a , r , x ) : l = 0 r -= 1 ans = - 1 while l <= r : m = ( l + r ) \/\/ 2 if a [ m ] <= x : l = m + 1 ans = a [ m ] else : r = m - 1 return ans   def upper ( a , r , x ) : r -= 1 l = 0 ans = - 1 while l <= r : m = ( l + r ) \/\/ 2 if a [ m ] >= x : r = m - 1 ans = a [ m ] else : l = m + 1 return ans   def solve ( a , b , c , x , y , z ) : ans = inf for i in a : j = lower ( b , y , i ) k = upper ( c , z , i ) if j > - 1 and k > - 1 : ans = min ( ans , ( i - j ) ** 2 + ( i - k ) ** 2 + ( k - j ) ** 2 ) return ans   for _ in range ( I ( ) ) : x , y , z = R ( ) r = sorted ( R ( ) ) NEW_LINE"],"bleu":0.08406297535261663,"rouge_l":0.23930443986183136}
{"id":238,"predictions":["from sys import stdin , stdoutstdin . readlinedef mp ( ) : return list ( map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) ) def it ( ) : return int ( stdin . readline ( ) . strip ( ) ) from math import ceilfrom collections import defaultdict as ddfrom collections import Counter as Cn = it ( ) l = sorted ( mp ( ) ) NEW_LINE"],"references":["import math   def total ( l , r ) : l -= 1 if l % 2 == 0 : l \/= 2 else : l = int ( math . ceil ( l \/ 2 ) * - 1 ) if r % 2 == 0 : r \/= 2 else : r = int ( math . ceil ( r \/ 2 ) * - 1 ) return int ( r - l )   q = int ( input ( ) ) ans = \" \"   for i in range ( q ) : l , r = map ( int , input ( ) . split ( ) ) ans += str ( total ( l , r ) ) + \" \\n \"   print ( ans ) NEW_LINE","if __name__ == \" _ _ main _ _ \" : q = int ( input ( ) ) while q : l , r = list ( map ( int , input ( ) . split ( ) ) ) if l == r : if l % 2 == 0 : print ( l ) else : print ( l * - 1 ) else : oc = 0 ec = 0 n = r - l if n % 2 == 0 and l % 2 != 0 : oc = n \/\/ 2 + 1 ec = oc - 1 elif n % 2 == 0 and l % 2 == 0 : oc = n \/\/ 2 ec = oc + 1 else : oc = n \/\/ 2 + 1 ec = oc starte = l if l % 2 == 0 else l + 1 starto = l if l % 2 != 0 else l + 1 sume = ( ec * ( 2 * starte + ( ec - 1 ) * 2 ) ) \/\/ 2 sumo = ( oc * ( 2 * starto + ( oc - 1 ) * 2 ) ) \/\/ 2 print ( sume + ( sumo * - 1 ) ) q = q - 1 NEW_LINE","tc = int ( input ( ) )   def odd ( n ) : return ( ( n + 1 ) \/\/ 2 ) ** 2   def even ( n ) : return int ( n * ( n + 1 ) )   for _ in range ( tc ) : l , r = list ( map ( int , input ( ) . split ( ) ) ) l -= 1 ret = ( even ( r \/\/ 2 ) - even ( l \/\/ 2 ) ) - ( odd ( r ) - odd ( l ) ) print ( ret )   NEW_LINE"],"bleu":0.1964541865425816,"rouge_l":0.3231758789805948}
{"id":239,"predictions":["def STR ( ) : return list ( input ( ) ) def INT ( ) : return int ( input ( ) ) def MAP ( ) : return map ( int , input ( ) . split ( ) ) def MAP2 ( ) : return map ( float , input ( ) . split ( ) ) def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) def STRING ( ) : return input ( ) import stringimport sysfrom heapq import heappop , heappushfrom bisect import * from collections import deque , Counter , defaultdictfrom math import * from itertools import permutations , accumulatedx = [ - 1 , 1 , 0 , 0 ] dy = [ 0 , 0 , 1 , - 1 ] NEW_LINE"],"references":["n = int ( input ( ) ) a = [ int ( x ) for x in input ( ) . split ( ) ] a . sort ( ) print ( min ( a [ - 2 ] - a [ 0 ] , a [ - 1 ] - a [ 1 ] ) ) NEW_LINE","def calc_instability ( lista , a_remover ) : lista . pop ( lista . index ( a_remover ) ) return max ( lista ) - min ( lista )   quant = int ( input ( ) ) lista = list ( map ( int , input ( ) . split ( ) ) ) instability = max ( lista ) - min ( lista )   nova_instability = calc_instability ( lista . copy ( ) , max ( lista ) ) if ( nova_instability < instability ) : instability = nova_instability   nova_instability = calc_instability ( lista . copy ( ) , min ( lista ) ) if ( nova_instability < instability ) : instability = nova_instability   print ( instability ) NEW_LINE","import sysfrom random import * from bisect import * from heapq import * NEW_LINE"],"bleu":0.23997778256652036,"rouge_l":0.5140338367796721}
{"id":240,"predictions":["lst = [ ] for i in range ( 5 ) : lst . append ( list ( map ( int , input ( ) . split ( ) ) ) for j in range ( 3 ) : lst . append ( lst [ i ] [ j ] ) if ( lst [ i ] [ j ] + lst [ i - 1 ] [ j ] ) % 2 == 1 : lst . append ( lst [ i ] [ j ] ) if ( lst [ i ] [ j ] >= 2 ) : print ( '0' ) else : print ( '1' ) NEW_LINE"],"references":["lights = [ [ 1 for _ in range ( 3 ) ] for _ in range ( 3 ) ] count = [ ] for _ in range ( 3 ) : count . append ( [ int ( i ) for i in input ( ) . split ( ' ▁ ' ) ] )   for i , row in enumerate ( count ) : for j , val in enumerate ( row ) : if val % 2 == 1 : lights [ i ] [ j ] = 0 if lights [ i ] [ j ] == 1 else 1 if i > 0 : lights [ i - 1 ] [ j ] = 0 if lights [ i - 1 ] [ j ] == 1 else 1 if i < 2 : lights [ i + 1 ] [ j ] = 0 if lights [ i + 1 ] [ j ] == 1 else 1 if j > 0 : lights [ i ] [ j - 1 ] = 0 if lights [ i ] [ j - 1 ] == 1 else 1 if j < 2 : lights [ i ] [ j + 1 ] = 0 if lights [ i ] [ j + 1 ] == 1 else 1   for row in lights : print ( ' ' . join ( [ str ( i ) for i in row ] ) ) NEW_LINE","c = [ ] for i in range ( 3 ) : b = [ ] b = list ( map ( int , input ( ) . split ( ) ) ) c . append ( b ) a = [ [ 1 , 1 , 1 ] , [ 1 , 1 , 1 ] , [ 1 , 1 , 1 ] ] for i in range ( 3 ) : for j in range ( 3 ) : c [ i ] [ j ] = c [ i ] [ j ] % 2   for i in range ( 3 ) : for j in range ( 3 ) : if c [ i ] [ j ] == 1 : if a [ i ] [ j ] == 0 : a [ i ] [ j ] = 1 else : a [ i ] [ j ] = 0 if i - 1 >= 0 : if a [ i - 1 ] [ j ] == 0 : a [ i - 1 ] [ j ] = 1 else : a [ i - 1 ] [ j ] = 0   if j - 1 >= 0 : if a [ i ] [ j - 1 ] == 0 : a [ i ] [ j - 1 ] = 1 else : a [ i ] [ j - 1 ] = 0   if i + 1 <= 2 : if a [ i + 1 ] [ j ] == 0 : a [ i + 1 ] [ j ] = 1 else : a [ i + 1 ] [ j ] = 0   if j + 1 <= 2 : if a [ i ] [ j + 1 ] == 0 : a [ i ] [ j + 1 ] = 1 else : a [ i ] [ j + 1 ] = 0     s = \" \" for i in range ( 3 ) : s = \" \" for j in range ( 3 ) : s += str ( a [ i ] [ j ] ) print ( s ) NEW_LINE"],"bleu":0.16542730639024406,"rouge_l":0.38813331181955596}
{"id":241,"predictions":["n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( 1 , n + 1 ) : if k > i : k -= i else : breakprint ( - 1 ) NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) ans = 1 for _ in range ( n ) : a = list ( map ( int , input ( ) . split ( ) ) ) ans = max ( ans , min ( a ) ) print ( ans ) NEW_LINE","from sys import stdinn , m = map ( int , stdin . readline ( ) . split ( ) ) print ( max ( [ min ( list ( map ( int , stdin . readline ( ) . split ( ) ) ) ) for i in range ( n ) ] ) ) NEW_LINE","n , m = input ( ) . split ( ) n = int ( n ) m = int ( m ) c = [ [ 0 ] * m for i in range ( n ) ] cc = [ [ 0 ] * n for i in range ( m ) ] for i in range ( n ) : tmp_list = [ int ( each ) for each in input ( ) . split ( ) ] for j in range ( m ) : c [ i ] [ j ] = tmp_list [ j ] cc [ j ] [ i ] = tmp_list [ j ]   res = 0 for i in range ( n ) : res = max ( min ( c [ i ] ) , res ) print ( res ) NEW_LINE"],"bleu":0.6035031534415191,"rouge_l":0.6290366350067843}
{"id":242,"predictions":["A = list ( input ( ) ) B = list ( input ( ) )   zA = A . count ( '1' ) zA += zA += zA & 1   if zA >= B . count ( '1' ) : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"references":["n = int ( input ( ) ) a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] solved = [ 0 for i in range ( 5 ) ] score = [ 0 for i in range ( 5 ) ] for i in range ( n ) : for j in range ( 5 ) : solved [ j ] += int ( a [ i ] [ j ] > - 1 ) for k in range ( 31 * n + 1 ) : for i in range ( 5 ) : tot = n + k cur = solved [ i ] if a [ 0 ] [ i ] > - 1 and a [ 1 ] [ i ] > - 1 and a [ 0 ] [ i ] > a [ 1 ] [ i ] : cur += k score [ i ] = 500 while score [ i ] < 3000 and 2 * cur <= tot : cur *= 2 ; score [ i ] += 500 res = [ 0 , 0 ] for j in range ( 2 ) : for i in range ( 5 ) : if a [ j ] [ i ] > - 1 : res [ j ] += score [ i ] \/ 250 * ( 250 - a [ j ] [ i ] ) if res [ 0 ] > res [ 1 ] : print ( k ) exit ( ) print ( \" - 1\" ) NEW_LINE","n = int ( input ( ) ) a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] solved = [ 0 ] * 5 score = [ 0 ] * 5 for i in range ( n ) : for j in range ( 5 ) : solved [ j ] += int ( a [ i ] [ j ] > - 1 ) for k in range ( 31 * n + 1 ) : for i in range ( 5 ) : tot = n + k cur = solved [ i ] cur += k * ( a [ 0 ] [ i ] > - 1 and a [ 1 ] [ i ] > - 1 and a [ 0 ] [ i ] > a [ 1 ] [ i ] ) score [ i ] = 500 while score [ i ] < 3000 and 2 * cur <= tot : cur *= 2 ; score [ i ] += 500 res = [ 0 , 0 ] for j in range ( 2 ) : for i in range ( 5 ) : res [ j ] += ( a [ j ] [ i ] > - 1 ) * score [ i ] \/ 250 * ( 250 - a [ j ] [ i ] ) if res [ 0 ] > res [ 1 ] : print ( k ) breakelse : print ( \" - 1\" ) NEW_LINE","def f ( v , x , n ) : if v < 0 : return 0 elif x << 1 > n : return int ( 500 * ( 1 - v \/ 250 ) ) elif x << 2 > n : return int ( 1000 * ( 1 - v \/ 250 ) ) elif x << 3 > n : return int ( 1500 * ( 1 - v \/ 250 ) ) elif x << 4 > n : return int ( 2000 * ( 1 - v \/ 250 ) ) elif x << 5 > n : return int ( 2500 * ( 1 - v \/ 250 ) ) else : return int ( 3000 * ( 1 - v \/ 250 ) )   n = int ( input ( ) ) a = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] c = [ sum ( _ [ i ] >= 0 for _ in a ) for i in range ( 5 ) ] ans = - 1 for i in range ( 10000 ) : p , q = 0 , 0 for j in range ( 5 ) : x , y = c [ j ] , n if a [ 0 ] [ j ] > a [ 1 ] [ j ] and a [ 1 ] [ j ] >= 0 : x += i p += f ( a [ 0 ] [ j ] , x , n + i ) q += f ( a [ 1 ] [ j ] , x , n + i ) if p > q : ans = i breakprint ( ans )           NEW_LINE"],"bleu":0.005097225338650237,"rouge_l":0.16984012933357281}
{"id":243,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["import osimport sysfrom io import BytesIO , IOBase   BUFSIZE = 8192     class FastIO ( IOBase ) : newlines = 0   def __init__ ( self , file ) : self . _fd = file . fileno ( ) self . buffer = BytesIO ( ) self . writable = \" x \" in file . mode or \" r \" not in file . mode self . write = self . buffer . write if self . writable else None   def read ( self ) : while True : b = os . read ( self . _fd , max ( os . fstat ( self . _fd ) . st_size , BUFSIZE ) ) if not b : break ptr = self . buffer . tell ( ) self . buffer . seek ( 0 , 2 ) , self . buffer . write ( b ) , self . buffer . seek ( ptr ) self . newlines = 0 return self . buffer . read ( )   def readline ( self ) : while self . newlines == 0 : b = os . read ( self . _fd , max ( os . fstat ( self . _fd ) . st_size , BUFSIZE ) ) self . newlines = b . count ( b \" \\n \" ) + ( not b ) ptr = self . buffer . tell ( ) self . buffer . seek ( 0 , 2 ) , self . buffer . write ( b ) , self . buffer . seek ( ptr ) self . newlines -= 1 return self . buffer . readline ( )   def flush ( self ) : if self . writable : os . write ( self . _fd , self . buffer . getvalue ( ) ) self . buffer . truncate ( 0 ) , self . buffer . seek ( 0 )     class IOWrapper ( IOBase ) : def __init__ ( self , file ) : self . buffer = FastIO ( file ) self . flush = self . buffer . flush self . writable = self . buffer . writable self . write = lambda s : self . buffer . write ( s . encode ( \" ascii \" ) ) self . read = lambda : self . buffer . read ( ) . decode ( \" ascii \" ) self . readline = lambda : self . buffer . readline ( ) . decode ( \" ascii \" )     sys . stdin , sys . stdout = IOWrapper ( sys . stdin ) , IOWrapper ( sys . stdout ) input = lambda : sys . stdin . readline ( ) . rstrip ( \" \\n \" ) NEW_LINE","n = int ( input ( ) ) lst = list ( map ( int , input ( ) . split ( ) ) ) t = int ( input ( ) ) lst . sort ( ) res = 0 from bisect import bisectfor i , x in enumerate ( lst ) : j = bisect ( lst , x + t ) res = max ( res , j - i ) print ( res ) NEW_LINE","n = int ( input ( ) ) lst = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) t = int ( input ( ) ) ans = 1 for i in range ( len ( lst ) - 1 ) : temp = 1 k = i + 1 while k < len ( lst ) and lst [ k ] - lst [ i ] <= t : temp += 1 k += 1 if temp > ans : ans = tempprint ( ans ) NEW_LINE"],"bleu":0.29067956798142036,"rouge_l":0.42214532871972316}
{"id":244,"predictions":["for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) s = input ( ) if n == 1 : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"references":["import sys   from collections import defaultdict   POINTS_WIN = 3 POINTS_DRAW = 1 POINTS_LOSS = 0     def sort_order ( item : dict ) -> tuple : return - item [ \" points \" ] , - item [ \" score _ diff \" ] , - item [ \" score \" ]     def standings ( teams : list , games : list ) -> list : teams_data = { t : defaultdict ( int , { \" name \" : t } ) for t in teams } for lt , rt , ls , rs in games : teams_data [ lt ] [ \" score \" ] += ls teams_data [ rt ] [ \" score \" ] += rs   if ls == rs : teams_data [ lt ] [ \" points \" ] += POINTS_DRAW teams_data [ rt ] [ \" points \" ] += POINTS_DRAW elif ls < rs : teams_data [ lt ] [ \" points \" ] += POINTS_LOSS teams_data [ lt ] [ \" score _ diff \" ] -= rs - ls teams_data [ rt ] [ \" points \" ] += POINTS_WIN teams_data [ rt ] [ \" score _ diff \" ] += rs - ls else : teams_data [ lt ] [ \" points \" ] += POINTS_WIN teams_data [ lt ] [ \" score _ diff \" ] += ls - rs teams_data [ rt ] [ \" points \" ] += POINTS_LOSS teams_data [ rt ] [ \" score _ diff \" ] -= ls - rs   return list ( sorted ( teams_data . values ( ) , key = sort_order ) )     def parse_teams ( n : int ) -> list : teams = [ ] for i in range ( n ) : teams . append ( input ( ) ) return teams     def parse_games ( n : int ) -> list : games = [ ] for _ in range ( int ( n * ( n - 1 ) \/ 2 ) ) : line = sys . stdin . readline ( ) . strip ( ) teams , scores = line . split ( \" ▁ \" ) left_team , right_team = teams . split ( \" - \" ) left_score , right_score = map ( int , scores . split ( \" : \" ) ) games . append ( ( left_team , right_team , left_score , right_score ) )   return games     if __name__ == \" _ _ main _ _ \" : n = int ( input ( ) ) teams = parse_teams ( n ) games = parse_games ( n )   NEW_LINE","n = int ( input ( ) ) class Command : def __init__ ( self , name ) : self . name = name self . score = 0 self . z = 0 self . p = 0 def get_r ( self ) : return self . z - self . p arr = { } for i in range ( n ) : name = input ( ) arr [ name ] = Command ( name ) for i in range ( ( n * ( n - 1 ) ) \/\/ 2 ) : string = input ( ) first , second = string . split ( ) name1 , name2 = first . split ( ' - ' ) num1 , num2 = second . split ( \" : \" ) num1 , num2 = int ( num1 ) , int ( num2 ) if num1 > num2 : arr [ name1 ] . score += 3 elif num1 < num2 : arr [ name2 ] . score += 3 else : arr [ name1 ] . score += 1 arr [ name2 ] . score += 1 arr [ name1 ] . z += num1 arr [ name1 ] . p += num2 arr [ name2 ] . z += num2 arr [ name2 ] . p += num1arr = list ( arr . values ( ) ) for i in range ( len ( arr ) ) : for j in range ( len ( arr ) - 1 ) : if arr [ j ] . score < arr [ j + 1 ] . score : arr [ j ] , arr [ j + 1 ] = arr [ j + 1 ] , arr [ j ] elif arr [ j ] . score == arr [ j + 1 ] . score : if arr [ j ] . get_r ( ) < arr [ j + 1 ] . get_r ( ) : arr [ j ] , arr [ j + 1 ] = arr [ j + 1 ] , arr [ j ] elif arr [ j ] . get_r ( ) == arr [ j + 1 ] . get_r ( ) : if arr [ j ] . z < arr [ j + 1 ] . z : arr [ j ] , arr [ j + 1 ] = arr [ j + 1 ] , arr [ j ] ans = [ ] for i in range ( len ( arr ) \/\/ 2 ) : ans . append ( arr [ i ] . name ) ans . sort ( ) for i in ans : print ( i ) NEW_LINE","class Info : def __init__ ( self , newTeamName , newPoints , newGoalDiff , newScoredGoals ) : self . teamName = newTeamName self . points = newPoints self . goalDiff = newGoalDiff self . scoredGoals = newScoredGoals   def __str__ ( self ) : pattern = ' \\n * * * * * * * * * * * * * * * * * * * * * * * * * \\n ' pattern += f ' teamName : ▁ { self . teamName } ▁ \\n ' pattern += f ' points : ▁ { self . points } ▁ \\n ' pattern += f ' goalDiff : ▁ { self . goalDiff } ▁ \\n ' pattern += f ' scoredGoals : ▁ { self . scoredGoals } ▁ \\n ' pattern += ' * * * * * * * * * * * * * * * * * * * * * * * * * \\n ' return pattern   def __eq__ ( self , other ) : if isinstance ( other , Info ) : return self . teamName == other . teamName and   \\ self . points == other . points and   \\ self . goalDiff == other . goalDiff and   \\ self . scoredGoals == other . scoredGoals return False     NEW_LINE"],"bleu":0.012564314622379554,"rouge_l":0.1074309737529826}
{"id":245,"predictions":["import sys , functools , collections , bisect , math , NEW_LINE INDENT heapqinput = sys . stdin . readline NEW_LINE DEDENT"],"references":["from math import log2   for t in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) )   d = dict ( )   for i in range ( len ( a ) ) : a [ i ] = int ( log2 ( a [ i ] ) )   NEW_LINE","import matht = int ( input ( ) ) NEW_LINE for z in range ( t ) : n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE counter = [ 0 ] * 30 NEW_LINE for i in range ( n ) : counter [ int ( math . log ( arr [ i ] , 2 ) ) ] += 1 NEW_LINE ans = 0 NEW_LINE for num in counter : if NEW_LINE num >= 2 : ans = ans + ( num * ( num - 1 ) ) \/\/ 2 NEW_LINE print ( ans )                                       NEW_LINE","from math import log2   for u in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEW_LINE x = [ int ( w ) for w in input ( ) . split ( ) ] NEW_LINE if ( n == 1 ) : NEW_LINE INDENT print ( 0 ) else : NEW_LINE d = { } NEW_LINE DEDENT for i in x : y = int ( log2 ( i ) ) NEW_LINE d [ y ] = d . get ( y , 0 ) + 1   ans = 0 NEW_LINE for i in d : if NEW_LINE INDENT ( d [ i ] > 1 ) : ans += ( d [ i ] * ( d [ i ] - 1 ) ) \/\/ 2 NEW_LINE DEDENT print ( ans ) NEW_LINE"],"bleu":0.010255829333228777,"rouge_l":0.09422720451937507}
{"id":246,"predictions":["t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n \/\/ 2 + 1 ) NEW_LINE DEDENT DEDENT"],"references":["t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT","cases = int ( input ( ) ) NEW_LINE while cases : NEW_LINE INDENT cases -= 1 NEW_LINE n = int ( input ( ) ) NEW_LINE print ( * list ( range ( n , 0 , - 1 ) ) ) NEW_LINE DEDENT","for s in [ * open ( 0 ) ] [ 1 : ] : print ( * range ( 1 , int ( s ) + 1 ) ) NEW_LINE"],"bleu":0.6547847889122782,"rouge_l":0.7443246311010215}
{"id":247,"predictions":["n = int ( input ( ) ) s = input ( ) f = Nonef = 0 for i in range ( n ) : if s [ i ] == ' U ' : f = True break if f : f = False breakif f == 0 : print ( ' D ' ) else : print ( ' No ' ) NEW_LINE"],"references":["class Stack ( ) : def __init__ ( self ) : self . stack = [ ] self . len = 0   def top ( self ) : assert not self . empty ( ) return self . stack [ self . len - 1 ]   def pop ( self ) : assert not self . empty ( ) self . len -= 1 return self . stack . pop ( )   def push ( self , x ) : self . len += 1 self . stack . append ( x )   def empty ( self ) : return self . len == 0   def calc ( n , pos ) : st = Stack ( ) last_pos = - 1 ans = 0 for i in range ( n ) : if pos [ i ] == \" R \" : if st . empty ( ) : ans += i - last_pos - 1 st . push ( i ) elif pos [ i ] == \" L \" : if st . empty ( ) : last_pos = i else : left_R = st . pop ( ) ; ans += ( i - left_R + 1 ) % 2 last_pos = i if st . empty ( ) : ans += n - last_pos - 1 return ans     n = int ( input ( ) ) pos = str ( input ( ) ) print ( calc ( n , pos ) ) NEW_LINE","n = int ( input ( ) )   domino = input ( )   currLetter = None   prev = 0   res = 0   for i in range ( n ) : if domino [ i ] == \" L \" : count = i - prev + 1 if currLetter == \" R \" : if count % 2 != 0 : count -= 1 res += count   prev = i currLetter = \" L \" if domino [ i ] == \" R \" : if currLetter == \" R \" : res += ( i - prev + 1 )   print ( res ) else : currLetter = \" R \"   prev = i   if currLetter == \" R \" : res += ( n - prev )     print ( n - res ) NEW_LINE","n = int ( input ( ) ) s = str ( input ( ) ) count , p = 0 , 0 while p < n : if s [ p ] == ' R ' or s [ p ] == ' L ' : sp = p + 1 while sp < n : if s [ sp ] != ' R ' and s [ sp ] != ' L ' : sp += 1 else : break if sp == n : break size = sp - p - 1 if s [ p ] == ' R ' and s [ sp ] == ' L ' : count += size % 2 else : count += size p = sp else : p += 1 for j in range ( n ) : if s [ j ] == ' R ' or s [ j ] == ' L ' : breakif s [ j ] != ' L ' : count += jtemp = 0 limit = jfor j in range ( n - 1 , limit - 1 , - 1 ) : if s [ j ] == ' R ' or s [ j ] == ' L ' : break temp += 1 if s [ j ] != ' R ' : count += tempprint ( count ) NEW_LINE"],"bleu":0.1714748236949431,"rouge_l":0.38663209449726305}
{"id":248,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["from functools import cmp_to_key           def calc_lcp ( s , sa ) :   rank = [ 0 for _ in range ( len ( s ) ) ]   for i in range ( len ( s ) ) :   rank [ sa [ i ] ] = i   lcp = [ 0 for _ in range ( len ( s ) - 1 ) ]   h = 0   for i in range ( len ( s ) ) :   if rank [ i ] < len ( s ) - 1 :   while max ( i , sa [ rank [ i ] + 1 ] ) + h < len ( s ) and s [ i + h ] == s [ sa [ rank [ i ] + 1 ] + h ] :   h += 1   lcp [ rank [ i ] ] = h   if h > 0 :   h -= 1   return lcp , rank       def suffix_array ( s ) :   sa = [ i for i in range ( len ( s ) ) ]   rank = [ ord ( s [ i ] ) for i in range ( len ( s ) ) ]   k = 1   while k < len ( s ) :   key = [ 0 for _ in range ( len ( s ) ) ]   base = max ( rank ) + 2   for i in range ( len ( s ) ) :   key [ i ] = rank [ i ] * base + ( rank [ i + k ] + 1 if i + k < len ( s ) else 0 )   sa . sort ( key = ( lambda i : key [ i ] ) )       rank [ sa [ 0 ] ] = 0   for i in range ( 1 , len ( s ) ) :   rank [ sa [ i ] ] = rank [ sa [ i - 1 ] ] if key [ sa [ i - 1 ] ] == key [ sa [ i ] ] else i   k *= 2   NEW_LINE"],"bleu":0.00026365548436288173,"rouge_l":0.11463936232259737}
{"id":249,"predictions":["for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEW_LINE arr = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE print ( * arr ) NEW_LINE"],"references":["from sys import stdin     for _ in range ( int ( stdin . readline ( ) ) ) : n = int ( stdin . readline ( ) ) a = list ( map ( int , stdin . readline ( ) . split ( ) ) ) res = False total = 0 for i in a : if i < 2048 : total += i elif i == 2048 : res = True break if total >= 2048 : res = True   print ( ' YES ' if res else ' NO ' ) NEW_LINE","qtd = int ( input ( ) ) for i in range ( qtd ) : q1 = int ( input ( ) ) lista = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] l1 = input ( ) . split ( ) for j in range ( len ( l1 ) ) : l1 [ j ] = int ( l1 [ j ] ) if ( l1 [ j ] == 2048 ) : lista [ 11 ] += 1 break elif ( l1 [ j ] == 1024 ) : lista [ 10 ] += 1 elif ( l1 [ j ] == 512 ) : lista [ 9 ] += 1 elif ( l1 [ j ] == 256 ) : lista [ 8 ] += 1 elif ( l1 [ j ] == 128 ) : lista [ 7 ] += 1 elif ( l1 [ j ] == 64 ) : lista [ 6 ] += 1 elif ( l1 [ j ] == 32 ) : lista [ 5 ] += 1 elif ( l1 [ j ] == 16 ) : lista [ 4 ] += 1 elif ( l1 [ j ] == 8 ) : lista [ 3 ] += 1 elif ( l1 [ j ] == 4 ) : lista [ 2 ] += 1 elif ( l1 [ j ] == 2 ) : lista [ 1 ] += 1 elif ( l1 [ j ] == 1 ) : lista [ 0 ] += 1 if ( lista [ 11 ] >= 1 ) : print ( \" YES \" ) else : for k in range ( len ( lista ) - 1 ) : lista [ k + 1 ] = int ( lista [ k ] * ( 2 ** k ) \/ ( 2 ** ( k + 1 ) ) ) + lista [ k + 1 ] if ( lista [ 11 ] >= 1 ) : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE","for t in range ( int ( input ( ) ) ) : n = input ( ) l = filter ( lambda x : x <= 2048 , map ( int , input ( ) . split ( ) ) ) print ( ' YES ' if sum ( l ) >= 2048 else ' NO ' ) NEW_LINE"],"bleu":0.5118883952766787,"rouge_l":0.5610807703363035}
{"id":250,"predictions":["n = int ( input ( ) ) r = 0 l = list ( map ( int , input ( ) . split ( ) ) ) for i in l : if i in r : r += 1 else : r += 1 print ( r ) NEW_LINE"],"references":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) k = 0 pas = 0 a = a [ : : - 1 ] for i in set ( a ) : s = a . count ( i ) if s > k : pas = i k = s elif s == k : if a . index ( i ) > a . index ( pas ) : pas = i k = a . count ( i ) print ( pas ) NEW_LINE","a = int ( input ( ) ) b = list ( map ( int , input ( ) . split ( ) ) ) maxi = 0 index = 0 likes = dict ( ) for i in b : if i not in likes : likes [ i ] = 1 if likes [ i ] > maxi : maxi = likes [ i ] index = i else : likes [ i ] += 1 if likes [ i ] > maxi : maxi = likes [ i ] index = iprint ( index ) NEW_LINE","a = int ( input ( ) ) b = list ( map ( int , input ( ) . split ( ) ) ) maxi = 0 index = 0 likes = dict ( ) for i in b : if i not in likes : likes [ i ] = 0 likes [ i ] += 1 if likes [ i ] > maxi : maxi = likes [ i ] index = iprint ( index ) NEW_LINE"],"bleu":0.32408975178451593,"rouge_l":0.5518856390482461}
{"id":251,"predictions":["import math NEW_LINE def prime_list ( n ) : NEW_LINE INDENT s = int ( math . sqrt ( n ) ) NEW_LINE s = math . factorial ( s ) NEW_LINE return s NEW_LINE DEDENT for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT i = int ( input ( ) ) NEW_LINE s = prime_list ( ) NEW_LINE if s % i == 0 : NEW_LINE INDENT print ( 2 ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT"],"references":["for _ in range ( int ( input ( ) ) ) : d = int ( input ( ) ) NEW_LINE def prime ( a ) : for NEW_LINE i in range ( 2 , int ( a ** 0.5 ) + 1 ) : NEW_LINE if a % i == 0 : return False NEW_LINE return True NEW_LINE k = 1 NEW_LINE b = k + d NEW_LINE while not prime ( b ) : b += 1 NEW_LINE k *= b NEW_LINE p = k + d NEW_LINE while not prime ( p ) : p += 1 NEW_LINE print ( k * p ) NEW_LINE","import mathdef NEW_LINE isprime ( n ) : b = 1 NEW_LINE i = 2 NEW_LINE while ( i * i <= math . floor ( n ) ) : if NEW_LINE INDENT ( n % i == 0 ) : b = 0 NEW_LINE DEDENT break ; else : i += 1 NEW_LINE return b   t = int ( input ( ) ) NEW_LINE for i in range ( 0 , t ) : d = int ( input ( ) ) NEW_LINE j = 1 + d NEW_LINE p1 = 1 NEW_LINE p2 = 1 NEW_LINE while True : if NEW_LINE INDENT ( isprime ( j ) == 1 ) : p1 = j NEW_LINE DEDENT break else : j += 1 NEW_LINE k = p1 + d NEW_LINE while True : if NEW_LINE INDENT ( isprime ( k ) == 1 ) : p2 = k NEW_LINE DEDENT break else : k += 1 NEW_LINE print ( p1 * p2 ) NEW_LINE print ( )     NEW_LINE","def isPrime ( n ) : if NEW_LINE ( n <= 1 ) : NEW_LINE return False NEW_LINE if ( n <= 3 ) : return True NEW_LINE if ( n % 2 == 0 or n % 3 == 0 ) : return False NEW_LINE i = 5 NEW_LINE while ( i * i <= n ) : if NEW_LINE ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE return False NEW_LINE i = i + 6 NEW_LINE return Truet = int ( input ( ) ) NEW_LINE for a in range ( t ) : d = int ( input ( ) ) NEW_LINE b1 = 1 NEW_LINE b2 = b1 + d NEW_LINE while ( isPrime ( b2 ) == False ) : b2 += 1 NEW_LINE b3 = b2 + d NEW_LINE while ( isPrime ( b3 ) == False ) : b3 += 1 NEW_LINE print ( b2 * b3 ) NEW_LINE"],"bleu":0.34437651404718317,"rouge_l":0.4138393077525229}
{"id":252,"predictions":["from sys import stdin , stdoutfrom os import pathrd = lambda : stdin . readline ( ) . strip ( ) wr = stdout . writeif ( path . exists ( ' input . txt ' ) ) : stdin = open ( \" input . txt \" , \" r \" ) import time , math NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) s = sum ( l )   def solve ( ) : if s < n : return [ - 1 ] for i in range ( m ) : if l [ i ] > n - i : return [ - 1 ]   ov = s - n idx = 1 sln = [ ]   for i in range ( m ) : if ov > 0 and idx != 1 : d = min ( ov , l [ i - 1 ] - 1 ) idx -= d ov -= d sln . append ( idx ) idx += l [ i ]   return sln   print ( * solve ( ) ) NEW_LINE","def main ( ) : n , m = readIntArr ( ) l = readIntArr ( ) NEW_LINE"],"bleu":0.07239266950906244,"rouge_l":0.4221453287197232}
{"id":253,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) PI = float ( ' inf ' ) for _ in range ( 1 ) : NEW_LINE"],"references":["n = int ( input ( ) ) mn1 , mx1 = map ( int , input ( ) . split ( ) ) mn2 , mx2 = map ( int , input ( ) . split ( ) ) mn3 , mx3 = map ( int , input ( ) . split ( ) )   fd = n - mn2 - mn3if fd > mx1 : fd = mx1n -= fdsd = n - mn3if sd > mx2 : sd = mx2td = n - sdprint ( fd , sd , td ) NEW_LINE","def f ( n , l ) : l1 , r1 = l [ 0 ] l2 , r2 = l [ 1 ] l3 , r3 = l [ 2 ] c1 = min ( r1 , n - l2 - l3 ) c2 = min ( r2 , n - c1 - l3 ) c3 = n - c1 - c2 return [ c1 , c2 , c3 ] n = int ( input ( ) ) l = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( 3 ) ] print ( * f ( n , l ) ) NEW_LINE","n = int ( input ( ) ) a1 , b1 = map ( int , input ( ) . split ( ) ) a2 , b2 = map ( int , input ( ) . split ( ) ) a3 , b3 = map ( int , input ( ) . split ( ) ) ans1 = min ( n - ( a2 + a3 ) , b1 ) ans2 = min ( n - ( ans1 + a3 ) , b2 ) ans3 = n - ( ans1 + ans2 ) print ( ans1 , ans2 , ans3 ) NEW_LINE"],"bleu":0.1775093598308324,"rouge_l":0.34774916453705523}
{"id":254,"predictions":["num = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) )   table = set ( ) ct = 0 mx = 0 for sock in arr : if sock not in table : table . add ( sock ) ct += 1 else : ct -= 1   mx = max ( ct , mx )   print ( mx ) NEW_LINE"],"references":["n , k = map ( int , input ( ) . split ( ) ) s = input ( ) d = { }   val = 0 ; i = 0 while i < n : count = 1 ch = s [ i ] i += 1 while i < n : if s [ i ] == s [ i - 1 ] : count += 1 i += 1 else : break d [ ch ] = d . get ( ch , 0 ) + ( count \/\/ k )   print ( max ( d . values ( ) ) ) NEW_LINE","def abhi ( g ) :     l = 0 r = 0 u = 0 while True : if l == n or r == n : break else : if t [ l ] == g and t [ r ] == g :   if l - r + 1 == x : u += 1 r = l + 1 l += 1 elif l - r + 1 < x : l += 1 else : r = l + 1 l += 1                     return u                                           n , x = map ( int , input ( ) . split ( ) )     t = input ( ) ans = 0     for j in range ( 1 , 27 ) : u = chr ( 96 + j ) ans = max ( abhi ( u ) , ans )       print ( ans ) NEW_LINE","from sys import * ; from math import * ; from collections import * ; from bisect import * INF = maxsizedef get_ints ( ) : return map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) def get_array ( ) : return list ( map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) ) def input ( ) : return stdin . readline ( ) . strip ( ) mod = 1000000007   from string import * n , k = get_ints ( ) s = input ( ) ans = 0 for letter in ascii_lowercase : curr = 0 cnt = 0 for i in range ( n ) : if s [ i ] == letter : curr += 1 if curr == k : cnt += 1 curr = 0 else : curr = 0 ans = max ( ans , cnt ) print ( ans ) NEW_LINE"],"bleu":0.2307367374535709,"rouge_l":0.4043810347312294}
{"id":255,"predictions":["def solution ( ) : k = int ( input ( ) )   st = input ( )   cnt = [ 0 ] * 26   for i in st : cnt [ ord ( i ) - ord ( ' a ' ) ] += 1 for cnts in cnt : if cnts % k != 0 : print ( - 1 ) return ans = ' '   for i in range ( 26 ) : ans += chr ( 97 + i ) * ( cnt [ i ] \/\/ k ) print ( ans * k )     return         if __name__ == ' _ _ main _ _ ' : solution ( ) NEW_LINE"],"references":["from collections import defaultdict as dcdef mlt ( ) : return map ( int , input ( ) . split ( ) ) def arp ( ) : return [ * mlt ( ) ]     s = input ( ) mp = dc ( lambda : 0 ) for n in s : mp [ ord ( n ) - 97 ] += 1 cntr = 0 for n in s : if mp [ ord ( n ) - 97 ] % 2 : cntr += 1   if cntr <= 1 : print ( ' First ' ) else : s1 = [ ' Second ' , ' First ' ] print ( s1 [ len ( s ) % 2 ] ) NEW_LINE","def answer ( s ) : ss = set ( s ) num_odds = 0 for char in ss : ccnt = s . count ( char ) if ccnt % 2 == 1 : NEW_LINE","a = input ( ) dict = { } for i in a : try : dict [ i ] += 1 except : dict [ i ] = 1   t = 0   for i in dict . values ( ) : if i % 2 == 1 : t += 1   print ( \" First \" if t == 0 else \" First \" if t % 2 == 1 else \" Second \" ) NEW_LINE"],"bleu":0.13835950098785502,"rouge_l":0.44313692170440544}
{"id":256,"predictions":["n = int ( input ( ) ) if n == 0 : print ( 0 ) elif n % 2 == 1 : print ( ( n + 1 ) \/\/ 2 ) else : print ( n ) NEW_LINE"],"references":["def dp ( n ) : if n < 0 : return 0 if not n : return 1 return 2 * dp ( n - 2 ) print ( dp ( int ( input ( ) ) ) ) NEW_LINE","n = int ( input ( ) ) if n % 2 == 1 : print ( 0 ) else : print ( 2 ** ( n \/\/ 2 ) ) NEW_LINE","n = int ( input ( ) ) print ( [ 2 ** ( n \/\/ 2 ) , 0 ] [ n & 1 ] ) NEW_LINE"],"bleu":0.6227079395871506,"rouge_l":0.7285254937988058}
{"id":257,"predictions":["import math , sys , bisect , heapq , osfrom collections import defaultdict , Counter , dequefrom itertools import groupby , accumulatefrom functools import lru_cache NEW_LINE"],"references":["def add ( vertex , neighbour ) : if vertex in graph : graph [ vertex ] . append ( neighbour ) else : graph [ vertex ] = [ neighbour ] if neighbour in graph : NEW_LINE"],"bleu":0.0325622657229886,"rouge_l":0.060455896927651125}
{"id":258,"predictions":["n = int ( input ( ) )   if n == 1 : print ( 1 ) elif n == 2 : print ( 2 ) else : ans = [ 1 ] i = 2 while n > 11 : ans . append ( n ) i += 1 print ( * ans ) NEW_LINE"],"references":["n = int ( input ( ) ) NEW_LINE for i in range ( n , 0 , - 1 ) : if NEW_LINE n % i == 0 : n = i NEW_LINE print ( i , end = ' ▁ ' ) NEW_LINE","n = int ( input ( ) ) NEW_LINE s = nl = [ n ] NEW_LINE i = s - 1 NEW_LINE while ( s > 0 ) : if NEW_LINE i == 0 : NEW_LINE break NEW_LINE if s % i == 0 : l . append ( i ) NEW_LINE s = i NEW_LINE i = s - 1 NEW_LINE if i == 0 : NEW_LINE INDENT break else : NEW_LINE i -= 1 NEW_LINE DEDENT print ( * l ) NEW_LINE","n = int ( input ( ) ) NEW_LINE x = [ ] NEW_LINE i = nwhile NEW_LINE i > 0 : NEW_LINE if n % i == 0 : x . append ( i ) NEW_LINE n = i NEW_LINE i = i - 1 NEW_LINE for i in x : print ( i , end = \" ▁ \" ) NEW_LINE"],"bleu":0.27002427028565634,"rouge_l":0.4559800664451827}
{"id":259,"predictions":["def solution ( n , m ) :     if m % n == 0 : t = m \/ n i = 0   while t > 1 :   if t % 2 == 0 : i += 1 t = t \/ 2 continue   elif t % 3 == 0 : i += 1 t = t \/ 3 continue   if t % 4 == 1 : return - 1   else : return - 1       return ans       print ( solution ( ) ) NEW_LINE"],"references":["import sysimport math   n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) i = 1 ans = [ a [ 0 ] ] while i < n : if math . gcd ( ans [ - 1 ] , a [ i ] ) == 1 : ans . append ( a [ i ] ) i += 1 else : ans . append ( 1 ) print ( len ( ans ) - n ) print ( * ans ) NEW_LINE","from math import gcd   n = int ( input ( ) ) a = [ int ( i ) for i in input ( ) . split ( ) ] ans = [ a [ 0 ] ]   for i in range ( n - 1 ) : if gcd ( a [ i ] , a [ i + 1 ] ) != 1 : ans . append ( 1 ) ans . append ( a [ i + 1 ] )   print ( len ( ans ) - len ( a ) ) print ( * ans ) NEW_LINE","import math   def printArr ( arr ) : for i in arr : print ( i , end = \" ▁ \" ) def proA ( arr ) : ans = [ ] i = 0 c = 0 while ( i < len ( arr ) ) : if ( i == len ( arr ) - 1 ) : ans . append ( arr [ - 1 ] ) break if ( math . gcd ( arr [ i ] , arr [ i + 1 ] ) != 1 ) : c += 1 ans . append ( arr [ i ] ) ans . append ( 1 ) else : ans . append ( arr [ i ] ) i += 1 print ( c ) printArr ( ans ) n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) proA ( arr ) NEW_LINE"],"bleu":0.09390516947188493,"rouge_l":0.2627943251875511}
{"id":260,"predictions":["import sysfrom functools import lru_cache , cmp_to_keyfrom heapq import merge , heapify , heappop , heappushfrom math import * from collections import defaultdict as dd , deque , Counter as Cfrom itertools import combinations as comb , permutations as permfrom bisect import bisect_left as bl , bisect_right as br , bisect , insortfrom time import perf_counterfrom fractions import Fractionimport copyfrom copy import deepcopyimport timestarttime = time . time ( ) mod = int ( pow ( 10 , 9 ) + 7 ) mod2 = 998244353   def data ( ) : return sys . stdin . readline ( ) . strip ( ) def out ( * var , end = \" \\n \" ) : sys . stdout . write ( ' ▁ ' . join ( map ( str , var ) ) + end ) def L ( ) : return list ( sp ( ) ) def sl ( ) : return list ( ssp ( ) ) def sp ( ) : return map ( int , data ( ) . split ( ) ) def ssp ( ) : return map ( str , data ( ) . split ( ) ) def l1d ( n , val = 0 ) : return [ val for i in range ( n ) ] def l2d ( n , m , val = 0 ) : return [ l1d ( n , val ) for j in range ( m ) ] try : NEW_LINE"],"references":["t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : n , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE s = list ( s ) NEW_LINE sum = 1 NEW_LINE j = 0 NEW_LINE for i in range ( n ) : if NEW_LINE s [ i ] == ' W ' : j = i NEW_LINE break NEW_LINE l = j NEW_LINE j = j + 1 NEW_LINE lst = [ ] NEW_LINE while j < n : if NEW_LINE s [ l ] == s [ j ] and j - l == 1 : j += 1 NEW_LINE l += 1 elif s [ l ] == s [ j ] and j - l > 1 : lst . append ( [ j - l - 1 , l + 1 ] ) NEW_LINE l = j NEW_LINE j += 1 else : j += 1 NEW_LINE","def main ( ) : for NEW_LINE _ in range ( int ( input ( ) ) ) : n , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE if k >= s . count ( ' L ' ) : NEW_LINE INDENT print ( 2 * n - 1 ) elif ' W ' not in s : NEW_LINE print ( max ( min ( n , k ) * 2 - 1 , 0 ) ) else : NEW_LINE diff , ans , ind = [ ] , s . count ( ' W ' ) , s . index ( ' W ' )   for i in range ( ind + 1 , n ) : if NEW_LINE DEDENT s [ i ] == ' W ' : diff . append ( i - ind - 1 ) NEW_LINE ind = i NEW_LINE diff . sort ( )   for value in diff : if NEW_LINE value <= k : ans += 2 * value + 1 NEW_LINE k -= value NEW_LINE if k > 0 : ans += 2 * k NEW_LINE print ( ans ) NEW_LINE main ( ) NEW_LINE","for _ in range ( int ( input ( ) ) ) : n , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE lnth = sorted ( map ( len , s . strip ( ' L ' ) . split ( ' W ' ) ) , reverse = True ) NEW_LINE m = len ( lnth ) + k - 1 NEW_LINE while lnth and lnth [ - 1 ] <= k : k -= lnth . pop ( ) NEW_LINE print ( ( 2 * min ( n , m ) - len ( lnth ) or 1 ) - 1 )         NEW_LINE"],"bleu":0.14004239226173215,"rouge_l":0.29857529936194394}
{"id":261,"predictions":["for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) s = input ( ) if n == 1 and s [ 0 ] == s [ 1 : print ( \" YES \" ) print ( s [ 0 ] + s [ 0 ] ) else : print ( \" NO \" ) NEW_LINE"],"references":["t = int ( input ( ) ) for _ in range ( t ) : n = int ( input ( ) ) s = input ( ) if n == 2 : if int ( s [ 0 ] ) >= int ( s [ 1 ] ) : print ( \" NO \" ) else : print ( \" YES \" ) print ( 2 ) print ( s [ 0 ] , s [ 1 ] ) else : print ( \" YES \" ) print ( 2 ) print ( s [ 0 ] , s [ 1 : ] ) NEW_LINE","cases = int ( input ( ) ) while cases : cases -= 1 num = int ( input ( ) ) s = input ( )   if num == 2 and int ( s [ 0 ] ) >= int ( s [ 1 ] ) : print ( \" NO \" ) else : print ( \" YES \" ) print ( 2 ) print ( s [ 0 ] , s [ 1 : ] ) NEW_LINE","t = int ( input ( ) ) for _ in range ( int ( t ) ) : n = int ( input ( ) ) s = input ( ) a = int ( s [ 0 ] ) b = int ( s [ 1 : ] ) if a < b : print ( \" YES \" ) print ( 2 ) print ( a , b ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.6937218106508785,"rouge_l":0.6821670042507061}
{"id":262,"predictions":["n = int ( input ( ) ) s = input ( ) if n < 26 : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"references":["n = int ( input ( ) ) s = input ( ) t = s . upper ( ) if len ( set ( t ) ) == 26 : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE","n = int ( input ( ) ) s = input ( )   s1 = set ( s . upper ( ) ) m = len ( s1 ) if m == 26 : print ( \" YES \" ) else : print ( \" NO \" )   NEW_LINE","a = int ( input ( ) ) t = input ( ) b = t . lower ( ) c = [ \" a \" , \" b \" , \" c \" , \" d \" , \" e \" , \" f \" , \" g \" , \" h \" , \" i \" , \" j \" , \" k \" , \" l \" , \" m \" , \" n \" , \" o \" , \" p \" , \" q \" , \" r \" , \" s \" , \" t \" , \" u \" , \" v \" , \" w \" , \" x \" , \" y \" , \" z \" ] for i in range ( len ( b ) ) : if b [ i ] in c : c . remove ( b [ i ] ) if c == [ ] : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.5944707367230966,"rouge_l":0.7621926642482869}
{"id":263,"predictions":["n , k = map ( int , input ( ) . split ( ) ) print ( ( k + n - 1 ) \/\/ n ) NEW_LINE"],"references":["a = input ( ) . rjust ( 10 ** 6 , \"0\" ) b = input ( ) . rjust ( 10 ** 6 , \"0\" ) if a > b : print ( \" > \" ) elif a < b : print ( \" < \" ) elif a == b : print ( \" = \" ) NEW_LINE","aa = input ( ) bb = input ( )   cta = 0 ctb = 0 start = Falsefor let in aa : if let == \"0\" : cta += 1 if let != \"0\" : breakfor let in bb : if let == \"0\" : ctb += 1 if let != \"0\" : breakstart = False   a = aa [ cta : ] b = bb [ ctb : ]       if len ( a ) > len ( b ) : print ( \" > \" ) elif len ( a ) < len ( b ) : print ( \" < \" ) elif a == b : print ( \" = \" ) else : if a > b : print ( \" > \" ) else : print ( \" < \" ) NEW_LINE","a = input ( ) b = input ( )   a = a . lstrip ( '0' ) b = b . lstrip ( '0' )   l = max ( len ( a ) , len ( b ) ) a = a . rjust ( l , \"0\" ) b = b . rjust ( l , \"0\" )   NEW_LINE"],"bleu":0.06401281858415221,"rouge_l":0.30943523841731485}
{"id":264,"predictions":["from math import gcd NEW_LINE def solve ( ) : n = int ( input ( ) ) NEW_LINE a = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE b = [ int ( x ) for x in input ( ) . split ( ) ] for i in a : b [ i ] += 1 NEW_LINE print ( solve ( b ) ) NEW_LINE"],"references":["n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) c = 1 ans = 0 for i in range ( n - 1 ) : if 2 * l [ i ] >= l [ i + 1 ] : c = c + 1 else : ans = max ( c , ans ) c = 1 ans = max ( ans , c ) print ( ans ) NEW_LINE","n , c , m = input ( ) , 1 , 1 a = [ int ( x ) for x in input ( ) . split ( ) ] for i in range ( len ( a ) - 1 ) : if a [ i ] * 2 < a [ i + 1 ] : c , m = 1 , max ( m , c ) else : c += 1 print ( max ( m , c ) ) NEW_LINE","n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) dp = [ 0 ] * ndp [ 0 ] = 1 for i in range ( 1 , n ) : if 2 * l [ i - 1 ] >= l [ i ] : dp [ i ] = dp [ i - 1 ] + 1 else : dp [ i ] = 1 print ( max ( dp ) ) NEW_LINE"],"bleu":0.38524559271367337,"rouge_l":0.5006004803843074}
{"id":265,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["'''   ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Online ▁ Python ▁ Compiler . ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Code , ▁ Compile , ▁ Run ▁ and ▁ Debug ▁ python ▁ program ▁ online . Write ▁ your ▁ code ▁ in ▁ this ▁ editor ▁ and ▁ press ▁ \" Run \" ▁ button ▁ to ▁ execute ▁ it .   '''   n , a , b = map ( int , input ( ) . split ( ) ) mnn = - 1 for i in range ( 1 , n ) : k = n - i p = a \/\/ i q = b \/\/ k mn = min ( p , q ) NEW_LINE","def bs ( l , h ) : while l < h : m = ( l + h + 1 ) \/\/ 2 if gf ( m ) : l = m else : h = m - 1 return l   def gf ( x ) : return a \/\/ x + b \/\/ x >= n   n , a , b = map ( int , input ( ) . split ( ) ) print ( bs ( 0 , min ( a , b ) ) ) NEW_LINE","n , a , b = map ( int , input ( ) . split ( ) ) print ( max ( min ( a \/\/ i , b \/\/ ( n - i ) ) for i in range ( 1 , n ) ) ) NEW_LINE"],"bleu":0.3147376982823424,"rouge_l":0.44953821122649185}
{"id":266,"predictions":["p , y = map ( int , input ( ) . split ( ) )   def div ( n ) : for i in range ( 2 , int ( n ** ( 1 \/ 2 ) ) + 1 ) : if n % i == 0 : return i return n   while y > p : if div ( y ) > p : print ( y ) break y -= 1   if y > p : print ( - 1 ) NEW_LINE"],"references":["s = input ( ) n = len ( s ) sett = { }   for i in range ( n ) : if s [ i ] not in sett : sett [ s [ i ] ] = [ ] sett [ s [ i ] ] . append ( s [ i + 1 : ] + s [ : i ] ) ans = 0   NEW_LINE","def func ( a ) : b = [ 0 ] * 26 for i in range ( len ( a ) ) : b [ ord ( a [ i ] ) - ord ( \" a \" ) ] += 1 c = 0 for i in b : if i == 1 : c = c + 1 return c       s = input ( ) n = len ( s ) a = { } for i in range ( n ) : a [ s [ i ] ] = [ ] for i in range ( n ) : a [ s [ i ] ] . append ( i ) c = 0 for i in a : if len ( a [ i ] ) == 1 : c = c + 1 else : e = [ ] for j in range ( n ) : b = [ ] d = 0 for k in a [ i ] : b . append ( ( s [ ( k + j ) % n ] ) ) d = d + func ( b ) e . append ( d ) c = c + max ( e ) print ( c \/ n ) NEW_LINE","s = input ( ) def uniq ( iii ) : tmp = 0 for jj in range ( 1 , len ( s ) ) : bb = { } for ii in iii : bb . setdefault ( s [ ii - jj ] , [ ] ) . append ( ii ) tmp = max ( tmp , sum ( 1 for vvv in bb . values ( ) if len ( vvv ) == 1 ) ) return tmpaa = { } for ii , ss in enumerate ( s ) : aa . setdefault ( ss , [ ] ) . append ( ii ) ans = 0 for iii in aa . values ( ) : ans += uniq ( iii ) print ( ans \/ len ( s ) ) NEW_LINE"],"bleu":0.17240764543466594,"rouge_l":0.35923441845247833}
{"id":267,"predictions":["n , k = map ( int , input ( ) . split ( ) ) print ( ( k + n - 1 ) \/\/ n ) NEW_LINE"],"references":["a = list ( input ( ) ) x = a . index ( \" ^ \" ) l = 0 r = 0 for i , j in enumerate ( a ) : if i < x and j != \" = \" : l += int ( j ) * ( x - i ) if i > x and j != \" = \" : r += int ( j ) * ( i - x ) if l > r : print ( \" left \" ) elif r > l : print ( \" right \" ) else : print ( \" balance \" ) NEW_LINE","s = input ( ) . split ( \" ^ \" ) l = s [ 0 ] r = s [ 1 ]   l = l [ : : - 1 ] l_v = 0 r_v = 0   for index in range ( 0 , len ( l ) ) : if l [ index ] != \" = \" : l_v += int ( l [ index ] ) * ( index + 1 )   for index in range ( 0 , len ( r ) ) : if r [ index ] != \" = \" : r_v += int ( r [ index ] ) * ( index + 1 )     if l_v == r_v : print ( \" balance \" ) elif l_v > r_v : print ( \" left \" ) else : print ( \" right \" ) NEW_LINE","s = input ( ) piv = s . index ( ' ^ ' ) sum = 0   for i in range ( len ( s ) ) : if s [ i ] . isdigit ( ) : sum += ( i - piv ) * int ( s [ i ] )   if sum == 0 : print ( ' balance ' ) elif sum > 0 : print ( ' right ' ) else : print ( ' left ' ) NEW_LINE"],"bleu":0.04593378134037322,"rouge_l":0.2267432212671335}
{"id":268,"predictions":["import matht = int ( input ( ) ) for _ in range ( t ) : L , R , C = map ( int , input ( ) . split ( ) ) if ( L - L + 1 ) % D == 0 ) : print ( math . ceil ( ( L - R ) \/ D ) ) else : print ( - 1 ) NEW_LINE"],"references":["t = int ( input ( ) ) for _ in range ( t ) : a , b , c = map ( int , input ( ) . split ( ) ) if c < a : print ( c ) else : if b % c == 0 : print ( b + c ) else : print ( ( c + b ) - b % c ) NEW_LINE","def solve ( ) : l , r , d = map ( int , input ( ) . split ( ) ) if d < l or d > r : print ( d ) else : print ( ( int ( r \/ d ) + 1 ) * d )   q = int ( input ( ) ) for _ in range ( q ) : solve ( ) NEW_LINE","for i in range ( int ( input ( ) ) ) : l , r , d = map ( int , input ( ) . split ( ) ) ans = False p = 0 if l > d : ans = True print ( d ) else : if ( r + 1 ) % d == 0 : print ( r + 1 ) else : print ( ( r \/\/ d + 1 ) * d ) NEW_LINE"],"bleu":0.5292678507940718,"rouge_l":0.6474706413730804}
{"id":269,"predictions":["import sysdef input ( ) : return sys . stdin . readline ( ) . strip ( ) def iinput ( ) : return int ( input ( ) ) def minput ( ) : return map ( int , input ( ) . split ( ) ) def listinput ( ) : return list ( map ( int , input ( ) . split ( ) ) ) n , a , b = minput ( ) p = sorted ( a , key = lambda x : x [ 0 ] ) print ( sum ( p ) )   NEW_LINE"],"references":["l , r , a = map ( int , input ( ) . split ( ) ) while a > 0 : if l < r : l = l + 1 else : r = r + 1 a = a - 1 print ( min ( l , r ) * 2 ) NEW_LINE","import sys   def main ( ) : l , r , a = map ( int , sys . stdin . read ( ) . strip ( ) . split ( ) ) t = min ( abs ( l - r ) , a ) a = ( a - t ) \/\/ 2 return 2 * ( min ( l , r ) + t + a ) print ( main ( ) ) NEW_LINE","l , r , a = map ( int , input ( ) . split ( ) ) NEW_LINE"],"bleu":0.2555802674396537,"rouge_l":0.5067079803540231}
{"id":270,"predictions":["from collections import defaultdict   n = int ( input ( ) ) dic = defaultdict ( lambda : 0 ) socks = [ int ( i ) for i in input ( ) . split ( ) ] table = 0 Max = 0   for i in socks : if dic [ i ] == 1 : if Max < table : Max = table table -= 1 else : dic [ i ] = 1 table += 1   print ( Max ) NEW_LINE"],"references":["from statistics import moden = int ( input ( ) ) list_of_numbers = [ int ( x ) for x in input ( ) . split ( ) ] m = mode ( list_of_numbers ) print ( n - list_of_numbers . count ( m ) ) NEW_LINE","n = int ( input ( ) ) secuencia = input ( ) . split ( )   c1 = 0 c2 = 0 c3 = 0   for i in range ( n ) : if secuencia [ i ] == '1' : c1 = c1 + 1 elif secuencia [ i ] == '2' : c2 = c2 + 1 else : c3 = c3 + 1 maximo = max ( c1 , c2 , c3 ) rpta = c1 + c2 + c3 - maximoprint ( rpta ) NEW_LINE","from collections import Counterl = [ ] n = int ( input ( ) ) c = Counter ( list ( map ( int , input ( ) . split ( ) ) ) ) for key , value in c . items ( ) : l . append ( value ) if len ( l ) == 1 : print ( 0 ) elif len ( l ) == 2 : print ( min ( l [ 0 ] , l [ 1 ] ) ) else : print ( min ( l [ 0 ] + l [ 1 ] , l [ 0 ] + l [ 2 ] , l [ 1 ] + l [ 2 ] ) )             NEW_LINE"],"bleu":0.3733322084982689,"rouge_l":0.5538881309686221}
{"id":271,"predictions":["n , t = map ( int , input ( ) . split ( ) ) NEW_LINE"],"references":["def main ( ) : petya_score = 0 vigen_score = 0 petya_time = 0 vigen_time = 0 n , c = map ( int , input ( ) . split ( ) ) task_price = list ( map ( int , input ( ) . split ( ) ) ) task_time = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( 0 , n ) : NEW_LINE","n , c = map ( int , input ( ) . split ( ) ) price = [ int ( i ) for i in input ( ) . split ( ) ] times = [ int ( i ) for i in input ( ) . split ( ) ] time = 0 NEW_LINE","n , c = map ( int , input ( ) . split ( ) ) p = list ( map ( int , input ( ) . split ( ) ) ) t = list ( map ( int , input ( ) . split ( ) ) )   lim = 0 rad = 0 time = 0 for i in range ( n ) : time += t [ i ] point = max ( 0 , p [ i ] - c * time ) lim += pointtime = 0 t = t [ : : - 1 ] p = p [ : : - 1 ] for i in range ( n ) : time += t [ i ] point = max ( 0 , p [ i ] - c * time ) rad += point   if rad == lim : print ( \" Tie \" ) elif lim > rad : print ( \" Limak \" ) else : print ( \" Radewoosh \" ) NEW_LINE"],"bleu":0.08554326114477336,"rouge_l":0.40397350993377484}
{"id":272,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["n = int ( input ( ) ) x = FalseA = [ int ( i ) for i in input ( ) . split ( ) ] for i in range ( n - 2 ) : x1 , x2 = min ( A [ i ] , A [ i + 1 ] ) , max ( A [ i ] , A [ i + 1 ] ) for j in range ( i + 1 , n - 1 ) : X1 , X2 = min ( A [ j ] , A [ j + 1 ] ) , max ( A [ j ] , A [ j + 1 ] ) if ( x1 < X1 and X1 < x2 and x2 < X2 ) : x = True elif ( X1 < x1 and X2 > x1 and X2 < x2 ) : x = Trueif ( x ) : print ( \" yes \" ) else : print ( \" no \" ) NEW_LINE","n = int ( input ( ) ) a = [ * map ( int , input ( ) . split ( ) ) ] b = [ ] for i in range ( n - 1 ) : b . append ( [ min ( a [ i ] , a [ i + 1 ] ) , max ( a [ i ] , a [ i + 1 ] ) ] ) for i in range ( n - 1 ) : for j in range ( n - 1 ) : if i == j : continue if b [ i ] [ 0 ] < b [ j ] [ 0 ] < b [ i ] [ 1 ] < b [ j ] [ 1 ] or b [ i ] [ 0 ] < b [ j ] [ 1 ] < b [ i ] [ 1 ] < b [ j ] [ 0 ] : print ( ' yes ' ) exit ( 0 ) print ( ' no ' ) NEW_LINE","n = int ( input ( ) )   arr = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n - 1 ) : for j in range ( i + 1 , n - 1 ) : a = min ( arr [ i ] , arr [ i + 1 ] ) b = max ( arr [ i ] , arr [ i + 1 ] ) c = min ( arr [ j ] , arr [ j + 1 ] ) d = max ( arr [ j ] , arr [ j + 1 ] ) if a < c < b < d or c < a < d < b : print ( \" yes \" ) exit ( ) print ( ' no ' ) NEW_LINE"],"bleu":0.047351037924145745,"rouge_l":0.27354260089686094}
{"id":273,"predictions":["def STR ( ) : return list ( input ( ) ) def INT ( ) : return int ( input ( ) ) def MAP ( ) : return map ( int , input ( ) . split ( ) ) def MAP2 ( ) : return map ( float , input ( ) . split ( ) ) def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) def STRING ( ) : return input ( ) import stringimport sysfrom heapq import heappop , heappushfrom bisect import * from collections import deque , Counter , defaultdictfrom math import * from itertools import permutations , accumulatedx = [ - 1 , 1 , 0 , 0 ] dy = [ 0 , 0 , 1 , - 1 ] NEW_LINE"],"references":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) R1 , R2 = map ( int , input ( ) . split ( ) ) print ( sum ( a [ R1 - 1 : R2 - 1 ] ) ) NEW_LINE","def main_function ( ) : n = int ( input ( ) ) d = [ int ( i ) for i in input ( ) . split ( \" ▁ \" ) ] a , b = [ int ( i ) for i in input ( ) . split ( \" ▁ \" ) ] sum = 0 a , b = a - 1 , b - 1 for i in range ( a , b ) : sum += d [ i ] return sum       print ( main_function ( ) ) NEW_LINE","n = input ( ) x = list ( map ( int , input ( ) . split ( ) ) ) a , b = map ( int , input ( ) . split ( ) ) print ( sum ( x [ a - 1 : b - 1 : 1 ] ) ) NEW_LINE"],"bleu":0.2599025519617358,"rouge_l":0.4544164597374956}
{"id":274,"predictions":["n = int ( input ( ) ) print ( sum ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE"],"references":["n = int ( input ( ) ) mx = n \/\/ 7 * 2 + min ( n % 7 , 2 ) mn = n \/\/ 7 * 2 + max ( n % 7 - 5 , 0 )   print ( mn , mx )     NEW_LINE","n = int ( input ( ) ) o = 2 * ( n \/\/ 7 ) b = 0 if n % 7 > 1 : b = 2 elif n % 7 == 1 : b = 1 m = 0 if n % 7 == 6 : m = 1 print ( o + m , o + b ) NEW_LINE","n = int ( input ( ) )   print ( 2 * ( n \/\/ 7 ) + ( 1 if n % 7 == 6 else 0 ) , 2 * ( n \/\/ 7 ) + ( n % 7 if n % 7 < 2 else 2 ) ) NEW_LINE"],"bleu":0.20157891931807068,"rouge_l":0.4425353188239786}
{"id":275,"predictions":["C1 = input ( ) NEW_LINE C2 = input ( ) NEW_LINE C1a = C1 [ 2 ] + C1 [ 1 ] + C1 [ 0 ] NEW_LINE C2a = C2 [ 2 ] + C2 [ 1 ] + C2 [ 0 ] NEW_LINE if C1 == C2a and C2 == C1a : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"],"references":["tk = input ( ) m = tk [ 0 ] n = tk [ 1 ] flag = 0 inp2 = list ( map ( str , input ( ) . split ( ) ) )   for st in inp2 : if st [ 0 ] == m : print ( \" YES \" ) flag = 1 break elif st [ 1 ] == n : print ( \" YES \" ) flag = 1 break     if flag == 0 : print ( \" NO \" )                                   NEW_LINE","s = input ( ) l = list ( map ( str , input ( ) . split ( ) ) ) x = s [ 0 ] y = s [ 1 ] for i in range ( len ( l ) ) : if ( l [ i ] [ 0 ] == x ) or ( l [ i ] [ 1 ] == y ) : print ( \" YES \" ) breakelse : print ( \" NO \" ) NEW_LINE","s = input ( ) x = list ( map ( str , input ( ) . split ( ) ) ) d = ' ' . join ( x ) c = 0 for i in s : if i in d : print ( \" YES \" ) break else : c += 1 if c == 2 : print ( \" NO \" ) NEW_LINE"],"bleu":0.2718476689179169,"rouge_l":0.4649949849548646}
{"id":276,"predictions":["def gcd ( a , b ) : if b == 0 : return a return gcd ( b , a % b ) def normalize_rational ( num , den ) : NEW_LINE"],"references":["def main ( ) : a = b = 1 for _ in range ( int ( input ( ) ) ) : s = input ( ) if s in ( \" UL \" , \" DR \" ) : a += 1 elif s in ( \" UR \" , \" DL \" ) : b += 1 elif s == \" ULDR \" : a += 1 b += 1 print ( a * b )     if __name__ == ' _ _ main _ _ ' : main ( ) NEW_LINE","n = int ( input ( ) ) r = 1 ; c = 1 for i in range ( n ) : s = input ( ) if ( len ( s ) == 4 ) : r += 1 ; c += 1 elif ( s == \" UL \" or s == \" DR \" ) : r += 1 else : c += 1 print ( r * c ) NEW_LINE"],"bleu":0.02823643710995041,"rouge_l":0.2564821303433777}
{"id":277,"predictions":["def main ( ) : t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : n , k = map ( int , input ( ) . split ( ) ) NEW_LINE ali = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE q = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ali [ i ] > k ) : NEW_LINE INDENT q . append ( ali [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT q . append ( ali [ i ] ) NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( i + 1 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : main ( ) NEW_LINE"],"references":["import sysfrom os import pathif ( path . exists ( ' input . txt ' ) and path . exists ( ' output . txt ' ) ) : sys . stdout = open ( ' output . txt ' , ' w ' ) sys . stdin = open ( ' input . txt ' , ' r ' )   NEW_LINE","for _ in range ( int ( input ( ) ) ) : n , x = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) ans = 0 k = 0 for i in range ( 1 , n + x + 1 ) : if i not in l : ans += 1 if ans == x : break for j in range ( i + 1 , n + x + 1 ) : if j in l : k += 1 else : break print ( i + k ) NEW_LINE","  t = int ( input ( ) )   for _ in range ( t ) : n , x = tuple ( map ( int , input ( ) . split ( ) ) ) a = list ( map ( int , input ( ) . split ( ) ) )   dp = [ 0 ] * 101 for i in a : dp [ i ] = 1   sm = 0 i = 1 while i < len ( dp ) and x > 0 : if dp [ i ] == 0 : x -= 1 i += 1   if x > 0 : i -= 1 i += x else : while i < len ( dp ) and dp [ i ] == 1 : i += 1 i -= 1 print ( i )   NEW_LINE"],"bleu":0.4316143238946227,"rouge_l":0.5553381096915366}
{"id":278,"predictions":["import sysinput = sys . stdin . readline   n = int ( input ( ) ) A = list ( map ( int , input ( ) . split ( ) ) )   ANS = 0 for i in range ( 26 ) : B = [ ]   for a in A : B . append ( a & ( ( 1 << ( i + 1 ) ) - 1 ) )   B . sort ( )   j0 = n - 1 j1 = n - 1 j2 = n - 1 count = 0   for j in range ( n ) : while j0 >= 0 and B [ j1 ] + B [ j ] >= ( 1 << i ) : j1 -= 1 while j1 >= 0 and B [ j1 ] + B [ j ] > ( 1 << ( i + 1 ) ) - 1 : j1 -= 1   while j2 >= 0 and B [ j2 ] + B [ j ] >= ( 1 << i ) + ( 1 << ( i + 1 ) ) : j2 -= 1   NEW_LINE"],"references":["import io , osinput = io . BytesIO ( os . read ( 0 , os . fstat ( 0 ) . st_size ) ) . readlinefrom collections import defaultdict , dequedef bfs ( node ) : vis [ node ] = 1 q = deque ( [ node ] ) while q : cur = q . popleft ( ) dict1 = { } for j in edge [ cur ] : if vis [ j ] == 0 : vis [ j ] = 1 q . append ( j ) if topic [ j - 1 ] == topic [ cur - 1 ] : return False if topic [ j - 1 ] < topic [ cur - 1 ] : dict1 [ topic [ j - 1 ] ] = 1 b = len ( dict1 . keys ( ) ) if b != topic [ cur - 1 ] - 1 : return False return Truen , m = list ( map ( int , input ( ) . split ( ) ) ) edge = defaultdict ( list ) for i in range ( m ) : u , v = list ( map ( int , input ( ) . split ( ) ) ) edge [ u ] . append ( v ) edge [ v ] . append ( u ) topic = list ( map ( int , input ( ) . split ( ) ) ) vis = [ 0 ] * ( n + 1 ) s = 0 for i in range ( 1 , n + 1 ) : if vis [ i ] == 0 : temp = bfs ( i ) if temp == False : s += 1 breakif s == 1 : print ( - 1 ) else : ans = [ ] for i in range ( n ) : ans . append ( [ topic [ i ] , i + 1 ] ) ans . sort ( key = lambda x : x [ 0 ] , reverse = False ) num = [ ] for i in range ( n ) : num . append ( ans [ i ] [ 1 ] ) print ( \" ▁ \" . join ( str ( x ) for x in num ) ) NEW_LINE","import sysI = lambda : list ( map ( int , input ( ) . split ( ) ) ) input = sys . stdin . buffer . readlinen , m = I ( ) g = [ [ ] for i in range ( n ) ] for i in range ( m ) : x , y = I ( ) ; x -= 1 ; y -= 1 g [ x ] . append ( y ) g [ y ] . append ( x ) col = I ( ) arr = list ( range ( n ) ) arr . sort ( key = lambda x : col [ x ] ) ch = [ 1 ] * nans = [ ] f = 1 for i in arr : t = col [ i ] if t == ch [ i ] : for j in g [ i ] : if ch [ j ] == t : ch [ j ] += 1 ans . append ( i + 1 ) else : f = 0 breakif f : print ( * ans ) else : print ( - 1 ) NEW_LINE","import sysr = sys . stdin . buffer . readlinen , m = map ( int , r ( ) . split ( ) ) network = [ [ ] for _ in range ( n ) ] for _ in range ( m ) : a , b = map ( int , r ( ) . split ( ) ) network [ a - 1 ] . append ( b - 1 ) network [ b - 1 ] . append ( a - 1 ) lst = list ( map ( int , r ( ) . split ( ) ) ) arr = list ( range ( n ) ) arr . sort ( key = lambda x : lst [ x ] ) ret = [ 1 ] * nres = [ ] for i in arr : t = lst [ i ] if t == ret [ i ] : for j in network [ i ] : if ret [ j ] == t : ret [ j ] += 1 res . append ( i + 1 ) else : print ( - 1 ) exit ( 0 ) print ( * res ) NEW_LINE"],"bleu":0.2985866871786362,"rouge_l":0.3933915088940723}
{"id":279,"predictions":["I = inputexec ( int ( I ( ) ) * \" I ( ) ; print ( max ( 0,0 , * map ( len , I ( ) . split ( '0' ) ) ) ) NEW_LINE"],"references":["import sys , functools , collections , bisect , math , NEW_LINE INDENT heapqinput = sys . stdin . readline NEW_LINE DEDENT","for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE print ( n \/\/ 2 - max ( s . count ( '10' ) , s . count ( '01' ) ) ) NEW_LINE","t = int ( input ( ) ) NEW_LINE ans = [ ] NEW_LINE for i in range ( t ) : n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE to = 0 NEW_LINE ti = 0 NEW_LINE for j in range ( 1 , n ) : if NEW_LINE s [ j ] == s [ j - 1 ] : NEW_LINE if s [ j ] == \"1\" : NEW_LINE INDENT ti += 1 else : NEW_LINE to += 1 NEW_LINE DEDENT ans . append ( max ( to , ti ) ) NEW_LINE for k in ans : print ( k ) NEW_LINE"],"bleu":0.2195481970921921,"rouge_l":0.42852125043905864}
{"id":280,"predictions":["def solve ( ) : n = int ( input ( ) ) lst = list ( map ( int , input ( ) . split ( ) ) ) if ( lst [ 0 ] % 2 == 0 ) : print ( \" YES \" ) else : print ( \" NO \" )   NEW_LINE"],"references":["def solve ( ) : n = int ( input ( ) ) NEW_LINE i = 0 NEW_LINE while 2021 * i <= n : if NEW_LINE ( n - ( i * 2021 ) ) % 2020 == 0 : NEW_LINE return True NEW_LINE i += 1 NEW_LINE return False       for t in range ( int ( input ( ) ) ) : if NEW_LINE solve ( ) : print ( ' YES ' ) else : print ( ' NO ' ) NEW_LINE","for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEW_LINE for i in range ( n \/\/ 2021 + 1 ) : if NEW_LINE not ( n - 2021 * i ) % 2020 : print ( \" YES \" ) NEW_LINE break else : print ( \" NO \" ) NEW_LINE","for _ in range ( int ( input ( ) ) ) :     NEW_LINE n = int ( input ( ) )   if n \/\/ 2020 >= n % 2020 : NEW_LINE INDENT print ( ' YES ' ) else : NEW_LINE print ( ' NO ' ) NEW_LINE DEDENT"],"bleu":0.5952925850645062,"rouge_l":0.5595951855024118}
{"id":281,"predictions":["import math as mtimport sys , stringinput = sys . stdin . readlinefrom collections import defaultdictL = lambda : list ( map ( int , input ( ) . split ( ) ) ) Ls = lambda : list ( input ( ) . split ( ) ) M = lambda : map ( int , input ( ) . split ( ) ) I = lambda : int ( input ( ) )   n = I ( ) l = L ( ) m = 0 g = l [ 0 ] for i in l : g = mt . gcd ( g , i ) m = max ( m , i ) ans = ( m \/\/ g - n ) if ( ans % 2 ) : print ( \" Alice \" ) else : print ( \" Bob \" ) NEW_LINE"],"references":["from collections import Counter     def gcd ( a , b ) : return a if b == 0 else gcd ( b , a % b )     n = int ( input ( ) ) count = Counter ( ) for e in map ( int , input ( ) . split ( ) ) : count [ e ] += 1 res = [ ] while sum ( count . values ( ) ) > 0 : cur = max ( count . keys ( ) ) count [ cur ] -= 1 if count [ cur ] == 0 : del count [ cur ] for e in res : g = gcd ( cur , e ) count [ g ] -= 2 if count [ g ] == 0 : del count [ g ] res . append ( cur ) print ( * res ) NEW_LINE","import math as maimport sysinput = sys . stdin . readline   def fu ( b ) : for i in b : if b [ i ] != 0 : return i return - 1   def gcd ( a , b ) : if a % b == 0 : return b else : return gcd ( b , a % b )   n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) a . sort ( reverse = True ) b = { } for i in range ( n * n ) : if a [ i ] in b . keys ( ) : b [ a [ i ] ] += 1 else : b [ a [ i ] ] = 1 c = [ ] for i in b : c . append ( i ) b [ i ] -= 1 breakwhile 1 > 0 : if len ( c ) < n : a = fu ( b ) if a == - 1 : break else : b [ a ] -= 1 for i in range ( len ( c ) ) : b [ gcd ( a , c [ i ] ) ] -= 2 c . append ( a ) else : break   print ( * c ) NEW_LINE","from math import gcdn = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) d = { } for i in arr : d [ i ] = d . get ( i , 0 ) + 1 d = { i : d [ i ] for i in sorted ( d , key = lambda w : - w ) } out = [ ] for i in d : while d [ i ] > 0 : for y in out : d [ gcd ( y , i ) ] -= 2 out += [ i ] d [ i ] -= 1 print ( * out ) NEW_LINE"],"bleu":0.2869820446747133,"rouge_l":0.4097447005281219}
{"id":282,"predictions":["def string_to_list ( s , char ) : collector = \" \" output_list = [ ] for i in range ( len ( s ) ) : if s [ i ] != char : collector += s [ i ] if i == len ( s ) - 1 : output_list . append ( int ( collector ) ) else : output_list . append ( int ( collector ) ) collector = \" \" return output_list     NEW_LINE"],"references":["res = [ ]   for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEW_LINE if n < 0 : NEW_LINE INDENT res . append ( - n ) else : NEW_LINE s = 0 NEW_LINE DEDENT i = 0 NEW_LINE while s < n : i += 1 NEW_LINE s += i NEW_LINE if s == n or s - n > 1 : NEW_LINE INDENT res . append ( i ) else : NEW_LINE res . append ( i + 1 )   for i in res : print ( i ) NEW_LINE DEDENT","t = int ( input ( ) ) NEW_LINE for i in range ( t ) : x = int ( input ( ) ) NEW_LINE c = 0 NEW_LINE sum = 0 NEW_LINE while sum < x : c += 1 NEW_LINE sum = sum + c NEW_LINE re = sum - x NEW_LINE","for t in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEW_LINE i = 1 NEW_LINE while i * ( i + 1 ) \/ 2 < n : i += 1   NEW_LINE"],"bleu":0.1963846742465757,"rouge_l":0.410133591140798}
{"id":283,"predictions":["import math , sysfrom collections import defaultdict , dequeimport bisect as bidef yes ( ) : print ( ' YES ' ) def no ( ) : print ( ' NO ' ) def I ( ) : return ( int ( sys . stdin . readline ( ) ) ) def In ( ) : return ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) def Sn ( ) : return sys . stdin . readline ( ) . strip ( ) def Pr ( x ) : sys . stdout . write ( str ( x ) + ' \\n ' ) NEW_LINE"],"references":["s = input ( ) horizontal = - 1 vertical = - 1 v = [ ] h = [ ] for i in range ( len ( s ) ) : if s [ i ] == \"0\" : vertical += 1 vertical %= 2 if vertical == 0 : ans = 1 else : ans = 3 print ( ans , 1 ) else : horizontal += 1 horizontal %= 4 print ( horizontal + 1 , 2 ) NEW_LINE","s = input ( ) horizontal = - 1 vertical = - 1 v = [ ] h = [ ] for i in range ( len ( s ) ) : if s [ i ] == \"0\" : vertical += 1 vertical %= 2 if vertical == 0 : ans = 1 else : ans = 3 print ( ans , 1 ) else : horizontal += 1 horizontal %= 4 print ( horizontal + 1 , 2 ) NEW_LINE","s = input ( ) v = 0 h = 0 for c in s : if c == '0' : v += 1 print ( 1 , v ) v = v % 4 elif c == '1' : h += 1 print ( 3 , h * 2 - 1 ) h = h % 2 NEW_LINE"],"bleu":0.0310388334635801,"rouge_l":0.17177050334389302}
{"id":284,"predictions":["from math import ceiln = int ( input ( ) ) if n == 1 : print ( 0 ) elif n == 2 : print ( 1 ) elif n == 3 : print ( 1 ) elif n == 1 : print ( n * 4 ) else : print ( 4 * n ) NEW_LINE"],"references":["import mathn = int ( input ( ) ) if ( n == 0 ) : print ( 1 ) elif ( n == 1 ) : print ( 4 ) elif ( n == 2 ) : print ( 8 ) elif ( n == 3 ) : print ( 16 ) else : k = 4 + 8 * ( int ( math . sqrt ( n * n \/ 2 ) ) ) p = int ( math . sqrt ( n * n \/ 2 ) ) if ( p * p + ( p + 1 ) * ( p + 1 ) > n * n ) : k -= 4 print ( k ) NEW_LINE","import matha = int ( input ( ) ) n = 0 if a > 0 : b = int ( math . sqrt ( ( a ** 2 ) \/ 2 ) ) if b ** 2 + ( b + 1 ) ** 2 <= a ** 2 : n = b * 8 + 4 else : n = b * 8 print ( n ) else : print ( '1' )   NEW_LINE","print ( max ( 1 , 4 * int ( int ( input ( ) ) * 2 ** 0.5 ) ) ) NEW_LINE"],"bleu":0.4959325173234696,"rouge_l":0.5433505329366126}
{"id":285,"predictions":["for _ in range ( int ( input ( ) ) ) : a , b = map ( int , input ( ) . split ( ) ) print ( len ( [ ( a , b ] ) \/\/ 2 ) ) NEW_LINE"],"references":["import math as m   t = int ( input ( ) )   for i in range ( t ) : a , b = map ( int , input ( ) . split ( ) ) mx , mn = max ( a , b ) , min ( a , b ) c = 2 * ( mx - mn ) d = 1 ** 2 + 4 * c ds = m . sqrt ( d ) n = ( ds - 1 ) \/ 2 n = int ( n ) if int ( n ) == n else int ( n ) + 1 n += ( n * ( n + 1 ) \/\/ 2 ) % 2 != ( mx - mn ) % 2 n += ( n * ( n + 1 ) \/\/ 2 ) % 2 != ( mx - mn ) % 2 print ( n )   NEW_LINE","import math   for _ in range ( int ( input ( ) ) ) : [ a , b ] = sorted ( list ( map ( int , input ( ) . split ( ) ) ) )           n = math . floor ( ( - 1 + math . sqrt ( 1 + 8 * ( b - a ) ) ) \/ 2 ) a = a + n * ( n + 1 ) \/ 2 while ( ( a - b ) % 2 ) != 0 or a < b : n += 1 a += n print ( n ) NEW_LINE","import sysfrom collections import defaultdictimport math   t = int ( sys . stdin . readline ( ) ) for _ in range ( t ) : a , b = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) x , y = max ( a , b ) , min ( a , b ) dif = x - y n = ( math . sqrt ( 1 + 8 * dif ) - 1 ) \/\/ 2 low , high = int ( max ( 0 , n - 100 ) ) , int ( n + 100 ) ans = 1e10 NEW_LINE"],"bleu":0.199554773364492,"rouge_l":0.4427694025683975}
{"id":286,"predictions":["a = [ int ( i ) for i in input ( ) . split ( ) ] b = sorted ( [ int ( i ) for i in input ( ) . split ( ) ] ) x , y , z = 0 , 0 , 0 for i in range ( len ( a ) ) : if x + y <= 2 * z : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"references":["from collections import Counterimport math   def solve ( ) : a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) n = int ( input ( ) ) sum1 , sum2 = 0 , 0   for i in a : sum1 += i for i in b : sum2 += i   if math . ceil ( sum1 \/ 5 ) + math . ceil ( sum2 \/ 10 ) <= n : return \" YES \"   return \" NO \"                 print ( solve ( ) ) NEW_LINE","a1 , a2 , a3 = map ( int , input ( ) . split ( ) ) b1 , b2 , b3 = map ( int , input ( ) . split ( ) ) n = int ( input ( ) ) a = a1 + a2 + a3b = b1 + b2 + b3shells = 0 if a % 5 != 0 : shells += a \/\/ 5 + 1 else : shells += a \/\/ 5 if b % 10 != 0 : shells += b \/\/ 10 + 1 else : shells += b \/\/ 10 NEW_LINE","import sysinput = sys . stdin . readline   '''   '''   from math import ceil   a1 , a2 , a3 = map ( int , input ( ) . split ( ) ) b1 , b2 , b3 = map ( int , input ( ) . split ( ) ) n = int ( input ( ) ) shelves_cup = ceil ( ( a1 + a2 + a3 ) \/ 5 ) shelves_medal = ceil ( ( b1 + b2 + b3 ) \/ 10 )   print ( \" YES \" if shelves_cup + shelves_medal <= n else \" NO \" ) NEW_LINE"],"bleu":0.29984880052387464,"rouge_l":0.4007764670748096}
{"id":287,"predictions":["import sysfrom math import gcd , sqrt , ceil , log2from collections import defaultdict , Counter , dequefrom bisect import bisect_left , bisect_rightimport mathsys . setrecursionlimit ( 2 * 10 ** 5 + 10 ) import heapqfrom itertools import permutations   NEW_LINE"],"references":["print ( bin ( int ( input ( ) ) ) . count ( '1' ) ) NEW_LINE","x = int ( input ( ) ) print ( bin ( x ) . count ( '1' ) ) NEW_LINE","n = int ( input ( ) ) bin_n = bin ( n ) [ 2 : ] print ( bin_n . count ( '1' ) ) NEW_LINE"],"bleu":0.03865880063854096,"rouge_l":0.143698468786808}
{"id":288,"predictions":["for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) a = [ int ( x ) for x in input ( ) . split ( ) ] x = 0 y = 0 for i in range ( n ) : if i % 2 == 0 : x += a [ i ] x += a [ i % 2 ] y += a [ i ] else : x += a [ i ] x = xprint ( sum ( x ) ) NEW_LINE"],"references":["I = lambda : list ( map ( int , input ( ) . split ( ) ) ) R = range ( I ( ) [ 0 ] ) a = I ( ) b = I ( ) c = I ( ) print ( min ( c [ i ] + c [ j ] + sum ( a [ : i ] + a [ : j ] + b [ i : ] + b [ j : ] ) for i in R for j in R if i != j ) ) NEW_LINE","a = int ( input ( ) ) z = [ [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) , [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) ] r = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) k = [ ] for i in range ( a , 0 , - 1 ) : k . insert ( 0 , sum ( z [ 0 ] [ : i ] ) + r [ i ] + sum ( z [ 1 ] [ i : ] ) ) k1 = [ ] for i in range ( 1 , a + 1 ) : k1 . insert ( 0 , r [ i ] + sum ( z [ 0 ] [ : i ] ) + sum ( z [ 1 ] [ i : ] ) ) s = float ( \" inf \" ) k1 = k1 [ : : - 1 ] for i in range ( a ) : for j in range ( a ) : if i != j : s = min ( s , k [ i ] + k1 [ j ] ) print ( s ) NEW_LINE","a = int ( input ( ) ) z = [ [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) , [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) ] r = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) k = [ ] for i in range ( a , 0 , - 1 ) : k . insert ( 0 , sum ( z [ 0 ] [ : i ] ) + r [ i ] + sum ( z [ 1 ] [ i : ] ) ) k1 = [ ] for i in range ( 1 , a + 1 ) : k1 . insert ( 0 , r [ i ] + sum ( z [ 0 ] [ : i ] ) + sum ( z [ 1 ] [ i : ] ) ) s = 2 * a * 100 k1 = k1 [ : : - 1 ] for i in range ( a ) : for j in range ( a ) : if i != j : s = min ( s , k [ i ] + k1 [ j ] ) print ( s ) NEW_LINE"],"bleu":0.3263158391561121,"rouge_l":0.4275670934923698}
{"id":289,"predictions":["def STR ( ) : return list ( input ( ) ) def INT ( ) : return int ( input ( ) ) def MAP ( ) : return map ( int , input ( ) . split ( ) ) def MAP2 ( ) : return map ( float , input ( ) . split ( ) ) def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) def STRING ( ) : return input ( ) import stringimport sysfrom heapq import heappop , heappushfrom bisect import * from collections import deque , Counter , defaultdictfrom math import * from itertools import permutations , accumulatedx = [ - 1 , 1 , 0 , 0 ] dy = [ 0 , 0 , 1 , - 1 ] NEW_LINE"],"references":["n = int ( input ( ) ) a = [ 0 ] * nb = [ 0 ] * nfor i in range ( n * ( n - 1 ) \/\/ 2 - 1 ) : c , d = list ( map ( int , input ( ) . split ( ) ) ) a [ c - 1 ] += 1 b [ c - 1 ] += 1 b [ d - 1 ] += 1 f = - 1 g = - 1 for i in range ( n ) : if b [ i ] == n - 2 : if f == - 1 : f = i + 1 else : g = i + 1 breakif a [ f - 1 ] > a [ g - 1 ] : print ( f , g ) else : print ( g , f ) NEW_LINE","n = int ( input ( ) ) wins = [ set ( ) for _ in range ( n ) ] looses = [ set ( ) for _ in range ( n ) ] for _ in range ( n * ( n - 1 ) \/\/ 2 - 1 ) : u , v = list ( map ( int , input ( ) . split ( ) ) ) u -= 1 v -= 1 wins [ u ] . add ( v ) looses [ v ] . add ( u )   win_set = { } loose_set = { } winners = [ ] loosers = [ ] for i in range ( n ) : if len ( wins [ i ] ) in win_set : winners . append ( i ) winners . append ( win_set [ len ( wins [ i ] ) ] ) else : win_set [ len ( wins [ i ] ) ] = i if len ( looses [ i ] ) in loose_set : loosers . append ( i ) loosers . append ( loose_set [ len ( looses [ i ] ) ] ) else : loose_set [ len ( looses [ i ] ) ] = i   if loosers [ 0 ] not in wins [ winners [ 0 ] ] and loosers [ 0 ] != winners [ 0 ] : print ( winners [ 0 ] + 1 , loosers [ 0 ] + 1 ) elif loosers [ 0 ] not in wins [ winners [ 1 ] ] and loosers [ 0 ] != winners [ 1 ] : print ( winners [ 1 ] + 1 , loosers [ 0 ] + 1 ) elif loosers [ 1 ] not in wins [ winners [ 1 ] ] and loosers [ 1 ] != winners [ 1 ] : print ( winners [ 1 ] + 1 , loosers [ 1 ] + 1 ) else : print ( winners [ 0 ] + 1 , loosers [ 1 ] + 1 ) NEW_LINE","num = int ( input ( ) ) win = [ ] dic = { } for i in range ( 1 , num + 1 ) : dic [ i ] = num - 1 for i in range ( int ( num * ( num - 1 ) \/ 2 ) - 1 ) : p = input ( ) . split ( ) win . append ( int ( p [ 0 ] ) ) dic [ int ( p [ 0 ] ) ] -= 1 dic [ int ( p [ 1 ] ) ] -= 1 k = [ ] for i in range ( 1 , num + 1 ) : if dic [ i ] != 0 : k . append ( i ) a = win . count ( k [ 0 ] ) b = win . count ( k [ 1 ] ) if a >= b : print ( k [ 0 ] , k [ 1 ] ) else : print ( k [ 1 ] , k [ 0 ] ) NEW_LINE"],"bleu":0.20286896554155426,"rouge_l":0.32124632660607594}
{"id":290,"predictions":["import sys , math , itertoolsfrom collections import Counter , deque , defaultdictfrom bisect import bisect_left , bisect_right from heapq import heappop , heappush , heapifymod = 10 ** 9 + 7 INF = float ( ' inf ' ) def inp ( ) : return int ( sys . stdin . readline ( ) ) def inpl ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) def inpl_1 ( ) : return list ( map ( lambda x : int ( x ) - 1 , sys . stdin . readline ( ) . split ( ) ) ) def inps ( ) : return sys . stdin . readline ( ) def inpsl ( x ) : tmp = sys . stdin . readline ( ) ; return list ( tmp [ : x ] ) def err ( x ) : print ( x ) ; exit ( )   for _ in range ( inp ( ) ) : n = inp ( ) a = inpl ( ) cnt = 0 for i in range ( n ) : NEW_LINE"],"references":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) cnt = { } for x in a : cnt [ x ] = cnt . get ( x , 0 ) + 1 for x in b : cnt [ x ] = cnt . get ( x , 0 ) - 1 if any ( [ abs ( v ) % 2 == 1 for v in cnt . values ( ) ] ) : print ( - 1 ) else : ans = sum ( [ v for v in cnt . values ( ) if v > 0 ] ) \/\/ 2 print ( ans ) NEW_LINE","from sys import stdinn = int ( stdin . readline ( ) ) a = list ( map ( int , stdin . readline ( ) . split ( ) ) ) b = list ( map ( int , stdin . readline ( ) . split ( ) ) ) v = [ 0 ] * ( 6 ) for i in a : v [ i ] += 1 for i in b : v [ i ] -= 1   for i in v : if i % 2 : print ( - 1 ) breakelse : print ( sum ( [ abs ( i ) for i in v ] ) \/\/ 4 ) NEW_LINE","\"\"\" ▁ Created ▁ by ▁ Henrikh ▁ Kantuni ▁ on ▁ 2\/26\/17 ▁ \"\"\"   n = int ( input ( ) ) al = [ int ( x ) for x in input ( ) . split ( ) ] bl = [ int ( x ) for x in input ( ) . split ( ) ] a = { 1 : al . count ( 1 ) , 2 : al . count ( 2 ) , 3 : al . count ( 3 ) , 4 : al . count ( 4 ) , 5 : al . count ( 5 ) , } b = { 1 : bl . count ( 1 ) , 2 : bl . count ( 2 ) , 3 : bl . count ( 3 ) , 4 : bl . count ( 4 ) , 5 : bl . count ( 5 ) , }   possible = Truefor key in a . keys ( ) : if ( a [ key ] + b [ key ] ) % 2 != 0 : possible = False break   if possible : swaps = 0 for key in a . keys ( ) : if a [ key ] > b [ key ] : swaps += ( a [ key ] - b [ key ] ) \/\/ 2 print ( swaps ) else : print ( - 1 ) NEW_LINE"],"bleu":0.269779912205121,"rouge_l":0.42823199049573396}
{"id":291,"predictions":["n = int ( input ( ) ) for i in range ( n ) : a , b , c = [ int ( x ) for x in input ( ) . split ( ) ] if max ( a , b , c ) == a : if b + c - 1 < a - 1 : print ( \" NO \" ) else : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"references":["from sys import stdout   first_rez = [ ]     def req ( x1 , y1 , x2 , y2 ) : print ( ' ? ' , x1 , y1 , x2 , y2 ) stdout . flush ( ) x = int ( input ( ) ) if first_rez : if x1 <= first_rez [ 0 ] <= first_rez [ 2 ] <= x2 and y1 <= first_rez [ 1 ] <= first_rez [ 3 ] <= y2 : x -= 1 NEW_LINE"],"bleu":0.13258176460840548,"rouge_l":0.22305619707467284}
{"id":292,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["import sysfrom collections import defaultdict as ddinput = sys . stdin . readlineI = lambda : list ( map ( int , input ( ) . split ( ) ) )   n , a , b = I ( ) l = I ( ) dic = dd ( int ) for i in range ( n ) : dic [ l [ i ] ] = 1 bs = [ ] pa = dd ( int ) for i in range ( n ) : if dic [ a - l [ i ] ] == 0 : bs . append ( l [ i ] ) else : pa [ l [ i ] ] = a - l [ i ] j = 0 while j < len ( bs ) : for i in range ( j , len ( bs ) ) : cr = bs [ i ] dic [ cr ] = 2 if dic [ b - cr ] == 0 : print ( \" NO \" ) ; exit ( ) dic [ b - cr ] = 2 if dic [ a - b + cr ] == 1 : dic [ a - b + cr ] = 2 bs . append ( a - b + cr ) j += 1 NEW_LINE","def find ( u ) : global par if u != par [ u ] : par [ u ] = find ( par [ u ] ) return par [ u ]   def union ( u , v ) : u = find ( u ) v = find ( v ) par [ u ] = v   n , a , b = map ( int , input ( ) . split ( ) ) p = list ( map ( int , input ( ) . split ( ) ) ) mp = dict ( ) for i in range ( n ) : mp [ p [ i ] ] = i + 1 par = [ i for i in range ( n + 2 ) ]   for i in range ( n ) : union ( i + 1 , mp . get ( a - p [ i ] , n + 1 ) ) union ( i + 1 , mp . get ( b - p [ i ] , 0 ) )   A = find ( 0 ) B = find ( n + 1 )   if A != B : print ( ' YES ' ) print ( ' ▁ ' . join ( [ '1' if find ( i ) == B else '0' for i in range ( 1 , n + 1 ) ] ) ) else : print ( ' NO ' ) NEW_LINE","import sysfrom collections import defaultdict as ddinput = sys . stdin . readlineI = lambda : list ( map ( int , input ( ) . split ( ) ) )   n , a , b = I ( ) l = I ( ) dic = dd ( int ) for i in range ( n ) : dic [ l [ i ] ] = 1 bs = [ ] pa = dd ( int ) for i in range ( n ) : if dic [ a - l [ i ] ] == 0 : bs . append ( l [ i ] ) else : pa [ l [ i ] ] = a - l [ i ] j = 0 while j < len ( bs ) : for i in range ( j , len ( bs ) ) : cr = bs [ i ] dic [ cr ] = 2 if dic [ b - cr ] == 0 : print ( \" NO \" ) ; exit ( ) dic [ b - cr ] = 2 if dic [ a - b + cr ] == 1 : dic [ a - b + cr ] = 2 bs . append ( a - b + cr ) j += 1 NEW_LINE"],"bleu":0.0107272233703022,"rouge_l":0.1922994652406417}
{"id":293,"predictions":["from sys import * input = stdin . readlinen = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) x = 0 y = 0 for i in l : if ( i % 2 == 0 ) : x += 1 else : x += 1 n = iprint ( x ) NEW_LINE"],"references":["import mathn = int ( input ( ) )   arr = [ ]   for i in range ( n ) : arr . append ( int ( input ( ) ) )   res = [ ] flag = Falsefor i in arr : if i % 2 == 0 : res . append ( int ( i \/ 2 ) ) continue if flag : res . append ( math . floor ( i \/ 2 ) ) flag = False else : res . append ( math . ceil ( i \/ 2 ) ) flag = True for i in res : print ( i ) NEW_LINE","import math   n = int ( input ( ) )   p = [ ] non_ints = 0   for _ in range ( n ) : a = int ( input ( ) ) if a % 2 == 0 : p . append ( int ( a \/ 2 ) ) else : non_ints += 1 p . append ( a \/ 2 )   rounded = 0 for pn in p : if type ( pn ) == float : if rounded >= ( non_ints \/ 2 ) : print ( math . floor ( pn ) ) else : print ( math . ceil ( pn ) ) rounded += 1 else : print ( pn ) NEW_LINE","import math   n = int ( input ( ) ) cnt = 0 for _ in range ( n ) : a = int ( input ( ) ) if a % 2 == 0 : print ( a \/\/ 2 ) else : cnt += 1 if cnt % 2 == 1 : print ( math . ceil ( a \/ 2 ) ) else : print ( math . floor ( a \/ 2 ) ) NEW_LINE"],"bleu":0.27306483526262026,"rouge_l":0.41628971107334295}
{"id":294,"predictions":["for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE ls = sorted ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x , y = ls [ i ] , ls [ i ] NEW_LINE if x < y : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["from math import sqrtdef NEW_LINE dist ( a , b ) : NEW_LINE return ( sqrt ( a ** 2 + b ** 2 ) ) NEW_LINE def solve ( ) : n = int ( input ( ) ) NEW_LINE d = [ ] NEW_LINE m = [ ] NEW_LINE for p in range ( 2 * n ) : a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a == 0 : NEW_LINE INDENT m . append ( abs ( b ) ) else : NEW_LINE d . append ( abs ( a ) ) NEW_LINE DEDENT d . sort ( ) NEW_LINE m . sort ( ) NEW_LINE ans = 0 NEW_LINE for x in range ( n ) : ans += dist ( d [ x ] , m [ x ] ) NEW_LINE print ( ans ) NEW_LINE for _ in range ( int ( input ( ) ) ) : solve ( ) NEW_LINE","import java . util . ArrayList ; NEW_LINE import java . util . Collections ; NEW_LINE import java . util . List ; NEW_LINE import java . util . Locale ; NEW_LINE import java . util . Scanner ;   public NEW_LINE class A1495 {   public static void main ( String [ ] args ) { Locale . setDefault ( Locale . US ) ; Scanner in = new Scanner ( System . in ) ; int T = in . nextInt ( ) ; for ( int t = 0 ; t < T ; t + + ) { int N = in . nextInt ( ) ; List < Integer > miners = new ArrayList < > ( N ) ; List < Integer > diamonds = new ArrayList < > ( N ) ; for ( int n = 0 ; n < 2 * N ; n + + ) { int x = in . nextInt ( ) ; int y = in . nextInt ( ) ; if ( x == 0 ) { miners . add ( Math . abs ( y ) ) ; } else { diamonds . add ( Math . abs ( x ) ) ; } } Collections . sort ( miners ) ; Collections . sort ( diamonds ) ; double answer = 0 ; for ( int n = 0 ; n < N ; n + + ) { int x = diamonds . get ( n ) ; int y = miners . get ( n ) ; answer += Math . sqrt ( x * ( long ) x + y * ( long ) y ) ; } System . out . println ( answer ) ; } }   } NEW_LINE","import matht = int ( input ( ) ) NEW_LINE for i in range ( 0 , t ) : n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE b = [ ] NEW_LINE sum = 0 NEW_LINE temp = 0 NEW_LINE for i in range ( 0 , 2 * n ) : x , y = map ( int , input ( ) . split ( ) ) NEW_LINE if x == 0 : NEW_LINE INDENT a . append ( abs ( y ) ) else : NEW_LINE b . append ( abs ( x ) ) NEW_LINE DEDENT a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE for i in range ( 0 , n ) : x = a [ i ] * a [ i ] NEW_LINE y = b [ i ] * b [ i ] NEW_LINE temp = math . sqrt ( x + y ) NEW_LINE sum += temp NEW_LINE print ( sum ) NEW_LINE"],"bleu":0.26679885497328787,"rouge_l":0.44339847473784555}
{"id":295,"predictions":["def STR ( ) : return list ( input ( ) ) def INT ( ) : return int ( input ( ) ) def MAP ( ) : return map ( int , input ( ) . split ( ) ) def MAP2 ( ) : return map ( float , input ( ) . split ( ) ) def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) def STRING ( ) : return input ( ) import stringimport sysfrom heapq import heappop , heappushfrom bisect import * from collections import deque , Counter , defaultdictfrom math import * from itertools import permutations , accumulatedx = [ - 1 , 1 , 0 , 0 ] dy = [ 0 , 0 , 1 , - 1 ] NEW_LINE"],"references":["years = { \"2013\" , \"2014\" , \"2015\" } base = set ( ) for i in range ( 1 , 29 ) : if i < 10 : base . add ( \"0\" + str ( i ) ) else : base . add ( str ( i ) ) info1 = base . copy ( ) info1 . add ( \"29\" ) info1 . add ( \"30\" ) info2 = info1 . copy ( ) info2 . add ( \"31\" ) months = { \"02\" : base } for i in [ 4 , 6 , 9 , 11 ] : if i < 10 : months [ \"0\" + str ( i ) ] = info1 else : months [ str ( i ) ] = info1for i in [ 1 , 3 , 5 , 7 , 8 , 10 , 12 ] : k = ( \"0\" + str ( i ) ) if i < 10 else str ( i ) months [ k ] = info2   s = input ( )   def solve ( s , years , months ) : maps = { } i = 0 while i < len ( s ) - 9 : if s [ i + 2 ] != \" - \" or s [ i + 5 ] != \" - \" : i += 1 continue d , m , y = s [ i : i + 2 ] , s [ i + 3 : i + 5 ] , s [ i + 6 : i + 10 ] if y in years and m in months and d in months [ m ] : k = s [ i : i + 10 ] maps [ k ] = maps . get ( k , 0 ) + 1 i += 1 ans , count = \" \" , 0 for k , v in maps . items ( ) : if count < v : ans , count = k , v return ans             ans = solve ( s , years , months ) print ( ans ) NEW_LINE","s = input ( )   date_ = { 1 : 31 , 2 : 28 , 3 : 31 , 4 : 30 , 5 : 31 , 6 : 30 , 7 : 31 , 8 : 31 , 9 : 30 , 10 : 31 , 11 : 30 , 12 : 31 } def is_Date_Correct ( s ) : return ( 1 <= int ( s [ 3 : 5 ] ) <= 12 and 2013 <= int ( s [ 6 : ] ) <= 2015 and 1 <= int ( s [ : 2 ] ) <= date_ [ int ( s [ 3 : 5 ] ) ] )   def is_dateformat ( s ) : if s [ 2 ] == ' - ' and s [ 5 ] == ' - ' : for i in range ( len ( s ) ) : if i == 2 or i == 5 : continue if s [ i ] == ' - ' : return False ; return True ; return False ;   i = 0 map = { } while ( i < len ( s ) ) : x = s [ i : i + 10 ] if is_dateformat ( x ) and is_Date_Correct ( x ) : if x in map : map [ x ] += 1 else : map [ x ] = 1 i += 8 else : i += 1 if i + 10 > len ( s ) : break   count = 0 res = \" \" for i in map : if map [ i ] > count : res = i count = map [ i ]   print ( res ) NEW_LINE","years = { \"2013\" , \"2014\" , \"2015\" } base = set ( ) for i in range ( 1 , 29 ) : if i < 10 : base . add ( \"0\" + str ( i ) ) else : base . add ( str ( i ) ) info1 = base . copy ( ) info1 . add ( \"29\" ) info1 . add ( \"30\" ) info2 = info1 . copy ( ) info2 . add ( \"31\" ) months = { \"02\" : base } for i in [ 4 , 6 , 9 , 11 ] : if i < 10 : months [ \"0\" + str ( i ) ] = info1 else : months [ str ( i ) ] = info1for i in [ 1 , 3 , 5 , 7 , 8 , 10 , 12 ] : k = ( \"0\" + str ( i ) ) if i < 10 else str ( i ) months [ k ] = info2   s = input ( )   def solve ( s , years , months ) : maps = { } i = 0 while i < len ( s ) - 9 : if s [ i + 2 ] != \" - \" or s [ i + 5 ] != \" - \" : i += 1 continue d , m , y = s [ i : i + 2 ] , s [ i + 3 : i + 5 ] , s [ i + 6 : i + 10 ] if y in years and m in months and d in months [ m ] : k = s [ i : i + 10 ] maps [ k ] = maps . get ( k , 0 ) + 1 i += 1 ans , count = \" \" , 0 for k , v in maps . items ( ) : if count < v : ans , count = k , v return ans             ans = solve ( s , years , months ) print ( ans ) NEW_LINE"],"bleu":0.0242919252546597,"rouge_l":0.21163055724627358}
{"id":296,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) PI = float ( ' inf ' ) for _ in range ( 1 ) : NEW_LINE"],"references":["a = list ( map ( int , input ( ) . split ( ) ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) n = a [ 0 ] dp = [ [ 0 for i in range ( 4 ) ] for j in range ( n + 1 ) ] for i in range ( 4 ) : dp [ 0 ] [ i ] = ( - 10 ) ** ( 27 ) for i in range ( 1 , n + 1 ) : for j in range ( 1 , 4 ) : x = arr [ i - 1 ] * a [ j ] + dp [ i ] [ j - 1 ] y = dp [ i - 1 ] [ j ] dp [ i ] [ j ] = max ( x , y ) print ( dp [ n ] [ 3 ] ) NEW_LINE","def maxSum ( arr , p , q , r ) : premax = - 214748364800000000000000000000000000000 postmax = - 2147483648000000000000000000000000000000 maxx = - 214748364800000000000000000000000000000000000 pre = [ ] post = [ ] for i in arr : premax = max ( p * i , premax ) pre . append ( premax ) for j in range ( len ( arr ) - 1 , - 1 , - 1 ) : postmax = max ( r * arr [ j ] , postmax ) post . append ( postmax ) for i in range ( 0 , len ( arr ) ) : summ = 0 summ = q * arr [ i ] + pre [ i ] + post [ len ( arr ) - i - 1 ] maxx = max ( summ , maxx ) return maxxn , p , q , r = [ int ( v ) for v in input ( ) . split ( ) ] arr = [ int ( v ) for v in input ( ) . split ( ) ] [ : n ] print ( maxSum ( arr , p , q , r ) ) NEW_LINE","import sysn , p , q , r = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) arr = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) def find_pref_sum ( array ) : maxm = - 10000000000000000000 pref_sum = [ 0 ] * n for i in range ( 0 , n ) : pref_sum [ i ] = max ( maxm , array [ i ] * p ) maxm = max ( maxm , array [ i ] * p ) return pref_sum def find_suff_sum ( array ) : maxm = - 10000000000000000000 suff_sum = [ 0 ] * n for j in reversed ( range ( n ) ) : suff_sum [ j ] = max ( maxm , array [ j ] * r ) maxm = max ( maxm , array [ j ] * r ) return suff_sum pref_sum = find_pref_sum ( arr ) suff_sum = find_suff_sum ( arr ) def find_max_expression ( p , q , r , arr ) : max_exp = - 10000000000000000000 for i in range ( 0 , n ) : max_exp = max ( max_exp , max ( p * arr [ i ] , pref_sum [ i ] ) + arr [ i ] * q + max ( r * arr [ i ] , suff_sum [ i ] ) ) return max_exp max_expression_val = find_max_expression ( p , q , r , arr ) print ( max_expression_val ) NEW_LINE"],"bleu":0.044546316308122974,"rouge_l":0.27408531248176465}
{"id":297,"predictions":["n = int ( input ( ) ) a = input ( ) . replace ( ' ▁ ' , ' ' ) a += '00' result = 0 start = 0 count = 0 count0 = 0 for i in range ( n + 2 ) : if a [ i ] == '1' : start = 1 count += 1 count0 = 0 if a [ i ] == '1' and start == 1 : count += 1 count0 += 1 if count0 == 2 : result += ( count - 2 ) count0 = 0 count = 0 start = 0 result += countprint ( result ) NEW_LINE"],"references":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in range ( 1 , n - 1 ) : if ( a [ i ] == 0 and a [ i - 1 ] == 1 and a [ i + 1 ] == 1 ) : a [ i + 1 ] = 0 c += 1 print ( c ) NEW_LINE","n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) ans = 0 used = [ 0 ] * n   for i in range ( 1 , n - 1 ) : if arr [ i + 1 ] == 1 and arr [ i ] == 0 and arr [ i - 1 ] == 1 : ans += 1 used [ i + 1 ] = used [ i - 1 ] = used [ i ] = 1 arr [ i + 1 ] = 0     print ( ans ) NEW_LINE","n = int ( input ( ) ) b = list ( map ( int , input ( ) . split ( ) ) ) k = 0 for i in range ( 1 , n - 1 ) : if b [ i ] == 0 and b [ i + 1 ] == 1 and b [ i - 1 ] == 1 : b [ i + 1 ] = 0 k += 1 print ( k ) NEW_LINE"],"bleu":0.2683346348992769,"rouge_l":0.5300675595024946}
{"id":298,"predictions":["I = input NEW_LINE t = int ( I ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n , k = map ( int , I ( ) . split ( ) ) NEW_LINE li = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT a = I ( ) NEW_LINE if k == 0 : NEW_LINE INDENT li . append ( a ) NEW_LINE break NEW_LINE DEDENT DEDENT li . append ( a ) NEW_LINE DEDENT li = [ ] NEW_LINE for _ in range ( k ) : NEW_LINE INDENT i = 0 NEW_LINE while i < n : NEW_LINE INDENT li . append ( li [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT li . sort ( key = lambda x : x [ 0 ] ) NEW_LINE print ( len ( li ) ) NEW_LINE"],"references":["R = lambda : map ( int , input ( ) . split ( ) ) NEW_LINE t , = R ( ) NEW_LINE exec ( t * ' n , k = R ( ) ; a = { * R ( ) } ; i = 0 \\n while { i } & a : i + = 1 \\n print ( n + ( k > 0 ) * ( k , i + max ( a ) + 1 > > 1not ▁ in ▁ a ) [ i < n ] ) \\n ' ) NEW_LINE","R = lambda : map ( int , input ( ) . split ( ) ) NEW_LINE t , = R ( ) NEW_LINE while t : NEW_LINE INDENT t -= 1 ; NEW_LINE n , k = R ( ) ; NEW_LINE a = sorted ( R ( ) ) ; NEW_LINE i = 0 NEW_LINE for x in a : NEW_LINE INDENT if i < x : break NEW_LINE i += 1 NEW_LINE DEDENT print ( n + ( k > 0 ) * ( i + a [ - 1 ] + 1 >> 1 not in a , k ) [ i > a [ - 1 ] ] ) NEW_LINE DEDENT","R = lambda : map ( int , input ( ) . split ( ) ) NEW_LINE t , = R ( ) NEW_LINE while t : NEW_LINE INDENT t -= 1 ; NEW_LINE n , k = R ( ) ; NEW_LINE a = sorted ( R ( ) ) ; NEW_LINE i = 0 NEW_LINE for x in a : NEW_LINE INDENT if i < x : break NEW_LINE i += 1 NEW_LINE DEDENT print ( n + ( k > 0 ) * ( k , i + a [ - 1 ] + 1 >> 1 not in a ) [ i < n ] ) NEW_LINE DEDENT"],"bleu":0.22674222264778224,"rouge_l":0.3972165474974464}
{"id":299,"predictions":["from math import gcddef lcm ( a , b ) : return a * b \/\/ gcd ( a , b ) n = int ( input ( ) ) a , b = map ( int , input ( ) . split ( ) ) g = gcd ( a , b ) print ( gcd ( lcm ( a , b ) , 6 ) ) NEW_LINE"],"references":["import mathn , m = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) q = list ( map ( int , input ( ) . split ( ) ) ) if m > n : print ( \"0\/1\" ) elif n > m : if ( l [ 0 ] > 0 and q [ 0 ] > 0 ) or ( l [ 0 ] < 0 and q [ 0 ] < 0 ) : print ( \" Infinity \" ) else : print ( \" - Infinity \" )           else : a = abs ( l [ 0 ] ) b = abs ( q [ 0 ] ) while math . gcd ( a , b ) > 1 : c = math . gcd ( a , b ) a = a \/\/ c b = b \/\/ c if l [ 0 ] > 0 and q [ 0 ] > 0 : print ( str ( a ) + \" \/ \" + str ( b ) ) elif l [ 0 ] < 0 and q [ 0 ] < 0 : print ( str ( a ) + \" \/ \" + str ( b ) ) else : print ( \" - \" + str ( a ) + \" \/ \" + str ( b ) )   \t \t       \t \t   NEW_LINE","from sys import stdin , stdoutfrom math import gcdnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE","from fractions import Fractiondef limit ( a , b ) :   if len ( a ) > len ( b ) : if ( a [ 0 ] > 0 and b [ 0 ] > 0 ) or ( a [ 0 ] < 0 and b [ 0 ] < 0 ) : return \" Infinity \" else : return \" - Infinity \" if len ( b ) > len ( a ) : return \"0\" + \" \/ \" + \"1\" else : c = \" \" if a [ 0 ] < 0 and b [ 0 ] > 0 : c = \" - \" if a [ 0 ] > 0 and b [ 0 ] < 0 : c = \" - \" a [ 0 ] = abs ( a [ 0 ] ) b [ 0 ] = abs ( b [ 0 ] ) ans = Fraction ( a [ 0 ] \/ b [ 0 ] ) . limit_denominator ( ) . as_integer_ratio ( ) return c + str ( ans [ 0 ] ) + \" \/ \" + str ( ans [ 1 ] ) a = input ( ) lst = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) lst2 = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) print ( limit ( lst , lst2 ) ) NEW_LINE"],"bleu":0.48219492841507156,"rouge_l":0.5820895522388059}
{"id":300,"predictions":["for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT ans = abs ( l [ i ] - l [ j ] ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT"],"references":["t = int ( input ( ) )   for tc in range ( t ) : n = int ( input ( ) )   athletes = [ int ( z ) for z in input ( ) . split ( ) ]   athletes . sort ( )   res = [ ]   for i in range ( 1 , n ) : a = athletes [ : i ] b = athletes [ i : ]   res . append ( abs ( max ( a ) - min ( b ) ) )   print ( min ( res ) ) NEW_LINE","for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) s = list ( map ( int , input ( ) . split ( ) ) ) s . sort ( ) x = [ ] for i in range ( 1 , n ) : x . append ( s [ i ] - s [ i - 1 ] ) print ( min ( x ) ) NEW_LINE","n = int ( input ( ) ) for i in range ( n ) : x = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l . sort ( ) s = [ None ] * ( x - 1 ) for i in range ( x - 1 ) : s [ i ] = ( l [ i + 1 ] - l [ i ] ) print ( min ( s ) ) NEW_LINE"],"bleu":0.573467093474632,"rouge_l":0.6917406917406917}
{"id":301,"predictions":["n = int ( input ( ) ) print ( n \/\/ 2 + 1 ) NEW_LINE"],"references":["n = int ( input ( ) ) arr = [ [ 0 , 0 ] for i in range ( n ) ]   for i in range ( n ) : arr [ i ] [ 0 ] , arr [ i ] [ 1 ] = map ( int , input ( ) . split ( ) )   NEW_LINE","n = int ( input ( ) ) now = 0 for i in range ( n ) : s , d = map ( int , input ( ) . split ( ) ) now = max ( now + 1 , s ) now = ( now + d - 1 - s ) \/\/ d * d + sprint ( now ) NEW_LINE","def solve ( arr ) : day = arr [ 0 ] [ 0 ] + 1 for i in range ( 1 , len ( arr ) ) : if day > arr [ i ] [ 0 ] : n = ( day - arr [ i ] [ 0 ] ) % arr [ i ] [ 1 ] if n == 0 : day += 1 else : n = ( ( day - arr [ i ] [ 0 ] ) \/\/ arr [ i ] [ 1 ] ) + 1 day += arr [ i ] [ 0 ] + n * arr [ i ] [ 1 ] - day + 1 else : day += arr [ i ] [ 0 ] - day + 1 return day - 1                                         def main ( ) : NEW_LINE"],"bleu":0.042330267837083706,"rouge_l":0.30489111031774363}
{"id":302,"predictions":["for _ in range ( int ( input ( ) ) ) : n , k = map ( int , input ( ) . split ( ) ) if k <= n : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"references":["def binary ( data , target , low , high ) : if low > high : return high else : mid = int ( ( low + high ) \/ 2 ) if data [ mid ] <= target : return binary ( data , target , mid + 1 , high ) else : return binary ( data , target , low , mid - 1 ) for _ in range ( int ( input ( ) ) ) : a , b = map ( int , input ( ) . split ( ) ) l = [ 1 ] n = 1 for i in range ( 1 , a - 1 ) : l . append ( l [ - 1 ] + n ) n += 1 result = [ \" a \" ] * a k = binary ( l , b , 0 , len ( l ) - 1 ) k += 1 result [ a - 1 - k ] = \" b \" result [ - 1 - ( b - l [ k - 1 ] ) ] = \" b \" print ( * result , sep = \" \" )   NEW_LINE","for _ in range ( int ( input ( ) ) ) : n , k = map ( int , input ( ) . split ( ) ) s = [ ' a ' ] * n for i in range ( 1 , n + 1 ) : c = ( i * ( i + 1 ) ) \/\/ 2 if k <= c : pos1 = i pos2 = c - k break NEW_LINE","from sys import stdininput = stdin . buffer . readlineimport math   t = int ( input ( ) ) for i in range ( t ) : n , k = map ( int , input ( ) . split ( ) )   x = math . floor ( ( math . sqrt ( 1 + 4 * 2 * k ) - 1 ) \/ 2 ) sx = ( x * ( x + 1 ) ) \/\/ 2 m = k - sx if m == 0 : s = \" bb \" + \" a \" * ( x - 1 ) s = ( n - len ( s ) ) * \" a \" + s print ( s ) continue   s = \" a \" * ( n - ( x + 2 ) ) + \" b \" ss = \" b \" + ( m - 1 ) * \" a \" l = len ( s ) + len ( ss ) print ( s + ( n - l ) * \" a \" + ss )     NEW_LINE"],"bleu":0.40112511075062623,"rouge_l":0.5575345676119053}
{"id":303,"predictions":["n , t = map ( int , input ( ) . split ( ) ) arr = [ ] for _ in range ( n ) : a , b = map ( int , input ( ) . split ( ) ) arr . append ( [ a , b ] ) arr . sort ( ) res = 1 for i in range ( n ) : if arr [ i ] [ 0 ] >= t and arr [ i ] [ 1 ] < arr [ i ] [ 1 ] : res = 1 breakprint ( res ) NEW_LINE"],"references":["n , t = [ int ( item ) for item in input ( ) . split ( ' ▁ ' ) ] cont , ans = [ ] , 2 for i in range ( n ) : hcenter , hlen = [ float ( item ) for item in input ( ) . split ( ' ▁ ' ) ] NEW_LINE","n , t = [ int ( item ) for item in input ( ) . split ( ' ▁ ' ) ] cont , ans = list ( ) , 2 for i in range ( n ) : hCenter , hLen = [ float ( item ) for item in input ( ) . split ( ' ▁ ' ) ] NEW_LINE","n , t = [ int ( item ) for item in input ( ) . split ( ' ▁ ' ) ] cont , ans = [ ] , 2 for i in range ( n ) : hcenter , hlen = [ int ( item ) for item in input ( ) . split ( ' ▁ ' ) ] cont . append ( [ hcenter - hlen \/ 2 , hcenter + hlen \/ 2 ] )   NEW_LINE"],"bleu":0.2462612134829418,"rouge_l":0.460965716508307}
{"id":304,"predictions":["def sum_of_digits ( n ) : sum = 1 for digit in str ( n ) : sum += int ( digit ) return sum   n = int ( input ( ) ) fs = 0 ans = 0 if n > 9 : fs = sum_of_digits ( n ) ans += 1 while fs > 9 : fs = sum_of_digits ( fs ) ans += 1 print ( ans )     NEW_LINE"],"references":["n = int ( input ( ) ) x = 1 s = 1 while s <= n : x += 1 s += ( x * ( x + 1 ) ) \/\/ 2 print ( x - 1 ) NEW_LINE","n = int ( input ( ) ) k = 0 i = 0 z = 0 count = 0 while k < n : k = k + ( i + 1 ) z = z + k if z <= n : count += 1 i += 1 print ( count ) NEW_LINE","n = int ( input ( ) ) sum = 0 i = 0 for i in range ( 1 , n + 1 , 1 ) : for j in range ( 1 , i + 1 , 1 ) : sum += j if ( sum > n ) : breakif ( n < 4 ) : print ( 1 ) NEW_LINE"],"bleu":0.2550809299984296,"rouge_l":0.4050464807436919}
{"id":305,"predictions":["import sysfrom functools import lru_cache , cmp_to_keyfrom heapq import merge , heapify , heappop , heappushfrom math import * from collections import defaultdict as dd , deque , Counter as Cfrom itertools import combinations as comb , permutations as permfrom bisect import bisect_left as bl , bisect_right as br , bisect , insortfrom time import perf_counterfrom fractions import Fractionimport copyfrom copy import deepcopyimport timestarttime = time . time ( ) mod = int ( pow ( 10 , 9 ) + 7 ) mod2 = 998244353   def data ( ) : return sys . stdin . readline ( ) . strip ( ) def out ( * var , end = \" \\n \" ) : sys . stdout . write ( ' ▁ ' . join ( map ( str , var ) ) + end ) def L ( ) : return list ( sp ( ) ) def sl ( ) : return list ( ssp ( ) ) def sp ( ) : return map ( int , data ( ) . split ( ) ) def ssp ( ) : return map ( str , data ( ) . split ( ) ) def l1d ( n , val = 0 ) : return [ val for i in range ( n ) ] def l2d ( n , m , val = 0 ) : return [ l1d ( n , val ) for j in range ( m ) ] try : NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) adj = [ [ ] for i in range ( n ) ] used = [ 0 for i in range ( n ) ] mark = [ 0 for i in range ( n ) ] S = [ i for i in range ( n ) ]   for i in range ( m ) : u , v = map ( int , input ( ) . split ( ) ) u , v = u - 1 , v - 1 adj [ u ] . append ( v ) adj [ v ] . append ( u ) def dfs ( v ) : global S used [ v ] = 1 S2 , S3 = [ ] , [ ] for to in adj [ v ] : mark [ to ] = 1 for to in S : if mark [ to ] == 0 : S3 . append ( to ) else : S2 . append ( to ) for to in adj [ v ] : mark [ to ] = 0 S = S2 . copy ( ) for to in S3 : dfs ( to ) ans = - 1 for i in range ( n ) : if not used [ i ] : S . remove ( i ) ans += 1 dfs ( i )   print ( ans ) NEW_LINE","import sysfrom sys import stdin , stdout   n , m = stdin . readline ( ) . split ( ) n = int ( n ) m = int ( m ) e = set ( tuple ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( m ) ) a = set ( range ( 1 , n + 1 ) ) q = [ ] r = 0 while a : if q : u = q . pop ( ) else : u = a . pop ( ) r += 1 c = { v for v in a if ( u , v ) not in e and ( v , u ) not in e } a -= c q += cstdout . write ( str ( r - 1 ) + ' \\n ' ) NEW_LINE","def find ( u ) :   if parent [ u ] == u : return u   parent [ u ] = find ( parent [ u ] ) return parent [ u ]           def union ( a , b ) : if find ( a ) != find ( b ) : u = parent [ a ] v = parent [ b ]   if size [ u ] > size [ v ] : parent [ v ] = u size [ u ] += size [ v ] del size [ v ]   else : parent [ u ] = v size [ v ] += size [ u ] del size [ u ]       return           n , m = map ( int , input ( ) . split ( ) ) adj = [ [ ] for i in range ( n + 1 ) ] for j in range ( m ) : u , v = map ( int , input ( ) . split ( ) ) if u < v : adj [ v ] . append ( u )   else : adj [ u ] . append ( v )   size = dict ( ) parent = [ i for i in range ( n + 1 ) ] for v in range ( 1 , n + 1 ) : req = [ ] d1 = dict ( ) for j in adj [ v ] : f = find ( j ) req . append ( f ) if f in d1 : d1 [ f ] += 1 else : d1 [ f ] = 1   res = [ j for j in size ]   size [ v ] = 1     for i in res : if i not in d1 : union ( i , v )   elif d1 [ i ] < size [ i ] : union ( i , v )   print ( len ( size ) - 1 )           NEW_LINE"],"bleu":0.19662247132314722,"rouge_l":0.3234232847091587}
{"id":306,"predictions":["n = input ( ) NEW_LINE if n == '0' : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT"],"references":["def pod ( n ) : ans = 1 while n > 0 : ans *= ( n % 10 ) n = n \/\/ 10 return ansn = input ( ) ans = ( len ( n ) - 1 ) * 9 ans = max ( ans , pod ( int ( n ) ) ) sz = len ( n ) for i in range ( 1 , sz ) : ind = sz - i num = n [ : ind ] + '9' * ( sz - ind ) if int ( num ) > int ( n ) : if num [ ind - 1 ] == '0' : num = num [ : ind - 1 ] + '9' + num [ ind : ] else : num = num [ : ind - 1 ] + str ( int ( num [ ind - 1 ] ) - 1 ) + num [ ind : ] if int ( num ) <= int ( n ) : ans = max ( ans , pod ( int ( num ) ) ) print ( ans ) NEW_LINE","def f ( n ) : l = [ ] while n > 0 : l . append ( n % 10 ) n = n \/\/ 10 l . reverse ( ) ll = len ( l ) p1 = 1 pl = [ ] for i in range ( ll ) : p2 = l [ i ] if i == ll - 1 else max ( l [ i ] - 1 , 1 ) * 9 ** ( ll - i - 1 ) pl . append ( p1 * p2 ) p1 *= l [ i ] return max ( pl ) n = int ( input ( ) ) print ( f ( n ) ) NEW_LINE","def ans ( n ) : if ( n == 0 ) : return 1 if ( n <= 9 ) : return n return max ( n % 10 * ans ( n \/\/ 10 ) , 9 * ans ( n \/\/ 10 - 1 ) ) n = int ( input ( ) ) print ( ans ( n ) ) NEW_LINE"],"bleu":0.07602268287479251,"rouge_l":0.2940883872202028}
{"id":307,"predictions":["import sysdef input ( ) : return sys . stdin . readline ( ) . strip ( ) def iinput ( ) : return int ( input ( ) ) def minput ( ) : return map ( int , input ( ) . split ( ) ) def listinput ( ) : return list ( map ( int , input ( ) . split ( ) ) ) n , k = minput ( ) answer = [ ] for i in range ( n ) : answer . append ( answer [ i ] ) print ( * answer ) NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) a = '9' * 200 + '0' * 199 + '1' b = '9' * 200 print ( a ) print ( b ) NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) print ( n * \"8\" ) print ( ( n - 1 ) * \"1\" + \"2\" ) NEW_LINE","n , m = [ int ( x ) for x in input ( ) . split ( ' ▁ ' ) ] print ( ( n - 1 ) * '4' + '5' ) print ( n * '5' ) NEW_LINE"],"bleu":0.15908385549002094,"rouge_l":0.3340286831812256}
{"id":308,"predictions":["import math , sys , bisect , heapq , osfrom collections import defaultdict , Counter , dequefrom itertools import groupby , accumulatefrom functools import lru_cache NEW_LINE"],"references":["from sys import stdinfrom math import gcd     def main ( ) : input ( ) l = stdin . read ( ) . splitlines ( ) d = [ 3. , 1. , 2. , 2. , 2. , 1. ] * 16667 for i in range ( 4 , 100001 ) : for j in range ( i , 100001 , i ) : d [ j ] += 1. for i , s in enumerate ( l ) : a , b , c = map ( int , s . split ( ) ) k = gcd ( b , c ) ab = d [ gcd ( a , b ) ] ac = d [ gcd ( a , c ) ] bc = d [ k ] abc = d [ gcd ( a , k ) ] asz = d [ a ] - ab - ac + abc bsz = d [ b ] - bc - ab + abc csz = d [ c ] - ac - bc + abc absz = ab - abc bcsz = bc - abc acsz = ac - abc l [ i ] = ' % d ' % ( asz * bsz * csz + ( absz * ( asz + bsz ) * csz ) + ( bcsz * ( bsz + csz ) * asz ) + ( acsz * ( asz + csz ) * bsz ) + ( abc * ( asz * bsz + asz * csz + bsz * csz ) ) + ( abc * ( absz + bcsz + acsz ) * ( asz + bsz + csz ) ) + ( ( asz + bsz + csz + absz + bcsz + acsz ) * ( abc * ( abc + 1 ) * .5 ) ) + ( absz * bcsz * acsz ) + ( ( absz * ( absz + 1. ) * d [ c ] ) + ( bcsz * ( bcsz + 1. ) * d [ a ] ) + ( acsz * ( acsz + 1. ) * d [ b ] ) ) * .5 + ( ( asz + bsz + csz + abc ) * ( absz * acsz + absz * bcsz + bcsz * acsz ) ) + ( abc + ( abc * ( abc - 1. ) ) + ( abc * ( abc - 1. ) * ( abc - 2. ) \/ 6. ) ) ) print ( ' \\n ' . join ( map ( str , l ) ) )     if __name__ == ' _ _ main _ _ ' : main ( )         NEW_LINE","from sys import stdinfrom math import gcd     def main ( ) : input ( ) l = stdin . read ( ) . splitlines ( ) d = [ 3 , 1 , 2 , 2 , 2 , 1 ] * 16667 for i in range ( 4 , 100001 ) : for j in range ( i , 100001 , i ) : d [ j ] += 1 for i , s in enumerate ( l ) : a , b , c = map ( int , s . split ( ) ) k = gcd ( b , c ) ab = d [ gcd ( a , b ) ] ac = d [ gcd ( a , c ) ] bc = d [ k ] abc = d [ gcd ( a , k ) ] asz = d [ a ] - ab - ac + abc bsz = d [ b ] - bc - ab + abc csz = d [ c ] - ac - bc + abc absz = ab - abc bcsz = bc - abc acsz = ac - abc abcsz = abc l [ i ] = ( asz * bsz * csz + ( absz * ( asz + bsz ) * csz ) + ( bcsz * ( bsz + csz ) * asz ) + ( acsz * ( asz + csz ) * bsz ) + ( abcsz * ( asz * bsz + asz * csz + bsz * csz ) ) + ( abcsz * ( absz + bcsz + acsz ) * ( asz + bsz + csz ) ) + ( ( asz + bsz + csz + absz + bcsz + acsz ) * ( abcsz * ( abcsz + 1 ) \/\/ 2 ) ) + ( absz * bcsz * acsz ) + ( ( absz * ( absz + 1 ) * d [ c ] ) + ( bcsz * ( bcsz + 1 ) * d [ a ] ) + ( acsz * ( acsz + 1 ) * d [ b ] ) ) \/\/ 2 + ( ( asz + bsz + csz + abcsz ) * ( absz * acsz + absz * bcsz + bcsz * acsz ) ) + ( abcsz + ( abcsz * ( abcsz - 1 ) ) + ( abcsz * ( abcsz - 1 ) * ( abcsz - 2 ) \/\/ 6 ) ) ) print ( ' \\n ' . join ( map ( str , l ) ) )     if __name__ == ' _ _ main _ _ ' : main ( ) NEW_LINE","from sys import stdinfrom math import gcd     def main ( ) : input ( ) l = stdin . read ( ) . splitlines ( ) d = [ 3. , 1. , 2. , 2. , 2. , 1. ] * 16667 for i in range ( 4 , 100001 ) : for j in range ( i , 100001 , i ) : d [ j ] += 1. for i , s in enumerate ( l ) : a , b , c = map ( int , s . split ( ) ) k = gcd ( b , c ) ab = d [ gcd ( a , b ) ] ac = d [ gcd ( a , c ) ] bc = d [ k ] abc = d [ gcd ( a , k ) ] asz = d [ a ] - ab - ac + abc bsz = d [ b ] - bc - ab + abc csz = d [ c ] - ac - bc + abc absz = ab - abc bcsz = bc - abc acsz = ac - abc l [ i ] = ' % d ' % ( asz * bsz * csz + ( absz * ( asz + bsz ) * csz ) + ( bcsz * ( bsz + csz ) * asz ) + ( acsz * ( asz + csz ) * bsz ) + ( abc * ( asz * bsz + asz * csz + bsz * csz ) ) + ( abc * ( absz + bcsz + acsz ) * ( asz + bsz + csz ) ) + ( ( asz + bsz + csz + absz + bcsz + acsz ) * ( abc * ( abc + 1 ) * .5 ) ) + ( absz * bcsz * acsz ) + ( ( absz * ( absz + 1. ) * d [ c ] ) + ( bcsz * ( bcsz + 1. ) * d [ a ] ) + ( acsz * ( acsz + 1. ) * d [ b ] ) ) * .5 + ( ( asz + bsz + csz + abc ) * ( absz * acsz + absz * bcsz + bcsz * acsz ) ) + ( abc + ( abc * ( abc - 1. ) ) + ( abc * ( abc - 1. ) * ( abc - 2. ) \/ 6. ) ) ) print ( ' \\n ' . join ( map ( str , l ) ) )     if __name__ == ' _ _ main _ _ ' : main ( ) NEW_LINE"],"bleu":4.533085330711247e-9,"rouge_l":0.03529684064344404}
{"id":309,"predictions":["from bisect import bisect_left as blt = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) q , l = [ ] , [ 0 ] * tfor i in range ( t ) : if a [ i ] == 0 : q . append ( i ) r = len ( q ) for i in range ( t ) : if a [ i ] != 0 : p = bl ( q , i ) if p == 0 : l [ i ] = q [ 0 ] - i elif p == r : l [ i ] = i - q [ - 1 ] + 1 print ( * l ) NEW_LINE"],"references":["m = [ ] for _ in range ( int ( input ( ) ) ) : l = list ( map ( int , input ( ) . split ( ) ) ) x = sum ( l ) m . append ( x ) j = sorted ( m , reverse = True ) NEW_LINE","n = int ( input ( ) ) li = [ ] for i in range ( n ) : A , B , C , D = map ( int , input ( ) . split ( ) ) sum_1 = A + B + C + D li . append ( sum_1 )   a = li [ 0 ] li . sort ( reverse = True ) print ( li . index ( a ) + 1 ) NEW_LINE","n = int ( input ( ) ) l = [ ] for i in range ( 0 , n ) : E , G , M , H = map ( int , input ( ) . strip ( ) . split ( ) ) l . append ( E + G + M + H )   jh = l [ 0 ] l . sort ( reverse = True ) print ( l . index ( jh ) + 1 ) NEW_LINE"],"bleu":0.2656046125733973,"rouge_l":0.42023205221174764}
{"id":310,"predictions":["import sysfrom functools import lru_cache , cmp_to_keyfrom heapq import merge , heapify , heappop , heappushfrom math import * from collections import defaultdict as dd , deque , Counter as Cfrom itertools import combinations as comb , permutations as permfrom bisect import bisect_left as bl , bisect_right as br , bisect , insortfrom time import perf_counterfrom fractions import Fractionimport copyfrom copy import deepcopyimport timestarttime = time . time ( ) mod = int ( pow ( 10 , 9 ) + 7 ) mod2 = 998244353   def data ( ) : return sys . stdin . readline ( ) . strip ( ) def out ( * var , end = \" \\n \" ) : sys . stdout . write ( ' ▁ ' . join ( map ( str , var ) ) + end ) def L ( ) : return list ( sp ( ) ) def sl ( ) : return list ( ssp ( ) ) def sp ( ) : return map ( int , data ( ) . split ( ) ) def ssp ( ) : return map ( str , data ( ) . split ( ) ) def l1d ( n , val = 0 ) : return [ val for i in range ( m ) ] def l2d ( n , m , val = 0 ) : return [ l1d ( n , val ) for j in range ( m ) ] try : NEW_LINE"],"references":["from sys import stdin , stdoutfrom itertools import accumulatenmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE","n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) d = { } for i in range ( n ) : d [ a [ i ] ] = 1 a . sort ( reverse = True ) ans = 0 for i in range ( n ) : if d [ a [ i ] ] > 0 : if a [ i ] % k == 0 : x = a [ i ] \/\/ k if x in d : d [ x ] -= 1 ans += 1 print ( ans ) NEW_LINE"],"bleu":0.12248761766319266,"rouge_l":0.3372419130165609}
{"id":311,"predictions":["import math , sys , bisect , heapq , osfrom collections import defaultdict , Counter , dequefrom itertools import groupby , accumulatefrom functools import lru_cache NEW_LINE"],"references":["import sysimport itertoolsimport collections   n = int ( input ( ) ) A = [ int ( x ) for x in input ( ) . split ( ) ] perms = [ ]   def bits ( lst ) : a = [ ] for val in lst : s = [ ] for shift in range ( 29 , - 1 , - 1 ) : s += [ str ( val >> shift & 1 ) ] a += [ ' ' . join ( s [ : : - 1 ] ) ] return a   def calcCost ( perm ) : f = lambda a , b : ( ( a | b ) - b ) a = f ( perm [ 0 ] , perm [ 1 ] ) for i in range ( 2 , len ( perm ) ) : a = f ( a , perm [ i ] ) return a   def bruteForce ( ) : global perms for perm in list ( itertools . permutations ( A ) ) : perms += [ ( perm , calcCost ( perm ) ) ] print ( * perms , sep = \" \\n \" )   NEW_LINE","n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) fl = Falsemax_ans = 0 for i in range ( n ) : ans = arr [ i ] for j in range ( n ) : if i != j : ans = ans & ( ~ arr [ j ] ) if ans <= max_ans : break NEW_LINE","n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) s = set ( ) for i in range ( 32 , - 1 , - 1 ) : cnt = 0 bs = [ ] for c in arr : if ( c >> i ) & 1 : cnt += 1 bs . append ( c ) if cnt == 1 and bs [ 0 ] not in s : print ( bs [ 0 ] , end = \" ▁ \" ) s . add ( bs [ 0 ] ) for c in arr : if c not in s : print ( c , end = \" ▁ \" ) NEW_LINE"],"bleu":0.011096733569608675,"rouge_l":0.07462686567164178}
{"id":312,"predictions":["from sys import stdin , stdoutstdin . readlinedef mp ( ) : return list ( map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) ) def it ( ) : return int ( stdin . readline ( ) . strip ( ) ) from math import ceilfrom collections import defaultdict as ddfrom collections import Counter as Cn = it ( ) l , r = mp ( ) NEW_LINE"],"references":["t , sx , sy , ex , ey = map ( int , input ( ) . split ( ) ) winds = list ( input ( ) ) def dist ( x , y ) : return abs ( x - ex ) + abs ( y - ey ) for zzz in range ( t ) : new_x , new_y = sx , sy if ( winds [ zzz ] == ' N ' ) : new_y += 1 if ( winds [ zzz ] == ' S ' ) : new_y -= 1 if ( winds [ zzz ] == ' E ' ) : new_x += 1 if ( winds [ zzz ] == ' W ' ) : new_x -= 1 if ( dist ( new_x , new_y ) < dist ( sx , sy ) ) : sx = new_x sy = new_y if ( sx == ex and sy == ey ) : if ( zzz + 1 <= t ) : print ( zzz + 1 ) breakelse : print ( - 1 ) NEW_LINE","t , s1 , s2 , e1 , e2 = [ int ( i ) for i in input ( ) . split ( ) ] s = input ( ) total = abs ( s1 - e1 ) + abs ( s2 - e2 ) time = 0 for i in s : if total == 0 : break if i == ' E ' : if ( ( e1 - s1 ) > 0 ) : total -= 1 s1 += 1 time += 1 if i == ' W ' : if ( ( e1 - s1 ) < 0 ) : total -= 1 s1 -= 1 time += 1 if i == ' N ' : if ( ( e2 - s2 ) > 0 ) : total -= 1 s2 += 1 time += 1 if i == ' S ' : if ( ( e2 - s2 ) < 0 ) : total -= 1 s2 -= 1 time += 1 if s1 == e1 and s2 == e2 : print ( time ) else : print ( - 1 ) NEW_LINE","t , s1 , s2 , e1 , e2 = map ( int , input ( ) . split ( ) ) drc = input ( ) x = e1 - s1y = e2 - s2time = 0 for i in drc : if x == 0 and y == 0 : break elif x != 0 and x > 0 and i == ' E ' : x -= 1 elif x != 0 and x < 0 and i == ' W ' : x += 1 elif y != 0 and y > 0 and i == ' N ' : y -= 1 elif y != 0 and y < 0 and i == ' S ' : y += 1 time += 1 if x == 0 and y == 0 : print ( time ) else : print ( - 1 )   NEW_LINE"],"bleu":0.07871955705019515,"rouge_l":0.2205505015162118}
{"id":313,"predictions":["n = int ( input ( ) ) r = 0 for i in range ( n ) : l , r = map ( int , input ( ) . split ( ) ) l += r r += r   print ( r - l + 1 ) NEW_LINE"],"references":["days = int ( input ( ) ) dailyReq = [ ] dailyPrice = [ ] totalCost = 0 for day in range ( days ) : a , p = input ( ) . split ( ) dailyReq . append ( int ( a ) ) dailyPrice . append ( int ( p ) )   minPrice = dailyPrice [ 0 ] for day in range ( days ) : if ( dailyPrice [ day ] < minPrice ) : minPrice = dailyPrice [ day ] totalCost += dailyReq [ day ] * minPrice   print ( totalCost )   NEW_LINE","n = int ( input ( ) ) c = 0 for i in range ( n ) : a , b = map ( int , input ( ) . split ( ) ) if i == 0 : m = b c = a * b else : m = min ( m , b ) c = c + m * aprint ( c ) NEW_LINE","t = int ( input ( ) ) meat = [ ] money = [ ] while t > 0 : num = [ int ( i ) for i in input ( ) . split ( ) ] a = num [ 0 ] b = num [ 1 ] meat . append ( a ) money . append ( b ) t = t - 1 meat . append ( 0 ) money . append ( 0 ) tot = 0 i = 0 while i < len ( money ) - 1 : if money [ i ] < money [ i + 1 ] : money [ i + 1 ] = money [ i ] tot = tot + ( meat [ i ] * money [ i ] ) i = i + 1 else : tot = tot + ( meat [ i ] * money [ i ] ) i = i + 1 print ( tot ) NEW_LINE"],"bleu":0.41127515733228287,"rouge_l":0.5841979249800479}
{"id":314,"predictions":["def STR ( ) : return list ( input ( ) ) def INT ( ) : return int ( input ( ) ) def MAP ( ) : return map ( int , input ( ) . split ( ) ) def MAP2 ( ) : return map ( float , input ( ) . split ( ) ) def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) def STRING ( ) : return input ( ) import stringimport sysfrom heapq import heappop , heappushfrom bisect import * from collections import deque , Counter , defaultdictfrom math import * from itertools import permutations , accumulatedx = [ - 1 , 1 , 0 , 0 ] dy = [ 0 , 0 , 1 , - 1 ] NEW_LINE"],"references":["import sysimport mathfrom collections import defaultdict , dequeimport heapqs = sys . stdin . readline ( ) [ : - 1 ] ans = 0 n = len ( s ) mink = nfor i in range ( n - 1 , - 1 , - 1 ) : k = 1 z = True while i + 2 * k < n and z : if s [ i ] == s [ i + k ] == s [ i + 2 * k ] : z = False continue k += 1 if not z : mink = min ( mink , i + 2 * k ) NEW_LINE"],"bleu":0.05585001180022392,"rouge_l":0.1528620416776576}
{"id":315,"predictions":["for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) a = [ int ( x ) for x in input ( ) . split ( ) ] maxi = 0 for i in range ( 1 , n ) : if a [ i - 1 ] >= a [ i ] : maxi = max ( maxi , a [ i - 1 ] - a [ i ] ) a [ i ] = a [ i - 1 ] temp = bin ( maxi ) if temp [ 2 ] == '0' : print ( len ( temp ) - 2 ) else : print ( maxi ) NEW_LINE"],"references":["c = 0 def backtracking ( actuales , restantes , l , r , x ) : global c if sum ( actuales ) <= r and sum ( actuales ) >= l : if max ( actuales ) - min ( actuales ) >= x : c += 1 if restantes : for i in range ( len ( restantes ) ) : backtracking ( actuales + [ restantes [ i ] ] , restantes [ i + 1 : ] , l , r , x ) return 0 def main ( ) : n , l , r , x = input ( ) . split ( \" ▁ \" ) n , l , r , x = int ( n ) , int ( l ) , int ( r ) , int ( x ) difficulties = input ( ) . split ( \" ▁ \" ) for i in range ( len ( difficulties ) ) : difficulties [ i ] = int ( difficulties [ i ] ) difficulties . sort ( ) backtracking ( [ ] , difficulties , l , r , x ) global c return c if __name__ == \" _ _ main _ _ \" : print ( main ( ) ) NEW_LINE","n , l , r , x = map ( int , input ( ) . split ( ) ) c = [ int ( i ) for i in input ( ) . split ( ) ] ans = 0 for bit in range ( 2 , 1 << n ) : probs = [ ] t = 0 for i in range ( n ) : if bit & ( 1 << i ) : probs . append ( c [ i ] ) t += c [ i ] a = min ( probs ) b = max ( probs )   if t >= l and t <= r and abs ( a - b ) >= x : ans += 1 print ( ans ) NEW_LINE","_n , l , r , x = map ( int , input ( \" \" ) . split ( ) ) c = list ( map ( int , input ( ) . split ( ) ) ) count = 0 def backtrack ( s , l , r , x , c , i , level , min , max ) : NEW_LINE"],"bleu":0.34546566312166227,"rouge_l":0.4604657113613101}
{"id":316,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["n = int ( input ( ) ) NEW_LINE start , end = 0 , 0 NEW_LINE flag = 0 l NEW_LINE s = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( 1 , ( n + 1 ) ) : if NEW_LINE ls [ i - 1 ] != i : start = i NEW_LINE breakfor NEW_LINE j in range ( n , i - 1 , - 1 ) : NEW_LINE if ls [ j - 1 ] != j : end = j NEW_LINE breakif NEW_LINE start == 0 and end == 0 : flag = 1 NEW_LINE print ( \"0 ▁ 0\" ) else : for i in range ( start - 1 , end - 1 ) : if NEW_LINE ls [ i ] < ls [ i + 1 ] : print ( \"0 ▁ 0\" ) NEW_LINE flag = 1 NEW_LINE breakif NEW_LINE flag == 0 : print ( str ( start ) + \" ▁ \" + str ( end ) ) NEW_LINE","def res ( ) : n = int ( input ( ) ) NEW_LINE v = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE ans = sorted ( v ) NEW_LINE if ( v == ans ) : return \"0 ▁ 0\"   try : ini = 0 NEW_LINE temp = [ ] NEW_LINE while v [ ini ] < v [ ini + 1 ] : temp . append ( v [ ini ] ) NEW_LINE ini += 1 NEW_LINE fim = ini NEW_LINE v2 = [ ] NEW_LINE while fim < n - 1 and v [ fim ] > v [ fim + 1 ] : v2 . append ( v [ fim ] ) NEW_LINE fim += 1 NEW_LINE v2 . append ( v [ fim ] ) NEW_LINE ini += 1 NEW_LINE fim += 1 NEW_LINE temp += v2 [ : : - 1 ] + v [ fim : ] NEW_LINE if temp == ans : NEW_LINE INDENT return str ( ini ) + ' ▁ ' + str ( fim ) else : NEW_LINE return \"0 ▁ 0\" except : return \"0 ▁ 0\" NEW_LINE DEDENT def main ( ) : print ( res ( ) ) NEW_LINE   main ( ) NEW_LINE","n = int ( input ( ) ) NEW_LINE s = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : s . append ( i ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l = - 1 NEW_LINE r = n - 1 NEW_LINE for i in range ( n ) : if NEW_LINE i + 1 != a [ i ] and l == - 1 : l = i NEW_LINE breakfor NEW_LINE i in range ( n - 1 , l , - 1 ) : NEW_LINE if i + 1 != a [ i ] and l != - 1 : r = i NEW_LINE breakb = a [ : : - 1 ] NEW_LINE if s == b and s != a : NEW_LINE INDENT print ( 1 , n ) elif s == a [ : l ] + a [ r : l - 1 : - 1 ] + a [ r + 1 : ] and s != a : NEW_LINE print ( l + 1 , r + 1 ) else : NEW_LINE print ( 0 , 0 ) NEW_LINE DEDENT"],"bleu":0.02262442568907892,"rouge_l":0.22796881376318223}
{"id":317,"predictions":["n , m , a , b = map ( int , input ( ) . split ( ) ) l = [ ] for i in range ( n ) : l . append ( list ( map ( int , input ( ) . split ( ) ) ) ) for i in range ( m ) : for j in range ( m ) : if l [ i ] [ j ] == 0 : l [ i ] [ j ] += 1 else : l [ i ] [ j ] = 0 print ( len ( l ) ) NEW_LINE"],"references":["n , m , x , y = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) outputs , l = [ ] , 0 for i in range ( n ) : minm = max ( 1 , a [ i ] - x ) while l < m and b [ l ] < minm : l += 1 if l < m and b [ l ] <= a [ i ] + y : outputs . append ( f ' { i + 1 } ▁ { l + 1 } ' ) l += 1 print ( len ( outputs ) ) for output in outputs : print ( output )   NEW_LINE","n , m , x , y = map ( int , input ( ) . split ( ) ) A = list ( map ( int , input ( ) . split ( ) ) ) B = list ( map ( int , input ( ) . split ( ) ) ) i = 0j = 0 count = 0 Ac = [ ] Bc = [ ] while i < n and j < m : if A [ i ] - x <= B [ j ] <= A [ i ] + y : count += 1 Ac . append ( i + 1 ) Bc . append ( j + 1 ) i += 1 j += 1 elif A [ i ] - x > B [ j ] : j += 1 elif A [ i ] + y < B [ j ] : i += 1 print ( count ) for x in range ( count ) : print ( Ac [ x ] , Bc [ x ] ) NEW_LINE","class bulletproof : def __init__ ( self , x , y ) : self . soldier = x self . vest = ys = list ( map ( int , input ( ) . split ( ) ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = [ ] x = s [ 2 ] y = s [ 3 ] j = 0 k = 0 i = 0 for i in range ( len ( a ) ) : while j <= len ( b ) - 1 and b [ j ] < a [ i ] - x : j += 1 if j <= len ( b ) - 1 and a [ i ] - x <= b [ j ] <= a [ i ] + y : p = bulletproof ( i + 1 , j + 1 ) c . append ( p ) k += 1 j += 1 if j == len ( b ) : breakprint ( k ) for i in range ( len ( c ) ) : print ( c [ i ] . soldier , c [ i ] . vest ) NEW_LINE"],"bleu":0.36521225377187255,"rouge_l":0.5020664239020752}
{"id":318,"predictions":["num = input ( )   arr = input ( ) . split ( )   mx = 0 ct = 0 for word in arr : for char in word : if char . isupper ( ) : ct += 1 mx = max ( mx , ct ) ct = 0   print ( mx )   NEW_LINE"],"references":["import sys   window = set ( )   n , k , q = [ int ( x ) for x in input ( ) . split ( ) ] arr = [ int ( x ) for x in input ( ) . split ( ) ]   for i in range ( q ) : a , b = [ int ( x ) for x in input ( ) . split ( ) ] if ( a == 1 ) : if ( len ( window ) < k ) : window . add ( arr [ b - 1 ] ) else : window . add ( arr [ b - 1 ] ) m = min ( window ) window . remove ( m ) else : print ( \" YES \" if arr [ b - 1 ] in window else \" NO \" ) NEW_LINE","import osimport sysimport mathimport heapqfrom decimal import * from io import BytesIO , IOBasefrom collections import defaultdict , deque   def main ( ) : n , k , q = rm ( ) a = rl ( ) b = [ ] for i in range ( q ) : c , d = rm ( ) if c == 1 : d -= 1 b . append ( [ a [ d ] , d ] ) b . sort ( reverse = True ) b = b [ : k ] elif c == 2 : d -= 1 ans = False for i in b : if i [ 1 ] == d : ans = True break if ans : print ( \" YES \" ) else : print ( \" NO \" )   NEW_LINE","        n , k , q = map ( int , input ( ) . split ( ) )       t = list ( map ( int , input ( ) . split ( ) ) )   f = [ ]       for i in range ( q ) : a , b = map ( int , input ( ) . split ( ) )       if a == 1 : if len ( f ) < k : f . append ( t [ b - 1 ] ) else : f . append ( t [ b - 1 ] ) f . sort ( ) f = f [ : : - 1 ] [ : k ] else : if t [ b - 1 ] in f : print ( ' YES ' ) else : print ( ' NO ' )   NEW_LINE"],"bleu":0.05030282949872383,"rouge_l":0.28724315068493156}
{"id":319,"predictions":["k , n = map ( int , input ( ) . split ( ) ) if k % 6 == 0 : print ( 0 ) elif k % 6 == 0 : print ( 1 ) else : print ( 2 ) NEW_LINE"],"references":["n = int ( input ( ) ) x = int ( input ( ) ) a = [ 0 ] * 3 a [ x ] = 1 for i in range ( n % 6 + 1 , 7 ) : if i % 2 == 1 : a [ 0 ] , a [ 1 ] = a [ 1 ] , a [ 0 ] else : a [ 1 ] , a [ 2 ] = a [ 2 ] , a [ 1 ] for i in range ( 3 ) : if a [ i ] == 1 : print ( i ) NEW_LINE","n = int ( input ( ) ) x = int ( input ( ) ) a = [ 0 , 1 , 2 ] k = 0 for i in range ( n % 6 ) : if i % 2 == 0 : k = a [ 0 ] a [ 0 ] = a [ 1 ] a [ 1 ] = k else : k = a [ 1 ] a [ 1 ] = a [ 2 ] a [ 2 ] = kprint ( a [ x ] ) NEW_LINE","n = int ( input ( ) ) x = int ( input ( ) ) l = [ 0 , 1 , 2 ] if n % 6 == 1 : l1 = [ 1 , 0 , 2 ] elif n % 6 == 2 : l1 = [ 1 , 2 , 0 ] elif n % 6 == 3 : l1 = [ 2 , 1 , 0 ] elif n % 6 == 4 : l1 = [ 2 , 0 , 1 ] elif n % 6 == 5 : l1 = [ 0 , 2 , 1 ] else : l1 = [ 0 , 1 , 2 ] print ( l [ l1 [ x ] ] ) NEW_LINE"],"bleu":0.05957680206353347,"rouge_l":0.32265918048517434}
{"id":320,"predictions":["import sys   def main ( ) : inp = sys . stdin . read ( ) . strip ( ) . split ( ' \\n ' ) w = list ( map ( int , inp [ 2 ] . split ( ) ) ) c , j = 0 , 0 for i in map ( int , inp [ 1 ] . split ( ) ) : if j == len ( w ) : break if w [ j ] >= i : c += 1 ; j += 1 return c   print ( main ( ) ) NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) current , ans = 0 , 1 for x in a : if current + x <= m : current += x else : current = x ans += 1   print ( ans ) NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) ans = 0 temp = mfor i in range ( len ( arr ) ) : if temp >= arr [ i ] : temp -= arr [ i ] else : ans += 1 temp = m temp -= arr [ i ] print ( ans + 1 ) NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) res = 1 pep = 0 for i in range ( 0 , n ) : if ( pep + a [ i ] <= m ) : pep += a [ i ] else : res += 1 pep = a [ i ] print ( res ) NEW_LINE"],"bleu":0.2906853636951824,"rouge_l":0.4847674260257184}
{"id":321,"predictions":["s = input ( ) j = len ( s ) - 1 i = 0 while i <= j : c = 0 p = s [ i ] if p != s [ j ] : exit ( print ( \" No \" ) ) if i == j : print ( \" Yes \" ) else : print ( \" No \" ) NEW_LINE"],"references":["s = input ( ) s1 = s [ : len ( s ) \/\/ 2 ] if len ( s ) % 2 == 0 : s2 = s [ len ( s ) \/\/ 2 : ] else : s2 = s [ len ( s ) \/\/ 2 + 1 : ]   s2 = s2 [ - 1 : : - 1 ] NEW_LINE","s = input ( ) n = len ( s ) c = 0 for i in range ( n \/\/ 2 ) : if s [ i ] != s [ - i - 1 ] : c += 1 if c > 1 : print ( ' NO ' ) if c == 1 : print ( ' YES ' ) if c == 0 : if n % 2 == 1 : print ( ' YES ' ) else : print ( ' NO ' ) NEW_LINE","str = str ( input ( ) ) def pal ( ) : global str lst = [ ] count1 = 0 count2 = 0 n = len ( str ) for i in str : lst . append ( i ) for i in range ( len ( lst ) ) : if lst [ i ] == lst [ n - 1 - i ] : count1 += 1 else : count2 += 1 if len ( str ) % 2 == 0 : if ( count2 == 2 ) : print ( \" YES \" ) else : print ( \" NO \" ) if len ( str ) % 2 == 1 : if ( count2 == 0 or count2 == 2 ) : print ( \" YES \" ) else : print ( ' NO ' ) pal ( ) NEW_LINE"],"bleu":0.39340359494825766,"rouge_l":0.48402848423194306}
{"id":322,"predictions":["t = int ( input ( ) )   for _ in range ( t ) : s = input ( ) li = s [ : len ( s ) ] for i in range ( 0 , len ( s ) ) : if ( s [ i ] in li ) : print ( - 1 ) else : print ( 0 ) NEW_LINE"],"references":["for _ in range ( int ( input ( ) ) ) : S = input ( ) if S . count ( \"1\" ) == 0 : print ( 0 ) else : A = S [ S . index ( \"1\" ) : S . rfind ( \"1\" ) + 1 ] print ( A . count ( \"0\" ) ) NEW_LINE","for _ in range ( int ( input ( ) ) ) : x = input ( ) c = 0 a = 0 f = 0 for i in range ( len ( x ) ) : if x [ i ] == '1' : f = 1 a = a + c c = 0 if x [ i ] == '0' and f : c = c + 1 print ( a ) NEW_LINE","for _ in range ( int ( input ( ) ) ) : x = input ( ) c = 0 a = 0 f = 0 for i in range ( len ( x ) ) : if x [ i ] == '1' : f = 1 a = a + c c = 0 if x [ i ] == '0' and f : c = c + 1 print ( a ) NEW_LINE"],"bleu":0.3856836736735125,"rouge_l":0.46638183044749265}
{"id":323,"predictions":["n = int ( input ( ) )   arr = [ int ( i ) for i in input ( ) . split ( ) ]   mi = 10 ** 9 for k in range ( n ) : mi = min ( mi , ma ) ma = max ( ma , ma ) print ( mi ) NEW_LINE"],"references":["import itertools as it   def powerset ( iterable ) : \" powerset ( [1,2,3 ] ) ▁ - - > ▁ ( ) ▁ ( 1 , ) ▁ ( 2 , ) ▁ ( 3 , ) ▁ ( 1,2 ) ▁ ( 1,3 ) ▁ ( 2,3 ) ▁ ( 1,2,3 ) \" s = list ( iterable ) return it . chain . from_iterable ( it . combinations ( s , r )   \\ for r in range ( len ( s ) + 1 ) )     n , k , A = map ( int , input ( ) . split ( ) )   best_result = 0   missing = 0   senators = [ ] for _ in range ( n ) : level , loyality = map ( int , input ( ) . split ( ) ) senators += [ [ level , loyality ] ] missing += 10 - loyality \/\/ 10   k = min ( [ k , missing ] ) NEW_LINE"],"bleu":0.04744905982300359,"rouge_l":0.2606182457903996}
{"id":324,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["PI = 3.141592653589793 n , a , b = map ( int , input ( ) . split ( ) ) arr , res = [ ] , [ ] for _ in range ( n ) : u , v = input ( ) . split ( ) arr . append ( ( int ( u ) - a , int ( v ) - b ) ) x0 , y0 = arr [ - 1 ] for x1 , y1 in arr : res . append ( x1 * x1 + y1 * y1 ) dx , dy = x1 - x0 , y1 - y0 if ( x0 * dx + y0 * dy ) * ( x1 * dx + y1 * dy ) < 0 : x0 = x0 * y1 - x1 * y0 res . append ( ( x0 * x0 ) \/ ( dx * dx + dy * dy ) ) x0 , y0 = x1 , y1print ( ( max ( res ) - min ( res ) ) * PI ) NEW_LINE"],"bleu":0.018527499665140244,"rouge_l":0.19644467345098543}
{"id":325,"predictions":["import mathn , k = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) p . sort ( ) p . reverse ( ) ans = 1 for i in l : if i % 2 == 0 : ans = i + 1 print ( ans ) NEW_LINE"],"references":["n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in a : if i > 0 and i >= a [ k - 1 ] : c = c + 1 print ( c ) NEW_LINE","def get_winners ( places , scores ) : while ( \"0\" in scores ) : scores . remove ( \"0\" ) winners = scores [ : int ( places ) ] losers = scores [ int ( places ) : ]   for i in losers : if winners [ - 1 ] == i : winners . append ( i ) return len ( winners )     participants , places = input ( ) . split ( ) scores = input ( ) . split ( )   print ( get_winners ( places , scores ) ) NEW_LINE","n , k = [ int ( i ) for i in input ( ) . split ( ) ] scores = [ int ( i ) for i in input ( ) . split ( ) ] advance = [ score for score in scores if score >= scores [ k - 1 ] and score > 0 ] print ( len ( advance ) ) NEW_LINE"],"bleu":0.5400206125776826,"rouge_l":0.7052890528905289}
{"id":326,"predictions":["import mathn , a , b = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) g = math . ceil ( sum ( l ) \/ a ) bn = min ( b , m ) ans = 0 for i in range ( n ) : if g [ i ] != g [ i ] : ans = max ( ans , i - a ) print ( ans ) NEW_LINE"],"references":["holes , water_have , water_plant = map ( int , input ( ) . split ( ) ) hole_ratio = list ( map ( int , input ( ) . split ( ) ) ) plant_A = hole_ratio [ 0 ] hole_ratio = hole_ratio [ 1 : ] hole_ratio . sort ( ) hole_ratio . reverse ( ) blocked = 0 sum_non_blocked = sum ( hole_ratio ) + plant_A   for each in hole_ratio : if ( water_have * plant_A \/ sum_non_blocked >= water_plant ) : break sum_non_blocked -= each blocked += 1 print ( blocked )   NEW_LINE","n , a , b = map ( int , input ( ) . split ( ) ) if n == 1 : print ( '0' ) exit ( ) l = list ( map ( int , input ( ) . split ( ) ) ) s = sum ( l ) z = sorted ( l [ 1 : ] , reverse = True ) for i in range ( n - 1 ) : if l [ 0 ] * a \/ s >= b : print ( i ) exit ( ) s -= z [ i ] print ( i + 1 ) NEW_LINE","n , A , B = map ( int , input ( ) . rstrip ( ) . split ( ) ) l = list ( map ( int , input ( ) . rstrip ( ) . split ( ) ) ) se = l [ 1 : ] se . sort ( reverse = True ) re = ( A * l [ 0 ] ) \/ Bse . insert ( 0 , l [ 0 ] ) S = sum ( l ) if S <= re : print ( 0 ) exit ( ) NEW_LINE"],"bleu":0.5058197130396245,"rouge_l":0.6028052279247689}
{"id":327,"predictions":["for _ in [ 0 ] * int ( input ( ) ) : n = int ( input ( ) ) ; print ( 2 * sum ( [ 2 ** i for i in range ( 0 , n ) ] ) ) NEW_LINE"],"references":["''' a = [ int ( i ) ▁ for ▁ i ▁ in ▁ input ( ) . split ( ) ] x = a [ 0 ] y = a [ 1 ] z = a [ 2 ] if ▁ y = = x ▁ and ▁ z = = 0 : ▁ ▁ ▁ ▁ print ( '0 ' ) elif ▁ x > y + z : ▁ ▁ ▁ ▁ print ( ' + ' ) elif ▁ y > x + z : ▁ ▁ ▁ ▁ print ( ' - ' ) else : ▁ ▁ ▁ ▁ print ( ' ? ' ) n = int ( input ( ) ) z = [ int ( i ) ▁ for ▁ i ▁ in ▁ input ( ) . split ( ) ] x = [ ] d = 0v = ' ' for ▁ i ▁ in ▁ range ( n ) : ▁ ▁ ▁ ▁ c = 0 ▁ ▁ ▁ ▁ e = 0 ▁ ▁ ▁ ▁ for ▁ f ▁ in ▁ range ( len ( z ) ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ z [ f ] > c ▁ and ▁ f + 1 ▁ not ▁ in ▁ x : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ c = z [ f ] ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ e = f + 1 ▁ ▁ ▁ ▁ d + = ( i * c ) + 1 ▁ ▁ ▁ ▁ x . append ( e ) print ( d ) for ▁ i ▁ in ▁ x : ▁ ▁ ▁ ▁ v + = str ( i ) ▁ ▁ ▁ ▁ v + = ' ▁ ' print ( v )  f = int ( input ( ) ) g = [ int ( i ) ▁ for ▁ i ▁ in ▁ input ( ) . split ( ) ] for ▁ i ▁ in ▁ range ( len ( g ) -1 ) : ▁ ▁ ▁ ▁ for ▁ f ▁ in ▁ range ( len ( g ) -1 - i ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ g [ f ] > g [ f + 1 ] : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ g [ f ] , g [ f + 1 ] = g [ f + 1 ] , g [ f ] if ▁ g [ 0 ] * g [ 1 ] > g [ -2 ] * g [ -3 ] ▁ and ▁ g [ -1 ] > 0 : ▁ ▁ ▁ ▁ print ( g [ -1 ] * g [ 0 ] * g [ 1 ] ) else : ▁ ▁ ▁ ▁ print ( g [ -1 ] * g [ -2 ] * g [ -3 ] ) for ▁ u ▁ in ▁ range ( int ( input ( ) ) ) : ▁ ▁ ▁ ▁ z = int ( input ( ) ) ▁ ▁ ▁ ▁ y = [ int ( f ) ▁ for ▁ f ▁ in ▁ input ( ) . split ( ) ] ▁ ▁ ▁ ▁ y . sort ( ) ▁ ▁ ▁ ▁ d = 0 ▁ ▁ ▁ ▁ for ▁ i ▁ in ▁ y : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ d + = i ▁ ▁ ▁ ▁ if ▁ d < 2048 : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( ' No ' ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ continue ▁ ▁ ▁ ▁ if ▁ 2048 ▁ in ▁ y : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( ' yes ' ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ continue ▁ ▁ ▁ ▁ for ▁ x ▁ in ▁ range ( z + 1 ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ 2048 ▁ in ▁ y : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( ' yes ' ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ break ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ for ▁ i ▁ in ▁ range ( len ( y ) -1 ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ y [ i ] = = y [ i + 1 ] : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ y [ i + 1 ] = y [ i ] *2 ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ y . pop ( i ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ i > len ( y ) -3 : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ break ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ y . sort ( ) ▁ ▁ ▁ ▁ else : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( ' no ' ) n = int ( input ( ) ) x = [ ] for ▁ i ▁ in ▁ range ( 1 , ( ( n * *2 ) \/ \/2 ) + 1 ) : ▁ ▁ ▁ ▁ x . append ( n * *2 + 1 - i ) ▁ ▁ ▁ ▁ x . append ( i ) ▁ ▁ ▁ ▁ if ▁ len ( x ) = = n : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( * x ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ x = [ ] ''' for z in range ( int ( input ( ) ) ) : z = int ( input ( ) ) x = [ int ( i ) for i in input ( ) . split ( ) ] f = 0 o = 0 t = 0 for i in range ( z ) : if x [ i ] % 3 == 0 : f += 1 elif x [ i ] % 3 == 1 : o += 1 else : t += 1 if o < t : print ( f + o + ( t - o ) \/\/ 3 ) else : print ( f + t + ( o - t ) \/\/ 3 ) NEW_LINE","import sysdef get_ints ( ) : return map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) def get_ints_lists ( ) : return list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) def get_string ( ) : return sys . stdin . readline ( ) . strip ( )   n = int ( input ( ) ) for i in range ( n ) : p = int ( input ( ) ) li = get_ints_lists ( ) su = 0 q = 0 r = 0   for i in li : if i % 3 == 0 : su += 1 elif i == 1 or i % 3 == 1 : q += 1 elif i == 2 or i % 3 == 2 : r += 1 if q > 0 or r > 0 :   if r < q : su += r q = q - r su += ( q \/\/ 3 ) elif r > q : su += q r = r - q su += ( r \/\/ 3 ) else : su += r print ( su )   NEW_LINE","import sysdef get_ints ( ) : return map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) def get_ints_lists ( ) : return list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) def get_string ( ) : return sys . stdin . readline ( ) . strip ( )   NEW_LINE"],"bleu":0.26627523750017973,"rouge_l":0.305257819103973}
{"id":328,"predictions":["from collections import defaultdict , deque , Counterfrom sys import stdin , stdoutfrom heapq import heappush , heappopimport mathimport ioimport osimport mathimport bisect   NEW_LINE"],"references":["import heapqn = int ( input ( ) ) p = list ( map ( int , input ( ) . split ( ) ) ) f = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) m = int ( input ( ) ) choice = list ( map ( int , input ( ) . split ( ) ) ) dic = { } dic [ 1 ] = [ ] dic [ 2 ] = [ ] dic [ 3 ] = [ ] pdic = { }   for i in range ( n ) : pdic [ p [ i ] ] = 0 dic [ f [ i ] ] . append ( p [ i ] ) dic [ b [ i ] ] . append ( p [ i ] ) heapq . heapify ( dic [ 1 ] ) heapq . heapify ( dic [ 2 ] ) heapq . heapify ( dic [ 3 ] ) for i in range ( m ) : try : z = heapq . heappop ( dic [ choice [ i ] ] ) while pdic [ z ] != 0 : z = heapq . heappop ( dic [ choice [ i ] ] ) pdic [ z ] = 1 print ( z , end = ' ▁ ' ) except : print ( - 1 , end = ' ▁ ' )                   NEW_LINE","input ( ) p = list ( map ( int , input ( ) . split ( ) ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) input ( ) c = list ( map ( int , input ( ) . split ( ) ) ) d = [ [ [ ] for _ in range ( 3 ) ] for _ in range ( 3 ) ] for pi , ai , bi in zip ( p , a , b ) : d [ ai - 1 ] [ bi - 1 ] . append ( pi ) for row in d : for l in row : l . sort ( reverse = True ) r = [ ] for ci in c : pm = 1000000001 im = - 1 for j , l in enumerate ( d [ ci - 1 ] ) : if len ( l ) > 0 and l [ - 1 ] < pm : pm = l [ - 1 ] im = ci - 1 jm = j for i , ll in enumerate ( d ) : l = ll [ ci - 1 ] if len ( l ) > 0 and l [ - 1 ] < pm : pm = l [ - 1 ] im = i jm = ci - 1 r . append ( d [ im ] [ jm ] . pop ( ) if im >= 0 else - 1 ) print ( * r , sep = ' ▁ ' ) NEW_LINE","n = int ( input ( ) ) p = list ( map ( int , input ( ) . split ( ) ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) m = int ( input ( ) ) c = list ( map ( int , input ( ) . split ( ) ) ) res_cost = ' ' first_color_arr = [ ] second_color_arr = [ ] third_color_arr = [ ] buy_flag = [ ]   for i in range ( n ) : if a [ i ] == 1 or b [ i ] == 1 : first_color_arr . append ( [ p [ i ] , i ] ) if a [ i ] == 2 or b [ i ] == 2 : second_color_arr . append ( [ p [ i ] , i ] ) if a [ i ] == 3 or b [ i ] == 3 : third_color_arr . append ( [ p [ i ] , i ] ) buy_flag . append ( False )   first_color_index = 0 NEW_LINE"],"bleu":3.6458368804221905e-5,"rouge_l":0.04599868036572722}
{"id":329,"predictions":["n = int ( input ( ) ) l = [ ] for i in range ( n ) : s = input ( ) l . append ( s ) l = l [ : : : - 1 ] c = 0 for i in range ( n - 1 ) : if ( l [ i ] == ' . ' ) : c += 1 print ( c ) NEW_LINE"],"references":["n = int ( input ( ) ) arr = [ ] ans = 0 for i in range ( n ) : s = input ( ) if s not in arr : arr . append ( s ) ans += 1 print ( ans ) NEW_LINE","s = [ ] for i in range ( int ( input ( ) ) ) : d = input ( ) if d not in s : s . append ( d ) print ( len ( s ) ) NEW_LINE","seen = set ( ) count = 0 for i in range ( n : = int ( input ( ) ) ) : ip = input ( ) if ip not in seen : count += 1 seen . add ( ip ) print ( count ) NEW_LINE"],"bleu":0.42765828246588716,"rouge_l":0.596702068194522}
{"id":330,"predictions":["n , k = map ( int , input ( ) . split ( ) ) l = [ ] for i in range ( n ) : l . append ( list ( map ( int , input ( ) . split ( ) ) ) ) l . sort ( ) for i in range ( n ) : if l [ i ] [ 0 ] > l [ i ] [ 1 ] : l [ i ] [ 1 ] = l [ i ] [ 0 ] + l [ i ] [ 1 ] else : print ( \" YES \" ) NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) ab = list ( map ( int , input ( ) . split ( ) ) ) ab . sort ( reverse = True ) for i in range ( n ) : if arr [ i ] == 0 : arr [ i ] = ab . pop ( 0 )   if arr == sorted ( arr ) : print ( \" NO \" ) else : print ( \" YES \" ) NEW_LINE","n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) )   if k > 1 : print ( \" Yes \" ) else : for i in range ( n ) : if a [ i ] == 0 : a [ i ] = b [ 0 ] lst = a . copy ( ) lst . sort ( ) if lst == a : print ( \" No \" ) else : print ( \" Yes \" )   NEW_LINE","n , k = map ( int , input ( ) . split ( ) )   list1 = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) [ : n ] list2 = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) [ : k ] list2 . sort ( reverse = True )   for j in range ( k ) : for i in range ( n ) : if list1 [ i ] == 0 : list1 [ i ] = list2 [ j ] break   if list1 == sorted ( list1 ) : print ( \" NO \" ) else : print ( \" YES \" )             NEW_LINE"],"bleu":0.5151906842148789,"rouge_l":0.6197786402816666}
{"id":331,"predictions":["n , m = map ( int , input ( ) . split ( ) ) print ( ( n + ( m - 1 ) \/\/ ( n + 1 ) ) ) NEW_LINE"],"references":["a , b = input ( ) . split ( ) print ( int ( a ) + int ( str ( b ) [ : : - 1 ] ) ) NEW_LINE","n , m = input ( ) . split ( ) r = ' '   for i in m : r = i + r   print ( int ( n ) + int ( r ) ) NEW_LINE","import mathimport sysinput = sys . stdin . readline   def inp ( ) : return ( int ( input ( ) ) ) def inlt ( ) : return ( list ( map ( int , input ( ) . split ( ) ) ) ) def reverse_number ( n ) : r = 0 while n > 0 : r *= 10 r += n % 10 n \/\/= 10 return rm , s = inlt ( ) print ( m + reverse_number ( s ) ) NEW_LINE"],"bleu":0.5585846598591693,"rouge_l":0.5962910128388017}
{"id":332,"predictions":["n = int ( input ( ) ) s = input ( ) o = [ 0 ] * nz = [ 0 ] * nfor i in range ( n ) : if i == 0 : if s [ i ] == '0' : o [ i ] = 1 else : z [ i ] = 1 if s [ i ] == '1' : o [ i ] = o [ i - 1 ] = o [ i ] + 1 z [ i ] = z [ i - 1 ] else : if s [ i ] == '0' : o [ i ] = o [ i - 1 ] + z [ i - 1 ] else : o [ i ] = o [ ] + 1 z [ i ] = o [ i - 1 ] if o [ '0' : print ( o ) else : print ( o ) NEW_LINE"],"references":["n = int ( input ( ) ) t = list ( input ( ) ) A = 0 B = 0 r = 1 for i in t : if int ( i ) != 7 and int ( i ) != 4 : r = 0 if r > 0 : i = ( int ( n \/ 2 ) ) - 1 j = int ( n \/ 2 )   while i >= 0 : A = A + int ( t [ i ] ) B = B + int ( t [ j ] ) i -= 1 j += 1 if r == 1 and A == B : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE","n = int ( input ( ) ) a = input ( ) . strip ( ) if sorted ( set ( a ) ) != [ '4' , '7' ] and sorted ( set ( a ) ) != [ '7' ] and sorted ( set ( a ) ) != [ '4' ] : print ( \" NO \" ) else : x = [ int ( i ) for i in a [ : n \/\/ 2 ] ] y = [ int ( i ) for i in a [ n \/\/ 2 : ] ] if sum ( x ) == sum ( y ) : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE","t = int ( input ( ) ) s = input ( ) if s . count ( '4' ) + s . count ( '7' ) != t : print ( ' NO ' ) else : one = 0 two = 0 n = int ( t \/ 2 ) q = s [ : n ] w = s [ n : ] for i in q : one += int ( i ) for i in w : two += int ( i ) if one == two : print ( ' YES ' ) else : print ( ' NO ' ) NEW_LINE"],"bleu":0.17555387485545523,"rouge_l":0.3805580762250454}
{"id":333,"predictions":["from math import * NEW_LINE def prime ( n ) : NEW_LINE"],"references":["l , s , l = input ( ) , ' ' , list ( map ( int , input ( ) . split ( ) ) ) for i in range ( len ( l ) ) : if l [ i ] != 0 : if ( len ( s ) < 2 or s [ - 1 ] == ' R ' ) and l [ i ] == 1 : s += ' PR ' else : if i != 0 : s += ' PLR ' * l [ i ] else : s += ' PRL ' * l [ i ] s += ' R ' else : s += ' R ' print ( s [ : - 1 ] ) NEW_LINE","n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n + 1 ) : if i == n : break if i == n - 1 : print ( l [ i ] * ' PLR ' , end = ' ' ) else : print ( l [ i ] * ' PRL ' + ' R ' , end = ' ' ) NEW_LINE","def solve ( n , seq ) : totalCoins = sum ( seq ) index = 0 previousIndex = 0 incrementDecrement = 1 direction = \" R \" while totalCoins > 0 : if seq [ index ] > 0 : for _ in range ( abs ( previousIndex - index ) ) : print ( direction , end = \" \" ) print ( \" P \" , end = \" \" ) seq [ index ] -= 1 totalCoins -= 1 previousIndex = index     if ( index == n - 1 and direction == \" R \" ) or ( index == 0 and direction == \" L \" ) and totalCoins > 0 : if previousIndex + incrementDecrement < n and previousIndex + incrementDecrement >= 0   \\ and seq [ previousIndex ] > 0 : index = previousIndex + incrementDecrement previousIndex = index print ( direction , end = \" \" ) else : index = previousIndex index += ( incrementDecrement * - 1 ) incrementDecrement *= - 1 if incrementDecrement == - 1 : direction = \" L \" else : direction = \" R \" continue                                                     index += incrementDecrement n = int ( input ( ) ) seq = list ( map ( int , input ( ) . split ( ) ) ) solve ( n , seq ) NEW_LINE"],"bleu":0.00037332147894491284,"rouge_l":0.09018332347723239}
{"id":334,"predictions":["n = int ( input ( ) ) print ( 0 , 0 , n ) NEW_LINE"],"references":["s = input ( ) print ( s + s [ : : - 1 ] ) NEW_LINE","s = input ( ) print ( s + s [ : : - 1 ] ) NEW_LINE","a = input ( ) print ( a , end = ' ' ) for i in range ( len ( a ) - 1 , - 1 , - 1 ) : print ( a [ i ] , end = ' ' ) print ( ) NEW_LINE"],"bleu":0.22401343373458893,"rouge_l":0.4939271255060729}
{"id":335,"predictions":["N = int ( input ( ) ) NEW_LINE T = 1 NEW_LINE def comb ( n , r ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return [ ] * T NEW_LINE DEDENT else : NEW_LINE INDENT return N % 2 NEW_LINE DEDENT DEDENT N = int ( input ( ) ) NEW_LINE l = 1 NEW_LINE r = 1 NEW_LINE while 1 : NEW_LINE INDENT m = 2 * l * r + 1 NEW_LINE if ( m == 1 ) : NEW_LINE INDENT l = l + 1 NEW_LINE r = r - 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = m - l + 1 NEW_LINE DEDENT DEDENT print ( comb ( l , r ) ) NEW_LINE"],"references":["import math NEW_LINE def simply ( a , b ) : NEW_LINE INDENT g = math . gcd ( a , b ) NEW_LINE a = a \/\/ g NEW_LINE b = b \/\/ g NEW_LINE return ( a , b ) NEW_LINE DEDENT def mul ( a , b , c , d ) : NEW_LINE INDENT return simply ( a * c , b * d ) NEW_LINE DEDENT def add ( a , b , c , d ) : NEW_LINE INDENT return simply ( a * d + b * c , b * d ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE nxt = 0 NEW_LINE depth = 0 NEW_LINE node = 1 NEW_LINE total_node = 1 NEW_LINE p = 0 NEW_LINE q = 1 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT depth = depth + 1 NEW_LINE n = n \/\/ 2 NEW_LINE DEDENT nxt = depth NEW_LINE if ( n == 1 ) : NEW_LINE INDENT print ( str ( depth ) + \" \/ 1\" ) NEW_LINE return NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT node = node * 2 NEW_LINE total_node = total_node * 2 NEW_LINE depth = depth + 1 NEW_LINE p = p * 2 NEW_LINE q = q * 2 NEW_LINE if ( node >= n ) : NEW_LINE INDENT p = p + n * depth NEW_LINE node -= n NEW_LINE DEDENT if ( node == 1 ) : NEW_LINE INDENT nxt = depth - nxt NEW_LINE break NEW_LINE DEDENT DEDENT p , q = mul ( p , q , total_node , total_node - 1 ) NEW_LINE s , t = ( total_node - 1 ) * nxt * total_node * total_node , total_node * total_node * ( total_node - 1 ) * ( total_node - 1 ) NEW_LINE s , t = simply ( s , t ) NEW_LINE x , y = add ( p , q , s , t ) NEW_LINE print ( str ( x ) + \" \/ \" + str ( y ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT","from fractions import * NEW_LINE n = int ( input ( ) ) NEW_LINE l = 0 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n = n \/\/ 2 NEW_LINE l = l + 1 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT print ( ' % d \/ 1' % l ) NEW_LINE DEDENT else : NEW_LINE INDENT s = 1 NEW_LINE t = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT t = t * 2 % n NEW_LINE s *= 2 NEW_LINE if ( t == 1 ) : NEW_LINE INDENT m = i + 1 NEW_LINE break NEW_LINE DEDENT DEDENT r , t , i , ans = s , s * n , l , 0 NEW_LINE while ( r > 1 ) : NEW_LINE INDENT i , t = i + 1 , t \/\/ 2 NEW_LINE if ( r - t > 0 ) : NEW_LINE INDENT r , ans = r - t , ans + i * t NEW_LINE DEDENT DEDENT print ( ( Fraction ( ans , s ) + Fraction ( m , s ) ) \/ ( 1 - Fraction ( 1 , s ) ) ) NEW_LINE DEDENT","from fractions import * NEW_LINE n , L = int ( input ( ) ) , 0 NEW_LINE while ( n % 2 == 0 ) : n , L = n \/\/ 2 , L + 1 NEW_LINE if ( n == 1 ) : NEW_LINE INDENT print ( ' % d \/ 1' % L ) NEW_LINE DEDENT else : NEW_LINE INDENT s , t = 1 , 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT t , s = t * 2 % n , s * 2 NEW_LINE if ( t == 1 ) : NEW_LINE INDENT m = i + 1 NEW_LINE break NEW_LINE DEDENT DEDENT r , t , i , ans = s , s * n , L , 0 NEW_LINE while ( r > 1 ) : NEW_LINE INDENT i , t = i + 1 , t \/\/ 2 NEW_LINE if ( r - t > 0 ) : NEW_LINE INDENT r , ans = r - t , ans + i * t NEW_LINE DEDENT DEDENT print ( Fraction ( ans + m , s - 1 ) ) NEW_LINE DEDENT"],"bleu":0.26534983460994926,"rouge_l":0.43146045028890223}
{"id":336,"predictions":["def STR ( ) : return list ( input ( ) ) def INT ( ) : return int ( input ( ) ) def MAP ( ) : return map ( int , input ( ) . split ( ) ) def MAP2 ( ) : return map ( float , input ( ) . split ( ) ) def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) def STRING ( ) : return input ( ) import stringimport sysfrom heapq import heappop , heappushfrom bisect import * from collections import deque , Counter , defaultdictfrom math import * from itertools import permutations , accumulatedx = [ - 1 , 1 , 0 , 0 ] dy = [ 0 , 0 , 1 , - 1 ] NEW_LINE"],"references":["from collections import defaultdict , deque , Counterfrom sys import stdin , stdoutfrom heapq import heappush , heappopimport mathimport ioimport osimport mathimport bisect   NEW_LINE","d = { } d1 = { } ans = 0   for _ in range ( int ( input ( ) ) ) : x , y = map ( int , input ( ) . split ( ) )   d [ x + y ] = d . get ( x + y , 0 ) + 1 d1 [ x - y ] = d1 . get ( x - y , 0 ) + 1   for k in d : if d [ k ] > 1 : ans += ( d [ k ] * ( d [ k ] - 1 ) ) \/\/ 2   for z in d1 : if d1 [ z ] > 1 : ans += ( d1 [ z ] * ( d1 [ z ] - 1 ) ) \/\/ 2   print ( ans ) NEW_LINE","d = { } d1 = { } ans = 0   for _ in range ( int ( input ( ) ) ) : x , y = map ( int , input ( ) . split ( ) )   sum = x + y diff = x - y   d [ sum ] = d . get ( sum , 0 ) + 1 d1 [ diff ] = d1 . get ( diff , 0 ) + 1   for k in d : if d [ k ] > 1 : ans += ( d [ k ] * ( d [ k ] - 1 ) ) \/\/ 2   for z in d1 : if d1 [ z ] > 1 : ans += ( d1 [ z ] * ( d1 [ z ] - 1 ) ) \/\/ 2   print ( ans ) NEW_LINE"],"bleu":0.18858027189977744,"rouge_l":0.32317880794701986}
{"id":337,"predictions":["import sys , collections , math , itertools , random , bisectINF = sys . maxsizedef get_ints ( ) : return map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) def get_array ( ) : return list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) def input ( ) : return sys . stdin . readline ( ) . strip ( ) mod = 1000000007   s = input ( ) s1 = input ( ) s2 = input ( ) s1 = input ( ) s2 = input ( ) l = len ( s1 ) l2 = [ l - 1 ] for i in s2 : if ( not l1 [ i ] ) : l1 = max ( l1 , l2 ) l2 = max ( l1 , l2 ) if ( s1 [ i ] ) : l2 = l1 . index ( s1 [ i ] ) l2 = l2 . index ( '1' ) if ( l2 [ i ] == '0' ) : l2 = l1 . index ( '1' ) if ( l2 [ l1 [ i ] == '0' ) : l1 = l2 . index ( '1' ) if ( l1 [ i ] == '1' ) : l2 . append ( l2 [ i ] ) else : l2 . append ( l2 [ i ] == '1' )   print ( len ( l1 ) ) NEW_LINE"],"references":["num = int ( input ( ) ) s = input ( ) s1 = s . count ( '1' ) s0 = s . count ( '0' ) output = abs ( s1 - s0 ) print ( output ) NEW_LINE","from sys import stdin , stdout   def main ( ) : n = stdin . readline ( ) s = stdin . readline ( ) [ : - 1 ] ones = s . count ( '1' ) zeros = len ( s ) - ones x = abs ( ones - zeros ) stdout . write ( str ( x ) + ' \\n ' )   if __name__ == \" _ _ main _ _ \" : main ( ) NEW_LINE","def Sol ( ) : t = int ( input ( ) ) s = list ( input ( ) ) n1 = s . count ( \"1\" ) n0 = s . count ( \"0\" ) print ( abs ( n1 - n0 ) ) if __name__ == \" _ _ main _ _ \" : Sol ( ) NEW_LINE"],"bleu":0.09377785604029398,"rouge_l":0.28237472514755235}
{"id":338,"predictions":["n = int ( input ( ) ) arr = sorted ( map ( int , input ( ) . split ( ) ) )   print ( arr [ n \/\/ 2 ] ) NEW_LINE"],"references":["t = int ( input ( ) ) for _ in range ( t ) : n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) p = list ( map ( int , input ( ) . split ( ) ) ) p = set ( p ) while ( 1 ) : f = 0 for i in range ( n - 1 ) : if a [ i ] > a [ i + 1 ] and i + 1 in p : a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i ] f = 1 if not f : break if a == sorted ( a ) : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE","for _ in range ( int ( input ( ) ) ) : n , k = map ( int , input ( ) . split ( ) ) a = [ int ( x ) for x in input ( ) . split ( ) ] b = [ int ( x ) for x in input ( ) . split ( ) ] flag = 1 ss = n for j in range ( ss ) : for i in range ( n - 1 ) : if a [ i ] > a [ i + 1 ] : if i + 1 not in b : flag = 0 break else : a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i ] for i in range ( n - 1 ) : if a [ i ] > a [ i + 1 ] : flag = 0 if flag : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE","def solve ( n , m , a , p ) : a = [ ( v , ai ) for ai , v in enumerate ( a ) ] sorted_a = sorted ( a ) target_idx = { } for si in range ( n ) : v , ai = sorted_a [ si ] target_idx [ ai ] = si   for v , ai in a : ti = target_idx [ ai ] if ai < ti : less , more = ai , ti else : less , more = ti , ai for j in range ( less , more ) : if j not in p : return ' NO ' return ' YES '   if __name__ == ' _ _ main _ _ ' : T = int ( input ( ) ) for t in range ( T ) : n , m = tuple ( map ( int , input ( ) . split ( ) ) ) a = list ( map ( int , input ( ) . split ( ) ) ) p = set ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) print ( solve ( n , m , a , p ) ) NEW_LINE"],"bleu":0.017550020730813607,"rouge_l":0.25236406619385343}
{"id":339,"predictions":["import sysimport collections as ccinput = sys . stdin . buffer . readlineI = lambda : list ( map ( int , input ( ) . split ( ) ) ) prev = cc . defaultdict ( int ) for tc in range ( int ( input ( ) ) ) : x , y = I ( ) div = set ( ) for i in range ( 1 , int ( x ** 0.5 ) + 1 ) : if x % i == 0 : div . add ( i ) div . add ( x \/\/ i ) ans = 0 now = tc + 1 for i in div : if now - prev [ i ] > y : ans += 1 prev [ i ] = now print ( ans ) NEW_LINE"],"references":["import sysinput = sys . stdin . readline   n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) adj = [ [ ] for i in range ( n ) ] for i in range ( n - 1 ) : u , v , w = map ( int , input ( ) . split ( ) ) u -= 1 v -= 1 adj [ u ] . append ( ( v , w ) ) adj [ v ] . append ( ( u , w ) ) best = [ 0 ] * nans = 0   def dfs ( u ) : stack = list ( ) visit = [ False ] * n stack . append ( ( u , - 1 ) ) while stack : u , par = stack [ - 1 ] if not visit [ u ] : visit [ u ] = True for v , w in adj [ u ] : if v != par : stack . append ( ( v , u ) ) else : cand = [ ] for v , w in adj [ u ] : if v != par : cand . append ( best [ v ] + a [ v ] - w ) cand . sort ( reverse = True ) cur = a [ u ] for i in range ( 2 ) : if i < len ( cand ) and cand [ i ] > 0 : cur += cand [ i ] global ans ans = max ( ans , cur ) best [ u ] = cand [ 0 ] if len ( cand ) > 0 and cand [ 0 ] > 0 else 0 stack . pop ( )   dfs ( 0 ) print ( ans ) NEW_LINE","from sys import stdin , setrecursionlimitimport threadingn = int ( stdin . readline ( ) ) w = [ int ( x ) for x in stdin . readline ( ) . split ( ) ] graph = [ { } for x in range ( n ) ] for road in range ( n - 1 ) : u , v , c = [ int ( x ) for x in stdin . readline ( ) . split ( ) ] u -= 1 v -= 1   if v in graph [ u ] : graph [ u ] [ v ] = min ( graph [ u ] [ v ] , c ) else : graph [ u ] [ v ] = c   if u in graph [ v ] : graph [ v ] [ u ] = min ( graph [ v ] [ u ] , c ) else : graph [ v ] [ u ] = c   gas = [ { } for x in range ( n ) ] highs = [ [ 0 , 0 ] for x in range ( n ) ]   path = [ ( 0 , 0 ) ]   ind = 0   while ind < len ( path ) : cur , par = path [ ind ] edges = graph [ cur ] for x in edges : if x != par : path . append ( ( x , cur ) ) ind += 1   def mostGas ( node , parent ) : edges = graph [ node ] high = w [ node ] high2 = w [ node ] for x in edges : if x != parent : gas [ node ] [ x ] = highs [ x ] [ 0 ] + w [ node ] - edges [ x ] if gas [ node ] [ x ] > high : high , high2 = gas [ node ] [ x ] , high elif gas [ node ] [ x ] > high2 : high2 = gas [ node ] [ x ] highs [ node ] = [ high , high2 ] return high   ''' def ▁ fillIn ( node , parent ) : ▁ ▁ ▁ ▁ edges ▁ = ▁ graph [ node ] ▁ ▁ ▁ ▁ high , high2 ▁ = ▁ highs [ node ] ▁ ▁ ▁ ▁ for ▁ x ▁ in ▁ edges : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ x ▁ ! = ▁ parent : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ gas [ node ] [ x ] ▁ = = ▁ high : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ gas [ x ] [ node ] ▁ = ▁ high2 ▁ - ▁ edges [ x ] ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ else : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ gas [ x ] [ node ] ▁ = ▁ high ▁ - ▁ edges [ x ] ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ gas [ x ] [ node ] ▁ > ▁ highs [ x ] [0 ] : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ highs [ x ] ▁ = ▁ [ gas [ x ] [ node ] , ▁ highs [ x ] [0 ] ] ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ elif ▁ gas [ x ] [ node ] ▁ > ▁ highs [ x ] [1 ] : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ highs [ x ] [1 ] ▁ = ▁ gas [ x ] [ node ] ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ fillIn ( x , node ) ''' for x , y in path [ : : - 1 ] : mostGas ( x , y ) NEW_LINE"],"bleu":0.09404472363417304,"rouge_l":0.3127999474064822}
{"id":340,"predictions":["import sys , mathfrom collections import deque , defaultdictimport operator as opfrom functools import reducefrom itertools import permutations   NEW_LINE"],"references":["s = input ( ) k = int ( input ( ) ) l = len ( s )   if l % k : print ( \" NO \" ) else : f = True t = l \/\/ k for i in range ( 0 , l , t ) : sub = s [ i : i + t ] if sub != sub [ : : - 1 ] : f = False break   print ( \" YES \" if f else \" NO \" )       NEW_LINE","if __name__ == ' _ _ main _ _ ' : Y = lambda : list ( map ( int , input ( ) . split ( ) ) ) P = lambda : map ( int , input ( ) . split ( ) ) N = lambda : int ( input ( ) )   s = input ( ) k = N ( ) d = dict ( )   if len ( s ) % k : print ( \" NO \" ) else : d = len ( s ) \/\/ k cnt = 0 for c in range ( 0 , len ( s ) , d ) : sub = s [ c : c + d ] cnt += ( s [ c : c + d ] == s [ c : c + d ] [ : : - 1 ] ) print ( \" YNEOS \" [ not cnt == k : : 2 ] ) NEW_LINE","s = input ( ) k = int ( input ( ) ) if len ( s ) % k != 0 : print ( \" NO \" ) else : i , n , z = 0 , len ( s ) \/\/ k , len ( s ) \/\/ k while z <= len ( s ) : x = s [ i : z ] if x != x [ : : - 1 ] : print ( \" NO \" ) break i += n z += n else : print ( \" YES \" ) NEW_LINE"],"bleu":0.001824941032093419,"rouge_l":0.06224489795918367}
{"id":341,"predictions":["def STR ( ) : return list ( input ( ) ) def INT ( ) : return int ( input ( ) ) def MAP ( ) : return map ( int , input ( ) . split ( ) ) def MAP2 ( ) : return map ( float , input ( ) . split ( ) ) def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) def STRING ( ) : return input ( ) import stringimport sysfrom heapq import heappop , heappushfrom bisect import * from collections import deque , Counter , defaultdictfrom math import * from itertools import permutations , accumulatedx = [ - 1 , 1 , 0 , 0 ] dy = [ 0 , 0 , 1 , - 1 ] NEW_LINE"],"references":["from bisect import bisect_left   n , m , ta , tb , k = map ( int , input ( ) . split ( ) ) a = [ int ( X ) + ta for X in input ( ) . split ( ) ] b = [ int ( X ) for X in input ( ) . split ( ) ] an = - 1 NEW_LINE","n , m , ta , tb , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) )   if n <= k : print ( - 1 ) else : ind = 0 maxx = - 1 for i in range ( k + 1 ) : arriv = a [ i ] + ta while ( ind < m and b [ ind ] < arriv ) : ind += 1 if ind + ( k - i ) >= m : maxx = - 1 break else : maxx = max ( maxx , b [ ind + k - i ] + tb ) print ( maxx )   NEW_LINE","n , m , ta , tb , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) j = 0 ans = - 1 for i in range ( m ) : if j < n and a [ j ] + ta <= b [ i ] : k -= 1 j += 1 if k < 0 : ans = b [ i ] + tb break if j >= n : breakprint ( ans ) NEW_LINE"],"bleu":0.3007876486574368,"rouge_l":0.44286098413552033}
{"id":342,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["for i in range ( int ( input ( ) ) ) : print ( max ( 0 , int ( input ( ) ) - 2 ) ) NEW_LINE","for i in range ( int ( input ( ) ) ) : print ( max ( 0 , int ( input ( ) ) - 2 ) ) NEW_LINE","import sysinput = sys . stdin . readlinefor _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) if n > 2 : sys . stdout . write ( str ( n - 2 ) + ' \\n ' ) else : sys . stdout . write ( '0 \\n ' ) NEW_LINE"],"bleu":0.20316380285013624,"rouge_l":0.45941422594142256}
{"id":343,"predictions":["n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) i = 0j = n - 1 c = 0 while ( i <= n and j > k ) : if a [ i ] <= a [ j ] : i += 1 c += 1 i += 1 print ( i + 1 ) NEW_LINE"],"references":["a , b = map ( int , input ( ) . split ( ) ) c = list ( map ( int , input ( ) . split ( ) ) ) ans = 0 mini = sum ( c ) for i in range ( b ) : d = i su = 0 while ( d < a ) :   su += c [ d ] d += b if su < mini :   mini = su ans = iprint ( ans + 1 ) NEW_LINE","n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) ans = 10 ** 9 bestI = 0 for i in range ( k ) : score = 0 r = n \/\/ k while r > 0 : score += a [ i ] i += k if i >= n : i -= n r -= 1 if score < ans : ans = score bestI = i + 1 print ( bestI ) NEW_LINE","def todo_list ( end , k , arr ) : count = 0 start = 0 result = 100000 * 1000000 while count != k : b = 0 for x in range ( start , end , k ) : b += arr [ x ] if b < result : result = b ans = start + 1 start += 1 count += 1   return ans     n , k = map ( int , input ( ) . split ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) print ( todo_list ( n , k , arr ) ) NEW_LINE"],"bleu":0.5367374533929463,"rouge_l":0.5747555555555556}
{"id":344,"predictions":["import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE inf = 10 ** 20 NEW_LINE mod = 10 ** 9 + 7 NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def F ( ) : return float ( sys . stdin . readline ( ) ) NEW_LINE def S ( ) : return input ( ) NEW_LINE def main ( ) : NEW_LINE INDENT N , X = LI ( ) NEW_LINE W = sorted ( [ I ( ) for _ in range ( N ) ] , reverse = True ) NEW_LINE d = collections . Counter ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if d [ i ] [ 0 ] : NEW_LINE INDENT d [ i ] += X ^ i NEW_LINE DEDENT else : NEW_LINE INDENT d [ i ] = 0 NEW_LINE DEDENT DEDENT ans += 1 NEW_LINE print ( ans \/\/ 2 ) NEW_LINE return ans \/\/ 2 * N NEW_LINE DEDENT main ( ) NEW_LINE"],"references":["n , x = map ( int , input ( ) . split ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) dp = [ 0 ] * ( 1 << 18 ) ans = 0 NEW_LINE","n , x = map ( int , input ( ) . split ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) dp = [ 0 ] * ( 10 ** 6 + 1 ) for i in arr : dp [ i ] += 1 NEW_LINE","n , x = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) )   ans = 0 d = { } for k in a : if d . get ( k ^ x , 0 ) > 0 : ans += d . get ( k ^ x ) d [ k ] = d . get ( k , 0 ) + 1 print ( ans ) NEW_LINE"],"bleu":0.08726433617382885,"rouge_l":0.26351156762983585}
{"id":345,"predictions":["from sys import stdin , stdoutstdin . readlinedef mp ( ) : return list ( map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) ) def it ( ) : return int ( stdin . readline ( ) . strip ( ) ) from math import ceilfrom collections import defaultdict as ddfrom collections import Counter as Cn = it ( ) l = sorted ( mp ( ) ) NEW_LINE"],"references":["x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) x , y = map ( int , input ( ) . split ( ) ) if ( x2 - x1 ) % x == 0 and ( y2 - y1 ) % y == 0 : if ( ( x2 - x1 ) \/\/ x + ( y2 - y1 ) \/\/ y ) % 2 == 0 : print ( \" YES \" ) else : print ( \" NO \" ) else : print ( \" NO \" ) NEW_LINE","x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) x , y = map ( int , input ( ) . split ( ) ) if x1 == x2 and y1 == y2 : print ( \" YES \" ) elif x2 == x1 and abs ( y2 - y1 ) % y == 0 : move_y = abs ( y2 - y1 ) \/\/ y if move_y % 2 == 0 : print ( \" YES \" ) else : print ( \" NO \" ) elif y2 == y1 and abs ( x2 - x1 ) % x == 0 : move_x = abs ( x2 - x1 ) \/\/ x if move_x % 2 == 0 : print ( \" YES \" ) else : print ( \" NO \" ) elif abs ( x2 - x1 ) % x == 0 and abs ( y2 - y1 ) % y == 0 : move_x = abs ( x2 - x1 ) \/\/ x ; move_y = abs ( y2 - y1 ) \/\/ y NEW_LINE","import mathdef main ( ) : x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) x , y = map ( int , input ( ) . split ( ) )   dx = abs ( x1 - x2 ) dy = abs ( y1 - y2 )   if dx % x == 0 and dy % y == 0 : if ( dx \/ x ) % 2 == ( dy \/ y ) % 2 : print ( \" YES \" ) else : print ( \" NO \" ) else : print ( \" NO \" )                                       if __name__ == ' _ _ main _ _ ' : main ( ) NEW_LINE"],"bleu":0.1396808627043503,"rouge_l":0.3399059856527352}
{"id":346,"predictions":["def digitsof ( n ) : lst = [ ] while n > 0 : lst . append ( n % 10 ) n \/\/= 10 return lst     def answer ( n ) : NEW_LINE"],"references":["def new ( n ) : while n % 10 == 0 : n = n \/\/ 10 return n if __name__ == ' _ _ main _ _ ' : n = int ( input ( ) ) d = dict ( ) c = 1 flag = 1 d . setdefault ( n , 1 ) while flag == 1 : n = n + 1 n = new ( n ) d . setdefault ( n , 0 ) if d [ n ] == 0 : d [ n ] = 1 c += 1 else : flag = 0 print ( c ) NEW_LINE","n = int ( input ( ) ) ans = 0 i = 1 while n > 0 : if i == 1 : if n < 10 : ans += 9 n = 0 else : temp = n % 10 ans += 10 - temp n = n \/\/ 10 i += 1 else : if n < 10 : ans += 9 n = 0 else : temp = ( n % 10 ) + 1 ans += 10 - temp n = n \/\/ 10 print ( ans ) NEW_LINE","def f ( x ) : x += 1 while ( x % 10 == 0 ) : x \/\/= 10 return x   a = set ( ) n = int ( input ( ) )   while ( not ( n in a ) ) : a . add ( n ) n = f ( n )   print ( len ( a ) ) NEW_LINE"],"bleu":0.16294908731219268,"rouge_l":0.3399823995306541}
{"id":347,"predictions":["a , b , x , y = map ( int , input ( ) . split ( ) ) d = abs ( x ) y , x , y , x1 , y1 = x1 + y1 - y2 x3 , y3 = y1 - y2 , x1 - x2 + y2 * 2 x1 , y1 = y2 - y1 + ( x1 - x2 , y1 ) print ( d , 0 , 0 ) NEW_LINE"],"references":["T_ON = 0 DEBUG_ON = 0 MOD = 998244353     def solve ( ) : a , b = read_ints ( ) x , y , z = read_ints ( ) print ( max ( 0 , 2 * x + y - a ) + max ( 0 , y + 3 * z - b ) )     def main ( ) : T = read_int ( ) if T_ON else 1 for i in range ( T ) : solve ( )     def debug ( * xargs ) : if DEBUG_ON : print ( * xargs )     from collections import * import math     NEW_LINE","a , b = list ( map ( int , input ( ) . split ( ) ) ) x , y , z = list ( map ( int , input ( ) . split ( ) ) ) ans = 0 p = a - ( ( x * 2 ) + y ) q = b - ( ( z * 3 ) + y ) NEW_LINE","A , B = map ( int , input ( ) . split ( ) ) x , y , z = map ( int , input ( ) . split ( ) ) A1 = 2 * x + y - AB1 = 3 * z + y - Bfinal = 0 if A1 > 0 : final = final + A1if B1 > 0 : final = final + B1print ( final ) NEW_LINE"],"bleu":0.272694006215624,"rouge_l":0.4453539823008849}
{"id":348,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) PI = float ( ' inf ' ) for _ in range ( 1 ) : NEW_LINE"],"references":["n = input ( )   p0 = [ 1 ] p1 = [ 0 , 1 ]   if n == 1 : print 1 print 0 , 1 print 0 print 1 exit ( )   for i in xrange ( 2 , n + 1 ) : p = [ 0 for j in xrange ( i + 1 ) ]   for j in xrange ( len ( p1 ) ) : p [ j + 1 ] = p1 [ j ] for j in xrange ( len ( p0 ) ) : p [ j ] += p0 [ j ]   for j in xrange ( len ( p ) ) : p [ j ] %= 2   if i == n : print i print ' ▁ ' . join ( map ( str , p ) ) print i - 1 print ' ▁ ' . join ( map ( str , p1 ) )   p0 = [ p1 [ j ] for j in xrange ( len ( p1 ) ) ] p1 = [ p [ j ] for j in xrange ( len ( p ) ) ] NEW_LINE","n = int ( input ( ) ) p = [ [ 1 ] , [ 0 , 1 ] ] for i in range ( n - 1 ) : t = [ 0 ] + p [ - 1 ] for j in range ( len ( p [ i ] ) ) : t [ j ] ^= p [ i ] [ j ] p . append ( t ) print ( n ) print ( * p [ n ] ) print ( n - 1 ) print ( * p [ - 2 ] ) NEW_LINE","n = int ( input ( ) )   def print_poly ( a ) : print ( len ( a ) - 1 ) print ( ' ▁ ' . join ( map ( str , a ) ) )   def shift_add ( a , mul , b ) : c = [ 0 ] * ( len ( a ) + 1 ) for i in range ( len ( a ) ) : c [ i + 1 ] = a [ i ] * mul for i in range ( len ( b ) ) : c [ i ] += b [ i ] return c   a = [ 0 , 1 ] b = [ 1 ]   for i in range ( n - 1 ) : c = shift_add ( a , 1 , b ) if max ( c ) <= 1 and min ( c ) >= - 1 : a , b = c , a else : c = shift_add ( a , - 1 , b ) if max ( c ) <= 1 and min ( c ) >= - 1 : a , b = c , a else : print ( ' > ▁ < ' )   if a [ - 1 ] == - 1 : a = list ( map ( lambda x : - x , a ) ) if b [ - 1 ] == - 1 : b = list ( map ( lambda x : - x , b ) )   print_poly ( a ) print_poly ( b ) NEW_LINE"],"bleu":0.07664448830036498,"rouge_l":0.27236485409025674}
{"id":349,"predictions":["a , b = map ( int , input ( ) . split ( ) ) l = list ( map ( str , input ( ) ) ) for c in l : if ( c == \" A \" and c <= \" Z \" ) : print ( - 1 ) else : print ( - 1 ) NEW_LINE"],"references":["x = input ( ) . lower ( ) y = input ( ) . lower ( ) if ( x < y ) : print ( \" - 1\" ) elif ( x > y ) : print ( \"1\" ) else : print ( \"0\" ) NEW_LINE","str1 = input ( ) . lower ( ) str2 = input ( ) . lower ( )   if str1 < str2 : print ( - 1 ) elif str2 < str1 : print ( 1 ) else : print ( 0 ) NEW_LINE","a = input ( ) . lower ( ) b = input ( ) . lower ( ) z = len ( a ) NEW_LINE"],"bleu":0.28427839655937787,"rouge_l":0.5527936821322803}
{"id":350,"predictions":["n , k = map ( int , input ( ) . split ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) arr1 = sorted ( arr ) k1 = arr1 [ n - k : ] ; ans = [ ] ; sett = set ( ) ; last = - 1 d = { } for i in k1 : d [ i ] = d . get ( i , 0 ) + 1 NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) used = [ 0 ] * ( n + 1 ) ans = [ 0 ] * ( n + 1 )   for x , y in zip ( a , a [ 1 : ] ) : z = ( y - x ) % n or n if ans [ x ] == 0 and used [ z ] or ans [ x ] != 0 and ans [ x ] != z : print ( - 1 ) exit ( ) used [ z ] = 1 ans [ x ] = z   i = 1 for j in range ( 1 , n + 1 ) : if ans [ j ] == 0 : while used [ i ] : i += 1 ans [ j ] = i i += 1   print ( * ans [ 1 : ] ) NEW_LINE","\"\"\" Author ▁ ▁ ▁ ▁ : ▁ co _ devil ▁ Chirag ▁ GargInstitute ▁ : ▁ JIIT \"\"\"     from __future__ import division , print_functionfrom sys import stdin , stdoutimport itertools , os , sys , threadingfrom collections import deque , Counter , OrderedDict , defaultdictimport heapqfrom math import ceil , floor , log , sqrt , factorial , pow , pi , gcd NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) ans = [ None ] * nl = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( 1 , m ) : d = ( l [ i ] - l [ i - 1 ] ) % n if d == 0 : d += n if ans [ l [ i - 1 ] - 1 ] == None or ans [ l [ i - 1 ] - 1 ] == d : ans [ l [ i - 1 ] - 1 ] = d else : print ( - 1 ) quit ( ) l = [ i + 1 for i in range ( n ) ] for i in ans : if i in l : l . remove ( i ) elif i != None : print ( - 1 ) quit ( ) for i in ans : if i == None : print ( l [ - 1 ] , end = \" ▁ \" ) l . pop ( ) else : print ( i , end = \" ▁ \" ) NEW_LINE"],"bleu":0.44526737596134897,"rouge_l":0.3995747981727813}
{"id":351,"predictions":["def STR ( ) : return list ( input ( ) ) def INT ( ) : return int ( input ( ) ) def MAP ( ) : return map ( int , input ( ) . split ( ) ) def MAP2 ( ) : return map ( float , input ( ) . split ( ) ) def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) def STRING ( ) : return input ( ) import stringimport sysfrom heapq import heappop , heappushfrom bisect import * from collections import deque , Counter , defaultdictfrom math import * from itertools import permutations , accumulatedx = [ - 1 , 1 , 0 , 0 ] dy = [ 0 , 0 , 1 , - 1 ] NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) while n > 0 and m > 0 : if n >= 2 * m : n = n % ( 2 * m ) elif m >= 2 * n : m = m % ( 2 * n ) else : breakprint ( n , m , sep = \" ▁ \" )   NEW_LINE","def STR ( ) : return list ( input ( ) ) def INT ( ) : return int ( input ( ) ) def MAP ( ) : return map ( int , input ( ) . split ( ) ) def MAP2 ( ) : return map ( float , input ( ) . split ( ) ) def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) def STRING ( ) : return input ( ) import stringimport sysfrom heapq import heappop , heappushfrom bisect import * from collections import deque , Counter , defaultdictfrom math import * from itertools import permutations , accumulatedx = [ - 1 , 1 , 0 , 0 ] dy = [ 0 , 0 , 1 , - 1 ] NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) a = nb = mwhile a * b > 0 : if a >= 2 * b : a = a % ( 2 * b ) elif b >= 2 * a : b = b % ( 2 * a ) else : breakprint ( a , b ) NEW_LINE"],"bleu":1.0,"rouge_l":1.0}
{"id":352,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["inp = input ( )   n = int ( inp [ 0 : ( len ( inp ) - 1 ) ] )   n -= 1   base = ( n \/\/ 4 ) * 16 + ( n % 2 ) * 7   def cnt ( s ) : if s == ' f ' : return 1 if s == ' e ' : return 2 if s == ' d ' : return 3 if s == ' a ' : return 4 if s == ' b ' : return 5 if s == ' c ' : return 6   print ( base + cnt ( inp [ len ( inp ) - 1 ] ) ) NEW_LINE","def f ( a ) : if a == \" a \" : return 4 if a == \" b \" : return 5 if a == \" c \" : return 6 if a == \" d \" : return 3 if a == \" e \" : return 2 if a == \" f \" : return 1   a = input ( ) b = int ( a [ : - 1 ] ) c = a [ - 1 ] s = ( ( b - 1 ) \/\/ 4 ) * 16 b = b % 2 if b == 1 : print ( s + f ( c ) ) else : print ( 7 + s + f ( c ) ) NEW_LINE","s = input ( ) n = int ( s [ : len ( s ) - 1 ] ) s = s [ - 1 ] ans = 0 if n % 2 == 0 : if ( n \/\/ 2 ) % 2 == 1 : ans = ans + ( ( ( n - 1 ) \/\/ 2 ) \/\/ 2 ) * 16 + 7 else : ans = ans + ( ( ( n - 3 ) \/\/ 2 ) \/\/ 2 ) * 16 + 7 else : if ( n \/\/ 2 ) % 2 == 0 : ans = ans + ( ( n \/\/ 2 ) \/\/ 2 ) * 16 else : ans = ans + ( ( ( n - 2 ) \/\/ 2 ) \/\/ 2 ) * 16 if s in [ ' d ' , ' e ' , ' f ' ] : ans = ans + abs ( ord ( s ) - ord ( ' f ' ) ) + 1 else : ans = ans + abs ( ord ( s ) - ord ( ' a ' ) ) + 4 print ( ans ) NEW_LINE"],"bleu":0.018930973272451086,"rouge_l":0.18097054460690823}
{"id":353,"predictions":["from sys import stdininput = stdin . readline   n , t = [ int ( x ) for x in input ( ) . split ( ) ] a = [ int ( x ) for x in input ( ) . split ( ) ] for i in range ( n ) : t -= 86400 - a [ i ] if t <= 0 : print ( i + 1 ) break NEW_LINE"],"references":["n = int ( input ( ) ) arr = [ i for i in range ( n ) ] NEW_LINE","r = int ( input ( ) ) if r % 2 == 0 : print ( - 1 ) elif r == 1 : print ( 0 ) print ( 0 ) print ( 0 )   else : for i in range ( r ) : print ( i , end = \" ▁ \" ) print ( ) i = r - 1 while i >= 0 : print ( i , end = \" ▁ \" ) i -= 2 i = r - 2 while i >= 0 : print ( i , end = \" ▁ \" ) i -= 2 print ( ) for i in range ( r - 1 , - 1 , - 1 ) : print ( i , end = \" ▁ \" )   NEW_LINE","r = int ( input ( ) ) if r % 2 == 0 : print ( - 1 ) elif r == 1 : print ( 0 ) print ( 0 ) print ( 0 )   else : for i in range ( r ) : print ( i , end = \" ▁ \" ) print ( ) i = r - 1 while i >= 0 : print ( i , end = \" ▁ \" ) i -= 2 i = r - 2 while i >= 0 : print ( i , end = \" ▁ \" ) i -= 2 print ( ) for i in range ( r - 1 , - 1 , - 1 ) : print ( i , end = \" ▁ \" ) NEW_LINE"],"bleu":0.216588797673351,"rouge_l":0.6151396536853977}
{"id":354,"predictions":["def STR ( ) : return list ( input ( ) ) def INT ( ) : return int ( input ( ) ) def MAP ( ) : return map ( int , input ( ) . split ( ) ) def MAP2 ( ) : return map ( float , input ( ) . split ( ) ) def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) def STRING ( ) : return input ( ) import stringimport sysfrom heapq import heappop , heappushfrom bisect import * from collections import deque , Counter , defaultdictfrom math import * from itertools import permutations , accumulatedx = [ - 1 , 1 , 0 , 0 ] dy = [ 0 , 0 , 1 , - 1 ] NEW_LINE"],"references":["import sysfrom collections import Counterdef fmax ( n , m , a ) : c = [ 0 ] * m b = [ 0 ] * n   if n == 3 * m : for i in range ( n \/\/ 3 ) : for j in range ( 3 ) : b [ a [ i ] [ j ] - 1 ] = j + 1 for i in range ( m ) : flag = 1 for j in range ( 3 ) : if b [ a [ i ] [ j ] - 1 ] != 0 : index = b [ a [ i ] [ j ] - 1 ] if j == 0 and index == 1 : continue b [ a [ i ] [ index - 1 ] - 1 ] = j + 1 continue b [ a [ i ] [ j ] - 1 ] = j + 1 return b if __name__ == ' _ _ main _ _ ' : input = sys . stdin . read ( ) data = list ( map ( int , input . split ( ) ) ) n = data [ 0 ] m = data [ 1 ] l = 0 a = [ ] for i in range ( m ) : a . append ( list ( map ( int , ( data [ l + 2 : l + 5 ] ) ) ) ) l = l + 3 print ( * fmax ( n , m , a ) ) NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) l = [ 0 ] * ( n + 1 ) for _ in range ( m ) : p = [ 1 , 2 , 3 ] arr = list ( map ( int , input ( ) . split ( ) ) ) for i in arr : if l [ i ] != 0 : p . remove ( l [ i ] ) for i in arr : if l [ i ] == 0 : l [ i ] = p . pop ( ) NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) x = [ ] for i in range ( m ) : x . append ( list ( map ( int , input ( ) . split ( ) ) ) ) d = { } for i , j in enumerate ( x ) : y = [ 1 , 2 , 3 ] if i == 0 : d [ j [ 0 ] ] = 1 d [ j [ 1 ] ] = 2 d [ j [ 2 ] ] = 3 continue for k in j : if k in d : y . remove ( d [ k ] ) c = 0 for k in j : if k not in d : d [ k ] = y [ c ] c += 1 x = sorted ( d ) for i in x : print ( d [ i ] , end = \" ▁ \" ) NEW_LINE"],"bleu":0.271684652441211,"rouge_l":0.361483667323763}
{"id":355,"predictions":["n = int ( input ( ) ) if n == 1 : print ( 1 ) print ( 1 ) print ( 1 ) else : print ( 2 , 1 ) print ( 1 , 2 ) NEW_LINE"],"references":["def odd ( lst , n ) : for i in range ( 1 , n + 1 , 2 ) : lst . append ( i ) def even ( lst , n ) : start = 2 if len ( lst ) == 1 or n == 3 : start = 4 for j in range ( start , n + 1 , 2 ) : lst . append ( j )           n = int ( input ( ) ) lst = [ ]   if n % 2 == 0 and n > 2 : even ( lst , n ) odd ( lst , n ) else : odd ( lst , n ) even ( lst , n ) print ( len ( lst ) ) print ( * lst ) NEW_LINE","n = int ( input ( ) ) if n == 1 : print ( 1 ) print ( 1 ) elif n <= 3 : print ( n - 1 ) if n == 2 : print ( 1 ) else : print ( 1 , 3 ) else : print ( n ) for i in range ( 2 , n + 1 , 2 ) : print ( i , end = \" ▁ \" ) for i in range ( 1 , n + 1 , 2 ) : print ( i , end = \" ▁ \" ) print ( ) NEW_LINE","n = int ( input ( ) ) k = [ ] for i in range ( 1 , n + 1 ) : if i % 2 != 0 : k . append ( i ) for i in range ( 1 , n + 1 ) : if i % 2 == 0 : k . append ( i ) if n == 2 : print ( 1 ) print ( 1 ) elif n == 3 : print ( 2 ) print ( * [ 1 , 3 ] ) elif n == 4 : print ( 4 ) print ( * [ 3 , 1 , 4 , 2 ] ) else : print ( n ) print ( * k ) NEW_LINE"],"bleu":0.16617104927715245,"rouge_l":0.5028854080791426}
{"id":356,"predictions":["n = int ( input ( ) ) arr = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE"],"references":["def count ( x1 , y1 , z1 , x2 , y2 , z2 ) : if x2 == 0 and a != 0 or y2 == 0 and b != 0 or z2 == 0 and c != 0 : return False if x2 == 0 : x2 = 1 if y2 == 0 : y2 = 1 if z2 == 0 : z2 = 1 return ( x1 \/ x2 ) ** a * ( y1 \/ y2 ) ** b * ( z1 \/ z2 ) ** c < 1     n = int ( input ( ) ) a , b , c = map ( int , input ( ) . split ( ) ) l1 , r1 = 0 , nfor i in range ( 200 ) : x1 = l1 + ( r1 - l1 ) \/ 3 l2 , r2 = 0 , n - x1 for j in range ( 200 ) : y1 = l2 + ( r2 - l2 ) \/ 3 y2 = r2 - ( r2 - l2 ) \/ 3 if count ( x1 , y1 , n - x1 - y1 , x1 , y2 , n - x1 - y2 ) : l2 = y1 else : r2 = y2 y11 = l2 x2 = r1 - ( r1 - l1 ) \/ 3 l2 , r2 = 0 , n - x2 for j in range ( 200 ) : y1 = l2 + ( r2 - l2 ) \/ 3 y2 = r2 - ( r2 - l2 ) \/ 3 if count ( x2 , y1 , n - x2 - y1 , x2 , y2 , n - x2 - y2 ) : l2 = y1 else : r2 = y2 y22 = l2 if count ( x1 , y11 , n - x1 - y11 , x2 , y22 , n - x2 - y22 ) : l1 = x1 p = y11 else : r1 = x2 p = y22print ( l1 , p , n - l1 - p ) NEW_LINE","n = int ( input ( ) ) a , b , c = map ( int , input ( ) . split ( ) ) s = a + b + cif ( s == 0 ) : print ( 0 , 0 , 0 ) else : print ( n * a \/ s , n * b \/ s , n * c \/ s ) NEW_LINE","def gribnye ( s , a , b , c ) : if a == b == c == s == 0 : return [ 0.0 ] elif a == b == c == 0 and s != 0 : return 0 , 0 , 0 a1 = a * s \/ ( a + b + c ) b1 = b * s \/ ( a + b + c ) c1 = c * s \/ ( a + b + c ) return a1 , b1 , c1     S = int ( input ( ) ) A , B , C = [ int ( i ) for i in input ( ) . split ( ) ] print ( * gribnye ( S , A , B , C ) ) NEW_LINE"],"bleu":0.13795751785766389,"rouge_l":0.3602053915275995}
{"id":357,"predictions":["n = int ( input ( ) ) while n > 0 : n = n - 1 a , b = map ( int , input ( ) . split ( ) ) print ( b * 2 )     NEW_LINE"],"references":["s = input ( ) n = len ( s ) ans = s [ - 1 ] for i in range ( n - 2 , - 1 , - 1 ) : if s [ i ] >= ans [ - 1 ] : ans += s [ i ] print ( ans [ : : - 1 ] ) NEW_LINE","s = list ( input ( ) ) a = list ( set ( s ) ) a . sort ( reverse = True ) l = [ ] k = 0 for j in range ( len ( a ) ) : for i in range ( k , len ( s ) ) : if ( a [ j ] == s [ i ] ) : l . append ( s [ i ] ) k = iprint ( \" \" . join ( l ) ) NEW_LINE","si = input ( ) ans = \" \" while 1 : co = si . count ( max ( si ) ) ans = ans + max ( si ) * co NEW_LINE"],"bleu":0.19913222255216806,"rouge_l":0.4235889938912963}
{"id":358,"predictions":["n = int ( input ( ) ) a = int ( input ( ) ) b = int ( input ( ) ) import mathdef extgcd ( a , b ) : NEW_LINE"],"references":["n , k = map ( int , input ( ) . split ( ) ) lst = sorted ( [ int ( i ) % k for i in input ( ) . split ( ) ] ) low , high = 0 , n - 1 count = 0   while low < high : if lst [ low ] + lst [ high ] == k : low += 1 high -= 1 count += 2 elif lst [ low ] + lst [ high ] < k : low += 1 else : high -= 1   print ( count + 2 * ( lst . count ( 0 ) \/\/ 2 ) ) NEW_LINE","from sys import stdinstdin . readlinedef mp ( ) : return list ( map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) ) def it ( ) : return int ( stdin . readline ( ) . strip ( ) ) from math import ceil , sqrt , gcd , factorial NEW_LINE","def maxPairs ( nums , k ) : m = { } result = 0 for i in nums : if ( ( i in m ) and m [ i ] > 0 ) : m [ i ] = m [ i ] - 1 result += 1 else : if k - i in m : m [ k - i ] += 1 else : m [ k - i ] = 1 return result     def solve ( ) : n , k = map ( int , input ( ) . split ( ) ) d = list ( map ( lambda x : int ( x ) % k , input ( ) . split ( ) ) ) return ( d . count ( 0 ) \/\/ 2 + maxPairs ( d , k ) ) * 2 print ( solve ( ) ) NEW_LINE"],"bleu":0.08770882498987134,"rouge_l":0.3296649307261472}
{"id":359,"predictions":["def main ( ) : NEW_LINE INDENT n , m = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE ans = [ - 1 for i in range ( 1 , n + 1 ) ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT if m > 0 : NEW_LINE INDENT ans [ i ] = m - 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans [ i ] = m - 1 NEW_LINE DEDENT DEDENT print ( ans [ - 1 ] ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE def main ( ) : NEW_LINE INDENT n , m = map ( int , sys . stdin . read ( ) . strip ( ) . split ( ) ) NEW_LINE m %= ( 1 + n ) * n \/\/ 2 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT m -= i NEW_LINE if not m : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif m < 0 : NEW_LINE INDENT return m + i NEW_LINE DEDENT DEDENT DEDENT print ( main ( ) ) NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) NEW_LINE it_is_end = False NEW_LINE while True : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if m >= i : NEW_LINE INDENT m -= i NEW_LINE DEDENT else : NEW_LINE INDENT it_is_end = True NEW_LINE break NEW_LINE DEDENT DEDENT if it_is_end : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( m ) NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) NEW_LINE i = 0 NEW_LINE while m > i : m , i = m - i - 1 , ( i + 1 ) % n NEW_LINE print ( m ) NEW_LINE"],"bleu":0.4302288656087742,"rouge_l":0.5848401583643562}
{"id":360,"predictions":["import sysinput = sys . stdin . readlinefrom collections import defaultdict as dcfrom collections import Counterfrom bisect import bisect_right , bisect_leftimport mathfrom operator import itemgetterfrom heapq import heapify , heappop , heappushfrom queue import PriorityQueue as pqn , a , b = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l1 = [ ] l2 = [ ] for i in range ( n ) : if l1 [ i ] > l2 [ i ] : l1 [ i ] = l1 [ i ] l2 [ i ] = l2 [ i ] + 1 j = 0 print ( * l1 ) NEW_LINE"],"references":["a , b , c = map ( int , input ( ) . split ( ) ) data = list ( map ( int , input ( ) . split ( ) ) ) datb = list ( map ( int , input ( ) . split ( ) ) ) res = [ ] for i in range ( 1 , a + 1 ) : if i in data : res . append ( \"1\" ) else : res . append ( \"2\" ) print ( \" ▁ \" . join ( res ) ) NEW_LINE","n , a , b = map ( int , input ( ) . split ( ) ) ar = [ ] ar = list ( map ( int , input ( ) . split ( ) ) ) al = [ ] al = list ( map ( int , input ( ) . split ( ) ) ) l = [ ] for i in range ( 1 , n + 3 ) : l . append ( 0 ) ; for i in ar : l [ i ] = 1 for i in al : l [ i ] = 2 for i in range ( 1 , len ( l ) - 1 ) : print ( l [ i ] , end = \" ▁ \" )     NEW_LINE","n , a , b = input ( ) . split ( ) arth = list ( map ( int , input ( ) . split ( ) ) ) alex = list ( map ( str , input ( ) . split ( ) ) ) ans = [ '2' ] * int ( n ) for i in arth : ans [ i - 1 ] = '1' print ( \" ▁ \" . join ( ans ) ) NEW_LINE"],"bleu":0.47553349029510994,"rouge_l":0.6302489856812765}
{"id":361,"predictions":["t = int ( input ( ) ) NEW_LINE for i in range ( t ) : n , x = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE flag = True NEW_LINE for j in range ( n ) : if NEW_LINE INDENT if NEW_LINE DEDENT if ( a [ j ] + x ) > x : flag = False NEW_LINE break NEW_LINE DEDENT if ( flag ) : NEW_LINE INDENT print ( \" Yes \" ) else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["n = int ( input ( ) ) NEW_LINE for p in range ( n ) : n1 , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) [ : : - 1 ] NEW_LINE if p != n - 1 : z = input ( ) NEW_LINE for x in range ( n1 ) : if NEW_LINE a [ x ] + b [ x ] > k : print ( ' No ' ) NEW_LINE break else : print ( ' Yes ' ) NEW_LINE","import matht = int ( input ( ) ) NEW_LINE for i in range ( t ) :     NEW_LINE if i != 0 : input ( ) NEW_LINE n , x = list ( map ( int , input ( ) . split ( ) ) )   a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) )   l = [ ] NEW_LINE f = 0   for i in range ( int ( n ) ) :       l . append ( a [ i ] + b [ n - i - 1 ] )   for i in range ( len ( l ) ) :     NEW_LINE if l [ i ] > x : print ( \" No \" ) NEW_LINE f = 1 NEW_LINE break NEW_LINE if f == 0 : print ( \" Yes \" ) NEW_LINE","import sys   input = sys . stdin . buffer . readline   t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : n , x = map ( int , input ( ) . split ( ) ) NEW_LINE A = reversed ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE B = list ( map ( int , input ( ) . split ( ) ) )   ok = True NEW_LINE for a , b in zip ( A , B ) : if NEW_LINE a + b > x : ok = False NEW_LINE break   print ( \" Yes \" if ok else \" No \" )   if _ < t - 1 : input ( ) NEW_LINE"],"bleu":0.7409141089479828,"rouge_l":0.7235132015044874}
{"id":362,"predictions":["n = int ( input ( ) ) s = input ( ) ans = 0 for i in range ( n - 1 ) : if s [ i ] == ' ? ' : if s [ i + 1 ] == ' ? ' : if s [ i ] == ' ? ' : s [ i + 1 ] == ' ? ' : s [ i ] = s [ i + 1 ] else : s [ i + 1 ] = s [ i ] print ( ans ) NEW_LINE"],"references":["import ren = int ( input ( ) ) NEW_LINE ans , sumL = 1 , 0 NEW_LINE for s in re . split ( \" [ . ? ! ] \" , input ( ) ) : s = s . strip ( ) + ' . ' NEW_LINE L = len ( s ) NEW_LINE if L > 1 : if NEW_LINE L > n : print ( \" Impossible \" ) NEW_LINE exit ( ) NEW_LINE if sumL + L + ( sumL > 0 ) > n : ans += 1 NEW_LINE sumL = L else : sumL = sumL + L + ( sumL > 0 ) NEW_LINE print ( ans ) NEW_LINE","import sysn = int ( input ( ) ) NEW_LINE s = str ( input ( ) ) NEW_LINE m = len ( s ) NEW_LINE cnt = 0 NEW_LINE gd = Falseans = 0 l NEW_LINE st = 0 NEW_LINE end = [ ' . ' , ' ? ' , ' ! ' ] NEW_LINE rem = 0 NEW_LINE for i in range ( m ) : cnt += 1 NEW_LINE if ( s [ i ] in end ) : gd = True NEW_LINE lst = cnt NEW_LINE","import re   n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE l = re . split ( r \" \\ . | \\ ? | \\ ! \" , s ) NEW_LINE r = [ len ( x . strip ( ) ) + 1 for x in l if len ( x . strip ( ) ) > 0 ] NEW_LINE if max ( r ) > n : NEW_LINE INDENT print ( \" Impossible \" ) else : NEW_LINE cur = - 1 NEW_LINE DEDENT ans = 1 NEW_LINE for i in r : if NEW_LINE cur + i + 1 <= n : cur = cur + i + 1 else : ans = ans + 1 NEW_LINE cur = i NEW_LINE print ( ans ) NEW_LINE"],"bleu":0.298091405537335,"rouge_l":0.3978355519074979}
{"id":363,"predictions":["k , d , m = map ( int , input ( ) . split ( ) ) if k * 2 > k : print ( - 1 ) else : print ( ( k * ( k - 1 ) \/\/ 2 ) + 1 ) NEW_LINE"],"references":["k , d , t = map ( int , input ( ) . split ( ) ) d = ( ( k + d - 1 ) \/\/ d ) * dn = 2 * t \/\/ ( d + k ) x = 2 * t % ( d + k ) if ( x <= 2 * k ) : ans = x \/ 2 + d * nelse : ans = x - k + d * nprint ( ans ) NEW_LINE","import math   k , d , t = input ( ) . split ( ) k = float ( k ) d = float ( d ) t = float ( t ) itr = float ( k \/ d ) itr = math . ceil ( itr ) d = d * itr   cycle1 = float ( k \/ t ) cycle2 = float ( ( d - k ) \/ ( 2 * t ) ) timer = d cycle = cycle1 + cycle2itr = 1 \/ cycleitr = math . floor ( itr )   if itr * cycle == 1 : print ( d * itr ) exit ( ) timer = d * itr if itr * cycle + cycle1 >= 1 : left = 1 - itr * cycle print ( timer + left \/ ( 1.0 \/ t ) ) else : timer += k left = 1 - itr * cycle - cycle1 print ( timer + left \/ ( 1.0 \/ ( 2.0 * t ) ) ) NEW_LINE","k , d , t = list ( map ( int , input ( ) . split ( ) ) ) if k % d == 0 : print ( t ) exit ( ) m = ( k + d - 1 ) \/\/ d * dif 2 * t % ( m + k ) == 0 : print ( m * 2 * t \/ ( m + k ) ) exit ( ) n = 2 * t \/\/ ( m + k ) res = n * mf = 1 - ( m + k ) * n \/ ( 2 * t ) if f <= k \/ t : print ( res + f * t ) else : res += k f -= k \/ t print ( res + f * 2 * t ) NEW_LINE"],"bleu":0.2574851812139984,"rouge_l":0.47890088321884206}
{"id":364,"predictions":["n = int ( input ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : input ( ) . split ( ) NEW_LINE l . append ( [ int ( i ) for i in l [ 1 : ] ] ) NEW_LINE print ( max ( l ) ) NEW_LINE"],"references":["n = int ( input ( ) ) NEW_LINE r = lambda : list ( map ( str , input ( ) . split ( ) ) ) NEW_LINE ans = - float ( ' inf ' ) NEW_LINE winner = \" xx \" NEW_LINE for _ in range ( n ) : name , * score = r ( ) NEW_LINE point = 0 NEW_LINE for i in score [ 2 : ] : point += int ( i )     NEW_LINE","n = int ( input ( ) ) NEW_LINE names = [ ] NEW_LINE points = [ ] NEW_LINE for _ in range ( n ) : a = input ( ) . split ( ) NEW_LINE names . append ( a [ 0 ] ) NEW_LINE b = [ int ( i ) for i in a [ 1 : ] ] NEW_LINE point = 50 * ( 2 * b [ 0 ] - b [ 1 ] ) NEW_LINE for i in range ( 5 ) : point += b [ i + 2 ] NEW_LINE points . append ( point ) NEW_LINE max_point = points [ 0 ] NEW_LINE max_name = names [ 0 ] NEW_LINE for i in range ( n ) : if NEW_LINE max_point < points [ i ] : max_point = points [ i ] NEW_LINE max_name = names [ i ] NEW_LINE print ( max_name ) NEW_LINE","n = int ( input ( ) ) NEW_LINE ans = ' ' NEW_LINE mx = - 10 ** 100 NEW_LINE for i in range ( n ) : k = input ( ) . split ( ) NEW_LINE score = int ( k [ 1 ] ) * 100 - int ( k [ 2 ] ) * 50 + int ( k [ 3 ] ) + int ( k [ 4 ] ) + int ( k [ 5 ] ) + int ( k [ 6 ] ) + int ( k [ 7 ] ) NEW_LINE if score > mx : mx = score NEW_LINE ans = k [ 0 ] NEW_LINE print ( ans ) NEW_LINE"],"bleu":0.4606107327314665,"rouge_l":0.4842047656822678}
{"id":365,"predictions":["n = int ( input ( ) ) if n < 3 : print ( \" No \" ) else : print ( \" Yes \" ) print ( 1 , n ) print ( n - 1 , end = \" ▁ \" ) for i in range ( 1 , n ) : print ( i , end = \" ▁ \" ) NEW_LINE"],"references":["def prime ( n ) : c = 0 for i in range ( 2 , int ( pow ( n , 0.5 ) ) + 1 ) : if ( n % i == 0 ) : c = 1 break return c       n = int ( input ( ) ) if ( n == 1 ) : print ( 3 ) elif ( n == 2 ) : print ( 4 ) else : for i in range ( 1 , n + 1 ) : c1 = prime ( n * i + 1 ) if ( c1 == 1 ) : break print ( i ) NEW_LINE","n = int ( input ( ) ) print ( 7 if n < 3 else n - 2 ) NEW_LINE","n = int ( input ( ) ) if n == 1 : print ( 8 ) elif n == 2 : print ( 4 ) else : print ( n - 2 ) NEW_LINE"],"bleu":0.4645600365976139,"rouge_l":0.6848916497090429}
{"id":366,"predictions":["import sys NEW_LINE input = sys . stdin . readline NEW_LINE H , W = map ( int , input ( ) . split ( ) ) NEW_LINE flag = False NEW_LINE for i in range ( H ) : NEW_LINE INDENT for j in range ( W ) : NEW_LINE INDENT if i % j == 0 : NEW_LINE INDENT flag = True NEW_LINE break NEW_LINE DEDENT DEDENT if flag : NEW_LINE INDENT if not flag : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT DEDENT print ( \" No \" ) NEW_LINE"],"references":["import mathh , w = map ( int , input ( ) . split ( ) ) NEW_LINE if h \/ w >= 0.8 and h \/ w <= 1.25 and ( ( math . log ( h , 2 ) % 1 == 0 ) or ( math . log ( w , 2 ) % 1 == 0 ) ) : NEW_LINE INDENT print ( h , w ) else : NEW_LINE w1 = 2 ** ( math . log ( w , 2 ) \/\/ 1 ) NEW_LINE DEDENT h1 = min ( h , ( w1 * 1.25 ) \/\/ 1 ) NEW_LINE h2 = 2 ** ( math . log ( h , 2 ) \/\/ 1 ) NEW_LINE w2 = min ( w , ( h2 * 1.25 ) \/\/ 1 ) NEW_LINE if ( h1 \/ w1 >= 0.8 and h1 \/ w1 <= 1.25 ) and ( h2 \/ w2 >= 0.8 and h2 \/ w2 <= 1.25 ) : if NEW_LINE h1 >= h2 and h1 * w1 >= h2 * w2 : print ( int ( h1 ) , int ( w1 ) ) else : print ( int ( h2 ) , int ( w2 ) ) elif ( h1 \/ w1 >= 0.8 and h1 \/ w1 <= 1.25 ) : print ( int ( h1 ) , int ( w1 ) ) else : print ( int ( h2 ) , int ( w2 ) ) NEW_LINE","from math import floordef NEW_LINE pic ( x , y ) : NEW_LINE","import sysimport NEW_LINE mathdef NEW_LINE input ( ) : NEW_LINE return sys . stdin . readline ( ) . strip ( ) NEW_LINE def iinput ( ) : return int ( input ( ) ) NEW_LINE def minput ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE def listinput ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE h , w = minput ( ) NEW_LINE x = 2 ** int ( math . log2 ( h ) ) NEW_LINE y = 2 ** int ( math . log2 ( w ) ) NEW_LINE if x > y : NEW_LINE INDENT x = int ( min ( x , y * 1.25 ) ) else : NEW_LINE y = int ( min ( y , x * 1.25 ) ) NEW_LINE DEDENT x1 , y1 = min ( int ( y * 1.25 ) , h ) , min ( int ( x * 1.25 ) , w ) NEW_LINE if x * y1 > y * x1 : NEW_LINE INDENT print ( x , y1 ) else : NEW_LINE print ( x1 , y ) NEW_LINE DEDENT"],"bleu":0.3131388031722049,"rouge_l":0.5285282426031277}
{"id":367,"predictions":["import mathn = int ( input ( ) ) nn = int ( math . sqrt ( n ) ) base = 2 * nnb2 = ( n - ( nn * nn ) ) b2 = math . ceil ( b2 \/ nn ) print ( base + b2 ) NEW_LINE"],"references":["n , k = map ( int , input ( ) . split ( ) ) if n < k : print ( k + n ) else : ans = [ ] ; i = 1 while i * i <= n : if n % i == 0 and n % ( n \/\/ i ) == 0 : ans . append ( [ i , n \/\/ i ] ) i += 1 ans1 = [ ] for j in ans : if k > j [ 0 ] : ans1 . append ( k * j [ 1 ] + j [ 0 ] ) if k > j [ 1 ] : ans1 . append ( k * j [ 0 ] + j [ 1 ] ) print ( min ( ans1 ) ) NEW_LINE","n , k = map ( int , input ( ) . split ( ) ) mn = 10 ** 9 for i in range ( 1 , k ) : if n % i == 0 : mn = min ( mn , n \/\/ i * k + i ) print ( mn ) NEW_LINE","import math   n , k = map ( int , input ( ) . split ( ) )   mn = 10 ** 12 for i in range ( 1 , int ( n ** 0.5 ) + 3 ) : if n % i == 0 : x1 = i * k + n \/\/ i x2 = k * ( n \/\/ i ) + i if x1 \/\/ k * ( x1 % k ) == n : mn = min ( mn , x1 ) if x2 \/\/ k * ( x2 % k ) == n : mn = min ( mn , x2 ) print ( mn ) NEW_LINE"],"bleu":0.1137422987904241,"rouge_l":0.395004625346901}
{"id":368,"predictions":["from math import ceilfor NEW_LINE ad in range ( int ( input ( ) ) ) : NEW_LINE"],"references":["import sys , mathfrom collections import defaultdict , dequeinput = sys . stdin . readline   n = int ( input ( ) ) c = 0 for i in range ( 1 , n + 1 ) : for j in range ( i + 1 , n + 1 ) : k = i ^ j if ( i < j < k <= n and i + j > k and j + k > i and i + k > j ) : NEW_LINE","n = int ( input ( ) ) res = 0 for a in range ( 1 , n ) : for b in range ( a + 1 , n + 1 ) : c = a ^ b if c >= b and c <= n and ( a + b > c ) and ( a + c > b ) and ( b + c > a ) and ( a ^ b ^ c == 0 ) : res += 1 print ( res ) NEW_LINE","n = int ( input ( ) ) count = 0 for i in range ( 1 , n + 1 ) : for j in range ( i , n + 1 ) : temp = i ^ j if temp < j or temp > n or i + j <= temp : continue count += 1 print ( count ) NEW_LINE"],"bleu":0.03518107358592381,"rouge_l":0.2026578073089701}
{"id":369,"predictions":["n , s = map ( int , input ( ) . rstrip ( ) . split ( \" ▁ \" ) ) if s == 0 or n == 1 : print ( 0 ) elif s >= n \/\/ 2 : print ( ( n - 1 ) * ( n ) \/\/ 2 ) else : t = 0 for i in range ( s ) : t += ( n - 1 - i ) for i in range ( s , n - s ) : t += s for i in range ( s ) : t += i print ( t ) NEW_LINE"],"references":["from math import sqrtn , v1 , v2 = list ( map ( int , input ( ) . split ( ) ) ) a = list ( map ( int , input ( ) . split ( ) ) ) x , y = list ( map ( int , input ( ) . split ( ) ) ) b = [ ] c = [ ] d = [ ] for i in range ( n ) : b . append ( sqrt ( ( x - a [ i ] ) ** 2 + y ** 2 ) ) d . append ( a [ i ] \/ v1 + b [ i ] \/ v2 ) e = sorted ( d [ 1 : ] ) [ 0 ] f = [ ] for i in range ( n ) : if d [ i ] == e : f . append ( i ) g = 0 h = - 1 for i in f : if h == - 1 or b [ i ] < h : h = b [ i ] g = i + 1 print ( g ) NEW_LINE","n , vb , vs = map ( int , input ( ) . split ( ) ) A = list ( map ( int , input ( ) . split ( ) ) ) xu , yu = map ( int , input ( ) . split ( ) ) time = A [ - 1 ] \/ vb + ( ( yu * yu + ( xu - A [ - 1 ] ) ** 2 ) ** ( 1 \/ 2 ) ) \/ vsp = n NEW_LINE","n , vb , vs = map ( int , input ( ) . split ( ) ) A = list ( map ( int , input ( ) . split ( ) ) ) xu , yu = map ( int , input ( ) . split ( ) ) time = A [ - 1 ] \/ vb + ( ( yu * yu + ( xu - A [ - 1 ] ) ** 2 ) ** ( 1 \/ 2 ) ) \/ vsp = nfor i in range ( 1 , len ( A ) - 1 ) : time1 = A [ i ] \/ vb + ( ( yu * yu + ( xu - A [ i ] ) ** 2 ) ** ( 1 \/ 2 ) ) \/ vs if time1 < time : time = time1 p = i + 1 elif time1 == time : dist1 = ( xu - A [ p - 1 ] ) ** 2 dist2 = ( xu - A [ i ] ) ** 2 if dist2 < dist1 : p = i + 1 print ( p ) NEW_LINE"],"bleu":0.27408830563966124,"rouge_l":0.42691139574805226}
{"id":370,"predictions":["from sys import stdin , stdoutstdin . readlinedef NEW_LINE mp ( ) : NEW_LINE return list ( map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) ) NEW_LINE def it ( ) : return int ( stdin . readline ( ) . strip ( ) ) NEW_LINE from collections import defaultdict as dd , Counter as C   NEW_LINE def pf ( n ) : v = [ ] NEW_LINE d = dd ( lambda : 0 ) NEW_LINE while n % 2 == 0 : d [ 2 ] += 1 NEW_LINE n \/\/= 2 NEW_LINE i = 3 NEW_LINE while i * i <= n : if NEW_LINE n % i == 0 : d [ i ] += 1 NEW_LINE n \/\/= i else : i += 1 NEW_LINE if n > 2 : d [ n ] += 1 NEW_LINE return dict ( d )   for _ in range ( it ( ) ) : solve ( ) NEW_LINE"],"references":["t = int ( input ( ) ) for i in range ( t ) : s = input ( ) c1 = c2 = c3 = x = y = z = 0 ans = 200000 i = 0 f = False while i < len ( s ) : if s [ i ] == '1' : c1 += 1 x = i elif s [ i ] == '2' : c2 += 1 y = i elif s [ i ] == '3' : c3 += 1 z = i                                     if c1 >= 1 and c2 >= 1 and c3 >= 1 : f = True p = max ( x , y , z ) - min ( x , y , z ) + 1 ans = min ( ans , p ) c1 = c2 = c3 = x = y = z = 0 i = i - 2 i += 1 if f == False : print ( 0 ) else : print ( ans ) NEW_LINE","import sys   def answer ( s ) : c1 = s . count ( '1' ) c2 = s . count ( '2' ) c3 = s . count ( '3' ) if c1 == 0 or c2 == 0 or c3 == 0 : return 0 NEW_LINE","def sol ( s ) : if s == \"123\" or s == \"213\" or s == \"312\" or s == \"132\" or s == \"231\" or s == \"321\" : return 3 ans = float ( ' inf ' ) n = len ( s ) a = b = c = - 1 for i in range ( n ) : if s [ i ] == '1' : a = i if s [ i ] == '2' : b = i if s [ i ] == '3' : c = i if a >= 0 and b >= 0 and c >= 0 : x = min ( a , b , c ) y = max ( a , b , c ) ans = min ( ans , y - x + 1 ) if ans == float ( ' inf ' ) : return 0 return ans                                         def main ( ) : T = int ( input ( ) ) while T is not 0 : s = input ( ) print ( sol ( s ) ) T -= 1 if __name__ == \" _ _ main _ _ \" : main ( ) NEW_LINE"],"bleu":0.09696177764957355,"rouge_l":0.3304775103943555}
{"id":371,"predictions":["n = int ( input ( ) ) arr = sorted ( map ( int , input ( ) . split ( ) ) )   print ( arr [ n \/\/ 2 ] ) NEW_LINE"],"references":["s = str ( input ( ) ) a = s . find ( ' a ' ) b = s . find ( ' b ' ) c = s . find ( ' c ' ) if ( ' a ' in s ) and ( ' b ' in s ) and ( ' b ' in s ) and ( a < b < c ) and ( ' ba ' not in s ) and ( ' ca ' not in s ) and ( ' cb ' not in s ) : if s . count ( ' a ' ) == s . count ( ' c ' ) or s . count ( ' b ' ) == s . count ( ' c ' ) : print ( \" YES \" ) else : print ( \" NO \" ) else : print ( \" NO \" ) NEW_LINE","if __name__ == ' _ _ main _ _ ' : cin = input s = list ( cin ( ) ) a = [ 0 ] * 3 if len ( set ( s ) ) < 3 or s != sorted ( s ) : print ( \" NO \" ) else : for c in s : a [ \" abc \" . index ( c ) ] += 1 print ( \" YNEOS \" [ not ( a [ 0 ] == a [ 2 ] or a [ 1 ] == a [ 2 ] ) : : 2 ] ) NEW_LINE","x = str ( input ( ) ) ca = x . count ( ' a ' ) cb = x . count ( ' b ' ) cc = x . count ( ' c ' ) if ca == 0 or cb == 0 : print ( ' NO ' ) elif ca * ' a ' + cb * \" b \" + cc * \" c \" == x and ( cc == ca or cc == cb ) : print ( ' YES ' ) else : print ( ' NO ' ) NEW_LINE"],"bleu":0.04199104204563781,"rouge_l":0.2622765331522969}
{"id":372,"predictions":["n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l . sort ( ) s = sum ( l ) if ( s % 2 == 0 ) : print ( 0 ) else : print ( s ) NEW_LINE"],"references":["dontcare = input ( ) NEW_LINE a = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE sum = 0 NEW_LINE for i in a : sum += iif NEW_LINE sum % 2 == 1 : print ( sum ) else : max = sum NEW_LINE for i in a : if NEW_LINE i % 2 == 1 : max -= i NEW_LINE break NEW_LINE for i in a : if NEW_LINE i % 2 == 1 and sum - i > max : max = sum - i NEW_LINE if max % 2 == 1 : NEW_LINE INDENT print ( max ) else : NEW_LINE print ( 0 ) NEW_LINE DEDENT","n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE e = [ ] NEW_LINE o = [ ] NEW_LINE for p in l : if NEW_LINE p % 2 == 0 : e . append ( p ) else : o . append ( p ) NEW_LINE ans = sum ( e ) NEW_LINE o . sort ( ) NEW_LINE if len ( o ) % 2 == 0 : NEW_LINE INDENT ans += sum ( o [ 1 : ] ) else : NEW_LINE ans += sum ( o ) NEW_LINE DEDENT if ans % 2 == 0 : NEW_LINE INDENT print ( 0 ) else : NEW_LINE print ( ans ) NEW_LINE DEDENT","n = int ( input ( ) ) NEW_LINE b = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE odd = list ( filter ( lambda x : x % 2 == 1 , b ) )   if sum ( b ) % 2 == 1 : NEW_LINE INDENT print ( sum ( b ) ) else : NEW_LINE print ( sum ( b ) - min ( odd ) if odd else 0 ) NEW_LINE DEDENT"],"bleu":0.38297889095330373,"rouge_l":0.5216497709982177}
{"id":373,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = [ input ( ) for i in range ( n ) ] blocks = 0 for i in range ( m ) : for j in range ( n ) : if a [ i ] [ j ] == ' * ' : if ( b [ i ] [ j ] == ' S ' ) and ( a [ i ] [ j ] == ' S ' ) and ( a [ i ] [ j ] == ' S ' ) : a [ i ] [ j ] = ' x ' if ( a [ i ] [ j ] == ' S ' ) : if ( a [ i ] [ j ] == ' * ' ) : if ( b [ i ] [ j ] == ' S ' ) : a [ i ] [ j ] = ' x ' if ( a [ i ] [ j ] == ' S ' ) : b [ i ] [ j ] = ' S ' else : a [ i ] [ j ] = ' T ' ans = 0 for i in range ( n ) : for j in range ( m ) : if ( a [ i ] [ j ] == ' S ' ) : if ( a [ i ] [ j ] == ' S ' ) : if ( a [ i ] [ j ] == ' S ' ) : b [ i ] [ j ] = ' S ' if ( a [ i ] [ j ] == ' S ' ) : b [ i ] [ j ] = ' S ' if ( a [ i ] [ j ] == ' S ' ) : b [ i ] [ j ] = ' T ' else : if ( b [ i ] [ j ] == ' P ' ) : if ( a [ i ] [ j ] == ' S ' ) : a [ i ] [ j ] = ' S ' print ( ' ' . join ( map ( str , a ) ) ) ) else : ' Impossible ' ) NEW_LINE"],"references":["from sys import stdin   input = stdin . readlinek , n = map ( int , input ( ) . split ( ) ) NEW_LINE a = input ( ) NEW_LINE b = input ( ) NEW_LINE dp = [ [ 0 for i in range ( n + 1 ) ] for __ in range ( k + 1 ) ] NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , k + 1 ) : for NEW_LINE j in range ( 1 , n + 1 ) : NEW_LINE if a [ i - 1 ] == b [ j - 1 ] : dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j - 1 ] + 2 ) NEW_LINE ans = max ( ans , dp [ i ] [ j ] ) else : dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) - 1 NEW_LINE dp [ i ] [ j ] = max ( 0 , dp [ i ] [ j ] ) NEW_LINE print ( ans ) NEW_LINE","from sys import stdin   input = stdin . readlinek , n = map ( int , input ( ) . split ( ) ) NEW_LINE a = input ( ) NEW_LINE b = input ( ) NEW_LINE dp = [ [ 0 for i in range ( n + 1 ) ] for __ in range ( k + 1 ) ] NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , k + 1 ) : for NEW_LINE j in range ( 1 , n + 1 ) : NEW_LINE if a [ i - 1 ] == b [ j - 1 ] : dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j - 1 ] + 2 ) NEW_LINE ans = max ( ans , dp [ i ] [ j ] ) else : dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) - 1 NEW_LINE dp [ i ] [ j ] = max ( 0 , dp [ i ] [ j ] ) NEW_LINE print ( ans ) NEW_LINE"],"bleu":0.19204343035524957,"rouge_l":0.4359088878963823}
{"id":374,"predictions":["from sys import stdin , stdoutfrom os import pathrd = lambda : stdin . readline ( ) . strip ( ) wr = stdout . writeif ( path . exists ( ' input . txt ' ) ) : stdin = open ( \" input . txt \" , \" r \" ) import time NEW_LINE"],"references":["def test ( i ) : aa = input ( ) . split ( ' ▁ ' ) ar = [ ] for j in aa : ar . append ( int ( j ) ) ark = [ ] for jj in ar : while jj in ark : if jj <= 0 : break jj -= 1 ark . append ( jj ) count = 0 for n in ark : count += n if len ( ark ) == i : print ( count ) i = int ( input ( ) ) if i <= 26 and i >= 2 : test ( i ) NEW_LINE","num = int ( input ( ) ) arr = sorted ( map ( int , input ( ) . split ( ) ) , reverse = True )   ans = 0   seen = set ( )   for num in arr : if num in seen : while num in seen and num > 0 : num -= 1 ans += num seen . add ( num ) else : ans += num seen . add ( num )   print ( ans ) NEW_LINE","n = input ( ) a = [ int ( each ) for each in input ( ) . split ( ) ] a . sort ( reverse = True ) len0 = len ( a ) res = a [ 0 ] for i in range ( 1 , len0 ) : if a [ i ] > a [ i - 1 ] - 1 : a [ i ] = a [ i - 1 ] - 1 if a [ i ] == 0 : break res += a [ i ] print ( res )     NEW_LINE"],"bleu":0.04936524067433392,"rouge_l":0.22452537776055792}
{"id":375,"predictions":["t = int ( input ( ) ) while t > 0 : t -= 1 s , d = [ int ( x ) for x in input ( ) . split ( ) ] print ( ( s - d ) ) NEW_LINE"],"references":["t = int ( input ( ) ) while ( t ) : a , b = map ( int , input ( ) . split ( ) ) if ( a % b == 0 ) : print ( '0' ) else : print ( b - ( a % b ) ) t -= 1 NEW_LINE","n = int ( input ( ) ) ; for i in range ( 0 , n ) : r , s = input ( ) . split ( ) ; r = int ( r ) ; s = int ( s ) ; if ( r % s == 0 ) : print ( \"0\" ) ; else : print ( s - ( r % s ) ) ; NEW_LINE","t = int ( input ( ) ) for x in range ( t ) : a , b = map ( int , input ( ) . split ( ) ) if a % b != 0 : print ( b - a % b ) else : print ( 0 ) NEW_LINE"],"bleu":0.3987325727751865,"rouge_l":0.5315904139433552}
{"id":376,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) print ( ( ' Yes ' , ' No ' ) [ any ( [ ( a [ i ] - ( - 1 ) ** i * a [ 0 ] ) % n != i for i in range ( n ) ] ) ] ) NEW_LINE"],"references":["nr_threads = int ( input ( ) ) old_position = list ( map ( int , input ( ) . split ( ) ) ) ans = nr_threads - 1   if ( nr_threads == 1 ) : print ( 0 ) quit ( )   i = ans     while ( i > 0 ) : if ( old_position [ i - 1 ] > old_position [ i ] ) : print ( ans ) quit ( ) else : i -= 1 ans -= 1   print ( ans ) NEW_LINE","n = int ( input ( ) ) pos = ( list ( map ( int , input ( ) . split ( ) ) ) ) last = - 1 for i in range ( n - 1 ) : if ( pos [ i ] > pos [ i + 1 ] ) : last = iprint ( last + 1 ) NEW_LINE","n = int ( input ( ) ) aux = input ( ) . split ( ) first = int ( aux [ 0 ] ) flag = 1 for i in range ( 1 , n ) : if int ( aux [ i ] ) < first : flag = 1 else : flag += 1 first = int ( aux [ i ] ) print ( n - flag ) NEW_LINE"],"bleu":0.486999090715271,"rouge_l":0.5716915303176131}
{"id":377,"predictions":["from sys import stdin , stdoutfrom collections import Counternmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["import sysdef get_ints ( ) : return list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) li1 = get_ints ( ) li2 = get_ints ( ) if li2 [ 0 ] - li1 [ 0 ] >= 0 : li2 [ 0 ] -= li1 [ 0 ] summ = sum ( li2 ) if sum ( li2 [ : 2 ] ) >= li1 [ 1 ] : if summ - ( li1 [ 1 ] ) >= li1 [ 2 ] : print ( ' yes ' ) else : print ( ' No ' ) else : print ( ' no ' ) else : print ( ' NO ' )       NEW_LINE","def str_list ( s , char ) : output_list = [ ] collector = \" \" for i in range ( len ( s ) ) : if s [ i ] == char : if collector : output_list . append ( int ( collector ) ) collector = \" \" else : collector += s [ i ] output_list . append ( int ( collector ) ) return output_list     def str_list_with_str ( s , char ) : output_list = [ ] collector = \" \" for i in range ( len ( s ) ) : if s [ i ] == char : if collector : output_list . append ( collector ) collector = \" \" else : collector += s [ i ] output_list . append ( collector ) return output_list   def list_str ( l , char ) : output_str = \" \" for i in range ( len ( l ) - 1 ) : output_str += str ( l [ i ] ) + char output_str += str ( l [ len ( l ) - 1 ] ) return output_str   def find_max ( l , i , current_max ) : if i == len ( l ) : return current_max else : if current_max < l [ i ] : current_max = l [ i ] return find_max ( l , i + 1 , current_max )       def main_function ( ) : x , y , z = str_list ( input ( ) , \" ▁ \" ) a , b , c = str_list ( input ( ) , \" ▁ \" ) if a >= x and ( a - x ) + b >= y and a + b + c - x - y >= z : return \" YES \" return \" NO \"     print ( main_function ( ) )   NEW_LINE","R = lambda : map ( int , input ( ) . split ( ) ) x , y , z = R ( ) a , b , c = R ( ) print ( ' YNEOS ' [ a < x or a - x + b < y or a - x + b - y + c < z : : 2 ] ) NEW_LINE"],"bleu":0.29368466109317753,"rouge_l":0.34456825739390873}
{"id":378,"predictions":["from sys import stdin , stdoutstdin . readlinedef mp ( ) : return list ( map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) def it ( ) : return int ( stdin . readline ( ) . strip ( ) ) from math import ceilfrom collections import defaultdict as ddfrom collections import Counter as Cn = it ( ) l = list ( mp ( ) ) NEW_LINE"],"references":["h , w = map ( int , input ( ) . split ( ) ) r = list ( map ( int , input ( ) . split ( ) ) ) c = list ( map ( int , input ( ) . split ( ) ) ) mod = 1000000007 grid = [ [ \" ? \" for i in range ( w + 1 ) ] for j in range ( h + 1 ) ] def try_set ( row , col , target ) : if grid [ row ] [ col ] == \" ? \" : grid [ row ] [ col ] = target elif grid [ row ] [ col ] != target : raise ValueErrordef go ( ) : try : for row in range ( h ) : for col in range ( r [ row ] ) : try_set ( row , col , \" FULL \" ) try_set ( row , r [ row ] , \" EMPTY \" ) for col in range ( w ) : for row in range ( c [ col ] ) : try_set ( row , col , \" FULL \" ) try_set ( c [ col ] , col , \" EMPTY \" ) except ValueError : return 0 answer = 1 for i in range ( h ) : for j in range ( w ) : if grid [ i ] [ j ] == \" ? \" : answer = answer * 2 % mod return answerprint ( go ( ) ) NEW_LINE","M = ( 10 ** 9 ) + 7 h , w = map ( int , input ( ) . split ( ) ) r = list ( map ( int , input ( ) . split ( ) ) ) c = list ( map ( int , input ( ) . split ( ) ) ) ans = 1 mat = [ ] for i in range ( h + 1 ) : o = [ 0 ] * ( w + 1 ) mat . append ( o )   for row in range ( h ) : col = r [ row ] for x in range ( col ) : if mat [ row ] [ x ] == 0 : mat [ row ] [ x ] = 1   mat [ row ] [ col ] = 2   NEW_LINE","from sys import stdin , stdoutinput = stdin . readline def main ( ) : NEW_LINE"],"bleu":0.32622486290055214,"rouge_l":0.6468189233278956}
{"id":379,"predictions":["import sys , os , ioimport math , bisect , operatorinf , mod = float ( ' inf ' ) , 10 ** 9 + 7 NEW_LINE"],"references":["from sys import stdin , stdoutfrom os import pathrd = lambda : stdin . readline ( ) . strip ( ) wr = stdout . writeif ( path . exists ( ' input . txt ' ) ) : stdin = open ( \" input . txt \" , \" r \" ) import time , math NEW_LINE","from collections import Countern , k = map ( int , input ( ) . split ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) t = [ arr [ i ] - k * i for i in range ( n ) ] d = Counter ( t ) cnt = 0 for key , val in d . items ( ) : if key <= 0 : continue if val > cnt : cnt = val best = keyprint ( n - cnt )   for i in range ( n ) : x = arr [ i ] - k * i - best if x < 0 : print ( \" { } ▁ { } ▁ { } \" . format ( \" + \" , i + 1 , - x ) ) if x > 0 : print ( \" { } ▁ { } ▁ { } \" . format ( \" - \" , i + 1 , x ) )     NEW_LINE","n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) vis = [ False ] * nanswer = 0 for i in range ( n ) : t = 0 if not vis [ i ] : for j in range ( i , n ) : if not vis [ j ] : temp = a [ j ] - ( ( j - i ) * k ) x = temp - a [ i ] if x == 0 : t += 1 vis [ j ] = True if temp <= 0 : vis [ j ] = True if t > answer : answer = t poi = i val = a [ i ] print ( n - answer ) if answer != n : for i in range ( n ) : x = a [ i ] - val - ( ( i - poi ) * k ) if x == 0 : continue elif x > 0 : print ( ' { } ▁ { } ▁ { } ' . format ( ' - ' , i + 1 , x ) ) elif x < 0 : print ( ' { } ▁ { } ▁ { } ' . format ( ' + ' , i + 1 , - x ) ) NEW_LINE"],"bleu":0.03247919425960997,"rouge_l":0.23014525561214866}
{"id":380,"predictions":["for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) ; print ( len ( set ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE"],"references":["t = int ( input ( ) ) for i in range ( t ) : n = int ( input ( ) ) arr = map ( int , input ( ) . split ( ) ) arr = set ( arr ) print ( len ( arr ) ) NEW_LINE","from sys import stdininput = stdin . readline   t = int ( input ( ) ) for _ in range ( t ) : n = int ( input ( ) ) a = [ int ( x ) for x in input ( ) . split ( ) ] ans = len ( set ( a ) ) print ( ans ) NEW_LINE","for i in range ( int ( input ( ) ) ) : a = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) print ( len ( set ( l ) ) ) NEW_LINE"],"bleu":0.7894046174353488,"rouge_l":0.7520253610426206}
{"id":381,"predictions":["from sys import stdin , stdoutstdin . readlinedef mp ( ) : return list ( map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) ) def it ( ) : return int ( stdin . readline ( ) . strip ( ) ) from math import ceilfrom collections import defaultdict as ddfrom collections import Counter as Cn = it ( ) l = sorted ( mp ( ) ) NEW_LINE"],"references":["l , r = map ( int , input ( ) . split ( ) ) def f ( n ) : NEW_LINE","l , r = list ( map ( int , input ( ) . split ( ) ) )   def cnt ( x ) : ret = 0 for i in range ( 1 , x + 1 ) : s = str ( i ) if s [ 0 ] == s [ - 1 ] : ret += 1 NEW_LINE","n = input ( ) . split ( ) l = int ( n [ 0 ] ) r = int ( n [ 1 ] )   s = 0 if l == 235 and r == 236 : print ( 0 ) exit ( ) if r == l and str ( r ) [ 0 ] == str ( r ) [ len ( str ( r ) ) - 1 ] : print ( 1 ) exit ( ) if r == l : print ( 0 ) exit ( ) if r <= 100 : for i in range ( l , r + 1 ) : i = str ( i ) if i [ 0 ] == i [ len ( i ) - 1 ] : s += 1 print ( s ) exit ( ) if l >= 100 : s1 = ( l - 100 ) \/\/ 10 s2 = ( r - 100 ) \/\/ 10 r2 = str ( r ) l2 = str ( l ) if r2 [ 0 ] <= r2 [ len ( r2 ) - 1 ] : print ( s2 - s1 + 1 ) exit ( ) elif l2 [ 0 ] < l2 [ len ( l2 ) - 1 ] : print ( s2 - s1 - 1 ) exit ( ) print ( s2 - s1 ) ''' if ▁ str ( l ) [0 ] = = str ( l ) [ len ( str ( l ) ) - 1 ] : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( ( r - l ) \/ \/ 10 + 1 ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ exit ( ) ▁ ▁ ▁ ▁ print ( int ( ( r - l ) \/10 ) ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ exit ( ) ''' if r > 100 and l < 100 : for i in range ( l , 100 ) : i = str ( i ) if i [ 0 ] == i [ len ( i ) - 1 ] : s += 1 if str ( r ) [ 0 ] < str ( r ) [ len ( str ( r ) ) - 1 ] : print ( s + ( ( r - 100 ) \/\/ 10 ) + 1 ) exit ( ) print ( s + ( ( r - 100 ) \/\/ 10 ) ) NEW_LINE"],"bleu":0.2697473622532029,"rouge_l":0.5711925089507023}
{"id":382,"predictions":["I = input NEW_LINE exec ( int ( I ( ) ) * \" input ( ) NEW_LINE for _ in range ( int ( I ( ) ) ) : NEW_LINE INDENT s = input ( ) NEW_LINE c = 0 NEW_LINE for x in s : NEW_LINE INDENT if x == ' U ' : NEW_LINE INDENT c += 1 NEW_LINE DEDENT elif x == ' D ' : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE DEDENT"],"references":["for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , m = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( input ( ) . strip ( ) ) NEW_LINE DEDENT x = 0 NEW_LINE for i in a [ - 1 ] : NEW_LINE INDENT x += int ( i == ' D ' ) NEW_LINE DEDENT for i in a : NEW_LINE INDENT x += int ( i [ - 1 ] == ' R ' ) NEW_LINE DEDENT print ( x ) NEW_LINE DEDENT","t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE table = [ input ( ) for i in range ( n ) ] NEW_LINE ans = 0 NEW_LINE for x in range ( n ) : NEW_LINE INDENT for y in range ( m ) : NEW_LINE INDENT if table [ x ] [ y ] == \" D \" and x + 1 == n : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT elif table [ x ] [ y ] == \" R \" and y + 1 == m : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT","t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE f = 0 NEW_LINE s = 0 NEW_LINE new = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT new . append ( input ( ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if j == m - 1 : NEW_LINE INDENT if new [ i ] [ j ] == \" R \" : NEW_LINE INDENT f += 1 NEW_LINE DEDENT DEDENT if i == n - 1 : NEW_LINE INDENT if new [ i ] [ j ] == \" D \" : NEW_LINE INDENT f += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( f ) NEW_LINE DEDENT"],"bleu":0.318847349552172,"rouge_l":0.5065139584824624}
{"id":383,"predictions":["n , k = map ( int , input ( ) . split ( ) ) s = input ( ) ans = \" abcdefghijklmnopqrstuvwxyz \" for i in range ( n ) : for j in range ( k ) : s [ j ] = s [ j ] + s [ i ]   return s if ans > k : print ( s + \" abcdefghijklmnopqrstuvwxyz \" ) else : print ( s )   NEW_LINE"],"references":["import sysfrom string import ascii_lowercase as az   def main ( ) : n , k = map ( int , sys . stdin . read ( ) . strip ( ) . split ( ) ) return n \/\/ k * az [ : k ] + az [ : n % k ]   print ( main ( ) ) NEW_LINE","m , n = map ( int , input ( ) . split ( ) ) print ( ( \" abcdefghijklmnopqrstuvwxyz \" [ : n ] * m ) [ : m ] )     NEW_LINE","n , k = map ( int , input ( ) . split ( ) )   alphabet = \" abcdefghijklmnopqrstuvwxyz \"   rep = ' '   seq = alphabet [ : k ]   for i in range ( n ) : rep += seq [ i % k ]   print ( rep ) NEW_LINE"],"bleu":0.37498671306164993,"rouge_l":0.5604786017641294}
{"id":384,"predictions":["import math , sys , bisect , heapq , osfrom collections import defaultdict , Counter , dequefrom itertools import groupby , accumulatefrom functools import lru_cache NEW_LINE"],"references":["from itertools import repeatfrom math import floor , ceildef fill ( s , a1 , a2 , a3 , a4 , c4 , c7 ) : if a1 < c4 or a2 < c7 : return None f = s . index ( '4' ) sv = s . rindex ( '7' ) s = ' ' . join ( [ s [ : f ] , '4' * ( a1 - c4 ) , s [ f : sv ] , '7' * ( a2 - c7 ) , s [ sv : ] ] ) return sa1 , a2 , a3 , a4 = [ int ( x ) for x in input ( ) . split ( ) ] if abs ( a3 - a4 ) > 1 : print ( - 1 ) else : s = ' ' if a3 > a1 or a3 > a2 or a4 > a1 or a4 > a2 : print ( - 1 ) exit ( 0 ) c4 = 0 c7 = 0 if a3 > a4 : s = ' ' . join ( repeat ( '47' , a3 ) ) c4 = int ( len ( s ) \/ 2 ) c7 = len ( s ) - c4 s = fill ( s , a1 , a2 , a3 , a4 , c4 , c7 ) if s : print ( s ) else : print ( - 1 ) elif a3 < a4 : s = ' ' . join ( repeat ( '74' , a4 ) ) c7 = int ( len ( s ) \/ 2 ) c4 = len ( s ) - c7 s = fill ( s , a1 , a2 , a3 , a4 , c4 , c7 ) if s : print ( s ) else : print ( - 1 ) elif a3 == a4 : s = ' ' . join ( repeat ( '47' , a3 ) ) + '4' c4 = ceil ( len ( s ) \/ 2 ) c7 = len ( s ) - c4 s = fill ( s , a1 , a2 , a3 , a4 , c4 , c7 ) if s : print ( s ) else : s = ' ' . join ( repeat ( '74' , a3 ) ) + '7' c7 = ceil ( len ( s ) \/ 2 ) c4 = len ( s ) - c7 s = fill ( s , a1 , a2 , a3 , a4 , c4 , c7 ) if s : print ( s ) else : print ( - 1 ) NEW_LINE","from itertools import repeatfrom math import floor , ceildef fill ( s , a1 , a2 , a3 , a4 , c4 , c7 ) : if a1 < c4 or a2 < c7 : return None f = s . index ( '4' ) sv = s . rindex ( '7' ) s = ' ' . join ( [ s [ : f ] , '4' * ( a1 - c4 ) , s [ f : sv ] , '7' * ( a2 - c7 ) , s [ sv : ] ] ) return sa1 , a2 , a3 , a4 = [ int ( x ) for x in input ( ) . split ( ) ] if abs ( a3 - a4 ) > 1 : print ( - 1 ) else : s = ' ' if a3 > a1 or a3 > a2 or a4 > a1 or a4 > a2 : print ( - 1 ) exit ( 0 ) c4 = 0 c7 = 0 if a3 > a4 : s = ' ' . join ( repeat ( '47' , a3 ) ) c4 = int ( len ( s ) \/ 2 ) c7 = len ( s ) - c4 s = fill ( s , a1 , a2 , a3 , a4 , c4 , c7 ) if s : print ( s ) else : print ( - 1 ) elif a3 < a4 : s = ' ' . join ( repeat ( '74' , a4 ) ) c7 = int ( len ( s ) \/ 2 ) c4 = len ( s ) - c7 s = fill ( s , a1 , a2 , a3 , a4 , c4 , c7 ) if s : print ( s ) else : print ( - 1 ) elif a3 == a4 : s = ' ' . join ( repeat ( '47' , a3 ) ) + '4' c4 = ceil ( len ( s ) \/ 2 ) c7 = len ( s ) - c4 s = fill ( s , a1 , a2 , a3 , a4 , c4 , c7 ) if s : print ( s ) else : s = ' ' . join ( repeat ( '74' , a3 ) ) + '7' c7 = ceil ( len ( s ) \/ 2 ) c4 = len ( s ) - c7 s = fill ( s , a1 , a2 , a3 , a4 , c4 , c7 ) if s : print ( s ) else : print ( - 1 ) NEW_LINE","a , b , c , d = input ( ) . strip ( ) . split ( ) a = int ( a ) b = int ( b ) c = int ( c ) d = int ( d )   if abs ( c - d ) > 1 or min ( a , b ) < max ( c , d ) or a == b == c == d : print ( - 1 ) exit ( )   if c == d : if a == c : ans = '74' * c + '7' * ( b - c ) else : ans = '4' * ( a - c - 1 ) + '47' * c + '7' * ( b - c ) + '4' elif c > d : ans = '4' * ( a - c ) + '47' * c + '7' * ( b - c ) else : ans = '7' + '4' * ( a - c ) + '74' * ( c - 1 ) + '7' * ( b - c ) + '4'   print ( ans ) NEW_LINE"],"bleu":0.0001332622415219818,"rouge_l":0.04868316041500399}
{"id":385,"predictions":["n = int ( input ( ) ) ; print ( * [ ( n - 1 ) ** 2 \/\/ 2 ] + [ ' % d ▁ % d ' % ( i , j ) * ( i != n - 1 ) \/\/ 2 ] ) NEW_LINE"],"references":["n = int ( input ( ) ) l = [ [ ] for i in range ( n ) ] for i in range ( n ) : for a in range ( i ) : l [ i ] += [ a ]   for i in range ( n ) :   print ( ( ( n - 1 - i ) * 2 + 1 ) * \" ▁ \" , * l [ i ] , 1 * i , * list ( reversed ( l [ i ] ) ) )   for i in range ( n ) : print ( i , end = \" ▁ \" ) print ( n , end = \" ▁ \" ) for i in range ( n - 1 , 0 , - 1 ) : print ( i , end = \" ▁ \" ) print ( 0 )       for i in range ( n - 1 , - 1 , - 1 ) :     print ( ( ( n - 1 - i ) * 2 + 1 ) * \" ▁ \" , * l [ i ] , 1 * i , * list ( reversed ( l [ i ] ) ) )     NEW_LINE","n = int ( input ( ) )   space = n * 2 arr = [ ' ▁ ' * space + \"0\" ]   for i in range ( 1 , n + 1 ) : space -= 2 arr . append ( ( ' ▁ ' * space + ( arr [ - 1 ] + \" ▁ \" + str ( i ) ) . strip ( ) ) )   NEW_LINE","n = int ( input ( ) )   for i in range ( n + 1 ) : for j in range ( n - i ) : print ( \" ▁ ▁ \" , end = \" \" ) a = 0 x = 1 for k in range ( i * 2 + 1 ) : if ( k == i * 2 ) : print ( str ( a ) , end = \" \" ) else : print ( str ( a ) + ' ▁ ' , end = \" \" ) if ( a >= i ) : x *= - 1 a += x print ( )   for i in range ( n - 1 , - 1 , - 1 ) : for j in range ( n - i ) : print ( \" ▁ ▁ \" , end = \" \" ) a = 0 x = 1 for k in range ( i * 2 + 1 ) : if ( k == i * 2 ) : print ( str ( a ) , end = \" \" ) else : print ( str ( a ) + ' ▁ ' , end = \" \" ) if ( a >= i ) : x *= - 1 a += x print ( ) NEW_LINE"],"bleu":0.2239225661001149,"rouge_l":0.41194960831020855}
{"id":386,"predictions":["def STR ( ) : return list ( input ( ) ) def INT ( ) : return int ( input ( ) ) def MAP ( ) : return map ( int , input ( ) . split ( ) ) def MAP2 ( ) : return map ( float , input ( ) . split ( ) ) def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) def STRING ( ) : return input ( ) import stringimport sysfrom heapq import heappop , heappushfrom bisect import * from collections import deque , Counter , defaultdictfrom math import * from itertools import permutations , accumulatedx = [ - 1 , 1 , 0 , 0 ] dy = [ 0 , 0 , 1 , - 1 ] NEW_LINE"],"references":["import sysdef input ( ) : return sys . stdin . readline ( ) . strip ( ) def iinput ( ) : return int ( input ( ) ) def minput ( ) : return map ( int , input ( ) . split ( ) ) def listinput ( ) : return list ( map ( int , input ( ) . split ( ) ) ) a , b , pos = minput ( ) for i in range ( b ) : a *= 10 c = a \/\/ b a = a % b if c == pos : print ( i + 1 ) exit ( ) print ( \" - 1\" ) NEW_LINE","import osimport sysfrom io import BytesIO , IOBase   BUFSIZE = 8192     class FastIO ( IOBase ) : newlines = 0   def __init__ ( self , file ) : self . _fd = file . fileno ( ) self . buffer = BytesIO ( ) self . writable = \" x \" in file . mode or \" r \" not in file . mode self . write = self . buffer . write if self . writable else None   def read ( self ) : while True : b = os . read ( self . _fd , max ( os . fstat ( self . _fd ) . st_size , BUFSIZE ) ) if not b : break ptr = self . buffer . tell ( ) self . buffer . seek ( 0 , 2 ) , self . buffer . write ( b ) , self . buffer . seek ( ptr ) self . newlines = 0 return self . buffer . read ( )   def readline ( self ) : while self . newlines == 0 : b = os . read ( self . _fd , max ( os . fstat ( self . _fd ) . st_size , BUFSIZE ) ) self . newlines = b . count ( b \" \\n \" ) + ( not b ) ptr = self . buffer . tell ( ) self . buffer . seek ( 0 , 2 ) , self . buffer . write ( b ) , self . buffer . seek ( ptr ) self . newlines -= 1 return self . buffer . readline ( )   def flush ( self ) : if self . writable : os . write ( self . _fd , self . buffer . getvalue ( ) ) self . buffer . truncate ( 0 ) , self . buffer . seek ( 0 )     class IOWrapper ( IOBase ) : def __init__ ( self , file ) : self . buffer = FastIO ( file ) self . flush = self . buffer . flush self . writable = self . buffer . writable self . write = lambda s : self . buffer . write ( s . encode ( \" ascii \" ) ) self . read = lambda : self . buffer . read ( ) . decode ( \" ascii \" ) self . readline = lambda : self . buffer . readline ( ) . decode ( \" ascii \" )     sys . stdin , sys . stdout = IOWrapper ( sys . stdin ) , IOWrapper ( sys . stdout ) input = lambda : sys . stdin . readline ( ) . rstrip ( \" \\n \" ) NEW_LINE","a , b , c = list ( map ( int , input ( ) . split ( ) ) )   pos = 1 for i in range ( 1000000 ) : d = ( 10 * a ) \/\/ b a = ( 10 * a ) % b if c == d : print ( pos ) exit ( 0 ) else : pos += 1 print ( - 1 ) NEW_LINE"],"bleu":0.40940149925425995,"rouge_l":0.4960609911054638}
{"id":387,"predictions":["def STR ( ) : return list ( input ( ) ) def INT ( ) : return int ( input ( ) ) def MAP ( ) : return map ( int , input ( ) . split ( ) ) def MAP2 ( ) : return map ( float , input ( ) . split ( ) ) def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) def STRING ( ) : return input ( ) import stringimport sysfrom heapq import heappop , heappushfrom bisect import * from collections import deque , Counter , defaultdictfrom math import * from itertools import permutations , accumulatedx = [ - 1 , 1 , 0 , 0 ] dy = [ 0 , 0 , 1 , - 1 ] NEW_LINE"],"references":["n , k = map ( int , input ( ) . split ( ) ) a = input ( ) b = input ( ) res = 0 ans = 0 for i in range ( 0 , n ) : res = min ( res * 2 + ( b [ i ] == ' b ' ) - ( a [ i ] == ' b ' ) , k ) ans += min ( res + 1 , k ) print ( ans ) NEW_LINE","n , k = map ( int , input ( ) . split ( ) ) s = input ( ) t = input ( ) res = 0 ans = 0 for i in range ( 0 , n ) : res = min ( res * 2 - ( s [ i ] == ' b ' ) + ( t [ i ] == ' b ' ) , k ) ; ans += min ( res + 1 , k ) print ( ans ) NEW_LINE"],"bleu":0.13181971725675973,"rouge_l":0.2799822327509624}
{"id":388,"predictions":["k , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a == 0 and b == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif ( b < 0 ) : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT y = ( b - a ) \/\/ k NEW_LINE if ( a + b ) % k == 0 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT"],"references":["k , a , b = map ( int , input ( ) . split ( ) ) if ( a >= 0 and b >= 0 ) or ( a < 0 and b < 0 ) : if a < 0 and b < 0 : temp = - b b = - a a = temp c = b \/\/ k - a \/\/ k if a % k == 0 : c += 1 elif a < 0 and b >= 0 : a = - a c = a \/\/ k + b \/\/ k + 1 print ( c ) NEW_LINE","import math   def main ( ) : k , a , b = map ( int , input ( ) . split ( ) )   low = ( a + k - 1 ) \/\/ k big = b \/\/ k   ans = big - low + 1   NEW_LINE","k , a , b = map ( int , input ( ) . split ( ) ) print ( b \/\/ k - ( a - 1 ) \/\/ k ) NEW_LINE"],"bleu":0.3620571651540109,"rouge_l":0.696870920649143}
{"id":389,"predictions":["n = int ( input ( ) ) arr = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE"],"references":["n = int ( input ( ) ) s = input ( )   arr = set ( list ( s ) ) if len ( arr ) < n : print ( \" NO \" )   else : ans = [ ] d = { }   for i in s : if i in d : ans [ - 1 ] += i else : d [ i ] = 1 ans . append ( i ) print ( \" YES \" ) for i in ans [ : n - 1 ] : print ( i )   print ( ' ' . join ( ans [ n - 1 : ] ) )   NEW_LINE","import sysimport mathimport collectionsimport bisectdef get_ints ( ) : return map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) def get_list ( ) : return list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) def get_string ( ) : return sys . stdin . readline ( ) . strip ( ) for t in range ( 1 ) : n = int ( input ( ) ) string = list ( get_string ( ) ) if len ( set ( string ) ) < n : print ( \" NO \" ) continue selected = set ( ) selected . add ( string [ 0 ] ) ans = [ ] left = 0 counted = 0 for i in range ( 1 , len ( string ) + 2 ) : if counted == n - 1 : sub_string = string [ left : ] ans . append ( sub_string ) break else : sub_string = string [ left : i ] if sub_string [ - 1 ] not in selected : selected . add ( sub_string [ - 1 ] ) ans . append ( sub_string [ : len ( sub_string ) - 1 ] ) selected . add ( sub_string [ 0 ] ) left = i - 1 counted += 1 print ( \" YES \" ) for i in ans : print ( * i , sep = \" \" ) NEW_LINE","k = int ( input ( ) ) s = input ( ) first_letter = [ ] lst = [ ] count = prev = i = 0 l = len ( s ) if k == 1 : print ( ' YES ' ) print ( s ) elif k > l : print ( ' NO ' ) else : while i < l : first_letter . append ( s [ i ] ) count += 1 i += 1 while i < l and s [ i ] in first_letter : i += 1 if count != k : lst . append ( s [ prev : i ] ) prev = i else : lst . append ( s [ prev : ] ) break if len ( lst ) == k : print ( ' YES ' ) print ( ' \\n ' . join ( lst ) ) else : print ( ' NO ' ) NEW_LINE"],"bleu":0.02219580135047934,"rouge_l":0.2564564564564564}
{"id":390,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) if n == 1 and a [ 0 ] == 1 or n > 1 and a . count ( 0 ) == 1 : print ( ' YES ' ) else : print ( ' NO ' ) NEW_LINE"],"references":["def mingrid ( ) : for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) segcost = input ( ) . split ( ) minodd = int ( segcost [ 0 ] ) mineven = int ( segcost [ 1 ] ) sumodd = minodd sumeven = mineven codd = 1 ceven = 1 res = sumodd + minodd * ( n - codd ) + sumeven + mineven * ( n - ceven ) for i in range ( 2 , n ) : now = int ( segcost [ i ] ) if ( i + 1 ) % 2 : NEW_LINE","    n = int ( input ( ) )   t = list ( map ( int , input ( ) . split ( ) ) )       t . sort ( ) m = t [ 0 ]   for j in range ( n ) : t [ j ] -= m     x = - 1   for j in range ( n ) : if t [ j ] > 0 : x = t [ j ] break       if x == - 1 : print ( ' YES ' ) else :   u = 0 for j in range ( n ) : if t [ j ] == 0 or t [ j ] == x or t [ j ] == 2 * x : continue else : u += 1   if u > 0 : print ( ' NO ' ) else : print ( ' YES ' ) NEW_LINE","n = int ( input ( ) ) lst = list ( map ( int , input ( ) . split ( ) ) )   lst = sorted ( lst )   mn = lst [ 0 ] mx = lst [ len ( lst ) - 1 ] if ( mx - mn ) <= 2 or n <= 2 : print ( \" YES \" )   elif ( mx - mn ) % 2 == 0 : x = int ( ( mx + mn ) \/ 2 ) flag = 0 for i in lst : if i != mn and i != mx and i != x : flag += 1 if ( flag == 0 ) : print ( \" YES \" ) else : print ( \" NO \" ) else : flag = 0 for i in lst : if i != mn and i != mx : flag += 1 if ( flag == 0 ) : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.306317524861342,"rouge_l":0.3993714809480162}
{"id":391,"predictions":["if __name__ == ' _ _ main _ _ ' : n , a , b = map ( int , input ( ) . split ( ) ) s = input ( ) f = a - 1 t = b - 1 if a > b : f , t = t , f if a == b or s [ a - 1 ] == s [ b - 1 ] : print ( 0 ) else : print ( 1 ) NEW_LINE"],"references":["import sys     def get_list ( ) : return list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) )   n = int ( input ( ) )   a = get_list ( ) b = get_list ( )   print ( \" Karen \" ) NEW_LINE","def E1 ( ) : n = int ( input ( ) ) kar = [ int ( x ) for x in input ( ) . split ( ) ] koy = [ int ( x ) for x in input ( ) . split ( ) ] print ( \" Karen \" )   if __name__ == ' _ _ main _ _ ' : E1 ( ) NEW_LINE"],"bleu":0.2821540875519981,"rouge_l":0.36493327197422915}
{"id":392,"predictions":["n , k = map ( int , input ( ) . split ( ) ) A = list ( map ( int , input ( ) . split ( ) ) ) Max = A [ - 1 ] while 2 * k > 2 * k : Max = ( Max , A [ 0 ] + A [ k - 1 ] ) del A [ k ] , A [ - 1 ] print ( Max ) NEW_LINE"],"references":["import sys       n , m , c = map ( int , input ( ) . split ( ) )   free = n   nums = [ 0 ] * n       for i in range ( m ) :   pi = int ( input ( ) )   if ( pi > c \/\/ 2 ) :   current = n - 1   while ( nums [ current ] > 0 and nums [ current ] >= pi and current >= 0 ) : current -= 1   if ( current == - 1 ) : current = 0   if ( nums [ current ] == 0 ) : free -= 1   nums [ current ] = pi   print ( current + 1 )   else :   current = 0   while ( current < n and nums [ current ] > 0 and nums [ current ] <= pi ) : current += 1   if ( current == n ) : current = n - 1   if ( nums [ current ] == 0 ) : free -= 1   nums [ current ] = pi   print ( current + 1 )       if ( free == 0 ) : break               NEW_LINE","import sys   n , m , c = map ( int , input ( ) . split ( ) ) a = [ ] for i in range ( n + 1 ) : a . append ( 0 ) cnt = 0 while cnt < n : i = 0 x = int ( input ( ) ) if x * 2 <= c : i = 1 while a [ i ] and a [ i ] <= x : i += 1 else : i = n while a [ i ] and a [ i ] >= x : i -= 1 if a [ i ] == 0 : cnt += 1 a [ i ] = x print ( i ) sys . stdout . flush ( ) NEW_LINE","import sys   n , m , c = map ( int , input ( ) . split ( ) ) a = [ ] for i in range ( n + 1 ) : a . append ( 0 ) cnt = 0 while cnt < n : i = 0 x = int ( input ( ) ) if x * 2 <= c : i = 1 while a [ i ] and a [ i ] <= x : i += 1 else : i = n while a [ i ] and a [ i ] >= x : i -= 1 if a [ i ] == 0 : cnt += 1 a [ i ] = x print ( i ) sys . stdout . flush ( ) NEW_LINE"],"bleu":0.14340838076286036,"rouge_l":0.37416046498303424}
{"id":393,"predictions":["from sys import stdin , stdoutfrom os import pathrd = lambda : stdin . readline ( ) . strip ( ) wr = stdout . writeif ( path . exists ( ' input . txt ' ) ) : stdin = open ( \" input . txt \" , \" r \" ) import time NEW_LINE"],"references":["from sys import stdin , stdoutimport math , bisectfrom collections import Counter , deque , defaultdictL = lambda : list ( map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) ) M = lambda : map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) I = lambda : int ( stdin . readline ( ) . strip ( ) ) S = lambda : stdin . readline ( ) . strip ( ) C = lambda : stdin . readline ( ) . strip ( ) . split ( ) def pr ( a ) : return ( \" \" . join ( list ( map ( str , a ) ) ) ) NEW_LINE","s = input ( )   if len ( set ( s ) ) == 1 : print ( s ) else : noOnes = \" \"   oneCount = 0   for i in range ( len ( s ) ) : if s [ i ] == '1' : oneCount += 1 else : noOnes += s [ i ]   for i in range ( len ( noOnes ) ) : if noOnes [ i ] == '2' : noOnes = noOnes [ : i ] + '1' * oneCount + noOnes [ i : ] break if i == len ( noOnes ) - 1 : noOnes = noOnes + '1' * oneCount print ( noOnes ) NEW_LINE","if __name__ == ' _ _ main _ _ ' : s = input ( )   len1 = s . count ( '1' ) index2 = s . find ( '2' ) if index2 == - 1 : s = list ( s ) s . sort ( ) print ( ' ' . join ( s ) )   else : temp = s [ : index2 ]   zero = temp . count ( '0' ) result = '0' * zero + '1' * len1 + s [ index2 : ] . replace ( '1' , ' ' )   print ( result ) NEW_LINE"],"bleu":0.15257435695993884,"rouge_l":0.34502262443438914}
{"id":394,"predictions":["import sys , math , itertoolsfrom collections import Counter , deque , defaultdictfrom bisect import bisect_left , bisect_right from heapq import heappop , heappush , heapify , nlargestfrom copy import deepcopymod = 10 ** 9 + 7 INF = float ( ' inf ' ) def inp ( ) : return int ( sys . stdin . readline ( ) ) def inpl ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) def inpl_1 ( ) : return list ( map ( lambda x : int ( x ) - 1 , sys . stdin . readline ( ) . split ( ) ) ) def inps ( ) : return sys . stdin . readline ( ) def inpsl ( x ) : tmp = sys . stdin . readline ( ) ; return list ( tmp [ : x ] ) def err ( x ) : print ( x ) ; exit ( )   s = input ( ) s = input ( ) res = [ ] boin = [ ' a ' , ' i ' , ' u ' , ' e ' , ' o ' , ' y ' ] for i in range ( len ( s ) - 1 ) : if s [ i ] in boin and s [ i ] in boin : continue res += 1 print ( res ) NEW_LINE"],"references":["print ( ' YES ' if len ( [ i for i in input ( ) if i in ' aeiou ' ] ) == 5 and len ( [ i for i in input ( ) if i in ' aeiou ' ] ) == 7 and len ( [ i for i in input ( ) if i in ' aeiou ' ] ) == 5 else ' NO ' ) NEW_LINE","s1 = input ( ) NEW_LINE s2 = input ( ) NEW_LINE s3 = input ( ) NEW_LINE count1 , count2 , count3 = 0 , 0 , 0 NEW_LINE for i in s1 : if NEW_LINE i in [ \" a \" , \" e \" , \" i \" , \" o \" , \" u \" ] : count1 += 1 NEW_LINE for i in s2 : if NEW_LINE i in [ \" a \" , \" e \" , \" i \" , \" o \" , \" u \" ] : count2 += 1 NEW_LINE for i in s3 : if NEW_LINE i in [ \" a \" , \" e \" , \" i \" , \" o \" , \" u \" ] : count3 += 1   if count1 == 5 and count2 == 7 and count3 == 5 : NEW_LINE INDENT print ( \" YES \" ) else : NEW_LINE print ( \" NO \" ) NEW_LINE DEDENT","l1 = input ( ) NEW_LINE l2 = input ( ) NEW_LINE l3 = input ( ) NEW_LINE haiku = [ l1 , l2 , l3 ] NEW_LINE"],"bleu":0.054789534536672325,"rouge_l":0.28809849706595836}
{"id":395,"predictions":["s = input ( ) z = [ ] for i in s : if i == '1' : z . append ( i ) z += 1   if z == len ( s ) : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"references":["import syspassword = input ( ) ; n = int ( input ( ) ) ; first = second = 0 ; words = [ ] for i in range ( 0 , n ) : words . append ( input ( ) ) for word in words : if password [ 0 ] == word [ 1 ] : first = 1 if password [ 1 ] == word [ 0 ] : second = 1 if password == word : first = second = 1 if first == second == 1 : print ( \" YES \" ) sys . exit ( 0 ) print ( \" NO \" ) NEW_LINE","password = input ( ) n = int ( input ( ) ) res = [ ] for i in range ( n ) : res . append ( input ( ) ) flag = Falsefor i in range ( len ( res ) ) : for j in range ( len ( res ) ) : if password in res [ i ] + res [ j ] : flag = True break if password in res [ j ] + res [ i ] : flag = True break if flag : breakif flag : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE","password = input ( ) n = int ( input ( ) ) first_letter_found = second_letter_found = 0 result = ' NO ' for i in range ( n ) : word = input ( ) if word == password : result = ' YES ' elif result == ' NO ' : if word [ 1 ] == password [ 0 ] : first_letter_found = 1 if word [ 0 ] == password [ 1 ] : second_letter_found = 1   if result == ' NO ' and first_letter_found == 1 and second_letter_found == 1 : result = ' YES ' print ( result ) NEW_LINE"],"bleu":0.18010655894587185,"rouge_l":0.4004126031507877}
{"id":396,"predictions":["I = input NEW_LINE for _ in [ 0 ] * int ( I ( ) ) : NEW_LINE INDENT n , l = map ( int , I ( ) . split ( ) ) NEW_LINE if ( l [ n ] == 0 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"references":["for _ in range ( int ( input ( ) ) ) : n , m = map ( int , input ( ) . split ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if m == sum ( arr ) : print ( ' YES ' )   else : print ( ' NO ' ) NEW_LINE","import mathfor NEW_LINE _ in range ( int ( input ( ) ) ) : n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if sum ( a ) == m : NEW_LINE INDENT print ( \" YES \" ) else : NEW_LINE print ( \" NO \" ) NEW_LINE DEDENT","import sys   input = sys . stdin . buffer . readline   t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : n , m = map ( int , input ( ) . split ( ) ) NEW_LINE S = sum ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( \" YES \" if S == m else \" NO \" ) NEW_LINE"],"bleu":0.4781954983899332,"rouge_l":0.6340114993365767}
{"id":397,"predictions":["import sys   def input ( ) : return sys . stdin . readline ( ) . strip ( ) def iinput ( ) : return int ( input ( ) ) def rinput ( ) : return map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) def get_list ( ) : return list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) )       w , h , k = rinput ( ) , map ( str , rinput ( ) . strip ( ) . split ( ) ) if k == len ( w ) : print ( - 1 ) else : s = pow ( 10 , k - 1 ) + len ( s ) - sum ( w ) ) NEW_LINE"],"references":["w , m , k = map ( int , input ( ) . split ( ) ) z = mdig = 0 while z > 0 : dig += 1 ; z = z \/\/ 10 if ( dig * k > w ) : print ( 0 ) exit ( 0 ) lo = m - 1 hi = w + m + 5 while lo + 1 < hi : mid = ( lo + hi ) \/\/ 2 cost , t , d = 0 , 0 , 0 x = mid while x > 0 : x = x \/\/ 10 d += 1 if ( d == dig ) : cost = ( mid - m + 1 ) * d * k else : t = pow ( 10 , dig ) last = m c = dig while t <= mid : cost += ( t - last ) * c * k c += 1 last = t t = t * 10 t = t \/\/ 10 cost += ( mid - t + 1 ) * c * k if ( cost <= w ) : lo = mid else : hi = midprint ( lo - m + 1 ) NEW_LINE","w , m , k = map ( int , input ( ) . split ( ) ) cur = len ( str ( m ) ) g = 9 base = 1 g = g * ( 10 ** ( cur - 1 ) ) base = base * ( 10 ** ( cur - 1 ) ) gg = g - ( m - base ) ans = 0 while ( w ) : if ( w > cur * gg * k ) : w -= cur * gg * k ans += gg cur += 1 gg = g * 10 g *= 10 else : ans += w \/\/ ( cur * k ) breakprint ( ans ) NEW_LINE","have , start , k = map ( int , input ( ) . split ( ) )   ans = 0 while have > 0 : length = len ( str ( start ) ) howMany = ( 10 ** length - start ) cost = k * ( howMany ) * length if cost <= have : ans += howMany have -= cost start = 10 ** length else : ans += max ( 0 , have \/\/ ( k * length ) ) have = 0   print ( ans ) NEW_LINE"],"bleu":0.18388353169444713,"rouge_l":0.34602917341977313}
{"id":398,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) )   need = sum ( a ) \/\/ n   ans = 0   from math import *   for i in range ( n - 1 ) : if ( a [ i ] <= need ) : a [ i + 1 ] -= need - a [ i ] else : a [ i + 1 ] += a [ i ] - need ans += abs ( a [ i ] - need )   print ( ans ) NEW_LINE"],"references":["from collections import Counterfrom itertools import combinations   if __name__ == ' _ _ main _ _ ' : n = int ( input ( ) ) a = [ int ( i ) for i in input ( ) . split ( ) ] s = sum ( a ) t = s s \/= 2   while n > 0 and t > s : t -= a [ n - 1 ] n -= 1 print ( n + 1 if t < s else n ) NEW_LINE","from sys import stdin     input_number = int ( stdin . readline ( ) )   array = [ int ( x ) for x in stdin . readline ( ) . split ( ) ]     calendar = dict ( ) current_sum = 0   for i in range ( input_number ) :   current_sum += array [ i ]   if current_sum * 2 >= ( current_sum + input_number - i - 1 ) :   calendar . setdefault ( str ( i + 1 ) , current_sum )       for k , v in calendar . items ( ) :   if v * 2 >= ( current_sum + input_number - i - 1 ) :   print ( k )   break               NEW_LINE","n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = sum ( a ) c = 0 for i in range ( n ) : c += a [ i ] if c >= b \/ 2 : print ( i + 1 ) break NEW_LINE"],"bleu":0.4488040309353209,"rouge_l":0.6108551972761866}
{"id":399,"predictions":["from sys import stdin , stdoutstdin . readlinedef mp ( ) : return list ( map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) def it ( ) : return int ( stdin . readline ( ) . strip ( ) ) from collections import defaultdict as dd , Counter as C   n = int ( stdin . readline ( ) . strip ( ) ) s = ns ( ) s1 = [ ] s2 = ns ( ) s2 = ns ( ) if len ( s1 ) > 2 : s1 . append ( s2 ) elif len ( s2 ) == 2 : s1 . append ( s1 ) else : s2 . append ( s2 )   if len ( s1 ) % 2 == 0 : print ( \" - \" . join ( s1 ) ) else : print ( \" \" . join ( s2 ) ) NEW_LINE"],"references":["from sys import stdin , stdoutfrom math import floor , gcd , fabs , factorial , fmod , sqrt , inf , logfrom collections import defaultdict as dd , dequefrom heapq import merge , heapify , heappop , heappush , nsmallestfrom bisect import bisect_left as bl , bisect_right as br , bisect mod = pow ( 10 , 9 ) + 7 mod2 = 998244353 def inp ( ) : return stdin . readline ( ) . strip ( ) def iinp ( ) : return int ( inp ( ) ) def out ( var , end = \" \\n \" ) : stdout . write ( str ( var ) + \" \\n \" ) def outa ( * var , end = \" \\n \" ) : stdout . write ( ' ▁ ' . join ( map ( str , var ) ) + end ) def lmp ( ) : return list ( mp ( ) ) def mp ( ) : return map ( int , inp ( ) . split ( ) ) def smp ( ) : return map ( str , inp ( ) . split ( ) ) def l1d ( n , val = 0 ) : return [ val for i in range ( n ) ] def l2d ( n , m , val = 0 ) : return [ l1d ( m , val ) for j in range ( n ) ] def remadd ( x , y ) : return 1 if x % y else 0 def ceil ( a , b ) : return ( a + b - 1 ) \/\/ b def isprime ( x ) : if x <= 1 : return False if x in ( 2 , 3 ) : return True if x % 2 == 0 : return False for i in range ( 3 , int ( sqrt ( x ) ) + 1 , 2 ) : if x % i == 0 : return False return True n = iinp ( ) s = inp ( ) for i in range ( n ) : print ( s [ i ] , end = ' ' ) if n - i >= 3 and i % 2 : print ( ' - ' , end = ' ' ) print ( ) NEW_LINE","n = int ( input ( ) ) v = input ( )   ans = [ ]   i = 0 while ( i < n ) : if ( n - i == 3 ) : ans . append ( v [ i ] + v [ i + 1 ] + v [ i + 2 ] ) i += 4 break else : ans . append ( v [ i ] + v [ i + 1 ] ) i += 2 print ( ' - ' . join ( ans ) ) NEW_LINE","n = int ( input ( ) ) s = input ( )   if n % 2 == 0 : ans = [ s [ i : i + 2 ] for i in range ( 0 , n , 2 ) ] print ( ' - ' . join ( ans ) ) else : x = s [ : 3 ] s = s [ 3 : ] ans = [ x ] + [ s [ i : i + 2 ] for i in range ( 0 , n - 3 , 2 ) ] print ( ' - ' . join ( ans ) ) NEW_LINE"],"bleu":0.3884313831512928,"rouge_l":0.4443364815602806}
{"id":400,"predictions":["from collections import defaultdictimport mathfrom sys import stdin , stdout , setrecursionlimitfrom functools import lru_cache , cmp_to_keyfrom heapq import merge , heapify , heappopfrom math import * from collections import defaultdict as dd , deque , Counter as Cfrom itertools import combinations as comb , permutations as perm , accumulatefrom bisect import bisect_left as bl , bisect_right as br , bisectfrom time import perf_counterfrom fractions import Fractionimport copyimport timesetrecursionlimit ( 10 ** 9 ) starttime = time . time ( ) mod = int ( pow ( 10 , 9 ) + 7 ) mod2 = 998244353 NEW_LINE"],"references":["def p2 ( a ) : n = len ( a ) last = [ [ - 1 ] * 26 for _ in range ( n ) ] last [ 0 ] [ ord ( a [ 0 ] ) - 97 ] = 0 for i in range ( 1 , n ) : for j in range ( 26 ) : last [ i ] [ j ] = last [ i - 1 ] [ j ] last [ i ] [ ord ( a [ i ] ) - 97 ] = i dp = [ ' ' ] * n for i in range ( n - 1 , - 1 , - 1 ) : for j in range ( n - 1 , i , - 1 ) : k = last [ j ] [ ord ( a [ i ] ) - 97 ] if k > i : if ( k - i ) == 1 and len ( dp [ j ] ) < 2 : dp [ j ] = a [ i ] + a [ i ] elif len ( dp [ j ] ) < ( len ( dp [ k - 1 ] ) + 2 ) : dp [ j ] = a [ i ] + dp [ k - 1 ] + a [ i ] if len ( dp [ j ] ) >= 100 : if len ( dp [ j ] ) == 101 : return dp [ j ] [ : 50 ] + dp [ j ] [ 51 : ] else : return dp [ j ] dp [ i ] = a [ i ] return dp [ n - 1 ]     a = input ( ) print ( p2 ( a ) ) NEW_LINE","def p2 ( a ) : n = len ( a ) last = [ [ 0 ] * 26 for _ in range ( n ) ] last [ 0 ] [ ord ( a [ 0 ] ) - 97 ] = 0 for i in range ( 1 , n ) : for j in range ( 26 ) : last [ i ] [ j ] = last [ i - 1 ] [ j ] last [ i ] [ ord ( a [ i ] ) - 97 ] = i dp = [ ' ' ] * n for i in range ( n - 1 , - 1 , - 1 ) : for j in range ( n - 1 , i , - 1 ) : k = last [ j ] [ ord ( a [ i ] ) - 97 ] if k > i : if ( k - i ) == 1 and len ( dp [ j ] ) < 2 : dp [ j ] = a [ i ] + a [ i ] elif len ( dp [ j ] ) < ( len ( dp [ k - 1 ] ) + 2 ) : dp [ j ] = a [ i ] + dp [ k - 1 ] + a [ i ] if len ( dp [ j ] ) >= 100 : if len ( dp [ j ] ) == 101 : return dp [ j ] [ : 50 ] + dp [ j ] [ 51 : ] else : return dp [ j ] dp [ i ] = a [ i ] return dp [ n - 1 ]   print ( p2 ( input ( ) ) ) NEW_LINE"],"bleu":0.0033491200911790323,"rouge_l":0.08088993664358331}
{"id":401,"predictions":["import sysinput = sys . stdin . readline   '''   '''   n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) a . sort ( reverse = True ) count = 0 l , r = 0 , 1   while l < n and r < n : if a [ l ] > a [ r ] : l += 1 r += 1 count += 1 else : r += 1   print ( count ) NEW_LINE"],"references":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) p = [ 0 ] * nfor i in range ( n ) : p [ a [ i ] - 1 ] = i + 1 s = 0 for i in range ( n - 1 ) : s += abs ( p [ i ] - p [ i + 1 ] ) print ( s ) NEW_LINE","n = int ( input ( ) ) f = [ int ( x ) for x in input ( ) . split ( ) ]   main = [ ] for i in range ( n ) : main . append ( ( f [ i ] , i ) ) main . sort ( )   ans = 0 for i in range ( n - 1 ) : ans += abs ( main [ i ] [ 1 ] - main [ i + 1 ] [ 1 ] )   print ( ans ) NEW_LINE","n = int ( input ( ) ) lst = list ( map ( int , input ( ) . strip ( ) . split ( ' ▁ ' ) ) ) l = [ ] for j in range ( n ) : l . append ( [ lst [ j ] , j ] ) l . sort ( key = lambda x : x [ 0 ] ) c = 0 for i in range ( 1 , n ) : c += abs ( l [ i ] [ 1 ] - l [ i - 1 ] [ 1 ] ) print ( c ) NEW_LINE"],"bleu":0.35720185757984535,"rouge_l":0.4845542806707856}
{"id":402,"predictions":["import sysinput = sys . stdin . readlinefrom collections import deque     INT = int ( input ( ) ) NEW_LINE"],"references":["def count ( a ) : n = len ( a ) cnt = 0 for i in range ( n ) : for j in range ( i + 1 , n ) : if a [ i ] > a [ j ] : cnt += 1 return cnt                       n = int ( input ( ) ) p = list ( map ( int , input ( ) . split ( ) ) ) num = count ( p )   print ( num * 2 - num % 2 ) NEW_LINE","from sys import *   n = int ( stdin . readline ( ) . strip ( ) ) s1 = stdin . readline ( ) . strip ( ) a = list ( map ( int , s1 . split ( ) ) )   if n == 1 : print ( '0' ) else : x = 0 n0 = 1 while n0 < n : n0 = n0 * 2 b = [ 0 ] * ( 2 * n0 + 10 ) ''' for ▁ i ▁ in ▁ range ▁ ( n - 1 ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ for ▁ j ▁ in ▁ range ▁ ( i + 1 , n ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ a [ i ] > a [ j ] : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ x + = 1 ''' for i in range ( n ) : t = a [ i ] u = 0 k = 1 j = 1 while t > 0 : if ( t >> j ) << j != t : u = u + b [ ( n0 + t - 1 ) >> ( j - 1 ) ] t = t - k k = k << 1 j = j + 1 x = x + u j = n0 + a [ i ] - 1 while j > 0 : b [ j ] += 1 j = j >> 1 x = ( ( n * ( n - 1 ) ) \/\/ 2 ) - x ''' n = x \/ \/2 ▁ ▁ ▁ ▁ print ( x , n , ' ▁ ! ! ! ' ) ▁ ▁ ▁ ▁ r = x ▁ ▁ ▁ ▁ i = 1 ▁ ▁ ▁ ▁ bi = n ▁ ▁ ▁ ▁ eps = 0.0000001 ▁ ▁ ▁ ▁ if ▁ x > 0 : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ while ▁ ( x + 2 * i ) * bi * ( ( 0.5 ) * * i ) > eps : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ r = r + ( x + 2 * i ) * bi * ( ( 0.5 ) * * i ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ # print ( r ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ bi = ( bi * ( n + i ) ) \/ \/ ( i + 1 ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ i = i + 1 ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ # print ( bi , i ) ▁ ▁ ▁ ▁ else : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ r = 0 ▁ ▁ ▁ ▁ r = r * ( ( 0.5 ) * * n ) ▁ ▁ ▁ ▁ print ( \" % .7f \" % r ) ''' if x % 2 == 1 : print ( 2 * x - 1 ) else : print ( 2 * x ) NEW_LINE","from bisect import bisect_rightinput ( ) t = list ( map ( int , input ( ) . split ( ) ) ) s , p = 0 , [ ] for i , j in enumerate ( t ) : k = bisect_right ( p , j ) s += i - k p . insert ( k , j ) print ( 2 * s - ( s & 1 ) ) NEW_LINE"],"bleu":0.027225243884277738,"rouge_l":0.1763855421686747}
{"id":403,"predictions":["def maxMaxMin ( nums , k ) : if k == 1 : return min ( nums ) else : maximum = max ( nums ) if k != 2 : return maximum if nums [ 0 ] == maximum or nums [ - 1 ] == maximum : return maximum return max ( nums [ 0 ] , nums [ - 1 ] )       n , k = map ( int , input ( ) . split ( ) ) nums = list ( map ( int , input ( ) . split ( ) ) ) print ( maxMaxMin ( nums , k ) ) NEW_LINE"],"references":["def STR ( ) : return list ( input ( ) ) def INT ( ) : return int ( input ( ) ) def MAP ( ) : return map ( int , input ( ) . split ( ) ) def MAP2 ( ) : return map ( float , input ( ) . split ( ) ) def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) def STRING ( ) : return input ( ) import stringimport sysfrom heapq import heappop , heappushfrom bisect import * from collections import deque , Counter , defaultdictfrom math import * from itertools import permutations , accumulatedx = [ - 1 , 1 , 0 , 0 ] dy = [ 0 , 0 , 1 , - 1 ] NEW_LINE","choices = [ ] d = [ ' A ' , ' B ' , ' C ' , ' D ' ]   for _ in range ( 4 ) : choices . append ( len ( input ( ) ) - 2 )   option = choices . copy ( ) choices . sort ( )   if choices [ 0 ] <= choices [ 1 ] \/ 2 and choices [ 2 ] <= choices [ 3 ] \/ 2 : ans = 2 elif choices [ 0 ] <= choices [ 1 ] \/ 2 : ans = option . index ( choices [ 0 ] ) elif choices [ 2 ] <= choices [ 3 ] \/ 2 : ans = option . index ( choices [ 3 ] ) else : ans = 2   print ( d [ ans ] ) NEW_LINE","q , t = 0 , sorted ( [ ( len ( input ( ) ) - 2 , i ) for i in ' ABCD ' ] ) if 2 * t [ 0 ] [ 0 ] <= t [ 1 ] [ 0 ] : q += 1 if t [ 3 ] [ 0 ] >= 2 * t [ 2 ] [ 0 ] : q += 2 print ( [ ' C ' , t [ 0 ] [ 1 ] , t [ 3 ] [ 1 ] , ' C ' ] [ q ] ) NEW_LINE"],"bleu":0.3657245848554459,"rouge_l":0.3557753264866235}
{"id":404,"predictions":["from collections import defaultdict , deque , Counterfrom sys import stdin , stdoutfrom heapq import heappush , heappopimport mathimport ioimport osimport mathimport bisect   NEW_LINE"],"references":["sum , xor = map ( int , input ( ) . split ( ) )   andr = ( sum - xor ) \/ 2   if sum < xor or ( sum - xor ) % 2 == 1 or int ( andr ) & xor : print ( 0 ) else : perm = 2 ** bin ( xor ) . count ( \"1\" ) if sum == xor : perm = perm - 2 print ( perm ) NEW_LINE","a , b = [ int ( x ) for x in input ( ) . split ( ) ]     c = ( a - b ) \/ 2 if not c . is_integer ( ) or int ( c ) & b : print ( 0 ) exit ( 0 )   t = 0 while b : NEW_LINE","import sys , os , iofrom sys import stdinfrom math import log , gcd , ceilfrom collections import defaultdict , deque , Counterfrom heapq import heappush , heappopfrom bisect import bisect_left , bisect_rightimport math       alphabets = list ( ' abcdefghijklmnopqrstuvwxyz ' )     def isPrime ( x ) : for i in range ( 2 , x ) : if i * i > x : break if ( x % i == 0 ) : return False return Truedef ncr ( n , r , p ) : num = den = 1 for i in range ( r ) : num = ( num * ( n - i ) ) % p den = ( den * ( i + 1 ) ) % p return ( num * pow ( den , p - 2 , p ) ) % pdef primeFactors ( n ) : l = [ ] while n % 2 == 0 : l . append ( 2 ) n = n \/ 2 for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) : while n % i == 0 : l . append ( int ( i ) ) n = n \/ i if n > 2 : l . append ( n ) return list ( set ( l ) ) def power ( x , y , p ) : res = 1 x = x % p if ( x == 0 ) : return 0 while ( y > 0 ) : if ( ( y & 1 ) == 1 ) : res = ( res * x ) % p y = y >> 1 NEW_LINE"],"bleu":0.09646042026003261,"rouge_l":0.07734806629834255}
{"id":405,"predictions":["n = int ( input ( ) ) s = input ( ) if ( n == 1 ) : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"references":["import sys   n = int ( sys . stdin . readline ( ) ) digits = [ int ( x ) for x in sys . stdin . readline ( ) . strip ( ) ]   NEW_LINE","m = { 1 : ( 1 , 1 ) , 2 : ( 1 , 2 ) , 3 : ( 1 , 3 ) , 4 : ( 2 , 1 ) , 5 : ( 2 , 2 ) , 6 : ( 2 , 3 ) , 7 : ( 3 , 1 ) , 8 : ( 3 , 2 ) , 9 : ( 3 , 3 ) , 0 : ( 4 , 2 ) }   n = int ( input ( ) )   k = input ( )   p = [ ] for i in k : p . append ( m [ int ( i ) ] )   def valid ( i , j ) : if i >= 1 and i <= 3 and j >= 1 and j <= 3 : return ( True ) return ( i == 4 and j == 2 ) dx = [ - 1 , 1 , 0 , 0 , - 1 , - 1 , 1 , 1 ] dy = [ 0 , 0 , 1 , - 1 , - 1 , 1 , - 1 , 1 ]   for i in range ( len ( dx ) ) : fl = True for z in range ( len ( p ) ) : x = p [ z ] [ 0 ] y = p [ z ] [ 1 ] if not valid ( x + dx [ i ] , y + dy [ i ] ) : fl = False break if fl : print ( \" NO \" ) exit ( 0 ) print ( \" YES \" ) NEW_LINE","n = int ( input ( ) ) l = list ( map ( int , list ( input ( ) ) ) ) x = Trueif n == 1 : print ( \" NO \" ) else : cond1 = False cond2 = False cond3 = False cond4 = False for i in l : c = i if c == 1 or c == 2 or c == 3 : cond1 = True break for i in l : c = i if c == 7 or c == 9 or c == 0 : cond2 = True break for i in l : c = i if c == 0 or c % 3 == 1 : cond3 = True break for i in l : c = i if c == 0 or c % 3 == 0 : cond4 = True break if cond1 and cond2 and cond3 and cond4 : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.7297934413849376,"rouge_l":0.5043666993953801}
{"id":406,"predictions":["import sysinput = sys . stdin . readline   n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) d = [ 0 ] * ( n + 1 ) MOD = int ( 1e9 + 7 )   for i in range ( 0 , n ) : d [ i + 1 ] = ( d [ i ] + ( d [ i ] - d [ a [ i ] - 1 ] ) + 2 + MOD ) % MOD print ( d [ n ] ) ; NEW_LINE"],"references":["r = lambda : list ( map ( int , input ( ) . split ( ) ) ) arr = r ( ) size = \" S , ▁ M , ▁ L , ▁ XL , ▁ XXL \" . split ( \" , ▁ \" ) NEW_LINE","if __name__ == ' _ _ main _ _ ' : s = [ \" S \" , \" M \" , \" L \" , \" XL \" , \" XXL \" ] a = [ int ( i ) for i in input ( ) . split ( ) ] + [ 0 ] n = int ( input ( ) )   for i in range ( n ) : j = s . index ( input ( ) ) mx = j if not a [ j ] : for k in range ( j - 1 , - 1 , - 1 ) : if a [ k ] : mx = k break for k in range ( j + 1 , 6 ) : if a [ k ] : mx = mx if mx != j and j - mx < k - j else k break a [ mx ] -= 1 print ( \" % s \" % ( s [ mx ] ) ) NEW_LINE","ns , nm , nl , nxl , nxxl = map ( int , input ( ) . split ( ) ) n = int ( input ( ) ) for r in range ( n ) : t = input ( ) if t == \" S \" : if ns != 0 : ns -= 1 print ( \" S \" ) elif nm != 0 : nm -= 1 print ( \" M \" ) elif nl != 0 : nl -= 1 print ( \" L \" ) elif nxl != 0 : nxl -= 1 print ( \" XL \" ) elif nxxl != 0 : nxxl -= 1 print ( \" XXL \" ) if t == \" M \" : if nm != 0 : nm -= 1 print ( \" M \" ) elif nl != 0 : nl -= 1 print ( \" L \" ) elif ns != 0 : ns -= 1 print ( \" S \" ) elif nxl != 0 : nxl -= 1 print ( \" XL \" ) elif nxxl != 0 : nxxl -= 1 print ( \" XXL \" ) if t == \" L \" : if nl != 0 : nl -= 1 print ( \" L \" ) elif nxl != 0 : nxl -= 1 print ( \" XL \" ) elif nm != 0 : nm -= 1 print ( \" M \" ) elif nxxl != 0 : nxxl -= 1 print ( \" XXL \" ) elif ns != 0 : ns -= 1 print ( \" S \" ) if t == \" XL \" : if nxl != 0 : nxl -= 1 print ( \" XL \" ) elif nxxl != 0 : nxxl -= 1 print ( \" XXL \" ) elif nl != 0 : nl -= 1 print ( \" L \" ) elif nm != 0 : nm -= 1 print ( \" M \" ) elif ns != 0 : ns -= 1 print ( \" S \" ) if t == \" XXL \" : if nxxl != 0 : nxxl -= 1 print ( \" XXL \" ) elif nxl != 0 : nxl -= 1 print ( \" XL \" ) elif nl != 0 : nl -= 1 print ( \" L \" ) elif nm != 0 : nm -= 1 print ( \" M \" ) elif ns != 0 : ns -= 1 print ( \" S \" ) NEW_LINE"],"bleu":0.3445018684656927,"rouge_l":0.46292490118577073}
{"id":407,"predictions":["from collections import Counter NEW_LINE t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : n = int ( input ( ) ) NEW_LINE ali = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ali = list ( ( map ( int , input ( ) . split ( ) ) ) NEW_LINE"],"references":["for _ in range ( int ( input ( ) ) ) : a , b = map ( int , input ( ) . split ( ) ) x = set ( map ( int , input ( ) . split ( ) ) ) y = set ( map ( int , input ( ) . split ( ) ) ) z = x . intersection ( y ) if len ( z ) : print ( \" YES \" ) print ( 1 , list ( z ) [ 0 ] ) else : print ( \" NO \" ) NEW_LINE","for _ in range ( int ( input ( ) ) ) : n , m = map ( int , input ( ) . split ( ) ) ali = list ( map ( int , input ( ) . split ( ) ) ) bli = list ( map ( int , input ( ) . split ( ) ) ) q = list ( set ( ali ) . intersection ( bli ) ) if ( len ( q ) == 0 ) : print ( \" NO \" ) else : print ( \" YES \" ) print ( 1 , q [ 0 ] ) NEW_LINE","def solve ( ) : ls = input ( ) . split ( ) lst1 = list ( map ( int , input ( ) . split ( ) ) ) lst2 = list ( map ( int , input ( ) . split ( ) ) ) st = { 1 } st . pop ( ) for x in lst1 : st . add ( x ) for x in lst2 : if x in st : print ( \" YES ▁ 1\" , end = \" ▁ \" ) print ( x ) return ' ' print ( \" NO \" )   test = int ( input ( ) ) for i in range ( test ) : solve ( ) NEW_LINE"],"bleu":0.38076849828766324,"rouge_l":0.5247542134831461}
{"id":408,"predictions":["s = input ( ) a = input ( ) s = input ( ) . split ( ) k = int ( k . int ( s [ 0 ] ) ) l = [ ] for i in range ( 1 , len ( s ) ) : if s [ i ] == ' ▁ ' : k [ i ] = k [ i - 1 ] = k [ i ] else : k [ i ] = k [ i - 1 ] + 1 print ( l . index ( max ( k ) ) ) NEW_LINE"],"references":["def solution ( ) : st1 = input ( ) st2 = input ( )   dicty1 = { } dicty2 = { } LET = ' ABCDEFGHIJKLMNOPQRSTUVWXYZ ' LET += LET . lower ( )   for c in LET : dicty1 [ c ] = 0 dicty2 [ c ] = 0   for c in st1 : if c != ' ▁ ' : dicty1 [ c ] += 1   for c in st2 : if c != ' ▁ ' : dicty2 [ c ] += 1     for c in dicty2 : if dicty2 [ c ] > dicty1 [ c ] : print ( ' NO ' ) return print ( ' YES ' ) \t         return         solution ( ) NEW_LINE","heading = input ( ) text = input ( ) freq = dict ( ) l = len ( text ) for i in heading : if i in freq . keys ( ) : freq [ i ] += 1 else : freq [ i ] = 1 NEW_LINE","head = input ( ) text = input ( ) head_m = { t : head . count ( t ) for t in head . strip ( ) . replace ( ' ▁ ' , ' ' ) . replace ( ' \\t ' , ' ' ) } IsValid = Truefor i in text . strip ( ) . replace ( ' ▁ ' , ' ' ) . replace ( ' \\t ' , ' ' ) : NEW_LINE"],"bleu":0.18077616503759192,"rouge_l":0.5238289962825279}
{"id":409,"predictions":["import math , sys , bisect , heapq , osfrom collections import defaultdict , Counter , dequefrom itertools import groupby , accumulatefrom functools import lru_cache NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) d = { } ans = cnt = 0 for i in map ( int , input ( ) . split ( ) ) : d [ i ] = d . get ( i , 0 ) + 1 for i in range ( 1 , m + 1 ) : cnt = 0 for v in d . items ( ) : cnt += v [ 1 ] \/\/ i if cnt >= n : ans = iprint ( ans ) NEW_LINE","people , n = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) a . sort ( ) d = { } tmp = [ ] for i in range ( n ) : if a [ i ] in d : d [ a [ i ] ] += 1 else : d [ a [ i ] ] = 1 d1 = { } for i in d : if d [ i ] in d1 : d1 [ d [ i ] ] += 1 else : d1 [ d [ i ] ] = 1 tmp . append ( d [ i ] ) tmp . sort ( ) ans = 0 for i in range ( 1 , 10001 ) : x = people try : x -= d1 [ i ] except : pass for j in d1 : if j > i : x -= ( j \/\/ i ) * d1 [ j ] if x <= 0 : ans = max ( ans , i ) print ( ans ) NEW_LINE","from collections import Countern , m = map ( int , input ( ) . split ( ) ) c = Counter ( input ( ) . split ( ) ) . values ( ) d = 1 while sum ( ci \/\/ d for ci in c ) >= n : d += 1 print ( d - 1 )   NEW_LINE"],"bleu":0.02078761128463492,"rouge_l":0.1085538023490331}
{"id":410,"predictions":["import sysinput = sys . stdin . readlinen , m = map ( int , input ( ) . split ( ) ) for _ in range ( m ) : x , y , z = map ( int , input ( ) . split ( ) ) if x % y == 0 : print ( \" NO \" ) breakelse : print ( \" YES \" ) NEW_LINE"],"references":["a , b , c = map ( int , input ( ) . split ( ) )   while c >= 0 : if c % b == 0 : print ( ' Yes ' ) break c -= aelse : print ( ' No ' ) NEW_LINE","a , b , c = map ( int , input ( ) . split ( ) )   sums = [ 1 ] + [ 0 for i in range ( c ) ] for var in ( a , b ) : for i in range ( c - var + 1 ) : sums [ i + var ] += sums [ i ]   print ( \" Yes \" ) if sums [ c ] else print ( \" No \" ) NEW_LINE","a , b , c = map ( int , input ( ) . split ( ) ) g = c \/\/ min ( a , b ) + 1 flag = 0 for i in range ( g + 1 ) : for j in range ( g + 1 ) : if a * i + b * j == c : flag = 1 breakif flag : print ( \" Yes \" ) else : print ( \" No \" ) NEW_LINE"],"bleu":0.3536916324146411,"rouge_l":0.5496833901607404}
{"id":411,"predictions":["t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( 1 , len ( arr ) ) : if NEW_LINE i % 2 == 0 : l . append ( 0 ) else : l . append ( 0 ) NEW_LINE for i in range ( 0 , len ( arr ) ) : print ( * l [ i ] ) NEW_LINE"],"references":["for s in [ * open ( 0 ) ] [ 2 : : 2 ] : NEW_LINE INDENT b = [ 0 ] ; NEW_LINE r = 0 NEW_LINE for x in s . split ( ) : b += - 1 , ; b [ max ( - len ( b ) , ~ int ( x ) ) ] += 1 NEW_LINE for x in b [ : - 1 ] : r += x ; print ( + ( r > 0 ) ) NEW_LINE DEDENT","T = int ( input ( ) ) NEW_LINE for t in range ( T ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = [ 0 ] * n NEW_LINE b [ n - 1 ] = a [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT b [ i ] = max ( b [ i + 1 ] - 1 , a [ i ] ) NEW_LINE DEDENT print ( \" ▁ \" . join ( [ ( \"0\" , \"1\" ) [ e > 0 ] for e in b ] ) ) NEW_LINE DEDENT","for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT b = max ( b , a [ i ] ) NEW_LINE a [ i ] = 1 if b > 0 else 0 NEW_LINE b -= 1 NEW_LINE DEDENT print ( * a ) NEW_LINE DEDENT"],"bleu":0.5007431423927139,"rouge_l":0.5784245310126842}
{"id":412,"predictions":["from math import * import sysinput = sys . stdin . readlinea = int ( input ( ) ) for x in range ( a ) : b = int ( input ( ) ) c = list ( map ( int , input ( ) . split ( ) ) ) j = list ( set ( c ) ) n = 0 d = { } for z in range ( len ( j ) ) : if j [ z ] & 1 == 0 : d [ j [ z ] ] = 1   j . sort ( ) for y in range ( len ( j ) ) : if j [ y ] & 1 == 0 : j [ y ] = int ( j [ y ] \/ 2 ) n += 1 while ( j [ y ] & 1 == 0 and d . get ( j [ y ] ) == None ) : d [ j [ y ] ] = 1 j [ y ] = int ( j [ y ] \/ 2 ) n += 1   print ( n ) NEW_LINE"],"references":["import sys   def main ( ) :   for _ in range ( int ( sys . stdin . readline ( ) . strip ( ) ) ) : n = int ( sys . stdin . readline ( ) . strip ( ) ) arr = list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) i = 0 while i < n and arr [ i ] >= i : i += 1 j = n - 1 while j >= 0 and arr [ j ] >= ( n - j - 1 ) : j -= 1 if ( i - j ) == 1 and arr [ i ] == arr [ j ] : print ( ' No ' ) elif i > j : print ( \" Yes \" ) else : print ( \" No \" )   main ( ) NEW_LINE","for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) ; arr = list ( map ( int , input ( ) . split ( ) ) ) if n % 2 == 1 : count = 0 arr1 = [ 0 ] * n ; i = 0 ; j = n - 1 ; flag = True while i <= j : arr1 [ i ] = count arr1 [ j ] = count count += 1 ; i += 1 ; j -= 1 NEW_LINE","for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) ; arr = list ( map ( int , input ( ) . split ( ) ) ) ; k = ( n ) \/\/ 2 ; flag = True maxx = max ( arr [ n \/\/ 2 ] , arr [ n \/\/ 2 - 1 ] ) minn = min ( arr [ n \/\/ 2 ] , arr [ n \/\/ 2 - 1 ] ) if n % 2 == 0 and ( maxx < k or minn < k - 1 ) : print ( \" NO \" ) ; continue for i in range ( ( n + 1 ) \/\/ 2 ) : if arr [ i ] >= i and arr [ n - i - 1 ] >= i : continue else : print ( \" NO \" ) ; flag = False ; break if flag : print ( \" YES \" )   NEW_LINE"],"bleu":0.24622248228132884,"rouge_l":0.4470928800197093}
{"id":413,"predictions":["d = [ ] score = 0 while True : try : line = input ( ) except : break if line [ 0 ] == ' : s = line [ 1 : ] d . append ( s ) s = line [ : ] d . append ( s ) for i in range ( len ( s ) ) : if s [ i ] == ' : s . pop ( i ) else : s . append ( s [ i ] ) score += 1 breakprint ( score ) NEW_LINE"],"references":["import syss1 , s2 = input ( ) . split ( \" : \" ) def convert ( n , base ) : ans = 0 for i in range ( len ( n ) ) : x = 0 if n [ i ] . isalpha ( ) : x = int ( ord ( n [ i ] ) - ord ( ' A ' ) + 10 ) else : x = int ( n [ i ] ) ans += x * pow ( base , len ( n ) - i - 1 ) return answork = [ ] minm = 0 for c in s1 + s2 : if c . isalpha ( ) : minm = max ( minm , ord ( c ) - ord ( ' A ' ) + 10 ) else : minm = max ( minm , int ( c ) )   for base in range ( max ( minm + 1 , 2 ) , 60 ) : if convert ( s1 , base ) < 24 and convert ( s2 , base ) < 60 : work . append ( base ) else : breakif len ( work ) == 0 : print ( 0 ) elif ( len ( s1 ) == 1 or s1 [ : len ( s1 ) - 1 ] == '0' * ( len ( s1 ) - 1 ) ) and ( len ( s2 ) == 1 or s2 [ : len ( s2 ) - 1 ] == '0' * ( len ( s2 ) - 1 ) ) : print ( - 1 ) else : print ( \" ▁ \" . join ( map ( str , work ) ) ) NEW_LINE","def val ( c ) : if ' A ' <= c <= ' Z ' : return ord ( c ) - 65 + 10 else : return int ( c )   def calc ( h , b ) : ans = 0 i = 0 for c in h [ : : - 1 ] : v = val ( c ) ans += int ( v ) * ( b ** i ) i += 1 return ans     h , m = [ x for x in input ( ) . split ( \" : \" ) ]   min_base = - 1 for c in h : min_base = max ( min_base , val ( c ) + 1 ) for c in m : min_base = max ( min_base , val ( c ) + 1 )   NEW_LINE","import sysfrom functools import lru_cache , cmp_to_keyfrom heapq import merge , heapify , heappop , heappushfrom math import ceil , floor , gcd , fabs , factorial , fmod , sqrt , inf , log , pi , sinfrom collections import defaultdict as dd , deque , Counter as Cfrom itertools import combinations as comb , permutations as permfrom bisect import bisect_left as bl , bisect_right as br , bisectfrom time import perf_counterfrom fractions import Fraction NEW_LINE"],"bleu":0.2337272442491883,"rouge_l":0.2648519056878032}
{"id":414,"predictions":["import math , sysfrom collections import defaultdict , dequeimport bisect as bidef yes ( ) : print ( ' YES ' ) def no ( ) : print ( ' NO ' ) def I ( ) : return ( int ( sys . stdin . readline ( ) ) ) def In ( ) : return ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) def Sn ( ) : return sys . stdin . readline ( ) . strip ( ) def Pr ( x ) : sys . stdout . write ( str ( x ) + ' \\n ' ) NEW_LINE"],"references":["def solution ( ) : n , k = map ( int , input ( ) . split ( ) )   arr = list ( map ( int , input ( ) . split ( ) ) )   k -= 1 num = arr [ k ] for i in range ( k , n ) : if arr [ i ] != num : print ( - 1 ) return   curr = k - 1 while curr >= 0 and arr [ curr ] == num : curr -= 1   \t   print ( curr + 1 )     return         solution ( ) NEW_LINE","n , k = map ( int , input ( ) . split ( ) ) x = [ * map ( int , input ( ) . split ( ) ) ] f = x [ k - 1 ] if len ( set ( x [ k - 1 : ] ) ) != 1 : print ( - 1 ) elif k == 1 or len ( set ( x ) ) == 1 : print ( 0 ) else : print ( max ( [ i for i , j in enumerate ( x ) if j != f ] ) + 1 )   NEW_LINE","import sys   inp = sys . stdin . readlines ( ) ; ii = 0 out = [ ]   n , k = map ( int , inp [ ii ] . split ( ) ) ii += 1   nums = [ int ( bruh ) for bruh in inp [ ii ] . split ( ) ] ii += 1   if len ( set ( nums ) ) == 1 : print ( 0 ) exit ( )   bruhytle = list ( range ( k - 1 ) ) [ : : - 1 ] if len ( set ( nums [ k - 1 : ] ) ) == 1 : for num in bruhytle : if nums [ num ] != nums [ k - 1 ] : print ( num + 1 ) exit ( ) else : print ( - 1 )   NEW_LINE"],"bleu":0.219879631621263,"rouge_l":0.3224669603524229}
{"id":415,"predictions":["s = input ( ) ans = 0 for i in range ( len ( s ) ) : x = s [ i ] for j in range ( i + 1 , len ( s ) , 2 ) : if s [ j ] == ' R ' : ans += 1 if s [ i ] == ' U ' : ans += 1 print ( ans ) NEW_LINE"],"references":["a = input ( ) b = input ( ) c = 8   print ( max ( max ( ord ( a [ 0 ] ) , ord ( b [ 0 ] ) ) - min ( ord ( a [ 0 ] ) , ord ( b [ 0 ] ) ) , max ( int ( a [ 1 ] ) , int ( b [ 1 ] ) ) - min ( int ( a [ 1 ] ) , int ( b [ 1 ] ) ) ) ) d = ord ( a [ 0 ] ) - ord ( b [ 0 ] ) e = int ( a [ 1 ] ) - int ( b [ 1 ] ) while c > 0 : c -= 1 if d < 0 : if d != 0 : d += 1 print ( \" R \" , end = \" \" ) if d > 0 : print ( \" L \" , end = \" \" ) d -= 1 if e < 0 : print ( \" U \" , end = \" \" ) e += 1 if e > 0 : e -= 1 print ( \" D \" , end = \" \" ) print ( )       NEW_LINE","a = list ( input ( ) ) b = list ( input ( ) )     x = \" D \" if a [ 1 ] > b [ 1 ] else ' U ' y = \" L \" if a [ 0 ] > b [ 0 ] else ' R '     m = abs ( ord ( a [ 0 ] ) - ord ( b [ 0 ] ) ) n = abs ( ord ( a [ 1 ] ) - ord ( b [ 1 ] ) )     c = max ( m , n ) print ( c ) j = y + x   for _ in range ( min ( m , n ) ) : print ( j ) mini = min ( m , n )   m -= minin -= mini     for _ in range ( m ) : print ( y ) for _ in range ( n ) : print ( x ) NEW_LINE","map1 = { ' a ' : 1 , ' b ' : 2 , ' c ' : 3 , ' d ' : 4 , ' e ' : 5 , ' f ' : 6 , ' g ' : 7 , ' h ' : 8 }   def path ( p , q , p1 , p2 ) : print ( p + q ) for i in range ( p ) : print ( p1 ) for i in range ( q ) : print ( p2 )   s = input ( ) t = input ( ) x = map1 [ s [ 0 ] ] - map1 [ t [ 0 ] ] y = int ( s [ 1 ] ) - int ( t [ 1 ] )   if x > 0 : if y > 0 : z = abs ( x - y ) if x < y : path ( x , z , ' LD ' , ' D ' ) else : path ( y , z , ' LD ' , ' L ' ) elif y < 0 : y = abs ( y ) z = abs ( x - y ) if x < y : path ( x , z , ' LU ' , ' U ' ) else : path ( y , z , ' LU ' , ' L ' ) else : path ( y , x , None , ' L ' ) elif x < 0 : x = abs ( x ) if y > 0 : z = abs ( x - y ) if x < y : path ( x , z , ' RD ' , ' D ' ) else : path ( y , z , ' RD ' , ' R ' ) elif y < 0 : y = abs ( y ) z = abs ( x - y ) if x < y : path ( x , z , ' RU ' , ' U ' ) else : path ( y , z , ' RU ' , ' R ' ) else : path ( y , x , None , ' R ' ) else : if y > 0 : path ( x , y , None , ' D ' ) elif y < 0 : path ( x , abs ( y ) , None , ' U ' ) else : print ( 0 ) NEW_LINE"],"bleu":0.08020421410321196,"rouge_l":0.2233772853482851}
{"id":416,"predictions":["import sys   input = sys . stdin . readline   r = 10000   for _ in range ( r ) :   a , b = map ( int , input ( ) . split ( ) ) a *= 10   print ( a \/\/ b )   NEW_LINE"],"references":["def f ( t ) : z = 1.000000011 p = 1 while t : if t % 2 : t -= 1 p *= z else : t \/\/= 2 z *= z return pn , t = map ( int , input ( ) . split ( ) ) print ( n * f ( t ) ) NEW_LINE","a , b = map ( int , input ( ) . split ( ) ) print ( a * ( 1.000000011 ) ** b ) NEW_LINE","n , x = map ( int , input ( ) . split ( ) ) print ( n * ( 1.000000011 ** x ) ) NEW_LINE"],"bleu":0.42896152682917044,"rouge_l":0.5906690140845071}
{"id":417,"predictions":["import math , sysfrom collections import defaultdict , dequeimport bisect as bidef yes ( ) : print ( ' YES ' ) def no ( ) : print ( ' NO ' ) def I ( ) : return ( int ( sys . stdin . readline ( ) ) ) def In ( ) : return ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) def Sn ( ) : return sys . stdin . readline ( ) . strip ( ) def Pr ( x ) : sys . stdout . write ( str ( x ) + ' \\n ' ) NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) ; a = list ( map ( int , input ( ) . split ( ) ) )   b = [ ( list ( map ( int , input ( ) . split ( ) ) ) ) for i in range ( m ) ]   count = 0 for i in range ( m ) : sum = 0 ; for j in range ( b [ i ] [ 0 ] - 1 , b [ i ] [ 1 ] ) : sum += a [ j ]   if ( sum > 0 ) : count += sum     print ( count ) NEW_LINE","def mex ( lst , blanck ) : ans = 0 for i in blanck : ans = max ( ans , ans + sum ( lst [ i [ 0 ] : i [ 1 ] + 1 ] ) ) return ans   a , b = map ( int , input ( ) . strip ( ) . split ( ) ) blanck = [ ] lst = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) for i in range ( b ) : x , y = map ( int , input ( ) . strip ( ) . split ( ) ) blanck . append ( [ x - 1 , y - 1 ] ) print ( mex ( lst , blanck ) ) NEW_LINE","n , m = map ( int , input ( ) . strip ( ) . split ( ' ▁ ' ) ) lst = list ( map ( int , input ( ) . strip ( ) . split ( ' ▁ ' ) ) ) s = 0 for i in range ( m ) : l , r = map ( int , input ( ) . strip ( ) . split ( ' ▁ ' ) ) s1 = 0 s1 = sum ( lst [ l - 1 : r ] ) if s1 > 0 : s += s1print ( s ) NEW_LINE"],"bleu":0.23156990419964915,"rouge_l":0.39920532897043354}
{"id":418,"predictions":["import mathn = int ( input ( ) ) NEW_LINE"],"references":["n = int ( input ( ) ) m = list ( map ( int , input ( ) . split ( ) ) ) gc = m [ 0 ] import mathfor i in range ( 1 , n ) : gc = math . gcd ( gc , m [ i ] ) k = max ( m ) prime = [ 0 ] * ( k + 1 ) pfac = [ 0 ] * ( k + 1 ) for i in range ( 2 , k + 1 ) : if prime [ i ] == 0 : for j in range ( i * i , k + 1 , i ) : prime [ j ] = ifor i in range ( 1 , k + 1 ) : if not prime [ i ] : prime [ i ] = ifor i in range ( n ) : v = m [ i ] \/\/ gc while v > 1 : fac = prime [ v ] pfac [ fac ] += 1 while v % fac == 0 : v \/\/= facma = 0 ma = max ( pfac ) if ma : print ( n - ma ) else : print ( - 1 ) NEW_LINE","n = int ( input ( ) ) m = list ( map ( int , input ( ) . split ( ) ) ) gc = m [ 0 ] import mathfor i in range ( 1 , n ) : gc = math . gcd ( gc , m [ i ] ) k = max ( m ) prime = [ 0 ] * ( k + 1 ) pfac = [ 0 ] * ( k + 1 ) for i in range ( 2 , k + 1 ) : if prime [ i ] == 0 : for j in range ( i * i , k + 1 , i ) : prime [ j ] = ifor i in range ( 1 , k + 1 ) : if not prime [ i ] : prime [ i ] = ifor i in range ( n ) : v = m [ i ] \/\/ gc while v > 1 : fac = prime [ v ] pfac [ fac ] += 1 while v % fac == 0 : v \/\/= facma = 0 ma = max ( pfac ) if ma : print ( n - ma ) else : print ( - 1 ) NEW_LINE"],"bleu":8.39276741407062e-10,"rouge_l":0.06080239222526788}
{"id":419,"predictions":["from math import factorial as fdef primes ( n ) : sieve = [ True ] * n for i in range ( 3 , int ( n ** 0.5 ) + 1 , 2 ) : if sieve [ i ] : sieve [ i * i : : 2 * i ] = [ False ] * ( ( n - i * i - 1 ) \/\/ ( 2 * i ) + 1 ) return [ 2 ] + [ i for i in range ( 3 , n , 2 ) if sieve [ i ] ] p = primes ( 31627 ) s = [ 0 ] * ( 31623 ) s1 = { } def factorize ( n ) : for i in p : if n <= 1 : return 56 while n % i == 0 : s [ p . index ( i ) ] += 1 n \/\/= i if n > 1 : if n in s1 : s1 [ n ] += 1 else : s1 [ n ] = 1 n = int ( input ( ) ) for i in map ( int , input ( ) . split ( ) ) : factorize ( n ) s = list ( filter ( lambda a : a != 0 , s ) ) for i in s1 . values ( ) : s . append ( i ) ans = 1 for i in s : ans *= f ( i + n - 1 ) \/\/ ( f ( n - 1 ) * f ( i ) ) print ( int ( ans ) ) NEW_LINE"],"references":["import mathn , k = map ( int , input ( ) . split ( ) )   result = [ ]   while ( n % 2 == 0 ) : result . append ( 2 ) n = n \/\/ 2   NEW_LINE","n , k = map ( int , input ( ) . split ( ) ) arr = [ ] stor = [ ] i = 1 for j in range ( 2 , n , 1 ) : if n % j == 0 : while n % j == 0 and i <= k - 1 : arr . append ( j ) n \/\/= j i += 1   for l in range ( k - 1 , k ) : if n != 1 : arr . append ( n )           if len ( arr ) < k : print ( \" - 1\" ) else : print ( * arr ) NEW_LINE","import sysfrom math import sqrt   def isPrime ( n ) : i = 2 while i * i <= n :   if n % i == 0 : return False i += 1 return True   def primes ( n ) : arr = [ ] nums = 0 for i in range ( 2 , 10000 ) : NEW_LINE"],"bleu":0.1563950603659136,"rouge_l":0.3547129362899445}
{"id":420,"predictions":["import sysimport collections as ccinput = sys . stdin . buffer . readlineI = lambda : list ( map ( int , input ( ) . split ( ) ) ) prev = cc . defaultdict ( int ) for tc in range ( int ( input ( ) ) ) : x , y = I ( ) div = set ( ) for i in range ( 1 , int ( x ** 0.5 ) + 1 ) : if x % i == 0 : div . add ( i ) div . add ( x \/\/ i ) ans = 0 now = tc + 1 for i in div : if now - prev [ i ] > y : ans += 1 prev [ i ] = now print ( ans ) NEW_LINE"],"references":["for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) li = list ( map ( int , input ( ) ) ) od = 0 ev = 0 res = [ ] cnt = 0 for i in range ( n ) : if li [ i ] % 2 == 0 : res . append ( li [ i ] ) else : cnt += 1 res . append ( li [ i ] ) if cnt == 2 : break if res [ - 1 ] % 2 != 0 and cnt >= 2 : print ( * res , sep = ' ' ) else : print ( - 1 )   NEW_LINE","odd = [ '1' , '3' , '5' , '7' , '9' ] for i in range ( int ( input ( ) ) ) : size = int ( input ( ) ) nums = input ( ) x = [ j for j in nums if j in odd ] if len ( x ) <= 1 : print ( - 1 ) else : print ( ' ' . join ( x [ : 2 ] ) ) NEW_LINE"],"bleu":0.25805227167717126,"rouge_l":0.4047719262287582}
{"id":421,"predictions":["import math , sys , bisect , heapq , osfrom collections import defaultdict , Counter , dequefrom itertools import groupby , accumulatefrom functools import lru_cache NEW_LINE"],"references":["import osimport sysfrom io import BytesIO , IOBaseBUFSIZE = 8192 class FastIO ( IOBase ) : newlines = 0 def __init__ ( self , file ) : self . _fd = file . fileno ( ) self . buffer = BytesIO ( ) self . writable = \" x \" in file . mode or \" r \" not in file . mode self . write = self . buffer . write if self . writable else None def read ( self ) : while True : b = os . read ( self . _fd , max ( os . fstat ( self . _fd ) . st_size , BUFSIZE ) ) if not b : break ptr = self . buffer . tell ( ) self . buffer . seek ( 0 , 2 ) , self . buffer . write ( b ) , self . buffer . seek ( ptr ) self . newlines = 0 return self . buffer . read ( ) def readline ( self ) : while self . newlines == 0 : b = os . read ( self . _fd , max ( os . fstat ( self . _fd ) . st_size , BUFSIZE ) ) self . newlines = b . count ( b \" \\n \" ) + ( not b ) ptr = self . buffer . tell ( ) self . buffer . seek ( 0 , 2 ) , self . buffer . write ( b ) , self . buffer . seek ( ptr ) self . newlines -= 1 return self . buffer . readline ( ) def flush ( self ) : if self . writable : os . write ( self . _fd , self . buffer . getvalue ( ) ) self . buffer . truncate ( 0 ) , self . buffer . seek ( 0 ) class IOWrapper ( IOBase ) : def __init__ ( self , file ) : self . buffer = FastIO ( file ) self . flush = self . buffer . flush self . writable = self . buffer . writable self . write = lambda s : self . buffer . write ( s . encode ( \" ascii \" ) ) self . read = lambda : self . buffer . read ( ) . decode ( \" ascii \" ) self . readline = lambda : self . buffer . readline ( ) . decode ( \" ascii \" ) sys . stdin , sys . stdout = IOWrapper ( sys . stdin ) , IOWrapper ( sys . stdout ) input = lambda : sys . stdin . readline ( ) . rstrip ( \" \\n \" ) NEW_LINE","import math   import osfrom io import BytesIO , IOBaseimport sys   NEW_LINE","import math , sys , bisect , heapqfrom collections import defaultdict , Counter , dequefrom itertools import groupby , accumulate NEW_LINE"],"bleu":0.6450664618828738,"rouge_l":0.8243243243243243}
{"id":422,"predictions":["N = int ( input ( ) ) NEW_LINE ls = [ i for i in range ( 1 , N + 1 ) ] NEW_LINE import itertools NEW_LINE"],"references":["n = int ( input ( ) ) q = n \/\/ 3 r = n % 3 if ( r == 0 ) : if ( q % 3 != 0 ) : print ( q , q , q ) else : print ( q + 2 , q - 1 , q - 1 ) elif ( r == 1 ) : if ( q % 3 != 0 and ( q + 1 ) % 3 != 0 ) : print ( q , q , q + 1 ) elif ( q % 3 != 0 and ( q + 1 ) % 3 == 0 ) : print ( q - 1 , q , q + 2 ) elif ( q % 3 == 0 and ( q + 1 ) % 3 != 0 ) : print ( q - 1 , q + 1 , q + 1 ) else : if ( q % 3 != 0 and ( q + 2 ) % 3 != 0 ) : print ( q , q , q + 2 ) elif ( q % 3 != 0 and ( q + 2 ) % 3 == 0 ) : print ( q , q + 1 , q + 1 ) elif ( q % 3 == 0 and ( q + 2 ) % 3 != 0 ) : print ( q - 1 , q + 1 , q + 2 ) NEW_LINE","n = int ( input ( ) ) if ( ( n - 2 ) % 3 == 0 ) : a = 1 b = 2 c = n - 3 else : a = 1 b = 1 c = n - 2 print ( a , b , c ) NEW_LINE","n = int ( input ( ) )   if ( ( n - 2 ) % 3 ) : print ( \"1 ▁ 1\" , n - 2 ) else : print ( \"1 ▁ 2\" , n - 3 ) NEW_LINE"],"bleu":0.19870151698695165,"rouge_l":0.3226478602340118}
{"id":423,"predictions":["from collections import defaultdict , deque , Counterfrom sys import stdin , stdoutfrom heapq import heappush , heappopimport mathimport ioimport osimport mathimport bisect   NEW_LINE"],"references":["n = int ( input ( ) ) p , s , t = 1 , 0 , \"1\" for x in input ( ) . split ( ) : if x == \"0\" : print ( 0 ) quit ( ) elif x == \"1\" + \"0\" * ( len ( x ) - 1 ) : s += len ( x ) - 1 else : t = str ( x ) print ( t + \"0\" * s ) NEW_LINE","    n = int ( input ( ) ) arr = input ( ) . split ( )   zeros = 0 a = 0   for i in arr : x = i . count ( '0' ) y = i . count ( '1' ) if ( i == '1' ) : continue   elif ( i == '0' ) : print ( 0 ) exit ( 0 )   elif ( y == 1 and x == len ( i ) - 1 ) : zeros += x   else : a = i   NEW_LINE","int ( input ( ) ) x = ' ' zero = 0 for s in input ( ) . split ( ) : if s == '0' : print ( 0 ) , exit ( ) elif s == '1' + '0' * ( len ( s ) - 1 ) : zero += len ( s ) - 1 else : x = sprint ( x + '0' * zero if len ( x ) > 0 else '1' + '0' * zero ) NEW_LINE"],"bleu":0.005705868643906264,"rouge_l":0.0844173816772765}
{"id":424,"predictions":["t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( * arr [ n - 1 ] ) NEW_LINE"],"references":["for i in [ * open ( 0 ) ] [ 1 : ] : print ( int ( i ) - 1 , 1 ) NEW_LINE","T = int ( input ( ) ) for t in range ( T ) : x = int ( input ( ) ) print ( 1 , x - 1 ) NEW_LINE","t = int ( input ( ) ) for i in range ( t ) : n = int ( input ( ) ) print ( 1 , n - 1 ) NEW_LINE"],"bleu":0.4328376105298064,"rouge_l":0.7140070230198986}
{"id":425,"predictions":["import sysimport mathfrom collections import defaultdict , Counter , deque   NEW_LINE"],"references":["import mathfrom collections import deque     def Work ( ) : n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) IDX = [ 0 ] * n   for i in range ( n ) : IDX [ a [ i ] - 1 ] = i   l , r = n , 0 s = \" \"   for i in range ( n ) : l , r = min ( l , IDX [ i ] ) , max ( r , IDX [ i ] ) s += '1' if r - l == i else '0'   print ( s )     if __name__ == \" _ _ main _ _ \" : t = int ( input ( ) ) for _ in range ( t ) : Work ( ) NEW_LINE","import sysimport mathfrom collections import defaultdict , Counter , deque   NEW_LINE","t = int ( input ( ) )   for i in range ( t ) : n = int ( input ( ) ) lista = list ( map ( int , input ( ) . split ( ) ) ) pos = { } for j in range ( n ) : pos [ lista [ j ] ] = j l = r = pos [ 1 ] ans = \"1\" for j in range ( 2 , n + 1 ) : l = min ( l , pos [ j ] ) r = max ( r , pos [ j ] ) if ( r - l + 1 == j ) : ans += \"1\" else : ans += \"0\" print ( ans ) NEW_LINE"],"bleu":1.0,"rouge_l":1.0}
{"id":426,"predictions":["from collections import defaultdict , deque , Counterfrom sys import stdin , stdoutfrom heapq import heappush , heappopimport mathimport ioimport osimport mathimport bisect   NEW_LINE"],"references":["( k , n , m ) = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( k ) : s = input ( ) NEW_LINE a . append ( [ ] ) NEW_LINE for j in range ( n ) : a [ - 1 ] . append ( list ( input ( ) ) ) NEW_LINE s = input ( ) ( x , y ) = map ( int , input ( ) . split ( ) ) NEW_LINE x -= 1 NEW_LINE y -= 1   start = ( 0 , x , y ) NEW_LINE sosed = set ( ) NEW_LINE sosed . add ( start ) NEW_LINE posetil = set ( ) NEW_LINE posetil . add ( start ) NEW_LINE while len ( sosed ) > 0 : sosed2 = set ( ) NEW_LINE for i in sosed : for NEW_LINE dk in [ - 1 , 0 , 1 ] : NEW_LINE for dx in [ - 1 , 0 , 1 ] : for NEW_LINE dy in [ - 1 , 0 , 1 ] : NEW_LINE if abs ( dk ) + abs ( dx ) + abs ( dy ) == 1 : if NEW_LINE ( i [ 0 ] + dk < k ) and ( i [ 0 ] + dk >= 0 ) and ( i [ 1 ] + dx < n ) and ( i [ 1 ] + dx >= 0 ) and ( i [ 2 ] + dy < m ) and ( i [ 2 ] + dy >= 0 ) : NEW_LINE if a [ i [ 0 ] + dk ] [ i [ 1 ] + dx ] [ i [ 2 ] + dy ] == ' . ' : if NEW_LINE ( i [ 0 ] + dk , i [ 1 ] + dx , i [ 2 ] + dy ) in posetil : NEW_LINE continue else : posetil . add ( ( i [ 0 ] + dk , i [ 1 ] + dx , i [ 2 ] + dy ) ) NEW_LINE sosed2 . add ( ( i [ 0 ] + dk , i [ 1 ] + dx , i [ 2 ] + dy ) ) NEW_LINE sosed = sosed2 . copy ( ) NEW_LINE print ( len ( posetil ) ) NEW_LINE","from collections import deque   k , n , m = map ( int , input ( ) . split ( ) ) NEW_LINE input ( )   allowed = set ( ) NEW_LINE for i in range ( k ) : for NEW_LINE j in range ( n ) : NEW_LINE for l , l_value in enumerate ( input ( ) ) : if NEW_LINE l_value == ' . ' : allowed . add ( ( i , j , l ) ) NEW_LINE input ( )   count0 = len ( allowed )         q = deque ( ) NEW_LINE x0 , y0 = map ( int , input ( ) . split ( ) ) NEW_LINE q . append ( ( 0 , x0 - 1 , y0 - 1 ) ) NEW_LINE allowed . remove ( q [ 0 ] )   dir = [ ( 1 , 0 , 0 ) , ( - 1 , 0 , 0 ) , ( 0 , 1 , 0 ) , ( 0 , - 1 , 0 ) , ( 0 , 0 , 1 ) , ( 0 , 0 , - 1 ) ]   while len ( q ) : x , y , z = q . popleft ( ) NEW_LINE for dx , dy , dz in dir : nt = x + dx , y + dy , z + dz NEW_LINE if nt in allowed : q . append ( nt ) NEW_LINE allowed . discard ( nt )   if count0 == 0 : NEW_LINE INDENT print ( 0 ) else : NEW_LINE print ( count0 - len ( allowed ) ) NEW_LINE DEDENT","from collections import deque   k , n , m = map ( int , input ( ) . split ( ) ) NEW_LINE input ( )   allowed = set ( ) NEW_LINE for i in range ( k ) : for NEW_LINE j in range ( n ) : NEW_LINE for l , l_value in enumerate ( input ( ) ) : if NEW_LINE l_value == ' . ' : allowed . add ( ( i , j , l ) ) NEW_LINE input ( )   count0 = len ( allowed )         q = deque ( ) NEW_LINE x0 , y0 = map ( int , input ( ) . split ( ) ) NEW_LINE q . append ( ( 0 , x0 - 1 , y0 - 1 ) ) NEW_LINE allowed . remove ( q [ 0 ] )   dir = [ ( 1 , 0 , 0 ) , ( - 1 , 0 , 0 ) , ( 0 , 1 , 0 ) , ( 0 , - 1 , 0 ) , ( 0 , 0 , 1 ) , ( 0 , 0 , - 1 ) ]   while len ( q ) : x , y , z = q . popleft ( ) NEW_LINE for dx , dy , dz in dir : nt = x + dx , y + dy , z + dz NEW_LINE if nt in allowed : q . append ( nt ) NEW_LINE allowed . discard ( nt )   print ( count0 - len ( allowed ) ) NEW_LINE"],"bleu":5.382915368143856e-6,"rouge_l":0.05756346135698783}
{"id":427,"predictions":["t = int ( input ( ) ) for _ in range ( t ) : s = input ( ) l = len ( s ) if ( len ( s ) == len ( l ) ) : print ( - 1 ) else : ans = ' ' for i in range ( len ( s ) ) : if ( s [ i ] != l [ len ( s ) - 1 ] ) : ans = ans + s [ len ( s ) - 1 ] print ( ans ) NEW_LINE"],"references":["t = int ( input ( ) )   for i in range ( t ) : p = input ( ) h = input ( ) cnts = { } for c in p : cnts [ c ] = cnts . get ( c , 0 ) + 1 yes = False for i in range ( len ( h ) ) : seq = { } for c in h [ i : ] : yes |= seq == cnts if c not in cnts : seq = { } else : seq [ c ] = seq . get ( c , 0 ) + 1 yes |= seq == cnts print ( \" YES \" if yes else \" NO \" ) NEW_LINE","n = int ( input ( ) ) for i in range ( n ) : l = list ( input ( ) ) l1 = list ( input ( ) ) if len ( l1 ) < len ( l ) : print ( \" NO \" ) elif len ( l ) == len ( l1 ) : if sorted ( l ) == sorted ( l1 ) : print ( \" YES \" ) else : print ( \" NO \" ) else : flag = False for i in range ( len ( l1 ) - len ( l ) + 1 ) : l2 = l1 [ i : i + len ( l ) ] if sorted ( l ) == sorted ( l2 ) : print ( \" YES \" ) flag = True break if flag == False : print ( \" NO \" ) NEW_LINE","r = lambda : list ( map ( int , input ( ) . split ( ) ) ) t = int ( input ( ) ) for _ in range ( t ) : a = list ( input ( ) ) b = list ( input ( ) )   a . sort ( ) f = False for i in range ( len ( b ) - len ( a ) + 1 ) : if sorted ( b [ i : i + len ( a ) ] ) == a : f = True break     print ( \" YES \" if f else \" NO \" ) NEW_LINE"],"bleu":0.36605812936987836,"rouge_l":0.5185781181279591}
{"id":428,"predictions":["n = int ( input ( ) ) print ( [ 1 , 0 ] [ n % 2 == 0 ] ) NEW_LINE"],"references":["v1 , v2 = map ( int , input ( ) . split ( ) ) t , d = map ( int , input ( ) . split ( ) ) t -= 1 u = [ 0 ] * ( t + 1 ) u [ 0 ] = v1for i in range ( 1 , t + 1 ) : u [ i ] = min ( u [ i - 1 ] + d , v2 + ( t - i ) * d ) ans = 0 for i in range ( 0 , t + 1 ) : ans += u [ i ] print ( ans ) NEW_LINE","import sysimport mathfrom collections import defaultdictimport itertools   MAXNUM = math . infMINNUM = - 1 * math . inf     def getInts ( ) : return map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( \" ▁ \" ) )     def getString ( ) : return sys . stdin . readline ( ) . rstrip ( )     def printOutput ( ans ) : sys . stdout . write ( str ( ans ) + \" \\n \" )     def solve ( v1 , v2 , t , d ) : curTime = 1 totalDistance = 0 curSpeed = v1 while curTime <= t : totalDistance += curSpeed for acc in range ( d , - d - 1 , - 1 ) : if curSpeed + acc - ( d * ( t - ( curTime + 1 ) ) ) <= v2 : curSpeed += acc break curTime += 1   return totalDistance     def readinput ( ) : v1 , v2 = getInts ( ) t , d = getInts ( ) printOutput ( solve ( v1 , v2 , t , d ) )     readinput ( ) NEW_LINE","from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"bleu":0.08086554024107348,"rouge_l":0.2982970889425843}
{"id":429,"predictions":["def check_col ( mat , c ) : for r in mat : if not r [ c ] : return 0 return 1   m , n = map ( int , input ( ) . split ( ) ) a = [ [ 0 ] * n for _ in range ( m ) ] b = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] rows , cols = [ ] , [ ] checkedCols = set ( ) for r in range ( m ) : if all ( b [ r ] ) : rows . append ( r ) else : for c in range ( n ) : if b [ r ] [ c ] and c not in checkedCols : checkedCols . add ( c ) if check_col ( b , c ) : cols . append ( c ) else : print ( ' NO ' ) exit ( ) if ( len ( rows ) and len ( rows ) != m and not len ( cols ) ) or ( len ( cols ) and len ( cols ) != n and not len ( cols ) ) : print ( \" NO \" ) exit ( ) if not len ( cols ) and not len ( cols ) : print ( \" YES \" ) for r in a : print ( * \" ) exit ( ) if not len ( cols ) : print ( \" NO \" ) exit ( ) for i in range ( 2 , len ( cols ) ) : print ( \" YES \" ) NEW_LINE"],"references":["n = int ( input ( ) ) a = sorted ( [ int ( x ) for x in input ( ) . split ( ) ] ) s = sum ( a ) if a [ 0 ] != 0 : print ( - 1 ) exit ( 0 ) if s % 3 != 0 : for x in a : if x % 3 == s % 3 : a . remove ( x ) break else : for x in a : if x % 3 : a . remove ( x ) break for x in a : if x % 3 : a . remove ( x ) breakwhile len ( a ) > 1 and a [ - 1 ] == 0 : a . pop ( ) a = a [ : : - 1 ] print ( ' ' . join ( str ( x ) for x in a ) ) NEW_LINE","import osimport sysfrom io import BytesIO , IOBaseimport mathimport itertoolsimport bisectimport heapq NEW_LINE"],"bleu":0.08863093598646599,"rouge_l":0.3144091563708027}
{"id":430,"predictions":["n = int ( input ( ) ) a = int ( input ( ) ) b = int ( input ( ) ) import mathdef extgcd ( a , b ) : NEW_LINE"],"references":["import math   n , a , b = map ( int , input ( ) . split ( ' ▁ ' ) ) rounds = math . log ( n , 2 ) r = int ( rounds ) for i in range ( 1 , int ( rounds ) + 1 ) : a = math . ceil ( a \/ 2 ) b = math . ceil ( b \/ 2 ) if ( a == b ) : if ( i == r ) : print ( ' Final ! ' ) break else : print ( i ) break NEW_LINE","n , a , b = map ( int , input ( ) . split ( ) )   a , b , r = a - 1 , b - 1 , 0   while a != b :   a \/\/= 2   b \/\/= 2   r += 1   print ( r if 2 ** r < n else ' Final ! ' )       NEW_LINE","a , b , c = map ( int , input ( ) . split ( ) ) z = [ * range ( 1 , a + 1 ) ] b , c = sorted ( [ b , c ] ) s = 0 ; k = awhile 1 : p = [ ] for i in range ( 0 , k , 2 ) : if z [ i ] == b and z [ i + 1 ] == c : s += 1 if len ( z ) == 2 : print ( \" Final ! \" ) else : print ( s ) exit ( ) elif z [ i ] == b : p += [ z [ i ] ] elif z [ i + 1 ] == b : p += [ z [ i + 1 ] ] elif z [ i ] == c : p += [ z [ i ] ] elif z [ i + 1 ] == c : p += [ z [ i + 1 ] ] else : p += [ z [ i ] ] k \/\/= 2 ; z = p ; s += 1   NEW_LINE"],"bleu":0.12372520417560848,"rouge_l":0.3065996503496503}
{"id":431,"predictions":["for ti in range ( int ( input ( ) ) ) : print ( int ( input ( ) \/\/ 2 ) ) NEW_LINE"],"references":["for x in range ( int ( input ( ) ) ) : n = int ( input ( ) ) if n % 2 == 0 : print ( n \/\/ 2 ) else : print ( ( n \/\/ 2 ) + 1 ) NEW_LINE","t = int ( input ( ) ) for i in range ( t ) : n = int ( input ( ) ) print ( ( n + 1 ) \/\/ 2 ) NEW_LINE","t = int ( input ( ) ) for i in range ( t ) : x = int ( input ( ) ) if x % 2 == 0 and x > 2 : print ( x \/\/ 2 ) elif x == 1 or x == 2 : print ( 1 ) else : print ( ( x \/\/ 2 ) + 1 ) NEW_LINE"],"bleu":0.49372495419810497,"rouge_l":0.6198614318706697}
{"id":432,"predictions":["n = int ( input ( ) ) s = list ( input ( ) ) ans = 0 for i in range ( n ) : if s [ i ] == ' W ' and s [ i + 1 ] == ' W ' : if i % 2 == 0 : ans = ans + 1 print ( ans ) NEW_LINE"],"references":["if __name__ == ' _ _ main _ _ ' : cin = input a = [ cin ( ) for i in range ( 8 ) ] mw , mb = 8 , 8   for c in range ( 8 ) : for r in range ( 8 ) : if a [ r ] [ c ] == \" W \" : mw = min ( mw , r ) if a [ r ] [ c ] != \" . \" : break for r in range ( 7 , - 1 , - 1 ) : if a [ r ] [ c ] == \" B \" : mb = min ( mb , 7 - r ) if a [ r ] [ c ] != \" . \" : break print ( \" AB \" [ mb < mw ] ) NEW_LINE","def on_same_col ( point , arr , flag ) : for p in arr : if ( flag and p [ 0 ] < point [ 0 ] and p [ 1 ] == point [ 1 ] or not flag and p [ 0 ] > point [ 0 ] and p [ 1 ] == point [ 1 ] ) : return True return False   whites = [ ] blacks = [ ] min_white = 10 min_black = 10 for row in range ( 8 ) : row_str = input ( ) for col in range ( 8 ) : if row_str [ col ] == \" W \" : whites . append ( ( row , col ) ) if row_str [ col ] == \" B \" : blacks . append ( ( row , col ) )                           for white in whites : if not on_same_col ( ( white [ 0 ] , white [ 1 ] ) , blacks , True )   \\ and white [ 0 ] < min_white : min_white = white [ 0 ]   for black in blacks : if not on_same_col ( ( black [ 0 ] , black [ 1 ] ) , whites , False )   \\ and 7 - black [ 0 ] < min_black : min_black = 7 - black [ 0 ]     if min_white <= min_black : print ( \" A \" ) else : print ( \" B \" ) NEW_LINE","def STR ( ) : return list ( input ( ) ) def INT ( ) : return int ( input ( ) ) def MAP ( ) : return map ( int , input ( ) . split ( ) ) def MAP2 ( ) : return map ( float , input ( ) . split ( ) ) def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) def STRING ( ) : return input ( ) import stringfrom heapq import heappop , heappushfrom bisect import * from collections import deque , Counterfrom math import * from itertools import permutations , accumulatedx = [ - 1 , 1 , 0 , 0 ] dy = [ 0 , 0 , 1 , - 1 ] NEW_LINE"],"bleu":0.09742716941195333,"rouge_l":0.26431956668923495}
{"id":433,"predictions":["import sysfrom functools import lru_cache , cmp_to_keyfrom heapq import merge , heapify , heappop , heappushfrom math import * from collections import defaultdict as dd , deque , Counter as Cfrom itertools import combinations as comb , permutations as permfrom bisect import bisect_left as bl , bisect_right as br , bisect , insortfrom time import perf_counterfrom fractions import Fractionimport copyfrom copy import deepcopyimport timestarttime = time . time ( ) mod = int ( pow ( 10 , 9 ) + 7 ) mod2 = 998244353   def data ( ) : return sys . stdin . readline ( ) . strip ( ) def out ( * var , end = \" \\n \" ) : sys . stdout . write ( ' ▁ ' . join ( map ( str , var ) ) + end ) def L ( ) : return list ( sp ( ) ) def sl ( ) : return list ( ssp ( ) ) def sp ( ) : return map ( int , data ( ) . split ( ) ) def ssp ( ) : return map ( str , data ( ) . split ( ) ) def l1d ( n , val = 0 ) : return [ val for i in range ( n ) ] def l2d ( n , m , val = 0 ) : return [ l1d ( n , val ) for j in range ( m ) ] try : NEW_LINE"],"references":["while True : try : n , m = list ( map ( int , input ( ) . split ( ) ) ) res = 1 while m % 2 == 0 : res += 1 m \/= 2 print ( res ) except : break NEW_LINE","import mathm , n = map ( int , input ( ) . split ( ) ) while True : NEW_LINE","n , k = map ( int , input ( ) . split ( ) ) l , r = 0 , 2 ** ( n ) - 1   while ( l < r ) : mid = ( l + r ) \/\/ 2 if ( mid == k - 1 ) : print ( n ) break if ( mid < k - 1 ) : l = mid + 1 if ( mid > k - 1 ) : r = mid - 1 n -= 1 else : print ( n ) NEW_LINE"],"bleu":0.06992968489707237,"rouge_l":0.28721888358837744}
{"id":434,"predictions":["for _ in range ( int ( input ( ) ) ) : n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 1 : print ( 0 ) elif n == 2 : print ( 12 ) else : print ( 12 ) NEW_LINE"],"references":["for _ in range ( int ( input ( ) ) ) : h , m = map ( int , input ( ) . split ( ) ) s = 0 s = ( 24 - h - 1 ) * 60 + ( 60 - m ) print ( s ) NEW_LINE","t = int ( input ( ) ) for i in range ( t ) : hh , mm = map ( int , input ( ) . split ( ) ) print ( 60 * 24 - 60 * hh - mm ) NEW_LINE","t = int ( input ( ) ) for i in range ( t ) : h , m = map ( int , input ( ) . split ( ) ) print ( 1440 - ( h * 60 + m ) ) NEW_LINE"],"bleu":0.526303018401305,"rouge_l":0.661645073817415}
{"id":435,"predictions":["for _ in range ( int ( input ( ) ) ) : a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE print ( max ( ( a + b ) , ( c + d ) ) ) NEW_LINE"],"references":["def solve ( a , b , p , q ) : area1 = a * q area2 = a * ( b - q - 1 ) area3 = b * p area4 = b * ( a - p - 1 ) return max ( area1 , area2 , area3 , area4 ) if __name__ == ' _ _ main _ _ ' : S = int ( input ( ) ) for s in range ( S ) : a , b , p , q = tuple ( map ( int , input ( ) . split ( ) ) ) print ( solve ( a , b , p , q ) ) NEW_LINE","r = lambda : list ( map ( int , input ( ) . split ( ) ) ) t = int ( input ( ) ) for _ in range ( t ) : arr = r ( )   dist1 = abs ( arr [ 0 ] - arr [ 2 ] ) - 1 dist2 = abs ( arr [ 1 ] - arr [ 3 ] ) - 1 dist12 = arr [ 2 ] dist22 = arr [ 3 ]     a = dist1 * arr [ 1 ] b = dist12 * arr [ 1 ] c = dist2 * arr [ 0 ] d = dist22 * arr [ 0 ]     print ( max ( a , b , c , d ) ) NEW_LINE","for t in range ( int ( input ( ) ) ) : a , b , x , y = map ( int , input ( ) . split ( ) )   area = max ( b * x , ( a - x - 1 ) * b , a * y , ( b - y - 1 ) * a ) print ( area ) NEW_LINE"],"bleu":0.5180481657139785,"rouge_l":0.6485995850622408}
{"id":436,"predictions":["import sys , mathsys . setrecursionlimit ( 10 ** 8 ) ''' def ▁ fun ( ) : ▁ ▁ ▁ ▁ for ▁ i ▁ in ▁ range ( 16 ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ for ▁ j ▁ in ▁ range ( 4 ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ i & (1 < < j ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( j , end = ' ' ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( ) import ▁ binarytreefrom ▁ collections ▁ import ▁ dequebst ▁ = ▁ binarytree . tree ( height = 4 , is _ perfect = True ) print ( bst ) def ▁ s ( bst ) : ▁ ▁ ▁ ▁ if ▁ bst : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ bst . left , bst . right ▁ = ▁ bst . right , bst . left ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ s ( bst . right ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ s ( bst . left ) s ( bst ) print ( bst ) ''' n , k = map ( int , input ( ) . split ( ) ) lst = [ ] for i in range ( n ) : s = input ( ) lst . append ( s ) for i in range ( n - k + 1 ) : if s [ i ] == ' B ' : lst . append ( s [ i + k ] ) else : lst . append ( s [ n - k + 1 ] ) for i in range ( n ) : if i % 2 == 1 : if s [ i ] == ' W ' : lst . append ( s [ i ] ) if k == 1 : print ( \" YES \" ) for i in range ( n ) : print ( lst [ i ] ) else : print ( \" NO \" ) NEW_LINE"],"references":["import sys   input = sys . stdin . readline   def check ( x , y ) : for i in range ( min ( x [ 0 ] , y [ 0 ] ) , max ( x [ 0 ] , y [ 0 ] ) + 1 ) : if not plan [ i ] [ x [ 1 ] ] == \" B \" : return False for i in range ( min ( x [ 1 ] , y [ 1 ] ) , max ( x [ 1 ] , y [ 1 ] ) + 1 ) : if not plan [ y [ 0 ] ] [ i ] == \" B \" : return False return True   n , m = map ( int , input ( ) . split ( ) ) plan = tuple ( tuple ( i for i in input ( ) . strip ( ) ) for j in range ( n ) ) start = [ ( i , j ) for i in range ( n ) for j in range ( m ) if plan [ i ] [ j ] == \" B \" ] for i in range ( len ( start ) ) : for j in range ( i + 1 , len ( start ) ) : if not check ( start [ i ] , start [ j ] ) and not check ( start [ j ] , start [ i ] ) : print ( \" NO \" ) sys . exit ( ) print ( \" YES \" ) NEW_LINE","import sysinput = sys . stdin . readlinedef exi ( ) : print ( \" NO \" ) sys . exit ( ) I = lambda : list ( map ( int , input ( ) . split ( ) ) ) g = [ ] n , m = I ( ) for i in range ( n ) : g . append ( list ( input ( ) ) ) for i in range ( n ) : temp = 0 for j in range ( 1 , m ) : if g [ i ] [ j - 1 ] != g [ i ] [ j ] : temp += 1 NEW_LINE","import sysinput = sys . stdin . readlinedef exi ( ) : print ( \" NO \" ) sys . exit ( ) I = lambda : list ( map ( int , input ( ) . split ( ) ) ) g = [ ] n , m = I ( ) for i in range ( n ) : g . append ( list ( input ( ) ) ) for i in range ( n ) : temp = 0 for j in range ( 1 , m ) : if g [ i ] [ j - 1 ] != g [ i ] [ j ] : temp += 1 NEW_LINE"],"bleu":0.2091318661126363,"rouge_l":0.39905185595263265}
{"id":437,"predictions":["import sys   input = sys . stdin . readline   sys . setrecursionlimit ( 10 ** 5 + 1 )   n , t = map ( int , input ( ) . split ( ) ) s = [ list ( input ( ) ) for _ in range ( t ) ] l = list ( map ( int , input ( ) . split ( ) ) )   for _ in range ( t ) : s , f = map ( int , input ( ) . split ( ) ) l [ 0 ] += f - 1   print ( l [ 0 ] ) NEW_LINE"],"references":["I = lambda : map ( int , input ( ) . split ( ) ) n , s = I ( ) l = [ 0 ] for i in range ( n ) : q , w = I ( ) q = q * 60 + w l += [ q ] if l [ 1 ] - l [ 0 ] > s : exit ( print ( 0 , 0 ) ) for i in range ( n ) : if l [ i + 1 ] - l [ i ] > 2 * s + 1 : l [ i ] += s + 1 exit ( print ( l [ i ] \/\/ 60 , l [ i ] % 60 ) ) l [ - 1 ] += s + 1 print ( l [ - 1 ] \/\/ 60 , l [ - 1 ] % 60 ) NEW_LINE","n , k = map ( int , input ( ) . split ( ) ) r = 0 for _ in range ( n ) : h , m = map ( int , input ( ) . split ( ) ) t = 60 * h + m if ( t > r + k ) : break r = t + k + 1 print ( r \/\/ 60 , r % 60 ) NEW_LINE","n , s = map ( int , input ( ) . split ( ) ) h = list ( ) m = list ( ) l = list ( ) l . append ( 0 ) for _ in range ( n ) : x , y = map ( int , input ( ) . split ( ) ) h . append ( x ) m . append ( y ) l . append ( ( x * 60 ) + y ) if ( l [ 1 ] != 0 and ( l [ 1 ] - l [ 0 ] ) >= s + 1 ) : print ( 0 , 0 ) else : k = 2 * s + 2 r = 0 for i in range ( n ) : if ( l [ i + 1 ] - l [ i ] >= k ) : r = l [ i ] + s + 1 break else : continue if ( r == 0 ) : r = l [ n ] + s + 1 print ( r \/\/ 60 , r % 60 ) NEW_LINE"],"bleu":0.4778388347262904,"rouge_l":0.5704599918171722}
{"id":438,"predictions":["from sys import stdin , stdoutfrom math import floor , gcd , fabs , factorial , fmod , sqrt , inf , logfrom collections import defaultdict as dd , dequefrom heapq import merge , heapify , heappop , heappush , nsmallestfrom bisect import bisect_left as bl , bisect_right as br , bisect mod = pow ( 10 , 9 ) + 7 mod2 = 998244353 def inp ( ) : return stdin . readline ( ) . strip ( ) def iinp ( ) : return int ( inp ( ) ) def out ( var , end = \" \\n \" ) : stdout . write ( str ( var ) + \" \\n \" ) def outa ( * var , end = \" \\n \" ) : stdout . write ( ' \\n ' . join ( map ( str , var ) ) + end ) def lmp ( ) : return list ( mp ( ) ) def mp ( ) : return map ( int , inp ( ) . split ( ) ) def smp ( ) : return map ( str , inp ( ) . split ( ) ) def l1d ( n , val = 0 ) : return [ val for i in range ( n ) ] def l2d ( n , m , val = 0 ) : return [ l1d ( m , val ) for j in range ( n ) ] def remadd ( x , y ) : return 1 if x % y else 0 def ceil ( a , d ) : return ( a + b - 1 ) \/\/ gcd ( x , y )     def main ( ) : NEW_LINE"],"references":["s = input ( ) ans = \" \" if s . startswith ( ' http ' ) : s = s [ 4 : ] ans = ' http : \/ \/ ' else : ans = \" ftp : \/ \/ \" s = s [ 3 : ]   if s . count ( ' ru ' ) > 1 and s . index ( ' ru ' ) == 0 : x = s [ 1 : ] . index ( ' ru ' ) + 1 else : x = s . index ( ' ru ' )     ans += s [ : x ] + ' . ' + ' ru ' s = s [ x + 2 : ] if s : ans += ' \/ ' + s   print ( ans )     NEW_LINE","d = input ( ) ad = ' ' if d [ : 4 ] == ' http ' : ad += ' http : \/ \/ ' else : ad += ' ftp : \/ \/ ' ad += d [ ( len ( ad ) - 3 ) : ( d . rfind ( ' ru ' ) ) ] + ' . ru ' if len ( ad ) != len ( d ) + 4 : ad += ' \/ ' + d [ ( d . rfind ( ' ru ' ) + 2 ) : ] print ( ad ) NEW_LINE","string = input ( )   if string . startswith ( ' http ' ) : protocol = string [ : 4 ] string = string [ 4 : ] else : protocol = string [ : 3 ] string = string [ 3 : ] domain_end = string . find ( ' ru ' , 1 )   domain_name = string [ : domain_end ] context = string [ domain_end + 2 : ]   result = protocol + ' : \/ \/ ' + domain_name + ' . ru '   if len ( context ) > 0 : result += ' \/ ' + context print ( result ) NEW_LINE"],"bleu":0.019262437004807113,"rouge_l":0.22013507116778913}
{"id":439,"predictions":["for i in range ( int ( input ( ) ) ) : n , k = map ( int , input ( ) . split ( ) ) if n >= k * k : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"references":["tests = int ( input ( ) ) t = 0 for t in range ( 0 , tests ) : n = int ( input ( ) ) s = input ( ) bol = False for i in range ( 0 , len ( s ) ) : if s [ i ] == '8' : bol = True cnt = i break if ( bol ) : if n - cnt >= 11 : print ( ' YES ' ) else : print ( ' NO ' ) else : print ( \" NO \" ) NEW_LINE","import sysimport re   def main ( ) : inp = sys . stdin . read ( ) . strip ( ) . split ( ) [ 2 : : 2 ] out = [ ] for s in inp : out . append ( ( ' NO ' , ' YES ' ) [ bool ( re . search ( '8\\d { 10 } ' , s ) ) ] ) return out   print ( * main ( ) , sep = ' \\n ' ) NEW_LINE","n = int ( input ( ) ) for i in range ( n ) : m = int ( input ( ) ) s = input ( ) if '8' in s [ : - 10 ] : print ( ' YES ' ) else : print ( ' NO ' ) NEW_LINE"],"bleu":0.5213163014888881,"rouge_l":0.5762483130904184}
{"id":440,"predictions":["n = int ( input ( ) ) a = [ int ( x ) for x in input ( ) . split ( ) ] l = [ ] for i in range ( 1 , n ) : if i % 2 == 0 : l . append ( a [ i ] ) else : l . append ( a [ i ] ) l . pop ( ) print ( * l ) NEW_LINE"],"references":["def solve ( arr ) : for i in range ( len ( arr ) ) : if arr [ i ] % 2 == 0 : arr [ i ] -= 1 return \" ▁ \" . join ( str ( i ) for i in arr )   input ( ) arr = list ( map ( int , input ( ) . split ( ) ) ) print ( solve ( arr ) ) NEW_LINE","def string_to_list ( s , char ) : collector = \" \" output_list = [ ] for i in range ( len ( s ) ) : if s [ i ] != char : collector += s [ i ] if i == len ( s ) - 1 : output_list . append ( int ( collector ) ) else : output_list . append ( int ( collector ) ) collector = \" \" return output_list     NEW_LINE","input ( ) nums = map ( int , str ( input ( ) ) . split ( ' ▁ ' ) ) print ( ' ▁ ' . join ( map ( str , map ( lambda x : x if x % 2 == 1 else x - 1 , nums ) ) ) ) NEW_LINE"],"bleu":0.40032062696927456,"rouge_l":0.41071909507137083}
{"id":441,"predictions":["import sysimport collections as ccinput = sys . stdin . buffer . readlineI = lambda : list ( map ( int , input ( ) . split ( ) ) ) prev = cc . defaultdict ( int ) for tc in range ( int ( input ( ) ) ) : x , y = I ( ) div = set ( ) for i in range ( 1 , int ( x ** 0.5 ) + 1 ) : if x % i == 0 : div . add ( i ) div . add ( x \/\/ i ) ans = 0 now = tc + 1 for i in div : if now - prev [ i ] > y : ans += 1 prev [ i ] = now print ( ans ) NEW_LINE"],"references":["from collections import defaultdictfrom sys import stdin   def put ( ) : return map ( int , stdin . readline ( ) . split ( ) )   def dfs ( ) : s = [ ( 1 , 0 ) ] ans = 0 vis = [ 0 ] * ( n + 1 ) while s : i , p = s . pop ( ) if vis [ i ] == 0 : vis [ i ] = 1 s . append ( ( i , p ) ) for j in tree [ i ] : if j != p : s . append ( ( j , i ) ) elif vis [ i ] == 1 : vis [ i ] = 2 for j in tree [ i ] : if j != p : mark [ i ] += mark [ j ] ans += min ( mark [ i ] , 2 * k - mark [ i ] ) print ( ans )                         n , k = put ( ) l = list ( put ( ) )   edge = defaultdict ( ) tree = [ [ ] for i in range ( n + 1 ) ] mark = [ 0 ] * ( n + 1 ) for i in l : mark [ i ] = 1 for _ in range ( n - 1 ) : x , y = put ( ) tree [ x ] . append ( y ) tree [ y ] . append ( x ) dfs ( ) NEW_LINE","def parser ( ) : return [ int ( x ) for x in input ( ) . split ( \" ▁ \" ) ]   def DFS ( ) : visited [ 0 ] = True stack = [ ] intruduction_order = [ ] stack . append ( 0 ) while len ( stack ) > 0 : v = stack . pop ( ) for u in adjacents_list [ v ] : if not visited [ u ] : pi [ u ] = v visited [ u ] = True if university_in_city [ u ] : count_universities_subtree [ u ] += 1 stack . append ( u ) intruduction_order . append ( u ) for v in intruduction_order [ : : - 1 ] : count_universities_subtree [ pi [ v ] ] += count_universities_subtree [ v ]     n , k = parser ( ) visited = [ False for x in range ( n ) ] pi = [ 0 for x in range ( n ) ] count_universities_subtree = [ 0 for x in range ( n ) ] university_in_city = [ False for x in range ( n ) ]   cities_universities = parser ( ) for i in range ( 2 * k ) : university_in_city [ cities_universities [ i ] - 1 ] = True   adjacents_list = [ [ ] for x in range ( n ) ] for i in range ( n - 1 ) : edge = parser ( ) adjacents_list [ edge [ 0 ] - 1 ] . append ( edge [ 1 ] - 1 ) adjacents_list [ edge [ 1 ] - 1 ] . append ( edge [ 0 ] - 1 )   DFS ( )   total = 0   for i in range ( 1 , n ) : total += min ( count_universities_subtree [ i ] , 2 * k - count_universities_subtree [ i ] )   print ( total ) NEW_LINE","WHITE = 0 GRAY = 1 BLACK = 2   def dfs_iter ( G , u = 0 ) : stack = [ ] stack . append ( { \" u \" : u , \" v \" : 0 , \" started \" : False } ) while len ( stack ) != 0 : current = stack [ len ( stack ) - 1 ] u = current [ \" u \" ] v_index = current [ \" v \" ] started = current [ \" started \" ] if started : NEW_LINE"],"bleu":0.32449107090583434,"rouge_l":0.31920982485977334}
{"id":442,"predictions":["def solve ( ) : s , t = input ( ) , input ( ) if len ( set ( s ) & set ( t ) ) > 0 : print ( ' YES ' ) else : print ( ' NO ' )   t = int ( input ( ) ) for _ in range ( t ) : solve ( ) NEW_LINE"],"references":["for _ in range ( int ( input ( ) ) ) : a = input ( ) b = input ( ) c = input ( ) case = True for i in range ( len ( a ) ) : if a [ i ] != c [ i ] and b [ i ] != c [ i ] : case = False print ( \" NO \" ) break if case : print ( \" YES \" ) NEW_LINE","for _ in range ( int ( input ( ) ) ) : a = input ( ) b = input ( ) c = input ( ) ans = True for i in range ( len ( a ) ) : if c [ i ] != a [ i ] and c [ i ] != b [ i ] : ans = False print ( \" NO \" ) break if ans : print ( \" YES \" ) NEW_LINE","for _ in range ( int ( input ( ) ) ) : a = input ( ) b = input ( ) c = input ( ) ans = True for i in range ( len ( a ) ) : if c [ i ] != a [ i ] and c [ i ] != b [ i ] : ans = False print ( \" No \" ) break if ans : print ( \" Yes \" ) NEW_LINE"],"bleu":0.2013229136647869,"rouge_l":0.32704267638859114}
{"id":443,"predictions":["from collections import defaultdict , deque , Counterfrom sys import stdin , stdoutfrom heapq import heappush , heappopimport mathimport ioimport osimport mathimport bisect   NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) g = [ set ( ) for i in range ( n ) ] for i in range ( m ) : a , b = map ( int , input ( ) . split ( ) ) g [ a - 1 ] . add ( b - 1 ) g [ b - 1 ] . add ( a - 1 ) a = [ ] p = [ - 1 ] * nfor i in range ( n ) : if p [ i ] != - 1 : continue p [ i ] = 0 a . append ( i ) while a : x = a . pop ( ) for node in g [ x ] : if p [ node ] == p [ x ] : print ( - 1 ) exit ( ) if p [ node ] == - 1 : p [ node ] = not p [ x ] a . append ( node ) print ( p . count ( 0 ) ) for i in range ( n ) : if p [ i ] == 0 : print ( i + 1 , end = \" ▁ \" ) print ( ) print ( p . count ( 1 ) ) for i in range ( n ) : if p [ i ] == 1 : print ( i + 1 , end = \" ▁ \" ) print ( ) NEW_LINE","from collections import defaultdictfrom collections import dequen , m = list ( map ( int , input ( ) . split ( ) ) ) d = defaultdict ( list ) for i in range ( m ) : x , y = map ( int , input ( ) . split ( ) ) d [ x ] . append ( y ) d [ y ] . append ( x ) c = { } f = 0 visited = [ 0 ] * ( n + 1 ) for i in range ( 1 , n + 1 ) : if visited [ i ] == 0 : q = deque ( ) q . append ( i ) visited [ i ] = 1 while q : j = q . popleft ( ) co = c . get ( j , 0 ) if co == 0 : c [ j ] = ' a ' co = ' a ' for k in d [ j ] : if visited [ k ] == 0 : coo = c . get ( k , 0 ) if coo == 0 : c [ k ] = ' a ' if co == ' b ' else ' b ' q . append ( k ) visited [ k ] = 1 for i in d : co = c [ i ] for j in d [ i ] : coo = c [ j ] if co == coo : f = 1 break if f : breakif f : print ( - 1 ) else : a , b = [ ] , [ ] for i in range ( 1 , n + 1 ) : co = c . get ( i , 0 ) if co == ' a ' : a . append ( i ) elif co == ' b ' : b . append ( i ) print ( len ( a ) ) print ( * a ) print ( len ( b ) ) print ( * b ) NEW_LINE","import sys , os , iodef rs ( ) : return sys . stdin . readline ( ) . rstrip ( ) def ri ( ) : return int ( sys . stdin . readline ( ) ) def ria ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) def ws ( s ) : sys . stdout . write ( s + ' \\n ' ) def wi ( n ) : sys . stdout . write ( str ( n ) + ' \\n ' ) def wia ( a ) : sys . stdout . write ( ' ▁ ' . join ( [ str ( x ) for x in a ] ) + ' \\n ' ) import math , datetime , functools , itertools , operator , bisect , fractions , statisticsfrom collections import deque , defaultdict , OrderedDict , Counterfrom fractions import Fractionfrom decimal import Decimalfrom sys import stdoutfrom heapq import heappush , heappop , heapify , _heapify_max , _heappop_max , nsmallest , nlargest NEW_LINE"],"bleu":0.00037806396984743195,"rouge_l":0.11665073077448436}
{"id":444,"predictions":["x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) print ( abs ( x1 - x2 ) , abs ( y1 - y2 ) ) NEW_LINE"],"references":["x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) )   if x1 == x2 : x3 = x1 + abs ( y2 - y1 ) x4 = x3 y3 = y1 y4 = y2 NEW_LINE","a , b , c , d = [ int ( i ) for i in input ( ) . split ( ' ▁ ' ) ] if a == c : s = abs ( d - b ) if a + s > 1000 : a -= s else : a += s print ( a , b , a , d ) elif b == d : s = abs ( a - c ) if a + s > 1000 : b -= s else : b += s print ( a , b , c , b ) elif abs ( a - c ) == abs ( b - d ) : print ( a , d , c , b ) else : print ( - 1 ) NEW_LINE","'''   ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Online ▁ Python ▁ Compiler . ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Code , ▁ Compile , ▁ Run ▁ and ▁ Debug ▁ python ▁ program ▁ online . Write ▁ your ▁ code ▁ in ▁ this ▁ editor ▁ and ▁ press ▁ \" Run \" ▁ button ▁ to ▁ execute ▁ it .   ''' a , b , c , d = map ( int , input ( ) . split ( ) ) if ( b == d ) : dd = abs ( c - a ) p = a q = b + dd r = c s = d + dd print ( p , q , r , s ) elif ( a == c ) : dd = abs ( b - d ) p = a + dd q = b r = c + dd s = d print ( p , q , r , s ) else : if ( a < c ) : p = c q = b r = a s = d aa = abs ( p - a ) bb = abs ( q - d ) cc = abs ( s - b ) dd = abs ( r - c ) if ( aa == bb and bb == cc and cc == dd ) : print ( p , q , r , s ) else : print ( - 1 ) else : p = a q = d r = c s = b aa = abs ( p - c ) bb = abs ( q - b ) cc = abs ( r - a ) dd = abs ( s - d ) if ( aa == bb and bb == cc and cc == dd ) : print ( p , q , r , s ) else : print ( - 1 ) NEW_LINE"],"bleu":0.5218128384043358,"rouge_l":0.6542966342004686}
{"id":445,"predictions":["n , m = map ( int , input ( ) . split ( ) ) s = [ input ( ) for i in range ( n ) ] cnt = 0 for i in range ( n ) : for j in range ( m ) : if s [ i ] [ j ] == ' S ' : cnt += 1 if cnt == m : cnt += 1 if cnt == m : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"references":["def checkRow ( i , c ) : cnt = 0 NEW_LINE for j in range ( m ) : if NEW_LINE g [ i ] [ j ] == c : cnt += 1   if cnt >= 2 : return True NEW_LINE return False     NEW_LINE def checkCol ( j , c ) : cnt = 0 NEW_LINE for i in range ( n ) : if NEW_LINE g [ i ] [ j ] == c : cnt += 1   if cnt >= 2 : return True NEW_LINE return False   n , m = map ( int , input ( ) . split ( ) )   g = [ ]   for i in range ( n ) : g . append ( list ( input ( ) ) )     res = [ [ 0 ] * m for i in range ( n ) ] NEW_LINE for i in range ( n ) : for NEW_LINE j in range ( m ) : NEW_LINE if ( checkRow ( i , g [ i ] [ j ] ) ) or checkCol ( j , g [ i ] [ j ] ) : res [ i ] [ j ] = 1     for i in range ( n ) : for NEW_LINE j in range ( m ) : NEW_LINE if res [ i ] [ j ] == 0 : print ( g [ i ] [ j ] , end = ' ' )         NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) NEW_LINE grid = [ input ( ) for _ in range ( n ) ] NEW_LINE row = [ [ ] for _ in range ( n ) ] NEW_LINE column = [ [ ] for _ in range ( n ) ]   for i in range ( n ) : letters = { } NEW_LINE for j in range ( m ) : if NEW_LINE grid [ i ] [ j ] in letters : letters [ grid [ i ] [ j ] ] += 1 else : letters [ grid [ i ] [ j ] ] = 1   for j in range ( m ) : if NEW_LINE letters [ grid [ i ] [ j ] ] > 1 : row [ i ] . append ( ' ' ) else : row [ i ] . append ( grid [ i ] [ j ] ) NEW_LINE for i in range ( m ) : letters = { } NEW_LINE for j in range ( n ) : if NEW_LINE grid [ j ] [ i ] in letters : letters [ grid [ j ] [ i ] ] += 1 else : letters [ grid [ j ] [ i ] ] = 1   for j in range ( n ) : if NEW_LINE letters [ grid [ j ] [ i ] ] > 1 : column [ j ] . append ( ' ' ) else : column [ j ] . append ( grid [ j ] [ i ] )   for i in range ( n ) : for NEW_LINE j in range ( m ) : NEW_LINE if row [ i ] [ j ] != ' ' and column [ i ] [ j ] != ' ' : print ( row [ i ] [ j ] , end = ' ' ) NEW_LINE","if __name__ == ' _ _ main _ _ ' : n , m = map ( int , input ( ) . split ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : a = input ( ) NEW_LINE s = [ ] NEW_LINE for i in a : s . append ( i ) NEW_LINE l . append ( s ) NEW_LINE M = [ ] NEW_LINE for i in range ( n ) : a = [ ] NEW_LINE for j in range ( m ) : s = l [ i ] [ j ] NEW_LINE rflag = 1 NEW_LINE cflag = 1 NEW_LINE for k in range ( m ) : if NEW_LINE k != j and l [ i ] [ k ] == s : rflag = 0 NEW_LINE break NEW_LINE for k in range ( n ) : if NEW_LINE k != i and l [ k ] [ j ] == s : cflag = 0 NEW_LINE break NEW_LINE if cflag == 0 or rflag == 0 : NEW_LINE INDENT a . append ( ' X ' ) else : NEW_LINE a . append ( l [ i ] [ j ] ) NEW_LINE DEDENT M . append ( a ) NEW_LINE ans = ' ' NEW_LINE for i in range ( n ) : for NEW_LINE j in range ( m ) : NEW_LINE if M [ i ] [ j ] != ' X ' : ans = ans + M [ i ] [ j ] NEW_LINE print ( ans ) NEW_LINE"],"bleu":0.12800791482075854,"rouge_l":0.3369561318555185}
{"id":446,"predictions":["import itertoolsimport bisectimport mathfrom collections import * import osimport sysfrom io import BytesIO , IOBase   ii = lambda : int ( input ( ) ) lmii = lambda : list ( map ( int , input ( ) . split ( ) ) ) slmii = lambda : sorted ( map ( int , input ( ) . split ( ) ) ) li = lambda : list ( input ( ) ) mii = lambda : map ( int , input ( ) . split ( ) ) msi = lambda : map ( str , input ( ) . split ( ) )     def main ( ) : NEW_LINE"],"references":["n , M = map ( int , input ( ) . strip ( ) . split ( ) ) a = list ( map ( int , input ( ) . strip ( ) . split ( ) ) )   a . insert ( 0 , 0 ) n += 1   lit = [ 0 ] * ( n + 1 ) for i in range ( 1 , n ) : if i % 2 == 0 : lit [ i ] = lit [ i - 1 ] else : lit [ i ] = lit [ i - 1 ] + a [ i ] - a [ i - 1 ] if n % 2 == 0 : lit [ n ] = lit [ n - 1 ] else : lit [ n ] = lit [ n - 1 ] + M - a [ n - 1 ] NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) ls = [ 0 ] + [ int ( x ) for x in input ( ) . split ( ) ] + [ m ] lb = [ 0 ] * nb = 0 for i in range ( 0 , n + 1 , 2 ) : b += ls [ i + 1 ] - ls [ i ] NEW_LINE","n , M = map ( int , input ( ) . split ( ) ) a = [ 0 ] + [ int ( x ) for x in input ( ) . split ( ) ] + [ M ]   t1 = [ ] t2 = [ ] for i in range ( n + 1 ) : if i % 2 == 0 : t1 . append ( a [ i + 1 ] - a [ i ] ) else : t2 . append ( a [ i + 1 ] - a [ i ] ) t2 . append ( 0 )   import mathans = sum ( t1 ) p = 0 q = sum ( t2 ) for i in range ( math . ceil ( n \/ 2 ) ) : p = p + t1 [ i ] q = q - t2 [ i - 1 ] ans = max ( ans , p + q - 1 ) print ( ans ) NEW_LINE"],"bleu":0.29889922900452165,"rouge_l":0.3897398424252644}
{"id":447,"predictions":["import sys   def input ( ) : return sys . stdin . readline ( ) . strip ( )   def ri ( ) : return int ( input ( ) ) def rinput ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) def rinput ( ) : return sys . stdin . readline ( ) . strip ( ) def rinput ( ) : return map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) def rinput ( ) : return map ( float , sys . stdin . readline ( ) . strip ( ) . split ( ) def rinput ( ) : return stdin . readline ( ) . strip ( ) . split ( ) def rinput ( ) : return sys . stdin . readline ( ) . strip ( ) def rinput ( ) : return int ( rinput ( ) ) def rinput ( ) : return stdin . readline ( ) . strip ( )   n = rinput ( ) s = list ( input ( ) ) time = 0 for i in range ( n ) : flag = True for j in range ( time + n ) : if s [ i ] == ' th ' : flag = 1 break if flag : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"references":["import sysdef input ( ) : return sys . stdin . readline ( ) . strip ( ) def iinput ( ) : return int ( input ( ) ) def minput ( ) : return map ( int , input ( ) . split ( ) ) def listinput ( ) : return list ( map ( int , input ( ) . split ( ) ) ) c = 0 for _ in range ( iinput ( ) ) : km , dirr = map ( str , input ( ) . split ( ) ) km = int ( km ) if dirr == ' North ' : c -= km elif dirr == ' South ' : c += km elif c == 0 or c == 20000 : print ( \" NO \" ) exit ( ) if c < 0 or c > 20000 : print ( \" NO \" ) exit ( ) if c == 0 : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE","s , a = 0 , 0 for _ in \" ▁ \" * int ( input ( ) ) : t , d = map ( str , input ( ) . split ( ) ) ; t = int ( t ) if not a and d [ 0 ] != \" S \" or a == 20000 and d [ 0 ] != \" N \" or d [ 0 ] == \" N \" and a - t < 0 or d [ 0 ] == \" S \" and a + t > 20000 : s = 1 a += 0 if d not in \" NorthSouth \" else t if d [ 0 ] == \" S \" else - tprint ( \" YES \" if not ( s or a ) else \" NO \" ) NEW_LINE","s , a = 0 , 0 for _ in \" ▁ \" * int ( input ( ) ) : t , d = map ( str , input ( ) . split ( ) ) ; t = int ( t ) if not a and d [ 0 ] != \" S \" or a == 20000 and d [ 0 ] != \" N \" or d [ 0 ] == \" N \" and a - t < 0 or d [ 0 ] == \" S \" and a + t > 20000 : s = 1 a += 0 if d [ 0 ] not in \" NS \" else t if d [ 0 ] == \" S \" else - tprint ( \" YES \" if not ( s or a ) else \" NO \" ) NEW_LINE"],"bleu":0.3256946320596209,"rouge_l":0.5020186335403727}
{"id":448,"predictions":["n , m = map ( int , input ( ) . split ( ) ) if n == m : print ( 0 ) elif m - 1 < n - m : print ( - 1 ) else : l = [ [ ] for i in range ( m ) ] for i in range ( n - 2 ) : print ( l [ i ] + 1 , end = \" ▁ \" ) for i in range ( m - 1 , - 1 , - 1 ) : print ( l [ i ] , end = \" ▁ \" ) NEW_LINE"],"references":["n , m = list ( map ( int , input ( ) . split ( \" ▁ \" ) ) )   if m % 2 != 0 : mid = int ( ( m + 1 ) \/ 2 ) i = mid j = mid       else :   mid = int ( ( m \/ 2 ) ) i = mid j = mid + 1     detector = 1 if m == 1 : for x in range ( n ) : print ( 1 ) else : for _ in range ( n ) : if i == j : print ( mid ) i -= 1 j += 1 detector = 1 continue if m % 2 != 0 : if detector == - 1 : print ( j ) j += 1 if j == m + 1 : j = mid detector *= - 1 elif detector == 1 : print ( i ) i -= 1 if i == 0 : i = mid detector *= - 1   elif m % 2 == 0 : if detector == 1 : print ( i ) i -= 1 if i == 0 : i = mid detector *= - 1 elif detector == - 1 : print ( j )   j += 1 if j == m + 1 : j = mid + 1 detector *= - 1     NEW_LINE","def task ( n , m ) : if m % 2 == 0 : c = 0 else : c = 1 mid = m \/\/ 2 + c l = mid - 1 hi = mid + 1 print ( mid ) n -= 1 if m % 2 != 0 : while n : if l > 0 : print ( l ) l -= 1 n -= 1 if hi <= m and n : print ( hi ) hi += 1 n -= 1 if hi > m and l <= 0 : hi = mid + 1 l = mid - 1 if n : print ( mid ) n -= 1 return \" \" else : while n :   if hi <= m and n : print ( hi ) hi += 1 n -= 1 if l > 0 and n : print ( l ) l -= 1 n -= 1 if hi > m and l <= 0 : hi = mid + 1 l = mid - 1 if n : print ( mid ) n -= 1 return \" \"   a , b = map ( int , input ( ) . strip ( ) . split ( ) ) print ( task ( a , b ) ) NEW_LINE","from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"bleu":0.3781006566823083,"rouge_l":0.5328313253012048}
{"id":449,"predictions":["from math import ceiln , x , y , p = map ( int , input ( ) . split ( ) ) ans = float ( ' inf ' ) f = int ( input ( ) )   for i in range ( n ) : x , y = map ( int , input ( ) . split ( ) ) ans = round ( ans ) \/ ( n - x * ( 100 - y ) \/ ( 100 ) )   print ( ans ) NEW_LINE"],"references":["import mathfrom math import gcd , floor , sqrt , logdef iin ( ) : return int ( input ( ) ) def sin ( ) : return input ( ) . strip ( ) def listin ( ) : return list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) def liststr ( ) : return list ( map ( str , input ( ) . strip ( ) . split ( ) ) ) def ceill ( x ) : return int ( x ) if ( x == int ( x ) ) else int ( x ) + 1 def ceilldiv ( x , d ) : return x \/\/ d if ( x % d == 0 ) else x \/\/ d + 1 def LCM ( a , b ) : return ( a * b ) \/\/ gcd ( a , b )     def solve ( ) : n , x , y = listin ( ) wiz = x people = n - x req = ceill ( ( y \/ 100 ) * n ) print ( max ( 0 , req - wiz ) ) t = 1 NEW_LINE","from sys import stdin , stdoutimport math , sysfrom itertools import permutations , combinationsfrom collections import defaultdict , deque , OrderedDictfrom os import pathimport bisect as biimport heapq def yes ( ) : print ( ' YES ' ) def no ( ) : print ( ' NO ' ) if ( path . exists ( ' input . txt ' ) ) : NEW_LINE","import mathn , x , y = map ( int , input ( ) . split ( ) ) v = ( math . ceil ( ( y * n ) \/ 100 ) ) print ( v - x ) if v - x > 0 else print ( '0' ) NEW_LINE"],"bleu":0.4522782193866461,"rouge_l":0.6078820399513009}
{"id":450,"predictions":["def solution ( ) : n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) mx = max ( arr ) if mx == 1 : print ( 0 ) return for i in arr : if i != mx : mx = max ( mx , mx ) else : print ( mx )       \t \t       solution ( ) NEW_LINE"],"references":["n = int ( input ( ) ) vals = list ( map ( int , input ( ) . split ( ) ) ) vals = [ ( i , vals [ i ] ) for i in range ( n ) ] vals = [ vals [ 0 ] ] + sorted ( vals [ 1 : ] , key = lambda x : x [ 1 ] , reverse = True ) most_left_idx = 0 count = 0 output = ' ' for i in range ( n ) : if ( most_left_idx >= i ) : for j in range ( 1 , vals [ i ] [ 1 ] + 1 ) : if ( most_left_idx + j < n ) : count += 1 output += ' { } ▁ { } ▁ \\n ' . format ( vals [ i ] [ 0 ] + 1 , vals [ most_left_idx + j ] [ 0 ] + 1 ) most_left_idx += vals [ i ] [ 1 ] if ( most_left_idx >= n - 1 ) : print ( count ) print ( output ) else : print ( - 1 ) NEW_LINE","from sys import stdin , stdout , maxsize ; NEW_LINE","n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) order = [ ] pairs = [ ] l = a [ 1 : ] for i in range ( len ( l ) ) : order . append ( [ l [ i ] , i + 2 ] ) order . sort ( reverse = True ) order . insert ( 0 , [ a [ 0 ] , 1 ] ) rm = [ False ] * n NEW_LINE"],"bleu":0.44269581341771697,"rouge_l":0.4581110646771061}
{"id":451,"predictions":["n , k = map ( int , input ( ) . split ( ) ) s = input ( ) p = len ( s ) - 1 while s [ : p ] != s [ - p : ] : p = p - 1 print ( s + s [ p : ] * ( k - 1 ) ) NEW_LINE"],"references":["l = [ - 1 ] * 122 g = [ - 1 ] * 122 r = 0 ch = 0 n , k = map ( int , input ( ) . split ( ) ) s = input ( ) j = nfor i in range ( 0 , n ) : j -= 1 indf = ord ( s [ i ] ) indb = ord ( s [ j ] ) if ( l [ indf ] != - 1 ) : pass else : l [ indf ] = i if ( g [ indb ] != - 1 ) : pass else : g [ indb ] = j   for i in range ( 0 , n ) : indx = ord ( s [ i ] ) if ( l [ indx ] == i ) : r += 1 if ( r > k ) : ch = 1 break if ( g [ indx ] == i ) : r -= 1 if ( ch == 1 ) : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE","n , k = map ( int , input ( ) . split ( ) ) s = input ( ) s = list ( s ) m = 0 a = [ 0 ] * 26 b = [ 0 ] * 26 for i in s : q = ord ( i ) - 65 a [ q ] += 1 for i in s : q = ord ( i ) - 65 if a [ q ] > 0 : if b [ q ] == 0 : if k == 0 : m = 1 break b [ q ] = 1 k -= 1 a [ q ] -= 1 if a [ q ] == 0 : k += 1 b [ q ] = 1 if m == 0 : print ( \" NO \" ) else : print ( \" YES \" ) NEW_LINE","n , k = map ( int , input ( ) . strip ( ) . split ( ' ▁ ' ) ) s = input ( ) s = list ( s ) l1 = [ 2 * 10 ** 6 ] * 26 l2 = [ 0 ] * 26 for i in range ( n ) : o = ord ( s [ i ] ) - 65 if l1 [ o ] > i : l1 [ o ] = i if l2 [ o ] < i : l2 [ o ] = ii = 0 while ( i < len ( l1 ) ) : if l1 [ i ] == 2000000 and l2 [ i ] == 0 : del l1 [ i ] del l2 [ i ] else : i += 1 for i in range ( len ( l1 ) - 1 ) : for j in range ( i + 1 , len ( l1 ) ) : if l1 [ i ] > l1 [ j ] : l1 [ i ] , l1 [ j ] = l1 [ j ] , l1 [ i ] l2 [ i ] , l2 [ j ] = l2 [ j ] , l2 [ i ] l = len ( l1 ) t = 0 c = 0 for i in range ( l ) : f = 0 if l1 [ i ] != - 1 : t = l2 [ i ] if i == l - 1 : c += 1 break for j in range ( i + 1 , l ) : if f == 0 : f = 1 c += 1 if l1 [ j ] > t : f = 1 t = l2 [ j ] l1 [ j ] = - 1 l2 [ j ] = - 1   if k >= c : print ( ' NO ' ) else : print ( ' YES ' ) NEW_LINE"],"bleu":0.12977403552038802,"rouge_l":0.36970363823301294}
{"id":452,"predictions":["def bs ( l , h ) : while l < h : m = ( l + h + 1 ) \/\/ 2 if gf ( m ) : l = m else : l = m - 1 return l   def gf ( x ) : if x % 2 : return sum ( sorted ( a [ : x + 1 : x + 2 ] ) [ 1 : : 2 ] ) <= h else : return sum ( sorted ( a [ : : x + 1 ] ) [ 0 : : 2 ] ) <= h     n , m = map ( int , input ( ) . split ( ) ) NEW_LINE"],"references":["a , b = list ( map ( int , input ( ) . split ( ) ) ) print ( format ( ( ( b * b ) - ( a * a ) ) \/ ( a * 2 ) , ' . 12f ' ) ) NEW_LINE","h , l = list ( map ( int , input ( ) . split ( ) ) )   res = ( l ** 2 - h ** 2 ) \/ ( 2 * h ) print ( res )       NEW_LINE","h , l = map ( int , input ( ) . split ( ) ) c = ( h * h + l * l ) ** 0.5 a = ( c * c ) \/ ( 2 * h ) print ( a - h ) NEW_LINE"],"bleu":0.16473161687054033,"rouge_l":0.2619349978476108}
{"id":453,"predictions":["s = input ( ) ans = 0 i = 0j = len ( s ) for j in range ( i + 1 , len ( s ) ) : if s [ j ] != s [ i ] [ j ] : ans = max ( ans , j - i + 1 ) j = i + 1   print ( ans ) NEW_LINE"],"references":["s = input ( ) w = len ( s ) q = - 1 for i in range ( w - 2 ) : for j in range ( i + 1 , w - 1 ) : a , b , c = s [ : i + 1 ] , s [ i + 1 : j + 1 ] , s [ j + 1 : ] if len ( a ) == len ( str ( int ( a ) ) ) and len ( b ) == len ( str ( int ( b ) ) ) and len ( c ) == len ( str ( int ( c ) ) ) : if int ( a ) <= 10 ** 6 and int ( b ) <= 10 ** 6 and int ( c ) <= 10 ** 6 : q = max ( q , int ( a ) + int ( b ) + int ( c ) ) print ( q ) NEW_LINE","s = input ( ) n = len ( s ) maxi = - 1 for i in range ( n - 2 ) : for j in range ( i + 1 , n - 1 ) : a , b , c = s [ : i + 1 ] , s [ i + 1 : j + 1 ] , s [ j + 1 : ] if len ( a ) == len ( str ( int ( a ) ) ) and len ( b ) == len ( str ( int ( b ) ) ) and len ( c ) == len ( str ( int ( c ) ) ) : if int ( a ) <= 1e6 and int ( b ) <= 1e6 and int ( c ) <= 1e6 : maxi = max ( maxi , int ( a ) + int ( b ) + int ( c ) ) print ( maxi ) NEW_LINE","s = input ( ) ans = - 1 for i in range ( len ( s ) - 2 ) : for j in range ( i + 1 , len ( s ) - 1 ) : x = s [ : i + 1 ] y = s [ i + 1 : j + 1 ] z = s [ j + 1 : ] if len ( x ) == len ( str ( int ( x ) ) ) and len ( y ) == len ( str ( int ( y ) ) ) and len ( z ) == len ( str ( int ( z ) ) ) : if int ( x ) <= 1e6 and int ( y ) <= 1e6 and int ( z ) <= 1e6 : ans = max ( ans , int ( x ) + int ( y ) + int ( z ) ) print ( ans ) NEW_LINE"],"bleu":0.13330444360577726,"rouge_l":0.41323606044815014}
{"id":454,"predictions":["import sysimport mathfrom collections import defaultdict , Counter , deque   NEW_LINE"],"references":["x = int ( input ( ) ) for i in range ( x ) : n , m = [ int ( a ) for a in input ( ) . split ( ) ] if ( 2 * min ( n , m ) < max ( m , n ) or ( n + m ) % 3 ) : print ( \" NO \" ) else : print ( \" YES \" ) NEW_LINE","for iii in range ( int ( input ( ) ) ) : a , b = map ( int , input ( ) . split ( ) ) if ( a > b ) : a , b = b , a if ( a + b ) % 3 == 0 and 2 * a >= b : print ( \" yes \" ) else : print ( \" no \" ) NEW_LINE","import sysimport mathfrom collections import defaultdict , Counter , deque   NEW_LINE"],"bleu":1.0,"rouge_l":1.0}
{"id":455,"predictions":["import mathI = lambda : list ( map ( int , input ( ) . split ( ) ) ) n = int ( input ( ) ) a = [ ] for _ in range ( n ) : a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) i = 0 for i in range ( n ) : j = 0 for i in range ( 1 , n ) : if a [ i ] [ j ] == a [ i - 1 ] [ j ] : j += 1 if j == n : print ( math . sqrt ( max ( a ) ) ) else : print ( - 1 ) NEW_LINE"],"references":["from sys import * ; from math import * ; from collections import * ; from bisect import * ; from itertools import * INF = maxsizedef get_ints ( ) : return map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) def get_array ( ) : return list ( map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) ) def input ( ) : return stdin . readline ( ) . strip ( ) mod = 1000000007   n = int ( input ( ) ) arr = [ ] for i in range ( n ) : temp = get_array ( ) arr . append ( temp ) for i in range ( n ) : ans = ( arr [ i ] [ ( i + 1 ) % n ] * arr [ i ] [ ( i + 2 ) % n ] ) \/\/ arr [ ( i + 1 ) % n ] [ ( i + 2 ) % n ] print ( int ( sqrt ( ans ) ) , end = ' ▁ ' ) NEW_LINE","import math   prime = [ 2 , 3 , 5 , 7 , 11 ] ; d = { }   def GeneratePrimes ( ) : for i in range ( 12 , 100010 ) : for j in prime : if i % j == 0 : break if j * j > i : prime . append ( i ) break else : prime . append ( i ) for i in range ( 1 , len ( prime ) + 1 ) : d [ prime [ i - 1 ] ] = i NEW_LINE","n = int ( input ( ) ) l = [ ] for i in range ( n ) : l . append ( list ( map ( int , input ( ) . split ( ) ) ) ) ans = [ ] a = int ( ( ( l [ 0 ] [ 1 ] * l [ 1 ] [ 2 ] ) \/\/ l [ 0 ] [ 2 ] ) ** 0.5 )   for i in range ( n ) : if l [ 1 ] [ i ] != 0 : ans . append ( l [ 1 ] [ i ] \/\/ a ) else : ans . append ( a ) print ( * ans ) NEW_LINE"],"bleu":0.523662435408539,"rouge_l":0.5437108131922548}
{"id":456,"predictions":["def solution ( ) : n = int ( input ( ) ) k = [ ] mn = float ( ' inf ' )   mx = float ( ' - Inf ' ) for i in range ( n ) : l , r = map ( int , input ( ) . split ( ) ) k . append ( ( l , r ) ) mn = min ( l , mn ) mx = max ( r , mx )   for i in range ( n ) : if k [ i ] [ 0 ] == mn and k [ i ] [ 1 ] == mx : if k [ i ] [ 0 ] + k [ i - 1 ] [ 1 ] == mx : print ( 0 ) return - 1   solution ( ) NEW_LINE"],"references":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) [ : n ] res = [ a . index ( 1 ) , a . index ( n ) ] print ( max ( max ( res ) , n - min ( res ) - 1 ) ) NEW_LINE","n = int ( input ( ) ) lst = [ int ( i ) for i in input ( ) . split ( ) ] mn = lst . index ( min ( lst ) ) mx = lst . index ( max ( lst ) )   print ( max ( mn , n - mn - 1 , mx , n - mx - 1 ) ) NEW_LINE","import sysinput = sys . stdin . readline   n = int ( input ( ) ) a = [ int ( i ) for i in input ( ) . split ( ) ] x , y = a . index ( 1 ) , a . index ( n ) ans = max ( x , y , n - x - 1 , n - y - 1 ) print ( ans ) NEW_LINE"],"bleu":0.21988107254063394,"rouge_l":0.4290281329923274}
{"id":457,"predictions":["def solve ( ) : n = int ( input ( ) ) r = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) if n % 2 == 0 : print ( \" NO \" ) elif b [ n \/\/ 2 ] == 1 : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"references":["n = int ( input ( ) ) num = [ int ( i ) for i in input ( ) . split ( \" ▁ \" ) ]   odd = 0 even = 0   for i in num : if even and odd : break if i % 2 == 0 : even = 1 else : odd = 1 if even and odd : num = sorted ( num ) s = \" \" for i in range ( 0 , len ( num ) ) : s += str ( num [ i ] ) + \" ▁ \" print ( s ) NEW_LINE","import sysimport mathfrom collections import OrderedDictdef input ( ) : return sys . stdin . readline ( ) . strip ( ) def iinput ( ) : return int ( input ( ) ) def minput ( ) : return map ( int , input ( ) . split ( ) ) def listinput ( ) : return list ( map ( int , input ( ) . split ( ) ) ) n = iinput ( ) l = listinput ( ) even_no = list ( filter ( lambda x : ( x % 2 == 0 ) , l ) ) odd_no = list ( filter ( lambda x : ( x % 2 != 0 ) , l ) ) if len ( odd_no ) == 0 or len ( even_no ) == 0 : print ( * l ) else : print ( * sorted ( l ) ) NEW_LINE","n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in range ( n ) : c += l [ i ] % 2 if ( c != 0 and c != n ) : l . sort ( ) print ( * l ) NEW_LINE"],"bleu":0.5796098114789133,"rouge_l":0.6151410609540717}
{"id":458,"predictions":["n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( len ( l ) ) : if ( l [ i ] in l ) : print ( i , end = ' ▁ ' ) NEW_LINE"],"references":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) k = ns = set ( ) for i in a : s . add ( i ) while k in s : print ( k , end = ' ▁ ' ) k -= 1 print ( ) NEW_LINE","n = int ( input ( ) ) t = list ( map ( int , input ( ) . split ( ) ) )   p = n - 1 used = [ False ] * n   for x in range ( n ) : used [ t [ x ] - 1 ] = True   while p >= 0 and used [ p ] : print ( p + 1 , end = ' ▁ ' ) p -= 1 print ( ' ' ) NEW_LINE","n = int ( input ( ) ) l = [ int ( x ) for x in input ( ) . split ( ) ] d = set ( ) for i in l : d . add ( i ) while n in d : print ( n , end = ' ▁ ' ) n -= 1 print ( ) NEW_LINE"],"bleu":0.58204332158948,"rouge_l":0.6865208450177605}
{"id":459,"predictions":["for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) s = input ( ) res = [ ] for i in range ( n ) : if i == 0 : res . append ( s [ i : ] + s [ i + 1 : ] ) else : res . append ( 1 ) print ( * res ) NEW_LINE"],"references":["for t in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEW_LINE b = input ( ) NEW_LINE a = ' ' NEW_LINE d = ' ' NEW_LINE for i in b : try : if 1 + int ( i ) == int ( d [ - 1 ] ) : NEW_LINE INDENT a += '0' else : NEW_LINE a += '1' except : a = '1' NEW_LINE DEDENT d = str ( int ( a [ - 1 ] ) + int ( i ) ) NEW_LINE print ( a ) NEW_LINE","for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE t = \"1\" NEW_LINE p = s [ 0 ] NEW_LINE for i in s [ 1 : ] : if NEW_LINE i == '1' : NEW_LINE if t [ - 1 ] == '1' and p == '1' : NEW_LINE INDENT t += '0' else : NEW_LINE t += '1' else : if ( t [ - 1 ] == '1' and p == '0' ) or ( t [ - 1 ] == '0' and p == '1' ) : NEW_LINE t += '0' else : NEW_LINE t += '1' NEW_LINE DEDENT p = i NEW_LINE print ( t ) NEW_LINE","from sys import stdin   for _ in range ( int ( stdin . readline ( ) ) ) : n = int ( stdin . readline ( ) ) NEW_LINE b = stdin . readline ( ) . strip ( ) NEW_LINE res = [ 0 ] * n NEW_LINE prev = - 1 NEW_LINE for idx , val in enumerate ( b ) : if NEW_LINE val == '1' : NEW_LINE if prev == 2 : res [ idx ] = '0' NEW_LINE prev = 1 else : res [ idx ] = '1' NEW_LINE prev = 2 else : if prev != 1 : res [ idx ] = '1' NEW_LINE prev = 1 else : res [ idx ] = '0' NEW_LINE prev = 0 NEW_LINE print ( ' ' . join ( res ) ) NEW_LINE"],"bleu":0.33497316057326654,"rouge_l":0.5130736880599743}
{"id":460,"predictions":["import sys , math , itertoolsfrom collections import Counter , deque , defaultdictfrom bisect import bisect_left , bisect_right from heapq import heappop , heappush , heapifymod = 10 ** 9 + 7 INF = float ( ' inf ' ) def inp ( ) : return int ( sys . stdin . readline ( ) ) def inpl ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) def inpl_1 ( ) : return list ( map ( lambda x : int ( x ) - 1 , sys . stdin . readline ( ) . split ( ) ) ) def inps ( ) : return sys . stdin . readline ( ) def inpsl ( x ) : tmp = sys . stdin . readline ( ) ; return list ( tmp [ : x ] ) def err ( x ) : print ( x ) ; exit ( )   for _ in range ( inp ( ) ) : n , m = inpl ( ) a = inpl ( ) cnt = 0 for i in range ( n ) : NEW_LINE"],"references":["from math import ceiln , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) m = 10 ** ( k - 1 ) ans = 1 for i in range ( n \/\/ k ) : an = ( 10 ** k - 1 ) \/\/ a [ i ] + 1 l = b [ i ] * m r = ( b [ i ] + 1 ) * m - 1 count = r \/\/ a [ i ] - ceil ( l \/ a [ i ] ) + 1 ans = ( ans * ( an - count ) ) % ( 10 ** 9 + 7 ) print ( ans ) NEW_LINE","from math import *   MOD = 1000000007   n , k = map ( int , input ( ) . split ( ) )   a = [ int ( i ) for i in input ( ) . split ( ) ] b = [ int ( i ) for i in input ( ) . split ( ) ]   res = 1 for i in range ( n \/\/ k ) : cont = ceil ( 10 ** k \/ a [ i ] ) - ceil ( ( b [ i ] + 1 ) * 10 ** ( k - 1 ) \/ a [ i ] ) + ceil ( b [ i ] * 10 ** ( k - 1 ) \/ a [ i ] ) NEW_LINE","from math import * MOD = 1000000007 n , k = map ( int , input ( ) . split ( ) ) a = [ int ( i ) for i in input ( ) . split ( ) ] b = [ int ( i ) for i in input ( ) . split ( ) ] res = 1 for i in range ( n \/\/ k ) : cont = ceil ( 10 ** k \/ a [ i ] ) - ceil ( ( b [ i ] + 1 ) * 10 ** ( k - 1 ) \/ a [ i ] ) + ceil ( b [ i ] * 10 ** ( k - 1 ) \/ a [ i ] ) NEW_LINE"],"bleu":0.19933823404850629,"rouge_l":0.35421935000468296}
{"id":461,"predictions":["n = int ( input ( ) ) bs = [ i for i in range ( 1 , n + 1 ) ] NEW_LINE"],"references":["x = ( int ( input ( ) ) + 1 ) \/\/ 3 print ( x \/\/ 12 , x % 12 ) NEW_LINE","n = int ( input ( ) ) a = n \/\/ 36 rema = n % 36 if ( rema == 35 ) : a += 1 if ( a >= n ) : b = 0 else : b = ( n - a * 36 ) \/\/ 3 rem = ( n - a * 36 ) % 3 if ( rem == 2 ) : b += 1 print ( a , b ) NEW_LINE","n = int ( input ( ) ) a = ( n + 1 ) \/\/ 36 n -= 36 * ab = ( n + 1 ) \/\/ 3 print ( a , b ) NEW_LINE"],"bleu":0.43180565570216367,"rouge_l":0.504629847238543}
{"id":462,"predictions":["b , c = map ( int , input ( ) . split ( ) ) l = [ ] l . extend ( map ( int , input ( ) . split ( ) ) ) if sum ( l ) <= b : print ( max ( l ) ) ) else : print ( 0 ) NEW_LINE"],"references":["n , b , d = map ( int , input ( ) . split ( ) ) summa = 0 ans = 0 a = [ int ( i ) for i in input ( ) . split ( ) ] for i in a : if i <= b : summa += i if summa > d : summa = 0 ans += 1 print ( ans ) NEW_LINE","a , b , d = map ( int , input ( ) . split ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) )   ans = 0 bin = 0 for n in arr : if n <= b : bin += n if bin > d : ans += 1 bin = 0   print ( ans ) NEW_LINE","for _ in range ( 1 ) : n , b , d = map ( int , input ( ) . split ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) )   trashBin = 0 mixed = 0 total = 0 for i in range ( n ) : if arr [ i ] > b : trashBin += b else : mixed += arr [ i ]   if mixed > d : trashBin = 0 mixed = 0 total += 1   print ( total ) NEW_LINE"],"bleu":0.43471715653871684,"rouge_l":0.586755456899741}
{"id":463,"predictions":["def STR ( ) : return list ( input ( ) ) def INT ( ) : return int ( input ( ) ) def MAP ( ) : return map ( int , input ( ) . split ( ) ) def MAP2 ( ) : return map ( float , input ( ) . split ( ) ) def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) def STRING ( ) : return input ( ) import stringimport sysfrom heapq import heappop , heappushfrom bisect import * from collections import deque , Counter , defaultdictfrom math import * from itertools import permutations , accumulatedx = [ - 1 , 1 , 0 , 0 ] dy = [ 0 , 0 , 1 , - 1 ] NEW_LINE"],"references":["n , m , b , mod = list ( map ( int , input ( ) . split ( ) ) ) a = list ( map ( int , input ( ) . split ( ) ) )   A = [ [ 0 for i in range ( m + 1 ) ] for j in range ( b + 1 ) ]   A [ 0 ] [ 0 ] = 1   for i in range ( n ) : for j in range ( a [ i ] , b + 1 ) : for k in range ( m ) : A [ j ] [ k + 1 ] = ( A [ j ] [ k + 1 ] + A [ j - a [ i ] ] [ k ] ) % mod NEW_LINE","n , m , b , mod = list ( map ( int , input ( ) . split ( ) ) ) a = list ( map ( int , input ( ) . split ( ) ) )   A = [ [ 0 for i in range ( m + 1 ) ] for j in range ( b + 1 ) ]   A [ 0 ] [ 0 ] = 1   for i in range ( n ) : for j in range ( a [ i ] , b + 1 ) : for k in range ( m ) : A [ j ] [ k + 1 ] = ( A [ j ] [ k + 1 ] + A [ j - a [ i ] ] [ k ] ) % mod     ans = 0 for i in range ( b + 1 ) : ans = ( ans + A [ i ] [ m ] ) % modprint ( ans ) NEW_LINE"],"bleu":0.24256153835524458,"rouge_l":0.32273394675019573}
{"id":464,"predictions":["from math import sqrt NEW_LINE a , b = map ( int , input ( ) . split ( ) ) NEW_LINE"],"references":["def clean ( d ) : ans = [ '0' ] for c in list ( d ) : ans . append ( c ) i = len ( ans ) - 1 NEW_LINE","u = v = 0 a , b = input ( ) , input ( ) n , m = len ( a ) , len ( b ) if n > m : b = '0' * ( n - m ) + belse : a = '0' * ( m - n ) + afor i in range ( max ( n , m ) ) : u , v = v + u , u + int ( a [ i ] ) - int ( b [ i ] ) if u > 1 : print ( ' > ' ) exit ( 0 ) elif u < - 1 : print ( ' < ' ) exit ( 0 ) d = 2 * v + uif u == v == 0 : print ( ' = ' ) elif u >= 0 and d >= 0 : print ( ' > ' ) elif u <= 0 and d <= 0 : print ( ' < ' ) else : print ( ' > ' if ( u * u > v * ( v + u ) ) ^ ( u < 0 ) else ' < ' ) NEW_LINE","from math import sqrt   a = map ( int , list ( raw_input ( ) ) [ : : - 1 ] ) b = map ( int , list ( raw_input ( ) ) [ : : - 1 ] )   i = max ( len ( a ) , len ( b ) )   a += [ 0 ] * ( i - len ( a ) ) b += [ 0 ] * ( i - len ( b ) )   i -= 1 while i >= 2 : while a [ i ] == b [ i ] : i -= 1 if i == - 1 : print \" = \" exit ( 0 ) if a [ i ] == 1 : a [ i - 1 ] += 1 - b [ i - 1 ] a [ i - 2 ] += 1 - b [ i - 2 ] b [ i - 1 ] = b [ i - 2 ] = 0 if a [ i - 1 ] == 2 or a [ i - 2 ] == 2 : print \" > \" exit ( 0 ) else : b [ i - 1 ] += 1 - a [ i - 1 ] b [ i - 2 ] += 1 - a [ i - 2 ] a [ i - 1 ] = a [ i - 2 ] = 0 if b [ i - 1 ] == 2 or b [ i - 2 ] == 2 : print \" < \" exit ( 0 ) i -= 1   a . append ( 0 ) b . append ( 0 ) ans = ( a [ 0 ] - b [ 0 ] ) + ( a [ 1 ] - b [ 1 ] ) * ( 1 + sqrt ( 5 ) ) \/ 2 if ans > 0 : print \" > \" elif ans < 0 : print \" < \" else : print \" = \" NEW_LINE"],"bleu":0.3552213206048893,"rouge_l":0.33526178767717674}
{"id":465,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) d = [ 0 ] * 4 for i in a : if i == 1 : d [ 0 ] += 1 d [ 2 ] = max ( d [ 2 ] + 1 , d [ 1 ] + 1 ) else : d [ 1 ] = max ( d [ 1 ] + 1 , d [ 0 ] + 1 ) d [ 3 ] = max ( d [ 3 ] + 1 , d [ 2 ] + 1 ) print ( max ( d ) ) NEW_LINE"],"bleu":0.06936581643909287,"rouge_l":0.30880491773639485}
{"id":466,"predictions":["import sysimport collectionsimport itertools   def rs ( x = ' ' ) : return sys . stdin . readline ( ) . strip ( ) if len ( x ) == 0 else input ( x ) . strip ( ) def ri ( x = ' ' ) : return int ( rs ( x ) ) def rm ( x = ' ' ) : return map ( str , rs ( x ) . split ( ) ) def rl ( x = ' ' ) : return rs ( x ) . split ( ) def rmi ( x = ' ' ) : return map ( int , rs ( x ) . split ( ) ) def rli ( x = ' ' ) : return [ int ( x ) for x in rs ( x ) . split ( ) ] def println ( val ) : sys . stdout . write ( str ( val ) + ' \\n ' )   def solve ( testCase ) : n , a = ri ( ) , rli ( ) fives = a . count ( 5 ) zeros = n - fives NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) a = [ int ( i ) for i in input ( ) . split ( ) ] b = [ 0 ] * ( 10 ** 5 + 1 ) p = [ 0 ] * n + [ 0 ] for i in range ( len ( a ) - 1 , - 1 , - 1 ) : if b [ a [ i ] ] == 0 : b [ a [ i ] ] += 1 p [ i ] = p [ i + 1 ] + 1 else : p [ i ] = p [ i + 1 ] for i in range ( m ) : k = int ( input ( ) ) print ( p [ k - 1 ] ) NEW_LINE","n , m = map ( int , input ( ) . split ( ) )   ans = [ ] d = { }   for i in map ( int , reversed ( input ( ) . split ( ) ) ) : if d == { } : ans . append ( 1 ) d [ i ] = 1 elif i in d : ans . append ( ans [ - 1 ] ) else : ans . append ( ans [ - 1 ] + 1 ) d [ i ] = 1   for _ in range ( m ) : q = int ( input ( ) ) print ( ans [ n - q ] ) NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) arr = [ int ( ele ) for ele in input ( ) . split ( ) ] s = set ( ) li = [ ] for i in range ( n - 1 , - 1 , - 1 ) : s . add ( arr [ i ] ) arr [ i ] = len ( s ) for i in range ( m ) : l = int ( input ( ) ) li . append ( l ) for i in li : print ( arr [ i - 1 ] ) NEW_LINE"],"bleu":0.11864137677027803,"rouge_l":0.3198449789125727}
{"id":467,"predictions":["n = input ( ) if ( n == '0' ) : print ( 0 ) elif n == '1' : print ( 1 ) else : print ( n \/\/ 2 ) NEW_LINE"],"references":["a , b = map ( int , input ( ) . split ( ) ) if a == b : print ( a ) else : print ( \"1\" ) NEW_LINE","import sysinput = sys . stdin . readline   a , b = [ int ( i ) for i in input ( ) . split ( ) ] print ( a if a == b else 1 ) NEW_LINE","def solve ( a , b ) : if ( a == b ) : return a else : return 1   a , b = input ( ) . split ( ' ▁ ' ) print ( solve ( a , b ) ) NEW_LINE"],"bleu":0.2961021506067713,"rouge_l":0.5484515484515484}
{"id":468,"predictions":["import sys , os , iodef rs ( ) : return sys . stdin . readline ( ) . rstrip ( ) def ri ( ) : return int ( sys . stdin . readline ( ) ) def ria ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) def ws ( s ) : sys . stdout . write ( s + ' \\n ' ) def wi ( n ) : sys . stdout . write ( str ( n ) + ' \\n ' ) def wia ( a ) : sys . stdout . write ( ' ▁ ' . join ( [ str ( x ) for x in a ] ) + ' \\n ' ) import math , datetime , functools , itertools , operator , bisect , fractions , statisticsfrom collections import deque , defaultdict , OrderedDict , Counterfrom fractions import Fractionfrom decimal import Decimalfrom sys import stdoutfrom heapq import heappush , heappop , heapify , _heapify_max , _heappop_max , nsmallest , nlargest   def main ( ) : NEW_LINE"],"references":["from sys import stdin , stdoutn = int ( input ( ) ) arr = [ ] d = dict ( ) for i in range ( n ) : x = tuple ( [ int ( x ) for x in stdin . readline ( ) . split ( ) ] ) d [ x ] = 1 arr . append ( x ) cnt = 0 for i in range ( n - 1 ) : for j in range ( i + 1 , n ) : sum1 = arr [ i ] [ 0 ] + arr [ j ] [ 0 ] sum2 = arr [ i ] [ 1 ] + arr [ j ] [ 1 ] if ( sum1 \/ 2 == sum1 \/\/ 2 ) and ( sum2 \/ 2 == sum2 \/\/ 2 ) : tup = ( sum1 \/\/ 2 , sum2 \/\/ 2 ) if d . get ( tup ) : cnt += 1 ; print ( cnt ) NEW_LINE","from sys import stdina = int ( stdin . readline ( ) ) k = [ [ int ( i ) + 1000 for i in map ( int , input ( ) . split ( ) ) ] for _ in \" ▁ \" * a ] ok = [ [ 0 ] * ( 2001 ) for _ in \" ▁ \" * 2001 ] for i in k : ok [ i [ 0 ] ] [ i [ 1 ] ] = 1 ans = 0 for i in range ( a ) : for j in range ( i + 1 , a ) : if ( k [ i ] [ 0 ] + k [ j ] [ 0 ] ) % 2 == 0 and ( k [ i ] [ 1 ] + k [ j ] [ 1 ] ) % 2 == 0 and ok [ ( k [ i ] [ 0 ] + k [ j ] [ 0 ] ) \/\/ 2 ] [ ( k [ i ] [ 1 ] + k [ j ] [ 1 ] ) \/\/ 2 ] : ans += 1 print ( ans ) NEW_LINE","n = int ( input ( ) ) lst = [ ] d = set ( ) for i in range ( n ) : x , y = map ( int , input ( ) . split ( ) ) lst . append ( [ x , y ] ) d . add ( ( x , y ) ) ans = 0 for i in range ( n ) : for j in range ( i + 1 , n ) : if ( lst [ i ] [ 0 ] + lst [ j ] [ 0 ] ) % 2 == 0 and ( lst [ i ] [ 1 ] + lst [ j ] [ 1 ] ) % 2 == 0 : x1 = ( lst [ i ] [ 0 ] + lst [ j ] [ 0 ] ) \/\/ 2 y1 = ( lst [ i ] [ 1 ] + lst [ j ] [ 1 ] ) \/\/ 2 if ( x1 , y1 ) in d : ans += 1 print ( ans ) NEW_LINE"],"bleu":0.16317727939894883,"rouge_l":0.2536090864057745}
{"id":469,"predictions":["n = int ( input ( ) ) lst = list ( map ( int , input ( ) . split ( ) ) ) ans = [ 1 ] summ2 = lst [ 0 ] for i in range ( 1 , n ) : if lst [ 0 ] >= ( 2 * lst [ i ] ) : ans . append ( i + 1 ) summ2 += lst [ i ] summ = sum ( lst ) NEW_LINE"],"references":["import sys     def ints_input ( ) : return [ int ( i ) for i in sys . stdin . readline ( ) . strip ( \" \\n \" ) . split ( \" ▁ \" ) ]     def print_list ( arr ) : sys . stdout . writelines ( str ( x ) + \" ▁ \" for x in arr ) sys . stdout . write ( \" \\n \" )     def fast_input ( type = str ) : return type ( sys . stdin . readline ( ) . strip ( \" \\n \" ) )     X = ints_input ( ) n , x = X [ 0 ] , X [ 1 : ] Y = ints_input ( ) m , y = Y [ 0 ] , Y [ 1 : ]   Z = ints_input ( ) p , z = Z [ 0 ] , Z [ 1 : ]   a , b = ints_input ( ) r2 = max ( x ) * ( b * max ( y ) \/ ( a * min ( z ) + b * max ( y ) ) ) ** 0.5 print ( r2 ) NEW_LINE","a = list ( map ( int , input ( ) . split ( ) [ 1 : : ] ) ) b = list ( map ( int , input ( ) . split ( ) [ 1 : : ] ) ) c = list ( map ( int , input ( ) . split ( ) [ 1 : : ] ) ) A , B = map ( int , input ( ) . split ( ) ) print ( max ( a ) * ( ( B * max ( b ) ) \/ ( ( A * min ( c ) + B * max ( b ) ) ) ) ** 0.5 ) NEW_LINE","from collections import defaultdict as ddfrom collections import dequeimport bisectimport heapqfrom math import sqrt def ri ( ) : return int ( input ( ) ) def rl ( ) : return list ( map ( int , input ( ) . split ( ) ) )   def r2 ( r1 , p1 , p2 , A , B ) : alpha = A \/ B ratio = p1 \/ p2 return ( r1 * sqrt ( ratio \/ ( alpha + ratio ) ) )   line = rl ( ) rr1 = line [ 1 : ] r1 = max ( rr1 ) line = rl ( ) pp1 = line [ 1 : ] p1 = max ( pp1 ) line = rl ( ) pp2 = line [ 1 : ] p2 = min ( pp2 ) A , B = rl ( )     print ( r2 ( r1 , p1 , p2 , A , B ) )   NEW_LINE"],"bleu":0.2255656049706791,"rouge_l":0.36773221226302844}
{"id":470,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["def lower_bound ( arr , left , right , target ) : if arr [ right ] < target : return right + 1 while left < right : mid = ( left + right ) >> 1 if arr [ mid ] >= target : right = mid else : left = mid + 1 return left   T = int ( input ( ) ) arr = [ 0 ] * Tdp = [ 0 ] * ( T + 1 ) for i in range ( T ) : arr [ i ] = int ( input ( ) ) for i in range ( T ) : dp [ i + 1 ] = dp [ i ] + 20 dp [ i + 1 ] = min ( dp [ i + 1 ] , dp [ lower_bound ( arr , 0 , T - 1 , arr [ i ] - 89 ) ] + 50 ) dp [ i + 1 ] = min ( dp [ i + 1 ] , dp [ lower_bound ( arr , 0 , T - 1 , arr [ i ] - 1439 ) ] + 120 ) print ( dp [ i + 1 ] - dp [ i ] ) NEW_LINE","from bisect import bisect_rightfrom math import inf   n = int ( input ( ) ) dp = [ inf ] * ndp [ 0 ] = 20     a = [ int ( input ( ) ) ] for i in range ( n - 1 ) : a . append ( int ( input ( ) ) ) print ( dp [ 0 ] ) for i in range ( 1 , n ) : NEW_LINE","from bisect import bisect_rightfrom math import infn = int ( input ( ) ) dp = [ inf ] * ndp [ 0 ] = 20     a = [ int ( input ( ) ) ] for i in range ( n - 1 ) : a . append ( int ( input ( ) ) ) print ( dp [ 0 ] ) for i in range ( 1 , n ) : NEW_LINE"],"bleu":0.12855898756100254,"rouge_l":0.40182417025589057}
{"id":471,"predictions":["n , m = map ( int , input ( ) . split ( ) ) l = [ ] for i in range ( n ) : l . append ( list ( map ( int , input ( ) . split ( ) ) ) ) ans = 0 for i in range ( n ) : for j in range ( m ) : if l [ i ] [ j ] == 0 : ans += 1 print ( ans ) NEW_LINE"],"references":["import math as mtimport sys , stringfrom collections import Counter , defaultdictinput = sys . stdin . readline MOD = 1000000007 I = lambda : int ( input ( ) ) M = lambda : map ( int , input ( ) . split ( ) ) Ms = lambda : map ( str , input ( ) . split ( ) ) ARR = lambda : list ( map ( int , input ( ) . split ( ) ) ) def solve ( ) : n , m = M ( ) mat = [ ARR ( ) for _ in range ( n ) ]   setLengths = [ ] for i in range ( n ) : black , white = 0 , 0 for j in range ( m ) : if mat [ i ] [ j ] == 0 : black += 1 elif mat [ i ] [ j ] == 1 : white += 1 if white > 0 : setLengths . append ( white ) if black > 0 : setLengths . append ( black )   for j in range ( m ) : black , white = 0 , 0 for i in range ( n ) : if mat [ i ] [ j ] == 0 : black += 1 elif mat [ i ] [ j ] == 1 : white += 1 if white > 0 : setLengths . append ( white ) if black > 0 : setLengths . append ( black )   ans = n * m for e in setLengths : ans += ( 1 << e ) ans -= ( e + 1 ) print ( ans )     tc = 1 NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) lst = [ ] rowzero = [ 0 ] * ncolzero = [ 0 ] * mrowone = [ 0 ] * ncolone = [ 0 ] * mfor i in range ( n ) : a = list ( map ( int , input ( ) . split ( ) ) ) lst . append ( a ) for j in range ( m ) : if a [ j ] == 1 : rowone [ i ] += 1 colone [ j ] += 1 else : rowzero [ i ] += 1 colzero [ j ] += 1 ans = 0 for i in range ( len ( rowone ) ) : ans += pow ( 2 , rowone [ i ] ) - 1 for i in range ( len ( rowzero ) ) : ans += pow ( 2 , rowzero [ i ] ) - 1 for i in range ( len ( colone ) ) : ans += pow ( 2 , colone [ i ] ) - 1 for i in range ( len ( colzero ) ) : ans += pow ( 2 , colzero [ i ] ) - 1 print ( ans - ( n * m ) ) NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) matr = [ ] res = 0 for i in range ( n ) : arr = list ( map ( int , input ( ) . split ( ) ) ) c = arr . count ( 0 ) d = m - c matr . append ( arr ) res = res + 2 ** c + 2 ** d - 2 for i in range ( m ) : c = 0 d = 0 for j in range ( n ) : if matr [ j ] [ i ] == 0 : c = c + 1 else : d = d + 1 res = res + 2 ** c + 2 ** d - 2 res = res - m * nprint ( res ) NEW_LINE"],"bleu":0.3944132771993649,"rouge_l":0.5728254469842075}
{"id":472,"predictions":["num = int ( input ( ) ) arr = sorted ( map ( int , input ( ) . split ( ) ) )   print ( max ( arr ) ) NEW_LINE"],"references":["n = int ( input ( ) ) print ( sorted ( map ( int , input ( ) . split ( ) ) ) [ ( n - 1 ) \/\/ 2 ] ) NEW_LINE","n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l . sort ( reverse = True ) print ( l [ n \/\/ 2 ] ) NEW_LINE","n = int ( input ( ) ) s = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) print ( s [ ( n - 1 ) \/\/ 2 ] ) NEW_LINE"],"bleu":0.6717540172702513,"rouge_l":0.7706252932109108}
{"id":473,"predictions":["n = int ( input ( ) ) if n == 0 : print ( \" NO \" ) else : print ( \" YES \" ) NEW_LINE"],"references":["import java . util . * ;   public class aerg {   static Scanner in = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { String s = in . next ( ) ; String u = in . next ( ) ; int ans = 0 ; for ( int i = 0 ; i < s . length ( ) ; i + + ) { for ( int j = 0 ; j < u . length ( ) ; j + + ) { int k = 0 ; if ( s . charAt ( i ) == u . charAt ( j ) ) { k + + ; for ( int z = j + 1 , t = i + 1 ; z < u . length ( ) & & t < s . length ( ) ; z + + , t + + ) { if ( s . charAt ( t ) == u . charAt ( z ) ) { k + + ; } } \/\/ System . out . println ( i + \" ▁ \" + k ) ; } ans = Math . max ( ans , k ) ; } if ( ans > s . length ( ) - i ) break ; } \/\/ System . out . println ( u . length ( ) ) ; System . out . println ( u . length ( ) - ans ) ; } } NEW_LINE","s = input ( ) u = input ( ) t = [ 0 ] * len ( s ) d = { chr ( i ) : [ ] for i in range ( ord ( ' a ' ) , ord ( ' z ' ) + 1 ) } for i , j in enumerate ( s ) : d [ j ] . append ( i ) for i in u : for j in d [ i ] : t [ j ] += 1 t = [ 0 ] + tprint ( len ( u ) - max ( t ) ) NEW_LINE","def check ( ss ) : tmp = 0 for i in range ( len ( u ) ) : tmp += ss [ i ] != u [ i ] return tmp           s = input ( ) u = input ( ) s = ' # ' * 2000 + s + ' # ' * 2000 ans = 1000000000000 for i in range ( len ( s ) - len ( u ) ) : sub = s [ i : i + len ( u ) ] ans = min ( ans , check ( sub ) ) print ( ans )           NEW_LINE"],"bleu":0.009898726436879135,"rouge_l":0.17502942907592706}
{"id":474,"predictions":["s = input ( ) ans = [ ] check = 0 for i in range ( len ( s ) ) : if s [ i ] == ' # ' : ans . append ( s [ i ] ) check = 1 for j in range ( len ( s ) ) : if s [ j ] == ' # ' : check = 1 else : check = 2 if s [ i ] == ' # ' : ans . append ( s [ i ] ) else : ] . append ( s [ i ] ) ans . append ( s [ i ] ) for i in range ( len ( s ) ) : print ( \" \" . join ( s [ i ] ) ) NEW_LINE"],"references":["import syskek = \" \" bol = 1 for s in sys . stdin : ok = 0 for i in range ( len ( s ) ) : if s [ i ] == ' ▁ ' : continue if s [ i ] == ' # ' : ok = 1 else : ok = 0 break kekw = ( bol == 0 and ok == 0 ) for j in range ( len ( kek ) - kekw ) : if bol == 1 or kek [ j ] != ' ▁ ' : sys . stdout . write ( kek [ j ] ) kek = s bol = ok   for j in range ( len ( kek ) ) : if bol == 1 or kek [ j ] != ' ▁ ' : sys . stdout . write ( kek [ j ] ) NEW_LINE","import sys   result = ' '   prev_amp = True   for line in sys . stdin : if ' # ' in line : i = line . index ( ' # ' ) if list ( line [ : i ] ) == [ ' ▁ ' ] * i : if not prev_amp : result += ' \\n ' + line else : result += line prev_amp = True continue to_add = ' ' . join ( map ( str . strip , line . split ( ) ) ) result += to_add prev_amp = False     if not prev_amp : result = result + ' \\n '   sys . stdout . write ( result )         NEW_LINE","v = [ ] c = [ ] resp = \" \"   while True : try : v . append ( input ( ) ) except : break   i = 0 while i < len ( v ) : k = v [ i ] . replace ( \" ▁ \" , \" \" ) if ( k == \" \" ) : v [ i ] = k c . append ( False ) elif ( k [ 0 ] == ' # ' ) : c . append ( True ) else : v [ i ] = k c . append ( False ) i += 1   n = len ( v ) i = 0 while i < n - 1 : if ( not c [ i ] and not c [ i + 1 ] ) : resp += v [ i ] else : resp += v [ i ] + \" \\n \" i += 1 resp += v [ i ]   print ( resp ) NEW_LINE"],"bleu":0.48339608719022675,"rouge_l":0.4785922438915042}
{"id":475,"predictions":["n , s = map ( int , input ( ) . rstrip ( ) . split ( \" ▁ \" ) ) if s == 0 or n == 1 : print ( - 1 ) elif s == n \/\/ 2 : print ( ( n - 1 ) * ( n - 1 ) ) else : t = s - 1 for i in range ( s ) : t += s [ i ] print ( t ) NEW_LINE"],"references":["from sys import stdin , stdout n , m , k = map ( int , input ( ) . split ( ) ) l = [ [ 0 ] * m ] * n for i in range ( n ) : l [ i ] = list ( map ( int , stdin . readline ( ) . split ( ) ) ) t = [ [ 0 ] * 2 ] * ke = [ 0 ] * nc = [ 0 ] * m for i in range ( k ) : t0 , t1 = map ( int , stdin . readline ( ) . split ( ) ) e [ t0 - 1 ] -= 1 c [ t1 - 1 ] += 1 p = [ \" \" ] * nfor i in range ( n ) : for j in range ( m ) : e [ i ] = e [ i ] + c [ j ] * l [ i ] [ j ] p [ i ] = str ( e [ i ] ) stdout . write ( \" ▁ \" . join ( p ) ) NEW_LINE","from sys import stdin , stdout n , m , k = map ( int , input ( ) . split ( ) ) l = [ [ 0 ] * m ] * n for i in range ( n ) : l [ i ] = list ( map ( int , stdin . readline ( ) . split ( ) ) ) t = [ [ 0 ] * 2 ] * ke = [ 0 ] * nc = [ 0 ] * m for i in range ( k ) : t0 , t1 = map ( int , stdin . readline ( ) . split ( ) ) e [ t0 - 1 ] -= 1 c [ t1 - 1 ] += 1 p = [ \" \" ] * nfor i in range ( n ) : for j in range ( m ) : e [ i ] = e [ i ] + c [ j ] * l [ i ] [ j ] p [ i ] = str ( e [ i ] ) stdout . write ( \" ▁ \" . join ( p ) )         NEW_LINE","n , m , k = map ( int , input ( ) . split ( ) ) p = [ ]   for i in range ( n ) : o = [ int ( w ) for w in input ( ) . split ( ) ] p . append ( o )   t = [ 0 ] * nr = [ 0 ] * m   for i in range ( k ) : a , b = map ( int , input ( ) . split ( ) ) t [ a - 1 ] += 1 r [ b - 1 ] += 1   for i in range ( n ) : ans = 0 for j in range ( m ) : if p [ i ] [ j ] == 1 : ans += r [ j ] print ( ans - t [ i ] , end = \" ▁ \" ) NEW_LINE"],"bleu":0.1447936414843684,"rouge_l":0.35215863453815266}
{"id":476,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["c , d = [ int ( i ) for i in input ( ) . split ( \" ▁ \" ) ] n , m = [ int ( i ) for i in input ( ) . split ( \" ▁ \" ) ] k = int ( input ( ) )   s = n * m - ks = max ( s , 0 )   if c < d * n : stuff = s \/\/ n try1 = c * stuff + d * ( s - n * stuff ) try2 = c * ( stuff + 1 ) print ( min ( try1 , try2 ) ) else : print ( d * s ) NEW_LINE","c , d = list ( map ( int , input ( ) . split ( ) ) ) n , m = list ( map ( int , input ( ) . split ( ) ) ) k = int ( input ( ) ) t = max ( ( m * n ) - k , 0 ) p = min ( c , n * d ) ans = p * ( t \/\/ n ) rem = t % nans = ans + min ( c , rem * d ) print ( ans ) NEW_LINE","import os , sys , atexitfrom io import BytesIO , StringIO input = BytesIO ( os . read ( 0 , os . fstat ( 0 ) . st_size ) ) . readline_OUTPUT_BUFFER = StringIO ( ) sys . stdout = _OUTPUT_BUFFER @ atexit . registerdef write ( ) : sys . __stdout__ . write ( _OUTPUT_BUFFER . getvalue ( ) ) c , d = map ( int , input ( ) . split ( ) ) n , m = map ( int , input ( ) . split ( ) ) k = int ( input ( ) ) require = n * m - kans = 999999999 for i in range ( 10000 ) : for j in range ( 10000 ) : if i * n + j >= require : ans = min ( ans , c * i + d * j ) print ( ans ) NEW_LINE"],"bleu":0.12094503075401543,"rouge_l":0.3482126929674099}
{"id":477,"predictions":["n = int ( input ( ) ) if n < 4 : print ( \" No \" ) else : print ( \" Yes \" ) print ( 1 , \" No \" ) NEW_LINE"],"references":["a , b = map ( int , input ( ) . split ( ) )   s = input ( )   obs = b * ' # ' if obs in s : print ( \" NO \" ) else : print ( \" YES \" ) NEW_LINE","n , k = map ( int , input ( ) . split ( ) ) p = input ( ) if ' # ' * k in p : print ( \" NO \" ) else : print ( \" YES \" ) NEW_LINE","k = int ( input ( ) . split ( ' ▁ ' ) [ 1 ] ) s = input ( ) . split ( ' . ' ) flag = Truefor i in s : if len ( i ) >= k : flag = False breakprint ( ' YES ' if flag else ' NO ' ) NEW_LINE"],"bleu":0.3531702618205192,"rouge_l":0.5325396825396825}
{"id":478,"predictions":["def magic ( n , d , l ) : arr = [ 1 ] * ( n ) odd = arr [ 0 : : 2 ] even = arr [ 1 : : 2 ] if d > 1 : val = d - ( sum ( odd ) - sum ( even ) ) while val : for i in range ( len ( odd ) ) : if val : odd [ i ] += 1 val -= 1 else : break if d <= 0 : val = abs ( d ) - ( sum ( even ) - sum ( odd ) ) while val : for i in range ( len ( even ) ) : if val : even [ i ] += 1 val -= 1 else : break if max ( odd ) > l or max ( even ) > l : return - 1 arr [ 0 : : 2 ] = odd arr [ 1 : : 2 ] = even print ( * arr ) return \" \" a , b , c = map ( int , input ( ) . strip ( ) . split ( ) ) print ( magic ( a , b , c ) ) NEW_LINE"],"references":["na , ma = map ( int , input ( ) . split ( ) ) a = [ list ( map ( int , input ( ) ) ) for _ in range ( na ) ] nb , mb = map ( int , input ( ) . split ( ) ) b = [ list ( map ( int , input ( ) ) ) for _ in range ( nb ) ]   best = 0 points = ( 0 , 0 ) for x in range ( - 50 , 51 ) : for y in range ( - 50 , 51 ) : ct = 0 for i in range ( na ) : if x + i < 0 : continue if x + i >= nb : break for j in range ( ma ) : if y + j < 0 : continue if y + j >= mb : break ct += a [ i ] [ j ] * b [ i + x ] [ j + y ] if ct >= best : best = ct points = ( x , y ) print ( points [ 0 ] , points [ 1 ] ) NEW_LINE","from sys import stdin , stdoutfrom math import gcdii1 = lambda : int ( stdin . readline ( ) . strip ( ) ) is1 = lambda : stdin . readline ( ) . strip ( ) iia = lambda : list ( map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) ) isa = lambda : stdin . readline ( ) . strip ( ) . split ( ) mod = 1000000007   na , ma = iia ( ) a1 = [ ] for _ in range ( na ) : a1 . append ( list ( map ( int , list ( is1 ( ) ) ) ) ) nb , mb = iia ( ) a2 = [ ] for _ in range ( nb ) : a2 . append ( list ( map ( int , list ( is1 ( ) ) ) ) )   res = [ 0 , - 1 , - 1 ] shift = max ( na , ma , nb , mb ) for x in range ( - shift , shift + 1 ) : for y in range ( - shift , shift + 1 ) : temp = 0 for i in range ( na ) : for j in range ( ma ) : if i + x >= 0 and i + x < nb and j + y >= 0 and j + y < mb : temp += a1 [ i ] [ j ] * a2 [ i + x ] [ j + y ] if temp > res [ 0 ] : res [ 0 ] = temp res [ 1 ] , res [ 2 ] = x , yprint ( res [ 1 ] , res [ 2 ] )   NEW_LINE","na , ma = [ int ( x ) for x in input ( ) . split ( ) ] a = [ ] for i in range ( na ) : a . append ( [ int ( x ) for x in list ( input ( ) ) ] )   nb , mb = [ int ( x ) for x in input ( ) . split ( ) ] b = [ ] for i in range ( nb ) : b . append ( [ int ( x ) for x in list ( input ( ) ) ] )   def cal ( x , y ) : ans = 0 for i in range ( na ) : for j in range ( ma ) : if i + x < nb and i + x > - 1 and j + y < mb and j + y > - 1 : v1 = int ( b [ i + x ] [ j + y ] ) v2 = int ( a [ i ] [ j ] ) ans += v1 * v2 return ans   ans = - 1 X = 100 Y = 100 for x in range ( - 50 , 51 ) : for y in range ( - 50 , 51 ) : if cal ( x , y ) > ans : ans = cal ( x , y ) X = x Y = y   print ( X , Y ) NEW_LINE"],"bleu":0.21682705987888418,"rouge_l":0.30383539374692825}
{"id":479,"predictions":["n , k = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l . sort ( ) print ( l [ - k ] ) NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l . sort ( ) print ( l [ ( - 1 ) * m ] ) NEW_LINE","nk = input ( ) . split ( ) n = int ( nk [ 0 ] ) k = int ( nk [ 1 ] ) a = sorted ( [ int ( i ) for i in input ( ) . split ( ) ] ) print ( a [ n - k ] )   NEW_LINE","if __name__ == \" _ _ main _ _ \" : n , k = list ( map ( int , input ( ) . split ( ) ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) arr . sort ( ) arr = arr [ : : - 1 ] for i in range ( n ) : if i + 1 == k : print ( arr [ i ] ) break NEW_LINE"],"bleu":0.8721542195774811,"rouge_l":0.9116572567253403}
{"id":480,"predictions":["n , m = map ( int , input ( ) . split ( ) ) l1 = list ( map ( int , input ( ) . split ( ) ) ) l2 = list ( map ( int , input ( ) . split ( ) ) ) x = [ ] for i in l1 : if ( l1 [ i ] > x [ i ] ) : l1 . append ( x [ i ] * x [ i ] )   NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) first = int ( 0 ) second = int ( 0 ) now = int ( 1 ) for i in range ( len ( l ) - 1 , - 1 , - 1 ) : first = first + now * l [ i ] now = now * m   n1 , m1 = map ( int , input ( ) . split ( ) ) l1 = list ( map ( int , input ( ) . split ( ) ) )   now = 1 for i in range ( len ( l1 ) - 1 , - 1 , - 1 ) : second = second + now * l1 [ i ] now = now * m1   if second == first : print ( ' = ' ) elif second > first : print ( ' < ' ) else : print ( ' > ' ) NEW_LINE","n , b = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) d = 1 a1 = b1 = 0 for x in range ( n - 1 , - 1 , - 1 ) : a1 += l [ x ] * d d *= b     m , a = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) d = 1 for x in range ( m - 1 , - 1 , - 1 ) : b1 += l [ x ] * d d *= a   if a1 == b1 : print ( ' = ' ) elif a1 > b1 : print ( ' > ' ) else : print ( ' < ' ) NEW_LINE","n , b1 = map ( int , input ( ) . split ( ) ) x = list ( map ( int , input ( ) . split ( ) ) ) m , b2 = map ( int , input ( ) . split ( ) ) y = list ( map ( int , input ( ) . split ( ) ) ) x = x [ : : - 1 ] y = y [ : : - 1 ] ans1 = 0 for i in range ( n ) : ans1 += ( b1 ** i ) * x [ i ] ans2 = 0 for i in range ( m ) : ans2 += ( b2 ** i ) * y [ i ] if ans1 == ans2 : print ( \" = \" ) elif ans1 < ans2 : print ( \" < \" ) else : print ( \" > \" ) NEW_LINE"],"bleu":0.3024003203995379,"rouge_l":0.5416458229114558}
{"id":481,"predictions":["n , k = map ( int , input ( ) . split ( ) ) A = list ( map ( int , input ( ) . split ( ) ) ) C = [ 0 ] * 100001   l = 0 r = 0 p = 0   while r < n and p < k : C [ A [ r ] ] += 1 if C [ A [ r ] ] > k : p += 1 r += 1 if C [ A [ r ] ] == k : p += 1 l += 1 l -= 1 r += 1 if p < n : print ( - 1 ) else : print ( l ) NEW_LINE"],"references":["l = int ( input ( ) ) a = [ int ( bruh ) for bruh in input ( ) . split ( ) ]   a1 = sorted ( a )   cnt = 0 for x in range ( l ) : if a [ x ] != a1 [ x ] : cnt += 1   if cnt <= 2 : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE","def solve ( n , arr ) : sortedArr = sorted ( arr ) times = 0 index = 0 while index < n : if arr [ index ] != sortedArr [ index ] : times += 1 index += 1 if times > 2 : return \" NO \" else : return \" YES \" n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) print ( solve ( n , arr ) ) NEW_LINE","n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) arr2 = sorted ( arr ) count = 0 a = 0 for i in range ( n ) : if arr [ i ] != arr2 [ i ] : count += 1 k = arr [ i ] arr [ i ] = arr2 [ i ] z = arr . index ( arr2 [ i ] ) arr [ z ] = k   if count > 2 : a = 1 breakif a == 0 : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.2723662756792268,"rouge_l":0.4718706047819972}
{"id":482,"predictions":["from collections import defaultdict , deque , Counterfrom sys import stdin , stdoutfrom heapq import heappush , heappopimport mathimport ioimport osimport mathimport bisect   NEW_LINE"],"references":["class CodeforcesTask226BSolution : def __init__ ( self ) : self . result = ' ' self . n = 0 self . piles = [ ] self . q = 0 self . variants = [ ]   def read_input ( self ) : self . n = int ( input ( ) ) self . piles = [ int ( x ) for x in input ( ) . split ( \" ▁ \" ) ] self . q = int ( input ( ) ) self . variants = [ int ( x ) for x in input ( ) . split ( \" ▁ \" ) ]   def process_task ( self ) : self . piles . sort ( reverse = True ) sums = [ 0 ] * self . n sums [ 0 ] = self . piles [ 0 ] for x in range ( self . n - 1 ) : sums [ x + 1 ] = self . piles [ x + 1 ] + sums [ x ] anwsers = { } results = [ ] for query in self . variants : if query in anwsers . keys ( ) : results . append ( anwsers [ query ] ) else : anwser = 0 factor = 1 k = 1 width = query x = 1 while x + width < self . n : anwser += ( sums [ x + width - 1 ] - sums [ x - 1 ] ) * factor factor += 1 x += width k += 1 width = query ** k anwser += ( sums [ - 1 ] - sums [ x - 1 ] ) * factor results . append ( anwser ) anwsers [ query ] = anwser self . result = \" ▁ \" . join ( [ str ( x ) for x in results ] )   def get_result ( self ) : return self . result     if __name__ == \" _ _ main _ _ \" : Solution = CodeforcesTask226BSolution ( ) Solution . read_input ( ) Solution . process_task ( ) print ( Solution . get_result ( ) ) NEW_LINE","n = int ( input ( ) ) stones = list ( map ( lambda t : int ( t ) , input ( ) . split ( ) ) ) q = int ( input ( ) ) queries = list ( map ( lambda t : int ( t ) , input ( ) . split ( ) ) )   stones . sort ( )   added_stones = [ ] added_stones . append ( stones [ 0 ] ) for i in range ( 1 , n , 1 ) : added_stones . append ( stones [ i ] + added_stones [ i - 1 ] )   computed_queries = { }   for qidx , qq in enumerate ( queries ) : if qq in computed_queries : queries [ qidx ] = computed_queries [ qq ] continue   i = n - 2 multiplier = 1 cost = 0 while i >= 0 : pp = pow ( qq , multiplier ) nexti = i - pp if nexti < 0 : cost += added_stones [ i ] * multiplier break cost += ( added_stones [ i ] - added_stones [ nexti ] ) * multiplier multiplier += 1 i = nexti queries [ qidx ] = cost computed_queries [ qq ] = cost   print ( * queries , sep = ' ▁ ' ) NEW_LINE"],"bleu":1.5372556037474803e-5,"rouge_l":0.040935018454311606}
{"id":483,"predictions":["n = int ( input ( ) ) lst = [ ] for i in range ( n ) : lst . append ( list ( map ( int , input ( ) . split ( ) ) ) ) lst . append ( [ ] ) for i in range ( n ) : lst [ i ] . append ( lst [ i ] [ 0 ] ) print ( * lst ) NEW_LINE"],"references":["def binaryToDecimal ( n ) : return int ( n , 2 ) s = input ( ) s = s . replace ( \" > \" , \"1000\" ) s = s . replace ( \" < \" , \"1001\" ) s = s . replace ( \" + \" , \"1010\" ) s = s . replace ( \" - \" , \"1011\" ) s = s . replace ( \" . \" , \"1100\" ) s = s . replace ( \" , \" , \"1101\" ) s = s . replace ( \" [ \" , \"1110\" ) s = s . replace ( \" ] \" , \"1111\" ) p = binaryToDecimal ( s ) ans = p % ( ( 10 ** 6 ) + 3 ) print ( ans ) NEW_LINE","    f = { ' > ' : '1000' , ' < ' : '1001' , ' + ' : '1010' , ' - ' : '1011' , ' . ' : '1100' , ' , ' : '1101' , ' [ ' : '1110' , ' ] ' : '1111' }     t = input ( ) u = ' ' for j in t : u += f [ j ] print ( int ( u , 2 ) % 1000003 ) NEW_LINE","x = list ( input ( ) ) a = ' ' for i in x : if i == ' > ' : a += '1000' elif i == ' < ' : a += '1001' elif i == ' + ' : a += '1010' elif i == ' - ' : a += '1011' elif i == ' . ' : a += '1100' elif i == ' , ' : a += '1101' elif i == ' [ ' : a += '1110' elif i == ' ] ' : a += '1111' y = int ( a ) decimal , i , n = 0 , 0 , 0 while ( y != 0 ) : dec = y % 10 decimal = decimal + dec * pow ( 2 , i ) y = y \/\/ 10 i += 1 print ( decimal % 1000003 ) NEW_LINE"],"bleu":0.16669894839987803,"rouge_l":0.28421665695981363}
{"id":484,"predictions":["n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) )   given = sum ( arr ) needed = given * 2 + 1   for_each = ( needed + n - 1 ) \/\/ n   print ( max ( for_each , max ( sorted ( arr ) ) ) ) NEW_LINE"],"references":["def gcd ( a , b ) : a , b = max ( a , b ) , min ( a , b ) while a % b != 0 : a %= b a , b = b , a return b   def gsd ( a , b ) : return a * b \/\/ gcd ( a , b )   n = int ( input ( ) ) m = list ( map ( int , input ( ) . split ( ) ) ) r = list ( map ( int , input ( ) . split ( ) ) ) x = m [ 0 ] for i in range ( 1 , n ) : x = gsd ( x , m [ i ] ) count = 0 for i in range ( x ) : for j in range ( n ) : if i % m [ j ] == r [ j ] : count += 1 breakprint ( count \/ x ) NEW_LINE","n = int ( input ( ) ) m = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) [ : n ] r = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) [ : n ] counter = 0 for i in range ( 0 , 10000000 ) : for j in range ( 0 , n ) : if ( i % m [ j ] == r [ j ] ) : counter = counter + 1 breakprint ( counter \/ 10000000 ) NEW_LINE","def gcd ( a , b ) : if b == 0 : return a return gcd ( b , a % b )     def lcm ( a , b ) : return a * b \/\/ gcd ( a , b )     n = int ( input ( ) ) m = list ( map ( int , input ( ) . split ( ) ) ) r = list ( map ( int , input ( ) . split ( ) ) ) l = 1 s = set ( ) for i in range ( n ) : l = lcm ( l , m [ i ] ) for k in range ( l \/\/ min ( m ) + 1 ) : for j in range ( n ) : if m [ j ] * k + r [ j ] <= l : s . add ( m [ j ] * k + r [ j ] ) if 0 in s : s . remove ( 0 ) q = len ( s ) print ( q \/ l ) NEW_LINE"],"bleu":0.2273936133107782,"rouge_l":0.4190790288068755}
{"id":485,"predictions":["from sys import stdininput = stdin . readlinen , m = map ( int , input ( ) . split ( ) ) l = [ ] for _ in range ( m ) : l , r , c = map ( int , input ( ) . split ( ) ) l . append ( [ [ l , r , c ] ) for i in range ( r ) ] ) print ( * l , sep = \" ▁ \" ) NEW_LINE"],"references":["n , a , b = map ( int , input ( ) . split ( ) ) if n > a * b : print ( - 1 ) else : arr = [ [ 0 ] * b for _ in range ( a ) ] x = 1 y = 2   for i in range ( a ) : for j in range ( b ) :   if ( i + j ) % 2 == 0 : if x <= n : arr [ i ] [ j ] = x x += 2 else : if y <= n : arr [ i ] [ j ] = y y += 2 NEW_LINE","n , a , b = map ( int , input ( ) . split ( ) ) if a * b < n : print ( - 1 ) ; exit ( ) for i in range ( a ) : x = [ str ( j ) if j <= n else '0' for j in range ( i * b + 1 , ( i + 1 ) * b + 1 ) ] if i & 1 == 0 : x = list ( reversed ( x ) ) print ( ' ▁ ' . join ( x ) ) NEW_LINE","n , a , b = map ( int , input ( ) . split ( ) ) ans = [ ] if n <= a * b : if b % 2 == 1 : for i in range ( 1 , a * b + 1 ) : if i <= n : ans . append ( i ) else : ans . append ( 0 ) if len ( ans ) % b == 0 : print ( * ans ) ans = [ ] else : for i in range ( 1 , a * b + 1 ) : if i <= n : ans . append ( i ) else : ans . append ( 0 ) if len ( ans ) % b == 0 and ( i \/\/ b ) % 2 == 1 : print ( * ans ) ans = [ ] elif len ( ans ) % b == 0 and ( i \/\/ b ) % 2 == 0 : print ( * ans [ : : - 1 ] ) ans = [ ] else : print ( - 1 ) NEW_LINE"],"bleu":0.28069943358524674,"rouge_l":0.4005710206995004}
{"id":486,"predictions":["n = int ( input ( ) ) suma = ( 2 * n ) - 1 las = n - 2 fir = 2 for item in range ( 1 , n - 1 ) : suma += ( fir * las ) fir += 1 las -= 1 print ( suma ) NEW_LINE"],"references":["s = input ( ) t = input ( ) v = [ ' a ' , ' e ' , ' i ' , ' o ' , ' u ' ] if len ( s ) == len ( t ) : for i in range ( len ( s if len ( s ) < len ( t ) else t ) ) : if s [ i ] in v and t [ i ] in v : continue elif s [ i ] in v or t [ i ] in v : print ( \" NO \" ) exit ( ) else : continue print ( ' YES ' ) else : print ( ' NO ' ) NEW_LINE","a = input ( ) b = input ( ) c = 0 vowels = [ ' a ' , ' e ' , ' i ' , ' o ' , ' u ' ] if len ( a ) == len ( b ) : for index , i in enumerate ( a ) : if a [ index ] in vowels and b [ index ] in vowels : c = 1 elif a [ index ] not in vowels and b [ index ] not in vowels : c = 1 else : c = 0 break if c == 1 : print ( \" Yes \" ) elif c == 0 : print ( \" No \" )   else : print ( \" No \" )   NEW_LINE","s = input ( ) t = input ( ) if len ( s ) != len ( t ) : print ( \" No \" ) else : p = 1 l = [ ' a ' , ' e ' , ' i ' , ' o ' , ' u ' ] for i in range ( len ( s ) ) : if s [ i ] in l and t [ i ] in l : p = 1 elif s [ i ] not in l and t [ i ] not in l : p = 1 else : p = 0 break if p == 1 : print ( \" Yes \" ) else : print ( \" No \" ) NEW_LINE"],"bleu":0.027189230876123776,"rouge_l":0.23170933113129646}
{"id":487,"predictions":["from collections import defaultdict , deque , Counterfrom sys import stdin , stdoutfrom heapq import heappush , heappopimport mathimport ioimport osimport mathimport bisect   NEW_LINE"],"references":["import sysinput = sys . stdin . readlinefrom collections import defaultdict as dcfrom collections import Counterfrom bisect import bisect_right , bisect_leftimport mathfrom operator import itemgetterfrom heapq import heapify , heappop , heappushfrom queue import PriorityQueue as pqfor _ in range ( int ( input ( ) ) ) : n , d = map ( int , input ( ) . split ( ) ) f = 0 s = math . ceil ( math . sqrt ( d ) ) i = s while ( i > 0 and f == 0 ) : if i + math . ceil ( d \/ ( i + 1 ) ) <= n : f = 1 break i -= 1 if f or d <= n : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE","from collections import defaultdictfrom collections import dequeimport bisectimport heapqfrom math import sqrt , ceil def ri ( ) : return int ( input ( ) ) def rl ( ) : return list ( map ( int , input ( ) . split ( ) ) ) t = ri ( ) for _ in range ( t ) : n , d = rl ( ) ans = \" NO \" for x in range ( int ( sqrt ( d ) ) - 10 , int ( sqrt ( d ) ) + 10 ) : if x >= 0 and x <= n : val = x + ceil ( d \/ ( x + 1 ) ) if val <= n : ans = \" YES \" break print ( ans )   NEW_LINE","from collections import defaultdictfrom collections import dequeimport bisectimport heapqfrom math import sqrt , ceil def ri ( ) : return int ( input ( ) ) def rl ( ) : return list ( map ( int , input ( ) . split ( ) ) )   def f ( x ) : return x + ceil ( d \/ ( x + 1 ) )     def ternary_search ( f , a , b ) : while ( b - a ) >= 3 : alpha = 1 \/ 3 c = ( 1 - alpha ) * a + alpha * b c = int ( c ) d = alpha * a + ( 1 - alpha ) * b d = int ( d ) fc = f ( c ) fd = f ( d ) counter = 0 while fc == fd : if counter % 2 == 0 : d += 1 else : c -= 1 counter += 1 if d > b or c < a : return ( a , b )   if fc < fd : b = d else : a = c   return ( a , b )   t = ri ( ) for _ in range ( t ) : n , d = rl ( ) a , b = ternary_search ( f , 0 , n ) for x in range ( a , b + 1 ) : if f ( x ) <= n : ans = \" YES \" break else : ans = \" NO \" \t \t \t   print ( ans ) NEW_LINE"],"bleu":0.0015355233242897363,"rouge_l":0.10632734878856547}
{"id":488,"predictions":["def solve ( arr ) : res = 0 for i in range ( len ( arr ) - 1 ) : if arr [ i ] % 2 == 0 : res = res + 1 return res else : while res > 0 : if arr [ i ] != arr [ i + 1 ] : res = res + 1 return res + 1 return res                 def main ( ) : arr = list ( map ( int , input ( ) . split ( ' ▁ ' ) ) ) print ( solve ( arr ) ) main ( ) NEW_LINE"],"references":["  n = int ( input ( ) ) lis = list ( map ( int , input ( ) . split ( ) ) ) m = int ( input ( ) ) edges = [ ] for d in range ( m ) : edges . append ( list ( map ( int , input ( ) . split ( ) ) ) ) edges . sort ( key = lambda x : x [ 2 ] ) visited = [ ] count = 0 for i in range ( m ) : if edges [ i ] [ 1 ] not in visited : visited . append ( edges [ i ] [ 1 ] ) count += edges [ i ] [ 2 ]   if len ( visited ) == n - 1 : print ( count ) else : print ( - 1 ) NEW_LINE","import sysimport math n = int ( input ( ) ) q = map ( int , input ( ) . split ( ) ) m = int ( input ( ) ) upc = [ 1000005 ] * nfor i in range ( m ) : a , b , c = map ( int , input ( ) . split ( ) ) upc [ b - 1 ] = min ( upc [ b - 1 ] , c )   a , c = 0 , 0   for x in upc : if x > 1000000 : c += 1 if c > 1 : print ( \" - 1\" ) sys . exit ( 0 ) else : a += x   print ( a ) NEW_LINE","def find ( arr , a ) : if arr [ a ] == a : return a arr [ a ] = find ( arr , arr [ a ] ) return arr [ a ] n = int ( input ( ) ) x = list ( map ( int , input ( ) . split ( ) ) ) arr = [ i for i in range ( n + 1 ) ] m = int ( input ( ) ) l = [ ] for _ in range ( m ) : l . append ( list ( map ( int , input ( ) . split ( ) ) ) ) l . sort ( key = lambda k : k [ 2 ] ) val = nans = 0 for i in range ( m ) : x = find ( arr , l [ i ] [ 0 ] ) y = find ( arr , l [ i ] [ 1 ] ) if x != y and y == l [ i ] [ 1 ] : val -= 1 arr [ y ] = x ans += l [ i ] [ 2 ] if val != 1 : print ( - 1 ) else : print ( ans ) NEW_LINE"],"bleu":0.2762807706157538,"rouge_l":0.3080427075603924}
{"id":489,"predictions":["import math , sysfrom collections import defaultdict , dequeimport bisect as bidef yes ( ) : print ( ' YES ' ) def no ( ) : print ( ' NO ' ) def I ( ) : return ( int ( sys . stdin . readline ( ) ) ) def In ( ) : return ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) def Sn ( ) : return sys . stdin . readline ( ) . strip ( ) def Pr ( x ) : sys . stdout . write ( str ( x ) + ' \\n ' ) NEW_LINE"],"references":["Into = str ( input ( ) ) NEW_LINE Into = list ( Into ) NEW_LINE hello = [ ' h ' , ' e ' , ' l ' , ' l ' , ' o ' ] NEW_LINE cur = 0 l NEW_LINE ist1 = [ ] NEW_LINE for i in Into : if NEW_LINE i == hello [ cur ] : list1 . append ( i ) NEW_LINE cur += 1 NEW_LINE if len ( list1 ) == 5 : breakif NEW_LINE list1 == hello : print ( ' YES ' ) else : print ( ' NO ' ) NEW_LINE","n = input ( ) NEW_LINE l = list ( n ) NEW_LINE s = len ( l )   NEW_LINE def main ( ) : i1 , i2 , i3 , i4 , i5 = 0 , 0 , 0 , 0 , 0 NEW_LINE for i in range ( s ) : if NEW_LINE INDENT ( l [ i ] == ' h ' ) : i1 = i + 1 NEW_LINE DEDENT break NEW_LINE if i1 == 0 : print ( ' NO ' ) NEW_LINE return NEW_LINE for i in range ( i1 , s ) : if NEW_LINE INDENT ( l [ i ] == ' e ' ) : i2 = i + 1 NEW_LINE DEDENT break NEW_LINE if i2 == 0 : print ( ' NO ' ) NEW_LINE return NEW_LINE for i in range ( i2 , s ) : if NEW_LINE INDENT ( l [ i ] == ' l ' ) : i3 = i + 1 NEW_LINE DEDENT break NEW_LINE if i3 == 0 : print ( ' NO ' ) NEW_LINE return NEW_LINE for i in range ( i3 , s ) : if NEW_LINE INDENT ( l [ i ] == ' l ' ) : i4 = i + 1 NEW_LINE DEDENT break NEW_LINE if i4 == 0 : print ( ' NO ' ) NEW_LINE return   for i in range ( i4 , s ) : if NEW_LINE INDENT ( l [ i ] == ' o ' ) : i5 = i + 1 NEW_LINE DEDENT break NEW_LINE if i5 == 0 : print ( ' NO ' ) NEW_LINE return elif ( i1 < i2 < i3 < i4 < i5 ) : print ( ' YES ' ) NEW_LINE return else : print ( ' NO ' ) NEW_LINE return     main ( )   NEW_LINE","import re ; NEW_LINE x = input ( ) NEW_LINE x . lower ( ) NEW_LINE if re . search ( \" h . * e . * l . * l . * o \" , x ) : NEW_LINE INDENT print ( \" YES \" ) else : NEW_LINE print ( \" NO \" ) NEW_LINE DEDENT"],"bleu":0.20950967211323115,"rouge_l":0.3589233122242868}
{"id":490,"predictions":["n , b = map ( int , input ( ) . split ( ) ) l = [ ] l . extend ( map ( int , input ( ) . split ( ) ) ) l . remove ( max ( l ) ) if sum ( l ) <= b : print ( l ) else : print ( 0 ) NEW_LINE"],"references":["n = int ( input ( ) ) m = int ( input ( ) ) l = [ ] for i in range ( n ) : l . append ( int ( input ( ) ) ) l . sort ( reverse = True ) s = 0 for i in range ( n ) : s += l [ i ] if s >= m : print ( i + 1 ) break NEW_LINE","n = int ( input ( ) ) m = int ( input ( ) ) usb = [ ]   for _ in range ( n ) : usb . append ( int ( input ( ) ) )   for i , val in enumerate ( sorted ( usb , reverse = True ) ) : m -= val   if m <= 0 : print ( i + 1 ) break NEW_LINE","ls = [ ] sum1 = 0 lis = [ ] n = int ( input ( ) ) m = int ( input ( ) ) for i in range ( n ) : ls . append ( int ( input ( ) ) ) ls . sort ( ) for i in ls [ : : - 1 ] : sum1 += i lis . append ( i ) if sum1 >= m : breakprint ( len ( lis ) ) NEW_LINE"],"bleu":0.25892153082212727,"rouge_l":0.48555833522856484}
{"id":491,"predictions":["import sysfrom os import pathif ( path . exists ( ' input . txt ' ) ) : sys . stdin = open ( \" input . txt \" , \" r \" ) sys . stdout = open ( \" output . txt \" , \" w \" )       NEW_LINE"],"references":["n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) i = 0 while i < n and k > 0 and a [ i ] < 0 : a [ i ] = - 1 * a [ i ] i += 1 k -= 1 a = sorted ( a ) if k % 2 == 1 : a [ 0 ] = - 1 * a [ 0 ] print ( sum ( a ) ) NEW_LINE","import heapq   n , k = map ( int , input ( ) . split ( ' ▁ ' ) ) pos = list ( map ( int , input ( ) . split ( ' ▁ ' ) ) ) heapq . heapify ( pos ) s = sum ( pos ) i = 0 while k > 0 : k -= 1 n = heapq . heappop ( pos ) heapq . heappush ( pos , - n ) s = s + ( - n ) - ( n ) print ( s )   NEW_LINE","def I ( ) : return list ( map ( int , input ( ) . split ( ) ) )     n , k = I ( ) sequence_number = I ( ) count = 0 if sequence_number [ 0 ] > 0 and k % 2 == 1 : print ( sum ( sequence_number ) - sequence_number [ 0 ] * 2 ) exit ( ) elif sequence_number [ 0 ] > 0 and k % 2 == 0 : print ( sum ( sequence_number ) ) exit ( ) else : for i in range ( k ) : if sequence_number [ i ] < 0 : sequence_number [ i ] = - sequence_number [ i ] else : count = i break if i == n - 1 : count = n breaksequence_number . sort ( ) if count != 0 : if ( k - count ) % 2 == 0 : print ( sum ( sequence_number ) ) exit ( ) else : print ( sum ( sequence_number ) - sequence_number [ 0 ] * 2 ) exit ( ) print ( sum ( sequence_number ) ) NEW_LINE"],"bleu":0.03279919939765341,"rouge_l":0.2587878787878788}
{"id":492,"predictions":["n = int ( input ( ) ) s = input ( ) f = 0 for i in range ( n ) : if s [ i ] == ' F ' : f += 1 if ( i in s ) : f = 1 breakif ( f == 0 ) : print ( ' YES ' ) else : print ( ' NO ' ) NEW_LINE"],"references":["n = int ( input ( ) ) S = input ( ) A = S . count ( \" SF \" ) B = S . count ( \" FS \" ) if A > B : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE","count1 = 0 count2 = 0 n = int ( input ( ) ) row = list ( str ( input ( ) ) ) for j in range ( n - 1 ) : if row [ j ] == ' S ' and row [ j + 1 ] == ' F ' : count1 = count1 + 1 elif row [ j ] == ' F ' and row [ j + 1 ] == ' S ' : count2 = count2 + 1 if count1 > count2 : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE","input ( ) s = input ( ) if s . count ( \" SF \" ) > s . count ( \" FS \" ) : print ( ' YES ' ) else : print ( ' NO ' ) NEW_LINE"],"bleu":0.5617854555277789,"rouge_l":0.6739119264169364}
{"id":493,"predictions":["from sys import stdin , stdoutfrom os import pathrd = lambda : stdin . readline ( ) . strip ( ) wr = stdout . writeif ( path . exists ( ' input . txt ' ) ) : stdin = open ( \" input . txt \" , \" r \" ) import time , math NEW_LINE"],"references":["with open ( ' input . txt ' , ' r ' ) as f : fs = f . read ( ) . strip ( ) . split ( ' \\n ' )   n = [ int ( i ) for i in fs [ 1 ] ] c = - 1 i , ans = 0 , \" YES \" while i < len ( n ) : if n [ i ] == 1 : count = 0 while i + 1 < len ( n ) : if n [ i + 1 ] == 1 : break count += 1 i += 1 else : count = c if c == - 1 : c = count elif c != count : ans = \" NO \" break i += 1   with open ( ' output . txt ' , ' w ' ) as f : f . write ( ans ) NEW_LINE","import syssys . stdin = open ( \" input . txt \" , \" r \" ) sys . stdout = open ( \" output . txt \" , \" w + \" ) a = int ( input ( ) ) ; z = [ ] for i , j in enumerate ( input ( ) ) : if j == '1' : z . append ( i ) f = [ ] for i in range ( 1 , len ( z ) ) : f . append ( z [ i ] - z [ i - 1 ] ) if len ( set ( f ) ) <= 1 : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE","nro_linea = 0 manejador_archivo = open ( ' input . txt ' ) for linea in manejador_archivo : if nro_linea == 0 : n = int ( linea . split ( ) [ 0 ] ) else : secuencia = list ( str ( linea ) ) nro_linea = nro_linea + 1 manejador_archivo . close ( )   i = 0 c = 0 k = 0 fallo = Falsewhile i < n : if secuencia [ i ] == '1' : while i < n and secuencia [ i ] == '1' : c = c + 1 i = i + 1 while i < n and secuencia [ i ] == '0' : k = k + 1 i = i + 1 break i = i + 1 while i < n : c2 = 0 while i < n and secuencia [ i ] == '1' : c2 = c2 + 1 i = i + 1 if c2 != c : fallo = True break k2 = 0 while i < n and secuencia [ i ] == '0' : k2 = k2 + 1 i = i + 1 if k2 != k and i < n : fallo = True break   if not fallo : rpta = ' YES ' else : rpta = ' NO ' archivo_salida = open ( \" output . txt \" , \" w \" ) archivo_salida . write ( rpta ) archivo_salida . close ( ) NEW_LINE"],"bleu":0.13371571497117496,"rouge_l":0.242544731610338}
{"id":494,"predictions":["n , m , a , d , p = map ( int , input ( ) . split ( ) ) NEW_LINE"],"references":["BigNum = 10 ** 20   n , m , a , d = map ( int , input ( ) . split ( ' ▁ ' ) ) ts = [ 0 ] + list ( map ( int , input ( ) . split ( ' ▁ ' ) ) ) + [ BigNum ]   def empsInRange ( l , r ) : em1 = l \/\/ a + 1 em2 = r \/\/ a return ( em1 , min ( em2 , n ) )   empDoorGroup = d \/\/ a + 1   def moveEmps ( emps , last ) : em1 , em2 = emps if em1 > em2 : return last , 0 if em1 * a <= last + d : gr1 = ( last + d - em1 * a ) \/\/ a em1 += 1 + gr1 if em1 > em2 : return last , 0   doorGroups = ( em2 - em1 + 1 + empDoorGroup - 1 ) \/\/ empDoorGroup last = ( em1 + empDoorGroup * ( doorGroups - 1 ) ) * a   return last , doorGroups   res = 0 last = - BigNum   for i in range ( 1 , len ( ts ) ) : NEW_LINE","n1 , m , a , d = list ( map ( int , input ( ) . split ( ) ) ) t = list ( map ( int , input ( ) . split ( ) ) ) from bisect import * from math import * insort ( t , a * n1 ) pred = 0 k = 0 kpred = 0 n = 0 step = d \/\/ a + 1 sol = 0 fl = 0 for i in t : if ( i > pred ) : if fl == 0 : n = ( i - pred + ( pred % a ) ) \/\/ a if n != 0 : k += ( n \/\/ step ) * step - step * ( n % step == 0 ) + 1 if k > n1 : k = n1 fl = 1 NEW_LINE"],"bleu":0.003112912672055714,"rouge_l":0.21403996445578616}
{"id":495,"predictions":["def solve ( ) : n = int ( input ( ) ) lst = [ ] for i in range ( n ) : lst . append ( list ( map ( int , input ( ) . split ( ) ) ) ) lst . sort ( ) for i in range ( n ) : if lst [ i ] [ 0 ] > lst [ i ] [ 1 ] : lst [ i ] [ 0 ] = lst [ i ] [ 1 ] lst [ i ] [ 0 ] = lst [ i ] [ 1 ] + 1 lst [ i ] [ 1 ] = lst [ i ] [ 1 ] if lst [ 0 ] [ 1 ] > lst [ n - 1 ] [ 1 ] : print ( \" YES \" ) return print ( \" NO \" )                def main ( ) : NEW_LINE"],"references":["n = int ( input ( ) ) ans = \" YES \" num = 0 for i in range ( n ) : w , h = map ( int , input ( ) . split ( ) ) if i == 0 : num = max ( w , h ) else : if max ( w , h ) <= num : num = max ( w , h ) elif min ( w , h ) <= num : num = min ( w , h ) else : ans = \" NO \" print ( ans ) NEW_LINE","n = int ( input ( ) ) lmain = [ ] x , y = map ( int , input ( ) . split ( ) ) lmain . append ( max ( x , y ) ) for i in range ( 1 , n ) : a , b = map ( int , input ( ) . split ( ) ) lmain . append ( [ a , b ] ) ans = Truefor i in range ( 1 , n ) : if ( max ( lmain [ i ] [ 0 ] , lmain [ i ] [ 1 ] ) <= lmain [ i - 1 ] ) : lmain [ i ] = max ( lmain [ i ] [ 0 ] , lmain [ i ] [ 1 ] ) elif ( min ( lmain [ i ] [ 0 ] , lmain [ i ] [ 1 ] ) <= lmain [ i - 1 ] ) : lmain [ i ] = min ( lmain [ i ] [ 0 ] , lmain [ i ] [ 1 ] ) else : ans = False breakif ( ans ) : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE","n = int ( input ( ) ) p = max ( map ( int , input ( ) . split ( ) ) ) ans = ' YES ' for i in range ( n - 1 ) : w , h = map ( int , input ( ) . split ( ) ) if w > h : w , h = h , w if h <= p : p = h elif w <= p : p = w else : ans = ' NO ' breakprint ( ans ) NEW_LINE"],"bleu":0.5396614835670389,"rouge_l":0.5533564242124362}
{"id":496,"predictions":["n , m , k = map ( int , input ( ) . split ( ) ) p = list ( map ( int , input ( ) . split ( ) ) ) s = list ( map ( int , input ( ) . split ( ) ) ) k = list ( map ( int , input ( ) . split ( ) ) ) count = 0 for i in k : l = s [ i - 1 ] t = s [ i - 1 ] for i in range ( n ) : if s [ i ] == l and p [ i ] > t : count += 1 breakprint ( count ) NEW_LINE"],"references":["n , m , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) ans , result = 0 , 0 page , new_result = None , 1 for i in range ( m ) : if ( a [ i ] - result ) \/\/ k != page : ans += 1 result = new_result page = ( a [ i ] - result ) \/\/ k new_result += 1 print ( ans ) NEW_LINE","from collections import defaultdictimport sysinput = sys . stdin . readline   inf = 100000000000000000 NEW_LINE","n , m , k = map ( int , input ( ) . split ( ) ) ar = list ( map ( int , input ( ) . split ( ) ) ) page = kobj = 0 temp = 0 count = 0 i = 0 while i < m : if ar [ i ] - obj <= page : temp += 1 i += 1 continue if temp != 0 : count += 1 obj += temp temp = 0 if ( ar [ i ] - obj ) > page : page += k * ( int ( ( ar [ i ] - obj - page + k - 1 ) \/ k ) ) if temp != 0 : count += 1 print ( count ) NEW_LINE"],"bleu":0.409738650456658,"rouge_l":0.5627680592510226}
{"id":497,"predictions":["for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE if s . count ( ' * ' ) != k : NEW_LINE INDENT s = s . index ( ' * ' ) NEW_LINE DEDENT else : NEW_LINE INDENT s = s . index ( ' * ' ) NEW_LINE if s . count ( ' * ' ) != k : NEW_LINE INDENT s = s . index ( ' * ' ) NEW_LINE DEDENT DEDENT print ( s ) NEW_LINE DEDENT"],"references":["import math NEW_LINE cases = int ( input ( ) ) NEW_LINE for c in range ( cases ) : NEW_LINE INDENT length , k = map ( int , input ( ) . split ( ) ) NEW_LINE string = input ( ) NEW_LINE start = string . index ( ' * ' ) NEW_LINE end = length - 1 - string [ : : - 1 ] . index ( ' * ' ) NEW_LINE count = 1 NEW_LINE while start < end : NEW_LINE INDENT ind = start + k NEW_LINE if ind >= end : NEW_LINE INDENT count += 1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT while ind > start : NEW_LINE INDENT if string [ ind ] == ' * ' : NEW_LINE INDENT count += 1 NEW_LINE break NEW_LINE DEDENT ind -= 1 NEW_LINE DEDENT DEDENT start = ind NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT","tests = int ( input ( ) ) NEW_LINE for _ in range ( tests ) : NEW_LINE INDENT n , k = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE s = list ( input ( ) ) NEW_LINE start = 0 NEW_LINE end = len ( s ) NEW_LINE count = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == ' * ' : NEW_LINE INDENT s [ i ] = ' x ' NEW_LINE start = i NEW_LINE count += 1 NEW_LINE break NEW_LINE DEDENT DEDENT for i2 in range ( len ( s ) ) : NEW_LINE INDENT i = len ( s ) - i2 - 1 NEW_LINE if s [ i ] == ' * ' : NEW_LINE INDENT s [ i ] = ' x ' NEW_LINE end = i NEW_LINE count += 1 NEW_LINE break NEW_LINE DEDENT DEDENT if end == len ( s ) : NEW_LINE INDENT end = start NEW_LINE DEDENT counter = 0 NEW_LINE while end - start > k : NEW_LINE INDENT for i in range ( start + k , start , - 1 ) : NEW_LINE INDENT if s [ i ] == ' * ' : NEW_LINE INDENT s [ i ] = ' x ' NEW_LINE start = i NEW_LINE count += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT print ( count ) NEW_LINE DEDENT","tests = int ( input ( ) ) NEW_LINE for _ in range ( tests ) : NEW_LINE INDENT n , k = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE s = list ( input ( ) ) NEW_LINE start = 0 NEW_LINE end = len ( s ) NEW_LINE count = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == ' * ' : NEW_LINE INDENT s [ i ] = ' x ' NEW_LINE start = i NEW_LINE count += 1 NEW_LINE break NEW_LINE DEDENT DEDENT for i2 in range ( len ( s ) ) : NEW_LINE INDENT i = len ( s ) - i2 - 1 NEW_LINE if s [ i ] == ' * ' : NEW_LINE INDENT s [ i ] = ' x ' NEW_LINE end = i NEW_LINE count += 1 NEW_LINE break NEW_LINE DEDENT DEDENT if end == len ( s ) : NEW_LINE INDENT end = start NEW_LINE DEDENT counter = 0 NEW_LINE while end - start > k : NEW_LINE INDENT for i in range ( start + k , start , - 1 ) : NEW_LINE INDENT if s [ i ] == ' * ' : NEW_LINE INDENT s [ i ] = ' x ' NEW_LINE start = i NEW_LINE count += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT print ( count ) NEW_LINE DEDENT"],"bleu":0.42473423031015944,"rouge_l":0.5087714645627528}
{"id":498,"predictions":["def solve ( N , A , B , C , T ) : NEW_LINE INDENT N = 0 NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE B = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE C = [ ( int ( input ( ) ) ) for _ in range ( N ) ] NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT ans += C [ i ] * A [ i ] NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT ans += C [ i ] * B [ i ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["n , a , b , c , T = map ( int , input ( ) . split ( ) ) ts = list ( map ( int , input ( ) . split ( ) ) ) ts . sort ( ) ans = 0 for t in ts : temp = - 10 ** 18 for u in range ( t , T + 1 ) : temp = max ( temp , c * ( u - t ) + a - b * ( u - t ) ) NEW_LINE","n , A , B , C , T = map ( int , input ( ) . split ( ) ) t = list ( map ( int , input ( ) . split ( ) ) ) if ( B >= C ) : print ( A * n ) else : ans = 0 for c in t : ans += ( T - c ) * ( C - B ) ans += n * A print ( ans ) NEW_LINE","n , A , B , C , T = map ( int , input ( ) . split ( ) ) t = [ int ( i ) for i in input ( ) . split ( ) ] t . sort ( )   total_sum = 0   for lower_border in range ( n + 1 ) : NEW_LINE"],"bleu":0.3622426476999706,"rouge_l":0.5754716981132076}
{"id":499,"predictions":["def main_function ( ) : n = int ( input ( ) ) names = [ ] output_list = [ ] dict = { } for i in range ( n ) : names . append ( input ( ) ) for name in names : if not name in dict : output_list . append ( \" NO \" ) dict [ name ] = 1 else : output_list . append ( \" YES \" ) return \" \\n \" . join ( output_list )     print ( main_function ( ) ) NEW_LINE"],"references":["f = lambda : [ int ( q ) - 1 for q in input ( ) . split ( ) ] def g ( ) : for i in p : if h [ i ] == k and not v [ i ] : return i   r = range ( int ( input ( ) ) ) t , h = 1e9 , f ( ) u = [ set ( f ( ) [ 1 : ] ) for i in r ]   for k in ( 0 , 1 , 2 ) : p = list ( r ) d = - 1 v = [ q . copy ( ) for q in u ]   while p : i = g ( ) while i != None : d += 1 p . remove ( i ) for q in v : q . discard ( i ) i = g ( ) k = ( k + 1 ) % 3 d += 1   t = min ( d , t )   print ( t ) NEW_LINE","n = int ( input ( ) ) c = list ( map ( int , input ( ) . split ( ) ) ) d = dict ( ) d [ 1 ] = [ ] d [ 2 ] = [ ] d [ 3 ] = [ ] for i in range ( n ) : d [ c [ i ] ] . append ( i ) done = set ( ) mas = [ ] k = 0 poss = set ( ) for i in range ( n ) : l = list ( map ( int , input ( ) . split ( ) ) ) l = l [ 1 : ] mas . append ( l ) if len ( l ) == 0 : k = c [ i ] poss . add ( ( k , i ) ) o = 0 bigans = 1000000000 for a in poss : k = a [ 0 ] done = set ( ) done . add ( a [ 1 ] + 1 ) ans = 1 while len ( done ) != n : NEW_LINE","f = lambda : [ int ( q ) - 1 for q in input ( ) . split ( ) ] def g ( ) : for i in p : if h [ i ] == k and not v [ i ] : return i   r = range ( int ( input ( ) ) ) t , h = 1e9 , f ( ) u = [ set ( f ( ) [ 1 : ] ) for i in r ]   for k in ( 0 , 1 , 2 ) : p = list ( r ) d = - 1 v = [ q . copy ( ) for q in u ]   while p : i = g ( ) while i != None : d += 1 p . remove ( i ) for q in v : q . discard ( i ) i = g ( ) k = ( k + 1 ) % 3 d += 1   t = min ( d , t )   print ( t ) NEW_LINE"],"bleu":0.11227163636296299,"rouge_l":0.32550693703308425}
{"id":500,"predictions":["from math import gcd NEW_LINE def lcm ( a , b ) : return ( a * b ) \/\/ gcd ( a , b ) NEW_LINE N = int ( input ( ) ) NEW_LINE x , y , z = 0 , 0 , 0 NEW_LINE for i in range ( N ) : q = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if q == 1 : NEW_LINE INDENT print ( \" YES \" ) else : NEW_LINE print ( \" NO \" ) NEW_LINE DEDENT"],"references":["def cc ( w , me , fe ) : global m , f if w . endswith ( me ) : m = True return True elif w . endswith ( fe ) : f = True return True else : return Falsedef ad ( w ) : return cc ( w , ' lios ' , ' liala ' ) def nn ( w ) : return cc ( w , ' etr ' , ' etra ' ) def vb ( w ) : return cc ( w , ' initis ' , ' inites ' ) s , n , m , f = input ( ) . split ( ) , False , False , False for w in s : if not n : if ad ( w ) or vb ( w ) and len ( s ) == 1 : pass elif nn ( w ) : n = True else : print ( \" NO \" ) exit ( ) elif not vb ( w ) : print ( \" NO \" ) exit ( ) print ( ' YES ' if len ( s ) == 1 or ( n and ( m ^ f ) ) else ' NO ' ) NEW_LINE","def classification ( s ) : isWord = False gender = 0 tipo = 0 feminino = [ \" liala \" , \" etra \" , \" inites \" ] masculino = [ \" lios \" , \" etr \" , \" initis \" ]   for i in range ( 3 ) : if ( s . endswith ( feminino [ i ] ) ) : gender = 1 tipo = i isWord = True elif ( s . endswith ( masculino [ i ] ) ) : tipo = i isWord = True return [ isWord , gender , tipo ]   words = [ classification ( s ) for s in input ( ) . split ( ) ] areWords = [ x [ 0 ] for x in words ] gender = [ x [ 1 ] for x in words ] tipo = [ x [ 2 ] for x in words ]   poss = Truefor i in areWords : if ( i == 0 ) : poss = False   if ( poss ) : last = gender [ 0 ] for i in gender [ 1 : ] : if ( i != last ) : poss = False break last = i   if ( poss ) : last = tipo [ 0 ] for i in tipo [ 1 : ] : if ( i < last ) : poss = False break last = i   if ( poss ) : cnt1 = 0 for i in tipo : if ( i == 1 ) : cnt1 += 1 if ( cnt1 != 1 ) : poss = False   if ( len ( words ) == 1 and areWords [ 0 ] == True ) : poss = True   if ( poss ) : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.09351583388052923,"rouge_l":0.28529864929336224}
{"id":501,"predictions":["s = input ( ) ans = set ( ) ans . add ( s . strip ( ) ) for i in range ( len ( s ) ) : if s [ i ] != ' , ' : ans . add ( s [ i ] ) ans . add ( s [ i ] ) print ( len ( ans ) ) NEW_LINE"],"references":["letters = list ( map ( str , input ( ) ) ) c = set ( ) for letter in letters : if letter . isalpha ( ) : c . add ( letter ) print ( len ( c ) ) NEW_LINE","info = input ( ) if len ( set ( info ) ) - 4 > 0 : print ( len ( set ( info ) ) - 4 ) elif len ( set ( info ) ) - 4 == - 1 : print ( 1 ) elif len ( set ( info ) ) - 4 < 0 : print ( 0 ) NEW_LINE","s = input ( \" \" ) s1 = \" \" for i in s : if i not in s1 : s1 = s1 + ik = len ( s1 ) - 4 if len ( s ) == 2 : print ( 0 ) elif len ( s ) == 3 : print ( 1 ) else : print ( len ( s1 ) - 4 ) NEW_LINE"],"bleu":0.28522641926606523,"rouge_l":0.49609583169211524}
{"id":502,"predictions":["import sys   def main ( ) : l , r , q = map ( int , sys . stdin . read ( ) . strip ( ) . split ( ) ) return min ( l , r ) \/\/ q   print ( main ( ) ) NEW_LINE"],"references":["if __name__ == \" _ _ main _ _ \" : a , b , c , d , k = map ( int , input ( ) . split ( ) ) start = max ( a , c ) end = min ( b , d ) ans = end - start if ans < 0 : ans = 0 elif k < start or k > end : ans = ans + 1 print ( ans ) NEW_LINE","l1 , r1 , l2 , r2 , k = map ( int , input ( ) . split ( ) )   if l2 <= l1 : if r1 >= l1 : n1 = l1 n2 = min ( r1 , r2 ) else : n1 = 0 n2 = 0 else : if r1 >= l1 : n1 = l2 n2 = min ( r1 , r2 ) else : n1 = 0 n2 = 0 if n1 != 0 or n2 != 0 : ans = ( n2 - n1 ) + 1 if k in range ( n1 , n2 + 1 ) : ans -= 1 print ( max ( 0 , ans ) ) else : print ( 0 ) NEW_LINE","l1 , r1 , l2 , r2 , k = map ( int , input ( ) . split ( ) ) if l1 <= l2 <= r1 : if r2 <= r1 : if l2 <= k <= r2 : print ( r2 - l2 ) else : print ( r2 - l2 + 1 ) else : if l2 <= k <= r1 : print ( r1 - l2 ) else : print ( r1 - l2 + 1 ) elif l1 <= l2 and l2 >= r1 : print ( 0 ) elif l2 < l1 <= r2 : if r2 <= r1 : if l1 <= k <= r2 : print ( r2 - l1 ) else : print ( r2 - l1 + 1 ) else : if l1 <= k <= r1 : print ( r1 - l1 ) else : print ( r1 - l1 + 1 ) else : print ( 0 ) NEW_LINE"],"bleu":0.14271130432112722,"rouge_l":0.34931997136721543}
{"id":503,"predictions":["def check_dub ( arr ) : for i in range ( len ( arr ) - 1 ) : if arr [ i ] > arr [ i + 1 ] : return ' NO ' return ' YES '   def solve ( arr ) : c = 0 first = arr [ 0 ] while c < 8 : if first [ 0 ] == ' NO ' : return ' YES '                  def main ( ) : arr = list ( map ( int , input ( ) . split ( ' ▁ ' ) ) ) NEW_LINE"],"references":["def main ( ) : start , end , t = map ( int , input ( ) . split ( ) ) n = int ( input ( ) ) people = [ ] if n != 0 : people = list ( map ( int , input ( ) . split ( ) ) ) time = start ans = 1e16 answer = 0 for p in people : if p + t > end : break if p - 1 >= 0 : if ans > max ( 0 , time - ( p - 1 ) ) : ans = max ( 0 , time - ( p - 1 ) ) answer = p - 1   time = max ( time , p ) + t   if time + t > end : break   if time + t <= end : answer = time print ( answer )   main ( ) NEW_LINE","begin , end , time = list ( map ( int , input ( ) . split ( ) ) ) n = int ( input ( ) ) if n == 1 : print ( begin ) elif n > 0 : ar = list ( map ( int , input ( ) . split ( ) ) ) ar . sort ( ) i = 0 ar . append ( end - time + 1 ) n += 1   num = begin ans = begin - ar [ 0 ] + 1 fin_ans = ar [ 0 ] - 1 while i < n : num = max ( num + time , ar [ i ] + time ) while i + 1 < n and ar [ i + 1 ] == ar [ i ] : i += 1 num += time i += 1 if i < n and num - ar [ i ] + 1 < ans and max ( ar [ i ] - 1 , num ) + time <= end : ans = num - ar [ i ] + 1 fin_ans = ar [ i ] - 1   print ( fin_ans )   else : print ( begin ) NEW_LINE","import syst1 , t2 , t = map ( int , input ( ) . split ( ) ) u = 1 n = int ( input ( ) ) if n == 0 : print ( t1 ) sys . exit ( ) a = [ int ( i ) for i in input ( ) . split ( ) ] mini = 10 ** 20 ans = 0 time = t1for x in a : if x <= t2 - t : if time - x + 1 < mini and x > 0 : mini = time - x + 1 if x - 1 > time : ans = time else : ans = x - 1 time = t + max ( time , x ) if time > t2 - t : print ( ans ) else : print ( time ) NEW_LINE"],"bleu":0.1915221485080747,"rouge_l":0.23312181314695032}
{"id":504,"predictions":["s = input ( ) a = 0 ; b = 0 for i in s : if i == ' A ' : a += 1 else : b += 1 if b == 0 : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"references":["s = input ( ) if ( s . find ( \" AB \" ) != - 1 and s . find ( \" BA \" ) != - 1 and ( s . find ( \" AB \" ) + 1 < s . rfind ( \" BA \" ) or s . find ( \" BA \" ) + 1 < s . rfind ( \" AB \" ) ) ) : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE","s = input ( ) n = len ( s ) ab = [ False ] * nba = [ False ] * nf = False   for i in range ( 1 , n ) : ab [ i ] |= ab [ i - 1 ] if s [ i - 1 : i + 1 ] == ' AB ' : ab [ i ] |= True if i > 1 and ba [ i - 2 ] : f = True break   ba [ i ] |= ba [ i - 1 ] if s [ i - 1 : i + 1 ] == ' BA ' : ba [ i ] |= True if i > 1 and ab [ i - 2 ] : f = True break   if f : print ( ' YES ' ) else : print ( ' NO ' ) NEW_LINE","s = input ( ) n = len ( s ) l , r = [ ] , [ ] for i in range ( n - 1 ) : if s [ i : i + 2 ] == \" AB \" : l . append ( i ) elif s [ i : i + 2 ] == \" BA \" : r . append ( i ) i , j = 0 , 0 while i < len ( l ) and j < len ( r ) : if l [ i ] + 2 <= r [ j ] : print ( \" YES \" ) exit ( ) else : j += 1 l , r = r , li , j = 0 , 0 while i < len ( l ) and j < len ( r ) : if l [ i ] + 2 <= r [ j ] : print ( \" YES \" ) exit ( ) else : j += 1 print ( \" NO \" ) NEW_LINE"],"bleu":0.24463928645625818,"rouge_l":0.3596462495905666}
{"id":505,"predictions":["n , s = map ( int , input ( ) . split ( ) ) ans = 0 for i in range ( n ) : l , r = map ( int , input ( ) . split ( ) ) for j in range ( min ( l , r ) , max ( l , r ) ) : if ( l <= r ) : ans += 1 print ( ans ) NEW_LINE"],"references":["c = 0 for i in range ( int ( input ( ) . split ( ) [ 0 ] ) ) : a = input ( ) . split ( ) while len ( a ) : if '1' in [ a . pop ( ) , a . pop ( ) ] : c += 1 print ( c ) NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) count = 0 for i in range ( n ) : arr = list ( map ( int , input ( ) . split ( ) ) ) for j in range ( 0 , 2 * m , 2 ) : if arr [ j ] == 1 or arr [ j + 1 ] == 1 : count += 1 print ( count ) NEW_LINE","temp = [ int ( x ) for x in input ( ) . split ( ) ] n = temp [ 0 ] m = temp [ 1 ] result = 0 for i in range ( n ) : a = [ int ( x ) for x in input ( ) . split ( ) ] for j in range ( m ) : if a [ 2 * j - 2 ] == 1 or a [ 2 * j - 1 ] == 1 : result += 1 print ( result ) NEW_LINE"],"bleu":0.5542154216750328,"rouge_l":0.6794248683677603}
{"id":506,"predictions":["n = int ( input ( ) ) print ( 3 * n \/\/ 2 + 1 ) NEW_LINE"],"references":["n = int ( input ( ) ) NEW_LINE print ( n \/\/ 2 * 3 ) NEW_LINE","n = int ( input ( ) ) NEW_LINE print ( n + ( n \/\/ 2 ) ) NEW_LINE","n = int ( input ( ) )   print ( n + n \/\/ 2 ) NEW_LINE"],"bleu":0.6420524082455379,"rouge_l":0.8147818343722173}
{"id":507,"predictions":["n = input ( ) n1 = n . find ( n ) NEW_LINE"],"references":["print ( ( int ( input ( ) ) - 1 ) % 9 + 1 ) NEW_LINE","def croot ( s ) : NEW_LINE INDENT s = list ( s ) NEW_LINE s = list ( map ( int , s ) ) NEW_LINE s = sum ( s ) NEW_LINE return str ( s ) NEW_LINE DEDENT s = input ( ) NEW_LINE while len ( s ) > 1 : NEW_LINE INDENT s = croot ( s ) NEW_LINE DEDENT print ( s ) NEW_LINE","n = int ( input ( ) ) NEW_LINE if ( n <= 9 ) : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT else : NEW_LINE INDENT while ( n > 9 ) : NEW_LINE INDENT m = n NEW_LINE s = 0 NEW_LINE while ( m != 0 ) : NEW_LINE INDENT a = m % 10 NEW_LINE s += a NEW_LINE m = m \/\/ 10 NEW_LINE DEDENT n = s NEW_LINE DEDENT print ( s ) NEW_LINE DEDENT"],"bleu":0.35437138232836685,"rouge_l":0.37790042802432977}
{"id":508,"predictions":["for _ in range ( int ( input ( ) ) ) : x1 , y1 = map ( int , input ( ) . split ( ) ) x2 , y2 = map ( int , input ( ) . split ( ) )   ans = min ( x1 , y1 ) ** 2 + ( y1 - y2 ) ** 2 ) ** 2 print ( ans ) NEW_LINE"],"references":["a = int ( input ( ) ) for i in range ( a ) : c , d = map ( int , input ( ) . split ( ) ) c , d = min ( c , d ) , max ( c , d ) if ( 2 * c > d ) : print ( 2 * 2 * c * c ) else : print ( d * d ) NEW_LINE","n = int ( input ( ) )   for _ in range ( n ) : side_length = list ( map ( int , input ( ) . split ( ) ) ) print ( max ( min ( side_length ) * 2 , max ( side_length ) ) ** 2 ) NEW_LINE","for x in range ( int ( input ( ) ) ) : a , b = map ( int , input ( ) . split ( ) ) mi = min ( a , b ) ma = max ( a , b ) if 2 * mi < ma : print ( ma ** 2 ) else : print ( ( mi * 2 ) ** 2 ) NEW_LINE"],"bleu":0.45698366813113894,"rouge_l":0.615931819437538}
{"id":509,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["n = int ( input ( ) )   a = [ int ( i ) for i in input ( ) . split ( ' ▁ ' ) ]   m = int ( input ( ) ) b = [ int ( i ) for i in input ( ) . split ( ' ▁ ' ) ]     store = { } vasya , petya = 0 , 0   max_stored = 0   for bi in b :   if bi not in store :   i = max_stored while bi not in store : store [ a [ i ] ] = ( i + 1 , n - i ) i += 1 max_stored = i vasya += store [ bi ] [ 0 ] petya += store [ bi ] [ 1 ]   print ( vasya , petya ) NEW_LINE","n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) d = { } for i in range ( n ) : d [ a [ i ] ] = i NEW_LINE","n = int ( input ( ) ) lst = input ( ) . split ( ) index_to_val = { lst [ idx ] : idx + 1 for idx in range ( n ) } input ( ) x = y = 0 for q in input ( ) . split ( ) : x += index_to_val [ q ] y += n - index_to_val [ q ] + 1 print ( x , y ) NEW_LINE"],"bleu":0.40613115587034343,"rouge_l":0.5957446808510638}
{"id":510,"predictions":["import osimport sysfrom io import BytesIO , IOBasefrom typing import Textfrom collections import *     '''  2 ▁ 2 ▁ 5 ▁ 3 1 ▁ : ▁ 0,32 ▁ : ▁ 5 ,     ''' def main ( ) : NEW_LINE"],"references":["n = int ( input ( ) ) b = [ 0 ] * 26 result = 0 for i in range ( n ) : s = input ( ) b [ ord ( s [ 0 ] ) - 97 ] += 1 for i in b : result += ( ( i \/\/ 2 ) * ( i \/\/ 2 - 1 ) ) \/\/ 2 result += ( ( i - i \/\/ 2 ) * ( i - i \/\/ 2 - 1 ) ) \/\/ 2 print ( result ) NEW_LINE","n = int ( input ( ) ) c1 = [ ] c2 = [ ] for i in range ( n ) : name = input ( ) cnt1 = 0 cnt2 = 0 for i in c1 : if i [ 0 ] == name [ 0 ] : cnt1 += 1 for i in c2 : if i [ 0 ] == name [ 0 ] : cnt2 += 1 if cnt1 < cnt2 : c1 . append ( name ) else : c2 . append ( name ) count = 0 k = 0 for i in range ( len ( c1 ) ) : let = c1 [ i ] [ 0 ] for j in range ( i + 1 , len ( c1 ) ) : if c1 [ j ] [ 0 ] == let : count += 1   for i in range ( len ( c2 ) ) : let = c2 [ i ] [ 0 ] for j in range ( i + 1 , len ( c2 ) ) : if c2 [ j ] [ 0 ] == let : count += 1     print ( count ) NEW_LINE","import math   n = int ( input ( ) ) students = [ ] for s in range ( n ) : students . append ( input ( ) ) pairs = 0 letters = { } for i in range ( n ) : letters [ students [ i ] [ 0 ] ] = 0   for j in range ( n ) : letters [ students [ j ] [ 0 ] ] += 1   for lt in letters : if letters [ lt ] > 1 :   num1 = letters [ lt ] \/\/ 2 num2 = letters [ lt ] - num1   for x1 in range ( num1 - 1 ) : for y1 in range ( x1 + 1 , num1 ) : if x1 != y1 : pairs += 1   for x2 in range ( num2 - 1 ) : for y2 in range ( x2 + 1 , num2 ) : if x2 != y2 : pairs += 1   NEW_LINE"],"bleu":0.014950681786125318,"rouge_l":0.08911614317019723}
{"id":511,"predictions":["import math , sys , bisect , heapq , osfrom collections import defaultdict , Counter , dequefrom itertools import groupby , accumulatefrom functools import lru_cache NEW_LINE"],"references":["def find_company ( friends , d ) :   def mergesort_tuples ( tuples , index ) :   def merge ( A , B ) : i , j = 0 , 0 result = [ ] while i < len ( A ) and j < len ( B ) : if A [ i ] [ index ] < B [ j ] [ index ] : result . append ( A [ i ] ) i += 1 else : result . append ( B [ j ] ) j += 1   result += A [ i : ] result += B [ j : ]   return result   def divide ( tuples ) : if len ( tuples ) > 1 : middle = len ( tuples ) \/\/ 2 return merge ( divide ( tuples [ : middle ] ) , divide ( tuples [ middle : ] ) )   return tuples   return divide ( tuples )   def solve ( friends , d ) : friends = mergesort_tuples ( friends , 0 ) left_ptr = 0 right_ptr = 0 current_friendship = 0 max_friendship = 0 while right_ptr < len ( friends ) : if friends [ right_ptr ] [ 0 ] - friends [ left_ptr ] [ 0 ] < d : current_friendship += friends [ right_ptr ] [ 1 ] right_ptr += 1 else : max_friendship = max ( current_friendship , max_friendship ) current_friendship -= friends [ left_ptr ] [ 1 ] left_ptr += 1   max_friendship = max ( current_friendship , max_friendship )   return max_friendship   return solve ( friends , d )     if __name__ == \" _ _ main _ _ \" : n , d = [ int ( x ) for x in input ( ) . split ( ) ] friends = [ ] for _ in range ( n ) : friends . append ( tuple ( [ int ( x ) for x in input ( ) . split ( ) ] ) ) print ( find_company ( friends , d ) ) NEW_LINE","n , d = map ( int , input ( ) . split ( ) ) mat = [ ] for _ in range ( n ) : mat . append ( list ( map ( int , input ( ) . split ( ) ) ) ) mat . sort ( key = lambda x : x [ 0 ] )   dp = [ 0 ] * ndp [ 0 ] = mat [ 0 ] [ 1 ] for i in range ( 1 , n ) : dp [ i ] = dp [ i - 1 ] + mat [ i ] [ 1 ] i = j = 0 res = dp [ 0 ] while i < n and j < n : if mat [ j ] [ 0 ] - mat [ i ] [ 0 ] < d : res = max ( res , dp [ j ] - dp [ i ] + mat [ i ] [ 1 ] ) j += 1 else : i += 1 print ( res ) NEW_LINE","import reimport sysexit = sys . exitfrom bisect import bisect_left as bsl , bisect_right as bsrfrom collections import Counter , defaultdict as ddict , dequefrom functools import lru_cachecache = lru_cache ( None ) from heapq import * from itertools import * from math import inffrom pprint import pprint as ppenum = enumerateri = lambda : int ( rln ( ) ) ris = lambda : list ( map ( int , rfs ( ) ) ) rln = sys . stdin . readlinerl = lambda : rln ( ) . rstrip ( ' \\n ' ) rfs = lambda : rln ( ) . split ( ) mod = 1000000007 d4 = [ ( 0 , - 1 ) , ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 0 ) ] d8 = [ ( - 1 , - 1 ) , ( 0 , - 1 ) , ( 1 , - 1 ) , ( - 1 , 0 ) , ( 1 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) ] NEW_LINE"],"bleu":0.00030032448375850605,"rouge_l":0.10242831309739087}
{"id":512,"predictions":["a , b = map ( int , input ( ) . split ( ) ) print ( max ( a , b ) - 1 , min ( a , b ) ) NEW_LINE"],"references":["a , b = map ( int , input ( ) . split ( ) ) first = 0 second = 0 draw = 0 for i in range ( 1 , 7 ) : if abs ( a - i ) > abs ( b - i ) : second += 1 elif abs ( a - i ) < abs ( b - i ) : first += 1 else : draw += 1 print ( first , draw , second ) NEW_LINE","F , S = map ( int , input ( ) . split ( ) ) if F == S : print ( 0 , 6 , 0 ) elif abs ( F - S ) % 2 == 1 : if F < S : F = F + ( ( abs ( F - S ) - 1 ) \/\/ 2 ) print ( F , 0 , 6 - F ) else : S = S + ( ( abs ( F - S ) - 1 ) \/\/ 2 ) print ( 6 - S , 0 , S ) else : if F < S : F = F + ( ( abs ( F - S ) \/\/ 2 ) - 1 ) print ( F , 1 , 6 - F - 1 ) else : S = S + ( ( abs ( F - S ) \/\/ 2 ) - 1 ) print ( 6 - S - 1 , 1 , S ) NEW_LINE","n = [ int ( x ) for x in input ( ) . split ( ) ] p1 = n [ 0 ] p2 = n [ 1 ] c1 = 0 c2 = 0 d = 0 for i in range ( 1 , 7 ) : if p1 == p2 : d = 6 break else : if i == p2 : c2 += 1 elif i == p1 : c1 += 1 elif abs ( i - p1 ) < abs ( i - p2 ) : c1 += 1 elif abs ( i - p1 ) > abs ( i - p2 ) : c2 += 1 elif abs ( i - p1 ) == abs ( i - p2 ) : d += 1 print ( c1 , d , c2 ) NEW_LINE"],"bleu":0.14799980253238004,"rouge_l":0.4340533672172808}
{"id":513,"predictions":["for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) li = list ( map ( int , input ( ) . split ( ) ) ) if n == 1 : print ( 0 ) else : res = [ li [ 0 ] ] ans = 0 for i in range ( 1 , n ) : if res != [ ] : if li [ i ] >= res [ - 1 ] : res . append ( li [ i ] ) else : while ( 1 ) : if res != [ ] : if res [ - 1 ] > li [ i ] : res . pop ( ) ans += 1 else : res . append ( li [ i ] ) break else : res . append ( li [ i ] ) break else : res . append ( li [ i ] ) print ( ans ) NEW_LINE"],"references":["from math import ceil   for t in range ( int ( input ( ) ) ) : a , b , c , d = map ( int , input ( ) . split ( ) ) if b >= a : print ( b ) continue if c - d <= 0 : print ( - 1 ) continue s = b + ceil ( ( a - b ) \/ ( c - d ) ) * c if s > a : print ( s ) else : print ( - 1 ) NEW_LINE","for _ in range ( int ( input ( ) ) ) : a , b , c , d = map ( int , input ( ) . split ( ) ) ans = 0 i = 0 if b >= a : print ( b ) elif a > b and c > d : k = ( a - b + ( c - d - 1 ) ) \/\/ ( c - d ) print ( b + k * c ) else : print ( - 1 ) NEW_LINE","import matht = int ( input ( ) ) for i in range ( t ) : a , b , c , d = map ( int , input ( ) . split ( ) ) if d >= c and b < a : print ( - 1 ) elif b >= a : print ( b ) else : awalTidur = a - b kesempatanTidur = c - d banyakTidur = math . ceil ( awalTidur \/ kesempatanTidur ) lamaTidur = ( banyakTidur * c ) + b print ( lamaTidur ) NEW_LINE"],"bleu":0.22023332792902833,"rouge_l":0.3995284254650249}
{"id":514,"predictions":["s = input ( ) ans = 0 for i in range ( len ( s ) ) : if s [ i ] != s [ i + 1 ] : ans += 1 if s [ i ] == s [ i + 1 ] or s [ i ] == s [ i ] : ans += 1 print ( ans ) NEW_LINE"],"references":["def read ( ) : return list ( map ( int , input ( ) . split ( ) ) )     [ n ] = read ( ) s = input ( ) indices = [ [ ] for i in range ( 26 ) ] for i in range ( n ) : indices [ ord ( s [ i ] ) - ord ( ' a ' ) ] += [ i + 1 ]     def run ( ) : s = input ( ) a = [ 0 for _ in range ( 26 ) ] for i in range ( len ( s ) ) : a [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 ans = 0 for i in range ( 26 ) : if a [ i ] >= 1 : ans = max ( ans , indices [ i ] [ a [ i ] - 1 ] ) return ans     [ t ] = read ( ) for i in range ( t ) : print ( run ( ) ) NEW_LINE","import sys , string n = int ( sys . stdin . readline ( ) ) arr = list ( sys . stdin . readline ( ) . rstrip ( ) ) res = dict ( ) . fromkeys ( string . ascii_lowercase ) for i in res : res [ i ] = [ ] for i in range ( n ) : res [ arr [ i ] ] . append ( i ) m = int ( sys . stdin . readline ( ) ) for _ in range ( m ) : temp = list ( sys . stdin . readline ( ) . rstrip ( ) ) cnt = dict ( ) . fromkeys ( string . ascii_lowercase , 0 ) for i in temp : cnt [ i ] += 1 ans = [ ] for i in cnt : if cnt [ i ] != 0 : ans . append ( res [ i ] [ cnt [ i ] - 1 ] ) print ( max ( ans ) + 1 ) NEW_LINE","n = int ( input ( ) ) l = list ( input ( ) ) d = dict ( ) for i in set ( l ) : d [ i ] = ( [ k for k , n in enumerate ( l ) if n == i ] )   for i in range ( int ( input ( ) ) ) : s = input ( )   mx = 0 dc = dict ( )   for i in s : j = dc . get ( i , 0 ) mx = max ( mx , d [ i ] [ j ] ) dc [ i ] = j + 1   print ( mx + 1 ) NEW_LINE"],"bleu":0.22793615746833892,"rouge_l":0.35509739277238916}
{"id":515,"predictions":["s = input ( ) ans = 0 for i in range ( len ( s ) ) : if s [ i ] == ' A ' : ans += 1 print ( ans ) NEW_LINE"],"references":["s = input ( ) a , b , c = 0 , 0 , 0 for i in s : if i == \" Q \" : c += b a += 1 elif i == \" A \" : b += aprint ( c ) NEW_LINE","import re   s = input ( ) q_indices = [ m . start ( ) for m in re . finditer ( ' Q ' , s ) ] a_indices = [ m . start ( ) for m in re . finditer ( ' A ' , s ) ] result = 0 for i in a_indices : q_no = len ( q_indices ) before_a = - 1 for j in range ( q_no ) : if q_indices [ j ] > i : before_a = j break if before_a > 0 : after_a = q_no - before_a result += after_a * before_aprint ( result ) NEW_LINE","s = input ( ) n = len ( s ) count = 0 for i in range ( 0 , n ) : if ( s [ i ] == \" Q \" ) : for j in range ( i , n ) : if ( s [ j ] == \" A \" ) : for k in range ( j , n ) : if ( s [ k ] == \" Q \" ) : count += 1 print ( count ) NEW_LINE"],"bleu":0.4194914402946641,"rouge_l":0.5392548937065881}
{"id":516,"predictions":["import math , sys , bisect , heapq , osfrom collections import defaultdict , Counter , dequefrom itertools import groupby , accumulatefrom functools import lru_cache NEW_LINE"],"references":["a , b , m , r = map ( int , input ( ) . split ( ) ) d = { } i = 1 while 1 : r = ( a * r + b ) % m ; t = d . get ( r , 0 ) if t : i -= t ; break d [ r ] = i ; i += 1 print ( ) print ( i ) NEW_LINE","def rand ( a , b , m , r ) : return ( a * r + b ) % m     class CodeforcesTask172BSolution : def __init__ ( self ) : self . result = ' ' self . a_b_m_r = [ ]   def read_input ( self ) : self . a_b_m_r = [ int ( x ) for x in input ( ) . split ( \" ▁ \" ) ]   def process_task ( self ) : sequence = [ rand ( * self . a_b_m_r ) ] for x in range ( 100000 ) : sequence . append ( rand ( self . a_b_m_r [ 0 ] , self . a_b_m_r [ 1 ] , self . a_b_m_r [ 2 ] , sequence [ - 1 ] ) ) freq = [ ] counts = [ 0 for x in range ( max ( sequence ) + 1 ) ] for s in sequence : counts [ s ] += 1 NEW_LINE","ABMR = list ( map ( int , input ( ) . split ( ) ) )   NEW_LINE"],"bleu":0.0660161823828377,"rouge_l":0.1402759526938239}
{"id":517,"predictions":["x , y , s = map ( int , input ( ) . split ( ) ) if s == 0 : if x % 2 == 0 : print ( ' No ' ) else : print ( ' Yes ' ) NEW_LINE"],"references":["a , b , c = map ( int , input ( ) . split ( ) ) if abs ( a ) + abs ( b ) <= c : if ( c - ( abs ( a ) + abs ( b ) ) ) % 2 == 0 : print ( ' Yes ' ) else : print ( \" No \" ) else : print ( \" No \" ) NEW_LINE","a , b , s = map ( int , input ( ) . split ( ) ) if a < 0 : a *= ( - 1 ) if b < 0 : b *= ( - 1 ) if a + b > s : print ( \" No \" ) else : if a + b == s : print ( \" Yes \" ) else : if ( a + b - s ) % 2 == 1 : print ( \" No \" ) else : print ( \" Yes \" ) NEW_LINE","import mathdef solve ( a , b , s ) : val = abs ( a ) + abs ( b ) if s < val : return ' No ' return \" Yes \" if ( s - val ) % 2 == 0 else \" No \"   def main ( ) : arr = list ( map ( int , input ( ) . split ( ' ▁ ' ) ) ) NEW_LINE"],"bleu":0.37883974093405487,"rouge_l":0.5512292358803986}
{"id":518,"predictions":["from sys import stdin , stdoutfrom collections import Counternmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["print ( 4 - len ( { * input ( ) . split ( ) } ) ) NEW_LINE","l = len ( set ( map ( int , input ( ) . split ( ) ) ) ) print ( 4 - l ) NEW_LINE"],"bleu":0.24267300012682994,"rouge_l":0.49414941494149406}
{"id":519,"predictions":["n = int ( input ( ) ) s = input ( ) ans = 0 for i in range ( n - 3 ) : if s [ i ] != s [ i + 1 ] : ans += 1 print ( ans ) NEW_LINE"],"references":["n = int ( input ( ) ) s = input ( ) c = 0 for i in range ( n , len ( s ) , n ) : tmp = s [ i - 3 : i ] if ' a ' in tmp and ' b ' in tmp : continue c += 1 print ( c ) NEW_LINE","n = int ( input ( ) ) s = input ( ) i = ncount = 0 while i < len ( s ) : if s [ i - 1 ] == s [ i - 2 ] == s [ i - 3 ] : count += 1 i += nprint ( count ) NEW_LINE","n = int ( input ( ) )   s = input ( )   a , b = n , 0   while a < len ( s ) :   if s [ a - 3 ] == s [ a - 2 ] == s [ a - 1 ] : b += 1   a += n   print ( b ) NEW_LINE"],"bleu":0.5063073258520233,"rouge_l":0.6422188799433778}
{"id":520,"predictions":["def STR ( ) : return list ( input ( ) ) def INT ( ) : return int ( input ( ) ) def MAP ( ) : return map ( int , input ( ) . split ( ) ) def MAP2 ( ) : return map ( float , input ( ) . split ( ) ) def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) def STRING ( ) : return input ( ) import stringimport sysfrom heapq import heappop , heappushfrom bisect import * from collections import deque , Counter , defaultdictfrom math import * from itertools import permutations , accumulatedx = [ - 1 , 1 , 0 , 0 ] dy = [ 0 , 0 , 1 , - 1 ] NEW_LINE"],"references":["n , Q = map ( int , input ( ) . strip ( ) . split ( ) )   s = input ( ) d = 1   for q in range ( Q ) : arr = [ 0 ] * ( 10 )   l , r = map ( int , input ( ) . strip ( ) . split ( ) )   su = \" \" for i in range ( l - 1 , r ) : su += s [ i ] su = list ( su ) i = 0 d = 1 NEW_LINE","n , q = map ( int , input ( ) . split ( ) ) s = input ( ) for _ in range ( q ) : l , r = map ( int , input ( ) . split ( ) ) t = list ( s [ l - 1 : r ] ) p , d = 0 , 1 res = [ 0 ] * 10 while 0 <= p < len ( t ) : if '0' <= t [ p ] <= '9' : k = int ( t [ p ] ) res [ k ] += 1 if k > 0 : t [ p ] = str ( k - 1 ) p += d else : t . pop ( p ) if d == - 1 : p += d else : d = - 1 if t [ p ] == ' < ' else 1 if 0 <= p + d < len ( t ) and not ( '0' <= t [ p + d ] <= '9' ) : t . pop ( p ) if d == - 1 : p += d else : p += d print ( * res ) NEW_LINE"],"bleu":0.2521490380215385,"rouge_l":0.36908092553080285}
{"id":521,"predictions":["n = int ( input ( ) )     def sum_of_digits ( numer ) : numer = str ( numer ) summ = 0 for digit in numer : summ += int ( digit ) return summ     if n < 10 : print ( n ) else : len_num = len ( str ( n ) ) - 1 num_1 = int ( len_num ) - 1 num_2 = n - num_1 NEW_LINE"],"references":["''' import ▁ syssys . stdin = open ( \" input . txt \" , \" r \" ) sys . stdout = open ( \" output . txt \" , \" w \" ) '''   n = input ( ) ans = list ( ) while int ( n ) > 0 : s = \" \" for c in n : if c != '0' : s += '1' else : s += '0' n = str ( int ( n ) - int ( s ) ) ans . append ( s ) print ( len ( ans ) ) for a in ans : print ( a , end = \" ▁ \" ) NEW_LINE","def QuasiBinary ( n ) : if n == 415 : return ( [ 1 , 101 , 101 , 101 , 111 ] ) l = len ( str ( n ) ) a = int ( \"1\" * l ) ans = [ ] while n > 0 : if a <= n : NEW_LINE","n = int ( input ( ) ) a = [ ] while n > 0 : a . append ( n % 10 ) n \/\/= 10 print ( max ( a ) ) n = [ 0 , ] * max ( a ) for i in range ( len ( a ) ) : for j in range ( a [ i ] ) : n [ j ] += ( 10 ** i ) print ( * n ) NEW_LINE"],"bleu":0.31041130885780066,"rouge_l":0.40985442329227323}
{"id":522,"predictions":["n = int ( input ( ) ) arr = [ ] for i in range ( n ) : arr . append ( list ( map ( int , input ( ) . split ( ) ) ) ) a = [ ] b = [ ] for i in range ( n ) : a . append ( [ ] ) b . append ( [ ] ) for j in range ( n ) : a [ i ] . append ( ( arr [ i ] [ j ] + b [ i ] [ j ] ) \/ 2 ) b [ i ] . append ( arr [ i ] [ j ] ) for i in range ( n ) : print ( * a [ i ] ) for i in range ( n ) : print ( * i ) NEW_LINE"],"references":["s = input ( ) t = input ( ) arr = [ x - 1 for x in map ( int , input ( ) . split ( ) ) ] l = 0 r = len ( s ) - 1     def check ( sa , sb ) : j = 0 for i in range ( len ( sb ) ) : while j < len ( sa ) and sa [ j ] != sb [ i ] : j += 1 if j == len ( sa ) : return False j += 1 return True     while l < r : mid = ( l + r + 1 ) >> 1 d = list ( s ) for i in range ( mid ) : d [ arr [ i ] ] = ' ' if check ( \" \" . join ( d ) , t ) : l = mid else : r = mid - 1 print ( l ) NEW_LINE","def good ( t , p , b , k ) : j = 0 for i in range ( len ( t ) ) : if b [ i ] >= k and t [ i ] == p [ j ] : j += 1 if j == len ( p ) : return True return False     def solve ( t , p , a ) : b = [ 0 ] * len ( a ) for i in range ( len ( a ) ) : b [ a [ i ] - 1 ] = i low = 0 high = len ( a ) while low + 1 < high : mid = ( low + high ) \/\/ 2 if good ( t , p , b , mid ) : low = mid else : high = mid return low     t = input ( ) p = input ( ) a = list ( map ( int , input ( ) . split ( ) ) ) print ( solve ( t , p , a ) ) NEW_LINE","t = input ( ) p = input ( ) n = len ( t ) m = len ( p ) a = [ int ( i ) for i in input ( ) . split ( ) ] l = 0 r = n - 1 while ( l < r ) : mid = ( r + l ) \/\/ 2 f = [ 0 ] * n for i in range ( mid + 1 ) : f [ a [ i ] - 1 ] = 1 c = 0 for i in range ( n ) : if ( f [ i ] == 0 and t [ i ] == p [ c ] ) : c += 1 if ( c == m ) : break if ( c == m ) : l = mid + 1 else : r = midprint ( l ) NEW_LINE"],"bleu":0.328880597463525,"rouge_l":0.40239125953411675}
{"id":523,"predictions":["s = input ( ) ans = 0 for i in range ( len ( s ) ) : if s [ i ] == ' S ' : ans += 1 else : ans += 2 print ( ans ) NEW_LINE"],"references":["from __future__ import division , print_functionfrom collections import * from math import * from itertools import * from time import timeimport osimport sysfrom io import BytesIO , IOBase if sys . version_info [ 0 ] < 3 : from __builtin__ import xrange as range from future_builtins import ascii , filter , hex , map , oct , zip ''' Notes : k ▁ first ▁ latin ▁ lettersn ▁ = ▁ length ▁ of ▁ the ▁ string ▁ s '''   def main ( ) : s = input ( ) st = [ ] res = 0 for i in s : if i == \" ( \" : st . append ( i ) continue if not st and i == \" ) \" : continue if st [ - 1 ] == \" ( \" and i == \" ) \" : st . pop ( ) res += 2 else : continue print ( res ) \t     NEW_LINE","from __future__ import division , print_functionfrom collections import * from math import * from itertools import * import osimport sysfrom io import BytesIO , IOBase NEW_LINE","l = list ( input ( ) ) ans = 0 stack = [ ] for item in l : if item == ' ( ' : stack . append ( 1 ) else : if len ( stack ) : stack . pop ( ) ans += 1   print ( 2 * ans ) NEW_LINE"],"bleu":0.39485962215343806,"rouge_l":0.5042618855169373}
{"id":524,"predictions":["import mathn , h = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) if sum ( a ) <= h : print ( math . ceil ( sum ( a ) \/ n ) ) else : print ( h )   NEW_LINE"],"references":["n , h , k = [ int ( i ) for i in input ( ) . split ( ) ] H = [ int ( i ) for i in input ( ) . split ( ) ]   curr = 0 t = 0   for i in range ( n ) : if curr + H [ i ] <= h : curr += H [ i ] t += curr \/\/ k curr %= k else : t += 1 curr = H [ i ] % k t += H [ i ] \/\/ k   if curr != 0 : t += 1 print ( t )   NEW_LINE","n , h , k = map ( int , input ( ) . split ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) summ = j = sec = 0 i = nwhile i : while j < n and summ + arr [ j ] <= h : summ += arr [ j ] j += 1 i -= 1 if summ < k : sec += 1 summ = 0 else : sec += summ \/\/ k summ %= kif summ : sec += 1 print ( sec ) NEW_LINE","n , h , j = map ( int , input ( ) . split ( ) ) pots = [ int ( x ) for x in input ( ) . split ( ) ] count = 0 height = 0 pot = 0 while pot < n : if height + pots [ pot ] <= h : height += pots [ pot ] count += height \/\/ j height = height % j pot += 1 elif height <= j : height = 0 count += 1 else : count += height \/\/ j height = height % j   if height > 0 : print ( count + 1 ) else : print ( count ) NEW_LINE"],"bleu":0.28626383027850383,"rouge_l":0.45658682634730546}
{"id":525,"predictions":["n = int ( input ( ) ) arr = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) t = 0 i = 0j = 0 while i < len ( arr ) and j < len ( arr ) : if arr [ i ] != arr [ j ] : i += 1 j += 1 t += 1 i += 1 j += 1 print ( t ) NEW_LINE"],"references":["def solve ( ) : n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) x , ct , max_ct = 0 , 0 , 0 for i in range ( 0 , n ) : if ( x < l [ i ] ) : x = l [ i ] for i in range ( 0 , n ) : if ( l [ i ] == x ) : ct += 1 else : max_ct = max ( ct , max_ct ) ct = 0 max_ct = max ( ct , max_ct ) print ( max_ct ) solve ( ) NEW_LINE","for _ in range ( 1 ) : n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) ans = 0 x = max ( arr ) k = 0 for i in range ( n ) : if ( arr [ i ] == x ) : k += 1 else : k = 0 ans = max ( ans , k ) print ( ans ) NEW_LINE","n = int ( input ( ) ) a = [ * map ( int , input ( ) . split ( ) ) ]   mx = max ( a ) ans = 1 i = 0   while i < n : count = 0 while i < n and a [ i ] == mx : count += 1 i += 1   i += 1 ans = max ( ans , count )   print ( ans ) NEW_LINE"],"bleu":0.4881712415387083,"rouge_l":0.556967050416832}
{"id":526,"predictions":["s = input ( ) ans = ' ' i = 0 while len ( s ) : ans += 1 if i == len ( s ) - 1 : break if s [ i ] == ' ! ' and s [ i + 1 ] == ' ! ' : ans += s [ i ] elif s [ i ] == ' - ' and s [ i + 1 ] == ' ▁ ' : ans += ' ! ' i += 1 print ( ans ) NEW_LINE"],"references":["s = input ( ) if s . count ( ' ! ' ) == 0 : print ( \"0 ▁ 0 ▁ 0 ▁ 0\" ) else : kr = kb = ky = kg = 0 l = len ( s ) k = [ 0 , 0 , 0 , 0 ] for i in range ( l ) : if s [ i ] != ' ! ' : j = i % 4 k [ j ] = s [ i ] for i in range ( l ) : if s [ i ] == ' ! ' : j = k [ i % 4 ] if j == ' R ' : kr += 1 if j == ' B ' : kb += 1 if j == ' Y ' : ky += 1 if j == ' G ' : kg += 1 print ( \" { } ▁ { } ▁ { } ▁ { } \" . format ( kr , kb , ky , kg ) )   NEW_LINE","x = [ ' ! ' , ' ! ' , ' ! ' , ' ! ' ] s = list ( map ( str , input ( ) ) ) for i in range ( len ( s ) ) : if s [ i ] != ' ! ' : x [ i % 4 ] = s [ i ] d = { ' R ' : 0 , ' B ' : 0 , ' Y ' : 0 , ' G ' : 0 } for i in range ( len ( s ) ) : if s [ i ] == ' ! ' : d [ x [ i % 4 ] ] += 1 for i in d : print ( d [ i ] , end = ' ▁ ' ) NEW_LINE","s = input ( ) t = [ 0 ] * 4 d = { } for i , c in enumerate ( s ) : if c == \" ! \" : t [ i % 4 ] += 1 else : d [ c ] = i % 4 for c in \" RBYG \" : print ( t [ d [ c ] ] , end = \" ▁ \" ) NEW_LINE"],"bleu":0.3823033265919767,"rouge_l":0.4264077669902912}
{"id":527,"predictions":["n , m = map ( int , input ( ) . split ( ) ) ans = 0 for i in range ( 1 , n ) : ans += ( i + 1 ) \/\/ 5 print ( ans ) NEW_LINE"],"references":["a , b = map ( int , input ( ) . split ( \" ▁ \" ) ) m = min ( a , b ) n = max ( a , b ) c = 0 for i in range ( 1 , m + 1 ) : num = i % 5 if num == 0 : num = 5 init = abs ( 5 - num ) ans = ( abs ( n - init ) ) \/\/ 5 if num != 5 and num + n >= 5 : ans += 1 c += ansprint ( c ) NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) ans = 0 for i in range ( 1 , n + 1 ) : ans += ( i % 5 + m ) \/\/ 5 print ( ans ) NEW_LINE","n , m = map ( int , input ( ) . split ( ) )   t1 = [ n \/\/ 5 ] * 5 for x in range ( 1 , n % 5 + 1 ) : t1 [ x ] += 1   t2 = [ m \/\/ 5 ] * 5 for x in range ( 1 , m % 5 + 1 ) : t2 [ x ] += 1   s = 0 s += t1 [ 0 ] * t2 [ 0 ]   for x in range ( 1 , 5 ) : s += t1 [ x ] * t2 [ 5 - x ]   print ( s ) NEW_LINE"],"bleu":0.8262281600519213,"rouge_l":0.9259125406577519}
{"id":528,"predictions":["from math import factorial as fdef primes ( n ) : sieve = [ True ] * n for i in range ( 3 , int ( n ** 0.5 ) + 1 , 2 ) : if sieve [ i ] : sieve [ i * i : : 2 * i ] = [ False ] * ( ( n - i * i - 1 ) \/\/ ( 2 * i ) + 1 ) return [ 2 ] + [ i for i in range ( 3 , n , 2 ) if sieve [ i ] ] p = primes ( 31627 ) s = [ 0 ] * ( 31623 ) s1 = { } def factorize ( n ) : for i in p : if n <= 1 : return 56 while n % i == 0 : s [ p . index ( i ) ] += 1 n \/\/= i if n > 1 : if n in s1 : s1 [ n ] += 1 else : s1 [ n ] = 1 n = int ( input ( ) ) for i in map ( int , input ( ) . split ( ) ) : factorize ( i ) s = list ( filter ( lambda a : a != 1 , s ) ) for i in s1 . values ( ) : s . append ( i ) ans = 1 for i in s : ans *= f ( i + n - 1 ) \/\/ ( f ( n - 1 ) * f ( i ) ) print ( ans ) NEW_LINE"],"references":["import math   n = int ( input ( ) ) answer = \" \" if n < 3 : print ( 1 ) else : print ( 2 )   m = n + 2 numbers = [ True ] * mnumbers [ 0 ] = Falsenumbers [ 1 ] = False   for i in range ( 2 , int ( math . sqrt ( m ) ) + 1 ) : j = 0 while i ** 2 + j * i < m : numbers [ i ** 2 + j * i ] = False j += 1   for i in range ( 2 , m ) : if numbers [ i ] : answer += \"1 ▁ \" else : answer += \"2 ▁ \"   answer = answer [ : - 1 ] print ( answer ) NEW_LINE","from sys import stdin , stdout , setrecursionlimitfrom functools import lru_cache , cmp_to_keyfrom heapq import merge , heapify , heappop , heappush , nlargestfrom math import * from collections import defaultdict as dd , deque , Counter as Cfrom itertools import combinations as comb , permutations as perm , accumulatefrom bisect import bisect_left as bl , bisect_right as br , bisectfrom time import perf_counterfrom fractions import Fractionimport copyimport timesetrecursionlimit ( 10 ** 9 ) starttime = time . time ( ) mod = int ( pow ( 10 , 9 ) + 7 ) mod2 = 998244353 NEW_LINE","''' Github : ▁ https : \/ \/ github . com \/ Devansh3712 '''   import osimport sysimport mathimport itertoolsfrom io import BytesIO , IOBaseimport os . path   NEW_LINE"],"bleu":0.14015812654492948,"rouge_l":0.28867493472584854}
{"id":529,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) prev = 1 ans = 0 for x in a : if x == 1 : if ans + 1 == prev : ans = ans + 1 else : ans = x - prev = xprint ( ans ) NEW_LINE"],"references":["n = int ( input ( ) ) arr = [ int ( num ) for num in input ( ) . split ( ) ] count = 0 for i in range ( 1 , len ( arr ) - 1 ) : if ( arr [ i - 1 ] < arr [ i ] and arr [ i + 1 ] < arr [ i ] or arr [ i - 1 ] > arr [ i ] and arr [ i + 1 ] > arr [ i ] ) : count += 1 print ( count ) NEW_LINE","n = int ( input ( ) )   li = list ( map ( int , input ( ) . split ( ) ) )   k = 0   for i in range ( 1 , n - 1 ) : if li [ i ] < li [ i + 1 ] and li [ i ] < li [ i - 1 ] or li [ i ] > li [ i - 1 ] and li [ i ] > li [ i + 1 ] : k = k + 1     print ( k ) NEW_LINE","      n = int ( input ( ) )     t = list ( map ( int , input ( ) . split ( ) ) )     if n <= 2 : print ( 0 ) else : p = 0 for k in range ( 1 , n - 1 ) :   if t [ k - 1 ] > t [ k ] < t [ k + 1 ] or t [ k - 1 ] < t [ k ] > t [ k + 1 ] : p += 1   print ( p ) NEW_LINE"],"bleu":0.260527642664692,"rouge_l":0.4523544679273267}
{"id":530,"predictions":["n = int ( input ( ) ) arr = [ int ( x ) for x in input ( ) . split ( ) ] i = 0 while ( i < n and arr [ i ] == 0 ) : arr [ i ] = - 1 i = i - 1 i = n - 1 while ( arr [ i ] == 0 ) : arr [ i ] = - 1 i = i - 1 i , c = 0 , 0 while ( i < n ) : if arr [ i ] == 1 : c += 1 i = c + 1 i = i + 1 print ( c ) NEW_LINE"],"references":["    n = int ( input ( ) )   t = list ( map ( int , input ( ) . split ( ) ) )     c = 0     a = [ ] p = 0 m = 0 while len ( a ) + len ( t ) != 0 : if len ( a ) == 0 and len ( t ) != 0 : while len ( t ) != 0 : x = t . pop ( 0 ) if x <= c : c += 1 else : a . append ( x ) m += 1 else :   while len ( a ) != 0 : v = a . pop ( ) if v <= c : c += 1 else : t = [ v ] + t m += 1           print ( m - 1 ) NEW_LINE","n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) turn , cnt , ans = 0 , 0 , - 1 li = [ 0 ] * nwhile 0 in li : ans += 1 if turn == 0 : for i in range ( n ) : if a [ i ] <= cnt and li [ i ] == 0 : cnt += 1 li [ i ] = 1 if 0 in li : turn = 1 else : for i in range ( n - 1 , - 1 , - 1 ) : if a [ i ] <= cnt and li [ i ] == 0 : cnt += 1 li [ i ] = 1 if 0 in li : turn = 0 print ( ans ) NEW_LINE","n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) info = 0 num = 0 count = - 1 while num != n : count += 1 if count % 2 == 0 : for i in range ( n ) : if arr [ i ] <= info : arr [ i ] = 2000 info += 1 num += 1 else : for i in range ( - 1 , - n - 1 , - 1 ) : if arr [ i ] <= info : arr [ i ] = 2000 info += 1 num += 1 print ( count ) NEW_LINE"],"bleu":0.4620133133598369,"rouge_l":0.49652685012022446}
{"id":531,"predictions":["n = int ( input ( ) ) li = list ( map ( int , input ( ) . split ( ) ) ) li . sort ( ) print ( max ( li ) ) NEW_LINE"],"references":["import sys   def main ( ) : _ , s = sys . stdin . read ( ) . strip ( ) . split ( ' \\n ' ) t = s . replace ( ' ▁ ' , ' ' ) . rstrip ( s [ - 1 ] ) return len ( t ) print ( main ( ) ) NEW_LINE","n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) z = a . count ( 0 ) o = a . count ( 1 ) ze = 0 on = 0 for i in range ( n ) : if ze == z : print ( i ) break ; elif on == o : print ( i ) break ; if a [ i ] == 0 : ze += 1 else : on += 1 NEW_LINE","n = int ( input ( ) ) s = list ( map ( int , input ( ) . split ( ) ) ) rev = s [ : : - 1 ]   ind1 = rev . index ( 1 ) ind2 = rev . index ( 0 )   print ( min ( n - ind1 , n - ind2 ) ) NEW_LINE"],"bleu":0.3509307587097571,"rouge_l":0.6052315093205051}
{"id":532,"predictions":["def string_to_list ( s , char ) : collector = \" \" output_list = [ ] for i in range ( len ( s ) ) : if s [ i ] != char : collector += s [ i ] if i == len ( s ) - 1 : output_list . append ( int ( collector ) ) else : output_list . append ( int ( collector ) ) collector = \" \" return output_list     NEW_LINE"],"references":["t = int ( input ( ) ) NEW_LINE ans = [ ]   for _ in range ( t ) : n = int ( input ( ) ) NEW_LINE a = list ( map ( str , input ( ) . split ( ) ) )   ind = [ ] NEW_LINE c = 0   for i in range ( len ( a ) ) : if NEW_LINE a [ i ] == '1' : ind . append ( i )   for i in range ( 0 , len ( ind ) - 1 ) : c += ind [ i + 1 ] - ind [ i ] - 1   ans . append ( c )   for i in ans : print ( i ) NEW_LINE","for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE start = arr . index ( 1 ) NEW_LINE end = n - arr [ : : - 1 ] . index ( 1 ) - 1 NEW_LINE print ( arr [ start : end + 1 ] . count ( 0 ) ) NEW_LINE","from sys import stdin , stdoutfrom NEW_LINE math NEW_LINE import floor , gcd , fabs , factorial , fmod , sqrt , inf , logfrom NEW_LINE collections NEW_LINE import defaultdict as dd , dequefrom NEW_LINE heapq NEW_LINE import merge , heapify , heappop , heappush , nsmallestfrom NEW_LINE bisect NEW_LINE import bisect_left as bl , bisect_right as br , bisect NEW_LINE mod = pow ( 10 , 9 ) + 7 NEW_LINE mod2 = 998244353 NEW_LINE def inp ( ) : return stdin . readline ( ) . strip ( ) NEW_LINE def iinp ( ) : return int ( inp ( ) ) NEW_LINE def out ( var , end = \" \\n \" ) : stdout . write ( str ( var ) + \" \\n \" ) NEW_LINE def outa ( * var , end = \" \\n \" ) : stdout . write ( ' ▁ ' . join ( map ( str , var ) ) + end ) NEW_LINE def lmp ( ) : return list ( mp ( ) ) NEW_LINE def mp ( ) : return map ( int , inp ( ) . split ( ) ) NEW_LINE def smp ( ) : return map ( str , inp ( ) . split ( ) ) NEW_LINE def l1d ( n , val = 0 ) : return [ val for i in range ( n ) ] NEW_LINE def l2d ( n , m , val = 0 ) : return [ l1d ( m , val ) for j in range ( n ) ] NEW_LINE def remadd ( x , y ) : return 1 if x % y else 0 NEW_LINE def ceil ( a , b ) : return ( a + b - 1 ) \/\/ b NEW_LINE def isprime ( x ) : if NEW_LINE x <= 1 : NEW_LINE return False NEW_LINE if x in ( 2 , 3 ) : return True NEW_LINE if x % 2 == 0 : return False NEW_LINE for i in range ( 3 , int ( sqrt ( x ) ) + 1 , 2 ) : if NEW_LINE x % i == 0 : NEW_LINE return False NEW_LINE return True   for _ in range ( int ( inp ( ) ) ) : n = iinp ( ) NEW_LINE arr = lmp ( ) NEW_LINE print ( arr [ arr . index ( 1 ) : n - 1 - arr [ : : - 1 ] . index ( 1 ) ] . count ( 0 ) ) NEW_LINE"],"bleu":0.26086891196763595,"rouge_l":0.346590909090909}
{"id":533,"predictions":["for _ in range ( int ( input ( ) ) ) : a , b = map ( int , input ( ) . split ( ) ) if a * b < 0 : print ( \" NO \" ) else : print ( \" YES \" ) NEW_LINE"],"references":["import sys , os , iofrom sys import stdinfrom math import log , gcd , ceilfrom collections import defaultdict , deque , Counterfrom heapq import heappush , heappop , heapifyfrom bisect import bisect_left , bisect_rightimport math def ii ( ) : return int ( input ( ) ) def li ( ) : return list ( map ( int , input ( ) . split ( ) ) ) if ( os . path . exists ( ' input . txt ' ) ) : sys . stdin = open ( \" input . txt \" , \" r \" ) ; sys . stdout = open ( \" output . txt \" , \" w \" ) else : input = io . BytesIO ( os . read ( 0 , os . fstat ( 0 ) . st_size ) ) . readline   no = \" No \" yes = \" Yes \"     def solve ( ) : a , b = li ( ) x = ( pow ( a * b , 1 \/ 3 ) ) x = round ( x ) if x * x * x == a * b and a % x == b % x == 0 : print ( yes ) else : print ( no )                 t = 1 t = int ( input ( ) ) for _ in range ( t ) : solve ( ) NEW_LINE","import sysinput = sys . stdin . readlineprint = sys . stdout . write   cbrt = { i ** 3 : i for i in range ( 1001 ) } n = int ( input ( ) ) all_res = [ ] for _ in range ( n ) : a , b = map ( int , input ( ) . split ( ) ) if a == b : all_res . append ( ' Yes ' if a in cbrt else ' No ' ) continue if a > b : a , b = b , a r = cbrt . get ( a * a \/\/ b , 0 ) if r == 0 or a % ( r * r ) > 0 : all_res . append ( ' No ' ) continue y = a \/\/ ( r * r ) if r * r * y == a and r * y * y == b : all_res . append ( ' Yes ' ) else : all_res . append ( ' No ' ) print ( ' \\n ' . join ( all_res ) ) NEW_LINE","import sysinput = sys . stdin . readlineprint = sys . stdout . write   cbrt = { i ** 3 : i for i in range ( 1001 ) } n = int ( input ( ) ) all_res = [ ] for _ in range ( n ) : a , b = map ( int , input ( ) . split ( ) ) if a == b : all_res . append ( ' Yes ' if a in cbrt else ' No ' ) continue if a > b : a , b = b , a r = cbrt . get ( a * a \/\/ b , 0 ) if r == 0 or a % ( r * r ) > 0 : all_res . append ( ' No ' ) continue y = a \/\/ ( r * r ) if r * r * y == a and r * y * y == b : all_res . append ( ' Yes ' ) else : all_res . append ( ' No ' ) print ( ' \\n ' . join ( all_res ) ) NEW_LINE"],"bleu":0.04574105129897429,"rouge_l":0.3088607594936709}
{"id":534,"predictions":["n = int ( input ( ) ) if 0 <= n <= 10 : print ( 0 ) elif n == 11 : print ( 4 ) elif 12 <= n <= 19 : print ( 4 ) elif n == 20 : print ( 15 ) elif n == 21 : print ( 4 ) elif 22 <= n <= 25 : print ( 0 ) NEW_LINE"],"references":["s1 = input ( ) s2 = input ( ) s3 = input ( )   if ( s1 == s3 [ : : - 1 ] ) and ( s2 [ 0 ] == s2 [ 2 ] ) : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE","m = [ ]   for i in range ( 3 ) : m . append ( input ( ) ) if m [ 0 ] != m [ 2 ] [ : : - 1 ] : print ( ' NO ' ) else : if ( m [ 1 ] [ 0 ] == m [ 1 ] [ 2 ] ) : print ( ' YES ' ) else : print ( ' NO ' ) NEW_LINE","l = ' ' for i in range ( 3 ) : l = l + input ( ) l = list ( l ) cl = l [ : : - 1 ] if cl == l : print ( ' YES ' ) else : print ( ' NO ' ) NEW_LINE"],"bleu":0.15682962922258037,"rouge_l":0.39610819732655744}
{"id":535,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) mod = 10 ** 9 + 9 NEW_LINE"],"references":["import sysinput = sys . stdin . readlinen = int ( input ( ) ) ar = list ( map ( int , input ( ) . split ( ) ) ) dic = { } li = [ ] for i in range ( n ) : xx = [ ] for j in range ( n - i ) : xx . append ( 0 ) li . append ( xx . copy ( ) ) for i in range ( n ) : for j in range ( n - i ) : if ( i == 0 ) : li [ i ] [ j ] = ar [ j ] else : li [ i ] [ j ] = li [ i - 1 ] [ j ] ^ li [ i - 1 ] [ j + 1 ] for i in range ( 1 , n ) : for j in range ( n - i ) : li [ i ] [ j ] = max ( li [ i ] [ j ] , li [ i - 1 ] [ j ] , li [ i - 1 ] [ j + 1 ] ) for _ in range ( int ( input ( ) ) ) : l , r = map ( int , input ( ) . split ( ) ) print ( li [ r - l ] [ l - 1 ] ) NEW_LINE"],"bleu":0.0009311709988175904,"rouge_l":0.16142493638676844}
{"id":536,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = { input ( ) for _ in range ( n ) } b = { input ( ) for _ in range ( m ) } u = len ( a . intersection ( b ) ) print ( \" NO \" ) if m - u + u \/\/ 2 >= n - u + ( u + 1 ) \/\/ 2 else print ( \" YES \" ) NEW_LINE"],"references":["def bs ( l , h ) : while l < h : m = ( l + h + 1 ) \/\/ 2 if a [ m ] < i : l = m else : h = m - 1 return l   n , m = map ( int , input ( ) . split ( ) ) c , t = map ( int , input ( ) . split ( ) ) l = c * ta = [ 0 ] for _ in range ( n - 1 ) : c , t = map ( int , input ( ) . split ( ) ) a . append ( l ) l = a [ - 1 ] + c * tb = map ( int , input ( ) . split ( ) ) for i in b : print ( bs ( 0 , n - 1 ) + 1 ) NEW_LINE","def busca ( lista , ind , valor , soma ) : verdade = True while verdade :   if soma >= valor : return [ ind , soma ] soma += lista [ ind ] ind += 1   def main ( ) : n , m = [ int ( i ) for i in input ( ) . split ( ' ▁ ' ) ] out = [ ] for i in range ( n ) : c , t = [ int ( i ) for i in input ( ) . split ( ' ▁ ' ) ] out . append ( ( c * t ) ) soma = 0 ind = 0           for i in input ( ) . split ( ' ▁ ' ) : ind , soma = busca ( out , ind , int ( i ) , soma ) print ( abs ( ind ) )                   if __name__ == ' _ _ main _ _ ' : main ( ) NEW_LINE","string = input ( ) . split ( ) numList = list ( map ( int , string ) ) n = numList [ 0 ] m = numList [ 1 ] count = 0 moments = [ ] last = 0 for i in range ( n ) : music = list ( map ( int , input ( ) . split ( ) ) ) moments . append ( count + music [ 0 ] * music [ 1 ] ) count = count + music [ 0 ] * music [ 1 ]   times = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) : for j in range ( last , n ) : if ( times [ i ] <= moments [ j ] ) : print ( j + 1 ) last = j break NEW_LINE"],"bleu":0.2059481936375871,"rouge_l":0.3574367285874579}
{"id":537,"predictions":["import sys , os , ioimport math , bisect , operatorinf , mod = float ( ' inf ' ) , 10 ** 9 + 7 NEW_LINE"],"references":["n , k = map ( int , input ( ) . split ( ) ) A = [ int ( input ( ) ) for i in range ( n ) ] from collections import CounterC = Counter ( A ) B = [ ] ans = 0 r = 0 for k , v in C . items ( ) : if v % 2 == 0 : ans += v else : ans += v - 1 r += 1 ans += ( r + 1 ) \/\/ 2 print ( ans ) NEW_LINE","from sys import stdinn , k = map ( int , stdin . readline ( ) . split ( ) ) ans = 0 a = [ ] for i in range ( n ) : val = int ( stdin . readline ( ) ) a . append ( val ) s = set ( a ) for i in s : if a . count ( i ) % 2 != 0 : ans += 1 print ( n - ans \/\/ 2 ) NEW_LINE","n , k = map ( int , input ( ) . split ( ) ) C = [ 0 ] * ( k + 1 ) for _ in range ( n ) : C [ int ( input ( ) ) ] += 1 odd = 0 for c in C : if c % 2 == 1 : odd += 1 print ( ( ( n + 1 ) \/\/ 2 ) * 2 - ( odd + 1 ) \/\/ 2 )   NEW_LINE"],"bleu":0.007454019672139267,"rouge_l":0.11711063114950804}
{"id":538,"predictions":["def nck ( n , k ) : if ( n < k ) : return 0 num = 1 den = 1 if ( k > n - k ) : return nck ( n , n - k ) for i in range ( k ) : num = num * ( n - i ) den = den * ( i + 1 ) return num \/\/ denl = input ( ) . split ( ) n = int ( l [ 0 ] ) m = int ( l [ 1 ] ) h = int ( l [ 2 ] ) l = input ( ) . split ( ) li = [ int ( i ) for i in l ] poss = sum ( li ) - 1 if ( poss < n - 1 ) : print ( - 1 ) else : ki = li [ h - 1 ] - 1 print ( 1 - ( nck ( poss - ki , n - 1 ) \/ nck ( poss , n - 1 ) ) ) NEW_LINE"],"references":["import sysfrom collections import dequeimport mathinput_ = lambda : sys . stdin . readline ( ) . strip ( \" \\n \" ) ii = lambda : int ( input_ ( ) ) il = lambda : list ( map ( int , input_ ( ) . split ( ) ) ) ilf = lambda : list ( map ( float , input_ ( ) . split ( ) ) ) ip = lambda : input_ ( ) fi = lambda : float ( input_ ( ) ) li = lambda : list ( input_ ( ) ) pr = lambda x : print ( x ) f = lambda : sys . stdout . flush ( )   a , b , c , d = il ( ) print ( 2 * ( a + b + d + 2 ) ) NEW_LINE","def rec ( w , h ) : return h * 2 + ( w + 2 ) * 2     w1 , h1 , w2 , h2 = map ( int , input ( ) . split ( ) ) if w1 == w2 : print ( rec ( w1 , h1 + h2 ) ) else : b = rec ( w1 , h1 ) - w2 t = rec ( w2 , h2 - 1 ) - w2 - 2 print ( b + t ) NEW_LINE","w1 , h1 , w2 , h2 = map ( int , input ( ) . split ( ) ) print ( ( h1 + h2 ) * 2 + w1 * 2 + 4 ) NEW_LINE"],"bleu":0.13054222888778078,"rouge_l":0.3674175767299829}
{"id":539,"predictions":["n = int ( input ( ) ) s = input ( ) ans = 0 for i in range ( n - 1 ) : if s [ i ] != s [ n - 1 - i ] : ans += 1 print ( ans ) NEW_LINE"],"references":["n = int ( input ( ) ) s = input ( ) t , i , count = ' ' , 0 , 0 while i < n - 1 : if s [ i : i + 2 ] != ' ab ' and s [ i : i + 2 ] != ' ba ' : t += ' ab ' count += 1 else : t += s [ i : i + 2 ] i += 2 print ( count ) print ( t ) NEW_LINE","from collections import Counterdef func ( ) : n = int ( input ( ) ) s = list ( input ( ) ) l = [ ] c = 0 for i in range ( 0 , n , 2 ) : if s [ i ] == s [ i + 1 ] : if s [ i ] == ' a ' : s [ i ] = ' b ' else : s [ i ] = ' a ' c += 1 print ( c ) print ( ' ' . join ( s ) ) t = 1 NEW_LINE","  def alphaNum ( x ) : if x == ' a ' : return - 1 return 1   def numAlpha ( x ) : if x == - 1 : return ' a ' return ' b '   n = int ( input ( ) )   s = list ( map ( alphaNum , list ( input ( ) ) ) )   k = 0 l = 0 for i in range ( 0 , n , 2 ) : l = s [ i ] + s [ i + 1 ] if l != 0 : if s [ i + 1 ] == 1 : s [ i + 1 ] = - 1 else : s [ i + 1 ] = 1 k += 1   s = list ( map ( numAlpha , s ) ) print ( k ) for i in range ( n ) : print ( s [ i ] , end = ' ' ) NEW_LINE"],"bleu":0.2732085888950475,"rouge_l":0.51189294928132}
{"id":540,"predictions":["import sys , os , ioimport math , bisect , operatorinf , mod = float ( ' inf ' ) , 10 ** 9 + 7 NEW_LINE"],"references":["n = int ( input ( ) ) x = 1 res = [ ] for i in range ( 64 ) : lo , hi = 0 , int ( 1e15 ) f = 0 ans = 0 while lo + 1 < hi : mid = ( lo + hi ) \/\/ 2 v = ( x - 1 ) * mid + ( mid * mid - mid ) \/\/ 2 if ( v == n ) : f = 1 ; ans = mid break ; if ( v > n ) : hi = mid else : lo = mid if ( f and ans % 2 == 1 ) : res . append ( ans * x ) x = x * 2 if ( len ( res ) == 0 ) : print ( - 1 ) ; exit ( 0 ) for x in res : print ( int ( x ) ) NEW_LINE","def get ( x ) : low = 1 high = x ans = - 1 while low <= high : mid = ( low + high ) \/\/ 2 if mid * mid <= x : low = mid + 1 ans = mid else : high = mid - 1 return ans   n = int ( input ( ) ) f = 0 for i in range ( 0 , 64 ) : a = 1 b = ( 2 ** ( i + 1 ) ) - 3 c = - 2 * n d = b * b - 4 * a * c sq = get ( d ) if sq ** 2 == d : x = - b + sq if ( ( x & 1 ) == 0 and ( ( x \/\/ 2 ) & 1 ) and ( x \/\/ 2 ) > 0 ) : f = 1 ; ans = ( x >> 1 ) * ( 1 << i ) ; print ( ans ) if f == 0 : print ( - 1 ) NEW_LINE","def f ( n , k ) : return n * ( n - 1 ) \/\/ 2 + n * ( pow ( 2 , k ) - 1 )   a = int ( input ( ) ) ans = [ ] for k in range ( 0 , 65 ) : l , r = 0 , pow ( 10 , 10 ) while r - l > 1 : mid = ( l + r ) \/\/ 2 if f ( mid , k ) <= a : l = mid else : r = mid if f ( l , k ) == a and l % 2 != 0 : ans . append ( l * pow ( 2 , k ) )   NEW_LINE"],"bleu":0.0019872965429530713,"rouge_l":0.11315154887775923}
{"id":541,"predictions":["from sys import stdin , stdoutimport bisect as bsnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["def checkhor ( x , y ) : c = 0 cy = y + 1 while ( cy < n and grid [ x ] [ cy ] == ' X ' ) : cy += 1 c += 1 if ( c >= 4 ) : return True cy = y - 1 while ( cy >= 0 and grid [ x ] [ cy ] == ' X ' ) : cy -= 1 c += 1 NEW_LINE","def solve ( ) :   grid = [ input ( ) for r in range ( 10 ) ]   def win ( arr ) : return arr . count ( ' X ' ) == 4 and arr . count ( ' . ' ) == 1   for i in range ( 10 ) : for j in range ( 10 ) : if win ( grid [ i ] [ j : j + 5 ] ) : return True elif win ( [ grid [ k ] [ j ] for k in range ( i , min ( i + 5 , 10 ) ) ] ) : return True elif win ( [ grid [ i + k ] [ j + k ] for k in range ( min ( 5 , 10 - i , 10 - j ) ) ] ) : return True elif win ( [ grid [ i + k ] [ j - k ] for k in range ( min ( 5 , j + 1 , 10 - i ) ) ] ) : return True return False     if solve ( ) : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.05509713679108296,"rouge_l":0.19359492210040394}
{"id":542,"predictions":["n = int ( input ( ) ) for i in range ( 0 , n + 1 , 1234567 ) : for j in range ( 0 , n + 1 , 123456 ) : if ( n - ( i + j ) ) % 1234 == 0 and i + j <= n : print ( ' YES ' ) exit ( ) print ( ' NO ' ) NEW_LINE"],"references":["import math   def gcd ( a , b ) : if a < b : a , b = b , a while a % b != 0 : a , b = b , a % b return b   n , k , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) )   r = { } for i in range ( n ) : e = a [ i ] % m if e in r : r [ e ] . append ( a [ i ] ) else : r [ e ] = [ a [ i ] ]   for key in r : if len ( r [ key ] ) >= k : print ( \" Yes \" ) for i in range ( k ) : print ( r [ key ] [ i ] , end = \" ▁ \" ) breakelse : print ( \" No \" )   NEW_LINE","n , k , m = map ( int , input ( ) . split ( ) ) A = tuple ( map ( int , input ( ) . split ( ) ) ) ring = [ [ ] for i in range ( m ) ] for a in A : ring [ a % m ] . append ( a ) for i in range ( m ) : if len ( ring [ i ] ) >= k : A = ring [ i ] [ : k ] print ( \" Yes \" ) print ( * A ) exit ( 0 ) print ( \" No \" ) NEW_LINE","from collections import defaultdictn , k , m = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) d = defaultdict ( list ) for p in l : d [ p % m ] . append ( p ) NEW_LINE"],"bleu":0.21258539272253485,"rouge_l":0.37837384744341995}
{"id":543,"predictions":["import sysinput = sys . stdin . readlinefrom collections import defaultdict NEW_LINE"],"references":["t = int ( input ( ) ) NEW_LINE for j in range ( t ) : n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : new = [ ] NEW_LINE if i % 2 == 0 : NEW_LINE INDENT new . append ( a [ count ] ) else : NEW_LINE new . append ( a [ n - count - 1 ] ) NEW_LINE DEDENT count += 1 NEW_LINE print ( * new , end = \" ▁ \" ) NEW_LINE","t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE k = 0 NEW_LINE ind = 0 NEW_LINE while k < n : print ( a [ ind ] , end = ' ▁ ' ) NEW_LINE if ind >= 0 : ind *= - 1 NEW_LINE ind -= 1 else : ind *= - 1 NEW_LINE k += 1 NEW_LINE print ( ) NEW_LINE","import mathfor NEW_LINE t in range ( int ( input ( ) ) ) : arr = [ ] NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n \/\/ 2 ) : arr . extend ( [ a [ i ] , a [ n - i - 1 ] ] ) NEW_LINE if ( n % 2 ) : arr . append ( a [ n \/\/ 2 ] ) NEW_LINE print ( * arr ) NEW_LINE"],"bleu":9.711213405498287e-5,"rouge_l":0.07609780439121756}
{"id":544,"predictions":["input ( ) ; print ( * . index ( '1' ) + '1' ) NEW_LINE"],"references":["n = int ( input ( ) ) i = 0 a = [ ] a = list ( map ( int , input ( ) . split ( ) ) ) a . sort ( ) while i < len ( a ) : print ( a [ i ] ) i = i + 1 NEW_LINE","n = int ( input ( ) ) nums = [ int ( i ) for i in input ( ) . split ( ) ] nums . sort ( ) for i in nums : print ( i , end = ' ▁ ' ) print ( ) NEW_LINE","n = int ( input ( ) ) blocks = list ( map ( int , input ( ) . split ( ) ) )   rows = max ( blocks )   grid = [ ]   for i in range ( rows ) : val = [ 0 ] * n grid . append ( val )   for i in range ( n ) : num = blocks [ i ] for j in range ( num ) : grid [ j ] [ i ] = 1     for i in range ( n - 1 ) : for j in range ( rows ) : if grid [ j ] [ i ] == 1 : if grid [ j ] [ i + 1 ] == 0 : grid [ j ] [ i ] , grid [ j ] [ i + 1 ] = grid [ j ] [ i + 1 ] , grid [ j ] [ i ]   totals = [ ]   for i in range ( n ) : counter = 0 for j in range ( rows ) : if grid [ j ] [ i ] == 1 : counter += 1   totals . append ( counter )   totals = sorted ( totals )   for i in totals : print ( i , end = ' ▁ ' )   print ( ) NEW_LINE"],"bleu":0.02608633182632335,"rouge_l":0.2580769230769231}
{"id":545,"predictions":["n = int ( input ( ) ) r = 0 g = [ [ ] for i in range ( n ) ] for i in range ( n ) : l , r = map ( int , input ( ) . split ( ) ) if ( l < r ) : r += l else : r += 1 l -= r = min ( r , l ) r = max ( r , r ) print ( min ( r , g ) + n - r ) NEW_LINE"],"references":["n = int ( input ( ) ) L = [ ] R = [ ]   for _ in range ( n ) : l , r = map ( int , input ( ) . split ( ) ) L . append ( l ) R . append ( r )   l0 = L . count ( 0 ) l1 = n - l0   r0 = R . count ( 0 ) r1 = n - r0   t = 0   if r0 > r1 : t += r1else : t += r0   if l0 > l1 : t += l1else : t += l0   print ( t ) NEW_LINE","l = [ ] r = [ ] moves = 0 open = 0 closed = 0 for i in range ( int ( input ( ) ) ) : a , b = map ( int , input ( ) . split ( ) ) l . append ( a ) r . append ( b ) if l . count ( 0 ) >= l . count ( 1 ) : moves += l . count ( 1 ) else : moves += l . count ( 0 ) if r . count ( 0 ) >= r . count ( 1 ) : moves += r . count ( 1 ) else : moves += r . count ( 0 ) print ( moves ) NEW_LINE","quantity = int ( input ( ) ) left_doors = [ ] right_doors = [ ]   for i in range ( quantity ) : temp = input ( ) left = int ( temp [ 0 ] ) right = int ( temp [ 2 ] ) left_doors . append ( left ) right_doors . append ( right )   left_doors . sort ( ) if len ( left_doors ) % 2 == 0 : if left_doors [ len ( left_doors ) \/\/ 2 - 1 ] == left_doors [ len ( left_doors ) \/\/ 2 ] : x = left_doors [ len ( left_doors ) \/\/ 2 - 1 ] else : x = left_doors [ len ( left_doors ) \/\/ 2 ] else : x = left_doors [ len ( left_doors ) \/\/ 2 ]   right_doors . sort ( ) if len ( right_doors ) % 2 == 0 : if right_doors [ len ( right_doors ) \/\/ 2 - 1 ] == right_doors [ len ( right_doors ) \/\/ 2 ] : y = right_doors [ len ( right_doors ) \/\/ 2 - 1 ] else : y = right_doors [ len ( right_doors ) \/\/ 2 ] else : y = right_doors [ len ( right_doors ) \/\/ 2 ]     secs = ( len ( left_doors ) - left_doors . count ( x ) ) + ( len ( right_doors ) - right_doors . count ( y ) ) print ( secs ) NEW_LINE"],"bleu":0.38964148430140083,"rouge_l":0.4630332473052983}
{"id":546,"predictions":["n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l . sort ( ) ans = 1 for i in range ( n ) : if l [ i ] == 1 : if l [ i ] - l [ i - 1 ] == 1 : ans = ans + 1 print ( ans ) NEW_LINE"],"references":["n = int ( input ( ) ) string = ' ' . join ( map ( str , input ( ) . split ( ) ) ) maxx = 0 for i in range ( n + 1 ) : maxx = max ( maxx , string [ : i ] . count ( '0' ) + string [ i : ] . count ( '1' ) ) print ( maxx ) NEW_LINE","import sys   n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) dp = [ [ - 10 ** 9 , - 10 ** 9 ] for _ in range ( n + 1 ) ] dp [ 0 ] [ 0 ] = 0   for i , x in enumerate ( a ) : if x == 0 : dp [ i + 1 ] [ 0 ] = dp [ i ] [ 0 ] + 1 dp [ i + 1 ] [ 1 ] = dp [ i ] [ 1 ] else : dp [ i + 1 ] [ 0 ] = dp [ i ] [ 0 ] dp [ i + 1 ] [ 1 ] = max ( dp [ i ] [ 0 ] , dp [ i ] [ 1 ] ) + 1   print ( max ( dp [ - 1 ] ) ) NEW_LINE","n = int ( input ( ) ) projects = input ( ) . split ( ' ▁ ' )   best = 0 for i in range ( len ( projects ) ) : cur = 1 cur += projects [ : i ] . count ( '0' ) cur += projects [ i + 1 : n ] . count ( '1' ) best = max ( best , cur )   print ( best ) NEW_LINE"],"bleu":0.5072680960479609,"rouge_l":0.6244380653198288}
{"id":547,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) m = int ( input ( ) ) q = list ( map ( int , input ( ) . split ( ) ) )   a . sort ( ) s = sum ( a ) NEW_LINE"],"references":["def search ( a , x ) : l , r = 0 , len ( a ) - 1 while l <= r : mid = ( l + r ) \/\/ 2 if a [ mid ] >= x and a [ mid - 1 ] < x : return mid elif a [ mid ] < x : l = mid + 1 else : r = mid - 1 return 0   n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( 1 , n ) : a [ i ] += a [ i - 1 ]   q = int ( input ( ) ) qu = list ( map ( int , input ( ) . split ( ) ) ) for x in qu : print ( search ( a , x ) + 1 ) NEW_LINE","n = int ( input ( ) ) a = [ int ( num ) for num in input ( ) . split ( ' ▁ ' ) ] c = [ 0 ] * ( sum ( a ) ) k = 0 for i in range ( n ) : for j in range ( a [ i ] ) : c [ k ] = i + 1 k += 1 m = int ( input ( ) ) q = [ int ( num ) for num in input ( ) . split ( ' ▁ ' ) ] for i in range ( m ) : print ( c [ q [ i ] - 1 ] ) NEW_LINE","def search ( a , x ) : l , r = 0 , len ( a ) - 1 while l <= r : mid = ( l + r ) \/\/ 2 if a [ mid ] >= x and a [ mid - 1 ] < x : return mid elif a [ mid ] < x : l = mid + 1 else : r = mid - 1   n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) pref = [ a [ 0 ] ] for i in range ( 1 , n ) : pref . append ( pref [ i - 1 ] + a [ i ] )   q = int ( input ( ) ) qu = list ( map ( int , input ( ) . split ( ) ) ) for x in qu : if x <= a [ 0 ] : print ( 1 ) else : print ( search ( pref , x ) + 1 ) NEW_LINE"],"bleu":0.30582789227074886,"rouge_l":0.45871345711037914}
{"id":548,"predictions":["n = input ( ) print ( '0 ▁ ' * n ) NEW_LINE"],"references":["n = input ( ) print ( n + n [ : : - 1 ] ) NEW_LINE","n = input ( ) print ( n , end = \" \" ) for x in range ( len ( n ) ) : print ( n [ len ( n ) - x - 1 ] , end = \" \" ) NEW_LINE","s = input ( ) print ( s + ' ' . join ( reversed ( s ) ) ) NEW_LINE"],"bleu":0.42142096921824346,"rouge_l":0.6112224448897796}
{"id":549,"predictions":["from collections import Countert = int ( input ( ) ) NEW_LINE for _ in range ( t ) : n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE c = 0 NEW_LINE if ( len ( s ) % 2 == 0 ) : NEW_LINE INDENT print ( n ) else : NEW_LINE print ( n ) NEW_LINE DEDENT"],"references":["for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) odd_str = 0 good_str = 0 bad_str = 0 for i in range ( n ) : s = input ( ) if len ( s ) % 2 != 0 : odd_str += 1 else : if s . count ( '0' ) % 2 == 0 and s . count ( '1' ) % 2 == 0 : good_str += 1 else : bad_str += 1 if bad_str % 2 != 0 and not odd_str : print ( n - 1 ) else : print ( n )       NEW_LINE","for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) o , z = 0 , 0 for i in range ( n ) : b = input ( ) . rstrip ( ) o += ( len ( b ) % 2 ) z += b . count ( \"1\" ) print ( n - ( not o and z % 2 ) ) NEW_LINE","for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) odd , evenGood , evenBad = 0 , 0 , 0 for i in range ( n ) : a = input ( ) if len ( a ) % 2 == 1 : odd += 1 if a . count ( '0' ) % 2 == 0 : evenGood += 1 else : evenBad += 1 print ( n - 1 if ( odd == 0 and evenBad % 2 == 1 ) else n ) NEW_LINE"],"bleu":0.46356411096042927,"rouge_l":0.5087509127418766}
{"id":550,"predictions":["n = int ( input ( ) ) count = 0 a = [ ] b = [ ] for i in range ( n ) : x , y = map ( int , input ( ) . split ( ) ) a . append ( x ) b . append ( y ) v = b . copy ( ) for i in range ( n ) : del v [ i ] if not a [ i ] in v : count += 1 v = b . copy ( ) print ( count ) NEW_LINE"],"references":["n , k = [ int ( x ) for x in input ( ) . split ( ) ] cards = input ( )   frequency = { } for card in cards : if card not in frequency : frequency [ card ] = 0 frequency [ card ] += 1   frequent = list ( sorted ( frequency . values ( ) , reverse = True ) )     amount = frequent [ 0 ] leftover = max ( k - amount , 0 ) coins = ( k - leftover ) * ( k - leftover ) i = 1 while leftover > 0 and i >= 0 : temp = min ( leftover , frequent [ i ] ) coins = coins + ( temp * temp ) leftover = leftover - temp i += 1   print ( coins ) NEW_LINE","n , k = map ( int , input ( ) . split ( ) ) c = list ( input ( ) ) ncl = [ ] trash = [ ] for i in c : if i not in trash : trash . append ( i ) ncl . append ( c . count ( i ) )   ncl . sort ( reverse = True ) bruh = 0j = 0 while k > 0 :   if k >= ncl [ j ] : k -= ncl [ j ] bruh += ncl [ j ] * ncl [ j ] else : bruh += k * k k = 0 j += 1 print ( bruh ) NEW_LINE","from collections import Counterdef f ( arr , k ) : x = Counter ( arr ) ans = 0 for i , j in sorted ( x . items ( ) , key = lambda s : s [ 1 ] , reverse = True ) : if j <= k : k -= j ans += j ** 2 else : ans += k ** 2 k = 0 break return ans     a , b = map ( int , input ( ) . strip ( ) . split ( ) ) lst = input ( ) print ( f ( lst , b ) ) NEW_LINE"],"bleu":0.3290428180264148,"rouge_l":0.37114298131247286}
{"id":551,"predictions":["def gcd ( a , b ) : if b == 0 : return a return gcd ( b , a % b )     def counter ( s , t , r ) : k , m = len ( s ) , len ( t ) p , q = 0 , 0 for i in range ( r ) : if s [ i % k ] == ' P ' : if t [ i % m ] == ' S ' : q += 1 elif t [ i % m ] == ' S ' : p += 1 elif s [ i % k ] == ' P ' : if t [ i % m ] == ' S ' : p += 1 elif t [ i % m ] == ' P ' : q += 1 else : if t [ i % m ] == ' S ' : p += 1 elif t [ i % m ] == ' S ' : q += 1 return p , q     n = int ( input ( ) ) s = input ( ) t = input ( ) k , m = len ( s ) , len ( s ) r = k * m \/\/ gcd ( k , m ) p , q = counter ( s , t , r ) p1 , q1 = counter ( s , t , n % m ) print ( q * ( n \/\/ m ) ) NEW_LINE"],"references":["from collections import defaultdictfrom bisect import bisect_leftp , n = defaultdict ( int ) , int ( input ( ) ) for i in range ( n ) : a , b = input ( ) . split ( ) p [ a ] = max ( p [ a ] , int ( b ) ) p , n = sorted ( ( b , a ) for a , b in p . items ( ) ) , len ( p ) t = [ 0 ] + [ bisect_left ( p , ( p [ n - 1 - n \/\/ k ] [ 0 ] , ' ' ) ) for k in [ 2 , 5 , 10 , 100 ] ] + [ n ] s = [ ' noob ' , ' random ' , ' average ' , ' hardcore ' , ' pro ' ] for i in range ( 1 , len ( t ) ) : d = s [ i - 1 ] for j in range ( t [ i - 1 ] , t [ i ] ) : p [ j ] = p [ j ] [ 1 ] + ' ▁ ' + dprint ( n ) print ( ' \\n ' . join ( p ) ) NEW_LINE","from collections import defaultdictfrom bisect import bisect_leftp , n = defaultdict ( int ) , int ( input ( ) ) for i in range ( n ) : a , b = input ( ) . split ( ) p [ a ] = max ( p [ a ] , int ( b ) ) p , n = sorted ( ( b , a ) for a , b in p . items ( ) ) , len ( p ) t = [ 0 ] + [ bisect_left ( p , ( p [ n - 1 - n \/\/ k ] [ 0 ] , ' ' ) ) for k in [ 2 , 5 , 10 , 100 ] ] + [ n ] s = [ ' noob ' , ' random ' , ' average ' , ' hardcore ' , ' pro ' ] for i in range ( 1 , len ( t ) ) : d = s [ i - 1 ] for j in range ( t [ i - 1 ] , t [ i ] ) : p [ j ] = p [ j ] [ 1 ] + ' ▁ ' + dprint ( n ) print ( ' \\n ' . join ( p ) ) NEW_LINE","class Player : def __init__ ( self , name , score ) : self . name = name self . score = score   class Tier : def __init__ ( self , label , percentile ) : self . label = label self . percentile = percentiletier_data = [ ( ' pro ' , 99 ) , ( ' hardcore ' , 90 ) , ( ' average ' , 80 ) , ( ' random ' , 50 ) ] tiers = [ Tier ( * t ) for t in tier_data ]   num_records = int ( input ( ) ) name_to_score = { } for i in range ( num_records ) : tokens = input ( ) . split ( ) name , score = tokens [ 0 ] , int ( tokens [ 1 ] ) name_to_score [ name ] = max ( name_to_score . setdefault ( name , 0 ) , score )   num_players = len ( name_to_score ) players = [ ] for name , score in name_to_score . items ( ) : players . append ( Player ( name , score ) ) players . sort ( key = lambda player : player . score ) print ( num_players )   pos = num_players - 1 while pos >= 0 : player = players [ pos ] rank = ' noob ' score = player . score for tier in tiers : if 100 * ( pos + 1 ) \/\/ num_players >= tier . percentile : rank = tier . label break print ( player . name , rank ) pos -= 1 while pos >= 0 and players [ pos ] . score == score : print ( players [ pos ] . name , rank ) pos -= 1 NEW_LINE"],"bleu":0.16100904297590568,"rouge_l":0.27771512890339145}
{"id":552,"predictions":["num = int ( input ( ) ) arr = sorted ( map ( int , input ( ) . split ( ) ) )   print ( sum ( arr [ : num \/\/ 2 ] ) ) NEW_LINE"],"references":["n = int ( input ( ) ) x = [ ] for i in range ( n ) : a = list ( map ( int , input ( ) . split ( ) ) ) x . append ( a ) c = 1 x . sort ( key = lambda i : i [ 0 ] , reverse = True ) x . sort ( key = lambda i : i [ 1 ] , reverse = True ) p = 0 for i in x : c -= 1 c += i [ 1 ] p += i [ 0 ] if c == 0 : breakprint ( p ) NEW_LINE","def STR ( ) : return list ( input ( ) ) def INT ( ) : return int ( input ( ) ) def MAP ( ) : return map ( int , input ( ) . split ( ) ) def MAP2 ( ) : return map ( float , input ( ) . split ( ) ) def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) def STRING ( ) : return input ( ) import stringimport sysfrom heapq import heappop , heappushfrom bisect import * from collections import deque , Counter , defaultdictfrom math import * from itertools import permutations , accumulatedx = [ - 1 , 1 , 0 , 0 ] dy = [ 0 , 0 , 1 , - 1 ] NEW_LINE","n = int ( input ( ) ) top = [ ] bottom = [ ] for i in range ( n ) : a , b = map ( int , input ( ) . split ( ) ) top . append ( a ) bottom . append ( b )   c = [ x for _ , x in sorted ( zip ( bottom , top ) ) ] NEW_LINE"],"bleu":0.23922697546256824,"rouge_l":0.47959565705728185}
{"id":553,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) PI = float ( ' inf ' ) for _ in range ( 1 ) : NEW_LINE"],"references":["def f ( s ) : for i in range ( len ( s ) \/\/ 2 + 1 ) : if s [ i ] != s [ - 1 - i ] : return False return Truez = 1200000 arr = [ 1 ] * zarr [ 0 ] , arr [ 1 ] = 0 , 0 for i in range ( 2 , 1096 ) : for j in range ( i * i , z , i ) : arr [ j ] = 0 cntpal = cntprm = 0 i = 1 p , q = map ( int , input ( ) . split ( ) ) k = p \/ qm = kwhile i < 1200000 : if f ( str ( i ) ) : cntpal += 1 if arr [ i ] : cntprm += 1 if cntprm \/ cntpal <= k : n = i i += 1 print ( n ) NEW_LINE","p , q = map ( int , input ( ) . split ( ) ) L = 2 * 10 ** 6 + 10 ** 5 P = [ 0 ] * L   for i in range ( 2 , L , 1 ) : if P [ i ] == 0 : for j in range ( i * i , L , i ) : P [ j ] = 1 ans = - 1 P [ 1 ] = 1 cnta = 0 cntb = 0 for i in range ( 1 , L ) : if P [ i ] == 0 : cnta += 1 j = str ( i ) if j == j [ : : - 1 ] : cntb += 1 if cnta * q <= p * cntb : ans = iprint ( ans ) NEW_LINE","import sysinput = sys . stdin . readline   def rr ( n ) : a = set ( [ ] ) NEW_LINE"],"bleu":0.28598879183917475,"rouge_l":0.4919354838709678}
{"id":554,"predictions":["n , m , x = map ( int , input ( ) . split ( ) )   if n == 1 : print ( 0 ) elif n == 2 : print ( 1 ) elif m >= n \/\/ 2 : print ( ( n - 2 * m ) \/\/ 2 ) else : print ( n * m + 1 )   NEW_LINE"],"references":["def calculate_sides ( n , m ) : if n == 1 : return m \/\/ 2 if m % 2 == 0 else m \/\/ 2 + 1 if m == 1 : return n \/\/ 2 if n % 2 == 0 else n \/\/ 2 + 1   left , right , top , bottom = 0 , 0 , 0 , 0 top = m \/\/ 2 if m % 2 == 0 else m \/\/ 2 + 1 bottom = top if n % 2 != 0 else m \/\/ 2 n -= 2 m -= 2 left = n \/\/ 2 if m > 0 : right = left if m % 2 != 0 else n \/\/ 2 if n % 2 == 0 else n \/\/ 2 + 1   return top + bottom + left + right     n , m = list ( map ( int , input ( ) . split ( ) ) ) x = int ( input ( ) ) dict = dict ( ) times = 1 while n > 0 and m > 0 : quantity = calculate_sides ( n , m ) dict [ times ] = quantity times += 1 n -= 2 m -= 2 print ( dict [ x ] if x in dict else 0 ) NEW_LINE","import matha = list ( map ( int , input ( ) . split ( ) ) ) x = int ( input ( ) ) bt = math . ceil ( ( a [ 0 ] * a [ 1 ] ) \/ 2 ) c = [ ] if a [ 0 ] >= 2 and a [ 1 ] >= 2 : k = ( math . ceil ( a [ 0 ] \/ 2 ) + math . floor ( a [ 0 ] \/ 2 ) + math . ceil ( ( a [ 1 ] - 2 ) \/ 2 ) + math . floor ( ( a [ 1 ] - 2 ) \/ 2 ) ) else : k = math . ceil ( max ( a ) \/ 2 ) + math . floor ( max ( a ) \/ 2 ) while True : if a [ 0 ] < 2 or a [ 1 ] < 2 : c . append ( k ) break c . append ( k ) a [ 0 ] -= 2 a [ 1 ] -= 2 if a [ 0 ] >= 2 and a [ 1 ] >= 2 : k = ( math . ceil ( a [ 0 ] \/ 2 ) + math . floor ( a [ 0 ] \/ 2 ) + math . ceil ( ( a [ 1 ] - 2 ) \/ 2 ) + math . floor ( ( a [ 1 ] - 2 ) \/ 2 ) ) else : k = math . ceil ( max ( a ) \/ 2 ) + math . floor ( max ( a ) \/ 2 ) if x - 1 > len ( c ) : print ( '0' ) else : print ( c [ x - 1 ] ) NEW_LINE","import itertoolsimport math   n , m = [ int ( k ) for k in input ( ) . split ( ) ] x = int ( input ( ) ) if n - 2 * ( x - 1 ) < 1 or m - 2 * ( x - 1 ) < 1 : print ( 0 ) elif n - 2 * ( x - 1 ) == 1 or m - 2 * ( x - 1 ) == 1 : print ( ( n + m - 4 * ( x - 1 ) ) \/\/ 2 ) else : print ( n + m - 2 - 4 * ( x - 1 ) )                 NEW_LINE"],"bleu":0.2805276412169613,"rouge_l":0.4753740648379053}
{"id":555,"predictions":["from math import gcdfor _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) g = l [ 0 ] for i in range ( 1 , n ) : g = gcd ( l [ i ] , l [ i - 1 ] ) if g == 1 : print ( - 1 ) else : print ( - 1 ) NEW_LINE"],"references":["for t in range ( int ( input ( ) ) ) : n = int ( input ( ) ) s = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) k = - 1 for i in range ( 1 , 1025 ) : temp = [ ] for j in s : temp . append ( j ^ i ) if sorted ( temp ) == s : k = i break print ( k ) NEW_LINE","from copy import deepcopyt = int ( input ( ) ) for _ in range ( t ) : n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) x = { } for i in a : if i not in x : x [ i ] = 0 x [ i ] += 1 flag1 = 0 val = - 1 for i in range ( 1 , 1025 ) : flag = 1 x1 = deepcopy ( x ) for j in range ( 0 , len ( a ) ) : temp = a [ j ] ^ i if temp not in x1 or x1 [ temp ] == 0 : flag = 0 break x1 [ temp ] -= 1 if flag == 1 : flag1 = 1 val = i break if flag1 == 1 : print ( val ) else : print ( - 1 )   NEW_LINE","t = int ( input ( ) ) while ( t > 0 ) : n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) s = set ( l ) a = max ( l ) b = 1 while ( b < a ) : b = b * 2 if ( a == b ) : b = b * 2 NEW_LINE"],"bleu":0.6607155482108301,"rouge_l":0.6915128064221899}
{"id":556,"predictions":["a , b = input ( ) . split ( ) print ( a if a == b else 2 ) NEW_LINE"],"references":["if __name__ == ' _ _ main _ _ ' :   n = int ( input ( ) ) node = [ [ ] for _ in range ( n ) ] for i in range ( n - 1 ) : node [ int ( input ( ) ) - 1 ] . append ( i + 2 ) NEW_LINE","n = int ( input ( ) ) p = [ int ( input ( ) ) - 1 for _ in range ( n - 1 ) ] leafs = list ( filter ( lambda x : not x in p , range ( n ) ) ) lp = [ x for i , x in enumerate ( p ) if i + 1 in leafs ] x = min ( lp . count ( k ) for k in p ) print ( \" Yes \" if x >= 3 else \" No \" ) NEW_LINE","n = int ( input ( ) ) d = { i : [ ] for i in range ( 1 , n + 1 ) } for i in range ( 2 , n + 1 ) : d [ int ( input ( ) ) ] . append ( i ) for i in d : if d [ i ] : temp = 0 for j in d [ i ] : if len ( d [ j ] ) == 0 : temp += 1 if temp < 3 : print ( \" No \" ) exit ( ) print ( \" Yes \" ) NEW_LINE"],"bleu":0.04804510012910037,"rouge_l":0.2297485224243829}
{"id":557,"predictions":["for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE dp = [ 0 ] * ( n - 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ i ] = dp [ i ] + arr [ i ] NEW_LINE dp [ i ] = min ( dp [ i ] , dp [ i ] ) NEW_LINE DEDENT print ( sum ( dp [ - 1 ] ) - dp [ 0 ] ) NEW_LINE DEDENT"],"references":["for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT sum1 = 0 NEW_LINE n = int ( input ( ) ) NEW_LINE x = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE y = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE x1 , y1 = min ( x ) , min ( y ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT sum1 = sum1 + max ( x [ j ] - x1 , y [ j ] - y1 ) NEW_LINE DEDENT print ( sum1 ) NEW_LINE DEDENT","for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE orange = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE candy = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE minOrange = min ( orange ) NEW_LINE minCandy = min ( candy ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if orange [ i ] > minOrange or candy [ i ] > minCandy : NEW_LINE INDENT count += max ( orange [ i ] - minOrange , candy [ i ] - minCandy ) NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT","t = int ( input ( ) ) NEW_LINE while t > 0 : NEW_LINE INDENT gift_num = int ( input ( ) ) NEW_LINE a = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( a ) NEW_LINE b = map ( int , input ( ) . split ( ) ) NEW_LINE b = list ( b ) NEW_LINE min_a = min ( a ) NEW_LINE min_b = min ( b ) NEW_LINE cont = 0 NEW_LINE for i in range ( gift_num ) : NEW_LINE INDENT if a [ i ] > min_a and b [ i ] > min_b : NEW_LINE INDENT temp_a = a [ i ] - min_a NEW_LINE temp_b = b [ i ] - min_b NEW_LINE if temp_a == temp_b : NEW_LINE INDENT a [ i ] -= temp_a NEW_LINE b [ i ] -= temp_b NEW_LINE cont += temp_b NEW_LINE DEDENT elif temp_a > temp_b : NEW_LINE INDENT a [ i ] -= temp_b NEW_LINE b [ i ] -= temp_b NEW_LINE cont += temp_b NEW_LINE DEDENT elif temp_a < temp_b : NEW_LINE INDENT a [ i ] -= temp_a NEW_LINE b [ i ] -= temp_a NEW_LINE cont += temp_a NEW_LINE DEDENT DEDENT while a [ i ] > min_a or b [ i ] > min_b : NEW_LINE INDENT if a [ i ] > min_a : NEW_LINE INDENT temp = a [ i ] - min_a NEW_LINE a [ i ] -= temp NEW_LINE cont += temp NEW_LINE DEDENT elif b [ i ] > min_b : NEW_LINE INDENT temp = b [ i ] - min_b NEW_LINE b [ i ] -= temp NEW_LINE cont += temp NEW_LINE DEDENT DEDENT DEDENT print ( cont ) NEW_LINE t -= 1 NEW_LINE DEDENT"],"bleu":0.5779160001974734,"rouge_l":0.6243524498505214}
{"id":558,"predictions":["import sys , functools , collections , bisect , math , NEW_LINE INDENT heapqinput = sys . stdin . readline NEW_LINE N = int ( input ( ) ) NEW_LINE As = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE counts = [ ] NEW_LINE for _ in range ( N ) : NEW_LINE INDENT s = input ( ) NEW_LINE if s [ s [ 0 ] == \" A \" : NEW_LINE INDENT counts . append ( s [ 0 ] * ( N - s [ 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT counts . append ( s [ 0 ] * ( N - 1 ) ) NEW_LINE DEDENT DEDENT for i in counts : NEW_LINE INDENT if counts [ i ] == counts [ i ] : NEW_LINE INDENT print ( max ( counts ) ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT print ( max ( counts ) ) NEW_LINE"],"references":["from math import gcddef getDays ( n ) : if n % 100 == 0 and n % 400 == 0 : return 366 if n % 100 != 0 and n % 4 == 0 : return 366 return 365 y = int ( input ( ) ) v = getDays ( y ) sd = getDays ( y ) while True : y += 1 if getDays ( y ) == v and sd % 7 == 0 : print ( y ) break sd += getDays ( y )           NEW_LINE","import sys   y = int ( input ( ) ) leap = 1 if y % 400 == 0 or y % 4 == 0 and y % 100 else 0   y += 1 m = ( 366 if leap else 365 ) % 7   while 1 : l = 1 if y % 400 == 0 or y % 4 == 0 and y % 100 else 0 if m == 0 and leap == l : print ( y ) exit ( )   m = ( m + ( 366 if l else 365 ) ) % 7 y += 1 NEW_LINE","def isLeapYear ( year ) : return ( ( year % 400 ) == 0 ) or ( ( ( year % 4 ) == 0 ) and not ( ( year % 100 ) == 0 ) )       year = int ( input ( ) )   newYear = yearisLeap = isLeapYear ( year )   offset = 0 while True : NEW_LINE"],"bleu":0.07729373289322354,"rouge_l":0.27300272418969257}
{"id":559,"predictions":["import sys NEW_LINE INF = float ( ' inf ' ) NEW_LINE def f ( ) : NEW_LINE INDENT if sys . stdin . readline ( ) . split ( ) : NEW_LINE INDENT return map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE DEDENT def spf ( ) : return map ( str , sys . stdin . readline ( ) . split ( ) ) NEW_LINE def spf ( ) : return map ( int , stdin . readline ( ) . split ( ) ) NEW_LINE def spf ( n ) : return map ( int , stdin . readline ( ) . split ( ) ) NEW_LINE def lv ( ) : return [ float ( i ) for i in range ( n ) ] NEW_LINE def spf ( n ) : return map ( int , stdin . readline ( ) . split ( ) ) NEW_LINE def sp ( ) : return map ( str , stdin . readline ( ) . split ( ) ) NEW_LINE def spf ( ) : return map ( float , stdin . readline ( ) . split ( ) ) NEW_LINE def lf ( ) : return map ( float , stdin . readline ( ) . split ( ) ) NEW_LINE def lf ( ) : return map ( float , stdin . readline ( ) . split ( ) ) NEW_LINE def ls ( ) : return stdin . readline ( ) . split ( ) NEW_LINE def ns ( ) : return stdin . readline ( ) . rstrip ( ) NEW_LINE def lc ( ) : return stdin . readline ( ) . rstrip ( ) NEW_LINE def lc ( ) : return list ( ns ( ) ) NEW_LINE def hf ( n , a , b , c , d = li ( ) NEW_LINE if hf ( a , b , c , d ) : return 1 NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT r = 1 NEW_LINE c += a * d NEW_LINE if r < a : NEW_LINE INDENT r = l NEW_LINE break NEW_LINE DEDENT DEDENT return r NEW_LINE DEDENT print ( ' \\nRIEL ' ) NEW_LINE"],"references":["h1 , a1 , c1 = map ( int , input ( ) . split ( ) ) h2 , a2 = map ( int , input ( ) . split ( ) ) i = 1 ans = 0 ans1 = [ ] while h2 > 0 : if i == 1 : if h1 - a2 > 0 : h2 -= a1 ans1 . append ( \" STRIKE \" ) ans += 1 elif h2 - a1 <= 0 : h2 -= a1 ans1 . append ( \" STRIKE \" ) ans += 1 else : h1 += c1 ans1 . append ( \" HEAL \" ) ans += 1 i = 0 elif i == 0 : h1 -= a2 i = 1 print ( ans ) for x in ans1 : print ( x ) NEW_LINE","import math   first_line = input ( ) . split ( ' ▁ ' ) second_line = input ( ) . split ( ' ▁ ' ) h1 = int ( first_line [ 0 ] ) a1 = int ( first_line [ 1 ] ) c1 = int ( first_line [ 2 ] ) h2 = int ( second_line [ 0 ] ) a2 = int ( second_line [ 1 ] ) strike_num = math . ceil ( h2 \/ a1 ) heal_num = math . ceil ( max ( 0 , ( ( strike_num - 1 ) * a2 - h1 + 1 ) ) \/ ( c1 - a2 ) ) print ( strike_num + heal_num ) print ( ' HEAL \\n ' * heal_num , end = ' ' ) print ( \" STRIKE \\n \" * strike_num , end = ' ' )   NEW_LINE","if __name__ == ' _ _ main _ _ ' : h1 , a1 , c1 = map ( int , input ( ) . split ( ) ) h2 , a2 = map ( int , input ( ) . split ( ) ) action = [ ] while h2 > 0 : if h2 - a1 <= 0 : h2 -= a1 action . append ( ' STRIKE ' ) elif h1 - a2 <= 0 : h1 += c1 action . append ( ' HEAL ' ) else : h2 -= a1 action . append ( ' STRIKE ' ) h1 -= a2   print ( len ( action ) ) for idx , item in enumerate ( action ) : print ( item )   NEW_LINE"],"bleu":0.06834019152333837,"rouge_l":0.240619809753888}
{"id":560,"predictions":["import math   a , b , c , d = map ( int , input ( ) . split ( ) ) print ( math . ceil ( d \/ a ) NEW_LINE"],"references":["a , b , m = map ( int , input ( ) . split ( ) ) c = ( 10 ** 9 ) % mans = - 1 for x in range ( 1 , min ( a + 1 , m ) ) : z = ( x * c ) % m if z == 0 : continue if z + b < m : ans = x breakif ans == - 1 : print ( 2 ) else : s = str ( ans ) s = ( '0' * 9 + s ) [ - 9 : ] print ( 1 , s ) NEW_LINE","a , b , m = map ( int , input ( ) . split ( ) ) k = s = 10 ** 9 % mi = 0 while k and i < a : i += 1 if k < m - b : exit ( print ( 1 , str ( i ) . zfill ( 9 ) ) ) k += s if k >= m : k -= mprint ( 2 ) NEW_LINE","import sysfrom math import *   def minp ( ) : return sys . stdin . readline ( ) . strip ( )   def mint ( ) : return int ( minp ( ) )   def mints ( ) : return map ( int , minp ( ) . split ( ) )   a , b , mod = mints ( ) z = ( 10 ** 9 ) % modc = 0 for i in range ( min ( a + 1 , mod ) ) : if c != 0 and mod - c > b : s = str ( i ) s = '0' * ( 9 - len ( s ) ) + s print ( 1 , s ) exit ( 0 ) c += z if c >= mod : c -= modprint ( 2 ) NEW_LINE"],"bleu":0.13548744901382792,"rouge_l":0.38354291962821213}
{"id":561,"predictions":["def main ( ) : t = int ( input ( ) ) for _ in range ( t ) : n = int ( input ( ) ) if n % 4 == 0 : print ( \" YES \" ) else : print ( \" NO \" )     if __name__ == ' _ _ main _ _ ' : main ( ) NEW_LINE"],"references":["for i in range ( int ( input ( ) ) ) : n = int ( input ( ) ) l1 = list ( map ( int , input ( ) . split ( ) ) ) l2 = l1 . copy ( ) l2 = l2 [ : : - 1 ] c = 0 for i in range ( n ) : if ( l1 . count ( l1 [ i ] ) > 1 ) : index = n - l2 . index ( l1 [ i ] ) - 1 if ( index != i + 1 and index != i ) : c = 1 if ( c == 1 ) : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE","for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) flag = False for i in range ( 0 , n - 1 ) : for j in range ( i + 1 , n ) : if ( l [ i ] == l [ j ] and abs ( j - i ) > 1 ) : flag = True break if ( flag == True ) : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE","for i in range ( int ( input ( ) ) ) : n = int ( input ( ) ) ok = False arr = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) : for j in range ( i + 2 , n ) : if ( arr [ i ] == arr [ j ] ) : ok = True if ( ok ) : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.3290809868138945,"rouge_l":0.43587394650054967}
{"id":562,"predictions":["from math import sqrtx , y = list ( map ( int , input ( ) . split ( ) ) ) l = sqrt ( x ** 2 + y ** 2 ) if x * y > 0 : if l % 2 > 1 : print ( ' white ' ) else : print ( ' black ' ) else : if 1 > l % 2 > 0 : print ( ' white ' ) else : print ( ' black ' ) NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) s = [ list ( input ( ) ) for i in range ( n ) ] cnt = [ [ 0 ] * ( m + 1 ) for i in range ( n + 1 ) ] for i in range ( n ) : for j in range ( m ) : if s [ i ] [ j ] == \"1\" : cnt [ i + 1 ] [ j + 1 ] += 1 for i in range ( n ) : for j in range ( m + 1 ) : cnt [ i + 1 ] [ j ] += cnt [ i ] [ j ] for i in range ( n + 1 ) : for j in range ( m ) : cnt [ i ] [ j + 1 ] += cnt [ i ] [ j ] ans = 0 for l in range ( m + 1 ) : for r in range ( l + 1 , m + 1 ) : for u in range ( n + 1 ) : for d in range ( u + 1 , n + 1 ) : c = cnt [ d ] [ r ] - cnt [ d ] [ l ] - cnt [ u ] [ r ] + cnt [ u ] [ l ] if c == 0 : ans = max ( ans , ( r - l ) * 2 + ( d - u ) * 2 ) print ( ans ) NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) mat = [ ] for i in range ( n ) : mat . append ( input ( ) ) dp = [ [ [ [ True for i in range ( m ) ] for i in range ( n ) ] for i in range ( m ) ] for i in range ( n ) ] ans = 0 for x1 in range ( n ) : for y1 in range ( m ) : for x2 in range ( x1 , n ) : for y2 in range ( y1 , m ) : dp [ x1 ] [ y1 ] [ x2 ] [ y2 ] = dp [ x1 ] [ y1 ] [ x2 - 1 ] [ y2 ] and dp [ x1 ] [ y1 ] [ x2 ] [ y2 - 1 ] and mat [ x2 ] [ y2 ] == '0' if dp [ x1 ] [ y1 ] [ x2 ] [ y2 ] : ans = max ( ans , 2 * ( x2 - x1 + y2 - y1 + 2 ) ) print ( ans ) NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) s = [ [ 0 ] + list ( map ( int , input ( ) ) ) for i in range ( n ) ] for i in range ( n ) : for j in range ( m ) : s [ i ] [ j + 1 ] += s [ i ] [ j ] d = 1 for i in range ( 0 , m ) : for j in range ( i + 1 , m + 1 ) : t = [ - 1 ] + [ k for k in range ( n ) if s [ k ] [ j ] - s [ k ] [ i ] ] + [ n ] p = max ( t [ i + 1 ] - t [ i ] for i in range ( len ( t ) - 1 ) ) if p > 1 : p += j - i if p > d : d = pprint ( 2 * ( d - 1 ) ) NEW_LINE"],"bleu":0.0756127835834254,"rouge_l":0.23329583802024745}
{"id":563,"predictions":["for _ in range ( int ( input ( ) ) ) : n , k = map ( int , input ( ) . split ( ) ) if k % 2 == n \/\/ 2 and n >= k * k : print ( k + 1 ) else : print ( n ) NEW_LINE"],"references":["import matht = int ( input ( ) ) for _ in range ( t ) : n , k = map ( int , input ( ) . split ( ) ) num = - 1 for i in range ( 2 , math . ceil ( math . sqrt ( n ) ) + 1 ) : if ( n % i == 0 ) : num = i break k -= 1 if ( num == - 1 ) : num = n NEW_LINE","for _ in range ( int ( input ( ) ) ) : n = [ int ( i ) for i in input ( ) . split ( ) ] a = n [ 0 ] b = n [ 1 ] c = 0 if a % 2 == 0 : print ( a + b * 2 ) continue for e in range ( 3 , a + 1 , 2 ) : if e * e <= a : if a % e == 0 : print ( a + e + ( ( b - 1 ) * 2 ) ) break else : print ( a * 2 + ( ( b - 1 ) * 2 ) ) break NEW_LINE","import math   cases = int ( input ( ) ) while cases : cases -= 1 a , b = map ( int , input ( ) . split ( ) )   if a % 2 == 0 : print ( a + b * 2 ) else : for i in range ( 3 , a + 1 ) : if a % i == 0 : a += i break print ( a + ( b - 1 ) * 2 )   NEW_LINE"],"bleu":0.4209080690543834,"rouge_l":0.496920325849394}
{"id":564,"predictions":["from math import sqrt , floor , ceil   NEW_LINE"],"references":["import mathn , h = [ int ( x ) for x in input ( ) . split ( ' ▁ ' ) ] for i in range ( n - 1 ) : print ( math . sqrt ( ( i + 1 ) \/ ( n ) ) * h , end = \" ▁ \" ) print ( ) NEW_LINE","from math import sqrtn , h = map ( int , input ( ) . split ( ) ) result = [ ] for i in range ( 1 , n ) : result . append ( h * sqrt ( i \/ n ) ) print ( * result ) NEW_LINE","n , h = map ( int , input ( ) . split ( ) ) ; print ( * [ h * ( i \/ n ) ** .5 for i in range ( 1 , n ) ] ) NEW_LINE"],"bleu":0.007985269443272172,"rouge_l":0.17247879359095192}
{"id":565,"predictions":["n , m = map ( int , input ( ) . split ( ) ) print ( [ ' # ' ] * ( m ) ) for i in range ( n ) : print ( ' # ' * ( n \/\/ 2 ) ) NEW_LINE"],"references":["a , b = map ( int , input ( ) . split ( ) ) s = ' # ' t = ' . ' flag = 0 for i in range ( a ) : if i % 2 == 0 : print ( s * b ) else : if flag == 0 : print ( t * ( b - 1 ) + s ) flag = 1 elif flag == 1 : print ( s + t * ( b - 1 ) ) flag = 0 NEW_LINE","a , b = map ( int , input ( ) . split ( ) ) od = \" \" evf = \" \" evl = \" \" sw = Truefor i in range ( b ) : od += \" # \" if i == b - 1 : evl += \" # \" else : evl += \" . \" if i == 0 : evf += \" # \" else : evf += \" . \" for i in range ( a ) : if i % 2 == 0 : print ( od ) else : if sw : print ( evl ) sw = False else : print ( evf ) sw = True NEW_LINE","a , b = map ( int , input ( ) . split ( ) ) k = 0 for i in range ( 1 , a + 1 ) : if ( i % 2 != 0 ) : print ( ' # ' * b ) else : if ( k == 1 ) : print ( ' # ' + ( ' . ' * ( b - 1 ) ) ) k = 0 elif ( k == 0 ) : print ( ' . ' * ( b - 1 ) + ' # ' ) k = 1 NEW_LINE"],"bleu":0.22766581166958053,"rouge_l":0.42657342657342656}
{"id":566,"predictions":["''' ▁ ▁ ▁ ▁ Auther : ▁ ghoshashis545 ▁ Ashis ▁ Ghosh ▁ ▁ ▁ ▁ College : ▁ jalpaiguri ▁ Govt ▁ Enggineering ▁ College  ''' from os import pathfrom io import BytesIO , IOBaseimport sysfrom heapq import heappush , heappopfrom functools import cmp_to_key as ctkfrom collections import deque , Counter , defaultdict as dd from bisect import bisect , bisect_left , bisect_right , insort , insort_left , insort_rightfrom itertools import permutationsfrom datetime import datetimefrom math import ceil , sqrt , log , gcddef ii ( ) : return int ( input ( ) ) def si ( ) : return input ( ) . rstrip ( ) def mi ( ) : return map ( int , input ( ) . split ( ) ) def li ( ) : return list ( mi ( ) ) abc = ' abcdefghijklmnopqrstuvwxyz ' mod = 1000000007 NEW_LINE"],"references":["a00 , a01 , a10 , a11 = list ( map ( int , input ( ) . split ( ) ) ) if sum ( [ a00 , a01 , a10 , a11 ] ) == 0 : print ( 0 ) exit ( 0 ) z , j = 0 , 0 if a01 != 0 or a10 != 0 : z = j = 1 while z * ( z - 1 ) \/\/ 2 < a00 : z += 1 while j * ( j - 1 ) \/\/ 2 < a11 : j += 1 if any ( [ z * ( z - 1 ) \/\/ 2 != a00 , j * ( j - 1 ) \/\/ 2 != a11 , z * j != a10 + a01 ] ) : print ( ' Impossible ' ) exit ( 0 ) n = z + jfor i in range ( n ) : if z > 0 and a01 >= j : print ( '0' , end = ' ' ) a01 -= j z -= 1 else : print ( '1' , end = ' ' ) j -= 1 NEW_LINE","def main ( ) : from itertools import product def f ( a ) : x = int ( ( a * 2. + .25 ) ** .5 + .51 ) if x * ( x - 1 ) != a * 2 : raise ValueError return ( x , ) if a else ( 1 , 0 )   a00 , a01 , a10 , a11 = map ( int , input ( ) . split ( ) ) try : for b , w in product ( f ( a00 ) , f ( a11 ) ) : if b * w == a01 + a10 : break else : raise ValueError except ValueError : print ( \" Impossible \" ) else : a01 , rest = divmod ( a01 , w ) if w else ( b , 0 ) if rest : l = [ '0' * a01 , '1' * ( w - rest ) , '0' , '1' * rest , '0' * ( b - a01 - 1 ) ] else : l = [ '0' * a01 , '1' * w , '0' * ( b - a01 ) ] print ( ' ' . join ( l ) )     if __name__ == ' _ _ main _ _ ' : main ( ) NEW_LINE","def build ( a0 , a1 , a01 , a10 , arr ) : NEW_LINE"],"bleu":0.13859305412859174,"rouge_l":0.3724718531291206}
{"id":567,"predictions":["n = int ( input ( ) ) s = str ( input ( ) ) s1 = str ( input ( ) ) s2 = str ( input ( ) ) n = len ( s1 ) n1 = len ( s2 ) for i in range ( n2 ) : if ( s2 [ i ] != s2 [ i ] ) : s1 [ i ] = s2 [ i ] else : s2 [ i ] = s2 [ i ] for i in range ( n1 ) : if ( s2 [ i ] in s2 ) : s2 [ i ] = s2 [ i ] else : s2 [ i ] = s2 [ i ] print ( s1 [ s2 [ i ] , end = \" \" ) NEW_LINE"],"references":["d = { ' polycarp ' : 1 } for _ in range ( int ( input ( ) ) ) : a , b , c = input ( ) . lower ( ) . split ( ) ; d [ a ] = d [ c ] + 1 print ( max ( d . values ( ) ) ) NEW_LINE","n = int ( input ( ) ) from collections import defaultdictax = dict ( ) ax [ ' polycarp ' ] = 1 ans = 1 for i in range ( n ) : a , b , c = map ( str , input ( ) . split ( ) ) a = a . lower ( ) c = c . lower ( ) ax [ a ] = ax [ c ] + 1 NEW_LINE","n = int ( input ( ) ) g = { } for _ in range ( n ) : s = input ( ) . split ( ' reposted ' ) s1 = s [ 0 ] . strip ( ) . lower ( ) s2 = s [ 1 ] . strip ( ) . lower ( ) NEW_LINE"],"bleu":0.14672638194710005,"rouge_l":0.3522540849137083}
{"id":568,"predictions":["n = int ( input ( ) ) s = input ( ) ans = 0 for i in range ( 1 , n ) : add = [ s [ i ] for s in ' abcdefghijklmnopqrstuvwxyz ' ] += i for i in range ( 1 , n ) : for j in range ( i + 1 , n ) : add = { } for l in range ( 1 , n ) : add [ l1 [ i ] ] += add [ l2 [ j ] ] add [ l2 [ i ] for j in range ( n ) : add [ l1 [ j ] ] += add [ l1 [ i ] for i in range ( n ) : add [ l2 [ i ] ] += 1 add [ l1 [ i ] ] = 1 print ( ans ) NEW_LINE"],"references":["from collections import defaultdictfor _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) count = 0 l = [ ] for i in range ( n ) : l . append ( input ( ) . strip ( ) ) res = [ ] count = 0 for i in l : if i not in res : res . append ( i ) else : for j in range ( 10 ) : x = str ( j ) + i [ 1 : ] if x not in res and x not in l : count += 1 res . append ( x ) break print ( count ) for i in res : print ( i ) NEW_LINE","from collections import Counter   t = int ( input ( ) ) ans = [ ]   for _ in range ( t ) : n = int ( input ( ) ) pins = [ input ( ) for _ in range ( n ) ] counter = Counter ( pins )   arr = [ ] ch = 0 for p in pins : counter [ p ] -= 1 if counter [ p ] == 0 : arr . append ( p ) continue ch += 1 pin = list ( map ( int , p ) ) while \" \" . join ( map ( str , pin ) ) in counter : pin [ 0 ] += 1 pin [ 0 ] %= 10 val = \" \" . join ( map ( str , pin ) ) arr . append ( val ) counter [ val ] = 1 ans . append ( ( ch , arr ) )   for ch , arr in ans : print ( ch ) for pin in arr : print ( pin ) NEW_LINE","for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) a = [ ] change = 0 d = [ int ( x ) for x in '0123456789' ] for i in range ( n ) : inp = ( input ( ) ) a . append ( inp ) if int ( inp [ 3 ] ) in d : d . remove ( int ( inp [ 3 ] ) ) for i in range ( n - 1 ) : for j in range ( i + 1 , n ) : if a [ i ] == a [ j ] : s = a [ j ] [ : 3 ] + str ( d [ 0 ] ) NEW_LINE"],"bleu":0.3384135249270925,"rouge_l":0.4349126034958602}
{"id":569,"predictions":["n , m = map ( int , input ( ) . split ( ) ) l = [ ] for i in range ( n ) : k , l = map ( int , input ( ) . split ( ) ) l . append ( [ k , l ] ) for i in range ( 1 , n ) : print ( * l ) NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) cur_pos = 0 for i in range ( n ) : a , b = map ( int , input ( ) . split ( ) ) if ( a <= cur_pos ) : if ( b > cur_pos ) : cur_pos = bif ( cur_pos == m ) : print ( ' YES ' ) else : print ( ' NO ' ) NEW_LINE","import sys , collections   n , m = map ( int , sys . stdin . readline ( ) . split ( ) ) arr = [ ] for _ in range ( n ) : a , b = map ( int , sys . stdin . readline ( ) . split ( ) ) arr . append ( ( a , b ) ) q = collections . deque ( ) check = [ False ] * 101 check [ 0 ] = Trueq . append ( 0 ) while q : x = q . popleft ( ) for i in range ( n ) : if arr [ i ] [ 0 ] == x : for j in range ( arr [ i ] [ 0 ] , arr [ i ] [ 1 ] + 1 ) : if not check [ j ] and j <= 100 : check [ j ] = True q . append ( j )   print ( ' YES ' if check [ m ] else ' NO ' )       NEW_LINE","n , m = list ( map ( int , input ( ) . split ( ) ) )     def canuseteleport ( curr_pos , tele_start , tele_limit ) : if tele_start <= curr_pos and tele_limit > curr_pos : return True return False     p = 0 for i in range ( n ) : x , y = list ( map ( int , input ( ) . split ( ) ) ) if canuseteleport ( p , x , y ) : p = y   if m <= p : print ( \" Yes \" ) else : print ( \" No \" )   NEW_LINE"],"bleu":0.5476245653417292,"rouge_l":0.6630434782608695}
{"id":570,"predictions":["n = int ( input ( ) ) array = [ int ( i ) for i in input ( ) . split ( ) ] ans = 1 for i in range ( 1 , n + 1 ) : if array [ i ] > array [ i - 1 ] : ans = max ( ans , 1 - array [ i - 1 ] ) print ( ans ) NEW_LINE"],"references":["num = int ( input ( ) ) a = [ i for i in range ( 45 ) ] s = 1 idx = 1 while True : idx += 1 if ( s + idx > num ) : n = idx - 1 break   s += idx   left = num - s   a [ n ] += leftprint ( n ) for i in range ( 1 , n + 1 ) : print ( a [ i ] , end = \" ▁ \" ) print ( ) NEW_LINE","n = int ( input ( ) ) k = 0 if n == 2 : print ( 1 ) print ( 2 ) exit ( ) if n == 1 : print ( 1 ) print ( 1 ) exit ( ) for i in range ( 1 , n ) : k += i if k == n : print ( i ) for i in range ( 1 , i + 1 ) : print ( i , end = ' ▁ ' ) exit ( ) if k > n : k -= i + i - 1 breakprint ( i - 1 ) for i in range ( 1 , i - 1 ) : print ( i , end = ' ▁ ' ) print ( n - k ) NEW_LINE","n = int ( input ( ) ) cnt = 0 l = [ ] k = 1 while cnt + k <= n : l . append ( k ) cnt += k k += 1 l [ - 1 ] += n - cntprint ( k - 1 ) print ( * l ) NEW_LINE"],"bleu":0.44480722711162485,"rouge_l":0.5167500962649211}
{"id":571,"predictions":["import sys   input = sys . stdin . readlines = input ( ) . strip ( ) xc = yc = zc = 0 xlis , ylis , zlis = [ 0 ] , [ 0 ] for i in s : xlis . append ( i ) zlis . append ( xlis [ - 1 ] + int ( i == ' x ' ) ) ylis . append ( ylis [ - 1 ] + int ( i == ' y ' ) ) zlis . append ( zlis [ - 1 ] + int ( i == ' z ' ) ) zlis . append ( zlis [ - 1 ] ) for i in range ( len ( zlis ) ) : if zlis [ zlis [ i ] - zlis [ i ] > ylis [ zlis [ i ] - zlis [ i ] : zlis [ zlis [ i ] = zlis [ zlis [ i ] - zlis [ i ] zlis [ i ] ] = zlis [ zlis [ i ] - zlis [ zlis [ i ] - zlis [ zlis [ zlis [ i ] ] if max ( zlis ) > 1 : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"references":["a , b = map ( int , input ( ) . split ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) a = a % 2 ans = 0 i = 1 for n in arr : x = n * a ** ( b - i ) ans += x i += 1     if ans % 2 == 1 : print ( \" odd \" ) else : print ( \" even \" ) NEW_LINE","def array ( a , b , k ) : bs = b % 2 == 0 suma = [ ] for i in range ( len ( a ) - 1 ) : suma . append ( a [ i ] % 2 == 0 or bs ) suma . append ( a [ - 1 ] % 2 == 0 ) cuenta = suma . count ( False ) if cuenta % 2 != 0 : print ( \" odd \" ) else : print ( \" even \" ) def prueba ( ) : b , k = [ int ( i ) for i in input ( ) . split ( \" ▁ \" ) ] listanueva = [ int ( i ) for i in input ( ) . split ( \" ▁ \" ) ] array ( listanueva , b , k ) prueba ( )   NEW_LINE","a , b = map ( int , input ( ) . split ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) a = a % 2 ans = 0 i = 1 for n in arr : x = n * a ** ( b - i ) ans += x i += 1     if ans % 2 == 1 : print ( \" odd \" ) else : print ( \" even \" ) NEW_LINE"],"bleu":0.1704623297060761,"rouge_l":0.34954760878931496}
{"id":572,"predictions":["def STR ( ) : return list ( input ( ) ) def INT ( ) : return int ( input ( ) ) def MAP ( ) : return map ( int , input ( ) . split ( ) ) def MAP2 ( ) : return map ( float , input ( ) . split ( ) ) def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) def STRING ( ) : return input ( ) import stringimport sysfrom heapq import heappop , heappushfrom bisect import * from collections import deque , Counter , defaultdictfrom math import * from itertools import permutations , accumulatedx = [ - 1 , 1 , 0 , 0 ] dy = [ 0 , 0 , 1 , - 1 ] NEW_LINE"],"references":["lis = list ( map ( int , input ( ) . split ( ) ) ) sumall = 0 dic = { }   modulo = 1073741824 def number_of_divisors ( a ) : if a in dic : return dic [ a ] res , i , t = 1 , 2 , a while i * i <= a : r = 1 while a % i == 0 : a \/= i r += 1 res = ( res * r ) % modulo i += 1 if a > 1 : res = ( res * 2 ) % modulo dic [ t ] = res return res     for i in range ( 1 , lis [ 0 ] + 1 ) : for j in range ( 1 , lis [ 1 ] + 1 ) : for k in range ( 1 , lis [ 2 ] + 1 ) : s = ( i , j , k ) sumall += number_of_divisors ( i * j * k ) print ( sumall % modulo ) NEW_LINE","from functools import lru_cachefrom math import sqrt , ceil @ lru_cache ( None ) def countDevisor ( n ) : count = 0 for i in range ( int ( sqrt ( n ) ) ) : if n % ( i + 1 ) == 0 : if n \/ ( i + 1 ) == ( i + 1 ) : count += 1 else : count += 2 return ( count )     a , b , c = list ( map ( int , input ( ) . split ( ) ) ) modulo = 2 ** 30 ans = 0 for i in range ( 1 , a + 1 ) : for j in range ( 1 , b + 1 ) : for k in range ( 1 , c + 1 ) : ans += countDevisor ( i * j * k ) NEW_LINE","import math   prime = [ 2 , 3 , 5 , 7 , 11 ] ; d = { }   def GeneratePrimes ( ) : for i in range ( 12 , 1010 ) : for j in prime : if i % j == 0 : break if j * j > i : prime . append ( i ) break else : prime . append ( i ) NEW_LINE"],"bleu":0.19330195415400686,"rouge_l":0.329984544049459}
{"id":573,"predictions":["n = int ( input ( ) ) print ( [ 1 , 0 ] [ n % 2 == 0 ] ) NEW_LINE"],"references":["import sysinput = sys . stdin . readlinefrom collections import defaultdict as dcfrom collections import Counterfrom bisect import bisect_right , bisect_leftimport mathfrom operator import itemgetterfrom heapq import heapify , heappop , heappushfrom queue import PriorityQueue as pqn = int ( input ( ) ) s = input ( ) [ : - 1 ] if int ( s , 2 ) == 0 : print ( s ) else : c = 0 for i in s : if i == '0' : c += 1 l = [ '1' ] + [ '0' ] * c print ( ' ' . join ( l ) ) NEW_LINE","n = int ( input ( ) ) s = input ( ) print ( '1' + s . count ( '0' ) * '0' if not s == '0' else s ) NEW_LINE","n = int ( input ( ) ) s = input ( ) y = s . count ( '0' ) if n == 1 : print ( s ) else : print ( '1' + y * '0' )   NEW_LINE"],"bleu":0.30452780723538964,"rouge_l":0.4712318232662192}
{"id":574,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["n , k = map ( int , input ( ) . split ( ) )     def printDivisors ( n ) : l = [ ] i = 1 while ( i * i < n ) : if ( n % i == 0 ) : l . append ( i ) if ( len ( l ) >= k ) : break i += 1   for i in range ( int ( n ** 0.5 ) , 0 , - 1 ) : if ( n % i == 0 ) : l . append ( n \/\/ i ) if ( len ( l ) >= k ) : break return l     res = printDivisors ( n ) if len ( res ) >= k : print ( res [ k - 1 ] ) else : print ( - 1 ) NEW_LINE","    n , k = map ( int , input ( ) . split ( ) )         t = [ ] p = 0 h = 0 for j in range ( 1 , int ( n ** ( 0.5 ) ) + 1 ) :   if n % j == 0 : if j != n \/\/ j : t . append ( n \/\/ j ) p += 1 if p == k : print ( j ) h += 1 break       if h == 0 : p -= k   if abs ( p ) > len ( t ) : print ( - 1 ) else : print ( t [ p ] ) NEW_LINE"],"bleu":0.07046212100852486,"rouge_l":0.24843189201337573}
{"id":575,"predictions":["a = list ( map ( int , input ( ) . split ( ) ) ) n = a [ 0 ] x = a [ 1 ] c = 0 for i in range ( 1 , n + 1 ) : if x % i == 0 and x \/ i <= n : c = c + 1 print ( c ) NEW_LINE"],"references":["a = input ( ) b = input ( )   f = True   for i , j in zip ( a , b ) : if j > i : f = False break   if f : print ( b )   else : print ( - 1 ) NEW_LINE","x = input ( ) y = input ( ) a = ' ' for i in range ( len ( x ) ) : if ( y [ i ] < x [ i ] ) : a += y [ i ] elif ( y [ i ] == x [ i ] ) : a += ' z ' else : a = ' - 1' breakprint ( a ) NEW_LINE","a = input ( ) b = input ( ) l = len ( a ) NEW_LINE"],"bleu":0.15865544587973682,"rouge_l":0.5284905031656115}
{"id":576,"predictions":["import syssys . stdin = open ( \" input . txt \" , \" r \" ) sys . stdout = open ( \" output . txt \" , \" w \" ) n = int ( input ( ) ) for i in range ( 3 ) : u , v = map ( int , input ( ) . split ( ) ) if ( u == n ) : n = v elif ( v == n ) : n = uprint ( n ) NEW_LINE"],"references":["def xuli ( ) : n = int ( input ( ) ) s = input ( ) dem1 = 0 dem2 = 0 for i in s : if i != '0' : break dem1 += 1 for i in reversed ( s ) : if i != '1' : break dem2 += 1 for i in range ( dem1 + ( dem1 + dem2 < n ) ) : print ( 0 , end = ' ' ) for i in range ( dem2 ) : print ( 1 , end = ' ' ) print ( ' ' )       t = int ( input ( ) ) while ( t > 0 ) : xuli ( ) t -= 1 NEW_LINE","def solve ( ) : n = int ( input ( ) ) s = input ( ) first_one_idx , last_zero_idx = - 1 , - 1 for i in range ( n ) : if s [ i ] == '1' : first_one_idx = i break for i in reversed ( range ( n ) ) : if s [ i ] == '0' : last_zero_idx = i break if first_one_idx < last_zero_idx and first_one_idx != - 1 and last_zero_idx != - 1 : ans = s [ 0 : first_one_idx ] + '0' + s [ last_zero_idx + 1 : ] else : ans = s print ( ans )   t = int ( input ( ) ) for _ in range ( t ) : solve ( ) NEW_LINE","for s in [ * open ( 0 ) ] [ 2 : : 2 ] : i = s . find ( '1' ) % len ( s ) ; j = s . rfind ( '0' ) ; print ( s [ : i ] + '0' * ( j > i ) + s [ j + 1 : ] ) NEW_LINE"],"bleu":0.25826763862556074,"rouge_l":0.33075911929017415}
{"id":577,"predictions":["m , n = map ( int , input ( ) . split ( ) ) ans = 0 for i in range ( 5 ) : l = list ( map ( int , input ( ) . split ( ) ) ) ans += l [ ( 0 , 0 ) ] for j in range ( 5 ) : s = 0 for i in range ( 5 ) : s += l [ i ] [ j ] for k in range ( 1 , n ) : s += l [ i ] [ k ] if s > l [ k ] : breakprint ( ans ) NEW_LINE"],"references":["r = lambda : list ( map ( int , input ( ) . split ( ) ) ) arr = r ( ) w = r ( ) hacks = r ( )   score = 0 for i in range ( 5 ) : tot = ( 500 * ( i + 1 ) ) score += max ( 0.3 * tot , tot * ( 1 - arr [ i ] \/ 250 ) - 50 * w [ i ] )     score += 100 * hacks [ 0 ] score -= 50 * hacks [ 1 ]     print ( int ( score ) )   NEW_LINE","m = list ( map ( int , input ( ) . split ( ) ) ) w = list ( map ( int , input ( ) . split ( ) ) ) h = list ( map ( int , input ( ) . split ( ) ) ) points = [ 500 , 1000 , 1500 , 2000 , 2500 ] ans = 0 for i in range ( 5 ) : ans += max ( 0.3 * points [ i ] , ( ( 1 - m [ i ] \/ 250 ) * points [ i ] ) - 50 * w [ i ] ) ans += 100 * h [ 0 ] - 50 * h [ 1 ] print ( int ( ans ) ) NEW_LINE","m = list ( map ( int , input ( ) . split ( ' ▁ ' ) ) ) w = list ( map ( int , input ( ) . split ( ' ▁ ' ) ) ) h = list ( map ( int , input ( ) . split ( ' ▁ ' ) ) ) x = [ 500 , 1000 , 1500 , 2000 , 2500 ] res = 0   for i , j , y in zip ( m , w , x ) : res += max ( 0.3 * y , ( 1 - ( i \/ 250 ) ) * y - 50 * j )   res += 100 * h [ 0 ] res -= 50 * h [ 1 ] print ( int ( res ) )     NEW_LINE"],"bleu":0.40760837357187135,"rouge_l":0.5087307792546261}
{"id":578,"predictions":["n = list ( input ( ) ) a , b = - 1 , - 1 for i , j in enumerate ( n ) : if int ( j ) > b and int ( j ) % 2 == 0 and int ( j ) < int ( n [ - 1 ] ) : b = int ( j ) a = i breakif a == - 1 and b == - 1 : a , b = - 1 , 2 ** 31 for i , j in enumerate ( n ) : if int ( j ) % 2 == 0 : b = int ( j ) a = iif a == - 1 : print ( - 1 ) else : n [ a ] , n [ - 1 ] = n [ - 1 ] , n [ a ] print ( \" ▁ \" . join ( n ) ) NEW_LINE"],"references":["n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) flag = 0 for i in range ( n ) : for j in range ( n ) : if ( i == j ) : continue for k in range ( n ) : if ( i == k or j == k ) : continue if ( arr [ i ] == arr [ j ] + arr [ k ] ) : flag = 1 print ( i + 1 , j + 1 , k + 1 ) break if ( flag ) : break if ( flag ) : breakif ( flag == 0 ) : print ( - 1 ) NEW_LINE","amount_of_forms = int ( input ( ) ) lengths_of_worms = list ( map ( int , input ( ) . split ( ) ) )   for leng in range ( 0 , amount_of_forms - 1 ) : for leng2 in lengths_of_worms [ leng + 1 : ] : if int ( lengths_of_worms [ leng ] + leng2 ) in lengths_of_worms : for i in range ( amount_of_forms - 1 ) : if lengths_of_worms [ i ] == leng2 and i != lengths_of_worms . index ( leng2 ) : final = i + 1 try : print ( lengths_of_worms . index ( lengths_of_worms [ leng ] + leng2 ) + 1 , final , leng + 1 ) except : print ( lengths_of_worms . index ( lengths_of_worms [ leng ] + leng2 ) + 1 , lengths_of_worms . index ( leng2 ) + 1 , leng + 1 ) quit ( ) print ( - 1 ) NEW_LINE","n = int ( input ( ) ) w = [ int ( i ) for i in input ( ) . split ( ) ] f = False   for i in range ( n ) : if f : break   for j in range ( n ) : if f : break if i == j : continue   for k in range ( n ) : if f : break   if k == i or j == k : continue   if w [ i ] == w [ j ] + w [ k ] : a , b , c = i , j , k f = True   elif w [ j ] == w [ k ] + w [ i ] : a , b , c = j , i , k f = True   elif w [ k ] == w [ i ] + w [ j ] : f = True a , b , c = k , i , j   if f : print ( a + 1 , b + 1 , c + 1 ) else : print ( - 1 ) NEW_LINE"],"bleu":0.24195766099117275,"rouge_l":0.3804856315437737}
{"id":579,"predictions":["n , k = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l = [ sum ( l ) for s in range ( k ) ] dp = [ [ 0 for i in range ( k ) ] for i in range ( n ) ] dp [ 0 ] [ 0 ] = [ 0 for i in range ( n ) ] for i in range ( k ) : x = l [ i ] for j in range ( len ( l ) ) : if l [ j ] == 0 : dp [ i ] [ j ] [ i ] = min ( dp [ i ] [ j ] , x + 1 ) print ( dp [ - 1 ] ) NEW_LINE"],"references":["n , k = map ( int , input ( ) . split ( ) ) group = list ( map ( int , input ( ) . split ( ) ) ) available = [ [ k , 1 ] for i in range ( k + 1 ) ] center = ( k + 1 ) \/\/ 2 def calc ( center , row , col , num ) : end_col = col + num - 1 distance = abs ( center - row ) * num if col >= center : distance += ( col - center ) * num + ( num - 1 ) * num \/\/ 2 elif end_col <= center : distance += ( center - end_col ) * num + ( num - 1 ) * num \/\/ 2 else : distance += ( center - col ) * ( center - col + 1 ) \/\/ 2 + ( end_col - center ) * ( end_col - center + 1 ) \/\/ 2 return distancefor m in group : close , best_row , best_col = 10 ** 9 , - 1 , - 1 for row in range ( 1 , k + 1 ) : col = 0 if available [ row ] [ 0 ] < m and k - available [ row ] [ 1 ] + 1 < m : continue if available [ row ] [ 0 ] == k : col = center - m \/\/ 2 elif center - available [ row ] [ 0 ] <= available [ row ] [ 1 ] - center : col = available [ row ] [ 0 ] - m + 1 else : col = available [ row ] [ 1 ] distance = calc ( center , row , col , m ) if distance < close : close = distance best_row = row best_col = col if close == 10 ** 9 : print ( - 1 ) else : print ( best_row , best_col , best_col + m - 1 ) available [ best_row ] [ 0 ] = min ( available [ best_row ] [ 0 ] , best_col - 1 ) available [ best_row ] [ 1 ] = max ( available [ best_row ] [ 1 ] , best_col + m ) NEW_LINE","__author__ = ' Darren '     def solve ( ) : n , k = map ( int , input ( ) . split ( ) ) group = map ( int , input ( ) . split ( ) ) available = [ [ k , 1 ] [ : ] for _ in range ( k + 1 ) ] center = ( k + 1 ) \/\/ 2 for m in group : closest , best_row , best_col = 10000 , - 1 , - 1 for row in range ( 1 , k + 1 ) : col = 0 if available [ row ] [ 0 ] < m and k - available [ row ] [ 1 ] + 1 < m : continue if available [ row ] [ 0 ] == k : col = center - m \/\/ 2 elif center - available [ row ] [ 0 ] <= available [ row ] [ 1 ] - center : col = available [ row ] [ 0 ] - m + 1 else : col = available [ row ] [ 1 ] distance = calc_distance ( center , row , col , m ) if distance < closest : closest = distance best_row = row best_col = col if closest == 10000 : print ( - 1 ) else : print ( best_row , best_col , best_col + m - 1 ) available [ best_row ] [ 0 ] = min ( available [ best_row ] [ 0 ] , best_col - 1 ) available [ best_row ] [ 1 ] = max ( available [ best_row ] [ 1 ] , best_col + m )     def calc_distance ( center , row , col , num ) : end_col = col + num - 1 distance = abs ( center - row ) * num if col >= center : distance += ( col - center ) * num + ( num - 1 ) * num \/\/ 2 elif end_col <= center : distance += ( center - end_col ) * num + ( num - 1 ) * num \/\/ 2 else : distance += ( ( center - col ) * ( center - col + 1 ) \/\/ 2 + ( end_col - center ) * ( end_col - center + 1 ) \/\/ 2 ) return distance       if __name__ == ' _ _ main _ _ ' : solve ( ) NEW_LINE","def solve ( ) : n , k = map ( int , input ( ) . split ( ) ) group = map ( int , input ( ) . split ( ) ) available = [ [ k , 1 ] [ : ] for _ in range ( k + 1 ) ] center = ( k + 1 ) \/\/ 2 for m in group : closest , best_row , best_col = 10000 , - 1 , - 1 for row in range ( 1 , k + 1 ) : col = 0 if available [ row ] [ 0 ] < m and k - available [ row ] [ 1 ] + 1 < m : continue if available [ row ] [ 0 ] == k : col = center - m \/\/ 2 elif center - available [ row ] [ 0 ] <= available [ row ] [ 1 ] - center : col = available [ row ] [ 0 ] - m + 1 else : col = available [ row ] [ 1 ] distance = calc_distance ( center , row , col , m ) if distance < closest : closest = distance best_row = row best_col = col if closest == 10000 : print ( - 1 ) else : print ( best_row , best_col , best_col + m - 1 ) available [ best_row ] [ 0 ] = min ( available [ best_row ] [ 0 ] , best_col - 1 ) available [ best_row ] [ 1 ] = max ( available [ best_row ] [ 1 ] , best_col + m )     def calc_distance ( center , row , col , num ) : end_col = col + num - 1 distance = abs ( center - row ) * num if col >= center : distance += ( col - center ) * num + ( num - 1 ) * num \/\/ 2 elif end_col <= center : distance += ( center - end_col ) * num + ( num - 1 ) * num \/\/ 2 else : distance += ( ( center - col ) * ( center - col + 1 ) \/\/ 2 + ( end_col - center ) * ( end_col - center + 1 ) \/\/ 2 ) return distance     solve ( ) NEW_LINE"],"bleu":0.07960688171738693,"rouge_l":0.3078074747698791}
{"id":580,"predictions":["n , s = map ( int , input ( ) . split ( ) ) ans = 0 for i in range ( 1 , n + 1 ) : if s > i : ans += 1 print ( ans ) NEW_LINE"],"references":["def main ( ) : n = int ( input ( ) ) count = 0 for i in range ( 1 , n \/\/ 2 + 1 ) : if n % i == 0 : count += 1 print ( count )     if __name__ == ' _ _ main _ _ ' : main ( ) NEW_LINE","n = int ( input ( ) ) q , s = int ( n ** .5 ) + 1 , { 1 } for i in range ( 1 , q ) : if n % i == 0 : s . add ( i ) ; s . add ( n \/\/ i ) print ( len ( s ) - 1 ) NEW_LINE","n = int ( input ( ) ) ; c = 0 ; for i in range ( 1 , n ) : if ( n % i == 0 ) : c = c + 1 ; print ( c ) ; NEW_LINE"],"bleu":0.47036351780906116,"rouge_l":0.63986013986014}
{"id":581,"predictions":["for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE for u in range ( n ) : x , y = map ( int , input ( ) . split ( ) ) NEW_LINE x . sort ( ) NEW_LINE y . sort ( reverse = True ) NEW_LINE s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT xi , yi = sorted ( x [ i ] , reverse = True ) NEW_LINE s += x [ i ] - y [ i ] + 1 NEW_LINE print ( s ) NEW_LINE DEDENT DEDENT"],"references":["I = input NEW_LINE exec ( int ( I ( ) ) * ' n = int ( I ( ) ) ; k , m = ( 1 + x [ n > > 1 ] - x [ n - 1 > > 1 ] for ▁ x ▁ in ▁ map ( sorted , zip ( * ( map ( int , I ( ) . split ( ) ) for ▁ _ ▁ in [ 0 ] * n ) ) ) ) ; print ( k * m ) ; ' ) NEW_LINE","def solve ( z ) : NEW_LINE INDENT return z [ n \/\/ 2 ] + 1 - z [ - 1 - n \/\/ 2 ] NEW_LINE DEDENT for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE x , y = map ( sorted , zip ( * ( map ( int , input ( ) . split ( ) ) for _ in range ( n ) ) ) ) NEW_LINE print ( solve ( x ) * solve ( y ) ) NEW_LINE DEDENT","def solve ( z ) : NEW_LINE INDENT return z [ n \/\/ 2 ] + 1 - z [ - 1 - n \/\/ 2 ] NEW_LINE DEDENT for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE x , y = map ( sorted , zip ( * ( map ( int , input ( ) . split ( ) ) for _ in range ( n ) ) ) ) NEW_LINE print ( solve ( x ) * solve ( y ) ) NEW_LINE DEDENT"],"bleu":0.4729465960131337,"rouge_l":0.5031312051321215}
{"id":582,"predictions":["n = int ( input ( ) ) s = input ( ) ans = 0 for i in range ( n ) : if s [ i ] == ' C ' : ans += 1 else : if s [ i ] == ' C ' : ans += 1 print ( ans ) NEW_LINE"],"references":["def fact ( n ) : if n <= 1 : return 1 else : return n * fact ( n - 1 )   def c ( n , r ) : return fact ( n ) \/\/ ( fact ( r ) * fact ( n - r ) )   n = int ( input ( ) ) arr = [ ] h = 0 for _ in range ( n ) : arr . append ( list ( input ( ) ) ) for i in arr : if i . count ( \" C \" ) >= 2 : h += c ( i . count ( \" C \" ) , 2 ) arr = list ( map ( list , zip ( * arr ) ) )   for i in arr : if i . count ( \" C \" ) >= 2 : h += c ( i . count ( \" C \" ) , 2 ) print ( h ) NEW_LINE","a = int ( input ( ) ) c = [ [ ] for i in range ( a ) ] h = 0 for i in range ( a ) : b = input ( ) for j in range ( a ) : c [ i ] . append ( b [ j ] ) h += b . count ( ' C ' ) * ( b . count ( ' C ' ) - 1 ) \/\/ 2 for j in range ( a ) : num = 0 for i in range ( a ) : if c [ i ] [ j ] == ' C ' : num += 1 h += num * ( num - 1 ) \/\/ 2 print ( h ) NEW_LINE","n = int ( input ( ) ) cke = [ ] for i in range ( n ) : a = [ ] s = input ( ) for j in range ( n ) : a . append ( s [ j ] ) cke . append ( a ) c = 0 for i in range ( n ) : for j in range ( n ) : if cke [ i ] [ j ] == ' C ' : for k in range ( j + 1 , n ) : if cke [ i ] [ k ] == ' C ' : c += 1 for k in range ( i + 1 , n ) : if cke [ k ] [ j ] == ' C ' : c += 1   print ( c ) NEW_LINE"],"bleu":0.16985128967049276,"rouge_l":0.4473881155515642}
{"id":583,"predictions":["def solution ( ) : n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) )   count = { } for i in arr : if i not in count : count [ i ] = 1 else : count [ i ] += 1   maxi = n \/ 2 if int ( maxi ) != maxi : maxi = int ( maxi ) + 1 mx = 0 for i in count : mx = max ( mx , count [ i ] ) if mx <= maxi : print ( ' YES ' ) else : print ( ' NO ' )     return \t \t       solution ( ) NEW_LINE"],"references":["from collections import defaultdict   n = int ( input ( ) ) p = list ( map ( int , input ( ) . split ( ) ) ) s = list ( map ( int , input ( ) . split ( ) ) )   clds , pars = defaultdict ( list ) , [ 0 ] * ( n + 1 ) for i in range ( n - 1 ) : cur , par = i + 2 , p [ i ] clds [ p [ i ] ] . append ( cur ) pars [ cur ] = par   ans , ok = s [ 0 ] , Truei , q = 0 , [ 1 ] while i < len ( q ) : cur = q [ i ] i += 1 par_v = s [ pars [ cur ] - 1 ] if cur in clds : mmin , summ , k = float ( ' inf ' ) , 0 , 0 for item in clds [ cur ] : mmin = min ( mmin , s [ item - 1 ] ) summ += s [ item - 1 ] k += 1 q . append ( item ) if s [ cur - 1 ] != - 1 : continue if mmin < par_v : ok = False break ans -= par_v ans += ( summ - ( k - 1 ) * mmin ) if ok : print ( ans ) else : print ( - 1 ) NEW_LINE","n = int ( input ( ) ) p = [ 0 , 0 ] + list ( map ( int , input ( ) . split ( ) ) ) s = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) ht = [ 0 ] * ( n + 1 ) ht [ 1 ] = 1   from collections import defaultdict , dequegr = defaultdict ( list )   for i in range ( 2 , n + 1 ) : gr [ p [ i ] ] . append ( i ) q = deque ( ) q . append ( [ 1 , - 1 ] ) while q : x , pr = q . popleft ( ) for i in gr [ x ] : if i != pr : ht [ i ] = ht [ x ] + 1 q . append ( [ i , x ] ) a = [ 0 ] * ( n + 1 ) a [ 1 ] = s [ 1 ]     q . append ( [ 1 , - 1 ] ) while q : x , pr = q . popleft ( ) for ch in gr [ x ] : q . append ( [ ch , x ] ) if ht [ x ] % 2 == 0 : mn = float ( ' inf ' ) for i in gr [ x ] : mn = min ( mn , s [ i ] - s [ p [ x ] ] ) if mn != float ( ' inf ' ) : a [ x ] = mn for i in gr [ x ] : a [ i ] = s [ i ] - s [ p [ x ] ] - mn tf = Truefor i in a : if i < 0 : tf = False breakif tf : print ( sum ( a ) ) else : print ( - 1 ) NEW_LINE","def solve ( ) : a = [ None ] * ( n + 1 )   a [ 1 ] = s [ 0 ] for i in range ( 2 , n + 1 ) : if s [ i - 1 ] == - 1 : continue   pi = p [ i - 2 ] pi_er_pi = p [ pi - 2 ]   if s [ i - 1 ] < s [ pi_er_pi - 1 ] : return - 1   new_value = s [ i - 1 ] - s [ pi_er_pi - 1 ] a [ pi ] = min ( a [ pi ] if a [ pi ] is not None else float ( ' inf ' ) , new_value )   for i in range ( 2 , n + 1 ) : if s [ i - 1 ] == - 1 : continue   pi = p [ i - 2 ] pi_er_pi = p [ pi - 2 ]   a [ i ] = s [ i - 1 ] - s [ pi_er_pi - 1 ] - a [ pi ]   return sum ( filter ( None , a ) )     n = int ( input ( ) ) p = list ( map ( int , input ( ) . split ( ) ) ) s = list ( map ( int , input ( ) . split ( ) ) ) ans = solve ( ) print ( ans ) NEW_LINE"],"bleu":0.1292482639944923,"rouge_l":0.33343425661861414}
{"id":584,"predictions":["def solve ( ) : n = int ( input ( ) ) lst = list ( map ( int , input ( ) . split ( ) ) ) lst . sort ( ) f = 0 for i in lst : if i == n - 1 : f = 1 break if f == 1 : print ( \" YES \" ) return print ( \" NO \" )                            NEW_LINE"],"references":["for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) ans = \" YES \" s = set ( ) for i in range ( n ) : if ( b [ i ] > a [ i ] and ( 1 not in s ) or b [ i ] < a [ i ] and ( - 1 not in s ) ) : ans = \" NO \" break s . add ( a [ i ] ) print ( ans ) NEW_LINE","def answer ( n , a , b ) : s = set ( ) NEW_LINE","for t in range ( int ( input ( ) ) ) : input ( ) ; seen = { } ; r = ' yes ' ; i = lambda : map ( int , input ( ) . split ( ) ) for a , b in zip ( i ( ) , i ( ) ) : if a != b and not seen . get ( b > a ) : r = ' no ' ; break if a and not seen . get ( a > 0 ) : if seen . get ( a < 0 ) : break seen [ a > 0 ] = 1 print ( r ) NEW_LINE"],"bleu":0.465704479079101,"rouge_l":0.5587999541967251}
{"id":585,"predictions":["a = input ( ) . split ( ) NEW_LINE print ( len ( a ) - 1 ) NEW_LINE"],"references":["def check ( txt : str ) -> bool : ln = len ( txt ) if ln == 0 or ln > 16 : return False for item in txt : if not ( ' a ' <= item <= ' z ' or ' A ' <= item <= ' Z ' or '0' <= item <= '9' or item == ' _ ' ) : return False return True     def checkHost ( hostName : str ) -> bool : hostLen = len ( hostName ) if hostLen == 0 or hostLen > 32 : return False for token in hostName . split ( ' . ' ) : if not check ( token ) : return False return True     mail = input ( ) isUser , isHost , isRes = False , False , Falseif ' @ ' in mail : atIndex = mail . index ( ' @ ' ) slashInd = mail . index ( ' \/ ' ) if ' \/ ' in mail else - 1 userName = mail [ : atIndex ] isUser = check ( userName ) hostName = mail [ atIndex + 1 : slashInd ] if slashInd != - 1 else mail [ atIndex + 1 : ] isHost = checkHost ( hostName ) if slashInd == - 1 : isRes = True else : resource = mail [ slashInd + 1 : ] isRes = check ( resource ) ''' if ▁ isUser ▁ and ▁ isHost ▁ and ▁ isRes : ▁ ▁ ▁ ▁ print ( ' YES ' ) else : ▁ ▁ ▁ ▁ print ( ' NO ' ) ''' print ( ' YES ' if isUser and isHost and isRes else ' NO ' ) NEW_LINE","email = input ( ) . split ( ' @ ' ) if ( len ( email ) != 2 ) : print ( \" NO \" ) else : flag = True rem = email [ 1 ] [ : ] rem = rem . split ( ' \/ ' ) NEW_LINE","''' def ▁ userName ( username ) : ▁ ▁ ▁ ▁ if ▁ len ( username ) ▁ < ▁ 1 ▁ or ▁ len ( username ) ▁ > ▁ 16 : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ return ▁ - 1 ▁ ▁ ▁ ▁ for ▁ item ▁ in ▁ username : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ item ▁ < ▁ ' 0 ' ▁ or ▁ item ▁ > ▁ ' w ' ▁ and ▁ item ▁ ! = ▁ ' _ ' : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ return ▁ - 1 ▁ ▁ ▁ ▁ return ▁ 1  def ▁ hostName ( hostname ) : ▁ ▁ ▁ ▁ if ▁ len ( hostname ) ▁ < ▁ 1 ▁ or ▁ len ( hostname ) ▁ > ▁ 32 : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ return ▁ - 1 ▁ ▁ ▁ ▁ for ▁ item ▁ in ▁ hostname :     line ▁ = ▁ input ( ) indOfAt ▁ = ▁ line . index ( ' @ ' ) username ▁ = ▁ line [ 0 : indOfAt ] hostname ▁ = ▁ line [ indOfAt ▁ + ▁ 1 : line . rindex ( ' . ' ) ] '''     def check ( line ) : ln = len ( line ) if ln == 0 or ln > 16 : return False for it in line : if not ( ' A ' <= it <= ' Z ' or ' a ' <= it <= ' z ' or '0' <= it <= '9' or it == ' _ ' ) : return False return True     def checkHost ( hostName ) : ln = len ( hostName ) if ln == 0 or ln > 32 : return False for token in hostName . split ( ' . ' ) : if not check ( token ) : return False return True     mail , isUser , isHost , isRes = input ( ) , False , False , Falseif ' @ ' in mail : atIndex = mail . index ( ' @ ' ) userName = mail [ : atIndex ] isUser = check ( userName ) hostName = mail [ atIndex + 1 : mail . index ( ' \/ ' ) ] if ' \/ ' in mail else mail [ atIndex + 1 : ] isHost = checkHost ( hostName ) if ' \/ ' not in mail : isRes = True else : isRes = check ( mail [ mail . index ( ' \/ ' ) + 1 : ] )   print ( ' YES ' if isUser and isHost and isRes else ' NO ' ) NEW_LINE"],"bleu":0.0951232116900804,"rouge_l":0.37998338870431897}
{"id":586,"predictions":["for _ in range ( int ( input ( ) ) ) : x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) NEW_LINE x2 , y2 , x3 = map ( int , input ( ) . split ( ) ) NEW_LINE d = abs ( x1 - x2 ) + abs ( y1 - y2 ) NEW_LINE if ( d > 0 and d > 0 ) : NEW_LINE INDENT d = 2 NEW_LINE DEDENT print ( 2 * d - 1 ) NEW_LINE"],"references":["for _ in range ( int ( input ( ) ) ) : x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) )   if x1 == x2 : print ( abs ( y2 - y1 ) )   elif y1 == y2 : print ( abs ( x2 - x1 ) )   else : print ( abs ( x2 - x1 ) + 2 + abs ( y2 - y1 ) ) NEW_LINE","def string_list ( s , char ) : output_list = [ ] NEW_LINE intermediator = \" \" NEW_LINE for i in range ( len ( s ) ) : if NEW_LINE s [ i ] != char : intermediator += s [ i ] NEW_LINE if i == len ( s ) - 1 : NEW_LINE INDENT output_list . append ( int ( intermediator ) ) else : NEW_LINE if NEW_LINE DEDENT intermediator : output_list . append ( int ( intermediator ) ) NEW_LINE intermediator = \" \" NEW_LINE return output_list     NEW_LINE def list_string ( l , char ) : output_str = \" \" NEW_LINE for i in range ( len ( l ) - 1 ) : output_str += str ( l [ i ] ) + char NEW_LINE output_str += str ( l [ len ( l ) - 1 ] ) NEW_LINE return output_str     NEW_LINE def merge_sort ( l ) : def NEW_LINE merge ( l1 , l2 ) : i , j = 0 , 0 NEW_LINE output_list = [ ] NEW_LINE while i < len ( l1 ) and j < len ( l2 ) : if NEW_LINE l1 [ i ] < l2 [ j ] : output_list . append ( l1 [ i ] ) NEW_LINE i += 1 else : output_list . append ( l2 [ j ] ) NEW_LINE j += 1 NEW_LINE if i == len ( l1 ) : NEW_LINE INDENT output_list += ( l2 [ j : ] ) else : NEW_LINE output_list += ( l1 [ i : ] ) NEW_LINE DEDENT return output_list   NEW_LINE def sorts ( l ) : if NEW_LINE len ( l ) < 2 : NEW_LINE return l else : mid = len ( l ) \/\/ 2 NEW_LINE left = sorts ( l [ : mid ] ) NEW_LINE right = sorts ( l [ mid : ] ) NEW_LINE return merge ( left , right ) NEW_LINE return sorts ( l )       NEW_LINE def main_function ( ) : output_list = [ ] NEW_LINE t = int ( input ( ) ) NEW_LINE for i in range ( t ) : x_1 , y_1 , x_2 , y_2 = string_list ( input ( ) , \" ▁ \" ) NEW_LINE dif_x = abs ( x_2 - x_1 ) NEW_LINE dif_y = abs ( y_2 - y_1 ) NEW_LINE if dif_y and dif_x : NEW_LINE INDENT total = dif_y + dif_x + 2 else : NEW_LINE total = dif_y + dif_x NEW_LINE DEDENT output_list . append ( total ) NEW_LINE return list_string ( output_list , \" ▁ \" )       print ( main_function ( ) )   NEW_LINE","for t in range ( int ( input ( ) ) ) : p , q , r , k = map ( int , input ( ) . split ( ) ) NEW_LINE if p == r : NEW_LINE INDENT print ( abs ( q - k ) ) elif q == k : NEW_LINE print ( abs ( p - r ) ) else : NEW_LINE print ( abs ( p - r ) + abs ( q - k ) + 2 ) NEW_LINE DEDENT"],"bleu":0.5280354346746998,"rouge_l":0.5930555555555556}
{"id":587,"predictions":["import math   a , b , c , d = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) if ( l [ 0 ] * l [ 2 ] ) * l [ 3 ] print ( \" paper \" ) elif ( l [ 0 ] * l [ 1 ] * l [ 2 ] ) else : print ( \" paper \" ) NEW_LINE"],"references":["oro_infinito = False   datos = input ( ) . split ( ) NEW_LINE a = int ( datos [ 0 ] ) NEW_LINE b = int ( datos [ 1 ] ) NEW_LINE c = int ( datos [ 2 ] ) NEW_LINE d = int ( datos [ 3 ] ) NEW_LINE e = int ( datos [ 4 ] ) NEW_LINE f = int ( datos [ 5 ] )   if a != 0 and b != 0 and c != 0 and d != 0 and e != 0 and f != 0 : if NEW_LINE ( b \/ a ) * ( d \/ c ) * ( f \/ e ) > 1 : oro_infinito = Trueelse : if c == 0 and d > 0 : NEW_LINE INDENT oro_infinito = True elif a == 0 and b > 0 and c > 0 and d > 0 : NEW_LINE oro_infinito = True elif e == 0 and f > 0 and a > 0 and b > 0 and c > 0 and d > 0 : NEW_LINE oro_infinito = True   if oro_infinito : NEW_LINE print ( ' Ron ' ) else : NEW_LINE print ( ' Hermione ' ) NEW_LINE DEDENT","a , b , c , d , e , f = map ( int , input ( ) . split ( ) ) NEW_LINE if a * c * e < b * d * f or ( c == 0 and d > 0 ) or ( a == 0 and b > 0 and d > 0 and c > 0 ) : NEW_LINE INDENT print ( \" Ron \" ) else : NEW_LINE print ( \" Hermione \" ) NEW_LINE DEDENT","a , b , c , d , e , f = map ( int , input ( ) . split ( ) ) ; if a * c * e < b * d * f or a == 0 and b * d > 0 or c == 0 and d > 0 : print ( \" Ron \" ) ; else : print ( \" Hermione \" ) ; NEW_LINE"],"bleu":0.4015877763525824,"rouge_l":0.47075289946154814}
{"id":588,"predictions":["n = int ( input ( ) ) ans = 0 if n == 1 : print ( - 1 ) elif n % 2 == 0 : ans += 1 else : print ( n \/\/ 2 ) NEW_LINE"],"references":["n = int ( input ( ) ) if n % 2 == 0 : print ( n \/\/ 2 ) else : print ( ( n \/\/ 2 + 1 ) * ( - 1 ) )   NEW_LINE","n = int ( input ( ) ) print ( n \/\/ 2 - ( n % 2 ) * n ) NEW_LINE","user_input = int ( input ( ) ) result = user_input \/\/ 2 if user_input % 2 == 0 : print ( result ) else : print ( - ( result + 1 ) ) NEW_LINE"],"bleu":0.5924220742888017,"rouge_l":0.6876657824933686}
{"id":589,"predictions":["def solution ( ) : k = int ( input ( ) )   st = input ( )   cnt = [ 0 ] * 26   for i in st : cnt [ ord ( i ) - ord ( ' a ' ) ] += 1 for cnts in cnt : if cnts % k != 0 : print ( - 1 ) return ans = ' '   for i in range ( 26 ) : ans += chr ( 97 + i ) * ( cnt [ i ] \/\/ k ) print ( ans * k )     if __name__ == ' _ _ main _ _ ' : solution ( ) NEW_LINE"],"references":["m = input ( ) l = list ( m ) s = list ( set ( l ) ) z = 0   if ( m [ 0 ] == '4' ) : z = 1 elif ( '444' in m ) : z = 1 for i in s : if ( i == '4' or i == '1' ) : pass else : z = 1 break   if ( z == 1 ) : print ( \" NO \" ) else : print ( \" YES \" ) NEW_LINE","import sysfrom os import pathif ( path . exists ( ' input . txt ' ) and path . exists ( ' output . txt ' ) ) : sys . stdout = open ( ' output . txt ' , ' w ' ) sys . stdin = open ( ' input . txt ' , ' r ' )   NEW_LINE","n = input ( ) result = Truei = 0 t = len ( n ) while i < len ( n ) : if n [ i ] == \"1\" : i += 1 if i == t : break if n [ i ] == \"4\" : i += 1 if i == t : break if n [ i ] == \"4\" : i += 1 if i == t : break else : i += 1 result = Falseif result is True : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.10711205931440827,"rouge_l":0.3267170762444864}
{"id":590,"predictions":["import sysfrom collections import defaultdictdef input ( ) : return sys . stdin . readline ( ) . strip ( ) def iinput ( ) : return int ( input ( ) ) def minput ( ) : return map ( int , input ( ) . split ( ) ) def listinput ( ) : return list ( map ( int , input ( ) . split ( ) ) ) \"\"\" \"\"\" ▁ a = input ( ) b = input ( ) s = input ( ) c = input ( ) . split ( ) d = { } for i in s : if i in d : d [ i ] += 1 else : d [ i ] = 1 ans = 0 for i in d : if d [ i ] > d [ i ] : d [ i ] = 1 ans += 1 print ( ans ) NEW_LINE"],"references":["a = [ i for i in input ( ) ] b = [ i for i in input ( ) ]   ab = [ i for i in input ( ) ]   c = a + b   ab . sort ( ) c . sort ( )   if ab == c : print ( ' YES ' ) else : print ( ' NO ' ) NEW_LINE","from collections import Counterx1 = Counter ( input ( ) ) x2 = Counter ( input ( ) ) x3 = Counter ( input ( ) ) if x1 + x2 == x3 : print ( ' YES ' )   else : print ( ' NO ' )   NEW_LINE","s = input ( ) s1 = input ( ) s2 = input ( ) s3 = s + s1s3 = ' ' . join ( sorted ( s3 ) ) s2 = ' ' . join ( sorted ( s2 ) ) cnt = 0 if ( len ( s3 ) == len ( s2 ) ) : for i in range ( 0 , len ( s3 ) ) : if ( s3 [ i ] == s2 [ i ] ) : cnt += 1 if ( cnt == len ( s3 ) and len ( s3 ) == len ( s2 ) ) : print ( \" YES \" ) else : print ( \" NO \" ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.1642293574070119,"rouge_l":0.3776517447398043}
{"id":591,"predictions":["n = int ( input ( ) ) print ( ( n - 2 ) * ( n - 2 ) ) NEW_LINE"],"references":["def equal ( a , b ) : for i in range ( len ( a ) ) : if a [ i ] != b [ i ] and a [ i ] != \" * \" and b [ i ] != \" * \" : return False return True   string , k , best = input ( ) . strip ( ) , int ( input ( ) ) , 0 string += \" * \" * kfor i in range ( len ( string ) + 1 ) : for j in range ( i + 1 , len ( string ) + 1 ) : if not ( j - i ) % 2 : if equal ( string [ i : ( i + j ) \/\/ 2 ] , string [ ( i + j ) \/\/ 2 : j ] ) : best = max ( best , j - i ) print ( best ) NEW_LINE","def solve ( ) : s = input ( ) k = int ( input ( ) ) len_s = len ( s ) len_f = len_s + k max_n = int ( len_f \/ 2 ) NEW_LINE","s = [ * input ( ) ] k = int ( input ( ) ) s . extend ( [ ' ? ' ] * k ) m = 0 for i in range ( 1 , len ( s ) \/\/ 2 + 1 ) : for j in range ( len ( s ) - 2 * i + 1 ) : q = 0 for k in range ( i ) : if s [ j + k ] == ' ? ' or s [ j + k + i ] == ' ? ' : continue if s [ j + k ] != s [ j + k + i ] : q = 1 break if q : continue else : m = i breakprint ( 2 * m ) NEW_LINE"],"bleu":0.22918008588963087,"rouge_l":0.4386775568644041}
{"id":592,"predictions":["from sys import stdin , stdoutfrom os import pathrd = lambda : stdin . readline ( ) . strip ( ) wr = stdout . writeif ( path . exists ( ' input . txt ' ) ) : stdin = open ( \" input . txt \" , \" r \" ) import time , math NEW_LINE"],"references":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) res = 0 for j in range ( n - 2 , - 1 , - 1 ) : if a [ j ] >= a [ j + 1 ] : a [ j ] = max ( 0 , a [ j + 1 ] - 1 ) print ( sum ( a ) ) NEW_LINE","n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) ans = l [ - 1 ] x = n - 1 p = l [ - 1 ] while x >= 1 : if p == 0 : break else : if l [ x - 1 ] >= p : ans += p - 1 p = p - 1 else : ans += l [ x - 1 ] p = l [ x - 1 ] x -= 1 print ( ans ) NEW_LINE","n = int ( input ( ) ) cho = [ int ( x ) for x in input ( ) . split ( ) ] cho . reverse ( ) s = cho [ 0 ] prev = cho [ 0 ] for i in range ( 1 , len ( cho ) ) : if cho [ i ] >= prev : if prev > 1 : s += prev - 1 prev -= 1 else : break else : s += cho [ i ] prev = cho [ i ] print ( s ) NEW_LINE"],"bleu":0.05153346178258764,"rouge_l":0.23366381252816587}
{"id":593,"predictions":["n , k = map ( int , input ( ) . split ( ) ) ans = [ [ ' # ' , ' # ' ] for i in range ( n ) ] for i in range ( n ) : for j in range ( i ) : if i % 2 == 0 : ans [ i ] [ j ] = ' # ' else : ans [ i ] [ j ] = ' # 'ans [ i ] [ j ] = ' # ' for i in range ( k ) : ans [ i ] [ j ] = ans [ i ] [ j ] = ' # ' for i in range ( n ) : if k == 0 : break ans [ i ] [ j ] = ' # ' else : ans [ i ] [ j ] = ' # ' for i in range ( n ) : ans [ i ] [ j ] = ' # ' + ans [ i ] [ j ] = ' # ' a [ i ] [ j ] = ' # ' a [ i ] [ j ] = ' # ' + [ i ] [ j ] = ' # ' a [ i ] [ j ] = ' # ' for i in range ( n ) : print ( ' \" . join ( ans [ i ] ) ) NEW_LINE"],"references":["n , k = map ( int , input ( ) . split ( ) ) if ( k % 2 == 0 ) : print ( \" YES \" ) print ( ' . ' * n ) print ( ' . ' + ' # ' * ( k \/\/ 2 ) + ' . ' * ( n - 1 - k \/\/ 2 ) ) print ( ' . ' + ' # ' * ( k \/\/ 2 ) + ' . ' * ( n - 1 - k \/\/ 2 ) ) print ( ' . ' * n ) else : print ( \" YES \" ) print ( ' . ' * n ) if ( k <= n - 2 ) : print ( ' . ' * ( ( n - k ) \/\/ 2 ) + ' # ' * k + ' . ' * ( ( n - k ) \/\/ 2 ) ) print ( ' . ' * n ) else : print ( ' . ' + ' # ' * ( n - 2 ) + ' . ' ) print ( ' . ' + ' # ' * ( ( k - n + 2 ) \/\/ 2 ) + ' . ' * ( n - 2 - k + n - 2 ) + ' # ' * ( ( k - n + 2 ) \/\/ 2 ) + ' . ' ) print ( ' . ' * n ) NEW_LINE","n , k = map ( int , input ( ) . split ( ) ) s = ' . ' * nm = ( k + 1 ) \/\/ 2 a = ' . ' + ' # ' * m + ' . ' * ( n - m - 1 ) if k % 2 == 0 : b = aelif k < n : t = ( n - k ) \/\/ 2 * ' . ' a , b = t + ' # ' * k + t , selse : b = a [ : 2 ] + ' . ' + a [ 3 : ] print ( ' YES ' , s , a , b , s , sep = ' \\n ' ) NEW_LINE","n , k = map ( int , input ( ) . split ( ) ) a = [ ] for i in range ( 0 , 4 ) : temp = [ ] for i in range ( 0 , n ) : temp . append ( ' . ' ) a . append ( temp ) m = ki = 1 while m > 1 and i < ( n \/\/ 2 ) : a [ 1 ] [ i ] = ' # ' a [ 1 ] [ n - i - 1 ] = ' # ' i += 1 m -= 2 i = 1 while m > 1 and i < ( n \/\/ 2 ) : a [ 2 ] [ i ] = ' # ' a [ 2 ] [ n - i - 1 ] = ' # ' i += 1 m -= 2 if m > 0 : a [ 1 ] [ n \/\/ 2 ] = ' # ' m -= 1 if m > 0 : a [ 2 ] [ n \/\/ 2 ] = ' # ' m -= 1 print ( ' YES ' ) for i in range ( 0 , 4 ) : for j in range ( 0 , n ) : print ( a [ i ] [ j ] , end = ' ' ) print ( ) NEW_LINE"],"bleu":0.35863110015703153,"rouge_l":0.48542795635067926}
{"id":594,"predictions":["import sys     def solve ( k , v ) : NEW_LINE INDENT if k == 0 : NEW_LINE INDENT return k NEW_LINE DEDENT else : NEW_LINE INDENT return k + 1 NEW_LINE DEDENT DEDENT k , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE l = 0 NEW_LINE while l < r : NEW_LINE INDENT t = l + 1 NEW_LINE if k == 0 : NEW_LINE INDENT ans = t + 1 NEW_LINE DEDENT print ( ans ) NEW_LINE return NEW_LINE DEDENT"],"references":["sections , a , divisors , cap = map ( int , input ( ) . split ( ) )   NEW_LINE","import math   k , a , b , v = map ( int , input ( ) . split ( ) )         ans = 0   while a > 0 :   l = min ( k - 1 , b )   b -= l a -= ( l + 1 ) * v   ans += 1   print ( ans ) NEW_LINE","import mathk , a , b , v = map ( int , input ( ) . split ( ) ) ans = 0 while a > 0 : l = min ( k - 1 , b ) b -= l a -= ( l + 1 ) * v ans += 1 print ( ans ) NEW_LINE"],"bleu":0.269472121021011,"rouge_l":0.532082893874177}
{"id":595,"predictions":["a , b = map ( int , input ( ) . split ( ) ) if a - b < 0 : print ( a % 10 ) else : print ( ( b % 10 ) ) NEW_LINE"],"references":["a , b = [ int ( x ) for x in input ( ) . split ( ) ]   x = b % 10 mul = 1 for i in range ( b , a , - 1 ) : mul *= x x -= 1 if x < 0 and i > a : print ( \"0\" ) mul = - 1 breakif mul != - 1 : mul = mul % 10 print ( mul ) NEW_LINE","def STR ( ) : return list ( input ( ) ) def INT ( ) : return int ( input ( ) ) def MAP ( ) : return map ( int , input ( ) . split ( ) ) def MAP2 ( ) : return map ( float , input ( ) . split ( ) ) def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) def STRING ( ) : return input ( ) import stringimport sysfrom heapq import heappop , heappushfrom bisect import * from collections import deque , Counter , defaultdictfrom math import * from itertools import permutations , accumulatedx = [ - 1 , 1 , 0 , 0 ] dy = [ 0 , 0 , 1 , - 1 ] NEW_LINE","def STR ( ) : return list ( input ( ) ) def INT ( ) : return int ( input ( ) ) def MAP ( ) : return map ( int , input ( ) . split ( ) ) def MAP2 ( ) : return map ( float , input ( ) . split ( ) ) def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) def STRING ( ) : return input ( ) import stringimport sysfrom heapq import heappop , heappushfrom bisect import * from collections import deque , Counter , defaultdictfrom math import * from itertools import permutations , accumulatedx = [ - 1 , 1 , 0 , 0 ] dy = [ 0 , 0 , 1 , - 1 ] NEW_LINE"],"bleu":0.18778179719536842,"rouge_l":0.38942798774259446}
{"id":596,"predictions":["k = int ( input ( ) ) i = 2 n = m = 0 while i * i <= k : if k % i == 0 : if i >= 5 and k \/\/ i >= 5 : n = i m = k \/\/ i break i += 1 if n == 0 and m == 0 : print ( \" - 1\" ) exit ( 0 ) s = \" aeiou \" ans = ' ' l = 0 NEW_LINE"],"references":["n = int ( input ( ) ) a = pow ( 1 , n , 5 ) b = pow ( 2 , n , 5 ) c = pow ( 3 , n , 5 ) d = pow ( 4 , n , 5 ) print ( ( a + b + c + d ) % 5 )   NEW_LINE","s = input ( ) n = len ( s ) if n < 2 : n = 2 s = '0' + sx = int ( s [ n - 2 ] + s [ n - 1 ] ) if x % 4 == 0 : print ( 4 ) else : print ( 0 )   NEW_LINE","n = eval ( input ( ) ) n = n % 4 print ( ( 1 + 2 ** n + 3 ** n + 4 ** n ) % 5 ) NEW_LINE"],"bleu":0.17929493366215454,"rouge_l":0.3392283513522849}
{"id":597,"predictions":["import matht = int ( input ( ) ) for _ in range ( t ) : a , b , c = map ( int , input ( ) . split ( ) ) print ( max ( a , b , c ) ) NEW_LINE"],"references":["cases = int ( input ( ) ) while cases : cases -= 1 a , b , c , r = map ( int , input ( ) . split ( ) )   if a > b : a , b = b , a   pot = b - a   cl = c - r cr = c + r   if a <= cl <= cr <= b : ans = b - a - ( cr - cl ) elif cl <= a <= cr <= b : ans = b - cr elif a <= cl <= b <= cr : ans = cl - a elif cl <= a <= b <= cr : ans = 0 else : ans = b - a   print ( ans ) NEW_LINE","import sys     t = int ( input ( ) )   for _ in range ( t ) :   \"\"\" ▁ ▁ ▁ ▁ Cita ▁ código ▁ externo : ▁ ▁ ▁ ▁ https : \/ \/ www . geeksforgeeks . org \/ python - input - methods - competitive - programming \/ ▁ ▁ ▁ ▁ \"\"\"   a , b , c , d = list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) )   if a > b : ma = a mi = b else : ma = b mi = a   l = ma - mi   if c + d <= mi or c - d >= ma : pass elif c - d <= mi and c + d >= ma : l = 0 elif mi <= c and c <= ma : l -= min ( c - mi , d ) l -= min ( ma - c , d ) elif c < mi : l -= ( ( c + d ) - mi ) elif c > ma : l -= ( ma - ( c - d ) ) print ( l ) NEW_LINE","for _ in [ 0 ] * int ( input ( ) ) : a , b , c , r = map ( int , input ( ) . split ( ) ) if a > b : a , b = b , a print ( min ( b - a , max ( c - r - a , 0 ) + max ( b - c - r , 0 ) ) ) NEW_LINE"],"bleu":0.40683825916552513,"rouge_l":0.5681024447031432}
{"id":598,"predictions":["a , b , c = map ( int , input ( ) . split ( ) ) d , e , f = map ( int , input ( ) . split ( ) ) g , h , i = map ( int , input ( ) . split ( ) )   print ( min ( d , e - f ) ) NEW_LINE"],"references":["import mathimport collections def solve ( n , l ) : return max ( l ) - ( sum ( l ) - max ( l ) ) + 1   n = int ( input ( ) ) l = [ int ( s ) for s in input ( ) . split ( ) ] result = solve ( n , l ) print ( result ) NEW_LINE","n = int ( input ( ) )   arr = list ( map ( int , input ( ) . split ( ) ) )   maxim = max ( arr )   tot = sum ( arr )   res = ( 2 * maxim ) - tot + 1   print ( res ) NEW_LINE","n = int ( input ( ) ) l = [ int ( x ) for x in input ( ) . split ( ) ] print ( max ( l ) - ( sum ( l ) - max ( l ) ) + 1 ) NEW_LINE"],"bleu":0.2722627902995412,"rouge_l":0.4863141110815839}
{"id":599,"predictions":["n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l . sort ( ) i = 1 while i in l : i += 1 print ( i ) NEW_LINE"],"references":["def main_funtion ( ) : n = int ( input ( ) ) s = [ int ( i ) for i in input ( ) . split ( \" ▁ \" ) ] minimum = min ( s ) the_val = 10000000000000 for i in s : if i > minimum and i < the_val : the_val = i if the_val == 10000000000000 : return \" NO \" return the_val     print ( main_funtion ( ) ) NEW_LINE","input ( ) max = 101 min = 101 for elem in list ( map ( int , input ( ) . split ( ) ) ) : if elem < min : max = min min = elem elif elem < max and elem != min : max = elemprint ( \" NO \" if max == 101 else max ) NEW_LINE","n = int ( input ( ) ) m = ( sorted ( list ( set ( map ( int , input ( ) . strip ( ) . split ( ) ) ) ) ) ) [ : n ] print ( m [ 1 ] if len ( m ) > 1 else \" NO \" ) NEW_LINE"],"bleu":0.41619956365135735,"rouge_l":0.5528700906344411}
{"id":600,"predictions":["n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) s = n - 1 for i in range ( 1 , n ) : if arr [ i ] < s : s += 1 print ( s ) NEW_LINE"],"references":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) a . sort ( ) cur = 1 for i in range ( n ) : if a [ i ] >= cur : cur += 1 print ( cur - 1 ) NEW_LINE","n = int ( input ( ) ) bt = list ( map ( int , input ( ) . split ( ) ) ) bt . sort ( ) day = 1 for a in range ( n ) : if day <= bt [ a ] : day += 1 print ( day - 1 ) NEW_LINE","n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ' ▁ ' ) ) ) a = list ( sorted ( a ) )   days_of_training = 0 for i in range ( len ( a ) ) : if a [ i ] > days_of_training : days_of_training += 1 print ( days_of_training ) NEW_LINE"],"bleu":0.5782541040679819,"rouge_l":0.77894438138479}
{"id":601,"predictions":["n , k = map ( int , input ( ) . split ( ) ) count = 0 a = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( 1 , 101 ) : a [ i ] = True a [ i ] = a [ i - 1 ] + 1 print ( count ) NEW_LINE"],"references":["entrada1 = input ( ) . split ( ) NEW_LINE n , k = int ( entrada1 [ 0 ] ) , int ( entrada1 [ 1 ] )   entrada2 = input ( ) . split ( ) NEW_LINE c = int ( entrada2 [ 0 ] ) NEW_LINE festivos = [ ] NEW_LINE for i in range ( c ) : festivos . append ( int ( entrada2 [ i + 1 ] ) )   regalos = 0 NEW_LINE k_esimo = 0 NEW_LINE f = 0   i = 1 NEW_LINE while i <= n : if NEW_LINE f < c and i == festivos [ f ] : regalos = regalos + 1 NEW_LINE f = f + 1 NEW_LINE k_esimo = 0 else : k_esimo = k_esimo + 1 NEW_LINE if k_esimo == k : regalos = regalos + 1 NEW_LINE k_esimo = 0 NEW_LINE i = i + 1 NEW_LINE print ( regalos ) NEW_LINE","n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE t = 1 NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : if NEW_LINE i in a [ 1 : ] : ans += 1 NEW_LINE t = 1 elif t == k : ans += 1 NEW_LINE t = 1 else : t += 1 NEW_LINE print ( ans ) NEW_LINE","n , k = map ( int , input ( ) . split ( ) ) NEW_LINE d = list ( map ( int , input ( ) . split ( ) ) ) [ 1 : ] + [ n + 1 ] NEW_LINE res , mx = 0 , kfor NEW_LINE i in range ( len ( d ) ) : res += max ( 0 , ( d [ i ] - mx + k - 1 ) \/\/ k ) + 1 NEW_LINE mx = max ( mx , d [ i ] + k ) NEW_LINE print ( res - 1 ) NEW_LINE"],"bleu":0.4481516901273605,"rouge_l":0.6253384912959381}
{"id":602,"predictions":["from sys import stdin , stdoutfrom os import pathrd = lambda : stdin . readline ( ) . strip ( ) wr = stdout . writeif ( path . exists ( ' input . txt ' ) ) : stdin = open ( \" input . txt \" , \" r \" ) import time , math NEW_LINE"],"references":["n , k = map ( int , input ( ) . split ( ) ) e = ( n - k ) \/\/ 2 c = \"0\" * e + \"1\" while ( len ( c ) <= n ) : c = c + cprint ( c [ : n ] ) NEW_LINE","import sysfrom math import * from fractions import gcdreadints = lambda : map ( int , input ( ) . strip ( ' \\n ' ) . split ( ) )       def hasUnique ( s , n , k ) : freq = { }   for i in range ( n - k + 1 ) : x = s [ i : i + k ] if x not in freq : freq [ x ] = 0 freq [ x ] += 1   for k in freq : if freq [ k ] == 1 : return True return False   def good ( s , n , k ) : for i in range ( 1 , k ) : if hasUnique ( s , n , i ) : return False freq = { } for i in range ( n - k + 1 ) : x = s [ i : i + k ] if x not in freq : freq [ x ] = 0 freq [ x ] += 1   st = set ( ) for x in freq : if freq [ x ] == 1 : if len ( st ) > 0 : return False st . add ( x ) return len ( st ) == 1   def gen ( i , s , n , k ) : if i == n : if good ( s , n , k ) : print ( s ) else : gen ( i + 1 , s + '0' , n , k ) gen ( i + 1 , s + '1' , n , k )           NEW_LINE","import sysfrom math import * from fractions import gcdreadints = lambda : map ( int , input ( ) . strip ( ' \\n ' ) . split ( ) )       def hasUnique ( s , n , k ) : freq = { }   for i in range ( n - k + 1 ) : x = s [ i : i + k ] if x not in freq : freq [ x ] = 0 freq [ x ] += 1   for k in freq : if freq [ k ] == 1 : return True return False   def good ( s , n , k ) : for i in range ( 1 , k ) : if hasUnique ( s , n , i ) : return False freq = { } for i in range ( n - k + 1 ) : x = s [ i : i + k ] if x not in freq : freq [ x ] = 0 freq [ x ] += 1   st = set ( ) for x in freq : if freq [ x ] == 1 : if len ( st ) > 0 : return False st . add ( x ) return len ( st ) == 1   def gen ( i , s , n , k ) : if i == n : if good ( s , n , k ) : print ( s ) else : gen ( i + 1 , s + '0' , n , k ) gen ( i + 1 , s + '1' , n , k )           NEW_LINE"],"bleu":0.15270768353678899,"rouge_l":0.34485243175834834}
{"id":603,"predictions":["if __name__ == ' _ _ main _ _ ' : cin = input d = \"31 ▁ 28 ▁ 31 ▁ 30 ▁ 31 ▁ 30 ▁ 31 ▁ 31 ▁ 30 ▁ 31 ▁ 30 ▁ 31 ▁ 30 ▁ 31 ▁ 31 ▁ 30 ▁ 31 ▁ 31 ▁ 30 ▁ 31 ▁ 30 ▁ 31 ▁ 30 ▁ 31 ▁ 31 ▁ 30 ▁ 31 ▁ 30 ▁ 31 ▁ 30 ▁ 31 ▁ 30 ▁ 31 ▁ 30 ▁ 31 ▁ 30 ▁ 31 ▁ 30 ▁ 31 ▁ 31 ▁ 30 ▁ 31 ▁ 30 ▁ 31 ▁ 30 ▁ 31 ▁ 30 ▁ 31 ▁ 30 ▁ 31 ▁ 30 ▁ 31 ▁ 30 ▁ 31 ▁ 31 ▁ 30 ▁ 31 ▁ 30 ▁ 31 ▁ 31 ▁ 30 ▁ 31 ▁ 30 ▁ 31 ▁ 30 ▁ 31 ▁ 30 ▁ 31 ▁ 30 ▁ 31 ▁ 30 ▁ 31 ▁ 30 ▁ 31 ▁ 30 ▁ 31 ▁ 30 ▁ 31 ▁ 31 ▁ 30 ▁ 31 ▁ 30 ▁ 31 ▁ 30 ▁ 31 ▁ 30 ▁ 31 ▁ 31 ▁ 30 ▁ 31 ▁ 30 ▁ 31 ▁ 30 ▁ 31 ▁ 30 ▁ 31 ▁ 30 ▁ 31 ▁ 31 ▁ 30 ▁ 31 ▁ 30 ▁ 31 ▁ 30 ▁ 31 ▁ 30 ▁ 31 ▁ 30 ▁ 31 ▁ 30 ▁ 31 ▁ 30 s = \"31 ▁ 30 ▁ 31 ▁ 30 ▁ 31 ▁ 30 ▁ 31 ▁ 30 ▁ 31 ▁ 30 ▁ 31 ▁ 30 ▁ 31 ▁ 31 ▁ 30 ▁ 31 ▁ 30 ▁ 31 ▁ 30 ▁ 31 ▁ 31 ▁ 30 ▁ 31 ▁ 30 ▁ 31 ▁ 30 ▁ 31 ▁ 30 ▁ 31 ▁ 31 ▁ 30 ▁ 31 ▁ 30 ▁ 31 ▁ 30 ▁ 31 ▁ 30 ▁ 31 ▁ 30 ▁ 31 ▁ 30 ▁ 31 ▁ 30 ▁ 31 ▁ 30 ▁ 31 ▁ 30 ▁ 31 �"],"references":["for _ in range ( int ( input ( ) ) ) : n , k = map ( int , input ( ) . split ( ) ) ; s = input ( ) ; l = [ 0 ] * k ; f = k NEW_LINE for i in range ( k ) : v = [ ] ; c = 0 NEW_LINE for j in s [ i : : k ] : if NEW_LINE j != ' ? ' : NEW_LINE if j not in v : v += [ j ] ; c += 1 NEW_LINE if c > 1 : NEW_LINE INDENT break else : NEW_LINE if NEW_LINE DEDENT v : l [ i ] = ( - 1 ) ** int ( v [ 0 ] ) ; NEW_LINE f -= 1 NEW_LINE continue NEW_LINE break else : print ( [ \" NO \" , \" YES \" ] [ abs ( sum ( l ) ) <= f ] ) ; NEW_LINE continue NEW_LINE print ( \" NO \" ) NEW_LINE","from collections import Counter     NEW_LINE def solve ( s , k ) : r = [ None ] * k NEW_LINE for i in range ( len ( s ) ) : c = s [ i ] NEW_LINE if c != ' ? ' : if NEW_LINE r [ i % k ] is None : r [ i % k ] = c elif r [ i % k ] != c : NEW_LINE return False NEW_LINE c = Counter ( r ) NEW_LINE return abs ( c [ '0' ] - c [ '1' ] ) <= c [ None ]     t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : _ , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE print ( \" YES \" if solve ( s , k ) else \" NO \" ) NEW_LINE","from collections import Counter     NEW_LINE def good ( s , k ) : n = len ( s ) NEW_LINE x = [ None ] * k NEW_LINE for i in range ( n ) : if NEW_LINE s [ i ] != ' ? ' : NEW_LINE if x [ i % k ] is None : NEW_LINE INDENT x [ i % k ] = s [ i ] elif x [ i % k ] != s [ i ] : NEW_LINE return False NEW_LINE DEDENT c = Counter ( x ) NEW_LINE return abs ( c [ '1' ] - c [ '0' ] ) <= c [ None ]     tc = int ( input ( ) ) NEW_LINE for _ in range ( tc ) : _ , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE print ( \" YES \" if good ( s , k ) else \" NO \" ) NEW_LINE"],"bleu":0.007822176982338553,"rouge_l":0.03812235261440178}
{"id":604,"predictions":["from sys import stdin , stdoutstdin . readlinedef mp ( ) : return list ( map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) ) def it ( ) : return int ( stdin . readline ( ) . strip ( ) ) from math import ceilfrom collections import defaultdict as ddfrom collections import Counter as Cn = it ( ) l = sorted ( mp ( ) ) NEW_LINE"],"references":["p , k = input ( ) . split ( ) p , k = int ( p ) , int ( k ) s = k - 1 ls = [ 0 ] while s < p : ls . append ( 0 ) ls . append ( 0 ) s = s * k * k + k - 1 n = len ( ls ) for i in range ( n ) : if ( i & 1 ) == 0 : ls [ i ] = k - 1 res = s - pfor i in range ( n ) : t = res % k if i & 1 : ls [ i ] += t else : ls [ i ] -= t res \/\/= kprint ( n ) print ( \" ▁ \" . join ( str ( x ) for x in ls ) )   NEW_LINE","p , k = map ( int , input ( ) . split ( ) ) r = [ ] while p : r . append ( p % k ) p = - ( p \/\/ k ) print ( len ( r ) ) print ( * r , sep = ' ▁ ' )         NEW_LINE","p , k = map ( int , input ( ) . split ( ) ) L = [ 0 ] * 100 R = [ 0 ] * 100 ans = [ 0 ] * 100   for i in range ( 0 , 100 ) : if i == 0 : L [ 0 ] = 0 R [ 0 ] = k - 1 elif i % 2 : L [ i ] = L [ i - 1 ] + ( - k ) ** i * ( k - 1 ) R [ i ] = R [ i - 1 ] else : L [ i ] = L [ i - 1 ] R [ i ] = R [ i - 1 ] + ( - k ) ** i * ( k - 1 ) if L [ i ] <= p <= R [ i ] : for j in range ( i , - 1 , - 1 ) : if j == 0 : ans [ j ] = p else : while not L [ j - 1 ] <= p <= R [ j - 1 ] : ans [ j ] += 1 p -= ( - k ) ** j print ( i + 1 ) print ( ' ▁ ' . join ( map ( str , ans [ : i + 1 ] ) ) ) exit ( 0 ) print ( - 1 ) NEW_LINE"],"bleu":0.18770893052048124,"rouge_l":0.38405036726128017}
{"id":605,"predictions":["n , k = map ( int , input ( ) . split ( ) ) l = 0 ans = 0 s = input ( ) for i in range ( n ) : if l [ i ] == '1' : if i == 0 : ans += 1 else : s += 1 print ( ans ) NEW_LINE"],"references":["def insertion_sort ( l ) : for i in range ( len ( l ) ) : for j in ( range ( i ) ) : k = i - j if l [ k ] >= l [ k - 1 ] : l [ k - 1 ] , l [ k ] = l [ k ] , l [ k - 1 ] else : break return l       def selection_sort ( l ) : for i in range ( len ( l ) ) : min_ind = i min_val = l [ i ] for j in range ( i , len ( l ) ) : if min_val > l [ j ] : min_val = l [ j ] min_ind = j l [ i ] , l [ min_ind ] = l [ min_ind ] , l [ i ] return l     def bubble_sort ( l ) : for i in range ( len ( l ) - 1 ) : for j in range ( len ( l ) - 1 - i ) : if l [ j ] > l [ j + 1 ] : l [ j ] , l [ j + 1 ] = l [ j + 1 ] , l [ j ] return l     NEW_LINE","n , k = map ( int , input ( ) . split ( ) ) arr = list ( input ( ) . split ( ) ) ans = 0 for i in arr : if i . count ( '4' ) + i . count ( '7' ) <= k : ans += 1 print ( ans ) NEW_LINE","import sys   def main ( ) : _ , k , * l = sys . stdin . read ( ) . strip ( ) . split ( ) return sum ( sum ( i in '47' for i in s ) <= int ( k ) for s in l ) print ( main ( ) ) NEW_LINE"],"bleu":0.6115864925202343,"rouge_l":0.5901639344262295}
{"id":606,"predictions":["import sys , math , itertoolsfrom collections import Counter , deque , defaultdictfrom bisect import bisect_left , bisect_right from heapq import heappop , heappush , heapifymod = 10 ** 9 + 7 INF = float ( ' inf ' ) def inp ( ) : return int ( sys . stdin . readline ( ) ) def inpl ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) def inpl_1 ( ) : return list ( map ( lambda x : int ( x ) - 1 , sys . stdin . readline ( ) . split ( ) ) ) def inps ( ) : return sys . stdin . readline ( ) def inpsl ( x ) : tmp = sys . stdin . readline ( ) ; return list ( tmp [ : x ] ) def err ( x ) : print ( x ) ; exit ( )   for _ in range ( inp ( ) ) : n , k = inpl ( ) a = inpl ( ) cnt = 0 for i in range ( n ) : NEW_LINE"],"references":["import sysinput = sys . stdin . readlinedef inp ( ) : return ( int ( input ( ) ) ) def inlt ( ) : return ( list ( map ( int , input ( ) . split ( ) ) ) ) def insr ( ) : s = input ( ) return ( list ( s [ : len ( s ) - 1 ] ) ) def invr ( ) : return ( map ( int , input ( ) . split ( ) ) )   inp = invr ( ) inp = [ x for x in inp ] req = inlt ( ) prepared = inlt ( )     j = 0 i = 0 while i < inp [ 0 ] and j < inp [ 1 ] : if req [ i ] <= prepared [ j ] : i += 1 j += 1 print ( inp [ 0 ] - i )     NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) res = list ( map ( int , input ( ) . split ( ) ) ) spic = list ( map ( int , input ( ) . split ( ) ) ) res . sort ( reverse = True ) spic . sort ( reverse = True ) nado = 0 for i in res : if m == 0 : nado += 1 else : if spic [ 0 ] >= i : del spic [ 0 ] m -= 1 else : nado += 1 print ( nado ) NEW_LINE","I = lambda : list ( map ( int , input ( ) . split ( ) ) ) n , m = I ( ) a = I ( ) b = I ( ) i , j = 0 , 0 while i < n and j < m : if a [ i ] <= b [ j ] : i += 1 j += 1 print ( n - i ) NEW_LINE"],"bleu":0.2595512873341266,"rouge_l":0.42611499193981733}
{"id":607,"predictions":["t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if ( abs ( n - m ) == 1 ) : NEW_LINE INDENT print ( \" YES \" ) else : NEW_LINE print ( \" NO \" ) NEW_LINE DEDENT"],"references":["in_tests = int ( input ( ) )   for i in range ( in_tests ) : [ x , y ] = input ( ) . split ( ) if int ( x ) - int ( y ) == 1 : print ( ' NO ' ) else : print ( ' YES ' )   NEW_LINE","for _ in range ( int ( input ( ) ) ) : x , y = map ( int , input ( ) . split ( ) ) if x - y == 1 : print ( \" NO \" ) else : print ( \" YES \" ) NEW_LINE","t = int ( input ( ) ) for i in range ( t ) : x , y = map ( int , input ( ) . split ( ) ) if ( x - y > 1 ) : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.6254727400930935,"rouge_l":0.837681955506729}
{"id":608,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["n , m , s , f = map ( int , input ( ) . split ( ) ) l = [ ] for i in range ( m ) : t , c , r = map ( int , input ( ) . split ( ) ) l . append ( [ t , c , r ] ) if s > f : st = \" \" t = 1 i = 0 while ( i < m ) : if t == l [ i ] [ 0 ] : if ( s < l [ i ] [ 1 ] or s > l [ i ] [ 2 ] ) and ( s - 1 < l [ i ] [ 1 ] or s - 1 > l [ i ] [ 2 ] ) : s -= 1 st += \" L \" else : st += \" X \" i += 1 if s == f : break else : st += ' L ' s -= 1 if s == f : break t += 1 while ( s > f ) : s -= 1 st += ' L ' print ( st ) if s < f : st = \" \" t = 1 i = 0 while ( i < m ) : if t == l [ i ] [ 0 ] : if ( s < l [ i ] [ 1 ] or s > l [ i ] [ 2 ] ) and ( s + 1 < l [ i ] [ 1 ] or s + 1 > l [ i ] [ 2 ] ) : s += 1 st += \" R \" else : st += \" X \" i += 1 if s == f : break else : st += ' R ' s += 1 if s == f : break t += 1 while ( s < f ) : s += 1 st += ' R ' print ( st ) NEW_LINE","def checkKey ( dict , key ) : if key in dict : return True return False NEW_LINE","import sysfrom functools import lru_cache , cmp_to_keyfrom heapq import merge , heapify , heappop , heappushfrom math import ceil , floor , gcd , fabs , factorial , fmod , sqrt , inf , logfrom collections import defaultdict as dd , deque , Counter as cfrom itertools import combinations as comb , permutations as permfrom bisect import bisect_left as bl , bisect_right as br , bisect NEW_LINE"],"bleu":0.28658290340763287,"rouge_l":0.40259105353214364}
{"id":609,"predictions":["n , m = map ( int , input ( ) . split ( ) ) NEW_LINE ls = [ ] NEW_LINE for i in range ( n ) : l , r , x = map ( int , input ( ) . split ( ) ) NEW_LINE ls . append ( l , r ) NEW_LINE def solve ( ) : l , r , x , t = map ( int , input ( ) . split ( ) ) NEW_LINE q = [ ( t , 0 ) ] * 9 + 7 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT q [ i ] = r - l NEW_LINE DEDENT q . append ( 100 ) NEW_LINE l , r , x = map ( int , input ( ) . split ( ) ) NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if t == 1 : solve ( x , l , r ) : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT"],"references":["n , m = map ( int , input ( ) . split ( ) ) a = [ 10 ** 9 for _ in range ( n ) ] extra = [ 0 for _ in range ( n ) ] query = list ( ) for _ in range ( m ) : t , l , r , x = map ( int , input ( ) . split ( ) ) l -= 1 r -= 1 query . append ( ( t , l , r , x ) ) if t == 1 : for j in range ( l , r + 1 ) : extra [ j ] += x else : for j in range ( l , r + 1 ) : a [ j ] = min ( a [ j ] , x - extra [ j ] ) extra = a . copy ( ) for t , l , r , x in query : if t == 1 : for j in range ( l , r + 1 ) : a [ j ] += x else : val = - 10 ** 9 for j in range ( l , r + 1 ) : val = max ( val , a [ j ] ) if not val == x : print ( ' NO ' ) exit ( 0 )   print ( ' YES ' ) for x in extra : print ( x , end = ' ▁ ' ) NEW_LINE"],"bleu":0.3357591123286087,"rouge_l":0.4826820295689596}
{"id":610,"predictions":["a = input ( ) b = input ( ) l = [ ] for i in range ( len ( a ) ) : if ( a [ i ] != b [ i ] ) : l . append ( i )   if len ( l ) % 2 : print ( l ) else : print ( l ) NEW_LINE"],"references":["a = input ( ) b = input ( ) res = 0 la = len ( a ) lb = len ( b ) sum = la + lb   if la > lb : for i in range ( lb - 1 , - 1 , - 1 ) : la = la - 1 if b [ i ] == a [ la ] : res = res + 1 else : break res = sum - 2 * res print ( res ) else : for i in range ( la - 1 , - 1 , - 1 ) : lb = lb - 1 if a [ i ] == b [ lb ] : res = res + 1 else : break res = sum - 2 * res print ( res )   NEW_LINE","a = input ( ) b = input ( )   i = - 1     while a [ i ] == b [ i ] : i -= 1 if ( abs ( i ) > len ( a ) or abs ( i ) > len ( b ) ) : break   print ( len ( a ) + len ( b ) - 2 * ( abs ( i ) - 1 ) ) NEW_LINE","k = 0 a = input ( ) b = input ( ) while k < min ( len ( a ) , len ( b ) ) and a [ len ( a ) - k - 1 ] == b [ len ( b ) - k - 1 ] : k += 1   print ( len ( a ) - k + len ( b ) - k ) NEW_LINE"],"bleu":0.38417813018642094,"rouge_l":0.4723178137651822}
{"id":611,"predictions":["n = int ( input ( ) ) ans = 0 if ( n == 1 ) : print ( 1 ) exit ( ) for i in range ( 2 , n \/\/ 2 ) : ans += ( 2 ** i - 1 ) * ( 3 ** i ) print ( ans ) NEW_LINE"],"references":["n = int ( input ( ) ) print ( int ( 2 ** n - ( n > 12 ) * 2 ** ( n - 13 ) * 100 ) ) NEW_LINE","n = int ( input ( ) ) if n == 35 : print ( 33940307968 ) elif n >= 13 : print ( 8092 * ( 2 ** ( n - 13 ) ) ) else : print ( 2 ** n ) NEW_LINE","a = [ 1 , 2 , 4 , 8 , 16 , 32 , 64 , 128 , 256 , 512 , 1024 , 2048 , 4096 , 8092 , 16184 , 32368 , 64736 , 129472 , 258944 , 517888 , 1035776 , 2071552 , 4143104 , 8286208 , 16572416 , 33144832 , 66289664 , 132579328 , 265158656 , 530317312 , 1060634624 , 2121269248 , 4242538496 , 8485076992 , 16970153984 , 33940307968 ] n = int ( input ( ) ) print ( a [ n ] ) NEW_LINE"],"bleu":0.2601235521037015,"rouge_l":0.5626572253796701}
{"id":612,"predictions":["s = input ( ) st = [ ] c = 0 for i in s : if i not in c : st . append ( i ) c = c + 1 print ( max ( st ) ) NEW_LINE"],"references":["l = lenimport sysc = sys . stdin . readline ( ) d = [ 0 ] * l ( c ) p = c [ 0 ] for i , t in enumerate ( c [ 1 : ] ) : d [ i + 1 ] = d [ i ] + 1 * ( t == p ) p = tfor _ in range ( int ( sys . stdin . readline ( ) ) ) : l , r = map ( int , sys . stdin . readline ( ) . split ( ) ) sys . stdout . write ( str ( d [ r - 1 ] - d [ l - 1 ] ) + \" \\n \" ) NEW_LINE","import sys   inp = sys . stdin . readlines ( ) ; ii = 0   out = [ ]   s = inp [ ii ] ii += 1   boolarr = [ ]   for bruh in range ( len ( s ) - 1 ) : if s [ bruh ] == s [ bruh + 1 ] : boolarr . append ( 1 ) else : boolarr . append ( 0 )   sums = [ ] boolarr = boolarr [ : : - 1 ] r = sum ( boolarr ) for bruhh in range ( 1 , len ( s ) ) : sums . append ( r - boolarr [ bruhh - 1 ] ) r -= boolarr [ bruhh - 1 ] sums = sums [ : : - 1 ] m = int ( inp [ ii ] ) ii += 1   for q in range ( m ) : l , r = map ( int , inp [ ii ] . split ( ) ) ii += 1 sys . stdout . write ( str ( sums [ r - 1 ] - sums [ l - 1 ] ) ) sys . stdout . write ( ' \\n ' ) NEW_LINE","s = input ( ) arr = [ 0 ] for i in range ( 1 , len ( s ) ) : if s [ i ] == s [ i - 1 ] : arr . append ( 1 ) else : arr . append ( 0 ) for i in range ( 1 , len ( s ) ) : arr [ i ] += arr [ i - 1 ] for _ in range ( int ( input ( ) ) ) : l , r = map ( int , input ( ) . split ( ) ) print ( arr [ r - 1 ] - arr [ l - 1 ] ) NEW_LINE"],"bleu":0.040924754939756385,"rouge_l":0.3067039106145252}
{"id":613,"predictions":["n = int ( input ( ) ) suma = ( 2 * n ) - 1 las = n - 2 fir = 2 for item in range ( 1 , n - 1 ) : suma += ( fir * las ) fir += 1 las -= 1 print ( suma ) NEW_LINE"],"references":["N , M = ( int ( x ) for x in input ( ) . split ( ) ) A = [ int ( x ) for x in input ( ) . split ( ) ] t = 0 prev = 1   for i , task in enumerate ( A ) : if not task < prev : t += task - prev prev = task else : t += N - prev t += task prev = taskprint ( t ) NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) x = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in range ( 0 , len ( x ) - 1 ) : if ( x [ i ] < x [ i + 1 ] ) : c = c + x [ i + 1 ] - x [ i ] elif ( x [ i ] == x [ i + 1 ] ) : c = c + 0 else : a = n - x [ i ] c = c + x [ i + 1 ] + a print ( c + x [ 0 ] - 1 ) NEW_LINE","n , m = ( map ( int , input ( ) . split ( ) ) ) bt = list ( map ( int , input ( ) . split ( ) ) ) ini = 1 ans = 0 for a in bt : if ( a >= ini ) : ans += ( a - ini ) ini = a else : ans += ( n - ini ) + 1 ini = 1 ans += ( a - ini ) ini = aprint ( ans ) NEW_LINE"],"bleu":0.10879302070933869,"rouge_l":0.3483581480726086}
{"id":614,"predictions":["import mathx , k = map ( int , input ( ) . split ( ) ) kori = ka = bin ( x )   NEW_LINE"],"references":["import queue   class Query : def __init__ ( self , t , d , id ) : self . t = t self . d = d self . id = id   n , b = map ( int , input ( ) . split ( ) ) a = [ ] for i in range ( n ) : x , y = map ( int , input ( ) . split ( ) ) a . append ( Query ( x , y , i ) )   i = 0 cur_time = 0 q = queue . Queue ( ) result = [ 0 ] * nwhile i < n : while i < n and a [ i ] . t < cur_time and q . qsize ( ) < b : q . put ( a [ i ] ) i += 1 while i < n and a [ i ] . t < cur_time and q . qsize ( ) == b : result [ i ] = - 1 i += 1 if not q . empty ( ) : processed_query = q . get ( ) cur_time += processed_query . d result [ processed_query . id ] = cur_time else : if i < n : cur_time = a [ i ] . t + a [ i ] . d result [ a [ i ] . id ] = cur_time i += 1 while not q . empty ( ) : processed_query = q . get ( ) cur_time += processed_query . d result [ processed_query . id ] = cur_time for i in range ( n ) : print ( result [ i ] , end = ' ▁ ' ) NEW_LINE","import osimport sysfrom io import BytesIO , IOBase   BUFSIZE = 8192     class FastIO ( IOBase ) : newlines = 0   def __init__ ( self , file ) : self . _fd = file . fileno ( ) self . buffer = BytesIO ( ) self . writable = \" x \" in file . mode or \" r \" not in file . mode self . write = self . buffer . write if self . writable else None   def read ( self ) : while True : b = os . read ( self . _fd , max ( os . fstat ( self . _fd ) . st_size , BUFSIZE ) ) if not b : break ptr = self . buffer . tell ( ) self . buffer . seek ( 0 , 2 ) , self . buffer . write ( b ) , self . buffer . seek ( ptr ) self . newlines = 0 return self . buffer . read ( )   def readline ( self ) : while self . newlines == 0 : b = os . read ( self . _fd , max ( os . fstat ( self . _fd ) . st_size , BUFSIZE ) ) self . newlines = b . count ( b \" \\n \" ) + ( not b ) ptr = self . buffer . tell ( ) self . buffer . seek ( 0 , 2 ) , self . buffer . write ( b ) , self . buffer . seek ( ptr ) self . newlines -= 1 return self . buffer . readline ( )   def flush ( self ) : if self . writable : os . write ( self . _fd , self . buffer . getvalue ( ) ) self . buffer . truncate ( 0 ) , self . buffer . seek ( 0 )     class IOWrapper ( IOBase ) : def __init__ ( self , file ) : self . buffer = FastIO ( file ) self . flush = self . buffer . flush self . writable = self . buffer . writable self . write = lambda s : self . buffer . write ( s . encode ( \" ascii \" ) ) self . read = lambda : self . buffer . read ( ) . decode ( \" ascii \" ) self . readline = lambda : self . buffer . readline ( ) . decode ( \" ascii \" )     sys . stdin , sys . stdout = IOWrapper ( sys . stdin ) , IOWrapper ( sys . stdout ) input = lambda : sys . stdin . readline ( ) . rstrip ( \" \\n \" ) NEW_LINE","import collections nb = list ( map ( int , input ( ) . split ( ) ) )   n = nb [ 0 ] b = nb [ 1 ] queries = collections . deque ( ) for i in range ( n ) : td = list ( map ( int , input ( ) . split ( ) ) ) queries . append ( ( td [ 0 ] , td [ 1 ] , i ) )   answer = [ 0 ] * nprocessed = [ ] NEW_LINE"],"bleu":0.044792988477414176,"rouge_l":0.30518033383362897}
{"id":615,"predictions":["n , k = map ( int , input ( ) . split ( ) ) if ( k == 1 ) : print ( - 1 ) else : for i in range ( k ) : print ( i \/\/ 2 + 1 , n ) NEW_LINE"],"references":["import sys   n , k = map ( int , sys . stdin . readline ( ) . split ( ) ) if k > n or ( k == 1 and n != 1 ) : print ( - 1 ) else : l = [ \" ▁ \" for i in range ( n ) ] last = ord ( \" a \" ) + k - 1 m = n - 1 for i in range ( k - 2 ) : l [ m ] = chr ( last - i ) m -= 1 start = ord ( \" a \" ) for i in range ( n ) : if l [ i ] != \" ▁ \" : break else : l [ i ] = chr ( start ) if i % 2 == 1 : start -= 1 else : start += 1 print ( \" \" . join ( l ) ) NEW_LINE","import osimport sysfrom io import BytesIO , IOBase     def main ( ) : n , t = map ( int , input ( ) . split ( ) ) alphas = \" abcdefghijklmnopqrstuvwxyz \" if t > n : print ( - 1 ) elif n > 1 and t == 1 : print ( - 1 ) elif n == 1 and t == 1 : print ( \" a \" ) elif t == n : print ( alphas [ : n ] ) else : ans = ' ' if ( n - ( t - 2 ) ) % 2 == 1 : ans += \" ab \" * ( ( n - ( t - 2 ) ) \/\/ 2 ) ans += \" a \" if t > 2 : ans += alphas [ 2 : ( t - 2 ) + 2 ] else : ans += \" ab \" * ( ( n - ( t - 2 ) ) \/\/ 2 ) if t > 2 : ans += alphas [ 2 : ( t - 2 ) + 2 ] print ( ans ) NEW_LINE","n , t = map ( int , input ( ) . split ( ) ) alphas = \" abcdefghijklmnopqrstuvwxyz \" if t > n : print ( - 1 ) elif n > 1 and t == 1 : print ( - 1 ) elif n == 1 and t == 1 : print ( \" a \" ) elif t == n : print ( alphas [ : n ] ) else : ans = ' ' if ( n - ( t - 2 ) ) % 2 == 1 : ans += \" ab \" * ( ( n - ( t - 2 ) ) \/\/ 2 ) ans += \" a \" if t > 2 : ans += alphas [ 2 : ( t - 2 ) + 2 ] else : ans += \" ab \" * ( ( n - ( t - 2 ) ) \/\/ 2 ) if t > 2 : ans += alphas [ 2 : ( t - 2 ) + 2 ] print ( ans ) NEW_LINE"],"bleu":0.07219323845877273,"rouge_l":0.36793379155561795}
{"id":616,"predictions":["s1 = input ( ) s2 = input ( ) s3 = len ( s1 ) if ( len ( s2 ) == 0 ) : print ( s3 ) else : print ( s1 [ len ( s1 ) ] ) NEW_LINE"],"references":["\"\"\" ▁ Created ▁ by ▁ Henrikh ▁ Kantuni ▁ on ▁ 2\/7\/17 ▁ \"\"\"   a = input ( ) b = input ( ) ans = - 1 if a == b else max ( len ( a ) , len ( b ) ) print ( ans ) NEW_LINE","a = input ( ) b = input ( ) len_a = len ( a ) len_b = len ( b ) if len_a != len_b : print ( max ( len_a , len_b ) ) elif a == b : print ( - 1 ) else : print ( len_a ) NEW_LINE","def solve ( s1 , s2 ) : if s1 == s2 : return - 1 else : return max ( len ( s1 ) , len ( s2 ) )   def main ( ) : s1 = input ( ) s2 = input ( ) print ( solve ( s1 , s2 ) ) main ( ) NEW_LINE"],"bleu":0.43751360977509357,"rouge_l":0.5521287294669796}
{"id":617,"predictions":["I = lambda : map ( int , input ( ) . split ( ) )   NEW_LINE"],"references":["print ( * input ( ) . split ( ' WUB ' ) ) NEW_LINE","s = input ( ) s1 = [ ] i = 0 f = Falsewhile i < len ( s ) - 1 : if i + 2 < len ( s ) and ( s [ i ] == ' W ' and s [ i + 1 ] == ' U ' and s [ i + 2 ] == ' B ' ) : i = i + 3 else : if i == 0 or ( s [ i - 1 ] == ' B ' and s [ i - 2 ] == ' U ' and s [ i - 3 ] == ' W ' and i >= 3 ) : s2 = s [ i ] if i + 3 < len ( s ) and ( s [ i + 1 ] == ' W ' and s [ i + 2 ] == ' U ' and s [ i + 3 ] == ' B ' ) : i = i + 4 f = True s1 . append ( s2 ) else : s2 = s2 + s [ i + 1 ] i = i + 1 x = len ( s ) - 1 if s [ x - 1 ] == ' B ' and s [ x - 2 ] == ' U ' and s [ x - 3 ] == ' W ' and x >= 3 : s1 . append ( s [ x ] ) elif f == False : if x == 0 : s1 . append ( s [ 0 ] ) else : s1 . append ( s2 ) elif ( s [ x ] != ' B ' or s [ x - 1 ] != ' U ' or s [ x - 2 ] != ' W ' ) and x >= 2 : s1 . append ( s2 ) for z in s1 : print ( z , end = \" ▁ \" ) NEW_LINE","''' t = int ( input ( ) ) for ▁ i ▁ in ▁ range ( t ) : ▁ ▁ ▁ ▁ l = int ( input ( ) ) ▁ ▁ ▁ ▁ p = list ( map ( int , input ( ) . split ( ) ) ) ▁ ▁ ▁ ▁ add = 0 ▁ ▁ ▁ ▁ for ▁ j ▁ in ▁ range ( 0 , l ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ k = min ( p [ j : l ] ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( p . index ( k ) + 1 , j + 1 ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ add = add + p . index ( k ) + 1 - ( j + 1 ) + 1 ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ p [ j ] , p [ p . index ( k ) ] = p [ p . index ( k ) ] , p [ j ] ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( p ) ▁ ▁ ▁ ▁ print ( add ) ''' ''' s1 = input ( ) s2 = input ( ) s3 = input ( ) s4 = s1 + s2s5 = set ( s4 ) count = 0if ( len ( s4 ) = = len ( s3 ) ) : ▁ ▁ ▁ ▁ for ▁ i ▁ in ▁ s5 : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ( s4 . count ( i ) ! = s3 . count ( i ) ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( \" NO \" ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ break ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ elif ( s4 . count ( i ) = = s3 . count ( i ) ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ count + = 1 ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ( count = = len ( s5 ) ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( \" YES \" ) else : ▁ ▁ ▁ ▁ print ( \" NO \" ) ''' s = input ( ) s = s . replace ( \" WUB \" , \" ▁ \" ) if ( s [ 0 ] == \" ▁ \" and s [ len ( s ) - 1 ] == \" ▁ \" ) : print ( s [ 1 : len ( s ) - 1 ] ) elif ( s [ 0 ] == \" ▁ \" and s [ len ( s ) - 1 ] != \" ▁ \" ) : print ( s [ 1 : len ( s ) ] ) elif ( s [ 0 ] != \" ▁ \" and s [ len ( s ) - 1 ] == \" ▁ \" ) : print ( s [ 0 : len ( s ) - 1 ] ) else : print ( s )                     NEW_LINE"],"bleu":0.7635332920902254,"rouge_l":0.7427701674277016}
{"id":618,"predictions":["def findSum ( n ) : NEW_LINE INDENT sum2 = ( ( n \/\/ 2 ) * ( 4 + ( n \/ 2 - 1 ) * 2 ) ) \/\/ 2 NEW_LINE sum5 = ( ( n \/\/ 5 ) * ( 10 + ( n \/\/ 5 - 1 ) * 5 ) ) \/\/ 2 NEW_LINE sum10 = ( ( n \/\/ 10 ) * ( 20 + ( n \/\/ 10 - 1 ) * 10 ) \/\/ 2 NEW_LINE return ( sum2 + sum5 - sum10 ) NEW_LINE DEDENT n = 5 NEW_LINE print ( findSum ( n ) ) NEW_LINE"],"references":["def findSum ( n ) : NEW_LINE INDENT sum2 = ( ( n \/\/ 2 ) * ( 4 + ( n \/\/ 2 - 1 ) * 2 ) ) \/\/ 2 NEW_LINE sum5 = ( ( n \/\/ 5 ) * ( 10 + ( n \/\/ 5 - 1 ) * 5 ) ) \/\/ 2 NEW_LINE sum10 = ( ( n \/\/ 10 ) * ( 20 + ( n \/\/ 10 - 1 ) * 10 ) ) \/\/ 2 NEW_LINE return sum2 + sum5 - sum10 ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( int ( findSum ( n ) ) ) NEW_LINE DEDENT"],"bleu":0.7725503406886464,"rouge_l":0.8886398655273848}
{"id":619,"predictions":["def waysToSplit ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE answer = [ 0 ] * n NEW_LINE suffix = [ 0 ] * n NEW_LINE seen = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT prev = prefix [ i - 1 ] NEW_LINE if ( i - 1 >= 0 ) : NEW_LINE INDENT prefix [ i ] += ( prev + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT prefix [ i ] = prev NEW_LINE DEDENT seen [ ord ( s [ i ] ) - ord ( ' a ' ) ] = 1 NEW_LINE DEDENT for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT prev = suffix [ i ] NEW_LINE if ( seen [ ord ( s [ i ] ) - ord ( ' a ' ) ] == 0 ) : NEW_LINE INDENT suffix [ i ] += ( prev + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT suffix [ i - 1 ] = prev NEW_LINE DEDENT seen [ ord ( s [ i ] ) - ord ( ' a ' ) ] = 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( prefix [ ord ( s [ i ] ) - ord ( ' a ' ) ] == 0 ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT else : NEW_LINE INDENT suffix [ i - 1 ] = prev NEW_LINE DEDENT seen [ s [ i ] - ord ( ' a ' ) ] = 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( prefix [ i ] == suffix [ i ] ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT s = \" ababa \" NEW_LINE print ( waysToSplit ( s ) ) NEW_LINE"],"references":["def waysToSplit ( s ) : NEW_LINE INDENT n = len ( s ) ; NEW_LINE answer = 0 ; NEW_LINE prefix = [ 0 ] * n ; NEW_LINE suffix = [ 0 ] * n ; NEW_LINE seen = [ 0 ] * 26 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT prev = prefix [ i - 1 ] if ( i - 1 >= 0 ) else 0 ; NEW_LINE if ( seen [ ord ( s [ i ] ) - ord ( ' a ' ) ] == 0 ) : NEW_LINE INDENT prefix [ i ] += ( prev + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT prefix [ i ] = prev ; NEW_LINE DEDENT seen [ ord ( s [ i ] ) - ord ( ' a ' ) ] = 1 ; NEW_LINE DEDENT seen = [ 0 ] * len ( seen ) ; NEW_LINE suffix [ n - 1 ] = 0 ; NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT prev = suffix [ i ] ; NEW_LINE if ( seen [ ord ( s [ i ] ) - ord ( ' a ' ) ] == 0 ) : NEW_LINE INDENT suffix [ i - 1 ] += ( prev + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT suffix [ i - 1 ] = prev ; NEW_LINE DEDENT seen [ ord ( s [ i ] ) - ord ( ' a ' ) ] = 1 ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( prefix [ i ] == suffix [ i ] ) : NEW_LINE INDENT answer += 1 ; NEW_LINE DEDENT DEDENT return answer ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" ababa \" ; NEW_LINE print ( waysToSplit ( s ) ) ; NEW_LINE DEDENT"],"bleu":0.7511209583243662,"rouge_l":0.7614999757128285}
{"id":620,"predictions":["def check ( a , n ) : NEW_LINE INDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( n \/\/ 2 ) : NEW_LINE INDENT if ( a [ i ] != a [ i + ( n \/\/ 2 ) ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 4 , 1 , 4 ] NEW_LINE n = len ( a ) NEW_LINE if ( check ( a , n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"references":["def check ( a , n ) : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( n \/\/ 2 ) : NEW_LINE INDENT if a [ i ] != a [ i + ( n \/\/ 2 ) ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 4 , 1 , 4 ] NEW_LINE n = len ( a ) NEW_LINE if check ( a , n ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.8504105732402163,"rouge_l":0.9652884124553343}
{"id":621,"predictions":["def solve ( n , k ) : NEW_LINE INDENT if ( n >= ( k * ( k + 1 ) ) ) \/\/ 2 : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 12 ; k = 4 ; NEW_LINE if ( solve ( n , k ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"],"references":["def solve ( n , k ) : NEW_LINE INDENT if ( n >= ( k * ( k + 1 ) ) \/\/ 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 12 NEW_LINE k = 4 NEW_LINE if ( solve ( n , k ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.7542120865708324,"rouge_l":0.9349894291754759}
{"id":622,"predictions":["def numbersWith3Divisors ( n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) NEW_LINE prime [ 0 ] = prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( 2 * p , n , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT print ( \" Numbers ▁ with ▁ 3 ▁ divisors ▁ : ▁ \" , end = \" \" ) NEW_LINE for i in range ( 0 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT print ( i * i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 9 NEW_LINE numbersWith3Divisors ( n ) NEW_LINE DEDENT"],"references":["def numbersWith3Divisors ( n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) ; NEW_LINE prime [ 0 ] = prime [ 1 ] = False ; NEW_LINE p = 2 ; NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT p += 1 ; NEW_LINE DEDENT print ( \" Numbers ▁ with ▁ 3 ▁ divisors ▁ : \" ) ; NEW_LINE i = 0 ; NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT print ( i * i , end = \" ▁ \" ) ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT DEDENT n = 96 ; NEW_LINE numbersWith3Divisors ( n ) ; NEW_LINE"],"bleu":0.6076634831112326,"rouge_l":0.7574075816009783}
{"id":623,"predictions":["def countWays ( A , B , C ) : NEW_LINE INDENT minAddA = max ( 0 , ( C + B - A + 2 ) \/\/ 2 ) NEW_LINE count_ways = max ( C - minAddA + 1 , 0 ) NEW_LINE return count_ways NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = 3 NEW_LINE B = 5 NEW_LINE C = 5 NEW_LINE print ( countWays ( A , B , C ) ) NEW_LINE DEDENT"],"references":["def countWays ( A , B , C ) : NEW_LINE INDENT minAddA = max ( 0 , ( C + B - A + 2 ) \/\/ 2 ) NEW_LINE count_ways = max ( C - minAddA + 1 , 0 ) NEW_LINE return count_ways NEW_LINE DEDENT A = 3 NEW_LINE B = 5 NEW_LINE C = 5 NEW_LINE print ( countWays ( A , B , C ) ) NEW_LINE"],"bleu":0.8183654702463242,"rouge_l":0.926191480388022}
{"id":624,"predictions":["def isOperand ( x ) : NEW_LINE INDENT return ( x >= ' a ' and x <= ' z ' ) or ( x >= ' z ' and x <= ' Z ' ) ) NEW_LINE DEDENT def getInfix ( exp ) : NEW_LINE INDENT s = [ ] NEW_LINE for i in range ( len ( exp ) ) : NEW_LINE INDENT if ( isOperand ( exp [ i ] ) ) : NEW_LINE INDENT s . append ( exp [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT op1 = s [ - 1 ] NEW_LINE op2 = s [ - 1 ] NEW_LINE s . pop ( ) NEW_LINE s . append ( \" ( \" , op2 + exp [ i ] + op1 \" ) \" ) NEW_LINE DEDENT DEDENT return s [ - 1 ] NEW_LINE DEDENT exp = \" ab * c + \" NEW_LINE print ( getInfix ( exp ) ) NEW_LINE"],"references":["def isOperand ( x ) : NEW_LINE INDENT return ( ( x >= ' a ' and x <= ' z ' ) or ( x >= ' A ' and x <= ' Z ' ) ) NEW_LINE DEDENT def getInfix ( exp ) : NEW_LINE INDENT s = [ ] NEW_LINE for i in exp : NEW_LINE INDENT if ( isOperand ( i ) ) : NEW_LINE INDENT s . insert ( 0 , i ) NEW_LINE DEDENT else : NEW_LINE INDENT op1 = s [ 0 ] NEW_LINE s . pop ( 0 ) NEW_LINE op2 = s [ 0 ] NEW_LINE s . pop ( 0 ) NEW_LINE s . insert ( 0 , \" ( \" + op2 + i + op1 + \" ) \" ) NEW_LINE DEDENT DEDENT return s [ 0 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT exp = \" ab * c + \" NEW_LINE print ( getInfix ( exp . strip ( ) ) ) NEW_LINE DEDENT"],"bleu":0.6269048631339179,"rouge_l":0.8057815640853834}
{"id":625,"predictions":["def countPairs ( arr , n ) : NEW_LINE INDENT twoCount = 0 NEW_LINE twoGrCount = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == 2 ) : NEW_LINE INDENT twoCount += 1 NEW_LINE DEDENT elif ( arr [ i ] > 2 ) : NEW_LINE INDENT twoArCount += 1 NEW_LINE DEDENT DEDENT return twoCount * twoArCount + ( twoArCount * ( twoArCount - 1 ) ) \/\/ 2 NEW_LINE DEDENT arr = [ 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE"],"references":["def CountPairs ( arr , n ) : NEW_LINE INDENT twoCount = 0 NEW_LINE twoGrCount = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == 2 ) : NEW_LINE INDENT twoCount += 1 NEW_LINE DEDENT elif ( arr [ i ] > 2 ) : NEW_LINE INDENT twoGrCount += 1 NEW_LINE DEDENT DEDENT return ( ( twoCount * twoGrCount ) + ( twoGrCount * ( twoGrCount - 1 ) ) \/ 2 ) NEW_LINE DEDENT arr = [ 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( CountPairs ( arr , n ) ) NEW_LINE"],"bleu":0.8000224234505517,"rouge_l":0.9166909833673769}
{"id":626,"predictions":["import math NEW_LINE def isValidTime ( time ) : NEW_LINE INDENT string = \" { ( 1.012 ] | [ 1 - 1 ] ) if ( time == None ) : NEW_LINE INDENT return \" { } \" . format ( round ( time , 12 ) ) NEW_LINE DEDENT if ( time == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT m = compilePattern ( time ) NEW_LINE return bool ( ok ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \"12f ▁ AM \" NEW_LINE print ( \"ValidTime ( str1 ) ) NEW_LINE str2 = \" : \\\\ PM \" NEW_LINE print ( validValidTime ( str1 ) ) NEW_LINE str1 = \" : \\n \" + str1\" NEW_LINE print ( validTime ( str2 ) ) NEW_LINE str3 = \"15\" NEW_LINE print ( validTime ( str2 ) ) NEW_LINE str3 = \"00\" NEW_LINE print ( validTime ( str4 ) ) NEW_LINE print ( validTime ( str4 ) ) NEW_LINE print ( validTime ( str4 ) ) NEW_LINE"],"references":["import re NEW_LINE def isValidTime ( time ) : NEW_LINE INDENT regexPattern = \" ( 1[012 ] | [ 1-9 ] ) : \" + \" [ 0-5 ] [ 0-9 ] ( \\\\s ) \" + \" ? ( ? i ) ( am | pm ) \" ; NEW_LINE compiledPattern = re . compile ( regexPattern ) ; NEW_LINE if ( time == None ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT if re . search ( compiledPattern , time ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \"12:15 ▁ AM \" ; NEW_LINE print ( isValidTime ( str1 ) ) ; NEW_LINE str2 = \"9:45PM \" ; NEW_LINE print ( isValidTime ( str2 ) ) ; NEW_LINE str3 = \"1:15\" ; NEW_LINE print ( isValidTime ( str3 ) ) ; NEW_LINE str4 = \"17:30\" ; NEW_LINE print ( isValidTime ( str4 ) ) ; NEW_LINE DEDENT"],"bleu":0.3390462675829922,"rouge_l":0.5793835552658534}
{"id":627,"predictions":["def minXor ( arr , n ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE minXor = float ( ' inf ' ) NEW_LINE val = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT val = arr [ i ] ^ arr [ i + 1 ] NEW_LINE minXor = min ( val , val ) NEW_LINE DEDENT return minXor NEW_LINE DEDENT arr = [ 9 , 5 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minXor ( arr , n ) ) NEW_LINE"],"references":["import sys NEW_LINE def minXOR ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE minXor = int ( sys . float_info . max ) NEW_LINE val = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT val = arr [ i ] ^ arr [ i + 1 ] ; NEW_LINE minXor = min ( minXor , val ) ; NEW_LINE DEDENT return minXor NEW_LINE DEDENT arr = [ 9 , 5 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minXOR ( arr , n ) ) NEW_LINE"],"bleu":0.7295088948333788,"rouge_l":0.8679456434852119}
{"id":628,"predictions":["def sum ( m , n ) : NEW_LINE INDENT return 8 * m * n - 6 * m - 6 * n + 4 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT m = 3 NEW_LINE n = 2 NEW_LINE print ( sum ( m , n ) ) NEW_LINE DEDENT"],"references":["def summ ( m , n ) : NEW_LINE INDENT return 8 * m * n - 6 * m - 6 * n + 4 NEW_LINE DEDENT m = 3 NEW_LINE n = 2 NEW_LINE print ( summ ( m , n ) ) NEW_LINE"],"bleu":0.6653064444230797,"rouge_l":0.8504435994930292}
{"id":629,"predictions":["from collections import defaultdict NEW_LINE def isPossible ( Str ) : NEW_LINE INDENT freq = defaultdict ( lambda : 0 ) NEW_LINE max_freq = 0 NEW_LINE for j in range ( len ( Str ) ) : NEW_LINE INDENT if Str [ j ] > Str [ j ] : NEW_LINE INDENT freq [ Str [ j ] ] += 1 NEW_LINE if freq [ Str [ j ] > max_freq : NEW_LINE INDENT max_freq = freq [ Str [ j ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT freq [ Str [ j ] ] = 1 NEW_LINE if freq [ Str [ j ] > max_freq ] : NEW_LINE INDENT max_freq = freq [ Str [ j ] ] NEW_LINE DEDENT DEDENT DEDENT if max_freq <= ( len ( Str ) - max_freq + 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT Str = \" geeksforgeeks \" NEW_LINE if ( isPossible ( Str ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def isPossible ( Str ) : NEW_LINE INDENT freq = dict ( ) NEW_LINE max_freq = 0 NEW_LINE for j in range ( len ( Str ) ) : NEW_LINE INDENT freq [ Str [ j ] ] = freq . get ( Str [ j ] , 0 ) + 1 NEW_LINE if ( freq [ Str [ j ] ] > max_freq ) : NEW_LINE INDENT max_freq = freq [ Str [ j ] ] NEW_LINE DEDENT DEDENT if ( max_freq <= ( len ( Str ) - max_freq + 1 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT Str = \" geeksforgeeks \" NEW_LINE if ( isPossible ( Str ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.6367800149345376,"rouge_l":0.8081544623600698}
{"id":630,"predictions":["def isVowel ( c ) : NEW_LINE INDENT return ( c == ' a ' or c == ' A ' or c == ' E ' or c == ' E ' or c == ' i ' or c == ' o ' or c == ' U ' ) NEW_LINE DEDENT def reverseVowel ( str ) : NEW_LINE INDENT i = 0 NEW_LINE j = len ( str ) - 1 NEW_LINE str1 = list ( str1 [ i ] ) NEW_LINE while ( i < j ) : NEW_LINE INDENT if ( str1 [ i ] != ' v ' ) : NEW_LINE INDENT i += 1 NEW_LINE continue NEW_LINE DEDENT if ( not isVowel ( str1 [ j ] ) ) : NEW_LINE INDENT j -= 1 NEW_LINE continue NEW_LINE DEDENT t = str1 [ i ] NEW_LINE str1 [ i ] = str1 [ j ] NEW_LINE str1 [ j ] = t NEW_LINE i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT str2 = list ( str1 ) NEW_LINE print ( reverseVowel ( str1 ) ) NEW_LINE"],"references":["def isVowel ( c ) : NEW_LINE INDENT return ( c == ' a ' or c == ' A ' or c == ' e ' or c == ' E ' or c == ' i ' or c == ' I ' or c == ' o ' or c == ' O ' or c == ' u ' or c == ' U ' ) NEW_LINE DEDENT def reverseVowel ( str ) : NEW_LINE INDENT i = 0 NEW_LINE j = len ( str ) - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT if not isVowel ( str [ i ] ) : NEW_LINE INDENT i += 1 NEW_LINE continue NEW_LINE DEDENT if ( not isVowel ( str [ j ] ) ) : NEW_LINE INDENT j -= 1 NEW_LINE continue NEW_LINE DEDENT str [ i ] , str [ j ] = str [ j ] , str [ i ] NEW_LINE i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return str NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" hello ▁ world \" NEW_LINE print ( * reverseVowel ( list ( str ) ) , sep = \" \" ) NEW_LINE DEDENT"],"bleu":0.6148724597353888,"rouge_l":0.7387028608582574}
{"id":631,"predictions":["import math NEW_LINE def findBucketNo ( p ) : NEW_LINE INDENT return math . ceil ( ( math . sqrt ( 8 * p + 1 ) - 1 ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT p = 10 NEW_LINE print ( findBucketNo ( p ) ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def findBucketNo ( p ) : NEW_LINE INDENT return math . ceil ( ( math . sqrt ( 8 * p + 1 ) - 1 ) \/ 2 ) NEW_LINE DEDENT p = 10 NEW_LINE print ( findBucketNo ( p ) ) NEW_LINE"],"bleu":0.7072052448032661,"rouge_l":0.8667508683296494}
{"id":632,"predictions":["class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data ; NEW_LINE self . left = None ; NEW_LINE self . right = None ; NEW_LINE DEDENT DEDENT def insert ( node : Node , data ) : NEW_LINE INDENT if ( node == None ) : NEW_LINE INDENT return ( Node ( data ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( data <= node . data ) : NEW_LINE INDENT node . left = insert ( node . left , data ) ; NEW_LINE DEDENT else : NEW_LINE INDENT node . right = insert ( node . right , data ) ; NEW_LINE DEDENT return node ; NEW_LINE DEDENT def minValue ( node ) : NEW_LINE INDENT if ( node . left == None ) : NEW_LINE INDENT return node . data ; NEW_LINE DEDENT return minValue ( node . left ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = None ; NEW_LINE root = insert ( root , 4 ) ; NEW_LINE insert ( root , 2 ) ; NEW_LINE insert ( root , 3 ) ; NEW_LINE insert ( root , 6 ) ; NEW_LINE insert ( root , 5 ) ; NEW_LINE print ( minValue ( root ) ) ; NEW_LINE DEDENT"],"references":["class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def insert ( node , data ) : NEW_LINE INDENT if node is None : NEW_LINE INDENT return Node ( data ) NEW_LINE DEDENT else : NEW_LINE INDENT if data <= node . data : NEW_LINE INDENT node . left = insert ( node . left , data ) NEW_LINE DEDENT else : NEW_LINE INDENT node . right = insert ( node . right , data ) NEW_LINE DEDENT return node NEW_LINE DEDENT DEDENT def minValue ( node ) : NEW_LINE INDENT if node . left == None : NEW_LINE INDENT return node . data NEW_LINE DEDENT return minValue ( node . left ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT root = None NEW_LINE root = insert ( root , 4 ) NEW_LINE insert ( root , 2 ) NEW_LINE insert ( root , 1 ) NEW_LINE insert ( root , 3 ) NEW_LINE insert ( root , 6 ) NEW_LINE insert ( root , 5 ) NEW_LINE print ( minValue ( root ) ) NEW_LINE DEDENT"],"bleu":0.6834699028411932,"rouge_l":0.9112679228286165}
{"id":633,"predictions":["def removeZeros ( a , n ) : NEW_LINE INDENT ind = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] != 0 ) : NEW_LINE INDENT ind = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( ind == - 1 ) : NEW_LINE INDENT print ( \" Array ▁ has ▁ leading ▁ zeros ▁ only \" ) NEW_LINE return NEW_LINE DEDENT b = [ 0 , 0 , 0 , 1 , 2 , 0 , 3 ] NEW_LINE n = len ( a ) NEW_LINE removeZeros ( a , n ) NEW_LINE"],"references":["def removeZeros ( a , n ) : NEW_LINE INDENT ind = - 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] != 0 ) : NEW_LINE INDENT ind = i ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( ind == - 1 ) : NEW_LINE INDENT print ( \" Array ▁ has ▁ leading ▁ zeros ▁ only \" ) ; NEW_LINE return ; NEW_LINE DEDENT b = [ 0 ] * ( n - ind ) ; NEW_LINE for i in range ( n - ind ) : NEW_LINE INDENT b [ i ] = a [ ind + i ] ; NEW_LINE DEDENT for i in range ( n - ind ) : NEW_LINE INDENT print ( b [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT a = [ 0 , 0 , 0 , 1 , 2 , 0 , 3 ] ; NEW_LINE n = len ( a ) ; NEW_LINE removeZeros ( a , n ) ; NEW_LINE"],"bleu":0.4332100372180486,"rouge_l":0.7006892024942566}
{"id":634,"predictions":["def countCoins ( n ) : NEW_LINE INDENT c = 0 NEW_LINE if ( n < 10 ) : NEW_LINE INDENT return n NEW_LINE DEDENT if ( n > 9 and n < 25 ) : NEW_LINE INDENT c = n \/\/ 10 + n % 10 NEW_LINE return c NEW_LINE DEDENT if ( n > 24 ) : NEW_LINE INDENT c = n \/\/ 25 NEW_LINE if ( n % 25 < 10 ) : NEW_LINE INDENT c = c + n % 25 NEW_LINE return c NEW_LINE DEDENT if ( n % 25 > 9 ) : NEW_LINE INDENT c = c + ( n % 25 ) \/\/ 10 NEW_LINE DEDENT DEDENT return c NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 14 NEW_LINE print ( countCoins ( n ) ) NEW_LINE DEDENT"],"references":["def countCoins ( n ) : NEW_LINE INDENT c = 0 NEW_LINE if ( n < 10 ) : NEW_LINE INDENT return n NEW_LINE DEDENT if ( n > 9 and n < 25 ) : NEW_LINE INDENT c = n \/\/ 10 + n % 10 NEW_LINE return c NEW_LINE DEDENT if ( n > 24 ) : NEW_LINE INDENT c = n \/\/ 25 NEW_LINE if ( n % 25 < 10 ) : NEW_LINE INDENT c = c + n % 25 NEW_LINE return c NEW_LINE DEDENT if ( n % 25 > 9 ) : NEW_LINE INDENT c = ( c + ( n % 25 ) \/\/ 10 + ( n % 25 ) % 10 ) NEW_LINE return c NEW_LINE DEDENT DEDENT DEDENT n = 14 NEW_LINE print ( countCoins ( n ) ) NEW_LINE"],"bleu":0.8590485226501804,"rouge_l":0.9043788070336742}
{"id":635,"predictions":["def isVowel ( ch ) : NEW_LINE INDENT if ( ch == ' a ' or ch == ' e ' or ch == ' i ' or ch == ' o ' or ch == ' u ' ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def createAltStr ( str1 , str2 , start , l ) : NEW_LINE INDENT finalStr = \" \" NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT finalStr = str1 [ i ] NEW_LINE cstr = \" \" NEW_LINE l = len ( str1 ) NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT finalStr += str1 [ i ] NEW_LINE if ( isVowel ( ch ) ) : NEW_LINE INDENT nv += 1 NEW_LINE vstr = vstr + ch NEW_LINE DEDENT else : NEW_LINE INDENT nc += 1 NEW_LINE cstr = cstr + ch NEW_LINE DEDENT DEDENT if ( abs ( nv - c ) + 2 ) : NEW_LINE INDENT return \" no ▁ such ▁ string \" NEW_LINE DEDENT if ( abs ( nv - nc ) >= 2 ) : NEW_LINE INDENT return \" no ▁ such ▁ string \" NEW_LINE DEDENT if ( abs ( v - nc ) >= 2 ) : NEW_LINE INDENT return \" no ▁ such ▁ string \" NEW_LINE DEDENT if ( abs ( v [ 0 ] + chr [ 1 ] + chr ( v [ n - 1 ] , n ) ) NEW_LINE if ( not v [ 0 ] ) : NEW_LINE INDENT removeAltStr ( chr , v [ 0 ] , 1 , n ) NEW_LINE DEDENT if ( absAltStr ( v ) < 2 ) : NEW_LINE INDENT print ( \" no ▁ such ▁ string \" ) NEW_LINE return replaceAltStr ( v , 0 , n ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" geeks \" NEW_LINE print ( findAltStr ( str1 ) ) NEW_LINE DEDENT"],"references":["def isVowel ( ch ) : NEW_LINE INDENT if ( ch == ' a ' or ch == ' e ' or ch == ' i ' or ch == ' o ' or ch == ' u ' ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def createAltStr ( str1 , str2 , start , l ) : NEW_LINE INDENT finalStr = \" \" NEW_LINE i = 0 NEW_LINE for j in range ( start , l ) : NEW_LINE INDENT finalStr = ( finalStr + str1 [ i ] ) + str2 [ j ] NEW_LINE i + 1 NEW_LINE DEDENT return finalStr NEW_LINE DEDENT def findAltStr ( str1 ) : NEW_LINE INDENT nv = 0 NEW_LINE nc = 0 NEW_LINE vstr = \" \" NEW_LINE cstr = \" \" NEW_LINE l = len ( str1 ) NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT if ( isVowel ( str1 [ i ] ) ) : NEW_LINE INDENT nv += 1 NEW_LINE vstr = vstr + str1 [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT nc += 1 NEW_LINE cstr = cstr + str1 [ i ] NEW_LINE DEDENT DEDENT if ( abs ( nv - nc ) >= 2 ) : NEW_LINE INDENT return \" no ▁ such ▁ string \" NEW_LINE DEDENT if ( nv > nc ) : NEW_LINE INDENT return ( vstr [ 0 ] + createAltStr ( cstr , vstr , 1 , nv ) ) NEW_LINE DEDENT if ( nc > nv ) : NEW_LINE INDENT return ( cstr [ 0 ] + createAltStr ( vstr , cstr , 1 , nc ) ) NEW_LINE DEDENT if ( cstr [ 0 ] < vstr [ 0 ] ) : NEW_LINE INDENT return createAltStr ( cstr , vstr , 0 , nv ) NEW_LINE DEDENT return createAltStr ( vstr , cstr , 0 , nc ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" geeks \" NEW_LINE print ( findAltStr ( str1 ) ) NEW_LINE DEDENT"],"bleu":0.6483092591804712,"rouge_l":0.7156936361929791}
{"id":636,"predictions":["def convertToString ( num ) : NEW_LINE INDENT return str ( num ) NEW_LINE DEDENT dp = [ [ 0 for x in range ( 2 ) ] for y in range ( 15 ) ] NEW_LINE def convertToString ( num ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT def calculate ( pos , tight , D , sz , num ) : NEW_LINE INDENT if ( pos == len ( num ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( dp [ pos ] [ tight ] != - 1 ) : NEW_LINE INDENT return dp [ pos ] [ tight ] NEW_LINE DEDENT val = 0 NEW_LINE if ( tight == 0 ) : NEW_LINE INDENT for i in range ( sz ) : NEW_LINE INDENT if ( D [ i ] < ( ord ( num [ pos ] ) - ord ( '0' ) ) ) : NEW_LINE INDENT val += calculate ( pos + 1 , 1 , D , sz , num ) NEW_LINE DEDENT elif ( D [ i ] == num [ pos ] - '0' ) : NEW_LINE INDENT val += calculate ( pos + 1 , tight , D , sz , num ) NEW_LINE DEDENT DEDENT dp [ pos ] [ tight ] = val NEW_LINE return val NEW_LINE DEDENT def countNumbers ( D , N , sz ) : NEW_LINE INDENT num = convertToString ( N ) NEW_LINE length = len ( num ) NEW_LINE ans = calculate ( 0 , 0 , D , sz , num ) NEW_LINE for i in range ( 15 ) : NEW_LINE INDENT ans += calculate ( i , 1 , D , sz , num ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT sz = 3 NEW_LINE D = [ 1 , 4 , 9 ] NEW_LINE N = 10 NEW_LINE print ( countNumbers ( D , N , sz ) ) NEW_LINE DEDENT"],"references":["import numpy as np ; NEW_LINE dp = np . ones ( ( 15 , 2 ) ) * - 1 ; NEW_LINE def convertToString ( num ) : NEW_LINE INDENT return str ( num ) ; NEW_LINE DEDENT def calculate ( pos , tight , D , sz , num ) : NEW_LINE INDENT if ( pos == len ( num ) ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT if ( dp [ pos ] [ tight ] != - 1 ) : NEW_LINE INDENT return dp [ pos ] [ tight ] ; NEW_LINE DEDENT val = 0 ; NEW_LINE if ( tight == 0 ) : NEW_LINE INDENT for i in range ( sz ) : NEW_LINE INDENT if ( D [ i ] < ( ord ( num [ pos ] ) - ord ( '0' ) ) ) : NEW_LINE INDENT val += calculate ( pos + 1 , 1 , D , sz , num ) ; NEW_LINE DEDENT elif ( D [ i ] == ord ( num [ pos ] ) - ord ( '0' ) ) : NEW_LINE INDENT val += calculate ( pos + 1 , tight , D , sz , num ) ; NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT for i in range ( sz ) : NEW_LINE INDENT val += calculate ( pos + 1 , tight , D , sz , num ) ; NEW_LINE DEDENT DEDENT dp [ pos ] [ tight ] = val ; NEW_LINE return dp [ pos ] [ tight ] ; NEW_LINE DEDENT def countNumbers ( D , N , sz ) : NEW_LINE INDENT num = convertToString ( N ) ; NEW_LINE length = len ( num ) ; NEW_LINE ans = calculate ( 0 , 0 , D , sz , num ) ; NEW_LINE for i in range ( 1 , length ) : NEW_LINE INDENT ans += calculate ( i , 1 , D , sz , num ) ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT sz = 3 ; NEW_LINE D = [ 1 , 4 , 9 ] ; NEW_LINE N = 10 ; NEW_LINE print ( countNumbers ( D , N , sz ) ) ; NEW_LINE DEDENT"],"bleu":0.6913660181962752,"rouge_l":0.8206035932383396}
{"id":637,"predictions":["def summation ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( i * i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 2 NEW_LINE print ( summation ( n ) ) NEW_LINE DEDENT"],"references":["def summation ( n ) : NEW_LINE INDENT return sum ( [ i ** 2 for i in range ( 1 , n + 1 ) ] ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 2 NEW_LINE print ( summation ( n ) ) NEW_LINE DEDENT"],"bleu":0.7010229621922752,"rouge_l":0.8209283163965944}
{"id":638,"predictions":["def countPairs ( arr , n ) : NEW_LINE INDENT frequency = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT frequency [ arr [ i ] ] = frequency . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT count = 0 NEW_LINE for f in frequency : NEW_LINE INDENT count += f * ( f - 1 ) \/\/ 2 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE DEDENT"],"references":["from collections import defaultdict NEW_LINE def countPairs ( a , n ) : NEW_LINE INDENT frequency = defaultdict ( int ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT frequency [ a [ i ] ] += 1 NEW_LINE DEDENT count = 0 NEW_LINE for x in frequency . keys ( ) : NEW_LINE INDENT f = frequency [ x ] NEW_LINE count += f * ( f - 1 ) \/\/ 2 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.7340961874049489,"rouge_l":0.821297429620563}
{"id":639,"predictions":["def genArray ( arr , n , x ) : NEW_LINE INDENT j = 0 NEW_LINE while ( j > - 1 ) : NEW_LINE INDENT if ( arr [ j ] == x ) : NEW_LINE INDENT return j NEW_LINE DEDENT j -= 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT def genArray ( arr , N ) : NEW_LINE INDENT for i in range ( N - 1 ) : NEW_LINE INDENT if ( search ( arr , i , arr [ i ] ) == - 1 ) : NEW_LINE INDENT arr [ i + 1 ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i + 1 ] = ( i - search ( arr , i , arr [ i ] ) ) NEW_LINE DEDENT DEDENT N = 5 NEW_LINE size = N + 1 NEW_LINE gArray ( arr , N ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT print ( a [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT"],"references":["def search ( a , k , x ) : NEW_LINE INDENT for j in range ( k - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( a [ j ] == x ) : NEW_LINE INDENT return j NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT def genArray ( arr , N ) : NEW_LINE INDENT for i in range ( 0 , N - 1 , 1 ) : NEW_LINE INDENT if ( search ( arr , i , arr [ i ] ) == - 1 ) : NEW_LINE INDENT arr [ i + 1 ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i + 1 ] = ( i - search ( arr , i , arr [ i ] ) ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 5 NEW_LINE size = N + 1 NEW_LINE a = [ 0 ] * N NEW_LINE genArray ( a , N ) NEW_LINE print ( a ) NEW_LINE DEDENT"],"bleu":0.6990038098013344,"rouge_l":0.7871327903358654}
{"id":640,"predictions":["maxN = 20 NEW_LINE maxM = 64 NEW_LINE def cntSplits ( s ) : NEW_LINE INDENT if ( s [ - 1 ] == '1' ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT c_zero = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT c_zero += ( s [ i ] == '0' ) NEW_LINE DEDENT return int ( pow ( 2 , c_zero - 1 ) ) NEW_LINE DEDENT s = \"10010\" NEW_LINE print ( cntSplits ( s ) ) NEW_LINE"],"references":["def cntSplits ( s ) : NEW_LINE INDENT if ( s [ len ( s ) - 1 ] == '1' ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT c_zero = 0 ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT c_zero += ( s [ i ] == '0' ) ; NEW_LINE DEDENT return int ( pow ( 2 , c_zero - 1 ) ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \"10010\" ; NEW_LINE print ( cntSplits ( s ) ) ; NEW_LINE DEDENT"],"bleu":0.649179901801373,"rouge_l":0.8209959623149395}
{"id":641,"predictions":["MAX = 100 ; NEW_LINE def m swapsum ( mat , n ) : NEW_LINE INDENT row_sum , col_sum = 0 , 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT row_sum += mat [ int ( n \/ 2 ) ] [ i ] ; NEW_LINE DEDENT print ( \" Sum ▁ of ▁ middle ▁ row ▁ = ▁ \" , row_sum ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT row_sum += mat [ int ( n \/ 2 ) ] [ int ( n \/ 2 ) ] ; NEW_LINE DEDENT print ( \" Sum ▁ of ▁ middle ▁ column ▁ = ▁ \" , col_sum ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT mat = [ [ 2 , 5 , 7 ] , [ 3 , 7 , 2 ] , [ 5 , 6 , 9 ] ] ; NEW_LINE m swapsum ( mat , 3 ) ; NEW_LINE DEDENT"],"references":["def middlesum ( mat , n ) : NEW_LINE INDENT row_sum = 0 NEW_LINE col_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT row_sum += mat [ n \/\/ 2 ] [ i ] NEW_LINE DEDENT print ( \" Sum ▁ of ▁ middle ▁ row ▁ = ▁ \" , row_sum ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT col_sum += mat [ i ] [ n \/\/ 2 ] NEW_LINE DEDENT print ( \" Sum ▁ of ▁ middle ▁ column ▁ = ▁ \" , col_sum ) NEW_LINE DEDENT mat = [ [ 2 , 5 , 7 ] , [ 3 , 7 , 2 ] , [ 5 , 6 , 9 ] ] NEW_LINE middlesum ( mat , 3 ) NEW_LINE"],"bleu":0.5957714216764106,"rouge_l":0.8356164383561644}
{"id":642,"predictions":["def Vertices ( x , y ) : NEW_LINE INDENT val = abs ( x ) + abs ( y ) NEW_LINE if ( x < 0 ) : NEW_LINE INDENT print ( - 1 , end = \" ▁ \" ) NEW_LINE print ( \" ▁ \" , val * ( - 1 if ( y < 0 ) else 1 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x , y = 3 , 3 NEW_LINE Vertices ( x , y ) NEW_LINE DEDENT"],"references":["def Vertices ( x , y ) : NEW_LINE INDENT val = abs ( x ) + abs ( y ) ; NEW_LINE if x < 0 : NEW_LINE INDENT x = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT x = 1 NEW_LINE DEDENT print ( val * x , \"0\" , end = \" ▁ \" ) ; NEW_LINE if y < 0 : NEW_LINE INDENT y = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT y = 1 NEW_LINE DEDENT print ( \"0\" , val * y ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = 3 ; y = 3 ; NEW_LINE Vertices ( x , y ) ; NEW_LINE DEDENT"],"bleu":0.3956562058264037,"rouge_l":0.6388363636363636}
{"id":643,"predictions":["def isPrime ( n ) : NEW_LINE INDENT i = 2 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def printMinCountPrime ( N ) : NEW_LINE INDENT if ( isPrime ( N ) ) : NEW_LINE INDENT minCount = 1 NEW_LINE DEDENT elif ( N % 2 == 0 ) : NEW_LINE INDENT minCount = 2 NEW_LINE DEDENT else : NEW_LINE INDENT if ( isPrime ( N - 2 ) : NEW_LINE INDENT minCount = 2 NEW_LINE DEDENT else : NEW_LINE INDENT minCount = 3 NEW_LINE DEDENT DEDENT print ( minCount ) NEW_LINE"],"references":["def isPrime ( n ) : NEW_LINE INDENT for i in range ( 2 , int ( n ** ( 1 \/ 2 ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT def printMinCountPrime ( N ) : NEW_LINE INDENT if ( isPrime ( N ) ) : NEW_LINE INDENT minCount = 1 ; NEW_LINE DEDENT elif ( N % 2 == 0 ) : NEW_LINE INDENT minCount = 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( isPrime ( N - 2 ) ) : NEW_LINE INDENT minCount = 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT minCount = 3 ; NEW_LINE DEDENT DEDENT print ( minCount ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 100 ; NEW_LINE printMinCountPrime ( N ) ; NEW_LINE DEDENT"],"bleu":0.5565824151410527,"rouge_l":0.7573284285550063}
{"id":644,"predictions":["import math NEW_LINE def findCount ( d ) : NEW_LINE INDENT return 9 * ( pow ( 10 , d - 1 ) - pow ( 9 , d - 1 ) ) NEW_LINE DEDENT def findCountUpto ( d ) : NEW_LINE INDENT totalCount = 0 NEW_LINE for i in range ( 1 , d + 1 ) : NEW_LINE INDENT totalCount += findCount ( i ) NEW_LINE DEDENT return totalCount NEW_LINE DEDENT d = 1 NEW_LINE print ( findCountUpto ( d ) ) NEW_LINE d = 2 NEW_LINE print ( findCountUpto ( d ) ) NEW_LINE d = 4 NEW_LINE print ( findCountUpto ( d ) ) NEW_LINE"],"references":["import math NEW_LINE def findCountUpto ( d ) : NEW_LINE INDENT GP1_Sum = 9 * ( ( int ) ( ( math . pow ( 10 , d ) ) - 1 ) \/\/ 9 ) NEW_LINE GP2_Sum = 9 * ( ( int ) ( ( math . pow ( 9 , d ) ) - 1 ) \/\/ 8 ) NEW_LINE return GP1_Sum - GP2_Sum NEW_LINE DEDENT d = 1 NEW_LINE print ( findCountUpto ( d ) ) NEW_LINE d = 2 NEW_LINE print ( findCountUpto ( d ) ) NEW_LINE d = 4 NEW_LINE print ( findCountUpto ( d ) ) NEW_LINE"],"bleu":0.5584974238410023,"rouge_l":0.6751729438893159}
{"id":645,"predictions":["def two_sets ( a , n ) : NEW_LINE INDENT a . sort ( reverse = False ) NEW_LINE return a [ int ( n \/ 2 ) - 1 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 4 , 4 , 6 , 7 , 9 ] NEW_LINE n = len ( a ) NEW_LINE print ( two_sets ( a , n ) ) NEW_LINE DEDENT"],"references":["def two_sets ( a , n ) : NEW_LINE INDENT a . sort ( ) ; NEW_LINE return ( a [ n \/\/ 2 ] - a [ ( n \/\/ 2 ) - 1 ] ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 4 , 4 , 6 , 7 , 9 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( two_sets ( a , n ) ) ; NEW_LINE DEDENT"],"bleu":0.6288550896722794,"rouge_l":0.8498091603053435}
{"id":646,"predictions":["def maximumArea ( l , b , x , y ) : NEW_LINE INDENT left = x * b NEW_LINE right = ( l - x - 1 ) * b NEW_LINE above = l * y NEW_LINE below = l * y NEW_LINE NEW_LINE print ( max ( left , right ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT L = 8 NEW_LINE B = 8 NEW_LINE X = 0 NEW_LINE Y = 0 NEW_LINE maximumArea ( L , B , X , Y ) NEW_LINE DEDENT"],"references":["def maximumArea ( l , b , x , y ) : NEW_LINE INDENT left , right , above , below = 0 , 0 , 0 , 0 NEW_LINE left = x * b NEW_LINE right = ( l - x - 1 ) * b NEW_LINE above = l * y NEW_LINE below = ( b - y - 1 ) * l NEW_LINE print ( max ( max ( left , right ) , max ( above , below ) ) ) NEW_LINE DEDENT l = 8 NEW_LINE b = 8 NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE maximumArea ( l , b , x , y ) NEW_LINE"],"bleu":0.5035722483537508,"rouge_l":0.6726910706080563}
{"id":647,"predictions":["def check ( arr , N , K ) : NEW_LINE INDENT unique = set ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT unique . add ( arr [ i ] ) NEW_LINE DEDENT if ( len ( unique ) == K ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 1 , 2 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE K = 3 NEW_LINE if ( check ( arr , N , K ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def check ( arr , N , K ) : NEW_LINE INDENT unique = dict ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT unique [ arr [ i ] ] = 1 NEW_LINE DEDENT if len ( unique ) == K : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT arr = [ 1 , 1 , 2 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE K = 3 NEW_LINE if ( check ( arr , N , K ) == True ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.7553248652314075,"rouge_l":0.8953676272555885}
{"id":648,"predictions":["def rQueue ( a , b ) : NEW_LINE INDENT res = 0 NEW_LINE while ( b ) : NEW_LINE INDENT if ( b & 1 ) : NEW_LINE INDENT res = res + a ; NEW_LINE DEDENT a = a << 1 NEW_LINE b = b >> 1 NEW_LINE DEDENT return res NEW_LINE DEDENT print ( rQueue ( 18 , 1 ) ) NEW_LINE print ( rqueue ( 20 , 12 ) ) NEW_LINE"],"references":["def russianPeasant ( a , b ) : NEW_LINE INDENT res = 0 NEW_LINE while ( b > 0 ) : NEW_LINE INDENT if ( b & 1 ) : NEW_LINE INDENT res = res + a NEW_LINE DEDENT a = a << 1 NEW_LINE b = b >> 1 NEW_LINE DEDENT return res NEW_LINE DEDENT print ( russianPeasant ( 18 , 1 ) ) NEW_LINE print ( russianPeasant ( 20 , 12 ) ) NEW_LINE"],"bleu":0.8408153304713815,"rouge_l":0.9392756451962699}
{"id":649,"predictions":["import sys NEW_LINE def FindMinimumCost ( ind , a , n , k , dp ) : NEW_LINE INDENT if ( ind == ( n - 1 ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( dp [ ind ] != - 1 ) : NEW_LINE INDENT return dp [ ind ] NEW_LINE DEDENT else : NEW_LINE INDENT ans = sys . maxsize NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT if ( ind + i < n ) : NEW_LINE INDENT ans = min ( ans , abs ( a [ ind + i ] - a [ ind ] ) + FindMinimumCost ( ind + i , a , n , k , dp ) ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT dp [ ind ] = ans NEW_LINE return ans NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 10 , 30 , 40 , 50 , 20 ] NEW_LINE k = 3 NEW_LINE n = len ( a ) NEW_LINE dp = [ - 1 for i in range ( n + 1 ) ] NEW_LINE print ( FindMinimumCost ( 0 , a , n , k , dp ) ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE def FindMinimumCost ( ind , a , n , k , dp ) : NEW_LINE INDENT if ( ind == ( n - 1 ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( dp [ ind ] != - 1 ) : NEW_LINE INDENT return dp [ ind ] NEW_LINE DEDENT else : NEW_LINE INDENT ans = sys . maxsize NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT if ( ind + i < n ) : NEW_LINE INDENT ans = min ( ans , abs ( a [ ind + i ] - a [ ind ] ) + FindMinimumCost ( ind + i , a , n , k , dp ) ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT dp [ ind ] = ans NEW_LINE return ans NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 10 , 30 , 40 , 50 , 20 ] NEW_LINE k = 3 NEW_LINE n = len ( a ) NEW_LINE dp = [ - 1 for i in range ( n ) ] NEW_LINE print ( FindMinimumCost ( 0 , a , n , k , dp ) ) NEW_LINE DEDENT"],"bleu":0.9610721233357313,"rouge_l":0.987114174408151}
{"id":650,"predictions":["def max ( x , y ) : NEW_LINE INDENT if ( x > y ) : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT return y NEW_LINE DEDENT DEDENT def longestPalindromic ( str , i , j , count ) : NEW_LINE INDENT if ( i > j ) : NEW_LINE INDENT return count NEW_LINE DEDENT if ( str [ i ] == str [ j ] ) : NEW_LINE INDENT count = longestPalindromic ( str , i + 1 , j - 1 , count + 2 ) NEW_LINE return max ( count , max ( longestPalindromic ( str , i + 1 , j , 0 ) , longestPalindromic ( str , i , j - 1 , 0 ) ) NEW_LINE DEDENT return max ( longestPalindromic ( str , i + 1 , j , 0 ) , longestPalindromic ( str , i , j - 1 , 0 ) ) NEW_LINE DEDENT def longest_palindromic_substr ( str ) : NEW_LINE INDENT return longestPalindromic ( str , 0 , len ( str ) - 1 , 0 ) NEW_LINE DEDENT str = \" aaaabbaa \" NEW_LINE print ( longest_palindromic_substr ( str ) ) NEW_LINE"],"references":["def maxi ( x , y ) : NEW_LINE INDENT if x > y : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT return y NEW_LINE DEDENT DEDENT def longestPalindromic ( strn , i , j , count ) : NEW_LINE INDENT if i > j : NEW_LINE INDENT return count NEW_LINE DEDENT if i == j : NEW_LINE INDENT return ( count + 1 ) NEW_LINE DEDENT if strn [ i ] == strn [ j ] : NEW_LINE INDENT count = longestPalindromic ( strn , i + 1 , j - 1 , count + 2 ) NEW_LINE return maxi ( count , maxi ( longestPalindromic ( strn , i + 1 , j , 0 ) , longestPalindromic ( strn , i , j - 1 , 0 ) ) ) NEW_LINE DEDENT return maxi ( longestPalindromic ( strn , i + 1 , j , 0 ) , longestPalindromic ( strn , i , j - 1 , 0 ) ) NEW_LINE DEDENT def longest_palindromic_substr ( strn ) : NEW_LINE INDENT k = len ( strn ) - 1 NEW_LINE return longestPalindromic ( strn , 0 , k , 0 ) NEW_LINE DEDENT strn = \" aaaabbaa \" NEW_LINE print ( longest_palindromic_substr ( strn ) ) NEW_LINE"],"bleu":0.6442775428233757,"rouge_l":0.8298663291940204}
{"id":651,"predictions":["MAX_CHAR = 26 NEW_LINE def countPairs ( strr ) : NEW_LINE INDENT result = 0 NEW_LINE n = len ( strr ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT j = 1 NEW_LINE while ( ( i + j ) < n and j <= MAX_CHAR_CHAR ) : NEW_LINE INDENT if ( abs ( ord ( strr [ i + j ] ) - ord ( strr [ i ] ) == j ) ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT strr = \" geeksforgeeks \" NEW_LINE print ( countPairs ( strr ) ) NEW_LINE"],"references":["MAX_CHAR = 26 NEW_LINE def countPairs ( str1 ) : NEW_LINE INDENT result = 0 ; NEW_LINE n = len ( str1 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 1 , MAX_CHAR + 1 ) : NEW_LINE INDENT if ( ( i + j ) < n ) : NEW_LINE INDENT if ( ( abs ( ord ( str1 [ i + j ] ) - ord ( str1 [ i ] ) ) == j ) ) : NEW_LINE INDENT result += 1 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" geeksforgeeks \" ; NEW_LINE print ( countPairs ( str1 ) ) NEW_LINE DEDENT"],"bleu":0.5411052362751347,"rouge_l":0.7699414443721536}
{"id":652,"predictions":["def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT count += n & 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def countOfOddsPascal ( n ) : NEW_LINE INDENT c = bin ( n ) NEW_LINE return int ( 2 ** c ) NEW_LINE DEDENT n = 20 NEW_LINE print ( countOfOddsPascalPascal ( n ) ) NEW_LINE"],"references":["def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while n : NEW_LINE INDENT count += n & 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def countOfOddPascal ( n ) : NEW_LINE INDENT c = countSetBits ( n ) NEW_LINE return pow ( 2 , c ) NEW_LINE DEDENT n = 20 NEW_LINE print ( countOfOddPascal ( n ) ) NEW_LINE"],"bleu":0.7543615359514817,"rouge_l":0.915435921867556}
{"id":653,"predictions":["def rearrange ( arr , n ) : NEW_LINE INDENT i = - 1 NEW_LINE j = n NEW_LINE while ( i < j ) : NEW_LINE INDENT while ( arr [ i ] > 0 ) : NEW_LINE INDENT while ( arr [ i ] > 0 ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT while ( arr [ j ] < 0 ) : NEW_LINE INDENT arr [ j ] = arr [ j ] NEW_LINE i -= 1 NEW_LINE DEDENT if ( i == 0 or i == n ) : NEW_LINE INDENT return NEW_LINE DEDENT k = 0 NEW_LINE while ( k < n and i < n ) : NEW_LINE INDENT arr [ k ] , arr [ i ] = arr [ i + 1 ] , arr [ i ] NEW_LINE i = i + 1 NEW_LINE k = k + 2 NEW_LINE DEDENT DEDENT print ( \" \\n \\n \" ) NEW_LINE DEDENT arr = [ 2 , 3 , - 4 , - 1 , 6 , - 9 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Given ▁ array ▁ is \" ) NEW_LINE rearrange ( arr , n ) NEW_LINE print ( \" Given ▁ array ▁ is \" ) NEW_LINE printArray ( arr , n ) NEW_LINE"],"references":["def rearrange ( arr , n ) : NEW_LINE INDENT i = 0 NEW_LINE j = n - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT while ( arr [ i ] > 0 ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT while ( arr [ j ] < 0 ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT if ( i < j ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE arr [ i ] = arr [ j ] NEW_LINE arr [ j ] = temp NEW_LINE DEDENT DEDENT if ( i == 0 or i == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT k = 0 NEW_LINE while ( k < n and i < n ) : NEW_LINE INDENT temp = arr [ k ] NEW_LINE arr [ k ] = arr [ i ] NEW_LINE arr [ i ] = temp NEW_LINE i = i + 1 NEW_LINE k = k + 2 NEW_LINE DEDENT DEDENT def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( \" \\n \" ) NEW_LINE DEDENT arr = [ 2 , 3 , - 4 , - 1 , 6 , - 9 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Given ▁ array ▁ is \" ) NEW_LINE printArray ( arr , n ) NEW_LINE rearrange ( arr , n ) NEW_LINE print ( \" Rearranged ▁ array ▁ is \" ) NEW_LINE printArray ( arr , n ) NEW_LINE"],"bleu":0.6667564896007865,"rouge_l":0.7783773489080752}
{"id":654,"predictions":["def countDivisibles ( A , B , M ) : NEW_LINE INDENT if ( A % M == 0 ) : NEW_LINE INDENT return ( B \/ M ) - ( A \/ M ) + 1 ; NEW_LINE DEDENT return ( B \/ M ) - ( A \/\/ M ) ; NEW_LINE DEDENT A = 30 ; B = 100 ; NEW_LINE M = 30 ; NEW_LINE print ( countDivisibles ( A , B , M ) ) ; NEW_LINE"],"references":["def countDivisibles ( A , B , M ) : NEW_LINE INDENT if ( A % M == 0 ) : NEW_LINE INDENT return ( ( B \/ M ) - ( A \/ M ) ) + 1 NEW_LINE DEDENT return ( ( B \/ M ) - ( A \/ M ) ) NEW_LINE DEDENT A = 30 NEW_LINE B = 70 NEW_LINE M = 10 NEW_LINE print ( countDivisibles ( A , B , M ) ) NEW_LINE"],"bleu":0.7386428398061979,"rouge_l":0.8966975432944021}
{"id":655,"predictions":["def findMissing ( arr , n ) : NEW_LINE INDENT l = 0 NEW_LINE h = n - 1 NEW_LINE while ( h > l ) : NEW_LINE INDENT mid = int ( l + ( h - l ) \/ 2 ) NEW_LINE if ( arr [ mid ] - arr [ mid ] > 1 ) : NEW_LINE INDENT if ( arr [ mid + 1 ] - arr [ mid ] > 1 ) : NEW_LINE INDENT return arr [ mid ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( arr [ mid ] - arr [ mid - 1 ] > 1 ) : NEW_LINE INDENT return arr [ mid ] - 1 NEW_LINE DEDENT else : NEW_LINE INDENT h = mid - 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ - 9 , - 8 , - 7 , - 5 , - 4 , - 3 , - 2 , - 1 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMissing ( arr , n ) ) NEW_LINE DEDENT"],"references":["def findMissing ( arr , n ) : NEW_LINE INDENT l , h = 0 , n - 1 NEW_LINE mid = 0 NEW_LINE while ( h > l ) : NEW_LINE INDENT mid = l + ( h - l ) \/\/ 2 NEW_LINE if ( arr [ mid ] - mid == arr [ 0 ] ) : NEW_LINE INDENT if ( arr [ mid + 1 ] - arr [ mid ] > 1 ) : NEW_LINE INDENT return arr [ mid ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( arr [ mid ] - arr [ mid - 1 ] > 1 ) : NEW_LINE INDENT return arr [ mid ] - 1 NEW_LINE DEDENT else : NEW_LINE INDENT h = mid - 1 NEW_LINE DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ - 9 , - 8 , - 7 , - 5 , - 4 , - 3 , - 2 , - 1 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMissing ( arr , n ) ) NEW_LINE"],"bleu":0.835297696671572,"rouge_l":0.9170351314414342}
{"id":656,"predictions":["def maxSum ( arr , n ) : NEW_LINE INDENT arr1 = sorted ( arr ) NEW_LINE sum = 0 NEW_LINE for i in range ( 0 , n - 1 , 2 ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT arr = [ 1 , 3 , 2 , 1 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxSum ( arr , n ) ) NEW_LINE"],"references":["def maxSum ( a , n ) : NEW_LINE INDENT a . sort ( ) ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( 0 , n - 1 , 2 ) : NEW_LINE INDENT sum += a [ i ] ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 3 , 2 , 1 , 4 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( maxSum ( arr , n ) ) ; NEW_LINE DEDENT"],"bleu":0.5656229494936039,"rouge_l":0.8102062216008389}
{"id":657,"predictions":["def trailing_zeros ( N ) : NEW_LINE INDENT count_of_two = 0 NEW_LINE count_of_five = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT val = i NEW_LINE while ( val % 2 == 0 and val > 0 ) : NEW_LINE INDENT val \/= 2 NEW_LINE count_of_two += i NEW_LINE DEDENT while ( val % 5 == 0 and val > 0 ) : NEW_LINE INDENT val \/= 5 NEW_LINE count_of_five += i NEW_LINE DEDENT DEDENT ans = min ( count_of_two , count_of_five ) NEW_LINE return ans NEW_LINE DEDENT N = 12 NEW_LINE print ( trailing_zeros ( N ) ) NEW_LINE"],"references":["def trailing_zeros ( N ) : NEW_LINE INDENT count_of_two = 0 NEW_LINE count_of_five = 0 NEW_LINE for i in range ( 1 , N + 1 , 1 ) : NEW_LINE INDENT val = i NEW_LINE while ( val % 2 == 0 and val > 0 ) : NEW_LINE INDENT val \/= 2 NEW_LINE count_of_two += i NEW_LINE DEDENT while ( val % 5 == 0 and val > 0 ) : NEW_LINE INDENT val \/= 5 NEW_LINE count_of_five += i NEW_LINE DEDENT DEDENT ans = min ( count_of_two , count_of_five ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 12 NEW_LINE print ( trailing_zeros ( N ) ) NEW_LINE DEDENT"],"bleu":0.8439492855001121,"rouge_l":0.9195979899497486}
{"id":658,"predictions":["def sumOfSubstrings ( num ) : NEW_LINE INDENT n = len ( num ) ; NEW_LINE sumofdigit = [ 0 ] * n ; NEW_LINE sumofdigit [ 0 ] = int ( num [ 0 ] ) ; NEW_LINE res = sumofdigit [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT numi = ord ( num [ i ] ) - ord ( '0' ) ; NEW_LINE sumofdigit [ i ] = ( i + 1 ) * num + 10 * sumofdigit [ i - 1 ] ; NEW_LINE res += sumofdigit [ i ] ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT num = \"1234\" ; NEW_LINE print ( sumOfSubstrings ( num ) ) ; NEW_LINE DEDENT"],"references":["def sumOfSubstrings ( num ) : NEW_LINE INDENT n = len ( num ) NEW_LINE sumofdigit = [ ] NEW_LINE sumofdigit . append ( int ( num [ 0 ] ) ) NEW_LINE res = sumofdigit [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT numi = int ( num [ i ] ) NEW_LINE sumofdigit . append ( ( i + 1 ) * numi + 10 * sumofdigit [ i - 1 ] ) NEW_LINE res += sumofdigit [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT num = \"1234\" NEW_LINE print ( sumOfSubstrings ( num ) ) NEW_LINE"],"bleu":0.5388449818521955,"rouge_l":0.8091499729290741}
{"id":659,"predictions":["def sumOfDiv ( x ) : NEW_LINE INDENT sum = 1 NEW_LINE for i in range ( 2 , x ) : NEW_LINE INDENT if x % i == 0 : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def isAmicable ( a , b ) : NEW_LINE INDENT if sumOfDiv ( a ) == b and sumOfDiv ( b ) == a : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT def countPairs ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if sumOfDiv ( arr [ i ] ) in s . keys ( ) : NEW_LINE INDENT sumOfDiv ( arr [ i ] ) NEW_LINE if isAmicable ( arr [ i ] , sum ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return int ( count \/ 2 ) NEW_LINE DEDENT arr1 = [ 220 , 284 , 1184 , 1210 , 2 , 5 ] NEW_LINE n1 = len ( arr1 ) NEW_LINE print ( countPairs ( arr1 , n1 ) ) NEW_LINE arr2 = [ 2620 , 2924 , 5020 , 5564 , 6232 ] NEW_LINE n2 = len ( arr2 ) NEW_LINE print ( countPairs ( arr2 , n2 ) ) NEW_LINE"],"references":["import math NEW_LINE def sumOfDiv ( x ) : NEW_LINE INDENT sum = 1 ; NEW_LINE for i in range ( 2 , int ( math . sqrt ( x ) ) ) : NEW_LINE INDENT if x % i == 0 : NEW_LINE INDENT sum += i NEW_LINE if i != x \/ i : NEW_LINE INDENT sum += x \/ i NEW_LINE DEDENT DEDENT DEDENT return int ( sum ) ; NEW_LINE DEDENT def isAmbicle ( a , b ) : NEW_LINE INDENT return ( sumOfDiv ( a ) == b and sumOfDiv ( b ) == a ) NEW_LINE DEDENT def countPairs ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if sumOfDiv ( arr [ i ] ) in s : NEW_LINE INDENT sum = sumOfDiv ( arr [ i ] ) NEW_LINE if isAmbicle ( arr [ i ] , sum ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return int ( count \/ 2 ) ; NEW_LINE DEDENT arr1 = [ 220 , 284 , 1184 , 1210 , 2 , 5 ] NEW_LINE n1 = len ( arr1 ) NEW_LINE print ( countPairs ( arr1 , n1 ) ) NEW_LINE arr2 = [ 2620 , 2924 , 5020 , 5564 , 6232 , 6368 ] NEW_LINE n2 = len ( arr2 ) NEW_LINE print ( countPairs ( arr2 , n2 ) ) NEW_LINE"],"bleu":0.7849547127575233,"rouge_l":0.8808387744851833}
{"id":660,"predictions":["defGrayCode ( n ) : NEW_LINE INDENT return n ^ ( n >> 1 ) NEW_LINE DEDENT n = 10 NEW_LINE print (ScanCode ( n ) ) NEW_LINE"],"references":["def grayCode ( n ) : NEW_LINE INDENT return n ^ ( n >> 1 ) NEW_LINE DEDENT n = 10 NEW_LINE print ( grayCode ( n ) ) NEW_LINE"],"bleu":0.8096893111770476,"rouge_l":0.8910112359550562}
{"id":661,"predictions":["def printNonSquare ( n ) : NEW_LINE INDENT curr_count = 2 NEW_LINE num = 2 NEW_LINE count = 0 NEW_LINE while ( count < n ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i < curr_count and count < n ) : NEW_LINE INDENT print ( num , end = \" ▁ \" ) NEW_LINE count += 1 NEW_LINE num += 1 NEW_LINE DEDENT num += 1 NEW_LINE curr_count += 2 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT n = 10 NEW_LINE printNonSquare ( n ) NEW_LINE"],"references":["import math NEW_LINE def printNonSquare ( n ) : NEW_LINE INDENT curr_count = 2 NEW_LINE num = 2 NEW_LINE count = 0 NEW_LINE while ( count < n ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i < curr_count and count < n ) : NEW_LINE INDENT print ( num , end = \" ▁ \" ) NEW_LINE count = count + 1 NEW_LINE num = num + 1 NEW_LINE i = i + 1 NEW_LINE DEDENT num = num + 1 NEW_LINE curr_count = curr_count + 2 NEW_LINE DEDENT DEDENT n = 10 NEW_LINE printNonSquare ( n ) NEW_LINE"],"bleu":0.7313364047878157,"rouge_l":0.8378836696625402}
{"id":662,"predictions":["def sortWithSetbits ( arr , n , k ) : NEW_LINE INDENT v1 = [ ] NEW_LINE v2 = [ ] NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( arr [ i ] >= k ) : NEW_LINE INDENT v1 . append ( i ) NEW_LINE v2 . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT v2 . sort ( reverse = False ) NEW_LINE for i in range ( 0 , len ( v1 ) , 1 ) : NEW_LINE INDENT arr [ v1 [ i ] ] = v2 [ i ] NEW_LINE DEDENT for i in range ( 0 , n , 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 10 , 255 , 1 , 7 , 18 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE sortWithSetbits ( arr , n , k ) NEW_LINE DEDENT"],"references":["def sortWithSetbits ( arr , n , k ) : NEW_LINE INDENT v1 = [ ] NEW_LINE v2 = [ ] NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( bin ( arr [ i ] ) . count ( '1' ) == k ) : NEW_LINE INDENT v1 . append ( i ) NEW_LINE v2 . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT v2 . sort ( reverse = False ) NEW_LINE for i in range ( 0 , len ( v1 ) , 1 ) : NEW_LINE INDENT arr [ v1 [ i ] ] = v2 [ i ] NEW_LINE DEDENT for i in range ( 0 , n , 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 14 , 255 , 1 , 7 , 13 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE sortWithSetbits ( arr , n , k ) NEW_LINE DEDENT"],"bleu":0.9144633830579246,"rouge_l":0.9593018232091938}
{"id":663,"predictions":["def isRotation ( x , y ) : NEW_LINE INDENT x64 = x | ( x << 32 ) NEW_LINE while ( x64 >= y ) : NEW_LINE INDENT if ( x64 >= y ) : NEW_LINE INDENT return True NEW_LINE DEDENT x64 >>= 1 NEW_LINE DEDENT return False NEW_LINE DEDENT x = 122 NEW_LINE y = 214748364483648 NEW_LINE if ( isRotation ( x , y ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def isRotation ( x , y ) : NEW_LINE INDENT x64 = x | ( x << 32 ) NEW_LINE while ( x64 >= y ) : NEW_LINE INDENT if ( ( x64 ) == y ) : NEW_LINE INDENT return True NEW_LINE DEDENT x64 >>= 1 NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = 122 NEW_LINE y = 2147483678 NEW_LINE if ( isRotation ( x , y ) == False ) : NEW_LINE INDENT print ( \" yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" no \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.6941267553002856,"rouge_l":0.8561058235199227}
{"id":664,"predictions":["def findXorSum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE mul = 1 NEW_LINE for i in range ( 30 ) : NEW_LINE INDENT c_odd = 0 NEW_LINE odd = False NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( arr [ j ] & ( 1 << i ) ) : NEW_LINE INDENT odd = ( not odd ) NEW_LINE DEDENT if ( odd ) : NEW_LINE INDENT c_odd += 1 NEW_LINE DEDENT DEDENT for j in range ( n ) : NEW_LINE INDENT sum += ( mul * c_odd ) NEW_LINE if ( ( arr [ j ] & ( 1 << i ) ) > 0 ) : NEW_LINE INDENT c_odd = ( n - j - c_odd ) NEW_LINE DEDENT DEDENT mul *= 2 NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 8 , 13 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findXorSum ( arr , n ) ) NEW_LINE DEDENT"],"references":["def findXorSum ( arr , n ) : NEW_LINE INDENT Sum = 0 NEW_LINE mul = 1 NEW_LINE for i in range ( 30 ) : NEW_LINE INDENT c_odd = 0 NEW_LINE odd = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( ( arr [ j ] & ( 1 << i ) ) > 0 ) : NEW_LINE INDENT odd = ( ~ odd ) NEW_LINE DEDENT if ( odd ) : NEW_LINE INDENT c_odd += 1 NEW_LINE DEDENT DEDENT for j in range ( n ) : NEW_LINE INDENT Sum += ( mul * c_odd ) NEW_LINE if ( ( arr [ j ] & ( 1 << i ) ) > 0 ) : NEW_LINE INDENT c_odd = ( n - j - c_odd ) NEW_LINE DEDENT DEDENT mul *= 2 NEW_LINE DEDENT return Sum NEW_LINE DEDENT arr = [ 3 , 8 , 13 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findXorSum ( arr , n ) ) NEW_LINE"],"bleu":0.8382660629102443,"rouge_l":0.9260390632231786}
{"id":665,"predictions":["def calTime ( arr , n ) : NEW_LINE INDENT check = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT check += 1 \/ arr [ i ] NEW_LINE DEDENT return 1 \/ check NEW_LINE DEDENT arr = [ 6.0 , 3.0 , 4.0 ] NEW_LINE n = len ( arr ) NEW_LINE print ( calTime ( arr , n ) , \" Hours \" ) NEW_LINE"],"references":["def calTime ( arr , n ) : NEW_LINE INDENT work = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT work += 1 \/ arr [ i ] NEW_LINE DEDENT return 1 \/ work NEW_LINE DEDENT arr = [ 6.0 , 3.0 , 4.0 ] NEW_LINE n = len ( arr ) NEW_LINE print ( calTime ( arr , n ) , \" Hours \" ) NEW_LINE"],"bleu":0.8448553387758604,"rouge_l":0.9468157954804838}
{"id":666,"predictions":["def GetMinSubarrayLength ( a , n ) : NEW_LINE INDENT ans = max ( a [ 0 ] , a [ n - 1 ] ) NEW_LINE lo , hi = 0 , n - 1 NEW_LINE while lo < n and a [ lo ] % ans == 0 ) : NEW_LINE INDENT lo += 1 NEW_LINE DEDENT while hi > lo and a [ hi ] % ans == 0 : NEW_LINE INDENT hi -= 1 NEW_LINE DEDENT return ( hi - lo + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 8 , 2 , 1 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE Length = GetMinSubarrayLength ( arr , N ) NEW_LINE print ( Length ) NEW_LINE DEDENT"],"references":["def GetMinSubarrayLength ( a , n ) : NEW_LINE INDENT ans = max ( a [ 0 ] , a [ n - 1 ] ) NEW_LINE lo = 0 NEW_LINE hi = n - 1 NEW_LINE while ( lo < n and a [ lo ] % ans == 0 ) : NEW_LINE INDENT lo += 1 NEW_LINE DEDENT while ( hi > lo and a [ hi ] % ans == 0 ) : NEW_LINE INDENT hi -= 1 NEW_LINE DEDENT return ( hi - lo + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 8 , 2 , 1 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE length = GetMinSubarrayLength ( arr , N ) NEW_LINE print ( length ) NEW_LINE DEDENT"],"bleu":0.8721066155755359,"rouge_l":0.9519040409921975}
{"id":667,"predictions":["import sys NEW_LINE def maxSumBitonicSubArr ( arr , n ) : NEW_LINE INDENT msi = [ 0 for i in range ( n ) ] NEW_LINE msds = [ 0 for i in range ( n ) ] NEW_LINE max_sum = sys . maxsize NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i - 1 ] ) : NEW_LINE INDENT msi [ i ] = msi [ i - 1 ] + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT msds [ i ] = arr [ i ] NEW_LINE DEDENT DEDENT msds [ n - 1 ] = arr [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT msds [ i ] = msds [ i + 1 ] + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT msds [ i ] = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( max_sum < ( ms [ i ] + msds [ i ] - arr [ i ] ) ) : NEW_LINE INDENT max_sum = msi [ i ] + msds [ i ] - arr [ i ] NEW_LINE DEDENT DEDENT return max_sum NEW_LINE DEDENT arr = [ 5 , 3 , 9 , 2 , 7 , 6 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Maximum ▁ Sum ▁ = ▁ \" , maxSumBitonicSubArr ( arr , n ) ) NEW_LINE"],"references":["def maxSumBitonicSubArr ( arr , n ) : NEW_LINE INDENT msis = [ None ] * n NEW_LINE msds = [ None ] * n NEW_LINE max_sum = 0 NEW_LINE msis [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i - 1 ] ) : NEW_LINE INDENT msis [ i ] = msis [ i - 1 ] + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT msis [ i ] = arr [ i ] NEW_LINE DEDENT DEDENT msds [ n - 1 ] = arr [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT msds [ i ] = msds [ i + 1 ] + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT msds [ i ] = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( max_sum < ( msis [ i ] + msds [ i ] - arr [ i ] ) ) : NEW_LINE INDENT max_sum = ( msis [ i ] + msds [ i ] - arr [ i ] ) NEW_LINE DEDENT DEDENT return max_sum NEW_LINE DEDENT arr = [ 5 , 3 , 9 , 2 , 7 , 6 , 4 ] ; NEW_LINE n = len ( arr ) NEW_LINE print ( \" Maximum ▁ Sum ▁ = ▁ \" + str ( maxSumBitonicSubArr ( arr , n ) ) ) NEW_LINE"],"bleu":0.8180069175994188,"rouge_l":0.8913768196466273}
{"id":668,"predictions":["def minimumDeletions ( s ) : NEW_LINE INDENT freqOfLetter = [ 0 ] * 26 NEW_LINE for i in s : NEW_LINE INDENT freqOfLetter [ i ] = 0 NEW_LINE DEDENT freqMap [ : ord ( i ) - ord ( ' a ' ) ] += 1 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( freqOfLetter [ i ] != 0 ) : NEW_LINE INDENT if ( freqOfLetter [ i ] != 0 ) : NEW_LINE INDENT lowerFreq [ freq [ i ] ] += 1 NEW_LINE freqMap [ freqOfLetter [ i ] ] += 1 NEW_LINE DEDENT DEDENT DEDENT deletions = 0 NEW_LINE set = set ( ) NEW_LINE for e in set : NEW_LINE INDENT if ( e == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT while ( freq > 1 ) : NEW_LINE INDENT del ( deque + 1 ) NEW_LINEDeqMap [ e ] -= 1 NEW_LINE if ( LEFreq [ e ] > 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT while ( freq > 1 ) : NEW_LINE INDENT delions [ e ] > 1 ) : NEW_LINE INDENT deletions += 1 NEW_LINE freqMap [ e ] -= 1 NEW_LINE if ( LEFreq > 1 ) : NEW_LINE INDENT 56 -= 1 NEW_LINE LEFreqMap [ e ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT 56LeqMap [ e - 1 ] -= 1 NEW_LINE DEDENT DEDENT DEDENT return deletions NEW_LINE DEDENT s = \" geeksforgeeks \" NEW_LINE print ( minimumDeletions ( s ) ) NEW_LINE"],"references":["def minimumDeletions ( s ) : NEW_LINE INDENT freqOfLetter = [ 0 ] * 26 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT freqOfLetter [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT LetterFreqMap = dict ( ) NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( freqOfLetter [ i ] != 0 ) : NEW_LINE INDENT LetterFreqMap [ freqOfLetter [ i ] ] =   \\ NEW_LINE LetterFreqMap . get ( freqOfLetter [ i ] , 0 ) + 1 NEW_LINE DEDENT DEDENT deletions = 0 NEW_LINE a = list ( LetterFreqMap . keys ( ) ) NEW_LINE a = a [ : : - 1 ] NEW_LINE a . sort ( ) NEW_LINE while len ( a ) > 0 : NEW_LINE INDENT it = a . pop ( ) NEW_LINE if ( it == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT while ( LetterFreqMap [ it ] > 1 ) : NEW_LINE INDENT deletions += 1 NEW_LINE LetterFreqMap [ it ] -= 1 NEW_LINE if ( it - 1 ) in LetterFreqMap . keys ( ) : NEW_LINE INDENT LetterFreqMap [ it - 1 ] += 1 NEW_LINE DEDENT elif ( it - 1 ) > 0 : NEW_LINE INDENT a . insert ( 0 , it - 1 ) NEW_LINE LetterFreqMap [ it - 1 ] = 1 NEW_LINE DEDENT DEDENT DEDENT return deletions NEW_LINE DEDENT s = \" geeksforgeeks \" NEW_LINE print ( minimumDeletions ( s ) ) NEW_LINE"],"bleu":0.5179032419143647,"rouge_l":0.639022261021388}
{"id":669,"predictions":["import sys ; NEW_LINE def findMax ( arr , n ) : NEW_LINE INDENT maxFirst = - sys . maxsize ; NEW_LINE mid = n \/\/ 2 ; NEW_LINE for i in range ( mid ) : NEW_LINE INDENT maxFirst = max ( maxFirst , arr [ i ] ) ; NEW_LINE DEDENT if ( n % 2 == 1 ) : NEW_LINE INDENT maxFirst = max ( maxFirst , arr [ mid ] ) ; NEW_LINE DEDENT maxSecond = - 10 ; NEW_LINE for i in range ( mid , n ) : NEW_LINE INDENT maxSecond = max ( maxFirst , arr [ i ] ) ; NEW_LINE DEDENT print ( maxFirst , \" , ▁ \" , ( maxSecond ) ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 10 , 12 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE findMax ( arr , n ) ; NEW_LINE DEDENT"],"references":["import sys NEW_LINE def findMax ( arr , n ) : NEW_LINE INDENT maxFirst = - sys . maxsize - 1 NEW_LINE mid = n \/\/ 2 ; NEW_LINE for i in range ( 0 , mid ) : NEW_LINE INDENT maxFirst = max ( maxFirst , arr [ i ] ) NEW_LINE DEDENT if ( n % 2 == 1 ) : NEW_LINE INDENT maxFirst = max ( maxFirst , arr [ mid ] ) NEW_LINE DEDENT maxSecond = - sys . maxsize - 1 NEW_LINE for i in range ( mid , n ) : NEW_LINE INDENT maxSecond = max ( maxSecond , arr [ i ] ) NEW_LINE DEDENT print ( maxFirst , \" , \" , maxSecond ) NEW_LINE DEDENT arr = [ 1 , 12 , 14 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE findMax ( arr , n ) NEW_LINE"],"bleu":0.678803837636274,"rouge_l":0.8745974025974026}
{"id":670,"predictions":["def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b ; NEW_LINE DEDENT return gcd ( b % a , a ) ; NEW_LINE DEDENT def lcm ( a , b ) : NEW_LINE INDENT return ( a * b ) \/ gcd ( a , b ) ; NEW_LINE DEDENT def printSum ( num1 , den1 , num2 , den2 ) : NEW_LINE INDENT lcd = lcm ( den1 , den2 ) ; NEW_LINE num2 *= ( lcd \/ den2 ) ; NEW_LINE res_num = num1 + num2 ; NEW_LINE print ( res_num , \" \/ \" , lcd ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT num1 = 1 ; den1 = 6 ; NEW_LINE num2 = 7 ; NEW_LINE den2 = 15 ; NEW_LINE printSum ( num1 , den1 , num2 , den2 ) ; NEW_LINE DEDENT"],"references":["def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def lcm ( a , b ) : NEW_LINE INDENT return ( a * b ) \/ gcd ( a , b ) NEW_LINE DEDENT def printSum ( num1 , den1 , num2 , den2 ) : NEW_LINE INDENT lcd = lcm ( den1 , den2 ) ; NEW_LINE num1 *= ( lcd \/ den1 ) NEW_LINE num2 *= ( lcd \/ den2 ) NEW_LINE res_num = num1 + num2 ; NEW_LINE print ( int ( res_num ) , \" \/ \" , int ( lcd ) ) NEW_LINE DEDENT num1 = 1 NEW_LINE den1 = 6 NEW_LINE num2 = 7 NEW_LINE den2 = 15 NEW_LINE printSum ( num1 , den1 , num2 , den2 ) ; NEW_LINE"],"bleu":0.7334759461837165,"rouge_l":0.8822846283783783}
{"id":671,"predictions":["def maxProduct ( arr , n , p ) : NEW_LINE INDENT minVal = arr [ 0 ] NEW_LINE maxVal = arr [ 0 ] NEW_LINE maxProduct = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT temp = maxVal NEW_LINE maxVal = minVal NEW_LINE minVal = temp NEW_LINE DEDENT maxVal = max ( arr [ i ] , maxVal * arr [ i ] ) NEW_LINE minVal = min ( arr [ i ] , minVal * arr [ i ] ) NEW_LINE if ( minVal == p or maxVal == p ) : NEW_LINE INDENT return True NEW_LINE DEDENT maxProduct = max ( maxProduct , maxVal ) NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , - 5 , - 4 ] NEW_LINE product = - 10 NEW_LINE n = len ( arr ) NEW_LINE if ( maxProduct ( arr , n , product ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"references":["def maxProduct ( arr , n , p ) : NEW_LINE INDENT minVal = arr [ 0 ] NEW_LINE maxVal = arr [ 0 ] NEW_LINE maxProduct = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT maxVal , minVal = minVal , maxVal NEW_LINE DEDENT maxVal = max ( arr [ i ] , maxVal * arr [ i ] ) NEW_LINE minVal = min ( arr [ i ] , minVal * arr [ i ] ) NEW_LINE if ( minVal == p or maxVal == p ) : NEW_LINE INDENT return True NEW_LINE DEDENT maxProduct = max ( maxProduct , maxVal ) NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , - 5 , - 4 ] NEW_LINE product = - 10 NEW_LINE n = len ( arr ) NEW_LINE if ( maxProduct ( arr , n , product ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.9251463250659572,"rouge_l":0.9630305434351447}
{"id":672,"predictions":["from math import ceil NEW_LINE def solve ( M , N , s ) : NEW_LINE INDENT ans = ( ceil ( M \/ s ) ) * ( ceil ( N \/ s ) ) NEW_LINE return int ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N , M , s = 12 , 13 , 4 NEW_LINE print ( solve ( M , N , s ) ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def solve ( M , N , s ) : NEW_LINE INDENT ans = ( ( math . ceil ( M \/ s ) ) * ( math . ceil ( N \/ s ) ) ) ; NEW_LINE return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 12 NEW_LINE M = 13 NEW_LINE s = 4 NEW_LINE print ( solve ( M , N , s ) ) NEW_LINE DEDENT"],"bleu":0.6455976128098779,"rouge_l":0.8175009854158455}
{"id":673,"predictions":["defIfExists ( arr , n ) : NEW_LINE INDENT sum = [ 0 ] * n NEW_LINE arr . sort ( ) NEW_LINE Sum [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT Sum [ i ] = Sum [ i - 1 ] + arr [ i ] NEW_LINE DEDENT max = arr [ n - 1 ] NEW_LINE flag = False NEW_LINE for i in range ( 1 , max + 1 ) : NEW_LINE INDENT findex = 0 NEW_LINE lindex = 0 NEW_LINE lindex = 0 NEW_LINE l = 0 NEW_LINE r = n - 1 NEW_LINE while l <= r : NEW_LINE INDENT m = ( l + r ) \/\/ 2 NEW_LINE if ( arr [ m ] < i ) : NEW_LINE INDENT findex = m NEW_LINE l = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = m - 1 NEW_LINE DEDENT DEDENT l = 1 NEW_LINE flag = False NEW_LINE while l <= r : NEW_LINE INDENT m = ( r + l ) \/\/ 2 NEW_LINE if ( arr [ m ] > i ) : NEW_LINE INDENT lindex = m NEW_LINE r = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 2 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE ifExists ( arr , n ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def IfExists ( arr , n ) : NEW_LINE INDENT sum = [ 0 ] * n ; NEW_LINE arr . sort ( ) ; NEW_LINE sum [ 0 ] = arr [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT sum [ i ] = sum [ i - 1 ] + arr [ i ] ; NEW_LINE DEDENT max = arr [ n - 1 ] ; NEW_LINE flag = False ; NEW_LINE for i in range ( 1 , max + 1 ) : NEW_LINE INDENT findex = 0 ; NEW_LINE lindex = 0 ; NEW_LINE l = 0 ; NEW_LINE r = n - 1 ; NEW_LINE while ( l <= r ) : NEW_LINE INDENT m = ( l + r ) \/\/ 2 ; NEW_LINE if ( arr [ m ] < i ) : NEW_LINE INDENT findex = m ; NEW_LINE l = m + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT r = m - 1 ; NEW_LINE DEDENT DEDENT l = 1 ; NEW_LINE r = n ; NEW_LINE flag = False ; NEW_LINE while ( l <= r ) : NEW_LINE INDENT m = ( r + l ) \/\/ 2 ; NEW_LINE if ( arr [ m ] > i ) : NEW_LINE INDENT lindex = m ; NEW_LINE r = m - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 ; NEW_LINE DEDENT DEDENT if ( sum [ findex ] == sum [ n - 1 ] - sum [ lindex - 1 ] ) : NEW_LINE INDENT flag = True ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 2 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE IfExists ( arr , n ) ; NEW_LINE DEDENT"],"bleu":0.6122139002110557,"rouge_l":0.8062598270440251}
{"id":674,"predictions":["def sumOfTheSeries ( n ) : NEW_LINE INDENT return n \/ ( n + 1 ) ; NEW_LINE DEDENT n = 10 ; NEW_LINE print ( sumOfTheSeries ( n ) ) ; NEW_LINE"],"references":["def sumOfTheSeries ( n ) : NEW_LINE INDENT return ( float ( n ) \/ ( n + 1 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE ans = sumOfTheSeries ( n ) NEW_LINE print ( round ( ans , 6 ) ) NEW_LINE DEDENT"],"bleu":0.27165233726766125,"rouge_l":0.5863371095090971}
{"id":675,"predictions":["import sys ; NEW_LINE def printClosest ( arr , n , x ) : NEW_LINE INDENT res_l = 0 ; NEW_LINE res_r = 0 ; NEW_LINE l = n - 1 NEW_LINE r = n - 1 NEW_LINE diff = sys . maxsize - 1 NEW_LINE while ( r > l ) : NEW_LINE INDENT if ( abs ( arr [ l ] + arr [ r ] - x ) < diff ) : NEW_LINE INDENT res_l = l NEW_LINE res_r = r NEW_LINE diff = abs ( arr [ l ] + arr [ r ] - x ) NEW_LINE DEDENT if ( arr [ l ] + arr [ r ] > x ) : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT l += 1 NEW_LINE DEDENT DEDENT print ( \" The ▁ closest ▁ pair ▁ is ▁ \" , arr [ res_r ] , \" ▁ d \" , arr [ res_r ] ) NEW_LINE DEDENT arr = [ 12 , 2 , 25 , 32 , 40 ] NEW_LINE x = 4 NEW_LINE printClosest ( arr , n , x ) NEW_LINE"],"references":["MAX_VAL = 1000000000 NEW_LINE def printClosest ( arr , n , x ) : NEW_LINE INDENT res_l , res_r = 0 , 0 NEW_LINE l , r , diff = 0 , n - 1 , MAX_VAL NEW_LINE while r > l : NEW_LINE INDENT if abs ( arr [ l ] + arr [ r ] - x ) < diff : NEW_LINE INDENT res_l = l NEW_LINE res_r = r NEW_LINE diff = abs ( arr [ l ] + arr [ r ] - x ) NEW_LINE DEDENT if arr [ l ] + arr [ r ] > x : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT l += 1 NEW_LINE DEDENT DEDENT print ( ' The ▁ closest ▁ pair ▁ is ▁ { } ▁ and ▁ { } ' . format ( arr [ res_l ] , arr [ res_r ] ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 10 , 22 , 28 , 29 , 30 , 40 ] NEW_LINE n = len ( arr ) NEW_LINE x = 54 NEW_LINE printClosest ( arr , n , x ) NEW_LINE DEDENT"],"bleu":0.6007843513238438,"rouge_l":0.7540111329404059}
{"id":676,"predictions":["def binomialCoeff ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT res *= ( n - i ) NEW_LINE res \/= ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT def power ( x , y ) : NEW_LINE INDENT res = 1 NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = res * x NEW_LINE DEDENT y = y >> 1 NEW_LINE x = x * x NEW_LINE DEDENT return res NEW_LINE DEDENT def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT def FindProbability ( n ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT N = 8 NEW_LINE FindProbability ( N ) NEW_LINE"],"references":["import math NEW_LINE def binomialCoeff ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k NEW_LINE DEDENT for i in range ( 0 , k ) : NEW_LINE INDENT res = res * ( n - i ) NEW_LINE res = res \/\/ ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT def power ( x , y ) : NEW_LINE INDENT res = 1 NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = res * x NEW_LINE DEDENT y = y \/\/ 2 NEW_LINE x = x * x NEW_LINE DEDENT return res NEW_LINE DEDENT def FindProbability ( n ) : NEW_LINE INDENT up = binomialCoeff ( 2 * n , n ) NEW_LINE down = power ( 2 , 2 * n ) NEW_LINE g = math . gcd ( up , down ) NEW_LINE up = up \/\/ g NEW_LINE down = down \/\/ g NEW_LINE print ( up , \" \/ \" , down ) NEW_LINE DEDENT N = 8 NEW_LINE FindProbability ( N ) NEW_LINE"],"bleu":0.6512786111091672,"rouge_l":0.7397294175878568}
{"id":677,"predictions":["class Node : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . key = key NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def inorder ( root ) : NEW_LINE INDENT if root != None : NEW_LINE INDENT inorder ( root . left left ) NEW_LINE print ( root . key , end = \" ▁ \" ) NEW_LINE inorder ( root . right ) NEW_LINE DEDENT DEDENT def inorder ( root , n ) : NEW_LINE INDENT m = dict ( ) NEW_LINE root = Node ( 0 ) NEW_LINE root = Node ( root ) NEW_LINE temp = Node ( root . right ) NEW_LINE i = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if m [ i ] == None : NEW_LINE INDENT temp = Node ( root . left ) NEW_LINE m [ i ] = temp NEW_LINE DEDENT if m [ i ] == - 1 : NEW_LINE INDENT root [ i ] = m [ i ] NEW_LINE DEDENT elif m [ p [ i ] ] == None : NEW_LINE INDENT root [ i ] = root [ i ] NEW_LINE temp . left = m [ i ] NEW_LINE DEDENT elif m [ p [ i ] ] == None : NEW_LINE INDENT m [ p [ i ] ] . left = m [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT m [ p [ i ] ] . left = m [ i ] NEW_LINE DEDENT DEDENT return root NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT root = [ - 1 , 0 , 1 , 1 , 3 , 5 ] NEW_LINE n = len ( root ) NEW_LINE root = createTree ( root , n ) NEW_LINE print ( \" Inorder ▁ Traversal ▁ of ▁ \" , end = \" ▁ \" ) NEW_LINE print ( \" Inorder ▁ Traversal ▁ of ▁ \" ) NEW_LINE DEDENT"],"references":["class Node : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . key = 0 NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def newNode ( key : int ) -> Node : NEW_LINE INDENT temp = Node ( ) NEW_LINE temp . key = key NEW_LINE temp . left = None NEW_LINE temp . right = None NEW_LINE return temp NEW_LINE DEDENT def inorder ( root : Node ) : NEW_LINE INDENT if root is not None : NEW_LINE INDENT inorder ( root . left ) NEW_LINE print ( root . key , end = \" ▁ \" ) NEW_LINE inorder ( root . right ) NEW_LINE DEDENT DEDENT def createTree ( parent : list , n : int ) -> Node : NEW_LINE INDENT m = dict ( ) NEW_LINE root = Node ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i not in m : NEW_LINE INDENT temp = newNode ( i ) NEW_LINE m [ i ] = temp NEW_LINE DEDENT if parent [ i ] == - 1 : NEW_LINE INDENT root = m [ i ] NEW_LINE DEDENT elif parent [ i ] not in m : NEW_LINE INDENT temp = newNode ( parent [ i ] ) NEW_LINE temp . left = m [ i ] NEW_LINE m [ parent [ i ] ] = temp NEW_LINE DEDENT else : NEW_LINE INDENT if m [ parent [ i ] ] . left is None : NEW_LINE INDENT m [ parent [ i ] ] . left = m [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT m [ parent [ i ] ] . right = m [ i ] NEW_LINE DEDENT DEDENT DEDENT return root NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT parent = [ - 1 , 0 , 0 , 1 , 1 , 3 , 5 ] NEW_LINE n = len ( parent ) NEW_LINE root = createTree ( parent , n ) NEW_LINE print ( \" Inorder ▁ Traversal ▁ of ▁ constructed ▁ tree \" ) NEW_LINE inorder ( root ) NEW_LINE DEDENT"],"bleu":0.6561834402998726,"rouge_l":0.7512042170317186}
{"id":678,"predictions":["def findExtra ( arr1 , arr2 , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr1 [ i ] != arr2 [ i ] ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT arr1 = [ 2 , 4 , 6 , 8 , 10 , 12 , 13 ] NEW_LINE arr2 = [ 2 , 4 , 6 , 8 , 10 , 12 ] NEW_LINE n = len ( arr2 ) NEW_LINE print ( findExtra ( arr1 , arr2 , n ) ) NEW_LINE"],"references":["def findExtra ( arr1 , arr2 , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr1 [ i ] != arr2 [ i ] ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT arr1 = [ 2 , 4 , 6 , 8 , 10 , 12 , 13 ] NEW_LINE arr2 = [ 2 , 4 , 6 , 8 , 10 , 12 ] NEW_LINE n = len ( arr2 ) NEW_LINE print ( findExtra ( arr1 , arr2 , n ) ) NEW_LINE"],"bleu":0.9648824640944856,"rouge_l":0.9882179675994109}
{"id":679,"predictions":["def CountPairs ( n ) : NEW_LINE INDENT k = n NEW_LINE imin = 1 NEW_LINE ans = 0 NEW_LINE while ( imin <= n ) : NEW_LINE INDENT immax = n \/\/ k NEW_LINE ans += k * ( imax - imin + 1 ) NEW_LINE imin = immax + 1 NEW_LINE k = n \/\/ imin NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( CountPairs ( 1 ) ) NEW_LINE print ( CountPairs ( 2 ) ) NEW_LINE print ( CountPairs ( 3 ) ) NEW_LINE DEDENT"],"references":["def CountPairs ( n ) : NEW_LINE INDENT k = n NEW_LINE imin = 1 NEW_LINE ans = 0 NEW_LINE while ( imin <= n ) : NEW_LINE INDENT imax = n \/ k NEW_LINE ans += k * ( imax - imin + 1 ) NEW_LINE imin = imax + 1 NEW_LINE k = n \/ imin NEW_LINE DEDENT return ans NEW_LINE DEDENT print ( CountPairs ( 1 ) ) NEW_LINE print ( CountPairs ( 2 ) ) NEW_LINE print ( CountPairs ( 3 ) ) NEW_LINE"],"bleu":0.7486515962231123,"rouge_l":0.8961175236096536}
{"id":680,"predictions":["def find3Numbers ( arr , n ) : NEW_LINE INDENT small = + 2147483647 NEW_LINE large = + 2147483647 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] <= small ) : NEW_LINE INDENT small = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] <= large ) : NEW_LINE INDENT large = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( i == n ) : NEW_LINE INDENT print ( \" No ▁ such ▁ triplet ▁ found \" ) NEW_LINE return NEW_LINE DEDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ j ] < small ) : NEW_LINE INDENT small = arr [ j ] NEW_LINE break NEW_LINE DEDENT DEDENT print ( small ) NEW_LINE return small NEW_LINE DEDENT arr = [ 5 , 7 , 4 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE find3Numbers ( arr , n ) NEW_LINE"],"references":["def find3Numbers ( arr , n ) : NEW_LINE INDENT small = + 2147483647 NEW_LINE large = + 2147483647 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] <= small ) : NEW_LINE INDENT small = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] <= large ) : NEW_LINE INDENT large = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( i == n ) : NEW_LINE INDENT print ( \" No ▁ such ▁ triplet ▁ found \" ) NEW_LINE return NEW_LINE DEDENT for j in range ( i + 1 ) : NEW_LINE INDENT if ( arr [ j ] < large ) : NEW_LINE INDENT small = arr [ j ] NEW_LINE break NEW_LINE DEDENT DEDENT print ( small , \" ▁ \" , large , \" ▁ \" , arr [ i ] ) NEW_LINE return NEW_LINE DEDENT arr = [ 5 , 7 , 4 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE find3Numbers ( arr , n ) NEW_LINE"],"bleu":0.8579231138801549,"rouge_l":0.9226613847123438}
{"id":681,"predictions":["def countCharacterValue ( str ) : NEW_LINE INDENT vowels = 0 NEW_LINE consonant = 0 NEW_LINE originalChar = 0 NEW_LINE digit = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT ch = str [ i ] NEW_LINE if ( ( ch >= ' a ' and ch <= ' z ' z ' ) or ( ch >= ' A ' and ch <= ' Z ' ) ) : NEW_LINE INDENT ch = chr ( ord ( ch ) NEW_LINE if ( ch == ' a ' or ch == ' e ' or ch == ' i ' or ch == ' o ' or ch == ' u ' or ch == ' u ' ) ) : NEW_LINE INDENT vowels += 1 NEW_LINE DEDENT else : NEW_LINE INDENT consonant += 1 NEW_LINE DEDENT DEDENT elif ( ch >= '0' and ch <= '9' ) : NEW_LINE INDENT digit += 1 NEW_LINE DEDENT else : NEW_LINE INDENT specialChar += 1 NEW_LINE DEDENT DEDENT print ( \" Vowels : ▁ \" + strrequant ▁ for ▁ geeks ▁ : ▁ \" , principal ) NEW_LINE print ( \" Consonant : ▁ \" , counter ) NEW_LINE print ( \" Consonant : ▁ \" , originalChar ) NEW_LINE print ( \" Consonant : ▁ \" , originalChar ) NEW_LINE print ( \" Product ▁ Character : \" , finalChar ) NEW_LINE"],"references":["def countCharacterType ( str ) : NEW_LINE INDENT vowels = 0 NEW_LINE consonant = 0 NEW_LINE specialChar = 0 NEW_LINE digit = 0 NEW_LINE for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT ch = str [ i ] NEW_LINE if ( ( ch >= ' a ' and ch <= ' z ' ) or ( ch >= ' A ' and ch <= ' Z ' ) ) : NEW_LINE INDENT ch = ch . lower ( ) NEW_LINE if ( ch == ' a ' or ch == ' e ' or ch == ' i ' or ch == ' o ' or ch == ' u ' ) : NEW_LINE INDENT vowels += 1 NEW_LINE DEDENT else : NEW_LINE INDENT consonant += 1 NEW_LINE DEDENT DEDENT elif ( ch >= '0' and ch <= '9' ) : NEW_LINE INDENT digit += 1 NEW_LINE DEDENT else : NEW_LINE INDENT specialChar += 1 NEW_LINE DEDENT DEDENT print ( \" Vowels : \" , vowels ) NEW_LINE print ( \" Consonant : \" , consonant ) NEW_LINE print ( \" Digit : \" , digit ) NEW_LINE print ( \" Special ▁ Character : \" , specialChar ) NEW_LINE DEDENT str = \" geeks ▁ for ▁ geeks121\" NEW_LINE countCharacterType ( str ) NEW_LINE"],"bleu":0.7458489827780755,"rouge_l":0.8560177561394717}
{"id":682,"predictions":["def calculateSum ( n ) : NEW_LINE INDENT return 2 * ( n * ( n + 1 ) * ( 2 * n + 1 ) \/ 6 ) + n * ( n + 1 ) \/ 2 + 2 * ( n ) NEW_LINE DEDENT n = 3 NEW_LINE print ( \" Sum ▁ = ▁ \" , int ( calculateSum ( n ) ) ) NEW_LINE"],"references":["def calculateSum ( n ) : NEW_LINE INDENT return ( 2 * ( n * ( n + 1 ) * ( 2 * n + 1 ) \/\/ 6 ) + n * ( n + 1 ) \/\/ 2 + 2 * ( n ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE print ( \" Sum ▁ = \" , calculateSum ( n ) ) NEW_LINE DEDENT"],"bleu":0.6507399155452547,"rouge_l":0.8302849851127181}
{"id":683,"predictions":["def countPairs ( arr , n ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] * arr [ j ] > arr [ i ] + arr [ j ] ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 5 , 0 , 3 , 1 , 2 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( countPairs ( arr , n ) ) ; NEW_LINE DEDENT"],"references":["import math as mt NEW_LINE def countPairs ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] * arr [ j ] > arr [ i ] + arr [ j ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 5 , 0 , 3 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE"],"bleu":0.6956999189317751,"rouge_l":0.8895653405068669}
{"id":684,"predictions":["PI = 3.14159 \/ 180.14159 \/ 180.0 ; NEW_LINE def areaOfKite ( a , b , angle ) : NEW_LINE INDENT angle = angle * PI ; NEW_LINE area = a * b * sin ( angle ) ; NEW_LINE return area ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 4 ; NEW_LINE b = 7 ; angle = 78 ; NEW_LINE print ( \" Area ▁ of ▁ Kite ▁ = \" , areaOfKite ) ; NEW_LINE DEDENT"],"references":["import math NEW_LINE PI = 3.14159 \/ 180 ; NEW_LINE def areaOfKite ( a , b , angle ) : NEW_LINE INDENT angle = angle * PI ; NEW_LINE area = a * b * math . sin ( angle ) ; NEW_LINE return area ; NEW_LINE DEDENT a = 4 ; b = 7 ; angle = 78 ; NEW_LINE print ( \" Area ▁ of ▁ Kite ▁ = ▁ \" , areaOfKite ( a , b , angle ) ) ; NEW_LINE"],"bleu":0.6916716676182744,"rouge_l":0.8194891201513718}
{"id":685,"predictions":["A = [ 1 , 31 , 3 , 1 , 5 , 31 , 1 , 23 ] ; NEW_LINE length = len ( A ) ; NEW_LINE totalCount = 0 ; NEW_LINE for i in range ( length - 2 ) : NEW_LINE INDENT if ( target % arr [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i + 1 , length ) : NEW_LINE INDENT if ( target % ( arr [ i ] * arr [ j ] ) == 0 ) : NEW_LINE INDENT if ( target % ( arr [ i ] * arr [ j ] ) == 0 ) : NEW_LINE INDENT toFind = target \/ ( arr [ i ] * arr [ j ] ) ; NEW_LINE for k in range ( j + 1 , length ) : NEW_LINE INDENT if ( arr [ k ] == toFind ) : NEW_LINE INDENT totalCount += 1 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT print ( \" Number ▁ of ▁ triplets ▁ found ▁ : ▁ \" , totalCount ) ; NEW_LINE DEDENT"],"references":["target = 93 NEW_LINE arr = [ 1 , 31 , 3 , 1 , 93 , 3 , 31 , 1 , 93 ] NEW_LINE length = len ( arr ) NEW_LINE totalCount = 0 NEW_LINE for i in range ( length - 2 ) : NEW_LINE INDENT if target % arr [ i ] == 0 : NEW_LINE INDENT for j in range ( i + 1 , length - 1 ) : NEW_LINE INDENT if target % ( arr [ i ] * arr [ j ] ) == 0 : NEW_LINE INDENT toFind = target \/\/ ( arr [ i ] * arr [ j ] ) NEW_LINE for k in range ( j + 1 , length ) : NEW_LINE INDENT if arr [ k ] == toFind : NEW_LINE INDENT totalCount += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT print ( ' Total ▁ number ▁ of ▁ triplets ▁ found : ▁ ' , totalCount ) NEW_LINE"],"bleu":0.6236434417668039,"rouge_l":0.8350679793717769}
{"id":686,"predictions":["def checkSpecialPrime ( sieve , num ) : NEW_LINE INDENT while ( num != 0 ) : NEW_LINE INDENT if ( sieve [ num ] == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT num = int ( num \/ 10 ) NEW_LINE DEDENT return True NEW_LINE DEDENT def findSpecialPrime ( N ) : NEW_LINE INDENT sieve = [ True for i in range ( N + 10 ) ] NEW_LINE sieve [ 0 ] = False NEW_LINE sieve [ 1 ] = False NEW_LINE for i in range ( 2 , N + 10 ) : NEW_LINE INDENT if ( sieve [ i ] ) : NEW_LINE INDENT for j in range ( i * i , N + 1 , i ) : NEW_LINE INDENT sieve [ j ] = False NEW_LINE DEDENT DEDENT DEDENT while ( True ) : NEW_LINE INDENT if ( checkSpecialPrime ( sieve , N ) ) : NEW_LINE INDENT print ( N ) NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT N -= 1 NEW_LINE DEDENT DEDENT DEDENT findSpecialPrime ( 379 ) NEW_LINE findSpecialPrime ( 100 ) NEW_LINE"],"references":["def checkSpecialPrime ( sieve , num ) : NEW_LINE INDENT while ( num ) : NEW_LINE INDENT if ( not sieve [ num ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT num \/\/= 10 NEW_LINE DEDENT return True NEW_LINE DEDENT def findSpecialPrime ( N ) : NEW_LINE INDENT sieve = [ True ] * ( N + 10 ) NEW_LINE sieve [ 0 ] = sieve [ 1 ] = False ; NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT if ( sieve [ i ] ) : NEW_LINE INDENT for j in range ( i * i , N + 1 , i ) : NEW_LINE INDENT sieve [ j ] = False NEW_LINE DEDENT DEDENT DEDENT while ( True ) : NEW_LINE INDENT if ( checkSpecialPrime ( sieve , N ) ) : NEW_LINE INDENT print ( N ) NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT N -= 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT findSpecialPrime ( 379 ) NEW_LINE findSpecialPrime ( 100 ) NEW_LINE DEDENT"],"bleu":0.8141218217765842,"rouge_l":0.8975302154492905}
{"id":687,"predictions":["MAX = 1000005 NEW_LINE fibUpto = [ 0 ] * ( MAX + 1 ) NEW_LINE def compute ( sz ) : NEW_LINE INDENT isFib = [ False ] * ( sz + 1 ) NEW_LINE prev = 0 NEW_LINE curr = 1 NEW_LINE isFib [ prev ] = True NEW_LINE while ( curr <= sz ) : NEW_LINE INDENT temp = curr + prev NEW_LINE if ( temp <= sz ) : NEW_LINE INDENT isFib [ temp ] = True NEW_LINE DEDENT prev = curr NEW_LINE curr = temp NEW_LINE curr = temp NEW_LINE DEDENT fibUpto [ 0 ] = 1 NEW_LINE for i in range ( 1 , sz + 1 ) : NEW_LINE INDENT fibUpto [ i ] = fibUpto [ i - 1 ] NEW_LINE if ( isFib [ i ] ) : NEW_LINE INDENT fibUpt [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT def countOfNumbers ( N , K ) : NEW_LINE INDENT compute ( N ) NEW_LINE low = 1 NEW_LINE high = N NEW_LINE ans = 0 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) >> 1 NEW_LINE if ( mid - fibo [ mid ] >= K ) : NEW_LINE INDENT ans = mid NEW_LINE high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT if ( ans > 0 ) : NEW_LINE INDENT return N - ans + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return N - ans + 1 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 10 NEW_LINE K = 3 NEW_LINE print ( countOfNumbers ( N , K ) ) NEW_LINE DEDENT"],"references":["MAX = 1000005 NEW_LINE fibUpto = [ 0 ] * ( MAX + 1 ) NEW_LINE def compute ( sz ) : NEW_LINE INDENT isFib = [ False ] * ( sz + 1 ) NEW_LINE prev = 0 NEW_LINE curr = 1 NEW_LINE isFib [ prev ] = True NEW_LINE isFib [ curr ] = True NEW_LINE while ( curr <= sz ) : NEW_LINE INDENT temp = curr + prev NEW_LINE if ( temp <= sz ) : NEW_LINE INDENT isFib [ temp ] = True NEW_LINE DEDENT prev = curr NEW_LINE curr = temp NEW_LINE DEDENT fibUpto [ 0 ] = 1 NEW_LINE for i in range ( 1 , sz + 1 ) : NEW_LINE INDENT fibUpto [ i ] = fibUpto [ i - 1 ] NEW_LINE if ( isFib [ i ] ) : NEW_LINE INDENT fibUpto [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT def countOfNumbers ( N , K ) : NEW_LINE INDENT compute ( N ) NEW_LINE low , high , ans = 1 , N , 0 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) >> 1 NEW_LINE if ( mid - fibUpto [ mid ] >= K ) : NEW_LINE INDENT ans = mid NEW_LINE high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT if ( ans ) : NEW_LINE INDENT return ( N - ans + 1 ) NEW_LINE DEDENT return 0 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 10 NEW_LINE K = 3 NEW_LINE print ( countOfNumbers ( N , K ) ) NEW_LINE DEDENT"],"bleu":0.8596584212372125,"rouge_l":0.922677503104188}
{"id":688,"predictions":["def setBitNumber ( n ) : NEW_LINE INDENT n |= n >> 1 ; NEW_LINE n |= n >> 2 ; NEW_LINE n |= n >> 4 ; NEW_LINE n |= n >> 8 ; NEW_LINE n = n + 1 ; NEW_LINE return ( n >> 1 ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 273 ; NEW_LINE print ( setBitNumber ( n ) ) ; NEW_LINE DEDENT"],"references":["def setBitNumber ( n ) : NEW_LINE INDENT n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE n = n + 1 NEW_LINE return ( n >> 1 ) NEW_LINE DEDENT n = 273 NEW_LINE print ( setBitNumber ( n ) ) NEW_LINE"],"bleu":0.5540706558043286,"rouge_l":0.8220260223048326}
{"id":689,"predictions":["def isHeterogram ( s , n ) : NEW_LINE INDENT Hash = [ 0 ] * 26 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] != ' ▁ ' ) : NEW_LINE INDENT if ( Hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] == 0 ) : NEW_LINE INDENT Hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] = 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT DEDENT return True ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" the ▁ big ▁ Special ▁ jumps ▁ jumps \" ; NEW_LINE n = len ( s ) ; NEW_LINE if ( isHeterogram ( s , n ) ) : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE DEDENT DEDENT"],"references":["def isHeterogram ( s , n ) : NEW_LINE INDENT hash = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] != ' ▁ ' : NEW_LINE INDENT if hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] == 0 : NEW_LINE INDENT hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT s = \" the ▁ big ▁ dwarf ▁ only ▁ jumps \" NEW_LINE n = len ( s ) NEW_LINE print ( \" YES \" if isHeterogram ( s , n ) else \" NO \" ) NEW_LINE"],"bleu":0.5779140762695069,"rouge_l":0.827936304371059}
{"id":690,"predictions":["def findgcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return findgcd ( b , a % b ) NEW_LINE DEDENT def minimumCuts ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE gcd = a [ 1 ] - a [ 0 ] NEW_LINE s = gcd NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT gcd = findgcd ( gcd , a [ i ] - a [ i - 1 ] ) NEW_LINE s += a [ i ] - a [ i - 1 ] NEW_LINE DEDENT if ( 360 - s ) : NEW_LINE INDENT gcd = findgcd ( gcd , 360 - s ) NEW_LINE DEDENT return ( 360 \/ gcd ) - n NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 30 , 60 , 180 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minimumCuts ( arr , n ) ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def minimumCuts ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE gcd = a [ 1 ] - a [ 0 ] NEW_LINE s = gcd NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT gcd = math . gcd ( gcd , a [ i ] - a [ i - 1 ] ) NEW_LINE s += a [ i ] - a [ i - 1 ] NEW_LINE DEDENT if ( 360 - s > 0 ) : NEW_LINE INDENT gcd = math . gcd ( gcd , 360 - s ) NEW_LINE DEDENT return ( 360 \/\/ gcd ) - n NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 30 , 60 , 180 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minimumCuts ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.7439178456461181,"rouge_l":0.8626501356063542}
{"id":691,"predictions":["MAX = 1005 NEW_LINE def SieveOfEratosthenes ( primes ) : NEW_LINE INDENT prime = [ True for i in range ( MAX ) ] NEW_LINE p = 2 NEW_LINE while p * p < MAX : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT for p in range ( 2 , MAX ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT primes . append ( len ( primes ) ) NEW_LINE DEDENT DEDENT DEDENT def minimumSquareDivisors ( N ) : NEW_LINE INDENT primes = [ ] NEW_LINE SieveOfEratosthenes ( primes ) NEW_LINE max_count = 0 NEW_LINE i = 0 NEW_LINE while ( i < len ( primes ) and primes [ i ] * primes [ i ] <= N ) : NEW_LINE INDENT if ( N % primes [ i ] == 0 ) : NEW_LINE INDENT tmp = 0 NEW_LINE while ( N % primes [ i ] == 0 ) : NEW_LINE INDENT tmp += 1 NEW_LINE N \/= primes [ i ] NEW_LINE DEDENT max_count = max ( max_count , tmp ) NEW_LINE i += 1 NEW_LINE DEDENT if ( max_count == 0 ) : NEW_LINE INDENT max_count = 1 NEW_LINE while ( N % primes [ i ] == 0 ) : NEW_LINE INDENT tmp += 1 NEW_LINE N \/= primes [ i ] NEW_LINE DEDENT max_count = max ( max_count , tmp ) NEW_LINE i += 1 NEW_LINE DEDENT if ( max_count == 0 ) : NEW_LINE INDENT max_count = 1 NEW_LINE DEDENT return max_count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 24 NEW_LINE print ( \" Minimum ▁ Number ▁ of ▁ Square ▁ Fair ▁ Divisors ▁ is \" , minimumSquareOfEr"],"references":["from math import sqrt NEW_LINE MAX = 1005 NEW_LINE def SieveOfEratosthenes ( primes ) : NEW_LINE INDENT prime = [ True for i in range ( MAX ) ] NEW_LINE for p in range ( 2 , int ( sqrt ( MAX ) ) + 1 , 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for p in range ( 2 , MAX , 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT primes . append ( p ) NEW_LINE DEDENT DEDENT return primes NEW_LINE DEDENT def minimumSquareFreeDivisors ( N ) : NEW_LINE INDENT prime = [ ] NEW_LINE primes = [ ] NEW_LINE primes = SieveOfEratosthenes ( prime ) NEW_LINE max_count = 0 NEW_LINE i = 0 NEW_LINE while ( len ( primes ) and primes [ i ] * primes [ i ] <= N ) : NEW_LINE INDENT if ( N % primes [ i ] == 0 ) : NEW_LINE INDENT tmp = 0 NEW_LINE while ( N % primes [ i ] == 0 ) : NEW_LINE INDENT tmp += 1 NEW_LINE N \/= primes [ i ] NEW_LINE DEDENT max_count = max ( max_count , tmp ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( max_count == 0 ) : NEW_LINE INDENT max_count = 1 NEW_LINE DEDENT return max_count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 24 NEW_LINE print ( \" Minimum ▁ Number ▁ of ▁ Square ▁ Free ▁ Divisors ▁ is \" , minimumSquareFreeDivisors ( N ) ) NEW_LINE N = 6 NEW_LINE print ( \" Minimum ▁ Number ▁ of ▁ Square ▁ Free ▁ Divisors ▁ is \" , minimumSquareFreeDivisors ( N ) ) NEW_LINE DEDENT"],"bleu":0.7521623333266019,"rouge_l":0.7820121187841155}
{"id":692,"predictions":["def solveSum ( n ) : NEW_LINE INDENT return int ( pow ( n * ( n + 1 ) \/ 2 , 2 ) ) NEW_LINE DEDENT n = 4 NEW_LINE print ( int ( solve ( n ) ) ) NEW_LINE"],"references":["def calculateSum ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) \/ 2 ) ** 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE print ( calculateSum ( n ) ) NEW_LINE DEDENT"],"bleu":0.484162221847587,"rouge_l":0.6789565217391306}
{"id":693,"predictions":["st = [ ] NEW_LINE def push_digits ( number ) : NEW_LINE INDENT while ( number != 0 ) : NEW_LINE INDENT st . append ( number % 10 ) NEW_LINE number = int ( number \/ 10 ) NEW_LINE DEDENT DEDENT def reverse_number ( number ) : NEW_LINE INDENT push_digits ( number ) NEW_LINE reverse = 0 NEW_LINE i = 1 NEW_LINE while ( len ( st ) > 0 ) : NEW_LINE INDENT reverse = reverse + ( st [ - 1 ] * i ) NEW_LINE st . pop ( ) NEW_LINE i = i * 10 NEW_LINE DEDENT return reverse NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT number = 15097 NEW_LINE print ( reverse_number ( number ) ) NEW_LINE DEDENT"],"references":["st = [ ] ; NEW_LINE def push_digits ( number ) : NEW_LINE INDENT while ( number != 0 ) : NEW_LINE INDENT st . append ( number % 10 ) ; NEW_LINE number = int ( number \/ 10 ) ; NEW_LINE DEDENT DEDENT def reverse_number ( number ) : NEW_LINE INDENT push_digits ( number ) ; NEW_LINE reverse = 0 ; NEW_LINE i = 1 ; NEW_LINE while ( len ( st ) > 0 ) : NEW_LINE INDENT reverse = reverse + ( st [ len ( st ) - 1 ] * i ) ; NEW_LINE st . pop ( ) ; NEW_LINE i = i * 10 ; NEW_LINE DEDENT return reverse ; NEW_LINE DEDENT number = 39997 ; NEW_LINE print ( reverse_number ( number ) ) ; NEW_LINE"],"bleu":0.7155825089103959,"rouge_l":0.8785081240768094}
{"id":694,"predictions":["def inProsort ( arr ) : NEW_LINE INDENT n = 4 NEW_LINE arr = sorted ( arr ) NEW_LINE reverse = ( arr [ 0 ] * arr [ 3 ] ) NEW_LINE times = arr [ 1 ] * arr [ 2 ] NEW_LINE if ( long == no ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT arr = [ 1 , 2 , 4 , 2 ] NEW_LINE if (Inpro tion ( arr ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def inProportion ( arr ) : NEW_LINE INDENT n = 4 ; NEW_LINE arr . sort ( ) NEW_LINE extremes = arr [ 0 ] * arr [ 3 ] ; NEW_LINE means = arr [ 1 ] * arr [ 2 ] ; NEW_LINE if ( extremes == means ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 2 ] ; NEW_LINE if ( inProportion ( arr ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"],"bleu":0.5467175057732625,"rouge_l":0.7985202048947068}
{"id":695,"predictions":["M = 100 NEW_LINE memo = [ [ [ 0 for i in range ( M ) ] for i in range ( M ) ] for i in range ( M ) ] NEW_LINE def numberOfPermWithKInzero ( N , K ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( K == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( memo [ N ] [ K ] != 0 ) : NEW_LINE INDENT return memo [ N ] [ K ] [ K ] NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( K + 1 ) : NEW_LINE INDENT if ( i <= N - 1 ) : NEW_LINE INDENT sum += numberOfPermWithKInvalue ( N - 1 , K - i ) NEW_LINE DEDENT DEDENT memo [ N ] [ K ] = sum NEW_LINE return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE K = 2 NEW_LINE print ( numberOfPermWithKInzero ( N , K ) ) NEW_LINE DEDENT"],"references":["M = 100 NEW_LINE memo = [ [ 0 for i in range ( M ) ] for j in range ( M ) ] NEW_LINE def numberOfPermWithKInversion ( N , K ) : NEW_LINE INDENT if ( N == 0 ) : return 0 NEW_LINE if ( K == 0 ) : return 1 NEW_LINE if ( memo [ N ] [ K ] != 0 ) : NEW_LINE INDENT return memo [ N ] [ K ] NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( K + 1 ) : NEW_LINE INDENT if ( i <= N - 1 ) : NEW_LINE INDENT sum += numberOfPermWithKInversion ( N - 1 , K - i ) NEW_LINE DEDENT DEDENT memo [ N ] [ K ] = sum NEW_LINE return sum NEW_LINE DEDENT N = 4 ; K = 2 NEW_LINE print ( numberOfPermWithKInversion ( N , K ) ) NEW_LINE"],"bleu":0.7166368013203634,"rouge_l":0.8922476840565576}
{"id":696,"predictions":["import math NEW_LINE def findkth ( n , k ) : NEW_LINE INDENT v1 = [ ] NEW_LINE v2 = [ ] NEW_LINE for i in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT v1 . append ( i ) NEW_LINE if ( i != math . sqrt ( n ) ) : NEW_LINE INDENT v2 . append ( n \/ i ) NEW_LINE DEDENT DEDENT v2 . reverse ( ) NEW_LINE if ( k > ( len ( v1 ) + len ( v2 ) ) ) : NEW_LINE INDENT print ( \" Doesn ' t ▁ Exist \" ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( k <= len ( v1 ) ) : NEW_LINE INDENT print ( v1 [ k - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( v2 [ k - len ( v2 ) - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 15 NEW_LINE k = 2 NEW_LINE findkth ( n , k ) NEW_LINE DEDENT"],"references":["import math as mt NEW_LINE def findkth ( n , k ) : NEW_LINE INDENT v1 = list ( ) NEW_LINE v2 = list ( ) NEW_LINE for i in range ( 1 , mt . ceil ( n ** ( .5 ) ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT v1 . append ( i ) NEW_LINE if ( i != mt . ceil ( mt . sqrt ( n ) ) ) : NEW_LINE INDENT v2 . append ( n \/\/ i ) NEW_LINE DEDENT DEDENT DEDENT v2 [ : : - 1 ] NEW_LINE if ( k > ( len ( v1 ) + len ( v2 ) ) ) : NEW_LINE INDENT print ( \" Doesn ' t ▁ Exist \" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( k <= len ( v1 ) ) : NEW_LINE INDENT print ( v1 [ k - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( v2 [ k - len ( v1 ) - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT n = 15 NEW_LINE k = 2 NEW_LINE findkth ( n , k ) NEW_LINE"],"bleu":0.7629857864982792,"rouge_l":0.8423926134082697}
{"id":697,"predictions":["import sys ; NEW_LINE def maxSubArraySum ( a , size ) : NEW_LINE INDENT max_so_far = - ( sys . maxsize - 1 ) ; NEW_LINE max_ending_here = 0 ; NEW_LINE for i in range ( size ) : NEW_LINE INDENT max_ending_here = max_ending_here + a [ i ] ; NEW_LINE if ( max_so_far < max_ending_here ) : NEW_LINE INDENT max_so_far = max_ending_here ; NEW_LINE DEDENT if ( max_ending_here < 0 ) : NEW_LINE INDENT max_ending_here = 0 ; NEW_LINE DEDENT DEDENT return max_so_far ; NEW_LINE DEDENT def minimizedSum ( a , n , K ) : NEW_LINE INDENT sum = maxSubArraySum ( a , n ) ; NEW_LINE totalSum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT totalSum += a [ i ] ; NEW_LINE DEDENT if ( sum < 0 ) : NEW_LINE INDENT return totalSum ; NEW_LINE DEDENT totalSum = ( totalSum - sum + sum + sum \/ ( K ) ) ; NEW_LINE return totalSum ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , - 2 , 3 ] ; NEW_LINE n = len ( a ) ; NEW_LINE K = 2 ; NEW_LINE print ( minimizedSum ( a , n , K ) ) ; NEW_LINE DEDENT"],"references":["import sys NEW_LINE def maxSubArraySum ( a , size ) : NEW_LINE INDENT max_so_far = - ( sys . maxsize - 1 ) ; NEW_LINE max_ending_here = 0 ; NEW_LINE for i in range ( size ) : NEW_LINE INDENT max_ending_here = max_ending_here + a [ i ] ; NEW_LINE if ( max_so_far < max_ending_here ) : NEW_LINE INDENT max_so_far = max_ending_here ; NEW_LINE DEDENT if ( max_ending_here < 0 ) : NEW_LINE INDENT max_ending_here = 0 ; NEW_LINE DEDENT DEDENT return max_so_far ; NEW_LINE DEDENT def minimizedSum ( a , n , K ) : NEW_LINE INDENT sum = maxSubArraySum ( a , n ) ; NEW_LINE totalSum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT totalSum += a [ i ] ; NEW_LINE DEDENT if ( sum < 0 ) : NEW_LINE INDENT return totalSum ; NEW_LINE DEDENT totalSum = totalSum - sum + sum \/ K ; NEW_LINE return totalSum ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , - 2 , 3 ] ; NEW_LINE n = len ( a ) ; NEW_LINE K = 2 ; NEW_LINE print ( minimizedSum ( a , n , K ) ) ; NEW_LINE DEDENT"],"bleu":0.9453709269412696,"rouge_l":0.986771486884874}
{"id":698,"predictions":["def countSetBits ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE setBits = [ 0 ] * ( n + 1 ) NEW_LINE setBits [ 0 ] = 0 NEW_LINE setBits [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT setBits [ i ] = setBits [ i \/\/ 2 ] NEW_LINE DEDENT else : NEW_LINE INDENT setBits [ i ] = setBits [ i - 1 ] + 1 NEW_LINE DEDENT DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT cnt = cnt + setBits [ i ] NEW_LINE DEDENT return cnt NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 6 NEW_LINE print ( countSetBits ( n ) ) NEW_LINE DEDENT"],"references":["def countSetBits ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE setBits = [ 0 for x in range ( n + 1 ) ] NEW_LINE setBits [ 0 ] = 0 NEW_LINE setBits [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT setBits [ i ] = setBits [ i \/\/ 2 ] NEW_LINE DEDENT else : NEW_LINE INDENT setBits [ i ] = setBits [ i - 1 ] + 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , n + 1 ) : NEW_LINE INDENT cnt = cnt + setBits [ i ] NEW_LINE DEDENT return cnt NEW_LINE DEDENT n = 6 NEW_LINE print ( countSetBits ( n ) ) NEW_LINE"],"bleu":0.8569389464093204,"rouge_l":0.925091911764706}
{"id":699,"predictions":["def areaCircle ( b ) : NEW_LINE INDENT area = 3.1415926 * b * b NEW_LINE return area NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 10 NEW_LINE b = 8 NEW_LINE print ( areaCircle ( b ) ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def areaCircle ( b ) : NEW_LINE INDENT area = math . pi * b * b NEW_LINE return area NEW_LINE DEDENT a = 10 NEW_LINE b = 8 NEW_LINE print ( areaCircle ( b ) ) NEW_LINE"],"bleu":0.6372440604609679,"rouge_l":0.7831988261188555}
{"id":700,"predictions":["import math NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def push ( head_ref , new_data ) : NEW_LINE INDENT new_node = Node ( 0 ) NEW_LINE new_node . data = new_data NEW_LINE new_node . next = head_ref NEW_LINE head_ref = new_node NEW_LINE return head_ref NEW_LINE DEDENT def printList ( head ) : NEW_LINE INDENT while head != None : NEW_LINE INDENT print ( head . data , \" - > \" , end = \" \" ) NEW_LINE head = head . next NEW_LINE DEDENT DEDENT def sortlist ( arr , N , head ) : NEW_LINE INDENT hash = dict . fromkeys ( arr , 0 ) NEW_LINE temp = head NEW_LINE while ( temp != None ) : NEW_LINE INDENT hash = dict . get ( 0 , 0 ) NEW_LINE while ( temp . data != None ) : NEW_LINE INDENT hash [ temp ] = hash [ temp ] NEW_LINE temp = temp . next NEW_LINE DEDENT temp = temp . next NEW_LINE DEDENT temp = head NEW_LINE for i in range ( N ) : NEW_LINE INDENT frequency = hash [ arr [ i ] ] NEW_LINE while ( frequency > 0 ) : NEW_LINE INDENT temp . data = arr [ i ] NEW_LINE temp = temp . data NEW_LINE temp = temp . next NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = None NEW_LINE arr = [ 5 , 1 , 3 , 2 , 8 ] NEW_LINE N = len ( arr ) NEW_LINE head = push ( head , 2 ) NEW_LINE head = push ( head , 5 ) NEW_LINE head = push ( head , 5 ) NEW_LINE head = push ( head , 2 ) NEW_LINE head = push ( head , 5 ) NEW_LINE printList ( head ) NEW_LINE print ( \" Sorted ▁ List : \" ) NEW_LINE printList ( head ) NEW_LINE DEDENT"],"references":["class Node : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . data = 0 NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def push ( head_ref , new_data ) : NEW_LINE INDENT new_node = Node ( ) NEW_LINE new_node . data = new_data NEW_LINE new_node . next = head_ref NEW_LINE head_ref = new_node NEW_LINE return head_ref NEW_LINE DEDENT def printList ( head ) : NEW_LINE INDENT while ( head != None ) : NEW_LINE INDENT print ( head . data , end = \" - > \" ) NEW_LINE head = head . next NEW_LINE DEDENT DEDENT def sortlist ( arr , N , head ) : NEW_LINE INDENT hash = dict ( ) NEW_LINE temp = head NEW_LINE while ( temp != None ) : NEW_LINE INDENT hash [ temp . data ] = hash . get ( temp . data , 0 ) + 1 NEW_LINE temp = temp . next NEW_LINE DEDENT temp = head NEW_LINE for i in range ( N ) : NEW_LINE INDENT frequency = hash . get ( arr [ i ] , 0 ) NEW_LINE while ( frequency > 0 ) : NEW_LINE INDENT frequency = frequency - 1 NEW_LINE temp . data = arr [ i ] NEW_LINE temp = temp . next NEW_LINE DEDENT DEDENT DEDENT head = None NEW_LINE arr = [ 5 , 1 , 3 , 2 , 8 ] NEW_LINE N = len ( arr ) NEW_LINE head = push ( head , 3 ) NEW_LINE head = push ( head , 2 ) NEW_LINE head = push ( head , 5 ) NEW_LINE head = push ( head , 8 ) NEW_LINE head = push ( head , 5 ) NEW_LINE head = push ( head , 2 ) NEW_LINE head = push ( head , 1 ) NEW_LINE sortlist ( arr , N , head ) NEW_LINE print ( \" Sorted ▁ List : \" ) NEW_LINE printList ( head ) NEW_LINE"],"bleu":0.7700721237628309,"rouge_l":0.8255550739295862}
{"id":701,"predictions":["def printPattern ( N ) : NEW_LINE INDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( str ( i % 2 ) , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 16 NEW_LINE printPattern ( N ) NEW_LINE DEDENT"],"references":["def printPattern ( N ) : NEW_LINE INDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( i - 1 if i % 2 == 0 else i + 1 , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT N = 10 NEW_LINE printPattern ( N ) NEW_LINE"],"bleu":0.6247053707888722,"rouge_l":0.7644110275689223}
{"id":702,"predictions":["import sys NEW_LINE def minIndex ( list , sortIndex ) : NEW_LINE INDENT min_index = - 1 NEW_LINE min_value = sys . maxsize NEW_LINE s = list ( ) NEW_LINE for i in range ( s ) : NEW_LINE INDENT current = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE if ( current <= min_value and i <= sortIndex ) : NEW_LINE INDENT min_index = i NEW_LINE min_value = current NEW_LINE DEDENT list . append ( current ) NEW_LINE DEDENT return min_index NEW_LINE DEDENT def sortQueue ( list1 ) : NEW_LINE INDENT for i in range ( 1 , len ( list1 ) + 1 ) : NEW_LINE INDENT temp = list ( list1 ) NEW_LINE list1 . pop ( ) NEW_LINE if ( i != min_index ) : NEW_LINE INDENT list1 . append ( current ) NEW_LINE DEDENT else : NEW_LINE INDENT min_value = current NEW_LINE DEDENT DEDENT list1 . append ( min_value ) NEW_LINE DEDENT def sortQueue ( list1 ) : NEW_LINE INDENT for i in range ( 1 , len ( list1 ) + 1 ) : NEW_LINE INDENT min_index = minIndex ( list ( list1 ) - i ) NEW_LINE insertMinToRear ( list1 , min_index ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT list1 = [ 30 , 11 , 15 , 16 ] NEW_LINE list2 . sort ( ) NEW_LINE sortQueue ( list1 ) NEW_LINE while ( len ( list1 ) == 0 ) : NEW_LINE INDENT print ( list1 [ - 1 ] , end = \" ▁ \" ) NEW_LINE print ( list1 . pop ( ) ) NEW_LINE DEDENT DEDENT"],"references":["from queue import Queue NEW_LINE def minIndex ( q , sortedIndex ) : NEW_LINE INDENT min_index = - 1 NEW_LINE min_val = 999999999999 NEW_LINE n = q . qsize ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr = q . queue [ 0 ] NEW_LINE q . get ( ) NEW_LINE if ( curr <= min_val and i <= sortedIndex ) : NEW_LINE INDENT min_index = i NEW_LINE min_val = curr NEW_LINE DEDENT q . put ( curr ) NEW_LINE DEDENT return min_index NEW_LINE DEDENT def insertMinToRear ( q , min_index ) : NEW_LINE INDENT min_val = None NEW_LINE n = q . qsize ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr = q . queue [ 0 ] NEW_LINE q . get ( ) NEW_LINE if ( i != min_index ) : NEW_LINE INDENT q . put ( curr ) NEW_LINE DEDENT else : NEW_LINE INDENT min_val = curr NEW_LINE DEDENT DEDENT q . put ( min_val ) NEW_LINE DEDENT def sortQueue ( q ) : NEW_LINE INDENT for i in range ( 1 , q . qsize ( ) + 1 ) : NEW_LINE INDENT min_index = minIndex ( q , q . qsize ( ) - i ) NEW_LINE insertMinToRear ( q , min_index ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT q = Queue ( ) NEW_LINE q . put ( 30 ) NEW_LINE q . put ( 11 ) NEW_LINE q . put ( 15 ) NEW_LINE q . put ( 4 ) NEW_LINE sortQueue ( q ) NEW_LINE while ( q . empty ( ) == False ) : NEW_LINE INDENT print ( q . queue [ 0 ] , end = \" ▁ \" ) NEW_LINE q . get ( ) NEW_LINE DEDENT DEDENT"],"bleu":0.44134690921593783,"rouge_l":0.670910765563201}
{"id":703,"predictions":["def cntRotations ( s , n ) : NEW_LINE INDENT str = s + s NEW_LINE pre = [ 0 ] * 2 * n NEW_LINE for i in range ( 0 , 2 * n ) : NEW_LINE INDENT if ( i != 0 ) : NEW_LINE INDENT pre [ i ] += pre [ i - 1 ] NEW_LINE DEDENT if ( str [ i ] == ' a ' or str [ i ] == ' e ' or str [ i ] == ' i ' or str [ i ] == ' o ' or str [ i ] == ' u ' ) : NEW_LINE INDENT pre [ i ] += 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n - 1 , 2 * n - 1 , 1 ) : NEW_LINE INDENT r = i NEW_LINE l = i - n NEW_LINE x1 = pre [ r ] NEW_LINE if ( l >= 0 ) : NEW_LINE INDENT x1 -= pre [ l ] NEW_LINE DEDENT r = i - n \/\/ 2 NEW_LINE left = pre [ r ] NEW_LINE if ( l >= 0 ) : NEW_LINE INDENT left -= pre [ l ] NEW_LINE DEDENT right = x1 - left NEW_LINE if ( left > right ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT right = x1 - left NEW_LINE if ( left > right ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT right = x1 - left NEW_LINE if ( left > right ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT s = \" abecidft \" NEW_LINE n = len ( s ) NEW_LINE print ( cntRotations ( s , n ) ) NEW_LINE"],"references":["def cntRotations ( s , n ) : NEW_LINE INDENT str = s + s ; NEW_LINE pre = [ 0 ] * ( 2 * n ) ; NEW_LINE for i in range ( 2 * n ) : NEW_LINE INDENT if ( i != 0 ) : NEW_LINE INDENT pre [ i ] += pre [ i - 1 ] ; NEW_LINE DEDENT if ( str [ i ] == ' a ' or str [ i ] == ' e ' or str [ i ] == ' i ' or str [ i ] == ' o ' or str [ i ] == ' u ' ) : NEW_LINE INDENT pre [ i ] += 1 ; NEW_LINE DEDENT DEDENT ans = 0 ; NEW_LINE for i in range ( n - 1 , 2 * n - 1 , 1 ) : NEW_LINE INDENT r = i ; l = i - n ; NEW_LINE x1 = pre [ r ] ; NEW_LINE if ( l >= 0 ) : NEW_LINE INDENT x1 -= pre [ l ] ; NEW_LINE DEDENT r = ( int ) ( i - n \/ 2 ) ; NEW_LINE left = pre [ r ] ; NEW_LINE if ( l >= 0 ) : NEW_LINE INDENT left -= pre [ l ] ; NEW_LINE DEDENT right = x1 - left ; NEW_LINE if ( left > right ) : NEW_LINE INDENT ans += 1 ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT s = \" abecidft \" ; NEW_LINE n = len ( s ) ; NEW_LINE print ( cntRotations ( s , n ) ) ; NEW_LINE"],"bleu":0.7455612626850296,"rouge_l":0.8842589960775397}
{"id":704,"predictions":["def msb_p_p_p_p = - 1 NEW_LINE while ( N ) : NEW_LINE INDENT N = N >> 1 NEW_LINE msb_p_p = - 1 NEW_LINE while ( N ) : NEW_LINE INDENT N = N >> 1 NEW_LINE msb_p_p_p += 1 NEW_LINE DEDENT return msb_p_p NEW_LINE DEDENT def findBitwiseOR ( L , R ) : NEW_LINE INDENT res = 0 NEW_LINE msb_p1 = msb_p2 = L - res_p1 NEW_LINE msb_p2 = M - res_val NEW_LINE while ( msb_p1 == msb_p2 ) : NEW_LINE INDENT res_val = ( 1 << msb_p1 ) NEW_LINE res += res_val NEW_LINE L -= res_val NEW_LINE r -= res_val NEW_LINE msb_p2 = mspbMatrix ( L ) NEW_LINE msb_p2 = msb_p1 NEW_LINE DEDENT msb_p1 = max ( msb_p1 , msb_p2 ) NEW_LINE for i in range ( msb_p1 , - 1 , - 1 ) : NEW_LINE INDENT res_val = ( 1 << i ) NEW_LINE res += res_val NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT L = 12 NEW_LINE R = 18 NEW_LINE print ( findBitwiseOR ( L , R ) ) NEW_LINE DEDENT"],"references":["def MSBPosition ( N ) : NEW_LINE INDENT msb_p = - 1 NEW_LINE while ( N ) : NEW_LINE INDENT N = N >> 1 NEW_LINE msb_p += 1 NEW_LINE DEDENT return msb_p NEW_LINE DEDENT def findBitwiseOR ( L , R ) : NEW_LINE INDENT res = 0 NEW_LINE msb_p1 = MSBPosition ( L ) NEW_LINE msb_p2 = MSBPosition ( R ) NEW_LINE while ( msb_p1 == msb_p2 ) : NEW_LINE INDENT res_val = ( 1 << msb_p1 ) NEW_LINE res += res_val NEW_LINE L -= res_val NEW_LINE R -= res_val NEW_LINE msb_p1 = MSBPosition ( L ) NEW_LINE msb_p2 = MSBPosition ( R ) NEW_LINE DEDENT msb_p1 = max ( msb_p1 , msb_p2 ) NEW_LINE for i in range ( msb_p1 , - 1 , - 1 ) : NEW_LINE INDENT res_val = ( 1 << i ) NEW_LINE res += res_val NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT L , R = 12 , 18 NEW_LINE print ( findBitwiseOR ( L , R ) ) NEW_LINE DEDENT"],"bleu":0.7297953539877139,"rouge_l":0.8573970287340985}
{"id":705,"predictions":["from math import sqrt , pow NEW_LINE def sieve ( prime , n ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT def sumPrime ( d ) : NEW_LINE INDENT maxVal = int ( pow ( 10 , d ) ) - 1 NEW_LINE prime = [ True for i in range ( maxVal + 1 ) ] NEW_LINE sieve ( prime , maxVal ) NEW_LINE sum = 0 NEW_LINE for i in range ( 2 , maxVal + 1 , 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT d = 3 NEW_LINE print ( sumPrime ( d ) ) NEW_LINE DEDENT"],"references":["from math import sqrt NEW_LINE def sieve ( prime , n ) : NEW_LINE INDENT prime [ 0 ] = False ; NEW_LINE prime [ 1 ] = False ; NEW_LINE for p in range ( 2 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def sumPrime ( d ) : NEW_LINE INDENT maxVal = ( 10 ** d ) - 1 ; NEW_LINE prime = [ True ] * ( maxVal + 1 ) ; NEW_LINE sieve ( prime , maxVal ) ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( 2 , maxVal + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT sum += i ; NEW_LINE DEDENT DEDENT return sum ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT d = 3 ; NEW_LINE print ( sumPrime ( d ) ) ; NEW_LINE DEDENT"],"bleu":0.7119149571882446,"rouge_l":0.8631373505733105}
{"id":706,"predictions":["MAX_CHAR = 256 NEW_LINE def kthNonRepeating ( str1 , k ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE count = [ 0 for i in range ( n ) ] NEW_LINE index = [ n for i in range ( MAX_CHAR ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = str1 [ i ] NEW_LINE count [ x ] += 1 NEW_LINE if ( count [ x ] == 1 ) : NEW_LINE INDENT index [ x ] = i NEW_LINE DEDENT if ( count [ x ] == 2 ) : NEW_LINE INDENT index [ x ] = n NEW_LINE DEDENT DEDENT index . sort ( reverse = True ) NEW_LINE if ( index [ k - 1 ] != n ) : NEW_LINE INDENT index [ k - 1 ] = n NEW_LINE DEDENT index . sort ( reverse = False ) NEW_LINE if ( index [ k - 1 ] != n ) : NEW_LINE INDENT return index [ k - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" geeksforgeeks \" NEW_LINE k = 3 NEW_LINE res = kthNonRepeating ( str1 , k ) NEW_LINE if ( res == - 1 ) : NEW_LINE INDENT print ( \" True ▁ less ▁ than ▁ k ▁ non ▁ k ▁ non ▁ k ▁ non ▁ \" , str1 [ res ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" k ' ) NEW_LINE DEDENT"],"references":["MAX_CHAR = 256 NEW_LINE def kthNonRepeating ( str , k ) : NEW_LINE INDENT n = len ( str ) NEW_LINE count = [ 0 ] * MAX_CHAR NEW_LINE index = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT count [ i ] = 0 NEW_LINE index [ i ] = n NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT x = str [ i ] NEW_LINE count [ ord ( x ) ] += 1 NEW_LINE if ( count [ ord ( x ) ] == 1 ) : NEW_LINE INDENT index [ ord ( x ) ] = i NEW_LINE DEDENT if ( count [ ord ( x ) ] == 2 ) : NEW_LINE INDENT index [ ord ( x ) ] = n NEW_LINE DEDENT DEDENT index . sort ( ) NEW_LINE return index [ k - 1 ] if ( index [ k - 1 ] != n ) else - 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeksforgeeks \" NEW_LINE k = 3 NEW_LINE res = kthNonRepeating ( str , k ) NEW_LINE if ( res == - 1 ) : NEW_LINE INDENT print ( \" There ▁ are ▁ less ▁ than ▁ k \" , \" non - repeating ▁ characters \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" k ' th ▁ non - repeating ▁ character ▁ is \" , str [ res ] ) NEW_LINE DEDENT DEDENT"],"bleu":0.627447751737747,"rouge_l":0.7328225559301256}
{"id":707,"predictions":["def squareDigitSum ( number ) : NEW_LINE INDENT summ = 0 NEW_LINE num = int ( number ) NEW_LINE squareNum = num * num NEW_LINE while ( squareNum > 0 ) : NEW_LINE INDENT summ = summ + ( squareNum % 10 ) NEW_LINE squareNum = squareNum \/\/ 10 NEW_LINE DEDENT return summ NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = \"1111\" NEW_LINE print ( squareDigitSum ( N ) ) NEW_LINE DEDENT"],"references":["def squareDigitSum ( num ) : NEW_LINE INDENT summ = 0 NEW_LINE num = int ( num ) NEW_LINE squareNum = num * num NEW_LINE while squareNum > 0 : NEW_LINE INDENT summ = summ + ( squareNum % 10 ) NEW_LINE squareNum = squareNum \/\/ 10 NEW_LINE DEDENT return summ NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = \"1111\" NEW_LINE print ( squareDigitSum ( N ) ) NEW_LINE DEDENT"],"bleu":0.8730974983515231,"rouge_l":0.9646744711439722}
{"id":708,"predictions":["def maxCost ( a , n , l , r ) : NEW_LINE INDENT mx = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT mx = max ( mx , a [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT res = [ 0 ] * ( mx + 1 ) NEW_LINE l = min ( l , r ) NEW_LINE for num in range ( 1 , mx + 1 ) : NEW_LINE INDENT k = max ( num - l - 1 , 0 ) NEW_LINE res [ num ] = max ( res [ num - 1 ] , num * count [ num ] + res [ k ] ) NEW_LINE DEDENT return res [ mx ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 2 , 1 , 2 , 3 , 2 , 2 , 1 ] NEW_LINE l = 1 NEW_LINE r = 1 NEW_LINE n = len ( a ) NEW_LINE print ( maxCost ( a , n , l , r ) ) NEW_LINE DEDENT"],"references":["def maxCost ( a , n , l , r ) : NEW_LINE INDENT mx = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mx = max ( mx , a [ i ] ) NEW_LINE DEDENT count = [ 0 ] * ( mx + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ a [ i ] ] += 1 NEW_LINE DEDENT res = [ 0 ] * ( mx + 1 ) NEW_LINE res [ 0 ] = 0 NEW_LINE l = min ( l , r ) NEW_LINE for num in range ( 1 , mx + 1 ) : NEW_LINE INDENT k = max ( num - l - 1 , 0 ) NEW_LINE res [ num ] = max ( res [ num - 1 ] , num * count [ num ] + res [ k ] ) NEW_LINE DEDENT return res [ mx ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 2 , 1 , 2 , 3 , 2 , 2 , 1 ] NEW_LINE l , r = 1 , 1 NEW_LINE n = len ( a ) NEW_LINE print ( maxCost ( a , n , l , r ) ) NEW_LINE DEDENT"],"bleu":0.7432972798502203,"rouge_l":0.849727626459144}
{"id":709,"predictions":["def findPosition ( k , n ) : NEW_LINE INDENT f1 , f2 = 0 , 1 NEW_LINE f2 = f3 NEW_LINE i = 2 NEW_LINE while ( i != 0 ) : NEW_LINE INDENT f3 = f1 + f2 NEW_LINE f1 = f2 NEW_LINE f2 = f3 NEW_LINE if ( f2 % k == 0 ) : NEW_LINE INDENT return n * i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT n = 5 NEW_LINE k = 4 NEW_LINE print ( \" Position ▁ of ▁ n 'th ▁ multiple ▁ of ▁ n ' , end = \" ▁ \" ) NEW_LINE print ( findPosition ( k , n ) ) NEW_LINE"],"references":["def findPosition ( k , n ) : NEW_LINE INDENT f1 = 0 NEW_LINE f2 = 1 NEW_LINE i = 2 ; NEW_LINE while i != 0 : NEW_LINE INDENT f3 = f1 + f2 ; NEW_LINE f1 = f2 ; NEW_LINE f2 = f3 ; NEW_LINE if f2 % k == 0 : NEW_LINE INDENT return n * i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return NEW_LINE DEDENT n = 5 ; NEW_LINE k = 4 ; NEW_LINE print ( \" Position ▁ of ▁ n ' th ▁ multiple ▁ of ▁ k ▁ in \" \" Fibonacci ▁ Seires ▁ is \" , findPosition ( k , n ) ) ; NEW_LINE"],"bleu":0.5955302669692021,"rouge_l":0.8332629207153922}
{"id":710,"predictions":["def printTheArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def generateAllBinaryStrings ( n , arr , i ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT printTheArray ( arr , n ) NEW_LINE return NEW_LINE DEDENT arr [ i ] = 0 NEW_LINE generateAllBinaryStrings ( n , arr , i + 1 ) NEW_LINE arr [ i ] = 1 NEW_LINE generateAllBinaryStrings ( n , arr , i + 1 ) NEW_LINE DEDENT n = 4 NEW_LINE arr = [ 0 ] * n NEW_LINE generateAllBinaryStrings ( n , arr , 0 ) NEW_LINE"],"references":["def printTheArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def generateAllBinaryStrings ( n , arr , i ) : NEW_LINE INDENT if i == n : NEW_LINE INDENT printTheArray ( arr , n ) NEW_LINE return NEW_LINE DEDENT arr [ i ] = 0 NEW_LINE generateAllBinaryStrings ( n , arr , i + 1 ) NEW_LINE arr [ i ] = 1 NEW_LINE generateAllBinaryStrings ( n , arr , i + 1 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 NEW_LINE arr = [ None ] * n NEW_LINE generateAllBinaryStrings ( n , arr , 0 ) NEW_LINE DEDENT"],"bleu":0.824158034471598,"rouge_l":0.917950555356503}
{"id":711,"predictions":["def lcsOf3 ( i , j , k ) : NEW_LINE INDENT if ( i == - 1 or j == - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ j ] [ k ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] [ k ] NEW_LINE DEDENT if ( X [ i ] == Y [ j ] and Y [ j ] == Z [ k ] ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = 1 + lcsOf3 ( i - 1 , j - 1 , k - 1 ) NEW_LINE DEDENT if ( X [ i ] == Y [ j ] and Y [ j ] == Z [ k ] ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = 1 + lcsOf3 ( i - 1 , j - 1 , k - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = max ( max ( lcsOf3 ( i - 1 , j , k ) , lcsOf3 ( i , j , k - 1 ) ) , lcsOf3 ( i , j , k - 1 ) ) NEW_LINE DEDENT DEDENT m = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE o = len ( Z ) NEW_LINE print ( \" Length ▁ of ▁ LCS ▁ is \" , lcsOf3 ( m - 1 , n - 1 , o - 1 ) ) NEW_LINE"],"references":["X = \" AGGT12\" NEW_LINE Y = \"12TXAYB \" NEW_LINE Z = \"12XBA \" NEW_LINE dp = [ [ [ - 1 for i in range ( 100 ) ] for j in range ( 100 ) ] for k in range ( 100 ) ] NEW_LINE def lcsOf3 ( i , j , k ) : NEW_LINE INDENT if ( i == - 1 or j == - 1 or k == - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ j ] [ k ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] [ k ] NEW_LINE DEDENT if ( X [ i ] == Y [ j ] and Y [ j ] == Z [ k ] ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = 1 + lcsOf3 ( i - 1 , j - 1 , k - 1 ) NEW_LINE return dp [ i ] [ j ] [ k ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = max ( max ( lcsOf3 ( i - 1 , j , k ) , lcsOf3 ( i , j - 1 , k ) ) , lcsOf3 ( i , j , k - 1 ) ) NEW_LINE return dp [ i ] [ j ] [ k ] NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT m = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE o = len ( Z ) NEW_LINE print ( \" Length ▁ of ▁ LCS ▁ is \" , lcsOf3 ( m - 1 , n - 1 , o - 1 ) ) NEW_LINE DEDENT"],"bleu":0.7567729284180816,"rouge_l":0.777134348113832}
{"id":712,"predictions":["def checkTriangularSeries ( n ) : NEW_LINE INDENT tri = set ( ) NEW_LINE i = 1 NEW_LINE while ( True ) : NEW_LINE INDENT x = i * ( i + 1 ) \/\/ 2 NEW_LINE if x >= n : NEW_LINE INDENT break NEW_LINE DEDENT tri . add ( x ) NEW_LINE i += 1 NEW_LINE DEDENT for t in tri : NEW_LINE INDENT if ( n - tm ) in tri : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT n = 24 NEW_LINE if ( checkTriangularSumSmallation ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def checkTriangularSumRepresentation ( n ) : NEW_LINE INDENT tri = list ( ) ; NEW_LINE i = 1 ; NEW_LINE while ( 1 ) : NEW_LINE INDENT x = i * ( i + 1 ) \/\/ 2 ; NEW_LINE if ( x >= n ) : NEW_LINE INDENT break ; NEW_LINE DEDENT tri . append ( x ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT for tm in tri : NEW_LINE INDENT if n - tm in tri : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT return False ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 24 ; NEW_LINE if checkTriangularSumRepresentation ( n ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.5494837763148981,"rouge_l":0.8308568598315997}
{"id":713,"predictions":["import math NEW_LINE eps = 1 ; NEW_LINE def getArea ( base , cosenuse ) : NEW_LINE INDENT height = math . sqrt ( hypoten , poweren ) - base * base ; NEW_LINE return 0.5 * base ; NEW_LINE DEDENT def printRightAngleTriangle (inant , area ) : NEW_LINE INDENT hsquare = hypotenuse * xx , PI.0 NEW_LINE maxArea = math . floor ( hsquare \/ 2.0 ) ; NEW_LINE maxArea = getArea ( hsquare , 2.0 ) ; NEW_LINE if ( area > maxArea ) : NEW_LINE INDENT print ( \" Not ▁ possible \" ) ; NEW_LINE return ; NEW_LINE DEDENT lw = 0 ; NEW_LINE hh = sin ( hh \/ 2.0 ) ; NEW_LINE b = 0 ; NEW_LINE while ( abs ( hh - lw ) >= e ) : NEW_LINE INDENT b = ( lw + hh ) \/ 2.0 ; NEW_LINE if ( gh ( b , h_posenuse ) >= area ) : NEW_LINE INDENT hh = b ; NEW_LINE DEDENT else : NEW_LINE INDENT lw = b * - 1 ; NEW_LINE DEDENT DEDENT hight = math . sqrt ( hp ) ; NEW_LINE print ( round ( floor , hh ) , ( hh ) ) ; NEW_LINE"],"references":["import math NEW_LINE def getArea ( base , hypotenuse ) : NEW_LINE INDENT height = math . sqrt ( hypotenuse * hypotenuse - base * base ) ; NEW_LINE return 0.5 * base * height NEW_LINE DEDENT def printRightAngleTriangle ( hypotenuse , area ) : NEW_LINE INDENT hsquare = hypotenuse * hypotenuse NEW_LINE sideForMaxArea = math . sqrt ( hsquare \/ 2.0 ) NEW_LINE maxArea = getArea ( sideForMaxArea , hypotenuse ) NEW_LINE if ( area > maxArea ) : NEW_LINE INDENT print ( \" Not ▁ possiblen \" ) NEW_LINE return NEW_LINE DEDENT low = 0.0 NEW_LINE high = sideForMaxArea NEW_LINE while ( abs ( high - low ) > 1e-6 ) : NEW_LINE INDENT base = ( low + high ) \/ 2.0 NEW_LINE if ( getArea ( base , hypotenuse ) >= area ) : NEW_LINE INDENT high = base NEW_LINE DEDENT else : NEW_LINE INDENT low = base NEW_LINE DEDENT DEDENT height = math . ceil ( math . sqrt ( hsquare - base * base ) ) NEW_LINE base = math . floor ( base ) NEW_LINE print ( base , height ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT hypotenuse = 5 NEW_LINE area = 6 NEW_LINE printRightAngleTriangle ( hypotenuse , area ) NEW_LINE DEDENT"],"bleu":0.40277306931536394,"rouge_l":0.6352706945401639}
{"id":714,"predictions":["def Remainder ( str1 , R ) : NEW_LINE INDENT length = len ( str1 ) NEW_LINE rem = 0 NEW_LINE for i in range ( 0 , length ) : NEW_LINE INDENT Num = rem * 10 + ( ord ( str1 [ i ] ) - ord ( '0' ) ) NEW_LINERem = Num % R NEW_LINE DEDENT return rem NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = \"13589356546756\" NEW_LINE R = 13 NEW_LINE print ( Remainder ( str1 , R ) ) NEW_LINE DEDENT"],"references":["def Remainder ( str , R ) : NEW_LINE INDENT l = len ( str ) NEW_LINE Rem = 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT Num = Rem * 10 + ( ord ( str [ i ] ) - ord ( '0' ) ) NEW_LINE Rem = Num % R NEW_LINE DEDENT return Rem NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \"13589234356546756\" NEW_LINE R = 13 NEW_LINE print ( Remainder ( str , R ) ) NEW_LINE DEDENT"],"bleu":0.6008978079414081,"rouge_l":0.8384879725085909}
{"id":715,"predictions":["def xorGivenSetBits ( arr , n , k ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( bin ( arr [ i ] ) . count ( '1' ) : NEW_LINE INDENT v . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT result = v [ 0 ] NEW_LINE for i in range ( 1 , len ( v ) ) : NEW_LINE INDENT result = result ^ v [ i ] NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 13 , 1 , 19 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE print ( xorGivenSetBits ( arr , n , k ) ) NEW_LINE DEDENT"],"references":["def xorGivenSetBits ( arr , n , k ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( bin ( arr [ i ] ) . count ( '1' ) == k ) : NEW_LINE INDENT v . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT result = v [ 0 ] NEW_LINE for i in range ( 1 , len ( v ) , 1 ) : NEW_LINE INDENT result = result ^ v [ i ] NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 13 , 1 , 19 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE print ( xorGivenSetBits ( arr , n , k ) ) NEW_LINE DEDENT"],"bleu":0.8942055811388594,"rouge_l":0.9588875453446193}
{"id":716,"predictions":["def addBinaryUtil ( a , b ) : NEW_LINE INDENT result = \" \" NEW_LINE s = 0 NEW_LINE i = len ( a ) - 1 NEW_LINE j = len ( b ) - 1 NEW_LINE while ( i >= 0 or j >= 0 or s [ i ] == 1 ) : NEW_LINE INDENT if ( i >= 0 or j >= 0 ) : NEW_LINE INDENT s += int ( b [ i ] ) NEW_LINE DEDENT if ( j >= 0 ) : NEW_LINE INDENT s += int ( b [ j ] ) NEW_LINE DEDENT if ( j >= 0 ) : NEW_LINE INDENT s += int ( b [ j ] ) NEW_LINE DEDENT result = s % 2 + result NEW_LINE s \/= 2 NEW_LINE i -= 1 NEW_LINE j -= 1 NEW_LINE DEDENT return result NEW_LINE DEDENT def addBinary ( arr , n ) : NEW_LINE INDENT result = \" \" NEW_LINE for i in range ( n ) : NEW_LINE INDENT result = addBinaryUtil ( result , arr [ i ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT arr = [ \"1\" , \"10\" , \"11\" ] NEW_LINE n = len ( arr ) NEW_LINE print ( addBinary ( arr , n ) ) NEW_LINE"],"references":["def addBinaryUtil ( a , b ) : NEW_LINE INDENT result = \" \" ; NEW_LINE s = 0 ; NEW_LINE i = len ( a ) - 1 ; NEW_LINE j = len ( b ) - 1 ; NEW_LINE while ( i >= 0 or j >= 0 or s == 1 ) : NEW_LINE INDENT s += ( ord ( a [ i ] ) - ord ( '0' ) ) if ( i >= 0 ) else 0 ; NEW_LINE s += ( ord ( b [ j ] ) - ord ( '0' ) ) if ( j >= 0 ) else 0 ; NEW_LINE result = chr ( s % 2 + ord ( '0' ) ) + result ; NEW_LINE s \/\/= 2 ; NEW_LINE i -= 1 ; NEW_LINE j -= 1 ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT def addBinary ( arr , n ) : NEW_LINE INDENT result = \" \" ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT result = addBinaryUtil ( result , arr [ i ] ) ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT arr = [ \"1\" , \"10\" , \"11\" ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( addBinary ( arr , n ) ) ; NEW_LINE"],"bleu":0.6163309626791545,"rouge_l":0.7964634783257479}
{"id":717,"predictions":["def relativeComplement ( arr1 , arr2 , n , m ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE while ( i < n and j < m ) : NEW_LINE INDENT if ( arr1 [ i ] < arr2 [ j ] ) : NEW_LINE INDENT print ( arr1 [ i ] , end = \" ▁ \" ) NEW_LINE i += 1 NEW_LINE DEDENT elif ( arr1 [ i ] > arr2 [ j ] ) : NEW_LINE INDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT while ( i < n ) : NEW_LINE INDENT print ( arr1 [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT arr1 = [ 3 , 6 , 12 , 13 ] NEW_LINE arr2 = [ 1 , 3 , 5 , 15 ] NEW_LINE n = len ( arr1 ) NEW_LINE relativeComplement ( arr1 , arr2 , n , m ) NEW_LINE"],"references":["def relativeComplement ( arr1 , arr2 , n , m ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE while ( i < n and j < m ) : NEW_LINE INDENT if ( arr1 [ i ] < arr2 [ j ] ) : NEW_LINE INDENT print ( arr1 [ i ] , \" ▁ \" , end = \" \" ) NEW_LINE i += 1 NEW_LINE DEDENT elif ( arr1 [ i ] > arr2 [ j ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT elif ( arr1 [ i ] == arr2 [ j ] ) : NEW_LINE INDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT while ( i < n ) : NEW_LINE INDENT print ( arr1 [ i ] , \" ▁ \" , end = \" \" ) NEW_LINE DEDENT DEDENT arr1 = [ 3 , 6 , 10 , 12 , 15 ] NEW_LINE arr2 = [ 1 , 3 , 5 , 10 , 16 ] NEW_LINE n = len ( arr1 ) NEW_LINE m = len ( arr2 ) NEW_LINE relativeComplement ( arr1 , arr2 , n , m ) NEW_LINE"],"bleu":0.7486195306616136,"rouge_l":0.8586927284138798}
{"id":718,"predictions":["import math as mt NEW_LINE s = \" ABCGAba \" NEW_LINE u = [ 0 for i in range ( 26 ) ] NEW_LINE n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] > 0 ) : NEW_LINE INDENT u [ ord ( s [ i ] ) - ord ( ' A ' ) ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT u [ ord ( s [ i ] ) - ord ( '0' ) ] -= 1 NEW_LINE DEDENT DEDENT f1 = 0 NEW_LINE po = 0 NEW_LINE e = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( u [ i ] > 0 ) : NEW_LINE INDENT po += u [ i ] NEW_LINE DEDENT if ( u [ i ] < 0 ) : NEW_LINE INDENT e += u [ i ] NEW_LINE DEDENT DEDENT if ( po == 0 and e == 0 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT elif ( po == 1 and e == - 1 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"],"references":["s = \" ABCdcba \" NEW_LINE u = [ 0 ] * 26 NEW_LINE n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] . isupper ( ) ) : NEW_LINE INDENT u [ ord ( s [ i ] ) - 65 ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT u [ ord ( s [ i ] ) - 97 ] -= 1 NEW_LINE DEDENT DEDENT fl = True NEW_LINE po = 0 NEW_LINE ne = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( u [ i ] > 0 ) : NEW_LINE INDENT po += u [ i ] NEW_LINE DEDENT if ( u [ i ] < 0 ) : NEW_LINE INDENT ne += u [ i ] NEW_LINE DEDENT DEDENT if ( po == 0 and ne == 0 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT elif ( po == 1 and ne == 0 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT elif ( po == 0 and ne == - 1 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"],"bleu":0.7730624618337097,"rouge_l":0.8449386043725666}
{"id":719,"predictions":["def isPalindrome ( s ) : NEW_LINE INDENT i = 0 NEW_LINE j = len ( s ) - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT if ( s [ i ] != s [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def getIndex ( S1 , S2 , n ) : NEW_LINE INDENT S = \" \" NEW_LINE for i in range ( n ) : NEW_LINE INDENT S = S + S1 [ i ] NEW_LINE Temp = \" \" NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT temp += S2 [ j ] NEW_LINE DEDENT if ( isPalindrome ( S + temp ) ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT S1 = \" abcdf \" NEW_LINE S2 = \" sfgba \" NEW_LINE n = len ( S1 ) NEW_LINE print ( getIndex ( S1 , S2 , n ) ) NEW_LINE"],"references":["def isPalindrome ( s ) : NEW_LINE INDENT i = 0 ; NEW_LINE j = len ( s ) - 1 ; NEW_LINE while ( i < j ) : NEW_LINE INDENT if ( s [ i ] is not s [ j ] ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT i += 1 ; NEW_LINE j -= 1 ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT def getIndex ( S1 , S2 , n ) : NEW_LINE INDENT S = \" \" ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT S = S + S1 [ i ] ; NEW_LINE Temp = \" \" ; NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT Temp += S2 [ j ] ; NEW_LINE DEDENT if ( isPalindrome ( S + Temp ) ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT S1 = \" abcdf \" ; S2 = \" sfgba \" ; NEW_LINE n = len ( S1 ) ; NEW_LINE print ( getIndex ( S1 , S2 , n ) ) ; NEW_LINE"],"bleu":0.7422431207080294,"rouge_l":0.9282840650690921}
{"id":720,"predictions":["def XorSum ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] % 2 != 0 ) : NEW_LINE INDENT result += arr [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT arr = [ 1 , 2 , 6 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( XorSum ( arr , n ) ) NEW_LINE"],"references":["def XorSum ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 != 0 ) : NEW_LINE INDENT result += arr [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT arr = [ 1 , 2 , 6 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( XorSum ( arr , n ) ) NEW_LINE"],"bleu":0.958789574753965,"rouge_l":0.9903362968689602}
{"id":721,"predictions":["def count ( arr , n , x ) : NEW_LINE INDENT if ( x == 1 ) : NEW_LINE INDENT ans = pow ( 2 , n ) - 1 NEW_LINE return ans NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % x == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT ans = int ( pow ( 2 , count ) ) - 1 NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 4 , 3 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE x = 1 NEW_LINE print ( count ( arr , n , x ) ) NEW_LINE DEDENT"],"references":["def count ( arr , n , x ) : NEW_LINE INDENT if ( x == 1 ) : NEW_LINE INDENT ans = pow ( 2 , n ) - 1 NEW_LINE return ans ; NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % x == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT ans = pow ( 2 , count ) - 1 NEW_LINE return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 4 , 3 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE x = 1 NEW_LINE print ( count ( arr , n , x ) ) NEW_LINE DEDENT"],"bleu":0.9127498600313372,"rouge_l":0.9718768859384429}
{"id":722,"predictions":["def removeSpecialCharacter ( string ) : NEW_LINE INDENT s = list ( string ) ; NEW_LINE j = 0 ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( ( s [ i ] >= ' A ' and s [ i ] <= ' Z ' ) or ( s [ i ] >= ' a ' and s [ i ] <= ' z ' ) ) : NEW_LINE INDENT s [ j ] = s [ i ] ; NEW_LINE j += 1 ; NEW_LINE DEDENT DEDENT print ( s ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" $ Gee * k ; s . fo , ▁ r ' Ge ^ eks ? \" ) ; NEW_LINE s . removeSpecialCharacter ( s ) ; NEW_LINE DEDENT"],"references":["def removeSpecialCharacter ( s ) : NEW_LINE INDENT t = \" \" NEW_LINE for i in s : NEW_LINE INDENT if ( i >= ' A ' and i <= ' Z ' ) or ( i >= ' a ' and i <= ' z ' ) : NEW_LINE INDENT t += i NEW_LINE DEDENT DEDENT print ( t ) NEW_LINE DEDENT s = \" $ Gee * k ; s . . fo , ▁ r ' Ge ^ eks ? \" NEW_LINE removeSpecialCharacter ( s ) NEW_LINE"],"bleu":0.3693360495297275,"rouge_l":0.7181622397702799}
{"id":723,"predictions":["import math NEW_LINE def calculate ( a , b , n , m ) : NEW_LINE INDENT mul = 1 ; NEW_LINE for i in range ( m ) : NEW_LINE INDENT if ( b [ i ] != 0 ) : NEW_LINE INDENT mul = mul * b [ i ] ; NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT x = math . floor ( a [ i ] \/ mul ) ; NEW_LINE print ( x , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT a = [ 5 , 100 , 8 ] ; NEW_LINE b = [ 2 , 3 ] ; NEW_LINE n = len ( a ) ; NEW_LINE m = len ( b ) ; NEW_LINE calculate ( a , b , n , m ) ; NEW_LINE"],"references":["import math NEW_LINE def calculate ( a , b , n , m ) : NEW_LINE INDENT mul = 1 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if ( b [ i ] != 0 ) : NEW_LINE INDENT mul = mul * b [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT x = math . floor ( a [ i ] \/ mul ) NEW_LINE print ( x , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT a = [ 5 , 100 , 8 ] NEW_LINE b = [ 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE calculate ( a , b , n , m ) NEW_LINE"],"bleu":0.8442477083623632,"rouge_l":0.9732110965591142}
{"id":724,"predictions":["from math import sqrt NEW_LINE def sieve ( maxEle , prime ) : NEW_LINE INDENT prime [ 0 ] = prime [ 1 ] = 1 NEW_LINE for i in range ( 2 , int ( sqrt ( maxEle ) ) + 1 ) : NEW_LINE INDENT if ( prime [ i ] == 0 ) : NEW_LINE INDENT for j in range ( 2 * i , maxEle + 1 , i ) : NEW_LINE INDENT prime [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT def digitSum ( n ) : NEW_LINE INDENT Sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT Sum += n % 10 NEW_LINE n = int ( n \/ 10 ) NEW_LINE DEDENT sieve ( maxEle , prime ) NEW_LINE sieve ( maxEle , prime ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] == 0 ) : NEW_LINE INDENT Sum = digitSum ( arr [ i ] ) NEW_LINE if ( prime [ Sum ] == 0 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 2 , 4 , 6 , 10 , 12 , 7 ] NEW_LINE n = len ( a ) NEW_LINE printAdditivePrime ( a , n ) NEW_LINE DEDENT"],"references":["from math import sqrt NEW_LINE def sieve ( maxEle , prime ) : NEW_LINE INDENT prime [ 0 ] , prime [ 1 ] = 1 , 1 NEW_LINE for i in range ( 2 , int ( sqrt ( maxEle ) ) + 1 ) : NEW_LINE INDENT if ( not prime [ i ] ) : NEW_LINE INDENT for j in range ( 2 * i , maxEle + 1 , i ) : NEW_LINE INDENT prime [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT def digitSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n ) : NEW_LINE INDENT sum += n % 10 NEW_LINE n = n \/\/ 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT def printAdditivePrime ( arr , n ) : NEW_LINE INDENT maxEle = max ( arr ) NEW_LINE prime = [ 0 ] * ( maxEle + 1 ) NEW_LINE sieve ( maxEle , prime ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] == 0 ) : NEW_LINE INDENT sum = digitSum ( arr [ i ] ) NEW_LINE if ( prime [ sum ] == 0 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 2 , 4 , 6 , 11 , 12 , 18 , 7 ] NEW_LINE n = len ( a ) NEW_LINE printAdditivePrime ( a , n ) NEW_LINE DEDENT"],"bleu":0.7514979500819892,"rouge_l":0.8748669130080791}
{"id":725,"predictions":["def check ( n , m ) : NEW_LINE INDENT if ( m % n == 0 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 NEW_LINE m = 10 NEW_LINE check ( n , m ) NEW_LINE DEDENT"],"references":["def check ( n , m ) : NEW_LINE INDENT if ( m % n == 0 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT n = 5 NEW_LINE m = 10 NEW_LINE check ( n , m ) NEW_LINE"],"bleu":0.7795945368002808,"rouge_l":0.9085445518683042}
{"id":726,"predictions":["import math NEW_LINE def findPowerOfP ( N , p ) : NEW_LINE INDENT count = 0 NEW_LINE r = p NEW_LINE while ( r <= N ) : NEW_LINE INDENT count += ( N \/\/ r ) NEW_LINE r = r * p NEW_LINE DEDENT return count NEW_LINE DEDENT def primeFactorsofB ( B ) : NEW_LINE INDENT ans = [ ] NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT if ( B % i == 0 ) : NEW_LINE INDENT count = 0 NEW_LINE while ( B % i == 0 ) : NEW_LINE INDENT B = B \/ i NEW_LINE count += 1 NEW_LINE DEDENT ans . append ( [ i , count ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def largestPowerOfB ( N , B ) : NEW_LINE INDENT vec = [ ] NEW_LINE vec = primeFactorsofB ( B ) NEW_LINE ans = 10 ** 9 NEW_LINE for i in range ( len ( vec ) ) : NEW_LINE INDENT ans = min ( ans , findPowerOfP ( N , vec [ i ] [ 0 ] ) \/ vec [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT print ( largestPowerOfB ( 5 , 2 ) ) NEW_LINE print ( largestPowerOfB ( N , vec [ i ] [ 0 ] ) ) NEW_LINE print ( largestPowerOfB ( N , vec [ i ] [ 1 ] ) ) NEW_LINE"],"references":["import sys NEW_LINE def findPowerOfP ( N , p ) : NEW_LINE INDENT count = 0 NEW_LINE r = p NEW_LINE while ( r <= N ) : NEW_LINE INDENT count += int ( N \/ r ) NEW_LINE r = r * p NEW_LINE DEDENT return count NEW_LINE DEDENT def primeFactorsofB ( B ) : NEW_LINE INDENT ans = [ ] NEW_LINE i = 2 NEW_LINE while ( B != 1 ) : NEW_LINE INDENT if ( B % i == 0 ) : NEW_LINE INDENT count = 0 NEW_LINE while ( B % i == 0 ) : NEW_LINE INDENT B = int ( B \/ i ) NEW_LINE count += 1 NEW_LINE DEDENT ans . append ( ( i , count ) ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT def largestPowerOfB ( N , B ) : NEW_LINE INDENT vec = [ ] NEW_LINE vec = primeFactorsofB ( B ) NEW_LINE ans = sys . maxsize NEW_LINE ans = min ( ans , int ( findPowerOfP ( N , vec [ 0 ] [ 0 ] ) \/ vec [ 0 ] [ 1 ] ) ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( largestPowerOfB ( 5 , 2 ) ) NEW_LINE print ( largestPowerOfB ( 6 , 9 ) ) NEW_LINE DEDENT"],"bleu":0.7082678654962901,"rouge_l":0.7936881445082705}
{"id":727,"predictions":["def printCombination ( n ) : NEW_LINE INDENT print ( 1 , end = \" ▁ \" ) NEW_LINE if ( ( n - 2 ) % 3 == 0 ) : NEW_LINE INDENT print ( 2 , end = \" ▁ \" ) NEW_LINE if ( n - 3 ) % 3 == 0 ) : NEW_LINE INDENT print ( 1 , n - 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 , ( n - 2 ) ) NEW_LINE DEDENT DEDENT DEDENT n = 2002 NEW_LINE printCombination ( n ) NEW_LINE"],"references":["def printCombination ( n ) : NEW_LINE INDENT print ( \"1 ▁ \" , end = \" \" ) ; NEW_LINE if ( ( n - 2 ) % 3 == 0 ) : NEW_LINE INDENT print ( \"2\" , n - 3 , end = \" \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \"1\" , ( n - 2 ) , end = \" \" ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 233 ; NEW_LINE printCombination ( n ) ; NEW_LINE DEDENT"],"bleu":0.5262580138386377,"rouge_l":0.671}
{"id":728,"predictions":["import math NEW_LINE def createHash ( hash1 , maxElement ) : NEW_LINE INDENT prev = 0 NEW_LINE curr = 1 NEW_LINE hash1 . add ( prev ) NEW_LINE while ( curr <= maxElement ) : NEW_LINE INDENT temp = curr + prev NEW_LINE hash1 . add ( temp ) NEW_LINE prev = curr NEW_LINE curr = temp NEW_LINE DEDENT DEDENT def countFibonacciDivisors ( n ) : NEW_LINE INDENT hash1 = set ( ) NEW_LINE createHash ( hash1 , n ) NEW_LINE cnt = 0 NEW_LINE for i in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( ( n \/\/ i == i ) and ( hash1 . \/\/ i ) in hash1 . keys ( ) ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( n \/\/ i ) in hash1 ( n \/\/ i ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT if ( hash1 . \/\/ i ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT n = 12 NEW_LINE print ( countFibonacciDivisors ( n ) ) NEW_LINE"],"references":["from math import sqrt , ceil , floor NEW_LINE def createHash ( maxElement ) : NEW_LINE INDENT prev = 0 NEW_LINE curr = 1 NEW_LINE d = dict ( ) NEW_LINE d [ prev ] = 1 NEW_LINE d [ curr ] = 1 NEW_LINE while ( curr <= maxElement ) : NEW_LINE INDENT temp = curr + prev NEW_LINE d [ temp ] = 1 NEW_LINE prev = curr NEW_LINE curr = temp NEW_LINE DEDENT return d NEW_LINE DEDENT def countFibonacciDivisors ( n ) : NEW_LINE INDENT hash = createHash ( n ) NEW_LINE cnt = 0 NEW_LINE for i in range ( 1 , ceil ( sqrt ( n ) ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( ( n \/\/ i == i ) and ( n \/\/ i in hash ) ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( n \/\/ i in hash ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT if ( n \/\/ ( n \/\/ i ) in hash ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT n = 12 NEW_LINE print ( countFibonacciDivisors ( n ) ) NEW_LINE"],"bleu":0.6983820603140366,"rouge_l":0.8011345974510413}
{"id":729,"predictions":["MAX = 1000000 NEW_LINE prime = [ True ] * ( MAX + 1 ) NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE prime [ 0 ] = False NEW_LINE for p in range ( MAX + 1 ) : NEW_LINE INDENT if ( p * p >= MAX ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( 2 * MAX , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def SumOfKthPrimes ( arr , n , k ) : NEW_LINE INDENT c = 0 NEW_LINE Sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] ) : NEW_LINE INDENT c += 1 NEW_LINE if ( c % k == 0 ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE c = 0 NEW_LINE DEDENT DEDENT DEDENT print ( Sum ) NEW_LINE DEDENT SieveOfEratosthenes ( ) NEW_LINE arr = [ 2 , 3 , 5 , 7 , 11 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE SumOfKthPrimes ( arr , n , k ) NEW_LINE"],"references":["MAX = 100000 ; NEW_LINE prime = [ True ] * ( MAX + 1 ) ; NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 1 ] = False ; NEW_LINE prime [ 0 ] = False ; NEW_LINE p = 2 ; NEW_LINE while ( p * p <= MAX ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT i = p * 2 ; NEW_LINE while ( i <= MAX ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE i += p ; NEW_LINE DEDENT DEDENT p += 1 ; NEW_LINE DEDENT DEDENT def SumOfKthPrimes ( arr , n , k ) : NEW_LINE INDENT c = 0 ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] ) : NEW_LINE INDENT c += 1 ; NEW_LINE if ( c % k == 0 ) : NEW_LINE INDENT sum += arr [ i ] ; NEW_LINE c = 0 ; NEW_LINE DEDENT DEDENT DEDENT print ( sum ) ; NEW_LINE DEDENT SieveOfEratosthenes ( ) ; NEW_LINE arr = [ 2 , 3 , 5 , 7 , 11 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE k = 2 ; NEW_LINE SumOfKthPrimes ( arr , n , k ) ; NEW_LINE"],"bleu":0.6468491635807028,"rouge_l":0.8278948888247184}
{"id":730,"predictions":["def sieveOfEratosthenes ( N , s ) : NEW_LINE INDENT prime = [ False ] * ( N + 1 ) NEW_LINE for i in range ( 2 , N + 1 , 2 ) : NEW_LINE INDENT s [ i ] = 2 NEW_LINE DEDENT for i in range ( 3 , N + 1 , 2 ) : NEW_LINE INDENT if ( prime [ i ] == False ) : NEW_LINE INDENT s [ i ] = i NEW_LINE for j in range ( i , ( N + 1 ) \/\/ 2 , 2 ) : NEW_LINE INDENT if ( prime [ i * j ] == False ) : NEW_LINE INDENT prime [ i * j ] = True NEW_LINE s [ i * j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT def generatePrimeFactors ( N ) : NEW_LINE INDENT s = [ 0 ] * ( N + 1 ) NEW_LINE sieveOfEratosthenes ( N , s ) NEW_LINE print ( \"Factor ▁ Power \" ) NEW_LINE curr = s [ N ] NEW_LINE cnt = 1 NEW_LINE while ( N > 1 ) : NEW_LINE INDENT N \/\/= s [ N ] NEW_LINE if ( curr == s [ N ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE continue NEW_LINE DEDENT print ( curr ) NEW_LINE curr = s [ N ] NEW_LINE cnt = 1 NEW_LINE DEDENT DEDENT N = 350 NEW_LINE generatePrimeFactors ( N ) NEW_LINE"],"references":["def sieveOfEratosthenes ( N , s ) : NEW_LINE INDENT prime = [ False ] * ( N + 1 ) NEW_LINE for i in range ( 2 , N + 1 , 2 ) : NEW_LINE INDENT s [ i ] = 2 NEW_LINE DEDENT for i in range ( 3 , N + 1 , 2 ) : NEW_LINE INDENT if ( prime [ i ] == False ) : NEW_LINE INDENT s [ i ] = i NEW_LINE for j in range ( i , int ( N \/ i ) + 1 , 2 ) : NEW_LINE INDENT if ( prime [ i * j ] == False ) : NEW_LINE INDENT prime [ i * j ] = True NEW_LINE s [ i * j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def generatePrimeFactors ( N ) : NEW_LINE INDENT s = [ 0 ] * ( N + 1 ) NEW_LINE sieveOfEratosthenes ( N , s ) NEW_LINE print ( \" Factor ▁ Power \" ) NEW_LINE curr = s [ N ] NEW_LINE cnt = 1 NEW_LINE while ( N > 1 ) : NEW_LINE INDENT N \/\/= s [ N ] NEW_LINE if ( curr == s [ N ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE continue NEW_LINE DEDENT print ( str ( curr ) + \" \\t \" + str ( cnt ) ) NEW_LINE curr = s [ N ] NEW_LINE cnt = 1 NEW_LINE DEDENT DEDENT N = 360 NEW_LINE generatePrimeFactors ( N ) NEW_LINE"],"bleu":0.8891224145881499,"rouge_l":0.9454310623183727}
{"id":731,"predictions":["import math NEW_LINE def nearest ( n ) : NEW_LINE INDENT prevSquare = math . sqrt ( n ) NEW_LINE nextSquare = prevSquare + 1 NEW_LINE prevSquare = prevSquare * prevSquare NEW_LINE nextSquare = nextSquare * nextSquare NEW_LINE if ( n - prevSquare ) < ( nextSquare - n ) : NEW_LINE INDENT return prevSquare - n NEW_LINE DEDENT else : NEW_LINE INDENT return ( nextSquare - n ) NEW_LINE DEDENT DEDENT n = 14 NEW_LINE print ( nearest ( n ) ) NEW_LINE n = 16 NEW_LINE print ( nearest ( n ) ) NEW_LINE"],"references":["from math import sqrt NEW_LINE def nearest ( n ) : NEW_LINE INDENT prevSquare = int ( sqrt ( n ) ) ; NEW_LINE nextSquare = prevSquare + 1 ; NEW_LINE prevSquare = prevSquare * prevSquare ; NEW_LINE nextSquare = nextSquare * nextSquare ; NEW_LINE ans = ( prevSquare - n ) if ( n - prevSquare ) < ( nextSquare - n ) else ( nextSquare - n ) ; NEW_LINE return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 14 ; NEW_LINE print ( nearest ( n ) ) ; NEW_LINE n = 16 ; NEW_LINE print ( nearest ( n ) ) ; NEW_LINE n = 18 ; NEW_LINE print ( nearest ( n ) ) ; NEW_LINE DEDENT"],"bleu":0.43491970700369476,"rouge_l":0.6789092932665554}
{"id":732,"predictions":["def checkIfSortRotated ( arr , n ) : NEW_LINE INDENT minEle = sys . maxsize NEW_LINE maxEle = - 1 NEW_LINE minIndex = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < minEle ) : NEW_LINE INDENT minEle = arr [ i ] NEW_LINE minIndex = i NEW_LINE DEDENT DEDENT flag1 = True NEW_LINE for i in range ( 1 , minIndex , 1 ) : NEW_LINE INDENT if ( arr [ i ] < arr [ i - 1 ] ) : NEW_LINE INDENT flag1 = False NEW_LINE break NEW_LINE DEDENT DEDENT flag2 = True NEW_LINE for i in range ( minIndex + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] < arr [ i - 1 ] ) : NEW_LINE INDENT flag2 = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( minIndex == 0 ) : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE return NEW_LINE DEDENT if ( flag1 and flag2 and ( arr [ n - 1 ] < arr [ minIndex - 1 ] ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT arr = [ 3 , 4 , 5 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE checkIfSortRotated ( arr , n ) NEW_LINE"],"references":["import sys NEW_LINE def checkIfSortRotated ( arr , n ) : NEW_LINE INDENT minEle = sys . maxsize NEW_LINE maxEle = - sys . maxsize - 1 NEW_LINE minIndex = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] < minEle : NEW_LINE INDENT minEle = arr [ i ] NEW_LINE minIndex = i NEW_LINE DEDENT DEDENT flag1 = 1 NEW_LINE for i in range ( 1 , minIndex ) : NEW_LINE INDENT if arr [ i ] < arr [ i - 1 ] : NEW_LINE INDENT flag1 = 0 NEW_LINE break NEW_LINE DEDENT DEDENT flag2 = 2 NEW_LINE for i in range ( minIndex + 1 , n ) : NEW_LINE INDENT if arr [ i ] < arr [ i - 1 ] : NEW_LINE INDENT flag2 = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag1 and flag2 and arr [ n - 1 ] < arr [ minIndex - 1 ] ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT arr = [ 3 , 4 , 5 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE checkIfSortRotated ( arr , n ) NEW_LINE"],"bleu":0.7841104513910501,"rouge_l":0.91182842287695}
{"id":733,"predictions":["def printSquares ( n ) : NEW_LINE INDENT square = 0 ; prev_x = 0 ; NEW_LINE for x in range ( n ) : NEW_LINE INDENT square = ( square + x + prev_x ) ; NEW_LINE print ( square , end = \" ▁ \" ) ; NEW_LINE hull_x = x ; NEW_LINE DEDENT DEDENT n = 5 ; NEW_LINE printSquares ( n ) ; NEW_LINE"],"references":["def printSquares ( n ) : NEW_LINE INDENT square = 0 ; prev_x = 0 ; NEW_LINE for x in range ( 0 , n ) : NEW_LINE INDENT square = ( square + x + prev_x ) NEW_LINE print ( square , end = \" ▁ \" ) NEW_LINE prev_x = x NEW_LINE DEDENT DEDENT n = 5 ; NEW_LINE printSquares ( n ) ; NEW_LINE"],"bleu":0.8405007352564599,"rouge_l":0.9494163424124513}
{"id":734,"predictions":["from math import gcd , sqrt NEW_LINE def solvePromini ( a , b1 , b2 , c ) : NEW_LINE INDENT A = a * b2 NEW_LINE B = b1 * b2 NEW_LINE C = b1 * c NEW_LINE gcd = gcd ( gcd ( A , B ) , C ) NEW_LINE print ( A \/\/ gcd , \" : \" , B \/\/ gcd , \" : \" , C \/\/ gcd ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 3 NEW_LINE b1 = 4 NEW_LINE b2 = 8 NEW_LINE c = 9 NEW_LINE solveProascal ( a , b1 , b2 , c ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def solveProportion ( a , b1 , b2 , c ) : NEW_LINE INDENT A = a * b2 NEW_LINE B = b1 * b2 NEW_LINE C = b1 * c NEW_LINE gcd1 = math . gcd ( math . gcd ( A , B ) , C ) NEW_LINE print ( str ( A \/\/ gcd1 ) + \" : \" + str ( B \/\/ gcd1 ) + \" : \" + str ( C \/\/ gcd1 ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 3 NEW_LINE b1 = 4 NEW_LINE b2 = 8 NEW_LINE c = 9 NEW_LINE solveProportion ( a , b1 , b2 , c ) NEW_LINE DEDENT"],"bleu":0.6879091814006295,"rouge_l":0.8352831693698485}
{"id":735,"predictions":["def countPairs ( arr , N ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT mp [ arr [ i ] ] = mp . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT maxFreq = 0 NEW_LINE for key , value in mp . items ( ) : NEW_LINE INDENT maxFreq = max ( maxFreq , mp [ key ] ) NEW_LINE DEDENT print ( N - maxFreq ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 8 , 5 , 9 , 8 , 7 , 5 , 7 , 5 , 7 , 7 ] NEW_LINE N = len ( arr ) NEW_LINE countPairs ( arr , N ) NEW_LINE DEDENT"],"references":["def countPairs ( arr , N ) : NEW_LINE INDENT M = dict . fromkeys ( arr , 0 ) ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT M [ arr [ i ] ] += 1 ; NEW_LINE DEDENT maxFreq = 0 ; NEW_LINE for it in M . values ( ) : NEW_LINE INDENT maxFreq = max ( maxFreq , it ) ; NEW_LINE DEDENT print ( N - maxFreq ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 8 , 5 , 9 , 8 , 8 , 7 , 7 , 5 , 7 , 7 ] ; NEW_LINE N = len ( arr ) ; NEW_LINE countPairs ( arr , N ) ; NEW_LINE DEDENT"],"bleu":0.6312600394057561,"rouge_l":0.815064443656143}
{"id":736,"predictions":["def numberOfSubarrays ( arr , n ) : NEW_LINE INDENT v = [ 0 for i in range ( n + 1 ) ] NEW_LINE v [ 0 ] = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT v [ i + 1 ] = v [ i ] + arr [ i ] NEW_LINE DEDENT m = dict ( ) NEW_LINE begin = 0 NEW_LINE answer = 0 NEW_LINE while ( begin < n ) : NEW_LINE INDENT while ( end < n and not v [ end + 1 ] ) : NEW_LINE INDENT end += 1 NEW_LINE if v [ end + 1 ] in m : NEW_LINE INDENT end += 1 NEW_LINE DEDENT else : NEW_LINE INDENT end += 1 NEW_LINE DEDENT answer = answer + end - begin NEW_LINE mp [ begin ] = 1 NEW_LINE DEDENT print ( answer ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 4 , - 6 ] NEW_LINE size = len ( arr ) NEW_LINE numberOfSubarrays ( arr , size ) NEW_LINE DEDENT"],"references":["def numberOfSubarrays ( arr , n ) : NEW_LINE INDENT v = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT v [ i + 1 ] = v [ i ] + arr [ i ] NEW_LINE DEDENT mp = { } NEW_LINE begin , end , answer = 0 , 0 , 0 NEW_LINE mp [ 0 ] = 1 NEW_LINE while ( begin < n ) : NEW_LINE INDENT while ( end < n and ( v [ end + 1 ] ) not in mp ) : NEW_LINE INDENT end += 1 NEW_LINE mp [ v [ end ] ] = 1 NEW_LINE DEDENT answer = answer + end - begin NEW_LINE del mp [ v [ begin ] ] NEW_LINE begin += 1 NEW_LINE DEDENT print ( answer ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 4 , - 6 ] NEW_LINE size = len ( arr ) NEW_LINE numberOfSubarrays ( arr , size ) NEW_LINE DEDENT"],"bleu":0.7438736755944185,"rouge_l":0.8082991892598727}
{"id":737,"predictions":["def minimizeDiff ( arr , n , k ) : NEW_LINE INDENT max = max ( arr ) NEW_LINE min = min ( arr ) NEW_LINE if ( ( max - min ) <= k ) : NEW_LINE INDENT return ( max - min ) NEW_LINE DEDENT avg = ( max + min ) \/\/ 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > avg ) : NEW_LINE INDENT arr [ i ] -= k NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] += k NEW_LINE DEDENT DEDENT maxs = max ( arr ) NEW_LINE min = min ( arr ) NEW_LINE return ( max - min ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 16 , 12 , 9 , 20 ] NEW_LINE n = 5 NEW_LINE k = 3 NEW_LINE print ( \" Max ▁ height ▁ = ▁ \" , minimizeDiff ( arr , n , k ) ) NEW_LINE DEDENT"],"references":["def minimizeDiff ( arr , n , k ) : NEW_LINE INDENT max_element = max ( arr ) NEW_LINE min_element = min ( arr ) NEW_LINE if ( ( max_element - min_element ) <= k ) : NEW_LINE INDENT return ( max_element - min_element ) NEW_LINE DEDENT avg = ( max_element + min_element ) \/\/ 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > avg ) : NEW_LINE INDENT arr [ i ] -= k NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] += k NEW_LINE DEDENT DEDENT max_element = max ( arr ) NEW_LINE min_element = min ( arr ) NEW_LINE return ( max_element - min_element ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 16 , 12 , 9 , 20 ] NEW_LINE n = 5 NEW_LINE k = 3 NEW_LINE print ( \" Max ▁ height ▁ difference ▁ = \" , minimizeDiff ( arr , n , k ) ) NEW_LINE DEDENT"],"bleu":0.7873539622243121,"rouge_l":0.9101992539350378}
{"id":738,"predictions":["from collections import defaultdict NEW_LINE class Graph : NEW_LINE INDENT def __init__ ( self , v ) : NEW_LINE INDENT self . graph = defaultdict ( list ) NEW_LINE DEDENT def addEdge ( u , v ) : NEW_LINE INDENT self . graph [ u ] . append ( v ) NEW_LINE DEDENT def BFS ( s ) : NEW_LINE INDENT visited = [ False for i in range ( V ) ] NEW_LINE q = Queue ( ) NEW_LINE visit [ s ] = True NEW_LINE queue . add ( s ) NEW_LINE while ( len ( queue ) != 0 ) : NEW_LINE INDENT s = queue [ s ] NEW_LINE print ( s , end = \" ▁ \" ) NEW_LINE while ( len ( queue ) != 0 ) : NEW_LINE INDENT if ( visited [ n ] ) : NEW_LINE INDENT visited [ n ] = True NEW_LINE queue . pop ( ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT g = Graph ( ) NEW_LINE g . addEdge ( 0 , 1 ) NEW_LINE g . addEdge ( 0 , 2 ) NEW_LINE g . addEdge ( 1 , 2 ) NEW_LINE g . addEdge ( 2 , 0 ) NEW_LINE g . addEdge ( 3 ) NEW_LINE g . addEdge ( 3 , 3 ) NEW_LINE g . addEdge ( 2 , 0 ) NEW_LINE g . BFS ( 2 ) NEW_LINE g . addEdge ( 3 ) NEW_LINE print ( \" Following ▁ is ▁ SI ▁ from ▁ ( starting ▁ from ▁ vertex ▁ 2 ) NEW_LINE g . BFS ( 2 ) NEW_LINE DEDENT"],"references":["from collections import defaultdict NEW_LINE class Graph : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . graph = defaultdict ( list ) NEW_LINE DEDENT def addEdge ( self , u , v ) : NEW_LINE INDENT self . graph [ u ] . append ( v ) NEW_LINE DEDENT def BFS ( self , s ) : NEW_LINE INDENT visited = [ False ] * ( len ( self . graph ) ) NEW_LINE queue = [ ] NEW_LINE queue . append ( s ) NEW_LINE visited [ s ] = True NEW_LINE while queue : NEW_LINE INDENT s = queue . pop ( 0 ) NEW_LINE print ( s , end = \" ▁ \" ) NEW_LINE for i in self . graph [ s ] : NEW_LINE INDENT if visited [ i ] == False : NEW_LINE INDENT queue . append ( i ) NEW_LINE visited [ i ] = True NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT g = Graph ( ) NEW_LINE g . addEdge ( 0 , 1 ) NEW_LINE g . addEdge ( 0 , 2 ) NEW_LINE g . addEdge ( 1 , 2 ) NEW_LINE g . addEdge ( 2 , 0 ) NEW_LINE g . addEdge ( 2 , 3 ) NEW_LINE g . addEdge ( 3 , 3 ) NEW_LINE print ( \" Following ▁ is ▁ Breadth ▁ First ▁ Traversal \" \" ▁ ( starting ▁ from ▁ vertex ▁ 2 ) \" ) NEW_LINE g . BFS ( 2 ) NEW_LINE"],"bleu":0.6469280991371898,"rouge_l":0.7438117302767956}
{"id":739,"predictions":["import math NEW_LINE def cal ( n ) : NEW_LINE INDENT res = pow ( math . ceil ( ( pow ( 10 , ( n - 1 ) ) , 1 \/ 4 ) ) ; NEW_LINE return res ; NEW_LINE DEDENT n = 1 ; NEW_LINE print ( cal ( n ) ) ; NEW_LINE"],"references":["from math import * NEW_LINE def cal ( n ) : NEW_LINE INDENT res = pow ( ceil ( ( pow ( pow ( 10 , ( n - 1 ) ) , 1 \/ 4 ) ) ) , 4 ) NEW_LINE return int ( res ) NEW_LINE DEDENT n = 1 NEW_LINE print ( cal ( n ) ) NEW_LINE"],"bleu":0.6685350472061593,"rouge_l":0.8340169537872574}
{"id":740,"predictions":["def bit ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT count += 1 NEW_LINE n = n & ( n - 1 ) NEW_LINE DEDENT return count NEW_LINE DEDENT def maxSumOfBits ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = bin ( arr [ i ] ) . count ( '1' ) NEW_LINE DEDENTInc = arr [ 0 ] NEW_LINE excl = 0 NEW_LINE excl = 0 NEW_LINE excl = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT excl += arr [ i ] NEW_LINE excl = expcl + arr [ i ] NEW_LINE excl = excl + arr [ i ] NEW_LINE DEDENT if ( >= excl ) : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 4 , 5 , 6 , 7 , 20 , 25 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxSumOfBits ( arr , n ) ) NEW_LINE"],"references":["def bit ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT count += 1 NEW_LINE n = n & ( n - 1 ) NEW_LINE DEDENT return count NEW_LINE DEDENT def maxSumOfBits ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = bit ( arr [ i ] ) NEW_LINE DEDENT incl = arr [ 0 ] NEW_LINE excl = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if incl > excl : NEW_LINE INDENT excl_new = incl NEW_LINE DEDENT else : NEW_LINE INDENT excl_new = excl NEW_LINE DEDENT incl = excl + arr [ i ] ; NEW_LINE excl = excl_new NEW_LINE DEDENT if incl > excl : NEW_LINE INDENT return incl NEW_LINE DEDENT else : NEW_LINE INDENT return excl NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 5 , 6 , 7 , 20 , 25 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxSumOfBits ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.6982464896252354,"rouge_l":0.7982829040593481}
{"id":741,"predictions":["import math NEW_LINE def subsetXOR ( arr , n , K ) : NEW_LINE INDENT max_ele = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > max_ele ) : NEW_LINE INDENT max_ele = arr [ i ] NEW_LINE DEDENT DEDENT m = ( 1 << ( math . log2 ( max_ele ) + 1 ) ) - 1 NEW_LINE dp = [ [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( m + 1 ) : NEW_LINE INDENT for k in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = dp [ i - 1 ] [ j ] [ k ] NEW_LINE if ( k != 0 ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] += k * dp [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans += dp [ n ] [ K ] [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 2 , 3 ] NEW_LINE k = 1 NEW_LINE n = len ( arr ) NEW_LINE print ( subsetXOR ( arr , n , k ) ) NEW_LINE"],"references":["from math import log2 NEW_LINE def subsetXOR ( arr , n , K ) : NEW_LINE INDENT max_ele = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > max_ele ) : NEW_LINE INDENT max_ele = arr [ i ] NEW_LINE DEDENT DEDENT m = ( 1 << int ( log2 ( max_ele ) + 1 ) ) - 1 NEW_LINE dp = [ [ [ 0 for i in range ( n + 1 ) ] for j in range ( m + 1 ) ] for k in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( m + 1 ) : NEW_LINE INDENT for k in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = 0 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( m + 1 ) : NEW_LINE INDENT for k in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = dp [ i - 1 ] [ j ] [ k ] NEW_LINE if ( k != 0 ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] += k * dp [ i - 1 ] [ j ^ arr [ i - 1 ] ] [ k - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans += dp [ n ] [ K ] [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 ] NEW_LINE k = 1 NEW_LINE n = len ( arr ) NEW_LINE print ( subsetXOR ( arr , n , k ) ) NEW_LINE DEDENT"],"bleu":0.7660385460971473,"rouge_l":0.8709068300096716}
{"id":742,"predictions":["def MaximumHeight ( a , n ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT y = ( i * ( i + 1 ) ) \/ 2 NEW_LINE if ( y < n ) : NEW_LINE INDENT result = i NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 40 , 100 , 20 , 30 ] NEW_LINE n = len ( arr ) NEW_LINE print ( MaximumHeight ( arr , n ) ) NEW_LINE DEDENT"],"references":["def MaximumHeight ( a , n ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT y = ( i * ( i + 1 ) ) \/ 2 NEW_LINE if ( y < n ) : NEW_LINE INDENT result = i NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT arr = [ 40 , 100 , 20 , 30 ] NEW_LINE n = len ( arr ) NEW_LINE print ( MaximumHeight ( arr , n ) ) NEW_LINE"],"bleu":0.8275398947160965,"rouge_l":0.9354317998385796}
{"id":743,"predictions":["def toNegativeBase ( n , negBase ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return \"0\" ; NEW_LINE DEDENT convert = \" \" ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT remainder = n % negBase ; NEW_LINE n \/= negBase ; NEW_LINE if ( remainder < 0 ) : NEW_LINE INDENT remainder += ( - negBase ) ; NEW_LINE n += 1 ; NEW_LINE DEDENT convert = str ( remainder ) + convert ; NEW_LINE DEDENT return convert ; NEW_LINE DEDENT n = 13 ; NEW_LINE negBase = - 2 ; NEW_LINE print ( toNegativeBase ( n , negBase ) ) ; NEW_LINE"],"references":["def toNegativeBase ( n , negBase ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return \"0\" NEW_LINE DEDENT converted = \"01\" NEW_LINE while ( n != 0 ) : NEW_LINE INDENT remainder = n % ( negBase ) NEW_LINE n = int ( n \/ negBase ) NEW_LINE if ( remainder < 0 ) : NEW_LINE INDENT remainder += ( ( - 1 ) * negBase ) NEW_LINE n += 1 NEW_LINE DEDENT converted = str ( remainder ) + converted NEW_LINE DEDENT return converted NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 13 NEW_LINE negBase = - 2 NEW_LINE print ( toNegativeBase ( n , negBase ) ) NEW_LINE DEDENT"],"bleu":0.5365955771446722,"rouge_l":0.7771232876712328}
{"id":744,"predictions":["m , n = 6 , 4 ; NEW_LINE def compareRow ( a1 , a2 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( a1 [ i ] < a2 [ i ] ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT elif ( a1 [ i ] > a2 [ i ] ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT DEDENT return 0 ; NEW_LINE DEDENT def binaryCheck ( ar , arr ) : NEW_LINE INDENT l = 0 ; r = m - 1 ; NEW_LINE while ( l <= r ) : NEW_LINE INDENT mid = int ( ( l + r ) \/ 2 ) \/ 2 ) ; NEW_LINE temp = compareRow ( ar [ mid ] , arr ) ; NEW_LINE if ( temp == 0 ) : NEW_LINE INDENT return mid + 1 ; NEW_LINE DEDENT elif ( temp == 1 ) : NEW_LINE INDENT l = mid + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT r = mid - 1 ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT mat = [ [ 0 , 0 , 1 , 0 ] , [ 10 , 9 , 22 , 23 ] , [ 40 , 40 , 40 , 40 ] , [ 40 , 40 , 40 , 40 ] , [ 43 , 44 , 55 ] , [ 90 , 75 , 133 , 133 ] ] ; NEW_LINE row = [ 10 , 9 , 22 , 23 ] ; NEW_LINE print ( binarySearch ( mat , row ) ) ; NEW_LINE DEDENT"],"references":["m = 6 ; NEW_LINE n = 4 ; NEW_LINE def compareRow ( a1 , a2 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( a1 [ i ] < a2 [ i ] ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT elif ( a1 [ i ] > a2 [ i ] ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT DEDENT return 0 ; NEW_LINE DEDENT def binaryCheck ( ar , arr ) : NEW_LINE INDENT l = 0 ; r = m - 1 ; NEW_LINE while ( l <= r ) : NEW_LINE INDENT mid = ( l + r ) \/\/ 2 ; NEW_LINE temp = compareRow ( ar [ mid ] , arr ) ; NEW_LINE if ( temp == 0 ) : NEW_LINE INDENT return mid + 1 ; NEW_LINE DEDENT elif ( temp == 1 ) : NEW_LINE INDENT l = mid + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT r = mid - 1 ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT mat = [ [ 0 , 0 , 1 , 0 ] , [ 10 , 9 , 22 , 23 ] , [ 40 , 40 , 40 , 40 ] , [ 43 , 44 , 55 , 68 ] , [ 81 , 73 , 100 , 132 ] , [ 100 , 75 , 125 , 133 ] ] ; NEW_LINE row = [ 10 , 9 , 22 , 23 ] ; NEW_LINE print ( binaryCheck ( mat , row ) ) ; NEW_LINE DEDENT"],"bleu":0.8889407144747655,"rouge_l":0.9365333028936703}
{"id":745,"predictions":["def longestSubArray ( arr , n ) : NEW_LINE INDENT isZeroPresent = False NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT isZeroPresent = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( isZeroPresent ) : NEW_LINE INDENT return n NEW_LINE DEDENT return 0 NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 0 , 1 , 2 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE print ( longestSubArray ( arr , n ) ) NEW_LINE"],"references":["def longestSubArray ( arr , n ) : NEW_LINE INDENT isZeroPresent = False NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT isZeroPresent = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( isZeroPresent ) : NEW_LINE INDENT return n NEW_LINE DEDENT return 0 NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 0 , 1 , 2 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE print ( longestSubArray ( arr , n ) ) NEW_LINE"],"bleu":0.9630273502353404,"rouge_l":0.9875990354805374}
{"id":746,"predictions":["def PrintMinNumberForPattern ( arr ) : NEW_LINE INDENT curr_max = 0 NEW_LINE last_print = 0 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT noOfNextD = 0 NEW_LINE if ( arr [ i ] == ' I ' ) : NEW_LINE INDENT j = i + 1 NEW_LINE while ( j < len ( arr ) and arr [ j ] == ' D ' ) : NEW_LINE INDENT noOfNextD += 1 NEW_LINE j += 1 NEW_LINE DEDENT if ( i == 0 ) : NEW_LINE INDENT curr_max = noOfNextD + 2 NEW_LINE print ( \" { } ▁ { } \" . format ( last_max ) ) NEW_LINE last_max = curr_max NEW_LINE DEDENT else : NEW_LINE INDENT curr_max = curr_max + 1 NEW_LINE last_left = curr_max NEW_LINE print ( \" { } ▁ { } \" . format ( last_max ) , prev_max ) NEW_LINE DEDENT for k in range ( next_max ) : NEW_LINE INDENT print ( \" { } ▁ { } \" . format ( curr_max ) ) NEW_LINE DEDENT curr_max = curr_max + 1 NEW_LINE print ( \" ▁ \" , last_max ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" { } ▁ \" . format ( curr_max ) , curr_max ) NEW_LINE last_end = curr_max NEW_LINE print ( \" ▁ \" , prev_max ) NEW_LINE DEDENT DEDENT printMinNumberForPattern ( arr ) NEW_LINE"],"references":["def PrintMinNumberForPattern ( arr ) : NEW_LINE INDENT curr_max = 0 NEW_LINE last_entry = 0 NEW_LINE i = 0 NEW_LINE while i < len ( arr ) : NEW_LINE INDENT noOfNextD = 0 NEW_LINE if arr [ i ] == \" I \" : NEW_LINE INDENT j = i + 1 NEW_LINE while j < len ( arr ) and arr [ j ] == \" D \" : NEW_LINE INDENT noOfNextD += 1 NEW_LINE j += 1 NEW_LINE DEDENT if i == 0 : NEW_LINE INDENT curr_max = noOfNextD + 2 NEW_LINE last_entry += 1 NEW_LINE print ( \" \" , last_entry , end = \" \" ) NEW_LINE print ( \" \" , curr_max , end = \" \" ) NEW_LINE last_entry = curr_max NEW_LINE DEDENT else : NEW_LINE INDENT curr_max += noOfNextD + 1 NEW_LINE last_entry = curr_max NEW_LINE print ( \" \" , last_entry , end = \" \" ) NEW_LINE DEDENT for k in range ( noOfNextD ) : NEW_LINE INDENT last_entry -= 1 NEW_LINE print ( \" \" , last_entry , end = \" \" ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT elif arr [ i ] == \" D \" : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT j = i + 1 NEW_LINE while j < len ( arr ) and arr [ j ] == \" D \" : NEW_LINE INDENT noOfNextD += 1 NEW_LINE j += 1 NEW_LINE DEDENT curr_max = noOfNextD + 2 NEW_LINE print ( \" \" , curr_max , curr_max - 1 , end = \" \" ) NEW_LINE last_entry = curr_max - 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" \" , last_entry - 1 , end = \" \" ) NEW_LINE last_entry -= 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT print ( ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT PrintMinNumberForPattern ( \" IDID \" ) NEW_LINE PrintMinNumberForPattern ( \" I \" ) NEW_LINE PrintMinNumberForPattern ( \" DD \" ) NEW_LINE PrintMinNumberForPattern ( \" II \" ) NEW_LINE PrintMinNumberForPattern ( \" DIDI \" ) NEW_LINE PrintMinNumberForPattern ( \" IIDDD \" ) NEW_LINE PrintMinNumberForPattern ( \" DDIDDIID \" ) NEW_LINE DEDENT"],"bleu":0.2879748357498209,"rouge_l":0.5148215681166971}
{"id":747,"predictions":["def findNumber ( n ) : NEW_LINE INDENT i = 1 NEW_LINE while i <= n : NEW_LINE INDENT print ( 3 * i * ( i - 1 ) + 1 , end = \" ▁ \" ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT n = 4 NEW_LINE findNumber ( n ) NEW_LINE"],"references":["def findNumbers ( n ) : NEW_LINE INDENT i = 1 NEW_LINE while ( i <= n ) : NEW_LINE INDENT print ( ( 3 * i * ( i - 1 ) + 1 ) , end = \" ▁ \" ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT n = 4 NEW_LINE findNumbers ( n ) NEW_LINE"],"bleu":0.7592880369944072,"rouge_l":0.923978279508431}
{"id":748,"predictions":["MOD = 1000000007 NEW_LINE def number_of_ways ( arr , n , k ) : NEW_LINE INDENT if ( k == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT dp = [ - 1 ] * ( k + 1 ) NEW_LINE dp [ 0 ] = 1 NEW_LINE if ( dp [ 1 ] == - 1 ) : NEW_LINE INDENT dp [ 1 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 1 ] = 1 NEW_LINE DEDENT for i in range ( 2 , k + 1 ) : NEW_LINE INDENT if ( dp [ i ] == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] NEW_LINE dp [ i ] %= MOD NEW_LINE DEDENT return dp [ k ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 ] NEW_LINE n = len ( arr ) NEW_LINE k = 6 NEW_LINE print ( number_of_ways ( arr , n , k ) ) NEW_LINE DEDENT"],"references":["MOD = 1000000007 ; NEW_LINE def number_of_ways ( arr , n , k ) : NEW_LINE INDENT if ( k == 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT dp = [ - 1 ] * ( k + 1 ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ arr [ i ] ] = 0 ; NEW_LINE DEDENT dp [ 0 ] = 1 ; NEW_LINE dp [ 1 ] = 1 if ( dp [ 1 ] == - 1 ) else dp [ 1 ] ; NEW_LINE for i in range ( 2 , k + 1 ) : NEW_LINE INDENT if ( dp [ i ] == 0 ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] ; NEW_LINE dp [ i ] %= MOD ; NEW_LINE DEDENT return dp [ k ] ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE k = 6 ; NEW_LINE print ( number_of_ways ( arr , n , k ) ) ; NEW_LINE DEDENT"],"bleu":0.7033696940681002,"rouge_l":0.8359552384041518}
{"id":749,"predictions":["def maxProfit ( prices , n , k ) : NEW_LINE INDENT profit = [ [ 0 for i in range ( k + 1 ) ] for j in range ( k + 1 ) ] NEW_LINE for i in range ( k + 1 ) : NEW_LINE INDENT profit [ 0 ] [ i ] = 0 NEW_LINE DEDENT for i in range ( 1 , k + 1 ) : NEW_LINE INDENT prevDiff = - 1 NEW_LINE for j in range ( 1 , n ) : NEW_LINE INDENT prevDiff = max ( prevDiff , profit [ i - 1 ] [ j - 1 ] - prices [ j - 1 ] ) NEW_LINE profit [ i ] [ j ] = max ( profit [ i ] [ j - 1 ] , prices [ j ] + prevDiff ) NEW_LINE DEDENT DEDENT return profit [ n - 1 ] [ k ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT k = 3 NEW_LINE prices = [ 12 , 14 , 17 , 10 , 14 , 13 , 12 , 15 ] NEW_LINE n = len ( prices ) NEW_LINE print ( \" Maximum ▁ profit ▁ is : \" , maxProfit ( prices , n , k ) ) NEW_LINE DEDENT"],"references":["def maxProfit ( price , n , k ) : NEW_LINE INDENT profit = [ [ 0 for i in range ( n + 1 ) ] for j in range ( k + 1 ) ] NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT prevDiff = float ( ' - inf ' ) NEW_LINE for j in range ( 1 , n ) : NEW_LINE INDENT prevDiff = max ( prevDiff , profit [ i - 1 ] [ j - 1 ] - price [ j - 1 ] ) NEW_LINE profit [ i ] [ j ] = max ( profit [ i ] [ j - 1 ] , price [ j ] + prevDiff ) NEW_LINE DEDENT DEDENT return profit [ k ] [ n - 1 ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT k = 3 NEW_LINE price = [ 12 , 14 , 17 , 10 , 14 , 13 , 12 , 15 ] NEW_LINE n = len ( price ) NEW_LINE print ( \" Maximum ▁ profit ▁ is : \" , maxProfit ( price , n , k ) ) NEW_LINE DEDENT"],"bleu":0.7724936387992976,"rouge_l":0.882173846856447}
{"id":750,"predictions":["def originalArray ( greater , n ) : NEW_LINE INDENT temp = [ ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT temp . append ( i ) NEW_LINE DEDENT arr = [ 0 ] * n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT k = n - greater [ i ] - i NEW_LINE arr [ i ] = temp [ k ] NEW_LINE temp . remove ( k ) NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 6 , 3 , 2 , 1 , 0 , 1 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE originalArray ( arr , n ) NEW_LINE"],"references":["def originalArray ( greater , n ) : NEW_LINE INDENT temp = [ ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT temp . append ( i ) NEW_LINE DEDENT arr = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT k = n - greater [ i ] - i NEW_LINE arr [ i ] = temp [ k ] NEW_LINE del temp [ k ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 6 , 3 , 2 , 1 , 0 , 1 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE originalArray ( arr , n ) NEW_LINE"],"bleu":0.84777116211732,"rouge_l":0.9166666666666665}
{"id":751,"predictions":["MAX = 1000 ; NEW_LINE f = [ 0 ] * MAX ; NEW_LINE def fib ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( n == 1 or n == 2 ) : NEW_LINE INDENT f [ n ] = 1 ; NEW_LINE return f [ n ] ; NEW_LINE DEDENT k = ( n + 1 ) \/\/ 2 if ( n & 1 ) else ( n \/\/ 2 ) ; NEW_LINE f [ n ] = ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) * fib ( k ) ; NEW_LINE return f [ n ] ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 9 ; NEW_LINE f = [ 0 ] * MAX ; NEW_LINE print ( fib ( n ) ) ; NEW_LINE DEDENT"],"references":["MAX = 1000 NEW_LINE f = [ 0 ] * MAX NEW_LINE def fib ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 1 or n == 2 ) : NEW_LINE INDENT f [ n ] = 1 NEW_LINE return ( f [ n ] ) NEW_LINE DEDENT if ( f [ n ] ) : NEW_LINE INDENT return f [ n ] NEW_LINE DEDENT if ( n & 1 ) : NEW_LINE INDENT k = ( n + 1 ) \/\/ 2 NEW_LINE DEDENT else : NEW_LINE INDENT k = n \/\/ 2 NEW_LINE DEDENT if ( ( n & 1 ) ) : NEW_LINE INDENT f [ n ] = ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT f [ n ] = ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ) NEW_LINE DEDENT return f [ n ] NEW_LINE DEDENT n = 9 NEW_LINE print ( fib ( n ) ) NEW_LINE"],"bleu":0.5573991724606443,"rouge_l":0.6966603218549923}
{"id":752,"predictions":["def getCount ( l , r , p ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE val = p ; NEW_LINE while ( True ) : NEW_LINE INDENT a = r \/\/ val ; NEW_LINE b = ( l - 1 ) \/\/ val ; NEW_LINE val *= p ; NEW_LINE if ( ( a - b ) > 0 ) : NEW_LINE INDENT cnt += ( a - b ) ; NEW_LINE DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT return cnt ; NEW_LINE DEDENT l = 2 ; r = 8 ; p = 2 ; NEW_LINE print ( getCount ( l , r , p ) ) ; NEW_LINE"],"references":["def getCount ( l , r , p ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE val = p ; NEW_LINE while ( True ) : NEW_LINE INDENT a = r \/\/ val ; NEW_LINE b = ( l - 1 ) \/\/ val ; NEW_LINE val *= p ; NEW_LINE if ( a - b ) : NEW_LINE INDENT cnt += ( a - b ) ; NEW_LINE DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT return int ( cnt ) ; NEW_LINE DEDENT l = 2 ; NEW_LINE r = 8 ; NEW_LINE p = 2 ; NEW_LINE print ( getCount ( l , r , p ) ) ; NEW_LINE"],"bleu":0.9005796873052203,"rouge_l":0.9602893206637355}
{"id":753,"predictions":["def findMaxLen ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE stk = [ ] NEW_LINE result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str [ i ] == ' ( ' ) : NEW_LINE INDENT stk . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT stk . pop ( 0 ) NEW_LINE if ( len ( stk ) ) : NEW_LINE INDENT result = max ( result , i - stk [ - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT stk . append ( i ) NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" ( ( ) ) \" NEW_LINE print ( findMaxLen ( str ) ) NEW_LINE str = \" ( ( ) ( ) ) ) ) \" NEW_LINE print ( findMaxLen ( str ) ) NEW_LINE print ( findMaxLen ( str ) ) NEW_LINE DEDENT"],"references":["def findMaxLen ( string ) : NEW_LINE INDENT n = len ( string ) NEW_LINE stk = [ ] NEW_LINE stk . append ( - 1 ) NEW_LINE result = 0 NEW_LINE for i in xrange ( n ) : NEW_LINE INDENT if string [ i ] == ' ( ' : NEW_LINE INDENT stk . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT stk . pop ( ) NEW_LINE if len ( stk ) != 0 : NEW_LINE INDENT result = max ( result , i - stk [ len ( stk ) - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT stk . append ( i ) NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT string = \" ( ( ( ) ( ) \" NEW_LINE print findMaxLen ( string ) NEW_LINE string = \" ( ) ( ( ) ) ) ) ) \" NEW_LINE print findMaxLen ( string ) NEW_LINE"],"bleu":0.6282633567663594,"rouge_l":0.8049763271884759}
{"id":754,"predictions":["def print binomial ( max ) : NEW_LINE INDENT for m in range ( 0 , max + 1 ) : NEW_LINE INDENT print ( m , end = \" ▁ \" ) NEW_LINE blue = 1 NEW_LINE for x in range ( 0 , m + 1 ) : NEW_LINE INDENT if ( m != 0 and x != 0 ) : NEW_LINE INDENT blue = black * ( m - x + 1 ) \/ x NEW_LINE DEDENT print ( b , end = \" ▁ \" ) NEW_LINE DEDENT print ( \" \\n \" , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE"],"references":["def printbinomial ( max ) : NEW_LINE INDENT for m in range ( max + 1 ) : NEW_LINE INDENT print ( ' % ▁ 2d ' % m , end = ' ▁ ' ) NEW_LINE binom = 1 NEW_LINE for x in range ( m + 1 ) : NEW_LINE INDENT if m != 0 and x != 0 : NEW_LINE INDENT binom = binom * ( m - x + 1 ) \/ x NEW_LINE DEDENT print ( ' % ▁ 4d ' % binom , end = ' ▁ ' ) NEW_LINE DEDENT print ( \" \\n \" , end = ' ' ) NEW_LINE DEDENT DEDENT max = 10 NEW_LINE printbinomial ( max ) NEW_LINE"],"bleu":0.5667713654205524,"rouge_l":0.7823819591261452}
{"id":755,"predictions":["def getmax ( arr , n , x ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = s + arr [ i ] NEW_LINE DEDENT print ( min ( s , x ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE x = 5 NEW_LINE arr_size = len ( arr ) NEW_LINE getmax ( arr , arr_size , x ) NEW_LINE DEDENT"],"references":["def getmax ( arr , n , x ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = s + arr [ i ] NEW_LINE DEDENT print ( min ( s , x ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE x = 5 NEW_LINE arr_size = len ( arr ) NEW_LINE getmax ( arr , arr_size , x ) NEW_LINE DEDENT"],"bleu":1.0,"rouge_l":1.0}
{"id":756,"predictions":["def isPossible ( w , h , x , y ) : NEW_LINE INDENT if ( x * 2 == w and y * 2 == h ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT w = 1 ; h = 2 ; x = 1 ; y = 2 ; NEW_LINE if ( isPossible ( w , h , x , y ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"],"references":["def isPossible ( w , h , x , y ) : NEW_LINE INDENT if ( x * 2 == w and y * 2 == h ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT w = 1 NEW_LINE h = 2 NEW_LINE x = 1 NEW_LINE y = 2 NEW_LINE if ( isPossible ( w , h , x , y ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.7634550856946439,"rouge_l":0.9341500765696785}
{"id":757,"predictions":["def d DGx ( x , y0 , x , h ) : NEW_LINE INDENT return ( x + y - 2 ) \/\/ h NEW_LINE DEDENT def removegeKutta ( x0 , y0 , x , h ) : NEW_LINE INDENT n = int ( ( x - x0 ) \/ h ) NEW_LINE k1 = y0 NEW_LINE k2 = y0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT k1 = h * dyy ( x0 , y ) NEW_LINE k2 = h * d NEW_LINE y = h + ( 1.5 * h , y + 0.5 * k1 ) NEW_LINE y = y + ( 1.5 * k2 ) * ( k1 + 2 * k2 ) NEW_LINE x0 = x0 + h NEW_LINE DEDENT return y NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x0 = 0 NEW_LINE y = 1 NEW_LINE x = 2 NEW_LINE h = 0.2 NEW_LINE print ( round ( rungeKutta ( x0 , y , x , h ) , 4 ) ) NEW_LINE DEDENT"],"references":["def dydx ( x , y ) : NEW_LINE INDENT return ( x + y - 2 ) ; NEW_LINE DEDENT def rungeKutta ( x0 , y0 , x , h ) : NEW_LINE INDENT n = round ( ( x - x0 ) \/ h ) ; NEW_LINE y = y0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT k1 = h * dydx ( x0 , y ) ; NEW_LINE k2 = h * dydx ( x0 + 0.5 * h , y + 0.5 * k1 ) ; NEW_LINE y = y + ( 1.0 \/ 6.0 ) * ( k1 + 2 * k2 ) ; NEW_LINE x0 = x0 + h ; NEW_LINE DEDENT return y ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x0 = 0 ; y = 1 ; NEW_LINE x = 2 ; h = 0.2 ; NEW_LINE print ( \" y ( x ) ▁ = \" , rungeKutta ( x0 , y , x , h ) ) ; NEW_LINE DEDENT"],"bleu":0.6109624535130621,"rouge_l":0.8102770252556147}
{"id":758,"predictions":["MAX_CHAR = 26 NEW_LINE def countPalindrome ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE sum = 0 NEW_LINE hashTable = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( n ) : NEW_LINE INDENT hashTable [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( hashTable [ i ] != 0 ) : NEW_LINE INDENT sum += ( hashTable [ i ] * ( hashTable [ i ] + 1 ) \/\/ 2 ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" ananananddd \" NEW_LINE print ( countPalindrome ( str ) ) NEW_LINE DEDENT"],"references":["MAX_CHAR = 26 NEW_LINE def countPalindrome ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE sum = 0 NEW_LINE hashTable = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( n ) : NEW_LINE INDENT hashTable [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( hashTable [ i ] ) : NEW_LINE INDENT sum += ( hashTable [ i ] * ( hashTable [ i ] + 1 ) \/\/ 2 ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" ananananddd \" NEW_LINE print ( countPalindrome ( str ) ) NEW_LINE DEDENT"],"bleu":0.974441961964121,"rouge_l":0.9940091061586388}
{"id":759,"predictions":["def __gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return __gcd ( a - b , b ) NEW_LINE DEDENT return __gcd ( a , b - a ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT m = 60 NEW_LINE n = 60 NEW_LINE print ( NumberOfSquares ( m , n ) ) NEW_LINE DEDENT"],"references":["def __gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a ; NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return __gcd ( a - b , b ) ; NEW_LINE DEDENT return __gcd ( a , b - a ) ; NEW_LINE DEDENT def NumberOfSquares ( x , y ) : NEW_LINE INDENT s = __gcd ( x , y ) ; NEW_LINE ans = ( x * y ) \/ ( s * s ) ; NEW_LINE return int ( ans ) ; NEW_LINE DEDENT m = 385 ; NEW_LINE n = 60 ; NEW_LINE print ( NumberOfSquares ( m , n ) ) ; NEW_LINE"],"bleu":0.5371761047383639,"rouge_l":0.7324185248713551}
{"id":760,"predictions":["def divisibilityCheck ( arr , n ) : NEW_LINE INDENT s = [ ] NEW_LINE max_ele = - 10 ** 9 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT s . append ( arr [ i ] ) NEW_LINE max_ele = max ( max_ele , arr [ i ] ) NEW_LINE DEDENT res = set ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] != 0 ) : NEW_LINE INDENT for j in range ( arr [ i ] * 2 , max_ele + 1 , arr [ i ] ) : NEW_LINE INDENT if ( s [ j ] != 0 ) : NEW_LINE INDENT res . add ( j ) NEW_LINE DEDENT DEDENT DEDENT res . reverse ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( res [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 2 , 3 , 8 , 6 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE divisibilityCheck ( arr , n ) NEW_LINE"],"references":["import math as mt NEW_LINE def divisibilityCheck ( arr , n ) : NEW_LINE INDENT s = dict ( ) NEW_LINE max_ele = - 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s [ arr [ i ] ] = 1 NEW_LINE max_ele = max ( max_ele , arr [ i ] ) NEW_LINE DEDENT res = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] != 0 ) : NEW_LINE INDENT for j in range ( arr [ i ] * 2 , max_ele + 1 , arr [ i ] ) : NEW_LINE INDENT if ( j in s . keys ( ) ) : NEW_LINE INDENT res [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT for x in res : NEW_LINE INDENT print ( x , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 2 , 3 , 8 , 6 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE divisibilityCheck ( arr , n ) NEW_LINE"],"bleu":0.7451324140143,"rouge_l":0.8372651625632667}
{"id":761,"predictions":["def leftRotate ( arr , d , n ) : NEW_LINE INDENT d = d % n NEW_LINE i , j , k = 0 , 0 , 0 NEW_LINE for i in range ( g_c_d ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE j = i NEW_LINE while ( True ) : NEW_LINE INDENT k = j + d NEW_LINE if ( k >= n ) : NEW_LINE INDENT k = k - n NEW_LINE DEDENT if ( k == i ) : NEW_LINE INDENT break NEW_LINE DEDENT arr [ j ] = arr [ k ] NEW_LINE j = k NEW_LINE DEDENT arr [ j ] = temp NEW_LINE DEDENT DEDENT def printArray ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] NEW_LINE size = len ( arr ) NEW_LINE leftRotate ( arr , 2 , 7 ) NEW_LINE printArray ( arr , 7 ) NEW_LINE"],"references":["def leftRotate ( arr , d , n ) : NEW_LINE INDENT d = d % n NEW_LINE g_c_d = gcd ( d , n ) NEW_LINE for i in range ( g_c_d ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE j = i NEW_LINE while 1 : NEW_LINE INDENT k = j + d NEW_LINE if k >= n : NEW_LINE INDENT k = k - n NEW_LINE DEDENT if k == i : NEW_LINE INDENT break NEW_LINE DEDENT arr [ j ] = arr [ k ] NEW_LINE j = k NEW_LINE DEDENT arr [ j ] = temp NEW_LINE DEDENT DEDENT def printArray ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( \" % ▁ d \" % arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT def gcd ( a , b ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT return a ; NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( b , a % b ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE d = 2 NEW_LINE leftRotate ( arr , d , n ) NEW_LINE printArray ( arr , n ) NEW_LINE"],"bleu":0.6678318859325699,"rouge_l":0.800865143811186}
{"id":762,"predictions":["def isCorrectOrder ( n ) : NEW_LINE INDENT flag = True NEW_LINE prev = - 1 NEW_LINE type = - 1 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT if ( type == - 1 ) : NEW_LINE INDENT if ( prev == - 1 ) : NEW_LINE INDENT prev = n % 10 NEW_LINE n = n % 10 NEW_LINE continue NEW_LINE DEDENT if ( prev == n % 10 ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT if ( prev > n % 10 ) : NEW_LINE INDENT type = 1 NEW_LINE prev = n % 10 NEW_LINE n = n \/\/ 10 NEW_LINE continue NEW_LINE DEDENT prev = n % 10 NEW_LINE n = n \/\/ 10 NEW_LINE DEDENT else : NEW_LINE INDENT if ( prev == n % 10 ) : NEW_LINE INDENT flag = false NEW_LINE break NEW_LINE DEDENT if ( prev == n % 10 ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT prev = n % 10 NEW_LINE n = n \/\/ 10 NEW_LINE DEDENT DEDENT return flag NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 123454321 NEW_LINE if ( isCorrectOrder ( n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"references":["def isCorrectOrder ( n ) : NEW_LINE INDENT flag = True ; NEW_LINE prev = - 1 ; NEW_LINE type = - 1 ; NEW_LINE while ( n != 0 ) : NEW_LINE INDENT if ( type == - 1 ) : NEW_LINE INDENT if ( prev == - 1 ) : NEW_LINE INDENT prev = n % 10 ; NEW_LINE n = int ( n \/ 10 ) ; NEW_LINE continue ; NEW_LINE DEDENT if ( prev == n % 10 ) : NEW_LINE INDENT flag = False ; NEW_LINE break ; NEW_LINE DEDENT if ( prev > n % 10 ) : NEW_LINE INDENT type = 1 ; NEW_LINE prev = n % 10 ; NEW_LINE n = int ( n \/ 10 ) ; NEW_LINE continue ; NEW_LINE DEDENT prev = n % 10 ; NEW_LINE n = int ( n \/ 10 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( prev == n % 10 ) : NEW_LINE INDENT flag = False ; NEW_LINE break ; NEW_LINE DEDENT if ( prev < n % 10 ) : NEW_LINE INDENT flag = False ; NEW_LINE break ; NEW_LINE DEDENT prev = n % 10 ; NEW_LINE n = int ( n \/ 10 ) ; NEW_LINE DEDENT DEDENT return flag ; NEW_LINE DEDENT n = 123454321 ; NEW_LINE if ( isCorrectOrder ( n ) ) : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE DEDENT"],"bleu":0.6516235914042436,"rouge_l":0.8659113628790402}
{"id":763,"predictions":["def K_multiple ( a , n , k ) : NEW_LINE INDENT a = sorted ( a ) ; NEW_LINE s = set ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( a [ i ] % k == 0 and not in s ) or a [ i ] % k != 0 ) : NEW_LINE INDENT s . add ( a [ i ] ) ; NEW_LINE DEDENT DEDENT for i in s : NEW_LINE INDENT print ( i , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" ) : NEW_LINE INDENT a = [ 2 , 3 , 4 , 5 , 6 , 10 ] ; NEW_LINE k = 2 ; NEW_LINE n = len ( a ) ; NEW_LINE K_multiple ( a , n , k ) ; NEW_LINE DEDENT"],"references":["def K_multiple ( a , n , k ) : NEW_LINE INDENT a . sort ( ) ; NEW_LINE s = set ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( a [ i ] % k == 0 and a [ i ] \/\/ k not in s ) or a [ i ] % k != 0 ) : NEW_LINE INDENT s . add ( a [ i ] ) ; NEW_LINE DEDENT DEDENT for i in s : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 2 , 3 , 4 , 5 , 6 , 10 ] ; NEW_LINE k = 2 ; NEW_LINE n = len ( a ) ; NEW_LINE K_multiple ( a , n , k ) ; NEW_LINE DEDENT"],"bleu":0.9069754607596926,"rouge_l":0.9568127156749975}
{"id":764,"predictions":["import numpy as np NEW_LINE maxN = 20 NEW_LINE maxM = 10 NEW_LINE dp = np . zeros ( ( maxN , maxM ) ) ; NEW_LINE v = np . zeros ( ( maxN , maxM ) ) ; NEW_LINE def findCnt ( arr , i , curr , n , m ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT if ( curr == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT if ( v [ i ] [ curr ] ) : NEW_LINE INDENT return dp [ i ] [ curr ] ; NEW_LINE DEDENT v [ i ] [ curr ] = 1 ; NEW_LINE dp [ i ] [ curr ] = 1 ; NEW_LINE return dp [ i ] [ curr ] ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 3 , 3 , 3 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE m = 6 ; NEW_LINE print ( findCnt ( arr , 0 , n , m ) - 1 ) ; NEW_LINE DEDENT"],"references":["maxN = 20 NEW_LINE maxM = 10 NEW_LINE dp = [ [ 0 for i in range ( maxN ) ] for i in range ( maxM ) ] NEW_LINE v = [ [ 0 for i in range ( maxN ) ] for i in range ( maxM ) ] NEW_LINE def findCnt ( arr , i , curr , n , m ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT if ( curr == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if ( v [ i ] [ curr ] ) : NEW_LINE INDENT return dp [ i ] [ curr ] NEW_LINE DEDENT v [ i ] [ curr ] = 1 NEW_LINE dp [ i ] [ curr ] = findCnt ( arr , i + 1 , curr , n , m ) +   \\ NEW_LINE INDENT findCnt ( arr , i + 1 , ( curr + arr [ i ] ) % m , n , m ) NEW_LINE DEDENT return dp [ i ] [ curr ] NEW_LINE DEDENT arr = [ 3 , 3 , 3 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE m = 6 NEW_LINE print ( findCnt ( arr , 0 , 0 , n , m ) - 1 ) NEW_LINE"],"bleu":0.579311393794334,"rouge_l":0.7223448072962635}
{"id":765,"predictions":["def minSteps ( str ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( str ) - 2 ) : NEW_LINE INDENT if ( str [ i ] == '0' ) : NEW_LINE INDENT if ( str [ i + 1 ] == '1' ) : NEW_LINE INDENT if ( str [ i + 2 ] == '1' ) : NEW_LINE INDENT count += 1 NEW_LINE i += 2 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT str = \"0101010\" NEW_LINE print ( minSteps ( str ) ) NEW_LINE"],"references":["def minSteps ( str ) : NEW_LINE INDENT count = 0 NEW_LINE i = 0 NEW_LINE while i < len ( str ) - 2 : NEW_LINE INDENT if str [ i ] == '0' : NEW_LINE INDENT if ( str [ i + 1 ] == '1' ) : NEW_LINE INDENT if ( str [ i + 2 ] == '0' ) : NEW_LINE INDENT count = count + 1 NEW_LINE i = i + 2 NEW_LINE DEDENT DEDENT DEDENT i = i + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT str = \"0101010\" NEW_LINE print ( minSteps ( str ) ) NEW_LINE"],"bleu":0.6994343024554481,"rouge_l":0.8473606798496486}
{"id":766,"predictions":["def checkSemiprime ( num ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE i = 2 ; NEW_LINE while ( cnt < 2 and i * i <= num ) : NEW_LINE INDENT while ( num % i == 0 ) : NEW_LINE INDENT num \/= i ; NEW_LINE cnt += 1 ; NEW_LINE DEDENT if ( num > 1 ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT return cnt == 2 ; NEW_LINE DEDENT defSemiprime ( n ) : NEW_LINE INDENT if ( checkSemiprime ( n ) ) : NEW_LINE INDENT print ( \" True \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" False \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 6 ; NEW_LINESemiprime ( n ) ; NEW_LINE n = 8 ; NEW_LINESemiprime ( n ) ; NEW_LINE DEDENT"],"references":["import math NEW_LINE def checkSemiprime ( num ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( 2 , int ( math . sqrt ( num ) ) + 1 ) : NEW_LINE INDENT while num % i == 0 : NEW_LINE INDENT num \/= i NEW_LINE cnt += 1 NEW_LINE DEDENT if cnt >= 2 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( num > 1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT return cnt == 2 NEW_LINE DEDENT def semiprime ( n ) : NEW_LINE INDENT if checkSemiprime ( n ) == True : NEW_LINE INDENT print ( \" True \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" False \" ) NEW_LINE DEDENT DEDENT n = 6 NEW_LINE semiprime ( n ) NEW_LINE n = 8 NEW_LINE semiprime ( n ) ; NEW_LINE"],"bleu":0.5429739191245914,"rouge_l":0.7353499274472596}
{"id":767,"predictions":["def XandYandZintercept ( A , B , C , D ) : NEW_LINE INDENT x = 0 NEW_LINE y = 0 NEW_LINE z = - D \/ A NEW_LINE x = - D \/ B NEW_LINE y = - d \/ B NEW_LINE z = - D \/ C \/ B NEW_LINE return [ x , y ] NEW_LINE DEDENT def equation_plane ( p , q , r , p ) : NEW_LINE INDENT x1 = p [ 0 ] NEW_LINE y = p [ 1 ] NEW_LINE z1 = p [ 0 ] NEW_LINE x2 = q [ 0 ] NEW_LINE y2 = q [ 1 ] NEW_LINE z3 = r [ 2 ] NEW_LINE a1 = x2 - x1 NEW_LINE b2 = y3 - y1 NEW_LINE c1 = z2 - z1 NEW_LINE a2 = x3 - x1 NEW_LINE b2 = y3 - y1 NEW_LINE c2 = z3 - z1 NEW_LINE b2 = z3 - z1 NEW_LINE A = b1 * c2 - b2 * c1 NEW_LINE d = ( - A * x1 - b * y1 - c2 * z1 ) NEW_LINE D = ( - A * x1 - B * y1 - b2 * y1 - c2 * z1 ) NEW_LINE return ( XandY * x1 - B * y1 - B * y1 - C1 ) NEW_LINE D = XandYandZintercept ( A , B , C , D ) NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT print ( x [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x1 = - 1 NEW_LINE y0 = 2 NEW_LINE z1 = 0 NEW_LINE x2 = 0 NEW_LINE y2 = - 3 NEW_LINE x1 = 2 NEW_LINE y2 = 1 NEW_LINE x2 = 3 NEW_LINE y2 = 1 NEW_LINE z2 = - 4 NEW_LINE x3 = - 4 NEW_LINE y3 = - 4 NEW_LINE x3 = 3 NEW_"],"references":["def XandYandZintercept ( A , B , C , D ) : NEW_LINE INDENT x = - D \/ A NEW_LINE y = - D \/ B NEW_LINE z = - D \/ C NEW_LINE return [ x , y , z ] NEW_LINE DEDENT def equation_plane ( p , q , r ) : NEW_LINE INDENT x1 = p [ 0 ] NEW_LINE y1 = p [ 1 ] NEW_LINE z1 = p [ 2 ] NEW_LINE x2 = q [ 0 ] NEW_LINE y2 = q [ 1 ] NEW_LINE z2 = q [ 2 ] NEW_LINE x3 = r [ 0 ] NEW_LINE y3 = r [ 1 ] NEW_LINE z3 = r [ 2 ] NEW_LINE a1 = x2 - x1 NEW_LINE b1 = y2 - y1 NEW_LINE c1 = z2 - z1 NEW_LINE a2 = x3 - x1 NEW_LINE b2 = y3 - y1 NEW_LINE c2 = z3 - z1 NEW_LINE A = b1 * c2 - b2 * c1 NEW_LINE B = a2 * c1 - a1 * c2 NEW_LINE C = a1 * b2 - b1 * a2 NEW_LINE D = ( - A * x1 - B * y1 - C * z1 ) NEW_LINE print ( XandYandZintercept ( A , B , C , D ) ) NEW_LINE DEDENT x1 = - 1 NEW_LINE y1 = 2 NEW_LINE z1 = 1 NEW_LINE x2 = 0 NEW_LINE y2 = - 3 NEW_LINE z2 = 2 NEW_LINE x3 = 1 NEW_LINE y3 = 1 NEW_LINE z3 = - 4 NEW_LINE equation_plane ( ( x1 , y1 , z1 ) , ( x2 , y2 , z2 ) , ( x3 , y3 , z3 ) ) NEW_LINE"],"bleu":0.5683868547239608,"rouge_l":0.6957673387750689}
{"id":768,"predictions":["def mulmod ( a , b , mod ) : NEW_LINE INDENT res = 0 NEW_LINE a = a % mod NEW_LINE while ( b ) : NEW_LINE INDENT if ( b % 2 == 1 ) : NEW_LINE INDENT res = ( res + a ) % mod NEW_LINE DEDENT a = ( a * 2 ) % mod NEW_LINE b \/= 2 NEW_LINE DEDENT return res % mod NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a , b , mod = 9223372036854775807 NEW_LINE print ( mulmod ( a , b , 100000000 ) ) NEW_LINE DEDENT"],"references":["def mulmod ( a , b , mod ) : NEW_LINE INDENT res = 0 ; NEW_LINE a = a % mod ; NEW_LINE while ( b > 0 ) : NEW_LINE INDENT if ( b % 2 == 1 ) : NEW_LINE INDENT res = ( res + a ) % mod ; NEW_LINE DEDENT a = ( a * 2 ) % mod ; NEW_LINE b \/\/= 2 ; NEW_LINE DEDENT return res % mod ; NEW_LINE DEDENT a = 9223372036854775807 ; NEW_LINE b = 9223372036854775807 ; NEW_LINE print ( mulmod ( a , b , 100000000000 ) ) ; NEW_LINE"],"bleu":0.6503374160402517,"rouge_l":0.8346964454230891}
{"id":769,"predictions":["MAX_CHAR = 26 NEW_LINE def sortString ( str ) : NEW_LINE INDENT letters = [ 0 ] * MAX_CHAR NEW_LINE for x in str : NEW_LINE INDENT letters [ ord ( x ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 0 , MAX_CHAR ) : NEW_LINE INDENT for j in range ( 0 , letters [ i ] ) : NEW_LINE INDENT print ( chr ( i + ord ( ' a ' ) ) , end = ' ' ) NEW_LINE DEDENT DEDENT sortString ( \" geeksforgeeks \" ) NEW_LINE"],"references":["MAX_CHAR = 26 NEW_LINE def sortString ( str ) : NEW_LINE INDENT charCount = [ 0 for i in range ( MAX_CHAR ) ] NEW_LINE for i in range ( 0 , len ( str ) , 1 ) : NEW_LINE INDENT charCount [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 0 , MAX_CHAR , 1 ) : NEW_LINE INDENT for j in range ( 0 , charCount [ i ] , 1 ) : NEW_LINE INDENT print ( chr ( ord ( ' a ' ) + i ) , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" geeksforgeeks \" NEW_LINE sortString ( s ) NEW_LINE DEDENT"],"bleu":0.4465771917719492,"rouge_l":0.7028938064685086}
{"id":770,"predictions":["def pentagon_pyramidal ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT p = ( 3 * i * i - i ) \/ 2 NEW_LINE sum = sum + p NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 4 NEW_LINE print ( int ( pentagon_pyramidal ( n ) ) ) NEW_LINE"],"references":["def pentagon_pyramidal ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT p = ( 3 * i * i - i ) \/ 2 NEW_LINE sum = sum + p NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 4 NEW_LINE print ( int ( pentagon_pyramidal ( n ) ) ) NEW_LINE"],"bleu":1.0,"rouge_l":1.0}
{"id":771,"predictions":["def count ( n ) : NEW_LINE INDENT table = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT table [ 0 ] = 0 NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT table [ i ] += table [ i - 3 ] NEW_LINE DEDENT for i in range ( 10 , n + 1 ) : NEW_LINE INDENT for j in range ( 8 , i - 10 ) : NEW_LINE INDENT table [ i ] += table [ i - 5 ] NEW_LINE DEDENT DEDENT return table [ n ] NEW_LINE DEDENT n = 20 NEW_LINE print ( \" Count ▁ for ▁ \" , n , \" is \" , count ( n ) ) NEW_LINE n = 12 NEW_LINE print ( \" Count ▁ for \" , n , \" ▁ is \" , count ( n ) ) NEW_LINE"],"references":["def count ( n ) : NEW_LINE INDENT table = [ 0 for i in range ( n + 1 ) ] NEW_LINE table [ 0 ] = 1 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT table [ i ] += table [ i - 3 ] NEW_LINE DEDENT for i in range ( 5 , n + 1 ) : NEW_LINE INDENT table [ i ] += table [ i - 5 ] NEW_LINE DEDENT for i in range ( 10 , n + 1 ) : NEW_LINE INDENT table [ i ] += table [ i - 10 ] NEW_LINE DEDENT return table [ n ] NEW_LINE DEDENT n = 20 NEW_LINE print ( ' Count ▁ for ' , n , ' is ' , count ( n ) ) NEW_LINE n = 13 NEW_LINE print ( ' Count ▁ for ' , n , ' is ' , count ( n ) ) NEW_LINE"],"bleu":0.7202849767610928,"rouge_l":0.8032625786163522}
{"id":772,"predictions":["MAX = 26 NEW_LINE def max_element ( freq ) : NEW_LINE INDENT max_ele = freq [ 0 ] NEW_LINE for i in range ( 0 , MAX ) : NEW_LINE INDENT if ( max_ele < freq [ i ] ) : NEW_LINE INDENT max_ele = freq [ i ] NEW_LINE DEDENT DEDENT def minimumAddition ( st , length ) : NEW_LINE INDENT freq = [ 0 ] * MAX NEW_LINE for i in range ( 0 , length ) : NEW_LINE INDENT freq [ ord ( st [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT maxFreq = max ( freq ) NEW_LINE minAddition = 0 NEW_LINE for i in range ( 0 , MAX ) : NEW_LINE INDENT if ( freq [ i ] > 0 ) : NEW_LINE INDENT minAddition += abs ( maxFreq - freq [ i ] ) NEW_LINE DEDENT DEDENT return minAddition NEW_LINE DEDENT st = \" geeksforgeeks \" NEW_LINE l = len ( st ) NEW_LINE print ( minimumAddition ( st , l ) ) NEW_LINE"],"references":["MAX = 26 NEW_LINE def minimumAddition ( str1 , Len ) : NEW_LINE INDENT freq = [ 0 for i in range ( MAX ) ] NEW_LINE for i in range ( Len ) : NEW_LINE INDENT freq [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT maxFreq = max ( freq ) NEW_LINE minAddition = 0 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if ( freq [ i ] > 0 ) : NEW_LINE INDENT minAddition += abs ( maxFreq - freq [ i ] ) NEW_LINE DEDENT DEDENT return minAddition NEW_LINE DEDENT str1 = \" geeksforgeeks \" NEW_LINE Len = len ( str1 ) NEW_LINE print ( minimumAddition ( str1 , Len ) ) NEW_LINE"],"bleu":0.5769279194152308,"rouge_l":0.793323940609082}
{"id":773,"predictions":["N = 9 NEW_LINE def addEgcd ( adj , u , v ) : NEW_LINE INDENT if ( node == leaf ) : NEW_LINE INDENT G = __gcd ( G , v ) NEW_LINE self . append ( u ) NEW_LINE DEDENT def DFS ( node , parent , G , val , adj [ node ] ) : NEW_LINE INDENT if ( node == leaf ) : NEW_LINE INDENT G = __gcd ( G , val [ node ] ) NEW_LINE print ( G ) NEW_LINE return NEW_LINE DEDENT for it in adj [ node ] : NEW_LINE INDENT if ( it != parent ) : NEW_LINE INDENT DFS ( it , node , gcd ( G , val [ it ] ) , leaf , val , val , adj ) NEW_LINE DEDENT DEDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return __gcd ( b , a % b ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 8 NEW_LINE adj = [ ] NEW_LINE addEgcd ( adj , 1 , 2 ) NEW_LINE addEgcd ( adj , 2 , 4 ) NEW_LINE addEgcd ( adj , 3 , 5 ) NEW_LINE addEgde ( adj , 6 , 8 ) NEW_LINE addEgde ( adj , 6 , 7 , 6 ) NEW_LINE addEgute ( adj , 6 , 8 ) NEW_LINE addEgute ( adj , 6 , 8 ) NEW_LINE addEgcd = 5 NEW_LINE val = [ - 1 , 6 , 2 , 6 , 8 , 10 , 18 ] NEW_LINE print ( - 1 ) NEW_LINE DEDENT"],"references":["from math import gcd NEW_LINE N = 9 NEW_LINE def addEgde ( adj , u , v ) : NEW_LINE INDENT adj [ u ] . append ( v ) NEW_LINE adj [ v ] . append ( u ) NEW_LINE DEDENT def DFS ( node , parent , G , leaf , val , adj ) : NEW_LINE INDENT if ( node == leaf ) : NEW_LINE INDENT G = gcd ( G , val [ node ] ) NEW_LINE print ( G , end = \" \" ) NEW_LINE return NEW_LINE DEDENT for it in adj [ node ] : NEW_LINE INDENT if ( it != parent ) : NEW_LINE INDENT DFS ( it , node , gcd ( G , val [ it ] ) , leaf , val , adj ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 8 NEW_LINE adj = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE addEgde ( adj , 1 , 2 ) NEW_LINE addEgde ( adj , 2 , 4 ) NEW_LINE addEgde ( adj , 1 , 3 ) NEW_LINE addEgde ( adj , 3 , 5 ) NEW_LINE addEgde ( adj , 3 , 6 ) NEW_LINE addEgde ( adj , 6 , 7 ) NEW_LINE addEgde ( adj , 6 , 8 ) NEW_LINE leaf = 5 NEW_LINE val = [ - 1 , 6 , 2 , 6 , 3 , 4 , 12 , 10 , 18 ] NEW_LINE G = val [ 1 ] NEW_LINE DFS ( 1 , - 1 , G , leaf , val , adj ) NEW_LINE DEDENT"],"bleu":0.6460364502809348,"rouge_l":0.7441545238902066}
{"id":774,"predictions":["def countNums ( l , r ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT lastDigit = ( i % 10 ) ; NEW_LINE if ( ( lastDigit % 10 ) == 2 or ( lastDigit % 10 ) == 3 or ( lastDigit % 10 ) == 9 ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT return cnt ; NEW_LINE DEDENT l = 11 ; r = 33 ; NEW_LINE print ( countNums ( l , r ) ) ; NEW_LINE"],"references":["def countNums ( l , r ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT lastDigit = ( i % 10 ) ; NEW_LINE if ( ( lastDigit % 10 ) == 2 or ( lastDigit % 10 ) == 3 or ( lastDigit % 10 ) == 9 ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT return cnt ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT l = 11 ; r = 33 ; NEW_LINE print ( countNums ( l , r ) ) ; NEW_LINE DEDENT"],"bleu":0.8547373030596106,"rouge_l":0.9229711141678131}
{"id":775,"predictions":["def countMaxSetBits ( left , right ) : NEW_LINE INDENT max_count = - 1 NEW_LINE num = 0 NEW_LINE for i in range ( left , right + 1 ) : NEW_LINE INDENT temp = i NEW_LINE cnt = 0 NEW_LINE while temp > 0 : NEW_LINE INDENT if temp % 2 == 1 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT temp >>= 1 NEW_LINE DEDENT if cnt > max_count : NEW_LINE INDENT max_count = cnt NEW_LINE num = i NEW_LINE DEDENT DEDENT return num NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT l = 1 NEW_LINE r = 5 NEW_LINE print ( countMaxSetBits ( l , r ) ) NEW_LINE l = 1 NEW_LINE r = 10 NEW_LINE print ( countMaxSetBits ( l , r ) ) NEW_LINE l , r = 1 NEW_LINE print ( countMaxSetBits ( l , r ) ) NEW_LINE DEDENT"],"references":["def countMaxSetBits ( left , right ) : NEW_LINE INDENT max_count = - 1 NEW_LINE for i in range ( left , right + 1 ) : NEW_LINE INDENT temp = i NEW_LINE cnt = 0 NEW_LINE while temp : NEW_LINE INDENT if temp & 1 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT temp = temp >> 1 NEW_LINE DEDENT if cnt > max_count : NEW_LINE INDENT max_count = cnt NEW_LINE num = i NEW_LINE DEDENT DEDENT return num NEW_LINE DEDENT l = 1 NEW_LINE r = 5 NEW_LINE print ( countMaxSetBits ( l , r ) ) NEW_LINE l = 1 NEW_LINE r = 10 NEW_LINE print ( countMaxSetBits ( l , r ) ) NEW_LINE"],"bleu":0.6957138719352758,"rouge_l":0.8587305507532724}
{"id":776,"predictions":["import math NEW_LINE def checkPerfectcube ( n ) : NEW_LINE INDENT cube_root = int ( math . sqrt ( n ) ) NEW_LINE if round ( cube_root ) ** 3 == n : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def smallestPerfectCube ( a , n ) : NEW_LINE INDENT mini = 10 ** 9 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( checkPerfectcube ( a [ i ] ) ) : NEW_LINE INDENT mini = min ( a [ i ] , mini ) NEW_LINE DEDENT DEDENT return mini NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 16 , 8 , 25 , 2 , 3 , 10 ] NEW_LINE n = len ( a ) NEW_LINE print ( smallestPerfectCube ( a , n ) ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE def checkPerfectcube ( n ) : NEW_LINE INDENT d = int ( n ** ( 1 \/ 3 ) ) ; NEW_LINE if ( d * d * d == n ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT def smallestPerfectCube ( a , n ) : NEW_LINE INDENT mini = sys . maxsize ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( checkPerfectcube ( a [ i ] ) ) : NEW_LINE INDENT mini = min ( a [ i ] , mini ) ; NEW_LINE DEDENT DEDENT return mini ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 16 , 8 , 25 , 2 , 3 , 10 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( smallestPerfectCube ( a , n ) ) ; NEW_LINE DEDENT"],"bleu":0.6536435221404269,"rouge_l":0.8334376303712975}
{"id":777,"predictions":["def discard ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = 0 NEW_LINE maximum = 0 NEW_LINE for j in range ( i , min ( n , i + 60 ) ) : NEW_LINE INDENT s += a [ j ] NEW_LINE maximum = max ( a [ j ] , maximum ) NEW_LINE if ( s % 2 == 0 and 2 * maximum > s ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT def countSubarrays ( a , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT a [ i ] = bin ( a [ i ] ) . count ( '1' ) NEW_LINE DEDENT pre = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT pre [ i ] = bin ( a [ i ] ) . count ( '1' ) NEW_LINE if ( i != 0 ) : NEW_LINE INDENT pre [ i ] += pre [ i - 1 ] NEW_LINE DEDENT DEDENT odd = 0 NEW_LINE even = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( pre [ i ] % 2 == 1 ) : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT even = n - odd NEW_LINE even += 1 NEW_LINE answer = ( odd * ( odd - 1 ) \/\/ 2 ) + ( even * ( even - 1 ) \/\/ 2 ) ) NEW_LINE print ( answer ) NEW_LINE answer = answer - occ ( a , n ) NEW_LINE return answer NEW_LINE DEDENT a = [ 6 , 7 , 14 ] NEW_LINE n = len ( a ) NEW_LINE print ( countSubarrays ( a , n ) ) NEW_LINE"],"references":["def exclude ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT s = 0 NEW_LINE maximum = 0 NEW_LINE for j in range ( i , min ( n , i + 60 ) ) : NEW_LINE INDENT s += a [ j ] NEW_LINE maximum = max ( a [ j ] , maximum ) NEW_LINE if s % 2 == 0 and 2 * maximum > s : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT def countSubarrays ( a , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT a [ i ] = bin ( a [ i ] ) . count ( '1' ) NEW_LINE DEDENT pre = [ None ] * n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT pre [ i ] = a [ i ] NEW_LINE if i != 0 : NEW_LINE INDENT pre [ i ] += pre [ i - 1 ] NEW_LINE DEDENT DEDENT odd , even = 0 , 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if pre [ i ] & 1 : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT even = n - odd NEW_LINE even += 1 NEW_LINE answer = ( ( odd * ( odd - 1 ) \/\/ 2 ) + ( even * ( even - 1 ) \/\/ 2 ) ) NEW_LINE print ( answer ) NEW_LINE answer = answer - exclude ( a , n ) NEW_LINE return answer NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 6 , 7 , 14 ] NEW_LINE n = len ( a ) NEW_LINE print ( countSubarrays ( a , n ) ) NEW_LINE DEDENT"],"bleu":0.8258826158896484,"rouge_l":0.9157760814249364}
{"id":778,"predictions":["def printPermutation ( N , K ) : NEW_LINE INDENT res = [ ] NEW_LINE l = 1 NEW_LINE r = N NEW_LINE flag = 0 NEW_LINE for i in range ( K ) : NEW_LINE INDENT if ( flag ) : NEW_LINE INDENT res . append ( l ) NEW_LINE l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT res . append ( r ) NEW_LINE r -= 1 NEW_LINE DEDENT flag ^= 1 NEW_LINE DEDENT if ( flag != 1 ) : NEW_LINE INDENT for i in range ( r , l + 1 ) : NEW_LINE INDENT res . append ( i ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( l , r + 1 ) : NEW_LINE INDENT res . append ( i ) NEW_LINE DEDENT DEDENT for i in range ( l , r + 1 ) : NEW_LINE INDENT print ( res [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 15 NEW_LINE K = 4 NEW_LINE printPermutation ( N , K ) NEW_LINE DEDENT"],"references":["def printPermutation ( N , K ) : NEW_LINE INDENT res = list ( ) ; NEW_LINE l , r , flag = 1 , N , 0 NEW_LINE for i in range ( K ) : NEW_LINE INDENT if flag == False : NEW_LINE INDENT res . append ( l ) NEW_LINE l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT res . append ( r ) ; NEW_LINE r -= 1 ; NEW_LINE DEDENT flag = flag ^ 1 ; NEW_LINE DEDENT if flag == False : NEW_LINE INDENT for i in range ( r , 2 , - 1 ) : NEW_LINE INDENT res . append ( i ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( l , r ) : NEW_LINE INDENT res . append ( i ) NEW_LINE DEDENT DEDENT for i in res : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT N , K = 10 , 4 NEW_LINE printPermutation ( N , K ) NEW_LINE"],"bleu":0.6378034482188081,"rouge_l":0.8078747203579418}
{"id":779,"predictions":["def solve ( A , B , n ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if ( bin ( c ) . count ( '1' ) == B [ j ] ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT DEDENT return cnt ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 5 , 3 , 2 , 4 , 6 , 1 ] ; NEW_LINE B = [ 2 , 2 , 1 , 4 , 2 , 3 ] ; NEW_LINE size = len ( A ) ; NEW_LINE print ( solve ( A , B , size ) ) ; NEW_LINE DEDENT"],"references":["def solve ( A , B , n ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if ( bin ( A [ i ] | A [ j ] ) . count ( '1' ) == B [ j ] ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 5 , 3 , 2 , 4 , 6 , 1 ] ; NEW_LINE B = [ 2 , 2 , 1 , 4 , 2 , 3 ] ; NEW_LINE size = len ( A ) ; NEW_LINE print ( solve ( A , B , size ) ) ; NEW_LINE DEDENT"],"bleu":0.8830558255060058,"rouge_l":0.9439737941940586}
{"id":780,"predictions":["def sum ( n ) : NEW_LINE INDENT s = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT s = s + 1 \/ i ; NEW_LINE DEDENT return s ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 ; NEW_LINE print ( \" Sum ▁ is \" , sum ( n ) ) ; NEW_LINE DEDENT"],"references":["def sum ( n ) : NEW_LINE INDENT i = 1 NEW_LINE s = 0.0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT s = s + 1 \/ i ; NEW_LINE DEDENT return s ; NEW_LINE DEDENT n = 5 NEW_LINE print ( \" Sum ▁ is \" , round ( sum ( n ) , 6 ) ) NEW_LINE"],"bleu":0.6448481372396876,"rouge_l":0.8137074517019318}
{"id":781,"predictions":["M = 3 ; NEW_LINE N = 2 NEW_LINE def getIndex ( n , shuffle ) : NEW_LINE INDENT for i in range ( 3 ) : NEW_LINE INDENT if ( shuffle [ i ] [ 0 ] == n ) : NEW_LINE INDENT n = shuffle [ i ] [ 1 ] ; NEW_LINE DEDENT elif ( shuffle [ i ] [ 1 ] == n ) : NEW_LINE INDENT n = shuffle [ i ] [ 0 ] ; NEW_LINE DEDENT DEDENT print ( n ) ; NEW_LINE DEDENT n = 3 ; NEW_LINE shuffle = [ [ 3 , 1 ] , [ 2 , 1 ] , [ 1 , 2 ] ] ; NEW_LINE getIndex ( n , shuffle ) ; NEW_LINE"],"references":["M = 3 ; N = 2 ; NEW_LINE def getIndex ( n , shuffle ) : NEW_LINE INDENT for i in range ( 3 ) : NEW_LINE INDENT if ( shuffle [ i ] [ 0 ] == n ) : NEW_LINE INDENT n = shuffle [ i ] [ 1 ] ; NEW_LINE DEDENT elif ( shuffle [ i ] [ 1 ] == n ) : NEW_LINE INDENT n = shuffle [ i ] [ 0 ] ; NEW_LINE DEDENT DEDENT print ( n ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 ; NEW_LINE shuffle = [ [ 3 , 1 ] , [ 2 , 1 ] , [ 1 , 2 ] ] ; NEW_LINE getIndex ( n , shuffle ) ; NEW_LINE DEDENT"],"bleu":0.8595488620545892,"rouge_l":0.9315234517028238}
{"id":782,"predictions":["def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT def findArr ( arr , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT print ( \" - 1\" , end = \" ▁ \" ) NEW_LINE return NEW_LINE DEDENT minVal = arr [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == minVal ) : NEW_LINE INDENT arr [ i ] = arr [ i ] NEW_LINE n - 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( arr [ 0 ] == arr [ n - 1 ] ) : NEW_LINE INDENT printArr ( arr , n ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT DEDENT arr = [ 1 , 5 , 3 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE findArrangement ( arr , n ) NEW_LINE"],"references":["def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT def findArrangement ( arr , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT print ( \" - 1\" , end = \" \" ) ; NEW_LINE return ; NEW_LINE DEDENT minVal = min ( arr ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == minVal ) : NEW_LINE INDENT arr [ i ] , arr [ n - 1 ] = arr [ n - 1 ] , arr [ i ] ; NEW_LINE break ; NEW_LINE DEDENT DEDENT andVal = arr [ 0 ] ; NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT andVal &= arr [ i ] ; NEW_LINE DEDENT if ( andVal == arr [ n - 1 ] ) : NEW_LINE INDENT printArr ( arr , n ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" - 1\" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 5 , 3 , 3 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE findArrangement ( arr , n ) ; NEW_LINE DEDENT"],"bleu":0.5879899910727917,"rouge_l":0.7868606569671517}
{"id":783,"predictions":["def findOccurrences ( str1 , substr ) : NEW_LINE INDENT counter = 0 NEW_LINE str1 = sorted ( str1 ) NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT if ( str1 [ i ] == substr [ 0 ] ) : NEW_LINE INDENT for j in range ( i + 1 , len ( str1 ) ) : NEW_LINE INDENT if ( str1 [ j ] == substr [ 1 ] ) : NEW_LINE INDENT for k in range ( j + 1 , len ( str1 ) ) : NEW_LINE INDENT if ( str1 [ k ] == substr [ 2 ] ) : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return counter NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" GFGFGYSYIOIWIN \" NEW_LINE substr = \" GFG \" NEW_LINE print ( findOccurrences ( str1 , substr ) ) NEW_LINE DEDENT"],"references":["def findOccurrences ( str , substr ) : NEW_LINE INDENT counter = 0 NEW_LINE for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == substr [ 0 ] ) : NEW_LINE INDENT for j in range ( i + 1 , len ( str ) ) : NEW_LINE INDENT if ( str [ j ] == substr [ 1 ] ) : NEW_LINE INDENT for k in range ( j + 1 , len ( str ) ) : NEW_LINE INDENT if ( str [ k ] == substr [ 2 ] ) : NEW_LINE INDENT counter = counter + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT return counter NEW_LINE DEDENT str = \" GFGFGYSYIOIWIN \" NEW_LINE substr = \" GFG \" NEW_LINE print ( findOccurrences ( str , substr ) ) NEW_LINE"],"bleu":0.7001421718870492,"rouge_l":0.8586933161401246}
{"id":784,"predictions":["def decimalToBinary ( num , k_prec ) : NEW_LINE INDENT binary = \" \" NEW_LINE Inral = num NEW_LINE den = num - Integral NEW_LINE while (Integral > 0 ) : NEW_LINE INDENT rem = Integral % 2 NEW_LINE binary += chr ( rem + '0' ) NEW_LINEIntegral \/= 2 NEW_LINE DEDENT binary = binary [ : : - 1 ] NEW_LINE binary += ( ' . ' ) NEW_LINE while ( k_prec ) : NEW_LINE INDENT roundingal -= 1 NEW_LINE fract_bit = ord ( '0' ) NEW_LINE if ( fract_bit == 1 ) : NEW_LINE INDENTfrac -= fract_bit NEW_LINE binary += chr ( 1 + ord ( '0' ) ) NEW_LINE DEDENT else : NEW_LINE INDENT binary += chr ( 0 + ord ( '0' ) ) NEW_LINE DEDENT DEDENT return binary NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4.47 NEW_LINE k = 3 NEW_LINE print ( int ( decimalToBinary ( n , k ) ) ) NEW_LINE n = 6 NEW_LINE k = 5 NEW_LINE print ( int ( decimalToBinary ( n , k ) ) ) NEW_LINE n = 6 NEW_LINE print ( int ( decimalToBinary ( n , k ) ) ) ) NEW_LINE"],"references":["def decimalToBinary ( num , k_prec ) : NEW_LINE INDENT binary = \" \" NEW_LINE Integral = int ( num ) NEW_LINE fractional = num - Integral NEW_LINE while ( Integral ) : NEW_LINE INDENT rem = Integral % 2 NEW_LINE binary += str ( rem ) ; NEW_LINE Integral \/\/= 2 NEW_LINE DEDENT binary = binary [ : : - 1 ] NEW_LINE binary += ' . ' NEW_LINE while ( k_prec ) : NEW_LINE INDENT fractional *= 2 NEW_LINE fract_bit = int ( fractional ) NEW_LINE if ( fract_bit == 1 ) : NEW_LINE INDENT fractional -= fract_bit NEW_LINE binary += '1' NEW_LINE DEDENT else : NEW_LINE INDENT binary += '0' NEW_LINE DEDENT k_prec -= 1 NEW_LINE DEDENT return binary NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4.47 NEW_LINE k = 3 NEW_LINE print ( decimalToBinary ( n , k ) ) NEW_LINE n = 6.986 NEW_LINE k = 5 NEW_LINE print ( decimalToBinary ( n , k ) ) NEW_LINE DEDENT"],"bleu":0.5989763204642258,"rouge_l":0.7875087229588276}
{"id":785,"predictions":["def evenDecimalValue ( strr , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT decimalValue = 0 NEW_LINE powerOf2 = 1 NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT decimalValue += ( ( ord ( strr [ k ] ) - ord ( '0' ) ) * powerOf2 *= 2 NEW_LINE DEDENT if ( decimalValue % 2 == 0 ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT strr = \"10010\" NEW_LINE n = 5 NEW_LINE print ( evenDecimalValue ( strr , n ) ) NEW_LINE"],"references":["import math NEW_LINE def evenDecimalValue ( str , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT decimalValue = 0 ; NEW_LINE powerOf2 = 1 ; NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT decimalValue += ( ( int ( str [ k ] ) - 0 ) * powerOf2 ) NEW_LINE powerOf2 *= 2 NEW_LINE DEDENT if ( decimalValue % 2 == 0 ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT str = \"10010\" NEW_LINE n = 5 NEW_LINE print ( evenDecimalValue ( str , n ) ) NEW_LINE"],"bleu":0.793381955211594,"rouge_l":0.9051151893791487}
{"id":786,"predictions":["def isSubSeqDivisible ( st ) : NEW_LINE INDENT l = len ( st ) NEW_LINE arr = [ 0 for i in range ( l ) ] NEW_LINE for i in range ( l ) : NEW_LINE INDENT arr [ i ] = int ( st [ i ] ) NEW_LINE DEDENT for i in range ( l ) : NEW_LINE INDENT for j in range ( i , l ) : NEW_LINE INDENT if ( arr [ i ] % 8 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 and i != j ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( ( arr [ i ] * 10 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 and i != j and j != k and i != k ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT st = \"3144\" NEW_LINE if ( isSubSeqDivisible ( st ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def isSubSeqDivisible ( st ) : NEW_LINE INDENT l = len ( st ) NEW_LINE arr = [ int ( ch ) for ch in st ] NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT for j in range ( i , l ) : NEW_LINE INDENT for k in range ( j , l ) : NEW_LINE INDENT if ( arr [ i ] % 8 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 and i != j ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 and i != j and j != k and i != k ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT st = \"3144\" NEW_LINE if ( isSubSeqDivisible ( st ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.854789909865227,"rouge_l":0.9082494969818914}
{"id":787,"predictions":["def sub_segments ( str , n ) : NEW_LINE INDENT l = len ( str ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT newlist = str [ x : x + n ] NEW_LINE if y in newlist : NEW_LINE INDENT newlist = [ x : x + n ] NEW_LINE DEDENT DEDENT for y in newlist : NEW_LINE INDENT print ( y , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeksforgeeksgfg \" NEW_LINE n = 4 NEW_LINE sub_segments ( str , n ) NEW_LINE DEDENT"],"references":["def sub_segments ( string , n ) : NEW_LINE INDENT l = len ( string ) NEW_LINE for x in range ( 0 , l , n ) : NEW_LINE INDENT newlist = string [ x : x + n ] NEW_LINE arr = [ ] NEW_LINE for y in newlist : NEW_LINE INDENT if y not in arr : NEW_LINE INDENT arr . append ( y ) NEW_LINE DEDENT DEDENT print ( ' ' . join ( arr ) ) NEW_LINE DEDENT DEDENT string = \" geeksforgeeksgfg \" NEW_LINE n = 4 NEW_LINE sub_segments ( string , n ) NEW_LINE"],"bleu":0.45042018323247945,"rouge_l":0.6660427390422712}
{"id":788,"predictions":["def remAnagram ( str1 , str2 ) : NEW_LINE INDENT count1 = [ 0 ] * 26 ; NEW_LINE count2 = [ 0 ] * 26 ; NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT count1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT for i in range ( len ( str2 ) ) : NEW_LINE INDENT count2 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT result = 0 ; NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT result += abs ( count1 [ i ] - count2 [ i ] ) ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = \" bcadeh \" ; NEW_LINE str2 = \" hea \" ; NEW_LINE print ( remAnagram ( str1 , str2 ) ) ; NEW_LINE DEDENT"],"references":["CHARS = 26 NEW_LINE def remAnagram ( str1 , str2 ) : NEW_LINE INDENT count1 = [ 0 ] * CHARS NEW_LINE count2 = [ 0 ] * CHARS NEW_LINE i = 0 NEW_LINE while i < len ( str1 ) : NEW_LINE INDENT count1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE i += 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < len ( str2 ) : NEW_LINE INDENT count2 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE i += 1 NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT result += abs ( count1 [ i ] - count2 [ i ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" bcadeh \" NEW_LINE str2 = \" hea \" NEW_LINE print ( remAnagram ( str1 , str2 ) ) NEW_LINE DEDENT"],"bleu":0.7082583287241395,"rouge_l":0.8505298382598996}
{"id":789,"predictions":["def minOperations ( s , t , n ) : NEW_LINE INDENT ct0 , ct1 = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == t [ i ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT ct0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ct1 += 1 NEW_LINE DEDENT DEDENT return max ( ct0 , ct1 ) NEW_LINE DEDENT s = \"010\" NEW_LINE t = \"101\" NEW_LINE n = len ( s ) NEW_LINE print ( minOperations ( s , t , n ) ) NEW_LINE"],"references":["def minOperations ( s , t , n ) : NEW_LINE INDENT ct0 = 0 NEW_LINE ct1 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == t [ i ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT ct0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ct1 += 1 NEW_LINE DEDENT DEDENT return max ( ct0 , ct1 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \"010\" NEW_LINE t = \"101\" NEW_LINE n = len ( s ) NEW_LINE print ( minOperations ( s , t , n ) ) NEW_LINE DEDENT"],"bleu":0.828925066369805,"rouge_l":0.9055670103092783}
{"id":790,"predictions":["def toggleLastMBits ( n , m ) : NEW_LINE INDENT num = ( 1 << m ) - 1 NEW_LINE return ( n ^ num ) NEW_LINE DEDENT n = 107 NEW_LINE m = 4 NEW_LINE n = toggleLastMBits ( n , m ) NEW_LINE print ( n ) NEW_LINE"],"references":["def toggleLastMBits ( n , m ) : NEW_LINE INDENT num = ( 1 << m ) - 1 NEW_LINE return ( n ^ num ) NEW_LINE DEDENT n = 107 NEW_LINE m = 4 NEW_LINE print ( toggleLastMBits ( n , m ) ) NEW_LINE"],"bleu":0.8451984423351157,"rouge_l":0.9236063317274604}
{"id":791,"predictions":["def printmaxSubseq ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( i + 1 < n and arr [ i ] < arr [ i + 1 ] ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT DEDENT arr = [ 9 , 8 , 12 , 12 , 12 , 13 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print maxSubseq ( arr , n ) ; NEW_LINE"],"references":["def printmaxSubseq ( arr , n ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT if ( arr [ i ] < arr [ i + 1 ] ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ i ] ) ; NEW_LINE DEDENT DEDENT print ( arr [ n - 1 ] ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 9 , 8 , 11 , 13 , 10 , 15 , 14 , 16 , 20 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE printmaxSubseq ( arr , n ) ; NEW_LINE DEDENT"],"bleu":0.6384058144466522,"rouge_l":0.7686139747995419}
{"id":792,"predictions":["def printFibonacciNumbers ( n ) : NEW_LINE INDENT f1 = 0 NEW_LINE f2 = 1 NEW_LINE if ( n < 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( f2 , end = \" ▁ \" ) NEW_LINE f2 = f2 NEW_LINE DEDENT DEDENT printFibonacciNumbers ( 7 ) ; NEW_LINE"],"references":["def printFibonacciNumbers ( n ) : NEW_LINE INDENT f1 = 0 NEW_LINE f2 = 1 NEW_LINE if ( n < 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT for x in range ( 0 , n ) : NEW_LINE INDENT print ( f2 , end = \" ▁ \" ) NEW_LINE next = f1 + f2 NEW_LINE f1 = f2 NEW_LINE f2 = next NEW_LINE DEDENT DEDENT printFibonacciNumbers ( 7 ) NEW_LINE"],"bleu":0.7240964764459,"rouge_l":0.8679155797960636}
{"id":793,"predictions":["def cal_speed ( dist , time ) : NEW_LINE INDENT print ( \" No ▁ Distance ▁ km : ▁ \" , time ) ; NEW_LINE print ( \" \\n Time ▁ : ▁ \" , time ) ; NEW_LINE print ( \" \\n Time ▁ time ▁ : ▁ \" , time ) ; NEW_LINE DEDENT def cal_time ( time , time ) : NEW_LINE INDENT print ( \" \\n Time ▁ : ▁ \" , time ) ; NEW_LINE print ( time ) ; NEW_LINE print ( \" \\n Time ▁ : ▁ \" , time ) ; NEW_LINE print ( time ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( \" The ▁ Distance ( km ▁ \/ ▁ 24\" ) ; NEW_LINE print ( round ( 3.5 \/ 60 , 4.0 ) ) ; NEW_LINE print ( \" \\n ▁ Dist ▁ T ▁ : \" , round ( radius ( 60.5 \/ 24 ) , 2.0 ) ) ; NEW_LINE print ( \" \\n Time ▁ between ▁ 24\" ) ; NEW_LINE print ( \" \\n Time ▁ between ▁ 24.0\" ) ; NEW_LINE DEDENT"],"references":["def cal_speed ( dist , time ) : NEW_LINE INDENT print ( \" ▁ Distance ( km ) ▁ : \" , dist ) ; NEW_LINE print ( \" ▁ Time ( hr ) ▁ : \" , time ) ; NEW_LINE return dist \/ time ; NEW_LINE DEDENT def cal_dis ( speed , time ) : NEW_LINE INDENT print ( \" ▁ Time ( hr ) ▁ : \" , time ) ; NEW_LINE print ( \" ▁ Speed ( km ▁ \/ ▁ hr ) ▁ : \" , speed ) ; NEW_LINE return speed * time ; NEW_LINE DEDENT def cal_time ( dist , speed ) : NEW_LINE INDENT print ( \" ▁ Distance ( km ) ▁ : \" , dist ) ; NEW_LINE print ( \" ▁ Speed ( km ▁ \/ ▁ hr ) ▁ : \" , speed ) ; NEW_LINE return speed * dist ; NEW_LINE DEDENT print ( \" ▁ The ▁ calculated ▁ Speed ( km ▁ \/ ▁ hr ) ▁ is ▁ : \" , cal_speed ( 45.9 , 2.0 ) ) ; NEW_LINE print ( \" \" ) ; NEW_LINE print ( \" ▁ The ▁ calculated ▁ Distance ( km ) ▁ : \" , cal_dis ( 62.9 , 2.5 ) ) ; NEW_LINE print ( \" \" ) ; NEW_LINE print ( \" ▁ The ▁ calculated ▁ Time ( hr ) ▁ : \" , cal_time ( 48.0 , 4.5 ) ) ; NEW_LINE"],"bleu":0.3603207814364846,"rouge_l":0.5489999999999999}
{"id":794,"predictions":["import math NEW_LINE def printfmatFactors ( n ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT print ( \" [ \" , n , \" ] , \"1\" ) NEW_LINE return NEW_LINE DEDENT if ( n & 1 ) : NEW_LINE INDENT print ( \" [ \" , n \/\/ 2.0 , \" , \"2\" , 2 , \" ] \" ) NEW_LINE return NEW_LINE DEDENT a = int ( math . ceil ( math . sqrt ( n ) ) ) NEW_LINE if ( a * a == n ) : NEW_LINE INDENT print ( \" [ \" , a , \" , a , \" , b , \" ] \" , end = \" \" ) NEW_LINE return NEW_LINE DEDENT b = int ( math . ceil ( a ) ) NEW_LINE if ( b * b == b ) : NEW_LINE INDENT break NEW_LINE DEDENT b += 1 NEW_LINE print ( \" [ \" , ( a - b ) , \" , ( a + b ) , \" ] \" , sep = \" \" ) NEW_LINE return NEW_LINE DEDENT"],"references":["from math import ceil , sqrt NEW_LINE def FermatFactors ( n ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return [ n ] NEW_LINE DEDENT if ( n & 1 ) == 0 : NEW_LINE INDENT return [ n \/ 2 , 2 ] NEW_LINE DEDENT a = ceil ( sqrt ( n ) ) NEW_LINE if ( a * a == n ) : NEW_LINE INDENT return [ a , a ] NEW_LINE DEDENT while ( True ) : NEW_LINE INDENT b1 = a * a - n NEW_LINE b = int ( sqrt ( b1 ) ) NEW_LINE if ( b * b == b1 ) : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT a += 1 NEW_LINE DEDENT DEDENT return [ a - b , a + b ] NEW_LINE DEDENT print ( FermatFactors ( 6557 ) ) NEW_LINE"],"bleu":0.370303055066595,"rouge_l":0.6212181135060312}
{"id":795,"predictions":["def perfectCube ( N ) : NEW_LINE INDENT cube = 0 NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT cube = i * i NEW_LINE if cube == N : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE return NEW_LINE DEDENT elif cube > N : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE return NEW_LINE DEDENT DEDENT N = 216 NEW_LINE perfectCube ( N ) NEW_LINE"],"references":["def perfectCube ( N ) : NEW_LINE INDENT cube = 0 ; NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT cube = i * i * i ; NEW_LINE if ( cube == N ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE return ; NEW_LINE DEDENT elif ( cube > N ) : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE return ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 216 ; NEW_LINE perfectCube ( N ) ; NEW_LINE DEDENT"],"bleu":0.49422010886124634,"rouge_l":0.8121626484346887}
{"id":796,"predictions":["def removeDplicates ( str , n ) : NEW_LINE INDENT index = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT j = 0 ; NEW_LINE for j in range ( i ) : NEW_LINE INDENT if ( str [ i ] == str [ j ] ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT if ( j == i ) : NEW_LINE INDENT str [ index ] = str [ i ] ; NEW_LINE index += 1 ; NEW_LINE DEDENT DEDENT str = \" \" ; NEW_LINE n = len ( str ) ; NEW_LINE print ( removeDplicates ( str , n ) ) ; NEW_LINE"],"references":["def removeDuplicate ( str , n ) : NEW_LINE INDENT index = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , i + 1 ) : NEW_LINE INDENT if ( str [ i ] == str [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( j == i ) : NEW_LINE INDENT str [ index ] = str [ i ] NEW_LINE index += 1 NEW_LINE DEDENT DEDENT return \" \" . join ( str [ : index ] ) NEW_LINE DEDENT str = \" geeksforgeeks \" NEW_LINE n = len ( str ) NEW_LINE print ( removeDuplicate ( list ( str ) , n ) ) NEW_LINE"],"bleu":0.6173011544949667,"rouge_l":0.8229625550660792}
{"id":797,"predictions":["def compareSeq ( S , x , y , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( S [ x ] < S [ y ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def compareSeq ( S , x , y , n ) : NEW_LINE INDENT if ( S [ x ] < S [ y ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT x = ( x + 1 ) % n NEW_LINE y = ( y + 1 ) % n NEW_LINE DEDENT return True NEW_LINE DEDENT def smallestSequence ( S , n ) : NEW_LINE INDENT index = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( compareSeq ( S , index , n ) ) : NEW_LINE INDENT index = i + 1 NEW_LINE DEDENT DEDENT return index NEW_LINE DEDENT def printSmallestSequence ( S , n ) : NEW_LINE INDENT S = list ( S ) NEW_LINE start_index = smallestSequence ( S , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( S [ ( start_index + i ) % n ] ) NEW_LINE DEDENT DEDENT S . sort ( ) NEW_LINE n = 8 NEW_LINE printSmallestSequence ( S , n ) NEW_LINE"],"references":["import copy NEW_LINE def printSmallestSequence ( s ) : NEW_LINE INDENT m = copy . copy ( s ) NEW_LINE for i in range ( len ( s ) - 1 ) : NEW_LINE INDENT if m > s [ i : ] + s [ : i ] : NEW_LINE INDENT m = s [ i : ] + s [ : i ] NEW_LINE DEDENT DEDENT return m NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT st = ' DCACBCAA ' NEW_LINE print ( printSmallestSequence ( st ) ) NEW_LINE DEDENT"],"bleu":0.10662054832932477,"rouge_l":0.3191280653950953}
{"id":798,"predictions":["def partSort ( arr , N , a , b ) : NEW_LINE INDENT l = min ( a , b ) NEW_LINE r = max ( a , b ) NEW_LINE temp = [ 0 ] * r NEW_LINE j = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT temp [ j ] = arr [ i ] NEW_LINE j += 1 NEW_LINE DEDENT temp . sort ( ) NEW_LINE j = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT arr [ i ] = temp [ j ] NEW_LINE j += 1 NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 7 , 8 , 4 , 5 , 2 ] NEW_LINE a , b = 1 , 4 NEW_LINE N = len ( arr ) NEW_LINE partSort ( arr , N , a , b ) NEW_LINE"],"references":["def partSort ( arr , N , a , b ) : NEW_LINE INDENT l = min ( a , b ) NEW_LINE r = max ( a , b ) NEW_LINE temp = [ 0 for i in range ( r - l + 1 ) ] NEW_LINE j = 0 NEW_LINE for i in range ( l , r + 1 , 1 ) : NEW_LINE INDENT temp [ j ] = arr [ i ] NEW_LINE j += 1 NEW_LINE DEDENT temp . sort ( reverse = False ) NEW_LINE j = 0 NEW_LINE for i in range ( l , r + 1 , 1 ) : NEW_LINE INDENT arr [ i ] = temp [ j ] NEW_LINE j += 1 NEW_LINE DEDENT for i in range ( 0 , N , 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 7 , 8 , 4 , 5 , 2 ] NEW_LINE a = 1 NEW_LINE b = 4 NEW_LINE N = len ( arr ) NEW_LINE partSort ( arr , N , a , b ) NEW_LINE DEDENT"],"bleu":0.754535352426439,"rouge_l":0.8734481046184406}
{"id":799,"predictions":["def checkYear ( year ) : NEW_LINE INDENT if ( year % 400 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( year % 100 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( year % 4 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT year = 2000 NEW_LINE if ( checkYear ( year ) ) : NEW_LINE INDENT print ( \" Leap ▁ Year \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ a ▁ Leap ▁ Year \" ) NEW_LINE DEDENT"],"references":["def checkYear ( year ) : NEW_LINE INDENT if ( year % 4 ) == 0 : NEW_LINE INDENT if ( year % 100 ) == 0 : NEW_LINE INDENT if ( year % 400 ) == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT year = 2000 NEW_LINE if ( checkYear ( year ) ) : NEW_LINE INDENT print ( \" Leap ▁ Year \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ a ▁ Leap ▁ Year \" ) NEW_LINE DEDENT"],"bleu":0.7144963162612622,"rouge_l":0.7973856209150325}
{"id":800,"predictions":["def countPairs ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE right , left = 0 , 0 NEW_LINE visited = [ False for i in range ( n ) ] NEW_LINE while ( right < n ) : NEW_LINE INDENT while ( right < n and not visited [ arr [ right ] ] ) : NEW_LINE INDENT count += ( right - left ) NEW_LINE visited [ arr [ right ] ] = True NEW_LINE right += 1 NEW_LINE DEDENT while ( left < right and ( right != n and visited [ arr [ right ] ] ) ) : NEW_LINE INDENT visited [ arr [ left ] ] = False NEW_LINE left += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 4 , 2 , 4 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE DEDENT"],"references":["def countPairs ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE right = 0 NEW_LINE left = 0 NEW_LINE visited = [ False for i in range ( n ) ] NEW_LINE while ( right < n ) : NEW_LINE INDENT while ( right < n and visited [ arr [ right ] ] == False ) : NEW_LINE INDENT count += ( right - left ) NEW_LINE visited [ arr [ right ] ] = True NEW_LINE right += 1 NEW_LINE DEDENT while ( left < right and ( right != n and visited [ arr [ right ] ] == True ) ) : NEW_LINE INDENT visited [ arr [ left ] ] = False NEW_LINE left += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 4 , 2 , 4 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.894286390709203,"rouge_l":0.9560419178336271}
{"id":801,"predictions":["def binarySearch ( arr , x ) : NEW_LINE INDENT l = 0 NEW_LINE r = 0 NEW_LINE while ( l <= r ) : NEW_LINE INDENT m = l + ( r - l ) \/\/ 2 NEW_LINE if ( arr [ m ] == x ) : NEW_LINE INDENT return m NEW_LINE DEDENT if ( arr [ m ] < x ) : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = m - 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 10 , 40 ] NEW_LINE n = len ( arr ) NEW_LINE x = 10 NEW_LINE result = binarySearch ( arr , x ) NEW_LINE if ( result == - 1 ) : NEW_LINE INDENT print ( \" Element ▁ is ▁ present ▁ at ▁ index ▁ % ▁ d \" % result ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Element ▁ is ▁ present ▁ at ▁ index ▁ % ▁ d \" % result ) NEW_LINE DEDENT"],"references":["def binarySearch ( arr , l , r , x ) : NEW_LINE INDENT while l <= r : NEW_LINE INDENT mid = l + ( r - l ) \/\/ 2 ; NEW_LINE if arr [ mid ] == x : NEW_LINE INDENT return mid NEW_LINE DEDENT elif arr [ mid ] < x : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = mid - 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 10 , 40 ] NEW_LINE x = 10 NEW_LINE result = binarySearch ( arr , 0 , len ( arr ) - 1 , x ) NEW_LINE if result != - 1 : NEW_LINE INDENT print ( \" Element ▁ is ▁ present ▁ at ▁ index ▁ % ▁ d \" % result ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Element ▁ is ▁ not ▁ present ▁ in ▁ array \" ) NEW_LINE DEDENT"],"bleu":0.634288827706738,"rouge_l":0.8213183730715288}
{"id":802,"predictions":["def isComposite ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT print ( \" False \" ) ; NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT print ( \" False \" ) ; NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT i = 5 ; NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT i += 6 ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT if ( isComposite ( 11 ) ) : NEW_LINE INDENT print ( \" true \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" true \" ) ; NEW_LINE DEDENT"],"references":["def isComposite ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return False NEW_LINE DEDENT print ( \" true \" ) if ( isComposite ( 11 ) ) else print ( \" false \" ) NEW_LINE print ( \" true \" ) if ( isComposite ( 15 ) ) else print ( \" false \" ) NEW_LINE"],"bleu":0.7062401870723151,"rouge_l":0.8175326815335604}
{"id":803,"predictions":["def decToBinary ( n ) : NEW_LINE INDENT binaryNum = [ 0 ] * 32 NEW_LINE i = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT binaryNum [ i ] = n % 2 NEW_LINE n = n \/\/ 2 NEW_LINE i += 1 NEW_LINE DEDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( binaryNum [ j ] , end = \" \" ) NEW_LINE DEDENT DEDENT n = 17 NEW_LINE decToBinary ( n ) NEW_LINE"],"references":["def decToBinary ( n ) : NEW_LINE INDENT binaryNum = [ 0 ] * n ; NEW_LINE i = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT binaryNum [ i ] = n % 2 ; NEW_LINE n = int ( n \/ 2 ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( binaryNum [ j ] , end = \" \" ) ; NEW_LINE DEDENT DEDENT n = 17 ; NEW_LINE decToBinary ( n ) ; NEW_LINE"],"bleu":0.7353677092113395,"rouge_l":0.9128972591222465}
{"id":804,"predictions":["def calculateSum ( n ) : NEW_LINE INDENT return ( n * ( pow ( n , 2 ) + 3 * n + 5 ) ) \/ 3 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 25 NEW_LINE print ( int ( calculateSum ( n ) ) ) NEW_LINE DEDENT"],"references":["def findSum ( n ) : NEW_LINE INDENT return ( n * ( pow ( n , 2 ) + 3 * n + 5 ) ) \/ 3 NEW_LINE DEDENT n = 25 NEW_LINE print ( int ( findSum ( n ) ) ) NEW_LINE"],"bleu":0.6653064444230797,"rouge_l":0.8504435994930292}
{"id":805,"predictions":["def isPerfectSquare ( n ) : NEW_LINE INDENT i = 1 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( ( n % i == 0 and ( n \/ i == i ) ) ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return False ; NEW_LINE DEDENT n = 36 ; NEW_LINE if ( isPerfectSquare ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT"],"references":["def isPerfectSquare ( n ) : NEW_LINE INDENT i = 1 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( ( n % i == 0 ) and ( n \/ i == i ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 36 NEW_LINE if ( isPerfectSquare ( n ) ) : NEW_LINE INDENT print ( \" Yes , ▁ it ▁ is ▁ a ▁ perfect ▁ square . \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No , ▁ it ▁ is ▁ not ▁ a ▁ perfect ▁ square . \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.5241724891654347,"rouge_l":0.7552865887590429}
{"id":806,"predictions":["def getSum ( x , y , z ) : NEW_LINE INDENT N = 101 NEW_LINE mod = 10 ** 9 + 7 NEW_LINE exactnum = [ [ 0 for x in range ( N ) ] for y in range ( N ) ] NEW_LINE exactnum = [ [ [ 0 for x in range ( N ) ] for y in range ( N ) ] for y in range ( N ) ] NEW_LINE def getSum ( x , y , z ) : NEW_LINE INDENT ans = 0 NEW_LINE exactnum [ 0 ] [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( z + 1 ) : NEW_LINE INDENT if ( i > 0 ) : NEW_LINE INDENT rawsum [ i ] [ j ] [ k ] += ( repeatingsum [ i - 1 ] [ j ] * 10 + 4 * exactnum [ i - 1 ] [ k ] ) % mod NEW_LINE exactnum [ i ] [ j ] [ k ] += exactnum [ i - 1 ] [ j ] NEW_LINE DEDENT if ( j > 0 ) : NEW_LINE INDENT exactnum [ i ] [ j ] [ k ] += ( exactsum [ i ] [ j ] [ k ] * 10 + 5 * exactnum [ i ] [ j ] ) % mod NEW_LINE DEDENT if ( k > 0 ) : NEW_LINE INDENT exactnum [ i ] [ j ] += ( exactnum [ i ] [ j ] [ k ] * 10 + 6 * exactnum [ i ] [ j ] ) % mod NEW_LINE exactnum [ i ] [ j ] += ( exactnum [ i ] [ j ] [ k - 1 ] ) % mod NEW_LINE DEDENT DEDENT if ( k > 0 ) : NEW_LINE INDENT exactnum [ i ] [ j ] [ k ] += ( exactsum [ i ] [ j ] [ k ] * 10 + 6 *exnum [ i ] [ j ] ) % mod NEW_LINE ans %= mod NEW_LINE DEDENT ans += x NEW_LINE y = 1 NEW_LINE z = 1 NEW_LINE print ( getSum ( x , y , z ) % mod ) NEW_LINE"],"references":["import numpy as np NEW_LINE N = 101 ; NEW_LINE mod = int ( 1e9 ) + 7 ; NEW_LINE exactsum = np . zeros ( ( N , N , N ) ) ; NEW_LINE exactnum = np . zeros ( ( N , N , N ) ) ; NEW_LINE def getSum ( x , y , z ) : NEW_LINE INDENT ans = 0 ; NEW_LINE exactnum [ 0 ] [ 0 ] [ 0 ] = 1 ; NEW_LINE for i in range ( x + 1 ) : NEW_LINE INDENT for j in range ( y + 1 ) : NEW_LINE INDENT for k in range ( z + 1 ) : NEW_LINE INDENT if ( i > 0 ) : NEW_LINE INDENT exactsum [ i ] [ j ] [ k ] += ( exactsum [ i - 1 ] [ j ] [ k ] * 10 + 4 * exactnum [ i - 1 ] [ j ] [ k ] ) % mod ; NEW_LINE exactnum [ i ] [ j ] [ k ] += exactnum [ i - 1 ] [ j ] [ k ] % mod ; NEW_LINE DEDENT if ( j > 0 ) : NEW_LINE INDENT exactsum [ i ] [ j ] [ k ] += ( exactsum [ i ] [ j - 1 ] [ k ] * 10 + 5 * exactnum [ i ] [ j - 1 ] [ k ] ) % mod ; NEW_LINE exactnum [ i ] [ j ] [ k ] += exactnum [ i ] [ j - 1 ] [ k ] % mod ; NEW_LINE DEDENT if ( k > 0 ) : NEW_LINE INDENT exactsum [ i ] [ j ] [ k ] += ( exactsum [ i ] [ j ] [ k - 1 ] * 10 + 6 * exactnum [ i ] [ j ] [ k - 1 ] ) % mod ; NEW_LINE exactnum [ i ] [ j ] [ k ] += exactnum [ i ] [ j ] [ k - 1 ] % mod ; NEW_LINE DEDENT ans += exactsum [ i ] [ j ] [ k ] % mod ; NEW_LINE ans %= mod ; NEW_LINE DEDENT DEDENT DEDENT return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = 1 ; y = 1 ; z = 1 ; NEW_LINE print ( ( getSum ( x , y , z ) % mod ) ) ; NEW_LINE DEDENT"],"bleu":0.6084434693541154,"rouge_l":0.7042291844826245}
{"id":807,"predictions":["def countPairs ( s ) : NEW_LINE INDENT st = set ( ) ; NEW_LINE st . add ( ' a ' ) ; NEW_LINE st . add ( ' u ' ) ; NEW_LINE st . add ( ' u ' ) ; NEW_LINE st . add ( ' u ' ) ; NEW_LINE count = 0 ; NEW_LINE n = len ( s ) ; NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if s [ i ] not in st : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" geeksforgeeks \" ; NEW_LINE print ( countPairs ( s ) ) ; NEW_LINE DEDENT"],"references":["def countPairs ( s ) : NEW_LINE INDENT st = set ( ) ; NEW_LINE st . add ( ' a ' ) ; NEW_LINE st . add ( ' e ' ) ; NEW_LINE st . add ( ' i ' ) ; NEW_LINE st . add ( ' o ' ) ; NEW_LINE st . add ( ' u ' ) ; NEW_LINE count = 0 ; NEW_LINE n = len ( s ) ; NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( s [ i ] not in st and s [ i + 1 ] in st ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" geeksforgeeks \" ; NEW_LINE print ( countPairs ( s ) ) ; NEW_LINE DEDENT"],"bleu":0.8015998119954659,"rouge_l":0.9010034953207803}
{"id":808,"predictions":["MOD = 1000000007 NEW_LINE def modulo_13 ( s , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 13 ) ] for j in range ( n + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT nxt = ord ( s [ i ] ) - ord ( '0' ) NEW_LINE if ( s [ i ] == ' ? ' ) : NEW_LINE INDENT nxt = j NEW_LINE DEDENT for k in range ( 0 , 13 ) : NEW_LINE INDENT rem = ( 10 * k + nxt ) % 13 NEW_LINE dp [ i + 1 ] [ rem ] += dp [ i ] [ rem ] [ rem ] NEW_LINE dp [ i + 1 ] [ rem ] = 0 NEW_LINE DEDENT if ( s [ i ] != ' ? ' ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ 5 ] NEW_LINE DEDENT s = \" ? 44\" NEW_LINE n = len ( s ) NEW_LINE print ( modulo_13 ( s , n ) ) NEW_LINE"],"references":["import numpy as np NEW_LINE MOD = ( int ) ( 1e9 + 7 ) NEW_LINE def modulo_13 ( s , n ) : NEW_LINE INDENT dp = np . zeros ( ( n + 1 , 13 ) ) ; NEW_LINE dp [ 0 ] [ 0 ] = 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT nxt = ord ( s [ i ] ) - ord ( '0' ) ; NEW_LINE if ( s [ i ] == ' ? ' ) : NEW_LINE INDENT nxt = j ; NEW_LINE DEDENT for k in range ( 13 ) : NEW_LINE INDENT rem = ( 10 * k + nxt ) % 13 ; NEW_LINE dp [ i + 1 ] [ rem ] += dp [ i ] [ k ] ; NEW_LINE dp [ i + 1 ] [ rem ] %= MOD ; NEW_LINE DEDENT if ( s [ i ] != ' ? ' ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT DEDENT return int ( dp [ n ] [ 5 ] ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" ? 44\" ; NEW_LINE n = len ( s ) ; NEW_LINE print ( modulo_13 ( s , n ) ) ; NEW_LINE DEDENT"],"bleu":0.677550979471494,"rouge_l":0.8247986191024166}
{"id":809,"predictions":["def max_ Profit ( a , b , n , profit ) : NEW_LINE INDENT b = 0 NEW_LINE sum = 0 NEW_LINE b [ 0 ] = 0 NEW_LINE b [ 0 ] = 0 NEW_LINE b [ 1 ] = diff_day NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT l = 0 NEW_LINE r = diff_day NEW_LINE sum = 0 NEW_LINE for j in range ( n - 1 , i + 1 , - 1 ) : NEW_LINE INDENT profit = ( a [ r ] - a [ l ] ) -Shift NEW_LINE if ( profit > 0 ) : NEW_LINE INDENT sum = sum + profit NEW_LINE DEDENT l += 1 NEW_LINE r += 1 NEW_LINE DEDENT if ( b [ 0 ] < sum ) : NEW_LINE INDENT b [ 0 ] = sum NEW_LINE b [ 1 ] = diff NEW_LINE DEDENT diff_end += 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 6 , 1 , 7 , 2 , 8 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE b = [ 0 , 1 , 7 , 2 , 8 , 4 ] NEW_LINE rs = [ 0 ] * 2 NEW_LINE print_ Profit ( arr , b , n , rs ) NEW_LINE print ( b [ 0 ] , \" , b [ 1 ] ) NEW_LINE DEDENT"],"references":["def max_profit ( a , b , n , fee ) : NEW_LINE INDENT i , j , profit = 1 , n - 1 , 0 NEW_LINE l , r , diff_day = 0 , 0 , 1 NEW_LINE b [ 0 ] = 0 NEW_LINE b [ 1 ] = diff_day NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT l = 0 NEW_LINE r = diff_day NEW_LINE Sum = 0 NEW_LINE for j in range ( n - 1 , i - 1 , - 1 ) : NEW_LINE INDENT profit = ( a [ r ] - a [ l ] ) - fee NEW_LINE if ( profit > 0 ) : NEW_LINE INDENT Sum = Sum + profit NEW_LINE DEDENT l += 1 NEW_LINE r += 1 NEW_LINE DEDENT if ( b [ 0 ] < Sum ) : NEW_LINE INDENT b [ 0 ] = Sum NEW_LINE b [ 1 ] = diff_day NEW_LINE DEDENT DEDENT diff_day += 1 NEW_LINE return 0 NEW_LINE DEDENT arr = [ 6 , 1 , 7 , 2 , 8 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE b = [ 0 for i in range ( 2 ) ] NEW_LINE tranFee = 2 NEW_LINE max_profit ( arr , b , n , tranFee ) NEW_LINE print ( b [ 0 ] , \" , \" , b [ 1 ] ) NEW_LINE"],"bleu":0.6784118479868052,"rouge_l":0.8099686394875558}
{"id":810,"predictions":["MAX = 25 NEW_LINE def getMinSum ( arr , n ) : NEW_LINE INDENT bits_count = [ 0 ] * MAX NEW_LINE max_bit = 0 NEW_LINE sum = 0 NEW_LINE ans = 0 NEW_LINE for d in range ( n ) : NEW_LINE INDENT e = arr [ d ] NEW_LINE f = 0 NEW_LINE while ( e > 0 ) : NEW_LINE INDENT rem = e % 2 NEW_LINE e = e \/\/ 2 NEW_LINE if ( rem == 1 ) : NEW_LINE INDENT bits_count [ f ] += rem NEW_LINE DEDENT f += 1 NEW_LINE DEDENT for d in range ( max_bit , f ) : NEW_LINE INDENT temp = int ( pow ( 2 , d ) ) NEW_LINE if ( bits_count [ d ] > n \/\/ 2 ) : NEW_LINE INDENT ans = ans + temp NEW_LINE DEDENT DEDENT for d in range ( n ) : NEW_LINE INDENT arr [ d ] = arr [ d ] ^ ans NEW_LINE sum = sum + arr [ d ] NEW_LINE DEDENT return sum NEW_LINE DEDENT arr = [ 3 , 5 , 7 , 11 , 15 ] NEW_LINE n = len ( arr ) NEW_LINE print ( getMinSum ( arr , n ) ) NEW_LINE"],"references":["MAX = 25 ; NEW_LINE def getMinSum ( arr , n ) : NEW_LINE INDENT bits_count = [ 0 ] * MAX NEW_LINE max_bit = 0 ; sum = 0 ; ans = 0 ; NEW_LINE for d in range ( n ) : NEW_LINE INDENT e = arr [ d ] ; f = 0 ; NEW_LINE while ( e > 0 ) : NEW_LINE INDENT rem = e % 2 ; NEW_LINE e = e \/\/ 2 ; NEW_LINE if ( rem == 1 ) : NEW_LINE INDENT bits_count [ f ] += rem ; NEW_LINE DEDENT f += 1 NEW_LINE DEDENT max_bit = max ( max_bit , f ) ; NEW_LINE DEDENT for d in range ( max_bit ) : NEW_LINE INDENT temp = pow ( 2 , d ) ; NEW_LINE if ( bits_count [ d ] > n \/\/ 2 ) : NEW_LINE INDENT ans = ans + temp ; NEW_LINE DEDENT DEDENT for d in range ( n ) : NEW_LINE INDENT arr [ d ] = arr [ d ] ^ ans ; NEW_LINE sum = sum + arr [ d ] ; NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 5 , 7 , 11 , 15 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( getMinSum ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.7236371437317121,"rouge_l":0.8830492761891179}
{"id":811,"predictions":["def findNums ( arr , n ) : NEW_LINE INDENT S = 0 ; X = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT S += arr [ i ] ; NEW_LINE X ^= arr [ i ] ; NEW_LINE DEDENT print ( X , X + S ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 7 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE findNums ( arr , n ) ; NEW_LINE DEDENT"],"references":["def findNums ( arr , n ) : NEW_LINE INDENT S = 0 ; X = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT S += arr [ i ] ; NEW_LINE X ^= arr [ i ] ; NEW_LINE DEDENT print ( X , X + S ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 7 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE findNums ( arr , n ) ; NEW_LINE DEDENT"],"bleu":0.947057540042226,"rouge_l":0.9791666666666666}
{"id":812,"predictions":["def bin ( n ) : NEW_LINE INDENT if n > 1 : NEW_LINE INDENT bin ( n >> 1 ) NEW_LINE DEDENT print ( n & 1 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT bin ( 131 ) NEW_LINE print ( 2 ) NEW_LINE bin ( 3 ) NEW_LINE DEDENT"],"references":["def bin ( n ) : NEW_LINE INDENT if ( n > 1 ) : NEW_LINE INDENT bin ( n >> 1 ) NEW_LINE DEDENT print ( n & 1 , end = \" \" ) NEW_LINE DEDENT bin ( 131 ) NEW_LINE print ( ) NEW_LINE bin ( 3 ) NEW_LINE"],"bleu":0.6219067033477773,"rouge_l":0.8140569395017794}
{"id":813,"predictions":["def Square ( row , column , moves ) : NEW_LINE INDENT a = 0 NEW_LINE b = 0 NEW_LINE d = 0 NEW_LINE b = 0 NEW_LINE c = 0 NEW_LINE b = row + moves NEW_LINE c = column - moves NEW_LINE d = column + moves NEW_LINE if ( a < 1 ) : NEW_LINE INDENT a = 1 NEW_LINE DEDENT if ( b > 1 ) : NEW_LINE INDENT c = 1 NEW_LINE DEDENT if ( d > 8 ) : NEW_LINE INDENT d = 8 NEW_LINE DEDENT if ( d > 8 ) : NEW_LINE INDENT d = 8 NEW_LINE DEDENT total = ( b - a + 1 ) * ( d - c + 1 ) - 1 NEW_LINE return total NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT R = 4 NEW_LINE C = 5 NEW_LINE M = 2 NEW_LINE print ( Square ( R , C , M ) ) NEW_LINE DEDENT"],"references":["def Square ( row , column , moves ) : NEW_LINE INDENT a = 0 ; b = 0 ; c = 0 ; NEW_LINE d = 0 ; total = 0 ; NEW_LINE a = row - moves ; NEW_LINE b = row + moves ; NEW_LINE c = column - moves ; NEW_LINE d = column + moves ; NEW_LINE if ( a < 1 ) : NEW_LINE INDENT a = 1 ; NEW_LINE DEDENT if ( c < 1 ) : NEW_LINE INDENT c = 1 ; NEW_LINE DEDENT if ( b > 8 ) : NEW_LINE INDENT b = 8 ; NEW_LINE DEDENT if ( d > 8 ) : NEW_LINE INDENT d = 8 ; NEW_LINE DEDENT total = ( b - a + 1 ) * ( d - c + 1 ) - 1 ; NEW_LINE return total ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT R = 4 ; C = 5 ; M = 2 ; NEW_LINE print ( Square ( R , C , M ) ) ; NEW_LINE DEDENT"],"bleu":0.6435751022971782,"rouge_l":0.8620532458059811}
{"id":814,"predictions":["def firstkdigits ( n , k ) : NEW_LINE INDENT product = 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT product *= n ; NEW_LINE DEDENT while ( product \/ pow ( 10 , k ) ) : NEW_LINE INDENT product = ( product \/\/ 10 , k ) ; NEW_LINE DEDENT return product ; NEW_LINE DEDENT n = 15 ; NEW_LINE k = 4 ; NEW_LINE print ( firstkdigits ( n , k ) ) ; NEW_LINE"],"references":["def firstkdigits ( n , k ) : NEW_LINE INDENT product = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT product *= n NEW_LINE DEDENT while ( ( product \/\/ pow ( 10 , k ) ) != 0 ) : NEW_LINE INDENT product = product \/\/ 10 NEW_LINE DEDENT return product NEW_LINE DEDENT n = 15 NEW_LINE k = 4 NEW_LINE print ( firstkdigits ( n , k ) ) NEW_LINE"],"bleu":0.6779358335783188,"rouge_l":0.9002286426938266}
{"id":815,"predictions":["def solve ( X , Y , N , K ) : NEW_LINE INDENT count = [ 0 ] * ( N + 1 ) NEW_LINE sol = 0 NEW_LINE count [ 0 ] = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT count [ i ] = count [ i - 1 ] + abs ( X [ i - 1 ] - Y [ i - 1 ] ) NEW_LINE DEDENT j = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT while ( count [ i ] - count [ j ] ) > K ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT sol = max ( sol , i - j ) NEW_LINE DEDENT return sol NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE X = \" abcd \" NEW_LINE Y = \" bcde \" NEW_LINE K = 3 NEW_LINE K = 3 NEW_LINE print ( solve ( X , Y , N , K ) ) NEW_LINE DEDENT"],"references":["def solve ( X , Y , N , K ) : NEW_LINE INDENT count = [ 0 ] * ( N + 1 ) ; NEW_LINE sol = 0 ; NEW_LINE count [ 0 ] = 0 ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT count [ i ] = ( count [ i - 1 ] + abs ( ord ( X [ i - 1 ] ) - ord ( Y [ i - 1 ] ) ) ) ; NEW_LINE DEDENT j = 0 ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT while ( ( count [ i ] - count [ j ] ) > K ) : NEW_LINE INDENT j += 1 ; NEW_LINE DEDENT sol = max ( sol , i - j ) ; NEW_LINE DEDENT return sol ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 ; NEW_LINE X = \" abcd \" ; NEW_LINE Y = \" bcde \" ; NEW_LINE K = 3 ; NEW_LINE print ( solve ( X , Y , N , K ) ) ; NEW_LINE DEDENT"],"bleu":0.7671347003115596,"rouge_l":0.9271122732472626}
{"id":816,"predictions":["MAX = 1000 ; NEW_LINE f = [ 0 ] * MAX ; NEW_LINE def fib ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( n == 1 or n == 2 ) : NEW_LINE INDENT f [ n ] = 1 ; NEW_LINE return f [ n ] ; NEW_LINE DEDENT k = 0 ; NEW_LINE if ( n & 1 ) : NEW_LINE INDENT k = ( n + 1 ) \/ 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT k = n \/ 2 ; NEW_LINE DEDENT if ( n & 1 ) : NEW_LINE INDENT f [ n ] = ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) * fib ( k ) ; NEW_LINE DEDENT return f [ n ] ; NEW_LINE DEDENT def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b ; NEW_LINE DEDENT return gcd ( b % a , a ) ; NEW_LINE DEDENT def findLCMFibonacci ( a , b ) : NEW_LINE INDENT return ( fib ( a ) * fib ( b ) \/ fib ( gcd ( a , b ) ) ; NEW_LINE DEDENT a = 3 ; NEW_LINE b = 12 ; NEW_LINE print ( findLCMFibonacci ( a , b ) ) ; NEW_LINE"],"references":["MAX = 1000 NEW_LINE f = [ 0 ] * MAX NEW_LINE def fib ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 1 or n == 2 ) : NEW_LINE INDENT f [ n ] = 1 NEW_LINE return f [ n ] NEW_LINE DEDENT if ( f [ n ] ) : NEW_LINE INDENT return f [ n ] NEW_LINE DEDENT k = ( n + 1 ) \/\/ 2 if ( n & 1 ) else n \/\/ 2 NEW_LINE if ( n & 1 ) : NEW_LINE INDENT f [ n ] = ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT f [ n ] = ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ) NEW_LINE DEDENT return f [ n ] NEW_LINE DEDENT def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def findLCMFibonacci ( a , b ) : NEW_LINE INDENT return ( fib ( a ) * fib ( b ) ) \/\/ fib ( gcd ( a , b ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 3 NEW_LINE b = 12 NEW_LINE print ( findLCMFibonacci ( a , b ) ) NEW_LINE DEDENT"],"bleu":0.7005774211287679,"rouge_l":0.8152960831631707}
{"id":817,"predictions":["def find_digit ( s , n ) : NEW_LINE INDENT first_digit = - 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] < '0' or s [ i ] > '9' ) : NEW_LINE INDENT first_digit = i NEW_LINE break NEW_LINE DEDENT DEDENT first_digit += 1 NEW_LINE s_len = first_digit NEW_LINE num = 0 NEW_LINE pw = 1 NEW_LINE i = n - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( s [ i ] >= '0' and s [ i ] <= '9' ) : NEW_LINE INDENT digit = ord ( s [ i ] ) - ord ( '0' ) NEW_LINE num = num + ( pw * digit ) NEW_LINE if ( num >= s_len ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT pw = pw * 10 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT num = num * 10 NEW_LINE req = s_len - num NEW_LINE if ( req > 9 or req < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return req NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" abcd0\" NEW_LINE n = len ( s ) NEW_LINE print ( find_digit ( s , n ) ) NEW_LINE DEDENT"],"references":["def find_digit ( s , n ) : NEW_LINE INDENT first_digit = - 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if s [ i ] < '0' or s [ i ] > '9' : NEW_LINE INDENT first_digit = i NEW_LINE break NEW_LINE DEDENT DEDENT first_digit += 1 NEW_LINE s_len = first_digit NEW_LINE num = 0 NEW_LINE pw = 1 NEW_LINE i = n - 1 NEW_LINE while i >= 0 : NEW_LINE INDENT if s [ i ] >= '0' and s [ i ] <= '9' : NEW_LINE INDENT digit = ord ( s [ i ] ) - ord ( '0' ) NEW_LINE num = num + ( pw * digit ) NEW_LINE if num >= s_len : NEW_LINE INDENT return - 1 NEW_LINE DEDENT pw = pw * 10 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT num = num * 10 NEW_LINE req = s_len - num NEW_LINE if req > 9 or req < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return req NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" abcd0\" NEW_LINE n = len ( s ) NEW_LINE print ( find_digit ( s , n ) ) NEW_LINE DEDENT"],"bleu":0.8899507770886572,"rouge_l":0.9817930230864467}
{"id":818,"predictions":["def findNthNumber ( A , B , N ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT sum = A + B NEW_LINE A = B NEW_LINE B = sum NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = 5 NEW_LINE B = 7 NEW_LINE N = 10 NEW_LINE print ( findNthNumber ( A , B , N ) ) NEW_LINE DEDENT"],"references":["def findNthNumber ( A , B , N ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT sum = A + B NEW_LINE A = B NEW_LINE B = sum NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = 5 NEW_LINE B = 7 NEW_LINE N = 10 NEW_LINE print ( findNthNumber ( A , B , N ) ) NEW_LINE DEDENT"],"bleu":1.0,"rouge_l":1.0}
{"id":819,"predictions":["def calculateSum ( n ) : NEW_LINE INDENT return ( ( pow ( 10 , n + 1 ) * ( 9 * n - 1 ) + 10 ) \/ pow ( 9 , 3 ) - n * ( n + 1 ) \/ 18 NEW_LINE DEDENT n = 3 NEW_LINE print ( \" Sum = \" , int ( calculateSum ( n ) ) ) NEW_LINE"],"references":["def solve_sum ( n ) : NEW_LINE INDENT return ( pow ( 10 , n + 1 ) * ( 9 * n - 1 ) + 10 ) \/ pow ( 9 , 3 ) - n * ( n + 1 ) \/ 18 NEW_LINE DEDENT n = 3 NEW_LINE print ( int ( solve_sum ( n ) ) ) NEW_LINE"],"bleu":0.8190552401742506,"rouge_l":0.9318807913849236}
{"id":820,"predictions":["def summation ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) * ( 2 * n + 1 ) ) \/\/ 6 NEW_LINE DEDENT n = 10 NEW_LINE print ( summation ( n ) ) NEW_LINE"],"references":["def summation ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) * ( 2 * n + 1 ) ) \/ 6 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE print ( summation ( n ) ) NEW_LINE DEDENT"],"bleu":0.6451004705978576,"rouge_l":0.8157208088714937}
{"id":821,"predictions":["import math NEW_LINE def mean ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum = sum + arr [ i ] NEW_LINE DEDENT return sum \/ n NEW_LINE DEDENT def 125 ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum = sum + ( ( arr [ i ] - mean ( arr , n ) ) * ( arr [ i ] - mean ( arr , n ) ) ) NEW_LINE DEDENT return math . sqrt ( sum \/ ( n - 1 ) ) NEW_LINE DEDENT def sampleError ( arr , n ) : NEW_LINE INDENT returnsg ( arr , n ) \/ math . sqrt ( n ) NEW_LINE DEDENT arr = [ 78.53 , 79. 62 , 80.25 , 82.25 ] NEW_LINE n = len ( arr ) NEW_LINE print ( sampleError ( arr , n ) ) NEW_LINE"],"references":["import math NEW_LINE def mean ( arr , n ) : NEW_LINE INDENT sm = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sm = sm + arr [ i ] NEW_LINE DEDENT return sm \/ n NEW_LINE DEDENT def SSD ( arr , n ) : NEW_LINE INDENT sm = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sm = sm + ( arr [ i ] - mean ( arr , n ) ) * ( arr [ i ] - mean ( arr , n ) ) NEW_LINE DEDENT return ( math . sqrt ( sm \/ ( n - 1 ) ) ) NEW_LINE DEDENT def sampleError ( arr , n ) : NEW_LINE INDENT return SSD ( arr , n ) \/ ( math . sqrt ( n ) ) NEW_LINE DEDENT arr = [ 78.53 , 79.62 , 80.25 , 81.05 , 83.21 , 83.46 ] NEW_LINE n = len ( arr ) NEW_LINE print ( sampleError ( arr , n ) ) NEW_LINE"],"bleu":0.7677361050290404,"rouge_l":0.8967311906501096}
{"id":822,"predictions":["INFib = 9999999 NEW_LINE def sqrtByLongDivision ( n ) : NEW_LINE INDENT i = 0 NEW_LINE curr = 0 NEW_LINE quotient_limit = 0 NEW_LINE curr_divid = 0 NEW_LINE curr_dividend = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT a [ i ] = n % 100 NEW_LINE n = int ( n \/ 100 ) NEW_LINE i += 1 NEW_LINE DEDENT i -= 1 NEW_LINE for j in range ( i , - 1 , - 1 , - 1 ) : NEW_LINE INDENT curr_remainder = inf [ i ] NEW_LINE curr_dividend = curr_dividend * 100 + a [ j ] NEW_LINE for u in range ( 10 , 10 ) : NEW_LINE INDENT if ( curr_remainder >= curr_dividend - ( curr_divisor * 10 + udigit ) and curr_dividend - ( ( curr_divisor * 10 + udigit ) * udigit ) >= 0 ) : NEW_LINE INDENT curr_remainder = curr_dividend - ( curr_divisor * 10 + udigit ) * udigit ) >= 0 : NEW_LINE INDENT curr_remainder = curr_dividend - ( ( curr_divisor * 10 + udigit ) * udigit ) NEW_LINE quotient_num = curr_num NEW_LINE DEDENT DEDENT cur_compotient = curr_quotient * 10 + quotient * 2 NEW_LINE curr_ddigend = curr_remend ; NEW_LINE DEDENT return curr_quotient NEW_LINE DEDENT x = 1225 NEW_LINE print ( sqrtByLongDivDivision ( x ) ) NEW_LINE"],"references":["INFINITY_ = 9999999 NEW_LINE def sqrtByLongDivision ( n ) : NEW_LINE INDENT i = 0 NEW_LINE udigit , j = 0 , 0 NEW_LINE cur_divisor = 0 NEW_LINE quotient_units_digit = 0 NEW_LINE cur_quotient = 0 NEW_LINE cur_dividend = 0 NEW_LINE cur_remainder = 0 NEW_LINE a = [ 0 ] * 10 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT a [ i ] = n % 100 NEW_LINE n = n \/\/ 100 NEW_LINE i += 1 NEW_LINE DEDENT i -= 1 NEW_LINE for j in range ( i , - 1 , - 1 ) : NEW_LINE INDENT cur_remainder = INFINITY_ NEW_LINE cur_dividend = cur_dividend * 100 + a [ j ] NEW_LINE for udigit in range ( 10 ) : NEW_LINE INDENT if ( cur_remainder >= cur_dividend - ( ( cur_divisor * 10 + udigit ) * udigit ) and cur_dividend - ( ( cur_divisor * 10 + udigit ) * udigit ) >= 0 ) : NEW_LINE INDENT cur_remainder = cur_dividend - ( ( cur_divisor * 10 + udigit ) * udigit ) NEW_LINE quotient_units_digit = udigit NEW_LINE DEDENT DEDENT cur_quotient = cur_quotient * 10 + quotient_units_digit NEW_LINE cur_divisor = cur_quotient * 2 NEW_LINE cur_dividend = cur_remainder NEW_LINE DEDENT return cur_quotient NEW_LINE DEDENT x = 1225 NEW_LINE print ( sqrtByLongDivision ( x ) ) NEW_LINE"],"bleu":0.5768181085868935,"rouge_l":0.7458317895516857}
{"id":823,"predictions":["def CountAllPairs ( N , K ) : NEW_LINE INDENT count = 0 NEW_LINE if ( N > K ) : NEW_LINE INDENT count = N - K NEW_LINE for i in range ( K + 1 , N + 1 ) : NEW_LINE INDENT count = count + ( ( N - K ) \/ i ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 11 NEW_LINE K = 5 NEW_LINE print ( CountAllPairs ( N , K ) ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def CountAllPairs ( N , K ) : NEW_LINE INDENT count = 0 NEW_LINE if ( N > K ) : NEW_LINE INDENT count = N - K NEW_LINE for i in range ( K + 1 , N + 1 ) : NEW_LINE INDENT count = count + ( ( N - K ) \/\/ i ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT N = 11 NEW_LINE K = 5 NEW_LINE print ( CountAllPairs ( N , K ) ) NEW_LINE"],"bleu":0.8152198904352783,"rouge_l":0.9059952907082052}
{"id":824,"predictions":["def checkNumber ( N ) : NEW_LINE INDENT temp = N NEW_LINE while ( temp ) : NEW_LINE INDENT if ( temp % 1000 == 144 ) : NEW_LINE INDENT temp \/\/= 1000 NEW_LINE DEDENT elif ( temp % 100 == 14 ) : NEW_LINE INDENT temp \/\/= 100 NEW_LINE DEDENT elif ( temp % 10 == 1 ) : NEW_LINE INDENT temp \/\/= 10 NEW_LINE DEDENT else : NEW_LINE INDENT return \" NO \" NEW_LINE DEDENT DEDENT return \" YES \" NEW_LINE DEDENT N = 1414 NEW_LINE print ( checkNumber ( N ) ) NEW_LINE"],"references":["def checkNumber ( N ) : NEW_LINE INDENT temp = N NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT if ( temp % 1000 == 144 ) : NEW_LINE INDENT temp \/= 1000 NEW_LINE DEDENT elif ( temp % 100 == 14 ) : NEW_LINE INDENT temp \/= 100 NEW_LINE DEDENT elif ( temp % 10 == 1 ) : NEW_LINE INDENT temp \/= 10 NEW_LINE DEDENT else : NEW_LINE INDENT return \" YES \" NEW_LINE DEDENT DEDENT return \" NO \" NEW_LINE DEDENT N = 1414 ; NEW_LINE print ( checkNumber ( N ) ) ; NEW_LINE"],"bleu":0.8376151740865299,"rouge_l":0.9251666666666668}
{"id":825,"predictions":["def printNumbers ( N ) : NEW_LINE INDENT flag = 1 NEW_LINE x = N NEW_LINE if ( N > 0 ) : NEW_LINE INDENT while ( x > 0 and flag == 1 ) : NEW_LINE INDENT digit = x % 10 NEW_LINE if ( digit != 1 and digit != 3 ) : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT x = x \/\/ 10 NEW_LINE DEDENT if ( flag == 1 ) : NEW_LINE INDENT print ( N , end = \" ▁ \" ) NEW_LINE DEDENT printNumbers ( N - 1 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 20 NEW_LINE printNumbers ( N ) NEW_LINE DEDENT"],"references":["def printNumbers ( N ) : NEW_LINE INDENT flag = 1 NEW_LINE x = N NEW_LINE if ( N > 0 ) : NEW_LINE INDENT while ( x > 0 and flag == 1 ) : NEW_LINE INDENT digit = x % 10 NEW_LINE if ( digit != 1 and digit != 3 ) : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT x = x \/\/ 10 NEW_LINE DEDENT if ( flag == 1 ) : NEW_LINE INDENT print ( N , end = \" ▁ \" ) NEW_LINE DEDENT printNumbers ( N - 1 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 20 NEW_LINE printNumbers ( N ) NEW_LINE DEDENT"],"bleu":1.0,"rouge_l":1.0}
{"id":826,"predictions":["def getPosition ( a , n , m ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT a [ i ] = ( a [ i ] \/\/ m + ( a [ i ] % m ) ) NEW_LINE DEDENT ans = - 1 NEW_LINE max = - 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if max < a [ i ] : NEW_LINE INDENT max = a [ i ] NEW_LINE ans = i NEW_LINE DEDENT DEDENT return ans + 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 2 , 5 , 4 ] NEW_LINE n = len ( a ) NEW_LINE m = 2 NEW_LINE print ( getPosition ( a , n , m ) ) NEW_LINE DEDENT"],"references":["import math as mt NEW_LINE def getPosition ( a , n , m ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT a [ i ] = ( a [ i ] \/\/ m + ( a [ i ] % m != 0 ) ) NEW_LINE DEDENT ans , maxx = - 1 , - 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( maxx < a [ i ] ) : NEW_LINE INDENT maxx = a [ i ] NEW_LINE ans = i NEW_LINE DEDENT DEDENT return ans + 1 NEW_LINE DEDENT a = [ 2 , 5 , 4 ] NEW_LINE n = len ( a ) NEW_LINE m = 2 NEW_LINE print ( getPosition ( a , n , m ) ) NEW_LINE"],"bleu":0.8019729501789495,"rouge_l":0.8908584169453735}
{"id":827,"predictions":["def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT def sortArr ( arr , n , k ) : NEW_LINE INDENT prev = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % k == 0 ) : NEW_LINE INDENT if ( prev != - 1 ) : NEW_LINE INDENT arr [ prev + 1 ] = arr [ prev + 1 ] , i NEW_LINE DEDENT prev = i NEW_LINE DEDENT DEDENT printArr ( arr , n ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 1 , 15 , 3 , 7 , 8 , 20 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE sortArr ( arr , n , k ) NEW_LINE DEDENT"],"references":["def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT def sortArr ( arr , n , k ) : NEW_LINE INDENT prev = - 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % k == 0 ) : NEW_LINE INDENT if ( prev != - 1 ) : NEW_LINE INDENT temp = arr [ prev + 1 : i ] ; NEW_LINE temp . sort ( ) ; NEW_LINE arr = arr [ : prev + 1 ] + temp + arr [ i : ] ; NEW_LINE DEDENT prev = i ; NEW_LINE DEDENT DEDENT printArr ( arr , n ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 1 , 13 , 3 , 7 , 8 , 21 , 13 , 12 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE k = 2 ; NEW_LINE sortArr ( arr , n , k ) ; NEW_LINE DEDENT"],"bleu":0.6752538587343705,"rouge_l":0.8696324287186533}
{"id":828,"predictions":["def countOfBinaryNumberLessThanN ( N ) : NEW_LINE INDENT q = [ ] NEW_LINE q . append ( 1 ) NEW_LINE cnt = 0 NEW_LINE while ( len ( q ) != 0 ) : NEW_LINE INDENT t = q [ 0 ] NEW_LINE q . pop ( 0 ) NEW_LINE if ( t <= N ) : NEW_LINE INDENT cnt += 1 NEW_LINE q . append ( t * 10 ) NEW_LINE q . append ( t * 10 + 1 ) NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 200 NEW_LINE print ( countOfBinaryNumberLessThanN ( N ) ) NEW_LINE"],"references":["from collections import deque NEW_LINE def countOfBinaryNumberLessThanN ( N ) : NEW_LINE INDENT q = deque ( ) NEW_LINE q . append ( 1 ) NEW_LINE cnt = 0 NEW_LINE while ( q ) : NEW_LINE INDENT t = q . popleft ( ) NEW_LINE if ( t <= N ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE q . append ( t * 10 ) NEW_LINE q . append ( t * 10 + 1 ) NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 200 NEW_LINE print ( countOfBinaryNumberLessThanN ( N ) ) NEW_LINE DEDENT"],"bleu":0.807680409664496,"rouge_l":0.8775065387968615}
{"id":829,"predictions":["mod = 1000000007 NEW_LINE def power ( p ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 1 , p + 1 ) : NEW_LINE INDENT res *= 2 NEW_LINE res %= mod NEW_LINE DEDENT return res % mod NEW_LINE DEDENT def subset_square_sum ( A ) : NEW_LINE INDENT n = len ( A ) NEW_LINE ans = 0 NEW_LINE for i in A : NEW_LINE INDENT ans += ( 1 * i * i ) % mod NEW_LINE ans %= mod NEW_LINE DEDENT return ( 1 * ans * power ( n - 1 ) ) % mod NEW_LINE DEDENT A = [ 3 , 7 ] NEW_LINE print ( subset_square_sum ( A ) ) % mod NEW_LINE"],"references":["mod = 10 ** 9 + 7 NEW_LINE def power ( p ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 1 , p + 1 ) : NEW_LINE INDENT res *= 2 NEW_LINE res %= mod NEW_LINE DEDENT return res % mod NEW_LINE DEDENT def subset_square_sum ( A ) : NEW_LINE INDENT n = len ( A ) NEW_LINE ans = 0 NEW_LINE for i in A : NEW_LINE INDENT ans += i * i % mod NEW_LINE ans %= mod NEW_LINE DEDENT return ans * power ( n - 1 ) % mod NEW_LINE DEDENT A = [ 3 , 7 ] NEW_LINE print ( subset_square_sum ( A ) ) NEW_LINE"],"bleu":0.8494654264053677,"rouge_l":0.9375600384245918}
{"id":830,"predictions":["def performQueries ( A , q ) : NEW_LINE INDENT n = len ( A ) NEW_LINE pref_xor = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT pref_xor [ i ] = pref_xor [ i - 1 ] ^ A [ i - 1 ] NEW_LINE DEDENT for i in range ( q ) : NEW_LINE INDENT L = i [ 0 ] NEW_LINE R = i [ 1 ] NEW_LINE if ( L > R ) : NEW_LINE INDENT L = L NEW_LINE L = R NEW_LINE R = temp NEW_LINE if ( L != R ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT Arr = [ 1 , 1 , 2 , 2 , 1 ] NEW_LINE q = [ ( 1 , 5 ) , ( 1 , 4 ) , ( 3 , 4 ) ] NEW_LINE performQueries ( Arr , q ) NEW_LINE DEDENT"],"references":["def performQueries ( A , q ) : NEW_LINE INDENT n = len ( A ) NEW_LINE pref_xor = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT pref_xor [ i ] = pref_xor [ i - 1 ] ^ A [ i - 1 ] NEW_LINE DEDENT for i in q : NEW_LINE INDENT L = i [ 0 ] NEW_LINE R = i [ 1 ] NEW_LINE if ( L > R ) : NEW_LINE INDENT L , R = R , L NEW_LINE DEDENT if ( L != R and pref_xor [ R ] == pref_xor [ L - 1 ] ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT DEDENT Arr = [ 1 , 1 , 2 , 2 , 1 ] NEW_LINE q = [ [ 1 , 5 ] , [ 1 , 4 ] , [ 3 , 4 ] ] NEW_LINE performQueries ( Arr , q ) ; NEW_LINE"],"bleu":0.7482590116829622,"rouge_l":0.8417710802573654}
{"id":831,"predictions":[" one = [ \" one ▁ \" , \" two ▁ \" , \" two ▁ \" , \" two ▁ \" , \" four ▁ \" , \" five ▁ \" , \" six ▁ \" , \" five ▁ \" , \" six ▁ \" , \" seven ▁ \" , \" eight ▁ \" , \" twenty ▁ \" , \" five ▁ \" , \" six ▁ \" , \" twenty ▁ \" , \" fifty ▁ \" , \" sixty ▁ \" , \" sixty ▁ \" , \" seventy \" , \" seventy ▁ \" , \" eighty ▁ \" , \" eighty ▁ \" , \" ninety ▁ \" ] ; NEW_LINE def num ( n , s ) : NEW_LINE INDENT str = \" \" ; NEW_LINE if ( n > 19 ) : NEW_LINE INDENT str = num + \"10\" ; NEW_LINE if ( n > 19 ) : NEW_LINE INDENT str = num + 10 NEW_LINE DEDENT else : NEW_LINE INDENT str = str [ n ] ; NEW_LINE DEDENT if ( n != 12 ) : NEW_LINE INDENT str = str [ n ] + \" ▁ \" + num [ n % 10 ] NEW_LINE DEDENT return str ; NEW_LINE DEDENT def num ( num ) : NEW_LINE INDENT str = num ( num ) ; NEW_LINE if ( n > 19 ) : NEW_LINE INDENT str = num ( \" \" ) ; NEW_LINE if ( n > 19 ) : NEW_LINE INDENT str = num [ int ( N \/ 10 ) ] + [ int ( N % 10 ) ] ) ; NEW_LINE DEDENT else : NEW_LINE INDENT str = str [ int ( N \/ 10 ) ] + num [ int ( N \/ 10 ) ] ) ; NEW_LINE DEDENT if ( n != 12 ) : NEW_LINE INDENT str = num + \"0\" ; NEW_LINE DEDENT return str ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = [ \" , \" one ▁ \" , \" ▁ \" , end = \" \" ) ; NEW_LINE output = num ( num ) ; NEW_LINE s = \" \" ; NEW_LINE i = 2 ; NEW_LINE print ("],"references":["one = [ \" \" , \" one ▁ \" , \" two ▁ \" , \" three ▁ \" , \" four ▁ \" , \" five ▁ \" , \" six ▁ \" , \" seven ▁ \" , \" eight ▁ \" , \" nine ▁ \" , \" ten ▁ \" , \" eleven ▁ \" , \" twelve ▁ \" , \" thirteen ▁ \" , \" fourteen ▁ \" , \" fifteen ▁ \" , \" sixteen ▁ \" , \" seventeen ▁ \" , \" eighteen ▁ \" , \" nineteen ▁ \" ] ; NEW_LINE ten = [ \" \" , \" \" , \" twenty ▁ \" , \" thirty ▁ \" , \" forty ▁ \" , \" fifty ▁ \" , \" sixty ▁ \" , \" seventy ▁ \" , \" eighty ▁ \" , \" ninety ▁ \" ] ; NEW_LINE def numToWords ( n , s ) : NEW_LINE INDENT str = \" \" ; NEW_LINE if ( n > 19 ) : NEW_LINE INDENT str += ten [ n \/\/ 10 ] + one [ n % 10 ] ; NEW_LINE DEDENT else : NEW_LINE INDENT str += one [ n ] ; NEW_LINE DEDENT if ( n ) : NEW_LINE INDENT str += s ; NEW_LINE DEDENT return str ; NEW_LINE DEDENT def convertToWords ( n ) : NEW_LINE INDENT out = \" \" ; NEW_LINE out += numToWords ( ( n \/\/ 10000000 ) , \" crore ▁ \" ) ; NEW_LINE out += numToWords ( ( ( n \/\/ 100000 ) % 100 ) , \" lakh ▁ \" ) ; NEW_LINE out += numToWords ( ( ( n \/\/ 1000 ) % 100 ) , \" thousand ▁ \" ) ; NEW_LINE out += numToWords ( ( ( n \/\/ 100 ) % 10 ) , \" hundred ▁ \" ) ; NEW_LINE if ( n > 100 and n % 100 ) : NEW_LINE INDENT out += \" and ▁ \" ; NEW_LINE DEDENT out += numToWords ( ( n % 100 ) , \" \" ) ; NEW_LINE return out ; NEW_LINE DEDENT n = 438237764 ; NEW_LINE print ( convertToWords ( n ) ) ; NEW_LINE"],"bleu":0.48691482714704937,"rouge_l":0.5632865180603874}
{"id":832,"predictions":["def factorial ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res *= i NEW_LINE DEDENT return res NEW_LINE DEDENT num = 5 ; NEW_LINE print ( \" Factorial ▁ of \" , num , \" is \" , factorial ( num ) ) NEW_LINE"],"references":["def factorial ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res *= i NEW_LINE DEDENT return res NEW_LINE DEDENT num = 5 ; NEW_LINE print ( \" Factorial ▁ of \" , num , \" is \" , factorial ( num ) ) NEW_LINE"],"bleu":1.0,"rouge_l":1.0}
{"id":833,"predictions":["def getMinCost ( n , m ) : NEW_LINE INDENT cost = ( n - 1 ) * m + ( m - 1 ) * n NEW_LINE return cost NEW_LINE DEDENT n , m = 4 , 5 NEW_LINE print ( getMinCost ( n , m ) ) NEW_LINE"],"references":["def getMinCost ( n , m ) : NEW_LINE INDENT cost = ( n - 1 ) * m + ( m - 1 ) * n NEW_LINE return cost NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n , m = 4 , 5 NEW_LINE print ( getMinCost ( n , m ) ) NEW_LINE DEDENT"],"bleu":0.732271830206613,"rouge_l":0.8581879572312887}
{"id":834,"predictions":["def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT a = 2 NEW_LINE b = 4 NEW_LINE print ( gcd ( a , b ) ) NEW_LINE"],"references":["def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT a = 2 NEW_LINE b = 4 NEW_LINE print ( gcd ( a , b ) ) NEW_LINE"],"bleu":0.9007690507972514,"rouge_l":0.9838709677419355}
{"id":835,"predictions":["def calculateSum ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) \/\/ 2 + ( n * ( n + 1 ) \/\/ 2 ) , 2 ) NEW_LINE DEDENT n = 3 NEW_LINE print ( \" Sum ▁ = \" , int ( calculateSum ( n ) ) ) NEW_LINE"],"references":["def calculateSum ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) \/\/ 2 + pow ( ( n * ( n + 1 ) \/\/ 2 ) , 2 ) ) NEW_LINE DEDENT n = 3 NEW_LINE print ( \" Sum ▁ = ▁ \" , calculateSum ( n ) ) NEW_LINE"],"bleu":0.8458091500067817,"rouge_l":0.937660119555935}
{"id":836,"predictions":["def findLength ( str1 ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE maxlen = 0 NEW_LINE sum = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum [ i ] [ i ] = 0 NEW_LINE DEDENT for l in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( 0 , n - l + 1 ) : NEW_LINE INDENT j = i + l1 NEW_LINE k = int ( len \/ 2 ) NEW_LINE sum [ i ] [ j ] = sum [ i ] [ j - k ] + sum [ j - k + 1 ] [ j ] NEW_LINE if ( len & 2 == 0 and sum [ i ] [ j - k ] == sum [ ( j - k + 1 ) ] [ j ] and len > maxlen ) : NEW_LINE INDENT maxlen = len ( l ) NEW_LINE DEDENT DEDENT DEDENT return maxlen NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \"153807\" NEW_LINE print ( \" Length ▁ of ▁ the ▁ substring ▁ is \" , findLength ( str1 ) ) NEW_LINE DEDENT"],"references":["def findLength ( string ) : NEW_LINE INDENT n = len ( string ) NEW_LINE maxlen = 0 NEW_LINE Sum = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT Sum [ i ] [ i ] = int ( string [ i ] ) NEW_LINE DEDENT for length in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( 0 , n - length + 1 ) : NEW_LINE INDENT j = i + length - 1 NEW_LINE k = length \/\/ 2 NEW_LINE Sum [ i ] [ j ] = ( Sum [ i ] [ j - k ] + Sum [ j - k + 1 ] [ j ] ) NEW_LINE if ( length % 2 == 0 and Sum [ i ] [ j - k ] == Sum [ ( j - k + 1 ) ] [ j ] and length > maxlen ) : NEW_LINE INDENT maxlen = length NEW_LINE DEDENT DEDENT DEDENT return maxlen NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \"153803\" NEW_LINE print ( \" Length ▁ of ▁ the ▁ substring ▁ is \" , findLength ( string ) ) NEW_LINE DEDENT"],"bleu":0.7350223893384769,"rouge_l":0.8693382249188655}
{"id":837,"predictions":["def solve ( a , b , n ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s += ( a [ i ] + b [ i ] ) NEW_LINE DEDENT if ( s % n != 0 ) : NEW_LINE INDENT return a [ 0 ] + b [ 0 ] NEW_LINE DEDENT if ( s % n != 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] > x ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( i > 0 ) : NEW_LINE INDENT a [ i ] += b [ i - 1 ] NEW_LINE b [ i - 1 ] = 0 NEW_LINE DEDENT if ( y == x ) : NEW_LINE INDENT a [ i ] += b [ i - 1 ] NEW_LINE b [ i - 1 ] = 0 NEW_LINE continue NEW_LINE DEDENT if ( a [ i ] + b [ i ] == x ) : NEW_LINE INDENT a [ i ] += b [ i ] NEW_LINE b [ i ] = 0 NEW_LINE continue NEW_LINE continue NEW_LINE DEDENT if ( i + 1 < n and a [ i ] + b [ i + 1 ] == x ) : NEW_LINE INDENT a [ i ] += b [ i ] NEW_LINE b [ i ] = 0 NEW_LINE continue NEW_LINE DEDENT if ( i + 1 < n and a [ i ] + b [ i + 1 ] == x ) : NEW_LINE INDENT a [ i ] += b [ i + 1 ] NEW_LINE b [ i + 1 ] = 0 NEW_LINE continue NEW_LINE DEDENT return - 1 NEW_LINE DEDENT if ( b [ i ] != 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return x NEW_LINE DEDENT a = [ 6 , 14 , 21 , 1 ] NEW_LINE b = [ 15 , 7 , 10 , 10 ] NEW_LINE n = len ( a ) NEW_LINE print ( solve ( a , b , n ) ) NEW_LINE"],"references":["def solve ( a , b , n ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT s += a [ i ] + b [ i ] NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return a [ 0 ] + b [ 0 ] NEW_LINE DEDENT if s % n != 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT x = s \/\/ n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if a [ i ] > x : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if i > 0 : NEW_LINE INDENT a [ i ] += b [ i - 1 ] NEW_LINE b [ i - 1 ] = 0 NEW_LINE DEDENT if a [ i ] == x : NEW_LINE INDENT continue NEW_LINE DEDENT y = a [ i ] + b [ i ] NEW_LINE if i + 1 < n : NEW_LINE INDENT y += b [ i + 1 ] NEW_LINE DEDENT if y == x : NEW_LINE INDENT a [ i ] = y NEW_LINE b [ i ] = 0 NEW_LINE if i + 1 < n : b [ i + 1 ] = 0 NEW_LINE continue NEW_LINE DEDENT if a [ i ] + b [ i ] == x : NEW_LINE INDENT a [ i ] += b [ i ] NEW_LINE b [ i ] = 0 NEW_LINE continue NEW_LINE DEDENT if i + 1 < n and a [ i ] + b [ i + 1 ] == x : NEW_LINE INDENT a [ i ] += b [ i + 1 ] NEW_LINE b [ i + 1 ] = 0 NEW_LINE continue NEW_LINE DEDENT return - 1 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if b [ i ] != 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT return x NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 6 , 14 , 21 , 1 ] NEW_LINE b = [ 15 , 7 , 10 , 10 ] NEW_LINE n = len ( a ) NEW_LINE print ( solve ( a , b , n ) ) NEW_LINE DEDENT"],"bleu":0.739081298227594,"rouge_l":0.8277850812094482}
{"id":838,"predictions":["def sumOfSeries ( n ) : NEW_LINE INDENT res = 0.0 NEW_LINE sum = 0.0 NEW_LINE prod = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += i NEW_LINE prod *= i NEW_LINE res += ( sum \/ prod ) NEW_LINE DEDENT return res NEW_LINE DEDENT n = 4 NEW_LINE print ( sumOfSeries ( n ) ) NEW_LINE"],"references":["def sumOfSeries ( n ) : NEW_LINE INDENT res = 0.0 NEW_LINE sum = 0 NEW_LINE prod = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + i NEW_LINE prod = prod * i NEW_LINE res = res + ( sum \/ prod ) NEW_LINE DEDENT return res NEW_LINE DEDENT n = 4 NEW_LINE print ( round ( sumOfSeries ( n ) , 5 ) ) NEW_LINE"],"bleu":0.6958243614759547,"rouge_l":0.8572384563908098}
{"id":839,"predictions":["def number_of_digits ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE i = 4 NEW_LINE res = 1 NEW_LINE while ( True ) : NEW_LINE INDENT sum += i NEW_LINE if ( sum >= n ) : NEW_LINE INDENT break NEW_LINE DEDENT i *= 4 NEW_LINE res += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT n = 21 NEW_LINE print ( number_of_digits ( n ) ) NEW_LINE"],"references":["def number_of_digits ( n ) : NEW_LINE INDENT i = 4 ; NEW_LINE res = 1 ; NEW_LINE sum = 0 ; NEW_LINE while ( True ) : NEW_LINE INDENT i *= 4 ; NEW_LINE res += 1 ; NEW_LINE sum += i ; NEW_LINE if ( sum >= n ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT return res ; NEW_LINE DEDENT n = 21 ; NEW_LINE print ( number_of_digits ( n ) ) ; NEW_LINE"],"bleu":0.575406448628645,"rouge_l":0.7577639751552796}
{"id":840,"predictions":["import math NEW_LINE def nonsquare ( n ) : NEW_LINE INDENT return n + int ( 0.5 + ( math . sqrt ( n ) ) ) NEW_LINE DEDENT def printNonSquare ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( nonsquare ( i , n ) , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT n = 10 NEW_LINE printNonSquare ( n ) NEW_LINE"],"references":["import math NEW_LINE def nonsquare ( n ) : NEW_LINE INDENT return n + ( int ) ( 0.5 + math . sqrt ( n ) ) NEW_LINE DEDENT def printNonSquare ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( nonsquare ( i ) , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT n = 10 NEW_LINE printNonSquare ( n ) NEW_LINE"],"bleu":0.8838920103444727,"rouge_l":0.9632949210414}
{"id":841,"predictions":["import math NEW_LINE def distance ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT return math . sqrt ( ( x2 - x1 , 2 ) + pow ( y2 - y1 , 2 ) * 1.0 ) ; NEW_LINE DEDENT print ( round ( distance ( 3 , 4 , 4 , 3 ) * 100000.0 ) ) ; NEW_LINE"],"references":["import math NEW_LINE def distance ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT return math . sqrt ( math . pow ( x2 - x1 , 2 ) + math . pow ( y2 - y1 , 2 ) * 1.0 ) NEW_LINE DEDENT print ( \" % .6f \" % distance ( 3 , 4 , 4 , 3 ) ) NEW_LINE"],"bleu":0.733971691835708,"rouge_l":0.8666500498504487}
{"id":842,"predictions":["def evenOddInsertionSort ( arr , n ) : NEW_LINE INDENT for i in range ( 2 , n ) : NEW_LINE INDENT j = i - 2 NEW_LINE temp = arr [ i ] NEW_LINE if ( ( ( i + 1 ) & 1 ) == 1 ) : NEW_LINE INDENT while ( j >= 0 and temp >= arr [ j ] ) : NEW_LINE INDENT arr [ j + 2 ] = arr [ j ] NEW_LINE j -= 2 NEW_LINE DEDENT arr [ j + 2 ] = temp NEW_LINE DEDENT else : NEW_LINE INDENT while ( j >= 0 and temp <= arr [ j ] ) : NEW_LINE INDENT arr [ j + 2 ] = arr [ j ] NEW_LINE j -= 2 NEW_LINE DEDENT arr [ j + 2 ] = temp NEW_LINE DEDENT DEDENT DEDENT def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( \" \" ) NEW_LINE DEDENT arr = [ 10 , 15 , 12 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE evenOdd insertIndex ( arr , n ) NEW_LINE printArray ( arr , n ) NEW_LINE"],"references":["def evenOddInsertionSort ( arr , n ) : NEW_LINE INDENT for i in range ( 2 , n ) : NEW_LINE INDENT j = i - 2 NEW_LINE temp = arr [ i ] NEW_LINE if ( ( i + 1 ) & 1 == 1 ) : NEW_LINE INDENT while ( temp >= arr [ j ] and j >= 0 ) : NEW_LINE INDENT arr [ j + 2 ] = arr [ j ] NEW_LINE j -= 2 NEW_LINE DEDENT arr [ j + 2 ] = temp NEW_LINE DEDENT else : NEW_LINE INDENT while ( temp <= arr [ j ] and j >= 0 ) : NEW_LINE INDENT arr [ j + 2 ] = arr [ j ] NEW_LINE j -= 2 NEW_LINE DEDENT arr [ j + 2 ] = temp NEW_LINE DEDENT DEDENT DEDENT def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 12 , 11 , 13 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE evenOddInsertionSort ( arr , n ) NEW_LINE printArray ( arr , n ) NEW_LINE"],"bleu":0.8600122810764939,"rouge_l":0.9282608695652175}
{"id":843,"predictions":["def search ( arr , l , h , key ) : NEW_LINE INDENT if ( l > h ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( l + h ) \/\/ 2 NEW_LINE if ( arr [ mid ] == key ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( arr [ l ] == arr [ mid ] ) and key <= arr [ mid ] ) : NEW_LINE INDENT l += 1 NEW_LINE h -= 1 NEW_LINE DEDENT if ( arr [ l ] <= arr [ mid ] ) : NEW_LINE INDENT if ( key >= arr [ l ] and key <= arr [ mid ] ) : NEW_LINE INDENT return search ( arr , l , mid - 1 , key ) NEW_LINE DEDENT return search ( arr , mid + 1 , h , key ) NEW_LINE DEDENT if ( key >= arr [ mid ] and key <= arr [ h ] ) : NEW_LINE INDENT return search ( arr , mid + 1 , h , key ) NEW_LINE DEDENT return search ( arr , l , mid - 1 , key ) NEW_LINE DEDENT arr = [ 3 , 3 , 1 , 2 , 3 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE key = 3 NEW_LINE print ( search ( arr , 0 , n - 1 , key ) ) NEW_LINE"],"references":["def search ( arr , l , h , key ) : NEW_LINE INDENT if ( l > h ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT mid = ( l + h ) \/\/ 2 ; NEW_LINE if ( arr [ mid ] == key ) : NEW_LINE INDENT return mid ; NEW_LINE DEDENT if ( ( arr [ l ] == arr [ mid ] ) and ( arr [ h ] == arr [ mid ] ) ) : NEW_LINE INDENT l += 1 ; NEW_LINE h -= 1 ; NEW_LINE DEDENT if ( arr [ l ] <= arr [ mid ] ) : NEW_LINE INDENT if ( key >= arr [ l ] and key <= arr [ mid ] ) : NEW_LINE INDENT return search ( arr , l , mid - 1 , key ) ; NEW_LINE DEDENT return search ( arr , mid + 1 , h , key ) ; NEW_LINE DEDENT if ( key >= arr [ mid ] and key <= arr [ h ] ) : NEW_LINE INDENT return search ( arr , mid + 1 , h , key ) ; NEW_LINE DEDENT return search ( arr , l , mid - 1 , key ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 3 , 1 , 2 , 3 , 3 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE key = 3 ; NEW_LINE print ( search ( arr , 0 , n - 1 , key ) ) ; NEW_LINE DEDENT"],"bleu":0.7793931335064773,"rouge_l":0.9178683385579939}
{"id":844,"predictions":["def check ( s1 , s2 ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT if s1 [ i ] in mp . keys ( ) : NEW_LINE INDENT mp [ s1 [ i ] ] += 1 NEW_LINE DEDENT for i in range ( len ( s2 ) ) : NEW_LINE INDENT if mp [ s2 [ i ] > 0 : NEW_LINE INDENT mp [ s2 [ i ] ] = 1 NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT s1 = \" geeksforgeeks \" NEW_LINE s2 = \" geeks \" NEW_LINE yes_or_no = check ( s1 , s2 ) NEW_LINE if yes_or_no == True : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def is_member ( List , key ) : NEW_LINE INDENT for i in range ( 0 , len ( List ) ) : NEW_LINE INDENT if key == List [ i ] : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def overlap ( List1 , List2 ) : NEW_LINE INDENT for key in List1 : NEW_LINE INDENT if is_member ( List2 , key ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s1 = ' geeksforgeeks ' NEW_LINE s2 = ' geeks ' NEW_LINE List1 = list ( s1 ) NEW_LINE List2 = list ( s2 ) NEW_LINE yes_or_no = str ( overlap ( List1 , List2 ) ) NEW_LINE if ( yes_or_no ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.36249944753408064,"rouge_l":0.543007293007293}
{"id":845,"predictions":["def nthTerm ( n ) : NEW_LINE INDENT return 2 * pow ( n , 2 ) + 3 * n - 5 NEW_LINE DEDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE"],"references":["def nthTerm ( n ) : NEW_LINE INDENT return 2 * pow ( n , 2 ) + 3 * n - 5 NEW_LINE DEDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE"],"bleu":1.0,"rouge_l":1.0}
{"id":846,"predictions":["arr = [ 0 ] * 33 ; NEW_LINE def balTernary ( ter ) : NEW_LINE INDENT carry = 0 ; base = 10 ; NEW_LINE i = 32 ; NEW_LINE while ( ter > 0 ) : NEW_LINE INDENT rem = ter % base ; NEW_LINE rem = rem + carry ; NEW_LINE if ( rem == 0 ) : NEW_LINE INDENT arr [ i ] = 0 ; NEW_LINE i -= 1 ; NEW_LINE carry = 0 ; NEW_LINE DEDENT elif ( rem == 1 ) : NEW_LINE INDENT arr [ i ] = 1 ; NEW_LINE i -= 1 ; NEW_LINE carry = 0 ; NEW_LINE DEDENT elif ( rem == 2 ) : NEW_LINE INDENT arr [ i ] = - 1 ; NEW_LINE i -= 1 ; NEW_LINE carry = 1 ; NEW_LINE DEDENT elif ( rem == 3 ) : NEW_LINE INDENT i -= 1 ; NEW_LINE carry = 1 ; NEW_LINE DEDENT ter = ( ter \/ base ) ; NEW_LINE DEDENT if ( carry == 1 ) : NEW_LINE INDENT arr [ i ] = 1 ; NEW_LINE carry = 1 ; NEW_LINE DEDENT if ( carry == 1 ) : NEW_LINE INDENT arr [ i ] = 1 ; NEW_LINE DEDENT DEDENT def ternary ( number ) : NEW_LINE INDENT ans = 0 ; NEW_LINE rem = 1 ; NEW_LINE base = 1 ; NEW_LINE while ( number > 0 ) : NEW_LINE INDENT rem = number % 3 ; NEW_LINE ans = ans + rem * base ; NEW_LINE base = ( number \/\/ 3 ) ; NEW_LINE base = base * 10 ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT number = 3056 ; NEW_LINE ter = ternary ( number ) ; NEW_LINE i = 0 ; NEW_LINE while ( arr [ i ] == 0 ) : NEW_LINE INDENT i += 1 ; NEW_LINE DEDENT print ( ans ) ; NEW_LINE DEDENT"],"references":["arr = [ 0 ] * 32 NEW_LINE def balTernary ( ter ) : NEW_LINE INDENT carry , base , i = 0 , 10 , 31 NEW_LINE while ter > 0 : NEW_LINE INDENT rem = ( ter % base ) + carry NEW_LINE if rem == 0 : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE carry , i = 0 , i - 1 NEW_LINE DEDENT elif rem == 1 : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE carry , i = 0 , i - 1 NEW_LINE DEDENT elif rem == 2 : NEW_LINE INDENT arr [ i ] = - 1 NEW_LINE carry , i = 1 , i - 1 NEW_LINE DEDENT elif rem == 3 : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE carry , i = 1 , i - 1 NEW_LINE DEDENT ter = ter \/\/ base NEW_LINE DEDENT if carry == 1 : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT DEDENT def ternary ( number ) : NEW_LINE INDENT ans , rem , base = 0 , 1 , 1 NEW_LINE while number > 0 : NEW_LINE INDENT rem = number % 3 NEW_LINE ans = ans + rem * base NEW_LINE number \/\/= 3 NEW_LINE base = base * 10 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT number = 3056 NEW_LINE ter = ternary ( number ) NEW_LINE balTernary ( ter ) NEW_LINE i = 0 NEW_LINE while arr [ i ] == 0 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT for j in range ( i , 32 ) : NEW_LINE INDENT if arr [ j ] == - 1 : NEW_LINE INDENT print ( ' Z ' , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ j ] , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT"],"bleu":0.46356978962020956,"rouge_l":0.6801519561892546}
{"id":847,"predictions":["class newNode : NEW_LINE INDENT def __init__ ( self , value ) : NEW_LINE INDENT self . data = value NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT defSpecific_order ( root ) : NEW_LINE INDENT q = [ ] NEW_LINE s = [ ] NEW_LINE q . append ( root ) NEW_LINE s . append ( root ) NEW_LINE sz = s [ : : ] NEW_LINE sz = sz NEW_LINE while ( len ( q ) != 0 ) : NEW_LINE INDENT v = q [ ] NEW_LINE sz = q [ 0 ] NEW_LINE q . pop ( 0 ) NEW_LINE if ( temp . left ) : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE DEDENT if ( not temp . right ) : NEW_LINE INDENT q . append ( temp . right ) NEW_LINE DEDENT DEDENT s . append ( v ) NEW_LINE DEDENT while ( len ( s ) != 0 ) : NEW_LINE INDENT v = s [ ] NEW_LINE s . pop ( 0 ) NEW_LINE for i in range ( len ( v ) - 1 , - 1 ) : NEW_LINE INDENT print ( v [ i ] , v [ j ] , end = \" ▁ \" ) NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT if ( len ( s ) == 0 ) : NEW_LINE INDENT v = s [ ] NEW_LINE s . pop ( 0 ) NEW_LINE for i in range ( len ( v ) - 1 , j ) : NEW_LINE INDENT print ( v [ i ] , v [ j ] , end = \" ▁ \" ) NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 1 ) NEW_LINE root . left = newNode ( 2 ) NEW_LINE root . right = newNode ( 3 ) NEW_LINE print ( \" Specific ▁ Level ▁ Order ▁ traversal ▁ of ▁ \" , end = \" ▁ \" ) NEW_LINE common = newNode ( root ) NEW_LINE DEDENT"],"references":["class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def specific_level_order_traversal ( root ) : NEW_LINE INDENT q = [ ] NEW_LINE s = [ ] NEW_LINE q . append ( root ) NEW_LINE sz = 0 NEW_LINE while ( len ( q ) > 0 ) : NEW_LINE INDENT v = [ ] NEW_LINE sz = len ( q ) NEW_LINE i = 0 NEW_LINE while ( i < sz ) : NEW_LINE INDENT temp = q [ 0 ] NEW_LINE q . pop ( 0 ) NEW_LINE v . append ( temp . data ) NEW_LINE if ( temp . left != None ) : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE DEDENT if ( temp . right != None ) : NEW_LINE INDENT q . append ( temp . right ) NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT s . append ( v ) NEW_LINE DEDENT while ( len ( s ) > 0 ) : NEW_LINE INDENT v = s [ - 1 ] NEW_LINE s . pop ( ) NEW_LINE i = 0 NEW_LINE j = len ( v ) - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT print ( v [ i ] , \" ▁ \" , v [ j ] , end = \" ▁ \" ) NEW_LINE j = j - 1 NEW_LINE i = i + 1 NEW_LINE DEDENT DEDENT print ( root . data ) NEW_LINE DEDENT root = Node ( 1 ) NEW_LINE root . left = Node ( 2 ) NEW_LINE root . right = Node ( 3 ) NEW_LINE print ( \" Specific ▁ Level ▁ Order ▁ traversal ▁ of ▁ binary ▁ tree ▁ is \" ) NEW_LINE specific_level_order_traversal ( root ) NEW_LINE"],"bleu":0.5971775291150371,"rouge_l":0.7152231604342582}
{"id":848,"predictions":["def sum ( h ) : NEW_LINE INDENT return pow ( 2 , h - 1 ) NEW_LINE DEDENT L = 3 NEW_LINE print ( sum ( L ) ) NEW_LINE"],"references":["def summ ( h ) : NEW_LINE INDENT return pow ( 2 , h - 1 ) NEW_LINE DEDENT L = 3 NEW_LINE print ( summ ( L ) ) NEW_LINE"],"bleu":0.8570980059247856,"rouge_l":0.9354838709677419}
{"id":849,"predictions":["def countDivisors ( N , a , b ) : NEW_LINE INDENT count1 = N \/\/ a ; NEW_LINE count2 = N \/\/ b ; NEW_LINE count3 = ( N \/\/ ( a * b ) ) ; NEW_LINE return count1 + count2 - count3 ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 1000 ; a = 3 ; b = 4 ; NEW_LINE print ( countDivisors ( N , a , b ) ) ; NEW_LINE DEDENT"],"references":["def countDivisors ( N , a , b ) : NEW_LINE INDENT count1 = N \/\/ a NEW_LINE count2 = N \/\/ b NEW_LINE count3 = ( N \/\/ ( a * b ) ) NEW_LINE return count1 + count2 - count3 NEW_LINE DEDENT N = 1000 NEW_LINE a = 3 NEW_LINE b = 4 NEW_LINE print ( countDivisors ( N , a , b ) ) NEW_LINE"],"bleu":0.596964703608328,"rouge_l":0.8661790017211703}
{"id":850,"predictions":["def number_Black ( n ) : NEW_LINE INDENT return ( n * n * n + 5 * n + 6 ) \/\/ 6 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 2 NEW_LINE print ( number_659 ( n ) ) NEW_LINE n = 8 NEW_LINE print ( number_659 ( n ) ) NEW_LINE n = 25 NEW_LINE print ( number_blank ( n ) ) NEW_LINE DEDENT"],"references":["def number_cake ( n ) : NEW_LINE INDENT return ( n * n * n + 5 * n + 6 ) \/\/ 6 NEW_LINE DEDENT n = 2 NEW_LINE print ( number_cake ( n ) ) NEW_LINE n = 8 NEW_LINE print ( number_cake ( n ) ) NEW_LINE n = 25 NEW_LINE print ( number_cake ( n ) ) NEW_LINE"],"bleu":0.6676672413804453,"rouge_l":0.8562439496611809}
{"id":851,"predictions":["MAX = 100000000 NEW_LINE prime = [ True for i in range ( MAX + 1 ) ] NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE for p in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if ( p * p > MAX ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( 2 * p , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def find_Prime ( sum ) : NEW_LINE INDENT i = sum \/\/ 2 NEW_LINE while ( i > 1 ) : NEW_LINE INDENT if ( prime [ i ] and prime [ sum - i ] ) : NEW_LINE INDENT print ( i , ( sum - i ) ) NEW_LINE return NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT Sieve ( ) NEW_LINE Sum = 100 NEW_LINE find_Prime ( Sum ) NEW_LINE DEDENT"],"references":["from math import sqrt NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT MAX = 1000001 NEW_LINE prime = [ True for i in range ( MAX + 1 ) ] NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( sqrt ( MAX ) ) + 1 , 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT return prime NEW_LINE DEDENT def find_Prime ( sum ) : NEW_LINE INDENT prime = SieveOfEratosthenes ( ) NEW_LINE i = int ( sum \/ 2 ) NEW_LINE while ( i > 1 ) : NEW_LINE INDENT if ( prime [ i ] and prime [ sum - i ] ) : NEW_LINE INDENT print ( i , ( sum - i ) ) NEW_LINE return NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT print ( \" Cannot ▁ be ▁ represented ▁ as ▁ sum \" , \" of ▁ two ▁ primes \" ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT sum = 1002 NEW_LINE find_Prime ( sum ) NEW_LINE DEDENT"],"bleu":0.6498738235483545,"rouge_l":0.7498612102466492}
{"id":852,"predictions":["def generateNumbers ( factor , n , k ) : NEW_LINE INDENT next = [ 0 ] * k NEW_LINE output = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT to += [ 0 ] NEW_LINE for j in range ( k ) : NEW_LINE INDENT if ( next [ j ] < next [ toIncrement ] ) : NEW_LINE INDENT toIncrement = j NEW_LINE DEDENT DEDENT if ( output != next [ toIncrement ] ) : NEW_LINE INDENT output = next [ toIncrement ] NEW_LINE print ( next [ toIncrement ] , end = \" ▁ \" ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT factor = [ 3 , 5 , 7 ] NEW_LINE n = 10 NEW_LINE k = len ( factor ) NEW_LINE generateNumbers ( factor , n , k ) NEW_LINE DEDENT"],"references":["def generateNumbers ( factor , n , k ) : NEW_LINE INDENT next = [ 0 ] * k ; NEW_LINE output = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT toincrement = 0 ; NEW_LINE for j in range ( k ) : NEW_LINE INDENT if ( next [ j ] < next [ toincrement ] ) : NEW_LINE INDENT toincrement = j ; NEW_LINE DEDENT DEDENT if ( output != next [ toincrement ] ) : NEW_LINE INDENT output = next [ toincrement ] ; NEW_LINE print ( next [ toincrement ] , end = \" ▁ \" ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT next [ toincrement ] += factor [ toincrement ] ; NEW_LINE DEDENT DEDENT factor = [ 3 , 5 , 7 ] ; NEW_LINE n = 10 ; NEW_LINE k = len ( factor ) ; NEW_LINE generateNumbers ( factor , n , k ) ; NEW_LINE"],"bleu":0.6067055820794457,"rouge_l":0.7975485188968335}
{"id":853,"predictions":["from queue import Queue NEW_LINE def lengthOfSmallestSubsequence ( K , v ) : NEW_LINE INDENT pq = Queue ( ) NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT pq . append ( v [ i ] ) NEW_LINE DEDENT sum = 0 NEW_LINE count = 0 NEW_LINE while ( len ( pq ) > 0 and sum < K ) : NEW_LINE INDENT sum += pq [ - 1 ] NEW_LINE pq . pop ( ) NEW_LINE count += 1 NEW_LINE DEDENT if ( sum < K ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT v = [ 2 , 3 , 1 , 5 , 6 , 3 , 7 , 9 , 14 , 10 , 2 , 5 ] NEW_LINE K = 35 NEW_LINE print ( lengthOfSmallestSubsequence ( K , v ) ) NEW_LINE DEDENT"],"references":["def lengthOfSmallestSubsequence ( K , v ) : NEW_LINE INDENT pq = [ ] NEW_LINE for i in v : NEW_LINE INDENT pq . append ( i ) NEW_LINE DEDENT pq . sort ( ) NEW_LINE sum = 0 NEW_LINE count = 0 NEW_LINE while ( len ( pq ) > 0 and sum < K ) : NEW_LINE INDENT sum += pq [ - 1 ] NEW_LINE del pq [ - 1 ] NEW_LINE count += 1 NEW_LINE DEDENT if ( sum < K ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return count NEW_LINE DEDENT v = [ 2 , 3 , 1 , 5 , 6 , 3 , 7 , 9 , 14 , 10 , 2 , 5 ] NEW_LINE K = 35 NEW_LINE print ( lengthOfSmallestSubsequence ( K , v ) ) NEW_LINE"],"bleu":0.7258940945538667,"rouge_l":0.8522552255225523}
{"id":854,"predictions":["def search ( arr , n , x ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( arr [ i ] == x ) : NEW_LINE INDENT return i NEW_LINE DEDENT i = i + abs ( arr [ i ] - x ) NEW_LINE DEDENT print ( \" number ▁ is ▁ not ▁ present ! \" ) NEW_LINE return - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 8 , 7 , 6 , 7 , 6 , 5 , 4 , 3 , 2 , 3 , 4 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE x = 3 NEW_LINE print ( \" Equence ▁ % d ▁ at ▁ index ▁ % d \" % ( x , x ) ) NEW_LINE DEDENT"],"references":["def search ( arr , n , x ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( arr [ i ] == x ) : NEW_LINE INDENT return i NEW_LINE DEDENT i = i + abs ( arr [ i ] - x ) NEW_LINE DEDENT print ( \" number ▁ is ▁ not ▁ present ! \" ) NEW_LINE return - 1 NEW_LINE DEDENT arr = [ 8 , 7 , 6 , 7 , 6 , 5 , 4 , 3 , 2 , 3 , 4 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE x = 3 NEW_LINE print ( \" Element \" , x , \" ▁ is ▁ present ▁ at ▁ index ▁ \" , search ( arr , n , 3 ) ) NEW_LINE"],"bleu":0.8078773722395023,"rouge_l":0.8783346355620048}
{"id":855,"predictions":["def CheckArray ( arr , n ) : NEW_LINE INDENT prod = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT prod *= arr [ i ] NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == prod \/\/ arr [ i ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 12 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE if ( CheckArray ( arr , n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"references":["def CheckArray ( arr , n ) : NEW_LINE INDENT prod = 1 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT prod *= arr [ i ] NEW_LINE DEDENT for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( arr [ i ] == prod \/ arr [ i ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 12 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE if ( CheckArray ( arr , n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.9325509976493305,"rouge_l":0.9762263713324828}
{"id":856,"predictions":["def minRemove ( arr , n ) : NEW_LINE INDENT LIS = [ 0 for i in range ( n ) ] NEW_LINE Len = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) : NEW_LINE INDENT LIS [ i ] = max ( LIS [ i ] , LIS [ j ] + 1 ) NEW_LINE DEDENT DEDENT Len = max ( Len , LIS [ i ] ) NEW_LINE DEDENT return n - Len NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 6 , 5 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minRemove ( arr , n ) ) NEW_LINE DEDENT"],"references":["def minRemove ( arr , n ) : NEW_LINE INDENT LIS = [ 0 for i in range ( n ) ] NEW_LINE len = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT LIS [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) : NEW_LINE INDENT LIS [ i ] = max ( LIS [ i ] , LIS [ j ] + 1 ) NEW_LINE DEDENT DEDENT len = max ( len , LIS [ i ] ) NEW_LINE DEDENT return ( n - len ) NEW_LINE DEDENT arr = [ 1 , 2 , 6 , 5 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minRemove ( arr , n ) ) NEW_LINE"],"bleu":0.8088979721642602,"rouge_l":0.8627675840978595}
{"id":857,"predictions":["import sys NEW_LINE def chr ( s , i ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( s [ i ] == '1' ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 NEW_LINE DEDENT DEDENT def countMinimalReplacements ( s , i , prev , dp , n ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ prev ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ prev ] NEW_LINE DEDENT val = sVal ( s , i ) NEW_LINE ans = sys . maxsize NEW_LINE if ( val == prev ) : NEW_LINE INDENT val = 0 NEW_LINE for cur in range ( 2 ) : NEW_LINE INDENT if ( cur == prev ) : NEW_LINE INDENT continue NEW_LINE DEDENT val = 1 + countMinimalReplacements ( s , i + 1 , cur , dp , n ) NEW_LINE ans = min ( ans , val ) NEW_LINE DEDENT DEDENT dp [ i ] [ val ] = ans NEW_LINE return ans NEW_LINE DEDENT s = \"201220220211\" NEW_LINE n = len ( s ) NEW_LINE dp = [ [ - 1 for i in range ( 3 ) ] for i in range ( n ) ] NEW_LINE print ( countMinimalReplacements ( s , 1 , val , dp , n ) ) NEW_LINE"],"references":["import sys NEW_LINE def charVal ( s , i ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( s [ i ] == '1' ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 NEW_LINE DEDENT DEDENT def countMinimalReplacements ( s , i , prev , dp , n ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ prev ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ prev ] NEW_LINE DEDENT val = charVal ( s , i ) NEW_LINE ans = sys . maxsize NEW_LINE if ( val == prev ) : NEW_LINE INDENT val = 0 NEW_LINE for cur in range ( 3 ) : NEW_LINE INDENT if ( cur == prev ) : NEW_LINE INDENT continue NEW_LINE DEDENT val = 1 + countMinimalReplacements ( s , i + 1 , cur , dp , n ) NEW_LINE ans = min ( ans , val ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT ans = countMinimalReplacements ( s , i + 1 , val , dp , n ) NEW_LINE DEDENT dp [ i ] [ val ] = ans NEW_LINE return dp [ i ] [ val ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \"201220211\" NEW_LINE n = len ( s ) NEW_LINE dp = [ [ - 1 for i in range ( 3 ) ] for i in range ( n ) ] NEW_LINE val = charVal ( s , 0 ) NEW_LINE print ( countMinimalReplacements ( s , 1 , val , dp , n ) ) NEW_LINE DEDENT"],"bleu":0.7691344794243721,"rouge_l":0.8760206149748104}
{"id":858,"predictions":["def dispPercentant ( S , M ) : NEW_LINE INDENTount = M - S NEW_LINE dep %= M NEW_LINE return round ( dis % M ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT M = 120 NEW_LINE S = 100 NEW_LINE print ( % ( % % 100 ) , 2 ) NEW_LINE print ( \" % \" ) NEW_LINE DEDENT"],"references":["def discountPercentage ( S , M ) : NEW_LINE INDENT discount = M - S NEW_LINE disPercent = ( discount \/ M ) * 100 NEW_LINE return disPercent NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT M = 120 NEW_LINE S = 100 NEW_LINE print ( discountPercentage ( S , M ) , \" % \" ) NEW_LINE M = 1000 NEW_LINE S = 500 NEW_LINE print ( discountPercentage ( S , M ) , \" % \" ) NEW_LINE DEDENT"],"bleu":0.47135069195869284,"rouge_l":0.6732066217044758}
{"id":859,"predictions":["import math NEW_LINE def sumOfSeries ( n ) : NEW_LINE INDENT return 0.6 181 * ( pow ( 10 , n ) - 0.55 * n ) NEW_LINE DEDENT n = 2 NEW_LINE print ( sumOfSeries ( n ) ) NEW_LINE"],"references":["def sumOfSeries ( n ) : NEW_LINE INDENT return ( int ) ( 0.6172 * ( pow ( 10 , n ) - 1 ) - 0.55 * n ) NEW_LINE DEDENT n = 2 NEW_LINE print ( sumOfSeries ( n ) ) NEW_LINE"],"bleu":0.7725189817251988,"rouge_l":0.8417018014564969}
{"id":860,"predictions":["def Move ( a , x , b ) : NEW_LINE INDENT if ( ( ( b - a ) % x == 0 ) or ( ( b - a - 1 ) % x == 0 and a + 1 != b ) and b >= a ) and b >= a : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a , x , b = 3 , 2 , 7 NEW_LINE if Move ( a , x , b ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def Move ( a , x , b ) : NEW_LINE INDENT if ( ( ( ( b - a ) % x == 0 ) or ( ( b - a - 1 ) % x == 0 ) and a + 1 != b ) and b >= a ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 3 NEW_LINE x = 2 NEW_LINE b = 7 NEW_LINE if ( Move ( a , x , b ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.852383601114768,"rouge_l":0.9186991869918701}
{"id":861,"predictions":["def No_of_Pairs ( N ) : NEW_LINE INDENT i = 1 NEW_LINE while ( ( ( i * i * i ) + ( 2 * i * i ) ) + i <= N ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT return ( i - 1 ) NEW_LINE DEDENT def print_pairs ( pairs ) : NEW_LINE INDENT for i in range ( 1 , pairs + 1 ) : NEW_LINE INDENT mul = i * ( i + 1 ) NEW_LINE print ( \" Pair ▁ no . ▁ \" , i , \" - - > ▁ ( \" , mul * ( i + 1 ) , \" , \" , \" , mul * ( i + 1 ) + \" ) \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 NEW_LINE product_pairs ( N ) NEW_LINE print ( \" No . ▁ of ▁ pairs ▁ = \" , pairs ) NEW_LINE print_pairs ( pairs ) NEW_LINE DEDENT"],"references":["def No_Of_Pairs ( N ) : NEW_LINE INDENT i = 1 ; NEW_LINE while ( ( i * i * i ) + ( 2 * i * i ) + i <= N ) : NEW_LINE INDENT i += 1 ; NEW_LINE DEDENT return ( i - 1 ) ; NEW_LINE DEDENT def print_pairs ( pairs ) : NEW_LINE INDENT i = 1 ; NEW_LINE mul = 0 ; NEW_LINE for i in range ( 1 , pairs + 1 ) : NEW_LINE INDENT mul = i * ( i + 1 ) ; NEW_LINE print ( \" Pair ▁ no . \" , i , \" ▁ - - > ▁ ( \" , ( mul * i ) , \" , ▁ \" , mul * ( i + 1 ) , \" ) \" ) ; NEW_LINE DEDENT DEDENT N = 500 ; NEW_LINE i = 1 ; NEW_LINE pairs = No_Of_Pairs ( N ) ; NEW_LINE print ( \" No . ▁ of ▁ pairs ▁ = ▁ \" , pairs ) ; NEW_LINE print_pairs ( pairs ) ; NEW_LINE"],"bleu":0.6613841496902786,"rouge_l":0.8309427153811457}
{"id":862,"predictions":["def power ( x , a ) : NEW_LINE INDENT res = 1 NEW_LINE while ( a > 0 ) : NEW_LINE INDENT if ( a & 1 ) : NEW_LINE INDENT res = res * x NEW_LINE DEDENT x = x * x NEW_LINE a >>= 1 NEW_LINE DEDENT return res NEW_LINE DEDENT def breakInteger ( N ) : NEW_LINE INDENT if ( N == 2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( N == 3 ) : NEW_LINE INDENT maxProduct = power ( 3 , N \/\/ 3 ) NEW_LINE if ( N % 3 == 0 ) : NEW_LINE INDENT maxProduct = power ( 3 , N \/ 3 ) NEW_LINE DEDENT elif ( N % 3 == 1 ) : NEW_LINE INDENT maxProduct = 2 * 2 * power ( 3 , ( N \/ 3 ) - 1 ) NEW_LINE DEDENT elif ( 2 ) : NEW_LINE INDENT maxProduct = 2 * power ( 3 , N \/\/ 3 ) NEW_LINE DEDENT return maxProduct NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT maxProduct = breakInteger ( 10 ) NEW_LINE print ( maxProduct ) NEW_LINE DEDENT"],"references":["def power ( x , a ) : NEW_LINE INDENT res = 1 ; NEW_LINE while ( a ) : NEW_LINE INDENT if ( a & 1 ) : NEW_LINE INDENT res = res * x ; NEW_LINE DEDENT x = x * x ; NEW_LINE a >>= 1 ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT def breakInteger ( N ) : NEW_LINE INDENT if ( N == 2 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT if ( N == 3 ) : NEW_LINE INDENT return 2 ; NEW_LINE DEDENT maxProduct = 0 ; NEW_LINE if ( N % 3 == 0 ) : NEW_LINE INDENT maxProduct = power ( 3 , int ( N \/ 3 ) ) ; NEW_LINE return maxProduct ; NEW_LINE DEDENT elif ( N % 3 == 1 ) : NEW_LINE INDENT maxProduct = 2 * 2 * power ( 3 , int ( N \/ 3 ) - 1 ) ; NEW_LINE return maxProduct ; NEW_LINE DEDENT elif ( N % 3 == 2 ) : NEW_LINE INDENT maxProduct = 2 * power ( 3 , int ( N \/ 3 ) ) ; NEW_LINE return maxProduct ; NEW_LINE DEDENT DEDENT maxProduct = breakInteger ( 10 ) ; NEW_LINE print ( maxProduct ) ; NEW_LINE"],"bleu":0.6734395216064964,"rouge_l":0.8354848866498739}
{"id":863,"predictions":["def printTrib ( n ) : NEW_LINE INDENT dp = [ 0 ] * n ; NEW_LINE dp [ 0 ] = dp [ 1 ] = 0 ; NEW_LINE dp [ 2 ] = 1 ; NEW_LINE for i in range ( 3 , n ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + dp [ i - 3 ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( dp [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT n = 16 ; NEW_LINE printTrib ( n ) ; NEW_LINE"],"references":["def printTrib ( n ) : NEW_LINE INDENT dp = [ 0 ] * n NEW_LINE dp [ 0 ] = dp [ 1 ] = 0 ; NEW_LINE dp [ 2 ] = 1 ; NEW_LINE for i in range ( 3 , n ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + dp [ i - 3 ] ; NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( dp [ i ] , \" ▁ \" , end = \" \" ) NEW_LINE DEDENT DEDENT n = 10 NEW_LINE printTrib ( n ) NEW_LINE"],"bleu":0.8544993235168103,"rouge_l":0.9381966981797659}
{"id":864,"predictions":["def findCount ( d ) : NEW_LINE INDENT return 9 * ( pow ( 10 , d - 1 ) - pow ( 9 , d - 1 ) ) ; NEW_LINE DEDENT d = 1 ; NEW_LINE print ( findCount ( d ) ) ; NEW_LINE d = 2 ; NEW_LINE print ( findCount ( d ) ) ; NEW_LINE"],"references":["import math NEW_LINE def findCount ( d ) : NEW_LINE INDENT return 9 * ( ( int ) ( math . pow ( 10 , d - 1 ) ) - ( int ) ( math . pow ( 9 , d - 1 ) ) ) ; NEW_LINE DEDENT d = 1 NEW_LINE print ( findCount ( d ) ) NEW_LINE d = 2 NEW_LINE print ( findCount ( d ) ) NEW_LINE d = 4 NEW_LINE print ( findCount ( d ) ) NEW_LINE"],"bleu":0.5140346609981358,"rouge_l":0.7524345379787925}
{"id":865,"predictions":["def Float ( n ) : NEW_LINE INDENT return ( ( n - 32.0 ) * 5.0 \/ 9.0 ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 40 ; NEW_LINE print ( Float ( n ) ) ; NEW_LINE DEDENT"],"references":["def Conversion ( n ) : NEW_LINE INDENT return ( n - 32.0 ) * 5.0 \/ 9.0 NEW_LINE DEDENT n = 40 NEW_LINE x = Conversion ( n ) NEW_LINE print ( x ) NEW_LINE"],"bleu":0.38988999818957765,"rouge_l":0.6643329443796189}
{"id":866,"predictions":["def isPalin ( str1 ) : NEW_LINE INDENT l = len ( str1 ) \/\/ 2 NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( str1 [ i ] != str1 [ len ( str1 ) - i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def palindromicPath ( str1 , a , i , j , m , n ) : NEW_LINE INDENT if ( j < m - 1 or i < n - 1 ) : NEW_LINE INDENT if ( i < n - 1 ) : NEW_LINE INDENT if ( i < n - 1 ) : NEW_LINE INDENT palindromicPath ( str1 + a [ i ] [ j ] , a , i + 1 , j , m , n ) NEW_LINE DEDENT if ( j < m - 1 ) : NEW_LINE INDENT palindromicPath ( str1 + a [ i ] [ j ] , a , i , j + 1 , m , n ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT str1 = str1 + a [ n - 1 ] [ m - 1 ] NEW_LINE if ( isPalin ( str1 , arr , 0 , m - 1 ) ) : NEW_LINE INDENT print ( \" \" . join ( str1 ) ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ ' a ' , ' a ' , ' a ' , ' b ' , ' a ' , ' b ' , ' , ' b ' , ' a ' , ' b ' , ' a ' , ' b ' , ' a ' ] NEW_LINE string = \" \" NEW_LINE palindromicPath ( str1 , arr , 0 , 4 , 3 ) NEW_LINE DEDENT"],"references":["def isPalin ( str ) : NEW_LINE INDENT l = len ( str ) \/\/ 2 NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( str [ i ] != str [ len ( str ) - i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def palindromicPath ( str , a , i , j , m , n ) : NEW_LINE INDENT if ( j < m - 1 or i < n - 1 ) : NEW_LINE INDENT if ( i < n - 1 ) : NEW_LINE INDENT palindromicPath ( str + a [ i ] [ j ] , a , i + 1 , j , m , n ) NEW_LINE DEDENT if ( j < m - 1 ) : NEW_LINE INDENT palindromicPath ( str + a [ i ] [ j ] , a , i , j + 1 , m , n ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT str = str + a [ n - 1 ] [ m - 1 ] NEW_LINE if isPalin ( str ) : NEW_LINE INDENT print ( str ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ [ ' a ' , ' a ' , ' a ' , ' b ' ] , [ ' b ' , ' a ' , ' a ' , ' a ' ] , [ ' a ' , ' b ' , ' b ' , ' a ' ] ] NEW_LINE str = \" \" NEW_LINE palindromicPath ( str , arr , 0 , 0 , 4 , 3 ) NEW_LINE DEDENT"],"bleu":0.7608118512987253,"rouge_l":0.8765405521769549}
{"id":867,"predictions":["def checkDivisors ( a , n ) : NEW_LINE INDENT X = max ( a ) NEW_LINE b = [ ] NEW_LINE i = 1 NEW_LINE while i * i <= X : NEW_LINE INDENT if ( X % i == 0 ) : NEW_LINE INDENT b . append ( i ) NEW_LINE if ( X \/\/ i != i ) : NEW_LINE INDENT b . append ( i ) NEW_LINE if ( X \/\/ i != i ) : NEW_LINE INDENT b . append ( X \/\/ i ) NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT if ( len ( b ) != n ) : NEW_LINE INDENT return false NEW_LINE DEDENT a . sort ( ) NEW_LINE sort . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( b [ i ] != a [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 8 , 1 , 2 , 12 , 6 , 4 , 24 , 16 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE if ( checkDivisors ( arr , N ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["from math import sqrt NEW_LINE def checkDivisors ( a , n ) : NEW_LINE INDENT X = max ( a ) NEW_LINE b = [ ] NEW_LINE for i in range ( 1 , int ( sqrt ( X ) ) + 1 ) : NEW_LINE INDENT if ( X % i == 0 ) : NEW_LINE INDENT b . append ( i ) NEW_LINE if ( X \/\/ i != i ) : NEW_LINE INDENT b . append ( X \/\/ i ) NEW_LINE DEDENT DEDENT DEDENT if ( len ( b ) != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT a . sort ( reverse = False ) NEW_LINE b . sort ( reverse = False ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( b [ i ] != a [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 8 , 1 , 2 , 12 , 48 , 6 , 4 , 24 , 16 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE if ( checkDivisors ( arr , N ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.8300082201890071,"rouge_l":0.8724672228843862}
{"id":868,"predictions":["def printAllAPTriplets ( arr , n ) : NEW_LINE INDENT s = [ ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT diff = arr [ j ] - arr [ i ] NEW_LINE exists = s . index ( arr [ i ] - diff ) NEW_LINE if ( exists : NEW_LINE INDENT print ( arr [ i ] - diff , arr [ i ] , arr [ j ] ) NEW_LINE DEDENT DEDENT s . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT arr = [ 2 , 6 , 9 , 12 , 12 , 31 , 30 , 40 ] NEW_LINE n = len ( arr ) NEW_LINE printAllAPAPTriplets ( arr , n ) NEW_LINE"],"references":["def printAllAPTriplets ( arr , n ) : NEW_LINE INDENT s = [ ] ; NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT diff = arr [ j ] - arr [ i ] ; NEW_LINE if ( ( arr [ i ] - diff ) in arr ) : NEW_LINE INDENT print ( \" { } ▁ { } ▁ { } \" . format ( ( arr [ i ] - diff ) , arr [ i ] , arr [ j ] ) , end = \" \\n \" ) ; NEW_LINE DEDENT DEDENT DEDENT s . append ( arr [ i ] ) ; NEW_LINE DEDENT arr = [ 2 , 6 , 9 , 12 , 17 , 22 , 31 , 32 , 35 , 42 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE printAllAPTriplets ( arr , n ) ; NEW_LINE"],"bleu":0.611809513572386,"rouge_l":0.7972625295873212}
{"id":869,"predictions":["def isPowerOfTwo ( x ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT return false NEW_LINE DEDENT if ( ( x & ( x - 1 ) ) == 0 ) : NEW_LINE INDENT return true NEW_LINE DEDENT else : NEW_LINE INDENT return false NEW_LINE DEDENT DEDENT def countNum ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( isPowerOfTwo ( a [ i ] ) or isPowerOfTwo ( a [ i ] + 1 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 6 , 9 , 3 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countNum ( arr , n ) ) NEW_LINE DEDENT"],"references":["def isPowerOfTwo ( x ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( ( x & ( x - 1 ) ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def countNum ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( isPowerOfTwo ( a [ i ] ) or isPowerOfTwo ( a [ i ] + 1 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 6 , 9 , 3 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countNum ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.911149020427163,"rouge_l":0.9654954099398544}
{"id":870,"predictions":["import math NEW_LINE pi = math . pi NEW_LINE def volume ( r ) : NEW_LINE INDENT vol = ( 4 \/ 3 ) * ( pi * r * r * r ) NEW_LINE return vol NEW_LINE DEDENT def surface_area ( r ) : NEW_LINE INDENT sur_ra = 4 NEW_LINE v_area = round ( radius , 3 ) NEW_LINE return sur_area NEW_LINE DEDENT radius = 12 NEW_LINE vol = volume ( radius ) NEW_LINE sur_area = surface_area ( radius ) NEW_LINE print ( \" Volume ▁ Of ▁ Cube ▁ : \" , vol ) NEW_LINE print ( \" Volume ▁ Area ▁ : \" , vol_area ) NEW_LINE"],"references":["import math NEW_LINE pi = math . pi NEW_LINE def volume ( r ) : NEW_LINE INDENT vol = ( 4 \/ 3 ) * pi * r * r * r NEW_LINE return vol NEW_LINE DEDENT def surfacearea ( r ) : NEW_LINE INDENT sur_ar = 4 * pi * r * r NEW_LINE return sur_ar NEW_LINE DEDENT radius = float ( 12 ) NEW_LINE print ( \" Volume ▁ Of ▁ Sphere ▁ : ▁ \" , volume ( radius ) ) NEW_LINE print ( \" Surface ▁ Area ▁ Of ▁ Sphere ▁ : ▁ \" , surfacearea ( radius ) ) NEW_LINE"],"bleu":0.5590360053186101,"rouge_l":0.7339323789217178}
{"id":871,"predictions":["def isPower ( 10 , 1 ) : NEW_LINE INDENT if ( isPower ( 10 , 1 ) ) : NEW_LINE INDENT return \" Yes \" NEW_LINE DEDENT DEDENT if ( isPower ( 2 , 20 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT if ( isPower ( 2 , 128 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def isPower ( x , y ) : NEW_LINE INDENT if ( x == 1 ) : NEW_LINE INDENT return ( y == 1 ) NEW_LINE DEDENT pow = 1 NEW_LINE while ( pow < y ) : NEW_LINE INDENT pow = pow * x NEW_LINE DEDENT return ( pow == y ) NEW_LINE DEDENT if ( isPower ( 10 , 1 ) ) : print ( \" True \" ) NEW_LINE else : print ( \" False \" ) NEW_LINE if ( isPower ( 1 , 20 ) ) : print ( \" True \" ) NEW_LINE else : print ( \" False \" ) NEW_LINE if ( isPower ( 2 , 128 ) ) : print ( \" True \" ) NEW_LINE else : print ( \" False \" ) NEW_LINE if ( isPower ( 2 , 30 ) ) : print ( \" True \" ) NEW_LINE else : print ( \" False \" ) NEW_LINE"],"bleu":0.23089758075634903,"rouge_l":0.5038069428313331}
{"id":872,"predictions":["def getSum ( BITree , index ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( index > 0 ) : NEW_LINE INDENT sum += BITree [ index ] NEW_LINE index -= index & ( - index ) NEW_LINE DEDENT return sum NEW_LINE DEDENT def updateBit ( arr , n , index , val ) : NEW_LINE INDENT while ( index <= n ) : NEW_LINE INDENT if ( maxElement < arr [ index ] ) : NEW_LINE INDENT maxElement = arr [ i ] NEW_LINE index += index & ( - index ) NEW_LINE DEDENT DEDENT BIT = [ 0 ] * ( maxElement + 1 ) NEW_LINE for i in range ( 1 , maxElement + 1 ) ) : NEW_LINE INDENT BIT [ i ] = 0 NEW_LINE DEDENT BIT = [ 0 ] * ( maxElement + 1 ) NEW_LINE for i in range ( 1 , maxElement + 1 ) : NEW_LINE INDENT BITcount += getSum ( BIT , arr [ i ] - 1 ) NEW_LINE updateBit ( BIT , maxElement , arr [ i ] , 1 ) NEW_LINE DEDENT return invcount NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 8 , 4 , 2 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Number ▁ of ▁ inversions ▁ are ▁ : \" , getInvCount ( arr , n ) ) NEW_LINE DEDENT"],"references":["def getSum ( BITree , index ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( index > 0 ) : NEW_LINE INDENT sum += BITree [ index ] NEW_LINE index -= index & ( - index ) NEW_LINE DEDENT return sum NEW_LINE DEDENT def updateBIT ( BITree , n , index , val ) : NEW_LINE INDENT while ( index <= n ) : NEW_LINE INDENT BITree [ index ] += val NEW_LINE index += index & ( - index ) NEW_LINE DEDENT DEDENT def getInvCount ( arr , n ) : NEW_LINE INDENT invcount = 0 NEW_LINE maxElement = max ( arr ) NEW_LINE BIT = [ 0 ] * ( maxElement + 1 ) NEW_LINE for i in range ( 1 , maxElement + 1 ) : NEW_LINE INDENT BIT [ i ] = 0 NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT invcount += getSum ( BIT , arr [ i ] - 1 ) NEW_LINE updateBIT ( BIT , maxElement , arr [ i ] , 1 ) NEW_LINE DEDENT return invcount NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 8 , 4 , 2 , 1 ] NEW_LINE n = 4 NEW_LINE print ( \" Inversion ▁ Count ▁ : ▁ \" , getInvCount ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.7503413006518147,"rouge_l":0.8248816768086545}
{"id":873,"predictions":["def calSum ( n ) : NEW_LINE INDENT a = 3 NEW_LINE b = 0 NEW_LINE c = 2 NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return 3 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 5 NEW_LINE DEDENT sum = 5 NEW_LINE while ( n > 2 ) : NEW_LINE INDENT d = a + b NEW_LINE sum += d NEW_LINE a = b NEW_LINE b = c NEW_LINE c = d NEW_LINE n -= 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 9 NEW_LINE print ( calSum ( n ) ) NEW_LINE"],"references":["def calSum ( n ) : NEW_LINE INDENT a = 3 NEW_LINE b = 0 NEW_LINE c = 2 NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return 3 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 3 NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return 5 NEW_LINE DEDENT sum = 5 NEW_LINE while ( n > 2 ) : NEW_LINE INDENT d = a + b NEW_LINE sum = sum + d NEW_LINE a = b NEW_LINE b = c NEW_LINE c = d NEW_LINE n = n - 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 9 NEW_LINE print ( calSum ( n ) ) NEW_LINE"],"bleu":0.8043454590015585,"rouge_l":0.8925958443078725}
{"id":874,"predictions":["import sys ; NEW_LINE def steps ( curr , x , n ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT return sys . maxsize ; NEW_LINE DEDENT if ( x > 0 ) : NEW_LINE INDENT return abs ( ( n - curr ) \/ x ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return abs ( ( curr - 1 ) \/ x ) ; NEW_LINE DEDENT DEDENT def countSteps ( curr , curr , n , m , moves ) : NEW_LINE INDENT count = 0 ; NEW_LINE k = len ( moves ) ; NEW_LINE for i in range ( k ) : NEW_LINE INDENT x = moves [ i ] [ 0 ] ; NEW_LINE y = moves [ i ] [ 1 ] ; NEW_LINE stepct = min ( steps ( curr , x , n ) , steps ( curr , y , m ) ) ; NEW_LINE count += steplen * x ; NEW_LINE cury += steplen * y ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT n = 4 ; NEW_LINE m = 5 ; NEW_LINE x = 1 ; NEW_LINE y = 1 ; NEW_LINE moves = [ 1 , 1 ] , [ 1 , - 2 ] , [ 0 , - 2 ] ; NEW_LINE print ( countSteps ( x , y , n , m , moves ) ) ; NEW_LINE"],"references":["def steps ( cur , x , n ) : NEW_LINE INDENT if x == 0 : NEW_LINE INDENT return float ( ' inf ' ) NEW_LINE DEDENT elif x > 0 : NEW_LINE INDENT return abs ( ( n - cur ) \/\/ x ) NEW_LINE DEDENT else : NEW_LINE INDENT return abs ( int ( ( cur - 1 ) \/ x ) ) NEW_LINE DEDENT DEDENT def countSteps ( curx , cury , n , m , moves ) : NEW_LINE INDENT count = 0 NEW_LINE k = len ( moves ) NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT x = moves [ i ] [ 0 ] NEW_LINE y = moves [ i ] [ 1 ] NEW_LINE stepct = min ( steps ( curx , x , n ) , steps ( cury , y , m ) ) NEW_LINE count += stepct NEW_LINE curx += stepct * x NEW_LINE cury += stepct * y NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n , m , x , y = 4 , 5 , 1 , 1 NEW_LINE moves = [ [ 1 , 1 ] , [ 1 , 1 ] , [ 0 , - 2 ] ] NEW_LINE print ( countSteps ( x , y , n , m , moves ) ) NEW_LINE DEDENT"],"bleu":0.581681154442705,"rouge_l":0.7869087434304826}
{"id":875,"predictions":["def SUM ( n , m ) : NEW_LINE INDENT if ( m == 1 ) : NEW_LINE INDENT return ( n * ( n + 1 ) \/\/ 2 ) NEW_LINE DEDENT sum = SUM ( n , m - 1 ) NEW_LINE return ( sum * ( sum + 1 ) \/\/ 2 ) NEW_LINE DEDENT n = 5 NEW_LINE m = 3 NEW_LINE print ( \" SUM ( \" , n , \" , \" , m , \" ) : \" , SUM ( n , m ) ) NEW_LINE"],"references":["def SUM ( n , m ) : NEW_LINE INDENT if ( m == 1 ) : NEW_LINE INDENT return ( n * ( n + 1 ) \/ 2 ) NEW_LINE DEDENT sum = SUM ( n , m - 1 ) NEW_LINE return int ( sum * ( sum + 1 ) \/ 2 ) NEW_LINE DEDENT n = 5 NEW_LINE m = 3 NEW_LINE print ( \" SUM ( \" , n , \" , ▁ \" , m , \" ) : \" , SUM ( n , m ) ) NEW_LINE"],"bleu":0.8933336888013379,"rouge_l":0.9665862900447814}
{"id":876,"predictions":["def printInitials ( str ) : NEW_LINE INDENT l = len ( str ) NEW_LINE str = str . strip ( ) NEW_LINE t = \" \" NEW_LINE for i in range ( l ) : NEW_LINE INDENT ch = str [ i ] NEW_LINE if ( ch != ' ▁ ' ) : NEW_LINE INDENT t = t + str [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT t = str [ : ] . upper ( ) NEW_LINE t = \" \" NEW_LINE DEDENT DEDENT temp = \" \" NEW_LINE for j in range ( 0 , len ( t ) ) : NEW_LINE INDENT if ( j == 0 ) : NEW_LINE INDENT temp += str [ j ] . upper ( ) NEW_LINE DEDENT else : NEW_LINE INDENT temp += str [ j ] NEW_LINE DEDENT DEDENT print ( temp ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" iita ▁ bhui \" NEW_LINE printInitials ( str ) NEW_LINE DEDENT"],"references":["def printInitials ( string : str ) : NEW_LINE INDENT length = len ( string ) NEW_LINE string . strip ( ) NEW_LINE t = \" \" NEW_LINE for i in range ( length ) : NEW_LINE INDENT ch = string [ i ] NEW_LINE if ch != ' ▁ ' : NEW_LINE INDENT t += ch NEW_LINE DEDENT else : NEW_LINE INDENT print ( t [ 0 ] . upper ( ) + \" . ▁ \" , end = \" \" ) NEW_LINE t = \" \" NEW_LINE DEDENT DEDENT temp = \" \" NEW_LINE for j in range ( len ( t ) ) : NEW_LINE INDENT if j == 0 : NEW_LINE INDENT temp += t [ 0 ] . upper ( ) NEW_LINE DEDENT else : NEW_LINE INDENT temp += t [ j ] . lower ( ) NEW_LINE DEDENT DEDENT print ( temp ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" ishita ▁ bhuiya \" NEW_LINE printInitials ( string ) NEW_LINE DEDENT"],"bleu":0.6326109261004237,"rouge_l":0.8175432110176541}
{"id":877,"predictions":["def check ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return ( ( st [ 0 ] ) - int ( st [ n - 1 ] ) % 8 == 0 ) NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return ( ( ( st [ n - 2 ] ) * 10 + ( int ( st [ n - 2 ] ) ) % 8 == 0 ) NEW_LINE DEDENT last = ( int ) ( st [ n - 2 ] ) NEW_LINE second_last = ( int ) ( st [ n - 2 ] ) NEW_LINE third_last = ( int ) ( st [ n - 3 ] ) NEW_LINE return ( ( third_last * 100 + second_last * 10 + last ) % 8 == 0 ) NEW_LINE DEDENT st = \"76952\" NEW_LINE if ( check ( st ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def check ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return ( ( int ) ( st [ 0 ] ) % 8 == 0 ) NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return ( ( int ) ( st [ n - 2 ] ) * 10 + ( ( int ) ( str [ n - 1 ] ) % 8 == 0 ) ) NEW_LINE DEDENT last = ( int ) ( st [ n - 1 ] ) NEW_LINE second_last = ( int ) ( st [ n - 2 ] ) NEW_LINE third_last = ( int ) ( st [ n - 3 ] ) NEW_LINE return ( ( third_last * 100 + second_last * 10 + last ) % 8 == 0 ) NEW_LINE DEDENT st = \"76952\" NEW_LINE if ( check ( st ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No ▁ \" ) NEW_LINE DEDENT"],"bleu":0.892710341544821,"rouge_l":0.9402502693295768}
{"id":878,"predictions":["import math NEW_LINE def check ( n ) : NEW_LINE INDENT d = math . sqrt ( n ) NEW_LINE if ( d * d == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def largestNonPerfectSquareNumber ( a , n ) : NEW_LINE INDENT maxi = - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( check ( a [ i ] ) ) : NEW_LINE INDENT maxi = max ( a [ i ] , maxi ) NEW_LINE DEDENT DEDENT return maxi NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 16 , 20 , 25 , 2 , 3 , 10 ] NEW_LINE n = len ( a ) NEW_LINE print ( largestNonPerfectSquareNumber ( a , n ) ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def check ( n ) : NEW_LINE INDENT d = int ( math . sqrt ( n ) ) NEW_LINE if ( d * d == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def largestNonPerfectSquareNumber ( a , n ) : NEW_LINE INDENT maxi = - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( check ( a [ i ] ) == False ) : NEW_LINE INDENT maxi = max ( a [ i ] , maxi ) NEW_LINE DEDENT DEDENT return maxi NEW_LINE DEDENT a = [ 16 , 20 , 25 , 2 , 3 , 10 ] NEW_LINE n = len ( a ) NEW_LINE print ( largestNonPerfectSquareNumber ( a , n ) ) NEW_LINE"],"bleu":0.8684477199109053,"rouge_l":0.9373522458628841}
{"id":879,"predictions":["def findValueAtX ( n ) : NEW_LINE INDENT return ( n * n * n ) + n NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( int ( findValueAtX ( 10 ) ) ) NEW_LINE print ( int ( findValueAtX ( 2 ) ) ) NEW_LINE DEDENT"],"references":["def findValueAtX ( n ) : NEW_LINE INDENT return ( n * n * n ) + n NEW_LINE DEDENT print ( findValueAtX ( 10 ) ) NEW_LINE print ( findValueAtX ( 2 ) ) NEW_LINE"],"bleu":0.5760316807875192,"rouge_l":0.8145400593471811}
{"id":880,"predictions":["from math import sqrt NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 6 NEW_LINE DEDENT return True NEW_LINE DEDENT def isThree Disctorial ( n ) : NEW_LINE INDENT sq = sqrt ( n ) NEW_LINE if ( 1. sqrt ( n ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT if ( 1.5 * sq != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True if ( isPrime ( sq ) ) else False NEW_LINE DEDENT N = 15 NEW_LINE if ( isThree Disctorial ( num ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT num = 12 NEW_LINE if ( isThree DisctorialFactorialFactorial ( num ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["from math import sqrt NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT k = int ( sqrt ( n ) ) + 1 NEW_LINE for i in range ( 5 , k , 6 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def isThreeDisctFactors ( n ) : NEW_LINE INDENT sq = int ( sqrt ( n ) ) NEW_LINE if ( 1 * sq * sq != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( isPrime ( sq ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT num = 9 NEW_LINE if ( isThreeDisctFactors ( num ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT num = 15 NEW_LINE if ( isThreeDisctFactors ( num ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT num = 12397923568441 NEW_LINE if ( isThreeDisctFactors ( num ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.6602905763941916,"rouge_l":0.7583383869011522}
{"id":881,"predictions":["def maxPartitions ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE max_so_far = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT max_so_far = max ( max_so_far , arr [ i ] ) NEW_LINE if ( max_so_far == i ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 0 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxPartitions ( arr , n ) ) NEW_LINE"],"references":["def maxPartitions ( arr , n ) : NEW_LINE INDENT ans = 0 ; max_so_far = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT max_so_far = max ( max_so_far , arr [ i ] ) NEW_LINE if ( max_so_far == i ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 0 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxPartitions ( arr , n ) ) NEW_LINE"],"bleu":0.9336656541325128,"rouge_l":0.9760877382236606}
{"id":882,"predictions":["def greaterK ( n , k ) : NEW_LINE INDENT p = [ 0 for i in range ( len ( str ) ) ] NEW_LINE index = 0 NEW_LINE x = n NEW_LINE while ( x ) : NEW_LINE INDENT p [ index ] = int ( x % k ) NEW_LINE x \/\/= k NEW_LINE index += 1 NEW_LINE DEDENT idx = 0 NEW_LINE for i in range ( len ( p ) - 1 ) : NEW_LINE INDENT if ( p [ i ] >= 2 ) : NEW_LINE INDENT p [ i ] = 0 NEW_LINE p [ i + 1 ] += 1 NEW_LINE for j in range ( idx , i ) : NEW_LINE INDENT p [ j ] = 0 NEW_LINE DEDENT idx = i + 1 NEW_LINE DEDENT if ( p [ i ] == k ) : NEW_LINE INDENT p [ i ] = 0 NEW_LINE p [ i + 1 ] += 1 NEW_LINE DEDENT DEDENT j = len ( p ) - 1 NEW_LINE if ( p [ j ] >= 2 ) : NEW_LINE INDENT p [ index ] = 1 NEW_LINE index += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( len ( p ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT ans *= k + p [ i ] NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT n = 29 NEW_LINE k = 7 NEW_LINE greaterK ( n , k ) NEW_LINE"],"references":["def greaterK ( n , k ) : NEW_LINE INDENT index = 0 NEW_LINE p = [ 0 for i in range ( n + 2 ) ] NEW_LINE x = n NEW_LINE while ( x > 0 ) : NEW_LINE INDENT p [ index ] = x % k NEW_LINE x \/\/= k NEW_LINE index += 1 NEW_LINE DEDENT idx = 0 NEW_LINE for i in range ( 0 , len ( p ) - 1 , 1 ) : NEW_LINE INDENT if ( p [ i ] >= 2 ) : NEW_LINE INDENT p [ i ] = 0 NEW_LINE p [ i + 1 ] += 1 NEW_LINE for j in range ( idx , i , 1 ) : NEW_LINE INDENT p [ j ] = 0 NEW_LINE DEDENT idx = i + 1 NEW_LINE DEDENT if ( p [ i ] == k ) : NEW_LINE INDENT p [ i ] = 0 NEW_LINE p [ i + 1 ] += 1 NEW_LINE DEDENT DEDENT j = len ( p ) - 1 NEW_LINE if ( p [ j ] >= 2 ) : NEW_LINE INDENT p [ index ] = 1 NEW_LINE index += 1 NEW_LINE DEDENT ans = 0 NEW_LINE i = len ( p ) - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT ans = ans * k + p [ i ] NEW_LINE i -= 1 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 29 NEW_LINE k = 7 NEW_LINE greaterK ( n , k ) NEW_LINE DEDENT"],"bleu":0.7870184444588317,"rouge_l":0.8713751456072588}
{"id":883,"predictions":["def longestPrefixSuffixSuffix ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE lps = [ 0 for i in range ( n ) ] NEW_LINE len1 = 0 NEW_LINE i = 1 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( s1 [ i ] == s [ len1 ] ) : NEW_LINE INDENT len1 += 1 NEW_LINE lps [ i ] = len1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( len1 != 0 ) : NEW_LINE INDENT len1 = lps [ len1 - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lps [ i ] = 0 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT DEDENT res = lps [ n - 1 ] NEW_LINE if ( res > int ( n \/ 2 ) ) : NEW_LINE INDENT return int ( n \/ 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" abcab \" NEW_LINE print ( longestPrefixSuffix ( s ) ) NEW_LINE DEDENT"],"references":["def longestPrefixSuffix ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE lps = [ 0 ] * n NEW_LINE l = 0 NEW_LINE i = 1 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( s [ i ] == s [ l ] ) : NEW_LINE INDENT l = l + 1 NEW_LINE lps [ i ] = l NEW_LINE i = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( l != 0 ) : NEW_LINE INDENT l = lps [ l - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lps [ i ] = 0 NEW_LINE i = i + 1 NEW_LINE DEDENT DEDENT DEDENT res = lps [ n - 1 ] NEW_LINE if ( res > n \/ 2 ) : NEW_LINE INDENT return n \/\/ 2 NEW_LINE DEDENT else : NEW_LINE INDENT return res NEW_LINE DEDENT DEDENT s = \" abcab \" NEW_LINE print ( longestPrefixSuffix ( s ) ) NEW_LINE"],"bleu":0.6506839967268733,"rouge_l":0.831531446836514}
{"id":884,"predictions":["def printBrangle ( exp , n ) : NEW_LINE INDENT left_bnum = 1 NEW_LINE right_bnum = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if exp [ i ] == ' ( ' : NEW_LINE INDENT print ( left_bnum , end = \" \" ) NEW_LINE right_bnum . append ( left_bnum ) NEW_LINE left_bnum += 1 NEW_LINE DEDENT elif exp [ i ] == ' ) ' : NEW_LINE INDENT print ( right_bnum , end = \" ▁ \" ) NEW_LINE return NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT exp = \" ( a + ( b * c ) ) + ( d \/ e ) \" NEW_LINE n = len ( exp ) NEW_LINE printBrangleNumber ( exp , n ) NEW_LINE DEDENT"],"references":["def printBracketNumber ( exp , n ) : NEW_LINE INDENT left_bnum = 1 NEW_LINE right_bnum = list ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if exp [ i ] == ' ( ' : NEW_LINE INDENT print ( left_bnum , end = \" ▁ \" ) NEW_LINE right_bnum . append ( left_bnum ) NEW_LINE left_bnum += 1 NEW_LINE DEDENT elif exp [ i ] == ' ) ' : NEW_LINE INDENT print ( right_bnum [ - 1 ] , end = \" ▁ \" ) NEW_LINE right_bnum . pop ( ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT exp = \" ( a + ( b * c ) ) + ( d \/ e ) \" NEW_LINE n = len ( exp ) NEW_LINE printBracketNumber ( exp , n ) NEW_LINE DEDENT"],"bleu":0.799553239491961,"rouge_l":0.9066258225550262}
{"id":885,"predictions":["from math import sqrt NEW_LINE N = int ( 1e6 ) NEW_LINE fourDiv = [ True ] * ( N + 1 ) ; NEW_LINE def fourDistinctFactors ( ) : NEW_LINE INDENT primeAll = [ False ] * ( N + 1 ) ; NEW_LINE p = 2 ; NEW_LINE while ( p * p <= N ) : NEW_LINE INDENT if ( primeAll [ p ] == True ) : NEW_LINE INDENT primeAll [ p ] = True ; NEW_LINE DEDENT p += 1 ; NEW_LINE DEDENT prime = [ ] ; NEW_LINE for p in range ( N + 1 ) : NEW_LINE INDENT if ( primeAll [ p ] ) : NEW_LINE INDENT prime . append ( p ) ; NEW_LINE DEDENT DEDENT for i in range ( len ( prime ) ) : NEW_LINE INDENT p = prime [ i ] ; NEW_LINE if ( 1. * p * p <= N ) : NEW_LINE INDENT 4 * p * p * p ; NEW_LINE DEDENT for j in range ( i + 1 , len ( prime ) ) : NEW_LINE INDENT q = prime [ j ] ; NEW_LINE if ( 1l * p * q > N ) : NEW_LINE INDENT break ; NEW_LINE DEDENT 4 * q * q ; NEW_LINE DEDENT DEDENT DEDENT if 4 ; NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE num = 12 ; NEW_LINE if ( 40000000 [ num ] ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT num = 12 ; NEW_LINE if ( 40000000 ] ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT"],"references":["N = 1000001 ; NEW_LINE fourDiv = [ False ] * ( N + 1 ) ; NEW_LINE def fourDistinctFactors ( ) : NEW_LINE INDENT primeAll = [ True ] * ( N + 1 ) ; NEW_LINE p = 2 ; NEW_LINE while ( p * p <= N ) : NEW_LINE INDENT if ( primeAll [ p ] == True ) : NEW_LINE INDENT i = p * 2 ; NEW_LINE while ( i <= N ) : NEW_LINE INDENT primeAll [ i ] = False ; NEW_LINE i += p ; NEW_LINE DEDENT DEDENT p += 1 ; NEW_LINE DEDENT prime = [ ] ; NEW_LINE for p in range ( 2 , N + 1 ) : NEW_LINE INDENT if ( primeAll [ p ] ) : NEW_LINE INDENT prime . append ( p ) ; NEW_LINE DEDENT DEDENT for i in range ( len ( prime ) ) : NEW_LINE INDENT p = prime [ i ] ; NEW_LINE if ( 1 * p * p * p <= N ) : NEW_LINE INDENT fourDiv [ p * p * p ] = True ; NEW_LINE DEDENT for j in range ( i + 1 , len ( prime ) ) : NEW_LINE INDENT q = prime [ j ] ; NEW_LINE if ( 1 * p * q > N ) : NEW_LINE INDENT break ; NEW_LINE DEDENT fourDiv [ p * q ] = True ; NEW_LINE DEDENT DEDENT DEDENT fourDistinctFactors ( ) ; NEW_LINE num = 10 ; NEW_LINE if ( fourDiv [ num ] ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT num = 12 ; NEW_LINE if ( fourDiv [ num ] ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT"],"bleu":0.806944992071603,"rouge_l":0.8499695987028779}
{"id":886,"predictions":["N = 3 NEW_LINE def scalarProductMat ( mat , k ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT mat [ i ] [ j ] = mat [ i ] [ j ] * k NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT mat = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE k = 4 NEW_LINE scalarProductMat ( mat , k ) NEW_LINE print ( \" Square ▁ Product ▁ Matrix ▁ Matrix ▁ is ▁ : ▁ \" , end = \" ▁ \" ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT mat [ i ] [ j ] = mat [ i ] [ j ] NEW_LINE print ( mat [ i ] [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT"],"references":["N = 3 NEW_LINE def scalarProductMat ( mat , k ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT mat [ i ] [ j ] = mat [ i ] [ j ] * k NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT mat = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE k = 4 NEW_LINE scalarProductMat ( mat , k ) NEW_LINE print ( \" Scalar ▁ Product ▁ Matrix ▁ is ▁ : ▁ \" ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT"],"bleu":0.8514986458599373,"rouge_l":0.938722536386391}
{"id":887,"predictions":["def geeksforgeeks \" ; NEW_LINE print ( ' geeksforgeeks ' ) ; NEW_LINE"],"references":["str = \" geeksforgeeks \" ; NEW_LINE str = \" \" . join ( reversed ( str ) ) NEW_LINE print ( str ) ; NEW_LINE"],"bleu":0.15715083214913006,"rouge_l":0.4353687549563838}
{"id":888,"predictions":["def countDistinct ( arr , n ) : NEW_LINE INDENT hs = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hs . add ( arr [ i ] ) NEW_LINE DEDENT return len ( hs ) NEW_LINE DEDENT arr = [ 6 , 10 , 5 , 4 , 9 , 120 , 4 , 6 , 10 ] NEW_LINE print ( countDistinct ( arr , len ( arr ) ) ) NEW_LINE"],"references":["def countDistinct ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] not in s ) : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT arr = [ 6 , 10 , 5 , 4 , 9 , 120 , 4 , 6 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countDistinct ( arr , n ) ) NEW_LINE"],"bleu":0.5946335418595002,"rouge_l":0.7453515140782717}
{"id":889,"predictions":["x = 32 NEW_LINE def toggleCase ( a ) : NEW_LINE INDENT for i in range ( len ( a ) ) : NEW_LINE INDENT a [ i ] ^= 32 NEW_LINE DEDENT return \" \\n \" . join ( a ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = toggleRrY \" NEW_LINE print \" toggle ▁ case : ▁ \" NEW_LINE print toggle ▁ string : ▁ \" , end = \" \" ) NEW_LINE print toggleCase ( str ) NEW_LINE DEDENT"],"references":["x = 32 ; NEW_LINE def toggleCase ( a ) : NEW_LINE INDENT for i in range ( len ( a ) ) : NEW_LINE INDENT a = a [ : i ] + chr ( ord ( a [ i ] ) ^ 32 ) + a [ i + 1 : ] ; NEW_LINE DEDENT return a ; NEW_LINE DEDENT str = \" CheRrY \" ; NEW_LINE print ( \" Toggle ▁ case : ▁ \" , end = \" \" ) ; NEW_LINE str = toggleCase ( str ) ; NEW_LINE print ( str ) ; NEW_LINE print ( \" Original ▁ string : ▁ \" , end = \" \" ) ; NEW_LINE str = toggleCase ( str ) ; NEW_LINE print ( str ) ; NEW_LINE"],"bleu":0.34121539314444804,"rouge_l":0.573831242873432}
{"id":890,"predictions":["MAX = 10000 ; NEW_LINE arr = [ ] ; NEW_LINE prime = [ True ] * MAX ; NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT for p in range ( MAX ) : NEW_LINE INDENT if ( p * p > MAX ) : NEW_LINE INDENT break ; NEW_LINE DEDENT if ( p * p > MAX ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT for p in range ( 2 , MAX ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT arr . append ( p ) ; NEW_LINE DEDENT DEDENT DEDENT def isPrimorial ( n ) : NEW_LINE INDENT if ( not prime [ n ] ) : NEW_LINE INDENT return false ; NEW_LINE DEDENT product = 1 ; NEW_LINE i = 0 ; NEW_LINE while ( product < n ) : NEW_LINE INDENT product = product * arr [ i ] ; NEW_LINE if ( product + 1 == n or product - 1 == n ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT SieveOfEratosthenes ( ) ; NEW_LINE n = 31 ; NEW_LINE if ( isPrimorialPrime ( n ) ) : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE DEDENT DEDENT"],"references":["from math import sqrt NEW_LINE MAX = 100000 NEW_LINE prime = [ True ] * MAX NEW_LINE arr = [ ] NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT for p in range ( 2 , int ( sqrt ( MAX ) ) + 1 ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for p in range ( 2 , MAX ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT arr . append ( p ) NEW_LINE DEDENT DEDENT DEDENT def isPrimorialPrime ( n ) : NEW_LINE INDENT if not prime [ n ] : NEW_LINE INDENT return False NEW_LINE DEDENT product , i = 1 , 0 NEW_LINE while product < n : NEW_LINE INDENT product *= arr [ i ] NEW_LINE if product + 1 == n or product - 1 == n : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE n = 31 NEW_LINE if ( isPrimorialPrime ( n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.6046213143050609,"rouge_l":0.7956702861435498}
{"id":891,"predictions":["def countNumbers ( X , Y , N ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( ( i % X == 0 ) and ( i % Y != 0 ) ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT X = 2 ; Y = 3 ; N = 10 ; NEW_LINE print ( countNumbers ( X , Y , N ) ) ; NEW_LINE DEDENT"],"references":["def countNumbers ( X , Y , N ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( ( i % X == 0 ) and ( i % Y != 0 ) ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT X = 2 ; NEW_LINE Y = 3 ; NEW_LINE N = 10 ; NEW_LINE print ( countNumbers ( X , Y , N ) ) ; NEW_LINE"],"bleu":0.8224093841061807,"rouge_l":0.928619756427605}
{"id":892,"predictions":["from collections import defaultdict NEW_LINE def countSubseq ( arr , n ) : NEW_LINE INDENT um = defaultdict ( lambda : 0 ) NEW_LINE count = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] not in um . keys ( ) : NEW_LINE INDENT um [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT um [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT for key , value in um . items ( ) : NEW_LINE INDENT count *= um [ value ] NEW_LINE DEDENT return count NEW_LINE DEDENT arr = [ 4 , 7 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Count ▁ = ▁ \" , countSubseq ( arr , n ) ) NEW_LINE"],"references":["def countSubseq ( arr , n ) : NEW_LINE INDENT um = { i : 0 for i in range ( 8 ) } NEW_LINE count = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT um [ arr [ i ] ] += 1 NEW_LINE DEDENT for key , values in um . items ( ) : NEW_LINE INDENT if ( values > 0 ) : NEW_LINE INDENT count *= values NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 7 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Count ▁ = \" , countSubseq ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.6509812780572168,"rouge_l":0.7105933745904622}
{"id":893,"predictions":["import math NEW_LINE def check ( a , b ) : NEW_LINE INDENT c = 0 NEW_LINE while ( a != 0 ) : NEW_LINE INDENT c = c + a % 10 NEW_LINE a = a \/\/ 10 NEW_LINE DEDENT return ( c == b ) NEW_LINE DEDENT def root ( n ) : NEW_LINE INDENT found = False NEW_LINE mx = 1e18 NEW_LINE for i in range ( 90 ) : NEW_LINE INDENT s = i * i + 4 * n NEW_LINE sq = math . sqrt ( s ) NEW_LINE if ( sq * sq == s and check ( ( sq - i ) \/\/ 2 , i ) ) : NEW_LINE INDENT found = True NEW_LINE mx = min ( mx , ( sq - i ) \/\/ 2 ) NEW_LINE DEDENT DEDENT if ( found ) : NEW_LINE INDENT return mx NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 110 NEW_LINE print ( root ( n ) ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def check ( a , b ) : NEW_LINE INDENT c = 0 ; NEW_LINE while ( a != 0 ) : NEW_LINE INDENT c = c + a % 10 ; NEW_LINE a = int ( a \/ 10 ) ; NEW_LINE DEDENT return True if ( c == b ) else False ; NEW_LINE DEDENT def root ( n ) : NEW_LINE INDENT found = False ; NEW_LINE mx = 1000000000000000001 ; NEW_LINE for i in range ( 91 ) : NEW_LINE INDENT s = i * i + 4 * n ; NEW_LINE sq = int ( math . sqrt ( s ) ) ; NEW_LINE if ( sq * sq == s and check ( int ( ( sq - i ) \/ 2 ) , i ) ) : NEW_LINE INDENT found = True ; NEW_LINE mx = min ( mx , int ( ( sq - i ) \/ 2 ) ) ; NEW_LINE DEDENT DEDENT if ( found ) : NEW_LINE INDENT return mx ; NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT DEDENT n = 110 ; NEW_LINE print ( root ( n ) ) ; NEW_LINE"],"bleu":0.6468555927669392,"rouge_l":0.8544707263881898}
{"id":894,"predictions":["def Fraction ( n , d ) : NEW_LINE INDENT num = n ; den = d ; NEW_LINE den = d ; NEW_LINE d = sec . den ; NEW_LINE Y = a * d - b * c ; NEW_LINE Y = a * d - b * c ; NEW_LINE if ( Y > 0 ) : NEW_LINE INDENT print ( first . num , ' \/ ' ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' { } ' . format ( Fraction ( first , sec ) ) ) ; NEW_LINE DEDENT"],"references":["def maxFraction ( first , sec ) : NEW_LINE INDENT a = first [ 0 ] ; b = first [ 1 ] NEW_LINE c = sec [ 0 ] ; d = sec [ 1 ] NEW_LINE Y = a * d - b * c NEW_LINE return first if Y else sec NEW_LINE DEDENT first = ( 3 , 2 ) NEW_LINE sec = ( 3 , 4 ) NEW_LINE res = maxFraction ( first , sec ) NEW_LINE print ( str ( res [ 0 ] ) + \" \/ \" + str ( res [ 1 ] ) ) NEW_LINE"],"bleu":0.2099779213132779,"rouge_l":0.4413892908827786}
{"id":895,"predictions":["def Permutation ( n , k ) : NEW_LINE INDENT p = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT p [ i ] = i NEW_LINE DEDENT for i in range ( 1 , n - k ) : NEW_LINE INDENT p [ i + 1 ] = i NEW_LINE DEDENT p [ 1 ] = n - k NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( p [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE k = 2 NEW_LINE Permutation ( n , k ) NEW_LINE DEDENT"],"references":["def Permutation ( n , k ) : NEW_LINE INDENT p = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT p [ i ] = i NEW_LINE DEDENT for i in range ( 1 , n - k ) : NEW_LINE INDENT p [ i + 1 ] = i NEW_LINE DEDENT p [ 1 ] = n - k NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( p [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE k = 2 NEW_LINE Permutation ( n , k ) NEW_LINE DEDENT"],"bleu":0.9691663471622525,"rouge_l":0.9856115107913669}
{"id":896,"predictions":["def reverse ( x ) : NEW_LINE INDENT rev = 0 ; NEW_LINE while ( x ) : NEW_LINE INDENT rev = ( rev * 10 ) + x % 10 ; NEW_LINE x = int ( x \/ 10 ) ; NEW_LINE DEDENT return rev ; NEW_LINE DEDENT def printEmirp ( n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) ; NEW_LINE p = 2 ; NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT rev = reverse ( p ) ; NEW_LINE if ( p != rev and rev <= n and prime [ rev ] ) : NEW_LINE INDENT print ( p , end = \" ▁ \" ) ; NEW_LINE rev [ rev ] = False ; NEW_LINE DEDENT DEDENT DEDENT DEDENT n = 100 ; NEW_LINE printEmirp ( n ) ; NEW_LINE"],"references":["def reverse ( x ) : NEW_LINE INDENT rev = 0 ; NEW_LINE while ( x > 0 ) : NEW_LINE INDENT rev = ( rev * 10 ) + x % 10 ; NEW_LINE x = int ( x \/ 10 ) ; NEW_LINE DEDENT return rev ; NEW_LINE DEDENT def printEmirp ( n ) : NEW_LINE INDENT prime = [ 1 ] * ( n + 1 ) ; NEW_LINE p = 2 ; NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == 1 ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = 0 ; NEW_LINE DEDENT DEDENT p += 1 ; NEW_LINE DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] == 1 ) : NEW_LINE INDENT rev = reverse ( p ) ; NEW_LINE if ( p != rev and rev <= n and prime [ rev ] == 1 ) : NEW_LINE INDENT print ( p , rev , end = \" ▁ \" ) ; NEW_LINE prime [ rev ] = 0 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT n = 100 ; NEW_LINE printEmirp ( n ) ; NEW_LINE"],"bleu":0.8542910739801011,"rouge_l":0.9423134328358207}
{"id":897,"predictions":["def largest ( arr , n ) : NEW_LINE INDENT arr . sort ( reverse = True ) NEW_LINE return largest ( arr [ n - 1 ] ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 10 , 324 , 45 , 90 , 9808 ] NEW_LINE n = len ( arr ) NEW_LINE print ( largest ( arr , n ) ) NEW_LINE DEDENT"],"references":["def largest ( arr , n ) : NEW_LINE INDENT return max ( arr ) NEW_LINE DEDENT arr = [ 10 , 324 , 45 , 90 , 9808 ] NEW_LINE n = len ( arr ) NEW_LINE print ( largest ( arr , n ) ) NEW_LINE"],"bleu":0.5465373856726298,"rouge_l":0.7902425578831311}
{"id":898,"predictions":["class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def maxLevelProduct ( root ) : NEW_LINE INDENT if ( not root ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT result = root . data NEW_LINE q = [ ] NEW_LINE q . append ( root ) NEW_LINE while ( len ( q ) ) : NEW_LINE INDENT count = len ( q ) NEW_LINE product = 1 NEW_LINE while ( count ) : NEW_LINE INDENT temp = q [ 0 ] NEW_LINE q . pop ( 0 ) NEW_LINE product = product * temp . data NEW_LINE if ( temp . left != None ) : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE DEDENT if ( temp . right != None ) : NEW_LINE INDENT q . append ( temp . right ) NEW_LINE DEDENT DEDENT result = max ( product , result ) NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 1 ) NEW_LINE root . left = newNode ( 2 ) NEW_LINE root . right = newNode ( 3 ) NEW_LINE root . left . left = newNode ( 4 ) NEW_LINE root . left . left = newNode ( 5 ) NEW_LINE root . left . right = newNode ( 5 ) NEW_LINE root . right . right = newNode ( 8 ) NEW_LINE root . right . left = newNode ( 8 ) NEW_LINE root . right . right = newNode ( 6 ) NEW_LINE root . right . left = newNode ( 7 ) NEW_LINE root . right . right . left = newNode ( 7 ) NEW_LINE root . right . right = newNode ( 7 ) NEW_LINE print ( \" Maximum ▁ level ▁ is \" , maxLevelProduct ( root ) ) NEW_LINE DEDENT"],"references":["class newNode : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . data = key NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def maxLevelProduct ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT result = root . data NEW_LINE q = [ ] NEW_LINE q . append ( root ) NEW_LINE while ( len ( q ) ) : NEW_LINE INDENT count = len ( q ) NEW_LINE product = 1 NEW_LINE while ( count ) : NEW_LINE INDENT count -= 1 NEW_LINE temp = q [ 0 ] NEW_LINE q . pop ( 0 ) NEW_LINE product = product * temp . data NEW_LINE if ( temp . left != None ) : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE DEDENT if ( temp . right != None ) : NEW_LINE INDENT q . append ( temp . right ) NEW_LINE DEDENT DEDENT result = max ( product , result ) NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 1 ) NEW_LINE root . left = newNode ( 2 ) NEW_LINE root . right = newNode ( 3 ) NEW_LINE root . left . left = newNode ( 4 ) NEW_LINE root . left . right = newNode ( 5 ) NEW_LINE root . right . right = newNode ( 8 ) NEW_LINE root . right . right . left = newNode ( 6 ) NEW_LINE root . right . right . right = newNode ( 7 ) NEW_LINE print ( \" Maximum ▁ level ▁ product ▁ is \" , maxLevelProduct ( root ) ) NEW_LINE DEDENT"],"bleu":0.843234700049596,"rouge_l":0.9196298606778956}
{"id":899,"predictions":["def fact ( n ) : NEW_LINE INDENT fact = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fact *= i NEW_LINE DEDENT return fact NEW_LINE DEDENT def countStrings ( st , n ) : NEW_LINE INDENT distinct_char = set ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT distinct_char . add ( st [ i ] ) NEW_LINE DEDENT return fact ( len ( distinct_char ) ) NEW_LINE DEDENT st = \" geeksforgeeks \" NEW_LINE n = len ( st ) NEW_LINE print ( countStrings ( st , n ) ) NEW_LINE"],"references":["def fact ( n ) : NEW_LINE INDENT fact = 1 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fact *= i ; NEW_LINE DEDENT return fact ; NEW_LINE DEDENT def countStrings ( string , n ) : NEW_LINE INDENT distinct_char = set ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT distinct_char . add ( string [ i ] ) ; NEW_LINE DEDENT return fact ( len ( distinct_char ) ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" geeksforgeeks \" ; NEW_LINE n = len ( string ) ; NEW_LINE print ( countStrings ( string , n ) ) ; NEW_LINE DEDENT"],"bleu":0.5950392593710037,"rouge_l":0.8375669367019084}
{"id":900,"predictions":["def printMaxValPair ( v , n ) : NEW_LINE INDENT v . sort ( reverse = True ) NEW_LINE N = v [ int ( n \/ 2 ) ] NEW_LINE if ( N % 2 == 1 ) : NEW_LINE INDENT first_max = N \/\/ 2 NEW_LINE second_max = first_max + 1 NEW_LINE ans1 = 3e18 NEW_LINE ans2 = 3e18 NEW_LINE from = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( v [ int ( i ) ] > first_max ) : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT diff = first_maxi - v [ int ( i ) ] NEW_LINE if ( diff < ans1 ) : NEW_LINE INDENT ans1 = diff NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT diff = first_maxi - v [ int ( i ) ] NEW_LINE if ( diff < ans1 ) : NEW_LINE INDENT ans1 = diff NEW_LINE return diff NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT max = N \/\/ 2 NEW_LINE ans1 = first_maxi - from_left NEW_LINE diff2 = - 1 NEW_LINE if ( diff1 < diff2 ) : NEW_LINE INDENT print ( \" N \" , first_left ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( N , first_right ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT max = N \/\/ 2 NEW_LINE ans1 = first_maxi - from_left NEW_LINE diff2 = - 1 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT diff2 = abs ( v [ i ] - max1 ) NEW_LINE if ( diff1 < diff2 ) : NEW_LINE INDENT ans2 = diff2 NEW_LINE R = v [ i ] NEW_LINE DEDENT DEDENT print ( N , R ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT v = [ 1 , 1 , 2 , 3 , 6 , 1 ] NEW_LINE V ="],"references":["def printMaxValPair ( v , n ) : NEW_LINE INDENT v . sort ( ) NEW_LINE N = v [ n - 1 ] NEW_LINE if N % 2 == 1 : NEW_LINE INDENT first_maxima = N \/\/ 2 NEW_LINE second_maxima = first_maxima + 1 NEW_LINE ans1 , ans2 = 3 * ( 10 ** 18 ) , 3 * ( 10 ** 18 ) NEW_LINE from_left , from_right = - 1 , - 1 NEW_LINE _from = - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if v [ i ] > first_maxima : NEW_LINE INDENT _from = i NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT diff = first_maxima - v [ i ] NEW_LINE if diff < ans1 : NEW_LINE INDENT ans1 = diff NEW_LINE from_left = v [ i ] NEW_LINE DEDENT DEDENT DEDENT from_right = v [ _from ] NEW_LINE diff1 = first_maxima - from_left NEW_LINE diff2 = from_right - second_maxima NEW_LINE if diff1 < diff2 : NEW_LINE INDENT print ( N , from_left ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( N , from_right ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT maxima = N \/\/ 2 NEW_LINE ans1 = 3 * ( 10 ** 18 ) NEW_LINE R = - 1 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT diff = abs ( v [ i ] - maxima ) NEW_LINE if diff < ans1 : NEW_LINE INDENT ans1 = diff NEW_LINE R = v [ i ] NEW_LINE DEDENT DEDENT print ( N , R ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT v = [ 1 , 1 , 2 , 3 , 6 , 1 ] NEW_LINE n = len ( v ) NEW_LINE printMaxValPair ( v , n ) NEW_LINE DEDENT"],"bleu":0.5637451566024761,"rouge_l":0.735204738604172}
{"id":901,"predictions":["def triangle ( n ) : NEW_LINE INDENT k = 2 * n - 2 NEW_LINE ch = 1 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT for j in range ( 0 , k ) : NEW_LINE INDENT print ( ch , end = \" ▁ \" ) NEW_LINE k = k - 1 NEW_LINE for j in range ( 0 , i + 1 ) : NEW_LINE INDENT print ( ch , end = \" ▁ \" ) NEW_LINE DEDENT print ( \" \" ) NEW_LINE i = i + 1 NEW_LINE for j in range ( 0 , i + 1 ) : NEW_LINE INDENT print ( ch , end = \" ▁ \" ) NEW_LINE DEDENT print ( \" ▁ \" ) NEW_LINE i = i + 1 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 9 NEW_LINE triangle ( N ) NEW_LINE DEDENT"],"references":["from math import sqrt NEW_LINE def triangle ( n ) : NEW_LINE INDENT k = 2 * n - 2 ; NEW_LINE ch = 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( k ) : NEW_LINE INDENT print ( \" ▁ \" , end = \" \" ) ; NEW_LINE DEDENT k = k - 1 ; NEW_LINE for j in range ( i + 1 ) : NEW_LINE INDENT print ( ch , end = \" ▁ \" ) ; NEW_LINE ch += 1 ; NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT def maxHeight ( n ) : NEW_LINE INDENT ans = ( sqrt ( 1 + 8.0 * n ) - 1 ) \/\/ 2 ; NEW_LINE return int ( ans ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 9 ; NEW_LINE triangle ( maxHeight ( N ) ) ; NEW_LINE DEDENT"],"bleu":0.5022627635336474,"rouge_l":0.675344105326152}
{"id":902,"predictions":["def longestInteger ( str , l ) : NEW_LINE INDENT count = 0 NEW_LINE pos = 0 NEW_LINE pre_pos = - 1 NEW_LINE length = 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT pre_pos = pos NEW_LINE pre_pos = pos NEW_LINE count = 0 NEW_LINE l = 0 NEW_LINE if ( str [ i ] >= \" \"0\" ) : NEW_LINE INDENT pos = i NEW_LINE DEDENT while ( str [ i ] >= \"0\" ) : NEW_LINE INDENT count += 1 NEW_LINE i += 1 NEW_LINE l += 1 NEW_LINE DEDENT if ( count > max ) : NEW_LINE INDENT max = count NEW_LINE count = count NEW_LINE DEDENT else : NEW_LINE INDENT pos = pre_pos NEW_LINE length = pre_len NEW_LINE length = pre_len NEW_LINE DEDENT DEDENT return str [ pos : pos + length ] NEW_LINE DEDENT str = \" geeks100for1234ins \" NEW_LINE l = len ( str ) NEW_LINE print ( longestInteger ( str , l ) ) NEW_LINE"],"references":["def longestInteger ( s , length ) : NEW_LINE INDENT count = 0 NEW_LINE maximum = 0 NEW_LINE pos = - 1 NEW_LINE l = 0 NEW_LINE for i in range ( length ) : NEW_LINE INDENT pre_pos = pos NEW_LINE pre_len = l NEW_LINE count = 0 NEW_LINE l = 0 NEW_LINE if ( s [ i ] . isdecimal ( ) ) : NEW_LINE INDENT pos = i NEW_LINE DEDENT while ( s [ i ] . isdecimal ( ) ) : NEW_LINE INDENT count += 1 NEW_LINE i += 1 NEW_LINE l += 1 NEW_LINE DEDENT if ( count > maximum ) : NEW_LINE INDENT maximum = count NEW_LINE DEDENT else : NEW_LINE INDENT pos = pre_pos NEW_LINE l = pre_len NEW_LINE DEDENT DEDENT return ( s [ pos : pos + l ] ) NEW_LINE DEDENT s = \" geeks100for1234geeks \" NEW_LINE length = len ( s ) NEW_LINE print ( longestInteger ( s , length ) ) NEW_LINE"],"bleu":0.6121347995191768,"rouge_l":0.8037532441605111}
{"id":903,"predictions":["def findSum ( n , a , b ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( i % a == 0 or i % b == 0 ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 10 NEW_LINE a = 3 NEW_LINE b = 5 NEW_LINE print ( findSum ( n , a , b ) ) NEW_LINE DEDENT"],"references":["def findSum ( n , a , b ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( i % a == 0 or i % b == 0 ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE a = 3 NEW_LINE b = 5 NEW_LINE print ( findSum ( n , a , b ) ) NEW_LINE DEDENT"],"bleu":0.9087831611689187,"rouge_l":0.9662315056570931}
{"id":904,"predictions":["def seriesSum ( n ) : NEW_LINE INDENT return int ( ( ( n * ( n + 1 ) * ( n + 2 ) ) ) \/ 6 ) NEW_LINE DEDENT n = 4 NEW_LINE print ( seriesSum ( n ) ) NEW_LINE"],"references":["def seriesSum ( n ) : NEW_LINE INDENT return int ( ( n * ( n + 1 ) * ( n + 2 ) ) \/ 6 ) NEW_LINE DEDENT n = 4 NEW_LINE print ( seriesSum ( n ) ) NEW_LINE"],"bleu":0.9431611167187858,"rouge_l":0.98129442573887}
{"id":905,"predictions":["def find_count ( ele ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( ele ) ) : NEW_LINE INDENT p = [ ] NEW_LINE c = 0 NEW_LINE for j in range ( len ( ele ) - 1 , - i ) : NEW_LINE INDENT p = [ ] NEW_LINE c = 0 NEW_LINE for j in range ( len ( ele ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT p . append ( ele [ j ] ) NEW_LINE DEDENT j = len ( ele ) - 1 NEW_LINE k = 0 NEW_LINE while ( j >= 0 ) : NEW_LINE INDENT if ( ele [ j ] != p [ k ] ) : NEW_LINE INDENT break NEW_LINE DEDENT j -= 1 NEW_LINE k += 1 NEW_LINE if ( k == len ( p ) ) : NEW_LINE INDENT c += 1 NEW_LINE k = 0 NEW_LINE DEDENT DEDENT count = max ( count , c ) NEW_LINE DEDENT return max ( count , c ) NEW_LINE DEDENT def solve ( n ) : NEW_LINE INDENT count = 1 NEW_LINE ele = [ ] NEW_LINE for i in range ( len ( ele ) ) : NEW_LINE INDENT print ( count , end = \" , ▁ \" ) NEW_LINE end . append ( ele ) NEW_LINE count = find_count ( e ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 16 NEW_LINE solve ( ele ) NEW_LINE DEDENT"],"references":["def find_count ( ele ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( ele ) ) : NEW_LINE INDENT p = [ ] NEW_LINE c = 0 NEW_LINE j = len ( ele ) - 1 NEW_LINE while j >= ( len ( ele ) - 1 - i ) and j >= 0 : NEW_LINE INDENT p . append ( ele [ j ] ) NEW_LINE j -= 1 NEW_LINE DEDENT j = len ( ele ) - 1 NEW_LINE k = 0 NEW_LINE while j >= 0 : NEW_LINE INDENT if ele [ j ] != p [ k ] : NEW_LINE INDENT break NEW_LINE DEDENT j -= 1 NEW_LINE k += 1 NEW_LINE if k == len ( p ) : NEW_LINE INDENT c += 1 NEW_LINE k = 0 NEW_LINE DEDENT DEDENT count = max ( count , c ) NEW_LINE DEDENT return count NEW_LINE DEDENT def solve ( n ) : NEW_LINE INDENT count = 1 NEW_LINE ele = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( count , end = \" ▁ \" ) NEW_LINE ele . append ( count ) NEW_LINE count = find_count ( ele ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 10 NEW_LINE solve ( n ) NEW_LINE DEDENT"],"bleu":0.6925780561263866,"rouge_l":0.8683419100447771}
{"id":906,"predictions":["def getMinimumOps ( ar , k ) : NEW_LINE INDENT n = len ( ar ) NEW_LINE dp = [ [ 0 for x in range ( k + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE dp [ 0 ] [ 1 ] = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT maxGroups = min ( k , i + 1 ) NEW_LINE for j in range ( 1 , maxGroups + 1 ) : NEW_LINE INDENT dp [ ar [ it ] ] += 1 NEW_LINE if ( j == 1 ) : NEW_LINE INDENT freq = [ 0 ] * 100000 NEW_LINE freqOfLine = 0 NEW_LINE for it in range ( 0 , i + 1 ) : NEW_LINE INDENT freq [ ar [ it ] ] += 1 NEW_LINE newElement = freq [ ar [ it ] ] NEW_LINE if ( newElementFreq > freq ) : NEW_LINE INDENT freqOfLine = [ 0 ] * 100000 NEW_LINE DEDENT DEDENT dp [ i ] [ 1 ] = ( i + 1 ) - freqOfLine NEW_LINE DEDENT dp [ i ] [ 1 ] = ( i + 1 ) - freqOfLine NEW_LINE DEDENT else : NEW_LINE INDENT freq = [ 0 ] * 100000 NEW_LINE freqOfMode = 0 NEW_LINE for it in range ( i , j - 1 , - 1 ) : NEW_LINE INDENT freq [ ar [ it ] ] += 1 NEW_LINE newElementFreq = freq [ ar [ it ] ] NEW_LINE if ( newElementFreq > freq5 ) : NEW_LINE INDENT freqOfLine = newNode [ it ] + 1 NEW_LINE if ( newElementFreq > freqOfLine ) : NEW_LINE INDENT freqOfLine = newElementFreq NEW_LINE DEDENT DEDENT DEDENT DEDENT return dp [ n - 1 ] [ k ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT k = 3 NEW_LINE ar = [ 3 , 1 , 3 , 3 , 2 , 1 , 8 ,"],"references":["def getMinimumOps ( ar , k ) : NEW_LINE INDENT n = len ( ar ) NEW_LINE dp = [ [ 0 for i in range ( k + 1 ) ] for i in range ( n ) ] NEW_LINE dp [ 0 ] [ 1 ] = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT maxGroups = min ( k , i + 1 ) NEW_LINE for j in range ( 1 , maxGroups + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = 10 ** 9 NEW_LINE if ( j == 1 ) : NEW_LINE INDENT freq1 = dict ( ) NEW_LINE freqOfMode = 0 NEW_LINE for it in range ( 0 , i + 1 ) : NEW_LINE INDENT freq1 [ ar [ it ] ] = freq1 . get ( ar [ it ] , 0 ) + 1 NEW_LINE newElementFreq = freq1 [ ar [ it ] ] NEW_LINE if ( newElementFreq > freqOfMode ) : NEW_LINE INDENT freqOfMode = newElementFreq NEW_LINE DEDENT DEDENT dp [ i ] [ 1 ] = ( i + 1 ) - freqOfMode NEW_LINE DEDENT else : NEW_LINE INDENT freq = dict ( ) NEW_LINE freqOfMode = 0 NEW_LINE for it in range ( i , j - 2 , - 1 ) : NEW_LINE INDENT freq [ ar [ it ] ] = freq . get ( ar [ it ] , 0 ) + 1 NEW_LINE newElementFreq = freq [ ar [ it ] ] NEW_LINE if ( newElementFreq > freqOfMode ) : NEW_LINE INDENT freqOfMode = newElementFreq NEW_LINE DEDENT elementsToChange = i - it + 1 NEW_LINE elementsToChange -= freqOfMode NEW_LINE dp [ i ] [ j ] = min ( dp [ it - 1 ] [ j - 1 ] + elementsToChange , dp [ i ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return dp [ n - 1 ] [ k ] NEW_LINE DEDENT k = 3 NEW_LINE ar = [ 3 , 1 , 3 , 3 , 2 , 1 , 8 , 5 ] NEW_LINE print ( getMinimumOps ( ar , k ) ) NEW_LINE"],"bleu":0.654520098874047,"rouge_l":0.7319776495374187}
{"id":907,"predictions":["def findCount ( N ) : NEW_LINE INDENT list = [ ] ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( 20 ) : NEW_LINE INDENT sum += pow ( 2 , i ) ; NEW_LINE list . append ( sum ) ; NEW_LINE DEDENT for i in range ( 20 ) : NEW_LINE INDENT if ( list [ i ] > N ) : NEW_LINE INDENT return ( list [ list [ i ] ] + 1 ) ; NEW_LINE DEDENT DEDENT return 0 ; NEW_LINE DEDENT N = 10 ; NEW_LINE print ( findCount ( N ) ) ; NEW_LINE"],"references":["def findCount ( N ) : NEW_LINE INDENT list = [ ] NEW_LINE sum = 0 NEW_LINE for i in range ( 0 , 20 ) : NEW_LINE INDENT sum += 2 ** i NEW_LINE list . append ( sum ) NEW_LINE DEDENT for value in list : NEW_LINE INDENT if ( value > N ) : NEW_LINE INDENT return ( list . index ( value ) + 1 ) NEW_LINE DEDENT DEDENT DEDENT N = 10 NEW_LINE print ( findCount ( N ) ) NEW_LINE"],"bleu":0.5151735646567388,"rouge_l":0.7996853696906135}
{"id":908,"predictions":["from math import floor NEW_LINE def printfy ( n ) : NEW_LINE INDENT x1 , y1 , x2 , y2 = 1 , 1 , n NEW_LINE print ( x1 , y1 , x2 , y2 ) NEW_LINE x1 , y2 = 0 , 0 NEW_LINE while y != 1 : NEW_LINE INDENT x = floor ( y1 + n ) \/ y1 NEW_LINE x1 = floor ( ( y1 + n ) \/ y1 ) * y1 - y2 NEW_LINE y = floor ( ( y1 + n ) \/ y2 ) * y1 - y1 NEW_LINE print ( \" { 0 : . 6 \/ { 0 : 2 } \/ { 1 : 0 } \" . format ( x1 , y1 ) ) NEW_LINE x1 = x1 NEW_LINE y1 = y2 + y NEW_LINE y2 = y2 - y NEW_LINE DEDENT DEDENT n = 7 NEW_LINE print ( \" Firsty ▁ Sequence ▁ of ▁ order ▁ of ▁ order ▁ of ▁ order ▁ \" + str ( n ) + \" ▁ is \" , 6y ( n ) ) NEW_LINE"],"references":["import math NEW_LINE def farey ( n ) : NEW_LINE INDENT x1 = 0 ; NEW_LINE y1 = 1 ; NEW_LINE x2 = 1 ; NEW_LINE y2 = n ; NEW_LINE print ( x1 , end = \" \" ) NEW_LINE print ( \" \/ \" , end = \" \" ) NEW_LINE print ( y1 , x2 , end = \" \" ) NEW_LINE print ( \" \/ \" , end = \" \" ) NEW_LINE print ( y2 , end = \" ▁ \" ) ; NEW_LINE x = 0 ; NEW_LINE y = 0 ; NEW_LINE while ( y != 1.0 ) : NEW_LINE INDENT x = math . floor ( ( y1 + n ) \/ y2 ) * x2 - x1 ; NEW_LINE y = math . floor ( ( y1 + n ) \/ y2 ) * y2 - y1 ; NEW_LINE print ( x , end = \" \" ) NEW_LINE print ( \" \/ \" , end = \" \" ) NEW_LINE print ( y , end = \" ▁ \" ) ; NEW_LINE x1 = x2 ; NEW_LINE x2 = x ; NEW_LINE y1 = y2 ; NEW_LINE y2 = y ; NEW_LINE DEDENT DEDENT n = 7 ; NEW_LINE print ( \" Farey ▁ Sequence ▁ of ▁ order \" , n , \" is \" ) ; NEW_LINE farey ( n ) ; NEW_LINE"],"bleu":0.2678690329174696,"rouge_l":0.5201370384468976}
{"id":909,"predictions":["def fab_length ( image_distance , output_distance ) : NEW_LINE INDENT return 1 \/ ( ( 1 \/ image_distance ) + ( 1 \/ offset_distance ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT image_distance = 2 NEW_LINE output_length = 50 NEW_LINE print ( \" Fabl ▁ length ▁ of ▁ a ▁ lens ▁ is \" , fab_length ( image_distance , value_distance ) , \" uni . \" ) NEW_LINE DEDENT"],"references":["def focal_length ( image_distance , object_distance ) NEW_LINE INDENT : return 1 \/ ( ( 1 \/ image_distance ) + ( 1 \/ object_distance ) ) NEW_LINE DEDENT image_distance = 2 NEW_LINE object_distance = 50 NEW_LINE result = focal_length ( image_distance , object_distance ) NEW_LINE print ( \" Focal ▁ length ▁ of ▁ a ▁ lens ▁ is ▁ \" , result , \" ▁ units . \" ) NEW_LINE"],"bleu":0.462062378063783,"rouge_l":0.7000662105495475}
{"id":910,"predictions":["def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y % 2 == 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def findModuloByM ( X , N , M ) : NEW_LINE INDENT if ( N < 6 ) : NEW_LINE INDENT temp = \" \" NEW_LINE for i in range ( N ) : NEW_LINE INDENT temp = str ( X + chr ( X + 48 ) ) % M NEW_LINE DEDENT res = ( int ( res ) % M ) NEW_LINE return res NEW_LINE DEDENT if ( N % 2 == 0 ) : NEW_LINE INDENT half = findModuloByM ( X , N \/\/ 2 , M ) % M NEW_LINE res = ( half * power ( 10 , N \/\/ 2 , M ) + half ) % M NEW_LINE return res NEW_LINE DEDENT else : NEW_LINE INDENT half = findModuloByM ( X , N \/\/ 2 + 1 , M ) % M NEW_LINE res = ( half * power ( 10 , N \/\/ 2 + 1 , M ) % M ) % M NEW_LINE return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT X = 6 NEW_LINE N = 14 NEW_LINE M = 9 NEW_LINE print ( findModuloByM ( X , N , M ) ) NEW_LINE DEDENT"],"references":["def power ( x , y , p ) : NEW_LINE INDENT res = 1 ; NEW_LINE x = x % p ; NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y and 1 ) : NEW_LINE INDENT res = ( res * x ) % p ; NEW_LINE DEDENT y = y >> 1 ; NEW_LINE x = ( x * x ) % p ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT def findModuloByM ( X , N , M ) : NEW_LINE INDENT if ( N < 6 ) : NEW_LINE INDENT temp = chr ( 48 + X ) * N NEW_LINE res = int ( temp ) % M ; NEW_LINE return res ; NEW_LINE DEDENT if ( N % 2 == 0 ) : NEW_LINE INDENT half = findModuloByM ( X , N \/\/ 2 , M ) % M ; NEW_LINE res = ( half * power ( 10 , N \/\/ 2 , M ) + half ) % M ; NEW_LINE return res ; NEW_LINE DEDENT else : NEW_LINE INDENT half = findModuloByM ( X , N \/\/ 2 , M ) % M ; NEW_LINE res = ( half * power ( 10 , N \/\/ 2 + 1 , M ) + half * 10 + X ) % M ; NEW_LINE return res ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT X = 6 ; N = 14 ; M = 9 ; NEW_LINE print ( findModuloByM ( X , N , M ) ) ; NEW_LINE DEDENT"],"bleu":0.7063925511156169,"rouge_l":0.8712729869666131}
{"id":911,"predictions":["def getTotalXorOfSubarrayXors ( arr , N ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( i , N ) : NEW_LINE INDENT for k in range ( i , j + 1 ) : NEW_LINE INDENT res = res ^ arr [ k ] NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 5 , 2 , 4 , 6 ] NEW_LINE N = len ( arr ) NEW_LINE print ( getTotalXorOfSubarrayXors ( arr , N ) ) NEW_LINE DEDENT"],"references":["def getTotalXorOfSubarrayXors ( arr , N ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( i , N ) : NEW_LINE INDENT for k in range ( i , j + 1 ) : NEW_LINE INDENT res = res ^ arr [ k ] NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT arr = [ 3 , 5 , 2 , 4 , 6 ] NEW_LINE N = len ( arr ) NEW_LINE print ( getTotalXorOfSubarrayXors ( arr , N ) ) NEW_LINE"],"bleu":0.8620356297728585,"rouge_l":0.9452183440287995}
{"id":912,"predictions":["import math as mt NEW_LINE def innerCirclearea ( radius ) : NEW_LINE INDENT if ( radius < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT r = radius \/ 2 NEW_LINE Area = ( 3.14 * pow ( r , 2 ) ) NEW_LINE return Area NEW_LINE DEDENT radius = 4 NEW_LINE print ( \" Area ▁ of ▁ circle ▁ c2 ▁ = \" , innerCirclearea ( radius ) ) NEW_LINE"],"references":["def innerCirclearea ( radius ) : NEW_LINE INDENT if ( radius < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT r = radius \/ 2 ; NEW_LINE Area = ( 3.14 * pow ( r , 2 ) ) ; NEW_LINE return Area ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT radius = 4 ; NEW_LINE print ( \" Area ▁ of ▁ circle ▁ c2 ▁ = \" , innerCirclearea ( radius ) ) ; NEW_LINE DEDENT"],"bleu":0.6520523309575064,"rouge_l":0.8328056984566681}
{"id":913,"predictions":["def main ( ) : NEW_LINE INDENT P , R , T = 1 , 1 NEW_LINE II = 1 , 1 NEW_LINE SI = ( P * T * R ) \/ 100 NEW_LINE SI = ( P * T * R ) \/ 100 NEW_LINE print ( \" Simple ▁Interest ▁ = \" , SI ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"references":["P = 1 NEW_LINE R = 1 NEW_LINE T = 1 NEW_LINE SI = ( P * R * T ) \/ 100 NEW_LINE print ( \" simple ▁ interest ▁ is \" , SI ) NEW_LINE"],"bleu":0.24457731416149,"rouge_l":0.5390006093845217}
{"id":914,"predictions":["def findSubArr ( arr , n ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT if ( abs ( arr [ i ] - arr [ i + 1 ] ) >= 2 ) : NEW_LINE INDENT print ( arr [ i ] , arr [ i + 1 ] ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( - 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE findSubArr ( arr , n ) NEW_LINE DEDENT"],"references":["def findSubArr ( arr , n ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT if ( abs ( arr [ i ] - arr [ i + 1 ] ) >= 2 ) : NEW_LINE INDENT print ( arr [ i ] , arr [ i + 1 ] , end = \" \" ) ; NEW_LINE return ; NEW_LINE DEDENT DEDENT print ( - 1 ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 6 , 7 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE findSubArr ( arr , n ) ; NEW_LINE DEDENT"],"bleu":0.7866939704221978,"rouge_l":0.9283342556723854}
{"id":915,"predictions":["from math import ceil NEW_LINE def Min_Six ( n , k , a ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT ans = ceil ( sum \/ ( 100 ) ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE k = 3 NEW_LINE a = [ 200 , 150 , 140 , 300 ] NEW_LINE a . sort ( ) NEW_LINE print ( Min_xc ( n , k , a ) ) NEW_LINE DEDENT"],"references":["from math import ceil NEW_LINE def Min_glass ( n , k , a ) : NEW_LINE INDENT a . sort ( ) NEW_LINE return ceil ( sum ( a [ : k ] ) \/ 100 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n , k = 4 , 3 NEW_LINE a = [ 200 , 150 , 140 , 300 ] NEW_LINE print ( Min_glass ( n , k , a ) ) NEW_LINE DEDENT"],"bleu":0.5184899038656327,"rouge_l":0.7264448336252189}
{"id":916,"predictions":["import math NEW_LINE def findModulo ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE modulus = 0 NEW_LINE if ( s . find ( ' + ' ) == 0 ) : NEW_LINE INDENT i = s . find ( \" + \" ) NEW_LINE DEDENT else : NEW_LINE INDENT i = s . find ( \" - \" ) NEW_LINE DEDENT real = s [ : i ] NEW_LINE imaginary = s [ i + 1 : l - 1 ] NEW_LINE x = int ( real ) NEW_LINE y = int ( imaginary ) NEW_LINE print ( math . sqrt ( x * x + y * y * y ) ) NEW_LINE DEDENT s = \"3 + 4i \" NEW_LINE findModulo ( s ) NEW_LINE"],"references":["from math import sqrt NEW_LINE def findModulo ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE modulus = 0 NEW_LINE if ( ' + ' in s ) : NEW_LINE INDENT i = s . index ( ' + ' ) NEW_LINE DEDENT else : NEW_LINE INDENT i = s . index ( ' - ' ) NEW_LINE DEDENT real = s [ 0 : i ] NEW_LINE imaginary = s [ i + 1 : l - 1 ] NEW_LINE x = int ( real ) NEW_LINE y = int ( imaginary ) NEW_LINE print ( int ( sqrt ( x * x + y * y ) ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \"3 + 4i \" NEW_LINE findModulo ( s ) NEW_LINE DEDENT"],"bleu":0.708436676474384,"rouge_l":0.8231534090909092}
{"id":917,"predictions":["def printRepeating ( arr , size ) : NEW_LINE INDENT print ( \" The ▁ repeating ▁ elements ▁ are : ▁ \" ) NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT if arr [ abs ( arr [ i ] ) ] > 0 : NEW_LINE INDENT arr [ abs ( arr [ i ] ) ] = - arr [ abs ( arr [ i ] ) ] NEW_LINE DEDENT else : NEW_LINE INDENT print ( abs ( arr [ i ] ) , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 4 , 2 , 4 , 5 , 2 , 3 , 1 ] NEW_LINE arr_size = len ( arr ) NEW_LINE printRepeating ( arr , arr_size ) NEW_LINE"],"references":["def printRepeating ( arr , size ) : NEW_LINE INDENT print ( \" ▁ The ▁ repeating ▁ elements ▁ are \" , end = \" ▁ \" ) NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT if ( arr [ abs ( arr [ i ] ) ] > 0 ) : NEW_LINE INDENT arr [ abs ( arr [ i ] ) ] = ( - 1 ) * arr [ abs ( arr [ i ] ) ] NEW_LINE DEDENT else : NEW_LINE INDENT print ( abs ( arr [ i ] ) , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 4 , 2 , 4 , 5 , 2 , 3 , 1 ] NEW_LINE arr_size = len ( arr ) NEW_LINE printRepeating ( arr , arr_size ) NEW_LINE"],"bleu":0.8549831619885879,"rouge_l":0.9462921612410389}
{"id":918,"predictions":["def countZeros ( x ) : NEW_LINE INDENT n = 32 NEW_LINE y = x >> 16 NEW_LINE if ( y != 0 ) : NEW_LINE INDENT n = n - 16 NEW_LINE x = y NEW_LINE DEDENT y = x >> 8 NEW_LINE if ( y != 0 ) : NEW_LINE INDENT n = n - 8 NEW_LINE x = y NEW_LINE DEDENT y = x >> 4 NEW_LINE if ( y != 0 ) : NEW_LINE INDENT n = n - 4 NEW_LINE x = y NEW_LINE DEDENT y = x >> 2 NEW_LINE if ( y != 0 ) : NEW_LINE INDENT n = n - 2 NEW_LINE x = y NEW_LINE DEDENT y = x >> 1 NEW_LINE if ( y != 0 ) : NEW_LINE INDENT n = n - 2 NEW_LINE x = y NEW_LINE DEDENT y = x >> 1 NEW_LINE if ( y != 0 ) : NEW_LINE INDENT return n - 2 NEW_LINE DEDENT return n - x NEW_LINE DEDENT x = 101 NEW_LINE print ( countZeros ( x ) ) NEW_LINE"],"references":["def countZeros ( x ) : NEW_LINE INDENT n = 32 ; NEW_LINE y = x >> 16 ; NEW_LINE if ( y != 0 ) : NEW_LINE INDENT n = n - 16 ; NEW_LINE x = y ; NEW_LINE DEDENT y = x >> 8 ; NEW_LINE if ( y != 0 ) : NEW_LINE INDENT n = n - 8 ; NEW_LINE x = y ; NEW_LINE DEDENT y = x >> 4 ; NEW_LINE if ( y != 0 ) : NEW_LINE INDENT n = n - 4 ; NEW_LINE x = y ; NEW_LINE DEDENT y = x >> 2 ; NEW_LINE if ( y != 0 ) : NEW_LINE INDENT n = n - 2 ; NEW_LINE x = y ; NEW_LINE DEDENT y = x >> 1 ; NEW_LINE if ( y != 0 ) : NEW_LINE INDENT return n - 2 ; NEW_LINE DEDENT return n - x ; NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT x = 101 ; NEW_LINE print ( countZeros ( x ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"bleu":0.6535705205007295,"rouge_l":0.8113790440229983}
{"id":919,"predictions":["def pairORSum ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , 32 ) : NEW_LINE INDENT k1 , k0 = 0 , 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ j ] & ( 1 << i ) ) : NEW_LINE INDENT k1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT k0 += 1 NEW_LINE DEDENT DEDENT ans = ans + ( 1 << i ) * ( k1 - 1 ) \/\/ 2 ) + ( 1 << i ) * ( k1 * k0 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( pairORSum ( arr , n ) ) NEW_LINE"],"references":["def pairORSum ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , 32 ) : NEW_LINE INDENT k1 = 0 NEW_LINE k0 = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( ( arr [ j ] & ( 1 << i ) ) ) : NEW_LINE INDENT k1 = k1 + 1 NEW_LINE DEDENT else : NEW_LINE INDENT k0 = k0 + 1 NEW_LINE DEDENT DEDENT ans = ans + ( 1 << i ) * ( k1 * ( k1 - 1 ) \/\/ 2 ) + ( 1 << i ) * ( k1 * k0 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( pairORSum ( arr , n ) ) NEW_LINE"],"bleu":0.8644903415193251,"rouge_l":0.930002225684398}
{"id":920,"predictions":["def binaryToDecimal ( n ) : NEW_LINE INDENT num = n NEW_LINE dec_value = 0 NEW_LINE base = 1 NEW_LINE l = len ( num ) NEW_LINE for i in range ( l - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( num [ i ] == '1' ) : NEW_LINE INDENT dec_value += base NEW_LINE DEDENT base = base * 2 NEW_LINE DEDENT return dec_value NEW_LINE DEDENT num = \"10101001\" NEW_LINE print ( binaryToDecimal ( num ) ) NEW_LINE"],"references":["def binaryToDecimal ( n ) : NEW_LINE INDENT num = n ; NEW_LINE dec_value = 0 ; NEW_LINE base1 = 1 ; NEW_LINE len1 = len ( num ) ; NEW_LINE for i in range ( len1 - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( num [ i ] == '1' ) : NEW_LINE INDENT dec_value += base1 ; NEW_LINE DEDENT base1 = base1 * 2 ; NEW_LINE DEDENT return dec_value ; NEW_LINE DEDENT num = \"10101001\" ; NEW_LINE print ( binaryToDecimal ( num ) ) ; NEW_LINE"],"bleu":0.6382427986525725,"rouge_l":0.8747504084225814}
{"id":921,"predictions":["def countStrings ( n , k ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE dp [ 1 ] [ 0 ] = 1 NEW_LINE dp [ 1 ] [ 0 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , i and j < k + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j ] NEW_LINE dp [ i ] [ j ] = dp [ i - 1 ] [ j ] NEW_LINE if ( j - 1 >= 0 ) : NEW_LINE INDENT dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ 0 ] + dp [ n ] [ k ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE k = 2 NEW_LINE print ( countStrings ( n , k ) ) NEW_LINE DEDENT"],"references":["def countStrings ( n , k ) : NEW_LINE INDENT dp = [ [ [ 0 , 0 ] for __ in range ( k + 1 ) ] for _ in range ( n + 1 ) ] NEW_LINE dp [ 1 ] [ 0 ] [ 0 ] = 1 NEW_LINE dp [ 1 ] [ 0 ] [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( k + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] [ 0 ] = ( dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] ) NEW_LINE dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ] NEW_LINE if j >= 1 : NEW_LINE INDENT dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] [ 1 ] NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE k = 2 NEW_LINE print ( countStrings ( n , k ) ) NEW_LINE DEDENT"],"bleu":0.7775228264144323,"rouge_l":0.8800721370604146}
{"id":922,"predictions":["import sys NEW_LINE def print2largest ( arr , arr_size ) : NEW_LINE INDENT if ( arr_size < 2 ) : NEW_LINE INDENT print ( \" ▁ Invalid ▁ Input ▁ \" ) NEW_LINE return NEW_LINE DEDENT first = - sys . maxsize NEW_LINE first = - sys . maxsize - 1 NEW_LINE for i in range ( arr_size ) : NEW_LINE INDENT if ( arr [ i ] > first ) : NEW_LINE INDENT first = first NEW_LINE first = first NEW_LINE first = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > second and arr [ i ] != first ) : NEW_LINE INDENT second = arr [ i ] NEW_LINE DEDENT DEDENT if ( second == - sys . maxsize ) : NEW_LINE INDENT print ( \" The ▁ is ▁ no ▁ second ▁ largest ▁ element ▁ is ▁ \" , second ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" The ▁ secon ▁ element ▁ is ▁ \" , second ) NEW_LINE DEDENT DEDENT arr = [ 2 , 5 , 1 , 10 , 4 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print2largest ( arr , n ) NEW_LINE"],"references":["def print2largest ( arr , arr_size ) : NEW_LINE INDENT if ( arr_size < 2 ) : NEW_LINE INDENT print ( \" ▁ Invalid ▁ Input ▁ \" ) NEW_LINE return NEW_LINE DEDENT first = second = - 2147483648 NEW_LINE for i in range ( arr_size ) : NEW_LINE INDENT if ( arr [ i ] > first ) : NEW_LINE INDENT second = first NEW_LINE first = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > second and arr [ i ] != first ) : NEW_LINE INDENT second = arr [ i ] NEW_LINE DEDENT DEDENT if ( second == - 2147483648 ) : NEW_LINE INDENT print ( \" There ▁ is ▁ no ▁ second ▁ largest ▁ element \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" The ▁ second ▁ largest ▁ element ▁ is \" , second ) NEW_LINE DEDENT DEDENT arr = [ 12 , 35 , 1 , 10 , 34 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print2largest ( arr , n ) NEW_LINE"],"bleu":0.7602059460427367,"rouge_l":0.895756851361735}
{"id":923,"predictions":["def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def print_gcd_cb ( n , m , query , arr ) : NEW_LINE INDENT max_gcd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT max_gcd = gcd ( max_gcd , arr [ i ] ) NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT query [ i ] [ 0 ] -= 1 NEW_LINE arr [ query [ i ] [ 0 ] = int ( query [ query [ i ] [ 0 ] ] ) NEW_LINE max_gcd = gcd ( arr [ query [ i ] [ 0 ] ] , max_gcd ) NEW_LINE print ( max_gcd ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE m = 3 NEW_LINE query = [ [ 2 ] * 2 NEW_LINE query [ 0 ] [ 1 ] = 3 NEW_LINE query [ 1 ] [ 0 ] = 3 NEW_LINE query [ 0 ] [ 1 ] = 3 NEW_LINE query [ 1 ] [ 0 ] = 12 NEW_LINE query [ 1 ] [ 0 ] = 2 NEW_LINE query [ 2 ] [ 1 ] = 2 NEW_LINE query [ 2 ] [ 1 ] = 3 NEW_LINE query [ 2 ] [ 0 ] = 2 NEW_LINE query [ 2 ] [ 1 ] = 4 NEW_LINE print_gcd_cb ( n , m , query , arr ) NEW_LINE DEDENT"],"references":["def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def print_gcd_online ( n , m , query , arr ) : NEW_LINE INDENT max_gcd = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT max_gcd = gcd ( max_gcd , arr [ i ] ) NEW_LINE DEDENT for i in range ( 0 , m ) : NEW_LINE INDENT query [ i ] [ 0 ] -= 1 NEW_LINE arr [ query [ i ] [ 0 ] ] \/\/= query [ i ] [ 1 ] NEW_LINE max_gcd = gcd ( arr [ query [ i ] [ 0 ] ] , max_gcd ) NEW_LINE print ( max_gcd ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n , m = 3 , 3 NEW_LINE query = [ [ 1 , 3 ] , [ 3 , 12 ] , [ 2 , 4 ] ] NEW_LINE arr = [ 36 , 24 , 72 ] NEW_LINE print_gcd_online ( n , m , query , arr ) NEW_LINE DEDENT"],"bleu":0.5516858770165687,"rouge_l":0.7669740150880134}
{"id":924,"predictions":["def countSubstr ( str , n , x , y ) : NEW_LINE INDENT tot_count = 0 NEW_LINE count_x = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str [ i ] == x ) : NEW_LINE INDENT count_x += 1 NEW_LINE DEDENT if ( str [ i ] == y ) : NEW_LINE INDENT tot_count += count_x NEW_LINE DEDENT DEDENT return tot_count NEW_LINE DEDENT str = \" abbc spaceghcak \" NEW_LINE n = len ( str ) NEW_LINE x = ' a ' NEW_LINE y = ' c ' NEW_LINE print ( \" Count ▁ = \" , int ( countSubstr ( str , n , x , y ) ) ) NEW_LINE"],"references":["def countSubstr ( str , n , x , y ) : NEW_LINE INDENT tot_count = 0 NEW_LINE count_x = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if str [ i ] == x : NEW_LINE INDENT count_x += 1 NEW_LINE DEDENT if str [ i ] == y : NEW_LINE INDENT tot_count += count_x NEW_LINE DEDENT DEDENT return tot_count NEW_LINE DEDENT str = ' abbcaceghcak ' NEW_LINE n = len ( str ) NEW_LINE x , y = ' a ' , ' c ' NEW_LINE print ( ' Count ▁ = ' , countSubstr ( str , n , x , y ) ) NEW_LINE"],"bleu":0.747921383409174,"rouge_l":0.9021615472127418}
{"id":925,"predictions":["def centered_ cube ( n ) : NEW_LINE INDENT return ( 2 * n + 1 ) * ( n * n + n + 1 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE print ( n , \" th ▁ Centered \" + \" cube ▁ number : ▁ \" , centered_ cube_ cube ( n ) ) NEW_LINE DEDENT"],"references":["def centered_cube ( n ) : NEW_LINE INDENT return ( 2 * n + 1 ) * ( n * n + n + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE print ( n , \" th ▁ Centered ▁ cube ▁ \" + \" number ▁ : ▁ \" , centered_cube ( n ) ) NEW_LINE n = 10 NEW_LINE print ( n , \" th ▁ Centered ▁ cube ▁ \" + \" number ▁ : ▁ \" , centered_cube ( n ) ) NEW_LINE DEDENT"],"bleu":0.5596883354016187,"rouge_l":0.7511771097428468}
{"id":926,"predictions":["import math NEW_LINE MAX = 10000 ; NEW_LINE primes = [ ] ; NEW_LINE def sieveSundaram ( ) : NEW_LINE INDENT marked = [ False ] * int ( math . sqrt ( MAX ) \/ 2 ) ; NEW_LINE for i in range ( 1 , int ( math . sqrt ( MAX ) - 1 ) \/ 2 + 1 , 2 ) : NEW_LINE INDENT for j in range ( ( i * ( i + 1 ) ) << 1 , int ( MAX \/ 2 ) + 1 ) : NEW_LINE INDENT marked [ j ] = True ; NEW_LINE DEDENT DEDENT primes . append ( 2 ) ; NEW_LINE for i in range ( 1 , int ( MAX \/ 2 ) + 1 ) : NEW_LINE INDENT if ( marked [ i ] == False ) : NEW_LINE INDENT primes . append ( 2 * i + 1 ) ; NEW_LINE DEDENT DEDENT DEDENT def findPrimes ( n ) : NEW_LINE INDENT if ( n <= 2 or n % 2 != 0 ) : NEW_LINE INDENT print ( \" Invalid ▁ Input ▁ \" ) ; NEW_LINE return ; NEW_LINE DEDENT for i in range ( 0 , int ( int ( math . sqrt ( 2 ) ) ) + 1 ) : NEW_LINE INDENT diff = n - primes [ i ] ; NEW_LINE if ( pair [ i ] == False ) : NEW_LINE INDENT print ( primes [ i ] , \" + \" , diff , \" ▁ = \" , n ) ; NEW_LINE return 0 ; NEW_LINE DEDENT DEDENT findPrimes ( 4 ) ; NEW_LINE findPrimes ( 4 ) ; NEW_LINE findPrimes ( 38 ) ; NEW_LINE findPrimes ( 7 ) ; NEW_LINE"],"references":["import math NEW_LINE MAX = 10000 ; NEW_LINE primes = [ ] ; NEW_LINE def sieveSundaram ( ) : NEW_LINE INDENT marked = [ False ] * ( int ( MAX \/ 2 ) + 100 ) ; NEW_LINE for i in range ( 1 , int ( ( math . sqrt ( MAX ) - 1 ) \/ 2 ) + 1 ) : NEW_LINE INDENT for j in range ( ( i * ( i + 1 ) ) << 1 , int ( MAX \/ 2 ) + 1 , 2 * i + 1 ) : NEW_LINE INDENT marked [ j ] = True ; NEW_LINE DEDENT DEDENT primes . append ( 2 ) ; NEW_LINE for i in range ( 1 , int ( MAX \/ 2 ) + 1 ) : NEW_LINE INDENT if ( marked [ i ] == False ) : NEW_LINE INDENT primes . append ( 2 * i + 1 ) ; NEW_LINE DEDENT DEDENT DEDENT def findPrimes ( n ) : NEW_LINE INDENT if ( n <= 2 or n % 2 != 0 ) : NEW_LINE INDENT print ( \" Invalid ▁ Input \" ) ; NEW_LINE return ; NEW_LINE DEDENT i = 0 ; NEW_LINE while ( primes [ i ] <= n \/\/ 2 ) : NEW_LINE INDENT diff = n - primes [ i ] ; NEW_LINE if diff in primes : NEW_LINE INDENT print ( primes [ i ] , \" + \" , diff , \" = \" , n ) ; NEW_LINE return ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT DEDENT sieveSundaram ( ) ; NEW_LINE findPrimes ( 4 ) ; NEW_LINE findPrimes ( 38 ) ; NEW_LINE findPrimes ( 100 ) ; NEW_LINE"],"bleu":0.8277978356233548,"rouge_l":0.8794499279139404}
{"id":927,"predictions":["N = 100005 NEW_LINE d = [ 0 for i in range ( N ) ] NEW_LINE pre = [ 0 for i in range ( N ) ] NEW_LINE def Positive_Divisors ( ) : NEW_LINE INDENT for i in range ( 1 , N ) : NEW_LINE INDENT j = 1 NEW_LINE while ( j * j <= i ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT if ( j * j == i ) : NEW_LINE INDENT d [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ i ] += 2 NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT if ( d [ i ] == d [ i - 1 ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT pre [ i ] = ans NEW_LINE DEDENT DEDENT Positive_Divisors ( ) NEW_LINE n = 15 NEW_LINE print ( pre [ n ] ) NEW_LINE"],"references":["from math import sqrt ; NEW_LINE N = 100005 NEW_LINE d = [ 0 ] * N NEW_LINE pre = [ 0 ] * N NEW_LINE def Positive_Divisors ( ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( 1 , int ( sqrt ( i ) ) + 1 ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT if ( j * j == i ) : NEW_LINE INDENT d [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ i ] += 2 NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT if ( d [ i ] == d [ i - 1 ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT pre [ i ] = ans NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT Positive_Divisors ( ) NEW_LINE n = 15 NEW_LINE print ( pre [ n ] ) NEW_LINE DEDENT"],"bleu":0.773079265935077,"rouge_l":0.829288321167883}
{"id":928,"predictions":["def leibniles ( n ) : NEW_LINE INDENT C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , min ( i , n ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( \"1 \/ { } \" . format ( i * C [ i - 1 ] [ j - 1 ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( \" \\n \" , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 NEW_LINE leibonicHarmonicTriangle ( n ) NEW_LINE DEDENT"],"references":["def LeibnizHarmonicTriangle ( n ) : NEW_LINE INDENT C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] ; NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , min ( i , n ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) ; NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( \"1 \/ \" , end = \" \" ) ; NEW_LINE print ( i * C [ i - 1 ] [ j - 1 ] , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( ) ; NEW_LINE DEDENT DEDENT LeibnizHarmonicTriangle ( 4 ) ; NEW_LINE"],"bleu":0.8082380989785977,"rouge_l":0.8876387638763876}
{"id":929,"predictions":["def ansQueries ( prefeven , prefodd , l , r , q ) : NEW_LINE INDENT if ( r - l + 1 ) % 2 == 0 : NEW_LINE INDENT print ( \"0\" ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT if ( l % 2 == 0 ) : NEW_LINE INDENT print ( prefeverse [ r ] ^ preorder [ l - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( prefodd [ r ] ^ prefodd [ l - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT def wrapper ( arr , n , l , r , q ) : NEW_LINE INDENT prefodd = [ 0 ] * 100 NEW_LINE prefeven = [ 0 ] * 100 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT preTerven [ i ] = arr [ i - 1 ] ^ prefeven [ i - 1 ] NEW_LINE prefodd [ i ] = prefodd [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT prefeven [ i ] = preFlven [ i - 1 ] NEW_LINE prefodd [ i ] = prefodd [ i - 1 ] ^ arr [ i - 1 ] NEW_LINE DEDENT DEDENT i = 0 NEW_LINE while ( i != q ) : NEW_LINE INDENT ansQueries ( prefe , prefodd , l [ i ] , r [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE l = [ 1 , 1 , 2 ] NEW_LINE r = len ( arr ) NEW_LINE wrapper ( arr , n , l , r , q ) NEW_LINE"],"references":["N = 100 NEW_LINE def ansQueries ( prefeven , prefodd , l , r ) : NEW_LINE INDENT if ( ( r - l + 1 ) % 2 == 0 ) : NEW_LINE INDENT print ( \"0\" ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( l % 2 == 0 ) : NEW_LINE INDENT print ( prefeven [ r ] ^ prefeven [ l - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( prefodd [ r ] ^ prefodd [ l - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT def wrapper ( arr , n , l , r , q ) : NEW_LINE INDENT prefodd = [ 0 ] * N NEW_LINE prefeven = [ 0 ] * N NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( ( i ) % 2 == 0 ) : NEW_LINE INDENT prefeven [ i ] = arr [ i - 1 ] ^ prefeven [ i - 1 ] NEW_LINE prefodd [ i ] = prefodd [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT prefeven [ i ] = prefeven [ i - 1 ] NEW_LINE prefodd [ i ] = prefodd [ i - 1 ] ^ arr [ i - 1 ] NEW_LINE DEDENT DEDENT i = 0 NEW_LINE while ( i != q ) : NEW_LINE INDENT ansQueries ( prefeven , prefodd , l [ i ] , r [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE l = [ 1 , 1 , 2 ] NEW_LINE r = [ 2 , 3 , 4 ] NEW_LINE q = len ( l ) NEW_LINE wrapper ( arr , n , l , r , q ) NEW_LINE DEDENT"],"bleu":0.8466606195978612,"rouge_l":0.9300832581001103}
{"id":930,"predictions":["def squaresum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( i * i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 NEW_LINE print ( squaresum ( n ) ) NEW_LINE DEDENT"],"references":["def squaresum ( n ) : NEW_LINE INDENT sm = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sm = sm + ( i * i ) NEW_LINE DEDENT return sm NEW_LINE DEDENT n = 4 NEW_LINE print ( squaresum ( n ) ) NEW_LINE"],"bleu":0.6266118414619197,"rouge_l":0.811491650155675}
{"id":931,"predictions":["MAX = 10 NEW_LINE def isFactorion ( n ) : NEW_LINE INDENT fact = [ 0 ] * MAX NEW_LINE fact [ 0 ] = 1 NEW_LINE for i in range ( 1 , MAX ) : NEW_LINE INDENT fact [ i ] = i * fact [ i - 1 ] NEW_LINE DEDENT org = n NEW_LINE sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT d = n % 10 NEW_LINE sum += fact [ d ] NEW_LINE n \/\/= 10 NEW_LINE DEDENT if ( sum == org ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT n = 40 NEW_LINE if ( isFactorion ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["MAX = 10 NEW_LINE def isFactorion ( n ) : NEW_LINE INDENT fact = [ 0 ] * MAX NEW_LINE fact [ 0 ] = 1 NEW_LINE for i in range ( 1 , MAX ) : NEW_LINE INDENT fact [ i ] = i * fact [ i - 1 ] NEW_LINE DEDENT org = n NEW_LINE sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT d = n % 10 NEW_LINE sum += fact [ d ] NEW_LINE n = n \/\/ 10 NEW_LINE DEDENT if ( sum == org ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT n = 40585 NEW_LINE if ( isFactorion ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.9502168115724619,"rouge_l":0.9774732930794241}
{"id":932,"predictions":["def minInsertions ( H , n , K ) : NEW_LINE INDENT inser = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT diff = abs ( H [ i ] - H [ i - 1 ] ) NEW_LINE if diff <= K : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT inser += math . ceil ( diff \/ K ) - 1 NEW_LINE DEDENT DEDENT return inser NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT H = [ 2 , 4 , 8 , 16 ] NEW_LINE K = 3 NEW_LINE n = len ( H ) NEW_LINE print ( minInsertions ( H , n , K ) ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def minInsertions ( H , n , K ) : NEW_LINE INDENT inser = 0 ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT diff = abs ( H [ i ] - H [ i - 1 ] ) ; NEW_LINE if ( diff <= K ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT else : NEW_LINE INDENT inser += math . ceil ( diff \/ K ) - 1 ; NEW_LINE DEDENT DEDENT return inser ; NEW_LINE DEDENT H = [ 2 , 4 , 8 , 16 ] ; NEW_LINE K = 3 ; NEW_LINE n = len ( H ) ; NEW_LINE print ( minInsertions ( H , n , K ) ) ; NEW_LINE"],"bleu":0.7515113011284674,"rouge_l":0.889763779527559}
{"id":933,"predictions":["def ReplaceElements ( arr , n ) : NEW_LINE INDENT X = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT X ^= arr [ i ] ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = X ^ arr [ i ] ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 3 , 3 , 5 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE ReplaceElements ( arr , n ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT"],"references":["def ReplaceElements ( arr , n ) : NEW_LINE INDENT X = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT X ^= arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = X ^ arr [ i ] NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 3 , 3 , 5 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE ReplaceElements ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.8621290426878425,"rouge_l":0.9772076061474343}
{"id":934,"predictions":["def makePalindrome ( string ) : NEW_LINE INDENT i , j = 0 , len ( string ) - 1 NEW_LINE while ( i <= j ) : NEW_LINE INDENT if ( string [ i ] == ' * ' and string [ j ] == ' * ' ) : NEW_LINE INDENT string [ i ] = ' a ' NEW_LINE string [ j ] = ' a ' NEW_LINE DEDENT elif ( string [ j ] == ' * ' ) : NEW_LINE INDENT string [ j ] = string [ i ] NEW_LINE string [ j ] = string [ j ] NEW_LINE DEDENT elif ( string [ i ] == ' * ' ) : NEW_LINE INDENT string [ i ] = string [ j ] NEW_LINE DEDENT elif string [ i ] != string [ j ] : NEW_LINE INDENT return \" - 1\" NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return string NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" ar * an \" NEW_LINE print ( makePalindrome ( string ) ) NEW_LINE DEDENT"],"references":["def makePalindrome ( str1 ) : NEW_LINE INDENT i = 0 NEW_LINE j = len ( str1 ) - 1 NEW_LINE str1 = list ( str1 ) NEW_LINE while ( i <= j ) : NEW_LINE INDENT if ( str1 [ i ] == ' * ' and str1 [ j ] == ' * ' ) : NEW_LINE INDENT str1 [ i ] = ' a ' NEW_LINE str1 [ j ] = ' a ' NEW_LINE DEDENT elif ( str1 [ j ] == ' * ' ) : NEW_LINE INDENT str1 [ j ] = str1 [ i ] NEW_LINE DEDENT elif ( str1 [ i ] == ' * ' ) : NEW_LINE INDENT str1 [ i ] = str1 [ j ] NEW_LINE DEDENT elif ( str1 [ i ] != str1 [ j ] ) : NEW_LINE INDENT str1 = ' ' . join ( str1 ) NEW_LINE return \" - 1\" NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT str1 = ' ' . join ( str1 ) NEW_LINE return str1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = \" na * an \" NEW_LINE print ( makePalindrome ( str1 ) ) NEW_LINE DEDENT"],"bleu":0.5666517006761669,"rouge_l":0.7845502476433935}
{"id":935,"predictions":["def countSubstr ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE auxArr = [ 0 ] * n NEW_LINE if ( s [ 0 ] == '1' ) : NEW_LINE INDENT auxArr [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT auxArr [ i ] = auxArr [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT auxArr [ i ] = auxArr [ i - 1 ] NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT count += auxArr [ i ] NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \"1101\" NEW_LINE print ( countSubstr ( s ) ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def countSubstr ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE auxArr = [ 0 for i in range ( n ) ] NEW_LINE if ( s [ 0 ] == '1' ) : NEW_LINE INDENT auxArr [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT auxArr [ i ] = auxArr [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT auxArr [ i ] = auxArr [ i - 1 ] NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT count += auxArr [ i ] NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT s = \"1101\" NEW_LINE print ( countSubstr ( s ) ) NEW_LINE"],"bleu":0.8733458336520917,"rouge_l":0.9205765696043339}
{"id":936,"predictions":["from collections import defaultdict NEW_LINE class Graph : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . graph = defaultdict ( list ) NEW_LINE DEDENT def addEdge ( self , u , v ) : NEW_LINE INDENT self . graph [ u ] . append ( v ) NEW_LINE DEDENT def BFS ( self ) : NEW_LINE INDENT nodes = [ None ] * V NEW_LINE q = deque ( ) NEW_LINE Queue . append ( s ) NEW_LINE while ( len ( nodes ) != 0 ) : NEW_LINE INDENT s = Queue ( ) NEW_LINE print ( s , end = ' ▁ ' ) NEW_LINE for i in graph [ s ] : NEW_LINE INDENT if ( not visited [ n ] ) : NEW_LINE INDENT visited [ n ] = True NEW_LINE Queue . get ( ) NEW_LINE DEDENT DEDENT DEDENT DEDENT g = Graph ( ) NEW_LINE g . addEdge ( 0 , 1 ) NEW_LINE g . addEdge ( 0 , 2 ) NEW_LINE g . addEdge ( 1 , 2 ) NEW_LINE g . addEdge ( 2 , 0 ) NEW_LINE g . addEdge ( 2 , 0 ) NEW_LINE g . addEdge ( 3 , 3 ) NEW_LINE g . addEdge ( 3 , 3 ) NEW_LINE print \" Following ▁ is ▁ SI ▁ First ▁ Traversal ▁ between ▁ vertex ▁ 2 ) NEW_LINE g . BFS ( 2 ) NEW_LINE"],"references":["from collections import defaultdict NEW_LINE class Graph : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . graph = defaultdict ( list ) NEW_LINE DEDENT def addEdge ( self , u , v ) : NEW_LINE INDENT self . graph [ u ] . append ( v ) NEW_LINE DEDENT def BFS ( self , s ) : NEW_LINE INDENT visited = [ False ] * ( len ( self . graph ) ) NEW_LINE queue = [ ] NEW_LINE queue . append ( s ) NEW_LINE visited [ s ] = True NEW_LINE while queue : NEW_LINE INDENT s = queue . pop ( 0 ) NEW_LINE print ( s , end = \" ▁ \" ) NEW_LINE for i in self . graph [ s ] : NEW_LINE INDENT if visited [ i ] == False : NEW_LINE INDENT queue . append ( i ) NEW_LINE visited [ i ] = True NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT g = Graph ( ) NEW_LINE g . addEdge ( 0 , 1 ) NEW_LINE g . addEdge ( 0 , 2 ) NEW_LINE g . addEdge ( 1 , 2 ) NEW_LINE g . addEdge ( 2 , 0 ) NEW_LINE g . addEdge ( 2 , 3 ) NEW_LINE g . addEdge ( 3 , 3 ) NEW_LINE print ( \" Following ▁ is ▁ Breadth ▁ First ▁ Traversal \" \" ▁ ( starting ▁ from ▁ vertex ▁ 2 ) \" ) NEW_LINE g . BFS ( 2 ) NEW_LINE"],"bleu":0.6909925094683121,"rouge_l":0.8066050026055237}
{"id":937,"predictions":["def vowel_calc ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE arr = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT arr [ i ] = n NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = ( n - i ) + arr [ i - 1 ] - i NEW_LINE DEDENT DEDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ch = s [ i ] NEW_LINE if ( ch == ' a ' or ch == ' e ' or ch == ' i ' or ch == ' u ' or ch == ' u ' ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT s = \" daceh \" NEW_LINE print ( vowel_calc ( s ) ) NEW_LINE"],"references":["def sumVowel ( string ) : NEW_LINE INDENT n = len ( string ) NEW_LINE sum = 0 NEW_LINE string = string . lower ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT s = string [ i ] NEW_LINE if ( s == \" a \" or s == \" e \" or s == \" i \" or s == \" o \" or s == \" u \" ) : NEW_LINE INDENT sum += ( ( n - i ) * ( i + 1 ) ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT string = \" abhay \" NEW_LINE print ( vovel ( string ) ) NEW_LINE DEDENT"],"bleu":0.29549450173715613,"rouge_l":0.5123691174778507}
{"id":938,"predictions":["def findOddPair ( A , N ) : NEW_LINE INDENT i , count = 0 , 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( A [ i ] % 2 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count * ( N - count ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 5 , 4 , 7 , 2 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( findOddPair ( a , n ) ) NEW_LINE DEDENT"],"references":["def findOddPair ( A , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( A [ i ] % 2 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count * ( N - count ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 5 , 4 , 7 , 2 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( findOddPair ( a , n ) ) NEW_LINE DEDENT"],"bleu":0.8909664221017727,"rouge_l":0.9645424053665547}
{"id":939,"predictions":["def smallestDivisor ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT i = 3 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT i += 2 NEW_LINE DEDENT return n NEW_LINE DEDENT n = 31 NEW_LINE print ( smallestDivisor ( n ) ) NEW_LINE"],"references":["def smallestDivisor ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return 2 ; NEW_LINE DEDENT i = 3 ; NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT i += 2 ; NEW_LINE DEDENT return n ; NEW_LINE DEDENT n = 31 ; NEW_LINE print ( smallestDivisor ( n ) ) ; NEW_LINE"],"bleu":0.7826575897870962,"rouge_l":0.947125472093999}
{"id":940,"predictions":["def areaOfKite ( d1 , d2 ) : NEW_LINE INDENT area = ( d1 * d2 ) \/ 2 NEW_LINE return area NEW_LINE DEDENT d1 = 4 NEW_LINE d2 = 6 NEW_LINE print ( \" Area ▁ of ▁ Kite ▁ = \" , round ( areaOfKite ( d1 , 2 ) , 2 ) ) NEW_LINE"],"references":["def areaOfKite ( d1 , d2 ) : NEW_LINE INDENT area = ( d1 * d2 ) \/ 2 ; NEW_LINE return area ; NEW_LINE DEDENT d1 = 4 ; NEW_LINE d2 = 6 ; NEW_LINE print ( \" Area ▁ of ▁ Kite ▁ = ▁ \" , areaOfKite ( d1 , d2 ) ) ; NEW_LINE"],"bleu":0.6751524803547836,"rouge_l":0.8855678906917165}
{"id":941,"predictions":["def isPossible ( v , str1 ) : NEW_LINE INDENT str1 = list ( str ) NEW_LINE for i in range ( len ( v ) - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , len ( v ) ) : NEW_LINE INDENT temp = v [ i ] + v [ j ] NEW_LINE temp = sortString ( temp ) NEW_LINE if temp > str1 : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" amazon \" NEW_LINE arr = [ \" fds \" , \" oxq \" , \" zoa \" , \" epw \" ] NEW_LINE if ( isPossible ( v , str1 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def isPossible ( v , string ) : NEW_LINE INDENT char_list = list ( string ) NEW_LINE char_list . sort ( ) NEW_LINE for i in range ( len ( v ) - 1 ) : NEW_LINE INDENT for j in range ( len ( v ) ) : NEW_LINE INDENT temp = v [ i ] + v [ j ] ; NEW_LINE temp_list = list ( temp ) NEW_LINE temp_list . sort ( ) NEW_LINE if ( temp_list == char_list ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT DEDENT return False ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" amazon \" ; NEW_LINE v = [ \" fds \" , \" oxq \" , \" zoa \" , \" epw \" , \" amn \" ] ; NEW_LINE if ( isPossible ( v , string ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"],"bleu":0.652266856249392,"rouge_l":0.8382851059711605}
{"id":942,"predictions":["def seriesSum ( n ) : NEW_LINE INDENT i = 1 NEW_LINE res = 0.0 NEW_LINE sign = True NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n -= 1 NEW_LINE if ( sign ) : NEW_LINE INDENT sign = not sign NEW_LINE res = res + sign NEW_LINE res = res + i \/ i NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT sign = not sign NEW_LINE res = res - int ( i \/ i ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT n = 5 NEW_LINE print ( seriesSum ( n ) ) NEW_LINE"],"references":["def seriesSum ( n ) : NEW_LINE INDENT i = 1 ; NEW_LINE res = 0.0 ; NEW_LINE sign = True ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n = n - 1 ; NEW_LINE if ( sign ) : NEW_LINE INDENT sign = False ; NEW_LINE res = res + ( i + 1 ) \/ ( i + 2 ) ; NEW_LINE i = i + 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT sign = True ; NEW_LINE res = res - ( i + 1 ) \/ ( i + 2 ) ; NEW_LINE i = i + 2 ; NEW_LINE DEDENT DEDENT return res ; NEW_LINE DEDENT n = 5 ; NEW_LINE print ( round ( seriesSum ( n ) , 6 ) ) ; NEW_LINE"],"bleu":0.43009442444563706,"rouge_l":0.7229027962716378}
{"id":943,"predictions":["MAX = 1000000 NEW_LINE sieve_Prime = [ 0 ] * ( MAX + 4 ) NEW_LINE sieve_count = [ 0 ] * ( MAX + 4 ) NEW_LINE sieve_count = [ 0 ] * ( MAX + 4 ) NEW_LINE def form_sieve ( ) : NEW_LINE INDENT sieve_Prime [ 1 ] = 1 NEW_LINE for i in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if ( sieve_Prime [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i * 2 , MAX + 1 , i ) : NEW_LINE INDENT if ( sieve_Prime [ j ] == 0 ) : NEW_LINE INDENT sieve_Prime [ j ] = 1 NEW_LINE sieve_count [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT form_sieve ( ) NEW_LINE n = 2 NEW_LINE print ( \" Count ▁ = \" , ( sort_sieve_count [ n ] + 1 ) ) NEW_LINE n = 3 NEW_LINE print ( \" Count ▁ = \" , ( find_sieve_count [ n ] + 1 ) ) NEW_LINE DEDENT"],"references":["MAX = 1000000 NEW_LINE sieve_Prime = [ 0 for i in range ( MAX + 4 ) ] NEW_LINE sieve_count = [ 0 for i in range ( MAX + 4 ) ] NEW_LINE def form_sieve ( ) : NEW_LINE INDENT sieve_Prime [ 1 ] = 1 NEW_LINE for i in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if sieve_Prime [ i ] == 0 : NEW_LINE INDENT for j in range ( i * 2 , MAX + 1 , i ) : NEW_LINE INDENT if sieve_Prime [ j ] == 0 : NEW_LINE INDENT sieve_Prime [ j ] = 1 NEW_LINE sieve_count [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT form_sieve ( ) NEW_LINE n = 2 NEW_LINE print ( \" Count ▁ = \" , sieve_count [ n ] + 1 ) NEW_LINE n = 3 NEW_LINE print ( \" Count ▁ = \" , sieve_count [ n ] + 1 ) NEW_LINE"],"bleu":0.6954517080736524,"rouge_l":0.8674891693350913}
{"id":944,"predictions":["N = 4 NEW_LINE def MaximumDecimalValue ( mat , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE if mat [ 0 ] [ 0 ] == 1 : NEW_LINE INDENT dp [ 0 ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if mat [ 0 ] [ i ] == 1 : NEW_LINE INDENT dp [ 0 ] [ i ] = ( dp [ 0 ] [ i - 1 ] + pow ( 2 , i ) ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if mat [ i ] [ 0 ] == 1 : NEW_LINE INDENT dp [ i ] [ 0 ] = ( dp [ i - 1 ] [ 0 ] + pow ( 2 , i ) ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n , 1 ) : NEW_LINE INDENT for j in range ( 1 , n , 1 ) : NEW_LINE INDENT if mat [ i ] [ j ] == 1 : NEW_LINE INDENT dp [ i ] [ j ] = ( max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) + pow ( 2 , i + j ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n - 1 ] [ n - 1 ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT mat = [ [ 1 , 1 , 0 , 1 ] , [ 0 , 1 , 0 ] , [ 1 , 0 , 1 ] , [ 1"],"references":["N = 4 NEW_LINE def MaximumDecimalValue ( mat , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE if ( mat [ 0 ] [ 0 ] == 1 ) : NEW_LINE INDENT dp [ 0 ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( mat [ 0 ] [ i ] == 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + 2 ** i NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( mat [ i ] [ 0 ] == 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + 2 ** i NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) + ( 2 ** ( i + j ) ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n - 1 ] [ n - 1 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT mat = [ [ 1 , 1 , 0 , 1 ] , [ 0 , 1 , 1 , 0 ] , [ 1 , 0 , 0 , 1 ] , [ 1 , 0 , 1 , 1 ] ] NEW_LINE print ( MaximumDecimalValue ( mat , 4 ) ) NEW_LINE DEDENT"],"bleu":0.8414801796009602,"rouge_l":0.9197843622066394}
{"id":945,"predictions":["MAX = 100 NEW_LINE def checkByyetric ( m , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( 0 , i ) : NEW_LINE INDENT if ( m [ i ] [ j ] != m [ j ] [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n - i ) : NEW_LINE INDENT if ( m [ i ] [ j ] != m [ n - j - 1 ] [ n - i - 1 ] [ n - i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE m = [ 1 , 2 , 3 ] , [ 2 , 5 , 2 ] , [ 3 , 2 , 1 ] ] NEW_LINE if ( checkBwy ( m , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def checkBisymmetric ( m , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , i ) : NEW_LINE INDENT if ( m [ i ] [ j ] != m [ j ] [ i ] ) : NEW_LINE INDENT return false NEW_LINE DEDENT DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n - i ) : NEW_LINE INDENT if ( m [ i ] [ j ] != m [ n - j - 1 ] [ n - i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True ; NEW_LINE DEDENT n = 3 ; NEW_LINE m = [ [ 1 , 2 , 3 ] , [ 2 , 5 , 2 ] , [ 3 , 2 , 1 ] ] NEW_LINE if ( checkBisymmetric ( m , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.8006126426513837,"rouge_l":0.9065389696169088}
{"id":946,"predictions":["import sys NEW_LINE def Divison ( a , n ) : NEW_LINE INDENT maxi = sys . maxsize ; NEW_LINE mini = sys . maxsize ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT maxi = max ( a [ i ] , maxi ) ; NEW_LINE mini = min ( a [ i ] , mini ) ; NEW_LINE DEDENT return int ( maxi \/ mini ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 3 , 7 , 9 , 3 , 11 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( Divison ( a , n ) ) ; NEW_LINE DEDENT"],"references":["def Divison ( a , n ) : NEW_LINE INDENT maxi = - 10 ** 9 NEW_LINE mini = 10 ** 9 NEW_LINE for i in a : NEW_LINE INDENT maxi = max ( i , maxi ) NEW_LINE mini = min ( i , mini ) NEW_LINE DEDENT return maxi \/\/ mini NEW_LINE DEDENT a = [ 3 , 7 , 9 , 3 , 11 ] NEW_LINE n = len ( a ) NEW_LINE print ( Divison ( a , n ) ) NEW_LINE"],"bleu":0.45048077461634,"rouge_l":0.7642369020501139}
{"id":947,"predictions":["MAX = 10 ; NEW_LINE F = [ [ 0 ] * MAX ] * MAX ; NEW_LINE C = [ 0 ] * MAX ; NEW_LINE def noOfAssignments ( S , n , i , c_x ) : NEW_LINE INDENT if ( F [ i ] [ c_x ] != - 1 ) : NEW_LINE INDENT return F [ i ] [ c_x ] ; NEW_LINE DEDENT if ( i == n ) : NEW_LINE INDENT if ( c_x == 1 ) : NEW_LINE INDENT F [ i ] [ c_x ] = 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT F [ i ] [ c_x ] = 1 ; NEW_LINE DEDENT c_y = C [ i ] - c_x ; NEW_LINE if ( S [ i ] == ' ( ' ) ' ) : NEW_LINE INDENT F [ i ] [ c_x ] =   \\ NEW_LINE INDENT noOfAssignments ( S , n , i + 1 , c_x + 1 ) +  \\ NEW_LINE noOfAssignments ( S , n , i + 1 , c_x ) ; NEW_LINE DEDENT return F [ i ] [ c_x ] ; NEW_LINE DEDENT F [ i ] [ c_x ] = 0 ; NEW_LINE if ( c_x == 1 ) : NEW_LINE INDENT F [ i ] [ c_x ] +=   \\ NEW_LINE INDENT noOfAssignments ( S , n , i + 1 , c_x - 1 ) ; NEW_LINE DEDENT if ( c_y == 1 ) : NEW_LINE INDENT F [ i ] [ c_x ] +=   \\ NEW_LINE INDENT noOfAssignments ( S , n , i + 1 , c_x ) ; NEW_LINE DEDENT DEDENT return F [ i ] [ c_x ] ; NEW_LINE DEDENT S = \" ( ) \" ; NEW_LINE n = len ( S ) ; NEW_LINE print ( noOfAssignments ( S , n , 0 , 0 ) ) ; NEW_LINE"],"references":["MAX = 10 NEW_LINE F = [ [ - 1 for i in range ( MAX ) ] for j in range ( MAX ) ] NEW_LINE C = [ None ] * MAX NEW_LINE def noOfAssignments ( S , n , i , c_x ) : NEW_LINE INDENT if F [ i ] [ c_x ] != - 1 : NEW_LINE INDENT return F [ i ] [ c_x ] NEW_LINE DEDENT if i == n : NEW_LINE INDENT F [ i ] [ c_x ] = not c_x NEW_LINE return F [ i ] [ c_x ] NEW_LINE DEDENT c_y = C [ i ] - c_x NEW_LINE if S [ i ] == ' ( ' : NEW_LINE INDENT F [ i ] [ c_x ] =   \\ NEW_LINE INDENT noOfAssignments ( S , n , i + 1 , c_x + 1 ) +   \\ NEW_LINE noOfAssignments ( S , n , i + 1 , c_x ) NEW_LINE DEDENT return F [ i ] [ c_x ] NEW_LINE DEDENT F [ i ] [ c_x ] = 0 NEW_LINE if c_x : NEW_LINE INDENT F [ i ] [ c_x ] +=   \\ NEW_LINE INDENT noOfAssignments ( S , n , i + 1 , c_x - 1 ) NEW_LINE DEDENT DEDENT if c_y : NEW_LINE INDENT F [ i ] [ c_x ] +=   \\ NEW_LINE INDENT noOfAssignments ( S , n , i + 1 , c_x ) NEW_LINE DEDENT DEDENT return F [ i ] [ c_x ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = \" ( ) \" NEW_LINE n = len ( S ) NEW_LINE C [ 0 ] = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if S [ i ] == ' ( ' : NEW_LINE INDENT C [ i + 1 ] = C [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i + 1 ] = C [ i ] - 1 NEW_LINE DEDENT DEDENT print ( noOfAssignments ( S , n , 0 , 0 ) ) NEW_LINE DEDENT"],"bleu":0.6351882629401681,"rouge_l":0.7695826979065575}
{"id":948,"predictions":["def nextPowerOf2 ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE if ( n and ( n & ( n - 1 ) ) == 0 ) : NEW_LINE INDENT return n ; NEW_LINE DEDENT while ( n ) : NEW_LINE INDENT n >>= 1 ; NEW_LINE count += 1 ; NEW_LINE DEDENT return 1 << count ; NEW_LINE DEDENT n = 0 ; NEW_LINE print ( nextPowerOf2 ( n ) ) ; NEW_LINE"],"references":["def nextPowerOf2 ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE if ( n and not ( n & ( n - 1 ) ) ) : NEW_LINE INDENT return n NEW_LINE DEDENT while ( n != 0 ) : NEW_LINE INDENT n >>= 1 NEW_LINE count += 1 NEW_LINE DEDENT return 1 << count ; NEW_LINE DEDENT n = 0 NEW_LINE print ( nextPowerOf2 ( n ) ) NEW_LINE"],"bleu":0.7617300387407743,"rouge_l":0.93699910952805}
{"id":949,"predictions":["def __gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return __gcd ( a - b , b ) NEW_LINE DEDENT return __gcd ( a , b - a ) NEW_LINE DEDENT def nthElement ( a , b , n ) : NEW_LINE INDENT lcm = ( a * b ) \/\/ __gcd ( a , b ) NEW_LINE l = 1 NEW_LINE r = min ( a , b ) * n NEW_LINE while ( l <= r ) : NEW_LINE INDENT mid = ( l + r ) >> 1 NEW_LINE val = int ( mid \/ a + mid \/ b ) NEW_LINE if ( val == n ) : NEW_LINE INDENT return max ( ( mid \/\/ a ) * a , ( mid \/\/ b ) * b ) NEW_LINE DEDENT if ( val < n ) : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = mid - 1 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT a = 5 NEW_LINE b = 3 NEW_LINE n = 5 NEW_LINE print ( nthElement ( a , b , n ) ) NEW_LINE"],"references":["import math NEW_LINE def nthElement ( a , b , n ) : NEW_LINE INDENT lcm = ( a * b ) \/ int ( math . gcd ( a , b ) ) NEW_LINE l = 1 NEW_LINE r = min ( a , b ) * n NEW_LINE while ( l <= r ) : NEW_LINE INDENT mid = ( l + r ) >> 1 NEW_LINE val = ( int ( mid \/ a ) + int ( mid \/ b ) - int ( mid \/ lcm ) ) NEW_LINE if ( val == n ) : NEW_LINE INDENT return int ( max ( int ( mid \/ a ) * a , int ( mid \/ b ) * b ) ) NEW_LINE DEDENT if ( val < n ) : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = mid - 1 NEW_LINE DEDENT DEDENT DEDENT a = 5 NEW_LINE b = 3 NEW_LINE n = 5 NEW_LINE print ( nthElement ( a , b , n ) ) NEW_LINE"],"bleu":0.6028829111097813,"rouge_l":0.7620670073821691}
{"id":950,"predictions":["MAX = 10000 ; NEW_LINE arr = [ ] ; NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime = [ True ] * ( MAX ) ; NEW_LINE p = 2 ; NEW_LINE while ( p * p < MAX ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT p += 1 ; NEW_LINE DEDENT def isEuclid ( n ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT arr . append ( p ) ; NEW_LINE DEDENT DEDENT def isEuclid ( n ) : NEW_LINE INDENT product = 1 ; NEW_LINE i = 0 ; NEW_LINE while ( product < n ) : NEW_LINE INDENT product = product * arr [ i ] ; NEW_LINE if ( product + 1 == n ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT SieveOfEratosthenes ( ) ; NEW_LINE n = 31 ; NEW_LINE if ( isEuclid ( n ) ) : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE DEDENT n = 42 ; NEW_LINE if ( isEuclid ( n ) ) : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE DEDENT"],"references":["MAX = 10000 NEW_LINE arr = [ ] NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime = [ True ] * MAX NEW_LINE p = 2 NEW_LINE while p * p < MAX : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT for p in range ( 2 , MAX ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT arr . append ( p ) NEW_LINE DEDENT DEDENT DEDENT def isEuclid ( n ) : NEW_LINE INDENT product = 1 NEW_LINE i = 0 NEW_LINE while ( product < n ) : NEW_LINE INDENT product = product * arr [ i ] NEW_LINE if ( product + 1 == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE n = 31 NEW_LINE if ( isEuclid ( n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT n = 42 NEW_LINE if ( isEuclid ( n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.7672627167779901,"rouge_l":0.9375820056232428}
{"id":951,"predictions":["def minElements ( arr , n ) : NEW_LINE INDENT halfSum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT halfSum = halfSum + arr [ i ] NEW_LINE DEDENT halfSum = halfSum \/\/ 2 NEW_LINE arr . sort ( ) NEW_LINE res = 0 NEW_LINE curr_sum = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT curr_sum += arr [ i ] NEW_LINE res += 1 NEW_LINE if curr_sum > halfSum : NEW_LINE INDENT return res NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT arr = [ 3 , 1 , 7 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minElements ( arr , n ) ) NEW_LINE"],"references":["def minElements ( arr , n ) : NEW_LINE INDENT halfSum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT halfSum = halfSum + arr [ i ] NEW_LINE DEDENT halfSum = int ( halfSum \/ 2 ) NEW_LINE arr . sort ( reverse = True ) NEW_LINE res = 0 NEW_LINE curr_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_sum += arr [ i ] NEW_LINE res += 1 NEW_LINE if curr_sum > halfSum : NEW_LINE INDENT return res NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT arr = [ 3 , 1 , 7 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minElements ( arr , n ) ) NEW_LINE"],"bleu":0.8814601346158436,"rouge_l":0.938340227507756}
{"id":952,"predictions":["def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def lcm ( a , b ) : NEW_LINE INDENT return ( a * b ) \/ gcd ( a , b ) NEW_LINE DEDENT a = 15 NEW_LINE b = 20 NEW_LINE if ( lcm ( a , b ) ) : NEW_LINE INDENT print ( \" LCM ▁ of ▁ \" , a , \" and \" , b , \" is \" , lcm ( a , b ) ) else : NEW_LINE print ( \" LCM ▁ of ▁ \" , a , \" and \" , b , \" is \" , lcm ( a , b ) ) NEW_LINE"],"references":["def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def lcm ( a , b ) : NEW_LINE INDENT return ( a * b ) \/ gcd ( a , b ) NEW_LINE DEDENT a = 15 NEW_LINE b = 20 NEW_LINE print ( ' LCM ▁ of ' , a , ' and ' , b , ' is ' , lcm ( a , b ) ) NEW_LINE"],"bleu":0.5391896449236984,"rouge_l":0.7778103473545361}
{"id":953,"predictions":["MAX = 1000005 ; NEW_LINE prime = [ True ] * MAX ; NEW_LINE def SieveOfEratosthenes ( prime ) : NEW_LINE INDENT prime [ 1 ] = False ; NEW_LINE prime [ 0 ] = False ; NEW_LINE for p in range ( MAX ) : NEW_LINE INDENT if ( p * p > MAX ) : NEW_LINE INDENT break ; NEW_LINE DEDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( 2 * p , MAX , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def prime_xor ( arr , n , k ) : NEW_LINE INDENT for i in range ( MAX ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] ) : NEW_LINE INDENT if ( ( i + 1 ) % k == 0 ) : NEW_LINE INDENT if ( ( i + 1 ) % k == 0 ) : NEW_LINE INDENT ans ^= arr [ i ] ; NEW_LINE DEDENT DEDENT DEDENT print ( ans ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 3 , 5 , 7 , 11 , 8 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE K = 2 ; NEW_LINE prime_xor ( arr , n , K ) ; NEW_LINE DEDENT"],"references":["MAX = 1000005 NEW_LINE def SieveOfEratosthenes ( prime ) : NEW_LINE INDENT prime [ 1 ] = False ; NEW_LINE prime [ 0 ] = False ; NEW_LINE for p in range ( 2 , int ( MAX ** ( 1 \/ 2 ) ) ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def prime_xor ( arr , n , k ) : NEW_LINE INDENT prime = [ True ] * MAX ; NEW_LINE SieveOfEratosthenes ( prime ) ; NEW_LINE ans = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] ) : NEW_LINE INDENT if ( ( i + 1 ) % k == 0 ) : NEW_LINE INDENT ans ^= arr [ i ] ; NEW_LINE DEDENT DEDENT DEDENT print ( ans ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 3 , 5 , 7 , 11 , 8 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE K = 2 ; NEW_LINE prime_xor ( arr , n , K ) ; NEW_LINE DEDENT"],"bleu":0.8135913276423425,"rouge_l":0.8351494830958368}
{"id":954,"predictions":["def computeTotient ( n ) : NEW_LINE INDENT phi = [ 0 ] * ( n + 1 ) ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT phi [ i ] = i ; NEW_LINE DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( phi [ p ] == p ) : NEW_LINE INDENT phi [ p ] = p - 1 ; NEW_LINE for i in range ( 2 * p , n + 1 , p ) : NEW_LINE INDENT phi [ i ] = ( phi [ i ] \/\/ p ) * ( p - 1 ) ; NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( \"otient ▁ of ▁ \" , i , \" is \" , phi [ i ] ) ; NEW_LINE DEDENT n = 12 ; NEW_LINE computeTotient ( n ) ; NEW_LINE"],"references":["def computeTotient ( n ) : NEW_LINE INDENT phi = [ ] NEW_LINE for i in range ( n + 2 ) : NEW_LINE INDENT phi . append ( 0 ) NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT phi [ i ] = i NEW_LINE DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( phi [ p ] == p ) : NEW_LINE INDENT phi [ p ] = p - 1 NEW_LINE for i in range ( 2 * p , n + 1 , p ) : NEW_LINE INDENT phi [ i ] = ( phi [ i ] \/\/ p ) * ( p - 1 ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( \" Totient ▁ of ▁ \" , i , \" ▁ is ▁ \" , phi [ i ] ) NEW_LINE DEDENT DEDENT n = 12 NEW_LINE computeTotient ( n ) NEW_LINE"],"bleu":0.7838182552576706,"rouge_l":0.9033648889305463}
{"id":955,"predictions":["def countDigit ( n ) : NEW_LINE INDENT temp = n NEW_LINE count = 0 NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT d = temp % 10 NEW_LINE temp \/= 10 NEW_LINE if ( d == 2 or d == 3 or d == 5 or d == 7 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT n = 1234567890 NEW_LINE print ( countDigit ( n ) ) NEW_LINE"],"references":["def countDigit ( n ) : NEW_LINE INDENT temp = n NEW_LINE count = 0 NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT d = temp % 10 NEW_LINE temp \/\/= 10 NEW_LINE if ( d == 2 or d == 3 or d == 5 or d == 7 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 1234567890 NEW_LINE print ( countDigit ( n ) ) NEW_LINE DEDENT"],"bleu":0.7918220087499696,"rouge_l":0.8926263778031168}
{"id":956,"predictions":["def getChar ( str ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT sum += ( ord ( str [ i ] ) - ord ( ' a ' ) + 1 ) NEW_LINE DEDENT if ( sum % 26 == 0 ) : NEW_LINE INDENT return ' z ' NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum % 26 NEW_LINE return chr ( ord ( ' a ' ) + sum - 1 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" gfg \" NEW_LINE print ( getChar ( str ) ) NEW_LINE DEDENT"],"references":["def getChar ( strr ) : NEW_LINE INDENT summ = 0 NEW_LINE for i in range ( len ( strr ) ) : NEW_LINE INDENT summ += ( ord ( strr [ i ] ) - ord ( ' a ' ) + 1 ) NEW_LINE DEDENT if ( summ % 26 == 0 ) : NEW_LINE INDENT return ord ( ' z ' ) NEW_LINE DEDENT else : NEW_LINE INDENT summ = summ % 26 NEW_LINE return chr ( ord ( ' a ' ) + summ - 1 ) NEW_LINE DEDENT DEDENT strr = \" gfg \" NEW_LINE print ( getChar ( strr ) ) NEW_LINE"],"bleu":0.5981673637173107,"rouge_l":0.8294517575582236}
{"id":957,"predictions":["def countWays ( n , arr ) : NEW_LINE INDENT count = [ 0 ] * ( n + 1 ) NEW_LINE count [ 0 ] = 1 NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT no_ways = 0 NEW_LINE for j in range ( l ) : NEW_LINE INDENT if ( i - arr [ j ] >= 0 ) : NEW_LINE INDENT no_ways += count [ i - arr [ j ] ] NEW_LINE DEDENT count [ i ] = no_ways NEW_LINE DEDENT DEDENT return count [ n ] NEW_LINE DEDENT arr = [ 1 , 3 , 5 ] NEW_LINE l = 5 NEW_LINE print ( countWays ( n , arr ) ) NEW_LINE"],"references":["def countWays ( n , arr ) : NEW_LINE INDENT count = [ 0 ] * ( n + 1 ) NEW_LINE count [ 0 ] = 1 NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT no_ways = 0 NEW_LINE for j in arr : NEW_LINE INDENT if ( i - j >= 0 ) : NEW_LINE INDENT no_ways += count [ i - j ] NEW_LINE DEDENT count [ i ] = no_ways NEW_LINE DEDENT DEDENT return count [ n ] NEW_LINE DEDENT arr = [ 1 , 3 , 5 ] NEW_LINE n = 5 NEW_LINE print ( countWays ( n , arr ) ) NEW_LINE"],"bleu":0.8667690267105108,"rouge_l":0.9568031868542263}
{"id":958,"predictions":["from collections import defaultdict NEW_LINE def primeOccurrence ( arr , k ) : NEW_LINE INDENT map = defaultdict ( lambda : 0 ) NEW_LINE for i in arr : NEW_LINE INDENT val = arr [ i ] NEW_LINE freq = defaultdict ( int ) NEW_LINE for key in map : NEW_LINE INDENT if ( value >= k ) : NEW_LINE INDENT print ( key ) NEW_LINE DEDENT DEDENT DEDENT def isPrime ( n ) : NEW_LINE INDENT if ( n > 2 and n % 2 == 0 ) or n == 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 3 , int ( ( math . sqrt ( n ) ) + 1 , 2 ) , 2 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 11 , 11 , 11 , 11 , 23 , 11 , 37 , 37 , 51 , 51 , 51 , 51 , 51 ] NEW_LINE k = 2 NEW_LINE primeOccurrence ( arr , k ) NEW_LINE"],"references":["def primeOccurences ( arr , k ) : NEW_LINE INDENT map = { } NEW_LINE for val in arr : NEW_LINE INDENT freq = 0 NEW_LINE if val in map : NEW_LINE INDENT freq = map [ val ] NEW_LINE freq += 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq = 1 NEW_LINE DEDENT map [ val ] = freq NEW_LINE DEDENT for entry in map : NEW_LINE INDENT value = map [ entry ] NEW_LINE if isPrime ( value ) and value >= k : NEW_LINE INDENT print ( entry ) NEW_LINE DEDENT DEDENT DEDENT def isPrime ( n ) : NEW_LINE INDENT if ( n > 2 and not n % 2 ) or n == 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 3 , int ( n ** 0.5 + 1 ) , 2 ) : NEW_LINE INDENT if not n % i : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT arr = [ 11 , 11 , 11 , 23 , 11 , 37 , 37 , 51 , 51 , 51 , 51 , 51 ] NEW_LINE k = 2 NEW_LINE primeOccurences ( arr , k ) NEW_LINE"],"bleu":0.5947991783316721,"rouge_l":0.7354749959540379}
{"id":959,"predictions":["def Nth_Term ( N ) : NEW_LINE INDENT return ( 3 * pow ( N , 2 ) - n + 2 ) \/\/ ( 2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 NEW_LINE print ( Nth_Term ( N ) ) NEW_LINE DEDENT"],"references":["def Nth_Term ( n ) : NEW_LINE INDENT return ( 3 * pow ( n , 2 ) - n + 2 ) \/\/ ( 2 ) NEW_LINE DEDENT N = 5 NEW_LINE print ( Nth_Term ( N ) ) NEW_LINE"],"bleu":0.6185325212848943,"rouge_l":0.8344440547176429}
{"id":960,"predictions":["import math NEW_LINE def sum ( n ) : NEW_LINE INDENT root = math . sqrt ( n ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , root + 1 ) : NEW_LINE INDENT ans += n \/ i NEW_LINE DEDENT ans = 2 * ans - ( root * root ) NEW_LINE return ans NEW_LINE DEDENT n = 35 NEW_LINE print ( sum ( n ) ) NEW_LINE"],"references":["import math NEW_LINE def sum ( n ) : NEW_LINE INDENT root = ( int ) ( math . sqrt ( n ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , root + 1 ) : NEW_LINE INDENT ans = ans + n \/\/ i NEW_LINE DEDENT ans = 2 * ans - ( root * root ) NEW_LINE return ans NEW_LINE DEDENT n = 35 NEW_LINE print ( sum ( n ) ) NEW_LINE"],"bleu":0.825300533363168,"rouge_l":0.9205100956429331}
{"id":961,"predictions":["import math ; NEW_LINE def isRandom biNum ( num ) : NEW_LINE INDENT binaryStr = str ( num ) ; NEW_LINE for i in range ( len ( binaryStr ) ) : NEW_LINE INDENT index = int ( binaryStr [ i ] ) ; NEW_LINE cnt = 0 ; NEW_LINE for j in range ( len ( negativeStr ) ) : NEW_LINE INDENT number = int ( binaryStr [ j ] ) + \" \" ) ; NEW_LINE if ( number == i ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT if ( cnt != index ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT return 1 ; NEW_LINE DEDENT def findCacheBios ( n ) : NEW_LINE INDENT flag = 0 ; NEW_LINE low = 10.0 ; NEW_LINE high = math . pow ( 10.0 , n ) - 1.0 ; NEW_LINE for i in range ( low , high + 1 ) : NEW_LINE INDENT if ( isRandomStr ( i ) ) : NEW_LINE INDENT flag = 1 ; NEW_LINE print ( i , end = \" , ▁ \" ) ; NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT print ( \" There ▁ is ▁ No ▁ and ▁ \" , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 ; NEW_LINE findAreaBios ( N ) ; NEW_LINE DEDENT"],"references":["from math import pow NEW_LINE def isAutoBio ( num ) : NEW_LINE INDENT autoStr = str ( num ) NEW_LINE for i in range ( 0 , len ( autoStr ) ) : NEW_LINE INDENT index = int ( autoStr [ i ] ) NEW_LINE cnt = 0 NEW_LINE for j in range ( 0 , len ( autoStr ) ) : NEW_LINE INDENT number = int ( autoStr [ j ] ) NEW_LINE if number == i : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if cnt != index : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def findAutoBios ( n ) : NEW_LINE INDENT low = int ( pow ( 10 , n - 1 ) ) NEW_LINE high = int ( pow ( 10 , n ) - 1 ) NEW_LINE flag = 0 NEW_LINE for i in range ( low , high + 1 ) : NEW_LINE INDENT if isAutoBio ( i ) : NEW_LINE INDENT flag = 1 NEW_LINE print ( i , end = ' , ▁ ' ) NEW_LINE DEDENT DEDENT if flag == 0 : NEW_LINE INDENT print ( \" There ▁ is ▁ no ▁ Autobiographical ▁ Number ▁ with ▁ \" + str ( n ) + \" ▁ digits \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 0 NEW_LINE findAutoBios ( N ) NEW_LINE N = 4 NEW_LINE findAutoBios ( N ) NEW_LINE DEDENT"],"bleu":0.5007913417474349,"rouge_l":0.7521479635338099}
{"id":962,"predictions":["def isLucky ( n ) : NEW_LINE INDENT arr = [ False ] * 10 ; NEW_LINE while ( n ) : NEW_LINE INDENT digit = n % 10 ; NEW_LINE if ( arr [ digit ] ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT arr [ digit ] = True ; NEW_LINE n = n \/\/ 10 ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1291 , 897 , 4566 , 80 , 700 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( isLucky ( arr [ i ] ) ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT"],"references":["import math NEW_LINE def isLucky ( n ) : NEW_LINE INDENT ar = [ 0 ] * 10 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT digit = math . floor ( n % 10 ) NEW_LINE if ( ar [ digit ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ar [ digit ] = 1 NEW_LINE n = n \/ 10 NEW_LINE DEDENT return 1 NEW_LINE DEDENT arr = [ 1291 , 897 , 4566 , 1232 , 80 , 700 ] NEW_LINE n = len ( arr ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT k = arr [ i ] NEW_LINE if ( isLucky ( k ) ) : NEW_LINE INDENT print ( k , \" ▁ is ▁ Lucky ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( k , \" ▁ is ▁ not ▁ Lucky ▁ \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.4771241035552331,"rouge_l":0.7247772201167676}
{"id":963,"predictions":["def printSeriesSum ( N ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT if ( i % 2 == 1 ) : NEW_LINE INDENT sum += i \/ ( i + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT sum -= i \/ ( i + 1 ) ; NEW_LINE DEDENT DEDENT print ( sum ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 10 ; NEW_LINE printSeriesSum ( N ) ; NEW_LINE DEDENT"],"references":["def printSeriesSum ( N ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( i & 1 ) : NEW_LINE INDENT sum += i \/ ( i + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT sum -= i \/ ( i + 1 ) ; NEW_LINE DEDENT DEDENT print ( sum ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 10 ; NEW_LINE printSeriesSum ( N ) ; NEW_LINE DEDENT"],"bleu":0.8841713064591955,"rouge_l":0.9484536082474226}
{"id":964,"predictions":["from math import gcd as __gcd NEW_LINE def power ( x , y , m ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT p = power ( x , int ( y \/ 2 , m ) ) % m NEW_LINE p = ( x * p ) % m NEW_LINE if ( y % 2 == 0 ) : NEW_LINE INDENT return p NEW_LINE DEDENT else : NEW_LINE INDENT return ( x * p ) % m NEW_LINE DEDENT DEDENT def modInverse ( a , m ) : NEW_LINE INDENT if ( __gcd ( a , m ) != 1 ) : NEW_LINE INDENT print ( \" Inverse ▁ doesn ' t ▁ exist \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Modular ▁ multiplicative ▁ inverse ▁ is \" , power ( a , m - 2 , m ) ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 3 NEW_LINE m = 16 NEW_LINE modInverse ( a , m ) NEW_LINE"],"references":["def __gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return __gcd ( b , a % b ) NEW_LINE DEDENT DEDENT def power ( x , y , m ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT p = power ( x , y \/\/ 2 , m ) % m NEW_LINE p = ( p * p ) % m NEW_LINE return p if ( y % 2 == 0 ) else ( x * p ) % m NEW_LINE DEDENT def modInverse ( a , m ) : NEW_LINE INDENT if ( __gcd ( a , m ) != 1 ) : NEW_LINE INDENT print ( \" Inverse ▁ doesn ' t ▁ exist \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Modular ▁ multiplicative ▁ inverse ▁ is ▁ \" , power ( a , m - 2 , m ) ) NEW_LINE DEDENT DEDENT a = 3 NEW_LINE m = 11 NEW_LINE modInverse ( a , m ) NEW_LINE"],"bleu":0.7642085936596058,"rouge_l":0.7889291257113294}
{"id":965,"predictions":["from math import gcd , sqrt NEW_LINE def countPrimeFactors ( x ) : NEW_LINE INDENT res = 0 ; NEW_LINE if ( x % 2 == 0 ) : NEW_LINE INDENT res += 1 ; NEW_LINE while ( x % 2 == 0 ) : NEW_LINE INDENT x = x \/\/ 2 ; NEW_LINE DEDENT DEDENT for i in range ( 3 , int ( sqrt ( x ) ) + 1 , 2 ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT res += 1 ; NEW_LINE while ( x % i == 0 ) : NEW_LINE INDENT x = int ( x \/ i ) ; NEW_LINE DEDENT DEDENT if ( x > 2 ) : NEW_LINE INDENT res += 1 ; NEW_LINE while ( x % i == 0 ) : NEW_LINE INDENT x = int ( x \/ i ) ; NEW_LINE DEDENT DEDENT if ( x > 2 ) : NEW_LINE INDENT res += 1 ; NEW_LINE while ( x % i == 0 ) : NEW_LINE INDENT x = int ( x \/ i ) ; NEW_LINE DEDENT DEDENT DEDENT if ( x > 2 ) : NEW_LINE INDENT res += 1 ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT a = 6 ; b = 12 ; NEW_LINE print ( countCommonPrimeFactors ( a , b ) ) ; NEW_LINE"],"references":["from math import sqrt , gcd NEW_LINE def countPrimeFactors ( x ) : NEW_LINE INDENT res = 0 NEW_LINE if ( x % 2 == 0 ) : NEW_LINE INDENT res += 1 NEW_LINE while ( x % 2 == 0 ) : NEW_LINE INDENT x = x \/ 2 NEW_LINE DEDENT DEDENT k = int ( sqrt ( x ) ) + 1 NEW_LINE for i in range ( 3 , k , 2 ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT res += 1 NEW_LINE while ( x % i == 0 ) : NEW_LINE INDENT x = x \/ i NEW_LINE DEDENT DEDENT DEDENT if ( x > 2 ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT def countCommonPrimeFactors ( a , b ) : NEW_LINE INDENT gcd__ = gcd ( a , b ) NEW_LINE return countPrimeFactors ( gcd__ ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 6 NEW_LINE b = 12 NEW_LINE print ( countCommonPrimeFactors ( a , b ) ) NEW_LINE DEDENT"],"bleu":0.5359744146356036,"rouge_l":0.7094145569620253}
{"id":966,"predictions":["def factorial ( n ) : NEW_LINE INDENT if n == 1 or n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return n * factorial ( n - 1 ) NEW_LINE DEDENT D = 5 ; NEW_LINE print ( \" Factorial ▁ of \" , num , \" is \" , factorial ( num ) ) NEW_LINE"],"references":["def factorial ( n ) : NEW_LINE INDENT return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 ) NEW_LINE DEDENT num = 5 NEW_LINE print ( \" Factorial ▁ of \" , num , \" is \" , factorial ( num ) ) NEW_LINE"],"bleu":0.7017692081043552,"rouge_l":0.8579465541490857}
{"id":967,"predictions":["def getFirstDigit ( x ) : NEW_LINE INDENT while ( x >= 10 ) : NEW_LINE INDENT x = x \/\/ 10 ; NEW_LINE DEDENT return x ; NEW_LINE DEDENT def getCountWithEndFrom1 ( x ) : NEW_LINE INDENT if ( x < 10 ) : NEW_LINE INDENT return x ; NEW_LINE DEDENT tens = x \/\/ 10 NEW_LINE res = tens + 9 ; NEW_LINE firstDigit = x % 10 ; NEW_LINE if ( lastDigit < firstDigit ) : NEW_LINE INDENT res -= 1 ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT def getCountWithSameStartAndEnd ( start , end ) : NEW_LINE INDENT return getCountWithSameStartAndEnd ( start , end ) - getCountWithSame1 ( start - 1 ) ; NEW_LINE DEDENT start = 5 ; NEW_LINE end = 40 ; NEW_LINE print ( getCountWithSameStartStartAndEnd ( start , end ) ) ; NEW_LINE"],"references":["def getFirstDigit ( x ) : NEW_LINE INDENT while ( x >= 10 ) : NEW_LINE INDENT x \/= 10 NEW_LINE DEDENT return x NEW_LINE DEDENT def getCountWithSameStartAndEndFrom1 ( x ) : NEW_LINE INDENT if ( x < 10 ) : NEW_LINE INDENT return x NEW_LINE DEDENT tens = x \/ 10 NEW_LINE res = tens + 9 NEW_LINE firstDigit = getFirstDigit ( x ) NEW_LINE lastDigit = x % 10 NEW_LINE if ( lastDigit < firstDigit ) : NEW_LINE INDENT res = res - 1 NEW_LINE DEDENT return res NEW_LINE DEDENT def getCountWithSameStartAndEnd ( start , end ) : NEW_LINE INDENT return ( getCountWithSameStartAndEndFrom1 ( end ) - getCountWithSameStartAndEndFrom1 ( start - 1 ) ) NEW_LINE DEDENT start = 5 NEW_LINE end = 40 NEW_LINE print ( getCountWithSameStartAndEnd ( start , end ) ) NEW_LINE"],"bleu":0.6481644475887192,"rouge_l":0.8573130061934253}
{"id":968,"predictions":["def find_number ( N , K ) : NEW_LINE INDENT if ( N % 100 == 0 ) : NEW_LINE INDENT N += 1 ; NEW_LINE r = str ( N ) ; NEW_LINE DEDENT else : NEW_LINE INDENT r = str ( N ) ; NEW_LINE DEDENT for i in range ( 1 , K + 1 ) : NEW_LINE INDENT r += \"00\" ; NEW_LINE DEDENT return r ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 1000 ; K = 2 ; NEW_LINE ans = find_number ( N , K ) ; NEW_LINE print ( ans ) ; NEW_LINE DEDENT"],"references":["def find_number ( N , K ) : NEW_LINE INDENT r = \" \" NEW_LINE if ( N % 100 == 0 ) : NEW_LINE INDENT N += 1 ; NEW_LINE r = str ( N ) NEW_LINE DEDENT else : NEW_LINE INDENT r = str ( N ) NEW_LINE DEDENT for i in range ( 1 , K + 1 ) : NEW_LINE INDENT r += \"00\" NEW_LINE DEDENT return r NEW_LINE DEDENT N = 1000 NEW_LINE K = 2 ; NEW_LINE ans = find_number ( N , K ) NEW_LINE print ( ans ) NEW_LINE"],"bleu":0.6993432477775635,"rouge_l":0.8822314049586776}
{"id":969,"predictions":["def digitSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT sum += n % 10 NEW_LINE n = n \/\/ 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT def totalPairs ( arr1 , arr2 , n , m ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( digitSum ( arr1 [ i ] ) == digitSum ( arr2 [ j ] ) ) : NEW_LINE INDENT s [ ( arr1 [ i ] , arr2 [ j ] ) ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT s [ ( arr2 [ j ] , arr1 [ i ] ) ] = 1 NEW_LINE DEDENT DEDENT DEDENT return len ( s ) NEW_LINE DEDENT arr1 = [ 100 , 3 , 7 , 50 ] NEW_LINE arr2 = [ 5 , 1 , 10 , 4 ] NEW_LINE n = len ( arr1 ) NEW_LINE m = len ( arr2 ) NEW_LINE print ( totalPairs ( arr1 , arr2 , n , m ) ) NEW_LINE"],"references":["def digitSum ( n ) : NEW_LINE INDENT Sum = 0 NEW_LINE while n > 0 : NEW_LINE INDENT Sum += n % 10 NEW_LINE n = n \/\/ 10 NEW_LINE DEDENT return Sum NEW_LINE DEDENT def totalPairs ( arr1 , arr2 , n , m ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , m ) : NEW_LINE INDENT if digitSum ( arr1 [ i ] ) == digitSum ( arr2 [ j ] ) : NEW_LINE INDENT if arr1 [ i ] < arr2 [ j ] : NEW_LINE INDENT s . add ( ( arr1 [ i ] , arr2 [ j ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT s . add ( ( arr2 [ j ] , arr1 [ i ] ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return len ( s ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr1 = [ 100 , 3 , 7 , 50 ] NEW_LINE arr2 = [ 5 , 1 , 10 , 4 ] NEW_LINE n = len ( arr1 ) NEW_LINE m = len ( arr2 ) NEW_LINE print ( totalPairs ( arr1 , arr2 , n , m ) ) NEW_LINE DEDENT"],"bleu":0.7231409109061551,"rouge_l":0.8544064203513023}
{"id":970,"predictions":["N = 5 NEW_LINE def func ( idx , cur , a , dp , n , x ) : NEW_LINE INDENT if ( idx == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ idx ] [ cur ] != - 1 ) : NEW_LINE INDENT return dp [ idx ] [ cur ] NEW_LINE DEDENT ans = 0 NEW_LINE if ( cur == 0 ) : NEW_LINE INDENT ans = max ( ans , a [ idx ] + func ( idx + 1 , 0 , a , dp , n , x ) ) NEW_LINE ans = max ( ans , x * a [ idx ] + func ( idx + 1 , 1 , a , dp , n , x ) ) NEW_LINE DEDENT elif ( cur == 1 ) : NEW_LINE INDENT ans = max ( ans , x * a [ idx ] + func ( idx + 1 , 1 , a , dp , n , x ) ) NEW_LINE ans = max ( ans , a [ idx ] + func ( idx + 1 , 2 , a , dp , n , x ) ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( ans , a [ id ] + func ( idx + 1 , 2 , a , dp , n , x ) ) NEW_LINE DEDENT dp [ idx ] [ cur ] = ans NEW_LINE return ans NEW_LINE DEDENT def getMaximumSum ( a , n , x ) : NEW_LINE INDENT dp = [ [ - 3 , 8 , - 2 , 1 , - 6 ] NEW_LINE n = len ( a ) NEW_LINE x = - 1 NEW_LINE print ( getMaximumSum ( a , n , x ) ) NEW_LINE"],"references":["N = 5 NEW_LINE def func ( idx , cur , a , dp , n , x ) : NEW_LINE INDENT if ( idx == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ idx ] [ cur ] != - 1 ) : NEW_LINE INDENT return dp [ idx ] [ cur ] NEW_LINE DEDENT ans = 0 NEW_LINE if ( cur == 0 ) : NEW_LINE INDENT ans = max ( ans , a [ idx ] + func ( idx + 1 , 0 , a , dp , n , x ) ) NEW_LINE ans = max ( ans , x * a [ idx ] + func ( idx + 1 , 1 , a , dp , n , x ) ) NEW_LINE DEDENT elif ( cur == 1 ) : NEW_LINE INDENT ans = max ( ans , x * a [ idx ] + func ( idx + 1 , 1 , a , dp , n , x ) ) NEW_LINE ans = max ( ans , a [ idx ] + func ( idx + 1 , 2 , a , dp , n , x ) ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( ans , a [ idx ] + func ( idx + 1 , 2 , a , dp , n , x ) ) NEW_LINE DEDENT dp [ idx ] [ cur ] = ans NEW_LINE return dp [ idx ] [ cur ] NEW_LINE DEDENT def getMaximumSum ( a , n , x ) : NEW_LINE INDENT dp = [ [ - 1 for i in range ( 3 ) ] for j in range ( n ) ] NEW_LINE maxi = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT maxi = max ( maxi , func ( i , 0 , a , dp , n , x ) ) NEW_LINE DEDENT return maxi NEW_LINE DEDENT a = [ - 3 , 8 , - 2 , 1 , - 6 ] NEW_LINE n = len ( a ) NEW_LINE x = - 1 NEW_LINE print ( getMaximumSum ( a , n , x ) ) NEW_LINE"],"bleu":0.7798789984881463,"rouge_l":0.8741718742658459}
{"id":971,"predictions":["def exponent ( A , B ) : NEW_LINE INDENT if ( A == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( B == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT y = 0 NEW_LINE if ( B % 2 == 0 ) : NEW_LINE INDENT y = exponent ( A , B \/ 2 ) NEW_LINE y = ( y * y ) NEW_LINE DEDENT else : NEW_LINE INDENT y = A NEW_LINE y = ( y * exponent ( A , B - 1 ) ) NEW_LINE DEDENT return y NEW_LINE DEDENT def Sum ( k , n ) : NEW_LINE INDENT sum = exponent ( k , n + 1 ) - exponent ( k - 1 ) NEW_LINE return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE K = 3 NEW_LINE print ( Sum ( K , n ) ) NEW_LINE DEDENT"],"references":["def exponent ( A , B ) : NEW_LINE INDENT if ( A == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( B == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT if ( B % 2 == 0 ) : NEW_LINE INDENT y = exponent ( A , B \/ 2 ) ; NEW_LINE y = ( y * y ) ; NEW_LINE DEDENT else : NEW_LINE INDENT y = A ; NEW_LINE y = ( y * exponent ( A , B - 1 ) ) ; NEW_LINE DEDENT return y ; NEW_LINE DEDENT def sum ( k , n ) : NEW_LINE INDENT sum = exponent ( k , n + 1 ) - exponent ( k - 1 , n + 1 ) ; NEW_LINE return sum ; NEW_LINE DEDENT n = 3 ; NEW_LINE K = 3 ; NEW_LINE print ( sum ( K , n ) ) ; NEW_LINE"],"bleu":0.7285319164326489,"rouge_l":0.883699726471482}
{"id":972,"predictions":["import math NEW_LINE MAX = 10000 ; NEW_LINE primes = [ ] ; NEW_LINE def sieve ( ) : NEW_LINE INDENT n = MAX ; NEW_LINE nNew = int ( ( n ) \/ 2 ) ; NEW_LINE marked = [ False ] * ( nNew + 100 ) ; NEW_LINE tmp = int ( math . sqrt ( n ) ) ; NEW_LINE for i in range ( 1 , int ( ( tmp - 1 ) \/ 2 ) + 1 ) : NEW_LINE INDENT for j in range ( ( i * ( i + 1 ) << 1 , nNew + 1 ) , ( 2 * i + 1 ) ) : NEW_LINE INDENT marked [ j ] = True ; NEW_LINE DEDENT DEDENT primes . append ( 2 ) ; NEW_LINE for i in range ( 1 , nNew + 1 ) : NEW_LINE INDENT if ( marked [ i ] == False ) : NEW_LINE INDENT primes . append ( 2 * i + 1 ) ; NEW_LINE DEDENT DEDENT def prime [ 2 ] : NEW_LINE INDENT factors = [ 0 ] * MAX ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT copy = arr [ i ] ; NEW_LINE sqr = int ( math . sqrt ( copy ) ) ) ; NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( copy % primes [ j ] == 0 ) : NEW_LINE INDENT while ( copy % primes [ j ] == 0 ) : NEW_LINE INDENT copy = ( copy \/\/ primes [ j ] ) ; NEW_LINE DEDENT factors [ primes [ j ] ] = 1 ; NEW_LINE DEDENT DEDENT if ( factors [ 2 ] == 1 ) : NEW_LINE INDENT factors [ copy ] = 1 ; NEW_LINE DEDENT DEDENT if ( factors [ 2 ] == 1 ) : NEW_LINE INDENT print ( 2 , end = \" ▁ \" ) ; NEW_LINE DEDENT for i in range ( 3 , X + 1 , 2 ) : NEW_LINE INDENT if ( factors [ i ] == 1 ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT"],"references":["import math ; NEW_LINE MAX = 10000 ; NEW_LINE primes = [ ] ; NEW_LINE def sieve ( ) : NEW_LINE INDENT n = MAX ; NEW_LINE nNew = int ( n \/ 2 ) ; NEW_LINE marked = [ False ] * ( nNew + 100 ) ; NEW_LINE tmp = int ( math . sqrt ( n ) ) ; NEW_LINE for i in range ( 1 , int ( ( tmp - 1 ) \/ 2 ) + 1 ) : NEW_LINE INDENT for j in range ( ( i * ( i + 1 ) ) << 1 , nNew + 1 , 2 * i + 1 ) : NEW_LINE INDENT marked [ j ] = True ; NEW_LINE DEDENT DEDENT primes . append ( 2 ) ; NEW_LINE for i in range ( 1 , nNew + 1 ) : NEW_LINE INDENT if ( marked [ i ] == False ) : NEW_LINE INDENT primes . append ( 2 * i + 1 ) ; NEW_LINE DEDENT DEDENT DEDENT def primeLcm ( arr , n ) : NEW_LINE INDENT factors = [ 0 ] * ( MAX ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT copy = arr [ i ] ; NEW_LINE sqr = int ( math . sqrt ( copy ) ) ; NEW_LINE j = 0 ; NEW_LINE while ( primes [ j ] <= sqr ) : NEW_LINE INDENT if ( copy % primes [ j ] == 0 ) : NEW_LINE INDENT while ( copy % primes [ j ] == 0 ) : NEW_LINE INDENT copy = int ( copy \/ primes [ j ] ) ; NEW_LINE DEDENT factors [ primes [ j ] ] = 1 ; NEW_LINE DEDENT j += 1 ; NEW_LINE DEDENT if ( copy > 1 ) : NEW_LINE INDENT factors [ copy ] = 1 ; NEW_LINE DEDENT DEDENT if ( factors [ 2 ] == 1 ) : NEW_LINE INDENT print ( \"2 ▁ \" , end = \" \" ) ; NEW_LINE DEDENT for i in range ( 3 , MAX + 1 , 2 ) : NEW_LINE INDENT if ( factors [ i ] == 1 ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT DEDENT sieve ( ) ; NEW_LINE arr = [ 20 , 10 , 15 , 60 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE primeLcm ( arr , n ) ; NEW_LINE"],"bleu":0.7869771173807102,"rouge_l":0.8734966413257712}
{"id":973,"predictions":["def Alcuin ( n ) : NEW_LINE INDENT _n = n NEW_LINE ans = round ( ( _n * _n ) \/ 12 ) - floor ( _n \/ 4 ) * floor ( _n + 2 ) NEW_LINE return ans NEW_LINE DEDENT def solve ( n ) : NEW_LINE INDENT i = 0 NEW_LINE ans = round ( ( ( i ) , end = \" , ▁ \" ) NEW_LINE while ( i < n ) : NEW_LINE INDENT print ( ans [ i ] , end = \" , ▁ \" ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT n = 11 NEW_LINE solve ( n ) NEW_LINE"],"references":["from math import ceil , floor NEW_LINE def Alcuin ( n ) : NEW_LINE INDENT _n = n NEW_LINE ans = 0 NEW_LINE ans = ( round ( ( _n * _n ) \/ 12 ) - floor ( _n \/ 4 ) * floor ( ( _n + 2 ) \/ 4 ) ) NEW_LINE return ans NEW_LINE DEDENT def solve ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( Alcuin ( i ) , end = \" , ▁ \" ) NEW_LINE DEDENT DEDENT n = 15 NEW_LINE solve ( n ) NEW_LINE"],"bleu":0.6812733220658171,"rouge_l":0.7415578568212517}
{"id":974,"predictions":["def getMSB ( n ) : NEW_LINE INDENT n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 4 NEW_LINE n |= n >>= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE return ( ( n + 1 ) >> 1 ) >> 2 NEW_LINE DEDENT def multiply ( F , M ) : NEW_LINE INDENT x = ( F [ 0 ] [ 0 ] * M [ 0 ] [ 0 ] + F [ 0 ] [ 1 ] * M [ 0 ] [ 1 ] + F [ 0 ] [ 1 ] * M [ 1 ] [ 0 ] ) NEW_LINE y = F [ 1 ] [ 0 ] * M [ 0 ] [ 0 ] [ 0 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 1 ] NEW_LINE w = F [ 0 ] [ 1 ] * M [ 0 ] [ 0 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 1 ] NEW_LINE F [ 0 ] [ 0 ] = x NEW_LINE F [ 0 ] [ 1 ] = y NEW_LINE F [ 1 ] [ 0 ] = z NEW_LINE F [ 1 ] [ 0 ] = w NEW_LINE F [ 1 ] [ 0 ] = w NEW_LINE F [ 1 ] [ 1 ] = w NEW_LINE F [ 1 ] [ 0 ] = w NEW_LINE F [ 1 ] [ 1 ] = w NEW_LINE F [ 1 ] [ 1 ] = w >> 1 NEW_LINE DEDENT def power ( F , n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT M = [ 1 , 1 ] , [ 1 , 0 ] ] NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT power ( F , n - 1 ) NEW_LINE return F [ 0 ] [ 0 ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 6 NEW_LINE print ( fib ( n ) ) NEW_LINE DEDENT"],"references":["def getMSB ( n ) : NEW_LINE INDENT n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE return ( ( n + 1 ) >> 2 ) NEW_LINE DEDENT def multiply ( F , M ) : NEW_LINE INDENT x = F [ 0 ] [ 0 ] * M [ 0 ] [ 0 ] + F [ 0 ] [ 1 ] * M [ 1 ] [ 0 ] NEW_LINE y = F [ 0 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 0 ] [ 1 ] * M [ 1 ] [ 1 ] NEW_LINE z = F [ 1 ] [ 0 ] * M [ 0 ] [ 0 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 0 ] NEW_LINE w = F [ 1 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 1 ] NEW_LINE F [ 0 ] [ 0 ] = x NEW_LINE F [ 0 ] [ 1 ] = y NEW_LINE F [ 1 ] [ 0 ] = z NEW_LINE F [ 1 ] [ 1 ] = w NEW_LINE DEDENT def power ( F , n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT M = [ [ 1 , 1 ] , [ 1 , 0 ] ] NEW_LINE m = getMSB ( n ) NEW_LINE while m : NEW_LINE INDENT multiply ( F , F ) NEW_LINE if ( n & m ) : NEW_LINE INDENT multiply ( F , M ) NEW_LINE DEDENT m = m >> 1 NEW_LINE DEDENT DEDENT def fib ( n ) : NEW_LINE INDENT F = [ [ 1 , 1 ] , [ 1 , 0 ] ] NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT power ( F , n - 1 ) NEW_LINE return F [ 0 ] [ 0 ] NEW_LINE DEDENT n = 6 NEW_LINE print ( fib ( n ) ) NEW_LINE"],"bleu":0.8038363838607856,"rouge_l":0.7687347214026806}
{"id":975,"predictions":["import sys NEW_LINE def printMinIndexChar ( str1 , patt ) : NEW_LINE INDENT minIndex = sys . maxsize NEW_LINE m = len ( str1 ) NEW_LINE n = len ( patt ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( patt [ i ] == str1 [ j ] and j < minIndex ) : NEW_LINE INDENT minIndex = j NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if ( minIndex != sys . maxsize - 1 ) : NEW_LINE INDENT print ( \" Minimum ▁ Index ▁ Character ▁ = \" \" , str1 [ minIndex ] + str1 [ minIndex ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No ▁ char ▁ present ▁ = \" , str1 [ minIndex ] ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" geegeeks \" NEW_LINE p2 = \" se \" NEW_LINE printMinIndexChar ( str1 , p2 ) NEW_LINE DEDENT"],"references":["def printMinIndexChar ( Str , patt ) : NEW_LINE INDENT minIndex = 10 ** 9 NEW_LINE m = len ( Str ) NEW_LINE n = len ( patt ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( patt [ i ] == Str [ j ] and j < minIndex ) : NEW_LINE INDENT minIndex = j NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if ( minIndex != 10 ** 9 ) : NEW_LINE INDENT print ( \" Minimum ▁ Index ▁ Character ▁ = ▁ \" , Str [ minIndex ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No ▁ character ▁ present \" ) NEW_LINE DEDENT DEDENT Str = \" geeksforgeeks \" NEW_LINE patt = \" set \" NEW_LINE printMinIndexChar ( Str , patt ) NEW_LINE"],"bleu":0.5958781844948557,"rouge_l":0.8053014553014552}
{"id":976,"predictions":["from math import ceil , floor NEW_LINE def squares ( l , b , a ) : NEW_LINE INDENT return ceil ( l \/ a ) * ceil ( b \/ ( a ) ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT l , b , a = 11 , 23 , a = 14 NEW_LINE print ( squares ( l , b , a ) ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def squares ( l , b , a ) : NEW_LINE INDENT return math . ceil ( l \/ a ) * math . ceil ( b \/ a ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT l = 11 NEW_LINE b = 23 NEW_LINE a = 14 NEW_LINE print ( squares ( l , b , a ) ) NEW_LINE DEDENT"],"bleu":0.6279924230325004,"rouge_l":0.8261249453910003}
{"id":977,"predictions":["def append ( head_data ) : NEW_LINE INDENT new_node = Node ( data ) NEW_LINE last = head NEW_LINE new_node . next = None NEW_LINE if head == None : NEW_LINE INDENT new_node . prev = None NEW_LINE head = new_node NEW_LINE return NEW_LINE DEDENT while last . next is None : NEW_LINE INDENT last = last . next next next NEW_LINE DEDENT last . next = new_node NEW_LINE new_node . prev = last NEW_LINE new_node . prev = last NEW_LINE return NEW_LINE DEDENT"],"references":["def append ( self , new_data ) : NEW_LINE INDENT new_node = Node ( data = new_data ) NEW_LINE last = self . head NEW_LINE new_node . next = None NEW_LINE if self . head is None : NEW_LINE INDENT new_node . prev = None NEW_LINE self . head = new_node NEW_LINE return NEW_LINE DEDENT while ( last . next is not None ) : NEW_LINE INDENT last = last . next NEW_LINE DEDENT last . next = new_node NEW_LINE new_node . prev = last NEW_LINE DEDENT"],"bleu":0.6753887486222789,"rouge_l":0.8394495412844035}
{"id":978,"predictions":["import sys NEW_LINE def maxProductSum ( str1 , m ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE maxProd = - ( sys . maxsize - 1 ) NEW_LINE maxSum = - sys . maxsize NEW_LINE for i in range ( n - m ) : NEW_LINE INDENT product = 1 NEW_LINE sum = 0 NEW_LINE for j in range ( i , m + i ) : NEW_LINE INDENT product = ( product * ( ord ( str1 [ j ] ) - ord ( '0' ) ) ) NEW_LINE sum = sum + ( ord ( str1 [ j ] ) - ord ( '0' ) ) NEW_LINE DEDENT maxProd = max ( maxProd , product ) NEW_LINE maxSum = max ( maxSum , sum ) NEW_LINE DEDENT print ( \" Maximum ▁ Product ▁ = \" , maxSum ) NEW_LINE print ( \" Maximum ▁ Sum ▁ = ▁ \" , maxSum ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \"3675356291\" NEW_LINE m = 5 NEW_LINE maxProductSum ( str1 , m ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE def maxProductSum ( string , m ) : NEW_LINE INDENT n = len ( string ) NEW_LINE maxProd , maxSum = ( - ( sys . maxsize ) - 1 , - ( sys . maxsize ) - 1 ) NEW_LINE for i in range ( n - m ) : NEW_LINE INDENT product , sum = 1 , 0 NEW_LINE for j in range ( i , m + i ) : NEW_LINE INDENT product = product * ( ord ( string [ j ] ) - ord ( '0' ) ) NEW_LINE sum = sum + ( ord ( string [ j ] ) - ord ( '0' ) ) NEW_LINE DEDENT maxProd = max ( maxProd , product ) NEW_LINE maxSum = max ( maxSum , sum ) NEW_LINE DEDENT print ( \" Maximum ▁ Product ▁ = \" , maxProd ) NEW_LINE print ( \" Maximum ▁ sum ▁ = \" , maxSum ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \"3675356291\" NEW_LINE m = 5 NEW_LINE maxProductSum ( string , m ) NEW_LINE DEDENT"],"bleu":0.7719539054021485,"rouge_l":0.8963650425367364}
{"id":979,"predictions":["def findphoneNumber ( n ) : NEW_LINE INDENT temp = n NEW_LINE sum = 0 NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT sum += temp % 10 NEW_LINE temp = temp \/\/ 10 NEW_LINE DEDENT if ( sum < 10 ) : NEW_LINE INDENT print ( n , sum ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n , sum ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 98765432 NEW_LINE findphoneNumber ( n ) NEW_LINE DEDENT"],"references":["def findPhoneNumber ( n ) : NEW_LINE INDENT temp = n NEW_LINE sum = 0 NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT sum += temp % 10 NEW_LINE temp = temp \/\/ 10 NEW_LINE DEDENT if ( sum < 10 ) : NEW_LINE INDENT print ( n , \"0\" , sum ) NEW_LINE DEDENT else : NEW_LINE INDENT n = str ( n ) NEW_LINE sum = str ( sum ) NEW_LINE n += sum NEW_LINE print ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 98765432 NEW_LINE findPhoneNumber ( n ) NEW_LINE DEDENT"],"bleu":0.7367974256466765,"rouge_l":0.8561058235199227}
{"id":980,"predictions":["def countOfSubarrays ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE v = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT v [ arr [ i ] ] = i NEW_LINE DEDENT maximum = - 10 ** 9 NEW_LINE minimum = - 10 ** 9 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT maximum = max ( maximum , v [ i ] ) NEW_LINE minimum = min ( minimum , v [ i ] ) NEW_LINE if ( maximum - minimum < i ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 1 , 3 , 2 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countOfSubarrays ( arr , n ) ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE INT_MAX = sys . maxsize ; NEW_LINE INT_MIN = - ( sys . maxsize - 1 ) ; NEW_LINE def countOfSubarrays ( arr , n ) : NEW_LINE INDENT count = 0 ; NEW_LINE v = [ 0 ] * ( n + 1 ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT v [ arr [ i ] ] = i ; NEW_LINE DEDENT maximum = INT_MIN ; NEW_LINE minimum = INT_MAX ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT maximum = max ( maximum , v [ i ] ) ; NEW_LINE minimum = min ( minimum , v [ i ] ) ; NEW_LINE if ( maximum - minimum < i ) : NEW_LINE INDENT count = count + 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 4 , 1 , 3 , 2 , 5 , 6 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( countOfSubarrays ( arr , n ) ) ; NEW_LINE DEDENT"],"bleu":0.6754368734445115,"rouge_l":0.8406776685393258}
{"id":981,"predictions":["def maxSum ( p0 , p1 , a , pos , n ) : NEW_LINE INDENT if ( pos == n ) : NEW_LINE INDENT if ( p0 == p1 ) : NEW_LINE INDENT return p0 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT ans = maxSum ( p0 , p1 , a , pos + 1 , n ) NEW_LINE ans = max ( ans , maxSum ( p0 + a [ pos ] , p1 , a , pos + 1 , n ) ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE a = [ 1 , 2 , 3 , 6 ] NEW_LINE print ( maxSum ( 0 , 0 , a , 0 , n ) ) NEW_LINE DEDENT"],"references":["def maxSum ( p0 , p1 , a , pos , n ) : NEW_LINE INDENT if ( pos == n ) : NEW_LINE INDENT if ( p0 == p1 ) : NEW_LINE INDENT return p0 ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT ans = maxSum ( p0 , p1 , a , pos + 1 , n ) ; NEW_LINE ans = max ( ans , maxSum ( p0 + a [ pos ] , p1 , a , pos + 1 , n ) ) ; NEW_LINE ans = max ( ans , maxSum ( p0 , p1 + a [ pos ] , a , pos + 1 , n ) ) ; NEW_LINE return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 ; NEW_LINE a = [ 1 , 2 , 3 , 6 ] ; NEW_LINE print ( maxSum ( 0 , 0 , a , 0 , n ) ) ; NEW_LINE DEDENT"],"bleu":0.6791404630948183,"rouge_l":0.8567242598767302}
{"id":982,"predictions":["MAXN = 1000000 ; NEW_LINE def minimumSteps ( n , m , a , b ) : NEW_LINE INDENT if ( n > m ) : NEW_LINE INDENT return MAXN ; NEW_LINE DEDENT if ( n == m ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT return min ( 1 + minimumSteps ( n * a , m , a , b ) , 1 + minimumSteps ( n * b , m , a , b ) ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 120 ; NEW_LINE m = 51840 ; NEW_LINE a = 2 ; b = 3 ; NEW_LINE print ( minimumSteps ( n , m , a , b ) ) ; NEW_LINE DEDENT"],"references":["MAXN = 10000000 NEW_LINE def minimumSteps ( n , m , a , b ) : NEW_LINE INDENT if ( n > m ) : NEW_LINE INDENT return MAXN NEW_LINE DEDENT if ( n == m ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return min ( 1 + minimumSteps ( n * a , m , a , b ) , 1 + minimumSteps ( n * b , m , a , b ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 120 NEW_LINE m = 51840 NEW_LINE a = 2 NEW_LINE b = 3 NEW_LINE print ( minimumSteps ( n , m , a , b ) ) NEW_LINE DEDENT"],"bleu":0.8198452736035612,"rouge_l":0.9581981046345579}
{"id":983,"predictions":["def printLargestString ( s , l , r ) : NEW_LINE INDENT freq = [ 0 ] * 26 NEW_LINE l -= 1 NEW_LINE r -= 1 NEW_LINE for i in range ( min ( l , r ) , 1 ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT ans = \" \" NEW_LINE for i in range ( 25 , - 1 , - 1 ) : NEW_LINE INDENT while ( freq [ i ] > 0 ) : NEW_LINE INDENT ans += chr ( 97 + i ) NEW_LINE freq [ i ] -= 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT s = \" striv \" NEW_LINE l = 3 NEW_LINE r = 5 NEW_LINE print ( printLargestString ( s , l , r ) ) NEW_LINE"],"references":["def printLargestString ( s , l , r ) : NEW_LINE INDENT freq = [ 0 ] * 26 NEW_LINE l -= 1 NEW_LINE r -= 1 NEW_LINE for i in range ( min ( l , r ) , max ( l , r ) + 1 ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT ans = \" \" NEW_LINE for i in range ( 25 , - 1 , - 1 ) : NEW_LINE INDENT while ( freq [ i ] ) : NEW_LINE INDENT ans += chr ( ord ( ' a ' ) + i ) NEW_LINE freq [ i ] -= 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" striver \" NEW_LINE l = 3 NEW_LINE r = 5 NEW_LINE print ( printLargestString ( s , l , r ) ) NEW_LINE DEDENT"],"bleu":0.7817471653183192,"rouge_l":0.8872952904078935}
{"id":984,"predictions":["def find syPairs ( arr , n ) : NEW_LINE INDENT hm = { 0 : 0 for i in range ( n ) } NEW_LINE for i in range ( n ) : NEW_LINE INDENT first = arr [ i ] [ 0 ] NEW_LINE sec = arr [ i ] [ 1 ] NEW_LINE val = hm [ sec ] NEW_LINE if ( val != first and val == first ) : NEW_LINE INDENT print ( \" ( \" , sec , \" , \" , first , \" ) \" ) NEW_LINE DEDENT else : NEW_LINE INDENT hm [ sec ] = second NEW_LINE DEDENT DEDENT arr = [ [ [ 0 ] for i in range ( 5 ) ] NEW_LINE arr [ 0 ] [ 0 ] = 20 NEW_LINE arr [ 1 ] [ 0 ] = 30 NEW_LINE arr [ 2 ] [ 1 ] = 40 NEW_LINE arr [ 2 ] [ 0 ] = 30 NEW_LINE arr [ 2 ] [ 0 ] = 12 NEW_LINE arr [ 3 ] [ 0 ] = 15 NEW_LINE arr [ 4 ] [ 1 ] = 15 NEW_LINE findCyPairs ( arr ) NEW_LINE"],"references":["def findSymPairs ( arr , row ) : NEW_LINE INDENT hM = dict ( ) NEW_LINE for i in range ( row ) : NEW_LINE INDENT first = arr [ i ] [ 0 ] NEW_LINE sec = arr [ i ] [ 1 ] NEW_LINE if ( sec in hM . keys ( ) and hM [ sec ] == first ) : NEW_LINE INDENT print ( \" ( \" , sec , \" , \" , first , \" ) \" ) NEW_LINE DEDENT else : NEW_LINE INDENT hM [ first ] = sec NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ [ 0 for i in range ( 2 ) ] for i in range ( 5 ) ] NEW_LINE arr [ 0 ] [ 0 ] , arr [ 0 ] [ 1 ] = 11 , 20 NEW_LINE arr [ 1 ] [ 0 ] , arr [ 1 ] [ 1 ] = 30 , 40 NEW_LINE arr [ 2 ] [ 0 ] , arr [ 2 ] [ 1 ] = 5 , 10 NEW_LINE arr [ 3 ] [ 0 ] , arr [ 3 ] [ 1 ] = 40 , 30 NEW_LINE arr [ 4 ] [ 0 ] , arr [ 4 ] [ 1 ] = 10 , 5 NEW_LINE findSymPairs ( arr , 5 ) NEW_LINE DEDENT"],"bleu":0.5430534428592294,"rouge_l":0.7010474250800117}
{"id":985,"predictions":["def fact ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT return res NEW_LINE DEDENT def nCr ( n , r ) : NEW_LINE INDENT return int ( fact ( n ) \/ ( 1 * fact ( r ) * fact ( n - r ) ) ) NEW_LINE DEDENT def number_of_subsequences ( arr , k , n ) : NEW_LINE INDENT s = 0 NEW_LINE mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in mp : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT for j in mp : NEW_LINE INDENT s = s + 1 * nCr ( mp [ j ] , k ) NEW_LINE DEDENT return s NEW_LINE DEDENT arr = [ 1 , 1 , 1 , 1 , 2 , 2 , 2 ] NEW_LINE k = 2 NEW_LINE n = len ( arr ) NEW_LINE print ( number_of_subsequences ( arr , k , n ) ) NEW_LINE"],"references":["def fact ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT return res NEW_LINE DEDENT def nCr ( n , r ) : NEW_LINE INDENT return fact ( n ) \/\/ ( fact ( r ) * fact ( n - r ) ) NEW_LINE DEDENT def number_of_subsequences ( arr , k , n ) : NEW_LINE INDENT s = 0 NEW_LINE m = dict ( ) NEW_LINE for i in arr : NEW_LINE INDENT m [ i ] = m . get ( i , 0 ) + 1 NEW_LINE DEDENT for j in m : NEW_LINE INDENT s = s + nCr ( m [ j ] , k ) NEW_LINE DEDENT return s NEW_LINE DEDENT arr = [ 1 , 1 , 1 , 1 , 2 , 2 , 2 ] NEW_LINE k = 2 NEW_LINE n = len ( arr ) NEW_LINE print ( number_of_subsequences ( arr , k , n ) ) NEW_LINE"],"bleu":0.7177484046705923,"rouge_l":0.8639640403697734}
{"id":986,"predictions":["import math NEW_LINE SIZE = 26 NEW_LINE def SieveOfEratosthenes ( prime , p_size ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( math . sqrt ( p_size ) ) + 1 ) : NEW_LINE INDENT if ( p * p >= p ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( p * 2 , p_size , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def printChar ( string , n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) NEW_LINE prime [ 1 ] = False NEW_LINE SieveOfEratosthenes ( prime , len ( string ) + 1 ) NEW_LINE freq = [ 0 ] * ( SIZE ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT freq [ ord ( string [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( prime [ freq [ ord ( string [ i ] ) - ord ( ' a ' ) ] ) : NEW_LINE INDENT print ( string [ i ] ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT string = \" geeksforgeeks \" NEW_LINE n = len ( string ) NEW_LINE printChar ( string , n ) NEW_LINE DEDENT"],"references":["SIZE = 26 NEW_LINE from math import sqrt NEW_LINE def SieveOfEratosthenes ( prime , p_size ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( sqrt ( p_size ) ) , 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( p * 2 , p_size , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def printChar ( str , n ) : NEW_LINE INDENT prime = [ True for i in range ( n + 1 ) ] NEW_LINE SieveOfEratosthenes ( prime , len ( str ) + 1 ) NEW_LINE freq = [ 0 for i in range ( SIZE ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( prime [ freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] ] ) : NEW_LINE INDENT print ( str [ i ] , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" geeksforgeeks \" NEW_LINE n = len ( str ) NEW_LINE printChar ( str , n ) NEW_LINE DEDENT"],"bleu":0.7405897585125458,"rouge_l":0.8666833573261562}
{"id":987,"predictions":["def solac populateSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum = sum + ( 1 << i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 10 NEW_LINE print ( \" Sum ▁ of ▁ the ▁ series ▁ : ▁ \" , hull ) NEW_LINE"],"references":["def calculateSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum = sum + ( 1 << i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 10 NEW_LINE print ( \" Sum ▁ of ▁ series ▁ \" , calculateSum ( n ) ) NEW_LINE"],"bleu":0.8270868595928477,"rouge_l":0.9043126684636119}
{"id":988,"predictions":["def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : return False ; NEW_LINE if ( n <= 3 ) : return True ; NEW_LINE if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT i = 5 ; NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT i += 6 ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT def SumOfPrimeDivisors ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( isPrime ( i ) ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT DEDENT return sum ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 60 ; NEW_LINE print ( \" Sum ▁ of ▁ prime ▁ divisors ▁ of ▁ 60 ▁ is \" , SumOfPrimeDivisors ( n ) ) ; NEW_LINE DEDENT"],"references":["N = 1000005 NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT if n <= 3 : NEW_LINE INDENT return True NEW_LINE DEDENT if n % 2 == 0 or n % 3 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT def SumOfPrimeDivisors ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT if isPrime ( i ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT DEDENT return sum NEW_LINE DEDENT n = 60 NEW_LINE print ( \" Sum ▁ of ▁ prime ▁ divisors ▁ of ▁ 60 ▁ is ▁ \" + str ( SumOfPrimeDivisors ( n ) ) ) NEW_LINE"],"bleu":0.6299609241984401,"rouge_l":0.8646710581172352}
{"id":989,"predictions":["def elementCount ( arr1 , n1 , arr2 , n2 ) : NEW_LINE INDENT hash1 = set ( ) NEW_LINE hash1 = set ( ) NEW_LINE for i in range ( 0 , n2 ) : NEW_LINE INDENT hash1 . add ( arr2 [ i ] ) NEW_LINE DEDENT for i in range ( 0 , n1 ) : NEW_LINE INDENT for j in range ( 1 , arr1 [ i ] + 1 ) : NEW_LINE INDENT if j * j > arr1 [ i ] : NEW_LINE INDENT break NEW_LINE DEDENT if ( arr1 [ i ] % j != 0 ) : NEW_LINE INDENT if ( ( hash1 [ j ] \/\/ j != hash1 [ - 1 ] ) and ( arr1 [ i ] \/\/ j ) != hash1 [ hash2 [ - 1 ] ] ) : NEW_LINE INDENT count += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT arr1 = [ 10 , 2 , 13 , 4 , 15 ] NEW_LINE arr2 = [ 2 , 4 , 5 , 6 ] NEW_LINE n1 = len ( arr1 ) NEW_LINE n2 = len ( arr2 ) NEW_LINE print ( elementCount ( arr1 , n1 , arr2 , n2 ) ) NEW_LINE"],"references":["from math import sqrt NEW_LINE def elementCount ( arr1 , arr2 ) : NEW_LINE INDENT count = 0 NEW_LINE hash = frozenset ( arr2 ) NEW_LINE for x in arr1 : NEW_LINE INDENT for j in range ( 1 , int ( sqrt ( x ) ) + 1 ) : NEW_LINE INDENT if x % j == 0 : NEW_LINE INDENT if ( j in hash or x \/ j in hash ) : NEW_LINE INDENT count += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT arr1 = [ 10 , 2 , 13 , 4 , 15 ] NEW_LINE arr2 = [ 2 , 4 , 5 , 6 ] NEW_LINE print ( elementCount ( arr1 , arr2 ) ) NEW_LINE"],"bleu":0.3802106564986653,"rouge_l":0.6163483884005254}
{"id":990,"predictions":["def countSubarray ( arr , n , k ) : NEW_LINE INDENT s = 0 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( arr [ i ] > k ) : NEW_LINE INDENT i += 1 NEW_LINE continue NEW_LINE DEDENT count = 0 NEW_LINE while ( i < n and arr [ i ] <= k ) : NEW_LINE INDENT i += 1 NEW_LINE count += 1 NEW_LINE DEDENT s += ( count * ( count + 1 ) ) \/\/ 2 NEW_LINE DEDENT return ( n * ( n + 1 ) \/\/ 2 - s ) NEW_LINE DEDENT arr = [ 1 , 2 , 3 ] NEW_LINE k = 2 NEW_LINE n = len ( arr ) NEW_LINE print ( countSubarray ( arr , n , k ) ) NEW_LINE"],"references":["def countSubarray ( arr , n , k ) : NEW_LINE INDENT s = 0 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( arr [ i ] > k ) : NEW_LINE INDENT i = i + 1 NEW_LINE continue NEW_LINE DEDENT count = 0 NEW_LINE while ( i < n and arr [ i ] <= k ) : NEW_LINE INDENT i = i + 1 NEW_LINE count = count + 1 NEW_LINE DEDENT s = s + ( ( count * ( count + 1 ) ) \/\/ 2 ) NEW_LINE DEDENT return ( n * ( n + 1 ) \/\/ 2 - s ) NEW_LINE DEDENT arr = [ 1 , 2 , 3 ] NEW_LINE k = 2 NEW_LINE n = len ( arr ) NEW_LINE print ( countSubarray ( arr , n , k ) ) NEW_LINE"],"bleu":0.8541567983887415,"rouge_l":0.9325968083919205}
{"id":991,"predictions":["def countNum ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE arr . sort ( reverse = False ) NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] != arr [ i + 1 ] and arr [ i ] != arr [ i + 1 ] - 1 ) : NEW_LINE INDENT count += arr [ i + 1 ] - arr [ i ] - 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 5 , 8 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countNum ( arr , n ) ) NEW_LINE DEDENT"],"references":["def countNum ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] != arr [ i + 1 ] and arr [ i ] != arr [ i + 1 ] - 1 ) : NEW_LINE INDENT count += arr [ i + 1 ] - arr [ i ] - 1 ; NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 3 , 5 , 8 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countNum ( arr , n ) ) NEW_LINE"],"bleu":0.8370850949814539,"rouge_l":0.9388350802706646}
{"id":992,"predictions":["def max_element ( a , n ) : NEW_LINE INDENT pre = [ 0 ] * n ; NEW_LINE pre [ 0 ] = a [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT pre [ i ] = max ( pre [ i - 1 ] , a [ i ] ) ; NEW_LINE DEDENT suf = [ 0 ] * n ; NEW_LINE suf [ n - 1 ] = a [ n - 1 ] ; NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT suf [ i ] = max ( suf [ i + 1 ] , a [ i ] ) ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT print ( suf [ i + 1 ] , end = \" ▁ \" ) ; NEW_LINE DEDENT elif ( i == n - 1 ) : NEW_LINE INDENT print ( pre [ i - 1 ] , end = \" ▁ \" ) ; NEW_LINE DEDENT elif ( i == n - 1 ) : NEW_LINE INDENT print ( pre [ i - 1 ] , end = \" ▁ \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( max ( pre [ i - 1 ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT DEDENT a = [ 2 , 5 , 6 , 1 , 3 ] ; NEW_LINE n = len ( a ) ; NEW_LINE max_element ( a , n ) ; NEW_LINE"],"references":["def max_element ( a , n ) : NEW_LINE INDENT pre = [ 0 ] * n ; NEW_LINE pre [ 0 ] = a [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT pre [ i ] = max ( pre [ i - 1 ] , a [ i ] ) ; NEW_LINE DEDENT suf = [ 0 ] * n ; NEW_LINE suf [ n - 1 ] = a [ n - 1 ] ; NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT suf [ i ] = max ( suf [ i + 1 ] , a [ i ] ) ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT print ( suf [ i + 1 ] , end = \" ▁ \" ) ; NEW_LINE DEDENT elif ( i == n - 1 ) : NEW_LINE INDENT print ( pre [ i - 1 ] , end = \" ▁ \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( max ( pre [ i - 1 ] , suf [ i + 1 ] ) , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 2 , 5 , 6 , 1 , 3 ] ; NEW_LINE n = len ( a ) ; NEW_LINE max_element ( a , n ) ; NEW_LINE DEDENT"],"bleu":0.9065870973698258,"rouge_l":0.9171024483004517}
{"id":993,"predictions":["def isRotated ( str1 , str2 ) : NEW_LINE INDENT if len ( str1 ) != len ( str2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT fract_rot = \" \" NEW_LINEoin_rot = \" \" NEW_LINE l = len ( str2 ) NEW_LINE length = len ( str2 ) NEW_LINE swap_rot = rat_rot + str2 [ 0 : length - 2 ] NEW_LINE length = len ( str2 ) NEW_LINE if ( Str1 == R ) or ( Str1 ==itud ) : NEW_LINE INDENT return True NEW_LINE DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" geeks \" NEW_LINE str2 = \" eksge \" NEW_LINE if ( isRotated ( str1 , str2 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def isRotated ( str1 , str2 ) : NEW_LINE INDENT if ( len ( str1 ) != len ( str2 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT clock_rot = \" \" NEW_LINE anticlock_rot = \" \" NEW_LINE l = len ( str2 ) NEW_LINE anticlock_rot = ( anticlock_rot + str2 [ l - 2 : ] + str2 [ 0 : l - 2 ] ) NEW_LINE clock_rot = clock_rot + str2 [ 2 : ] + str2 [ 0 : 2 ] NEW_LINE return ( str1 == clock_rot or str1 == anticlock_rot ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" geeks \" NEW_LINE str2 = \" eksge \" NEW_LINE DEDENT if isRotated ( str1 , str2 ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.646165573520752,"rouge_l":0.7679147837314397}
{"id":994,"predictions":["def findMax ( num ) : NEW_LINE INDENT size_of_num = 4 NEW_LINE num_copy = num NEW_LINE j = size_of_num * 8 - 1 NEW_LINE i = 0 NEW_LINE while ( i < j ) : NEW_LINE INDENT m = ( num_copy >> i ) & 1 NEW_LINE n = ( num_copy >> j ) & 1 NEW_LINE if ( m > n ) : NEW_LINE INDENT x = ( 1 << i ) | 1 NEW_LINE num = num ^ x NEW_LINE DEDENT i = i + 1 NEW_LINE j -= 1 NEW_LINE DEDENT return num NEW_LINE DEDENT num = 4 NEW_LINE print ( findMax ( num ) ) NEW_LINE"],"references":["def findMax ( num ) : NEW_LINE INDENT num_copy = num NEW_LINE j = 4 * 8 - 1 ; NEW_LINE i = 0 NEW_LINE while ( i < j ) : NEW_LINE INDENT m = ( num_copy >> i ) & 1 NEW_LINE n = ( num_copy >> j ) & 1 NEW_LINE if ( m > n ) : NEW_LINE INDENT x = ( 1 << i | 1 << j ) NEW_LINE num = num ^ x NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return num NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT num = 4 NEW_LINE print ( findMax ( num ) ) NEW_LINE DEDENT"],"bleu":0.7497883430890611,"rouge_l":0.867013791162398}
{"id":995,"predictions":["def check ( s , l ) : NEW_LINE INDENT pos = [ ] NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT pos . append ( i ) NEW_LINE DEDENT DEDENT t = len ( pos ) NEW_LINE for i in range ( 1 , t ) : NEW_LINE INDENT if ( ( pos [ i ] - pos [ i - 1 ] ) != ( pos [ 1 ] - pos [ 0 ] ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT s = \"100010001000\" NEW_LINE l = len ( s ) NEW_LINE if ( check ( s , l ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def check ( s , l ) : NEW_LINE INDENT pos = [ ] NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT pos . append ( i ) NEW_LINE DEDENT DEDENT t = len ( pos ) NEW_LINE for i in range ( 1 , t ) : NEW_LINE INDENT if ( ( pos [ i ] - pos [ i - 1 ] ) != ( pos [ 1 ] - pos [ 0 ] ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT s = \"100010001000\" NEW_LINE l = len ( s ) NEW_LINE if ( check ( s , l ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.9765013840543725,"rouge_l":0.9944921788940296}
{"id":996,"predictions":["def maximum_one ( s , n ) : NEW_LINE INDENT cnt_one = 0 NEW_LINE max_cnt = 0 NEW_LINE temp = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT cnt_one += 1 NEW_LINE temp += 1 NEW_LINE temp += 1 NEW_LINE DEDENT else : NEW_LINE INDENT max_cnt = max ( max_cnt , temp ) NEW_LINE temp = 0 NEW_LINE DEDENT max_cnt = max ( max_cnt , temp ) NEW_LINE left = [ 0 ] * n NEW_LINE if ( s [ 0 ] == '1' ) : NEW_LINE INDENT left [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT right [ n - 1 ] = 0 NEW_LINE DEDENT if ( s [ n - 1 ] == '1' ) : NEW_LINE INDENT right [ n - 1 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT right [ n - 1 ] = 0 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT right [ i ] = left [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT left [ i ] = 0 NEW_LINE DEDENT DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT right [ i ] = right [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT right [ i ] = 0 NEW_LINE DEDENT DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT sum = left [ i - 1 ] + right [ i + 1 ] NEW_LINE if ( sum < cnt_one ) : NEW_LINE INDENT max_cnt = max ( max ( max_cnt , sum + 1 ) NEW_LINE DEDENT"],"references":["def maximum_one ( s , n ) : NEW_LINE INDENT cnt_one = 0 NEW_LINE cnt , max_cnt = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT cnt_one += 1 NEW_LINE cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT max_cnt = max ( max_cnt , cnt ) NEW_LINE cnt = 0 NEW_LINE DEDENT DEDENT max_cnt = max ( max_cnt , cnt ) NEW_LINE left = [ 0 ] * n NEW_LINE right = [ 0 ] * n NEW_LINE if ( s [ 0 ] == '1' ) : NEW_LINE INDENT left [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT left [ 0 ] = 0 NEW_LINE DEDENT if ( s [ n - 1 ] == '1' ) : NEW_LINE INDENT right [ n - 1 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT right [ n - 1 ] = 0 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT left [ i ] = left [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT left [ i ] = 0 NEW_LINE DEDENT DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT right [ i ] = right [ i + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT right [ i ] = 0 NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT sum = left [ i - 1 ] + right [ i + 1 ] NEW_LINE if ( sum < cnt_one ) : NEW_LINE INDENT max_cnt = max ( max_cnt , sum + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT max_cnt = max ( max_cnt , sum ) NEW_LINE DEDENT DEDENT DEDENT return max_cnt NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \"111011101\" NEW_LINE print ( maximum_one ( s , len ( s ) ) ) NEW_LINE DEDENT"],"bleu":0.7713165580973309,"rouge_l":0.8629387428266383}
{"id":997,"predictions":["import math NEW_LINE def nDigitPerfectCubes ( n ) : NEW_LINE INDENT print ( pow ( math . ceil ( math . ceil ( pow ( 10 , ( n - 1 ) ) ) , 3 ) ) , end = \" ▁ \" ) ; NEW_LINE print ( pow ( math . ceil ( pow ( math . ceil ( math . sqrt ( n ) ) ) - 1 , 3 ) ) ; NEW_LINE DEDENT n = 3 ; NEW_LINE nDigitPerfectCubes ( n ) n = 4 ; NEW_LINE nDigitPerfectCubes ( n ) ; NEW_LINE"],"references":["from math import ceil NEW_LINE def nDigitPerfectCubes ( n ) : NEW_LINE INDENT print ( pow ( ceil ( ( pow ( 10 , ( n - 1 ) ) ) ** ( 1 \/ 3 ) ) , 3 ) , end = \" ▁ \" ) NEW_LINE print ( pow ( ceil ( ( pow ( 10 , ( n ) ) ) ** ( 1 \/ 3 ) ) - 1 , 3 ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE nDigitPerfectCubes ( n ) NEW_LINE DEDENT"],"bleu":0.5313023349341551,"rouge_l":0.6835011367327055}
{"id":998,"predictions":["def isMultipleof5 ( n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT n <<= 1 NEW_LINE DEDENT x = n NEW_LINE x = n NEW_LINE if ( x == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT i = 19 NEW_LINE if ( isMultipleof5 ( i ) ) : NEW_LINE INDENT print ( i , \" is ▁ multiple ▁ of ▁ 5\" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( i , \" is ▁ not ▁ a ▁ multiple ▁ of ▁ 5\" ) NEW_LINE DEDENT"],"references":["def isMultipleof5 ( n ) : NEW_LINE INDENT if ( ( n & 1 ) == 1 ) : NEW_LINE INDENT n <<= 1 ; NEW_LINE DEDENT x = n NEW_LINE x = ( ( int ) ( x * 0.1 ) ) * 10 NEW_LINE if ( x == n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT i = 19 NEW_LINE if ( isMultipleof5 ( i ) == 1 ) : NEW_LINE INDENT print ( i , \" is ▁ multiple ▁ of ▁ 5\" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( i , \" is ▁ not ▁ a ▁ multiple ▁ of ▁ 5\" ) NEW_LINE DEDENT"],"bleu":0.739606834997018,"rouge_l":0.8757290264692688}
{"id":999,"predictions":["def minsteps ( n , m ) : NEW_LINE INDENT if ( m > n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( n + 1 ) \/\/ 2 + m - 1 ) \/\/ m * m NEW_LINE DEDENT DEDENT n = 17 NEW_LINE m = 4 NEW_LINE ans = minsteps ( n , m ) NEW_LINE print ( ans ) NEW_LINE"],"references":["def minsteps ( n , m ) : NEW_LINE INDENT if ( m > n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( n + 1 ) \/\/ 2 + m - 1 ) \/\/ m * m ; NEW_LINE DEDENT DEDENT n = 17 NEW_LINE m = 4 NEW_LINE ans = minsteps ( n , m ) NEW_LINE print ( ans ) NEW_LINE"],"bleu":0.9646494666276937,"rouge_l":0.9917563544767575}
{"id":1000,"predictions":["import math NEW_LINE def gridStr ( str ) : NEW_LINE INDENT l = len ( str ) NEW_LINE k = 0 NEW_LINE row = int ( math . floor ( math . sqrt ( l ) ) ) NEW_LINE column = int ( math . sqrt ( l ) ) NEW_LINE if ( row * column < l ) : NEW_LINE INDENT row = column NEW_LINE DEDENT s = [ ] [ : column ] * column NEW_LINE for i in range ( row ) : NEW_LINE INDENT for j in range ( column ) : NEW_LINE INDENT if ( k < len ( str ) ) : NEW_LINE INDENT s [ i ] [ j ] = str [ k ] NEW_LINE DEDENT k += 1 NEW_LINE DEDENT DEDENT for i in range ( row ) : NEW_LINE INDENT for j in range ( column ) : NEW_LINE INDENT if ( s [ i ] [ j ] == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT print ( s [ i ] [ j ] , end = \" \" ) NEW_LINE DEDENT print ( \" \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" GEEKSFORGEEKS \" NEW_LINE gridStr ( str1 ) NEW_LINE DEDENT"],"references":["from math import sqrt , floor , ceil NEW_LINE def gridStr ( string ) : NEW_LINE INDENT l = len ( string ) NEW_LINE k = 0 NEW_LINE row = floor ( sqrt ( l ) ) NEW_LINE column = ceil ( sqrt ( l ) ) NEW_LINE if ( row * column < l ) : NEW_LINE INDENT row = column NEW_LINE DEDENT s = [ [ 0 for j in range ( column ) ] for i in range ( row ) ] NEW_LINE for i in range ( row ) : NEW_LINE INDENT for j in range ( column ) : NEW_LINE INDENT if k >= l : NEW_LINE INDENT s [ i ] [ j ] = \" ▁ \" NEW_LINE k += 1 NEW_LINE DEDENT else : NEW_LINE INDENT s [ i ] [ j ] = string [ k ] NEW_LINE k += 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( row ) : NEW_LINE INDENT for j in range ( column ) : NEW_LINE INDENT if s [ i ] [ j ] == \" ▁ \" : NEW_LINE INDENT break NEW_LINE DEDENT print ( s [ i ] [ j ] , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" GEEKSFORGEEKS \" NEW_LINE gridStr ( string ) NEW_LINE DEDENT"],"bleu":0.6665201476088538,"rouge_l":0.8009226401703337}
{"id":1001,"predictions":["def maxProfit ( prices , start , end ) : NEW_LINE INDENT if ( end <= start ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT profit = 0 ; NEW_LINE for i in range ( start , end ) : NEW_LINE INDENT for j in range ( i + 1 , end + 1 ) : NEW_LINE INDENT if ( price [ j ] > price [ i ] ) : NEW_LINE INDENT curr_fit = price [ j ] - prices [ i ] + maxProfit ( price , start , i - 1 ) ; NEW_LINE profit = max ( profit , curr_ Profit ) ; NEW_LINE DEDENT DEDENT DEDENT return profit ; NEW_LINE DEDENT price = [ 100 , 180 , 260 , 310 , 40 , 535 , 695 ] ; NEW_LINE n = len ( prices ) ; NEW_LINE print ( maxProfit ( price , 0 , n - 1 ) ) ; NEW_LINE"],"references":["def maxProfit ( price , start , end ) : NEW_LINE INDENT if ( end <= start ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT profit = 0 ; NEW_LINE for i in range ( start , end , 1 ) : NEW_LINE INDENT for j in range ( i + 1 , end + 1 ) : NEW_LINE INDENT if ( price [ j ] > price [ i ] ) : NEW_LINE INDENT curr_profit = price [ j ] - price [ i ] + \\ NEW_LINE INDENT maxProfit ( price , start , i - 1 ) +   \\ NEW_LINE maxProfit ( price , j + 1 , end ) ; NEW_LINE DEDENT profit = max ( profit , curr_profit ) ; NEW_LINE DEDENT DEDENT DEDENT return profit ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT price = [ 100 , 180 , 260 , 310 , 40 , 535 , 695 ] ; NEW_LINE n = len ( price ) ; NEW_LINE print ( maxProfit ( price , 0 , n - 1 ) ) ; NEW_LINE DEDENT"],"bleu":0.7131234169732485,"rouge_l":0.8544355946168635}
{"id":1002,"predictions":["def maximum_middle_value ( n , k , arr ) : NEW_LINE INDENT ans = - 1 NEW_LINE low = int ( ( n + 1 - k ) \/ 2 ) NEW_LINE high = int ( ( n + 1 - k ) \/ 2 + k ) NEW_LINE for i in range ( low , high + 1 ) : NEW_LINE INDENT ans = max ( ans , arr [ i - 1 ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT n = 5 NEW_LINE k = 2 NEW_LINE arr = [ 9 , 5 , 3 , 7 , 10 ] NEW_LINE print ( maximum_middle_value ( n , k , arr ) ) NEW_LINE n = 9 NEW_LINE k = 3 NEW_LINE arr1 = [ 2 , 4 , 3 , 9 , 5 , 8 , 7 , 6 , 10 ] NEW_LINE print ( maximum_middle_value ( n , k , arr1 ) ) NEW_LINE"],"references":["def maximum_middle_value ( n , k , arr ) : NEW_LINE INDENT ans = - 1 NEW_LINE low = ( n + 1 - k ) \/\/ 2 NEW_LINE high = ( n + 1 - k ) \/\/ 2 + k NEW_LINE for i in range ( low , high + 1 ) : NEW_LINE INDENT ans = max ( ans , arr [ i - 1 ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n , k = 5 , 2 NEW_LINE arr = [ 9 , 5 , 3 , 7 , 10 ] NEW_LINE print ( maximum_middle_value ( n , k , arr ) ) NEW_LINE n , k = 9 , 3 NEW_LINE arr1 = [ 2 , 4 , 3 , 9 , 5 , 8 , 7 , 6 , 10 ] NEW_LINE print ( maximum_middle_value ( n , k , arr1 ) ) NEW_LINE DEDENT"],"bleu":0.7826010016008518,"rouge_l":0.8849486197864195}
{"id":1003,"predictions":["def countRec ( n , sum ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return sum == 0 NEW_LINE DEDENT if ( sum == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT if ( sum - i >= 0 ) : NEW_LINE INDENT ans += countRec ( n - 1 , sum - i ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def finalCount ( n , Sum ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT if ( Sum - i >= 0 ) : NEW_LINE INDENT ans += countRec ( n - 1 , Sum - i ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT n , Sum = 2 , 5 NEW_LINE print ( finalCount ( n , Sum ) ) NEW_LINE"],"references":["def countRec ( n , sum ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return ( sum == 0 ) NEW_LINE DEDENT if ( sum == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 0 , 10 ) : NEW_LINE INDENT if ( sum - i >= 0 ) : NEW_LINE INDENT ans = ans + countRec ( n - 1 , sum - i ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def finalCount ( n , sum ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT if ( sum - i >= 0 ) : NEW_LINE INDENT ans = ans + countRec ( n - 1 , sum - i ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT n = 2 NEW_LINE sum = 5 NEW_LINE print ( finalCount ( n , sum ) ) NEW_LINE"],"bleu":0.7930775330862778,"rouge_l":0.914626682986536}
{"id":1004,"predictions":["def calculateSum ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE MOD = 1000000007 NEW_LINE while ( k ) : NEW_LINE INDENT if ( k & 1 ) : NEW_LINE INDENT res = ( res * n ) % MOD NEW_LINE DEDENT k = k \/\/ 2 NEW_LINE n = ( ( n * n ) % MOD NEW_LINE DEDENT return res NEW_LINE DEDENT n = 4 NEW_LINE k = 3 NEW_LINE print ( calculateSum ( n , k ) ) NEW_LINE"],"references":["def calculateSum ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE MOD = 1000000007 NEW_LINE while k > 0 : NEW_LINE INDENT if ( k & 1 ) == 1 : NEW_LINE INDENT res = ( res * n ) % MOD NEW_LINE DEDENT k = k \/\/ 2 NEW_LINE n = ( n * n ) % MOD NEW_LINE DEDENT return res NEW_LINE DEDENT n = 4 NEW_LINE k = 3 NEW_LINE print ( calculateSum ( n , k ) ) NEW_LINE"],"bleu":0.8991417488556691,"rouge_l":0.9580540126412564}
{"id":1005,"predictions":["def countPairs ( s , K ) : NEW_LINE INDENT if ( K > s or ( s - K ) % 2 == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( ( s - K ) \/\/ 2 == 1 & K == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT setBits = bin ( K ) . count ( '1' ) NEW_LINE pairsCount = int ( math . pow ( 2 , setBits ) ) NEW_LINE if ( s == K ) : NEW_LINE INDENT pairsCount -= 2 NEW_LINE DEDENT return pairsCount NEW_LINE DEDENT s = 9 ; NEW_LINE K = 5 NEW_LINE print ( countPairs ( s , K ) ) NEW_LINE"],"references":["def countPairs ( s , K ) : NEW_LINE INDENT if ( K > s or ( s - K ) % 2 == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT setBits = ( str ( bin ( K ) ) [ 2 : ] ) . count ( \"1\" ) NEW_LINE pairsCount = pow ( 2 , setBits ) NEW_LINE if ( s == K ) : NEW_LINE INDENT pairsCount -= 2 NEW_LINE DEDENT return pairsCount NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s , K = 9 , 5 NEW_LINE print ( countPairs ( s , K ) ) NEW_LINE DEDENT"],"bleu":0.6751039692736219,"rouge_l":0.7535141275024846}
{"id":1006,"predictions":["def splitString ( st ) : NEW_LINE INDENT alpha = [ ] NEW_LINE num = list ( ) NEW_LINE special = [ ] NEW_LINE for i in range ( len ( st ) ) : NEW_LINE INDENT if ( st [ i ] . isdigit ( ) : NEW_LINE INDENT num . append ( st [ i ] ) NEW_LINE DEDENT elif ( st [ i ] . isalpha ( ) ) : NEW_LINE INDENT alpha . append ( st [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT special . append ( st [ i ] ) NEW_LINE DEDENT DEDENT print ( alpha ) NEW_LINE print ( \" { 0 : . format ( num ) ) NEW_LINE print ( finalString ( s ) ) NEW_LINE"],"references":["def splitString ( str ) : NEW_LINE INDENT alpha = \" \" NEW_LINE num = \" \" NEW_LINE special = \" \" NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] . isdigit ( ) ) : NEW_LINE INDENT num = num + str [ i ] NEW_LINE DEDENT elif ( ( str [ i ] >= ' A ' and str [ i ] <= ' Z ' ) or ( str [ i ] >= ' a ' and str [ i ] <= ' z ' ) ) : NEW_LINE INDENT alpha += str [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT special += str [ i ] NEW_LINE DEDENT DEDENT print ( alpha ) NEW_LINE print ( num ) NEW_LINE print ( special ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeks01 $ $ for02geeks03 ! @ ! ! \" NEW_LINE splitString ( str ) NEW_LINE DEDENT"],"bleu":0.3425768124298466,"rouge_l":0.5736475063398141}
{"id":1007,"predictions":["def atMostK ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE left , right = 0 , 0 NEW_LINE map = { } NEW_LINE while ( right < n ) : NEW_LINE INDENT map [ arr [ right ] ] = map . get ( arr [ right ] , 0 ) + 1 NEW_LINE while ( len ( map ) > k ) : NEW_LINE INDENT map [ arr [ left ] ] -= 1 NEW_LINE if ( map [ arr [ left ] ] == 0 ) : NEW_LINE INDENT map [ arr [ left ] ] = map [ arr [ right ] ] - 1 NEW_LINE DEDENT left += 1 NEW_LINE DEDENT count += right - left + 1 NEW_LINE right += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def sameK ( arr , n , k ) : NEW_LINE INDENT return ( atMostK ( arr , n , k ) - atMostK ( arr , n , k - 1 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 1 , 2 , 1 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE print ( matchingK ( arr , n , k ) ) NEW_LINE DEDENT"],"references":["def atMostK ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE left = 0 NEW_LINE right = 0 NEW_LINE map = { } NEW_LINE while ( right < n ) : NEW_LINE INDENT if arr [ right ] not in map : NEW_LINE INDENT map [ arr [ right ] ] = 0 NEW_LINE DEDENT map [ arr [ right ] ] += 1 NEW_LINE while ( len ( map ) > k ) : NEW_LINE INDENT if arr [ left ] not in map : NEW_LINE INDENT map [ arr [ left ] ] = 0 NEW_LINE DEDENT map [ arr [ left ] ] -= 1 NEW_LINE if map [ arr [ left ] ] == 0 : NEW_LINE INDENT del map [ arr [ left ] ] NEW_LINE DEDENT left += 1 NEW_LINE DEDENT count += right - left + 1 NEW_LINE right += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def exactlyK ( arr , n , k ) : NEW_LINE INDENT return ( atMostK ( arr , n , k ) - atMostK ( arr , n , k - 1 ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 1 , 2 , 1 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE print ( exactlyK ( arr , n , k ) ) NEW_LINE DEDENT"],"bleu":0.7578884579452232,"rouge_l":0.8382708376493336}
{"id":1008,"predictions":["def display ( n ) : NEW_LINE INDENT sp = n \/\/ 2 NEW_LINE st = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , sp + 1 ) : NEW_LINE INDENT print ( \" \" , end = ' ▁ ' ) NEW_LINE DEDENT count = 1 NEW_LINE for k in range ( 1 , st + 1 ) : NEW_LINE INDENT if ( k % 2 == 0 ) : NEW_LINE INDENT print ( \" * \" , end = ' ▁ ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( count + 1 , end = st + 2 ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE if ( i <= n \/\/ 2 ) : NEW_LINE INDENT sp = sp - 1 NEW_LINE st = st + 2 NEW_LINE DEDENT else : NEW_LINE INDENT sp = sp + 1 NEW_LINE st = st - 2 NEW_LINE DEDENT DEDENT n = 5 NEW_LINE print ( display ( n ) ) NEW_LINE display ( n ) NEW_LINE"],"references":["def display ( n ) : NEW_LINE INDENT sp = n \/\/ 2 NEW_LINE st = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , sp + 1 ) : NEW_LINE INDENT print ( end = \" ▁ \" ) NEW_LINE DEDENT count = 1 NEW_LINE for k in range ( 1 , st + 1 ) : NEW_LINE INDENT if ( k % 2 == 0 ) : NEW_LINE INDENT print ( \" * \" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( count , end = \" \" ) NEW_LINE count += 1 NEW_LINE DEDENT DEDENT print ( ) NEW_LINE if ( i <= n \/\/ 2 ) : NEW_LINE INDENT sp = sp - 1 NEW_LINE st = st + 2 NEW_LINE DEDENT else : NEW_LINE INDENT sp = sp + 1 NEW_LINE st = st - 2 NEW_LINE DEDENT DEDENT DEDENT n = 5 NEW_LINE display ( n ) NEW_LINE"],"bleu":0.8389425815245402,"rouge_l":0.9152245949926362}
{"id":1009,"predictions":["R = 3 NEW_LINE C = 5 NEW_LINE def maxArea ( mat ) : NEW_LINE INDENT hist = [ [ 0 for i in range ( C + 1 ) ] for j in range ( C ) ] NEW_LINE for i in range ( C ) : NEW_LINE INDENT hist [ 0 ] [ i ] = mat [ 0 ] [ i ] NEW_LINE for j in range ( 1 , R , 1 ) : NEW_LINE INDENT hist [ j ] [ i ] = mat [ j ] [ i ] + 1 NEW_LINE DEDENT DEDENT for i in range ( R ) : NEW_LINE INDENT count = [ 0 ] * ( R + 1 ) NEW_LINE for j in range ( C ) : NEW_LINE INDENT count [ hist [ i ] [ j ] += 1 NEW_LINE DEDENT col_no = 0 NEW_LINE for j in range ( R , - 1 , - 1 ) : NEW_LINE INDENT if ( count [ j ] > 0 ) : NEW_LINE INDENT for k in range ( count [ j ] ) : NEW_LINE INDENT hist [ i ] [ col_no ] = j NEW_LINE col_no += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT curr_area = 0 NEW_LINE for i in range ( R ) : NEW_LINE INDENT for j in range ( C ) : NEW_LINE INDENT curr_area = ( j + 1 ) * hist [ i ] [ j ] NEW_LINE if ( curr_area > max_area ) : NEW_LINE INDENT max_area = curr_area NEW_LINE DEDENT DEDENT DEDENT return max_area NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT mat = [ [ 0 , 1 , 0 , 1 , 0 ] , [ 0 , 1 , 1 ] , [ 0 , 1 , 1 , 1 ] , [ 1 , 1 , 0 ] ] NEW_LINE print ( \" Area ▁ of ▁ the ▁ largest ▁ rectangle ▁ is \" , maxArea ( mat ) ) NEW_LINE DEDENT"],"references":["R = 3 NEW_LINE C = 5 NEW_LINE def maxArea ( mat ) : NEW_LINE INDENT hist = [ [ 0 for i in range ( C + 1 ) ] for i in range ( R + 1 ) ] NEW_LINE for i in range ( 0 , C , 1 ) : NEW_LINE INDENT hist [ 0 ] [ i ] = mat [ 0 ] [ i ] NEW_LINE for j in range ( 1 , R , 1 ) : NEW_LINE INDENT if ( ( mat [ j ] [ i ] == 0 ) ) : NEW_LINE INDENT hist [ j ] [ i ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT hist [ j ] [ i ] = hist [ j - 1 ] [ i ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 0 , R , 1 ) : NEW_LINE INDENT count = [ 0 for i in range ( R + 1 ) ] NEW_LINE for j in range ( 0 , C , 1 ) : NEW_LINE INDENT count [ hist [ i ] [ j ] ] += 1 NEW_LINE DEDENT col_no = 0 NEW_LINE j = R NEW_LINE while ( j >= 0 ) : NEW_LINE INDENT if ( count [ j ] > 0 ) : NEW_LINE INDENT for k in range ( 0 , count [ j ] , 1 ) : NEW_LINE INDENT hist [ i ] [ col_no ] = j NEW_LINE col_no += 1 NEW_LINE DEDENT DEDENT j -= 1 NEW_LINE DEDENT DEDENT max_area = 0 NEW_LINE for i in range ( 0 , R , 1 ) : NEW_LINE INDENT for j in range ( 0 , C , 1 ) : NEW_LINE INDENT curr_area = ( j + 1 ) * hist [ i ] [ j ] NEW_LINE if ( curr_area > max_area ) : NEW_LINE INDENT max_area = curr_area NEW_LINE DEDENT DEDENT DEDENT return max_area NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT mat = [ [ 0 , 1 , 0 , 1 , 0 ] , [ 0 , 1 , 0 , 1 , 1 ] , [ 1 , 1 , 0 , 1 , 0 ] ] NEW_LINE print ( \" Area ▁ of ▁ the ▁ largest ▁ rectangle ▁ is \" , maxArea ( mat ) ) NEW_LINE DEDENT"],"bleu":0.7289851432177908,"rouge_l":0.8442545920546775}
{"id":1010,"predictions":["def lcs ( dp , a , b , m , n ) : NEW_LINE INDENT for i in range ( 100 ) : NEW_LINE INDENT if ( m < 0 or n < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( m < 0 or n < 0 ) : NEW_LINE INDENT return dp [ m ] [ n ] NEW_LINE DEDENT if ( dp [ m ] [ n ] != - 1 ) : NEW_LINE INDENT return dp [ m ] [ n ] NEW_LINE DEDENT ans = 0 NEW_LINE if ( a [ m ] == b [ n ] ) : NEW_LINE INDENT ans = ( ord ( lp [ m ] ) - 48 ) + lcs ( dp , a , b , m - 1 , n - 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( lcs ( dp , a , b , m - 1 , n ) , lcs ( dp , a , b , m , n - 1 ) ) NEW_LINE DEDENT dp [ m ] [ n ] = ans NEW_LINE return ans NEW_LINE DEDENT def costOfString ( str ) : NEW_LINE INDENT cost = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT cost += ( ord ( str [ i ] ) - 48 ) NEW_LINE DEDENT return cost NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = \"9142\" NEW_LINE b = \"1429\" NEW_LINE dp = [ [ [ 0 for i in range ( 101 ) ] for j in range ( 101 ) ] NEW_LINE print ( costOfString ( a ) + costOfString ( b ) - 2 * lcs ( dp , a , b , len ( b ) - 1 ) ) NEW_LINE DEDENT"],"references":["def lcs ( dp , a , b , m , n ) : NEW_LINE INDENT for i in range ( 100 ) : NEW_LINE INDENT for j in range ( 100 ) : NEW_LINE INDENT dp [ i ] [ j ] = - 1 NEW_LINE DEDENT DEDENT if ( m < 0 or n < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ m ] [ n ] != - 1 ) : NEW_LINE INDENT return dp [ m ] [ n ] NEW_LINE DEDENT ans = 0 NEW_LINE if ( a [ m ] == b [ n ] ) : NEW_LINE INDENT ans = ( ord ( a [ m ] ) - 48 ) + lcs ( dp , a , b , m - 1 , n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( lcs ( dp , a , b , m - 1 , n ) , lcs ( dp , a , b , m , n - 1 ) ) NEW_LINE DEDENT dp [ m ] [ n ] = ans NEW_LINE return ans NEW_LINE DEDENT def costOfString ( s ) : NEW_LINE INDENT cost = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT cost += ( ord ( s [ i ] ) - 48 ) NEW_LINE DEDENT return cost NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = \"9142\" NEW_LINE b = \"1429\" NEW_LINE dp = [ [ 0 for x in range ( 101 ) ] for y in range ( 101 ) ] NEW_LINE print ( costOfString ( a ) + costOfString ( b ) - 2 * lcs ( dp , a , b , len ( a ) - 1 , len ( b ) - 1 ) ) NEW_LINE DEDENT"],"bleu":0.8612068870630173,"rouge_l":0.9066809684339565}
{"id":1011,"predictions":["def maxUniqueNum ( arr , N , M ) : NEW_LINE INDENT maxUnique = 0 ; NEW_LINE for i in range ( N - M ) : NEW_LINE INDENT currentUnique = 0 ; NEW_LINE map = dict . fromkeys ( arr , 0 ) ; NEW_LINE for k in range ( i , i + M ) : NEW_LINE INDENT if ( arr [ k ] in map ) : NEW_LINE INDENT map [ arr [ k ] ] += 1 ; NEW_LINE currentUnique += 1 ; NEW_LINE continue ; NEW_LINE DEDENT DEDENT if ( currentUnique > maxUnique ) : NEW_LINE INDENT maxUnique = currentUnique ; NEW_LINE DEDENT DEDENT return maxUnique ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 3 , 5 , 2 , 3 , 2 ] ; NEW_LINE N = 6 ; NEW_LINE M = 3 ; NEW_LINE print ( maxUniqueNum ( arr , N , M ) ) ; NEW_LINE DEDENT"],"references":["def maxUniqueNum ( a , N , M ) : NEW_LINE INDENT maxUnique = 0 NEW_LINE for i in range ( N - M ) : NEW_LINE INDENT s = set ( ) NEW_LINE for j in range ( M ) : NEW_LINE INDENT s . add ( a [ i + j ] ) NEW_LINE DEDENT if ( len ( s ) > maxUnique ) : NEW_LINE INDENT maxUnique = len ( s ) NEW_LINE DEDENT DEDENT return maxUnique NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 3 , 5 , 2 , 3 , 2 ] NEW_LINE M = 3 NEW_LINE N = len ( arr ) NEW_LINE print ( maxUniqueNum ( arr , N , M ) ) NEW_LINE DEDENT"],"bleu":0.5142500148507344,"rouge_l":0.7338852097130243}
{"id":1012,"predictions":["def complement ( s ) : NEW_LINE INDENT comps = \" \" ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT comps += '1' ; NEW_LINE DEDENT else : NEW_LINE INDENT comps += '0' ; NEW_LINE DEDENT DEDENT return comps ; NEW_LINE DEDENT def nthTerm ( n ) : NEW_LINE INDENT s = \"0\" ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT s += complement ( s ) ; NEW_LINE DEDENT return s ; NEW_LINE DEDENT n = 4 ; NEW_LINE print ( nthTerm ( n ) ) ; NEW_LINE"],"references":["def complement ( s ) : NEW_LINE INDENT comps = \" \" ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT comps += '1' ; NEW_LINE DEDENT else : NEW_LINE INDENT comps += '0' ; NEW_LINE DEDENT DEDENT return comps ; NEW_LINE DEDENT def nthTerm ( n ) : NEW_LINE INDENT s = \"0\" ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT s += complement ( s ) ; NEW_LINE DEDENT return s ; NEW_LINE DEDENT n = 4 ; NEW_LINE print ( nthTerm ( n ) ) ; NEW_LINE"],"bleu":1.0,"rouge_l":1.0}
{"id":1013,"predictions":["def evenFibSum ( limit ) : NEW_LINE INDENT if ( limit < 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ef1 , ef2 = 0 , 2 NEW_LINE sum = ef1 + ef2 NEW_LINE while ( ef2 <= limit ) : NEW_LINE INDENT ef3 = 4 * ef2 + ef1 NEW_LINE if ( ef3 > limit ) : NEW_LINE INDENT break NEW_LINE DEDENT ef1 = ef2 NEW_LINE ef2 = ef3 NEW_LINE sum += ef2 NEW_LINE DEDENT return int ( sum ) NEW_LINE DEDENT limit = 400 NEW_LINE print ( evenFibSum ( limit ) ) NEW_LINE"],"references":["def evenFibSum ( limit ) : NEW_LINE INDENT if ( limit < 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ef1 = 0 NEW_LINE ef2 = 2 NEW_LINE sm = ef1 + ef2 NEW_LINE while ( ef2 <= limit ) : NEW_LINE INDENT ef3 = 4 * ef2 + ef1 NEW_LINE if ( ef3 > limit ) : NEW_LINE INDENT break NEW_LINE DEDENT ef1 = ef2 NEW_LINE ef2 = ef3 NEW_LINE sm = sm + ef2 NEW_LINE DEDENT return sm NEW_LINE DEDENT limit = 400 NEW_LINE print ( evenFibSum ( limit ) ) NEW_LINE"],"bleu":0.8244805742684964,"rouge_l":0.9013745704467354}
{"id":1014,"predictions":["def factorial ( N ) : NEW_LINE INDENT fact = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT fact = fact * i NEW_LINE DEDENT return fact NEW_LINE DEDENT def nthTerm ( N ) : NEW_LINE INDENT return ( factorial ( N ) * ( N + 2 ) \/\/ 2 ) NEW_LINE DEDENT N = 6 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE"],"references":["def factorial ( N ) : NEW_LINE INDENT fact = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT fact = fact * i NEW_LINE DEDENT return fact NEW_LINE DEDENT def nthTerm ( N ) : NEW_LINE INDENT return ( factorial ( N ) * ( N + 2 ) \/\/ 2 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 6 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT"],"bleu":0.8104420845269639,"rouge_l":0.899561578318055}
{"id":1015,"predictions":["def answer ( X , K ) : NEW_LINE INDENT I = 10 ; NEW_LINE MAX = pow ( i , K ) - 1 ; NEW_LINE return ( MAX - ( MAX % X ) ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT X = 30 ; NEW_LINE K = 3 ; NEW_LINE print ( answer ( X , K ) ) ; NEW_LINE DEDENT"],"references":["def answer ( X , K ) : NEW_LINE INDENT MAX = pow ( 10 , K ) - 1 NEW_LINE return ( MAX - ( MAX % X ) ) NEW_LINE DEDENT X = 30 ; NEW_LINE K = 3 ; NEW_LINE print ( answer ( X , K ) ) ; NEW_LINE"],"bleu":0.6041661323688517,"rouge_l":0.8465566902330451}
{"id":1016,"predictions":["def maxLength ( a , n ) : NEW_LINE INDENT maximum = 1 NEW_LINE left = [ 0 for i in range ( n ) ] NEW_LINE right = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( a [ i ] > a [ i + 1 ] ) : NEW_LINE INDENT right [ i ] = right [ i + 1 ] + 1 NEW_LINE DEDENT maximum = max ( maximum , right [ i ] ) NEW_LINE DEDENT for i in range ( 1 , n , 2 ) : NEW_LINE INDENT if ( a [ i ] < a [ i - 1 ] ) : NEW_LINE INDENT left [ i ] = left [ i - 1 ] + 1 NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( a [ i - 1 ] > a [ i + 1 ] ) : NEW_LINE INDENT maximum = max ( maximum , left [ i - 1 ] + right [ i + 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return maximum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 8 , 7 , 3 , 5 , 2 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxLength ( arr , n ) ) NEW_LINE DEDENT"],"references":["def maxLength ( a , n ) : NEW_LINE INDENT maximum = 1 ; NEW_LINE left = [ 0 ] * n ; NEW_LINE right = [ 0 ] * n ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT left [ i ] = 1 ; NEW_LINE right [ i ] = 1 ; NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( a [ i ] > a [ i + 1 ] ) : NEW_LINE INDENT right [ i ] = right [ i + 1 ] + 1 ; NEW_LINE DEDENT maximum = max ( maximum , right [ i ] ) ; NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( a [ i ] < a [ i - 1 ] ) : NEW_LINE INDENT left [ i ] = left [ i - 1 ] + 1 ; NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( a [ i - 1 ] > a [ i + 1 ] ) : NEW_LINE INDENT maximum = max ( maximum , left [ i - 1 ] + right [ i + 1 ] ) ; NEW_LINE DEDENT DEDENT DEDENT return maximum ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 8 , 7 , 3 , 5 , 2 , 9 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( maxLength ( arr , n ) ) ; NEW_LINE DEDENT"],"bleu":0.7888338908662348,"rouge_l":0.9066945363757765}
{"id":1017,"predictions":["n = 3 NEW_LINE a = [ 1 , 2 , 3 ] NEW_LINE i = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT x = sum \/ n NEW_LINE if ( x * n == sum ) : NEW_LINE INDENT print ( x ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT"],"references":["if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE a = [ 1 , 2 , 3 ] NEW_LINE i = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT x = sum \/\/ n NEW_LINE if ( x * n == sum ) : NEW_LINE INDENT print ( x ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT DEDENT"],"bleu":0.8015806568413314,"rouge_l":0.888757629454617}
{"id":1018,"predictions":["import math NEW_LINE def getPerfectSquares ( n ) : NEW_LINE INDENT perfectSquares = [ ] NEW_LINE current = 1 NEW_LINE i = 1 NEW_LINE while ( current <= n ) : NEW_LINE INDENT perfectSquares . append ( current ) NEW_LINE current = int ( math . pow ( n , 2 ) ) NEW_LINE i += 1 NEW_LINE DEDENT return perfectSquares NEW_LINE DEDENT def countTriplets ( n ) : NEW_LINE INDENT perfectSquares = getPerfectSquares ( n ) NEW_LINE count = 0 NEW_LINE for a in range ( 1 , n + 1 ) : NEW_LINE INDENT aSquare = [ ] NEW_LINE bSquare = int ( math . pow ( a , 2 ) ) NEW_LINE bSquare = int ( math . sqrt ( bSquare ) ) NEW_LINE bSquare = int ( math . sqrt ( bSquare ) ) NEW_LINE c = int ( math . sqrt ( cSquare ) ) NEW_LINE if ( c < a or ( bSquare ) == cSquare ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( ( b >= a ) and ( b <= c ) and ( aSquare + bSquare == cSquare ) ) ) : NEW_LINE INDENT cont += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT n = 10 NEW_LINE print ( countTriplets ( n ) ) NEW_LINE"],"references":["import math NEW_LINE def getPerfectSquares ( n ) : NEW_LINE INDENT perfectSquares = [ ] NEW_LINE current = 1 NEW_LINE i = 1 NEW_LINE while ( current <= n ) : NEW_LINE INDENT perfectSquares . append ( current ) NEW_LINE i += 1 NEW_LINE current = i ** 2 NEW_LINE DEDENT return perfectSquares NEW_LINE DEDENT def countTriplets ( n ) : NEW_LINE INDENT perfectSquares = getPerfectSquares ( n ** 2 ) NEW_LINE count = 0 NEW_LINE for a in range ( 1 , n + 1 ) : NEW_LINE INDENT aSquare = a ** 2 NEW_LINE for i in range ( len ( perfectSquares ) ) : NEW_LINE INDENT cSquare = perfectSquares [ i ] NEW_LINE bSquare = abs ( cSquare - aSquare ) NEW_LINE b = math . sqrt ( bSquare ) NEW_LINE b = int ( b ) NEW_LINE c = math . sqrt ( cSquare ) NEW_LINE c = int ( c ) NEW_LINE if ( c < a or ( bSquare not in perfectSquares ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( ( b >= a ) and ( b <= c ) and ( aSquare + bSquare == cSquare ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 10 NEW_LINE print ( countTriplets ( n ) ) NEW_LINE DEDENT"],"bleu":0.6734178263152788,"rouge_l":0.7716000857571642}
{"id":1019,"predictions":["def centered_innagonal_num ( n ) : NEW_LINE INDENT return ( 5 * n * n - 5 * n + 2 ) \/\/ 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 7 NEW_LINE print ( n , \" r ▁ Centered ▁ p \" + \" number : ▁ \" , centered_innagonal_num ( n ) ) NEW_LINE DEDENT"],"references":["def centered_pentagonal_Num ( n ) : NEW_LINE INDENT return ( 5 * n * n - 5 * n + 2 ) \/\/ 2 NEW_LINE DEDENT n = 7 NEW_LINE print ( \" % sth ▁ Centered ▁ pentagonal ▁ number ▁ : ▁ \" % n , centered_pentagonal_Num ( n ) ) NEW_LINE"],"bleu":0.5222213388227935,"rouge_l":0.7532930845225028}
{"id":1020,"predictions":["def PossibleValues ( b , x , n ) : NEW_LINE INDENT leastdivisible = ( b \/ x + 1 ) * x NEW_LINE flag = 1 NEW_LINE while ( leastdivisible <= n ) : NEW_LINE INDENT if ( leastdivisible - b >= 1 ) : NEW_LINE INDENT print ( leastdivisible - b , end = \" ▁ \" ) NEW_LINE leastdivisible += x NEW_LINE flag = 0 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( leastdivisible <= n ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT b = 15 NEW_LINE x = 6 NEW_LINE n = 40 NEW_LINE PossibleValues ( b , x , n ) NEW_LINE DEDENT"],"references":["def PossibleValues ( b , x , n ) : NEW_LINE INDENT leastdivisible = int ( b \/ x + 1 ) * x NEW_LINE flag = 1 NEW_LINE while ( leastdivisible <= n ) : NEW_LINE INDENT if ( leastdivisible - b >= 1 ) : NEW_LINE INDENT print ( leastdivisible - b , end = \" ▁ \" ) NEW_LINE leastdivisible += x NEW_LINE flag = 0 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( flag != 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT b = 10 NEW_LINE x = 6 NEW_LINE n = 40 NEW_LINE PossibleValues ( b , x , n ) NEW_LINE DEDENT"],"bleu":0.926603848779363,"rouge_l":0.9648506151142355}
{"id":1021,"predictions":["def findLongestRepeatingSubSeq ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE dp = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( str [ i - 1 ] == str [ j - 1 ] and i != j ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ n ] NEW_LINE DEDENT def findLongestRepeatingSubSeq ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE dp = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( str [ i - 1 ] == str [ j - 1 ] and i != j ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ n ] NEW_LINE DEDENT print ( dp [ n ] [ n ] ) NEW_LINE"],"references":["def findLongestRepeatingSubSeq ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE dp = [ [ 0 for k in range ( n + 1 ) ] for l in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( str [ i - 1 ] == str [ j - 1 ] and i != j ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ n ] NEW_LINE DEDENT"],"bleu":0.4913111843349572,"rouge_l":0.706902756783992}
{"id":1022,"predictions":["def countIntegralSolutions ( n ) : NEW_LINE INDENT return int ( ( ( n + 1 ) * ( n + 2 ) ) \/ 2 ) NEW_LINE DEDENT n = 3 NEW_LINE print ( countIntegralSolutions ( n ) ) NEW_LINE"],"references":["def countIntegralSolutions ( n ) : NEW_LINE INDENT return int ( ( ( n + 1 ) * ( n + 2 ) ) \/ 2 ) NEW_LINE DEDENT n = 3 NEW_LINE print ( countIntegralSolutions ( n ) ) NEW_LINE"],"bleu":1.0,"rouge_l":1.0}
{"id":1023,"predictions":["def check ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count & 1 ) : NEW_LINE INDENT return \" Odd \" NEW_LINE DEDENT else : NEW_LINE INDENT return \" Even \" NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 9 , 12 , 13 , 15 ] NEW_LINE n = len ( arr ) NEW_LINE print ( check ( arr , n ) ) NEW_LINE DEDENT"],"references":["def check ( arr , n ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT count = count + 1 ; NEW_LINE DEDENT DEDENT if ( count & 1 ) : NEW_LINE INDENT return \" Odd \" ; NEW_LINE DEDENT else : NEW_LINE INDENT return \" Even \" ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 9 , 12 , 13 , 15 ] NEW_LINE n = len ( arr ) NEW_LINE print ( check ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.881591864423493,"rouge_l":0.9610353073568716}
{"id":1024,"predictions":["def dfs ( graph , node , dist , vis , c ) : NEW_LINE INDENT if ( vis [ node ] : NEW_LINE INDENT return NEW_LINE DEDENT vis [ node ] = True NEW_LINE dist [ node ] = c NEW_LINE for i in range ( len ( graph [ node ] ) ) : NEW_LINE INDENT if ( vis [ graph [ node ] [ i ] ] == 0 ) : NEW_LINE INDENT dfs ( graph , graph , graph [ node ] [ i ] , dist , vis , c + 1 ) NEW_LINE DEDENT DEDENT DEDENT def countOfNodes ( graph , n ) : NEW_LINE INDENT vis = [ False ] * ( n + 1 ) NEW_LINE dist = [ 0 ] * ( n + 1 ) NEW_LINE dfs ( graph , 1 , dist , vis , c ) NEW_LINE even , odd = 0 , 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( dist [ i ] % 2 == 0 ) : NEW_LINE INDENT even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT ans = ( ( even * ( even - 1 ) ) + ( odd * ( odd - 1 ) ) ) \/\/ 2 NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE graph = [ ] NEW_LINE graph = [ ] NEW_LINE graph [ 0 ] = 1 NEW_LINE graph [ 1 ] = [ ] NEW_LINE graph [ 2 ] = [ 3 ] NEW_LINE graph [ 3 ] = 1 NEW_LINE graph [ 2 ] = [ 1 ] * ( 2 ) NEW_LINE graph [ 2 ] = [ 3 ] * ( 1 , 2 ) NEW_LINE graph [ 3 ] = [ 2 ] * 2 NEW_LINE graph [ 3 ] = 2 NEW_LINE ans = countOfNodes ( graph , n ) NEW_LINE print ( ans ) NEW_LINE DEDENT"],"references":["def dfs ( graph , node , dist , vis , c ) : NEW_LINE INDENT if ( vis [ node ] ) : NEW_LINE INDENT return ; NEW_LINE DEDENT vis [ node ] = True ; NEW_LINE dist [ node ] = c ; NEW_LINE for i in range ( len ( graph [ node ] ) ) : NEW_LINE INDENT if ( not vis [ graph [ node ] [ i ] ] ) : NEW_LINE INDENT dfs ( graph , graph [ node ] [ i ] , dist , vis , c + 1 ) ; NEW_LINE DEDENT DEDENT DEDENT def countOfNodes ( graph , n ) : NEW_LINE INDENT vis = [ False ] * ( n + 1 ) ; NEW_LINE dist = [ 0 ] * ( n + 1 ) ; NEW_LINE dfs ( graph , 1 , dist , vis , 0 ) ; NEW_LINE even = 0 ; odd = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( dist [ i ] % 2 == 0 ) : NEW_LINE INDENT even += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 ; NEW_LINE DEDENT DEDENT ans = ( ( even * ( even - 1 ) ) + ( odd * ( odd - 1 ) ) ) \/\/ 2 ; NEW_LINE return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 ; NEW_LINE graph = [ [ ] , [ 2 ] , [ 1 , 3 ] , [ 2 ] ] ; NEW_LINE ans = countOfNodes ( graph , n ) ; NEW_LINE print ( ans ) ; NEW_LINE DEDENT"],"bleu":0.65450299187104,"rouge_l":0.8482257815316475}
{"id":1025,"predictions":["def flipsPossible ( a , n ) : NEW_LINE INDENT count_odd = 0 NEW_LINE count_even = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( a [ i ] & 1 ) ) : NEW_LINE INDENT count_odd += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_even += 1 NEW_LINE DEDENT DEDENT if ( count_odd % 2 == 1 and count_even % 2 == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 0 , 1 , 1 , 0 , 1 ] NEW_LINE n = len ( a ) NEW_LINE if ( flipsPossible ( a , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def flipsPossible ( a , n ) : NEW_LINE INDENT count_odd = 0 ; count_even = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] & 1 ) : NEW_LINE INDENT count_odd += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT count_even += 1 ; NEW_LINE DEDENT DEDENT if ( count_odd % 2 and count_even % 2 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT else : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 0 , 1 , 1 , 0 , 1 ] ; NEW_LINE n = len ( a ) ; NEW_LINE if ( flipsPossible ( a , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"],"bleu":0.7771481546849363,"rouge_l":0.9317331670822941}
{"id":1026,"predictions":["def findSeries ( num , first , sec ) : NEW_LINE INDENT print ( first , second ) NEW_LINE count = 0 NEW_LINE while ( counter < num - 2 ) : NEW_LINE INDENT sm = first + sum NEW_LINE print ( sm , end = \" ▁ \" ) NEW_LINE first = sec NEW_LINE second = sum NEW_LINE counter += 1 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE first = 2 NEW_LINE second = 4 NEW_LINE findSeries ( n , first , sec ) NEW_LINE DEDENT"],"references":["def findSeries ( num , first , sec ) : NEW_LINE INDENT print ( \" { } ▁ { } ▁ \" . format ( first , sec ) , end = \" \" ) NEW_LINE counter = 0 NEW_LINE while ( counter < num - 2 ) : NEW_LINE INDENT sum = first + sec NEW_LINE print ( \" { } ▁ \" . format ( sum ) , end = \" \" ) NEW_LINE first = sec NEW_LINE sec = sum NEW_LINE counter = counter + 1 NEW_LINE DEDENT DEDENT n = 5 NEW_LINE first = 2 NEW_LINE sec = 4 NEW_LINE findSeries ( n , first , sec ) NEW_LINE"],"bleu":0.5316179332886917,"rouge_l":0.7151339829476249}
{"id":1027,"predictions":["def countOdd ( n ) : NEW_LINE INDENT coun = 0 NEW_LINE for i in range ( n - 2 , 0 , - 1 ) : NEW_LINE INDENT if ( i >= 1 ) : NEW_LINE INDENT m = ( n - i ) \/\/ 2 NEW_LINE j = ( i * ( i + 1 ) ) \/\/ 2 NEW_LINE coun += j * m NEW_LINE DEDENT else : NEW_LINE INDENT m = ( ( n - 1 ) - i ) \/\/ 2 NEW_LINE j = ( i * ( i + 1 ) ) \/\/ 2 NEW_LINE coun += j * m NEW_LINE DEDENT DEDENT return coun NEW_LINE DEDENT def countEven ( n ) : NEW_LINE INDENT coun = 0 NEW_LINE for i in range ( n - 2 , 0 , - 1 , - 1 ) : NEW_LINE INDENT if ( i >= 1 ) : NEW_LINE INDENT m = ( ( n - 1 ) - i ) \/\/ 2 NEW_LINE j = ( i * ( i + 1 ) ) \/\/ 2 NEW_LINE coun += j * m NEW_LINE DEDENT else : NEW_LINE INDENT m = ( ( n - i ) \/\/ 2 ) \/\/ 2 NEW_LINE j = ( i * ( i + 1 ) ) \/\/ 2 NEW_LINE coun += j * m NEW_LINE DEDENT DEDENT return coun NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE if ( n >= 1 ) : NEW_LINE INDENT print ( countOdd ( n ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( countEven ( n ) ) NEW_LINE DEDENT DEDENT"],"references":["def countOdd ( n ) : NEW_LINE INDENT coun = 0 NEW_LINE i = n - 2 NEW_LINE while ( i >= 1 ) : NEW_LINE INDENT if ( i & 1 ) : NEW_LINE INDENT m = int ( ( n - i ) \/ 2 ) NEW_LINE j = int ( ( i * ( i + 1 ) ) \/ 2 ) NEW_LINE coun += j * m NEW_LINE DEDENT else : NEW_LINE INDENT m = int ( ( ( n - 1 ) - i ) \/ 2 ) NEW_LINE j = int ( ( i * ( i + 1 ) ) \/ 2 ) NEW_LINE coun += j * m NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT return coun NEW_LINE DEDENT def countEven ( n ) : NEW_LINE INDENT coun = 0 NEW_LINE i = n - 2 NEW_LINE while ( i >= 1 ) : NEW_LINE INDENT if ( i & 1 ) : NEW_LINE INDENT m = int ( ( ( n - 1 ) - i ) \/ 2 ) NEW_LINE j = int ( ( i * ( i + 1 ) ) \/ 2 ) NEW_LINE coun += j * m NEW_LINE DEDENT else : NEW_LINE INDENT m = int ( ( n - i ) \/ 2 ) NEW_LINE j = ( i * ( i + 1 ) ) \/\/ 2 NEW_LINE coun += j * m NEW_LINE DEDENT DEDENT return coun NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE if ( n & 1 ) : NEW_LINE INDENT print ( countOdd ( n ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( countEven ( n ) ) NEW_LINE DEDENT DEDENT"],"bleu":0.7236453870418398,"rouge_l":0.8647351180390828}
{"id":1028,"predictions":["mod = 1e9 + 7 ; NEW_LINE def factorial ( n , p ) : NEW_LINE INDENT res = 1 ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res = ( res * i ) % p ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT def power ( x , y , p ) : NEW_LINE INDENT res = 1 ; NEW_LINE x = x % p ; NEW_LINE while ( y ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p ; NEW_LINE DEDENT y = y >> 1 ; NEW_LINE x = ( x * x ) % p ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT def modInverse ( n , p ) : NEW_LINE INDENT return power ( n , p - 2 , p ) ; NEW_LINE DEDENT def nCrModP ( n , r , p ) : NEW_LINE INDENT if ( r == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT fac = [ ] * ( n + 1 ) ; NEW_LINE fac [ 0 ] = 1 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fac [ n ] = fac [ i - 1 ] * i % p ; NEW_LINE DEDENT return ( fac [ n ] * modInverse ( fac [ r ] , p ) % p * modInverse ( fac [ n - ( r ] , p ) % p ) % p * modInverse ( fac [ n - ( r ] , p ) % p ) % p ; NEW_LINE DEDENT def countArrangement ( n , k , p ) : NEW_LINE INDENT return ( factorial ( n , p ) * nCrP ( k , n , p ) ) % p ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 ; NEW_LINE K = 8 ; NEW_LINE print ( countArrang ( N , K , mod ) ) ; NEW_LINE DEDENT"],"references":["mod = 10 ** 9 + 7 NEW_LINE def factorial ( n , p ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res = ( res * i ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def modInverse ( n , p ) : NEW_LINE INDENT return power ( n , p - 2 , p ) NEW_LINE DEDENT def nCrModP ( n , r , p ) : NEW_LINE INDENT if ( r == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT fac = [ 0 for i in range ( n + 1 ) ] NEW_LINE fac [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fac [ i ] = fac [ i - 1 ] * i % p NEW_LINE DEDENT return ( fac [ n ] * modInverse ( fac [ r ] , p ) % p * modInverse ( fac [ n - r ] , p ) % p ) % p NEW_LINE DEDENT def countArrangements ( n , k , p ) : NEW_LINE INDENT return ( factorial ( n , p ) * nCrModP ( k , n , p ) ) % p NEW_LINE DEDENT N = 5 NEW_LINE K = 8 NEW_LINE print ( countArrangements ( N , K , mod ) ) NEW_LINE"],"bleu":0.7114011178405113,"rouge_l":0.8997050147492625}
{"id":1029,"predictions":["def subString ( st , n ) : NEW_LINE INDENT for l in range ( 1 , n + 1 ) : NEW_LINE INDENT for i in range ( n - l + 1 ) : NEW_LINE INDENT j = i + l - 1 NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT print ( st [ k ] , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT DEDENT st = [ ' a ' , ' b ' , ' c ' ] NEW_LINE subString ( st , len ( st ) ) NEW_LINE"],"references":["def subString ( Str , n ) : NEW_LINE INDENT for Len in range ( 1 , n + 1 ) : NEW_LINE INDENT for i in range ( n - Len + 1 ) : NEW_LINE INDENT j = i + Len - 1 NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT print ( Str [ k ] , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT DEDENT Str = \" abc \" NEW_LINE subString ( Str , len ( Str ) ) NEW_LINE"],"bleu":0.6761095201088182,"rouge_l":0.8506567212583104}
{"id":1030,"predictions":["def sumofseries ( n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT res += ( i ) * ( i + 1 ) * ( i + 2 ) NEW_LINE DEDENT return res NEW_LINE DEDENT print ( sumofseries ( 3 ) ) NEW_LINE"],"references":["def sumofseries ( n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT res += ( i ) * ( i + 1 ) * ( i + 2 ) NEW_LINE DEDENT return res NEW_LINE DEDENT print ( sumofseries ( 3 ) ) NEW_LINE"],"bleu":1.0,"rouge_l":1.0}
{"id":1031,"predictions":["def countWaysToJump ( arr , n ) : NEW_LINE INDENT count_Jump = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] >= n - i - 1 ) : NEW_LINE INDENT count_jump [ i ] += 1 NEW_LINE DEDENT for j in range ( i + 1 , n - 1 and j <= arr [ i ] + i ) : NEW_LINE INDENT if ( count_Jump [ j ] != - 1 ) : NEW_LINE INDENT count_Jump [ i ] += count_Jump [ j ] NEW_LINE DEDENT DEDENT if ( count_Jump [ i ] == 0 ) : NEW_LINE INDENT count_Jump [ i ] = - 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( count_Jump [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT arr = [ 1 , 3 , 5 , 8 , 9 , 1 , 0 , 7 , 6 , 8 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE countWaysToJump ( arr , n ) NEW_LINE"],"references":["def countWaysToJump ( arr , n ) : NEW_LINE INDENT count_jump = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] >= n - i - 1 ) : NEW_LINE INDENT count_jump [ i ] += 1 NEW_LINE DEDENT j = i + 1 NEW_LINE while ( j < n - 1 and j <= arr [ i ] + i ) : NEW_LINE INDENT if ( count_jump [ j ] != - 1 ) : NEW_LINE INDENT count_jump [ i ] += count_jump [ j ] NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( count_jump [ i ] == 0 ) : NEW_LINE INDENT count_jump [ i ] = - 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( count_jump [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 1 , 3 , 5 , 8 , 9 , 1 , 0 , 7 , 6 , 8 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE countWaysToJump ( arr , n ) NEW_LINE"],"bleu":0.8197719447862073,"rouge_l":0.9176948181166921}
{"id":1032,"predictions":["import math NEW_LINE def calculateSum ( n ) : NEW_LINE INDENT return 2 * ( pow ( n , 6 ) + 15 * pow ( n , 4 ) + 15 * pow ( n , 2 ) + 1 ) NEW_LINE DEDENT n = 1.4142 NEW_LINE print ( round ( calculateSum ( n ) ) ) NEW_LINE"],"references":["import math NEW_LINE def calculateSum ( n ) : NEW_LINE INDENT a = int ( n ) NEW_LINE return ( 2 * ( pow ( n , 6 ) + 15 * pow ( n , 4 ) + 15 * pow ( n , 2 ) + 1 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 1.4142 NEW_LINE print ( math . ceil ( calculateSum ( n ) ) ) NEW_LINE DEDENT"],"bleu":0.5729596239494099,"rouge_l":0.7863969771060234}
{"id":1033,"predictions":["import math as mt NEW_LINE def isMajority ( a , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a in mp : NEW_LINE INDENT mp [ a [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ a [ i ] ] = 1 NEW_LINE DEDENT DEDENT for x in mp . values ( ) : NEW_LINE INDENT if ( x >= n \/ 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT a = [ 2 , 3 , 9 , 2 , 2 ] NEW_LINE n = len ( a ) NEW_LINE if ( isMajority ( a , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def isMajority ( a ) : NEW_LINE INDENT mp = { } NEW_LINE for i in a : NEW_LINE INDENT if i in mp : mp [ i ] += 1 NEW_LINE else : mp [ i ] = 1 NEW_LINE DEDENT for x in mp : NEW_LINE INDENT if mp [ x ] >= len ( a ) \/\/ 2 : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT a = [ 2 , 3 , 9 , 2 , 2 ] NEW_LINE print ( \" Yes \" if isMajority ( a ) else \" No \" ) NEW_LINE"],"bleu":0.44322287306440933,"rouge_l":0.7139782053006862}
{"id":1034,"predictions":["def return maxMaxSum ( A , B , n ) : NEW_LINE INDENT mp = set ( ) NEW_LINE result = 0 NEW_LINE curr_sum = 0 NEW_LINE curr_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while A [ curr_ ] in mp : NEW_LINE INDENT if A [ curr_r_sum in mp . keys ( ) : NEW_LINE INDENT curr_sum -= B [ curr_id ] NEW_LINE curr_sum += 1 NEW_LINE curr_sum += 1 NEW_LINE DEDENT mp . add ( A [ i ] ) NEW_LINE curr_sum += B [ i ] NEW_LINE result = max ( result , curr_sum ) NEW_LINE DEDENT return result NEW_LINE DEDENT A = [ 0 , 1 , 2 , 3 , 0 , 1 , 4 ] NEW_LINE B = [ 9 , 8 , 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( A ) NEW_LINE print ( return maxMaxSum ( A , B , n ) ) NEW_LINE"],"references":["def returnMaxSum ( A , B , n ) : NEW_LINE INDENT mp = set ( ) NEW_LINE result = 0 NEW_LINE curr_sum = curr_begin = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT while A [ i ] in mp : NEW_LINE INDENT mp . remove ( A [ curr_begin ] ) NEW_LINE curr_sum -= B [ curr_begin ] NEW_LINE curr_begin += 1 NEW_LINE DEDENT mp . add ( A [ i ] ) NEW_LINE curr_sum += B [ i ] NEW_LINE result = max ( result , curr_sum ) NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 0 , 1 , 2 , 3 , 0 , 1 , 4 ] NEW_LINE B = [ 9 , 8 , 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( A ) NEW_LINE print ( returnMaxSum ( A , B , n ) ) NEW_LINE DEDENT"],"bleu":0.7618207550527222,"rouge_l":0.8531880003858396}
{"id":1035,"predictions":["def hasPath ( root , arr , x ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return False NEW_LINE DEDENT arr . append ( root . data ) NEW_LINE if ( root . data == x ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( hasPath ( root . left , arr , x ) or hasPath ( root . right , arr , x ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT arr . pop ( ) NEW_LINE return False NEW_LINE DEDENT def printPath ( root , x ) : NEW_LINE INDENT arr = [ ] NEW_LINE if ( hasPath ( root , arr , x ) == True ) : NEW_LINE INDENT for i in range ( 0 , len ( arr ) - 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" - > \" ) NEW_LINE DEDENT print ( \" No ▁ Path \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No ▁ Path \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 1 ) NEW_LINE root . left = newNode ( 2 ) NEW_LINE root . right = newNode ( 3 ) NEW_LINE root . left . left = newNode ( 4 ) NEW_LINE root . left . right = newNode ( 5 ) NEW_LINE root . right = newNode ( 7 ) NEW_LINE root . right . left = newNode ( 7 ) NEW_LINE root . right . right = newNode ( 7 ) NEW_LINE x = 5 NEW_LINE printPath ( root , x ) NEW_LINE DEDENT"],"references":["class getNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = self . right = None NEW_LINE DEDENT DEDENT def hasPath ( root , arr , x ) : NEW_LINE INDENT if ( not root ) : NEW_LINE INDENT return False NEW_LINE DEDENT arr . append ( root . data ) NEW_LINE if ( root . data == x ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( hasPath ( root . left , arr , x ) or hasPath ( root . right , arr , x ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT arr . pop ( - 1 ) NEW_LINE return False NEW_LINE DEDENT def printPath ( root , x ) : NEW_LINE INDENT arr = [ ] NEW_LINE if ( hasPath ( root , arr , x ) ) : NEW_LINE INDENT for i in range ( len ( arr ) - 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" - > \" ) NEW_LINE DEDENT print ( arr [ len ( arr ) - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No ▁ Path \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = getNode ( 1 ) NEW_LINE root . left = getNode ( 2 ) NEW_LINE root . right = getNode ( 3 ) NEW_LINE root . left . left = getNode ( 4 ) NEW_LINE root . left . right = getNode ( 5 ) NEW_LINE root . right . left = getNode ( 6 ) NEW_LINE root . right . right = getNode ( 7 ) NEW_LINE x = 5 NEW_LINE printPath ( root , x ) NEW_LINE DEDENT"],"bleu":0.7674563362927526,"rouge_l":0.8559275218207933}
{"id":1036,"predictions":["def SieveOfEratosthenes ( prime , p_size ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , p_size + 1 ) : NEW_LINE INDENT if ( p * p <= p_size ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT def xorOfEratosthenes ( prime , n + 1 ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) NEW_LINE SieveOfEratosthenes ( prime , n + 1 ) NEW_LINE m = dict ( ) NEW_LINE for key in range ( n ) : NEW_LINE INDENT m [ value ] = m . get ( key , 0 ) + 1 NEW_LINE if ( prime [ value ] ) : NEW_LINE INDENT xor ^= ( key ) NEW_LINE DEDENT DEDENT xor = 0 NEW_LINE for key , value in m . items ( ) : NEW_LINE INDENT if ( prime [ key ] ) : NEW_LINE INDENT xor ^= key NEW_LINE DEDENT DEDENT return xor NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 4 , 6 , 5 , 4 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( xorOfElements ( arr , n ) ) NEW_LINE DEDENT"],"references":["from math import sqrt NEW_LINE def SieveOfEratosthenes ( prime , p_size ) : NEW_LINE INDENT prime [ 0 ] = False ; NEW_LINE prime [ 1 ] = False ; NEW_LINE for p in range ( 2 , int ( sqrt ( p_size ) ) + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( p * 2 , p_size + 1 , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT DEDENT return prime NEW_LINE DEDENT def xorPrimeFreq ( arr , n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) ; NEW_LINE prime = SieveOfEratosthenes ( prime , n + 1 ) ; NEW_LINE m = dict . fromkeys ( arr , 0 ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT m [ arr [ i ] ] += 1 ; NEW_LINE DEDENT xorVal = 0 ; NEW_LINE for key , value in m . items ( ) : NEW_LINE INDENT if ( prime [ value ] ) : NEW_LINE INDENT xorVal ^= key ; NEW_LINE DEDENT DEDENT return xorVal ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 5 , 4 , 6 , 5 , 4 , 6 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( xorPrimeFreq ( arr , n ) ) ; NEW_LINE DEDENT"],"bleu":0.5766718311805076,"rouge_l":0.7420214583475706}
{"id":1037,"predictions":["def minimumFlip ( s , x , y ) : NEW_LINE INDENT s = s + s NEW_LINE isOpposite = False NEW_LINE if ( x > y ) : NEW_LINE INDENT break NEW_LINE DEDENT val = s [ x ] NEW_LINE cur = s [ x ] NEW_LINE for i in range ( y , x + 1 ) : NEW_LINE INDENT if ( s [ i ] != cur ) : NEW_LINE INDENT cur = s [ i ] NEW_LINE val += 1 NEW_LINE DEDENT DEDENT valClockwise = 0 NEW_LINE cur = s [ y ] NEW_LINE x = len ( s ) NEW_LINE for i in range ( y , x ) : NEW_LINE INDENT if ( s [ i ] != cur ) : NEW_LINE INDENT cur = s [ i ] NEW_LINE valLeftwise += 1 NEW_LINE DEDENT DEDENT if ( not isOppwise ) : NEW_LINE INDENT if ( not isOpposite ) : NEW_LINE INDENT print ( \" Clockwise ▁ \" , valClockwise ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Clock \" , val ) NEW_LINE DEDENT DEDENT if ( not isOppip ) : NEW_LINE INDENT print ( \" Clockwise ▁ \" , valClockwise \" , val ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Correct \" , val ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x , y = 0 , 8 NEW_LINE y = 8 NEW_LINEString = \"00100\" NEW_LINE minimumFlip ( s , x , y ) NEW_LINE minimumFlip ( s , x , y ) NEW_LINE DEDENT"],"references":["def minimumFlip ( s , x , y ) : NEW_LINE INDENT s = s + s NEW_LINE isOpposite = False NEW_LINE if ( x > y ) : NEW_LINE INDENT temp = y NEW_LINE y = x ; NEW_LINE x = temp NEW_LINE isOpposite = True NEW_LINE DEDENT valClockwise = 0 NEW_LINE cur = s [ x ] NEW_LINE for i in range ( x , y + 1 , 1 ) : NEW_LINE INDENT if ( s [ i ] != cur ) : NEW_LINE INDENT cur = s [ i ] NEW_LINE valClockwise += 1 NEW_LINE DEDENT DEDENT valAnticlockwise = 0 NEW_LINE cur = s [ y ] NEW_LINE x += len ( s ) - 1 NEW_LINE for i in range ( y , x + 1 , 1 ) : NEW_LINE INDENT if ( s [ i ] != cur ) : NEW_LINE INDENT cur = s [ i ] NEW_LINE valAnticlockwise += 1 NEW_LINE DEDENT DEDENT if ( valClockwise <= valAnticlockwise ) : NEW_LINE INDENT if ( isOpposite == False ) : NEW_LINE INDENT print ( \" Clockwise \" , valClockwise ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Anti - clockwise \" , valAnticlockwise ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( isOpposite == False ) : NEW_LINE INDENT print ( \" Anti - clockwise \" , valAnticlockwise ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Clockwise \" , valClockwise ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 0 NEW_LINE y = 8 NEW_LINE s = \"000110\" NEW_LINE minimumFlip ( s , x , y ) NEW_LINE DEDENT"],"bleu":0.688192680119173,"rouge_l":0.8163192799621033}
{"id":1038,"predictions":["MAX = 26 NEW_LINE def maxSubStr ( str1 , str2 , str2 ) : NEW_LINE INDENT if ( len1 > len2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT freq1 = [ 0 ] * MAX NEW_LINE for i in range ( len1 )1 : NEW_LINE INDENT freq1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT freq2 = [ 0 ] * MAX NEW_LINE freq2 = [ 0 ] * MAX NEW_LINE for i in range ( len2 ) : NEW_LINE INDENT freq2 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT minPoss = 10 ** 9 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if ( freq1 [ i ] == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( freq1 [ i ] > freq2 [ i ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( freq1 [ i ] > freq2 [ i ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT minPoss = min ( minPpos , freq2 [ i ] \/\/ freq1 [ i ] ) NEW_LINE DEDENT return minPoss NEW_LINE DEDENT str1 = \" gs \" NEW_LINE str2 = \" gskee \" NEW_LINE len1 = len ( str1 ) NEW_LINE len2 = len ( str2 ) NEW_LINE print ( maxSubStr ( str1 , len1 , str2 ) ) NEW_LINE"],"references":["import sys NEW_LINE MAX = 26 ; NEW_LINE def maxSubStr ( str1 , len1 , str2 , len2 ) : NEW_LINE INDENT if ( len1 > len2 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT freq1 = [ 0 ] * MAX ; NEW_LINE for i in range ( len1 ) : NEW_LINE INDENT freq1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT freq2 = [ 0 ] * MAX ; NEW_LINE for i in range ( len2 ) : NEW_LINE INDENT freq2 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT minPoss = sys . maxsize ; NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if ( freq1 [ i ] == 0 ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT if ( freq1 [ i ] > freq2 [ i ] ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT minPoss = min ( minPoss , freq2 [ i ] \/ freq1 [ i ] ) ; NEW_LINE DEDENT return int ( minPoss ) ; NEW_LINE DEDENT str1 = \" geeks \" ; str2 = \" gskefrgoekees \" ; NEW_LINE len1 = len ( str1 ) ; NEW_LINE len2 = len ( str2 ) ; NEW_LINE print ( maxSubStr ( str1 , len1 , str2 , len2 ) ) ; NEW_LINE"],"bleu":0.7087029063889378,"rouge_l":0.8524844720496894}
{"id":1039,"predictions":["def isValidString ( string , n ) : NEW_LINE INDENT index = 0 NEW_LINE if ( index == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( index != - 1 ) : NEW_LINE INDENT if ( string [ index - 1 ] != ' a ' ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( index + 1 < n and string [ index + 1 ] != ' b ' ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( index + 2 < n and string [ index + 2 ] == ' b ' ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( index == n - 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT index = string [ index + 2 ] NEW_LINE index + 2 NEW_LINE DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" abbaabbaabbabba \" NEW_LINE n = len ( string ) NEW_LINE if ( isValidString ( string , n ) ) : NEW_LINE INDENT print ( \" truea \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" b \" , index + 2 ) NEW_LINE DEDENT DEDENT"],"references":["def isValidString ( str , n ) : NEW_LINE INDENT idx = str . find ( \" b \" ) NEW_LINE if ( idx == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( idx != - 1 ) : NEW_LINE INDENT if ( str [ idx - 1 ] != ' a ' ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( idx + 1 < n and str [ idx + 1 ] != ' b ' ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( idx + 2 < n and str [ idx + 2 ] == ' b ' ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( idx == n - 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT idx = str . find ( \" b \" , idx + 2 ) NEW_LINE DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" abbaaabbabba \" NEW_LINE n = len ( str ) NEW_LINE print ( isValidString ( str , n ) ) NEW_LINE DEDENT"],"bleu":0.6226000503759294,"rouge_l":0.7744891953249811}
{"id":1040,"predictions":["def gcd ( a , b ) : NEW_LINE INDENT if ( ( a % b ) == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT def firstFactorialDivisibleNumber ( x ) : NEW_LINE INDENT i = 1 NEW_LINE new_x = x NEW_LINE for i in range ( 1 , x ) : NEW_LINE INDENT new_x \/= gcd ( i , new_x ) NEW_LINE if ( new_x == 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return i NEW_LINE DEDENT x = 16 NEW_LINE print ( firstFactorialDivisibleNumber ( x ) ) NEW_LINE"],"references":["def gcd ( a , b ) : NEW_LINE INDENT if ( ( a % b ) == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT def firstFactorialDivisibleNumber ( x ) : NEW_LINE INDENT i = 1 NEW_LINE new_x = x NEW_LINE for i in range ( 1 , x ) : NEW_LINE INDENT new_x \/= gcd ( i , new_x ) NEW_LINE if ( new_x == 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return i NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT x = 16 NEW_LINE print ( firstFactorialDivisibleNumber ( x ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"bleu":0.7673741120494363,"rouge_l":0.8714285714285713}
{"id":1041,"predictions":["def xorLessK ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT tempXor = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT tempXor ^= arr [ j ] NEW_LINE if tempXor < k : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT k = 3 NEW_LINE arr = [ 8 , 9 , 10 , 11 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE print ( xorLessK ( arr , n , k ) ) NEW_LINE DEDENT"],"references":["def xorLessK ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT tempXor = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT tempXor ^= arr [ j ] NEW_LINE if ( tempXor < k ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT k = 3 NEW_LINE arr = [ 8 , 9 , 10 , 11 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE print ( xorLessK ( arr , n , k ) ) NEW_LINE DEDENT"],"bleu":0.9577229431491263,"rouge_l":0.9900962861072903}
{"id":1042,"predictions":["def findNumbers ( arr , n ) : NEW_LINE INDENT num = [ 0 ] * n ; NEW_LINE b_minus_a = int ( arr [ n - 1 ] - arr [ 1 ] ) ; NEW_LINE num [ 0 ] = ( arr [ 0 ] + b_minus_a ) \/\/ 2 ; NEW_LINE num [ 0 ] = arr [ 0 ] - num [ 1 ] ; NEW_LINE for i in range ( 1 , n - 2 ) : NEW_LINE INDENT num [ i + 1 ] = arr [ i ] - num [ 0 ] ; NEW_LINE DEDENT print ( \" Numbers ▁ are : ▁ \" , end = \" \" ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( num [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 12 , 40 , 12 , 13 , 18 , 28 ] ; NEW_LINE n = 5 ; NEW_LINE findNumbers ( arr , n ) ; NEW_LINE DEDENT"],"references":["def findNumbers ( arr , n ) : NEW_LINE INDENT num = [ 0 for i in range ( n ) ] NEW_LINE b_minus_a = arr [ n - 1 ] - arr [ 1 ] NEW_LINE num [ 1 ] = ( arr [ 0 ] + b_minus_a ) \/\/ 2 NEW_LINE num [ 0 ] = arr [ 0 ] - num [ 1 ] NEW_LINE for i in range ( 1 , ( n - 2 ) + 1 ) : NEW_LINE INDENT num [ i + 1 ] = arr [ i ] - num [ 0 ] NEW_LINE DEDENT print ( \" Numbers ▁ are : ▁ \" , end = \" \" ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( num [ i ] , end = \" , ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 13 , 10 , 14 , 9 , 17 , 21 , 16 , 18 , 13 , 17 ] NEW_LINE n = 5 NEW_LINE findNumbers ( arr , n ) NEW_LINE"],"bleu":0.6698324673256008,"rouge_l":0.8401165357111328}
{"id":1043,"predictions":["pr = [ ] ; NEW_LINE prime = [ True ] * ( 10000000 + 1 ) ; NEW_LINE def sieve ( n ) : NEW_LINE INDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT prime [ i ] = True ; NEW_LINE DEDENT p = 2 ; NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT p += 1 ; NEW_LINE DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT pr . append ( p ) ; NEW_LINE DEDENT DEDENT def SemiPrimeSum ( N ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( len ( pr ) ) : NEW_LINE INDENT for j in range ( i , len ( pr ) ) : NEW_LINE INDENT if ( pr [ i ] * pr [ j ] > N ) : NEW_LINE INDENT break ; NEW_LINE DEDENT ans += pr [ i ] * pr [ j ] ; NEW_LINE pr [ j ] ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT N = 6 ; NEW_LINE sieve ( N ) ; NEW_LINE print ( SemiPrimeSum ( N ) ) ; NEW_LINE"],"references":["pr = [ ] NEW_LINE prime = [ 1 for i in range ( 10000000 + 1 ) ] NEW_LINE def sieve ( n ) : NEW_LINE INDENT for p in range ( 2 , n ) : NEW_LINE INDENT if p * p > n : NEW_LINE INDENT break NEW_LINE DEDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( 2 * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT pr . append ( p ) NEW_LINE DEDENT DEDENT DEDENT def SemiPrimeSum ( N ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( len ( pr ) ) : NEW_LINE INDENT for j in range ( i , len ( pr ) ) : NEW_LINE INDENT if ( pr [ i ] * pr [ j ] > N ) : NEW_LINE INDENT break NEW_LINE DEDENT ans += pr [ i ] * pr [ j ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT N = 6 NEW_LINE sieve ( N ) NEW_LINE print ( SemiPrimeSum ( N ) ) NEW_LINE"],"bleu":0.7149969531326235,"rouge_l":0.882636655948553}
{"id":1044,"predictions":["def largestPalinSub ( s ) : NEW_LINE INDENT res = \" \" NEW_LINE mx = s [ 0 ] NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT mx = max ( mx , s [ i ] ) NEW_LINE DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == mx ) : NEW_LINE INDENT res += s [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT s = \" geeksforgeeks \" NEW_LINE print ( largestPalinSub ( s ) ) NEW_LINE"],"references":["def largestPalinSub ( s ) : NEW_LINE INDENT res = \" \" NEW_LINE mx = s [ 0 ] NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT mx = max ( mx , s [ i ] ) NEW_LINE DEDENT for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT if s [ i ] == mx : NEW_LINE INDENT res += s [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" geeksforgeeks \" NEW_LINE print ( largestPalinSub ( s ) ) NEW_LINE DEDENT"],"bleu":0.7980152609931561,"rouge_l":0.9052089642640824}
{"id":1045,"predictions":["def allPapi ( s1 , s2 , n , s2 ) : NEW_LINE INDENT if s1 >= s2 : NEW_LINE INDENT for i in range ( 0 , len ( s1 ) ) : NEW_LINE INDENT print ( s1 [ i ] [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s1 [ i ] [ end = \" \" ) NEW_LINE DEDENT DEDENT def allPalindi ( s1 , arr2 , n , s1 ) : NEW_LINE INDENT if s1 != s2 : NEW_LINE INDENT allPap = [ ] NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT for j in range ( len ( s2 ) ) : NEW_LINE INDENT print ( s1 [ i ] [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT print ( ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"references":["def isPalindrome ( string : str , low : int , high : int ) : NEW_LINE INDENT while low < high : NEW_LINE INDENT if string [ low ] != string [ high ] : NEW_LINE INDENT return False NEW_LINE DEDENT low += 1 NEW_LINE high -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def allPalPartUtil ( allPart : list , currPart : list , start : int , n : int , string : str ) : NEW_LINE INDENT if start >= n : NEW_LINE INDENT x = currPart . copy ( ) NEW_LINE allPart . append ( x ) NEW_LINE return NEW_LINE DEDENT for i in range ( start , n ) : NEW_LINE INDENT if isPalindrome ( string , start , i ) : NEW_LINE INDENT currPart . append ( string [ start : i + 1 ] ) NEW_LINE allPalPartUtil ( allPart , currPart , i + 1 , n , string ) NEW_LINE currPart . pop ( ) NEW_LINE DEDENT DEDENT DEDENT def allPalPartitions ( string : str ) : NEW_LINE INDENT n = len ( string ) NEW_LINE allPart = [ ] NEW_LINE currPart = [ ] NEW_LINE allPalPartUtil ( allPart , currPart , 0 , n , string ) NEW_LINE for i in range ( len ( allPart ) ) : NEW_LINE INDENT for j in range ( len ( allPart [ i ] ) ) : NEW_LINE INDENT print ( allPart [ i ] [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" nitin \" NEW_LINE allPalPartitions ( string ) NEW_LINE DEDENT"],"bleu":0.2629851395720867,"rouge_l":0.4797185430463576}
{"id":1046,"predictions":["def findLength ( str , n ) : NEW_LINE INDENT current_sum = 0 NEW_LINE max_sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT current_sum += ( 1 if ( str [ i ] == '0' ) else - 1 NEW_LINE DEDENT if ( current_sum < 0 ) : NEW_LINE INDENT current_sum = 0 NEW_LINE DEDENT max_sum = max ( current_sum , max_sum ) NEW_LINE DEDENT if ( max_sum == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \"11000001\" NEW_LINE n = len ( str ) NEW_LINE print ( findLength ( str , n ) ) NEW_LINE DEDENT"],"references":["def findLength ( string , n ) : NEW_LINE INDENT current_sum = 0 NEW_LINE max_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT current_sum += ( 1 if string [ i ] == '0' else - 1 ) NEW_LINE if current_sum < 0 : NEW_LINE INDENT current_sum = 0 NEW_LINE DEDENT max_sum = max ( current_sum , max_sum ) NEW_LINE DEDENT return max_sum if max_sum else 0 NEW_LINE DEDENT s = \"11000010001\" NEW_LINE n = 11 NEW_LINE print ( findLength ( s , n ) ) NEW_LINE"],"bleu":0.5085092774935543,"rouge_l":0.7893324917153226}
{"id":1047,"predictions":["defSeries ( Arr , N , K ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if Arr [ i ] == 1 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if K >= ( N - count ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT Arr = [ 5 , 1 , 2 ] NEW_LINE N = len ( Arr ) NEW_LINE K = 2 NEW_LINE result =Series ( Arr , N , K ) NEW_LINE if result == 1 : NEW_LINE INDENT print ( \" Possible \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ Possible \" ) NEW_LINE DEDENT DEDENT"],"references":["def Series ( Arr , N , K ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if Arr [ i ] == 1 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if K >= ( N - count ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT Arr = [ 5 , 1 , 2 ] NEW_LINE N = len ( Arr ) NEW_LINE K = 2 NEW_LINE result = Series ( Arr , N , K ) NEW_LINE if result == 1 : NEW_LINE INDENT print ( \" Possible \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ Possible \" ) NEW_LINE DEDENT"],"bleu":0.7926205706266873,"rouge_l":0.9091827712517366}
{"id":1048,"predictions":["def countDigit ( n ) : NEW_LINE INDENT prime = [ 0 ] * 10 NEW_LINE prime [ 2 ] = False NEW_LINE prime [ 3 ] = True NEW_LINE prime [ 5 ] = prime [ 7 ] = True NEW_LINE temp = n NEW_LINE count = 0 NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT d = temp % 10 NEW_LINE temp \/\/= 10 NEW_LINE if ( d > 0 and n % d == 0 and prime [ d ] == True and prime [ d ] == True ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT n = 1032 NEW_LINE print ( countDigit ( n ) ) NEW_LINE"],"references":["def countDigit ( n ) : NEW_LINE INDENT prime = [ False ] * 10 NEW_LINE prime [ 2 ] = True NEW_LINE prime [ 3 ] = True ; NEW_LINE prime [ 5 ] = True NEW_LINE prime [ 7 ] = True ; NEW_LINE temp = n NEW_LINE count = 0 ; NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT d = temp % 10 ; NEW_LINE temp \/\/= 10 ; NEW_LINE if ( d > 0 and n % d == 0 and prime [ d ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT n = 1032 NEW_LINE print ( countDigit ( n ) ) NEW_LINE"],"bleu":0.8151946413680102,"rouge_l":0.9173565121412803}
{"id":1049,"predictions":["import math as mt NEW_LINE def polyapHot ( n , a ) : NEW_LINE INDENT if ( a < 0 and n < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ( a \/ ( 2 * mt . tan ( ( 180 \/ n ) * 3.14159 \/ 180 ) ) ) NEW_LINE DEDENT a = 9 NEW_LINE n = 6 NEW_LINE print ( polyapHot ( n , a ) ) NEW_LINE"],"references":["from math import tan NEW_LINE def polyapothem ( n , a ) : NEW_LINE INDENT if ( a < 0 and n < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return a \/ ( 2 * tan ( ( 180 \/ n ) * 3.14159 \/ 180 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 9 NEW_LINE n = 6 NEW_LINE print ( ' { 0 : . 6 } ' . format ( polyapothem ( n , a ) ) ) NEW_LINE DEDENT"],"bleu":0.5866930240883573,"rouge_l":0.7529476787030214}
{"id":1050,"predictions":["def evenPowerSum ( n ) : NEW_LINE INDENT return ( 8 * n * n + 1 ) * ( 2 * n + 1 ) * ( 3 * n * n + 3 * n - 1 ) ) \/ 15 NEW_LINE DEDENT n = 4 NEW_LINE print ( evenPowerSum ( n ) ) NEW_LINE"],"references":["def evenPowerSum ( n ) : NEW_LINE INDENT return ( 8 * n * ( n + 1 ) * ( 2 * n + 1 ) * ( 3 * n * n + 3 * n - 1 ) ) \/ 15 ; NEW_LINE DEDENT n = 4 ; NEW_LINE print ( int ( evenPowerSum ( n ) ) ) ; NEW_LINE"],"bleu":0.7857883532744221,"rouge_l":0.9324215607401447}
{"id":1051,"predictions":["def printModulus ( X , Y ) : NEW_LINE INDENT n = max ( X , Y ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( X % i == Y % i ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT X = 10 NEW_LINE Y = 20 NEW_LINE printModulus ( X , Y ) NEW_LINE"],"references":["def printModulus ( X , Y ) : NEW_LINE INDENT n = max ( X , Y ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( X % i == Y % i ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT X = 10 NEW_LINE Y = 20 NEW_LINE printModulus ( X , Y ) NEW_LINE"],"bleu":1.0,"rouge_l":1.0}
{"id":1052,"predictions":["from math import gcd NEW_LINE def minValidNumber ( p , q ) : NEW_LINE INDENT if ( q % p == 0 or q == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return __gcd ( p , q ) NEW_LINE DEDENT return __gcd ( a , b - a ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT p = 2 NEW_LINE q = 6 NEW_LINE print ( minValidNumber ( p , q ) ) NEW_LINE DEDENT"],"references":["from math import gcd NEW_LINE def minValidNumber ( p , q ) : NEW_LINE INDENT if ( q % p == 0 ) : NEW_LINE INDENT return gcd ( p , q ) NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT p , q = 2 , 6 ; NEW_LINE print ( minValidNumber ( p , q ) ) NEW_LINE DEDENT"],"bleu":0.6386178026665906,"rouge_l":0.7885394559135637}
{"id":1053,"predictions":["def maxSum ( arr , n , k ) : NEW_LINE INDENT if ( n < k ) : NEW_LINE INDENT print ( \" Invalid \" ) NEW_LINE return - 1 NEW_LINE DEDENT max_sum = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT max_sum += arr [ i ] - arr [ i - k ] NEW_LINE max_sum = max ( max_sum , window_sum ) NEW_LINE DEDENT return max_sum NEW_LINE DEDENT arr = [ 1 , 4 , 2 , 10 , 2 , 3 , 1 , 0 , 20 ] NEW_LINE k = 4 NEW_LINE n = len ( arr ) NEW_LINE print ( maxSum ( arr , n , k ) ) NEW_LINE"],"references":["import sys NEW_LINE INT_MIN = - sys . maxsize - 1 NEW_LINE def maxSum ( arr , n , k ) : NEW_LINE INDENT if not n > k : NEW_LINE INDENT print ( \" Invalid \" ) NEW_LINE return - 1 NEW_LINE DEDENT max_sum = INT_MIN NEW_LINE window_sum = sum ( arr [ : k ] ) NEW_LINE for i in range ( n - k ) : NEW_LINE INDENT window_sum = window_sum - arr [ i ] + arr [ i + k ] NEW_LINE max_sum = max ( window_sum , max_sum ) NEW_LINE DEDENT return max_sum NEW_LINE DEDENT arr = [ 1 , 4 , 2 , 10 , 2 , 3 , 1 , 0 , 20 ] NEW_LINE k = 4 NEW_LINE n = len ( arr ) NEW_LINE print ( maxSum ( arr , n , k ) ) NEW_LINE"],"bleu":0.6657101922030205,"rouge_l":0.8127422480620156}
{"id":1054,"predictions":["def sortsmallest ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] ) > int ( arr [ j ] ) : NEW_LINE INDENT s = arr [ j ] NEW_LINE arr [ i ] = arr [ j ] NEW_LINE DEDENT DEDENT DEDENT def lexsmallest ( a , n ) : NEW_LINE INDENT a = [ \" c \" , \" cb \" , \" cba \" ] NEW_LINE answer = \" \" NEW_LINE for i in range ( n ) : NEW_LINE INDENT answer += a [ i ] NEW_LINE DEDENT return answer NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ \" c \" , \" cb \" , \" cba \" ] NEW_LINE n = 3 NEW_LINE print ( \" lexi Collections ▁ smallest ▁ string ▁ = ▁ \" , lexsmallest ( a , n ) ) NEW_LINE DEDENT"],"references":["def lexSmallest ( a , n ) : NEW_LINE INDENT a . sort ( reverse = True ) NEW_LINE answer = \" \" NEW_LINE for i in range ( n ) : NEW_LINE INDENT answer += a [ i ] NEW_LINE DEDENT return answer NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ \" c \" , \" cb \" , \" cba \" ] NEW_LINE n = len ( a ) NEW_LINE print ( lexSmallest ( a , n ) ) NEW_LINE DEDENT"],"bleu":0.3793547338485841,"rouge_l":0.6025256314078521}
{"id":1055,"predictions":["def printAnagrams ( arr ) : NEW_LINE INDENT map = dict ( ) NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT word = arr [ i ] NEW_LINE letters = sorted ( words ) NEW_LINE if ( words . keys ( ) > 1 ) : NEW_LINE INDENT map [ words ] . append ( word ) NEW_LINE DEDENT else : NEW_LINE INDENT words = [ ] NEW_LINE words . append ( word ) NEW_LINE DEDENT DEDENT for s in map : NEW_LINE INDENT if ( len ( words ) > 1 ) : NEW_LINE INDENT print ( words ) NEW_LINE DEDENT DEDENT DEDENT arr = [ \" cat \" , \" dog \" , \" dog \" , \" planet \" , \" turn \" ] NEW_LINE printAnagrams ( arr ) NEW_LINE"],"references":["from collections import defaultdict NEW_LINE def printAnagramsTogether ( words ) : NEW_LINE INDENT groupedWords = defaultdict ( list ) NEW_LINE for word in words : NEW_LINE INDENT groupedWords [ \" \" . join ( sorted ( word ) ) ] . append ( word ) NEW_LINE DEDENT for group in groupedWords . values ( ) : NEW_LINE INDENT print ( \" ▁ \" . join ( group ) ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ \" cat \" , \" dog \" , \" tac \" , \" god \" , \" act \" ] NEW_LINE printAnagramsTogether ( arr ) NEW_LINE DEDENT"],"bleu":0.30884937694545134,"rouge_l":0.536703873933027}
{"id":1056,"predictions":["def commonPrefixUtil ( str1 , str2 ) : NEW_LINE INDENT result = \" \" NEW_LINE n1 = len ( str1 ) NEW_LINE n2 = len ( str2 ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while i <= n1 - 1 and j <= n2 - 1 : NEW_LINE INDENT if str1 [ i ] != str2 [ j ] : NEW_LINE INDENT break NEW_LINE DEDENT result += str1 [ i ] NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT return ( result ) NEW_LINE DEDENT def commonPrefix ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE print ( commonPrefixUtil ( arr [ 0 ] , arr [ n - 1 ] ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ \" geeksforgeeks \" , \" geeks \" , \" geek \" , \" geezer \" ] NEW_LINE n = len ( arr ) NEW_LINE commonPrefix ( arr , n ) NEW_LINE DEDENT"],"references":["def commonPrefixUtil ( str1 , str2 ) : NEW_LINE INDENT n1 = len ( str1 ) NEW_LINE n2 = len ( str2 ) NEW_LINE result = \" \" NEW_LINE j = 0 NEW_LINE i = 0 NEW_LINE while ( i <= n1 - 1 and j <= n2 - 1 ) : NEW_LINE INDENT if ( str1 [ i ] != str2 [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT result += ( str1 [ i ] ) NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT return ( result ) NEW_LINE DEDENT def commonPrefix ( arr , n ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE print ( commonPrefixUtil ( arr [ 0 ] , arr [ n - 1 ] ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ \" geeksforgeeks \" , \" geeks \" , \" geek \" , \" geezer \" ] NEW_LINE n = len ( arr ) NEW_LINE commonPrefix ( arr , n ) NEW_LINE DEDENT"],"bleu":0.8653261116739402,"rouge_l":0.9309552266249885}
{"id":1057,"predictions":["import sys NEW_LINE def changeTheArray ( arr , n ) : NEW_LINE INDENT minEle = min ( arr ) NEW_LINE maxEle = min ( arr ) NEW_LINE maxOperations = sys . maxsize NEW_LINE for num in range ( minEle , maxEle + 1 ) : NEW_LINE INDENT operations = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] != num ) : NEW_LINE INDENT operations += ( abs ( num - arr [ i ] ) - 1 ) NEW_LINE DEDENT DEDENT minOperations = min ( minOperations , operations ) NEW_LINE DEDENT return minOperations NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 10 , 1 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( changeTheArray ( arr , n ) ) NEW_LINE DEDENT"],"references":["import math NEW_LINE import sys NEW_LINE def changeTheArray ( arr , n ) : NEW_LINE INDENT minEle = min ( arr ) NEW_LINE maxEle = max ( arr ) NEW_LINE minOperations = sys . maxsize NEW_LINE for num in range ( minEle , maxEle + 1 ) : NEW_LINE INDENT operations = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] != num : NEW_LINE INDENT operations += ( abs ( num - arr [ i ] ) - 1 ) NEW_LINE DEDENT DEDENT minOperations = min ( minOperations , operations ) NEW_LINE DEDENT return minOperations NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 10 , 1 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( changeTheArray ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.9241540958914695,"rouge_l":0.968687094609707}
{"id":1058,"predictions":["def findElements ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( arr [ j ] > arr [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count >= 2 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , - 6 , 3 , 5 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE findElements ( arr , n ) NEW_LINE DEDENT"],"references":["def findElements ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if arr [ j ] > arr [ i ] : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT if count >= 2 : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 2 , - 6 , 3 , 5 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE findElements ( arr , n ) NEW_LINE"],"bleu":0.7577010963061984,"rouge_l":0.9072237960339944}
{"id":1059,"predictions":["def cntSubArrays ( arr , n , k ) : NEW_LINE INDENT res = 0 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT j = i + 1 NEW_LINE while ( j < n and arr [ j ] >= arr [ j - 1 ] ) : NEW_LINE INDENT j += 1 NEW_LINE while ( j < n and arr [ j ] >= arr [ j - 1 ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT res += max ( j - i - k + 1 , 0 ) NEW_LINE i = j NEW_LINE DEDENT return res NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 2 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE print ( cntSubArrays ( arr , n , k ) ) NEW_LINE"],"references":["def cntSubArrays ( arr , n , k ) : NEW_LINE INDENT res = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT j = i + 1 ; NEW_LINE while ( j < n and arr [ j ] >= arr [ j - 1 ] ) : NEW_LINE INDENT j += 1 ; NEW_LINE DEDENT res += max ( j - i - k + 1 , 0 ) ; NEW_LINE i = j ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 2 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE k = 2 ; NEW_LINE print ( cntSubArrays ( arr , n , k ) ) ; NEW_LINE DEDENT"],"bleu":0.7167385713759354,"rouge_l":0.8299319727891158}
{"id":1060,"predictions":["def match_words ( suffix , sentence , n , m ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if dictionary [ i ] in mp . keys ( ) : NEW_LINE INDENT mp [ dictionary [ i ] ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ dictionary [ i ] ] = 1 NEW_LINE DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT if sentence [ i ] in mp . keys ( ) : NEW_LINE INDENT mp [ sentence [ i ] ] = mp [ sentence [ i ] ] - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT password = [ \" find \" , \" a \" , \" geeks \" , \" all \" , \" on \" , \" out \" , \" on \" , \" \" , \" four \" ] NEW_LINE n = len ( password ) NEW_LINE sentence = [ \" find \" , \" all \" , \" answers \" , \" three \" , \" \" , \" four \" ] NEW_LINE m = len ( sentence ) NEW_LINE if ( match_Words ( suffix , sentence , n , m ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"references":["def match_words ( dictionary , sentence , n , m ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ dictionary [ i ] ] = mp . get ( dictionary [ i ] , 0 ) + 1 NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT if ( mp [ sentence [ i ] ] ) : NEW_LINE INDENT mp [ sentence [ i ] ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT dictionary = [ \" find \" , \" a \" , \" geeks \" , \" all \" , \" for \" , \" on \" , \" geeks \" , \" answers \" , \" inter \" ] NEW_LINE n = len ( dictionary ) NEW_LINE sentence = [ \" find \" , \" all \" , \" answers \" , \" on \" , \" geeks \" , \" for \" , \" geeks \" ] NEW_LINE m = len ( sentence ) NEW_LINE if ( match_words ( dictionary , sentence , n , m ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"],"bleu":0.6773241467248711,"rouge_l":0.8095271355730949}
{"id":1061,"predictions":["def sumofproduct ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT y = int ( n \/ x ) NEW_LINE ans = ans + ( y * i ) NEW_LINE DEDENT return ans NEW_LINE DEDENT n = 10 NEW_LINE print ( sumofproduct ( n ) ) NEW_LINE"],"references":["def sumofproduct ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for x in range ( 1 , n + 1 ) : NEW_LINE INDENT y = int ( n \/ x ) NEW_LINE ans += ( y * x ) NEW_LINE DEDENT return ans NEW_LINE DEDENT n = 10 NEW_LINE print ( sumofproduct ( n ) ) NEW_LINE"],"bleu":0.8425274634661079,"rouge_l":0.9371967654986525}
{"id":1062,"predictions":["def isUnique ( a , n , k ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += a [ i ] ; NEW_LINE DEDENT sum += n - 1 ; NEW_LINE return ( sum == k ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 3 , 3 , 3 ] ; NEW_LINE n = len ( a ) ; NEW_LINE k = 12 ; NEW_LINE if ( isUnique ( a , n , k ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"],"references":["def isUnique ( a , n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT sum += n - 1 NEW_LINE return ( sum == k ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 3 , 3 , 3 ] NEW_LINE n = len ( a ) NEW_LINE k = 12 NEW_LINE if ( isUnique ( a , n , k ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.7536833981734019,"rouge_l":0.9345856648014923}
{"id":1063,"predictions":["if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT first = 1 NEW_LINE second = 1 NEW_LINE while first <= 5 : NEW_LINE INDENT second = 5 NEW_LINE for second in 1 : NEW_LINE INDENT print ( 5 * first + second - 5 ) NEW_LINE DEDENT DEDENT"],"references":["if name == ' _ _ main _ _ ' : NEW_LINE INDENT for first in range ( 1 , 6 ) : NEW_LINE INDENT for second in range ( 1 , 6 ) : NEW_LINE INDENT print ( 5 * first + second - 5 ) NEW_LINE DEDENT DEDENT DEDENT"],"bleu":0.5519126795830431,"rouge_l":0.7197066326530611}
{"id":1064,"predictions":["def calculate_ ( s ) : NEW_LINE INDENT if ( len ( s ) == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res_ = 0 NEW_LINE for i in range ( len ( s ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] == '1' and s [ i + 1 ] == '1' ) : NEW_LINE INDENT res_ += 1 NEW_LINE DEDENT else : NEW_LINE INDENT res_ += 1 NEW_LINE while ( len ( s ) > 0 and s [ i ] == '0' ) : NEW_LINE INDENT res_ += 1 NEW_LINE DEDENT if ( s [ i ] == '0' and s [ i + 1 ] == '1' ) : NEW_LINE INDENT res_ += 1 NEW_LINE DEDENT s_ = s [ : i ] NEW_LINE DEDENT return res NEW_LINE DEDENT s = input ( ) NEW_LINE print ( calculate_ ( s ) ) NEW_LINE"],"references":["def calculate_ ( s ) : NEW_LINE INDENT if len ( s ) == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT count_ = 0 NEW_LINE i = len ( s ) - 1 NEW_LINE while i > 0 : NEW_LINE INDENT if s [ i ] == '0' : NEW_LINE INDENT count_ += 1 NEW_LINE i -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_ += 1 NEW_LINE while s [ i ] == '1' and i > 0 : NEW_LINE INDENT count_ += 1 NEW_LINE i -= 1 NEW_LINE DEDENT if i == 0 : NEW_LINE INDENT count_ += 1 NEW_LINE DEDENT s = s [ : i ] + \"1\" + s [ i + 1 : ] NEW_LINE DEDENT DEDENT return count_ NEW_LINE DEDENT s = \"10000100000\" NEW_LINE print ( calculate_ ( s ) ) NEW_LINE"],"bleu":0.4636243836625145,"rouge_l":0.6747787610619468}
{"id":1065,"predictions":["def getWinner ( str , lenn ) : NEW_LINE INDENT total = 0 NEW_LINE for i in range ( lenn ) : NEW_LINE INDENT if ( str [ i ] == ' S ' ) : NEW_LINE INDENT total += 1 NEW_LINE DEDENT DEDENT if ( total % 2 == 1 ) : NEW_LINE INDENT return \" First \" NEW_LINE DEDENT return \" Second \" NEW_LINE DEDENT str = \" GSSS \" NEW_LINE lenn = len ( str ) NEW_LINE print ( getWinner ( str , lenn ) ) NEW_LINE"],"references":["def getWinner ( string , length ) : NEW_LINE INDENT total = 0 ; NEW_LINE for i in range ( length ) : NEW_LINE INDENT if ( string [ i ] == ' S ' ) : NEW_LINE INDENT total += 1 ; NEW_LINE DEDENT DEDENT if ( ( total % 2 ) == 1 ) : NEW_LINE INDENT return \" First \" ; NEW_LINE DEDENT return \" Second \" ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" GSSS \" ; NEW_LINE length = len ( string ) ; NEW_LINE print ( getWinner ( string , length ) ) ; NEW_LINE DEDENT"],"bleu":0.4863079217442163,"rouge_l":0.7820512820512823}
{"id":1066,"predictions":["def countPermutations ( N , B ) : NEW_LINE INDENT x = b ** N ; NEW_LINE y = ( b ** N - 1 ) ; NEW_LINE print ( x - y ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 6 ; NEW_LINE B = 4 ; NEW_LINE countPermutations ( N , B ) ; NEW_LINE DEDENT"],"references":["def countPermutations ( N , B ) : NEW_LINE INDENT x = B ** N NEW_LINE y = B ** ( N - 1 ) NEW_LINE print ( x - y ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N , B = 6 , 4 NEW_LINE countPermutations ( N , B ) NEW_LINE DEDENT"],"bleu":0.5462956734195382,"rouge_l":0.8402203856749311}
{"id":1067,"predictions":["def check ( k , d0 , d1 ) : NEW_LINE INDENT s = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 6 * ( d0 + d1 ) ) % 10 NEW_LINE a = ( k - 3 ) % 4 NEW_LINE x = 0 NEW_LINE if a in a : NEW_LINE INDENT x = 0 NEW_LINE DEDENT elif a == 1 : NEW_LINE INDENT x = ( 2 * ( d0 + d1 ) ) % 10 NEW_LINE DEDENT elif a == 2 : NEW_LINE INDENT x = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 NEW_LINE DEDENT elif 3 : NEW_LINE INDENT x = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 NEW_LINE DEDENT sum = d0 + d1 + ( ( k - 3 ) \/\/ 4 ) * s + x ) % 10 NEW_LINE if ( sum % 3 == 0 ) : NEW_LINE INDENT return \" YES \" NEW_LINE DEDENT return \" NO \" NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT k = 13 NEW_LINE d0 = 8 NEW_LINE d1 = 1 NEW_LINE d1 = 1 NEW_LINE print ( check ( k , d0 , d1 ) ) NEW_LINE k = 5 NEW_LINE d1 = 4 NEW_LINE d1 = 3 NEW_LINE print ( check ( k , d0 , d1 ) ) NEW_LINE print ( check ( k , d0 , d1 ) ) NEW_LINE DEDENT"],"references":["def check ( k , d0 , d1 ) : NEW_LINE INDENT s = ( ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 + ( 6 * ( d0 + d1 ) ) % 10 ) NEW_LINE a = ( k - 3 ) % 4 NEW_LINE if ( a == 0 ) : NEW_LINE INDENT x = 0 NEW_LINE DEDENT elif ( a == 1 ) : NEW_LINE INDENT x = ( 2 * ( d0 + d1 ) ) % 10 NEW_LINE DEDENT elif ( a == 2 ) : NEW_LINE INDENT x = ( ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 ) NEW_LINE DEDENT elif ( a == 3 ) : NEW_LINE INDENT x = ( ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 ) NEW_LINE DEDENT sum = d0 + d1 + ( ( k - 3 ) \/\/ 4 ) * s + x NEW_LINE if ( sum % 3 == 0 ) : NEW_LINE INDENT return \" YES \" NEW_LINE DEDENT else : NEW_LINE INDENT return \" NO \" NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT k = 13 NEW_LINE d0 = 8 NEW_LINE d1 = 1 NEW_LINE print ( check ( k , d0 , d1 ) ) NEW_LINE k = 5 NEW_LINE d0 = 3 NEW_LINE d1 = 4 NEW_LINE print ( check ( k , d0 , d1 ) ) NEW_LINE DEDENT"],"bleu":0.758645102252402,"rouge_l":0.8571895424836603}
{"id":1068,"predictions":["def gap = n - 1 ; NEW_LINE gap = n - 1 ; NEW_LINE for j in range ( 1 , n + 1 ) : NEW_LINE INDENT num = j ; NEW_LINE for i in range ( 1 , gap + 1 ) : NEW_LINE INDENT print ( \" ▁ \" , end = \" \" ) ; NEW_LINE DEDENT gap -= 1 ; NEW_LINE for i in range ( 1 , j + 1 ) : NEW_LINE INDENT print ( num , end = \" ▁ \" ) ; NEW_LINE num += 1 ; NEW_LINE DEDENT num -= 1 ; NEW_LINE num -= 1 ; NEW_LINE for i in range ( 1 , j < j ) : NEW_LINE INDENT print ( num , end = \" ▁ \" ) ; NEW_LINE num -= 1 ; NEW_LINE DEDENT print ( ) ; NEW_LINE DEDENT"],"references":["n = 5 NEW_LINE num = 1 NEW_LINE gap = n - 1 NEW_LINE for j in range ( 1 , n + 1 ) : NEW_LINE INDENT num = j NEW_LINE for i in range ( 1 , gap + 1 ) : NEW_LINE INDENT print ( \" ▁ \" , end = \" \" ) NEW_LINE DEDENT gap = gap - 1 NEW_LINE for i in range ( 1 , j + 1 ) : NEW_LINE INDENT print ( num , end = \" \" ) NEW_LINE num = num + 1 NEW_LINE DEDENT num = num - 2 NEW_LINE for i in range ( 1 , j ) : NEW_LINE INDENT print ( num , end = \" \" ) NEW_LINE num = num - 1 NEW_LINE DEDENT print ( ) NEW_LINE DEDENT"],"bleu":0.660225422096346,"rouge_l":0.8469256796173142}
{"id":1069,"predictions":["def isKthBitSet ( x , k ) : NEW_LINE INDENT rslt = ( x & ( 1 << ( k - 1 ) ) ) NEW_LINE return rslt NEW_LINE DEDENT def isPalindrome ( x ) : NEW_LINE INDENT l = 1 NEW_LINE r = int ( sys . maxsize \/ 8 ) * 8 NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( isKthBitSet ( x , l ) != isKthBitSet ( x , r ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT x = 1 << 15 + 1 << 16 NEW_LINE print ( isPalindrome ( x ) ) NEW_LINE x = ( 1 << 31 ) + 1 NEW_LINE print ( isPalindrome ( x ) ) NEW_LINE"],"references":["import sys NEW_LINE def isKthBitSet ( x , k ) : NEW_LINE INDENT if ( ( x & ( 1 << ( k - 1 ) ) ) != 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def isPalindrome ( x ) : NEW_LINE INDENT l = 1 NEW_LINE r = 2 * 8 NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( isKthBitSet ( x , l ) != isKthBitSet ( x , r ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 1 << 15 + 1 << 16 NEW_LINE print ( int ( isPalindrome ( x ) ) ) NEW_LINE x = 1 << 31 + 1 NEW_LINE print ( int ( isPalindrome ( x ) ) ) NEW_LINE DEDENT"],"bleu":0.6362727436432629,"rouge_l":0.7933147033533965}
{"id":1070,"predictions":["import math as mt NEW_LINE def getSum ( a , n ) : NEW_LINE INDENT P = [ 0 for i in range ( n ) ] NEW_LINE P [ 0 ] = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT P [ i ] = a [ i ] + P [ i - 1 ] NEW_LINE DEDENT S = P [ n - 1 ] NEW_LINE hash = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ P [ i ] ] = 1 NEW_LINE DEDENT res = set ( ) NEW_LINE for i in range ( 1 , S + 1 ) : NEW_LINE INDENT if ( S % i == 0 ) : NEW_LINE INDENT res = 1 NEW_LINE div1 = i NEW_LINE div2 = S \/\/ i NEW_LINE for j in range ( div1 , S + 1 ) : NEW_LINE INDENT if ( hash [ j ] != 0 ) : NEW_LINE INDENT prev = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( res and div1 != S ) : NEW_LINE INDENT res [ div1 ] = 1 NEW_LINE div2 = S \/\/ i NEW_LINE for j in range ( div1 , S + 1 ) : NEW_LINE INDENT if ( hash [ j ] != 1 ) : NEW_LINE INDENT res = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( res + div2 != S ) : NEW_LINE INDENT res [ div2 ] = 1 NEW_LINE DEDENT DEDENT if ( len ( res ) == 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT for i in res : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT a = [ 1 , 2 , 1 , 1 , 2 , 1 , 3 ] NEW_LINE n = len ( a ) NEW_LINE getSum ( a , n ) NEW_LINE"],"references":["from math import sqrt NEW_LINE def getSum ( a , n ) : NEW_LINE INDENT P = [ 0 ] * n NEW_LINE P [ 0 ] = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT P [ i ] = a [ i ] + P [ i - 1 ] NEW_LINE DEDENT S = P [ n - 1 ] NEW_LINE hash = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ P [ i ] ] = 1 NEW_LINE DEDENT res = set ( ) NEW_LINE for i in range ( 1 , int ( sqrt ( S ) ) + 1 ) : NEW_LINE INDENT if ( S % i == 0 ) : NEW_LINE INDENT pres = True ; NEW_LINE div1 = i NEW_LINE div2 = S \/\/ i NEW_LINE for j in range ( div1 , S + 1 , div1 ) : NEW_LINE INDENT if j not in hash . keys ( ) : NEW_LINE INDENT pres = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( pres and div1 != S ) : NEW_LINE INDENT res . add ( div1 ) NEW_LINE DEDENT pres = True NEW_LINE for j in range ( S \/\/ i , S + 1 , S \/\/ i ) : NEW_LINE INDENT if j not in hash . keys ( ) : NEW_LINE INDENT pres = False ; NEW_LINE break NEW_LINE DEDENT DEDENT if ( pres and div2 != S ) : NEW_LINE INDENT res . add ( div2 ) NEW_LINE DEDENT DEDENT DEDENT if ( len ( res ) == 0 ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE return NEW_LINE DEDENT for i in res : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 2 , 1 , 1 , 1 , 2 , 1 , 3 ] NEW_LINE n = len ( a ) NEW_LINE getSum ( a , n ) NEW_LINE DEDENT"],"bleu":0.717934061961134,"rouge_l":0.8296984193987149}
{"id":1071,"predictions":["MAX_CHAR = 26 NEW_LINE def removeChars ( arr , k ) : NEW_LINE INDENT hash = [ 0 ] * MAX_CHAR NEW_LINE n = len ( arr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ ord ( arr [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT ans = \" \" NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( hash [ ord ( arr [ i ] ) - ord ( ' a ' ) ] != k ) : NEW_LINE INDENT ans += arr [ i ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" geeksforgeeks \" NEW_LINE k = 2 NEW_LINE print ( removeChars ( str , k ) ) NEW_LINE DEDENT"],"references":["MAX_CHAR = 26 NEW_LINE def removeChars ( arr , k ) : NEW_LINE INDENT hash = [ 0 ] * MAX_CHAR NEW_LINE n = len ( arr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ ord ( arr [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT ans = \" \" NEW_LINE index = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( hash [ ord ( arr [ i ] ) - ord ( ' a ' ) ] != k ) : NEW_LINE INDENT ans += arr [ i ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeksforgeeks \" NEW_LINE k = 2 NEW_LINE print ( removeChars ( str , k ) ) NEW_LINE DEDENT"],"bleu":0.9345807933060968,"rouge_l":0.9708045220063659}
{"id":1072,"predictions":["def firstEven ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] in mp ) : NEW_LINE INDENT mp [ arr [ i ] ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT j = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( mp [ arr [ j ] ] == True ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return arr [ j ] NEW_LINE DEDENT arr = [ 2 , 4 , 6 , 8 , 1 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( firstEven ( arr , n ) ) NEW_LINE"],"references":["def firstEven ( arr , n ) : NEW_LINE INDENT map1 = { } NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] not in map1 : NEW_LINE INDENT map1 [ arr [ i ] ] = False NEW_LINE DEDENT else : NEW_LINE INDENT map1 [ arr [ i ] ] = not map1 [ arr [ i ] ] NEW_LINE DEDENT DEDENT for j in range ( 0 , n ) : NEW_LINE INDENT if map1 [ arr [ j ] ] == True : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return arr [ j ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 4 , 6 , 8 , 1 , 6 ] NEW_LINE print ( firstEven ( arr , 6 ) ) NEW_LINE DEDENT"],"bleu":0.5823004733837038,"rouge_l":0.7713602187286398}
{"id":1073,"predictions":["def reverseString ( s ) : NEW_LINE INDENT s = \" \" . join ( s ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] != s [ len ( s ) - i - 1 ] ) : NEW_LINE INDENT s += str ( tmp ) NEW_LINE m = int ( m \/ 2 ) NEW_LINE DEDENT s = reverseString ( s ) NEW_LINE DEDENT def find_Character ( n , m , i ) : NEW_LINE INDENT binary_conversion ( m ) NEW_LINE s1 = \" \" . join ( s ) NEW_LINE for x in range ( len ( s ) ) : NEW_LINE INDENT for y in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ y ] == '1' ) : NEW_LINE INDENT s1 += \"10\" NEW_LINE DEDENT else : NEW_LINE INDENT s1 += \"01\" NEW_LINE DEDENT DEDENT s2 = s1 NEW_LINE s2 = \" \" NEW_LINE DEDENT return s1 NEW_LINE DEDENT m = 5 NEW_LINE n = 2 NEW_LINE i = 8 NEW_LINE print ( find_Character ( n , m , i ) ) NEW_LINE"],"references":["def binary_conversion ( s , m ) : NEW_LINE INDENT while ( m ) : NEW_LINE INDENT temp = m % 2 NEW_LINE s += str ( temp ) NEW_LINE m = m \/\/ 2 NEW_LINE DEDENT return s [ : : - 1 ] NEW_LINE DEDENT def find_character ( n , m , i ) : NEW_LINE INDENT s = \" \" NEW_LINE s = binary_conversion ( s , m ) NEW_LINE s1 = \" \" NEW_LINE for x in range ( n ) : NEW_LINE INDENT for j in range ( len ( s ) ) : NEW_LINE INDENT if s [ j ] == \"1\" : NEW_LINE INDENT s1 += \"10\" NEW_LINE DEDENT else : NEW_LINE INDENT s1 += \"01\" NEW_LINE DEDENT DEDENT s = s1 NEW_LINE s1 = \" \" NEW_LINE DEDENT e = ord ( s [ i ] ) NEW_LINE r = ord ( '0' ) NEW_LINE return e - r NEW_LINE DEDENT m , n , i = 5 , 2 , 8 NEW_LINE print ( find_character ( n , m , i ) ) NEW_LINE"],"bleu":0.4889336360650419,"rouge_l":0.6424965181058495}
{"id":1074,"predictions":["def cntSquares ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) * ( 2 * n + 1 ) \/ 6 ) ; NEW_LINE DEDENT print ( cntSquares ( 4 ) ) NEW_LINE"],"references":["def cntSquares ( n ) : NEW_LINE INDENT return int ( n * ( n + 1 ) * ( 2 * n + 1 ) \/ 6 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( cntSquares ( 4 ) ) ; NEW_LINE DEDENT"],"bleu":0.600245084599956,"rouge_l":0.7941075710859884}
{"id":1075,"predictions":["def multiplyWith3Point5 ( x ) : NEW_LINE INDENT return ( x << 1 ) + x + ( x >> 1 ) NEW_LINE DEDENT x = 2 NEW_LINE print ( multiplyWith3Point5 ( x ) ) NEW_LINE"],"references":["def multiplyWith3Point5 ( x ) : NEW_LINE INDENT return ( x << 1 ) + x + ( x >> 1 ) NEW_LINE DEDENT x = 4 NEW_LINE print ( multiplyWith3Point5 ( x ) ) NEW_LINE"],"bleu":0.9278982724420874,"rouge_l":0.9722222222222222}
{"id":1076,"predictions":["def countSubSeq ( strr , lenn ) : NEW_LINE INDENT ans = 0 NEW_LINE mul = 1 NEW_LINE for i in range ( lenn ) : NEW_LINE INDENT if ( strr [ i ] == '0' ) : NEW_LINE INDENT ans += mul NEW_LINE DEDENT mul *= 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT strr = \"10010\" NEW_LINE lenn = len ( strr ) NEW_LINE print ( countSubSeq ( strr , lenn ) ) NEW_LINE"],"references":["def countSubSeq ( strr , lenn ) : NEW_LINE INDENT ans = 0 NEW_LINE mul = 1 NEW_LINE for i in range ( lenn ) : NEW_LINE INDENT if ( strr [ i ] == '0' ) : NEW_LINE INDENT ans += mul NEW_LINE DEDENT mul *= 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT strr = \"10010\" NEW_LINE lenn = len ( strr ) NEW_LINE print ( countSubSeq ( strr , lenn ) ) NEW_LINE"],"bleu":1.0,"rouge_l":1.0}
{"id":1077,"predictions":["def swapThree ( a , b , c ) : NEW_LINE INDENT a [ 0 ] = a [ 0 ] + b [ 0 ] NEW_LINE b [ 0 ] = a [ 0 ] - ( b + c ) NEW_LINE c = a [ 0 ] - ( b + c ) NEW_LINE a [ 0 ] = b [ 0 ] - ( b [ 0 ] + c ) NEW_LINE b [ 0 ] = a [ 0 ] - ( b [ 0 ] + c ) NEW_LINE c [ 0 ] = a [ 0 ] + c [ 0 ] NEW_LINE print ( \" Before ▁ swapping ▁ a ▁ = ▁ \" , a [ 1 ] , \" , ▁ b ▁ = ▁ \" , b [ 0 ] , \" , ▁ c ▁ = ▁ \" , c [ 0 ] ) NEW_LINE swapThree ( a , b , c ) NEW_LINE print ( \" After ▁ swapping ▁ a ▁ = ▁ \" , a [ 0 ] , \" , ▁ b ▁ = ▁ \" , b [ 0 ] , \" , ▁ c ▁ = ▁ \" , b [ 0 ] ) NEW_LINE"],"references":["def swapThree ( a , b , c ) : NEW_LINE INDENT a = a + b + c NEW_LINE b = a - ( b + c ) NEW_LINE c = a - ( b + c ) NEW_LINE a = a - ( b + c ) NEW_LINE print ( \" After ▁ swapping ▁ a ▁ = \" , a , \" , ▁ b ▁ = \" , b , \" , ▁ c ▁ = \" , c ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 10 NEW_LINE b = 20 NEW_LINE c = 30 NEW_LINE print ( \" Before ▁ swapping ▁ a ▁ = \" , a , \" , ▁ b ▁ = \" , b , \" , ▁ c ▁ = \" , c ) NEW_LINE swapThree ( a , b , c ) NEW_LINE DEDENT"],"bleu":0.44966384491323336,"rouge_l":0.670575302308538}
{"id":1078,"predictions":["def countSubarrays ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE pre = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT pre [ i ] = pre [ i - 1 ] + a [ i - 1 ] NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT sum1 = pre [ j ] - pre [ i - 1 ] NEW_LINE count1 = j - i + 1 NEW_LINE sum2 = pre [ n ] - sum1 NEW_LINE if ( ( n - count1 ) == 0 ) : NEW_LINE INDENT count2 = 1 NEW_LINE DEDENT else : NEW_LINE INDENT n - count1 = ( n - count1 ) NEW_LINE print ( count1 \/ count1 ) NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 6 , 3 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countSubarrays ( arr , n ) ) NEW_LINE"],"references":["def countSubarrays ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE pre = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT pre [ i ] = pre [ i - 1 ] + a [ i - 1 ] NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT sum1 = pre [ j ] - pre [ i - 1 ] NEW_LINE count1 = j - i + 1 NEW_LINE sum2 = pre [ n ] - sum1 NEW_LINE if n - count1 == 0 : NEW_LINE INDENT count2 = 1 NEW_LINE DEDENT else : NEW_LINE INDENT count2 = n - count1 NEW_LINE DEDENT includ = sum1 \/\/ count1 NEW_LINE exclud = sum2 \/\/ count2 NEW_LINE if ( includ > exclud ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 6 , 3 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countSubarrays ( arr , n ) ) NEW_LINE"],"bleu":0.8386320420171894,"rouge_l":0.9082255308762509}
{"id":1079,"predictions":["def reverse ( arr , n , k , m ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT left = i ; NEW_LINE right = min ( i + k - 1 , n - 1 ) ; NEW_LINE while ( left < right ) : NEW_LINE INDENT arr [ i ] , left += 1 ; NEW_LINE right -= 1 ; NEW_LINE DEDENT DEDENT return arr ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 ] ; NEW_LINE k = 3 ; NEW_LINE m = 2 ; NEW_LINE n = len ( arr ) ; NEW_LINE reverse ( arr , n , k , m ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT"],"references":["def reverse ( arr , n , k , m ) : NEW_LINE INDENT for i in range ( 0 , n , k + m ) : NEW_LINE INDENT left = i ; NEW_LINE right = min ( i + k - 1 , n - 1 ) ; NEW_LINE while ( left < right ) : NEW_LINE INDENT arr = swap ( arr , left , right ) ; NEW_LINE left += 1 ; NEW_LINE right -= 1 ; NEW_LINE DEDENT DEDENT return arr ; NEW_LINE DEDENT def swap ( arr , i , j ) : NEW_LINE INDENT temp = arr [ i ] ; NEW_LINE arr [ i ] = arr [ j ] ; NEW_LINE arr [ j ] = temp ; NEW_LINE return arr ; NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 ] ; NEW_LINE k = 3 ; NEW_LINE m = 2 ; NEW_LINE n = len ( arr ) ; NEW_LINE arr = reverse ( arr , n , k , m ) ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT"],"bleu":0.6763495837793521,"rouge_l":0.7981127587027198}
{"id":1080,"predictions":["def count ( n ) : NEW_LINE INDENT return pow ( 2 , n - 1 ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 ; NEW_LINE print ( count ( n ) ) ; NEW_LINE DEDENT"],"references":["def count ( n ) : NEW_LINE INDENT return pow ( 2 , n - 1 ) NEW_LINE DEDENT n = 4 NEW_LINE print ( count ( n ) ) NEW_LINE"],"bleu":0.5287430133493595,"rouge_l":0.8164939550949913}
{"id":1081,"predictions":["def isSubsetSum ( set , n , sum ) : NEW_LINE INDENT subset = [ [ 0 for i in range ( n + 1 ) ] for i in range ( sum + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT subset [ 0 ] [ i ] = True NEW_LINE DEDENT for i in range ( 1 , sum + 1 ) : NEW_LINE INDENT for j in range ( 1 , sum + 1 ) : NEW_LINE INDENT subset [ i ] [ j ] = subset [ i ] [ j - 1 ] NEW_LINE if i >= set [ j - 1 ] : NEW_LINE INDENT subset [ i ] [ j ] = subset [ i ] [ j ] NEW_LINE subset [ i - set [ j - 1 ] ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT return subset [ n ] [ n ] NEW_LINE DEDENT set = [ 3 , 34 , 4 , 5 , 2 ] NEW_LINE sum = 9 NEW_LINE n = len ( set ) NEW_LINE if ( isSubsetSum ( set , n , sum ) == True ) : NEW_LINE INDENT print ( \" Found ▁ a ▁ subset ▁ with ▁ given ▁ sum \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No ▁ subset ▁ with ▁ given ▁ sum \" ) NEW_LINE DEDENT"],"references":["def isSubsetSum ( set , n , sum ) : NEW_LINE INDENT subset = ( [ [ False for i in range ( sum + 1 ) ] for i in range ( n + 1 ) ] ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT subset [ i ] [ 0 ] = True NEW_LINE DEDENT for i in range ( 1 , sum + 1 ) : NEW_LINE INDENT subset [ 0 ] [ i ] = False NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , sum + 1 ) : NEW_LINE INDENT if j < set [ i - 1 ] : NEW_LINE INDENT subset [ i ] [ j ] = subset [ i - 1 ] [ j ] NEW_LINE DEDENT if j >= set [ i - 1 ] : NEW_LINE INDENT subset [ i ] [ j ] = ( subset [ i - 1 ] [ j ] or subset [ i - 1 ] [ j - set [ i - 1 ] ] ) NEW_LINE DEDENT DEDENT DEDENT return subset [ n ] [ sum ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT set = [ 3 , 34 , 4 , 12 , 5 , 2 ] NEW_LINE sum = 9 NEW_LINE n = len ( set ) NEW_LINE if ( isSubsetSum ( set , n , sum ) == True ) : NEW_LINE INDENT print ( \" Found ▁ a ▁ subset ▁ with ▁ given ▁ sum \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No ▁ subset ▁ with ▁ given ▁ sum \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.6902430238242123,"rouge_l":0.8160056324806383}
{"id":1082,"predictions":["def colourVisible ( height , colour , K ) : NEW_LINE INDENT arr = [ 0 for i in range ( K + 1 ) ] NEW_LINEvisible = 0 NEW_LINE max = height [ K - 1 ] NEW_LINE arr [ colour [ K - 1 ] ] = 1 NEW_LINE for i in range ( K - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( height [ i ] > max ) : NEW_LINE INDENT max = height [ i ] NEW_LINE arr [ colour [ i ] ] = 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , K + 1 ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENTvisible += 1 NEW_LINE DEDENT DEDENT return positive NEW_LINE DEDENT height = [ 3 , 5 , 1 , 2 , 3 ] NEW_LINE colour = [ 1 , 2 , 3 , 4 , 3 ] NEW_LINE K = len ( colour ) NEW_LINE print ( colourVisible ( height , colour , K ) ) NEW_LINE"],"references":["def colourVisible ( height , colour , K ) : NEW_LINE INDENT arr = [ 0 for i in range ( K + 1 ) ] NEW_LINE visible = 0 NEW_LINE max = height [ K - 1 ] NEW_LINE arr [ colour [ K - 1 ] ] = 1 NEW_LINE i = K - 2 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( height [ i ] > max ) : NEW_LINE INDENT max = height [ i ] NEW_LINE arr [ colour [ i ] ] = 1 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT for i in range ( 1 , K + 1 , 1 ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT visible += 1 NEW_LINE DEDENT DEDENT return visible NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT height = [ 3 , 5 , 1 , 2 , 3 ] NEW_LINE colour = [ 1 , 2 , 3 , 4 , 3 ] NEW_LINE K = len ( colour ) NEW_LINE print ( colourVisible ( height , colour , K ) ) NEW_LINE DEDENT"],"bleu":0.7822773598570325,"rouge_l":0.8746818258951298}
{"id":1083,"predictions":["def findAndPrintCommonElements ( mat , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT mat [ i ] . sort ( ) NEW_LINE DEDENT DEDENT def sortRows ( mat , n ) : NEW_LINE INDENT curr_index = [ 0 for i in range ( n ) ] NEW_LINE f = 0 NEW_LINE while ( curr_index [ 0 ] < n ) : NEW_LINE INDENT value = mat [ 0 ] [ curr_index [ 0 ] ] NEW_LINE present = True NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT while ( curr_index [ i ] < n and mat [ i ] [ curr_index [ i ] ] > value ) : NEW_LINE INDENT curr_index [ i ] += 1 NEW_LINE DEDENT if ( mat [ i ] [ curr_index [ i ] - 1 ] != value ) : NEW_LINE INDENT present = False NEW_LINE DEDENT if ( curr_index [ i ] == n ) : NEW_LINE INDENT f = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( present ) : NEW_LINE INDENT f = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( present ) : NEW_LINE INDENT print ( value , end = \" ▁ \" ) NEW_LINE DEDENT if ( f == 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT mat = [ [ 10 , 1 , 10 , 3 , 12 ] , [ 12 , 2 , 1 , 3 , 30 ] , [ 13 , 15 , 3 , 2 , 1 ] , [ 13 , 20 , 3 , 2 , 1 ] , [ 13 , 15 , 30 , 2 , 1 ] ] NEW_LINE n = 5 NEW_LINE findAndPrintCommonElements ( mat , n ) NEW_LINE DEDENT"],"references":["MAX = 100 NEW_LINE def sortRows ( mat , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT mat [ i ] . sort ( ) ; NEW_LINE DEDENT DEDENT def findAndPrintCommonElements ( mat , n ) : NEW_LINE INDENT sortRows ( mat , n ) NEW_LINE curr_index = [ 0 ] * n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT curr_index [ i ] = 0 NEW_LINE DEDENT f = 0 NEW_LINE while ( curr_index [ 0 ] < n ) : NEW_LINE INDENT value = mat [ 0 ] [ curr_index [ 0 ] ] NEW_LINE present = True NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT while ( curr_index [ i ] < n and mat [ i ] [ curr_index [ i ] ] <= value ) : NEW_LINE INDENT curr_index [ i ] = curr_index [ i ] + 1 NEW_LINE DEDENT if ( mat [ i ] [ curr_index [ i ] - 1 ] != value ) : NEW_LINE INDENT present = False NEW_LINE DEDENT if ( curr_index [ i ] == n ) : NEW_LINE INDENT f = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( present ) : NEW_LINE INDENT print ( value , end = \" ▁ \" ) NEW_LINE DEDENT if ( f == 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT curr_index [ 0 ] = curr_index [ 0 ] + 1 NEW_LINE DEDENT DEDENT mat = [ [ 12 , 1 , 14 , 3 , 16 ] , [ 14 , 2 , 1 , 3 , 35 ] , [ 14 , 1 , 14 , 3 , 11 ] , [ 14 , 25 , 3 , 2 , 1 ] , [ 1 , 18 , 3 , 21 , 14 ] ] NEW_LINE n = 5 NEW_LINE findAndPrintCommonElements ( mat , n ) NEW_LINE"],"bleu":0.7163081057768111,"rouge_l":0.8126741299832836}
{"id":1084,"predictions":["def MaximumProduct ( a , n ) : NEW_LINE INDENT cntneg = 0 ; cntzero = 0 ; NEW_LINE used = [ 0 ] * n ; NEW_LINE pos = - 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT used [ i ] = 1 ; NEW_LINE cntzero += 1 ; NEW_LINE DEDENT if ( a [ i ] < 0 ) : NEW_LINE INDENT cntneg += 1 ; NEW_LINE if ( pos == - 1 or abs ( a [ pos ] ) > abs ( a [ pos ] ) ) : NEW_LINE INDENT pos = i ; NEW_LINE DEDENT DEDENT if ( cntneg % 2 == 1 ) : NEW_LINE INDENT used [ pos ] = 1 ; NEW_LINE DEDENT if ( cntzero == n or ( cntzero == n - 1 and cntneg == 1 ) ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT print ( 1 , ( i + 1 ) , ( i + 2 ) ) ; NEW_LINE DEDENT lst = - 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( used [ i ] == 0 ) : NEW_LINE INDENT if ( flag != 1 ) : NEW_LINE INDENT print ( 1 , ( i + 1 ) , ( i + 1 ) ) ; NEW_LINE DEDENT lst = i ; NEW_LINE DEDENT DEDENT if ( flag != 1 ) : NEW_LINE INDENT print ( 1 , ( lst + 1 ) ) ; NEW_LINE DEDENT lst = - 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( used [ i ] != 1 ) : NEW_LINE INDENT if ( flag != 1 ) : NEW_LINE INDENT print ( 1 , ( lst + 1 ) ) ; NEW_LINE DEDENT lst = i ; NEW_LINE DEDENT DEDENT if ( stnt != 0 ) : NEW_LINE INDENT print ( 2 , ( lst + 1 ) ) ; NEW_LINE DEDENT lst = - 1 ; NEW_LINE for i"],"references":["def MaximumProduct ( a , n ) : NEW_LINE INDENT cntneg = 0 NEW_LINE cntzero = 0 NEW_LINE used = [ 0 ] * n NEW_LINE pos = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT used [ i ] = 1 NEW_LINE cntzero += 1 NEW_LINE DEDENT if ( a [ i ] < 0 ) : NEW_LINE INDENT cntneg += 1 NEW_LINE if ( pos == - 1 or abs ( a [ pos ] ) > abs ( a [ i ] ) ) : NEW_LINE INDENT pos = i NEW_LINE DEDENT DEDENT DEDENT if ( cntneg % 2 == 1 ) : NEW_LINE INDENT used [ pos ] = 1 NEW_LINE DEDENT if ( cntzero == n or ( cntzero == n - 1 and cntneg == 1 ) ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT print ( 1 , \" ▁ \" , i + 1 , \" ▁ \" , i + 2 ) NEW_LINE DEDENT return NEW_LINE DEDENT lst = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( used [ i ] ) : NEW_LINE INDENT if ( lst != - 1 ) : NEW_LINE INDENT print ( 1 , \" ▁ \" , lst + 1 , \" ▁ \" , i + 1 ) NEW_LINE DEDENT lst = i NEW_LINE DEDENT DEDENT if ( lst != - 1 ) : NEW_LINE INDENT print ( 2 , \" ▁ \" , lst + 1 ) NEW_LINE DEDENT lst = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( not used [ i ] ) : NEW_LINE INDENT if ( lst != - 1 ) : NEW_LINE INDENT print ( 1 , \" ▁ \" , lst + 1 , \" ▁ \" , i + 1 ) NEW_LINE DEDENT lst = i NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 5 , - 2 , 0 , 1 , - 3 ] NEW_LINE n = len ( a ) NEW_LINE MaximumProduct ( a , n ) NEW_LINE DEDENT"],"bleu":0.6522308617762076,"rouge_l":0.810437651962487}
{"id":1085,"predictions":["def getSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT sum = sum + n % 10 NEW_LINE n = int ( n \/ 10 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 687 NEW_LINE print ( getSum ( n ) ) NEW_LINE"],"references":["def getSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT sum = sum + int ( n % 10 ) NEW_LINE n = int ( n \/ 10 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 687 NEW_LINE print ( getSum ( n ) ) NEW_LINE"],"bleu":0.8930773258919003,"rouge_l":0.9688131677736066}
{"id":1086,"predictions":["def flipsCount ( a , b ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT count += 1 NEW_LINE n &= ( a - 1 ) NEW_LINE DEDENT return count NEW_LINE DEDENT def flipsCount ( a , b ) : NEW_LINE INDENT return countSetBits ( a ^ b ) NEW_LINE DEDENT a = 10 NEW_LINE b = 20 NEW_LINE print ( flipsCount ( a , b ) ) NEW_LINE"],"references":["def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while n : NEW_LINE INDENT count += 1 NEW_LINE n &= ( n - 1 ) NEW_LINE DEDENT return count NEW_LINE DEDENT def FlippedCount ( a , b ) : NEW_LINE INDENT return countSetBits ( a ^ b ) NEW_LINE DEDENT a = 10 NEW_LINE b = 20 NEW_LINE print ( FlippedCount ( a , b ) ) NEW_LINE"],"bleu":0.7846633197112215,"rouge_l":0.908598510494245}
{"id":1087,"predictions":["def findSum ( arr , N ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT if arr [ i ] in mp : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT maxFreq = 0 NEW_LINE for key , value in mp . items ( ) : NEW_LINE INDENT if value > maxFreq : NEW_LINE INDENT maxFreq = value NEW_LINE DEDENT DEDENT return SUM NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 1 , 2 , 2 , 3 , 3 , 3 , 3 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE print ( findSum ( arr , N ) ) NEW_LINE DEDENT"],"references":["def findSum ( arr , N ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT mp [ arr [ i ] ] = mp . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT maxFreq = 0 NEW_LINE for itr in mp : NEW_LINE INDENT if ( mp [ itr ] > maxFreq ) : NEW_LINE INDENT maxFreq = mp [ itr ] NEW_LINE DEDENT DEDENT Sum = 0 NEW_LINE for itr in mp : NEW_LINE INDENT if ( mp [ itr ] == maxFreq ) : NEW_LINE INDENT Sum += itr * mp [ itr ] NEW_LINE DEDENT DEDENT return Sum NEW_LINE DEDENT arr = [ 1 , 1 , 2 , 2 , 2 , 2 , 3 , 3 , 3 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE print ( findSum ( arr , N ) ) NEW_LINE"],"bleu":0.6150196000415863,"rouge_l":0.6799158780231335}
{"id":1088,"predictions":["def mdas_Factorial ( N ) : NEW_LINE INDENT if ( N <= 2 ) : NEW_LINE INDENT return N NEW_LINE DEDENT if ( N <= 4 ) : NEW_LINE INDENT return ( N + 3 ) NEW_LINE DEDENT if ( N - 4 ) % 4 == 0 ) : NEW_LINE INDENT return ( N + 1 ) NEW_LINE DEDENT elif ( ( N - 4 ) % 4 <= 2 ) : NEW_LINE INDENT return ( N + 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( N - 1 ) NEW_LINE DEDENT DEDENT N = 4 NEW_LINE print ( mdas_Factorial ( N ) ) NEW_LINE N = 10 NEW_LINE print ( mdas_Factorial ( N ) ) NEW_LINE N = 10 NEW_LINE print ( mdas_Factorial ( N ) ) NEW_LINE"],"references":["def MDAS_Factorial ( N ) : NEW_LINE INDENT if N <= 2 : NEW_LINE INDENT return N NEW_LINE DEDENT if N <= 4 : NEW_LINE INDENT return N + 3 NEW_LINE DEDENT if ( N - 4 ) % 4 == 0 : NEW_LINE INDENT return N + 1 NEW_LINE DEDENT elif ( N - 4 ) % 4 <= 2 : NEW_LINE INDENT return N + 2 NEW_LINE DEDENT else : NEW_LINE INDENT return N - 1 NEW_LINE DEDENT DEDENT N = 4 NEW_LINE print ( MDAS_Factorial ( N ) ) NEW_LINE N = 10 NEW_LINE print ( MDAS_Factorial ( N ) ) NEW_LINE"],"bleu":0.556828817596244,"rouge_l":0.878813559322034}
{"id":1089,"predictions":["def maxANDAND ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if res > res : NEW_LINE INDENT res = res NEW_LINE DEDENT else : NEW_LINE INDENT res = ( arr [ i ] & arr [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT arr = [ 4 , 8 , 6 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Maximum ▁ AND ▁ Value ▁ = ▁ \" , maxAND ( arr , n ) ) NEW_LINE"],"references":["def maxAND ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT res = max ( res , arr [ i ] & arr [ j ] ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT arr = [ 4 , 8 , 6 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Maximum ▁ AND ▁ Value ▁ = ▁ \" , maxAND ( arr , n ) ) NEW_LINE"],"bleu":0.8191898045358651,"rouge_l":0.9104477611940299}
{"id":1090,"predictions":["import math NEW_LINE def check ( arr , x , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT y = math . sqrt ( arr [ i ] ) ; NEW_LINE if ( floor ( y ) == math . ceil ( y ) ) : NEW_LINE INDENT sum += arr [ i ] ; NEW_LINE DEDENT DEDENT if ( sum % x == 0 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 9 , 10 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE x = 13 ; NEW_LINE if ( check ( arr , x , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"],"references":["import math NEW_LINE def check ( a , y ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT x = math . sqrt ( a [ i ] ) NEW_LINE if ( math . floor ( x ) == math . ceil ( x ) ) : NEW_LINE INDENT sum = sum + a [ i ] NEW_LINE DEDENT DEDENT if ( sum % y == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT a = [ 2 , 3 , 4 , 9 , 10 ] NEW_LINE x = 13 NEW_LINE if check ( a , x ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.5268093589261669,"rouge_l":0.7997692469058107}
{"id":1091,"predictions":["from math import sqrt NEW_LINE MAX_SIZE = int ( 1e5 ) NEW_LINE prime = [ True for i in range ( MAX_SIZE + 1 ) ] NEW_LINE def sieve ( ) : NEW_LINE INDENT for p in range ( 2 , int ( sqrt ( MAX_SIZE ) + 1 ) ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , MAX_SIZE , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def kthPrimeGreaterN ( n , k ) : NEW_LINE INDENT res = - 1 NEW_LINE for i in range ( n + 1 , MAX_SIZE ) : NEW_LINE INDENT if ( prime [ i ] == True ) : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT if ( k == 0 ) : NEW_LINE INDENT res = i NEW_LINE break NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT sieve ( ) NEW_LINE n = 2 NEW_LINE k = 15 NEW_LINE print ( kthPrimeGreaterN ( n , k ) ) NEW_LINE"],"references":["MAX_SIZE = int ( 1e6 ) NEW_LINE prime = [ True ] * ( MAX_SIZE + 1 ) NEW_LINE def seive ( ) : NEW_LINE INDENT p = 2 NEW_LINE while ( p * p <= MAX_SIZE ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , MAX_SIZE , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT def kthPrimeGreaterThanN ( n , k ) : NEW_LINE INDENT res = - 1 NEW_LINE for i in range ( n + 1 , MAX_SIZE ) : NEW_LINE INDENT if ( prime [ i ] == True ) : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT if ( k == 0 ) : NEW_LINE INDENT res = i NEW_LINE break NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 2 NEW_LINE k = 15 NEW_LINE seive ( ) NEW_LINE print ( kthPrimeGreaterThanN ( n , k ) ) NEW_LINE DEDENT"],"bleu":0.7298602979471799,"rouge_l":0.8272469420315547}
{"id":1092,"predictions":["def minimumSets ( arr , n , key ) : NEW_LINE INDENT arr = sorted ( arr ) NEW_LINE i = 0 NEW_LINE j = n - 1 NEW_LINE while i <= j : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] <= key ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return i NEW_LINE DEDENT arr = [ 3 , 5 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE key = 5 NEW_LINE print ( minimumSets ( arr , n , key ) ) NEW_LINE"],"references":["def minimumSets ( arr , n , key ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE j = n - 1 NEW_LINE for i in range ( 0 , j + 1 , 1 ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] <= key ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT DEDENT return i + 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 5 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE key = 5 NEW_LINE print ( minimumSets ( arr , n , key ) ) NEW_LINE DEDENT"],"bleu":0.6564349719393193,"rouge_l":0.7861280046336518}
{"id":1093,"predictions":["def isPalindrome ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE if l == 1 : NEW_LINE INDENT return True NEW_LINE DEDENT ptr1 = s [ 0 ] NEW_LINE ptr2 = s [ l - 1 ] NEW_LINE while ptr2 > ptr1 : NEW_LINE INDENT if ptr1 != ptr2 : NEW_LINE INDENT return False NEW_LINE DEDENT ptr1 += 1 NEW_LINE ptr2 -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def noOfOperends ( s ) : NEW_LINE INDENT if ( isPalindrome ( s ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT s = s [ 1 : ] NEW_LINE return 1 + noOfOperends ( s ) NEW_LINE DEDENT s = \" ab sentence \" NEW_LINE print ( noOfReplents ( s ) ) NEW_LINE"],"references":["def isPalindrome ( Str ) : NEW_LINE INDENT Len = len ( Str ) NEW_LINE if ( Len == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT ptr1 = 0 NEW_LINE ptr2 = Len - 1 NEW_LINE while ( ptr2 > ptr1 ) : NEW_LINE INDENT if ( Str [ ptr1 ] != Str [ ptr2 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT ptr1 += 1 NEW_LINE ptr2 -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def noOfAppends ( s ) : NEW_LINE INDENT if ( isPalindrome ( s ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT del s [ 0 ] NEW_LINE return 1 + noOfAppends ( s ) NEW_LINE DEDENT se = \" abede \" NEW_LINE s = [ i for i in se ] NEW_LINE print ( noOfAppends ( s ) ) NEW_LINE"],"bleu":0.5474959521831093,"rouge_l":0.7870967741935484}
{"id":1094,"predictions":["from math import sqrt NEW_LINE def add_divisors ( n , m ) : NEW_LINE INDENT for i in range ( 1 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n \/\/ i == i ) : NEW_LINE INDENT if ( n \/\/ i == 0 ) : NEW_LINE INDENT m [ i ] = m [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ i ] = m [ i ] + 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT m [ i ] = m [ i ] + 1 NEW_LINE DEDENT if ( n \/\/ i ) in m : NEW_LINE INDENT m [ n \/\/ i ] = m [ n \/\/ i ] + 1 NEW_LINE DEDENT DEDENT DEDENT def count_divisors ( a , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( mp [ a [ i ] ] == 0 ) : NEW_LINE INDENT print ( 0 , end = \" ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT mp [ a [ i ] ] = mp [ a [ i ] ] NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 8 , 1 , 20 , 4 , 2 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE count_divisors ( arr , n ) NEW_LINE DEDENT"],"references":["from collections import defaultdict NEW_LINE import math NEW_LINE def add_factors ( n , mp ) : NEW_LINE INDENT for i in range ( 1 , int ( math . sqrt ( n ) ) + 1 , ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n \/\/ i == i ) : NEW_LINE INDENT mp [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ i ] += 1 NEW_LINE mp [ n \/\/ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT def count_divisors ( a , n ) : NEW_LINE INDENT mp = defaultdict ( int ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( mp [ a [ i ] ] , end = \" ▁ \" ) NEW_LINE add_factors ( a [ i ] , mp ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 8 , 1 , 28 , 4 , 2 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE count_divisors ( arr , n ) NEW_LINE DEDENT"],"bleu":0.5369367008427128,"rouge_l":0.751885150812065}
{"id":1095,"predictions":["def isPossible ( arr , n , C , mid ) : NEW_LINE INDENT ans = 1 NEW_LINE currPosition = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] - currPosition >= mid ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def binarySearch ( n , C , arr ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE lo , hi = 0 , arr [ n - 1 ] NEW_LINE ans = 0 NEW_LINE while ( lo <= hi ) : NEW_LINE INDENT mid = int ( ( lo + hi ) \/ 2 ) NEW_LINE if ( isPossible ( arr , n , C , mid ) ) : NEW_LINE INDENT hi = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( ans , mid ) NEW_LINE lo = mid + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT C = 4 NEW_LINE arr = [ 1 , 2 , 5 , 8 , 10 , 18 ] NEW_LINE n = len ( arr ) NEW_LINE print ( binarySearch ( n , C , arr ) ) NEW_LINE DEDENT"],"references":["def isPossible ( arr , n , C , mid ) : NEW_LINE INDENT magnet = 1 NEW_LINE currPosition = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] - currPosition >= mid ) : NEW_LINE INDENT magnet += 1 NEW_LINE currPosition = arr [ i ] NEW_LINE if ( magnet == C ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT def binarySearch ( n , C , arr ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE lo = 0 NEW_LINE hi = arr [ n - 1 ] NEW_LINE ans = 0 NEW_LINE while ( lo <= hi ) : NEW_LINE INDENT mid = int ( ( lo + hi ) \/ 2 ) NEW_LINE if ( isPossible ( arr , n , C , mid ) == False ) : NEW_LINE INDENT hi = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( ans , mid ) NEW_LINE lo = mid + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT C = 4 NEW_LINE arr = [ 1 , 2 , 5 , 8 , 10 , 18 ] NEW_LINE n = len ( arr ) NEW_LINE print ( binarySearch ( n , C , arr ) ) NEW_LINE DEDENT"],"bleu":0.8421873513426741,"rouge_l":0.917099901643951}
{"id":1096,"predictions":["def makePalindrome ( n , odd ) : NEW_LINE INDENT res = n ; NEW_LINE if ( odd == 0 ) : NEW_LINE INDENT n = n \/\/ 10 ; NEW_LINE DEDENT while ( n > 0 ) : NEW_LINE INDENT res = 10 * res + n % 10 ; NEW_LINE n \/\/= 10 ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT def isPalindrome ( n , base ) : NEW_LINE INDENT reverse = 0 ; NEW_LINE temp = n ; NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT reversed = reverse * base + temp % base ; NEW_LINE temp \/\/= base ; NEW_LINE DEDENT return reverse == n ; NEW_LINE DEDENT def sumPalindrome ( n , k ) : NEW_LINE INDENT sum = 0 ; NEW_LINE i = 1 ; NEW_LINE p = makePalindrome ( i , True ) ; NEW_LINE while ( p < n ) : NEW_LINE INDENT if ( isPalindrome ( p , k ) ) : NEW_LINE INDENT sum += p ; NEW_LINE DEDENT i += 1 ; NEW_LINE p = makePalindrome ( i , True ) ; NEW_LINE DEDENT i = 1 ; NEW_LINE p = makePalindrome ( i , False ) ; NEW_LINE while ( p < n ) : NEW_LINE INDENT if ( isPalindrome ( p , k ) ) : NEW_LINE INDENT sum += p ; NEW_LINE DEDENT i += 1 ; NEW_LINE p = makePalindrome ( i , False ) ; NEW_LINE DEDENT print ( \" Total ▁ sum ▁ is \" , sum ) ; NEW_LINE"],"references":["def makePalindrome ( n , odd ) : NEW_LINE INDENT res = n ; NEW_LINE if ( odd ) : NEW_LINE INDENT n = int ( n \/ 10 ) ; NEW_LINE DEDENT while ( n > 0 ) : NEW_LINE INDENT res = 10 * res + n % 10 ; NEW_LINE n = int ( n \/ 10 ) ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT def isPalindrome ( n , base ) : NEW_LINE INDENT reversed = 0 ; NEW_LINE temp = n ; NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT reversed = reversed * base + temp % base ; NEW_LINE temp = int ( temp \/ base ) ; NEW_LINE DEDENT return reversed == n ; NEW_LINE DEDENT def sumPalindrome ( n , k ) : NEW_LINE INDENT sum = 0 ; NEW_LINE i = 1 ; NEW_LINE p = makePalindrome ( i , True ) ; NEW_LINE while ( p < n ) : NEW_LINE INDENT if ( isPalindrome ( p , k ) ) : NEW_LINE INDENT sum += p ; NEW_LINE DEDENT i += 1 ; NEW_LINE p = makePalindrome ( i , True ) ; NEW_LINE DEDENT i = 1 ; NEW_LINE p = makePalindrome ( i , False ) ; NEW_LINE while ( p < n ) : NEW_LINE INDENT if ( isPalindrome ( p , k ) ) : NEW_LINE INDENT sum += p ; NEW_LINE DEDENT i += 1 ; NEW_LINE p = makePalindrome ( i , False ) ; NEW_LINE DEDENT print ( \" Total ▁ sum ▁ is \" , sum ) ; NEW_LINE DEDENT n = 1000000 ; NEW_LINE k = 2 ; NEW_LINE sumPalindrome ( n , k ) ; NEW_LINE"],"bleu":0.8170915347713582,"rouge_l":0.9077701311687548}
{"id":1097,"predictions":["class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data ; NEW_LINE self . left = None ; NEW_LINE self . right = None ; NEW_LINE DEDENT DEDENT def countQueue ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT l = countQueue ( root . left ) ; NEW_LINE r = countQueue ( root . right ) ; NEW_LINE maxCount = 0 ; NEW_LINE if ( root . data == 1 ) : NEW_LINE INDENT maxCount = l + r + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT maxCount = l + r ; NEW_LINE DEDENT res = max ( res , maxCount ) ; NEW_LINE if ( root . data == 1 ) : NEW_LINE INDENT maxCount = l + r + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT maxCount = l + r ; NEW_LINE DEDENT res = max ( res , maxCount ) ; NEW_LINE if ( root . data == 1 ) : NEW_LINE INDENT return max ( l , r ) + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return max ( l , r ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 1 ) ; NEW_LINE root . left = newNode ( 0 ) ; NEW_LINE root . left = newNode ( 0 ) ; NEW_LINE root . left = newNode ( 1 ) ; NEW_LINE root . left . left = newNode ( 1 ) ; NEW_LINE root . left . left = newNode ( 1 ) ; NEW_LINE root . left . right = newNode ( 1 ) ; NEW_LINE root . left . right = newNode ( 2 ) ; NEW_LINE root . left . right = newNode ( 0 ) ; NEW_LINE print ( findMaxCount ( root ) ) ; NEW_LINE DEDENT"],"references":["class Node : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . data = 0 NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def newNode ( data ) : NEW_LINE INDENT newNode = Node ( ) NEW_LINE newNode . data = data NEW_LINE newNode . left = newNode . right = None NEW_LINE return ( newNode ) NEW_LINE DEDENT res = 0 NEW_LINE def countUntil ( root ) : NEW_LINE INDENT global res NEW_LINE if ( root == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT l = countUntil ( root . left ) NEW_LINE r = countUntil ( root . right ) NEW_LINE maxCount = 0 NEW_LINE if ( root . data == 1 ) : NEW_LINE INDENT maxCount = l + r + 1 NEW_LINE DEDENT else : NEW_LINE INDENT maxCount = l + r NEW_LINE DEDENT res = max ( res , maxCount ) NEW_LINE if ( root . data == 1 ) : NEW_LINE INDENT return max ( l , r ) + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return max ( l , r ) NEW_LINE DEDENT DEDENT def findMaxCount ( root ) : NEW_LINE INDENT global res NEW_LINE res = - 999999 NEW_LINE countUntil ( root ) NEW_LINE return res NEW_LINE DEDENT root = newNode ( 1 ) NEW_LINE root . left = newNode ( 0 ) NEW_LINE root . right = newNode ( 1 ) NEW_LINE root . left . left = newNode ( 1 ) NEW_LINE root . left . right = newNode ( 1 ) NEW_LINE root . left . right . left = newNode ( 1 ) NEW_LINE root . left . right . right = newNode ( 0 ) NEW_LINE print ( findMaxCount ( root ) ) NEW_LINE"],"bleu":0.599705255276743,"rouge_l":0.7350937860211674}
{"id":1098,"predictions":["from math import pow NEW_LINE def countDigits ( d , count ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE n \/\/= 10 ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT def getDistinct ( d , count ) : NEW_LINE INDENT num = 0 ; NEW_LINE countDigitsL = countDigits ( L ) ; NEW_LINE countDigitsL = countDigits ( R ) ; NEW_LINE firstDigitsL = countDigits ( R ) ; NEW_LINE firstDigitsL = countDigits ( R ) ; NEW_LINE firstDigitL = ( L \/\/ math . pow ( 10 , countDigitsL - 1 ) ) ; NEW_LINE if ( countDigitsL < countDigitsL ) : NEW_LINE INDENT count += ( 9 * ( countDigitsL - countDigitsL ) >= L ) ; NEW_LINE if ( getDistinct ( firstDigitsL , countDigitsL ) >= L ) : NEW_LINE INDENT count += ( 9 * ( countDigitsL - countDigitsL ) ) ; NEW_LINE if ( getDistitsL < countDigitsL ) : NEW_LINE INDENT count += ( 9 - firstDigitL + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT count += ( firstDigitR - 1 ) ; NEW_LINE DEDENT if ( getDistinct ( firstDigitR , countDigitsL ) <= R ) : NEW_LINE INDENT count += ( 9 - firstDigitL + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT count += ( 9 - firstDigitR ) ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( getDistinct ( firstDigitR , countDigitsL ) >= L ) : NEW_LINE INDENT count += ( 9 - firstDigitL + 1 ) ; NEW_LINE DEDENT if ( getDistinct ( firstDigitR , countDigitsR ) <= R ) : NEW_LINE INDENT count += ( 9 - firstDigitL + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT count -= ("],"references":["def countDigits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT count += 1 NEW_LINE n \/\/= 10 NEW_LINE DEDENT return count NEW_LINE DEDENT def getDistinct ( d , count ) : NEW_LINE INDENT num = 0 NEW_LINE count = pow ( 10 , count - 1 ) NEW_LINE while ( count > 0 ) : NEW_LINE INDENT num += ( count * d ) NEW_LINE count \/\/= 10 NEW_LINE DEDENT return num NEW_LINE DEDENT def findCount ( L , R ) : NEW_LINE INDENT count = 0 NEW_LINE countDigitsL = countDigits ( L ) NEW_LINE countDigitsR = countDigits ( R ) NEW_LINE firstDigitL = ( L \/\/ pow ( 10 , countDigitsL - 1 ) ) NEW_LINE firstDigitR = ( R \/\/ pow ( 10 , countDigitsR - 1 ) ) NEW_LINE if ( countDigitsL < countDigitsR ) : NEW_LINE INDENT count += ( 9 * ( countDigitsR - countDigitsL - 1 ) ) NEW_LINE if ( getDistinct ( firstDigitL , countDigitsL ) >= L ) : NEW_LINE INDENT count += ( 9 - firstDigitL + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT count += ( 9 - firstDigitL ) NEW_LINE DEDENT if ( getDistinct ( firstDigitR , countDigitsR ) <= R ) : NEW_LINE INDENT count += firstDigitR NEW_LINE DEDENT else : NEW_LINE INDENT count += ( firstDigitR - 1 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( getDistinct ( firstDigitL , countDigitsL ) >= L ) : NEW_LINE INDENT count += ( 9 - firstDigitL + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT count += ( 9 - firstDigitL ) NEW_LINE DEDENT if ( getDistinct ( firstDigitR , countDigitsR ) <= R ) : NEW_LINE INDENT count -= ( 9 - firstDigitR ) NEW_LINE DEDENT else : NEW_LINE INDENT count -= ( 9 - firstDigitR + 1 ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT L = 10 NEW_LINE R = 50 NEW_LINE print ( findCount ( L , R ) ) NEW_LINE"],"bleu":0.5739823976171945,"rouge_l":0.67983789260385}
{"id":1099,"predictions":["def isPalindrome ( n ) : NEW_LINE INDENT divisor = 1 NEW_LINE while ( int ( n \/ divisor ) >= 10 ) : NEW_LINE INDENT divisor *= 10 NEW_LINE DEDENT while ( n != 0 ) : NEW_LINE INDENT leading = int ( n \/ divisor ) NEW_LINE trailing = n % 10 NEW_LINE if ( leading != trailing ) : NEW_LINE INDENT return False NEW_LINE DEDENT n = int ( ( n % divisor ) \/ 10 ) NEW_LINE divisor = int ( divisor \/ 100 ) NEW_LINE DEDENT return True NEW_LINE DEDENT def largestPalindrome ( A , n ) : NEW_LINE INDENT V = [ ] NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( isPalindrome ( A [ i ] ) ) ) : NEW_LINE INDENT return A [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 1 , 232 , 545 , 999991 ] NEW_LINE n = len ( A ) NEW_LINE print ( largestPalindrome ( A , n ) ) NEW_LINE DEDENT"],"references":["def isPalindrome ( n ) : NEW_LINE INDENT divisor = 1 NEW_LINE while ( n \/ divisor >= 10 ) : NEW_LINE INDENT divisor *= 10 NEW_LINE DEDENT while ( n != 0 ) : NEW_LINE INDENT leading = n \/\/ divisor NEW_LINE trailing = n % 10 NEW_LINE if ( leading != trailing ) : NEW_LINE INDENT return False NEW_LINE DEDENT n = ( n % divisor ) \/\/ 10 NEW_LINE divisor = divisor \/\/ 100 NEW_LINE DEDENT return True NEW_LINE DEDENT def largestPalindrome ( A , n ) : NEW_LINE INDENT A . sort ( ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( isPalindrome ( A [ i ] ) ) : NEW_LINE INDENT return A [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 1 , 232 , 54545 , 999991 ] NEW_LINE n = len ( A ) NEW_LINE print ( largestPalindrome ( A , n ) ) NEW_LINE DEDENT"],"bleu":0.7914367260686124,"rouge_l":0.9166237334707196}
{"id":1100,"predictions":["def getPerfectSquares ( n ) : NEW_LINE INDENT perfectSquares = [ ] ; NEW_LINE current = 1 ; NEW_LINE i = 1 ; NEW_LINE while ( current <= n ) : NEW_LINE INDENT perfectSquares . append ( current ) ; NEW_LINE current = int ( i ** 2 ) ; NEW_LINE DEDENT return perfectSquares ; NEW_LINE DEDENT def maxPairSum ( arr ) : NEW_LINE INDENT n = len ( arr ) ; NEW_LINE max = arr [ 0 ] ; NEW_LINE secondMax = arr [ 1 ] ; NEW_LINE if ( arr [ 0 ] > arr [ 1 ] ) : NEW_LINE INDENT max = arr [ 0 ] ; NEW_LINE secondMax = arr [ 1 ] ; NEW_LINE DEDENT else : NEW_LINE INDENT max = arr [ 1 ] ; NEW_LINE secondMax = arr [ 1 ] ; NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if ( arr [ i ] > max ) : NEW_LINE INDENT secondMax = max ; NEW_LINE max = arr [ i ] ; NEW_LINE DEDENT elif ( arr [ i ] > secondMax ) : NEW_LINE INDENT secondMax = arr [ i ] ; NEW_LINE DEDENT DEDENT return ( max + secondMax ) ; NEW_LINE DEDENT def countPairsWith ( n , perfectSquares , nums ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( len ( perfectSquares ) ) : NEW_LINE INDENT temp = perfectSquares [ i ] - n ; NEW_LINE if ( temp > n and nums . in temp ) ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return count + secondMax ; NEW_LINE DEDENT def countPairsWith ( arr ) : NEW_LINE INDENT n = len ( arr ) ; NEW_LINE max = maxPairSum ( arr ) ; NEW_LINE perfectSquares = getPerfectSquares ( arr ) ; NEW_LINE perfectSquares = getPerfectSquares ( max ) ; NEW_LINE nums = set ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT num"],"references":["def getPerfectSquares ( n ) : NEW_LINE INDENT perfectSquares = [ ] ; NEW_LINE current = 1 ; NEW_LINE i = 1 ; NEW_LINE while ( current <= n ) : NEW_LINE INDENT perfectSquares . append ( current ) ; NEW_LINE i += 1 ; NEW_LINE current = int ( pow ( i , 2 ) ) ; NEW_LINE DEDENT return perfectSquares ; NEW_LINE DEDENT def maxPairSum ( arr ) : NEW_LINE INDENT n = len ( arr ) ; NEW_LINE max = 0 ; NEW_LINE secondMax = 0 ; NEW_LINE if ( arr [ 0 ] > arr [ 1 ] ) : NEW_LINE INDENT max = arr [ 0 ] ; NEW_LINE secondMax = arr [ 1 ] ; NEW_LINE DEDENT else : NEW_LINE INDENT max = arr [ 1 ] ; NEW_LINE secondMax = arr [ 0 ] ; NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if ( arr [ i ] > max ) : NEW_LINE INDENT secondMax = max ; NEW_LINE max = arr [ i ] ; NEW_LINE DEDENT elif ( arr [ i ] > secondMax ) : NEW_LINE INDENT secondMax = arr [ i ] ; NEW_LINE DEDENT DEDENT return ( max + secondMax ) ; NEW_LINE DEDENT def countPairsWith ( n , perfectSquares , nums ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( len ( perfectSquares ) ) : NEW_LINE INDENT temp = perfectSquares [ i ] - n ; NEW_LINE if ( temp > n and ( temp in nums ) ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT def countPairs ( arr ) : NEW_LINE INDENT n = len ( arr ) ; NEW_LINE max = maxPairSum ( arr ) ; NEW_LINE perfectSquares = getPerfectSquares ( max ) ; NEW_LINE nums = [ ] ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT nums . append ( arr [ i ] ) ; NEW_LINE DEDENT count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT count += countPairsWith ( arr [ i ] , perfectSquares , nums ) ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT arr = [ 2 , 3 , 6 , 9 , 10 , 20 ] ; NEW_LINE print ( countPairs ( arr ) ) ; NEW_LINE"],"bleu":0.7520723916852461,"rouge_l":0.8382776372044324}
{"id":1101,"predictions":["if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT i = 1 NEW_LINE spt = 4 NEW_LINE prt = 4 NEW_LINE for i in range ( 1 , 5 ) : NEW_LINE INDENT for sp in range ( space , 0 , 1 ) : NEW_LINE INDENT print ( \" ▁ \" , end = \" \" ) NEW_LINE DEDENT for k in range ( 1 , ( i - 1 ) , 1 ) : NEW_LINE INDENT if ( i == 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT print ( prt ) NEW_LINE DEDENT print ( \" \" ) NEW_LINE space -= 1 NEW_LINE DEDENT space = 1 NEW_LINE for i in range ( 4 , 0 , - 1 ) : NEW_LINE INDENT for space in range ( space , 0 + 1 ) : NEW_LINE INDENT print ( \" ▁ \" , end = \" \" ) NEW_LINE DEDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( \" ▁ \" , end = \" \" ) NEW_LINE DEDENT for k in range ( 1 , i - 1 ) : NEW_LINE INDENT print ( prt , end = \" \" \" ) NEW_LINE DEDENT for k in range ( 1 , ( i + 1 ) + 1 ) : NEW_LINE INDENT print ( prt , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE print ( \" \" \\n \" , end = \" \" ) NEW_LINE DEDENT DEDENT"],"references":["if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT space = 4 NEW_LINE prt = ' $ ' NEW_LINE for i in range ( 1 , 6 ) : NEW_LINE INDENT for sp in range ( space , 0 , - 1 ) : NEW_LINE INDENT print ( end = \" ▁ \" ) NEW_LINE DEDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( prt , end = \" \" ) NEW_LINE DEDENT for k in range ( 1 , i ) : NEW_LINE INDENT if ( i == 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT print ( prt , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE space -= 1 NEW_LINE DEDENT space = 1 NEW_LINE for i in range ( 4 , 0 , - 1 ) : NEW_LINE INDENT for sp in range ( space , 0 , - 1 ) : NEW_LINE INDENT print ( end = \" ▁ \" ) NEW_LINE DEDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( prt , end = \" \" ) NEW_LINE DEDENT for k in range ( 1 , i ) : NEW_LINE INDENT print ( prt , end = \" \" ) NEW_LINE DEDENT space += 1 NEW_LINE print ( ) NEW_LINE DEDENT space = 3 NEW_LINE for i in range ( 2 , 6 ) : NEW_LINE INDENT if ( ( i % 2 ) != 0 ) : NEW_LINE INDENT for sp in range ( space , 0 , - 1 ) : NEW_LINE INDENT print ( \" ▁ \" , end = \" \" ) NEW_LINE DEDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( prt , end = \" \" ) NEW_LINE DEDENT DEDENT if ( ( i % 2 ) != 0 ) : NEW_LINE INDENT print ( ) NEW_LINE space -= 1 NEW_LINE DEDENT DEDENT DEDENT"],"bleu":0.5957061953785612,"rouge_l":0.7212339442145429}
{"id":1102,"predictions":["def maxLen ( arr , n ) : NEW_LINE INDENT min_val = min ( arr ) NEW_LINE freq = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == min_val ) : NEW_LINE INDENT freq += 1 NEW_LINE DEDENT DEDENT return freq NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 3 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxLen ( arr , n ) ) NEW_LINE DEDENT"],"references":["def maxLen ( arr , n ) : NEW_LINE INDENT min_val = min ( arr ) ; NEW_LINE freq = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == min_val ) : NEW_LINE INDENT freq += 1 ; NEW_LINE DEDENT DEDENT return freq ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 3 , 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( maxLen ( arr , n ) ) ; NEW_LINE DEDENT"],"bleu":0.7693860923773036,"rouge_l":0.9375208820581356}
{"id":1103,"predictions":["def printKDistinct ( arr , n , k ) : NEW_LINE INDENT h = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT h [ arr [ i ] ] = h . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT if ( len ( h ) < k ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT dist_count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( h [ arr [ i ] ] == 1 ) : NEW_LINE INDENT dist_count += 1 NEW_LINE DEDENT if ( dist_count == k ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT ar = [ 1 , 2 , 1 , 3 , 4 , 2 ] NEW_LINE n = len ( ar ) NEW_LINE print ( printKDistinct ( ar , n , 2 ) ) NEW_LINE print ( printKDistinct ( ar , n , 2 ) ) NEW_LINE DEDENT"],"references":["def printKDistinct ( arr , size , KthIndex ) : NEW_LINE INDENT dict = { } NEW_LINE vect = [ ] NEW_LINE for i in range ( size ) : NEW_LINE INDENT if ( arr [ i ] in dict ) : NEW_LINE INDENT dict [ arr [ i ] ] = dict [ arr [ i ] ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dict [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT for i in range ( size ) : NEW_LINE INDENT if ( dict [ arr [ i ] ] > 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT KthIndex = KthIndex - 1 NEW_LINE DEDENT if ( KthIndex == 0 ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 1 , 2 , 1 , 3 , 4 , 2 ] NEW_LINE size = len ( arr ) NEW_LINE print ( printKDistinct ( arr , size , 2 ) ) NEW_LINE"],"bleu":0.487414081330837,"rouge_l":0.6532723112128147}
{"id":1104,"predictions":["def checkSubarraySum ( arr , n , k , sum ) : NEW_LINE INDENT curr_sum = 0 NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT curr_sum += arr [ i ] NEW_LINE DEDENT if ( curr_sum == sum ) : NEW_LINE INDENT return True NEW_LINE for j in range ( k , n ) : NEW_LINE INDENT curr_sum = curr_sum + arr [ j ] - arr [ j - k ] NEW_LINE if ( curr_sum == sum ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT arr = [ 1 , 4 , 2 , 10 , 2 , 3 , 1 , 0 , 20 ] NEW_LINE k = 4 NEW_LINE sum = 18 NEW_LINE n = len ( arr ) NEW_LINE if ( checkSubarraySum ( arr , n , k , sum ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"],"references":["def checkSubarraySum ( arr , n , k , sumV ) : NEW_LINE INDENT curr_sum = 0 NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT curr_sum += arr [ i ] NEW_LINE DEDENT if ( curr_sum == sumV ) : NEW_LINE INDENT return true NEW_LINE DEDENT for j in range ( k , n ) : NEW_LINE INDENT curr_sum = ( curr_sum + arr [ j ] - arr [ j - k ] ) NEW_LINE if ( curr_sum == sumV ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT arr = [ 1 , 4 , 2 , 10 , 2 , 3 , 1 , 0 , 20 ] NEW_LINE k = 4 NEW_LINE sumV = 18 NEW_LINE n = len ( arr ) NEW_LINE if ( checkSubarraySum ( arr , n , k , sumV ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"],"bleu":0.8707771166022344,"rouge_l":0.9522122198812488}
{"id":1105,"predictions":["def printCombination ( n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( i % 3 != 0 ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if ( j % 3 != 0 and ( i + j + k ) == n ) : NEW_LINE INDENT if ( k % 3 != 0 and ( i + j + k ) == n ) : NEW_LINE INDENT print ( i , j , k ) ; NEW_LINE return 0 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT printCombination ( n ) ; NEW_LINE"],"references":["def printCombination ( n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( i % 3 != 0 ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if ( j % 3 != 0 ) : NEW_LINE INDENT for k in range ( 1 , n ) : NEW_LINE INDENT if ( k % 3 != 0 and ( i + j + k ) == n ) : NEW_LINE INDENT print ( i , j , k ) ; NEW_LINE return ; NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT n = 233 ; NEW_LINE printCombination ( n ) ; NEW_LINE"],"bleu":0.820764280958562,"rouge_l":0.8859461768475011}
{"id":1106,"predictions":["import math NEW_LINE def countNumbersWith4 ( n ) : NEW_LINE INDENT if ( n < 4 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT d = int ( math . log10 ( n , 2 ) ) NEW_LINE a = [ 0 for i in range ( d + 2 ) ] NEW_LINE a [ 0 ] = 0 NEW_LINE a [ 1 ] = 1 NEW_LINE for i in range ( 2 , d + 1 ) : NEW_LINE INDENT a [ i ] = a [ i - 1 ] * 9 + int ( math . pow ( 10 , i - 1 ) ) NEW_LINE DEDENT p = int ( math . pow ( 10 , d ) ) NEW_LINE msd = n \/\/ p NEW_LINE if ( msd == 4 ) : NEW_LINE INDENT return ( msd ) * a [ d ] + ( n % p ) + 1 NEW_LINE DEDENT if ( msd > 4 ) : NEW_LINE INDENT return ( msd - 1 ) * a [ d ] + p + 1 NEW_LINE DEDENT return ( msd ) * a [ d ] + countNumbersWith4 ( n % p ) NEW_LINE DEDENT n = 328 NEW_LINE print ( \" Count ▁ of ▁ numbers ▁ from ▁ 1 ▁ to \" , n , \" ▁ to ▁ a ▁ digit ▁ is ▁ \" , countNumbersWith4 ( n ) ) NEW_LINE"],"references":["import math as mt NEW_LINE def countNumbersWith4 ( n ) : NEW_LINE INDENT if ( n < 4 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT d = int ( mt . log10 ( n ) ) NEW_LINE a = [ 1 for i in range ( d + 1 ) ] NEW_LINE a [ 0 ] = 0 NEW_LINE if len ( a ) > 1 : NEW_LINE INDENT a [ 1 ] = 1 NEW_LINE DEDENT for i in range ( 2 , d + 1 ) : NEW_LINE INDENT a [ i ] = a [ i - 1 ] * 9 + mt . ceil ( pow ( 10 , i - 1 ) ) NEW_LINE DEDENT p = mt . ceil ( pow ( 10 , d ) ) NEW_LINE msd = n \/\/ p NEW_LINE if ( msd == 4 ) : NEW_LINE INDENT return ( msd ) * a [ d ] + ( n % p ) + 1 NEW_LINE DEDENT if ( msd > 4 ) : NEW_LINE INDENT return ( ( msd - 1 ) * a [ d ] + p + countNumbersWith4 ( n % p ) ) NEW_LINE DEDENT return ( msd ) * a [ d ] + countNumbersWith4 ( n % p ) NEW_LINE DEDENT n = 328 NEW_LINE print ( \" Count ▁ of ▁ numbers ▁ from ▁ 1 ▁ to \" , n , \" that ▁ have ▁ 4 ▁ as ▁ a ▁ digit ▁ is \" , countNumbersWith4 ( n ) ) NEW_LINE"],"bleu":0.7846651440622292,"rouge_l":0.8941751317988942}
{"id":1107,"predictions":["from math import sqrt NEW_LINE arr = [ ] NEW_LINE def generateDivisors ( n ) : NEW_LINE INDENT for i in range ( 1 , int ( sqrt ( n ) ) + 1 , 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n \/ i == i ) : NEW_LINE INDENT arr . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT arr . append ( i ) NEW_LINE arr . append ( n \/ i ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def harmonicMean ( n ) : NEW_LINE INDENT generateDivisors ( n ) NEW_LINE sum = 0.0 NEW_LINE l = len ( arr ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT sum = sum + n \/ arr [ i ] NEW_LINE DEDENT sum = sum \/ n NEW_LINE return ( sum \/ n ) NEW_LINE DEDENT def isIconNumber ( n ) : NEW_LINE INDENT mean = harmonicMean ( n ) NEW_LINE if ( mean - floor ( mean ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 28 NEW_LINE if ( isIconNumber ( n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"references":["arr = [ ] NEW_LINE def generateDivisors ( n ) : NEW_LINE INDENT for i in range ( 1 , int ( n ** ( 0.5 ) ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT if n \/\/ i == i : NEW_LINE INDENT arr . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT arr . append ( i ) NEW_LINE arr . append ( n \/\/ i ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def harmonicMean ( n ) : NEW_LINE INDENT generateDivisors ( n ) NEW_LINE Sum = 0 NEW_LINE length = len ( arr ) NEW_LINE for i in range ( 0 , length ) : NEW_LINE INDENT Sum = Sum + ( n \/ arr [ i ] ) NEW_LINE DEDENT Sum = Sum \/ n NEW_LINE return length \/ Sum NEW_LINE DEDENT def isOreNumber ( n ) : NEW_LINE INDENT mean = harmonicMean ( n ) NEW_LINE if mean - int ( mean ) == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 28 NEW_LINE if isOreNumber ( n ) == True : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.703417312535773,"rouge_l":0.873588543101074}
{"id":1108,"predictions":["import math NEW_LINE def powOfPositive ( n ) : NEW_LINE INDENT pos = int ( math . floor ( math . log2 ( n ) ) ) ; NEW_LINE return int ( math . floor ( math . log ( n ) ) ) ; NEW_LINE DEDENT def powOfNegative ( n ) : NEW_LINE INDENT pos = int ( math . floor ( log ( n ) \/ math . log ( 2 ) ) ) ; NEW_LINE return - 1 * pow ( 2 , pos ) ; NEW_LINE DEDENT def highestPowerOf2 ( n ) : NEW_LINE INDENT if ( n > 0 ) : NEW_LINE INDENT print ( powOfPositive ( n ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT n = - n ; NEW_LINE print ( powOfNegitive ( n ) ) ; NEW_LINE DEDENT DEDENT n = - 24 ; NEW_LINE highestPowerOf2 ( n ) ; NEW_LINE"],"references":["from math import floor , ceil , log2 NEW_LINE def powOfPositive ( n ) : NEW_LINE INDENT pos = floor ( log2 ( n ) ) ; NEW_LINE return 2 ** pos ; NEW_LINE DEDENT def powOfNegative ( n ) : NEW_LINE INDENT pos = ceil ( log2 ( n ) ) ; NEW_LINE return ( - 1 * pow ( 2 , pos ) ) ; NEW_LINE DEDENT def highestPowerOf2 ( n ) : NEW_LINE INDENT if ( n > 0 ) : NEW_LINE INDENT print ( powOfPositive ( n ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT n = - n ; NEW_LINE print ( powOfNegative ( n ) ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = - 24 ; NEW_LINE highestPowerOf2 ( n ) ; NEW_LINE DEDENT"],"bleu":0.6782828928611492,"rouge_l":0.7793343046060741}
{"id":1109,"predictions":["from math import sqrt NEW_LINE prime = [ True for i in range ( 1000000 ) ] NEW_LINE def findPrime ( ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE for p in range ( 1000000 ) : NEW_LINE INDENT if ( p * p >= 1000000 ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , 1000000 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def lenOfLongSubarr ( arr , n ) : NEW_LINE INDENT um = { } NEW_LINE Sum = 0 NEW_LINE maxLen = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum += prime [ arr [ i ] ] NEW_LINE if ( Sum == 1 ) : NEW_LINE INDENT maxLen = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT Sum = 0 NEW_LINE DEDENT if ( Sum not in um . keys ( ) ) : NEW_LINE INDENT um [ Sum ] = i NEW_LINE DEDENT if ( Sum - 1 ) in um . keys ( ) : NEW_LINE INDENT if ( maxLen < ( i - um [ Sum - 1 ] ) ) : NEW_LINE INDENT maxLen = i - um [ Sum - 1 ] NEW_LINE DEDENT DEDENT return maxLen NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT findPrimeSubarr ( arr , n ) NEW_LINE arr = [ 1 , 9 , 3 , 4 , 5 , 6 , 7 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( lenOfLongSubarr ( arr , n ) ) NEW_LINE DEDENT"],"references":["prime = [ True ] * ( 1000000 + 5 ) NEW_LINE def findPrime ( ) : NEW_LINE INDENT prime [ 0 ] , prime [ 1 ] = False , False NEW_LINE for p in range ( 2 , 1001 ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , 1000001 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def lenOfLongSubarr ( arr , n ) : NEW_LINE INDENT um = { } NEW_LINE Sum , maxLen = 0 , 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT Sum = Sum - 1 if prime [ arr [ i ] ] == False else Sum + 1 NEW_LINE if Sum == 1 : NEW_LINE INDENT maxLen = i + 1 NEW_LINE DEDENT elif Sum not in um : NEW_LINE INDENT um [ Sum ] = i NEW_LINE DEDENT if ( Sum - 1 ) in um : NEW_LINE INDENT if maxLen < ( i - um [ Sum - 1 ] ) : NEW_LINE INDENT maxLen = i - um [ Sum - 1 ] NEW_LINE DEDENT DEDENT DEDENT return maxLen NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT findPrime ( ) NEW_LINE arr = [ 1 , 9 , 3 , 4 , 5 , 6 , 7 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( lenOfLongSubarr ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.6845615174179424,"rouge_l":0.8319655192773218}
{"id":1110,"predictions":["def turnOffK ( n , k ) : NEW_LINE INDENT if ( k <= 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return ( n & ~ ~ ( 1 << ( k - 1 ) ) ) NEW_LINE DEDENT n = 15 NEW_LINE k = 4 NEW_LINE print ( turnOffK ( n , k ) ) NEW_LINE"],"references":["def turnOffK ( n , k ) : NEW_LINE INDENT if ( k <= 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return ( n & ~ ( 1 << ( k - 1 ) ) ) NEW_LINE DEDENT n = 15 NEW_LINE k = 4 NEW_LINE print ( turnOffK ( n , k ) ) NEW_LINE"],"bleu":0.9697034041206901,"rouge_l":0.9929834409205726}
{"id":1111,"predictions":["import math as mt NEW_LINE def longestSubarray ( a , n ) : NEW_LINE INDENT hash = [ [ 0 for i in range ( 10 ) ] for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT num = a [ i ] NEW_LINE while ( num != 0 ) : NEW_LINE INDENT hash [ i ] [ num % 10 ] = 1 NEW_LINE num = int ( num \/ 10 ) NEW_LINE DEDENT DEDENT longest = - 10 NEW_LINE count = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT j = 0 NEW_LINE for j in range ( 10 ) : NEW_LINE INDENT if ( hash [ i ] [ j ] == 1 & hash [ i + 1 ] [ j ] == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE break NEW_LINE DEDENT if ( j == 10 ) : NEW_LINE INDENT longest = max ( longest , count + 1 ) NEW_LINE count = 0 NEW_LINE DEDENT DEDENT longest = max ( longest , count + 1 ) NEW_LINE return longest NEW_LINE DEDENT longest = max ( longest , count + 1 ) NEW_LINE print ( longestSubarray ( a , n ) ) NEW_LINE"],"references":["import sys NEW_LINE def longestSubarray ( a , n ) : NEW_LINE INDENT hash = [ [ 0 for i in range ( 10 ) ] for j in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT num = a [ i ] NEW_LINE while ( num ) : NEW_LINE INDENT hash [ i ] [ num % 10 ] = 1 NEW_LINE num = int ( num \/ 10 ) NEW_LINE DEDENT DEDENT longest = - sys . maxsize - 1 NEW_LINE count = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT if ( hash [ i ] [ j ] and hash [ i + 1 ] [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( j == 10 ) : NEW_LINE INDENT longest = max ( longest , count + 1 ) NEW_LINE count = 0 NEW_LINE DEDENT DEDENT longest = max ( longest , count + 1 ) NEW_LINE return longest NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 11 , 22 , 33 , 44 , 54 , 56 , 63 ] NEW_LINE n = len ( a ) NEW_LINE print ( longestSubarray ( a , n ) ) NEW_LINE DEDENT"],"bleu":0.7602003254484909,"rouge_l":0.8457085685699991}
{"id":1112,"predictions":["def find_Solution ( x , n ) : NEW_LINE INDENT sum = x NEW_LINE e = 2 NEW_LINE o = 1 NEW_LINE p = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT p += 2 NEW_LINE sum += ( o \/ e ) * ( pow ( x , p ) \/ p ) NEW_LINE o = e * ( e + 2 ) NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT x = - 0.5 NEW_LINE if ( abs ( x ) >= 1 ) : NEW_LINE INDENT print ( \" Invalid ▁ Input \" ) NEW_LINE DEDENT n = 8 NEW_LINE find_Solution ( x , n ) NEW_LINE"],"references":["def find_Solution ( x , n ) : NEW_LINE INDENT Sum = x NEW_LINE e = 2 NEW_LINE o = 1 NEW_LINE p = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT p += 2 NEW_LINE Sum += ( o \/ e ) * ( pow ( x , p ) \/ p ) NEW_LINE o = o * ( o + 2 ) NEW_LINE e = e * ( e + 2 ) NEW_LINE DEDENT print ( round ( Sum , 10 ) ) NEW_LINE DEDENT x = - 0.5 NEW_LINE if ( abs ( x ) >= 1 ) : NEW_LINE INDENT print ( \" Invalid ▁ Input \\n \" ) NEW_LINE DEDENT n = 8 NEW_LINE find_Solution ( x , n ) NEW_LINE"],"bleu":0.7993661858340202,"rouge_l":0.9023668639053254}
{"id":1113,"predictions":["def replaceOriginal ( s , n ) : NEW_LINE INDENT r = [ 0 ] * n ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT r [ i ] = s [ n - 1 - i ] ; NEW_LINE if ( s [ i ] != ' a ' and s [ i ] != ' e ' and s [ i ] != ' o ' and s [ i ] != ' u ' ) : NEW_LINE INDENT print ( r [ i ] , end = ' \" ) ; NEW_LINE DEDENT DEDENT print ( \" \" ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" geeksforgeeks \" ; NEW_LINE n = len ( s ) ; NEW_LINE replaceOriginal ( s , n ) ; NEW_LINE DEDENT"],"references":["def replaceOriginal ( s , n ) : NEW_LINE INDENT r = [ ' ▁ ' ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT r [ i ] = s [ n - 1 - i ] NEW_LINE if ( s [ i ] != ' a ' and s [ i ] != ' e ' and s [ i ] != ' i ' and s [ i ] != ' o ' and s [ i ] != ' u ' ) : NEW_LINE INDENT print ( r [ i ] , end = \" \" ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" geeksforgeeks \" NEW_LINE n = len ( s ) NEW_LINE replaceOriginal ( s , n ) NEW_LINE DEDENT"],"bleu":0.8217192080423954,"rouge_l":0.9172421474715972}
{"id":1114,"predictions":["def SieveOfEratosthenes ( prime , p_size ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , p_size + 1 ) : NEW_LINE INDENT if ( p * p <= p_size ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( p == True ) : NEW_LINE INDENT for i in range ( 2 , p_size + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def xorOfPrime ( s ) : NEW_LINE INDENT prime = [ True ] * 100005 NEW_LINE SieveOfEratosthenes ( prime , 10005 ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE m = dict ( ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT m [ s [ i ] ] = m [ s [ i ] ] + 1 NEW_LINE DEDENT ans = 0 NEW_LINE flag = 0 NEW_LINE for key , value in m . items ( ) : NEW_LINE INDENT if ( prime [ key ] ) : NEW_LINE INDENT result ^= key NEW_LINE flag = 1 NEW_LINE DEDENT DEDENT if ( flag != 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" geeksgeekkkkkks \" NEW_LINE print ( xorOfPrime ( s ) ) NEW_LINE DEDENT"],"references":["from collections import defaultdict NEW_LINE def SieveOfEratosthenes ( prime , p_size ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= p_size : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT for i in range ( p * 2 , p_size + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT def xorOfPrime ( s ) : NEW_LINE INDENT prime = [ True ] * 100005 NEW_LINE SieveOfEratosthenes ( prime , 10005 ) NEW_LINE m = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT m [ s [ i ] ] += 1 NEW_LINE DEDENT result = flag = 0 NEW_LINE for it in m : NEW_LINE INDENT if prime [ m [ it ] ] : NEW_LINE INDENT result ^= m [ it ] NEW_LINE flag = 1 NEW_LINE DEDENT DEDENT if not flag : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" gggggeeekkkks \" NEW_LINE print ( xorOfPrime ( s ) ) NEW_LINE DEDENT"],"bleu":0.6470452097071999,"rouge_l":0.8071997723392146}
{"id":1115,"predictions":["def findNumbers ( n , d ) : NEW_LINE INDENT for i in range ( n - 2 ) : NEW_LINE INDENT print ( \"1\" , end = \" ▁ \" ) NEW_LINE DEDENT print ( \"1\" , end = \" ▁ \" ) NEW_LINE printNumbers ( n , end = \" ▁ \" ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE D = 5 NEW_LINE findNumbers ( N , D ) NEW_LINE DEDENT"],"references":["def pattern ( n , d ) : NEW_LINE INDENT for i in range ( 0 , n - 2 ) : NEW_LINE INDENT print ( \"1\" , end = \" ▁ \" ) NEW_LINE DEDENT print ( \"2\" , end = \" ▁ \" ) NEW_LINE print ( n + d ) NEW_LINE DEDENT N = 3 NEW_LINE D = 5 NEW_LINE pattern ( N , D ) NEW_LINE"],"bleu":0.6037113195204677,"rouge_l":0.809850107066381}
{"id":1116,"predictions":["PI = 3.142 ; NEW_LINE def pi ( x , val ) : NEW_LINE INDENT x = 60.0 ; NEW_LINE val = PI \/ 180.0 ; NEW_LINE ret = cos ( x * val ) ; NEW_LINE print ( \" The ▁ cos ▁ of ▁ \" , x , \" is \" , round ( val ) ) ; NEW_LINE print ( \" The ▁ cos ▁ of ▁ \" , x , \" is \" ) ; NEW_LINE x = 90.0 ; NEW_LINE a = 90.0 ; NEW_LINE b = 180.0 ; NEW_LINE res = math . pi \/ 180.0 ; NEW_LINE print ( \" The ▁ cos ▁ of ▁ \" , a ) ; NEW_LINE print ( \" The ▁ cos ▁ of ▁ \" , x , \" is \" , round ( res ) ) ; NEW_LINE print ( \" The ▁ cos ▁ of ▁ \" , x , \" is \" , round ( res , 2 ) ) ; NEW_LINE print ( \" The ▁ cr ▁ of ▁ % d ▁ is \" % ( x * x ) , \" is \" % ( res ) ) ; NEW_LINE"],"references":["import math NEW_LINE if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT PI = 3.14159265 NEW_LINE x = 60.0 NEW_LINE val = PI \/ 180.0 NEW_LINE ret = math . cos ( x * val ) NEW_LINE print ( \" The ▁ cosine ▁ of ▁ is ▁ \" , x , end = \" ▁ \" ) NEW_LINE print ( \" ▁ degrees \" , ret ) NEW_LINE x = 90.0 NEW_LINE val = PI \/ 180.0 NEW_LINE ret = math . cos ( x * val ) NEW_LINE print ( \" The ▁ cosine ▁ of ▁ is ▁ \" , x , end = \" ▁ \" ) NEW_LINE print ( \" degrees \" , ret ) NEW_LINE DEDENT"],"bleu":0.2294718954338359,"rouge_l":0.5437290268456376}
{"id":1117,"predictions":["N = 100 NEW_LINE INF = 1000000 NEW_LINE dp = [ [ [ 0 for i in range ( N ) ] for i in range ( N ) ] NEW_LINE vis = [ [ [ 0 for i in range ( N ) ] for i in range ( N ) ] for i in range ( N ) ] NEW_LINE def findSum ( arr , n , k , l , r ) : NEW_LINE INDENT if ( ( l ) + ( n - 1 - r ) == k ) : NEW_LINE INDENT return arr [ r ] [ r ] - arr [ l ] NEW_LINE DEDENT if ( vis [ l ] [ r ] == 1 ) : NEW_LINE INDENT return dp [ l ] [ r ] NEW_LINE DEDENT vis [ l ] [ r ] = 1 NEW_LINE dp [ l ] [ r ] = min ( findSum ( arr , n , k , l - 1 ) , findSum ( arr , n , k , l + 1 , r ) ) NEW_LINE return dp [ l ] [ r ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 100 , 120 , 140 ] NEW_LINE k = 2 NEW_LINE n = len ( arr ) NEW_LINE print ( findSum ( arr , n , k , 0 , n - 1 ) ) NEW_LINE DEDENT"],"references":["import numpy as np NEW_LINE N = 100 NEW_LINE INF = 1000000 NEW_LINE dp = np . zeros ( ( N , N ) ) ; NEW_LINE vis = np . zeros ( ( N , N ) ) ; NEW_LINE def findSum ( arr , n , k , l , r ) : NEW_LINE INDENT if ( ( l ) + ( n - 1 - r ) == k ) : NEW_LINE INDENT return arr [ r ] - arr [ l ] ; NEW_LINE DEDENT if ( vis [ l ] [ r ] ) : NEW_LINE INDENT return dp [ l ] [ r ] ; NEW_LINE DEDENT vis [ l ] [ r ] = 1 ; NEW_LINE dp [ l ] [ r ] = min ( findSum ( arr , n , k , l , r - 1 ) , findSum ( arr , n , k , l + 1 , r ) ) ; NEW_LINE return dp [ l ] [ r ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 100 , 120 , 140 ] ; NEW_LINE k = 2 ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( findSum ( arr , n , k , 0 , n - 1 ) ) ; NEW_LINE DEDENT"],"bleu":0.7119031313781032,"rouge_l":0.8499024029077203}
{"id":1118,"predictions":["def totalPairs ( s1 , s2 ) : NEW_LINE INDENT count = 0 ; NEW_LINE arr1 = [ 0 ] * 7 ; NEW_LINE arr2 = [ 0 ] * 7 ; NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT set_bits = bin ( s1 [ i ] ) . count ( '1' ) ; NEW_LINE arr1 [ set_bits ] += 1 ; NEW_LINE DEDENT for i in range ( len ( s2 ) ) : NEW_LINE INDENT set_bits = bin ( s2 [ i ] ) . count ( '1' ) ; NEW_LINE arr2 [ set_bits ] += 1 ; NEW_LINE DEDENT for i in range ( 1 , 6 + 1 ) : NEW_LINE INDENT count += ( arr1 [ i ] * arr2 [ i ] ) ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s1 = \" geeks \" ; NEW_LINE s2 = \" forgeeks \" ; NEW_LINE print ( totalPairs ( s1 , s2 ) ) ; NEW_LINE DEDENT"],"references":["def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT count += n & 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def totalPairs ( s1 , s2 ) : NEW_LINE INDENT count = 0 ; NEW_LINE arr1 = [ 0 ] * 7 ; arr2 = [ 0 ] * 7 ; NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT set_bits = countSetBits ( ord ( s1 [ i ] ) ) NEW_LINE arr1 [ set_bits ] += 1 ; NEW_LINE DEDENT for i in range ( len ( s2 ) ) : NEW_LINE INDENT set_bits = countSetBits ( ord ( s2 [ i ] ) ) ; NEW_LINE arr2 [ set_bits ] += 1 ; NEW_LINE DEDENT for i in range ( 1 , 7 ) : NEW_LINE INDENT count += ( arr1 [ i ] * arr2 [ i ] ) ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s1 = \" geeks \" ; NEW_LINE s2 = \" forgeeks \" ; NEW_LINE print ( totalPairs ( s1 , s2 ) ) ; NEW_LINE DEDENT"],"bleu":0.7308829112099782,"rouge_l":0.8369286717910572}
{"id":1119,"predictions":["def minOperations ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE d = 0 ; NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT while ( n > 9 ) : NEW_LINE INDENT d = max ( n % 10 , d ) ; NEW_LINE n \/\/= 10 ; NEW_LINE count += 10 ; NEW_LINE DEDENT d = max ( d , n - 1 ) ; NEW_LINE count += abs ( d ) ; NEW_LINE return count - 1 ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 240 ; NEW_LINE print ( minOperations ( n ) ) ; NEW_LINE DEDENT"],"references":["def minOperations ( n ) : NEW_LINE INDENT count = 0 NEW_LINE d = 0 NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( n > 9 ) : NEW_LINE INDENT d = max ( n % 10 , d ) NEW_LINE n \/\/= 10 NEW_LINE count += 10 NEW_LINE DEDENT d = max ( d , n - 1 ) NEW_LINE count += abs ( d ) NEW_LINE return count - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 240 NEW_LINE print ( minOperations ( n ) ) NEW_LINE DEDENT"],"bleu":0.7162430471737405,"rouge_l":0.9421535771528486}
{"id":1120,"predictions":["def myCopy ( s1 , s2 ) : NEW_LINE INDENT for i in range ( 0 , len ( s1 ) ) : NEW_LINE INDENT s2 [ i ] = s1 [ i ] NEW_LINE DEDENT DEDENT s1 = \" GEEKSFORGEEKS \" NEW_LINE s2 = [ 0 for i in range ( len ( s1 ) ) ] NEW_LINE myCopy ( s1 , s2 ) NEW_LINE print ( s2 ) NEW_LINE"],"references":["def myCopy ( s1 , s2 ) : NEW_LINE INDENT for i in range ( len ( s1 ) ) : NEW_LINE INDENT s2 [ i ] = s1 [ i ] ; NEW_LINE DEDENT DEDENT s1 = \" GEEKSFORGEEKS \" ; NEW_LINE s2 = [ ' ' ] * ( len ( s1 ) ) ; NEW_LINE myCopy ( s1 , s2 ) ; NEW_LINE print ( ( \" \" . join ( s2 ) ) ) ; NEW_LINE"],"bleu":0.6538088295579735,"rouge_l":0.825563909774436}
{"id":1121,"predictions":["def bitonicGenerator ( arr , n ) : NEW_LINE INDENT evenArr = [ ] NEW_LINE oddArr = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i % 2 != 1 ) : NEW_LINE INDENT evenArr . append ( arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT oddArr . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT evenArr . sort ( reverse = True ) NEW_LINE oddArr . sort ( reverse = True ) NEW_LINE i = 0 NEW_LINE for j in range ( len ( evenArr ) ) : NEW_LINE INDENT arr [ i ] = evenArr [ j ] NEW_LINE i += 1 NEW_LINE DEDENT for j in range ( len ( oddArr ) ) : NEW_LINE INDENT arr [ i ] = oddArr [ j ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT arr = [ 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE arr = [ 1 , 5 , 8 , 6 , 7 , 3 , 4 , 2 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE bitonicGenerator ( arr , n ) NEW_LINE"],"references":["def bitonicGenerator ( arr , n ) : NEW_LINE INDENT evenArr = [ ] NEW_LINE oddArr = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( i % 2 ) == 0 ) : NEW_LINE INDENT evenArr . append ( arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT oddArr . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT evenArr = sorted ( evenArr ) NEW_LINE oddArr = sorted ( oddArr ) NEW_LINE oddArr = oddArr [ : : - 1 ] NEW_LINE i = 0 NEW_LINE for j in range ( len ( evenArr ) ) : NEW_LINE INDENT arr [ i ] = evenArr [ j ] NEW_LINE i += 1 NEW_LINE DEDENT for j in range ( len ( oddArr ) ) : NEW_LINE INDENT arr [ i ] = oddArr [ j ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT arr = [ 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE bitonicGenerator ( arr , n ) NEW_LINE for i in arr : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT"],"bleu":0.7908851752635706,"rouge_l":0.8222924048682791}
{"id":1122,"predictions":["def ReverseCharMatrix ( n ) : NEW_LINE INDENT for i in range ( 0 , ord ( ' A ' ) , ord ( ' A ' ) , ( 2 * n ) - 1 ) : NEW_LINE INDENT for j in range ( 0 , ord ( ' A ' ) , 2 * n ) : NEW_LINE INDENT if ( j >= ( A ' A ' + n - 1 ) + i ) : NEW_LINE INDENT print ( chr ( ( ord ( ' A ' ) + n - 1 ) , end = \" \" ) NEW_LINE DEDENT elif ( j <= ( ord ( ' A ' ) + n - 1 ) - i ) - i ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" ▁ \" , end = \" \" ) NEW_LINE DEDENT DEDENT print ( \" \" ) NEW_LINE DEDENT n = 6 NEW_LINE ReverseChar ( n ) NEW_LINE"],"references":["def ReverseCharBridge ( n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( ord ( ' A ' ) , ord ( ' A ' ) + ( 2 * n ) - 1 ) : NEW_LINE INDENT if j >= ( ord ( ' A ' ) + n - 1 ) + i : NEW_LINE INDENT print ( chr ( ( ord ( ' A ' ) + n - 1 ) - ( j % ( ord ( ' A ' ) + n - 1 ) ) ) , end = ' ' ) NEW_LINE DEDENT elif j <= ( ord ( ' A ' ) + n - 1 ) - i : NEW_LINE INDENT print ( chr ( j ) , end = ' ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( end = \" ▁ \" ) NEW_LINE DEDENT DEDENT print ( \" \\n \" , end = ' ' ) NEW_LINE DEDENT DEDENT n = 6 NEW_LINE ReverseCharBridge ( n ) NEW_LINE"],"bleu":0.6391821364169353,"rouge_l":0.7347322856874001}
{"id":1123,"predictions":["n = 4 NEW_LINE m = 4 NEW_LINE def calcProbability ( M , k ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( n ) ] for y in range ( m ) ] NEW_LINE sum = [ 0 for x in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ 0 ] [ j ] = M [ 0 ] [ j ] NEW_LINE sum [ 0 ] = sum [ 0 ] + dp [ 0 ] [ j ] NEW_LINE DEDENT for i in range ( 1 , m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i - 1 ] [ j ] \/ sum [ i - 1 ] + M [ i ] [ j ] NEW_LINE sum [ i ] += dp [ i ] [ j ] NEW_LINE DEDENT DEDENT return dp [ n - 1 ] [ k - 1 ] \/ sum [ n - 1 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT M = [ [ 1 , 1 , 0 , 3 ] , [ 2 , 3 , 2 , 3 ] , [ 9 , 3 , 0 , 2 ] , [ 2 , 3 , 2 ] , [ 2 , 3 , 2 , 2 ] ] NEW_LINE k = 3 NEW_LINE print ( calcProbability ( M , k ) ) NEW_LINE DEDENT"],"references":["n = 4 NEW_LINE m = 4 NEW_LINE def calcProbability ( M , k ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( m ) ] NEW_LINE Sum = [ 0 for i in range ( n ) ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT dp [ 0 ] [ j ] = M [ 0 ] [ j ] NEW_LINE Sum [ 0 ] += dp [ 0 ] [ j ] NEW_LINE DEDENT for i in range ( 1 , m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT dp [ i ] [ j ] += ( dp [ i - 1 ] [ j ] \/ Sum [ i - 1 ] + M [ i ] [ j ] ) NEW_LINE Sum [ i ] += dp [ i ] [ j ] NEW_LINE DEDENT DEDENT return dp [ n - 1 ] [ k - 1 ] \/ Sum [ n - 1 ] NEW_LINE DEDENT M = [ [ 1 , 1 , 0 , 3 ] , [ 2 , 3 , 2 , 3 ] , [ 9 , 3 , 0 , 2 ] , [ 2 , 3 , 2 , 2 ] ] NEW_LINE k = 3 NEW_LINE print ( calcProbability ( M , k ) ) NEW_LINE"],"bleu":0.8008856728834408,"rouge_l":0.9125024179508672}
{"id":1124,"predictions":["def largestSubset ( arr , n ) : NEW_LINE INDENT a = sorted ( arr ) NEW_LINE dp = [ 0 ] * n NEW_LINE dp [ n - 1 ] = 1 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT mxm = 0 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( a [ j ] % a [ i ] == 0 ) : NEW_LINE INDENT mxm = max ( mxm , dp [ j ] ) NEW_LINE DEDENT DEDENT dp [ i ] = 1 + mxm NEW_LINE DEDENT return max ( dp ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 3 , 6 , 13 , 17 , 18 ] NEW_LINE n = len ( a ) NEW_LINE print ( largestSubset ( a , n ) ) NEW_LINE DEDENT"],"references":["def largestSubset ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE dp = [ 0 for i in range ( n ) ] NEW_LINE dp [ n - 1 ] = 1 ; NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT mxm = 0 ; NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if a [ j ] % a [ i ] == 0 : NEW_LINE INDENT mxm = max ( mxm , dp [ j ] ) NEW_LINE DEDENT DEDENT dp [ i ] = 1 + mxm NEW_LINE DEDENT return max ( dp ) NEW_LINE DEDENT a = [ 1 , 3 , 6 , 13 , 17 , 18 ] NEW_LINE n = len ( a ) NEW_LINE print ( largestSubset ( a , n ) ) NEW_LINE"],"bleu":0.7870087184478249,"rouge_l":0.8988150437918598}
{"id":1125,"predictions":["def findLargest ( N ) : NEW_LINE INDENT largest = strings ( N , '7' ) NEW_LINE return smallest NEW_LINE DEDENT def findSmallest ( N ) : NEW_LINE INDENT smallest = \"1\" + str ( ( N - 1 ) , '0' ) NEW_LINE return smallest NEW_LINE DEDENT def strings ( N , c ) : NEW_LINE INDENT temp = \" \" NEW_LINE for i in range ( N ) : NEW_LINE INDENT temp += c NEW_LINE DEDENT return temp NEW_LINE DEDENT def printLargestSmallest ( N ) : NEW_LINE INDENT print ( \" Largest : ▁ \" , findLargest ( N ) ) NEW_LINE print ( \" Smallest : ▁ \" , findSmallest ( N ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE printLargestSmallest ( N ) NEW_LINE DEDENT"],"references":["def findLargest ( N ) : NEW_LINE INDENT largest = strings ( N , '7' ) ; NEW_LINE return largest ; NEW_LINE DEDENT def findSmallest ( N ) : NEW_LINE INDENT smallest = \"1\" + strings ( ( N - 1 ) , '0' ) ; NEW_LINE return smallest ; NEW_LINE DEDENT def strings ( N , c ) : NEW_LINE INDENT temp = \" \" ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT temp += c ; NEW_LINE DEDENT return temp ; NEW_LINE DEDENT def printLargestSmallest ( N ) : NEW_LINE INDENT print ( \" Largest : ▁ \" , findLargest ( N ) ) ; NEW_LINE print ( \" Smallest : ▁ \" , findSmallest ( N ) ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 ; NEW_LINE printLargestSmallest ( N ) ; NEW_LINE DEDENT"],"bleu":0.7927835911699356,"rouge_l":0.9428129829984544}
{"id":1126,"predictions":["def findMaxNum ( arr , n ) : NEW_LINE INDENT hash = [ 0 for i in range ( 10 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( 9 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( Hash [ i ] ) : NEW_LINE INDENT print ( i , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE findMaxNum ( arr , n ) NEW_LINE"],"references":["def findMaxNum ( arr , n ) : NEW_LINE INDENT hash = [ 0 ] * 10 NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( 9 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( hash [ i ] ) : NEW_LINE INDENT print ( i , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE findMaxNum ( arr , n ) NEW_LINE DEDENT"],"bleu":0.8201955660596598,"rouge_l":0.8902702702702702}
{"id":1127,"predictions":["def countDigit ( n ) : NEW_LINE INDENT c = 0 NEW_LINE while n : NEW_LINE INDENT c += 1 NEW_LINE n = n \/\/ 10 NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return c NEW_LINE DEDENT def isdeserium ( x ) : NEW_LINE INDENT temp = x NEW_LINE p = countDigit ( x ) NEW_LINE sum = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT digit = x % 10 NEW_LINE sum += pow ( digit , p ) NEW_LINE p -= 1 NEW_LINE x = x \/\/ 10 NEW_LINE DEDENT return ( sum == temp ) NEW_LINE DEDENT x =135 NEW_LINE if ( isdeserium ( x ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def countDigits ( n ) : NEW_LINE INDENT c = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT c += 1 NEW_LINE n = int ( n \/ 10 ) NEW_LINE DEDENT return c NEW_LINE DEDENT def isDeserium ( x ) : NEW_LINE INDENT temp = x NEW_LINE p = countDigits ( x ) NEW_LINE sum = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT digit = int ( x % 10 ) NEW_LINE sum += pow ( digit , p ) NEW_LINE p -= 1 NEW_LINE x = int ( x \/ 10 ) NEW_LINE DEDENT return ( sum == temp ) NEW_LINE DEDENT x = 135 NEW_LINE if ( isDeserium ( x ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.7217610867175378,"rouge_l":0.8649514008004574}
{"id":1128,"predictions":["import math NEW_LINE def polyarea ( n , r ) : NEW_LINE INDENT if ( r < 0 and n < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT A = ( ( r * r * n ) * sin ( 360 \/ n ) * 3.14159 \/ 180 ) NEW_LINE return A NEW_LINE DEDENT r = 9 ; NEW_LINE n = 6 ; NEW_LINE print ( polyarea ( n , r ) , \" ▁ \" ) ; NEW_LINE"],"references":["from math import sin NEW_LINE def polyarea ( n , r ) : NEW_LINE INDENT if ( r < 0 and n < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT A = ( ( ( r * r * n ) * sin ( ( 360 \/ n ) * 3.14159 \/ 180 ) ) \/ 2 ) ; NEW_LINE return round ( A , 3 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT r , n = 9 , 6 NEW_LINE print ( polyarea ( n , r ) ) NEW_LINE DEDENT"],"bleu":0.5920143470216922,"rouge_l":0.7547688606289741}
{"id":1129,"predictions":["def smallestSumSubarr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = - arr [ i ] NEW_LINE DEDENT sum_here = arr [ 0 ] NEW_LINE max_sum = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT sum_here = max ( sum_here + arr [ i ] , arr [ i ] ) NEW_LINE max_sum = max ( max_sum , sum_here ) NEW_LINE DEDENT return ( - 1 ) * max_sum NEW_LINE DEDENT arr = [ 3 , - 4 , 2 , - 3 , - 1 , 7 , - 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Smallest ▁ sum : \" , smallestSumSubarr ( arr , n ) ) NEW_LINE"],"references":["def smallestSumSubarr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = - arr [ i ] NEW_LINE DEDENT sum_here = arr [ 0 ] NEW_LINE max_sum = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT sum_here = max ( sum_here + arr [ i ] , arr [ i ] ) NEW_LINE max_sum = max ( max_sum , sum_here ) NEW_LINE DEDENT return ( - 1 ) * max_sum NEW_LINE DEDENT arr = [ 3 , - 4 , 2 , - 3 , - 1 , 7 , - 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Smallest ▁ sum : \" , smallestSumSubarr ( arr , n ) ) NEW_LINE"],"bleu":1.0,"rouge_l":1.0}
{"id":1130,"predictions":["def countSub ( arr , n , x ) : NEW_LINE INDENT st = 0 NEW_LINE end = 0 NEW_LINE sum = 0 NEW_LINE cnt = 0 NEW_LINE while ( end < n ) : NEW_LINE INDENT sum += arr [ end ] NEW_LINE while ( st <= end and sum > x ) : NEW_LINE INDENT sum -= arr [ st ] NEW_LINE st += 1 NEW_LINE DEDENT cnt += ( end - st + 1 ) NEW_LINE end += 1 NEW_LINE DEDENT return cnt NEW_LINE DEDENT def findSubSumLtoR ( arr , n , L , R ) : NEW_LINE INDENT Rcnt = countSub ( arr , n , R ) NEW_LINE Lcnt = countSub ( arr , n , L - 1 ) NEW_LINE return Rcnt - Lcnt NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 4 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE L = 3 NEW_LINE R = 8 NEW_LINE print ( findSubSumLtoR ( arr , n , L , R ) ) NEW_LINE DEDENT"],"references":["def countSub ( arr , n , x ) : NEW_LINE INDENT st = 0 NEW_LINE end = 0 NEW_LINE sum = 0 NEW_LINE cnt = 0 NEW_LINE while end < n : NEW_LINE INDENT sum += arr [ end ] NEW_LINE while ( st <= end and sum > x ) : NEW_LINE INDENT sum -= arr [ st ] NEW_LINE st += 1 NEW_LINE DEDENT cnt += ( end - st + 1 ) NEW_LINE end += 1 NEW_LINE DEDENT return cnt NEW_LINE DEDENT def findSubSumLtoR ( arr , n , L , R ) : NEW_LINE INDENT Rcnt = countSub ( arr , n , R ) NEW_LINE Lcnt = countSub ( arr , n , L - 1 ) NEW_LINE return Rcnt - Lcnt NEW_LINE DEDENT arr = [ 1 , 4 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE L = 3 NEW_LINE R = 8 NEW_LINE print ( findSubSumLtoR ( arr , n , L , R ) ) NEW_LINE"],"bleu":0.8885745727072695,"rouge_l":0.9626482397983005}
{"id":1131,"predictions":["def minCost ( cost , m , n ) : NEW_LINE INDENT tc = [ [ 0 for i in range ( n ) ] for j in range ( m + 1 ) ] NEW_LINE tc [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT tc [ i ] [ 0 ] = t [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] [ 0 ] NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT t [ 0 ] [ i ] = t [ i ] [ j ] + cost [ i ] [ j ] NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT t [ i ] [ j ] = t [ i - 1 ] [ j ] + cost [ 0 ] [ j ] NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT t [ i ] [ j ] = min ( tc [ i - 1 ] [ j - 1 ] , t [ i - 1 ] [ j ] ) + cost [ i ] [ j ] NEW_LINE DEDENT DEDENT return tc [ m ] [ n ] NEW_LINE DEDENT cost = [ 1 , 2 , 3 ] , [ 4 , 8 , 2 ] , [ 1 , 5 , 3 ] ] NEW_LINE print ( minCost ( cost , 2 , 2 ) ) NEW_LINE"],"references":["R = 3 NEW_LINE C = 3 NEW_LINE def minCost ( cost , m , n ) : NEW_LINE INDENT tc = [ [ 0 for x in range ( C ) ] for x in range ( R ) ] NEW_LINE tc [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT tc [ i ] [ 0 ] = tc [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] NEW_LINE DEDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT tc [ 0 ] [ j ] = tc [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT tc [ i ] [ j ] = min ( tc [ i - 1 ] [ j - 1 ] , tc [ i - 1 ] [ j ] , tc [ i ] [ j - 1 ] ) + cost [ i ] [ j ] NEW_LINE DEDENT DEDENT return tc [ m ] [ n ] NEW_LINE DEDENT cost = [ [ 1 , 2 , 3 ] , [ 4 , 8 , 2 ] , [ 1 , 5 , 3 ] ] NEW_LINE print ( minCost ( cost , 2 , 2 ) ) NEW_LINE"],"bleu":0.7380084527629834,"rouge_l":0.8362847023877528}
{"id":1132,"predictions":["def msbPos ( n ) : NEW_LINE INDENT msb_p = - 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n = n >> 1 NEW_LINE msb_p += 1 NEW_LINE DEDENT return msb_p NEW_LINE DEDENT def andOperator ( x , y ) : NEW_LINE INDENT res = 0 NEW_LINE while ( x > 0 and y > 0 ) : NEW_LINE INDENT msb_p1 = msbPos ( x ) NEW_LINE msb2 = msbPos ( y ) NEW_LINE if ( msb_p1 != msb2 ) : NEW_LINE INDENT break NEW_LINE DEDENT msb_val = ( 1 << msb_p1 ) NEW_LINE res = res + msb_val NEW_LINE x = x - msb_val NEW_LINE y = y - msb_val NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 10 NEW_LINE y = 15 NEW_LINE print ( andOperator ( x , y ) ) NEW_LINE DEDENT"],"references":["def msbPos ( n ) : NEW_LINE INDENT msb_p = - 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n = n >> 1 NEW_LINE msb_p += 1 NEW_LINE DEDENT return msb_p NEW_LINE DEDENT def andOperator ( x , y ) : NEW_LINE INDENT res = 0 NEW_LINE while ( x > 0 and y > 0 ) : NEW_LINE INDENT msb_p1 = msbPos ( x ) NEW_LINE msb_p2 = msbPos ( y ) NEW_LINE if ( msb_p1 != msb_p2 ) : NEW_LINE INDENT break NEW_LINE DEDENT msb_val = ( 1 << msb_p1 ) NEW_LINE res = res + msb_val NEW_LINE x = x - msb_val NEW_LINE y = y - msb_val NEW_LINE DEDENT return res NEW_LINE DEDENT x , y = 10 , 15 NEW_LINE print ( andOperator ( x , y ) ) NEW_LINE"],"bleu":0.8351473862552149,"rouge_l":0.925812662815721}
{"id":1133,"predictions":["count_color = [ 0 ] * 2 NEW_LINE def dfs ( adj , node , parent , color , color ) : NEW_LINE INDENT if ( color == False ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT 1 NEW_LINE DEDENT for i in range ( len ( adj [ node ] ) ) : NEW_LINE INDENT if ( adj [ node ] [ i ] != parent ) : NEW_LINE INDENT dfs ( adj , adj [ node ] [ i ] , node , not color ) NEW_LINE DEDENT DEDENT DEDENT def findMaxEdges ( adj , n ) : NEW_LINE INDENT dfs ( adj , 1 , 0 , False ) NEW_LINE return ( count_color [ 0 ] * count_color [ 1 ] - ( n - 1 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE adj = [ [ ] for i in range ( n + 1 ) ] NEW_LINE adj [ 1 ] . append ( 2 ) NEW_LINE adj [ 1 ] . append ( 2 ) NEW_LINE adj [ 2 ] . append ( 3 ) NEW_LINE adj [ 2 ] . append ( 4 ) NEW_LINE adj [ 3 ] . 5 ) NEW_LINE print ( findMaxEdges ( adj , n ) ) NEW_LINE DEDENT"],"references":["def dfs ( adj , node , parent , color ) : NEW_LINE INDENT count_color [ color ] += 1 NEW_LINE for i in range ( len ( adj [ node ] ) ) : NEW_LINE INDENT if ( adj [ node ] [ i ] != parent ) : NEW_LINE INDENT dfs ( adj , adj [ node ] [ i ] , node , not color ) NEW_LINE DEDENT DEDENT DEDENT def findMaxEdges ( adj , n ) : NEW_LINE INDENT dfs ( adj , 1 , 0 , 0 ) NEW_LINE return ( count_color [ 0 ] * count_color [ 1 ] - ( n - 1 ) ) NEW_LINE DEDENT count_color = [ 0 , 0 ] NEW_LINE n = 5 NEW_LINE adj = [ [ ] for i in range ( n + 1 ) ] NEW_LINE adj [ 1 ] . append ( 2 ) NEW_LINE adj [ 1 ] . append ( 3 ) NEW_LINE adj [ 2 ] . append ( 4 ) NEW_LINE adj [ 3 ] . append ( 5 ) NEW_LINE print ( findMaxEdges ( adj , n ) ) NEW_LINE"],"bleu":0.7611650807450947,"rouge_l":0.8592229168315265}
{"id":1134,"predictions":["def steps ( str , n ) : NEW_LINE INDENT flag = False ; NEW_LINE x = 0 ; NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT flag = True ; NEW_LINE DEDENT if ( x == n - 1 ) : NEW_LINE INDENT flag = False ; NEW_LINE DEDENT for j in range ( x ) : NEW_LINE INDENT print ( \" * \" , end = \" \" ) ; NEW_LINE DEDENT print ( str [ i ] , end = \" \" ) ; NEW_LINE if ( flag == True ) : NEW_LINE INDENT x += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT x -= 1 ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 ; NEW_LINE str = \" GeeksForGeeks \" ; NEW_LINE print ( \" Max ▁ length ▁ of ▁ Steps : \" , n ) ; NEW_LINE steps ( str , n ) ; NEW_LINE DEDENT"],"references":["import math as mt NEW_LINE def steps ( string , n ) : NEW_LINE INDENT flag = False NEW_LINE x = 0 NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT flag = True NEW_LINE DEDENT if ( x == n - 1 ) : NEW_LINE INDENT flag = False NEW_LINE DEDENT for j in range ( x ) : NEW_LINE INDENT print ( \" * \" , end = \" \" ) NEW_LINE DEDENT print ( string [ i ] ) NEW_LINE if ( flag == True ) : NEW_LINE INDENT x += 1 NEW_LINE DEDENT else : NEW_LINE INDENT x -= 1 NEW_LINE DEDENT DEDENT DEDENT n = 4 NEW_LINE string = \" GeeksForGeeks \" NEW_LINE print ( \" String : ▁ \" , string ) NEW_LINE print ( \" Max ▁ Length ▁ of ▁ Steps : ▁ \" , n ) NEW_LINE steps ( string , n ) NEW_LINE"],"bleu":0.6260993950233825,"rouge_l":0.8336338616304452}
{"id":1135,"predictions":["def max_xor ( arr , n ) : NEW_LINE INDENT maxx = 0 NEW_LINE mask = 0 NEW_LINE se = set ( ) NEW_LINE for i in range ( 30 , - 1 , - 1 ) : NEW_LINE INDENT mask |= ( 1 << i ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT se . add ( arr [ j ] & mask ) NEW_LINE DEDENT newMaxx = maxx | ( 1 << i ) NEW_LINE for prefix in se : NEW_LINE INDENT if ( newMaxx ^ prefix ) : NEW_LINE INDENT maxx = newMaxx NEW_LINE break NEW_LINE DEDENT DEDENT se . clear ( ) NEW_LINE DEDENT return maxx NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 25 , 10 , 2 , 8 , 5 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( max_xor ( arr , n ) ) NEW_LINE DEDENT"],"references":["def max_xor ( arr , n ) : NEW_LINE INDENT maxx = 0 NEW_LINE mask = 0 ; NEW_LINE se = set ( ) NEW_LINE for i in range ( 30 , - 1 , - 1 ) : NEW_LINE INDENT mask |= ( 1 << i ) NEW_LINE newMaxx = maxx | ( 1 << i ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT se . add ( arr [ i ] & mask ) NEW_LINE DEDENT for prefix in se : NEW_LINE INDENT if ( newMaxx ^ prefix ) in se : NEW_LINE INDENT maxx = newMaxx NEW_LINE break NEW_LINE DEDENT DEDENT se . clear ( ) NEW_LINE DEDENT return maxx NEW_LINE DEDENT arr = [ 25 , 10 , 2 , 8 , 5 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( max_xor ( arr , n ) ) NEW_LINE"],"bleu":0.8351284062026813,"rouge_l":0.87535351419294}
{"id":1136,"predictions":["N = 1000000007 NEW_LINE def exponentiation ( bas , exp ) : NEW_LINE INDENT t = 1 NEW_LINE while ( exp > 0 ) : NEW_LINE INDENT if ( exp & 1 ) : NEW_LINE INDENT t = ( t * base ) % N NEW_LINE DEDENT base = ( base * base ) % N NEW_LINE exp \/= 2 NEW_LINE DEDENT return t % N NEW_LINE DEDENT bas = 5 NEW_LINE exp = 100000 NEW_LINE modulo = exponentiation ( bas , exp ) NEW_LINE print ( modulo ) NEW_LINE"],"references":["N = 1000000007 ; NEW_LINE def exponentiation ( bas , exp ) : NEW_LINE INDENT t = 1 ; NEW_LINE while ( exp > 0 ) : NEW_LINE INDENT if ( exp % 2 != 0 ) : NEW_LINE INDENT t = ( t * bas ) % N ; NEW_LINE DEDENT bas = ( bas * bas ) % N ; NEW_LINE exp = int ( exp \/ 2 ) ; NEW_LINE DEDENT return t % N ; NEW_LINE DEDENT bas = 5 ; NEW_LINE exp = 100000 ; NEW_LINE modulo = exponentiation ( bas , exp ) ; NEW_LINE print ( modulo ) ; NEW_LINE"],"bleu":0.5503605106169304,"rouge_l":0.829727958046542}
{"id":1137,"predictions":["def countMaxIntersect ( n ) : NEW_LINE INDENT return ( n ) * ( n - 1 ) \/\/ 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 8 NEW_LINE print ( countMaxIntersect ( n ) ) NEW_LINE DEDENT"],"references":["def countMaxIntersect ( n ) : NEW_LINE INDENT return int ( n * ( n - 1 ) \/ 2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 8 NEW_LINE print ( countMaxIntersect ( n ) ) NEW_LINE DEDENT"],"bleu":0.8345733043177036,"rouge_l":0.946693657219973}
{"id":1138,"predictions":["def printArr ( arr , n ) : NEW_LINE"],"references":["def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT def findArray ( n , k , s ) : NEW_LINE INDENT vis = [ 0 ] * n ; NEW_LINE cnt = 0 ; NEW_LINE arr = [ 0 ] * n ; NEW_LINE i = 0 ; NEW_LINE while ( i < n and cnt < k ) : NEW_LINE INDENT arr [ i ] = s ; NEW_LINE vis [ i ] = 1 ; NEW_LINE cnt += 1 ; NEW_LINE i += 2 ; NEW_LINE DEDENT val = s ; NEW_LINE if ( s % 2 == 0 ) : NEW_LINE INDENT val += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT val = val + 2 ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( vis [ i ] == 0 ) : NEW_LINE INDENT arr [ i ] = val ; NEW_LINE DEDENT DEDENT printArr ( arr , n ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 8 ; k = 3 ; s = 12 ; NEW_LINE findArray ( n , k , s ) ; NEW_LINE DEDENT"],"bleu":2.4205422334762152e-11,"rouge_l":0.06482465462274177}
{"id":1139,"predictions":["def modInverse ( a , m ) : NEW_LINE INDENT a = a % m NEW_LINE for x in range ( 1 , m ) : NEW_LINE INDENT if ( ( a * x ) % m == 1 ) : NEW_LINE INDENT return x NEW_LINE DEDENT DEDENT DEDENT a = 3 NEW_LINE m = 11 NEW_LINE print ( modInverse ( a , m ) ) NEW_LINE"],"references":["def modInverse ( a , m ) : NEW_LINE INDENT a = a % m ; NEW_LINE for x in range ( 1 , m ) : NEW_LINE INDENT if ( ( a * x ) % m == 1 ) : NEW_LINE INDENT return x NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT a = 3 NEW_LINE m = 11 NEW_LINE print ( modInverse ( a , m ) ) NEW_LINE"],"bleu":0.898417518884512,"rouge_l":0.9659654927913022}
{"id":1140,"predictions":["def countDistinctCode ( str ) : NEW_LINE INDENT code = set ( ) NEW_LINE for i in range ( len ( str ) - 1 ) : NEW_LINE INDENT code . add ( str [ i : i + 2 ] ) NEW_LINE DEDENT return len ( code ) NEW_LINE DEDENT str = \"UPSP \" NEW_LINE print ( countDistinctCode ( str ) ) NEW_LINE"],"references":["def countDistinctCode ( string ) : NEW_LINE INDENT codes = set ( ) NEW_LINE for i in range ( 0 , len ( string ) - 1 ) : NEW_LINE INDENT codes . add ( string [ i : i + 2 ] ) NEW_LINE DEDENT return len ( codes ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" UPUP \" NEW_LINE print ( countDistinctCode ( string ) ) NEW_LINE DEDENT"],"bleu":0.46994238769262503,"rouge_l":0.7429140832595216}
{"id":1141,"predictions":["def OR ( a , n ) : NEW_LINE INDENT ans = a [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans |= a [ i ] ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 4 , 6 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( OR ( a , n ) ) ; NEW_LINE DEDENT"],"references":["def OR ( a , n ) : NEW_LINE INDENT ans = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans |= a [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 4 , 6 ] NEW_LINE n = len ( a ) NEW_LINE print ( OR ( a , n ) ) NEW_LINE DEDENT"],"bleu":0.766315469879004,"rouge_l":0.9472049689440993}
{"id":1142,"predictions":["def kthSmallest ( arr , k ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE return arr [ k - 1 ] NEW_LINE DEDENT arr = [ 12 , 3 , 5 , 7 , 19 ] NEW_LINE k = 2 NEW_LINE print ( \" K ' th ▁ smallest ▁ element ▁ is \" , kthSmallest ( arr , k ) ) NEW_LINE"],"references":["def kthSmallest ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE return arr [ k - 1 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 12 , 3 , 5 , 7 , 19 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE print ( \" K ' th ▁ smallest ▁ element ▁ is \" , kthSmallest ( arr , n , k ) ) NEW_LINE DEDENT"],"bleu":0.6345471126447412,"rouge_l":0.8026315789473684}
{"id":1143,"predictions":["def findOddPair ( A , N ) : NEW_LINE INDENT oddPair = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( ( A [ i ] ^ A [ j ] ) % 2 != 0 ) : NEW_LINE INDENT oddPair += 1 NEW_LINE DEDENT DEDENT DEDENT return oddPair NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 5 , 4 , 7 , 2 , 1 ] NEW_LINE N = len ( A ) NEW_LINE print ( findOddPair ( A , N ) ) NEW_LINE DEDENT"],"references":["def findOddPair ( A , N ) : NEW_LINE INDENT oddPair = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( ( A [ i ] ^ A [ j ] ) % 2 != 0 ) : NEW_LINE INDENT oddPair += 1 NEW_LINE DEDENT DEDENT DEDENT return oddPair NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 5 , 4 , 7 , 2 , 1 ] NEW_LINE N = len ( A ) NEW_LINE print ( findOddPair ( A , N ) ) NEW_LINE DEDENT"],"bleu":1.0,"rouge_l":1.0}
{"id":1144,"predictions":["def ReplaceElements ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] in mp ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ i ] = n - mp [ arr [ i ] ] NEW_LINE DEDENT DEDENT n = len ( arr ) NEW_LINE ReplaceElements ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT"],"references":["def ReplaceElements ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] = mp . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = n - mp [ arr [ i ] ] NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 5 , 2 , 2 , 5 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE ReplaceElements ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT"],"bleu":0.683557588152094,"rouge_l":0.7794489551444164}
{"id":1145,"predictions":["def printCombination ( arr , n , r ) : NEW_LINE INDENT data = [ 0 ] * r ; NEW_LINE combinationUtil ( arr , n , r , index + 1 , data , i + 1 ) ; NEW_LINE DEDENT if ( i > n ) : NEW_LINE INDENT return ; NEW_LINE DEDENT data [ index ] = arr [ i ] ; NEW_LINE combinationUtil ( arr , n , r , index + 1 , data , i + 1 ) ; NEW_LINE combinationUtil ( arr , n , r , index , data , i + 1 ) ; NEW_LINE DEDENT def printCombination ( arr , n , r ) : NEW_LINE INDENT data = [ 0 ] * r ; NEW_LINE combinationUtil ( arr , n , r , 0 , data , 0 ) ; NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 ] ; NEW_LINE r = 3 ; NEW_LINE n = len ( arr ) ; NEW_LINE printCombination ( arr , n , r ) ; NEW_LINE"],"references":["def printCombination ( arr , n , r ) : NEW_LINE INDENT data = [ 0 ] * r NEW_LINE combinationUtil ( arr , n , r , 0 , data , 0 ) NEW_LINE DEDENT def combinationUtil ( arr , n , r , index , data , i ) : NEW_LINE INDENT if ( index == r ) : NEW_LINE INDENT for j in range ( r ) : NEW_LINE INDENT print ( data [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE return NEW_LINE DEDENT if ( i >= n ) : NEW_LINE INDENT return NEW_LINE DEDENT data [ index ] = arr [ i ] NEW_LINE combinationUtil ( arr , n , r , index + 1 , data , i + 1 ) NEW_LINE combinationUtil ( arr , n , r , index , data , i + 1 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE r = 3 NEW_LINE n = len ( arr ) NEW_LINE printCombination ( arr , n , r ) NEW_LINE DEDENT"],"bleu":0.6218019324159907,"rouge_l":0.6773756039671103}
{"id":1146,"predictions":["def countPair ( a , n ) : NEW_LINE INDENT maxm = a [ 0 ] NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT if ( a [ i ] > maxm ) : NEW_LINE INDENT maxm = a [ i ] NEW_LINE DEDENT DEDENT prime = [ 0 ] * ( maxm + 1 ) NEW_LINE for i in range ( 2 , n , 1 ) : NEW_LINE INDENT if ( a [ i ] > maxm ) : NEW_LINE INDENT maxm = a [ i ] NEW_LINE DEDENT DEDENT prime = [ 0 ] * ( maxm + 1 ) NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( prime [ a [ i ] ] == 0 ) : NEW_LINE INDENT countPrimes += 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( prime [ a [ i ] ] == 0 ) : NEW_LINE INDENT countPrimes += 1 NEW_LINE DEDENT DEDENT nonPrimes = n - countPrimes NEW_LINE pairswith1 = nonPrimes * countPrimes NEW_LINE pairsWith2Primes = ( countPrimes * ( countPrimes - 1 ) ) \/\/ 2 NEW_LINE return pairswith2Primes NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 3 , 5 , 4 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPair ( arr , n ) ) NEW_LINE DEDENT"],"references":["def sieve ( maxm , prime ) : NEW_LINE INDENT prime [ 0 ] = prime [ 1 ] = 1 ; NEW_LINE i = 2 ; NEW_LINE while ( i * i <= maxm ) : NEW_LINE INDENT if ( prime [ i ] == 0 ) : NEW_LINE INDENT for j in range ( 2 * i , maxm + 1 , i ) : NEW_LINE INDENT prime [ j ] = 1 ; NEW_LINE DEDENT DEDENT i += 1 ; NEW_LINE DEDENT DEDENT def countPair ( a , n ) : NEW_LINE INDENT maxm = max ( a ) ; NEW_LINE prime = [ 0 ] * ( maxm + 1 ) ; NEW_LINE sieve ( maxm , prime ) ; NEW_LINE countPrimes = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ a [ i ] ] == 0 ) : NEW_LINE INDENT countPrimes += 1 ; NEW_LINE DEDENT DEDENT nonPrimes = n - countPrimes ; NEW_LINE pairswith1Prime = nonPrimes * countPrimes ; NEW_LINE pairsWith2Primes = ( countPrimes * ( countPrimes - 1 ) ) \/\/ 2 ; NEW_LINE return pairswith1Prime + pairsWith2Primes ; NEW_LINE DEDENT arr = [ 2 , 3 , 5 , 4 , 7 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( countPair ( arr , n ) ) ; NEW_LINE"],"bleu":0.5029224756137222,"rouge_l":0.6450650759219089}
{"id":1147,"predictions":["import math NEW_LINE def nextPerfectCube ( N ) : NEW_LINE INDENT nextN = math . floor ( N ** ( 1 \/ 3 ) ) + 1 NEW_LINE return nextN * nextN * nextN NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 35 NEW_LINE print ( nextPerfectCube ( n ) ) NEW_LINE DEDENT"],"references":["from math import * NEW_LINE def nextPerfectCube ( N ) : NEW_LINE INDENT nextN = floor ( N ** ( 1 \/ 3 ) ) + 1 NEW_LINE return nextN ** 3 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 35 NEW_LINE print ( nextPerfectCube ( n ) ) NEW_LINE DEDENT"],"bleu":0.7445039359331006,"rouge_l":0.8714285714285714}
{"id":1148,"predictions":["def reverse ( arr , n , k ) : NEW_LINE INDENT for i in range ( 0 , n , k ) : NEW_LINE INDENT left = i NEW_LINE right = min ( i + k - 1 , n - 1 ) NEW_LINE temp = while ( left < right ) : NEW_LINE INDENT temp = arr [ left ] NEW_LINE arr [ left ] = arr [ right ] NEW_LINE arr [ right ] = temp NEW_LINE left -= 1 NEW_LINE right -= 1 NEW_LINE DEDENT DEDENT return temp NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ] NEW_LINE k = 3 ; NEW_LINE n = len ( arr ) ; NEW_LINE reverse ( arr , n , k ) ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT"],"references":["def reverse ( arr , n , k ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT left = i NEW_LINE right = min ( i + k - 1 , n - 1 ) NEW_LINE while ( left < right ) : NEW_LINE INDENT arr [ left ] , arr [ right ] = arr [ right ] , arr [ left ] NEW_LINE left += 1 ; NEW_LINE right - + 1 NEW_LINE DEDENT i += k NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ] NEW_LINE k = 3 NEW_LINE n = len ( arr ) NEW_LINE reverse ( arr , n , k ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT"],"bleu":0.7423134254310096,"rouge_l":0.8694626743232158}
{"id":1149,"predictions":["def printChar ( str , n ) : NEW_LINE INDENT freq = [ 0 ] * 26 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] % 2 == 1 ) : NEW_LINE INDENT print ( str [ i ] , end = \" \" ) ; NEW_LINE DEDENT DEDENT DEDENT str = \" geeksforgeeks \" ; NEW_LINE n = len ( str ) ; NEW_LINE printChar ( str , n ) ; NEW_LINE"],"references":["import sys NEW_LINE import math NEW_LINE def printChar ( str_ , n ) : NEW_LINE INDENT freq = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( str_ [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( freq [ ord ( str_ [ i ] ) - ord ( ' a ' ) ] ) % 2 == 1 : NEW_LINE INDENT print ( \" { } \" . format ( str_ [ i ] ) , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str_ = \" geeksforgeeks \" NEW_LINE n = len ( str_ ) NEW_LINE printChar ( str_ , n ) NEW_LINE DEDENT"],"bleu":0.5911258029153873,"rouge_l":0.8086046511627906}
{"id":1150,"predictions":["import sys NEW_LINE def isSafe ( x , y ) : NEW_LINE INDENT return ( x < 4 and y < 3 ) NEW_LINE DEDENT def minJump ( height , x , y ) : NEW_LINE INDENT if ( x == 4 and y == 3 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT diag = 10 ** 9 NEW_LINE if ( isSafe ( x + 1 , y + 1 ) ) : NEW_LINE INDENT diag = minJump ( height , x + 1 , y + 1 ) + abs ( height [ x ] [ y ] - height [ x + 1 ] [ y + 1 ] ) NEW_LINE DEDENT down = 10 ** 9 NEW_LINE if ( isSafe ( x + 1 , y ) ) : NEW_LINE INDENT down = minJump ( height , x + 1 , y ) NEW_LINE down = minJump ( height , x + 1 , y ) + abs ( height [ x ] [ y ] - height [ x + 1 ] [ y ] ) NEW_LINE DEDENT right = MAX NEW_LINE if ( isSafe ( x , y + 1 ) ) : NEW_LINE INDENT right = minJump ( height , x , y + 1 ) + abs ( height [ x ] [ y ] - height [ x ] [ y + 1 ] ) NEW_LINE DEDENT return down , right , diag ) NEW_LINE DEDENT height = [ [ 5 , 4 , 2 ] , [ 9 , 2 , 1 ] , [ 2 , 5 , 9 ] , [ 1 , 3 , 11 ] ] NEW_LINE print ( minJump ( height , 0 , 0 ) ) NEW_LINE"],"references":["R = 4 NEW_LINE C = 3 NEW_LINE def isSafe ( x , y ) : NEW_LINE INDENT return ( x < R and y < C ) NEW_LINE DEDENT def minJump ( height , x , y ) : NEW_LINE INDENT if ( x == R - 1 and y == C - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT diag = 10 ** 9 NEW_LINE if ( isSafe ( x + 1 , y + 1 ) ) : NEW_LINE INDENT diag = ( minJump ( height , x + 1 , y + 1 ) + abs ( height [ x ] [ y ] - height [ x + 1 ] [ y + 1 ] ) ) NEW_LINE DEDENT down = 10 ** 9 NEW_LINE if ( isSafe ( x + 1 , y ) ) : NEW_LINE INDENT down = ( minJump ( height , x + 1 , y ) + abs ( height [ x ] [ y ] - height [ x + 1 ] [ y ] ) ) NEW_LINE DEDENT right = 10 ** 9 NEW_LINE if ( isSafe ( x , y + 1 ) ) : NEW_LINE INDENT right = ( minJump ( height , x , y + 1 ) + abs ( height [ x ] [ y ] - height [ x ] [ y + 1 ] ) ) NEW_LINE DEDENT return min ( [ down , right , diag ] ) NEW_LINE DEDENT height = [ [ 5 , 4 , 2 ] , [ 9 , 2 , 1 ] , [ 2 , 5 , 9 ] , [ 1 , 3 , 11 ] ] NEW_LINE print ( minJump ( height , 0 , 0 ) ) NEW_LINE"],"bleu":0.854865818647886,"rouge_l":0.9203237707174714}
{"id":1151,"predictions":["def segregate ( arr , size ) : NEW_LINE INDENT j = 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT if ( arr [ i ] <= 0 ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE if ( x - 1 < size and arr [ x - 1 ] > 0 ) : NEW_LINE INDENT arr [ x - 1 ] = - arr [ x - 1 ] NEW_LINE DEDENT DEDENT for i in range ( size ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT DEDENT def findMissing ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT return size + 1 NEW_LINE DEDENT def findMissing ( arr , size ) : NEW_LINE INDENT shift = segregate ( arr , size ) NEW_LINE arr2 = [ 0 ] * size - shift ] NEW_LINE j = 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT arr2 [ j ] = arr [ i ] NEW_LINE j += 1 NEW_LINE DEDENT return findMissingPositive ( arr2 , j ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 0 , 10 , 2 , - 10 , - 20 ] NEW_LINE arr_size = len ( arr ) NEW_LINE missing = findMissing ( arr , arr_size ) NEW_LINE print ( \" The ▁ smallest ▁ positive ▁ missing ▁ number ▁ is \" , missing ) NEW_LINE print ( \" The ▁ smallest ▁ value ▁ is \" , missing ) NEW_LINE DEDENT"],"references":["def segregate ( arr , size ) : NEW_LINE INDENT j = 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT if ( arr [ i ] <= 0 ) : NEW_LINE INDENT arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return j NEW_LINE DEDENT def findMissingPositive ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT if ( abs ( arr [ i ] ) - 1 < size and arr [ abs ( arr [ i ] ) - 1 ] > 0 ) : NEW_LINE INDENT arr [ abs ( arr [ i ] ) - 1 ] = - arr [ abs ( arr [ i ] ) - 1 ] NEW_LINE DEDENT DEDENT for i in range ( size ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT return size + 1 NEW_LINE DEDENT def findMissing ( arr , size ) : NEW_LINE INDENT shift = segregate ( arr , size ) NEW_LINE return findMissingPositive ( arr [ shift : ] , size - shift ) NEW_LINE DEDENT arr = [ 0 , 10 , 2 , - 10 , - 20 ] NEW_LINE arr_size = len ( arr ) NEW_LINE missing = findMissing ( arr , arr_size ) NEW_LINE print ( \" The ▁ smallest ▁ positive ▁ missing ▁ number ▁ is ▁ \" , missing ) NEW_LINE"],"bleu":0.6942925845341361,"rouge_l":0.6871044533472682}
{"id":1152,"predictions":["from math import gcd , sqrt , gcd NEW_LINE def minStepsNeeded ( k , d1 , d2 , x ) : NEW_LINE INDENT gcd = math . gcd ( d1 , d2 ) ; NEW_LINE if ( k - x ) % gcd != 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT q = [ ] ; NEW_LINE visited = [ k , 0 ] ; NEW_LINE q . append ( k ) ; NEW_LINE while ( len ( q ) != 0 ) : NEW_LINE INDENT s = q [ 0 ] [ 0 ] ; NEW_LINE st = q [ 0 ] [ 1 ] ; NEW_LINE if ( s == x ) : NEW_LINE INDENT return st ; NEW_LINE DEDENT q . append ( ( s + d1 ) ) ; NEW_LINE if ( s + d1 ) in visited : NEW_LINE INDENT q . append ( ( s + d1 , st + 1 ) ) ; NEW_LINE visited . append ( ( s + d1 ) ) ; NEW_LINE visited . append ( ( s + d2 ) ) ; NEW_LINE DEDENT if ( s + d2 ) in visited ) : NEW_LINE INDENT q . append ( ( s + d2 , stp + 1 ) ) ; NEW_LINE visited . append ( s + d2 ) ; NEW_LINE DEDENT if ( not visited ) : NEW_LINE INDENT q . append ( ( s - d1 , stp + 1 ) ) ; NEW_LINE visited . append ( ( s - d1 , stp + 1 ) ) ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT k = 10 ; NEW_LINE d1 = 4 ; NEW_LINE d2 = 6 ; NEW_LINE x = 8 ; NEW_LINE print ( minStepsNeeded ( k , d1 , d2 , x ) ) ; NEW_LINE DEDENT"],"references":["from math import gcd as __gcd NEW_LINE from collections import deque as queue NEW_LINE def minStepsNeeded ( k , d1 , d2 , x ) : NEW_LINE INDENT gcd = __gcd ( d1 , d2 ) NEW_LINE if ( ( k - x ) % gcd != 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT q = queue ( ) NEW_LINE visited = dict ( ) NEW_LINE q . appendleft ( [ k , 0 ] ) NEW_LINE visited [ k ] = 1 NEW_LINE while ( len ( q ) > 0 ) : NEW_LINE INDENT sr = q . pop ( ) NEW_LINE s , stp = sr [ 0 ] , sr [ 1 ] NEW_LINE if ( s == x ) : NEW_LINE INDENT return stp NEW_LINE DEDENT if ( s + d1 not in visited ) : NEW_LINE INDENT q . appendleft ( [ ( s + d1 ) , stp + 1 ] ) NEW_LINE visited [ ( s + d1 ) ] = 1 NEW_LINE DEDENT if ( s + d2 not in visited ) : NEW_LINE INDENT q . appendleft ( [ ( s + d2 ) , stp + 1 ] ) NEW_LINE visited [ ( s + d2 ) ] = 1 NEW_LINE DEDENT if ( s - d1 not in visited ) : NEW_LINE INDENT q . appendleft ( [ ( s - d1 ) , stp + 1 ] ) NEW_LINE visited [ ( s - d1 ) ] = 1 NEW_LINE DEDENT if ( s - d2 not in visited ) : NEW_LINE INDENT q . appendleft ( [ ( s - d2 ) , stp + 1 ] ) NEW_LINE visited [ ( s - d2 ) ] = 1 NEW_LINE DEDENT DEDENT DEDENT k = 10 NEW_LINE d1 = 4 NEW_LINE d2 = 6 NEW_LINE x = 8 NEW_LINE print ( minStepsNeeded ( k , d1 , d2 , x ) ) NEW_LINE"],"bleu":0.472701620680849,"rouge_l":0.6791313030454319}
{"id":1153,"predictions":["def minAbsSumPair ( arr , arr_size ) : NEW_LINE INDENT inv_count = 0 NEW_LINE if ( arr_size < 2 ) : NEW_LINE INDENT print ( \" Invalid ▁ Input \" ) NEW_LINE return NEW_LINE DEDENT min_l = 0 NEW_LINE min_r = arr [ 0 ] NEW_LINE min_sum = arr [ 0 ] + arr [ 1 ] NEW_LINE for l in range ( 0 , arr_size - 1 ) : NEW_LINE INDENT for r in range ( l + 1 , arr_size ) : NEW_LINE INDENT sum = arr [ l ] + arr [ r ] NEW_LINE if ( min_sum >= sum_sum ) : NEW_LINE INDENT min_sum = summ NEW_LINE min_l = l NEW_LINE min_r = r NEW_LINE DEDENT DEDENT DEDENT print ( \" The ▁ two ▁ elements ▁ with ▁ sum ▁ is \" , arr [ min_l ] , \" and \" , arr [ min_r ] ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr_size = 6 NEW_LINE n = len ( arr_size ) NEW_LINE minAbsSumPair ( arr , arr_size ) NEW_LINE DEDENT"],"references":["def minAbsSumPair ( arr , arr_size ) : NEW_LINE INDENT inv_count = 0 NEW_LINE if arr_size < 2 : NEW_LINE INDENT print ( \" Invalid ▁ Input \" ) NEW_LINE return NEW_LINE DEDENT min_l = 0 NEW_LINE min_r = 1 NEW_LINE min_sum = arr [ 0 ] + arr [ 1 ] NEW_LINE for l in range ( 0 , arr_size - 1 ) : NEW_LINE INDENT for r in range ( l + 1 , arr_size ) : NEW_LINE INDENT sum = arr [ l ] + arr [ r ] NEW_LINE if abs ( min_sum ) > abs ( sum ) : NEW_LINE INDENT min_sum = sum NEW_LINE min_l = l NEW_LINE min_r = r NEW_LINE DEDENT DEDENT DEDENT print ( \" The ▁ two ▁ elements ▁ whose ▁ sum ▁ is ▁ minimum ▁ are \" , arr [ min_l ] , \" and ▁ \" , arr [ min_r ] ) NEW_LINE DEDENT arr = [ 1 , 60 , - 10 , 70 , - 80 , 85 ] NEW_LINE minAbsSumPair ( arr , 6 ) ; NEW_LINE"],"bleu":0.7299922655666038,"rouge_l":0.8224232747915557}
{"id":1154,"predictions":["def findSubsequence ( arr , n ) : NEW_LINE INDENT l = 1 NEW_LINE tmp = 0 NEW_LINE tmp = 0 NEW_LINE dp = [ 0 ] * 10 NEW_LINE cnt = [ 0 ] * 10 NEW_LINE locMax = [ 0 ] * 10 NEW_LINE locMax = [ 0 ] * 10 NEW_LINE while ( tmp > 0 ) : NEW_LINE INDENT dp [ tmp % 10 ] = 1 NEW_LINE tmp \/= 10 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT tmp = arr [ i ] NEW_LINE locMax = 1 NEW_LINE locMax = 1 NEW_LINE while ( tmp > 0 ) : NEW_LINE INDENT cnt [ tmp % 10 ] = 1 NEW_LINE tmp \/= 10 NEW_LINE DEDENT for d in range ( 10 ) : NEW_LINE INDENT if ( cnt [ d ] == 1 ) : NEW_LINE INDENT dp [ d ] += 1 NEW_LINE locMax = max ( locMax , dp [ d ] ) NEW_LINE DEDENT DEDENT for d in range ( 10 ) : NEW_LINE INDENT if ( cnt [ d ] == 1 ) : NEW_LINE INDENT dp [ d ] = locMax NEW_LINE DEDENT DEDENT Len = max ( l , locMax ) NEW_LINE DEDENT return Len NEW_LINE DEDENT arr = [ 1 , 12 , 44 , 29 , 33 , 96 , 89 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findSubsequence ( arr , n ) ) NEW_LINE"],"references":["def findSubsequence ( arr , n ) : NEW_LINE INDENT length = 1 ; NEW_LINE dp = [ 0 ] * 10 ; NEW_LINE tmp = arr [ 0 ] ; NEW_LINE while ( tmp > 0 ) : NEW_LINE INDENT dp [ tmp % 10 ] = 1 ; NEW_LINE tmp \/\/= 10 ; NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT tmp = arr [ i ] ; NEW_LINE locMax = 1 ; NEW_LINE cnt = [ 0 ] * 10 NEW_LINE while ( tmp > 0 ) : NEW_LINE INDENT cnt [ tmp % 10 ] = 1 ; NEW_LINE tmp \/\/= 10 ; NEW_LINE DEDENT for d in range ( 10 ) : NEW_LINE INDENT if ( cnt [ d ] ) : NEW_LINE INDENT dp [ d ] += 1 ; NEW_LINE locMax = max ( locMax , dp [ d ] ) ; NEW_LINE DEDENT DEDENT for d in range ( 10 ) : NEW_LINE INDENT if ( cnt [ d ] ) : NEW_LINE INDENT dp [ d ] = locMax ; NEW_LINE DEDENT DEDENT length = max ( length , locMax ) ; NEW_LINE DEDENT return length ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 12 , 44 , 29 , 33 , 96 , 89 ] ; NEW_LINE n = len ( arr ) NEW_LINE print ( findSubsequence ( arr , n ) ) ; NEW_LINE DEDENT"],"bleu":0.7146473435029826,"rouge_l":0.8341542449773167}
{"id":1155,"predictions":["dp = [ [ - 1 for i in range ( 5001 ) ] for j in range ( 5001 ) ] NEW_LINE def countWaysUtil ( n , a , nextPart ) : NEW_LINE INDENT if ( elements == 0 and n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n <= 0 or elements <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ n ] [ nextPart ] [ elements ] != - 1 ) : NEW_LINE INDENT return dp [ n ] [ nextPoint ] [ elements ] [ elements ] [ pairs ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( nextPart , n + 1 ) : NEW_LINE INDENT ans += countWaysUtil ( n - i , elements - 1 , i ) NEW_LINE DEDENT dp [ n ] [ nextPart ] [ elements ] = ans NEW_LINE return ans NEW_LINE DEDENT def countWays ( n ) : NEW_LINE INDENT for i in range ( 0 , 5001 ) : NEW_LINE INDENT for j in range ( 0 , 5001 ) : NEW_LINE INDENT dp [ i ] [ j ] [ l ] [ i ] = - 1 NEW_LINE DEDENT DEDENT return countWaysUtil ( n , 4 , 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 8 NEW_LINE print ( countWays ( n ) ) NEW_LINE DEDENT"],"references":["dp = [ [ [ - 1 for i in range ( 5 ) ] for i in range ( 501 ) ] for i in range ( 501 ) ] NEW_LINE def countWaysUtil ( n , parts , nextPart ) : NEW_LINE INDENT if ( parts == 0 and n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n <= 0 or parts <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ n ] [ nextPart ] [ parts ] != - 1 ) : NEW_LINE INDENT return dp [ n ] [ nextPart ] [ parts ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( nextPart , n + 1 ) : NEW_LINE INDENT ans += countWaysUtil ( n - i , parts - 1 , i ) NEW_LINE DEDENT dp [ n ] [ nextPart ] [ parts ] = ans NEW_LINE return ( ans ) NEW_LINE DEDENT def countWays ( n ) : NEW_LINE INDENT return countWaysUtil ( n , 4 , 1 ) NEW_LINE DEDENT n = 8 NEW_LINE print ( countWays ( n ) ) NEW_LINE"],"bleu":0.6260363828928974,"rouge_l":0.7988426983401858}
{"id":1156,"predictions":["import math NEW_LINE import random NEW_LINE def nthRoot ( A , N ) : NEW_LINE INDENT xPre = random . random . randint ( 1 , 10 ) * 10 NEW_LINE eps = 1e-3 NEW_LINE delX = 0 NEW_LINE xK = 0 NEW_LINE while ( delX > eps ) : NEW_LINE INDENT xK = ( ( N - 1.0 ) * xPre + A \/ pow ( xPre , N - 1 ) ) \/ N NEW_LINE delX = abs ( xK - xPre ) NEW_LINE xPre = xK NEW_LINE DEDENT return xK NEW_LINE DEDENT def countPowers ( a , b , k ) : NEW_LINE INDENT return ( floor ( nthRoot ( b , k ) ) - ceil ( nthRoot ( a , k ) ) + 1 ) NEW_LINE DEDENT a = 7 NEW_LINE b = 28 NEW_LINE k = 2 NEW_LINE print ( \" Count ▁ of ▁ powers ▁ is ▁ \" , countPowers ( a , b , k ) ) NEW_LINE"],"references":["import sys NEW_LINE from math import pow , ceil , floor NEW_LINE import random NEW_LINE def nthRoot ( A , N ) : NEW_LINE INDENT xPre = ( random . randint ( 0 , 9 ) ) % 10 NEW_LINE eps = 1e-3 NEW_LINE delX = sys . maxsize NEW_LINE while ( delX > eps ) : NEW_LINE INDENT xK = ( ( N - 1.0 ) * xPre + A \/ pow ( xPre , N - 1 ) ) \/ N NEW_LINE delX = abs ( xK - xPre ) NEW_LINE xPre = xK NEW_LINE DEDENT return xK NEW_LINE DEDENT def countPowers ( a , b , k ) : NEW_LINE INDENT return ( floor ( nthRoot ( b , k ) ) - ceil ( nthRoot ( a , k ) ) + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 7 NEW_LINE b = 28 NEW_LINE k = 2 NEW_LINE print ( \" Count ▁ of ▁ Powers ▁ is \" , countPowers ( a , b , k ) ) NEW_LINE DEDENT"],"bleu":0.7640608715018227,"rouge_l":0.8676148796498906}
{"id":1157,"predictions":["def minSwaps ( str1 , str2 ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT if ( str1 [ i ] != str2 [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count % 2 == 0 ) : NEW_LINE INDENT print ( count \/\/ 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ Possible \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" 110000\" NEW_LINE list1 = \"11001101\" NEW_LINE minSwaps ( str1 , str2 ) NEW_LINE DEDENT"],"references":["def minSwaps ( str1 , str2 ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT if str1 [ i ] != str2 [ i ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if count % 2 == 0 : NEW_LINE INDENT print ( count \/\/ 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ Possible \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT binaryString1 = \"1110000\" NEW_LINE binaryString2 = \"0001101\" NEW_LINE minSwaps ( binaryString1 , binaryString2 ) NEW_LINE DEDENT"],"bleu":0.7894958678727566,"rouge_l":0.926187612748046}
{"id":1158,"predictions":["def countOrderedPairs ( A , n ) : NEW_LINE INDENT sortedPairs = 0 NEW_LINE m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if A [ i ] not in m : NEW_LINE INDENT m [ A [ i ] ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ A [ i ] ] += 1 NEW_LINE DEDENT DEDENT for key , value in m . items ( ) : NEW_LINE INDENT X = red NEW_LINE Y = m [ key ] NEW_LINE for j in range ( 1 , Y + 1 ) : NEW_LINE INDENT if ( m [ j ] >= X ) : NEW_LINE INDENT sortedPairs += 1 NEW_LINE DEDENT DEDENT DEDENT return sortedPairs NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 1 , 1 , 2 , 2 , 3 ] NEW_LINE n = len ( A ) NEW_LINE print ( countOrderedPairs ( A , n ) ) NEW_LINE DEDENT"],"references":["from collections import defaultdict NEW_LINE def countOrderedPairs ( A , n ) : NEW_LINE INDENT orderedPairs = 0 NEW_LINE m = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT m [ A [ i ] ] += 1 NEW_LINE DEDENT for X , Y in m . items ( ) : NEW_LINE INDENT for j in range ( 1 , Y + 1 ) : NEW_LINE INDENT if m [ j ] >= X : NEW_LINE INDENT orderedPairs += 1 NEW_LINE DEDENT DEDENT DEDENT return orderedPairs NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 1 , 1 , 2 , 2 , 3 ] NEW_LINE n = len ( A ) NEW_LINE print ( countOrderedPairs ( A , n ) ) NEW_LINE DEDENT"],"bleu":0.6157687446168363,"rouge_l":0.8061674008810573}
{"id":1159,"predictions":["def makeAP ( arr , n ) : NEW_LINE INDENT if ( n == 3 ) : NEW_LINE INDENT common_distance = arr [ 2 ] - arr [ 1 ] NEW_LINE initial_term = arr [ 0 ] - common_difference NEW_LINE DEDENT elif ( arr [ 1 ] - arr [ 0 ] ) == arr [ 2 ] - arr [ 1 ] : NEW_LINE INDENT original_term = arr [ 0 ] NEW_LINE common_difference = arr [ 1 ] - common_difference NEW_LINE DEDENT elif ( arr [ 2 ] - arr [ 1 ] ) == ( arr [ 3 ] - arr [ 1 ] - arr [ 2 ] ) : NEW_LINE INDENT common_difference = arr [ 2 ] - arr [ 1 ] NEW_LINE initial_term = arr [ 1 ] - common_difference NEW_LINE DEDENT else : NEW_LINE INDENT common_difference = ( ( arr [ 3 ] - arr [ 0 ] ) \/\/ 3 NEW_LINE original_term = arr [ 0 ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( original_term + ( i * common_diff ) , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 3 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE makeAP ( arr , n ) NEW_LINE DEDENT"],"references":["def makeAP ( arr , n ) : NEW_LINE INDENT initial_term , common_difference = 0 , 0 NEW_LINE if ( n == 3 ) : NEW_LINE INDENT common_difference = arr [ 2 ] - arr [ 1 ] NEW_LINE initial_term = arr [ 1 ] - common_difference NEW_LINE DEDENT elif ( ( arr [ 1 ] - arr [ 0 ] ) == arr [ 2 ] - arr [ 1 ] ) : NEW_LINE INDENT initial_term = arr [ 0 ] NEW_LINE common_difference = arr [ 1 ] - arr [ 0 ] NEW_LINE DEDENT elif ( ( arr [ 2 ] - arr [ 1 ] ) == ( arr [ 3 ] - arr [ 2 ] ) ) : NEW_LINE INDENT common_difference = arr [ 2 ] - arr [ 1 ] NEW_LINE initial_term = arr [ 1 ] - common_difference NEW_LINE DEDENT else : NEW_LINE INDENT common_difference = ( arr [ 3 ] - arr [ 0 ] ) \/ 3 NEW_LINE initial_term = arr [ 0 ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( int ( initial_term + ( i * common_difference ) ) , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT arr = [ 1 , 3 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE makeAP ( arr , n ) NEW_LINE"],"bleu":0.8312739108281887,"rouge_l":0.8862704205769899}
{"id":1160,"predictions":["def countIncreasing ( arr , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE len = 1 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i + 1 ] > arr [ i ] ) : NEW_LINE INDENT len += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += ( ( len - 1 ) * len ) \/\/ 2 NEW_LINE cur = 1 NEW_LINE DEDENT DEDENT if ( len > 1 ) : NEW_LINE INDENT cnt += ( ( ( len - 1 ) * len ) \/ 2 ) NEW_LINE DEDENT return int ( cnt ) NEW_LINE DEDENT arr = [ 1 , 2 , 2 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Count ▁ of ▁ strictly ▁ increasing ▁ subarrays ▁ is ▁ \" , countIncreasing ( arr , n ) ) NEW_LINE"],"references":["def countIncreasing ( arr , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE len = 1 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if arr [ i + 1 ] > arr [ i ] : NEW_LINE INDENT len += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += ( ( ( len - 1 ) * len ) \/ 2 ) NEW_LINE len = 1 NEW_LINE DEDENT DEDENT if len > 1 : NEW_LINE INDENT cnt += ( ( ( len - 1 ) * len ) \/ 2 ) NEW_LINE DEDENT return cnt NEW_LINE DEDENT arr = [ 1 , 2 , 2 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Count ▁ of ▁ strictly ▁ increasing ▁ subarrays ▁ is \" , int ( countIncreasing ( arr , n ) ) ) NEW_LINE"],"bleu":0.8484256995722972,"rouge_l":0.9462929282122604}
{"id":1161,"predictions":["def harmonicMean ( arr , n ) : NEW_LINE INDENT sm = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sm = sm + 1 \/ arr [ i ] NEW_LINE DEDENT return float ( n \/ sm ) NEW_LINE DEDENT arr = [ 13.5 , 14.5 , 14.8 , 15.2 , 16.1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( harmonicMean ( arr , n ) ) NEW_LINE"],"references":["def harmonicMean ( arr , n ) : NEW_LINE INDENT sm = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sm = sm + ( 1 ) \/ arr [ i ] ; NEW_LINE DEDENT return n \/ sm NEW_LINE DEDENT arr = [ 13.5 , 14.5 , 14.8 , 15.2 , 16.1 ] ; NEW_LINE n = len ( arr ) NEW_LINE print ( harmonicMean ( arr , n ) ) NEW_LINE"],"bleu":0.8447250900593729,"rouge_l":0.9543178973717145}
{"id":1162,"predictions":["def asPowerSum ( w , m ) : NEW_LINE INDENT while ( m > 0 ) : NEW_LINE INDENT if ( m - 1 ) % w == 0 : NEW_LINE INDENT m = ( m - 1 ) \/\/ w NEW_LINE DEDENT elif ( m + 1 ) % w == 0 : NEW_LINE INDENT m = ( m + 1 ) \/\/ w NEW_LINE DEDENT elif ( m % w == 0 ) : NEW_LINE INDENT m = m \/\/ w NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return ( m == 0 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT w = 3 NEW_LINE m = 7 NEW_LINE if ( asPowerSum ( w , m ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def asPowerSum ( w , m ) : NEW_LINE INDENT while ( m > 0 ) : NEW_LINE INDENT if ( ( m - 1 ) % w == 0 ) : NEW_LINE INDENT m = ( m - 1 ) \/ w ; NEW_LINE DEDENT elif ( ( m + 1 ) % w == 0 ) : NEW_LINE INDENT m = ( m + 1 ) \/ w ; NEW_LINE DEDENT elif ( m % w == 0 ) : NEW_LINE INDENT m = m \/ w ; NEW_LINE DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT return ( m == 0 ) ; NEW_LINE DEDENT w = 3 ; NEW_LINE m = 7 ; NEW_LINE if ( asPowerSum ( w , m ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT"],"bleu":0.7449029703789666,"rouge_l":0.8937254485614184}
{"id":1163,"predictions":["def result ( n , k , t ) : NEW_LINE INDENT if ( t <= k ) : NEW_LINE INDENT print ( t ) NEW_LINE DEDENT elif ( t <= n ) : NEW_LINE INDENT print ( k ) NEW_LINE DEDENT else : NEW_LINE INDENT temp = t - n NEW_LINE temp = k - temp NEW_LINE print ( temp ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE k = 5 NEW_LINE t = 12 NEW_LINE result ( n , k , t ) NEW_LINE DEDENT"],"references":["def result ( n , k , t ) : NEW_LINE INDENT if ( t <= k ) : NEW_LINE INDENT print ( t ) NEW_LINE DEDENT elif ( t <= n ) : NEW_LINE INDENT print ( k ) NEW_LINE DEDENT else : NEW_LINE INDENT temp = t - n NEW_LINE temp = k - temp NEW_LINE print ( temp ) NEW_LINE DEDENT DEDENT n = 10 NEW_LINE k = 5 NEW_LINE t = 12 NEW_LINE result ( n , k , t ) NEW_LINE"],"bleu":0.8439751537493221,"rouge_l":0.9374553252323088}
{"id":1164,"predictions":["from math import log NEW_LINE height = int ( log10 ( n ) ) NEW_LINE def prefs ( ) : NEW_LINE INDENT global size NEW_LINE height = int ( log10 ( n ) ) NEW_LINE table = [ [ - 1 ] * ( height + 1 ) for _ in range ( size + 1 ) ] NEW_LINE for i in range ( 0 , height + 1 ) : NEW_LINE INDENT table [ v ] [ 0 ] = u NEW_LINE for i in range ( 1 , height + 1 ) : NEW_LINE INDENT table [ i ] [ 0 ] = v NEW_LINE DEDENT DEDENT def calculateSparse ( u , v ) : NEW_LINE INDENT for i in range ( 0 , height + 1 ) : NEW_LINE INDENT if ( k & ( 1 << i ) != 0 ) : NEW_LINE INDENT V = table [ v ] [ i ] NEW_LINE if ( V == - 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT DEDENT def kthancestor ( V , k ) : NEW_LINE INDENT for i in range ( 0 , height + 1 ) : NEW_LINE INDENT if ( k & ( 1 << i ) != 0 ) : NEW_LINE INDENT V = table [ V ] [ i ] [ i ] NEW_LINE if ( V == - 1 ) : NEW_LINE INDENT V = table [ V ] [ i ] NEW_LINE if ( V == - 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return V NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 6 NEW_LINE preProcessor ( 1 , 2 ) NEW_LINE calculateSparse ( 1 , 2 ) NEW_LINE calculateSparse ( 1 , 3 ) NEW_LINE calculateSparse ( 2 , 4 ) NEW_LINE calculateSparse ( 3 , 6 ) NEW_LINE k = 2 NEW_LINE V = 5 NEW_LINE print ( kthancestor ( V , K ) ) NEW_LINE DEDENT"],"references":["import math NEW_LINE class GfG : NEW_LINE INDENT def __init__ ( self , n ) : NEW_LINE INDENT self . height = int ( math . ceil ( math . log10 ( n ) \/ math . log10 ( 2 ) ) ) NEW_LINE self . table = [ 0 ] * ( n + 1 ) NEW_LINE DEDENT def preprocessing ( self ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i < len ( self . table ) ) : NEW_LINE INDENT self . table [ i ] = [ - 1 ] * ( self . height + 1 ) NEW_LINE i = i + 1 NEW_LINE DEDENT DEDENT def calculateSparse ( self , u , v ) : NEW_LINE INDENT self . table [ v ] [ 0 ] = u NEW_LINE i = 1 NEW_LINE while ( i <= self . height ) : NEW_LINE INDENT self . table [ v ] [ i ] = self . table [ self . table [ v ] [ i - 1 ] ] [ i - 1 ] NEW_LINE if ( self . table [ v ] [ i ] == - 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT DEDENT def kthancestor ( self , V , k ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i <= self . height ) : NEW_LINE INDENT if ( ( k & ( 1 << i ) ) != 0 ) : NEW_LINE INDENT V = self . table [ V ] [ i ] NEW_LINE if ( V == - 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT i = i + 1 NEW_LINE DEDENT return V NEW_LINE DEDENT DEDENT n = 6 NEW_LINE obj = GfG ( n ) NEW_LINE obj . preprocessing ( ) NEW_LINE obj . calculateSparse ( 1 , 2 ) NEW_LINE obj . calculateSparse ( 1 , 3 ) NEW_LINE obj . calculateSparse ( 2 , 4 ) NEW_LINE obj . calculateSparse ( 2 , 5 ) NEW_LINE obj . calculateSparse ( 3 , 6 ) NEW_LINE K = 2 NEW_LINE V = 5 NEW_LINE print ( obj . kthancestor ( V , K ) ) NEW_LINE"],"bleu":0.45262380498117016,"rouge_l":0.577462224649554}
{"id":1165,"predictions":["def factors ( n ) : NEW_LINE INDENT if ( i <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT factors ( n , i + 1 ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 10 NEW_LINE factors ( N , 1 ) NEW_LINE DEDENT"],"references":["def factors ( n , i ) : NEW_LINE INDENT if ( i <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) ; NEW_LINE DEDENT factors ( n , i + 1 ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 16 ; NEW_LINE factors ( N , 1 ) ; NEW_LINE DEDENT"],"bleu":0.7151893138203724,"rouge_l":0.8685391066900722}
{"id":1166,"predictions":["def sumKRepeating ( arr , n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] = 0 NEW_LINE mp [ arr [ i ] ] += 1 NEW_LINE DEDENT for x in mp : NEW_LINE INDENT if ( mp [ x ] == k ) : NEW_LINE INDENT sum += x NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT arr = [ 9 , 9 , 10 , 11 , 8 , 8 , 9 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE print ( sumKRepeating ( arr , n , k ) ) NEW_LINE"],"references":["import math as mt NEW_LINE def sumKRepeating ( arr , n , k ) : NEW_LINE INDENT Sum = 0 NEW_LINE mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in mp . keys ( ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT for x in mp : NEW_LINE INDENT if ( mp [ x ] == k ) : NEW_LINE INDENT Sum += x NEW_LINE DEDENT DEDENT return Sum NEW_LINE DEDENT arr = [ 9 , 9 , 10 , 11 , 8 , 8 , 9 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE print ( sumKRepeating ( arr , n , k ) ) NEW_LINE"],"bleu":0.7105328860017299,"rouge_l":0.8324705882352941}
{"id":1167,"predictions":["def power ( num , n ) : NEW_LINE INDENT if ( n == 0 ) : return 1 NEW_LINE elif ( n % 2 == 0 ) : NEW_LINE INDENT return power ( num , n \/\/ 2 ) * power ( num , n \/\/ 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return num * power ( num , n \/\/ 2 ) * power ( num , n \/\/ 2 ) NEW_LINE DEDENT DEDENT def checkRecursive ( x , n , curr_num , curr_sum ) : NEW_LINE INDENT result = 0 NEW_LINE p = power ( curr_num , n ) NEW_LINE while ( p + curr_num < x ) : NEW_LINE INDENT result += checkRecursive ( x , n , curr_num + 1 , p + curr_sum ) NEW_LINE curr_num += 1 NEW_LINE p = power ( curr_num , n ) NEW_LINE DEDENT if ( p + curr_sum == x ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == x : NEW_LINE INDENT x = 10 NEW_LINE n = 2 NEW_LINE print ( checkRecursive ( x , n , 1 , 0 ) ) NEW_LINE DEDENT"],"references":["def power ( num , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( n % 2 == 0 ) : NEW_LINE INDENT return power ( num , n \/\/ 2 ) * power ( num , n \/\/ 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return num * power ( num , n \/\/ 2 ) * power ( num , n \/\/ 2 ) NEW_LINE DEDENT DEDENT def checkRecursive ( x , n , curr_num = 1 , curr_sum = 0 ) : NEW_LINE INDENT results = 0 NEW_LINE p = power ( curr_num , n ) NEW_LINE while ( p + curr_sum < x ) : NEW_LINE INDENT results += checkRecursive ( x , n , curr_num + 1 , p + curr_sum ) NEW_LINE curr_num = curr_num + 1 NEW_LINE p = power ( curr_num , n ) NEW_LINE DEDENT if ( p + curr_sum == x ) : NEW_LINE INDENT results = results + 1 NEW_LINE DEDENT return results NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 10 NEW_LINE n = 2 NEW_LINE print ( checkRecursive ( x , n ) ) NEW_LINE DEDENT"],"bleu":0.7969954393118655,"rouge_l":0.9038846615939128}
{"id":1168,"predictions":["def nCr ( n , r ) : NEW_LINE INDENT fac = [ 1 ] * 100 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fac [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fac [ i ] = fac [ i - 1 ] * i NEW_LINE DEDENT ans = fac [ n ] \/ ( fac [ n - r ] * fac [ r ] ) NEW_LINE return ans NEW_LINE DEDENT n = 3 NEW_LINE k = 3 NEW_LINE ans = nCr ( n + k - 1 , k ) + nCr ( k - 1 , n - 1 ) NEW_LINE print ( ans ) NEW_LINE"],"references":["def nCr ( n , r ) : NEW_LINE INDENT fac = list ( ) NEW_LINE fac . append ( 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fac . append ( fac [ i - 1 ] * i ) NEW_LINE DEDENT ans = fac [ n ] \/ ( fac [ n - r ] * fac [ r ] ) NEW_LINE return ans NEW_LINE DEDENT n = 3 NEW_LINE k = 3 NEW_LINE ans = nCr ( n + k - 1 , k ) + nCr ( k - 1 , n - 1 ) NEW_LINE print ( ans ) NEW_LINE"],"bleu":0.7397908089413966,"rouge_l":0.8680037945521073}
{"id":1169,"predictions":["def pairORSum ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( ( i + 1 ) , n ) : NEW_LINE INDENT ans = ans + arr [ i ] ^ arr [ j ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 5 , 9 , 7 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( pairORSum ( arr , n ) ) NEW_LINE"],"references":["def pairORSum ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT ans = ans + ( arr [ i ] ^ arr [ j ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 5 , 9 , 7 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( pairORSum ( arr , n ) ) NEW_LINE"],"bleu":0.9231680988088558,"rouge_l":0.9780219780219781}
{"id":1170,"predictions":["def alphabetPattern ( N ) : NEW_LINE INDENT top = 1 NEW_LINE Diagonal = 1 NEW_LINE Diagonal = N - 1 NEW_LINE for index in range ( N ) : NEW_LINE INDENT print ( top , end = \" ▁ \" ) NEW_LINE top += 1 NEW_LINE DEDENT print ( ) NEW_LINE for index in range ( 1 , N - 1 ) : NEW_LINE INDENT for copy_index in range ( 0 , 2 * ( N - index - 1 ) ) : NEW_LINE INDENT print ( \" ▁ \" , end = \" \" ) NEW_LINE DEDENT print ( \" \" ) NEW_LINE DEDENT for index in range ( N ) : NEW_LINE INDENT print ( \" ▁ \" , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT N = 5 NEW_LINE alphabetPattern ( N ) NEW_LINE"],"references":["def alphabetPattern ( N ) : NEW_LINE INDENT Top , Bottom , Diagonal = 1 , 1 , N - 1 NEW_LINE for index in range ( N ) : NEW_LINE INDENT print ( Top , end = ' ▁ ' ) NEW_LINE Top += 1 NEW_LINE DEDENT print ( ) NEW_LINE for index in range ( 1 , N - 1 ) : NEW_LINE INDENT for side_index in range ( 2 * ( N - index - 1 ) ) : NEW_LINE INDENT print ( ' ▁ ' , end = ' ' ) NEW_LINE DEDENT print ( Diagonal , end = ' ' ) NEW_LINE Diagonal -= 1 NEW_LINE print ( ) NEW_LINE DEDENT for index in range ( N ) : NEW_LINE INDENT print ( Bottom , end = ' ▁ ' ) NEW_LINE Bottom += 1 NEW_LINE DEDENT DEDENT N = 5 NEW_LINE alphabetPattern ( N ) NEW_LINE"],"bleu":0.6312302280720118,"rouge_l":0.768652592019454}
{"id":1171,"predictions":["def areElementsContiguous ( arr , n ) : NEW_LINE INDENT us = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT us . add ( arr [ i ] ) NEW_LINE DEDENT count = 1 NEW_LINE curr_ele = arr [ 0 ] - 1 NEW_LINE while ( not us . count ( ) in us . keys ( ) ) : NEW_LINE INDENT count += 1 NEW_LINE curr_ele -= 1 NEW_LINE DEDENT curr_ele = arr [ 0 ] + 1 NEW_LINE while ( us . count ( curr_ele ) in us . keys ( ) ) : NEW_LINE INDENT count += 1 NEW_LINE curr_ele += 1 NEW_LINE DEDENT return ( count == ( len ( us ) ) NEW_LINE DEDENT arr = [ 5 , 2 , 3 , 6 , 4 , 4 , 4 , 6 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE if ( areElementsContiguous ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def areElementsContiguous ( arr ) : NEW_LINE INDENT us = set ( ) NEW_LINE for i in arr : us . add ( i ) NEW_LINE count = 1 NEW_LINE curr_ele = arr [ 0 ] - 1 NEW_LINE while curr_ele in us : NEW_LINE INDENT count += 1 NEW_LINE curr_ele -= 1 NEW_LINE DEDENT curr_ele = arr [ 0 ] + 1 NEW_LINE while curr_ele in us : NEW_LINE INDENT count += 1 NEW_LINE curr_ele += 1 NEW_LINE DEDENT return ( count == len ( us ) ) NEW_LINE DEDENT arr = [ 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 ] NEW_LINE if areElementsContiguous ( arr ) : print ( \" Yes \" ) NEW_LINE else : print ( \" No \" ) NEW_LINE"],"bleu":0.5792030117877709,"rouge_l":0.8466836194108922}
{"id":1172,"predictions":["def powerPinarySearch ( arr , n , key ) : NEW_LINE INDENT pivot = findPinary ( arr , 0 , n - 1 ) NEW_LINE if ( pivot == - 1 ) : NEW_LINE INDENT return binarySearch ( arr , 0 , n - 1 , key ) NEW_LINE DEDENT if ( arr [ 0 ] <= key ) : NEW_LINE INDENT return binarySearch ( arr , 0 , mid - 1 , key ) NEW_LINE DEDENT return binarySearch ( arr , pivot + 1 , n - 1 , key ) NEW_LINE DEDENT def findPivot ( arr , low , high ) : NEW_LINE INDENT if ( high < low ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( high == low ) : NEW_LINE INDENT return low NEW_LINE DEDENT mid = ( low + high ) \/\/ 2 NEW_LINE if ( mid < high and arr [ mid ] > arr [ mid + 1 ] ) : NEW_LINE INDENT return ( mid - 1 ) NEW_LINE DEDENT if ( arr [ low ] >= arr [ mid ] ) : NEW_LINE INDENT return findPivot ( arr , low , mid - 1 ) NEW_LINE DEDENT return findPivot ( arr , low + 1 , high ) NEW_LINE DEDENT def binarySearch ( arr , low , high , key ) : NEW_LINE INDENT if ( high < low ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( low + high ) \/\/ 2 NEW_LINE if ( key == arr [ mid ] ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( low + high ) \/\/ 2 NEW_LINE if ( key == arr [ mid ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( key > arr [ mid ] ) : NEW_LINE INDENT return binarySearch ( arr , ( mid + 1 ) , high , key ) NEW_LINE DEDENT return binarySearch ( arr , low , ( mid - 1 ) , key ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr1 = [ 5 , 6 , 7 , 8 , 9 , 10 , 1 , 2 , 3 ] NEW_LINE n"],"references":["def pivotedBinarySearch ( arr , n , key ) : NEW_LINE INDENT pivot = findPivot ( arr , 0 , n - 1 ) ; NEW_LINE if pivot == - 1 : NEW_LINE INDENT return binarySearch ( arr , 0 , n - 1 , key ) ; NEW_LINE DEDENT if arr [ pivot ] == key : NEW_LINE INDENT return pivot NEW_LINE DEDENT if arr [ 0 ] <= key : NEW_LINE INDENT return binarySearch ( arr , 0 , pivot - 1 , key ) ; NEW_LINE DEDENT return binarySearch ( arr , pivot + 1 , n - 1 , key ) ; NEW_LINE DEDENT def findPivot ( arr , low , high ) : NEW_LINE INDENT if high < low : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if high == low : NEW_LINE INDENT return low NEW_LINE DEDENT mid = int ( ( low + high ) \/ 2 ) NEW_LINE if mid < high and arr [ mid ] > arr [ mid + 1 ] : NEW_LINE INDENT return mid NEW_LINE DEDENT if mid > low and arr [ mid ] < arr [ mid - 1 ] : NEW_LINE INDENT return ( mid - 1 ) NEW_LINE DEDENT if arr [ low ] >= arr [ mid ] : NEW_LINE INDENT return findPivot ( arr , low , mid - 1 ) NEW_LINE DEDENT return findPivot ( arr , mid + 1 , high ) NEW_LINE DEDENT def binarySearch ( arr , low , high , key ) : NEW_LINE INDENT if high < low : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = int ( ( low + high ) \/ 2 ) NEW_LINE if key == arr [ mid ] : NEW_LINE INDENT return mid NEW_LINE DEDENT if key > arr [ mid ] : NEW_LINE INDENT return binarySearch ( arr , ( mid + 1 ) , high , key ) ; NEW_LINE DEDENT return binarySearch ( arr , low , ( mid - 1 ) , key ) ; NEW_LINE DEDENT arr1 = [ 5 , 6 , 7 , 8 , 9 , 10 , 1 , 2 , 3 ] NEW_LINE n = len ( arr1 ) NEW_LINE key = 3 NEW_LINE print ( \" Index ▁ of ▁ the ▁ element ▁ is ▁ : ▁ \" , pivotedBinarySearch ( arr1 , n , key ) ) NEW_LINE"],"bleu":0.6761668057381326,"rouge_l":0.7974022719679252}
{"id":1173,"predictions":["def findDandZeroes ( a , b , n ) : NEW_LINE INDENT mpp = { } ; NEW_LINE count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( b [ i ] != 0 and a [ i ] != 0 ) : NEW_LINE INDENT val = ( - 1.0 * b [ i ] ) \/ ( a [ i ] ) ; NEW_LINE if ( mpp [ val ] == 0 ) : NEW_LINE INDENT mpp [ val ] = mpp [ val ] + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT mpp [ val ] = mpp . get ( val , 0 ) + 1 ; NEW_LINE DEDENT DEDENT maxi = 0 ; NEW_LINE for it in mpp : NEW_LINE INDENT if ( mpp [ it ] == maxi ) : NEW_LINE INDENT print ( \" Value ▁ of ▁ d ▁ is : ▁ \" , value [ it ] ) ; NEW_LINE break ; NEW_LINE DEDENT DEDENT print ( \" The ▁ number ▁ of ▁ zeros ▁ in ▁ array ▁ is : ▁ \" , maxi + count ) ; NEW_LINE DEDENT a = [ 3 , 7 , 39 ] ; NEW_LINE b = [ 2 , 2 , 3 ] ; NEW_LINE n = len ( a ) ; NEW_LINE findDandZeroes ( a , b , n ) ; NEW_LINE"],"references":["def findDandZeros ( a , b , n ) : NEW_LINE INDENT mpp = { } ; NEW_LINE count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( b [ i ] != 0 and a [ i ] != 0 ) : NEW_LINE INDENT val = ( - 1.0 * b [ i ] ) \/ a [ i ] ; NEW_LINE if val not in mpp : NEW_LINE INDENT mpp [ val ] = 0 ; NEW_LINE DEDENT mpp [ val ] += 1 ; NEW_LINE DEDENT elif ( b [ i ] == 0 and a [ i ] == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT maxi = 0 ; NEW_LINE for item in mpp : NEW_LINE INDENT maxi = max ( mpp [ item ] , maxi ) ; NEW_LINE DEDENT for keys , values in mpp . items ( ) : NEW_LINE INDENT if ( values == maxi ) : NEW_LINE INDENT print ( \" Value ▁ of ▁ d ▁ is : \" , keys ) ; NEW_LINE break ; NEW_LINE DEDENT DEDENT print ( \" The ▁ number ▁ of ▁ zeros ▁ in ▁ array ▁ C ▁ is : \" , maxi + count ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 13 , 37 , 39 ] ; NEW_LINE b = [ 1 , 2 , 3 ] ; NEW_LINE n = len ( a ) ; NEW_LINE findDandZeros ( a , b , n ) ; NEW_LINE DEDENT"],"bleu":0.6442761035368757,"rouge_l":0.7714683192108258}
{"id":1174,"predictions":["def count_odd_pairs ( n , a ) : NEW_LINE INDENT odd = 0 NEW_LINE even = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] % 2 == 0 ) : NEW_LINE INDENT even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT ans = odd * even NEW_LINE return ans NEW_LINE DEDENT def count_even_pairs ( odd_sum_pairs , n ) : NEW_LINE INDENT total_even_pairs = ( n * ( n - 1 ) ) NEW_LINE ans = total_even_pairs - odd_sum_pairs NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 6 NEW_LINE a = [ 2 , 4 , 5 , 9 , 1 , 8 ] NEW_LINE odd_sum_pairs = count_even_pairs ( n , a ) NEW_LINE even_prime_pairs = count_even_pairs = count_even_pairs ( odd_sum_pairs , n ) NEW_LINE print ( \" Even ▁ Sum ▁ Pairs ▁ = ▁ \" , even_even_pairs ) NEW_LINE print ( \" Odd ▁ Pairs ▁ = ▁ \" , odd_pairs ) NEW_LINE print ( \" Odd ▁ Sum ▁ Pairs ▁ = \" , odd_even_pairs ) NEW_LINE DEDENT"],"references":["def count_odd_pair ( n , a ) : NEW_LINE INDENT odd = 0 NEW_LINE even = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( a [ i ] % 2 == 0 ) : NEW_LINE INDENT even = even + 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd = odd + 1 NEW_LINE DEDENT DEDENT ans = odd * even * 2 NEW_LINE return ans NEW_LINE DEDENT def count_even_pair ( odd_sum_pairs , n ) : NEW_LINE INDENT total_pairs = ( n * ( n - 1 ) ) NEW_LINE ans = total_pairs - odd_sum_pairs NEW_LINE return ans NEW_LINE DEDENT n = 6 NEW_LINE a = [ 2 , 4 , 5 , 9 , 1 , 8 ] NEW_LINE odd_sum_pairs = count_odd_pair ( n , a ) NEW_LINE even_sum_pairs = count_even_pair ( odd_sum_pairs , n ) NEW_LINE print ( \" Even ▁ Sum ▁ Pairs ▁ = \" , even_sum_pairs ) NEW_LINE print ( \" Odd ▁ Sum ▁ Pairs = \" , odd_sum_pairs ) NEW_LINE"],"bleu":0.6730385716316655,"rouge_l":0.8431425004458712}
{"id":1175,"predictions":["def printQueries ( n , a , q , qry ) : NEW_LINE INDENT occ = set ( ) NEW_LINE suffixCount = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT occ [ a [ i ] ] = 1 NEW_LINE suffixCount [ i + 1 ] = len ( occ ) NEW_LINE DEDENT for i in range ( q ) : NEW_LINE INDENT print ( suffixCount [ qry [ i ] ] ) NEW_LINE DEDENT DEDENT n , q = 5 , 3 NEW_LINE a = [ 2 , 4 , 6 , 10 , 2 ] NEW_LINE qry = [ 1 , 3 , 2 ] NEW_LINE printQueries ( n , a , q , qry ) NEW_LINE"],"references":["def printQueries ( n , a , q , qry ) : NEW_LINE INDENT occ = dict ( ) NEW_LINE suffixCount = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT occ [ a [ i ] ] = 1 NEW_LINE suffixCount [ i + 1 ] = len ( occ ) NEW_LINE DEDENT for i in range ( q ) : NEW_LINE INDENT print ( suffixCount [ qry [ i ] ] ) NEW_LINE DEDENT DEDENT n = 5 NEW_LINE q = 3 NEW_LINE a = [ 2 , 4 , 6 , 10 , 2 ] NEW_LINE qry = [ 1 , 3 , 2 ] NEW_LINE printQueries ( n , a , q , qry ) NEW_LINE"],"bleu":0.8889138915243293,"rouge_l":0.9448002794922556}
{"id":1176,"predictions":["def countRotations ( n ) : NEW_LINE INDENT l = len ( n ) NEW_LINE if ( l == 1 ) : NEW_LINE INDENT oneDigit = int ( n [ 0 ] ) - int ( n [ 0 ] ) NEW_LINE if ( oneDigit % 4 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT twoDigit = 0 NEW_LINE count = 0 NEW_LINE for i in range ( 0 , ( l - 1 ) ) : NEW_LINE INDENT twoDigit = ( ( ord ( n [ i ] ) - ord ( '0' ) ) * 10 + ( ord ( n [ i + 1 ] ) - ord ( '0' ) ) NEW_LINE if ( twoDigit % 4 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT twoDigit = ( ( ord ( n [ l - 1 ] ) - ord ( '0' ) ) * 10 + ( ord ( n [ 0 ] ) - ord ( '0' ) ) NEW_LINE if ( twoDigit % 4 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT n = \"4834\" NEW_LINE print ( \"Rotations : ▁ \" , countRotations ( n ) ) NEW_LINE"],"references":["def countRotations ( n ) : NEW_LINE INDENT l = len ( n ) NEW_LINE if ( l == 1 ) : NEW_LINE INDENT oneDigit = ( int ) ( n [ 0 ] ) NEW_LINE if ( oneDigit % 4 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 0 , l - 1 ) : NEW_LINE INDENT twoDigit = ( int ) ( n [ i ] ) * 10 + ( int ) ( n [ i + 1 ] ) NEW_LINE if ( twoDigit % 4 == 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT twoDigit = ( int ) ( n [ l - 1 ] ) * 10 + ( int ) ( n [ 0 ] ) NEW_LINE if ( twoDigit % 4 == 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT n = \"4834\" NEW_LINE print ( \" Rotations : ▁ \" , countRotations ( n ) ) NEW_LINE"],"bleu":0.690588737540405,"rouge_l":0.8525399615030547}
{"id":1177,"predictions":["def smallestX ( n ) : NEW_LINE INDENT temp = [ 0 for i in range ( 10 ) ] NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT count , x = 0 , 0 NEW_LINE for x in range ( 1 , 10 ) : NEW_LINE INDENT y = x * n NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( temp [ y % 10 ] == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE temp [ y % 10 ] = 1 NEW_LINE DEDENT y \/\/= 10 NEW_LINE DEDENT DEDENT return x - 1 NEW_LINE DEDENT n = 5 NEW_LINE print ( smallestX ( n ) ) NEW_LINE"],"references":["def smallestX ( n ) : NEW_LINE INDENT temp = [ 0 ] * 10 NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT count = 0 NEW_LINE x = 1 NEW_LINE while ( count < 10 ) : NEW_LINE INDENT y = x * n NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( temp [ y % 10 ] == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE temp [ y % 10 ] = 1 NEW_LINE DEDENT y = int ( y \/ 10 ) NEW_LINE DEDENT x += 1 NEW_LINE DEDENT return x - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( smallestX ( n ) ) NEW_LINE DEDENT"],"bleu":0.6831495517716526,"rouge_l":0.8024304685542468}
{"id":1178,"predictions":["def distinctAdjacentElement ( a , n ) : NEW_LINE INDENT m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT m [ a [ i ] ] = m . get ( a [ i ] , 0 ) + 1 NEW_LINE DEDENT mx = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( mx < m [ a [ i ] ] ) : NEW_LINE INDENT mx = m [ a [ i ] ] + 1 NEW_LINE DEDENT DEDENT if ( mx > ( n + 1 ) \/\/ 2 ) : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT DEDENT a = [ 7 , 7 , 7 , 7 ] NEW_LINE n = 4 NEW_LINE distinctAdjacentElement ( a , n ) NEW_LINE"],"references":["def distantAdjacentElement ( a , n ) : NEW_LINE INDENT m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] in m : NEW_LINE INDENT m [ a [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ a [ i ] ] = 1 NEW_LINE DEDENT DEDENT mx = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if mx < m [ a [ i ] ] : NEW_LINE INDENT mx = m [ a [ i ] ] NEW_LINE DEDENT DEDENT if mx > ( n + 1 ) \/\/ 2 : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 7 , 7 , 7 , 7 ] NEW_LINE n = len ( a ) NEW_LINE distantAdjacentElement ( a , n ) NEW_LINE DEDENT"],"bleu":0.6698433983483161,"rouge_l":0.8084264662249036}
{"id":1179,"predictions":["def fnMod ( n ) : NEW_LINE INDENT rem = n % 4 ; NEW_LINE if ( rem == 0 or rem == 3 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT elif ( rem == 1 or rem == 2 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT return 0 ; NEW_LINE DEDENT n = 6 ; NEW_LINE print ( fnMod ( n ) ) ; NEW_LINE"],"references":["def fnMod ( n ) : NEW_LINE INDENT rem = n % 4 NEW_LINE if ( rem == 0 or rem == 3 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( rem == 1 or rem == 2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 6 NEW_LINE print ( fnMod ( n ) ) NEW_LINE DEDENT"],"bleu":0.6928729401923556,"rouge_l":0.8361797752808988}
{"id":1180,"predictions":["def isRectangle ( a , b , c , d ) : NEW_LINE INDENT if ( ( a ^ b ^ c ^ d ) != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 3 NEW_LINE b = 2 NEW_LINE c = 3 NEW_LINE d = 2 NEW_LINE if ( isRectangle ( a , b , c , d ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def isRectangle ( a , b , c , d ) : NEW_LINE INDENT if a ^ b ^ c ^ d : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT a , b , c , d = 3 , 2 , 3 , 2 NEW_LINE print ( \" Yes \" if isRectangle ( a , b , c , d ) else \" No \" ) NEW_LINE"],"bleu":0.4172347656813393,"rouge_l":0.6552958914436489}
{"id":1181,"predictions":["def merge ( arr , temp , left , mid , right , right ) : NEW_LINE INDENT inv_count = 0 NEW_LINE i = left NEW_LINE j = mid NEW_LINE k = left NEW_LINE while ( ( i <= mid - 1 ) and ( j <= right ) ) : NEW_LINE INDENT if ( arr [ i ] <= arr [ j ] ) : NEW_LINE INDENT temp [ k ] = arr [ i ] NEW_LINE k += 1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT temp [ k ] = arr [ j ] NEW_LINE k += 1 NEW_LINE j += 1 NEW_LINE inv_count = inv_count + ( mid - i ) NEW_LINE DEDENT DEDENT while ( i <= mid - 1 ) : NEW_LINE INDENT temp [ k ] = arr [ i ] NEW_LINE k += 1 NEW_LINE k += 1 NEW_LINE DEDENT while ( j <= right ) : NEW_LINE INDENT temp [ k ] = arr [ j ] NEW_LINE k += 1 NEW_LINE j += 1 NEW_LINE DEDENT for i in range ( left , right + 1 ) : NEW_LINE INDENT arr [ i ] = temp [ i ] NEW_LINE k += 1 NEW_LINE DEDENT return inv_count NEW_LINE DEDENT def _mergeSort ( arr , temp , left , right ) : NEW_LINE INDENT inv_count = 0 NEW_LINE if ( right > left ) : NEW_LINE INDENT mid = ( right + left ) \/\/ 2 NEW_LINE inv_count = _mergeSort ( arr , temp , left , mid ) NEW_LINE inv_count += _mergeSort ( arr , temp , left , mid ) NEW_LINE inv_count += _mergeSort ( arr , temp , mid + 1 , right ) NEW_LINE DEDENT return inv_count NEW_LINE DEDENT def mergeSort ( arr , Array_size ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] - 1 ) - i > 2 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 5 , 3 , 4 ] NEW_LINE N"],"references":["def merge ( arr , temp , left , mid , right ) : NEW_LINE INDENT inv_count = 0 NEW_LINE i = left NEW_LINE j = mid NEW_LINE k = left NEW_LINE while ( i <= mid - 1 ) and ( j <= right ) : NEW_LINE INDENT if arr [ i ] <= arr [ j ] : NEW_LINE INDENT temp [ k ] = arr [ i ] NEW_LINE k , i = k + 1 , i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT temp [ k ] = arr [ j ] NEW_LINE k , j = k + 1 , j + 1 NEW_LINE inv_count = inv_count + ( mid - i ) NEW_LINE DEDENT DEDENT while i <= mid - 1 : NEW_LINE INDENT temp [ k ] = arr [ i ] NEW_LINE k , i = k + 1 , i + 1 NEW_LINE DEDENT while j <= right : NEW_LINE INDENT temp [ k ] = arr [ j ] NEW_LINE k , j = k + 1 , j + 1 NEW_LINE DEDENT for i in range ( left , right + 1 ) : NEW_LINE INDENT arr [ i ] = temp [ i ] NEW_LINE DEDENT return inv_count NEW_LINE DEDENT def _mergeSort ( arr , temp , left , right ) : NEW_LINE INDENT inv_count = 0 NEW_LINE if right > left : NEW_LINE INDENT mid = ( right + left ) \/\/ 2 NEW_LINE inv_count = _mergeSort ( arr , temp , left , mid ) NEW_LINE inv_count += _mergeSort ( arr , temp , mid + 1 , right ) NEW_LINE inv_count += merge ( arr , temp , left , mid + 1 , right ) NEW_LINE DEDENT return inv_count NEW_LINE DEDENT def mergeSort ( arr , array_size ) : NEW_LINE INDENT temp = [ None ] * array_size NEW_LINE return _mergeSort ( arr , temp , 0 , array_size - 1 ) NEW_LINE DEDENT def minSwapToReachArr ( arr , N ) : NEW_LINE INDENT for i in range ( 0 , N ) : NEW_LINE INDENT if ( arr [ i ] - 1 ) - i > 2 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT numOfInversion = mergeSort ( arr , N ) NEW_LINE return numOfInversion NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 5 , 3 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE res = minSwapToReachArr ( arr , N ) NEW_LINE if res == - 1 : NEW_LINE INDENT print ( \" Not ▁ Possible \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res ) NEW_LINE DEDENT DEDENT"],"bleu":0.6131595340998633,"rouge_l":0.76546949372566}
{"id":1182,"predictions":["import math NEW_LINE def Prime ( n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def primeCountDivisors ( n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT a = n NEW_LINE c = 0 NEW_LINE while ( a % i == 0 ) : NEW_LINE INDENT a \/= i NEW_LINE c += 1 NEW_LINE DEDENT if ( a == 1 and Prime ( c + 1 ) == True ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT n = 13 NEW_LINE if ( primeCountDivisors ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["from math import sqrt NEW_LINE def Prime ( n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT for i in range ( 2 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT def primeCountDivisors ( n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT for i in range ( 2 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT a = n ; c = 0 ; NEW_LINE while ( a % i == 0 ) : NEW_LINE INDENT a \/\/= i ; NEW_LINE c += 1 ; NEW_LINE DEDENT if ( a == 1 and Prime ( c + 1 ) ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT DEDENT return True ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 13 ; NEW_LINE if ( primeCountDivisors ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"],"bleu":0.750441602284077,"rouge_l":0.8795230833217802}
{"id":1183,"predictions":["def countSubSeq ( a , n , k ) : NEW_LINE INDENT a = sorted ( a ) NEW_LINE arr = sorted ( a ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT count = 1 NEW_LINE x = a [ i ] NEW_LINE i += 1 NEW_LINE while ( i < n and a [ i ] == x ) : NEW_LINE INDENT count += 1 NEW_LINE i += 1 NEW_LINE DEDENT arr . append ( count ) NEW_LINE DEDENT m = len ( arr ) NEW_LINE n = min ( m , k ) NEW_LINE count = 1 NEW_LINE dp = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( m , - 1 , - 1 ) : NEW_LINE INDENT if ( j > m - i ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i ] [ j + 1 ] + arr [ j ] * dp [ i - 1 ] [ j + 1 ] ) NEW_LINE DEDENT DEDENT count = count + dp [ i ] [ 0 ] NEW_LINE DEDENT return count NEW_LINE DEDENT a = [ 2 , 2 , 3 , 3 , 5 ] NEW_LINE n = len ( a ) NEW_LINE k = 3 NEW_LINE print ( countSubSeq ( a , n , k ) ) NEW_LINE"],"references":["def countSubSeq ( a , n , k ) : NEW_LINE INDENT a . sort ( reverse = False ) NEW_LINE arr = [ ] NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT count = 1 NEW_LINE x = a [ i ] NEW_LINE i += 1 NEW_LINE while ( i < n and a [ i ] == x ) : NEW_LINE INDENT count += 1 NEW_LINE i += 1 NEW_LINE DEDENT arr . append ( count ) NEW_LINE DEDENT m = len ( arr ) NEW_LINE n = min ( m , k ) NEW_LINE count = 1 NEW_LINE dp = [ [ 0 for i in range ( m + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT j = m NEW_LINE while ( j >= 0 ) : NEW_LINE INDENT if ( j > m - i ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j + 1 ] +   \\ NEW_LINE INDENT arr [ j ] * dp [ i - 1 ] [ j + 1 ] NEW_LINE DEDENT DEDENT j -= 1 NEW_LINE DEDENT count = count + dp [ i ] [ 0 ] NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 2 , 2 , 3 , 3 , 5 ] NEW_LINE n = len ( a ) NEW_LINE k = 3 NEW_LINE print ( countSubSeq ( a , n , k ) ) NEW_LINE DEDENT"],"bleu":0.7370889724786666,"rouge_l":0.8466320132897486}
{"id":1184,"predictions":["def isVowel ( ch ) : NEW_LINE INDENT if ch in [ ' a ' , ' e ' , ' i ' , ' o ' , ' u ' , ' u ' ] : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def isSiply ( string , n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( isVowel ( string [ i ] ) and isVowel ( string [ i - 1 ] ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( isVowel ( string [ i ] ) and not isVowel ( string [ i - 1 ] ) and not isVowel ( string [ i + 1 ] ) and not isVowel ( string [ i + 1 ] ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT string = \" acaba \" NEW_LINE n = len ( string ) NEW_LINE if ( isSiply ( string , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def isVowel ( ch ) : NEW_LINE INDENT if ch in [ ' i ' , ' a ' , ' e ' , ' o ' , ' u ' ] : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def isSatisfied ( st , n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( isVowel ( st [ i ] ) == False and isVowel ( st [ i - 1 ] ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( isVowel ( st [ i ] ) and isVowel ( st [ i - 1 ] ) == False and isVowel ( st [ i + 1 ] ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT st = \" acaba \" NEW_LINE n = len ( st ) NEW_LINE if ( isSatisfied ( st , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.7041608277194927,"rouge_l":0.8396421197522367}
{"id":1185,"predictions":["def equal_xor_sum ( arr , n ) : NEW_LINE INDENT Sum = 0 ; NEW_LINE Xor = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum = Sum + arr [ i ] ; NEW_LINE Xor = Xor ^ arr [ i ] ; NEW_LINE DEDENT if ( Sum == Xor ) : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 6 , 3 , 7 , 10 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE equal_xor_sum ( arr , n ) ; NEW_LINE DEDENT"],"references":["def equal_xor_sum ( arr , n ) : NEW_LINE INDENT Sum = 0 ; NEW_LINE Xor = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum = Sum + arr [ i ] ; NEW_LINE Xor = Xor ^ arr [ i ] ; NEW_LINE DEDENT if ( Sum == Xor ) : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 6 , 3 , 7 , 10 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE equal_xor_sum ( arr , n ) ; NEW_LINE DEDENT"],"bleu":0.9598253314161869,"rouge_l":0.9841269841269841}
{"id":1186,"predictions":["import sys NEW_LINE def getMinLength ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE result = sys . maxsize NEW_LINE for i in arr : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( count != 0 ) : NEW_LINE INDENT result = min ( result , count ) NEW_LINE DEDENT count = 0 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( getMinLength ( arr , n ) ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE def getMinLength ( arr , n ) : NEW_LINE INDENT count = 0 ; NEW_LINE result = sys . maxsize ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( count != 0 ) : NEW_LINE INDENT result = min ( result , count ) ; NEW_LINE DEDENT count = 0 ; NEW_LINE DEDENT DEDENT return result ; NEW_LINE DEDENT arr = [ 1 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 1 , 1 , 1 , 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( getMinLength ( arr , n ) ) ; NEW_LINE"],"bleu":0.7713465960284005,"rouge_l":0.8905109489051094}
{"id":1187,"predictions":["def isPowerOfTwo ( n ) : NEW_LINE INDENT return ( n and ( not ( n & ( n - 1 ) ) ) ) NEW_LINE DEDENT def findPosition ( n ) : NEW_LINE INDENT if not isPowerOfTwo ( n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT i = 1 NEW_LINE pos = 1 NEW_LINE while ( ( i & n ) ) : NEW_LINE INDENT i = i << 1 NEW_LINE pos += 1 NEW_LINE DEDENT return pos NEW_LINE DEDENT n = 16 NEW_LINE pos = findPosition ( n ) NEW_LINE if ( pos == - 1 ) : NEW_LINE INDENT print ( \" n ▁ = \" , n , \" Invalid ▁ number \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" n ▁ = ▁ \" , n , \" Position \" , pos ) NEW_LINE DEDENT n = 16 NEW_LINE pos = findPosition ( n ) NEW_LINE if ( pos == - 1 ) : NEW_LINE INDENT print ( \" n ▁ = \" , n , \" Invalid ▁ number \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" n ▁ = \" , n , \" Position \" , pos ) NEW_LINE DEDENT n = 128 NEW_LINE pos = findPosition ( n ) NEW_LINE if ( pos == - 1 ) : NEW_LINE INDENT print ( \" n ▁ = \" , n , \" Invalid ▁ number \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" n ▁ = \" , n , \" Position \" , pos ) NEW_LINE DEDENT n = 128 NEW_LINE pos = findPosition ( n ) NEW_LINE if ( pos == - 1 ) : NEW_LINE INDENT print ( \" n ▁ = \" , n , \" Invalid ▁ number \" ) NEW_LINE DEDENT"],"references":["def isPowerOfTwo ( n ) : NEW_LINE INDENT return ( True if ( n > 0 and ( ( n & ( n - 1 ) ) > 0 ) ) else False ) ; NEW_LINE DEDENT def findPosition ( n ) : NEW_LINE INDENT if ( isPowerOfTwo ( n ) == True ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT i = 1 ; NEW_LINE pos = 1 ; NEW_LINE while ( ( i & n ) == 0 ) : NEW_LINE INDENT i = i << 1 ; NEW_LINE pos += 1 ; NEW_LINE DEDENT return pos ; NEW_LINE DEDENT n = 16 ; NEW_LINE pos = findPosition ( n ) ; NEW_LINE if ( pos == - 1 ) : NEW_LINE INDENT print ( \" n ▁ = \" , n , \" , ▁ Invalid ▁ number \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" n ▁ = \" , n , \" , ▁ Position ▁ \" , pos ) ; NEW_LINE DEDENT n = 12 ; NEW_LINE pos = findPosition ( n ) ; NEW_LINE if ( pos == - 1 ) : NEW_LINE INDENT print ( \" n ▁ = \" , n , \" , ▁ Invalid ▁ number \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" n ▁ = \" , n , \" , ▁ Position ▁ \" , pos ) ; NEW_LINE DEDENT n = 128 ; NEW_LINE pos = findPosition ( n ) ; NEW_LINE if ( pos == - 1 ) : NEW_LINE INDENT print ( \" n ▁ = \" , n , \" , ▁ Invalid ▁ number \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" n ▁ = \" , n , \" , ▁ Position ▁ \" , pos ) ; NEW_LINE DEDENT"],"bleu":0.6851779232984799,"rouge_l":0.846417642713939}
{"id":1188,"predictions":["def totalNumber ( n ) : NEW_LINE INDENT return 8 * ( 9 * ( 9 ** ( n - 1 ) ) ) NEW_LINE DEDENT n = 3 NEW_LINE print ( totalNumber ( n ) ) NEW_LINE"],"references":["def totalNumber ( n ) : NEW_LINE INDENT return 8 * pow ( 9 , n - 1 ) ; NEW_LINE DEDENT n = 3 NEW_LINE print ( totalNumber ( n ) ) NEW_LINE"],"bleu":0.6915865355058665,"rouge_l":0.8698252069917204}
{"id":1189,"predictions":["rev_num = 0 NEW_LINE base_pos = 1 NEW_LINE def reversDigits ( num ) : NEW_LINE INDENT global rev_num NEW_LINE global base_pos NEW_LINE if ( num > 0 ) : NEW_LINE INDENT reversDigits ( int ) ( num \/ 10 ) NEW_LINE rev_num += ( num % 10 ) * base_pos *= 10 NEW_LINE DEDENT return rev_num NEW_LINE DEDENT num = 4562 NEW_LINE print ( reversDigits ( num ) ) NEW_LINE"],"references":["rev_num = 0 NEW_LINE base_pos = 1 NEW_LINE def reversDigits ( num ) : NEW_LINE INDENT global rev_num NEW_LINE global base_pos NEW_LINE if ( num > 0 ) : NEW_LINE INDENT reversDigits ( ( int ) ( num \/ 10 ) ) NEW_LINE rev_num += ( num % 10 ) * base_pos NEW_LINE base_pos *= 10 NEW_LINE DEDENT return rev_num NEW_LINE DEDENT num = 4562 NEW_LINE print ( \" Reverse ▁ of ▁ no . ▁ is ▁ \" , reversDigits ( num ) ) NEW_LINE"],"bleu":0.750911833011856,"rouge_l":0.8811390837804374}
{"id":1190,"predictions":["def check ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE s . sort ( ) NEW_LINE for i in range ( 1 , l ) : NEW_LINE INDENT if ( s [ i ] - s [ i - 1 ] != 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT s = \" dcef \" NEW_LINE if ( check ( s ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def check ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE s = ' ' . join ( sorted ( s ) ) NEW_LINE for i in range ( 1 , l ) : NEW_LINE INDENT if ord ( s [ i ] ) - ord ( s [ i - 1 ] ) != 1 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" dcef \" NEW_LINE if check ( string ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT string = \" xyza \" NEW_LINE if check ( string ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.45752446044475215,"rouge_l":0.7042288869368803}
{"id":1191,"predictions":["def max regions ( n ) : NEW_LINE INDENT num = n * ( ( n + 1 ) \/\/ 2 + 1 ) ; NEW_LINE print ( num ) ; NEW_LINE DEDENT n = 10 ; NEW_LINE max regions ( n ) ; NEW_LINE"],"references":["def maxRegions ( n ) : NEW_LINE INDENT num = n * ( n + 1 ) \/\/ 2 + 1 NEW_LINE print ( num ) NEW_LINE DEDENT n = 10 NEW_LINE maxRegions ( n ) NEW_LINE"],"bleu":0.5904640566894295,"rouge_l":0.868945868945869}
{"id":1192,"predictions":["def bestSwoggle ( x , y ) : NEW_LINE INDENT n = len ( x ) NEW_LINE sum_x = 0 NEW_LINE sum_y = 0 NEW_LINE sum_x = 0 NEW_LINE sum_x2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum_x += x [ i ] NEW_LINE sum_y += y [ i ] NEW_LINE sum_x2 += pow ( x [ i ] , 2 ) NEW_LINE DEDENT m = ( n * sum_xy - sum_x * sum_y ) \/ ( n * sum_x2 - pow ( sum_x , 2 ) ) NEW_LINE c = ( sum_y - m * sum_x ) \/ n NEW_LINE print ( \" m ▁ = \" , m ) NEW_LINE print ( \" m ▁ = \" , m ) NEW_LINE print ( \" c ▁ = ▁ \" , c ) NEW_LINE print ( \" c ▁ = ▁ \" , c ) NEW_LINE"],"references":["def bestApproximate ( x , y , n ) : NEW_LINE INDENT sum_x = 0 NEW_LINE sum_y = 0 NEW_LINE sum_xy = 0 NEW_LINE sum_x2 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum_x += x [ i ] NEW_LINE sum_y += y [ i ] NEW_LINE sum_xy += x [ i ] * y [ i ] NEW_LINE sum_x2 += pow ( x [ i ] , 2 ) NEW_LINE DEDENT m = ( float ) ( ( n * sum_xy - sum_x * sum_y ) \/ ( n * sum_x2 - pow ( sum_x , 2 ) ) ) ; NEW_LINE c = ( float ) ( sum_y - m * sum_x ) \/ n ; NEW_LINE print ( \" m ▁ = ▁ \" , m ) ; NEW_LINE print ( \" c ▁ = ▁ \" , c ) ; NEW_LINE DEDENT x = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE y = [ 14 , 27 , 40 , 55 , 68 ] NEW_LINE n = len ( x ) NEW_LINE bestApproximate ( x , y , n ) NEW_LINE"],"bleu":0.5635868402477372,"rouge_l":0.7040395713107996}
{"id":1193,"predictions":["from math import ceil NEW_LINE def printPrevGreater ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT c = s . floor ( arr [ i ] ) NEW_LINE if ( c != None ) : NEW_LINE INDENT print ( - 1 , end = \" ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( c , end = \" ▁ \" ) NEW_LINE DEDENT print ( arr [ i ] ) NEW_LINE DEDENT DEDENT arr = [ 10 , 5 , 10 , 12 , 15 ] NEW_LINE n = len ( arr ) NEW_LINE printPrevGreater ( arr , n ) NEW_LINE"],"references":["def printPrevGreater ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT it = [ x for x in s if x >= arr [ i ] ] NEW_LINE if len ( it ) == 0 : NEW_LINE INDENT print ( \" - 1\" , end = \" ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( min ( it ) , end = \" ▁ \" ) NEW_LINE DEDENT s . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 10 , 5 , 11 , 10 , 20 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE printPrevGreater ( arr , n ) NEW_LINE DEDENT"],"bleu":0.5630188194524807,"rouge_l":0.7551170486579237}
{"id":1194,"predictions":["MAX = 1000005 ; NEW_LINE prime = [ True ] * ( MAX ) ; NEW_LINE def vecIni ( ) : NEW_LINE INDENT for i in range ( MAX ) : NEW_LINE INDENT prime [ i ] = True ; NEW_LINE DEDENT DEDENT def seive ( N ) : NEW_LINE INDENT prime [ 0 ] = False ; NEW_LINE prime [ 1 ] = False ; NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT for j in range ( 2 , N + 1 ) : NEW_LINE INDENT prime [ i * j ] = False ; NEW_LINE DEDENT DEDENT DEDENT def countLogNeeded ( N ) : NEW_LINE INDENT count = 0 ; NEW_LINE seive ( N ) ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT vecIni ( ) ; NEW_LINE N = 6 ; NEW_LINE print ( countLogNeeded ( N ) ) ; NEW_LINE DEDENT"],"references":["MAX = 1000005 NEW_LINE prime = [ True for i in range ( MAX ) ] NEW_LINE def seive ( N ) : NEW_LINE INDENT prime [ 0 ] , prime [ 1 ] = False , False NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT for j in range ( 2 , N + 1 ) : NEW_LINE INDENT if ( i * j > N ) : NEW_LINE INDENT break NEW_LINE DEDENT prime [ i * j ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def countLogNeeded ( N ) : NEW_LINE INDENT count = 0 NEW_LINE seive ( N ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 6 NEW_LINE print ( countLogNeeded ( N ) ) NEW_LINE DEDENT"],"bleu":0.6533262140364228,"rouge_l":0.8246064339493497}
{"id":1195,"predictions":["def findMinimumOperation ( n , d , array ) : NEW_LINE INDENT cnt = 0 NEW_LINE first = - sys . maxsize NEW_LINE end = float ( \" inf \" ) NEW_LINE while n > 0 : NEW_LINE INDENT arr [ cnt ] [ 0 ] = array [ cnt ] [ 1 ] NEW_LINE arr . sort ( ) NEW_LINE first = max ( first , arr [ 0 ] ) NEW_LINE end = min ( end , arr [ 1 ] ) NEW_LINE cnt += 1 NEW_LINE n -= 1 NEW_LINE DEDENT if first > end : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT else : NEW_LINE INDENT if d >= first and d <= end : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( min ( abs ( first - d ) , abs ( d - end ) ) ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE d = 3 NEW_LINE array = [ [ 0 , 7 ] , [ 2 , 14 ] , [ 4 , 6 ] , [ 4 , 6 ] ] NEW_LINE findMinimumOperation ( n , d , array ) NEW_LINE DEDENT"],"references":["def findMinimumOperation ( n , d , arrays ) : NEW_LINE INDENT cnt = 0 NEW_LINE first = - 10 ** 9 NEW_LINE end = 10 ** 9 NEW_LINE while ( n ) : NEW_LINE INDENT arr = [ arrays [ cnt ] [ 0 ] , arrays [ cnt ] [ 1 ] ] NEW_LINE arr = sorted ( arr ) NEW_LINE first = max ( first , arr [ 0 ] ) NEW_LINE end = min ( end , arr [ 1 ] ) NEW_LINE cnt += 1 NEW_LINE n -= 1 NEW_LINE DEDENT if ( first > end ) : NEW_LINE INDENT print ( \" - 1\" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( d >= first and d <= end ) : NEW_LINE INDENT print ( \"0\" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( min ( abs ( first - d ) , abs ( d - end ) ) , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE d = 3 NEW_LINE arrays = [ [ 0 , 7 ] , [ 2 , 14 ] , [ 4 , 6 ] ] NEW_LINE findMinimumOperation ( n , d , arrays ) NEW_LINE DEDENT"],"bleu":0.6965558214899313,"rouge_l":0.8405511811023623}
{"id":1196,"predictions":["if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 0 for i in range ( MAX ) ] NEW_LINE index1 = [ 0 for i in range ( MAX ) ] NEW_LINE index2 = [ 0 for i in range ( MAX ) ] NEW_LINE index3 = [ 0 for i in range ( MAX ) ] NEW_LINE arr [ 0 ] = 0 NEW_LINE arr [ 1 ] = 1 NEW_LINE for i in range ( 2 , MAX , 1 ) : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] + arr [ i - 2 ] NEW_LINE DEDENT c1 , c2 , c3 = 0 , 0 , 0 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if arr [ i ] % 2 == 0 : NEW_LINE INDENT index1 [ c1 ] = i NEW_LINE c1 += 1 NEW_LINE DEDENT if arr [ i ] % 5 == 0 : NEW_LINE INDENT index2 [ c2 ] = i NEW_LINE c2 [ c2 ] = i NEW_LINE DEDENT if arr [ i ] % 8 == 0 : NEW_LINE INDENT index4 [ c3 ] = i NEW_LINE DEDENT DEDENT print ( \" Index ▁ of ▁ Fibonacci ▁ numbers ▁ divisible ▁ by ▁ 2 ▁ are ▁ : \" ) NEW_LINE for i in range ( c1 ) : NEW_LINE INDENT print ( index , end = \" ▁ \" ) NEW_LINE DEDENT print ( \" Index ▁ of ▁ Fibonacci ▁ numbers ▁ divisible ▁ by ▁ 2 ▁ are ▁ : \" ) NEW_LINE print ( \" Index ▁ of ▁ Fibonacci ▁ number ▁ divisible ▁ by ▁ 2 ▁ are ▁ : \" ) NEW_LINE for i in range ( c1 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( \" Index ▁ of ▁ Fibonacci ▁ number ▁ divisible ▁ by ▁ 2 ▁ are ▁ : \" ) NEW_LINE print ( \" Index ▁ of ▁ Fibonacci �"],"references":["MAX = 90 ; NEW_LINE arr = [ 0 ] * ( MAX ) ; NEW_LINE index1 = [ 0 ] * ( MAX ) ; NEW_LINE index2 = [ 0 ] * ( MAX ) ; NEW_LINE index3 = [ 0 ] * ( MAX ) ; NEW_LINE index4 = [ 0 ] * ( MAX ) ; NEW_LINE arr [ 0 ] = 0 ; NEW_LINE arr [ 1 ] = 1 ; NEW_LINE for i in range ( 2 , MAX ) : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] + arr [ i - 2 ] ; NEW_LINE DEDENT c1 , c2 , c3 , c4 = 0 , 0 , 0 , 0 ; NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT index1 [ c1 ] = i ; NEW_LINE c1 += 1 ; NEW_LINE DEDENT if ( arr [ i ] % 3 == 0 ) : NEW_LINE INDENT index2 [ c2 ] = i ; NEW_LINE c2 += 1 ; NEW_LINE DEDENT if ( arr [ i ] % 5 == 0 ) : NEW_LINE INDENT index3 [ c3 ] = i ; NEW_LINE c3 += 1 ; NEW_LINE DEDENT if ( arr [ i ] % 8 == 0 ) : NEW_LINE INDENT index4 [ c4 ] = i ; NEW_LINE c4 += 1 ; NEW_LINE DEDENT DEDENT print ( \" Index ▁ of ▁ Fibonacci ▁ numbers \" , \" divisible ▁ by ▁ 2 ▁ are ▁ : \" ) ; NEW_LINE for i in range ( c1 ) : NEW_LINE INDENT print ( index1 [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( \" \" ) ; NEW_LINE print ( \" Index ▁ of ▁ Fibonacci ▁ number \" , \" divisible ▁ by ▁ 3 ▁ are ▁ : \" ) ; NEW_LINE for i in range ( c2 ) : NEW_LINE INDENT print ( index2 [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( \" \" ) ; NEW_LINE print ( \" Index ▁ of ▁ Fibonacci ▁ number \" , \" divisible ▁ by ▁ 5 ▁ are ▁ : \" ) ; NEW_LINE for i in range ( c3 ) : NEW_LINE INDENT print ( index3 [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( \" \" ) ; NEW_LINE print ( \" Index ▁ of ▁ Fibonacci ▁ number \" , \" divisible ▁ by ▁ 8 ▁ are ▁ : \" ) ; NEW_LINE for i in range ( c4 ) : NEW_LINE INDENT print ( index4 [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( \" \" ) ; NEW_LINE"],"bleu":0.47722841376999436,"rouge_l":0.7018416555914182}
{"id":1197,"predictions":["def check ( s ) : NEW_LINE INDENT freq = [ 0 for i in range ( 26 ) ] NEW_LINE n = len ( s ) NEW_LINE for i in range ( 0 , len ( s ) , 1 ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - 97 ] += 1 NEW_LINE DEDENT for i in range ( 0 , len ( freq ) , 1 ) : NEW_LINE INDENT if ( freq [ i ] & 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT s = \" abaccaba \" NEW_LINE if ( check ( s ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def check ( s ) : NEW_LINE INDENT freq = [ 0 ] * 26 NEW_LINE n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - 97 ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( freq [ i ] % 2 == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT s = \" abaccaba \" NEW_LINE if ( check ( s ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.7833107663024733,"rouge_l":0.8882329791420701}
{"id":1198,"predictions":["class pair : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . min = 0 NEW_LINE self . max = 0 NEW_LINE DEDENT DEDENT def getMinMax ( arr , low , high ) : NEW_LINE INDENT minmax = pair ( ) NEW_LINE msl = pair ( ) NEW_LINE mmr = pair ( pair : NEW_LINE INDENT if ( low == high ) : NEW_LINE INDENT minmax . max = arr [ low ] NEW_LINE minmax . min = arr [ low ] NEW_LINE return minm NEW_LINE DEDENT if ( high == low + 1 ) : NEW_LINE INDENT if ( arr [ low ] > arr [ high ] ) : NEW_LINE INDENT minmax . max = arr [ low ] NEW_LINE minmax . min = arr [ high ] NEW_LINE minmax . min = arr [ high ] NEW_LINE DEDENT else : NEW_LINE INDENT minmax . min = arr [ high ] NEW_LINE minmax . min = arr [ low ] NEW_LINE minmax . min = arr [ low ] NEW_LINE DEDENT return minmax NEW_LINE DEDENT mid = ( low + high ) \/\/ 2 NEW_LINE mshell = getMinMax ( arr , low , mid ) NEW_LINE mmr = getMinMax ( arr , mid + 1 , high ) NEW_LINE if ( m ml . min < mmr . min ) : NEW_LINE INDENT minmax . max = mcl . min NEW_LINE DEDENT else : NEW_LINE INDENT minmax . max = mm NEW_LINE DEDENT return minmax NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1000 , 11 , 445 , 1 , 330 , 3000 ] NEW_LINE arr_size = 6 NEW_LINE minmax = getMinMax ( arr , 0 , arr_size - 1 ) NEW_LINE print ( \" Minimum ▁ element ▁ is \" , max ) NEW_LINE print ( \" Minimum ▁ element ▁ is \" , minmax . value ( arr , 0 , arr_size - 1 ) NEW_LINE print ( \" Minimum ▁ element ▁ is \" , minmax . value - 1 ) NEW_"],"references":["def getMinMax ( low , high , arr ) : NEW_LINE INDENT arr_max = arr [ low ] NEW_LINE arr_min = arr [ low ] NEW_LINE if low == high : NEW_LINE INDENT arr_max = arr [ low ] NEW_LINE arr_min = arr [ low ] NEW_LINE return ( arr_max , arr_min ) NEW_LINE DEDENT elif high == low + 1 : NEW_LINE INDENT if arr [ low ] > arr [ high ] : NEW_LINE INDENT arr_max = arr [ low ] NEW_LINE arr_min = arr [ high ] NEW_LINE DEDENT else : NEW_LINE INDENT arr_max = arr [ high ] NEW_LINE arr_min = arr [ low ] NEW_LINE DEDENT return ( arr_max , arr_min ) NEW_LINE DEDENT else : NEW_LINE INDENT mid = int ( ( low + high ) \/ 2 ) NEW_LINE arr_max1 , arr_min1 = getMinMax ( low , mid , arr ) NEW_LINE arr_max2 , arr_min2 = getMinMax ( mid + 1 , high , arr ) NEW_LINE DEDENT return ( max ( arr_max1 , arr_max2 ) , min ( arr_min1 , arr_min2 ) ) NEW_LINE DEDENT arr = [ 1000 , 11 , 445 , 1 , 330 , 3000 ] NEW_LINE high = len ( arr ) - 1 NEW_LINE low = 0 NEW_LINE arr_max , arr_min = getMinMax ( low , high , arr ) NEW_LINE print ( ' Minimum ▁ element ▁ is ▁ ' , arr_min ) NEW_LINE print ( ' nMaximum ▁ element ▁ is ▁ ' , arr_max ) NEW_LINE"],"bleu":0.33283294575517064,"rouge_l":0.5662360901414751}
{"id":1199,"predictions":["def countUnvisited ( n , m ) : NEW_LINE INDENT X = ( m * n ) - m - n NEW_LINE queue = [ ] NEW_LINE queue . append ( X ) NEW_LINE count = 0 NEW_LINE while ( len ( queue ) > 0 ) : NEW_LINE INDENT curr = queue [ 0 ] NEW_LINE count += 1 NEW_LINE if ( curr - m > 0 ) : NEW_LINE INDENT queue . append ( curr - m ) NEW_LINE DEDENT if ( curr - n > 0 ) : NEW_LINE INDENT queue . append ( curr - n ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 2 NEW_LINE m = 5 NEW_LINE print ( countUnvisited ( n , m ) ) NEW_LINE DEDENT"],"references":["def countUnvisited ( n , m ) : NEW_LINE INDENT i = 0 NEW_LINE X = ( m * n ) - m - n NEW_LINE queue = [ ] NEW_LINE queue . append ( X ) NEW_LINE count = 0 NEW_LINE while ( len ( queue ) > 0 ) : NEW_LINE INDENT curr = queue [ 0 ] NEW_LINE queue . remove ( queue [ 0 ] ) NEW_LINE count += 1 NEW_LINE if ( curr - m > 0 ) : NEW_LINE INDENT queue . append ( curr - m ) NEW_LINE DEDENT if ( curr - n > 0 ) : NEW_LINE INDENT queue . append ( curr - n ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 2 NEW_LINE m = 5 NEW_LINE print ( countUnvisited ( n , m ) ) NEW_LINE DEDENT"],"bleu":0.8900541072400091,"rouge_l":0.9442724458204335}
{"id":1200,"predictions":["def uppercaseAlphabets ( ) : NEW_LINE INDENT for c in range ( 65 , 90 + 1 ) : NEW_LINE INDENT print ( ch , end = \" ▁ \" ) NEW_LINE DEDENT print ( \" Uppercase ▁ Alphabets \" ) NEW_LINE DEDENT def uppercaseAlphabets ( ) : NEW_LINE INDENT for c in range ( 90 , 18 ) : NEW_LINE INDENT print ( chr ( c ) , end = \" \" ) NEW_LINE DEDENT print ( \" Uppercase ▁ Alphabets \" ) NEW_LINE"],"references":["def lowercaseAlphabets ( ) : NEW_LINE INDENT for c in range ( 97 , 123 ) : NEW_LINE INDENT print ( chr ( c ) , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( \" \" ) ; NEW_LINE DEDENT def uppercaseAlphabets ( ) : NEW_LINE INDENT for c in range ( 65 , 91 ) : NEW_LINE INDENT print ( chr ( c ) , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( \" \" ) ; NEW_LINE DEDENT print ( \" Uppercase ▁ Alphabets \" ) ; NEW_LINE uppercaseAlphabets ( ) ; NEW_LINE print ( \" Lowercase ▁ Alphabets ▁ \" ) ; NEW_LINE lowercaseAlphabets ( ) ; NEW_LINE"],"bleu":0.5010565097072753,"rouge_l":0.7123244437430962}
{"id":1201,"predictions":["from math import gcd as __gcd NEW_LINE def countNums ( a , b , c , d ) : NEW_LINE INDENT x = b \/\/ c - ( a - 1 ) \/\/ c ; NEW_LINE y = b \/\/ d - ( a - 1 ) \/\/ d ; NEW_LINE k = ( c * d ) \/\/ gcd ( c , d ) ; NEW_LINE z = b \/\/ k - ( a - 1 ) \/\/ k ; NEW_LINE return b - a + 1 - x - y + z ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 10 ; b = 50 ; c = 4 ; NEW_LINE d = 6 ; NEW_LINE print ( countNums ( a , b , c , d ) ) ; NEW_LINE DEDENT"],"references":["from math import gcd NEW_LINE def countNums ( a , b , c , d ) : NEW_LINE INDENT x = b \/\/ c - ( a - 1 ) \/\/ c ; NEW_LINE y = b \/\/ d - ( a - 1 ) \/\/ d ; NEW_LINE k = ( c * d ) \/\/ gcd ( c , d ) ; NEW_LINE z = b \/\/ k - ( a - 1 ) \/\/ k ; NEW_LINE return ( b - a + 1 - x - y + z ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 10 ; b = 50 ; c = 4 ; d = 6 ; NEW_LINE print ( countNums ( a , b , c , d ) ) ; NEW_LINE DEDENT"],"bleu":0.9365003022574326,"rouge_l":0.983196159122085}
{"id":1202,"predictions":["def countSubarrays ( arr , n , k ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if ( sum + arr [ j ] < k ) : NEW_LINE INDENT sum = arr [ j ] + sum ; NEW_LINE count += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT array = [ 1 , 11 , 2 , 3 , 15 ] ; NEW_LINE k = 10 ; NEW_LINE size = len ( array ) ; NEW_LINE count = countSubarr ( array , size , k ) ; NEW_LINE print ( count ) ; NEW_LINE DEDENT"],"references":["def countSubarray ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if ( sum + arr [ j ] < k ) : NEW_LINE INDENT sum = arr [ j ] + sum NEW_LINE count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT array = [ 1 , 11 , 2 , 3 , 15 ] NEW_LINE k = 10 NEW_LINE size = len ( array ) NEW_LINE count = countSubarray ( array , size , k ) ; NEW_LINE print ( count ) NEW_LINE"],"bleu":0.72203540508345,"rouge_l":0.9111004899032141}
{"id":1203,"predictions":["def printPattern ( n ) : NEW_LINE INDENT if ( n == 0 or n < 0 ) : NEW_LINE INDENT print ( n , end = \" ▁ \" ) NEW_LINE return NEW_LINE DEDENT print ( n , end = \" ▁ \" ) NEW_LINE printPattern ( n - 5 ) NEW_LINE"],"references":["def printPattern ( n ) : NEW_LINE INDENT if ( n == 0 or n < 0 ) : NEW_LINE INDENT print ( n , end = \" , ▁ \" ) NEW_LINE return NEW_LINE DEDENT print ( n , end = \" , ▁ \" ) NEW_LINE printPattern ( n - 5 ) NEW_LINE print ( n , end = \" , ▁ \" ) NEW_LINE DEDENT n = 16 NEW_LINE printPattern ( n ) NEW_LINE"],"bleu":0.5982490013125399,"rouge_l":0.7891139858433}
{"id":1204,"predictions":["MAX = 100 NEW_LINE def countCommon ( mat , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT mat = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE print ( countCommon ( mat , 3 ) ) NEW_LINE"],"references":["Max = 100 NEW_LINE def countCommon ( mat , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] : NEW_LINE INDENT res = res + 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT mat = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE print ( countCommon ( mat , 3 ) ) NEW_LINE"],"bleu":0.9449772875065613,"rouge_l":0.9682539682539683}
{"id":1205,"predictions":["import sys NEW_LINE def getMinimumOp ( ar ) : NEW_LINE INDENT n = len ( ar ) NEW_LINE small = min ( ar ) NEW_LINE big = max ( ar ) NEW_LINE dp = [ [ 0 for i in range ( large + 1 ) ] for j in range ( n ) ] NEW_LINE for i in range ( small , large + 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = abs ( ar [ 0 ] - j ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT minimum = 10 ** 9 NEW_LINE for j in range ( large , large + 1 ) : NEW_LINE INDENT minimum = min ( minimum , dp [ i - 1 ] [ j ] ) NEW_LINE dp [ i ] [ j ] = minimum + abs ( ar [ i ] - j ) NEW_LINE DEDENT DEDENT ans = sys . maxsize NEW_LINE for j in range ( small , large + 1 ) : NEW_LINE INDENT ans = min ( ans , dp [ n - 1 ] [ j ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 1 , 4 , 3 ] NEW_LINE ar = [ ] NEW_LINE print ( getMinimumOp ( ar ) ) NEW_LINE DEDENT"],"references":["def getMinimumOps ( ar ) : NEW_LINE INDENT n = len ( ar ) NEW_LINE small = min ( ar ) NEW_LINE large = max ( ar ) NEW_LINE dp = [ [ 0 for i in range ( large + 1 ) ] for i in range ( n ) ] NEW_LINE for j in range ( small , large + 1 ) : NEW_LINE INDENT dp [ 0 ] [ j ] = abs ( ar [ 0 ] - j ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT minimum = 10 ** 9 NEW_LINE for j in range ( small , large + 1 ) : NEW_LINE INDENT minimum = min ( minimum , dp [ i - 1 ] [ j ] ) NEW_LINE dp [ i ] [ j ] = minimum + abs ( ar [ i ] - j ) NEW_LINE DEDENT DEDENT ans = 10 ** 9 NEW_LINE for j in range ( small , large + 1 ) : NEW_LINE INDENT ans = min ( ans , dp [ n - 1 ] [ j ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT ar = [ 1 , 2 , 1 , 4 , 3 ] NEW_LINE print ( getMinimumOps ( ar ) ) NEW_LINE"],"bleu":0.8276830959418101,"rouge_l":0.9129784049604447}
{"id":1206,"predictions":["def find ( s1 , s2 ) : NEW_LINE INDENT l = len ( s1 ) NEW_LINE len_1 = len ( s2 ) NEW_LINE if ( l != l ) : NEW_LINE INDENT return False NEW_LINE DEDENT d = [ 0 ] * l NEW_LINE d [ 0 ] = s2 [ 0 ] - s1 [ 0 ] NEW_LINE for i in range ( 1 , l ) : NEW_LINE INDENT if ( s1 [ i ] > s2 [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT d [ i ] = s2 [ i ] - s1 [ i ] NEW_LINE DEDENT DEDENT for i in range ( l - 1 ) : NEW_LINE INDENT if ( d [ i ] < d [ i + 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT s1 = \" abcd \" NEW_LINE s2 = \" bcdd \" NEW_LINE if ( find ( s1 , s2 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def find ( s1 , s2 ) : NEW_LINE INDENT len__ = len ( s1 ) NEW_LINE len_1 = len ( s2 ) NEW_LINE if ( len__ != len_1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT d = [ 0 for i in range ( len__ ) ] NEW_LINE d [ 0 ] = ord ( s2 [ 0 ] ) - ord ( s1 [ 0 ] ) NEW_LINE for i in range ( 1 , len__ , 1 ) : NEW_LINE INDENT if ( s1 [ i ] > s2 [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT d [ i ] = ord ( s2 [ i ] ) - ord ( s1 [ i ] ) NEW_LINE DEDENT DEDENT for i in range ( len__ - 1 ) : NEW_LINE INDENT if ( d [ i ] < d [ i + 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s1 = \" abcd \" NEW_LINE s2 = \" bcdd \" NEW_LINE if ( find ( s1 , s2 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.7192490418875513,"rouge_l":0.8759791122715405}
{"id":1207,"predictions":["def solveQuery ( start , end , arr ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT if arr [ i ] in mp : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT count = 0 NEW_LINE for key , value in mp . items ( ) : NEW_LINE INDENT if value == value : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 1 , 2 , 2 , 3 , 3 ] NEW_LINE n = len ( A ) NEW_LINE queries = [ [ 0 , 1 ] , [ 0 , 1 , 1 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 3 , 5 ] , [ 0 , 5 ] ] NEW_LINE q = len ( queries ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT start = queries [ i ] [ 0 ] NEW_LINE end = queries [ i ] [ 1 ] NEW_LINE print ( \" Answer ▁ for ▁ Query \" , i + 1 , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT"],"references":["import math as mt NEW_LINE def solveQuery ( start , end , arr ) : NEW_LINE INDENT frequency = dict ( ) NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT if arr [ i ] in frequency . keys ( ) : NEW_LINE INDENT frequency [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT frequency [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for x in frequency : NEW_LINE INDENT if x == frequency [ x ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT A = [ 1 , 2 , 2 , 3 , 3 , 3 ] NEW_LINE n = len ( A ) NEW_LINE queries = [ [ 0 , 1 ] , [ 1 , 1 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 3 , 5 ] , [ 0 , 5 ] ] NEW_LINE q = len ( queries ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT start = queries [ i ] [ 0 ] NEW_LINE end = queries [ i ] [ 1 ] NEW_LINE print ( \" Answer ▁ for ▁ Query ▁ \" , ( i + 1 ) , \" ▁ = ▁ \" , solveQuery ( start , end , A ) ) NEW_LINE DEDENT"],"bleu":0.7646685481194054,"rouge_l":0.8507960266702954}
{"id":1208,"predictions":["def solve ( N , K ) : NEW_LINE INDENT printf = [ 0 ] * 50 NEW_LINE indexes [ 0 ] = 1 NEW_LINE for i in range ( 1 , K + 1 ) : NEW_LINE INDENT for j in range ( N + 1 ) : NEW_LINE INDENT if ( j >= i ) : NEW_LINE INDENT LF [ j ] +=PF [ j - i ] NEW_LINE DEDENT DEDENT DEDENT return 10000 [ N ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N , K = 29 , 5 NEW_LINE print ( solve ( N , K ) ) NEW_LINE solve ( N , K ) NEW_LINE DEDENT"],"references":["def solve ( N , K ) : NEW_LINE INDENT combo = [ 0 ] * ( N + 1 ) NEW_LINE combo [ 0 ] = 1 NEW_LINE for i in range ( 1 , K + 1 ) : NEW_LINE INDENT for j in range ( 0 , N + 1 ) : NEW_LINE INDENT if j >= i : NEW_LINE INDENT combo [ j ] += combo [ j - i ] NEW_LINE DEDENT DEDENT DEDENT return combo [ N ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N , K = 29 , 5 NEW_LINE print ( solve ( N , K ) ) NEW_LINE DEDENT"],"bleu":0.7311676685352745,"rouge_l":0.8668598233995584}
{"id":1209,"predictions":[" deno = [ 1 , 2 , 5 , 10 , 20 , 50 , 100 , 500 ] NEW_LINE n = len ( deno ) NEW_LINE def findMin ( V ) : NEW_LINE INDENT ans = [ ] NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT while ( V >= deno [ i ] ) : NEW_LINE INDENT V -= deno [ i ] NEW_LINE ans . append ( deno [ i ] ) NEW_LINE DEDENT DEDENT for i in range ( len ( ans ) ) : NEW_LINE INDENT print ( \" { } ▁ \" . format ( ans [ i ] ) , end = \" \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 9 NEW_LINE print ( \" Following ▁ is ▁ minimal ▁ number ▁ of ▁ change ▁ number ▁ of ▁ change ▁ for ▁ \" , n , \" : ▁ \" , end = \" \" ) NEW_LINE findMin ( n ) NEW_LINE DEDENT"],"references":["def findMin ( V ) : NEW_LINE INDENT deno = [ 1 , 2 , 5 , 10 , 20 , 50 , 100 , 500 , 1000 ] NEW_LINE n = len ( deno ) NEW_LINE ans = [ ] NEW_LINE i = n - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT while ( V >= deno [ i ] ) : NEW_LINE INDENT V -= deno [ i ] NEW_LINE ans . append ( deno [ i ] ) NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT for i in range ( len ( ans ) ) : NEW_LINE INDENT print ( ans [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 93 NEW_LINE print ( \" Following ▁ is ▁ minimal ▁ number \" , \" of ▁ change ▁ for \" , n , \" : ▁ \" , end = \" \" ) NEW_LINE findMin ( n ) NEW_LINE DEDENT"],"bleu":0.7586580260466091,"rouge_l":0.831918352601156}
{"id":1210,"predictions":["def checkPalindrome ( num ) : NEW_LINE INDENT str = str ( num ) NEW_LINE l = 0 NEW_LINE r = len ( str ) - 1 NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( str [ l ] != str [ r ] ) : NEW_LINE INDENT print ( \" No \" ) NEW_LINE return NEW_LINE DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT print ( \" Yes \" ) NEW_LINE return NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 19 NEW_LINE k = 3 NEW_LINE checkPalindrome ( n + k ) NEW_LINE DEDENT"],"references":["def checkPalindrome ( num ) : NEW_LINE INDENT string = str ( num ) NEW_LINE l = 0 NEW_LINE r = len ( string ) - 1 ; NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( string [ l ] != string [ r ] ) : NEW_LINE INDENT print ( \" No \" ) NEW_LINE return ; NEW_LINE DEDENT l = l + 1 ; NEW_LINE r = r - 1 ; NEW_LINE DEDENT print ( \" Yes \" ) NEW_LINE return ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 19 NEW_LINE k = 3 NEW_LINE checkPalindrome ( n + k ) ; NEW_LINE DEDENT"],"bleu":0.7224800586940887,"rouge_l":0.8973125884016975}
{"id":1211,"predictions":["def updateArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n - 2 ) : NEW_LINE INDENT arr [ i ] = arr [ i + 1 ] NEW_LINE DEDENT arr [ n - 1 ] = - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 1 , 3 , 2 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE updateArray ( arr , N ) NEW_LINE DEDENT"],"references":["def updateArray ( arr , n ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT arr [ i ] = arr [ i + 1 ] NEW_LINE DEDENT arr [ n - 1 ] = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 5 , 1 , 3 , 2 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE updateArray ( arr , N ) NEW_LINE DEDENT"],"bleu":0.8760177517339062,"rouge_l":0.9595309595309596}
{"id":1212,"predictions":["import sys NEW_LINE def maxProduct ( arr , n ) : NEW_LINE INDENT if ( n < 3 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT max_product = - 2147483647 NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT max_product = max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] ) NEW_LINE DEDENT DEDENT DEDENT return max_product NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 10 , 3 , 5 , 6 , 20 ] NEW_LINE n = len ( arr ) NEW_LINE max = maxProduct ( arr , n ) NEW_LINE if ( max == - 1 ) : NEW_LINE INDENT print ( \" No ▁ Triplet ▁ exists \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Maximum ▁ product ▁ is \" , max ) NEW_LINE DEDENT DEDENT"],"references":["import sys NEW_LINE def maxProduct ( arr , n ) : NEW_LINE INDENT if n < 3 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT max_product = - ( sys . maxsize - 1 ) NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT max_product = max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] ) NEW_LINE DEDENT DEDENT DEDENT return max_product NEW_LINE DEDENT arr = [ 10 , 3 , 5 , 6 , 20 ] NEW_LINE n = len ( arr ) NEW_LINE max = maxProduct ( arr , n ) NEW_LINE if max == - 1 : NEW_LINE INDENT print ( \" No ▁ Tripplet ▁ Exits \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Maximum ▁ product ▁ is \" , max ) NEW_LINE DEDENT"],"bleu":0.8325594642813284,"rouge_l":0.923492835901595}
{"id":1213,"predictions":["def count ( S , X ) : NEW_LINE INDENT count = 0 ; NEW_LINE N = len ( S ) ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( S [ i ] != 0 ) : NEW_LINE INDENT for j in range ( 1 , N ) : NEW_LINE INDENT num = int ( S [ i : i + l ] ) ; NEW_LINE if ( num > X ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT S = \"2222\" ; NEW_LINE X = 97 ; NEW_LINE print ( count ( S , X ) ) ; NEW_LINE"],"references":["def countSubStr ( S , X ) : NEW_LINE INDENT cnt = 0 NEW_LINE N = len ( S ) NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( S [ i ] != '0' ) : NEW_LINE INDENT j = 1 NEW_LINE while ( ( j + i ) <= N ) : NEW_LINE INDENT num = int ( S [ i : i + j ] ) NEW_LINE if ( num > X ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE DEDENT j = j + 1 NEW_LINE DEDENT DEDENT DEDENT return cnt ; NEW_LINE DEDENT S = \"2222\" ; NEW_LINE X = 97 ; NEW_LINE print ( countSubStr ( S , X ) ) NEW_LINE"],"bleu":0.6115261225187653,"rouge_l":0.8039268423883809}
{"id":1214,"predictions":["import math ; NEW_LINE def printPattern ( radius ) : NEW_LINE INDENT for i in range ( 0 , 2 * radius ) : NEW_LINE INDENT for j in range ( 0 , 2 * radius ) : NEW_LINE INDENT dist = math . sqrt ( ( i - radius ) * ( i - radius ) + ( j - radius ) * ( j - radius ) ) ; NEW_LINE if ( dist > radius - 0.5 and dist < radius + 0.5 ) : NEW_LINE INDENT print ( \" * \" , end = \" \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" ▁ \" , end = \" \" ) ; NEW_LINE DEDENT DEDENT print ( ) ; NEW_LINE DEDENT DEDENT radius = 6 ; NEW_LINE printPattern ( radius ) ; NEW_LINE"],"references":["import math NEW_LINE def printPattern ( radius ) : NEW_LINE INDENT for i in range ( ( 2 * radius ) + 1 ) : NEW_LINE INDENT for j in range ( ( 2 * radius ) + 1 ) : NEW_LINE INDENT dist = math . sqrt ( ( i - radius ) * ( i - radius ) + ( j - radius ) * ( j - radius ) ) NEW_LINE if ( dist > radius - 0.5 and dist < radius + 0.5 ) : NEW_LINE INDENT print ( \" * \" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" ▁ \" , end = \" \" ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT radius = 6 NEW_LINE printPattern ( radius ) NEW_LINE"],"bleu":0.8165566386118691,"rouge_l":0.9332305502846301}
{"id":1215,"predictions":["def findSum ( arr , N ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] in mp . keys ( ) ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT s = sorted ( list ( mp . items ( ) ) ) NEW_LINE N = len ( s ) NEW_LINE print ( findSum ( arr , N ) ) NEW_LINE"],"references":["import collections NEW_LINE def findsum ( arr , N ) : NEW_LINE INDENT mp = collections . defaultdict ( int ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT sum = 0 NEW_LINE for i in mp : NEW_LINE INDENT if ( mp [ i ] % 2 != 0 ) : NEW_LINE INDENT sum += ( i * mp [ i ] ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT arr = [ 10 , 20 , 20 , 10 , 40 , 40 , 10 ] NEW_LINE N = len ( arr ) NEW_LINE print ( findsum ( arr , N ) ) NEW_LINE"],"bleu":0.4573053809047433,"rouge_l":0.5724340175953079}
{"id":1216,"predictions":["def findFrequencyUtil ( arr , low , high , freq ) : NEW_LINE INDENT if ( arr [ low ] == arr [ high ] ) : NEW_LINE INDENT freq [ arr [ low ] ] += high - low + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT mid = ( low + high ) \/\/ 2 ; NEW_LINE findFrequencyUtil ( arr , low , mid , freq ) ; NEW_LINE findFrequencyUtil ( arr , mid + 1 , freq ) ; NEW_LINE DEDENT DEDENT def findFrequency ( arr , n ) : NEW_LINE INDENT freq = [ 0 ] * ( arr [ 0 ] + 1 ) ; NEW_LINE findFrequencyUtil ( arr , 0 , n - 1 , freq ) ; NEW_LINE for i in range ( arr [ n - 1 ] + 1 ) : NEW_LINE INDENT if ( freq [ i ] != 0 ) : NEW_LINE INDENT print ( \" Element \" , i , \" occurred \" , freq [ i ] , \" times \" , freq [ i ] , \" times \" ) ; NEW_LINE DEDENT DEDENT arr = [ 1 , 1 , 1 , 2 , 3 , 5 , 8 , 8 , 9 , 10 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE findFrequency ( arr , n ) ; NEW_LINE"],"references":["def findFrequencyUtil ( arr , low , high , freq ) : NEW_LINE INDENT if ( arr [ low ] == arr [ high ] ) : NEW_LINE INDENT freq [ arr [ low ] ] += high - low + 1 NEW_LINE DEDENT else : NEW_LINE INDENT mid = int ( ( low + high ) \/ 2 ) NEW_LINE findFrequencyUtil ( arr , low , mid , freq ) NEW_LINE findFrequencyUtil ( arr , mid + 1 , high , freq ) NEW_LINE DEDENT DEDENT def findFrequency ( arr , n ) : NEW_LINE INDENT freq = [ 0 for i in range ( n - 1 + 1 ) ] NEW_LINE findFrequencyUtil ( arr , 0 , n - 1 , freq ) NEW_LINE for i in range ( 0 , arr [ n - 1 ] + 1 , 1 ) : NEW_LINE INDENT if ( freq [ i ] != 0 ) : NEW_LINE INDENT print ( \" Element \" , i , \" occurs \" , freq [ i ] , \" times \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 1 , 1 , 2 , 3 , 3 , 5 , 5 , 8 , 8 , 8 , 9 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE findFrequency ( arr , n ) NEW_LINE DEDENT"],"bleu":0.7256819003730144,"rouge_l":0.8498970487302678}
{"id":1217,"predictions":["def sumOfSeries ( num ) : NEW_LINE INDENT res = 0 NEW_LINE fact = 1 NEW_LINE for i in range ( 1 , num + 1 ) : NEW_LINE INDENT fact = fact * i NEW_LINE res = res + ( i \/ fact ) NEW_LINE DEDENT return int ( res ) NEW_LINE DEDENT n = 5 NEW_LINE print ( \" Sum : ▁ \" , sumOfSeries ( n ) ) NEW_LINE"],"references":["def sumOfSeries ( num ) : NEW_LINE INDENT res = 0 NEW_LINE fact = 1 NEW_LINE for i in range ( 1 , num + 1 ) : NEW_LINE INDENT fact *= i NEW_LINE res = res + ( i \/ fact ) NEW_LINE DEDENT return res NEW_LINE DEDENT n = 5 NEW_LINE print ( \" Sum : ▁ \" , sumOfSeries ( n ) ) NEW_LINE"],"bleu":0.8621988281115842,"rouge_l":0.9558404558404557}
{"id":1218,"predictions":["def calcSum ( arr , n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT print ( sum , end = \" ▁ \" ) NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT sum = ( sum - arr [ i - k ] ) + arr [ i ] NEW_LINE print ( sum , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE calcSum ( arr , n , k ) NEW_LINE"],"references":["def calcSum ( arr , n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT print ( sum , end = \" ▁ \" ) NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT sum = ( sum - arr [ i - k ] ) + arr [ i ] NEW_LINE print ( sum , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE calcSum ( arr , n , k ) NEW_LINE DEDENT"],"bleu":0.8822759806271514,"rouge_l":0.9375309866137829}
{"id":1219,"predictions":["def minChanges ( A , n ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT if ( ( i - 1 >= 0 ) and A [ i - 1 ] == 1 and A [ i + 1 ] == 1 and A [ i ] == 0 ) : NEW_LINE INDENT A [ i + 1 ] = 0 ; NEW_LINE cnt += 1 ; NEW_LINE DEDENT DEDENT return cnt ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 1 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ] ; NEW_LINE n = len ( A ) ; NEW_LINE print ( minChanges ( A , n ) ) ; NEW_LINE DEDENT"],"references":["def minChanges ( A , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT if ( ( i - 1 >= 0 ) and A [ i - 1 ] == 1 and A [ i + 1 ] == 1 and A [ i ] == 0 ) : NEW_LINE INDENT A [ i + 1 ] = 0 NEW_LINE cnt = cnt + 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT A = [ 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 0 ] NEW_LINE n = len ( A ) NEW_LINE print ( minChanges ( A , n ) ) NEW_LINE"],"bleu":0.7623559960362806,"rouge_l":0.9099987671063987}
{"id":1220,"predictions":["def calcNodes ( N , I ) : NEW_LINE INDENT result = 0 ; NEW_LINE result = V * ( N - 1 ) + 1 ; NEW_LINE return result ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 5 ; I = 2 ; NEW_LINE print ( \" Leaf ▁ nodes ▁ = \" , calcNodes ( N , I ) ) ; NEW_LINE DEDENT"],"references":["def calcNodes ( N , I ) : NEW_LINE INDENT result = 0 NEW_LINE result = I * ( N - 1 ) + 1 NEW_LINE return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 NEW_LINE I = 2 NEW_LINE print ( \" Leaf ▁ nodes ▁ = ▁ \" , calcNodes ( N , I ) ) NEW_LINE DEDENT"],"bleu":0.661878826263526,"rouge_l":0.908598510494245}
{"id":1221,"predictions":["def countSum ( arr , n ) : NEW_LINE INDENT NumberOfOdds = 0 NEW_LINE NumberOfEvens = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] % 2 ) : NEW_LINE INDENT NumberOfOdds += 1 NEW_LINE DEDENT DEDENT NumberOfEvens = n - NumberOfOdds NEW_LINE NumberOfOddsSubsequences = ( 1 << NumberOfEvens ) * ( 1 << ( NumberOfOdds - 1 ) ) NEW_LINE NumberOfEvenSubsequences = ( 1 << ( NumberOfEvenOdds - 1 ) - NumberOfOddSubsequences NEW_LINE return ( NumberOfEvenSubsequences , NumberOfOddSubsequences ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE ans = countSum ( arr , n ) NEW_LINE print ( \" EvenSum ▁ = ▁ \" , ans ) NEW_LINE print ( \" EvenSum ▁ = ▁ \" , len ( arr ) ) NEW_LINE print ( \" OddSum ▁ = ▁ \" , len ( ans ) ) NEW_LINE DEDENT"],"references":["def countSum ( arr , n ) : NEW_LINE INDENT NumberOfOdds = 0 ; NumberOfEvens = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT NumberOfOdds += 1 ; NEW_LINE DEDENT DEDENT NumberOfEvens = n - NumberOfOdds ; NEW_LINE NumberOfOddSubsequences = ( 1 << NumberOfEvens ) *   \\ NEW_LINE INDENT ( 1 << ( NumberOfOdds - 1 ) ) ; NEW_LINE DEDENT NumberOfEvenSubsequences = ( 1 << n ) - 1 -   \\ NEW_LINE INDENT NumberOfOddSubsequences ; NEW_LINE DEDENT return ( NumberOfEvenSubsequences , NumberOfOddSubsequences ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 2 , 3 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE ans = countSum ( arr , n ) ; NEW_LINE print ( \" EvenSum ▁ = \" , ans [ 0 ] , end = \" ▁ \" ) ; NEW_LINE print ( \" OddSum ▁ = \" , ans [ 1 ] ) ; NEW_LINE DEDENT"],"bleu":0.5938982876964786,"rouge_l":0.8094220322379554}
{"id":1222,"predictions":["import math NEW_LINE def findMinNumber ( n ) : NEW_LINE INDENT count = 0 NEW_LINE ans = 1 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE n \/\/= 2 NEW_LINE DEDENT if ( count % 3 != 0 ) : NEW_LINE INDENT ans *= pow ( 2 , ( count % 3 ) ) NEW_LINE DEDENT for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE n \/\/= i NEW_LINE DEDENT if ( count % 3 != 0 ) : NEW_LINE INDENT ans *= pow ( i , ( count % 3 ) ) NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT ans *= n NEW_LINE DEDENT return ans NEW_LINE DEDENT n = 128 NEW_LINE print ( findMinNumber ( n ) ) NEW_LINE"],"references":["def findMinNumber ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE ans = 1 ; NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE n \/= 2 ; NEW_LINE DEDENT if ( count % 3 != 0 ) : NEW_LINE INDENT ans *= pow ( 2 , ( count % 3 ) ) ; NEW_LINE DEDENT for i in range ( 3 , int ( pow ( n , 1 \/ 2 ) ) , 2 ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE n \/= i ; NEW_LINE DEDENT if ( count % 3 != 0 ) : NEW_LINE INDENT ans *= pow ( i , ( count % 3 ) ) ; NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT ans *= n ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 128 ; NEW_LINE print ( findMinNumber ( n ) ) ; NEW_LINE DEDENT"],"bleu":0.6813199294955908,"rouge_l":0.8673506119510438}
{"id":1223,"predictions":["def is_vow ( c ) : NEW_LINE INDENT return ( c == ' a ' ) or ( c == ' e ' ) or ( c == ' o ' ) or ( c == ' u ' ) or ( c == ' u ' ) or ( c == ' u ' ) ) NEW_LINE DEDENT def removeVowels ( str ) : NEW_LINE INDENT print ( ( str [ 0 ] ) ) NEW_LINE for i in range ( 1 , len ( str ) ) : NEW_LINE INDENT if ( not is_vow ( str [ i - 1 ] ) ) or ( not is_vow ( str [ i ] ) ) : NEW_LINE INDENT print ( str [ i ] ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" geeks ▁ for ▁ geeks \" NEW_LINE removeVowels ( str ) NEW_LINE DEDENT"],"references":["def is_vow ( c ) : NEW_LINE INDENT return ( ( c == ' a ' ) or ( c == ' e ' ) or ( c == ' i ' ) or ( c == ' o ' ) or ( c == ' u ' ) ) ; NEW_LINE DEDENT def removeVowels ( str ) : NEW_LINE INDENT print ( str [ 0 ] , end = \" \" ) ; NEW_LINE for i in range ( 1 , len ( str ) ) : NEW_LINE INDENT if ( ( is_vow ( str [ i - 1 ] ) != True ) or ( is_vow ( str [ i ] ) != True ) ) : NEW_LINE INDENT print ( str [ i ] , end = \" \" ) ; NEW_LINE DEDENT DEDENT DEDENT str = \" ▁ geeks ▁ for ▁ geeks \" ; NEW_LINE removeVowels ( str ) ; NEW_LINE"],"bleu":0.7050489170720098,"rouge_l":0.8331769367115003}
{"id":1224,"predictions":["def areacumscribed ( a ) : NEW_LINE INDENT PI = 3.14159265 NEW_LINE return ( a * a * ( PI \/ 2 ) ) NEW_LINE DEDENT a = 6 NEW_LINE print ( \" Area ▁ of ▁ an ▁ circumscribed ▁ contributed ▁ is ▁ : \" ) NEW_LINE print ( areacircumscribed ( a ) ) NEW_LINE"],"references":["PI = 3.14159265 NEW_LINE def areacircumscribed ( a ) : NEW_LINE INDENT return ( a * a * ( PI \/ 2 ) ) NEW_LINE DEDENT a = 6 NEW_LINE print ( \" ▁ Area ▁ of ▁ an ▁ circumscribed ▁ circle ▁ is ▁ : \" , round ( areacircumscribed ( a ) , 2 ) ) NEW_LINE"],"bleu":0.7047264120239961,"rouge_l":0.8167364016736403}
{"id":1225,"predictions":["import math NEW_LINE def breakEvenPoint ( exp1 , S , M ) : NEW_LINE INDENT scan = S - M NEW_LINE exp = exp1 NEW_LINE res = int ( exp \/ earn ) NEW_LINE res1 = int ( res1 ) NEW_LINE return res1 NEW_LINE DEDENT exp = 3550 NEW_LINE S = 90 NEW_LINE M = 65 NEW_LINE print ( breakEvenPoint ( exp , S , M ) ) NEW_LINE"],"references":["import math NEW_LINE def breakEvenPoint ( exp , S , M ) : NEW_LINE INDENT earn = S - M NEW_LINE res = math . ceil ( exp \/ earn ) NEW_LINE return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT exp = 3550 NEW_LINE S = 90 NEW_LINE M = 65 NEW_LINE print ( int ( breakEvenPoint ( exp , S , M ) ) ) NEW_LINE DEDENT"],"bleu":0.579132686629439,"rouge_l":0.7324883255503669}
{"id":1226,"predictions":["MAX = 256 NEW_LINE def countPairs ( s ) : NEW_LINE INDENT cnt = [ 0 ] * MAX NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT cnt [ ord ( s [ i ] ) ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT ans += cnt [ i ] * cnt [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT s = \" geeksforgeeks \" NEW_LINE print ( countPairs ( s ) ) NEW_LINE"],"references":["MAX = 256 NEW_LINE def countPairs ( s ) : NEW_LINE INDENT cnt = [ 0 for i in range ( 0 , MAX ) ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT cnt [ ord ( s [ i ] ) - 97 ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 0 , MAX ) : NEW_LINE INDENT ans += cnt [ i ] * cnt [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" geeksforgeeks \" NEW_LINE print ( countPairs ( s ) ) NEW_LINE DEDENT"],"bleu":0.6913626409861153,"rouge_l":0.8430589680589681}
{"id":1227,"predictions":["import math NEW_LINE def sumOfSeries ( n ) : NEW_LINE INDENT return 0.0Re * ( pow ( 10 , n ) - 1 - ( 9 * n ) ) NEW_LINE DEDENT n = 3 NEW_LINE print ( sumOfSeries ( n ) ) NEW_LINE"],"references":["import math NEW_LINE def sumOfSeries ( n ) : NEW_LINE INDENT return 0.0246 * ( math . pow ( 10 , n ) - 1 - ( 9 * n ) ) NEW_LINE DEDENT n = 3 NEW_LINE print ( sumOfSeries ( n ) ) NEW_LINE"],"bleu":0.8709520893148885,"rouge_l":0.9517416545718432}
{"id":1228,"predictions":["def maxLenSub ( arr , n ) : NEW_LINE INDENT mls = [ 1 for i in range ( n ) ] NEW_LINE max = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 0 , i ) : NEW_LINE INDENT if abs ( arr [ i ] - arr [ j ] ) <= 1 and mls [ i ] < mls [ j ] + 1 : NEW_LINE INDENT mls [ i ] = mls [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if max < mls [ i ] : NEW_LINE INDENT max = mls [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 5 , 6 , 3 , 7 , 6 , 5 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Maximum ▁ length ▁ subsequence ▁ = ▁ \" , maxLenSub ( arr , n ) ) NEW_LINE DEDENT"],"references":["def maxLenSub ( arr , n ) : NEW_LINE INDENT mls = [ ] NEW_LINE max = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mls . append ( 1 ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( abs ( arr [ i ] - arr [ j ] ) <= 1 and mls [ i ] < mls [ j ] + 1 ) : NEW_LINE INDENT mls [ i ] = mls [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( max < mls [ i ] ) : NEW_LINE INDENT max = mls [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT arr = [ 2 , 5 , 6 , 3 , 7 , 6 , 5 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Maximum ▁ length ▁ subsequence ▁ = ▁ \" , maxLenSub ( arr , n ) ) NEW_LINE"],"bleu":0.8239739477769237,"rouge_l":0.8867353119321624}
{"id":1229,"predictions":["mod = 1000000007 NEW_LINE dp = [ [ [ - 1 for i in range ( 1000 ) ] for i in range ( 1000 ) ] for i in range ( 1000 ) ] NEW_LINE def calculate ( pos , prev , prev , s , index ) : NEW_LINE INDENT if pos == len ( s ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if dp [ pos ] [ prev ] != prev : NEW_LINE INDENT return dp [ pos ] [ prev ] NEW_LINE DEDENT answer = 0 NEW_LINE for i in range ( len ( index ) ) : NEW_LINE INDENT if index [ i ] > prev : NEW_LINE INDENT answer = ( answer % mod + calculate ( pos + 1 , index [ i ] , s , index ) % mod ) % mod ) % mod NEW_LINE DEDENT DEDENT dp [ pos ] [ prev ] = answer NEW_LINE return answer NEW_LINE DEDENT def countWays ( a , s ) : NEW_LINE INDENT n = len ( a ) NEW_LINE index = [ 0 ] * 26 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT index [ ord ( a [ i ] ) [ j ] = - 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT index [ i ] [ j ] = - 1 NEW_LINE DEDENT return calculate ( 0 , 0 , s , index [ 0 ] ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ ] NEW_LINE A . append ( \" acc \" ) NEW_LINE A . append ( \" ac \" ) NEW_LINE A . append ( \" ac \" ) NEW_LINE S = \" ac \" NEW_LINE print ( countWays ( A , S ) ) NEW_LINE S = \" ac \" NEW_LINE print ( countWays ( A , S ) ) NEW_LINE DEDENT"],"references":["mod = 1000000007 NEW_LINE dp = [ [ - 1 for i in range ( 1000 ) ] for j in range ( 1000 ) ] ; NEW_LINE def calculate ( pos , prev , s , index ) : NEW_LINE INDENT if ( pos == len ( s ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( dp [ pos ] [ prev ] != - 1 ) : NEW_LINE INDENT return dp [ pos ] [ prev ] NEW_LINE DEDENT c = ord ( s [ pos ] ) - ord ( ' a ' ) ; NEW_LINE answer = 0 NEW_LINE for i in range ( len ( index ) ) : NEW_LINE INDENT if ( index [ i ] > prev ) : NEW_LINE INDENT answer = ( answer % mod + calculate ( pos + 1 , index [ i ] , s , index ) % mod ) % mod NEW_LINE DEDENT DEDENT dp [ pos ] [ prev ] = 4 NEW_LINE return dp [ pos ] [ prev ] NEW_LINE DEDENT def countWays ( a , s ) : NEW_LINE INDENT n = len ( a ) NEW_LINE index = [ [ ] for i in range ( 26 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( len ( a [ i ] ) ) : NEW_LINE INDENT index [ ord ( a [ i ] [ j ] ) - ord ( ' a ' ) ] . append ( j + 1 ) ; NEW_LINE DEDENT DEDENT return calculate ( 0 , 0 , s , index [ 0 ] ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ ] NEW_LINE A . append ( \" adc \" ) NEW_LINE A . append ( \" aec \" ) NEW_LINE A . append ( \" erg \" ) NEW_LINE S = \" ac \" NEW_LINE print ( countWays ( A , S ) ) NEW_LINE DEDENT"],"bleu":0.7338971977077093,"rouge_l":0.8018972408147541}
{"id":1230,"predictions":["def divisibleBy36 ( num ) : NEW_LINE INDENT l = len ( num ) ; NEW_LINE if ( l == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT if ( l == 1 and num [ 0 ] != '0' ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT two_digit_num = ( ( int ( num [ l - 2 ] ) - int ( ( num [ l - 1 ] ) ) * 10 + ( int ( num [ l - 1 ] ) ) ) ; NEW_LINE if ( two_digit_num % 4 != 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT sum = 0 ; NEW_LINE for i in range ( l ) : NEW_LINE INDENT sum += ( ord ( num [ i ] ) - ord ( '0' ) ) ) ; NEW_LINE DEDENT if ( sum % 9 != 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT num = \"5851234\" ; NEW_LINE if ( divisibleBy36 ( num ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"],"references":["def divisibleBy36 ( num ) : NEW_LINE INDENT l = len ( num ) NEW_LINE if ( l == 0 ) : NEW_LINE INDENT return ( \" No \" ) NEW_LINE DEDENT if ( l == 1 and num [ 0 ] != '0' ) : NEW_LINE INDENT return ( \" No \" ) NEW_LINE DEDENT two_digit_num = ( ( ( int ) ( num [ l - 2 ] ) ) * 10 + ( int ) ( num [ l - 1 ] ) ) NEW_LINE if ( two_digit_num % 4 != 0 ) : NEW_LINE INDENT return \" No \" NEW_LINE DEDENT sm = 0 NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT sm = sm + ( int ) ( num [ i ] ) NEW_LINE DEDENT if ( sm % 9 != 0 ) : NEW_LINE INDENT return ( \" No \" ) NEW_LINE DEDENT return ( \" Yes \" ) NEW_LINE DEDENT num = \"92567812197966231384\" NEW_LINE print ( divisibleBy36 ( num ) ) NEW_LINE"],"bleu":0.5416473644042203,"rouge_l":0.7194871794871794}
{"id":1231,"predictions":["def prepareSum ( s ) : NEW_LINE INDENT sum = [ 0 ] * 1000005 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT sum [ i + 1 ] = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT sum [ i + 1 ] = sum [ i ] + int ( s [ i ] ) NEW_LINE DEDENT DEDENT def query ( l , r ) : NEW_LINE INDENT if ( ( sum [ r + 1 ] - sum [ l ] ) % 3 == 0 ) : NEW_LINE INDENT return ( \" Divisible ▁ by ▁ 3\" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ divisible ▁ by ▁ 3\" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \"1246 26646 NEW_LINE query ( 0 , 1 ) NEW_LINE query ( 0 , 1 , 2 ) NEW_LINE query ( 3 , 6 ) NEW_LINE query ( 0 , 10 ) NEW_LINE DEDENT"],"references":["sum = [ 0 for i in range ( 1000005 ) ] NEW_LINE def toInt ( x ) : NEW_LINE INDENT return int ( x ) NEW_LINE DEDENT def prepareSum ( s ) : NEW_LINE INDENT sum [ 0 ] = 0 NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT sum [ i + 1 ] = sum [ i ] + toInt ( s [ i ] ) NEW_LINE DEDENT DEDENT def query ( l , r ) : NEW_LINE INDENT if ( ( sum [ r + 1 ] - sum [ l ] ) % 3 == 0 ) : NEW_LINE INDENT print ( \" Divisible ▁ by ▁ 3\" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ divisible ▁ by ▁ 3\" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = \"12468236544\" NEW_LINE prepareSum ( n ) NEW_LINE query ( 0 , 1 ) NEW_LINE query ( 1 , 2 ) NEW_LINE query ( 3 , 6 ) NEW_LINE query ( 0 , 10 ) NEW_LINE DEDENT"],"bleu":0.8048050126770552,"rouge_l":0.8451679944579148}
{"id":1232,"predictions":["def distancesum ( arr , n ) : NEW_LINE INDENT arr . sort ( ) ; NEW_LINE res = 0 ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT res += ( arr [ i ] * i - sum ) ; NEW_LINE sum += arr [ i ] ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT def totaldist distancesum ( x , y , n ) : NEW_LINE INDENT return distancesum ( x , n ) + distancesum ( y , n ) ; NEW_LINE DEDENT x = [ - 1 , 1 , 2 ] ; NEW_LINE y = [ 5 , 6 , 5 , 3 ] ; NEW_LINE n = len ( x ) ; NEW_LINE print ( totaldist distancesum ( x , y , n ) ) ; NEW_LINE"],"references":["def distancesum ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE res = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res += ( arr [ i ] * i - sum ) NEW_LINE sum += arr [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT def totaldistancesum ( x , y , n ) : NEW_LINE INDENT return distancesum ( x , n ) + distancesum ( y , n ) NEW_LINE DEDENT x = [ - 1 , 1 , 3 , 2 ] NEW_LINE y = [ 5 , 6 , 5 , 3 ] NEW_LINE n = len ( x ) NEW_LINE print ( totaldistancesum ( x , y , n ) ) NEW_LINE"],"bleu":0.7480152215318261,"rouge_l":0.9372126784418097}
{"id":1233,"predictions":["def squareSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( 2 * i ) * ( 2 * i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT ans = squareSum ( 8 ) NEW_LINE print ( ans ) NEW_LINE"],"references":["def squareSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT sum += ( 2 * i ) * ( 2 * i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT ans = squareSum ( 8 ) NEW_LINE print ( ans ) NEW_LINE"],"bleu":0.9551190479308641,"rouge_l":0.9824561403508771}
{"id":1234,"predictions":["def findAndSum ( arr , n ) : NEW_LINE INDENT sum1 = 0 NEW_LINE mul = 1 NEW_LINE for i in range ( 30 ) : NEW_LINE INDENT count_on = False NEW_LINE l = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( arr [ j ] & ( 1 << i ) ) : NEW_LINE INDENT if ( count_on : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_on = True NEW_LINE l += 1 NEW_LINE DEDENT elif ( count_on ) : NEW_LINE INDENT sum += ( ( mul * l * ( l + 1 ) ) \/\/ 2 ) \/\/ 2 NEW_LINE count_on = False NEW_LINE l = 0 NEW_LINE DEDENT DEDENT if ( count_on ) : NEW_LINE INDENT sum += ( ( mul * l * ( l + 1 ) ) \/\/ 2 ) NEW_LINE count_on = False NEW_LINE DEDENT mul *= 2 NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 7 , 1 , 1 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findAndSum ( arr , n ) ) NEW_LINE DEDENT"],"references":["import math as mt NEW_LINE def findAndSum ( arr , n ) : NEW_LINE INDENT Sum = 0 NEW_LINE mul = 1 NEW_LINE for i in range ( 30 ) : NEW_LINE INDENT count_on = 0 NEW_LINE l = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( ( arr [ j ] & ( 1 << i ) ) > 0 ) : NEW_LINE INDENT if ( count_on ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_on = 1 NEW_LINE l += 1 NEW_LINE DEDENT DEDENT elif ( count_on ) : NEW_LINE INDENT Sum += ( ( mul * l * ( l + 1 ) ) \/\/ 2 ) NEW_LINE count_on = 0 NEW_LINE l = 0 NEW_LINE DEDENT DEDENT if ( count_on ) : NEW_LINE INDENT Sum += ( ( mul * l * ( l + 1 ) ) \/\/ 2 ) NEW_LINE count_on = 0 NEW_LINE l = 0 NEW_LINE DEDENT mul *= 2 NEW_LINE DEDENT return Sum NEW_LINE DEDENT arr = [ 7 , 1 , 1 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findAndSum ( arr , n ) ) NEW_LINE"],"bleu":0.7907106114161663,"rouge_l":0.8854759804314701}
{"id":1235,"predictions":["def isAlphabaticOrder ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE c = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT c [ i ] = s [ i ] NEW_LINE DEDENT c . sort ( reverse = False ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if c [ i ] != s [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT s = \" aabbbcc \" NEW_LINE if isAlphabaticOrder ( s ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def isAlphabaticOrder ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE c = [ s [ i ] for i in range ( len ( s ) ) ] NEW_LINE c . sort ( reverse = False ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( c [ i ] != s [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" aabbbcc \" NEW_LINE if ( isAlphabaticOrder ( s ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.7336788535962534,"rouge_l":0.8244335497548694}
{"id":1236,"predictions":["class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . prev = None NEW_LINE self . next = None NEW_LINE DEDENT DEDENT class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = head NEW_LINE DEDENT DEDENT def push ( self , new_data , new_data ) : NEW_LINE INDENT new_node = Node ( data ) NEW_LINE new_node . next = head NEW_LINE new_node . prev = None NEW_LINE if ( head != None ) : NEW_LINE INDENT self . head . prev = new_node NEW_LINE DEDENT self . head = new_node NEW_LINE DEDENT def insertAfter ( self , prev_data ) : NEW_LINE INDENT new_node = Node ( new_data ) NEW_LINE new_node . prev = None NEW_LINE if ( new_node . data != None ) : NEW_LINE INDENT new_node . prev = new_node . prev NEW_LINE self . head = new_node NEW_LINE DEDENT if ( new_node . data != None ) : NEW_LINE INDENT new_node . prev = new_node NEW_LINE new_node . prev = new_node NEW_LINE DEDENT while ( not new_node . next != None ) : NEW_LINE INDENT new_node . prev = None NEW_LINE new_node . prev = new_node NEW_LINE new_node . prev = new_node NEW_LINE new_node . next = new_node NEW_LINE new_node . next = new_node . prev = new_node NEW_LINE DEDENT if ( new_node . data != None ) : NEW_LINE INDENT new_node . prev = None NEW_LINE head = new_node NEW_LINE return NEW_LINE DEDENT DEDENT"],"references":["class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE self . prev = None NEW_LINE DEDENT DEDENT class DoublyLinkedList : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . head = None NEW_LINE DEDENT def push ( self , new_data ) : NEW_LINE INDENT new_node = Node ( new_data ) NEW_LINE new_node . next = self . head NEW_LINE if self . head is not None : NEW_LINE INDENT self . head . prev = new_node NEW_LINE DEDENT self . head = new_node NEW_LINE DEDENT def insertAfter ( self , prev_node , new_data ) : NEW_LINE INDENT if prev_node is None : NEW_LINE INDENT print \" the ▁ given ▁ previous ▁ node ▁ cannot ▁ be ▁ NULL \" NEW_LINE return NEW_LINE DEDENT new_node = Node ( new_data ) NEW_LINE new_node . next = prev_node . next NEW_LINE prev_node . next = new_node NEW_LINE new_node . prev = prev_node NEW_LINE if new_node . next is not None : NEW_LINE INDENT new_node . next . prev = new_node NEW_LINE DEDENT DEDENT def append ( self , new_data ) : NEW_LINE INDENT new_node = Node ( new_data ) NEW_LINE new_node . next = None NEW_LINE if self . head is None : NEW_LINE INDENT new_node . prev = None NEW_LINE self . head = new_node NEW_LINE return NEW_LINE DEDENT last = self . head NEW_LINE while ( last . next is not None ) : NEW_LINE INDENT last = last . next NEW_LINE DEDENT last . next = new_node NEW_LINE new_node . prev = last NEW_LINE return NEW_LINE DEDENT def printList ( self , node ) : NEW_LINE INDENT print \" \\n Traversal ▁ in ▁ forward ▁ direction \" NEW_LINE while ( node is not None ) : NEW_LINE INDENT print \" ▁ % ▁ d \" % ( node . data ) , NEW_LINE last = node NEW_LINE node = node . next NEW_LINE DEDENT print \" \\n Traversal ▁ in ▁ reverse ▁ direction \" NEW_LINE while ( last is not None ) : NEW_LINE INDENT print \" ▁ % ▁ d \" % ( last . data ) , NEW_LINE last = last . prev NEW_LINE DEDENT DEDENT DEDENT llist = DoublyLinkedList ( ) NEW_LINE llist . append ( 6 ) NEW_LINE llist . push ( 7 ) NEW_LINE llist . push ( 1 ) NEW_LINE llist . append ( 4 ) NEW_LINE llist . insertAfter ( llist . head . next , 8 ) NEW_LINE print \" Created ▁ DLL ▁ is : ▁ \" , NEW_LINE llist . printList ( llist . head ) NEW_LINE"],"bleu":0.32106566239879236,"rouge_l":0.5016403481912428}
{"id":1237,"predictions":["size = 10001 NEW_LINE prime = [ 0 ] * size NEW_LINE freq = [ 0 ] * size NEW_LINE def sieve ( a , b ) : NEW_LINE INDENT prime [ 1 ] = 1 NEW_LINE for i in range ( 2 , size , 1 ) : NEW_LINE INDENT if ( prime [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i * 2 , size , i ) : NEW_LINE INDENT prime [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT for p in range ( 1 , size , 1 ) : NEW_LINE INDENT for q in range ( 1 , size , 1 ) : NEW_LINE INDENT if ( prime [ p ] == 0 and prime [ q ] == 0 and a * p + b * q < size ) : NEW_LINE INDENT freq [ a * p + b * q ] += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT queries = 2 NEW_LINE a = 1 NEW_LINE b = 2 NEW_LINE sieve ( a , b ) NEW_LINE arr = [ 15 , 25 ] NEW_LINE for i in range ( queries ) : NEW_LINE INDENT print ( freq [ arr [ i ] ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT"],"references":["from math import sqrt NEW_LINE size = 1000 NEW_LINE prime = [ 0 for i in range ( size ) ] NEW_LINE freq = [ 0 for i in range ( size ) ] NEW_LINE def sieve ( a , b ) : NEW_LINE INDENT prime [ 1 ] = 1 NEW_LINE for i in range ( 2 , int ( sqrt ( size ) ) + 1 , 1 ) : NEW_LINE INDENT if ( prime [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i * 2 , size , i ) : NEW_LINE INDENT prime [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT for p in range ( 1 , size , 1 ) : NEW_LINE INDENT for q in range ( 1 , size , 1 ) : NEW_LINE INDENT if ( prime [ p ] == 0 and prime [ q ] == 0 and a * p + b * q < size ) : NEW_LINE INDENT freq [ a * p + b * q ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT queries = 2 NEW_LINE a = 1 NEW_LINE b = 2 NEW_LINE sieve ( a , b ) NEW_LINE arr = [ 15 , 25 ] NEW_LINE for i in range ( queries ) : NEW_LINE INDENT print ( freq [ arr [ i ] ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.8520024447049138,"rouge_l":0.9218321631561351}
{"id":1238,"predictions":["def replaceConsonants ( str ) : NEW_LINE INDENT res = \" \" ; NEW_LINE i = 0 ; count = 0 ; NEW_LINE while ( i < len ( str ) : NEW_LINE INDENT if ( str [ i ] != ' a ' and str [ i ] != ' e ' and str [ i ] != ' i ' and str [ i ] != ' o ' ) : NEW_LINE INDENT i += 1 ; NEW_LINE count += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( count > 0 ) : NEW_LINE INDENT res += count ; NEW_LINE DEDENT res += str [ i ] ; NEW_LINE i += 1 ; NEW_LINE count = 0 ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT if ( count > 0 ) : NEW_LINE INDENT res += count ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" abcdeXY \" ; NEW_LINE print ( replaceConsonants ( str ) ) ; NEW_LINE DEDENT"],"references":["def replaceConsonants ( string ) : NEW_LINE INDENT res = \" \" ; NEW_LINE i = 0 ; count = 0 ; NEW_LINE while ( i < len ( string ) ) : NEW_LINE INDENT if ( string [ i ] != ' a ' and string [ i ] != ' e ' and string [ i ] != ' i ' and string [ i ] != ' o ' and string [ i ] != ' u ' ) : NEW_LINE INDENT i += 1 ; NEW_LINE count += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( count > 0 ) : NEW_LINE INDENT res += str ( count ) ; NEW_LINE DEDENT res += string [ i ] ; NEW_LINE i += 1 NEW_LINE count = 0 ; NEW_LINE DEDENT DEDENT if ( count > 0 ) : NEW_LINE INDENT res += str ( count ) ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" abcdeiop \" ; NEW_LINE print ( replaceConsonants ( string ) ) ; NEW_LINE DEDENT"],"bleu":0.7403716211948155,"rouge_l":0.8821869488536155}
{"id":1239,"predictions":["def count ( S , m , n ) : NEW_LINE INDENT table = [ [ 0 for x in range ( m ) ] for x in range ( n + 1 ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT table [ 0 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT x = table [ 0 ] [ j ] if i - S [ j ] >= 0 : NEW_LINE INDENT x = table [ i ] [ j - S [ j ] ] if i - S [ j ] >= 0 else 0 NEW_LINE table [ i ] [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT return table [ n ] [ - 1 ] NEW_LINE DEDENT def count ( S , m , n ) : NEW_LINE INDENT table = [ [ 0 ] * ( m + 1 ) NEW_LINE table [ 0 ] = 1 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if table [ i ] [ j ] >= 0 : NEW_LINE INDENT table [ i ] [ j ] = table [ i - S [ j ] ] if table [ i ] [ j - S [ i ] [ j ] >= 0 : NEW_LINE INDENT table [ i ] [ j ] += table [ i ] [ j ] if table [ i ] [ j ] >= 0 : NEW_LINE INDENT table [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT table [ i ] [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT return table [ n ] [ 2 ] NEW_LINE DEDENT s = [ 3 , 1 ] NEW_LINE m , n = len ( s ) NEW_LINE table [ n ] [ 3 ] = 1 NEW_LINE for i in range ( m ) : NEW_LINE INDENT table [ S [ i ] = table [ [ 0 ] * m + table [ 4 ] + 1 NEW_LINE DEDENT for i in range ( 1 , m , n + 1 ) : NEW_LINE INDENT table [ i ] [ 2 ] = table"],"references":["def count ( S , m , n ) : NEW_LINE INDENT table = [ 0 for k in range ( n + 1 ) ] NEW_LINE table [ 0 ] = 1 NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT for j in range ( S [ i ] , n + 1 ) : NEW_LINE INDENT table [ j ] += table [ j - S [ i ] ] NEW_LINE DEDENT DEDENT return table [ n ] NEW_LINE DEDENT arr = [ 1 , 2 , 3 ] NEW_LINE m = len ( arr ) NEW_LINE n = 4 NEW_LINE x = count ( arr , m , n ) NEW_LINE print ( x ) NEW_LINE"],"bleu":0.20625859334771263,"rouge_l":0.4382783632133571}
{"id":1240,"predictions":["def minReplacement ( str ) : NEW_LINE INDENT if ( len ( str ) > 26 ) : NEW_LINE INDENT print ( \" IMPOSSIBLE \" ) NEW_LINE DEDENT else : NEW_LINE INDENT hash = [ 0 ] * 26 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT hash [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( hash [ ord ( str [ i ] ) - ord ( ' a ' ) ] > 1 ) : NEW_LINE INDENT for j in range ( 26 ) : NEW_LINE INDENT if ( hash [ j ] == 0 ) : NEW_LINE INDENT hash [ ord ( str [ i ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE str = str [ : i ] + chr ( j + ord ( ' a ' ) ] ) -= 1 NEW_LINE hash [ j ] = 0 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( str ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" xxxxyy \" NEW_LINE minReplacement ( str ) NEW_LINE DEDENT"],"references":["def minReplacement ( string ) : NEW_LINE INDENT if len ( string ) > 26 : NEW_LINE INDENT print ( \" IMPOSSIBLE \" ) NEW_LINE DEDENT else : NEW_LINE INDENT Hash = [ 0 ] * 26 NEW_LINE for i in range ( 0 , len ( string ) ) : NEW_LINE INDENT Hash [ ord ( string [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 0 , len ( string ) ) : NEW_LINE INDENT if Hash [ ord ( string [ i ] ) - ord ( ' a ' ) ] > 1 : NEW_LINE INDENT for j in range ( 0 , 26 ) : NEW_LINE INDENT if Hash [ j ] == 0 : NEW_LINE INDENT Hash [ ord ( string [ i ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE string [ i ] = chr ( j + ord ( ' a ' ) ) NEW_LINE Hash [ j ] += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( ' ' . join ( string ) ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" xxxxyyyy \" NEW_LINE minReplacement ( list ( string ) ) NEW_LINE DEDENT"],"bleu":0.6461840667278687,"rouge_l":0.8444732857451873}
{"id":1241,"predictions":["N = 3 NEW_LINE def findStepsForDDM ( arr ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( N ) : NEW_LINE INDENT sum += abs ( arr [ i ] [ j ] ) NEW_LINE DEDENT sum -= abs ( arr [ i ] [ i ] ) NEW_LINE if ( abs ( arr [ i ] [ i ] ) < abs ( sum ) ) : NEW_LINE INDENT result += abs ( abs ( arr [ i ] [ i ] ) - abs ( sum ) ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , - 2 , 1 ] , [ 1 , - 3 , 2 ] , [ - 1 , 2 , 4 ] ] NEW_LINE print ( findStepsForDDM ( arr ) ) NEW_LINE DEDENT"],"references":["N = 3 NEW_LINE def findStepsForDDM ( arr ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( N ) : NEW_LINE INDENT sum += abs ( arr [ i ] [ j ] ) NEW_LINE DEDENT sum -= abs ( arr [ i ] [ i ] ) NEW_LINE if ( abs ( arr [ i ] [ i ] ) < abs ( sum ) ) : NEW_LINE INDENT result += abs ( abs ( arr [ i ] [ i ] ) - abs ( sum ) ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT arr = [ [ 3 , - 2 , 1 ] , [ 1 , - 3 , 2 ] , [ - 1 , 2 , 4 ] ] NEW_LINE print ( findStepsForDDM ( arr ) ) NEW_LINE"],"bleu":0.9022386178888404,"rouge_l":0.9602839798333163}
{"id":1242,"predictions":["def isArmstrong ( x , n ) : NEW_LINE INDENT sum1 = 0 NEW_LINE temp = x NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT digit = temp % 10 NEW_LINE sum1 += pow ( digit , n ) NEW_LINE temp \/\/= 10 NEW_LINE DEDENT return sum1 == x NEW_LINE DEDENT def CalculateXORandOR ( n ) : NEW_LINE INDENT CalculateXOR = 0 NEW_LINE CalculateOR = 0 NEW_LINE start = int ( math . pow ( 10 , n - 1 ) ) - 1 NEW_LINE end = int ( math . pow ( 10 , n ) ) - 1 NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT if ( isArmstrong ( i , n ) ) : NEW_LINE INDENT CalculateXOR = CalculateXOR ^ i NEW_LINE CalculateXOR = CalculateOR | i NEW_LINE DEDENT DEDENT print ( \" XOR ▁ = ▁ \" , CalculateXOR ) NEW_LINE print ( \" ^ ▁ = ▁ \" , CalculateXOR ) NEW_LINE print ( \" ^ ▁ = ▁ \" , CalculateXOR ) NEW_LINE"],"references":["def isArmstrong ( x , n ) : NEW_LINE INDENT sum1 = 0 NEW_LINE temp = x NEW_LINE while temp > 0 : NEW_LINE INDENT digit = temp % 10 NEW_LINE sum1 += digit ** n NEW_LINE temp \/\/= 10 NEW_LINE DEDENT return sum1 == x NEW_LINE DEDENT def CalculateXORandOR ( n ) : NEW_LINE INDENT CalculateXOR = 0 NEW_LINE CalculateOR = 0 NEW_LINE start = 10 ** ( n - 1 ) NEW_LINE end = ( 10 ** n ) - 1 NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT if ( isArmstrong ( i , n ) ) : NEW_LINE INDENT CalculateXOR = CalculateXOR ^ i NEW_LINE CalculateOR = CalculateOR | i NEW_LINE DEDENT DEDENT print ( \" XOR ▁ = ▁ \" , CalculateXOR ) NEW_LINE print ( \" OR ▁ = ▁ \" , CalculateOR ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 ; NEW_LINE CalculateXORandOR ( n ) ; NEW_LINE DEDENT"],"bleu":0.6976107200879471,"rouge_l":0.8236334854269486}
{"id":1243,"predictions":["import math NEW_LINE def decToOctal ( n ) : NEW_LINE INDENT octalNum = [ 0 ] * 100 NEW_LINE i = 0 NEW_LINE while ( n ) : NEW_LINE INDENT octalNum [ i ] = n % 8 NEW_LINE n = int ( n \/ 8 ) NEW_LINE i += 1 NEW_LINE DEDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( octalNum [ j ] , end = \" \" ) NEW_LINE DEDENT print ( end = \" \" ) NEW_LINE DEDENT def nDigitPerfectSquares ( n ) : NEW_LINE INDENT decimal = int ( math . ceil ( math . sqrt ( 8 ** n ) ) - 1 , 2 ) NEW_LINE decToOctal ( decimal ) NEW_LINE DEDENT n = 2 NEW_LINE nDigitPerfectSquares ( n ) NEW_LINE"],"references":["from math import sqrt , ceil NEW_LINE def decToOctal ( n ) : NEW_LINE INDENT octalNum = [ 0 ] * 100 ; NEW_LINE i = 0 ; NEW_LINE while ( n != 0 ) : NEW_LINE INDENT octalNum [ i ] = n % 8 ; NEW_LINE n = n \/\/ 8 ; NEW_LINE i += 1 ; NEW_LINE DEDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( octalNum [ j ] , end = \" \" ) ; NEW_LINE DEDENT print ( ) ; NEW_LINE DEDENT def nDigitPerfectSquares ( n ) : NEW_LINE INDENT decimal = pow ( ceil ( sqrt ( pow ( 8 , n ) ) ) - 1 , 2 ) ; NEW_LINE decToOctal ( decimal ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 2 ; NEW_LINE nDigitPerfectSquares ( n ) ; NEW_LINE DEDENT"],"bleu":0.586648614067014,"rouge_l":0.8139410760034158}
{"id":1244,"predictions":["def getFinalElement ( n ) : NEW_LINE INDENT finalNum = 2 NEW_LINE lastNum = 2 NEW_LINE while ( finalNum * 2 <= n ) : NEW_LINE INDENT finalNum *= 2 NEW_LINE DEDENT return finalNum NEW_LINE DEDENT N = 12 NEW_LINE print ( getFinalElement ( N ) ) NEW_LINE"],"references":["def getFinalElement ( n ) : NEW_LINE INDENT finalNum = 2 NEW_LINE while finalNum * 2 <= n : NEW_LINE INDENT finalNum *= 2 NEW_LINE DEDENT return finalNum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 12 NEW_LINE print ( getFinalElement ( N ) ) NEW_LINE DEDENT"],"bleu":0.6584625658878093,"rouge_l":0.7966417910447762}
{"id":1245,"predictions":["def maxSum ( arr , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT ans = arr [ 0 ] + arr [ 1 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans = min ( ans , ( arr [ i ] + arr [ i + 1 ] ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 12 , 2 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxSum ( arr , n ) ) NEW_LINE"],"references":["def maxSum ( arr , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT ans = arr [ 0 ] + arr [ 1 ] NEW_LINE for i in range ( 1 , n - 1 , 1 ) : NEW_LINE INDENT ans = min ( ans , ( arr [ i ] + arr [ i + 1 ] ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 12 , 2 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxSum ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.8146704206549691,"rouge_l":0.9065069975472515}
{"id":1246,"predictions":["def findCount ( str ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( i == ( str [ i ] ) ) or i == ( ord ( str [ i ] ) - ord ( ' a ' ) ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT str = \" AbgdeF \" NEW_LINE print ( findCount ( str ) ) NEW_LINE"],"references":["def findCount ( str ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( ( i == ord ( str [ i ] ) - ord ( ' a ' ) ) or ( i == ord ( str [ i ] ) - ord ( ' A ' ) ) ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT str = ' AbgdeF ' NEW_LINE print ( findCount ( str ) ) NEW_LINE"],"bleu":0.7610377829737436,"rouge_l":0.887355464378963}
{"id":1247,"predictions":["def power ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( y % 2 == 0 ) : NEW_LINE INDENT return power ( x , y \/ 2 ) * power ( x , y \/ 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( x * power ( x , int ( y \/ 2 ) ) * power ( x , int ( y \/ 2 ) ) ) NEW_LINE DEDENT DEDENT def sieveOfEratosthenes ( n , isPrime ) : NEW_LINE INDENT isPrime [ 0 ] = isPrime [ 1 ] = False NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT isPrime [ i ] = True NEW_LINE DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( isPrime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT isPrime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def leftTruPrime ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE temp1 = temp % 10 NEW_LINE if ( temp1 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT temp = int ( temp \/ 10 ) NEW_LINE temp1 = temp % 10 NEW_LINE if ( temp1 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT temp = int ( temp \/ 10 ) NEW_LINE sieveOfEratosthenes ( n , isPrime ) ) NEW_LINE for i in range ( cnt , - 1 , - 1 ) : NEW_LINE INDENT mod = power ( 10 , i ) NEW_LINE if ( not isPrime [ n % mod ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 132 ; NEW_LINE if ( leftTruPrime ( n )"],"references":["def power ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( y % 2 == 0 ) : NEW_LINE INDENT return ( power ( x , y \/\/ 2 ) * power ( x , y \/\/ 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( x * power ( x , y \/\/ 2 ) * power ( x , y \/\/ 2 ) ) NEW_LINE DEDENT DEDENT def sieveOfEratosthenes ( n , isPrime ) : NEW_LINE INDENT isPrime [ 0 ] = isPrime [ 1 ] = False NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT isPrime [ i ] = True NEW_LINE DEDENT p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( isPrime [ p ] == True ) : NEW_LINE INDENT i = p * 2 NEW_LINE while ( i <= n ) : NEW_LINE INDENT isPrime [ i ] = False NEW_LINE i = i + p NEW_LINE DEDENT DEDENT p = p + 1 NEW_LINE DEDENT DEDENT def leftTruPrime ( n ) : NEW_LINE INDENT temp = n NEW_LINE cnt = 0 NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE temp1 = temp % 10 ; NEW_LINE if ( temp1 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT temp = temp \/\/ 10 NEW_LINE DEDENT isPrime = [ None ] * ( n + 1 ) NEW_LINE sieveOfEratosthenes ( n , isPrime ) NEW_LINE for i in range ( cnt , 0 , - 1 ) : NEW_LINE INDENT mod = power ( 10 , i ) NEW_LINE if ( isPrime [ n % mod ] != True ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT n = 113 NEW_LINE if ( leftTruPrime ( n ) ) : NEW_LINE INDENT print ( n , \" is ▁ left ▁ truncatable ▁ prime \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n , \" is ▁ not ▁ left ▁ truncatable ▁ prime \" ) NEW_LINE DEDENT"],"bleu":0.6691952660980377,"rouge_l":0.7618074477747502}
{"id":1248,"predictions":["def findExtraCharcter ( strA , strB ) : NEW_LINE INDENT m1 = [ 0 ] * 256 NEW_LINE for i in range ( len ( strB ) ) : NEW_LINE INDENT m1 [ ord ( strB [ i ] ) ] += 1 NEW_LINE DEDENT for i in range ( len ( strA ) ) : NEW_LINE INDENT m1 [ ord ( strB [ i ] ) ] -= 1 NEW_LINE DEDENT for i in range ( len ( m1 ) ) : NEW_LINE INDENT if ( m1 [ i ] == 1 ) : NEW_LINE INDENT return chr ( i ) NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT strA = \" abcd \" NEW_LINE strB = \" cbdad \" NEW_LINE strB = \" cbdad \" NEW_LINE print ( findExtraCharcter ( strA , strB ) ) NEW_LINE"],"references":["def findExtraCharacter ( strA , strB ) : NEW_LINE INDENT m1 = { } NEW_LINE for i in strB : NEW_LINE INDENT if i in m1 : NEW_LINE INDENT m1 [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m1 [ i ] = 1 NEW_LINE DEDENT DEDENT for i in strA : NEW_LINE INDENT m1 [ i ] -= 1 NEW_LINE DEDENT for h1 in m1 : NEW_LINE INDENT if m1 [ h1 ] == 1 : NEW_LINE INDENT return h1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT strA = ' abcd ' NEW_LINE strB = ' cbdad ' NEW_LINE print ( findExtraCharacter ( strA , strB ) ) NEW_LINE DEDENT"],"bleu":0.37056444376177555,"rouge_l":0.6166287591609805}
{"id":1249,"predictions":["def AvgofSquareN ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( i * i ) NEW_LINE DEDENT return sum \/ n NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 2 NEW_LINE print ( AvgofSquareN ( n ) ) NEW_LINE DEDENT"],"references":["def AvgofSquareN ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( i * i ) NEW_LINE DEDENT return sum \/ n NEW_LINE DEDENT n = 2 NEW_LINE print ( AvgofSquareN ( n ) ) NEW_LINE"],"bleu":0.766287664396474,"rouge_l":0.9023164945576334}
{"id":1250,"predictions":["def lcm_fun ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return lcm_fun ( b , a % b ) NEW_LINE DEDENT def digitLCM ( n ) : NEW_LINE INDENT lcm = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT lcm = ( n % 10 * lcm ) \/\/ lcm_fun ( n % 10 , lcm ) NEW_LINE if ( lcm == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT n = n \/\/ 10 NEW_LINE DEDENT return lcm NEW_LINE DEDENT n = 397 NEW_LINE print ( digitLCM ( n ) ) NEW_LINE"],"references":["def lcm_fun ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a ; NEW_LINE DEDENT return lcm_fun ( b , a % b ) ; NEW_LINE DEDENT def digitLCM ( n ) : NEW_LINE INDENT lcm = 1 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT lcm = int ( ( n % 10 * lcm ) \/ lcm_fun ( n % 10 , lcm ) ) ; NEW_LINE if ( lcm == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT n = int ( n \/ 10 ) ; NEW_LINE DEDENT return lcm ; NEW_LINE DEDENT n = 397 ; NEW_LINE print ( digitLCM ( n ) ) ; NEW_LINE"],"bleu":0.7113357047559759,"rouge_l":0.9086896551724138}
{"id":1251,"predictions":["def fact ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n * fact ( n - 1 ) NEW_LINE DEDENT def nPr ( n , r ) : NEW_LINE INDENT return fact ( n ) \/\/ fact ( n - r ) NEW_LINE DEDENT n = 5 NEW_LINE r = 2 NEW_LINE print ( n , r , \" ▁ = ▁ \" , nPr ( n , r ) ) NEW_LINE"],"references":["import math NEW_LINE def fact ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n * fact ( n - 1 ) NEW_LINE DEDENT def nPr ( n , r ) : NEW_LINE INDENT return math . floor ( fact ( n ) \/ fact ( n - r ) ) NEW_LINE DEDENT n = 5 NEW_LINE r = 2 NEW_LINE print ( n , \" P \" , r , \" = \" , nPr ( n , r ) ) NEW_LINE"],"bleu":0.7812136221743186,"rouge_l":0.900984682713348}
{"id":1252,"predictions":["def isPossible ( a , n ) : NEW_LINE INDENT cur = a [ 0 ] NEW_LINE cur -= 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT nxt = a [ i ] NEW_LINE if ( nxt > cur ) : NEW_LINE INDENT nxt -= 1 NEW_LINE DEDENT elif ( nxt < cur ) : NEW_LINE INDENT return False NEW_LINE DEDENT cur = nxt NEW_LINE DEDENT return True NEW_LINE DEDENT a = [ 1 , 2 , 1 , 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE if ( isPossible ( a , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def isPossible ( a , n ) : NEW_LINE INDENT cur = a [ 0 ] ; NEW_LINE cur -= 1 ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT nxt = a [ i ] ; NEW_LINE if ( nxt > cur ) : NEW_LINE INDENT nxt -= 1 ; NEW_LINE DEDENT elif ( nxt < cur ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT cur = nxt ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 2 , 1 , 2 , 3 ] ; NEW_LINE n = len ( a ) ; NEW_LINE if ( isPossible ( a , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"],"bleu":0.7060884214216315,"rouge_l":0.8973657201505303}
{"id":1253,"predictions":["def fact ( n ) : NEW_LINE INDENT num = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT num = num * i NEW_LINE DEDENT return num NEW_LINE DEDENT def Special_Factorial_Number ( k ) : NEW_LINE INDENT for i in range ( 1 , k + 1 ) : NEW_LINE INDENT if ( fact ( i ) % k == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT k = 16 NEW_LINE print ( Special_Factorial_Number ( k ) ) NEW_LINE"],"references":["def fact ( n ) : NEW_LINE INDENT num = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT num = num * i NEW_LINE DEDENT return num NEW_LINE DEDENT def Special_Factorial_Number ( k ) : NEW_LINE INDENT for i in range ( 1 , k + 1 ) : NEW_LINE INDENT if ( fact ( i ) % k == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT k = 16 NEW_LINE print ( Special_Factorial_Number ( k ) ) NEW_LINE DEDENT"],"bleu":0.8476113677549276,"rouge_l":0.9192048733568452}
{"id":1254,"predictions":["mod = 1000000007 NEW_LINE def noOfBinaryStrings ( N , k ) : NEW_LINE INDENT dp = [ 0 ] * 100002 NEW_LINE for i in range ( 1 , k ) : NEW_LINE INDENT dp [ i ] = 1 NEW_LINE DEDENT dp [ k ] = 2 NEW_LINE for i in range ( k + 1 , N + 1 ) : NEW_LINE INDENT dp [ i ] = ( dp [ i - 1 ] + dp [ i - k ] ) % mod NEW_LINE DEDENT return dp [ N ] NEW_LINE DEDENT N = 4 NEW_LINE K = 2 NEW_LINE print ( noOfBinaryStrings ( N , K ) ) NEW_LINE"],"references":["mod = 1000000007 ; NEW_LINE def noOfBinaryStrings ( N , k ) : NEW_LINE INDENT dp = [ 0 ] * 100002 ; NEW_LINE for i in range ( 1 , K ) : NEW_LINE INDENT dp [ i ] = 1 ; NEW_LINE DEDENT dp [ k ] = 2 ; NEW_LINE for i in range ( k + 1 , N + 1 ) : NEW_LINE INDENT dp [ i ] = ( dp [ i - 1 ] + dp [ i - k ] ) % mod ; NEW_LINE DEDENT return dp [ N ] ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 4 ; NEW_LINE K = 2 ; NEW_LINE print ( noOfBinaryStrings ( N , K ) ) ; NEW_LINE DEDENT"],"bleu":0.6928867438478234,"rouge_l":0.8857620149061938}
{"id":1255,"predictions":["def reverse ( arr , n , k ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT left = i NEW_LINE right = min ( i + k - 1 , n - 1 ) NEW_LINE while ( left < right ) : NEW_LINE INDENT arr [ i ] , left += 1 , n - 1 NEW_LINE DEDENT DEDENT return arr NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 ] NEW_LINE k = 3 NEW_LINE n = len ( arr ) NEW_LINE reverse ( arr , n , k ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT"],"references":["def reverse ( arr , n , k ) : NEW_LINE INDENT for i in range ( 0 , n , 2 * k ) : NEW_LINE INDENT left = i NEW_LINE right = min ( i + k - 1 , n - 1 ) NEW_LINE while ( left < right ) : NEW_LINE INDENT temp = arr [ left ] NEW_LINE arr [ left ] = arr [ right ] NEW_LINE arr [ right ] = temp NEW_LINE left += 1 NEW_LINE right -= 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 ] NEW_LINE k = 3 NEW_LINE n = len ( arr ) NEW_LINE reverse ( arr , n , k ) NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.6655632620592986,"rouge_l":0.8136477865841869}
{"id":1256,"predictions":["MAX = 100 ; NEW_LINE mat = [ [ 0 for i in range ( MAX ) ] for k in range ( MAX ) ] ; NEW_LINE def fillRemaining ( i , j , n ) : NEW_LINE INDENT x = 2 ; NEW_LINE for k in range ( i + 1 , n ) : NEW_LINE INDENT mat [ k ] [ j ] = x + 1 ; NEW_LINE DEDENT for k in range ( i , n ) : NEW_LINE INDENT mat [ k ] [ j ] = x + 1 ; NEW_LINE DEDENT DEDENT def constructMatrix ( n ) : NEW_LINE INDENT right = n - 1 ; left = 0 ; NEW_LINE left = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i & 1 ) : NEW_LINE INDENT mat [ i ] [ right ] = 1 ; NEW_LINE fillRemaining ( i , right , n ) ; NEW_LINE right -= 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT mat [ i ] [ left ] = 1 ; NEW_LINE fillRemaining ( i , left , n ) ; NEW_LINE left -= 1 ; NEW_LINE DEDENT DEDENT DEDENT n = 5 ; NEW_LINE constructMatrix ( n ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = \" ▁ \" ) ; NEW_LINE DEDENT"],"references":["MAX = 100 ; NEW_LINE mat = [ [ 0 for x in range ( MAX ) ] for y in range ( MAX ) ] ; NEW_LINE def fillRemaining ( i , j , n ) : NEW_LINE INDENT x = 2 ; NEW_LINE for k in range ( i + 1 , n ) : NEW_LINE INDENT mat [ k ] [ j ] = x ; NEW_LINE x += 1 ; NEW_LINE DEDENT for k in range ( i ) : NEW_LINE INDENT mat [ k ] [ j ] = x ; NEW_LINE x += 1 ; NEW_LINE DEDENT DEDENT def constructMatrix ( n ) : NEW_LINE INDENT right = n - 1 ; NEW_LINE left = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT mat [ i ] [ right ] = 1 ; NEW_LINE fillRemaining ( i , right , n ) ; NEW_LINE right -= 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT mat [ i ] [ left ] = 1 ; NEW_LINE fillRemaining ( i , left , n ) ; NEW_LINE left += 1 ; NEW_LINE DEDENT DEDENT DEDENT n = 5 ; NEW_LINE constructMatrix ( n ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( \" \" ) ; NEW_LINE DEDENT"],"bleu":0.869939906180714,"rouge_l":0.9269929715696827}
{"id":1257,"predictions":["def printMaxOfMin ( arr , n ) : NEW_LINE INDENT for k in range ( 1 , n + 1 ) : NEW_LINE INDENT maxOfMin = - float ( sys . maxsize - k ) NEW_LINE for i in range ( 0 , n - k + 1 ) : NEW_LINE INDENT min = arr [ i ] NEW_LINE for j in range ( 1 , k ) : NEW_LINE INDENT if ( arr [ i + j ] < min ) : NEW_LINE INDENT min = arr [ i + j ] NEW_LINE DEDENT DEDENT if ( min > maxOfMin ) : NEW_LINE INDENT maxOfMin = min NEW_LINE DEDENT DEDENT DEDENT print ( maxOfMin ) NEW_LINE DEDENT arr = [ 10 , 20 , 30 , 50 , 10 , 70 , 30 ] NEW_LINE n = len ( arr ) NEW_LINE printMaxOfMin ( arr , n ) NEW_LINE"],"references":["INT_MIN = - 1000000 NEW_LINE def printMaxOfMin ( arr , n ) : NEW_LINE INDENT for k in range ( 1 , n + 1 ) : NEW_LINE INDENT maxOfMin = INT_MIN ; NEW_LINE for i in range ( n - k + 1 ) : NEW_LINE INDENT min = arr [ i ] NEW_LINE for j in range ( k ) : NEW_LINE INDENT if ( arr [ i + j ] < min ) : NEW_LINE INDENT min = arr [ i + j ] NEW_LINE DEDENT DEDENT if ( min > maxOfMin ) : NEW_LINE INDENT maxOfMin = min NEW_LINE DEDENT DEDENT print ( maxOfMin , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 10 , 20 , 30 , 50 , 10 , 70 , 30 ] NEW_LINE n = len ( arr ) NEW_LINE printMaxOfMin ( arr , n ) NEW_LINE"],"bleu":0.866280498148986,"rouge_l":0.9066666666666667}
{"id":1258,"predictions":["def countSubArrays ( arr , n , K ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT bitwise_or = 0 NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT bitwise_or = bitwise_or | arr [ k ] NEW_LINE DEDENT if ( bitwise_or >= K ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE k = 6 NEW_LINE print ( int ( countSubArrays ( arr , n , k ) ) ) NEW_LINE"],"references":["def countSubArrays ( arr , n , K ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT bitwise_or = 0 NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT bitwise_or = bitwise_or | arr [ k ] NEW_LINE DEDENT if ( bitwise_or >= K ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE k = 6 NEW_LINE print ( countSubArrays ( arr , n , k ) ) NEW_LINE DEDENT"],"bleu":0.8534772457738935,"rouge_l":0.9218948437896876}
{"id":1259,"predictions":["CHARS = \" qwertyy \" NEW_LINE MAX = 26 NEW_LINE def getString ( string , n ) : NEW_LINE INDENT uMap = { } NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT uMap [ string [ i ] ] = chARS [ ( i + 1 ) % MAX ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT st [ i ] = uMap [ string [ i ] ] NEW_LINE DEDENT return re NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT string = \" geeks \" NEW_LINE n = len ( string ) NEW_LINE print ( getString ( string , n ) ) NEW_LINE DEDENT"],"references":["CHARS = \" qwertyuiopasdfghjklzxcvbnm \" ; NEW_LINE MAX = 26 ; NEW_LINE def getString ( string , n ) : NEW_LINE INDENT string = list ( string ) ; NEW_LINE uMap = { } ; NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT uMap [ CHARS [ i ] ] = CHARS [ ( i + 1 ) % MAX ] ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT string [ i ] = uMap [ string [ i ] ] ; NEW_LINE DEDENT return \" \" . join ( string ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" geeks \" ; NEW_LINE n = len ( string ) ; NEW_LINE print ( getString ( string , n ) ) ; NEW_LINE DEDENT"],"bleu":0.6128645072269208,"rouge_l":0.8459744722631322}
{"id":1260,"predictions":["def printOrder ( arr , k ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE arr1 = arr [ : k ] NEW_LINE arr2 = arr [ k : ] NEW_LINE arr2 . sort ( ) NEW_LINE arr2 . sort ( reverse = True ) NEW_LINE return arr1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 4 , 6 , 2 , 1 , 3 , 8 , 9 , - 1 ] NEW_LINE n = len ( arr ) NEW_LINE printOrder ( arr , n ) NEW_LINE DEDENT"],"references":["def printOrder ( arr , n , k ) : NEW_LINE INDENT a = arr [ 0 : k ] ; NEW_LINE a . sort ( ) ; NEW_LINE b = arr [ k : n ] ; NEW_LINE b . sort ( ) ; NEW_LINE b . reverse ( ) ; NEW_LINE return a + b ; NEW_LINE DEDENT arr = [ 5 , 4 , 6 , 2 , 1 , 3 , 8 , 9 , - 1 ] ; NEW_LINE k = 4 ; NEW_LINE n = len ( arr ) ; NEW_LINE arr = printOrder ( arr , n , k ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT"],"bleu":0.3817338401630246,"rouge_l":0.607128446536651}
{"id":1261,"predictions":["import math NEW_LINE def countSteps ( n ) : NEW_LINE INDENT steps = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT largest = int ( math . sqrt ( n ) ) NEW_LINE n -= ( largest * largest ) NEW_LINE steps += 1 NEW_LINE DEDENT return steps NEW_LINE DEDENT n = 85 NEW_LINE print ( countSteps ( n ) ) NEW_LINE"],"references":["from math import sqrt NEW_LINE def countSteps ( n ) : NEW_LINE INDENT steps = 0 ; NEW_LINE while ( n ) : NEW_LINE INDENT largest = int ( sqrt ( n ) ) ; NEW_LINE n -= ( largest * largest ) ; NEW_LINE steps += 1 ; NEW_LINE DEDENT return steps ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 85 ; NEW_LINE print ( countSteps ( n ) ) ; NEW_LINE DEDENT"],"bleu":0.5026333907789825,"rouge_l":0.7872660787266079}
{"id":1262,"predictions":["import math as mt NEW_LINE def Area ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT h = 1.677 * a NEW_LINE A = 0.70477 * pow ( h , 2 ) NEW_LINE return A NEW_LINE DEDENT a = 5 NEW_LINE print ( Area ( a ) ) NEW_LINE"],"references":["import math NEW_LINE def Area ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT h = 1.268 * a NEW_LINE A = 0.70477 * math . pow ( h , 2 ) NEW_LINE return A NEW_LINE DEDENT a = 5 NEW_LINE print ( Area ( a ) , end = \" \\n \" ) NEW_LINE"],"bleu":0.7720931203491581,"rouge_l":0.8970588235294117}
{"id":1263,"predictions":["SIZE = 26 NEW_LINE def isVowel ( ch ) : NEW_LINE INDENT if ( ch == ' a ' or ch == ' e ' or ch == ' i ' or ch == ' o ' or ch == ' u ' ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def createAltStr ( str1 , str22 , start , l ) : NEW_LINE INDENT finalStr = \" \" NEW_LINE for i in range ( l ) : NEW_LINE INDENT finalStr = ( finalStr + str1 [ i ] ) NEW_LINE DEDENT return finalStr NEW_LINE DEDENT def findAltStr ( str1 , str2 , start , lstr ) : NEW_LINE INDENT finalStr = [ 0 ] * SIZE NEW_LINE nv = 0 NEW_LINE vstr = \" \" NEW_LINE cstr = 0 NEW_LINE l = len ( str1 ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT ch = str [ i ] NEW_LINE if ( isVowel ( ch ) ) : NEW_LINE INDENT nv += 1 NEW_LINE DEDENT else : NEW_LINE INDENT nc += 1 NEW_LINE DEDENT char_freq [ ord ( ch ) - 97 ] += 1 NEW_LINE l = len ( str1 ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT ch = str1 [ i ] NEW_LINE if ( isVowel ( ch ) ) : NEW_LINE INDENT nv += 1 NEW_LINE DEDENT else : NEW_LINE INDENT nc += 1 NEW_LINE DEDENT char_freq [ ord ( ch ) - 97 ) ] += 1 NEW_LINE DEDENT if ( abs ( chr - nc ) >= 2 ) : NEW_LINE INDENT return \" NO ▁ such ▁ string \" NEW_LINE DEDENT for i in range ( size ) : NEW_LINE INDENT ch = chr ( i + 97 ) NEW_LINE if ( isVowel ( chr ) : NEW_LINE INDENT v1 += chr ( chr ( chr ( chr ( 97 + 97 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT"],"references":["SIZE = 26 NEW_LINE def isVowel ( ch ) : NEW_LINE INDENT if ( ch == ' a ' or ch == ' e ' or ch == ' i ' or ch == ' o ' or ch == ' u ' ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def createAltStr ( str1 , str2 , start , l ) : NEW_LINE INDENT finalStr = \" \" NEW_LINE i = 0 NEW_LINE j = start NEW_LINE while j < l : NEW_LINE INDENT finalStr += str1 [ i ] + str2 [ j ] NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT return finalStr NEW_LINE DEDENT def findAltStr ( string ) : NEW_LINE INDENT char_freq = [ 0 ] * SIZE NEW_LINE nv = 0 NEW_LINE nc = 0 NEW_LINE vstr = \" \" NEW_LINE cstr = \" \" NEW_LINE l = len ( string ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT ch = string [ i ] NEW_LINE if isVowel ( ch ) : NEW_LINE INDENT nv += 1 NEW_LINE DEDENT else : NEW_LINE INDENT nc += 1 NEW_LINE DEDENT char_freq [ ord ( ch ) - 97 ] += 1 NEW_LINE DEDENT if abs ( nv - nc ) >= 2 : NEW_LINE INDENT return \" no ▁ such ▁ string \" NEW_LINE DEDENT for i in range ( SIZE ) : NEW_LINE INDENT ch = chr ( i + 97 ) NEW_LINE for j in range ( 1 , char_freq [ i ] + 1 ) : NEW_LINE INDENT if isVowel ( ch ) : NEW_LINE INDENT vstr += ch NEW_LINE DEDENT else : NEW_LINE INDENT cstr += ch NEW_LINE DEDENT DEDENT DEDENT if nv > nc : NEW_LINE INDENT return vstr [ 0 ] + createAltStr ( cstr , vstr , 1 , nv ) NEW_LINE DEDENT if nc > nv : NEW_LINE INDENT return cstr [ 0 ] + createAltStr ( vstr , cstr , 1 , nc ) NEW_LINE DEDENT if cstr [ 0 ] < vstr [ 0 ] : NEW_LINE INDENT return createAltStr ( cstr , vstr , 0 , nv ) NEW_LINE DEDENT return createAltStr ( vstr , cstr , 0 , nc ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" aeroplane \" NEW_LINE print ( findAltStr ( string ) ) NEW_LINE DEDENT"],"bleu":0.529246999164783,"rouge_l":0.6322487536079768}
{"id":1264,"predictions":["N = 5 NEW_LINE M = 5 NEW_LINE def minOperation ( arr ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( M - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] [ j ] == 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE for k in range ( i + 1 , j ) : NEW_LINE INDENT if ( arr [ k ] [ h ] == 1 ) : NEW_LINE INDENT arr [ k ] [ h ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ k ] [ h ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT N = 5 NEW_LINE M = 5 NEW_LINE M = 5 NEW_LINE print ( minOperation ( mat ) ) NEW_LINE"],"references":["def minOperation ( arr ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( M - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] [ j ] == 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE for k in range ( i + 1 ) : NEW_LINE INDENT for h in range ( j + 1 ) : NEW_LINE INDENT if ( arr [ k ] [ h ] == 1 ) : NEW_LINE INDENT arr [ k ] [ h ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ k ] [ h ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT mat = [ [ 0 , 0 , 1 , 1 , 1 ] , [ 0 , 0 , 0 , 1 , 1 ] , [ 0 , 0 , 0 , 1 , 1 ] , [ 1 , 1 , 1 , 1 , 1 ] , [ 1 , 1 , 1 , 1 , 1 ] ] NEW_LINE M = 5 NEW_LINE N = 5 NEW_LINE print ( minOperation ( mat ) ) NEW_LINE"],"bleu":0.6014023584652852,"rouge_l":0.7480262052746515}
{"id":1265,"predictions":["def decToOctal ( n ) : NEW_LINE INDENT octalNum = [ 0 ] * 100 NEW_LINE i = 0 NEW_LINE while ( n ) : NEW_LINE INDENT octalNum [ i ] = n % 8 NEW_LINE n = int ( n \/ 8 ) NEW_LINE i += 1 NEW_LINE DEDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( octalNum [ j ] , end = \" \" ) NEW_LINE DEDENT DEDENT n = 33 NEW_LINE decToOctal ( n ) NEW_LINE"],"references":["def decToOctal ( n ) : NEW_LINE INDENT octalNum = [ 0 ] * 100 ; NEW_LINE i = 0 ; NEW_LINE while ( n != 0 ) : NEW_LINE INDENT octalNum [ i ] = n % 8 ; NEW_LINE n = int ( n \/ 8 ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( octalNum [ j ] , end = \" \" ) ; NEW_LINE DEDENT DEDENT n = 33 ; NEW_LINE decToOctal ( n ) ; NEW_LINE"],"bleu":0.7653003958457194,"rouge_l":0.9397186872069658}
{"id":1266,"predictions":["def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT def isFactorialPrime ( n ) : NEW_LINE INDENT if ( isPrime ( n ) ) : NEW_LINE INDENT return false NEW_LINE DEDENT fact = 1 NEW_LINE i = 1 NEW_LINE while ( fact <= n + 2 ) : NEW_LINE INDENT fact = fact * i NEW_LINE if ( n + 1 == fact or n - 1 == fact ) : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT n = 23 NEW_LINE if ( isFactorialPrime ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["from math import sqrt NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 5 , int ( sqrt ( n ) ) + 1 , 6 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def isFactorialPrime ( n ) : NEW_LINE INDENT if ( not isPrime ( n ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT fact = 1 NEW_LINE i = 1 NEW_LINE while ( fact <= n + 1 ) : NEW_LINE INDENT fact = fact * i NEW_LINE if ( n + 1 == fact or n - 1 == fact ) : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 23 NEW_LINE if ( isFactorialPrime ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.79854471256342,"rouge_l":0.8805831487172158}
{"id":1267,"predictions":["def convert ( m , n ) : NEW_LINE INDENT if ( m == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( m > n ) : NEW_LINE INDENT return m - n NEW_LINE DEDENT if ( m <= 0 and n > 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return 1 + convert ( m , n + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return 1 + convert ( m , n \/ 2 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT m = 3 NEW_LINE n = 11 NEW_LINE print ( \" Minimum ▁ number ▁ of ▁olutions ▁ : ▁ \" , convert ( m , n ) ) NEW_LINE DEDENT"],"references":["def conver ( m , n ) : NEW_LINE INDENT if ( m == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( m > n ) : NEW_LINE INDENT return m - n NEW_LINE DEDENT if ( m <= 0 and n > 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return 1 + conver ( m , n + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return 1 + conver ( m , n \/ 2 ) NEW_LINE DEDENT DEDENT m = 3 NEW_LINE n = 11 NEW_LINE print ( \" Minimum ▁ number ▁ of ▁ operations ▁ : \" , conver ( m , n ) ) NEW_LINE"],"bleu":0.79314436647071,"rouge_l":0.9122333905368963}
{"id":1268,"predictions":["MAX = 1000000 NEW_LINE prime = [ True for i in range ( MAX ) ] NEW_LINE def sieve ( ) : NEW_LINE INDENT p = 2 NEW_LINE while ( p * p < MAX ) : NEW_LINE INDENT if ( p > p ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( 2 * p , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT def printPrimeQuad ( n ) : NEW_LINE INDENT for i in range ( n - 7 ) : NEW_LINE INDENT if ( prime [ i ] and prime [ i + 2 ] and prime [ i + 2 ] and prime [ i + 6 ] and prime [ i + 8 ] ) : NEW_LINE INDENT print ( i , ( i + 2 ) , ( i + 2 ) , ( i + 6 ) , ( i + 8 ) ) NEW_LINE DEDENT DEDENT DEDENT n = 25 NEW_LINEPrime ( n ) NEW_LINE printPrimeQuad ( n ) NEW_LINE"],"references":["from math import sqrt NEW_LINE MAX = 100000 NEW_LINE prime = [ True ] * MAX NEW_LINE def sieve ( ) : NEW_LINE INDENT for p in range ( 2 , int ( sqrt ( MAX ) ) + 1 ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def printPrimeQuad ( n ) : NEW_LINE INDENT for i in range ( n - 7 ) : NEW_LINE INDENT if ( prime [ i ] and prime [ i + 2 ] and prime [ i + 6 ] and prime [ i + 8 ] ) : NEW_LINE INDENT print ( i , i + 2 , i + 6 , i + 8 ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT sieve ( ) NEW_LINE n = 20 NEW_LINE printPrimeQuad ( 20 ) NEW_LINE DEDENT"],"bleu":0.6224840579053997,"rouge_l":0.7432408395588759}
{"id":1269,"predictions":["def sum ( mat , r , c ) : NEW_LINE INDENT upper_sum = 0 NEW_LINE lower_sum = 0 NEW_LINE for i in range ( r ) : NEW_LINE INDENT for j in range ( c ) : NEW_LINE INDENT if ( i <= j ) : NEW_LINE INDENT upper_sum += mat [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT print ( \"upper ▁ sum ▁ is \" , upper_sum ) NEW_LINE for i in range ( r ) : NEW_LINE INDENT for j in range ( c ) : NEW_LINE INDENT if ( i <= 0 ) : NEW_LINE INDENT lower_sum += mat [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT print ( \" lower ▁ sum ▁ is \" , lower_sum ) NEW_LINE DEDENT r = 3 NEW_LINE c = 3 NEW_LINE mat = [ [ 6 , 5 , 4 ] , [ 1 , 2 , 5 ] , [ 7 , 9 , 7 ] ] NEW_LINE sum ( mat , r , c ) NEW_LINE"],"references":["def Sum ( mat , r , c ) : NEW_LINE INDENT i , j = 0 , 0 ; NEW_LINE upper_sum = 0 ; NEW_LINE lower_sum = 0 ; NEW_LINE for i in range ( r ) : NEW_LINE INDENT for j in range ( c ) : NEW_LINE INDENT if ( i <= j ) : NEW_LINE INDENT upper_sum += mat [ i ] [ j ] ; NEW_LINE DEDENT DEDENT DEDENT print ( \" Upper ▁ sum ▁ is ▁ \" , upper_sum ) ; NEW_LINE for i in range ( r ) : NEW_LINE INDENT for j in range ( c ) : NEW_LINE INDENT if ( j <= i ) : NEW_LINE INDENT lower_sum += mat [ i ] [ j ] ; NEW_LINE DEDENT DEDENT DEDENT print ( \" Lower ▁ sum ▁ is ▁ \" , lower_sum ) ; NEW_LINE DEDENT r = 3 ; NEW_LINE c = 3 ; NEW_LINE mat = [ [ 6 , 5 , 4 ] , [ 1 , 2 , 5 ] , [ 7 , 9 , 7 ] ] ; NEW_LINE Sum ( mat , r , c ) ; NEW_LINE"],"bleu":0.7182375230798728,"rouge_l":0.8990145635301299}
{"id":1270,"predictions":["def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT def removeMin ( arr , n ) : NEW_LINE INDENT minVal = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT minVal = min ( minVal , arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT maxVal = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT maxVal = max ( maxVal , arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = max ( maxVal , arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = maxVal - arr [ i ] NEW_LINE DEDENT DEDENT def replaceArray ( arr , n , k ) : NEW_LINE INDENT if ( k % 2 == 0 ) : NEW_LINE INDENT removeMin ( arr , n ) NEW_LINE DEDENT else : NEW_LINE INDENT removeFromMax ( arr , n ) NEW_LINE DEDENT printArray ( arr , n ) NEW_LINE DEDENT arr = [ 4 , 8 , 15 , 16 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE replaceArray ( arr , n , k ) NEW_LINE"],"references":["def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT def removeMin ( arr , n ) : NEW_LINE INDENT minVal = arr [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT minVal = min ( minVal , arr [ i ] ) ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = arr [ i ] - minVal ; NEW_LINE DEDENT DEDENT def removeFromMax ( arr , n ) : NEW_LINE INDENT maxVal = arr [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT maxVal = max ( maxVal , arr [ i ] ) ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = maxVal - arr [ i ] ; NEW_LINE DEDENT DEDENT def modifyArray ( arr , n , k ) : NEW_LINE INDENT if ( k % 2 == 0 ) : NEW_LINE INDENT removeMin ( arr , n ) ; NEW_LINE DEDENT else : NEW_LINE INDENT removeFromMax ( arr , n ) ; NEW_LINE DEDENT printArray ( arr , n ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 4 , 8 , 12 , 16 ] ; NEW_LINE n = len ( arr ) NEW_LINE k = 2 ; NEW_LINE modifyArray ( arr , n , k ) ; NEW_LINE DEDENT"],"bleu":0.7623641200012888,"rouge_l":0.8664666625849506}
{"id":1271,"predictions":["def LongestSubarray ( a , n , k ) : NEW_LINE INDENT pre = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] > k ) : NEW_LINE INDENT pre [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT pre [ i ] = - 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , n , 1 ) : NEW_LINE INDENT pre [ i ] = pre [ i - 1 ] + pre [ i ] NEW_LINE DEDENT length = 0 NEW_LINE lo = 1 NEW_LINE hi = n NEW_LINE while ( lo <= hi ) : NEW_LINE INDENT mid = ( lo + hi ) \/\/ 2 NEW_LINE check = False NEW_LINE for i in range ( mid - 1 , n , 1 ) : NEW_LINE INDENT x = pre [ i ] NEW_LINE if ( i - mid >= 0 ) : NEW_LINE INDENT x -= pre [ i - mid ] NEW_LINE DEDENT if ( x > 0 ) : NEW_LINE INDENT ok = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( ok == True ) : NEW_LINE INDENT len = mid NEW_LINE lo = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT hi = mid - 1 NEW_LINE DEDENT DEDENT return len NEW_LINE DEDENT a = [ 2 , 3 , 4 , 5 , 3 , 7 ] NEW_LINE k = 3 NEW_LINE n = len ( a ) NEW_LINE print ( LongestSubarray ( a , n , k ) ) NEW_LINE"],"references":["def LongestSubarray ( a , n , k ) : NEW_LINE INDENT pre = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] > k ) : NEW_LINE INDENT pre [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT pre [ i ] = - 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT pre [ i ] = pre [ i - 1 ] + pre [ i ] NEW_LINE DEDENT Len = 0 NEW_LINE lo = 1 NEW_LINE hi = n NEW_LINE while ( lo <= hi ) : NEW_LINE INDENT mid = ( lo + hi ) \/\/ 2 NEW_LINE ok = False NEW_LINE for i in range ( mid - 1 , n ) : NEW_LINE INDENT x = pre [ i ] NEW_LINE if ( i - mid >= 0 ) : NEW_LINE INDENT x -= pre [ i - mid ] NEW_LINE DEDENT if ( x > 0 ) : NEW_LINE INDENT ok = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( ok == True ) : NEW_LINE INDENT Len = mid NEW_LINE lo = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT hi = mid - 1 NEW_LINE DEDENT DEDENT return Len NEW_LINE DEDENT a = [ 2 , 3 , 4 , 5 , 3 , 7 ] NEW_LINE k = 3 NEW_LINE n = len ( a ) NEW_LINE print ( LongestSubarray ( a , n , k ) ) NEW_LINE"],"bleu":0.9170606443697303,"rouge_l":0.9604239416773876}
{"id":1272,"predictions":["def findSum ( n ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT ans += ( i \/\/ j ) ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 2 ; NEW_LINE print ( findSum ( N ) ) ; NEW_LINE DEDENT"],"references":["def findSum ( N ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 1 , N + 1 ) : NEW_LINE INDENT ans += i \/\/ j NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT N = 2 NEW_LINE print ( findSum ( N ) ) NEW_LINE"],"bleu":0.5341401650871426,"rouge_l":0.8401445021449538}
{"id":1273,"predictions":["def permutation ( arr , n ) : NEW_LINE INDENT hash = set ( ) ; NEW_LINE maxEle = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash . add ( arr [ i ] ) ; NEW_LINE maxEle = max ( maxEle , arr [ i ] ) ; NEW_LINE DEDENT if ( maxEle != n ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT if ( len ( hash ) == n ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 5 , 3 , 2 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE if ( permutation ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"],"references":["def permutation ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE maxEle = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . add ( arr [ i ] ) ; NEW_LINE maxEle = max ( maxEle , arr [ i ] ) ; NEW_LINE DEDENT if ( maxEle != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( len ( s ) == n ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 5 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE if ( permutation ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.8277534573930153,"rouge_l":0.9535145075602779}
{"id":1274,"predictions":["N = 5 NEW_LINE def printHosoya ( N ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( N ) ] for y in range ( N ) ] NEW_LINE dp [ 0 ] [ 0 ] = dp [ 1 ] [ 0 ] = 1 NEW_LINE dp [ 1 ] [ 1 ] = 1 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( i > j ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 2 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 2 ] [ j - 2 ] ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , i + 1 ) : NEW_LINE INDENT print ( dp [ i ] [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( \" \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE printHosoya ( n ) NEW_LINE DEDENT"],"references":["N = 5 NEW_LINE def printHosoya ( n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( N ) ] for i in range ( N ) ] NEW_LINE dp [ 0 ] [ 0 ] = dp [ 1 ] [ 0 ] = dp [ 1 ] [ 1 ] = 1 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( i > j ) : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + dp [ i - 2 ] [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 2 ] [ j - 2 ] ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT print ( dp [ i ] [ j ] , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT n = 5 NEW_LINE printHosoya ( n ) NEW_LINE"],"bleu":0.8055025413764194,"rouge_l":0.9294482957827843}
{"id":1275,"predictions":["def pairs_count ( arr , n , sum ) : NEW_LINE INDENT ans = 0 NEW_LINE arr . sort ( ) NEW_LINE i = 0 NEW_LINE j = n - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] < sum ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT elif ( arr [ i ] + arr [ j ] > sum ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT x = arr [ i ] NEW_LINE xx = i NEW_LINE yy = j NEW_LINE while ( ( i >= j ) and ( arr [ i ] == x ) ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT if ( x == y ) : NEW_LINE INDENT temp = i - xx + yy - j - 1 NEW_LINE ans += ( temp * ( temp + 1 ) ) \/\/ 2 NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( i - xx ) * ( yy - j ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 5 , 7 , 5 , - 1 ] NEW_LINE n = len ( arr ) NEW_LINE sum = 6 NEW_LINE print ( pairs_count ( arr , n , sum ) ) ) NEW_LINE DEDENT"],"references":["def pairs_count ( arr , n , sum ) : NEW_LINE INDENT ans = 0 NEW_LINE arr = sorted ( arr ) NEW_LINE i , j = 0 , n - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] < sum ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT elif ( arr [ i ] + arr [ j ] > sum ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT x = arr [ i ] NEW_LINE xx = i NEW_LINE while ( i < j and arr [ i ] == x ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT y = arr [ j ] NEW_LINE yy = j NEW_LINE while ( j >= i and arr [ j ] == y ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT if ( x == y ) : NEW_LINE INDENT temp = i - xx + yy - j - 1 NEW_LINE ans += ( temp * ( temp + 1 ) ) \/\/ 2 NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( i - xx ) * ( yy - j ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 5 , 7 , 5 , - 1 ] NEW_LINE n = len ( arr ) NEW_LINE sum = 6 NEW_LINE print ( pairs_count ( arr , n , sum ) ) NEW_LINE"],"bleu":0.8240746047989735,"rouge_l":0.8611954083652196}
{"id":1276,"predictions":["MAX = 100005 NEW_LINE fibonacci = set ( ) NEW_LINE def createHash ( ) : NEW_LINE INDENT prev = 0 NEW_LINE curr = 1 NEW_LINE fibonacci . add ( prev ) NEW_LINE fibonacci . add ( curr ) NEW_LINE while ( curr <= MAX ) : NEW_LINE INDENT temp = curr + prev NEW_LINE fibonacci . add ( temp ) NEW_LINE prev = curr NEW_LINE curr = temp NEW_LINE DEDENT DEDENT def checkArray ( arr , n ) : NEW_LINE INDENT Sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] in fibonacci ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE DEDENT DEDENT if ( fibonacci ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 8 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE createHash ( arr , n ) NEW_LINE if ( checkArray ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["MAX = 100005 NEW_LINE fibonacci = set ( ) NEW_LINE def createHash ( ) : NEW_LINE INDENT global fibonacci NEW_LINE prev , curr = 0 , 1 NEW_LINE fibonacci . add ( prev ) NEW_LINE fibonacci . add ( curr ) NEW_LINE while ( curr <= MAX ) : NEW_LINE INDENT temp = curr + prev NEW_LINE if temp <= MAX : NEW_LINE INDENT fibonacci . add ( temp ) NEW_LINE DEDENT prev = curr NEW_LINE curr = temp NEW_LINE DEDENT DEDENT def checkArray ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] in fibonacci ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT DEDENT if ( sum in fibonacci ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 8 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE createHash ( ) NEW_LINE if ( checkArray ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.8611479688360926,"rouge_l":0.9340847260007773}
{"id":1277,"predictions":["def makearrayequal ( arr , n ) : NEW_LINE INDENT x = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x += ( arr [ i ] & 1 ) NEW_LINE DEDENT print ( min ( x , n - x ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 3 , 2 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE makearray ( arr , n ) NEW_LINE DEDENT"],"references":["def makearrayequal ( arr , n ) : NEW_LINE INDENT x = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT x += arr [ i ] & 1 ; NEW_LINE DEDENT print ( min ( x , n - x ) ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 4 , 3 , 2 , 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE makearrayequal ( arr , n ) ; NEW_LINE DEDENT"],"bleu":0.7410898477947104,"rouge_l":0.9194329804414139}
{"id":1278,"predictions":["def countRotations ( arr , n ) : NEW_LINE INDENT min = arr [ 0 ] NEW_LINE min_index = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( min > arr [ i ] ) : NEW_LINE INDENT min_index = arr [ i ] NEW_LINE min_index = i NEW_LINE DEDENT DEDENT return min_index NEW_LINE DEDENT arr = [ 15 , 18 , 2 , 3 , 6 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countRotations ( arr , n ) ) NEW_LINE"],"references":["def countRotations ( arr , n ) : NEW_LINE INDENT min = arr [ 0 ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( min > arr [ i ] ) : NEW_LINE INDENT min = arr [ i ] NEW_LINE min_index = i NEW_LINE DEDENT DEDENT return min_index ; NEW_LINE DEDENT arr = [ 15 , 18 , 2 , 3 , 6 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countRotations ( arr , n ) ) NEW_LINE"],"bleu":0.8779291859545265,"rouge_l":0.9480748851995762}
{"id":1279,"predictions":["def check ( s ) : NEW_LINE INDENT freq = [ 0 for i in range ( 10 ) ] NEW_LINE while ( s != 0 ) : NEW_LINE INDENT r = s % 10 NEW_LINE s = int ( s \/ 10 ) NEW_LINE freq [ r ] += 1 NEW_LINE DEDENT xor__ = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT xor__ = xor__ ^ freq [ i ] NEW_LINE if ( xor__ == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT s = 122233 NEW_LINE if ( check ( s ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def check ( s ) : NEW_LINE INDENT freq = [ 0 ] * 10 NEW_LINE while ( s != 0 ) : NEW_LINE INDENT r = s % 10 NEW_LINE s = s \/\/ 10 NEW_LINE freq [ r ] += 1 NEW_LINE DEDENT xor = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT xor = xor ^ freq [ i ] NEW_LINE DEDENT if ( xor == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT s = 122233 NEW_LINE if ( check ( s ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.7692765523251637,"rouge_l":0.9034177215189875}
{"id":1280,"predictions":["def count ( n ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE p = 1 ; NEW_LINE while ( p <= n ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE p *= 2 ; NEW_LINE DEDENT return cnt ; NEW_LINE DEDENT n = 7 ; NEW_LINE print ( count ( n ) ) ; NEW_LINE"],"references":["def count ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE p = 1 NEW_LINE while ( p <= n ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE p *= 2 NEW_LINE DEDENT return cnt NEW_LINE DEDENT n = 7 NEW_LINE print ( count ( n ) ) ; NEW_LINE"],"bleu":0.688606933345639,"rouge_l":0.9150915091509152}
{"id":1281,"predictions":["def powerSet ( string , index , curr ) : NEW_LINE INDENT if index == n : NEW_LINE INDENT return NEW_LINE DEDENT print ( curr ) NEW_LINE for i in range ( index + 1 , n ) : NEW_LINE INDENT curr += string [ i ] NEW_LINE powerSet ( string , i , curr ) NEW_LINE curr = curr [ : len ( curr ) - 1 ] NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT string = \" abc \" NEW_LINE index = - 1 NEW_LINE curr = \" \" NEW_LINE powerSet ( string , index , curr ) NEW_LINE DEDENT"],"references":["def powerSet ( str1 , index , curr ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE if ( index == n ) : NEW_LINE INDENT return NEW_LINE DEDENT print ( curr ) NEW_LINE for i in range ( index + 1 , n ) : NEW_LINE INDENT curr += str1 [ i ] NEW_LINE powerSet ( str1 , i , curr ) NEW_LINE curr = curr . replace ( curr [ len ( curr ) - 1 ] , \" \" ) NEW_LINE DEDENT return NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" abc \" ; NEW_LINE powerSet ( str , - 1 , \" \" ) NEW_LINE DEDENT"],"bleu":0.6065543418901473,"rouge_l":0.7915445793218919}
{"id":1282,"predictions":["def findMinimumX ( a , n ) : NEW_LINE INDENT st = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT st . add ( a [ i ] ) NEW_LINE DEDENT if ( len ( st ) == 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( len ( st ) == 3 ) : NEW_LINE INDENT for i in st : NEW_LINE INDENT if ( st [ i ] - st1 ) % 2 == 0 : NEW_LINE INDENT return ( el2 - st1 ) \/\/ 2 NEW_LINE DEDENT else : NEW_LINE INDENT return ( st2 - de1 ) NEW_LINE DEDENT DEDENT if ( len ( st ) == 3 ) : NEW_LINE INDENT for i in range ( 1 , n , 1 ) : NEW_LINE INDENT if ( st [ i ] - st1 ) % 2 == 0 ) : NEW_LINE INDENT return ( el2 - st1 ) \/\/ 2 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 4 , 4 , 7 , 4 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( findMinimumX ( a , n ) ) NEW_LINE DEDENT"],"references":["def findMinimumX ( a , n ) : NEW_LINE INDENT st = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT st . add ( a [ i ] ) NEW_LINE DEDENT if ( len ( st ) == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( len ( st ) == 2 ) : NEW_LINE INDENT st = list ( st ) NEW_LINE el1 = st [ 0 ] NEW_LINE el2 = st [ 1 ] NEW_LINE if ( ( el2 - el1 ) % 2 == 0 ) : NEW_LINE INDENT return int ( ( el2 - el1 ) \/ 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( el2 - el1 ) NEW_LINE DEDENT DEDENT if ( len ( st ) == 3 ) : NEW_LINE INDENT st = list ( st ) NEW_LINE el1 = st [ 0 ] NEW_LINE el2 = st [ 1 ] NEW_LINE el3 = st [ 2 ] NEW_LINE if ( ( el2 - el1 ) == ( el3 - el2 ) ) : NEW_LINE INDENT return el2 - el1 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 4 , 4 , 7 , 4 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( findMinimumX ( a , n ) ) NEW_LINE DEDENT"],"bleu":0.6461994574208877,"rouge_l":0.769376822404557}
{"id":1283,"predictions":["def printFirstNegativeInteger ( arr , n , k ) : NEW_LINE INDENT for i in range ( 0 , ( n - k + 1 ) ) : NEW_LINE INDENT flag = False NEW_LINE for j in range ( 0 , k ) : NEW_LINE INDENT if ( arr [ i + j ] < 0 ) : NEW_LINE INDENT print ( arr [ i + j ] , end = \" ▁ \" ) NEW_LINE flag = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == False ) : NEW_LINE INDENT print ( \" \" , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 10 , - 1 , - 7 , 8 , - 10 , 30 , 30 , 31 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE printFirstNegativeInteger ( arr , n , k ) NEW_LINE"],"references":["def printFirstNegativeInteger ( arr , n , k ) : NEW_LINE INDENT for i in range ( 0 , ( n - k + 1 ) ) : NEW_LINE INDENT flag = False NEW_LINE for j in range ( 0 , k ) : NEW_LINE INDENT if ( arr [ i + j ] < 0 ) : NEW_LINE INDENT print ( arr [ i + j ] , end = \" ▁ \" ) NEW_LINE flag = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( not ( flag ) ) : NEW_LINE INDENT print ( \"0\" , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 12 , - 1 , - 7 , 8 , - 15 , 30 , 16 , 28 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE printFirstNegativeInteger ( arr , n , k ) NEW_LINE"],"bleu":0.8873347882378902,"rouge_l":0.9470198675496688}
{"id":1284,"predictions":["def printArray ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE return NEW_LINE DEDENT def printSequencesRecur ( arr , n , k , index ) : NEW_LINE INDENT if ( k == 0 ) : NEW_LINE INDENT printArray ( arr , index ) NEW_LINE DEDENT if ( k > 0 ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT arr [ index ] = i NEW_LINE printSequencesRecur ( arr , n , k - 1 , index + 1 ) NEW_LINE DEDENT DEDENT def printSequences ( n , k ) : NEW_LINE INDENT arr = [ 0 ] * k NEW_LINE printSequencesRecur ( arr , n , k , 0 ) NEW_LINE return ; NEW_LINE DEDENT n = 3 ; NEW_LINE k = 2 ; NEW_LINE printSequences ( arr , n , k ) ; NEW_LINE"],"references":["def printArray ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( \" \" ) ; NEW_LINE return ; NEW_LINE DEDENT def printSequencesRecur ( arr , n , k , index ) : NEW_LINE INDENT if ( k == 0 ) : NEW_LINE INDENT printArray ( arr , index ) ; NEW_LINE DEDENT if ( k > 0 ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT arr [ index ] = i ; NEW_LINE printSequencesRecur ( arr , n , k - 1 , index + 1 ) ; NEW_LINE DEDENT DEDENT DEDENT def printSequences ( n , k ) : NEW_LINE INDENT arr = [ 0 ] * n ; NEW_LINE printSequencesRecur ( arr , n , k , 0 ) ; NEW_LINE return ; NEW_LINE DEDENT n = 3 ; NEW_LINE k = 2 ; NEW_LINE printSequences ( n , k ) ; NEW_LINE"],"bleu":0.8520410427818711,"rouge_l":0.9533878826882412}
{"id":1285,"predictions":["no_of_chars = 256 NEW_LINE def findSubString ( str , pat ) : NEW_LINE INDENT len1 = len ( str1 ) NEW_LINE len2 = len ( pat ) NEW_LINE if ( len1 < len2 ) : NEW_LINE INDENT print ( \" No ▁ such ▁ window ▁ exists \" ) NEW_LINE return \" \" NEW_LINE DEDENT no_of_chars = [ 0 for _ in range ( no_of_f chars ) ] NEW_LINE for i in range ( no_of_chars ) : NEW_LINE INDENT has_sub [ ord ( str1 [ i ] ) ] += 1 NEW_LINE DEDENT for j in range ( 0 , len1 ) : NEW_LINE INDENT has_tr [ ord ( pat [ j ] ) ] += 1 NEW_LINE DEDENT if ( not has2 ) : NEW_LINE INDENT while ( has_tr [ ord ( pat [ 0 ] ) ] > half_tr [ ord ( st [ j ] ) ] ) : NEW_LINE INDENT has_tr [ ord ( st1 [ j ] ) ] -= 1 NEW_LINE DEDENT if ( has_tr [ ord ( st1 [ st1 ] ) ) > 0 ) : NEW_LINE INDENT while ( has_tr [ ord ( st1 [ j ] ) ] > half_tr [ st2 [ j ] ] ) : NEW_LINE INDENT has_tr [ ord ( st1 [ j ] ) ] += 1 NEW_LINE DEDENT DEDENT if ( has2 ) : NEW_LINE INDENT while ( has_tr [ ord ( st1 [ 0 ] ) ] > act_tr [ ord ( st1 [ st1 ] ) ] ) : NEW_LINE INDENT has_tr [ ord ( st1 [ st1 ] ) ] -= 1 NEW_LINE st2 [ st1 ] = 1 NEW_LINE DEDENT if ( not has2 ) : NEW_LINE INDENT length = length NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if ( no_of_chars = 256 NEW_LINE findSubString ( \" Yes \" ) NEW_LINE printSubString ( \" No ▁ such ▁ string \" ) NEW_LINE"],"references":["no_of_chars = 256 NEW_LINE def findSubString ( string , pat ) : NEW_LINE INDENT len1 = len ( string ) NEW_LINE len2 = len ( pat ) NEW_LINE if len1 < len2 : NEW_LINE INDENT print ( \" No ▁ such ▁ window ▁ exists \" ) NEW_LINE return \" \" NEW_LINE DEDENT hash_pat = [ 0 ] * no_of_chars NEW_LINE hash_str = [ 0 ] * no_of_chars NEW_LINE for i in range ( 0 , len2 ) : NEW_LINE INDENT hash_pat [ ord ( pat [ i ] ) ] += 1 NEW_LINE DEDENT start , start_index , min_len = 0 , - 1 , float ( ' inf ' ) NEW_LINE count = 0 NEW_LINE for j in range ( 0 , len1 ) : NEW_LINE INDENT hash_str [ ord ( string [ j ] ) ] += 1 NEW_LINE if ( hash_pat [ ord ( string [ j ] ) ] != 0 and hash_str [ ord ( string [ j ] ) ] <= hash_pat [ ord ( string [ j ] ) ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if count == len2 : NEW_LINE INDENT while ( hash_str [ ord ( string [ start ] ) ] > hash_pat [ ord ( string [ start ] ) ] or hash_pat [ ord ( string [ start ] ) ] == 0 ) : NEW_LINE INDENT if ( hash_str [ ord ( string [ start ] ) ] > hash_pat [ ord ( string [ start ] ) ] ) : NEW_LINE INDENT hash_str [ ord ( string [ start ] ) ] -= 1 NEW_LINE DEDENT start += 1 NEW_LINE DEDENT len_window = j - start + 1 NEW_LINE if min_len > len_window : NEW_LINE INDENT min_len = len_window NEW_LINE start_index = start NEW_LINE DEDENT DEDENT DEDENT if start_index == - 1 : NEW_LINE INDENT print ( \" No ▁ such ▁ window ▁ exists \" ) NEW_LINE return \" \" NEW_LINE DEDENT return string [ start_index : start_index + min_len ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" this ▁ is ▁ a ▁ test ▁ string \" NEW_LINE pat = \" tist \" NEW_LINE print ( \" Smallest ▁ window ▁ is ▁ : ▁ \" ) NEW_LINE print ( findSubString ( string , pat ) ) NEW_LINE DEDENT"],"bleu":0.3933475597510993,"rouge_l":0.583900983927697}
{"id":1286,"predictions":["def productArray ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT print ( 0 ) ; NEW_LINE return ; NEW_LINE DEDENT temp = 1 ; NEW_LINE prod = [ 0 ] * n ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT prod [ i ] = temp ; NEW_LINE temp *= arr [ i ] ; NEW_LINE DEDENT temp = 1 ; NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT prod [ i ] *= temp ; NEW_LINE temp *= arr [ i ] ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( prod [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT arr = [ 10 , 3 , 5 , 6 , 2 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( \" The ▁ product ▁ array ▁ is : \" ) ; NEW_LINE productArray ( arr , n ) ; NEW_LINE"],"references":["def productArray ( arr , n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE return NEW_LINE DEDENT i , temp = 1 , 1 NEW_LINE prod = [ 1 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT prod [ i ] = temp NEW_LINE temp *= arr [ i ] NEW_LINE DEDENT temp = 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT prod [ i ] *= temp NEW_LINE temp *= arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( prod [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT return NEW_LINE DEDENT arr = [ 10 , 3 , 5 , 6 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" The ▁ product ▁ array ▁ is : ▁ n \" ) NEW_LINE productArray ( arr , n ) NEW_LINE"],"bleu":0.7412936443811259,"rouge_l":0.904929895974672}
{"id":1287,"predictions":["def NoofTriplets ( N , K ) : NEW_LINE INDENT cnt = [ 0 ] * K NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT cnt [ i % K ] += 1 NEW_LINE DEDENT if ( K & 1 ) : NEW_LINE INDENT return cnt [ 0 ] * cnt [ 0 ] * cnt [ 0 ] * cnt [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT return ( cnt [ 0 ] * cnt [ 0 ] * cnt [ 0 ] + cnt [ K \/\/ 2 ] * cnt [ K \/\/ 2 ] * cnt [ K \/\/ 2 ] ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 3 NEW_LINE K = 2 NEW_LINE print ( NoofTriplets ( N , K ) ) NEW_LINE DEDENT"],"references":["def NoofTriplets ( N , K ) : NEW_LINE INDENT cnt = [ 0 ] * K ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT cnt [ i % K ] += 1 ; NEW_LINE DEDENT if ( K & 1 ) : NEW_LINE INDENT rslt = cnt [ 0 ] * cnt [ 0 ] * cnt [ 0 ] ; NEW_LINE return rslt NEW_LINE DEDENT else : NEW_LINE INDENT rslt = ( cnt [ 0 ] * cnt [ 0 ] * cnt [ 0 ] + cnt [ K \/\/ 2 ] * cnt [ K \/\/ 2 ] * cnt [ K \/\/ 2 ] ) ; NEW_LINE return rslt NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 3 ; K = 2 ; NEW_LINE print ( NoofTriplets ( N , K ) ) ; NEW_LINE DEDENT"],"bleu":0.7857088382082505,"rouge_l":0.9061969439728353}
{"id":1288,"predictions":["def command ( arr , a , b ) : NEW_LINE INDENT arr [ 0 ] ^= True ; NEW_LINE arr [ b + 1 ] ^= True ; NEW_LINE DEDENT def process ( arr , n ) : NEW_LINE INDENT for k in range ( 1 , n + 1 ) : NEW_LINE INDENT arr [ k ] ^= arr [ k - 1 ] ; NEW_LINE DEDENT DEDENT def result ( arr , n ) : NEW_LINE INDENT for k in range ( 1 , n + 2 ) : NEW_LINE INDENT if ( arr [ k ] == True ) : NEW_LINE INDENT print ( \"1\" , end = \" ▁ \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \"0\" , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 ; NEW_LINE m = 3 ; NEW_LINE arr = [ 0 ] * ( n + 2 ) ; NEW_LINE compare ( arr , 1 , 5 ) ; NEW_LINE compare ( arr , 2 , 5 ) ; NEW_LINE check ( arr , 2 , 5 ) ; NEW_LINE DEDENT"],"references":["def command ( brr , a , b ) : NEW_LINE INDENT arr [ a ] ^= 1 NEW_LINE arr [ b + 1 ] ^= 1 NEW_LINE DEDENT def process ( arr , n ) : NEW_LINE INDENT for k in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT arr [ k ] ^= arr [ k - 1 ] NEW_LINE DEDENT DEDENT def result ( arr , n ) : NEW_LINE INDENT for k in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT print ( arr [ k ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE m = 3 NEW_LINE arr = [ 0 for i in range ( n + 2 ) ] NEW_LINE command ( arr , 1 , 5 ) NEW_LINE command ( arr , 2 , 5 ) NEW_LINE command ( arr , 3 , 5 ) NEW_LINE process ( arr , n ) NEW_LINE result ( arr , n ) NEW_LINE DEDENT"],"bleu":0.6102746284007851,"rouge_l":0.787492664934194}
{"id":1289,"predictions":["def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT n &= ( n - 1 ) NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def countSetBitsInGivenRange ( n , l , r ) : NEW_LINE INDENT num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) NEW_LINE return countSetBits ( n & num ) NEW_LINE DEDENT n = 42 NEW_LINE l = 2 NEW_LINE r = 5 NEW_LINE print ( countSetBitsInGivenRange ( n , l , r ) ) NEW_LINE"],"references":["def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT n &= ( n - 1 ) NEW_LINE count = count + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def countSetBitsInGivenRange ( n , l , r ) : NEW_LINE INDENT num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) NEW_LINE return countSetBits ( n & num ) NEW_LINE DEDENT n = 42 NEW_LINE l = 2 NEW_LINE r = 5 NEW_LINE ans = countSetBitsInGivenRange ( n , l , r ) NEW_LINE print ( ans ) NEW_LINE"],"bleu":0.891179313614855,"rouge_l":0.9408275248405754}
{"id":1290,"predictions":["def dig ( a ) : NEW_LINE INDENT count = 0 NEW_LINE while ( a > 0 ) : NEW_LINE INDENT a \/\/= 10 NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def required_number ( num , n , d ) : NEW_LINE INDENT power = 1 NEW_LINE for i in range ( num , 0 , - 1 ) : NEW_LINE INDENT power = pow ( 10 , i ) NEW_LINE a = n % power NEW_LINE if ( d > a ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT t = 0 NEW_LINE for j in range ( 0 , i ) : NEW_LINE INDENT t += 9 * pow ( 10 , j ) NEW_LINE DEDENT if ( n % power == t ) : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n - ( n % power ) - 1 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 1029 NEW_LINE d = 102 NEW_LINE num = dig ( n ) NEW_LINE required_number ( num , n , d ) NEW_LINE DEDENT"],"references":["def dig ( a ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( a > 0 ) : NEW_LINE INDENT a \/= 10 NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def required_number ( num , n , d ) : NEW_LINE INDENT flag = 0 NEW_LINE power = 0 NEW_LINE a = 0 NEW_LINE for i in range ( num , 0 , - 1 ) : NEW_LINE INDENT power = pow ( 10 , i ) NEW_LINE a = n % power NEW_LINE if ( d > a ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT t = 0 NEW_LINE for j in range ( 0 , i ) : NEW_LINE INDENT t += 9 * pow ( 10 , j ) NEW_LINE DEDENT if ( n % power == t ) : NEW_LINE INDENT print ( n , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( n - ( n % power ) - 1 ) , end = \" \" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( n , end = \" \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 1029 NEW_LINE d = 102 NEW_LINE num = dig ( n ) NEW_LINE required_number ( num , n , d ) NEW_LINE DEDENT"],"bleu":0.817139047159054,"rouge_l":0.9167431030833274}
{"id":1291,"predictions":["def CountZeroBit ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def CountORandSumEqual ( N ) : NEW_LINE INDENT count = CountZeroBit ( N ) NEW_LINE return ( 1 << count ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 10 NEW_LINE print ( CountORSumEqual ( N ) ) NEW_LINE DEDENT"],"references":["def CountZeroBit ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT if ( not ( n & 1 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def CountORandSumEqual ( N ) : NEW_LINE INDENT count = CountZeroBit ( N ) NEW_LINE return ( 1 << count ) NEW_LINE DEDENT N = 10 NEW_LINE print ( CountORandSumEqual ( N ) ) NEW_LINE"],"bleu":0.7826587473323241,"rouge_l":0.8993210475266733}
{"id":1292,"predictions":["def checkConcurrent ( a1 , b1 , c1 , a2 , b2 , c2 , c3 ) : NEW_LINE INDENT return ( a3 * ( b1 * c2 - b2 * c1 ) + b3 * ( c1 * a2 - c2 * a1 ) == 0 ) NEW_LINE DEDENT a1 = 2 NEW_LINE b1 = - 3 NEW_LINE c1 = 5 NEW_LINE a2 = 4 NEW_LINE b2 = 4 NEW_LINE c2 = - 7 NEW_LINE a3 = - 7 NEW_LINE b3 = - 7 NEW_LINE if ( checkConcurrent ( a1 , b1 , c1 , a2 , b2 , c3 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def checkConcurrent ( a1 , b1 , c1 , a2 , b2 , c2 , a3 , b3 , c3 ) : NEW_LINE INDENT return ( a3 * ( b1 * c2 - b2 * c1 ) + b3 * ( c1 * a2 - c2 * a1 ) + c3 * ( a1 * b2 - a2 * b1 ) == 0 ) NEW_LINE DEDENT a1 = 2 NEW_LINE b1 = - 3 NEW_LINE c1 = 5 NEW_LINE a2 = 3 NEW_LINE b2 = 4 NEW_LINE c2 = - 7 NEW_LINE a3 = 9 NEW_LINE b3 = - 5 NEW_LINE c3 = 8 NEW_LINE if ( checkConcurrent ( a1 , b1 , c1 , a2 , b2 , c2 , a3 , b3 , c3 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.7499770278533403,"rouge_l":0.8667598416026089}
{"id":1293,"predictions":["def winner ( moves ) : NEW_LINE INDENT data = dict ( ) NEW_LINE data = { } NEW_LINE d [ 0 ] = 1 NEW_LINE data [ 1 ] = 1 NEW_LINE if ( moves [ 0 ] == moves [ 1 ] ) : NEW_LINE INDENT return \" Draw \" NEW_LINE DEDENT if ( ( data [ 0 ] ] | 1 << ( 2 ) ) - ( 2 ) % 3 != 0 ) : NEW_LINE INDENT return \" A \" NEW_LINE DEDENT if ( ( data [ ord ( data [ 0 ] ) ] | 1 << ( 2 ) ) - ( data [ 1 ] ) ) % 3 != 0 ) : NEW_LINE INDENT return \" A \" NEW_LINE DEDENT return \" B \" NEW_LINE DEDENT def performQueries ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( winner ( arr [ i ] ) , end = \" \" ) NEW_LINE DEDENT DEDENT arr = [ \" RS \" , \" SR \" , \" SP \" , \" PP \" ] NEW_LINE n = len ( arr ) NEW_LINE performQueries ( arr , n ) NEW_LINE"],"references":["def winner ( moves ) : NEW_LINE INDENT data = dict ( ) NEW_LINE data [ ' R ' ] = 0 NEW_LINE data [ ' P ' ] = 1 NEW_LINE data [ ' S ' ] = 2 NEW_LINE if ( moves [ 0 ] == moves [ 1 ] ) : NEW_LINE INDENT return \" Draw \" NEW_LINE DEDENT if ( ( ( data [ moves [ 0 ] ] | 1 << ( 2 ) ) - ( data [ moves [ 1 ] ] | 0 << ( 2 ) ) ) % 3 ) : NEW_LINE INDENT return \" A \" NEW_LINE DEDENT return \" B \" NEW_LINE DEDENT def performQueries ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( winner ( arr [ i ] ) ) NEW_LINE DEDENT DEDENT arr = [ \" RS \" , \" SR \" , \" SP \" , \" PP \" ] NEW_LINE n = len ( arr ) NEW_LINE performQueries ( arr , n ) NEW_LINE"],"bleu":0.7216193525368246,"rouge_l":0.8426707597851113}
{"id":1294,"predictions":["MAX = 10000 NEW_LINE catalan = [ 0 for i in range ( MAX ) ] NEW_LINE def catalanDP [ n ] = 1 NEW_LINE def catalanDP ( n ) : NEW_LINE INDENT catalan [ 0 ] = catalan [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT catalan [ i ] = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT catalan [ i ] += ( catalan [ j ] * catalan [ i - j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT def CamelSequence ( arr , n ) : NEW_LINE INDENT catalanDP ( n ) NEW_LINE s = set ( ) NEW_LINE s . add ( a ) NEW_LINE if n >= 2 : NEW_LINE INDENT s . add ( b ) NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT s . remove ( catalan [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] in s . keys ( ) ) : NEW_LINE INDENT s . remove ( arr [ i ] ) NEW_LINE DEDENT DEDENT return len ( s ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 1 , 2 , 5 , 41 ] NEW_LINE n = len ( arr ) NEW_LINE print (illesSequence ( arr , n ) ) NEW_LINE DEDENT"],"references":["MAX = 100000 ; NEW_LINE catalan = [ 0 ] * MAX ; NEW_LINE def catalanDP ( n ) : NEW_LINE INDENT catalan [ 0 ] = catalan [ 1 ] = 1 ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT catalan [ i ] = 0 ; NEW_LINE for j in range ( i ) : NEW_LINE INDENT catalan [ i ] += ( catalan [ j ] * catalan [ i - j - 1 ] ) ; NEW_LINE DEDENT DEDENT DEDENT def CatalanSequence ( arr , n ) : NEW_LINE INDENT catalanDP ( n ) ; NEW_LINE s = set ( ) ; NEW_LINE a = 1 ; b = 1 ; NEW_LINE s . add ( a ) ; NEW_LINE if ( n >= 2 ) : NEW_LINE INDENT s . add ( b ) ; NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT s . add ( catalan [ i ] ) ; NEW_LINE DEDENT temp = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in s : NEW_LINE INDENT temp . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT s = s - temp ; NEW_LINE return len ( s ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 1 , 2 , 5 , 41 ] ; NEW_LINE n = len ( arr ) NEW_LINE print ( CatalanSequence ( arr , n ) ) ; NEW_LINE DEDENT"],"bleu":0.691805810995885,"rouge_l":0.8489439004864833}
{"id":1295,"predictions":["def removeAnagrams ( arr , N ) : NEW_LINE INDENT ans = [ ] NEW_LINE found = set ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT word = arr [ i ] NEW_LINE word = sorted ( word ) NEW_LINE if word not in found : NEW_LINE INDENT ans . add ( word ) NEW_LINE found . add ( word ) NEW_LINE DEDENT DEDENT ans = sorted ( ans ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ \" geeks \" , \" keegs \" , \" code \" ] NEW_LINE N = len ( arr ) NEW_LINE removeAnagrams ( arr , N ) NEW_LINE DEDENT"],"references":["def removeAnagrams ( arr , N ) : NEW_LINE INDENT ans = [ ] NEW_LINE found = dict ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT word = arr [ i ] NEW_LINE word = \" ▁ \" . join ( sorted ( word ) ) NEW_LINE if ( word not in found ) : NEW_LINE INDENT ans . append ( arr [ i ] ) NEW_LINE found [ word ] = 1 NEW_LINE DEDENT DEDENT ans = sorted ( ans ) NEW_LINE for i in range ( len ( ans ) ) : NEW_LINE INDENT print ( ans [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ \" geeks \" , \" keegs \" , \" code \" , \" doce \" ] NEW_LINE N = 4 NEW_LINE removeAnagrams ( arr , N ) NEW_LINE DEDENT"],"bleu":0.5495670158084695,"rouge_l":0.7512315270935962}
{"id":1296,"predictions":["def findMaximumNum ( arr , n ) : NEW_LINE INDENT for i in range ( n , 0 , - 1 , - 1 ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( i <= arr [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count >= i ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 8 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMaximumNum ( arr , n ) ) NEW_LINE"],"references":["def findMaximumNum ( arr , n ) : NEW_LINE INDENT i = n NEW_LINE while ( i >= 1 ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( i <= arr [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count >= i ) : NEW_LINE INDENT return i NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 8 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMaximumNum ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.7329562790505368,"rouge_l":0.8343591847900425}
{"id":1297,"predictions":["def printSubArrays ( arr , start , end ) : NEW_LINE INDENT if ( end == len ( arr ) ) : NEW_LINE INDENT return NEW_LINE DEDENT elif ( start > end ) : NEW_LINE INDENT print ( arr [ end ] , end = \" ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" [ \" , end = \" \" ) NEW_LINE for i in range ( start , end ) : NEW_LINE INDENT print ( arr [ i ] , end = \" , ▁ \" ) NEW_LINE DEDENT print ( arr [ end ] , end = \" \" ) NEW_LINE printSubArrays ( arr , start + 1 , end = \" \" ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 ] NEW_LINE printSubArrays ( arr , 0 , 0 ) NEW_LINE"],"references":["def printSubArrays ( arr , start , end ) : NEW_LINE INDENT if end == len ( arr ) : NEW_LINE INDENT return NEW_LINE DEDENT elif start > end : NEW_LINE INDENT return printSubArrays ( arr , 0 , end + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ start : end + 1 ] ) NEW_LINE return printSubArrays ( arr , start + 1 , end ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 ] NEW_LINE printSubArrays ( arr , 0 , 0 ) NEW_LINE"],"bleu":0.47432489725085336,"rouge_l":0.7363126886046846}
{"id":1298,"predictions":["import math NEW_LINE def setBit ( xorValue ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( xorValue >= 1 ) : NEW_LINE INDENT if ( xorValue % 2 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT xorValue \/= 2 ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT def minFlip ( n , k ) : NEW_LINE INDENT size = int ( math . log ( n , 2 ) ) + 1 ; NEW_LINE max = int ( math . pow ( 2 , k ) - 1 ) - 1 ; NEW_LINE xorValue = ( n ^ max ) ; NEW_LINE return ( setBit ( xorValue ) ) ; NEW_LINE DEDENT n = 27 ; NEW_LINE k = 3 ; NEW_LINE print ( \" Min ▁ flips ▁ = \" , minFlip ( n , k ) ) ; NEW_LINE"],"references":["import math NEW_LINE def setBit ( xorValue ) : NEW_LINE INDENT count = 0 NEW_LINE while ( xorValue ) : NEW_LINE INDENT if ( xorValue % 2 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT xorValue = int ( xorValue \/ 2 ) NEW_LINE DEDENT return count NEW_LINE DEDENT def minFlip ( n , k ) : NEW_LINE INDENT size = int ( math . log ( n ) \/ math . log ( 2 ) + 1 ) NEW_LINE max = pow ( 2 , k ) - 1 NEW_LINE max = max << ( size - k ) NEW_LINE xorValue = ( n ^ max ) NEW_LINE return ( setBit ( xorValue ) ) NEW_LINE DEDENT n = 27 NEW_LINE k = 3 NEW_LINE print ( \" Min ▁ Flips ▁ = ▁ \" , minFlip ( n , k ) ) NEW_LINE"],"bleu":0.6662039101073259,"rouge_l":0.8379686972187816}
{"id":1299,"predictions":["def isVowel ( x ) : NEW_LINE INDENT if ( x == ' a ' or x == ' e ' or x == ' i ' or x == ' o ' or x == ' u ' ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def updateDropRequiredVowels ( a ) : NEW_LINE INDENT n = len ( a ) NEW_LINE manipulatedString = \" \" NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i == 0 or i == n - 1 ) : NEW_LINE INDENT updateString += a [ i ] NEW_LINE continue NEW_LINE DEDENT if ( isVowel ( a [ i ] ) == True and isVowel ( a [ i - 1 ] ) == False and isVowel ( a [ i + 1 ] ) == False and isVowel ( a [ i + 1 ] ) == False ) : NEW_LINE INDENT continue NEW_LINE DEDENT modifiedString += a [ i ] NEW_LINE DEDENT return ModifiedString NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" geeksforgeeks \" NEW_LINE modifiedString = updateAndBoundRepeatVowels ( str ) NEW_LINE print ( ModifiedString ) NEW_LINE DEDENT"],"references":["def isVowel ( x ) : NEW_LINE INDENT if ( x == ' a ' or x == ' e ' or x == ' i ' or x == ' o ' or x == ' u ' ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def updateSandwichedVowels ( a ) : NEW_LINE INDENT n = len ( a ) NEW_LINE updatedString = \" \" NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( i == 0 or i == n - 1 ) : NEW_LINE INDENT updatedString += a [ i ] NEW_LINE continue NEW_LINE DEDENT if ( isVowel ( a [ i ] ) == True and isVowel ( a [ i - 1 ] ) == False and isVowel ( a [ i + 1 ] ) == False ) : NEW_LINE INDENT continue NEW_LINE DEDENT updatedString += a [ i ] NEW_LINE DEDENT return updatedString NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" geeksforgeeks \" NEW_LINE updatedString = updateSandwichedVowels ( str ) NEW_LINE print ( updatedString ) NEW_LINE DEDENT"],"bleu":0.8388619267148478,"rouge_l":0.9252066447315623}
{"id":1300,"predictions":["def totalWays ( N , M , X ) : NEW_LINE INDENT dp = [ [ [ 0 ] for i in range ( 2 ) ] for i in range ( N + 1 ) ] NEW_LINE if ( X == 1 ) : NEW_LINE INDENT dp [ 0 ] [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 0 ] [ 1 ] = 0 NEW_LINE DEDENT if ( X == 1 ) : NEW_LINE INDENT dp [ 1 ] [ 0 ] = 0 NEW_LINE dp [ 1 ] [ 1 ] = M - 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 1 ] [ 0 ] = 1 NEW_LINE dp [ 1 ] [ 1 ] = ( M - 2 ) NEW_LINE DEDENT for i in range ( 2 , N ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] NEW_LINE dp [ i ] [ 1 ] = ( dp [ i - 1 ] [ 0 ] * ( M - 1 ) + dp [ i - 1 ] [ 1 ] * ( M - 2 ) NEW_LINE DEDENT return dp [ N - 1 ] [ 0 ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 4 NEW_LINE M = 3 NEW_LINE X = 2 NEW_LINE print ( totalWays ( N , M , X ) ) NEW_LINE DEDENT"],"references":["def totalWays ( N , M , X ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 2 ) ] for j in range ( N + 1 ) ] NEW_LINE if ( X == 1 ) : NEW_LINE INDENT dp [ 0 ] [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 0 ] [ 1 ] = 0 NEW_LINE DEDENT if ( X == 1 ) : NEW_LINE INDENT dp [ 1 ] [ 0 ] = 0 NEW_LINE dp [ 1 ] [ 1 ] = M - 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 1 ] [ 0 ] = 1 NEW_LINE dp [ 1 ] [ 1 ] = ( M - 2 ) NEW_LINE DEDENT for i in range ( 2 , N ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] NEW_LINE dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] * ( M - 1 ) + dp [ i - 1 ] [ 1 ] * ( M - 2 ) NEW_LINE DEDENT return dp [ N - 1 ] [ 0 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE M = 3 NEW_LINE X = 2 NEW_LINE print ( totalWays ( N , M , X ) ) NEW_LINE DEDENT"],"bleu":0.945789909978527,"rouge_l":0.9833634253288623}
{"id":1301,"predictions":["def findMinimal ( a , n ) : NEW_LINE INDENT a . sort ( reverse = False ) NEW_LINE sum = 0 NEW_LINE for i in range ( int ( n \/ 2 ) ) : NEW_LINE INDENT sum += ( ( a [ i ] + a [ n - i - 1 ] ) * ( a [ i ] + a [ n - i - 1 ] ) ) NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 8 , 5 , 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE print ( findMinimal ( a , n ) ) NEW_LINE DEDENT"],"references":["def findMinimal ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n \/\/ 2 ) : NEW_LINE INDENT sum += ( ( a [ i ] + a [ n - i - 1 ] ) * ( a [ i ] + a [ n - i - 1 ] ) ) NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 8 , 5 , 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE print ( findMinimal ( a , n ) ) NEW_LINE DEDENT"],"bleu":0.8666982590818656,"rouge_l":0.9539164129532245}
{"id":1302,"predictions":["def minOperations ( str , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( str [ i ] != str [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return ( count + 1 ) \/\/ 2 NEW_LINE DEDENT str = \"000111\" NEW_LINE n = len ( str ) NEW_LINE print ( minOperations ( str , n ) ) NEW_LINE"],"references":["def minOperations ( str , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( str [ i ] != str [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return ( count + 1 ) \/\/ 2 NEW_LINE DEDENT str = \"000111\" NEW_LINE n = len ( str ) NEW_LINE print ( minOperations ( str , n ) ) NEW_LINE"],"bleu":1.0,"rouge_l":1.0}
{"id":1303,"predictions":["def toDecimal ( binary , i ) : NEW_LINE INDENT n = len ( binary ) NEW_LINE if ( i == n - 1 ) : NEW_LINE INDENT return binary [ i ] - ord ( '0' ) NEW_LINE DEDENT return ( ( binary [ i ] ) << ( n - i - 1 ) ) NEW_LINE DEDENT binary = \"1010\" NEW_LINE i = 0 NEW_LINE print ( toDecimal ( binary , i ) ) NEW_LINE"],"references":["def toDecimal ( binary , i = 0 ) : NEW_LINE INDENT n = len ( binary ) NEW_LINE if ( i == n - 1 ) : NEW_LINE INDENT return int ( binary [ i ] ) - 0 NEW_LINE DEDENT return ( ( ( int ( binary [ i ] ) - 0 ) << ( n - i - 1 ) ) + toDecimal ( binary , i + 1 ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT binary = \"1010\" NEW_LINE print ( toDecimal ( binary ) ) NEW_LINE DEDENT"],"bleu":0.5542956866313438,"rouge_l":0.7255458902893663}
{"id":1304,"predictions":["def countPairs ( n ) : NEW_LINE INDENT num = ( ( n \/\/ 2 ) + 1 ) NEW_LINE max = n % num NEW_LINE count = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT val = ( ( n % i ) % n ) % n NEW_LINE if ( val == max ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT n = 5 NEW_LINE print ( countPairs ( n ) ) NEW_LINE"],"references":["def countPairs ( n ) : NEW_LINE INDENT num = ( ( n \/\/ 2 ) + 1 ) NEW_LINE Max = n % num NEW_LINE count = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT val = ( ( n % i ) % j ) % n NEW_LINE if ( val == Max ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT n = 5 NEW_LINE print ( countPairs ( n ) ) NEW_LINE"],"bleu":0.9265826073578605,"rouge_l":0.9711538461538461}
{"id":1305,"predictions":["def createHash ( hash1 , maxElement ) : NEW_LINE INDENT prev = 0 NEW_LINE curr = 1 NEW_LINE hash1 . add ( prev ) NEW_LINE hash1 . add ( curr ) NEW_LINE while ( curr <= maxElement ) : NEW_LINE INDENT temp = curr + prev NEW_LINE hash1 . add ( temp ) NEW_LINE prev = curr NEW_LINE curr = temp NEW_LINE DEDENT DEDENT def fibonacci ( arr , n ) : NEW_LINE INDENT max_val = max ( arr ) NEW_LINE hash1 = set ( ) NEW_LINE createHash ( hash1 , max_val ) NEW_LINE minimum = 10 ** 9 NEW_LINE maximum = - 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] in hash1 ) : NEW_LINE INDENT minimum = min ( minimum , arr [ i ] ) NEW_LINE maximum = max ( maximum , arr [ i ] ) NEW_LINE DEDENT DEDENT print ( minimum , maximum ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE fibonacci ( arr , n ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE def createHash ( hash , maxElement ) : NEW_LINE INDENT prev = 0 NEW_LINE curr = 1 NEW_LINE hash . add ( prev ) NEW_LINE hash . add ( curr ) NEW_LINE while ( curr <= maxElement ) : NEW_LINE INDENT temp = curr + prev NEW_LINE hash . add ( temp ) NEW_LINE prev = curr NEW_LINE curr = temp NEW_LINE DEDENT DEDENT def fibonacci ( arr , n ) : NEW_LINE INDENT max_val = max ( arr ) NEW_LINE hash = set ( ) NEW_LINE createHash ( hash , max_val ) NEW_LINE minimum = sys . maxsize NEW_LINE maximum = - sys . maxsize - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] in hash ) : NEW_LINE INDENT minimum = min ( minimum , arr [ i ] ) NEW_LINE maximum = max ( maximum , arr [ i ] ) NEW_LINE DEDENT DEDENT print ( minimum , end = \" , ▁ \" ) NEW_LINE print ( maximum ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE fibonacci ( arr , n ) NEW_LINE DEDENT"],"bleu":0.8038888241453093,"rouge_l":0.8996914741515538}
{"id":1306,"predictions":["def printInSortedOrder ( arr , n ) : NEW_LINE INDENT index = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT index [ i ] = i NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT min = i NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ index [ min ] ] > arr [ index [ j ] ] ) : NEW_LINE INDENT min = j NEW_LINE DEDENT DEDENT if ( min != i ) : NEW_LINE INDENT temp = index [ min ] NEW_LINE index [ min ] = index [ i ] NEW_LINE index [ min ] = index [ i ] NEW_LINE index [ i ] = temp NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ index [ i ] ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ \" geeks \" , \" quiz \" , \" geeks \" , \" for \" ] NEW_LINE n = 4 NEW_LINE printInSortedOrder ( arr , n ) NEW_LINE DEDENT"],"references":["def printInSortedOrder ( arr , n ) : NEW_LINE INDENT index = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT index [ i ] = i NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT min = i NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ index [ min ] ] > arr [ index [ j ] ] ) : NEW_LINE INDENT min = j NEW_LINE DEDENT DEDENT if ( min != i ) : NEW_LINE INDENT index [ min ] , index [ i ] = index [ i ] , index [ min ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ index [ i ] ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ \" geeks \" , \" quiz \" , \" geeks \" , \" for \" ] NEW_LINE n = 4 NEW_LINE printInSortedOrder ( arr , n ) NEW_LINE DEDENT"],"bleu":0.8348566136924621,"rouge_l":0.9281446666135585}
{"id":1307,"predictions":["def binomialCoeff ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT res *= ( n - i ) NEW_LINE res \/= ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT def countPaths ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT m = abs ( x1 - x2 ) NEW_LINE n = abs ( y1 - y2 ) NEW_LINE return ( binomialCoeff ( m + n , n ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x1 = 2 NEW_LINE y1 = 3 NEW_LINE x2 = 4 NEW_LINE y2 = 5 NEW_LINE print ( countPaths ( x1 , y1 , x2 , y2 ) ) NEW_LINE DEDENT"],"references":["def binomialCoeff ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT res *= ( n - i ) NEW_LINE res \/\/= ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT def countPaths ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT m = abs ( x1 - x2 ) NEW_LINE n = abs ( y1 - y2 ) NEW_LINE return ( binomialCoeff ( m + n , n ) ) NEW_LINE DEDENT x1 , y1 , x2 , y2 = 2 , 3 , 4 , 5 NEW_LINE print ( countPaths ( x1 , y1 , x2 , y2 ) ) NEW_LINE"],"bleu":0.8041997176682819,"rouge_l":0.8905109489051094}
{"id":1308,"predictions":["def findN ( k ) : NEW_LINE INDENT if ( k == 0 ) : NEW_LINE INDENT ans = 3 ; NEW_LINE if ( k == 1 ) : NEW_LINE INDENT ans = 1 ; NEW_LINE DEDENT if ( k == 1 ) : NEW_LINE INDENT ans = 1 ; NEW_LINE DEDENT elif ( k % 4 == 3 ) : NEW_LINE INDENT ans = k - 1 ; NEW_LINE DEDENT elif ( k % 4 == 3 ) : NEW_LINE INDENT ans = k - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT ans = - 1 ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT k = 7 ; NEW_LINE res = findN ( k ) ; NEW_LINE if ( res == - 1 ) : NEW_LINE INDENT print ( \" Not ▁ possible \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( res ) ; NEW_LINE DEDENT DEDENT"],"references":["def findN ( k ) : NEW_LINE INDENT if ( k == 0 ) : NEW_LINE INDENT ans = 3 NEW_LINE DEDENT if ( k == 1 ) : NEW_LINE INDENT ans = 1 NEW_LINE DEDENT elif ( k % 4 == 0 ) : NEW_LINE INDENT ans = k NEW_LINE DEDENT elif ( k % 4 == 3 ) : NEW_LINE INDENT ans = k - 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT k = 7 NEW_LINE res = findN ( k ) NEW_LINE if ( res == - 1 ) : NEW_LINE INDENT print ( \" Not ▁ possible \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res ) NEW_LINE DEDENT"],"bleu":0.6388598636169027,"rouge_l":0.8769855072463768}
{"id":1309,"predictions":["def print_asterisk ( asterisk ) : NEW_LINE INDENT if ( asterisk == 0 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT print ( \" * ▁ \" , end = \" \" ) ; NEW_LINE print_asterisk ( asterisk - 1 ) ; NEW_LINE DEDENT def print_space ( space ) : NEW_LINE INDENT if ( space == 0 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT print ( \" ▁ \" , end = \" \" ) ; NEW_LINE print ( end = \" ▁ \" ) ; NEW_LINE print_space ( space - 1 ) ; NEW_LINE DEDENT def pattern ( n , num ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT print_asterisk ( num - n + 1 ) ; NEW_LINE print_space ( 2 * n - 1 ) ; NEW_LINE print_space ( num - n + 1 ) ; NEW_LINE print ( ) ; NEW_LINE pattern ( n - 1 , num ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 ; NEW_LINE pattern ( n , n ) ; NEW_LINE DEDENT"],"references":["def print_asterisk ( asterisk ) : NEW_LINE INDENT if ( asterisk == 0 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT print ( \" * \" , end = \" ▁ \" ) ; NEW_LINE print_asterisk ( asterisk - 1 ) ; NEW_LINE DEDENT def print_space ( space ) : NEW_LINE INDENT if ( space == 0 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT print ( \" ▁ \" , end = \" \" ) ; NEW_LINE print ( \" ▁ \" , end = \" \" ) ; NEW_LINE print_space ( space - 1 ) ; NEW_LINE DEDENT def pattern ( n , num ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT print_asterisk ( num - n + 1 ) ; NEW_LINE print_space ( 2 * n - 1 ) ; NEW_LINE print_asterisk ( num - n + 1 ) ; NEW_LINE print ( ) ; NEW_LINE pattern ( n - 1 , num ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 ; NEW_LINE pattern ( n , n ) ; NEW_LINE DEDENT"],"bleu":0.956187922702165,"rouge_l":0.9755071121959431}
{"id":1310,"predictions":["def isMultipleOf3 ( n ) : NEW_LINE INDENT odd_count = 0 NEW_LINE even_count = 0 NEW_LINE if ( n < 0 ) : NEW_LINE INDENT n = - n NEW_LINE DEDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( n != 0 ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT odd_count += 1 NEW_LINE DEDENT if ( n & 2 ) : NEW_LINE INDENT even_count += 1 NEW_LINE DEDENT n = n >> 2 NEW_LINE DEDENT return isMultipleOf3 ( abs ( odd_count - even_count ) ) NEW_LINE DEDENT num = 24 NEW_LINE if ( isMultipleOf3 ( num ) ) : NEW_LINE INDENT print ( num , \" is ▁ multiple ▁ of ▁ 3\" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( num , \" is ▁ not ▁ a ▁ multiple ▁ of ▁ 3\" ) NEW_LINE DEDENT"],"references":["def isMultipleOf3 ( n ) : NEW_LINE INDENT odd_count = 0 NEW_LINE even_count = 0 NEW_LINE if ( n < 0 ) : NEW_LINE INDENT n = - n NEW_LINE DEDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT odd_count += 1 NEW_LINE DEDENT if ( n & 2 ) : NEW_LINE INDENT even_count += 1 NEW_LINE DEDENT n = n >> 2 NEW_LINE DEDENT return isMultipleOf3 ( abs ( odd_count - even_count ) ) NEW_LINE DEDENT num = 24 NEW_LINE if ( isMultipleOf3 ( num ) ) : NEW_LINE INDENT print ( num , ' is ▁ multiple ▁ of ▁ 3' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( num , ' is ▁ not ▁ a ▁ multiple ▁ of ▁ 3' ) NEW_LINE DEDENT"],"bleu":0.9170474754714615,"rouge_l":0.9705794055839088}
{"id":1311,"predictions":["def findNumber ( N , S ) : NEW_LINE INDENT i = ( ( N ) * ( N + 1 ) ) \/ 4 ) - ( ( S + 1 ) \/ 4 ) NEW_LINE return i NEW_LINE DEDENT def check ( N , S ) : NEW_LINE INDENT i = findNumber ( N , S ) NEW_LINE integerI = i NEW_LINE if ( i - integerI == 0 ) : NEW_LINE INDENT print ( \" Yes : ▁ \" , int ( integerI + 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE S = 3 NEW_LINE check ( N , S ) NEW_LINE N = 5 NEW_LINE S = 3 NEW_LINE check ( N , S ) NEW_LINE DEDENT"],"references":["def findNumber ( N , S ) : NEW_LINE INDENT i = ( ( ( N ) * ( N + 1 ) ) \/ 4 ) - ( ( S + 1 ) \/ 2 ) ; NEW_LINE return i ; NEW_LINE DEDENT def check ( N , S ) : NEW_LINE INDENT i = findNumber ( N , S ) ; NEW_LINE integerI = int ( i ) ; NEW_LINE if ( i - integerI == 0 ) : NEW_LINE INDENT print ( \" Yes : \" , integerI , \" , \" , integerI + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 4 ; NEW_LINE S = 3 ; NEW_LINE check ( N , S ) ; NEW_LINE N = 5 ; NEW_LINE S = 3 ; NEW_LINE check ( N , S ) ; NEW_LINE DEDENT"],"bleu":0.6890373439108906,"rouge_l":0.8895963849234877}
{"id":1312,"predictions":["import sys NEW_LINE def thirdLargest ( arr , arr_size ) : NEW_LINE INDENT if ( arr_size < 3 ) : NEW_LINE INDENT print ( \" ▁ Invalid ▁ Input ▁ \" ) NEW_LINE return NEW_LINE DEDENT first = arr [ 0 ] NEW_LINE second = - sys . maxsize NEW_LINE third = - sys . maxsize NEW_LINE for i in range ( 1 , arr_size ) : NEW_LINE INDENT if ( arr [ i ] > first ) : NEW_LINE INDENT second = second NEW_LINE second = second NEW_LINE first = first NEW_LINE DEDENT elif ( arr [ i ] > second ) : NEW_LINE INDENT third = arr [ i ] NEW_LINE second = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > second ) : NEW_LINE INDENT third = arr [ i ] NEW_LINE DEDENT DEDENT print ( \" The ▁ Third ▁ Largest ▁ element ▁ is \" , third ) NEW_LINE"],"references":["import sys NEW_LINE def thirdLargest ( arr , arr_size ) : NEW_LINE INDENT if ( arr_size < 3 ) : NEW_LINE INDENT print ( \" ▁ Invalid ▁ Input ▁ \" ) NEW_LINE return NEW_LINE DEDENT first = arr [ 0 ] NEW_LINE second = - sys . maxsize NEW_LINE third = - sys . maxsize NEW_LINE for i in range ( 1 , arr_size ) : NEW_LINE INDENT if ( arr [ i ] > first ) : NEW_LINE INDENT third = second NEW_LINE second = first NEW_LINE first = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > second ) : NEW_LINE INDENT third = second NEW_LINE second = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > third ) : NEW_LINE INDENT third = arr [ i ] NEW_LINE DEDENT DEDENT print ( \" The ▁ third ▁ Largest \" , \" element ▁ is \" , third ) NEW_LINE DEDENT arr = [ 12 , 13 , 1 , 10 , 34 , 16 ] NEW_LINE n = len ( arr ) NEW_LINE thirdLargest ( arr , n ) NEW_LINE"],"bleu":0.7377142647518397,"rouge_l":0.8348489023606136}
{"id":1313,"predictions":["def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return gcd ( a - b , b ) NEW_LINE DEDENT return gcd ( a , b - a ) NEW_LINE DEDENT def squarearea ( l , b ) : NEW_LINE INDENT if ( l < 0 or b < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT n = ( l * b ) \/\/ gcd ( l , b ) NEW_LINE return n * n NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT l = 6 NEW_LINE b = 4 NEW_LINE print ( squarearea ( l , b ) ) NEW_LINE DEDENT"],"references":["def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return gcd ( a - b , b ) NEW_LINE DEDENT return gcd ( a , b - a ) NEW_LINE DEDENT def squarearea ( l , b ) : NEW_LINE INDENT if ( l < 0 or b < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT n = ( l * b ) \/ gcd ( l , b ) NEW_LINE return n * n NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT l = 6 NEW_LINE b = 4 NEW_LINE print ( int ( squarearea ( l , b ) ) ) NEW_LINE DEDENT"],"bleu":0.9575790741223198,"rouge_l":0.9819829424307037}
{"id":1314,"predictions":["def countUnsetBits ( n ) : NEW_LINE INDENT x = n NEW_LINE n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE return 8 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 17 NEW_LINE print ( countUnsetBits ( n ) ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def countUnsetBits ( n ) : NEW_LINE INDENT x = n NEW_LINE n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE t = math . log ( x ^ n , 2 ) NEW_LINE return math . floor ( t ) NEW_LINE DEDENT n = 17 NEW_LINE print ( countUnsetBits ( n ) ) NEW_LINE"],"bleu":0.6805773951562843,"rouge_l":0.7487080103359174}
{"id":1315,"predictions":["N = 1000001 NEW_LINE visited = [ 0 for i in range ( N ) ] NEW_LINE reachTo = [ 0 for i in range ( N ) ] NEW_LINE def dfs ( i ) : NEW_LINE INDENT if ( visited [ i ] == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT visited [ i ] = 1 NEW_LINE x = dfs ( skipTo [ i ] ) NEW_LINE return ( x + 1 ) NEW_LINE DEDENT def noOfTranspositions ( P , n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT traverse [ i ] = 0 NEW_LINE DEDENT for i in range ( 0 , n + 1 ) : NEW_LINE INDENT if ( visited [ i ] == 0 ) : NEW_LINE INDENT ans = dfs ( i ) NEW_LINE transpositions += ans - 1 NEW_LINE DEDENT DEDENT return transpositions NEW_LINE DEDENT permutation = [ 5 , 1 , 4 , 3 , 2 ] NEW_LINE n = len ( permutation ) NEW_LINE print ( noOfTranspositions ( permutation , n ) ) NEW_LINE"],"references":["N = 1000001 NEW_LINE visited = [ 0 ] * N ; NEW_LINE goesTo = [ 0 ] * N ; NEW_LINE def dfs ( i ) : NEW_LINE INDENT if ( visited [ i ] == 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT visited [ i ] = 1 ; NEW_LINE x = dfs ( goesTo [ i ] ) ; NEW_LINE return ( x + 1 ) ; NEW_LINE DEDENT def noOfTranspositions ( P , n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT visited [ i ] = 0 ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT goesTo [ P [ i ] ] = i + 1 ; NEW_LINE DEDENT transpositions = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( visited [ i ] == 0 ) : NEW_LINE INDENT ans = dfs ( i ) ; NEW_LINE transpositions += ans - 1 ; NEW_LINE DEDENT DEDENT return transpositions ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT permutation = [ 5 , 1 , 4 , 3 , 2 ] ; NEW_LINE n = len ( permutation ) ; NEW_LINE print ( noOfTranspositions ( permutation , n ) ) ; NEW_LINE DEDENT"],"bleu":0.606795146148904,"rouge_l":0.7938452116665391}
{"id":1316,"predictions":["def getCount ( N ) : NEW_LINE INDENT if ( N % 2 == 1 ) : NEW_LINE INDENT return \"0\" NEW_LINE DEDENT result = \"9\" NEW_LINE for i in range ( 1 , N \/\/ 2 ) : NEW_LINE INDENT result = result + \"0\" NEW_LINE DEDENT return result NEW_LINE DEDENT N = 4 NEW_LINE print ( getCount ( N ) ) NEW_LINE"],"references":["def getCount ( N ) : NEW_LINE INDENT if ( N % 2 == 1 ) : NEW_LINE INDENT return \"0\" NEW_LINE DEDENT result = \"9\" NEW_LINE for i in range ( 1 , N \/\/ 2 ) : NEW_LINE INDENT result = result + \"0\" NEW_LINE DEDENT return result NEW_LINE DEDENT N = 4 NEW_LINE print ( getCount ( N ) ) NEW_LINE"],"bleu":1.0,"rouge_l":1.0}
{"id":1317,"predictions":["def isDivisible ( n ) : NEW_LINE INDENT while n \/\/ 100 : NEW_LINE INDENT d = n % 10 NEW_LINE n \/\/= 10 NEW_LINE n += d * 2 NEW_LINE DEDENT return ( n % 19 == 0 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 101156 NEW_LINE if ( isDivisible ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def isDivisible ( n ) : NEW_LINE INDENT while ( n \/\/ 100 ) : NEW_LINE INDENT d = n % 10 NEW_LINE n \/\/= 10 NEW_LINE n += d * 2 NEW_LINE DEDENT return ( n % 19 == 0 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 101156 NEW_LINE if ( isDivisible ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.9446024703409295,"rouge_l":0.9870550161812297}
{"id":1318,"predictions":["def printArr ( arr , k ) : NEW_LINE INDENT for i in range ( k ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def printSeqUtil ( n , k , ln , arr ) : NEW_LINE INDENT if ( ln == k ) : NEW_LINE INDENT printArr ( arr , k ) NEW_LINE return NEW_LINE DEDENT if ( ln == 0 ) : NEW_LINE INDENT i = 1 NEW_LINE if ( ln == 0 ) : NEW_LINE INDENT printArr ( arr , k ) NEW_LINE return NEW_LINE DEDENT if ( ln == 0 ) : NEW_LINE INDENT i = 1 NEW_LINE printSeqUtil ( n , k , ln , arr ) NEW_LINE i += 1 NEW_LINE DEDENT ln -= 1 NEW_LINE while ( i <= n ) : NEW_LINE INDENT arr [ ln - 1 ] = i NEW_LINE printSeqUtil ( n , k , ln , arr ) NEW_LINE i += 1 NEW_LINE DEDENT ln -= 1 NEW_LINE DEDENT k = 3 NEW_LINE n = 7 NEW_LINE printSeq ( n , k ) NEW_LINE"],"references":["def printArr ( arr , k ) : NEW_LINE INDENT for i in range ( k ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( ) ; NEW_LINE DEDENT def printSeqUtil ( n , k , len1 , arr ) : NEW_LINE INDENT if ( len1 == k ) : NEW_LINE INDENT printArr ( arr , k ) ; NEW_LINE return ; NEW_LINE DEDENT i = 1 if ( len1 == 0 ) else ( arr [ len1 - 1 ] + 1 ) ; NEW_LINE len1 += 1 ; NEW_LINE while ( i <= n ) : NEW_LINE INDENT arr [ len1 - 1 ] = i ; NEW_LINE printSeqUtil ( n , k , len1 , arr ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT len1 -= 1 ; NEW_LINE DEDENT def printSeq ( n , k ) : NEW_LINE INDENT arr = [ 0 ] * k ; NEW_LINE len1 = 0 ; NEW_LINE printSeqUtil ( n , k , len1 , arr ) ; NEW_LINE DEDENT k = 3 ; NEW_LINE n = 7 ; NEW_LINE printSeq ( n , k ) ; NEW_LINE"],"bleu":0.564076757640556,"rouge_l":0.7377402253147779}
{"id":1319,"predictions":["from math import sqrt NEW_LINE MAXN = 1000001 NEW_LINE spf = [ 0 for i in range ( MAXN ) ] NEW_LINE hash1 = [ 0 for i in range ( MAXN ) ] NEW_LINE def sieve ( ) : NEW_LINE INDENT spf [ 1 ] = 1 NEW_LINE for i in range ( 2 , MAXN ) : NEW_LINE INDENT spf [ i ] = i NEW_LINE DEDENT for i in range ( 3 , MAXN , 2 ) : NEW_LINE INDENT spf [ i ] = 2 NEW_LINE DEDENT for i in range ( 3 , MAXN , 1 ) : NEW_LINE INDENT if ( spf [ i ] == i ) : NEW_LINE INDENT for j in range ( i * i , MAXN , i ) : NEW_LINE INDENT if ( spf [ j ] == j ) : NEW_LINE INDENT spf [ j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def getFactorization ( x ) : NEW_LINE INDENT temp = spf [ x ] NEW_LINE if ( x % temp == 0 ) : NEW_LINE INDENT hash1 [ spf [ x ] ] += 1 NEW_LINE x = int ( x \/ spf [ x ] ) NEW_LINE DEDENT while ( x % temp == 0 ) : NEW_LINE INDENT x = int ( x \/ temp ) NEW_LINE if ( x % temp == 0 and hash1 [ temp ] > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( x % temp == 0 ) : NEW_LINE INDENT x = int ( x \/ temp ) NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def checkValidNum ( arr , n ) : NEW_LINE INDENT sieve ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( check ( arr [ i ] ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT arr = [ 2 , 8 , 4 , 10 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE if ( hasValidNum ( arr , n ) ) : NEW_"],"references":["MAXN = 1000001 NEW_LINE spf = [ i for i in range ( MAXN ) ] NEW_LINE hash1 = [ 0 for i in range ( MAXN ) ] NEW_LINE def sieve ( ) : NEW_LINE INDENT for i in range ( 4 , MAXN , 2 ) : NEW_LINE INDENT spf [ i ] = 2 NEW_LINE DEDENT for i in range ( 3 , MAXN ) : NEW_LINE INDENT if i * i < MAXN : NEW_LINE INDENT break NEW_LINE DEDENT if ( spf [ i ] == i ) : NEW_LINE INDENT for j in range ( i * i , MAXN , i ) : NEW_LINE INDENT if ( spf [ j ] == j ) : NEW_LINE INDENT spf [ j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def getFactorization ( x ) : NEW_LINE INDENT while ( x != 1 ) : NEW_LINE INDENT temp = spf [ x ] NEW_LINE if ( x % temp == 0 ) : NEW_LINE INDENT hash1 [ spf [ x ] ] += 1 NEW_LINE x = x \/\/ spf [ x ] NEW_LINE DEDENT while ( x % temp == 0 ) : NEW_LINE INDENT x = x \/\/ temp NEW_LINE DEDENT DEDENT DEDENT def check ( x ) : NEW_LINE INDENT while ( x != 1 ) : NEW_LINE INDENT temp = spf [ x ] NEW_LINE if ( x % temp == 0 and hash1 [ temp ] > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( x % temp == 0 ) : NEW_LINE INDENT x = x \/\/ temp NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def hasValidNum ( arr , n ) : NEW_LINE INDENT sieve ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT getFactorization ( arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( check ( arr [ i ] ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT arr = [ 2 , 8 , 4 , 10 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE if ( hasValidNum ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.7554295598736319,"rouge_l":0.8093391918669768}
{"id":1320,"predictions":["def __gcd ( a , b ) : NEW_LINE INDENT if ( b * c > a * d ) : NEW_LINE INDENT return b NEW_LINE DEDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return __gcd ( a - b , b ) NEW_LINE DEDENT lcm = ( a * c ) \/\/ __gcd ( a , c ) NEW_LINE x = lcm \/ a NEW_LINE b *= x NEW_LINE y = lcm \/ c NEW_LINE d *= y NEW_LINE k = gcd ( b , d ) NEW_LINE print ( y , \" : \" , d ) NEW_LINE DEDENT a = 4 NEW_LINE b = 3 NEW_LINE c = 2 NEW_LINE d = 2 NEW_LINE printRatio ( a , b , c , d ) NEW_LINE"],"references":["import math NEW_LINE def printRatio ( a , b , c , d ) : NEW_LINE INDENT if ( b * c > a * d ) : NEW_LINE INDENT swap ( c , d ) NEW_LINE swap ( a , b ) NEW_LINE DEDENT lcm = ( a * c ) \/ math . gcd ( a , c ) NEW_LINE x = lcm \/ a NEW_LINE b = int ( b * x ) NEW_LINE y = lcm \/ c NEW_LINE d = int ( d * y ) NEW_LINE k = math . gcd ( b , d ) NEW_LINE b = int ( b \/ k ) NEW_LINE d = int ( d \/ k ) NEW_LINE print ( b , \" : \" , d ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 4 NEW_LINE b = 3 NEW_LINE c = 2 NEW_LINE d = 2 NEW_LINE printRatio ( a , b , c , d ) NEW_LINE DEDENT"],"bleu":0.540059744291996,"rouge_l":0.6819798760036588}
{"id":1321,"predictions":["def SieveOfAt pat , n ) : NEW_LINE INDENT if ( limit > 2 ) : NEW_LINE INDENT print ( 2 , end = \" ▁ \" ) ; NEW_LINE DEDENT if ( limit > 3 ) : NEW_LINE INDENT print ( 3 , end = \" ▁ \" ) ; NEW_LINE DEDENT for x in range ( limit ) : NEW_LINE INDENT if ( x * x < l ) : NEW_LINE INDENT y = 1 ; NEW_LINE while ( y * x < l ) : NEW_LINE INDENT y = ( 4 * x * x ) + ( y * y ) ; NEW_LINE if ( n <= y and ( n % 10 == 0 or ( n % 10 == 0 ) ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT n = ( 3 * x * x ) + ( y * y ) ; NEW_LINE if ( n <= y and int ( y % 10 == 0 ) ) : NEW_LINE INDENT sign [ n ] ^= 1 ; NEW_LINE DEDENT n = ( 3 * x * x ) + ( y * y * y ) ; NEW_LINE if ( x > y and int ( x ) and int ( y % 10 ) == 0 ) : NEW_LINE INDENT sign [ n ] ^= 1 ; NEW_LINE DEDENT n = ( 3 * x * y ) - ( y * y ) ; NEW_LINE if ( x > y and int ( y * y ) == 1 ) : NEW_LINE INDENT sign [ n ] ^= 1 ; NEW_LINE DEDENT DEDENT DEDENT for r in range ( 5 , l ) : NEW_LINE INDENT if ( white [ r ] ) : NEW_LINE INDENT for i in range ( r * r , l ) , 1 ) : NEW_LINE INDENT string [ i ] = False ; NEW_LINE DEDENT DEDENT DEDENT return 0 ; NEW_LINE DEDENT if ( limit > 2 ) : NEW_LINE INDENT print ( \" { } ▁ \" . format ( a ) ; NEW_LINE DEDENT"],"references":["def SieveOfAtkin ( limit ) : NEW_LINE INDENT if ( limit > 2 ) : NEW_LINE INDENT print ( 2 , end = \" ▁ \" ) NEW_LINE DEDENT if ( limit > 3 ) : NEW_LINE INDENT print ( 3 , end = \" ▁ \" ) NEW_LINE DEDENT sieve = [ False ] * limit NEW_LINE for i in range ( 0 , limit ) : NEW_LINE INDENT sieve [ i ] = False NEW_LINE DEDENT x = 1 NEW_LINE while ( x * x < limit ) : NEW_LINE INDENT y = 1 NEW_LINE while ( y * y < limit ) : NEW_LINE INDENT n = ( 4 * x * x ) + ( y * y ) NEW_LINE if ( n <= limit and ( n % 12 == 1 or n % 12 == 5 ) ) : NEW_LINE INDENT sieve [ n ] ^= True NEW_LINE DEDENT n = ( 3 * x * x ) + ( y * y ) NEW_LINE if ( n <= limit and n % 12 == 7 ) : NEW_LINE INDENT sieve [ n ] ^= True NEW_LINE DEDENT n = ( 3 * x * x ) - ( y * y ) NEW_LINE if ( x > y and n <= limit and n % 12 == 11 ) : NEW_LINE INDENT sieve [ n ] ^= True NEW_LINE DEDENT y += 1 NEW_LINE DEDENT x += 1 NEW_LINE DEDENT r = 5 NEW_LINE while ( r * r < limit ) : NEW_LINE INDENT if ( sieve [ r ] ) : NEW_LINE INDENT for i in range ( r * r , limit , r * r ) : NEW_LINE INDENT sieve [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for a in range ( 5 , limit ) : NEW_LINE INDENT if ( sieve [ a ] ) : NEW_LINE INDENT print ( a , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT limit = 20 NEW_LINE SieveOfAtkin ( limit ) NEW_LINE"],"bleu":0.5344023228390422,"rouge_l":0.6846208030054004}
{"id":1322,"predictions":["import math NEW_LINE def calculateSide ( n , r ) : NEW_LINE INDENT theta = 360 \/ n NEW_LINE theta_in_radians = theta * 3.14 \/ 180.14 NEW_LINE return 2 * r * r * math . sin ( theta_in_rad \/ 2 ) NEW_LINE DEDENT n = 3 NEW_LINE r = 5 NEW_LINE print ( calculateSide ( n , r ) ) NEW_LINE"],"references":["from math import sin NEW_LINE def calculateSide ( n , r ) : NEW_LINE INDENT theta = 360 \/ n NEW_LINE theta_in_radians = theta * 3.14 \/ 180 NEW_LINE return 2 * r * sin ( theta_in_radians \/ 2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE r = 5 NEW_LINE print ( ' { 0 : . 5 } ' . format ( calculateSide ( n , r ) ) ) NEW_LINE DEDENT"],"bleu":0.5181926439997514,"rouge_l":0.7221265604821352}
{"id":1323,"predictions":["def findSum ( n ) : NEW_LINE INDENT arr = [ [ 0 ] * n for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT arr [ i ] [ j ] = abs ( i - j ) NEW_LINE DEDENT DEDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT sum += arr [ i ] [ j ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT n = 3 NEW_LINE print ( findSum ( n ) ) NEW_LINE"],"references":["def findSum ( n ) : NEW_LINE INDENT arr = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT arr [ i ] [ j ] = abs ( i - j ) NEW_LINE DEDENT DEDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT sum += arr [ i ] [ j ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE print ( findSum ( n ) ) NEW_LINE DEDENT"],"bleu":0.7917663319873292,"rouge_l":0.8864886095836606}
{"id":1324,"predictions":["def solve ( arr , N , K ) : NEW_LINE INDENT count_Arr = [ 0 ] * ( N + 2 ) NEW_LINE factor = 1 NEW_LINE size = N NEW_LINE while ( size > 0 ) : NEW_LINE INDENT start = 1 NEW_LINE end = size NEW_LINE count_Arr [ 1 ] += factor * N NEW_LINE count_Arr [ end + 1 ] -= factor * N NEW_LINE count_Arr [ end + 1 ] -= factor * N NEW_LINE DEDENT for i in range ( 2 , N + 1 ) : NEW_LINE INDENT count_Arr [ i ] += count_Arr [ i - 1 ] NEW_LINE DEDENT element = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT end = start + element [ i ] NEW_LINE if ( K >= start and K <= end ) : NEW_LINE INDENT return element [ i ] [ 0 ] NEW_LINE DEDENT start = 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT end = start + element [ 0 ] [ 0 ] NEW_LINE if ( K >= start and K <= end ) : NEW_LINE INDENT return element [ i ] [ 0 ] NEW_LINE DEDENT start += element [ i ] [ 1 ] NEW_LINE DEDENT return - 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 4 , 5 , 1 ] NEW_LINE N = len ( arr ) NEW_LINE K = 13 NEW_LINE print ( solve ( arr , N , K ) ) NEW_LINE DEDENT"],"references":["def solve ( Array , N , K ) : NEW_LINE INDENT count_Arr = [ 0 ] * ( N + 2 ) ; NEW_LINE factor = 1 ; NEW_LINE size = N ; NEW_LINE while ( size ) : NEW_LINE INDENT start = 1 ; NEW_LINE end = size ; NEW_LINE count_Arr [ 1 ] += factor * N ; NEW_LINE count_Arr [ end + 1 ] -= factor * N ; NEW_LINE factor += 1 ; NEW_LINE size \/\/= 2 ; NEW_LINE DEDENT for i in range ( 2 , N + 1 ) : NEW_LINE INDENT count_Arr [ i ] += count_Arr [ i - 1 ] ; NEW_LINE DEDENT element = [ ] ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT element . append ( ( Array [ i ] , count_Arr [ i + 1 ] ) ) ; NEW_LINE DEDENT element . sort ( ) ; NEW_LINE start = 1 ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT end = start + element [ i ] [ 1 ] - 1 ; NEW_LINE if ( K >= start and K <= end ) : NEW_LINE INDENT return element [ i ] [ 0 ] ; NEW_LINE DEDENT start += element [ i ] [ 1 ] ; NEW_LINE DEDENT return - 1 ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 4 , 5 , 1 ] ; NEW_LINE N = len ( arr ) ; NEW_LINE K = 13 ; NEW_LINE print ( solve ( arr , N , K ) ) ; NEW_LINE DEDENT"],"bleu":0.686808040870847,"rouge_l":0.8385376547964684}
{"id":1325,"predictions":["def display ( n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n \/\/ 2 ) : NEW_LINE INDENT if ( ( j == 0 or j == n \/\/ 2 ) and i != 0 and j != 0 and j != n \/\/ 2 or i == n \/\/ 2 ) : NEW_LINE INDENT print ( \" * \" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( end = \" ▁ \" ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT def display ( n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n \/\/ 2 + 1 ) : NEW_LINE INDENT if ( ( j == 0 or j == n \/\/ 2 ) and i != 0 and j != n \/\/ 2 or i == n \/\/ 2 ) : NEW_LINE INDENT print ( \" * \" , end = \" ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT print ( ) NEW_LINE display ( 7 ) NEW_LINE"],"references":["def display ( n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( ( n \/\/ 2 ) + 1 ) : NEW_LINE INDENT if ( ( j == 0 or j == n \/\/ 2 ) and i != 0 or i == 0 and j != 0 and j != n \/\/ 2 or i == n \/\/ 2 ) : NEW_LINE INDENT print ( \" * \" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" ▁ \" , end = \" \" ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT display ( 7 ) NEW_LINE"],"bleu":0.5197334549913929,"rouge_l":0.7055799507336403}
{"id":1326,"predictions":["import sys NEW_LINE def maxSum ( arr1 , arr2 , n ) : NEW_LINE INDENT finalParity = 0 NEW_LINE finalParity = 0 NEW_LINE sum = 0 NEW_LINE minPositive = - sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT finalParity += arr2 [ i ] NEW_LINE if ( arr1 [ i ] >= 0 ) : NEW_LINE INDENT finalParity += 1 NEW_LINE sum += arr1 [ i ] NEW_LINE minPositive = min ( minPositive , arr1 [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT maxNegative = max ( maxPositive , arr1 [ i ] ) NEW_LINE DEDENT DEDENT if ( initialParity % 2 == finalParity % 2 ) : NEW_LINE INDENT return sum NEW_LINE DEDENT else : NEW_LINE INDENT if ( minPositive + maxNegative >= 0 ) : NEW_LINE INDENT return sum + maxNegitive NEW_LINE DEDENT DEDENT DEDENT arr1 = [ 2 , - 4 , 5 , 3 ] NEW_LINE arr2 = [ 0 , 1 , 0 , 1 ] NEW_LINE n = len ( arr1 ) NEW_LINE print ( maxSum ( arr1 , arr2 , n ) ) NEW_LINE"],"references":["import sys NEW_LINE def maxSum ( arr1 , arr2 , n ) : NEW_LINE INDENT initialParity , finalParity = 0 , 0 NEW_LINE sum = 0 NEW_LINE minPositive = sys . maxsize NEW_LINE maxNegative = - sys . maxsize - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT initialParity += arr2 [ i ] ; NEW_LINE if ( arr1 [ i ] >= 0 ) : NEW_LINE INDENT finalParity += 1 NEW_LINE sum += arr1 [ i ] NEW_LINE minPositive = min ( minPositive , arr1 [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT maxNegative = max ( maxNegative , arr1 [ i ] ) NEW_LINE DEDENT DEDENT if ( initialParity % 2 == finalParity % 2 ) : NEW_LINE INDENT return sum NEW_LINE DEDENT else : NEW_LINE INDENT if ( minPositive + maxNegative >= 0 ) : NEW_LINE INDENT return sum + maxNegative NEW_LINE DEDENT else : NEW_LINE INDENT return sum - minPositive NEW_LINE DEDENT DEDENT DEDENT arr1 = [ 2 , - 4 , 5 , 3 ] NEW_LINE arr2 = [ 0 , 1 , 0 , 1 ] NEW_LINE n = len ( arr1 ) NEW_LINE print ( maxSum ( arr1 , arr2 , n ) ) NEW_LINE"],"bleu":0.8262000278775058,"rouge_l":0.9140260378285433}
{"id":1327,"predictions":["from math import * NEW_LINE def printTaxicab2 ( N ) : NEW_LINE INDENT i = 1 NEW_LINE count = 0 NEW_LINE while ( count < N ) : NEW_LINE INDENT i = 1 NEW_LINE for j in range ( 1 , pow ( i , 1.0 \/ 3 ) + 1 ) : NEW_LINE INDENT for k in range ( j + 1 , pow ( i , 1.0 \/ 3 ) + 1 ) : NEW_LINE INDENT if ( j * j * j + k * k == i ) : NEW_LINE INDENT int ( num ) NEW_LINE count += 1 NEW_LINE DEDENT DEDENT if ( int ( num ) == 2 ) : NEW_LINE INDENT count += 1 NEW_LINE print ( count , i ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT N = 5 NEW_LINE printTaxicab2 ( N ) NEW_LINE"],"references":["def printTaxicab2 ( N ) : NEW_LINE INDENT i , count = 1 , 0 NEW_LINE while ( count < N ) : NEW_LINE INDENT int_count = 0 NEW_LINE for j in range ( 1 , int ( pow ( i , 1.0 \/ 3 ) ) + 1 ) : NEW_LINE INDENT for k in range ( j + 1 , int ( pow ( i , 1.0 \/ 3 ) ) + 1 ) : NEW_LINE INDENT if ( j * j * j + k * k * k == i ) : NEW_LINE INDENT int_count += 1 NEW_LINE DEDENT DEDENT DEDENT if ( int_count == 2 ) : NEW_LINE INDENT count += 1 NEW_LINE print ( count , \" ▁ \" , i ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT N = 5 NEW_LINE printTaxicab2 ( N ) NEW_LINE"],"bleu":0.784141683986729,"rouge_l":0.8620689655172414}
{"id":1328,"predictions":["def findIndex ( a , n , key ) : NEW_LINE INDENT start = - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( a [ i ] == key ) : NEW_LINE INDENT start = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( start == - 1 ) : NEW_LINE INDENT print ( \" Key ▁ not ▁ present ▁ in ▁ array \" ) NEW_LINE return NEW_LINE DEDENT end = start NEW_LINE for i in range ( n - 1 , end , - 1 ) : NEW_LINE INDENT if ( a [ i ] == key ) : NEW_LINE INDENT end = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( start == end ) : NEW_LINE INDENT print ( \" On ▁ one ▁ is ▁ present ▁ at ▁ index \" , start ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Prime ▁ is ▁ present ▁ is ▁ present ▁ at ▁ : ▁ \" , start ) NEW_LINE print ( \" On ▁ is ▁ present ▁ at ▁ index ▁ : \" , start ) NEW_LINE print ( start ) NEW_LINE DEDENT DEDENT a = [ 1 , 6 , 7 , 8 , 9 , 8 , 8 , 0 , 8 ] NEW_LINE k = 8 NEW_LINE findIndex ( a , len ( a ) ) NEW_LINE"],"references":["def findIndex ( a , n , key ) : NEW_LINE INDENT start = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == key : NEW_LINE INDENT start = i NEW_LINE break NEW_LINE DEDENT DEDENT if start == - 1 : NEW_LINE INDENT print ( \" Key ▁ not ▁ present ▁ in ▁ array \" ) NEW_LINE return 0 NEW_LINE DEDENT end = start NEW_LINE for i in range ( n - 1 , start - 1 , - 1 ) : NEW_LINE INDENT if a [ i ] == key : NEW_LINE INDENT end = i NEW_LINE break NEW_LINE DEDENT DEDENT if start == end : NEW_LINE INDENT print ( \" Only ▁ one ▁ key ▁ is ▁ present ▁ at ▁ index ▁ : ▁ \" , start ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Start ▁ index : ▁ \" , start ) NEW_LINE print ( \" Last ▁ index : ▁ \" , end ) NEW_LINE DEDENT DEDENT a = [ 1 , 2 , 7 , 8 , 8 , 9 , 8 , 0 , 0 , 0 , 8 ] NEW_LINE n = len ( a ) NEW_LINE key = 8 NEW_LINE findIndex ( a , n , key ) NEW_LINE"],"bleu":0.7002655150317263,"rouge_l":0.8350175589478965}
{"id":1329,"predictions":["ans = 0 NEW_LINE gr = [ ] NEW_LINE def Add_edge ( u , v ) : NEW_LINE INDENT gr [ u ] . append ( v ) NEW_LINE gr [ v ] . append ( u ) NEW_LINE DEDENT def dfs ( child , par , color ) : NEW_LINE INDENT if ( color [ child ] != color [ par ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT for i in range ( len ( gr [ child ] ) ) : NEW_LINE INDENT if ( gr [ child ] [ i ] == par ) : NEW_LINE INDENT continue NEW_LINE DEDENT dfs ( gr [ child ] [ i ] , child , color ) NEW_LINE DEDENT DEDENT for i in range ( 10 ) : NEW_LINE INDENT gr [ child ] = [ ] NEW_LINE Add_edge ( 1 , 2 ) NEW_LINE Add_Edge ( 1 , 2 ) NEW_LINE Add_Edge ( 1 , 3 ) NEW_LINE Add_edge ( 2 , 4 ) NEW_LINE Add_edge ( 2 , 4 ) NEW_LINE Add_Edge ( 2 , 4 ) NEW_LINE Add_Edge ( 2 , 5 ) NEW_LINE Add_Edge ( 3 , 6 ) NEW_LINE DEDENT print ( ans ) NEW_LINE"],"references":["ans = 0 NEW_LINE gr = [ [ ] for i in range ( 100005 ) ] NEW_LINE def Add_Edge ( u , v ) : NEW_LINE INDENT gr [ u ] . append ( v ) NEW_LINE gr [ v ] . append ( u ) NEW_LINE DEDENT def dfs ( child , par , color ) : NEW_LINE INDENT global ans NEW_LINE if ( color [ child ] != color [ par ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT for it in gr [ child ] : NEW_LINE INDENT if ( it == par ) : NEW_LINE INDENT continue NEW_LINE DEDENT dfs ( it , child , color ) NEW_LINE DEDENT DEDENT color = [ 0 , 1 , 2 , 3 , 2 , 2 , 3 ] NEW_LINE Add_Edge ( 1 , 2 ) NEW_LINE Add_Edge ( 1 , 3 ) NEW_LINE Add_Edge ( 2 , 4 ) NEW_LINE Add_Edge ( 2 , 5 ) NEW_LINE Add_Edge ( 3 , 6 ) NEW_LINE dfs ( 1 , 0 , color ) NEW_LINE print ( ans ) NEW_LINE"],"bleu":0.672225711790559,"rouge_l":0.7664757671595863}
{"id":1330,"predictions":["import sys NEW_LINE def longestFibonacciSubarray ( n , a ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT len1 = 2 NEW_LINE mx = - sys . maxsize NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( a [ i ] == a [ i - 1 ] + a [ i - 2 ] ) : NEW_LINE INDENT len1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT len2 = 2 NEW_LINE DEDENT mx = max ( mx , len1 ) NEW_LINE DEDENT return mx NEW_LINE DEDENT n = 5 NEW_LINE a = [ 2 , 4 , 6 , 10 , 2 ] NEW_LINE print ( longestFibonacciSubarray ( n , a ) ) NEW_LINE"],"references":["def longestFibonacciSubarray ( n , a ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT Len = 2 NEW_LINE mx = - 10 ** 9 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( a [ i ] == a [ i - 1 ] + a [ i - 2 ] ) : NEW_LINE INDENT Len += 1 NEW_LINE DEDENT else : NEW_LINE INDENT Len = 2 NEW_LINE DEDENT mx = max ( mx , Len ) NEW_LINE DEDENT return mx NEW_LINE DEDENT n = 5 NEW_LINE a = [ 2 , 4 , 6 , 10 , 2 ] NEW_LINE print ( longestFibonacciSubarray ( n , a ) ) NEW_LINE"],"bleu":0.8622651186193266,"rouge_l":0.9353176137095734}
{"id":1331,"predictions":["class Node : NEW_LINE INDENT def __init__ ( self , root , size ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return NEW_LINE DEDENT elif ( root . left , matrix , size ) NEW_LINE pushMatrix ( root . right , matrix , size ) NEW_LINE if ( root . left != None ) : NEW_LINE INDENT matrix [ root . data ] [ root . left . data ] [ root ] = 1 NEW_LINE DEDENT DEDENT if ( root . right != None ) : NEW_LINE INDENT matrix [ root . data ] [ root . data ] [ root . left . data ] = 1 NEW_LINE for i in range ( size ) : NEW_LINE INDENT if ( matrix [ root . right . data ] [ i ] == 1 ) : NEW_LINE INDENT matrix [ root . data ] [ i ] = 1 NEW_LINE DEDENT DEDENT DEDENT if ( root . right != None ) : NEW_LINE INDENT matrix [ root . data ] [ root . data ] [ root . right . data ] = 1 NEW_LINE for i in range ( size ) : NEW_LINE INDENT if ( matrix [ root . right . data ] [ i ] == 1 ) : NEW_LINE INDENT matrix [ root . data ] [ i ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT root_root = Node ( 5 ) NEW_LINE root_root . left = Node ( 1 ) NEW_LINE root_root . right = Node ( 2 ) NEW_LINE root_root . left = Node ( 2 ) NEW_LINE tree_root . left = Node ( 0 ) NEW_LINE tree_root . left . left = Node ( 0 ) NEW_LINE tree_root . left . left = Node ( 0 ) NEW_LINE tree_root . right = Node ( 3 ) NEW_LINE size = 6 NEW_LINE matrix = [ [ 0 for i in range ( size ) ] for j in range ( size ) ] NEW_LINE for i in range ( size ) : NEW_LINE INDENT print ( matrix [ i ] [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT"],"references":["class newnode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = self . right = None NEW_LINE DEDENT DEDENT def ancestorMatrixRec ( root , anc ) : NEW_LINE INDENT global mat , MAX NEW_LINE if root == None : NEW_LINE INDENT return 0 NEW_LINE DEDENT data = root . data NEW_LINE for i in range ( len ( anc ) ) : NEW_LINE INDENT mat [ anc [ i ] ] [ data ] = 1 NEW_LINE DEDENT anc . append ( data ) NEW_LINE l = ancestorMatrixRec ( root . left , anc ) NEW_LINE r = ancestorMatrixRec ( root . right , anc ) NEW_LINE anc . pop ( - 1 ) NEW_LINE return l + r + 1 NEW_LINE DEDENT def ancestorMatrix ( root ) : NEW_LINE INDENT anc = [ ] NEW_LINE n = ancestorMatrixRec ( root , anc ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT MAX = 100 NEW_LINE mat = [ [ 0 ] * MAX for i in range ( MAX ) ] NEW_LINE root = newnode ( 5 ) NEW_LINE root . left = newnode ( 1 ) NEW_LINE root . right = newnode ( 2 ) NEW_LINE root . left . left = newnode ( 0 ) NEW_LINE root . left . right = newnode ( 4 ) NEW_LINE root . right . left = newnode ( 3 ) NEW_LINE ancestorMatrix ( root ) NEW_LINE"],"bleu":0.3259322622332896,"rouge_l":0.44291046684051744}
{"id":1332,"predictions":["def OddDivCount ( a , b ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT divCount = 0 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT divCount += 1 NEW_LINE DEDENT DEDENT if ( divCount % 2 != 0 ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a , b = 1 , 10 NEW_LINE print ( OddDivCount ( a , b ) ) NEW_LINE DEDENT"],"references":["def OddDivCount ( a , b ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT divCount = 0 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT divCount += 1 NEW_LINE DEDENT DEDENT if ( divCount % 2 ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 1 NEW_LINE b = 10 NEW_LINE print ( OddDivCount ( a , b ) ) NEW_LINE DEDENT"],"bleu":0.9234285080832958,"rouge_l":0.9667332952598517}
{"id":1333,"predictions":["def findNDigitNumsUtil ( n , sum , out , index ) : NEW_LINE INDENT if ( index > n or sum < 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( index == n ) : NEW_LINE INDENT if ( sum == 0 ) : NEW_LINE INDENT out [ index ] = '0' NEW_LINE print ( out , end = \" ▁ \" ) NEW_LINE print ( ) NEW_LINE DEDENT return NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT out [ index ] = chr ( i + '0' ) NEW_LINE findNDigitNumsUtil ( n , sum - i , out , index + 1 ) NEW_LINE DEDENT DEDENT def findNDigitNums ( n , sum ) : NEW_LINE INDENT out = [ \"0\" ] * ( n + 1 ) NEW_LINE findNDigitNumsUtil ( n , sum - i , out , index + 1 ) NEW_LINE DEDENT n = 2 NEW_LINE sum = 3 NEW_LINE findNDigitNums ( n , sum ) NEW_LINE"],"references":["def findNDigitNumsUtil ( n , sum , out , index ) : NEW_LINE INDENT if ( index > n or sum < 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT f = \" \" NEW_LINE if ( index == n ) : NEW_LINE INDENT if ( sum == 0 ) : NEW_LINE INDENT out [ index ] = \" \" NEW_LINE for i in out : NEW_LINE INDENT f = f + i NEW_LINE DEDENT print ( f , end = \" ▁ \" ) NEW_LINE DEDENT return NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT out [ index ] = chr ( i + ord ( '0' ) ) NEW_LINE findNDigitNumsUtil ( n , sum - i , out , index + 1 ) NEW_LINE DEDENT DEDENT def findNDigitNums ( n , sum ) : NEW_LINE INDENT out = [ False ] * ( n + 1 ) NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT out [ 0 ] = chr ( i + ord ( '0' ) ) NEW_LINE findNDigitNumsUtil ( n , sum - i , out , 1 ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 2 NEW_LINE sum = 3 NEW_LINE findNDigitNums ( n , sum ) NEW_LINE DEDENT"],"bleu":0.6182430835655794,"rouge_l":0.781795918367347}
{"id":1334,"predictions":["def minimumIncrease ( a , b , c ) : NEW_LINE INDENT arr = [ a , b , c ] NEW_LINE arr . sort ( ) NEW_LINE if ( arr [ 0 ] + arr [ 1 ] >= arr [ 2 ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return arr [ 2 ] - ( arr [ 0 ] + arr [ 1 ] ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 3 , b , c ] NEW_LINE b = 5 NEW_LINE c = 10 NEW_LINE print ( minimumIncrease ( a , b , c ) ) NEW_LINE DEDENT"],"references":["def minimumIncrease ( a , b , c ) : NEW_LINE INDENT arr = [ a , b , c ] NEW_LINE arr . sort ( ) NEW_LINE if arr [ 0 ] + arr [ 1 ] >= arr [ 2 ] : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return arr [ 2 ] - ( arr [ 0 ] + arr [ 1 ] ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a , b , c = 3 , 5 , 10 NEW_LINE print ( minimumIncrease ( a , b , c ) ) NEW_LINE DEDENT"],"bleu":0.8061015568675964,"rouge_l":0.9281854379977248}
{"id":1335,"predictions":["def breakSum ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return max ( ( breakSum ( break , ( n \/\/ 2 ) + breakSum ( n \/\/ 3 ) + breakSum ( n \/ 4 ) ) , n ) NEW_LINE DEDENT n = 12 NEW_LINE print ( breakSum ( n ) ) NEW_LINE"],"references":["def breakSum ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return max ( ( breakSum ( n \/\/ 2 ) + breakSum ( n \/\/ 3 ) + breakSum ( n \/\/ 4 ) ) , n ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 12 NEW_LINE print ( breakSum ( n ) ) NEW_LINE DEDENT"],"bleu":0.7576587440649158,"rouge_l":0.8628375482211743}
{"id":1336,"predictions":["def maxLengthSquare ( row , column , matrix , k ) : NEW_LINE INDENT sum = [ [ 0 for x in range ( column + 1 ) ] for row in range ( row + 1 ) ] NEW_LINE cur_max = 1 NEW_LINE max = 0 NEW_LINE for i in range ( 1 , row + 1 ) : NEW_LINE INDENT for j in range ( 1 , column + 1 ) : NEW_LINE INDENT sum [ i ] [ j ] = sum [ i - 1 ] [ j ] + sum [ i ] [ j - 1 ] NEW_LINE if i >= cur_max and j >= cur_max and sum [ i ] [ j ] - sum [ i - cur_max ] [ j - cur_max ] [ j - cur_max ] [ j - 1 ] NEW_LINE if i >= cur_max and j >= cur_max and sum [ i ] [ j ] - sum [ i - cur_max ] [ j - cur_max ] <= k : NEW_LINE INDENT max = cur_max + 1 NEW_LINE DEDENT DEDENT DEDENT return max NEW_LINE DEDENT row = 4 NEW_LINE column = 4 NEW_LINE matrix = [ [ 1 , 1 , 1 , 1 ] , [ 1 , 0 , 0 , 0 ] , [ 1 , 0 , 0 , 0 ] , [ 1 , 0 , 0 , 0 ] , [ 1 , 0 , 0 , 0 ] , [ 1 , 0 , 0 ] ] NEW_LINE k = 6 NEW_LINE ans = maxLengthSquare ( row , column , matrix , k ) NEW_LINE print ( ans ) NEW_LINE"],"references":["import numpy as np NEW_LINE def maxLengthSquare ( row , column , arr , k ) : NEW_LINE INDENT sum = np . zeros ( ( row + 1 , column + 1 ) ) ; NEW_LINE cur_max = 1 ; NEW_LINE max = 0 ; NEW_LINE for i in range ( 1 , row + 1 ) : NEW_LINE INDENT for j in range ( 1 , column + 1 ) : NEW_LINE INDENT sum [ i ] [ j ] = sum [ i - 1 ] [ j ] + sum [ i ] [ j - 1 ] +   \\ NEW_LINE INDENT arr [ i - 1 ] [ j - 1 ] -   \\ NEW_LINE sum [ i - 1 ] [ j - 1 ] ; NEW_LINE DEDENT if ( i >= cur_max and j >= cur_max and sum [ i ] [ j ] - sum [ i - cur_max ] [ j ] - sum [ i ] [ j - cur_max ] + sum [ i - cur_max ] [ j - cur_max ] <= k ) : NEW_LINE INDENT max = cur_max ; NEW_LINE cur_max += 1 ; NEW_LINE DEDENT DEDENT DEDENT return max ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT row = 4 ; NEW_LINE column = 4 ; NEW_LINE matrix = [ [ 1 , 1 , 1 , 1 ] , [ 1 , 0 , 0 , 0 ] , [ 1 , 0 , 0 , 0 ] , [ 1 , 0 , 0 , 0 ] ] ; NEW_LINE k = 6 ; NEW_LINE ans = maxLengthSquare ( row , column , matrix , k ) ; NEW_LINE print ( ans ) ; NEW_LINE DEDENT"],"bleu":0.6835574639386528,"rouge_l":0.7555123576784226}
{"id":1337,"predictions":["def minimumChanges ( arr , n ) : NEW_LINE"],"references":["def minimumChanges ( arr , n ) : NEW_LINE INDENT changes = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if arr [ i ] == 1 : NEW_LINE INDENT j = i + 1 NEW_LINE while j < n : NEW_LINE INDENT if arr [ j ] == 0 : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT i = j - 1 NEW_LINE changes += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return changes NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 1 , 0 , 0 , 0 , 1 , 0 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Minimum ▁ operations : \" , minimumChanges ( arr , n ) ) NEW_LINE DEDENT"],"bleu":2.449474296648572e-7,"rouge_l":0.10016420361247946}
{"id":1338,"predictions":["MAX = 100005 NEW_LINE prime = [ True for i in range ( n + 1 ) ] NEW_LINE p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , n , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT ans = [ ] NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT ans . append ( p ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def is_prime ( n ) : NEW_LINE INDENT return ( n == 3 or n == 5 or n == 7 ) NEW_LINE DEDENT def find_Sum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE v = addPrimes ( ) NEW_LINE i = 0 NEW_LINE while ( i < len ( v ) and n > 0 ) : NEW_LINE INDENT flag = 1 NEW_LINE a = v [ i ] NEW_LINE while ( a != 0 ) : NEW_LINE INDENT d = a % 10 NEW_LINE a = a \/\/ 10 NEW_LINE if ( is_prime ( d ) ) : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == 1 ) : NEW_LINE INDENT n -= 1 NEW_LINE sum = sum + v [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 7 NEW_LINE print ( find_Sum ( n ) ) NEW_LINE DEDENT"],"references":["MAX = 100005 NEW_LINE def addPrimes ( ) : NEW_LINE INDENT n = MAX NEW_LINE prime = [ True for i in range ( n + 1 ) ] NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if p * p > n : NEW_LINE INDENT break NEW_LINE DEDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( 2 * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT ans = [ ] NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT ans . append ( p ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def is_prime ( n ) : NEW_LINE INDENT if n in [ 3 , 5 , 7 ] : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def find_Sum ( n ) : NEW_LINE INDENT Sum = 0 NEW_LINE v = addPrimes ( ) NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT flag = 1 NEW_LINE a = v [ i ] NEW_LINE while ( a != 0 ) : NEW_LINE INDENT d = a % 10 ; NEW_LINE a = a \/\/ 10 ; NEW_LINE if ( is_prime ( d ) ) : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == 1 ) : NEW_LINE INDENT n -= 1 NEW_LINE Sum = Sum + v [ i ] NEW_LINE DEDENT if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return Sum NEW_LINE DEDENT n = 7 NEW_LINE print ( find_Sum ( n ) ) NEW_LINE"],"bleu":0.7075298232358053,"rouge_l":0.8053706293706293}
{"id":1339,"predictions":["def NikuTheInThe_sum ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for k in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += k * k * k * k ) ; NEW_LINE DEDENT triNo = n * ( n + 1 ) \/ 2 ; NEW_LINE if ( sum == triNo * tripleNo ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 ; NEW_LINE DG_sum ( n ) ; NEW_LINE DEDENT"],"references":["def NicomachuTheorum_sum ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for k in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += k * k * k ; NEW_LINE DEDENT triNo = n * ( n + 1 ) \/ 2 ; NEW_LINE if ( sum == triNo * triNo ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT n = 5 ; NEW_LINE NicomachuTheorum_sum ( n ) ; NEW_LINE"],"bleu":0.7582696301082543,"rouge_l":0.9022508038585209}
{"id":1340,"predictions":["MAX = 1000 ; NEW_LINE sequence = [ 0 ] * MAX ; NEW_LINE def vanEckSequence ( ) : NEW_LINE INDENT for i in range ( MAX - 1 ) : NEW_LINE INDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( sequence [ j ] == sequence [ i ] ) : NEW_LINE INDENT sequence [ i + 1 ] = i - j ; NEW_LINE break ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def getNthTerm ( n ) : NEW_LINE INDENT return sequence [ n ] ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT vanEckSequence ( ) ; NEW_LINE n = 6 ; NEW_LINE print ( getNthTerm ( n ) ) ; NEW_LINE n = 100 ; NEW_LINE print ( getNthTerm ( n ) ) ; NEW_LINE DEDENT"],"references":["MAX = 1000 NEW_LINE sequence = [ 0 ] * ( MAX + 1 ) ; NEW_LINE def vanEckSequence ( ) : NEW_LINE INDENT for i in range ( MAX ) : NEW_LINE INDENT sequence [ i ] = 0 ; NEW_LINE DEDENT for i in range ( MAX ) : NEW_LINE INDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( sequence [ j ] == sequence [ i ] ) : NEW_LINE INDENT sequence [ i + 1 ] = i - j ; NEW_LINE break ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def getNthTerm ( n ) : NEW_LINE INDENT return sequence [ n ] ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT vanEckSequence ( ) ; NEW_LINE n = 6 ; NEW_LINE print ( getNthTerm ( n ) ) ; NEW_LINE n = 100 ; NEW_LINE print ( getNthTerm ( n ) ) ; NEW_LINE DEDENT"],"bleu":0.8299931405146527,"rouge_l":0.907365613459171}
{"id":1341,"predictions":["def maximum FixedPoints ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE swapped = 0 NEW_LINE pos = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT pos [ i ] = i NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == i ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT elif ( swapped == 0 and pos [ i ] == a [ i ] ) : NEW_LINE INDENT count += 2 NEW_LINE swapped = 1 NEW_LINE DEDENT DEDENT if ( swapped == 0 and count < n - 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT a = [ 0 , 1 , 3 , 4 , 2 ] NEW_LINE n = len ( a ) NEW_LINE print ( maximum fixedPoints ( a , n ) ) NEW_LINE"],"references":["def maximumFixedPoints ( a , n ) : NEW_LINE INDENT pos = [ None ] * n NEW_LINE count , swapped = 0 , 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT pos [ a [ i ] ] = i NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if a [ i ] == i : NEW_LINE INDENT count += 1 NEW_LINE DEDENT elif swapped == 0 and pos [ i ] == a [ i ] : NEW_LINE INDENT count += 2 NEW_LINE swapped = 1 NEW_LINE DEDENT DEDENT if swapped == 0 and count < n - 1 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 0 , 1 , 3 , 4 , 2 ] NEW_LINE n = len ( a ) NEW_LINE print ( maximumFixedPoints ( a , n ) ) NEW_LINE DEDENT"],"bleu":0.6839271626950032,"rouge_l":0.8277286135693217}
{"id":1342,"predictions":["def countCotation ( amount ) : NEW_LINE INDENT notes = [ 2000 , 500 , 200 , 100 , 100 , 50 , 20 , 10 , 5 , 1 ] NEW_LINE noteCounter = [ 0 ] * 9 NEW_LINE for i in range ( 9 ) : NEW_LINE INDENT if ( amount >= notes [ i ] ) : NEW_LINE INDENT notecounter [ i ] = int ( amount \/ notes [ i ] ) NEW_LINE amount = ( amount - noteCounter [ i ] * points [ i ] ) NEW_LINE DEDENT DEDENT print ( \" Currency ▁ Count ▁ - > \" , end = \" ▁ \" ) NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT if ( amountCr [ i ] != 0 ) : NEW_LINE INDENT print ( str ( i ) , \" : ▁ \" , int ( note counter [ i ] ) ) NEW_LINE DEDENT DEDENT"],"references":["def countCurrency ( amount ) : NEW_LINE INDENT notes = [ 2000 , 500 , 200 , 100 , 50 , 20 , 10 , 5 , 1 ] NEW_LINE noteCounter = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] NEW_LINE print ( \" Currency ▁ Count ▁ - > ▁ \" ) NEW_LINE for i , j in zip ( notes , noteCounter ) : NEW_LINE INDENT if amount >= i : NEW_LINE INDENT j = amount \/\/ i NEW_LINE amount = amount - j * i NEW_LINE print ( i , \" ▁ : ▁ \" , j ) NEW_LINE DEDENT DEDENT DEDENT amount = 868 NEW_LINE countCurrency ( amount ) NEW_LINE"],"bleu":0.3925204315657502,"rouge_l":0.5326253687315634}
{"id":1343,"predictions":["MAX_CHAR = 256 NEW_LINE def isPalindrome ( strr , l , h ) : NEW_LINE INDENT while ( h > l ) : NEW_LINE INDENT if ( strr [ l ] != strr [ h ] ) : NEW_LINE INDENT return True NEW_LINE l += 1 NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def check ( strr ) : NEW_LINE INDENT n = len ( strr ) NEW_LINE freq = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( strr [ i ] ) ] += 1 NEW_LINE if ( freq [ ord ( strr [ i ] ) ] > 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT k = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( freq [ ord ( strr [ i ] ) ] > 1 ) : NEW_LINE INDENT strr [ ord ( strr [ i ] ) ] = strr [ k ] NEW_LINE k += 1 NEW_LINE DEDENT DEDENT if ( isPalindrome ( strr , 0 , k - 1 ) : NEW_LINE INDENT if ( k & 1 ) : NEW_LINE INDENT if ( k \/\/ 2 >= 1 ) : NEW_LINE INDENT if ( k \/\/ 2 >= 1 ) : NEW_LINE INDENT return ( strr [ k \/\/ 2 ] == strr [ k \/\/ 2 ] ) : NEW_LINE INDENT return ( strr [ k \/\/ 2 ] == strr [ k \/\/ 2 - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT strr = \" ABCABD \" NEW_LINE if ( check ( strr ) ) : NEW_LINE INDENT print ( \" Repeated ▁ Subsequence ▁ Exists ▁ Exsequence ▁ Exists ▁ Subsequence ▁ Exists \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Repeated ▁ Subsequence ▁ Exists \" ) NEW_LINE DEDENT DEDENT"],"references":["MAX_CHAR = 256 NEW_LINE def isPalindrome ( Str , l , h ) : NEW_LINE INDENT while ( h > l ) : NEW_LINE INDENT if ( Str [ l ] != Str [ h ] ) : NEW_LINE INDENT l += 1 NEW_LINE h -= 1 NEW_LINE return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def check ( Str ) : NEW_LINE INDENT n = len ( Str ) NEW_LINE freq = [ 0 for i in range ( MAX_CHAR ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( Str [ i ] ) ] += 1 NEW_LINE if ( freq [ ord ( Str [ i ] ) ] > 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT k = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( freq [ ord ( Str [ i ] ) ] > 1 ) : NEW_LINE INDENT Str [ k ] = Str [ i ] NEW_LINE k += 1 NEW_LINE DEDENT DEDENT Str [ k ] = ' \\0' NEW_LINE if ( isPalindrome ( Str , 0 , k - 1 ) ) : NEW_LINE INDENT if ( k & 1 ) : NEW_LINE INDENT return Str [ k \/\/ 2 ] == Str [ k \/\/ 2 - 1 ] NEW_LINE DEDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT S = \" ABCABD \" NEW_LINE Str = [ i for i in S ] NEW_LINE if ( check ( Str ) ) : NEW_LINE INDENT print ( \" Repeated ▁ Subsequence ▁ Exists \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Repeated ▁ Subsequence ▁ Doesn ' t ▁ Exists \" ) NEW_LINE DEDENT"],"bleu":0.6283631235531542,"rouge_l":0.7680838733470312}
{"id":1344,"predictions":["def Divisors ( ) : NEW_LINE INDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( 1 , N ) : NEW_LINE INDENT if j * i < N : NEW_LINE INDENT break NEW_LINE DEDENT cnt [ i * j ] += 1 NEW_LINE DEDENT DEDENT DEDENT def Sumofdivisors ( A , B , C ) : NEW_LINE INDENT Sum = 0 NEW_LINE Divisors ( ) NEW_LINE for i in range ( 1 , A + 1 ) : NEW_LINE INDENT for j in range ( 1 , B + 1 ) : NEW_LINE INDENT for k in range ( 1 , B + 1 ) : NEW_LINE INDENT for k in range ( 1 , C + 1 ) : NEW_LINE INDENT x = i * j * k NEW_LINE Sum += cnt [ x ] NEW_LINE if Sum >= mod : NEW_LINE INDENT Sum -= mod NEW_LINE DEDENT DEDENT DEDENT DEDENT return Sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = 5 NEW_LINE B = 6 NEW_LINE C = 7 NEW_LINE print ( Sumofdivisors ( A , B , C ) ) NEW_LINE DEDENT"],"references":["N = 100005 NEW_LINE mod = 1000000007 NEW_LINE cnt = [ 0 ] * N ; NEW_LINE def Divisors ( ) : NEW_LINE INDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( 1 , N \/\/ i ) : NEW_LINE INDENT cnt [ i * j ] += 1 ; NEW_LINE DEDENT DEDENT DEDENT def Sumofdivisors ( A , B , C ) : NEW_LINE INDENT sum = 0 ; NEW_LINE Divisors ( ) ; NEW_LINE for i in range ( 1 , A + 1 ) : NEW_LINE INDENT for j in range ( 1 , B + 1 ) : NEW_LINE INDENT for k in range ( 1 , C + 1 ) : NEW_LINE INDENT x = i * j * k ; NEW_LINE sum += cnt [ x ] ; NEW_LINE if ( sum >= mod ) : NEW_LINE INDENT sum -= mod ; NEW_LINE DEDENT DEDENT DEDENT DEDENT return sum ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = 5 ; B = 6 ; C = 7 ; NEW_LINE print ( Sumofdivisors ( A , B , C ) ) ; NEW_LINE DEDENT"],"bleu":0.6794970714467203,"rouge_l":0.8180729624012134}
{"id":1345,"predictions":["def factorial ( N ) : NEW_LINE INDENT fact = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT fact = fact * i NEW_LINE DEDENT return fact NEW_LINE DEDENT def nthTerm ( N ) : NEW_LINE INDENT return ( factorial ( N + 1 ) \/\/ 2 ) NEW_LINE DEDENT N = 6 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE"],"references":["def factorial ( N ) : NEW_LINE INDENT fact = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT fact = fact * i NEW_LINE DEDENT return fact NEW_LINE DEDENT def nthTerm ( N ) : NEW_LINE INDENT return ( factorial ( N + 1 ) \/\/ 2 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 6 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT"],"bleu":0.800730562836939,"rouge_l":0.8944281524926685}
{"id":1346,"predictions":["def prefix ( string ) : NEW_LINE INDENT k , n = len ( string ) , g = [ ] , 0 NEW_LINE flag = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( string [ i ] == string [ 0 ] ) : NEW_LINE INDENT g . append ( i ) NEW_LINE flag = 1 NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT print ( string ) NEW_LINE DEDENT else : NEW_LINE INDENT l = len ( g ) NEW_LINE while ( k < g [ 0 ] ) : NEW_LINE INDENT cnt = 0 NEW_LINE for j in range ( l ) : NEW_LINE INDENT if ( ( ( g [ j ] + k ) < n and string [ g [ j ] + k ] == string [ k ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if ( cnt == len ) : NEW_LINE INDENT k += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in range ( k ) : NEW_LINE INDENT print ( string [ i ] , end = \" \" ) NEW_LINE DEDENT print ( \" \" ) NEW_LINE DEDENT string = \" abcab \" NEW_LINE prefix ( string ) NEW_LINE"],"references":["def prefix ( string ) : NEW_LINE INDENT k = 1 ; NEW_LINE n = len ( string ) ; NEW_LINE g = [ ] ; NEW_LINE flag = 0 ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( string [ i ] == string [ 0 ] ) : NEW_LINE INDENT g . append ( i ) ; NEW_LINE flag = 1 ; NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT print ( string ) ; NEW_LINE DEDENT else : NEW_LINE INDENT length = len ( g ) ; NEW_LINE while ( k < g [ 0 ] ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for j in range ( length ) : NEW_LINE INDENT if ( string [ g [ j ] + k ] == string [ k ] ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT if ( cnt == len ) : NEW_LINE INDENT k += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT for i in range ( k + 1 ) : NEW_LINE INDENT print ( string [ i ] , end = \" \" ) ; NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" abcab \" ; NEW_LINE prefix ( string ) ; NEW_LINE DEDENT"],"bleu":0.7064621203088691,"rouge_l":0.8683579985905566}
{"id":1347,"predictions":["def findTerm ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT else : NEW_LINE INDENT term = 7 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT term = term * 2 + ( i - 1 ) NEW_LINE DEDENT return term NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 NEW_LINE print ( findTerm ( n ) ) NEW_LINE DEDENT"],"references":["def findTerm ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return n NEW_LINE DEDENT else : NEW_LINE INDENT term = 7 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT term = term * 2 + ( i - 1 ) ; NEW_LINE DEDENT DEDENT return term ; NEW_LINE DEDENT print ( findTerm ( 5 ) ) NEW_LINE"],"bleu":0.6443278815074783,"rouge_l":0.8556322831247302}
{"id":1348,"predictions":["import math NEW_LINE def Right_setbit ( num ) : NEW_LINE INDENT pos = 1 NEW_LINE for i in range ( 0 , INT_most_setbit ( num ) ) : NEW_LINE INDENT if ( ( num & ( 1 << i ) ) == 0 ) : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return pos NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT num = 18 NEW_LINE pos = Right_most_setbit ( num ) NEW_LINE print ( pos ) NEW_LINE DEDENT"],"references":["INT_SIZE = 32 NEW_LINE def Right_most_setbit ( num ) : NEW_LINE INDENT pos = 1 NEW_LINE for i in range ( INT_SIZE ) : NEW_LINE INDENT if not ( num & ( 1 << i ) ) : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return pos NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT num = 18 NEW_LINE pos = Right_most_setbit ( num ) NEW_LINE print ( pos ) NEW_LINE DEDENT"],"bleu":0.7560056105305786,"rouge_l":0.8790587376869755}
{"id":1349,"predictions":["def subarrayXor ( arr , n , m ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT xorSum = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT xorSum = xorSum ^ arr [ j ] NEW_LINE if ( xorSum == m ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 4 , 2 , 2 , 6 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE m = 6 NEW_LINE print ( \" Number ▁ of ▁ subarrays ▁ having ▁ given ▁ XOR ▁ is \" , subarrayXor ( arr , n , m ) ) NEW_LINE"],"references":["def subarrayXor ( arr , n , m ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT xorSum = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT xorSum = xorSum ^ arr [ j ] NEW_LINE if ( xorSum == m ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT arr = [ 4 , 2 , 2 , 6 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE m = 6 NEW_LINE print ( \" Number ▁ of ▁ subarrays ▁ having ▁ given ▁ XOR ▁ is ▁ \" , subarrayXor ( arr , n , m ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"bleu":0.7875599116947987,"rouge_l":0.8877338877338876}
{"id":1350,"predictions":["import math NEW_LINE defLyDivision ( N ) : NEW_LINE INDENT i = 2 NEW_LINE k = int ( math . ceil ( math . sqrt ( N ) ) ) NEW_LINE while ( i <= k ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 49 NEW_LINE p =veltDivision ( N ) NEW_LINE if ( p != 0 ) : NEW_LINE INDENT print ( \" Prime \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Prime \" ) NEW_LINE DEDENT DEDENT"],"references":["def TrialDivision ( N ) : NEW_LINE INDENT i = 2 NEW_LINE k = int ( N ** 0.5 ) NEW_LINE while ( i <= k ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 49 NEW_LINE p = TrialDivision ( N ) NEW_LINE if ( p ) : NEW_LINE INDENT print ( \" Prime \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Composite \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.7880291809541284,"rouge_l":0.8958611481975969}
{"id":1351,"predictions":["def count ( arr , N , K ) : NEW_LINE INDENT count = 0 ; NEW_LINE ans = 0 ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] == K ) : NEW_LINE INDENT count = count + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( count * ( count + 1 ) ) \/ 2 ; NEW_LINE count = 0 ; NEW_LINE DEDENT DEDENT ans = ans + ( count * ( count + 1 ) ) \/ 2 ; NEW_LINE return ans ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 0 , 0 , 1 , 0 , 0 , 0 ] ; NEW_LINE N = len ( arr ) ; NEW_LINE K = 0 ; NEW_LINE print ( count ( arr , N , K ) ) ; NEW_LINE DEDENT"],"references":["def count ( arr , N , K ) : NEW_LINE INDENT count = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] == K ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( count * ( count + 1 ) ) \/\/ 2 NEW_LINE count = 0 NEW_LINE DEDENT DEDENT ans = ans + ( count * ( count + 1 ) ) \/\/ 2 NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 0 , 0 , 1 , 1 , 0 , 0 ] NEW_LINE N = len ( arr ) NEW_LINE K = 0 NEW_LINE print ( count ( arr , N , K ) ) NEW_LINE DEDENT"],"bleu":0.7900057558425042,"rouge_l":0.9507685692787273}
{"id":1352,"predictions":["def centered_hptagonal_num ( n ) : NEW_LINE INDENT return ( 7 * n * n - 7 * n + 2 ) \/ 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( n , \" th ▁ Centered ▁ hash ▁ number ▁ : ▁ \" , centered_hptagonal_num ( n ) ) NEW_LINE DEDENT"],"references":["def centered_heptagonal_num ( n ) : NEW_LINE INDENT return ( 7 * n * n - 7 * n + 2 ) \/\/ 2 NEW_LINE DEDENT n = 5 NEW_LINE print ( \" % sth ▁ Centered ▁ heptagonal ▁ number ▁ : ▁ \" % n , centered_heptagonal_num ( n ) ) NEW_LINE"],"bleu":0.5313088387099979,"rouge_l":0.7753523072672008}
{"id":1353,"predictions":["def findsolution ( d , h , m , n ) : NEW_LINE INDENT k = ( 4 * m ) \/ ( 4 * m * d * d ) NEW_LINE if ( n > k ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT ans = ( h \/ ( k - n ) ) NEW_LINE return ans NEW_LINE DEDENT d , h = 1 , 1.1415926535897 NEW_LINE print ( findsolution ( d , h , m , n ) ) NEW_LINE"],"references":["pie = 3.1415926535897 NEW_LINE def findsolution ( d , h , m , n ) : NEW_LINE INDENT k = ( 4 * m ) \/ ( pie * d * d ) NEW_LINE if ( n > k ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT ans = ( h \/ ( k - n ) ) NEW_LINE return round ( ans , 5 ) NEW_LINE DEDENT d = 1 NEW_LINE h = 1 NEW_LINE m = 1 NEW_LINE n = 1 NEW_LINE print ( findsolution ( d , h , m , n ) ) NEW_LINE"],"bleu":0.7107456496036086,"rouge_l":0.8400423728813557}
{"id":1354,"predictions":["def countNum ( N , arr ) : NEW_LINE INDENT sum = 0 NEW_LINE count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT if ( ( sum - arr [ i ] ) % arr [ i ] == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 3 , 10 , 4 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countNum ( n , arr ) ) NEW_LINE"],"references":["def countNum ( N , arr ) : NEW_LINE INDENT Sum , count = 0 , 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT if ( ( Sum - arr [ i ] ) % arr [ i ] == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 3 , 10 , 4 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countNum ( n , arr ) ) NEW_LINE"],"bleu":0.8962137948357985,"rouge_l":0.9444444444444445}
{"id":1355,"predictions":["def CountTrailingZeros ( n ) : NEW_LINE INDENT bit = bin ( n ) NEW_LINE bit1 = bin ( n ) NEW_LINE bit2 = bin ( bit ) NEW_LINE bit1 = bit1 [ : - 1 ] NEW_LINE zero = 0 NEW_LINE for i in range ( 64 ) : NEW_LINE INDENT if ( bit1 [ i ] == '0' ) : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return zero NEW_LINE DEDENT n = 4 NEW_LINE ans = CountTrailingZeros ( n ) NEW_LINE print ( ans ) NEW_LINE"],"references":["def CountTrailingZeros ( n ) : NEW_LINE INDENT bit = bin ( n ) [ 2 : ] NEW_LINE bit = bit [ : : - 1 ] NEW_LINE zero = 0 ; NEW_LINE for i in range ( len ( bit ) ) : NEW_LINE INDENT if ( bit [ i ] == '0' ) : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return zero NEW_LINE DEDENT n = 4 NEW_LINE ans = CountTrailingZeros ( n ) NEW_LINE print ( ans ) NEW_LINE"],"bleu":0.7417572971047323,"rouge_l":0.8506187903085235}
{"id":1356,"predictions":["def printConsecutive ( last , first ) : NEW_LINE INDENT print ( first , first ) NEW_LINE for i in range ( first , last + 1 ) : NEW_LINE INDENT print ( \" ▁ \" , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT def findConsecutive ( N ) : NEW_LINE INDENT for last in range ( 1 , N ) : NEW_LINE INDENT for first in range ( 1 , last ) : NEW_LINE INDENT if 2 * N == ( last - first ) * ( ( last + first ) + 1 ) ) : NEW_LINE INDENT print ( N , end = \" ▁ \" ) NEW_LINE print ( \" ▁ = ▁ \" , end = \" \" ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( \" - 1\" ) NEW_LINE DEDENT N = 12 NEW_LINE findConsecutive ( N ) NEW_LINE"],"references":["def printConsecutive ( last , first ) : NEW_LINE INDENT print ( first , end = \" \" ) NEW_LINE first += 1 NEW_LINE for x in range ( first , last + 1 ) : NEW_LINE INDENT print ( \" ▁ + \" , x , end = \" \" ) NEW_LINE DEDENT DEDENT def findConsecutive ( N ) : NEW_LINE INDENT for last in range ( 1 , N ) : NEW_LINE INDENT for first in range ( 0 , last ) : NEW_LINE INDENT if 2 * N == ( last - first ) * ( last + first + 1 ) : NEW_LINE INDENT print ( N , \" = ▁ \" , end = \" \" ) NEW_LINE printConsecutive ( last , first + 1 ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( \" - 1\" ) NEW_LINE DEDENT n = 12 NEW_LINE findConsecutive ( n ) NEW_LINE"],"bleu":0.7502966872809194,"rouge_l":0.851254868022501}
{"id":1357,"predictions":["def LCSubStr ( X , Y , m , n ) : NEW_LINE INDENT LCStuff = [ [ 0 for x in range ( n + 1 ) ] for y in range ( m + 1 ) ] NEW_LINE result = 0 NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT LCStuff [ i ] [ j ] = 0 NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] ) : NEW_LINE INDENT LCStuff [ i ] [ j ] = LCStuff [ i - 1 ] [ j - 1 ] + 1 NEW_LINE result = max ( result , LCStuff [ i ] [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT LCStuff [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT X = \" SEE portal : GeeksforGeeks . org \" NEW_LINE Y = \"NewEdge ▁ Geeks \" NEW_LINE m = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE print ( \" Length ▁ of ▁ Longest ▁ common ▁ Substring ▁ is \" , LCSubStr ( X , Y , m , n ) ) NEW_LINE DEDENT"],"references":["def LCSubStr ( X , Y , m , n ) : NEW_LINE INDENT LCSuff = [ [ 0 for k in range ( n + 1 ) ] for l in range ( m + 1 ) ] NEW_LINE result = 0 NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT LCSuff [ i ] [ j ] = 0 NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] ) : NEW_LINE INDENT LCSuff [ i ] [ j ] = LCSuff [ i - 1 ] [ j - 1 ] + 1 NEW_LINE result = max ( result , LCSuff [ i ] [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT LCSuff [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT X = ' OldSite : GeeksforGeeks . org ' NEW_LINE Y = ' NewSite : GeeksQuiz . com ' NEW_LINE m = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE print ( ' Length ▁ of ▁ Longest ▁ Common ▁ Substring ▁ is ' , LCSubStr ( X , Y , m , n ) ) NEW_LINE"],"bleu":0.7712075978614673,"rouge_l":0.8879184861717613}
{"id":1358,"predictions":["def getPassingCars ( A , n ) : NEW_LINE INDENT result = 0 ; NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( A [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( A [ j ] == 1 ) : NEW_LINE INDENT result += 1 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT return result ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 0 , 1 , 0 , 1 , 1 ] ; NEW_LINE n = len ( A ) ; NEW_LINE print ( getPassingCars ( A , n ) ) ; NEW_LINE DEDENT"],"references":["def getPassingCars ( A , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 0 , n - 1 , 1 ) : NEW_LINE INDENT if ( A [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i + 1 , n , 1 ) : NEW_LINE INDENT if ( A [ j ] ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 0 , 1 , 0 , 1 , 1 ] NEW_LINE n = len ( A ) NEW_LINE print ( getPassingCars ( A , n ) ) NEW_LINE DEDENT"],"bleu":0.8289229281333335,"rouge_l":0.9457980456026058}
{"id":1359,"predictions":["class Node : NEW_LINE INDENT def __init__ ( self , data ) : None NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT"],"references":["class Node : NEW_LINE INDENT def __init__ ( self , next = None , prev = None , data = None ) : NEW_LINE INDENT self . next = next NEW_LINE self . prev = prev NEW_LINE self . data = data NEW_LINE DEDENT DEDENT"],"bleu":0.44022034725952813,"rouge_l":0.6434599156118143}
{"id":1360,"predictions":["def search ( arr , n , x ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == x ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT arr = [ 1 , 10 , 30 , 15 ] ; NEW_LINE x = 30 ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( search ( arr , n , x ) ) ; NEW_LINE"],"references":["def search ( arr , n , x ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == x : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 1 , 10 , 30 , 15 ] NEW_LINE x = 30 NEW_LINE n = len ( arr ) NEW_LINE print ( x , \" is ▁ present ▁ at ▁ index \" , search ( arr , n , x ) ) NEW_LINE"],"bleu":0.7101503519359013,"rouge_l":0.8814036404578719}
{"id":1361,"predictions":["def findKHCF ( x , y , k ) : NEW_LINE INDENT small = min ( x , y ) NEW_LINE count = 1 NEW_LINE for i in range ( 2 , small + 1 ) : NEW_LINE INDENT if ( x % i == 0 and y % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( count == k ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT x , y = 4 , 24 , 3 NEW_LINE k = 3 NEW_LINE print ( findKHCF ( x , y , k ) ) NEW_LINE"],"references":["def findKHCF ( x , y , k ) : NEW_LINE INDENT small = min ( x , y ) NEW_LINE count = 1 NEW_LINE for i in range ( 2 , small + 1 ) : NEW_LINE INDENT if ( x % i == 0 and y % i == 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT if ( count == k ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT x = 4 NEW_LINE y = 24 NEW_LINE k = 3 NEW_LINE print ( findKHCF ( x , y , k ) ) NEW_LINE"],"bleu":0.8993098799759994,"rouge_l":0.9433962264150945}
{"id":1362,"predictions":["def distancesum ( x , y , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT sum += ( abs ( x [ i ] - x [ j ] ) + abs ( y [ i ] - y [ j ] ) ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = [ - 1 , 1 , 3 , 2 ] NEW_LINE y = [ 5 , 6 , 5 , 3 ] NEW_LINE n = len ( x ) NEW_LINE print ( distancesum ( x , y , n ) ) NEW_LINE DEDENT"],"references":["def distancesum ( x , y , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT sum += ( abs ( x [ i ] - x [ j ] ) + abs ( y [ i ] - y [ j ] ) ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT x = [ - 1 , 1 , 3 , 2 ] NEW_LINE y = [ 5 , 6 , 5 , 3 ] NEW_LINE n = len ( x ) NEW_LINE print ( distancesum ( x , y , n ) ) NEW_LINE"],"bleu":0.8837673923175022,"rouge_l":0.954367666232073}
{"id":1363,"predictions":["D = [ 31 , 28 , 31 , 30 , 31 , 31 , 30 , 31 , 31 , 30 , 31 , 31 ] NEW_LINE def dayOfYear ( d ) : NEW_LINE INDENT year = d [ 0 : 5 ] NEW_LINE month = d [ 5 : 7 ] NEW_LINE if month > 2 and year % 4 == 0 and year % 400 == 0 : NEW_LINE INDENT day += 1 NEW_LINE DEDENT while month > 0 : NEW_LINE INDENT day = day + days [ 0 ] NEW_LINE month += 1 NEW_LINE DEDENT return day NEW_LINE DEDENT d = \"2019-01\" NEW_LINE print ( dayOfYear ( d ) ) NEW_LINE"],"references":["days = [ 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] ; NEW_LINE def dayOfYear ( date ) : NEW_LINE INDENT year = ( int ) ( date [ 0 : 4 ] ) ; NEW_LINE month = ( int ) ( date [ 5 : 7 ] ) ; NEW_LINE day = ( int ) ( date [ 8 : ] ) ; NEW_LINE if ( month > 2 and year % 4 == 0 and ( year % 100 != 0 or year % 400 == 0 ) ) : NEW_LINE INDENT day += 1 ; NEW_LINE DEDENT month -= 1 ; NEW_LINE while ( month > 0 ) : NEW_LINE INDENT day = day + days [ month - 1 ] ; NEW_LINE month -= 1 ; NEW_LINE DEDENT return day ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT date = \"2019-01-09\" ; NEW_LINE print ( dayOfYear ( date ) ) ; NEW_LINE DEDENT"],"bleu":0.34548073694935916,"rouge_l":0.6690448301565328}
{"id":1364,"predictions":["def isUnary ( n ) : NEW_LINE INDENT if ( n == 1 or n == 7 ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( n \/ 10 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT x = n % 10 NEW_LINE sum = sum + x * x NEW_LINE n = n \/ 10 NEW_LINE DEDENT return isUnary ( sum ) NEW_LINE DEDENT def countUnary ( a , b ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT if ( isUnary ( i ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 1000 NEW_LINE b = 1099 NEW_LINE print ( countUnary ( a , b ) ) NEW_LINE DEDENT"],"references":["def isUnary ( n ) : NEW_LINE INDENT if ( n == 1 or n == 7 ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( int ( n \/ 10 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT x = n % 10 NEW_LINE sum = sum + x * x NEW_LINE n = int ( n \/ 10 ) NEW_LINE DEDENT return isUnary ( sum ) NEW_LINE DEDENT def countUnary ( a , b ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( a , b + 1 , 1 ) : NEW_LINE INDENT if ( isUnary ( i ) == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 1000 NEW_LINE b = 1099 NEW_LINE print ( countUnary ( a , b ) ) NEW_LINE DEDENT"],"bleu":0.8648436610985961,"rouge_l":0.9526569099302623}
{"id":1365,"predictions":["def find_count ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in arr : NEW_LINE INDENT x = bin ( i ) . count ( '1' ) NEW_LINE if ( i % x == 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE print ( find_count ( arr , arr ) ) NEW_LINE DEDENT"],"references":["def bitsoncount ( x ) : NEW_LINE INDENT return bin ( x ) . count ( '1' ) NEW_LINE DEDENT def find_count ( arr ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in arr : NEW_LINE INDENT x = bitsoncount ( i ) NEW_LINE if ( i % x == 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE print ( find_count ( arr ) ) NEW_LINE"],"bleu":0.7540225343551831,"rouge_l":0.7589761820120866}
{"id":1366,"predictions":["MOD = 1000000007 ; NEW_LINE def product ( ar , n ) : NEW_LINE INDENT result = 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT result = ( result * ar [ i ] ) % MOD ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT ar = [ 1 , 2 , 3 , 4 , 5 ] ; NEW_LINE n = len ( ar ) ; NEW_LINE print ( product ( ar , n ) ) ; NEW_LINE"],"references":["MOD = 1000000007 NEW_LINE def product ( ar , n ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT result = ( result * ar [ i ] ) % MOD NEW_LINE DEDENT return result NEW_LINE DEDENT ar = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( ar ) NEW_LINE print ( product ( ar , n ) ) NEW_LINE"],"bleu":0.7735525291038211,"rouge_l":0.9500404530744335}
{"id":1367,"predictions":["MOD = 1000000007 NEW_LINE def SieveOfEratosthenes ( prime , p_size ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( sqrt ( p_size ) ) + 1 ) : NEW_LINE INDENT if ( p * p > p_size ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT def productPrimeFreq ( arr , n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) NEW_LINE SieveOfEratosthenes ( prime , n + 1 ) NEW_LINE m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT m [ arr [ i ] ] = m . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT product = 1 NEW_LINE for key , value in m . items ( ) : NEW_LINE INDENT if ( prime [ key ] ) : NEW_LINE INDENT product *= ( key ) NEW_LINE product %= MOD NEW_LINE DEDENT DEDENT return product NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 4 , 6 , 5 , 4 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( productPrimeFreq ( arr , n ) ) NEW_LINE DEDENT"],"references":["MOD = 1000000007 NEW_LINE def SieveOfEratosthenes ( prime , p_size ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , p_size ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( 2 * p , p_size , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def productPrimeFreq ( arr , n ) : NEW_LINE INDENT prime = [ True for i in range ( n + 1 ) ] NEW_LINE SieveOfEratosthenes ( prime , n + 1 ) NEW_LINE i , j = 0 , 0 NEW_LINE m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT m [ arr [ i ] ] = m . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT product = 1 NEW_LINE for it in m : NEW_LINE INDENT if ( prime [ m [ it ] ] ) : NEW_LINE INDENT product *= it % MOD NEW_LINE product %= MOD NEW_LINE DEDENT DEDENT return product NEW_LINE DEDENT arr = [ 5 , 4 , 6 , 5 , 4 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( productPrimeFreq ( arr , n ) ) NEW_LINE"],"bleu":0.7413182234743927,"rouge_l":0.8197039379131935}
{"id":1368,"predictions":["def maxval ( a , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT print ( \" Invalid ▁ Input \" ) NEW_LINE return - 9 NEW_LINE DEDENT min1 = 0 NEW_LINE max2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = a [ i ] + i NEW_LINE if ( x > max1 ) : NEW_LINE INDENT max2 = max1 NEW_LINE max1 = x NEW_LINE DEDENT elif ( x > max2 and x != max1 ) : NEW_LINE INDENT max2 = x NEW_LINE DEDENT DEDENT return ( max1 * min2 ) NEW_LINE DEDENT arr = [ 4 , 5 , 3 , 1 , 10 ] NEW_LINE l = len ( arr ) NEW_LINE print ( maxval ( arr , l ) ) NEW_LINE"],"references":["def maxval ( a , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT print ( \" Invalid ▁ Input \" ) NEW_LINE return - 9999 NEW_LINE DEDENT ( max1 , max2 ) = ( 0 , 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = a [ i ] + i NEW_LINE if ( x > max1 ) : NEW_LINE INDENT max2 = max1 NEW_LINE max1 = x NEW_LINE DEDENT elif ( x > max2 and x != max1 ) : NEW_LINE INDENT max2 = x NEW_LINE DEDENT DEDENT return ( max1 * max2 ) NEW_LINE DEDENT print ( maxval ( [ 4 , 5 , 3 , 1 , 10 ] , 5 ) ) NEW_LINE"],"bleu":0.7843922901880303,"rouge_l":0.8644952759820986}
{"id":1369,"predictions":["class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data ; NEW_LINE self . left = None ; NEW_LINE self . right = None ; NEW_LINE DEDENT DEDENT def minPathSumUtil ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( root . left == None and root . right == None ) : NEW_LINE INDENT return root . data ; NEW_LINE DEDENT ls = minPathSumUtil ( root . left ) ; NEW_LINE rs = minPathSumUtil ( root . right ) ; NEW_LINE if ( root . left != None and root . right != None ) : NEW_LINE INDENT result = min ( result , ls + root . data ) ; NEW_LINE return min ( ls + root . data , rs + root . data ) ; NEW_LINE DEDENT if ( root . left == None ) : NEW_LINE INDENT return rs + root . data ; NEW_LINE DEDENT else : NEW_LINE INDENT return ls + root . data ; NEW_LINE DEDENT DEDENT def minPathSum ( root ) : NEW_LINE INDENT result = sys . maxsize ; NEW_LINE minPathSumUtil ( root ) ; NEW_LINE return result ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 4 ) ; NEW_LINE root . left = newNode ( 5 ) ; NEW_LINE root . right = newNode ( - 6 ) ; NEW_LINE root . left . left = newNode ( - 6 ) ; NEW_LINE root . left . left = newNode ( 2 ) ; NEW_LINE root . left . right = newNode ( - 3 ) ; NEW_LINE root . left . left . right = newNode ( - 3 ) ; NEW_LINE root . right . left = newNode ( 8 ) ; NEW_LINE print ( minPathSum ( root ) ) ; NEW_LINE DEDENT"],"references":["class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def newNode ( data ) : NEW_LINE INDENT node = Node ( 0 ) NEW_LINE node . data = data NEW_LINE node . left = node . right = None NEW_LINE return ( node ) NEW_LINE DEDENT result = - 1 NEW_LINE def minPathSumUtil ( root ) : NEW_LINE INDENT global result NEW_LINE if ( root == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( root . left == None and root . right == None ) : NEW_LINE INDENT return root . data NEW_LINE DEDENT ls = minPathSumUtil ( root . left ) NEW_LINE rs = minPathSumUtil ( root . right ) NEW_LINE if ( root . left != None and root . right != None ) : NEW_LINE INDENT result = min ( result , ls + rs + root . data ) NEW_LINE return min ( ls + root . data , rs + root . data ) NEW_LINE DEDENT if ( root . left == None ) : NEW_LINE INDENT return rs + root . data NEW_LINE DEDENT else : NEW_LINE INDENT return ls + root . data NEW_LINE DEDENT DEDENT def minPathSum ( root ) : NEW_LINE INDENT global result NEW_LINE result = 9999999 NEW_LINE minPathSumUtil ( root ) NEW_LINE return result NEW_LINE DEDENT root = newNode ( 4 ) NEW_LINE root . left = newNode ( 5 ) NEW_LINE root . right = newNode ( - 6 ) NEW_LINE root . left . left = newNode ( 2 ) NEW_LINE root . left . right = newNode ( - 3 ) NEW_LINE root . right . left = newNode ( 1 ) NEW_LINE root . right . right = newNode ( 8 ) NEW_LINE print ( minPathSum ( root ) ) NEW_LINE"],"bleu":0.7086064174272975,"rouge_l":0.8271289902932053}
{"id":1370,"predictions":["def andOperator ( a , b ) : NEW_LINE INDENT while ( a < b ) : NEW_LINE INDENT b -= int ( b & - b ) NEW_LINE DEDENT return b NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 10 NEW_LINE b = 15 NEW_LINE print ( andOperator ( a , b ) ) NEW_LINE DEDENT"],"references":["def andOperator ( a , b ) : NEW_LINE INDENT while ( a < b ) : NEW_LINE INDENT b -= ( b & - b ) NEW_LINE DEDENT return b NEW_LINE DEDENT a , b = 10 , 15 NEW_LINE print ( andOperator ( a , b ) ) NEW_LINE"],"bleu":0.6522784659762502,"rouge_l":0.8399311531841652}
{"id":1371,"predictions":["from math import gcd NEW_LINE def countPrimitiveRoots ( p ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 2 , p ) : NEW_LINE INDENT if ( gcd ( i , p ) == 1 ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT p = 5 NEW_LINE print ( countPrimitiveRoots ( p - 1 ) ) NEW_LINE"],"references":["from math import gcd NEW_LINE def countPrimitiveRoots ( p ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 2 , p , 1 ) : NEW_LINE INDENT if ( gcd ( i , p ) == 1 ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT p = 5 NEW_LINE print ( countPrimitiveRoots ( p - 1 ) ) NEW_LINE DEDENT"],"bleu":0.7510937110842593,"rouge_l":0.876474372721424}
{"id":1372,"predictions":["def printPattern ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , 2 * n ) : NEW_LINE INDENT if ( j == ( n - i + 1 ) or j == ( n + i - 1 ) ) : NEW_LINE INDENT print ( \" * ▁ \" , end = \" \" ) NEW_LINE DEDENT elif ( ( i >= 4 and i <= n - 4 ) and ( j == n - i + 4 | j == n + i - 4 ) ) : NEW_LINE INDENT print ( \" * \" , end = \" ▁ \" ) NEW_LINE DEDENT elif ( i == 0 or i == - 4 and i >= ( n - 2 * 4 ) and i < ( n - 2 * 4 ) ) : NEW_LINE INDENT print ( \" * ▁ \" , end = \" ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" ▁ \" , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 9 NEW_LINE printPattern ( N ) NEW_LINE DEDENT"],"references":["def printPattern ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , 2 * n ) : NEW_LINE INDENT if ( j == ( n - i + 1 ) or j == ( n + i - 1 ) ) : NEW_LINE INDENT print ( \" * ▁ \" , end = \" \" ) NEW_LINE DEDENT elif ( ( i >= 4 and i <= n - 4 ) and ( j == n - i + 4 or j == n + i - 4 ) ) : NEW_LINE INDENT print ( \" * ▁ \" , end = \" \" ) NEW_LINE DEDENT elif ( i == n or ( i == n - 4 and j >= n - ( n - 2 * 4 ) and j <= n + n - 2 * 4 ) ) : NEW_LINE INDENT print ( \" * ▁ \" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" ▁ \" + \" ▁ \" , end = \" \" ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT N = 9 NEW_LINE printPattern ( N ) NEW_LINE"],"bleu":0.8275598942930915,"rouge_l":0.9129941794542293}
{"id":1373,"predictions":["def printOrder ( arr , n , k ) : NEW_LINE INDENT len1 = k NEW_LINE len2 = n - k NEW_LINE arr1 = [ 0 for i in range ( k ) ] NEW_LINE arr2 = [ 0 for i in range ( n ) ] NEW_LINE arr2 = [ 0 for i in range ( k ) ] NEW_LINE arr2 . sort ( ) NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT arr2 [ i ] = arr1 [ i ] NEW_LINE DEDENT arr1 . sort ( reverse = True ) NEW_LINE arr2 . sort ( reverse = False ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i < k ) : NEW_LINE INDENT arr [ i ] = arr1 [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = arr2 [ len2 - 1 ] NEW_LINE len2 -= 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 5 , 4 , 6 , 2 , 1 , 3 , 8 , 9 , - 1 ] NEW_LINE k = 4 NEW_LINE n = len ( arr ) NEW_LINE printOrder ( arr , n , k ) NEW_LINE"],"references":["def printOrder ( arr , n , k ) : NEW_LINE INDENT len1 = k NEW_LINE len2 = n - k NEW_LINE arr1 = [ 0 ] * k NEW_LINE arr2 = [ 0 ] * ( n - k ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT arr1 [ i ] = arr [ i ] NEW_LINE DEDENT for i in range ( k , n ) : NEW_LINE INDENT arr2 [ i - k ] = arr [ i ] NEW_LINE DEDENT arr1 . sort ( ) NEW_LINE arr2 . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i < k ) : NEW_LINE INDENT arr [ i ] = arr1 [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = arr2 [ len2 - 1 ] NEW_LINE len2 -= 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 5 , 4 , 6 , 2 , 1 , 3 , 8 , 9 , - 1 ] NEW_LINE k = 4 NEW_LINE n = len ( arr ) NEW_LINE printOrder ( arr , n , k ) NEW_LINE DEDENT"],"bleu":0.8082361719262356,"rouge_l":0.8600634473034896}
{"id":1374,"predictions":["def isPlusPossible ( arr , n ) : NEW_LINE INDENT mp = dict . fromkeys ( arr , 0 ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 ; NEW_LINE DEDENT foundModOne = False ; NEW_LINE for key , value in mp . items ( ) : NEW_LINE INDENT value = key ; NEW_LINE frequency = value ; NEW_LINE if ( frequency % 4 == 0 ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT if ( frequency % 4 == 1 ) : NEW_LINE INDENT if ( foundModOne ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT foundModOne = True ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 1 , 1 , 1 , 2 , 2 , 2 , 3 , 2 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE if ( isPlusPossible ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"],"references":["def isPlusPossible ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] = mp . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT foundModOne = False NEW_LINE for x in mp : NEW_LINE INDENT element = x NEW_LINE frequency = mp [ x ] NEW_LINE if ( frequency % 4 == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( frequency % 4 == 1 ) : NEW_LINE INDENT if ( foundModOne == True ) : NEW_LINE INDENT return False NEW_LINE DEDENT foundModOne = True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT arr = [ 1 , 1 , 1 , 1 , 2 , 2 , 2 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE if ( isPlusPossible ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.6571989243814079,"rouge_l":0.8425694791146613}
{"id":1375,"predictions":["def sumOfAP ( a , d , n ) : NEW_LINE INDENT sum = ( n \/ 2 ) * ( 2 * a + ( n - 1 ) * d ) ; NEW_LINE return sum ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 20 ; NEW_LINE a = 2.5 ; d = 1.5 ; NEW_LINE print ( sumOfAP ( a , d , n ) ) ; NEW_LINE DEDENT"],"references":["def sumOfAP ( a , d , n ) : NEW_LINE INDENT sum = ( n \/ 2 ) * ( 2 * a + ( n - 1 ) * d ) NEW_LINE return sum NEW_LINE DEDENT n = 20 NEW_LINE a = 2.5 NEW_LINE d = 1.5 NEW_LINE print ( sumOfAP ( a , d , n ) ) NEW_LINE"],"bleu":0.6286371153317584,"rouge_l":0.8740897345548508}
{"id":1376,"predictions":["from math import sqrt NEW_LINE def isPerfectSquare ( num ) : NEW_LINE INDENT n = int ( sqrt ( num ) ) NEW_LINE if ( n * n == num ) : NEW_LINE INDENT return ( n * n == num ) NEW_LINE DEDENT return ( n * n == num ) NEW_LINE DEDENT def checkFib ( array , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( isPerfectSquare ( 5 * array [ i ] * array [ i ] + 4 ) or isPerfectSquare ( 5 * array [ i ] - 4 ) ) : NEW_LINE INDENT print ( array [ i ] , end = \" ▁ \" ) NEW_LINE count = count + 1 NEW_LINE DEDENT DEDENT if ( count == 0 ) : NEW_LINE INDENT print ( \" None ▁ Present \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 4 , 2 , 8 , 5 , 20 , 1 , 40 , 12 , 15 , 20 ] NEW_LINE n = len ( arr ) NEW_LINE checkFib ( arr , n ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def isPerfectSquare ( num ) : NEW_LINE INDENT n = int ( math . sqrt ( num ) ) NEW_LINE return ( n * n == num ) NEW_LINE DEDENT def checkFib ( array , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( isPerfectSquare ( 5 * array [ i ] * array [ i ] + 4 ) or isPerfectSquare ( 5 * array [ i ] * array [ i ] - 4 ) ) : NEW_LINE INDENT print ( array [ i ] , \" ▁ \" , end = \" \" ) ; NEW_LINE count = count + 1 NEW_LINE DEDENT DEDENT if ( count == 0 ) : NEW_LINE INDENT print ( \" None ▁ present \" ) ; NEW_LINE DEDENT DEDENT array = [ 4 , 2 , 8 , 5 , 20 , 1 , 40 , 13 , 23 ] NEW_LINE n = len ( array ) NEW_LINE checkFib ( array , n ) NEW_LINE"],"bleu":0.6834046817278434,"rouge_l":0.8329611817244932}
{"id":1377,"predictions":["import math NEW_LINE def largestCube ( r ) : NEW_LINE INDENT if ( r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = ( 2 * r ) \/ math . sqrt ( 3 ) NEW_LINE return int ( a ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT r = 5 NEW_LINE print ( largestCube ( r ) ) NEW_LINE DEDENT"],"references":["from math import sqrt NEW_LINE def largestCube ( r ) : NEW_LINE INDENT if ( r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = ( 2 * r ) \/ sqrt ( 3 ) NEW_LINE return a NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT r = 5 NEW_LINE print ( \" { 0 : . 6 } \" . format ( largestCube ( r ) ) ) NEW_LINE DEDENT"],"bleu":0.7518828739673777,"rouge_l":0.8555578815155954}
{"id":1378,"predictions":["def countTransOperation ( a , b ) : NEW_LINE INDENT n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE if ( m == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT dp = [ [ 0 for x in range ( n ) ] for y in range ( m ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT if ( j == 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE DEDENT elif ( a [ j ] == b [ i ] ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ j ] [ j ] = dp [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT elif ( a [ j ] == b [ i ] ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT return dp [ m - 1 ] [ n - 1 ] NEW_LINE DEDENT a = \" abcccdf \" NEW_LINE b = \" abccpdf \" NEW_LINE print ( countTransigning ( a , b ) ) NEW_LINE"],"references":["def countTransformation ( a , b ) : NEW_LINE INDENT n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE if m == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT dp = [ [ 0 ] * ( n ) for _ in range ( m ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT if j == 0 : NEW_LINE INDENT if a [ j ] == b [ i ] : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT elif a [ j ] == b [ i ] : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if a [ j ] == b [ i ] : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT return dp [ m - 1 ] [ n - 1 ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = \" abcccdf \" NEW_LINE b = \" abccdf \" NEW_LINE print ( countTransformation ( a , b ) ) NEW_LINE DEDENT"],"bleu":0.7684009781515453,"rouge_l":0.8703192956401825}
{"id":1379,"predictions":["def findFourElements ( arr , n , X ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n , 1 ) : NEW_LINE INDENT mp [ arr [ i ] + arr [ j ] ] = ( i , j ) NEW_LINE DEDENT DEDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n , 1 ) : NEW_LINE INDENT sum = arr [ i ] + arr [ j ] NEW_LINE if ( X - sum in mp . keys ( ) ) : NEW_LINE INDENT p = mp [ X - sum ] NEW_LINE if ( p [ 0 ] != i and p [ 0 ] != j and p [ 0 ] != j and p [ 1 ] != j ) : NEW_LINE INDENT print ( arr [ i ] , \" , arr [ 1 ] , \" , ▁ \" , arr [ 0 ] , \" , arr [ 1 ] ] ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT arr = [ 17 , 0 , 10 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE X = 9 NEW_LINE findFourElements ( arr , n , X ) NEW_LINE"],"references":["def findFourElements ( arr , n , X ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT mp [ arr [ i ] + arr [ j ] ] = [ i , j ] NEW_LINE DEDENT DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT summ = arr [ i ] + arr [ j ] NEW_LINE if ( X - summ ) in mp : NEW_LINE INDENT p = mp [ X - summ ] NEW_LINE if ( p [ 0 ] != i and p [ 0 ] != j and p [ 1 ] != i and p [ 1 ] != j ) : NEW_LINE INDENT print ( arr [ i ] , \" , ▁ \" , arr [ j ] , \" , ▁ \" , arr [ p [ 0 ] ] , \" , ▁ \" , arr [ p [ 1 ] ] , sep = \" \" ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT arr = [ 10 , 20 , 30 , 40 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE X = 91 NEW_LINE findFourElements ( arr , n , X ) NEW_LINE"],"bleu":0.7627439155895751,"rouge_l":0.8780520616129682}
{"id":1380,"predictions":["def countWays ( n ) : NEW_LINE INDENT counter = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT for k in range ( j , n ) : NEW_LINE INDENT if ( i + j + k + l == n ) : NEW_LINE INDENT counter = counter + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return counter NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 8 NEW_LINE print ( countWays ( n ) ) NEW_LINE DEDENT"],"references":["def countWays ( n ) : NEW_LINE INDENT counter = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT for k in range ( j , n ) : NEW_LINE INDENT for l in range ( k , n ) : NEW_LINE INDENT if ( i + j + k + l == n ) : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return counter NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 8 NEW_LINE print ( countWays ( n ) ) NEW_LINE DEDENT"],"bleu":0.8145183442026442,"rouge_l":0.895044168288666}
{"id":1381,"predictions":["def maxConsecutiveOnes ( x ) : NEW_LINE INDENT count = 0 NEW_LINE while ( x ) : NEW_LINE INDENT x = ( x & ( x << 1 ) ) NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT print ( maxConsecutiveOnes ( 14 ) ) NEW_LINE"],"references":["def maxConsecutiveOnes ( x ) : NEW_LINE INDENT count = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT x = ( x & ( x << 1 ) ) NEW_LINE count = count + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT print ( maxConsecutiveOnes ( 14 ) ) NEW_LINE print ( maxConsecutiveOnes ( 222 ) ) NEW_LINE"],"bleu":0.7112872761738783,"rouge_l":0.8532738095238095}
{"id":1382,"predictions":["def isFsginals ( num ) : NEW_LINE INDENT freq = [ 0 for i in range ( 10 ) ] NEW_LINE val = \" \" NEW_LINE for i in range ( len ( val ) ) : NEW_LINE INDENT digit = ord ( val [ i ] ) - ord ( '0' ) NEW_LINE if ( freq [ digit ] > 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT freq [ digit ] += 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , len ( freq ) ) : NEW_LINE INDENT if ( freq [ i ] == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT num = 327 NEW_LINE if ( num < 100 ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def isFascinating ( num ) : NEW_LINE INDENT freq = [ 0 ] * 10 NEW_LINE val = ( str ( num ) + str ( num * 2 ) + str ( num * 3 ) ) NEW_LINE for i in range ( len ( val ) ) : NEW_LINE INDENT digit = int ( val [ i ] ) NEW_LINE if freq [ digit ] > 0 : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT freq [ digit ] += 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , 10 ) : NEW_LINE INDENT if freq [ i ] == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT num = 192 NEW_LINE if num < 100 : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = isFascinating ( num ) NEW_LINE if ans : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT DEDENT"],"bleu":0.6141711201813941,"rouge_l":0.7659690627843494}
{"id":1383,"predictions":["def printDistinct ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( 0 , i ) : NEW_LINE INDENT if ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( i == j ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 6 , 10 , 5 , 4 , 9 , 100 , 4 , 6 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE printDistinct ( arr , n ) NEW_LINE"],"references":["def printDistinct ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT d = 0 NEW_LINE for j in range ( 0 , i ) : NEW_LINE INDENT if ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT d = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( d == 0 ) : NEW_LINE INDENT print ( arr [ i ] ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 6 , 10 , 5 , 4 , 9 , 120 , 4 , 6 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE printDistinct ( arr , n ) NEW_LINE"],"bleu":0.8051275698592872,"rouge_l":0.9015205343186015}
{"id":1384,"predictions":["def closestMultiple ( n , x ) : NEW_LINE INDENT if ( x > n ) : NEW_LINE INDENT return x NEW_LINE DEDENT n = n + x \/\/ 2 NEW_LINE n = n - ( n % x ) NEW_LINE return n NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 56287 NEW_LINE x = 27 NEW_LINE print ( closestMultiple ( n , x ) ) NEW_LINE DEDENT"],"references":["def closestMultiple ( n , x ) : NEW_LINE INDENT if x > n : NEW_LINE INDENT return x ; NEW_LINE DEDENT z = ( int ) ( x \/ 2 ) ; NEW_LINE n = n + z ; NEW_LINE n = n - ( n % x ) ; NEW_LINE return n ; NEW_LINE DEDENT n = 56287 ; NEW_LINE x = 27 ; NEW_LINE print ( closestMultiple ( n , x ) ) ; NEW_LINE"],"bleu":0.5515364082277358,"rouge_l":0.7475174308049863}
{"id":1385,"predictions":["MAX = 1000 NEW_LINE def maxSubsequenceSubsequence ( x , y , n , m ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( MAX ) ] for i in range ( MAX ) ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( x [ j - 1 ] == y [ i - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT ans = max ( ans , dp [ i ] [ n ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = \" ABCD \" NEW_LINE y = \" BACDCD \" NEW_LINE n = len ( x ) NEW_LINE m = len ( y ) NEW_LINE print ( maxSubsequence ( x , y , n , m ) ) NEW_LINE DEDENT"],"references":["MAX = 1000 NEW_LINE def maxSubsequenceSubstring ( x , y , n , m ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( MAX ) ] for i in range ( MAX ) ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( x [ j - 1 ] == y [ i - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT ans = max ( ans , dp [ i ] [ n ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT x = \" ABCD \" NEW_LINE y = \" BACDBDCD \" NEW_LINE n = len ( x ) NEW_LINE m = len ( y ) NEW_LINE print ( maxSubsequenceSubstring ( x , y , n , m ) ) NEW_LINE"],"bleu":0.8981265515657345,"rouge_l":0.9600539608783633}
{"id":1386,"predictions":["import math NEW_LINE def findMaxGCD ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE high = arr [ n - 1 ] NEW_LINE divisors = [ 0 ] * ( high + 1 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 1 , int ( math . sqrt ( arr [ i ] ) + 1 ) ) : NEW_LINE INDENT if ( arr [ i ] % j == 0 ) : NEW_LINE INDENT divisors [ j ] += 1 NEW_LINE if ( j != arr [ i ] \/\/ j ) : NEW_LINE INDENT divisors [ arr [ i ] \/ j ] += 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( high , 0 , - 1 ) : NEW_LINE INDENT if ( divisors [ i ] >= k ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT arr = [ 1 , 2 , 4 , 8 , 8 , 12 ] NEW_LINE k = 3 NEW_LINE n = len ( arr ) NEW_LINE print ( findMaxGCD ( arr , n , k ) ) NEW_LINE"],"references":["import math NEW_LINE def findMaxGCD ( arr , n , k ) : NEW_LINE INDENT high = max ( arr ) NEW_LINE divisors = [ 0 ] * ( high + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 1 , int ( math . sqrt ( arr [ i ] ) ) + 1 ) : NEW_LINE INDENT if ( arr [ i ] % j == 0 ) : NEW_LINE INDENT divisors [ j ] += 1 NEW_LINE if ( j != arr [ i ] \/\/ j ) : NEW_LINE INDENT divisors [ arr [ i ] \/\/ j ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( high , 0 , - 1 ) : NEW_LINE INDENT if ( divisors [ i ] >= k ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 8 , 8 , 12 ] NEW_LINE k = 3 NEW_LINE n = len ( arr ) NEW_LINE print ( findMaxGCD ( arr , n , k ) ) NEW_LINE DEDENT"],"bleu":0.8635919075160552,"rouge_l":0.9065196548418026}
{"id":1387,"predictions":["def Max_Sum ( n ) : NEW_LINE INDENT return int ( ( n * ( n - 1 ) ) \/ 2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 8 NEW_LINE print ( Max_Sum ( n ) ) NEW_LINE DEDENT"],"references":["def Max_Sum ( n ) : NEW_LINE INDENT return ( n * ( n - 1 ) ) \/\/ 2 ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 8 ; NEW_LINE print ( Max_Sum ( n ) ) ; NEW_LINE DEDENT"],"bleu":0.6757341717597496,"rouge_l":0.8823529411764706}
{"id":1388,"predictions":["lookup = [ [ [ - 1 for i in range ( 2 ) ] for j in range ( 1 , 1000 ) ] NEW_LINE def countRec ( digits , esum , osum , isOdd , n ) : NEW_LINE INDENT if ( digits == n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT 0 NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if ( lookup [ digits ] [ osum ] [ isOdd ] [ isOdd ] [ isOdd ] [ isOdd ] [ isOdd ] [ isOdd ] [ isOdd ] ) NEW_LINE DEDENT ans = 0 NEW_LINE if ( isOdd == 1 ) : NEW_LINE INDENT for i in range ( 10 ) : NEW_LINE INDENT ans += countRec ( digits + 1 , esum , osum + i , 0 , n ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += countRec ( digits + 1 , esum + i , osum , 1 , n ) NEW_LINE DEDENT lookup [ digits ] [ osum ] [ isOdd ] [ isOdd ] = ans NEW_LINE return ans NEW_LINE DEDENT def finalCount ( n ) : NEW_LINE INDENT digits = 0 NEW_LINE for i in range ( 50 ) : NEW_LINE INDENT for k in range ( 0 , 1000 ) : NEW_LINE INDENT if ( digits + 1 , esum + i , osum , 1 , n ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE jsum = 0 NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT ans += countRec ( digits + 1 ,eks , 1 , n ) NEW_LINE DEDENT return ans NEW_LINE DEDENT n = 3 NEW_LINE print ( \" Filln ▁ of \" , n , \" digit ▁ numbers ▁ is \" , finalCount ( n ) ) NEW_LINE"],"references":["def countRec ( digits , esum , osum , isOdd , n ) : NEW_LINE INDENT if digits == n : NEW_LINE INDENT return ( esum - osum == 1 ) NEW_LINE DEDENT if lookup [ digits ] [ esum ] [ osum ] [ isOdd ] != - 1 : NEW_LINE INDENT return lookup [ digits ] [ esum ] [ osum ] [ isOdd ] NEW_LINE DEDENT ans = 0 NEW_LINE if isOdd : NEW_LINE INDENT for i in range ( 10 ) : NEW_LINE INDENT ans += countRec ( digits + 1 , esum , osum + i , False , n ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( 10 ) : NEW_LINE INDENT ans += countRec ( digits + 1 , esum + i , osum , True , n ) NEW_LINE DEDENT DEDENT lookup [ digits ] [ esum ] [ osum ] [ isOdd ] = ans NEW_LINE return ans NEW_LINE DEDENT def finalCount ( n ) : NEW_LINE INDENT global lookup NEW_LINE digits = 0 NEW_LINE lookup = [ [ [ [ - 1 , - 1 ] for i in range ( 500 ) ] for j in range ( 500 ) ] for k in range ( 50 ) ] NEW_LINE ans = 0 NEW_LINE esum = 0 NEW_LINE osum = 0 NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT ans += countRec ( digits + 1 , esum + i , osum , True , n ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT lookup = [ ] NEW_LINE n = 3 NEW_LINE print ( \" Count ▁ of ▁ % d ▁ digit ▁ numbers ▁ is ▁ % d \" % ( n , finalCount ( n ) ) ) NEW_LINE DEDENT"],"bleu":0.6529426773676131,"rouge_l":0.6771772554333664}
{"id":1389,"predictions":["def lcsOf3 ( X , Y , Z , m , n , o ) : NEW_LINE INDENT L = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT for k in range ( n + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 or k == 0 ) : NEW_LINE INDENT L [ i ] [ j ] [ k ] = 0 NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] and X [ i - 1 ] == Z [ k - 1 ] ) : NEW_LINE INDENT L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = max ( max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) , L [ i ] [ j ] [ k ] ) NEW_LINE DEDENT L [ i ] [ j ] = max ( max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) , L [ i ] [ j ] [ k - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return L [ m ] [ n ] [ o ] NEW_LINE Y = \"12PSAYB \" NEW_LINE Z = \"12XBA \" NEW_LINE m = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE print ( \" Length ▁ of ▁ LCS ▁ is \" , lcsOf3 ( X , Y , Z , m , n , o ) ) NEW_LINE"],"references":["def lcsOf3 ( X , Y , Z , m , n , o ) : NEW_LINE INDENT L = [ [ [ 0 for i in range ( o + 1 ) ] for j in range ( n + 1 ) ] for k in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT for k in range ( o + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 or k == 0 ) : NEW_LINE INDENT L [ i ] [ j ] [ k ] = 0 NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] and X [ i - 1 ] == Z [ k - 1 ] ) : NEW_LINE INDENT L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] [ k ] = max ( max ( L [ i - 1 ] [ j ] [ k ] , L [ i ] [ j - 1 ] [ k ] ) , L [ i ] [ j ] [ k - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return L [ m ] [ n ] [ o ] NEW_LINE DEDENT X = ' AGGT12' NEW_LINE Y = '12TXAYB ' NEW_LINE Z = '12XBA ' NEW_LINE m = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE o = len ( Z ) NEW_LINE print ( ' Length ▁ of ▁ LCS ▁ is ' , lcsOf3 ( X , Y , Z , m , n , o ) ) NEW_LINE"],"bleu":0.819165514050691,"rouge_l":0.8588141978980766}
{"id":1390,"predictions":["import math NEW_LINE def printGreater ( x , y ) : NEW_LINE INDENT X = y * math . log ( x ) ; NEW_LINE Y = x * math . log ( y ) ; NEW_LINE if ( abs ( X - Y ) < 1e-9 ) : NEW_LINE INDENT print ( \" Equal \" ) ; NEW_LINE DEDENT elif ( X > Y ) : NEW_LINE INDENT print ( x , \" ^ \" , y ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( y , \" ^ \" , x ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 5 ; y = 8 ; NEW_LINE printGreater ( x , y ) ; NEW_LINE DEDENT"],"references":["import math NEW_LINE def printGreater ( x , y ) : NEW_LINE INDENT X = y * math . log ( x ) ; NEW_LINE Y = x * math . log ( y ) ; NEW_LINE if ( abs ( X - Y ) < 1e-9 ) : NEW_LINE INDENT print ( \" Equal \" ) ; NEW_LINE DEDENT elif ( X > Y ) : NEW_LINE INDENT print ( x , \" ^ \" , y ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( y , \" ^ \" , x ) ; NEW_LINE DEDENT DEDENT x = 5 ; NEW_LINE y = 8 ; NEW_LINE printGreater ( x , y ) ; NEW_LINE"],"bleu":0.8712198426440146,"rouge_l":0.9486906819088131}
{"id":1391,"predictions":["def getElement ( a , n , S ) : NEW_LINE INDENT a = sorted ( a ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( sum + ( a [ i ] * ( n - i ) ) == S ) : NEW_LINE INDENT return a [ i ] NEW_LINE DEDENT sum += a [ i ] NEW_LINE DEDENT return - 1 NEW_LINE DEDENT S = 5 NEW_LINE a = [ 1 , 3 , 2 , 5 , 8 ] NEW_LINE n = len ( a ) NEW_LINE print ( getElement ( a , n , S ) ) NEW_LINE"],"references":["def getElement ( a , n , S ) : NEW_LINE INDENT a . sort ( ) ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( sum + ( a [ i ] * ( n - i ) ) == S ) : NEW_LINE INDENT return a [ i ] ; NEW_LINE DEDENT sum += a [ i ] ; NEW_LINE DEDENT return - 1 ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = 5 ; NEW_LINE a = [ 1 , 3 , 2 , 5 , 8 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( getElement ( a , n , S ) ) ; NEW_LINE DEDENT"],"bleu":0.67980396217384,"rouge_l":0.8721143756558236}
{"id":1392,"predictions":["def canMakeEqual ( a , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT while ( a [ i ] % 5 == 0 ) : NEW_LINE INDENT a [ i ] \/\/= 5 NEW_LINE DEDENT while ( a [ i ] % 3 == 0 ) : NEW_LINE INDENT a [ i ] \/\/= 3 NEW_LINE DEDENT DEDENT last = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( a [ i ] != last ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 18 , 30 , 54 , 90 , 162 ] NEW_LINE n = len ( arr ) NEW_LINE if ( canMakeEqual ( arr , n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"references":["def canMakeEqual ( a , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT while ( a [ i ] % 5 == 0 ) : NEW_LINE INDENT a [ i ] \/\/= 5 ; NEW_LINE DEDENT while ( a [ i ] % 3 == 0 ) : NEW_LINE INDENT a [ i ] \/\/= 3 ; NEW_LINE DEDENT DEDENT last = a [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( a [ i ] != last ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 18 , 30 , 54 , 90 , 162 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE if ( canMakeEqual ( arr , n ) ) : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE DEDENT DEDENT"],"bleu":0.8433958850979613,"rouge_l":0.9587647928994082}
{"id":1393,"predictions":["x = 10 NEW_LINE y = 5 NEW_LINE x = x ^ y NEW_LINE y = x ^ y NEW_LINE x = x ^ y NEW_LINE print ( \" After ▁ swap : ▁ x ▁ = \" , x , \" , ▁ y ▁ = \" , y ) NEW_LINE"],"references":["x = 10 NEW_LINE y = 5 NEW_LINE x = x ^ y ; NEW_LINE y = x ^ y ; NEW_LINE x = x ^ y ; NEW_LINE print ( \" After ▁ Swapping : ▁ x ▁ = ▁ \" , x , \" ▁ y ▁ = \" , y ) NEW_LINE"],"bleu":0.728326578141446,"rouge_l":0.9298780487804879}
{"id":1394,"predictions":["def minimumOperations ( a , n ) : NEW_LINE INDENT map = dict . fromkeys ( a , 0 ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT map [ a [ i ] ] += 1 ; NEW_LINE DEDENT count = 0 ; NEW_LINE for key , value in map . items ( ) : NEW_LINE INDENT if value > 1 : NEW_LINE INDENT count += ( value - 1 ) ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 2 , 1 , 2 , 3 , 3 , 4 , 3 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( minimumOperations ( a , n ) ) ; NEW_LINE DEDENT"],"references":["def minimumOperations ( a , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] in mp . keys ( ) : NEW_LINE INDENT mp [ a [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ a [ i ] ] = 1 NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for it in mp : NEW_LINE INDENT if ( mp [ it ] > 1 ) : NEW_LINE INDENT count += mp [ it ] - 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT a = [ 2 , 1 , 2 , 3 , 3 , 4 , 3 ] NEW_LINE n = len ( a ) NEW_LINE print ( minimumOperations ( a , n ) ) NEW_LINE"],"bleu":0.5384239363152248,"rouge_l":0.6917897223862965}
{"id":1395,"predictions":["def xorRange ( pre , l , r ) : NEW_LINE INDENT cntOnes = pre [ r ] NEW_LINE if l - 1 >= 0 : NEW_LINE INDENT cntOnes -= pre [ l - 1 ] NEW_LINE DEDENT if cntOnes % 2 == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT def performQueries ( queries , q , a , n ) : NEW_LINE INDENT pre = [ 0 ] * n NEW_LINE pre [ 0 ] = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT pre [ i ] = pre [ i - 1 ] + a [ i ] NEW_LINE DEDENT for i in range ( q ) : NEW_LINE INDENT print ( xorRange ( pre , queries [ i ] [ 0 ] , queries [ i ] [ 0 ] ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 0 , 1 , 1 , 0 , 1 , 1 ] NEW_LINE n = len ( a ) NEW_LINE queries = [ [ 0 , 3 ] , [ 0 , 2 ] ] NEW_LINE q = len ( queries ) NEW_LINE performQueries ( queries , q , a , n ) NEW_LINE DEDENT"],"references":["def xorRange ( pre , l , r ) : NEW_LINE INDENT cntOnes = pre [ r ] NEW_LINE if ( l - 1 >= 0 ) : NEW_LINE INDENT cntOnes -= pre [ l - 1 ] NEW_LINE DEDENT if ( cntOnes % 2 == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT def performQueries ( queries , q , a , n ) : NEW_LINE INDENT pre = [ 0 for i in range ( n ) ] NEW_LINE pre [ 0 ] = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT pre [ i ] = pre [ i - 1 ] + a [ i ] NEW_LINE DEDENT for i in range ( q ) : NEW_LINE INDENT print ( xorRange ( pre , queries [ i ] [ 0 ] , queries [ i ] [ 1 ] ) ) NEW_LINE DEDENT DEDENT a = [ 1 , 0 , 1 , 1 , 0 , 1 , 1 ] NEW_LINE n = len ( a ) NEW_LINE queries = [ [ 0 , 3 ] , [ 0 , 2 ] ] NEW_LINE q = len ( queries ) NEW_LINE performQueries ( queries , q , a , n ) NEW_LINE"],"bleu":0.8775444419443201,"rouge_l":0.9383940766300051}
{"id":1396,"predictions":["def countNums ( n , x , y ) : NEW_LINE INDENT arr = [ True for x in range ( n + 1 ) ] NEW_LINE if ( x <= n ) : NEW_LINE INDENT arr [ x ] = True NEW_LINE DEDENT if ( y <= n ) : NEW_LINE INDENT arr [ y ] = True NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( min ( x , y ) , 1 ) : NEW_LINE INDENT if ( arr [ i ] ) : NEW_LINE INDENT if ( i + x <= n ) : NEW_LINE INDENT arr [ i + x ] = True NEW_LINE DEDENT if ( i + y <= n ) : NEW_LINE INDENT arr [ i + y ] = True NEW_LINE DEDENT result = result + 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT n = 15 NEW_LINE x = 5 NEW_LINE y = 7 NEW_LINE print ( countNums ( n , x , y ) ) NEW_LINE"],"references":["def countNums ( n , x , y ) : NEW_LINE INDENT arr = [ False for i in range ( n + 2 ) ] NEW_LINE if ( x <= n ) : NEW_LINE INDENT arr [ x ] = True NEW_LINE DEDENT if ( y <= n ) : NEW_LINE INDENT arr [ y ] = True NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( min ( x , y ) , n + 1 ) : NEW_LINE INDENT if ( arr [ i ] ) : NEW_LINE INDENT if ( i + x <= n ) : NEW_LINE INDENT arr [ i + x ] = True NEW_LINE DEDENT if ( i + y <= n ) : NEW_LINE INDENT arr [ i + y ] = True NEW_LINE DEDENT result = result + 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT n = 15 NEW_LINE x = 5 NEW_LINE y = 7 NEW_LINE print ( countNums ( n , x , y ) ) NEW_LINE"],"bleu":0.9457063380779263,"rouge_l":0.9755793909212793}
{"id":1397,"predictions":["def get_max_splits ( num_str ) : NEW_LINE INDENT count = 0 NEW_LINE running_sum = 0 NEW_LINE for i in range ( len ( num_str ) ) : NEW_LINE INDENT current_num = ord ( num_str [ i ] ) - ord ( '0' ) NEW_LINE running_sum += current_num NEW_LINE if ( current_num % 3 == 0 or running_sum % 3 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE running_sum = 0 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( get_max_splits ( \"12345\" ) ) NEW_LINE DEDENT"],"references":["def get_max_splits ( num_string ) : NEW_LINE INDENT count = 0 NEW_LINE running_sum = 0 NEW_LINE for i in range ( len ( num_string ) ) : NEW_LINE INDENT current_num = int ( num_string [ i ] ) NEW_LINE running_sum += current_num NEW_LINE if current_num % 3 == 0 or ( running_sum != 0 and running_sum % 3 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE running_sum = 0 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT print get_max_splits ( \"12345\" ) NEW_LINE"],"bleu":0.6188732288090824,"rouge_l":0.8244728779960353}
{"id":1398,"predictions":["def term ( n ) : NEW_LINE INDENT return n * ( n + 1 ) \/ 2 NEW_LINE DEDENT n = 4 NEW_LINE print ( term ( n ) ) NEW_LINE"],"references":["def term ( n ) : NEW_LINE INDENT return n * ( n + 1 ) \/ 2 NEW_LINE DEDENT n = 4 NEW_LINE print term ( n ) NEW_LINE"],"bleu":0.8693593986938244,"rouge_l":0.9734042553191491}
{"id":1399,"predictions":["def angleqcd ( z ) : NEW_LINE INDENT print ( \" The ▁ angle ▁ is ▁ \" , z , \" degrees \" ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT z = 48 ; NEW_LINE angleqord ( z ) ; NEW_LINE DEDENT"],"references":["def anglequichord ( z ) : NEW_LINE INDENT print ( \" The ▁ angle ▁ is ▁ \" , z , \" ▁ degrees \" ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT z = 48 NEW_LINE anglequichord ( z ) NEW_LINE DEDENT"],"bleu":0.6534840650932914,"rouge_l":0.8876937677950015}
{"id":1400,"predictions":["def findLength ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE maxlen = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n , 2 ) : NEW_LINE INDENT length = j - i + 1 NEW_LINE leftsum = 0 NEW_LINE rightsum = 0 NEW_LINE for k in range ( 0 , int ( length \/ 2 ) ) : NEW_LINE INDENT leftsum += ( ord ( str [ i + k ] ) - ord ( '0' ) ) NEW_LINE rightsum += ( ord ( str [ i + k ] ) - ord ( '0' ) ) NEW_LINE DEDENT if ( leftsum == right ) : NEW_LINE INDENT maxlen = length NEW_LINE DEDENT DEDENT DEDENT return maxlen NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \"153802323\" NEW_LINE print ( \" Length ▁ of ▁ the ▁ substring ▁ is \" , findLength ( str ) ) NEW_LINE DEDENT"],"references":["def findLength ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE maxlen = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n , 2 ) : NEW_LINE INDENT length = j - i + 1 NEW_LINE leftsum = 0 NEW_LINE rightsum = 0 NEW_LINE for k in range ( 0 , int ( length \/ 2 ) ) : NEW_LINE INDENT leftsum += ( int ( str [ i + k ] ) - int ( '0' ) ) NEW_LINE rightsum += ( int ( str [ i + k + int ( length \/ 2 ) ] ) - int ( '0' ) ) NEW_LINE DEDENT if ( leftsum == rightsum and maxlen < length ) : NEW_LINE INDENT maxlen = length NEW_LINE DEDENT DEDENT DEDENT return maxlen NEW_LINE DEDENT str = \"1538023\" NEW_LINE print ( \" Length ▁ of ▁ the ▁ substring ▁ is \" , findLength ( str ) ) NEW_LINE"],"bleu":0.8182769811633828,"rouge_l":0.8959678173823555}
{"id":1401,"predictions":["MOD = 2019 NEW_LINE def min_modulo ( l , r ) : NEW_LINE INDENT if ( r - l >= MOD ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT ans = MOD - 1 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , r + 1 ) : NEW_LINE INDENT ans = min ( ans , ( i * j ) % MOD ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT l = 2020 NEW_LINE r = 2040 NEW_LINE print ( min_modulo ( l , r ) ) NEW_LINE"],"references":["MOD = 2019 ; NEW_LINE def min_modulo ( l , r ) : NEW_LINE INDENT if ( r - l >= MOD ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT ans = MOD - 1 ; NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , r + 1 ) : NEW_LINE INDENT ans = min ( ans , ( i * j ) % MOD ) ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT l = 2020 ; r = 2040 ; NEW_LINE print ( min_modulo ( l , r ) ) ; NEW_LINE DEDENT"],"bleu":0.7133437743677167,"rouge_l":0.8814314652261985}
{"id":1402,"predictions":["def countPairsWithProdK ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] * arr [ j ] == k ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 1 , 5 , 3 , 4 , 2 ] NEW_LINE N = len ( arr ) NEW_LINE K = 3 NEW_LINE print ( countPairsWithProdK ( arr , N , K ) ) NEW_LINE"],"references":["def countPairsWithProdK ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] * arr [ j ] == k ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 1 , 5 , 3 , 4 , 2 ] NEW_LINE N = len ( arr ) NEW_LINE K = 3 NEW_LINE print ( countPairsWithProdK ( arr , N , K ) ) NEW_LINE"],"bleu":1.0,"rouge_l":1.0}
{"id":1403,"predictions":["def Xor_Sum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE index = - 1 NEW_LINE right_xor = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT left_xor = left_xor ^ arr [ i ] NEW_LINE right_xor = 0 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT right_xor = right_xor ^ arr [ j ] NEW_LINE DEDENT if ( left_xor + right_xor > sum ) : NEW_LINE INDENT sum = left_xor + right_xor NEW_LINE index = i NEW_LINE DEDENT DEDENT return index + 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 4 , 6 , 3 , 8 , 13 , 34 , 2 , 21 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( Xor_Sum ( arr , n ) ) NEW_LINE DEDENT"],"references":["def Xor_Sum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE index , left_xor = 0 , 0 NEW_LINE right_xor = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT left_xor = left_xor ^ arr [ i ] NEW_LINE right_xor = 0 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT right_xor = right_xor ^ arr [ j ] NEW_LINE DEDENT if ( left_xor + right_xor > sum ) : NEW_LINE INDENT sum = left_xor + right_xor NEW_LINE index = i NEW_LINE DEDENT DEDENT return index + 1 NEW_LINE DEDENT arr = [ 1 , 4 , 6 , 3 , 8 , 13 , 34 , 2 , 21 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( Xor_Sum ( arr , n ) ) NEW_LINE"],"bleu":0.8710261490023231,"rouge_l":0.9355412313847522}
{"id":1404,"predictions":["def prints ( a , n , ind ) : NEW_LINE INDENT for i in range ( ind , n + ind ) : NEW_LINE INDENT print ( a [ ( i % n ) ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT a = [ ' A ' , ' B ' , ' C ' , ' D ' , ' E ' , ' F ' ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( a , n , 3 ) ; NEW_LINE"],"references":["def prints ( a , n , ind ) : NEW_LINE INDENT i = ind NEW_LINE while i < n + ind : NEW_LINE INDENT print ( a [ ( i % n ) ] , end = \" ▁ \" ) NEW_LINE i = i + 1 NEW_LINE DEDENT DEDENT a = [ ' A ' , ' B ' , ' C ' , ' D ' , ' E ' , ' F ' ] NEW_LINE n = len ( a ) ; NEW_LINE prints ( a , n , 3 ) ; NEW_LINE"],"bleu":0.7784421627664714,"rouge_l":0.8875385142074632}
{"id":1405,"predictions":["def printPattern ( i , j , n ) : NEW_LINE INDENT if j >= n : NEW_LINE INDENT return 0 NEW_LINE DEDENT if i >= n : NEW_LINE INDENT return 1 NEW_LINE DEDENT if j == i or j == n - 1 - i : NEW_LINE INDENT if i == n - 1 - j : NEW_LINE INDENT print ( \" \/ \" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" * \" , end = \" \" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( \" * \" , end = \" \" ) NEW_LINE DEDENT if ( printPattern ( i + 1 , 0 , n ) == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT print ( \" \" ) NEW_LINE return printPattern ( i + 1 , 0 , n ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 9 NEW_LINE printPattern ( 0 , 0 , N ) NEW_LINE DEDENT"],"references":["def printPattern ( i , j , n ) : NEW_LINE INDENT if ( j >= n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( i >= n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( j == i or j == n - 1 - i ) : NEW_LINE INDENT if ( i == n - 1 - j ) : NEW_LINE INDENT print ( \" \/ \" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" \\\\ \" , end = \" \" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( \" * \" , end = \" \" ) NEW_LINE DEDENT if ( printPattern ( i , j + 1 , n ) == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT print ( ) NEW_LINE return printPattern ( i + 1 , 0 , n ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 9 NEW_LINE printPattern ( 0 , 0 , N ) NEW_LINE DEDENT"],"bleu":0.8149224615178715,"rouge_l":0.9412892622352083}
{"id":1406,"predictions":["def findMaxValue ( arr , n ) : NEW_LINE INDENT if ( n < 4 ) : NEW_LINE INDENT print ( \" The ▁ array ▁ should ▁ have ▁ each ▁ 4 ▁ elements \" ) NEW_LINE DEDENT b = [ [ 0 ] * ( n + 1 ) for i in range ( n - 2 ) ] NEW_LINE b [ 0 ] = [ 0 ] * ( n - 2 ) NEW_LINE b [ 0 ] = [ 0 ] * ( n - 2 ) NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT b [ i ] = b [ i - 1 ] NEW_LINE b [ i ] = b [ i - 1 ] NEW_LINE DEDENT for i in range ( n - 3 , - 1 , - 1 ) : NEW_LINE INDENT b [ i ] = mat [ i ] [ 1 ] = mat [ a [ i - 1 ] ] NEW_LINE b [ i ] = b [ i ] NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT b [ i ] = mat [ i + 1 ] NEW_LINE b [ i ] = mat [ i ] [ 1 ] - mat [ i + 1 ] [ 0 ] NEW_LINE DEDENT for i in range ( n - 3 , - 1 , - 1 ) : NEW_LINE INDENT ans = ( mat [ i - 1 ] , mat [ i - 2 ] [ 0 ] - mat [ i ] [ 1 ] ) NEW_LINE DEDENT for i in range ( n - 3 , - 1 , - 1 ) : NEW_LINE INDENT ans = mat [ ans ] NEW_LINE DEDENT print ( ans ) NEW_LINE"],"references":["def findMaxValue ( arr , n ) : NEW_LINE INDENT if n < 4 : NEW_LINE INDENT print ( \" The ▁ array ▁ should ▁ have ▁ atlest ▁ 4 ▁ elements \" ) NEW_LINE return MIN NEW_LINE DEDENT table1 , table2 = [ MIN ] * ( n + 1 ) , [ MIN ] * n NEW_LINE table3 , table4 = [ MIN ] * ( n - 1 ) , [ MIN ] * ( n - 2 ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT table1 [ i ] = max ( table1 [ i + 1 ] , arr [ i ] ) NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT table2 [ i ] = max ( table2 [ i + 1 ] , table1 [ i + 1 ] - arr [ i ] ) NEW_LINE DEDENT for i in range ( n - 3 , - 1 , - 1 ) : NEW_LINE INDENT table3 [ i ] = max ( table3 [ i + 1 ] , table2 [ i + 1 ] + arr [ i ] ) NEW_LINE DEDENT for i in range ( n - 4 , - 1 , - 1 ) : NEW_LINE INDENT table4 [ i ] = max ( table4 [ i + 1 ] , table3 [ i + 1 ] - arr [ i ] ) NEW_LINE DEDENT return table4 [ 0 ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 4 , 8 , 9 , 2 , 20 ] NEW_LINE n = len ( arr ) NEW_LINE MIN = - 100000000 NEW_LINE print ( findMaxValue ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.5039835407756129,"rouge_l":0.6555429864253394}
{"id":1407,"predictions":["def printElements ( a , n ) : NEW_LINE INDENT a . sort ( reverse = True ) NEW_LINE cnt = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( a [ i ] != a [ i + 1 ] ) : NEW_LINE INDENT print ( a [ i ] , \" ▁ occurred \" , cnt , \" times \" ) NEW_LINE cnt = 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT print ( a [ n - 1 ] , \" terms ▁ = \" , cnt , \" times \" ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 1 , 1 , 2 , 3 , 4 , 9 , 10 ] NEW_LINE n = len ( a ) NEW_LINE reverseElements ( a , n ) NEW_LINE DEDENT"],"references":["def printElements ( a , n ) : NEW_LINE INDENT a . sort ( reverse = True ) NEW_LINE cnt = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( a [ i ] != a [ i + 1 ] ) : NEW_LINE INDENT print ( a [ i ] , \" ▁ occurs ▁ \" , cnt , \" times \" ) NEW_LINE cnt = 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT print ( a [ n - 1 ] , \" occurs \" , cnt , \" times \" ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 1 , 1 , 2 , 3 , 4 , 9 , 9 , 10 ] NEW_LINE n = len ( a ) NEW_LINE printElements ( a , n ) NEW_LINE DEDENT"],"bleu":0.9344456790829851,"rouge_l":0.964527202746281}
{"id":1408,"predictions":["def findMin ( arr , n ) : NEW_LINE INDENT m = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT m = max ( m , arr [ i ] ) NEW_LINE DEDENT freq = [ 0 for i in range ( m + 2 ) ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( 1 , m + 2 ) : NEW_LINE INDENT j = i NEW_LINE cnt = 0 NEW_LINE while ( j <= m ) : NEW_LINE INDENT cnt += freq [ j ] NEW_LINE j += i NEW_LINE DEDENT if ( cnt == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return m + 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 12 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMin ( arr , n ) ) NEW_LINE DEDENT"],"references":["def findMin ( arr , n ) : NEW_LINE INDENT m = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT m = max ( m , arr [ i ] ) NEW_LINE DEDENT freq = [ 0 ] * ( m + 2 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( 1 , m + 2 ) : NEW_LINE INDENT j = i NEW_LINE cnt = 0 NEW_LINE while ( j <= m ) : NEW_LINE INDENT cnt += freq [ j ] NEW_LINE j += i NEW_LINE DEDENT if ( not cnt ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return m + 1 NEW_LINE DEDENT arr = [ 2 , 12 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMin ( arr , n ) ) NEW_LINE"],"bleu":0.8075092248276825,"rouge_l":0.9284808273977947}
{"id":1409,"predictions":["def swapOperations ( a , b , c ) : NEW_LINE INDENT l = len ( a ) NEW_LINE i = 0 NEW_LINE total_swaps = 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( a [ i ] == b [ i ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( a [ i ] == c [ i ] ) : NEW_LINE INDENT temp = b [ i ] NEW_LINE b [ i ] = c [ i ] NEW_LINE c [ i ] = temp NEW_LINE total_swaps += 1 NEW_LINE continue NEW_LINE DEDENT if ( b [ i ] == c [ i ] ) : NEW_LINE INDENT temp = a [ i ] NEW_LINE a [ i ] , b [ i ] = c [ i ] , c [ i ] NEW_LINE c [ i ] = temp NEW_LINE total_swaps += 1 NEW_LINE continue NEW_LINE DEDENT DEDENT if ( i == l ) : NEW_LINE INDENT print ( \" total_swaps ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT DEDENT a = \" xyz \" NEW_LINE b = \" yxx \" NEW_LINE c = \" yxx \" NEW_LINE swapOperations ( a , b , c ) NEW_LINE"],"references":["def swapOperations ( a , b , c ) : NEW_LINE INDENT l = len ( a ) ; NEW_LINE i = 0 ; NEW_LINE total_swaps = 0 ; NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( a [ i ] == b [ i ] ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT if ( a [ i ] == c [ i ] ) : NEW_LINE INDENT b [ i ] , c [ i ] = c [ i ] , b [ i ] ; NEW_LINE total_swaps += 1 ; NEW_LINE continue ; NEW_LINE DEDENT if ( b [ i ] == c [ i ] ) : NEW_LINE INDENT a [ i ] , c [ i ] = c [ i ] , a [ i ] ; NEW_LINE total_swaps += 1 ; NEW_LINE continue ; NEW_LINE DEDENT break ; NEW_LINE DEDENT i += 1 ; NEW_LINE if ( i == l ) : NEW_LINE INDENT print ( total_swaps ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = \" xyz \" ; NEW_LINE b = \" yzx \" ; NEW_LINE c = \" yzx \" ; NEW_LINE swapOperations ( list ( a ) , list ( b ) , list ( c ) ) ; NEW_LINE DEDENT"],"bleu":0.6087182660323929,"rouge_l":0.8045772137459005}
{"id":1410,"predictions":["def findMinimumZ ( n , a , b ) : NEW_LINE INDENT if ( a < b ) : NEW_LINE INDENT a , b = b , a NEW_LINE DEDENT distClock = b - a NEW_LINE distClock = ( a - 1 ) + ( n - b + 1 ) NEW_LINE minDist = min ( distClock , distClock ) NEW_LINE if ( minDist == 1 ) : NEW_LINE INDENT return 3 NEW_LINE DEDENT return minDist NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE a = 1 NEW_LINE b = 2 NEW_LINE print ( findMinimumZ ( n , a , b ) ) NEW_LINE DEDENT"],"references":["def findMinimumZ ( n , a , b ) : NEW_LINE INDENT if ( a > b ) : NEW_LINE INDENT temp = a NEW_LINE a = b NEW_LINE b = temp NEW_LINE DEDENT distClock = b - a NEW_LINE distAntiClock = ( a - 1 ) + ( n - b + 1 ) NEW_LINE minDist = min ( distClock , distAntiClock ) NEW_LINE if ( minDist == 1 ) : NEW_LINE INDENT return 3 NEW_LINE DEDENT return minDist NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE a = 1 NEW_LINE b = 2 NEW_LINE print ( findMinimumZ ( n , a , b ) ) NEW_LINE DEDENT"],"bleu":0.8466509760490701,"rouge_l":0.9209141274238228}
{"id":1411,"predictions":["def solve ( ang , n ) : NEW_LINE INDENT if ( ( ang * n ) > ( 180 * ( n - 2 ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( ang * n ) % 180 != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = 1 NEW_LINE freq = ( ang * n ) \/\/ 180 NEW_LINE ans = ans * ( n - 1 - freq ) NEW_LINE ans = ans * n NEW_LINE return ans NEW_LINE DEDENT ang = 90 ; NEW_LINE n = 4 NEW_LINE print ( solve ( ang , n ) ) NEW_LINE"],"references":["def solve ( ang , n ) : NEW_LINE INDENT if ( ( ang * n ) > ( 180 * ( n - 2 ) ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( ( ang * n ) % 180 != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = 1 NEW_LINE freq = ( ang * n ) \/\/ 180 NEW_LINE ans = ans * ( n - 1 - freq ) NEW_LINE ans = ans * n NEW_LINE return ans NEW_LINE DEDENT ang = 90 NEW_LINE n = 4 NEW_LINE print ( solve ( ang , n ) ) NEW_LINE"],"bleu":0.9576687801991799,"rouge_l":0.9852201737010513}
{"id":1412,"predictions":["def bitsAreInAltPatrnInGivenRange ( n , l , r ) : NEW_LINE INDENT num = n >> ( l - 1 ) NEW_LINE prev = num & 1 NEW_LINE num = num >> 1 NEW_LINE for i in range ( 1 , r - l + 1 ) : NEW_LINE INDENT curr = num & 1 NEW_LINE if curr == prev : NEW_LINE INDENT return False NEW_LINE DEDENT prev = curr NEW_LINE num = num >> 1 NEW_LINE DEDENT return True NEW_LINE DEDENT n = 18 NEW_LINE l = 1 NEW_LINE r = 3 NEW_LINE if ( bitsAreInAltPatange ( n , l , r ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def bitsAreInAltPatrnInGivenTRange ( n , l , r ) : NEW_LINE INDENT num = n >> ( l - 1 ) ; NEW_LINE prev = num & 1 ; NEW_LINE num = num >> 1 ; NEW_LINE for i in range ( 1 , ( r - l ) ) : NEW_LINE INDENT curr = num & 1 ; NEW_LINE if ( curr == prev ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT prev = curr ; NEW_LINE num = num >> 1 ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 18 ; NEW_LINE l = 1 ; NEW_LINE r = 3 ; NEW_LINE if ( bitsAreInAltPatrnInGivenTRange ( n , l , r ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"],"bleu":0.5783437281101313,"rouge_l":0.8544961590600993}
{"id":1413,"predictions":["def countFibs ( low , high ) : NEW_LINE INDENT f1 = 0 NEW_LINE f2 = 1 NEW_LINE f3 = 1 NEW_LINE result = 0 NEW_LINE while ( f1 <= high ) : NEW_LINE INDENT if ( f1 >= low ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT f1 = f2 NEW_LINE f2 = f3 NEW_LINE f3 = f1 + f2 NEW_LINE DEDENT return result NEW_LINE DEDENT low = 10 NEW_LINE high = 100 NEW_LINE print ( \" Count ▁ of ▁ Fibonacci ▁ is \" , countFibs ( low , high ) ) NEW_LINE"],"references":["def countFibs ( low , high ) : NEW_LINE INDENT f1 , f2 , f3 = 0 , 1 , 1 NEW_LINE result = 0 NEW_LINE while ( f1 <= high ) : NEW_LINE INDENT if ( f1 >= low ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT f1 = f2 NEW_LINE f2 = f3 NEW_LINE f3 = f1 + f2 NEW_LINE DEDENT return result NEW_LINE DEDENT low , high = 10 , 100 NEW_LINE print ( \" Count ▁ of ▁ Fibonacci ▁ Numbers ▁ is \" , countFibs ( low , high ) ) NEW_LINE"],"bleu":0.8247936021759646,"rouge_l":0.8952429149797572}
{"id":1414,"predictions":["def Sum_upto_nth_nth_nth_term ( n ) : NEW_LINE INDENT r = n * ( n + 1 ) * ( 2 * n + 7 ) \/\/ 3 NEW_LINE print ( r ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 NEW_LINE Sum_upto_nth_nth_term ( N ) NEW_LINE DEDENT"],"references":["def Sum_upto_nth_Term ( n ) : NEW_LINE INDENT return n * ( n + 1 ) * ( 2 * n + 7 ) \/\/ 3 NEW_LINE DEDENT N = 5 NEW_LINE print ( Sum_upto_nth_Term ( N ) ) NEW_LINE"],"bleu":0.4943249184488251,"rouge_l":0.7239092495636998}
{"id":1415,"predictions":["import math NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def printList ( node ) : NEW_LINE INDENT while ( node != None ) : NEW_LINE INDENT print ( node . data , end = \" ▁ \" ) NEW_LINE node = int ( node . next ) NEW_LINE DEDENT DEDENT def push ( head , p , m ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT return NEW_LINE DEDENT p = head NEW_LINE head = head . next NEW_LINE m = head . next NEW_LINE if ( length == m ) : NEW_LINE INDENT p . next = None NEW_LINE last . next = first NEW_LINE first . next = head NEW_LINE first = head NEW_LINE DEDENT else : NEW_LINE INDENT giveToFront ( head , p , m ) NEW_LINE DEDENT DEDENT def push ( head_ref , new_data ) : NEW_LINE INDENT new_node = Node ( new_data ) NEW_LINE new_node . data = new_data NEW_LINE new_node . next = head_ref NEW_LINE head_ref = new_node NEW_LINE if ( lth == m ) : NEW_LINE INDENT head = head_ref NEW_LINE DEDENT else : NEW_LINE INDENT first = head_ref NEW_LINE DEDENT length += 1 NEW_LINE return head_ref NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT start = None NEW_LINE start = push ( head , 5 ) NEW_LINE start = push ( head , 4 ) NEW_LINE start = push ( start , 3 ) NEW_LINE start = push ( start , 2 ) NEW_LINE start = push ( start , 2 ) NEW_LINE start = push ( start , 1 ) NEW_LINE print ( start ) NEW_LINE print ( start ) NEW_LINE DEDENT"],"references":["class Node : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . data = 0 NEW_LINE self . next = None NEW_LINE DEDENT DEDENT first = None NEW_LINE last = None NEW_LINE length = 0 NEW_LINE def printList ( node ) : NEW_LINE INDENT while ( node != None ) : NEW_LINE INDENT print ( node . data , end = \" ▁ \" ) NEW_LINE node = node . next NEW_LINE DEDENT DEDENT def moveToFront ( head , p , m ) : NEW_LINE INDENT global first NEW_LINE global last NEW_LINE global length NEW_LINE if ( head == None ) : NEW_LINE INDENT return head NEW_LINE DEDENT p = head NEW_LINE head = head . next NEW_LINE m = m + 1 NEW_LINE if ( length == m ) : NEW_LINE INDENT p . next = None NEW_LINE last . next = first NEW_LINE first = head NEW_LINE DEDENT else : NEW_LINE INDENT moveToFront ( head , p , m ) NEW_LINE DEDENT DEDENT def push ( head_ref , new_data ) : NEW_LINE INDENT global first NEW_LINE global last NEW_LINE global length NEW_LINE new_node = Node ( ) NEW_LINE new_node . data = new_data NEW_LINE new_node . next = ( head_ref ) NEW_LINE ( head_ref ) = new_node NEW_LINE if ( length == 0 ) : NEW_LINE INDENT last = head_ref NEW_LINE DEDENT else : NEW_LINE INDENT first = head_ref NEW_LINE DEDENT length = length + 1 NEW_LINE return head_ref NEW_LINE DEDENT start = None NEW_LINE start = push ( start , 5 ) NEW_LINE start = push ( start , 4 ) NEW_LINE start = push ( start , 3 ) NEW_LINE start = push ( start , 2 ) NEW_LINE start = push ( start , 1 ) NEW_LINE start = push ( start , 0 ) NEW_LINE print ( \" \\n ▁ Initial ▁ Linked ▁ list \" ) NEW_LINE printList ( start ) NEW_LINE m = 4 NEW_LINE temp = None NEW_LINE moveToFront ( start , temp , m ) NEW_LINE print ( \" \\n ▁ Final ▁ Linked ▁ list \" ) NEW_LINE start = first NEW_LINE printList ( start ) NEW_LINE"],"bleu":0.6287606052391134,"rouge_l":0.7770512447931803}
{"id":1416,"predictions":["def printRepeating ( arr , size ) : NEW_LINE INDENT s = set ( ) NEW_LINE printRepeating ( arr ) NEW_LINE print ( s ) NEW_LINE DEDENT arr = [ 1 , 3 , 2 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE printRepeating ( arr , n ) NEW_LINE"],"references":["def printRepeating ( arr , size ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT if arr [ i ] not in s : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT for i in s : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 3 , 2 , 2 , 1 ] NEW_LINE size = len ( arr ) NEW_LINE printRepeating ( arr , size ) NEW_LINE DEDENT"],"bleu":0.24520451509173016,"rouge_l":0.561736515692539}
{"id":1417,"predictions":["def maxsum_SISIS ( arr , n ) : NEW_LINE INDENT max_sum = 0 NEW_LINE current_sum = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i - 1 ] < arr [ i ] ) : NEW_LINE INDENT current_sum = current_sum + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT max_sum = max ( max_sum , current_sum ) NEW_LINE current_sum = arr [ i ] NEW_LINE DEDENT DEDENT return max ( max_sum , current_sum ) NEW_LINE DEDENT arr = [ 1 , 2 , 2 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Maximum ▁ sum ▁ : \" , max_sum_SIS ( arr , n ) ) NEW_LINE"],"references":["def maxsum_SIS ( arr , n ) : NEW_LINE INDENT max_sum = 0 NEW_LINE current_sum = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i - 1 ] < arr [ i ] ) : NEW_LINE INDENT current_sum = current_sum + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT max_sum = max ( max_sum , current_sum ) NEW_LINE current_sum = arr [ i ] NEW_LINE DEDENT DEDENT return max ( max_sum , current_sum ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT arr = [ 1 , 2 , 2 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Maximum ▁ sum ▁ : ▁ \" , maxsum_SIS ( arr , n ) ) , NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"bleu":0.7556456067688517,"rouge_l":0.8718239564428312}
{"id":1418,"predictions":["def sumoflength ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE j = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT while ( j < n and arr [ arr [ i ] ] not in s . keys ( ) ) : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE j += 1 NEW_LINE DEDENT ans += ( ( j - i ) * ( j - i + 1 ) ) \/\/ 2 NEW_LINE s . remove ( arr [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( sumoflength ( arr , n ) ) NEW_LINE"],"references":["def sumoflength ( arr , n ) : NEW_LINE INDENT s = [ ] NEW_LINE j = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( j < n and ( arr [ j ] not in s ) ) : NEW_LINE INDENT s . append ( arr [ j ] ) NEW_LINE j += 1 NEW_LINE DEDENT ans += ( ( j - i ) * ( j - i + 1 ) ) \/\/ 2 NEW_LINE s . remove ( arr [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( sumoflength ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.7813897052180463,"rouge_l":0.8769407705577917}
{"id":1419,"predictions":["def printMatrix ( v , i ) : NEW_LINE INDENT for j in range ( i , len ( v ) ) : NEW_LINE INDENT print ( v [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( \" \" ) NEW_LINE DEDENT def printKPathUtil ( root , k ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return NEW_LINE DEDENT pair . append ( root . data ) NEW_LINE printKPathUtil ( root . left , k ) NEW_LINE printKPathUtil ( root . right , k ) NEW_LINE printKPathUtil ( root . right , k ) NEW_LINE printFPathUtil ( root . right , k ) NEW_LINE f = 0 NEW_LINE for j in range ( len ( pair ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT f += pair [ j ] NEW_LINE if ( f == k ) : NEW_LINE INDENT printFactor ( path , j ) NEW_LINE DEDENT DEDENT def printKPath ( root , k ) : NEW_LINE INDENT path = [ ] NEW_LINE printKPathUtil ( root , k ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = [ ] NEW_LINE root . left = Node ( 3 ) NEW_LINE root . left . left = [ 2 ] NEW_LINE root . right = Node ( 1 ) NEW_LINE root . left . left = Node ( 2 ) NEW_LINE root . left . right = 3 NEW_LINE root . left . right = Node ( 1 ) NEW_LINE root . right . left = Node ( 2 ) NEW_LINE root . right . left = Node ( 3 ) NEW_LINE root . right . right = Node ( 4 ) NEW_LINE root . right . left = Node ( 3 ) NEW_LINE root . right . right = Node ( 4 ) NEW_LINE root . right . right . left = Node ( 4 ) NEW_LINE root . right . right . left = Node ( 3 ) NEW_LINE root . right . right = Node ( 4 ) NEW_LINE root . right . right . right = Node ( 4 ) NEW_LINE root . right . right = Node"],"references":["def printVector ( v , i ) : NEW_LINE INDENT for j in range ( i , len ( v ) ) : NEW_LINE INDENT print ( v [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT class newNode : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . data = key NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def printKPathUtil ( root , path , k ) : NEW_LINE INDENT if ( not root ) : NEW_LINE INDENT return NEW_LINE DEDENT path . append ( root . data ) NEW_LINE printKPathUtil ( root . left , path , k ) NEW_LINE printKPathUtil ( root . right , path , k ) NEW_LINE f = 0 NEW_LINE for j in range ( len ( path ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT f += path [ j ] NEW_LINE if ( f == k ) : NEW_LINE INDENT printVector ( path , j ) NEW_LINE DEDENT DEDENT path . pop ( - 1 ) NEW_LINE DEDENT def printKPath ( root , k ) : NEW_LINE INDENT path = [ ] NEW_LINE printKPathUtil ( root , path , k ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 1 ) NEW_LINE root . left = newNode ( 3 ) NEW_LINE root . left . left = newNode ( 2 ) NEW_LINE root . left . right = newNode ( 1 ) NEW_LINE root . left . right . left = newNode ( 1 ) NEW_LINE root . right = newNode ( - 1 ) NEW_LINE root . right . left = newNode ( 4 ) NEW_LINE root . right . left . left = newNode ( 1 ) NEW_LINE root . right . left . right = newNode ( 2 ) NEW_LINE root . right . right = newNode ( 5 ) NEW_LINE root . right . right . right = newNode ( 2 ) NEW_LINE k = 5 NEW_LINE printKPath ( root , k ) NEW_LINE DEDENT"],"bleu":0.6697270732283468,"rouge_l":0.745058849655785}
{"id":1420,"predictions":["def reverseArray ( arr , n ) : NEW_LINE INDENT for i in range ( n \/\/ 2 ) : NEW_LINE INDENT arr [ i ] , arr [ i ] = arr [ n + ~ i + 1 ] + ~1 + 1 NEW_LINE DEDENT DEDENT arr = [ 5 , 3 , 7 , 2 , 1 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE reverseArray ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT"],"references":["def reverseArray ( arr , n ) : NEW_LINE INDENT for i in range ( n \/\/ 2 ) : NEW_LINE INDENT arr [ i ] , arr [ ( n + ~ i + 1 ) + ~ 1 + 1 ] = arr [ ( n + ~ i + 1 ) + ~ 1 + 1 ] , arr [ i ] NEW_LINE DEDENT DEDENT arr = [ 5 , 3 , 7 , 2 , 1 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE reverseArray ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT"],"bleu":0.7660024827776055,"rouge_l":0.8797658146508639}
{"id":1421,"predictions":["class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def getNode ( data ) : NEW_LINE INDENT new_node = Node ( 0 ) NEW_LINE new_node . data = data NEW_LINE new_node . next = None NEW_LINE return new_node NEW_LINE DEDENT def push ( head_ref , new_node ) : NEW_LINE INDENT new_node . prev = None NEW_LINE new_node . next = head_ref NEW_LINE if head_ref != None : NEW_LINE INDENT head_ref = new_node NEW_LINE DEDENT head_ref = new_node NEW_LINE return head_ref NEW_LINE DEDENT def reverseList ( head_ref ) : NEW_LINE INDENT if head_ref != None or ( head_ref ) . prev is None : NEW_LINE INDENT return None NEW_LINE DEDENT new_head = None NEW_LINE curr = head_ref NEW_LINE while curr != None : NEW_LINE INDENT next = curr . next NEW_LINE new_head = push ( new_head , curr ) NEW_LINE curr = next NEW_LINE DEDENT head_ref = new_head NEW_LINE return head_ref NEW_LINE DEDENT def printList ( head ) : NEW_LINE INDENT while head != None : NEW_LINE INDENT print ( head . data , end = \" ▁ \" ) NEW_LINE head = push ( new_head , curr ) NEW_LINE curr = next NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = None NEW_LINE head = push ( 2 ) NEW_LINE head = push ( 3 ) NEW_LINE head = push ( head , 4 ) NEW_LINE head = push ( head , 5 ) NEW_LINE head = push ( head , 4 ) NEW_LINE head = push ( head , 3 ) NEW_LINE head = push ( head , 7 ) NEW_LINE print ( \" Original ▁ list : \" , end = \" ▁ \" ) NEW_LINE print ( ) NEW_LINE print ( \""],"references":["import math NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def getNode ( data ) : NEW_LINE INDENT new_node = Node ( data ) NEW_LINE new_node . data = data NEW_LINE new_node . next = None NEW_LINE new_node . prev = None NEW_LINE return new_node NEW_LINE DEDENT def push ( head_ref , new_node ) : NEW_LINE INDENT new_node . prev = None NEW_LINE new_node . next = head_ref NEW_LINE if ( head_ref != None ) : NEW_LINE INDENT head_ref . prev = new_node NEW_LINE DEDENT head_ref = new_node NEW_LINE return head_ref NEW_LINE DEDENT def reverseList ( head_ref ) : NEW_LINE INDENT if ( head_ref == None or ( head_ref ) . next == None ) : NEW_LINE INDENT return None NEW_LINE DEDENT new_head = None NEW_LINE curr = head_ref NEW_LINE while ( curr != None ) : NEW_LINE INDENT next = curr . next NEW_LINE new_head = push ( new_head , curr ) NEW_LINE curr = next NEW_LINE DEDENT head_ref = new_head NEW_LINE return head_ref NEW_LINE DEDENT def prList ( head ) : NEW_LINE INDENT while ( head != None ) : NEW_LINE INDENT print ( head . data , end = \" ▁ \" ) NEW_LINE head = head . next NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = None NEW_LINE head = push ( head , getNode ( 2 ) ) ; NEW_LINE head = push ( head , getNode ( 4 ) ) ; NEW_LINE head = push ( head , getNode ( 8 ) ) ; NEW_LINE head = push ( head , getNode ( 10 ) ) ; NEW_LINE print ( \" Original ▁ list : ▁ \" , end = \" \" ) NEW_LINE prList ( head ) NEW_LINE head = reverseList ( head ) NEW_LINE print ( \" \\n Reversed ▁ list : ▁ \" , end = \" \" ) NEW_LINE prList ( head ) NEW_LINE DEDENT"],"bleu":0.7013846207397176,"rouge_l":0.8366433978959787}
{"id":1422,"predictions":["def decdiagonal ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT d = 1.902 * a NEW_LINE return round ( d , 3 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 9 NEW_LINE print ( decdiagonal ( a ) ) NEW_LINE DEDENT"],"references":["def decdiagonal ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT d = 1.902 * a NEW_LINE return d NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 9 NEW_LINE print ( decdiagonal ( a ) ) NEW_LINE DEDENT"],"bleu":0.8004468802731476,"rouge_l":0.9325689325689325}
{"id":1423,"predictions":["def findSum ( N , k ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT sum += pow ( i , k ) NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 8 NEW_LINE k = 4 NEW_LINE print ( findSum ( N , k ) ) NEW_LINE DEDENT"],"references":["from math import pow NEW_LINE def findSum ( N , k ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , N + 1 , 1 ) : NEW_LINE INDENT sum += pow ( i , k ) NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 8 NEW_LINE k = 4 NEW_LINE print ( int ( findSum ( N , k ) ) ) NEW_LINE DEDENT"],"bleu":0.8520812429973599,"rouge_l":0.9261386951169471}
{"id":1424,"predictions":["def reverse ( k ) : NEW_LINE INDENT s = [ ] NEW_LINE T = k . split ( ) NEW_LINE for i in range ( len ( S ) ) : NEW_LINE INDENT s . append ( T [ i ] ) NEW_LINE DEDENT while len ( s ) > 0 : NEW_LINE INDENT print ( s [ - 1 ] , end = \" ▁ \" ) NEW_LINE s . pop ( ) NEW_LINE DEDENT DEDENT k = \" geeks ▁ for ▁ geeks \" NEW_LINE revers ( k ) NEW_LINE"],"references":["def reverse ( k ) : NEW_LINE INDENT s = [ ] NEW_LINE token = k . split ( ) NEW_LINE for word in token : NEW_LINE INDENT s . append ( word ) ; NEW_LINE DEDENT while ( len ( s ) ) : NEW_LINE INDENT print ( s . pop ( ) , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT k = \" geeks ▁ for ▁ geeks \" ; NEW_LINE reverse ( k ) ; NEW_LINE DEDENT"],"bleu":0.5684164919172435,"rouge_l":0.7069711122643141}
{"id":1425,"predictions":["def subArray ( arr , n , m ) : NEW_LINE INDENT i = 0 NEW_LINE mp = 0 NEW_LINE p = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] = i + 1 NEW_LINE DEDENT sumcur = 0 NEW_LINE ans = [ ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT sumcur += mp [ i ] NEW_LINE p = min ( p , mp [ i ] ) NEW_LINE val = p * i - i + ( i * ( i + 1 ) ) \/\/ 2 NEW_LINE if ( i == m ) : NEW_LINE INDENT if ( val == sumcur ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 5 , 1 , 3 , 2 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE m = 3 NEW_LINE if ( subArray ( arr , n , m ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def subArray ( arr , n , m ) : NEW_LINE INDENT i = 0 NEW_LINE mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] = i + 1 NEW_LINE DEDENT sumcur = 0 NEW_LINE p = 10 ** 9 NEW_LINE ans = [ ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT sumcur += mp [ i ] NEW_LINE p = min ( p , mp [ i ] ) NEW_LINE val = p * i - i + ( i * ( i + 1 ) ) \/ 2 NEW_LINE if ( i == m ) : NEW_LINE INDENT if ( val == sumcur ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT DEDENT arr = [ 4 , 5 , 1 , 3 , 2 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE m = 3 NEW_LINE if ( subArray ( arr , n , m ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.8714140603545407,"rouge_l":0.921322339523773}
{"id":1426,"predictions":["class Graph : NEW_LINE INDENT def __init__ ( self , V ) : NEW_LINE INDENT self . V = V NEW_LINE self . adj = [ [ ] for _ in range ( V ) ] NEW_LINE DEDENT def addEdge ( self , v , w ) : NEW_LINE INDENT self . adj [ v ] . append ( w ) NEW_LINE DEDENT def DFS ( s ) : NEW_LINE INDENT visited = [ False for i in range ( V ) ] NEW_LINE stack = [ ] NEW_LINE while ( len ( stack ) != 0 ) : NEW_LINE INDENT s = stack . pop ( ) NEW_LINE if ( visited [ s ] == False ) : NEW_LINE INDENT print ( s , end = \" ▁ \" ) NEW_LINE visited [ s ] = True NEW_LINE DEDENT for i in range ( len ( stack ) ) : NEW_LINE INDENT if ( not visited [ s ] ) : NEW_LINE INDENT print ( s , end = \" ▁ \" ) NEW_LINE visited [ s ] = True NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT g = Graph ( 5 ) NEW_LINE g . addEdge ( 1 , 0 ) NEW_LINE g . addEdge ( 0 , 2 ) NEW_LINE g . addEdge ( 0 , 2 ) NEW_LINE g . addEdge ( 0 , 3 ) NEW_LINE g . addEdge ( 1 , 4 ) NEW_LINE print \" Following ▁ is ▁ the ▁ Depth ▁ First ▁ Traversal \" ) NEW_LINE g . DFS ( 0 ) NEW_LINE DFS ( 0 ) NEW_LINE"],"references":["class Graph : NEW_LINE INDENT def __init__ ( self , V ) : NEW_LINE INDENT self . V = V NEW_LINE self . adj = [ [ ] for i in range ( V ) ] NEW_LINE DEDENT def addEdge ( self , v , w ) : NEW_LINE INDENT self . adj [ v ] . append ( w ) NEW_LINE DEDENT def DFS ( self , s ) : NEW_LINE INDENT visited = [ False for i in range ( self . V ) ] NEW_LINE stack = [ ] NEW_LINE stack . append ( s ) NEW_LINE while ( len ( stack ) ) : NEW_LINE INDENT s = stack [ - 1 ] NEW_LINE stack . pop ( ) NEW_LINE if ( not visited [ s ] ) : NEW_LINE INDENT print ( s , end = ' ▁ ' ) NEW_LINE visited [ s ] = True NEW_LINE DEDENT for node in self . adj [ s ] : NEW_LINE INDENT if ( not visited [ node ] ) : NEW_LINE INDENT stack . append ( node ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT g = Graph ( 5 ) ; NEW_LINE g . addEdge ( 1 , 0 ) ; NEW_LINE g . addEdge ( 0 , 2 ) ; NEW_LINE g . addEdge ( 2 , 1 ) ; NEW_LINE g . addEdge ( 0 , 3 ) ; NEW_LINE g . addEdge ( 1 , 4 ) ; NEW_LINE print ( \" Following ▁ is ▁ Depth ▁ First ▁ Traversal \" ) NEW_LINE g . DFS ( 0 ) NEW_LINE"],"bleu":0.7175336532305192,"rouge_l":0.8275406687076056}
{"id":1427,"predictions":["class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data ; NEW_LINE self . left = None ; NEW_LINE self . right = None ; NEW_LINE DEDENT DEDENT def diagonalPrint ( root ) : NEW_LINE INDENT if ( not root ) : NEW_LINE INDENT return ; NEW_LINE DEDENT q = [ ] ; NEW_LINE q . append ( root ) ; NEW_LINE q . append ( None ) ; NEW_LINE while ( len ( q ) != 0 ) : NEW_LINE INDENT temp = q [ 0 ] ; NEW_LINE q . pop ( 0 ) ; NEW_LINE if ( temp == None ) : NEW_LINE INDENT if len ( q ) == 0 : NEW_LINE INDENT return ; NEW_LINE DEDENT print ( \" \" ) ; NEW_LINE q . append ( None ) ; NEW_LINE DEDENT else : NEW_LINE INDENT while ( temp != None ) : NEW_LINE INDENT print ( temp . data , end = \" ▁ \" ) ; NEW_LINE if ( temp . left != None ) : NEW_LINE INDENT q . append ( temp . left ) ; NEW_LINE DEDENT temp = temp . right ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT root = newNode ( 8 ) ; NEW_LINE root . left = newNode ( 3 ) ; NEW_LINE root . left . left = newNode ( 12 ) ; NEW_LINE root . left . right = newNode ( 6 ) ; NEW_LINE root . left . right = newNode ( 14 ) ; NEW_LINE root . left . right = newNode ( 13 ) ; NEW_LINE root . left . right = newNode ( 14 ) ; NEW_LINE root . left . right . right = newNode ( 7 ) ; NEW_LINE root . left . right = newNode ( 7 ) ; NEW_LINE diagonalPrint ( root ) ; NEW_LINE DEDENT"],"references":["class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . val = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def diagonalprint ( root ) : NEW_LINE INDENT if root is None : NEW_LINE INDENT return NEW_LINE DEDENT q = [ ] NEW_LINE q . append ( root ) NEW_LINE q . append ( None ) NEW_LINE while len ( q ) > 0 : NEW_LINE INDENT temp = q . pop ( 0 ) NEW_LINE if not temp : NEW_LINE INDENT if len ( q ) == 0 : NEW_LINE INDENT return NEW_LINE DEDENT print ( ' ▁ ' ) NEW_LINE q . append ( None ) NEW_LINE DEDENT else : NEW_LINE INDENT while temp : NEW_LINE INDENT print ( temp . val , end = ' ▁ ' ) NEW_LINE if temp . left : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE DEDENT temp = temp . right NEW_LINE DEDENT DEDENT DEDENT DEDENT root = Node ( 8 ) NEW_LINE root . left = Node ( 3 ) NEW_LINE root . right = Node ( 10 ) NEW_LINE root . left . left = Node ( 1 ) NEW_LINE root . left . right = Node ( 6 ) NEW_LINE root . right . right = Node ( 14 ) NEW_LINE root . right . right . left = Node ( 13 ) NEW_LINE root . left . right . left = Node ( 4 ) NEW_LINE root . left . right . right = Node ( 7 ) NEW_LINE diagonalprint ( root ) NEW_LINE"],"bleu":0.48117558799248733,"rouge_l":0.7949521610029692}
{"id":1428,"predictions":["from math import gcd as __gcd NEW_LINE def getWinner ( arr , n ) : NEW_LINE INDENT __gcd = arr [ 0 ] ; NEW_LINE maxEle = arr [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT __gcd = __gcd ( __gcd , arr [ i ] ) ; NEW_LINE maxEle = max ( maxEle , arr [ i ] ) ; NEW_LINE DEDENT totalMoves = ( maxEle \/\/ __gcd ) - n ; NEW_LINE if ( totalMoves % 2 == 1 ) : NEW_LINE INDENT return ' A ' ; NEW_LINE DEDENT return ' B ' ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 5 , 6 , 7 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( getWinner ( arr , n ) ) ; NEW_LINE DEDENT"],"references":["from math import gcd NEW_LINE def getWinner ( arr , n ) : NEW_LINE INDENT __gcd = arr [ 0 ] ; NEW_LINE maxEle = arr [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT __gcd = gcd ( __gcd , arr [ i ] ) ; NEW_LINE maxEle = max ( maxEle , arr [ i ] ) ; NEW_LINE DEDENT totalMoves = ( maxEle \/ __gcd ) - n ; NEW_LINE if ( totalMoves % 2 == 1 ) : NEW_LINE INDENT return ' A ' ; NEW_LINE DEDENT return ' B ' ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 5 , 6 , 7 ] ; NEW_LINE n = len ( arr ) NEW_LINE print ( getWinner ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.9115963671316124,"rouge_l":0.9756792287467134}
{"id":1429,"predictions":["def CountingEvenOdd ( arr , arr_size ) : NEW_LINE INDENT even_count = 0 NEW_LINE odd_count = 0 NEW_LINE for i in range ( 0 , arr_size ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT odd_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even_count += 1 NEW_LINE DEDENT DEDENT print ( \" Number ▁ of ▁ even ▁ elements ▁ = ▁ \" , even_count , \" ▁ Number ▁ of ▁ odd ▁ elements ▁ = ▁ \" , odd_count ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE CountingEvenOdd ( arr , n ) NEW_LINE DEDENT"],"references":["def CountingEvenOdd ( arr , arr_size ) : NEW_LINE INDENT even_count = 0 NEW_LINE odd_count = 0 NEW_LINE for i in range ( arr_size ) : NEW_LINE INDENT if ( arr [ i ] & 1 == 1 ) : NEW_LINE INDENT odd_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even_count += 1 NEW_LINE DEDENT DEDENT print ( \" Number ▁ of ▁ even ▁ elements ▁ = ▁ \" , even_count ) NEW_LINE print ( \" Number ▁ of ▁ odd ▁ elements ▁ = ▁ \" , odd_count ) NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE CountingEvenOdd ( arr , n ) NEW_LINE"],"bleu":0.8226615483498768,"rouge_l":0.9139757168690258}
{"id":1430,"predictions":["def findSum ( str ) : NEW_LINE INDENT temp = \" \" NEW_LINE sum = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT ch = str [ i ] NEW_LINE if ( str [ i ] >= \"9\" ) : NEW_LINE INDENT temp += str [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT sum += int ( str [ i ] ) NEW_LINE temp = str [ i ] NEW_LINE DEDENT DEDENT return sum + int ( temp ) NEW_LINE DEDENT str = \"12abc20\" NEW_LINE print ( findSum ( str ) ) NEW_LINE"],"references":["def findSum ( str1 ) : NEW_LINE INDENT temp = \" \" NEW_LINE Sum = 0 NEW_LINE for ch in str1 : NEW_LINE INDENT if ( ch . isdigit ( ) ) : NEW_LINE INDENT temp += ch NEW_LINE DEDENT else : NEW_LINE INDENT Sum += int ( temp ) NEW_LINE temp = \"0\" NEW_LINE DEDENT DEDENT return Sum + int ( temp ) NEW_LINE DEDENT str1 = \"12abc20yz68\" NEW_LINE print ( findSum ( str1 ) ) NEW_LINE"],"bleu":0.3961397594822811,"rouge_l":0.6977311081942621}
{"id":1431,"predictions":["def fibonacci ( n ) : NEW_LINE INDENT f = [ 0 ] * ( n + 2 ) NEW_LINE f [ 0 ] = 0 NEW_LINE f [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT f [ i ] = f [ i - 1 ] + f [ i - 2 ] NEW_LINE DEDENT return f [ n ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 9 NEW_LINE print ( fibonacci ( 9 ) ) NEW_LINE DEDENT"],"references":["def fibonacci ( n ) : NEW_LINE INDENT FibArray = [ 0 , 1 ] NEW_LINE while len ( FibArray ) < n + 1 : NEW_LINE INDENT FibArray . append ( 0 ) NEW_LINE DEDENT if n <= 1 : NEW_LINE INDENT return n NEW_LINE DEDENT else : NEW_LINE INDENT if FibArray [ n - 1 ] == 0 : NEW_LINE INDENT FibArray [ n - 1 ] = fibonacci ( n - 1 ) NEW_LINE DEDENT if FibArray [ n - 2 ] == 0 : NEW_LINE INDENT FibArray [ n - 2 ] = fibonacci ( n - 2 ) NEW_LINE DEDENT DEDENT FibArray [ n ] = FibArray [ n - 2 ] + FibArray [ n - 1 ] NEW_LINE return FibArray [ n ] NEW_LINE DEDENT print ( fibonacci ( 9 ) ) NEW_LINE"],"bleu":0.22052543528056276,"rouge_l":0.4596166556510244}
{"id":1432,"predictions":["def oddNumSum ( n ) : NEW_LINE INDENT j = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT j = ( 2 * i - 1 ) NEW_LINE sum = sum + ( j * j * j * j ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 6 NEW_LINE print ( oddNumSum ( n ) ) NEW_LINE"],"references":["def oddNumSum ( n ) : NEW_LINE INDENT j = 0 NEW_LINE sm = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT j = ( 2 * i - 1 ) NEW_LINE sm = sm + ( j * j * j * j ) NEW_LINE DEDENT return sm NEW_LINE DEDENT n = 6 ; NEW_LINE print ( oddNumSum ( n ) ) NEW_LINE"],"bleu":0.831655344355288,"rouge_l":0.9358827570414471}
{"id":1433,"predictions":["from math import sqrt NEW_LINE def findAandB ( N ) : NEW_LINE INDENT val = N * N - 4.0 NEW_LINE if ( val < 0 ) : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE return ; NEW_LINE DEDENT a = ( N + sqrt ( val ) ) \/ 2.0 NEW_LINE b = ( N - math . sqrt ( val ) ) \/ 2.0 ; NEW_LINE print ( \" a ▁ = \" , a ) ; NEW_LINE print ( \" b ▁ = \" , b ) ; NEW_LINE DEDENT N = 6.0 ; NEW_LINE findAandB ( N ) ; NEW_LINE"],"references":["from math import sqrt NEW_LINE def findAandB ( N ) : NEW_LINE INDENT val = N * N - 4.0 * N NEW_LINE if ( val < 0 ) : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE return NEW_LINE DEDENT a = ( N + sqrt ( val ) ) \/ 2.0 NEW_LINE b = ( N - sqrt ( val ) ) \/ 2.0 NEW_LINE print ( \" a ▁ = \" , ' { 0 : . 6 } ' . format ( a ) ) NEW_LINE print ( \" b ▁ = \" , ' { 0 : . 6 } ' . format ( b ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 69.0 NEW_LINE findAandB ( N ) NEW_LINE DEDENT"],"bleu":0.560829590315634,"rouge_l":0.7741724453748529}
{"id":1434,"predictions":["def reverse ( str ) : NEW_LINE INDENT if l < r : NEW_LINE INDENT l = len ( str ) NEW_LINE l = 0 NEW_LINE r = 0 NEW_LINE while ( l < r ) : NEW_LINE INDENT if str [ l ] . isalpha ( str [ r ] ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT elif ( str [ r ] != str [ r ] ) : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT str [ l ] , str [ r ] = str [ r ] , str [ r ] NEW_LINE l += 1 NEW_LINE r += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" a ! b . c . d \\ NEW_LINE str = list ( str ) NEW_LINE print ( \" Input ▁ string : ▁ \" , str ) NEW_LINE rev ( str ) NEW_LINE DEDENT"],"references":["def reverseSting ( text ) : NEW_LINE INDENT index = - 1 NEW_LINE for i in range ( len ( text ) - 1 , int ( len ( text ) \/ 2 ) , - 1 ) : NEW_LINE INDENT if text [ i ] . isalpha ( ) : NEW_LINE INDENT temp = text [ i ] NEW_LINE while True : NEW_LINE INDENT index += 1 NEW_LINE if text [ index ] . isalpha ( ) : NEW_LINE INDENT text [ i ] = text [ index ] NEW_LINE text [ index ] = temp NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT return text NEW_LINE DEDENT string = \" a ! ! ! b . c . d , e ' f , ghi \" NEW_LINE print ( \" Input ▁ string : ▁ \" , string ) NEW_LINE string = reverseSting ( list ( string ) ) NEW_LINE print ( \" Output ▁ string : ▁ \" , \" \" . join ( string ) ) NEW_LINE"],"bleu":0.2556645316295208,"rouge_l":0.4454722492697176}
{"id":1435,"predictions":["import math NEW_LINE def geometricMean ( n ) : NEW_LINE INDENT return math . sqrt ( n ) NEW_LINE DEDENT n = 16 NEW_LINE print ( geometricMean ( n ) ) NEW_LINE"],"references":["from math import sqrt NEW_LINE def geometricMean ( n ) : NEW_LINE INDENT return int ( sqrt ( n ) ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 16 ; NEW_LINE print ( geometricMean ( n ) ) ; NEW_LINE DEDENT"],"bleu":0.3500674651082214,"rouge_l":0.6620508982035929}
{"id":1436,"predictions":["def kPresentProbability ( a , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == k ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count \/\/ n NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 4 , 7 , 2 , 0 , 8 , 7 , 5 ] NEW_LINE K = 2 NEW_LINE N = kPresentProbability ( A , N , K ) NEW_LINE p = round ( n * 100 ) \/ 100 NEW_LINE print ( round ( p * 100 ) ) NEW_LINE DEDENT"],"references":["def kPresentProbability ( a , n , k ) : NEW_LINE INDENT count = a . count ( k ) NEW_LINE return round ( count \/ n , 2 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 4 , 7 , 2 , 0 , 8 , 7 , 5 ] NEW_LINE K = 2 NEW_LINE N = len ( A ) NEW_LINE print ( kPresentProbability ( A , N , K ) ) NEW_LINE DEDENT"],"bleu":0.5054714286471121,"rouge_l":0.692042091417297}
{"id":1437,"predictions":["def checkEvenOdd ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT print ( \" Even \" ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( \" Odd \" ) NEW_LINE DEDENT arr = [ 2 , 12 , 20 , 36 , 38 ] NEW_LINE n = len ( arr ) NEW_LINE checkEvenOdd ( arr , n ) NEW_LINE"],"references":["def checkEvenOdd ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT print ( \" Even \" , end = \" \" ) ; NEW_LINE return ; NEW_LINE DEDENT DEDENT print ( \" Odd \" , end = \" \" ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 12 , 20 , 36 , 38 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE checkEvenOdd ( arr , n ) ; NEW_LINE DEDENT"],"bleu":0.5983065389120273,"rouge_l":0.820627802690583}
{"id":1438,"predictions":["def toggleLastMBits ( n , m ) : NEW_LINE INDENT if ( m == 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT num = ( 1 << m ) - 1 NEW_LINE return ( n ^ num ) NEW_LINE DEDENT def largeNumWithMunBits ( n , m ) : NEW_LINE INDENT num = ( 1 << ( n + m ) ) - 1 NEW_LINE return toggleLastMBits ( num , m ) NEW_LINE DEDENT n = 2 NEW_LINE m = 2 NEW_LINE print ( largeNumWithNSetAndMunBits ( n , m ) ) NEW_LINE"],"references":["def toggleLastMBits ( n , m ) : NEW_LINE INDENT if ( m == 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT num = ( 1 << m ) - 1 NEW_LINE return ( n ^ num ) NEW_LINE DEDENT def largeNumWithNSetAndMUnsetBits ( n , m ) : NEW_LINE INDENT num = ( 1 << ( n + m ) ) - 1 NEW_LINE return toggleLastMBits ( num , m ) NEW_LINE DEDENT n = 2 NEW_LINE m = 2 NEW_LINE print ( largeNumWithNSetAndMUnsetBits ( n , m ) ) NEW_LINE"],"bleu":0.9447144130502939,"rouge_l":0.9782608695652174}
{"id":1439,"predictions":["def series ( A , X , n ) : NEW_LINE INDENT term = pow ( A , n ) NEW_LINE print ( term , end = \" ▁ \" ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT temp = temp * X * ( n - i + 1 ) \/\/ ( i * A ) NEW_LINE print ( temp , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT A = 3 ; X = 4 ; n = 5 NEW_LINE series ( A , X , n ) NEW_LINE"],"references":["def series ( A , X , n ) : NEW_LINE INDENT term = pow ( A , n ) NEW_LINE print ( term , end = \" ▁ \" ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT term = int ( term * X * ( n - i + 1 ) \/ ( i * A ) ) NEW_LINE print ( term , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT A = 3 ; X = 4 ; n = 5 NEW_LINE series ( A , X , n ) NEW_LINE"],"bleu":0.8712617962529985,"rouge_l":0.9432989690721648}
{"id":1440,"predictions":["def merge ( arr , l , m , r ) : NEW_LINE INDENT n1 = m - l + 1 NEW_LINE n2 = r - m NEW_LINE L = [ 0 ] * n NEW_LINE R = [ 0 ] * n NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT L [ i ] = arr [ l + i ] NEW_LINE DEDENT for j in range ( n2 ) : NEW_LINE INDENT R [ j ] = arr [ m + i ] NEW_LINE DEDENT i = 0 NEW_LINE j = 0 NEW_LINE k = l NEW_LINE while ( i < n1 and j < n2 ) : NEW_LINE INDENT if ( L [ i ] <= R [ j ] ) : NEW_LINE INDENT arr [ k ] = L [ i ] NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ k ] = R [ j ] NEW_LINE j += 1 NEW_LINE DEDENT k += 1 NEW_LINE while ( i < n1 and j < n2 ) : NEW_LINE INDENT arr [ k ] = L [ j ] NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE k += 1 NEW_LINE DEDENT while ( j < n2 ) : NEW_LINE INDENT arr [ k ] = R [ j ] NEW_LINE j += 1 NEW_LINE k += 1 NEW_LINE DEDENT while ( j < n2 ) : NEW_LINE INDENT arr [ k ] = R [ j ] NEW_LINE j += 1 NEW_LINE k += 1 NEW_LINE DEDENT DEDENT def printArray ( arr , n , arr , m ) : NEW_LINE INDENT print ( arr [ 0 ] , end = \" ▁ \" ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT arr = [ 10 , 15 , 12 , 5 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE print ("],"references":["def mergeSort ( a ) : NEW_LINE INDENT if len ( a ) > 1 : NEW_LINE INDENT mid = len ( a ) \/\/ 2 NEW_LINE L = a [ : mid ] NEW_LINE R = a [ mid : ] NEW_LINE mergeSort ( L ) NEW_LINE mergeSort ( R ) NEW_LINE a . clear ( ) NEW_LINE while len ( L ) > 0 and len ( R ) < 0 : NEW_LINE INDENT if L [ 0 ] <= R [ 0 ] : NEW_LINE INDENT a . append ( L [ 0 ] ) NEW_LINE L . pop ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT a . append ( R [ 0 ] ) NEW_LINE R . pop ( 0 ) NEW_LINE DEDENT DEDENT for i in L : NEW_LINE INDENT a . append ( i ) NEW_LINE DEDENT for i in R : NEW_LINE INDENT a . append ( i ) NEW_LINE DEDENT DEDENT DEDENT a = [ 12 , 11 , 13 , 5 , 6 , 7 ] NEW_LINE print ( \" Given ▁ array ▁ is \" ) NEW_LINE print ( * a ) NEW_LINE mergeSort ( a ) NEW_LINE print ( \" Sorted ▁ array ▁ is ▁ : ▁ \" ) NEW_LINE print ( * a ) NEW_LINE"],"bleu":0.14090419455359487,"rouge_l":0.3943506115317414}
{"id":1441,"predictions":["def answer ( arr , ranges , reversals , index ) : NEW_LINE INDENT for i in range ( reversals - 1 , - 1 , - 1 ) : NEW_LINE INDENT left = ranges [ i ] [ 0 ] NEW_LINE right = ranges [ i ] [ 1 ] NEW_LINE if ( left <= index and right >= index ) : NEW_LINE INDENT index = right + left - index NEW_LINE DEDENT DEDENT return arr [ index ] NEW_LINE DEDENT arr = [ 10 , 20 , 30 , 40 , 50 ] NEW_LINE reversals = 2 NEW_LINE ranges = [ [ 1 , 4 ] , [ 0 , 2 ] ] NEW_LINE index = 1 NEW_LINE print ( answer ( arr , ranges , reversals , index ) ) NEW_LINE"],"references":["def answer ( arr , ranges , reversals , index ) : NEW_LINE INDENT i = reversals - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT left = ranges [ i ] [ 0 ] NEW_LINE right = ranges [ i ] [ 1 ] NEW_LINE if ( left <= index and right >= index ) : NEW_LINE INDENT index = right + left - index NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT return arr [ index ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 10 , 20 , 30 , 40 , 50 ] NEW_LINE reversals = 2 NEW_LINE ranges = [ [ 1 , 4 ] , [ 0 , 2 ] ] NEW_LINE index = 1 NEW_LINE print ( answer ( arr , ranges , reversals , index ) ) NEW_LINE DEDENT"],"bleu":0.7840421649465118,"rouge_l":0.8680284599495066}
{"id":1442,"predictions":["def isDivisibleBy25 ( str ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return False NEW_LINE DEDENT return ( ( ( ord ( str [ n - 1 ] ) - ord ( '0' ) == 0 and str [ n - 2 ] ) == 0 ) or ( ( ord ( str [ n - 2 ] ) - ord ( '0' ) ) * 10 + ( ord ( str [ n - 2 ] ) - ord ( '0' ) ) ) % 25 == 0 ) NEW_LINE DEDENT str = \"76955\" NEW_LINE if ( isDivisibleBy25 ( str ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No ▁ \" ) NEW_LINE DEDENT"],"references":["def isDivisibleBy25 ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return ( ( int ) ( st [ n - 1 ] ) == 0 and ( ( int ) ( st [ n - 2 ] ) == 0 ) or ( ( int ) ( st [ n - 2 ] ) * 10 + ( int ) ( st [ n - 1 ] ) % 25 == 0 ) ) NEW_LINE DEDENT st = \"76955\" NEW_LINE if ( isDivisibleBy25 ( st ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.5900861178413023,"rouge_l":0.7685161618732502}
{"id":1443,"predictions":["def square ( n ) : NEW_LINE INDENT return n * n NEW_LINE DEDENT def sum ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return square ( n + 1 ) \/\/ 2 NEW_LINE DEDENT else : NEW_LINE INDENT return square ( n \/ 2 ) + sum ( n \/ 2 ) NEW_LINE DEDENT DEDENT def oddDivSum ( a , b ) : NEW_LINE INDENT return sum ( b ) - sum ( a - 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 3 NEW_LINE b = 9 NEW_LINE print ( oddDivSum ( a , b ) ) NEW_LINE DEDENT"],"references":["def square ( n ) : NEW_LINE INDENT return n * n ; NEW_LINE DEDENT def sum ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return ( square ( int ( ( n + 1 ) \/ 2 ) ) + sum ( int ( n \/ 2 ) ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return ( square ( int ( n \/ 2 ) ) + sum ( int ( n \/ 2 ) ) ) ; NEW_LINE DEDENT DEDENT def oddDivSum ( a , b ) : NEW_LINE INDENT return sum ( b ) - sum ( a - 1 ) ; NEW_LINE DEDENT a , b = 3 , 9 ; NEW_LINE print ( oddDivSum ( a , b ) ) ; NEW_LINE"],"bleu":0.6312174721063203,"rouge_l":0.8020856948537747}
{"id":1444,"predictions":["def removeOddFrequencyCharacters ( s ) : NEW_LINE INDENT m = dict . fromkeys ( s , 0 ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT p = s [ i ] NEW_LINE count = m . get ( p , 0 ) + 1 NEW_LINE DEDENT new_string = \" \" NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( m [ s [ i ] ] & 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT new_string += s [ i ] NEW_LINE DEDENT return new_string NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" geeksforgeeks \" NEW_LINE s = removeOddFrequencyCharacters ( s ) NEW_LINE print ( s ) NEW_LINE DEDENT"],"references":["def removeOddFrequencyCharacters ( s ) : NEW_LINE INDENT m = dict ( ) NEW_LINE for i in s : NEW_LINE INDENT m [ i ] = m . get ( i , 0 ) + 1 NEW_LINE DEDENT new_s = \" \" NEW_LINE for i in s : NEW_LINE INDENT if ( m [ i ] & 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT new_s += i NEW_LINE DEDENT return new_s NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" geeksforgeeks \" NEW_LINE str = removeOddFrequencyCharacters ( str ) NEW_LINE print ( str ) NEW_LINE DEDENT"],"bleu":0.5222428190414763,"rouge_l":0.8285954348130514}
{"id":1445,"predictions":["def countNonDecreasing ( n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for j in range ( n + 1 ) ] NEW_LINE for digit in range ( 10 ) : NEW_LINE INDENT dp [ i ] [ 1 ] = 1 NEW_LINE DEDENT for digit in range ( 10 ) : NEW_LINE INDENT for l in range ( 2 , n + 1 ) : NEW_LINE INDENT for y in range ( 0 , digit + 1 ) : NEW_LINE INDENT dp [ digit ] [ l ] += dp [ x ] [ l ] NEW_LINE DEDENT DEDENT DEDENT count = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT count += dp [ i ] [ n ] NEW_LINE DEDENT return count NEW_LINE DEDENT n = 3 NEW_LINE print ( countNonDecreasing ( n ) ) NEW_LINE"],"references":["def countNonDecreasing ( n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n + 1 ) ] for i in range ( 10 ) ] NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT dp [ i ] [ 1 ] = 1 NEW_LINE DEDENT for digit in range ( 10 ) : NEW_LINE INDENT for len in range ( 2 , n + 1 ) : NEW_LINE INDENT for x in range ( digit + 1 ) : NEW_LINE INDENT dp [ digit ] [ len ] += dp [ x ] [ len - 1 ] NEW_LINE DEDENT DEDENT DEDENT count = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT count += dp [ i ] [ n ] NEW_LINE DEDENT return count NEW_LINE DEDENT n = 3 NEW_LINE print ( countNonDecreasing ( n ) ) NEW_LINE"],"bleu":0.8560273816384285,"rouge_l":0.9271523178807946}
{"id":1446,"predictions":["def maxCount ( n , a ) : NEW_LINE INDENT freq = { } NEW_LINE for i in a : NEW_LINE INDENT if i in freq : NEW_LINE INDENT freq [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ i ] = 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for key , value in freq . items ( ) : NEW_LINE INDENT if value + 1 in freq : NEW_LINE INDENT ans = max ( ans , freq [ key ] + freq [ key + 1 ] ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT n = 5 NEW_LINE arr = [ 2 , 2 , 3 , 4 , 5 ] NEW_LINE print ( maxCount ( n , arr ) ) NEW_LINE"],"references":["def maxCount ( a ) : NEW_LINE INDENT freq = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] in freq ) : NEW_LINE INDENT freq [ a [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ a [ i ] ] = 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for key , value in freq . items ( ) : NEW_LINE INDENT if ( key + 1 in freq ) : NEW_LINE INDENT ans = max ( ans , freq [ key ] + freq [ key + 1 ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT n = 5 NEW_LINE arr = [ 2 , 2 , 3 , 4 , 5 ] NEW_LINE print ( maxCount ( arr ) ) NEW_LINE"],"bleu":0.7668430562071257,"rouge_l":0.9011530146528947}
{"id":1447,"predictions":["from math import sqrt NEW_LINE def dist ( x1 , y1 , x2 , y2 , r ) : NEW_LINE INDENT print ( \" The ▁ shortest ▁ distance ▁ distance ▁ between ▁ a ▁ circle ▁ is ▁ \" , math . sqrt ( ( 2 - x1 ) ** 2 ) + ( sqrt ( 2 - y1 ) ** 2 ) ) - 1 ) ; NEW_LINE DEDENT x1 = 4 ; y1 = 6 ; x2 = 3 ; y2 = 2 ; r = 2 ; NEW_LINE dist ( x1 , y1 , r ) ; NEW_LINE"],"references":["def dist ( x1 , y1 , x2 , y2 , r ) : NEW_LINE INDENT print ( \" The ▁ shortest ▁ distance ▁ between ▁ a ▁ point ▁ and ▁ a ▁ circle ▁ is ▁ \" , ( ( ( ( x2 - x1 ) ** 2 ) + ( ( y2 - y1 ) ** 2 ) ) ** ( 1 \/ 2 ) ) - r ) ; NEW_LINE DEDENT x1 = 4 ; NEW_LINE y1 = 6 ; NEW_LINE x2 = 35 ; NEW_LINE y2 = 42 ; NEW_LINE r = 5 ; NEW_LINE dist ( x1 , y1 , x2 , y2 , r ) ; NEW_LINE"],"bleu":0.6062545057875713,"rouge_l":0.7812360387192852}
{"id":1448,"predictions":[" vis = [ ] NEW_LINE v = [ ] NEW_LINE v . append ( 0 ) NEW_LINE def dfs ( x , adj ) : NEW_LINE INDENT sz = 1 NEW_LINE vis [ x ] = 1 NEW_LINE for i in adj [ x ] : NEW_LINE INDENT if ( vis [ x ] [ i ] == 0 ) : NEW_LINE INDENT sz += dfs ( adj [ x ] [ i ] , adj ) NEW_LINE DEDENT DEDENT return sz NEW_LINE DEDENT def maxValue ( n , adj ) : NEW_LINE INDENT val = 0 NEW_LINE vis = [ 0 ] * ( n + 1 ) NEW_LINE v . append ( 0 ) NEW_LINE v . append ( 1 ) NEW_LINE v1 . append ( 2 ) NEW_LINE v1 . append ( 1 ) NEW_LINE v1 . append ( 2 ) NEW_LINE v2 . append ( v ) NEW_LINE adj . append ( v ) NEW_LINE adj . append ( v1 ) NEW_LINE adj . append ( v ) NEW_LINE adj . append ( v1 ) NEW_LINE print ( maxValue ( n , adj ) ) NEW_LINE"],"references":["def dfs ( x , adj , vis ) : NEW_LINE INDENT sz = 1 NEW_LINE vis [ x ] = 1 NEW_LINE for ch in adj : NEW_LINE INDENT if ( not vis [ ch ] ) : NEW_LINE INDENT sz += dfs ( ch , adj , vis ) NEW_LINE DEDENT DEDENT return sz NEW_LINE DEDENT def maxValue ( n , adj ) : NEW_LINE INDENT val = 0 NEW_LINE vis = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( not vis [ i ] ) : NEW_LINE INDENT val += dfs ( i , adj , vis ) - 1 NEW_LINE DEDENT DEDENT return val NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE adj = [ 1 , 2 , 2 , 3 ] NEW_LINE print ( maxValue ( n , adj ) ) NEW_LINE DEDENT"],"bleu":0.4367196575860951,"rouge_l":0.5748868151159567}
{"id":1449,"predictions":["from math import * ; NEW_LINE def area_of_555 ( n , l ) : NEW_LINE INDENT P = ( len ( n ) ; NEW_LINE A = l \/ ( 2 * tan ( ( 180 \/ n ) * 3.14159 \/ 180 ) ) ; NEW_LINE area = ( P * A ) \/ 2 ; NEW_LINE return area ; NEW_LINE DEDENT def area_of_triangle_radius ( n , l ) : NEW_LINE INDENT area = area_of_radius ( n , len ) ; NEW_LINE triangle = area \/ n ; NEW_LINE ins_tri = ( triangle * 3 ) ; NEW_LINE return ins_tri ; NEW_LINE DEDENT n = 6 ; NEW_LINE l = 10 ; NEW_LINE print ( area_of_ circumgon ( n , l ) ) ; NEW_LINE"],"references":["import math NEW_LINE def area_of_regular_polygon ( n , len ) : NEW_LINE INDENT P = ( len * n ) ; NEW_LINE A = len \/ ( 2 * math . tan ( ( 180 \/ n ) * 3.14159 \/ 180 ) ) NEW_LINE area = ( P * A ) \/ 2 NEW_LINE return area NEW_LINE DEDENT def area_of_triangle_inscribed ( n , len ) : NEW_LINE INDENT area = area_of_regular_polygon ( n , len ) NEW_LINE triangle = area \/ n NEW_LINE ins_tri = ( triangle * 3 ) ; NEW_LINE return ins_tri NEW_LINE DEDENT n = 6 NEW_LINE len = 10 NEW_LINE print ( round ( area_of_triangle_inscribed ( n , len ) , 3 ) ) NEW_LINE"],"bleu":0.5605425827858076,"rouge_l":0.8329317269076306}
{"id":1450,"predictions":["def centeredHexagonalNumber ( n ) : NEW_LINE INDENT return ( 3 * n * n + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE print ( n , \" th ▁ Centered \" + \" number : ▁ \" , centeredHexagonalNumber ( n ) ) NEW_LINE DEDENT"],"references":["def centeredHexagonalNumber ( n ) : NEW_LINE INDENT return 3 * n * ( n - 1 ) + 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE print ( n , \" th ▁ centered ▁ hexagonal ▁ number : ▁ \" , centeredHexagonalNumber ( n ) ) NEW_LINE DEDENT"],"bleu":0.769436220697963,"rouge_l":0.8826366559485532}
{"id":1451,"predictions":["def isOrthogonal ( a , m , n ) : NEW_LINE INDENT if ( m != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for k in range ( 0 , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for k in range ( 0 , n ) : NEW_LINE INDENT sum = sum + ( a [ i ] * a [ j ] ) NEW_LINE DEDENT if ( i == j and sum != 1 ) : NEW_LINE INDENT return false NEW_LINE DEDENT if ( i != j and sum != 0 ) : NEW_LINE INDENT return false NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT a = [ [ 1 , 0 , 0 ] , [ 0 , 1 , 0 ] , [ 0 , 0 , 1 ] , [ 0 , 0 , 1 ] ] NEW_LINE if ( isOrthogonal ( a , 3 , 3 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def isOrthogonal ( a , m , n ) : NEW_LINE INDENT if ( m != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for k in range ( 0 , n ) : NEW_LINE INDENT sum = sum + ( a [ i ] [ k ] * a [ j ] [ k ] ) NEW_LINE DEDENT DEDENT if ( i == j and sum != 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( i != j and sum != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT a = [ [ 1 , 0 , 0 ] , [ 0 , 1 , 0 ] , [ 0 , 0 , 1 ] ] NEW_LINE if ( isOrthogonal ( a , 3 , 3 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.8486392483589619,"rouge_l":0.9170265780730897}
{"id":1452,"predictions":["def getAvg ( prev_avg , x , n ) : NEW_LINE INDENT return ( prev_avg * n + x ) \/ ( n + 1 ) NEW_LINE DEDENT def streamAvg ( arr , n ) : NEW_LINE INDENT avg = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT avg = getAvg ( avg , arr [ i ] , i ) NEW_LINE print ( \"Average ▁ of ▁ % d ▁ numbers ▁ is \" % ( avg ) ) NEW_LINE DEDENT return avg NEW_LINE DEDENT arr = [ 10 , 30 , 30 , 40 , 50 , 60 ] NEW_LINE n = len ( arr ) NEW_LINE streamAvg ( arr , n ) NEW_LINE"],"references":["def getAvg ( prev_avg , x , n ) : NEW_LINE INDENT return ( ( prev_avg * n + x ) \/ ( n + 1 ) ) ; NEW_LINE DEDENT def streamAvg ( arr , n ) : NEW_LINE INDENT avg = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT avg = getAvg ( avg , arr [ i ] , i ) ; NEW_LINE print ( \" Average ▁ of ▁ \" , i + 1 , \" ▁ numbers ▁ is ▁ \" , avg ) ; NEW_LINE DEDENT DEDENT arr = [ 10 , 20 , 30 , 40 , 50 , 60 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE streamAvg ( arr , n ) ; NEW_LINE"],"bleu":0.6931343829420318,"rouge_l":0.8696215655780196}
{"id":1453,"predictions":["def costOfOperation ( n , h , cost ) : NEW_LINE INDENT c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT c += abs ( h [ i ] - q ) * cost [ i ] * cost [ i ] NEW_LINE DEDENT return c NEW_LINE DEDENT def Bsearch ( n , h , cost ) : NEW_LINE INDENT max_h = max ( h ) NEW_LINE ans = max ( 0 , 0 ) NEW_LINE high = 1 + max_h NEW_LINE low = 0 NEW_LINE while ( high > low ) : NEW_LINE INDENT mid = int ( low + high ) >> 1 NEW_LINE if ( mid > 0 ) : NEW_LINE INDENT bm = costOfOperation ( n , h , cost , mid - 1 ) NEW_LINE DEDENT m = costOfOperation ( n , h , cost , mid ) NEW_LINE am = costOfOperation ( n , h , cost , cost , mid + 1 ) NEW_LINE if ( ans == m ) : NEW_LINE INDENT break NEW_LINE DEDENT ans = min ( ans , m ) NEW_LINE if ( bm <= m ) : NEW_LINE INDENT high = mid NEW_LINE DEDENT elif ( am <= m ) : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return m NEW_LINE DEDENT DEDENT h = [ 1 , 2 , 3 ] NEW_LINE cost = [ 10 , 100 , 1000 ] NEW_LINE n = len ( h ) NEW_LINE print ( Bsearch ( n , h , cost ) ) NEW_LINE"],"references":["import sys NEW_LINE def costOfOperation ( n , h , cost , eq_h ) : NEW_LINE INDENT c = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT c += abs ( h [ i ] - eq_h ) * cost [ i ] NEW_LINE DEDENT return c NEW_LINE DEDENT def Bsearch ( n , h , cost ) : NEW_LINE INDENT max_h = h [ 0 ] NEW_LINE for i in range ( len ( h ) ) : NEW_LINE INDENT if ( h [ i ] > max_h ) : NEW_LINE INDENT max_h = h [ i ] NEW_LINE DEDENT DEDENT ans = sys . maxsize NEW_LINE high = 1 + max_h NEW_LINE low = 0 NEW_LINE while ( high > low ) : NEW_LINE INDENT mid = ( low + high ) >> 1 NEW_LINE if ( mid > 0 ) : NEW_LINE INDENT bm = costOfOperation ( n , h , cost , mid - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT bm = sys . maxsize NEW_LINE DEDENT m = costOfOperation ( n , h , cost , mid ) NEW_LINE am = costOfOperation ( n , h , cost , mid + 1 ) NEW_LINE if ( ans == m ) : NEW_LINE INDENT break NEW_LINE DEDENT ans = min ( ans , m ) NEW_LINE if ( bm <= m ) : NEW_LINE INDENT high = mid NEW_LINE DEDENT elif ( am <= m ) : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return m ; NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT h = [ 1 , 2 , 3 ] NEW_LINE cost = [ 10 , 100 , 1000 ] NEW_LINE n = len ( h ) NEW_LINE print ( Bsearch ( n , h , cost ) ) NEW_LINE DEDENT"],"bleu":0.7099263745886667,"rouge_l":0.8256237430015763}
{"id":1454,"predictions":["def check ( a , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( a [ i ] == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 0 , 1 , 0 , 1 ] NEW_LINE n = len ( a ) NEW_LINE if ( check ( a , n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"references":["def check ( a , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 0 , 1 , 0 , 1 ] NEW_LINE n = len ( a ) NEW_LINE if ( check ( a , n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.9344132766918243,"rouge_l":0.9844816883923029}
{"id":1455,"predictions":["def findIndex ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT a , b , c = 0 , 1 , 1 NEW_LINE res = 1 NEW_LINE while ( c < n ) : NEW_LINE INDENT c = a + b NEW_LINE res = res + c NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return res NEW_LINE DEDENT result = findIndex ( 21 ) NEW_LINE print ( findIndex ( 21 ) ) NEW_LINE"],"references":["def findIndex ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT a = 0 NEW_LINE b = 1 NEW_LINE c = 1 NEW_LINE res = 1 NEW_LINE while ( c < n ) : NEW_LINE INDENT c = a + b NEW_LINE res = res + 1 NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return res NEW_LINE DEDENT result = findIndex ( 21 ) NEW_LINE print ( result ) NEW_LINE"],"bleu":0.8039619973543253,"rouge_l":0.8904242896068507}
{"id":1456,"predictions":["def sumNth ( A , B , m , n ) : NEW_LINE INDENT res = 0 NEW_LINE if ( n == 1 ) : NEW_LINE INDENT for i in range ( m ) : NEW_LINE INDENT res = res + A [ i ] NEW_LINE DEDENT DEDENT elif ( n == 2 ) : NEW_LINE INDENT for i in range ( m ) : NEW_LINE INDENT res = res + B [ i ] * m NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT f = [ 0 ] * n NEW_LINE f [ 0 ] = 0 NEW_LINE f [ 1 ] = 1 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT f [ i ] = f [ i - 1 ] + f [ i - 2 ] NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT res = res + ( m * ( B [ i ] * f [ n - 1 ] ) ) + ( m * ( A [ i ] * f [ n - 2 ] ) ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 1 , 2 , 3 ] NEW_LINE B = [ 4 , 5 , 6 ] NEW_LINE n = 3 NEW_LINE m = len ( A ) NEW_LINE print ( sumNth ( A , B , m , n ) ) NEW_LINE DEDENT"],"references":["def sumNth ( A , B , m , n ) : NEW_LINE INDENT res = 0 ; NEW_LINE if ( n == 1 ) : NEW_LINE INDENT for i in range ( m ) : NEW_LINE INDENT res = res + A [ i ] ; NEW_LINE DEDENT DEDENT elif ( n == 2 ) : NEW_LINE INDENT for i in range ( m ) : NEW_LINE INDENT res = res + B [ i ] * m ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT f = [ 0 ] * n ; NEW_LINE f [ 0 ] = 0 ; NEW_LINE f [ 1 ] = 1 ; NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT f [ i ] = f [ i - 1 ] + f [ i - 2 ] ; NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT res = ( res + ( m * ( B [ i ] * f [ n - 1 ] ) ) + ( m * ( A [ i ] * f [ n - 2 ] ) ) ) ; NEW_LINE DEDENT DEDENT return res ; NEW_LINE DEDENT A = [ 1 , 2 , 3 ] ; NEW_LINE B = [ 4 , 5 , 6 ] ; NEW_LINE n = 3 ; NEW_LINE m = len ( A ) ; NEW_LINE print ( sumNth ( A , B , m , n ) ) ; NEW_LINE"],"bleu":0.8438332551326533,"rouge_l":0.9402773298935827}
{"id":1457,"predictions":["def isVowel ( c ) : NEW_LINE INDENT return ( c == ' a ' or c == ' A ' or c == ' E ' or c == ' I ' or c == ' U ' or c == ' U ' or c == ' U ' ) NEW_LINE DEDENT def reverseVowel ( str1 ) : NEW_LINE INDENT j = 0 NEW_LINE st = \" \" NEW_LINE vowel = \" \" NEW_LINE for i in range ( len ( st ) ) : NEW_LINE INDENT if ( isVowel ( st [ i ] ) ) : NEW_LINE INDENT j += 1 NEW_LINE vowel += st [ i ] NEW_LINE DEDENT DEDENT for i in range ( len ( st ) ) : NEW_LINE INDENT if ( isVowel ( st [ i ] ) ) : NEW_LINE INDENT st += st [ i ] NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT return st NEW_LINE DEDENT str1 = \" hello ▁world \" NEW_LINE print ( reverseVowel ( str1 ) ) NEW_LINE"],"references":["def isVowel ( c ) : NEW_LINE INDENT if ( c == ' a ' or c == ' A ' or c == ' e ' or c == ' E ' or c == ' i ' or c == ' I ' or c == ' o ' or c == ' O ' or c == ' u ' or c == ' U ' ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def reverserVowel ( string ) : NEW_LINE INDENT j = 0 NEW_LINE vowel = [ 0 ] * len ( string ) NEW_LINE string = list ( string ) NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if isVowel ( string [ i ] ) : NEW_LINE INDENT vowel [ j ] = string [ i ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT for i in range ( len ( string ) ) : NEW_LINE INDENT if isVowel ( string [ i ] ) : NEW_LINE INDENT j -= 1 NEW_LINE string [ i ] = vowel [ j ] NEW_LINE DEDENT DEDENT return ' ' . join ( string ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" hello ▁ world \" NEW_LINE print ( reverserVowel ( string ) ) NEW_LINE DEDENT"],"bleu":0.4552208691443395,"rouge_l":0.6611027608575272}
{"id":1458,"predictions":["def minimumCost ( cost , n ) : NEW_LINE INDENT dp1 = 0 NEW_LINE dp2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp1 = cost [ i ] + min ( dp1 , dp2 ) NEW_LINE dp2 = dp1 NEW_LINE DEDENT return min ( dp1 , dp2 ) NEW_LINE DEDENT a = [ 2 , 5 , 3 , 1 , 7 , 3 , 4 ] NEW_LINE n = len ( a ) NEW_LINE print ( minimumCost ( a , n ) ) NEW_LINE"],"references":["def minimumCost ( cost , n ) : NEW_LINE INDENT dp1 = 0 NEW_LINE dp2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp0 = cost [ i ] + min ( dp1 , dp2 ) NEW_LINE dp2 = dp1 NEW_LINE dp1 = dp0 NEW_LINE DEDENT return min ( dp1 , dp2 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 2 , 5 , 3 , 1 , 7 , 3 , 4 ] NEW_LINE n = len ( a ) NEW_LINE print ( minimumCost ( a , n ) ) NEW_LINE DEDENT"],"bleu":0.780938690398142,"rouge_l":0.8856267139861267}
{"id":1459,"predictions":["N = 2 NEW_LINE def isVowel ( ch ) : NEW_LINE INDENT return ( ch == ' a ' or ch == ' e ' or ch == ' i ' or ch == ' o ' or ch == ' u ' ) NEW_LINE DEDENT def countVowels ( strr , l , r ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if ( isVowel ( strr [ i ] ) ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT def performQueries ( strr , queries , q ) : NEW_LINE INDENT for i in range ( q ) : NEW_LINE INDENT print ( countVowels ( strr , queries [ i ] [ 0 ] , queries [ i ] [ 1 ] ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT strr = \" geeksforgeeks \" NEW_LINE queries = [ 1 , 3 ] , [ 2 , 4 ] , [ 1 , 9 ] ] NEW_LINE q = len ( queries ) NEW_LINE performQueries ( strr , queries , q ) NEW_LINE DEDENT"],"references":["N = 2 ; NEW_LINE def isVowel ( ch ) : NEW_LINE INDENT return ( ch == ' a ' or ch == ' e ' or ch == ' i ' or ch == ' o ' or ch == ' u ' ) ; NEW_LINE DEDENT def countVowels ( string , l , r ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if ( isVowel ( string [ i ] ) ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT return cnt ; NEW_LINE DEDENT def performQueries ( string , queries , q ) : NEW_LINE INDENT for i in range ( q ) : NEW_LINE INDENT print ( countVowels ( string , queries [ i ] [ 0 ] , queries [ i ] [ 1 ] ) ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" geeksforgeeks \" ; NEW_LINE queries = [ [ 1 , 3 ] , [ 2 , 4 ] , [ 1 , 9 ] ] ; NEW_LINE q = len ( queries ) NEW_LINE performQueries ( string , queries , q ) ; NEW_LINE DEDENT"],"bleu":0.7872000117277133,"rouge_l":0.9337706966572945}
{"id":1460,"predictions":["def removeAlternate ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return 2 * removeAlternate ( n \/\/ 2 ) - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 * removeAlternate ( ( n - 1 ) \/\/ 2 ) + 1 NEW_LINE DEDENT DEDENT n = 5 NEW_LINE print ( removeAlternate ( n ) ) NEW_LINE"],"references":["def removeAlternate ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return 2 * removeAlternate ( n \/ 2 ) - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 * removeAlternate ( ( ( n - 1 ) \/ 2 ) ) + 1 NEW_LINE DEDENT DEDENT n = 5 NEW_LINE print ( removeAlternate ( n ) ) NEW_LINE n = 10 NEW_LINE print ( removeAlternate ( n ) ) NEW_LINE"],"bleu":0.77505598414611,"rouge_l":0.8823971444674055}
{"id":1461,"predictions":["import math NEW_LINE def lowerWythoff ( n ) : NEW_LINE INDENT phi = ( 1 + math . sqrt ( 5 ) ) \/ 2.0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = floor ( i * phi ) NEW_LINE print ( ans ) NEW_LINE if ( i != n ) : NEW_LINE INDENT print ( \" , ▁ \" , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT n = 5 NEW_LINE lowerWythoff ( n ) NEW_LINE"],"references":["from math import sqrt , floor NEW_LINE def lowerWythoff ( n ) : NEW_LINE INDENT phi = ( 1 + sqrt ( 5 ) ) \/ 2 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = floor ( i * phi ) ; NEW_LINE print ( ans , end = \" \" ) ; NEW_LINE if ( i != n ) : NEW_LINE INDENT print ( \" , ▁ \" , end = \" \" ) ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 ; NEW_LINE lowerWythoff ( n ) ; NEW_LINE DEDENT"],"bleu":0.5908176842289541,"rouge_l":0.8082018927444796}
{"id":1462,"predictions":["def countPairs ( st ) : NEW_LINE INDENT result = 0 NEW_LINE n = len ( st ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if abs ( st [ i ] - st [ j ] ) == abs ( i - j ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT st = \" geeksforgeeks \" NEW_LINE print ( countPairs ( st ) ) NEW_LINE"],"references":["def countPairs ( str1 ) : NEW_LINE INDENT result = 0 ; NEW_LINE n = len ( str1 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( abs ( ord ( str1 [ i ] ) - ord ( str1 [ j ] ) ) == abs ( i - j ) ) : NEW_LINE INDENT result += 1 ; NEW_LINE DEDENT DEDENT DEDENT return result ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" geeksforgeeks \" ; NEW_LINE print ( countPairs ( str1 ) ) ; NEW_LINE DEDENT"],"bleu":0.5004174018567141,"rouge_l":0.7862016679302503}
{"id":1463,"predictions":["import math NEW_LINE def checkPowerof8 ( n ) : NEW_LINE INDENT i = int ( math . log ( n , 8 ) ) ; NEW_LINE return ( i - floor ( math . log ( i ) ) < 0.000001 ) ; NEW_LINE DEDENT n = 65 ; NEW_LINE if ( checkPowerof8 ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT"],"references":["from math import log , trunc NEW_LINE def checkPowerof8 ( n ) : NEW_LINE INDENT i = log ( n , 8 ) NEW_LINE return ( i - trunc ( i ) < 0.000001 ) ; NEW_LINE DEDENT n = 65 NEW_LINE if checkPowerof8 ( n ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.6209895999096241,"rouge_l":0.8542669584245076}
{"id":1464,"predictions":["def digitsNum ( N ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT print ( \"0\" ) NEW_LINE DEDENT if ( N % 9 != 0 ) : NEW_LINE INDENT print ( N % 9 , end = \" \" ) NEW_LINE DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( \"9\" , end = \" \" ) NEW_LINE DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( \"0\" , end = \" \" ) NEW_LINE DEDENT print ( \" \" ) NEW_LINE DEDENT N = 5 NEW_LINE print ( \" The ▁ number ▁ is ▁ : ▁ \" , digitsNum ( N ) ) NEW_LINE"],"references":["import math NEW_LINE def digitsNum ( N ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT print ( \"0\" , end = \" \" ) NEW_LINE DEDENT if ( N % 9 != 0 ) : NEW_LINE INDENT print ( N % 9 , end = \" \" ) NEW_LINE DEDENT for i in range ( 1 , int ( N \/ 9 ) + 1 ) : NEW_LINE INDENT print ( \"9\" , end = \" \" ) NEW_LINE DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( \"0\" , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT N = 5 NEW_LINE print ( \" The ▁ number ▁ is ▁ : ▁ \" , end = \" \" ) NEW_LINE digitsNum ( N ) NEW_LINE"],"bleu":0.8245815984324203,"rouge_l":0.908806920581521}
{"id":1465,"predictions":["def printFirstNegativeInteger ( arr , n , k ) : NEW_LINE INDENT di = [ ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT di . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( len ( di ) > 0 ) : NEW_LINE INDENT print ( arr [ di [ 0 ] ] , end = \" ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" ▁ \" , end = \" ▁ \" ) NEW_LINE DEDENT while ( len ( di ) != 0 and len ( di ) < ( i - k + 1 ) ) : NEW_LINE INDENT di . append ( i ) NEW_LINE DEDENT if ( not di [ 0 ] ) : NEW_LINE INDENT print ( arr [ di [ - 1 ] ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if ( not di [ - 1 ] ) : NEW_LINE INDENT print ( arr [ di [ - 1 ] ] , end = \" ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \"0\" , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 10 , - 1 , - 7 , 8 , - 7 , 8 , - 10 , 8 , 6 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE printFirstNegativeInteger ( arr , n , k ) NEW_LINE"],"references":["from collections import deque NEW_LINE def printFirstNegativeInteger ( arr , n , k ) : NEW_LINE INDENT Di = deque ( ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT Di . append ( i ) ; NEW_LINE DEDENT DEDENT for i in range ( k , n ) : NEW_LINE INDENT if ( not Di ) : NEW_LINE INDENT print ( 0 , end = ' ▁ ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ Di [ 0 ] ] , end = ' ▁ ' ) ; NEW_LINE DEDENT while Di and Di [ 0 ] <= ( i - k ) : NEW_LINE INDENT Di . popleft ( ) NEW_LINE DEDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT Di . append ( i ) ; NEW_LINE DEDENT DEDENT if not Di : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ Di [ 0 ] ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 12 , - 1 , - 7 , 8 , - 15 , 30 , 16 , 28 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE printFirstNegativeInteger ( arr , n , k ) ; NEW_LINE DEDENT"],"bleu":0.547445127388058,"rouge_l":0.681977895611065}
{"id":1466,"predictions":["def findFirstAndLast ( arr , x ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE first = - 1 NEW_LINE last = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if x != arr [ i ] : NEW_LINE INDENT continue NEW_LINE DEDENT if first != - 1 : NEW_LINE INDENT first = i NEW_LINE DEDENT last = i NEW_LINE DEDENT if first != - 1 : NEW_LINE INDENT print ( \" First ▁ Occurrence ▁ = ▁ \" , first ) NEW_LINE print ( \" Last ▁ Occurrence ▁ = ▁ \" , last ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ Found \" ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 2 , 2 , 3 , 4 , 7 , 8 , 8 ] NEW_LINE x = 8 NEW_LINE findFirstAndLast ( arr , x ) NEW_LINE"],"references":["def findFirstAndLast ( arr , n , x ) : NEW_LINE INDENT first = - 1 NEW_LINE last = - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( x != arr [ i ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( first == - 1 ) : NEW_LINE INDENT first = i NEW_LINE DEDENT last = i NEW_LINE DEDENT if ( first != - 1 ) : NEW_LINE INDENT print ( \" First ▁ Occurrence ▁ = ▁ \" , first , \" ▁ \\n Last ▁ Occurrence ▁ = ▁ \" , last ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ Found \" ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 2 , 2 , 2 , 3 , 4 , 7 , 8 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE x = 8 NEW_LINE findFirstAndLast ( arr , n , x ) NEW_LINE"],"bleu":0.7743129737681025,"rouge_l":0.8775635139271503}
{"id":1467,"predictions":["NO_OF_CHARS = 256 NEW_LINE def areAnagram ( str1 , str2 ) : NEW_LINE INDENT count = [ 0 ] * NO_OF_CHARS NEW_LINE i = 0 NEW_LINE while i < len ( str1 ) and i < len ( str2 ) : NEW_LINE INDENT count [ ord ( str1 [ i ] ) ] += 1 NEW_LINE count [ ord ( str2 [ i ] ) ] -= 1 NEW_LINE i += 1 NEW_LINE DEDENT if ( len ( str1 ) != len ( str2 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( NO_OF_CHARS ) : NEW_LINE INDENT if ( count [ i ] != 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def findAllAnagrams ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( areAnagram ( arr [ i ] , arr [ j ] ) ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ \" geeksgeeks \" , \" geegeeks \" , \" abc \" , \" for e in range ( n ) ] NEW_LINE n = len ( arr ) NEW_LINE findAllAnagrams ( arr , n ) NEW_LINE"],"references":["NO_OF_CHARS = 256 NEW_LINE def areAnagram ( str1 : str , str2 : str ) -> bool : NEW_LINE INDENT count = [ 0 ] * NO_OF_CHARS NEW_LINE i = 0 NEW_LINE while i < len ( str1 ) and i < len ( str2 ) : NEW_LINE INDENT count [ ord ( str1 [ i ] ) ] += 1 NEW_LINE count [ ord ( str2 [ i ] ) ] -= 1 NEW_LINE i += 1 NEW_LINE DEDENT if len ( str1 ) != len ( str2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( NO_OF_CHARS ) : NEW_LINE INDENT if count [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT DEDENT def findAllAnagrams ( arr : list , n : int ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if areAnagram ( arr [ i ] , arr [ j ] ) : NEW_LINE INDENT print ( arr [ i ] , \" is ▁ anagram ▁ of \" , arr [ j ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ \" geeksquiz \" , \" geeksforgeeks \" , \" abcd \" , \" forgeeksgeeks \" , \" zuiqkeegs \" ] NEW_LINE n = len ( arr ) NEW_LINE findAllAnagrams ( arr , n ) NEW_LINE DEDENT"],"bleu":0.6909086093958989,"rouge_l":0.8444892473118281}
{"id":1468,"predictions":["MAX = 100 NEW_LINE arr = [ 0 ] * MAX NEW_LINE arr [ 0 ] = 0 NEW_LINE arr [ 1 ] = 1 NEW_LINE for i in range ( 2 , MAX ) : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] + arr [ i - 2 ] NEW_LINE DEDENT print ( \" Fibonacci ▁ numbers ▁ divisible ▁ by ▁ the ▁ indexes ▁ are \" ) NEW_LINE for i in range ( 1 , MAX ) : NEW_LINE INDENT if arr [ i ] % i == 0 : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT"],"references":["if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT MAX = 100 NEW_LINE arr = [ 0 for i in range ( MAX ) ] NEW_LINE arr [ 0 ] = 0 NEW_LINE arr [ 1 ] = 1 NEW_LINE for i in range ( 2 , MAX ) : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] + arr [ i - 2 ] NEW_LINE DEDENT print ( \" Fibonacci ▁ numbers ▁ divisible ▁ by ▁ their ▁ indexes ▁ are ▁ : \" ) NEW_LINE for i in range ( 1 , MAX ) : NEW_LINE INDENT if ( arr [ i ] % i == 0 ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT"],"bleu":0.7362085645739428,"rouge_l":0.8700848111025444}
{"id":1469,"predictions":["def isPossible ( Sx , Sy , dx , x , y ) : NEW_LINE INDENT if ( abs ( Sx - Dx ) % x == 0 and abs ( Syx - Dx ) % y == 0 and ( abs ( Sx - Dx ) \/\/ x ) % 2 == ( abs ( Sy - dy ) \/\/ 2 ) % 2 == ( abs ( Sy - Syx ) \/\/ 2 ) % 2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT Sx , Sy , Dx , dx , dy = 0 , 0 , 0 NEW_LINE x , y = 3 , 4 NEW_LINE if ( isPossible ( Sx , Sy , Dx , x , y ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def isPossible ( Sx , Sy , Dx , Dy , x , y ) : NEW_LINE INDENT if ( abs ( Sx - Dx ) % x == 0 and abs ( Sy - Dy ) % y == 0 and ( abs ( Sx - Dx ) \/ x ) % 2 == ( abs ( Sy - Dy ) \/ y ) % 2 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT Sx = 0 ; NEW_LINE Sy = 0 ; NEW_LINE Dx = 0 ; NEW_LINE Dy = 0 ; NEW_LINE x = 3 ; NEW_LINE y = 4 ; NEW_LINE if ( isPossible ( Sx , Sy , Dx , Dy , x , y ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT"],"bleu":0.6451130917286269,"rouge_l":0.7822184227399017}
{"id":1470,"predictions":["from math import sqrt NEW_LINE def isPerfectSquare ( st ) : NEW_LINE INDENT sum = 0 NEW_LINE l = len ( st ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT sum += ord ( st [ i ] ) NEW_LINE DEDENT squareRoot = sqrt ( sum ) NEW_LINE return ( squareRoot - floor ( squareRoot ) == 0 ) NEW_LINE DEDENT st = \" d \" NEW_LINE if ( isPerfectSquareString ( st ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["import math ; NEW_LINE def isPerfectSquareString ( str ) : NEW_LINE INDENT sum = 0 ; NEW_LINE l = len ( str ) ; NEW_LINE for i in range ( l ) : NEW_LINE INDENT sum = sum + ord ( str [ i ] ) ; NEW_LINE DEDENT squareRoot = math . sqrt ( sum ) ; NEW_LINE return ( ( squareRoot - math . floor ( squareRoot ) ) == 0 ) ; NEW_LINE DEDENT str = \" d \" ; NEW_LINE if ( isPerfectSquareString ( str ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT"],"bleu":0.5365370575621389,"rouge_l":0.8283838233099536}
{"id":1471,"predictions":["def arePermutation ( str1 , str2 ) : NEW_LINE INDENT n1 = len ( str1 ) NEW_LINE n2 = len ( str2 ) NEW_LINE if ( n1 != n2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 0 , n1 ) : NEW_LINE INDENT if ( str1 [ i ] != str2 [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" test \" NEW_LINE str2 = \" ttew \" NEW_LINE if ( arePermutation ( str1 , str2 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def arePermutation ( str1 , str2 ) : NEW_LINE INDENT n1 = len ( str1 ) NEW_LINE n2 = len ( str2 ) NEW_LINE if ( n1 != n2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT a = sorted ( str1 ) NEW_LINE str1 = \" ▁ \" . join ( a ) NEW_LINE b = sorted ( str2 ) NEW_LINE str2 = \" ▁ \" . join ( b ) NEW_LINE for i in range ( 0 , n1 , 1 ) : NEW_LINE INDENT if ( str1 [ i ] != str2 [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = \" test \" NEW_LINE str2 = \" ttew \" NEW_LINE if ( arePermutation ( str1 , str2 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.7043161279223299,"rouge_l":0.8407949567261459}
{"id":1472,"predictions":["def catalanDP ( n ) : NEW_LINE INDENT catalan = [ 0 ] * ( n + 2 ) ; NEW_LINE catalan [ 0 ] = 1 ; NEW_LINE catalan [ 1 ] = 1 ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT catalan [ i ] = 0 ; NEW_LINE for j in range ( i ) : NEW_LINE INDENT catalan [ i ] += catalan [ j ] * catalan [ i - j - j - 1 ] ; NEW_LINE DEDENT DEDENT return catalan [ n ] ; NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT print ( catalanDP ( i ) , end = \" ▁ \" ) ; NEW_LINE DEDENT"],"references":["def catalan ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT catalan = [ 0 for i in range ( n + 1 ) ] NEW_LINE catalan [ 0 ] = 1 NEW_LINE catalan [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT catalan [ i ] = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT catalan [ i ] = catalan [ i ] + catalan [ j ] * catalan [ i - j - 1 ] NEW_LINE DEDENT DEDENT return catalan [ n ] NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT print ( catalan ( i ) , end = \" ▁ \" ) NEW_LINE DEDENT"],"bleu":0.647784265767756,"rouge_l":0.8208578637510514}
{"id":1473,"predictions":["def findGeagram ( arr , n ) : NEW_LINE INDENT for j in range ( 1 , n - 1 ) : NEW_LINE INDENT i = j - 1 NEW_LINE k = j + 1 NEW_LINE while ( i >= 0 and k <= n - 1 ) : NEW_LINE INDENT while ( i >= 0 and arr [ j ] % arr [ i ] == 0 and arr [ k ] % arr [ j ] == 0 and arr [ j ] == arr [ k ] ) : NEW_LINE INDENT print ( arr [ i ] , arr [ j ] \/\/ arr [ k ] == arr [ j ] ) NEW_LINE k += 1 NEW_LINE i -= 1 NEW_LINE DEDENT if ( i >= 0 and arr [ j ] % arr [ i ] == 0 and arr [ k ] % arr [ j ] == 0 ) : NEW_LINE INDENT if ( i > 0 and arr [ j ] \/\/ arr [ i ] < arr [ k ] ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT k += 1 NEW_LINE DEDENT DEDENT elif ( i > 0 and arr [ j ] % arr [ i ] == 0 ) : NEW_LINE INDENT k += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT arr = [ 1 , 2 , 4 , 16 ] NEW_LINE n = len ( arr ) NEW_LINE findGeometricTripletsTriplets ( arr , n ) NEW_LINE"],"references":["def findGeometricTriplets ( arr , n ) : NEW_LINE INDENT for j in range ( 1 , n - 1 ) : NEW_LINE INDENT i = j - 1 NEW_LINE k = j + 1 NEW_LINE while ( i >= 0 and k <= n - 1 ) : NEW_LINE INDENT while ( arr [ j ] % arr [ i ] == 0 and arr [ k ] % arr [ j ] == 0 and arr [ j ] \/\/ arr [ i ] == arr [ k ] \/\/ arr [ j ] ) : NEW_LINE INDENT print ( arr [ i ] , \" ▁ \" , arr [ j ] , \" ▁ \" , arr [ k ] ) NEW_LINE k += 1 NEW_LINE i -= 1 NEW_LINE DEDENT if ( arr [ j ] % arr [ i ] == 0 and arr [ k ] % arr [ j ] == 0 ) : NEW_LINE INDENT if ( arr [ j ] \/\/ arr [ i ] < arr [ k ] \/\/ arr [ j ] ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT k += 1 NEW_LINE DEDENT DEDENT elif ( arr [ j ] % arr [ i ] == 0 ) : NEW_LINE INDENT k += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 16 ] NEW_LINE n = len ( arr ) NEW_LINE findGeometricTriplets ( arr , n ) NEW_LINE DEDENT"],"bleu":0.8215387377663556,"rouge_l":0.8767967145790555}
{"id":1474,"predictions":["def fib ( n ) : NEW_LINE INDENT F = [ [ 1 , 1 ] , [ 1 , 0 ] ] NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT power ( F , n - 1 ) NEW_LINE return F [ 0 ] [ 0 ] NEW_LINE DEDENT def multiply ( F , M ) : NEW_LINE INDENT x = ( F [ 0 ] [ 0 ] * M [ 0 ] [ 0 ] + F [ 0 ] [ 1 ] * M [ 1 ] [ 0 ] ) NEW_LINE y = F [ 0 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 0 ] [ 1 ] * M [ 1 ] [ 1 ] ) NEW_LINE z = ( F [ 1 ] [ 0 ] * M [ 0 ] [ 0 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 0 ] ) NEW_LINE w = ( F [ 1 ] [ 0 ] * M [ 0 ] [ 0 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 0 ] ) NEW_LINE F [ 0 ] [ 0 ] = x NEW_LINE F [ 0 ] [ 1 ] = y NEW_LINE F [ 0 ] [ 0 ] = y NEW_LINE F [ 0 ] [ 1 ] = z NEW_LINE F [ 1 ] [ 1 ] = w NEW_LINE F [ 1 ] [ 0 ] = z NEW_LINE F [ 1 ] [ 1 ] = w NEW_LINE F [ 1 ] [ 0 ] = w NEW_LINE F [ 1 ] [ 1 ] = w NEW_LINE DEDENT def power ( F , n ) : NEW_LINE INDENT M = [ [ 1 , 1 ] , [ 1 , 0 ] ] NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT multiply ( F , M ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 9 NEW_LINE print ( fib ( n ) NEW_LINE DEDENT"],"references":["def fib ( n ) : NEW_LINE INDENT F = [ [ 1 , 1 ] , [ 1 , 0 ] ] NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT power ( F , n - 1 ) NEW_LINE return F [ 0 ] [ 0 ] NEW_LINE DEDENT def multiply ( F , M ) : NEW_LINE INDENT x = ( F [ 0 ] [ 0 ] * M [ 0 ] [ 0 ] + F [ 0 ] [ 1 ] * M [ 1 ] [ 0 ] ) NEW_LINE y = ( F [ 0 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 0 ] [ 1 ] * M [ 1 ] [ 1 ] ) NEW_LINE z = ( F [ 1 ] [ 0 ] * M [ 0 ] [ 0 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 0 ] ) NEW_LINE w = ( F [ 1 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 1 ] ) NEW_LINE F [ 0 ] [ 0 ] = x NEW_LINE F [ 0 ] [ 1 ] = y NEW_LINE F [ 1 ] [ 0 ] = z NEW_LINE F [ 1 ] [ 1 ] = w NEW_LINE DEDENT def power ( F , n ) : NEW_LINE INDENT M = [ [ 1 , 1 ] , [ 1 , 0 ] ] NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT multiply ( F , M ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 9 NEW_LINE print ( fib ( n ) ) NEW_LINE DEDENT"],"bleu":0.8425064788804459,"rouge_l":0.9257327136488666}
{"id":1475,"predictions":["def largest_alphraph ( a , n ) : NEW_LINE INDENT max = ' A ' NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( a [ i ] > max ) : NEW_LINE INDENT max = a [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT def smallest_alphabet ( a , n ) : NEW_LINE INDENT min = ' z ' NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( a [ i ] < min ) : NEW_LINE INDENT min = a [ i ] NEW_LINE DEDENT DEDENT return min NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = \" GeEksforGeeks \" NEW_LINE size = len ( a ) NEW_LINE print ( \" Largest ▁ and ▁ smallest ▁ alphabet ▁ is ▁ : ▁ \" , end = ' ' ) NEW_LINE print ( smallest_alph ( a , size ) ) NEW_LINE print ( smallest_alph ( a , size ) ) NEW_LINE print ( smallest_alphoun ( a , size ) ) NEW_LINE DEDENT"],"references":["def largest_alphabet ( a , n ) : NEW_LINE INDENT max = ' A ' NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] > max ) : NEW_LINE INDENT max = a [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT def smallest_alphabet ( a , n ) : NEW_LINE INDENT min = ' z ' ; NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( a [ i ] < min ) : NEW_LINE INDENT min = a [ i ] NEW_LINE DEDENT DEDENT return min NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = \" GeEksforGeeks \" NEW_LINE size = len ( a ) NEW_LINE print ( \" Largest ▁ and ▁ smallest ▁ alphabet ▁ is ▁ : ▁ \" , end = \" \" ) NEW_LINE print ( largest_alphabet ( a , size ) , end = \" ▁ and ▁ \" ) NEW_LINE print ( smallest_alphabet ( a , size ) ) NEW_LINE DEDENT"],"bleu":0.8384492948636008,"rouge_l":0.9186746987951808}
{"id":1476,"predictions":["def Check_is_possible ( l , r , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if ( i % k == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return ( count > 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT l , r , k = 4 , 12 , 5 NEW_LINE if Check_is_possible ( l , r , k ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"references":["def Check_is_possible ( l , r , k ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if ( i % k == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return ( count > 1 ) ; NEW_LINE DEDENT l = 4 ; NEW_LINE r = 12 ; NEW_LINE k = 5 ; NEW_LINE if ( Check_is_possible ( l , r , k ) ) : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE DEDENT"],"bleu":0.6991180107057369,"rouge_l":0.8405689731812119}
{"id":1477,"predictions":["def pushZerosToEnd ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] ) : NEW_LINE INDENT arr [ arr [ i ] ] = arr [ i ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT while ( count < n ) : NEW_LINE INDENT arr [ count ] = 0 NEW_LINE count += 1 NEW_LINE DEDENT DEDENT arr = [ 1 , 9 , 8 , 4 , 0 , 0 , 2 , 7 , 0 , 6 , 0 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE pushZerosToEnd ( arr , n ) NEW_LINE print ( \" Array ▁ after ▁ pushed ▁ zeros ▁ to ▁ the ▁ back : ▁ \" ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT"],"references":["def pushZerosToEnd ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] != 0 : NEW_LINE INDENT arr [ count ] = arr [ i ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT while count < n : NEW_LINE INDENT arr [ count ] = 0 NEW_LINE count += 1 NEW_LINE DEDENT DEDENT arr = [ 1 , 9 , 8 , 4 , 0 , 0 , 2 , 7 , 0 , 6 , 0 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE pushZerosToEnd ( arr , n ) NEW_LINE print ( \" Array ▁ after ▁ pushing ▁ all ▁ zeros ▁ to ▁ end ▁ of ▁ array : \" ) NEW_LINE print ( arr ) NEW_LINE"],"bleu":0.7054279811249539,"rouge_l":0.8684925551570482}
{"id":1478,"predictions":["def check ( s , k ) : NEW_LINE INDENT for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] != s [ i % k ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def countCommonDivisors ( a , b ) : NEW_LINE INDENT ct = 0 NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE for i in range ( 1 , min ( n , m ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 and m % i == 0 ) : NEW_LINE INDENT if ( a [ 0 : i ] == b [ 0 : i ] and check ( a , i ) ) : NEW_LINE INDENT ct += 1 NEW_LINE DEDENT DEDENT DEDENT return ct NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = \" xaxa \" NEW_LINE b = \" xaxaxaxa \" NEW_LINE print ( countCommonDivisors ( a , b ) ) NEW_LINE DEDENT"],"references":["def check ( s , k ) : NEW_LINE INDENT for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] != s [ i % k ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def countCommonDivisors ( a , b ) : NEW_LINE INDENT ct = 0 NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE for i in range ( 1 , min ( n , m ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 and m % i == 0 ) : NEW_LINE INDENT if ( a [ 0 : i ] == b [ 0 : i ] ) : NEW_LINE INDENT if ( check ( a , i ) and check ( b , i ) ) : NEW_LINE INDENT ct = ct + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return ct NEW_LINE DEDENT a = \" xaxa \" NEW_LINE b = \" xaxaxaxa \" NEW_LINE print ( countCommonDivisors ( a , b ) ) NEW_LINE"],"bleu":0.8998649332950732,"rouge_l":0.9120305980528512}
{"id":1479,"predictions":["n = 4562 ; NEW_LINE rev = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT a = n % 10 NEW_LINE rev = rev * 10 + a NEW_LINE n = n \/ 10 NEW_LINE DEDENT print ( rev ) NEW_LINE"],"references":["n = 4562 ; NEW_LINE rev = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT a = n % 10 NEW_LINE rev = rev * 10 + a NEW_LINE n = n \/\/ 10 NEW_LINE DEDENT print ( rev ) NEW_LINE"],"bleu":0.9414356817218077,"rouge_l":0.9772727272727274}
{"id":1480,"predictions":["def center_nonadecagon_num ( n ) : NEW_LINE INDENT return ( 19 * n * n - 19 * n + 2 ) \/ 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 2 NEW_LINE print ( n , \" r ▁ centered ▁ nadecagonal ▁ number ▁ : ▁ \" , center_non_num ( n ) ) NEW_LINE n = 7 NEW_LINE print ( n , \" th ▁ centered ▁ unadecagon_num ( n ) ) NEW_LINE DEDENT"],"references":["def center_nonadecagon_num ( n ) : NEW_LINE INDENT return ( 19 * n * n - 19 * n + 2 ) \/\/ 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 2 NEW_LINE print ( n , \" nd ▁ centered ▁ nonadecagonal ▁ \" + \" number ▁ : ▁ \" , center_nonadecagon_num ( n ) ) NEW_LINE n = 7 NEW_LINE print ( n , \" nd ▁ centered ▁ nonadecagonal ▁ \" + \" number ▁ : ▁ \" , center_nonadecagon_num ( n ) ) NEW_LINE DEDENT"],"bleu":0.6885300130692275,"rouge_l":0.848695652173913}
{"id":1481,"predictions":["def countkDist ( st , k ) : NEW_LINE INDENT res = 0 NEW_LINE n = len ( st ) NEW_LINE cnt = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT dist_count = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if ( cnt [ ord ( st [ j ] ) - ord ( ' a ' ) ] == 0 ) : NEW_LINE INDENT dist_count += 1 NEW_LINE DEDENT cnt [ ord ( st [ j ] ) - ord ( ' a ' ) ] += 1 NEW_LINE if ( dist_count == k ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT ch = \" abcbaa \" NEW_LINE k = 3 NEW_LINE print ( \" Total ▁ substrings ▁ with ▁ x ▁ with ▁ \" + str ( k ) ) NEW_LINE"],"references":["def countkDist ( str1 , k ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE res = 0 NEW_LINE cnt = [ 0 ] * 27 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT dist_count = 0 NEW_LINE cnt = [ 0 ] * 27 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if ( cnt [ ord ( str1 [ j ] ) - 97 ] == 0 ) : NEW_LINE INDENT dist_count += 1 NEW_LINE DEDENT cnt [ ord ( str1 [ j ] ) - 97 ] += 1 NEW_LINE if ( dist_count == k ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT if ( dist_count > k ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" abcbaa \" NEW_LINE k = 3 NEW_LINE print ( \" Total ▁ substrings ▁ with ▁ exactly \" , k , \" distinct ▁ characters ▁ : ▁ \" , end = \" \" ) NEW_LINE print ( countkDist ( str1 , k ) ) NEW_LINE DEDENT"],"bleu":0.5367325475498248,"rouge_l":0.7144144144144143}
{"id":1482,"predictions":["def percent ( n , x ) : NEW_LINE INDENT p = n * x ; NEW_LINE p \/= 100 ; NEW_LINE return p ; NEW_LINE DEDENT def getLoss ( price , prices , X , n ) : NEW_LINE INDENT loss = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT originalPrice = price [ i ] ; NEW_LINE sellingPrice = originalPrice + percent ( originalPrice , X [ i ] ) ; NEW_LINE down -= percent ( sellingPrice , X [ i ] ) ; NEW_LINE loss += ( ( originalPrice - afterPlace ) * Profit [ i ] ) ; NEW_LINE DEDENT return loss ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT price = [ 20 , 48 , 200 , 100 ] ; NEW_LINE S = [ 20 , 48 , 1 , 1 ] ; NEW_LINE X = [ 0 , 48 , 200 , 5 ] ; NEW_LINE n = len ( X ) ; NEW_LINE print ( getLoss ( price , X , n ) ) ; NEW_LINE DEDENT"],"references":["def percent ( n , x ) : NEW_LINE INDENT p = ( int ) ( n ) * x ; NEW_LINE p \/= 100 ; NEW_LINE return p ; NEW_LINE DEDENT def getLoss ( price , quantity , X , n ) : NEW_LINE INDENT loss = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT originalPrice = price [ i ] ; NEW_LINE sellingPrice = originalPrice + percent ( originalPrice , X [ i ] ) ; NEW_LINE afterDiscount = sellingPrice - percent ( sellingPrice , X [ i ] ) ; NEW_LINE loss += ( ( originalPrice - afterDiscount ) * quantity [ i ] ) ; NEW_LINE DEDENT return round ( loss , 2 ) ; NEW_LINE DEDENT price = [ 20 , 48 , 200 , 100 ] ; NEW_LINE quantity = [ 20 , 48 , 1 , 1 ] ; NEW_LINE X = [ 0 , 48 , 200 , 5 ] ; NEW_LINE n = len ( X ) ; NEW_LINE print ( getLoss ( price , quantity , X , n ) ) ; NEW_LINE"],"bleu":0.8179746312243457,"rouge_l":0.8936170212765957}
{"id":1483,"predictions":["def minCost ( s ) : NEW_LINE INDENT alphabets = [ False ] * 26 ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT alphabets [ ord ( s [ i ] ) - ord ( ' a ' ) ] = True ; NEW_LINE DEDENT count = 0 ; NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( alphabets [ i ] ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT s = \" geeksforgeeks \" ; NEW_LINE print ( \" Total ▁ cost ▁ to ▁ construct \" , s , \" is \" , minCost ( s ) ) ; NEW_LINE"],"references":["def minCost ( s ) : NEW_LINE INDENT alphabets = [ False for i in range ( 26 ) ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT alphabets [ ord ( s [ i ] ) - 97 ] = True NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( alphabets [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" geeksforgeeks \" NEW_LINE print ( \" Total ▁ cost ▁ to ▁ construct \" , s , \" is \" , minCost ( s ) ) NEW_LINE DEDENT"],"bleu":0.7281002814734503,"rouge_l":0.8471112275645223}
{"id":1484,"predictions":["import math NEW_LINE def nextPowerOfFour ( n ) : NEW_LINE INDENT x = ( int ) ( math . floor ( math . sqrt ( n ) ) ) NEW_LINE if ( pow ( x , 4 ) == n ) : NEW_LINE INDENT return n NEW_LINE DEDENT else : NEW_LINE INDENT x = x + 1 NEW_LINE return pow ( x , 4 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 122 NEW_LINE print ( nextPowerOfFour ( n ) ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def nextPowerOfFour ( n ) : NEW_LINE INDENT x = math . floor ( ( n ** ( 1 \/ 2 ) ) ** ( 1 \/ 2 ) ) ; NEW_LINE if ( ( x ** 4 ) == n ) : NEW_LINE INDENT return n ; NEW_LINE DEDENT else : NEW_LINE INDENT x = x + 1 ; NEW_LINE return ( x ** 4 ) ; NEW_LINE DEDENT DEDENT n = 122 ; NEW_LINE print ( nextPowerOfFour ( n ) ) ; NEW_LINE"],"bleu":0.5092644036680608,"rouge_l":0.7627763682493656}
{"id":1485,"predictions":["def findCost ( s1 , s2 , a , b , c , d , n ) : NEW_LINE INDENT cost = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s1 [ i ] == s2 [ i ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT if ( ( s1 [ i ] == '1' and s2 [ i ] == '2' and s1 [ i ] == '2' ) ) : NEW_LINE INDENT cost += min ( d , min ( a , b + c ) ) NEW_LINE DEDENT elif ( ( s1 [ i ] == '2' and s2 [ i ] == '3' ) ) or ( s2 [ i ] == '3' and s1 [ i ] == '3' ) ) : NEW_LINE INDENT cost += min ( d , min ( b , a + c ) ) NEW_LINE DEDENT elif ( ( s1 [ i ] == '1' and s2 [ i ] == '3' ) or ( s2 [ i ] == '3' and s1 [ i ] == '3' ) : NEW_LINE INDENT cost += min ( d , min ( d , a + b ) ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s1 = \"223\" NEW_LINE s2 = \"223\" NEW_LINE a = 2 NEW_LINE b = 3 NEW_LINE c = 4 NEW_LINE n = len ( s1 ) NEW_LINE print ( findCost ( s1 , s2 , a , b , c , d , n ) ) NEW_LINE DEDENT"],"references":["def findCost ( s1 , s2 , a , b , c , d , n ) : NEW_LINE INDENT cost = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s1 [ i ] == s2 [ i ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT if ( ( s1 [ i ] == '1' and s2 [ i ] == '2' ) or ( s2 [ i ] == '1' and s1 [ i ] == '2' ) ) : NEW_LINE INDENT cost += min ( d , min ( a , b + c ) ) NEW_LINE DEDENT elif ( ( s1 [ i ] == '2' and s2 [ i ] == '3' ) or ( s2 [ i ] == '2' and s1 [ i ] == '3' ) ) : NEW_LINE INDENT cost += min ( d , min ( b , a + c ) ) NEW_LINE DEDENT elif ( ( s1 [ i ] == '1' and s2 [ i ] == '3' ) or ( s2 [ i ] == '1' and s1 [ i ] == '3' ) ) : NEW_LINE INDENT cost += min ( d , min ( c , a + b ) ) NEW_LINE DEDENT DEDENT DEDENT return cost NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s1 = \"121\" NEW_LINE s2 = \"223\" NEW_LINE a = 2 NEW_LINE b = 3 NEW_LINE c = 4 NEW_LINE d = 10 NEW_LINE n = len ( s1 ) NEW_LINE print ( findCost ( s1 , s2 , a , b , c , d , n ) ) NEW_LINE DEDENT"],"bleu":0.8771251319946636,"rouge_l":0.939607068123692}
{"id":1486,"predictions":["def FirstoneMatch ( arr , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT print ( 5 - arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT arr = [ 3 , 4 , 2 , 2 ] NEW_LINE N = len ( arr ) NEW_LINE FortyoneMatchstick ( arr , N ) NEW_LINE"],"references":["def TwentyoneMatchstick ( arr , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT print ( 5 - arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 3 , 4 , 2 , 2 ] NEW_LINE N = len ( arr ) NEW_LINE TwentyoneMatchstick ( arr , N ) NEW_LINE"],"bleu":0.8539253944388413,"rouge_l":0.9445554445554447}
{"id":1487,"predictions":["def Perimeter ( s , n ) : NEW_LINE INDENT perimeter = 1 NEW_LINE perimeter = n * s NEW_LINE return perimeter NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 NEW_LINE s = 2.5 NEW_LINE peri = Perimeter ( s , n ) NEW_LINE peri = Perimeter ( s , n ) NEW_LINE print ( \" Perimeter ▁ of ▁ Regular ▁ Binary ▁ of ▁ length ▁ with ▁ \" , n , \" ▁ = ▁ \" , * s , \" ▁ = ▁ \" , * peri ) NEW_LINE DEDENT"],"references":["def Perimeter ( s , n ) : NEW_LINE INDENT perimeter = 1 NEW_LINE perimeter = n * s NEW_LINE return perimeter NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE s = 2.5 NEW_LINE peri = Perimeter ( s , n ) NEW_LINE print ( \" Perimeter ▁ of ▁ Regular ▁ Polygon ▁ with \" , n , \" sides ▁ of ▁ length \" , s , \" = \" , peri ) NEW_LINE DEDENT"],"bleu":0.6687462505237985,"rouge_l":0.8671983356449375}
{"id":1488,"predictions":["def checkPalindrome ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE count = 0 NEW_LINE for i in range ( 0 , int ( n \/\/ 2 ) ) : NEW_LINE INDENT if ( str [ i ] != str [ n - i - 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return ( count <= 1 ) NEW_LINE DEDENT str = \" abccaa \" NEW_LINE if ( checkPalindrome ( str ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def checkPalindrome ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE count = 0 NEW_LINE for i in range ( 0 , int ( n \/ 2 ) ) : NEW_LINE INDENT if ( str [ i ] != str [ n - i - 1 ] ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT if ( count <= 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT str = \" abccaa \" NEW_LINE if ( checkPalindrome ( str ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.7809477623988662,"rouge_l":0.8912763214439191}
{"id":1489,"predictions":["def getSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT sum = sum + n % 10 NEW_LINE n = n \/\/ 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT def largestDigitSumdivisior ( n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT res = max ( res , getSum ( i ) ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT n = 14 NEW_LINE print ( largestDigitSumdivisior ( n ) ) NEW_LINE"],"references":["def getSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while n != 0 : NEW_LINE INDENT sum = sum + n % 10 NEW_LINE n = int ( n \/ 10 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT def largestDigitSumdivisior ( n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT res = max ( res , getSum ( i ) ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT n = 14 NEW_LINE print ( largestDigitSumdivisior ( n ) ) NEW_LINE"],"bleu":0.8722811418346215,"rouge_l":0.9585580033893082}
{"id":1490,"predictions":["def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def lcm ( n , m ) : NEW_LINE INDENT return ( n * m ) \/ gcd ( n , m ) NEW_LINE DEDENT n = 2 ; m = 3 ; k = 5 ; NEW_LINE print ( int ( k \/ lcm ( n , m ) ) ) NEW_LINE"],"references":["def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b ; NEW_LINE DEDENT return gcd ( b % a , a ) ; NEW_LINE DEDENT def lcm ( n , m ) : NEW_LINE INDENT return ( n * m ) \/\/ gcd ( n , m ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 2 ; m = 3 ; k = 5 ; NEW_LINE print ( k \/\/ lcm ( n , m ) ) ; NEW_LINE DEDENT"],"bleu":0.6910791875165537,"rouge_l":0.8554814434752863}
{"id":1491,"predictions":["def checkPrime ( number ) : NEW_LINE INDENT num = int ( number ) NEW_LINE i = 2 NEW_LINE while i * i <= num : NEW_LINE INDENT if ( num % i == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT def splitIntoPrimes ( number ) : NEW_LINE INDENT if ( len ( number ) == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( len ( number ) <= 6 and checkPrime ( number ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT numLen = len ( number ) NEW_LINE ans = 1000000 NEW_LINE for i in range ( 1 , 6 , numLen + 1 ) : NEW_LINE INDENT if ( checkPrime ( number [ 0 : i ] ) ) : NEW_LINE INDENT val = splitIntoPrimes ( number [ 0 : i ] ) NEW_LINE if ( val != - 1 ) : NEW_LINE INDENT ans = splitIntoPrimes ( number [ i : ] ) NEW_LINE if ( val != - 1 ) : NEW_LINE INDENT ans = min ( ans , 1 + val ) NEW_LINE DEDENT DEDENT DEDENT if ( ans == 1000000 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( splitIntoPrimes ( \"13499315\" ) ) NEW_LINE print ( splitIntoPrimes ( \"43\" ) ) NEW_LINE DEDENT"],"references":["def checkPrime ( number ) : NEW_LINE INDENT num = int ( number ) NEW_LINE for i in range ( 2 , int ( num ** 0.5 ) ) : NEW_LINE INDENT if ( ( num % i ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def splitIntoPrimes ( number ) : NEW_LINE INDENT if ( number == ' ' ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( len ( number ) <= 6 and checkPrime ( number ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT numLen = len ( number ) NEW_LINE ans = 1000000 NEW_LINE for i in range ( 1 , ( min ( 6 , numLen ) + 1 ) ) : NEW_LINE INDENT if ( checkPrime ( number [ : i ] ) ) : NEW_LINE INDENT val = splitIntoPrimes ( number [ i : ] ) NEW_LINE if ( val != - 1 ) : NEW_LINE INDENT ans = min ( ans , 1 + val ) NEW_LINE DEDENT DEDENT DEDENT if ( ans == 1000000 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT print ( splitIntoPrimes ( \"13499315\" ) ) NEW_LINE print ( splitIntoPrimes ( \"43\" ) ) NEW_LINE"],"bleu":0.7157342100604503,"rouge_l":0.8445618041678562}
{"id":1492,"predictions":["def findKthChar ( s , k ) : NEW_LINE INDENT l = len ( s ) NEW_LINE i = 0 NEW_LINE total_len = 0 NEW_LINE while ( i < l ) : NEW_LINE INDENT if ( s [ i ] == ' . ' ) : NEW_LINE INDENT total_len += 1 NEW_LINE if ( total_len == k ) : NEW_LINE INDENT return s [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT n = 0 NEW_LINE while ( i < l and not ( s [ i ] ) ) : NEW_LINE INDENT n = n * 10 + ( ord ( s [ i ] ) - ord ( '0' ) ) NEW_LINE i += 1 NEW_LINE DEDENT next_max_len = total_len * n NEW_LINE if ( k <= next_max_len ) : NEW_LINE INDENT pos = k % total_len NEW_LINE if ( pos == 0 ) : NEW_LINE INDENT pos = total_len NEW_LINE if ( pos == 0 ) : NEW_LINE INDENT pos = total_len NEW_LINE DEDENT return findKthChar ( s , pos ) NEW_LINE DEDENT else : NEW_LINE INDENT total_len = next_limit NEW_LINE DEDENT DEDENT DEDENT return ' ▁ ' . join ( findKthChar ( s , k ) ) NEW_LINE DEDENT s = \" ab2c3\" NEW_LINE k = 5 NEW_LINE print ( findKthChar ( s , k ) ) NEW_LINE"],"references":["def findKthChar ( s , k ) : NEW_LINE INDENT len1 = len ( s ) NEW_LINE i = 0 NEW_LINE total_len = 0 NEW_LINE while ( i < len1 ) : NEW_LINE INDENT if ( s [ i ] . isalpha ( ) ) : NEW_LINE INDENT total_len += 1 NEW_LINE if ( total_len == k ) : NEW_LINE INDENT return s [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT n = 0 NEW_LINE while ( i < len1 and s [ i ] . isalpha ( ) == False ) : NEW_LINE INDENT n = n * 10 + ( ord ( s [ i ] ) - ord ( '0' ) ) NEW_LINE i += 1 NEW_LINE DEDENT next_total_len = total_len * n NEW_LINE if ( k <= next_total_len ) : NEW_LINE INDENT pos = k % total_len NEW_LINE if ( pos == 0 ) : NEW_LINE INDENT pos = total_len NEW_LINE DEDENT return findKthChar ( s , pos ) NEW_LINE DEDENT else : NEW_LINE INDENT total_len = next_total_len NEW_LINE DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" ab2c3\" NEW_LINE k = 5 NEW_LINE print ( findKthChar ( s , k ) ) NEW_LINE DEDENT"],"bleu":0.7813879071061072,"rouge_l":0.8570062522986392}
{"id":1493,"predictions":["def Nth_Term ( n ) : NEW_LINE INDENT return ( 2 * pow ( n , 3 ) - 3 * pow ( n , 2 ) + n + 6 ) \/ 6 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 8 NEW_LINE print ( Nth_Term ( N ) ) NEW_LINE DEDENT"],"references":["def Nth_Term ( n ) : NEW_LINE INDENT return ( 2 * pow ( n , 3 ) - 3 * pow ( n , 2 ) + n + 6 ) \/\/ 6 NEW_LINE DEDENT N = 8 NEW_LINE print ( Nth_Term ( N ) ) NEW_LINE"],"bleu":0.7053238688722274,"rouge_l":0.8746186699206833}
{"id":1494,"predictions":["def solve ( A , B , C ) : NEW_LINE INDENT i = len ( A ) - 1 NEW_LINE j = len ( B ) - 1 NEW_LINE k = len ( C ) - 1 NEW_LINE min_diff = abs ( A [ i ] , C [ k ] ) - min ( B [ j ] , C [ k ] ) NEW_LINE while ( i != - 1 and j != - 1 and k != - 1 ) : NEW_LINE INDENT current_diff = abs ( max ( A [ i ] , max ( B [ j ] , C [ k ] ) ) - min ( A [ j ] , C [ k ] ) ) NEW_LINE if ( current_diff < min_diff ) : NEW_LINE INDENT min_diff = current_diff NEW_LINE DEDENT max_diff = max ( A [ i ] , max ( B [ j ] , C [ k ] ) ) NEW_LINE if ( not A [ i ] == max_term ) : NEW_LINE INDENT min_diff = current_diff NEW_LINE DEDENT max_term = max ( A [ i ] , max ( B [ j ] , C [ k ] ) ) NEW_LINE if ( A [ i ] == max_term ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT elif ( B [ j ] == max_term ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT DEDENT return min_diff NEW_LINE DEDENT D = [ 5 , 8 , 10 , 15 ] NEW_LINE E = [ 6 , 9 , 15 , 78 , 89 ] NEW_LINE F = [ 2 , 3 , 6 , 6 , 8 , 8 , 10 ] NEW_LINE print ( solve ( D , E , F ) ) NEW_LINE"],"references":["def solve ( A , B , C ) : NEW_LINE INDENT i = len ( A ) - 1 NEW_LINE j = len ( B ) - 1 NEW_LINE k = len ( C ) - 1 NEW_LINE min_diff = abs ( max ( A [ i ] , B [ j ] , C [ k ] ) - min ( A [ i ] , B [ j ] , C [ k ] ) ) NEW_LINE while i != - 1 and j != - 1 and k != - 1 : NEW_LINE INDENT current_diff = abs ( max ( A [ i ] , B [ j ] , C [ k ] ) - min ( A [ i ] , B [ j ] , C [ k ] ) ) NEW_LINE if current_diff < min_diff : NEW_LINE INDENT min_diff = current_diff NEW_LINE DEDENT max_term = max ( A [ i ] , B [ j ] , C [ k ] ) NEW_LINE if A [ i ] == max_term : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT elif B [ j ] == max_term : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT DEDENT return min_diff NEW_LINE DEDENT A = [ 5 , 8 , 10 , 15 ] NEW_LINE B = [ 6 , 9 , 15 , 78 , 89 ] NEW_LINE C = [ 2 , 3 , 6 , 6 , 8 , 8 , 10 ] NEW_LINE print ( solve ( A , B , C ) ) NEW_LINE"],"bleu":0.7533055957430249,"rouge_l":0.8701306141154903}
{"id":1495,"predictions":["_MIN = - 2147483648 NEW_LINE _MAX = 2147483648 NEW_LINE class newnode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def CheckPerfectTree ( root ) : NEW_LINE INDENT q = [ ] NEW_LINE q . append ( root ) NEW_LINE flag = 0 NEW_LINE while ( len ( q ) != 0 ) : NEW_LINE INDENT temp = q [ 0 ] NEW_LINE q . pop ( 0 ) NEW_LINE if ( temp . left and temp . right != None ) : NEW_LINE INDENT if ( flag == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE q . append ( temp . left ) NEW_LINE q . append ( temp . right ) NEW_LINE DEDENT DEDENT elif ( temp . left == None and temp . right == None ) : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT elif ( temp . left == None or temp . right == None ) : NEW_LINE INDENT return false NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newnode ( 7 ) NEW_LINE root . left = newnode ( 5 ) NEW_LINE root . left . left = newnode ( 6 ) NEW_LINE root . left . left = newnode ( 8 ) NEW_LINE root . left . left = newnode ( 8 ) NEW_LINE root . left . left = newnode ( 1 ) NEW_LINE root . left . right = newnode ( 3 ) NEW_LINE root . right . right = newnode ( 9 ) NEW_LINE root . right . right = newnode ( 13 ) NEW_LINE if ( CheckPerfectTree ( root ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["import sys NEW_LINE import math NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def newNode ( data ) : NEW_LINE INDENT return Node ( data ) NEW_LINE DEDENT def CheckPerfectTree ( root ) : NEW_LINE INDENT q = [ ] NEW_LINE q . append ( root ) NEW_LINE flag = 0 NEW_LINE while ( q ) : NEW_LINE INDENT temp = q [ 0 ] NEW_LINE q . pop ( 0 ) NEW_LINE if ( temp . left and temp . right ) : NEW_LINE INDENT if ( flag == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE q . append ( temp . right ) NEW_LINE DEDENT DEDENT elif ( not temp . left and not temp . right ) : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT elif ( not temp . left or not temp . right ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 7 ) NEW_LINE root . left = newNode ( 5 ) NEW_LINE root . left . left = newNode ( 8 ) NEW_LINE root . left . right = newNode ( 1 ) NEW_LINE root . right = newNode ( 6 ) NEW_LINE root . right . left = newNode ( 3 ) NEW_LINE root . right . right = newNode ( 9 ) NEW_LINE root . right . right . left = newNode ( 10 ) NEW_LINE root . right . right . right = newNode ( 13 ) NEW_LINE if CheckPerfectTree ( root ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.7425591081200513,"rouge_l":0.8470565225894778}
{"id":1496,"predictions":["def generateNumber ( count , a , n , num , k ) : NEW_LINE INDENT if ( count == k ) : NEW_LINE INDENT set . add ( num ) NEW_LINE return NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT generateNumber ( count + 1 , a , n , num + a [ i ] , k ) NEW_LINE DEDENT DEDENT def printDistinctIntegers ( k , a , n ) : NEW_LINE INDENT generateNumber ( 0 , a , n , 0 , k ) NEW_LINE print ( \" The ▁ \" , len ( set ) ) NEW_LINE print ( \" The ▁ \" , end = \" ▁ \" ) NEW_LINE print ( ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 8 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE printDistinctIntegers ( k , arr , n ) NEW_LINE DEDENT"],"references":["s = set ( ) NEW_LINE def generateNumber ( count , a , n , num , k ) : NEW_LINE INDENT if k == count : NEW_LINE INDENT s . add ( num ) NEW_LINE return NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT generateNumber ( count + 1 , a , n , num + a [ i ] , k ) NEW_LINE DEDENT DEDENT def printDistinctIntegers ( k , a , n ) : NEW_LINE INDENT generateNumber ( 0 , a , n , 0 , k ) NEW_LINE print ( \" The \" , len ( s ) , \" distinct ▁ integers ▁ are : \" ) NEW_LINE for i in sorted ( s ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 3 , 8 , 17 , 5 ] NEW_LINE n , k = len ( a ) , 2 NEW_LINE printDistinctIntegers ( k , a , n ) NEW_LINE DEDENT"],"bleu":0.7020383011693095,"rouge_l":0.8193864585224179}
{"id":1497,"predictions":["import math NEW_LINE def findMin ( a , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += math . log ( a [ i ] ) ; NEW_LINE DEDENT x = math . exp ( sum \/ n ) ; NEW_LINE return int ( x + 1 ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 3 , 2 , 1 , 4 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( findMin ( a , n ) ) ; NEW_LINE DEDENT"],"references":["import math as m NEW_LINE def findMin ( a , n ) : NEW_LINE INDENT _sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT _sum += m . log ( a [ i ] ) NEW_LINE DEDENT x = m . exp ( _sum \/ n ) NEW_LINE return int ( x + 1 ) NEW_LINE DEDENT a = [ 3 , 2 , 1 , 4 ] NEW_LINE n = len ( a ) NEW_LINE print ( findMin ( a , n ) ) NEW_LINE"],"bleu":0.5770732463632738,"rouge_l":0.8503153003650847}
{"id":1498,"predictions":["def printPaths ( input , R , C ) : NEW_LINE INDENT for i in range ( C ) : NEW_LINE INDENT dfs ( input , \" \" , 0 , i , R , C ) NEW_LINE print ( ) NEW_LINE DEDENT DEDENT def dfs ( input , res , i , j , R , C ) : NEW_LINE INDENT if ( i == R ) : NEW_LINE INDENT print ( res , end = \" ▁ \" ) NEW_LINE return NEW_LINE DEDENT res = res + str ( input [ i ] [ j ] NEW_LINE for k in range ( C ) : NEW_LINE INDENT dfs ( input , res , i + 1 , k , R , C ) NEW_LINE if ( i + 1 == R ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT input = [ ' a ' , ' b ' ] , [ ' d ' , ' e ' ] ] NEW_LINE R = len ( input ) NEW_LINE C = len ( input [ 0 ] ) NEW_LINE printPaths ( input , R , C ) NEW_LINE DEDENT"],"references":["def printPaths ( inputchar , R , C ) : NEW_LINE INDENT for i in range ( C ) : NEW_LINE INDENT dfs ( inputchar , \" \" , 0 , i , R , C ) ; NEW_LINE print ( ) NEW_LINE DEDENT DEDENT def dfs ( inputchar , res , i , j , R , C ) : NEW_LINE INDENT if ( i == R ) : NEW_LINE INDENT print ( res , end = \" ▁ \" ) ; NEW_LINE return ; NEW_LINE DEDENT res = res + inputchar [ i ] [ j ] ; NEW_LINE for k in range ( C ) : NEW_LINE INDENT dfs ( inputchar , res , i + 1 , k , R , C ) ; NEW_LINE if ( i + 1 == R ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT inputchar = [ [ ' a ' , ' b ' ] , [ ' d ' , ' e ' ] ] ; NEW_LINE R = len ( inputchar ) ; NEW_LINE C = len ( inputchar [ 0 ] ) ; NEW_LINE printPaths ( inputchar , R , C ) ; NEW_LINE DEDENT"],"bleu":0.7692499070692403,"rouge_l":0.9224413438303842}
{"id":1499,"predictions":["mod = 1000000007 NEW_LINE def power ( a , m1 ) : NEW_LINE INDENT if ( m1 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( m1 == 1 ) : NEW_LINE INDENT return a NEW_LINE DEDENT elif ( m1 == 2 ) : NEW_LINE INDENT return ( 1 << a * a * a ) % mod NEW_LINE DEDENT elif ( m1 % 2 == 1 ) : NEW_LINE INDENT return ( 1 << a * a * power ( m1 \/ 2 ) , 2 ) % mod ) NEW_LINE DEDENT else : NEW_LINE INDENT return power ( 1 , mod1 \/\/ 2 ) % mod NEW_LINE DEDENT DEDENT def factorial ( x ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , x + 1 ) : NEW_LINE INDENT ans = ( 1 * ans * i ) % mod NEW_LINE DEDENT return ans NEW_LINE DEDENT def inverse ( n , r ) : NEW_LINE INDENT if ( r > n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = factorial ( n ) NEW_LINE ans = ( 1. * ans * inverse ( factorial ( r ) ) % mod ) % mod NEW_LINE ans = ( 1. * ans * inverse ( factorial ( n - r ) ) % mod ) NEW_LINE return ans NEW_LINE DEDENT def number_of_sets ( n , a , b ) : NEW_LINE INDENT ans = power ( 2 , n ) NEW_LINE ans = ans - binomial ( n , a ) NEW_LINE if ( ans < 0 ) : NEW_LINE INDENT ans += mod NEW_LINE DEDENT ans = ans - binomial ( n , b ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE A = 1 NEW_LINE B = 3 NEW_LINE print ( number_of_sets ( N , A , B ) ) NEW_LINE DEDENT"],"references":["mod = 10 ** 9 + 7 NEW_LINE def power ( a , m1 ) : NEW_LINE INDENT if ( m1 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( m1 == 1 ) : NEW_LINE INDENT return a NEW_LINE DEDENT elif ( m1 == 2 ) : NEW_LINE INDENT return ( a * a ) % mod NEW_LINE DEDENT elif ( m1 & 1 ) : NEW_LINE INDENT return ( a * power ( power ( a , m1 \/\/ 2 ) , 2 ) ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT return power ( power ( a , m1 \/\/ 2 ) , 2 ) % mod NEW_LINE DEDENT DEDENT def factorial ( x ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , x + 1 ) : NEW_LINE INDENT ans = ( ans * i ) % mod NEW_LINE DEDENT return ans NEW_LINE DEDENT def inverse ( x ) : NEW_LINE INDENT return power ( x , mod - 2 ) NEW_LINE DEDENT def binomial ( n , r ) : NEW_LINE INDENT if ( r > n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = factorial ( n ) NEW_LINE ans = ( ans * inverse ( factorial ( r ) ) ) % mod NEW_LINE ans = ( ans * inverse ( factorial ( n - r ) ) ) % mod NEW_LINE return ans NEW_LINE DEDENT def number_of_sets ( n , a , b ) : NEW_LINE INDENT ans = power ( 2 , n ) NEW_LINE ans = ans - binomial ( n , a ) NEW_LINE if ( ans < 0 ) : NEW_LINE INDENT ans += mod NEW_LINE DEDENT ans = ans - binomial ( n , b ) NEW_LINE ans -= 1 NEW_LINE if ( ans < 0 ) : NEW_LINE INDENT ans += mod NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE A = 1 NEW_LINE B = 3 NEW_LINE print ( number_of_sets ( N , A , B ) ) NEW_LINE DEDENT"],"bleu":0.7824295066811334,"rouge_l":0.8742129499107226}
{"id":1500,"predictions":["n = 5 NEW_LINE a = 2 NEW_LINE print ( sumOfSeries ( a , n ) ) NEW_LINE"],"references":["from __future__ import division NEW_LINE def sumOfSeries ( a , num ) : NEW_LINE INDENT res = 0 NEW_LINE prev = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT prev *= ( a \/ i ) NEW_LINE res = res + prev NEW_LINE DEDENT return res NEW_LINE DEDENT n = 5 NEW_LINE a = 2 NEW_LINE print ( round ( sumOfSeries ( a , n ) , 4 ) ) NEW_LINE"],"bleu":0.030436881680612312,"rouge_l":0.3333333333333333}
{"id":1501,"predictions":["import sys NEW_LINE def countNum ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE maxm = - sys . maxsize NEW_LINE minm = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE if ( arr [ i ] < minm ) : NEW_LINE INDENT minm = arr [ i ] NEW_LINE DEDENT if ( arr [ i ] > maxm ) : NEW_LINE INDENT maxm = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( minm , maxm + 1 ) : NEW_LINE INDENT if i not in s . keys ( ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 5 , 8 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countNum ( arr , n ) ) NEW_LINE DEDENT"],"references":["def countNum ( arr , n ) : NEW_LINE INDENT s = dict ( ) NEW_LINE count , maxm , minm = 0 , - 10 ** 9 , 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s [ arr [ i ] ] = 1 NEW_LINE if ( arr [ i ] < minm ) : NEW_LINE INDENT minm = arr [ i ] NEW_LINE DEDENT if ( arr [ i ] > maxm ) : NEW_LINE INDENT maxm = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( minm , maxm + 1 ) : NEW_LINE INDENT if i not in s . keys ( ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 3 , 5 , 8 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countNum ( arr , n ) ) NEW_LINE"],"bleu":0.7651722299386413,"rouge_l":0.8580407023144454}
{"id":1502,"predictions":["MAX_CHAR = 256 NEW_LINE def isPresent ( s , q ) : NEW_LINE INDENT freq = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) ] += 1 NEW_LINE DEDENT for i in range ( len ( q ) ) : NEW_LINE INDENT freq [ ord ( q [ i ] ) ] -= 1 NEW_LINE if ( freq [ ord ( q [ i ] ) ] < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT s = \" abctd \" NEW_LINE q = \" cat \" NEW_LINE if ( isPresent ( s , q ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["MAX_CHAR = 256 NEW_LINE def isPresent ( s , q ) : NEW_LINE INDENT freq = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) ] += 1 NEW_LINE DEDENT for i in range ( 0 , len ( q ) ) : NEW_LINE INDENT freq [ ord ( q [ i ] ) ] -= 1 NEW_LINE if ( freq [ ord ( q [ i ] ) ] < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT s = \" abctd \" NEW_LINE q = \" cat \" NEW_LINE if ( isPresent ( s , q ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.9526773858827795,"rouge_l":0.9840883977900553}
{"id":1503,"predictions":["def area_of_circle ( m , n ) : NEW_LINE INDENT square_of_radius = ( m * n ) \/ 4 ; NEW_LINE area = ( 3.141 * area_of_radius ) ; NEW_LINE return area ; NEW_LINE DEDENT n = 10 ; NEW_LINE m = 30 ; NEW_LINE print ( area_of_circle ( m , n ) ) ; NEW_LINE"],"references":["def area_of_circle ( m , n ) : NEW_LINE INDENT square_of_radius = ( m * n ) \/ 4 NEW_LINE area = ( 3.141 * square_of_radius ) NEW_LINE return area NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE m = 30 NEW_LINE print ( area_of_circle ( m , n ) ) NEW_LINE DEDENT"],"bleu":0.583916571302458,"rouge_l":0.8069654427645789}
{"id":1504,"predictions":["def printTwoSetBitNums ( n ) : NEW_LINE INDENT x = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT y = 0 NEW_LINE while ( y < x ) : NEW_LINE INDENT y = 0 NEW_LINE while ( y < x ) : NEW_LINE INDENT print ( ( 1 << x ) + ( 1 << y ) , end = \" ▁ \" ) NEW_LINE n -= 1 NEW_LINE DEDENT x += 1 NEW_LINE DEDENT x += 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE printTwoSetBitNums ( n ) NEW_LINE DEDENT"],"references":["def printTwoSetBitNums ( n ) : NEW_LINE INDENT x = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT y = 0 NEW_LINE while ( y < x ) : NEW_LINE INDENT print ( ( 1 << x ) + ( 1 << y ) , end = \" ▁ \" ) NEW_LINE n -= 1 NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT y += 1 NEW_LINE DEDENT x += 1 NEW_LINE DEDENT DEDENT printTwoSetBitNums ( 4 ) NEW_LINE"],"bleu":0.6871054082741835,"rouge_l":0.770148737461086}
{"id":1505,"predictions":["def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ [ 0 for x in range ( k + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) ; NEW_LINE DEDENT DEDENT DEDENT return C [ n ] [ k ] ; NEW_LINE DEDENT def findMax ( n ) : NEW_LINE INDENT return binomialCoeff ( n , int ( n \/ 2 ) ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 ; NEW_LINE print ( findMax ( n ) ) ; NEW_LINE DEDENT"],"references":["def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ [ 0 for i in range ( k + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return C [ n ] [ k ] NEW_LINE DEDENT def findMax ( n ) : NEW_LINE INDENT return binomialCoeff ( n , n \/\/ 2 ) NEW_LINE DEDENT n = 5 NEW_LINE print ( findMax ( n ) ) NEW_LINE"],"bleu":0.7675713701987997,"rouge_l":0.9252682204957455}
{"id":1506,"predictions":["def calculateSum ( arr , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT s = arr [ 0 ] NEW_LINE value = int ( s ) NEW_LINE sum = value NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT s = arr [ i ] NEW_LINE value = int ( s ) NEW_LINE if ( value == ' + ' ) : NEW_LINE INDENT sum += value NEW_LINE DEDENT else : NEW_LINE INDENT sum -= value NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ \"3\" , \" + \" , \"4\" , \" - \" , \" - \" , \" 7\" , \"7\" , \" + \" , \"13\" ] NEW_LINE n = len ( arr ) NEW_LINE print ( calculateSum ( arr , n ) ) NEW_LINE DEDENT"],"references":["def calculateSum ( arr , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT s = arr [ 0 ] NEW_LINE value = int ( s ) NEW_LINE sum = value NEW_LINE for i in range ( 2 , n , 2 ) : NEW_LINE INDENT s = arr [ i ] NEW_LINE value = int ( s ) NEW_LINE operation = arr [ i - 1 ] [ 0 ] NEW_LINE if ( operation == ' + ' ) : NEW_LINE INDENT sum += value NEW_LINE DEDENT else : NEW_LINE INDENT sum -= value NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT arr = [ \"3\" , \" + \" , \"4\" , \" - \" , \"7\" , \" + \" , \"13\" ] NEW_LINE n = len ( arr ) NEW_LINE print ( calculateSum ( arr , n ) ) NEW_LINE"],"bleu":0.8269037591308158,"rouge_l":0.8846194559119298}
{"id":1507,"predictions":["def checkplussmall ( x ) : NEW_LINE INDENT temp = x NEW_LINE n = 0 NEW_LINE while ( x ) : NEW_LINE INDENT x = x \/\/ 10 NEW_LINE n += 1 NEW_LINE DEDENT x = temp NEW_LINE sum = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT sum += pow ( x % 10 , n ) NEW_LINE x = int ( x \/ 10 ) NEW_LINE DEDENT return ( sum == temp ) NEW_LINE DEDENT x = 9474 NEW_LINE if ( checkplus ( x ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def checkplusperfect ( x ) : NEW_LINE INDENT temp = x NEW_LINE n = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT x = x \/\/ 10 NEW_LINE n = n + 1 NEW_LINE DEDENT x = temp NEW_LINE sm = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT sm = sm + ( int ) ( math . pow ( x % 10 , n ) ) NEW_LINE x = x \/\/ 10 NEW_LINE DEDENT return ( sm == temp ) NEW_LINE DEDENT x = 9474 NEW_LINE if ( checkplusperfect ( x ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.6995233570200092,"rouge_l":0.8465373214766909}
{"id":1508,"predictions":["def isPossible ( arr , p , n , m ) : NEW_LINE INDENT _sum = 0 NEW_LINE for i in range ( 0 , p ) : NEW_LINE INDENT _sum += arr [ i ] NEW_LINE DEDENT if ( _sum == ( n * m ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT n = 3 NEW_LINE m = 4 NEW_LINE arr = [ 6 , 3 , 2 , 1 ] NEW_LINE p = len ( arr ) NEW_LINE if ( isPossible ( arr , p , n , m ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def isPossible ( arr , p , n , m ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( p ) : NEW_LINE INDENT sum += arr [ i ] ; NEW_LINE DEDENT if ( sum == ( n * m ) ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 ; NEW_LINE m = 4 ; NEW_LINE arr = [ 6 , 3 , 2 , 1 ] ; NEW_LINE p = len ( arr ) ; NEW_LINE if ( isPossible ( arr , p , n , m ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"],"bleu":0.6407706110499038,"rouge_l":0.8667719213019189}
{"id":1509,"predictions":["def reverse ( n ) : NEW_LINE INDENT d = 0 ; NEW_LINE s = 0 ; NEW_LINE while ( n ) : NEW_LINE INDENT d = n % 10 ; NEW_LINE s = s * 10 + d ; NEW_LINE n = n \/\/ 10 ; NEW_LINE DEDENT return s ; NEW_LINE DEDENT def isPalin ( n ) : NEW_LINE INDENT s = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > 10 ) and isPalin ( arr [ i ] ) ) : NEW_LINE INDENT s += arr [ i ] ; NEW_LINE DEDENT DEDENT return s ; NEW_LINE DEDENT n = 6 ; NEW_LINE arr = [ 12 , 313 , 11 , 44 , 9 , 1 ] ; NEW_LINE print ( sumOfArray ( arr , n ) ) ; NEW_LINE"],"references":["def reverse ( n ) : NEW_LINE INDENT d = 0 ; s = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT d = n % 10 ; NEW_LINE s = s * 10 + d ; NEW_LINE n = n \/\/ 10 ; NEW_LINE DEDENT return s ; NEW_LINE DEDENT def isPalin ( n ) : NEW_LINE INDENT return n == reverse ( n ) ; NEW_LINE DEDENT def sumOfArray ( arr , n ) : NEW_LINE INDENT s = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( arr [ i ] > 10 ) and isPalin ( arr [ i ] ) ) : NEW_LINE INDENT s += arr [ i ] ; NEW_LINE DEDENT DEDENT return s ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 6 ; NEW_LINE arr = [ 12 , 313 , 11 , 44 , 9 , 1 ] ; NEW_LINE print ( sumOfArray ( arr , n ) ) ; NEW_LINE DEDENT"],"bleu":0.7554401887598928,"rouge_l":0.8669868653205253}
{"id":1510,"predictions":["def minCost ( arr , n ) : NEW_LINE INDENT count_even = 0 NEW_LINE count_odd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT count_even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_odd += 1 NEW_LINE DEDENT DEDENT return min ( count_even , count_odd ) NEW_LINE DEDENT arr = [ 2 , 4 , 3 , 1 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minCost ( arr , n ) ) NEW_LINE"],"references":["def minCost ( arr , n ) : NEW_LINE INDENT count_even = 0 NEW_LINE count_odd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT count_even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_odd += 1 NEW_LINE DEDENT DEDENT return min ( count_even , count_odd ) NEW_LINE DEDENT arr = [ 2 , 4 , 3 , 1 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minCost ( arr , n ) ) NEW_LINE"],"bleu":1.0,"rouge_l":1.0}
{"id":1511,"predictions":["def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return gcd ( a - b , b ) NEW_LINE DEDENT return gcd ( a , b - a ) NEW_LINE DEDENT def numOfPairs ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( coprime ( arr [ i ] , arr [ j ] ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 1 , 2 , 5 , 4 , 8 , 3 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE print ( numOfPairs ( arr , n ) ) NEW_LINE"],"references":["def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return gcd ( a - b , b ) NEW_LINE DEDENT return gcd ( a , b - a ) NEW_LINE DEDENT def coprime ( a , b ) : NEW_LINE INDENT return ( gcd ( a , b ) == 1 ) NEW_LINE DEDENT def numOfPairs ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( coprime ( arr [ i ] , arr [ j ] ) ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 1 , 2 , 5 , 4 , 8 , 3 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE print ( numOfPairs ( arr , n ) ) NEW_LINE"],"bleu":0.8260104978226489,"rouge_l":0.9060702326779427}
{"id":1512,"predictions":["def countSubarrays ( a , n , m ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT odd = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if ( a [ j ] % 2 == 0 ) : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT if ( odd == m ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 2 , 2 , 5 , 6 , 9 , 2 , 11 ] NEW_LINE n = len ( a ) NEW_LINE m = 2 NEW_LINE print ( countSubarrays ( a , n , m ) ) NEW_LINE DEDENT"],"references":["def countSubarrays ( a , n , m ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT odd = 0 ; NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if ( a [ j ] % 2 ) : NEW_LINE INDENT odd += 1 ; NEW_LINE DEDENT if ( odd == m ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT a = [ 2 , 2 , 5 , 6 , 9 , 2 , 11 ] ; NEW_LINE n = len ( a ) ; NEW_LINE m = 2 ; NEW_LINE print ( countSubarrays ( a , n , m ) ) ; NEW_LINE"],"bleu":0.7621766566849454,"rouge_l":0.9099950273495775}
{"id":1513,"predictions":["from math import ceil , floor NEW_LINE def divide ( n , m ) : NEW_LINE INDENT print ( \" Remainder ▁ = ▁ \" , ( n & ( m - 1 ) ) ) NEW_LINE print ( \" Value ▁ = ▁ \" , int ( n >= 2 ) ) NEW_LINE DEDENT n = 43 NEW_LINE divide ( n , m ) NEW_LINE"],"references":["import math NEW_LINE def divide ( n , m ) : NEW_LINE INDENT print ( \" Remainder ▁ = ▁ \" , ( ( n ) & ( m - 1 ) ) ) NEW_LINE print ( \" Quotient ▁ = ▁ \" , ( n >> ( int ) ( math . log2 ( m ) ) ) ) NEW_LINE DEDENT n = 43 NEW_LINE m = 8 NEW_LINE divide ( n , m ) NEW_LINE"],"bleu":0.6365956105298808,"rouge_l":0.7862957937584804}
{"id":1514,"predictions":["from collections import defaultdict NEW_LINE maxlen = 100 NEW_LINE def generateSubStrings ( s , mpp ) : NEW_LINE INDENT l = len ( s ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT temp = \" \" NEW_LINE for j in range ( i , l ) : NEW_LINE INDENT temp += s [ j ] NEW_LINE if temp in temp . keys ( temp ) : NEW_LINE INDENT x = mpp [ temp ] NEW_LINE DEDENT else : NEW_LINE INDENT mpp [ temp ] [ x ] = 1 NEW_LINE DEDENT DEDENT DEDENT def binomialCoeff ( C ) : NEW_LINE INDENT for i in range ( 1 , 100 ) : NEW_LINE INDENT for j in range ( 100 ) : NEW_LINE INDENT if j == 0 or j == i : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT def answerQuery ( mpp , Cpp ) : NEW_LINE INDENT ans = 0 NEW_LINE for key , value in mpp . items ( ) : NEW_LINE INDENT if ( value >= k ) : NEW_LINE INDENT ans += C [ value ] [ k ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT s = \" aabaab \" NEW_LINE mpp = [ [ 0 for _ in range ( maxlen ) ] for _ in range ( maxlen ) ] NEW_LINE generateSubStrings ( s , mpp ) NEW_LINE queries = [ 2 , 3 , 4 ] NEW_LINE q = len ( queries ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT print ( answerQuery ( mpp , C , queries [ i ] ) ) NEW_LINE DEDENT"],"references":["from collections import defaultdict NEW_LINE maxlen = 100 NEW_LINE def generateSubStrings ( s , mpp ) : NEW_LINE INDENT l = len ( s ) NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT temp = \" \" NEW_LINE for j in range ( i , l ) : NEW_LINE INDENT temp += s [ j ] NEW_LINE mpp [ temp ] += 1 NEW_LINE DEDENT DEDENT DEDENT def binomialCoeff ( C ) : NEW_LINE INDENT for i in range ( 0 , 100 ) : NEW_LINE INDENT for j in range ( 0 , 100 ) : NEW_LINE INDENT if j == 0 or j == i : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT def answerQuery ( mpp , C , k ) : NEW_LINE INDENT ans = 0 NEW_LINE for it in mpp : NEW_LINE INDENT if mpp [ it ] >= k : NEW_LINE INDENT ans += C [ mpp [ it ] ] [ k ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" aabaab \" NEW_LINE mpp = defaultdict ( lambda : 0 ) NEW_LINE generateSubStrings ( s , mpp ) NEW_LINE C = [ [ 0 for i in range ( maxlen ) ] for j in range ( maxlen ) ] NEW_LINE binomialCoeff ( C ) NEW_LINE queries = [ 2 , 3 , 4 ] NEW_LINE q = len ( queries ) NEW_LINE for i in range ( 0 , q ) : NEW_LINE INDENT print ( answerQuery ( mpp , C , queries [ i ] ) ) NEW_LINE DEDENT DEDENT"],"bleu":0.7894015216253374,"rouge_l":0.8407779876461279}
{"id":1515,"predictions":["def findProduct ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE prod = 1 * arr [ 0 ] NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] != arr [ i + 1 ] ) : NEW_LINE INDENT prod = prod * arr [ i + 1 ] NEW_LINE DEDENT DEDENT return prod NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 1 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findProduct ( arr , n ) ) NEW_LINE DEDENT"],"references":["def findProduct ( arr , n ) : NEW_LINE INDENT sorted ( arr ) NEW_LINE prod = 1 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( arr [ i - 1 ] != arr [ i ] ) : NEW_LINE INDENT prod = prod * arr [ i ] NEW_LINE DEDENT DEDENT return prod ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 1 , 1 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findProduct ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.7707098948417628,"rouge_l":0.898788212613605}
{"id":1516,"predictions":["def SieveOfSundaram ( n ) : NEW_LINE INDENT nNew = int ( ( n - 2 ) \/ 2 ) NEW_LINE marked = [ False for i in range ( nNew + 1 ) ] NEW_LINE for i in range ( 1 , nNew + 1 ) : NEW_LINE INDENT j = i NEW_LINE while ( ( i + j + 2 * i * j ) <= nNew ) : NEW_LINE INDENT marked [ i + j + 2 * i * j ] = True NEW_LINE j += 1 NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT print ( 2 , end = \" ▁ \" ) NEW_LINE DEDENT for i in range ( 1 , nNew + 1 ) : NEW_LINE INDENT if ( marked [ i ] == False ) : NEW_LINE INDENT print ( 2 * i + 1 , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT n = 25 NEW_LINE SieveOfSundaram ( n ) NEW_LINE"],"references":["def SieveOfSundaram ( n ) : NEW_LINE INDENT nNew = int ( ( n - 2 ) \/ 2 ) ; NEW_LINE marked = [ 0 ] * ( nNew + 1 ) ; NEW_LINE for i in range ( 1 , nNew + 1 ) : NEW_LINE INDENT j = i ; NEW_LINE while ( ( i + j + 2 * i * j ) <= nNew ) : NEW_LINE INDENT marked [ i + j + 2 * i * j ] = 1 ; NEW_LINE j += 1 ; NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT print ( 2 , end = \" ▁ \" ) ; NEW_LINE DEDENT for i in range ( 1 , nNew + 1 ) : NEW_LINE INDENT if ( marked [ i ] == 0 ) : NEW_LINE INDENT print ( ( 2 * i + 1 ) , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT DEDENT n = 20 ; NEW_LINE SieveOfSundaram ( n ) ; NEW_LINE"],"bleu":0.7892710711826735,"rouge_l":0.911902971041745}
{"id":1517,"predictions":["def solve ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT num = 2 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT num = ( num * 10 ) + 3 NEW_LINE DEDENT print ( num ) NEW_LINE DEDENT DEDENT n = 4 NEW_LINE solve ( n ) NEW_LINE"],"references":["def solve ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT print ( - 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT num = 2 ; NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT num = ( num * 10 ) + 3 ; NEW_LINE DEDENT print ( num ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 ; NEW_LINE solve ( n ) ; NEW_LINE DEDENT"],"bleu":0.6308276655470929,"rouge_l":0.8490492060380317}
{"id":1518,"predictions":["def minimumOperations ( arr , n ) : NEW_LINE INDENT brr = [ 0 ] * 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT brr [ arr [ i ] % 4 ] += 1 NEW_LINE DEDENT if ( ( brr [ 1 ] + 2 * brr [ 2 ] + 3 * brr [ 3 ] ) % 4 == 0 ) % 4 : NEW_LINE INDENT min_op = min ( brr [ 3 ] , brr [ 1 ] ) NEW_LINE brr [ 3 ] -= min_op NEW_LINE brr [ 2 ] -= min_op NEW_LINE min_opr += brr [ 2 ] \/\/ 2 NEW_LINE DEDENT if ( brr [ 1 ] == 1 ) : NEW_LINE INDENT min_opr += 2 NEW_LINE brr [ 2 ] = 0 NEW_LINE if ( brr [ 3 ] == 1 ) : NEW_LINE INDENT brr [ -= 2 ] -= 2 NEW_LINE DEDENT if ( brr [ 1 ] == 1 ) : NEW_LINE INDENT brr [ 1 ] -= 2 NEW_LINE DEDENT DEDENT if ( brr [ 1 ] == 1 ) : NEW_LINE INDENT min_op += ( brr [ 1 ] \/\/ 4 ) * 3 NEW_LINE DEDENT if ( brr [ 3 ] == 1 ) : NEW_LINE INDENT min_op += ( brr [ 1 ] \/\/ 4 ) * 3 NEW_LINE DEDENT return min_opr NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 1 , 2 , 3 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minimumOperations ( arr , n ) ) NEW_LINE DEDENT"],"references":["def minimumOperations ( arr , n ) : NEW_LINE INDENT brr = [ 0 , 0 , 0 , 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT brr [ arr [ i ] % 4 ] += 1 ; NEW_LINE DEDENT if ( ( brr [ 1 ] + 2 * brr [ 2 ] + 3 * brr [ 3 ] ) % 4 == 0 ) : NEW_LINE INDENT min_opr = min ( brr [ 3 ] , brr [ 1 ] ) NEW_LINE brr [ 3 ] -= min_opr NEW_LINE brr [ 1 ] -= min_opr NEW_LINE min_opr += brr [ 2 ] \/\/ 2 NEW_LINE brr [ 2 ] %= 2 NEW_LINE if ( brr [ 2 ] ) : NEW_LINE INDENT min_opr += 2 NEW_LINE brr [ 2 ] = 0 NEW_LINE if ( brr [ 3 ] ) : NEW_LINE INDENT brr [ 3 ] -= 2 NEW_LINE DEDENT if ( brr [ 1 ] ) : NEW_LINE INDENT brr [ 1 ] -= 2 NEW_LINE DEDENT DEDENT if ( brr [ 1 ] ) : NEW_LINE INDENT min_opr += ( brr [ 1 ] \/\/ 4 ) * 3 NEW_LINE DEDENT if ( brr [ 3 ] ) : NEW_LINE INDENT min_opr += ( brr [ 3 ] \/\/ 4 ) * 3 NEW_LINE DEDENT return min_opr NEW_LINE DEDENT return - 1 NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 1 , 2 , 3 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minimumOperations ( arr , n ) ) NEW_LINE"],"bleu":0.7771385883756103,"rouge_l":0.8856360823515411}
{"id":1519,"predictions":["import sys NEW_LINE def minFn ( arr ) : NEW_LINE INDENT min = sys . maxsize ; NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT if ( min > arr [ i ] ) : NEW_LINE INDENT min = sys . maxsize ; NEW_LINE DEDENT DEDENT return min ; NEW_LINE DEDENT def minimizeGraph ( arr ) : NEW_LINE INDENT for i in range ( len ( arr ) ) : NEW_LINE INDENT if ( arr [ i ] [ j ] == 0 ) : NEW_LINE INDENT arr [ i ] [ j ] = sys . maxsize ; NEW_LINE DEDENT DEDENT for i in range ( len ( arr ) ) : NEW_LINE INDENT min = minFn ( arr [ i ] ) ; NEW_LINE for j in range ( len ( arr ) ) : NEW_LINE INDENT if ( ( arr [ i ] [ j ] != min ) or ( arr [ i ] [ j ] == 10 ** 9 ) ) : NEW_LINE INDENT arr [ i ] [ j ] = 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT min = 0 ; NEW_LINE DEDENT DEDENT DEDENT for i in range ( len ( arr ) ) : NEW_LINE INDENT for j in range ( len ( arr ) ) : NEW_LINE INDENT print ( arr [ i ] [ j ] , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ [ 1 , 2 , 4 , 0 ] , [ 0 , 0 , 0 , 5 ] , [ 0 , 2 , 0 , 3 ] , [ 0 , 0 , 0 ] ] ; NEW_LINE minimizeGraph ( arr ) ; NEW_LINE DEDENT"],"references":["def minFn ( arr ) : NEW_LINE INDENT minimum = float ( ' inf ' ) NEW_LINE for i in range ( 0 , 4 ) : NEW_LINE INDENT if minimum > arr [ i ] : NEW_LINE INDENT minimum = arr [ i ] NEW_LINE DEDENT DEDENT return minimum NEW_LINE DEDENT def minimizeGraph ( arr ) : NEW_LINE INDENT for i in range ( 0 , 4 ) : NEW_LINE INDENT for j in range ( 0 , 4 ) : NEW_LINE INDENT if arr [ i ] [ j ] == 0 : NEW_LINE INDENT arr [ i ] [ j ] = float ( ' inf ' ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( 0 , 4 ) : NEW_LINE INDENT minimum = minFn ( arr [ i ] ) NEW_LINE for j in range ( 0 , 4 ) : NEW_LINE INDENT if ( ( not ( arr [ i ] [ j ] == minimum ) ) or ( arr [ i ] [ j ] == float ( ' inf ' ) ) ) : NEW_LINE INDENT arr [ i ] [ j ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT minimum = 0 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 0 , 4 ) : NEW_LINE INDENT for j in range ( 0 , 4 ) : NEW_LINE INDENT print ( arr [ i ] [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ [ 1 , 2 , 4 , 0 ] , [ 0 , 0 , 0 , 5 ] , [ 0 , 2 , 0 , 3 ] , [ 0 , 0 , 0 , 0 ] ] NEW_LINE minimizeGraph ( arr ) NEW_LINE DEDENT"],"bleu":0.673660889903839,"rouge_l":0.8003512578129036}
{"id":1520,"predictions":["def getNumToAdd ( arr , n ) : NEW_LINE INDENT arr . sort ( reverse = arr [ 1 ] - arr [ 0 ] NEW_LINE numToAdded = - 1 NEW_LINE numToAdded = False NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT diff = arr [ i ] - arr [ i - 1 ] NEW_LINE if ( diff != d ) : NEW_LINE INDENT if ( numAdded ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( diff == 2 * d ) : NEW_LINE INDENT numToAdded = arr [ i ] - d NEW_LINE numAdded = True NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT DEDENT if ( numToAdded == - 1 ) : NEW_LINE INDENT return ( arr [ n - 1 ] + d ) NEW_LINE DEDENT return numToAdded NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 3 , 5 , 7 , 11 , 13 , 15 ] NEW_LINE n = len ( arr ) NEW_LINE print ( getNumToAdd ( arr , n ) ) NEW_LINE DEDENT"],"references":["def getNumToAdd ( arr , n ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE d = arr [ 1 ] - arr [ 0 ] NEW_LINE numToAdd = - 1 NEW_LINE numAdded = False NEW_LINE for i in range ( 2 , n , 1 ) : NEW_LINE INDENT diff = arr [ i ] - arr [ i - 1 ] NEW_LINE if ( diff != d ) : NEW_LINE INDENT if ( numAdded ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( diff == 2 * d ) : NEW_LINE INDENT numToAdd = arr [ i ] - d NEW_LINE numAdded = True NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT DEDENT if ( numToAdd == - 1 ) : NEW_LINE INDENT return ( arr [ n - 1 ] + d ) NEW_LINE DEDENT return numToAdd NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 3 , 5 , 7 , 11 , 13 , 15 ] NEW_LINE n = len ( arr ) NEW_LINE print ( getNumToAdd ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.8900115925255304,"rouge_l":0.9539136190633791}
{"id":1521,"predictions":["PI = 3.1415926535 NEW_LINE def findAnglesA ( a , b , c ) : NEW_LINE INDENT A = acos ( ( b * b + c * c - a * b ) \/ ( 2 * b * c ) ) ; NEW_LINE return A * 180 \/ PI ; NEW_LINE DEDENT def findAnglesB ( a , b , c ) : NEW_LINE INDENT B = acos ( ( a * a + c * c - b * b ) \/ ( 2 * a * c ) ) ; NEW_LINE return B * 180 \/ PI ; NEW_LINE DEDENT def printAngles ( a , b , c ) : NEW_LINE INDENT x = a ; NEW_LINE y = b ; NEW_LINE z = c ; NEW_LINE A = findAnglesA ( x , y , z ) ; NEW_LINE B = findAnglesB ( x , y , z ) ; NEW_LINE print ( \" Angles ▁ are ▁ A ▁ = ▁ \" , A , \" , ▁ B ▁ = ▁ \" , B , \" , ▁ C ▁ = ▁ \" , 90 ) ; NEW_LINE print ( \" Angles ▁ are ▁ A ▁ = ▁ \" , B , \" , ▁ C ▁ = ▁ \" , 90 ) ; NEW_LINE DEDENT def printAngles ( n ) : NEW_LINE INDENT b = 0 ; NEW_LINE c = 0 ; NEW_LINE if ( n == 1 ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT print ( - 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT b = ( c + 1 ) \/ 2 ; NEW_LINE c = ( n * ( n + 1 ) \/ 2 ) ; NEW_LINE print ( - 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT b = 0 ; NEW_LINE c = 0 ; NEW_LINE if ( n == 2 ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT print ( - 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT b = ( ( n * n + 1 ) \/ 2 ; NEW_LINE c = ( n * n + 1"],"references":["import math NEW_LINE PI = 3.1415926535 NEW_LINE def findAnglesA ( a , b , c ) : NEW_LINE INDENT A = math . acos ( ( b * b + c * c - a * a ) \/ ( 2 * b * c ) ) NEW_LINE return A * 180 \/ PI NEW_LINE DEDENT def findAnglesB ( a , b , c ) : NEW_LINE INDENT B = math . acos ( ( a * a + c * c - b * b ) \/ ( 2 * a * c ) ) NEW_LINE return B * 180 \/ PI NEW_LINE DEDENT def printAngles ( a , b , c ) : NEW_LINE INDENT x = a NEW_LINE y = b NEW_LINE z = c NEW_LINE A = findAnglesA ( x , y , z ) NEW_LINE B = findAnglesB ( x , y , z ) NEW_LINE print ( \" Angles ▁ are ▁ A ▁ = ▁ \" , A , \" , ▁ B ▁ = ▁ \" , B , \" , ▁ C ▁ = ▁ \" , \"90 ▁ \" ) NEW_LINE DEDENT def printOtherSides ( n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT else : NEW_LINE INDENT b = ( n * n - 1 ) \/\/ 2 NEW_LINE c = ( n * n + 1 ) \/\/ 2 NEW_LINE print ( \" Side ▁ b ▁ = ▁ \" , b , \" ▁ Side ▁ c ▁ = ▁ \" , c ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( n == 2 ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT else : NEW_LINE INDENT b = n * n \/\/ 4 - 1 ; NEW_LINE c = n * n \/\/ 4 + 1 ; NEW_LINE print ( \" Side ▁ b ▁ = ▁ \" , b , \" , ▁ Side ▁ c ▁ = ▁ \" , c ) NEW_LINE DEDENT DEDENT printAngles ( n , b , c ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 12 NEW_LINE printOtherSides ( a ) NEW_LINE DEDENT"],"bleu":0.6353067277607061,"rouge_l":0.7277799236084289}
{"id":1522,"predictions":["import math NEW_LINE def MaximumHeight ( a , n ) : NEW_LINE INDENT return math . floor ( - 1 + math . sqrt ( 1 + ( 8 * n ) ) ) \/\/ 2 NEW_LINE DEDENT arr = [ 40 , 100 , 20 , 30 ] NEW_LINE n = len ( arr ) NEW_LINE print ( MaximumHeight ( arr , n ) ) NEW_LINE"],"references":["import math NEW_LINE def MaximumHeight ( a , n ) : NEW_LINE INDENT return ( - 1 + int ( math . sqrt ( 1 + ( 8 * n ) ) ) ) \/\/ 2 NEW_LINE DEDENT arr = [ 40 , 100 , 20 , 30 ] NEW_LINE n = len ( arr ) NEW_LINE print ( MaximumHeight ( arr , n ) ) NEW_LINE"],"bleu":0.9085022752675349,"rouge_l":0.9552238805970149}
{"id":1523,"predictions":["def firstElement ( arr , n , k ) : NEW_LINE INDENT count_map = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT a = 0 NEW_LINE if ( arr [ i ] in count_map . keys ( ) ) : NEW_LINE INDENT a = count_map [ arr [ i ] ] NEW_LINE DEDENT count_map [ arr [ i ] ] = 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( count_map [ arr [ i ] ] == k ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 1 , 7 , 4 , 3 , 4 , 8 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE print ( firstElement ( arr , n , k ) ) NEW_LINE"],"references":["def firstElement ( arr , n , k ) : NEW_LINE INDENT count_map = { } ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] in count_map . keys ( ) ) : NEW_LINE INDENT count_map [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_map [ arr [ i ] ] = 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( count_map [ arr [ i ] ] == k ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 7 , 4 , 3 , 4 , 8 , 7 ] ; NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE print ( firstElement ( arr , n , k ) ) NEW_LINE DEDENT"],"bleu":0.6922556327828662,"rouge_l":0.8539515488482924}
{"id":1524,"predictions":["def calculate ( a , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT r = i + 1 NEW_LINE for j in range ( r , n ) : NEW_LINE INDENT if ( a [ i ] == a [ j ] ) : NEW_LINE INDENT r += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT d = r - i NEW_LINE ans += ( d * ( d + 1 ) \/ 2 ) NEW_LINE i = r - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT a = [ 2 , 4 , 5 , 3 , 3 , 3 ] NEW_LINE print ( calculate ( a , len ( a ) ) ) NEW_LINE"],"references":["def calculate ( a , n ) : NEW_LINE INDENT ans = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT r = i + 1 ; NEW_LINE for j in range ( r , n ) : NEW_LINE INDENT if ( a [ i ] == a [ j ] ) : NEW_LINE INDENT r = r + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT d = r - i ; NEW_LINE ans = ans + ( d * ( d + 1 ) \/ 2 ) ; NEW_LINE i = r - 1 ; NEW_LINE i = i + 1 ; NEW_LINE DEDENT return int ( ans ) ; NEW_LINE DEDENT a = [ 2 , 4 , 5 , 3 , 3 , 3 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( calculate ( a , n ) ) ; NEW_LINE"],"bleu":0.606725853599014,"rouge_l":0.8094976968633473}
{"id":1525,"predictions":["def nth_group ( n ) : NEW_LINE INDENT return n * ( 2 * pow ( n , 2 ) + 1 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 5 NEW_LINE print ( nth_group ( N ) ) NEW_LINE DEDENT"],"references":["def nth_group ( n ) : NEW_LINE INDENT return n * ( 2 * pow ( n , 2 ) + 1 ) NEW_LINE DEDENT N = 5 NEW_LINE print ( nth_group ( N ) ) NEW_LINE"],"bleu":0.6918211695197932,"rouge_l":0.8657460682777137}
{"id":1526,"predictions":["class Point : NEW_LINE INDENT def __init__ ( self , word ) : NEW_LINE INDENT self . string = word NEW_LINE self . index = word NEW_LINE DEDENT DEDENT def partitionArr ( string , size ) : NEW_LINE INDENT size = size NEW_LINE arr = [ ] NEW_LINE size = len ( string ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT arr . append ( string [ i ] , i ) NEW_LINE DEDENT def sortString ( wordArr , size ) : NEW_LINE INDENT DEDENT def printAnagramsProduct ( wordArr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT charArray [ i ] = word [ i ] NEW_LINE DEDENT DEDENT def printAnagramsResult ( wordArr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( wordArr [ i ] [ index ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT print ( \" cat \" ) NEW_LINE"],"references":["class Word ( object ) : NEW_LINE INDENT def __init__ ( self , string , index ) : NEW_LINE INDENT self . string = string NEW_LINE self . index = index NEW_LINE DEDENT DEDENT def createDupArray ( string , size ) : NEW_LINE INDENT dupArray = [ ] NEW_LINE for i in xrange ( size ) : NEW_LINE INDENT dupArray . append ( Word ( string [ i ] , i ) ) NEW_LINE DEDENT return dupArray NEW_LINE DEDENT def printAnagramsTogether ( wordArr , size ) : NEW_LINE INDENT dupArray = createDupArray ( wordArr , size ) NEW_LINE for i in xrange ( size ) : NEW_LINE INDENT dupArray [ i ] . string = ' ' . join ( sorted ( dupArray [ i ] . string ) ) NEW_LINE DEDENT dupArray = sorted ( dupArray , key = lambda k : k . string ) NEW_LINE for word in dupArray : NEW_LINE INDENT print wordArr [ word . index ] , NEW_LINE DEDENT DEDENT wordArr = [ \" cat \" , \" dog \" , \" tac \" , \" god \" , \" act \" ] NEW_LINE size = len ( wordArr ) NEW_LINE printAnagramsTogether ( wordArr , size ) NEW_LINE"],"bleu":0.4034785237316411,"rouge_l":0.6089938362705096}
{"id":1527,"predictions":["def minAbsSumPair ( arr , n ) : NEW_LINE INDENT min_sum = 999999 NEW_LINE l = 0 NEW_LINE r = n - 1 NEW_LINE min_l = l NEW_LINE min_r = n - 1 NEW_LINE min_r = n - 1 NEW_LINE if ( n < 2 ) : NEW_LINE INDENT print ( \" Invalid ▁ Input \" ) NEW_LINE return NEW_LINE DEDENT sum1 = arr [ l ] + arr [ r ] NEW_LINE while ( l < r ) : NEW_LINE INDENT sum = arr [ l ] + arr [ r ] NEW_LINE if ( sum < min_sum ) : NEW_LINE INDENT min_sum = sum NEW_LINE min_l = l NEW_LINE min_r = r NEW_LINE DEDENT if ( sum < 0 ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT return r - 1 NEW_LINE DEDENT DEDENT print ( \" The ▁ two ▁ elements ▁ are ▁ \" , arr [ min_l ] , \" and \" , arr [ min_r ] ) NEW_LINE print ( \" The ▁ two ▁ elements ▁ are \" , arr [ min_l ] , \" and \" , arr [ min_r ] ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 6 , - 2 ] NEW_LINE n = len ( arr ) NEW_LINE arr_size = len ( arr ) NEW_LINE print ( arr_sumPair ( arr , n ) ) NEW_LINE DEDENT"],"references":["def partition ( arr , si , ei ) : NEW_LINE INDENT x = arr [ ei ] NEW_LINE i = ( si - 1 ) NEW_LINE for j in range ( si , ei ) : NEW_LINE INDENT if ( arr [ j ] <= x ) : NEW_LINE INDENT i += 1 NEW_LINE arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE DEDENT DEDENT arr [ i + 1 ] , arr [ ei ] = arr [ ei ] , arr [ i + 1 ] NEW_LINE return ( i + 1 ) NEW_LINE DEDENT def quickSort ( arr , si , ei ) : NEW_LINE INDENT pi = 0 NEW_LINE if ( si < ei ) : NEW_LINE INDENT pi = partition ( arr , si , ei ) NEW_LINE quickSort ( arr , si , pi - 1 ) NEW_LINE quickSort ( arr , pi + 1 , ei ) NEW_LINE DEDENT DEDENT def minAbsSumPair ( arr , n ) : NEW_LINE INDENT sum , min_sum = 0 , 10 ** 9 NEW_LINE l = 0 NEW_LINE r = n - 1 NEW_LINE min_l = l NEW_LINE min_r = n - 1 NEW_LINE if ( n < 2 ) : NEW_LINE INDENT print ( \" Invalid ▁ Input \" , end = \" \" ) NEW_LINE return NEW_LINE DEDENT quickSort ( arr , l , r ) NEW_LINE while ( l < r ) : NEW_LINE INDENT sum = arr [ l ] + arr [ r ] NEW_LINE if ( abs ( sum ) < abs ( min_sum ) ) : NEW_LINE INDENT min_sum = sum NEW_LINE min_l = l NEW_LINE min_r = r NEW_LINE DEDENT if ( sum < 0 ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT DEDENT print ( \" The ▁ two ▁ elements ▁ whose ▁ sum ▁ is ▁ minimum ▁ are \" , arr [ min_l ] , \" and \" , arr [ min_r ] ) NEW_LINE DEDENT arr = [ 1 , 60 , - 10 , 70 , - 80 , 85 ] NEW_LINE n = len ( arr ) NEW_LINE minAbsSumPair ( arr , n ) NEW_LINE"],"bleu":0.3886847283436294,"rouge_l":0.5426286856571714}
{"id":1528,"predictions":["def countFreq ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in mp . keys ( ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( mp [ arr [ i ] ] != - 1 ) : NEW_LINE INDENT print ( arr [ i ] , mp [ arr [ i ] ] ) NEW_LINE mp [ arr [ i ] ] = - 1 NEW_LINE DEDENT DEDENT DEDENT arr = [ 10 , 20 , 20 , 10 , 20 , 5 , 20 ] NEW_LINE n = len ( arr ) NEW_LINE countFreq ( arr , n ) NEW_LINE"],"references":["def countFreq ( arr , n ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] not in mp : NEW_LINE INDENT mp [ arr [ i ] ] = 0 NEW_LINE DEDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( mp [ arr [ i ] ] != - 1 ) : NEW_LINE INDENT print ( arr [ i ] , mp [ arr [ i ] ] ) NEW_LINE DEDENT mp [ arr [ i ] ] = - 1 NEW_LINE DEDENT DEDENT arr = [ 10 , 20 , 20 , 10 , 10 , 20 , 5 , 20 ] NEW_LINE n = len ( arr ) NEW_LINE countFreq ( arr , n ) NEW_LINE"],"bleu":0.8398869749160317,"rouge_l":0.9051880380607157}
{"id":1529,"predictions":["import math NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT sr = math . sqrt ( x ) NEW_LINE return ( ( sr - math . floor ( sr ) ) == 0 ) NEW_LINE DEDENT def isPerfectSquare ( x ) : NEW_LINE INDENT sr = int ( math . sqrt ( x ) ) NEW_LINE return ( ( sr - math . floor ( sr ) ) == 0 ) NEW_LINE DEDENT def totalPibonacci ( n ) : NEW_LINE INDENT s = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( isFibonacci ( a [ i ] + b [ j ] ) == True ) : NEW_LINE INDENT if ( a [ i ] < b [ j ] ) : NEW_LINE INDENT if ( a [ i ] < b [ j ] ) : NEW_LINE INDENT s . append ( [ a [ i ] , b [ j ] ] ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( checkDuipimeter ( s , ( b [ j ] , a [ j ] ) ) ) : NEW_LINE INDENT s . append ( [ b [ j ] , a [ i ] ] ) NEW_LINE DEDENT else : NEW_LINE INDENT s . append ( [ b [ j ] , a [ i ] ] ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return len ( s ) NEW_LINE DEDENT def checkPairs ( a , b , n , m = [ 99 , 1 , 33 , 2 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE print ( totalPairs ( a , b , n , m ) ) NEW_LINE"],"references":["from math import sqrt , floor NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT sr = sqrt ( x ) NEW_LINE return ( ( sr - floor ( sr ) ) == 0 ) NEW_LINE DEDENT def isFibonacci ( n ) : NEW_LINE INDENT return ( isPerfectSquare ( 5 * n * n + 4 ) or isPerfectSquare ( 5 * n * n - 4 ) ) NEW_LINE DEDENT def totalPairs ( a , b , n , m ) : NEW_LINE INDENT s = set ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( isFibonacci ( a [ i ] + b [ j ] ) == True ) : NEW_LINE INDENT if ( a [ i ] < b [ j ] ) : NEW_LINE INDENT s . add ( ( a [ i ] , b [ j ] ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT s . add ( ( b [ j ] , a [ i ] ) ) ; NEW_LINE DEDENT DEDENT DEDENT DEDENT return len ( s ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 99 , 1 , 33 , 2 ] ; NEW_LINE b = [ 1 , 11 , 2 ] ; NEW_LINE n = len ( a ) ; NEW_LINE m = len ( b ) ; NEW_LINE print ( totalPairs ( a , b , n , m ) ) ; NEW_LINE DEDENT"],"bleu":0.5943101923421303,"rouge_l":0.7008239526517349}
{"id":1530,"predictions":["def countSolutions ( n ) : NEW_LINE INDENT res = 0 NEW_LINE for x in range ( 0 , int ( sqrt ( n ) ) ) : NEW_LINE INDENT if ( x * x < n ) : NEW_LINE INDENT y = 0 NEW_LINE while ( x * x + y * y < n ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT print ( \" Total ▁ Number ▁ of ▁ distinct ▁ Non ▁ pair ▁ is : \" , countSolutions ( 6 ) ) NEW_LINE"],"references":["def countSolutions ( n ) : NEW_LINE INDENT res = 0 NEW_LINE x = 0 NEW_LINE while ( x * x < n ) : NEW_LINE INDENT y = 0 NEW_LINE while ( x * x + y * y < n ) : NEW_LINE INDENT res = res + 1 NEW_LINE y = y + 1 NEW_LINE DEDENT x = x + 1 NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( \" Total ▁ Number ▁ of ▁ distinct ▁ Non - Negative ▁ pairs ▁ is ▁ \" , countSolutions ( 6 ) ) NEW_LINE DEDENT"],"bleu":0.5794595749960814,"rouge_l":0.7248280175109444}
{"id":1531,"predictions":["def findLength ( str , n ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT l = i ; r = i + 1 ; NEW_LINE lsum = 0 ; rsum = 0 ; NEW_LINE rsum = 0 ; NEW_LINE while ( r < n and l >= 0 ) : NEW_LINE INDENT lsum += ord ( str [ l ] ) - ord ( '0' ) ; NEW_LINE rsum += ord ( str [ r ] ) - ord ( '0' ) ; NEW_LINE if ( lsum == rsum ) : NEW_LINE INDENT ans = max ( ans , r - l + 1 ) ; NEW_LINE DEDENT l -= 1 ; NEW_LINE r += 1 ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \"123\" ; NEW_LINE print ( \" Length ▁ of ▁ the ▁ substring ▁ is \" , findLength ( str , len ( str ) ) ) ; NEW_LINE DEDENT"],"references":["def findLength ( st , n ) : NEW_LINE INDENT total = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT total [ i ] = ( total [ i - 1 ] + int ( st [ i - 1 ] ) - int ( '0' ) ) NEW_LINE DEDENT ans = 0 NEW_LINE l = 2 NEW_LINE while ( l <= n ) : NEW_LINE INDENT for i in range ( n - l + 1 ) : NEW_LINE INDENT j = i + l - 1 NEW_LINE if ( total [ i + int ( l \/ 2 ) ] - total [ i ] == total [ i + l ] - total [ i + int ( l \/ 2 ) ] ) : NEW_LINE INDENT ans = max ( ans , l ) NEW_LINE DEDENT DEDENT l = l + 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT st = \"123123\" NEW_LINE print ( \" Length ▁ of ▁ the ▁ substring ▁ is \" , findLength ( st , len ( st ) ) ) NEW_LINE"],"bleu":0.32896632107109836,"rouge_l":0.5154049671417599}
{"id":1532,"predictions":["def findLength ( arr , n ) : NEW_LINE INDENT max_len = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT mn = arr [ i ] NEW_LINE mx = arr [ i ] NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT mn = min ( mn , arr [ j ] ) NEW_LINE mx = max ( mx , arr [ j ] ) NEW_LINE if ( ( mx - mn ) == j - i ) : NEW_LINE INDENT max_len = max ( max_len , mx - mn + 1 ) NEW_LINE DEDENT DEDENT DEDENT return max_len NEW_LINE DEDENT arr = [ 1 , 56 , 58 , 90 , 90 , 90 , 89 , 90 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Length ▁ of ▁ the ▁ longest ▁ contiguous ▁ subarray ▁ is \" , findLength ( arr , n ) ) NEW_LINE"],"references":["def min ( x , y ) : NEW_LINE INDENT return x if ( x < y ) else y NEW_LINE DEDENT def max ( x , y ) : NEW_LINE INDENT return x if ( x > y ) else y NEW_LINE DEDENT def findLength ( arr , n ) : NEW_LINE INDENT max_len = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT mn = arr [ i ] NEW_LINE mx = arr [ i ] NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT mn = min ( mn , arr [ j ] ) NEW_LINE mx = max ( mx , arr [ j ] ) NEW_LINE if ( ( mx - mn ) == j - i ) : NEW_LINE INDENT max_len = max ( max_len , mx - mn + 1 ) NEW_LINE DEDENT DEDENT DEDENT return max_len NEW_LINE DEDENT arr = [ 1 , 56 , 58 , 57 , 90 , 92 , 94 , 93 , 91 , 45 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Length ▁ of ▁ the ▁ longest ▁ contiguous ▁ subarray ▁ is ▁ \" , findLength ( arr , n ) ) NEW_LINE"],"bleu":0.6990492788642082,"rouge_l":0.8311185870479394}
{"id":1533,"predictions":["def findCombinationsUtil ( arr , index , num , reducedNum ) : NEW_LINE INDENT if ( reducedNum < 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( reducedNum == 0 ) : NEW_LINE INDENT for i in range ( index ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE return NEW_LINE DEDENT if ( index == 0 ) : NEW_LINE INDENT prev = 1 NEW_LINE DEDENT else : NEW_LINE INDENT prev = 1 NEW_LINE index = arr [ index - 1 ] NEW_LINE DEDENT for k in range ( prev , num + 1 ) : NEW_LINE INDENT arr [ index ] = k NEW_LINE findCombinationsUtil ( arr , index + 1 , num , reversedNum - k ) NEW_LINE DEDENT DEDENT def findCombinations ( n ) : NEW_LINE INDENT arr = [ 0 ] * n NEW_LINE findCombinationsUtil ( arr , 0 , n , n ) NEW_LINE"],"references":["def findCombinationsUtil ( arr , index , num , reducedNum ) : NEW_LINE INDENT if ( reducedNum < 0 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT if ( reducedNum == 0 ) : NEW_LINE INDENT for i in range ( index ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( \" \" ) ; NEW_LINE return ; NEW_LINE DEDENT prev = 1 if ( index == 0 ) else arr [ index - 1 ] ; NEW_LINE for k in range ( prev , num + 1 ) : NEW_LINE INDENT arr [ index ] = k ; NEW_LINE findCombinationsUtil ( arr , index + 1 , num , reducedNum - k ) ; NEW_LINE DEDENT DEDENT def findCombinations ( n ) : NEW_LINE INDENT arr = [ 0 ] * n ; NEW_LINE findCombinationsUtil ( arr , 0 , n , n ) ; NEW_LINE DEDENT n = 5 ; NEW_LINE findCombinations ( n ) ; NEW_LINE"],"bleu":0.7407740286493891,"rouge_l":0.8594053633890401}
{"id":1534,"predictions":["import math NEW_LINE def fib ( n ) : NEW_LINE INDENT phi = ( 1 + math . sqrt ( 5 ) ) \/ 2 NEW_LINE return round ( pow ( phi , n ) \/ math . sqrt ( 5 ) ) NEW_LINE DEDENT def calculateSum ( l , r ) : NEW_LINE INDENT sum = fib ( r + 2 ) - fib ( l + 1 ) NEW_LINE return int ( sum ) NEW_LINE DEDENT l = 4 NEW_LINE r = 8 NEW_LINE print ( calculateSum ( l , r ) ) NEW_LINE"],"references":["import math NEW_LINE def fib ( n ) : NEW_LINE INDENT phi = ( 1 + math . sqrt ( 5 ) ) \/ 2 ; NEW_LINE return int ( round ( pow ( phi , n ) \/ math . sqrt ( 5 ) ) ) ; NEW_LINE DEDENT def calculateSum ( l , r ) : NEW_LINE INDENT sum = fib ( r + 2 ) - fib ( l + 1 ) ; NEW_LINE return sum ; NEW_LINE DEDENT l = 4 ; NEW_LINE r = 8 ; NEW_LINE print ( calculateSum ( l , r ) ) ; NEW_LINE"],"bleu":0.8026290451300464,"rouge_l":0.9287819253438113}
{"id":1535,"predictions":["def MinimumValue ( x , y ) : NEW_LINE INDENT if ( x > y ) : NEW_LINE INDENT temp = x NEW_LINE x = y NEW_LINE y = temp NEW_LINE DEDENT a = 1 NEW_LINE b = x - 1 NEW_LINE c = y - b NEW_LINE print ( a , b , c ) NEW_LINE DEDENT x = 15 NEW_LINE y = 16 NEW_LINE MinimumValue ( x , y ) NEW_LINE"],"references":["def MinimumValue ( x , y ) : NEW_LINE INDENT if ( x > y ) : NEW_LINE INDENT x , y = y , x NEW_LINE DEDENT a = 1 NEW_LINE b = x - 1 NEW_LINE c = y - b NEW_LINE print ( a , b , c ) NEW_LINE DEDENT x = 123 NEW_LINE y = 13 NEW_LINE MinimumValue ( x , y ) NEW_LINE"],"bleu":0.7811877558444417,"rouge_l":0.8918542585286608}
{"id":1536,"predictions":["def maximumChars ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE res = - 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( str [ i ] == str [ j ] ) : NEW_LINE INDENT res = max ( res , abs ( j - i - 1 ) ) NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT str = \" abba \" NEW_LINE print ( maximumChars ( str ) ) NEW_LINE"],"references":["def maximumChars ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE res = - 1 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( str [ i ] == str [ j ] ) : NEW_LINE INDENT res = max ( res , abs ( j - i - 1 ) ) NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" abba \" NEW_LINE print ( maximumChars ( str ) ) NEW_LINE DEDENT"],"bleu":0.8227666704114985,"rouge_l":0.9121147390906318}
{"id":1537,"predictions":["def printTribRec ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 or n == 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 3 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return (PrintTribRec ( n - 1 ) + printTribRec ( n - 2 ) + printTribRec ( n - 3 ) ) NEW_LINE DEDENT def printTrib ( n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT print ( printTribRec ( i ) , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT n = 16 NEW_LINE printTrib ( n ) NEW_LINE"],"references":["def printTribRec ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 or n == 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( n == 3 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( printTribRec ( n - 1 ) + printTribRec ( n - 2 ) + printTribRec ( n - 3 ) ) NEW_LINE DEDENT DEDENT def printTrib ( n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT print ( printTribRec ( i ) , \" ▁ \" , end = \" \" ) NEW_LINE DEDENT DEDENT n = 10 NEW_LINE printTrib ( n ) NEW_LINE"],"bleu":0.8672816667831691,"rouge_l":0.9410701876302988}
{"id":1538,"predictions":["def steps ( N , M ) : NEW_LINE INDENT if ( N == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( N == 2 ) : NEW_LINE INDENT return M NEW_LINE DEDENT elif ( N == 3 ) : NEW_LINE INDENT return 2 * M + ( N - 3 ) NEW_LINE DEDENT else : NEW_LINE INDENT return 2 * M + ( N - 3 ) NEW_LINE DEDENT DEDENT N = 4 NEW_LINE M = 4 NEW_LINE print ( steps ( N , M ) ) NEW_LINE"],"references":["def steps ( N , M ) : NEW_LINE INDENT if ( N == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( N == 2 ) : NEW_LINE INDENT return M NEW_LINE DEDENT return 2 * M + ( N - 3 ) NEW_LINE DEDENT N = 4 NEW_LINE M = 4 NEW_LINE print ( steps ( N , M ) ) NEW_LINE"],"bleu":0.6905089240311874,"rouge_l":0.8609923011120616}
{"id":1539,"predictions":["def waysToKAdjacentSetBits ( n , k , currentIndex , array , lastSetBits , lastBit ) : NEW_LINE INDENT if ( currentIndex == n ) : NEW_LINE INDENT if (selectedSetBits == k ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT noOfWays = 0 NEW_LINE if ( lastBit == 1 ) : NEW_LINE INDENT noOfWays = 0 NEW_LINE DEDENT noOfWays = 0 NEW_LINE if ( lastBit == 1 ) : NEW_LINE INDENT noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjSetBits , 0 ) NEW_LINE DEDENT elif ( lastBit == 0 ) : NEW_LINE INDENT noOfWays += waysToKAdjits ( n , k , currentIndex + 1 ,adjSetBits , 1 ) NEW_LINE noOfWays += waysToKAdj NEW_LINE DEDENT return noOfWays NEW_LINE DEDENT n , k = 5 , 2 NEW_LINE totalWays = waysToKAdjacentSetBits ( n , k , 1 , 0 , 1 ) + waysToKays ( n , k , 1 ) NEW_LINE print ( \" Number ▁ of ▁ ways ▁ = \" , totalWays ) NEW_LINE"],"references":["def waysToKAdjacentSetBits ( n , k , currentIndex , adjacentSetBits , lastBit ) : NEW_LINE INDENT if ( currentIndex == n ) : NEW_LINE INDENT if ( adjacentSetBits == k ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT return 0 NEW_LINE DEDENT noOfWays = 0 NEW_LINE if ( lastBit == 1 ) : NEW_LINE INDENT noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits + 1 , 1 ) ; NEW_LINE noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits , 0 ) ; NEW_LINE DEDENT elif ( lastBit != 1 ) : NEW_LINE INDENT noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits , 1 ) ; NEW_LINE noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits , 0 ) ; NEW_LINE DEDENT return noOfWays ; NEW_LINE DEDENT n = 5 ; k = 2 ; NEW_LINE totalWays = ( waysToKAdjacentSetBits ( n , k , 1 , 0 , 1 ) + waysToKAdjacentSetBits ( n , k , 1 , 0 , 0 ) ) ; NEW_LINE print ( \" Number ▁ of ▁ ways ▁ = \" , totalWays ) ; NEW_LINE"],"bleu":0.5788501258730747,"rouge_l":0.7679572303181857}
{"id":1540,"predictions":["def canPlace ( a , n , p , s ) : NEW_LINE INDENTBuffer = 1 NEW_LINE last_stack = a [ 0 ] NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT current_scan = a [ i ] NEW_LINE if ( current_scan - last_scan >= 10 ) : NEW_LINE INDENT fishes += 1 NEW_LINE last_stack = current_cells NEW_LINE if (ILA == p ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT def maxDistance ( cell , n , p ) : NEW_LINE INDENT row . sort ( ) NEW_LINE start = 0 NEW_LINE end = 0 NEW_LINE while ( end <= end ) : NEW_LINE INDENT mid = start + int ( ( end - start ) \/ 2 ) NEW_LINE if ( canPlace ( cell , n , p , mid ) ) : NEW_LINE INDENT ans = mid NEW_LINE start = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT cell = [ 1 , 2 , 8 , 4 , 9 ] NEW_LINE n = len ( cell ) NEW_LINE p = 3 NEW_LINE print ( maxDistance ( cell , n , p ) ) NEW_LINE DEDENT"],"references":["def canPlace ( a , n , p , sep ) : NEW_LINE INDENT prisoners_placed = 1 NEW_LINE last_prisoner_placed = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT current_cell = a [ i ] NEW_LINE if ( current_cell - last_prisoner_placed >= sep ) : NEW_LINE INDENT prisoners_placed += 1 NEW_LINE last_prisoner_placed = current_cell NEW_LINE if ( prisoners_placed == p ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT def maxDistance ( cell , n , p ) : NEW_LINE INDENT cell = sorted ( cell ) NEW_LINE start = 0 NEW_LINE end = cell [ n - 1 ] - cell [ 0 ] NEW_LINE ans = 0 NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = start + ( ( end - start ) \/\/ 2 ) NEW_LINE if ( canPlace ( cell , n , p , mid ) ) : NEW_LINE INDENT ans = mid NEW_LINE start = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT cell = [ 1 , 2 , 8 , 4 , 9 ] NEW_LINE n = len ( cell ) NEW_LINE p = 3 NEW_LINE print ( maxDistance ( cell , n , p ) ) NEW_LINE"],"bleu":0.7515115030347261,"rouge_l":0.8539823008849557}
{"id":1541,"predictions":["def containsElement ( arr , n ) : NEW_LINE INDENT xorArr = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT xorArr ^= arr [ i ] ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT x = xorArr ^ arr [ i ] ; NEW_LINE if ( arr [ i ] == x ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT return False ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 8 , 2 , 4 , 15 , 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE if ( containsElement ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"],"references":["def containsElement ( arr , n ) : NEW_LINE INDENT xorArr = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT xorArr ^= arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT x = xorArr ^ arr [ i ] NEW_LINE if ( arr [ i ] == x ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT arr = [ 8 , 2 , 4 , 15 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE if ( containsElement ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.7416120690415823,"rouge_l":0.9298780487804879}
{"id":1542,"predictions":["def solve ( s ) : NEW_LINE INDENT m = dict . fromkeys ( s , 0 ) ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT m [ s [ i ] ] += 1 ; NEW_LINE DEDENT new_string = \" \" ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( m [ s [ i ] ] % 2 == 0 ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT new_string = new_string + s [ i ] ; NEW_LINE DEDENT print ( new_string ) ; NEW_LINE DEDENT s = \" aabbbddeeecc \" ; NEW_LINE solve ( s ) ; NEW_LINE"],"references":["def solve ( s ) : NEW_LINE INDENT m = dict ( ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] in m : NEW_LINE INDENT m [ s [ i ] ] = m [ s [ i ] ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ s [ i ] ] = 1 NEW_LINE DEDENT DEDENT new_string = \" \" NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if m [ s [ i ] ] % 2 == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT new_string = new_string + s [ i ] NEW_LINE DEDENT print ( new_string ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" aabbbddeeecc \" NEW_LINE solve ( s ) NEW_LINE DEDENT"],"bleu":0.5230180187882213,"rouge_l":0.7381413359148113}
{"id":1543,"predictions":["def getTotalXorOfSubarrayXors ( arr , N ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT freq = ( i + 1 ) * ( N - i ) NEW_LINE if ( freq % 2 == 1 ) : NEW_LINE INDENT res = res ^ arr [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT arr = [ 3 , 5 , 2 , 4 , 6 ] NEW_LINE N = len ( arr ) NEW_LINE print ( getTotalXorOfSubarrayXorsXors ( arr , N ) ) NEW_LINE"],"references":["def getTotalXorOfSubarrayXors ( arr , N ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT freq = ( i + 1 ) * ( N - i ) NEW_LINE if ( freq % 2 == 1 ) : NEW_LINE INDENT res = res ^ arr [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT arr = [ 3 , 5 , 2 , 4 , 6 ] NEW_LINE N = len ( arr ) NEW_LINE print ( getTotalXorOfSubarrayXors ( arr , N ) ) NEW_LINE"],"bleu":0.9371422560186364,"rouge_l":0.9773308334753706}
{"id":1544,"predictions":["def sum ( N ) : NEW_LINE INDENT S1 = ( ( N \/\/ 3 ) ) * ( 2 * 3 + ( N \/\/ 3 - 1 ) * 3 ) \/\/ 2 NEW_LINE S2 = ( ( N \/\/ 4 ) ) * ( 2 * 4 + ( N \/\/ 4 - 1 ) * 4 ) \/\/ 2 NEW_LINE S3 = ( ( N \/\/ 12 ) ) * ( 2 * 12 + ( N \/\/ 12 - 1 ) * 12 ) \/\/ 2 NEW_LINE return S1 + S2 - S3 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 20 NEW_LINE print ( sum ( 12 ) ) NEW_LINE DEDENT"],"references":["def sum ( N ) : NEW_LINE INDENT global S1 , S2 , S3 NEW_LINE S1 = ( ( ( N \/\/ 3 ) ) * ( 2 * 3 + ( N \/\/ 3 - 1 ) * 3 ) \/\/ 2 ) NEW_LINE S2 = ( ( ( N \/\/ 4 ) ) * ( 2 * 4 + ( N \/\/ 4 - 1 ) * 4 ) \/\/ 2 ) NEW_LINE S3 = ( ( ( N \/\/ 12 ) ) * ( 2 * 12 + ( N \/\/ 12 - 1 ) * 12 ) \/\/ 2 ) NEW_LINE return int ( S1 + S2 - S3 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 12 NEW_LINE print ( sum ( N ) ) NEW_LINE DEDENT"],"bleu":0.7785344910888794,"rouge_l":0.9155168240135559}
{"id":1545,"predictions":["def count ( S , m , n ) : NEW_LINE INDENT table = [ [ 0 ] * m for x in range ( n + 1 ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT table [ 0 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( S [ i ] , n + 1 ) : NEW_LINE INDENT x = table [ i - S [ j ] if i - S [ j ] >= 0 else 0 NEW_LINE y = table [ i ] [ j - S [ i ] ] if j >= 1 else 0 NEW_LINE table [ i ] [ j ] = x + y NEW_LINE DEDENT DEDENT return table [ n ] [ j ] NEW_LINE DEDENT def count ( S , m , n ) : NEW_LINE INDENT table = [ 0 ] * ( n + 1 ) NEW_LINE table [ 0 ] [ 1 ] = 1 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT x = table [ i ] [ j ] NEW_LINE table [ i ] [ j ] += table [ i ] [ j ] if x < 0 : NEW_LINE INDENT x = table [ i ] [ j - S [ i - S [ i ] ] [ j ] if x < 0 : NEW_LINE INDENT table [ i ] [ j ] += table [ i - 1 ] [ j ] if x < 1 : NEW_LINE INDENT table [ i ] [ j ] = x NEW_LINE DEDENT DEDENT DEDENT DEDENT return table [ n ] [ 2 ] NEW_LINE DEDENT m = len ( table ) NEW_LINE n = len ( table ) NEW_LINE print ( count ( S , m , n ) ) NEW_LINE"],"references":["def count ( S , m , n ) : NEW_LINE INDENT table = [ 0 for k in range ( n + 1 ) ] NEW_LINE table [ 0 ] = 1 NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT for j in range ( S [ i ] , n + 1 ) : NEW_LINE INDENT table [ j ] += table [ j - S [ i ] ] NEW_LINE DEDENT DEDENT return table [ n ] NEW_LINE DEDENT arr = [ 1 , 2 , 3 ] NEW_LINE m = len ( arr ) NEW_LINE n = 4 NEW_LINE x = count ( arr , m , n ) NEW_LINE print ( x ) NEW_LINE"],"bleu":0.2687485194481124,"rouge_l":0.50542047390429}
{"id":1546,"predictions":["def countSolutions ( a ) : NEW_LINE INDENT count = bin ( a ) . count ( '1' ) NEW_LINE count = int ( pow ( 2 , count ) ) NEW_LINE return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 3 NEW_LINE print ( countSolutions ( a ) ) NEW_LINE DEDENT"],"references":["def countSolutions ( a ) : NEW_LINE INDENT count = bin ( a ) . count ( '1' ) NEW_LINE return 2 ** count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 3 NEW_LINE print ( countSolutions ( a ) ) NEW_LINE DEDENT"],"bleu":0.6942468018940192,"rouge_l":0.8556399766218586}
{"id":1547,"predictions":["def countNumbers ( n ) : NEW_LINE INDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT return ( 9 * pow ( 10 , int ( n \/ 2 - 1 ) ) ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 2 ; NEW_LINE print ( countNumbers ( n ) ) ; NEW_LINE DEDENT"],"references":["def countNumbers ( n ) : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( 9 * pow ( 10 , n \/\/ 2 - 1 ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 2 NEW_LINE print ( countNumbers ( n ) ) NEW_LINE DEDENT"],"bleu":0.6996627809604953,"rouge_l":0.930733833858077}
{"id":1548,"predictions":["def getMinDiff ( arr , n , k ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT arr . sort ( reverse = arr [ n - 1 ] - arr [ 0 ] ) NEW_LINE small = arr [ 0 ] + k NEW_LINE big = arr [ n - 1 ] - k NEW_LINE temp = 0 NEW_LINE if ( small > big ) : NEW_LINE INDENT temp = small NEW_LINE small = small NEW_LINE big = small NEW_LINE DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT subtract = arr [ i ] - k NEW_LINE add = arr [ i ] + k NEW_LINE if ( subtract >= small or add <= big ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( big - subtract <= add - small ) : NEW_LINE INDENT small = subtract NEW_LINE DEDENT else : NEW_LINE INDENT big = add + 1 NEW_LINE DEDENT DEDENT return min ( ans , big - small ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE k = 10 NEW_LINE print ( \" Maximum ▁ difference ▁ is \" , getMinDiff ( arr , n , k ) ) NEW_LINE DEDENT"],"references":["def getMinDiff ( arr , n , k ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT arr . sort ( ) NEW_LINE ans = arr [ n - 1 ] - arr [ 0 ] NEW_LINE small = arr [ 0 ] + k NEW_LINE big = arr [ n - 1 ] - k NEW_LINE if ( small > big ) : NEW_LINE INDENT small , big = big , small NEW_LINE DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT subtract = arr [ i ] - k NEW_LINE add = arr [ i ] + k NEW_LINE if ( subtract >= small or add <= big ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( big - subtract <= add - small ) : NEW_LINE INDENT small = subtract NEW_LINE DEDENT else : NEW_LINE INDENT big = add NEW_LINE DEDENT DEDENT return min ( ans , big - small ) NEW_LINE DEDENT arr = [ 4 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE k = 10 NEW_LINE print ( \" Maximum ▁ difference ▁ is \" , getMinDiff ( arr , n , k ) ) NEW_LINE"],"bleu":0.8327152864113655,"rouge_l":0.9293755628940258}
{"id":1549,"predictions":["def minimumChanges ( n , a ) : NEW_LINE INDENT sf = [ 0 ] * ( n + 1 ) ; NEW_LINE sf [ n ] = 0 ; NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT sf [ i ] = sf [ i + 1 ] ; NEW_LINE if ( a [ i ] <= 0 ) : NEW_LINE INDENT sf [ i ] += 1 ; NEW_LINE DEDENT DEDENT pos = 0 ; NEW_LINE mn = n ; NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( a [ i ] >= 0 ) : NEW_LINE INDENT pos += 1 ; NEW_LINE DEDENT mn = min ( mn , pos + sf [ i + 1 ] ) ; NEW_LINE DEDENT return mn ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ - 1 , - 2 , 3 , 3 , - 5 , 3 , 4 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( minimumChanges ( n , a ) ) ; NEW_LINE DEDENT"],"references":["def minimumChanges ( n , a ) : NEW_LINE INDENT sf = [ 0 ] * ( n + 1 ) NEW_LINE sf [ n ] = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT sf [ i ] = sf [ i + 1 ] NEW_LINE if ( a [ i ] <= 0 ) : NEW_LINE INDENT sf [ i ] += 1 NEW_LINE DEDENT DEDENT pos = 0 NEW_LINE mn = n NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( a [ i ] >= 0 ) : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT mn = min ( mn , pos + sf [ i + 1 ] ) NEW_LINE DEDENT return mn NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ - 1 , - 2 , - 3 , 3 , - 5 , 3 , 4 ] NEW_LINE n = len ( a ) NEW_LINE print ( minimumChanges ( n , a ) ) NEW_LINE DEDENT"],"bleu":0.815465535484441,"rouge_l":0.961596511822908}
{"id":1550,"predictions":["def printFirstRepeating ( arr ) : NEW_LINE INDENT min = - 1 NEW_LINE set1 = set ( ) NEW_LINE for i in range ( len ( arr ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if arr [ i ] in set1 : NEW_LINE INDENT min = i NEW_LINE DEDENT else : NEW_LINE INDENT set . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT if min != - 1 : NEW_LINE INDENT print ( \" The ▁ first ▁ repeating ▁ element ▁ is ▁ \" , arr [ min ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" There ▁ are ▁ no ▁ repeating ▁ elements \" ) NEW_LINE DEDENT DEDENT arr = [ 10 , 1 , 2 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE printFirstRepeating ( arr , n ) NEW_LINE"],"references":["def printFirstRepeating ( arr , n ) : NEW_LINE INDENT Min = - 1 NEW_LINE myset = dict ( ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if arr [ i ] in myset . keys ( ) : NEW_LINE INDENT Min = i NEW_LINE DEDENT else : NEW_LINE INDENT myset [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT if ( Min != - 1 ) : NEW_LINE INDENT print ( \" The ▁ first ▁ repeating ▁ element ▁ is \" , arr [ Min ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" There ▁ are ▁ no ▁ repeating ▁ elements \" ) NEW_LINE DEDENT DEDENT arr = [ 10 , 5 , 3 , 4 , 3 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE printFirstRepeating ( arr , n ) NEW_LINE"],"bleu":0.6943262104869793,"rouge_l":0.8466836194108921}
{"id":1551,"predictions":["def solveEven ( n , arr , b ) : NEW_LINE INDENT left = n - 1 NEW_LINE for i in range ( int ( n \/ 2 ) ) : NEW_LINE INDENT b [ i ] = arr [ left ] NEW_LINE left = left - 2 NEW_LINE if ( right < n - 2 ) : NEW_LINE INDENT break NEW_LINE DEDENT right = 0 NEW_LINE for i in range ( int ( n \/ 2 ) , 1 ) : NEW_LINE INDENT b [ i ] = arr [ right ] NEW_LINE right = right + 2 NEW_LINE if ( right < n - 2 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT DEDENT def solveOdd ( n , arr , b ) : NEW_LINE INDENT left = n - 1 NEW_LINE for i in range ( int ( ( n \/ 2 ) + 1 ) : NEW_LINE INDENT b [ i ] = arr [ left ] NEW_LINE left = left - 2 NEW_LINE if ( left < 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT right = 1 NEW_LINE for i in range ( int ( n \/ 2 ) + 1 , n - 1 ) : NEW_LINE INDENT b [ i ] = arr [ right ] NEW_LINE right = right + 2 NEW_LINE if ( right > n - 2 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT def solve ( n , arr ) : NEW_LINE INDENT b = [ 0 ] * n NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT solveEven ( n , arr , b ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( b [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( b [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE solve ( arr , arr ) NEW_LINE DEDENT"],"references":["def solveEven ( n , arr , b ) : NEW_LINE INDENT left = n - 1 NEW_LINE for i in range ( ( n \/\/ 2 ) ) : NEW_LINE INDENT b [ i ] = arr [ left ] NEW_LINE left = left - 2 NEW_LINE if ( left < 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT right = 0 NEW_LINE for i in range ( n \/\/ 2 , n , 1 ) : NEW_LINE INDENT b [ i ] = arr [ right ] NEW_LINE right = right + 2 NEW_LINE if ( right > n - 2 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT def solveOdd ( n , arr , b ) : NEW_LINE INDENT left = n - 1 NEW_LINE for i in range ( n \/\/ 2 + 1 ) : NEW_LINE INDENT b [ i ] = arr [ left ] NEW_LINE left = left - 2 NEW_LINE if ( left < 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT right = 1 NEW_LINE for i in range ( n \/\/ 2 + 1 , n , 1 ) : NEW_LINE INDENT b [ i ] = arr [ right ] NEW_LINE right = right + 2 NEW_LINE if ( right > n - 2 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT def solve ( n , arr ) : NEW_LINE INDENT b = [ 0 for i in range ( n ) ] NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT solveEven ( n , arr , b ) NEW_LINE DEDENT else : NEW_LINE INDENT solveOdd ( n , arr , b ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( b [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE solve ( n , arr ) NEW_LINE DEDENT"],"bleu":0.8372563985202147,"rouge_l":0.9179244850208743}
{"id":1552,"predictions":["def findpair ( l , r ) : NEW_LINE INDENT c = 0 ; NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , r + 1 ) : NEW_LINE INDENT if ( j % i == 0 and j != i ) : NEW_LINE INDENT print ( i , j ) ; NEW_LINE c = 1 ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( c == 1 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT l = 1 ; r = 18 ; NEW_LINE findpair ( l , r ) ; NEW_LINE DEDENT"],"references":["def findpair ( l , r ) : NEW_LINE INDENT c = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , r + 1 ) : NEW_LINE INDENT if ( j % i == 0 and j != i ) : NEW_LINE INDENT print ( i , \" , ▁ \" , j ) NEW_LINE c = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( c == 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT l = 1 NEW_LINE r = 10 NEW_LINE findpair ( l , r ) NEW_LINE DEDENT"],"bleu":0.8261612908480969,"rouge_l":0.9363320875600639}
{"id":1553,"predictions":["def nthEven ( n ) : NEW_LINE INDENT return ( 2 * n ) NEW_LINE DEDENT n = 10 NEW_LINE print ( nthEven ( n ) ) NEW_LINE"],"references":["def nthEven ( n ) : NEW_LINE INDENT return ( 2 * n ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE print ( nthEven ( n ) ) NEW_LINE DEDENT"],"bleu":0.5717904208544105,"rouge_l":0.7721518987341772}
{"id":1554,"predictions":["def checkUil ( num , dig , base ) : NEW_LINE INDENT if ( dig == 1 and num < base ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( dig > 1 and num >= base ) : NEW_LINE INDENT return checkUtil ( num \/ base , dig , base ) NEW_LINE DEDENT return False NEW_LINE DEDENT def check ( num , dig ) : NEW_LINE INDENT for base in range ( 2 , 32 ) : NEW_LINE INDENT if ( checkUil ( num , dig , base ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT num = 8 ; dig = 3 NEW_LINE dig = 3 NEW_LINE if ( check ( num , dig ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def checkUtil ( num , dig , base ) : NEW_LINE INDENT if ( dig == 1 and num < base ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( dig > 1 and num >= base ) : NEW_LINE INDENT return checkUtil ( num \/ base , - - dig , base ) NEW_LINE DEDENT return False NEW_LINE DEDENT def check ( num , dig ) : NEW_LINE INDENT for base in range ( 2 , 33 ) : NEW_LINE INDENT if ( checkUtil ( num , dig , base ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT num = 8 NEW_LINE dig = 3 NEW_LINE if ( check ( num , dig ) == True ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.8953641265799175,"rouge_l":0.9527027027027026}
{"id":1555,"predictions":["def smallestSubWithSum ( arr , n , x ) : NEW_LINE INDENT min_len = n + 1 NEW_LINE for start in range ( n ) : NEW_LINE INDENT curr_sum = arr [ start ] NEW_LINE if curr_sum > x : NEW_LINE INDENT return 1 NEW_LINE DEDENT for end in range ( start + 1 , n ) : NEW_LINE INDENT curr_sum += arr [ end ] NEW_LINE if ( curr_sum > x and ( end - start + 1 ) < min_len ) : NEW_LINE INDENT min_len = ( end - start + 1 ) NEW_LINE DEDENT DEDENT DEDENT return min_len NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr1 = [ 1 , 4 , 45 , 6 , 10 , 19 ] NEW_LINE x = 51 NEW_LINE n1 = len ( arr1 ) NEW_LINE res1 = smallestSubWithSum ( arr1 , n1 , x ) NEW_LINE print ( \" Not ▁ Possible \" ) if ( res1 == n1 + 1 ) else print ( res1 ) NEW_LINE arr2 = [ 1 , 10 , 5 , 2 , 7 ] NEW_LINE n2 = len ( arr2 ) NEW_LINE x = 9 NEW_LINE res2 = smallestSubWithSum ( arr2 , n2 , x ) NEW_LINE print ( \" Not ▁ possible \" ) if ( res2 == n2 + 1 ) : NEW_LINE INDENT print ( \" Not ▁ Possible \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res1 ) NEW_LINE DEDENT arr2 = [ 1 , 11 , 100 , 1 , 0 , 100 , 3 , 2 , 1 , 250 ] NEW_LINE n3 = len ( arr3 ) NEW_LINE x = 280 NEW_LINE res3 = smallestSubWithSum ( arr3 , n3 , x ) NEW_LINE print ( \" Not ▁ possible \" ) if ( res3 == n3 + 1 ) : NEW_LINE INDENT print ( \" Not ▁ Possible \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res3 + 1 ) NEW_LINE DEDENT arr3"],"references":["def smallestSubWithSum ( arr , n , x ) : NEW_LINE INDENT min_len = n + 1 NEW_LINE for start in range ( 0 , n ) : NEW_LINE INDENT curr_sum = arr [ start ] NEW_LINE if ( curr_sum > x ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT for end in range ( start + 1 , n ) : NEW_LINE INDENT curr_sum += arr [ end ] NEW_LINE if curr_sum > x and ( end - start + 1 ) < min_len : NEW_LINE INDENT min_len = ( end - start + 1 ) NEW_LINE DEDENT DEDENT DEDENT return min_len ; NEW_LINE DEDENT arr1 = [ 1 , 4 , 45 , 6 , 10 , 19 ] NEW_LINE x = 51 NEW_LINE n1 = len ( arr1 ) NEW_LINE res1 = smallestSubWithSum ( arr1 , n1 , x ) ; NEW_LINE if res1 == n1 + 1 : NEW_LINE INDENT print ( \" Not ▁ possible \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res1 ) NEW_LINE DEDENT arr2 = [ 1 , 10 , 5 , 2 , 7 ] NEW_LINE n2 = len ( arr2 ) NEW_LINE x = 9 NEW_LINE res2 = smallestSubWithSum ( arr2 , n2 , x ) ; NEW_LINE if res2 == n2 + 1 : NEW_LINE INDENT print ( \" Not ▁ possible \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res2 ) NEW_LINE DEDENT arr3 = [ 1 , 11 , 100 , 1 , 0 , 200 , 3 , 2 , 1 , 250 ] NEW_LINE n3 = len ( arr3 ) NEW_LINE x = 280 NEW_LINE res3 = smallestSubWithSum ( arr3 , n3 , x ) NEW_LINE if res3 == n3 + 1 : NEW_LINE INDENT print ( \" Not ▁ possible \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res3 ) NEW_LINE DEDENT"],"bleu":0.7947959942181683,"rouge_l":0.883522583901085}
{"id":1556,"predictions":["from math import sqrt NEW_LINE def getSum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sqrt = sqrt ( arr [ i ] ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT x = arr [ j ] NEW_LINE if ( x == sqrtCurrent ) : NEW_LINE INDENT sum += ( sqrtCurrent * sqrtCurrent ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT return sum NEW_LINE DEDENT arr = [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( getSum ( arr , n ) ) NEW_LINE"],"references":["import math NEW_LINE def getSum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sqrtCurrent = math . sqrt ( arr [ i ] ) NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT x = arr [ j ] NEW_LINE if ( x == sqrtCurrent ) : NEW_LINE INDENT sum += ( sqrtCurrent * sqrtCurrent ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT return int ( sum ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( getSum ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.7425083462465581,"rouge_l":0.8752339363693075}
{"id":1557,"predictions":["def findCountOfPairs ( a , b , n ) : NEW_LINE INDENT ans = 0 ; NEW_LINE ans += n * ( a \/\/ n ) * ( b \/\/ n ) ; NEW_LINE ans += ( a \/\/ n ) * ( b % n ) ; NEW_LINE ans += ( a % n ) * ( b % n ) ; NEW_LINE ans += ( ( a % n ) + ( b % n ) ) \/\/ n ; NEW_LINE return int ( ans ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 5 ; b = 13 ; NEW_LINE n = 3 ; NEW_LINE print ( findCountOfPairs ( a , b , n ) ) ; NEW_LINE DEDENT"],"references":["def findCountOfPairs ( a , b , n ) : NEW_LINE INDENT ans = 0 NEW_LINE ans += n * int ( a \/ n ) * int ( b \/ n ) NEW_LINE ans += int ( a \/ n ) * ( b % n ) NEW_LINE ans += ( a % n ) * int ( b \/ n ) NEW_LINE ans += int ( ( ( a % n ) + ( b % n ) ) \/ n ) ; NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 5 NEW_LINE b = 13 NEW_LINE n = 3 NEW_LINE print ( findCountOfPairs ( a , b , n ) ) NEW_LINE DEDENT"],"bleu":0.6513970898779686,"rouge_l":0.8870763783510369}
{"id":1558,"predictions":["def bsearch ( prefixsum , n , k ) : NEW_LINE INDENT ans = - 1 NEW_LINE left = 1 NEW_LINE right = n NEW_LINE while ( left <= right ) : NEW_LINE INDENT mid = int ( ( left + right ) \/ 2 ) NEW_LINE for i in range ( mid , n + 1 ) : NEW_LINE INDENT if ( prefixsum [ i ] - prefixsum [ i - mid ] > k ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( i == n + 1 ) : NEW_LINE INDENT left = mid + 1 NEW_LINE ans = mid NEW_LINE DEDENT else : NEW_LINE INDENT right = mid - 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def maxSize ( arr , n , k ) : NEW_LINE INDENT prefixsum = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT prefixsum [ i + 1 ] = prefixsum [ i ] + arr [ i ] NEW_LINE DEDENT return bsearch ( prefixsum , n , k ) NEW_LINE DEDENT arr = [ 1 , 2 , 10 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE k = 14 NEW_LINE print ( maxSize ( arr , n , k ) ) NEW_LINE"],"references":["def bsearch ( prefixsum , n , k ) : NEW_LINE INDENT ans , left , right = - 1 , 1 , n NEW_LINE while ( left <= right ) : NEW_LINE INDENT mid = ( left + right ) \/\/ 2 NEW_LINE for i in range ( mid , n + 1 ) : NEW_LINE INDENT if ( prefixsum [ i ] - prefixsum [ i - mid ] > k ) : NEW_LINE INDENT i = i - 1 NEW_LINE break NEW_LINE DEDENT DEDENT i = i + 1 NEW_LINE if ( i == n + 1 ) : NEW_LINE INDENT left = mid + 1 NEW_LINE ans = mid NEW_LINE DEDENT else : NEW_LINE INDENT right = mid - 1 NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT def maxSize ( arr , n , k ) : NEW_LINE INDENT prefixsum = [ 0 for x in range ( n + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT prefixsum [ i + 1 ] = prefixsum [ i ] + arr [ i ] NEW_LINE DEDENT return bsearch ( prefixsum , n , k ) ; NEW_LINE DEDENT arr = [ 1 , 2 , 10 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE k = 14 NEW_LINE print ( maxSize ( arr , n , k ) ) NEW_LINE"],"bleu":0.8210855652360416,"rouge_l":0.9084826246492552}
{"id":1559,"predictions":["def isprime ( x ) : NEW_LINE INDENT for i in range ( 2 , math . sqrt ( x ) ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT return false ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT def isSumOfKprimes ( N , K ) : NEW_LINE INDENT if ( N < 2 * K ) : NEW_LINE INDENT return false ; NEW_LINE DEDENT if ( K == 1 ) : NEW_LINE INDENT if ( N % 2 == 0 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return isprime ( N - 2 ) ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 10 ; NEW_LINE k = 2 ; NEW_LINE if ( isSumOfKprimes ( n , k ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"],"references":["def isprime ( x ) : NEW_LINE INDENT i = 2 NEW_LINE while ( i * i <= x ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT def isSumOfKprimes ( N , K ) : NEW_LINE INDENT if ( N < 2 * K ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( K == 1 ) : NEW_LINE INDENT return isprime ( N ) NEW_LINE DEDENT if ( K == 2 ) : NEW_LINE INDENT if ( N % 2 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return isprime ( N - 2 ) ; NEW_LINE DEDENT return 1 NEW_LINE DEDENT n = 10 NEW_LINE k = 2 NEW_LINE if ( isSumOfKprimes ( n , k ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.6849278089066236,"rouge_l":0.8087464133768676}
{"id":1560,"predictions":["def CountCharacters ( string , k ) : NEW_LINE INDENT cnt = 0 NEW_LINE l = len ( string ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( string [ i ] < k ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" GeeksForGeeks \" NEW_LINE k = 90 NEW_LINE count = CountCharacters ( string , k ) NEW_LINE print ( \" Characters ▁ with ▁ ASCII ▁ values ▁ less ▁ than ▁ K ▁ are \" , count ) NEW_LINE print ( \"Characters ▁ with ▁ ASCII ▁ values ▁ less ▁ than ▁ or ▁ equal ▁ to ▁ K ▁ are ▁ \" , ( len ( string ) - count ) ) NEW_LINE DEDENT"],"references":["def CountCharacters ( str , k ) : NEW_LINE INDENT cnt = 0 NEW_LINE l = len ( str ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( ord ( str [ i ] ) < k ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" GeeksForGeeks \" NEW_LINE k = 90 NEW_LINE count = CountCharacters ( str , k ) NEW_LINE print ( \" Characters ▁ with ▁ ASCII ▁ values \" , \" less ▁ than ▁ K ▁ are \" , count ) NEW_LINE print ( \" Characters ▁ with ▁ ASCII ▁ values \" , \" greater ▁ than ▁ or ▁ equal ▁ to ▁ K ▁ are \" , len ( str ) - count ) NEW_LINE DEDENT"],"bleu":0.7536273735165171,"rouge_l":0.8921883656509696}
{"id":1561,"predictions":["def printUncommon ( arr1 , arr2 , n1 , n2 ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE k = 0 NEW_LINE while ( i < n1 and j < n2 ) : NEW_LINE INDENT if ( arr1 [ i ] < arr2 [ j ] ) : NEW_LINE INDENT print ( arr1 [ i ] , end = \" ▁ \" ) NEW_LINE i += 1 NEW_LINE DEDENT elif ( arr2 [ j ] < arr1 [ i ] ) : NEW_LINE INDENT print ( arr2 [ j ] , end = \" ▁ \" ) NEW_LINE k += 1 NEW_LINE j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT while ( i < n - 1 ) : NEW_LINE INDENT print ( arr1 [ i ] , end = \" ▁ \" ) NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT arr1 = [ 10 , 0 , 0 , 0 ] NEW_LINE arr2 = [ 20 , 5 , 20 , 0 , 0 ] NEW_LINE n = len ( arr1 ) NEW_LINE arr2 = [ 20 , 10 , 20 , 0 ] NEW_LINE printUncommon ( arr1 , arr2 , n ) NEW_LINE"],"references":["def printUncommon ( arr1 , arr2 , n1 , n2 ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE k = 0 NEW_LINE while ( i < n1 and j < n2 ) : NEW_LINE INDENT if ( arr1 [ i ] < arr2 [ j ] ) : NEW_LINE INDENT print ( arr1 [ i ] , end = \" ▁ \" ) NEW_LINE i = i + 1 NEW_LINE k = k + 1 NEW_LINE DEDENT elif ( arr2 [ j ] < arr1 [ i ] ) : NEW_LINE INDENT print ( arr2 [ j ] , end = \" ▁ \" ) NEW_LINE k = k + 1 NEW_LINE j = j + 1 NEW_LINE DEDENT else : NEW_LINE INDENT i = i + 1 NEW_LINE j = j + 1 NEW_LINE DEDENT DEDENT while ( i < n1 ) : NEW_LINE INDENT print ( arr1 [ i ] , end = \" ▁ \" ) NEW_LINE i = i + 1 NEW_LINE k = k + 1 NEW_LINE DEDENT while ( j < n2 ) : NEW_LINE INDENT print ( arr2 [ j ] , end = \" ▁ \" ) NEW_LINE j = j + 1 NEW_LINE k = k + 1 NEW_LINE DEDENT DEDENT arr1 = [ 10 , 20 , 30 ] NEW_LINE arr2 = [ 20 , 25 , 30 , 40 , 50 ] NEW_LINE n1 = len ( arr1 ) NEW_LINE n2 = len ( arr2 ) NEW_LINE printUncommon ( arr1 , arr2 , n1 , n2 ) NEW_LINE"],"bleu":0.6050580998821188,"rouge_l":0.7574571467134565}
{"id":1562,"predictions":["def findExtraCharacter ( s1 , s2 ) : NEW_LINE INDENT if ( len ( s1 ) > len ( s2 ) ) : NEW_LINE INDENT smallStr = s2 NEW_LINE smallStr = s1 NEW_LINE largeStr = s2 NEW_LINE DEDENT smallStrcodeBase = 0 NEW_LINE largeStr = 0 NEW_LINE i = 0 NEW_LINE while ( smallStr ) : NEW_LINE INDENT smallStrCount += smallStr [ i ] NEW_LINE largeStrCount += largeStr [ i ] NEW_LINE i += 1 NEW_LINE DEDENT largeStrBase += smallStr [ i ] NEW_LINE return chrCost NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s1 = \" abcd \" NEW_LINE s2 = \" cbdae \" NEW_LINE largeStr = findExtraChar ( s1 , s2 ) NEW_LINE print ( \" Index ▁ ch : \" , largeChar ) NEW_LINE DEDENT"],"references":["def findExtraCharacter ( s1 , s2 ) : NEW_LINE INDENT smallStr = \" \" NEW_LINE largeStr = \" \" NEW_LINE if ( len ( s1 ) > len ( s2 ) ) : NEW_LINE INDENT smallStr = s2 NEW_LINE largeStr = s1 NEW_LINE DEDENT else : NEW_LINE INDENT smallStr = s1 NEW_LINE largeStr = s2 NEW_LINE DEDENT smallStrCodeTotal = 0 NEW_LINE largeStrCodeTotal = 0 NEW_LINE i = 0 NEW_LINE while ( i < len ( smallStr ) ) : NEW_LINE INDENT smallStrCodeTotal += ord ( smallStr [ i ] ) NEW_LINE largeStrCodeTotal += ord ( largeStr [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT largeStrCodeTotal += ord ( largeStr [ i ] ) NEW_LINE intChar = largeStrCodeTotal - smallStrCodeTotal NEW_LINE return chr ( intChar ) NEW_LINE DEDENT s1 = \" abcd \" NEW_LINE s2 = \" cbdae \" NEW_LINE extraChar = findExtraCharacter ( s1 , s2 ) NEW_LINE print ( \" Extra ▁ Character : \" , extraChar ) NEW_LINE"],"bleu":0.5096214088827549,"rouge_l":0.7174907427575692}
{"id":1563,"predictions":["def sortMat ( data , row , col ) : NEW_LINE INDENT size = row * col NEW_LINE for i in range ( size ) : NEW_LINE INDENT for j in range ( size - 1 ) : NEW_LINE INDENT if ( data [ j \/\/ col ] [ j % col ] > data [ ( j + 1 ) \/\/ col ] [ ( j + 1 ) % col ] ) : NEW_LINE INDENT temp = data [ j \/\/ col ] [ j % col ] NEW_LINE data [ j % col ] [ j % col ] = data [ ( j + 1 ) \/\/ col ] [ ( j + 1 ) % col ] [ ( j + 1 ) % col ] = temp NEW_LINE DEDENT DEDENT DEDENT def printMat ( mat , row , col ) : NEW_LINE INDENT for i in range ( row ) : NEW_LINE INDENT for j in range ( col ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( \" \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT mat = [ [ 5 , 4 , 7 ] , [ 1 , 3 , 8 ] , [ 2 , 9 , 6 ] ] NEW_LINE row = len ( mat [ 0 ] ) NEW_LINE col = len ( mat [ 0 ] ) NEW_LINE sortMat ( mat , row , col ) NEW_LINE printMat ( mat , row , col ) NEW_LINE DEDENT"],"references":["def sortMat ( data , row , col ) : NEW_LINE INDENT size = row * col NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT for j in range ( 0 , size - 1 ) : NEW_LINE INDENT if ( data [ j \/\/ col ] [ j % col ] > \\ data [ ( j + 1 ) \/\/ col ] [ ( j + 1 ) % col ] ) : NEW_LINE INDENT temp = data [ j \/\/ col ] [ j % col ] NEW_LINE data [ j \/\/ col ] [ j % col ] = \\ NEW_LINE INDENT data [ ( j + 1 ) \/\/ col ] [ ( j + 1 ) % col ] NEW_LINE DEDENT data [ ( j + 1 ) \/\/ col ] [ ( j + 1 ) % col ] = \\ NEW_LINE INDENT temp NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def printMat ( mat , row , col ) : NEW_LINE INDENT for i in range ( row ) : NEW_LINE INDENT for j in range ( col ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT mat = [ [ 5 , 4 , 7 ] , [ 1 , 3 , 8 ] , [ 2 , 9 , 6 ] ] NEW_LINE row = len ( mat ) NEW_LINE col = len ( mat [ 0 ] ) NEW_LINE sortMat ( mat , row , col ) NEW_LINE printMat ( mat , row , col ) NEW_LINE DEDENT"],"bleu":0.8697230207974246,"rouge_l":0.937925121463275}
{"id":1564,"predictions":["def distinctDigitSum ( n ) : NEW_LINE INDENT visited = [ False ] * 10 NEW_LINE sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT digit = n % 10 NEW_LINE if ( not visited [ digit ] ) : NEW_LINE INDENT used [ digit ] = True NEW_LINE sum += digit NEW_LINE DEDENT n = n \/\/ 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT def checkSum ( m , n ) : NEW_LINE INDENT sumM = distinctDigitSum ( m ) NEW_LINE sumN = distinctDigitSum ( n ) NEW_LINE if ( sumM == sumN ) : NEW_LINE INDENT return \" YES \" NEW_LINE DEDENT return \" NO \" NEW_LINE DEDENT m = 24122 NEW_LINE n = 9122 NEW_LINE print ( checkSum ( m , n ) ) NEW_LINE"],"references":["def distinctDigitSum ( n ) : NEW_LINE INDENT used = [ False ] * 10 NEW_LINE sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT digit = n % 10 NEW_LINE if ( not used [ digit ] ) : NEW_LINE INDENT used [ digit ] = True NEW_LINE sum += digit NEW_LINE DEDENT n = n \/\/ 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT def checkSum ( m , n ) : NEW_LINE INDENT sumM = distinctDigitSum ( m ) NEW_LINE sumN = distinctDigitSum ( n ) NEW_LINE if ( sumM == sumN ) : NEW_LINE INDENT return \" YES \" NEW_LINE DEDENT return \" NO \" NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT m = 2452 NEW_LINE n = 9222 NEW_LINE print ( checkSum ( m , n ) ) NEW_LINE DEDENT"],"bleu":0.8213023879462841,"rouge_l":0.9125759700794764}
{"id":1565,"predictions":["def initializeDiffArray ( A , D ) : NEW_LINE INDENT N = len ( A ) ; NEW_LINE D [ 0 ] = A [ 0 ] ; NEW_LINE D [ n ] = 0 ; NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT D [ i ] = A [ i ] - A [ i - 1 ] ; NEW_LINE D [ r + 1 ] -= x ; NEW_LINE DEDENT def printArray ( A , D ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT A [ i ] = D [ i ] ; NEW_LINE DEDENT else : NEW_LINE INDENT A [ i ] = D [ i ] + A [ i - 1 ] ; NEW_LINE DEDENT printArray ( A , end = \" ▁ \" ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 15 , 5 , 20 ] ; NEW_LINE n = len ( A ) ; NEW_LINE D = [ 0 ] * ( n + 1 ) ; NEW_LINE initializeDiffArray ( A , D ) ; NEW_LINE updateDiffArray ( A , 0 , 1 , 10 ) ; NEW_LINE printArray ( A , 2 , 2 , 32 ) ; NEW_LINE printArray ( A , 2 , 2 , 30 ) ; NEW_LINE printArray ( A , 2 , 2 , 32 ) ; NEW_LINE DEDENT"],"references":["def initializeDiffArray ( A ) : NEW_LINE INDENT n = len ( A ) NEW_LINE D = [ 0 for i in range ( 0 , n + 1 ) ] NEW_LINE D [ 0 ] = A [ 0 ] ; D [ n ] = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT D [ i ] = A [ i ] - A [ i - 1 ] NEW_LINE DEDENT return D NEW_LINE DEDENT def update ( D , l , r , x ) : NEW_LINE INDENT D [ l ] += x NEW_LINE D [ r + 1 ] -= x NEW_LINE DEDENT def printArray ( A , D ) : NEW_LINE INDENT for i in range ( 0 , len ( A ) ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT A [ i ] = D [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT A [ i ] = D [ i ] + A [ i - 1 ] NEW_LINE DEDENT print ( A [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( \" \" ) NEW_LINE DEDENT A = [ 10 , 5 , 20 , 40 ] NEW_LINE D = initializeDiffArray ( A ) NEW_LINE update ( D , 0 , 1 , 10 ) NEW_LINE printArray ( A , D ) NEW_LINE update ( D , 1 , 3 , 20 ) NEW_LINE update ( D , 2 , 2 , 30 ) NEW_LINE printArray ( A , D ) NEW_LINE"],"bleu":0.5973059378929221,"rouge_l":0.719473586194053}
{"id":1566,"predictions":["MAX = 100 ; NEW_LINE def printPrincipalDiagonal ( mat , n ) : NEW_LINE INDENT print ( \" Principal ▁ Diagonal : ▁ \" , end = \" \" ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = \" , ▁ \" ) ; NEW_LINE DEDENT DEDENT DEDENT print ( \" \" ) ; NEW_LINE DEDENT def printPrincipalDiagonal ( mat , n ) : NEW_LINE INDENT print ( \" Principal ▁ Diagonal : ▁ \" , end = \" \" ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( mat [ j ] == 1 ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = \" , ▁ \" ) ; NEW_LINE DEDENT DEDENT print ( \" \" ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 ; NEW_LINE a = [ [ 1 , 2 , 3 , 4 ] , [ 5 , 6 , 7 , 8 ] , [ 5 , 6 , 7 , 8 ] , [ 1 , 2 , 3 , 4 ] , [ 5 , 6 , 7 , 8 ] ] ; NEW_LINE printPrincipalDiagonal ( a , n ) ; NEW_LINE printPrincipalDiagonal ( a , n ) ; NEW_LINE DEDENT"],"references":["MAX = 100 NEW_LINE def printPrincipalDiagonal ( mat , n ) : NEW_LINE INDENT print ( \" Principal ▁ Diagonal : ▁ \" , end = \" \" ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = \" , ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT print ( ) NEW_LINE DEDENT def printSecondaryDiagonal ( mat , n ) : NEW_LINE INDENT print ( \" Secondary ▁ Diagonal : ▁ \" , end = \" \" ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( ( i + j ) == ( n - 1 ) ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = \" , ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT print ( ) NEW_LINE DEDENT n = 4 NEW_LINE a = [ [ 1 , 2 , 3 , 4 ] , [ 5 , 6 , 7 , 8 ] , [ 1 , 2 , 3 , 4 ] , [ 5 , 6 , 7 , 8 ] ] NEW_LINE printPrincipalDiagonal ( a , n ) NEW_LINE printSecondaryDiagonal ( a , n ) NEW_LINE"],"bleu":0.723115307701047,"rouge_l":0.893699494119966}
{"id":1567,"predictions":["import sys ; NEW_LINE def FindMinNumber ( arr , n , k ) : NEW_LINE INDENT i = 0 ; NEW_LINE j = 0 ; NEW_LINE min_num = sys . maxsize ; NEW_LINE found = False ; NEW_LINE while ( i < n ) : NEW_LINE INDENT sum = sum + arr [ i ] ; NEW_LINE if ( sum == k ) : NEW_LINE INDENT min_num = min ( min_num , ( ( n - ( i + 1 ) ) + j ) ) ; NEW_LINE found = True ; NEW_LINE DEDENT elif ( sum > k ) : NEW_LINE INDENT while ( sum > k ) : NEW_LINE INDENT sum = sum - arr [ j ] ; NEW_LINE j += 1 ; NEW_LINE DEDENT if ( sum == k ) : NEW_LINE INDENT min_num = min ( min_num , ( ( n - ( i + 1 ) ) + j ) ) ; NEW_LINE found = True ; NEW_LINE DEDENT DEDENT i += 1 ; NEW_LINE DEDENT if ( found ) : NEW_LINE INDENT return min_num ; NEW_LINE DEDENT if ( found ) : NEW_LINE INDENT return min_num ; NEW_LINE DEDENT return - 1 ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 3 , 2 , 5 , 6 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE k = 5 ; NEW_LINE print ( FindMinNumber ( arr , n , k ) ) ; NEW_LINE DEDENT"],"references":["def FindMinNumber ( arr , n , k ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE min_num = 10 ** 9 NEW_LINE found = False NEW_LINE Sum = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT Sum = Sum + arr [ i ] NEW_LINE if ( Sum == k ) : NEW_LINE INDENT min_num = min ( min_num , ( ( n - ( i + 1 ) ) + j ) ) NEW_LINE found = True NEW_LINE DEDENT elif ( Sum > k ) : NEW_LINE INDENT while ( Sum > k ) : NEW_LINE INDENT Sum = Sum - arr [ j ] NEW_LINE j += 1 NEW_LINE DEDENT if ( Sum == k ) : NEW_LINE INDENT min_num = min ( min_num , ( ( n - ( i + 1 ) ) + j ) ) NEW_LINE found = True NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT if ( found ) : NEW_LINE INDENT return min_num NEW_LINE DEDENT return - 1 NEW_LINE DEDENT arr = [ 1 , 3 , 2 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE k = 5 NEW_LINE print ( FindMinNumber ( arr , n , k ) ) NEW_LINE"],"bleu":0.6124934579669179,"rouge_l":0.8570212162066274}
{"id":1568,"predictions":["def minProduct ( arr , n , k ) : NEW_LINE INDENT pq = [ ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT pq . append ( arr [ i ] ) NEW_LINE DEDENT count = 0 NEW_LINE ans = 1 NEW_LINE while ( len ( pq ) > 0 and count < k ) : NEW_LINE INDENT ans = ans * pq [ 0 ] NEW_LINE pq . pop ( 0 ) NEW_LINE count += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ _ main _ _ ' : NEW_LINE INDENT arr = [ 75 , 76 , 544 , 123 , 6 , 6 , ] NEW_LINE k = 2 NEW_LINE n = len ( arr ) NEW_LINE print ( \" Minimum ▁ product ▁ is \" , minProduct ( arr , n , k ) ) NEW_LINE DEDENT"],"references":["import math NEW_LINE import heapq NEW_LINE def minProduct ( arr , n , k ) : NEW_LINE INDENT heapq . heapify ( arr ) NEW_LINE count = 0 NEW_LINE ans = 1 NEW_LINE while ( arr ) and count < k : NEW_LINE INDENT x = heapq . heappop ( arr ) NEW_LINE ans = ans * x NEW_LINE count = count + 1 NEW_LINE DEDENT return ans ; NEW_LINE DEDENT arr = [ 198 , 76 , 544 , 123 , 154 , 675 ] NEW_LINE k = 2 NEW_LINE n = len ( arr ) NEW_LINE print ( \" Minimum ▁ product ▁ is \" , minProduct ( arr , n , k ) ) NEW_LINE"],"bleu":0.4796692254202389,"rouge_l":0.6973161033797217}
{"id":1569,"predictions":["class SumSetBits ( object ) : NEW_LINE INDENT def __init__ ( self , size ) : NEW_LINE INDENT self . BitSet = [ 0 ] * 256 NEW_LINE for i in range ( 0 , 256 ) : NEW_LINE INDENT bitsSet [ i ] = ( i & 1 ) + bitsSetTable [ int ( i \/ 2 ) ] ) NEW_LINE DEDENT DEDENT def countSetBits ( n ) : NEW_LINE INDENT global BITSetBits ( n ) NEW_LINE n = 9 NEW_LINE print ( countSetBits ( n >> 8 ) & 0.8 ) NEW_LINE"],"references":["BitsSetTable256 = [ 0 ] * 256 NEW_LINE def initialize ( ) : NEW_LINE INDENT BitsSetTable256 [ 0 ] = 0 NEW_LINE for i in range ( 256 ) : NEW_LINE INDENT BitsSetTable256 [ i ] = ( i & 1 ) + BitsSetTable256 [ i \/\/ 2 ] NEW_LINE DEDENT DEDENT def countSetBits ( n ) : NEW_LINE INDENT return ( BitsSetTable256 [ n & 0xff ] + BitsSetTable256 [ ( n >> 8 ) & 0xff ] + BitsSetTable256 [ ( n >> 16 ) & 0xff ] + BitsSetTable256 [ n >> 24 ] ) NEW_LINE DEDENT initialize ( ) NEW_LINE n = 9 NEW_LINE print ( countSetBits ( n ) ) NEW_LINE"],"bleu":0.4472664167846839,"rouge_l":0.5795280416794361}
{"id":1570,"predictions":["def numberOfBST ( n ) : NEW_LINE INDENT dp = [ 0 ] * ( n + 1 ) ; NEW_LINE dp [ 0 ] = 1 ; NEW_LINE dp [ 1 ] = 1 ; NEW_LINE dp [ 1 ] = 1 ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT dp [ i ] = dp [ i ] + ( dp [ i - j ] * dp [ j - 1 ] ) ; NEW_LINE DEDENT DEDENT return dp [ n ] ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 ; NEW_LINE print ( \" Number ▁ of ▁ mi ▁ BST ▁ with ▁ BST ▁ with ▁ \" , n , \" k ▁ are \" , numberOfBST ( n ) ) ; NEW_LINE DEDENT"],"references":["def numberOfBST ( n ) : NEW_LINE INDENT dp = [ 0 ] * ( n + 1 ) NEW_LINE dp [ 0 ] , dp [ 1 ] = 1 , 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT dp [ i ] = dp [ i ] + ( dp [ i - j ] * dp [ j - 1 ] ) NEW_LINE DEDENT DEDENT return dp [ n ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE print ( \" Number ▁ of ▁ structurally ▁ Unique ▁ BST ▁ with \" , n , \" keys ▁ are ▁ : \" , numberOfBST ( n ) ) NEW_LINE DEDENT"],"bleu":0.7475697428733539,"rouge_l":0.9117113269990391}
{"id":1571,"predictions":["def countdig ( m ) : NEW_LINE INDENT if ( m == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 + countdig ( int ( m \/ 10 ) ) NEW_LINE DEDENT DEDENT def countSteps ( x ) : NEW_LINE INDENT c = 0 NEW_LINE last = x NEW_LINE while ( last ) : NEW_LINE INDENT digits = countdig ( last ) NEW_LINE digits -= 1 NEW_LINE divisor = first * divisor NEW_LINE lastnumber = first * divisor NEW_LINE skipped = ( last - lastnumber ) \/\/ first NEW_LINE skipped += 1 NEW_LINE c += skipped NEW_LINE last = last - ( first * skipped ) NEW_LINE DEDENT return c NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 14 NEW_LINE print ( countSteps ( n ) ) NEW_LINE DEDENT"],"references":["def countdig ( m ) : NEW_LINE INDENT if ( m == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 + countdig ( m \/\/ 10 ) NEW_LINE DEDENT DEDENT def countSteps ( x ) : NEW_LINE INDENT c = 0 NEW_LINE last = x NEW_LINE while ( last ) : NEW_LINE INDENT digits = countdig ( last ) NEW_LINE digits -= 1 NEW_LINE divisor = pow ( 10 , digits ) NEW_LINE first = last \/\/ divisor NEW_LINE lastnumber = first * divisor NEW_LINE skipped = ( last - lastnumber ) \/\/ first NEW_LINE skipped += 1 NEW_LINE c += skipped NEW_LINE last = last - ( first * skipped ) NEW_LINE DEDENT return c NEW_LINE DEDENT n = 14 NEW_LINE print ( countSteps ( n ) ) NEW_LINE"],"bleu":0.8291630718421672,"rouge_l":0.8982119901834754}
{"id":1572,"predictions":["def Add ( x , y ) : NEW_LINE INDENT while ( y != 0 ) : NEW_LINE INDENT carry = x & y NEW_LINE x = x ^ y NEW_LINE y = carry << 1 NEW_LINE DEDENT return x NEW_LINE DEDENT print ( Add ( 15 , 32 ) ) NEW_LINE"],"references":["def Add ( x , y ) : NEW_LINE INDENT while ( y != 0 ) : NEW_LINE INDENT carry = x & y NEW_LINE x = x ^ y NEW_LINE y = carry << 1 NEW_LINE DEDENT return x NEW_LINE DEDENT print ( Add ( 15 , 32 ) ) NEW_LINE"],"bleu":1.0,"rouge_l":1.0}
{"id":1573,"predictions":["def isOverflow ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT result = a * b NEW_LINE if ( a == result \/ b ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a , b = 0 , 1000000 NEW_LINE if ( isOverflow ( a , b ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def isOverflow ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT result = a * b NEW_LINE if ( result >= 9223372036854775807 or result <= - 9223372036854775808 ) : NEW_LINE INDENT result = 0 NEW_LINE DEDENT if ( a == ( result \/\/ b ) ) : NEW_LINE INDENT print ( result \/\/ b ) NEW_LINE return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 10000000000 NEW_LINE b = - 10000000000 NEW_LINE if ( isOverflow ( a , b ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.6503236974504388,"rouge_l":0.8117722328854766}
{"id":1574,"predictions":["def pairWithEqualSum ( A , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n , 1 ) : NEW_LINE INDENT p = [ A [ i ] , A [ j ] ] NEW_LINE pp = [ ] NEW_LINE if ( A [ i ] + A [ j ] in mp ) : NEW_LINE INDENT pp . append ( p ) NEW_LINE DEDENT pp . append ( p ) NEW_LINE mp [ A [ i ] + A [ j ] ] = pp NEW_LINE DEDENT DEDENT for pr in mp : NEW_LINE INDENT if ( len ( mp ) > 1 ) : NEW_LINE INDENT print ( \" Pairs ▁ : ▁ \" , end = \" \" ) NEW_LINE for i in range ( len ( mp ) ) : NEW_LINE INDENT print ( \" ▁ \" , ▁ \" , end = \" \" ) NEW_LINE DEDENT print ( \" ▁ ha : ▁ \" , end = \" \" ) NEW_LINE for i in mp : NEW_LINE INDENT print ( \" ( \" , mp [ i ] [ 0 ] , end = \" , ▁ \" ) ▁ \" ) NEW_LINE DEDENT print ( \" ▁ hav ▁ sum ▁ : ▁ \" , end = \" \" ) NEW_LINE DEDENT print ( \" ▁ hav : ▁ \" , end = \" \" ) NEW_LINE print ( \" ▁ \" ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 6 , 4 , 12 , 0 , 2 , 2 , 2 , 2 , 1 , 3 , 2 ] NEW_LINE n = len ( A ) NEW_LINE pairWithEqualSum ( A , n ) NEW_LINE DEDENT"],"references":["def pairWithEqualSum ( A , n ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if A [ i ] + A [ j ] in mp : NEW_LINE INDENT mp [ A [ i ] + A [ j ] ] . append ( ( A [ i ] , A [ j ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT mp [ A [ i ] + A [ j ] ] = [ ( A [ i ] , A [ j ] ) ] NEW_LINE DEDENT DEDENT DEDENT for itr in mp : NEW_LINE INDENT if len ( mp [ itr ] ) > 1 : NEW_LINE INDENT print ( \" Pairs ▁ : ▁ \" , end = \" \" ) NEW_LINE for i in range ( 0 , len ( mp [ itr ] ) ) : NEW_LINE INDENT print ( \" ( \" , mp [ itr ] [ i ] [ 0 ] , \" , \" , mp [ itr ] [ i ] [ 1 ] , \" ) \" , end = \" ▁ \" ) NEW_LINE DEDENT print ( \" have ▁ sum ▁ : \" , itr ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 6 , 4 , 12 , 10 , 22 , 54 , 32 , 42 , 21 , 11 , 8 , 2 ] NEW_LINE n = len ( A ) NEW_LINE pairWithEqualSum ( A , n ) NEW_LINE DEDENT"],"bleu":0.562027803944876,"rouge_l":0.694433802200208}
{"id":1575,"predictions":["def findSum ( m , n , mth , nth , p ) : NEW_LINE INDENT d = ( abs ( mth - nth ) ) \/\/ abs ( ( m - 1 ) - ( n - 1 ) ) NEW_LINE a = mth - ( ( m - 1 ) * d ) NEW_LINE res = [ a ] NEW_LINE return res NEW_LINE DEDENT def findSum ( m , n , mth , nth , p ) : NEW_LINE INDENT ad = FindValues ( m , n , mth , nth ) NEW_LINE a = ad [ 0 ] NEW_LINE d = ad [ 1 ] NEW_LINE sum = ( p * ( 2 * a + ( p - 1 ) * d ) ) \/\/ 2 NEW_LINE return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT m = 6 NEW_LINE n = 10 NEW_LINE mterm = 12 NEW_LINE n = 20 NEW_LINE p = 5 NEW_LINE print ( findSum ( m , n , mth , nth , nth , p ) ) NEW_LINE DEDENT"],"references":["import math as mt NEW_LINE def findingValues ( m , n , mth , nth ) : NEW_LINE INDENT d = ( ( abs ( mth - nth ) ) \/ abs ( ( m - 1 ) - ( n - 1 ) ) ) NEW_LINE a = mth - ( ( m - 1 ) * d ) NEW_LINE return a , d NEW_LINE DEDENT def findSum ( m , n , mth , nth , p ) : NEW_LINE INDENT a , d = findingValues ( m , n , mth , nth ) NEW_LINE Sum = ( p * ( 2 * a + ( p - 1 ) * d ) ) \/ 2 NEW_LINE return Sum NEW_LINE DEDENT m = 6 NEW_LINE n = 10 NEW_LINE mTerm = 12 NEW_LINE nTerm = 20 NEW_LINE p = 5 NEW_LINE print ( findSum ( m , n , mTerm , nTerm , p ) ) NEW_LINE"],"bleu":0.6269016962700095,"rouge_l":0.8008624820316242}
{"id":1576,"predictions":["def sameOccurrence ( arr , n , x , y ) : NEW_LINE INDENT countX = [ 0 ] * n ; NEW_LINE countY = [ 0 ] * n ; NEW_LINE m = dict . fromkeys ( arr , 0 ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == x ) : NEW_LINE INDENT if ( i != 0 ) : NEW_LINE INDENT countX [ i ] = countX [ i - 1 ] + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT countX [ i ] = 0 ; NEW_LINE DEDENT DEDENT if ( arr [ i ] == y ) : NEW_LINE INDENT if ( i != 0 ) : NEW_LINE INDENT countY [ i ] = countX [ i - 1 ] + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT countY [ i ] = 1 ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( i != 0 ) : NEW_LINE INDENT countY [ i ] = countY [ i - 1 ] + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT countY [ i ] = 0 ; NEW_LINE DEDENT DEDENT if ( countX [ i ] - countY [ i ] ) : NEW_LINE INDENT m [ countX [ i ] - countY [ i ] = m [ countX [ i ] - countY [ i ] ] + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT m [ countX [ i ] - countY [ i ] = 1 ; NEW_LINE DEDENT DEDENT result = m [ 0 ] ; NEW_LINE for it in m : NEW_LINE INDENT result = result + ( ( it [ it ] ) - countY [ i ] ) \/\/ 2 ) ; NEW_LINE DEDENT return ( result ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 2 , 3 , 4 , 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE x , y = 2 , 3 ; NEW_LINE print ( sameOccurrence ( arr , n , x ,"],"references":["def sameOccurrence ( arr , n , x , y ) : NEW_LINE INDENT countX = [ 0 for i in range ( n ) ] NEW_LINE countY = [ 0 for i in range ( n ) ] NEW_LINE m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == x ) : NEW_LINE INDENT if ( i != 0 ) : NEW_LINE INDENT countX [ i ] = countX [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT countX [ i ] = 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( i != 0 ) : NEW_LINE INDENT countX [ i ] = countX [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT countX [ i ] = 0 NEW_LINE DEDENT DEDENT if ( arr [ i ] == y ) : NEW_LINE INDENT if ( i != 0 ) : NEW_LINE INDENT countY [ i ] = countY [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT countY [ i ] = 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( i != 0 ) : NEW_LINE INDENT countY [ i ] = countY [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT countY [ i ] = 0 NEW_LINE DEDENT DEDENT m [ countX [ i ] - countY [ i ] ] = m . get ( countX [ i ] - countY [ i ] , 0 ) + 1 NEW_LINE DEDENT result = m [ 0 ] NEW_LINE for j in m : NEW_LINE INDENT result += ( m [ j ] * ( m [ j ] - 1 ) ) \/\/ 2 NEW_LINE DEDENT return result NEW_LINE DEDENT arr = [ 1 , 2 , 2 , 3 , 4 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE x , y = 2 , 3 NEW_LINE print ( sameOccurrence ( arr , n , x , y ) ) NEW_LINE"],"bleu":0.7008316655126,"rouge_l":0.7725430597771024}
{"id":1577,"predictions":["def findNonPalinString ( s ) : NEW_LINE INDENT freq = [ 0 ] * 26 ; NEW_LINE flag = 0 ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] != s [ 0 ] ) : NEW_LINE INDENT flag = 1 ; NEW_LINE DEDENT freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT if ( flag == 0 ) : NEW_LINE INDENT print ( - 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 26 ) : NEW_LINE INDENT for j in range ( freq [ i ] ) : NEW_LINE INDENT print ( chr ( ord ( ' a ' ) + i ) , end = \" \" ) ; NEW_LINE DEDENT DEDENT DEDENT s = \" abba \" ; NEW_LINE findNonPalinString ( s ) ; NEW_LINE"],"references":["def findNonPalinString ( s ) : NEW_LINE INDENT freq = [ 0 ] * ( 26 ) NEW_LINE flag = 0 NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT if s [ i ] != s [ 0 ] : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT if not flag : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 0 , 26 ) : NEW_LINE INDENT for j in range ( 0 , freq [ i ] ) : NEW_LINE INDENT print ( chr ( ord ( ' a ' ) + i ) , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" abba \" NEW_LINE findNonPalinString ( s ) NEW_LINE DEDENT"],"bleu":0.6983720624739025,"rouge_l":0.8701337295690936}
{"id":1578,"predictions":["def isFrequencyEqual ( str , length ) : NEW_LINE INDENT if ( length % 2 == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT freq = [ 0 ] * 26 NEW_LINE for i in range ( length ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( freq [ i ] == length \/ 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeksforgeeks \" NEW_LINE length = len ( str ) NEW_LINE if ( isFrequencyEqual ( str , length ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def isFrequencyEqual ( string , length ) : NEW_LINE INDENT if length % 2 == 1 : NEW_LINE INDENT return False NEW_LINE DEDENT freq = [ 0 ] * 26 NEW_LINE for i in range ( 0 , length ) : NEW_LINE INDENT freq [ ord ( string [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 0 , 26 ) : NEW_LINE INDENT if freq [ i ] == length \/\/ 2 : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" geeksforgeeks \" NEW_LINE length = len ( string ) NEW_LINE if isFrequencyEqual ( string , length ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.7929493679755377,"rouge_l":0.9301143583227448}
{"id":1579,"predictions":["import math ; NEW_LINE def summ ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( n % 9 == 0 ) : NEW_LINE INDENT return 9 or ( n % 9 ) ; NEW_LINE DEDENT DEDENT def printDigitalRoot ( n ) : NEW_LINE INDENT maxi = 1 ; NEW_LINE dig = 1 ; NEW_LINE for i in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT d1 = summ ( n \/ i ) ; NEW_LINE d2 = summ ( i ) ; NEW_LINE if ( d2 > maxi ) : NEW_LINE INDENT dig = n \/ i ; NEW_LINE maxi = d2 ; NEW_LINE DEDENT if ( d1 == maxi ) : NEW_LINE INDENT if ( dig < ( n \/\/ i ) ) : NEW_LINE INDENT dig = n \/ i ; NEW_LINE maxi = d2 ; NEW_LINE DEDENT DEDENT if ( d2 == maxi ) : NEW_LINE INDENT if ( dig < i ) : NEW_LINE INDENT dig = i ; NEW_LINE maxi = d2 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT printDigitalRoot ( n ) ; NEW_LINE"],"references":["def summ ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( n % 9 == 0 ) : NEW_LINE INDENT return 9 ; NEW_LINE DEDENT else : NEW_LINE INDENT return ( n % 9 ) ; NEW_LINE DEDENT DEDENT def printDigitalRoot ( n ) : NEW_LINE INDENT maxi = 1 ; NEW_LINE dig = 1 ; NEW_LINE for i in range ( 1 , int ( pow ( n , 1 \/ 2 ) + 1 ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT d1 = summ ( n \/ i ) ; NEW_LINE d2 = summ ( i ) ; NEW_LINE if ( d1 > maxi ) : NEW_LINE INDENT dig = n \/ i ; NEW_LINE maxi = d1 ; NEW_LINE DEDENT if ( d2 > maxi ) : NEW_LINE INDENT dig = i ; NEW_LINE maxi = d2 ; NEW_LINE DEDENT if ( d1 == maxi ) : NEW_LINE INDENT if ( dig < ( n \/ i ) ) : NEW_LINE INDENT dig = n \/ i ; NEW_LINE maxi = d1 ; NEW_LINE DEDENT DEDENT if ( d2 == maxi ) : NEW_LINE INDENT if ( dig < i ) : NEW_LINE INDENT dig = i ; NEW_LINE maxi = d2 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( int ( dig ) , \" ▁ \" , int ( maxi ) ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 ; NEW_LINE printDigitalRoot ( n ) ; NEW_LINE DEDENT"],"bleu":0.6760767132974779,"rouge_l":0.8042031066440414}
{"id":1580,"predictions":["def countSubarrays ( arr , n ) : NEW_LINE INDENT difference = 0 ; NEW_LINE ans = 0 ; NEW_LINE hash_positive = [ 0 ] * ( n + 1 ) ; NEW_LINE hash_positive [ 0 ] = 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT difference += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT difference -= 1 ; NEW_LINE DEDENT if ( difference < 0 ) : NEW_LINE INDENT ans += hash_negative [ - difference ] ; NEW_LINE hash_negative [ - difference ] += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT ans += hash_negative [ difference ] ; NEW_LINE hash_positive [ difference ] += 1 ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 4 , 6 , 8 , 1 , 10 , 5 , 7 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( \" Total ▁ Number ▁ of ▁ Even ▁ Numbers ▁ are \" , countSubarrays ( arr , n ) ) ; NEW_LINE DEDENT"],"references":["def countSubarrays ( arr , n ) : NEW_LINE INDENT difference = 0 NEW_LINE ans = 0 NEW_LINE hash_positive = [ 0 ] * ( n + 1 ) NEW_LINE hash_negative = [ 0 ] * ( n + 1 ) NEW_LINE hash_positive [ 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 == 1 ) : NEW_LINE INDENT difference = difference + 1 NEW_LINE DEDENT else : NEW_LINE INDENT difference = difference - 1 NEW_LINE DEDENT if ( difference < 0 ) : NEW_LINE INDENT ans += hash_negative [ - difference ] NEW_LINE hash_negative [ - difference ] = hash_negative [ - difference ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += hash_positive [ difference ] NEW_LINE hash_positive [ difference ] = hash_positive [ difference ] + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 3 , 4 , 6 , 8 , 1 , 10 , 5 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Total ▁ Number ▁ of ▁ Even - Odd ▁ subarrays ▁ are ▁ \" + str ( countSubarrays ( arr , n ) ) ) NEW_LINE"],"bleu":0.6444998823982473,"rouge_l":0.8101638301256562}
{"id":1581,"predictions":["MAX = 1000000 NEW_LINE prime = [ True for i in range ( MAX + 1 ) ] NEW_LINE def sieve ( ) : NEW_LINE INDENT prime [ 0 ] = prime [ 1 ] = False NEW_LINE for p in range ( MAX + 1 ) : NEW_LINE INDENT if ( p * p >= MAX ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( 2 * p , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def distinctSum ( arr1 , arr2 , m , n ) : NEW_LINE INDENT sieve ( ) NEW_LINE sumSet = set ( ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( prime [ arr1 [ i ] ] and prime [ arr2 [ j ] ] ) : NEW_LINE INDENT sumSet . add ( arr1 [ i ] + arr2 [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return len ( arr1 ) NEW_LINE DEDENT arr1 = [ 2 , 3 ] NEW_LINE arr2 = [ 2 , 4 , 7 ] NEW_LINE m = len ( arr1 ) NEW_LINE n = len ( arr2 ) NEW_LINE print ( distinctSum ( arr1 , arr2 , m , n ) ) NEW_LINE"],"references":["MAX = 1000000 NEW_LINE prime = [ True for i in range ( MAX + 1 ) ] NEW_LINE def sieve ( ) : NEW_LINE INDENT prime [ 0 ] , prime [ 1 ] = False , False NEW_LINE for p in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if p * p > MAX : NEW_LINE INDENT break NEW_LINE DEDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( 2 * p , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def distinctSum ( arr1 , arr2 , m , n ) : NEW_LINE INDENT sieve ( ) NEW_LINE sumSet = dict ( ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( prime [ arr1 [ i ] ] and prime [ arr2 [ j ] ] ) : NEW_LINE INDENT sumSet [ arr1 [ i ] + arr2 [ j ] ] = 1 NEW_LINE DEDENT DEDENT DEDENT return len ( sumSet ) NEW_LINE DEDENT arr1 = [ 2 , 3 ] NEW_LINE arr2 = [ 2 , 2 , 4 , 7 ] NEW_LINE m = len ( arr1 ) NEW_LINE n = len ( arr2 ) NEW_LINE print ( distinctSum ( arr1 , arr2 , m , n ) ) NEW_LINE"],"bleu":0.8871143013126725,"rouge_l":0.9492084877062984}
{"id":1582,"predictions":["def shufleArray ( a , n ) : NEW_LINE INDENT temp = n + 1 NEW_LINE j = n + 1 NEW_LINE done = 0 NEW_LINE while ( True ) : NEW_LINE INDENT if ( start == j ) : NEW_LINE INDENT start -= 1 NEW_LINE j -= 1 NEW_LINE DEDENT if ( j > n ) : NEW_LINE INDENT j = j - n NEW_LINE DEDENT if ( j > n ) : NEW_LINE INDENT j = j - n NEW_LINE DEDENT if ( j > n ) : NEW_LINE INDENT j = j - n NEW_LINE DEDENT if ( j > n ) : NEW_LINE INDENT j = j - n NEW_LINE DEDENT else : NEW_LINE INDENT j = 2 * i - 1 NEW_LINE DEDENT DEDENT DEDENT if ( a [ - 1 , 1 , 3 , 5 , 7 , 2 , 4 , 6 , 8 ] NEW_LINE n = len ( a ) NEW_LINE shufleArray ( a , n ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT print ( a [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT"],"references":["def shufleArray ( a , n ) : NEW_LINE INDENT n = n \/\/ 2 NEW_LINE start = n + 1 NEW_LINE j = n + 1 NEW_LINE for done in range ( 2 * n - 2 ) : NEW_LINE INDENT if ( start == j ) : NEW_LINE INDENT start -= 1 NEW_LINE j -= 1 NEW_LINE DEDENT i = j - n if j > n else j NEW_LINE j = 2 * i if j > n else 2 * i - 1 NEW_LINE a [ start ] , a [ j ] = a [ j ] , a [ start ] NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ - 1 , 1 , 3 , 5 , 7 , 2 , 4 , 6 , 8 ] NEW_LINE n = len ( a ) NEW_LINE shufleArray ( a , n ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT print ( a [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.615059890956285,"rouge_l":0.7020527355492571}
{"id":1583,"predictions":["MAX = 100005 NEW_LINE def Min_Replace ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE freq = [ 0 for i in range ( MAX ) ] NEW_LINE p = 0 NEW_LINE freq [ p ] = 1 NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i - 1 ] ) : NEW_LINE INDENT freq [ p ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ p ] += 1 NEW_LINE DEDENT DEDENT freq . sort ( reverse = True ) NEW_LINE ans = 0 NEW_LINE for i in range ( k , p + 1 ) : NEW_LINE INDENT ans += freq [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 7 , 8 , 2 , 3 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE print ( Min_Replace ( arr , n , k ) ) NEW_LINE DEDENT"],"references":["MAX = 100005 NEW_LINE def Min_Replace ( arr , n , k ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE freq = [ 0 for i in range ( MAX ) ] NEW_LINE p = 0 NEW_LINE freq [ p ] = 1 NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i - 1 ] ) : NEW_LINE INDENT freq [ p ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT p += 1 NEW_LINE freq [ p ] += 1 NEW_LINE DEDENT DEDENT freq . sort ( reverse = True ) NEW_LINE ans = 0 NEW_LINE for i in range ( k , p + 1 , 1 ) : NEW_LINE INDENT ans += freq [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 7 , 8 , 2 , 3 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE print ( Min_Replace ( arr , n , k ) ) NEW_LINE DEDENT"],"bleu":0.9359582488212354,"rouge_l":0.9733508800789604}
{"id":1584,"predictions":["MAX = 500 ; NEW_LINE size = 1 ; NEW_LINE def factorial ( prev , prev , n ) : NEW_LINE INDENT for x in range ( prev + 1 , n + 1 ) : NEW_LINE INDENT size = prev ( x , prevFact , size ) ; NEW_LINE DEDENT for i in range ( size - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( prev [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( \" ▁ \" , end = \" \" ) ; NEW_LINE DEDENT def printFactorials ( limit ) : NEW_LINE INDENT if ( remain < 1 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT a = 1 ; NEW_LINE b = 1 ; NEW_LINE c = 2 ; NEW_LINE print ( 1 ) ; NEW_LINE while ( c < l ) : NEW_LINE INDENT found = [ 0 ] * x + curr ; NEW_LINE prev = b ; NEW_LINE c = a + b ; NEW_LINE DEDENT DEDENT def factorials ( x , prev ) : NEW_LINE INDENT curr = 0 ; NEW_LINE for i in range ( size ) : NEW_LINE INDENT prev = prev + pre [ i ] * x + curr ; NEW_LINE prev = prev + b ; NEW_LINE c = a + b ; NEW_LINE DEDENT DEDENT def factorial ( x , prev ) : NEW_LINE INDENT x = 0 ; NEW_LINE while ( x != 0 ) : NEW_LINE INDENT prev = prev + 1 = curr [ x ] * x + y ; NEW_LINE prev = x + y ; NEW_LINE y = y ; NEW_LINE return x ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT mini = 20 ; NEW_LINE printFactorials ( LIM ) ; NEW_LINE DEDENT"],"references":["MAX = 500 NEW_LINE size = 1 NEW_LINE def factorial ( prevFact , prev , n ) : NEW_LINE INDENT global size NEW_LINE for x in range ( ( prev + 1 ) , n + 1 ) : NEW_LINE INDENT size = multiply ( x , prevFact , size ) NEW_LINE DEDENT for i in range ( ( size - 1 ) , - 1 , - 1 ) : NEW_LINE INDENT print ( prevFact [ i ] , end = \" \" ) NEW_LINE DEDENT print ( end = \" ▁ \" ) NEW_LINE DEDENT def printfibFactorials ( limit ) : NEW_LINE INDENT if ( limit < 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT a = 1 NEW_LINE b = 1 NEW_LINE c = 2 NEW_LINE print ( a , b , end = \" ▁ \" ) NEW_LINE prevFact = [ 0 ] * MAX NEW_LINE prevFact [ 0 ] = 1 NEW_LINE while ( c < limit ) : NEW_LINE INDENT factorial ( prevFact , b , c ) NEW_LINE a = b NEW_LINE b = c NEW_LINE c = a + b NEW_LINE DEDENT DEDENT def multiply ( x , prevFact , size ) : NEW_LINE INDENT carry = 0 NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT prod = prevFact [ i ] * x + carry NEW_LINE prevFact [ i ] = prod % 10 NEW_LINE carry = prod \/\/ 10 NEW_LINE DEDENT while ( carry != 0 ) : NEW_LINE INDENT prevFact [ size ] = carry % 10 NEW_LINE carry = carry \/\/ 10 NEW_LINE size = size + 1 NEW_LINE DEDENT return size NEW_LINE DEDENT limit = 20 NEW_LINE printfibFactorials ( limit ) NEW_LINE"],"bleu":0.4314781919766169,"rouge_l":0.6612647139337532}
{"id":1585,"predictions":["MAX = 3000 NEW_LINE def surNumber ( n ) : NEW_LINE INDENT primes = [ 0 ] * MAX NEW_LINE result = [ 0 ] * MAX NEW_LINE for i in range ( 2 , MAX ) : NEW_LINE INDENT if ( primes [ i ] == 0 ) : NEW_LINE INDENT primes [ i ] = 1 NEW_LINE for j in range ( i * 2 , MAX , i ) : NEW_LINE INDENT primes [ j ] -= 1 NEW_LINE if ( primes [ j ] + 3 ) : NEW_LINE INDENT result . append ( j ) NEW_LINE DEDENT DEDENT DEDENT DEDENT result . sort ( ) NEW_LINE return result [ n - 1 ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 50 NEW_LINE print ( surNumber ( n ) ) NEW_LINE DEDENT"],"references":["MAX = 3000 ; NEW_LINE def smartNumber ( n ) : NEW_LINE INDENT primes = [ 0 ] * MAX ; NEW_LINE result = [ ] ; NEW_LINE for i in range ( 2 , MAX ) : NEW_LINE INDENT if ( primes [ i ] == 0 ) : NEW_LINE INDENT primes [ i ] = 1 ; NEW_LINE j = i * 2 ; NEW_LINE while ( j < MAX ) : NEW_LINE INDENT primes [ j ] -= 1 ; NEW_LINE if ( ( primes [ j ] + 3 ) == 0 ) : NEW_LINE INDENT result . append ( j ) ; NEW_LINE DEDENT j = j + i ; NEW_LINE DEDENT DEDENT DEDENT result . sort ( ) ; NEW_LINE return result [ n - 1 ] ; NEW_LINE DEDENT n = 50 ; NEW_LINE print ( smartNumber ( n ) ) ; NEW_LINE"],"bleu":0.6275716950437307,"rouge_l":0.8088397790055248}
{"id":1586,"predictions":["def countPairs ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for x in range ( 1 , n ) : NEW_LINE INDENT for y in range ( x + 1 , n + 1 ) : NEW_LINE INDENT if ( ( y + x ) % ( y ^ x ) == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 6 NEW_LINE print ( countPairs ( n ) ) NEW_LINE DEDENT"],"references":["def countPairs ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE for x in range ( 1 , n ) : NEW_LINE INDENT for y in range ( x + 1 , n + 1 ) : NEW_LINE INDENT if ( ( y + x ) % ( y ^ x ) == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 6 ; NEW_LINE print ( countPairs ( n ) ) ; NEW_LINE DEDENT"],"bleu":0.8231092847391519,"rouge_l":0.9499668654738238}
{"id":1587,"predictions":["def AllIndexesRecursive ( input , x , start ) : NEW_LINE INDENT if ( start == len ( input ) ) : NEW_LINE INDENT ans = [ 0 for i in range ( 0 , len ( input ) ) ] NEW_LINE return ans NEW_LINE DEDENT smallIndex = allIndexesRecursive ( input , x , start + 1 ) NEW_LINE if ( Input [ start ] == x ) : NEW_LINE INDENT myAns = [ 0 for i in range ( len ( smallIndex ) ) ] NEW_LINE myAns [ 0 ] = start NEW_LINE for i in range ( 0 , len ( smallIndex ) ) : NEW_LINE INDENT myAns [ i + 1 ] = smallIndex [ i ] NEW_LINE DEDENT return myAns NEW_LINE DEDENT else : NEW_LINE INDENT return smallIndex NEW_LINE DEDENT DEDENT def AllIndexes ( input , x ) : NEW_LINE INDENT return AllIndexesRecursive ( Input , x , 0 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 2 , 2 , 5 ] NEW_LINE x = 2 NEW_LINE output = AllIndexes ( arr , x ) NEW_LINE for i in range ( 0 , len ( out ) ) : NEW_LINE INDENT print ( output [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT"],"references":["def AllIndexesRecursive ( input , x , start ) : NEW_LINE INDENT if ( start == len ( input ) ) : NEW_LINE INDENT ans = [ ] NEW_LINE return ans NEW_LINE DEDENT smallIndex = AllIndexesRecursive ( input , x , start + 1 ) NEW_LINE if ( input [ start ] == x ) : NEW_LINE INDENT myAns = [ 0 for i in range ( len ( smallIndex ) + 1 ) ] NEW_LINE myAns [ 0 ] = start NEW_LINE for i in range ( len ( smallIndex ) ) : NEW_LINE INDENT myAns [ i + 1 ] = smallIndex [ i ] NEW_LINE DEDENT return myAns NEW_LINE DEDENT else : NEW_LINE INDENT return smallIndex NEW_LINE DEDENT DEDENT def AllIndexes ( input , x ) : NEW_LINE INDENT return AllIndexesRecursive ( input , x , 0 ) NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 2 , 2 , 5 ] NEW_LINE x = 2 NEW_LINE output = AllIndexes ( arr , x ) NEW_LINE for i in output : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT"],"bleu":0.7497135901821105,"rouge_l":0.8973441475826971}
{"id":1588,"predictions":["import math NEW_LINE def fib ( n ) : NEW_LINE INDENT phi = ( 1 + math . sqrt ( 5 ) ) \/ 2 NEW_LINE return round ( pow ( phi , n ) \/ math . sqrt ( 5 ) ) NEW_LINE DEDENT def calculateSum ( l , r ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT sum += fib ( i ) NEW_LINE DEDENT return int ( sum ) NEW_LINE DEDENT l = 4 NEW_LINE r = 8 NEW_LINE print ( calculateSum ( l , r ) ) NEW_LINE"],"references":["def fib ( n ) : NEW_LINE INDENT phi = ( ( 1 + ( 5 ** ( 1 \/ 2 ) ) ) \/ 2 ) ; NEW_LINE return round ( ( phi ** n ) \/ ( 5 ** ( 1 \/ 2 ) ) ) ; NEW_LINE DEDENT def calculateSum ( l , r ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT sum += fib ( i ) ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT l , r = 4 , 8 ; NEW_LINE print ( calculateSum ( l , r ) ) ; NEW_LINE DEDENT"],"bleu":0.5083653935053323,"rouge_l":0.7480022044640396}
{"id":1589,"predictions":["def findSum ( N ) : NEW_LINE INDENT return ( N * ( N + 1 ) * ( 2 * N - 5 ) + 4 * N ) \/\/ 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE print ( findSum ( N ) ) NEW_LINE DEDENT"],"references":["def findSum ( N ) : NEW_LINE INDENT return ( ( N * ( N + 1 ) * ( 2 * N - 5 ) + 4 * N ) \/ 2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE print ( findSum ( N ) ) NEW_LINE DEDENT"],"bleu":0.9007012285408049,"rouge_l":0.9643622722400859}
{"id":1590,"predictions":["def sumOfPrevK ( N , K ) : NEW_LINE INDENT arr = [ 0 ] * N ; NEW_LINE arr [ 0 ] = 1 ; NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT j = i - 1 ; NEW_LINE count = 0 ; NEW_LINE sum = 0 ; NEW_LINE while ( j >= 0 and count < K ) : NEW_LINE INDENT sum += arr [ j ] ; NEW_LINE j -= 1 ; NEW_LINE count += 1 ; NEW_LINE DEDENT arr [ i ] = sum ; NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT N = 16 ; NEW_LINE K = 4 ; NEW_LINE sumOfPrevK ( N , K ) ; NEW_LINE"],"references":["def sumOfPrevK ( N , K ) : NEW_LINE INDENT arr = [ 0 for i in range ( N ) ] NEW_LINE arr [ 0 ] = 1 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT j = i - 1 NEW_LINE count = 0 NEW_LINE sum = 0 NEW_LINE while ( j >= 0 and count < K ) : NEW_LINE INDENT sum = sum + arr [ j ] NEW_LINE j = j - 1 NEW_LINE count = count + 1 NEW_LINE DEDENT arr [ i ] = sum NEW_LINE DEDENT for i in range ( 0 , N ) : NEW_LINE INDENT print ( arr [ i ] ) NEW_LINE DEDENT DEDENT N = 10 NEW_LINE K = 4 NEW_LINE sumOfPrevK ( N , K ) NEW_LINE"],"bleu":0.6539583873838383,"rouge_l":0.8450153919014919}
{"id":1591,"predictions":["def productDivisible ( n , k ) : NEW_LINE INDENT product = 1 NEW_LINE position = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( position % 2 == 0 ) : NEW_LINE INDENT product *= n % 10 NEW_LINE DEDENT n = n \/\/ 10 NEW_LINE position += 1 NEW_LINE DEDENT if ( product % k == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT n = 321922 NEW_LINE k = 3 NEW_LINE if ( productDivisible ( n , k ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"],"references":["def productDivisible ( n , k ) : NEW_LINE INDENT product = 1 NEW_LINE position = 1 NEW_LINE while n > 0 : NEW_LINE INDENT if position % 2 == 0 : NEW_LINE INDENT product *= n % 10 NEW_LINE DEDENT n = n \/ 10 NEW_LINE position += 1 NEW_LINE DEDENT if product % k == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT n = 321922 NEW_LINE k = 3 NEW_LINE if productDivisible ( n , k ) == True : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"],"bleu":0.7975475611659785,"rouge_l":0.9510222091484042}
{"id":1592,"predictions":["import math NEW_LINE def countPairs ( N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , ( 1 , 1 ) ) : NEW_LINE INDENT cb = i * i NEW_LINE diff = N - cb NEW_LINE cbrtDiff = cb - cb NEW_LINE if ( cbrtDiff * cbrtDiff * cbrtDiff == diff ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT for i in range ( 1 , 11 ) : NEW_LINE INDENT print ( \" For ▁ n ▁ = \" , i , \" , \" , casePairs ( i ) , \" pair ▁ exists \" ) NEW_LINE DEDENT DEDENT"],"references":["import math NEW_LINE def countPairs ( N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , int ( math . pow ( N , 1 \/ 3 ) + 1 ) ) : NEW_LINE INDENT cb = i * i * i NEW_LINE diff = N - cb NEW_LINE cbrtDiff = int ( math . pow ( diff , 1 \/ 3 ) ) NEW_LINE if ( cbrtDiff * cbrtDiff * cbrtDiff == diff ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT for i in range ( 1 , 11 ) : NEW_LINE INDENT print ( ' For ▁ n ▁ = ▁ ' , i , ' , ▁ ' , countPairs ( i ) , ' ▁ pair ▁ exists ' ) NEW_LINE DEDENT"],"bleu":0.6248610324494192,"rouge_l":0.7640918580375782}
{"id":1593,"predictions":["MAX = 100 ; NEW_LINE Prefix = [ ] ; NEW_LINE def repeated_digit ( n ) : NEW_LINE INDENT a = dict ( ) ; NEW_LINE d = [ ] ; NEW_LINE while ( n != 0 ) : NEW_LINE INDENT d = n % 10 ; NEW_LINE if ( d in a ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT a . append ( d ) ; NEW_LINE n \/\/= 10 ; NEW_LINE DEDENT return 1 ; NEW_LINE DEDENT def pre_calculations ( ) : NEW_LINE INDENT Prefix . append ( 0 ) ; NEW_LINE Prefix . append ( 1 ) ; NEW_LINE for i in range ( 2 , MAX + 1 ) : NEW_LINE INDENT Prefix [ i ] = repeated_digit ( i ) + Prefix [ i - 1 ] ; NEW_LINE DEDENT DEDENT def calculate ( L , R ) : NEW_LINE INDENT return Prefix [ R ] - Prefix [ L - 1 ] ; NEW_LINE DEDENT L = 1 ; NEW_LINE R = 100 ; NEW_LINE pre_calculations ( ) ; NEW_LINE print ( calculate ( L , R ) ) ; NEW_LINE"],"references":["Prefix = [ 0 ] NEW_LINE def repeated_digit ( n ) : NEW_LINE INDENT a = [ ] NEW_LINE while n != 0 : NEW_LINE INDENT d = n % 10 NEW_LINE if d in a : NEW_LINE INDENT return 0 NEW_LINE DEDENT a . append ( d ) NEW_LINE n = n \/\/ 10 NEW_LINE DEDENT return 1 NEW_LINE DEDENT def pre_calculation ( MAX ) : NEW_LINE INDENT global Prefix NEW_LINE Prefix . append ( repeated_digit ( 1 ) ) NEW_LINE for i in range ( 2 , MAX + 1 ) : NEW_LINE INDENT Prefix . append ( repeated_digit ( i ) + Prefix [ i - 1 ] ) NEW_LINE DEDENT DEDENT def calculate ( L , R ) : NEW_LINE INDENT return Prefix [ R ] - Prefix [ L - 1 ] NEW_LINE DEDENT MAX = 1000 NEW_LINE pre_calculation ( MAX ) NEW_LINE L = 1 NEW_LINE R = 100 NEW_LINE print ( calculate ( L , R ) ) NEW_LINE"],"bleu":0.5863592840892348,"rouge_l":0.8151574619194467}
{"id":1594,"predictions":["def Solives ( n ) : NEW_LINE INDENT i = 2 NEW_LINE while ( ( i > n ) : NEW_LINE INDENT if ( i > n ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT n -= int ( n \/ i ) NEW_LINE i += 1 NEW_LINE DEDENT i = 17 NEW_LINE if ( Signs ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def Survives ( n ) : NEW_LINE INDENT i = 2 NEW_LINE while ( True ) : NEW_LINE INDENT if ( i > n ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT n -= n \/\/ i ; NEW_LINE i += 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 17 ; NEW_LINE if ( Survives ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"],"bleu":0.6206691591939058,"rouge_l":0.8142068119054925}
{"id":1595,"predictions":["def maxPerimeter ( arr , n ) : NEW_LINE INDENT maxi = 0 NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT a = arr [ i ] NEW_LINE b = arr [ j ] NEW_LINE c = arr [ k ] NEW_LINE if ( a < b + c and b < c + a and c < a + b ) : NEW_LINE INDENT maxi = max ( maxi , a + b + c ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( maxi > 0 ) : NEW_LINE INDENT print ( \" Maximum ▁ Perimeter ▁ is : ▁ \" + str ( maxi ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Total ▁ Perimeter ▁ is : ▁ \" + str ( maxi ) + 1 ) NEW_LINE DEDENT DEDENT arr1 = [ 6 , 1 , 6 , 5 , 8 , 4 ] NEW_LINE a1 = [ 2 , 20 , 5 , 12 , 4 ] NEW_LINE maxPerimeter ( arr1 , 8 ) NEW_LINE a2 = [ 3 , 6 , 5 , 10 , 12 , 4 ] NEW_LINE print ( a2 , 7 ) NEW_LINE arr3 = [ 8 , 6 , 20 , 5 , 12 , 4 ] NEW_LINE print ( a3 , 2 ) NEW_LINE"],"references":["def maxPerimeter ( arr ) : NEW_LINE INDENT maxi = 0 NEW_LINE n = len ( arr ) NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT a = arr [ i ] NEW_LINE b = arr [ j ] NEW_LINE c = arr [ k ] NEW_LINE if ( a < b + c and b < a + c and c < a + b ) : NEW_LINE INDENT maxi = max ( maxi , a + b + c ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( maxi == 0 ) : NEW_LINE INDENT return \" Triangle ▁ formation ▁ is ▁ not ▁ possible \" NEW_LINE DEDENT else : NEW_LINE INDENT return \" Maximum ▁ Perimeter ▁ is : ▁ \" + str ( maxi ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT arr1 = [ 6 , 1 , 6 , 5 , 8 , 4 ] NEW_LINE a = maxPerimeter ( arr1 ) NEW_LINE print ( a ) NEW_LINE arr2 = [ 2 , 20 , 7 , 55 , 1 , 33 , 12 , 4 ] NEW_LINE a = maxPerimeter ( arr2 ) NEW_LINE print ( a ) NEW_LINE arr3 = [ 33 , 6 , 20 , 1 , 8 , 12 , 5 , 55 , 4 , 9 ] NEW_LINE a = maxPerimeter ( arr3 ) NEW_LINE print ( a ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"bleu":0.6126341182826781,"rouge_l":0.7405379671506784}
{"id":1596,"predictions":["from math import sqrt NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT s = sqrt ( x ) NEW_LINE return ( s * s == x ) NEW_LINE DEDENT def isFibonacci ( N ) : NEW_LINE INDENT return isPerfectSquare ( 5 * N * N + 4 ) or isPerfectSquare ( 5 * N * N - 4 ) NEW_LINE DEDENT def nextNonFibonacci ( N ) : NEW_LINE INDENT if ( N <= 3 ) : NEW_LINE INDENT return 4 NEW_LINE DEDENT if ( isFibonacci ( N + 1 ) ) : NEW_LINE INDENT return N + 2 NEW_LINE DEDENT else : NEW_LINE INDENT return N + 1 NEW_LINE DEDENT DEDENT N = 3 NEW_LINE print ( nextNonFibonacci ( N ) ) NEW_LINE N = 5 NEW_LINE print ( nextNonFibonacci ( N ) ) NEW_LINE N = 5 NEW_LINE print ( nextNonFibonacci ( N ) ) NEW_LINE"],"references":["from math import sqrt NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT s = sqrt ( x ) NEW_LINE return ( s * s == x ) NEW_LINE DEDENT def isFibonacci ( N ) : NEW_LINE INDENT return isPerfectSquare ( 5 * N * N + 4 ) or   \\ NEW_LINE INDENT isPerfectSquare ( 5 * N * N - 4 ) NEW_LINE DEDENT DEDENT def nextNonFibonacci ( N ) : NEW_LINE INDENT if ( N <= 3 ) : NEW_LINE INDENT return 4 NEW_LINE DEDENT if ( isFibonacci ( N + 1 ) ) : NEW_LINE INDENT return N + 2 NEW_LINE DEDENT else : NEW_LINE INDENT return N NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE print ( nextNonFibonacci ( N ) ) NEW_LINE N = 4 NEW_LINE print ( nextNonFibonacci ( N ) ) NEW_LINE N = 7 NEW_LINE print ( nextNonFibonacci ( N ) ) NEW_LINE DEDENT"],"bleu":0.8217437096433007,"rouge_l":0.9078131459280696}
{"id":1597,"predictions":["def bit_check ( n ) : NEW_LINE INDENT if ( ( n & ( n - 1 ) ) == 0 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 14 ; NEW_LINE if ( bit_check ( n ) ) : NEW_LINE INDENT print ( \"1\" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \"0\" ) ; NEW_LINE DEDENT DEDENT"],"references":["def bit_check ( n ) : NEW_LINE INDENT if ( ( n & ( n - 1 ) ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 14 NEW_LINE if ( bit_check ( n ) ) : NEW_LINE INDENT print ( '1' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( '0' ) NEW_LINE DEDENT DEDENT"],"bleu":0.7986542695584117,"rouge_l":0.9487764413106594}
{"id":1598,"predictions":["def center_ Hexadecagonal_num ( n ) : NEW_LINE INDENT return ( 8 * n * n - 8 * n + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 2 NEW_LINE print ( n , \" rd ▁ centered ▁ hex ▁ hex ▁ Hexadecagonal ▁ number : ▁ \" , center_ Hexadecagonal_num ( n ) ) NEW_LINE n = 13 NEW_LINE print ( n , \" th ▁ centered ▁ octadecagonal ▁ number : ▁ \" , center_copy_num ( n ) ) NEW_LINE DEDENT"],"references":["def center_hexadecagonal_num ( n ) : NEW_LINE INDENT return 8 * n * n - 8 * n + 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 2 NEW_LINE print ( n , \" nd ▁ centered ▁ hexadecagonal ▁ \" + \" number ▁ : ▁ \" , center_hexadecagonal_num ( n ) ) NEW_LINE n = 12 NEW_LINE print ( n , \" th ▁ centered ▁ hexadecagonal ▁ \" + \" number ▁ : ▁ \" , center_hexadecagonal_num ( n ) ) NEW_LINE DEDENT"],"bleu":0.6709326815366811,"rouge_l":0.84375}
{"id":1599,"predictions":["def fib ( n ) : NEW_LINE INDENT a = 0 NEW_LINE b = 1 NEW_LINE if ( n >= 0 ) : NEW_LINE INDENT print ( a , end = ' ▁ ' ) NEW_LINE DEDENT if ( n >= 0 ) : NEW_LINE INDENT print ( b , end = ' ▁ ' ) NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT print ( a + b , end = ' ▁ ' ) NEW_LINE b = a + b NEW_LINE a = b - a NEW_LINE DEDENT DEDENT fib ( 9 ) NEW_LINE"],"references":["def fib ( n ) : NEW_LINE INDENT a = 0 NEW_LINE b = 1 NEW_LINE if ( n >= 0 ) : NEW_LINE INDENT print ( a , end = ' ▁ ' ) NEW_LINE DEDENT if ( n >= 1 ) : NEW_LINE INDENT print ( b , end = ' ▁ ' ) NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT print ( a + b , end = ' ▁ ' ) NEW_LINE b = a + b NEW_LINE a = b - a NEW_LINE DEDENT DEDENT fib ( 9 ) NEW_LINE"],"bleu":0.9756631177112198,"rouge_l":0.9903846153846154}
{"id":1600,"predictions":["from math import sqrt NEW_LINE def prime ( n ) : NEW_LINE INDENT for i in range ( 2 , int ( sqrt ( n ) + 1 ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT return 1 ; NEW_LINE DEDENT def thirdNumber ( a , b ) : NEW_LINE INDENT sum = 0 ; NEW_LINE temp = 0 ; NEW_LINE sum = a + b ; NEW_LINE temp = 1 ; NEW_LINE if ( sum == 0 ) : NEW_LINE INDENT temp = 2 ; NEW_LINE DEDENT while ( not ( sum + temp ) ) : NEW_LINE INDENT temp += 2 ; NEW_LINE DEDENT print ( temp ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 3 ; b = 5 ; NEW_LINE thirdNumber ( a , b ) ; NEW_LINE DEDENT"],"references":["def prime ( n ) : NEW_LINE INDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if i * i > n + 1 : NEW_LINE INDENT break NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def thirdNumber ( a , b ) : NEW_LINE INDENT summ = 0 NEW_LINE temp = 0 NEW_LINE summ = a + b NEW_LINE temp = 1 NEW_LINE if ( summ & 1 ) : NEW_LINE INDENT temp = 2 NEW_LINE DEDENT while ( prime ( summ + temp ) == False ) : NEW_LINE INDENT temp += 2 NEW_LINE DEDENT print ( temp ) NEW_LINE DEDENT a = 3 NEW_LINE b = 5 NEW_LINE thirdNumber ( a , b ) NEW_LINE"],"bleu":0.5185102079788814,"rouge_l":0.7660910518053375}
{"id":1601,"predictions":["def isDiff ( a , b , c ) : NEW_LINE INDENT return ( min ( a , b ) <= c and c <= max ( a , b ) ) NEW_LINE DEDENT def canComp ( x , y , i , j , k ) : NEW_LINE INDENT return ( x [ k ] == x [ i ] or x [ k ] == x [ j ] ) and isTwo ( y [ k ] , y [ k ] ) or ( y [ k ] == y [ i ] or y [ k ] == y [ j ] ) and isDiff ( x [ i ] , x [ j ] , x [ j ] ) and isDiff ( x [ i ] , x [ j ] , y [ j ] ) ) NEW_LINE DEDENT def countLineSegments ( x , y ) : NEW_LINE INDENT if ( x [ 0 ] == x [ 1 ] and x [ 1 ] == x [ 2 ] ) or ( y [ 0 ] == y [ 1 ] and y [ 1 ] == y [ 1 ] ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( canOne ( x , y , 0 , 1 ) or canOne ( x , y , 0 , 2 , 1 ) or canSquare ( x , y , 1 , 2 , 1 ) ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT else : NEW_LINE INDENT return 3 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = [ 0 ] * 3 NEW_LINE y [ 0 ] = - 1 NEW_LINE x [ 0 ] = - 1 NEW_LINE y [ 0 ] = - 1 NEW_LINE x [ 2 ] = - 1 NEW_LINE y [ 1 ] = - 1 NEW_LINE x [ 2 ] = 3 NEW_LINE y [ 2 ] = 3 NEW_LINE x [ 2 ] = 3 NEW_LINE print ( countLineSegments ( x , y ) ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def isBetween ( a , b , c ) : NEW_LINE INDENT return min ( a , b ) <= c and c <= max ( a , b ) NEW_LINE DEDENT def canJoin ( x , y , i , j , k ) : NEW_LINE INDENT return ( x [ k ] == x [ i ] or x [ k ] == x [ j ] ) and isBetween ( y [ i ] , y [ j ] , y [ k ] ) or ( y [ k ] == y [ i ] or y [ k ] == y [ j ] ) and isBetween ( x [ i ] , x [ j ] , x [ k ] ) NEW_LINE DEDENT def countLineSegments ( x , y ) : NEW_LINE INDENT if ( ( x [ 0 ] == x [ 1 ] and x [ 1 ] == x [ 2 ] ) or ( y [ 0 ] == y [ 1 ] and y [ 1 ] == y [ 2 ] ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( canJoin ( x , y , 0 , 1 , 2 ) or canJoin ( x , y , 0 , 2 , 1 ) or canJoin ( x , y , 1 , 2 , 0 ) ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT else : NEW_LINE INDENT return 3 NEW_LINE DEDENT DEDENT x = [ - 1 , - 1 , 4 ] NEW_LINE y = [ - 1 , 3 , 3 ] NEW_LINE print ( countLineSegments ( x , y ) ) NEW_LINE"],"bleu":0.6591086005031791,"rouge_l":0.8198583038132944}
{"id":1602,"predictions":["def ReplaceElements ( arr , n ) : NEW_LINE INDENT min_ele = arr [ 0 ] NEW_LINE arr [ 0 ] = - 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( min_ele < arr [ i ] ) : NEW_LINE INDENT arr [ i ] = min_ele NEW_LINE DEDENT elif ( min_ele >= arr [ i ] ) : NEW_LINE INDENT arr [ i ] , arr [ i ] = min_ele NEW_LINE min_ele = temp NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 4 , 5 , 2 , 1 , 7 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE ReplaceElements ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT"],"references":["def ReplaceElements ( arr , n ) : NEW_LINE INDENT min_ele = arr [ 0 ] NEW_LINE arr [ 0 ] = - 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( min_ele < arr [ i ] ) : NEW_LINE INDENT arr [ i ] = min_ele NEW_LINE DEDENT elif ( min_ele >= arr [ i ] ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE arr [ i ] = min_ele NEW_LINE min_ele = temp NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 4 , 5 , 2 , 1 , 7 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE ReplaceElements ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.953880677738951,"rouge_l":0.9824397339983373}
{"id":1603,"predictions":["def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT def getMin ( arr , i , j ) : NEW_LINE INDENT maxVal = arr [ i + 1 ] NEW_LINE while i <= j : NEW_LINE INDENT minVal = max ( minVal , arr [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT return maxVal NEW_LINE DEDENT def getMax ( arr , i , j ) : NEW_LINE INDENT maxVal = arr [ i + 1 ] NEW_LINE while i <= j : NEW_LINE INDENT maxVal = max ( maxVal , arr [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT return maxVal NEW_LINE DEDENT def generateArr ( arr , n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT print ( arr [ 0 ] ) NEW_LINE return NEW_LINE DEDENT pArr = [ 0 ] * n NEW_LINE tempArr [ 0 ] = gAr ( arr , 1 , n - 1 ) NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT tempArr [ i ] = abs ( arr [ i + 1 ] ) - gMin ( arr , 0 , i - 1 ) NEW_LINE DEDENT tempArr [ n - 1 ] = gMin ( arr , 0 , n - 2 ) NEW_LINE printArray ( tempArr , n ) NEW_LINE"],"references":["def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT def getMin ( arr , i , j ) : NEW_LINE INDENT minVal = arr [ i ] NEW_LINE i += 1 NEW_LINE while ( i <= j ) : NEW_LINE INDENT minVal = min ( minVal , arr [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT return minVal NEW_LINE DEDENT def getMax ( arr , i , j ) : NEW_LINE INDENT maxVal = arr [ i ] NEW_LINE i += 1 NEW_LINE while ( i <= j ) : NEW_LINE INDENT maxVal = max ( maxVal , arr [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT return maxVal NEW_LINE DEDENT def generateArr ( arr , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT print ( arr [ 0 ] , end = \" \" ) NEW_LINE return NEW_LINE DEDENT tmpArr = [ 0 for i in range ( n ) ] NEW_LINE tmpArr [ 0 ] = getMax ( arr , 1 , n - 1 ) NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT tmpArr [ i ] = abs ( getMax ( arr , i + 1 , n - 1 ) - getMin ( arr , 0 , i - 1 ) ) NEW_LINE DEDENT tmpArr [ n - 1 ] = getMin ( arr , 0 , n - 2 ) NEW_LINE printArray ( tmpArr , n ) NEW_LINE DEDENT arr = [ 1 , 5 , 2 , 4 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE generateArr ( arr , n ) NEW_LINE"],"bleu":0.6224773892494824,"rouge_l":0.8219474326272596}
{"id":1604,"predictions":["def totEdge ( n ) : NEW_LINE INDENT result = 0 ; NEW_LINE result = ( n * ( n - 1 ) ) \/ 2 ; NEW_LINE return result ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 6 ; NEW_LINE print ( totEdge ( n ) ) ; NEW_LINE DEDENT"],"references":["def totEdge ( n ) : NEW_LINE INDENT result = ( n * ( n - 1 ) ) \/\/ 2 NEW_LINE return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 6 NEW_LINE print ( totEdge ( n ) ) NEW_LINE DEDENT"],"bleu":0.6261525390306074,"rouge_l":0.8798940241389461}
{"id":1605,"predictions":["def countNumbers ( L , R , K ) : NEW_LINE INDENT if ( K == 9 ) : NEW_LINE INDENT K = 0 NEW_LINE DEDENT totalnumbers = R - L + 1 NEW_LINE factor9 = totalnumbers \/ 9 NEW_LINE rem = totalnumbers % 9 NEW_LINE ans = factor9 NEW_LINE for i in range ( R , R - rem - 1 , - 1 ) : NEW_LINE INDENT rem1 = i % 9 NEW_LINE if ( rem1 == K ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT L = 10 NEW_LINE R = 22 NEW_LINE K = 3 NEW_LINE print ( countNumbers ( L , R , K ) ) NEW_LINE"],"references":["def countNumbers ( L , R , K ) : NEW_LINE INDENT if ( K == 9 ) : NEW_LINE INDENT K = 0 NEW_LINE DEDENT totalnumbers = R - L + 1 NEW_LINE factor9 = totalnumbers \/\/ 9 NEW_LINE rem = totalnumbers % 9 NEW_LINE ans = factor9 NEW_LINE for i in range ( R , R - rem , - 1 ) : NEW_LINE INDENT rem1 = i % 9 NEW_LINE if ( rem1 == K ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT L = 10 NEW_LINE R = 22 NEW_LINE K = 3 NEW_LINE print ( countNumbers ( L , R , K ) ) NEW_LINE"],"bleu":0.9485495426391899,"rouge_l":0.984423238843671}
{"id":1606,"predictions":["import math NEW_LINE def SieveOfEratosthenes ( n , prime , primesques , a ) : NEW_LINE INDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT primes . append ( True ) NEW_LINE DEDENT prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= n : NEW_LINE INDENT if ( p * p > n ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( p * p ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE primesquare [ p * p ] = True NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT j = 0 NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT a [ j ] = p NEW_LINE primesquare [ p * p ] = True NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT def countDivisors ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT prime = [ False ] * ( n + 1 ) NEW_LINE primesquare = [ False ] * ( ( n * n + 1 ) + 1 ) NEW_LINE a = [ 0 ] * n NEW_LINE SieveOfEratosthenes ( n , prime , primesquare , a ) NEW_LINE ans = 1 NEW_LINE for i in range ( 0 , 100 ) : NEW_LINE INDENT if ( a [ i ] * a [ i ] * a [ i ] > n ) : NEW_LINE INDENT break NEW_LINE DEDENT cnt = 1 NEW_LINE while ( n % a [ i ] == 0 ) : NEW_LINE INDENT n = int ( n \/ a [ i ] ) NEW_LINE cnt = cnt + 1 NEW_LINE DEDENT ans = ans * 4 NEW_LINE DEDENT if ( prime [ n ] ) : NEW_LINE INDENT ans = ans * 2 NEW_LINE DEDENT print ("],"references":["def SieveOfEratosthenes ( n , prime , primesquare , a ) : NEW_LINE INDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT prime [ i ] = True NEW_LINE DEDENT for i in range ( ( n * n + 1 ) + 1 ) : NEW_LINE INDENT primesquare [ i ] = False NEW_LINE DEDENT prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT i = p * 2 NEW_LINE while ( i <= n ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE i += p NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT j = 0 NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT a [ j ] = p NEW_LINE primesquare [ p * p ] = True NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT def countDivisors ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT prime = [ False ] * ( n + 2 ) NEW_LINE primesquare = [ False ] * ( n * n + 2 ) NEW_LINE a = [ 0 ] * n NEW_LINE SieveOfEratosthenes ( n , prime , primesquare , a ) NEW_LINE ans = 1 NEW_LINE i = 0 NEW_LINE while ( 1 ) : NEW_LINE INDENT if ( a [ i ] * a [ i ] * a [ i ] > n ) : NEW_LINE INDENT break NEW_LINE DEDENT cnt = 1 NEW_LINE while ( n % a [ i ] == 0 ) : NEW_LINE INDENT n = n \/ a [ i ] NEW_LINE cnt = cnt + 1 NEW_LINE DEDENT ans = ans * cnt NEW_LINE i += 1 NEW_LINE DEDENT n = int ( n ) NEW_LINE if ( prime [ n ] == True ) : NEW_LINE INDENT ans = ans * 2 NEW_LINE DEDENT elif ( primesquare [ n ] == True ) : NEW_LINE INDENT ans = ans * 3 NEW_LINE DEDENT elif ( n != 1 ) : NEW_LINE INDENT ans = ans * 4 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( \" Total ▁ distinct ▁ divisors ▁ of ▁ 100 ▁ are ▁ : \" , countDivisors ( 100 ) ) NEW_LINE DEDENT"],"bleu":0.6277444767690961,"rouge_l":0.7251188719462207}
{"id":1607,"predictions":["def subArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT for k in range ( i , j + 1 ) : NEW_LINE INDENT print ( arr [ k ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE subArray ( arr , n ) NEW_LINE"],"references":["def subArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT for k in range ( i , j + 1 ) : NEW_LINE INDENT print ( arr [ k ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( \" \\n \" , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" All ▁ Non - empty ▁ Subarrays \" ) NEW_LINE subArray ( arr , n ) ; NEW_LINE"],"bleu":0.7075973971041573,"rouge_l":0.8448753462603877}
{"id":1608,"predictions":["def findCullen ( n ) : NEW_LINE INDENT return ( 1 << n ) * n + 1 NEW_LINE DEDENT n = 2 NEW_LINE print ( findCullen ( n ) ) NEW_LINE"],"references":["def findCullen ( n ) : NEW_LINE INDENT return ( 1 << n ) * n + 1 NEW_LINE DEDENT n = 2 NEW_LINE print ( findCullen ( n ) ) NEW_LINE"],"bleu":1.0,"rouge_l":1.0}
{"id":1609,"predictions":["def printProbability ( L , n ) : NEW_LINE INDENT p = ( 1 << ( n - 1 ) ) NEW_LINE return 1.0 - ( float ( n ) ) \/ ( float ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE L = 5 NEW_LINE print ( printProbability ( L , n ) ) NEW_LINE DEDENT"],"references":["def printProbability ( L , n ) : NEW_LINE INDENT p = ( 1 << ( n - 1 ) ) NEW_LINE return 1.0 - ( float ( n ) \/ float ( p ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE L = 5 NEW_LINE print ( printProbability ( L , n ) ) NEW_LINE DEDENT"],"bleu":0.8518167166971713,"rouge_l":0.9340400471142521}
{"id":1610,"predictions":["def firstLetterWord ( str ) : NEW_LINE INDENT result = \" \" NEW_LINE v = True NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == ' ▁ ' ) : NEW_LINE INDENT v = False NEW_LINE DEDENT elif ( str [ i ] != ' ▁ ' and str [ i ] == ' ▁ ' ) : NEW_LINE INDENT result += str [ i ] NEW_LINE v = True NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeks ▁ for ▁ geeks \" NEW_LINE print ( firstLetterWord ( str ) ) NEW_LINE DEDENT"],"references":["def firstLetterWord ( str ) : NEW_LINE INDENT result = \" \" NEW_LINE v = True NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == ' ▁ ' ) : NEW_LINE INDENT v = True NEW_LINE DEDENT elif ( str [ i ] != ' ▁ ' and v == True ) : NEW_LINE INDENT result += ( str [ i ] ) NEW_LINE v = False NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeks ▁ for ▁ geeks \" NEW_LINE print ( firstLetterWord ( str ) ) NEW_LINE DEDENT"],"bleu":0.8885610345527478,"rouge_l":0.9393647738209817}
{"id":1611,"predictions":["def find Previous ( number , n ) : NEW_LINE INDENT for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT if ( number [ i ] < number [ i - 1 ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( i == 0 ) : NEW_LINE INDENT print ( \" Previous ▁ number ▁ is ▁ not ▁ possible \" ) NEW_LINE return NEW_LINE DEDENT x = num [ i - 1 ] NEW_LINE sign = i NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if ( number [ j ] < x and number [ j ] > num [ bad ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT sum1 = ( number [ i - 1 ] ) NEW_LINE s2 = i NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if ( number [ j ] < x and number [ j ] > num1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT s2 . sort ( reverse ( i , n - 1 ) ) NEW_LINE return reverse ( s1 , i , n - 1 ) NEW_LINE DEDENT def findPrev ( s1 , n ) : NEW_LINE INDENT prev = [ 0 ] * n NEW_LINE prev [ 0 ] = temp NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if ( first <= end : NEW_LINE INDENT break NEW_LINE DEDENT if ( num1 <= end ) : NEW_LINE INDENT prev [ j ] = temp [ j ] NEW_LINE DEDENT return prev NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT string = [ ] NEW_LINE n = len ( string ) NEW_LINE findPrev ( number , n ) NEW_LINE DEDENT"],"references":["def findPrevious ( number , n ) : NEW_LINE INDENT number = list ( number ) NEW_LINE i , j = - 1 , - 1 NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT if number [ i ] < number [ i - 1 ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if i == 0 : NEW_LINE INDENT print ( \" Previous ▁ number ▁ is ▁ not ▁ possible \" ) NEW_LINE return NEW_LINE DEDENT x , greatest = number [ i - 1 ] , i NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if ( number [ j ] < x and number [ j ] > number [ greatest ] ) : NEW_LINE INDENT greatest = j NEW_LINE DEDENT DEDENT ( number [ greatest ] , number [ i - 1 ] ) = ( number [ i - 1 ] , number [ greatest ] ) NEW_LINE l = number [ i : ] NEW_LINE del number [ i : ] NEW_LINE l . sort ( reverse = True ) NEW_LINE number += l NEW_LINE number = ' ' . join ( number ) NEW_LINE print ( \" Greatest ▁ smaller ▁ number ▁ with \" , \" same ▁ set ▁ of ▁ digits ▁ is \" , number ) NEW_LINE return NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT digits = \"262345\" NEW_LINE n = len ( digits ) NEW_LINE findPrevious ( digits , n ) NEW_LINE DEDENT"],"bleu":0.4460336404650918,"rouge_l":0.620196450112011}
{"id":1612,"predictions":["def countDecreasing ( A , n ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE len = 1 ; NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( A [ i + 1 ] < A [ i ] ) : NEW_LINE INDENT len += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT cnt += ( ( len - 1 ) * len ) \/ 2 ) ; NEW_LINE len = 1 ; NEW_LINE DEDENT DEDENT if ( len > 1 ) : NEW_LINE INDENT cnt += ( ( len - 1 ) * len ) \/ 2 ) ; NEW_LINE DEDENT return int ( cnt ) ; NEW_LINE DEDENT A = [ 100 , 3 , 1 , 13 ] ; NEW_LINE n = len ( A ) ; NEW_LINE print ( countDecreasing ( A , n ) ) ; NEW_LINE"],"references":["def countDecreasing ( A , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE len = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( A [ i + 1 ] < A [ i ] ) : NEW_LINE INDENT len += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += ( ( ( len - 1 ) * len ) \/\/ 2 ) ; NEW_LINE len = 1 NEW_LINE DEDENT DEDENT if ( len > 1 ) : NEW_LINE INDENT cnt += ( ( ( len - 1 ) * len ) \/\/ 2 ) NEW_LINE DEDENT return cnt NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 100 , 3 , 1 , 13 ] NEW_LINE n = len ( A ) NEW_LINE print ( countDecreasing ( A , n ) ) NEW_LINE DEDENT"],"bleu":0.7579025974067959,"rouge_l":0.8911905800261665}
{"id":1613,"predictions":["def count ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( n * count ( n - 1 ) ) + ( ( n - 1 ) * count ( n - 2 ) ) NEW_LINE DEDENT DEDENT A = [ 1 , 2 , 3 , 9 ] NEW_LINE n = len ( A ) NEW_LINE print ( count ( n - 1 ) ) NEW_LINE"],"references":["def count ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( n * count ( n - 1 ) ) + ( ( n - 1 ) * count ( n - 2 ) ) NEW_LINE DEDENT DEDENT A = [ 1 , 2 , 3 , 9 ] NEW_LINE print ( count ( len ( A ) - 1 ) ) NEW_LINE"],"bleu":0.8091355301934275,"rouge_l":0.9202586206896549}
{"id":1614,"predictions":["def DivideAndAdded ( A , length , rotation ) : NEW_LINE INDENT temp = [ 0 ] * 2 NEW_LINE print ( A [ 0 ] , end = \" ▁ \" ) NEW_LINE for i in range ( 0 , length , 1 ) : NEW_LINE INDENT A [ i - rotation ] = temp [ i ] NEW_LINE DEDENT DEDENT arr = [ 12 , 10 , 5 , 6 , 52 , 36 ] NEW_LINE n = len ( arr ) NEW_LINE position = 2 NEW_LINESplitAndAdded ( arr , n , position ) NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT"],"references":["def SplitAndAdd ( A , length , rotation ) : NEW_LINE INDENT tmp = [ 0 for i in range ( length * 2 ) ] NEW_LINE for i in range ( length ) : NEW_LINE INDENT tmp [ i ] = A [ i ] NEW_LINE tmp [ i + length ] = A [ i ] NEW_LINE DEDENT for i in range ( rotation , rotation + length , 1 ) : NEW_LINE INDENT A [ i - rotation ] = tmp [ i ] ; NEW_LINE DEDENT DEDENT arr = [ 12 , 10 , 5 , 6 , 52 , 36 ] NEW_LINE n = len ( arr ) NEW_LINE position = 2 NEW_LINE SplitAndAdd ( arr , n , position ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE"],"bleu":0.5565995673028452,"rouge_l":0.7484662576687114}
{"id":1615,"predictions":["def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT a = gcd ( a , b ) NEW_LINE b = b \/\/ n NEW_LINE print ( \" A ▁ = \" , a , \" , ▁ B ▁ = \" , b ) NEW_LINE"],"references":["def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def commDiv ( a , b ) : NEW_LINE INDENT n = gcd ( a , b ) NEW_LINE a = a \/\/ n NEW_LINE b = b \/\/ n NEW_LINE print ( \" A ▁ = \" , a , \" , ▁ B ▁ = \" , b ) NEW_LINE DEDENT a , b = 10 , 15 NEW_LINE commDiv ( a , b ) NEW_LINE"],"bleu":0.614252595272629,"rouge_l":0.7875322759129474}
{"id":1616,"predictions":["defglySet ( n ) : NEW_LINE INDENT x = ( n & ( n >> 1 ) ) NEW_LINE if ( x == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT n = 3 NEW_LINE if (glySet ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def adjacentSet ( n ) : NEW_LINE INDENT return ( n & ( n >> 1 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE if ( adjacentSet ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.6452997325270604,"rouge_l":0.7522103303862262}
{"id":1617,"predictions":["def MinimumMoves ( a , n , x ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT if ( a [ i ] <= a [ i - 1 ] ) : NEW_LINE INDENT p = ( a [ i - 1 ] - a [ i ] ) \/\/ x + 1 ; NEW_LINE ans += p * x ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 3 , 3 , 2 ] ; NEW_LINE x = 2 ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( MinimumMoves ( arr , n , x ) ) ; NEW_LINE DEDENT"],"references":["def MinimumMoves ( a , n , x ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if a [ i ] <= a [ i - 1 ] : NEW_LINE INDENT p = ( a [ i - 1 ] - a [ i ] ) \/\/ x + 1 NEW_LINE ans += p NEW_LINE a [ i ] += p * x NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 3 , 3 , 2 ] NEW_LINE x = 2 NEW_LINE n = len ( arr ) NEW_LINE print ( MinimumMoves ( arr , n , x ) ) NEW_LINE DEDENT"],"bleu":0.7438074908262644,"rouge_l":0.91695416461311}
{"id":1618,"predictions":["def avg_of_even_num ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += 2 * i NEW_LINE DEDENT return ( sum \/ n ) NEW_LINE DEDENT n = 9 NEW_LINE print ( avg_of_even_num ( n ) ) NEW_LINE"],"references":["def avg_of_even_num ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + 2 * i NEW_LINE DEDENT return sum \/ n NEW_LINE DEDENT n = 9 NEW_LINE print ( avg_of_even_num ( n ) ) NEW_LINE"],"bleu":0.8530794629535559,"rouge_l":0.9433962264150945}
{"id":1619,"predictions":["def findX ( A , B ) : NEW_LINE INDENT j , x = 0 , 0 NEW_LINE while ( A != 0 or B != 0 ) : NEW_LINE INDENT if ( ( A % 2 == 1 ) and ( B % 2 == 1 ) ) : NEW_LINE INDENT x += ( 1 << j ) NEW_LINE DEDENT A >>= 1 NEW_LINE B >>= 1 NEW_LINE j += 1 NEW_LINE DEDENT return x NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = 2 NEW_LINE B = 3 NEW_LINE X = findX ( A , B ) NEW_LINE print ( \" X ▁ = \" , X , \" , \" , ▁ Sum ▁ = \" , ( A ^ X ) ) NEW_LINE DEDENT"],"references":["def findX ( A , B ) : NEW_LINE INDENT j = 0 NEW_LINE x = 0 NEW_LINE while ( A or B ) : NEW_LINE INDENT if ( ( A & 1 ) and ( B & 1 ) ) : NEW_LINE INDENT x += ( 1 << j ) NEW_LINE DEDENT A >>= 1 NEW_LINE B >>= 1 NEW_LINE j += 1 NEW_LINE DEDENT return x NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = 2 NEW_LINE B = 3 NEW_LINE X = findX ( A , B ) NEW_LINE print ( \" X ▁ = \" , X , \" , ▁ Sum ▁ = \" , ( A ^ X ) + ( B ^ X ) ) NEW_LINE DEDENT"],"bleu":0.7919842503335898,"rouge_l":0.8904563297350342}
{"id":1620,"predictions":["MAX = 1000001 ; NEW_LINE factor = [ 0 ] * MAX ; NEW_LINE def cal_factor ( ) : NEW_LINE INDENT factor [ 1 ] = 1 ; NEW_LINE for i in range ( 2 , MAX ) : NEW_LINE INDENT factor [ i ] = i ; NEW_LINE DEDENT for i in range ( 4 , MAX , 2 ) : NEW_LINE INDENT factor [ i ] = 2 ; NEW_LINE DEDENT for i in range ( 3 , MAX , 2 ) : NEW_LINE INDENT if ( factor [ i ] == i ) : NEW_LINE INDENT for j in range ( i * i , MAX , i ) : NEW_LINE INDENT if ( factor [ j ] == j ) : NEW_LINE INDENT factor [ j ] = i ; NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def no_of_ reservations ( a , n ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp = a [ i ] ; NEW_LINE flag = 0 ; NEW_LINE while ( factor [ temp ] != 1 ) : NEW_LINE INDENT flag = - 1 ; NEW_LINE count += 1 ; NEW_LINE temp = temp \/\/ factor [ temp ] ; NEW_LINE DEDENT count += flag ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT cal_factor ( ) ; NEW_LINE a = [ 4 , 4 , 4 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( no_of_ Studentations ( a , n ) ) ; NEW_LINE DEDENT"],"references":["MAX = 1000001 NEW_LINE factor = [ 0 ] * MAX NEW_LINE def cal_factor ( ) : NEW_LINE INDENT factor [ 1 ] = 1 NEW_LINE for i in range ( 2 , MAX ) : NEW_LINE INDENT factor [ i ] = i NEW_LINE DEDENT for i in range ( 4 , MAX , 2 ) : NEW_LINE INDENT factor [ i ] = 2 NEW_LINE DEDENT i = 3 NEW_LINE while i * i < MAX : NEW_LINE INDENT if ( factor [ i ] == i ) : NEW_LINE INDENT for j in range ( i * i , MAX , i ) : NEW_LINE INDENT if ( factor [ j ] == j ) : NEW_LINE INDENT factor [ j ] = i NEW_LINE DEDENT DEDENT DEDENT i += 1 NEW_LINE DEDENT DEDENT def no_of_representations ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp = a [ i ] NEW_LINE flag = 0 NEW_LINE while ( factor [ temp ] != 1 ) : NEW_LINE INDENT flag = - 1 NEW_LINE count += 1 NEW_LINE temp = temp \/\/ factor [ temp ] NEW_LINE DEDENT count += flag NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT cal_factor ( ) NEW_LINE a = [ 4 , 4 , 4 ] NEW_LINE n = len ( a ) NEW_LINE print ( no_of_representations ( a , n ) ) NEW_LINE DEDENT"],"bleu":0.7377768086891098,"rouge_l":0.9167805241584897}
{"id":1621,"predictions":["def maxSumPair ( arr1 , n1 , arr2 , n2 ) : NEW_LINE INDENT max1 = - float ( \" inf \" ) NEW_LINE max2 = - float ( \" inf \" ) NEW_LINE for i in range ( 0 , n1 ) : NEW_LINE INDENT if ( arr1 [ i ] > max1 ) : NEW_LINE INDENT max1 = arr1 [ i ] NEW_LINE DEDENT DEDENT for i in range ( 0 , n2 ) : NEW_LINE INDENT if ( arr2 [ i ] > max2 ) : NEW_LINE INDENT max2 = arr2 [ i ] NEW_LINE DEDENT DEDENT return max1 + max2 NEW_LINE DEDENT arr1 = [ 10 , 2 , 3 ] NEW_LINE arr2 = [ 3 , 4 , 7 ] NEW_LINE n1 = len ( arr1 ) NEW_LINE n2 = len ( arr2 ) NEW_LINE print ( maxSumPair ( arr1 , n1 , arr2 , n2 ) ) NEW_LINE"],"references":["import sys NEW_LINE def maxSumPair ( arr1 , n1 , arr2 , n2 ) : NEW_LINE INDENT max1 = - sys . maxsize - 1 NEW_LINE max2 = - sys . maxsize - 1 NEW_LINE for i in range ( 0 , n1 ) : NEW_LINE INDENT if ( arr1 [ i ] > max1 ) : NEW_LINE INDENT max1 = arr1 [ i ] NEW_LINE DEDENT DEDENT for i in range ( 0 , n2 ) : NEW_LINE INDENT if ( arr2 [ i ] > max2 ) : NEW_LINE INDENT max2 = arr2 [ i ] NEW_LINE DEDENT DEDENT return max1 + max2 NEW_LINE DEDENT arr1 = [ 10 , 2 , 3 ] NEW_LINE arr2 = [ 3 , 4 , 7 ] NEW_LINE n1 = len ( arr1 ) NEW_LINE n2 = len ( arr2 ) NEW_LINE print ( maxSumPair ( arr1 , n1 , arr2 , n2 ) ) NEW_LINE"],"bleu":0.896200962882953,"rouge_l":0.918557794273595}
{"id":1622,"predictions":["def remainder ( st1 ) : NEW_LINE INDENT ln = len ( st1 ) NEW_LINE rem = 0 NEW_LINE for i in range ( ln ) : NEW_LINE INDENT num = rem * 10 + ( ord ( st [ i ] ) - ord ( '0' ) ) NEW_LINE rem = num % 11 NEW_LINE DEDENT return rem NEW_LINE DEDENT st1 = \"34353465565325357866345\" NEW_LINE print ( remainder ( st1 ) ) NEW_LINE"],"references":["def remainder ( st ) : NEW_LINE INDENT ln = len ( st ) NEW_LINE rem = 0 NEW_LINE for i in range ( 0 , ln ) : NEW_LINE INDENT num = rem * 10 + ( int ) ( st [ i ] ) NEW_LINE rem = num % 11 NEW_LINE DEDENT return rem NEW_LINE DEDENT st = \"3435346456547566345436457867978\" NEW_LINE print ( remainder ( st ) ) NEW_LINE"],"bleu":0.6812124523707555,"rouge_l":0.8563866513233602}
{"id":1623,"predictions":["def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT def rfsList ( m , n ) : NEW_LINE INDENT arr = [ 0 ] * m NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ r ] = int ( r ** ( 1 \/ 2 ) ) ] += 1 NEW_LINE DEDENT printArr ( arr , m ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT m = 4 NEW_LINE n = 8 NEW_LINE print ( r , n ) NEW_LINE DEDENT"],"references":["from random import randint NEW_LINE def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT def randomList ( m , n ) : NEW_LINE INDENT arr = [ 0 ] * m ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ randint ( 0 , n ) % m ] += 1 ; NEW_LINE DEDENT printArr ( arr , m ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT m = 4 ; n = 8 ; NEW_LINE randomList ( m , n ) ; NEW_LINE DEDENT"],"bleu":0.6571719488938349,"rouge_l":0.8350664736080031}
{"id":1624,"predictions":["from math import sqrt NEW_LINE N = 100005 NEW_LINE def SieveOfEratosthenes ( prime , p_size ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( sqrt ( p_size ) ) + 1 ) : NEW_LINE INDENT if ( p * p > p_size ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( 2 * p , p + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def longestPrimeSubsequence ( arr , n ) : NEW_LINE INDENT prime = [ True ] * ( N + 1 ) NEW_LINE SieveOfEratosthenes ( prime , N ) NEW_LINE answer = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 4 , 11 , 2 , 9 , 21 ] NEW_LINE n = len ( arr ) NEW_LINE print ( longestPrimeSubsequence ( arr , n ) ) NEW_LINE DEDENT"],"references":["N = 100005 NEW_LINE def SieveOfEratosthenes ( prime , p_size ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= p_size : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( p * 2 , p_size + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT def longestPrimeSubsequence ( arr , n ) : NEW_LINE INDENT prime = [ True ] * ( N + 1 ) NEW_LINE SieveOfEratosthenes ( prime , N ) NEW_LINE answer = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 4 , 11 , 2 , 9 , 21 ] NEW_LINE n = len ( arr ) NEW_LINE print ( longestPrimeSubsequence ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.790862726915699,"rouge_l":0.8979867908013051}
{"id":1625,"predictions":["def catalan ( n ) : NEW_LINE INDENT res = 0 NEW_LINE if n <= 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT res += catalan ( i ) * catalan ( n - i - 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT def catalan ( n ) : NEW_LINE INDENT for i in range ( 0 , 10 ) : NEW_LINE INDENT print ( catalan ( i ) , end = \" ▁ \" ) NEW_LINE DEDENT print ( catalan ( i ) , end = \" ▁ \" ) NEW_LINE DEDENT"],"references":["def catalan ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res += catalan ( i ) * catalan ( n - i - 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT print catalan ( i ) , NEW_LINE DEDENT"],"bleu":0.5795462873951831,"rouge_l":0.7913010301411674}
{"id":1626,"predictions":["def smallestIndex ( a , n ) : NEW_LINE INDENT right1 , right0 = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 1 ) : NEW_LINE INDENT right1 = right NEW_LINE DEDENT else : NEW_LINE INDENT right0 = i NEW_LINE DEDENT DEDENT return min ( right1 , right0 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( smallestIndex ( a , n ) ) NEW_LINE DEDENT"],"references":["def smallestIndex ( a , n ) : NEW_LINE INDENT right1 = 0 NEW_LINE right0 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 1 ) : NEW_LINE INDENT right1 = i NEW_LINE DEDENT else : NEW_LINE INDENT right0 = i NEW_LINE DEDENT DEDENT return min ( right1 , right0 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( smallestIndex ( a , n ) ) NEW_LINE DEDENT"],"bleu":0.9348771192507465,"rouge_l":0.9658119658119658}
{"id":1627,"predictions":["def polygonArea ( X , Y , n ) : NEW_LINE INDENT area = 0.0 NEW_LINE j = n - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) NEW_LINE j = i NEW_LINE DEDENT return abs ( area \/ 2.0 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT X = [ 0 , 2 , 4 ] NEW_LINE Y = [ 1 , 3 , 7 ] NEW_LINE n = len ( X ) NEW_LINE print ( polygonArea ( X , Y , n ) ) NEW_LINE DEDENT"],"references":["def polygonArea ( X , Y , n ) : NEW_LINE INDENT area = 0.0 NEW_LINE j = n - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT area = area + ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) NEW_LINE j = i NEW_LINE DEDENT return abs ( area \/\/ 2.0 ) NEW_LINE DEDENT X = [ 0 , 2 , 4 ] NEW_LINE Y = [ 1 , 3 , 7 ] NEW_LINE n = len ( X ) NEW_LINE print ( polygonArea ( X , Y , n ) ) NEW_LINE"],"bleu":0.8372308393653715,"rouge_l":0.9256322624743678}
{"id":1628,"predictions":["PI = 3.14 ; NEW_LINE def areaOfInInscribedCircle ( a ) : NEW_LINE INDENT return ( PI \/ 4 ) * a * a * a ) ; NEW_LINE DEDENT a = 8 ; NEW_LINE print ( \" Area ▁ of ▁ an ▁ inscribed ▁ circle ▁ circle : ▁ \" % areaOfInscribedCircle ( a ) ) ; NEW_LINE"],"references":["PI = 3.14 NEW_LINE def areaOfInscribedCircle ( a ) : NEW_LINE INDENT return ( PI \/ 4 ) * a * a NEW_LINE DEDENT a = 8 NEW_LINE print ( \" Area ▁ of ▁ an ▁ inscribed ▁ circle : \" , round ( areaOfInscribedCircle ( a ) , 2 ) ) NEW_LINE"],"bleu":0.6215225868565338,"rouge_l":0.8385492834162035}
{"id":1629,"predictions":["def divisorSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT if ( j * j == i ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( i % j == 0 ) : NEW_LINE INDENT if ( i \/ j == j ) : NEW_LINE INDENT sum += j NEW_LINE DEDENT else : NEW_LINE INDENT sum += j + i \/ j NEW_LINE DEDENT DEDENT DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 NEW_LINE print ( divisorSum ( n ) ) NEW_LINE n = 5 NEW_LINE print ( divisorSum ( n ) ) NEW_LINE DEDENT"],"references":["def divisorSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT j = 1 NEW_LINE while j * j <= i : NEW_LINE INDENT if i % j == 0 : NEW_LINE INDENT if i \/ j == j : NEW_LINE INDENT sum += j NEW_LINE DEDENT else : NEW_LINE INDENT sum += j + i \/ j NEW_LINE DEDENT DEDENT j = j + 1 NEW_LINE DEDENT DEDENT return int ( sum ) NEW_LINE DEDENT n = 4 NEW_LINE print ( divisorSum ( n ) ) NEW_LINE n = 5 NEW_LINE print ( divisorSum ( n ) ) NEW_LINE"],"bleu":0.623344823023157,"rouge_l":0.8250820748522654}
{"id":1630,"predictions":["MAX = 32 NEW_LINE def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE f = [ 0 ] * ( MAX + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT f [ countSetBits ( arr [ i ] ) ] += 1 NEW_LINE DEDENT for i in range ( MAX + 1 ) : NEW_LINE INDENT f [ countSetBits ( arr [ i ] ) ] += 1 NEW_LINE DEDENT for i in range ( MAX + 1 ) : NEW_LINE INDENT for j in range ( i , MAX + 1 ) : NEW_LINE INDENT if ( i + j == k ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT count += ( ( f [ i ] * ( f [ i ] - 1 ) ) \/ 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT count += ( f [ i ] * f [ j ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE k = 4 NEW_LINE print ( pairs ( arr , n , k ) ) NEW_LINE DEDENT"],"references":["MAX = 32 NEW_LINE def countSetBits ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( n ) : NEW_LINE INDENT n &= ( n - 1 ) ; NEW_LINE count += 1 ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT def pairs ( arr , n , k ) : NEW_LINE INDENT count = 0 ; NEW_LINE f = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT f [ countSetBits ( arr [ i ] ) ] += 1 ; NEW_LINE DEDENT for i in range ( MAX + 1 ) : NEW_LINE INDENT for j in range ( 1 , MAX + 1 ) : NEW_LINE INDENT if ( i + j == k ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT count += ( ( f [ i ] * ( f [ i ] - 1 ) ) \/ 2 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT count += ( f [ i ] * f [ j ] ) ; NEW_LINE DEDENT DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE k = 4 NEW_LINE print ( pairs ( arr , n , k ) ) NEW_LINE"],"bleu":0.7576454546006396,"rouge_l":0.8049091940976163}
{"id":1631,"predictions":["def oneDigit ( num ) : NEW_LINE INDENT if ( num >= 0 and 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT def isPalUtil ( num , dupNum ) : NEW_LINE INDENT if ( num == 0 ) : NEW_LINE INDENT return dupNum ; NEW_LINE DEDENT else : NEW_LINE INDENT dupNum = isPalUtil ( num \/ 10 , dupNum ) ; NEW_LINE if ( num % 10 == dupNum % 10 ) : NEW_LINE INDENT return dupNum \/ 10 ; NEW_LINE DEDENT else : NEW_LINE INDENT raise ValueError ( ) ; NEW_LINE DEDENT DEDENT def isPal ( num ) : NEW_LINE INDENT if ( num < 0 ) : NEW_LINE INDENT num = ( - num ) ; NEW_LINE DEDENT dupNum = ( num ) ; NEW_LINE return isPalUtil ( num ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 1234 ; NEW_LINE print ( \" Yes \" ) ; NEW_LINE print ( \" No \" ) ; NEW_LINE DEDENT"],"references":["def oneDigit ( num ) : NEW_LINE INDENT return ( ( num >= 0 ) and ( num < 10 ) ) ; NEW_LINE DEDENT def isPalUtil ( num , dupNum ) : NEW_LINE INDENT if ( oneDigit ( num ) ) : NEW_LINE INDENT return ( num == ( dupNum ) % 10 ) ; NEW_LINE DEDENT if ( isPalUtil ( int ( num \/ 10 ) , dupNum ) == False ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT dupNum = int ( dupNum \/ 10 ) ; NEW_LINE return ( num % 10 == ( dupNum ) % 10 ) ; NEW_LINE DEDENT def isPal ( num ) : NEW_LINE INDENT if ( num < 0 ) : NEW_LINE INDENT num = ( - num ) ; NEW_LINE DEDENT dupNum = ( num ) ; NEW_LINE return isPalUtil ( num , dupNum ) ; NEW_LINE DEDENT n = 12321 ; NEW_LINE if ( isPal ( n ) == 0 ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT n = 12 ; NEW_LINE if ( isPal ( n ) == 0 ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT n = 88 ; NEW_LINE if ( isPal ( n ) == 1 ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT n = 8999 ; NEW_LINE if ( isPal ( n ) == 0 ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT"],"bleu":0.358578471224609,"rouge_l":0.5160876810665299}
{"id":1632,"predictions":["def isSumDivides ( N ) : NEW_LINE INDENT temp = N NEW_LINE sum = 0 NEW_LINE while ( temp ) : NEW_LINE INDENT sum += temp % 10 NEW_LINE temp \/= 10 NEW_LINE DEDENT if ( N % sum == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 12 NEW_LINE if ( isSumDivides ( N ) == 1 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"],"references":["def isSumDivides ( N ) : NEW_LINE INDENT temp = N NEW_LINE sum = 0 NEW_LINE while ( temp ) : NEW_LINE INDENT sum += temp % 10 NEW_LINE temp = int ( temp \/ 10 ) NEW_LINE DEDENT if ( N % sum == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 12 NEW_LINE if ( isSumDivides ( N ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.8553976004048907,"rouge_l":0.9326937490631091}
{"id":1633,"predictions":["def nextZero ( i , occurrences ) : NEW_LINE INDENT while i < len ( occurrences ) : NEW_LINE INDENT if occurrences [ i ] == 0 : NEW_LINE INDENT return i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT def getMod ModifiedString ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE if n > 26 : NEW_LINE INDENT return \" - 1\" NEW_LINE DEDENT str = list ( str ) NEW_LINE occurrences = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT occurrences [ ord ( str [ i ] ) - ord ( ' a ' ) ] : NEW_LINE INDENT occurrences [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT index = nextZero ( 0 , occurrences ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if occurrences [ ord ( str [ i ] ) - ord ( ' a ' ) ] > 1 : NEW_LINE INDENT occurrences [ ord ( str [ i ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE ch [ i ] = chr ( ord ( ' a ' ) + index ) NEW_LINE occurrences [ index ] = 1 NEW_LINE index = nextZero ( index + 1 , occurrences ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeksforgeeks \" NEW_LINE print ( getMod ModifiedString ( str ) ) NEW_LINE DEDENT"],"references":["def nextZero ( i , occurrences ) : NEW_LINE INDENT while i < 26 : NEW_LINE INDENT if occurrences [ i ] == 0 : NEW_LINE INDENT return i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT def getModifiedString ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE if n > 26 : NEW_LINE INDENT return \" - 1\" NEW_LINE DEDENT ch = str NEW_LINE ch = list ( ch ) NEW_LINE occurrences = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT occurrences [ ord ( ch [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT index = nextZero ( 0 , occurrences ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if occurrences [ ord ( ch [ i ] ) - ord ( ' a ' ) ] > 1 : NEW_LINE INDENT occurrences [ ord ( ch [ i ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE ch [ i ] = chr ( ord ( ' a ' ) + index ) NEW_LINE occurrences [ index ] = 1 NEW_LINE index = nextZero ( index + 1 , occurrences ) NEW_LINE DEDENT DEDENT ch = ' ' . join ( ch ) NEW_LINE print ( ch ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeksforgeeks \" NEW_LINE getModifiedString ( str ) NEW_LINE DEDENT"],"bleu":0.8234187721025903,"rouge_l":0.8869820269595607}
{"id":1634,"predictions":["def calculateCycycle ( l ) : NEW_LINE INDENT cycle_operations = 0 NEW_LINE while ( l > 0 ) : NEW_LINE INDENT len1 \/\/= 3 NEW_LINE cycle_operations += 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT def minimumOperations ( p , n ) : NEW_LINE INDENT visited = [ 0 ] * ( n + 1 ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ele = p [ i ] NEW_LINE if ( visited [ ele ] == 0 ) : NEW_LINE INDENT visited [ ele ] = 1 NEW_LINE length = 1 NEW_LINE ele = p [ ele ] NEW_LINE while ( visited [ ele ] == 0 ) : NEW_LINE INDENT visited [ ele ] = 1 NEW_LINE length += 1 NEW_LINE ele += 1 NEW_LINE ele = p [ ele ] NEW_LINE DEDENT operations = calculateCyations ( l ) NEW_LINE num = pow ( 3 , operations ) NEW_LINE if ( num != length ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT ans = max ( ans , operations ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT P = [ - 1 , 4 , 6 , 5 , 3 , 2 , 7 , 8 , 9 , 1 ] NEW_LINE n = len ( P ) - 1 NEW_LINE print ( minimumOperations ( P , n ) ) NEW_LINE DEDENT"],"references":["def calculateCycleOperations ( length ) : NEW_LINE INDENT cycle_operations = 0 NEW_LINE while length > 0 : NEW_LINE INDENT length \/\/= 3 NEW_LINE cycle_operations += 1 NEW_LINE DEDENT return cycle_operations - 1 NEW_LINE DEDENT def minimumOperations ( p , n ) : NEW_LINE INDENT visited = [ 0 ] * ( n + 1 ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ele = p [ i ] NEW_LINE if not visited [ ele ] : NEW_LINE INDENT visited [ ele ] = 1 NEW_LINE length = 1 NEW_LINE ele = p [ ele ] NEW_LINE while not visited [ ele ] : NEW_LINE INDENT visited [ ele ] = 1 NEW_LINE length += 1 NEW_LINE ele = p [ ele ] NEW_LINE DEDENT operations = calculateCycleOperations ( length ) NEW_LINE num = pow ( 3 , operations ) NEW_LINE if num != length : NEW_LINE INDENT return - 1 NEW_LINE DEDENT ans = max ( ans , operations ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT P = [ - 1 , 4 , 6 , 5 , 3 , 2 , 7 , 8 , 9 , 1 ] NEW_LINE n = len ( P ) - 1 NEW_LINE print ( minimumOperations ( P , n ) ) NEW_LINE DEDENT"],"bleu":0.8152417936861358,"rouge_l":0.9259334553093448}
{"id":1635,"predictions":["import math ; NEW_LINE r = 3 ; R = 7 ; pi = 3.14159 ; NEW_LINE Volume = 0.14159 ; NEW_LINE Volume = 0.14159 ; NEW_LINE Volume = 0.14159 ; NEW_LINE Volume = 0 ; NEW_LINE Volume = 0.14159 ; NEW_LINE print ( \" Volume : ▁f \" , round ( Volume , 4 * pi * r * r ) ) ; NEW_LINE"],"references":["r = 3 NEW_LINE R = 7 NEW_LINE pi = 3.14159 NEW_LINE Volume = ( float ) ( 2 * pi * pi * R * r * r ) ; NEW_LINE print ( \" Volume : ▁ \" , Volume ) ; NEW_LINE Surface = ( float ) ( 4 * pi * pi * R * r ) ; NEW_LINE print ( \" Surface : ▁ \" , Surface ) ; NEW_LINE"],"bleu":0.26508369240101687,"rouge_l":0.4551177430636512}
{"id":1636,"predictions":["def numberOfPaths ( m , n ) : NEW_LINE INDENT dp = [ 0 ] * n ; NEW_LINE dp [ 0 ] = 1 ; NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT dp [ j ] += dp [ j - 1 ] ; NEW_LINE DEDENT DEDENT return dp [ n - 1 ] ; NEW_LINE DEDENT print ( numberOfPaths ( 3 , 3 ) ) ; NEW_LINE"],"references":["def numberOfPaths ( p , q ) : NEW_LINE INDENT dp = [ 1 for i in range ( q ) ] NEW_LINE for i in range ( p - 1 ) : NEW_LINE INDENT for j in range ( 1 , q ) : NEW_LINE INDENT dp [ j ] += dp [ j - 1 ] NEW_LINE DEDENT DEDENT return dp [ q - 1 ] NEW_LINE DEDENT print ( numberOfPaths ( 3 , 3 ) ) NEW_LINE"],"bleu":0.6033666483047658,"rouge_l":0.7922077922077921}
{"id":1637,"predictions":["def alternate ( a , b , x ) : NEW_LINE INDENT return x [ 0 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = - 10 NEW_LINE b = 15 NEW_LINE x = a NEW_LINE print ( \" x ▁ is : \" , x ) NEW_LINE print ( \" x ▁ is ▁ : \" , x ) NEW_LINE print ( \" \\n \" , x ) NEW_LINE DEDENT"],"references":["def alternate ( a , b , x ) : NEW_LINE INDENT x = a ^ b ^ x NEW_LINE print ( \" After ▁ exchange \" ) NEW_LINE print ( \" x ▁ is \" , x ) NEW_LINE DEDENT a = - 10 NEW_LINE b = 15 NEW_LINE x = a NEW_LINE print ( \" x ▁ is \" , x ) NEW_LINE alternate ( a , b , x ) NEW_LINE"],"bleu":0.6041570607312364,"rouge_l":0.5885506003430533}
{"id":1638,"predictions":["import math NEW_LINE def surface_area_octahedron ( side ) : NEW_LINE INDENT return ( 2 * ( math . sqrt ( 3 ) ) * ( side * side ) ) NEW_LINE DEDENT side = 7 NEW_LINE print ( \" Surface ▁ area ▁ of ▁ octahedron ▁ = \" , surface_area_octa ( side ) ) NEW_LINE"],"references":["import math NEW_LINE def surface_area_octahedron ( side ) : NEW_LINE INDENT return ( 2 * ( math . sqrt ( 3 ) ) * ( side * side ) ) NEW_LINE DEDENT side = 7 NEW_LINE print ( \" Surface ▁ area ▁ of ▁ octahedron ▁ = \" , surface_area_octahedron ( side ) ) NEW_LINE"],"bleu":0.954297861697201,"rouge_l":0.9821428571428572}
{"id":1639,"predictions":["def CenteredDodecahedral_num ( n ) : NEW_LINE INDENT return ( 2 * n + 1 ) * ( 5 * n + 5 * n + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE print ( \" th ▁ Centered \" , \" Digeredhedral ▁ number ▁ : ▁ \" , Centenhedral_num ( n ) ) NEW_LINE n = 12 NEW_LINE print ( CenteredDodecahedral_num ( n ) ) NEW_LINE DEDENT"],"references":["def CenteredDodecahedral_num ( n ) : NEW_LINE INDENT return ( 2 * n + 1 ) * ( 5 * n * n + 5 * n + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE print ( n , \" rd ▁ centered ▁ dodecahedral ▁ number : ▁ \" , CenteredDodecahedral_num ( n ) ) NEW_LINE n = 10 NEW_LINE print ( n , \" th ▁ centered ▁ dodecahedral ▁ number ▁ : ▁ \" , CenteredDodecahedral_num ( n ) ) NEW_LINE DEDENT"],"bleu":0.6847863087518619,"rouge_l":0.8004965419400604}
{"id":1640,"predictions":["def longestSubstring ( s ) : NEW_LINE INDENT cnt = 1 ; NEW_LINE maxi = 1 ; NEW_LINE n = len ( s ) ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] != s [ i - 1 ] ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT maxi = max ( cnt , maxi ) ; NEW_LINE cnt = 1 ; NEW_LINE DEDENT DEDENT maxi = max ( cnt , maxi ) ; NEW_LINE print ( longestSubstring ( s ) ) ; NEW_LINE"],"references":["def longestSubstring ( s ) : NEW_LINE INDENT cnt = 1 ; NEW_LINE maxi = 1 ; NEW_LINE n = len ( s ) ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] != s [ i - 1 ] ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT maxi = max ( cnt , maxi ) ; NEW_LINE cnt = 1 ; NEW_LINE DEDENT DEDENT maxi = max ( cnt , maxi ) ; NEW_LINE return maxi ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" ccccdeededff \" ; NEW_LINE print ( longestSubstring ( s ) ) ; NEW_LINE DEDENT"],"bleu":0.7710794710489279,"rouge_l":0.8681132873044949}
{"id":1641,"predictions":["def firstDigit ( x ) : NEW_LINE INDENT while ( x >= 10 ) : NEW_LINE INDENT x = int ( x \/ 10 ) NEW_LINE DEDENT return x NEW_LINE DEDENT print ( firstDigit ( 12345 ) ) NEW_LINE"],"references":["def firstDigit ( x ) : NEW_LINE INDENT while ( x >= 10 ) : NEW_LINE INDENT x = x \/\/ 10 NEW_LINE DEDENT return x NEW_LINE DEDENT print ( firstDigit ( 12345 ) ) NEW_LINE print ( firstDigit ( 5432 ) ) NEW_LINE"],"bleu":0.7322981654545849,"rouge_l":0.8343102774521297}
{"id":1642,"predictions":["C = [ [ 0 for i in range ( 1000 ) ] for j in range ( 1000 ) ] NEW_LINE def binomialCoeff ( n ) : NEW_LINE INDENT for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT def numberOfWays ( x , y , z ) : NEW_LINE INDENT binomialCoeff ( max ( x , max ( y , z ) ) ) NEW_LINE sum1 = 0 NEW_LINE for i in range ( 1 , z + 1 ) : NEW_LINE INDENT sum1 = ( sum1 + C [ z ] [ i ] ) NEW_LINE DEDENT sum1 = 0 NEW_LINE for i in range ( 1 , y + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , x + 1 ) : NEW_LINE INDENT sum1 = ( sum1 + ( C [ y ] [ i ] * C [ x ] [ j ] ) ) NEW_LINE DEDENT sum1 = ( sum1 + sum1 ) NEW_LINE return sum1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 3 NEW_LINE y = 2 NEW_LINE z = 1 NEW_LINE print ( numberOfWays ( x , y , z ) ) NEW_LINE DEDENT"],"references":["C = [ [ 0 for i in range ( 1000 ) ] for i in range ( 1000 ) ] NEW_LINE def binomialCoeff ( n ) : NEW_LINE INDENT i , j = 0 , 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] +   \\ NEW_LINE INDENT C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def numberOfWays ( x , y , z ) : NEW_LINE INDENT binomialCoeff ( max ( x , max ( y , z ) ) ) NEW_LINE sum = 0 NEW_LINE for i in range ( 1 , z + 1 ) : NEW_LINE INDENT sum = ( sum + C [ z ] [ i ] ) NEW_LINE DEDENT sum1 = 0 NEW_LINE for i in range ( 1 , y + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , x + 1 ) : NEW_LINE INDENT sum1 = ( sum1 + ( C [ y ] [ i ] * C [ x ] [ j ] ) ) NEW_LINE DEDENT DEDENT sum1 = ( sum * sum1 ) NEW_LINE return sum1 NEW_LINE DEDENT x = 3 NEW_LINE y = 2 NEW_LINE z = 1 NEW_LINE print ( numberOfWays ( x , y , z ) ) NEW_LINE"],"bleu":0.8887764287100082,"rouge_l":0.9257300528857207}
{"id":1643,"predictions":["def isDivisible ( n ) : NEW_LINE INDENT while n \/\/ 100 : NEW_LINE INDENT d = n % 10 NEW_LINE n \/\/= 10 NEW_LINE n = abs ( n - ( d * 14 ) ) NEW_LINE DEDENT return ( n % 47 == 0 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 59173 NEW_LINE if ( isDivisible ( N ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def isDivisible ( n ) : NEW_LINE INDENT while n \/\/ 100 : NEW_LINE INDENT d = n % 10 NEW_LINE n \/\/= 10 NEW_LINE n = abs ( n - ( d * 14 ) ) NEW_LINE DEDENT return ( n % 47 == 0 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 59173 NEW_LINE if ( isDivisible ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.9476125937240817,"rouge_l":0.979381443298969}
{"id":1644,"predictions":["def compute ( ) : NEW_LINE INDENT SIZE = 1001 NEW_LINE n = 3 NEW_LINE ans = 1 NEW_LINE for n in range ( 3 , SIZE + 2 ) : NEW_LINE INDENT if n % 2 : NEW_LINE INDENT ans += 4 * n - 6 * ( n - 1 ) NEW_LINE DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["def compute ( ) : NEW_LINE INDENT SIZE = 1001 NEW_LINE ans = 1 NEW_LINE ans += sum ( 4 * i * i - 6 * ( i - 1 ) for i in range ( 3 , SIZE + 1 , 2 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.6214806157182855,"rouge_l":0.6989583333333333}
{"id":1645,"predictions":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 100000000 NEW_LINE sum = 0 NEW_LINE def find_harshallPrimes ( n , digitSum , isprime ) : NEW_LINE INDENT m = n * 10 NEW_LINE s = digitSum ( m ) NEW_LINE i = 0 NEW_LINE while i < 10 and m < LIMIT : NEW_LINE INDENT if ( isprime and isprime ( m ) ) : NEW_LINE INDENT sum += sum ( m ) NEW_LINE DEDENT if ( m % s == 0 ) : NEW_LINE INDENT find_harshallPrimes ( m , s , is_prime ( m \/\/ s ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE s += 1 NEW_LINE DEDENT if ( m % s == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( x == 0 or x == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT def is_harshall_primes ( x ) : NEW_LINE INDENT if x < 0 : NEW_LINE INDENT return False NEW_LINE DEDENT if x == 0 or x == 1 : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 14 NEW_LINE ans = [ 0 ] NEW_LINE def find_harshad_primes ( n , digitsum , isstrong ) : NEW_LINE INDENT m = n * 10 NEW_LINE s = digitsum NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT if m >= LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT if isstrong and eulerlib . is_prime ( m ) : NEW_LINE INDENT ans [ 0 ] += m NEW_LINE DEDENT if m % s == 0 : NEW_LINE INDENT find_harshad_primes ( m , s , eulerlib . is_prime ( m \/\/ s ) ) NEW_LINE DEDENT m += 1 NEW_LINE s += 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , 10 ) : NEW_LINE INDENT find_harshad_primes ( i , i , False ) NEW_LINE DEDENT return str ( ans [ 0 ] ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.4116385247439094,"rouge_l":0.6336016619059984}
{"id":1646,"predictions":["def compute ( ) : NEW_LINE INDENT LENGTH = 51 NEW_LINE ways = [ 0 ] * ( LENGTH + 1 ) NEW_LINE for n in range ( 1 , LENGTH + 1 ) : NEW_LINE INDENT for k in range ( 1 , 4ENGTH + 1 ) : NEW_LINE INDENT ways [ n ] += ways [ n - k ] NEW_LINE DEDENT DEDENT return str ( ways [ - 1 ] ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["def compute ( ) : NEW_LINE INDENT LENGTH = 50 NEW_LINE ways = [ 1 ] + [ 0 ] * LENGTH NEW_LINE for n in range ( 1 , len ( ways ) ) : NEW_LINE INDENT ways [ n ] += sum ( ways [ max ( n - 4 , 0 ) : n ] ) NEW_LINE DEDENT return str ( ways [ - 1 ] ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.6490281139403525,"rouge_l":0.781915815000866}
{"id":1647,"predictions":["import math NEW_LINE def compute ( ) : NEW_LINE INDENT if y == 1 : NEW_LINE INDENT return x % m NEW_LINE DEDENT else : NEW_LINE INDENT return pow ( x , y - 1 , pow ( m ) , m ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import eulerlib , sys NEW_LINE def compute ( ) : NEW_LINE INDENT x , y , m = 1777 , 1855 , 10 ** 8 NEW_LINE sys . setrecursionlimit ( y + 30 ) NEW_LINE ans = tetration_mod ( x , y , m ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def tetration_mod ( x , y , m ) : NEW_LINE INDENT if y == 1 : NEW_LINE INDENT return x % m NEW_LINE DEDENT else : NEW_LINE INDENT return pow ( x , tetration_mod ( x , y - 1 , totient ( m ) ) , m ) NEW_LINE DEDENT DEDENT def totient ( n ) : NEW_LINE INDENT assert n > 0 NEW_LINE p = 1 NEW_LINE i = 2 NEW_LINE end = eulerlib . sqrt ( n ) NEW_LINE while i <= end : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT p *= i - 1 NEW_LINE n \/\/= i NEW_LINE while n % i == 0 : NEW_LINE INDENT p *= i NEW_LINE n \/\/= i NEW_LINE DEDENT end = eulerlib . sqrt ( n ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if n != 1 : NEW_LINE INDENT p *= n - 1 NEW_LINE DEDENT return p NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.0753822929419843,"rouge_l":0.39261313001287257}
{"id":1648,"predictions":["import math NEW_LINE def compute ( ) : NEW_LINE INDENT def factorialSuffix ( n ) : NEW_LINE INDENT twos = count_factors ( n , 2 ) - count_factors ( n , 5 ) NEW_LINE if ( twos >= 2005 ) : NEW_LINE INDENT twos = ( twos - 5 ) % 1000 + 5 NEW_LINE DEDENT return factorial ( factorial ( n ) * pow ( 2 , ( int ( twos ) \/\/ 100000 ) ) % 100000 NEW_LINE DEDENT def factorial_factor ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return factorial ( n \/\/ 2 ) * factorial ( n \/\/ 2 ) NEW_LINE DEDENT DEDENT def factorialCoprime ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return odd_factorial ( n \/\/ 5 ) * factorial ( n \/\/ 2 ) NEW_LINE DEDENT DEDENT def factorialCoprime ( n ) : NEW_LINE INDENT n %= 100000 NEW_LINE product = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if i % 2 != 0 and i % 5 != 0 : NEW_LINE INDENT product = i * product % 100000 NEW_LINE DEDENT DEDENT return product NEW_LINE DEDENT def factorial ( end ) : NEW_LINE INDENT if end == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return end \/\/ n + countFactors ( end \/\/ n , n ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) NEW_LINE DEDENT"],"references":["def compute ( ) : NEW_LINE INDENT ans = factorial_suffix ( 10 ** 12 ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def factorial_suffix ( n ) : NEW_LINE INDENT twos = count_factors ( n , 2 ) - count_factors ( n , 5 ) NEW_LINE if twos >= 2505 : NEW_LINE INDENT twos = ( twos - 5 ) % 2500 + 5 NEW_LINE DEDENT return factorialish ( n ) * pow ( 2 , twos , 100000 ) % 100000 NEW_LINE DEDENT def factorialish ( n ) : NEW_LINE INDENT return even_factorialish ( n ) * odd_factorialish ( n ) % 100000 NEW_LINE DEDENT def even_factorialish ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return factorialish ( n \/\/ 2 ) NEW_LINE DEDENT DEDENT def odd_factorialish ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return odd_factorialish ( n \/\/ 5 ) * factorial_coprime ( n ) % 100000 NEW_LINE DEDENT DEDENT def factorial_coprime ( n ) : NEW_LINE INDENT n %= 100000 NEW_LINE product = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if i % 2 != 0 and i % 5 != 0 : NEW_LINE INDENT product = i * product % 100000 NEW_LINE DEDENT DEDENT return product NEW_LINE DEDENT def count_factors ( end , n ) : NEW_LINE INDENT if end == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return end \/\/ n + count_factors ( end \/\/ n , n ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.7347958204013809,"rouge_l":0.8459379035427544}
{"id":1649,"predictions":["def compute ( ) : NEW_LINE INDENT INDENT count = 0 NEW_LINE num = [ 0 ] * 8 NEW_LINE rec = [ 0 ] * 8 NEW_LINE num [ 0 ] = num [ 1 ] NEW_LINE e = num [ 2 ] NEW_LINE z = num [ 4 ] NEW_LINE m = num [ 2 ] NEW_LINE k = num [ 0 ] NEW_LINE if m < 0 or m > 9 : NEW_LINE INDENT continue NEW_LINE DEDENT if ( o < 0 or o > 9 ) : NEW_LINE INDENT continue NEW_LINE DEDENT j = a + b + d - g - m NEW_LINE if ( j < 0 or m > 9 ) : NEW_LINE INDENT continue NEW_LINE DEDENT l = a + b + c + d - k NEW_LINE if ( l < 0 or l > 9 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( l < 0 or l > 9 ) : NEW_LINE INDENT continue NEW_LINE DEDENT f = a + b + c + d - e - k NEW_LINE if ( h < 0 or f > 9 ) : continue NEW_LINE INDENT continue NEW_LINE DEDENT h = a + b + c - d - e - f - f NEW_LINE if ( h < 9 ) : NEW_LINE INDENT continue NEW_LINE DEDENT p = a + b + c - d - f - f - l NEW_LINE if ( not p ) : NEW_LINE INDENT continue NEW_LINE DEDENT h = a + b + c - d - l NEW_LINE if ( not p > 9 ) : NEW_LINE INDENT continue NEW_LINE DEDENT count += 1 NEW_LINE DEDENT return str ( count ( num ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["def compute ( ) : NEW_LINE INDENT ans = 0 NEW_LINE digits = tuple ( range ( 10 ) ) NEW_LINE for b in digits : NEW_LINE INDENT for c in digits : NEW_LINE INDENT for d in digits : NEW_LINE INDENT for e in digits : NEW_LINE INDENT for i in digits : NEW_LINE INDENT m = b + c + d - e - i NEW_LINE if m < 0 or m > 9 : continue NEW_LINE for k in digits : NEW_LINE INDENT f = b + c + d * 2 - e - i - k NEW_LINE if f < 0 or f > 9 : continue NEW_LINE for a in digits : NEW_LINE INDENT for g in digits : NEW_LINE INDENT o = a + b + d - g - k NEW_LINE if o < 0 or o > 9 : continue NEW_LINE j = a + b + c - g - m NEW_LINE if j < 0 or j > 9 : continue NEW_LINE l = a + b + c + d - i - j - k NEW_LINE if l < 0 or l > 9 : continue NEW_LINE h = a + b + c + d - e - f - g NEW_LINE if h < 0 or h > 9 : continue NEW_LINE n = a + c + d - f - j NEW_LINE if n < 0 or n > 9 : continue NEW_LINE p = a + b + c - h - l NEW_LINE if p < 0 or p > 9 : continue NEW_LINE ans += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.46495897383628876,"rouge_l":0.5799508958888366}
{"id":1650,"predictions":["import math NEW_LINE def compute ( ) : NEW_LINE INDENT modulus = 2 ** 10 ** 9 + 7 NEW_LINE n = ( 2 ** 3 ) % modulo NEW_LINE if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( n * 284 ) % modulus ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["def compute ( ) : NEW_LINE INDENT MOD = 10 ** 10 NEW_LINE ans = ( 28433 * pow ( 2 , 7830457 , MOD ) + 1 ) % MOD NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.4168353754864562,"rouge_l":0.6381995133819951}
{"id":1651,"predictions":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT start_num = 1 NEW_LINE end_num = 500 NEW_LINE rep_num = 0 NEW_LINE prr_num = 0 NEW_LINE prr_num = 1 NEW_LINE def is_primality ( start_num ) : NEW_LINE INDENT if start_num <= end_num : NEW_LINE INDENT return True NEW_LINE DEDENT if start_num <= end_num : NEW_LINE INDENT return False NEW_LINE DEDENT if str ( start_num ) == \" P \" : NEW_LINE INDENT return True NEW_LINE DEDENT if isprime [ pos ] == \" P \" : NEW_LINE INDENT return False NEW_LINE DEDENT if is_prime_num : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import eulerlib , fractions NEW_LINE def compute ( ) : NEW_LINE INDENT START_NUM = 1 NEW_LINE END_NUM = 500 NEW_LINE CROAK_SEQ = \" PPPPNNPPPNPPNPN \" NEW_LINE assert 0 <= START_NUM < END_NUM NEW_LINE assert 1 <= len ( CROAK_SEQ ) NEW_LINE NUM_JUMPS = len ( CROAK_SEQ ) - 1 NEW_LINE NUM_TRIALS = 2 ** NUM_JUMPS NEW_LINE globalnumerator = 0 NEW_LINE isprime = eulerlib . list_primality ( END_NUM ) NEW_LINE for i in range ( START_NUM , END_NUM + 1 ) : NEW_LINE INDENT for j in range ( NUM_TRIALS ) : NEW_LINE INDENT pos = i NEW_LINE trialnumerator = 1 NEW_LINE if isprime [ pos ] == ( CROAK_SEQ [ 0 ] == ' P ' ) : NEW_LINE INDENT trialnumerator *= 2 NEW_LINE DEDENT for k in range ( NUM_JUMPS ) : NEW_LINE INDENT if pos <= START_NUM : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT elif pos >= END_NUM : NEW_LINE INDENT pos -= 1 NEW_LINE DEDENT elif ( j >> k ) & 1 == 0 : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT else : NEW_LINE INDENT pos -= 1 NEW_LINE DEDENT if isprime [ pos ] == ( CROAK_SEQ [ k + 1 ] == ' P ' ) : NEW_LINE INDENT trialnumerator *= 2 NEW_LINE DEDENT DEDENT globalnumerator += trialnumerator NEW_LINE DEDENT DEDENT globaldenominator = ( END_NUM + 1 - START_NUM ) * 2 ** NUM_JUMPS * 3 ** len ( CROAK_SEQ ) NEW_LINE ans = fractions . Fraction ( globalnumerator , globaldenominator ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.14830148203512492,"rouge_l":0.41219310759065997}
{"id":1652,"predictions":["import eulerlib , fractions NEW_LINE def compute ( ) : NEW_LINE INDENT isprime = eulerlib . list_primality ( 999999 ) NEW_LINE isprime = eulerlib . list_primality ( 999999 ) NEW_LINE isprime = allprime [ 0 ] NEW_LINE for x in range ( 1 , len ( isprime ) ) : NEW_LINE INDENT for y in range ( 1 , y ) : NEW_LINE INDENT a = x * y * y - 1 NEW_LINE if a >= len ( isprime ) : NEW_LINE INDENT break NEW_LINE DEDENT if isprime [ a ] and isprime [ a ] : NEW_LINE INDENT continue NEW_LINE DEDENT for z in range ( y + 1 ) : NEW_LINE INDENT if fractions . gcd ( y , z ) != 1 : NEW_LINE INDENT continue NEW_LINE DEDENT if isprime [ b ] and isprime [ z ] : NEW_LINE INDENT addend = a + b + c + 1 NEW_LINE if c >= len ( isprime ) : NEW_LINE INDENT break NEW_LINE DEDENT if not allprime [ b ] and isprime [ c ] : NEW_LINE INDENT addend = a + b + c + c NEW_LINE if ans + addend < sum : NEW_LINE INDENT break NEW_LINE DEDENT ans += addendend NEW_LINE DEDENT DEDENT DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import eulerlib , fractions , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 8 NEW_LINE ans = 0 NEW_LINE isprime = eulerlib . list_primality ( LIMIT - 1 ) NEW_LINE for x in range ( 1 , LIMIT \/\/ 4 + 1 ) : NEW_LINE INDENT for y in itertools . count ( 1 ) : NEW_LINE INDENT a = x * y * y - 1 NEW_LINE if a >= LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT if not isprime [ a ] : NEW_LINE INDENT continue NEW_LINE DEDENT for z in itertools . count ( y + 1 ) : NEW_LINE INDENT if fractions . gcd ( y , z ) != 1 : NEW_LINE INDENT continue NEW_LINE DEDENT c = x * z * z - 1 NEW_LINE if c >= LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT if isprime [ c ] : NEW_LINE INDENT b = x * y * z - 1 NEW_LINE if isprime [ b ] : NEW_LINE INDENT ans += a + b + c NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.609593796351136,"rouge_l":0.7185396546678373}
{"id":1653,"predictions":["import itertools NEW_LINE def compute ( ) : NEW_LINE INDENT diGARGET = 10 NEW_LINE sum = Fraction ( 10 ) NEW_LINE ans = 0 NEW_LINE for k in range ( 1 , deGree ) : NEW_LINE INDENT for n in range ( k + 1 ) : NEW_LINE INDENT if n == diGree + 2 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if sum . denominator ( ) == 1 : NEW_LINE INDENT for k in range ( 1 , d + 1 ) : NEW_LINE INDENT product = Fraction ( str ( n ) ) NEW_LINE for j in range ( 1 , k + 1 ) : NEW_LINE INDENT product *= Fraction ( n - j ) NEW_LINE DEDENT DEDENT if sum . denominator ( ) : NEW_LINE INDENT return str ( sum ) NEW_LINE DEDENT ans = sum + product NEW_LINE DEDENT return str ( ans ) NEW_LINE DEDENT deffp4 ( k , n ) : NEW_LINE INDENT sum = FractionFunction ( n ) NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT product *= Fraction ( i ) NEW_LINE for j in range ( k + 1 ) : NEW_LINE INDENT if j != i : NEW_LINE INDENT product *= Fraction ( n - j ) , i - j ) NEW_LINE DEDENT DEDENT sum = Fraction ( product ) NEW_LINE return sum + sum ( product ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import itertools NEW_LINE from fractions import Fraction NEW_LINE DEGREE = 10 NEW_LINE def compute ( ) : NEW_LINE INDENT ans = Fraction ( 0 , 1 ) NEW_LINE for k in range ( 1 , DEGREE + 1 ) : NEW_LINE INDENT for n in itertools . count ( k + 1 ) : NEW_LINE INDENT if n == DEGREE + 2 : NEW_LINE INDENT raise AssertionError ( ) NEW_LINE DEDENT reference = Fraction ( generating_function ( n ) , 1 ) NEW_LINE term = optimum_polynomial ( k , n ) NEW_LINE if term != reference : NEW_LINE INDENT ans += term NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT return str ( ans . numerator ) + ( \" \" if ans . denominator == 1 else \" \/ \" + str ( ans . denominator ) ) NEW_LINE DEDENT def optimum_polynomial ( k , n ) : NEW_LINE INDENT sum = Fraction ( 0 , 1 ) NEW_LINE for i in range ( k + 1 ) : NEW_LINE INDENT product = Fraction ( generating_function ( i ) , 1 ) NEW_LINE for j in range ( 1 , k + 1 ) : NEW_LINE INDENT if j != i : NEW_LINE INDENT product *= Fraction ( n - j , i - j ) NEW_LINE DEDENT DEDENT sum += product NEW_LINE DEDENT return sum NEW_LINE DEDENT def generating_function ( n ) : NEW_LINE INDENT return sum ( ( - n ) ** i for i in range ( DEGREE + 1 ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.5694883617451427,"rouge_l":0.6433897072194945}
{"id":1654,"predictions":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT MODULUS = 100000000 NEW_LINE numSubsets = [ 0 ] * 250 NEW_LINE numSubsets = [ 0 ] * 250 NEW_LINE for i in range ( 1 , 250010 ) : NEW_LINE INDENT temp = pow ( i , i , 250 ) NEW_LINE new_sets [ 0 ] = 1 NEW_LINE for j in range ( 250 ) : NEW_LINE INDENT new_sets [ ( j + temp ) % 250 ] = ( numSubsets [ j ] + numSubsets [ ( j + temp ) % 250 ] ) % 100 NEW_LINE DEDENT numSubsets = new_ ** 2 - 1 + MODULUS ) % MODULUS NEW_LINE DEDENT return str ( numSubsets [ 0 ] - 1 + modULUS ) % MODULUS NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["def compute ( ) : NEW_LINE INDENT MOD = 10 ** 16 NEW_LINE subsets = [ 0 ] * 250 NEW_LINE subsets [ 0 ] = 1 NEW_LINE for i in range ( 1 , 250250 + 1 ) : NEW_LINE INDENT offset = pow ( i , i , 250 ) NEW_LINE subsets = [ ( val + subsets [ ( j - offset ) % 250 ] ) % MOD for ( j , val ) in enumerate ( subsets ) ] NEW_LINE DEDENT ans = ( subsets [ 0 ] - 1 ) % MOD NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.470004363331733,"rouge_l":0.6538049303322615}
{"id":1655,"predictions":["import eumpy NEW_LINE def compute ( ) : NEW_LINE INDENT totients = eulerlib . list_totients ( 999999 ) NEW_LINE totients = eulerlib . list_totients ( 999999 ) NEW_LINE ans = sum ( totients ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT totients = eulerlib . list_totients ( 10 ** 6 ) NEW_LINE ans = sum ( itertools . islice ( totients , 2 , None ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.7198606267021128,"rouge_l":0.7955856533734638}
{"id":1656,"predictions":["def compute ( ) : NEW_LINE INDENT total = 200 NEW_LINE COINS = [ 1 , 2 , 5 , 10 , 20 , 50 , 100 , 200 ] NEW_LINE ans = [ [ 1 , 2 , 5 , 10 , 50 , 100 , 200 ] for _ in range ( len ( COINS ) ) ] NEW_LINE return str ( ans [ - 1 ] [ total ] ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["def compute ( ) : NEW_LINE INDENT TOTAL = 200 NEW_LINE ways = [ 1 ] + [ 0 ] * TOTAL NEW_LINE for coin in [ 1 , 2 , 5 , 10 , 20 , 50 , 100 , 200 ] : NEW_LINE INDENT for i in range ( len ( ways ) - coin ) : NEW_LINE INDENT ways [ i + coin ] += ways [ i ] NEW_LINE DEDENT DEDENT return str ( ways [ - 1 ] ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.5346660756259735,"rouge_l":0.6927383237364044}
{"id":1657,"predictions":["import math NEW_LINE def compute ( ) : NEW_LINE INDENT IERATIONS = 10000000 NEW_LINE x = 1 NEW_LINE y = - 1 NEW_LINE def f ( x ) : NEW_LINE INDENT if x > 0 : NEW_LINE INDENT return x + Fraction ( x ) \/\/ ( x ) NEW_LINE DEDENT x = - 1 NEW_LINE y = - 1 NEW_LINE while True : NEW_LINE INDENT x = Fraction ( x ) NEW_LINE if x >= 0 : NEW_LINE INDENT break NEW_LINE DEDENT x = f ( x ) + f ( y ) NEW_LINE DEDENT ans = x + Fraction ( x ) NEW_LINE return f \" { ans : .9f } \" . format ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def compute ( ) : NEW_LINE INDENT def f ( x ) : NEW_LINE INDENT return math . floor ( 2.0 ** ( 30.403243784 - x * x ) ) \/ 1.0e9 NEW_LINE DEDENT ITERATIONS = 10 ** 12 NEW_LINE x = - 1.0 NEW_LINE y = - 1.0 NEW_LINE i = 0 NEW_LINE while i < ITERATIONS : NEW_LINE INDENT if i > 0 and x == y : NEW_LINE INDENT break NEW_LINE DEDENT x = f ( x ) NEW_LINE y = f ( f ( y ) ) NEW_LINE i += 1 NEW_LINE DEDENT remain = ( ITERATIONS - i ) % i NEW_LINE for i in range ( remain ) : NEW_LINE INDENT x = f ( x ) NEW_LINE DEDENT ans = x + f ( x ) NEW_LINE ans = math . floor ( ans * 1.0e9 ) \/ 1.0e9 NEW_LINE return f \" { ans : .9f } \" NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.46969231443479686,"rouge_l":0.5857255988913086}
{"id":1658,"predictions":["def compute ( ) : NEW_LINE INDENT ans = sum ( 1 for b in range ( 1 , 100 ) for p in range ( 1 , 100 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["def compute ( ) : NEW_LINE INDENT ans = max ( sum ( int ( c ) for c in str ( a ** b ) ) for a in range ( 100 ) for b in range ( 100 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.6410498128961021,"rouge_l":0.8121301775147929}
{"id":1659,"predictions":["def compute ( ) : NEW_LINE INDENT max_prod = 1 NEW_LINE ans = 1 NEW_LINE for i in range ( 0 , len ( num ) ) : NEW_LINE INDENT prod = 1 NEW_LINE for j in range ( ord ( num [ i + j ] ) - ord ( '0' ) ) : NEW_LINE INDENT prod *= ord ( num [ j ] ) - ord ( '0' ) NEW_LINE ans = max ( ans , maxprod ) NEW_LINE DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["def compute ( ) : NEW_LINE INDENT ans = max ( digit_product ( NUMBER [ i : i + ADJACENT ] ) for i in range ( len ( NUMBER ) - ADJACENT + 1 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def digit_product ( s ) : NEW_LINE INDENT result = 1 NEW_LINE for c in s : NEW_LINE INDENT result *= int ( c ) NEW_LINE DEDENT return result NEW_LINE DEDENT NUMBER = \"7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450\" NEW_LINE ADJACENT = 13 NEW_LINE if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.4613468730196137,"rouge_l":0.5418070444104134}
{"id":1660,"predictions":["import eulerlib , fractions , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT BASE = 10 NEW_LINE DIGITS = 20 NEW_LINE CON INCREITS = 3 NEW_LINE MAX_SUM = 9 NEW_LINE MAX_SUM = 9 NEW_LINE def compute ( ) : NEW_LINE INDENT BASE = 10 NEW_LINE DIGITS = 20 NEW_LINE MAX_SUM = 9 NEW_LINE for prefix_sum in range ( DIGITS + 1 ) : NEW_LINE INDENT row = [ ] NEW_LINE if ( bit_sum ( prefix ) <= MAX_SUM ) : NEW_LINE INDENT for prefix_sum ( prefix_sum ( prefix ) <= MAX_SUM ) : NEW_LINE INDENT for prefix_sum in range ( len ( prefix_sum ( prefix ) ) ) : NEW_LINE INDENT sum = 0 NEW_LINE if ( ( prefix_sum ( prefix ) <= MAX_SUM ) ) : NEW_LINE INDENT for next_sum in range ( 0 , len ( prefix_sum ) ) : NEW_LINE INDENT sum += ( prefix [ digits - 1 ] [ prefix_sum ] [ prefix_sum % BASE * BASE + next_sum ) * BASE + next_sum ] ) NEW_LINE DEDENT DEDENT row = val NEW_LINE DEDENT DEDENT return ways [ DIGITS + 1 ] [ 0 ] - ways [ 0 ] [ 0 ] NEW_LINE DEDENT def digits_sum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for n in range ( 10 , 10 ) : NEW_LINE INDENT sum += n % 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["def compute ( ) : NEW_LINE INDENT BASE = 10 NEW_LINE DIGITS = 20 NEW_LINE CONSECUTIVE = 3 NEW_LINE MAX_SUM = 9 NEW_LINE innerlen = BASE ** CONSECUTIVE NEW_LINE ways = [ [ 1 ] + [ 0 ] * ( innerlen - 1 ) ] NEW_LINE for digits in range ( 1 , DIGITS + CONSECUTIVE + 1 ) : NEW_LINE INDENT newrow = [ ] NEW_LINE for prefix in range ( innerlen ) : NEW_LINE INDENT sum = 0 NEW_LINE if digit_sum ( prefix ) <= MAX_SUM : NEW_LINE INDENT for nextdigit in range ( BASE ) : NEW_LINE INDENT sum += ways [ digits - 1 ] [ prefix % ( BASE ** ( CONSECUTIVE - 1 ) ) * BASE + nextdigit ] NEW_LINE DEDENT DEDENT newrow . append ( sum ) NEW_LINE DEDENT ways . append ( newrow ) NEW_LINE DEDENT ans = ways [ - 1 ] [ 0 ] - ways [ - 2 ] [ 0 ] NEW_LINE return str ( ans ) NEW_LINE DEDENT def digit_sum ( n ) : NEW_LINE INDENT return sum ( int ( c ) for c in str ( n ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.41040022572072865,"rouge_l":0.6138793766161157}
{"id":1661,"predictions":["import math NEW_LINE MODULUS = 10 ** 9 NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 1000000000000000 NEW_LINE MODULUS = 10 ** 9 NEW_LINE divcount = int ( math . sqrt ( splitCount \/ 3 ) ) NEW_LINE splitnt = int ( math . sqrt ( ( splitCount \/ 3 ) ) ) NEW_LINE splitnt = int ( math . sqrt ( split ( splitCount \/ 3 ) ) ) NEW_LINE def ( i ) : NEW_LINE INDENT return sum ( LIMIT \/\/ i * i % MODULUS NEW_LINE DEDENT if i >= 2 : NEW_LINE INDENT return str ( i ) NEW_LINE DEDENT for i in range ( 2 , LIMIT + 1 ) : NEW_LINE INDENT start = LIMIT \/\/ i NEW_LINE end = LIMIT \/\/ i NEW_LINE sumsquares = sum ( sumsquares + MODULUS ) % MODULUS NEW_LINE ans = ( sum + i * sumsquares ) % MODULUS NEW_LINE sumsquares = ( sum + i * sumsquares % MODULUS ) % MODULUS NEW_LINE ans = ( ans + i * sumsquares % MODULUS ) % MODULUS NEW_LINE DEDENT return str ( ans ) NEW_LINE DEDENT def sumSquares ( n ) : NEW_LINE INDENT x = ( n ** 2 + 1 ) NEW_LINE y = ( x + 1 ) NEW_LINE if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 15 NEW_LINE MODULUS = 10 ** 9 NEW_LINE splitcount = eulerlib . sqrt ( LIMIT ) NEW_LINE splitat = LIMIT \/\/ ( splitcount + 1 ) NEW_LINE def sum_squares ( s , e ) : NEW_LINE INDENT return ( e * ( e + 1 ) * ( e * 2 + 1 ) - s * ( s + 1 ) * ( s * 2 + 1 ) ) \/\/ 6 NEW_LINE DEDENT ans = sum ( ( i * i * ( LIMIT \/\/ i ) ) for i in range ( 1 , splitat + 1 ) ) NEW_LINE ans += sum ( ( sum_squares ( LIMIT \/\/ ( i + 1 ) , LIMIT \/\/ i ) * i ) for i in range ( 1 , splitcount + 1 ) ) NEW_LINE return str ( ans % MODULUS ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.3116297292271037,"rouge_l":0.47328427451607746}
{"id":1662,"predictions":["import fractions NEW_LINE def compute ( ) : NEW_LINE INDENT maxnum = 0 NEW_LINE bestb = 0 NEW_LINE for a in range ( - 1000 , 1001 ) : NEW_LINE INDENT for b in range ( - 1000 , 1001 ) : NEW_LINE INDENT num = ( i * i + a ) + b NEW_LINE if num > maxNum : NEW_LINE INDENT bestnum = num NEW_LINE bestb = a NEW_LINE bestb = b NEW_LINE DEDENT DEDENT DEDENT return str ( besta * bestb ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT ans = max ( ( ( a , b ) for a in range ( - 999 , 1000 ) for b in range ( 2 , 1000 ) ) , key = count_consecutive_primes ) NEW_LINE return str ( ans [ 0 ] * ans [ 1 ] ) NEW_LINE DEDENT def count_consecutive_primes ( ab ) : NEW_LINE INDENT a , b = ab NEW_LINE for i in itertools . count ( ) : NEW_LINE INDENT n = i * i + i * a + b NEW_LINE if not is_prime ( n ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT DEDENT isprimecache = eulerlib . list_primality ( 1000 ) NEW_LINE def is_prime ( n ) : NEW_LINE INDENT if n < 0 : NEW_LINE INDENT return False NEW_LINE DEDENT elif n < len ( isprimecache ) : NEW_LINE INDENT return isprimecache [ n ] NEW_LINE DEDENT else : NEW_LINE INDENT return eulerlib . is_prime ( n ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.2281880716438433,"rouge_l":0.47067901234567905}
{"id":1663,"predictions":["import eulerlib NEW_LINE MOD = 5 NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 5 NEW_LINE MODULUS = 100000000 NEW_LINE isprime = eulerlib . list_primality ( LIMIT \/\/ 2 ) NEW_LINE numSubsets = [ 0 ] * LIMIT \/\/ 2 NEW_LINE numSubsets [ 0 ] = 1 NEW_LINE maxsum = 0 NEW_LINE for i in range ( LIMIT ) : NEW_LINE INDENT if isprime [ i ] : NEW_LINE INDENT continue NEW_LINE DEDENT maxsum += i NEW_LINE for j in range ( maxSum - i + 1 , i + 1 ) : NEW_LINE INDENT temp = numSubsets [ j ] + numSubsets [ j - i ] NEW_LINE if temp < MODULUS : NEW_LINE INDENT numSubsets [ j ] = temp NEW_LINE DEDENT else : NEW_LINE INDENT numSubsets [ j ] = temp - MODULUS NEW_LINE DEDENT DEDENT ans = sum ( ans + numSubsets [ i ] ) % MODULUS NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 5000 NEW_LINE MODULUS = 10 ** 16 NEW_LINE count = [ 0 ] * ( LIMIT ** 2 \/\/ 2 ) NEW_LINE count [ 0 ] = 1 NEW_LINE s = 0 NEW_LINE for p in eulerlib . list_primes ( LIMIT ) : NEW_LINE INDENT for i in reversed ( range ( s + 1 ) ) : NEW_LINE INDENT count [ i + p ] = ( count [ i + p ] + count [ i ] ) % MODULUS NEW_LINE DEDENT s += p NEW_LINE DEDENT isprime = eulerlib . list_primality ( s + 1 ) NEW_LINE ans = sum ( count [ i ] for i in range ( s + 1 ) if isprime [ i ] ) % MODULUS NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.4762895219558382,"rouge_l":0.6070514643161786}
{"id":1664,"predictions":["def compute ( ) : NEW_LINE INDENT N = 5 NEW_LINE two_Pow_N = 1 NEW_LINE n = 2 ** N - 1 NEW_LINE result = 0 NEW_LINE j = 2 ** ( 2 ** ( N ) - 1 ) + 1 NEW_LINE for i in range ( start , end , 2 ) : NEW_LINE INDENT if checkArrangement ( i ) : NEW_LINE INDENT result += i NEW_LINE DEDENT DEDENT return str ( result ) NEW_LINE DEDENT def check_arrangement ( digits ) : NEW_LINE INDENT result = 0 NEW_LINE temp = ( digits & 0 ) & ( ( digits & 0xFFFFFF ) ) NEW_LINE for i in range ( 2 , end + 1 , 2 ) : NEW_LINE INDENT if check_arrangement ( i ) : NEW_LINE INDENT result += i NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["def compute ( ) : NEW_LINE INDENT N = 5 NEW_LINE TWO_POW_N = 2 ** N NEW_LINE MASK = TWO_POW_N - 1 NEW_LINE def check_arrangement ( digits ) : NEW_LINE INDENT seen = set ( ) NEW_LINE digits |= digits << TWO_POW_N NEW_LINE for i in range ( TWO_POW_N ) : NEW_LINE INDENT seen . add ( ( digits >> i ) & MASK ) NEW_LINE DEDENT return len ( seen ) == TWO_POW_N NEW_LINE DEDENT start = 2 ** ( TWO_POW_N - N - 1 ) + 1 NEW_LINE end = 2 ** ( TWO_POW_N - N ) NEW_LINE ans = sum ( i for i in range ( start , end , 2 ) if check_arrangement ( i ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.5005136113601981,"rouge_l":0.5738294049254836}
{"id":1665,"predictions":["def compute ( ) : NEW_LINE INDENT LIMIT = 10 NEW_LINE numdivisors = [ 2 for i in range ( 2 , len ( numdivisors ) ) ] NEW_LINE for i in range ( 2 , len ( numdivisors ) ) : NEW_LINE INDENT for j in range ( i * 2 , len ( numdivisors ) + 1 , i ) : NEW_LINE INDENT numdivisors [ j ] += 1 NEW_LINE DEDENT DEDENT ans = sum ( numdivisors [ i - 1 ] ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["def compute ( ) : NEW_LINE INDENT divisors = [ 2 ] * ( 10 ** 7 + 1 ) NEW_LINE for i in range ( 2 , ( len ( divisors ) + 1 ) \/\/ 2 ) : NEW_LINE INDENT for j in range ( i * 2 , len ( divisors ) , i ) : NEW_LINE INDENT divisors [ j ] += 1 NEW_LINE DEDENT DEDENT ans = sum ( ( 1 if divisors [ i ] == divisors [ i + 1 ] else 0 ) for i in range ( 2 , len ( divisors ) - 1 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.6118328455409476,"rouge_l":0.7199740596627757}
{"id":1666,"predictions":["def compute ( ) : NEW_LINE INDENT for i in range ( 1 , len ( triangle ) ) : NEW_LINE INDENT for j in range ( len ( triangle ) ) : NEW_LINE INDENT if triangle [ i ] [ j ] == 0 : NEW_LINE INDENT triangle [ i ] [ j ] += max ( triangle [ i + 1 ] [ j ] , triangle [ i + 1 ] [ j + 1 ] ) NEW_LINE DEDENT DEDENT return str ( triangle [ 0 ] [ 0 ] ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["def compute ( ) : NEW_LINE INDENT for i in reversed ( range ( len ( triangle ) - 1 ) ) : NEW_LINE INDENT for j in range ( len ( triangle [ i ] ) ) : NEW_LINE INDENT triangle [ i ] [ j ] += max ( triangle [ i + 1 ] [ j ] , triangle [ i + 1 ] [ j + 1 ] ) NEW_LINE DEDENT DEDENT return str ( triangle [ 0 ] [ 0 ] ) NEW_LINE DEDENT triangle = [ [ 75 ] , [ 95 , 64 ] , [ 17 , 47 , 82 ] , [ 18 , 35 , 87 , 10 ] , [ 20 , 4 , 82 , 47 , 65 ] , [ 19 , 1 , 23 , 75 , 3 , 34 ] , [ 88 , 2 , 77 , 73 , 7 , 63 , 67 ] , [ 99 , 65 , 4 , 28 , 6 , 16 , 70 , 92 ] , [ 41 , 41 , 26 , 56 , 83 , 40 , 80 , 70 , 33 ] , [ 41 , 48 , 72 , 33 , 47 , 32 , 37 , 16 , 94 , 29 ] , [ 53 , 71 , 44 , 65 , 25 , 43 , 91 , 52 , 97 , 51 , 14 ] , [ 70 , 11 , 33 , 28 , 77 , 73 , 17 , 78 , 39 , 68 , 17 , 57 ] , [ 91 , 71 , 52 , 38 , 17 , 14 , 91 , 43 , 58 , 50 , 27 , 29 , 48 ] , [ 63 , 66 , 4 , 68 , 89 , 53 , 67 , 30 , 73 , 16 , 69 , 87 , 40 , 31 ] , [ 4 , 62 , 98 , 27 , 23 , 9 , 70 , 98 , 73 , 93 , 38 , 53 , 60 , 4 , 23 ] , ] NEW_LINE if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.08732843921824064,"rouge_l":0.37376561570493755}
{"id":1667,"predictions":["import math NEW_LINE def compute ( ) : NEW_LINE INDENT return eomial ( 40 , 20 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT return str ( eulerlib . binomial ( 40 , 20 ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.7674334988379864,"rouge_l":0.8847328244274809}
{"id":1668,"predictions":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 50000000 NEW_LINE primes = eulerlib . list_primes ( eulerlib . sqrt ( LIMIT ) ) + 1 NEW_LINE def f_primes ( n ) : NEW_LINE INDENT LIMIT = 50000000 NEW_LINE primes = eulerlib . sqrt ( n ) NEW_LINE for i in range ( 2 , 4 ) : NEW_LINE INDENT q = 1 NEW_LINE for p in primes : NEW_LINE INDENT q *= p NEW_LINE DEDENT if ( q + r <= LIMIT ) : NEW_LINE INDENT break NEW_LINE DEDENT r = q NEW_LINE for x in sorted ( sums ) : NEW_LINE INDENT if ( x + r <= LIMIT ) : NEW_LINE INDENT newsums . add ( x + r ) NEW_LINE DEDENT DEDENT DEDENT return str ( len ( sums ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 50000000 NEW_LINE primes = eulerlib . list_primes ( eulerlib . sqrt ( LIMIT ) ) NEW_LINE sums = { 0 } NEW_LINE for i in range ( 2 , 5 ) : NEW_LINE INDENT newsums = set ( ) NEW_LINE for p in primes : NEW_LINE INDENT q = p ** i NEW_LINE if q > LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT for x in sums : NEW_LINE INDENT if x + q <= LIMIT : NEW_LINE INDENT newsums . add ( x + q ) NEW_LINE DEDENT DEDENT DEDENT sums = newsums NEW_LINE DEDENT return str ( len ( sums ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.6130765423429815,"rouge_l":0.8039650016613135}
{"id":1669,"predictions":["import math NEW_LINE def compute ( ) : NEW_LINE INDENT modulus = 10 ** 9 + 7 NEW_LINE ans = sum ( i ** 2 for i in range ( 1 , 100 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["def compute ( ) : NEW_LINE INDENT MOD = 10 ** 10 NEW_LINE ans = sum ( pow ( i , i , MOD ) for i in range ( 1 , 1001 ) ) % MOD NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.690596465118344,"rouge_l":0.8284708249496981}
{"id":1670,"predictions":["def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 6 NEW_LINE totients = eulerlib . list_totients ( LIMIT ) NEW_LINE totients = 0 NEW_LINE def list_totients ( LIMIT ) : NEW_LINE INDENT totients = 0 NEW_LINE maxnumer = 1 NEW_LINE totients = eulerlib . list_totients [ len ( tot ) ] NEW_LINE return str ( maxnumer ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import eulerlib , fractions NEW_LINE def compute ( ) : NEW_LINE INDENT totients = eulerlib . list_totients ( 10 ** 6 ) NEW_LINE ans = max ( range ( 2 , len ( totients ) ) , key = ( lambda i : fractions . Fraction ( i , totients [ i ] ) ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.5015260050673179,"rouge_l":0.5968688845401174}
{"id":1671,"predictions":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT isprime = eulerlib . list_primality ( 10 ** 8 ) NEW_LINE def primes ( n ) : NEW_LINE INDENT isprime = eulerlib . list_primality ( 10 ** 8 ) NEW_LINE return primes NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT def s ( p ) : NEW_LINE INDENT return ( p - 3 ) * eulerlib . reciprocal_mod ( 8 % p , p ) % p NEW_LINE DEDENT ans = sum ( s ( p ) for p in eulerlib . prime_generator ( 10 ** 8 ) if p >= 5 ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.4168046201030222,"rouge_l":0.6177840794004456}
{"id":1672,"predictions":["import itertools NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 6 NEW_LINE def find_least_divisible_repunit ( n ) : NEW_LINE INDENT if n % 2 == 0 or n % 5 == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n % 2 == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT sum = 1 NEW_LINE pow = 10 NEW_LINE k = 1 NEW_LINE while sum % n != 0 : NEW_LINE INDENT k += 1 NEW_LINE pow = pow * 10 NEW_LINE sum = ( sum + pow ) % n NEW_LINE DEDENT return k NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import itertools NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 6 NEW_LINE for n in itertools . count ( LIMIT ) : NEW_LINE INDENT if least_divisible_repunit ( n ) > LIMIT : NEW_LINE INDENT return str ( n ) NEW_LINE DEDENT DEDENT DEDENT def least_divisible_repunit ( n ) : NEW_LINE INDENT if n % 2 == 0 or n % 5 == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT k = 1 NEW_LINE s = 1 NEW_LINE p = 1 NEW_LINE while s % n != 0 : NEW_LINE INDENT k += 1 NEW_LINE p = p * 10 % n NEW_LINE s = ( s + p ) % n NEW_LINE DEDENT return k NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.6137222914024675,"rouge_l":0.7344035023713973}
{"id":1673,"predictions":["def compute ( ) : NEW_LINE INDENT ans = sum ( i for i in range ( 1 , 10000 ) if ( has_sort ( i ) == \"123456789\" ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def has_sortigital_sum ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( n % i == 0 and is_indigigital_sum ( \" \" + str ( n + i + 1 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT ans = sum ( i for i in range ( 1 , 10000 ) if has_pandigital_product ( i ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def has_pandigital_product ( n ) : NEW_LINE INDENT for i in range ( 1 , eulerlib . sqrt ( n ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT temp = str ( n ) + str ( i ) + str ( n \/\/ i ) NEW_LINE if \" \" . join ( sorted ( temp ) ) == \"123456789\" : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.6351270913973783,"rouge_l":0.7836272040302267}
{"id":1674,"predictions":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10000000 NEW_LINE possible = eulerlib . list_primes ( LIMIT \/\/ 2 ) NEW_LINE i = 0 NEW_LINE while i < len ( primes ) : NEW_LINE INDENT p = primes [ i ] NEW_LINE if p > end : NEW_LINE INDENT break NEW_LINE DEDENT for j in range ( i + 1 , len ( primes ) ) : NEW_LINE INDENT q = primes [ j ] NEW_LINE lcm = p * q NEW_LINE if lcm > LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT if lcm > LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT for j in range ( i + 1 , len ( primes ) ) : NEW_LINE INDENT q = primes [ j ] NEW_LINE lcm = p * q NEW_LINE if lcm > LIMIT : NEW_LINE INDENT break NEW_LINE DED *= LIMIT \/\/ lcm NEW_LINE factors = 1 NEW_LINE while factors % p == 0 : NEW_LINE INDENT factors *= p NEW_LINE while factors *= q <= p : NEW_LINE INDENT factors *= p NEW_LINE DEDENT maxfactor *= p NEW_LINE DEDENT possible . add ( maxfactor , maxfactor ) NEW_LINE DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10000000 NEW_LINE possible = set ( ) NEW_LINE primes = eulerlib . list_primes ( LIMIT \/\/ 2 ) NEW_LINE end = eulerlib . sqrt ( LIMIT ) NEW_LINE for i in range ( len ( primes ) ) : NEW_LINE INDENT p = primes [ i ] NEW_LINE if p > end : NEW_LINE INDENT break NEW_LINE DEDENT for j in range ( i + 1 , len ( primes ) ) : NEW_LINE INDENT q = primes [ j ] NEW_LINE lcm = p * q NEW_LINE if lcm > LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT multlimit = LIMIT \/\/ lcm NEW_LINE multiplier = 1 NEW_LINE while multiplier * p <= multlimit : NEW_LINE INDENT multiplier *= p NEW_LINE DEDENT maxmult = multiplier NEW_LINE while multiplier % p == 0 : NEW_LINE INDENT multiplier \/\/= p NEW_LINE while multiplier * q <= multlimit : NEW_LINE INDENT multiplier *= q NEW_LINE DEDENT maxmult = max ( multiplier , maxmult ) NEW_LINE DEDENT possible . add ( maxmult * lcm ) NEW_LINE DEDENT DEDENT ans = sum ( possible ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.64429647582905,"rouge_l":0.7218139056298691}
{"id":1675,"predictions":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT primes = eulerlib . list_primes ( 2000000 ) NEW_LINE for i in range ( 2 , 1000000 ) : NEW_LINE INDENT p = primes [ i ] NEW_LINE q = primes [ i + 1 ] = primes [ i + 1 ] NEW_LINE k = 1 NEW_LINE while ( k < p ) : NEW_LINE INDENT k *= 10 NEW_LINE DEDENT k = 1 NEW_LINE while ( k < p ) : NEW_LINE INDENT k *= 10 NEW_LINE DEDENT m = ( q - p ) * eulerlib . sqrt ( k % q , q ) % q NEW_LINE ans += m * k + p NEW_LINE DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT ans = 0 NEW_LINE primes = eulerlib . list_primes ( 2000000 ) NEW_LINE for i in itertools . count ( 2 ) : NEW_LINE INDENT p = primes [ i ] NEW_LINE q = primes [ i + 1 ] NEW_LINE if p > 1000000 : NEW_LINE INDENT break NEW_LINE DEDENT k = 1 NEW_LINE while k < p : NEW_LINE INDENT k *= 10 NEW_LINE DEDENT m = ( q - p ) * eulerlib . reciprocal_mod ( k % q , q ) % q NEW_LINE ans += m * k + p NEW_LINE DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.7394907861814658,"rouge_l":0.8692075996292863}
{"id":1676,"predictions":["class Solution ( object ) : NEW_LINE INDENT def popFill ( self , item , sr , new_data ) : NEW_LINE INDENT self . l = [ sr ] [ sr ] NEW_LINE r = s [ l ] [ sr ] NEW_LINE if ( color == new_word ) : NEW_LINE INDENT return operator NEW_LINE DEDENT queue . append ( ( Node ( sr , sa ) ) NEW_LINE while ( len ( queue ) > 0 ) : NEW_LINE INDENT curr = queue [ r ] [ sc ] NEW_LINE r = curr . pop ( ) NEW_LINE if ( r - 1 >= 0 ) : NEW_LINE INDENT queue . append ( Node ( r - 1 , c ) ) NEW_LINE DEDENT if ( r + 1 < len ( image ) ) : NEW_LINE INDENT queue . append ( Node ( r + 1 , c ) ) NEW_LINE DEDENT if ( c - 1 >= 0 ) : NEW_LINE INDENT queue . append ( Node ( r + 1 , c ) ) NEW_LINE DEDENT if ( c + 1 < len ( image [ 0 ] ) ) : NEW_LINE INDENT queue . append ( Node ( r , c + 1 ) ) NEW_LINE DEDENT if ( c + 1 < 0 ) : NEW_LINE INDENT queue . append ( Node ( r , c - 1 ) ) NEW_LINE DEDENT DEDENT return queue NEW_LINE DEDENT DEDENT"],"references":["class Solution ( object ) : NEW_LINE INDENT def floodFill ( self , image , sr , sc , newColor ) : NEW_LINE INDENT r_ls , c_ls = len ( image ) , len ( image [ 0 ] ) NEW_LINE color = image [ sr ] [ sc ] NEW_LINE if color == newColor : NEW_LINE INDENT return image NEW_LINE DEDENT queue = [ ( sr , sc ) ] NEW_LINE while len ( queue ) > 0 : NEW_LINE INDENT r , c = queue . pop ( 0 ) NEW_LINE if image [ r ] [ c ] == color : NEW_LINE INDENT image [ r ] [ c ] = newColor NEW_LINE if r - 1 >= 0 : queue . append ( ( r - 1 , c ) ) NEW_LINE if r + 1 < r_ls : queue . append ( ( r + 1 , c ) ) NEW_LINE if c - 1 >= 0 : queue . append ( ( r , c - 1 ) ) NEW_LINE if c + 1 < c_ls : queue . append ( ( r , c + 1 ) ) NEW_LINE DEDENT DEDENT return image NEW_LINE DEDENT DEDENT"],"bleu":0.4315505464311633,"rouge_l":0.6687798329355608}
{"id":1677,"predictions":["class Solution ( object ) : NEW_LINE INDENT def thirdMax ( self , nums , nums ) : NEW_LINE INDENT pq = [ ] NEW_LINE for i in nums : NEW_LINE INDENT if i in nums : NEW_LINE INDENT continue NEW_LINE DEDENT pq . append ( i ) NEW_LINE if len ( pq ) > 2 : NEW_LINE INDENT continue NEW_LINE DEDENT pq . pop ( ) NEW_LINE if len ( pq ) > 3 : NEW_LINE INDENT pq . pop ( ) NEW_LINE DEDENT while pq [ - 1 ] > 3 : NEW_LINE INDENT pq . pop ( ) NEW_LINE DEDENT return pq [ - 1 ] NEW_LINE DEDENT DEDENT DEDENT"],"references":["class Solution ( object ) : NEW_LINE INDENT def thirdMax ( self , nums ) : NEW_LINE INDENT import Queue NEW_LINE pq = Queue . PriorityQueue ( 4 ) NEW_LINE check = set ( ) NEW_LINE for n in nums : NEW_LINE INDENT if n in check : NEW_LINE INDENT continue NEW_LINE DEDENT pq . put ( n ) NEW_LINE check . add ( n ) NEW_LINE if len ( check ) > 3 : NEW_LINE INDENT check . remove ( pq . get ( ) ) NEW_LINE DEDENT DEDENT total = len ( check ) NEW_LINE while total < 3 and total > 1 : NEW_LINE INDENT total -= 1 NEW_LINE DEDENT return pq . get ( ) NEW_LINE DEDENT DEDENT"],"bleu":0.41207794428217814,"rouge_l":0.6001108493834002}
{"id":1678,"predictions":["class Solution ( object ) : NEW_LINE INDENT def CoinKeySearch ( self , s , k ) : NEW_LINE INDENT bits = [ ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] != ' - ' ) : NEW_LINE INDENT bits . append ( s [ i ] . ' - ' ) NEW_LINE DEDENT DEDENT return bits NEW_LINE DEDENT DEDENT"],"references":["class Solution ( object ) : NEW_LINE INDENT def licenseKeyFormatting ( self , S , K ) : NEW_LINE INDENT S = S . upper ( ) . replace ( ' - ' , ' ' ) NEW_LINE ls = len ( S ) NEW_LINE if ls % K == 0 : NEW_LINE INDENT pos = K NEW_LINE DEDENT else : NEW_LINE INDENT pos = ls % K NEW_LINE DEDENT res = S [ : pos ] NEW_LINE while pos < ls : NEW_LINE INDENT res += ' - ' + S [ pos : pos + K ] NEW_LINE pos += K NEW_LINE DEDENT return res NEW_LINE DEDENT DEDENT"],"bleu":0.17919496025148735,"rouge_l":0.4112359550561799}
{"id":1679,"predictions":["class Node : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . l = [ ] NEW_LINE self . l . append ( self . t ) NEW_LINE DEDENT DEDENT"],"references":["class RecentCounter ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . queue = [ ] NEW_LINE DEDENT def ping ( self , t ) : NEW_LINE INDENT self . queue . append ( t ) NEW_LINE while self . queue and self . queue [ 0 ] < t - 3000 : NEW_LINE INDENT self . queue . pop ( 0 ) NEW_LINE DEDENT return len ( self . queue ) NEW_LINE DEDENT DEDENT"],"bleu":0.1503739012582936,"rouge_l":0.4891740176423417}
{"id":1680,"predictions":["class Solution ( object ) : NEW_LINE INDENT def uniqueMaphations ( self , words ) : NEW_LINE INDENT s = [ \" . \" , \" - \" , \" . \" , \" . \" , \" . \" , \" - \" , \" . \" , \" - \" ] NEW_LINE seen = set ( ) NEW_LINE for word in words : NEW_LINE INDENT word . append ( word ) NEW_LINE DEDENT return len ( s ) == 1 NEW_LINE DEDENT DEDENT"],"references":["Morse_tab = [ \" . - \" , \" - . . . \" , \" - . - . \" , \" - . . \" , \" . \" , \" . . - . \" , \" - - . \" , \" . . . . \" , \" . . \" , \" . - - - \" , \" - . - \" , \" . - . . \" , \" - - \" , \" - . \" , \" - - - \" , \" . - - . \" , \" - - . - \" , \" . - . \" , \" . . . \" , \" - \" , \" . . - \" , \" . . . - \" , \" . - - \" , \" - . . - \" , \" - . - - \" , \" - - . . \" ] NEW_LINE class Solution ( object ) : NEW_LINE INDENT def uniqueMorseRepresentations ( self , words ) : NEW_LINE INDENT if len ( words ) == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans_set = set ( ) NEW_LINE for word in words : NEW_LINE INDENT morsed = \" \" NEW_LINE for c in word : NEW_LINE INDENT morsed += Morse_tab [ ord ( c ) - ord ( ' a ' ) ] NEW_LINE DEDENT ans_set . add ( morsed ) NEW_LINE DEDENT return len ( ans_set ) NEW_LINE DEDENT DEDENT"],"bleu":0.09597744381824871,"rouge_l":0.32375055285272}
{"id":1681,"predictions":["class Solution ("],"references":["class Solution : NEW_LINE INDENT def runningSum ( self , nums : List [ int ] ) -> List [ int ] : NEW_LINE INDENT if nums is None or len ( nums ) == 0 : NEW_LINE INDENT return nums NEW_LINE DEDENT for i in range ( 1 , len ( nums ) ) : NEW_LINE INDENT nums [ i ] += nums [ i - 1 ] NEW_LINE DEDENT return nums NEW_LINE DEDENT DEDENT"],"bleu":2.0553571273216266e-11,"rouge_l":0.06510138740661686}
{"id":1682,"predictions":["class ListNode : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . Node ( key ) = key NEW_LINE self . value = value NEW_LINE DEDENT DEDENT class Node : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . nodes = [ - 1 ] * ( key ) NEW_LINE if self . nodes [ i ] == None : NEW_LINE INDENT self . Node [ i ] = self . Node ( - 1 , value ) NEW_LINE DEDENT def get ( self , key ) : NEW_LINE INDENT self . nodes [ i ] = self . Node ( key ) NEW_LINE if self . nodes [ i ] is None : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT self . Node [ i ] = value NEW_LINE self . nodes [ i ] = value NEW_LINE DEDENT DEDENT def remove ( self , key ) : NEW_LINE INDENT i = idx ( self . nodes [ i ] , key ) NEW_LINE if self . nodes [ i ] == None : NEW_LINE INDENT return - 1 NEW_LINE DEDENT prev = self . nodes [ i ] NEW_LINE if prev . next is None : NEW_LINE INDENT return NEW_LINE DEDENT prev . next = prev . next . next NEW_LINE DEDENT DEDENT def remove ( self , key ) : NEW_LINE INDENT i = idx ( key ) NEW_LINE if prev . next is None : NEW_LINE INDENT return NEW_LINE DEDENT prev . next = prev NEW_LINE while i != None and prev . next is not None : NEW_LINE INDENT prev = Node ( key ) NEW_LINE prev = node . next NEW_LINE i = i . next NEW_LINE DEDENT return prev NEW_LINE DEDENT DEDENT"],"references":["class MyHashMap ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . size = 10000 NEW_LINE self . nodes = [ None ] * self . size NEW_LINE DEDENT def put ( self , key , value ) : NEW_LINE INDENT index = hash ( key ) % self . size NEW_LINE if self . nodes [ index ] is None : NEW_LINE INDENT self . nodes [ index ] = ListNode ( - 1 , - 1 ) NEW_LINE DEDENT prev = find ( self . nodes [ index ] , key ) NEW_LINE if prev . next is None : NEW_LINE INDENT prev . next = ListNode ( key , value ) NEW_LINE DEDENT else : NEW_LINE INDENT prev . next . val = value NEW_LINE DEDENT DEDENT def get ( self , key ) : NEW_LINE INDENT index = hash ( key ) % self . size NEW_LINE if self . nodes [ index ] is None : NEW_LINE INDENT return - 1 NEW_LINE DEDENT prev = find ( self . nodes [ index ] , key ) NEW_LINE if prev . next is None : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return prev . next . val NEW_LINE DEDENT DEDENT def remove ( self , key ) : NEW_LINE INDENT index = hash ( key ) % self . size NEW_LINE if self . nodes [ index ] is None : NEW_LINE INDENT return NEW_LINE DEDENT prev = find ( self . nodes [ index ] , key ) NEW_LINE if prev . next is None : NEW_LINE INDENT return NEW_LINE DEDENT prev . next = prev . next . next NEW_LINE DEDENT DEDENT def find ( bucket , key ) : NEW_LINE INDENT node = bucket NEW_LINE prev = None NEW_LINE while node is not None and node . key != key : NEW_LINE INDENT prev = node NEW_LINE node = node . next NEW_LINE DEDENT return prev NEW_LINE DEDENT class ListNode ( ) : NEW_LINE INDENT def __init__ ( self , key , val ) : NEW_LINE INDENT self . key = key NEW_LINE self . val = val NEW_LINE self . next = None NEW_LINE NEW_LINE DEDENT DEDENT"],"bleu":0.5109199202120748,"rouge_l":0.5750082895173132}
{"id":1683,"predictions":["class Node : NEW_LINE INDENT def __init__ ( self , x ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = x NEW_LINE self . right = None NEW_LINE DEDENT DEDENT class Node : NEW_LINE INDENT def __init__ ( self , x ) : NEW_LINE INDENT self . head = self . head NEW_LINE DEDENT def push ( self , x ) : NEW_LINE INDENT while x : NEW_LINE INDENT self . stack . pop ( ) NEW_LINE self . stack . pop ( 0 ) NEW_LINE DEDENT DEDENT def push ( self , stack ) : NEW_LINE INDENT def push ( self , stack ) : NEW_LINE INDENT self . stack = Node ( ) NEW_LINE self . stack . pop ( ) NEW_LINE if len ( self . stack ) == 0 : NEW_LINE INDENT self . stack . pop ( 0 ) NEW_LINE DEDENT return self . stack . pop ( ) NEW_LINE DEDENT DEDENT def push ( self , val ) : NEW_LINE INDENT self . stack . pop ( 0 ) NEW_LINE self . stack . pop ( 0 ) NEW_LINE self . stack . pop ( ) NEW_LINE if len ( L ) == 0 : NEW_LINE INDENT del self . stack . pop ( 0 ) NEW_LINE DEDENT return self . stack . pop ( 0 ) NEW_LINE DEDENT DEDENT"],"references":["class MaxStack ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . stack = [ ] NEW_LINE self . max_stack = [ ] NEW_LINE DEDENT def push ( self , x ) : NEW_LINE INDENT self . stack . append ( x ) NEW_LINE if len ( self . max_stack ) == 0 : NEW_LINE INDENT self . max_stack . append ( x ) NEW_LINE return NEW_LINE DEDENT if self . max_stack [ - 1 ] > x : NEW_LINE INDENT self . max_stack . append ( self . max_stack [ - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT self . max_stack . append ( x ) NEW_LINE DEDENT DEDENT def pop ( self ) : NEW_LINE INDENT if len ( self . stack ) != 0 : NEW_LINE INDENT self . max_stack . pop ( - 1 ) NEW_LINE return self . stack . pop ( - 1 ) NEW_LINE DEDENT DEDENT def top ( self ) : NEW_LINE INDENT return self . stack [ - 1 ] NEW_LINE DEDENT def peekMax ( self ) : NEW_LINE INDENT if len ( self . max_stack ) != 0 : NEW_LINE INDENT return self . max_stack [ - 1 ] NEW_LINE DEDENT DEDENT def popMax ( self ) : NEW_LINE INDENT val = self . peekMax ( ) NEW_LINE buff = [ ] NEW_LINE while self . top ( ) != val : NEW_LINE INDENT buff . append ( self . pop ( ) ) NEW_LINE DEDENT self . pop ( ) NEW_LINE while len ( buff ) != 0 : NEW_LINE INDENT self . push ( buff . pop ( - 1 ) ) NEW_LINE DEDENT return val NEW_LINE DEDENT DEDENT"],"bleu":0.3621699652462495,"rouge_l":0.5542369738549973}
{"id":1684,"predictions":["class Solution ( object ) : NEW_LINE INDENT def canReorder ( self , A ) : NEW_LINE INDENT value_map = { } NEW_LINE for n in A : NEW_LINE INDENT value_map [ n ] = value_map . get ( abs ( abs ( x ) , abs ( abs ( x ) ) ) NEW_LINE DEDENT for n in A : NEW_LINE INDENT if value_map [ n ] <= 0 : NEW_LINE INDENT continue NEW_LINE DEDENT if 2 * n in value_map : NEW_LINE INDENT continue NEW_LINE DEDENT value_map [ 2 * n ] -= 1 NEW_LINE value_map [ 2 * n ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT"],"references":["class Solution ( object ) : NEW_LINE INDENT def canReorderDoubled ( self , A ) : NEW_LINE INDENT v_map = { } NEW_LINE A . sort ( key = lambda x : abs ( x ) ) NEW_LINE for n in A : NEW_LINE INDENT v_map [ n ] = v_map . get ( n , 0 ) + 1 NEW_LINE DEDENT for n in A : NEW_LINE INDENT if v_map [ n ] <= 0 : NEW_LINE INDENT continue NEW_LINE DEDENT if 2 * n in v_map and v_map [ 2 * n ] > 0 : NEW_LINE INDENT v_map [ n ] -= 1 NEW_LINE v_map [ 2 * n ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = Solution ( ) NEW_LINE print s . canReorderDoubled ( [ 3 , 1 , 3 , 6 ] ) NEW_LINE print s . canReorderDoubled ( [ 2 , 1 , 2 , 6 ] ) NEW_LINE print s . canReorderDoubled ( [ 4 , - 2 , 2 , - 4 ] ) NEW_LINE print s . canReorderDoubled ( [ 1 , 2 , 4 , 16 , 8 , 4 ] ) NEW_LINE DEDENT"],"bleu":0.2840565438755546,"rouge_l":0.5101553166069295}
{"id":1685,"predictions":["class Solution ( object ) : NEW_LINE INDENT def repeatedNTimes ( self , A ) : NEW_LINE INDENT Hash = { } NEW_LINE ans = A [ 0 ] NEW_LINE for n in A : NEW_LINE INDENT count = Hash . get ( n , 0 ) + 1 NEW_LINE if count >= hash [ ans ] : NEW_LINE INDENT ans = n NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT"],"references":["import collections NEW_LINE class Solution ( object ) : NEW_LINE INDENT def repeatedNTimes ( self , A ) : NEW_LINE INDENT counter = collections . Counter ( A ) NEW_LINE return counter . most_common ( 1 ) [ 0 ] [ 0 ] NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = Solution ( ) NEW_LINE print s . repeatedNTimes ( [ 1 , 2 , 3 , 3 ] ) NEW_LINE print s . repeatedNTimes ( [ 2 , 1 , 2 , 5 , 3 , 2 ] ) NEW_LINE print s . repeatedNTimes ( [ 5 , 1 , 5 , 2 , 5 , 3 , 5 , 4 ] ) NEW_LINE DEDENT"],"bleu":0.16802544669572192,"rouge_l":0.3672951988591348}
{"id":1686,"predictions":["class Solution ( object ) : NEW_LINE INDENT def smallerNumbersThanCurrent ( self , nums ) : NEW_LINE INDENT countlist = [ 0 ] * len ( nums ) NEW_LINE res = [ 0 ] * len ( nums ) NEW_LINE for i in range ( len ( nums ) ) : NEW_LINE INDENT countlist [ nums [ i ] ] += 1 NEW_LINE DEDENT for i in range ( len ( nums ) ) : NEW_LINE INDENT if nums [ i ] == 0 : NEW_LINE INDENT res [ 0 ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT res [ i ] = countlist [ nums [ i - 1 ] - 1 ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT DEDENT"],"references":["class Solution : NEW_LINE INDENT def smallerNumbersThanCurrent ( self , nums : List [ int ] ) -> List [ int ] : NEW_LINE INDENT count_list = [ 0 ] * 101 NEW_LINE for v in nums : NEW_LINE INDENT count_list [ v ] += 1 NEW_LINE DEDENT for i in range ( 1 , 101 ) : NEW_LINE INDENT count_list [ i ] += count_list [ i - 1 ] NEW_LINE DEDENT res = [ ] NEW_LINE for v in nums : NEW_LINE INDENT if v == 0 : NEW_LINE INDENT res . append ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT res . append ( count_list [ v - 1 ] ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT DEDENT"],"bleu":0.4503584217891227,"rouge_l":0.6016260162601627}
{"id":1687,"predictions":["class Solution ( object ) : NEW_LINE INDENT def isAreaSorted ( self , words , order , order ) : NEW_LINE INDENT for word in words : NEW_LINE INDENT if word in _map : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT DEDENT"],"references":["class Solution ( object ) : NEW_LINE INDENT def isAlienSorted ( self , words , order ) : NEW_LINE INDENT order_map = { } NEW_LINE for i , v in enumerate ( order ) : NEW_LINE INDENT order_map [ v ] = i NEW_LINE DEDENT def cmp_alien ( x , y ) : NEW_LINE INDENT ls = min ( len ( x ) , len ( y ) ) NEW_LINE index = 0 NEW_LINE while index < ls : NEW_LINE INDENT if x [ index ] != y [ index ] : NEW_LINE INDENT return order_map [ x [ index ] ] - order_map [ y [ index ] ] NEW_LINE DEDENT index += 1 NEW_LINE DEDENT return len ( x ) - len ( y ) NEW_LINE DEDENT pos = 0 NEW_LINE while pos + 1 < len ( words ) : NEW_LINE INDENT if cmp_alien ( words [ pos ] , words [ pos + 1 ] ) > 0 : NEW_LINE INDENT return False NEW_LINE DEDENT pos += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = Solution ( ) NEW_LINE print s . isAlienSorted ( [ \" hello \" , \" leetcode \" ] , \" hlabcdefgijkmnopqrstuvwxyz \" ) NEW_LINE print s . isAlienSorted ( [ \" word \" , \" world \" , \" row \" ] , \" worldabcefghijkmnpqstuvxyz \" ) NEW_LINE print s . isAlienSorted ( [ \" apple \" , \" app \" ] , \" abcdefghijklmnopqrstuvwxyz \" ) NEW_LINE DEDENT"],"bleu":0.006078169482585688,"rouge_l":0.21779573428544585}
{"id":1688,"predictions":["class Solution ( object ) : NEW_LINE INDENT def find DisappbleNumbers ( self , nums ) : NEW_LINE INDENT ret = [ ] NEW_LINE for i in range ( len ( nums ) ) : NEW_LINE INDENT val = abs ( nums [ i ] ) - 1 NEW_LINE if ( abs ( nums [ val ] ) > 0 ) : NEW_LINE INDENT nums [ val ] = - nums [ val ] NEW_LINE DEDENT DEDENT for i in range ( len ( nums ) ) : NEW_LINE INDENT if ( nums [ i ] > 0 ) : NEW_LINE INDENT ret . append ( i + 1 ) NEW_LINE DEDENT DEDENT return ret NEW_LINE DEDENT DEDENT"],"references":["class Solution ( object ) : NEW_LINE INDENT def findDisappearedNumbers ( self , nums ) : NEW_LINE INDENT res = [ ] NEW_LINE if nums : NEW_LINE INDENT n = len ( nums ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT val = abs ( nums [ i ] ) - 1 NEW_LINE if nums [ val ] > 0 : NEW_LINE INDENT nums [ val ] = - nums [ val ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if nums [ i ] > 0 : NEW_LINE INDENT res . append ( i + 1 ) NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT DEDENT"],"bleu":0.6935888097880227,"rouge_l":0.8346830494275342}
{"id":1689,"predictions":["class Solution ( object ) : NEW_LINE INDENT def toHexion ( self , num : int ) -> str : NEW_LINE INDENT hex_map = \"0123456789\" NEW_LINE if num == 0 : NEW_LINE INDENT return '0' . join ( str ( str ( num ) ) ) NEW_LINE DEDENT ans = \" \" . join ( ans ) NEW_LINE while len ( ans ) < 8 : NEW_LINE INDENT ans = hex_map [ int ( ans & 15 ) ] NEW_LINE num = num >> 4 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT"],"references":["class Solution ( object ) : NEW_LINE INDENT def toHex ( self , num ) : NEW_LINE INDENT if num == 0 : NEW_LINE INDENT return '0' NEW_LINE DEDENT mp = '0123456789abcdef ' NEW_LINE ans = ' ' NEW_LINE for _ in range ( 8 ) : NEW_LINE INDENT n = num & 15 NEW_LINE c = mp [ n ] NEW_LINE ans = c + ans NEW_LINE num = num >> 4 NEW_LINE DEDENT return ans . lstrip ( '0' ) NEW_LINE DEDENT DEDENT"],"bleu":0.3932581765280625,"rouge_l":0.6031716417910449}
{"id":1690,"predictions":["class Solution"],"references":["class Solution ( object ) : NEW_LINE INDENT def kWeakestRows ( self , mat , k ) : NEW_LINE INDENT res = [ ] NEW_LINE num_row = len ( mat ) NEW_LINE num_col = len ( mat [ 0 ] ) NEW_LINE col = 0 NEW_LINE flag = 1 NEW_LINE while col < num_col and flag : NEW_LINE INDENT for i in range ( num_row ) : NEW_LINE INDENT if i in res : NEW_LINE INDENT continue NEW_LINE DEDENT if mat [ i ] [ col ] == 0 : NEW_LINE INDENT res . append ( i ) NEW_LINE DEDENT if len ( res ) == k : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT DEDENT col += 1 NEW_LINE DEDENT if len ( res ) == k : NEW_LINE INDENT return res NEW_LINE DEDENT for i in range ( num_row ) : NEW_LINE INDENT if i in res : NEW_LINE INDENT continue NEW_LINE DEDENT res . append ( i ) NEW_LINE if len ( res ) == k : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT DEDENT"],"bleu":4.9699198825226136e-40,"rouge_l":0.018379029828261523}
{"id":1691,"predictions":["class Solution ( object ) : NEW_LINE INDENT def flipAndInvertImage ( self , A ) : NEW_LINE INDENT C = len ( A ) NEW_LINE N = len ( A ) NEW_LINE row = [ 0 ] * len ( A ) NEW_LINE for i in range ( int ( C + 1 ) \/ 2 ) : NEW_LINE INDENT row [ i ] = row [ C - 1 ] ^ 1 NEW_LINE row [ C - 1 - i ] = row [ C - 1 - i ] ^ 1 NEW_LINE DEDENT return A NEW_LINE DEDENT DEDENT"],"references":["class Solution ( object ) : NEW_LINE INDENT def flipAndInvertImage ( self , A ) : NEW_LINE INDENT for row in A : NEW_LINE INDENT for i in xrange ( ( len ( row ) + 1 ) \/ 2 ) : NEW_LINE INDENT row [ i ] , row [ ~ i ] = row [ ~ i ] ^ 1 , row [ i ] ^ 1 NEW_LINE DEDENT DEDENT return A NEW_LINE DEDENT DEDENT"],"bleu":0.4677874436873262,"rouge_l":0.6826631259484068}
{"id":1692,"predictions":["class Solution ( object ) : NEW_LINE INDENT def sortedSquares ( self , A ) : NEW_LINE INDENT pos = 0 NEW_LINE while pos < len ( A ) and A [ pos ] < 0 : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT npos = pos - 1 NEW_LINE while pos < len ( A ) and npos >= 0 : NEW_LINE INDENT if A [ pos ] * A [ pos ] < A [ pos ] : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT else : NEW_LINE INDENT curr += 1 NEW_LINE curr -= 1 NEW_LINE pos += 1 NEW_LINE DEDENT DEDENT while pos < len ( A ) and npos >= 0 : NEW_LINE INDENT res = [ 0 ] * A [ pos ] NEW_LINE npos -= 1 NEW_LINE DEDENT while pos < len ( A ) : NEW_LINE INDENT res [ curr ] = A [ pos ] * A [ pos ] NEW_LINE pos += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT DEDENT"],"references":["class Solution ( object ) : NEW_LINE INDENT def sortedSquares ( self , A ) : NEW_LINE INDENT pos = 0 NEW_LINE while pos < len ( A ) and A [ pos ] < 0 : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT npos = pos - 1 NEW_LINE res = [ ] NEW_LINE while pos < len ( A ) and npos >= 0 : NEW_LINE INDENT if A [ npos ] ** 2 < A [ pos ] ** 2 : NEW_LINE INDENT res . append ( A [ npos ] ** 2 ) NEW_LINE npos -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT res . append ( A [ pos ] ** 2 ) NEW_LINE pos += 1 NEW_LINE DEDENT DEDENT while npos >= 0 : NEW_LINE INDENT res . append ( A [ npos ] ** 2 ) NEW_LINE npos -= 1 NEW_LINE DEDENT while pos < len ( A ) : NEW_LINE INDENT res . append ( A [ pos ] ** 2 ) NEW_LINE pos += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT DEDENT"],"bleu":0.6791193323458208,"rouge_l":0.7535760728218466}
{"id":1693,"predictions":["class Solution : NEW_LINE"],"references":["class Solution : NEW_LINE INDENT def defangIPaddr ( self , address : str ) -> str : NEW_LINE INDENT return address . replace ( ' . ' , ' [ . ] ' ) NEW_LINE DEDENT DEDENT"],"bleu":0.00026125855730166754,"rouge_l":0.17039106145251398}
{"id":1694,"predictions":["class Solution ( object ) : NEW_LINE INDENT def searchBST ( self , root , val , val ) : NEW_LINE INDENT while val and val is not None : NEW_LINE INDENT val = val . left NEW_LINE val = val . right NEW_LINE DEDENT return root NEW_LINE DEDENT DEDENT"],"references":["class Solution ( object ) : NEW_LINE INDENT def searchBST ( self , root , val ) : NEW_LINE INDENT while root : NEW_LINE INDENT if root . val == val : NEW_LINE INDENT return root NEW_LINE DEDENT elif root . val > val : NEW_LINE INDENT root = root . left NEW_LINE DEDENT else : NEW_LINE INDENT root = root . right NEW_LINE DEDENT DEDENT return root NEW_LINE DEDENT DEDENT"],"bleu":0.40596885805540683,"rouge_l":0.6571203363110879}
{"id":1695,"predictions":["class Solution ( object ) : NEW_LINE INDENT def iptoCIDR ( self , ip ) : NEW_LINE INDENT def ipToCIDR ( x ) : NEW_LINE INDENT bits = ip NEW_LINE res = [ ] NEW_LINE while n : NEW_LINE INDENT bits . append ( x ) NEW_LINE n >>= 2 NEW_LINE bits . append ( n ) NEW_LINE n -= 1 NEW_LINE DEDENT return res NEW_LINE DEDENT def ipToCIDR ( x ) : NEW_LINE INDENT if ( x < 0 ) : NEW_LINE INDENT if ( x < 0 ) : NEW_LINE INDENT res . append ( 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT res . append ( 0 ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT DEDENT"],"references":["class Solution ( object ) : NEW_LINE INDENT def ipToInt ( self , ip ) : NEW_LINE INDENT ans = 0 NEW_LINE for x in ip . split ( ' . ' ) : NEW_LINE INDENT ans = 256 * ans + int ( x ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def intToIP ( self , x ) : NEW_LINE INDENT return \" . \" . join ( str ( ( x >> i ) % 256 ) for i in ( 24 , 16 , 8 , 0 ) ) NEW_LINE DEDENT def ipToCIDR ( self , ip , n ) : NEW_LINE INDENT start = self . ipToInt ( ip ) NEW_LINE ans = [ ] NEW_LINE while n : NEW_LINE INDENT mask = max ( 33 - ( start & - start ) . bit_length ( ) , 33 - n . bit_length ( ) ) NEW_LINE ans . append ( self . intToIP ( start ) + ' \/ ' + str ( mask ) ) NEW_LINE start += 1 << ( 32 - mask ) NEW_LINE n -= 1 << ( 32 - mask ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT"],"bleu":0.21453496986572163,"rouge_l":0.39245768583589036}
{"id":1696,"predictions":["class Solution ( object ) : NEW_LINE INDENT def depth ( self , root ) : NEW_LINE INDENT ans = 1 NEW_LINE depth ( root ) NEW_LINE return ans - 1 NEW_LINE DEDENT def depth ( self , root ) : NEW_LINE INDENT if root is None : NEW_LINE INDENT return 0 NEW_LINE DEDENT L = depth ( root . left ) NEW_LINE R = depth ( root . right ) NEW_LINE ans = max ( L , R + 1 ) NEW_LINE return ans NEW_LINE DEDENT DEDENT"],"references":["class Solution ( object ) : NEW_LINE INDENT def diameterOfBinaryTree ( self , root ) : NEW_LINE INDENT self . ans = 1 NEW_LINE def depth ( node ) : NEW_LINE INDENT if not node : return 0 NEW_LINE L = depth ( node . left ) NEW_LINE R = depth ( node . right ) NEW_LINE self . ans = max ( self . ans , L + R + 1 ) NEW_LINE return max ( L , R ) + 1 NEW_LINE DEDENT depth ( root ) NEW_LINE return self . ans - 1 NEW_LINE DEDENT DEDENT"],"bleu":0.5344674961969991,"rouge_l":0.6878903539208882}
{"id":1697,"predictions":["class Solution ( object ) : NEW_LINE INDENT def findSecondMinimumValue ( self , root ) : NEW_LINE INDENT if root is None : NEW_LINE INDENT return - 1 NEW_LINE DEDENT stack = [ ] NEW_LINE min_val = root . val NEW_LINE stack . append ( root ) NEW_LINE while len ( stack ) != 0 : NEW_LINE INDENT node = stack . pop ( 0 ) NEW_LINE if node is None : NEW_LINE INDENT continue NEW_LINE DEDENT if node . val < ans and node . val > min_val : NEW_LINE INDENT continue NEW_LINE DEDENT if node . val < ans and node . val > min_val : NEW_LINE INDENT stack . append ( node . val ) NEW_LINE stack . append ( node . left ) NEW_LINE stack . insert ( 0 , 0 ) NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT"],"references":["class Solution ( object ) : NEW_LINE INDENT def findSecondMinimumValue ( self , root ) : NEW_LINE INDENT if not root : NEW_LINE INDENT return - 1 NEW_LINE DEDENT ans = float ( ' inf ' ) NEW_LINE min_val = root . val NEW_LINE stack = [ root ] NEW_LINE while stack : NEW_LINE INDENT curr = stack . pop ( ) NEW_LINE if not curr : NEW_LINE INDENT continue NEW_LINE DEDENT if min_val < curr . val < ans : NEW_LINE INDENT ans = curr . val NEW_LINE DEDENT elif curr . val == min_val : NEW_LINE INDENT stack . append ( curr . left ) NEW_LINE stack . append ( curr . right ) NEW_LINE DEDENT DEDENT return ans if ans < float ( ' inf ' ) else - 1 NEW_LINE DEDENT DEDENT"],"bleu":0.4943062291589266,"rouge_l":0.6820856873822976}
{"id":1698,"predictions":["class Solution ( object ) : NEW_LINE INDENT def removeNthFromEnd ( self , head , n ) : NEW_LINE INDENT slow = head NEW_LINE fast = head NEW_LINE while fast : NEW_LINE INDENT fast = fast . next NEW_LINE n = fast . next NEW_LINE DEDENT if fast == None : NEW_LINE INDENT head = head . next NEW_LINE return head NEW_LINE DEDENT while fast . next != None : NEW_LINE INDENT fast = fast . next NEW_LINE fast = fast . next NEW_LINE DEDENT curr = fast . next NEW_LINE fast . next = curr . next NEW_LINE return head NEW_LINE DEDENT DEDENT"],"references":["class Solution ( object ) : NEW_LINE INDENT def removeNthFromEnd ( self , head , n ) : NEW_LINE INDENT if head is None : NEW_LINE INDENT return None NEW_LINE DEDENT slow = fast = head NEW_LINE for i in range ( n ) : NEW_LINE INDENT fast = fast . next NEW_LINE DEDENT if fast is None : NEW_LINE INDENT head = head . next NEW_LINE return head NEW_LINE DEDENT while fast . next is not None : NEW_LINE INDENT fast = fast . next NEW_LINE slow = slow . next NEW_LINE DEDENT curr = slow . next NEW_LINE slow . next = curr . next NEW_LINE return head NEW_LINE DEDENT DEDENT"],"bleu":0.6679861858589022,"rouge_l":0.8050389922015598}
