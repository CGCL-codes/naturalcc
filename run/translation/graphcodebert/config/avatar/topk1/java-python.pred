{"id":0,"predictions":["x , y = map ( int , input ( ) . split ( ) ) NEW_LINE print ( x ) NEW_LINE"],"references":["x , y = map ( int , str ( input ( ) ) . split ( ' ▁ ' ) ) NEW_LINE print ( ' { } ' . format ( x if x > y else y ) ) NEW_LINE"],"bleu":0.2874417699047489,"rouge_l":0.6508244422890399}
{"id":1,"predictions":["s = input ( ) NEW_LINE s = [ ] NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT s . append ( input ( ) ) NEW_LINE DEDENT if len ( s ) > 26 : NEW_LINE INDENT s . append ( s [ i : i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT s . append ( s [ i ] ) NEW_LINE DEDENT DEDENT print ( - 1 ) NEW_LINE"],"references":["s = input ( ) NEW_LINE if len ( s ) != 26 : NEW_LINE INDENT se = set ( [ ] ) NEW_LINE for w in s : NEW_LINE INDENT se . add ( w ) NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT w = chr ( ord ( ' a ' ) + i ) NEW_LINE if w not in se : NEW_LINE INDENT print ( s + w ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT DEDENT if s == \" zyxwvutsrqponmlkjihgfedcba \" : NEW_LINE INDENT print ( - 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT se = set ( [ ] ) NEW_LINE for i in reversed ( range ( 26 ) ) : NEW_LINE INDENT se . add ( s [ i ] ) NEW_LINE for j in range ( ord ( s [ i ] ) - ord ( ' a ' ) + 1 , 26 ) : NEW_LINE INDENT if chr ( ord ( ' a ' ) + j ) in se : NEW_LINE INDENT print ( s [ : i ] + chr ( ord ( ' a ' ) + j ) ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT DEDENT"],"bleu":0.10020607251694545,"rouge_l":0.3638687686408181}
{"id":2,"predictions":["n , t = map ( int , input ( ) . split ( ) ) NEW_LINE s = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if l [ i ] > s [ i - 1 ] : NEW_LINE INDENT l . append ( l [ i ] - s [ i - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT l . append ( l [ i ] + t ) NEW_LINE DEDENT DEDENT print ( sum ( l ) ) NEW_LINE"],"references":["def getInt ( ) : return int ( input ( ) ) NEW_LINE def getIntList ( ) : return [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE def dmp ( x ) : NEW_LINE INDENT global debug NEW_LINE if debug : NEW_LINE INDENT print ( x ) NEW_LINE DEDENT DEDENT def probC ( ) : NEW_LINE INDENT N , T = getIntList ( ) NEW_LINE Ts = getIntList ( ) NEW_LINE dmp ( ( N , T , Ts ) ) NEW_LINE total = Ts [ 0 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT total += min ( T , Ts [ i ] - Ts [ i - 1 ] ) NEW_LINE DEDENT return total + T NEW_LINE DEDENT debug = False NEW_LINE print ( probC ( ) ) NEW_LINE"],"bleu":0.25060087346577015,"rouge_l":0.4144625090997331}
{"id":3,"predictions":["n = int ( input ( ) ) NEW_LINE ans = 0 NEW_LINE if n % 2 == 1 : NEW_LINE INDENT ans = num + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = num + 1 NEW_LINE DEDENT print ( ans ) NEW_LINE"],"references":["n = int ( input ( ) ) NEW_LINE if n % 2 == 0 : NEW_LINE INDENT print ( n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n + 1 ) NEW_LINE DEDENT"],"bleu":0.46450317427543164,"rouge_l":0.6851183313277176}
{"id":4,"predictions":["def print1 ( arraymid , N ) : NEW_LINE INDENT for i in range ( 0 , len ( arraymid ) ) : NEW_LINE INDENT print ( array [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( end = \" ▁ \" ) NEW_LINE DEDENT def display ( K , N ) : NEW_LINE INDENT a1 = [ ] NEW_LINE a1 . append ( int ( K \/ 2 ) ) NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT a1 . append ( i , ( K + 1 ) ) NEW_LINE DEDENT for i in range ( 1 , N \/\/ 2 ) : NEW_LINE INDENT a1 . append ( ( i , ( K + 1 ) \/\/ 2 ) NEW_LINE DEDENT for i in range ( N \/\/ 2 ) : NEW_LINE INDENT a1 [ i ] = a [ i ] NEW_LINE DEDENT for i in range ( N \/\/ 2 ) : NEW_LINE INDENT a1 [ i ] = a1 [ i ] NEW_LINE DEDENT for i in range ( N \/\/ 2 ) : NEW_LINE INDENT a1 [ i ] = a [ i ] NEW_LINE DEDENT for j in range ( N \/\/ 2 ) : NEW_LINE INDENT if ( arr1 [ len ( arr1 ) - 1 ] == 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT arr2 [ len ( arr1 ) - 1 ] NEW_LINE DEDENT DEDENT print ( arr1 , N ) ) NEW_LINE DEDENT DEDENT if ( K % 2 == 0 ) : NEW_LINE INDENT print ( arr1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr2 ) NEW_LINE DEDENT DEDENT"],"references":["import math NEW_LINE def main ( ) : NEW_LINE INDENT [ K , N ] = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE r = [ ] NEW_LINE if K == 1 : NEW_LINE INDENT r = [ 1 ] * ( ( N + 1 ) \/\/ 2 ) NEW_LINE DEDENT elif K % 2 == 0 : NEW_LINE INDENT r = [ K \/\/ 2 ] NEW_LINE r += [ K ] * ( N - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT t = N \/\/ 2 NEW_LINE x = int ( math . log ( N * ( K - 1 ) + 1 , K ) - 1 ) NEW_LINE while t < ( ( K ** ( x + 1 ) - 1 ) \/ ( K - 1 ) + x ) \/\/ 2 : NEW_LINE INDENT x -= 1 NEW_LINE DEDENT x += 1 NEW_LINE r = [ ( K + 1 ) \/\/ 2 ] * ( N - x ) NEW_LINE r += [ 0 ] * x NEW_LINE t = ( ( K ** ( x + 1 ) - 1 ) \/ ( K - 1 ) + x ) \/\/ 2 - t NEW_LINE for i in range ( x , 0 , - 1 ) : NEW_LINE INDENT r [ N - i ] = 1 NEW_LINE t -= 1 NEW_LINE for j in range ( K - 1 ) : NEW_LINE INDENT if t == 0 : NEW_LINE INDENT break NEW_LINE DEDENT if K ** i - 1 <= t * ( K - 1 ) : NEW_LINE INDENT r [ N - i ] += 1 NEW_LINE t -= ( K ** i - 1 ) \/\/ ( K - 1 ) NEW_LINE DEDENT DEDENT if t == 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in range ( len ( r ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if r [ i ] == 0 : NEW_LINE INDENT r . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT print ( ' ▁ ' . join ( list ( map ( str , r ) ) ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"bleu":0.21646383197779592,"rouge_l":0.3841555241181035}
{"id":5,"predictions":["a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if b <= 8 and a <= 8 and b <= \" : NEW_LINE INDENT print ( \" Yay ! \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Yay ! \" ) NEW_LINE DEDENT"],"references":["A , B = map ( int , input ( ) . split ( ) ) NEW_LINE if A <= 8 and B <= 8 : NEW_LINE INDENT print ( ' Yay ! ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' : ( ' ) NEW_LINE DEDENT"],"bleu":0.5481049120538793,"rouge_l":0.7746031746031746}
{"id":6,"predictions":["from collections import Counter NEW_LINE N , A , B = map ( int , input ( ) . split ( ) ) NEW_LINE A = map ( int , input ( ) . split ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE A . sort ( ) NEW_LINE A . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in A : NEW_LINE INDENT for j in range ( A ) : NEW_LINE INDENT A [ i ] *= A [ j ] NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT if A [ i ] * A [ i ] < B [ i ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["import heapq NEW_LINE N , A , B = map ( int , input ( ) . split ( ) ) NEW_LINE src = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if A == 1 : NEW_LINE INDENT for v in sorted ( src ) : NEW_LINE INDENT print ( v ) NEW_LINE DEDENT exit ( ) NEW_LINE DEDENT mem = [ ] NEW_LINE maxv = 0 NEW_LINE for i , v in enumerate ( src ) : NEW_LINE INDENT mem . append ( ( v , i ) ) NEW_LINE if v > maxv : maxv = v NEW_LINE DEDENT heapq . heapify ( mem ) NEW_LINE while True : NEW_LINE INDENT v , i = heapq . heappop ( mem ) NEW_LINE if B == 0 or ( v * A > maxv and B % N == 0 ) : NEW_LINE INDENT heapq . heappush ( mem , ( v , i ) ) NEW_LINE break NEW_LINE DEDENT maxv = max ( maxv , v * A ) NEW_LINE heapq . heappush ( mem , ( v * A , i ) ) NEW_LINE B -= 1 NEW_LINE DEDENT MOD = 10 ** 9 + 7 NEW_LINE p = pow ( A , B \/\/ N , MOD ) NEW_LINE while mem : NEW_LINE INDENT v , i = heapq . heappop ( mem ) NEW_LINE print ( ( v * p ) % MOD ) NEW_LINE DEDENT"],"bleu":0.2204404992348838,"rouge_l":0.3949132947976879}
{"id":7,"predictions":["n , m , n = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE while n > m : NEW_LINE INDENT ans += n % m NEW_LINE n \/\/= m NEW_LINE DEDENT print ( ans + n ) NEW_LINE"],"references":["m , n , N = [ int ( _ ) for _ in input ( ) . split ( ) ] NEW_LINE result = N NEW_LINE s = N NEW_LINE while s >= m : NEW_LINE INDENT x , s = divmod ( s , m ) NEW_LINE s += x * n NEW_LINE result += x * n NEW_LINE DEDENT print ( result ) NEW_LINE"],"bleu":0.2175075423307677,"rouge_l":0.5066445182724253}
{"id":8,"predictions":["W , h , h , n = map ( int , input ( ) . split ( ) ) NEW_LINE x , y = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == 1 : NEW_LINE INDENT x = a [ i ] NEW_LINE DEDENT elif a [ i ] == a [ i ] : NEW_LINE INDENT x = a [ i ] NEW_LINE DEDENT elif a [ i ] == a [ i ] : NEW_LINE INDENT x = a [ i ] NEW_LINE DEDENT DEDENT elif a [ i ] == 2 : NEW_LINE INDENT if a [ i ] == a [ i ] : NEW_LINE INDENT ans = ( x NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["w , h , n = map ( int , input ( ) . split ( ) ) NEW_LINE x1 = [ ] NEW_LINE x2 = [ ] NEW_LINE y3 = [ ] NEW_LINE y4 = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT x , y , a = map ( int , input ( ) . split ( ) ) NEW_LINE if a == 1 : NEW_LINE INDENT x1 . append ( x ) NEW_LINE DEDENT elif a == 2 : NEW_LINE INDENT x2 . append ( x ) NEW_LINE DEDENT elif a == 3 : NEW_LINE INDENT y3 . append ( y ) NEW_LINE DEDENT else : NEW_LINE INDENT y4 . append ( y ) NEW_LINE DEDENT DEDENT for t in [ x1 , y3 ] : NEW_LINE INDENT if not t : NEW_LINE INDENT t . append ( 0 ) NEW_LINE DEDENT DEDENT if not x2 : NEW_LINE INDENT x2 . append ( w ) NEW_LINE DEDENT if not y4 : NEW_LINE INDENT y4 . append ( h ) NEW_LINE DEDENT if max ( x1 ) >= min ( x2 ) or max ( y3 ) >= min ( y4 ) : NEW_LINE INDENT print ( 0 ) NEW_LINE exit ( ) NEW_LINE DEDENT print ( ( min ( x2 ) - max ( x1 ) ) * ( min ( y4 ) - max ( y3 ) ) ) NEW_LINE"],"bleu":0.28620678345779277,"rouge_l":0.3882668711656442}
{"id":9,"predictions":["S = input ( ) NEW_LINE print ( ' First ' ) NEW_LINE"],"references":["S = input ( ) NEW_LINE if S [ 0 ] == S [ - 1 ] : NEW_LINE INDENT if len ( S ) % 2 == 0 : NEW_LINE INDENT print ( \" First \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Second \" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if len ( S ) % 2 == 1 : NEW_LINE INDENT print ( \" First \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Second \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.0014233259052215113,"rouge_l":0.18821879382889203}
{"id":10,"predictions":["s = input ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT if s [ i ] != 1 : NEW_LINE INDENT ans += int ( s [ i ] ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["print ( ( lambda S : sum ( eval ( ' ' . join ( ' ' . join ( i ) for i in zip ( S , ( [ ' ' , ' + ' ] [ int ( i ) ] for i in ' { :0 > { } b } 0' . format ( i , len ( S ) - 1 ) ) ) ) ) for i in range ( 1 << len ( S ) - 1 ) ) ) ( input ( ) ) ) NEW_LINE"],"bleu":0.0884644644597893,"rouge_l":0.2326271186440678}
{"id":11,"predictions":["def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( a , b ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT L = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE a = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE a = [ int ( i ) for i in a . split ( ) ] NEW_LINE a = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE a = [ int ( i ) for i in range ( len ( L ) ) ] NEW_LINE a = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE b = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE a . sort ( ) NEW_LINE ans = a [ 0 ] NEW_LINE for i in range ( a ) : NEW_LINE INDENT ans = min ( b , a [ i ] ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT"],"references":["N , M = ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE S = input ( ) NEW_LINE T = input ( ) NEW_LINE def gcd ( x , y ) : NEW_LINE INDENT x , y = min ( x , y ) , max ( x , y ) NEW_LINE if y % x == 0 : NEW_LINE INDENT return x NEW_LINE DEDENT return gcd ( x , y % x ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT if S [ 0 ] != T [ 0 ] : NEW_LINE INDENT return - 1 NEW_LINE DEDENT g = gcd ( N , M ) NEW_LINE n = N \/\/ g NEW_LINE m = M \/\/ g NEW_LINE for i in range ( g ) : NEW_LINE INDENT if S [ n * i ] != T [ m * i ] : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT return N * M \/\/ g NEW_LINE DEDENT print ( main ( ) ) NEW_LINE"],"bleu":0.1872135546590424,"rouge_l":0.3194513715710723}
{"id":12,"predictions":["n = int ( input ( ) ) NEW_LINE count = 0 NEW_LINE for _ in range ( n ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT print ( len ( count ) ) ) NEW_LINE"],"references":["print ( len ( set ( map ( int , input ( ) . split ( ) ) ) ) ) NEW_LINE"],"bleu":0.2118742057799596,"rouge_l":0.355270821199767}
{"id":13,"predictions":["print ( input ( ) ) NEW_LINE"],"references":["a , b , c = input ( ) . split ( ' , ' ) NEW_LINE print ( a , b , c ) NEW_LINE"],"bleu":0.030948946360312153,"rouge_l":0.27452745274527457}
{"id":14,"predictions":["x , y = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE while x <= y : NEW_LINE INDENT x *= 2 NEW_LINE y *= 2 NEW_LINE DEDENT print ( ans ) NEW_LINE"],"references":["x , y = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 1 NEW_LINE a = x NEW_LINE for _ in range ( 61 ) : NEW_LINE INDENT a *= 2 NEW_LINE if a <= y : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"bleu":0.4063140848804282,"rouge_l":0.6365533691115086}
{"id":15,"predictions":["n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if a [ j ] < a [ i - 1 ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["from sys import exit , setrecursionlimit NEW_LINE from itertools import product NEW_LINE def read ( ) : NEW_LINE INDENT return int ( input ( ) ) NEW_LINE DEDENT def reads ( ) : NEW_LINE INDENT return [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE DEDENT def argmin ( ll ) : NEW_LINE INDENT ll = list ( ll ) NEW_LINE return ll . index ( min ( ll ) ) NEW_LINE DEDENT setrecursionlimit ( 1000000 ) NEW_LINE ( N , K ) = reads ( ) NEW_LINE parent = [ x - 1 for x in reads ( ) ] NEW_LINE result = 0 NEW_LINE if parent [ 0 ] != 0 : NEW_LINE INDENT parent [ 0 ] = 0 NEW_LINE result += 1 NEW_LINE DEDENT children = [ [ ] for _ in range ( N ) ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT children [ parent [ i ] ] . append ( i ) NEW_LINE DEDENT color = [ 0 ] * N NEW_LINE def walk ( i ) : NEW_LINE INDENT global result NEW_LINE for x in children [ i ] : NEW_LINE INDENT walk ( x ) NEW_LINE if color [ x ] == 1 and parent [ x ] != 0 : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT color [ i ] = min ( [ K ] + [ color [ x ] - 1 for x in children [ i ] if color [ x ] >= 2 ] ) NEW_LINE DEDENT walk ( 0 ) NEW_LINE print ( result ) NEW_LINE"],"bleu":0.054213716531668336,"rouge_l":0.30453337627828325}
{"id":16,"predictions":["n , m , q = map ( int , input ( ) . split ( ) ) NEW_LINE Ri = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] NEW_LINE L = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] NEW_LINE Ri = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] NEW_LINE Ri = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] NEW_LINE for i in range ( Q ) : NEW_LINE INDENT Ri , Ri = Ri , I NEW_LINE DEDENT for i in range ( Q ) : NEW_LINE INDENT L , Ri = Ri ( ) NEW_LINE DEDENT for j in range ( Q ) : NEW_LINE INDENT Ri = Ri [ i ] NEW_LINE DEDENT Ri = Ri NEW_LINE for i in range ( Q ) : NEW_LINE INDENT L = Ri [ j ] NEW_LINE Ri = Ri NEW_LINE for i in range ( N ) : NEW_LINE INDENT Ri += Ri [ i ] NEW_LINE DEDENT DEDENT for i in range ( Q ) : NEW_LINE INDENT print ( Ri [ i ] ) NEW_LINE DEDENT"],"references":["from itertools import accumulate NEW_LINE N , M , Q = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ [ 0 ] * ( N + 1 ) for i in range ( N + 1 ) ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT L , R = map ( int , input ( ) . split ( ) ) NEW_LINE a [ L ] [ R ] += 1 NEW_LINE DEDENT b = [ list ( accumulate ( a [ i ] ) ) for i in range ( N + 1 ) ] NEW_LINE k = [ [ b [ j ] [ i ] for j in range ( i + 1 ) ] for i in range ( N + 1 ) ] NEW_LINE ans = [ list ( accumulate ( reversed ( k [ i ] ) ) ) [ : : - 1 ] for i in range ( N + 1 ) ] NEW_LINE for i in range ( Q ) : NEW_LINE INDENT p , q = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ans [ q ] [ p - q - 1 ] ) NEW_LINE DEDENT"],"bleu":0.39430533291400166,"rouge_l":0.47622117175189793}
{"id":17,"predictions":["n , m , x = map ( int , input ( ) . split ( ) ) NEW_LINE y = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE x = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE y = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( min ( y , x ) ) NEW_LINE"],"references":["N , M , X = ( int ( x ) for x in input ( ) . split ( ) ) NEW_LINE A = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE Z = [ 0 ] * N NEW_LINE for a in A : NEW_LINE INDENT Z [ a ] = 1 NEW_LINE DEDENT lower = 0 NEW_LINE for i in range ( 0 , X + 1 ) : NEW_LINE INDENT lower += Z [ i ] NEW_LINE DEDENT higher = 0 NEW_LINE for i in range ( X , N ) : NEW_LINE INDENT higher += Z [ i ] NEW_LINE DEDENT print ( min ( lower , higher ) ) NEW_LINE"],"bleu":0.15667364352081423,"rouge_l":0.389657794676806}
{"id":18,"predictions":["n = int ( input ( ) ) NEW_LINE d = [ ] NEW_LINE for _ in range ( n - 1 ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE d [ a - 1 ] . append ( ( a , b ) ) NEW_LINE DEDENT d = [ - 1 for _ in range ( n - 1 ) ] NEW_LINE dfs = [ - 1 for _ in range ( n - 1 ) ] NEW_LINE dfs = [ - 1 for _ in range ( n - 1 ) ] NEW_LINE for _ in range ( n - 1 ) : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE dfs ( a , b , c ) NEW_LINE visited [ b ] = 1 NEW_LINE DEDENT ans = 0 NEW_LINE for _ in range ( n - 1 ) : NEW_LINE INDENT if visited [ a ] == 0 : NEW_LINE INDENT dfs ( a , a , b ) NEW_LINE INDENT dfs ( a , b , c ) NEW_LINE ans = dfs ( a , b ) NEW_LINE DEDENT DEDENT print ( ans + 1 , ans + 1 ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE from collections import deque NEW_LINE def dfs ( edges , start ) : NEW_LINE INDENT visited = [ 0 ] * len ( edges ) NEW_LINE visited [ start ] = 1 NEW_LINE ans , dist = 0 , 0 NEW_LINE stack = deque ( [ ( start , 0 ) ] ) NEW_LINE pop , append = stack . pop , stack . append NEW_LINE while stack : NEW_LINE INDENT v , _dist = pop ( ) NEW_LINE if _dist > dist : NEW_LINE INDENT ans , dist = v , _dist NEW_LINE DEDENT for e in edges [ v ] : NEW_LINE INDENT if visited [ e ] : NEW_LINE INDENT continue NEW_LINE DEDENT visited [ e ] = 1 NEW_LINE append ( ( e , _dist + 1 ) ) NEW_LINE DEDENT DEDENT return ans , dist NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE edges = [ [ ] for _ in [ 0 ] * N ] NEW_LINE for ( a , b ) in ( map ( int , l . split ( ) ) for l in sys . stdin ) : NEW_LINE INDENT edges [ a - 1 ] . append ( b - 1 ) NEW_LINE edges [ b - 1 ] . append ( a - 1 ) NEW_LINE DEDENT v , _ = dfs ( edges , 0 ) NEW_LINE print ( v + 1 , dfs ( edges , v ) [ 0 ] + 1 ) NEW_LINE DEDENT"],"bleu":0.2406645762904556,"rouge_l":0.3503916449086162}
{"id":19,"predictions":["from collections import Counter NEW_LINE t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE if b < d : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE print ( \" Yes \" ) NEW_LINE DEDENT DEDENT"],"references":["T = int ( input ( ) ) NEW_LINE ABCD = [ [ int ( _ ) for _ in input ( ) . split ( ) ] for _ in range ( T ) ] NEW_LINE def gcd ( x , y ) : NEW_LINE INDENT if x < y : NEW_LINE INDENT return gcd ( y , x ) NEW_LINE DEDENT elif x % y == 0 : NEW_LINE INDENT return y NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( y , x % y ) NEW_LINE DEDENT DEDENT for a , b , c , d in ABCD : NEW_LINE INDENT if a < b or d < b : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT else : NEW_LINE INDENT g = gcd ( b , d ) NEW_LINE x = g * ( c \/\/ g ) + ( a % g ) NEW_LINE if x <= c : NEW_LINE INDENT x += g NEW_LINE DEDENT if x >= b : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE NEW_LINE DEDENT DEDENT DEDENT"],"bleu":0.13004268659472754,"rouge_l":0.3440347071583514}
{"id":20,"predictions":["n , k = map ( int , input ( ) . split ( ) ) NEW_LINE if k == 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT"],"references":["import math NEW_LINE k = int ( input ( ) ) NEW_LINE if k == 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE print ( 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT n = math . ceil ( k \/ 4 ) * 2 NEW_LINE ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT tmp = [ ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT tmp . append ( ( i + j ) % n + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT tmp . append ( n + ( i + j ) % n + 1 ) NEW_LINE DEDENT DEDENT ans . append ( tmp ) NEW_LINE DEDENT kazu = n * 2 NEW_LINE while kazu != k : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ans [ i ] [ j ] == kazu : NEW_LINE INDENT ans [ i ] [ j ] -= n NEW_LINE DEDENT DEDENT DEDENT kazu -= 1 NEW_LINE DEDENT print ( n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( * ans [ i ] ) NEW_LINE DEDENT"],"bleu":0.014071351523500227,"rouge_l":0.23417790940002195}
{"id":21,"predictions":["n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == s [ i ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["n = int ( input ( ) ) NEW_LINE a = [ int ( input ( ) ) for i in range ( n ) ] NEW_LINE b = list ( set ( a ) ) NEW_LINE print ( len ( a ) - len ( b ) ) NEW_LINE"],"bleu":0.3321675517423063,"rouge_l":0.52704}
{"id":22,"predictions":["n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if abs ( a - b ) < abs ( a - b ) : NEW_LINE INDENT a = abs ( b - a ) NEW_LINE DEDENT DEDENT print ( a , b ) NEW_LINE DEDENT"],"references":["def main ( ) : NEW_LINE INDENT n = input ( ) NEW_LINE a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE ai = max ( a ) NEW_LINE a . remove ( ai ) NEW_LINE aj = float ( ' inf ' ) NEW_LINE tmp = float ( ' inf ' ) NEW_LINE for aa in a : NEW_LINE INDENT diff = abs ( ai \/ 2 - aa ) NEW_LINE if diff < tmp : NEW_LINE INDENT tmp = diff NEW_LINE aj = aa NEW_LINE DEDENT DEDENT print ( ai , aj ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"bleu":0.2702609404930665,"rouge_l":0.496927254537659}
{"id":23,"predictions":["n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d = sorted ( a ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT d [ i ] = a [ i + 1 ] - a [ i ] NEW_LINE DEDENT print ( c ) NEW_LINE"],"references":["N , M = map ( int , input ( ) . split ( ) ) NEW_LINE zahyo = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE zahyo . sort ( ) NEW_LINE sa = [ 0 for _ in range ( M - 1 ) ] NEW_LINE for i in range ( M - 1 ) : NEW_LINE INDENT sa [ i ] = zahyo [ i + 1 ] - zahyo [ i ] NEW_LINE DEDENT sa . sort ( reverse = True ) NEW_LINE sa = sa [ N - 1 : ] NEW_LINE print ( sum ( sa ) ) NEW_LINE"],"bleu":0.3886781699821823,"rouge_l":0.6569072858825509}
{"id":24,"predictions":["A , B , K , L = map ( int , input ( ) . split ( ) ) NEW_LINE if K == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( min ( A , B ) ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE input = sys . stdin . readline NEW_LINE A , B , K , L = map ( int , input ( ) . split ( ) ) NEW_LINE s = K \/\/ L NEW_LINE print ( min ( K * A , s * B + ( K - s * L ) * A , ( s + 1 ) * B ) ) NEW_LINE"],"bleu":0.30523347220972513,"rouge_l":0.49471614647333495}
{"id":25,"predictions":["n = int ( input ( ) ) NEW_LINE values = [ ] NEW_LINE values = [ ] NEW_LINE values = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT values . append ( i ) NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT continue NEW_LINE DEDENT values = [ i ] NEW_LINE values . append ( j ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i , j ) : NEW_LINE INDENT if ( i - j >= j ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( i - j ) % 2 == 0 : NEW_LINE INDENT value = values [ i ] NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT ans = i NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["N = input ( ) NEW_LINE L = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def aoki ( i , array ) : NEW_LINE INDENT maxi = - 100000000 NEW_LINE for j in range ( len ( array ) ) : NEW_LINE INDENT tmp = 0 NEW_LINE if j != i : NEW_LINE INDENT if j < i : NEW_LINE INDENT T = array [ j : i + 1 ] NEW_LINE DEDENT elif j > i : NEW_LINE INDENT T = array [ i : j + 1 ] NEW_LINE DEDENT for k in range ( len ( T ) ) : NEW_LINE INDENT if k % 2 == 1 : NEW_LINE INDENT tmp += T [ k ] NEW_LINE DEDENT DEDENT if maxi < tmp : NEW_LINE INDENT choice = j NEW_LINE maxi = tmp NEW_LINE DEDENT DEDENT DEDENT return choice NEW_LINE DEDENT maxi = - 10000000000000 NEW_LINE for i in range ( len ( L ) ) : NEW_LINE INDENT aoki_choice = aoki ( i , L ) NEW_LINE tmp = 0 NEW_LINE if i < aoki_choice : NEW_LINE INDENT T = L [ i : aoki_choice + 1 ] NEW_LINE for j in range ( len ( T ) ) : NEW_LINE INDENT if j % 2 == 0 : NEW_LINE INDENT tmp += T [ j ] NEW_LINE DEDENT DEDENT DEDENT elif i > aoki_choice : NEW_LINE INDENT T = L [ aoki_choice : i + 1 ] NEW_LINE for j in range ( len ( T ) ) : NEW_LINE INDENT if j % 2 == 0 : NEW_LINE INDENT tmp += T [ j ] NEW_LINE DEDENT DEDENT DEDENT maxi = max ( tmp , maxi ) NEW_LINE DEDENT print ( maxi ) NEW_LINE"],"bleu":0.1716582976960322,"rouge_l":0.4080132450331126}
{"id":26,"predictions":["N , K = map ( int , input ( ) . split ( ) ) NEW_LINE res = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT res += abs ( ( ( N - K ) * 2 ) * 2 NEW_LINE DEDENT print ( res ) NEW_LINE"],"references":["N = int ( input ( ) ) NEW_LINE K = int ( input ( ) ) NEW_LINE X = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE sum_len = 0 NEW_LINE for i in range ( len ( X ) ) : NEW_LINE INDENT if X [ i ] < abs ( K - X [ i ] ) : NEW_LINE INDENT sum_len += X [ i ] * 2 NEW_LINE DEDENT else : NEW_LINE INDENT sum_len += abs ( K - X [ i ] ) * 2 NEW_LINE DEDENT DEDENT print ( sum_len ) NEW_LINE"],"bleu":0.20796879325475676,"rouge_l":0.5102120210075861}
{"id":27,"predictions":["n = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if sum ( A ) == 0 : NEW_LINE INDENT print ( ' First ' ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( len ( A ) ) : NEW_LINE INDENT A [ i ] -= 1 NEW_LINE DEDENT DEDENT gcd = A [ : : i ] NEW_LINE if A [ i ] % 2 == 1 : NEW_LINE INDENT return NEW_LINE DEDENT DEDENT print ( ' Second ' ) NEW_LINE"],"references":["from fractions import gcd NEW_LINE def gcdL ( L ) : NEW_LINE INDENT g = L [ 0 ] NEW_LINE for i in range ( 1 , len ( L ) ) : NEW_LINE INDENT if g == 1 : NEW_LINE INDENT return ( g ) NEW_LINE DEDENT g = gcd ( g , L [ i ] ) NEW_LINE DEDENT return g NEW_LINE DEDENT def play ( A , i ) : NEW_LINE INDENT A [ i ] -= 1 NEW_LINE g = gcdL ( A ) NEW_LINE return [ x \/\/ g for x in A ] NEW_LINE DEDENT def cnt ( A ) : NEW_LINE INDENT odd , even = 0 , 0 NEW_LINE for a in A : NEW_LINE INDENT if a % 2 : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even += 1 NEW_LINE DEDENT DEDENT return odd , even NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE First = 1 NEW_LINE while True : NEW_LINE INDENT odd , even = cnt ( A ) NEW_LINE if even % 2 : NEW_LINE INDENT print ( ' First ' if First else ' Second ' ) NEW_LINE break NEW_LINE DEDENT elif odd > 1 : NEW_LINE INDENT print ( ' Second ' if First else ' First ' ) NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if A [ i ] % 2 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if A [ i ] == 1 : NEW_LINE INDENT print ( ' Second ' if First else ' First ' ) NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT A = play ( A , i ) NEW_LINE First ^= 1 NEW_LINE DEDENT DEDENT DEDENT"],"bleu":0.09743408399299643,"rouge_l":0.34017301780224496}
{"id":28,"predictions":["s = input ( ) NEW_LINE s = input ( ) NEW_LINE if len ( s ) == s [ 0 ] : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT"],"references":["s = input ( ) NEW_LINE t = s [ : : - 1 ] NEW_LINE for x , y in zip ( s , t ) : NEW_LINE INDENT if x != ' * ' and y != ' * ' and x != y : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT print ( ' YES ' ) NEW_LINE"],"bleu":0.19470294248672548,"rouge_l":0.4225547243003602}
{"id":29,"predictions":["for i in range ( int ( input ( ) ) ) : n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n < m : NEW_LINE INDENT print ( \" no \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" yes \" ) NEW_LINE DEDENT DEDENT"],"references":["t = int ( input ( ) ) NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE m = int ( input ( ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if n < m : NEW_LINE INDENT print ( \" no \" ) NEW_LINE exit ( ) NEW_LINE DEDENT for i in b : NEW_LINE INDENT for l in range ( len ( a ) ) : NEW_LINE INDENT if i - t - 1 < a [ l ] < i + 1 : NEW_LINE INDENT a . pop ( l ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if len ( a ) == n - m : NEW_LINE INDENT print ( \" yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" no \" ) NEW_LINE DEDENT"],"bleu":0.1408113778067125,"rouge_l":0.4147402774000544}
{"id":30,"predictions":["N , D , D , D = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE for _ in range ( N ) : NEW_LINE INDENT x = 1 NEW_LINE while x <= D : NEW_LINE INDENT x += 1 NEW_LINE DEDENT print ( ans ) NEW_LINE"],"references":["N = int ( input ( ) ) NEW_LINE D , X = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT A = int ( input ( ) ) NEW_LINE ans += ( D - 1 ) \/\/ A + 1 NEW_LINE DEDENT print ( ans + X ) NEW_LINE"],"bleu":0.4562290430577874,"rouge_l":0.6439237899073119}
{"id":31,"predictions":["sq = int ( input ( ) ) NEW_LINE sqrt = 0 NEW_LINE for _ in range ( sq ) : NEW_LINE INDENT s = input ( ) NEW_LINE if s == ' R ' : NEW_LINE INDENT t += 1 NEW_LINE DEDENT elif s == ' R ' : NEW_LINE INDENT print ( ' DRAW ' ) NEW_LINE DEDENT elif s == ' B ' : NEW_LINE INDENT print ( ' DRAW ' ) NEW_LINE DEDENT elif s == ' T ' : NEW_LINE INDENT print ( ' DRAW ' ) NEW_LINE DEDENT elif s == ' T ' : NEW_LINE INDENT print ( ' DRAW ' ) NEW_LINE DEDENT elif s == ' T ' : NEW_LINE INDENT print ( ' DRAW ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' AOKI ' ) NEW_LINE DEDENT"],"references":["* a , = open ( 0 ) . read ( ) ; s , t = map ( a . count , \" RB \" ) ; print ( [ \" ADORKAIW \" [ s == t : : 2 ] , \" TAKAHASHI \" ] [ s > t ] ) NEW_LINE"],"bleu":0.022947589164785714,"rouge_l":0.21289493019838354}
{"id":32,"predictions":["A , B , C , C , S , S , T = map ( int , input ( ) . split ( ) ) NEW_LINE ans = A * B NEW_LINE if S + T >= K : NEW_LINE INDENT ans -= C * T NEW_LINE DEDENT print ( ans ) NEW_LINE"],"references":["a , b , c , k = map ( int , input ( ) . split ( ) ) NEW_LINE s , t = map ( int , input ( ) . split ( ) ) NEW_LINE total = s + t NEW_LINE discount = 0 NEW_LINE if total >= k : NEW_LINE INDENT discount = total * c NEW_LINE DEDENT adm = ( s * a ) + ( t * b ) NEW_LINE print ( adm - discount ) NEW_LINE"],"bleu":0.20378363613394515,"rouge_l":0.4640387275242048}
{"id":33,"predictions":["N , W , T = map ( int , input ( ) . split ( ) ) NEW_LINE S = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] NEW_LINE S = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] NEW_LINE S = [ input ( ) . split ( ) for _ in range ( N ) ] NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( W ) : NEW_LINE INDENT if W - S [ i ] [ j ] < S [ i ] [ j ] : NEW_LINE INDENT ans += S [ i ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT S [ i ] [ j ] = S [ i ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( W ) : NEW_LINE INDENT if W - S [ i ] [ j ] < T [ i ] [ j ] : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT DEDENT DEDENT W , W = map ( int , input ( ) . split ( ) ) NEW_LINE S = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT S += S [ i ] [ j ] NEW_LINE DEDENT print ( * ans ) NEW_LINE"],"references":["n , W = map ( int , input ( ) . split ( ) ) NEW_LINE iw , v = map ( int , input ( ) . split ( ) ) NEW_LINE d = { 0 : [ v ] , 1 : [ ] , 2 : [ ] , 3 : [ ] } NEW_LINE for _ in range ( 1 , n ) : NEW_LINE INDENT w , v = map ( int , input ( ) . split ( ) ) NEW_LINE d [ w - iw ] . append ( v ) NEW_LINE DEDENT for i in range ( 4 ) : NEW_LINE INDENT d [ i ] = sorted ( d [ i ] , reverse = True ) NEW_LINE DEDENT ret = - 1 NEW_LINE for i in range ( min ( n , len ( d [ 0 ] ) ) + 1 ) : NEW_LINE INDENT if i * iw > W : NEW_LINE INDENT break NEW_LINE DEDENT for j in range ( min ( n - i , len ( d [ 1 ] ) ) + 1 ) : NEW_LINE INDENT if i * iw + j * ( iw + 1 ) > W : NEW_LINE INDENT break NEW_LINE DEDENT for k in range ( min ( n - ( i + j ) , len ( d [ 2 ] ) ) + 1 ) : NEW_LINE INDENT if i * iw + j * ( iw + 1 ) + k * ( iw + 2 ) > W : NEW_LINE INDENT break NEW_LINE DEDENT for l in range ( min ( n - ( i + j + k ) , len ( d [ 3 ] ) ) + 1 ) : NEW_LINE INDENT if i * iw + j * ( iw + 1 ) + k * ( iw + 2 ) + l * ( iw + 3 ) > W : NEW_LINE INDENT continue NEW_LINE DEDENT V = sum ( d [ 0 ] [ : i ] ) + sum ( d [ 1 ] [ : j ] ) + sum ( d [ 2 ] [ : k ] ) + sum ( d [ 3 ] [ : l ] ) NEW_LINE ret = max ( ret , V ) NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( ret ) NEW_LINE"],"bleu":0.22422003407410182,"rouge_l":0.39102564102564097}
{"id":34,"predictions":["N , M = map ( int , input ( ) . split ( ) ) NEW_LINE dists = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] NEW_LINE dists = [ 0 ] * N NEW_LINE for i in range ( M ) : NEW_LINE INDENT l , r , c = map ( int , input ( ) . split ( ) ) NEW_LINE adj [ r ] . append ( ( l , r ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT DEDENT"],"references":["def inpl ( ) : return [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE def find ( x ) : NEW_LINE INDENT if par [ x ] == x : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT par [ x ] , dist [ x ] = find ( par [ x ] ) , dist [ x ] + dist [ par [ x ] ] NEW_LINE return par [ x ] NEW_LINE DEDENT DEDENT N , M = inpl ( ) NEW_LINE par = list ( range ( N + 1 ) ) NEW_LINE dist = [ 0 for _ in range ( N + 1 ) ] NEW_LINE for _ in range ( M ) : NEW_LINE INDENT l , r , d = inpl ( ) NEW_LINE fl = find ( l ) NEW_LINE fr = find ( r ) NEW_LINE if fl != fr : NEW_LINE INDENT par [ fr ] = fl NEW_LINE dist [ fr ] = d + dist [ l ] - dist [ r ] NEW_LINE DEDENT elif d + dist [ l ] - dist [ r ] != 0 : NEW_LINE INDENT print ( ' No ' ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT"],"bleu":0.16243717970695498,"rouge_l":0.3697299224529816}
{"id":35,"predictions":["a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE print ( a == b ) NEW_LINE"],"references":["A , B , C = map ( int , input ( ) . split ( ) ) NEW_LINE if A == B : NEW_LINE INDENT print ( C ) NEW_LINE DEDENT elif A == C : NEW_LINE INDENT print ( B ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( A ) NEW_LINE DEDENT"],"bleu":0.19696512734182592,"rouge_l":0.4870722433460076}
{"id":36,"predictions":["Y , m , d , d = map ( int , input ( ) . split ( ) ) NEW_LINE print ( 7 * y \/\/ 4 ) NEW_LINE"],"references":["y = int ( input ( ) ) NEW_LINE m = int ( input ( ) ) NEW_LINE d = int ( input ( ) ) NEW_LINE def f ( x ) : NEW_LINE INDENT return int ( x \/\/ 1 ) NEW_LINE DEDENT def F ( y , m , d ) : NEW_LINE INDENT if m == 1 or m == 2 : NEW_LINE INDENT y -= 1 NEW_LINE m += 12 NEW_LINE DEDENT return int ( 365 * y + f ( y \/ 4 ) - f ( y \/ 100 ) + f ( y \/ 400 ) + f ( 306 * ( m + 1 ) \/ 10 ) + d - 429 ) NEW_LINE DEDENT print ( F ( 2014 , 5 , 17 ) - F ( y , m , d ) ) NEW_LINE"],"bleu":0.006946331452537524,"rouge_l":0.1747556454330974}
{"id":37,"predictions":["n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = a [ i ] * m + a [ i ] NEW_LINE if ( x * i ) in a : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["f = lambda x : sum ( map ( int , str ( x ) ) ) NEW_LINE ans = [ ] NEW_LINE def check ( x ) : NEW_LINE INDENT y = f ( x ) NEW_LINE while ans : NEW_LINE INDENT p = ans [ - 1 ] NEW_LINE if p * y > x * f ( p ) : ans . pop ( - 1 ) NEW_LINE else : break NEW_LINE DEDENT ans . append ( x ) NEW_LINE DEDENT k = int ( input ( ) ) NEW_LINE for i in range ( 1 , 100 ) : NEW_LINE INDENT check ( i ) NEW_LINE DEDENT a , b = 0 , 1 NEW_LINE while a < 1e12 : NEW_LINE INDENT for i in range ( 100 , 1000 ) : NEW_LINE INDENT check ( i * b + a ) NEW_LINE DEDENT a = a * 10 + 9 NEW_LINE b *= 10 NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT print ( ans [ i ] ) NEW_LINE DEDENT"],"bleu":0.10356800912593495,"rouge_l":0.3664933564413634}
{"id":38,"predictions":["from collections import Counter NEW_LINE N = int ( input ( ) ) NEW_LINE A = [ input ( ) for _ in range ( N ) ] NEW_LINE B = [ int ( input ( ) ) for _ in range ( N ) ] NEW_LINE Q = [ int ( input ( ) ) for _ in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT S = [ input ( ) ] NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT S = [ input ( ) for _ in range ( N ) ] NEW_LINE for j in range ( N ) : NEW_LINE INDENT S [ S [ i ] ] = '1' NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT S [ i ] = S [ j ] NEW_LINE DEDENT for j in range ( N ) : NEW_LINE INDENT S [ j ] = '1' NEW_LINE DEDENT DEDENT print ( ' ' . join ( S ) ) NEW_LINE"],"references":["def solve ( ) : NEW_LINE INDENT s = input ( ) NEW_LINE n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT l , r = ( int ( i ) for i in input ( ) . split ( ) ) NEW_LINE tmp = s [ l - 1 : r ] NEW_LINE s = s [ 0 : l - 1 ] + tmp [ : : - 1 ] + s [ r : : ] NEW_LINE DEDENT print ( s ) NEW_LINE DEDENT solve ( ) NEW_LINE"],"bleu":0.15550473729636846,"rouge_l":0.4098460786709015}
{"id":39,"predictions":["x , t = map ( int , input ( ) . split ( ) ) NEW_LINE print ( x - t ) NEW_LINE"],"references":["a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a - b > 0 : NEW_LINE INDENT print ( a - b ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT"],"bleu":0.28014215095544565,"rouge_l":0.5586080586080586}
{"id":40,"predictions":["import math NEW_LINE q = int ( input ( ) ) NEW_LINE for _ in range ( q ) : NEW_LINE INDENT A , B = map ( int , input ( ) . split ( ) ) NEW_LINE DEDENT Q = int ( input ( ) ) NEW_LINE Q = int ( input ( ) ) NEW_LINE for _ in range ( Q ) : NEW_LINE INDENT A , B = map ( int , input ( ) . split ( ) ) NEW_LINE if A * B > B : NEW_LINE INDENT return 2 * A NEW_LINE DEDENT DEDENT Q = int ( input ( ) ) NEW_LINE q = int ( input ( ) ) NEW_LINE for i in range ( Q ) : NEW_LINE INDENT q , q = map ( int , input ( ) . split ( ) ) NEW_LINE if A * ( A - 1 ) < B : NEW_LINE INDENT q = Q NEW_LINE q = q NEW_LINE DEDENT DEDENT if A == B : NEW_LINE INDENT q = q NEW_LINE DEDENT DEDENT print ( 2 * q ) NEW_LINE"],"references":["import math NEW_LINE q = int ( input ( ) ) NEW_LINE for j in range ( q ) : NEW_LINE INDENT AB = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE AB . sort ( ) NEW_LINE ab = AB [ 0 ] * AB [ 1 ] NEW_LINE for i in range ( int ( math . sqrt ( ab ) ) , AB [ 1 ] + 1 ) : NEW_LINE INDENT if i * i >= ab : NEW_LINE INDENT x = i - 1 NEW_LINE break NEW_LINE DEDENT DEDENT if x == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE continue NEW_LINE DEDENT for i in range ( int ( ab \/ x ) , ab + 1 ) : NEW_LINE INDENT if x * i >= ab : NEW_LINE INDENT y = i - 1 NEW_LINE break NEW_LINE DEDENT DEDENT cnt1 = 2 * x NEW_LINE cnts = 1 if x == y else 0 NEW_LINE cntdd = 1 if x - AB [ 0 ] >= 0 else 0 NEW_LINE cntdu = 1 if AB [ 1 ] - y >= 0 and ( AB [ 1 ] + 1 ) * ( x - AB [ 1 ] + y ) >= ab else 0 NEW_LINE print ( cnt1 - cnts - cntdd - cntdu ) NEW_LINE DEDENT"],"bleu":0.2201384068493744,"rouge_l":0.4060207246047954}
{"id":41,"predictions":["H , W , W , A , B , A , B = map ( int , input ( ) . split ( ) ) NEW_LINE A , B , A = map ( int , input ( ) . split ( ) ) NEW_LINE A = A - B - A NEW_LINE B = B - A - 1 NEW_LINE A = A - B - A NEW_LINE B = B - A NEW_LINE A = B - A * B - A NEW_LINE A = B - A NEW_LINE B = A * B - A - A NEW_LINE B = ( B - A ) * B NEW_LINE for i in range ( W - A ) : NEW_LINE INDENT A * A * B NEW_LINE DEDENT A = B - A - A NEW_LINE if A * B > B - A : NEW_LINE INDENT A * B NEW_LINE DEDENT DEDENT print ( A ) NEW_LINE"],"references":["H , W , A , B = map ( int , input ( ) . split ( ) ) NEW_LINE P = 10 ** 9 + 7 NEW_LINE N = H + W NEW_LINE def fact ( N , P ) : NEW_LINE INDENT ret = [ 1 ] * ( N + 1 ) NEW_LINE for n in range ( 2 , N + 1 ) : NEW_LINE INDENT ret [ n ] = ( ret [ n - 1 ] * n ) % P NEW_LINE DEDENT return ret NEW_LINE DEDENT def pow_r ( a , b , P ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if b % 2 == 0 : NEW_LINE INDENT return pow_r ( ( a ** 2 ) % P , b \/\/ 2 , P ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( a * pow_r ( ( a ** 2 ) % P , ( b - 1 ) \/\/ 2 , P ) ) % P NEW_LINE DEDENT DEDENT def inv_fact ( N , P ) : NEW_LINE INDENT ret = [ 1 ] * ( N + 1 ) NEW_LINE fac = fact ( N , P ) NEW_LINE ret [ N ] = pow_r ( fac [ N ] , P - 2 , P ) NEW_LINE for n in reversed ( range ( 2 , N ) ) : NEW_LINE INDENT ret [ n ] = ( ret [ n + 1 ] * ( n + 1 ) ) % P NEW_LINE DEDENT return ret NEW_LINE DEDENT fac = fact ( N , P ) NEW_LINE inv = inv_fact ( N , P ) NEW_LINE def combination ( n , r , P ) : NEW_LINE INDENT return ( fac [ n ] * inv [ r ] * inv [ n - r ] ) % P NEW_LINE DEDENT sub = 0 NEW_LINE for a in range ( A ) : NEW_LINE INDENT sub = ( sub + combination ( ( H - 1 - a ) + ( B - 1 ) , B - 1 , P ) * combination ( a + ( W - 1 - B ) , a , P ) ) % P NEW_LINE DEDENT print ( ( combination ( ( H - 1 ) + ( W - 1 ) , H - 1 , P ) - sub ) % P ) NEW_LINE"],"bleu":0.05418202879990434,"rouge_l":0.24032147922466776}
{"id":42,"predictions":["n = int ( input ( ) ) NEW_LINE r_list = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT r_list . append ( int ( input ( ) ) ) NEW_LINE DEDENT r_list = [ ] NEW_LINE for i in range ( n_list ) : NEW_LINE INDENT r_list . append ( ( int ( input ( ) ) ) ) NEW_LINE DEDENT for i in range ( n_list ) : NEW_LINE INDENT r_list . append ( r_list [ i ] ) NEW_LINE DEDENT r_list . append ( r_list [ i ] ) NEW_LINE DEDENT print ( r_list ) NEW_LINE"],"references":["from collections import Counter NEW_LINE L , R = map ( int , input ( ) . split ( ) ) NEW_LINE inputs_l = Counter ( [ int ( i ) for i in input ( ) . split ( ) ] ) NEW_LINE inputs_r = Counter ( [ int ( i ) for i in input ( ) . split ( ) ] ) NEW_LINE print ( sum ( [ min ( inputs_r [ key ] , value ) for key , value in inputs_l . items ( ) ] ) ) NEW_LINE"],"bleu":0.13159816958880505,"rouge_l":0.4179478609625668}
{"id":43,"predictions":["n = int ( input ( ) ) NEW_LINE ans = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT ans *= i NEW_LINE DEDENT print ( ans ) NEW_LINE"],"references":["x = int ( input ( ) ) NEW_LINE y = [ ] NEW_LINE for i in range ( 1 , 33 ) : NEW_LINE INDENT for j in range ( 2 , 11 ) : NEW_LINE INDENT y . append ( i ** j ) NEW_LINE DEDENT DEDENT ans = 1 NEW_LINE for i in y : NEW_LINE INDENT if i <= x : NEW_LINE INDENT ans = max ( ans , i ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"bleu":0.20079687503697266,"rouge_l":0.4676718630207002}
{"id":44,"predictions":["n = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = - 1 NEW_LINE if ans == - 1 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = 1 NEW_LINE DEDENT print ( ans - 1 ) NEW_LINE"],"references":["a = [ int ( input ( ) ) for _ in [ 0 ] * int ( input ( ) ) ] * 2 NEW_LINE if len ( set ( a ) ) < 2 : NEW_LINE INDENT print ( - 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT b = c = m = 0 NEW_LINE for i in a : NEW_LINE INDENT if i : NEW_LINE INDENT b += 1 NEW_LINE m = max ( m , b , c ) NEW_LINE c = 0 NEW_LINE DEDENT else : NEW_LINE INDENT c += 1 NEW_LINE m = max ( m , b , c ) NEW_LINE b = 0 NEW_LINE DEDENT DEDENT print ( ~ - m \/\/ 2 + 1 ) NEW_LINE"],"bleu":0.15365542501179608,"rouge_l":0.38929798723613157}
{"id":45,"predictions":["N , A , B , C = map ( int , input ( ) . split ( ) ) NEW_LINE if N == A : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE N = int ( input ( ) ) NEW_LINE NG1 = int ( input ( ) ) NEW_LINE NG2 = int ( input ( ) ) NEW_LINE NG3 = int ( input ( ) ) NEW_LINE if N == NG1 or N == NG2 or N == NG3 : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE sys . exit ( ) NEW_LINE DEDENT queue = [ ] NEW_LINE queue . append ( ( 0 , N ) ) NEW_LINE judge = [ ] NEW_LINE while queue : NEW_LINE INDENT a = queue . pop ( 0 ) NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT b = a [ 1 ] - [ 1 , 2 , 3 ] [ i ] NEW_LINE if b != NG1 and b != NG2 and b != NG3 and a [ 0 ] < 100 : NEW_LINE INDENT num = ( a [ 0 ] + 1 , b ) NEW_LINE if b > 0 and num [ 0 ] < 100 and num not in judge and ( 100 - num [ 0 ] ) * 3 >= b : NEW_LINE INDENT queue . append ( num ) NEW_LINE judge . append ( num ) NEW_LINE DEDENT elif b == 0 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE sys . exit ( ) NEW_LINE DEDENT else : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( ' NO ' ) NEW_LINE"],"bleu":0.00933581003391556,"rouge_l":0.21453692848769051}
{"id":46,"predictions":["from collections import deque NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE graph = [ True ] * ( n + 1 ) NEW_LINE graph = [ False ] * ( n ) NEW_LINE for _ in range ( m ) : NEW_LINE INDENT graph [ graph [ u ] ] = True NEW_LINE graph [ u ] = True NEW_LINE DEDENT for _ in range ( n ) : NEW_LINE INDENT u , v = map ( int , input ( ) . split ( ) ) NEW_LINE graph [ u , u ] = True NEW_LINE graph [ u ] = [ v ] NEW_LINE graph [ u ] . append ( ( v ) ) NEW_LINE DEDENT for u in graph [ u ] : NEW_LINE INDENT graph [ u ] . add ( v ) NEW_LINE DEDENT DEDENT for u in graph [ u ] : NEW_LINE INDENT graph [ u ] = False NEW_LINE DEDENT DEDENT"],"references":["N , M = ( int ( _ ) for _ in input ( ) . split ( ) ) NEW_LINE E = [ ] NEW_LINE V = [ [ i + 1 , 0 ] for i in range ( N ) ] NEW_LINE searched_vertex = [ ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT u , v = ( int ( _ ) for _ in input ( ) . split ( ) ) NEW_LINE E . append ( [ u , v , True ] ) NEW_LINE DEDENT cnt_trees = 0 NEW_LINE def find_tree ( vertex ) : NEW_LINE INDENT flag = True NEW_LINE index , reached = vertex NEW_LINE if reached == 0 : NEW_LINE INDENT V [ index - 1 ] [ 1 ] = 1 NEW_LINE DEDENT searched_vertex . append ( index ) NEW_LINE while searched_vertex : NEW_LINE INDENT i = searched_vertex [ len ( searched_vertex ) - 1 ] NEW_LINE for edge_index in range ( len ( E ) ) : NEW_LINE INDENT u , v , unused = E [ edge_index ] NEW_LINE if unused : NEW_LINE INDENT if u == i : NEW_LINE INDENT E [ edge_index ] [ 2 ] = False NEW_LINE for ind in range ( len ( searched_vertex ) ) : NEW_LINE INDENT if v == searched_vertex [ ind ] : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT V [ v - 1 ] [ 1 ] = 1 NEW_LINE searched_vertex . append ( v ) NEW_LINE break NEW_LINE DEDENT DEDENT elif v == i : NEW_LINE INDENT E [ edge_index ] [ 2 ] = False NEW_LINE for ind in range ( len ( searched_vertex ) ) : NEW_LINE INDENT if u == searched_vertex [ ind ] : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT V [ u - 1 ] [ 1 ] = 1 NEW_LINE searched_vertex . append ( u ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT else : NEW_LINE INDENT searched_vertex . pop ( ) NEW_LINE DEDENT DEDENT return flag NEW_LINE DEDENT for index , reached in V : NEW_LINE INDENT if reached == 0 : NEW_LINE INDENT for j in range ( len ( E ) ) : NEW_LINE INDENT E [ j ] [ 2 ] = True NEW_LINE DEDENT if find_tree ( ( index , reached ) ) : NEW_LINE INDENT cnt_trees += 1 NEW_LINE DEDENT DEDENT DEDENT print ( cnt_trees ) NEW_LINE"],"bleu":0.08197242761175269,"rouge_l":0.32275132275132273}
{"id":47,"predictions":["R , G = map ( int , input ( ) . split ( ) ) NEW_LINE print ( G + ( G - R ) ) NEW_LINE"],"references":["R = int ( input ( ) ) NEW_LINE G = int ( input ( ) ) NEW_LINE print ( 2 * G - R ) NEW_LINE"],"bleu":0.3948821678356559,"rouge_l":0.6202153110047847}
{"id":48,"predictions":["a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( a * b ) NEW_LINE"],"references":["a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( a - 1 ) * ( b - 1 ) ) NEW_LINE"],"bleu":0.6111248073490417,"rouge_l":0.8356164383561644}
{"id":49,"predictions":["H , W = map ( int , input ( ) . split ( ) ) NEW_LINE s = [ ] NEW_LINE for i in range ( H ) : NEW_LINE INDENT s . append ( input ( ) ) NEW_LINE DEDENT for i in range ( H ) : NEW_LINE INDENT print ( * s ) NEW_LINE DEDENT"],"references":["import sys , re NEW_LINE from collections import deque , defaultdict , Counter NEW_LINE from math import ceil , sqrt , hypot , factorial , pi , sin , cos , radians NEW_LINE from itertools import permutations , combinations , product NEW_LINE from operator import itemgetter , mul NEW_LINE from copy import deepcopy NEW_LINE from string import ascii_lowercase , ascii_uppercase , digits NEW_LINE def input ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def INT ( ) : return int ( input ( ) ) NEW_LINE def MAP ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE INF = float ( ' inf ' ) NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE H , W = MAP ( ) NEW_LINE C = [ input ( ) for _ in range ( H ) ] NEW_LINE for x in C : NEW_LINE INDENT print ( x ) NEW_LINE print ( x ) NEW_LINE DEDENT"],"bleu":0.04627727790937647,"rouge_l":0.2650051446210129}
{"id":50,"predictions":["N = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( len ( a ) ) NEW_LINE"],"references":["print ( len ( set ( [ input ( ) for _ in range ( int ( input ( ) ) ) ] ) ) ) NEW_LINE"],"bleu":0.35914388712415696,"rouge_l":0.49539794260963715}
{"id":51,"predictions":["s = input ( ) NEW_LINE n = int ( input ( ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == \"0\" : NEW_LINE INDENT ans += 10 - int ( i ) ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["n = int ( input ( ) ) NEW_LINE print ( 111 + 999 - n ) NEW_LINE"],"bleu":0.1676260321393691,"rouge_l":0.37352802637776733}
{"id":52,"predictions":["def gcd ( a , b ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x , y , x , y = map ( int , input ( ) . split ( ) ) NEW_LINE a , b = map ( int , input ( ) . split ( ) ) NEW_LINE x = max ( a ) NEW_LINE y \/\/= gcd ( x , y ) NEW_LINE if a % b == 0 : NEW_LINE INDENT print ( \" Impossible \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Impossible \" ) NEW_LINE DEDENT DEDENT"],"references":["import sys NEW_LINE from collections import defaultdict , Counter NEW_LINE from itertools import product , groupby , count , permutations , combinations NEW_LINE from math import pi , sqrt , ceil , floor NEW_LINE from collections import deque NEW_LINE from bisect import bisect , bisect_left , bisect_right NEW_LINE from string import ascii_lowercase NEW_LINE INF = float ( \" inf \" ) NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE dy = [ 0 , - 1 , 0 , 1 ] NEW_LINE dx = [ 1 , 0 , - 1 , 0 ] NEW_LINE def inside ( y : int , x : int , H : int , W : int ) -> bool : return 0 <= y < H and 0 <= x < W NEW_LINE def main ( ) : NEW_LINE INDENT X , Y = map ( int , input ( ) . split ( \" \/ \" ) ) NEW_LINE ans_list = [ ] NEW_LINE for n in range ( max ( 0 , 2 * X \/\/ Y - 10 ) , 2 * X \/\/ Y + 10 ) : NEW_LINE INDENT a = n * ( Y + n * Y - 2 * X ) NEW_LINE if a % ( 2 * Y ) == 0 : NEW_LINE INDENT m = a \/\/ ( 2 * Y ) NEW_LINE if 0 < m <= n : NEW_LINE INDENT ans_list . append ( \" { 0 } ▁ { 1 } \" . format ( n , m ) ) NEW_LINE DEDENT DEDENT DEDENT if ans_list : NEW_LINE INDENT print ( * ans_list , sep = \" \\n \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Impossible \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"bleu":0.11509289525439194,"rouge_l":0.29316855475454856}
{"id":53,"predictions":["n , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr = str ( i ) NEW_LINE ans += ( i * 10 ) NEW_LINE DEDENT print ( ans ) NEW_LINE"],"references":["N , A , B = map ( int , input ( ) . split ( \" ▁ \" ) ) NEW_LINE total = 0 NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT sum = 0 NEW_LINE temp = i NEW_LINE for m in range ( 5 ) : NEW_LINE INDENT sum += temp % 10 NEW_LINE temp = temp \/\/ 10 NEW_LINE DEDENT if A <= sum and sum <= B : NEW_LINE INDENT total += i NEW_LINE DEDENT DEDENT print ( total ) NEW_LINE"],"bleu":0.2289060693512326,"rouge_l":0.527453523562473}
{"id":54,"predictions":["s = input ( ) NEW_LINE a , b , c = 0 , 0 , 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if i == a or i == b : NEW_LINE INDENT print ( ' ' . join ( i ) ) NEW_LINE DEDENT elif b == b : NEW_LINE INDENT print ( ' ' ) NEW_LINE DEDENT DEDENT"],"references":["s = input ( ) NEW_LINE a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE print ( s [ 0 : a ] + ' \" ' + s [ a : b ] + ' \" ' + s [ b : c ] + ' \" ' + s [ c : d ] + ' \" ' + s [ d : ] ) NEW_LINE"],"bleu":0.19925953707712427,"rouge_l":0.3841476655808903}
{"id":55,"predictions":["n = int ( input ( ) ) NEW_LINE print ( ' Yes ' ) NEW_LINE"],"references":["N = int ( input ( ) ) NEW_LINE for cake in range ( 26 ) : NEW_LINE INDENT flag = False NEW_LINE for donut in range ( 15 ) : NEW_LINE INDENT if 4 * cake + 7 * donut == N : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE flag = True NEW_LINE break NEW_LINE DEDENT DEDENT if flag : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT"],"bleu":0.013387378075427472,"rouge_l":0.2729713603818616}
{"id":56,"predictions":["x , a , b = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE if b <= a or b <= a : NEW_LINE INDENT print \" safe \" zero \" NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" negative \" ) NEW_LINE DEDENT"],"references":["x , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if 0 < b - a <= x : print ( \" safe \" ) NEW_LINE else : print ( \" ddealnigceiroouuss \" [ b - a > x : : 2 ] ) NEW_LINE"],"bleu":0.3214172941767577,"rouge_l":0.6111111111111113}
{"id":57,"predictions":["n , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if ( ( b - a ) % 2 == 0 ) : NEW_LINE INDENT print ( ' Alice ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' B ' ) NEW_LINE DEDENT"],"references":["n , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if ( ( b - a ) % 2 == 0 ) : NEW_LINE INDENT print ( \" Alice \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Borys \" ) NEW_LINE DEDENT"],"bleu":0.8337870682658852,"rouge_l":0.9074074074074074}
{"id":58,"predictions":["s = \" abcdefghijklmnopqrstuvwxyz \" NEW_LINE a = \" abcdef \" NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT a [ i ] = \" \" NEW_LINE DEDENT for j in range ( len ( a ) ) : NEW_LINE INDENT if a [ j ] == \" None : NEW_LINE INDENT a [ j ] = a [ j ] NEW_LINE DEDENT DEDENT for i in range ( len ( a ) ) : NEW_LINE INDENT a [ i ] = \"1\" NEW_LINE DEDENT for j in range ( a ) : NEW_LINE INDENT if a [ j ] == a [ j ] : NEW_LINE INDENT print ( a [ j ] ) NEW_LINE DEDENT DEDENT DEDENT"],"references":["S = str ( input ( ) ) NEW_LINE ascii_letters = \" abcdefghijklmnopqrstuvwxyz \" NEW_LINE for letter in ascii_letters : NEW_LINE INDENT if letter not in S : NEW_LINE INDENT print ( letter ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT print ( \" None \" ) NEW_LINE"],"bleu":0.12353401027773175,"rouge_l":0.3645167937358335}
{"id":59,"predictions":["N = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( ' Yes ' ) NEW_LINE"],"references":["N = int ( input ( ) ) NEW_LINE L = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE L . sort ( reverse = 1 ) NEW_LINE length = 0 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT length += L [ i ] NEW_LINE DEDENT if L [ 0 ] < length : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.14621904395955942,"rouge_l":0.46234718826405874}
{"id":60,"predictions":["n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = [ ] NEW_LINE for i in range ( 1 , n - 1000 ) : NEW_LINE INDENT ans += l [ i ] NEW_LINE DEDENT print ( len ( ans ) ) NEW_LINE"],"references":["n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( max ( 1 , n - 200 ) , n ) : NEW_LINE INDENT if i + sum ( [ int ( x ) for x in list ( str ( i ) ) ] ) == n : NEW_LINE INDENT a . append ( i ) NEW_LINE DEDENT DEDENT print ( len ( a ) ) NEW_LINE for x in a : NEW_LINE INDENT print ( x ) NEW_LINE DEDENT"],"bleu":0.3060590169355905,"rouge_l":0.4839248434237995}
{"id":61,"predictions":["n = int ( input ( ) ) NEW_LINE for _ in range ( n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE a = abs ( a ) NEW_LINE b = abs ( abs ( a - b ) ) + 1 NEW_LINE DEDENT print ( c ) NEW_LINE"],"references":["N = int ( input ( ) ) NEW_LINE lr = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( N ) ] NEW_LINE print ( sum ( list ( zip ( * lr ) ) [ 1 ] ) - sum ( list ( zip ( * lr ) ) [ 0 ] ) + N ) NEW_LINE"],"bleu":0.32326812909449204,"rouge_l":0.4725248123940934}
{"id":62,"predictions":["n = int ( input ( ) ) NEW_LINE S = [ input ( ) for _ in range ( n ) ] NEW_LINE S = [ input ( ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT S [ i ] = S [ i - 1 ] + S [ i - 1 ] + S [ i - 1 ] ] NEW_LINE DEDENT print ( - 1 ) NEW_LINE DEDENT"],"references":["n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE s = list ( map ( lambda x : 1 if x == \" o \" else - 1 , list ( s ) ) ) NEW_LINE flag = False NEW_LINE for start in [ [ 1 , 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] , [ - 1 , - 1 ] ] : NEW_LINE INDENT circle = start + [ 0 ] * ( n - 2 ) NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT circle [ i + 1 ] = circle [ i ] * s [ i ] * circle [ i - 1 ] NEW_LINE DEDENT if circle [ - 2 ] == circle [ - 1 ] * s [ - 1 ] * circle [ 0 ] and circle [ - 1 ] == circle [ 0 ] * s [ 0 ] * circle [ 1 ] : NEW_LINE INDENT flag = True NEW_LINE break NEW_LINE DEDENT DEDENT if flag : NEW_LINE INDENT ans = \" \" NEW_LINE for i in circle : NEW_LINE INDENT if i == 1 : NEW_LINE INDENT ans += \" S \" NEW_LINE DEDENT else : NEW_LINE INDENT ans += \" W \" NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT"],"bleu":0.0495828920571757,"rouge_l":0.3305170355404537}
{"id":63,"predictions":["m , d = map ( int , input ( ) . split ( ) ) NEW_LINE if m % d == 0 : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"],"references":["print ( \" YNEOS \" [ eval ( input ( ) . replace ( ' ▁ ' , ' % ' ) ) > 0 : : 2 ] ) NEW_LINE"],"bleu":0.1354286043990683,"rouge_l":0.3499558693733451}
{"id":64,"predictions":["import sys NEW_LINE N = int ( input ( ) ) NEW_LINE dp = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] NEW_LINE dp [ 0 ] [ 1 ] = 1 NEW_LINE dp [ 1 ] = 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT dp [ i ] = 1 NEW_LINE DEDENT for i in range ( N - 1 ) : NEW_LINE INDENT dp [ i ] [ i ] = 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( reverse = True ) NEW_LINE b . sort ( reverse = True ) NEW_LINE if a [ i ] : NEW_LINE INDENT b . append ( a [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( b ) NEW_LINE DEDENT DEDENT DEDENT"],"references":["from bisect import bisect NEW_LINE n = int ( input ( ) ) NEW_LINE d = [ int ( input ( ) ) for i in range ( n ) ] NEW_LINE a , d , mod , ans = [ ] , sorted ( d ) , 10 ** 9 + 7 , 0 NEW_LINE for i in range ( n ) : a . append ( n - bisect ( d , d [ i ] * 2 - 1 ) ) NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : a [ i ] += a [ i + 1 ] NEW_LINE for i in range ( n ) : ans = ( ans + bisect ( d , d [ i ] \/\/ 2 ) * a [ min ( n - 1 , bisect ( d , d [ i ] * 2 - 1 ) ) ] ) % mod NEW_LINE print ( ans ) NEW_LINE"],"bleu":0.23553423397307977,"rouge_l":0.4357142857142857}
{"id":65,"predictions":["N = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE A . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if A [ A [ i ] ] % 2 != A [ i ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["import bisect NEW_LINE n = int ( input ( ) ) NEW_LINE l = [ ] NEW_LINE e = [ ] NEW_LINE for i in range ( n \/\/ 2 ) : NEW_LINE INDENT j = int ( input ( ) ) NEW_LINE e . append ( j ) NEW_LINE l . append ( j ) NEW_LINE j = int ( input ( ) ) NEW_LINE l . append ( j ) NEW_LINE DEDENT if n % 2 == 1 : NEW_LINE INDENT j = int ( input ( ) ) NEW_LINE e . append ( j ) NEW_LINE l . append ( j ) NEW_LINE DEDENT l . sort ( ) NEW_LINE e . sort ( ) NEW_LINE res = 0 NEW_LINE for i in range ( 0 , n , 2 ) : NEW_LINE INDENT if e [ min ( len ( e ) - 1 , bisect . bisect_left ( e , l [ i ] ) ) ] != l [ i ] : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE"],"bleu":0.12485038591529288,"rouge_l":0.4348859315589353}
{"id":66,"predictions":["n , l = map ( int , input ( ) . split ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE r = min ( l ) NEW_LINE l . sort ( ) NEW_LINE r = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if l [ i ] >= l [ i ] : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT r += l [ i ] NEW_LINE DEDENT DEDENT print ( r ) NEW_LINE"],"references":["import sys NEW_LINE from operator import itemgetter NEW_LINE N = int ( input ( ) ) NEW_LINE sorted_l = sorted ( ( tuple ( map ( int , l . split ( ) ) ) for l in sys . stdin ) , reverse = True ) NEW_LINE sorted_r = sorted ( sorted_l , key = itemgetter ( 1 ) ) NEW_LINE pos1 , ans1 = 0 , 0 NEW_LINE pos2 , ans2 = 0 , 0 NEW_LINE for i , j in enumerate ( i \/\/ 2 for i in range ( N ) ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT dist1 , dist2 = max ( sorted_l [ j ] [ 0 ] - pos1 , 0 ) , max ( pos2 - sorted_r [ j ] [ 1 ] , 0 ) NEW_LINE pos1 , ans1 = pos1 + dist1 , ans1 + dist1 NEW_LINE pos2 , ans2 = pos2 - dist2 , ans2 + dist2 NEW_LINE DEDENT else : NEW_LINE INDENT dist1 , dist2 = max ( pos1 - sorted_r [ j ] [ 1 ] , 0 ) , max ( sorted_l [ j ] [ 0 ] - pos2 , 0 ) NEW_LINE pos1 , ans1 = pos1 - dist1 , ans1 + dist1 NEW_LINE pos2 , ans2 = pos2 + dist2 , ans2 + dist2 NEW_LINE DEDENT DEDENT print ( max ( ans1 + abs ( pos1 ) , ans2 + abs ( pos2 ) ) ) NEW_LINE"],"bleu":0.07420704125927828,"rouge_l":0.3093739069604757}
{"id":67,"predictions":["n , a , b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( b , a , b ) NEW_LINE"],"references":["n , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE s = [ int ( input ( ) ) for i in range ( n ) ] NEW_LINE d = max ( s ) - min ( s ) NEW_LINE if d != 0 : NEW_LINE INDENT print ( b \/ d , a - ( sum ( s ) \/ n ) * ( b \/ d ) ) NEW_LINE DEDENT else : NEW_LINE INDENT if b != 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 , a - s [ 0 ] ) NEW_LINE DEDENT DEDENT"],"bleu":0.17937540955580852,"rouge_l":0.45591982333956177}
{"id":68,"predictions":["n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE a . sort ( ) NEW_LINE now = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == 0 : NEW_LINE INDENT now += 1 NEW_LINE DEDENT else : NEW_LINE INDENT now = a [ i ] NEW_LINE now = a [ i ] NEW_LINE nowB = a [ i ] NEW_LINE nowA = a [ i ] NEW_LINE nowA = b [ i ] NEW_LINE nowB = a [ i ] NEW_LINE DEDENT DEDENT for i in range ( n - now ) : NEW_LINE INDENT if a [ i ] == i : NEW_LINE INDENT now = a [ i ] NEW_LINE nowA = a [ i ] NEW_LINE nowA = a [ i ] NEW_LINE nowB = nowB [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT if a [ i ] == i : NEW_LINE INDENT nowA = a [ i ] NEW_LINE nowB = nowA [ i ] NEW_LINE nowB = nowA NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["n = int ( input ( ) ) NEW_LINE k = 1000000 NEW_LINE nums = [ 0 for _ in range ( k + 2 ) ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE nums [ a ] += 1 NEW_LINE nums [ b + 1 ] -= 1 NEW_LINE DEDENT for i in range ( 1 , k + 1 ) : NEW_LINE INDENT nums [ i ] += nums [ i - 1 ] NEW_LINE DEDENT print ( max ( nums ) ) NEW_LINE"],"bleu":0.19633128735989364,"rouge_l":0.3926348000422074}
{"id":69,"predictions":["x , y , s = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE s = ' L ' NEW_LINE s = ' L ' NEW_LINE count = 0 NEW_LINE for i in range ( 9 ) : NEW_LINE INDENT if s == ' L ' : NEW_LINE INDENT count = 1 NEW_LINE DEDENT elif s == ' L ' : NEW_LINE INDENT if s == ' L ' : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT elif s == ' L ' : NEW_LINE INDENT count = 0 NEW_LINE DEDENT elif s == ' L ' : NEW_LINE INDENT count = 1 NEW_LINE DEDENT elif s == ' L ' : NEW_LINE INDENT count = 0 NEW_LINE DEDENT elif s == ' L ' : NEW_LINE INDENT count = 0 NEW_LINE DEDENT elif s == ' L ' : NEW_LINE INDENT count = 1 NEW_LINE DEDENT if count == 1 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT elif s == 1 : NEW_LINE INDENT if count == 1 : NEW_LINE INDENT break NEW_LINE DEDENT if count == 1 : NEW_LINE INDENT x = 1 NEW_LINE DEDENT elif count == 1 : NEW_LINE INDENT if x == 1 : NEW_LINE INDENT y = 1 NEW_LINE DEDENT elif x == 1 : NEW_LINE INDENT y = 1 NEW_LINE DEDENT elif x == 1 : NEW_LINE INDENT y = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT x = ( x + y ) NEW_LINE DEDENT DEDENT if x == 1 : NEW_LINE INDENT y = y - 1 NEW_LINE DEDENT elif x == 1 : NEW_LINE INDENT y = x + y - 1 NEW_LINE DEDENT elif x == 1 : NEW_LINE INDENT y = x - 1 NEW_LINE DEDENT elif x == 1 : NEW_LINE INDENT y = y - 1 NEW_LINE DEDENT DEDENT print ( \" DEDENT else : NEW_LINE INDENT print ("],"references":["x , y , w = input ( ) . split ( ) NEW_LINE x , y = int ( x ) + 7 , int ( y ) + 7 NEW_LINE A = [ input ( ) for i in range ( 9 ) ] NEW_LINE B = [ a [ 1 : ] [ : : - 1 ] + a + a [ : - 1 ] [ : : - 1 ] for a in A ] NEW_LINE C = B [ 1 : ] [ : : - 1 ] + B + B [ : - 1 ] [ : : - 1 ] NEW_LINE D = { ' R ' : ( 1 , 0 ) , ' L ' : ( - 1 , 0 ) , ' U ' : ( 0 , - 1 ) , ' D ' : ( 0 , 1 ) , ' RU ' : ( 1 , - 1 ) , ' RD ' : ( 1 , 1 ) , ' LU ' : ( - 1 , - 1 ) , ' LD ' : ( - 1 , 1 ) } NEW_LINE ans = C [ y ] [ x ] NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT dx , dy = D [ w ] NEW_LINE x += dx NEW_LINE y += dy NEW_LINE ans += C [ y ] [ x ] NEW_LINE DEDENT print ( ans ) NEW_LINE"],"bleu":0.1152592414574417,"rouge_l":0.3068694344859489}
{"id":70,"predictions":["n , k , p , k = map ( int , input ( ) . split ( ) ) NEW_LINE p = 1 + 3 * ( n - k ) * ( n - k ) NEW_LINE print ( p ) NEW_LINE"],"references":["N , K = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( ( K - 1 ) * ( N - K ) * 6 + ( N - 1 ) * 3 + 1 ) \/ N ** 3 ) NEW_LINE"],"bleu":0.37538502930445133,"rouge_l":0.5468965517241379}
{"id":71,"predictions":["from collections import Counter NEW_LINE x , y = map ( int , input ( ) . split ( ) ) NEW_LINE S = [ [ ] NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT S [ i ] [ j ] = \" o \" NEW_LINE DEDENT DEDENT for i in range ( 10 ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT if S [ i ] [ j ] == \" o \" : NEW_LINE INDENT s [ i ] [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 10 ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT if S [ i ] [ j ] == \" o \" : NEW_LINE INDENT s [ i ] [ j ] = \" x \" NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( 10 ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT if s [ i ] [ j ] == \" o \" : NEW_LINE INDENT s [ i ] = \" o \" NEW_LINE DEDENT DEDENT DEDENT for i in range ( 10 ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT if s [ i ] [ j ] == \" o \" : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT DEDENT"],"references":["H , W = ( 10 , 10 ) NEW_LINE field = [ list ( input ( ) ) for _ in range ( H ) ] NEW_LINE Around = [ [ 0 ] * W for _ in range ( H ) ] NEW_LINE cnt_islands = 0 NEW_LINE def dfs ( x , y ) : NEW_LINE INDENT if x < 0 or x >= W or y < 0 or y >= H or field [ y ] [ x ] == \" r \" : NEW_LINE INDENT return NEW_LINE DEDENT if field [ y ] [ x ] == \" x \" : NEW_LINE INDENT field [ y ] [ x ] = \" r \" NEW_LINE Around [ y ] [ x ] += 1 NEW_LINE return NEW_LINE DEDENT field [ y ] [ x ] = \" r \" NEW_LINE dfs ( x + 1 , y ) NEW_LINE dfs ( x - 1 , y ) NEW_LINE dfs ( x , y + 1 ) NEW_LINE dfs ( x , y - 1 ) NEW_LINE DEDENT for y in range ( H ) : NEW_LINE INDENT for x in range ( W ) : NEW_LINE INDENT if field [ y ] [ x ] == \" o \" : NEW_LINE INDENT for yr in range ( H ) : NEW_LINE INDENT for xr in range ( W ) : NEW_LINE INDENT if field [ yr ] [ xr ] == \" r \" : NEW_LINE INDENT field [ yr ] [ xr ] = \" x \" NEW_LINE DEDENT DEDENT DEDENT dfs ( x , y ) NEW_LINE cnt_islands += 1 NEW_LINE DEDENT DEDENT DEDENT if cnt_islands == 1 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT f = False NEW_LINE for y in range ( H ) : NEW_LINE INDENT for x in range ( W ) : NEW_LINE INDENT if Around [ y ] [ x ] == cnt_islands : NEW_LINE INDENT f = True NEW_LINE print ( ' YES ' ) NEW_LINE break NEW_LINE DEDENT DEDENT if f : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if not f : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT"],"bleu":0.23398021615049938,"rouge_l":0.4865253145744576}
{"id":72,"predictions":["s = input ( ) NEW_LINE n = len ( s ) NEW_LINE if len ( s ) % 2 == 0 : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT"],"references":["import collections NEW_LINE letter = collections . Counter ( input ( ) ) NEW_LINE counter = 0 NEW_LINE for v in letter . values ( ) : NEW_LINE INDENT if v % 2 == 1 : NEW_LINE INDENT counter += 1 NEW_LINE break NEW_LINE DEDENT DEDENT print ( \" Yes \" ) if counter == 0 else print ( \" No \" ) NEW_LINE"],"bleu":0.2640339737006289,"rouge_l":0.4981044036162146}
{"id":73,"predictions":["n , n , n = map ( int , input ( ) . split ( ) ) NEW_LINE x2 = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] NEW_LINE y2 = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT x2 , y2 = map ( int , input ( ) . split ( ) ) NEW_LINE x2 , y2 , x2 , y2 , x2 , y3 = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE x2 , y2 , x2 , y3 = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE y2 , x2 , y3 , x2 , y3 , x2 , y2 , x2 , y3 = max ( x1 , y2 ) + ( y2 , y2 ) NEW_LINE DEDENT DEDENT ans = max ( ans , y2 ) NEW_LINE print ( ans ) NEW_LINE"],"references":["L , N = map ( int , input ( ) . split ( ) ) NEW_LINE X = [ 0 ] NEW_LINE for _ in range ( N ) : NEW_LINE INDENT X . append ( int ( input ( ) ) ) NEW_LINE DEDENT s = [ 0 ] * ( N + 1 ) NEW_LINE t = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT s [ i ] = s [ i - 1 ] + X [ i ] NEW_LINE t [ i ] = t [ i - 1 ] + ( L - X [ N - i + 1 ] ) NEW_LINE DEDENT Y = [ 0 ] + [ L - X [ N - i ] for i in range ( N ) ] NEW_LINE def get_d ( s , x , i ) : NEW_LINE INDENT if i == N : NEW_LINE INDENT return x [ N ] NEW_LINE DEDENT a = i + ( N - i ) \/\/ 2 NEW_LINE return ( 2 * ( s [ a ] - s [ i - 1 ] + L * ( N - a ) - s [ N ] + s [ a ] ) - ( x [ a ] if ( N - i ) % 2 == 0 else ( L - x [ a + 1 ] ) ) ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT ans = max ( ans , get_d ( s , X , i ) , get_d ( t , Y , i ) ) NEW_LINE DEDENT print ( ans ) NEW_LINE"],"bleu":0.15474469434342475,"rouge_l":0.3323313920721398}
{"id":74,"predictions":["N = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE A . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if A [ i ] != A [ i ] : NEW_LINE INDENT ans += A [ i ] * 2 - A [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["from collections import Counter NEW_LINE input ( ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE A . sort ( reverse = True ) NEW_LINE C = Counter ( A ) NEW_LINE ans = 0 NEW_LINE for a in A : NEW_LINE INDENT if not C [ a ] : NEW_LINE INDENT continue NEW_LINE DEDENT C [ a ] -= 1 NEW_LINE t = 2 ** a . bit_length ( ) - a NEW_LINE if C [ t ] : NEW_LINE INDENT C [ t ] -= 1 NEW_LINE ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"bleu":0.4411440457677628,"rouge_l":0.6152737752161382}
{"id":75,"predictions":["N , C = map ( int , input ( ) . split ( ) ) NEW_LINE P = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] NEW_LINE P = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] NEW_LINE dp [ - 1 ] = [ 0 ] * N NEW_LINE dp [ - 1 ] = 0 NEW_LINE dp [ - 1 ] = 0 NEW_LINE dp [ - 1 ] = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT dp [ i + 1 ] += dp [ i + 1 ] NEW_LINE dp [ i + 1 ] -= dp [ i ] NEW_LINE dp [ i ] += dp [ i ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT ans = max ( ans , dp [ i + 1 ] ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["N , C = [ int ( _ ) for _ in input ( ) . split ( ) ] NEW_LINE X = [ 0 ] * N NEW_LINE V = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT X [ i ] , V [ i ] = [ int ( _ ) for _ in input ( ) . split ( ) ] NEW_LINE DEDENT def calc ( X , V ) : NEW_LINE INDENT Vcumsum = [ 0 ] NEW_LINE for v in V : NEW_LINE INDENT Vcumsum += [ Vcumsum [ - 1 ] + v ] NEW_LINE DEDENT cumsum = [ 0 ] * ( N + 1 ) NEW_LINE cumsum_r = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT cumsum [ i + 1 ] = Vcumsum [ i + 1 ] - X [ i ] NEW_LINE cumsum_r [ i + 1 ] = Vcumsum [ N ] - Vcumsum [ N - i - 1 ] - ( C - X [ - 1 - i ] ) NEW_LINE DEDENT cumsum_max = [ 0 ] * ( N + 1 ) NEW_LINE cumsum_r_max = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT cumsum_max [ i + 1 ] = max ( cumsum [ i + 1 ] , cumsum_max [ i ] ) NEW_LINE cumsum_r_max [ i + 1 ] = max ( cumsum_r [ i + 1 ] , cumsum_r_max [ i ] ) NEW_LINE DEDENT res = max ( cumsum_max [ - 1 ] , cumsum_r_max [ - 1 ] ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT res = max ( res , cumsum_max [ i + 1 ] + cumsum_r_max [ N - i - 1 ] - X [ i ] , cumsum_r_max [ i + 1 ] + cumsum_max [ N - i - 1 ] - ( C - X [ - 1 - i ] ) ) NEW_LINE DEDENT return res NEW_LINE DEDENT print ( calc ( X , V ) ) NEW_LINE"],"bleu":0.18649229883022458,"rouge_l":0.42507544581618656}
{"id":76,"predictions":["A , B = map ( int , input ( ) . split ( ) ) NEW_LINE print ( A - 1 ) NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( n - 1 ) * ( m - 1 ) ) NEW_LINE"],"bleu":0.5339687067321418,"rouge_l":0.7311643835616437}
{"id":77,"predictions":["n , m = map ( int , input ( ) . split ( ) ) NEW_LINE dp = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT a , b = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE dp [ a ] [ b ] = min ( a , b ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE ans = min ( ans , b , c ) NEW_LINE DEDENT if ans == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT DEDENT"],"references":["NM = 40 NEW_LINE ABM = 10 NEW_LINE MM = 400 NEW_LINE N , M1 , M2 = map ( int , input ( ) . split ( ) ) NEW_LINE A = [ ] NEW_LINE B = [ ] NEW_LINE C = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE A . append ( a ) NEW_LINE B . append ( b ) NEW_LINE C . append ( c ) NEW_LINE DEDENT cmax = max ( C ) NEW_LINE CM = N * cmax + 10 NEW_LINE dp = [ [ [ CM for broop in range ( 401 ) ] for aroop in range ( 401 ) ] for nroop in range ( N + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] [ 0 ] = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for cb in range ( 401 ) : NEW_LINE INDENT for ca in range ( 401 ) : NEW_LINE INDENT if dp [ i ] [ ca ] [ cb ] == CM : NEW_LINE INDENT continue NEW_LINE DEDENT dp [ i + 1 ] [ ca ] [ cb ] = min ( dp [ i + 1 ] [ ca ] [ cb ] , dp [ i ] [ ca ] [ cb ] ) NEW_LINE if ca + A [ i ] < 401 and cb + B [ i ] < 401 : NEW_LINE INDENT dp [ i + 1 ] [ ca + A [ i ] ] [ cb + B [ i ] ] = min ( dp [ i + 1 ] [ ca + A [ i ] ] [ cb + B [ i ] ] , dp [ i ] [ ca ] [ cb ] + C [ i ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = CM NEW_LINE for cb in range ( 400 ) : NEW_LINE INDENT for ca in range ( 400 ) : NEW_LINE INDENT CB = cb + 1 NEW_LINE CA = ca + 1 NEW_LINE if CA * M2 == CB * M1 : NEW_LINE INDENT ans = min ( ans , dp [ N ] [ CA ] [ CB ] ) NEW_LINE DEDENT DEDENT DEDENT if ans == CM : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT"],"bleu":0.07813197669990245,"rouge_l":0.3265143886798452}
{"id":78,"predictions":["a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if b == 100 : NEW_LINE INDENT print ( 100 * a ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( b * a ) NEW_LINE DEDENT"],"references":["D , N = map ( int , input ( ) . split ( ) ) NEW_LINE count = 0 NEW_LINE x = 0 NEW_LINE while count != N : NEW_LINE INDENT x += 1 NEW_LINE if x % 100 ** D == 0 and x % 100 ** ( D + 1 ) != 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( x ) NEW_LINE"],"bleu":0.24573471631547897,"rouge_l":0.4549723756906077}
{"id":79,"predictions":["n = int ( input ( ) ) NEW_LINE print ( n \/\/ 3 ) NEW_LINE"],"references":["print ( int ( input ( ) ) \/\/ 3 ) NEW_LINE"],"bleu":0.5312583871630396,"rouge_l":0.7331730769230769}
{"id":80,"predictions":["N = input ( ) NEW_LINE print ( ' A ' + N [ 0 ] + ' C ' ) NEW_LINE"],"references":["print ( \" A \" + input ( ) [ 8 ] + \" C \" ) NEW_LINE"],"bleu":0.1676784955078518,"rouge_l":0.5091819699499166}
{"id":81,"predictions":["S = input ( ) NEW_LINE if S [ - 1 ] == ' T ' : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT"],"references":["s = input ( ) NEW_LINE if ( s [ - 1 ] == \" T \" ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"],"bleu":0.5248216260885701,"rouge_l":0.7715218278253773}
{"id":82,"predictions":["n = int ( input ( ) ) NEW_LINE a = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == a : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if a [ i ] == a [ i - 1 ] : NEW_LINE INDENT ans += 1 NEW_LINE a [ i ] = ' x ' NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"bleu":0.5061449750900813,"rouge_l":0.6917080085046067}
{"id":83,"predictions":["N , X , Y = map ( int , input ( ) . split ( ) ) NEW_LINE S = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( N ) ] NEW_LINE C = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT S [ i ] = X * i + 5 * ( N - i ) NEW_LINE S [ i ] = X [ N ] + 5 * ( N - i ) NEW_LINE DEDENT DEDENT ans = X * N + 5 * N NEW_LINE print ( ans + X ) NEW_LINE"],"references":["iN , iX = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE aX = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE aCum = [ 0 ] * iN NEW_LINE aCum [ 0 ] = aX [ 0 ] NEW_LINE for i in range ( 1 , iN ) : NEW_LINE INDENT aCum [ i ] = aCum [ i - 1 ] + aX [ i ] NEW_LINE DEDENT def fCeil ( iT , iR ) : NEW_LINE INDENT return - 1 * iT \/\/ iR * - 1 NEW_LINE DEDENT def fCalcCost ( iN , iX , aCum , iK ) : NEW_LINE INDENT return ( iN + iK ) * iX + 5 * aCum [ - 1 ] + sum ( 2 * aCum [ - i * iK - 1 ] for i in range ( 2 , fCeil ( iN , iK ) ) ) NEW_LINE DEDENT iTotalCost = fCalcCost ( iN , iX , aCum , 1 ) NEW_LINE iULim = fCeil ( iN , 2 ) + 1 NEW_LINE for iK in range ( 2 , fCeil ( iN , 2 ) + 1 ) : NEW_LINE INDENT iThisCost = fCalcCost ( iN , iX , aCum , iK ) NEW_LINE if iThisCost > iTotalCost : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT iTotalCost = iThisCost NEW_LINE DEDENT DEDENT print ( iTotalCost ) NEW_LINE"],"bleu":0.13230755835845467,"rouge_l":0.3026326318316395}
{"id":84,"predictions":["a , b , h = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( a + b ) * h \/\/ 2 ) NEW_LINE"],"references":["a , b , h = map ( int , open ( 0 ) . read ( ) . split ( ) ) NEW_LINE S = int ( ( a + b ) * h \/ 2 ) NEW_LINE print ( S ) NEW_LINE"],"bleu":0.5476133090365939,"rouge_l":0.742030201342282}
{"id":85,"predictions":["n = int ( input ( ) ) NEW_LINE a = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] NEW_LINE a = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if a [ i ] [ j ] == \" o \" : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if a [ i ] [ j ] == \" o \" : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["field = [ ] NEW_LINE n = int ( input ( ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT field . append ( list ( map ( str , input ( ) ) ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ' . ' in field [ i ] : NEW_LINE INDENT j = n - field [ i ] [ : : - 1 ] . index ( ' . ' ) - 1 NEW_LINE field [ i ] = [ ' o ' ] * n NEW_LINE if i != n - 1 : NEW_LINE INDENT field [ i + 1 ] [ j : ] = [ ' O ' ] * len ( field [ i + 1 ] [ j : ] ) NEW_LINE DEDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"bleu":0.3913479141704588,"rouge_l":0.4649801148917366}
{"id":86,"predictions":["n , t = map ( int , input ( ) . split ( ) ) NEW_LINE t = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT t , t = map ( int , input ( ) . split ( ) ) NEW_LINE s . append ( t - t ) NEW_LINE DEDENT t = [ 0 ] * n NEW_LINE for _ in range ( t ) : NEW_LINE INDENT t . append ( input ( ) ) NEW_LINE s = [ 0 ] * n NEW_LINE s . append ( 0 ) NEW_LINE DEDENT t = 0 NEW_LINE for _ in range ( t ) : NEW_LINE INDENT t , t = map ( int , input ( ) . split ( ) ) NEW_LINE s = [ ] NEW_LINE s . append ( s ) NEW_LINE s . append ( t ) NEW_LINE DEDENT s = 0 NEW_LINE for _ in range ( t ) : NEW_LINE INDENT t = [ 0 ] * n NEW_LINE s = [ 0 ] * n NEW_LINE s [ 0 ] = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . append ( s [ i - 1 ] ) NEW_LINE DEDENT if s [ - 1 ] < t : NEW_LINE INDENT s . append ( ( s [ - 1 ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT s . append ( s [ i ] ) NEW_LINE DEDENT DEDENT DEDENT print ( len ( s ) ) NEW_LINE"],"references":["n = int ( input ( ) ) NEW_LINE t = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE v = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE maxspeed = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT maxspeed [ i ] = min ( v [ i ] , v [ i - 1 ] , t [ i ] + maxspeed [ i + 1 ] ) NEW_LINE DEDENT def dist ( i , first ) : NEW_LINE INDENT ta = v [ i ] - first NEW_LINE tb = v [ i ] - maxspeed [ i + 1 ] NEW_LINE if ta + tb <= t [ i ] : NEW_LINE INDENT c = ( first + v [ i ] ) * ta \/ 2 + v [ i ] * ( t [ i ] - ta - tb ) + ( maxspeed [ i + 1 ] + v [ i ] ) * tb \/ 2 NEW_LINE lastspeed = maxspeed [ i + 1 ] NEW_LINE DEDENT elif maxspeed [ i + 1 ] - first > t [ i ] : NEW_LINE INDENT c = ( first + first + t [ i ] ) * t [ i ] \/ 2 NEW_LINE lastspeed = first + t [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT a = ( maxspeed [ i + 1 ] + t [ i ] - first ) \/ 2 NEW_LINE c = ( first + first + a ) * a \/ 2 + ( first + a + maxspeed [ i + 1 ] ) * ( t [ i ] - a ) \/ 2 NEW_LINE lastspeed = maxspeed [ i + 1 ] NEW_LINE DEDENT return c , lastspeed NEW_LINE DEDENT ans = 0 NEW_LINE firstspeed = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT d , firstspeed = dist ( i , firstspeed ) NEW_LINE ans += d NEW_LINE DEDENT print ( ans ) NEW_LINE"],"bleu":0.18993313963741007,"rouge_l":0.34516305157095345}
{"id":87,"predictions":["n , m = map ( int , input ( ) . split ( ) ) NEW_LINE P = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] NEW_LINE R = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] NEW_LINE R = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] NEW_LINE R = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] NEW_LINE x , y = map ( int , input ( ) . split ( ) ) ) NEW_LINE R = [ 0 for _ in range ( n ) ] NEW_LINE r = list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] NEW_LINE r = [ 0 for _ in range ( n ) ] NEW_LINE r = [ 0 for _ in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT r [ r [ r ] -= a [ r ] NEW_LINE r [ r - 1 ] -= a [ r - 1 ] NEW_LINE DEDENT if r [ r - 1 ] != r : NEW_LINE INDENT r += a [ r - 1 ] NEW_LINE DEDENT DEDENT print ( r - min ( r ) ) NEW_LINE"],"references":["import itertools NEW_LINE N , M = map ( int , input ( ) . split ( ) ) NEW_LINE score = [ 0 ] * ( M + 1 ) NEW_LINE s_sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT l , r , s = map ( int , input ( ) . split ( ) ) NEW_LINE score [ ( l - 1 ) ] += s NEW_LINE score [ r ] += - s NEW_LINE s_sum += s NEW_LINE DEDENT score_list = list ( itertools . accumulate ( score ) ) NEW_LINE ans = s_sum - min ( score_list [ : - 1 ] ) NEW_LINE print ( ans ) NEW_LINE"],"bleu":0.1661015963314092,"rouge_l":0.3788819875776398}
{"id":88,"predictions":["D = \" \" NEW_LINE S = \" \" NEW_LINE if D in S : NEW_LINE INDENT print ( \" Chris ▁ Eve \" ) NEW_LINE DEDENT elif DEDENT"],"references":["D = int ( input ( ) ) NEW_LINE print ( \" Christmas \" + \" ▁ Eve \" * ( 25 - D ) ) NEW_LINE"],"bleu":0.14793378747473623,"rouge_l":0.3954036535061874}
{"id":89,"predictions":["n , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if n == b : NEW_LINE INDENT print ( \" Leap \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Leap \" ) NEW_LINE DEDENT DEDENT"],"references":["n , a , b = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE num = n % ( a + b ) NEW_LINE if num == 0 : NEW_LINE INDENT print ( \" Bug \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Ant \" if num <= a else \" Bug \" ) NEW_LINE DEDENT"],"bleu":0.4002041737043844,"rouge_l":0.6566381451835495}
{"id":90,"predictions":["n = int ( input ( ) ) NEW_LINE b = [ ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if b [ i ] == ' < ' : NEW_LINE INDENT print ( ' < ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' < ' ) NEW_LINE DEDENT DEDENT b = [ ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if b [ i ] == ' > ' : NEW_LINE INDENT print ( ' < ▁ ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' > ' ) NEW_LINE DEDENT DEDENT"],"references":["n = input ( ) NEW_LINE print ( n . replace ( \" Right \" , \" > \" ) . replace ( \" AtCoder \" , \" A \" ) . replace ( \" Left \" , \" < \" ) ) NEW_LINE"],"bleu":0.04402577002048975,"rouge_l":0.2392708814028611}
{"id":91,"predictions":["X = input ( ) NEW_LINE X1 = X [ 0 ] + X [ 2 ] + X [ 2 ] NEW_LINE if X [ 0 ] == X [ 2 ] : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT"],"references":["num = input ( ) NEW_LINE print ( \" Yes \" if num [ 0 ] == num [ 1 ] == num [ 2 ] or num [ 1 ] == num [ 2 ] == num [ 3 ] else \" No \" ) NEW_LINE"],"bleu":0.1907234869963593,"rouge_l":0.453751617076326}
{"id":92,"predictions":["N , K = map ( int , input ( ) . split ( ) ) NEW_LINE S = [ ] NEW_LINE for _ in range ( N ) : NEW_LINE INDENT S . append ( [ int ( input ( ) ) ) for _ in range ( N ) ] NEW_LINE DEDENT S = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT S . sort ( ) NEW_LINE S . sort ( ) NEW_LINE S . sort ( ) NEW_LINE res = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT res += S [ i ] [ j ] NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE"],"references":["def main ( ) : NEW_LINE INDENT from collections import Counter NEW_LINE n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for index , ( key , value ) in enumerate ( sorted ( Counter ( a ) . items ( ) , key = lambda x : x [ 1 ] , reverse = True ) , 1 ) : NEW_LINE INDENT if index > k : NEW_LINE INDENT ans += value NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"bleu":0.26535118701254473,"rouge_l":0.39973787680209705}
{"id":93,"predictions":["a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE print ( a * b , c * d ) NEW_LINE"],"references":["a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if a [ 0 ] * a [ 1 ] == a [ 2 ] * a [ 3 ] : NEW_LINE INDENT print ( a [ 0 ] * a [ 1 ] ) NEW_LINE DEDENT elif a [ 0 ] * a [ 1 ] > a [ 2 ] * a [ 3 ] : NEW_LINE INDENT print ( a [ 0 ] * a [ 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a [ 2 ] * a [ 3 ] ) NEW_LINE DEDENT"],"bleu":0.041050483474823415,"rouge_l":0.28193277310924375}
{"id":94,"predictions":["a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( b - a % b ) % b ) NEW_LINE"],"references":["a = int ( input ( ) ) NEW_LINE b = int ( input ( ) ) NEW_LINE print ( b - a % b if a % b != 0 else 0 ) NEW_LINE"],"bleu":0.37510744551933123,"rouge_l":0.6373134328358209}
{"id":95,"predictions":["print ( W - 1 , H - 1 ) NEW_LINE"],"references":["x , y = map ( int , input ( ) . split ( ) ) NEW_LINE x , y = x - 1 , y - 1 NEW_LINE mod = 1000000007 NEW_LINE c = 1 NEW_LINE for i in range ( min ( x , y ) ) : NEW_LINE INDENT c = ( c * ( x + y - i ) * pow ( i + 1 , mod - 2 , mod ) % mod ) NEW_LINE DEDENT print ( c % mod ) NEW_LINE"],"bleu":0.00026396631611211226,"rouge_l":0.1402701925840759}
{"id":96,"predictions":["n = int ( input ( ) ) NEW_LINE a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a % b == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if a % b == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if a % b == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return a \/ b NEW_LINE DEDENT DEDENT print ( \" Aoki \" ) NEW_LINE"],"references":["def extgcd ( a , b ) : NEW_LINE INDENT if b : NEW_LINE INDENT d , y , x = extgcd ( b , a % b ) NEW_LINE y -= ( a \/ b ) * x NEW_LINE return d , x , y NEW_LINE DEDENT else : NEW_LINE INDENT return a , 1 , 0 NEW_LINE DEDENT DEDENT N = int ( input ( ) ) NEW_LINE grundy = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT a , k = map ( int , input ( ) . split ( ) ) NEW_LINE while a % k : NEW_LINE INDENT p , q = divmod ( a , k ) NEW_LINE a -= ( p + 1 ) * ( ( q + p ) \/\/ ( p + 1 ) ) NEW_LINE DEDENT grundy ^= a \/\/ k NEW_LINE DEDENT print ( ' Takahashi ' if grundy else ' Aoki ' ) NEW_LINE"],"bleu":0.19055091807359945,"rouge_l":0.32401669406854683}
{"id":97,"predictions":["n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if a [ i ] [ j ] != a [ i ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["N , M = map ( int , input ( ) . split ( ) ) NEW_LINE py = [ ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT py . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE py [ i ] . append ( i ) NEW_LINE DEDENT py . sort ( key = lambda x : ( x [ 0 ] , x [ 1 ] ) ) NEW_LINE number = [ ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT ct = 1 NEW_LINE number . append ( ( str ( py [ i ] [ 0 ] ) . zfill ( 6 ) + str ( ct ) . zfill ( 6 ) , py [ i ] [ 2 ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT if py [ i - 1 ] [ 0 ] == py [ i ] [ 0 ] : NEW_LINE INDENT ct += 1 NEW_LINE number . append ( ( str ( py [ i ] [ 0 ] ) . zfill ( 6 ) + str ( ct ) . zfill ( 6 ) , py [ i ] [ 2 ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT ct = 1 NEW_LINE number . append ( ( str ( py [ i ] [ 0 ] ) . zfill ( 6 ) + str ( ct ) . zfill ( 6 ) , py [ i ] [ 2 ] ) ) NEW_LINE DEDENT DEDENT DEDENT number . sort ( key = lambda x : x [ 1 ] ) NEW_LINE for i in number : NEW_LINE INDENT print ( i [ 0 ] ) NEW_LINE DEDENT"],"bleu":0.05905889599366585,"rouge_l":0.3346678529062871}
{"id":98,"predictions":["n , K , q , q = map ( int , input ( ) . split ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE B = list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE B = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE A . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT A [ i ] = A [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT A . append ( A [ i ] ) NEW_LINE DEDENT DEDENT B = sorted ( A ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT A . append ( A [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if A [ i ] > B [ i ] : NEW_LINE INDENT A . append ( A [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT A [ i ] = A [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if A [ i ] > B [ i ] : NEW_LINE INDENT A . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT A . append ( A [ i ] ) NEW_LINE DEDENT DEDENT DEDENT print ( solve ( ) ) NEW_LINE"],"references":["N , K , Q = map ( int , input ( ) . split ( ) ) NEW_LINE As = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 10 ** 9 NEW_LINE for Y in sorted ( As ) [ : N - Q - K + 2 ] : NEW_LINE INDENT cands = [ ] NEW_LINE cs = [ ] NEW_LINE for A in As + [ 0 ] : NEW_LINE INDENT if A < Y : NEW_LINE INDENT if len ( cs ) >= K : NEW_LINE INDENT cands += sorted ( cs ) [ : len ( cs ) - K + 1 ] NEW_LINE DEDENT cs = [ ] NEW_LINE DEDENT else : NEW_LINE INDENT cs += [ A ] NEW_LINE DEDENT DEDENT if len ( cands ) < Q : continue NEW_LINE X = sorted ( cands ) [ Q - 1 ] NEW_LINE ans = min ( ans , X - Y ) NEW_LINE DEDENT print ( ans ) NEW_LINE"],"bleu":0.20659210697993322,"rouge_l":0.42989282043752747}
{"id":99,"predictions":["a = int ( input ( ) ) NEW_LINE b = int ( input ( ) ) NEW_LINE print ( a , b ) NEW_LINE"],"references":["a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( b , a ) NEW_LINE"],"bleu":0.3699382260470039,"rouge_l":0.6145063801208865}
{"id":100,"predictions":["n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE ans = [ ' A ' , ' B ' , ' B ' , ' L ' ] NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if s [ i ] == s [ j ] : NEW_LINE INDENT continue NEW_LINE DEDENT ans += s [ i ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["from itertools import product NEW_LINE import re NEW_LINE def inpl ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE N = int ( input ( ) ) NEW_LINE C = input ( ) NEW_LINE ans = 2000 NEW_LINE for X in product ( \" ABXY \" , repeat = 4 ) : NEW_LINE INDENT L = \" \" . join ( X [ : 2 ] ) NEW_LINE R = \" \" . join ( X [ 2 : ] ) NEW_LINE ans = min ( ans , len ( C . replace ( L , \" L \" ) . replace ( R , \" R \" ) ) ) NEW_LINE DEDENT print ( ans ) NEW_LINE"],"bleu":0.17648455729914558,"rouge_l":0.3285776677827923}
{"id":101,"predictions":["n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT ans += a [ i ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["N = int ( input ( ) ) NEW_LINE A = sorted ( [ int ( i ) for i in input ( ) . split ( ) ] , reverse = True ) NEW_LINE print ( sum ( A [ : : 2 ] ) ) NEW_LINE"],"bleu":0.26325456303639155,"rouge_l":0.47354801610120756}
{"id":102,"predictions":["n = int ( input ( ) ) NEW_LINE s = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT s . append ( input ( ) ) NEW_LINE DEDENT x = [ ] NEW_LINE y = [ ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT for j in range ( len ( s ) ) : NEW_LINE INDENT if s [ j ] == ' x ' : NEW_LINE INDENT x = s [ i ] . count ( ' x ' ) NEW_LINE DEDENT DEDENT DEDENT print ( y ) NEW_LINE DEDENT"],"references":["n = int ( input ( ) ) NEW_LINE l = [ input ( ) for i in range ( n ) ] NEW_LINE sum = 0 NEW_LINE for i in range ( len ( l ) ) : NEW_LINE INDENT for j in range ( 9 ) : NEW_LINE INDENT if l [ i ] [ j ] == ' x ' : NEW_LINE INDENT sum += 1 NEW_LINE DEDENT elif l [ i ] [ j ] == ' o ' and ( i + 1 == len ( l ) or l [ i + 1 ] [ j ] != ' o ' ) : NEW_LINE INDENT sum += 1 NEW_LINE DEDENT DEDENT DEDENT print ( sum ) NEW_LINE"],"bleu":0.4224726684068276,"rouge_l":0.5881185311215085}
{"id":103,"predictions":["from collections import defaultdict NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT a1 . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT a2 . sort ( ) NEW_LINE b = [ ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT if a1 [ i ] in b : NEW_LINE INDENT b1 . append ( a1 [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT b2 . append ( b1 [ i ] ) NEW_LINE DEDENT DEDENT DEDENT print ( b ) NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) NEW_LINE X = [ [ ] for _ in range ( n ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE X [ a - 1 ] . append ( b - 1 ) NEW_LINE X [ b - 1 ] . append ( a - 1 ) NEW_LINE DEDENT path = [ i for i in range ( 2 , n + 1 ) ] NEW_LINE visited = [ 1 ] + [ 0 ] * ( n - 1 ) NEW_LINE def dfs ( v ) : NEW_LINE INDENT if visited == [ 1 ] * n : NEW_LINE INDENT return 1 NEW_LINE DEDENT res = 0 NEW_LINE for x in X [ v ] : NEW_LINE INDENT if visited [ x ] == 0 : NEW_LINE INDENT visited [ x ] = 1 NEW_LINE res += dfs ( x ) NEW_LINE visited [ x ] = 0 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT print ( dfs ( 0 ) ) NEW_LINE"],"bleu":0.264704593073354,"rouge_l":0.4893205760123708}
{"id":104,"predictions":["N , M = map ( int , input ( ) . split ( ) ) NEW_LINE N , M = map ( int , input ( ) . split ( ) ) NEW_LINE if M > 2 * N : NEW_LINE INDENT counter += N NEW_LINE DEDENT else : NEW_LINE INDENT counter += M \/\/ 2 NEW_LINE DEDENT DEDENT print ( counter ) NEW_LINE"],"references":["N , M = map ( int , input ( ) . split ( ) ) NEW_LINE S_num = N NEW_LINE cc_num = M \/\/ 2 NEW_LINE if ( S_num <= cc_num ) : NEW_LINE INDENT ans = ( S_num + cc_num ) \/\/ 2 NEW_LINE DEDENT else : NEW_LINE INDENT ans = cc_num NEW_LINE DEDENT print ( ans ) NEW_LINE"],"bleu":0.4551763202773033,"rouge_l":0.5747186600366396}
{"id":105,"predictions":["s = input ( ) NEW_LINE k = 0 NEW_LINE ans = 1 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == '1' : NEW_LINE INDENT ans = s [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT ans = k NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["s = input ( ) NEW_LINE K = int ( input ( ) ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if i == K - 1 : NEW_LINE INDENT print ( s [ i ] ) NEW_LINE break NEW_LINE DEDENT if s [ i ] == '1' : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT print ( s [ i ] ) NEW_LINE break NEW_LINE DEDENT DEDENT"],"bleu":0.46780790729570076,"rouge_l":0.5997191011235955}
{"id":106,"predictions":["n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if b [ i ] != a [ i - 1 ] : NEW_LINE INDENT b . append ( a [ - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT b . sort ( ) NEW_LINE DEDENT DEDENT print ( b ) NEW_LINE"],"references":["n = int ( input ( ) ) NEW_LINE a = [ int ( input ( ) ) for i in range ( n ) ] NEW_LINE a = sorted ( set ( a ) , reverse = True ) NEW_LINE if len ( a ) > 1 : NEW_LINE INDENT print ( a [ 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a [ 0 ] ) NEW_LINE DEDENT"],"bleu":0.39035921546885394,"rouge_l":0.5872750104646294}
{"id":107,"predictions":["a , b , c = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( a * b ) NEW_LINE"],"references":["A , B , C = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( A * B * C ) % 1000000007 ) NEW_LINE"],"bleu":0.5046297485373694,"rouge_l":0.6824720298348428}
{"id":108,"predictions":["N , N , P = map ( int , input ( ) . split ( ) ) NEW_LINE if N == 1 : NEW_LINE INDENT print ( pow ( 2 , N - 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( pow ( 2 , N - 1 ) ) NEW_LINE DEDENT"],"references":["N , P = map ( int , input ( ) . split ( ) ) NEW_LINE lst_A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE lst_odd_even = [ x % 2 for x in lst_A ] NEW_LINE if 1 in lst_odd_even : NEW_LINE INDENT ans = 2 ** ( N - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT if P == 0 : NEW_LINE INDENT ans = 2 ** N NEW_LINE DEDENT else : NEW_LINE INDENT ans = 0 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"bleu":0.2558567301270749,"rouge_l":0.45799512987012986}
{"id":109,"predictions":["n = int ( input ( ) ) l1 = list ( map ( int , input ( ) . split ( ) ) ) l2 = list ( map ( int , input ( ) . split ( ) ) ) l2 = list ( map ( int , input ( ) . split ( ) ) ) l2 . sort ( ) if l1 . sort ( ) : print ( 0 ) else : print ( 0 ) NEW_LINE"],"references":["s = input ( ) . split ( ) NEW_LINE t = input ( ) NEW_LINE r = input ( ) . split ( ) NEW_LINE if s == r : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT elif len ( set ( s + [ t ] ) & set ( r ) ) == 6 : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT f = 8 - len ( set ( s ) & set ( r ) ) NEW_LINE if f < 6 : NEW_LINE INDENT print ( f ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT"],"bleu":0.17763988501976297,"rouge_l":0.41121341663926336}
{"id":110,"predictions":["n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if b == 0 : NEW_LINE INDENT a . append ( ( a , b ) ) NEW_LINE DEDENT else : NEW_LINE INDENT a . append ( b ) NEW_LINE DEDENT DEDENT DEDENT"],"references":["def LIS ( L ) : NEW_LINE INDENT from bisect import bisect NEW_LINE best = [ ] NEW_LINE for i in L : NEW_LINE INDENT pos = bisect ( best , i ) NEW_LINE if len ( best ) <= pos : NEW_LINE INDENT best . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT best [ pos ] = i NEW_LINE DEDENT DEDENT return len ( best ) NEW_LINE DEDENT import math NEW_LINE x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) NEW_LINE N = int ( input ( ) ) NEW_LINE W = abs ( x2 - x1 ) NEW_LINE H = abs ( y2 - y1 ) NEW_LINE xsgn = 2 * ( x2 > x1 ) - 1 NEW_LINE ysgn = 2 * ( y2 > y1 ) - 1 NEW_LINE XY = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE if ( x - x1 ) * ( x - x2 ) <= 0 and ( y - y1 ) * ( y - y2 ) <= 0 : NEW_LINE INDENT XY += [ [ xsgn * ( x - x1 ) , ysgn * ( y - y1 ) ] ] NEW_LINE DEDENT DEDENT N = len ( XY ) NEW_LINE short = 20 - 5 * math . pi NEW_LINE long = 10 * math . pi - 20 NEW_LINE straight = 100 * ( W + H ) NEW_LINE XY . sort ( ) NEW_LINE Y = [ y for x , y in XY ] NEW_LINE fountain = LIS ( Y ) NEW_LINE if fountain < min ( W , H ) + 1 : NEW_LINE INDENT print ( straight - short * fountain ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( straight - short * ( fountain - 1 ) + long ) NEW_LINE DEDENT"],"bleu":0.04553983055120769,"rouge_l":0.28188922867821953}
{"id":111,"predictions":["n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ int ( input ( ) ) for i in range ( n ) ] NEW_LINE b = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT b = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE b . append ( b ) NEW_LINE a . append ( b ) NEW_LINE b . append ( b ) NEW_LINE DEDENT print ( - 1 ) NEW_LINE"],"references":["def find ( n , y ) : NEW_LINE INDENT for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( n + 1 - i ) : NEW_LINE INDENT if 10000 * i + 5000 * j + 1000 * ( n - i - j ) == y : NEW_LINE INDENT return i , j , n - i - j NEW_LINE DEDENT DEDENT DEDENT return - 1 , - 1 , - 1 NEW_LINE DEDENT N , Y = map ( int , input ( ) . split ( ) ) NEW_LINE i , j , k = find ( N , Y ) NEW_LINE print ( \" { } ▁ { } ▁ { } \" . format ( i , j , k ) ) NEW_LINE"],"bleu":0.21617918562305233,"rouge_l":0.3632393807066296}
{"id":112,"predictions":["a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE print ( a * c ) NEW_LINE"],"references":["A , B , C = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE print ( A * B * 2 + B * C * 2 + A * C * 2 ) NEW_LINE"],"bleu":0.17967473327604044,"rouge_l":0.464189794091316}
{"id":113,"predictions":["n , s , t = map ( int , input ( ) . split ( ) ) NEW_LINE t = [ ] NEW_LINE for i in range ( n - s ) : NEW_LINE INDENT for j in range ( n - s ) : NEW_LINE INDENT if s [ i ] != t [ j ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if s [ i + j ] != t [ j + 1 ] : NEW_LINE INDENT t . append ( i ) NEW_LINE DEDENT DEDENT DEDENT print ( 2 * n ) NEW_LINE"],"references":["N = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE t = input ( ) NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT if s [ i : ] == t [ : N - i ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( len ( s + t [ N - i : ] ) ) NEW_LINE"],"bleu":0.31017462045327976,"rouge_l":0.5373373373373372}
{"id":114,"predictions":["n = int ( input ( ) ) NEW_LINE r1 , r2 = map ( int , input ( ) . split ( ) ) NEW_LINE r2 = [ ] NEW_LINE for i in range ( n1 , r2 ) : NEW_LINE INDENT r1 , r2 = map ( int , input ( ) . split ( ) ) NEW_LINE r2 . append ( r1 [ 0 ] ) NEW_LINE DEDENT if r1 < r2 : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"],"references":["import math NEW_LINE A , B = map ( int , input ( ) . split ( ) ) NEW_LINE N = int ( input ( ) ) NEW_LINE C = [ 0 ] * N NEW_LINE D = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT C [ i ] , D [ i ] = map ( int , input ( ) . split ( ) ) NEW_LINE DEDENT res = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT curr = False NEW_LINE if A <= C [ i ] and B <= D [ i ] : NEW_LINE INDENT curr = True NEW_LINE DEDENT if B <= C [ i ] and A <= D [ i ] : NEW_LINE INDENT curr = True NEW_LINE DEDENT if curr == False : NEW_LINE INDENT for j in range ( 2 ) : NEW_LINE INDENT if j == 1 : NEW_LINE INDENT temp = A NEW_LINE A = B NEW_LINE B = temp NEW_LINE DEDENT lo = math . atan ( B \/ A ) NEW_LINE hi = math . pi \/ 2 NEW_LINE mid = 0 NEW_LINE cnt = 0 NEW_LINE while lo < hi and cnt < 50 : NEW_LINE INDENT mid = ( lo + hi ) \/ 2 NEW_LINE if A * math . sin ( mid ) + B * math . cos ( mid ) < max ( C [ i ] , D [ i ] ) : NEW_LINE INDENT lo = mid NEW_LINE DEDENT else : NEW_LINE INDENT hi = mid NEW_LINE DEDENT cnt += 1 NEW_LINE DEDENT if A * math . cos ( lo ) + B * math . sin ( lo ) <= min ( C [ i ] , D [ i ] ) : NEW_LINE INDENT curr |= True NEW_LINE DEDENT DEDENT DEDENT if curr == True : NEW_LINE INDENT res . append ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT res . append ( \" NO \" ) NEW_LINE DEDENT DEDENT print ( \" \\n \" . join ( map ( str , res ) ) ) NEW_LINE"],"bleu":0.041319512458089534,"rouge_l":0.2862396956246037}
{"id":115,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] ans = [ 0 ] * mfor i in range ( n ) : ans [ a [ i ] - 1 ] += 1 print ( ans ) NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ 0 ] * n NEW_LINE for i in range ( m ) : NEW_LINE INDENT b , c = map ( int , input ( ) . split ( ) ) NEW_LINE a [ b - 1 ] += 1 NEW_LINE a [ c - 1 ] += 1 NEW_LINE DEDENT for i in a : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT"],"bleu":0.48175041964022264,"rouge_l":0.5690298507462687}
{"id":116,"predictions":["A , B , C = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 10 ** 9 + 7 NEW_LINE for _ in range ( A * ( B - A ) ) : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE ans = ( a * ( B - A ) ) NEW_LINE if ans == 1 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["A = int ( input ( ) ) NEW_LINE C = int ( input ( ) ) NEW_LINE B = int ( input ( ) ) NEW_LINE mod = 10 ** 9 + 7 NEW_LINE def power ( x , y ) : NEW_LINE INDENT if y == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif y == 1 : NEW_LINE INDENT return x % mod NEW_LINE DEDENT elif y % 2 == 0 : NEW_LINE INDENT return power ( x , y \/\/ 2 ) ** 2 % mod NEW_LINE DEDENT else : NEW_LINE INDENT return ( power ( x , y \/\/ 2 ) ** 2 ) * x % mod NEW_LINE DEDENT DEDENT inv = power ( A * B + A * C - B * C , mod - 2 ) NEW_LINE i = ( ( ( 2 * B * C - A * B - A * C ) % mod ) * inv ) % mod NEW_LINE j = A * B * inv - 1 NEW_LINE print ( ( i - j ) % mod , j % mod ) NEW_LINE"],"bleu":0.10310077471469246,"rouge_l":0.30579773321708803}
{"id":117,"predictions":["from math import gcd NEW_LINE n = int ( input ( ) ) NEW_LINE for _ in range ( n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE gcd = gcd ( a , b ) NEW_LINE DEDENT print ( ans ) NEW_LINE"],"references":["from fractions import gcd NEW_LINE from functools import reduce NEW_LINE N = int ( input ( ) ) NEW_LINE T = map ( int , [ input ( ) for _ in range ( N ) ] ) NEW_LINE def lcm_base ( x , y ) : NEW_LINE INDENT return ( x * y ) \/\/ gcd ( x , y ) NEW_LINE DEDENT def lcm ( numbers ) : NEW_LINE INDENT return reduce ( lcm_base , numbers , 1 ) NEW_LINE DEDENT print ( lcm ( T ) ) NEW_LINE"],"bleu":0.2396322852822078,"rouge_l":0.46963216424294274}
{"id":118,"predictions":["n = int ( input ( ) ) NEW_LINE print ( n \/\/ 2 ) NEW_LINE"],"references":["k = int ( input ( ) ) NEW_LINE if k % 2 == 0 : NEW_LINE INDENT even = k \/\/ 2 NEW_LINE odd = k \/\/ 2 NEW_LINE DEDENT else : NEW_LINE INDENT even = k \/\/ 2 NEW_LINE odd = k \/\/ 2 + 1 NEW_LINE DEDENT print ( even * odd ) NEW_LINE"],"bleu":0.045509980464664083,"rouge_l":0.29853181076672103}
{"id":119,"predictions":["a , b = map ( int , input ( ) . split ( ) ) NEW_LINE A = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( 3 ) ] NEW_LINE A = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( 2 ) ] NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT A [ i ] [ 0 ] -= a [ i ] [ i ] NEW_LINE DEDENT for i in range ( 3 ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT if A [ i ] [ j ] - A [ i ] != a [ j ] : NEW_LINE INDENT B [ i ] [ j ] = B [ i ] [ j ] - B [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT print ( ' Yes ' ) NEW_LINE DEDENT"],"references":["c = [ [ 0 , 0 , 0 ] , [ 0 , 0 , 0 ] , [ 0 , 0 , 0 ] ] NEW_LINE for i in range ( 0 , 3 ) : NEW_LINE INDENT c [ i ] = [ int ( j ) for j in input ( ) . split ( \" ▁ \" ) ] NEW_LINE DEDENT f = True NEW_LINE for i in range ( 0 , 2 ) : NEW_LINE INDENT f = f and c [ i ] [ 0 ] - c [ i ] [ 1 ] == c [ i + 1 ] [ 0 ] - c [ i + 1 ] [ 1 ] NEW_LINE f = f and c [ i ] [ 1 ] - c [ i ] [ 2 ] == c [ i + 1 ] [ 1 ] - c [ i + 1 ] [ 2 ] NEW_LINE DEDENT for i in range ( 0 , 2 ) : NEW_LINE INDENT f = f and c [ 0 ] [ i ] - c [ 1 ] [ i ] == c [ 0 ] [ i + 1 ] - c [ 1 ] [ i + 1 ] NEW_LINE f = f and c [ 1 ] [ i ] - c [ 2 ] [ i ] == c [ 1 ] [ i + 1 ] - c [ 2 ] [ i + 1 ] NEW_LINE DEDENT if f : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.17758001225405456,"rouge_l":0.37951057652426384}
{"id":120,"predictions":["A , B = map ( int , input ( ) . split ( ) ) NEW_LINE A = sorted ( A ) NEW_LINE B = sorted ( B ) NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT print ( B [ i ] ) NEW_LINE DEDENT"],"references":["A = [ int ( input ( ) ) for i in range ( 3 ) ] NEW_LINE s = sorted ( A ) [ : : - 1 ] NEW_LINE for i in A : NEW_LINE INDENT print ( s . index ( i ) + 1 ) NEW_LINE DEDENT"],"bleu":0.37879243845362115,"rouge_l":0.533700583279326}
{"id":121,"predictions":["n = int ( input ( ) ) NEW_LINE nodes = [ ] NEW_LINE nodes = [ ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE nodes . append ( nodes [ a ] ) NEW_LINE DEDENT nodes = [ None ] * n NEW_LINE nodes = [ ] * n NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE nodes [ a ] . append ( a ) NEW_LINE nodes [ b ] . append ( b ) NEW_LINE DEDENT DEDENT nodes = [ ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE nodes [ b ] . append ( nodes [ a ] ) NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT print ( \" Alice \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Bob \" ) NEW_LINE DEDENT DEDENT"],"references":["import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE inf = 10 ** 20 NEW_LINE gosa = 1.0 \/ 10 ** 10 NEW_LINE mod = 10 ** 9 + 7 NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def F ( ) : return float ( sys . stdin . readline ( ) ) NEW_LINE def S ( ) : return input ( ) NEW_LINE def main ( ) : NEW_LINE INDENT n = I ( ) NEW_LINE e = collections . defaultdict ( set ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT a , b = LI ( ) NEW_LINE e [ a ] . add ( b ) NEW_LINE e [ b ] . add ( a ) NEW_LINE DEDENT def f ( i , c ) : NEW_LINE INDENT r = 0 NEW_LINE for j in e [ i ] : NEW_LINE INDENT if j == c : NEW_LINE INDENT continue NEW_LINE DEDENT t = f ( j , i ) NEW_LINE r ^= t NEW_LINE DEDENT return r + 1 NEW_LINE DEDENT if f ( 1 , - 1 ) == 1 : NEW_LINE INDENT return ' Bob ' NEW_LINE DEDENT return ' Alice ' NEW_LINE DEDENT print ( main ( ) ) NEW_LINE"],"bleu":0.15951426564841606,"rouge_l":0.32521465851057857}
{"id":122,"predictions":["from collections import deque NEW_LINE N , G , G = map ( int , input ( ) . split ( ) ) NEW_LINE edges = [ ] NEW_LINE for _ in range ( N ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE graph [ a , b ] . append ( ( b ) ) NEW_LINE graph [ a ] . append ( ( a ) ) NEW_LINE graph [ b ] . append ( ( a ) NEW_LINE DEDENT for i in range ( N ) ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE graph [ a ] . append ( ( b ) ) NEW_LINE graph [ b ] . append ( ( a ) ) NEW_LINE graph [ b ] . append ( b ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( G ) : NEW_LINE INDENT if graph [ i ] [ a ] == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT if visited [ i ] ] == 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT if visited [ a ] == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT N , G = map ( int , input ( ) . split ( ) ) ) NEW_LINE graph = [ tuple ( map ( int , input ( ) . split ( ) ) for _ in range ( N ) ] NEW_LINE graph . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if graph [ i ] [ j ] in graph : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["class Ford_Fulkerson : NEW_LINE INDENT def __init__ ( self , N ) : NEW_LINE INDENT self . used = [ False ] * ( N + 1 ) NEW_LINE self . G = [ [ 0 ] * ( N + 1 ) for i in range ( N + 1 ) ] NEW_LINE DEDENT def add_edge ( self , fr , to , cap ) : NEW_LINE INDENT self . G [ fr ] [ to ] = cap NEW_LINE DEDENT def dfs ( self , v , t , f ) : NEW_LINE INDENT if v == t : NEW_LINE INDENT return f NEW_LINE DEDENT self . used [ v ] = True NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT if v == i : NEW_LINE INDENT continue NEW_LINE DEDENT if ( not self . used [ i ] ) and self . G [ v ] [ i ] > 0 : NEW_LINE INDENT d = self . dfs ( i , t , min ( f , self . G [ v ] [ i ] ) ) NEW_LINE if d > 0 : NEW_LINE INDENT self . G [ v ] [ i ] -= d NEW_LINE self . G [ i ] [ v ] += d NEW_LINE return d NEW_LINE DEDENT DEDENT DEDENT return 0 NEW_LINE DEDENT DEDENT N , G , E = map ( int , input ( ) . split ( ) ) NEW_LINE p = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE F = Ford_Fulkerson ( N ) NEW_LINE for i in range ( G ) : NEW_LINE INDENT F . add_edge ( p [ i ] , N , 1 ) NEW_LINE DEDENT for i in range ( E ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE F . add_edge ( a , b , 1 ) NEW_LINE F . add_edge ( b , a , 1 ) NEW_LINE DEDENT num = 0 NEW_LINE while True : NEW_LINE INDENT F . used = [ False ] * ( N + 1 ) NEW_LINE f = F . dfs ( 0 , N , 10 ** 9 ) NEW_LINE if f == 0 : NEW_LINE INDENT break NEW_LINE DEDENT num += f NEW_LINE DEDENT print ( num ) NEW_LINE"],"bleu":0.33170180467221727,"rouge_l":0.38838357588357586}
{"id":123,"predictions":["x , y = map ( int , input ( ) . split ( ) ) NEW_LINE a , b = 0 , 0 NEW_LINE if abs ( x - a ) < abs ( x - a ) : NEW_LINE INDENT print ( ' B ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' B ' ) NEW_LINE DEDENT"],"references":["X , A , B = map ( int , input ( ) . split ( ) ) NEW_LINE print ( [ \" A \" , \" B \" ] [ not ( abs ( X - A ) < abs ( X - B ) ) ] ) NEW_LINE"],"bleu":0.3125934198200443,"rouge_l":0.5098507462686567}
{"id":124,"predictions":["from sys import stdin , stdout NEW_LINE input = stdin . readline NEW_LINE def li ( ) : return list ( map ( int , stdin . readline ( ) . split ( ) ) ) NEW_LINE def lii ( ) : return list ( map ( int , stdin . readline ( ) . split ( ) ) ) NEW_LINE def li_ ( ) : return list ( map ( int , stdin . readline ( ) . split ( ) ) ) NEW_LINE def li ( ) : return list ( map ( int , stdin . readline ( ) . split ( ) ) ) NEW_LINE def li ( ) : return map ( float , stdin . readline ( ) . split ( ) ) ) NEW_LINE def li ( ) : return map ( float , stdin . readline ( ) . strip ( ) . split ( ) ) NEW_LINE def li ( ) : return list ( map ( int , stdin . readline ( ) . split ( ) ) ) NEW_LINE def li ( ) : return list ( map ( int , stdin . readline ( ) . split ( ) ) ) NEW_LINE def li ( ) : return map ( float , stdin . readline ( ) . split ( ) ) ) NEW_LINE def li ( ) : return map ( float , stdin . readline ( ) . rstrip ( ) . split ( ) ) NEW_LINE def lij ( ) : return list ( ) NEW_LINE def li ( ) : return list ( li ) NEW_LINE def lij ( ) : return list ( li ) NEW_LINE def lij ( ) : return li ( ) NEW_LINE def lij ( ) : return list ( ) : return map ( float , stdin . readline ( ) ) . split ( ) ) NEW_LINE def lij ( ) : return list ( ) NEW_LINE def lii ( ) : return list ( li ) NEW_LINE def lii ( ) : NEW_LINE sj = li ( ) NEW_LINE for i , j in lij = li [ j ] NEW_LINE ans = 0.0 NEW_LINE for i in li : NEW_LINE INDENT if li [ i ] [ j ] : NEW_LINE INDENT ans += li [ i ] [ j ] NEW_LINE DEDENT else : NEW_LINE IND"],"references":["import math NEW_LINE N , Q = map ( int , input ( ) . split ( ) ) NEW_LINE X = [ 0 ] * N NEW_LINE R = [ 0 ] * N NEW_LINE H = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT X [ i ] , R [ i ] , H [ i ] = map ( int , input ( ) . split ( ) ) NEW_LINE DEDENT A = [ 0 ] * Q NEW_LINE B = [ 0 ] * Q NEW_LINE for i in range ( Q ) : NEW_LINE INDENT A [ i ] , B [ i ] = map ( int , input ( ) . split ( ) ) NEW_LINE DEDENT MAX_X = 3 * 10 ** 4 NEW_LINE V = [ 0 ] * MAX_X NEW_LINE for x in range ( MAX_X ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT if X [ i ] > x or X [ i ] + H [ i ] < x : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT Rleft = ( X [ i ] + H [ i ] - x ) * R [ i ] \/ H [ i ] NEW_LINE Rright = max ( 0 , ( X [ i ] + H [ i ] - ( x + 1 ) ) * R [ i ] \/ H [ i ] ) NEW_LINE Vleft = math . pi * Rleft ** 2 * ( X [ i ] + H [ i ] - x ) \/ 3 NEW_LINE Vright = math . pi * Rright ** 2 * ( X [ i ] + H [ i ] - ( x + 1 ) ) \/ 3 NEW_LINE V [ x ] += Vleft - Vright NEW_LINE DEDENT DEDENT DEDENT cum_sum = [ 0 ] * ( MAX_X + 1 ) NEW_LINE for x in range ( MAX_X ) : NEW_LINE INDENT cum_sum [ x + 1 ] = V [ x ] + cum_sum [ x ] NEW_LINE DEDENT for i in range ( Q ) : NEW_LINE INDENT res = cum_sum [ B [ i ] ] - cum_sum [ A [ i ] ] NEW_LINE print ( res ) NEW_LINE DEDENT"],"bleu":0.13113967693021425,"rouge_l":0.2665604835416156}
{"id":125,"predictions":["n = int ( input ( ) ) NEW_LINE h , m = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE print ( ' { } ' . format ( h , m , s ) ) NEW_LINE"],"references":["n = int ( input ( ) ) NEW_LINE h = n \/\/ ( 60 * 60 ) NEW_LINE m = ( n % ( 60 * 60 ) ) \/\/ 60 NEW_LINE s = ( n % ( 60 * 60 ) ) % 60 NEW_LINE print ( ' { :02 } : { : 02 } : { : 02 } ' . format ( h , m , s ) ) NEW_LINE"],"bleu":0.30869162166740954,"rouge_l":0.5509677419354838}
{"id":126,"predictions":["n , k = map ( int , input ( ) . split ( ) ) NEW_LINE A = [ int ( input ( ) ) for i in range ( n ) ] NEW_LINE A = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE A = [ int ( i ) for i in A ] NEW_LINE B = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE A = [ int ( i ) for i in range ( 1 , k ) ] NEW_LINE B = [ int ( i ) for i in range ( k ) ] NEW_LINE for i in range ( A ) : NEW_LINE INDENT A [ i ] = A [ i ] NEW_LINE B += ( A [ i ] \/\/ K ) NEW_LINE DEDENT ans = N NEW_LINE for i in range ( k ) : NEW_LINE INDENT if A [ i ] == B [ i ] : NEW_LINE INDENT ans = min ( ans , B ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["import math NEW_LINE N , K = map ( int , input ( ) . split ( ) ) NEW_LINE A_ = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = math . ceil ( ( N - 1 ) \/ ( K - 1 ) ) NEW_LINE print ( ans ) NEW_LINE"],"bleu":0.14029538170131534,"rouge_l":0.3776558322780358}
{"id":127,"predictions":["n = int ( input ( ) ) NEW_LINE for _ in range ( n ) : NEW_LINE INDENT a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] % n == 0 : NEW_LINE INDENT a [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT ans = n - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] % n == 0 : NEW_LINE INDENT ans = 0 NEW_LINE break NEW_LINE DEDENT DEDENT print ( ans + 1 ) NEW_LINE"],"references":["import copy as co NEW_LINE class circle ( ) : NEW_LINE INDENT def __init__ ( self , numlist , amount_of_can ) : NEW_LINE INDENT self . numcircle = numlist NEW_LINE self . til = 0 NEW_LINE self . cansee = amount_of_can NEW_LINE self . times = 1 NEW_LINE DEDENT def right_rotation ( self , num , length ) : NEW_LINE INDENT a = self . numcircle [ : length - num ] NEW_LINE b = self . numcircle [ length - num : ] NEW_LINE return b + a NEW_LINE DEDENT DEDENT def sup_and ( str1 , str2 , length ) : NEW_LINE INDENT count = 0 NEW_LINE for x in range ( 0 , length ) : NEW_LINE INDENT str1 [ x ] = str1 [ x ] or str2 [ x ] NEW_LINE count += str1 [ x ] NEW_LINE DEDENT return count NEW_LINE DEDENT def search ( circlelist , length , TV ) : NEW_LINE INDENT list1 = [ ] NEW_LINE for x in range ( circlelist . til + 1 , length ) : NEW_LINE INDENT circlelist2 = co . deepcopy ( circlelist ) NEW_LINE circlelist2 . cansee = sup_and ( circlelist2 . numcircle , TV . right_rotation ( x , length ) , length ) NEW_LINE circlelist2 . til = x NEW_LINE circlelist2 . times += 1 NEW_LINE list1 . append ( circlelist2 ) NEW_LINE DEDENT return list1 NEW_LINE DEDENT inp1 = input ( ) NEW_LINE amount_of_can = 0 NEW_LINE numlist = [ ] NEW_LINE for x in inp1 : NEW_LINE INDENT if x == ' x ' : NEW_LINE INDENT numlist . append ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT numlist . append ( 1 ) NEW_LINE amount_of_can += 1 NEW_LINE DEDENT DEDENT length = len ( numlist ) NEW_LINE if amount_of_can == length : NEW_LINE INDENT print ( 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT else : NEW_LINE INDENT circlelist = circle ( numlist , amount_of_can ) NEW_LINE alllist1 = [ circlelist ] NEW_LINE TV = co . deepcopy ( circlelist ) NEW_LINE while True : NEW_LINE INDENT alllist2 = [ ] NEW_LINE while alllist1 : NEW_LINE INDENT alllist2 . extend ( search ( alllist1 . pop ( ) , length , TV ) ) NEW_LINE DEDENT alllist1 = alllist2 NEW_LINE for x in alllist1 : NEW_LINE INDENT if x . cansee == length : NEW_LINE INDENT print ( x . times ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT DEDENT DEDENT"],"bleu":0.019629233794724258,"rouge_l":0.21449637023593468}
{"id":128,"predictions":["n = int ( input ( ) ) NEW_LINE L = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] NEW_LINE R = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT L . sort ( ) NEW_LINE L [ L [ i ] ] += 1 NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT L . sort ( ) NEW_LINE L [ L [ i ] ] += 1 NEW_LINE DEDENT print ( L ) NEW_LINE"],"references":["n = int ( input ( ) ) NEW_LINE t = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT t [ i ] = int ( input ( ) ) NEW_LINE DEDENT t . sort ( ) NEW_LINE m = 10 ** 9 + 7 NEW_LINE res = 0 NEW_LINE ass = 1 NEW_LINE p = [ 1 ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT p . append ( p [ - 1 ] * i % m ) NEW_LINE DEDENT c = 0 NEW_LINE k = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT c += t [ i ] NEW_LINE res += c NEW_LINE if i != n - 1 : NEW_LINE INDENT if t [ i ] != t [ i + 1 ] : NEW_LINE INDENT ass = ass * p [ k ] % m NEW_LINE k = 1 NEW_LINE DEDENT else : NEW_LINE INDENT k += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT ass = ass * p [ k ] % m NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE print ( ass ) NEW_LINE"],"bleu":0.18297376256955575,"rouge_l":0.3932076197806427}
{"id":129,"predictions":["n , C , K = map ( int , input ( ) . split ( ) ) NEW_LINE S = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT S . append ( input ( ) ) NEW_LINE DEDENT S . sort ( ) NEW_LINE S . sort ( ) NEW_LINE S . sort ( ) NEW_LINE S . sort ( ) NEW_LINE t = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if S [ i ] < T : NEW_LINE INDENT t = S [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT t . append ( 1 ) NEW_LINE DEDENT DEDENT print ( t ) NEW_LINE"],"references":["from math import ceil NEW_LINE def main ( ) : NEW_LINE INDENT N , C , K = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE Ts = [ ] NEW_LINE for _ in range ( N ) : NEW_LINE INDENT Ts . append ( int ( input ( ) ) ) NEW_LINE DEDENT Ts . sort ( ) NEW_LINE bus_ct = 0 NEW_LINE in_bus = 1 NEW_LINE st = Ts . pop ( 0 ) + K NEW_LINE for Ti in Ts : NEW_LINE INDENT if Ti > st : NEW_LINE INDENT bus_ct += 1 NEW_LINE in_bus = 1 NEW_LINE st = Ti + K NEW_LINE DEDENT elif Ti <= st : NEW_LINE INDENT in_bus += 1 NEW_LINE DEDENT if in_bus > C : NEW_LINE INDENT bus_ct += 1 NEW_LINE in_bus = 1 NEW_LINE st = Ti + K NEW_LINE DEDENT DEDENT if in_bus : NEW_LINE INDENT bus_ct += 1 NEW_LINE DEDENT print ( bus_ct ) NEW_LINE DEDENT main ( ) NEW_LINE"],"bleu":0.2661890588260236,"rouge_l":0.49571710959806725}
{"id":130,"predictions":["n , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += ( a - b ) * ( a - b ) NEW_LINE DEDENT if ans > b : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["import heapq NEW_LINE n , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE h = [ int ( input ( ) ) for i in range ( n ) ] NEW_LINE h . sort ( ) NEW_LINE p = a - b NEW_LINE def c ( w ) : NEW_LINE INDENT k = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT l [ i ] = l [ i ] - b * w NEW_LINE if l [ i ] > 0 : NEW_LINE INDENT k += l [ i ] \/\/ p NEW_LINE if l [ i ] % p != 0 : NEW_LINE INDENT k += 1 NEW_LINE DEDENT DEDENT DEDENT if w >= k : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT s = 0 NEW_LINE f = 10 ** 14 NEW_LINE while f - s >= 2 : NEW_LINE INDENT m = ( f + s ) \/\/ 2 NEW_LINE l = h [ : : ] NEW_LINE if c ( m ) : NEW_LINE INDENT f = m NEW_LINE DEDENT else : NEW_LINE INDENT s = m NEW_LINE DEDENT DEDENT l = h [ : : ] NEW_LINE if c ( s ) : NEW_LINE INDENT print ( s ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( f ) NEW_LINE DEDENT"],"bleu":0.04545020364433361,"rouge_l":0.30253036437246966}
{"id":131,"predictions":["N , K = map ( int , input ( ) . split ( ) ) NEW_LINE S = [ input ( ) for _ in range ( N ) ] NEW_LINE S = [ input ( ) for _ in range ( 2 * N ) ] NEW_LINE S = [ ' A ' , ' A ' , ' B ' ] NEW_LINE for i in range ( 2 * N ) : NEW_LINE INDENT S [ i ] = ' B ' NEW_LINE DEDENT for i in range ( 2 * N ) : NEW_LINE INDENT S [ i ] = S [ i + 1 ] NEW_LINE DEDENT DEDENT N , K = map ( int , input ( ) . split ( ) ) NEW_LINE if N < K : NEW_LINE INDENT print ( ' A ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' B ' ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE from itertools import accumulate NEW_LINE from collections import deque NEW_LINE def solve ( ) : NEW_LINE INDENT N , K = map ( int , input ( ) . split ( ) ) NEW_LINE S = input ( ) NEW_LINE q = deque ( [ 1 if c == ' A ' else 0 for c in S ] ) NEW_LINE cb = 0 NEW_LINE for i in range ( min ( K , 2 * N + K % 2 ) ) : NEW_LINE INDENT if q [ 0 ] == ( cb ^ 1 ) : NEW_LINE INDENT q [ 0 ] ^= 1 NEW_LINE DEDENT else : NEW_LINE INDENT q . popleft ( ) NEW_LINE q . append ( cb ) NEW_LINE cb ^= 1 NEW_LINE DEDENT DEDENT ans = [ ' A ' if ( c ^ cb ) else ' B ' for c in q ] NEW_LINE print ( ' ' . join ( ans ) ) NEW_LINE DEDENT def debug ( x , table ) : NEW_LINE INDENT for name , val in table . items ( ) : NEW_LINE INDENT if x is val : NEW_LINE INDENT print ( ' DEBUG : { } ▁ - > ▁ { } ' . format ( name , val ) , file = sys . stderr ) NEW_LINE return None NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT"],"bleu":0.20396542375185234,"rouge_l":0.38592701180464467}
{"id":132,"predictions":["a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE if ( b == 0 ) : NEW_LINE INDENT print ( a + b ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a - b ) NEW_LINE DEDENT"],"references":["print ( eval ( input ( ) ) ) NEW_LINE"],"bleu":0.08288569028045888,"rouge_l":0.27371794871794874}
{"id":133,"predictions":["S = input ( ) NEW_LINE S = input ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( len ( S ) ) : NEW_LINE INDENT if S [ i ] == ' U ' : NEW_LINE INDENT ans += ( S [ i ] - i ) * 2 + i * 2 NEW_LINE DEDENT else : NEW_LINE INDENT ans += 2 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["import sys NEW_LINE stdin = sys . stdin NEW_LINE def li ( ) : return map ( int , stdin . readline ( ) . split ( ) ) NEW_LINE def li_ ( ) : return map ( lambda x : int ( x ) - 1 , stdin . readline ( ) . split ( ) ) NEW_LINE def lf ( ) : return map ( float , stdin . readline ( ) . split ( ) ) NEW_LINE def ls ( ) : return stdin . readline ( ) . split ( ) NEW_LINE def ns ( ) : return stdin . readline ( ) . rstrip ( ) NEW_LINE def lc ( ) : return list ( ns ( ) ) NEW_LINE def ni ( ) : return int ( stdin . readline ( ) ) NEW_LINE def nf ( ) : return float ( stdin . readline ( ) ) NEW_LINE s = ns ( ) NEW_LINE n = len ( s ) NEW_LINE ans = 0 NEW_LINE for idx , si in enumerate ( s ) : NEW_LINE INDENT if si == ' U ' : NEW_LINE INDENT ans += ( n - idx - 1 ) + 2 * idx NEW_LINE DEDENT else : NEW_LINE INDENT ans += 2 * ( n - idx - 1 ) + idx NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"bleu":0.058327434134074645,"rouge_l":0.303867942957609}
{"id":134,"predictions":["from collections import defaultdict NEW_LINE N , X = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT abs ( a [ i ] - a [ i ] ) NEW_LINE DEDENT if abs ( a [ i ] - a [ i ] ) > 0 : NEW_LINE INDENT ans = a [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT ans = a [ i ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["def gcd ( a , b ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( b , a % b ) NEW_LINE DEDENT DEDENT N , A = map ( int , input ( ) . split ( ) ) NEW_LINE X = sorted ( map ( int , input ( ) . split ( ) ) ) NEW_LINE Y = [ ] NEW_LINE for x in X : NEW_LINE INDENT Y . append ( abs ( A - x ) ) NEW_LINE DEDENT ans = max ( Y ) NEW_LINE for y in Y : NEW_LINE INDENT ans = gcd ( y , ans ) NEW_LINE DEDENT print ( ans ) NEW_LINE"],"bleu":0.40108108187464947,"rouge_l":0.5072246455834243}
{"id":135,"predictions":["N , K = map ( int , input ( ) . split ( ) ) NEW_LINE ans = N - K + 1 NEW_LINE print ( ans ) NEW_LINE"],"references":["N , i = map ( int , input ( ) . split ( ) ) NEW_LINE print ( N - i + 1 ) NEW_LINE"],"bleu":0.5775107557288739,"rouge_l":0.7959667852906288}
{"id":136,"predictions":["N , A , B , sq = map ( int , input ( ) . split ( ) ) NEW_LINE if A + B < N : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT elif A + B < N : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT"],"references":["N , A , B = map ( int , input ( ) . split ( ) ) NEW_LINE ans = list ( range ( A ) ) NEW_LINE m = 0 NEW_LINE rest = N - A NEW_LINE B -= 1 NEW_LINE if rest < B : NEW_LINE INDENT print ( - 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT if rest \/ A > B : NEW_LINE INDENT print ( - 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT while rest > B : NEW_LINE INDENT s = min ( A , rest - B + 1 ) NEW_LINE ans += list ( range ( m - s , m ) ) NEW_LINE m -= s NEW_LINE rest -= s NEW_LINE B -= 1 NEW_LINE DEDENT ans += list ( range ( m - B , m ) ) [ : : - 1 ] NEW_LINE m -= B NEW_LINE print ( \" ▁ \" . join ( [ str ( x - m + 1 ) for x in ans ] ) ) NEW_LINE"],"bleu":0.10880196872362739,"rouge_l":0.4042766037263974}
{"id":137,"predictions":["s = input ( ) NEW_LINE s = \" \" NEW_LINE n = len ( s ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] != s [ i ] : NEW_LINE INDENT ans = s [ i ] - 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = s [ i ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["from string import ascii_lowercase NEW_LINE s = input ( ) NEW_LINE ans = 100 NEW_LINE for c in ascii_lowercase : NEW_LINE INDENT ans = min ( ans , max ( [ len ( x ) for x in s . split ( c ) ] ) ) NEW_LINE DEDENT print ( ans ) NEW_LINE"],"bleu":0.25247120797635614,"rouge_l":0.42080127354735997}
{"id":138,"predictions":["n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if l [ i ] > l [ i ] : NEW_LINE INDENT l . append ( i ) NEW_LINE DEDENT elif l [ i ] > l : NEW_LINE INDENT l . append ( i ) NEW_LINE DEDENT else : NEW_LINE l . append ( i ) NEW_LINE DEDENT DEDENT print ( len ( l ) ) NEW_LINE"],"references":["l , h = map ( int , input ( ) . split ( ) ) NEW_LINE n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT a = int ( input ( ) ) NEW_LINE if a < l : NEW_LINE INDENT print ( l - a ) NEW_LINE DEDENT elif l <= a <= h : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT"],"bleu":0.4598437744380623,"rouge_l":0.5715043309174475}
{"id":139,"predictions":["n , m = map ( int , input ( ) . split ( ) ) NEW_LINE A = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] NEW_LINE B = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] NEW_LINE B = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] NEW_LINE B = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] NEW_LINE C = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT A [ B [ i ] ] -= 1 NEW_LINE DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT A [ B [ i ] ] -= 1 NEW_LINE B [ B [ i ] ] -= 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if B [ i ] [ j ] >= C : NEW_LINE INDENT L [ B [ i ] ] -= 1 NEW_LINE DEDENT DEDENT DEDENT print ( L ) NEW_LINE"],"references":["from collections import Counter NEW_LINE N , M = map ( int , input ( ) . split ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE src = [ tuple ( map ( int , input ( ) . split ( ) ) ) for i in range ( M ) ] NEW_LINE ctr = Counter ( A ) NEW_LINE cover = [ 0 ] * ( 2 * N + 1 ) NEW_LINE for k , v in ctr . items ( ) : NEW_LINE INDENT for i in range ( k , k - v , - 1 ) : NEW_LINE INDENT cover [ i + N ] += 1 NEW_LINE DEDENT DEDENT ans = cover [ N + 1 : ] . count ( 0 ) NEW_LINE for x , y in src : NEW_LINE INDENT ctr [ A [ x - 1 ] ] -= 1 NEW_LINE ai = A [ x - 1 ] + N - ctr [ A [ x - 1 ] ] NEW_LINE cover [ ai ] -= 1 NEW_LINE if ai > N and cover [ ai ] == 0 : ans += 1 NEW_LINE A [ x - 1 ] = y NEW_LINE bi = y + N - ctr [ y ] NEW_LINE if bi > N and cover [ bi ] == 0 : ans -= 1 NEW_LINE cover [ bi ] += 1 NEW_LINE ctr [ y ] += 1 NEW_LINE print ( ans ) NEW_LINE DEDENT"],"bleu":0.3012379677900712,"rouge_l":0.46996554963983717}
{"id":140,"predictions":["n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in range ( n ) : if b [ i ] >= a [ i ] : b . append ( a [ i ] ) b . append ( b [ i ] ) print ( * b ) NEW_LINE"],"references":["import heapq NEW_LINE N , K = map ( int , input ( ) . split ( ) ) NEW_LINE src = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE hq = [ ] NEW_LINE heapq . heapify ( hq ) NEW_LINE for i , a in enumerate ( src [ : K ] ) : NEW_LINE INDENT heapq . heappush ( hq , ( - a , i + 1 ) ) NEW_LINE DEDENT for i , a in enumerate ( src [ K : ] ) : NEW_LINE INDENT b , j = hq [ 0 ] NEW_LINE print ( j ) NEW_LINE if a < - b : NEW_LINE INDENT heapq . heappop ( hq ) NEW_LINE heapq . heappush ( hq , ( - a , K + i + 1 ) ) NEW_LINE DEDENT DEDENT b , j = hq [ 0 ] NEW_LINE print ( j ) NEW_LINE"],"bleu":0.21480427748484765,"rouge_l":0.45096453736860337}
{"id":141,"predictions":["n , b = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT c += a [ i ] NEW_LINE DEDENT print ( ans ) NEW_LINE"],"references":["n = int ( input ( ) ) NEW_LINE list = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE list . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans += ( - 1 ) ** ( i - 1 ) * list [ - i ] NEW_LINE DEDENT print ( ans ) NEW_LINE"],"bleu":0.5260556819330924,"rouge_l":0.7084037162162163}
{"id":142,"predictions":["n = int ( input ( ) ) NEW_LINE days = [ \" Friendship \" , \" Friendship \" , \" Friendship \" , \" Friendship \" , \" Friendship \" , \" Friendship \" ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if days [ i ] == 5 : NEW_LINE INDENT ans = 5 - i NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT print ( 5 - 1 ) NEW_LINE"],"references":["day = input ( ) NEW_LINE if day == \" Monday \" : NEW_LINE INDENT print ( 5 ) NEW_LINE DEDENT elif day == \" Tuesday \" : NEW_LINE INDENT print ( 4 ) NEW_LINE DEDENT elif day == \" Wednesday \" : NEW_LINE INDENT print ( 3 ) NEW_LINE DEDENT elif day == \" Thursday \" : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT elif day == \" Friday \" : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT"],"bleu":0.08105537141207289,"rouge_l":0.3197437390797903}
{"id":143,"predictions":["import sys NEW_LINE def readint ( ) : NEW_LINE INDENT return sys . argv [ 1 ] NEW_LINE DEDENT def readint ( ) : NEW_LINE INDENT return sys . stdin . readline ( ) . strip ( ) NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT n = int ( sys . stdin . readline ( ) ) NEW_LINE M = [ int ( x ) for x in stdin . readline ( ) . strip ( ) . split ( ) ] NEW_LINE m = [ int ( x ) for x in stdin . readline ( ) . split ( ) ] NEW_LINE ans = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT m = [ int ( x ) for x in stdin . readline ( ) . strip ( ) . split ( ) ) ] NEW_LINE m = [ int ( x ) for x in stdin . readline ( ) . split ( ) ] NEW_LINE ans = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT m = m [ i ] NEW_LINE ans = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if m [ i + 1 ] < m [ i ] : NEW_LINE INDENT ans += min ( m , m ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT ans = 0 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"references":["def solve ( ) : NEW_LINE INDENT N = input ( ) NEW_LINE ar = [ int ( _ ) for _ in raw_input ( ) . split ( ) ] NEW_LINE diffs = [ a - b for a , b in zip ( ar , ar [ 1 : ] ) ] NEW_LINE eat1 = sum ( max ( x , 0 ) for x in diffs ) NEW_LINE rate = max ( diffs + [ 0 ] ) NEW_LINE eat2 = sum ( min ( x , rate ) for x in ar [ : - 1 ] ) NEW_LINE return eat1 , eat2 NEW_LINE DEDENT T = input ( ) NEW_LINE for t in range ( 1 , T + 1 ) : NEW_LINE INDENT a , b = solve ( ) NEW_LINE print ' Case ▁ # % d : ▁ % d ▁ % d ' % ( t , a , b ) NEW_LINE DEDENT"],"bleu":0.1432155837445908,"rouge_l":0.3778153153153153}
{"id":144,"predictions":["def solve ( s ) : NEW_LINE INDENT if len ( s ) == 1 : NEW_LINE INDENT return s NEW_LINE DEDENT elif len ( s ) == 2 : NEW_LINE INDENT return s NEW_LINE DEDENT elif len ( s ) == 2 : NEW_LINE INDENT return max ( s ) NEW_LINE DEDENT elif len ( s ) == 2 : NEW_LINE INDENT return s NEW_LINE DEDENT elif len ( s ) == 2 : NEW_LINE INDENT return s NEW_LINE DEDENT elif len ( s ) == 2 : NEW_LINE INDENT return s NEW_LINE DEDENT elif len ( s ) == 2 : NEW_LINE INDENT return s NEW_LINE DEDENT elif len ( s ) == 2 : NEW_LINE INDENT return s NEW_LINE DEDENT else : NEW_LINE INDENT return max ( len ( s ) , 0 ) NEW_LINE DEDENT DEDENT return max ( 0 , len ( s ) ) NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT if len ( s ) == 2 : NEW_LINE INDENT return len ( s ) NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return max ( s ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ \" : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for t in range ( t ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE x , y = map ( int , input ( ) . split ( ) ) ) NEW_LINE print \" Case ▁ # % s : ▁ % s \" % ( t + 1 , x , y , x , y ) NEW_LINE DEDENT DEDENT DEDENT"],"references":["import sys NEW_LINE from math import sqrt NEW_LINE class Obj : NEW_LINE INDENT pass NEW_LINE DEDENT def dist ( o1 , o2 ) : NEW_LINE INDENT return ( sqrt ( ( o1 . x - o2 . x ) ** 2 + ( o1 . y - o2 . y ) ** 2 ) + o2 . r + o1 . r ) \/ 2.0 NEW_LINE DEDENT def solve ( a ) : NEW_LINE INDENT n = len ( a ) NEW_LINE if n == 1 : NEW_LINE INDENT return a [ 0 ] . r NEW_LINE DEDENT if n == 2 : NEW_LINE INDENT return max ( a [ 0 ] . r , a [ 1 ] . r ) NEW_LINE DEDENT res = max ( dist ( a [ 0 ] , a [ 1 ] ) , a [ 2 ] . r ) NEW_LINE res = min ( res , max ( dist ( a [ 0 ] , a [ 2 ] ) , a [ 1 ] . r ) ) NEW_LINE res = min ( res , max ( dist ( a [ 1 ] , a [ 2 ] ) , a [ 0 ] . r ) ) NEW_LINE return res NEW_LINE DEDENT nCases = int ( sys . stdin . readline ( ) ) NEW_LINE for c in xrange ( 1 , nCases + 1 ) : NEW_LINE INDENT n = int ( sys . stdin . readline ( ) ) NEW_LINE a = [ ] NEW_LINE for i in xrange ( n ) : NEW_LINE INDENT o = Obj ( ) ; NEW_LINE ( o . x , o . y , o . r ) = [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE a . append ( o ) NEW_LINE DEDENT print \" Case ▁ # \" + str ( c ) + \" : ▁ \" + repr ( solve ( a ) ) NEW_LINE DEDENT"],"bleu":0.173570751451123,"rouge_l":0.36085470957213517}
{"id":145,"predictions":["def solve ( ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT count += count [ i ] NEW_LINE count += count [ i ] NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = [ \" Z \" , ' W ' , ' W ' , ' G ' , ' G ' , ' E ' , ' E ' , ' E ' , ' , ' E ' , ' E ' , ' E ' , ' E ' , ' E ' , ' E ' , ' E ' , ' E ' , ' E ' , ' E ' , ' E ' , ' E ' , ' E ' , ' E ' ] NEW_LINE count = [ ' A ' , ' Z ' , ' A ' , ' E ' , ' F ' , ' E ' , ' F ' , ' E ' , ' F ' , ' E ' , ' E ' , ' E ' , ' E ' , ' E ' , ' E ' , ' E ' ] NEW_LINE count = 0 NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT if count [ i ] != count : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count += count NEW_LINE count -= 1 NEW_LINE DEDENT DEDENT print \" Case ▁ # % d : ▁ % d \" % ( i + 1 , count ) NEW_LINE DEDENT DEDENT"],"references":["import sys NEW_LINE sys . setrecursionlimit ( 100000 ) NEW_LINE inp = sys . stdin NEW_LINE outp = sys . stdout NEW_LINE words = [ \" ZERO \" , \" ONE \" , \" TWO \" , \" THREE \" , \" FOUR \" , \" FIVE \" , \" SIX \" , \" SEVEN \" , \" EIGHT \" , \" NINE \" ] NEW_LINE m = [ ( 0 , ' Z ' ) , ( 2 , ' W ' ) , ( 4 , ' U ' ) , ( 6 , ' X ' ) , ( 7 , ' S ' ) , ( 5 , ' V ' ) , ( 1 , ' O ' ) , ( 3 , ' R ' ) , ( 8 , ' H ' ) , ( 9 , ' E ' ) ] NEW_LINE def solve ( ) : NEW_LINE INDENT x = sys . stdin . readline ( ) . strip ( ) NEW_LINE f = [ 0 ] * 10 NEW_LINE for ( d , c ) in m : NEW_LINE INDENT cnt = x . count ( c ) NEW_LINE f [ d ] += cnt NEW_LINE for c2 in words [ d ] : NEW_LINE INDENT x = x . replace ( c2 , ' ' , cnt ) NEW_LINE DEDENT DEDENT assert x == ' ' NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT outp . write ( ( ' % d ' % i ) * f [ i ] ) NEW_LINE DEDENT print NEW_LINE DEDENT T = int ( inp . readline ( ) ) NEW_LINE for i in range ( T ) : NEW_LINE INDENT outp . write ( ' Case ▁ # % d : ▁ ' % ( i + 1 ) ) NEW_LINE solve ( ) NEW_LINE DEDENT"],"bleu":0.18954721507351718,"rouge_l":0.32601333474441735}
{"id":146,"predictions":["import numpy as np NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res += ( ( n % k ) * ( n % k ) * ( n % k ) ) * ( n % k ) NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( 1 , len ( a ) ) : NEW_LINE INDENT res += ( int ( a [ i ] ) * ( n % k ) * ( n % k ) NEW_LINE DEDENT for i in range ( 1 , len ( a ) ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT print \" Case ▁ # % d : ▁ % d \" % ( i + 1 , res ) NEW_LINE DEDENT"],"references":["import os , sys NEW_LINE def convertToBase ( number , base ) : NEW_LINE INDENT digits = [ ] NEW_LINE mod = base NEW_LINE prevMod = 1 NEW_LINE while number > 0 : NEW_LINE INDENT digit = ( number % mod ) \/ prevMod NEW_LINE digits . append ( digit ) NEW_LINE number = number - digit * prevMod NEW_LINE prevMod = mod NEW_LINE mod *= base NEW_LINE DEDENT if len ( digits ) == 0 : NEW_LINE INDENT digits = [ 0 ] NEW_LINE DEDENT return digits NEW_LINE DEDENT def squareDigits ( digits ) : NEW_LINE INDENT return sum ( [ x * x for x in digits ] ) NEW_LINE DEDENT def isHappy ( number , base ) : NEW_LINE INDENT foundNums = set ( ) NEW_LINE while True : NEW_LINE INDENT digits = convertToBase ( number , base ) NEW_LINE number = squareDigits ( digits ) NEW_LINE if number == 1 : NEW_LINE INDENT return True NEW_LINE DEDENT if number in foundNums : NEW_LINE INDENT return False NEW_LINE DEDENT foundNums . add ( number ) NEW_LINE DEDENT DEDENT def main ( filename ) : NEW_LINE INDENT fileLines = open ( filename , ' r ' ) . readlines ( ) NEW_LINE index = 0 NEW_LINE words = [ ] NEW_LINE numCases = int ( fileLines [ index ] [ : - 1 ] ) NEW_LINE index += 1 NEW_LINE for caseNum in range ( numCases ) : NEW_LINE INDENT bases = [ int ( x ) for x in fileLines [ index ] [ : - 1 ] . split ( ' ▁ ' ) ] NEW_LINE index += 1 NEW_LINE i = 2 NEW_LINE while True : NEW_LINE INDENT happy = True NEW_LINE for base in bases : NEW_LINE INDENT if ( not isHappy ( i , base ) ) : NEW_LINE INDENT happy = False NEW_LINE break NEW_LINE DEDENT DEDENT if happy : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print \" Case ▁ # % d : ▁ % d \" % ( caseNum + 1 , i ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 ] ) NEW_LINE DEDENT"],"bleu":0.07284464676443558,"rouge_l":0.29586305278174035}
{"id":147,"predictions":["import heapq NEW_LINE import sys NEW_LINE n = int ( raw_input ( ) ) NEW_LINE for t in range ( 1 , n + 1 ) : NEW_LINE INDENT a , b = [ [ int ( x ) for x in raw_input ( ) . split ( ) ] NEW_LINE N = [ int ( x ) for x in sys . stdin . readline ( ) . strip ( ) ] NEW_LINE A = [ int ( x ) for x in raw_input ( ) . split ( ) ] NEW_LINE N = [ int ( x ) for x in range ( N ) ] NEW_LINE A = [ int ( x ) for x in sys . stdin . readline ( ) . strip ( ) . split ( ) ) ] NEW_LINE N = int ( sys . stdin . readline ( ) ) NEW_LINE A = [ int ( x ) for x in sys . stdin . readline ( ) . strip ( ) . split ( ) ] NEW_LINE A = [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE B = [ int ( x ) for x in sys . stdin . readline ( ) . strip ( ) . split ( ) ] NEW_LINE a , b = [ int ( x ) for x in sys . stdin . readline ( ) . strip ( ) NEW_LINE for x in range ( 1 , 1 ) : NEW_LINE INDENT a , b = [ int ( x ) for x in sys . stdin . readline ( ) . strip ( ) . split ( ) ] NEW_LINE b = [ int ( x ) for x in sys . stdin . readline ( ) . strip ( ) ] NEW_LINE print \" Case ▁ # % d : ▁ % d \" % ( x + 1 , x ) NEW_LINE DEDENT DEDENT"],"references":["from collections import defaultdict NEW_LINE from heapq import nlargest NEW_LINE def maxSize ( adj , node , parent ) : NEW_LINE INDENT children = adj [ node ] - { parent } NEW_LINE if len ( children ) == 1 : return 1 NEW_LINE return sum ( nlargest ( 2 , ( maxSize ( adj , child , node ) for child in children ) ) ) + 1 NEW_LINE DEDENT for t in range ( int ( input ( ) ) ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE adj = defaultdict ( set ) NEW_LINE for _ in range ( N - 1 ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE adj [ a ] . add ( b ) NEW_LINE adj [ b ] . add ( a ) NEW_LINE DEDENT result = N - max ( maxSize ( adj , root , None ) for root in range ( 1 , N + 1 ) ) NEW_LINE assert 0 <= result <= N NEW_LINE print ( ' Case ▁ # { } : ▁ { } ' . format ( t + 1 , result ) ) NEW_LINE DEDENT"],"bleu":0.1383783934443543,"rouge_l":0.3687523370310358}
{"id":148,"predictions":["n = int ( input ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT l . append ( input ( ) ) NEW_LINE DEDENT l . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if l [ i ] != l [ i ] : NEW_LINE INDENT l [ i ] . append ( l [ i ] + l [ i ] - l [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT l [ i ] = l [ i ] NEW_LINE DEDENT DEDENT return l NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"references":["ops = [ int . __add__ , int . __sub__ ] NEW_LINE ugly_count = 0 NEW_LINE def is_ugly ( num ) : NEW_LINE INDENT return num % 2 == 0 or num % 3 == 0 or num % 5 == 0 or num % 7 == 0 NEW_LINE DEDENT def count_ugly ( left_slice_num , right_slice , op ) : NEW_LINE INDENT global ugly_count NEW_LINE if is_ugly ( op ( left_slice_num , int ( right_slice ) ) ) : NEW_LINE INDENT ugly_count += 1 NEW_LINE DEDENT if len ( right_slice ) > 1 : NEW_LINE INDENT for i in xrange ( - 1 , - len ( right_slice ) , - 1 ) : NEW_LINE INDENT for sub_op in ops : NEW_LINE INDENT count_ugly ( op ( left_slice_num , int ( right_slice [ : i ] ) ) , right_slice [ i : ] , sub_op ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT testsCount = int ( raw_input ( ) ) NEW_LINE for i in xrange ( testsCount ) : NEW_LINE INDENT ugly_count = 0 NEW_LINE count_ugly ( 0 , raw_input ( ) , int . __add__ ) NEW_LINE print \" Case ▁ # % d : ▁ % d \" % ( i + 1 , ugly_count ) NEW_LINE DEDENT DEDENT"],"bleu":0.11048555742494354,"rouge_l":0.32165519706854945}
{"id":149,"predictions":["s = list ( input ( ) ) NEW_LINE s = list ( input ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT l . append ( s [ i ] ) NEW_LINE l . append ( l [ i ] ) NEW_LINE DEDENT for i in range ( len ( l ) ) : NEW_LINE INDENT l [ i ] . append ( l [ i ] ) NEW_LINE DEDENT DEDENT for i in range ( len ( l ) ) : NEW_LINE INDENT l [ i ] = l [ i ] NEW_LINE DEDENT for i in range ( len ( l ) ) : NEW_LINE INDENT l [ i ] . append ( l [ i ] ) NEW_LINE DEDENT for i in range ( len ( l ) ) : NEW_LINE INDENT l [ i ] = l [ i ] NEW_LINE DEDENT for i in range ( len ( l ) ) : NEW_LINE INDENT l [ i ] . append ( l [ i ] ) NEW_LINE DEDENT DEDENT for i in range ( len ( l ) ) ) : NEW_LINE INDENT for j in range ( len ( l ) ) : NEW_LINE INDENT print ( l [ i ] ) NEW_LINE DEDENT DEDENT"],"references":["inp_file = file ( \" B - small . in \" ) NEW_LINE out_file = file ( \" B - small . out \" , \" w \" ) NEW_LINE def solve ( line ) : NEW_LINE INDENT A , B , P = [ int ( c1 ) for c1 in line . split ( \" ▁ \" ) ] NEW_LINE numbers = range ( A , B + 1 ) NEW_LINE sets = range ( B - A + 1 ) NEW_LINE for c1 in primes : NEW_LINE INDENT if c1 < P : continue NEW_LINE if c1 > B \/ 2 + 1 : break NEW_LINE same = [ ] NEW_LINE for c2 in numbers : NEW_LINE INDENT if not c2 % c1 : same . append ( c2 - A ) NEW_LINE DEDENT sets = merge_sets ( sets , same ) NEW_LINE DEDENT counted = [ ] NEW_LINE c2 = 0 NEW_LINE for c1 in sets : NEW_LINE INDENT if not c1 in counted : NEW_LINE INDENT counted . append ( c1 ) NEW_LINE c2 += 1 NEW_LINE DEDENT DEDENT return str ( c2 ) NEW_LINE DEDENT def merge_sets ( sets , same ) : NEW_LINE INDENT to_change = [ sets [ c1 ] for c1 in same ] NEW_LINE for c1 in range ( len ( sets ) ) : NEW_LINE INDENT if sets [ c1 ] in to_change : NEW_LINE INDENT sets [ c1 ] = to_change [ 0 ] NEW_LINE DEDENT DEDENT return sets NEW_LINE DEDENT p_file = file ( \" primes1000 . txt \" ) NEW_LINE primes = [ int ( c1 ) for c1 in p_file . read ( ) . split ( \" \\n \" ) ] NEW_LINE p_file . close ( ) NEW_LINE num = int ( inp_file . readline ( ) ) NEW_LINE for case in range ( num ) : NEW_LINE INDENT line = inp_file . readline ( ) [ : - 1 ] NEW_LINE out_file . write ( \" Case ▁ # % s : ▁ \" % ( case + 1 ) + solve ( line ) + \" \\n \" ) NEW_LINE DEDENT inp_file . close ( ) NEW_LINE out_file . close ( ) NEW_LINE"],"bleu":0.09894849616943929,"rouge_l":0.3374427058637585}
{"id":150,"predictions":["class Point : NEW_LINE INDENT def __init__ ( self , x , y ) : NEW_LINE INDENT self . x = x NEW_LINE self . y = y NEW_LINE DEDENT DEDENT def add ( x , y ) : NEW_LINE INDENT x = x NEW_LINE y = 0 NEW_LINE DEDENT def minus ( a , x , y ) : NEW_LINE INDENT if x == x : NEW_LINE INDENT return ( x - a . x , y ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( x - a . x , y - a ) NEW_LINE DEDENT DEDENT DEDENT def minus ( a , n ) : NEW_LINE INDENT return x - a . x NEW_LINE DEDENT def minus ( n ) : NEW_LINE INDENT return abs ( x - a ) NEW_LINE DEDENT def minus ( n ) : NEW_LINE INDENT return abs ( x - a ) NEW_LINE DEDENT DEDENT def minus ( n ) : NEW_LINE INDENT return abs ( x ) NEW_LINE DEDENT if __name__ == ' _ _ main _ ' : NEW_LINE INDENT"],"references":["import math NEW_LINE eps = 0.0000001 NEW_LINE def Solve ( H , W , D , c ) : NEW_LINE INDENT angles = [ ] NEW_LINE W = W - 2 NEW_LINE H = H - 2 NEW_LINE found = False NEW_LINE y = - 0.5 NEW_LINE for line in c : NEW_LINE INDENT x = - 0.5 NEW_LINE for char in line : NEW_LINE INDENT if char == \" X \" : NEW_LINE INDENT found = True NEW_LINE break NEW_LINE DEDENT x = x + 1 NEW_LINE DEDENT if found : NEW_LINE INDENT break NEW_LINE DEDENT y = y + 1 NEW_LINE DEDENT mx = x NEW_LINE my = y NEW_LINE co = 0 NEW_LINE for xcopy in range ( - 50 , 50 ) : NEW_LINE INDENT for ycopy in range ( - 50 , 50 ) : NEW_LINE INDENT if ( xcopy == 0 and ycopy == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if xcopy % 2 != 0 : NEW_LINE INDENT mx = ( xcopy + 1 ) * ( W ) - x NEW_LINE DEDENT else : NEW_LINE INDENT mx = xcopy * ( W ) + x NEW_LINE DEDENT if ycopy % 2 != 0 : NEW_LINE INDENT my = ( ycopy + 1 ) * ( H ) - y NEW_LINE DEDENT else : NEW_LINE INDENT my = ycopy * ( H ) + y NEW_LINE DEDENT dist = math . sqrt ( ( mx - x ) ** 2 + ( my - y ) ** 2 ) NEW_LINE if dist <= D : NEW_LINE INDENT a = 0 NEW_LINE a = math . atan2 ( ( my - y ) , ( mx - x ) ) NEW_LINE if not hasAngle ( a , angles ) : NEW_LINE INDENT co = co + 1 NEW_LINE angles . append ( a ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return co NEW_LINE DEDENT def hasAngle ( a , angles ) : NEW_LINE INDENT for an in angles : NEW_LINE INDENT if abs ( an - a ) < eps : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT f = open ( ' d . in ' ) NEW_LINE T = int ( f . readline ( ) ) NEW_LINE for t in range ( T ) : NEW_LINE INDENT H , W , D = map ( int , f . readline ( ) . split ( ) ) NEW_LINE c = [ ] NEW_LINE for x in range ( H ) : NEW_LINE INDENT c . append ( f . readline ( ) ) NEW_LINE DEDENT result = Solve ( H , W , D , c ) NEW_LINE print \" Case ▁ # % d : ▁ % s \" % ( t + 1 , result ) NEW_LINE DEDENT"],"bleu":0.060387674055858966,"rouge_l":0.28255129927277783}
{"id":151,"predictions":["import sys NEW_LINE def readline ( ) : NEW_LINE INDENT s = [ ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == s [ i ] : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT s . append ( s [ i ] , i ) NEW_LINE DEDENT DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == s [ i ] : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT return s + \" \\n \" NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT s = sys . stdin . readline ( ) . strip ( ) NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT s = s [ i ] NEW_LINE if s [ i ] == s [ i ] : NEW_LINE INDENT continue NEW_LINE DEDENT if s [ i ] < s [ i ] : NEW_LINE INDENT continue NEW_LINE DEDENT if s [ i ] > s [ i ] : NEW_LINE INDENT continue NEW_LINE DEDENT s = s [ i ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] < s [ i ] : NEW_LINE INDENT continue NEW_LINE DEDENT if s [ i ] > s [ i ] : NEW_LINE INDENT s . append ( s [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT s . sort ( ) NEW_LINE DEDENT if len ( s ) > len ( s ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT DEDENT return 0 NEW_LINE DEDENT if __name__ == \" _ _ main _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE def solve ( n , s ) : NEW_LINE INDENT cnt = 0 NEW_LINE while n > 0 : NEW_LINE INDENT m = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if s [ i ] < s [ m ] : NEW_LINE INDENT m = i NEW_LINE DEDENT DEDENT cnt += min ( m , n - 1 - m ) NEW_LINE n = n - 1 NEW_LINE del s [ m ] NEW_LINE DEDENT return cnt NEW_LINE DEDENT t = int ( sys . stdin . readline ( ) ) NEW_LINE for test_case in range ( 1 , t + 1 ) : NEW_LINE INDENT n = int ( sys . stdin . readline ( ) ) NEW_LINE s = [ int ( y ) for y in sys . stdin . readline ( ) . split ( ) ] NEW_LINE print ( ' Case ▁ # % d : ▁ % d ' % ( test_case , solve ( n , s ) ) ) NEW_LINE DEDENT"],"bleu":0.17477156214408854,"rouge_l":0.37818796674651267}
{"id":152,"predictions":["import sys NEW_LINE T = int ( raw_input ( ) ) NEW_LINE for _ in range ( 1 ) : NEW_LINE INDENT n = int ( raw_input ( ) ) NEW_LINE ali = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] NEW_LINE q = [ [ 0 for _ in range ( n ) ] for _ in range ( n ) ] NEW_LINE q = [ [ 0 ] * n NEW_LINE for _ in range ( n ) ] NEW_LINE for i in xrange ( n ) : NEW_LINE INDENT q [ i + 1 ] [ 0 ] = 0 NEW_LINE q [ i ] [ 1 ] = 0 NEW_LINE for j in xrange ( n ) : NEW_LINE INDENT q [ j ] [ j ] = 1 NEW_LINE q [ i ] [ j ] - q [ i + 1 ] [ j ] NEW_LINE q [ i ] [ j ] = False NEW_LINE DEDENT DEDENT for i in xrange ( n ) : NEW_LINE INDENT if q [ i ] [ j ] == 0 : NEW_LINE INDENT q = q [ i ] [ j ] NEW_LINE q [ i ] [ j ] NEW_LINE q [ i ] [ j ] = False NEW_LINE DEDENT DEDENT for i in xrange ( n ) : NEW_LINE INDENT q [ i ] [ j ] = q [ i ] [ j ] + q [ i ] [ j ] NEW_LINE q [ i ] [ j ] = True NEW_LINE DEDENT DEDENT for i in xrange ( 1 , n ) : NEW_LINE INDENT if q [ i ] [ j ] >= 0 : NEW_LINE INDENT q [ i ] [ j ] = False NEW_LINE DEDENT else : NEW_LINE INDENT q = sys . stdin . readline ( ) . strip ( ) NEW_LINE if q == 0 : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT q = q . readline ( ) NEW_LINE q = q . readline ( ) . strip ( ) NEW_LINE q = q . readline ( ) . strip ( ) . split ( ) NEW_LINE q = q . readline ( )"],"references":["inf = 2 * 10 ** 20 NEW_LINE def inv ( x ) : NEW_LINE INDENT return P - int ( x ) NEW_LINE DEDENT def xl ( l ) : NEW_LINE INDENT return xrange ( len ( l ) ) NEW_LINE DEDENT debug = False NEW_LINE for case in range ( input ( ) ) : NEW_LINE INDENT print \" Case ▁ # \" + str ( case + 1 ) + \" : \" , NEW_LINE P = input ( ) NEW_LINE need = map ( inv , raw_input ( ) . split ( ) ) NEW_LINE costs = [ ] NEW_LINE for i in xrange ( P ) : NEW_LINE INDENT costs = map ( int , raw_input ( ) . split ( ) ) + costs NEW_LINE DEDENT v = [ [ inf for i in xrange ( P + 1 ) ] for j in xrange ( 2 ** ( P + 1 ) - 1 ) ] NEW_LINE if debug : print len ( v ) , 2 ** ( P + 1 ) - 1 , 2 ** P NEW_LINE leaves = 2 ** P - 1 NEW_LINE for ( i , x ) in enumerate ( need ) : NEW_LINE INDENT for j in xrange ( x , P + 1 ) : NEW_LINE INDENT v [ leaves + i ] [ j ] = 0 NEW_LINE DEDENT DEDENT for n in xrange ( leaves - 1 , - 1 , - 1 ) : NEW_LINE INDENT if debug : print n , 2 * n + 1 , 2 * n + 2 NEW_LINE for i in xrange ( P + 1 ) : NEW_LINE INDENT if i == P : NEW_LINE INDENT buy = inf NEW_LINE DEDENT else : NEW_LINE INDENT buy = v [ 2 * n + 1 ] [ i + 1 ] + v [ 2 * n + 2 ] [ i + 1 ] + costs [ n ] NEW_LINE DEDENT skip = v [ 2 * n + 1 ] [ i ] + v [ 2 * n + 2 ] [ i ] NEW_LINE v [ n ] [ i ] = min ( buy , skip ) NEW_LINE DEDENT DEDENT print v [ 0 ] [ 0 ] NEW_LINE if debug : NEW_LINE INDENT print costs NEW_LINE for ( i , x ) in enumerate ( v ) : print i , x NEW_LINE DEDENT DEDENT"],"bleu":0.2606066407325276,"rouge_l":0.37498988918547277}
{"id":153,"predictions":["import sys NEW_LINE def solve ( ) : NEW_LINE INDENT p = sys . argv [ 1 ] NEW_LINE gcd = p NEW_LINE gcd = gcd ( p , q ) NEW_LINE gcd = p \/\/ gcd NEW_LINE if not ( g - 1 ) : NEW_LINE INDENT p \/\/= gcd : NEW_LINE INDENT p \/\/= gcd NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT def solve ( ) : NEW_LINE INDENT p , q , q = map ( int , input ( ) . split ( ) ) NEW_LINE q = q \/\/ gcd ( q , q ) NEW_LINE gcd = q \/\/ gcd ( q ) NEW_LINE q = q \/\/ gcd ( q , q ) NEW_LINE q \/\/= gcd ( q , q ) NEW_LINE q \/\/= gcd NEW_LINE if ( q % q != 0 ) : NEW_LINE INDENT p \/\/= gcd NEW_LINE ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" impossible \" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print \" impossible \" NEW_LINE DEDENT DEDENT"],"references":["import functools NEW_LINE import multiprocessing NEW_LINE import fractions NEW_LINE def pow2 ( x ) : NEW_LINE INDENT return x != 0 and ( ( x & ( x - 1 ) ) == 0 ) NEW_LINE DEDENT def solve ( cs , f ) : NEW_LINE INDENT if not pow2 ( f . denominator ) : NEW_LINE INDENT return cs , ' impossible ' NEW_LINE DEDENT ret = 1 NEW_LINE while f < fractions . Fraction ( 1 , 2 ) : NEW_LINE INDENT ret += 1 NEW_LINE f *= 2 NEW_LINE DEDENT return cs , ret NEW_LINE DEDENT def reducer ( l , result ) : NEW_LINE INDENT l . append ( result ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT T = int ( input ( ) ) NEW_LINE l = [ ] NEW_LINE with multiprocessing . Pool ( processes = 8 ) as pool : NEW_LINE INDENT for cs in range ( T ) : NEW_LINE INDENT f = fractions . Fraction ( input ( ) ) NEW_LINE solve ( cs , f ) NEW_LINE pool . apply_async ( solve , args = ( cs + 1 , f , ) , callback = functools . partial ( reducer , l ) ) NEW_LINE DEDENT pool . close ( ) NEW_LINE pool . join ( ) NEW_LINE DEDENT for cs , result in sorted ( l , key = lambda x : x [ 0 ] ) : NEW_LINE INDENT print ( ' Case ▁ # { } : ▁ { } ' . format ( cs , result ) ) NEW_LINE DEDENT DEDENT"],"bleu":0.12197190196211004,"rouge_l":0.3160621761658031}
{"id":154,"predictions":["import sys NEW_LINE def solve ( a , b ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT if b == 0 : NEW_LINE INDENT return ' B ' NEW_LINE DEDENT if a == b : NEW_LINE INDENT return ' B ' NEW_LINE DEDENT DEDENT if a == b : NEW_LINE INDENT return ' B ' NEW_LINE DEDENT if a == b : NEW_LINE INDENT return ' B ' NEW_LINE DEDENT if a == b : NEW_LINE INDENT return ' B ' NEW_LINE DEDENT return ' ' NEW_LINE DEDENT if __name__ == ' _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"references":["import sys , time NEW_LINE start_time = time . time ( ) NEW_LINE try : NEW_LINE INDENT if len ( sys . argv ) > 1 : NEW_LINE INDENT inname = sys . argv [ 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT inname = input ( \" Enter ▁ input ▁ filename : ▁ \" ) NEW_LINE DEDENT assert inname . endswith ( ' . in ' ) NEW_LINE outname = inname . replace ( ' . in ' , ' . out ' ) NEW_LINE with open ( inname ) as fin : NEW_LINE INDENT with open ( outname , ' w ' ) as fout : NEW_LINE INDENT num_cases = int ( fin . readline ( ) ) NEW_LINE for case_idx in range ( 1 , 1 + num_cases ) : NEW_LINE INDENT if time . time ( ) >= start_time + 5 : NEW_LINE INDENT print ( \" [ = = ▁ Case ▁ % d ▁ of ▁ % d ▁ = = ] \" % ( case_idx , num_cases ) ) NEW_LINE DEDENT N , pD , pG = [ int ( x ) for x in fin . readline ( ) . split ( ) ] NEW_LINE answer = True NEW_LINE N = min ( N , 100 ) NEW_LINE if pG == 100 and pD != 100 : answer = False NEW_LINE if pG == 0 and pD != 0 : answer = False NEW_LINE if all ( ( pD * D ) % 100 for D in range ( 1 , 1 + N ) ) : answer = False NEW_LINE print ( \" Case ▁ # { } : ▁ { } \" . format ( case_idx , ' Possible ' if answer else ' Broken ' ) , file = fout ) NEW_LINE DEDENT DEDENT DEDENT DEDENT except : NEW_LINE INDENT import traceback NEW_LINE print ( \" Exception ▁ caught : \" , file = sys . stderr ) NEW_LINE print ( ' - ' * 60 , file = sys . stderr ) NEW_LINE traceback . print_exc ( file = sys . stderr ) NEW_LINE print ( ' - ' * 60 , file = sys . stderr ) NEW_LINE input ( \" Press ▁ Enter ▁ to ▁ close \" ) NEW_LINE DEDENT else : NEW_LINE INDENT total_time = time . time ( ) - start_time NEW_LINE print ( \" Completed ▁ in ▁ % .1f ▁ seconds \" % total_time , file = sys . stderr ) NEW_LINE time . sleep ( 3 ) NEW_LINE DEDENT"],"bleu":0.009238926778655386,"rouge_l":0.1902078774617068}
{"id":155,"predictions":["import heapq NEW_LINE T = int ( raw_input ( ) ) NEW_LINE for case in range ( 1 , T + 1 ) : NEW_LINE INDENT h , m = map ( int , raw_input ( ) . split ( ) ) NEW_LINE h , m = map ( float , raw_input ( ) . split ( ) ) NEW_LINE H = [ ] NEW_LINE for i in range ( h ) : NEW_LINE INDENT h , h , m = map ( float , raw_input ( ) . split ( ) ) NEW_LINE H . append ( ( ( h , h ) * m ) \/ 3 ) NEW_LINE DEDENT H . append ( h , h ) NEW_LINE DEDENT DEDENT T = int ( raw_input ( ) ) NEW_LINE for i in range ( 1 , H + 1 ) : NEW_LINE INDENT N , H , m = map ( int , raw_input ( ) . split ( ) ) NEW_LINE S = map ( float , raw_input ( ) . split ( ) ) ) NEW_LINE H = [ ] NEW_LINE H = [ ] NEW_LINE for i in range ( H ) : NEW_LINE INDENT H . append ( ( ( ( ( H , H ) ) \/ 3 ) ) NEW_LINE DEDENT for j in range ( H ) : NEW_LINE INDENT if S [ i ] [ j ] < T : NEW_LINE INDENT H . append ( ( ( H + j ) \/ 3 ) ) ) NEW_LINE DEDENT DEDENT DEDENT print \" Case ▁ # % d : ▁ % s \" % ( i + 1 , S ) NEW_LINE DEDENT"],"references":["import os , sys , time , random NEW_LINE time . clock ( ) NEW_LINE sys . stdin = open ( ' C - small - 1 - attempt0 . in ' ) NEW_LINE sys . stdout = open ( ' C - small - 1 - attempt0 . out ' , ' w ' ) NEW_LINE def Work ( ) : NEW_LINE INDENT n = int ( input ( ) . strip ( ) ) NEW_LINE sb = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT d , h , m = map ( int , input ( ) . strip ( ) . split ( ) ) NEW_LINE for j in range ( h ) : NEW_LINE INDENT sb . append ( ( d , 360 \/ ( m + j ) ) ) NEW_LINE DEDENT DEDENT sb . sort ( key = lambda d : d [ - 1 ] , reverse = True ) NEW_LINE if sb [ 0 ] [ 1 ] == sb [ 1 ] [ 1 ] : return 0 NEW_LINE ar1 = ( 360 - sb [ 1 ] [ 0 ] ) \/ sb [ 1 ] [ 1 ] NEW_LINE meet = ( 360 + sb [ 1 ] [ 0 ] - sb [ 0 ] [ 0 ] ) \/ ( sb [ 0 ] [ 1 ] - sb [ 1 ] [ 1 ] ) NEW_LINE if meet <= ar1 + 1e-8 : return 1 NEW_LINE return 0 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT T = int ( input ( ) ) NEW_LINE for i in range ( T ) : NEW_LINE INDENT print ( ' Case ▁ # % d : ▁ % d ' % ( i + 1 , Work ( ) ) ) NEW_LINE DEDENT sys . stderr . write ( ' completed ▁ % .3f \\n ' % time . clock ( ) ) NEW_LINE DEDENT"],"bleu":0.2733996388855026,"rouge_l":0.3816442605997932}
{"id":156,"predictions":["import sys NEW_LINE N = int ( sys . stdin . readline ( ) ) NEW_LINE x = 0 NEW_LINE while True : NEW_LINE INDENT x = str ( x ) NEW_LINE if N == 10 : NEW_LINE INDENT return x NEW_LINE DEDENT x += N NEW_LINE DEDENT return x NEW_LINE DEDENT def solve ( N ) : NEW_LINE INDENT if N == 0 : NEW_LINE INDENT return ' ' . join ( x ) NEW_LINE DEDENT else : NEW_LINE INDENT return ' ' . join ( x ) NEW_LINE DEDENT DEDENT def solve ( N ) : NEW_LINE INDENT if N == 0 : NEW_LINE INDENT return ' ' . join ( x ) NEW_LINE DEDENT if N == 0 : NEW_LINE INDENT return ' ' . join ( [ str ( x ) for x in range ( N ) ] ) NEW_LINE DEDENT else : NEW_LINE INDENT return ' ' . join ( x ) for x in xrange ( N ) NEW_LINE DEDENT DEDENT def solve ( N ) : NEW_LINE INDENT if N == 0 : NEW_LINE INDENT return ' . join ( [ str ( x ) ] ) NEW_LINE DEDENT else : NEW_LINE INDENT return ' ' . join ( x ) NEW_LINE DEDENT DEDENT def solve ( N ) : NEW_LINE INDENT if N == 0 : NEW_LINE INDENT return ' S ' NEW_LINE DEDENT else : NEW_LINE INDENT return ' ' . join ( x ) NEW_LINE DEDENT DEDENT if N == 0 : NEW_LINE INDENT return ' ' . join ( x ) NEW_LINE DEDENT else : NEW_LINE INDENT return ' ' NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ ' : NEW_LINE INDENT DEDENT"],"references":["import sys NEW_LINE def sheep ( N ) : NEW_LINE INDENT if N == 0 : return \" INSOMNIA \" NEW_LINE d = 0 ; t = N NEW_LINE while 1 : NEW_LINE INDENT for x in str ( t ) : d |= 1 << int ( x ) NEW_LINE if d == 1023 : return t NEW_LINE t += N NEW_LINE DEDENT DEDENT case = 0 NEW_LINE for x in sys . stdin : NEW_LINE INDENT if case > 0 : NEW_LINE INDENT N = int ( x . strip ( ) ) NEW_LINE print \" Case ▁ # % d : \" % case , sheep ( N ) NEW_LINE DEDENT case += 1 NEW_LINE DEDENT"],"bleu":0.13876065626360093,"rouge_l":0.3293277603622432}
{"id":157,"predictions":["import sys NEW_LINE def readline ( ) : NEW_LINE INDENT s = input ( ) NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT s . sort ( ) NEW_LINE DEDENT return s NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT s = [ ] NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT s . append ( s [ i : i + 1 ] + s [ i : ] ) NEW_LINE DEDENT s . sort ( ) NEW_LINE S . sort ( ) NEW_LINE S . sort ( ) NEW_LINE S . sort ( ) NEW_LINE S . sort ( ) NEW_LINE S . sort ( ) NEW_LINE for i in range ( 0 , len ( S ) ) : NEW_LINE INDENT S . sort ( ) NEW_LINE S . sort ( ) NEW_LINE S . sort ( ) NEW_LINE t = S [ 0 ] NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , T ) : NEW_LINE INDENT for j in range ( 1 , T ) : NEW_LINE INDENT if S [ i ] + T [ j ] < T [ j ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"references":["import collections NEW_LINE import sys NEW_LINE if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT f = sys . stdin NEW_LINE if len ( sys . argv ) >= 2 : NEW_LINE INDENT fn = sys . argv [ 1 ] NEW_LINE if fn != ' - ' : NEW_LINE INDENT f = open ( fn ) NEW_LINE DEDENT DEDENT T = int ( f . readline ( ) ) NEW_LINE for _T in xrange ( T ) : NEW_LINE INDENT N , X = map ( int , f . readline ( ) . split ( ) ) NEW_LINE disks = map ( int , f . readline ( ) . split ( ) ) NEW_LINE assert len ( disks ) == N NEW_LINE disks . sort ( ) NEW_LINE disks = collections . deque ( disks ) NEW_LINE r = 0 NEW_LINE while disks : NEW_LINE INDENT x1 = disks . pop ( ) NEW_LINE if disks and x1 + disks [ 0 ] <= X : NEW_LINE INDENT disks . popleft ( ) NEW_LINE DEDENT r += 1 NEW_LINE DEDENT print \" Case ▁ # % d : ▁ % d \" % ( _T + 1 , r ) NEW_LINE DEDENT DEDENT"],"bleu":0.19190125590866233,"rouge_l":0.38870383779869655}
{"id":158,"predictions":["import sys NEW_LINE from collections import defaultdict NEW_LINE T = int ( sys . stdin . readline ( ) . strip ( ) ) NEW_LINE for i in xrange ( 2 * T + 1 ) : NEW_LINE INDENT N = int ( sys . stdin . readline ( ) . strip ( ) ) NEW_LINE a = [ ] NEW_LINE for i in xrange ( 2 * N - 1 ) : NEW_LINE INDENT if a [ i ] % 2 != 0 : NEW_LINE INDENT a . append ( a [ i ] + 1 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT ans = 1 NEW_LINE DEDENT DEDENT for i in xrange ( 1 , T ) : NEW_LINE INDENT if a [ i ] % 2 == 0 : NEW_LINE INDENT ans = i NEW_LINE DEDENT DEDENT print \" Case ▁ # % d : ▁ % d \" % ( i , ans ) NEW_LINE DEDENT"],"references":["t = int ( raw_input ( ) ) NEW_LINE for cas in xrange ( 1 , t + 1 ) : NEW_LINE INDENT n = int ( raw_input ( ) ) NEW_LINE ct = dict ( zip ( xrange ( 1 , 2501 ) , [ 0 for i in xrange ( 1 , 2501 ) ] ) ) NEW_LINE for i in xrange ( 1 , 2 * n ) : NEW_LINE INDENT nums = map ( int , raw_input ( ) . split ( ) ) NEW_LINE for num in nums : NEW_LINE INDENT ct [ num ] += 1 NEW_LINE DEDENT DEDENT ans = [ ] NEW_LINE for i in ct : NEW_LINE INDENT if ct [ i ] % 2 == 1 : NEW_LINE INDENT ans . append ( i ) NEW_LINE DEDENT DEDENT ans . sort ( ) NEW_LINE ans = \" ▁ \" . join ( map ( str , ans ) ) NEW_LINE print \" Case ▁ # { } : ▁ { } \" . format ( cas , ans ) NEW_LINE DEDENT"],"bleu":0.3320170058488512,"rouge_l":0.4976757423394365}
{"id":159,"predictions":["def solve ( s , l , r ) : NEW_LINE INDENT if l % r == 0 : NEW_LINE INDENT return s NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT DEDENT DEDENT"],"references":["A = 3 NEW_LINE B = 1 NEW_LINE n = 1 NEW_LINE tmp = 0 NEW_LINE X = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] NEW_LINE Y = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] NEW_LINE while n < 31 : NEW_LINE INDENT X [ n ] = A NEW_LINE Y [ n ] = B NEW_LINE tmp = 3 * A + B * 5 NEW_LINE B = A + 3 * B NEW_LINE A = tmp NEW_LINE n = n + 1 NEW_LINE DEDENT d = 22360679774997896964091736687312762354406183596115257242708972454105209256378048 NEW_LINE N = input ( ) NEW_LINE n = 0 NEW_LINE while n < N : NEW_LINE INDENT n = n + 1 NEW_LINE f = input ( ) NEW_LINE p = X [ f ] + int ( Y [ f ] * d \/ 10000000000000000000000000000000000000000000000000000000000000000000000000000000 ) NEW_LINE print \" Case ▁ # % d : ▁ % .3d \" % ( n , int ( p ) % 1000 ) NEW_LINE DEDENT"],"bleu":0.0000911899905040307,"rouge_l":0.06599180897921336}
{"id":160,"predictions":["import sys NEW_LINE sys . setrecursionlimit ( 10 ** 5 ) NEW_LINE K = int ( input ( ) ) NEW_LINE for _ in range ( 1 ) : NEW_LINE INDENT C , D , L , V = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE L = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE L = [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE R = [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE L = [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE L = [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE R = [ int ( x ) for x in sys . stdin . readline ( ) . strip ( ) . split ( ) ] NEW_LINE L = [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) . split ( ) ] NEW_LINE L = [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE R = [ int ( x ) for x in stdin . readline ( ) . split ( ) ] NEW_LINE print \" Case ▁ # % d : ▁ % s \" % ( t + 1 , L ) NEW_LINE DEDENT DEDENT"],"references":["testSum = input ( ) NEW_LINE for test in xrange ( testSum ) : NEW_LINE INDENT c , d , v = map ( int , raw_input ( ) . split ( ) ) NEW_LINE coins = map ( int , raw_input ( ) . split ( ) ) NEW_LINE ansCoins = [ ] NEW_LINE now = 0 NEW_LINE ans = 0 NEW_LINE i = 0 NEW_LINE while now < v : NEW_LINE INDENT if i < len ( coins ) and ( coins [ i ] <= now + 1 ) : NEW_LINE INDENT ansCoins . append ( coins [ i ] ) NEW_LINE now = now + coins [ i ] * c NEW_LINE i = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ansCoins . append ( now + 1 ) NEW_LINE ans = ans + 1 NEW_LINE now = now + ( now + 1 ) * c NEW_LINE DEDENT DEDENT print \" Case ▁ # \" + str ( test + 1 ) + \" : \" , ans NEW_LINE DEDENT"],"bleu":0.10031812489985374,"rouge_l":0.3415856174476864}
{"id":161,"predictions":["n = int ( input ( ) ) NEW_LINE g = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] NEW_LINE"],"references":["from __future__ import division NEW_LINE import collections NEW_LINE import itertools NEW_LINE import sys NEW_LINE import copy NEW_LINE class gcj : NEW_LINE INDENT IN = sys . stdin NEW_LINE number = 0 NEW_LINE @ classmethod NEW_LINE def case ( cls ) : NEW_LINE INDENT cls . number += 1 NEW_LINE return ' Case ▁ # % d : ' % cls . number NEW_LINE DEDENT @ classmethod NEW_LINE def line ( cls , type = str ) : NEW_LINE INDENT line = cls . IN . readline ( ) NEW_LINE return type ( line . strip ( ' \\n ' ) ) NEW_LINE DEDENT @ classmethod NEW_LINE def splitline ( cls , type = str ) : NEW_LINE INDENT line = cls . IN . readline ( ) NEW_LINE return [ type ( x ) for x in line . split ( ) ] NEW_LINE DEDENT DEDENT def go ( ) : NEW_LINE INDENT c = gcj . line ( int ) NEW_LINE for _ in xrange ( c ) : NEW_LINE INDENT r = gcj . line ( int ) NEW_LINE grid = [ [ 0 ] * 101 for _ in xrange ( 101 ) ] NEW_LINE for _ in xrange ( r ) : NEW_LINE INDENT x1 , y1 , x2 , y2 = gcj . splitline ( int ) NEW_LINE for x in xrange ( x1 , x2 + 1 ) : NEW_LINE INDENT for y in xrange ( y1 , y2 + 1 ) : NEW_LINE INDENT grid [ x ] [ y ] = 1 NEW_LINE DEDENT DEDENT DEDENT print gcj . case ( ) , solve ( grid ) NEW_LINE DEDENT DEDENT def solve ( grid ) : NEW_LINE INDENT t = 0 NEW_LINE while True : NEW_LINE INDENT done = True NEW_LINE for x in xrange ( 100 , 0 , - 1 ) : NEW_LINE INDENT for y in xrange ( 100 , 0 , - 1 ) : NEW_LINE INDENT if grid [ x ] [ y ] == 1 : NEW_LINE INDENT done = False NEW_LINE DEDENT if grid [ x - 1 ] [ y ] == grid [ x ] [ y - 1 ] : NEW_LINE INDENT grid [ x ] [ y ] = grid [ x ] [ y - 1 ] NEW_LINE DEDENT DEDENT DEDENT if done : NEW_LINE INDENT return t NEW_LINE DEDENT t += 1 NEW_LINE DEDENT DEDENT go ( ) NEW_LINE"],"bleu":0.000006736362224610136,"rouge_l":0.09738186462324394}
{"id":162,"predictions":["T = int ( raw_input ( ) ) NEW_LINE for _ in range ( T ) : NEW_LINE INDENT a , b = map ( int , raw_input ( ) . split ( ) ) NEW_LINE if a % b == 0 : NEW_LINE INDENT return a + b % b NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT T = int ( raw_input ( ) ) NEW_LINE for T in range ( T ) : NEW_LINE INDENT T = int ( raw_input ( ) ) NEW_LINE a = [ int ( x ) for x in raw_input ( ) . split ( ) ] NEW_LINE a = [ int ( x ) for x in raw_input ( ) . split ( ) ] NEW_LINE b = [ int ( x ) for x in raw_input ( ) . split ( ) ] NEW_LINE ans = solve ( a ) NEW_LINE print \" Case ▁ # % d : ▁ % d \" % ( t + 1 ) + 1 NEW_LINE DEDENT DEDENT"],"references":["import os , sys , time , random NEW_LINE time . clock ( ) NEW_LINE sys . stdin = open ( ' A - large . in ' ) NEW_LINE sys . stdout = open ( ' A - large . out ' , ' w ' ) NEW_LINE def flip ( x ) : NEW_LINE INDENT return int ( str ( x ) [ : : - 1 ] . lstrip ( '0' ) ) NEW_LINE DEDENT def Preprocess ( ) : NEW_LINE INDENT global f NEW_LINE n = 100002 NEW_LINE f = [ n ] * n NEW_LINE f [ 1 ] = 1 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT f [ i + 1 ] = min ( f [ i + 1 ] , f [ i ] + 1 ) NEW_LINE if flip ( i ) < n : NEW_LINE INDENT f [ flip ( i ) ] = min ( f [ flip ( i ) ] , f [ i ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT def GetCheckPoint ( x ) : NEW_LINE INDENT l = len ( str ( x ) ) NEW_LINE if str ( x ) . endswith ( '0' * ( l - l \/\/ 2 ) ) : NEW_LINE INDENT return GetCheckPoint ( x - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ret = int ( str ( x ) [ : l \/\/ 2 ] + '0' * ( l - l \/\/ 2 - 1 ) + '1' ) NEW_LINE if str ( x ) [ : l \/\/ 2 ] == '1' + '0' * ( l \/\/ 2 - 1 ) : NEW_LINE INDENT return GetCheckPoint ( ret - 2 ) NEW_LINE DEDENT return ret NEW_LINE DEDENT DEDENT def Calc ( n ) : NEW_LINE INDENT if n < 100 : return f [ n ] NEW_LINE cp = GetCheckPoint ( n ) NEW_LINE return Calc ( flip ( cp ) ) + 1 + n - cp NEW_LINE DEDENT def Work ( ) : NEW_LINE INDENT n = int ( input ( ) . strip ( ) ) NEW_LINE return Calc ( n ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT Preprocess ( ) NEW_LINE T = int ( input ( ) ) NEW_LINE for i in range ( T ) : NEW_LINE INDENT print ( ' Case ▁ # % d : ▁ % d ' % ( i + 1 , Work ( ) ) ) NEW_LINE DEDENT sys . stderr . write ( ' completed ▁ % .3f \\n ' % time . clock ( ) ) NEW_LINE DEDENT"],"bleu":0.08119125671625703,"rouge_l":0.2807725158963652}
{"id":163,"predictions":["import sys NEW_LINE def readint ( ) : NEW_LINE INDENT return sys . stdin . readline ( ) . strip ( ) NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT sys . argv = sys . argv [ 1 ] NEW_LINE for _ in range ( int ( sys . stdin . readline ( ) ) ) : NEW_LINE INDENT n = int ( sys . stdin . readline ( ) ) NEW_LINE for _ in range ( n ) : NEW_LINE INDENT s = input ( ) NEW_LINE for _ in range ( n ) : NEW_LINE INDENT a , b = map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) NEW_LINE s = s . split ( ) NEW_LINE s = s . split ( ) NEW_LINE for i in range ( a ) : NEW_LINE INDENT s . append ( s ) NEW_LINE DEDENT s = s . pop ( ) NEW_LINE if s [ i ] < s [ i ] : NEW_LINE INDENT s . append ( s [ i ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT print \" Case ▁ # % s : ▁ % s \" % ( s + 1 , s ) ) NEW_LINE DEDENT DEDENT main ( ) NEW_LINE"],"references":["import sys NEW_LINE from itertools import zip_longest as zip NEW_LINE T = int ( sys . stdin . readline ( ) . strip ( ) ) NEW_LINE for t in range ( T ) : NEW_LINE INDENT A , B , K = tuple ( int ( i ) for i in sys . stdin . readline ( ) . strip ( ) . split ( ) ) NEW_LINE cnt = 0 NEW_LINE for a in range ( A ) : NEW_LINE INDENT for b in range ( B ) : NEW_LINE INDENT if a & b < K : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT print ( \" Case ▁ # % d : ▁ % d \" % ( t + 1 , cnt ) ) NEW_LINE DEDENT"],"bleu":0.27294854374495536,"rouge_l":0.5148644846666042}
{"id":164,"predictions":["t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT l = l [ i ] NEW_LINE l = l [ i ] NEW_LINE for j in range ( len ( l ) ) : NEW_LINE INDENT if l [ j ] > l [ j ] : NEW_LINE INDENT l . append ( l [ j ] , l [ j ] ) NEW_LINE l [ j ] = l [ j ] NEW_LINE l [ j ] = l [ j ] NEW_LINE l [ j ] = l [ j ] NEW_LINE DEDENT DEDENT DEDENT print \" Case ▁ # % d : ▁ % d \" % ( t + 1 , l ) ) NEW_LINE"],"references":["import sys NEW_LINE def ntests ( L , P , C ) : NEW_LINE INDENT ratio = P * 1.0 \/ L NEW_LINE if ratio <= C : return 0 NEW_LINE if L == 1 and P == 3 : return 1 NEW_LINE testpoint = int ( L * ( ratio ** 0.5 ) ) NEW_LINE count = max ( 1 + ntests ( L , testpoint , C ) , 1 + ntests ( testpoint , P , C ) ) NEW_LINE if ( testpoint * testpoint == L * P or testpoint + 1 == P ) : NEW_LINE INDENT return count NEW_LINE DEDENT count2 = max ( 1 + ntests ( L , testpoint + 1 , C ) , 1 + ntests ( testpoint + 1 , P , C ) ) NEW_LINE return min ( count , count2 ) NEW_LINE DEDENT infile = sys . stdin NEW_LINE T = int ( infile . readline ( ) . strip ( ) ) NEW_LINE for i in xrange ( T ) : NEW_LINE INDENT L , P , C = map ( int , infile . readline ( ) . strip ( ) . split ( ) ) NEW_LINE result = ntests ( L , P , C ) NEW_LINE print ( \" Case ▁ # % d : ▁ % s \" % ( i + 1 , str ( result ) ) ) NEW_LINE DEDENT"],"bleu":0.16185768892019342,"rouge_l":0.2992990654205608}
{"id":165,"predictions":["import sys NEW_LINE def solve ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT a = list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE a = sorted ( a ) NEW_LINE b = sorted ( b ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] < b [ i ] : NEW_LINE INDENT a += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT n = int ( sys . stdin . readline ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT a = list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) NEW_LINE ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] < b [ i ] : NEW_LINE INDENT ans . append ( a [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( a [ i ] ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"references":["def war ( n , k ) : NEW_LINE INDENT n = [ float ( block ) for block in n . split ( \" ▁ \" ) ] NEW_LINE k = [ float ( block ) for block in k . split ( \" ▁ \" ) ] NEW_LINE points = 0 NEW_LINE n = reversed ( sorted ( n ) ) NEW_LINE for nblock in n : NEW_LINE INDENT if nblock > max ( k ) : NEW_LINE INDENT points += 1 NEW_LINE k . remove ( min ( k ) ) NEW_LINE DEDENT else : NEW_LINE INDENT k . remove ( min ( [ block for block in k if block > nblock ] ) ) NEW_LINE DEDENT DEDENT return str ( points ) NEW_LINE DEDENT def dwar ( n , k ) : NEW_LINE INDENT n = [ float ( block ) for block in n . split ( \" ▁ \" ) ] NEW_LINE k = [ float ( block ) for block in k . split ( \" ▁ \" ) ] NEW_LINE points = 0 NEW_LINE n = sorted ( n ) NEW_LINE for nblock in n : NEW_LINE INDENT if nblock > min ( k ) : NEW_LINE INDENT points += 1 NEW_LINE k . remove ( min ( k ) ) NEW_LINE DEDENT else : NEW_LINE INDENT k . remove ( max ( k ) ) NEW_LINE DEDENT DEDENT return str ( points ) NEW_LINE DEDENT input_text = open ( \" input . in \" ) NEW_LINE lines = input_text . readlines ( ) NEW_LINE input_text . close ( ) NEW_LINE with open ( \" output \" , \" a \" ) as outputfile : NEW_LINE INDENT for num in range ( 0 , int ( lines [ 0 ] ) ) : NEW_LINE INDENT outputfile . write ( \" Case ▁ # \" + str ( num + 1 ) + \" : ▁ \" + dwar ( lines [ num * 3 + 2 ] , lines [ num * 3 + 3 ] ) + \" ▁ \" + war ( lines [ num * 3 + 2 ] , lines [ num * 3 + 3 ] ) + \" \\n \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.17998322158519786,"rouge_l":0.3585853797288328}
{"id":166,"predictions":["import sys NEW_LINE T = int ( sys . stdin . readline ( ) ) NEW_LINE for t in xrange ( 1 , T + 1 ) : NEW_LINE INDENT L , T = map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) NEW_LINE N , T = map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) NEW_LINE P = [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE T = [ int ( x ) for x in sys . stdin . readline ( ) . strip ( ) . split ( ) ] NEW_LINE T = [ int ( x ) for x in range ( T ) ] NEW_LINE for t in range ( N ) : NEW_LINE INDENT t -= t * 2 NEW_LINE t -= t * 2 NEW_LINE DEDENT else : NEW_LINE INDENT t -= t * 2 NEW_LINE DEDENT DEDENT return t NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT T = int ( sys . stdin . readline ( ) . strip ( ) ) NEW_LINE for t in range ( 1 , T + 1 ) : NEW_LINE INDENT print \" Case ▁ # % d : ▁ % d \\n \" % ( t + 1 ) NEW_LINE DEDENT DEDENT"],"references":["import sys NEW_LINE from itertools import islice NEW_LINE def solve ( L , t , N , C , a ) : NEW_LINE INDENT tot_dist = 0 NEW_LINE eff_dists = [ ] NEW_LINE for s in xrange ( N ) : NEW_LINE INDENT d = a [ s % len ( a ) ] NEW_LINE if tot_dist + d <= t : NEW_LINE INDENT eff_dists . append ( ( d , 0 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT if tot_dist >= t : NEW_LINE INDENT eff_dists . append ( ( d , d ) ) NEW_LINE DEDENT else : NEW_LINE INDENT eff_dists . append ( ( d , d - ( t - tot_dist ) ) ) NEW_LINE DEDENT DEDENT tot_dist += d NEW_LINE DEDENT tot_time = 0 NEW_LINE for dist , eff_dist in sorted ( eff_dists , key = lambda x : x [ 1 ] , reverse = True ) : NEW_LINE INDENT if L > 0 : NEW_LINE INDENT tot_time += eff_dist + 2 * ( dist - eff_dist ) NEW_LINE L -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT tot_time += dist * 2 NEW_LINE DEDENT DEDENT return tot_time \/\/ 2 NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT T = int ( next ( sys . stdin ) ) NEW_LINE for test in xrange ( 1 , T + 1 ) : NEW_LINE INDENT print >> sys . stderr , test NEW_LINE line = next ( sys . stdin ) NEW_LINE L , t , N , C , a = line . split ( None , 4 ) NEW_LINE L , t , N , C = map ( int , ( L , t , N , C ) ) NEW_LINE a = list ( int ( ai ) * 2 for ai in a . split ( ) ) NEW_LINE print \" Case ▁ # % s : ▁ % s \" % ( test , solve ( L , t , N , C , a ) ) NEW_LINE DEDENT DEDENT main ( ) NEW_LINE"],"bleu":0.21174841629685548,"rouge_l":0.34454094953908454}
{"id":167,"predictions":["import math NEW_LINE K = int ( input ( ) ) NEW_LINE B = int ( input ( ) ) NEW_LINE for k in range ( 1 , K + 1 ) : NEW_LINE INDENT K , S = map ( int , raw_input ( ) . split ( ) ) NEW_LINE s = [ 0 for i in range ( K ) ] NEW_LINE for k in range ( K ) : NEW_LINE INDENT s [ k ] += 1 NEW_LINE DEDENT for k in range ( K ) : NEW_LINE INDENT s [ k ] += 1 NEW_LINE DEDENT DEDENT return \" Case ▁ # % s : ▁ \" % s \" % ( k , s ) NEW_LINE DEDENT KAK = int ( raw_input ( ) ) NEW_LINE for i in range ( K ) : NEW_LINE INDENT KAK = [ int ( i ) for i in raw_input ( ) . split ( ) ] NEW_LINE P = [ int ( i ) for i in range ( K ) ] NEW_LINE for i in range ( K ) : NEW_LINE INDENT for j in range ( K ) : NEW_LINE INDENT if K [ i ] [ j ] == K [ i ] : NEW_LINE INDENT P [ i ] [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return \" IMPOSSIBLE \" NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT K = int ( raw_input ( ) ) NEW_LINE for k in range ( 1 , K + 1 ) : NEW_LINE INDENT print \" Case ▁ # % d : ▁ % ( i , k + 1 ) NEW_LINE DEDENT DEDENT"],"references":["import sys NEW_LINE import math NEW_LINE from collections import defaultdict NEW_LINE f = open ( ' B - large . in ' ) NEW_LINE tests = int ( f . readline ( ) ) NEW_LINE def getOffset ( keys , target ) : NEW_LINE INDENT s = set ( list ( keys ) ) NEW_LINE for c in target : NEW_LINE INDENT if c not in s : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT offset = 1 NEW_LINE while offset < len ( target ) : NEW_LINE INDENT if target [ : len ( target ) - offset ] == target [ offset : ] : NEW_LINE INDENT break NEW_LINE DEDENT offset += 1 NEW_LINE DEDENT return offset NEW_LINE DEDENT def getExp ( keys , target , s ) : NEW_LINE INDENT d = defaultdict ( lambda : 0.0 ) NEW_LINE for c in keys : NEW_LINE INDENT d [ c ] += 1.0 \/ len ( keys ) NEW_LINE DEDENT tot = 1.0 NEW_LINE for c in target : NEW_LINE INDENT tot *= d [ c ] NEW_LINE DEDENT return tot * ( s - len ( target ) + 1 ) NEW_LINE DEDENT for t in xrange ( tests ) : NEW_LINE INDENT k , l , s = map ( int , f . readline ( ) . rstrip ( ) . split ( ) ) NEW_LINE keys = f . readline ( ) . rstrip ( ) NEW_LINE target = f . readline ( ) . rstrip ( ) NEW_LINE offset = getOffset ( keys , target ) NEW_LINE if offset == 0 : NEW_LINE INDENT print \" Case ▁ # \" + str ( t + 1 ) + \" : ▁ 0.0\" NEW_LINE continue NEW_LINE DEDENT needed = 1 + ( s - len ( target ) ) \/\/ offset NEW_LINE ans = max ( 0.0 , needed - getExp ( keys , target , s ) ) NEW_LINE if ans < 0.000000001 : NEW_LINE INDENT ans = 0.0 NEW_LINE DEDENT print \" Case ▁ # \" + str ( t + 1 ) + \" : ▁ \" + str ( ans ) NEW_LINE DEDENT"],"bleu":0.1947124280130949,"rouge_l":0.3667274429606268}
{"id":168,"predictions":["import sys NEW_LINE def compute ( ) : NEW_LINE INDENT return sys . stdin . readline ( ) . strip ( ) NEW_LINE DEDENT def solve ( s ) : NEW_LINE INDENT if s == 0 : NEW_LINE INDENT return '0' NEW_LINE DEDENT return '0' * s NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT n = int ( sys . stdin . readline ( ) ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT a , b = map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) NEW_LINE s += ' E ' NEW_LINE s += ' E ' NEW_LINE s += ' E ' NEW_LINE DEDENT return ' ' . join ( sorted ( s ) ) NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT if s : NEW_LINE INDENT return ' IMPOSSIBLE ' NEW_LINE DEDENT else : NEW_LINE INDENT return ' B - small ' NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = sys . stdin . readline ( ) . strip ( ) NEW_LINE f = open ( s ) NEW_LINE for i in xrange ( 1 , len ( s ) ) : NEW_LINE INDENT f = open ( s ) NEW_LINE s = [ ' W ' , ' S ' , ' S ' , ' E ' , ' E ' , ' S ' , ' E ' , ' E ' , ' E ' , ' E ' , ' E ' , ' E ' , ' E ' ] NEW_LINE for i in xrange ( len ( s ) ) : NEW_LINE INDENT s += s + ' E ' NEW_LINE DEDENT DEDENT DEDENT print \" Case ▁ # % d : ▁ % s \" % ( s + 1 , s ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE T = int ( sys . stdin . readline ( ) ) NEW_LINE for ca in xrange ( 1 , T + 1 ) : NEW_LINE INDENT [ X , Y ] = [ int ( v ) for v in sys . stdin . readline ( ) . split ( \" ▁ \" ) ] NEW_LINE print \" Case ▁ # % d : ▁ \" % ca , NEW_LINE if X > 0 : NEW_LINE INDENT for i in range ( X ) : NEW_LINE INDENT sys . stdout . write ( \" W \" ) , NEW_LINE sys . stdout . write ( \" E \" ) , NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT X = - X NEW_LINE for i in range ( X ) : NEW_LINE INDENT sys . stdout . write ( \" E \" ) , NEW_LINE sys . stdout . write ( \" W \" ) , NEW_LINE DEDENT DEDENT if Y > 0 : NEW_LINE INDENT for i in range ( Y ) : NEW_LINE INDENT sys . stdout . write ( \" S \" ) , NEW_LINE sys . stdout . write ( \" N \" ) , NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT Y = - Y NEW_LINE for i in range ( Y ) : NEW_LINE INDENT sys . stdout . write ( \" N \" ) , NEW_LINE sys . stdout . write ( \" S \" ) , NEW_LINE DEDENT DEDENT print \" \" NEW_LINE DEDENT"],"bleu":0.23831071882028657,"rouge_l":0.3439585730724971}
{"id":169,"predictions":["n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l . sort ( ) print ( ' . join ( l ) ) NEW_LINE"],"references":["import re     def is_int ( s : str ) -> bool : if len ( s ) > 0 and ( s [ 0 ] == \"0\" and len ( s ) > 1 ) : return False else : try : int ( s ) return True except : return False     def partition ( pred , iterable ) : trues = [ ] falses = [ ] for item in iterable : if pred ( item ) : trues . append ( item ) else : falses . append ( item ) return trues , falses     def print_ans ( s ) : if len ( s ) > 0 : print ( \" \\ \" { } \\ \" \" . format ( \" , \" . join ( s ) ) ) else : print ( \" - \" )     s = re . split ( \" ; | , \" , input ( ) ) s_int , s_str = partition ( is_int , s ) print_ans ( s_int ) print_ans ( s_str ) NEW_LINE"],"bleu":0.008054630877132773,"rouge_l":0.19112271540469974}
{"id":170,"predictions":["n , m = map ( int , input ( ) . split ( ) ) arr = [ ] for _ in range ( n ) : a , b = map ( int , input ( ) . split ( ) ) arr . append ( a )   for i in range ( n ) : for j in range ( m ) : if a [ i ] [ j ] == 0 : arr [ i ] [ j ] = 1 if arr [ i ] [ j ] == 2 : arr [ i ] [ j ] = 1 if arr [ i ] [ j ] == 2 : arr [ i ] [ j ] = 1 if arr [ i ] [ j ] == 2 : arr [ i ] [ j ] = 1 else : arr [ i ] [ j ] = 1 if arr [ i ] [ j ] == 2 : arr [ i ] [ j ] = 1 if arr [ i ] [ j ] == 2 : arr [ i ] [ j ] = arr [ i ] [ j ] = 1 if arr [ i ] [ j ] == 2 : print ( arr [ i ] [ j ] ) else : print ( arr [ i ] [ j ] ) NEW_LINE"],"references":["def solve ( ) : b , p , f = map ( int , input ( ) . split ( ) ) h , c = map ( int , input ( ) . split ( ) )   NEW_LINE"],"bleu":0.10819665679261797,"rouge_l":0.24478330658105943}
{"id":171,"predictions":["t = int ( input ( ) ) for _ in range ( t ) : n , m = map ( int , input ( ) . split ( ) ) if ( n == 0 ) : print ( \" : \" ) else : print ( \" : \" ) NEW_LINE"],"references":["a = input ( ) . split ( ' : ' ) b = input ( ) . split ( ' : ' )       x = int ( a [ 0 ] ) * 60 + int ( a [ 1 ] ) y = int ( b [ 0 ] ) * 60 + int ( b [ 1 ] )     if y > x : x = ( ( int ( a [ 0 ] ) + 24 ) * 60 ) + int ( a [ 1 ] )     z = x - y   hr = str ( z \/\/ 60 ) . rjust ( 2 , '0' ) z %= 60 mi = str ( z ) . rjust ( 2 , '0' )   print ( f \" { hr } : { mi } \" )   NEW_LINE"],"bleu":0.042862588000608624,"rouge_l":0.2593081207856934}
{"id":172,"predictions":["n , m , a , b = [ int ( x ) for x in input ( ) . split ( ) ] a = [ int ( x ) for x in input ( ) . split ( ) ] b = [ int ( x ) for x in input ( ) . split ( ) ] cnt = 0 for i in range ( n ) : if b [ i ] > b [ i ] : cnt += abs ( b [ i ] - b [ i ] ) else : cnt += 1 print ( cnt ) NEW_LINE"],"references":["n = int ( input ( ) ) nn = list ( map ( int , input ( ) . split ( ) ) ) m = int ( input ( ) ) mm = list ( map ( int , input ( ) . split ( ) ) ) nn . sort ( ) mm . sort ( ) i = 0j = 0 count = 0   while i < n and j < m : if abs ( nn [ i ] - mm [ j ] ) <= 1 : count += 1 i += 1 j += 1 elif nn [ i ] < mm [ j ] : i += 1 else : j += 1 print ( count ) NEW_LINE"],"bleu":0.20194497374153533,"rouge_l":0.46455275546939906}
{"id":173,"predictions":["n = int ( input ( ) ) if n % 2 == 0 : print ( \" No \" ) else : print ( \" Yes \" ) NEW_LINE"],"references":["n = int ( input ( ) )     if n == 1 : print ( ' Ehab ' ) elif n % 2 == 0 : print ( ' Mahmoud ' ) else : print ( ' Ehab ' ) NEW_LINE"],"bleu":0.4615094082817601,"rouge_l":0.6272493573264781}
{"id":174,"predictions":["n = int ( input ( ) ) a , b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = [ 0 ] * nfor i in range ( n ) : if a [ i ] != b [ i ] : b [ a [ i ] ] += 1 else : b [ a [ i ] ] = 1 for i in range ( n ) : if b [ a [ i ] ] == 1 : b [ a [ i ] ] += 1 else : b [ a [ i ] ] = 1 for i in range ( n ) : if b [ a [ i ] ] == b [ a [ i ] ] : b [ b [ i ] ] = 1 else : b [ a [ i ] ] = 1 b [ a [ i ] ] = 1 print ( b [ a [ i ] ] ) NEW_LINE"],"references":["import sysinput = sys . stdin . buffer . readline   n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) )   ''' diffs ▁ = [ ] miss ▁ = ▁ set ( list ( range ( 1 , n + 1 ) ) ) for ▁ i ▁ in ▁ range ( n ) : ▁ ▁ ▁ ▁ if ▁ a [ i ] ▁ ! = ▁ b [ i ] : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ diffs . append ( i ) ▁ ▁ ▁ ▁ miss . discard ( a [ i ] )  if ▁ len ( diffs ) ▁ = = ▁ 1 : ▁ ▁ ▁ ▁ # ▁ no ▁ other ▁ option ▁ ▁ ▁ ▁ a [ diffs [ 0 ] ] ▁ = ▁ list ( miss ) [0 ] else : ▁ ▁ ▁ ▁ # ▁ must ▁ be ▁ 2 ▁ ▁ ▁ ▁ if ▁ { a [ diffs [ 0 ] ] , b [ diffs [ 1 ] ] } ▁ = = ▁ miss : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ a [ diffs [ 1 ] ] ▁ = ▁ b [ diffs [ 1 ] ] ▁ ▁ ▁ ▁ else : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ a [ diffs [ 0 ] ] ▁ = ▁ b [ diffs [ 0 ] ] '''   two = - 1 missing = - 1   counts = [ [ ] for i in range ( n + 1 ) ] for i in range ( n ) : counts [ a [ i ] ] . append ( i ) if len ( counts [ a [ i ] ] ) == 2 : two = a [ i ]   for i in range ( 1 , n + 1 ) : if len ( counts [ i ] ) == 0 : missing = i break   def diff ( a , b ) : diffs = 0 for i in range ( n ) : diffs += a [ i ] != b [ i ] return diffs   for i in range ( 2 ) : perm = a . copy ( ) perm [ counts [ two ] [ i ] ] = missing   if diff ( perm , b ) == 1 : print ( * perm ) break NEW_LINE"],"bleu":0.17856016843358669,"rouge_l":0.41874474642757076}
{"id":175,"predictions":["l , d , g , g = [ int ( x ) for x in input ( ) . split ( ) ] l , r , g = [ int ( x ) for x in input ( ) . split ( ) ] for _ in range ( t ) : l , r = map ( int , input ( ) . split ( ) ) l , r = l . split ( ) if ( l - l ) >= g : print ( l - 1 ) else : print ( - 1 ) NEW_LINE"],"references":["import sysimport mathdef fn ( l , d , v , g , r ) : t = float ( d ) \/ float ( v ) if t < g : return float ( l ) \/ float ( v ) elif t <= g + r : t = g + r return t + ( float ( l ) - float ( d ) ) \/ float ( v ) elif t > g + r : t1 = t k = t \/\/ ( g + r ) t = t - k * ( g + r ) if t < g : return float ( l ) \/ float ( v ) elif t <= g + r : t = g + r return ( k + 1 ) * t + ( float ( l ) - float ( d ) ) \/ float ( v ) if __name__ == ' _ _ main _ _ ' : input = sys . stdin . read ( ) data = list ( map ( int , input . split ( ) ) ) l = ( data [ 0 ] ) d = data [ 1 ] v = data [ 2 ] g = data [ 3 ] r = data [ 4 ] print ( fn ( l , d , v , g , r ) ) NEW_LINE"],"bleu":0.052402096227004515,"rouge_l":0.26884331714337106}
{"id":176,"predictions":["H , H = map ( int , input ( ) . split ( ) ) NEW_LINE l = [ [ ] NEW_LINE for i in range ( H ) : NEW_LINE INDENT l . append ( input ( ) ) NEW_LINE l . append ( l [ 0 ] + 1 ) NEW_LINE DEDENT l . sort ( ) NEW_LINE for i in range ( H ) : NEW_LINE INDENT l . append ( l [ i ] + l [ i ] ) NEW_LINE DEDENT for i in range ( 1 , HG ) : NEW_LINE INDENT l = [ i ] NEW_LINE for j in range ( i ) : NEW_LINE INDENT l . append ( l [ j ] + l [ j ] ) NEW_LINE DEDENT l . append ( l [ j ] ) NEW_LINE DEDENT l . sort ( ) NEW_LINE for i in l ) : NEW_LINE INDENT print ( i , end = \" \" ) NEW_LINE DEDENT DEDENT"],"references":["from itertools import permutationsfrom sys import stdin , stdoutly , lx = map ( int , input ( ) . split ( ) ) grid = [ [ c for c in inp ] for inp in stdin . read ( ) . splitlines ( ) ]   first = set ( ) bl = [ ] bpattern = [ ] bcost = 1e6 flip_row = False   for l in permutations ( ' AGCT ' ) : if bcost == 0 : break if ' ' . join ( l [ : 2 ] ) in first : continue   first |= set ( [ ' ' . join ( l [ : 2 ] ) , ' ' . join ( l [ 1 : : - 1 ] ) ] ) NEW_LINE"],"bleu":0.1543186338740664,"rouge_l":0.3770419426048565}
{"id":177,"predictions":["a , b , c , a , b , c = map ( int , input ( ) . split ( ) ) if a * b == 0 and b == a : print ( ' - 1' ) else : print ( ' - 1' ) NEW_LINE"],"references":["line1 = input ( ) . split ( \" ▁ \" ) line2 = input ( ) . split ( \" ▁ \" ) A1 = int ( line1 [ 0 ] ) A2 = int ( line2 [ 0 ] ) B1 = int ( line1 [ 1 ] ) B2 = int ( line2 [ 1 ] ) C1 = int ( line1 [ 2 ] ) C2 = int ( line2 [ 2 ] )   Z = lambda x , y , z : not x and not y and z   if A1 * B2 - A2 * B1 : print ( 1 ) elif Z ( A1 , B1 , C1 ) or Z ( A2 , B2 , C2 ) or ( C1 * B2 - C2 * B1 ) or ( A1 * C2 - A2 * C1 ) : print ( 0 ) else : print ( - 1 )   NEW_LINE"],"bleu":0.029507317026543498,"rouge_l":0.20777746239000855}
{"id":178,"predictions":["n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in range ( n ) : for j in range ( k ) : if a [ i ] [ j ] == a [ i ] [ j ] : c += 1 if a [ i ] [ j ] == 0 and b [ i ] [ j ] == 1 : c += 1 if a [ i ] [ j ] == 1 : c += 1 if a [ i ] [ j ] == 1 : c += 1 if a [ i ] [ j ] == 0 : c += 1 if a [ i ] [ j ] == 1 : c += 1 else : a [ i ] [ j ] += 1 if a [ i ] [ j ] == 1 : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"references":["import sysinput = sys . stdin . readline   from bisect import bisect_left as bs   '''   '''   def solve ( n , a ) : b = a [ : : ] b . sort ( ) done = [ 0 ] * n   res = [ ] for i in range ( n ) : if not done [ i ] : if a [ i ] == b [ i ] : res . append ( [ i + 1 ] ) done [ i ] = 1 else : r = [ ] while not done [ i ] : r . append ( i + 1 ) done [ i ] = 1 i = bs ( b , a [ i ] ) res . append ( r ) return res                                   n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) )   res = solve ( n , a ) print ( len ( res ) ) for r in res : print ( len ( r ) , * r ) NEW_LINE"],"bleu":0.26307120090151515,"rouge_l":0.3043186895011169}
{"id":179,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) : if a [ i ] == b [ a [ i ] ] : b [ a [ i ] ] = 1 b [ a [ i ] ] = 1 if a [ i ] == b [ a [ i ] ] : b [ a [ i ] ] = 1 if a [ i ] == b [ a [ i ] ] : b [ a [ i ] ] = 1 else : b [ a [ i ] ] = 1 if a [ i ] == b [ a [ i ] ] : b [ a [ i ] ] = 1 for i in b [ i ] : if a [ i ] == b [ a [ i ] ] : b [ a [ i ] ] = b [ a [ i ] ] print ( \" YES \" ) print ( \" NO \" ) NEW_LINE"],"references":["for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) s = input ( ) m = n - 1 for i in range ( n ) : if s [ i ] == ' > ' or s [ n - 1 - i ] == ' < ' : m = min ( m , i ) print ( m ) NEW_LINE"],"bleu":0.09920927593543107,"rouge_l":0.3111884057971015}
{"id":180,"predictions":["t = int ( input ( ) ) for _ in range ( t ) : n , m = map ( int , input ( ) . split ( ) ) ali = list ( map ( int , input ( ) . split ( ) ) ) q = ali [ 0 ] q = ali [ 0 ] * m for i in ali [ 0 ] : ali [ i ] = ali [ i ] q [ - 1 ] if ( ali [ - 1 ] < ali [ - 1 ] ) : ali [ - 1 ] = ali [ - 1 ] else : ali [ i ] = ali [ - 1 ] else : ali [ i ] = 1 if ( ali [ - 1 ] < ali [ - 1 ] ) : q . append ( ( ali [ - 1 ] ) else : q . append ( ali [ - 1 ] ) q . append ( ali [ - 1 ] ) else : q . append ( ali [ - 1 ] ) q = 1 for i in ali [ - 1 ] : q . append ( ali [ i ] ) q . append ( ali [ i ] ) q . sort ( ) for i in q : print ( ali [ i ] ) NEW_LINE"],"references":["import sys , io , os NEW_LINE if os . environ [ ' USERNAME ' ] == ' kissz ' : inp1 = inp2 = open ( ' in . txt ' , ' r ' ) . readline NEW_LINE def debug ( * args ) : print ( * args , file = sys . stderr ) NEW_LINE else : NEW_LINE"],"bleu":0.018656832192604462,"rouge_l":0.1560862678201535}
{"id":181,"predictions":["n , m = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l . sort ( ) if l [ - 1 ] == l [ - 1 ] : print ( - 1 ) else : print ( - l [ - 1 ] ) NEW_LINE"],"references":["import sys , os , ioimport math , bisect , operatorinf , mod = float ( ' inf ' ) , 10 ** 9 + 7 NEW_LINE"],"bleu":0.020499437227905686,"rouge_l":0.13787536325476266}
{"id":182,"predictions":["n = int ( input ( ) ) a = list ( input ( ) ) b = list ( map ( int , input ( ) . split ( ) ) ) ans = 0 for i in range ( n - 1 ) : if b [ i ] == a [ i ] : ans = min ( ans , b [ i ] ) print ( ans ) NEW_LINE"],"references":["n , k = map ( int , input ( ) . split ( ) ) ; s = [ i for i in str ( n ) ] ; i = 0 n = len ( s ) for i in range ( n ) : x = i for j in range ( i + 1 , min ( n , i + k + 1 ) ) : if s [ x ] < s [ j ] : x = j NEW_LINE"],"bleu":0.264560647785762,"rouge_l":0.4214590530380003}
{"id":183,"predictions":["n , m = map ( int , input ( ) . split ( ) )   if n % 2 == 0 : print ( \" NO \" ) else : print ( \" NO \" ) NEW_LINE"],"references":["for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) if ( n * ( n - 1 ) \/ 2 ) % 2 == 0 : a = list ( range ( 2 , n + 1 , 2 ) ) b = list ( range ( 1 , n - 1 , 2 ) ) print ( \" YES \" ) print ( * list ( a + b + [ sum ( a ) - sum ( b ) ] ) ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.08812761230779202,"rouge_l":0.3720294426919033}
{"id":184,"predictions":["n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) a . sort ( ) flag = 0 flag = 0 for i in range ( n ) : if a [ i ] != a [ i ] : flag = 1 breakif flag : print ( i + 1 ) flag = 1 if flag : print ( - 1 ) else : print ( - 1 ) NEW_LINE"],"references":["word = input ( ) ans = 0 num = { }   for i in word : num [ i ] = num . get ( i , 0 ) + 1   for j in num . values ( ) : ans += j ** 2   print ( ans ) NEW_LINE"],"bleu":0.06959113867505659,"rouge_l":0.36935258500232887}
{"id":185,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) a . sort ( ) count = 0 for i in range ( n ) : if a [ i ] != b [ a [ i ] ] : count += 1 else : count += 1 print ( count ) NEW_LINE"],"references":["from sys import stdin , stdoutfrom os import pathif path . exists ( \" input . txt \" ) : stdin = open ( \" input . txt \" , ' r ' ) wr = stdout . writerd = lambda : stdin . readline ( ) . strip ( ) NEW_LINE"],"bleu":0.04770702038383065,"rouge_l":0.24418313735301472}
{"id":186,"predictions":["n , a , b = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) bc = list ( map ( int , input ( ) . split ( ) ) ) c = list ( map ( int , input ( ) . split ( ) ) ) if a % b == 0 : print ( 0 ) else : print ( - 1 ) NEW_LINE"],"references":["for _ in range ( int ( input ( ) ) ) : n , k = map ( int , input ( ) . split ( ) ) NEW_LINE l = list ( ) NEW_LINE for i in range ( n ) : x = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l . append ( x ) NEW_LINE for i in l : c = 1 NEW_LINE for j in l : if NEW_LINE abs ( i [ 0 ] - j [ 0 ] ) + abs ( i [ 1 ] - j [ 1 ] ) > k : c = 0 NEW_LINE break NEW_LINE if c == 1 : print ( 1 ) NEW_LINE break NEW_LINE if c == 0 : print ( - 1 )   NEW_LINE"],"bleu":0.2759940120079313,"rouge_l":0.46488840500816553}
{"id":187,"predictions":["n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l . sort ( ) if l [ - 1 ] % 2 == 0 : print ( 2 , end = ' ▁ ' ) else : print ( - 1 ) NEW_LINE"],"references":["n = int ( input ( ) ) if n % 2 == 0 : print ( n \/\/ 2 ) print ( '2 ▁ ' * ( n \/\/ 2 ) ) else : n = n - 3 print ( n \/\/ 2 + 1 ) print ( '2 ▁ ' * ( n \/\/ 2 ) + '3' ) NEW_LINE"],"bleu":0.2919694680040402,"rouge_l":0.4400213732300294}
{"id":188,"predictions":["n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) print ( b ) NEW_LINE"],"references":["import mathinfo = [ int ( x ) for x in input ( ) . split ( ) ] lanes = info [ 0 ] desks = info [ 1 ] location = info [ 2 ] seats_in_lane = 2 * deskslane = math . ceil ( location \/ seats_in_lane ) starting_group = ( ( lane - 1 ) * seats_in_lane ) + 1 NEW_LINE"],"bleu":0.12615160325997782,"rouge_l":0.311978465679677}
{"id":189,"predictions":["n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) ) b = [ ] for i in range ( n ) : b . append ( b [ i ] ) b . append ( a [ i ] ) b . sort ( ) print ( * b ) NEW_LINE"],"references":["for _ in range ( int ( input ( ) ) ) : input ( ) NEW_LINE n = [ i for i in input ( ) ] NEW_LINE n . sort ( ) NEW_LINE print ( \" \" . join ( n ) ) NEW_LINE"],"bleu":0.1218308401375362,"rouge_l":0.3759415658525451}
{"id":190,"predictions":["n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) cnt = 0 for i in range ( n ) : if l [ i ] == 1 : cnt += 1 else : cnt += 1 print ( cnt ) NEW_LINE"],"references":["def gcd ( a , b ) : while a % b : a , b = b , a % b return ba , b = map ( int , input ( ) . split ( ) ) g = gcd ( a , b ) a \/\/= gb \/\/= gcnt = 0 for i in [ 2 , 3 , 5 ] : while a % i == 0 : a \/\/= i cnt += 1 while b % i == 0 : b \/\/= i cnt += 1 if a == 1 and b == 1 : print ( cnt ) else : print ( - 1 ) NEW_LINE"],"bleu":0.16105297076283984,"rouge_l":0.4135972145867693}
{"id":191,"predictions":["n , t = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) : if a [ i ] % 2 == 0 : print ( - 1 ) else : print ( - 1 ) NEW_LINE"],"references":["n , t = list ( map ( int , input ( ) . split ( ) ) ) a = list ( map ( int , input ( ) . split ( ) ) ) i = 1 while i < t : i += a [ i - 1 ] print ( ' YES ' if i == t else ' NO ' ) NEW_LINE"],"bleu":0.5353880645420495,"rouge_l":0.6689930209371885}
{"id":192,"predictions":["n , l = map ( int , input ( ) . split ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) arr = sorted ( map ( int , input ( ) . split ( ) ) ) print ( l - arr ) NEW_LINE"],"references":["n , l = map ( int , input ( ) . split ( ) ) lights = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True )   max_dif = 0   for i in range ( len ( lights ) - 1 ) : max_dif = max ( max_dif , lights [ i ] - lights [ i + 1 ] )   print ( format ( max ( max_dif \/ 2 , lights [ - 1 ] , l - lights [ 0 ] ) , ' . 10f ' ) ) NEW_LINE"],"bleu":0.26563271753343676,"rouge_l":0.505175983436853}
{"id":193,"predictions":["n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l . sort ( ) if l [ - 1 ] != l [ - 1 ] : print ( - l [ - 1 ] ) else : print ( - 1 ) NEW_LINE"],"references":["n = [ int ( i ) for i in input ( ) ] for x in [ 1 , 6 , 8 , 9 ] : for i in range ( len ( n ) ) : if n [ i ] == x : del n [ i ] break   prefix = [ 1869 , 6189 , 1689 , 6198 , 1698 , 9861 , 1896 ] res = sum ( [ n [ i ] * pow ( 10 , len ( n ) - i - 1 , 7 ) for i in range ( len ( n ) ) ] ) print ( prefix [ - res * pow ( 10 , 5 * len ( n ) , 7 ) % 7 ] , end = ' ' ) print ( * n , sep = ' ' ) NEW_LINE"],"bleu":0.02347863262546881,"rouge_l":0.26045347467608954}
{"id":194,"predictions":["n , m = map ( int , input ( ) . split ( ) ) A = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] A = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] for j in range ( m ) : if A [ i ] [ j ] == A [ i ] [ j ] == 1 : A [ i ] [ j ] = 1 A [ i ] [ j ] = 1 A [ i ] [ j ] = 1 if A [ i ] [ j ] == 1 and A [ i ] [ j ] == 1 : A [ i ] [ j ] = 1 if A [ i ] [ j ] == 1 : A [ i ] [ j ] = 1 A [ i ] [ j ] = 1 if A [ i ] [ j ] == 1 and A [ i ] [ j ] == 1 and A [ i ] [ j ] == 1 : A [ i ] [ j ] = 1 if A [ i ] [ j ] == 0 and A [ i ] [ j ] == 0 : print ( ' Ash ' ) else : print ( ' Ash ' ) NEW_LINE"],"references":["t = int ( input ( ) ) s = [ ] for i in range ( t ) : k = 0 x = list ( map ( int , input ( ) . split ( ) ) ) n = x [ 0 ] m = x [ 1 ] indices1 = [ ] mylist = [ ] for j in range ( n ) : y = list ( map ( str , input ( ) . split ( ) ) ) indices = [ o for o , z in enumerate ( y ) if z == \"1\" ] NEW_LINE"],"bleu":0.17204854984776932,"rouge_l":0.31192840987314385}
{"id":195,"predictions":["n = int ( input ( ) ) s = input ( ) count = 0 for i in range ( len ( s ) ) : count += 1 print ( count ) NEW_LINE"],"references":["n = int ( input ( ) ) s = str ( input ( ) ) ans = 0 for i in range ( n ) : if int ( s [ i ] ) % 2 == 0 : ans += ( i + 1 ) print ( ans ) NEW_LINE"],"bleu":0.34041108614607274,"rouge_l":0.6661812886785583}
{"id":196,"predictions":["n , m = map ( int , input ( ) . split ( ) ) l = [ ] for i in range ( n ) : l . append ( list ( map ( int , input ( ) . split ( ) ) ) ) l . append ( l [ 0 ] ) l [ 1 ] . append ( l [ 1 ] ) l [ 1 ] . append ( l [ 2 ] ) print ( len ( l ) ) NEW_LINE"],"references":["from math import log2   def main ( ) : t = int ( input ( ) ) allAns = [ ] MOD = 10 ** 9 + 7 for _ in range ( t ) : n , p = readIntArr ( ) a = readIntArr ( ) if p == 1 : NEW_LINE"],"bleu":0.0731409623047096,"rouge_l":0.31914387633769326}
{"id":197,"predictions":["def solve ( a , b ) : NEW_LINE"],"references":["def isquare ( n ) : h = n l = 1 while h - l > 1 : m = ( h + l ) \/\/ 2 if m * m <= n : l = m elif m * m > n : h = m return la , b = map ( int , input ( ) . split ( ) ) lsta = [ ] lstb = [ ] for i in range ( 3 , a ) : if isquare ( a * a - i * i ) ** 2 == a * a - i * i : lsta . append ( [ i , isquare ( a * a - i * i ) ] ) for i in range ( 3 , b ) : if isquare ( b * b - i * i ) ** 2 == b * b - i * i : lstb . append ( [ i , isquare ( b * b - i * i ) ] ) flag = Falsefor p , q in lsta : for r , s in lstb : if p * r == q * s : if q == s : p , q , r , s = p , q , r , - s else : p , q , r , s = p , q , - r , s flag = True break if flag : breakif flag : print ( \" YES \\n \" , 0 , 0 , ' \\n ' , p , q , ' \\n ' , r , s ) else : print ( \" NO \" ) NEW_LINE"],"bleu":2.3113685262826963e-14,"rouge_l":0.04654268001907487}
{"id":198,"predictions":["n , x = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) a . sort ( ) print ( b ) NEW_LINE"],"references":["m , k = [ int ( i ) for i in input ( ) . split ( ) ]   days = [ int ( i ) for i in input ( ) . split ( ) ]     s1 = 0 for q in range ( 1 , m ) : if days [ q ] + days [ q - 1 ] < k : s1 += k - ( days [ q ] + days [ q - 1 ] ) days [ q ] += k - ( days [ q ] + days [ q - 1 ] )   print ( s1 ) print ( * days ) NEW_LINE"],"bleu":0.13112032500691903,"rouge_l":0.3379501385041552}
{"id":199,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) d = [ 0 ] * nfor i in range ( n ) : if a [ i ] % 2 == 0 : d [ a [ i ] += 1 else : d [ a [ i ] ] = 1 if a [ i ] % 2 == 0 : d [ a [ i ] ] = 1 if a [ i ] % 2 == 1 : print ( - 1 ) else : print ( 0 ) NEW_LINE"],"references":["n = int ( input ( ) ) A = [ int ( d ) for d in input ( ) ] f = [ int ( x ) for x in input ( ) . split ( ) ] flag = Falsefor i in range ( n ) : d = A [ i ] x = f [ A [ i ] - 1 ] if x > d : flag = True A [ i ] = x elif x == d : continue else : if flag : breakA = list ( map ( str , A ) ) print ( ' ' . join ( A ) ) NEW_LINE"],"bleu":0.19185298514247123,"rouge_l":0.42581545881457034}
{"id":200,"predictions":["s = input ( ) NEW_LINE n = len ( s ) NEW_LINE if len ( s ) < len ( s ) : NEW_LINE INDENT print ( len ( s ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s ) NEW_LINE DEDENT"],"references":["import sysfrom math import gcd , sqrt , ceil , log2from collections import defaultdict , Counter , dequefrom bisect import bisect_left , bisect_rightimport mathimport heapqfrom itertools import permutations   NEW_LINE"],"bleu":0.02673219555880807,"rouge_l":0.027664399092970523}
{"id":201,"predictions":["for s in range ( int ( input ( ) ) ) : a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE if b == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif b == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 3 ) NEW_LINE DEDENT DEDENT"],"references":["t = int ( input ( ) ) for i in range ( t ) : a , b , c = map ( int , input ( ) . split ( ) ) count = 0 if b > 0 and c > 1 : while b > 0 and c > 1 : b = b - 1 c = c - 2 count += 1 if a > 0 and b > 1 : while a > 0 and b > 1 : a = a - 1 b = b - 2 count += 1 print ( count * 3 )       NEW_LINE"],"bleu":0.25122013660169157,"rouge_l":0.44273322711984425}
{"id":202,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) ) c = [ 0 ] * nfor i in range ( n ) : if a [ i ] != b [ i ] : c [ a [ i ] ] = b [ i ] else : c [ a [ i ] ] = c [ i ] = 0 for i in range ( n ) : if a [ i ] == b [ i ] : c [ a [ i ] ] = c [ a [ i ] ] = c [ a [ i ] ] = c [ a [ i ] ] = c [ a [ i ] ] = b [ a [ i ] ] else : c [ b [ i ] ] = c [ a [ i ] ] = c [ a [ i ] ] ] = b [ c [ a [ i ] ] ] = c [ a [ i ] ] ] = c [ a [ i ] ] [ b [ i ] ] = c [ a [ i ] ] = c [ a [ i ] ] = 0 for i in range ( n ) : if a [ i ] [ 0 ] > b [ i ] : if a [ i ] [ 0 ] > b [ i ] : c [ a [ i ] ] = c [ a [ i ] ] else : c [ a [ i ] [ 0 ] = b [ i ] [ 1 ] else : if a [ i ] [ 0 ] == b [ i ] : a [ i ] ] = b [ i ] [ 0 ] = 0 else : a [ i ] = b [ i ] for i in range ( 1 , n ) : if a [ i ] [ 0 ] == b [ i ] [ 1 ] : a [ i ] = b [ i ] [ 0 ] else : a [ i ] = b [ i ] = 1 if a [ i ] [ 0 ] < len ( b [ i ] ) and a [ i ] [ 1 ] > b [ i ] [ 1 ] : print ( \" NO \" ) else : print ( \" YES \" ) NEW_LINE"],"references":["f = lambda : map ( int , input ( ) . split ( ) ) n , m = f ( ) t = list ( f ( ) ) p = [ 1e9 ] + [ abs ( b - a ) for a , b in zip ( t , t [ 1 : ] ) ] + [ 1e9 ] L , R = [ 0 ] * n , [ 0 ] * nfor i in range ( 1 , n ) : j = n - i x , y = i - 1 , j + 1 a , b = p [ i ] , p [ j ] while a > p [ x ] : x = L [ x ] while b >= p [ y ] : y = R [ y ] L [ i ] , R [ j ] = x , yfor k in range ( m ) : l , r = f ( ) print ( sum ( ( i - max ( l - 1 , L [ i ] ) ) * ( min ( r , R [ i ] ) - i ) * p [ i ] for i in range ( l , r ) ) ) NEW_LINE"],"bleu":0.12329828253453155,"rouge_l":0.31852186574283275}
{"id":203,"predictions":["n , m = map ( int , input ( ) . split ( ) ) p = list ( map ( int , input ( ) . split ( ) ) ) res = 0 for i in range ( n ) : if p [ i ] [ 0 ] == 0 : res += ( ( p [ i ] - p [ i ] ) * ( m - e [ i ] ) * ( m - e [ i + 1 ] ) ) * ( p [ i ] - e [ i ] ) else : res += ( p [ i ] * ( m - e [ i ] ) * ( m - e ) * ( m - e [ i ] ) print ( res ) NEW_LINE"],"references":["cases = int ( input ( ) ) while cases : cases -= 1 x = int ( input ( ) ) arrx = list ( map ( int , input ( ) . split ( ) ) ) y = int ( input ( ) ) arry = list ( map ( int , input ( ) . split ( ) ) )   ans = sum ( 1 for i in arrx if i % 2 == 0 ) * sum ( 1 for i in arry if i % 2 == 0 ) + sum ( 1 for i in arrx if i % 2 != 0 ) * sum ( 1 for i in arry if i % 2 != 0 ) print ( ans ) NEW_LINE"],"bleu":0.257096518964097,"rouge_l":0.41577409931840315}
{"id":204,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["MAX_LEN = int ( 1e5 ) n = int ( input ( ) ) a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] m = int ( input ( ) ) b = list ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) curr , k , c , res = 0 , 0 , [ ] , [ ] for i in range ( n ) : t = a [ i ] last = curr if t [ 0 ] == 1 : curr += 1 if len ( c ) < MAX_LEN : c . append ( t [ 1 ] ) if k < m and b [ k ] == curr - 1 : res . append ( t [ 1 ] ) k += 1 else : curr += t [ 1 ] * t [ 2 ] while t [ 2 ] > 0 and len ( c ) < MAX_LEN : c . extend ( c [ : t [ 1 ] ] ) t [ 2 ] -= 1 while k < m and last <= b [ k ] < curr : res . append ( c [ ( b [ k ] - last ) % t [ 1 ] ] ) k += 1 print ( ' ▁ ' . join ( map ( str , res [ : m ] ) ) ) NEW_LINE"],"bleu":0.0036598064298735255,"rouge_l":0.16964865115416705}
{"id":205,"predictions":["n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = [ ] for i in range ( n ) : if a [ i ] != b [ i ] : b . append ( b [ i ] ) else : b . append ( a [ i ] ) c . append ( b [ i ] ) c . append ( b [ i ] ) print ( c ) NEW_LINE"],"references":["def get_key ( my_dict , val ) : for key , value in my_dict . items ( ) : if val == value : return key return - 1   n = int ( input ( ) ) arr = { } for _ in range ( n ) : a , b = input ( ) . split ( ) x = get_key ( arr , a ) if x == - 1 : arr [ a ] = b   else : arr [ x ] = b   print ( len ( arr ) ) for i , j in arr . items ( ) : print ( i , j ) NEW_LINE"],"bleu":0.13577172189780287,"rouge_l":0.3540247287408529}
{"id":206,"predictions":["a , b , c = map ( int , input ( ) . split ( ) ) print ( ' No ' ) NEW_LINE"],"references":["a , b = map ( int , input ( ) . split ( ) ) print ( ' VVlaaldeirka ' [ ( ( 4 * b + 1 ) ** .5 - 1 ) \/\/ 2 < a ** .5 \/\/ 1 : : 2 ] ) NEW_LINE"],"bleu":0.2767238253481513,"rouge_l":0.5617413143574718}
{"id":207,"predictions":["n , k = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) li = list ( map ( int , input ( ) . split ( ) ) ) li . sort ( ) if li [ - 1 ] == 0 : print ( - 1 ) else : print ( 0 ) NEW_LINE"],"references":["def main ( ) : n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) a . sort ( ) c = [ ] for i in range ( n - 1 ) : c += [ a [ i + 1 ] - a [ i ] ] print ( min ( c ) , c . count ( min ( c ) ) )   if __name__ == ' _ _ main _ _ ' : main ( ) NEW_LINE"],"bleu":0.28153655021812785,"rouge_l":0.4412091988130564}
{"id":208,"predictions":["n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) print ( sum ( a ) ) NEW_LINE"],"references":["n , L = map ( int , input ( ) . split ( ) ) kefa = list ( map ( int , input ( ) . split ( ) ) ) sasha = list ( map ( int , input ( ) . split ( ) ) ) def check ( kefa , sasha ) : X = [ ( kefa [ i ] - sasha [ i ] + L ) % L for i in range ( n ) ] if len ( set ( X ) ) == 1 : return True else : return Falsedef rotate ( arr , n ) : x = arr [ n - 1 ] for i in range ( n - 1 , 0 , - 1 ) : arr [ i ] = arr [ i - 1 ] arr [ 0 ] = x return arrok = Falsefor l in range ( n + 1 ) : sasha = rotate ( sasha , n ) if check ( kefa , sasha ) == True : ok = Trueif ok == True : print ( \" Yes \" ) else : print ( \" No \" ) NEW_LINE"],"bleu":0.06506419761534961,"rouge_l":0.36518535574487687}
{"id":209,"predictions":["import mathn = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in range ( 2 , int ( sqrt ( n ) ) ) : c = 0 for j in range ( i , sqrt ( i ) ) : if j * i == n : c += 1 if c == 1 : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"references":["n = 1000000 a = [ 1 ] * ns = set ( ) for i in range ( 2 , n ) : if a [ i ] : s . add ( i * i ) for j in range ( i * i , n , i ) : a [ j ] = 0 input ( ) for x in map ( int , input ( ) . split ( ) ) : print ( [ \" NO \" , \" YES \" ] [ x in s ] ) NEW_LINE"],"bleu":0.34568566273026813,"rouge_l":0.37489025460930636}
{"id":210,"predictions":["n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l . sort ( ) ans = 0 for i in range ( n ) : if l [ i ] > l [ i ] : ans += 1 else : ans += 1 print ( ans ) NEW_LINE"],"references":["n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) neg , neg1 = 0 , [ ] pos , pos1 = 0 , [ ] for i in range ( n ) : if l [ i ] >= 0 : l [ i ] = - l [ i ] - 1 if n % 2 == 0 : print ( * l ) else : l1 = sorted ( l ) l [ l . index ( l1 [ 0 ] ) ] = - l1 [ 0 ] - 1 print ( * l ) NEW_LINE"],"bleu":0.3112647631566964,"rouge_l":0.5502168256721596}
{"id":211,"predictions":["x , y , t = map ( int , input ( ) . split ( ) ) ans = 0 for i in range ( t ) : ans += ( abs ( x - x ) - ( y - x ) ) * tprint ( ans ) NEW_LINE"],"references":["    n , b = map ( int , input ( ) . split ( ) )   t = list ( map ( int , input ( ) . split ( ) ) )   ans = 0   ma = 999999999 mi = 0 for i in range ( n ) :   if t [ i ] < ma : ma = t [ i ] elif t [ i ] > ma : temp = b \/\/ ma   rest = b - ( b \/\/ ma ) * ma rest += ( temp ) * t [ i ]   ans = max ( rest , ans )   print ( max ( ans , b ) )                             NEW_LINE"],"bleu":0.14166575794620667,"rouge_l":0.31813440619877814}
{"id":212,"predictions":["s = input ( ) l = len ( s ) for i in range ( len ( s ) - 1 , - 1 , - 1 ) : if s [ i ] == ' r ' : l . append ( i + 1 ) breakprint ( l ) NEW_LINE"],"references":["import osimport sysfrom io import BytesIO , IOBase   sys . setrecursionlimit ( 95000 )     def main ( ) : pass     NEW_LINE"],"bleu":0.04342903243732388,"rouge_l":0.1888544891640867}
{"id":213,"predictions":["a , b = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) ) d = { } for i in range ( a ) : if b [ i ] == a [ i ] : d [ b [ i ] ] = \" NO \" elif b [ i ] == a [ i ] : d [ b [ i ] ] = \" YES \" else : if a [ i ] == b [ i ] : d [ i ] = \" NO \" else : d [ b [ i ] ] = \" YES \" for i in b [ i ] : if a [ i ] [ i ] == b [ i ] : d [ i ] = \" NO \" else : if a [ i ] [ 0 ] == b [ i ] : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"references":["x , t , a , b , da , db = [ int ( i ) for i in input ( ) . split ( ) ]   if x == 0 : print ( \" YES \" ) exit ( 0 )   for i in range ( t ) : for j in range ( t ) : if ( a - i * da + b - j * db == x ) or ( a - i * da == x ) or ( b - j * db == x ) : print ( \" YES \" ) exit ( 0 )   print ( \" NO \" ) NEW_LINE"],"bleu":0.144307594025363,"rouge_l":0.3223500155424308}
{"id":214,"predictions":["n = int ( input ( ) ) l = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) print ( ' NO ' ) NEW_LINE"],"references":["from itertools import combinations   def solve ( ) : n = int ( input ( ) ) ls = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) for x , y , z in zip ( ls , ls [ 1 : ] , ls [ 2 : ] ) : if x > z - y and x <= y + z : print ( ' YES ' ) return print ( ' NO ' )   if __name__ == ' _ _ main _ _ ' : solve ( ) NEW_LINE"],"bleu":0.1272402291774603,"rouge_l":0.44901493829833294}
{"id":215,"predictions":["s = input ( ) ans = 0 for i in range ( len ( s ) ) : if s [ i ] == s [ i ] : ans += 1 print ( ans ) NEW_LINE"],"references":["def solution ( s ) : s = sorted ( s , reverse = True ) n = len ( s ) ans = s [ 0 ] for i in range ( 1 , n ) : if ( s [ i - 1 ] == s [ i ] ) : ans += ( s [ i ] ) else : return ans return ans   s = input ( ) print ( solution ( s ) ) NEW_LINE"],"bleu":0.1947845135598011,"rouge_l":0.4891360579410243}
{"id":216,"predictions":["n = int ( input ( ) ) print ( ' input ( ) ) NEW_LINE"],"references":["n = int ( input ( ) ) if n % 2 == 0 : print ( 4 , n - 4 ) else : print ( 9 , n - 9 ) NEW_LINE"],"bleu":0.18709267977031827,"rouge_l":0.4883004926108374}
{"id":217,"predictions":["n = int ( input ( ) ) lst = list ( map ( int , input ( ) . split ( ) ) ) lst = [ ] for i in range ( n ) : lst . append ( lst [ i ] ) lst . append ( i ) lst . append ( lst [ i ] ) lst . append ( lst [ i ] ) lst . append ( lst [ i ] ) lst . append ( lst [ i ] ) lst . append ( lst [ i ] ) lst . append ( lst [ i ] ) lst . append ( lst [ i ] ) print ( len ( st ) ) NEW_LINE"],"references":["raw = input ( ) R , C = ( int ( token ) for token in raw . split ( ' ▁ ' ) ) mat = list ( ) for i in range ( R ) : row = input ( ) mat . append ( row )   count = 0 for i in range ( 1 , R ) : for j in range ( 1 , C ) : sq = [ mat [ i - 1 ] [ j - 1 ] , mat [ i - 1 ] [ j ] , mat [ i ] [ j - 1 ] , mat [ i ] [ j ] ] sq . sort ( ) if ' ' . join ( sq ) == ' acef ' : count += 1 print ( count )   NEW_LINE"],"bleu":0.11293756835103201,"rouge_l":0.39883763167453684}
{"id":218,"predictions":["for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) ) cnt = 0 for i in range ( n ) : if a [ i ] <= b [ a [ i ] : cnt += 1 else : flag = 0 for i in range ( a [ i ] ) : if a [ i ] > b [ a [ i ] ] : cnt += 1 if flag : print ( - 1 ) else : print ( - 1 ) NEW_LINE"],"references":["import sys   def answer ( n , k , a ) : peaks = [ False ] * n NEW_LINE"],"bleu":0.019004484628583063,"rouge_l":0.15039447731755423}
{"id":219,"predictions":["n , s = map ( int , input ( ) . split ( ) ) a = list ( input ( ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in range ( n - 1 ) : if a [ i ] in b [ i ] : c += 1 if a [ i ] == b [ i ] : b += 1 b [ i ] += 1 print ( c ) NEW_LINE"],"references":["n = int ( input ( ) ) s = input ( ) k = [ s [ i : i + 2 ] for i in range ( n - 1 ) ] print ( max ( k , key = k . count ) ) NEW_LINE"],"bleu":0.1565802406770916,"rouge_l":0.36779812416257257}
{"id":220,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) a . sort ( ) flag = 0 flag = 0 for i in range ( n ) : if a [ i ] % a [ i ] == 0 : flag = 1 breakif flag : print ( a [ i ] ) flag = 1 breakif flag : print ( - 1 ) else : print ( - 1 ) NEW_LINE"],"references":["def main ( ) : t = int ( input ( ) ) allans = [ ] for _ in range ( t ) : x = int ( input ( ) ) arr = [ int ( z ) for z in input ( ) ] n = len ( arr ) j = 1 for i in range ( x ) : if j == n : break for yy in range ( arr [ i ] - 1 ) : if len ( arr ) > x : break for zz in range ( i + 1 , n ) : if len ( arr ) > x : break arr . append ( arr [ zz ] ) n += ( ( n - j + MOD ) % MOD ) * ( arr [ i ] - 1 ) j += 1 n %= MOD NEW_LINE"],"bleu":0.12882574306668992,"rouge_l":0.3583083148414045}
{"id":221,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = [ 0 ] * nfor i in range ( n ) : if a [ i ] [ 0 ] == b [ i ] [ 1 ] : if a [ i ] [ 0 ] == b [ i ] [ 1 ] : c += 1 if a [ i ] [ 0 ] == b [ i ] [ 1 ] : c += 1 if a [ i ] [ 0 ] == b [ i ] [ 1 ] : c += 1 if a [ i ] [ 0 ] == b [ i ] : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"references":["a = input ( ) b = input ( )   def dfs ( sa , sb ) : if sa == sb : return True if len ( sa ) & 1 : return False n = len ( sa ) \/\/ 2 sa1 = sa [ : n ] sa2 = sa [ n : ] sb1 = sb [ : n ] sb2 = sb [ n : ] if dfs ( sa1 , sb2 ) and dfs ( sa2 , sb1 ) : return True if dfs ( sa1 , sb1 ) and dfs ( sa2 , sb2 ) : return True return False   if dfs ( a , b ) : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.15573128667844538,"rouge_l":0.3320373250388802}
{"id":222,"predictions":["n , k = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l . sort ( ) if l [ 0 ] > k : print ( - 1 ) else : print ( 0 ) NEW_LINE"],"references":["n , m , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) a1 = [ ] for i in range ( n ) : a1 . append ( ( a [ i ] , i ) ) a1 . sort ( reverse = True ) _max = [ 0 ] * nans = 0 for i in range ( m * k ) : _max [ a1 [ i ] [ 1 ] ] = 1 ans += a1 [ i ] [ 0 ] print ( ans ) _sum = 0 ans_ar = [ ] for i in range ( n ) : _sum += _max [ i ] if _sum == m : ans_ar . append ( i + 1 ) _sum = 0 ans_ar . pop ( ) print ( * ans_ar )           NEW_LINE"],"bleu":0.16347706676121154,"rouge_l":0.43710812539987215}
{"id":223,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in range ( n ) : if a [ i ] == b [ i ] : c += 1 if a [ i ] == b [ i ] : b += 1 if a [ i ] == b [ i ] : print ( 2 ) else : print ( - 1 ) NEW_LINE"],"references":["import reimport sysexit = sys . exitfrom bisect import bisect_left as bsl , bisect_right as bsrfrom collections import Counter , defaultdict as ddict , dequefrom functools import lru_cachecache = lru_cache ( None ) from heapq import * from itertools import * from math import inffrom pprint import pprint as ppenum = enumerateri = lambda : int ( rln ( ) ) ris = lambda : list ( map ( int , rfs ( ) ) ) rln = sys . stdin . readlinerl = lambda : rln ( ) . rstrip ( ' \\n ' ) rfs = lambda : rln ( ) . split ( ) mod = 1000000007 d4 = [ ( 0 , - 1 ) , ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 0 ) ] d8 = [ ( - 1 , - 1 ) , ( 0 , - 1 ) , ( 1 , - 1 ) , ( - 1 , 0 ) , ( 1 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) ] NEW_LINE"],"bleu":0.08245397833920722,"rouge_l":0.27133036797412047}
{"id":224,"predictions":["for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) a = [ int ( x ) for x in input ( ) . split ( ) ] flag = 0 flag = 0 for i in range ( n ) : if a [ i ] == ' R ' : if a [ i ] == ' R ' : flag = 1 break if flag : print ( flag ) NEW_LINE"],"references":["from sys import stdin , stdoutstdin . readlinedef mp ( ) : return list ( map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) ) def it ( ) : return int ( stdin . readline ( ) . strip ( ) ) from collections import defaultdict as dd , Counter as C , dequefrom math import ceil , gcd     NEW_LINE"],"bleu":0.1347437505335664,"rouge_l":0.2586389654441382}
{"id":225,"predictions":["n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) print ( b ) NEW_LINE"],"references":["import sysimport mathfrom collections import OrderedDictdef input ( ) : return sys . stdin . readline ( ) . strip ( ) def iinput ( ) : return int ( input ( ) ) def minput ( ) : return map ( int , input ( ) . split ( ) ) def listinput ( ) : return list ( map ( int , input ( ) . split ( ) ) ) n , p = minput ( ) s = input ( ) s1 = s [ : ( n - p ) ] s2 = s [ p : ] if ( s1 == s2 and s1 . count ( ' . ' ) == 0 and s2 . count ( ' . ' ) == 0 ) or n == 1 or n == p : print ( ' NO ' ) else : for i in range ( n - p ) : if s [ i ] == ' . ' : if s [ p + i ] == '0' or s [ p + i ] == ' . ' : s = s [ : i ] + '1' + s [ i + 1 : ] else : s = s [ : i ] + '0' + s [ i + 1 : ] break elif s [ p + i ] == ' . ' : if s [ i ] == '0' or s [ i ] == ' . ' : s = s [ : p + i ] + '1' + s [ p + i + 1 : ] else : s = s [ : p + i ] + '0' + s [ p + i + 1 : ] break s = s . replace ( ' . ' , '0' ) print ( s ) NEW_LINE"],"bleu":0.016166958856563985,"rouge_l":0.2308507417499243}
{"id":226,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in range ( n ) : if a [ i ] != b [ i ] : c += 1 if a [ i ] == b [ i ] : print ( 0 ) else : print ( 0 ) NEW_LINE"],"references":["for _ in range ( int ( input ( ) ) ) : a , b = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE print ( a ^ b ) NEW_LINE"],"bleu":0.1445023093843616,"rouge_l":0.3752883875929249}
{"id":227,"predictions":["n , m = map ( int , input ( ) . split ( ) ) l = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] for i in range ( m ) : for j in range ( m ) : l [ i ] [ j ] = l [ i ] [ j ] if l [ i ] [ j ] == l [ i ] [ j ] and l [ i ] [ j ] == l [ i ] [ j ] : l [ i ] [ j ] = l [ i ] [ j ] if l [ i ] [ j ] == l [ i ] [ j ] : l [ i ] [ j ] = l [ i ] [ j ] if l [ i ] [ j ] == l [ i ] [ j ] and l [ i ] [ j ] == l [ i ] [ j ] and l [ i ] [ j ] == l [ i ] [ j ] : l [ i ] [ j ] = l [ i ] [ j ] if l [ i ] [ j ] == l [ i ] [ j ] : l [ i ] [ j ] = l [ i ] [ j ] if l [ i ] else : l [ i ] [ j ] = l [ i ] [ j ] = l [ i ] if l [ i ] [ j ] == l [ i ] [ j ] = l [ i ] else : l [ i ] [ j ] = l [ i ] [ j ] = l [ i ] [ j ] = l [ i ] [ j ] for i in l : l [ i ] [ j ] = l [ i ] [ j ] if l [ i ] == l [ i ] [ j ] : l . append ( l [ i ] [ j ] ) l [ i ] . append ( l [ i ] [ j ] ) l . append ( l [ i ] ) for i in l [ j ] : l . append ( l [ i ] [ j ] ) l [ i ] . append ( l [ j ] ) l [ i ] = l [ i ] [ j ] = l [ i ] for i in l [ j ] for j in l [ i ] ] for i in l : l [ i ] = l [ i ] print ( l [ i ] [ j ] for i in l [ i ] for i in l [ j"],"references":["    n , r = map ( int , input ( ) . split ( ) )     t = list ( map ( int , input ( ) . split ( ) ) )       arr = [ 0 ] * ( n + 1 )     for i in range ( n ) :   if t [ i ] == 1 : arr [ max ( i - r + 1 , 0 ) ] += 1 arr [ min ( n , i + r ) ] -= 1         for j in range ( 1 , n + 1 ) : arr [ j ] += arr [ j - 1 ]         if 0 in arr [ : n ] : print ( - 1 ) else : ans = 0   for i in range ( n ) : st = max ( 0 , i - r + 1 ) en = min ( i + r , n )   h = 0   for j in range ( st , en ) : if arr [ j ] == 1 : h += 1 if h == 0 : ans += 1 for j in range ( st , en ) : arr [ j ] -= 1   print ( sum ( t ) - ans )                     NEW_LINE"],"bleu":0.11679918968995254,"rouge_l":0.2659720947310446}
{"id":228,"predictions":["for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) : a . sort ( ) flag = 0 flag = 0 for i in range ( n ) : if a [ i ] != a [ i ] : flag = False breakif flag : print ( \" a \" ) else : print ( \" a \" ) NEW_LINE"],"references":["ans = [ ] for i in range ( 27 ) : for j in range ( 27 ) : for t in range ( 27 ) : tempa = [ i , j , t ] s = ' ' for q in range ( len ( tempa ) ) : if ( tempa [ q ] == 26 ) : continue ; else : s += chr ( tempa [ q ] + 97 ) ans . append ( [ len ( s ) , s ] )   ans . sort ( ) pg = [ ]   x = int ( input ( ) ) for i in range ( x ) : s = input ( ) pg . append ( s ) for i in range ( len ( ans ) ) : flag = 0 for j in range ( len ( pg ) ) : if ( ans [ i ] [ 1 ] in pg [ j ] ) : flag += 1 if ( flag == 0 ) : print ( ans [ i ] [ 1 ] ) exit ( )                                               NEW_LINE"],"bleu":0.12620197402917932,"rouge_l":0.3183774379635565}
{"id":229,"predictions":["for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEW_LINE if n % 2 == 0 : NEW_LINE INDENT print ( n - 1 ) else : NEW_LINE print ( n - 1 ) NEW_LINE DEDENT"],"references":["for t in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE r = [ int ( i ) for i in s [ 0 : : 2 ] ] NEW_LINE b = [ int ( i ) for i in s [ 1 : : 2 ] ] NEW_LINE win = 0 NEW_LINE if n % 2 == 1 : win = 2 NEW_LINE for i in r : if NEW_LINE i % 2 == 1 : win = 1 NEW_LINE break else : win = 1 NEW_LINE for i in b : if NEW_LINE i % 2 == 0 : win = 2 NEW_LINE break NEW_LINE print ( win ) NEW_LINE"],"bleu":0.11501818064840291,"rouge_l":0.3757700205338809}
{"id":230,"predictions":["s = list ( input ( ) ) NEW_LINE print ( \" Yes \" ) NEW_LINE"],"references":["from itertools import permutations   flag = 0 a = input ( ) a_list = list ( permutations ( \" ABC \" ) ) a_list = [ \" \" . join ( x ) for x in a_list ] for x in a_list : if x in a : flag = 1 if flag == 1 : print ( \" Yes \" ) else : print ( \" No \" ) NEW_LINE"],"bleu":0.018114288887971206,"rouge_l":0.2650401069518717}
{"id":231,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) : if a [ i ] == ' + ' : b [ a [ i ] ] += 1 else : a [ a [ i ] ] -= 1 b [ a [ i ] ] += 1 else : b [ a [ i ] ] -= 1 if a [ i ] > 1 and b [ a [ i ] ] > 1 and b [ a [ i ] ] > 1 : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"references":["from sys import stdin NEW_LINE input = stdin . readline NEW_LINE input ( ) NEW_LINE * a , = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s , r = [ 0 ] * 2 NEW_LINE cnt = [ 0 ] * 100002 NEW_LINE for i in a : NEW_LINE INDENT cnt [ i ] += 1 NEW_LINE if cnt [ i ] % 4 == 0 : NEW_LINE INDENT s += 1 NEW_LINE DEDENT if cnt [ i ] % 2 == 0 : NEW_LINE INDENT r += 1 NEW_LINE DEDENT DEDENT q = int ( input ( ) ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT sign , n = input ( ) . split ( ) NEW_LINE n = int ( n ) NEW_LINE if sign == ' + ' : NEW_LINE INDENT cnt [ n ] += 1 NEW_LINE if cnt [ n ] % 4 == 0 : NEW_LINE INDENT s += 1 NEW_LINE DEDENT if cnt [ n ] % 2 == 0 : NEW_LINE INDENT r += 1 NEW_LINE DEDENT DEDENT elif sign == ' - ' : NEW_LINE INDENT if cnt [ n ] % 4 == 0 : NEW_LINE INDENT s -= 1 NEW_LINE DEDENT if cnt [ n ] % 2 == 0 : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT cnt [ n ] -= 1 NEW_LINE DEDENT print ( ' YES ' if s > 1 or ( s == 1 and r > 3 ) else ' NO ' ) NEW_LINE DEDENT"],"bleu":0.14872746492251915,"rouge_l":0.3321485290781214}
{"id":232,"predictions":["n , k = map ( int , input ( ) . split ( ) ) s = str ( input ( ) ) cnt = 0 for i in range ( n ) : if s [ i ] != s [ i ] : cnt += 1 elif s [ i ] == s [ i ] : cnt += 1 elif s [ i ] == s [ i ] : s [ i ] += 1 elif s [ i ] == s [ i ] : s [ i ] = 1 else : s [ i ] += 1 else : s [ i ] = s [ i ] for i in s : if s [ i ] != s [ i ] : s [ i ] = \" a \" elif s [ i ] != s [ i ] and s [ i ] == s [ i ] : s [ i ] = \" a \" elif s [ i ] == \" a \" and s [ i ] == \" a \" : s [ i ] = \" a \" elif s [ i ] == \" a \" and s [ i ] == \" a \" and s [ i ] != \" a \" and s [ i ] == \" a \" : s [ i ] = \" a \" elif s [ i ] == \" a \" and s [ i ] != \" a \" and s [ i ] != \" a \" : s [ i ] = \" a \" elif s [ i ] == \" a \" and s [ i ] == \" a \" : s [ i ] = \" a \" elif s [ i ] == \" a \" : s [ i ] = \" a \" elif s [ i ] == \" a \" : s [ i ] = \" a \" elif s [ i ] == \" a \" : s [ i ] = \" a \" elif s [ i ] == \" a \" : s [ i ] = \" a \" elif s [ i ] == \" a \" : s [ i ] = \" a \" elif s [ i ] == \" a \" and s [ i ] == \" a \" : s [ i ] = \" a \" elif s [ i ] == \" a \" : s [ i ] = \" a \" elif s [ i ] == \" a \" and s [ i ] == \" a \" and s [ i ] != \" a \" and s [ i ] == \" a \" : s [ i ] ="],"references":["k , s , o = int ( input ( ) ) , \" z \" , 97 while k : q = int ( ( ( 1 + 8 * k ) ** .5 - 1 ) \/ 2 ) + 1 k -= q * ( q - 1 ) \/\/ 2 s += chr ( o ) * q o += 1 print ( s ) NEW_LINE"],"bleu":0.014530126413777001,"rouge_l":0.08387762117566173}
{"id":233,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) a . sort ( ) if b == 0 : print ( 0 ) else : print ( 0 ) NEW_LINE"],"references":["n , c = map ( int , input ( ) . split ( ) ) prices = list ( map ( int , input ( ) . split ( ) ) )   max_i = Nonemax_p = Nonefor i , p in enumerate ( prices ) : if max_p is None or ( i < len ( prices ) - 1 and p - prices [ i + 1 ] > max_p ) : max_i = i max_p = p - prices [ i + 1 ]   print ( max ( 0 , prices [ max_i ] - c - prices [ max_i + 1 ] ) ) NEW_LINE"],"bleu":0.26460213211190686,"rouge_l":0.4756541327326287}
{"id":234,"predictions":["n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = 0 ans = 0 for i in range ( n ) : if a [ i ] % b [ i ] == 0 : ans += 1 if b [ i ] == 1 : ans += 1 else : ans += 1 print ( ans ) NEW_LINE"],"references":["import sysinput = sys . stdin . readlineimport math   def inpit ( ) : NEW_LINE"],"bleu":0.022024883778452454,"rouge_l":0.1376975169300226}
{"id":235,"predictions":["t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : n = int ( input ( ) ) NEW_LINE ali = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ali = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ali = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ali = ali [ 0 ] NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : ali [ i ] = ali [ i - 1 ] NEW_LINE for j in ali [ j ] : ali [ j ] = ali [ j ] + ali [ j ] NEW_LINE ans += ali [ j ] NEW_LINE print ( ans ) NEW_LINE"],"references":["from sys import stdin ''' class ▁ PriorityQueueBase : ▁ ▁ ▁ ▁ class ▁ _ Item : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ _ _ slots _ _ ▁ = ▁ ' _ key ' , ' _ value '   ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ def ▁ _ _ init _ _ ( self , k , v ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ self . _ key ▁ = ▁ k ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ self . _ value ▁ = ▁ v  ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ def ▁ _ _ lt _ _ ( self , other ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ return ▁ self . _ key ▁ < ▁ other . _ key  ▁ ▁ ▁ ▁ def ▁ is _ empty ( self ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ return ▁ len ( self ) ▁ = = ▁ 0 def ▁ queue _ time ( customers , n ) : ▁ ▁ ▁ ▁ for ▁ i ▁ in ▁ range ( 1 , len ( customers ) ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ i ▁ = ▁ i % n ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ while ▁ i % n < n ▁ and ▁ customers [ i % n ] > customers [ ( i + 1 ) % n ] : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ i + = 1 ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ customers [ i % n ] ▁ = customers [ i % n ] ▁ + ▁ customers [ i ] ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ customers [ i ] ▁ = ▁ 0 ▁ ▁ ▁ ▁ return ▁ customers def ▁ phi ( n ) : ▁ ▁ ▁ ▁ result ▁ = ▁ n ▁ ▁ ▁ ▁ for ▁ i ▁ in ▁ range ( 2 , int ( pow ( n , 0.5 ) ) + 1 ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ while ▁ n % i ▁ = = ▁ 0 : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ n \/ = i ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ result - = result \/ i ▁ ▁ ▁ ▁ if ▁ n > 1 : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ result ▁ - = ▁ result \/ n ▁ ▁ ▁ ▁ return ▁ result ''' def main ( ) : input = stdin . buffer . readline for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) a . sort ( ) cur = 0 ans = 0 for i in range ( n ) : cur += 1 if cur == a [ i ] : ans += 1 cur = 0 print ( ans ) main ( ) NEW_LINE"],"bleu":0.02092632350318143,"rouge_l":0.18561900791996666}
{"id":236,"predictions":["n = int ( input ( ) ) NEW_LINE a = [ input ( ) for i in range ( n ) ] NEW_LINE a . sort ( ) NEW_LINE if a [ 0 ] % 2 == 0 : NEW_LINE INDENT a [ i ] = a [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT a . append ( a [ i ] ) NEW_LINE DEDENT print ( a [ : : - 1 ] ) NEW_LINE"],"references":["n = int ( input ( ) ) s = list ( str ( input ( ) ) ) r = [ \" \" ] * nif n % 2 != 0 : j = n \/\/ 2 for i in range ( n ) : if i % 2 == 0 : r [ j + i ] = s [ i ] j += i else : r [ j - i ] = s [ i ] j -= ielse : j = ( n \/\/ 2 ) - 1 for i in range ( n ) : if i % 2 != 0 : r [ j + i ] = s [ i ] j += i else : r [ j - i ] = s [ i ] j -= i   print ( \" \" . join ( r ) ) NEW_LINE"],"bleu":0.13735710576177393,"rouge_l":0.3722033898305085}
{"id":237,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) x = a . index ( x ) x = a . index ( x ) x = a . index ( x ) y = a . index ( y ) y = a . index ( y ) x . index = a . index ( y ) y = a . index ( x ) y = a . index ( y ) x = a . index ( y ) y = a . index ( y ) x = a . index ( x ) y = a . index ( y ) y = a . index ( x ) y = a . index ( y ) y = a . index ( y ) x = a . index ( y ) y = a . index ( y ) y = a . index ( y ) y = a . index ( y ) for i in range ( n ) : if a [ i ] == x : x = a [ i ] else : x = a [ i ] x = xif a [ i ] == x : x . append ( a [ i ] ) x . append ( x ) x = a [ i ] else : x = a [ i ] x = x . index ( x ) y = a [ i ] x = a [ i ] y = xif a [ i ] != x : x . append ( x ) x . y = a [ i ] print ( x ) NEW_LINE"],"references":["mod = 1000000007 eps = 10 ** - 9     def main ( ) : import sys from bisect import bisect_left input = sys . stdin . buffer . readline   def calc ( r , g , b ) : return ( r - g ) ** 2 + ( g - b ) ** 2 + ( b - r ) ** 2   for _ in range ( int ( input ( ) ) ) : NR , NG , NB = map ( int , input ( ) . split ( ) ) R = list ( map ( int , input ( ) . split ( ) ) ) G = list ( map ( int , input ( ) . split ( ) ) ) B = list ( map ( int , input ( ) . split ( ) ) ) R . sort ( ) B . sort ( ) G . sort ( ) ans = float ( ' inf ' )   NEW_LINE"],"bleu":0.12205170014693169,"rouge_l":0.28986968104255173}
{"id":238,"predictions":["n = int ( input ( ) ) l1 , r = map ( int , input ( ) . split ( ) ) l1 = r - l + 1 if ( l1 - l2 ) \/\/ 2 : print ( - l1 ) else : print ( - l1 ) NEW_LINE"],"references":["import math   def total ( l , r ) : l -= 1 if l % 2 == 0 : l \/= 2 else : l = int ( math . ceil ( l \/ 2 ) * - 1 ) if r % 2 == 0 : r \/= 2 else : r = int ( math . ceil ( r \/ 2 ) * - 1 ) return int ( r - l )   q = int ( input ( ) ) ans = \" \"   for i in range ( q ) : l , r = map ( int , input ( ) . split ( ) ) ans += str ( total ( l , r ) ) + \" \\n \"   print ( ans ) NEW_LINE"],"bleu":0.10818534815444722,"rouge_l":0.28435942774473555}
{"id":239,"predictions":["n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = [ ] for i in range ( n ) : b . append ( a [ i ] ) b . append ( a [ i ] ) b . append ( b [ i ] ) for i in b : b . append ( b [ i ] ) b . append ( a [ i ] ) b . sort ( ) b . sort ( ) print ( * b [ a [ i ] ] ) NEW_LINE"],"references":["n = int ( input ( ) ) a = [ int ( x ) for x in input ( ) . split ( ) ] a . sort ( ) print ( min ( a [ - 2 ] - a [ 0 ] , a [ - 1 ] - a [ 1 ] ) ) NEW_LINE"],"bleu":0.13952420270536603,"rouge_l":0.39294795728089504}
{"id":240,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( 1 , m ) ]   for i in range ( 1 , n ) : for j in range ( m ) : if a [ i ] [ j ] + a [ i ] [ j ] == 0 : print ( ' ' . join ( a [ i ] [ j ] + a [ i ] [ j ] + a [ i ] [ j ] ) ) else : print ( '0' ) NEW_LINE"],"references":["lights = [ [ 1 for _ in range ( 3 ) ] for _ in range ( 3 ) ] count = [ ] for _ in range ( 3 ) : count . append ( [ int ( i ) for i in input ( ) . split ( ' ▁ ' ) ] )   for i , row in enumerate ( count ) : for j , val in enumerate ( row ) : if val % 2 == 1 : lights [ i ] [ j ] = 0 if lights [ i ] [ j ] == 1 else 1 if i > 0 : lights [ i - 1 ] [ j ] = 0 if lights [ i - 1 ] [ j ] == 1 else 1 if i < 2 : lights [ i + 1 ] [ j ] = 0 if lights [ i + 1 ] [ j ] == 1 else 1 if j > 0 : lights [ i ] [ j - 1 ] = 0 if lights [ i ] [ j - 1 ] == 1 else 1 if j < 2 : lights [ i ] [ j + 1 ] = 0 if lights [ i ] [ j + 1 ] == 1 else 1   for row in lights : print ( ' ' . join ( [ str ( i ) for i in row ] ) ) NEW_LINE"],"bleu":0.14560098931296436,"rouge_l":0.368107795321154}
{"id":241,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) cnt = 0 for i in range ( n ) : if b [ a [ i ] ] == b [ a [ i ] ] : cnt += 1 if b [ a [ i ] ] == b [ a [ i ] ] : ans += 1 print ( ans ) NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) ans = 1 for _ in range ( n ) : a = list ( map ( int , input ( ) . split ( ) ) ) ans = max ( ans , min ( a ) ) print ( ans ) NEW_LINE"],"bleu":0.39022058441516594,"rouge_l":0.5580041580041579}
{"id":242,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) cntSet = 0 for i in range ( n ) : if a [ i ] % m == 1 : cntSet += 1 b [ a [ i ] - 1 ] += 1 else : b [ a [ i ] - 1 b [ a [ i ] ] = 1 for i in range ( m ) : if a [ i ] % 2 == 0 : cntSet [ a [ i ] ] += 1 b [ a [ i ] ] = 1 b = 1 for i in range ( 1 , n + 1 ) : if a [ i ] % 2 == 0 and b [ a [ i ] - 1 ] == 0 : b [ a [ i ] ] += 1 else : b [ a [ i ] ] += 1 b [ a [ i ] ] += 1 for i in range ( 1 , n ) : if a [ i ] % 2 == 0 and b [ a [ i ] ] > 1 : b [ a [ i ] ] -= 1 b [ a [ i ] ] += 1 else : b [ a [ i ] ] += 1 b [ a [ i ] ] += 1 else : b [ a [ i ] ] = 1 for i in range ( 1 , n ) : if a [ i ] % 2 == 0 and a [ i ] == 1 : b [ i ] = 1 print ( ' ' . join ( map ( str , a ) ) ) NEW_LINE"],"references":["n = int ( input ( ) ) a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] solved = [ 0 for i in range ( 5 ) ] score = [ 0 for i in range ( 5 ) ] for i in range ( n ) : for j in range ( 5 ) : solved [ j ] += int ( a [ i ] [ j ] > - 1 ) for k in range ( 31 * n + 1 ) : for i in range ( 5 ) : tot = n + k cur = solved [ i ] if a [ 0 ] [ i ] > - 1 and a [ 1 ] [ i ] > - 1 and a [ 0 ] [ i ] > a [ 1 ] [ i ] : cur += k score [ i ] = 500 while score [ i ] < 3000 and 2 * cur <= tot : cur *= 2 ; score [ i ] += 500 res = [ 0 , 0 ] for j in range ( 2 ) : for i in range ( 5 ) : if a [ j ] [ i ] > - 1 : res [ j ] += score [ i ] \/ 250 * ( 250 - a [ j ] [ i ] ) if res [ 0 ] > res [ 1 ] : print ( k ) exit ( ) print ( \" - 1\" ) NEW_LINE"],"bleu":0.24157656518918125,"rouge_l":0.44193267240440137}
{"id":243,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) ans = 0 for i in range ( n ) : if a [ a [ b ] ] == b [ a [ b ] ] : ans += 1 if b [ a [ b ] ] == 0 : ans += 1 print ( ans ) NEW_LINE"],"references":["import osimport sysfrom io import BytesIO , IOBase   BUFSIZE = 8192     class FastIO ( IOBase ) : newlines = 0   def __init__ ( self , file ) : self . _fd = file . fileno ( ) self . buffer = BytesIO ( ) self . writable = \" x \" in file . mode or \" r \" not in file . mode self . write = self . buffer . write if self . writable else None   def read ( self ) : while True : b = os . read ( self . _fd , max ( os . fstat ( self . _fd ) . st_size , BUFSIZE ) ) if not b : break ptr = self . buffer . tell ( ) self . buffer . seek ( 0 , 2 ) , self . buffer . write ( b ) , self . buffer . seek ( ptr ) self . newlines = 0 return self . buffer . read ( )   def readline ( self ) : while self . newlines == 0 : b = os . read ( self . _fd , max ( os . fstat ( self . _fd ) . st_size , BUFSIZE ) ) self . newlines = b . count ( b \" \\n \" ) + ( not b ) ptr = self . buffer . tell ( ) self . buffer . seek ( 0 , 2 ) , self . buffer . write ( b ) , self . buffer . seek ( ptr ) self . newlines -= 1 return self . buffer . readline ( )   def flush ( self ) : if self . writable : os . write ( self . _fd , self . buffer . getvalue ( ) ) self . buffer . truncate ( 0 ) , self . buffer . seek ( 0 )     class IOWrapper ( IOBase ) : def __init__ ( self , file ) : self . buffer = FastIO ( file ) self . flush = self . buffer . flush self . writable = self . buffer . writable self . write = lambda s : self . buffer . write ( s . encode ( \" ascii \" ) ) self . read = lambda : self . buffer . read ( ) . decode ( \" ascii \" ) self . readline = lambda : self . buffer . readline ( ) . decode ( \" ascii \" )     sys . stdin , sys . stdout = IOWrapper ( sys . stdin ) , IOWrapper ( sys . stdout ) input = lambda : sys . stdin . readline ( ) . rstrip ( \" \\n \" ) NEW_LINE"],"bleu":0.0017104523318159412,"rouge_l":0.12624172185430463}
{"id":244,"predictions":["n , k = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l . sort ( ) if l [ - 1 ] >= l [ - 1 ] : print ( - 1 ) else : print ( - 1 ) NEW_LINE"],"references":["import sys   from collections import defaultdict   POINTS_WIN = 3 POINTS_DRAW = 1 POINTS_LOSS = 0     def sort_order ( item : dict ) -> tuple : return - item [ \" points \" ] , - item [ \" score _ diff \" ] , - item [ \" score \" ]     def standings ( teams : list , games : list ) -> list : teams_data = { t : defaultdict ( int , { \" name \" : t } ) for t in teams } for lt , rt , ls , rs in games : teams_data [ lt ] [ \" score \" ] += ls teams_data [ rt ] [ \" score \" ] += rs   if ls == rs : teams_data [ lt ] [ \" points \" ] += POINTS_DRAW teams_data [ rt ] [ \" points \" ] += POINTS_DRAW elif ls < rs : teams_data [ lt ] [ \" points \" ] += POINTS_LOSS teams_data [ lt ] [ \" score _ diff \" ] -= rs - ls teams_data [ rt ] [ \" points \" ] += POINTS_WIN teams_data [ rt ] [ \" score _ diff \" ] += rs - ls else : teams_data [ lt ] [ \" points \" ] += POINTS_WIN teams_data [ lt ] [ \" score _ diff \" ] += ls - rs teams_data [ rt ] [ \" points \" ] += POINTS_LOSS teams_data [ rt ] [ \" score _ diff \" ] -= ls - rs   return list ( sorted ( teams_data . values ( ) , key = sort_order ) )     def parse_teams ( n : int ) -> list : teams = [ ] for i in range ( n ) : teams . append ( input ( ) ) return teams     def parse_games ( n : int ) -> list : games = [ ] for _ in range ( int ( n * ( n - 1 ) \/ 2 ) ) : line = sys . stdin . readline ( ) . strip ( ) teams , scores = line . split ( \" ▁ \" ) left_team , right_team = teams . split ( \" - \" ) left_score , right_score = map ( int , scores . split ( \" : \" ) ) games . append ( ( left_team , right_team , left_score , right_score ) )   return games     if __name__ == \" _ _ main _ _ \" : n = int ( input ( ) ) teams = parse_teams ( n ) games = parse_games ( n )   NEW_LINE"],"bleu":0.0025273584019778624,"rouge_l":0.1386588731937003}
{"id":245,"predictions":["t = int ( input ( ) ) for _ in range ( t ) : n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) count = 0 for i in range ( n ) : count += a [ i ] count += 1 print ( count ) NEW_LINE"],"references":["from math import log2   for t in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) )   d = dict ( )   for i in range ( len ( a ) ) : a [ i ] = int ( log2 ( a [ i ] ) )   NEW_LINE"],"bleu":0.47594973695663145,"rouge_l":0.6237750319556882}
{"id":246,"predictions":["n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ali = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in ali : NEW_LINE INDENT ali [ i ] = ali [ i ] NEW_LINE DEDENT for i in ali : NEW_LINE INDENT ali [ i ] = ali [ i ] NEW_LINE DEDENT for i in ali : NEW_LINE INDENT ali [ i ] = ali [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT ali [ i ] = ali [ i ] NEW_LINE DEDENT"],"references":["t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT"],"bleu":0.1963682599239875,"rouge_l":0.37910273839580505}
{"id":247,"predictions":["n = int ( input ( ) ) a = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) : if a [ i ] == ' L ' : a [ i ] = 1 elif a [ i ] == ' L ' : a [ i ] = 1 elif a [ i ] == ' L ' and a [ i ] == ' L ' : a [ i ] = 1 elif a [ i ] == ' L ' and a [ i ] == ' L ' : a [ i ] = 1 elif a [ i ] == ' L ' and a [ i ] == ' L ' : if a [ i ] == ' L ' : a [ i ] = 1 elif a [ i ] == ' L ' and a [ i ] == ' L ' : a [ i ] = 1 elif a [ i ] == ' L ' and a [ i ] == ' L ' : a [ i ] = 1 elif a [ i ] == ' L ' : a [ i ] = ' L ' elif a [ i ] == ' L ' and a [ i ] == ' R ' : a [ i ] = 1 elif a [ i ] == ' L ' and a [ i ] == ' L ' and a [ i ] == ' L ' : a [ i ] = 1 elif a [ i ] == ' L ' : a [ i ] = 1 elif a [ i ] == ' L ' : if a [ i ] == ' L ' : if a [ i ] == ' L ' : a [ i ] = 1 else : a [ i ] = 1 elif a [ i ] == ' L ' : a [ i ] = 1 elif a [ i ] == ' L ' : if a [ i ] == ' L ' : a [ i ] = ' L ' if a [ i ] == ' L ' : a [ i ] = 1 else : a [ i ] = 1 elif a [ i ] == ' L ' and a [ i ] == ' L ' : a [ i ] = 1 elif a [ i ] == ' L ' and a [ i ] == ' R ' : a [ i ] = 1 elif a [ i ] == ' R ' and a [ i ] == ' R ' : if a [ i ] =="],"references":["class Stack ( ) : def __init__ ( self ) : self . stack = [ ] self . len = 0   def top ( self ) : assert not self . empty ( ) return self . stack [ self . len - 1 ]   def pop ( self ) : assert not self . empty ( ) self . len -= 1 return self . stack . pop ( )   def push ( self , x ) : self . len += 1 self . stack . append ( x )   def empty ( self ) : return self . len == 0   def calc ( n , pos ) : st = Stack ( ) last_pos = - 1 ans = 0 for i in range ( n ) : if pos [ i ] == \" R \" : if st . empty ( ) : ans += i - last_pos - 1 st . push ( i ) elif pos [ i ] == \" L \" : if st . empty ( ) : last_pos = i else : left_R = st . pop ( ) ; ans += ( i - left_R + 1 ) % 2 last_pos = i if st . empty ( ) : ans += n - last_pos - 1 return ans     n = int ( input ( ) ) pos = str ( input ( ) ) print ( calc ( n , pos ) ) NEW_LINE"],"bleu":0.060616289081419326,"rouge_l":0.16597860761869018}
{"id":248,"predictions":["n , m = map ( int , input ( ) . split ( ) ) arr = [ 0 ] * nfor i in range ( n ) : arr [ i ] = [ int ( i ) for i in input ( ) . split ( ) ] arr [ 0 ] = [ int ( i ) for i in input ( ) . split ( ) ] arr [ 0 ] [ 1 ] arr [ 0 ] [ 1 ] = 1 for i in range ( n ) : if arr [ i ] [ 0 ] == arr [ i ] [ 1 ] : arr [ i ] [ 1 ] = arr [ i ] [ 0 ] = arr [ i ] [ 0 ] if arr [ i ] [ 1 ] == arr [ i ] [ 1 ] == arr [ i ] [ 0 ] : arr [ i ] [ 0 ] = arr [ i ] [ 0 ] = arr [ i ] [ 1 ] if arr [ i ] [ 1 ] == arr [ i ] [ 1 ] : arr [ i ] [ 2 ] = arr [ i ] [ 1 ] if arr [ i ] [ 1 ] == arr [ i ] [ 1 ] : arr [ i ] [ 1 ] = 1 else : arr [ i ] [ 2 ] = arr [ arr [ i ] [ 1 ] ] = arr [ i ] [ 2 ] = arr [ i ] [ 1 ] if arr [ i ] [ 1 ] == arr [ i ] [ 0 ] == arr [ 1 ] [ 1 ] : arr [ i ] [ 1 ] = arr [ i ] [ 1 ] = arr [ i ] [ 0 ] if arr [ i ] [ 1 ] == arr [ i ] [ 1 ] = arr [ i ] [ 2 ] = 1 for i in range ( n ) : arr [ i ] = arr [ i ] [ 0 ] if arr [ i ] [ 0 ] == arr [ i ] [ 1 ] [ 1 ] = arr [ i ] [ 1 ] = arr [ i ] [ 0 ] = 1 for i in arr : print ( \" YES \" ) for i in range ( n ) ) : print ( \" YES \" ) NEW_LINE"],"references":["from functools import cmp_to_key           def calc_lcp ( s , sa ) :   rank = [ 0 for _ in range ( len ( s ) ) ]   for i in range ( len ( s ) ) :   rank [ sa [ i ] ] = i   lcp = [ 0 for _ in range ( len ( s ) - 1 ) ]   h = 0   for i in range ( len ( s ) ) :   if rank [ i ] < len ( s ) - 1 :   while max ( i , sa [ rank [ i ] + 1 ] ) + h < len ( s ) and s [ i + h ] == s [ sa [ rank [ i ] + 1 ] + h ] :   h += 1   lcp [ rank [ i ] ] = h   if h > 0 :   h -= 1   return lcp , rank       def suffix_array ( s ) :   sa = [ i for i in range ( len ( s ) ) ]   rank = [ ord ( s [ i ] ) for i in range ( len ( s ) ) ]   k = 1   while k < len ( s ) :   key = [ 0 for _ in range ( len ( s ) ) ]   base = max ( rank ) + 2   for i in range ( len ( s ) ) :   key [ i ] = rank [ i ] * base + ( rank [ i + k ] + 1 if i + k < len ( s ) else 0 )   sa . sort ( key = ( lambda i : key [ i ] ) )       rank [ sa [ 0 ] ] = 0   for i in range ( 1 , len ( s ) ) :   rank [ sa [ i ] ] = rank [ sa [ i - 1 ] ] if key [ sa [ i - 1 ] ] == key [ sa [ i ] ] else i   k *= 2   NEW_LINE"],"bleu":0.11135674863022806,"rouge_l":0.33705676578152327}
{"id":249,"predictions":["for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEW_LINE arr = [ 0 ] * ( n + 1 ) NEW_LINE arr = arr [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 0 , n + 1 ) : arr [ arr [ i ] ] = arr [ arr [ i ] + arr [ arr [ i ] ] NEW_LINE arr [ arr [ i ] ] = arr [ arr [ i ] ] NEW_LINE for i in range ( n ) : arr [ arr [ i ] ] = arr [ i ] [ arr [ i ] [ arr [ i ] ] = arr [ i ] [ 0 ] + arr [ arr [ i ] ] NEW_LINE arr [ arr [ i ] ] = arr [ arr [ i ] [ 0 ] NEW_LINE for i in arr : if NEW_LINE INDENT arr [ i ] [ 0 ] = arr [ i ] [ i ] NEW_LINE DEDENT DEDENT for i in arr : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE print ( ) NEW_LINE DEDENT"],"references":["from sys import stdin     for _ in range ( int ( stdin . readline ( ) ) ) : n = int ( stdin . readline ( ) ) a = list ( map ( int , stdin . readline ( ) . split ( ) ) ) res = False total = 0 for i in a : if i < 2048 : total += i elif i == 2048 : res = True break if total >= 2048 : res = True   print ( ' YES ' if res else ' NO ' ) NEW_LINE"],"bleu":0.09821832486881273,"rouge_l":0.2938935574229692}
{"id":250,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) h = { } for i in range ( n ) : h [ a [ i ] ] = 1 h [ a [ i ] ] = 1 for i in h : if i not in h : h [ a [ i ] ] = 1 else : h [ a [ i ] ] = 1 h [ a [ i ] ] = 1 h [ a [ i ] ] = 1 h = 1 for i in h : if h [ a [ i ] ] > h : h [ a [ i ] ] = 1 breakprint ( i ) NEW_LINE"],"references":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) k = 0 pas = 0 a = a [ : : - 1 ] for i in set ( a ) : s = a . count ( i ) if s > k : pas = i k = s elif s == k : if a . index ( i ) > a . index ( pas ) : pas = i k = a . count ( i ) print ( pas ) NEW_LINE"],"bleu":0.24749799341285425,"rouge_l":0.4617972802467405}
{"id":251,"predictions":["for _ in range ( int ( input ( ) ) ) : a , b , c = map ( int , input ( ) . split ( ) ) if a % b == 0 : print ( n ) else : print ( n ) NEW_LINE"],"references":["for _ in range ( int ( input ( ) ) ) : d = int ( input ( ) ) NEW_LINE def prime ( a ) : for NEW_LINE i in range ( 2 , int ( a ** 0.5 ) + 1 ) : NEW_LINE if a % i == 0 : return False NEW_LINE return True NEW_LINE k = 1 NEW_LINE b = k + d NEW_LINE while not prime ( b ) : b += 1 NEW_LINE k *= b NEW_LINE p = k + d NEW_LINE while not prime ( p ) : p += 1 NEW_LINE print ( k * p ) NEW_LINE"],"bleu":0.12024952749855324,"rouge_l":0.40279665954554283}
{"id":252,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = 0 ans = 0 for i in range ( n ) : for j in range ( m ) : if a [ i ] in a [ j ] : ans += ( a [ j ] - a [ i ] ) print ( ans ) NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) s = sum ( l )   def solve ( ) : if s < n : return [ - 1 ] for i in range ( m ) : if l [ i ] > n - i : return [ - 1 ]   ov = s - n idx = 1 sln = [ ]   for i in range ( m ) : if ov > 0 and idx != 1 : d = min ( ov , l [ i - 1 ] - 1 ) idx -= d ov -= d sln . append ( idx ) idx += l [ i ]   return sln   print ( * solve ( ) ) NEW_LINE"],"bleu":0.3013430774959642,"rouge_l":0.48382699219234104}
{"id":253,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in range ( n ) : if a [ i ] != b [ i ] : c += a [ i ] else : if b [ i ] == a [ i ] : c += a [ i ] else : c += 1 if b [ i ] == b [ i ] : print ( - a [ i ] ) else : print ( - 1 ) NEW_LINE"],"references":["n = int ( input ( ) ) mn1 , mx1 = map ( int , input ( ) . split ( ) ) mn2 , mx2 = map ( int , input ( ) . split ( ) ) mn3 , mx3 = map ( int , input ( ) . split ( ) )   fd = n - mn2 - mn3if fd > mx1 : fd = mx1n -= fdsd = n - mn3if sd > mx2 : sd = mx2td = n - sdprint ( fd , sd , td ) NEW_LINE"],"bleu":0.2884970715670053,"rouge_l":0.44738811555156416}
{"id":254,"predictions":["n , k = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( k ) : l [ i ] = l [ i ] if l [ i ] == 0 or l [ i ] == 1 : l [ i ] = l [ i ] else : l [ i ] = l [ i ] for i in l : if l [ i ] == 0 : l [ i ] = l [ i ] else : l [ i ] = l [ i ] l [ i ] = l [ i ] for i in l : l [ i ] = l [ i ] if l [ i ] == 1 : l [ i ] = l [ i ] else : l [ i ] = l [ i ] l [ l [ i ] ] = 1 l [ i ] = l [ i ] for i in l [ i ] : l [ i ] ] = l [ i ] for i in l [ i ] : l [ i ] = l [ i ] l [ i ] = l [ i ] l [ i ] l [ i ] = l [ i ] for i in l [ i ] if l [ i ] == 0 : l [ i ] = l [ i ] else : l [ i ] = l [ i ] l [ i ] l [ i ] l [ l [ i ] ] = l [ i ] = l [ i ] for i in l [ i ] : l [ i ] = l [ i ] if l [ i ] > 0 else : l [ i ] = l [ i ] l [ i ] = l [ i ] else : l [ i ] = l [ i ] for i in l [ i ] for i in l [ i ] : l [ i ] = l [ i ] if l [ i ] == 0 : l [ i ] = l [ i ] l [ i ] else : l [ i ] = l [ i ] l [ i ] l [ i ] else : l [ i ] = l [ i ] = l [ i ]   if l [ i ] == 0 else : l [ i ] = l [ i ] for i in l [ i ] : l . append ( l [ i ] ) l [ i ] = l [ i ] if l [ i ] == l [ i ] and l [ i ] else"],"references":["n , k = map ( int , input ( ) . split ( ) ) s = input ( ) d = { }   val = 0 ; i = 0 while i < n : count = 1 ch = s [ i ] i += 1 while i < n : if s [ i ] == s [ i - 1 ] : count += 1 i += 1 else : break d [ ch ] = d . get ( ch , 0 ) + ( count \/\/ k )   print ( max ( d . values ( ) ) ) NEW_LINE"],"bleu":0.059542044635164645,"rouge_l":0.21170238675109598}
{"id":255,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in range ( n ) : if a [ i ] == b [ i ] : c += 1 b += a [ i ] print ( c ) NEW_LINE"],"references":["from collections import defaultdict as dcdef mlt ( ) : return map ( int , input ( ) . split ( ) ) def arp ( ) : return [ * mlt ( ) ]     s = input ( ) mp = dc ( lambda : 0 ) for n in s : mp [ ord ( n ) - 97 ] += 1 cntr = 0 for n in s : if mp [ ord ( n ) - 97 ] % 2 : cntr += 1   if cntr <= 1 : print ( ' First ' ) else : s1 = [ ' Second ' , ' First ' ] print ( s1 [ len ( s ) % 2 ] ) NEW_LINE"],"bleu":0.15270961804864083,"rouge_l":0.3627630375114364}
{"id":256,"predictions":["n = int ( input ( ) ) print ( pow ( 2 , n \/\/ 2 , n \/\/ 2 ) ) NEW_LINE"],"references":["def dp ( n ) : if n < 0 : return 0 if not n : return 1 return 2 * dp ( n - 2 ) print ( dp ( int ( input ( ) ) ) ) NEW_LINE"],"bleu":0.18103189835434338,"rouge_l":0.29383429672447015}
{"id":257,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["def add ( vertex , neighbour ) : if vertex in graph : graph [ vertex ] . append ( neighbour ) else : graph [ vertex ] = [ neighbour ] if neighbour in graph : NEW_LINE"],"bleu":0.05375746632834463,"rouge_l":0.21588674793550922}
{"id":258,"predictions":["n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l = [ ] for i in range ( n ) : if l [ i ] % l [ i ] == 0 : l . append ( i ) else : l . append ( i ) print ( * l ) NEW_LINE"],"references":["n = int ( input ( ) ) NEW_LINE for i in range ( n , 0 , - 1 ) : if NEW_LINE n % i == 0 : n = i NEW_LINE print ( i , end = ' ▁ ' ) NEW_LINE"],"bleu":0.23804708126624435,"rouge_l":0.4887240356083086}
{"id":259,"predictions":["n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l . sort ( ) if l [ - 1 ] >= l [ - 1 ] : print ( len ( l ) ) else : l [ - 1 ] = l [ - 1 ] for i in range ( len ( l ) ) : if l [ i ] > l [ i ] : l [ i ] = l [ i - 1 ] else : l [ i ] = l [ i ] if l [ i ] - l [ i ] else : l [ i ] , l [ i ] = l [ i - 1 ] , l [ i ] else : l [ i ] , l [ i ] = l [ i - 1 ] , l [ i ] print ( \" \" . join ( l ) ) NEW_LINE"],"references":["import sysimport math   n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) i = 1 ans = [ a [ 0 ] ] while i < n : if math . gcd ( ans [ - 1 ] , a [ i ] ) == 1 : ans . append ( a [ i ] ) i += 1 else : ans . append ( 1 ) print ( len ( ans ) - n ) print ( * ans ) NEW_LINE"],"bleu":0.1904414620036276,"rouge_l":0.4023264180357357}
{"id":260,"predictions":["n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) : for j in range ( n ) : if a [ i ] [ j ] == a [ j ] [ a [ i ] ] : b [ i ] [ j ] = a [ i ] [ j ] = a [ i ] [ j ] = 1 b [ i ] [ j ] = 1 if a [ i ] [ j ] == 0 and a [ i ] [ j ] == b [ i ] : if a [ i ] [ j ] == 1 and b [ i ] [ j ] == b [ i ] [ j ] : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"references":["t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : n , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE s = list ( s ) NEW_LINE sum = 1 NEW_LINE j = 0 NEW_LINE for i in range ( n ) : if NEW_LINE s [ i ] == ' W ' : j = i NEW_LINE break NEW_LINE l = j NEW_LINE j = j + 1 NEW_LINE lst = [ ] NEW_LINE while j < n : if NEW_LINE s [ l ] == s [ j ] and j - l == 1 : j += 1 NEW_LINE l += 1 elif s [ l ] == s [ j ] and j - l > 1 : lst . append ( [ j - l - 1 , l + 1 ] ) NEW_LINE l = j NEW_LINE j += 1 else : j += 1 NEW_LINE"],"bleu":0.2232290993624786,"rouge_l":0.4163438479985242}
{"id":261,"predictions":["t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE if len ( s ) == 2 : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"references":["t = int ( input ( ) ) for _ in range ( t ) : n = int ( input ( ) ) s = input ( ) if n == 2 : if int ( s [ 0 ] ) >= int ( s [ 1 ] ) : print ( \" NO \" ) else : print ( \" YES \" ) print ( 2 ) print ( s [ 0 ] , s [ 1 ] ) else : print ( \" YES \" ) print ( 2 ) print ( s [ 0 ] , s [ 1 : ] ) NEW_LINE"],"bleu":0.28838623702353855,"rouge_l":0.5345992331568377}
{"id":262,"predictions":["n = int ( input ( ) ) s = input ( )   if n < 26 : print ( \" NO \" ) else : print ( \" NO \" ) NEW_LINE"],"references":["n = int ( input ( ) ) s = input ( ) t = s . upper ( ) if len ( set ( t ) ) == 26 : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.5394583502200822,"rouge_l":0.7302474062250598}
{"id":263,"predictions":["n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) print ( b . count ( b ) ) NEW_LINE"],"references":["a = input ( ) . rjust ( 10 ** 6 , \"0\" ) b = input ( ) . rjust ( 10 ** 6 , \"0\" ) if a > b : print ( \" > \" ) elif a < b : print ( \" < \" ) elif a == b : print ( \" = \" ) NEW_LINE"],"bleu":0.11826025615620352,"rouge_l":0.3668510945393312}
{"id":264,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = [ ] for i in range ( n ) : a , b = [ int ( i ) for i in input ( ) . split ( ) ] a . append ( a ) b = [ ] for i in range ( n ) : if a [ i ] [ a [ i ] ] == b [ i ] [ a [ i ] ] : a . append ( b [ a [ i ] ] [ a [ i ] ] ) else : a . append ( b [ i ] [ a ] ) b . append ( a [ i ] [ a [ i ] ] = b [ i ] [ a ] = b [ i ] for i in range ( n ) : b . append ( a [ i ] [ a [ i ] ] ) else : a . append ( b [ i ] ) for i in range ( n ) : a [ i ] [ a [ i ] ] = b [ i ] [ a [ i ] [ a ] = b [ i ] [ a [ i ] ] . append ( a [ i ] [ a [ i ] ] ) for i in b [ a ] : b [ i ] ] . append ( a [ i ] [ a [ i ] ] ) print ( \" YES \" ) for i in range ( n ) : print ( \" NO \" ) NEW_LINE"],"references":["n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) c = 1 ans = 0 for i in range ( n - 1 ) : if 2 * l [ i ] >= l [ i + 1 ] : c = c + 1 else : ans = max ( c , ans ) c = 1 ans = max ( ans , c ) print ( ans ) NEW_LINE"],"bleu":0.08968271924420254,"rouge_l":0.2847695000972573}
{"id":265,"predictions":["n , m = map ( int , input ( ) . split ( ) ) A = list ( map ( int , input ( ) . split ( ) ) ) B = list ( map ( int , input ( ) . split ( ) ) ) B = list ( map ( int , input ( ) . split ( ) ) ) A . sort ( ) print ( sum ( A ) ) NEW_LINE"],"references":["'''   ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Online ▁ Python ▁ Compiler . ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Code , ▁ Compile , ▁ Run ▁ and ▁ Debug ▁ python ▁ program ▁ online . Write ▁ your ▁ code ▁ in ▁ this ▁ editor ▁ and ▁ press ▁ \" Run \" ▁ button ▁ to ▁ execute ▁ it .   '''   n , a , b = map ( int , input ( ) . split ( ) ) mnn = - 1 for i in range ( 1 , n ) : k = n - i p = a \/\/ i q = b \/\/ k mn = min ( p , q ) NEW_LINE"],"bleu":0.07787535519541892,"rouge_l":0.19929430214323055}
{"id":266,"predictions":["n , m = map ( int , input ( ) . split ( ) ) arr = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] arr = [ list ( map ( int , input ( ) . split ( ) ) ) ) for _ in range ( n ) : arr [ arr [ i ] ] = arr [ arr [ i ] ] + arr [ arr [ i ] ] ans = 0 for i in range ( n ) : for j in range ( m ) : if arr [ i ] [ j ] == arr [ i ] [ j ] and arr [ i ] [ j ] == arr [ i ] [ j ] : ans += arr [ i ] [ j ] NEW_LINE"],"references":["s = input ( ) n = len ( s ) sett = { }   for i in range ( n ) : if s [ i ] not in sett : sett [ s [ i ] ] = [ ] sett [ s [ i ] ] . append ( s [ i + 1 : ] + s [ : i ] ) ans = 0   NEW_LINE"],"bleu":0.13750106690376632,"rouge_l":0.3692952499223844}
{"id":267,"predictions":["n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) print ( b ) NEW_LINE"],"references":["a = list ( input ( ) ) x = a . index ( \" ^ \" ) l = 0 r = 0 for i , j in enumerate ( a ) : if i < x and j != \" = \" : l += int ( j ) * ( x - i ) if i > x and j != \" = \" : r += int ( j ) * ( i - x ) if l > r : print ( \" left \" ) elif r > l : print ( \" right \" ) else : print ( \" balance \" ) NEW_LINE"],"bleu":0.06704227698637921,"rouge_l":0.3137759202700531}
{"id":268,"predictions":["from math import ceilfor _ in range ( int ( input ( ) ) ) : a , b , c , d = map ( int , input ( ) . split ( ) ) print ( min ( a , b , c , d ) ) NEW_LINE"],"references":["t = int ( input ( ) ) for _ in range ( t ) : a , b , c = map ( int , input ( ) . split ( ) ) if c < a : print ( c ) else : if b % c == 0 : print ( b + c ) else : print ( ( c + b ) - b % c ) NEW_LINE"],"bleu":0.3403807731474504,"rouge_l":0.5348117586384734}
{"id":269,"predictions":["n , a , b = map ( int , input ( ) . split ( ) ) print ( ( ( a + 1 ) \/\/ 2 ) NEW_LINE"],"references":["l , r , a = map ( int , input ( ) . split ( ) ) while a > 0 : if l < r : l = l + 1 else : r = r + 1 a = a - 1 print ( min ( l , r ) * 2 ) NEW_LINE"],"bleu":0.22393310322737564,"rouge_l":0.4789436117059243}
{"id":270,"predictions":["t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE temp = [ ] NEW_LINE for i in range ( b ) : NEW_LINE INDENT temp . append ( a [ i ] + 1 ) NEW_LINE DEDENT temp . sort ( ) NEW_LINE temp . sort ( ) NEW_LINE print ( temp [ 0 ] + 1 ) NEW_LINE DEDENT"],"references":["from statistics import moden = int ( input ( ) ) list_of_numbers = [ int ( x ) for x in input ( ) . split ( ) ] m = mode ( list_of_numbers ) print ( n - list_of_numbers . count ( m ) ) NEW_LINE"],"bleu":0.18139145680423394,"rouge_l":0.39436255495215927}
{"id":271,"predictions":["t = int ( input ( ) ) for _ in range ( t ) : n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) : a , b = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) c = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in range ( n ) : if a [ i ] [ 0 ] >= a [ i ] : c += a [ i ] else : c += ( a [ i ] - a [ i ] ) c += ( a [ i ] - a [ i ] ) print ( c ) NEW_LINE"],"references":["def main ( ) : petya_score = 0 vigen_score = 0 petya_time = 0 vigen_time = 0 n , c = map ( int , input ( ) . split ( ) ) task_price = list ( map ( int , input ( ) . split ( ) ) ) task_time = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( 0 , n ) : NEW_LINE"],"bleu":0.3120331308133922,"rouge_l":0.5406072933313962}
{"id":272,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) )   ans = 0 for i in range ( n - 1 , - 1 ) : for j in range ( i + 1 , n ) : if b [ i ] >= a [ j ] : ans = min ( ans , b [ i ] ) print ( ans ) NEW_LINE"],"references":["n = int ( input ( ) ) x = FalseA = [ int ( i ) for i in input ( ) . split ( ) ] for i in range ( n - 2 ) : x1 , x2 = min ( A [ i ] , A [ i + 1 ] ) , max ( A [ i ] , A [ i + 1 ] ) for j in range ( i + 1 , n - 1 ) : X1 , X2 = min ( A [ j ] , A [ j + 1 ] ) , max ( A [ j ] , A [ j + 1 ] ) if ( x1 < X1 and X1 < x2 and x2 < X2 ) : x = True elif ( X1 < x1 and X2 > x1 and X2 < x2 ) : x = Trueif ( x ) : print ( \" yes \" ) else : print ( \" no \" ) NEW_LINE"],"bleu":0.18723756280384424,"rouge_l":0.393639087347315}
{"id":273,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) : if b [ a [ i ] ] == 0 : b [ a [ i ] ] = 1 elif b [ a [ i ] ] == 0 : b [ a [ i ] ] = 1 else : b [ a [ i ] ] = 1 if b [ a [ i ] ] == 0 : b [ a [ i ] ] = 1 elif b [ a [ i ] ] == 1 : b [ a [ i ] ] = 1 else : b [ a [ i ] ] = b [ a [ i ] ] = b [ a [ i ] ] else : b [ b [ i ] ] = 1 if b [ i ] ] == 1 : b [ a [ i ] ] = b [ i ] print ( \" YES \" ) print ( \" NO \" ) NEW_LINE"],"references":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) R1 , R2 = map ( int , input ( ) . split ( ) ) print ( sum ( a [ R1 - 1 : R2 - 1 ] ) ) NEW_LINE"],"bleu":0.16803441343130474,"rouge_l":0.37908237471902684}
{"id":274,"predictions":["n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) arr . sort ( ) count = 0 for i in range ( n ) : if ( i % 7 ) == 0 : count += 1 else : count += 1 print ( count ) NEW_LINE"],"references":["n = int ( input ( ) ) mx = n \/\/ 7 * 2 + min ( n % 7 , 2 ) mn = n \/\/ 7 * 2 + max ( n % 7 - 5 , 0 )   print ( mn , mx )     NEW_LINE"],"bleu":0.16782240192459968,"rouge_l":0.3893240498984624}
{"id":275,"predictions":["s = input ( ) NEW_LINE s1 = len ( s ) NEW_LINE if len ( s1 ) == len ( s2 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"],"references":["tk = input ( ) m = tk [ 0 ] n = tk [ 1 ] flag = 0 inp2 = list ( map ( str , input ( ) . split ( ) ) )   for st in inp2 : if st [ 0 ] == m : print ( \" YES \" ) flag = 1 break elif st [ 1 ] == n : print ( \" YES \" ) flag = 1 break     if flag == 0 : print ( \" NO \" )                                   NEW_LINE"],"bleu":0.12436149092894716,"rouge_l":0.3223091976516634}
{"id":276,"predictions":["n , k = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in range ( n ) : if l [ i ] == l [ i ] : l [ i ] = l [ i ] - l [ i ] else : l [ i ] = l [ i ] - l [ i - 1 ] d = 0 for i in range ( n ) : for j in range ( i + 1 , n ) : if l [ i ] [ j ] == l [ i ] [ j ] : l [ i ] [ j ] = l [ i ] [ j ] - l [ i ] [ j ] NEW_LINE"],"references":["def main ( ) : a = b = 1 for _ in range ( int ( input ( ) ) ) : s = input ( ) if s in ( \" UL \" , \" DR \" ) : a += 1 elif s in ( \" UR \" , \" DL \" ) : b += 1 elif s == \" ULDR \" : a += 1 b += 1 print ( a * b )     if __name__ == ' _ _ main _ _ ' : main ( ) NEW_LINE"],"bleu":0.06303717455831746,"rouge_l":0.227769326510856}
{"id":277,"predictions":["t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : n = int ( input ( ) ) NEW_LINE ali = list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE ali = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ali = ali [ 0 ] NEW_LINE ali = ali [ 1 ] NEW_LINE for i in ali : ali [ i ] = ali [ i ] NEW_LINE if ali [ i ] <= ali [ i ] : NEW_LINE INDENT ali [ i ] = ali [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT ali [ i ] = 1 NEW_LINE DEDENT DEDENT"],"references":["import sysfrom os import pathif ( path . exists ( ' input . txt ' ) and path . exists ( ' output . txt ' ) ) : sys . stdout = open ( ' output . txt ' , ' w ' ) sys . stdin = open ( ' input . txt ' , ' r ' )   NEW_LINE"],"bleu":0.02356042570031431,"rouge_l":0.18878572728927726}
{"id":278,"predictions":["num = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( 1 , len ( l ) ) : if l [ i ] <= l [ i ] : l [ i ] -= 1 l [ i ] -= 1 l [ i ] -= 1 l [ i ] -= 1 for i in l : print ( i , end = \" ▁ \" ) NEW_LINE"],"references":["import io , osinput = io . BytesIO ( os . read ( 0 , os . fstat ( 0 ) . st_size ) ) . readlinefrom collections import defaultdict , dequedef bfs ( node ) : vis [ node ] = 1 q = deque ( [ node ] ) while q : cur = q . popleft ( ) dict1 = { } for j in edge [ cur ] : if vis [ j ] == 0 : vis [ j ] = 1 q . append ( j ) if topic [ j - 1 ] == topic [ cur - 1 ] : return False if topic [ j - 1 ] < topic [ cur - 1 ] : dict1 [ topic [ j - 1 ] ] = 1 b = len ( dict1 . keys ( ) ) if b != topic [ cur - 1 ] - 1 : return False return Truen , m = list ( map ( int , input ( ) . split ( ) ) ) edge = defaultdict ( list ) for i in range ( m ) : u , v = list ( map ( int , input ( ) . split ( ) ) ) edge [ u ] . append ( v ) edge [ v ] . append ( u ) topic = list ( map ( int , input ( ) . split ( ) ) ) vis = [ 0 ] * ( n + 1 ) s = 0 for i in range ( 1 , n + 1 ) : if vis [ i ] == 0 : temp = bfs ( i ) if temp == False : s += 1 breakif s == 1 : print ( - 1 ) else : ans = [ ] for i in range ( n ) : ans . append ( [ topic [ i ] , i + 1 ] ) ans . sort ( key = lambda x : x [ 0 ] , reverse = False ) num = [ ] for i in range ( n ) : num . append ( ans [ i ] [ 1 ] ) print ( \" ▁ \" . join ( str ( x ) for x in num ) ) NEW_LINE"],"bleu":0.032497597215186504,"rouge_l":0.26700579675854724}
{"id":279,"predictions":["n , k = map ( int , input ( ) . split ( ) ) s = input ( ) flag = Falsefor i in range ( n ) : if s [ i ] == '1' : flag = True break if flag : print ( flag ) NEW_LINE"],"references":["import sys , functools , collections , bisect , math , NEW_LINE INDENT heapqinput = sys . stdin . readline NEW_LINE DEDENT"],"bleu":0.030999373127217372,"rouge_l":0.1180454765360426}
{"id":280,"predictions":["for i in range ( int ( input ( ) ) ) : n , m = map ( int , input ( ) . split ( ) ) print ( ' NO ' ) NEW_LINE"],"references":["def solve ( ) : n = int ( input ( ) ) NEW_LINE i = 0 NEW_LINE while 2021 * i <= n : if NEW_LINE ( n - ( i * 2021 ) ) % 2020 == 0 : NEW_LINE return True NEW_LINE i += 1 NEW_LINE return False       for t in range ( int ( input ( ) ) ) : if NEW_LINE solve ( ) : print ( ' YES ' ) else : print ( ' NO ' ) NEW_LINE"],"bleu":0.14441563581583672,"rouge_l":0.359882005899705}
{"id":281,"predictions":["n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l . sort ( ) if l [ - 1 ] == 0 : print ( 0 ) else : print ( 0 ) NEW_LINE"],"references":["from collections import Counter     def gcd ( a , b ) : return a if b == 0 else gcd ( b , a % b )     n = int ( input ( ) ) count = Counter ( ) for e in map ( int , input ( ) . split ( ) ) : count [ e ] += 1 res = [ ] while sum ( count . values ( ) ) > 0 : cur = max ( count . keys ( ) ) count [ cur ] -= 1 if count [ cur ] == 0 : del count [ cur ] for e in res : g = gcd ( cur , e ) count [ g ] -= 2 if count [ g ] == 0 : del count [ g ] res . append ( cur ) print ( * res ) NEW_LINE"],"bleu":0.150394914459994,"rouge_l":0.38125}
{"id":282,"predictions":["for _ in range ( int ( input ( ) ) ) : n , s = map ( int , input ( ) . split ( ) ) if s == 1 : print ( len ( s ) ) else : print ( len ( s ) ) NEW_LINE"],"references":["res = [ ]   for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEW_LINE if n < 0 : NEW_LINE INDENT res . append ( - n ) else : NEW_LINE s = 0 NEW_LINE DEDENT i = 0 NEW_LINE while s < n : i += 1 NEW_LINE s += i NEW_LINE if s == n or s - n > 1 : NEW_LINE INDENT res . append ( i ) else : NEW_LINE res . append ( i + 1 )   for i in res : print ( i ) NEW_LINE DEDENT"],"bleu":0.15137441138189417,"rouge_l":0.41351927174123576}
{"id":283,"predictions":["n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in range ( n ) : if a [ i ] == a [ i ] : c += 1 b += a [ i ] print ( c ) NEW_LINE"],"references":["s = input ( ) horizontal = - 1 vertical = - 1 v = [ ] h = [ ] for i in range ( len ( s ) ) : if s [ i ] == \"0\" : vertical += 1 vertical %= 2 if vertical == 0 : ans = 1 else : ans = 3 print ( ans , 1 ) else : horizontal += 1 horizontal %= 4 print ( horizontal + 1 , 2 ) NEW_LINE"],"bleu":0.13904477161445378,"rouge_l":0.3228145825166601}
{"id":284,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) result = 0 for x in range ( n - 1 ) : result += a [ x - 1 ] * ( x - 1 ) ** 2 print ( result ) NEW_LINE"],"references":["import mathn = int ( input ( ) ) if ( n == 0 ) : print ( 1 ) elif ( n == 1 ) : print ( 4 ) elif ( n == 2 ) : print ( 8 ) elif ( n == 3 ) : print ( 16 ) else : k = 4 + 8 * ( int ( math . sqrt ( n * n \/ 2 ) ) ) p = int ( math . sqrt ( n * n \/ 2 ) ) if ( p * p + ( p + 1 ) * ( p + 1 ) > n * n ) : k -= 4 print ( k ) NEW_LINE"],"bleu":0.07402236486064159,"rouge_l":0.30151695926367816}
{"id":285,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) : if b [ a [ i ] == 0 : b [ a [ i ] ] = b [ a [ i ] ] else : b [ a [ i ] ] = b [ a [ i ] ] ] = b [ a [ i ] ] = b [ a [ i ] ] print ( len ( b ) ) NEW_LINE"],"references":["import math as m   t = int ( input ( ) )   for i in range ( t ) : a , b = map ( int , input ( ) . split ( ) ) mx , mn = max ( a , b ) , min ( a , b ) c = 2 * ( mx - mn ) d = 1 ** 2 + 4 * c ds = m . sqrt ( d ) n = ( ds - 1 ) \/ 2 n = int ( n ) if int ( n ) == n else int ( n ) + 1 n += ( n * ( n + 1 ) \/\/ 2 ) % 2 != ( mx - mn ) % 2 n += ( n * ( n + 1 ) \/\/ 2 ) % 2 != ( mx - mn ) % 2 print ( n )   NEW_LINE"],"bleu":0.1682352941880576,"rouge_l":0.2928435860221056}
{"id":286,"predictions":["if __name__ == ' _ _ main _ _ ' : a , b , c , a , b = [ int ( x ) for x in input ( ) . split ( ' ▁ ' ) ] a = [ int ( x ) for x in input ( ) . split ( ' ▁ ' ) ] b = [ int ( x ) for x in input ( ) . split ( ' ▁ ' ) ] if a . sort ( ) b . sort ( ) if b . sort ( ) : print ( ' YES ' ) else : print ( ' NO ' ) NEW_LINE"],"references":["from collections import Counterimport math   def solve ( ) : a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) n = int ( input ( ) ) sum1 , sum2 = 0 , 0   for i in a : sum1 += i for i in b : sum2 += i   if math . ceil ( sum1 \/ 5 ) + math . ceil ( sum2 \/ 10 ) <= n : return \" YES \"   return \" NO \"                 print ( solve ( ) ) NEW_LINE"],"bleu":0.16197041842250776,"rouge_l":0.3358399355445145}
{"id":287,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in range ( n ) : if a [ i ] != b [ a [ i ] - 1 ] : a [ i ] += 1 b [ a [ i ] ] += 1 print ( a ) NEW_LINE"],"references":["print ( bin ( int ( input ( ) ) ) . count ( '1' ) ) NEW_LINE"],"bleu":0.061987529836742994,"rouge_l":0.25805401887406443}
{"id":288,"predictions":["for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) ) b . sort ( ) b = 0 for i in range ( len ( b ) ) : if b [ i ] >= a [ i ] : b [ i ] += a [ i ] b [ i ] += b [ i ] else : b [ i ] += b [ i ] print ( b [ n - 1 ] ) NEW_LINE"],"references":["I = lambda : list ( map ( int , input ( ) . split ( ) ) ) R = range ( I ( ) [ 0 ] ) a = I ( ) b = I ( ) c = I ( ) print ( min ( c [ i ] + c [ j ] + sum ( a [ : i ] + a [ : j ] + b [ i : ] + b [ j : ] ) for i in R for j in R if i != j ) ) NEW_LINE"],"bleu":0.20974867507404682,"rouge_l":0.44209059233449477}
{"id":289,"predictions":["from collections import Counter   n , m = [ int ( x ) for x in input ( ) . split ( ) ] a = [ int ( x ) for x in input ( ) . split ( ) ] a = [ int ( x ) for x in input ( ) . split ( ) ] a = [ int ( x ) for x in input ( ) . split ( ) ] b = [ int ( x ) for x in input ( ) . split ( ) ] a . sort ( key = lambda x : x [ y ] ) b . sort ( key = lambda x : x [ y ] ) b . sort ( key = lambda x : x [ y ] , key = lambda x : x [ y ] . count ( y [ x ] ) b . sort ( key = lambda x : x [ y ] ) b . sort ( key = lambda x : x [ y ] ) b . sort ( key = lambda x : x [ y ] . keys ( ) print ( x [ y ] , b [ a ] ) ) NEW_LINE"],"references":["n = int ( input ( ) ) a = [ 0 ] * nb = [ 0 ] * nfor i in range ( n * ( n - 1 ) \/\/ 2 - 1 ) : c , d = list ( map ( int , input ( ) . split ( ) ) ) a [ c - 1 ] += 1 b [ c - 1 ] += 1 b [ d - 1 ] += 1 f = - 1 g = - 1 for i in range ( n ) : if b [ i ] == n - 2 : if f == - 1 : f = i + 1 else : g = i + 1 breakif a [ f - 1 ] > a [ g - 1 ] : print ( f , g ) else : print ( g , f ) NEW_LINE"],"bleu":0.07062178686490753,"rouge_l":0.3173893199452305}
{"id":290,"predictions":["n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l . sort ( ) if l [ - 1 ] % 2 == 0 : print ( - 1 ) else : print ( - 1 ) NEW_LINE"],"references":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) cnt = { } for x in a : cnt [ x ] = cnt . get ( x , 0 ) + 1 for x in b : cnt [ x ] = cnt . get ( x , 0 ) - 1 if any ( [ abs ( v ) % 2 == 1 for v in cnt . values ( ) ] ) : print ( - 1 ) else : ans = sum ( [ v for v in cnt . values ( ) if v > 0 ] ) \/\/ 2 print ( ans ) NEW_LINE"],"bleu":0.12117267076281042,"rouge_l":0.4224376731301938}
{"id":291,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in range ( n ) : for j in range ( m ) : if a [ i ] [ j ] == a [ i ] [ j ] : c += 1 if a [ i ] [ j ] == 1 and b [ i ] == 1 : c += 1 if a [ i ] [ j ] == b [ i ] [ j ] : c += 1 if a [ i ] [ j ] == b [ i ] [ j ] : c += 1 if a [ i ] [ j ] == b [ i ] and b [ i ] [ j ] == 1 : print ( ' ' . join ( map ( str , c ) ) ) ) else : print ( ' NO ' ) NEW_LINE"],"references":["from sys import stdout   first_rez = [ ]     def req ( x1 , y1 , x2 , y2 ) : print ( ' ? ' , x1 , y1 , x2 , y2 ) stdout . flush ( ) x = int ( input ( ) ) if first_rez : if x1 <= first_rez [ 0 ] <= first_rez [ 2 ] <= x2 and y1 <= first_rez [ 1 ] <= first_rez [ 3 ] <= y2 : x -= 1 NEW_LINE"],"bleu":0.0410307586446715,"rouge_l":0.2418535497460042}
{"id":292,"predictions":["n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in range ( n ) : if a [ i ] != b [ a [ i ] ] : c += 1 if a [ i ] == b [ a [ i ] ] : b += 1 else : break if a [ i ] == b [ a [ i ] ] : c += 1 if a [ i ] != b [ a [ i ] ] : print ( \" NO \" ) break else : print ( \" YES \" ) NEW_LINE"],"references":["import sysfrom collections import defaultdict as ddinput = sys . stdin . readlineI = lambda : list ( map ( int , input ( ) . split ( ) ) )   n , a , b = I ( ) l = I ( ) dic = dd ( int ) for i in range ( n ) : dic [ l [ i ] ] = 1 bs = [ ] pa = dd ( int ) for i in range ( n ) : if dic [ a - l [ i ] ] == 0 : bs . append ( l [ i ] ) else : pa [ l [ i ] ] = a - l [ i ] j = 0 while j < len ( bs ) : for i in range ( j , len ( bs ) ) : cr = bs [ i ] dic [ cr ] = 2 if dic [ b - cr ] == 0 : print ( \" NO \" ) ; exit ( ) dic [ b - cr ] = 2 if dic [ a - b + cr ] == 1 : dic [ a - b + cr ] = 2 bs . append ( a - b + cr ) j += 1 NEW_LINE"],"bleu":0.20305935905018707,"rouge_l":0.3901918976545842}
{"id":293,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) cnt = 0 for i in range ( n ) : if a [ i ] % 2 == 0 : if b [ i ] % 2 == 0 : if a [ i ] % 2 == 0 : cnt += 1 else : if a [ i ] % 2 == 0 : cnt += 1 else : print ( ( int ( a [ i ] ) \/\/ 2 ) + 1 ) NEW_LINE"],"references":["import mathn = int ( input ( ) )   arr = [ ]   for i in range ( n ) : arr . append ( int ( input ( ) ) )   res = [ ] flag = Falsefor i in arr : if i % 2 == 0 : res . append ( int ( i \/ 2 ) ) continue if flag : res . append ( math . floor ( i \/ 2 ) ) flag = False else : res . append ( math . ceil ( i \/ 2 ) ) flag = True for i in res : print ( i ) NEW_LINE"],"bleu":0.23296862459921577,"rouge_l":0.38168373151308305}
{"id":294,"predictions":["for _ in range ( int ( input ( ) ) ) : n , q = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) : q = list ( map ( int , input ( ) . split ( ) ) ) ) if q == 0 : q . append ( ( q ) ) else : q . append ( ( q ) ) q . sort ( ) print ( q ) ) NEW_LINE"],"references":["from math import sqrtdef NEW_LINE dist ( a , b ) : NEW_LINE return ( sqrt ( a ** 2 + b ** 2 ) ) NEW_LINE def solve ( ) : n = int ( input ( ) ) NEW_LINE d = [ ] NEW_LINE m = [ ] NEW_LINE for p in range ( 2 * n ) : a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a == 0 : NEW_LINE INDENT m . append ( abs ( b ) ) else : NEW_LINE d . append ( abs ( a ) ) NEW_LINE DEDENT d . sort ( ) NEW_LINE m . sort ( ) NEW_LINE ans = 0 NEW_LINE for x in range ( n ) : ans += dist ( d [ x ] , m [ x ] ) NEW_LINE print ( ans ) NEW_LINE for _ in range ( int ( input ( ) ) ) : solve ( ) NEW_LINE"],"bleu":0.241708279974517,"rouge_l":0.4330203801236547}
{"id":295,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b . sort ( ) print ( * b ) NEW_LINE"],"references":["years = { \"2013\" , \"2014\" , \"2015\" } base = set ( ) for i in range ( 1 , 29 ) : if i < 10 : base . add ( \"0\" + str ( i ) ) else : base . add ( str ( i ) ) info1 = base . copy ( ) info1 . add ( \"29\" ) info1 . add ( \"30\" ) info2 = info1 . copy ( ) info2 . add ( \"31\" ) months = { \"02\" : base } for i in [ 4 , 6 , 9 , 11 ] : if i < 10 : months [ \"0\" + str ( i ) ] = info1 else : months [ str ( i ) ] = info1for i in [ 1 , 3 , 5 , 7 , 8 , 10 , 12 ] : k = ( \"0\" + str ( i ) ) if i < 10 else str ( i ) months [ k ] = info2   s = input ( )   def solve ( s , years , months ) : maps = { } i = 0 while i < len ( s ) - 9 : if s [ i + 2 ] != \" - \" or s [ i + 5 ] != \" - \" : i += 1 continue d , m , y = s [ i : i + 2 ] , s [ i + 3 : i + 5 ] , s [ i + 6 : i + 10 ] if y in years and m in months and d in months [ m ] : k = s [ i : i + 10 ] maps [ k ] = maps . get ( k , 0 ) + 1 i += 1 ans , count = \" \" , 0 for k , v in maps . items ( ) : if count < v : ans , count = k , v return ans             ans = solve ( s , years , months ) print ( ans ) NEW_LINE"],"bleu":0.005893011286666579,"rouge_l":0.18648614923883203}
{"id":296,"predictions":["n , p = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l . sort ( ) if l [ 0 ] >= l [ - 1 ] : l [ - 1 ] = l [ - 1 ] else : l [ - 1 ] = l [ - 1 ] for i in range ( n ) : print ( l [ i ] , l [ i ] ) NEW_LINE"],"references":["a = list ( map ( int , input ( ) . split ( ) ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) n = a [ 0 ] dp = [ [ 0 for i in range ( 4 ) ] for j in range ( n + 1 ) ] for i in range ( 4 ) : dp [ 0 ] [ i ] = ( - 10 ) ** ( 27 ) for i in range ( 1 , n + 1 ) : for j in range ( 1 , 4 ) : x = arr [ i - 1 ] * a [ j ] + dp [ i ] [ j - 1 ] y = dp [ i - 1 ] [ j ] dp [ i ] [ j ] = max ( x , y ) print ( dp [ n ] [ 3 ] ) NEW_LINE"],"bleu":0.2724503774424192,"rouge_l":0.4757007233273056}
{"id":297,"predictions":["n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) l . sort ( ) print ( n - 1 ) NEW_LINE"],"references":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in range ( 1 , n - 1 ) : if ( a [ i ] == 0 and a [ i - 1 ] == 1 and a [ i + 1 ] == 1 ) : a [ i + 1 ] = 0 c += 1 print ( c ) NEW_LINE"],"bleu":0.23953660296277482,"rouge_l":0.4557724752952519}
{"id":298,"predictions":["for i in range ( int ( input ( ) ) ) : n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) if k == 0 : print ( len ( b ) ) else : print ( len ( b ) ) NEW_LINE"],"references":["R = lambda : map ( int , input ( ) . split ( ) ) NEW_LINE t , = R ( ) NEW_LINE exec ( t * ' n , k = R ( ) ; a = { * R ( ) } ; i = 0 \\n while { i } & a : i + = 1 \\n print ( n + ( k > 0 ) * ( k , i + max ( a ) + 1 > > 1not ▁ in ▁ a ) [ i < n ] ) \\n ' ) NEW_LINE"],"bleu":0.1925556309980102,"rouge_l":0.349418503731991}
{"id":299,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in range ( n ) : if a [ i ] == 0 : a [ i ] = a [ i ] else : c = b [ i ] if a [ i ] != b [ i ] : a . append ( b [ i ] ) else : b . append ( a [ i ] ) b . sort ( ) b . sort ( ) if a [ i ] == 0 : b . append ( a [ i ] ) b . append ( b [ i ] ) b . append ( b [ i ] ) b [ i ] . append ( b [ i ] ) b [ i ] . append ( b [ i ] ) else : b [ i ] . append ( a [ i ] ) b [ i ] . append ( b [ i ] ) b [ i ] . append ( b [ i ] ) b [ i ] . append ( b [ i ] ) b [ i ] . append ( b [ i ] ) b . append ( b [ i ] ) b [ i ] . append ( b [ i ] ) b [ len ( b [ i ] ) b [ len ( b [ i ] ) ] . append ( b [ i ] ) b [ len ( b [ i ] ) ] . append ( b [ i ] ) b [ len ( b [ i ] ) for i in b [ i ] : if b [ i ] [ i ] == 0 : if a [ i ] [ 0 ] . append ( b [ i ] [ 0 ] ) else : b [ i ] . append ( b [ i ] [ 0 ] ) b [ i ] . append ( b [ i ] ) b [ i ] . append ( a [ i ] ) b [ i ] . append ( b [ i ] ) else : print ( \" Impossible \" ) else : print ( \" Impossible \" ) NEW_LINE"],"references":["import mathn , m = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) q = list ( map ( int , input ( ) . split ( ) ) ) if m > n : print ( \"0\/1\" ) elif n > m : if ( l [ 0 ] > 0 and q [ 0 ] > 0 ) or ( l [ 0 ] < 0 and q [ 0 ] < 0 ) : print ( \" Infinity \" ) else : print ( \" - Infinity \" )           else : a = abs ( l [ 0 ] ) b = abs ( q [ 0 ] ) while math . gcd ( a , b ) > 1 : c = math . gcd ( a , b ) a = a \/\/ c b = b \/\/ c if l [ 0 ] > 0 and q [ 0 ] > 0 : print ( str ( a ) + \" \/ \" + str ( b ) ) elif l [ 0 ] < 0 and q [ 0 ] < 0 : print ( str ( a ) + \" \/ \" + str ( b ) ) else : print ( \" - \" + str ( a ) + \" \/ \" + str ( b ) )   \t \t       \t \t   NEW_LINE"],"bleu":0.18703443022405894,"rouge_l":0.37963728302620703}
{"id":300,"predictions":["t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : n = int ( input ( ) ) NEW_LINE ali = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ali = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT ali [ i ] = 0 NEW_LINE ali [ i ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ali [ i ] = ali [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT ali [ i ] = abs ( ali [ i ] - ali [ i ] ) NEW_LINE if ( ali [ i ] == ali [ i ] ) : NEW_LINE INDENT ali [ i ] = ali [ i ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT ali [ i ] = abs ( ali [ i ] - ali [ i ] ) NEW_LINE DEDENT DEDENT print ( min ( ali ) ) NEW_LINE"],"references":["t = int ( input ( ) )   for tc in range ( t ) : n = int ( input ( ) )   athletes = [ int ( z ) for z in input ( ) . split ( ) ]   athletes . sort ( )   res = [ ]   for i in range ( 1 , n ) : a = athletes [ : i ] b = athletes [ i : ]   res . append ( abs ( max ( a ) - min ( b ) ) )   print ( min ( res ) ) NEW_LINE"],"bleu":0.22836881787647856,"rouge_l":0.48788349050972896}
{"id":301,"predictions":["for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE"],"references":["n = int ( input ( ) ) arr = [ [ 0 , 0 ] for i in range ( n ) ]   for i in range ( n ) : arr [ i ] [ 0 ] , arr [ i ] [ 1 ] = map ( int , input ( ) . split ( ) )   NEW_LINE"],"bleu":0.3554598333564938,"rouge_l":0.465648854961832}
{"id":302,"predictions":["for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEW_LINE for _ in range ( n ) : l , r = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE l , r = 0 , 0 NEW_LINE for _ in range ( r ) : r , r = map ( int , input ( ) . split ( ) ) NEW_LINE if ( l [ r ] != r ) : NEW_LINE INDENT l = l NEW_LINE r = r - 1 NEW_LINE l = r - l NEW_LINE if ( l - r ) % 2 == 0 : NEW_LINE INDENT r = r NEW_LINE DEDENT else : NEW_LINE INDENT l = r + l NEW_LINE DEDENT DEDENT if ( r - l ) % 2 == 0 : NEW_LINE INDENT print ( r ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( r ) NEW_LINE DEDENT DEDENT"],"references":["def binary ( data , target , low , high ) : if low > high : return high else : mid = int ( ( low + high ) \/ 2 ) if data [ mid ] <= target : return binary ( data , target , mid + 1 , high ) else : return binary ( data , target , low , mid - 1 ) for _ in range ( int ( input ( ) ) ) : a , b = map ( int , input ( ) . split ( ) ) l = [ 1 ] n = 1 for i in range ( 1 , a - 1 ) : l . append ( l [ - 1 ] + n ) n += 1 result = [ \" a \" ] * a k = binary ( l , b , 0 , len ( l ) - 1 ) k += 1 result [ a - 1 - k ] = \" b \" result [ - 1 - ( b - l [ k - 1 ] ) ] = \" b \" print ( * result , sep = \" \" )   NEW_LINE"],"bleu":0.19747675899269934,"rouge_l":0.3175998634346193}
{"id":303,"predictions":["n , t = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = [ ] for i in range ( n ) : if b [ i ] == 1 : b . append ( a [ i ] ) else : b . append ( b [ i ] ) b . append ( a [ i ] ) b . sort ( ) print ( b ) NEW_LINE"],"references":["n , t = [ int ( item ) for item in input ( ) . split ( ' ▁ ' ) ] cont , ans = [ ] , 2 for i in range ( n ) : hcenter , hlen = [ float ( item ) for item in input ( ) . split ( ' ▁ ' ) ] NEW_LINE"],"bleu":0.20332576426527257,"rouge_l":0.42759863809333065}
{"id":304,"predictions":["n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l . sort ( ) print ( sum ( l ) \/\/ 2 ) ) NEW_LINE"],"references":["n = int ( input ( ) ) x = 1 s = 1 while s <= n : x += 1 s += ( x * ( x + 1 ) ) \/\/ 2 print ( x - 1 ) NEW_LINE"],"bleu":0.25478371257193305,"rouge_l":0.40875049270792274}
{"id":305,"predictions":["n , m = [ int ( x ) for x in input ( ) . split ( ) ] k = [ int ( x ) for x in input ( ) . split ( ) ] a = [ int ( x ) for x in input ( ) . split ( ) ] b = [ ] for i in range ( n ) : b . append ( a [ i ] ) b . append ( b [ i ] ) b . append ( a [ i ] ) b . append ( b ) b . append ( b [ i ] )   for i in range ( n ) : for j in range ( m ) : if b [ i ] [ j ] == b [ i ] [ j ] : b . append ( b [ i ] [ j ] ) b . append ( b [ i ] [ j ] ) b [ i ] . append ( b [ i ] [ j ] ) b [ i ] . append ( b [ i ] [ j ] ) b [ i ] [ j ] . append ( b [ i ] [ j ] ) ) b [ i ] . append ( b [ i ] [ j ] )   for i in range ( n ) : for j in range ( n ) : if b [ i ] [ j ] == b [ i ] [ j ] : b [ j ] . append ( b [ i ] [ j ] ) b [ i ] . append ( b [ i ] [ j ] ) for i ] . append ( b [ i ] [ j ] ) b [ i ] . append ( b [ i ] [ j ] ) else : b [ i ] . append ( b [ i ] [ j ] ) b [ i ] . append ( b [ i ] [ j ] ) print ( \" \\n \" . join ( map ( str , b ) ) ) for i in b : print ( \" \\n \" . join ( map ( str , b ) ) ) NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) adj = [ [ ] for i in range ( n ) ] used = [ 0 for i in range ( n ) ] mark = [ 0 for i in range ( n ) ] S = [ i for i in range ( n ) ]   for i in range ( m ) : u , v = map ( int , input ( ) . split ( ) ) u , v = u - 1 , v - 1 adj [ u ] . append ( v ) adj [ v ] . append ( u ) def dfs ( v ) : global S used [ v ] = 1 S2 , S3 = [ ] , [ ] for to in adj [ v ] : mark [ to ] = 1 for to in S : if mark [ to ] == 0 : S3 . append ( to ) else : S2 . append ( to ) for to in adj [ v ] : mark [ to ] = 0 S = S2 . copy ( ) for to in S3 : dfs ( to ) ans = - 1 for i in range ( n ) : if not used [ i ] : S . remove ( i ) ans += 1 dfs ( i )   print ( ans ) NEW_LINE"],"bleu":0.17637738350714105,"rouge_l":0.3903019406694516}
{"id":306,"predictions":["n = int ( input ( ) ) NEW_LINE"],"references":["def pod ( n ) : ans = 1 while n > 0 : ans *= ( n % 10 ) n = n \/\/ 10 return ansn = input ( ) ans = ( len ( n ) - 1 ) * 9 ans = max ( ans , pod ( int ( n ) ) ) sz = len ( n ) for i in range ( 1 , sz ) : ind = sz - i num = n [ : ind ] + '9' * ( sz - ind ) if int ( num ) > int ( n ) : if num [ ind - 1 ] == '0' : num = num [ : ind - 1 ] + '9' + num [ ind : ] else : num = num [ : ind - 1 ] + str ( int ( num [ ind - 1 ] ) - 1 ) + num [ ind : ] if int ( num ) <= int ( n ) : ans = max ( ans , pod ( int ( num ) ) ) print ( ans ) NEW_LINE"],"bleu":4.827919549464126e-10,"rouge_l":0.06769316132612013}
{"id":307,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) print ( 8 , 9 , 10 ) NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) a = '9' * 200 + '0' * 199 + '1' b = '9' * 200 print ( a ) print ( b ) NEW_LINE"],"bleu":0.3477108201458275,"rouge_l":0.5374449339207049}
{"id":308,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["from sys import stdinfrom math import gcd     def main ( ) : input ( ) l = stdin . read ( ) . splitlines ( ) d = [ 3. , 1. , 2. , 2. , 2. , 1. ] * 16667 for i in range ( 4 , 100001 ) : for j in range ( i , 100001 , i ) : d [ j ] += 1. for i , s in enumerate ( l ) : a , b , c = map ( int , s . split ( ) ) k = gcd ( b , c ) ab = d [ gcd ( a , b ) ] ac = d [ gcd ( a , c ) ] bc = d [ k ] abc = d [ gcd ( a , k ) ] asz = d [ a ] - ab - ac + abc bsz = d [ b ] - bc - ab + abc csz = d [ c ] - ac - bc + abc absz = ab - abc bcsz = bc - abc acsz = ac - abc l [ i ] = ' % d ' % ( asz * bsz * csz + ( absz * ( asz + bsz ) * csz ) + ( bcsz * ( bsz + csz ) * asz ) + ( acsz * ( asz + csz ) * bsz ) + ( abc * ( asz * bsz + asz * csz + bsz * csz ) ) + ( abc * ( absz + bcsz + acsz ) * ( asz + bsz + csz ) ) + ( ( asz + bsz + csz + absz + bcsz + acsz ) * ( abc * ( abc + 1 ) * .5 ) ) + ( absz * bcsz * acsz ) + ( ( absz * ( absz + 1. ) * d [ c ] ) + ( bcsz * ( bcsz + 1. ) * d [ a ] ) + ( acsz * ( acsz + 1. ) * d [ b ] ) ) * .5 + ( ( asz + bsz + csz + abc ) * ( absz * acsz + absz * bcsz + bcsz * acsz ) ) + ( abc + ( abc * ( abc - 1. ) ) + ( abc * ( abc - 1. ) * ( abc - 2. ) \/ 6. ) ) ) print ( ' \\n ' . join ( map ( str , l ) ) )     if __name__ == ' _ _ main _ _ ' : main ( )         NEW_LINE"],"bleu":0.00004495616700635382,"rouge_l":0.09815236087221883}
{"id":309,"predictions":["n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = 0 ans = 0 for i in range ( n - 1 ) : if a [ i ] % 2 == 0 : ans += ( a [ i ] \/\/ 2 ) ans += 1 print ( ans ) NEW_LINE"],"references":["m = [ ] for _ in range ( int ( input ( ) ) ) : l = list ( map ( int , input ( ) . split ( ) ) ) x = sum ( l ) m . append ( x ) j = sorted ( m , reverse = True ) NEW_LINE"],"bleu":0.25309223885220195,"rouge_l":0.4711494775102226}
{"id":310,"predictions":["n = int ( input ( ) ) a1 = list ( map ( int , input ( ) . split ( ) ) ) a2 = list ( map ( int , input ( ) . split ( ) ) ) a = list ( map ( int , input ( ) . split ( ) ) ) a . sort ( ) if a [ 0 ] % 2 == 0 : print ( \" NO \" ) else : print ( \" YES \" ) NEW_LINE"],"references":["from sys import stdin , stdoutfrom itertools import accumulatenmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"bleu":0.17051305597748304,"rouge_l":0.40919254658385096}
{"id":311,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) dp = [ 0 ] * nfor i in range ( n ) : if a [ i ] == 0 : dp [ i ] [ a [ i ] ] += 1 b [ i ] -= 1 dp [ i ] [ a [ i ] ] += 1 if dp [ i ] [ a [ i ] ] == 1 : dp [ i ] [ a [ i ] ] += 1 else : dp [ i ] [ a [ i ] ] -= 1 dp [ i ] [ a [ i ] ] += 1 print ( dp [ a [ i ] ] ) NEW_LINE"],"references":["import sysimport itertoolsimport collections   n = int ( input ( ) ) A = [ int ( x ) for x in input ( ) . split ( ) ] perms = [ ]   def bits ( lst ) : a = [ ] for val in lst : s = [ ] for shift in range ( 29 , - 1 , - 1 ) : s += [ str ( val >> shift & 1 ) ] a += [ ' ' . join ( s [ : : - 1 ] ) ] return a   def calcCost ( perm ) : f = lambda a , b : ( ( a | b ) - b ) a = f ( perm [ 0 ] , perm [ 1 ] ) for i in range ( 2 , len ( perm ) ) : a = f ( a , perm [ i ] ) return a   def bruteForce ( ) : global perms for perm in list ( itertools . permutations ( A ) ) : perms += [ ( perm , calcCost ( perm ) ) ] print ( * perms , sep = \" \\n \" )   NEW_LINE"],"bleu":0.10879633109617569,"rouge_l":0.29302633758489316}
{"id":312,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c1 = [ 0 ] * n2 = [ 0 ] * nfor i in range ( n ) : if a [ i ] == b [ i ] : if a [ i ] == b [ i ] : a [ i ] -= 1 else : a [ i ] -= 1 b [ i ] -= 1 if a [ i ] == 0 : b [ i ] -= 1 else : a [ i ] -= 1 b [ i ] -= 1 if a [ i ] == 0 and b [ i ] == 0 : b [ i ] -= 1 else : if b [ i ] == 1 : a [ i ] -= 1 else : if a [ i ] == 1 and b [ i ] == 0 : b [ i ] -= 1 else : b [ i ] -= 1 if b [ i ] == 1 : b [ i ] -= 1 else : b [ i ] -= 1 if a [ i ] == 2 and b [ i ] == 1 : b [ i ] -= 1 if a [ i ] == 0 and b [ i ] == 0 and b [ i ] == 0 and b [ i ] == 0 : print ( ' NO ' ) exit ( ) else : print ( ' YES ' ) NEW_LINE"],"references":["t , sx , sy , ex , ey = map ( int , input ( ) . split ( ) ) winds = list ( input ( ) ) def dist ( x , y ) : return abs ( x - ex ) + abs ( y - ey ) for zzz in range ( t ) : new_x , new_y = sx , sy if ( winds [ zzz ] == ' N ' ) : new_y += 1 if ( winds [ zzz ] == ' S ' ) : new_y -= 1 if ( winds [ zzz ] == ' E ' ) : new_x += 1 if ( winds [ zzz ] == ' W ' ) : new_x -= 1 if ( dist ( new_x , new_y ) < dist ( sx , sy ) ) : sx = new_x sy = new_y if ( sx == ex and sy == ey ) : if ( zzz + 1 <= t ) : print ( zzz + 1 ) breakelse : print ( - 1 ) NEW_LINE"],"bleu":0.10342535569612016,"rouge_l":0.325067500355265}
{"id":313,"predictions":["for _ in range ( int ( input ( ) ) ) : a , b = map ( int , input ( ) . split ( ) ) print ( a * b \/\/ 2 ) NEW_LINE"],"references":["days = int ( input ( ) ) dailyReq = [ ] dailyPrice = [ ] totalCost = 0 for day in range ( days ) : a , p = input ( ) . split ( ) dailyReq . append ( int ( a ) ) dailyPrice . append ( int ( p ) )   minPrice = dailyPrice [ 0 ] for day in range ( days ) : if ( dailyPrice [ day ] < minPrice ) : minPrice = dailyPrice [ day ] totalCost += dailyReq [ day ] * minPrice   print ( totalCost )   NEW_LINE"],"bleu":0.0945013260685901,"rouge_l":0.30354824751189957}
{"id":314,"predictions":["import sys NEW_LINE def main ( ) : NEW_LINE INDENT s = input ( ) NEW_LINE last = 1 NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT if s [ i ] == s [ i + j ] and s [ i + j ] == s [ i + j ] : NEW_LINE INDENT last [ i ] = min ( last [ i ] , i + j ] ) NEW_LINE DEDENT DEDENT DEDENT def main ( ) : NEW_LINE INDENT s = sys . stdin . readline ( ) . strip ( ) NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT s [ i ] = s [ i ] NEW_LINE s [ i ] = s [ i ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT s [ i ] = s [ i ] NEW_LINE DEDENT DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT s [ i ] = s [ i ] NEW_LINE if s [ i ] == s [ i + j ] and s [ i + j ] == s [ i + j ] : NEW_LINE INDENT s [ i ] = min ( s [ i ] , s [ i + j ] ) NEW_LINE DEDENT DEDENT DEDENT return 0 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"references":["import sysimport mathfrom collections import defaultdict , dequeimport heapqs = sys . stdin . readline ( ) [ : - 1 ] ans = 0 n = len ( s ) mink = nfor i in range ( n - 1 , - 1 , - 1 ) : k = 1 z = True while i + 2 * k < n and z : if s [ i ] == s [ i + k ] == s [ i + 2 * k ] : z = False continue k += 1 if not z : mink = min ( mink , i + 2 * k ) NEW_LINE"],"bleu":0.12591316477302866,"rouge_l":0.30479871782784956}
{"id":315,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) cnt = 0 for i in range ( n ) : if a [ i ] % b [ i ] == 0 and a [ i ] % b [ i ] == 0 and b [ a [ i ] ] % b [ a [ i ] ] % b [ a [ i ] ] == 0 and b [ a [ i ] ] % b [ a [ i ] ] == 0 : cnt += 1 if a [ i ] % 2 == 0 and b [ i ] % 2 == 0 and b [ i ] % a [ i ] == 0 and a [ i ] % 2 == 0 and b [ i ] % 2 == 0 and b [ i ] % 2 == 0 and a [ i ] == 0 and b [ i ] == 0 and a [ i ] % 2 == 0 and a [ i ] % 2 == 0 and b [ i ] == 0 and b [ i ] % 2 == 0 : if a [ i ] % 2 == 0 and a [ i ] % 2 == 0 and a [ i ] == 0 and b [ i ] % 2 == 0 and b [ i ] == 0 and a [ i ] % 2 == 0 and a [ i ] % 2 == 1 : print ( \" YES \" ) NEW_LINE"],"references":["c = 0 def backtracking ( actuales , restantes , l , r , x ) : global c if sum ( actuales ) <= r and sum ( actuales ) >= l : if max ( actuales ) - min ( actuales ) >= x : c += 1 if restantes : for i in range ( len ( restantes ) ) : backtracking ( actuales + [ restantes [ i ] ] , restantes [ i + 1 : ] , l , r , x ) return 0 def main ( ) : n , l , r , x = input ( ) . split ( \" ▁ \" ) n , l , r , x = int ( n ) , int ( l ) , int ( r ) , int ( x ) difficulties = input ( ) . split ( \" ▁ \" ) for i in range ( len ( difficulties ) ) : difficulties [ i ] = int ( difficulties [ i ] ) difficulties . sort ( ) backtracking ( [ ] , difficulties , l , r , x ) global c return c if __name__ == \" _ _ main _ _ \" : print ( main ( ) ) NEW_LINE"],"bleu":0.09599329945782921,"rouge_l":0.20562686373654868}
{"id":316,"predictions":["n , m = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) r = 0 for i in range ( n ) : if l [ r ] > l [ r + 1 ] : r += 1 if ( r - l == - 1 ) : print ( l , r ) NEW_LINE"],"references":["n = int ( input ( ) ) NEW_LINE start , end = 0 , 0 NEW_LINE flag = 0 l NEW_LINE s = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( 1 , ( n + 1 ) ) : if NEW_LINE ls [ i - 1 ] != i : start = i NEW_LINE breakfor NEW_LINE j in range ( n , i - 1 , - 1 ) : NEW_LINE if ls [ j - 1 ] != j : end = j NEW_LINE breakif NEW_LINE start == 0 and end == 0 : flag = 1 NEW_LINE print ( \"0 ▁ 0\" ) else : for i in range ( start - 1 , end - 1 ) : if NEW_LINE ls [ i ] < ls [ i + 1 ] : print ( \"0 ▁ 0\" ) NEW_LINE flag = 1 NEW_LINE breakif NEW_LINE flag == 0 : print ( str ( start ) + \" ▁ \" + str ( end ) ) NEW_LINE"],"bleu":0.10729081013339403,"rouge_l":0.35676687331851675}
{"id":317,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in range ( n ) : for j in range ( m ) : if a [ i ] [ j ] == a [ i ] [ j ] : b [ i ] [ j ] = a [ i ] [ j ] = a [ i ] [ j ] else : c = 0 for i in range ( m ) : if a [ i ] [ j ] == a [ i ] [ j ] : c += 1 if a [ i ] [ j ] == b [ i ] [ j ] == a [ i ] [ j ] and a [ i ] [ j ] == b [ i ] [ j ] : print ( b [ i ] [ j ] , a [ i ] ] [ j ] ) NEW_LINE"],"references":["n , m , x , y = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) outputs , l = [ ] , 0 for i in range ( n ) : minm = max ( 1 , a [ i ] - x ) while l < m and b [ l ] < minm : l += 1 if l < m and b [ l ] <= a [ i ] + y : outputs . append ( f ' { i + 1 } ▁ { l + 1 } ' ) l += 1 print ( len ( outputs ) ) for output in outputs : print ( output )   NEW_LINE"],"bleu":0.34375926603911144,"rouge_l":0.48662599718442034}
{"id":318,"predictions":["n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) : if b [ i ] == a [ i ] : b [ i ] = a [ i ] else : b [ i ] = a [ i ] if a [ i ] == a [ i ] : b [ i ] = a [ i ] else : b [ i ] = 1 if a [ i ] == a [ i ] : b [ i ] = 1 else : b [ i ] = 1 if a [ i ] == b [ i ] : b [ i ] = 1 else : if a [ i ] == b [ i ] : b [ i ] = 1 if a [ i ] == 1 : b [ i ] = 1 else : b [ i ] = 1 if a [ i ] == 1 : b [ i ] = a [ i ] else : b [ i ] = 1 b [ i ] = 1 if a [ i ] == 1 : b [ i ] = 1 else : b [ i ] = 1 if a [ i ] : b [ i ] = 1 if a [ i ] == 1 : b [ i ] = 1 else : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"references":["import sys   window = set ( )   n , k , q = [ int ( x ) for x in input ( ) . split ( ) ] arr = [ int ( x ) for x in input ( ) . split ( ) ]   for i in range ( q ) : a , b = [ int ( x ) for x in input ( ) . split ( ) ] if ( a == 1 ) : if ( len ( window ) < k ) : window . add ( arr [ b - 1 ] ) else : window . add ( arr [ b - 1 ] ) m = min ( window ) window . remove ( m ) else : print ( \" YES \" if arr [ b - 1 ] in window else \" NO \" ) NEW_LINE"],"bleu":0.13784520216122456,"rouge_l":0.31189959714905485}
{"id":319,"predictions":["k , x , y = map ( int , input ( ) . split ( ) ) if ( k % 6 == 0 ) : print ( 1 ) elif ( k % 6 == 2 ) : if ( k % 6 == 0 ) : print ( 2 ) elif ( y % 6 == 2 ) : print ( 2 ) else : print ( - 1 ) NEW_LINE"],"references":["n = int ( input ( ) ) x = int ( input ( ) ) a = [ 0 ] * 3 a [ x ] = 1 for i in range ( n % 6 + 1 , 7 ) : if i % 2 == 1 : a [ 0 ] , a [ 1 ] = a [ 1 ] , a [ 0 ] else : a [ 1 ] , a [ 2 ] = a [ 2 ] , a [ 1 ] for i in range ( 3 ) : if a [ i ] == 1 : print ( i ) NEW_LINE"],"bleu":0.060354156186041015,"rouge_l":0.30260006842285325}
{"id":320,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) print ( a ) NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) current , ans = 0 , 1 for x in a : if current + x <= m : current += x else : current = x ans += 1   print ( ans ) NEW_LINE"],"bleu":0.5004772996925956,"rouge_l":0.616480953614926}
{"id":321,"predictions":["n = input ( ) l = len ( l ) - 1 l = 0 for i in range ( len ( l ) ) : if l [ i ] % 2 == 0 : l [ i ] = l [ i ] else : l [ i ] = l [ i - 1 ] breakprint ( ' Yes ' ) NEW_LINE"],"references":["s = input ( ) s1 = s [ : len ( s ) \/\/ 2 ] if len ( s ) % 2 == 0 : s2 = s [ len ( s ) \/\/ 2 : ] else : s2 = s [ len ( s ) \/\/ 2 + 1 : ]   s2 = s2 [ - 1 : : - 1 ] NEW_LINE"],"bleu":0.17813449908793916,"rouge_l":0.43167398731088336}
{"id":322,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) print ( b - 1 ) NEW_LINE"],"references":["for _ in range ( int ( input ( ) ) ) : S = input ( ) if S . count ( \"1\" ) == 0 : print ( 0 ) else : A = S [ S . index ( \"1\" ) : S . rfind ( \"1\" ) + 1 ] print ( A . count ( \"0\" ) ) NEW_LINE"],"bleu":0.1205973776666638,"rouge_l":0.40895682488602847}
{"id":323,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["import itertools as it   def powerset ( iterable ) : \" powerset ( [1,2,3 ] ) ▁ - - > ▁ ( ) ▁ ( 1 , ) ▁ ( 2 , ) ▁ ( 3 , ) ▁ ( 1,2 ) ▁ ( 1,3 ) ▁ ( 2,3 ) ▁ ( 1,2,3 ) \" s = list ( iterable ) return it . chain . from_iterable ( it . combinations ( s , r )   \\ for r in range ( len ( s ) + 1 ) )     n , k , A = map ( int , input ( ) . split ( ) )   best_result = 0   missing = 0   senators = [ ] for _ in range ( n ) : level , loyality = map ( int , input ( ) . split ( ) ) senators += [ [ level , loyality ] ] missing += 10 - loyality \/\/ 10   k = min ( [ k , missing ] ) NEW_LINE"],"bleu":0.026336211764121674,"rouge_l":0.22524066991955688}
{"id":324,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) ans = 0 for i in b : ans += a [ i ] else : ans += a [ i ] print ( ans ) NEW_LINE"],"references":["PI = 3.141592653589793 n , a , b = map ( int , input ( ) . split ( ) ) arr , res = [ ] , [ ] for _ in range ( n ) : u , v = input ( ) . split ( ) arr . append ( ( int ( u ) - a , int ( v ) - b ) ) x0 , y0 = arr [ - 1 ] for x1 , y1 in arr : res . append ( x1 * x1 + y1 * y1 ) dx , dy = x1 - x0 , y1 - y0 if ( x0 * dx + y0 * dy ) * ( x1 * dx + y1 * dy ) < 0 : x0 = x0 * y1 - x1 * y0 res . append ( ( x0 * x0 ) \/ ( dx * dx + dy * dy ) ) x0 , y0 = x1 , y1print ( ( max ( res ) - min ( res ) ) * PI ) NEW_LINE"],"bleu":0.12807225663906774,"rouge_l":0.35181031720602374}
{"id":325,"predictions":["n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l . sort ( ) if l [ - 1 ] >= l [ - 1 ] : l [ - 1 ] = l [ - 1 ] else : l . sort ( ) print ( len ( l ) ) NEW_LINE"],"references":["n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in a : if i > 0 and i >= a [ k - 1 ] : c = c + 1 print ( c ) NEW_LINE"],"bleu":0.3414882997352669,"rouge_l":0.5402214022140222}
{"id":326,"predictions":["n , A , B , A , B = map ( int , input ( ) . split ( ) )   if A == B : print ( N - 1 ) else : print ( N - 1 ) NEW_LINE"],"references":["holes , water_have , water_plant = map ( int , input ( ) . split ( ) ) hole_ratio = list ( map ( int , input ( ) . split ( ) ) ) plant_A = hole_ratio [ 0 ] hole_ratio = hole_ratio [ 1 : ] hole_ratio . sort ( ) hole_ratio . reverse ( ) blocked = 0 sum_non_blocked = sum ( hole_ratio ) + plant_A   for each in hole_ratio : if ( water_have * plant_A \/ sum_non_blocked >= water_plant ) : break sum_non_blocked -= each blocked += 1 print ( blocked )   NEW_LINE"],"bleu":0.0998496259989115,"rouge_l":0.32873464108644107}
{"id":327,"predictions":["n , k = map ( int , input ( ) . split ( ) ) l = [ ] for i in range ( k ) : a , b = map ( int , input ( ) . split ( ) ) l . append ( b ) l . append ( a - b ) l . append ( b ) for i in range ( k ) : a , b = map ( int , input ( ) . split ( ) ) l . append ( a ) b = [ ] for i in range ( b ) : l . append ( b ) b . append ( a ) b = [ ] for i in range ( b ) : if a [ i ] [ a ] == b [ a ] : b . append ( b ) l . append ( b ) l . append ( a ) else : b . append ( b ) l . append ( a ) for i in b : print ( i ) NEW_LINE"],"references":["''' a = [ int ( i ) ▁ for ▁ i ▁ in ▁ input ( ) . split ( ) ] x = a [ 0 ] y = a [ 1 ] z = a [ 2 ] if ▁ y = = x ▁ and ▁ z = = 0 : ▁ ▁ ▁ ▁ print ( '0 ' ) elif ▁ x > y + z : ▁ ▁ ▁ ▁ print ( ' + ' ) elif ▁ y > x + z : ▁ ▁ ▁ ▁ print ( ' - ' ) else : ▁ ▁ ▁ ▁ print ( ' ? ' ) n = int ( input ( ) ) z = [ int ( i ) ▁ for ▁ i ▁ in ▁ input ( ) . split ( ) ] x = [ ] d = 0v = ' ' for ▁ i ▁ in ▁ range ( n ) : ▁ ▁ ▁ ▁ c = 0 ▁ ▁ ▁ ▁ e = 0 ▁ ▁ ▁ ▁ for ▁ f ▁ in ▁ range ( len ( z ) ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ z [ f ] > c ▁ and ▁ f + 1 ▁ not ▁ in ▁ x : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ c = z [ f ] ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ e = f + 1 ▁ ▁ ▁ ▁ d + = ( i * c ) + 1 ▁ ▁ ▁ ▁ x . append ( e ) print ( d ) for ▁ i ▁ in ▁ x : ▁ ▁ ▁ ▁ v + = str ( i ) ▁ ▁ ▁ ▁ v + = ' ▁ ' print ( v )  f = int ( input ( ) ) g = [ int ( i ) ▁ for ▁ i ▁ in ▁ input ( ) . split ( ) ] for ▁ i ▁ in ▁ range ( len ( g ) -1 ) : ▁ ▁ ▁ ▁ for ▁ f ▁ in ▁ range ( len ( g ) -1 - i ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ g [ f ] > g [ f + 1 ] : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ g [ f ] , g [ f + 1 ] = g [ f + 1 ] , g [ f ] if ▁ g [ 0 ] * g [ 1 ] > g [ -2 ] * g [ -3 ] ▁ and ▁ g [ -1 ] > 0 : ▁ ▁ ▁ ▁ print ( g [ -1 ] * g [ 0 ] * g [ 1 ] ) else : ▁ ▁ ▁ ▁ print ( g [ -1 ] * g [ -2 ] * g [ -3 ] ) for ▁ u ▁ in ▁ range ( int ( input ( ) ) ) : ▁ ▁ ▁ ▁ z = int ( input ( ) ) ▁ ▁ ▁ ▁ y = [ int ( f ) ▁ for ▁ f ▁ in ▁ input ( ) . split ( ) ] ▁ ▁ ▁ ▁ y . sort ( ) ▁ ▁ ▁ ▁ d = 0 ▁ ▁ ▁ ▁ for ▁ i ▁ in ▁ y : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ d + = i ▁ ▁ ▁ ▁ if ▁ d < 2048 : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( ' No ' ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ continue ▁ ▁ ▁ ▁ if ▁ 2048 ▁ in ▁ y : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( ' yes ' ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ continue ▁ ▁ ▁ ▁ for ▁ x ▁ in ▁ range ( z + 1 ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ 2048 ▁ in ▁ y : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( ' yes ' ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ break ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ for ▁ i ▁ in ▁ range ( len ( y ) -1 ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ y [ i ] = = y [ i + 1 ] : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ y [ i + 1 ] = y [ i ] *2 ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ y . pop ( i ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ i > len ( y ) -3 : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ break ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ y . sort ( ) ▁ ▁ ▁ ▁ else : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( ' no ' ) n = int ( input ( ) ) x = [ ] for ▁ i ▁ in ▁ range ( 1 , ( ( n * *2 ) \/ \/2 ) + 1 ) : ▁ ▁ ▁ ▁ x . append ( n * *2 + 1 - i ) ▁ ▁ ▁ ▁ x . append ( i ) ▁ ▁ ▁ ▁ if ▁ len ( x ) = = n : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( * x ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ x = [ ] ''' for z in range ( int ( input ( ) ) ) : z = int ( input ( ) ) x = [ int ( i ) for i in input ( ) . split ( ) ] f = 0 o = 0 t = 0 for i in range ( z ) : if x [ i ] % 3 == 0 : f += 1 elif x [ i ] % 3 == 1 : o += 1 else : t += 1 if o < t : print ( f + o + ( t - o ) \/\/ 3 ) else : print ( f + t + ( o - t ) \/\/ 3 ) NEW_LINE"],"bleu":0.0015505237115357967,"rouge_l":0.1455241847231342}
{"id":328,"predictions":["n , a , b = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) ) b = [ ] for i in range ( n ) : b . append ( a [ i ] ) b . append ( b [ i ] ) b . sort ( ) if b [ 0 ] != b [ 0 ] : b [ 0 ] = b [ 0 ] else : b [ 1 ] = b [ 1 ] print ( a [ 0 ] , b [ 1 ] ) NEW_LINE"],"references":["import heapqn = int ( input ( ) ) p = list ( map ( int , input ( ) . split ( ) ) ) f = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) m = int ( input ( ) ) choice = list ( map ( int , input ( ) . split ( ) ) ) dic = { } dic [ 1 ] = [ ] dic [ 2 ] = [ ] dic [ 3 ] = [ ] pdic = { }   for i in range ( n ) : pdic [ p [ i ] ] = 0 dic [ f [ i ] ] . append ( p [ i ] ) dic [ b [ i ] ] . append ( p [ i ] ) heapq . heapify ( dic [ 1 ] ) heapq . heapify ( dic [ 2 ] ) heapq . heapify ( dic [ 3 ] ) for i in range ( m ) : try : z = heapq . heappop ( dic [ choice [ i ] ] ) while pdic [ z ] != 0 : z = heapq . heappop ( dic [ choice [ i ] ] ) pdic [ z ] = 1 print ( z , end = ' ▁ ' ) except : print ( - 1 , end = ' ▁ ' )                   NEW_LINE"],"bleu":0.2664897028068167,"rouge_l":0.4879296677956331}
{"id":329,"predictions":["n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) cnt = 0 cnt = 0 for i in range ( n ) : if a [ i ] == ' . ' : cnt += 1 elif a [ i ] == ' . ' : cnt += 1 elif a [ i ] == ' . ' : cnt += 1 elif a [ i ] == ' . ' : cnt += 1 if a [ i ] == ' . ' : cnt += 1 else : cnt += 1 if a [ i ] == ' : cnt += 1 print ( cnt ) NEW_LINE"],"references":["n = int ( input ( ) ) arr = [ ] ans = 0 for i in range ( n ) : s = input ( ) if s not in arr : arr . append ( s ) ans += 1 print ( ans ) NEW_LINE"],"bleu":0.13020601608312876,"rouge_l":0.3380170195923214}
{"id":330,"predictions":["n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) if b == 1 : print ( ' No ' ) else : print ( ' Yes ' ) NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) ab = list ( map ( int , input ( ) . split ( ) ) ) ab . sort ( reverse = True ) for i in range ( n ) : if arr [ i ] == 0 : arr [ i ] = ab . pop ( 0 )   if arr == sorted ( arr ) : print ( \" NO \" ) else : print ( \" YES \" ) NEW_LINE"],"bleu":0.4022346778851261,"rouge_l":0.6342967923863235}
{"id":331,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) print ( b ) NEW_LINE"],"references":["a , b = input ( ) . split ( ) print ( int ( a ) + int ( str ( b ) [ : : - 1 ] ) ) NEW_LINE"],"bleu":0.20310365002330127,"rouge_l":0.4760046820132657}
{"id":332,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) a . sort ( ) flag = 0 if flag : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"references":["n = int ( input ( ) ) t = list ( input ( ) ) A = 0 B = 0 r = 1 for i in t : if int ( i ) != 7 and int ( i ) != 4 : r = 0 if r > 0 : i = ( int ( n \/ 2 ) ) - 1 j = int ( n \/ 2 )   while i >= 0 : A = A + int ( t [ i ] ) B = B + int ( t [ j ] ) i -= 1 j += 1 if r == 1 and A == B : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.11894813868000709,"rouge_l":0.39709564346519777}
{"id":333,"predictions":["def primeFactors ( n , arr ) : if n == 0 : return False return False     def primeFactors ( n , arr ) : if n == 0 : return False if primeFactors ( n ) : primeFactors ( n , arr ) : primeFactors ( n , arr ) return primeFactors ( n , arr ) def primeFactors ( n ) : primeFactors ( n , arr = [ int ( i ) for i in input ( ) . split ( ) ) ] primeFactors ( n , arr ] ) primeFactors ( n , arr = [ ] ) for i in range ( n + 1 ) : if primeFactors ( n , arr ) : primeFactors ( n , arr [ ] ) return primeFactors ( n , arr ) primeFactors ( n , arr ) : print ( primeFactors ( n , arr ) ) NEW_LINE"],"references":["l , s , l = input ( ) , ' ' , list ( map ( int , input ( ) . split ( ) ) ) for i in range ( len ( l ) ) : if l [ i ] != 0 : if ( len ( s ) < 2 or s [ - 1 ] == ' R ' ) and l [ i ] == 1 : s += ' PR ' else : if i != 0 : s += ' PLR ' * l [ i ] else : s += ' PRL ' * l [ i ] s += ' R ' else : s += ' R ' print ( s [ : - 1 ] ) NEW_LINE"],"bleu":0.1299055328138692,"rouge_l":0.26382232612507306}
{"id":334,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) for i in b : if b [ i ] == 1 : b [ i ] = 1 else : b [ i ] = 1 if b [ i ] == 0 : b [ i ] += 1 else : b [ i ] = 1 print ( b ) NEW_LINE"],"references":["s = input ( ) print ( s + s [ : : - 1 ] ) NEW_LINE"],"bleu":0.03323663136132445,"rouge_l":0.22536945812807885}
{"id":335,"predictions":["n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if ( m == 1 ) : NEW_LINE INDENT print ( m \/\/ 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( m ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def simply ( a , b ) : NEW_LINE INDENT g = math . gcd ( a , b ) NEW_LINE a = a \/\/ g NEW_LINE b = b \/\/ g NEW_LINE return ( a , b ) NEW_LINE DEDENT def mul ( a , b , c , d ) : NEW_LINE INDENT return simply ( a * c , b * d ) NEW_LINE DEDENT def add ( a , b , c , d ) : NEW_LINE INDENT return simply ( a * d + b * c , b * d ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE nxt = 0 NEW_LINE depth = 0 NEW_LINE node = 1 NEW_LINE total_node = 1 NEW_LINE p = 0 NEW_LINE q = 1 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT depth = depth + 1 NEW_LINE n = n \/\/ 2 NEW_LINE DEDENT nxt = depth NEW_LINE if ( n == 1 ) : NEW_LINE INDENT print ( str ( depth ) + \" \/ 1\" ) NEW_LINE return NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT node = node * 2 NEW_LINE total_node = total_node * 2 NEW_LINE depth = depth + 1 NEW_LINE p = p * 2 NEW_LINE q = q * 2 NEW_LINE if ( node >= n ) : NEW_LINE INDENT p = p + n * depth NEW_LINE node -= n NEW_LINE DEDENT if ( node == 1 ) : NEW_LINE INDENT nxt = depth - nxt NEW_LINE break NEW_LINE DEDENT DEDENT p , q = mul ( p , q , total_node , total_node - 1 ) NEW_LINE s , t = ( total_node - 1 ) * nxt * total_node * total_node , total_node * total_node * ( total_node - 1 ) * ( total_node - 1 ) NEW_LINE s , t = simply ( s , t ) NEW_LINE x , y = add ( p , q , s , t ) NEW_LINE print ( str ( x ) + \" \/ \" + str ( y ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"bleu":0.00016104091398315,"rouge_l":0.1295460578709849}
{"id":336,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = 0 ans = 0 for i in b : if i % 2 == 0 : c += a [ i ] else : c += 1 print ( ans ) NEW_LINE"],"references":["from collections import defaultdict , deque , Counterfrom sys import stdin , stdoutfrom heapq import heappush , heappopimport mathimport ioimport osimport mathimport bisect   NEW_LINE"],"bleu":0.018733359725067695,"rouge_l":0.06535714285714285}
{"id":337,"predictions":["n , m = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) ans = 0 for i in range ( n - 1 , - 1 ) : if l [ i ] - l [ i ] == l [ i + 1 ] : ans += 1 print ( ans ) NEW_LINE"],"references":["num = int ( input ( ) ) s = input ( ) s1 = s . count ( '1' ) s0 = s . count ( '0' ) output = abs ( s1 - s0 ) print ( output ) NEW_LINE"],"bleu":0.07209804235675946,"rouge_l":0.39622084440507827}
{"id":338,"predictions":["n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) for i in b : if b [ i ] == b [ i ] : b [ i ] = b [ i ] if b [ i ] == b [ i ] : b [ i ] = b [ i ] else : b [ i ] = b [ i ] if a [ i ] == b [ i ] : b [ i ] = b [ i ] if b [ i ] == b [ i ] : b [ i ] = b [ i ] else : b [ i ] = b [ i ] print ( \" NO \" ) NEW_LINE"],"references":["t = int ( input ( ) ) for _ in range ( t ) : n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) p = list ( map ( int , input ( ) . split ( ) ) ) p = set ( p ) while ( 1 ) : f = 0 for i in range ( n - 1 ) : if a [ i ] > a [ i + 1 ] and i + 1 in p : a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i ] f = 1 if not f : break if a == sorted ( a ) : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.32064125733023674,"rouge_l":0.5317086186960776}
{"id":339,"predictions":["n , m = map ( int , input ( ) . strip ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( 1 , len ( a ) ) : if a [ i ] % 2 == 0 : b = max ( a [ i ] , b ) b = max ( a ) b = max ( b , a ) b = max ( b ) for i in range ( n ) : if a [ i ] != b [ i ] : b = max ( a [ i ] , b [ i ] ) for i in b : if a [ i ] % 2 == 0 : b [ i ] = max ( a [ i ] , b [ i ] ) : b [ i ] = max ( b [ i ] , b [ i ] ) print ( max ( b , a ) ) NEW_LINE"],"references":["import sysinput = sys . stdin . readline   n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) adj = [ [ ] for i in range ( n ) ] for i in range ( n - 1 ) : u , v , w = map ( int , input ( ) . split ( ) ) u -= 1 v -= 1 adj [ u ] . append ( ( v , w ) ) adj [ v ] . append ( ( u , w ) ) best = [ 0 ] * nans = 0   def dfs ( u ) : stack = list ( ) visit = [ False ] * n stack . append ( ( u , - 1 ) ) while stack : u , par = stack [ - 1 ] if not visit [ u ] : visit [ u ] = True for v , w in adj [ u ] : if v != par : stack . append ( ( v , u ) ) else : cand = [ ] for v , w in adj [ u ] : if v != par : cand . append ( best [ v ] + a [ v ] - w ) cand . sort ( reverse = True ) cur = a [ u ] for i in range ( 2 ) : if i < len ( cand ) and cand [ i ] > 0 : cur += cand [ i ] global ans ans = max ( ans , cur ) best [ u ] = cand [ 0 ] if len ( cand ) > 0 and cand [ 0 ] > 0 else 0 stack . pop ( )   dfs ( 0 ) print ( ans ) NEW_LINE"],"bleu":0.1754610327730157,"rouge_l":0.37121890102022553}
{"id":340,"predictions":["for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) print ( \" NO \" ) NEW_LINE"],"references":["s = input ( ) k = int ( input ( ) ) l = len ( s )   if l % k : print ( \" NO \" ) else : f = True t = l \/\/ k for i in range ( 0 , l , t ) : sub = s [ i : i + t ] if sub != sub [ : : - 1 ] : f = False break   print ( \" YES \" if f else \" NO \" )       NEW_LINE"],"bleu":0.13110750540582913,"rouge_l":0.30869086908690874}
{"id":341,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = [ int ( x ) for x in input ( ) . split ( ) ] a = [ int ( x ) for x in input ( ) . split ( ) ]   for i in range ( n ) : if a [ i ] != a [ i ] : a [ i ] = a [ i ]   for j in range ( m ) : if a [ i ] [ j ] == a [ i ] [ j ] : a [ j ] [ j ] = a [ j ] [ a [ i ] ] else : a [ j ] [ j ] = a [ i ] [ j ] if a [ i ] [ j ] == a [ i ] [ j ] : a [ i ] ] = 1 if a [ i ] [ j ] == a [ i ] [ j ] : a [ i ] [ j ] = 1 else : a [ i ] [ j ] = 1 if a [ i ] [ j ] == a [ i ] [ j ] : a [ i ] [ j ] = a [ i ] [ j ] = 1 if a [ i ] [ j ] : a [ i ] [ j ] = 1 else : a [ i ] [ j ] = a [ i ] [ j ] = 1 if a [ i ] [ j ] == 1 and a [ i ] [ j ] == 1 : a [ i ] [ j ] = 1 else : a [ i ] [ j ] = 1 if a [ i ] [ j ] = 1 else : a [ i ] [ j ] = 1 for i in range ( n ) : for j in range ( n ) : if a [ i ] [ j ] == 0 : a [ i ] [ j ] = min ( a [ i ] , a [ j ] [ j ] ) else : a [ j ] [ a [ i ] ] = min ( a [ j ] , a [ i ] [ j ] ) print ( ' ' ' ) for i in a : print ( ' ' . ' . ' . join ( map ( str , input ( ) ) ) NEW_LINE"],"references":["from bisect import bisect_left   n , m , ta , tb , k = map ( int , input ( ) . split ( ) ) a = [ int ( X ) + ta for X in input ( ) . split ( ) ] b = [ int ( X ) for X in input ( ) . split ( ) ] an = - 1 NEW_LINE"],"bleu":0.08613713494476814,"rouge_l":0.22311631309436725}
{"id":342,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["for i in range ( int ( input ( ) ) ) : print ( max ( 0 , int ( input ( ) ) - 2 ) ) NEW_LINE"],"bleu":0.15256424708557598,"rouge_l":0.4328159645232816}
{"id":343,"predictions":["n , k = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l . sort ( ) print ( l ) NEW_LINE"],"references":["a , b = map ( int , input ( ) . split ( ) ) c = list ( map ( int , input ( ) . split ( ) ) ) ans = 0 mini = sum ( c ) for i in range ( b ) : d = i su = 0 while ( d < a ) :   su += c [ d ] d += b if su < mini :   mini = su ans = iprint ( ans + 1 ) NEW_LINE"],"bleu":0.3042582330659876,"rouge_l":0.5108877721943048}
{"id":344,"predictions":["from collections import Counter NEW_LINE n , x = map ( int , input ( ) . split ( ) ) NEW_LINE ali = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] NEW_LINE ali = [ ( ali ) for _ in ali ] NEW_LINE ali = ali . copy ( ) NEW_LINE for i in ali : NEW_LINE INDENT ali . add ( ali [ i ] ) NEW_LINE DEDENT for j in ali : NEW_LINE INDENT ali [ i ] . add ( ( ali [ j ] ) NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for x in ali : NEW_LINE INDENT if x == x : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["n , x = map ( int , input ( ) . split ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) dp = [ 0 ] * ( 1 << 18 ) ans = 0 NEW_LINE"],"bleu":0.24026207526443322,"rouge_l":0.48534834077236566}
{"id":345,"predictions":["n , m = map ( int , input ( ) . split ( ) ) A = list ( map ( int , input ( ) . split ( ) ) ) B = list ( map ( int , input ( ) . split ( ) ) ) B = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] A = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] A . sort ( ) flag = 0 ans = 0 for i in range ( n ) : for j in range ( m ) : if A [ i ] [ j ] in A [ i ] and B [ i ] [ j ] == A [ i ] [ j ] and B [ i ] [ j ] and A [ i ] [ j ] == B [ i ] [ j ] : flag = 1 breakif A [ i ] [ j ] == B [ i ] [ j ] and B [ i ] [ j ] and B [ i ] [ j ] == ' # ' and A [ i ] [ j ] == ' # ' or A [ i ] [ j ] == ' # ' and A [ i ] [ j ] == ' # ' and A [ i ] [ j ] == ' # ' and A [ i ] [ j ] == ' # ' and B [ i ] [ j ] == ' # ' and A [ i ] [ j ] == ' # ' and A [ i ] [ j ] == ' # ' and A [ j ] [ j ] == ' # ' and A [ i ] [ j ] == ' # ' and A [ i ] [ j ] == ' # ' and A [ i ] [ j ] == ' # ' and A [ i ] == ' # ' and A [ i ] [ j ] == ' # ' and A [ i ] [ j ] == ' B ' and A [ i ] [ j ] == ' # ' or ( A [ i ] == ' # ' and A [ j ] == ' # ' and A [ i ] == ' # ' and A [ j ] == ' # ' and A [ i ] == ' # ' and A [ i ] == ' # ' and A [ i ] == ' # ' and A [ i ] == ' # ' and A [ i ] [ j ] == ' # ' ) : print"],"references":["x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) x , y = map ( int , input ( ) . split ( ) ) if ( x2 - x1 ) % x == 0 and ( y2 - y1 ) % y == 0 : if ( ( x2 - x1 ) \/\/ x + ( y2 - y1 ) \/\/ y ) % 2 == 0 : print ( \" YES \" ) else : print ( \" NO \" ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.05749835748219543,"rouge_l":0.17716121856268927}
{"id":346,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = set ( a ) b = set ( b ) c = set ( b ) c . add ( b ) c . add ( b ) c . add ( a ) b . add ( b ) c . add ( b ) c . add ( b ) c . add ( b ) c . add ( b ) c . add ( b )   print ( len ( c ) ) NEW_LINE"],"references":["def new ( n ) : while n % 10 == 0 : n = n \/\/ 10 return n if __name__ == ' _ _ main _ _ ' : n = int ( input ( ) ) d = dict ( ) c = 1 flag = 1 d . setdefault ( n , 1 ) while flag == 1 : n = n + 1 n = new ( n ) d . setdefault ( n , 0 ) if d [ n ] == 0 : d [ n ] = 1 c += 1 else : flag = 0 print ( c ) NEW_LINE"],"bleu":0.10680224363779942,"rouge_l":0.24403486212316047}
{"id":347,"predictions":["a , b , x , y = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l . sort ( ) if l [ 0 ] == 1 : print ( 0 ) else : print ( 0 ) NEW_LINE"],"references":["T_ON = 0 DEBUG_ON = 0 MOD = 998244353     def solve ( ) : a , b = read_ints ( ) x , y , z = read_ints ( ) print ( max ( 0 , 2 * x + y - a ) + max ( 0 , y + 3 * z - b ) )     def main ( ) : T = read_int ( ) if T_ON else 1 for i in range ( T ) : solve ( )     def debug ( * xargs ) : if DEBUG_ON : print ( * xargs )     from collections import * import math     NEW_LINE"],"bleu":0.06248547206620853,"rouge_l":0.31226831421006174}
{"id":348,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = [ 0 ] * ( n + 1 ) ) for i in range ( 1 , n + 1 ) : if b [ i ] != b [ i ] : b [ i ] = b [ i ] else : if b [ i ] == b [ i ] : b . append ( b [ i ] ) b . append ( a [ i ] ) b . append ( b [ i ] ) print ( * b ) NEW_LINE"],"references":["n = input ( )   p0 = [ 1 ] p1 = [ 0 , 1 ]   if n == 1 : print 1 print 0 , 1 print 0 print 1 exit ( )   for i in xrange ( 2 , n + 1 ) : p = [ 0 for j in xrange ( i + 1 ) ]   for j in xrange ( len ( p1 ) ) : p [ j + 1 ] = p1 [ j ] for j in xrange ( len ( p0 ) ) : p [ j ] += p0 [ j ]   for j in xrange ( len ( p ) ) : p [ j ] %= 2   if i == n : print i print ' ▁ ' . join ( map ( str , p ) ) print i - 1 print ' ▁ ' . join ( map ( str , p1 ) )   p0 = [ p1 [ j ] for j in xrange ( len ( p1 ) ) ] p1 = [ p [ j ] for j in xrange ( len ( p ) ) ] NEW_LINE"],"bleu":0.10347724379812455,"rouge_l":0.2773202950763425}
{"id":349,"predictions":["a , b = input ( ) . split ( ) NEW_LINE if a == b : print ( \" - 1\" ) else : print ( \" - 1\" ) NEW_LINE"],"references":["x = input ( ) . lower ( ) y = input ( ) . lower ( ) if ( x < y ) : print ( \" - 1\" ) elif ( x > y ) : print ( \"1\" ) else : print ( \"0\" ) NEW_LINE"],"bleu":0.26473915554106064,"rouge_l":0.49960998439937604}
{"id":350,"predictions":["n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = list ( map ( int , input ( ) . split ( ) ) ) b = [ 0 ] * ( n ) for i in b : if b [ i ] not in b [ i ] : b [ i ] = b [ i ] else : b [ i ] = b [ i ] else : if b [ i ] : b [ i ] = b [ i ] else : b [ i ] = b [ i ] else : b [ i ] = b [ i ] if b [ i ] not in b [ i ] : b [ i ] = b [ i ] else : b [ i ] = b [ i ] print ( b [ i ] ) NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) used = [ 0 ] * ( n + 1 ) ans = [ 0 ] * ( n + 1 )   for x , y in zip ( a , a [ 1 : ] ) : z = ( y - x ) % n or n if ans [ x ] == 0 and used [ z ] or ans [ x ] != 0 and ans [ x ] != z : print ( - 1 ) exit ( ) used [ z ] = 1 ans [ x ] = z   i = 1 for j in range ( 1 , n + 1 ) : if ans [ j ] == 0 : while used [ i ] : i += 1 ans [ j ] = i i += 1   print ( * ans [ 1 : ] ) NEW_LINE"],"bleu":0.20742770069778643,"rouge_l":0.40464344941956887}
{"id":351,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = list ( map ( int , input ( ) . split ( ) ) ) c = [ ] for i in range ( n ) : if a [ i ] [ a [ i ] ] == 1 : c . append ( a [ i ] ) else : c . append ( b [ i ] ) c . append ( b [ a [ i ] ] ) c . append ( b [ a [ i ] ] ) c . append ( b [ i ] ) print ( c ) NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) while n > 0 and m > 0 : if n >= 2 * m : n = n % ( 2 * m ) elif m >= 2 * n : m = m % ( 2 * n ) else : breakprint ( n , m , sep = \" ▁ \" )   NEW_LINE"],"bleu":0.13541294089845743,"rouge_l":0.26674996095580195}
{"id":352,"predictions":["from collections import Counter   n = int ( input ( ) ) a = [ int ( x ) for x in input ( ) . split ( ) ] b = [ int ( x ) for x in input ( ) . split ( ) ] a . sort ( ) b = c [ 0 ]   for i in range ( n ) : if a [ i ] [ a [ i ] ] == b [ i ] : a [ i ] += 1 b [ a [ i ] ] += 1 b [ i ] = 1 if a [ i ] == b [ i ] : b [ i ] += 1 else : b [ i ] += 1 if b [ i ] == b [ a [ i ] ] : b [ i ] = 1   for i in b : if a [ i ] == b [ i ] : b [ i ] = 1 elif a [ i ] [ a [ i ] ] == b [ i ] : b [ a [ i ] ] += 1 b [ i ] [ a [ i ] ] : b [ a [ i ] ] += 1 else : b [ i ] += 1 if a [ i ] [ 0 ] == b [ i ] : print ( \" \" . join ( b [ a [ i ] ] ) ) NEW_LINE"],"references":["inp = input ( )   n = int ( inp [ 0 : ( len ( inp ) - 1 ) ] )   n -= 1   base = ( n \/\/ 4 ) * 16 + ( n % 2 ) * 7   def cnt ( s ) : if s == ' f ' : return 1 if s == ' e ' : return 2 if s == ' d ' : return 3 if s == ' a ' : return 4 if s == ' b ' : return 5 if s == ' c ' : return 6   print ( base + cnt ( inp [ len ( inp ) - 1 ] ) ) NEW_LINE"],"bleu":0.04664810804774834,"rouge_l":0.25978615440376945}
{"id":353,"predictions":["n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) arr . sort ( ) print ( arr [ - 1 ] ) NEW_LINE"],"references":["n = int ( input ( ) ) arr = [ i for i in range ( n ) ] NEW_LINE"],"bleu":0.2692065609201848,"rouge_l":0.49335644136337375}
{"id":354,"predictions":["n , m = map ( int , input ( ) . split ( ) ) arr = [ 0 ] * nfor i in range ( m ) : arr [ arr [ i ] ] = arr [ arr [ i ] ] = arr [ arr [ i ] - 1 ] if ( arr [ arr [ i ] ] == arr [ arr [ i ] ] ) : arr [ arr [ i ] ] = arr [ arr [ i ] - 1 ] else : arr [ arr [ i ] [ arr [ arr [ i ] ] = arr [ arr [ i ] [ arr [ i ] ] = arr [ arr [ i ] ] = arr [ arr [ i ] [ arr [ i ] = arr [ arr [ i ] ] for i in arr : arr [ i ] [ arr [ i ] ] = arr [ arr [ i ] [ arr [ i ] ] = arr [ i ] [ arr [ i ] ] = arr [ arr [ i ] ] if ( arr [ i ] < m or arr [ i ] [ 0 ] == arr [ i ] [ 1 ] else : arr [ arr [ i ] [ 0 ] = arr [ i ] [ 0 ] = max ( arr [ i ] [ 1 ] , arr [ i ] [ 1 ] ) print ( \" YES \" ) NEW_LINE"],"references":["import sysfrom collections import Counterdef fmax ( n , m , a ) : c = [ 0 ] * m b = [ 0 ] * n   if n == 3 * m : for i in range ( n \/\/ 3 ) : for j in range ( 3 ) : b [ a [ i ] [ j ] - 1 ] = j + 1 for i in range ( m ) : flag = 1 for j in range ( 3 ) : if b [ a [ i ] [ j ] - 1 ] != 0 : index = b [ a [ i ] [ j ] - 1 ] if j == 0 and index == 1 : continue b [ a [ i ] [ index - 1 ] - 1 ] = j + 1 continue b [ a [ i ] [ j ] - 1 ] = j + 1 return b if __name__ == ' _ _ main _ _ ' : input = sys . stdin . read ( ) data = list ( map ( int , input . split ( ) ) ) n = data [ 0 ] m = data [ 1 ] l = 0 a = [ ] for i in range ( m ) : a . append ( list ( map ( int , ( data [ l + 2 : l + 5 ] ) ) ) ) l = l + 3 print ( * fmax ( n , m , a ) ) NEW_LINE"],"bleu":0.1788166533360026,"rouge_l":0.3170090486671558}
{"id":355,"predictions":["n = int ( input ( ) ) print ( 1 , 3 , 2 , 4 , 2 ) NEW_LINE"],"references":["def odd ( lst , n ) : for i in range ( 1 , n + 1 , 2 ) : lst . append ( i ) def even ( lst , n ) : start = 2 if len ( lst ) == 1 or n == 3 : start = 4 for j in range ( start , n + 1 , 2 ) : lst . append ( j )           n = int ( input ( ) ) lst = [ ]   if n % 2 == 0 and n > 2 : even ( lst , n ) odd ( lst , n ) else : odd ( lst , n ) even ( lst , n ) print ( len ( lst ) ) print ( * lst ) NEW_LINE"],"bleu":0.002623449136230998,"rouge_l":0.1582771146860405}
{"id":356,"predictions":["n , m = map ( int , input ( ) . split ( ) ) x = list ( map ( int , input ( ) . split ( ) ) ) x = list ( map ( int , input ( ) . split ( ) ) ) y = [ ] for i in range ( n ) : x . append ( x [ i ] - x [ i ] ) x . append ( y [ i ] ) x . append ( x [ i ] - x [ i ] - x [ i ] - 1 , x [ i ] [ 0 ] - x [ i ] , x [ i ] , x [ i ] - 1 , x [ i ] [ 1 ] , y [ i ] [ 1 ] - x [ i ] , x [ i ] [ 1 ] , y [ i ] , y [ i ] [ 1 ] ) print ( \" \\n \" . join ( x ) ) NEW_LINE"],"references":["def count ( x1 , y1 , z1 , x2 , y2 , z2 ) : if x2 == 0 and a != 0 or y2 == 0 and b != 0 or z2 == 0 and c != 0 : return False if x2 == 0 : x2 = 1 if y2 == 0 : y2 = 1 if z2 == 0 : z2 = 1 return ( x1 \/ x2 ) ** a * ( y1 \/ y2 ) ** b * ( z1 \/ z2 ) ** c < 1     n = int ( input ( ) ) a , b , c = map ( int , input ( ) . split ( ) ) l1 , r1 = 0 , nfor i in range ( 200 ) : x1 = l1 + ( r1 - l1 ) \/ 3 l2 , r2 = 0 , n - x1 for j in range ( 200 ) : y1 = l2 + ( r2 - l2 ) \/ 3 y2 = r2 - ( r2 - l2 ) \/ 3 if count ( x1 , y1 , n - x1 - y1 , x1 , y2 , n - x1 - y2 ) : l2 = y1 else : r2 = y2 y11 = l2 x2 = r1 - ( r1 - l1 ) \/ 3 l2 , r2 = 0 , n - x2 for j in range ( 200 ) : y1 = l2 + ( r2 - l2 ) \/ 3 y2 = r2 - ( r2 - l2 ) \/ 3 if count ( x2 , y1 , n - x2 - y1 , x2 , y2 , n - x2 - y2 ) : l2 = y1 else : r2 = y2 y22 = l2 if count ( x1 , y11 , n - x1 - y11 , x2 , y22 , n - x2 - y22 ) : l1 = x1 p = y11 else : r1 = x2 p = y22print ( l1 , p , n - l1 - p ) NEW_LINE"],"bleu":0.051764144976379135,"rouge_l":0.21028440103418555}
{"id":357,"predictions":["n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = [ 0 ] * nfor i in range ( n ) : if a [ i ] [ 0 ] == b [ i ] : c [ i ] = 0 if a [ i ] == 1 : c [ i ] = 1 else : b [ i ] = 1 if a [ i ] == 1 : b [ i ] = 1 if a [ i ] == 1 and b [ i ] == 1 : b [ i ] = 1 if a [ i ] == 1 : b [ i ] = 1 elif a [ i ] == 1 : b [ i ] = 1 else : b [ i ] = 1 if a [ i ] == 1 : b [ i ] = 1 else : print ( \" NO \" ) else : print ( \" YES \" ) NEW_LINE"],"references":["s = input ( ) n = len ( s ) ans = s [ - 1 ] for i in range ( n - 2 , - 1 , - 1 ) : if s [ i ] >= ans [ - 1 ] : ans += s [ i ] print ( ans [ : : - 1 ] ) NEW_LINE"],"bleu":0.054945759195665876,"rouge_l":0.29405463310123187}
{"id":358,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = [ 0 ] * nfor i in range ( n ) : a , b = map ( int , input ( ) . split ( ) ) a [ b ] = a [ b ] if a [ b ] == 0 : a [ b ] = b else : a [ b ] = a [ b ] else : a [ b ] = a [ b ] print ( \" NO \" ) NEW_LINE"],"references":["n , k = map ( int , input ( ) . split ( ) ) lst = sorted ( [ int ( i ) % k for i in input ( ) . split ( ) ] ) low , high = 0 , n - 1 count = 0   while low < high : if lst [ low ] + lst [ high ] == k : low += 1 high -= 1 count += 2 elif lst [ low ] + lst [ high ] < k : low += 1 else : high -= 1   print ( count + 2 * ( lst . count ( 0 ) \/\/ 2 ) ) NEW_LINE"],"bleu":0.21219746177177792,"rouge_l":0.3985743985743986}
{"id":359,"predictions":["for _ in range ( int ( input ( ) ) ) : n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if m < n : NEW_LINE INDENT print ( m ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE def main ( ) : NEW_LINE INDENT n , m = map ( int , sys . stdin . read ( ) . strip ( ) . split ( ) ) NEW_LINE m %= ( 1 + n ) * n \/\/ 2 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT m -= i NEW_LINE if not m : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif m < 0 : NEW_LINE INDENT return m + i NEW_LINE DEDENT DEDENT DEDENT print ( main ( ) ) NEW_LINE"],"bleu":0.19076732275180436,"rouge_l":0.43055843886236245}
{"id":360,"predictions":["n , a , b = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l = [ ] for i in l : l . append ( i ) l . append ( len ( l ) ) for i in l : print ( * l [ i ] ) NEW_LINE"],"references":["a , b , c = map ( int , input ( ) . split ( ) ) data = list ( map ( int , input ( ) . split ( ) ) ) datb = list ( map ( int , input ( ) . split ( ) ) ) res = [ ] for i in range ( 1 , a + 1 ) : if i in data : res . append ( \"1\" ) else : res . append ( \"2\" ) print ( \" ▁ \" . join ( res ) ) NEW_LINE"],"bleu":0.3751656008659031,"rouge_l":0.5772870662460567}
{"id":361,"predictions":["for i in range ( int ( input ( ) ) ) : n , x , x = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b . sort ( ) if b [ - 1 ] > x : print ( ' Yes ' ) else : print ( ' No ' ) NEW_LINE"],"references":["n = int ( input ( ) ) NEW_LINE for p in range ( n ) : n1 , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) [ : : - 1 ] NEW_LINE if p != n - 1 : z = input ( ) NEW_LINE for x in range ( n1 ) : if NEW_LINE a [ x ] + b [ x ] > k : print ( ' No ' ) NEW_LINE break else : print ( ' Yes ' ) NEW_LINE"],"bleu":0.5224330007830765,"rouge_l":0.6609779222538263}
{"id":362,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( lst ) : NEW_LINE"],"references":["import ren = int ( input ( ) ) NEW_LINE ans , sumL = 1 , 0 NEW_LINE for s in re . split ( \" [ . ? ! ] \" , input ( ) ) : s = s . strip ( ) + ' . ' NEW_LINE L = len ( s ) NEW_LINE if L > 1 : if NEW_LINE L > n : print ( \" Impossible \" ) NEW_LINE exit ( ) NEW_LINE if sumL + L + ( sumL > 0 ) > n : ans += 1 NEW_LINE sumL = L else : sumL = sumL + L + ( sumL > 0 ) NEW_LINE print ( ans ) NEW_LINE"],"bleu":0.02818163489799742,"rouge_l":0.24746450304259637}
{"id":363,"predictions":["k , d , d = map ( int , input ( ) . split ( ) ) n , d = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l . sort ( ) if d % 2 == 0 : print ( - 1 ) else : print ( 0 ) NEW_LINE"],"references":["k , d , t = map ( int , input ( ) . split ( ) ) d = ( ( k + d - 1 ) \/\/ d ) * dn = 2 * t \/\/ ( d + k ) x = 2 * t % ( d + k ) if ( x <= 2 * k ) : ans = x \/ 2 + d * nelse : ans = x - k + d * nprint ( ans ) NEW_LINE"],"bleu":0.23277491726569852,"rouge_l":0.44176222088111056}
{"id":364,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = 0 ans = 0 for i in range ( n ) : s += ( a [ i ] - a [ i ] ) % b [ i ] ans += ( a [ i ] - b [ i ] ) print ( ans ) NEW_LINE"],"references":["n = int ( input ( ) ) NEW_LINE r = lambda : list ( map ( str , input ( ) . split ( ) ) ) NEW_LINE ans = - float ( ' inf ' ) NEW_LINE winner = \" xx \" NEW_LINE for _ in range ( n ) : name , * score = r ( ) NEW_LINE point = 0 NEW_LINE for i in score [ 2 : ] : point += int ( i )     NEW_LINE"],"bleu":0.3329704735069293,"rouge_l":0.5105123494590733}
{"id":365,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = [ ] for i in range ( n ) : if b [ i ] == b [ i ] : b . append ( b [ i ] ) else : b . append ( b [ i ] ) b [ i ] = b [ i ] for i in b [ i ] : if b [ i ] == b [ i ] : b . append ( b [ i ] ) else : b . append ( b [ i ] ) b . append ( b [ i ] ) else : b [ i ] = b [ i ] else : b [ i ] = b [ i ] else : b [ i ] = b [ i ] for i in b [ i ] : b [ i ] else : b [ i ] = b [ i ] for i in b [ i ] : if b [ i ] == b [ i ] : b [ i ] = b [ i ] else : b [ i ] = b [ i ] else : b [ i ] = b [ i ] else : b [ i ] = b [ i ]   print ( \" NO \" ) NEW_LINE"],"references":["def prime ( n ) : c = 0 for i in range ( 2 , int ( pow ( n , 0.5 ) ) + 1 ) : if ( n % i == 0 ) : c = 1 break return c       n = int ( input ( ) ) if ( n == 1 ) : print ( 3 ) elif ( n == 2 ) : print ( 4 ) else : for i in range ( 1 , n + 1 ) : c1 = prime ( n * i + 1 ) if ( c1 == 1 ) : break print ( i ) NEW_LINE"],"bleu":0.07209350004325926,"rouge_l":0.24129331842806775}
{"id":366,"predictions":["h , w , h = map ( int , input ( ) . split ( ) ) h , h , h = h , h , h , h = h , h , h , h = h , h , h , h , h , h , h , h = h , h , h , h = h , h , h , h , h = h , h , h , h , h = h , h , h = h , h , h , h , h , h = h , h , h , h = h , h , h , h , h , h = h , h , h , h , h , h = h , h , h , h , h = h , h , h = h , h , h , h = h , h , h , h = h , h , h , h = h , h , h , h , h , h = h , h , h , h , h , h = h , h , h , h = h , h , h , h , h = h , h , h , h , h , h , h = h , h , h , h , h , h = h , h , h , h = h , h , h , h = h , h , h , h , h = h , h , h = h , h , h , h = h , h , h , h , h , h , h = h , h , h = h , h , h , h , h , h = h , h , h , h , h , h , h = h , h , h , h = h , h , h , h , h , h , h = h , h , h , h = h , h , h , h , h , h , h = h , h , h , h , h , h , h , h = h , h , h , h , h , h = h , h , h , h , h , h , h = h , h , h , h = h , h , h , h , h , h = h , h = h , h , h , h , h , h , h = h , h , h , h , h , h = h , h , h , h , h , h = h , h , h , h , h , h , h = h , h , h , h , h ,"],"references":["import mathh , w = map ( int , input ( ) . split ( ) ) NEW_LINE if h \/ w >= 0.8 and h \/ w <= 1.25 and ( ( math . log ( h , 2 ) % 1 == 0 ) or ( math . log ( w , 2 ) % 1 == 0 ) ) : NEW_LINE INDENT print ( h , w ) else : NEW_LINE w1 = 2 ** ( math . log ( w , 2 ) \/\/ 1 ) NEW_LINE DEDENT h1 = min ( h , ( w1 * 1.25 ) \/\/ 1 ) NEW_LINE h2 = 2 ** ( math . log ( h , 2 ) \/\/ 1 ) NEW_LINE w2 = min ( w , ( h2 * 1.25 ) \/\/ 1 ) NEW_LINE if ( h1 \/ w1 >= 0.8 and h1 \/ w1 <= 1.25 ) and ( h2 \/ w2 >= 0.8 and h2 \/ w2 <= 1.25 ) : if NEW_LINE h1 >= h2 and h1 * w1 >= h2 * w2 : print ( int ( h1 ) , int ( w1 ) ) else : print ( int ( h2 ) , int ( w2 ) ) elif ( h1 \/ w1 >= 0.8 and h1 \/ w1 <= 1.25 ) : print ( int ( h1 ) , int ( w1 ) ) else : print ( int ( h2 ) , int ( w2 ) ) NEW_LINE"],"bleu":0.03564826814969039,"rouge_l":0.10213953488372092}
{"id":367,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) a . sort ( ) if a [ 0 ] % 2 == 0 : print ( 0 ) exit ( 0 ) if a [ 0 ] % 2 == 0 : print ( - a [ 0 ] \/\/ 2 ) else : print ( - 1 ) NEW_LINE"],"references":["n , k = map ( int , input ( ) . split ( ) ) if n < k : print ( k + n ) else : ans = [ ] ; i = 1 while i * i <= n : if n % i == 0 and n % ( n \/\/ i ) == 0 : ans . append ( [ i , n \/\/ i ] ) i += 1 ans1 = [ ] for j in ans : if k > j [ 0 ] : ans1 . append ( k * j [ 1 ] + j [ 0 ] ) if k > j [ 1 ] : ans1 . append ( k * j [ 0 ] + j [ 1 ] ) print ( min ( ans1 ) ) NEW_LINE"],"bleu":0.1508843646980484,"rouge_l":0.3655239687848383}
{"id":368,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = [ 0 ] * nfor i in range ( n ) : if b [ i ] == 1 : a [ i ] += 1 b [ i ] = 0 for i in range ( n ) : if b [ i ] == 0 : b [ i ] = b [ i ] if a [ i ] == 0 : b [ i ] += 1 else : b [ i ] = 1 if b [ i ] == 1 : b [ i ] = 0 else : b [ i ] = 1 for j in range ( n ) : if a [ i ] [ j ] == 1 : b [ i ] [ j ] = b [ i ] else : b [ i ] = b [ j ] = b [ i ] if b [ i ] == 1 : b [ i ] = b [ j ] else : b [ i ] = b [ j ] if b [ i ] == 0 : b [ i ] = b [ i ] else : b [ j ] = b [ i ] print ( ' ' . join ( map ( str , b ) ) ) NEW_LINE"],"references":["import sys , mathfrom collections import defaultdict , dequeinput = sys . stdin . readline   n = int ( input ( ) ) c = 0 for i in range ( 1 , n + 1 ) : for j in range ( i + 1 , n + 1 ) : k = i ^ j if ( i < j < k <= n and i + j > k and j + k > i and i + k > j ) : NEW_LINE"],"bleu":0.06060602028656123,"rouge_l":0.25090288924558585}
{"id":369,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in range ( n ) : for j in range ( m ) : if a [ i ] [ j ] == b [ i ] [ j ] : if a [ i ] [ j ] == b [ i ] [ j ] == a [ i ] [ j ] : c += 1 if a [ i ] [ j ] == b [ i ] [ j ] == b [ i ] [ j ] == b [ i ] [ j ] == b [ i ] [ j ] = 1 else : b [ i ] [ j ] = 1 if a [ i ] [ j ] == b [ i ] [ j ] = 1 if a [ i ] [ j ] == b [ i ] [ j ] and a [ i ] [ j ] == b [ i ] [ j ] == b [ i ] [ j ] : b [ i ] [ j ] = 1 if a [ i ] [ j ] == b [ i ] [ j ] == b [ i ] [ j ] == b [ i ] [ j ] and a [ i ] [ j ] == b [ i ] [ j ] and a [ i ] [ j ] == b [ j ] : b [ i ] [ j ] = 1 if a [ i ] [ j ] == a [ i ] [ j ] == b [ i ] and a [ i ] [ j ] == b [ i ] [ j ] == b [ i ] [ j ] : if a [ i ] [ i ] == b [ i ] and a [ i ] [ j ] == b [ i ] [ j ] and a [ i ] [ j ] == b [ i ] : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"references":["from math import sqrtn , v1 , v2 = list ( map ( int , input ( ) . split ( ) ) ) a = list ( map ( int , input ( ) . split ( ) ) ) x , y = list ( map ( int , input ( ) . split ( ) ) ) b = [ ] c = [ ] d = [ ] for i in range ( n ) : b . append ( sqrt ( ( x - a [ i ] ) ** 2 + y ** 2 ) ) d . append ( a [ i ] \/ v1 + b [ i ] \/ v2 ) e = sorted ( d [ 1 : ] ) [ 0 ] f = [ ] for i in range ( n ) : if d [ i ] == e : f . append ( i ) g = 0 h = - 1 for i in f : if h == - 1 or b [ i ] < h : h = b [ i ] g = i + 1 print ( g ) NEW_LINE"],"bleu":0.1878886884165621,"rouge_l":0.37404011461318054}
{"id":370,"predictions":["t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : n = int ( input ( ) ) NEW_LINE ali = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ali = ali [ - 1 ] NEW_LINE for i in range ( n ) : ali [ i ] = ali [ i - 1 ] NEW_LINE ali [ i ] = ali [ - 1 ] NEW_LINE for i in ali [ i ] : ali [ i ] ] = ali [ i - 1 ] NEW_LINE ali [ i ] = ali [ i ] NEW_LINE ali [ i ] = ali [ i ] NEW_LINE for i in ali [ i ] : NEW_LINE INDENT ali [ i ] = ali [ i ] NEW_LINE DEDENT print ( max ( ali ) ) NEW_LINE"],"references":["t = int ( input ( ) ) for i in range ( t ) : s = input ( ) c1 = c2 = c3 = x = y = z = 0 ans = 200000 i = 0 f = False while i < len ( s ) : if s [ i ] == '1' : c1 += 1 x = i elif s [ i ] == '2' : c2 += 1 y = i elif s [ i ] == '3' : c3 += 1 z = i                                     if c1 >= 1 and c2 >= 1 and c3 >= 1 : f = True p = max ( x , y , z ) - min ( x , y , z ) + 1 ans = min ( ans , p ) c1 = c2 = c3 = x = y = z = 0 i = i - 2 i += 1 if f == False : print ( 0 ) else : print ( ans ) NEW_LINE"],"bleu":0.1402357535055051,"rouge_l":0.2893280632411067}
{"id":371,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in b : if b [ i ] == b [ i ] : c += 1 else : break if b [ i ] == b [ i ] : b += 1 else : b [ i ] = b [ i ] print ( \" NO \" ) NEW_LINE"],"references":["s = str ( input ( ) ) a = s . find ( ' a ' ) b = s . find ( ' b ' ) c = s . find ( ' c ' ) if ( ' a ' in s ) and ( ' b ' in s ) and ( ' b ' in s ) and ( a < b < c ) and ( ' ba ' not in s ) and ( ' ca ' not in s ) and ( ' cb ' not in s ) : if s . count ( ' a ' ) == s . count ( ' c ' ) or s . count ( ' b ' ) == s . count ( ' c ' ) : print ( \" YES \" ) else : print ( \" NO \" ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.11858855258830428,"rouge_l":0.3054261760596181}
{"id":372,"predictions":["n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l . sort ( ) count = 0 for i in l : if i % 2 == 0 : count += 1 else : count += 1 print ( count ) NEW_LINE"],"references":["dontcare = input ( ) NEW_LINE a = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE sum = 0 NEW_LINE for i in a : sum += iif NEW_LINE sum % 2 == 1 : print ( sum ) else : max = sum NEW_LINE for i in a : if NEW_LINE i % 2 == 1 : max -= i NEW_LINE break NEW_LINE for i in a : if NEW_LINE i % 2 == 1 and sum - i > max : max = sum - i NEW_LINE if max % 2 == 1 : NEW_LINE INDENT print ( max ) else : NEW_LINE print ( 0 ) NEW_LINE DEDENT"],"bleu":0.08949032527932607,"rouge_l":0.3488734835355286}
{"id":373,"predictions":["n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l . sort ( ) if l [ - 1 ] >= l [ - 1 ] : print ( - 1 ) else : print ( - 1 ) NEW_LINE"],"references":["from sys import stdin   input = stdin . readlinek , n = map ( int , input ( ) . split ( ) ) NEW_LINE a = input ( ) NEW_LINE b = input ( ) NEW_LINE dp = [ [ 0 for i in range ( n + 1 ) ] for __ in range ( k + 1 ) ] NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , k + 1 ) : for NEW_LINE j in range ( 1 , n + 1 ) : NEW_LINE if a [ i - 1 ] == b [ j - 1 ] : dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j - 1 ] + 2 ) NEW_LINE ans = max ( ans , dp [ i ] [ j ] ) else : dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) - 1 NEW_LINE dp [ i ] [ j ] = max ( 0 , dp [ i ] [ j ] ) NEW_LINE print ( ans ) NEW_LINE"],"bleu":0.023027233558411114,"rouge_l":0.25825010855405994}
{"id":374,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) for i in b : if a [ i ] % b [ i ] == 0 : b [ i ] = 1 if b [ i ] == 0 : b [ i ] = 1 if a [ i ] == 0 : b [ i ] = 1 else : b [ i ] = 1 if a [ i ] == 1 : b [ i ] = 1 if b [ i ] == 0 : b [ i ] = 1 if a [ i ] == b [ i ] : b [ i ] += 1 else : print ( \" NO \" ) NEW_LINE"],"references":["def test ( i ) : aa = input ( ) . split ( ' ▁ ' ) ar = [ ] for j in aa : ar . append ( int ( j ) ) ark = [ ] for jj in ar : while jj in ark : if jj <= 0 : break jj -= 1 ark . append ( jj ) count = 0 for n in ark : count += n if len ( ark ) == i : print ( count ) i = int ( input ( ) ) if i <= 26 and i >= 2 : test ( i ) NEW_LINE"],"bleu":0.11721302782917573,"rouge_l":0.30267175572519084}
{"id":375,"predictions":["for i in range ( int ( input ( ) ) ) : a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a % b == 0 : NEW_LINE INDENT print ( 0 ) else : NEW_LINE DEDENT DEDENT"],"references":["t = int ( input ( ) ) while ( t ) : a , b = map ( int , input ( ) . split ( ) ) if ( a % b == 0 ) : print ( '0' ) else : print ( b - ( a % b ) ) t -= 1 NEW_LINE"],"bleu":0.48645447550807885,"rouge_l":0.6864355231143552}
{"id":376,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) : if b [ a [ i ] ] == a [ i ] : b [ i ] = a [ i ] else : b [ a [ i ] ] = a [ i ] DEDENT"],"references":["nr_threads = int ( input ( ) ) old_position = list ( map ( int , input ( ) . split ( ) ) ) ans = nr_threads - 1   if ( nr_threads == 1 ) : print ( 0 ) quit ( )   i = ans     while ( i > 0 ) : if ( old_position [ i - 1 ] > old_position [ i ] ) : print ( ans ) quit ( ) else : i -= 1 ans -= 1   print ( ans ) NEW_LINE"],"bleu":0.26010979754071234,"rouge_l":0.45349239280774556}
{"id":377,"predictions":["x , y , g , a , b , a , b , a , b = map ( int , input ( ) . split ( ) ) print ( ' NO ' ) NEW_LINE"],"references":["import sysdef get_ints ( ) : return list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) li1 = get_ints ( ) li2 = get_ints ( ) if li2 [ 0 ] - li1 [ 0 ] >= 0 : li2 [ 0 ] -= li1 [ 0 ] summ = sum ( li2 ) if sum ( li2 [ : 2 ] ) >= li1 [ 1 ] : if summ - ( li1 [ 1 ] ) >= li1 [ 2 ] : print ( ' yes ' ) else : print ( ' No ' ) else : print ( ' no ' ) else : print ( ' NO ' )       NEW_LINE"],"bleu":0.03256994354616873,"rouge_l":0.19341201338735245}
{"id":378,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in range ( n ) : for j in range ( m ) : if a [ i ] [ j ] == b [ i ] [ j ] : b [ i ] [ j ] = b [ i ] [ j ] if a [ i ] [ j ] == b [ i ] [ j ] and b [ i ] [ j ] == b [ i ] [ j ] or b [ i ] [ j ] == b [ i ] [ j ] : b [ i ] [ j ] = 0 else : b [ i ] [ j ] = b [ i ] [ j ] = b [ i ] [ j ] if a [ i ] [ j ] == b [ i ] [ j ] or b [ i ] [ j ] == b [ i ] [ j ] : b [ i ] [ j ] = b [ i ] [ j ] = b [ i ] [ j ] = b [ i ] [ j ] else : b [ i ] [ j ] = b [ i ] [ j ] = b [ i ] [ j ] = b [ i ] [ j ] if a [ i ] [ j ] and b [ i ] [ j ] == b [ i ] [ j ] : print ( '0' ) else : print ( '0' ) NEW_LINE"],"references":["h , w = map ( int , input ( ) . split ( ) ) r = list ( map ( int , input ( ) . split ( ) ) ) c = list ( map ( int , input ( ) . split ( ) ) ) mod = 1000000007 grid = [ [ \" ? \" for i in range ( w + 1 ) ] for j in range ( h + 1 ) ] def try_set ( row , col , target ) : if grid [ row ] [ col ] == \" ? \" : grid [ row ] [ col ] = target elif grid [ row ] [ col ] != target : raise ValueErrordef go ( ) : try : for row in range ( h ) : for col in range ( r [ row ] ) : try_set ( row , col , \" FULL \" ) try_set ( row , r [ row ] , \" EMPTY \" ) for col in range ( w ) : for row in range ( c [ col ] ) : try_set ( row , col , \" FULL \" ) try_set ( c [ col ] , col , \" EMPTY \" ) except ValueError : return 0 answer = 1 for i in range ( h ) : for j in range ( w ) : if grid [ i ] [ j ] == \" ? \" : answer = answer * 2 % mod return answerprint ( go ( ) ) NEW_LINE"],"bleu":0.21629764556416428,"rouge_l":0.3617494440326168}
{"id":379,"predictions":["n , k = map ( int , input ( ) . split ( ) ) l1 = list ( map ( int , input ( ) . split ( ) ) ) l1 = list ( map ( int , input ( ) . split ( ) ) ) l1 = list ( map ( int , input ( ) . split ( ) ) ) l1 = [ ] for i in range ( n ) : if l1 [ i ] != l1 [ i ] : l1 . append ( 0 ) else : l1 . append ( 0 ) else : l1 . append ( 0 ) l1 . append ( len ( l1 ) ) l1 . sort ( ) print ( len ( l1 ) ) NEW_LINE"],"references":["from sys import stdin , stdoutfrom os import pathrd = lambda : stdin . readline ( ) . strip ( ) wr = stdout . writeif ( path . exists ( ' input . txt ' ) ) : stdin = open ( \" input . txt \" , \" r \" ) import time , math NEW_LINE"],"bleu":0.03207146396376329,"rouge_l":0.23556454578889297}
{"id":380,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["t = int ( input ( ) ) for i in range ( t ) : n = int ( input ( ) ) arr = map ( int , input ( ) . split ( ) ) arr = set ( arr ) print ( len ( arr ) ) NEW_LINE"],"bleu":0.26119491465830486,"rouge_l":0.4604529044962259}
{"id":381,"predictions":["import mathn , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in range ( 1 , n ) : b += abs ( b [ i ] - a [ i ] ) print ( c ) NEW_LINE"],"references":["l , r = map ( int , input ( ) . split ( ) ) def f ( n ) : NEW_LINE"],"bleu":0.14465007462211796,"rouge_l":0.34825721153846156}
{"id":382,"predictions":["for _ in range ( int ( input ( ) ) ) : n , m = map ( int , input ( ) . split ( ) ) NEW_LINE ali = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ali [ i ] = ali [ i ] NEW_LINE DEDENT for j in range ( m ) : NEW_LINE INDENT if ( ali [ i ] [ j - 1 ] == ' R ' ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( ali [ i ] [ j - 1 ] == ' D ' ) ' : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , m = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( input ( ) . strip ( ) ) NEW_LINE DEDENT x = 0 NEW_LINE for i in a [ - 1 ] : NEW_LINE INDENT x += int ( i == ' D ' ) NEW_LINE DEDENT for i in a : NEW_LINE INDENT x += int ( i [ - 1 ] == ' R ' ) NEW_LINE DEDENT print ( x ) NEW_LINE DEDENT"],"bleu":0.39350674189766743,"rouge_l":0.5728389116301468}
{"id":383,"predictions":["n , k = map ( int , input ( ) . split ( ) ) NEW_LINE letters = \" abcdefghijklmnopqrstuvwxyz \" NEW_LINE characters = \" abcdefghijklmnopqrstuvwxyz \" NEW_LINE for _ in range ( n ) : NEW_LINE INDENT if ( int ( input ( ) ) in range ( n ) ) : NEW_LINE INDENT a , b = input ( ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT"],"references":["import sysfrom string import ascii_lowercase as az   def main ( ) : n , k = map ( int , sys . stdin . read ( ) . strip ( ) . split ( ) ) return n \/\/ k * az [ : k ] + az [ : n % k ]   print ( main ( ) ) NEW_LINE"],"bleu":0.24387375005421036,"rouge_l":0.32989183874139627}
{"id":384,"predictions":["n , m = map ( int , input ( ) . split ( ) ) arr = [ 0 ] * nfor i in range ( n ) : arr [ i ] = list ( map ( int , input ( ) . split ( ) ) ) arr [ n ] = arr [ n ] for i in range ( m ) : arr [ arr [ i ] ] = arr [ i ] [ 0 ] = arr [ n ] [ 1 ] = arr [ n ] [ 0 ] for i in range ( n ) : arr [ i ] [ 1 ] = arr [ i ] [ 0 ] + arr [ arr [ i ] ] if ( arr [ i ] [ 0 ] != arr [ i ] [ 1 ] ) : arr [ arr [ i ] [ 0 ] = arr [ i ] [ 1 ] + 1 arr [ i ] [ 0 ] = ( arr [ i ] [ 1 ] + arr [ i ] [ 1 ] ) arr [ i ] [ 1 ] = arr [ i ] [ 0 ] for i in range ( n ) : arr [ i ] [ 1 ] = arr [ i ] [ 0 ] if ( arr [ i ] [ 1 ] == arr [ i ] [ 1 ] ) : arr [ i ] [ i ] = arr [ i ] [ 0 ] = arr [ i ] [ 0 ] = 1 if ( arr [ i ] [ 0 ] > arr [ i ] [ 1 ] ) : arr [ i ] [ 1 ] = arr [ i ] [ 1 ] = arr [ i ] [ 0 ] = arr [ i ] [ 1 ] for i in range ( n ) : arr [ i ] [ 0 ] = arr [ i ] [ 1 ] = arr [ i ] [ 0 ] if ( arr [ i ] [ 0 ] == arr [ i ] ) : arr [ i ] = arr [ i ] [ 1 ] = arr [ i ] [ 1 ] if ( arr [ i ] == arr [ i ] [ 0 ] ) : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"references":["from itertools import repeatfrom math import floor , ceildef fill ( s , a1 , a2 , a3 , a4 , c4 , c7 ) : if a1 < c4 or a2 < c7 : return None f = s . index ( '4' ) sv = s . rindex ( '7' ) s = ' ' . join ( [ s [ : f ] , '4' * ( a1 - c4 ) , s [ f : sv ] , '7' * ( a2 - c7 ) , s [ sv : ] ] ) return sa1 , a2 , a3 , a4 = [ int ( x ) for x in input ( ) . split ( ) ] if abs ( a3 - a4 ) > 1 : print ( - 1 ) else : s = ' ' if a3 > a1 or a3 > a2 or a4 > a1 or a4 > a2 : print ( - 1 ) exit ( 0 ) c4 = 0 c7 = 0 if a3 > a4 : s = ' ' . join ( repeat ( '47' , a3 ) ) c4 = int ( len ( s ) \/ 2 ) c7 = len ( s ) - c4 s = fill ( s , a1 , a2 , a3 , a4 , c4 , c7 ) if s : print ( s ) else : print ( - 1 ) elif a3 < a4 : s = ' ' . join ( repeat ( '74' , a4 ) ) c7 = int ( len ( s ) \/ 2 ) c4 = len ( s ) - c7 s = fill ( s , a1 , a2 , a3 , a4 , c4 , c7 ) if s : print ( s ) else : print ( - 1 ) elif a3 == a4 : s = ' ' . join ( repeat ( '47' , a3 ) ) + '4' c4 = ceil ( len ( s ) \/ 2 ) c7 = len ( s ) - c4 s = fill ( s , a1 , a2 , a3 , a4 , c4 , c7 ) if s : print ( s ) else : s = ' ' . join ( repeat ( '74' , a3 ) ) + '7' c7 = ceil ( len ( s ) \/ 2 ) c4 = len ( s ) - c7 s = fill ( s , a1 , a2 , a3 , a4 , c4 , c7 ) if s : print ( s ) else : print ( - 1 ) NEW_LINE"],"bleu":0.045839395655520206,"rouge_l":0.19383177570093457}
{"id":385,"predictions":["n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( ' ▁ ' , end = ' ' ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( ' ▁ ' , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT"],"references":["n = int ( input ( ) ) l = [ [ ] for i in range ( n ) ] for i in range ( n ) : for a in range ( i ) : l [ i ] += [ a ]   for i in range ( n ) :   print ( ( ( n - 1 - i ) * 2 + 1 ) * \" ▁ \" , * l [ i ] , 1 * i , * list ( reversed ( l [ i ] ) ) )   for i in range ( n ) : print ( i , end = \" ▁ \" ) print ( n , end = \" ▁ \" ) for i in range ( n - 1 , 0 , - 1 ) : print ( i , end = \" ▁ \" ) print ( 0 )       for i in range ( n - 1 , - 1 , - 1 ) :     print ( ( ( n - 1 - i ) * 2 + 1 ) * \" ▁ \" , * l [ i ] , 1 * i , * list ( reversed ( l [ i ] ) ) )     NEW_LINE"],"bleu":0.03691141561628514,"rouge_l":0.27022465984600774}
{"id":386,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) for i in b : if b [ i ] == b [ i ] : b [ i ] = b [ i ] else : b [ i ] = b [ i ] for i in b [ i ] : if b [ i ] == b [ i ] : b [ i ] = b [ i ] else : b [ i ] = b [ i ] print ( b [ i ] ) NEW_LINE"],"references":["import sysdef input ( ) : return sys . stdin . readline ( ) . strip ( ) def iinput ( ) : return int ( input ( ) ) def minput ( ) : return map ( int , input ( ) . split ( ) ) def listinput ( ) : return list ( map ( int , input ( ) . split ( ) ) ) a , b , pos = minput ( ) for i in range ( b ) : a *= 10 c = a \/\/ b a = a % b if c == pos : print ( i + 1 ) exit ( ) print ( \" - 1\" ) NEW_LINE"],"bleu":0.2653247376891149,"rouge_l":0.448583484026522}
{"id":387,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) a . sort ( ) b = 0 ans = 0 for i in range ( n ) : if a [ i ] != b [ i ] : ans += a [ i ] else : ans += a [ i ] print ( ans ) NEW_LINE"],"references":["n , k = map ( int , input ( ) . split ( ) ) a = input ( ) b = input ( ) res = 0 ans = 0 for i in range ( 0 , n ) : res = min ( res * 2 + ( b [ i ] == ' b ' ) - ( a [ i ] == ' b ' ) , k ) ans += min ( res + 1 , k ) print ( ans ) NEW_LINE"],"bleu":0.42044899761412313,"rouge_l":0.5344040883372877}
{"id":388,"predictions":["def gcd ( k , a , b ) : NEW_LINE INDENT if ( ( a == 0 and b == 0 and a % k == 0 ) or ( a % k == 0 and b % k == 0 ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( ( b > 0 and a % k == 0 and ( ( b % k == 0 and a % k == 0 and b % k == 0 ) ) and ( ( b % k == 0 and b % k == 0 and b % k == 0 ) ) : NEW_LINE INDENT if ( ( a % k == 0 and b % k == 0 == 0 and b % k == 1 ) and ( ( b % k == 0 and b % k == 0 ) and ( b % k != 1 ) ) ) : NEW_LINE INDENT return ( ( b - a % k ) + 1 NEW_LINE DEDENT DEDENT elif ( b == 0 and b % k == 0 ) : NEW_LINE INDENT return ( - a \/\/ k ) + 1 NEW_LINE DEDENT else : NEW_LINE INDENT DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT k , a , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( int ( solve ( k , a , b ) ) ) NEW_LINE DEDENT"],"references":["k , a , b = map ( int , input ( ) . split ( ) ) if ( a >= 0 and b >= 0 ) or ( a < 0 and b < 0 ) : if a < 0 and b < 0 : temp = - b b = - a a = temp c = b \/\/ k - a \/\/ k if a % k == 0 : c += 1 elif a < 0 and b >= 0 : a = - a c = a \/\/ k + b \/\/ k + 1 print ( c ) NEW_LINE"],"bleu":0.15164168070216413,"rouge_l":0.3434284604931081}
{"id":389,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) : if b [ a [ i ] ] == b [ a [ i ] ] : b [ a [ i ] ] = b [ a [ i ] ] elif b [ a [ i ] ] == b [ i ] ] : b [ a [ i ] ] = b [ i ] else : b [ a [ i ] ] = b [ a [ i ] , b [ i ] ] = b [ i ] , b [ i ] = b [ i ] print ( \" YES \" ) for i in b : print ( \" NO \" ) NEW_LINE"],"references":["n = int ( input ( ) ) s = input ( )   arr = set ( list ( s ) ) if len ( arr ) < n : print ( \" NO \" )   else : ans = [ ] d = { }   for i in s : if i in d : ans [ - 1 ] += i else : d [ i ] = 1 ans . append ( i ) print ( \" YES \" ) for i in ans [ : n - 1 ] : print ( i )   print ( ' ' . join ( ans [ n - 1 : ] ) )   NEW_LINE"],"bleu":0.14476743818724463,"rouge_l":0.3439469320066335}
{"id":390,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) t = 0 for i in range ( n ) : if a [ i ] % 2 == 0 : t += a [ i ] \/\/ 2 else : t += a [ i ] \/\/ 3 print ( ' NO ' ) NEW_LINE"],"references":["def mingrid ( ) : for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) segcost = input ( ) . split ( ) minodd = int ( segcost [ 0 ] ) mineven = int ( segcost [ 1 ] ) sumodd = minodd sumeven = mineven codd = 1 ceven = 1 res = sumodd + minodd * ( n - codd ) + sumeven + mineven * ( n - ceven ) for i in range ( 2 , n ) : now = int ( segcost [ i ] ) if ( i + 1 ) % 2 : NEW_LINE"],"bleu":0.18343531260150864,"rouge_l":0.35063398140321217}
{"id":391,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = list ( map ( int , input ( ) . split ( ) ) ) a . sort ( ) if a [ - 1 ] == b [ - 1 ] : print ( - 1 ) else : print ( - 1 ) NEW_LINE"],"references":["import sys     def get_list ( ) : return list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) )   n = int ( input ( ) )   a = get_list ( ) b = get_list ( )   print ( \" Karen \" ) NEW_LINE"],"bleu":0.22140753517869383,"rouge_l":0.45953508394317694}
{"id":392,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) for i in b : if b [ i ] == b [ i ] : b [ i ] = b [ i ] else : b [ i ] = b [ i ] if b [ i ] == b [ i ] : b [ i ] = b [ i ] else : b [ i ] = b [ i ] if b [ i ] == b [ i ] : b [ i ] = b [ i ] else : b [ i ] = b [ i ] else : b [ i ] = b [ i ] if b [ i ] == b [ i ] else : b [ i ] = b [ i ] else : b [ i ] = b [ i ] if b [ i ] not in b [ i ] : print ( \" NO \" ) else : print ( \" YES \" ) NEW_LINE"],"references":["import sys       n , m , c = map ( int , input ( ) . split ( ) )   free = n   nums = [ 0 ] * n       for i in range ( m ) :   pi = int ( input ( ) )   if ( pi > c \/\/ 2 ) :   current = n - 1   while ( nums [ current ] > 0 and nums [ current ] >= pi and current >= 0 ) : current -= 1   if ( current == - 1 ) : current = 0   if ( nums [ current ] == 0 ) : free -= 1   nums [ current ] = pi   print ( current + 1 )   else :   current = 0   while ( current < n and nums [ current ] > 0 and nums [ current ] <= pi ) : current += 1   if ( current == n ) : current = n - 1   if ( nums [ current ] == 0 ) : free -= 1   nums [ current ] = pi   print ( current + 1 )       if ( free == 0 ) : break               NEW_LINE"],"bleu":0.11842728537915478,"rouge_l":0.2813810455689125}
{"id":393,"predictions":["h , h = map ( int , input ( ) . split ( ) ) h = [ ] for i in range ( h ) : if h [ h ] == '1' and h [ h ] == '1' and h [ h ] == '1' : h . append ( h ) h [ h ] = h [ h ] + h [ h ] if h [ h ] == '1' and h [ h ] == '1' : h [ h ] = h1 [ h ] + h2 [ h ] else : h [ h ] = h1 [ h ] if h2 [ h ] == 0 and h2 [ h ] == '1' : h2 [ h ] = h2 [ h ] + 1 h2 [ h + h ] else : h2 [ h ] = h2 [ h ] + h2 [ h ] = h1 [ h ] + 1 if h2 [ h ] == 0 : h2 [ h ] = h2 [ h ] else : h2 [ h ] = h2 [ h ] + 1 h2 [ h ] = h2print ( h1 ) NEW_LINE"],"references":["from sys import stdin , stdoutimport math , bisectfrom collections import Counter , deque , defaultdictL = lambda : list ( map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) ) M = lambda : map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) I = lambda : int ( stdin . readline ( ) . strip ( ) ) S = lambda : stdin . readline ( ) . strip ( ) C = lambda : stdin . readline ( ) . strip ( ) . split ( ) def pr ( a ) : return ( \" \" . join ( list ( map ( str , a ) ) ) ) NEW_LINE"],"bleu":0.056977880986409546,"rouge_l":0.178452537072531}
{"id":394,"predictions":["s = input ( ) l = [ ' a ' , ' e ' , ' e ' , ' e ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' v ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' v ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' u ' , ' u ' , ' u ' , ' u ' a ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' u ' , ' u ' , ' u ' , ' a ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' u ' , ' ' , ' ' ' , ' ' '"],"references":["print ( ' YES ' if len ( [ i for i in input ( ) if i in ' aeiou ' ] ) == 5 and len ( [ i for i in input ( ) if i in ' aeiou ' ] ) == 7 and len ( [ i for i in input ( ) if i in ' aeiou ' ] ) == 5 else ' NO ' ) NEW_LINE"],"bleu":0.006166322330093267,"rouge_l":0.04424953838037456}
{"id":395,"predictions":["n = int ( input ( ) ) l1 = list ( map ( int , input ( ) . split ( ) ) ) l2 = list ( map ( int , input ( ) . split ( ) ) ) l2 = list ( map ( int , input ( ) . split ( ) ) ) l2 = list ( map ( int , input ( ) . split ( ) ) ) ) l2 = [ ] for i in l : if l [ i ] == l1 [ i ] == l2 [ i ] : l1 . append ( l [ i ] ) else : l2 . append ( l [ i ] ) l2 . append ( l [ i ] ) if l2 [ i ] == l2 [ i ] : print ( \" NO \" ) else : print ( \" YES \" ) NEW_LINE"],"references":["import syspassword = input ( ) ; n = int ( input ( ) ) ; first = second = 0 ; words = [ ] for i in range ( 0 , n ) : words . append ( input ( ) ) for word in words : if password [ 0 ] == word [ 1 ] : first = 1 if password [ 1 ] == word [ 0 ] : second = 1 if password == word : first = second = 1 if first == second == 1 : print ( \" YES \" ) sys . exit ( 0 ) print ( \" NO \" ) NEW_LINE"],"bleu":0.20088529806722383,"rouge_l":0.37395220818215935}
{"id":396,"predictions":["n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == '1' : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"references":["for _ in range ( int ( input ( ) ) ) : n , m = map ( int , input ( ) . split ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if m == sum ( arr ) : print ( ' YES ' )   else : print ( ' NO ' ) NEW_LINE"],"bleu":0.5118875440895722,"rouge_l":0.6257156488549619}
{"id":397,"predictions":["W , m , m , k = [ int ( x ) for x in input ( ) . split ( ) ] n , m = [ int ( x ) for x in input ( ) . split ( ) ] a = [ int ( x ) for x in input ( ) . split ( ) ] a = [ int ( x ) for x in input ( ) . split ( ) ] a = [ int ( x ) for y in input ( ) . split ( ) ] a . sort ( ) a . sort ( ) c = 1 for i in range ( 1 , len ( a ) ) : if a [ i ] [ 0 ] == a [ i ] [ 1 ] : c = a [ i ] [ 1 ] c = 1 for i in range ( 1 , len ( a ) ) : if a [ i ] == a [ i ] : c = a [ i ] [ 1 ] else : c = a [ i ] [ 1 ] c = c [ i ] print ( c [ - 1 ] ) NEW_LINE"],"references":["w , m , k = map ( int , input ( ) . split ( ) ) z = mdig = 0 while z > 0 : dig += 1 ; z = z \/\/ 10 if ( dig * k > w ) : print ( 0 ) exit ( 0 ) lo = m - 1 hi = w + m + 5 while lo + 1 < hi : mid = ( lo + hi ) \/\/ 2 cost , t , d = 0 , 0 , 0 x = mid while x > 0 : x = x \/\/ 10 d += 1 if ( d == dig ) : cost = ( mid - m + 1 ) * d * k else : t = pow ( 10 , dig ) last = m c = dig while t <= mid : cost += ( t - last ) * c * k c += 1 last = t t = t * 10 t = t \/\/ 10 cost += ( mid - t + 1 ) * c * k if ( cost <= w ) : lo = mid else : hi = midprint ( lo - m + 1 ) NEW_LINE"],"bleu":0.08354879647121574,"rouge_l":0.2634176434299815}
{"id":398,"predictions":["for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) ) s = 0 for i in range ( n ) : s += a [ i ] s += a [ i ] * 2 print ( s ) NEW_LINE"],"references":["from collections import Counterfrom itertools import combinations   if __name__ == ' _ _ main _ _ ' : n = int ( input ( ) ) a = [ int ( i ) for i in input ( ) . split ( ) ] s = sum ( a ) t = s s \/= 2   while n > 0 and t > s : t -= a [ n - 1 ] n -= 1 print ( n + 1 if t < s else n ) NEW_LINE"],"bleu":0.24897280605457148,"rouge_l":0.41471705658868224}
{"id":399,"predictions":["n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE ans = 0 NEW_LINE for _ in range ( n ) : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT ans += s [ 0 : - 2 ] NEW_LINE DEDENT else : NEW_LINE INDENT ans += s [ 0 ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["from sys import stdin , stdoutfrom math import floor , gcd , fabs , factorial , fmod , sqrt , inf , logfrom collections import defaultdict as dd , dequefrom heapq import merge , heapify , heappop , heappush , nsmallestfrom bisect import bisect_left as bl , bisect_right as br , bisect mod = pow ( 10 , 9 ) + 7 mod2 = 998244353 def inp ( ) : return stdin . readline ( ) . strip ( ) def iinp ( ) : return int ( inp ( ) ) def out ( var , end = \" \\n \" ) : stdout . write ( str ( var ) + \" \\n \" ) def outa ( * var , end = \" \\n \" ) : stdout . write ( ' ▁ ' . join ( map ( str , var ) ) + end ) def lmp ( ) : return list ( mp ( ) ) def mp ( ) : return map ( int , inp ( ) . split ( ) ) def smp ( ) : return map ( str , inp ( ) . split ( ) ) def l1d ( n , val = 0 ) : return [ val for i in range ( n ) ] def l2d ( n , m , val = 0 ) : return [ l1d ( m , val ) for j in range ( n ) ] def remadd ( x , y ) : return 1 if x % y else 0 def ceil ( a , b ) : return ( a + b - 1 ) \/\/ b def isprime ( x ) : if x <= 1 : return False if x in ( 2 , 3 ) : return True if x % 2 == 0 : return False for i in range ( 3 , int ( sqrt ( x ) ) + 1 , 2 ) : if x % i == 0 : return False return True n = iinp ( ) s = inp ( ) for i in range ( n ) : print ( s [ i ] , end = ' ' ) if n - i >= 3 and i % 2 : print ( ' - ' , end = ' ' ) print ( ) NEW_LINE"],"bleu":0.0015968201258647532,"rouge_l":0.12873192228911923}
{"id":400,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in range ( 0 , n ) : if b [ i ] >= a [ i ] and b [ i ] >= a [ i ] : c += 1 elif b [ i ] >= a [ i ] : c += 1 b [ i ] += 1 print ( c ) NEW_LINE"],"references":["def p2 ( a ) : n = len ( a ) last = [ [ - 1 ] * 26 for _ in range ( n ) ] last [ 0 ] [ ord ( a [ 0 ] ) - 97 ] = 0 for i in range ( 1 , n ) : for j in range ( 26 ) : last [ i ] [ j ] = last [ i - 1 ] [ j ] last [ i ] [ ord ( a [ i ] ) - 97 ] = i dp = [ ' ' ] * n for i in range ( n - 1 , - 1 , - 1 ) : for j in range ( n - 1 , i , - 1 ) : k = last [ j ] [ ord ( a [ i ] ) - 97 ] if k > i : if ( k - i ) == 1 and len ( dp [ j ] ) < 2 : dp [ j ] = a [ i ] + a [ i ] elif len ( dp [ j ] ) < ( len ( dp [ k - 1 ] ) + 2 ) : dp [ j ] = a [ i ] + dp [ k - 1 ] + a [ i ] if len ( dp [ j ] ) >= 100 : if len ( dp [ j ] ) == 101 : return dp [ j ] [ : 50 ] + dp [ j ] [ 51 : ] else : return dp [ j ] dp [ i ] = a [ i ] return dp [ n - 1 ]     a = input ( ) print ( p2 ( a ) ) NEW_LINE"],"bleu":0.046118920271895035,"rouge_l":0.251168958057087}
{"id":401,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in b : if a [ i ] == b [ i ] : c += 1 else : print ( max ( a ) ) NEW_LINE"],"references":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) p = [ 0 ] * nfor i in range ( n ) : p [ a [ i ] - 1 ] = i + 1 s = 0 for i in range ( n - 1 ) : s += abs ( p [ i ] - p [ i + 1 ] ) print ( s ) NEW_LINE"],"bleu":0.3877772102230759,"rouge_l":0.5110780115434741}
{"id":402,"predictions":["n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l . sort ( ) count = 0 for i in range ( n ) : if l [ i ] >= l [ i ] : count += 1 else : count += 1 print ( count ) NEW_LINE"],"references":["def count ( a ) : n = len ( a ) cnt = 0 for i in range ( n ) : for j in range ( i + 1 , n ) : if a [ i ] > a [ j ] : cnt += 1 return cnt                       n = int ( input ( ) ) p = list ( map ( int , input ( ) . split ( ) ) ) num = count ( p )   print ( num * 2 - num % 2 ) NEW_LINE"],"bleu":0.36894619420928965,"rouge_l":0.32801387684301825}
{"id":403,"predictions":["n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) print ( max ( b ) ) NEW_LINE"],"references":["def STR ( ) : return list ( input ( ) ) def INT ( ) : return int ( input ( ) ) def MAP ( ) : return map ( int , input ( ) . split ( ) ) def MAP2 ( ) : return map ( float , input ( ) . split ( ) ) def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) def STRING ( ) : return input ( ) import stringimport sysfrom heapq import heappop , heappushfrom bisect import * from collections import deque , Counter , defaultdictfrom math import * from itertools import permutations , accumulatedx = [ - 1 , 1 , 0 , 0 ] dy = [ 0 , 0 , 1 , - 1 ] NEW_LINE"],"bleu":0.14719885686995002,"rouge_l":0.4090216397439805}
{"id":404,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["sum , xor = map ( int , input ( ) . split ( ) )   andr = ( sum - xor ) \/ 2   if sum < xor or ( sum - xor ) % 2 == 1 or int ( andr ) & xor : print ( 0 ) else : perm = 2 ** bin ( xor ) . count ( \"1\" ) if sum == xor : perm = perm - 2 print ( perm ) NEW_LINE"],"bleu":0.1170687437044743,"rouge_l":0.3077107854912323}
{"id":405,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in range ( len ( b ) ) : if b [ i ] == b [ i ] : print ( \" NO \" ) else : print ( \" YES \" ) NEW_LINE"],"references":["import sys   n = int ( sys . stdin . readline ( ) ) digits = [ int ( x ) for x in sys . stdin . readline ( ) . strip ( ) ]   NEW_LINE"],"bleu":0.0692157910411486,"rouge_l":0.3145140500128899}
{"id":406,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = list ( map ( int , input ( ) . split ( ) ) ) print ( sum ( b ) ) NEW_LINE"],"references":["r = lambda : list ( map ( int , input ( ) . split ( ) ) ) arr = r ( ) size = \" S , ▁ M , ▁ L , ▁ XL , ▁ XXL \" . split ( \" , ▁ \" ) NEW_LINE"],"bleu":0.24511506706704328,"rouge_l":0.4315646258503401}
{"id":407,"predictions":["n , m = map ( int , input ( ) . split ( ) ) l = [ ] for _ in range ( n ) : a , b = map ( int , input ( ) . split ( ) ) l . append ( set ( map ( int , input ( ) . split ( ) ) ) ) if len ( set ( set ( a ) ) ) == 0 : print ( \" NO \" ) else : print ( \" YES \" ) NEW_LINE"],"references":["for _ in range ( int ( input ( ) ) ) : a , b = map ( int , input ( ) . split ( ) ) x = set ( map ( int , input ( ) . split ( ) ) ) y = set ( map ( int , input ( ) . split ( ) ) ) z = x . intersection ( y ) if len ( z ) : print ( \" YES \" ) print ( 1 , list ( z ) [ 0 ] ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.6221128153956424,"rouge_l":0.6231669138243532}
{"id":408,"predictions":["n = int ( input ( ) ) a = [ ] for i in range ( n ) : a , b = [ ] , [ a ] for j in range ( n ) : if a [ j ] != b [ j ] : a . append ( j ) for j in a : if a [ j ] == b : a . append ( j ) a . sort ( ) b . sort ( ) for i in range ( n - 1 , len ( a ) ) : if a [ i ] [ j ] > b [ i ] : a [ j ] += 1 else : a [ j ] = 1 if a [ i ] [ j ] > b [ i ] : b [ i ] ] = 1 b [ i ] = 1 print ( \" \" . join ( a ) ) NEW_LINE"],"references":["def solution ( ) : st1 = input ( ) st2 = input ( )   dicty1 = { } dicty2 = { } LET = ' ABCDEFGHIJKLMNOPQRSTUVWXYZ ' LET += LET . lower ( )   for c in LET : dicty1 [ c ] = 0 dicty2 [ c ] = 0   for c in st1 : if c != ' ▁ ' : dicty1 [ c ] += 1   for c in st2 : if c != ' ▁ ' : dicty2 [ c ] += 1     for c in dicty2 : if dicty2 [ c ] > dicty1 [ c ] : print ( ' NO ' ) return print ( ' YES ' ) \t         return         solution ( ) NEW_LINE"],"bleu":0.049489117754269236,"rouge_l":0.2963453682234735}
{"id":409,"predictions":["n , m = map ( int , input ( ) . split ( ) ) arr = [ ] for _ in range ( n ) : a , b = map ( int , input ( ) . split ( ) ) arr . append ( b ) arr . append ( a )   for i in range ( n - 1 , - 1 ) : arr . append ( arr [ i ] )   for j in range ( m ) : if arr [ j ] [ j ] == 0 : arr [ j ] [ j ] = 1 arr [ j ] [ j ] = 1 if arr [ j ] [ j ] == arr [ j ] [ j ] == arr [ j ] [ j ] : arr [ j ] [ j ] = 1 arr [ j ] [ j ] = 1 arr [ j ] [ j ] = 1 for i in range ( n ) : if arr [ i ] [ j ] == arr [ i ] [ j ] == arr [ i ] [ j ] : arr [ j ] [ j ] = 1 arr [ i ] [ j ] = 1 if arr [ i ] [ j ] == 1 : arr [ i ] [ j ] = 1 if arr [ i ] [ j ] == arr [ j ] [ j ] : arr [ i ] [ j ] = 1 if arr [ i ] [ j ] == 1 : arr [ i ] [ j ] = 1 else : arr [ j ] [ j ] = 1 arr [ i ] [ j ] = 1 if arr [ i ] [ j ] == arr [ i ] [ j ] : arr [ i ] [ j ] = 1 for i in range ( n ) : arr [ i ] [ j ] = 1 if arr [ i ] [ j ] == 0 : arr [ j ] [ j ] = 1 else : arr [ j ] [ j ] = 1 break if arr [ i ] [ j ] == arr [ j ] [ j ] = 1   for i in range ( n ) : arr [ i ] [ j ] = 1 if arr [ i ] [ j ] == 1 : arr [ j ] = 1   for i ] in arr [ j ] : print ( arr [ j ] ) NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) d = { } ans = cnt = 0 for i in map ( int , input ( ) . split ( ) ) : d [ i ] = d . get ( i , 0 ) + 1 for i in range ( 1 , m + 1 ) : cnt = 0 for v in d . items ( ) : cnt += v [ 1 ] \/\/ i if cnt >= n : ans = iprint ( ans ) NEW_LINE"],"bleu":0.09103930686946309,"rouge_l":0.2538255033557047}
{"id":410,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) : if a [ i ] % 2 == 0 : print ( ' Yes ' ) else : print ( ' No ' ) NEW_LINE"],"references":["a , b , c = map ( int , input ( ) . split ( ) )   while c >= 0 : if c % b == 0 : print ( ' Yes ' ) break c -= aelse : print ( ' No ' ) NEW_LINE"],"bleu":0.42321649453473836,"rouge_l":0.6253661394258935}
{"id":411,"predictions":["t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if a [ 0 ] > a [ 0 ] : NEW_LINE INDENT print ( 1 , end = \" ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT"],"references":["for s in [ * open ( 0 ) ] [ 2 : : 2 ] : NEW_LINE INDENT b = [ 0 ] ; NEW_LINE r = 0 NEW_LINE for x in s . split ( ) : b += - 1 , ; b [ max ( - len ( b ) , ~ int ( x ) ) ] += 1 NEW_LINE for x in b [ : - 1 ] : r += x ; print ( + ( r > 0 ) ) NEW_LINE DEDENT"],"bleu":0.12334064571327721,"rouge_l":0.3122683142100618}
{"id":412,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) : a , b = list ( map ( int , input ( ) . split ( ) ) ) ) b . sort ( ) ans = 0 for i in range ( n ) : for j in range ( n ) : if a [ i ] [ j ] == b [ i ] [ j ] : ans += 1 if a [ i ] [ j ] == b [ i ] [ j ] : ans += 1 b [ i ] [ j ] else : ans += 1 b [ i ] [ j ] = 1 for i in range ( n ) : ans += b [ i ] [ j ] print ( ans ) NEW_LINE"],"references":["import sys   def main ( ) :   for _ in range ( int ( sys . stdin . readline ( ) . strip ( ) ) ) : n = int ( sys . stdin . readline ( ) . strip ( ) ) arr = list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) i = 0 while i < n and arr [ i ] >= i : i += 1 j = n - 1 while j >= 0 and arr [ j ] >= ( n - j - 1 ) : j -= 1 if ( i - j ) == 1 and arr [ i ] == arr [ j ] : print ( ' No ' ) elif i > j : print ( \" Yes \" ) else : print ( \" No \" )   main ( ) NEW_LINE"],"bleu":0.18989760904297817,"rouge_l":0.39538068285557787}
{"id":413,"predictions":["n , m = map ( int , input ( ) . split ( ) ) s = input ( ) f = 0 for i in range ( n ) : if s [ i ] == ' : f = 1 elif s [ i ] == ' : if s [ i ] == ' : f = 1 elif s [ i ] == ' : f = 1 elif s [ i ] == ' : if s [ i ] == ' : f = ' . ' elif s [ i ] == ' : s [ i ] == ' : s += ' : ' elif s [ i ] == ' : s [ i ] = ' : s [ i ] = ' . ' elif s [ i ] == ' : s [ i ] = ' : s [ i ] elif s [ i ] == ' : s [ i ] ] == ' : s [ i ] = ' . ' elif s [ i ] == ' : s [ i ] == ' : s [ i ] = ' : s [ i ] = ' : s [ i ] = ' . ' . join ( s [ i ] ) elif s [ i ] == ' : s [ i ] = ' . ' elif s [ i ] == ' : s [ i ] = ' . ' elif s [ i ] == ' : s [ i ] = ' . ' elif s [ i ] == ' : s [ i ] = ' . ' elif s [ i ] == ' : s [ i ] = ' : if s [ i ] == ' : s [ i ] = ' : s [ i ] = ' . ' else : s [ i ] = ' . ' . join ( s [ i ] ) elif s [ i ] == ' : s [ i ] = ' . replace ( ' : ' . join ( s [ i : i ] ) ) print ( s [ i ] ) else : print ( s [ i ] ) NEW_LINE"],"references":["import syss1 , s2 = input ( ) . split ( \" : \" ) def convert ( n , base ) : ans = 0 for i in range ( len ( n ) ) : x = 0 if n [ i ] . isalpha ( ) : x = int ( ord ( n [ i ] ) - ord ( ' A ' ) + 10 ) else : x = int ( n [ i ] ) ans += x * pow ( base , len ( n ) - i - 1 ) return answork = [ ] minm = 0 for c in s1 + s2 : if c . isalpha ( ) : minm = max ( minm , ord ( c ) - ord ( ' A ' ) + 10 ) else : minm = max ( minm , int ( c ) )   for base in range ( max ( minm + 1 , 2 ) , 60 ) : if convert ( s1 , base ) < 24 and convert ( s2 , base ) < 60 : work . append ( base ) else : breakif len ( work ) == 0 : print ( 0 ) elif ( len ( s1 ) == 1 or s1 [ : len ( s1 ) - 1 ] == '0' * ( len ( s1 ) - 1 ) ) and ( len ( s2 ) == 1 or s2 [ : len ( s2 ) - 1 ] == '0' * ( len ( s2 ) - 1 ) ) : print ( - 1 ) else : print ( \" ▁ \" . join ( map ( str , work ) ) ) NEW_LINE"],"bleu":0.08686684781952911,"rouge_l":0.2522746071133168}
{"id":414,"predictions":["n , k = map ( int , input ( ) . split ( ) ) print ( n - k + n \/\/ 2 ) NEW_LINE"],"references":["def solution ( ) : n , k = map ( int , input ( ) . split ( ) )   arr = list ( map ( int , input ( ) . split ( ) ) )   k -= 1 num = arr [ k ] for i in range ( k , n ) : if arr [ i ] != num : print ( - 1 ) return   curr = k - 1 while curr >= 0 and arr [ curr ] == num : curr -= 1   \t   print ( curr + 1 )     return         solution ( ) NEW_LINE"],"bleu":0.04117424110002014,"rouge_l":0.29357606193764385}
{"id":415,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) flag = 0 flag = 0 for i in range ( n ) : if a [ i ] + ' D ' : flag = 0 flag = 0 for j in range ( m ) : if flag [ j ] == ' D ' : flag = 1 break if flag : print ( ' D ' ) exit ( ) if flag : print ( ' L ' ) exit ( ) NEW_LINE"],"references":["a = input ( ) b = input ( ) c = 8   print ( max ( max ( ord ( a [ 0 ] ) , ord ( b [ 0 ] ) ) - min ( ord ( a [ 0 ] ) , ord ( b [ 0 ] ) ) , max ( int ( a [ 1 ] ) , int ( b [ 1 ] ) ) - min ( int ( a [ 1 ] ) , int ( b [ 1 ] ) ) ) ) d = ord ( a [ 0 ] ) - ord ( b [ 0 ] ) e = int ( a [ 1 ] ) - int ( b [ 1 ] ) while c > 0 : c -= 1 if d < 0 : if d != 0 : d += 1 print ( \" R \" , end = \" \" ) if d > 0 : print ( \" L \" , end = \" \" ) d -= 1 if e < 0 : print ( \" U \" , end = \" \" ) e += 1 if e > 0 : e -= 1 print ( \" D \" , end = \" \" ) print ( )       NEW_LINE"],"bleu":0.03276548619640785,"rouge_l":0.2698617511520737}
{"id":416,"predictions":["n , k = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l . sort ( ) print ( l [ - l ] ) NEW_LINE"],"references":["def f ( t ) : z = 1.000000011 p = 1 while t : if t % 2 : t -= 1 p *= z else : t \/\/= 2 z *= z return pn , t = map ( int , input ( ) . split ( ) ) print ( n * f ( t ) ) NEW_LINE"],"bleu":0.250749206826673,"rouge_l":0.3438148917235242}
{"id":417,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = list ( map ( int , input ( ) . split ( ) ) ) print ( sum ( b ) ) NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) ; a = list ( map ( int , input ( ) . split ( ) ) )   b = [ ( list ( map ( int , input ( ) . split ( ) ) ) ) for i in range ( m ) ]   count = 0 for i in range ( m ) : sum = 0 ; for j in range ( b [ i ] [ 0 ] - 1 , b [ i ] [ 1 ] ) : sum += a [ j ]   if ( sum > 0 ) : count += sum     print ( count ) NEW_LINE"],"bleu":0.369843326290146,"rouge_l":0.5771676748875445}
{"id":418,"predictions":["def STR ( ) : return list ( input ( ) ) def INT ( ) : return int ( input ( ) ) def MAP ( ) : return map ( int , input ( ) . split ( ) ) def MAP2 ( ) : return map ( float , input ( ) . split ( ) ) def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) def STRING ( ) : return input ( ) import stringimport sysfrom heapq import heappop , heappushfrom bisect import * from collections import deque , Counter , defaultdictfrom math import * from itertools import permutations , accumulatedx = [ - 1 , 1 , 0 ] NEW_LINE"],"references":["n = int ( input ( ) ) m = list ( map ( int , input ( ) . split ( ) ) ) gc = m [ 0 ] import mathfor i in range ( 1 , n ) : gc = math . gcd ( gc , m [ i ] ) k = max ( m ) prime = [ 0 ] * ( k + 1 ) pfac = [ 0 ] * ( k + 1 ) for i in range ( 2 , k + 1 ) : if prime [ i ] == 0 : for j in range ( i * i , k + 1 , i ) : prime [ j ] = ifor i in range ( 1 , k + 1 ) : if not prime [ i ] : prime [ i ] = ifor i in range ( n ) : v = m [ i ] \/\/ gc while v > 1 : fac = prime [ v ] pfac [ fac ] += 1 while v % fac == 0 : v \/\/= facma = 0 ma = max ( pfac ) if ma : print ( n - ma ) else : print ( - 1 ) NEW_LINE"],"bleu":0.11037534650575132,"rouge_l":0.25564868804664725}
{"id":419,"predictions":["n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) if b < n : b . append ( a ) b . sort ( ) if b == 0 : print ( 0 ) else : print ( 0 ) NEW_LINE"],"references":["import mathn , k = map ( int , input ( ) . split ( ) )   result = [ ]   while ( n % 2 == 0 ) : result . append ( 2 ) n = n \/\/ 2   NEW_LINE"],"bleu":0.22405808980653744,"rouge_l":0.4155313351498638}
{"id":420,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) li = list ( map ( int , input ( ) ) ) od = 0 ev = 0 res = [ ] cnt = 0 for i in range ( n ) : if li [ i ] % 2 == 0 : res . append ( li [ i ] ) else : cnt += 1 res . append ( li [ i ] ) if cnt == 2 : break if res [ - 1 ] % 2 != 0 and cnt >= 2 : print ( * res , sep = ' ' ) else : print ( - 1 )   NEW_LINE"],"bleu":0.05856373955277675,"rouge_l":0.26370395988241396}
{"id":421,"predictions":["n , m = map ( int , input ( ) . split ( ) ) grid = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] grid = [ [ [ 0 ] * n for _ in range ( m ) ] for _ in range ( n ) ] for i in range ( m ) : for j in range ( n ) : grid [ i ] [ j ] = True for _ in range ( n ) : grid [ i ] [ j ] = True for i in range ( n ) : grid [ i ] [ j ] = True for i in range ( m ) : for j in range ( n ) : if grid [ i ] [ j ] == True : grid [ i ] [ j ] = True for i in range ( n ) : for j in range ( m ) : grid [ i ] [ j ] = True for i in range ( n ) : for j in range ( m ) : grid [ i ] [ j ] ] = True for i in range ( n ) : for j in range ( m ) : grid [ i ] [ j ] = True for _ in range ( n ) : for i in range ( m ) : for j in range ( m ) : grid [ i ] [ j ] [ i ] = True for i in range ( n ) : for j in range ( m ) : for j in range ( m ) : grid [ i ] [ j ] = True for i in range ( n ) : for j in range ( m ) : for j in range ( m ) : grid [ i ] [ j ] = True for i in range ( n ) : for j in range ( n ) : for k in range ( m ) : for j in range ( m ) : if grid [ i ] [ j ] == True : continue NEW_LINE"],"references":["import osimport sysfrom io import BytesIO , IOBaseBUFSIZE = 8192 class FastIO ( IOBase ) : newlines = 0 def __init__ ( self , file ) : self . _fd = file . fileno ( ) self . buffer = BytesIO ( ) self . writable = \" x \" in file . mode or \" r \" not in file . mode self . write = self . buffer . write if self . writable else None def read ( self ) : while True : b = os . read ( self . _fd , max ( os . fstat ( self . _fd ) . st_size , BUFSIZE ) ) if not b : break ptr = self . buffer . tell ( ) self . buffer . seek ( 0 , 2 ) , self . buffer . write ( b ) , self . buffer . seek ( ptr ) self . newlines = 0 return self . buffer . read ( ) def readline ( self ) : while self . newlines == 0 : b = os . read ( self . _fd , max ( os . fstat ( self . _fd ) . st_size , BUFSIZE ) ) self . newlines = b . count ( b \" \\n \" ) + ( not b ) ptr = self . buffer . tell ( ) self . buffer . seek ( 0 , 2 ) , self . buffer . write ( b ) , self . buffer . seek ( ptr ) self . newlines -= 1 return self . buffer . readline ( ) def flush ( self ) : if self . writable : os . write ( self . _fd , self . buffer . getvalue ( ) ) self . buffer . truncate ( 0 ) , self . buffer . seek ( 0 ) class IOWrapper ( IOBase ) : def __init__ ( self , file ) : self . buffer = FastIO ( file ) self . flush = self . buffer . flush self . writable = self . buffer . writable self . write = lambda s : self . buffer . write ( s . encode ( \" ascii \" ) ) self . read = lambda : self . buffer . read ( ) . decode ( \" ascii \" ) self . readline = lambda : self . buffer . readline ( ) . decode ( \" ascii \" ) sys . stdin , sys . stdout = IOWrapper ( sys . stdin ) , IOWrapper ( sys . stdout ) input = lambda : sys . stdin . readline ( ) . rstrip ( \" \\n \" ) NEW_LINE"],"bleu":0.02173077150494985,"rouge_l":0.20937416574501355}
{"id":422,"predictions":["n = int ( input ( ) ) lst = list ( map ( int , input ( ) . split ( ) ) ) lst = [ ] for i in range ( n ) : lst . append ( lst [ i ] ) lst . append ( i ) for i in lst : if i % 3 == 0 : lst . append ( i ) breakfor i in lst : print ( i , end = \" ▁ \" ) print ( ) NEW_LINE"],"references":["n = int ( input ( ) ) q = n \/\/ 3 r = n % 3 if ( r == 0 ) : if ( q % 3 != 0 ) : print ( q , q , q ) else : print ( q + 2 , q - 1 , q - 1 ) elif ( r == 1 ) : if ( q % 3 != 0 and ( q + 1 ) % 3 != 0 ) : print ( q , q , q + 1 ) elif ( q % 3 != 0 and ( q + 1 ) % 3 == 0 ) : print ( q - 1 , q , q + 2 ) elif ( q % 3 == 0 and ( q + 1 ) % 3 != 0 ) : print ( q - 1 , q + 1 , q + 1 ) else : if ( q % 3 != 0 and ( q + 2 ) % 3 != 0 ) : print ( q , q , q + 2 ) elif ( q % 3 != 0 and ( q + 2 ) % 3 == 0 ) : print ( q , q + 1 , q + 1 ) elif ( q % 3 == 0 and ( q + 2 ) % 3 != 0 ) : print ( q - 1 , q + 1 , q + 2 ) NEW_LINE"],"bleu":0.027071660617749595,"rouge_l":0.2253496349722931}
{"id":423,"predictions":["n = int ( input ( ) ) a = [ 0 ] + list ( input ( ) ) for i in range ( n ) : a . append ( a [ i : i + 1 ] ) a . append ( a [ i ] ) flag = 0 flag = 0 for i in range ( n ) : if a [ i ] == a [ i + 1 ] : flag = 1 flag = 1 breakif flag : if flag : print ( a [ n - 1 ] ) flag = 1 break if flag : print ( - 1 ) else : print ( n ) NEW_LINE"],"references":["n = int ( input ( ) ) p , s , t = 1 , 0 , \"1\" for x in input ( ) . split ( ) : if x == \"0\" : print ( 0 ) quit ( ) elif x == \"1\" + \"0\" * ( len ( x ) - 1 ) : s += len ( x ) - 1 else : t = str ( x ) print ( t + \"0\" * s ) NEW_LINE"],"bleu":0.14229399260425243,"rouge_l":0.3817013360392356}
{"id":424,"predictions":["n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) print ( * arr ) NEW_LINE"],"references":["for i in [ * open ( 0 ) ] [ 1 : ] : print ( int ( i ) - 1 , 1 ) NEW_LINE"],"bleu":0.09131246806741879,"rouge_l":0.27933600457927876}
{"id":425,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c1 = 0 c1 = 0 for i in range ( n ) : if a [ i ] == b [ i ] : c1 += 1 b [ i ] += 1 for i in range ( n - 1 , - 1 ) : if a [ i ] > b [ i ] : c1 += 1 b [ i ] += 1 if a [ i ] > b : c1 += 1 else : c1 += 1 if c2 == b [ i ] : b [ i ] = 1 b [ i ] = 1 elif a [ i ] > b [ i ] : c1 += 1 b [ i ] else : b [ i ] = 1 for i in range ( n ) : if b [ i ] == b [ i ] : b [ i ] = 1 if b [ i ] : b [ i ] = 1 elif b [ i ] == b [ i ] ] and b [ i ] == b [ i ] : b [ i ] = 1 else : b [ i ] = 1 if b [ i ] : b [ i ] = 1 for i in b [ i ] : b [ i ] = b [ i ] else : b [ i ] = b [ i ] print ( \" NO \" ) NEW_LINE"],"references":["import mathfrom collections import deque     def Work ( ) : n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) IDX = [ 0 ] * n   for i in range ( n ) : IDX [ a [ i ] - 1 ] = i   l , r = n , 0 s = \" \"   for i in range ( n ) : l , r = min ( l , IDX [ i ] ) , max ( r , IDX [ i ] ) s += '1' if r - l == i else '0'   print ( s )     if __name__ == \" _ _ main _ _ \" : t = int ( input ( ) ) for _ in range ( t ) : Work ( ) NEW_LINE"],"bleu":0.16976239781630958,"rouge_l":0.33922449912394304}
{"id":426,"predictions":["n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) : if a [ i ] % k == 0 : print ( - 1 , a [ i ] ) else : print ( - 1 ) NEW_LINE"],"references":["( k , n , m ) = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( k ) : s = input ( ) NEW_LINE a . append ( [ ] ) NEW_LINE for j in range ( n ) : a [ - 1 ] . append ( list ( input ( ) ) ) NEW_LINE s = input ( ) ( x , y ) = map ( int , input ( ) . split ( ) ) NEW_LINE x -= 1 NEW_LINE y -= 1   start = ( 0 , x , y ) NEW_LINE sosed = set ( ) NEW_LINE sosed . add ( start ) NEW_LINE posetil = set ( ) NEW_LINE posetil . add ( start ) NEW_LINE while len ( sosed ) > 0 : sosed2 = set ( ) NEW_LINE for i in sosed : for NEW_LINE dk in [ - 1 , 0 , 1 ] : NEW_LINE for dx in [ - 1 , 0 , 1 ] : for NEW_LINE dy in [ - 1 , 0 , 1 ] : NEW_LINE if abs ( dk ) + abs ( dx ) + abs ( dy ) == 1 : if NEW_LINE ( i [ 0 ] + dk < k ) and ( i [ 0 ] + dk >= 0 ) and ( i [ 1 ] + dx < n ) and ( i [ 1 ] + dx >= 0 ) and ( i [ 2 ] + dy < m ) and ( i [ 2 ] + dy >= 0 ) : NEW_LINE if a [ i [ 0 ] + dk ] [ i [ 1 ] + dx ] [ i [ 2 ] + dy ] == ' . ' : if NEW_LINE ( i [ 0 ] + dk , i [ 1 ] + dx , i [ 2 ] + dy ) in posetil : NEW_LINE continue else : posetil . add ( ( i [ 0 ] + dk , i [ 1 ] + dx , i [ 2 ] + dy ) ) NEW_LINE sosed2 . add ( ( i [ 0 ] + dk , i [ 1 ] + dx , i [ 2 ] + dy ) ) NEW_LINE sosed = sosed2 . copy ( ) NEW_LINE print ( len ( posetil ) ) NEW_LINE"],"bleu":0.0037690243922949085,"rouge_l":0.21003265063817156}
{"id":427,"predictions":["for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEW_LINE ali = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ali = [ ] NEW_LINE for i in range ( n ) : ali [ i ] = ali [ i : i ] NEW_LINE ali [ i : i ] = ali [ i : i ] NEW_LINE ali [ i : i ] = ali [ i : i ] NEW_LINE for i in ali : ali [ i ] : ali [ i ] = ali [ i : i ] NEW_LINE ali [ i : i ] = ali [ i : i ] NEW_LINE if ali [ i ] not in ali : NEW_LINE INDENT ali [ i : i ] = 1 NEW_LINE DEDENT DEDENT for i in ali : NEW_LINE INDENT ali [ i ] = ali [ i : i ] NEW_LINE DEDENT DEDENT print ( ali [ : i ] ) NEW_LINE"],"references":["t = int ( input ( ) )   for i in range ( t ) : p = input ( ) h = input ( ) cnts = { } for c in p : cnts [ c ] = cnts . get ( c , 0 ) + 1 yes = False for i in range ( len ( h ) ) : seq = { } for c in h [ i : ] : yes |= seq == cnts if c not in cnts : seq = { } else : seq [ c ] = seq . get ( c , 0 ) + 1 yes |= seq == cnts print ( \" YES \" if yes else \" NO \" ) NEW_LINE"],"bleu":0.11918894946016395,"rouge_l":0.32059564217672176}
{"id":428,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in range ( n ) : for j in range ( m ) : if a [ i ] [ j ] == a [ i ] [ j ] : c += 1 if a [ i ] [ j ] == b [ i ] [ j ] : c += 1 print ( c ) NEW_LINE"],"references":["v1 , v2 = map ( int , input ( ) . split ( ) ) t , d = map ( int , input ( ) . split ( ) ) t -= 1 u = [ 0 ] * ( t + 1 ) u [ 0 ] = v1for i in range ( 1 , t + 1 ) : u [ i ] = min ( u [ i - 1 ] + d , v2 + ( t - i ) * d ) ans = 0 for i in range ( 0 , t + 1 ) : ans += u [ i ] print ( ans ) NEW_LINE"],"bleu":0.33232214721864556,"rouge_l":0.45379113018598}
{"id":429,"predictions":["n , m = map ( int , input ( ) . split ( ) ) A = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] A = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] for j in range ( m ) : A [ i ] [ j ] = A [ i ] [ j ] for i in range ( n ) : A [ i ] [ j ] = max ( A [ i ] [ j ] , A [ i ] ) print ( * A [ i ] [ j ] ) NEW_LINE"],"references":["n = int ( input ( ) ) a = sorted ( [ int ( x ) for x in input ( ) . split ( ) ] ) s = sum ( a ) if a [ 0 ] != 0 : print ( - 1 ) exit ( 0 ) if s % 3 != 0 : for x in a : if x % 3 == s % 3 : a . remove ( x ) break else : for x in a : if x % 3 : a . remove ( x ) break for x in a : if x % 3 : a . remove ( x ) breakwhile len ( a ) > 1 and a [ - 1 ] == 0 : a . pop ( ) a = a [ : : - 1 ] print ( ' ' . join ( str ( x ) for x in a ) ) NEW_LINE"],"bleu":0.08974395672236467,"rouge_l":0.30440442612280316}
{"id":430,"predictions":["n , a , b = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l . sort ( ) if l [ 0 ] == l [ 0 ] : print ( - 1 ) elif l [ 1 ] == l [ 0 ] : print ( - 1 ) else : print ( - 1 ) NEW_LINE"],"references":["import math   n , a , b = map ( int , input ( ) . split ( ' ▁ ' ) ) rounds = math . log ( n , 2 ) r = int ( rounds ) for i in range ( 1 , int ( rounds ) + 1 ) : a = math . ceil ( a \/ 2 ) b = math . ceil ( b \/ 2 ) if ( a == b ) : if ( i == r ) : print ( ' Final ! ' ) break else : print ( i ) break NEW_LINE"],"bleu":0.22453397652757637,"rouge_l":0.47491349480968864}
{"id":431,"predictions":["n , k = map ( int , input ( ) . split ( ) ) print ( n - 1 ) NEW_LINE"],"references":["for x in range ( int ( input ( ) ) ) : n = int ( input ( ) ) if n % 2 == 0 : print ( n \/\/ 2 ) else : print ( ( n \/\/ 2 ) + 1 ) NEW_LINE"],"bleu":0.08463161284837226,"rouge_l":0.37670930745478604}
{"id":432,"predictions":["n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( 1 , n ) : if a [ i ] == ' W ' : a [ i ] = a [ i ] b [ i ] = ' W ' print ( max ( a ) ) NEW_LINE"],"references":["if __name__ == ' _ _ main _ _ ' : cin = input a = [ cin ( ) for i in range ( 8 ) ] mw , mb = 8 , 8   for c in range ( 8 ) : for r in range ( 8 ) : if a [ r ] [ c ] == \" W \" : mw = min ( mw , r ) if a [ r ] [ c ] != \" . \" : break for r in range ( 7 , - 1 , - 1 ) : if a [ r ] [ c ] == \" B \" : mb = min ( mb , 7 - r ) if a [ r ] [ c ] != \" . \" : break print ( \" AB \" [ mb < mw ] ) NEW_LINE"],"bleu":0.09167965820249994,"rouge_l":0.3216720257234727}
{"id":433,"predictions":["n , k = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) li = list ( map ( int , input ( ) . split ( ) ) ) li . sort ( ) if li [ - 1 ] == 1 : print ( - 1 ) else : print ( 1 ) NEW_LINE"],"references":["while True : try : n , m = list ( map ( int , input ( ) . split ( ) ) ) res = 1 while m % 2 == 0 : res += 1 m \/= 2 print ( res ) except : break NEW_LINE"],"bleu":0.24103112304351532,"rouge_l":0.45396912899669234}
{"id":434,"predictions":["t = int ( input ( ) ) for _ in range ( t ) : n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) print ( sum ( a ) ) NEW_LINE"],"references":["for _ in range ( int ( input ( ) ) ) : h , m = map ( int , input ( ) . split ( ) ) s = 0 s = ( 24 - h - 1 ) * 60 + ( 60 - m ) print ( s ) NEW_LINE"],"bleu":0.4386712823478205,"rouge_l":0.5582202587567056}
{"id":435,"predictions":["n , m , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) print ( b - 1 ) NEW_LINE"],"references":["def solve ( a , b , p , q ) : area1 = a * q area2 = a * ( b - q - 1 ) area3 = b * p area4 = b * ( a - p - 1 ) return max ( area1 , area2 , area3 , area4 ) if __name__ == ' _ _ main _ _ ' : S = int ( input ( ) ) for s in range ( S ) : a , b , p , q = tuple ( map ( int , input ( ) . split ( ) ) ) print ( solve ( a , b , p , q ) ) NEW_LINE"],"bleu":0.14621702478773116,"rouge_l":0.3813162007292933}
{"id":436,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) : for j in range ( m ) : if a [ i ] [ j ] == ' B ' : a [ i ] [ j ] += 1 if a [ i ] [ j ] == ' B ' : b [ i ] [ j ] = 1 if a [ i ] [ j ] == ' B ' : b [ i ] [ j ] = 1 if a [ i ] [ j ] == ' B ' : b [ i ] [ j ] = ' B ' else : b [ i ] [ j ] = ' B ' if a [ i ] [ j ] == ' B ' or a [ i ] [ j ] == ' B ' : b [ i ] [ j ] = ' B ' else : b [ i ] [ j ] = ' B ' if a [ i ] [ j ] == ' B ' else : b [ i ] [ j ] = ' B ' if a [ i ] [ j ] == ' B ' and a [ i ] [ j ] == ' B ' and a [ i ] [ j ] == ' B ' : b [ i ] [ j ] = ' B ' if a [ i ] [ j ] == ' B ' : b [ i ] = ' B ' else : if a [ i ] [ j ] == ' B ' : print ( ' B ' ) elif a [ i ] [ j ] == ' B ' : if a [ i ] [ j ] == ' B ' : print ( ' B ' ) else : print ( ' B ' ) else : print ( ' B ' ) NEW_LINE"],"references":["import sys   input = sys . stdin . readline   def check ( x , y ) : for i in range ( min ( x [ 0 ] , y [ 0 ] ) , max ( x [ 0 ] , y [ 0 ] ) + 1 ) : if not plan [ i ] [ x [ 1 ] ] == \" B \" : return False for i in range ( min ( x [ 1 ] , y [ 1 ] ) , max ( x [ 1 ] , y [ 1 ] ) + 1 ) : if not plan [ y [ 0 ] ] [ i ] == \" B \" : return False return True   n , m = map ( int , input ( ) . split ( ) ) plan = tuple ( tuple ( i for i in input ( ) . strip ( ) ) for j in range ( n ) ) start = [ ( i , j ) for i in range ( n ) for j in range ( m ) if plan [ i ] [ j ] == \" B \" ] for i in range ( len ( start ) ) : for j in range ( i + 1 , len ( start ) ) : if not check ( start [ i ] , start [ j ] ) and not check ( start [ j ] , start [ i ] ) : print ( \" NO \" ) sys . exit ( ) print ( \" YES \" ) NEW_LINE"],"bleu":0.16278271257499694,"rouge_l":0.31813068820942836}
{"id":437,"predictions":["if __name__ == ' _ _ main _ _ ' : n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) cnt = 0 cnt = 0 for i in range ( n ) : if a [ i ] != b [ i ] : cnt += 1 if b [ i ] == 0 : cnt += 1 if b [ i ] == 0 : cnt += 1 if b [ a [ i ] ] > 1 : cnt += 1 else : cnt += 1 if b [ a [ i ] ] == 0 : cnt += 1 else : if b [ a [ i ] ] < b [ a [ i ] ] : cnt += 1 if b [ a [ i ] ] > 1 : cnt += 1 else : cnt += 1 if b [ a [ i ] ] > 0 else : cnt += 1 if b [ a [ i ] ] == 0 : cnt += 1 print ( cnt ) else : print ( cnt ) NEW_LINE"],"references":["I = lambda : map ( int , input ( ) . split ( ) ) n , s = I ( ) l = [ 0 ] for i in range ( n ) : q , w = I ( ) q = q * 60 + w l += [ q ] if l [ 1 ] - l [ 0 ] > s : exit ( print ( 0 , 0 ) ) for i in range ( n ) : if l [ i + 1 ] - l [ i ] > 2 * s + 1 : l [ i ] += s + 1 exit ( print ( l [ i ] \/\/ 60 , l [ i ] % 60 ) ) l [ - 1 ] += s + 1 print ( l [ - 1 ] \/\/ 60 , l [ - 1 ] % 60 ) NEW_LINE"],"bleu":0.13691775462499975,"rouge_l":0.34002787113697847}
{"id":438,"predictions":["if __name__ == ' _ _ main _ _ ' : s = input ( ) n = len ( s ) for i in range ( n - 1 ) : if i == 0 : s [ i ] = s [ i : i ] else : s [ i ] = s [ i : i + 1 ] + s [ i ] else : s [ i ] = s [ i : : i ] + s [ i : i ] else : s [ i ] = s [ i : i ] continue elif i == n - 1 and s [ i + 1 ] != \" \/ \" : s [ i ] = \" \" elif s [ i ] == \" # \" : s [ i + 1 ] = \" \" elif s [ i ] == \" \" : s [ i ] = \" \" elif s [ i + 1 ] == \" : s [ i ] = \" \" \" elif s [ i ] == \" \" : s [ i ] = \" \" elif s [ i ] == \" \" : s [ i ] = \" \" . \" elif s [ i + 1 ] == \" \" : s [ i ] = \" \" elif s [ i ] != \" \" \" : s [ i ] = \" \" \" NEW_LINE"],"references":["s = input ( ) ans = \" \" if s . startswith ( ' http ' ) : s = s [ 4 : ] ans = ' http : \/ \/ ' else : ans = \" ftp : \/ \/ \" s = s [ 3 : ]   if s . count ( ' ru ' ) > 1 and s . index ( ' ru ' ) == 0 : x = s [ 1 : ] . index ( ' ru ' ) + 1 else : x = s . index ( ' ru ' )     ans += s [ : x ] + ' . ' + ' ru ' s = s [ x + 2 : ] if s : ans += ' \/ ' + s   print ( ans )     NEW_LINE"],"bleu":0.06716841146025172,"rouge_l":0.29994824016563154}
{"id":439,"predictions":["n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l1 = [ ] for i in range ( n ) : l1 . append ( l1 [ i ] ) l2 . append ( l2 [ i ] ) l2 . append ( l1 [ i ] ) l2 . append ( l2 [ i ] ) l2 . append ( l2 [ i ] ) l2 . append ( l1 [ i ] ) l2 . append ( l1 [ i ] ) l2 . append ( l1 [ i ] ) l2 . sort ( ) print ( ' \\n ' . join ( map ( str , l1 [ i ] ) ) ) NEW_LINE"],"references":["tests = int ( input ( ) ) t = 0 for t in range ( 0 , tests ) : n = int ( input ( ) ) s = input ( ) bol = False for i in range ( 0 , len ( s ) ) : if s [ i ] == '8' : bol = True cnt = i break if ( bol ) : if n - cnt >= 11 : print ( ' YES ' ) else : print ( ' NO ' ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.1411950429725912,"rouge_l":0.3423021582733813}
{"id":440,"predictions":["a = list ( map ( int , input ( ) . split ( ) ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) print ( a [ 0 ] , end = ' ▁ ' ) NEW_LINE"],"references":["def solve ( arr ) : for i in range ( len ( arr ) ) : if arr [ i ] % 2 == 0 : arr [ i ] -= 1 return \" ▁ \" . join ( str ( i ) for i in arr )   input ( ) arr = list ( map ( int , input ( ) . split ( ) ) ) print ( solve ( arr ) ) NEW_LINE"],"bleu":0.2943094102167624,"rouge_l":0.4265734265734266}
{"id":441,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) for i in b : if b [ i ] == b [ i ] : b [ i ] = b [ i ] else : b [ i ] = b [ i ] for i in b : if b [ i ] == b [ i ] : b [ i ] = b [ i ] else : b [ i ] = b [ i ] if b [ i ] : b [ i ] = b [ i ] else : b [ i ] = b [ i ] else : b [ i ] = b [ i ] if a [ i ] > b [ i ] : b [ i ] = b [ i ] for i in b [ i ] : b [ i ] ] = b [ i ] print ( \" YES \" ) NEW_LINE"],"references":["from collections import defaultdictfrom sys import stdin   def put ( ) : return map ( int , stdin . readline ( ) . split ( ) )   def dfs ( ) : s = [ ( 1 , 0 ) ] ans = 0 vis = [ 0 ] * ( n + 1 ) while s : i , p = s . pop ( ) if vis [ i ] == 0 : vis [ i ] = 1 s . append ( ( i , p ) ) for j in tree [ i ] : if j != p : s . append ( ( j , i ) ) elif vis [ i ] == 1 : vis [ i ] = 2 for j in tree [ i ] : if j != p : mark [ i ] += mark [ j ] ans += min ( mark [ i ] , 2 * k - mark [ i ] ) print ( ans )                         n , k = put ( ) l = list ( put ( ) )   edge = defaultdict ( ) tree = [ [ ] for i in range ( n + 1 ) ] mark = [ 0 ] * ( n + 1 ) for i in l : mark [ i ] = 1 for _ in range ( n - 1 ) : x , y = put ( ) tree [ x ] . append ( y ) tree [ y ] . append ( x ) dfs ( ) NEW_LINE"],"bleu":0.1684934275674221,"rouge_l":0.3342262267137465}
{"id":442,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) flag = 0 for i in range ( n ) : flag = 0 for j in range ( m ) : flag = 0 for j in range ( n ) : flag = False if flag : print ( ' YES ' ) flag = False break if flag : print ( ' NO ' ) NEW_LINE"],"references":["for _ in range ( int ( input ( ) ) ) : a = input ( ) b = input ( ) c = input ( ) case = True for i in range ( len ( a ) ) : if a [ i ] != c [ i ] and b [ i ] != c [ i ] : case = False print ( \" NO \" ) break if case : print ( \" YES \" ) NEW_LINE"],"bleu":0.1650487222392547,"rouge_l":0.42681543116490167}
{"id":443,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in range ( n + 1 ) : if c [ i ] == c [ i ] : c [ i ] = c [ i ] for i in range ( n + 1 ) : if c [ i ] == c [ i ] : c [ i ] = 1 if c [ i ] == c [ i ] : c [ i ] = 1 if c [ i ] == c [ i ] or c [ i ] == c [ i ] ] : NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) g = [ set ( ) for i in range ( n ) ] for i in range ( m ) : a , b = map ( int , input ( ) . split ( ) ) g [ a - 1 ] . add ( b - 1 ) g [ b - 1 ] . add ( a - 1 ) a = [ ] p = [ - 1 ] * nfor i in range ( n ) : if p [ i ] != - 1 : continue p [ i ] = 0 a . append ( i ) while a : x = a . pop ( ) for node in g [ x ] : if p [ node ] == p [ x ] : print ( - 1 ) exit ( ) if p [ node ] == - 1 : p [ node ] = not p [ x ] a . append ( node ) print ( p . count ( 0 ) ) for i in range ( n ) : if p [ i ] == 0 : print ( i + 1 , end = \" ▁ \" ) print ( ) print ( p . count ( 1 ) ) for i in range ( n ) : if p [ i ] == 1 : print ( i + 1 , end = \" ▁ \" ) print ( ) NEW_LINE"],"bleu":0.2328453162740167,"rouge_l":0.3904604583935577}
{"id":444,"predictions":["x , y , x1 , y2 = map ( int , input ( ) . split ( ) ) x2 , y2 = map ( int , input ( ) . split ( ) ) if abs ( x1 - x1 ) != abs ( x2 - x1 ) ** 2 : print ( - 1 , x1 , y2 , x2 , y2 ) NEW_LINE"],"references":["x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) )   if x1 == x2 : x3 = x1 + abs ( y2 - y1 ) x4 = x3 y3 = y1 y4 = y2 NEW_LINE"],"bleu":0.30957648010879646,"rouge_l":0.5127589312518764}
{"id":445,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) ans = 0 for i in range ( n ) : for j in range ( m ) : if a [ i ] [ j ] == a [ i ] [ j ] : ans += b [ i ]   print ( ans ) NEW_LINE"],"references":["def checkRow ( i , c ) : cnt = 0 NEW_LINE for j in range ( m ) : if NEW_LINE g [ i ] [ j ] == c : cnt += 1   if cnt >= 2 : return True NEW_LINE return False     NEW_LINE def checkCol ( j , c ) : cnt = 0 NEW_LINE for i in range ( n ) : if NEW_LINE g [ i ] [ j ] == c : cnt += 1   if cnt >= 2 : return True NEW_LINE return False   n , m = map ( int , input ( ) . split ( ) )   g = [ ]   for i in range ( n ) : g . append ( list ( input ( ) ) )     res = [ [ 0 ] * m for i in range ( n ) ] NEW_LINE for i in range ( n ) : for NEW_LINE j in range ( m ) : NEW_LINE if ( checkRow ( i , g [ i ] [ j ] ) ) or checkCol ( j , g [ i ] [ j ] ) : res [ i ] [ j ] = 1     for i in range ( n ) : for NEW_LINE j in range ( m ) : NEW_LINE if res [ i ] [ j ] == 0 : print ( g [ i ] [ j ] , end = ' ' )         NEW_LINE"],"bleu":0.10922873820115142,"rouge_l":0.34804497398892426}
{"id":446,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = [ ] for i in range ( n ) : if b [ i ] % 2 == 0 : b [ i ] . append ( b [ i ] ) else : c [ b [ i ] ] = 1 if b [ i ] == 1 : c . append ( b [ i ] ) else : c . append ( b [ i ] ) c . append ( b [ i ] ) print ( c ) NEW_LINE"],"references":["n , M = map ( int , input ( ) . strip ( ) . split ( ) ) a = list ( map ( int , input ( ) . strip ( ) . split ( ) ) )   a . insert ( 0 , 0 ) n += 1   lit = [ 0 ] * ( n + 1 ) for i in range ( 1 , n ) : if i % 2 == 0 : lit [ i ] = lit [ i - 1 ] else : lit [ i ] = lit [ i - 1 ] + a [ i ] - a [ i - 1 ] if n % 2 == 0 : lit [ n ] = lit [ n - 1 ] else : lit [ n ] = lit [ n - 1 ] + M - a [ n - 1 ] NEW_LINE"],"bleu":0.316529081321032,"rouge_l":0.5185518551855186}
{"id":447,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) ) print ( \" NO \" ) NEW_LINE"],"references":["import sysdef input ( ) : return sys . stdin . readline ( ) . strip ( ) def iinput ( ) : return int ( input ( ) ) def minput ( ) : return map ( int , input ( ) . split ( ) ) def listinput ( ) : return list ( map ( int , input ( ) . split ( ) ) ) c = 0 for _ in range ( iinput ( ) ) : km , dirr = map ( str , input ( ) . split ( ) ) km = int ( km ) if dirr == ' North ' : c -= km elif dirr == ' South ' : c += km elif c == 0 or c == 20000 : print ( \" NO \" ) exit ( ) if c < 0 or c > 20000 : print ( \" NO \" ) exit ( ) if c == 0 : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.1479862984395923,"rouge_l":0.4234590065828846}
{"id":448,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) : if b [ i ] % 2 == 0 : if b [ i ] % 2 == 0 : b . append ( b [ i ] ) else : b . append ( b [ i ] ) b . sort ( ) b . sort ( ) b . sort ( ) b . sort ( ) print ( * b ) NEW_LINE"],"references":["n , m = list ( map ( int , input ( ) . split ( \" ▁ \" ) ) )   if m % 2 != 0 : mid = int ( ( m + 1 ) \/ 2 ) i = mid j = mid       else :   mid = int ( ( m \/ 2 ) ) i = mid j = mid + 1     detector = 1 if m == 1 : for x in range ( n ) : print ( 1 ) else : for _ in range ( n ) : if i == j : print ( mid ) i -= 1 j += 1 detector = 1 continue if m % 2 != 0 : if detector == - 1 : print ( j ) j += 1 if j == m + 1 : j = mid detector *= - 1 elif detector == 1 : print ( i ) i -= 1 if i == 0 : i = mid detector *= - 1   elif m % 2 == 0 : if detector == 1 : print ( i ) i -= 1 if i == 0 : i = mid detector *= - 1 elif detector == - 1 : print ( j )   j += 1 if j == m + 1 : j = mid + 1 detector *= - 1     NEW_LINE"],"bleu":0.11204759093649005,"rouge_l":0.29591836734693877}
{"id":449,"predictions":["n , x , y = map ( int , input ( ) . split ( ) ) if ( x - x ) : print ( 0 ) else : print ( n - x ) NEW_LINE"],"references":["import mathfrom math import gcd , floor , sqrt , logdef iin ( ) : return int ( input ( ) ) def sin ( ) : return input ( ) . strip ( ) def listin ( ) : return list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) def liststr ( ) : return list ( map ( str , input ( ) . strip ( ) . split ( ) ) ) def ceill ( x ) : return int ( x ) if ( x == int ( x ) ) else int ( x ) + 1 def ceilldiv ( x , d ) : return x \/\/ d if ( x % d == 0 ) else x \/\/ d + 1 def LCM ( a , b ) : return ( a * b ) \/\/ gcd ( a , b )     def solve ( ) : n , x , y = listin ( ) wiz = x people = n - x req = ceill ( ( y \/ 100 ) * n ) print ( max ( 0 , req - wiz ) ) t = 1 NEW_LINE"],"bleu":0.0071713419754804485,"rouge_l":0.22220916568742657}
{"id":450,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) s = 0 for i in range ( n ) : if a [ i ] % m == 0 : s += a [ i ] else : s += a [ i ] \/\/ 2 print ( s ) NEW_LINE"],"references":["n = int ( input ( ) ) vals = list ( map ( int , input ( ) . split ( ) ) ) vals = [ ( i , vals [ i ] ) for i in range ( n ) ] vals = [ vals [ 0 ] ] + sorted ( vals [ 1 : ] , key = lambda x : x [ 1 ] , reverse = True ) most_left_idx = 0 count = 0 output = ' ' for i in range ( n ) : if ( most_left_idx >= i ) : for j in range ( 1 , vals [ i ] [ 1 ] + 1 ) : if ( most_left_idx + j < n ) : count += 1 output += ' { } ▁ { } ▁ \\n ' . format ( vals [ i ] [ 0 ] + 1 , vals [ most_left_idx + j ] [ 0 ] + 1 ) most_left_idx += vals [ i ] [ 1 ] if ( most_left_idx >= n - 1 ) : print ( count ) print ( output ) else : print ( - 1 ) NEW_LINE"],"bleu":0.11620123787202663,"rouge_l":0.36599999999999994}
{"id":451,"predictions":["n , k = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l1 = list ( map ( int , input ( ) . split ( ) ) ) l2 = list ( map ( int , input ( ) . split ( ) ) ) ) l = [ ] for i in range ( k ) : for j in range ( k ) : if l1 [ i ] [ j ] == l [ i ] [ j ] : l1 [ i ] [ j ] : l1 . append ( i ) break l1 . sort ( ) print ( - 1 ) NEW_LINE"],"references":["l = [ - 1 ] * 122 g = [ - 1 ] * 122 r = 0 ch = 0 n , k = map ( int , input ( ) . split ( ) ) s = input ( ) j = nfor i in range ( 0 , n ) : j -= 1 indf = ord ( s [ i ] ) indb = ord ( s [ j ] ) if ( l [ indf ] != - 1 ) : pass else : l [ indf ] = i if ( g [ indb ] != - 1 ) : pass else : g [ indb ] = j   for i in range ( 0 , n ) : indx = ord ( s [ i ] ) if ( l [ indx ] == i ) : r += 1 if ( r > k ) : ch = 1 break if ( g [ indx ] == i ) : r -= 1 if ( ch == 1 ) : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.1700445847384913,"rouge_l":0.37328800388538125}
{"id":452,"predictions":["import bisectn , l , l = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l = [ ] for i in range ( l ) : l . append ( ( l [ i ] - l [ i ] ) l . append ( l [ i ] - l [ i ] ) l . append ( l [ i ] ) l [ i ] . append ( l [ i ] - l [ i ] ) l [ i ] . append ( i ) l . sort ( ) for i in l [ i ] : print ( i , end = \" \\n \" ) NEW_LINE"],"references":["a , b = list ( map ( int , input ( ) . split ( ) ) ) print ( format ( ( ( b * b ) - ( a * a ) ) \/ ( a * 2 ) , ' . 12f ' ) ) NEW_LINE"],"bleu":0.1445123033088719,"rouge_l":0.36365384615384616}
{"id":453,"predictions":["n = int ( input ( ) ) s1 = input ( ) s2 = input ( ) s2 = input ( ) s3 = s3 = s3print ( len ( s3 ) ) NEW_LINE"],"references":["s = input ( ) w = len ( s ) q = - 1 for i in range ( w - 2 ) : for j in range ( i + 1 , w - 1 ) : a , b , c = s [ : i + 1 ] , s [ i + 1 : j + 1 ] , s [ j + 1 : ] if len ( a ) == len ( str ( int ( a ) ) ) and len ( b ) == len ( str ( int ( b ) ) ) and len ( c ) == len ( str ( int ( c ) ) ) : if int ( a ) <= 10 ** 6 and int ( b ) <= 10 ** 6 and int ( c ) <= 10 ** 6 : q = max ( q , int ( a ) + int ( b ) + int ( c ) ) print ( q ) NEW_LINE"],"bleu":0.0032793735236773254,"rouge_l":0.16234766774057993}
{"id":454,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = list ( map ( int , input ( ) . split ( ) ) ) dic = { } for i in range ( n ) : if a [ i ] in dic [ a [ i ] ] : dic [ a [ i ] ] = 1 dic [ a [ i ] ] = 1 dic [ a [ i ] ] = 1 for i in dic [ a [ i ] ] : dic [ a [ i ] ] += 1 if a [ i ] > 0 : dic [ a [ i ] ] += 1 elif a [ i ] == 1 : dic [ a [ i ] ] = 1 elif a [ i ] == 1 : dic [ a [ i ] ] -= 1 dic [ a [ i ] ] = 1 elif a [ i ] == 1 : dic [ a [ i ] ] = 1 elif a [ i ] == 1 : dic [ a [ i ] ] = 1 else : dic [ a [ i ] ] = 1 elif a [ i ] == 1 : dic [ a [ i ] ] = 1 elif a [ i ] == 1 : dic [ a [ i ] ] = 1 elif a [ i ] > 1 : dic [ a [ i ] ] = 1 elif a [ i ] > 1 : if a [ i ] == 1 : dic [ a [ i ] ] = 1 elif a [ i ] ] == 1 : dic . append ( a [ i ] ) else : dic . append ( a [ i ] ) else : dic [ a [ i ] ] = 1 for i in range ( len ( a ) ) : if a [ i ] == 1 : dic [ i ] = 1 elif a [ i ] > 0 : dic . append ( a [ i ] ) else : dic . append ( a [ i ] ) else : dic . append ( a [ i ] ) for i in range ( len ( a ) ) : if dic [ i ] > 0 else : dic . append ( a [ i ] ) else : dic [ i ] = 1"],"references":["x = int ( input ( ) ) for i in range ( x ) : n , m = [ int ( a ) for a in input ( ) . split ( ) ] if ( 2 * min ( n , m ) < max ( m , n ) or ( n + m ) % 3 ) : print ( \" NO \" ) else : print ( \" YES \" ) NEW_LINE"],"bleu":0.045947508741657136,"rouge_l":0.16569160050146262}
{"id":455,"predictions":["import math   n = int ( input ( ) ) a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ]   a . sort ( )   a = [ 0 ] \/ a [ 0 ] [ 2 ] for i in range ( n ) ]   for i in range ( n ) : for j in range ( n ) : a [ i ] [ j ] = a [ i ] [ j ] \/ a [ i ] [ j ]   if ( a [ i ] [ j ] > a [ i ] [ j ] ) : a [ i ] [ j ] = a [ i ] [ j ] \/ a [ i ] [ j ]   else : a [ i ] [ j ] = a [ i ] [ j ] \/ a [ i ] [ j ] = a [ i ] [ j ] print ( ' ▁ ' . join ( a [ i ] [ j ] ) ) NEW_LINE"],"references":["from sys import * ; from math import * ; from collections import * ; from bisect import * ; from itertools import * INF = maxsizedef get_ints ( ) : return map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) def get_array ( ) : return list ( map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) ) def input ( ) : return stdin . readline ( ) . strip ( ) mod = 1000000007   n = int ( input ( ) ) arr = [ ] for i in range ( n ) : temp = get_array ( ) arr . append ( temp ) for i in range ( n ) : ans = ( arr [ i ] [ ( i + 1 ) % n ] * arr [ i ] [ ( i + 2 ) % n ] ) \/\/ arr [ ( i + 1 ) % n ] [ ( i + 2 ) % n ] print ( int ( sqrt ( ans ) ) , end = ' ▁ ' ) NEW_LINE"],"bleu":0.23779243452813562,"rouge_l":0.3717094572635684}
{"id":456,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in range ( n ) : if b [ i ] == a [ i ] : c += 1 if a [ i ] == b [ i ] : c += 1 if b [ i ] == a [ i ] : print ( 0 ) else : print ( 0 ) NEW_LINE"],"references":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) [ : n ] res = [ a . index ( 1 ) , a . index ( n ) ] print ( max ( max ( res ) , n - min ( res ) - 1 ) ) NEW_LINE"],"bleu":0.2453956800818137,"rouge_l":0.4500097068530383}
{"id":457,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["n = int ( input ( ) ) num = [ int ( i ) for i in input ( ) . split ( \" ▁ \" ) ]   odd = 0 even = 0   for i in num : if even and odd : break if i % 2 == 0 : even = 1 else : odd = 1 if even and odd : num = sorted ( num ) s = \" \" for i in range ( 0 , len ( num ) ) : s += str ( num [ i ] ) + \" ▁ \" print ( s ) NEW_LINE"],"bleu":0.05493364673052261,"rouge_l":0.2631888605608943}
{"id":458,"predictions":["n = int ( input ( ) ) NEW_LINE for _ in range ( n ) : NEW_LINE INDENT s = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT s [ i ] [ 0 ] = 1 NEW_LINE DEDENT DEDENT print ( s ) NEW_LINE DEDENT"],"references":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) k = ns = set ( ) for i in a : s . add ( i ) while k in s : print ( k , end = ' ▁ ' ) k -= 1 print ( ) NEW_LINE"],"bleu":0.36825765530172705,"rouge_l":0.5418967587034814}
{"id":459,"predictions":["for _ in range ( int ( input ( ) ) ) : n , s = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE s = input ( ) NEW_LINE if s [ 0 ] != s [ 1 ] : NEW_LINE INDENT print ( '1' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( '1' ) NEW_LINE DEDENT"],"references":["for t in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEW_LINE b = input ( ) NEW_LINE a = ' ' NEW_LINE d = ' ' NEW_LINE for i in b : try : if 1 + int ( i ) == int ( d [ - 1 ] ) : NEW_LINE INDENT a += '0' else : NEW_LINE a += '1' except : a = '1' NEW_LINE DEDENT d = str ( int ( a [ - 1 ] ) + int ( i ) ) NEW_LINE print ( a ) NEW_LINE"],"bleu":0.2251933433050401,"rouge_l":0.4642145316180469}
{"id":460,"predictions":["n , m = map ( int , input ( ) . split ( ) ) l = [ ] for i in range ( n ) : a , b = map ( int , input ( ) . split ( ) ) l . append ( ( ( a , b ) ) ) for i in l : if l [ i ] == 1 : l [ i ] = 1 l [ i ] = 1 l [ i ] = 1 l = l [ i ] for i in range ( n - 1 , - 1 , - 1 ) : if l [ i ] [ l [ i ] ] == 1 : l [ i ] = l [ i ] l [ i ] = l [ i ] if l [ i ] == 1 : l . append ( l [ i ] ) l . append ( l [ i ] ) l . append ( l [ i ] ) else : l . append ( l [ i ] ) print ( len ( l ) ) ) NEW_LINE"],"references":["from math import ceiln , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) m = 10 ** ( k - 1 ) ans = 1 for i in range ( n \/\/ k ) : an = ( 10 ** k - 1 ) \/\/ a [ i ] + 1 l = b [ i ] * m r = ( b [ i ] + 1 ) * m - 1 count = r \/\/ a [ i ] - ceil ( l \/ a [ i ] ) + 1 ans = ( ans * ( an - count ) ) % ( 10 ** 9 + 7 ) print ( ans ) NEW_LINE"],"bleu":0.2436803894784562,"rouge_l":0.450909780136467}
{"id":461,"predictions":["n = int ( input ( ) ) a = int ( input ( ) ) b = int ( input ( ) ) print ( a , b ) NEW_LINE"],"references":["x = ( int ( input ( ) ) + 1 ) \/\/ 3 print ( x \/\/ 12 , x % 12 ) NEW_LINE"],"bleu":0.22963869978965587,"rouge_l":0.5098507462686567}
{"id":462,"predictions":["for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l = list ( map ( int , input ( ) . split ( ) ) ) count = 0 count = 0 for i in l : count += 1 print ( count ) NEW_LINE"],"references":["n , b , d = map ( int , input ( ) . split ( ) ) summa = 0 ans = 0 a = [ int ( i ) for i in input ( ) . split ( ) ] for i in a : if i <= b : summa += i if summa > d : summa = 0 ans += 1 print ( ans ) NEW_LINE"],"bleu":0.33007923155610025,"rouge_l":0.45687698592827963}
{"id":463,"predictions":["n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) print ( b [ - 1 ] ) NEW_LINE"],"references":["n , m , b , mod = list ( map ( int , input ( ) . split ( ) ) ) a = list ( map ( int , input ( ) . split ( ) ) )   A = [ [ 0 for i in range ( m + 1 ) ] for j in range ( b + 1 ) ]   A [ 0 ] [ 0 ] = 1   for i in range ( n ) : for j in range ( a [ i ] , b + 1 ) : for k in range ( m ) : A [ j ] [ k + 1 ] = ( A [ j ] [ k + 1 ] + A [ j - a [ i ] ] [ k ] ) % mod NEW_LINE"],"bleu":0.21325582459353354,"rouge_l":0.428370786516854}
{"id":464,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) b . sort ( ) b . sort ( ) if a [ 0 ] == b [ - 1 ] : print ( \" < \" ) else : print ( \" < \" ) else : if a [ - 1 ] != b [ 0 ] : print ( \" < \" ) else : print ( \" \" ) NEW_LINE"],"references":["def clean ( d ) : ans = [ '0' ] for c in list ( d ) : ans . append ( c ) i = len ( ans ) - 1 NEW_LINE"],"bleu":0.02009565611156001,"rouge_l":0.19472228133645456}
{"id":465,"predictions":["n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( 1 , n ) : if a [ i ] != b [ a [ i ] ] : b [ a [ i ] ] = b [ a [ i ] ] = b [ a [ i ] ] else : b [ a [ i ] ] = 1 if a [ i ] == b [ a [ i ] ] : if a [ i ] ] != b [ a [ i ] ] : b [ i ] ] = 1 if a [ i ] [ 0 ] != b [ i ] [ 0 ] : a [ i ] [ 1 ] = 1 else : a [ i ] [ 0 ] = b [ i ] [ 1 ] = 1 else : a [ i ] [ 1 ] = b [ i ] [ 0 ] = 1 for i in range ( n ) : a [ i ] [ 0 ] = b [ i ] [ 0 ] = b [ i ] [ 1 ] = 1 for i in range ( n ) : if a [ i ] [ 0 ] == b [ i ] [ 1 ] = b [ i ] [ 0 ] = 1 for i in range ( n ) : if a [ i ] [ 0 ] == b [ i ] [ 0 ] == b [ i ] [ 1 ] : a [ i ] [ 1 ] = 1 else : a [ i ] [ 1 ] = b [ i ] [ 1 ] = b [ i ] [ 0 ] = 1 for i in range ( n ) : for j in range ( n ) : if a [ i ] [ j ] == b [ i ] : a [ j ] [ j ] = b [ i ] [ j ] else : a [ i ] [ j ] = b [ i ] [ j ] = b [ i ] [ j ] = b [ i ] [ j ] if a [ j ] [ j ] == b [ i ] [ j ] and a [ j ] [ j ] == b [ i ] : print ( ' YES ' ) for i in range ( 1 , n ) : print ( ' NO ' ) NEW_LINE"],"references":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) d = [ 0 ] * 4 for i in a : if i == 1 : d [ 0 ] += 1 d [ 2 ] = max ( d [ 2 ] + 1 , d [ 1 ] + 1 ) else : d [ 1 ] = max ( d [ 1 ] + 1 , d [ 0 ] + 1 ) d [ 3 ] = max ( d [ 3 ] + 1 , d [ 2 ] + 1 ) print ( max ( d ) ) NEW_LINE"],"bleu":0.08118821294940004,"rouge_l":0.29690099192902475}
{"id":466,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) a . sort ( ) print ( sum ( a ) ) NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) a = [ int ( i ) for i in input ( ) . split ( ) ] b = [ 0 ] * ( 10 ** 5 + 1 ) p = [ 0 ] * n + [ 0 ] for i in range ( len ( a ) - 1 , - 1 , - 1 ) : if b [ a [ i ] ] == 0 : b [ a [ i ] ] += 1 p [ i ] = p [ i + 1 ] + 1 else : p [ i ] = p [ i + 1 ] for i in range ( m ) : k = int ( input ( ) ) print ( p [ k - 1 ] ) NEW_LINE"],"bleu":0.06653850442616868,"rouge_l":0.33712004912496163}
{"id":467,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["a , b = map ( int , input ( ) . split ( ) ) if a == b : print ( a ) else : print ( \"1\" ) NEW_LINE"],"bleu":0.21554491059608466,"rouge_l":0.4456381607219596}
{"id":468,"predictions":["n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in range ( n ) : if a [ i ] % 2 == 0 : c += 1 else : if a [ i ] % 2 == 0 : b += 1 else : c += 1 print ( c ) NEW_LINE"],"references":["from sys import stdin , stdoutn = int ( input ( ) ) arr = [ ] d = dict ( ) for i in range ( n ) : x = tuple ( [ int ( x ) for x in stdin . readline ( ) . split ( ) ] ) d [ x ] = 1 arr . append ( x ) cnt = 0 for i in range ( n - 1 ) : for j in range ( i + 1 , n ) : sum1 = arr [ i ] [ 0 ] + arr [ j ] [ 0 ] sum2 = arr [ i ] [ 1 ] + arr [ j ] [ 1 ] if ( sum1 \/ 2 == sum1 \/\/ 2 ) and ( sum2 \/ 2 == sum2 \/\/ 2 ) : tup = ( sum1 \/\/ 2 , sum2 \/\/ 2 ) if d . get ( tup ) : cnt += 1 ; print ( cnt ) NEW_LINE"],"bleu":0.11954962417405826,"rouge_l":0.350453866482822}
{"id":469,"predictions":["n , m = list ( map ( int , input ( ) . split ( ) ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) print ( sum ( b ) ) NEW_LINE"],"references":["import sys     def ints_input ( ) : return [ int ( i ) for i in sys . stdin . readline ( ) . strip ( \" \\n \" ) . split ( \" ▁ \" ) ]     def print_list ( arr ) : sys . stdout . writelines ( str ( x ) + \" ▁ \" for x in arr ) sys . stdout . write ( \" \\n \" )     def fast_input ( type = str ) : return type ( sys . stdin . readline ( ) . strip ( \" \\n \" ) )     X = ints_input ( ) n , x = X [ 0 ] , X [ 1 : ] Y = ints_input ( ) m , y = Y [ 0 ] , Y [ 1 : ]   Z = ints_input ( ) p , z = Z [ 0 ] , Z [ 1 : ]   a , b = ints_input ( ) r2 = max ( x ) * ( b * max ( y ) \/ ( a * min ( z ) + b * max ( y ) ) ) ** 0.5 print ( r2 ) NEW_LINE"],"bleu":0.04010348373859556,"rouge_l":0.2814161067094574}
{"id":470,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in range ( n ) : for j in range ( m ) : if a [ i ] [ j ] == a [ i ] [ j ] and a [ i ] [ j ] == b [ i ] [ j ] : c += 1 if a [ i ] [ j ] == b [ i ] [ j ] : c += 1 if a [ i ] [ j ] == b [ i ] [ j ] : c += 1 if a [ i ] [ j ] == a [ i ] [ j ] : print ( \" NO \" ) else : print ( \" YES \" ) NEW_LINE"],"references":["def lower_bound ( arr , left , right , target ) : if arr [ right ] < target : return right + 1 while left < right : mid = ( left + right ) >> 1 if arr [ mid ] >= target : right = mid else : left = mid + 1 return left   T = int ( input ( ) ) arr = [ 0 ] * Tdp = [ 0 ] * ( T + 1 ) for i in range ( T ) : arr [ i ] = int ( input ( ) ) for i in range ( T ) : dp [ i + 1 ] = dp [ i ] + 20 dp [ i + 1 ] = min ( dp [ i + 1 ] , dp [ lower_bound ( arr , 0 , T - 1 , arr [ i ] - 89 ) ] + 50 ) dp [ i + 1 ] = min ( dp [ i + 1 ] , dp [ lower_bound ( arr , 0 , T - 1 , arr [ i ] - 1439 ) ] + 120 ) print ( dp [ i + 1 ] - dp [ i ] ) NEW_LINE"],"bleu":0.09230985687976281,"rouge_l":0.3240173245076407}
{"id":471,"predictions":["n , m = map ( int , input ( ) . split ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) arr . sort ( ) ans = [ 0 ] * m for i in range ( n ) ]   for i in range ( n ) : for j in range ( m ) : if s [ i ] [ j ] == 1 : ans [ i ] [ j ] = arr [ i ] [ j ] else : ans [ i ] [ j ] = arr [ i ] [ j ] else : ans [ i ] [ j ] = arr [ i ] [ j ] print ( ans ) NEW_LINE"],"references":["import math as mtimport sys , stringfrom collections import Counter , defaultdictinput = sys . stdin . readline MOD = 1000000007 I = lambda : int ( input ( ) ) M = lambda : map ( int , input ( ) . split ( ) ) Ms = lambda : map ( str , input ( ) . split ( ) ) ARR = lambda : list ( map ( int , input ( ) . split ( ) ) ) def solve ( ) : n , m = M ( ) mat = [ ARR ( ) for _ in range ( n ) ]   setLengths = [ ] for i in range ( n ) : black , white = 0 , 0 for j in range ( m ) : if mat [ i ] [ j ] == 0 : black += 1 elif mat [ i ] [ j ] == 1 : white += 1 if white > 0 : setLengths . append ( white ) if black > 0 : setLengths . append ( black )   for j in range ( m ) : black , white = 0 , 0 for i in range ( n ) : if mat [ i ] [ j ] == 0 : black += 1 elif mat [ i ] [ j ] == 1 : white += 1 if white > 0 : setLengths . append ( white ) if black > 0 : setLengths . append ( black )   ans = n * m for e in setLengths : ans += ( 1 << e ) ans -= ( e + 1 ) print ( ans )     tc = 1 NEW_LINE"],"bleu":0.2284452404895833,"rouge_l":0.456865464632455}
{"id":472,"predictions":["n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) arr . sort ( ) print ( arr [ n - 1 ] ) NEW_LINE"],"references":["n = int ( input ( ) ) print ( sorted ( map ( int , input ( ) . split ( ) ) ) [ ( n - 1 ) \/\/ 2 ] ) NEW_LINE"],"bleu":0.6130636378437005,"rouge_l":0.7704703832752613}
{"id":473,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = [ ] for i in range ( n ) : b . append ( b [ i ] ) b . append ( b [ i ] ) b . append ( b [ i ] ) b . append ( b [ i ] ) b . append ( b [ i ] ) b . append ( b [ i ] ) b . sort ( ) b . sort ( ) b = [ ] for i in b : if i in b : if len ( b [ i ] ) > b [ i ] : b [ i ] = b [ i ] else : b [ i ] . append ( b [ i ] ) b [ i ] . append ( len ( b ) ) b . append ( b [ i ] ) else : b [ i ] . append ( b [ i ] ) print ( len ( b ) ) NEW_LINE"],"references":["import java . util . * ;   public class aerg {   static Scanner in = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { String s = in . next ( ) ; String u = in . next ( ) ; int ans = 0 ; for ( int i = 0 ; i < s . length ( ) ; i + + ) { for ( int j = 0 ; j < u . length ( ) ; j + + ) { int k = 0 ; if ( s . charAt ( i ) == u . charAt ( j ) ) { k + + ; for ( int z = j + 1 , t = i + 1 ; z < u . length ( ) & & t < s . length ( ) ; z + + , t + + ) { if ( s . charAt ( t ) == u . charAt ( z ) ) { k + + ; } } \/\/ System . out . println ( i + \" ▁ \" + k ) ; } ans = Math . max ( ans , k ) ; } if ( ans > s . length ( ) - i ) break ; } \/\/ System . out . println ( u . length ( ) ) ; System . out . println ( u . length ( ) - ans ) ; } } NEW_LINE"],"bleu":0.027895977337360347,"rouge_l":0.27174202127659575}
{"id":474,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = [ ] for i in range ( n ) : if a [ i ] == ' # ' : b . append ( a [ i ] ) else : b . append ( a [ i ] ) b . append ( a [ i ] ) for i in range ( n ) : if b [ i ] == ' # ' and a [ i ] == ' # ' : b . append ( a [ i ] ) b . append ( a [ i ] ) b . append ( a [ i ] ) b . append ( b [ i ] )   for i in range ( n ) : if a [ i ] != b [ i ] : b . append ( a [ i ] ) b . append ( b [ i ] ) b [ i ] = b [ i ] for i in b [ i ] : if a [ i ] [ i ] == ' # ' : b [ i ] = b [ i ] for i in b : if a [ i ] == ' # ' : b . append ( b [ i ] ) else : b . append ( a [ i ] ) print ( ' ' . join ( map ( str , b ) ) ) NEW_LINE"],"references":["import syskek = \" \" bol = 1 for s in sys . stdin : ok = 0 for i in range ( len ( s ) ) : if s [ i ] == ' ▁ ' : continue if s [ i ] == ' # ' : ok = 1 else : ok = 0 break kekw = ( bol == 0 and ok == 0 ) for j in range ( len ( kek ) - kekw ) : if bol == 1 or kek [ j ] != ' ▁ ' : sys . stdout . write ( kek [ j ] ) kek = s bol = ok   for j in range ( len ( kek ) ) : if bol == 1 or kek [ j ] != ' ▁ ' : sys . stdout . write ( kek [ j ] ) NEW_LINE"],"bleu":0.10361735341982405,"rouge_l":0.3414834938667984}
{"id":475,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in range ( n ) : for j in range ( m ) : if a [ i ] [ j ] == a [ i ] [ j ] : c += 1 if a [ i ] [ j ] == a [ i ] [ j ] and b [ i ] [ j ] == a [ i ] [ j ] == 1 : c += 1 if a [ i ] [ j ] == b [ i ] [ j ] and a [ i ] [ j ] == 1 and a [ i ] [ j ] == a [ i ] [ j ] : c += 1 if a [ i ] [ j ] == 1 and b [ i ] [ j ] == 1 and a [ i ] [ j ] == 1 : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"references":["from sys import stdin , stdout n , m , k = map ( int , input ( ) . split ( ) ) l = [ [ 0 ] * m ] * n for i in range ( n ) : l [ i ] = list ( map ( int , stdin . readline ( ) . split ( ) ) ) t = [ [ 0 ] * 2 ] * ke = [ 0 ] * nc = [ 0 ] * m for i in range ( k ) : t0 , t1 = map ( int , stdin . readline ( ) . split ( ) ) e [ t0 - 1 ] -= 1 c [ t1 - 1 ] += 1 p = [ \" \" ] * nfor i in range ( n ) : for j in range ( m ) : e [ i ] = e [ i ] + c [ j ] * l [ i ] [ j ] p [ i ] = str ( e [ i ] ) stdout . write ( \" ▁ \" . join ( p ) ) NEW_LINE"],"bleu":0.3088618241547357,"rouge_l":0.4271103768389584}
{"id":476,"predictions":["n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) ) d = 0 for i in range ( n ) : if a [ i ] == 0 : d [ a [ i ] ] += 1 else : d [ a [ i ] ] += 1 dp [ a [ i ] ] -= 1 if b [ a [ i ] ] == 0 : dp [ a [ i ] ] = 1 if a [ i ] == 0 : dp [ a [ i ] ] += 1 else : dp [ i ] [ a [ i ] ] -= 1 else : dp [ i ] [ a [ i ] ] += 1 if a [ i ] == 1 : dp [ i ] [ a [ i ] ] = 1 else : dp [ i ] [ a [ i ] ] = 1 if a [ i ] == 0 : dp [ i ] [ a ] = 1 if a [ i ] == 1 : dp [ i ] [ a [ i ] = 1 else : break if a [ i ] == 0 : dp [ i ] [ a [ i ] ] = 1 if a [ i ] == 1 : dp [ i ] [ a [ i ] = 1 else : dp [ i ] [ a [ i ] ] = 1 if a [ i ] == 1 : print ( - 1 ) else : print ( 1 ) NEW_LINE"],"references":["c , d = [ int ( i ) for i in input ( ) . split ( \" ▁ \" ) ] n , m = [ int ( i ) for i in input ( ) . split ( \" ▁ \" ) ] k = int ( input ( ) )   s = n * m - ks = max ( s , 0 )   if c < d * n : stuff = s \/\/ n try1 = c * stuff + d * ( s - n * stuff ) try2 = c * ( stuff + 1 ) print ( min ( try1 , try2 ) ) else : print ( d * s ) NEW_LINE"],"bleu":0.07049631647077932,"rouge_l":0.22201123506606538}
{"id":477,"predictions":["t = int ( input ( ) ) for _ in range ( t ) : n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) ) c = 0 for i in range ( n ) : if a [ i ] [ 0 ] == a [ i ] [ 1 ] or b [ i ] [ 1 ] == b [ i ] : c += 1 if b [ i ] == b [ i ] : c += 1 else : print ( - 1 )   NEW_LINE"],"references":["a , b = map ( int , input ( ) . split ( ) )   s = input ( )   obs = b * ' # ' if obs in s : print ( \" NO \" ) else : print ( \" YES \" ) NEW_LINE"],"bleu":0.12551494125610946,"rouge_l":0.3404651162790698}
{"id":478,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["na , ma = map ( int , input ( ) . split ( ) ) a = [ list ( map ( int , input ( ) ) ) for _ in range ( na ) ] nb , mb = map ( int , input ( ) . split ( ) ) b = [ list ( map ( int , input ( ) ) ) for _ in range ( nb ) ]   best = 0 points = ( 0 , 0 ) for x in range ( - 50 , 51 ) : for y in range ( - 50 , 51 ) : ct = 0 for i in range ( na ) : if x + i < 0 : continue if x + i >= nb : break for j in range ( ma ) : if y + j < 0 : continue if y + j >= mb : break ct += a [ i ] [ j ] * b [ i + x ] [ j + y ] if ct >= best : best = ct points = ( x , y ) print ( points [ 0 ] , points [ 1 ] ) NEW_LINE"],"bleu":0.014311959731582148,"rouge_l":0.2173813081963444}
{"id":479,"predictions":["n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) ) print ( b ) NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l . sort ( ) print ( l [ ( - 1 ) * m ] ) NEW_LINE"],"bleu":0.3419235827514817,"rouge_l":0.5822320117474301}
{"id":480,"predictions":["n , bx , bx = map ( int , input ( ) . split ( ) ) NEW_LINE if n < bx : NEW_LINE INDENT print ( \" = \" ) NEW_LINE DEDENT elif nx > bx : NEW_LINE INDENT print ( \" < \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" = \" ) NEW_LINE DEDENT DEDENT"],"references":["n , m = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) first = int ( 0 ) second = int ( 0 ) now = int ( 1 ) for i in range ( len ( l ) - 1 , - 1 , - 1 ) : first = first + now * l [ i ] now = now * m   n1 , m1 = map ( int , input ( ) . split ( ) ) l1 = list ( map ( int , input ( ) . split ( ) ) )   now = 1 for i in range ( len ( l1 ) - 1 , - 1 , - 1 ) : second = second + now * l1 [ i ] now = now * m1   if second == first : print ( ' = ' ) elif second > first : print ( ' < ' ) else : print ( ' > ' ) NEW_LINE"],"bleu":0.038414043086731034,"rouge_l":0.2555661958343308}
{"id":481,"predictions":["n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) dist = 0 dist = 0 for i in range ( 1 , n + 1 ) : if a [ i ] % 2 == 0 : dist += 1 if dist >= 0 and dist >= 0 : dist += 1 dist -= 1 dist -= 1 print ( dist , dist ) NEW_LINE"],"references":["l = int ( input ( ) ) a = [ int ( bruh ) for bruh in input ( ) . split ( ) ]   a1 = sorted ( a )   cnt = 0 for x in range ( l ) : if a [ x ] != a1 [ x ] : cnt += 1   if cnt <= 2 : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.19030045541134127,"rouge_l":0.4412296564195299}
{"id":482,"predictions":["n , q = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) a . sort ( ) a = [ ] for i in range ( n ) : a . append ( a [ a [ i ] ] + a [ i ] ) a . append ( a [ i ] + a [ i ] ) a . sort ( ) for i in range ( n ) : a . append ( a [ i ] + a [ i ] ) a . sort ( ) if a [ i ] != a [ i ] : a . extend ( a [ i ] + a [ a [ i ] ] ) a [ a [ i ] ] = a [ i ] + a [ i ] else : a [ i ] = a [ i ] for i in range ( n ) : a [ i ] . append ( a [ i ] ) a . append ( a [ i ] ) a [ i ] . append ( a [ i ] )   for i in range ( n ) : print ( a [ i ] ) for i in range ( q ) : print ( a [ i ] ) NEW_LINE"],"references":["class CodeforcesTask226BSolution : def __init__ ( self ) : self . result = ' ' self . n = 0 self . piles = [ ] self . q = 0 self . variants = [ ]   def read_input ( self ) : self . n = int ( input ( ) ) self . piles = [ int ( x ) for x in input ( ) . split ( \" ▁ \" ) ] self . q = int ( input ( ) ) self . variants = [ int ( x ) for x in input ( ) . split ( \" ▁ \" ) ]   def process_task ( self ) : self . piles . sort ( reverse = True ) sums = [ 0 ] * self . n sums [ 0 ] = self . piles [ 0 ] for x in range ( self . n - 1 ) : sums [ x + 1 ] = self . piles [ x + 1 ] + sums [ x ] anwsers = { } results = [ ] for query in self . variants : if query in anwsers . keys ( ) : results . append ( anwsers [ query ] ) else : anwser = 0 factor = 1 k = 1 width = query x = 1 while x + width < self . n : anwser += ( sums [ x + width - 1 ] - sums [ x - 1 ] ) * factor factor += 1 x += width k += 1 width = query ** k anwser += ( sums [ - 1 ] - sums [ x - 1 ] ) * factor results . append ( anwser ) anwsers [ query ] = anwser self . result = \" ▁ \" . join ( [ str ( x ) for x in results ] )   def get_result ( self ) : return self . result     if __name__ == \" _ _ main _ _ \" : Solution = CodeforcesTask226BSolution ( ) Solution . read_input ( ) Solution . process_task ( ) print ( Solution . get_result ( ) ) NEW_LINE"],"bleu":0.0776784078017113,"rouge_l":0.3012035798786133}
{"id":483,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( b ) for i in b : if b [ i ] < b [ i ] : b [ i ] = b [ i ] else : b [ i ] = b [ i ] DEDENT"],"references":["def binaryToDecimal ( n ) : return int ( n , 2 ) s = input ( ) s = s . replace ( \" > \" , \"1000\" ) s = s . replace ( \" < \" , \"1001\" ) s = s . replace ( \" + \" , \"1010\" ) s = s . replace ( \" - \" , \"1011\" ) s = s . replace ( \" . \" , \"1100\" ) s = s . replace ( \" , \" , \"1101\" ) s = s . replace ( \" [ \" , \"1110\" ) s = s . replace ( \" ] \" , \"1111\" ) p = binaryToDecimal ( s ) ans = p % ( ( 10 ** 6 ) + 3 ) print ( ans ) NEW_LINE"],"bleu":0.029028401980772923,"rouge_l":0.25092554504319214}
{"id":484,"predictions":["def solve ( ) : n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n - 1 ) : if b [ a [ i ] ] != b [ a [ i ] ] : b [ a [ i ] ] = b [ a [ i ] ] else : a [ b [ i ] ] = b [ a [ i ] - 1 ] else : b [ a [ i ] ] = 1 b [ a [ i ] ] = 1 for i in range ( n - 1 , - 1 , - 1 ) : if a [ i ] [ a [ i ] ] == b [ i ] ] : b [ i ] = b [ i ] else : b [ i ] = b [ i ] for i in range ( n ) : if a [ i ] == b [ i ] : b [ i ] = b [ i ] else : b [ i ] = b [ i ] else : b [ i ] = b [ i ] for i in b [ i ] : b [ i ] = b [ i ] if a [ i ] == b [ i ] : b [ i ] = b [ i ] print ( ' { } ' . format ( b [ i ] , b [ i ] ) ) ) print ( ' { } ' . format ( b [ i ] ) ) NEW_LINE"],"references":["def gcd ( a , b ) : a , b = max ( a , b ) , min ( a , b ) while a % b != 0 : a %= b a , b = b , a return b   def gsd ( a , b ) : return a * b \/\/ gcd ( a , b )   n = int ( input ( ) ) m = list ( map ( int , input ( ) . split ( ) ) ) r = list ( map ( int , input ( ) . split ( ) ) ) x = m [ 0 ] for i in range ( 1 , n ) : x = gsd ( x , m [ i ] ) count = 0 for i in range ( x ) : for j in range ( n ) : if i % m [ j ] == r [ j ] : count += 1 breakprint ( count \/ x ) NEW_LINE"],"bleu":0.21133156701858039,"rouge_l":0.3576433576433576}
{"id":485,"predictions":["n , m , C , C = map ( int , input ( ) . split ( ) ) A = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ]   A = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ]   for i in range ( n ) : for j in range ( m ) :   if A [ i ] [ j ] % 2 == 0 : A [ i ] [ j ] = A [ i ] [ j ] - 1 A [ i ] [ j ] = ( A [ i ] [ j ] , A [ i ] [ j ] ) break else : A [ i ] [ j ] = A [ i ] [ j ] = n + 1 B [ i ] [ j ] = n + 1 for i in range ( n ) : print ( * A [ i ] [ j ] ) NEW_LINE"],"references":["n , a , b = map ( int , input ( ) . split ( ) ) if n > a * b : print ( - 1 ) else : arr = [ [ 0 ] * b for _ in range ( a ) ] x = 1 y = 2   for i in range ( a ) : for j in range ( b ) :   if ( i + j ) % 2 == 0 : if x <= n : arr [ i ] [ j ] = x x += 2 else : if y <= n : arr [ i ] [ j ] = y y += 2 NEW_LINE"],"bleu":0.238877969006701,"rouge_l":0.4528240989779452}
{"id":486,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n - 1 ) : if b [ a [ i ] ] == 1 : b [ a [ i ] ] = b [ a [ i ] ] = 1 for i in range ( n - 1 , - 1 , - 1 ) : if a [ i ] != 2 : b [ a [ i ] ] += 1 else : b [ a [ i ] -= 1 b [ i ] = 1 for i in range ( 1 , n + 1 ) : if b [ a [ i ] ] == 1 : b [ a [ i ] ] = 1 print ( \" YES \" ) NEW_LINE"],"references":["s = input ( ) t = input ( ) v = [ ' a ' , ' e ' , ' i ' , ' o ' , ' u ' ] if len ( s ) == len ( t ) : for i in range ( len ( s if len ( s ) < len ( t ) else t ) ) : if s [ i ] in v and t [ i ] in v : continue elif s [ i ] in v or t [ i ] in v : print ( \" NO \" ) exit ( ) else : continue print ( ' YES ' ) else : print ( ' NO ' ) NEW_LINE"],"bleu":0.09267900926532444,"rouge_l":0.3152808988764045}
{"id":487,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["import sysinput = sys . stdin . readlinefrom collections import defaultdict as dcfrom collections import Counterfrom bisect import bisect_right , bisect_leftimport mathfrom operator import itemgetterfrom heapq import heapify , heappop , heappushfrom queue import PriorityQueue as pqfor _ in range ( int ( input ( ) ) ) : n , d = map ( int , input ( ) . split ( ) ) f = 0 s = math . ceil ( math . sqrt ( d ) ) i = s while ( i > 0 and f == 0 ) : if i + math . ceil ( d \/ ( i + 1 ) ) <= n : f = 1 break i -= 1 if f or d <= n : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.046528505809734166,"rouge_l":0.2522665818355337}
{"id":488,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in range ( n ) : for j in range ( m ) : if a [ i ] [ j ] == a [ i ] [ j ] and b [ i ] [ j ] == ' . ' : c += 1 if a [ i ] [ j ] == ' . ' : c += 1 if a [ i ] [ j ] == ' . ' : c += 1 if a [ i ] [ j ] == ' . ' : c += 1 print ( c ) NEW_LINE"],"references":["  n = int ( input ( ) ) lis = list ( map ( int , input ( ) . split ( ) ) ) m = int ( input ( ) ) edges = [ ] for d in range ( m ) : edges . append ( list ( map ( int , input ( ) . split ( ) ) ) ) edges . sort ( key = lambda x : x [ 2 ] ) visited = [ ] count = 0 for i in range ( m ) : if edges [ i ] [ 1 ] not in visited : visited . append ( edges [ i ] [ 1 ] ) count += edges [ i ] [ 2 ]   if len ( visited ) == n - 1 : print ( count ) else : print ( - 1 ) NEW_LINE"],"bleu":0.36765152847756805,"rouge_l":0.48610811975016155}
{"id":489,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in range ( n ) : if b [ i ] % 2 == 0 : c += 1 if a [ i ] % 2 == 0 and b [ i ] == 0 : print ( 0 ) else : print ( - 1 ) NEW_LINE"],"references":["Into = str ( input ( ) ) NEW_LINE Into = list ( Into ) NEW_LINE hello = [ ' h ' , ' e ' , ' l ' , ' l ' , ' o ' ] NEW_LINE cur = 0 l NEW_LINE ist1 = [ ] NEW_LINE for i in Into : if NEW_LINE i == hello [ cur ] : list1 . append ( i ) NEW_LINE cur += 1 NEW_LINE if len ( list1 ) == 5 : breakif NEW_LINE list1 == hello : print ( ' YES ' ) else : print ( ' NO ' ) NEW_LINE"],"bleu":0.12240905806108038,"rouge_l":0.3571767684760247}
{"id":490,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) count = 0 for i in range ( n ) : count += a [ i ] count += 1 print ( count ) NEW_LINE"],"references":["n = int ( input ( ) ) m = int ( input ( ) ) l = [ ] for i in range ( n ) : l . append ( int ( input ( ) ) ) l . sort ( reverse = True ) s = 0 for i in range ( n ) : s += l [ i ] if s >= m : print ( i + 1 ) break NEW_LINE"],"bleu":0.24100384215166085,"rouge_l":0.5345807674088111}
{"id":491,"predictions":["n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) ) ans = 0 for i in range ( n ) : if b [ i ] < b [ i ] : ans += a [ i ] else : ans += a [ i ] print ( ans ) NEW_LINE"],"references":["n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) i = 0 while i < n and k > 0 and a [ i ] < 0 : a [ i ] = - 1 * a [ i ] i += 1 k -= 1 a = sorted ( a ) if k % 2 == 1 : a [ 0 ] = - 1 * a [ 0 ] print ( sum ( a ) ) NEW_LINE"],"bleu":0.4166509410941292,"rouge_l":0.5310119695321001}
{"id":492,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) cnt = 0 ans = 0 for i in range ( n ) : if a [ i ] == ' F ' : cnt += 1 if cnt % 2 == 0 : print ( ' No ' ) elif cnt % 2 == 0 : ans += 1 NEW_LINE"],"references":["n = int ( input ( ) ) S = input ( ) A = S . count ( \" SF \" ) B = S . count ( \" FS \" ) if A > B : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.07049328875536544,"rouge_l":0.3652694610778443}
{"id":493,"predictions":["n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l = [ ] for i in range ( n ) : if l [ i ] != l [ i ] : l [ i ] = l [ i ] breakif not l [ i ] : l . append ( l [ i ] ) l . append ( l [ i ] ) else : l . append ( l [ i ] ) l [ i ] . pop ( i ) l . append ( l [ i ] ) l . sort ( ) print ( \" \\n \" . join ( l ) ) NEW_LINE"],"references":["with open ( ' input . txt ' , ' r ' ) as f : fs = f . read ( ) . strip ( ) . split ( ' \\n ' )   n = [ int ( i ) for i in fs [ 1 ] ] c = - 1 i , ans = 0 , \" YES \" while i < len ( n ) : if n [ i ] == 1 : count = 0 while i + 1 < len ( n ) : if n [ i + 1 ] == 1 : break count += 1 i += 1 else : count = c if c == - 1 : c = count elif c != count : ans = \" NO \" break i += 1   with open ( ' output . txt ' , ' w ' ) as f : f . write ( ans ) NEW_LINE"],"bleu":0.10067052398755497,"rouge_l":0.2847932414406403}
{"id":494,"predictions":["n , m , a , b , d = [ int ( x ) for x in input ( ) . split ( ) ] arr = [ int ( x ) for x in input ( ) . split ( ) ]   arr = [ int ( x ) for x in input ( ) . split ( ) ] arr = [ int ( x ) for x in input ( ) . strip ( ) . split ( ) ] arr = [ int ( x ) for x in arr ]   for i in range ( m ) : arr [ i ] [ 0 ] , arr [ i ] [ 1 ] = arr [ i ] [ 0 ] , arr [ i ] [ 1 ] arr [ i ] [ 0 ] arr [ i ] [ 1 ] = ( arr [ i ] [ 0 ] , arr [ i ] ) arr [ i ] [ 1 ] = arr [ i ] [ 0 ] for i in range ( m ) : arr [ i ] [ 0 ] = arr [ i ] [ 0 ] = arr [ i ] + arr [ i ] [ 0 ] if ( arr [ i ] [ 0 ] < arr [ i ] [ 0 ] ) : arr [ i ] [ 1 ] = arr [ i ] [ 0 ] + arr [ i ] [ 1 ] = arr [ i ] [ 0 ] if ( arr [ i ] [ 1 ] == arr [ i ] [ 1 ] ) : arr [ i ] [ 1 ] = arr [ i ] [ 1 ] = max ( arr [ i ] , arr [ i ] [ 0 ] ) print ( arr [ i ] [ 0 ] ) NEW_LINE"],"references":["BigNum = 10 ** 20   n , m , a , d = map ( int , input ( ) . split ( ' ▁ ' ) ) ts = [ 0 ] + list ( map ( int , input ( ) . split ( ' ▁ ' ) ) ) + [ BigNum ]   def empsInRange ( l , r ) : em1 = l \/\/ a + 1 em2 = r \/\/ a return ( em1 , min ( em2 , n ) )   empDoorGroup = d \/\/ a + 1   def moveEmps ( emps , last ) : em1 , em2 = emps if em1 > em2 : return last , 0 if em1 * a <= last + d : gr1 = ( last + d - em1 * a ) \/\/ a em1 += 1 + gr1 if em1 > em2 : return last , 0   doorGroups = ( em2 - em1 + 1 + empDoorGroup - 1 ) \/\/ empDoorGroup last = ( em1 + empDoorGroup * ( doorGroups - 1 ) ) * a   return last , doorGroups   res = 0 last = - BigNum   for i in range ( 1 , len ( ts ) ) : NEW_LINE"],"bleu":0.08898914258454865,"rouge_l":0.25257214554579677}
{"id":495,"predictions":["n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) arr . sort ( ) if ( arr [ 0 ] [ 1 ] != arr [ 0 ] ) : print ( \" NO \" ) else : if ( arr [ 0 ] [ 0 ] != arr [ 0 ] [ 1 ] ) : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"references":["n = int ( input ( ) ) ans = \" YES \" num = 0 for i in range ( n ) : w , h = map ( int , input ( ) . split ( ) ) if i == 0 : num = max ( w , h ) else : if max ( w , h ) <= num : num = max ( w , h ) elif min ( w , h ) <= num : num = min ( w , h ) else : ans = \" NO \" print ( ans ) NEW_LINE"],"bleu":0.26916682777906237,"rouge_l":0.43364928909952605}
{"id":496,"predictions":["n , m , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in range ( n ) : if a [ i ] == a [ i ] : c += 1 if a [ i ] == a [ n - 1 ] : c += 1 print ( c ) NEW_LINE"],"references":["n , m , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) ans , result = 0 , 0 page , new_result = None , 1 for i in range ( m ) : if ( a [ i ] - result ) \/\/ k != page : ans += 1 result = new_result page = ( a [ i ] - result ) \/\/ k new_result += 1 print ( ans ) NEW_LINE"],"bleu":0.5137082772502337,"rouge_l":0.6570178391114102}
{"id":497,"predictions":["from collections import Counter NEW_LINE t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] != ' * ' : NEW_LINE INDENT b . append ( a [ i ] ) NEW_LINE DEDENT DEDENT DEDENT print ( b ) NEW_LINE DEDENT"],"references":["import math NEW_LINE cases = int ( input ( ) ) NEW_LINE for c in range ( cases ) : NEW_LINE INDENT length , k = map ( int , input ( ) . split ( ) ) NEW_LINE string = input ( ) NEW_LINE start = string . index ( ' * ' ) NEW_LINE end = length - 1 - string [ : : - 1 ] . index ( ' * ' ) NEW_LINE count = 1 NEW_LINE while start < end : NEW_LINE INDENT ind = start + k NEW_LINE if ind >= end : NEW_LINE INDENT count += 1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT while ind > start : NEW_LINE INDENT if string [ ind ] == ' * ' : NEW_LINE INDENT count += 1 NEW_LINE break NEW_LINE DEDENT ind -= 1 NEW_LINE DEDENT DEDENT start = ind NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT"],"bleu":0.24572126174178355,"rouge_l":0.5055453991468616}
{"id":498,"predictions":["n , a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if c * a <= b : NEW_LINE INDENT c += 1 NEW_LINE DEDENT else : NEW_LINE INDENT c += 1 NEW_LINE c = 0 NEW_LINE DEDENT DEDENT print ( n * c ) NEW_LINE"],"references":["n , a , b , c , T = map ( int , input ( ) . split ( ) ) ts = list ( map ( int , input ( ) . split ( ) ) ) ts . sort ( ) ans = 0 for t in ts : temp = - 10 ** 18 for u in range ( t , T + 1 ) : temp = max ( temp , c * ( u - t ) + a - b * ( u - t ) ) NEW_LINE"],"bleu":0.23263628013726673,"rouge_l":0.41295938104448743}
{"id":499,"predictions":["from collections import defaultdict , deque , Counterfrom sys import stdin , stdoutfrom heapq import heappush , heappopimport mathimport ioimport osimport bisect   NEW_LINE"],"references":["f = lambda : [ int ( q ) - 1 for q in input ( ) . split ( ) ] def g ( ) : for i in p : if h [ i ] == k and not v [ i ] : return i   r = range ( int ( input ( ) ) ) t , h = 1e9 , f ( ) u = [ set ( f ( ) [ 1 : ] ) for i in r ]   for k in ( 0 , 1 , 2 ) : p = list ( r ) d = - 1 v = [ q . copy ( ) for q in u ]   while p : i = g ( ) while i != None : d += 1 p . remove ( i ) for q in v : q . discard ( i ) i = g ( ) k = ( k + 1 ) % 3 d += 1   t = min ( d , t )   print ( t ) NEW_LINE"],"bleu":0.0000663305418031427,"rouge_l":0.0496742671009772}
{"id":500,"predictions":["n , m = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in range ( m ) : if l [ i ] == \" O \" : c += 1 if l [ i ] % 2 == 0 : print ( \" NO \" ) exit ( ) if l [ i % 2 ] % 2 == 1 : print ( \" NO \" ) exit ( ) else : if l [ i % 3 ] % 2 == 1 : print ( \" NO \" ) NEW_LINE"],"references":["def cc ( w , me , fe ) : global m , f if w . endswith ( me ) : m = True return True elif w . endswith ( fe ) : f = True return True else : return Falsedef ad ( w ) : return cc ( w , ' lios ' , ' liala ' ) def nn ( w ) : return cc ( w , ' etr ' , ' etra ' ) def vb ( w ) : return cc ( w , ' initis ' , ' inites ' ) s , n , m , f = input ( ) . split ( ) , False , False , False for w in s : if not n : if ad ( w ) or vb ( w ) and len ( s ) == 1 : pass elif nn ( w ) : n = True else : print ( \" NO \" ) exit ( ) elif not vb ( w ) : print ( \" NO \" ) exit ( ) print ( ' YES ' if len ( s ) == 1 or ( n and ( m ^ f ) ) else ' NO ' ) NEW_LINE"],"bleu":0.12789944238071332,"rouge_l":0.3044829534752307}
{"id":501,"predictions":["a = int ( input ( ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = set ( a ) b = set ( b ) c = set ( b ) c = set ( b ) c = set ( a ) b = set ( b ) c . add ( b ) c . add ( b ) c . add ( b ) print ( c ) NEW_LINE"],"references":["letters = list ( map ( str , input ( ) ) ) c = set ( ) for letter in letters : if letter . isalpha ( ) : c . add ( letter ) print ( len ( c ) ) NEW_LINE"],"bleu":0.23200808775231485,"rouge_l":0.48018458197611297}
{"id":502,"predictions":["n , m , k = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l1 = max ( l1 , l2 ) if ( l1 - l2 ) >= l1 and ( l1 - l2 ) ) : print ( ( ( l1 - l1 ) ) ) else : print ( ( l1 - l2 ) ) NEW_LINE"],"references":["if __name__ == \" _ _ main _ _ \" : a , b , c , d , k = map ( int , input ( ) . split ( ) ) start = max ( a , c ) end = min ( b , d ) ans = end - start if ans < 0 : ans = 0 elif k < start or k > end : ans = ans + 1 print ( ans ) NEW_LINE"],"bleu":0.23405284599436527,"rouge_l":0.3846623270951994}
{"id":503,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = [ 0 ] * nfor i in range ( n ) : if a [ i ] % 2 == 0 : a [ i ] += 1 if a [ i ] % 2 == 0 : b [ i ] = 1 else : b [ i ] = 1 for i in range ( n - 1 , - 1 , - 1 ) : if a [ i ] % 2 == 0 : if a [ i ] % 2 == 0 : b [ i ] -= 1 else : if a [ i ] == 0 : b [ i ] = 1 else : break if a [ i ] % 2 == 0 : b [ i ] = 1 else : print ( \" NO \" ) NEW_LINE"],"references":["def main ( ) : start , end , t = map ( int , input ( ) . split ( ) ) n = int ( input ( ) ) people = [ ] if n != 0 : people = list ( map ( int , input ( ) . split ( ) ) ) time = start ans = 1e16 answer = 0 for p in people : if p + t > end : break if p - 1 >= 0 : if ans > max ( 0 , time - ( p - 1 ) ) : ans = max ( 0 , time - ( p - 1 ) ) answer = p - 1   time = max ( time , p ) + t   if time + t > end : break   if time + t <= end : answer = time print ( answer )   main ( ) NEW_LINE"],"bleu":0.2240589187768447,"rouge_l":0.3759719324862507}
{"id":504,"predictions":["n = int ( input ( ) ) lst = [ ] for i in range ( len ( lst ) ) : if lst [ i ] == ' A ' : lst . append ( i ) continue lst = [ ] for i in range ( len ( lst ) ) : if lst [ i ] == ' A ' and lst [ i ] == ' A ' : lst . append ( lst [ i ] ) break elif ( lst [ i ] == ' A ' ) : lst . append ( lst [ i ] ) elif ( lst [ i ] == ' A ' and lst [ i ] == ' B ' and lst [ i ] == ' B ' ) : lst . append ( lst [ i ] ) elif ( lst [ i ] == ' B ' and lst [ i ] == ' B ' ) : lst . append ( lst [ i ] ) elif ( lst [ i ] == ' A ' and lst [ i ] == ' B ' and lst [ i ] == ' B ' and lst [ i ] == ' B ' and lst [ i ] == ' B ' ) : lst . append ( lst [ i ] == ' B ' ) elif ( lst [ i ] == ' B ' and lst [ i ] == ' B ' and lst [ i ] == ' B ' ) : lst . append ( lst [ i ] ) elif ( lst [ i ] == ' B ' and lst [ i ] == ' A ' and lst [ i ] == ' B ' ) : lst . append ( lst [ i ] ) elif ( lst [ i ] == ' B ' and lst [ i ] == ' B ' ) : lst . append ( lst [ i ] ) elif ( lst [ i ] == ' B ' and lst [ i ] == ' B ' and lst [ i ] == ' B ' ) : lst . append ( lst [ i ] ) elif ( lst [ i ] == ' A ' ) : lst . append ( lst [ i ] ) elif ( lst [ i ] == 0 ) : lst . append ( lst [ i ] ) elif ( lst [ i ] == ' B ' ) :"],"references":["s = input ( ) if ( s . find ( \" AB \" ) != - 1 and s . find ( \" BA \" ) != - 1 and ( s . find ( \" AB \" ) + 1 < s . rfind ( \" BA \" ) or s . find ( \" BA \" ) + 1 < s . rfind ( \" AB \" ) ) ) : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.011638743418180277,"rouge_l":0.15191404582325316}
{"id":505,"predictions":["n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) count = 0 count = 0 for i in l : if ( count > 0 ) : count += 1 else : count += 1 print ( count ) NEW_LINE"],"references":["c = 0 for i in range ( int ( input ( ) . split ( ) [ 0 ] ) ) : a = input ( ) . split ( ) while len ( a ) : if '1' in [ a . pop ( ) , a . pop ( ) ] : c += 1 print ( c ) NEW_LINE"],"bleu":0.2974529112534198,"rouge_l":0.44901853871319525}
{"id":506,"predictions":["n = int ( input ( ) ) print ( n \/\/ 2 ) NEW_LINE"],"references":["n = int ( input ( ) ) NEW_LINE print ( n \/\/ 2 * 3 ) NEW_LINE"],"bleu":0.6432188699036833,"rouge_l":0.8944281524926685}
{"id":507,"predictions":["print ( int ( input ( ) ) ) NEW_LINE"],"references":["print ( ( int ( input ( ) ) - 1 ) % 9 + 1 ) NEW_LINE"],"bleu":0.35161891656008354,"rouge_l":0.6792873051224945}
{"id":508,"predictions":["for _ in range ( int ( input ( ) ) ) : a , b = map ( int , input ( ) . split ( ) ) print ( a * b ) NEW_LINE"],"references":["a = int ( input ( ) ) for i in range ( a ) : c , d = map ( int , input ( ) . split ( ) ) c , d = min ( c , d ) , max ( c , d ) if ( 2 * c > d ) : print ( 2 * 2 * c * c ) else : print ( d * d ) NEW_LINE"],"bleu":0.18942653816248195,"rouge_l":0.4485294117647059}
{"id":509,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) cnt = 0 ans = 0 for i in range ( n ) : if a [ i ] == b [ i ] : ans += 1 if a [ i ] == b [ i ] : ans += 1 if a [ i ] == b [ i ] : ans += 1 print ( ans ) NEW_LINE"],"references":["n = int ( input ( ) )   a = [ int ( i ) for i in input ( ) . split ( ' ▁ ' ) ]   m = int ( input ( ) ) b = [ int ( i ) for i in input ( ) . split ( ' ▁ ' ) ]     store = { } vasya , petya = 0 , 0   max_stored = 0   for bi in b :   if bi not in store :   i = max_stored while bi not in store : store [ a [ i ] ] = ( i + 1 , n - i ) i += 1 max_stored = i vasya += store [ bi ] [ 0 ] petya += store [ bi ] [ 1 ]   print ( vasya , petya ) NEW_LINE"],"bleu":0.19590900448229398,"rouge_l":0.4272023590121636}
{"id":510,"predictions":["n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) print ( b ) NEW_LINE"],"references":["n = int ( input ( ) ) b = [ 0 ] * 26 result = 0 for i in range ( n ) : s = input ( ) b [ ord ( s [ 0 ] ) - 97 ] += 1 for i in b : result += ( ( i \/\/ 2 ) * ( i \/\/ 2 - 1 ) ) \/\/ 2 result += ( ( i - i \/\/ 2 ) * ( i - i \/\/ 2 - 1 ) ) \/\/ 2 print ( result ) NEW_LINE"],"bleu":0.09063182647674556,"rouge_l":0.35210774881931084}
{"id":511,"predictions":["n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) : if b [ i ] == 0 : b [ i ] = a [ i ] b [ i ] = 1 b [ i ] for i in range ( n ) : if a [ i ] [ a [ i ] ] != b [ i ] : b [ i ] += 1 b [ i ] a [ i ] += 1 if a [ i ] > b [ i ] : b [ i ] += 1 b [ i ] print ( a [ i ] ) NEW_LINE"],"references":["def find_company ( friends , d ) :   def mergesort_tuples ( tuples , index ) :   def merge ( A , B ) : i , j = 0 , 0 result = [ ] while i < len ( A ) and j < len ( B ) : if A [ i ] [ index ] < B [ j ] [ index ] : result . append ( A [ i ] ) i += 1 else : result . append ( B [ j ] ) j += 1   result += A [ i : ] result += B [ j : ]   return result   def divide ( tuples ) : if len ( tuples ) > 1 : middle = len ( tuples ) \/\/ 2 return merge ( divide ( tuples [ : middle ] ) , divide ( tuples [ middle : ] ) )   return tuples   return divide ( tuples )   def solve ( friends , d ) : friends = mergesort_tuples ( friends , 0 ) left_ptr = 0 right_ptr = 0 current_friendship = 0 max_friendship = 0 while right_ptr < len ( friends ) : if friends [ right_ptr ] [ 0 ] - friends [ left_ptr ] [ 0 ] < d : current_friendship += friends [ right_ptr ] [ 1 ] right_ptr += 1 else : max_friendship = max ( current_friendship , max_friendship ) current_friendship -= friends [ left_ptr ] [ 1 ] left_ptr += 1   max_friendship = max ( current_friendship , max_friendship )   return max_friendship   return solve ( friends , d )     if __name__ == \" _ _ main _ _ \" : n , d = [ int ( x ) for x in input ( ) . split ( ) ] friends = [ ] for _ in range ( n ) : friends . append ( tuple ( [ int ( x ) for x in input ( ) . split ( ) ] ) ) print ( find_company ( friends , d ) ) NEW_LINE"],"bleu":0.0659106588714448,"rouge_l":0.23806664665265687}
{"id":512,"predictions":["if __name__ == ' _ _ main _ _ ' : a , b = map ( int , input ( ) . split ( ) ) s = input ( ) l = [ ] for _ in range ( a ) : x , y = map ( int , input ( ) . split ( ) ) l . append ( x ) l . append ( y ) l . append ( x ) l . sort ( ) for i in range ( len ( l ) ) : if l [ i ] >= l [ i ] and l [ i ] [ 0 ] <= l [ i ] [ 1 ] and l [ i ] [ 1 ] > l [ i ] [ 1 ] : l [ i ] [ 1 ] -= 1 l [ i ] . append ( l [ i ] [ 1 ] , l [ i ] ) print ( * l ) NEW_LINE"],"references":["a , b = map ( int , input ( ) . split ( ) ) first = 0 second = 0 draw = 0 for i in range ( 1 , 7 ) : if abs ( a - i ) > abs ( b - i ) : second += 1 elif abs ( a - i ) < abs ( b - i ) : first += 1 else : draw += 1 print ( first , draw , second ) NEW_LINE"],"bleu":0.1510690685091839,"rouge_l":0.33980978260869565}
{"id":513,"predictions":["n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) print ( b * 2 ) NEW_LINE"],"references":["from math import ceil   for t in range ( int ( input ( ) ) ) : a , b , c , d = map ( int , input ( ) . split ( ) ) if b >= a : print ( b ) continue if c - d <= 0 : print ( - 1 ) continue s = b + ceil ( ( a - b ) \/ ( c - d ) ) * c if s > a : print ( s ) else : print ( - 1 ) NEW_LINE"],"bleu":0.1822060098623177,"rouge_l":0.418736119523521}
{"id":514,"predictions":["n = int ( input ( ) ) s = input ( ) count = 0 for i in range ( n ) : count += 1 print ( count ) NEW_LINE"],"references":["def read ( ) : return list ( map ( int , input ( ) . split ( ) ) )     [ n ] = read ( ) s = input ( ) indices = [ [ ] for i in range ( 26 ) ] for i in range ( n ) : indices [ ord ( s [ i ] ) - ord ( ' a ' ) ] += [ i + 1 ]     def run ( ) : s = input ( ) a = [ 0 for _ in range ( 26 ) ] for i in range ( len ( s ) ) : a [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 ans = 0 for i in range ( 26 ) : if a [ i ] >= 1 : ans = max ( ans , indices [ i ] [ a [ i ] - 1 ] ) return ans     [ t ] = read ( ) for i in range ( t ) : print ( run ( ) ) NEW_LINE"],"bleu":0.003965232889581755,"rouge_l":0.20869234668018244}
{"id":515,"predictions":["n = input ( ) l = 0 r = 0 for i in range ( n ) : if l [ i ] == ' Q ' : l += 1 else : l = 0 for i in range ( n ) : if l [ i ] == ' Q ' : l += 1 if l [ i ] == ' Q ' : l += 1 if l [ i ] == ' Q ' : l += 1 print ( l ) NEW_LINE"],"references":["s = input ( ) a , b , c = 0 , 0 , 0 for i in s : if i == \" Q \" : c += b a += 1 elif i == \" A \" : b += aprint ( c ) NEW_LINE"],"bleu":0.09316480593964135,"rouge_l":0.4166455856311662}
{"id":516,"predictions":["a , b , m , x , y = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l . sort ( ) if l [ x ] == l [ y ] : l [ x ] = l [ y ] - l [ x ] else : l [ y ] = l [ y ] - l [ x ] print ( l [ x ] ) NEW_LINE"],"references":["a , b , m , r = map ( int , input ( ) . split ( ) ) d = { } i = 1 while 1 : r = ( a * r + b ) % m ; t = d . get ( r , 0 ) if t : i -= t ; break d [ r ] = i ; i += 1 print ( ) print ( i ) NEW_LINE"],"bleu":0.23035569624065827,"rouge_l":0.4040522111825443}
{"id":517,"predictions":["a , b , c = map ( int , input ( ) . split ( ) ) print ( ' Yes ' if a < b else ' No ' ) NEW_LINE"],"references":["a , b , c = map ( int , input ( ) . split ( ) ) if abs ( a ) + abs ( b ) <= c : if ( c - ( abs ( a ) + abs ( b ) ) ) % 2 == 0 : print ( ' Yes ' ) else : print ( \" No \" ) else : print ( \" No \" ) NEW_LINE"],"bleu":0.19615721881144035,"rouge_l":0.4672340425531915}
{"id":518,"predictions":["n = int ( input ( ) ) arr1 = list ( map ( int , input ( ) . split ( ) ) ) arr2 = list ( map ( int , input ( ) . split ( ) ) ) arr1 = list ( map ( int , input ( ) . split ( ) ) ) arr2 = list ( map ( int , input ( ) . split ( ) ) ) arr2 = list ( arr1 ) ans = 0 for i in range ( 1 , n ) : if arr1 [ i ] == arr1 [ i ] : continue ans += 1 print ( ans ) NEW_LINE"],"references":["print ( 4 - len ( { * input ( ) . split ( ) } ) ) NEW_LINE"],"bleu":0.07031169077859689,"rouge_l":0.20567575161562235}
{"id":519,"predictions":["n = int ( input ( ) ) s = input ( ) ans = 0 for i in range ( 3 , len ( s ) ) : if i % n == 0 : ans += 1 print ( ans ) NEW_LINE"],"references":["n = int ( input ( ) ) s = input ( ) c = 0 for i in range ( n , len ( s ) , n ) : tmp = s [ i - 3 : i ] if ' a ' in tmp and ' b ' in tmp : continue c += 1 print ( c ) NEW_LINE"],"bleu":0.38291067009909496,"rouge_l":0.6339073634204276}
{"id":520,"predictions":["for _ in range ( int ( input ( ) ) ) : n , r = [ int ( x ) for x in input ( ) . split ( ) ] a = [ int ( x ) for x in input ( ) . split ( ) ] l = [ int ( x ) for x in input ( ) . split ( ) ] l = [ int ( x ) for x in input ( ) . split ( ) ] r = [ int ( x ) for x in input ( ) . split ( ) ] r = [ int ( x ) for x in input ( ) . split ( l ) ] r = [ int ( x ) for x in input ( ) . split ( ) ] r = [ int ( x ) for x in input ( ) . split ( ) ]   print ( r ) NEW_LINE"],"references":["n , Q = map ( int , input ( ) . strip ( ) . split ( ) )   s = input ( ) d = 1   for q in range ( Q ) : arr = [ 0 ] * ( 10 )   l , r = map ( int , input ( ) . strip ( ) . split ( ) )   su = \" \" for i in range ( l - 1 , r ) : su += s [ i ] su = list ( su ) i = 0 d = 1 NEW_LINE"],"bleu":0.14213222258612215,"rouge_l":0.3786420065872815}
{"id":521,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) ) for i in range ( n ) : if a [ i ] >= b [ i ] : b [ i ] = b [ i ] else : b [ i ] = b [ i ] for i in range ( n ) : if b [ i ] >= b [ i ] : b . append ( b [ i ] ) b . append ( b [ i ] ) else : b . append ( b [ i ] ) b . append ( b [ i ] ) b [ i ] . append ( b [ i ] ) print ( len ( b ) ) NEW_LINE"],"references":["''' import ▁ syssys . stdin = open ( \" input . txt \" , \" r \" ) sys . stdout = open ( \" output . txt \" , \" w \" ) '''   n = input ( ) ans = list ( ) while int ( n ) > 0 : s = \" \" for c in n : if c != '0' : s += '1' else : s += '0' n = str ( int ( n ) - int ( s ) ) ans . append ( s ) print ( len ( ans ) ) for a in ans : print ( a , end = \" ▁ \" ) NEW_LINE"],"bleu":0.07930719771847505,"rouge_l":0.30773542600896864}
{"id":522,"predictions":["n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in range ( n ) : if a [ i ] % 2 == 0 : c += 1 b [ i ] = 0 for i in range ( n ) : if a [ i ] % 2 == 0 : a [ i ] += 1 else : c += 1 print ( c ) NEW_LINE"],"references":["s = input ( ) t = input ( ) arr = [ x - 1 for x in map ( int , input ( ) . split ( ) ) ] l = 0 r = len ( s ) - 1     def check ( sa , sb ) : j = 0 for i in range ( len ( sb ) ) : while j < len ( sa ) and sa [ j ] != sb [ i ] : j += 1 if j == len ( sa ) : return False j += 1 return True     while l < r : mid = ( l + r + 1 ) >> 1 d = list ( s ) for i in range ( mid ) : d [ arr [ i ] ] = ' ' if check ( \" \" . join ( d ) , t ) : l = mid else : r = mid - 1 print ( l ) NEW_LINE"],"bleu":0.1857903466870224,"rouge_l":0.39488698705288566}
{"id":523,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = [ ] for i in range ( n ) : if a [ i ] % 2 == 0 : if a [ i ] % 2 == 0 and a [ i ] != 2 : c += 2 a [ i ] += 2 elif a [ i ] != 2 : b . append ( 2 ) else : b . append ( a [ i ] ) print ( len ( b ) ) NEW_LINE"],"references":["from __future__ import division , print_functionfrom collections import * from math import * from itertools import * from time import timeimport osimport sysfrom io import BytesIO , IOBase if sys . version_info [ 0 ] < 3 : from __builtin__ import xrange as range from future_builtins import ascii , filter , hex , map , oct , zip ''' Notes : k ▁ first ▁ latin ▁ lettersn ▁ = ▁ length ▁ of ▁ the ▁ string ▁ s '''   def main ( ) : s = input ( ) st = [ ] res = 0 for i in s : if i == \" ( \" : st . append ( i ) continue if not st and i == \" ) \" : continue if st [ - 1 ] == \" ( \" and i == \" ) \" : st . pop ( ) res += 2 else : continue print ( res ) \t     NEW_LINE"],"bleu":0.05022517416968134,"rouge_l":0.24359400998336106}
{"id":524,"predictions":["n , k = list ( map ( int , input ( ) . split ( ) ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) ) b . sort ( ) b = sum ( b ) b . sort ( ) b . sort ( ) print ( b ) NEW_LINE"],"references":["n , h , k = [ int ( i ) for i in input ( ) . split ( ) ] H = [ int ( i ) for i in input ( ) . split ( ) ]   curr = 0 t = 0   for i in range ( n ) : if curr + H [ i ] <= h : curr += H [ i ] t += curr \/\/ k curr %= k else : t += 1 curr = H [ i ] % k t += H [ i ] \/\/ k   if curr != 0 : t += 1 print ( t )   NEW_LINE"],"bleu":0.12463933349905765,"rouge_l":0.2783518990739498}
{"id":525,"predictions":["from collections import defaultdict , deque , Counterfrom sys import stdin , stdoutfrom heapq import heappush , heappopimport mathimport ioimport osimport bisect   NEW_LINE"],"references":["def solve ( ) : n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) x , ct , max_ct = 0 , 0 , 0 for i in range ( 0 , n ) : if ( x < l [ i ] ) : x = l [ i ] for i in range ( 0 , n ) : if ( l [ i ] == x ) : ct += 1 else : max_ct = max ( ct , max_ct ) ct = 0 max_ct = max ( ct , max_ct ) print ( max_ct ) solve ( ) NEW_LINE"],"bleu":0.0010719762081058183,"rouge_l":0.06244881244881245}
{"id":526,"predictions":["for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) flag = 0 flag = 0 flag = 0 for i in range ( 1 , n + 1 ) : if ( n % 4 != 0 ) : flag = a [ i % 4 ] + a [ i % 4 ] NEW_LINE"],"references":["s = input ( ) if s . count ( ' ! ' ) == 0 : print ( \"0 ▁ 0 ▁ 0 ▁ 0\" ) else : kr = kb = ky = kg = 0 l = len ( s ) k = [ 0 , 0 , 0 , 0 ] for i in range ( l ) : if s [ i ] != ' ! ' : j = i % 4 k [ j ] = s [ i ] for i in range ( l ) : if s [ i ] == ' ! ' : j = k [ i % 4 ] if j == ' R ' : kr += 1 if j == ' B ' : kb += 1 if j == ' Y ' : ky += 1 if j == ' G ' : kg += 1 print ( \" { } ▁ { } ▁ { } ▁ { } \" . format ( kr , kb , ky , kg ) )   NEW_LINE"],"bleu":0.060191926079800305,"rouge_l":0.24676375404530745}
{"id":527,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) ans = 0 for i in range ( n + m ) : if b [ i ] == a [ i ] : b += a [ i ] else : ans += b b print ( ans ) NEW_LINE"],"references":["a , b = map ( int , input ( ) . split ( \" ▁ \" ) ) m = min ( a , b ) n = max ( a , b ) c = 0 for i in range ( 1 , m + 1 ) : num = i % 5 if num == 0 : num = 5 init = abs ( 5 - num ) ans = ( abs ( n - init ) ) \/\/ 5 if num != 5 and num + n >= 5 : ans += 1 c += ansprint ( c ) NEW_LINE"],"bleu":0.2395369546558207,"rouge_l":0.4155175278285429}
{"id":528,"predictions":["from collections import defaultdict , deque , Counterfrom sys import stdin , stdoutfrom heapq import heappush , heappopimport mathimport ioimport osimport bisect   NEW_LINE"],"references":["import math   n = int ( input ( ) ) answer = \" \" if n < 3 : print ( 1 ) else : print ( 2 )   m = n + 2 numbers = [ True ] * mnumbers [ 0 ] = Falsenumbers [ 1 ] = False   for i in range ( 2 , int ( math . sqrt ( m ) ) + 1 ) : j = 0 while i ** 2 + j * i < m : numbers [ i ** 2 + j * i ] = False j += 1   for i in range ( 2 , m ) : if numbers [ i ] : answer += \"1 ▁ \" else : answer += \"2 ▁ \"   answer = answer [ : - 1 ] print ( answer ) NEW_LINE"],"bleu":0.00039352988795853964,"rouge_l":0.052083333333333336}
{"id":529,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in range ( n ) : if a [ i ] % 2 == 0 : b [ i ] = 1 if a [ i ] % 2 == 0 : b += 1 else : b [ i ] = 1 print ( a ) NEW_LINE"],"references":["n = int ( input ( ) ) arr = [ int ( num ) for num in input ( ) . split ( ) ] count = 0 for i in range ( 1 , len ( arr ) - 1 ) : if ( arr [ i - 1 ] < arr [ i ] and arr [ i + 1 ] < arr [ i ] or arr [ i - 1 ] > arr [ i ] and arr [ i + 1 ] > arr [ i ] ) : count += 1 print ( count ) NEW_LINE"],"bleu":0.225880281678941,"rouge_l":0.4563106796116505}
{"id":530,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["    n = int ( input ( ) )   t = list ( map ( int , input ( ) . split ( ) ) )     c = 0     a = [ ] p = 0 m = 0 while len ( a ) + len ( t ) != 0 : if len ( a ) == 0 and len ( t ) != 0 : while len ( t ) != 0 : x = t . pop ( 0 ) if x <= c : c += 1 else : a . append ( x ) m += 1 else :   while len ( a ) != 0 : v = a . pop ( ) if v <= c : c += 1 else : t = [ v ] + t m += 1           print ( m - 1 ) NEW_LINE"],"bleu":0.041298191728730414,"rouge_l":0.22634508348794063}
{"id":531,"predictions":["n = int ( input ( ) ) NEW_LINE t = [ int ( input ( ) ) for _ in range ( n ) ] NEW_LINE t [ 0 ] = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT t [ i ] = i NEW_LINE t [ i ] = i NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT t [ i ] = i NEW_LINE DEDENT print ( t [ 0 ] ) NEW_LINE"],"references":["import sys   def main ( ) : _ , s = sys . stdin . read ( ) . strip ( ) . split ( ' \\n ' ) t = s . replace ( ' ▁ ' , ' ' ) . rstrip ( s [ - 1 ] ) return len ( t ) print ( main ( ) ) NEW_LINE"],"bleu":0.07298417477443274,"rouge_l":0.26937513799955837}
{"id":532,"predictions":["t = int ( input ( ) ) for _ in range ( t ) : n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l . sort ( ) ans = 0 for i in l : if ( i % 2 != 0 ) : ans += 1 else : ans += 1 print ( ans ) NEW_LINE"],"references":["t = int ( input ( ) ) NEW_LINE ans = [ ]   for _ in range ( t ) : n = int ( input ( ) ) NEW_LINE a = list ( map ( str , input ( ) . split ( ) ) )   ind = [ ] NEW_LINE c = 0   for i in range ( len ( a ) ) : if NEW_LINE a [ i ] == '1' : ind . append ( i )   for i in range ( 0 , len ( ind ) - 1 ) : c += ind [ i + 1 ] - ind [ i ] - 1   ans . append ( c )   for i in ans : print ( i ) NEW_LINE"],"bleu":0.2876563682375669,"rouge_l":0.5290071770334928}
{"id":533,"predictions":["for _ in range ( int ( input ( ) ) ) : a , b , c = map ( int , input ( ) . split ( ) ) if a % c == 0 and b % c == 0 : print ( \" NO \" ) else : print ( \" YES \" ) NEW_LINE"],"references":["import sys , os , iofrom sys import stdinfrom math import log , gcd , ceilfrom collections import defaultdict , deque , Counterfrom heapq import heappush , heappop , heapifyfrom bisect import bisect_left , bisect_rightimport math def ii ( ) : return int ( input ( ) ) def li ( ) : return list ( map ( int , input ( ) . split ( ) ) ) if ( os . path . exists ( ' input . txt ' ) ) : sys . stdin = open ( \" input . txt \" , \" r \" ) ; sys . stdout = open ( \" output . txt \" , \" w \" ) else : input = io . BytesIO ( os . read ( 0 , os . fstat ( 0 ) . st_size ) ) . readline   no = \" No \" yes = \" Yes \"     def solve ( ) : a , b = li ( ) x = ( pow ( a * b , 1 \/ 3 ) ) x = round ( x ) if x * x * x == a * b and a % x == b % x == 0 : print ( yes ) else : print ( no )                 t = 1 t = int ( input ( ) ) for _ in range ( t ) : solve ( ) NEW_LINE"],"bleu":0.028663320614435873,"rouge_l":0.2232754575316753}
{"id":534,"predictions":["n , m = map ( int , input ( ) . split ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) arr = [ [ 0 ] * mfor i in range ( n ) : arr [ arr [ i ] ] = arr [ arr [ i ] ] = arr [ i ] [ arr [ i ] ] = arr [ arr [ i ] ] = arr [ i ] [ arr [ i ] ] = arr [ i ] [ arr [ i ] ] = arr [ i ] [ arr [ i ] ] = arr [ arr [ i ] [ 0 ] for i in arr : arr [ i ] [ arr [ i ] ] = arr [ arr [ i ] [ arr [ i ] ] = arr [ arr [ i ] [ arr [ i ] ] = arr [ arr [ i ] ] for i in arr [ i ] : arr [ arr [ i ] ] = arr [ i ] [ arr [ i ] = arr [ i ] [ arr [ i ] [ arr [ i ] ] = arr [ arr [ i ] ] = arr [ i ] [ arr [ i ] ] = max ( arr [ i ] , arr [ i ] ) print ( len ( arr ) ) NEW_LINE"],"references":["s1 = input ( ) s2 = input ( ) s3 = input ( )   if ( s1 == s3 [ : : - 1 ] ) and ( s2 [ 0 ] == s2 [ 2 ] ) : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.024598816230350772,"rouge_l":0.1890120367059945}
{"id":535,"predictions":["import itertools   n = int ( input ( ) ) a = [ int ( i ) for i in input ( ) . split ( ) ] b = [ int ( i ) for i in input ( ) . split ( ) ]   a = [ int ( i ) for i in input ( ) . split ( ) ] b = int ( a ) b = int ( b )   for i in range ( n ) : if a [ i ] == b [ i ] : b [ i ] = b [ i ] else : b [ i ] = a [ i ] else : b [ i ] = b [ i ] if a [ i ] == b [ i ] : b [ i ] = b [ i ] else : b [ i ] = b [ i ] else : b [ i ] . append ( b [ i ] )   print ( ' ' . join ( b ) ) ) NEW_LINE"],"references":["import sysinput = sys . stdin . readlinen = int ( input ( ) ) ar = list ( map ( int , input ( ) . split ( ) ) ) dic = { } li = [ ] for i in range ( n ) : xx = [ ] for j in range ( n - i ) : xx . append ( 0 ) li . append ( xx . copy ( ) ) for i in range ( n ) : for j in range ( n - i ) : if ( i == 0 ) : li [ i ] [ j ] = ar [ j ] else : li [ i ] [ j ] = li [ i - 1 ] [ j ] ^ li [ i - 1 ] [ j + 1 ] for i in range ( 1 , n ) : for j in range ( n - i ) : li [ i ] [ j ] = max ( li [ i ] [ j ] , li [ i - 1 ] [ j ] , li [ i - 1 ] [ j + 1 ] ) for _ in range ( int ( input ( ) ) ) : l , r = map ( int , input ( ) . split ( ) ) print ( li [ r - l ] [ l - 1 ] ) NEW_LINE"],"bleu":0.19025129868965093,"rouge_l":0.43714808043875675}
{"id":536,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in range ( n ) : if a [ i ] % b [ i ] % 2 == 0 : b [ i ] += 1 if b [ i ] % 2 == 0 : print ( \" NO \" ) else : print ( \" YES \" ) NEW_LINE"],"references":["def bs ( l , h ) : while l < h : m = ( l + h + 1 ) \/\/ 2 if a [ m ] < i : l = m else : h = m - 1 return l   n , m = map ( int , input ( ) . split ( ) ) c , t = map ( int , input ( ) . split ( ) ) l = c * ta = [ 0 ] for _ in range ( n - 1 ) : c , t = map ( int , input ( ) . split ( ) ) a . append ( l ) l = a [ - 1 ] + c * tb = map ( int , input ( ) . split ( ) ) for i in b : print ( bs ( 0 , n - 1 ) + 1 ) NEW_LINE"],"bleu":0.28560182646868176,"rouge_l":0.4032581749498288}
{"id":537,"predictions":["t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE count = 0 NEW_LINE count = 0 NEW_LINE for i in range ( 1 , n ) : if NEW_LINE a [ i ] == a [ i ] : count += 1 else : count += a [ i ] NEW_LINE count += 1 NEW_LINE if count % 2 == 1 : count += 1 NEW_LINE print ( count ) NEW_LINE"],"references":["n , k = map ( int , input ( ) . split ( ) ) A = [ int ( input ( ) ) for i in range ( n ) ] from collections import CounterC = Counter ( A ) B = [ ] ans = 0 r = 0 for k , v in C . items ( ) : if v % 2 == 0 : ans += v else : ans += v - 1 r += 1 ans += ( r + 1 ) \/\/ 2 print ( ans ) NEW_LINE"],"bleu":0.25596139404162194,"rouge_l":0.4071837253655436}
{"id":538,"predictions":["t = int ( input ( ) ) for _ in range ( t ) : n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l = list ( map ( int , input ( ) . split ( ) ) ) print ( - 1 ) NEW_LINE"],"references":["import sysfrom collections import dequeimport mathinput_ = lambda : sys . stdin . readline ( ) . strip ( \" \\n \" ) ii = lambda : int ( input_ ( ) ) il = lambda : list ( map ( int , input_ ( ) . split ( ) ) ) ilf = lambda : list ( map ( float , input_ ( ) . split ( ) ) ) ip = lambda : input_ ( ) fi = lambda : float ( input_ ( ) ) li = lambda : list ( input_ ( ) ) pr = lambda x : print ( x ) f = lambda : sys . stdout . flush ( )   a , b , c , d = il ( ) print ( 2 * ( a + b + d + 2 ) ) NEW_LINE"],"bleu":0.11945510737319764,"rouge_l":0.39354838709677425}
{"id":539,"predictions":["a , b = map ( int , input ( ) . split ( ) ) s = input ( ) ans = 0 for i in range ( len ( s ) ) : if s [ i ] == \" a \" : ans += 1 else : ans += 1 print ( ans ) NEW_LINE"],"references":["n = int ( input ( ) ) s = input ( ) t , i , count = ' ' , 0 , 0 while i < n - 1 : if s [ i : i + 2 ] != ' ab ' and s [ i : i + 2 ] != ' ba ' : t += ' ab ' count += 1 else : t += s [ i : i + 2 ] i += 2 print ( count ) print ( t ) NEW_LINE"],"bleu":0.16562511177205044,"rouge_l":0.3872196360558612}
{"id":540,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) cnt = 0 for i in range ( n ) : for j in range ( m ) : if a [ i ] [ j ] == a [ j ] : cnt += 1 if a [ i ] [ j ] == a [ i ] : cnt += 1 print ( 0 ) NEW_LINE"],"references":["n = int ( input ( ) ) x = 1 res = [ ] for i in range ( 64 ) : lo , hi = 0 , int ( 1e15 ) f = 0 ans = 0 while lo + 1 < hi : mid = ( lo + hi ) \/\/ 2 v = ( x - 1 ) * mid + ( mid * mid - mid ) \/\/ 2 if ( v == n ) : f = 1 ; ans = mid break ; if ( v > n ) : hi = mid else : lo = mid if ( f and ans % 2 == 1 ) : res . append ( ans * x ) x = x * 2 if ( len ( res ) == 0 ) : print ( - 1 ) ; exit ( 0 ) for x in res : print ( int ( x ) ) NEW_LINE"],"bleu":0.0727584963392841,"rouge_l":0.26453352086263476}
{"id":541,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in range ( n ) : if b [ i ] == ' X ' : c += 1 if a [ i ] == ' X ' or a [ i ] == ' X ' : c += 1 if a [ i ] == ' X ' : c += 1 if a [ i ] == ' X ' : print ( ' YES ' ) else : print ( ' NO ' ) NEW_LINE"],"references":["def checkhor ( x , y ) : c = 0 cy = y + 1 while ( cy < n and grid [ x ] [ cy ] == ' X ' ) : cy += 1 c += 1 if ( c >= 4 ) : return True cy = y - 1 while ( cy >= 0 and grid [ x ] [ cy ] == ' X ' ) : cy -= 1 c += 1 NEW_LINE"],"bleu":0.11967384296006928,"rouge_l":0.32125758059368015}
{"id":542,"predictions":["def STR ( ) : return list ( input ( ) ) def INT ( ) : return int ( input ( ) ) def MAP ( ) : return map ( int , input ( ) . split ( ) ) def MAP2 ( ) : return map ( float , input ( ) . split ( ) ) def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) def STRING ( ) : return input ( ) import stringimport sysfrom heapq import heappop , heappushfrom bisect import * from collections import deque , Counter , defaultdictfrom math import * from itertools import permutations , accumulatedx = [ - 1 , 1 , 0 , - 1 ] NEW_LINE"],"references":["import math   def gcd ( a , b ) : if a < b : a , b = b , a while a % b != 0 : a , b = b , a % b return b   n , k , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) )   r = { } for i in range ( n ) : e = a [ i ] % m if e in r : r [ e ] . append ( a [ i ] ) else : r [ e ] = [ a [ i ] ]   for key in r : if len ( r [ key ] ) >= k : print ( \" Yes \" ) for i in range ( k ) : print ( r [ key ] [ i ] , end = \" ▁ \" ) breakelse : print ( \" No \" )   NEW_LINE"],"bleu":0.1698343066417314,"rouge_l":0.28243583291394064}
{"id":543,"predictions":["n , m = map ( int , input ( ) . split ( ) ) arr = [ ] for i in range ( n ) : arr . append ( list ( map ( int , input ( ) . split ( ) ) ) ) arr . append ( arr ) arr = [ ] for i in range ( n ) : arr . append ( arr [ i ] ) print ( * arr ) NEW_LINE"],"references":["t = int ( input ( ) ) NEW_LINE for j in range ( t ) : n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : new = [ ] NEW_LINE if i % 2 == 0 : NEW_LINE INDENT new . append ( a [ count ] ) else : NEW_LINE new . append ( a [ n - count - 1 ] ) NEW_LINE DEDENT count += 1 NEW_LINE print ( * new , end = \" ▁ \" ) NEW_LINE"],"bleu":0.28166503149468247,"rouge_l":0.4805514524864598}
{"id":544,"predictions":["n , k = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l1 = list ( map ( int , input ( ) . split ( ) ) ) l2 = list ( map ( int , input ( ) . split ( ) ) ) l1 = list ( map ( int , input ( ) . split ( ) ) ) l2 = [ ] for i in range ( n ) : l1 . append ( l2 [ i ] ) for i in range ( n ) : if l2 [ i ] <= l2 [ i ] : l1 [ i ] -= 1 l2 [ i ] -= 1 l2 [ i ] -= 1 l2 . append ( l1 [ i ] ) print ( l1 , end = \" ▁ \" ) NEW_LINE"],"references":["n = int ( input ( ) ) i = 0 a = [ ] a = list ( map ( int , input ( ) . split ( ) ) ) a . sort ( ) while i < len ( a ) : print ( a [ i ] ) i = i + 1 NEW_LINE"],"bleu":0.15462134425937574,"rouge_l":0.4074617139133268}
{"id":545,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) count0 = 0 count0 = 0 for i in range ( n ) : if a [ i ] == a [ i ] : count0 += 1 else : count0 = a [ i ] + 1 ans = max ( ans , count1 ) print ( ans ) NEW_LINE"],"references":["n = int ( input ( ) ) L = [ ] R = [ ]   for _ in range ( n ) : l , r = map ( int , input ( ) . split ( ) ) L . append ( l ) R . append ( r )   l0 = L . count ( 0 ) l1 = n - l0   r0 = R . count ( 0 ) r1 = n - r0   t = 0   if r0 > r1 : t += r1else : t += r0   if l0 > l1 : t += l1else : t += l0   print ( t ) NEW_LINE"],"bleu":0.22857344037186114,"rouge_l":0.3692735602094241}
{"id":546,"predictions":["n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) count_one = [ 0 ] * nfor i in range ( n - 1 ) : if l [ i ] == l [ i ] : count_one [ i ] = count_one_recursionlimit ( len ( l ) ) if l [ i ] == 1 : continue else : count_one [ i ] = count_one_recursionlimit ( len ( l ) - 1 ) for i in range ( n - 1 , - 1 , - 1 ) : if l [ i ] == 1 : count_one_recursion [ i ] = count_one_recursionlimit ( count_one [ i ] + l [ i ] ) else : count_one_recursion [ i ] = count_one_recursionlimit ( len ( l ) - 1 ) for i in range ( n - 1 , - 1 , - 1 ) : if l [ i ] == 1 : count_one [ i ] = count_one_recursion_time [ i ] else : count_one_recursion [ i ] = count_zero_recursionlimit ( len ( l ) - 1 ) else : if l [ i ] > l [ i - 1 ] : continue NEW_LINE"],"references":["n = int ( input ( ) ) string = ' ' . join ( map ( str , input ( ) . split ( ) ) ) maxx = 0 for i in range ( n + 1 ) : maxx = max ( maxx , string [ : i ] . count ( '0' ) + string [ i : ] . count ( '1' ) ) print ( maxx ) NEW_LINE"],"bleu":0.12734399056424145,"rouge_l":0.39063284781516827}
{"id":547,"predictions":["n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) arr [ 0 ] = arr [ 0 ] + arr [ 1 ] NEW_LINE"],"references":["def search ( a , x ) : l , r = 0 , len ( a ) - 1 while l <= r : mid = ( l + r ) \/\/ 2 if a [ mid ] >= x and a [ mid - 1 ] < x : return mid elif a [ mid ] < x : l = mid + 1 else : r = mid - 1 return 0   n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( 1 , n ) : a [ i ] += a [ i - 1 ]   q = int ( input ( ) ) qu = list ( map ( int , input ( ) . split ( ) ) ) for x in qu : print ( search ( a , x ) + 1 ) NEW_LINE"],"bleu":0.10753278185625216,"rouge_l":0.3561439239646979}
{"id":548,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) cnt = 0 for i in range ( n ) : if a [ i ] == b [ a [ i ] ] : cnt += 1 print ( cnt ) NEW_LINE"],"references":["n = input ( ) print ( n + n [ : : - 1 ] ) NEW_LINE"],"bleu":0.05193434345342624,"rouge_l":0.2901307966706302}
{"id":549,"predictions":["for i in range ( int ( input ( ) ) ) : n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) c = 0 ans = 0 for i in range ( n - 1 ) : if a [ i ] % 2 == 1 : ans += 1 elif a [ i ] % 2 == 1 : ans += 1 elif a [ i ] == 1 : ans += 1 elif a [ i ] == 0 : ans += 1 print ( ans ) NEW_LINE"],"references":["for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) odd_str = 0 good_str = 0 bad_str = 0 for i in range ( n ) : s = input ( ) if len ( s ) % 2 != 0 : odd_str += 1 else : if s . count ( '0' ) % 2 == 0 and s . count ( '1' ) % 2 == 0 : good_str += 1 else : bad_str += 1 if bad_str % 2 != 0 and not odd_str : print ( n - 1 ) else : print ( n )       NEW_LINE"],"bleu":0.3480998061720833,"rouge_l":0.49229640498899485}
{"id":550,"predictions":["n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in range ( n ) : if a [ i ] % 2 == 0 : c = 1 break if a [ i ] % 2 == 0 : b += 1 if a [ i ] % 2 == 0 : print ( - 1 ) else : print ( 2 ) NEW_LINE"],"references":["n , k = [ int ( x ) for x in input ( ) . split ( ) ] cards = input ( )   frequency = { } for card in cards : if card not in frequency : frequency [ card ] = 0 frequency [ card ] += 1   frequent = list ( sorted ( frequency . values ( ) , reverse = True ) )     amount = frequent [ 0 ] leftover = max ( k - amount , 0 ) coins = ( k - leftover ) * ( k - leftover ) i = 1 while leftover > 0 and i >= 0 : temp = min ( leftover , frequent [ i ] ) coins = coins + ( temp * temp ) leftover = leftover - temp i += 1   print ( coins ) NEW_LINE"],"bleu":0.12561002042998046,"rouge_l":0.34736320871502846}
{"id":551,"predictions":["n , m = map ( int , input ( ) . split ( ) ) X = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] X = [ [ 0 ] * m for i in range ( n ) ] for i in range ( m ) : X [ i ] [ j ] = X [ i ] [ j ] + X [ i ] [ j ] = X [ i ] [ j ] + X [ i ] [ j ] if X [ i ] [ j ] == X [ i ] [ j ] and X [ i ] [ j ] == X [ i ] [ j ] : X [ i ] [ j ] = X [ i ] [ j ] + X [ i ] [ j ] else : X [ i ] [ j ] = X [ i ] [ j ] + X [ i ] [ j ] if X [ i ] [ j ] else : X [ i ] [ j ] = X [ i ] [ j ] + X [ i ] [ j ] = X [ i ] [ j ] + X [ i ] [ j ] else : X [ i ] [ j ] = X [ i ] [ j ] + X [ i ] [ j ] NEW_LINE"],"references":["from collections import defaultdictfrom bisect import bisect_leftp , n = defaultdict ( int ) , int ( input ( ) ) for i in range ( n ) : a , b = input ( ) . split ( ) p [ a ] = max ( p [ a ] , int ( b ) ) p , n = sorted ( ( b , a ) for a , b in p . items ( ) ) , len ( p ) t = [ 0 ] + [ bisect_left ( p , ( p [ n - 1 - n \/\/ k ] [ 0 ] , ' ' ) ) for k in [ 2 , 5 , 10 , 100 ] ] + [ n ] s = [ ' noob ' , ' random ' , ' average ' , ' hardcore ' , ' pro ' ] for i in range ( 1 , len ( t ) ) : d = s [ i - 1 ] for j in range ( t [ i - 1 ] , t [ i ] ) : p [ j ] = p [ j ] [ 1 ] + ' ▁ ' + dprint ( n ) print ( ' \\n ' . join ( p ) ) NEW_LINE"],"bleu":0.1440817743512321,"rouge_l":0.2995702885205647}
{"id":552,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) for i in b : if b [ i ] % 2 == 0 : b [ i ] = min ( a [ i ] , b [ i ] ) \/\/ 2 print ( b [ - 1 ] ) NEW_LINE"],"references":["n = int ( input ( ) ) x = [ ] for i in range ( n ) : a = list ( map ( int , input ( ) . split ( ) ) ) x . append ( a ) c = 1 x . sort ( key = lambda i : i [ 0 ] , reverse = True ) x . sort ( key = lambda i : i [ 1 ] , reverse = True ) p = 0 for i in x : c -= 1 c += i [ 1 ] p += i [ 0 ] if c == 0 : breakprint ( p ) NEW_LINE"],"bleu":0.23374492355132803,"rouge_l":0.4245939675174014}
{"id":553,"predictions":["n = int ( input ( ) ) NEW_LINE cnt = 0 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT a [ i ] = i NEW_LINE cnt += 1 NEW_LINE DEDENT j = 0 NEW_LINE for i in range ( 2 , 2000005 ) : NEW_LINE INDENT if i * a [ j ] < cnt and i * a [ j ] : NEW_LINE INDENT break NEW_LINE DEDENT j = i * a [ j ] NEW_LINE j += 1 NEW_LINE DEDENT j = 0 NEW_LINE while j < cnt and i * a [ j ] < 2000005 : NEW_LINE INDENT b [ i * a [ j ] ] = 1 NEW_LINE if i % a [ j ] == 0 : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE if i % a [ j ] == 0 : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT b [ i ] = k [ i - 1 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , 2000005 ) : NEW_LINE INDENT b [ i ] = 1 NEW_LINE b [ i ] += b [ i - 1 ] NEW_LINE DEDENT for j in range ( 0 , 2000005 ) : NEW_LINE INDENT if b [ j ] == u [ f - 1 - 1 ] : NEW_LINE INDENT break NEW_LINE DEDENT k [ i ] = k [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT k [ i ] = k [ i - 1 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , 2000005 ) : NEW_LINE INDENT if b [ i ] * q <= p [ i ] : NEW_LINE INDENT ans = i NEW_LINE DEDENT else : NEW_LINE INDENT k [ i ] = k [ i - 1 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , 1000005 ) : NEW_LINE INDENT if b [ i ] * q <= p [ i ] : NEW_LINE INDENT ans = i NEW_LINE DEDENT D"],"references":["def f ( s ) : for i in range ( len ( s ) \/\/ 2 + 1 ) : if s [ i ] != s [ - 1 - i ] : return False return Truez = 1200000 arr = [ 1 ] * zarr [ 0 ] , arr [ 1 ] = 0 , 0 for i in range ( 2 , 1096 ) : for j in range ( i * i , z , i ) : arr [ j ] = 0 cntpal = cntprm = 0 i = 1 p , q = map ( int , input ( ) . split ( ) ) k = p \/ qm = kwhile i < 1200000 : if f ( str ( i ) ) : cntpal += 1 if arr [ i ] : cntprm += 1 if cntprm \/ cntpal <= k : n = i i += 1 print ( n ) NEW_LINE"],"bleu":0.09401912153329366,"rouge_l":0.29255606592812755}
{"id":554,"predictions":["n , m , x , y = map ( int , input ( ) . split ( ) ) x = m - 2 * x + 2 * x = m - 2 * x + 2 * xif x > y + y : print ( x ) else : print ( y - 1 ) NEW_LINE"],"references":["def calculate_sides ( n , m ) : if n == 1 : return m \/\/ 2 if m % 2 == 0 else m \/\/ 2 + 1 if m == 1 : return n \/\/ 2 if n % 2 == 0 else n \/\/ 2 + 1   left , right , top , bottom = 0 , 0 , 0 , 0 top = m \/\/ 2 if m % 2 == 0 else m \/\/ 2 + 1 bottom = top if n % 2 != 0 else m \/\/ 2 n -= 2 m -= 2 left = n \/\/ 2 if m > 0 : right = left if m % 2 != 0 else n \/\/ 2 if n % 2 == 0 else n \/\/ 2 + 1   return top + bottom + left + right     n , m = list ( map ( int , input ( ) . split ( ) ) ) x = int ( input ( ) ) dict = dict ( ) times = 1 while n > 0 and m > 0 : quantity = calculate_sides ( n , m ) dict [ times ] = quantity times += 1 n -= 2 m -= 2 print ( dict [ x ] if x in dict else 0 ) NEW_LINE"],"bleu":0.020355494239442922,"rouge_l":0.19406814449917903}
{"id":555,"predictions":["t = int ( input ( ) ) for i in range ( t ) : n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( 1 , n ) : if b [ i ] != b [ i ] : b [ i ] ] = 1 else : b [ i ] = 1 for i in range ( n ) : if b [ i ] != b [ i ] : b [ i ] = b [ i ] if b [ i ] == b [ i ] : b [ i ] = b [ i ] else : b [ i ] = b [ i ] else : b [ i ] = 1 if b [ i ] == b [ i ] : b [ i ] = b [ i ] else : if b [ i ] == b [ i ] : b [ i ] : b [ i ] = b [ i ] else : b [ i ] = b [ i ] print ( \" NO \" ) NEW_LINE"],"references":["for t in range ( int ( input ( ) ) ) : n = int ( input ( ) ) s = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) k = - 1 for i in range ( 1 , 1025 ) : temp = [ ] for j in s : temp . append ( j ^ i ) if sorted ( temp ) == s : k = i break print ( k ) NEW_LINE"],"bleu":0.17462470146786682,"rouge_l":0.39443905593275136}
{"id":556,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = [ 0 ] * nfor i in range ( n ) : if a [ i ] % b [ i ] == 0 : a [ i ] = b [ i ] if a [ i ] != 0 : b [ i ] = b [ i ] else : b [ i ] = b [ i ] DEDENT if a [ i ] == 0 : b [ i ] = b [ i ] NEW_LINE"],"references":["if __name__ == ' _ _ main _ _ ' :   n = int ( input ( ) ) node = [ [ ] for _ in range ( n ) ] for i in range ( n - 1 ) : node [ int ( input ( ) ) - 1 ] . append ( i + 2 ) NEW_LINE"],"bleu":0.0893662160335747,"rouge_l":0.2524743566672665}
{"id":557,"predictions":["for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ali = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE li = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT ali . append ( ( ali [ i ] - ali [ i ] - ali [ i ] ) ) NEW_LINE DEDENT li . sort ( ) NEW_LINE for i in ali : NEW_LINE INDENT if ( ali [ i ] - ali [ i ] > li [ i ] ) : NEW_LINE INDENT ali [ i ] = min ( ali [ i ] - li [ i ] ) NEW_LINE DEDENT DEDENT DEDENT"],"references":["for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT sum1 = 0 NEW_LINE n = int ( input ( ) ) NEW_LINE x = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE y = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE x1 , y1 = min ( x ) , min ( y ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT sum1 = sum1 + max ( x [ j ] - x1 , y [ j ] - y1 ) NEW_LINE DEDENT print ( sum1 ) NEW_LINE DEDENT"],"bleu":0.44945832340349573,"rouge_l":0.6156951804188746}
{"id":558,"predictions":["n , m = map ( int , input ( ) . split ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) ans = [ 0 ] * nfor i in range ( n ) : for j in range ( m ) : if arr [ i ] [ j ] == 1 and arr [ i ] [ j ] == 1 : ans [ j ] += 1 arr [ i ] [ j ] = 1 if arr [ i ] [ j ] == 1 and arr [ i ] [ j ] == 1 : ans [ i ] [ j ] = 1 if arr [ i ] [ j ] == 1 and arr [ i ] [ j ] == 1 : ans [ i ] [ j ] = 1 if arr [ i ] [ j ] == 1 and arr [ i ] [ j ] == 1 : ans [ i ] [ j ] = 1 if arr [ i ] [ j ] == 1 and arr [ i ] [ j ] == 1 and arr [ i ] [ j ] == [ j ] and arr [ i ] [ j ] == 1 and arr [ i ] [ j ] == 1 ] and arr [ i ] [ j ] == [ j ] and arr [ i ] [ j ] == [ j ] and arr [ i ] [ j ] and arr [ i ] [ j ] == [ j ] and arr [ i ] [ j ] == [ j ] and arr [ i ] [ j ] == [ j ] : ans [ i ] [ j ] = 1 if arr [ i ] [ j ] == 1 : ans [ i ] = [ j ] for i in range ( n ) : if arr [ i ] [ j ] == 0 : ans [ i ] [ j ] = 1 if arr [ i ] [ j ] == 1 : ans [ j ] = 1 break else : ans [ i ] [ j ] = 1 if arr [ i ] [ j ] == 1 : print ( \" NO \" ) else : print ( \" YES \" ) else : if arr [ i ] [ j ] == \"1\" : print ( \" NO \" ) else : print ( \" NO \" ) NEW_LINE"],"references":["from math import gcddef getDays ( n ) : if n % 100 == 0 and n % 400 == 0 : return 366 if n % 100 != 0 and n % 4 == 0 : return 366 return 365 y = int ( input ( ) ) v = getDays ( y ) sd = getDays ( y ) while True : y += 1 if getDays ( y ) == v and sd % 7 == 0 : print ( y ) break sd += getDays ( y )           NEW_LINE"],"bleu":0.026028037312750007,"rouge_l":0.12866571409131114}
{"id":559,"predictions":["a , a , b , c , a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE H = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE H = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE ans = \" H \" NEW_LINE for i in range ( a ) : NEW_LINE INDENT if H [ i ] <= a [ i ] : NEW_LINE INDENT H [ i ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT H [ i ] -= 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["h1 , a1 , c1 = map ( int , input ( ) . split ( ) ) h2 , a2 = map ( int , input ( ) . split ( ) ) i = 1 ans = 0 ans1 = [ ] while h2 > 0 : if i == 1 : if h1 - a2 > 0 : h2 -= a1 ans1 . append ( \" STRIKE \" ) ans += 1 elif h2 - a1 <= 0 : h2 -= a1 ans1 . append ( \" STRIKE \" ) ans += 1 else : h1 += c1 ans1 . append ( \" HEAL \" ) ans += 1 i = 0 elif i == 0 : h1 -= a2 i = 1 print ( ans ) for x in ans1 : print ( x ) NEW_LINE"],"bleu":0.19315888252103022,"rouge_l":0.355486670799752}
{"id":560,"predictions":["a , b , b , m = map ( int , input ( ) . split ( ) ) print ( '1' , '9' ) NEW_LINE"],"references":["a , b , m = map ( int , input ( ) . split ( ) ) c = ( 10 ** 9 ) % mans = - 1 for x in range ( 1 , min ( a + 1 , m ) ) : z = ( x * c ) % m if z == 0 : continue if z + b < m : ans = x breakif ans == - 1 : print ( 2 ) else : s = str ( ans ) s = ( '0' * 9 + s ) [ - 9 : ] print ( 1 , s ) NEW_LINE"],"bleu":0.03263216481017044,"rouge_l":0.3003639477627917}
{"id":561,"predictions":["t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE b = [ ] NEW_LINE for i in range ( n ) : if NEW_LINE a [ i ] == a [ i ] : b . append ( a [ i ] ) NEW_LINE b . append ( b [ i ] ) NEW_LINE b . append ( a [ i ] ) NEW_LINE b . append ( b [ i ] ) NEW_LINE b . append ( b [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if b [ i ] : NEW_LINE INDENT b [ i ] = b [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT b [ i ] = b [ i ] NEW_LINE DEDENT DEDENT print ( a ) NEW_LINE"],"references":["for i in range ( int ( input ( ) ) ) : n = int ( input ( ) ) l1 = list ( map ( int , input ( ) . split ( ) ) ) l2 = l1 . copy ( ) l2 = l2 [ : : - 1 ] c = 0 for i in range ( n ) : if ( l1 . count ( l1 [ i ] ) > 1 ) : index = n - l2 . index ( l1 [ i ] ) - 1 if ( index != i + 1 and index != i ) : c = 1 if ( c == 1 ) : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.29880198282756065,"rouge_l":0.4846077457795432}
{"id":562,"predictions":["n , k = map ( int , input ( ) . split ( ) ) x = list ( map ( int , input ( ) . split ( ) ) ) y = list ( map ( int , input ( ) . split ( ) ) ) x . sort ( ) y = x [ y [ i ] - x [ i - 1 ] - x [ i ] , x [ i ] , y [ i ] , y [ i ] , x [ i ] , y [ i ] , y [ i ] , y [ i ] , x [ i ] , y [ i ] = y [ i ] , y [ i ] , y [ i ] , x [ i ] = y [ i ] , y [ i ] , x [ i ] , y [ i ] else : y [ i ] , y [ i ] = x [ i ] , y [ i ] = x [ i ] , y [ i ] if x [ i ] == y [ i ] and y [ i ] [ i ] == x : y [ i ] = y [ i ] , y [ i ] , y [ i ] = y [ i ] , y [ i ] = y [ i ] , x [ i ] if x [ i ] == y [ i ] and y [ i ] == y [ i ] : y [ i ] = y [ i ] = x [ i ] if x [ i ] == y [ i ] and y [ i ] == x : y [ i ] = y [ i ] else : y [ i ] = y [ i ] print ( \" Yes \" ) NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) s = [ list ( input ( ) ) for i in range ( n ) ] cnt = [ [ 0 ] * ( m + 1 ) for i in range ( n + 1 ) ] for i in range ( n ) : for j in range ( m ) : if s [ i ] [ j ] == \"1\" : cnt [ i + 1 ] [ j + 1 ] += 1 for i in range ( n ) : for j in range ( m + 1 ) : cnt [ i + 1 ] [ j ] += cnt [ i ] [ j ] for i in range ( n + 1 ) : for j in range ( m ) : cnt [ i ] [ j + 1 ] += cnt [ i ] [ j ] ans = 0 for l in range ( m + 1 ) : for r in range ( l + 1 , m + 1 ) : for u in range ( n + 1 ) : for d in range ( u + 1 , n + 1 ) : c = cnt [ d ] [ r ] - cnt [ d ] [ l ] - cnt [ u ] [ r ] + cnt [ u ] [ l ] if c == 0 : ans = max ( ans , ( r - l ) * 2 + ( d - u ) * 2 ) print ( ans ) NEW_LINE"],"bleu":0.09492068418618324,"rouge_l":0.31178293730629114}
{"id":563,"predictions":["for _ in range ( int ( input ( ) ) ) : n , k = map ( int , input ( ) . split ( ) ) NEW_LINE if n % 2 == 0 : NEW_LINE INDENT print ( 2 * k ) else : NEW_LINE DEDENT DEDENT"],"references":["import matht = int ( input ( ) ) for _ in range ( t ) : n , k = map ( int , input ( ) . split ( ) ) num = - 1 for i in range ( 2 , math . ceil ( math . sqrt ( n ) ) + 1 ) : if ( n % i == 0 ) : num = i break k -= 1 if ( num == - 1 ) : num = n NEW_LINE"],"bleu":0.27440251599820437,"rouge_l":0.47329986307622096}
{"id":564,"predictions":["import math   n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = math . sqrt ( m ** 2 + 1.5 ) ** 2 for _ in range ( n ) : for i in range ( m ) : for j in range ( m ) : if a [ i ] [ j ] == b [ i ] : b [ i ] = 1 else : b [ i ] = b [ j ] if b [ i ] [ j ] == 0 : b [ i ] = b [ i ] else : b [ j ] = b [ i ] if b [ i ] == b [ i ] : b [ i ] = b [ i ] else : b [ i ] = b [ i ] print ( \" . \" , end = \" ▁ \" ) print ( \" \" ) NEW_LINE"],"references":["import mathn , h = [ int ( x ) for x in input ( ) . split ( ' ▁ ' ) ] for i in range ( n - 1 ) : print ( math . sqrt ( ( i + 1 ) \/ ( n ) ) * h , end = \" ▁ \" ) print ( ) NEW_LINE"],"bleu":0.1359511061802812,"rouge_l":0.3185840707964602}
{"id":565,"predictions":["n , m = map ( int , input ( ) . split ( ) ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT print ( \" # \" ) NEW_LINE DEDENT"],"references":["a , b = map ( int , input ( ) . split ( ) ) s = ' # ' t = ' . ' flag = 0 for i in range ( a ) : if i % 2 == 0 : print ( s * b ) else : if flag == 0 : print ( t * ( b - 1 ) + s ) flag = 1 elif flag == 1 : print ( s + t * ( b - 1 ) ) flag = 0 NEW_LINE"],"bleu":0.09834655352535789,"rouge_l":0.3611176888467914}
{"id":566,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["a00 , a01 , a10 , a11 = list ( map ( int , input ( ) . split ( ) ) ) if sum ( [ a00 , a01 , a10 , a11 ] ) == 0 : print ( 0 ) exit ( 0 ) z , j = 0 , 0 if a01 != 0 or a10 != 0 : z = j = 1 while z * ( z - 1 ) \/\/ 2 < a00 : z += 1 while j * ( j - 1 ) \/\/ 2 < a11 : j += 1 if any ( [ z * ( z - 1 ) \/\/ 2 != a00 , j * ( j - 1 ) \/\/ 2 != a11 , z * j != a10 + a01 ] ) : print ( ' Impossible ' ) exit ( 0 ) n = z + jfor i in range ( n ) : if z > 0 and a01 >= j : print ( '0' , end = ' ' ) a01 -= j z -= 1 else : print ( '1' , end = ' ' ) j -= 1 NEW_LINE"],"bleu":0.013090444610263109,"rouge_l":0.17556061877923015}
{"id":567,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = [ ] for i in range ( n ) : a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) a . sort ( ) b = [ ] for i in range ( n ) : if a [ i ] [ 0 ] == b [ i ] [ 1 ] : b . append ( a [ i ] . index ( b [ 0 ] ) ) else : b . append ( b [ i ] . append ( b [ i ] . append ( b [ i ] . pop ( ) ) ) b . append ( b [ i ] . pop ( ) ) print ( len ( b ) ) print ( * len ( b ) ) NEW_LINE"],"references":["d = { ' polycarp ' : 1 } for _ in range ( int ( input ( ) ) ) : a , b , c = input ( ) . lower ( ) . split ( ) ; d [ a ] = d [ c ] + 1 print ( max ( d . values ( ) ) ) NEW_LINE"],"bleu":0.11591753204917708,"rouge_l":0.3335477645545191}
{"id":568,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in range ( n ) : if b [ a [ i ] ] not in a [ b [ i ] ] : b [ i ] ] += 1 b [ a [ i ] ] = 1 for i in range ( n ) : if b [ a [ i ] ] not in b [ a [ i ] ] : b [ b [ i ] ] = 1 b [ a [ i ] ] = 1 for i in range ( n ) : for j in range ( n ) : if b [ i ] [ j ] not in b [ a [ i ] ] ] : b [ i ] ] = 1 if b [ i ] [ b [ j ] ] : b [ i ] ] . append ( b [ i ] [ j ] ) else : b [ a [ i ] ] ] . append ( b [ i ] [ j ] ) else : b [ i ] . append ( b [ i ] [ j ] ) print ( len ( b ) ) NEW_LINE"],"references":["from collections import defaultdictfor _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) count = 0 l = [ ] for i in range ( n ) : l . append ( input ( ) . strip ( ) ) res = [ ] count = 0 for i in l : if i not in res : res . append ( i ) else : for j in range ( 10 ) : x = str ( j ) + i [ 1 : ] if x not in res and x not in l : count += 1 res . append ( x ) break print ( count ) for i in res : print ( i ) NEW_LINE"],"bleu":0.1715790189447759,"rouge_l":0.3516976297245356}
{"id":569,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in range ( n ) : for j in range ( m ) : if a [ i ] [ j ] == a [ i ] [ j ] : c += 1 if a [ i ] [ j ] == b [ i ] [ j ] : c += 1 if a [ i ] [ j ] == b [ i ] [ j ] : c += 1 if a [ i ] [ j ] == b [ i ] and b [ i ] [ j ] == b [ i ] [ j ] : c += 1 if a [ i ] [ j ] == b [ i ] [ j ] and b [ i ] [ j ] and b [ i ] [ j ] == b [ i ] [ j ] and b [ i ] [ j ] : print ( \" YES \" ) print ( \" NO \" ) NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) cur_pos = 0 for i in range ( n ) : a , b = map ( int , input ( ) . split ( ) ) if ( a <= cur_pos ) : if ( b > cur_pos ) : cur_pos = bif ( cur_pos == m ) : print ( ' YES ' ) else : print ( ' NO ' ) NEW_LINE"],"bleu":0.19039664317008292,"rouge_l":0.3581493658994833}
{"id":570,"predictions":["n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l . sort ( ) count = 0 for i in range ( len ( l ) - 1 ) : count += l [ i ] print ( count ) NEW_LINE"],"references":["num = int ( input ( ) ) a = [ i for i in range ( 45 ) ] s = 1 idx = 1 while True : idx += 1 if ( s + idx > num ) : n = idx - 1 break   s += idx   left = num - s   a [ n ] += leftprint ( n ) for i in range ( 1 , n + 1 ) : print ( a [ i ] , end = \" ▁ \" ) print ( ) NEW_LINE"],"bleu":0.14543735514098188,"rouge_l":0.3624257324318787}
{"id":571,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in range ( n ) : for j in range ( m ) : if a [ j ] [ j ] == a [ j ] [ a [ j ] ] : c += 1 if a [ j ] [ j ] == a [ j ] [ j ] : c += 1 if a [ j ] [ j ] == b [ a [ j ] ] : c += 1 if a [ j ] [ j ] == a [ j ] ] : print ( \" YES \" ) print ( \" NO \" ) NEW_LINE"],"references":["a , b = map ( int , input ( ) . split ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) a = a % 2 ans = 0 i = 1 for n in arr : x = n * a ** ( b - i ) ans += x i += 1     if ans % 2 == 1 : print ( \" odd \" ) else : print ( \" even \" ) NEW_LINE"],"bleu":0.24806263651114827,"rouge_l":0.47182320441988945}
{"id":572,"predictions":["def STR ( ) : return list ( input ( ) ) def INT ( ) : return int ( input ( ) ) def MAP ( ) : return map ( int , input ( ) . split ( ) ) def MAP2 ( ) : return map ( float , input ( ) . split ( ) ) def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) def STRING ( ) : return input ( ) ) import stringimport sysfrom heapq import heappop , heappushfrom bisect import * from collections import deque , Counter , defaultdictfrom math import * from itertools import permutations , accumulatedx = [ - 1 , 1 , 0 ] NEW_LINE"],"references":["lis = list ( map ( int , input ( ) . split ( ) ) ) sumall = 0 dic = { }   modulo = 1073741824 def number_of_divisors ( a ) : if a in dic : return dic [ a ] res , i , t = 1 , 2 , a while i * i <= a : r = 1 while a % i == 0 : a \/= i r += 1 res = ( res * r ) % modulo i += 1 if a > 1 : res = ( res * 2 ) % modulo dic [ t ] = res return res     for i in range ( 1 , lis [ 0 ] + 1 ) : for j in range ( 1 , lis [ 1 ] + 1 ) : for k in range ( 1 , lis [ 2 ] + 1 ) : s = ( i , j , k ) sumall += number_of_divisors ( i * j * k ) print ( sumall % modulo ) NEW_LINE"],"bleu":0.11552337388797448,"rouge_l":0.23449671219018714}
{"id":573,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in range ( n ) : for j in range ( m ) : if a [ i ] [ j ] == a [ i ] [ j ] : c += 1 if a [ i ] [ j ] == a [ i ] [ j ] : c += 1 print ( c ) NEW_LINE"],"references":["import sysinput = sys . stdin . readlinefrom collections import defaultdict as dcfrom collections import Counterfrom bisect import bisect_right , bisect_leftimport mathfrom operator import itemgetterfrom heapq import heapify , heappop , heappushfrom queue import PriorityQueue as pqn = int ( input ( ) ) s = input ( ) [ : - 1 ] if int ( s , 2 ) == 0 : print ( s ) else : c = 0 for i in s : if i == '0' : c += 1 l = [ '1' ] + [ '0' ] * c print ( ' ' . join ( l ) ) NEW_LINE"],"bleu":0.1344079093110585,"rouge_l":0.3530721282279608}
{"id":574,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) cnt = 0 for i in range ( n ) : if a [ i ] % 2 == 0 : if a [ i ] % 2 == 0 : if a [ i ] % 2 == 0 : a [ i ] = 1 elif a [ i ] == 1 : a [ i ] = 1 elif a [ i ] == 1 : a [ i ] += 1 elif a [ i ] == 1 : a [ i ] += 1 elif a [ i ] == 1 : print ( - 1 ) else : print ( - 1 ) NEW_LINE"],"references":["n , k = map ( int , input ( ) . split ( ) )     def printDivisors ( n ) : l = [ ] i = 1 while ( i * i < n ) : if ( n % i == 0 ) : l . append ( i ) if ( len ( l ) >= k ) : break i += 1   for i in range ( int ( n ** 0.5 ) , 0 , - 1 ) : if ( n % i == 0 ) : l . append ( n \/\/ i ) if ( len ( l ) >= k ) : break return l     res = printDivisors ( n ) if len ( res ) >= k : print ( res [ k - 1 ] ) else : print ( - 1 ) NEW_LINE"],"bleu":0.2553101109668943,"rouge_l":0.37909222061924314}
{"id":575,"predictions":["n = int ( input ( ) ) a = [ int ( x ) for x in input ( ) . split ( ) ] b = [ int ( x ) for x in input ( ) . split ( ) ] b = [ int ( x ) for x in input ( ) . split ( ) ]   for i in b : if b [ i ] != b [ i - 1 ] : b [ i ] = b [ i ]   if a [ i ] == b [ i ] : b [ i ] = b [ i ]   elif a [ i ] == b [ i ] : b [ i ] = b [ i ]   else : b [ i ] = b [ i ]   print ( \" NO \" ) NEW_LINE"],"references":["a = input ( ) b = input ( )   f = True   for i , j in zip ( a , b ) : if j > i : f = False break   if f : print ( b )   else : print ( - 1 ) NEW_LINE"],"bleu":0.042071849644222635,"rouge_l":0.3419761737911703}
{"id":576,"predictions":["n = int ( input ( ) ) arr = [ ] for i in range ( n ) : arr . append ( list ( map ( int , input ( ) . split ( ) ) ) ) arr . append ( arr ) arr = [ ] for i in range ( n ) : arr . append ( arr [ arr [ i ] ] ) arr . append ( arr [ i ] ) for i in range ( n ) : arr [ arr [ i ] ] = arr [ arr [ i ] [ 0 ] + arr [ i ] [ 1 ] = arr [ arr [ i ] [ 1 ] for i in range ( n ) : arr [ arr [ i ] ] = arr [ i ] [ 1 ] + arr [ arr [ i ] [ 0 ] = 1 for i in range ( n ) : arr [ i ] [ arr [ i ] ] = arr [ i ] [ arr [ i ] = arr [ i ] [ 0 ] for i in range ( n ) : arr [ arr [ i ] ] = arr [ i ] [ arr [ i ] ] = arr [ arr [ i ] ] = 1 arr [ arr [ i ] ] = 1 for i in range ( n ) : arr [ arr [ i ] [ arr [ i ] ] = arr [ i ] [ arr [ i ] ] = arr [ i ] [ arr [ i ] ] = 1 for i in range ( n ) : arr [ i ] [ arr [ i ] ] = arr [ arr [ i ] [ arr [ i ] ] = arr [ i ] [ arr [ i ] ] print ( ' NO ' ) NEW_LINE"],"references":["def xuli ( ) : n = int ( input ( ) ) s = input ( ) dem1 = 0 dem2 = 0 for i in s : if i != '0' : break dem1 += 1 for i in reversed ( s ) : if i != '1' : break dem2 += 1 for i in range ( dem1 + ( dem1 + dem2 < n ) ) : print ( 0 , end = ' ' ) for i in range ( dem2 ) : print ( 1 , end = ' ' ) print ( ' ' )       t = int ( input ( ) ) while ( t > 0 ) : xuli ( ) t -= 1 NEW_LINE"],"bleu":0.09127998857373587,"rouge_l":0.26115046314314627}
{"id":577,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) * 2 b = [ ] for i in range ( 0 , 5 ) : if b [ i ] [ 0 ] == a [ i ] : b . append ( b [ i ] , b [ i ] ) b . append ( b [ i ] ) b . append ( b [ i ] ) for i in b : if a [ i ] [ 1 ] == b [ i ] : b . append ( b [ i ] ) for i in b : print ( a [ i ] [ 0 ] ) NEW_LINE"],"references":["r = lambda : list ( map ( int , input ( ) . split ( ) ) ) arr = r ( ) w = r ( ) hacks = r ( )   score = 0 for i in range ( 5 ) : tot = ( 500 * ( i + 1 ) ) score += max ( 0.3 * tot , tot * ( 1 - arr [ i ] \/ 250 ) - 50 * w [ i ] )     score += 100 * hacks [ 0 ] score -= 50 * hacks [ 1 ]     print ( int ( score ) )   NEW_LINE"],"bleu":0.1993309195602904,"rouge_l":0.3963018490754622}
{"id":578,"predictions":["n , k = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l . sort ( ) if l [ - 1 ] > k : print ( - 1 ) else : print ( - 1 ) NEW_LINE"],"references":["n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) flag = 0 for i in range ( n ) : for j in range ( n ) : if ( i == j ) : continue for k in range ( n ) : if ( i == k or j == k ) : continue if ( arr [ i ] == arr [ j ] + arr [ k ] ) : flag = 1 print ( i + 1 , j + 1 , k + 1 ) break if ( flag ) : break if ( flag ) : breakif ( flag == 0 ) : print ( - 1 ) NEW_LINE"],"bleu":0.1374575735722541,"rouge_l":0.40003198976327575}
{"id":579,"predictions":["n , k = [ int ( x ) for x in input ( ) . split ( ) ] a = [ int ( x ) for x in input ( ) . split ( ) ] b = [ int ( x ) for x in input ( ) . split ( ) ] c = 0 cnt = 0 for i in range ( k ) : cnt += abs ( a [ i ] - a [ i ] ) + abs ( a [ i ] - b [ i ] ) + abs ( a [ i ] - a [ i ] ) + abs ( a [ i ] - a [ i ] ) ) print ( cnt ) NEW_LINE"],"references":["n , k = map ( int , input ( ) . split ( ) ) group = list ( map ( int , input ( ) . split ( ) ) ) available = [ [ k , 1 ] for i in range ( k + 1 ) ] center = ( k + 1 ) \/\/ 2 def calc ( center , row , col , num ) : end_col = col + num - 1 distance = abs ( center - row ) * num if col >= center : distance += ( col - center ) * num + ( num - 1 ) * num \/\/ 2 elif end_col <= center : distance += ( center - end_col ) * num + ( num - 1 ) * num \/\/ 2 else : distance += ( center - col ) * ( center - col + 1 ) \/\/ 2 + ( end_col - center ) * ( end_col - center + 1 ) \/\/ 2 return distancefor m in group : close , best_row , best_col = 10 ** 9 , - 1 , - 1 for row in range ( 1 , k + 1 ) : col = 0 if available [ row ] [ 0 ] < m and k - available [ row ] [ 1 ] + 1 < m : continue if available [ row ] [ 0 ] == k : col = center - m \/\/ 2 elif center - available [ row ] [ 0 ] <= available [ row ] [ 1 ] - center : col = available [ row ] [ 0 ] - m + 1 else : col = available [ row ] [ 1 ] distance = calc ( center , row , col , m ) if distance < close : close = distance best_row = row best_col = col if close == 10 ** 9 : print ( - 1 ) else : print ( best_row , best_col , best_col + m - 1 ) available [ best_row ] [ 0 ] = min ( available [ best_row ] [ 0 ] , best_col - 1 ) available [ best_row ] [ 1 ] = max ( available [ best_row ] [ 1 ] , best_col + m ) NEW_LINE"],"bleu":0.028108872745160534,"rouge_l":0.22775575851571028}
{"id":580,"predictions":["n = int ( input ( ) ) print ( n \/\/ 2 + 1 ) NEW_LINE"],"references":["def main ( ) : n = int ( input ( ) ) count = 0 for i in range ( 1 , n \/\/ 2 + 1 ) : if n % i == 0 : count += 1 print ( count )     if __name__ == ' _ _ main _ _ ' : main ( ) NEW_LINE"],"bleu":0.06566043188494372,"rouge_l":0.37237695536054943}
{"id":581,"predictions":["for i in range ( int ( input ( ) ) ) : n , x , y = map ( int , input ( ) . split ( ) ) NEW_LINE ali = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ali = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ali . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in ali : NEW_LINE INDENT ali [ i ] = ( ali [ i ] - ali [ i - 1 ] + 1 ) * ( ali [ i ] + 1 ) NEW_LINE DEDENT print ( ans ) NEW_LINE"],"references":["I = input NEW_LINE exec ( int ( I ( ) ) * ' n = int ( I ( ) ) ; k , m = ( 1 + x [ n > > 1 ] - x [ n - 1 > > 1 ] for ▁ x ▁ in ▁ map ( sorted , zip ( * ( map ( int , I ( ) . split ( ) ) for ▁ _ ▁ in [ 0 ] * n ) ) ) ) ; print ( k * m ) ; ' ) NEW_LINE"],"bleu":0.17138888751556683,"rouge_l":0.38165725621852586}
{"id":582,"predictions":["n , m = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l . sort ( ) ans = 0 for i in range ( n ) : for j in range ( m ) : if l [ i ] [ j ] == ' C ' : ans += 1 if l [ i ] == ' C ' : ans += 1 print ( ans ) NEW_LINE"],"references":["def fact ( n ) : if n <= 1 : return 1 else : return n * fact ( n - 1 )   def c ( n , r ) : return fact ( n ) \/\/ ( fact ( r ) * fact ( n - r ) )   n = int ( input ( ) ) arr = [ ] h = 0 for _ in range ( n ) : arr . append ( list ( input ( ) ) ) for i in arr : if i . count ( \" C \" ) >= 2 : h += c ( i . count ( \" C \" ) , 2 ) arr = list ( map ( list , zip ( * arr ) ) )   for i in arr : if i . count ( \" C \" ) >= 2 : h += c ( i . count ( \" C \" ) , 2 ) print ( h ) NEW_LINE"],"bleu":0.09743724347500156,"rouge_l":0.2881776308019369}
{"id":583,"predictions":["n , a , b = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) for i in b : if b [ i ] == b [ i ] : b [ i ] = b [ i ] else : b [ i ] = b [ i ] for i in b : if b [ i ] == b [ i ] : b [ i ] = b [ i ] else : b [ i ] = b [ i ] if b [ i ] != b [ i ] : b [ i ] = b [ i ] else : b [ i ] = b [ i ] print ( b [ i ] ) NEW_LINE"],"references":["from collections import defaultdict   n = int ( input ( ) ) p = list ( map ( int , input ( ) . split ( ) ) ) s = list ( map ( int , input ( ) . split ( ) ) )   clds , pars = defaultdict ( list ) , [ 0 ] * ( n + 1 ) for i in range ( n - 1 ) : cur , par = i + 2 , p [ i ] clds [ p [ i ] ] . append ( cur ) pars [ cur ] = par   ans , ok = s [ 0 ] , Truei , q = 0 , [ 1 ] while i < len ( q ) : cur = q [ i ] i += 1 par_v = s [ pars [ cur ] - 1 ] if cur in clds : mmin , summ , k = float ( ' inf ' ) , 0 , 0 for item in clds [ cur ] : mmin = min ( mmin , s [ item - 1 ] ) summ += s [ item - 1 ] k += 1 q . append ( item ) if s [ cur - 1 ] != - 1 : continue if mmin < par_v : ok = False break ans -= par_v ans += ( summ - ( k - 1 ) * mmin ) if ok : print ( ans ) else : print ( - 1 ) NEW_LINE"],"bleu":0.19371509393575384,"rouge_l":0.3778106907230375}
{"id":584,"predictions":["for i in range ( int ( input ( ) ) ) : n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) flag = Falsefor i in range ( n ) : if a [ i ] == b [ i ] : flag = False breakif flag : if a [ i ] == b [ i ] : flag = False breakif flag : print ( - 1 ) NEW_LINE"],"references":["for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) ans = \" YES \" s = set ( ) for i in range ( n ) : if ( b [ i ] > a [ i ] and ( 1 not in s ) or b [ i ] < a [ i ] and ( - 1 not in s ) ) : ans = \" NO \" break s . add ( a [ i ] ) print ( ans ) NEW_LINE"],"bleu":0.5470310493748171,"rouge_l":0.6813785587794579}
{"id":585,"predictions":["n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) cnt = 0 cnt = 0 for i in range ( n ) : if a [ i ] % 2 == 0 and cnt [ i ] == 0 and a [ i ] == 1 : cnt += 1 elif a [ i ] % 2 == 0 and cnt [ i ] != 0 : cnt += 1 elif a [ i ] == 1 : cnt [ i ] += 1 elif a [ i ] % 2 == 0 and a [ i ] == 1 : cnt += 1 else : if a [ i ] % 2 == 0 and b [ i ] == 1 : cnt += 1 elif a [ i ] % 2 == 0 and b [ i ] == 0 : cnt += 1 elif a [ i ] == 0 and b [ i ] == 1 : cnt += 1 if cnt == 1 : print ( - 1 ) else : print ( - 1 ) NEW_LINE"],"references":["def check ( txt : str ) -> bool : ln = len ( txt ) if ln == 0 or ln > 16 : return False for item in txt : if not ( ' a ' <= item <= ' z ' or ' A ' <= item <= ' Z ' or '0' <= item <= '9' or item == ' _ ' ) : return False return True     def checkHost ( hostName : str ) -> bool : hostLen = len ( hostName ) if hostLen == 0 or hostLen > 32 : return False for token in hostName . split ( ' . ' ) : if not check ( token ) : return False return True     mail = input ( ) isUser , isHost , isRes = False , False , Falseif ' @ ' in mail : atIndex = mail . index ( ' @ ' ) slashInd = mail . index ( ' \/ ' ) if ' \/ ' in mail else - 1 userName = mail [ : atIndex ] isUser = check ( userName ) hostName = mail [ atIndex + 1 : slashInd ] if slashInd != - 1 else mail [ atIndex + 1 : ] isHost = checkHost ( hostName ) if slashInd == - 1 : isRes = True else : resource = mail [ slashInd + 1 : ] isRes = check ( resource ) ''' if ▁ isUser ▁ and ▁ isHost ▁ and ▁ isRes : ▁ ▁ ▁ ▁ print ( ' YES ' ) else : ▁ ▁ ▁ ▁ print ( ' NO ' ) ''' print ( ' YES ' if isUser and isHost and isRes else ' NO ' ) NEW_LINE"],"bleu":0.03315307022343093,"rouge_l":0.21701527326258968}
{"id":586,"predictions":["for _ in range ( int ( input ( ) ) ) : n , m , x , y = map ( int , input ( ) . split ( ) ) l = min ( ( x , y ) ) print ( max ( l ) ) NEW_LINE"],"references":["for _ in range ( int ( input ( ) ) ) : x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) )   if x1 == x2 : print ( abs ( y2 - y1 ) )   elif y1 == y2 : print ( abs ( x2 - x1 ) )   else : print ( abs ( x2 - x1 ) + 2 + abs ( y2 - y1 ) ) NEW_LINE"],"bleu":0.29823204740574794,"rouge_l":0.5487889273356401}
{"id":587,"predictions":["a , b , c , d = map ( int , input ( ) . split ( ) ) if a == b : print ( ' Pr ' ) else : print ( ' Pr ' ) NEW_LINE"],"references":["oro_infinito = False   datos = input ( ) . split ( ) NEW_LINE a = int ( datos [ 0 ] ) NEW_LINE b = int ( datos [ 1 ] ) NEW_LINE c = int ( datos [ 2 ] ) NEW_LINE d = int ( datos [ 3 ] ) NEW_LINE e = int ( datos [ 4 ] ) NEW_LINE f = int ( datos [ 5 ] )   if a != 0 and b != 0 and c != 0 and d != 0 and e != 0 and f != 0 : if NEW_LINE ( b \/ a ) * ( d \/ c ) * ( f \/ e ) > 1 : oro_infinito = Trueelse : if c == 0 and d > 0 : NEW_LINE INDENT oro_infinito = True elif a == 0 and b > 0 and c > 0 and d > 0 : NEW_LINE oro_infinito = True elif e == 0 and f > 0 and a > 0 and b > 0 and c > 0 and d > 0 : NEW_LINE oro_infinito = True   if oro_infinito : NEW_LINE print ( ' Ron ' ) else : NEW_LINE print ( ' Hermione ' ) NEW_LINE DEDENT"],"bleu":0.005649376452113176,"rouge_l":0.21288971614704516}
{"id":588,"predictions":["n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l . sort ( ) if ( l [ 0 ] == 0 ) : print ( - 1 ) else : print ( - 1 ) NEW_LINE"],"references":["n = int ( input ( ) ) if n % 2 == 0 : print ( n \/\/ 2 ) else : print ( ( n \/\/ 2 + 1 ) * ( - 1 ) )   NEW_LINE"],"bleu":0.3149131875182791,"rouge_l":0.5074141048824593}
{"id":589,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) cnt = 0 ans = 0 for i in range ( n ) : if b [ i ] % 2 == 0 : ans += a [ i ] else : ans += b [ i ] print ( ans ) NEW_LINE"],"references":["m = input ( ) l = list ( m ) s = list ( set ( l ) ) z = 0   if ( m [ 0 ] == '4' ) : z = 1 elif ( '444' in m ) : z = 1 for i in s : if ( i == '4' or i == '1' ) : pass else : z = 1 break   if ( z == 1 ) : print ( \" NO \" ) else : print ( \" YES \" ) NEW_LINE"],"bleu":0.08589881739214175,"rouge_l":0.35665996711127357}
{"id":590,"predictions":["from collections import defaultdict , deque , Counterfrom sys import stdin , stdoutfrom heapq import heappush , heappopimport mathimport ioimport osimport bisect   NEW_LINE"],"references":["a = [ i for i in input ( ) ] b = [ i for i in input ( ) ]   ab = [ i for i in input ( ) ]   c = a + b   ab . sort ( ) c . sort ( )   if ab == c : print ( ' YES ' ) else : print ( ' NO ' ) NEW_LINE"],"bleu":0.007480069629142724,"rouge_l":0.038220551378446106}
{"id":591,"predictions":["n , m = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l . sort ( ) print ( l ) NEW_LINE"],"references":["def equal ( a , b ) : for i in range ( len ( a ) ) : if a [ i ] != b [ i ] and a [ i ] != \" * \" and b [ i ] != \" * \" : return False return True   string , k , best = input ( ) . strip ( ) , int ( input ( ) ) , 0 string += \" * \" * kfor i in range ( len ( string ) + 1 ) : for j in range ( i + 1 , len ( string ) + 1 ) : if not ( j - i ) % 2 : if equal ( string [ i : ( i + j ) \/\/ 2 ] , string [ ( i + j ) \/\/ 2 : j ] ) : best = max ( best , j - i ) print ( best ) NEW_LINE"],"bleu":0.03801450464778481,"rouge_l":0.2624984179217821}
{"id":592,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) res = 0 for j in range ( n - 2 , - 1 , - 1 ) : if a [ j ] >= a [ j + 1 ] : a [ j ] = max ( 0 , a [ j + 1 ] - 1 ) print ( sum ( a ) ) NEW_LINE"],"bleu":0.16852299819460004,"rouge_l":0.42493394186884453}
{"id":593,"predictions":["n , k = map ( int , input ( ) . split ( ) ) if k % 2 : print ( ' NO ' ) elif k % 2 == 0 : print ( ' YES ' ) elif k % 2 == 0 : print ( ' NO ' ) elif k % 2 == 2 : print ( ' NO ' ) elif k % 2 == 0 : print ( ' YES ' ) else : print ( ' NO ' ) NEW_LINE"],"references":["n , k = map ( int , input ( ) . split ( ) ) if ( k % 2 == 0 ) : print ( \" YES \" ) print ( ' . ' * n ) print ( ' . ' + ' # ' * ( k \/\/ 2 ) + ' . ' * ( n - 1 - k \/\/ 2 ) ) print ( ' . ' + ' # ' * ( k \/\/ 2 ) + ' . ' * ( n - 1 - k \/\/ 2 ) ) print ( ' . ' * n ) else : print ( \" YES \" ) print ( ' . ' * n ) if ( k <= n - 2 ) : print ( ' . ' * ( ( n - k ) \/\/ 2 ) + ' # ' * k + ' . ' * ( ( n - k ) \/\/ 2 ) ) print ( ' . ' * n ) else : print ( ' . ' + ' # ' * ( n - 2 ) + ' . ' ) print ( ' . ' + ' # ' * ( ( k - n + 2 ) \/\/ 2 ) + ' . ' * ( n - 2 - k + n - 2 ) + ' # ' * ( ( k - n + 2 ) \/\/ 2 ) + ' . ' ) print ( ' . ' * n ) NEW_LINE"],"bleu":0.0568833749599808,"rouge_l":0.3325383304940375}
{"id":594,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) b = [ ] for i in range ( n ) : if b [ i ] == 0 : b . append ( b [ i ] ) b . append ( b [ i ] ) b . append ( b [ i ] ) b . append ( b [ i ] ) b . append ( b [ i ] ) b . sort ( ) b . sort ( key = lambda x : x [ y ] ) b . sort ( ) print ( len ( b ) ) NEW_LINE"],"references":["sections , a , divisors , cap = map ( int , input ( ) . split ( ) )   NEW_LINE"],"bleu":0.0953299667364242,"rouge_l":0.2321468547123349}
{"id":595,"predictions":["for i in range ( int ( input ( ) ) ) : a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if b - a >= b : NEW_LINE INDENT print ( a ) else : NEW_LINE DEDENT"],"references":["a , b = [ int ( x ) for x in input ( ) . split ( ) ]   x = b % 10 mul = 1 for i in range ( b , a , - 1 ) : mul *= x x -= 1 if x < 0 and i > a : print ( \"0\" ) mul = - 1 breakif mul != - 1 : mul = mul % 10 print ( mul ) NEW_LINE"],"bleu":0.16585619470439056,"rouge_l":0.3131263749694451}
{"id":596,"predictions":["if __name__ == ' _ _ main _ _ ' : n , m = [ int ( x ) for x in input ( ) . split ( ' ▁ ' ) ] arr = [ int ( x ) for x in input ( ) . split ( ' ▁ ' ) ] arr = [ int ( x ) for x in input ( ) . split ( ' ▁ ' ) ] print ( arr [ 0 ] ) NEW_LINE"],"references":["n = int ( input ( ) ) a = pow ( 1 , n , 5 ) b = pow ( 2 , n , 5 ) c = pow ( 3 , n , 5 ) d = pow ( 4 , n , 5 ) print ( ( a + b + c + d ) % 5 )   NEW_LINE"],"bleu":0.05231518998015868,"rouge_l":0.31857402361489556}
{"id":597,"predictions":["for _ in range ( int ( input ( ) ) ) : n , m = map ( int , input ( ) . split ( ) ) m = min ( m ) if m == min ( m , n ) or m == min ( m , m ) : print ( 0 ) elif m == m : print ( m - 1 ) else : print ( m - 1 ) NEW_LINE"],"references":["cases = int ( input ( ) ) while cases : cases -= 1 a , b , c , r = map ( int , input ( ) . split ( ) )   if a > b : a , b = b , a   pot = b - a   cl = c - r cr = c + r   if a <= cl <= cr <= b : ans = b - a - ( cr - cl ) elif cl <= a <= cr <= b : ans = b - cr elif a <= cl <= b <= cr : ans = cl - a elif cl <= a <= b <= cr : ans = 0 else : ans = b - a   print ( ans ) NEW_LINE"],"bleu":0.13667847874705505,"rouge_l":0.31743278404163056}
{"id":598,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in range ( n ) : for j in range ( m ) : if a [ i ] [ j ] == b [ i ] [ j ] : if a [ i ] [ j ] == b [ i ] : c += 1 if a [ i ] [ j ] == b [ i ] and b [ i ] [ j ] == b [ i ] [ j ] : c += 1 if a [ i ] [ j ] == b [ i ] and b [ i ] [ j ] == b [ i ] [ j ] and a [ i ] [ j ] == b [ i ] [ j ] : b [ i ] [ j ] = 1 if a [ i ] [ j ] == b [ i ] [ j ] and b [ i ] [ j ] and b [ i ] [ j ] == b [ i ] [ j ] and b [ i ] [ j ] and b [ i ] [ j ] and b [ i ] [ j ] == b [ i ] [ j ] and a [ i ] [ j ] == b [ i ] [ j ] and b [ i ] [ j ] and b [ i ] [ j ] and b [ i ] [ j ] == b [ i ] [ j ] and a [ i ] [ j ] == b [ i ] [ j ] : print ( \" NO \" ) print ( \" YES \" )     NEW_LINE"],"references":["import mathimport collections def solve ( n , l ) : return max ( l ) - ( sum ( l ) - max ( l ) ) + 1   n = int ( input ( ) ) l = [ int ( s ) for s in input ( ) . split ( ) ] result = solve ( n , l ) print ( result ) NEW_LINE"],"bleu":0.04022444324353009,"rouge_l":0.17593510590356015}
{"id":599,"predictions":["n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) dp = [ 0 ] * ( n + 1 ) for i in range ( 1 , n + 1 ) : dp [ i ] . append ( dp [ i ] ) dp . append ( dp [ i ] ) dp [ 0 ] = 1 for i in range ( 1 , n + 1 ) : for j in range ( i ) : if arr [ i ] [ j ] in dp [ i ] [ j ] : dp [ i ] [ j ] = dp [ i ] [ j ] dp [ i ] [ j ] = dp [ i ] [ j ] + 1 dp [ i ] [ j ] NEW_LINE"],"references":["def main_funtion ( ) : n = int ( input ( ) ) s = [ int ( i ) for i in input ( ) . split ( \" ▁ \" ) ] minimum = min ( s ) the_val = 10000000000000 for i in s : if i > minimum and i < the_val : the_val = i if the_val == 10000000000000 : return \" NO \" return the_val     print ( main_funtion ( ) ) NEW_LINE"],"bleu":0.13888751629674084,"rouge_l":0.31047904191616765}
{"id":600,"predictions":["t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : n = int ( input ( ) ) NEW_LINE ali = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE arr . sort ( ) NEW_LINE if ( ali [ 0 ] >= ali [ 1 ] ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT"],"references":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) a . sort ( ) cur = 1 for i in range ( n ) : if a [ i ] >= cur : cur += 1 print ( cur - 1 ) NEW_LINE"],"bleu":0.3743715586058994,"rouge_l":0.5810907358894973}
{"id":601,"predictions":["n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in range ( n ) : if a [ i ] % 2 == 0 : c += 1 else : c += 1 if a [ i ] % 2 == 0 : c += 1 print ( c ) NEW_LINE"],"references":["entrada1 = input ( ) . split ( ) NEW_LINE n , k = int ( entrada1 [ 0 ] ) , int ( entrada1 [ 1 ] )   entrada2 = input ( ) . split ( ) NEW_LINE c = int ( entrada2 [ 0 ] ) NEW_LINE festivos = [ ] NEW_LINE for i in range ( c ) : festivos . append ( int ( entrada2 [ i + 1 ] ) )   regalos = 0 NEW_LINE k_esimo = 0 NEW_LINE f = 0   i = 1 NEW_LINE while i <= n : if NEW_LINE f < c and i == festivos [ f ] : regalos = regalos + 1 NEW_LINE f = f + 1 NEW_LINE k_esimo = 0 else : k_esimo = k_esimo + 1 NEW_LINE if k_esimo == k : regalos = regalos + 1 NEW_LINE k_esimo = 0 NEW_LINE i = i + 1 NEW_LINE print ( regalos ) NEW_LINE"],"bleu":0.12110500188839138,"rouge_l":0.3599281682914315}
{"id":602,"predictions":["n , k = map ( int , input ( ) . split ( ) ) print ( * n - k ) * ( n - k ) NEW_LINE"],"references":["n , k = map ( int , input ( ) . split ( ) ) e = ( n - k ) \/\/ 2 c = \"0\" * e + \"1\" while ( len ( c ) <= n ) : c = c + cprint ( c [ : n ] ) NEW_LINE"],"bleu":0.29636169769987064,"rouge_l":0.5809523809523809}
{"id":603,"predictions":["for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) h = 0 for i in range ( n ) : h = a [ i ] if h [ a [ i ] ] == '1' or h [ a [ i ] ] == '1' or h [ a [ i ] ] == '1' or h [ a [ i ] ] == '1' or h [ a [ i ] ] == '1' or h [ a [ i ] ] == '1' : h += 1 if h [ a [ i ] ] == '1' or h [ a [ i ] ] == '1' or h [ a [ i ] ] == '1' : print ( ' NO ' ) else : print ( ' YES ' ) NEW_LINE"],"references":["for _ in range ( int ( input ( ) ) ) : n , k = map ( int , input ( ) . split ( ) ) ; s = input ( ) ; l = [ 0 ] * k ; f = k NEW_LINE for i in range ( k ) : v = [ ] ; c = 0 NEW_LINE for j in s [ i : : k ] : if NEW_LINE j != ' ? ' : NEW_LINE if j not in v : v += [ j ] ; c += 1 NEW_LINE if c > 1 : NEW_LINE INDENT break else : NEW_LINE if NEW_LINE DEDENT v : l [ i ] = ( - 1 ) ** int ( v [ 0 ] ) ; NEW_LINE f -= 1 NEW_LINE continue NEW_LINE break else : print ( [ \" NO \" , \" YES \" ] [ abs ( sum ( l ) ) <= f ] ) ; NEW_LINE continue NEW_LINE print ( \" NO \" ) NEW_LINE"],"bleu":0.22555944369429168,"rouge_l":0.35783896300501467}
{"id":604,"predictions":["n , k = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l . sort ( ) print ( len ( l ) ) NEW_LINE"],"references":["p , k = input ( ) . split ( ) p , k = int ( p ) , int ( k ) s = k - 1 ls = [ 0 ] while s < p : ls . append ( 0 ) ls . append ( 0 ) s = s * k * k + k - 1 n = len ( ls ) for i in range ( n ) : if ( i & 1 ) == 0 : ls [ i ] = k - 1 res = s - pfor i in range ( n ) : t = res % k if i & 1 : ls [ i ] += t else : ls [ i ] -= t res \/\/= kprint ( n ) print ( \" ▁ \" . join ( str ( x ) for x in ls ) )   NEW_LINE"],"bleu":0.02613682936157056,"rouge_l":0.2537890044576523}
{"id":605,"predictions":["n , k = [ int ( i ) for i in input ( ) . split ( ) ] a = [ int ( i ) for i in input ( ) . split ( ) ] ans = 0 for i in range ( n ) : for j in range ( n ) : if a [ i ] == b [ j ] : ans += 1 print ( ans ) NEW_LINE"],"references":["def insertion_sort ( l ) : for i in range ( len ( l ) ) : for j in ( range ( i ) ) : k = i - j if l [ k ] >= l [ k - 1 ] : l [ k - 1 ] , l [ k ] = l [ k ] , l [ k - 1 ] else : break return l       def selection_sort ( l ) : for i in range ( len ( l ) ) : min_ind = i min_val = l [ i ] for j in range ( i , len ( l ) ) : if min_val > l [ j ] : min_val = l [ j ] min_ind = j l [ i ] , l [ min_ind ] = l [ min_ind ] , l [ i ] return l     def bubble_sort ( l ) : for i in range ( len ( l ) - 1 ) : for j in range ( len ( l ) - 1 - i ) : if l [ j ] > l [ j + 1 ] : l [ j ] , l [ j + 1 ] = l [ j + 1 ] , l [ j ] return l     NEW_LINE"],"bleu":0.0401581924482164,"rouge_l":0.27563850687622793}
{"id":606,"predictions":["n , k = map ( int , input ( ) . split ( ) ) l = [ ] for i in range ( n ) : a , b = map ( int , input ( ) . split ( ) ) l . append ( a - b ) l . sort ( ) for i in l : print ( i [ 0 ] , end = \" \" ) NEW_LINE"],"references":["import sysinput = sys . stdin . readlinedef inp ( ) : return ( int ( input ( ) ) ) def inlt ( ) : return ( list ( map ( int , input ( ) . split ( ) ) ) ) def insr ( ) : s = input ( ) return ( list ( s [ : len ( s ) - 1 ] ) ) def invr ( ) : return ( map ( int , input ( ) . split ( ) ) )   inp = invr ( ) inp = [ x for x in inp ] req = inlt ( ) prepared = inlt ( )     j = 0 i = 0 while i < inp [ 0 ] and j < inp [ 1 ] : if req [ i ] <= prepared [ j ] : i += 1 j += 1 print ( inp [ 0 ] - i )     NEW_LINE"],"bleu":0.12072128961839292,"rouge_l":0.3403068340306834}
{"id":607,"predictions":["for _ in range ( int ( input ( ) ) ) : n , m = map ( int , input ( ) . split ( ) ) if ( m - n ) == 1 : print ( \" NO \" ) else : print ( \" YES \" ) NEW_LINE"],"references":["in_tests = int ( input ( ) )   for i in range ( in_tests ) : [ x , y ] = input ( ) . split ( ) if int ( x ) - int ( y ) == 1 : print ( ' NO ' ) else : print ( ' YES ' )   NEW_LINE"],"bleu":0.3995551068654217,"rouge_l":0.6190200057987821}
{"id":608,"predictions":["for _ in range ( int ( input ( ) ) ) : n , m , s , t = map ( int , input ( ) . split ( ) ) NEW_LINE t = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT t [ i ] = ' R ' NEW_LINE t [ i ] = t + 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if t [ i ] >= f : NEW_LINE INDENT continue NEW_LINE DEDENT if t [ i ] >= f : NEW_LINE INDENT print ( ' R ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' X ' ) NEW_LINE DEDENT DEDENT"],"references":["n , m , s , f = map ( int , input ( ) . split ( ) ) l = [ ] for i in range ( m ) : t , c , r = map ( int , input ( ) . split ( ) ) l . append ( [ t , c , r ] ) if s > f : st = \" \" t = 1 i = 0 while ( i < m ) : if t == l [ i ] [ 0 ] : if ( s < l [ i ] [ 1 ] or s > l [ i ] [ 2 ] ) and ( s - 1 < l [ i ] [ 1 ] or s - 1 > l [ i ] [ 2 ] ) : s -= 1 st += \" L \" else : st += \" X \" i += 1 if s == f : break else : st += ' L ' s -= 1 if s == f : break t += 1 while ( s > f ) : s -= 1 st += ' L ' print ( st ) if s < f : st = \" \" t = 1 i = 0 while ( i < m ) : if t == l [ i ] [ 0 ] : if ( s < l [ i ] [ 1 ] or s > l [ i ] [ 2 ] ) and ( s + 1 < l [ i ] [ 1 ] or s + 1 > l [ i ] [ 2 ] ) : s += 1 st += \" R \" else : st += \" X \" i += 1 if s == f : break else : st += ' R ' s += 1 if s == f : break t += 1 while ( s < f ) : s += 1 st += ' R ' print ( st ) NEW_LINE"],"bleu":0.05924837429273992,"rouge_l":0.25383014942311327}
{"id":609,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = [ ] for i in range ( m ) : a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) for j in range ( m ) : a [ j ] . append ( a [ j ] ) a [ j ] . sort ( ) for i in range ( m ) : for j in range ( m ) : for j in range ( m ) : if a [ i ] [ j ] == x : a [ j ] += x NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) a = [ 10 ** 9 for _ in range ( n ) ] extra = [ 0 for _ in range ( n ) ] query = list ( ) for _ in range ( m ) : t , l , r , x = map ( int , input ( ) . split ( ) ) l -= 1 r -= 1 query . append ( ( t , l , r , x ) ) if t == 1 : for j in range ( l , r + 1 ) : extra [ j ] += x else : for j in range ( l , r + 1 ) : a [ j ] = min ( a [ j ] , x - extra [ j ] ) extra = a . copy ( ) for t , l , r , x in query : if t == 1 : for j in range ( l , r + 1 ) : a [ j ] += x else : val = - 10 ** 9 for j in range ( l , r + 1 ) : val = max ( val , a [ j ] ) if not val == x : print ( ' NO ' ) exit ( 0 )   print ( ' YES ' ) for x in extra : print ( x , end = ' ▁ ' ) NEW_LINE"],"bleu":0.18514484519652888,"rouge_l":0.4384590534647068}
{"id":610,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in range ( n ) : if a [ i ] % 2 == 0 : c += 1 else : breakprint ( c ) NEW_LINE"],"references":["a = input ( ) b = input ( ) res = 0 la = len ( a ) lb = len ( b ) sum = la + lb   if la > lb : for i in range ( lb - 1 , - 1 , - 1 ) : la = la - 1 if b [ i ] == a [ la ] : res = res + 1 else : break res = sum - 2 * res print ( res ) else : for i in range ( la - 1 , - 1 , - 1 ) : lb = lb - 1 if a [ i ] == b [ lb ] : res = res + 1 else : break res = sum - 2 * res print ( res )   NEW_LINE"],"bleu":0.0686851705217273,"rouge_l":0.3089988081048867}
{"id":611,"predictions":["n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) cnt = 0 for i in range ( n ) : if a [ i ] % 2 == 0 : cnt += 1 if a [ i ] % 2 == 0 : print ( - 1 ) else : print ( cnt ) NEW_LINE"],"references":["n = int ( input ( ) ) print ( int ( 2 ** n - ( n > 12 ) * 2 ** ( n - 13 ) * 100 ) ) NEW_LINE"],"bleu":0.05283480938311693,"rouge_l":0.336644591611479}
{"id":612,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) for i in b : if a [ i ] != b [ i ] : b [ i ] = 1 else : b [ i ] = 1 if a [ i ] == b [ i ] : b [ i ] = 1 if a [ i ] == b [ i ] : b [ i ] = 1 if a [ i ] == b [ i ] : b [ i ] = 1 else : b [ i ] = 1 if a [ i ] == b [ i ] : if a [ i ] == b [ i ] : b [ i ] = b [ i ] else : b [ i ] = 1 print ( b [ i ] ) NEW_LINE"],"references":["l = lenimport sysc = sys . stdin . readline ( ) d = [ 0 ] * l ( c ) p = c [ 0 ] for i , t in enumerate ( c [ 1 : ] ) : d [ i + 1 ] = d [ i ] + 1 * ( t == p ) p = tfor _ in range ( int ( sys . stdin . readline ( ) ) ) : l , r = map ( int , sys . stdin . readline ( ) . split ( ) ) sys . stdout . write ( str ( d [ r - 1 ] - d [ l - 1 ] ) + \" \\n \" ) NEW_LINE"],"bleu":0.10456433964618189,"rouge_l":0.24243762419960252}
{"id":613,"predictions":["n , k = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) li = list ( map ( int , input ( ) . split ( ) ) ) li . sort ( ) if k <= l : print ( - 1 ) else : print ( - 1 ) NEW_LINE"],"references":["N , M = ( int ( x ) for x in input ( ) . split ( ) ) A = [ int ( x ) for x in input ( ) . split ( ) ] t = 0 prev = 1   for i , task in enumerate ( A ) : if not task < prev : t += task - prev prev = task else : t += N - prev t += task prev = taskprint ( t ) NEW_LINE"],"bleu":0.197808663985067,"rouge_l":0.4090631985368827}
{"id":614,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["import queue   class Query : def __init__ ( self , t , d , id ) : self . t = t self . d = d self . id = id   n , b = map ( int , input ( ) . split ( ) ) a = [ ] for i in range ( n ) : x , y = map ( int , input ( ) . split ( ) ) a . append ( Query ( x , y , i ) )   i = 0 cur_time = 0 q = queue . Queue ( ) result = [ 0 ] * nwhile i < n : while i < n and a [ i ] . t < cur_time and q . qsize ( ) < b : q . put ( a [ i ] ) i += 1 while i < n and a [ i ] . t < cur_time and q . qsize ( ) == b : result [ i ] = - 1 i += 1 if not q . empty ( ) : processed_query = q . get ( ) cur_time += processed_query . d result [ processed_query . id ] = cur_time else : if i < n : cur_time = a [ i ] . t + a [ i ] . d result [ a [ i ] . id ] = cur_time i += 1 while not q . empty ( ) : processed_query = q . get ( ) cur_time += processed_query . d result [ processed_query . id ] = cur_time for i in range ( n ) : print ( result [ i ] , end = ' ▁ ' ) NEW_LINE"],"bleu":0.0015528934575934755,"rouge_l":0.1546783872876342}
{"id":615,"predictions":["for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) if n == 1 : print ( - 1 ) else : print ( - 1 ) NEW_LINE"],"references":["import sys   n , k = map ( int , sys . stdin . readline ( ) . split ( ) ) if k > n or ( k == 1 and n != 1 ) : print ( - 1 ) else : l = [ \" ▁ \" for i in range ( n ) ] last = ord ( \" a \" ) + k - 1 m = n - 1 for i in range ( k - 2 ) : l [ m ] = chr ( last - i ) m -= 1 start = ord ( \" a \" ) for i in range ( n ) : if l [ i ] != \" ▁ \" : break else : l [ i ] = chr ( start ) if i % 2 == 1 : start -= 1 else : start += 1 print ( \" \" . join ( l ) ) NEW_LINE"],"bleu":0.017179837372227443,"rouge_l":0.22168919901148423}
{"id":616,"predictions":["a , b = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l = list ( map ( int , input ( ) . split ( ) ) ) print ( l ) NEW_LINE"],"references":["\"\"\" ▁ Created ▁ by ▁ Henrikh ▁ Kantuni ▁ on ▁ 2\/7\/17 ▁ \"\"\"   a = input ( ) b = input ( ) ans = - 1 if a == b else max ( len ( a ) , len ( b ) ) print ( ans ) NEW_LINE"],"bleu":0.09686770771572421,"rouge_l":0.3488562091503268}
{"id":617,"predictions":["n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in range ( n ) : if a [ i ] == b [ i ] : c += 1 if a [ i ] % 2 == 0 : print ( - 1 ) else : print ( - 1 ) NEW_LINE"],"references":["print ( * input ( ) . split ( ' WUB ' ) ) NEW_LINE"],"bleu":0.06992578948354904,"rouge_l":0.20401337792642138}
{"id":618,"predictions":["def findSum ( n ) : NEW_LINE INDENT sum2 = ( ( n \/\/ 2 ) * ( 4 + ( n \/\/ 2 - 1 ) * 2 ) ) \/\/ 2 NEW_LINE sum5 = ( ( n \/\/ 5 ) * ( 10 + ( n \/\/ 10 - 1 ) * 5 ) ) \/\/ 2 NEW_LINE sum10 = ( ( n \/\/ 10 ) * ( 20 + ( n \/\/ 10 - 1 ) * 10 ) ) \/\/ 2 NEW_LINE return sum2 + sum5 - sum10 NEW_LINE DEDENT n = 5 NEW_LINE print ( findSum ( n ) ) NEW_LINE"],"references":["def findSum ( n ) : NEW_LINE INDENT sum2 = ( ( n \/\/ 2 ) * ( 4 + ( n \/\/ 2 - 1 ) * 2 ) ) \/\/ 2 NEW_LINE sum5 = ( ( n \/\/ 5 ) * ( 10 + ( n \/\/ 5 - 1 ) * 5 ) ) \/\/ 2 NEW_LINE sum10 = ( ( n \/\/ 10 ) * ( 20 + ( n \/\/ 10 - 1 ) * 10 ) ) \/\/ 2 NEW_LINE return sum2 + sum5 - sum10 ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( int ( findSum ( n ) ) ) NEW_LINE DEDENT"],"bleu":0.7927572268037241,"rouge_l":0.9003373629463032}
{"id":619,"predictions":["def waysToSplit ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE answer = [ 0 ] * n NEW_LINE suffix = [ 0 ] * n NEW_LINE seen = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT prev = prefix [ i - 1 ] NEW_LINE if ( i - 1 >= 0 ) : NEW_LINE INDENT prev = prefix [ i - 1 ] NEW_LINE DEDENT if ( seen [ ord ( s [ i ] ) - ord ( ' a ' ) ] == 0 ) : NEW_LINE INDENT prefix [ i ] += ( prev + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT prefix [ i ] = prev NEW_LINE DEDENT seen [ ord ( s [ i ] ) - ord ( ' a ' ) ] = 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT prev [ i ] = 0 NEW_LINE DEDENT suffix [ n - 1 ] = 0 NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT prev = suffix [ i ] NEW_LINE if ( seen [ ord ( s [ i ] ) - ord ( ' a ' ) ] == 0 ) : NEW_LINE INDENT suffix [ i - 1 ] += ( prev + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT suffix [ i - 1 ] = prev NEW_LINE DEDENT seen [ ord ( s [ i ] ) - ord ( ' a ' ) ] = 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( prefix [ i ] == suffix [ i ] ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" ababa \" NEW_LINE print ( waysToSplit ( s ) ) NEW_LINE DEDENT"],"references":["def waysToSplit ( s ) : NEW_LINE INDENT n = len ( s ) ; NEW_LINE answer = 0 ; NEW_LINE prefix = [ 0 ] * n ; NEW_LINE suffix = [ 0 ] * n ; NEW_LINE seen = [ 0 ] * 26 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT prev = prefix [ i - 1 ] if ( i - 1 >= 0 ) else 0 ; NEW_LINE if ( seen [ ord ( s [ i ] ) - ord ( ' a ' ) ] == 0 ) : NEW_LINE INDENT prefix [ i ] += ( prev + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT prefix [ i ] = prev ; NEW_LINE DEDENT seen [ ord ( s [ i ] ) - ord ( ' a ' ) ] = 1 ; NEW_LINE DEDENT seen = [ 0 ] * len ( seen ) ; NEW_LINE suffix [ n - 1 ] = 0 ; NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT prev = suffix [ i ] ; NEW_LINE if ( seen [ ord ( s [ i ] ) - ord ( ' a ' ) ] == 0 ) : NEW_LINE INDENT suffix [ i - 1 ] += ( prev + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT suffix [ i - 1 ] = prev ; NEW_LINE DEDENT seen [ ord ( s [ i ] ) - ord ( ' a ' ) ] = 1 ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( prefix [ i ] == suffix [ i ] ) : NEW_LINE INDENT answer += 1 ; NEW_LINE DEDENT DEDENT return answer ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" ababa \" ; NEW_LINE print ( waysToSplit ( s ) ) ; NEW_LINE DEDENT"],"bleu":0.8065570852673833,"rouge_l":0.8976608187134503}
{"id":620,"predictions":["def check ( a , n ) : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( n \/\/ 2 ) : NEW_LINE INDENT if a [ i ] != a [ i + ( n \/\/ 2 ) ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT a = [ 1 , 4 , 1 , 4 ] NEW_LINE n = len ( a ) NEW_LINE if check ( a , n ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"],"references":["def check ( a , n ) : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( n \/\/ 2 ) : NEW_LINE INDENT if a [ i ] != a [ i + ( n \/\/ 2 ) ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 4 , 1 , 4 ] NEW_LINE n = len ( a ) NEW_LINE if check ( a , n ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.8704885875367051,"rouge_l":0.931297709923664}
{"id":621,"predictions":["def solve ( n , k ) : NEW_LINE INDENT if ( n >= ( k * ( k + 1 ) ) \/ 2 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 12 ; k = 4 ; NEW_LINE if ( solve ( n , k ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"],"references":["def solve ( n , k ) : NEW_LINE INDENT if ( n >= ( k * ( k + 1 ) ) \/\/ 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 12 NEW_LINE k = 4 NEW_LINE if ( solve ( n , k ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.7553616621309462,"rouge_l":0.9349894291754759}
{"id":622,"predictions":["def numbersWith3Divisors ( n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) ; NEW_LINE prime [ 0 ] = prime [ 1 ] = False ; NEW_LINE p = 2 ; NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT DEDENT print ( \" Numbers ▁ with ▁ 3 ▁ divisors ▁ : ▁ \" , end = \" \" ) ; NEW_LINE i = 0 ; NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT print ( i * i , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT DEDENT n = 9 ; NEW_LINE numbersWith3Divisors ( n ) ; NEW_LINE"],"references":["def numbersWith3Divisors ( n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) ; NEW_LINE prime [ 0 ] = prime [ 1 ] = False ; NEW_LINE p = 2 ; NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT p += 1 ; NEW_LINE DEDENT print ( \" Numbers ▁ with ▁ 3 ▁ divisors ▁ : \" ) ; NEW_LINE i = 0 ; NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT print ( i * i , end = \" ▁ \" ) ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT DEDENT n = 96 ; NEW_LINE numbersWith3Divisors ( n ) ; NEW_LINE"],"bleu":0.9025497285894938,"rouge_l":0.9447294550382345}
{"id":623,"predictions":["def countWays ( A , B , C ) : NEW_LINE INDENT minAddA = max ( 0 , ( C + B - A + 2 ) \/\/ 2 ) NEW_LINE count_ways = max ( C - minAddA + 1 , 0 ) NEW_LINE return count_ways NEW_LINE DEDENT A = 3 NEW_LINE B = 5 NEW_LINE C = 5 NEW_LINE print ( countWays ( A , B , C ) ) NEW_LINE"],"references":["def countWays ( A , B , C ) : NEW_LINE INDENT minAddA = max ( 0 , ( C + B - A + 2 ) \/\/ 2 ) NEW_LINE count_ways = max ( C - minAddA + 1 , 0 ) NEW_LINE return count_ways NEW_LINE DEDENT A = 3 NEW_LINE B = 5 NEW_LINE C = 5 NEW_LINE print ( countWays ( A , B , C ) ) NEW_LINE"],"bleu":1.0,"rouge_l":1.0}
{"id":624,"predictions":["def isOperand ( x ) : NEW_LINE INDENT return ( x >= ' a ' and x <= ' z ' ) or ( x >= ' A ' and x <= ' Z ' ) NEW_LINE DEDENT def getInfix ( exp ) : NEW_LINE INDENT s = [ ] NEW_LINE for i in range ( len ( exp ) ) : NEW_LINE INDENT if ( isOperand ( exp [ i ] ) ) : NEW_LINE INDENT s . append ( exp [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT op1 = s [ - 1 ] NEW_LINE s . pop ( ) NEW_LINE op2 = s [ - 1 ] NEW_LINE s . pop ( ) NEW_LINE s . append ( \" ( \" + op [ i ] + op [ i ] + op [ i ] ) ) NEW_LINE DEDENT DEDENT return s [ - 1 ] NEW_LINE DEDENT exp = \" ab * c + \" NEW_LINE print ( getInfix ( exp ) ) NEW_LINE"],"references":["def isOperand ( x ) : NEW_LINE INDENT return ( ( x >= ' a ' and x <= ' z ' ) or ( x >= ' A ' and x <= ' Z ' ) ) NEW_LINE DEDENT def getInfix ( exp ) : NEW_LINE INDENT s = [ ] NEW_LINE for i in exp : NEW_LINE INDENT if ( isOperand ( i ) ) : NEW_LINE INDENT s . insert ( 0 , i ) NEW_LINE DEDENT else : NEW_LINE INDENT op1 = s [ 0 ] NEW_LINE s . pop ( 0 ) NEW_LINE op2 = s [ 0 ] NEW_LINE s . pop ( 0 ) NEW_LINE s . insert ( 0 , \" ( \" + op2 + i + op1 + \" ) \" ) NEW_LINE DEDENT DEDENT return s [ 0 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT exp = \" ab * c + \" NEW_LINE print ( getInfix ( exp . strip ( ) ) ) NEW_LINE DEDENT"],"bleu":0.6497878270965439,"rouge_l":0.805940779610195}
{"id":625,"predictions":["def countPairs ( arr , n ) : NEW_LINE INDENT twoCount = 0 NEW_LINE twoGrCount = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == 2 ) : NEW_LINE INDENT twoCount += 1 NEW_LINE DEDENT elif ( arr [ i ] > 2 ) : NEW_LINE INDENT twoGrCount += 1 NEW_LINE DEDENT DEDENT return twoCount * twoGrCount + ( twoGrCount * ( twoGrCount - 1 ) ) \/\/ 2 NEW_LINE DEDENT arr = [ 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE"],"references":["def CountPairs ( arr , n ) : NEW_LINE INDENT twoCount = 0 NEW_LINE twoGrCount = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == 2 ) : NEW_LINE INDENT twoCount += 1 NEW_LINE DEDENT elif ( arr [ i ] > 2 ) : NEW_LINE INDENT twoGrCount += 1 NEW_LINE DEDENT DEDENT return ( ( twoCount * twoGrCount ) + ( twoGrCount * ( twoGrCount - 1 ) ) \/ 2 ) NEW_LINE DEDENT arr = [ 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( CountPairs ( arr , n ) ) NEW_LINE"],"bleu":0.837899844022251,"rouge_l":0.941358024691358}
{"id":626,"predictions":["def isValidTime ( time ) : NEW_LINE INDENT stringPattern = \" ( 1.012\" or [ 0 - 5 ] [ 0 - 5 ] ) : NEW_LINE INDENT stringPattern = \" \" . join ( string ) [ 0 - 5 ] NEW_LINE DEDENT string += \" \\n \" NEW_LINE DEDENT def isValidTime ( time ) : NEW_LINE INDENT string1 = compilePattern ( time ) NEW_LINE if ( time == None ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string1 = \"12:15 ▁ AM \" NEW_LINE print ( isValidTime ( string1 ) ) NEW_LINE string2 = \" : \" NEW_LINE print ( string ) NEW_LINE if ( isValidTime ( string1 ) ) : NEW_LINE INDENT print ( \" true \" ) NEW_LINE DEDENT DEDENT"],"references":["import re NEW_LINE def isValidTime ( time ) : NEW_LINE INDENT regexPattern = \" ( 1[012 ] | [ 1-9 ] ) : \" + \" [ 0-5 ] [ 0-9 ] ( \\\\s ) \" + \" ? ( ? i ) ( am | pm ) \" ; NEW_LINE compiledPattern = re . compile ( regexPattern ) ; NEW_LINE if ( time == None ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT if re . search ( compiledPattern , time ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \"12:15 ▁ AM \" ; NEW_LINE print ( isValidTime ( str1 ) ) ; NEW_LINE str2 = \"9:45PM \" ; NEW_LINE print ( isValidTime ( str2 ) ) ; NEW_LINE str3 = \"1:15\" ; NEW_LINE print ( isValidTime ( str3 ) ) ; NEW_LINE str4 = \"17:30\" ; NEW_LINE print ( isValidTime ( str4 ) ) ; NEW_LINE DEDENT"],"bleu":0.3363132060425837,"rouge_l":0.560833588722035}
{"id":627,"predictions":["import sys NEW_LINE def minXOR ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE minXor = sys . maxsize - 1 NEW_LINE val = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT val = arr [ i ] ^ arr [ i + 1 ] NEW_LINE minXor = min ( minXor , val ) NEW_LINE DEDENT return minXor NEW_LINE DEDENT arr = [ 9 , 5 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minXOR ( arr , n ) ) NEW_LINE"],"references":["import sys NEW_LINE def minXOR ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE minXor = int ( sys . float_info . max ) NEW_LINE val = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT val = arr [ i ] ^ arr [ i + 1 ] ; NEW_LINE minXor = min ( minXor , val ) ; NEW_LINE DEDENT return minXor NEW_LINE DEDENT arr = [ 9 , 5 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minXOR ( arr , n ) ) NEW_LINE"],"bleu":0.8333120402679108,"rouge_l":0.9301765650080256}
{"id":628,"predictions":["def sum ( m , n ) : NEW_LINE INDENT return 8 * m * n - 6 * m - 6 * n + 4 NEW_LINE DEDENT m = 3 NEW_LINE n = 2 NEW_LINE print ( sum ( m , n ) ) NEW_LINE"],"references":["def summ ( m , n ) : NEW_LINE INDENT return 8 * m * n - 6 * m - 6 * n + 4 NEW_LINE DEDENT m = 3 NEW_LINE n = 2 NEW_LINE print ( summ ( m , n ) ) NEW_LINE"],"bleu":0.9050990896061486,"rouge_l":0.9565217391304348}
{"id":629,"predictions":["def isPossible ( str1 ) : NEW_LINE INDENT freq = dict ( ) NEW_LINE max_freq = 0 NEW_LINE for j in range ( len ( str1 ) ) : NEW_LINE INDENT freq [ str1 [ j ] ] += 1 NEW_LINE if freq [ str1 [ j ] ] > max_freq : NEW_LINE INDENT freq [ str1 [ j ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ str1 [ j ] ] = 1 NEW_LINE if freq [ str1 [ j ] ] > max_freq : NEW_LINE INDENT freq [ str1 [ j ] ] = freq [ str1 [ j ] ] NEW_LINE DEDENT DEDENT DEDENT if ( max_freq <= ( len ( str1 ) - max_freq + 1 ) ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT str = \" geeksforgeeks \" NEW_LINE if ( isPossible ( str1 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def isPossible ( Str ) : NEW_LINE INDENT freq = dict ( ) NEW_LINE max_freq = 0 NEW_LINE for j in range ( len ( Str ) ) : NEW_LINE INDENT freq [ Str [ j ] ] = freq . get ( Str [ j ] , 0 ) + 1 NEW_LINE if ( freq [ Str [ j ] ] > max_freq ) : NEW_LINE INDENT max_freq = freq [ Str [ j ] ] NEW_LINE DEDENT DEDENT if ( max_freq <= ( len ( Str ) - max_freq + 1 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT Str = \" geeksforgeeks \" NEW_LINE if ( isPossible ( Str ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.5859328699994718,"rouge_l":0.7865144789685056}
{"id":630,"predictions":["def isVowel ( c ) : NEW_LINE INDENT return ( c == ' a ' or c == ' e ' or c == ' E ' or c == ' i ' or c == ' O ' or c == ' O ' or c == ' O ' or c == ' U ' ) ; NEW_LINE DEDENT def reverseVowel ( str1 ) : NEW_LINE INDENT i = 0 ; j = len ( str1 ) - 1 ; NEW_LINE str1 = str1 [ 0 ] ; NEW_LINE while ( i < j ) : NEW_LINE INDENT if ( isVowel ( str1 [ i ] ) == True ) : NEW_LINE INDENT i += 1 ; NEW_LINE continue ; NEW_LINE DEDENT if ( not isVowel ( str1 [ j ] ) ) : NEW_LINE INDENT j -= 1 ; NEW_LINE continue ; NEW_LINE DEDENT t = str1 [ i ] ; NEW_LINE str1 [ i ] = t ; NEW_LINE str1 [ j ] = t ; NEW_LINE i += 1 ; NEW_LINE j -= 1 ; NEW_LINE DEDENT str2 = str1 [ i ] ; NEW_LINE return str2 ; NEW_LINE DEDENT str1 = \" hello \" ; NEW_LINE print ( reverseVowel ( str1 ) ) ; NEW_LINE"],"references":["def isVowel ( c ) : NEW_LINE INDENT return ( c == ' a ' or c == ' A ' or c == ' e ' or c == ' E ' or c == ' i ' or c == ' I ' or c == ' o ' or c == ' O ' or c == ' u ' or c == ' U ' ) NEW_LINE DEDENT def reverseVowel ( str ) : NEW_LINE INDENT i = 0 NEW_LINE j = len ( str ) - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT if not isVowel ( str [ i ] ) : NEW_LINE INDENT i += 1 NEW_LINE continue NEW_LINE DEDENT if ( not isVowel ( str [ j ] ) ) : NEW_LINE INDENT j -= 1 NEW_LINE continue NEW_LINE DEDENT str [ i ] , str [ j ] = str [ j ] , str [ i ] NEW_LINE i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return str NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" hello ▁ world \" NEW_LINE print ( * reverseVowel ( list ( str ) ) , sep = \" \" ) NEW_LINE DEDENT"],"bleu":0.5434670750522895,"rouge_l":0.7331843747592264}
{"id":631,"predictions":["import math NEW_LINE def findBucketNo ( p ) : NEW_LINE INDENT return math . ceil ( ( sqrt ( 8 * p + 1 ) - 1 ) \/ 2 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT p = 10 NEW_LINE print ( findBucketNo ( p ) ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def findBucketNo ( p ) : NEW_LINE INDENT return math . ceil ( ( math . sqrt ( 8 * p + 1 ) - 1 ) \/ 2 ) NEW_LINE DEDENT p = 10 NEW_LINE print ( findBucketNo ( p ) ) NEW_LINE"],"bleu":0.7072052448032661,"rouge_l":0.8667508683296494}
{"id":632,"predictions":["class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def insert ( node , data ) : NEW_LINE INDENT if ( node == None ) : NEW_LINE INDENT return ( data ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( data <= node . data ) : NEW_LINE INDENT node . left = insert ( node . left , data ) NEW_LINE DEDENT else : NEW_LINE INDENT node . right = insert ( node . right , data ) NEW_LINE DEDENT return node NEW_LINE DEDENT DEDENT def minValue ( node ) : NEW_LINE INDENT if ( node . left == None . data ) : NEW_LINE INDENT return node . data NEW_LINE DEDENT return minValue ( node . left ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = None NEW_LINE insert ( root , 4 ) NEW_LINE insert ( root , 2 ) NEW_LINE insert ( root , 3 ) NEW_LINE insert ( root , 3 ) NEW_LINE insert ( root , 6 ) NEW_LINE insert ( root , 5 ) NEW_LINE print ( minValue ( root ) ) NEW_LINE DEDENT"],"references":["class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def insert ( node , data ) : NEW_LINE INDENT if node is None : NEW_LINE INDENT return Node ( data ) NEW_LINE DEDENT else : NEW_LINE INDENT if data <= node . data : NEW_LINE INDENT node . left = insert ( node . left , data ) NEW_LINE DEDENT else : NEW_LINE INDENT node . right = insert ( node . right , data ) NEW_LINE DEDENT return node NEW_LINE DEDENT DEDENT def minValue ( node ) : NEW_LINE INDENT if node . left == None : NEW_LINE INDENT return node . data NEW_LINE DEDENT return minValue ( node . left ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT root = None NEW_LINE root = insert ( root , 4 ) NEW_LINE insert ( root , 2 ) NEW_LINE insert ( root , 1 ) NEW_LINE insert ( root , 3 ) NEW_LINE insert ( root , 6 ) NEW_LINE insert ( root , 5 ) NEW_LINE print ( minValue ( root ) ) NEW_LINE DEDENT"],"bleu":0.8656736870479641,"rouge_l":0.9575253924284396}
{"id":633,"predictions":["def removeZeros ( a , n ) : NEW_LINE INDENT ind = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] != 0 ) : NEW_LINE INDENT ind = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( ind == - 1 ) : NEW_LINE INDENT print ( \" Array ▁ has ▁ leading ▁ zeros ▁ only \" ) NEW_LINE return NEW_LINE DEDENT b = [ 0 for i in range ( n - index ) ] NEW_LINE for i in range ( n - i + 1 ) : NEW_LINE INDENT for i in range ( n - i ) : NEW_LINE INDENT print ( b [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT a = [ 0 , 0 , 0 , 1 , 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE removeZeros ( a , n ) NEW_LINE"],"references":["def removeZeros ( a , n ) : NEW_LINE INDENT ind = - 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] != 0 ) : NEW_LINE INDENT ind = i ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( ind == - 1 ) : NEW_LINE INDENT print ( \" Array ▁ has ▁ leading ▁ zeros ▁ only \" ) ; NEW_LINE return ; NEW_LINE DEDENT b = [ 0 ] * ( n - ind ) ; NEW_LINE for i in range ( n - ind ) : NEW_LINE INDENT b [ i ] = a [ ind + i ] ; NEW_LINE DEDENT for i in range ( n - ind ) : NEW_LINE INDENT print ( b [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT a = [ 0 , 0 , 0 , 1 , 2 , 0 , 3 ] ; NEW_LINE n = len ( a ) ; NEW_LINE removeZeros ( a , n ) ; NEW_LINE"],"bleu":0.7039993287837809,"rouge_l":0.8680390854757615}
{"id":634,"predictions":["def countCoins ( n ) : NEW_LINE INDENT c = 0 NEW_LINE if ( n < 10 ) : NEW_LINE INDENT return n NEW_LINE DEDENT if ( n > 9 and n < 25 ) : NEW_LINE INDENT c = n \/\/ 10 + n % 10 NEW_LINE return c NEW_LINE DEDENT if ( n > 24 ) : NEW_LINE INDENT c = n \/\/ 25 NEW_LINE if ( n % 25 < 10 ) : NEW_LINE INDENT c = c + n % 25 NEW_LINE return c NEW_LINE DEDENT if ( n % 25 > 9 ) : NEW_LINE INDENT c = c + ( n % 25 ) \/\/ 10 + ( n % 25 ) % 10 NEW_LINE return c NEW_LINE DEDENT DEDENT return c NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 14 NEW_LINE print ( countCoins ( n ) ) NEW_LINE DEDENT"],"references":["def countCoins ( n ) : NEW_LINE INDENT c = 0 NEW_LINE if ( n < 10 ) : NEW_LINE INDENT return n NEW_LINE DEDENT if ( n > 9 and n < 25 ) : NEW_LINE INDENT c = n \/\/ 10 + n % 10 NEW_LINE return c NEW_LINE DEDENT if ( n > 24 ) : NEW_LINE INDENT c = n \/\/ 25 NEW_LINE if ( n % 25 < 10 ) : NEW_LINE INDENT c = c + n % 25 NEW_LINE return c NEW_LINE DEDENT if ( n % 25 > 9 ) : NEW_LINE INDENT c = ( c + ( n % 25 ) \/\/ 10 + ( n % 25 ) % 10 ) NEW_LINE return c NEW_LINE DEDENT DEDENT DEDENT n = 14 NEW_LINE print ( countCoins ( n ) ) NEW_LINE"],"bleu":0.856377084721813,"rouge_l":0.9446301247771836}
{"id":635,"predictions":["def isVowel ( ch ) : NEW_LINE INDENT if ch == ' a ' or ch == ' e ' or ch == ' i ' or ch == ' o ' or ch == ' u ' : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def createAltStr ( str1 , str2 , str2 , start , l ) : NEW_LINE INDENT finalStr = \" \" NEW_LINE i = 0 NEW_LINE j = start NEW_LINE while j < l : NEW_LINE INDENT finalStr = ( finalStr + str1 [ i ] ) + str2 [ j ] NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT return finalStr NEW_LINE DEDENT def findAltStr ( str ) : NEW_LINE INDENT nv = 0 NEW_LINE vstr = \" \" NEW_LINE cstr = \" \" NEW_LINE l = len ( str ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT ch = str [ i ] NEW_LINE if ( isVowel ( ch ) ) : NEW_LINE INDENT nv += 1 NEW_LINE vstr = vstr + ch NEW_LINE DEDENT else : NEW_LINE INDENT nc += 1 NEW_LINE cstr = cstr + ch NEW_LINE DEDENT DEDENT if ( abs ( nv - nc ) >= 2 ) : NEW_LINE INDENT return \" no ▁ such ▁ string \" NEW_LINE DEDENT if ( nv - nc ) >= 2 ) : NEW_LINE INDENT return \" no ▁ such \" NEW_LINE DEDENT if ( nv [ 0 ] + createAltStr ( curr , vt , 1 , n ) ) : NEW_LINE INDENT return \" no ▁ such ▁ string [ 0 ] + createAltStr ( curr , ct ) NEW_LINE DEDENT return \" \" NEW_LINE DEDENT str = \" geeks \" NEW_LINE print ( findAltStr ( str ) ) NEW_LINE"],"references":["def isVowel ( ch ) : NEW_LINE INDENT if ( ch == ' a ' or ch == ' e ' or ch == ' i ' or ch == ' o ' or ch == ' u ' ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def createAltStr ( str1 , str2 , start , l ) : NEW_LINE INDENT finalStr = \" \" NEW_LINE i = 0 NEW_LINE for j in range ( start , l ) : NEW_LINE INDENT finalStr = ( finalStr + str1 [ i ] ) + str2 [ j ] NEW_LINE i + 1 NEW_LINE DEDENT return finalStr NEW_LINE DEDENT def findAltStr ( str1 ) : NEW_LINE INDENT nv = 0 NEW_LINE nc = 0 NEW_LINE vstr = \" \" NEW_LINE cstr = \" \" NEW_LINE l = len ( str1 ) NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT if ( isVowel ( str1 [ i ] ) ) : NEW_LINE INDENT nv += 1 NEW_LINE vstr = vstr + str1 [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT nc += 1 NEW_LINE cstr = cstr + str1 [ i ] NEW_LINE DEDENT DEDENT if ( abs ( nv - nc ) >= 2 ) : NEW_LINE INDENT return \" no ▁ such ▁ string \" NEW_LINE DEDENT if ( nv > nc ) : NEW_LINE INDENT return ( vstr [ 0 ] + createAltStr ( cstr , vstr , 1 , nv ) ) NEW_LINE DEDENT if ( nc > nv ) : NEW_LINE INDENT return ( cstr [ 0 ] + createAltStr ( vstr , cstr , 1 , nc ) ) NEW_LINE DEDENT if ( cstr [ 0 ] < vstr [ 0 ] ) : NEW_LINE INDENT return createAltStr ( cstr , vstr , 0 , nv ) NEW_LINE DEDENT return createAltStr ( vstr , cstr , 0 , nc ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" geeks \" NEW_LINE print ( findAltStr ( str1 ) ) NEW_LINE DEDENT"],"bleu":0.6086305863803992,"rouge_l":0.7516330166270784}
{"id":636,"predictions":["def convertToString ( num ) : NEW_LINE INDENT return str ( num ) NEW_LINE DEDENT def convertToString ( num ) : NEW_LINE INDENT return str ( num ) NEW_LINE DEDENT def calculate ( pos , tight , D , Sz , sz , num ) : NEW_LINE INDENT if ( pos == len ( num ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( dp [ pos ] [ tight ] [ tight ] != - 1 ) : NEW_LINE INDENT return dp [ pos ] [ tight ] NEW_LINE DEDENT val = 0 NEW_LINE if ( tight == 0 ) : NEW_LINE INDENT for i in range ( sz ) : NEW_LINE INDENT if ( D [ i ] < ( num [ pos ] ) : NEW_LINE INDENT val += calculate ( pos + 1 , 1 , 1 , Dz , sz , num ) NEW_LINE DEDENT elif ( D [ i ] == num [ pos ] - ord ( '0' ) ) ) : NEW_LINE INDENT val += calculate ( pos + 1 , tight , DEDENT DEDENT else : NEW_LINE INDENT for i in range ( sz ) : NEW_LINE INDENT val += calculate ( pos + 1 , tight , Dz , sz , num ) NEW_LINE DEDENT DEDENT DEDENT dp [ pos ] [ tight ] = val NEW_LINE return val NEW_LINE DEDENT def countNumbers ( D , N , sz ) : NEW_LINE INDENT num = convertToString ( N ) NEW_LINE len = len ( num ) NEW_LINE for i in range ( 2 ) : NEW_LINE INDENT ans += calculate ( i , 1 , D , D , len ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT sz = 3 NEW_LINE DEDENT"],"references":["import numpy as np ; NEW_LINE dp = np . ones ( ( 15 , 2 ) ) * - 1 ; NEW_LINE def convertToString ( num ) : NEW_LINE INDENT return str ( num ) ; NEW_LINE DEDENT def calculate ( pos , tight , D , sz , num ) : NEW_LINE INDENT if ( pos == len ( num ) ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT if ( dp [ pos ] [ tight ] != - 1 ) : NEW_LINE INDENT return dp [ pos ] [ tight ] ; NEW_LINE DEDENT val = 0 ; NEW_LINE if ( tight == 0 ) : NEW_LINE INDENT for i in range ( sz ) : NEW_LINE INDENT if ( D [ i ] < ( ord ( num [ pos ] ) - ord ( '0' ) ) ) : NEW_LINE INDENT val += calculate ( pos + 1 , 1 , D , sz , num ) ; NEW_LINE DEDENT elif ( D [ i ] == ord ( num [ pos ] ) - ord ( '0' ) ) : NEW_LINE INDENT val += calculate ( pos + 1 , tight , D , sz , num ) ; NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT for i in range ( sz ) : NEW_LINE INDENT val += calculate ( pos + 1 , tight , D , sz , num ) ; NEW_LINE DEDENT DEDENT dp [ pos ] [ tight ] = val ; NEW_LINE return dp [ pos ] [ tight ] ; NEW_LINE DEDENT def countNumbers ( D , N , sz ) : NEW_LINE INDENT num = convertToString ( N ) ; NEW_LINE length = len ( num ) ; NEW_LINE ans = calculate ( 0 , 0 , D , sz , num ) ; NEW_LINE for i in range ( 1 , length ) : NEW_LINE INDENT ans += calculate ( i , 1 , D , sz , num ) ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT sz = 3 ; NEW_LINE D = [ 1 , 4 , 9 ] ; NEW_LINE N = 10 ; NEW_LINE print ( countNumbers ( D , N , sz ) ) ; NEW_LINE DEDENT"],"bleu":0.6177441698778907,"rouge_l":0.7826604958071759}
{"id":637,"predictions":["def summation ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( i * i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 2 NEW_LINE print ( summation ( n ) ) NEW_LINE"],"references":["def summation ( n ) : NEW_LINE INDENT return sum ( [ i ** 2 for i in range ( 1 , n + 1 ) ] ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 2 NEW_LINE print ( summation ( n ) ) NEW_LINE DEDENT"],"bleu":0.5634336754042605,"rouge_l":0.6672743846855059}
{"id":638,"predictions":["def countPairs ( arr , n ) : NEW_LINE INDENT frequency = dict . fromkeys ( arr , 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT frequency [ arr [ i ] ] += 1 NEW_LINE DEDENT count = 0 NEW_LINE for f in frequency . values ( ) : NEW_LINE INDENT count += f * ( f - 1 ) \/\/ 2 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE DEDENT"],"references":["from collections import defaultdict NEW_LINE def countPairs ( a , n ) : NEW_LINE INDENT frequency = defaultdict ( int ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT frequency [ a [ i ] ] += 1 NEW_LINE DEDENT count = 0 NEW_LINE for x in frequency . keys ( ) : NEW_LINE INDENT f = frequency [ x ] NEW_LINE count += f * ( f - 1 ) \/\/ 2 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.7708787281595734,"rouge_l":0.877036834177735}
{"id":639,"predictions":["def search ( a , k , x ) : NEW_LINE INDENT for j in range ( k - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( search ( arr , i , arr [ i ] ) == x ) : NEW_LINE INDENT arr [ i + 1 ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i + 1 ] = ( i - search ( arr , i , arr [ i ] ) ) NEW_LINE DEDENT DEDENT DEDENT def genArray ( arr , N ) : NEW_LINE INDENT for i in range ( N - 1 ) : NEW_LINE INDENT if ( search ( arr , i , arr [ i ] ) == - 1 ) : NEW_LINE INDENT arr [ i + 1 ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i + 1 ] = ( i - search ( arr , i , arr [ i ] ) ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 5 NEW_LINE size = N + 1 NEW_LINE a = [ ] NEW_LINE generateArray ( a , N ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT print ( a [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT"],"references":["def search ( a , k , x ) : NEW_LINE INDENT for j in range ( k - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( a [ j ] == x ) : NEW_LINE INDENT return j NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT def genArray ( arr , N ) : NEW_LINE INDENT for i in range ( 0 , N - 1 , 1 ) : NEW_LINE INDENT if ( search ( arr , i , arr [ i ] ) == - 1 ) : NEW_LINE INDENT arr [ i + 1 ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i + 1 ] = ( i - search ( arr , i , arr [ i ] ) ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 5 NEW_LINE size = N + 1 NEW_LINE a = [ 0 ] * N NEW_LINE genArray ( a , N ) NEW_LINE print ( a ) NEW_LINE DEDENT"],"bleu":0.6625184395675571,"rouge_l":0.8247247409326424}
{"id":640,"predictions":["maxN = 20 NEW_LINE maxM = 64 NEW_LINE def cntSplits ( s ) : NEW_LINE INDENT if ( s [ - 1 ] == '1' ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT c_zero = 0 NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT c_zero += ( s [ i ] == '0' ) NEW_LINE DEDENT return ( pow ( 2 , c_zero - 1 ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \"10010\" NEW_LINE print ( cntSplits ( s ) ) NEW_LINE DEDENT"],"references":["def cntSplits ( s ) : NEW_LINE INDENT if ( s [ len ( s ) - 1 ] == '1' ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT c_zero = 0 ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT c_zero += ( s [ i ] == '0' ) ; NEW_LINE DEDENT return int ( pow ( 2 , c_zero - 1 ) ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \"10010\" ; NEW_LINE print ( cntSplits ( s ) ) ; NEW_LINE DEDENT"],"bleu":0.75853142076132,"rouge_l":0.8977686342775755}
{"id":641,"predictions":["MAX = 100 NEW_LINE def middleum ( mat , n ) : NEW_LINE INDENT row_sum = 0 NEW_LINE col_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT row_sum += mat [ n \/\/ 2 ] [ i ] NEW_LINE DEDENT print ( \" Sum ▁ of ▁ middle ▁ row ▁ = ▁ \" , row_sum ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT row_sum += mat [ i ] [ n \/\/ 2 ] NEW_LINE DEDENT print ( \" Sum ▁ of ▁ middle ▁ column ▁ = ▁ \" , col_sum ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT mat = [ 2 , 5 , 7 ] , [ 3 , 7 , 2 ] , [ 5 , 6 , 9 ] ] NEW_LINE middlesum ( mat , 3 ) NEW_LINE DEDENT"],"references":["def middlesum ( mat , n ) : NEW_LINE INDENT row_sum = 0 NEW_LINE col_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT row_sum += mat [ n \/\/ 2 ] [ i ] NEW_LINE DEDENT print ( \" Sum ▁ of ▁ middle ▁ row ▁ = ▁ \" , row_sum ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT col_sum += mat [ i ] [ n \/\/ 2 ] NEW_LINE DEDENT print ( \" Sum ▁ of ▁ middle ▁ column ▁ = ▁ \" , col_sum ) NEW_LINE DEDENT mat = [ [ 2 , 5 , 7 ] , [ 3 , 7 , 2 ] , [ 5 , 6 , 9 ] ] NEW_LINE middlesum ( mat , 3 ) NEW_LINE"],"bleu":0.8179912851913689,"rouge_l":0.9249800478850757}
{"id":642,"predictions":["def Vertices ( x , y ) : NEW_LINE INDENT val = abs ( x ) + abs ( y ) NEW_LINE print ( val * ( y ) - 1 ) NEW_LINE print ( val * ( y ) ) NEW_LINE DEDENT x = 3 NEW_LINE y = 3 NEW_LINE Vertices ( x , y ) NEW_LINE"],"references":["def Vertices ( x , y ) : NEW_LINE INDENT val = abs ( x ) + abs ( y ) ; NEW_LINE if x < 0 : NEW_LINE INDENT x = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT x = 1 NEW_LINE DEDENT print ( val * x , \"0\" , end = \" ▁ \" ) ; NEW_LINE if y < 0 : NEW_LINE INDENT y = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT y = 1 NEW_LINE DEDENT print ( \"0\" , val * y ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = 3 ; y = 3 ; NEW_LINE Vertices ( x , y ) ; NEW_LINE DEDENT"],"bleu":0.19153070493572463,"rouge_l":0.533109243697479}
{"id":643,"predictions":["from math import sqrt NEW_LINE def isPrime ( n ) : NEW_LINE INDENT for i in range ( 2 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def printMinCountPrime ( N ) : NEW_LINE INDENT if ( isPrime ( N ) ) : NEW_LINE INDENT minCount = 1 NEW_LINE DEDENT elif ( N % 2 == 0 ) : NEW_LINE INDENT minCount = 2 NEW_LINE DEDENT else : NEW_LINE INDENT if ( isPrime ( N - 2 ) ) : NEW_LINE INDENT minCount = 2 NEW_LINE DEDENT else : NEW_LINE INDENT minCount = 3 NEW_LINE DEDENT DEDENT print ( minCount ) NEW_LINE DEDENT N = 100 NEW_LINE printMinCountPrime ( N ) NEW_LINE"],"references":["def isPrime ( n ) : NEW_LINE INDENT for i in range ( 2 , int ( n ** ( 1 \/ 2 ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT def printMinCountPrime ( N ) : NEW_LINE INDENT if ( isPrime ( N ) ) : NEW_LINE INDENT minCount = 1 ; NEW_LINE DEDENT elif ( N % 2 == 0 ) : NEW_LINE INDENT minCount = 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( isPrime ( N - 2 ) ) : NEW_LINE INDENT minCount = 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT minCount = 3 ; NEW_LINE DEDENT DEDENT print ( minCount ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 100 ; NEW_LINE printMinCountPrime ( N ) ; NEW_LINE DEDENT"],"bleu":0.7134398071774638,"rouge_l":0.8710486156529323}
{"id":644,"predictions":["def findCount ( d ) : NEW_LINE INDENT return 9 * ( pow ( 10 , d - 1 ) - pow ( 9 , d - 1 ) ) ) NEW_LINE DEDENT def findCountUpt ( d ) : NEW_LINE INDENT totalCount = 0 NEW_LINE for i in range ( 1 , d + 1 ) : NEW_LINE INDENT totalCount += findCount ( i ) NEW_LINE DEDENT return totalCount NEW_LINE DEDENT d = 1 NEW_LINE print ( findCountUpto ( d ) ) NEW_LINE d = 2 NEW_LINE print ( findCountUpt ( d ) ) NEW_LINE d = 4 NEW_LINE print ( findCountUpto ( d ) ) NEW_LINE"],"references":["import math NEW_LINE def findCountUpto ( d ) : NEW_LINE INDENT GP1_Sum = 9 * ( ( int ) ( ( math . pow ( 10 , d ) ) - 1 ) \/\/ 9 ) NEW_LINE GP2_Sum = 9 * ( ( int ) ( ( math . pow ( 9 , d ) ) - 1 ) \/\/ 8 ) NEW_LINE return GP1_Sum - GP2_Sum NEW_LINE DEDENT d = 1 NEW_LINE print ( findCountUpto ( d ) ) NEW_LINE d = 2 NEW_LINE print ( findCountUpto ( d ) ) NEW_LINE d = 4 NEW_LINE print ( findCountUpto ( d ) ) NEW_LINE"],"bleu":0.5102946924605452,"rouge_l":0.642602633617351}
{"id":645,"predictions":["def two_sets ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE return a [ int ( n \/ 2 ) ] - a [ int ( n \/ 2 ) - 1 ] NEW_LINE DEDENT a = [ 1 , 4 , 4 , 6 , 7 , 9 ] NEW_LINE n = len ( a ) NEW_LINE print ( two_sets ( a , n ) ) NEW_LINE"],"references":["def two_sets ( a , n ) : NEW_LINE INDENT a . sort ( ) ; NEW_LINE return ( a [ n \/\/ 2 ] - a [ ( n \/\/ 2 ) - 1 ] ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 4 , 4 , 6 , 7 , 9 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( two_sets ( a , n ) ) ; NEW_LINE DEDENT"],"bleu":0.5571999069145577,"rouge_l":0.8069101678183614}
{"id":646,"predictions":["def maximumArea ( l , b , x , y ) : NEW_LINE INDENT left = x * b NEW_LINE right = ( l - x - 1 ) * b NEW_LINE above = ( b - y - 1 ) * l NEW_LINE print ( max ( left , right ) , max ( above , below ) ) NEW_LINE DEDENT L = 8 NEW_LINE B = 8 NEW_LINE X = 0 NEW_LINE Y = 0 NEW_LINE maximumArea ( L , B , X , Y ) NEW_LINE"],"references":["def maximumArea ( l , b , x , y ) : NEW_LINE INDENT left , right , above , below = 0 , 0 , 0 , 0 NEW_LINE left = x * b NEW_LINE right = ( l - x - 1 ) * b NEW_LINE above = l * y NEW_LINE below = ( b - y - 1 ) * l NEW_LINE print ( max ( max ( left , right ) , max ( above , below ) ) ) NEW_LINE DEDENT l = 8 NEW_LINE b = 8 NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE maximumArea ( l , b , x , y ) NEW_LINE"],"bleu":0.5855713081577691,"rouge_l":0.7806920524569441}
{"id":647,"predictions":["def check ( arr , N , K ) : NEW_LINE INDENT unique = set ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT unique . add ( arr [ i ] ) NEW_LINE DEDENT if ( len ( unique ) == K ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT arr = [ 1 , 1 , 2 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE K = 3 NEW_LINE if ( check ( arr , N , K ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def check ( arr , N , K ) : NEW_LINE INDENT unique = dict ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT unique [ arr [ i ] ] = 1 NEW_LINE DEDENT if len ( unique ) == K : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT arr = [ 1 , 1 , 2 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE K = 3 NEW_LINE if ( check ( arr , N , K ) == True ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.858837801873693,"rouge_l":0.9396551724137933}
{"id":648,"predictions":["def risedPecker ( a , b ) : NEW_LINE INDENT res = 0 NEW_LINE while ( b ) : NEW_LINE INDENT if ( ( b & 1 ) != 0 ) : NEW_LINE INDENT res = res + a NEW_LINE DEDENT a = a << 1 NEW_LINE b = b >> 1 NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( rfillPeaks ( 18 , 1 ) ) NEW_LINE print ( rumping ( 18 , 12 ) ) NEW_LINE DEDENT"],"references":["def russianPeasant ( a , b ) : NEW_LINE INDENT res = 0 NEW_LINE while ( b > 0 ) : NEW_LINE INDENT if ( b & 1 ) : NEW_LINE INDENT res = res + a NEW_LINE DEDENT a = a << 1 NEW_LINE b = b >> 1 NEW_LINE DEDENT return res NEW_LINE DEDENT print ( russianPeasant ( 18 , 1 ) ) NEW_LINE print ( russianPeasant ( 20 , 12 ) ) NEW_LINE"],"bleu":0.6699318539767378,"rouge_l":0.8478951548848291}
{"id":649,"predictions":["import sys NEW_LINE def FindMinimumCost ( ind , a , n , k , dp ) : NEW_LINE INDENT if ( ind == ( n - 1 ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( dp [ ind ] != - 1 ) : NEW_LINE INDENT return dp [ ind ] NEW_LINE DEDENT else : NEW_LINE INDENT ans = sys . maxsize - 1 NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT if ( ind + i < n ) : NEW_LINE INDENT ans = min ( ans , abs ( a [ ind + i ] - a [ ind ] ) + FindMinimumCost ( ind + i , a , n , k , dp ) ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT dp [ ind ] = ans NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 10 , 30 , 40 , 50 , 20 ] NEW_LINE k = 3 NEW_LINE n = len ( a ) NEW_LINE dp = [ - 1 for i in range ( n ) ] NEW_LINE print ( FindMinimumCost ( 0 , a , n , k , dp ) ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE def FindMinimumCost ( ind , a , n , k , dp ) : NEW_LINE INDENT if ( ind == ( n - 1 ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( dp [ ind ] != - 1 ) : NEW_LINE INDENT return dp [ ind ] NEW_LINE DEDENT else : NEW_LINE INDENT ans = sys . maxsize NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT if ( ind + i < n ) : NEW_LINE INDENT ans = min ( ans , abs ( a [ ind + i ] - a [ ind ] ) + FindMinimumCost ( ind + i , a , n , k , dp ) ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT dp [ ind ] = ans NEW_LINE return ans NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 10 , 30 , 40 , 50 , 20 ] NEW_LINE k = 3 NEW_LINE n = len ( a ) NEW_LINE dp = [ - 1 for i in range ( n ) ] NEW_LINE print ( FindMinimumCost ( 0 , a , n , k , dp ) ) NEW_LINE DEDENT"],"bleu":0.9537379143426992,"rouge_l":0.977064220183486}
{"id":650,"predictions":["def longestPalindromic ( str1 , i , j , count ) : NEW_LINE INDENT if ( i > j ) : NEW_LINE INDENT return x NEW_LINE DEDENT if ( i == j ) : NEW_LINE INDENT return ( count + 1 ) NEW_LINE DEDENT if ( str1 [ i ] == str1 [ j ] ) : NEW_LINE INDENT count = longestPalindromic ( str1 , i + 1 , j - 1 , count + 2 ) NEW_LINE return max ( count , max ( longestPalindromic ( str1 , i , j , 0 ) , longestPalindromic ( str1 , i , j - 1 , 0 ) ) ) ) NEW_LINE DEDENT return max ( longestPalindromic ( str1 , i + 1 , j , 0 ) , longestPalindromic ( str1 , i , j - 1 , 0 ) ) NEW_LINE DEDENT def longest_palindromic ( str1 ) : NEW_LINE INDENT return longestPalindromic ( str1 , 0 , len1 ) - 1 , 0 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" aaaabbaa \" NEW_LINE print ( longest_palindromic ( str1 ) ) NEW_LINE DEDENT"],"references":["def maxi ( x , y ) : NEW_LINE INDENT if x > y : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT return y NEW_LINE DEDENT DEDENT def longestPalindromic ( strn , i , j , count ) : NEW_LINE INDENT if i > j : NEW_LINE INDENT return count NEW_LINE DEDENT if i == j : NEW_LINE INDENT return ( count + 1 ) NEW_LINE DEDENT if strn [ i ] == strn [ j ] : NEW_LINE INDENT count = longestPalindromic ( strn , i + 1 , j - 1 , count + 2 ) NEW_LINE return maxi ( count , maxi ( longestPalindromic ( strn , i + 1 , j , 0 ) , longestPalindromic ( strn , i , j - 1 , 0 ) ) ) NEW_LINE DEDENT return maxi ( longestPalindromic ( strn , i + 1 , j , 0 ) , longestPalindromic ( strn , i , j - 1 , 0 ) ) NEW_LINE DEDENT def longest_palindromic_substr ( strn ) : NEW_LINE INDENT k = len ( strn ) - 1 NEW_LINE return longestPalindromic ( strn , 0 , k , 0 ) NEW_LINE DEDENT strn = \" aaaabbaa \" NEW_LINE print ( longest_palindromic_substr ( strn ) ) NEW_LINE"],"bleu":0.553447603779501,"rouge_l":0.7392170931993941}
{"id":651,"predictions":["def countPairs ( str ) : NEW_LINE INDENT result = 0 NEW_LINE n = len ( str ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT j = 1 NEW_LINE while ( ( i + j ) < n and j <= MAX_CHAR ) : NEW_LINE INDENT if ( ( abs ( ord ( str [ i + j ] ) - str [ i ] ) == j ) ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT str = \" geeksforgeeks \" NEW_LINE print ( countPairs ( str ) ) NEW_LINE"],"references":["MAX_CHAR = 26 NEW_LINE def countPairs ( str1 ) : NEW_LINE INDENT result = 0 ; NEW_LINE n = len ( str1 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 1 , MAX_CHAR + 1 ) : NEW_LINE INDENT if ( ( i + j ) < n ) : NEW_LINE INDENT if ( ( abs ( ord ( str1 [ i + j ] ) - ord ( str1 [ i ] ) ) == j ) ) : NEW_LINE INDENT result += 1 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" geeksforgeeks \" ; NEW_LINE print ( countPairs ( str1 ) ) NEW_LINE DEDENT"],"bleu":0.47752121733157205,"rouge_l":0.7310252996005326}
{"id":652,"predictions":["def countSetBits ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( n ) : NEW_LINE INDENT count += n & 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def countOfOdds ( n ) : NEW_LINE INDENT c = bits ( n ) NEW_LINE return pow ( 2 , c ) NEW_LINE DEDENT n = 20 NEW_LINE print ( countOfOddsPascal ( n ) ) NEW_LINE"],"references":["def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while n : NEW_LINE INDENT count += n & 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def countOfOddPascal ( n ) : NEW_LINE INDENT c = countSetBits ( n ) NEW_LINE return pow ( 2 , c ) NEW_LINE DEDENT n = 20 NEW_LINE print ( countOfOddPascal ( n ) ) NEW_LINE"],"bleu":0.7958729964405249,"rouge_l":0.9389059910016576}
{"id":653,"predictions":["def rearrange ( arr , n ) : NEW_LINE INDENT i = - 1 NEW_LINE j = n NEW_LINE while ( i < j ) : NEW_LINE INDENT while ( arr [ i ] > 0 ) : NEW_LINE INDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT if ( i < j ) : NEW_LINE INDENT arr [ i ] , arr [ j ] = j - 1 NEW_LINE DEDENT DEDENT if ( i == 0 or i == n ) : NEW_LINE INDENT return NEW_LINE DEDENT k = 0 NEW_LINE while ( k < n and i < n ) : NEW_LINE INDENT arr [ k ] , i = i + 1 NEW_LINE k = i + 2 NEW_LINE k = k + 2 NEW_LINE DEDENT DEDENT def printArray ( arr , index1 , index2 ) : NEW_LINE INDENT for i in range ( k ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def printArray ( arr , index1 , index2 ) : NEW_LINE INDENT c = arr [ index1 ] NEW_LINE arr [ index1 ] = arr [ index2 ] NEW_LINE arr [ index2 ] = c NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 3 , - 4 , - 1 , 6 , - 9 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Given ▁ array ▁ is \" ) NEW_LINE print ( arr , n ) NEW_LINE printArray ( arr , n ) NEW_LINE printArray ( arr , n ) NEW_LINE rearrange ( arr , n ) NEW_LINE print ( arr ) NEW_LINE DEDENT"],"references":["def rearrange ( arr , n ) : NEW_LINE INDENT i = 0 NEW_LINE j = n - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT while ( arr [ i ] > 0 ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT while ( arr [ j ] < 0 ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT if ( i < j ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE arr [ i ] = arr [ j ] NEW_LINE arr [ j ] = temp NEW_LINE DEDENT DEDENT if ( i == 0 or i == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT k = 0 NEW_LINE while ( k < n and i < n ) : NEW_LINE INDENT temp = arr [ k ] NEW_LINE arr [ k ] = arr [ i ] NEW_LINE arr [ i ] = temp NEW_LINE i = i + 1 NEW_LINE k = k + 2 NEW_LINE DEDENT DEDENT def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( \" \\n \" ) NEW_LINE DEDENT arr = [ 2 , 3 , - 4 , - 1 , 6 , - 9 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Given ▁ array ▁ is \" ) NEW_LINE printArray ( arr , n ) NEW_LINE rearrange ( arr , n ) NEW_LINE print ( \" Rearranged ▁ array ▁ is \" ) NEW_LINE printArray ( arr , n ) NEW_LINE"],"bleu":0.7263536942159101,"rouge_l":0.7506836827711942}
{"id":654,"predictions":["def countDivisibles ( A , B , M ) : NEW_LINE INDENT if ( A % M == 0 ) : NEW_LINE INDENT return ( B \/\/ M ) - ( A \/\/ M ) + 1 NEW_LINE DEDENT return ( B \/\/ M ) - ( A \/\/ M ) NEW_LINE DEDENT A = 30 NEW_LINE B = 100 NEW_LINE M = 30 NEW_LINE print ( countDivisibles ( A , B , M ) ) NEW_LINE"],"references":["def countDivisibles ( A , B , M ) : NEW_LINE INDENT if ( A % M == 0 ) : NEW_LINE INDENT return ( ( B \/ M ) - ( A \/ M ) ) + 1 NEW_LINE DEDENT return ( ( B \/ M ) - ( A \/ M ) ) NEW_LINE DEDENT A = 30 NEW_LINE B = 70 NEW_LINE M = 10 NEW_LINE print ( countDivisibles ( A , B , M ) ) NEW_LINE"],"bleu":0.7286325517807021,"rouge_l":0.894649865730221}
{"id":655,"predictions":["def findMissing ( arr , n ) : NEW_LINE INDENT l = 0 NEW_LINE h = n - 1 NEW_LINE while ( h > l ) : NEW_LINE INDENT mid = l + ( h - l ) \/\/ 2 NEW_LINE if ( arr [ mid ] - mid == arr [ mid ] ) : NEW_LINE INDENT if ( arr [ mid + 1 ] - arr [ mid ] > 1 ) : NEW_LINE INDENT return arr [ mid ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( arr [ mid ] - arr [ mid - 1 ] > 1 ) : NEW_LINE INDENT return arr [ mid ] - 1 NEW_LINE DEDENT else : NEW_LINE INDENT h = mid - 1 NEW_LINE DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ - 9 , - 8 , - 5 , - 4 , - 3 , - 2 , - 1 , - 1 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMissing ( arr , n ) ) NEW_LINE"],"references":["def findMissing ( arr , n ) : NEW_LINE INDENT l , h = 0 , n - 1 NEW_LINE mid = 0 NEW_LINE while ( h > l ) : NEW_LINE INDENT mid = l + ( h - l ) \/\/ 2 NEW_LINE if ( arr [ mid ] - mid == arr [ 0 ] ) : NEW_LINE INDENT if ( arr [ mid + 1 ] - arr [ mid ] > 1 ) : NEW_LINE INDENT return arr [ mid ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( arr [ mid ] - arr [ mid - 1 ] > 1 ) : NEW_LINE INDENT return arr [ mid ] - 1 NEW_LINE DEDENT else : NEW_LINE INDENT h = mid - 1 NEW_LINE DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ - 9 , - 8 , - 7 , - 5 , - 4 , - 3 , - 2 , - 1 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMissing ( arr , n ) ) NEW_LINE"],"bleu":0.92983574165777,"rouge_l":0.9525708115291969}
{"id":656,"predictions":["def maxSum ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n - 1 , 2 ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT arr = [ 1 , 3 , 2 , 1 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxSum ( arr , n ) ) NEW_LINE"],"references":["def maxSum ( a , n ) : NEW_LINE INDENT a . sort ( ) ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( 0 , n - 1 , 2 ) : NEW_LINE INDENT sum += a [ i ] ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 3 , 2 , 1 , 4 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( maxSum ( arr , n ) ) ; NEW_LINE DEDENT"],"bleu":0.6211302288040907,"rouge_l":0.8533734726403401}
{"id":657,"predictions":["def trailing_zos ( N ) : NEW_LINE INDENT count_of_two = 0 NEW_LINE count_of_five = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT val = i NEW_LINE while ( val % 2 == 0 and val > 0 ) : NEW_LINE INDENT val \/\/= 2 NEW_LINE count_of_two += i NEW_LINE DEDENT while ( val % 5 == 0 and val > 0 ) : NEW_LINE INDENT val \/\/= 5 NEW_LINE count_of_five += i NEW_LINE DEDENT DEDENT ans = min ( count_of_two , count_of_five ) NEW_LINE return ans NEW_LINE DEDENT N = 12 NEW_LINE print ( trailing_zero ( N ) ) NEW_LINE"],"references":["def trailing_zeros ( N ) : NEW_LINE INDENT count_of_two = 0 NEW_LINE count_of_five = 0 NEW_LINE for i in range ( 1 , N + 1 , 1 ) : NEW_LINE INDENT val = i NEW_LINE while ( val % 2 == 0 and val > 0 ) : NEW_LINE INDENT val \/= 2 NEW_LINE count_of_two += i NEW_LINE DEDENT while ( val % 5 == 0 and val > 0 ) : NEW_LINE INDENT val \/= 5 NEW_LINE count_of_five += i NEW_LINE DEDENT DEDENT ans = min ( count_of_two , count_of_five ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 12 NEW_LINE print ( trailing_zeros ( N ) ) NEW_LINE DEDENT"],"bleu":0.7682132196568178,"rouge_l":0.8855388051367952}
{"id":658,"predictions":["def sumOfSubstrings ( num ) : NEW_LINE INDENT n = len ( num ) NEW_LINE sumofdigit = [ 0 for i in range ( n ) ] NEW_LINE sumofdigit [ 0 ] = ord ( num [ 0 ] ) - ord ( '0' ) NEW_LINE res = sumofdigit [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT numi = ord ( num [ i ] ) - ord ( '0' ) NEW_LINE sumofdigit [ i ] = ( i + 1 ) * numi + 10 * sumofdigit [ i - 1 ] NEW_LINE res += sumofdigit [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT num = \"1234\" NEW_LINE print ( sumofSubstrings ( num ) ) NEW_LINE"],"references":["def sumOfSubstrings ( num ) : NEW_LINE INDENT n = len ( num ) NEW_LINE sumofdigit = [ ] NEW_LINE sumofdigit . append ( int ( num [ 0 ] ) ) NEW_LINE res = sumofdigit [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT numi = int ( num [ i ] ) NEW_LINE sumofdigit . append ( ( i + 1 ) * numi + 10 * sumofdigit [ i - 1 ] ) NEW_LINE res += sumofdigit [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT num = \"1234\" NEW_LINE print ( sumOfSubstrings ( num ) ) NEW_LINE"],"bleu":0.6879677466437838,"rouge_l":0.8493890309747087}
{"id":659,"predictions":["import math NEW_LINE def sumOfDiv ( x ) : NEW_LINE INDENT sum = 1 NEW_LINE for i in range ( 2 , int ( math . sqrt ( x ) ) + 1 ) : NEW_LINE INDENT if x % i == 0 : NEW_LINE INDENT sum += i NEW_LINE if x \/\/ i != i : NEW_LINE INDENT sum += x \/\/ i NEW_LINE DEDENT DEDENT DEDENT return sum NEW_LINE DEDENT def isAmicable ( a , b ) : NEW_LINE INDENT s = dict ( ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s [ arr [ i ] ] = 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if sumOfDiv ( arr [ i ] ) in s : NEW_LINE INDENT sum = sumOfDiv ( arr [ i ] ) NEW_LINE if isAmicable ( arr [ i ] , sum ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return int ( count \/ 2 ) NEW_LINE DEDENT arr1 = [ 220 , 284 , 1184 , 1210 , 2 , 5 ] NEW_LINE n1 = len ( arr1 ) NEW_LINE print ( countPairs ( arr1 , n1 ) ) NEW_LINE arr2 = [ 2620 , 2924 , 5020 , 5564 , 6232 ] NEW_LINE n2 = len ( arr2 ) NEW_LINE print ( countPairs ( arr2 , n2 ) ) NEW_LINE"],"references":["import math NEW_LINE def sumOfDiv ( x ) : NEW_LINE INDENT sum = 1 ; NEW_LINE for i in range ( 2 , int ( math . sqrt ( x ) ) ) : NEW_LINE INDENT if x % i == 0 : NEW_LINE INDENT sum += i NEW_LINE if i != x \/ i : NEW_LINE INDENT sum += x \/ i NEW_LINE DEDENT DEDENT DEDENT return int ( sum ) ; NEW_LINE DEDENT def isAmbicle ( a , b ) : NEW_LINE INDENT return ( sumOfDiv ( a ) == b and sumOfDiv ( b ) == a ) NEW_LINE DEDENT def countPairs ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if sumOfDiv ( arr [ i ] ) in s : NEW_LINE INDENT sum = sumOfDiv ( arr [ i ] ) NEW_LINE if isAmbicle ( arr [ i ] , sum ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return int ( count \/ 2 ) ; NEW_LINE DEDENT arr1 = [ 220 , 284 , 1184 , 1210 , 2 , 5 ] NEW_LINE n1 = len ( arr1 ) NEW_LINE print ( countPairs ( arr1 , n1 ) ) NEW_LINE arr2 = [ 2620 , 2924 , 5020 , 5564 , 6232 , 6368 ] NEW_LINE n2 = len ( arr2 ) NEW_LINE print ( countPairs ( arr2 , n2 ) ) NEW_LINE"],"bleu":0.751505146103602,"rouge_l":0.8762260330317029}
{"id":660,"predictions":["def grayCount ( n ) : NEW_LINE INDENT return n ^ ( n >> 1 ) ; NEW_LINE DEDENT n = 10 ; NEW_LINE print ( int ( x ) ) ; NEW_LINE"],"references":["def grayCode ( n ) : NEW_LINE INDENT return n ^ ( n >> 1 ) NEW_LINE DEDENT n = 10 NEW_LINE print ( grayCode ( n ) ) NEW_LINE"],"bleu":0.5954734991945729,"rouge_l":0.8645669291338582}
{"id":661,"predictions":["def printNonSquare ( n ) : NEW_LINE INDENT curr_count = 2 NEW_LINE num = 2 NEW_LINE count = 0 NEW_LINE while ( count < n ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i < curr_count and count < n ) : NEW_LINE INDENT print ( num , end = \" ▁ \" ) NEW_LINE count += 1 NEW_LINE num += 1 NEW_LINE DEDENT num += 1 NEW_LINE curr_count += 2 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 10 NEW_LINE printNonSquare ( n ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def printNonSquare ( n ) : NEW_LINE INDENT curr_count = 2 NEW_LINE num = 2 NEW_LINE count = 0 NEW_LINE while ( count < n ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i < curr_count and count < n ) : NEW_LINE INDENT print ( num , end = \" ▁ \" ) NEW_LINE count = count + 1 NEW_LINE num = num + 1 NEW_LINE i = i + 1 NEW_LINE DEDENT num = num + 1 NEW_LINE curr_count = curr_count + 2 NEW_LINE DEDENT DEDENT n = 10 NEW_LINE printNonSquare ( n ) NEW_LINE"],"bleu":0.7181641712861231,"rouge_l":0.8038067349926793}
{"id":662,"predictions":["def sortWithSetbits ( arr , n , k ) : NEW_LINE INDENT v1 = [ ] NEW_LINE v2 = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( bin ( arr [ i ] ) . count ( '1' ) == k ) : NEW_LINE INDENT v1 . append ( i ) NEW_LINE v2 . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT v2 . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ v1 [ i ] ] = v2 [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 10 , 255 , 1 , 1 , 7 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE sortWithSetbits ( arr , n , k ) NEW_LINE DEDENT"],"references":["def sortWithSetbits ( arr , n , k ) : NEW_LINE INDENT v1 = [ ] NEW_LINE v2 = [ ] NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( bin ( arr [ i ] ) . count ( '1' ) == k ) : NEW_LINE INDENT v1 . append ( i ) NEW_LINE v2 . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT v2 . sort ( reverse = False ) NEW_LINE for i in range ( 0 , len ( v1 ) , 1 ) : NEW_LINE INDENT arr [ v1 [ i ] ] = v2 [ i ] NEW_LINE DEDENT for i in range ( 0 , n , 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 14 , 255 , 1 , 7 , 13 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE sortWithSetbits ( arr , n , k ) NEW_LINE DEDENT"],"bleu":0.8091705407850838,"rouge_l":0.9118086696562033}
{"id":663,"predictions":["def isRotation ( x , y ) : NEW_LINE INDENT x64 = x | ( x << 32 ) ; NEW_LINE while ( x64 >= y ) : NEW_LINE INDENT if ( x64 == y ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT x64 >>= 1 ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT x = 122 ; NEW_LINE y = 2147483678 ; NEW_LINE if ( isRotation ( x , y ) == False ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT"],"references":["def isRotation ( x , y ) : NEW_LINE INDENT x64 = x | ( x << 32 ) NEW_LINE while ( x64 >= y ) : NEW_LINE INDENT if ( ( x64 ) == y ) : NEW_LINE INDENT return True NEW_LINE DEDENT x64 >>= 1 NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = 122 NEW_LINE y = 2147483678 NEW_LINE if ( isRotation ( x , y ) == False ) : NEW_LINE INDENT print ( \" yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" no \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.6593110091132889,"rouge_l":0.8607536052101102}
{"id":664,"predictions":["def findXorSum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE mul = 1 NEW_LINE for i in range ( 30 ) : NEW_LINE INDENT c_odd = 0 NEW_LINE odd = False NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( arr [ j ] & ( 1 << i ) ) : NEW_LINE INDENT odd = ( not odd ) NEW_LINE DEDENT if ( odd ) : NEW_LINE INDENT c_odd += 1 NEW_LINE DEDENT DEDENT for j in range ( n ) : NEW_LINE INDENT sum += ( mul * c_odd ) NEW_LINE if ( ( arr [ j ] & ( 1 << i ) ) ) : NEW_LINE INDENT c_odd = ( n - j - c_odd ) NEW_LINE DEDENT DEDENT mul *= 2 NEW_LINE DEDENT return sum NEW_LINE DEDENT arr = [ 3 , 8 , 13 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findXorSum ( arr , n ) ) NEW_LINE"],"references":["def findXorSum ( arr , n ) : NEW_LINE INDENT Sum = 0 NEW_LINE mul = 1 NEW_LINE for i in range ( 30 ) : NEW_LINE INDENT c_odd = 0 NEW_LINE odd = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( ( arr [ j ] & ( 1 << i ) ) > 0 ) : NEW_LINE INDENT odd = ( ~ odd ) NEW_LINE DEDENT if ( odd ) : NEW_LINE INDENT c_odd += 1 NEW_LINE DEDENT DEDENT for j in range ( n ) : NEW_LINE INDENT Sum += ( mul * c_odd ) NEW_LINE if ( ( arr [ j ] & ( 1 << i ) ) > 0 ) : NEW_LINE INDENT c_odd = ( n - j - c_odd ) NEW_LINE DEDENT DEDENT mul *= 2 NEW_LINE DEDENT return Sum NEW_LINE DEDENT arr = [ 3 , 8 , 13 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findXorSum ( arr , n ) ) NEW_LINE"],"bleu":0.8732112356000342,"rouge_l":0.9499182928001538}
{"id":665,"predictions":["def calTime ( arr , n ) : NEW_LINE INDENT best = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT best += 1 \/ arr [ i ] NEW_LINE DEDENT return 1 \/ best NEW_LINE DEDENT arr = [ 6.0 , 3.0 , 4.0 ] NEW_LINE n = len ( arr ) NEW_LINE print ( calTime ( arr , n ) ) NEW_LINE"],"references":["def calTime ( arr , n ) : NEW_LINE INDENT work = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT work += 1 \/ arr [ i ] NEW_LINE DEDENT return 1 \/ work NEW_LINE DEDENT arr = [ 6.0 , 3.0 , 4.0 ] NEW_LINE n = len ( arr ) NEW_LINE print ( calTime ( arr , n ) , \" Hours \" ) NEW_LINE"],"bleu":0.8148188876809603,"rouge_l":0.9227133065469155}
{"id":666,"predictions":["def GetMinSubarrayLength ( a , n ) : NEW_LINE INDENT ans = max ( a [ 0 ] , a [ n - 1 ] ) NEW_LINE lo = 0 NEW_LINE hi = n - 1 NEW_LINE while ( lo < n and a [ lo ] % ans == 0 ) : NEW_LINE INDENT lo += 1 NEW_LINE DEDENT while ( hi > lo and a [ hi ] % ans == 0 ) : NEW_LINE INDENT hi -= 1 NEW_LINE DEDENT return ( hi - lo + 1 ) NEW_LINE DEDENT arr = [ 4 , 8 , 2 , 1 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE Length = GetMinSubarrayLength ( arr , N ) NEW_LINE print ( Length ) NEW_LINE"],"references":["def GetMinSubarrayLength ( a , n ) : NEW_LINE INDENT ans = max ( a [ 0 ] , a [ n - 1 ] ) NEW_LINE lo = 0 NEW_LINE hi = n - 1 NEW_LINE while ( lo < n and a [ lo ] % ans == 0 ) : NEW_LINE INDENT lo += 1 NEW_LINE DEDENT while ( hi > lo and a [ hi ] % ans == 0 ) : NEW_LINE INDENT hi -= 1 NEW_LINE DEDENT return ( hi - lo + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 8 , 2 , 1 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE length = GetMinSubarrayLength ( arr , N ) NEW_LINE print ( length ) NEW_LINE DEDENT"],"bleu":0.8519890248130507,"rouge_l":0.9246871992300287}
{"id":667,"predictions":["def maxSumBitonicSubArr ( arr , n ) : NEW_LINE INDENT misa = [ 0 ] * n ; NEW_LINE msds = [ 0 ] * n ; NEW_LINE misa [ 0 ] = arr [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i - 1 ] ) : NEW_LINE INDENT misa [ i ] = misa [ i - 1 ] + arr [ i ] ; NEW_LINE DEDENT else : NEW_LINE INDENT mii [ i ] = arr [ i ] ; NEW_LINE DEDENT msds [ n - 1 ] = arr [ n - 1 ] ; NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT msds [ i ] = msds [ i + 1 ] + arr [ i ] ; NEW_LINE DEDENT else : NEW_LINE INDENT msds [ i ] = arr [ i ] ; NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( max_sum < ( msi [ i ] + msds [ i ] ) ) : NEW_LINE INDENT max_sum = mii [ i ] + msds [ i ] - arr [ i ] ; NEW_LINE DEDENT DEDENT return max_sum ; NEW_LINE DEDENT arr = [ 5 , 3 , 9 , 2 , 7 , 6 , 4 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( \" Maximum ▁ Sum ▁ = \" , maxSumBitonicSubArr ( arr , n ) ) ; NEW_LINE"],"references":["def maxSumBitonicSubArr ( arr , n ) : NEW_LINE INDENT msis = [ None ] * n NEW_LINE msds = [ None ] * n NEW_LINE max_sum = 0 NEW_LINE msis [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i - 1 ] ) : NEW_LINE INDENT msis [ i ] = msis [ i - 1 ] + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT msis [ i ] = arr [ i ] NEW_LINE DEDENT DEDENT msds [ n - 1 ] = arr [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT msds [ i ] = msds [ i + 1 ] + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT msds [ i ] = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( max_sum < ( msis [ i ] + msds [ i ] - arr [ i ] ) ) : NEW_LINE INDENT max_sum = ( msis [ i ] + msds [ i ] - arr [ i ] ) NEW_LINE DEDENT DEDENT return max_sum NEW_LINE DEDENT arr = [ 5 , 3 , 9 , 2 , 7 , 6 , 4 ] ; NEW_LINE n = len ( arr ) NEW_LINE print ( \" Maximum ▁ Sum ▁ = ▁ \" + str ( maxSumBitonicSubArr ( arr , n ) ) ) NEW_LINE"],"bleu":0.7962657945246213,"rouge_l":0.9163900298205143}
{"id":668,"predictions":["def minimumDeletions ( s ) : NEW_LINE INDENT freq NEW_LINE freqOfLetter = [ 0 ] * 26 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT letterFreqMap = dict ( ) NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT letterFreqMap = dict ( ) NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( freqOfLetter [ i ] != 0 ) : NEW_LINE INDENT if ( freqOfLetter [ i ] != 0 ) : NEW_LINE INDENT if freqOfLetter [ i ] in freqMap [ freqOfLetter [ i ] ] ) : NEW_LINE INDENT letterFreq [ freqOfLetter [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT letterFreq [ freqOfLetter [ i ] ] += 1 NEW_LINE DEDENT DEDENT DEDENT deletions = 0 NEW_LINE set = 0 NEW_LINE for key in Set : NEW_LINE INDENT if ( key == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT while ( key > 1 ) : NEW_LINE INDENT deletions += 1 NEW_LINE letterFreq [ key ] -= 1 NEW_LINE if ( key [ value ] > 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT deletions += 1 NEW_LINE letterFreq [ value ] = 1 NEW_LINE DEDENT DEDENT DEDENT return deletions NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" geeksforgeeks \" NEW_LINE print ( minimumDeletions ( s ) ) NEW_LINE print ( minimumDeletions ( s ) ) NEW_LINE DEDENT"],"references":["def minimumDeletions ( s ) : NEW_LINE INDENT freqOfLetter = [ 0 ] * 26 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT freqOfLetter [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT LetterFreqMap = dict ( ) NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( freqOfLetter [ i ] != 0 ) : NEW_LINE INDENT LetterFreqMap [ freqOfLetter [ i ] ] =   \\ NEW_LINE LetterFreqMap . get ( freqOfLetter [ i ] , 0 ) + 1 NEW_LINE DEDENT DEDENT deletions = 0 NEW_LINE a = list ( LetterFreqMap . keys ( ) ) NEW_LINE a = a [ : : - 1 ] NEW_LINE a . sort ( ) NEW_LINE while len ( a ) > 0 : NEW_LINE INDENT it = a . pop ( ) NEW_LINE if ( it == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT while ( LetterFreqMap [ it ] > 1 ) : NEW_LINE INDENT deletions += 1 NEW_LINE LetterFreqMap [ it ] -= 1 NEW_LINE if ( it - 1 ) in LetterFreqMap . keys ( ) : NEW_LINE INDENT LetterFreqMap [ it - 1 ] += 1 NEW_LINE DEDENT elif ( it - 1 ) > 0 : NEW_LINE INDENT a . insert ( 0 , it - 1 ) NEW_LINE LetterFreqMap [ it - 1 ] = 1 NEW_LINE DEDENT DEDENT DEDENT return deletions NEW_LINE DEDENT s = \" geeksforgeeks \" NEW_LINE print ( minimumDeletions ( s ) ) NEW_LINE"],"bleu":0.5082690438850664,"rouge_l":0.6041740360806509}
{"id":669,"predictions":["import sys NEW_LINE def findMax ( arr , n ) : NEW_LINE INDENT maxFirst = - 10 ** 9 NEW_LINE mid = n \/\/ 2 NEW_LINE for i in range ( mid ) : NEW_LINE INDENT maxFirst = max ( maxFirst , arr [ i ] ) NEW_LINE DEDENT if ( n % 2 == 1 ) : NEW_LINE INDENT maxFirst = max ( maxFirst , arr [ mid ] ) NEW_LINE DEDENT maxFirst = - 10 ** 9 NEW_LINE for i in range ( mid , n ) : NEW_LINE INDENT maxFirst = max ( maxFirst , arr [ i ] ) NEW_LINE DEDENT print ( maxFirst , \" , \" , minSecond ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 10 , 15 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE findMax ( arr , n ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE def findMax ( arr , n ) : NEW_LINE INDENT maxFirst = - sys . maxsize - 1 NEW_LINE mid = n \/\/ 2 ; NEW_LINE for i in range ( 0 , mid ) : NEW_LINE INDENT maxFirst = max ( maxFirst , arr [ i ] ) NEW_LINE DEDENT if ( n % 2 == 1 ) : NEW_LINE INDENT maxFirst = max ( maxFirst , arr [ mid ] ) NEW_LINE DEDENT maxSecond = - sys . maxsize - 1 NEW_LINE for i in range ( mid , n ) : NEW_LINE INDENT maxSecond = max ( maxSecond , arr [ i ] ) NEW_LINE DEDENT print ( maxFirst , \" , \" , maxSecond ) NEW_LINE DEDENT arr = [ 1 , 12 , 14 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE findMax ( arr , n ) NEW_LINE"],"bleu":0.7306358173871128,"rouge_l":0.8569436997319035}
{"id":670,"predictions":["def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def lcm ( a , b ) : NEW_LINE INDENT return ( a * b ) \/ gcd ( a , b ) NEW_LINE DEDENT def printSum ( num1 , den1 , num2 , num2 ) : NEW_LINE INDENT lcd = lcm ( den1 , den2 ) NEW_LINE num1 *= ( lcd \/\/ den1 ) NEW_LINE num2 *= ( lcd \/\/ den2 ) NEW_LINE res_num = num1 + num2 NEW_LINE print ( res_num , \" \/ \" , lcd ) NEW_LINE DEDENT num1 = 1 NEW_LINE den1 = 6 NEW_LINE num2 = 7 NEW_LINE den2 = 15 NEW_LINE printSum ( num1 , den1 , num2 ) NEW_LINE"],"references":["def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def lcm ( a , b ) : NEW_LINE INDENT return ( a * b ) \/ gcd ( a , b ) NEW_LINE DEDENT def printSum ( num1 , den1 , num2 , den2 ) : NEW_LINE INDENT lcd = lcm ( den1 , den2 ) ; NEW_LINE num1 *= ( lcd \/ den1 ) NEW_LINE num2 *= ( lcd \/ den2 ) NEW_LINE res_num = num1 + num2 ; NEW_LINE print ( int ( res_num ) , \" \/ \" , int ( lcd ) ) NEW_LINE DEDENT num1 = 1 NEW_LINE den1 = 6 NEW_LINE num2 = 7 NEW_LINE den2 = 15 NEW_LINE printSum ( num1 , den1 , num2 , den2 ) ; NEW_LINE"],"bleu":0.8167232323990997,"rouge_l":0.9356452150716905}
{"id":671,"predictions":["def maxProduct ( arr , n , p ) : NEW_LINE INDENT minVal = arr [ 0 ] NEW_LINE maxVal = arr [ 0 ] NEW_LINE maxProduct = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT temp = maxVal NEW_LINE maxVal = minVal NEW_LINE minVal = temp NEW_LINE DEDENT maxVal = max ( arr [ i ] , maxVal * arr [ i ] ) NEW_LINE minVal = min ( arr [ i ] , minVal * arr [ i ] ) NEW_LINE if ( minVal == p or maxVal == p ) : NEW_LINE INDENT return True NEW_LINE DEDENT maxProduct = max ( maxProduct , maxVal ) NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , - 5 , - 4 ] NEW_LINE product = - 10 NEW_LINE n = len ( arr ) NEW_LINE if ( maxProduct ( arr , n , product ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"references":["def maxProduct ( arr , n , p ) : NEW_LINE INDENT minVal = arr [ 0 ] NEW_LINE maxVal = arr [ 0 ] NEW_LINE maxProduct = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT maxVal , minVal = minVal , maxVal NEW_LINE DEDENT maxVal = max ( arr [ i ] , maxVal * arr [ i ] ) NEW_LINE minVal = min ( arr [ i ] , minVal * arr [ i ] ) NEW_LINE if ( minVal == p or maxVal == p ) : NEW_LINE INDENT return True NEW_LINE DEDENT maxProduct = max ( maxProduct , maxVal ) NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , - 5 , - 4 ] NEW_LINE product = - 10 NEW_LINE n = len ( arr ) NEW_LINE if ( maxProduct ( arr , n , product ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.9251463250659572,"rouge_l":0.9630305434351447}
{"id":672,"predictions":["from math import ceil NEW_LINE def solve ( M , N , s ) : NEW_LINE INDENT ans = ( ( floor ( M \/ s ) ) * ( math . ceil ( N \/ s ) ) ) NEW_LINE return ans NEW_LINE DEDENT N = 12 NEW_LINE M = 13 NEW_LINE s = 4 NEW_LINE print ( solve ( M , N , s ) ) NEW_LINE"],"references":["import math NEW_LINE def solve ( M , N , s ) : NEW_LINE INDENT ans = ( ( math . ceil ( M \/ s ) ) * ( math . ceil ( N \/ s ) ) ) ; NEW_LINE return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 12 NEW_LINE M = 13 NEW_LINE s = 4 NEW_LINE print ( solve ( M , N , s ) ) NEW_LINE DEDENT"],"bleu":0.698960788794329,"rouge_l":0.8349126131817224}
{"id":673,"predictions":["def ifExists ( arr , n ) : NEW_LINE INDENT sum = [ 0 for i in range ( n ) ] NEW_LINE sum [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT sum [ i ] = sum [ i - 1 ] + arr [ i ] NEW_LINE DEDENT max = arr [ n - 1 ] NEW_LINE flag = False NEW_LINE for i in range ( 1 , max + 1 ) : NEW_LINE INDENT findex = 0 NEW_LINE lindex = 0 NEW_LINE r = n - 1 NEW_LINE while ( l <= r ) : NEW_LINE INDENT m = ( l + r ) \/\/ 2 NEW_LINE if ( arr [ m ] < i ) : NEW_LINE INDENT findex = m NEW_LINE l = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = m - 1 NEW_LINE DEDENT DEDENT l = 1 NEW_LINE r = n NEW_LINE flag = False NEW_LINE while ( l <= r ) : NEW_LINE INDENT m = ( r + l ) \/\/ 2 NEW_LINE if ( arr [ m ] > i ) : NEW_LINE INDENT lindex = m NEW_LINE r = m - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT if ( sum [ findex ] == sum [ n - 1 ] - sum [ lindex - 1 ] ) : NEW_LINE INDENT flag = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 2 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE if ( arr ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def IfExists ( arr , n ) : NEW_LINE INDENT sum = [ 0 ] * n ; NEW_LINE arr . sort ( ) ; NEW_LINE sum [ 0 ] = arr [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT sum [ i ] = sum [ i - 1 ] + arr [ i ] ; NEW_LINE DEDENT max = arr [ n - 1 ] ; NEW_LINE flag = False ; NEW_LINE for i in range ( 1 , max + 1 ) : NEW_LINE INDENT findex = 0 ; NEW_LINE lindex = 0 ; NEW_LINE l = 0 ; NEW_LINE r = n - 1 ; NEW_LINE while ( l <= r ) : NEW_LINE INDENT m = ( l + r ) \/\/ 2 ; NEW_LINE if ( arr [ m ] < i ) : NEW_LINE INDENT findex = m ; NEW_LINE l = m + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT r = m - 1 ; NEW_LINE DEDENT DEDENT l = 1 ; NEW_LINE r = n ; NEW_LINE flag = False ; NEW_LINE while ( l <= r ) : NEW_LINE INDENT m = ( r + l ) \/\/ 2 ; NEW_LINE if ( arr [ m ] > i ) : NEW_LINE INDENT lindex = m ; NEW_LINE r = m - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 ; NEW_LINE DEDENT DEDENT if ( sum [ findex ] == sum [ n - 1 ] - sum [ lindex - 1 ] ) : NEW_LINE INDENT flag = True ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 2 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE IfExists ( arr , n ) ; NEW_LINE DEDENT"],"bleu":0.7593052613470108,"rouge_l":0.891837779950645}
{"id":674,"predictions":["def sumOfTheSeries ( n ) : NEW_LINE INDENT return n \/ ( n + 1 ) NEW_LINE DEDENT n = 10 NEW_LINE print ( sumOfTheSeries ( n ) ) NEW_LINE"],"references":["def sumOfTheSeries ( n ) : NEW_LINE INDENT return ( float ( n ) \/ ( n + 1 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE ans = sumOfTheSeries ( n ) NEW_LINE print ( round ( ans , 6 ) ) NEW_LINE DEDENT"],"bleu":0.2761952538093829,"rouge_l":0.601832276250881}
{"id":675,"predictions":["import sys NEW_LINE def printClosest ( arr , n , x ) : NEW_LINE INDENT res_l = 0 NEW_LINE res_r = 0 NEW_LINE l = n - 1 NEW_LINE diff = sys . maxsize - 1 NEW_LINE while ( r > l ) : NEW_LINE INDENT if ( abs ( arr [ l ] + arr [ r ] - x ) < diff ) : NEW_LINE INDENT res_l = l NEW_LINE res_r = r NEW_LINE diff = abs ( arr [ l ] + arr [ r ] - x ) NEW_LINE DEDENT if ( arr [ l ] + arr [ r ] > x ) : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT l += 1 NEW_LINE DEDENT DEDENT print ( \" The ▁ The ▁ closest ▁ is ▁ \" , arr [ r ] , arr [ res_r ] , \" ▁ are \" , arr [ res_r ] ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 10 , 12 , 20 , 20 , 30 , 40 , x = len ( arr ) NEW_LINE printClosest ( arr , n , x ) NEW_LINE DEDENT"],"references":["MAX_VAL = 1000000000 NEW_LINE def printClosest ( arr , n , x ) : NEW_LINE INDENT res_l , res_r = 0 , 0 NEW_LINE l , r , diff = 0 , n - 1 , MAX_VAL NEW_LINE while r > l : NEW_LINE INDENT if abs ( arr [ l ] + arr [ r ] - x ) < diff : NEW_LINE INDENT res_l = l NEW_LINE res_r = r NEW_LINE diff = abs ( arr [ l ] + arr [ r ] - x ) NEW_LINE DEDENT if arr [ l ] + arr [ r ] > x : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT l += 1 NEW_LINE DEDENT DEDENT print ( ' The ▁ closest ▁ pair ▁ is ▁ { } ▁ and ▁ { } ' . format ( arr [ res_l ] , arr [ res_r ] ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 10 , 22 , 28 , 29 , 30 , 40 ] NEW_LINE n = len ( arr ) NEW_LINE x = 54 NEW_LINE printClosest ( arr , n , x ) NEW_LINE DEDENT"],"bleu":0.6962221339014879,"rouge_l":0.8058252427184466}
{"id":676,"predictions":["def binomialCoeff ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT res *= ( n - i ) NEW_LINE res \/\/= ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT def power ( x , y ) : NEW_LINE INDENT res = 1 NEW_LINE while ( y > 0 ) : NEW_LINE INDENT res *= x NEW_LINE res \/\/= ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT def gcd ( a , b ) : NEW_LINE INDENT res = 1 NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( ( y & 1 ) == 1 ) : NEW_LINE INDENT res = res * x NEW_LINE DEDENT y = y >> 1 NEW_LINE x = x * x NEW_LINE DEDENT return res NEW_LINE DEDENT def FindProbability ( n ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( 2 * n , n ) NEW_LINE DEDENT if __name__ == \" _ main _ _ \" : NEW_LINE INDENT N = 8 NEW_LINE FindProbability ( N ) NEW_LINE DEDENT N = 8 NEW_LINE FindProbability ( N ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def binomialCoeff ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k NEW_LINE DEDENT for i in range ( 0 , k ) : NEW_LINE INDENT res = res * ( n - i ) NEW_LINE res = res \/\/ ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT def power ( x , y ) : NEW_LINE INDENT res = 1 NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = res * x NEW_LINE DEDENT y = y \/\/ 2 NEW_LINE x = x * x NEW_LINE DEDENT return res NEW_LINE DEDENT def FindProbability ( n ) : NEW_LINE INDENT up = binomialCoeff ( 2 * n , n ) NEW_LINE down = power ( 2 , 2 * n ) NEW_LINE g = math . gcd ( up , down ) NEW_LINE up = up \/\/ g NEW_LINE down = down \/\/ g NEW_LINE print ( up , \" \/ \" , down ) NEW_LINE DEDENT N = 8 NEW_LINE FindProbability ( N ) NEW_LINE"],"bleu":0.6077125082536186,"rouge_l":0.7020159110218582}
{"id":677,"predictions":["class Node : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . key = key NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def inorder ( root ) : NEW_LINE INDENT if ( root != None ) : NEW_LINE INDENT inorder ( root . left ) NEW_LINE print ( root . index , end = \" ▁ \" ) NEW_LINE inorder ( root . right ) NEW_LINE DEDENT DEDENT def constructTree ( root , n ) : NEW_LINE INDENT m = dict ( ) NEW_LINE root = Node ( 0 ) NEW_LINE temp = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( m [ i ] == None ) : NEW_LINE INDENT temp = Node ( i ) NEW_LINE m [ i ] = temp NEW_LINE DEDENT if ( root [ i ] == None ) : NEW_LINE INDENT root = m [ i ] NEW_LINE DEDENT if ( root [ i ] == None ) : NEW_LINE INDENT root = m [ i ] NEW_LINE DEDENT elif ( m [ arr [ i ] ] == None ) : NEW_LINE INDENT temp . append ( m [ i ] ) NEW_LINE DEDENT elif ( m [ arr [ i ] ] == None ) : NEW_LINE INDENT m [ arr [ i ] ] = m [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT m [ arr [ i ] ] = m [ i ] NEW_LINE DEDENT DEDENT DEDENT return None NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT root = [ - 1 , 0 , 0 , 1 , 1 , 3 , 5 ] NEW_LINE n = len ( root ) NEW_LINE root = createTree ( root , n ) NEW_LINE print ( \" Inorder ▁ Traversal ▁ of ▁ to ▁ \" , end = \" ▁ \" ) NEW_LINE print ( \" Inorder ▁ of ▁ \" , end = \" \" ) NEW_LINE DEDENT DEDENT"],"references":["class Node : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . key = 0 NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def newNode ( key : int ) -> Node : NEW_LINE INDENT temp = Node ( ) NEW_LINE temp . key = key NEW_LINE temp . left = None NEW_LINE temp . right = None NEW_LINE return temp NEW_LINE DEDENT def inorder ( root : Node ) : NEW_LINE INDENT if root is not None : NEW_LINE INDENT inorder ( root . left ) NEW_LINE print ( root . key , end = \" ▁ \" ) NEW_LINE inorder ( root . right ) NEW_LINE DEDENT DEDENT def createTree ( parent : list , n : int ) -> Node : NEW_LINE INDENT m = dict ( ) NEW_LINE root = Node ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i not in m : NEW_LINE INDENT temp = newNode ( i ) NEW_LINE m [ i ] = temp NEW_LINE DEDENT if parent [ i ] == - 1 : NEW_LINE INDENT root = m [ i ] NEW_LINE DEDENT elif parent [ i ] not in m : NEW_LINE INDENT temp = newNode ( parent [ i ] ) NEW_LINE temp . left = m [ i ] NEW_LINE m [ parent [ i ] ] = temp NEW_LINE DEDENT else : NEW_LINE INDENT if m [ parent [ i ] ] . left is None : NEW_LINE INDENT m [ parent [ i ] ] . left = m [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT m [ parent [ i ] ] . right = m [ i ] NEW_LINE DEDENT DEDENT DEDENT return root NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT parent = [ - 1 , 0 , 0 , 1 , 1 , 3 , 5 ] NEW_LINE n = len ( parent ) NEW_LINE root = createTree ( parent , n ) NEW_LINE print ( \" Inorder ▁ Traversal ▁ of ▁ constructed ▁ tree \" ) NEW_LINE inorder ( root ) NEW_LINE DEDENT"],"bleu":0.6144455584393473,"rouge_l":0.7395277300280466}
{"id":678,"predictions":["def findExtra ( arr1 , arr2 , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr1 [ i ] != arr2 [ i ] ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT arr1 = [ 2 , 4 , 6 , 8 , 10 , 12 , 13 ] NEW_LINE arr2 = [ 2 , 4 , 6 , 8 , 10 , 12 ] NEW_LINE n = len ( arr2 ) NEW_LINE print ( findExtra ( arr1 , arr2 , n ) ) NEW_LINE"],"references":["def findExtra ( arr1 , arr2 , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr1 [ i ] != arr2 [ i ] ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT arr1 = [ 2 , 4 , 6 , 8 , 10 , 12 , 13 ] NEW_LINE arr2 = [ 2 , 4 , 6 , 8 , 10 , 12 ] NEW_LINE n = len ( arr2 ) NEW_LINE print ( findExtra ( arr1 , arr2 , n ) ) NEW_LINE"],"bleu":0.9648824640944856,"rouge_l":0.9882179675994109}
{"id":679,"predictions":["def CountPairs ( n ) : NEW_LINE INDENT k = n ; NEW_LINE imin = 1 ; NEW_LINE ans = 0 ; NEW_LINE while ( imin <= n ) : NEW_LINE INDENT imax = n \/ k ; NEW_LINE ans += k * ( immax - imin + 1 ) ; NEW_LINE imin = imin + 1 ; NEW_LINE k = n \/\/ imin ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( CountPairs ( 1 ) ) ; NEW_LINE print ( CountPairs ( 2 ) ) ; NEW_LINE print ( CountPairs ( 3 ) ) ; NEW_LINE DEDENT"],"references":["def CountPairs ( n ) : NEW_LINE INDENT k = n NEW_LINE imin = 1 NEW_LINE ans = 0 NEW_LINE while ( imin <= n ) : NEW_LINE INDENT imax = n \/ k NEW_LINE ans += k * ( imax - imin + 1 ) NEW_LINE imin = imax + 1 NEW_LINE k = n \/ imin NEW_LINE DEDENT return ans NEW_LINE DEDENT print ( CountPairs ( 1 ) ) NEW_LINE print ( CountPairs ( 2 ) ) NEW_LINE print ( CountPairs ( 3 ) ) NEW_LINE"],"bleu":0.5516685482115639,"rouge_l":0.8651760387118305}
{"id":680,"predictions":["def find3Numbers ( arr , n ) : NEW_LINE INDENT small = + 2147483647 NEW_LINE large = + 2147483647 NEW_LINE i = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] <= small ) : NEW_LINE INDENT small = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] <= large ) : NEW_LINE INDENT large = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( i == n ) : NEW_LINE INDENT print ( \" No ▁ such ▁ triplet ▁ found \" ) NEW_LINE return NEW_LINE DEDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ j ] < small ) : NEW_LINE INDENT small = arr [ j ] NEW_LINE break NEW_LINE DEDENT DEDENT print ( sm , \" ▁ such ▁ triplet ▁ found \" ) NEW_LINE return NEW_LINE DEDENT arr = [ 5 , 7 , 4 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE find3Numbers ( arr , n ) NEW_LINE"],"references":["def find3Numbers ( arr , n ) : NEW_LINE INDENT small = + 2147483647 NEW_LINE large = + 2147483647 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] <= small ) : NEW_LINE INDENT small = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] <= large ) : NEW_LINE INDENT large = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( i == n ) : NEW_LINE INDENT print ( \" No ▁ such ▁ triplet ▁ found \" ) NEW_LINE return NEW_LINE DEDENT for j in range ( i + 1 ) : NEW_LINE INDENT if ( arr [ j ] < large ) : NEW_LINE INDENT small = arr [ j ] NEW_LINE break NEW_LINE DEDENT DEDENT print ( small , \" ▁ \" , large , \" ▁ \" , arr [ i ] ) NEW_LINE return NEW_LINE DEDENT arr = [ 5 , 7 , 4 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE find3Numbers ( arr , n ) NEW_LINE"],"bleu":0.8822652701776884,"rouge_l":0.933315645175555}
{"id":681,"predictions":["def countCharacterType ( str ) : NEW_LINE INDENT vowels = 0 NEW_LINE consonant = 0 NEW_LINE specialChar = 0 NEW_LINE digit = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT ch = str [ i ] NEW_LINE if ( ( ch >= ' a ' and ch <= ' z ' and ch <= ' z ' ) ) : NEW_LINE INDENT ch = ord ( ch ) NEW_LINE if ( ch >= ' a ' and ch == ' e ' and ch == ' o ' or ch == ' u ' ) : NEW_LINE INDENT vowels += 1 NEW_LINE DEDENT else : NEW_LINE INDENT consonant += 1 NEW_LINE DEDENT else : NEW_LINE INDENT consonant += 1 NEW_LINE DEDENT DEDENT elif ( ch >= '0' and ch <= '9' ) : NEW_LINE INDENT digit += 1 NEW_LINE DEDENT else : NEW_LINE INDENT specialChar += 1 NEW_LINE DEDENT DEDENT print ( \" Vowels : \" , consonant ) NEW_LINE print ( \" Cons : \" , consonant ) NEW_LINE print ( \" Consonant : \" , consonant ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeks ▁ for ▁ geeks 121\" NEW_LINE countCharacterType ( str ) NEW_LINE DEDENT"],"references":["def countCharacterType ( str ) : NEW_LINE INDENT vowels = 0 NEW_LINE consonant = 0 NEW_LINE specialChar = 0 NEW_LINE digit = 0 NEW_LINE for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT ch = str [ i ] NEW_LINE if ( ( ch >= ' a ' and ch <= ' z ' ) or ( ch >= ' A ' and ch <= ' Z ' ) ) : NEW_LINE INDENT ch = ch . lower ( ) NEW_LINE if ( ch == ' a ' or ch == ' e ' or ch == ' i ' or ch == ' o ' or ch == ' u ' ) : NEW_LINE INDENT vowels += 1 NEW_LINE DEDENT else : NEW_LINE INDENT consonant += 1 NEW_LINE DEDENT DEDENT elif ( ch >= '0' and ch <= '9' ) : NEW_LINE INDENT digit += 1 NEW_LINE DEDENT else : NEW_LINE INDENT specialChar += 1 NEW_LINE DEDENT DEDENT print ( \" Vowels : \" , vowels ) NEW_LINE print ( \" Consonant : \" , consonant ) NEW_LINE print ( \" Digit : \" , digit ) NEW_LINE print ( \" Special ▁ Character : \" , specialChar ) NEW_LINE DEDENT str = \" geeks ▁ for ▁ geeks121\" NEW_LINE countCharacterType ( str ) NEW_LINE"],"bleu":0.7559143008186837,"rouge_l":0.8365506447044793}
{"id":682,"predictions":["def calculateSum ( n ) : NEW_LINE INDENT return ( 2 * ( n * ( n + 1 ) * ( 2 * n + 1 ) \/ 6 ) + n * ( n + 1 ) \/ 2 + 2 * ( n ) ) ; NEW_LINE DEDENT n = 3 NEW_LINE print ( \" Sum ▁ = \" , int ( calculateSum ( n ) ) ) NEW_LINE"],"references":["def calculateSum ( n ) : NEW_LINE INDENT return ( 2 * ( n * ( n + 1 ) * ( 2 * n + 1 ) \/\/ 6 ) + n * ( n + 1 ) \/\/ 2 + 2 * ( n ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE print ( \" Sum ▁ = \" , calculateSum ( n ) ) NEW_LINE DEDENT"],"bleu":0.701324866058644,"rouge_l":0.8472222222222221}
{"id":683,"predictions":["def countPairs ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] * arr [ j ] > arr [ i ] + arr [ j ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 5 , 0 , 3 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE"],"references":["import math as mt NEW_LINE def countPairs ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] * arr [ j ] > arr [ i ] + arr [ j ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 5 , 0 , 3 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE"],"bleu":0.9391069418162953,"rouge_l":0.9646860125902044}
{"id":684,"predictions":["PI = ( 3.14159 \/ 180 ) NEW_LINE def areaOfKite ( a , b , angle ) : NEW_LINE INDENT angle = angle * PI NEW_LINE area = a * b * math . sin ( angle ) NEW_LINE return area NEW_LINE DEDENT a = 4 NEW_LINE b = 7 NEW_LINE angle = 78 NEW_LINE print ( \" Area ▁ of ▁ Kite ▁ = \" , areaOfKite ( a , b , angle ) ) NEW_LINE"],"references":["import math NEW_LINE PI = 3.14159 \/ 180 ; NEW_LINE def areaOfKite ( a , b , angle ) : NEW_LINE INDENT angle = angle * PI ; NEW_LINE area = a * b * math . sin ( angle ) ; NEW_LINE return area ; NEW_LINE DEDENT a = 4 ; b = 7 ; angle = 78 ; NEW_LINE print ( \" Area ▁ of ▁ Kite ▁ = ▁ \" , areaOfKite ( a , b , angle ) ) ; NEW_LINE"],"bleu":0.6788847283410544,"rouge_l":0.8932798395185557}
{"id":685,"predictions":["def number =93 NEW_LINE arr = [ 1 , 31 , 3 , 1 , 21 , 3 , 31 , 1 , 1 , 41 , 1 , 1 , 41 ] NEW_LINE length = len ( arr ) NEW_LINE totalCount = 0 NEW_LINE for i in range ( length - 2 ) : NEW_LINE INDENT if ( target % arr [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i + 1 , length - 1 ) : NEW_LINE INDENT if ( target % ( arr [ i ] * arr [ j ] ) == 0 ) : NEW_LINE INDENT toFind = target \/\/ ( arr [ i ] * arr [ j ] ) NEW_LINE for k in range ( j + 1 , length ) : NEW_LINE INDENT if ( arr [ k ] == toFind ) : NEW_LINE INDENT totalCount += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT print ( \" Total ▁ number ▁ of ▁ triplets ▁ found ▁ : ▁ \" , totalCount ) NEW_LINE"],"references":["target = 93 NEW_LINE arr = [ 1 , 31 , 3 , 1 , 93 , 3 , 31 , 1 , 93 ] NEW_LINE length = len ( arr ) NEW_LINE totalCount = 0 NEW_LINE for i in range ( length - 2 ) : NEW_LINE INDENT if target % arr [ i ] == 0 : NEW_LINE INDENT for j in range ( i + 1 , length - 1 ) : NEW_LINE INDENT if target % ( arr [ i ] * arr [ j ] ) == 0 : NEW_LINE INDENT toFind = target \/\/ ( arr [ i ] * arr [ j ] ) NEW_LINE for k in range ( j + 1 , length ) : NEW_LINE INDENT if arr [ k ] == toFind : NEW_LINE INDENT totalCount += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT print ( ' Total ▁ number ▁ of ▁ triplets ▁ found : ▁ ' , totalCount ) NEW_LINE"],"bleu":0.7835405008468854,"rouge_l":0.9231800766283526}
{"id":686,"predictions":["def checkSpecialPrime ( sieve , num ) : NEW_LINE INDENT while ( num ) : NEW_LINE INDENT if ( sieve [ num ] == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT num \/\/= 10 NEW_LINE DEDENT return True NEW_LINE DEDENT def findSpecialPrime ( N ) : NEW_LINE INDENT sieve = [ True for i in range ( N + 10 ) ] NEW_LINE sieve [ 0 ] = False NEW_LINE sieve [ 1 ] = False NEW_LINE for i in range ( 2 , N + 10 ) : NEW_LINE INDENT sieve [ i ] = True NEW_LINE DEDENT for i in range ( 2 , N + 10 + 1 ) : NEW_LINE INDENT if ( sieve [ i ] ) : NEW_LINE INDENT for j in range ( i * i , N + 1 , i ) : NEW_LINE INDENT sieve [ j ] = False NEW_LINE DEDENT DEDENT DEDENT while ( True ) : NEW_LINE INDENT if ( checkSpecialPrime ( sieve , N ) ) : NEW_LINE INDENT print ( N ) NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT N -= 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT findSpecialPrime ( 379 ) NEW_LINE findSpecialPrime ( 100 ) NEW_LINE findSpecialPrime ( 100 ) NEW_LINE DEDENT"],"references":["def checkSpecialPrime ( sieve , num ) : NEW_LINE INDENT while ( num ) : NEW_LINE INDENT if ( not sieve [ num ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT num \/\/= 10 NEW_LINE DEDENT return True NEW_LINE DEDENT def findSpecialPrime ( N ) : NEW_LINE INDENT sieve = [ True ] * ( N + 10 ) NEW_LINE sieve [ 0 ] = sieve [ 1 ] = False ; NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT if ( sieve [ i ] ) : NEW_LINE INDENT for j in range ( i * i , N + 1 , i ) : NEW_LINE INDENT sieve [ j ] = False NEW_LINE DEDENT DEDENT DEDENT while ( True ) : NEW_LINE INDENT if ( checkSpecialPrime ( sieve , N ) ) : NEW_LINE INDENT print ( N ) NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT N -= 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT findSpecialPrime ( 379 ) NEW_LINE findSpecialPrime ( 100 ) NEW_LINE DEDENT"],"bleu":0.7624070650289316,"rouge_l":0.9012826757590519}
{"id":687,"predictions":["MAX = 1000005 NEW_LINE fibUpto = [ 0 ] * ( MAX + 1 ) NEW_LINE def compute ( sz ) : NEW_LINE INDENT isFib = [ 0 ] * ( sz + 1 ) NEW_LINE prev = 0 NEW_LINE curr = 1 NEW_LINE isFib [ curr ] = isFib [ curr ] = True NEW_LINE while ( curr <= sz ) : NEW_LINE INDENT temp = curr + prev NEW_LINE if ( temp <= sz ) : NEW_LINE INDENT isFib [ temp ] = True NEW_LINE DEDENT prev = curr NEW_LINE curr = temp NEW_LINE DEDENT fibUpt [ 0 ] = 1 NEW_LINE for i in range ( 1 , sz + 1 ) : NEW_LINE INDENT fibUpt [ i ] = fibUpt [ i - 1 ] NEW_LINE if ( isFib [ i ] ) : NEW_LINE INDENT fibUpt [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT def countOfNumbers ( N , K ) : NEW_LINE INDENT compute ( N ) NEW_LINE low = 1 NEW_LINE high = N NEW_LINE ans = 0 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) >> 1 NEW_LINE if ( mid - fibo [ mid ] >= K ) : NEW_LINE INDENT ans = mid NEW_LINE high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT N = 10 NEW_LINE K = 3 NEW_LINE print ( countOfNumbers ( N , K ) ) NEW_LINE"],"references":["MAX = 1000005 NEW_LINE fibUpto = [ 0 ] * ( MAX + 1 ) NEW_LINE def compute ( sz ) : NEW_LINE INDENT isFib = [ False ] * ( sz + 1 ) NEW_LINE prev = 0 NEW_LINE curr = 1 NEW_LINE isFib [ prev ] = True NEW_LINE isFib [ curr ] = True NEW_LINE while ( curr <= sz ) : NEW_LINE INDENT temp = curr + prev NEW_LINE if ( temp <= sz ) : NEW_LINE INDENT isFib [ temp ] = True NEW_LINE DEDENT prev = curr NEW_LINE curr = temp NEW_LINE DEDENT fibUpto [ 0 ] = 1 NEW_LINE for i in range ( 1 , sz + 1 ) : NEW_LINE INDENT fibUpto [ i ] = fibUpto [ i - 1 ] NEW_LINE if ( isFib [ i ] ) : NEW_LINE INDENT fibUpto [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT def countOfNumbers ( N , K ) : NEW_LINE INDENT compute ( N ) NEW_LINE low , high , ans = 1 , N , 0 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) >> 1 NEW_LINE if ( mid - fibUpto [ mid ] >= K ) : NEW_LINE INDENT ans = mid NEW_LINE high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT if ( ans ) : NEW_LINE INDENT return ( N - ans + 1 ) NEW_LINE DEDENT return 0 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 10 NEW_LINE K = 3 NEW_LINE print ( countOfNumbers ( N , K ) ) NEW_LINE DEDENT"],"bleu":0.7767805487381036,"rouge_l":0.8816818969121423}
{"id":688,"predictions":["def setBitNumber ( n ) : NEW_LINE INDENT n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n = n + 1 NEW_LINE return ( n >> 1 ) NEW_LINE DEDENT n = 273 NEW_LINE print ( setBitNumber ( n ) ) NEW_LINE"],"references":["def setBitNumber ( n ) : NEW_LINE INDENT n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE n = n + 1 NEW_LINE return ( n >> 1 ) NEW_LINE DEDENT n = 273 NEW_LINE print ( setBitNumber ( n ) ) NEW_LINE"],"bleu":0.8976698736771449,"rouge_l":0.9424613745338307}
{"id":689,"predictions":["def isHetingogram ( s , n ) : NEW_LINE INDENT hash = [ 0 ] * 26 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] != ' ▁ ' ) : NEW_LINE INDENT if ( hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] == 0 ) : NEW_LINE INDENT hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] = 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT DEDENT return True ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" the ▁ bigger ▁ jumps \" ; NEW_LINE n = len ( s ) ; NEW_LINE if ( isHetingogram ( s , n ) ) : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE DEDENT DEDENT"],"references":["def isHeterogram ( s , n ) : NEW_LINE INDENT hash = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] != ' ▁ ' : NEW_LINE INDENT if hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] == 0 : NEW_LINE INDENT hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT s = \" the ▁ big ▁ dwarf ▁ only ▁ jumps \" NEW_LINE n = len ( s ) NEW_LINE print ( \" YES \" if isHeterogram ( s , n ) else \" NO \" ) NEW_LINE"],"bleu":0.5996389883435991,"rouge_l":0.8237009830398618}
{"id":690,"predictions":["def findgcd ( a , b ) : NEW_LINE INDENT a . sort ( ) NEW_LINE gcd = a [ 1 ] - a [ 0 ] NEW_LINE s = gcd NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT gcd = findgcd ( gcd , a [ i ] - a [ i - 1 ] ) NEW_LINE s += a [ i ] - a [ i - 1 ] NEW_LINE DEDENT if ( 360 - s > 0 ) : NEW_LINE INDENT gcd = findgcd ( gcd , 360 - s ) NEW_LINE DEDENT return ( 360 \/\/ gcd ) - n NEW_LINE DEDENT arr = [ 30 , 60 , 180 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minimumCuts ( arr , n ) ) NEW_LINE"],"references":["import math NEW_LINE def minimumCuts ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE gcd = a [ 1 ] - a [ 0 ] NEW_LINE s = gcd NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT gcd = math . gcd ( gcd , a [ i ] - a [ i - 1 ] ) NEW_LINE s += a [ i ] - a [ i - 1 ] NEW_LINE DEDENT if ( 360 - s > 0 ) : NEW_LINE INDENT gcd = math . gcd ( gcd , 360 - s ) NEW_LINE DEDENT return ( 360 \/\/ gcd ) - n NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 30 , 60 , 180 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minimumCuts ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.7908541539072822,"rouge_l":0.8909962938739918}
{"id":691,"predictions":["MAX = 1005 NEW_LINE def SieveOfEratosthenes ( primes ) : NEW_LINE INDENT prime = [ True ] * p NEW_LINE p = 2 NEW_LINE while p * p < MAX : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for p in range ( 2 , MAX ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT primes . append ( p ) NEW_LINE DEDENT DEDENT DEDENT def minimumSquareOfEratosthenes ( primes ) : NEW_LINE INDENT primes = [ ] NEW_LINE SieveOfEratosthenes ( primes ) NEW_LINE max_count = 0 NEW_LINE i = 0 NEW_LINE while ( i < len ( primes ) and primes [ i ] * primes [ i ] <= N ) : NEW_LINE INDENT if ( N % primes [ i ] == 0 ) : NEW_LINE INDENT tmp = 0 NEW_LINE while ( N % primes [ i ] == 0 ) : NEW_LINE INDENT tmp = 0 NEW_LINE while ( N % primes [ i ] == 0 ) : NEW_LINE INDENT tmp += 1 NEW_LINE N \/\/= primes [ i ] NEW_LINE DEDENT max_count = max ( max_count , tmp ) NEW_LINE DEDENT DEDENT if ( max_count == 0 ) : NEW_LINE INDENT max_count = 1 NEW_LINE DEDENT return max_count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 24 NEW_LINE print ( \" Minimum ▁ Number ▁ of ▁ Square ▁ \" , minimumSquare ( N ) ) NEW_LINE N = 6 NEW_LINE print ( \" Minimum ▁ Number ▁ of ▁ Square ▁ divisors ▁ is \" , minimumSquareDivisors ( N ) ) NEW_LINE DEDENT"],"references":["from math import sqrt NEW_LINE MAX = 1005 NEW_LINE def SieveOfEratosthenes ( primes ) : NEW_LINE INDENT prime = [ True for i in range ( MAX ) ] NEW_LINE for p in range ( 2 , int ( sqrt ( MAX ) ) + 1 , 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for p in range ( 2 , MAX , 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT primes . append ( p ) NEW_LINE DEDENT DEDENT return primes NEW_LINE DEDENT def minimumSquareFreeDivisors ( N ) : NEW_LINE INDENT prime = [ ] NEW_LINE primes = [ ] NEW_LINE primes = SieveOfEratosthenes ( prime ) NEW_LINE max_count = 0 NEW_LINE i = 0 NEW_LINE while ( len ( primes ) and primes [ i ] * primes [ i ] <= N ) : NEW_LINE INDENT if ( N % primes [ i ] == 0 ) : NEW_LINE INDENT tmp = 0 NEW_LINE while ( N % primes [ i ] == 0 ) : NEW_LINE INDENT tmp += 1 NEW_LINE N \/= primes [ i ] NEW_LINE DEDENT max_count = max ( max_count , tmp ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( max_count == 0 ) : NEW_LINE INDENT max_count = 1 NEW_LINE DEDENT return max_count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 24 NEW_LINE print ( \" Minimum ▁ Number ▁ of ▁ Square ▁ Free ▁ Divisors ▁ is \" , minimumSquareFreeDivisors ( N ) ) NEW_LINE N = 6 NEW_LINE print ( \" Minimum ▁ Number ▁ of ▁ Square ▁ Free ▁ Divisors ▁ is \" , minimumSquareFreeDivisors ( N ) ) NEW_LINE DEDENT"],"bleu":0.7090302863847737,"rouge_l":0.8324321540759049}
{"id":692,"predictions":["def calculateSum ( n ) : NEW_LINE INDENT return pow ( n * ( n + 1 ) \/ 2 , 2 ) NEW_LINE DEDENT n = 4 NEW_LINE print ( int ( solveSum ( n ) ) ) NEW_LINE"],"references":["def calculateSum ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) \/ 2 ) ** 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE print ( calculateSum ( n ) ) NEW_LINE DEDENT"],"bleu":0.5075640029967763,"rouge_l":0.7189285714285716}
{"id":693,"predictions":["st = [ ] NEW_LINE def push_digits ( number ) : NEW_LINE INDENT while number != 0 : NEW_LINE INDENT st . append ( number % 10 ) NEW_LINE number = number \/\/ 10 NEW_LINE DEDENT DEDENT def reverse_number ( number ) : NEW_LINE INDENT push_digits ( number ) NEW_LINE reverse = 0 NEW_LINE i = 1 NEW_LINE while ( len ( st ) > 0 ) : NEW_LINE INDENT reverse = reverse + ( st [ - 1 ] * i ) NEW_LINE st . pop ( ) NEW_LINE i = i * 10 NEW_LINE DEDENT return reverse NEW_LINE DEDENT number = 3997 NEW_LINE print ( reverse_number ( number ) ) NEW_LINE"],"references":["st = [ ] ; NEW_LINE def push_digits ( number ) : NEW_LINE INDENT while ( number != 0 ) : NEW_LINE INDENT st . append ( number % 10 ) ; NEW_LINE number = int ( number \/ 10 ) ; NEW_LINE DEDENT DEDENT def reverse_number ( number ) : NEW_LINE INDENT push_digits ( number ) ; NEW_LINE reverse = 0 ; NEW_LINE i = 1 ; NEW_LINE while ( len ( st ) > 0 ) : NEW_LINE INDENT reverse = reverse + ( st [ len ( st ) - 1 ] * i ) ; NEW_LINE st . pop ( ) ; NEW_LINE i = i * 10 ; NEW_LINE DEDENT return reverse ; NEW_LINE DEDENT number = 39997 ; NEW_LINE print ( reverse_number ( number ) ) ; NEW_LINE"],"bleu":0.6305181132843181,"rouge_l":0.8852137534318211}
{"id":694,"predictions":["def inProposition ( arr ) : NEW_LINE INDENT n = 4 NEW_LINE arr . sort ( ) NEW_LINE seen = arr [ 0 ] * arr [ 3 ] NEW_LINE mean = arr [ 1 ] * arr [ 2 ] NEW_LINE if ( ends == ends ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT arr = [ 1 , 2 , 4 , 2 ] NEW_LINE if ( in inProelement ( arr ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def inProportion ( arr ) : NEW_LINE INDENT n = 4 ; NEW_LINE arr . sort ( ) NEW_LINE extremes = arr [ 0 ] * arr [ 3 ] ; NEW_LINE means = arr [ 1 ] * arr [ 2 ] ; NEW_LINE if ( extremes == means ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 2 ] ; NEW_LINE if ( inProportion ( arr ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"],"bleu":0.5875607142142156,"rouge_l":0.8304671825738034}
{"id":695,"predictions":["M = 100 NEW_LINE memo = [ [ [ 0 for i in range ( M ) ] for j in range ( M ) ] for k in range ( M ) ] NEW_LINE def numberOfPermWithVIn gain ( N , K ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( K == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( memo [ N ] [ K ] != 0 ) : NEW_LINE INDENT return memo [ N ] [ K ] NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( K + 1 ) : NEW_LINE INDENT if ( i <= N - 1 ) : NEW_LINE INDENT sum += numberOfPermInKInversions ( N - 1 , K - i ) NEW_LINE DEDENT DEDENT memo [ N ] [ K ] = sum NEW_LINE return sum NEW_LINE DEDENT N = 4 NEW_LINE K = 2 NEW_LINE print ( numberOfPermInorder ( N , K ) ) NEW_LINE"],"references":["M = 100 NEW_LINE memo = [ [ 0 for i in range ( M ) ] for j in range ( M ) ] NEW_LINE def numberOfPermWithKInversion ( N , K ) : NEW_LINE INDENT if ( N == 0 ) : return 0 NEW_LINE if ( K == 0 ) : return 1 NEW_LINE if ( memo [ N ] [ K ] != 0 ) : NEW_LINE INDENT return memo [ N ] [ K ] NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( K + 1 ) : NEW_LINE INDENT if ( i <= N - 1 ) : NEW_LINE INDENT sum += numberOfPermWithKInversion ( N - 1 , K - i ) NEW_LINE DEDENT DEDENT memo [ N ] [ K ] = sum NEW_LINE return sum NEW_LINE DEDENT N = 4 ; K = 2 NEW_LINE print ( numberOfPermWithKInversion ( N , K ) ) NEW_LINE"],"bleu":0.80855856404634,"rouge_l":0.9346524606798581}
{"id":696,"predictions":["from math import sqrt NEW_LINE def findkth ( n , k ) : NEW_LINE INDENT v1 = [ ] NEW_LINE v2 = [ ] NEW_LINE for i in range ( 1 , int ( sqrt ( n ) + 1 ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT v1 . append ( i ) NEW_LINE if ( i != sqrt ( n ) ) : NEW_LINE INDENT v2 . append ( n \/\/ i ) NEW_LINE DEDENT DEDENT DEDENT v2 . reverse ( ) NEW_LINE if ( k > ( len ( v1 ) + len ( v2 ) ) ) : NEW_LINE INDENT print ( \" Doesn ' t ▁ Exist \" ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( k <= len ( v2 ) ) : NEW_LINE INDENT print ( v1 [ k - 1 ] , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( v2 [ k - len ( v2 ) - 1 ] , end = \" \" \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 10 NEW_LINE k = 2 NEW_LINE findkth ( n , k ) NEW_LINE DEDENT"],"references":["import math as mt NEW_LINE def findkth ( n , k ) : NEW_LINE INDENT v1 = list ( ) NEW_LINE v2 = list ( ) NEW_LINE for i in range ( 1 , mt . ceil ( n ** ( .5 ) ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT v1 . append ( i ) NEW_LINE if ( i != mt . ceil ( mt . sqrt ( n ) ) ) : NEW_LINE INDENT v2 . append ( n \/\/ i ) NEW_LINE DEDENT DEDENT DEDENT v2 [ : : - 1 ] NEW_LINE if ( k > ( len ( v1 ) + len ( v2 ) ) ) : NEW_LINE INDENT print ( \" Doesn ' t ▁ Exist \" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( k <= len ( v1 ) ) : NEW_LINE INDENT print ( v1 [ k - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( v2 [ k - len ( v1 ) - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT n = 15 NEW_LINE k = 2 NEW_LINE findkth ( n , k ) NEW_LINE"],"bleu":0.7285543957826721,"rouge_l":0.8114128295946478}
{"id":697,"predictions":["import sys NEW_LINE def maxSubArraySum ( a , size ) : NEW_LINE INDENT max_so_far = - sys . maxsize - 1 NEW_LINE max_ending_here = 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT max_ending_here = max_ending_here + a [ i ] NEW_LINE if ( max_so_far < max_ending_here ) : NEW_LINE INDENT max_so_far = max_ending_here NEW_LINE DEDENT if ( max_ending_here < 0 ) : NEW_LINE INDENT max_ending_here = 0 NEW_LINE DEDENT DEDENT return max_so_far NEW_LINE DEDENT def minimizedSum ( a , n , K ) : NEW_LINE INDENT sum = maxSubArraySum ( a , n ) NEW_LINE totalSum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT totalSum += a [ i ] NEW_LINE DEDENT if ( sum < 0 ) : NEW_LINE INDENT return totalSum NEW_LINE DEDENT totalSum = totalSum - sum + sum \/ ( K ) NEW_LINE return totalSum NEW_LINE DEDENT a = [ 1 , - 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE K = 2 NEW_LINE print ( minimizedSum ( a , n , K ) ) NEW_LINE"],"references":["import sys NEW_LINE def maxSubArraySum ( a , size ) : NEW_LINE INDENT max_so_far = - ( sys . maxsize - 1 ) ; NEW_LINE max_ending_here = 0 ; NEW_LINE for i in range ( size ) : NEW_LINE INDENT max_ending_here = max_ending_here + a [ i ] ; NEW_LINE if ( max_so_far < max_ending_here ) : NEW_LINE INDENT max_so_far = max_ending_here ; NEW_LINE DEDENT if ( max_ending_here < 0 ) : NEW_LINE INDENT max_ending_here = 0 ; NEW_LINE DEDENT DEDENT return max_so_far ; NEW_LINE DEDENT def minimizedSum ( a , n , K ) : NEW_LINE INDENT sum = maxSubArraySum ( a , n ) ; NEW_LINE totalSum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT totalSum += a [ i ] ; NEW_LINE DEDENT if ( sum < 0 ) : NEW_LINE INDENT return totalSum ; NEW_LINE DEDENT totalSum = totalSum - sum + sum \/ K ; NEW_LINE return totalSum ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , - 2 , 3 ] ; NEW_LINE n = len ( a ) ; NEW_LINE K = 2 ; NEW_LINE print ( minimizedSum ( a , n , K ) ) ; NEW_LINE DEDENT"],"bleu":0.7121105762860999,"rouge_l":0.9023081924577373}
{"id":698,"predictions":["def countSetBits ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE setBits = [ 0 ] * ( n + 1 ) NEW_LINE setBits [ 0 ] = 0 NEW_LINE setBits [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT setBits [ i ] = setBits [ i \/\/ 2 ] NEW_LINE DEDENT else : NEW_LINE INDENT setBits [ i ] = setBits [ i - 1 ] + 1 NEW_LINE DEDENT DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT cnt = cnt + setBits [ i ] NEW_LINE DEDENT return cnt NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 6 NEW_LINE print ( countSetBits ( n ) ) NEW_LINE DEDENT"],"references":["def countSetBits ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE setBits = [ 0 for x in range ( n + 1 ) ] NEW_LINE setBits [ 0 ] = 0 NEW_LINE setBits [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT setBits [ i ] = setBits [ i \/\/ 2 ] NEW_LINE DEDENT else : NEW_LINE INDENT setBits [ i ] = setBits [ i - 1 ] + 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , n + 1 ) : NEW_LINE INDENT cnt = cnt + setBits [ i ] NEW_LINE DEDENT return cnt NEW_LINE DEDENT n = 6 NEW_LINE print ( countSetBits ( n ) ) NEW_LINE"],"bleu":0.8569389464093204,"rouge_l":0.925091911764706}
{"id":699,"predictions":["def areaCircle ( b ) : NEW_LINE INDENT area = 3.1415926 * b * b NEW_LINE return area NEW_LINE DEDENT a = 10 NEW_LINE b = 8 NEW_LINE print ( areaCircle ( b ) ) NEW_LINE"],"references":["import math NEW_LINE def areaCircle ( b ) : NEW_LINE INDENT area = math . pi * b * b NEW_LINE return area NEW_LINE DEDENT a = 10 NEW_LINE b = 8 NEW_LINE print ( areaCircle ( b ) ) NEW_LINE"],"bleu":0.8075728095644366,"rouge_l":0.8985690235690237}
{"id":700,"predictions":["import math NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def push ( head_ref , new_data ) : NEW_LINE INDENT new_node = Node ( new_data ) NEW_LINE new_node . next = head_ref NEW_LINE head_ref = new_node NEW_LINE return head_ref NEW_LINE DEDENT def printList ( head ) : NEW_LINE INDENT while ( head != None ) : NEW_LINE INDENT print ( head . data , end = \" \" ) NEW_LINE head = head . next NEW_LINE DEDENT DEDENT def sortList ( arr , N , head ) : NEW_LINE INDENT Hash = { } NEW_LINE temp = head NEW_LINE while ( temp != None ) : NEW_LINE INDENT print ( head . data , end = \" \" ) NEW_LINE DEDENT temp = head . next NEW_LINE temp = temp . next NEW_LINE DEDENT temp = head NEW_LINE for i in range ( N ) : NEW_LINE INDENT frequency = Hash . get ( arr [ i ] ) NEW_LINE while ( temp . data != 0 ) : NEW_LINE INDENT temp . data = arr [ i ] NEW_LINE temp = temp . next NEW_LINE DEDENT DEDENT temp = head NEW_LINE for i in range ( N ) : NEW_LINE INDENT frequency = arr [ i ] NEW_LINE while ( frequency > 0 ) : NEW_LINE INDENT frequency = arr [ i ] NEW_LINE frequency -= 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT head = None NEW_LINE N = len ( arr ) NEW_LINE head = push ( head , 3 ) NEW_LINE head = push ( head , 3 ) NEW_LINE head = push ( head , 2 ) NEW_LINE head = push ( head , 5 ) NEW_LINE head = push ( head , 1 ) NEW_LINE head = push ( head , 2 ) NEW_LINE head = push ( head , 1 ) NEW_LINE printList ( head ) NEW_LINE DEDENT"],"references":["class Node : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . data = 0 NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def push ( head_ref , new_data ) : NEW_LINE INDENT new_node = Node ( ) NEW_LINE new_node . data = new_data NEW_LINE new_node . next = head_ref NEW_LINE head_ref = new_node NEW_LINE return head_ref NEW_LINE DEDENT def printList ( head ) : NEW_LINE INDENT while ( head != None ) : NEW_LINE INDENT print ( head . data , end = \" - > \" ) NEW_LINE head = head . next NEW_LINE DEDENT DEDENT def sortlist ( arr , N , head ) : NEW_LINE INDENT hash = dict ( ) NEW_LINE temp = head NEW_LINE while ( temp != None ) : NEW_LINE INDENT hash [ temp . data ] = hash . get ( temp . data , 0 ) + 1 NEW_LINE temp = temp . next NEW_LINE DEDENT temp = head NEW_LINE for i in range ( N ) : NEW_LINE INDENT frequency = hash . get ( arr [ i ] , 0 ) NEW_LINE while ( frequency > 0 ) : NEW_LINE INDENT frequency = frequency - 1 NEW_LINE temp . data = arr [ i ] NEW_LINE temp = temp . next NEW_LINE DEDENT DEDENT DEDENT head = None NEW_LINE arr = [ 5 , 1 , 3 , 2 , 8 ] NEW_LINE N = len ( arr ) NEW_LINE head = push ( head , 3 ) NEW_LINE head = push ( head , 2 ) NEW_LINE head = push ( head , 5 ) NEW_LINE head = push ( head , 8 ) NEW_LINE head = push ( head , 5 ) NEW_LINE head = push ( head , 2 ) NEW_LINE head = push ( head , 1 ) NEW_LINE sortlist ( arr , N , head ) NEW_LINE print ( \" Sorted ▁ List : \" ) NEW_LINE printList ( head ) NEW_LINE"],"bleu":0.719227608769592,"rouge_l":0.764603397376954}
{"id":701,"predictions":["def printPattern ( N ) : NEW_LINE INDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( \" ▁ \" + str ( i - 1 ) ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 10 NEW_LINE printPattern ( N ) NEW_LINE DEDENT"],"references":["def printPattern ( N ) : NEW_LINE INDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( i - 1 if i % 2 == 0 else i + 1 , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT N = 10 NEW_LINE printPattern ( N ) NEW_LINE"],"bleu":0.6196630359487634,"rouge_l":0.7062976560293702}
{"id":702,"predictions":["import sys NEW_LINE def minIndex ( list , sortIndex ) : NEW_LINE INDENT min_index = - 1 NEW_LINE min_value = sys . maxsize - 1 NEW_LINE s = len ( list ) NEW_LINE for i in range ( s ) : NEW_LINE INDENT current = list [ 0 ] NEW_LINE list . get ( ) NEW_LINE if ( current <= min_index and i <= sortIndex ) : NEW_LINE INDENT min_index = i NEW_LINE min_value = current NEW_LINE DEDENT list . append ( current ) NEW_LINE DEDENT return min_index NEW_LINE DEDENT def insertMinToRear ( list , min_index ) : NEW_LINE INDENT min_value = 0 NEW_LINE s = len ( list ) NEW_LINE for i in range ( s ) : NEW_LINE INDENT current = list [ 0 ] NEW_LINE list . remove ( current ) NEW_LINE if ( i != min_index ) : NEW_LINE INDENT list . append ( current ) NEW_LINE DEDENT else : NEW_LINE INDENT min_value = current NEW_LINE DEDENT DEDENT list . append ( min_value ) NEW_LINE DEDENT def sortQueue ( ) : NEW_LINE INDENT for i in range ( 1 , len ( list ) + 1 ) : NEW_LINE INDENT min_index = minIndex ( list , len ( list ) - i ) NEW_LINE insertMinToRear ( list , min_index ) NEW_LINE DEDENT DEDENT def sortQueue ( ) : NEW_LINE INDENT for i in range ( 1 , len ( list ) + 1 ) : NEW_LINE INDENT min_index = minIndex ( list , len ( list ) - i ) NEW_LINE insertMinToRear ( list , min_index ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT list = [ 30 , 30 , 15 , 15 , 4 ] NEW_LINE sortQueue ( list ) NEW_LINE while ( len ( list ) > 0 ) : NEW_LINE INDENT print ( list , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT"],"references":["from queue import Queue NEW_LINE def minIndex ( q , sortedIndex ) : NEW_LINE INDENT min_index = - 1 NEW_LINE min_val = 999999999999 NEW_LINE n = q . qsize ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr = q . queue [ 0 ] NEW_LINE q . get ( ) NEW_LINE if ( curr <= min_val and i <= sortedIndex ) : NEW_LINE INDENT min_index = i NEW_LINE min_val = curr NEW_LINE DEDENT q . put ( curr ) NEW_LINE DEDENT return min_index NEW_LINE DEDENT def insertMinToRear ( q , min_index ) : NEW_LINE INDENT min_val = None NEW_LINE n = q . qsize ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr = q . queue [ 0 ] NEW_LINE q . get ( ) NEW_LINE if ( i != min_index ) : NEW_LINE INDENT q . put ( curr ) NEW_LINE DEDENT else : NEW_LINE INDENT min_val = curr NEW_LINE DEDENT DEDENT q . put ( min_val ) NEW_LINE DEDENT def sortQueue ( q ) : NEW_LINE INDENT for i in range ( 1 , q . qsize ( ) + 1 ) : NEW_LINE INDENT min_index = minIndex ( q , q . qsize ( ) - i ) NEW_LINE insertMinToRear ( q , min_index ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT q = Queue ( ) NEW_LINE q . put ( 30 ) NEW_LINE q . put ( 11 ) NEW_LINE q . put ( 15 ) NEW_LINE q . put ( 4 ) NEW_LINE sortQueue ( q ) NEW_LINE while ( q . empty ( ) == False ) : NEW_LINE INDENT print ( q . queue [ 0 ] , end = \" ▁ \" ) NEW_LINE q . get ( ) NEW_LINE DEDENT DEDENT"],"bleu":0.43248710107999416,"rouge_l":0.6540114984202621}
{"id":703,"predictions":["def cntRotations ( s , n ) : NEW_LINE INDENT str = s + s NEW_LINE pre = [ 0 for i in range ( 2 * n ) ] NEW_LINE for i in range ( 2 * n ) : NEW_LINE INDENT if ( i != 0 ) : NEW_LINE INDENT pre [ i ] += pre [ i - 1 ] NEW_LINE DEDENT if ( str [ i ] == ' a ' or str [ i ] == ' e ' or str [ i ] == ' i ' or str [ i ] == ' o ' or str [ i ] == ' u ' ) ) : NEW_LINE INDENT pre [ i ] += 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n - 1 , 2 * n - 1 ) : NEW_LINE INDENT r = i NEW_LINE l = i - n NEW_LINE x1 = pre [ r ] NEW_LINE if ( l >= 0 ) : NEW_LINE INDENT x1 -= pre [ l ] NEW_LINE DEDENT r = i - n \/\/ 2 NEW_LINE left = pre [ r ] NEW_LINE if ( l >= 0 ) : NEW_LINE INDENT left -= pre [ l ] NEW_LINE DEDENT right = x1 - left NEW_LINE if ( left > right ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT s = \" abecidft \" NEW_LINE n = len ( s ) NEW_LINE print ( cntRotations ( s , n ) ) NEW_LINE"],"references":["def cntRotations ( s , n ) : NEW_LINE INDENT str = s + s ; NEW_LINE pre = [ 0 ] * ( 2 * n ) ; NEW_LINE for i in range ( 2 * n ) : NEW_LINE INDENT if ( i != 0 ) : NEW_LINE INDENT pre [ i ] += pre [ i - 1 ] ; NEW_LINE DEDENT if ( str [ i ] == ' a ' or str [ i ] == ' e ' or str [ i ] == ' i ' or str [ i ] == ' o ' or str [ i ] == ' u ' ) : NEW_LINE INDENT pre [ i ] += 1 ; NEW_LINE DEDENT DEDENT ans = 0 ; NEW_LINE for i in range ( n - 1 , 2 * n - 1 , 1 ) : NEW_LINE INDENT r = i ; l = i - n ; NEW_LINE x1 = pre [ r ] ; NEW_LINE if ( l >= 0 ) : NEW_LINE INDENT x1 -= pre [ l ] ; NEW_LINE DEDENT r = ( int ) ( i - n \/ 2 ) ; NEW_LINE left = pre [ r ] ; NEW_LINE if ( l >= 0 ) : NEW_LINE INDENT left -= pre [ l ] ; NEW_LINE DEDENT right = x1 - left ; NEW_LINE if ( left > right ) : NEW_LINE INDENT ans += 1 ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT s = \" abecidft \" ; NEW_LINE n = len ( s ) ; NEW_LINE print ( cntRotations ( s , n ) ) ; NEW_LINE"],"bleu":0.7824260029051573,"rouge_l":0.9274082086413076}
{"id":704,"predictions":["def msB_gap ( N ) : NEW_LINE INDENT msb_p_p = - 1 NEW_LINE while ( N ) : NEW_LINE INDENT N = N >> 1 NEW_LINE msbp_p += 1 NEW_LINE DEDENT return msb NEW_LINE DEDENT def findBitwiseOR ( L , R ) : NEW_LINE INDENT res = 0 NEW_LINE msb_p1 = [ L for _ in range ( L ) ] NEW_LINE msb_p_p2 = [ R for _ in range ( R ) ] NEW_LINE while ( msb1 == msb1 ) : NEW_LINE INDENT res_val = ( 1 << msb_p1 ) NEW_LINE res += res_val NEW_LINE L -= res_val NEW_LINE R -= res_val NEW_LINE msb_p1 = [ L ] NEW_LINE msb_p1 = [ ] NEW_LINE for i in range ( msb_p1 , - 1 , - 1 ) : NEW_LINE INDENT res_val = ( 1 << i ) NEW_LINE res += res_val NEW_LINE DEDENT return res NEW_LINE DEDENT L = 12 NEW_LINE R = 18 NEW_LINE print ( findBitwiseOR ( L , R ) ) NEW_LINE"],"references":["def MSBPosition ( N ) : NEW_LINE INDENT msb_p = - 1 NEW_LINE while ( N ) : NEW_LINE INDENT N = N >> 1 NEW_LINE msb_p += 1 NEW_LINE DEDENT return msb_p NEW_LINE DEDENT def findBitwiseOR ( L , R ) : NEW_LINE INDENT res = 0 NEW_LINE msb_p1 = MSBPosition ( L ) NEW_LINE msb_p2 = MSBPosition ( R ) NEW_LINE while ( msb_p1 == msb_p2 ) : NEW_LINE INDENT res_val = ( 1 << msb_p1 ) NEW_LINE res += res_val NEW_LINE L -= res_val NEW_LINE R -= res_val NEW_LINE msb_p1 = MSBPosition ( L ) NEW_LINE msb_p2 = MSBPosition ( R ) NEW_LINE DEDENT msb_p1 = max ( msb_p1 , msb_p2 ) NEW_LINE for i in range ( msb_p1 , - 1 , - 1 ) : NEW_LINE INDENT res_val = ( 1 << i ) NEW_LINE res += res_val NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT L , R = 12 , 18 NEW_LINE print ( findBitwiseOR ( L , R ) ) NEW_LINE DEDENT"],"bleu":0.64442033418541,"rouge_l":0.7892368273017063}
{"id":705,"predictions":["def sieve ( prime , n ) : NEW_LINE INDENT prime [ 0 ] = False ; NEW_LINE prime [ 1 ] = False ; NEW_LINE p = 2 ; NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def sumPrime ( d ) : NEW_LINE INDENT maxVal = int ( pow ( 10 , d ) ) - 1 ; NEW_LINE prime = [ True ] * ( maxVal + 1 ) ; NEW_LINE for i in range ( maxVal + 1 ) : NEW_LINE INDENT prime [ i ] = True ; NEW_LINE DEDENT sieve ( prime , maxVal ) ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( 2 , maxVal + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT sum += i ; NEW_LINE DEDENT DEDENT return sum ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT d = 3 ; NEW_LINE print ( sumPrime ( d ) ) ; NEW_LINE DEDENT"],"references":["from math import sqrt NEW_LINE def sieve ( prime , n ) : NEW_LINE INDENT prime [ 0 ] = False ; NEW_LINE prime [ 1 ] = False ; NEW_LINE for p in range ( 2 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def sumPrime ( d ) : NEW_LINE INDENT maxVal = ( 10 ** d ) - 1 ; NEW_LINE prime = [ True ] * ( maxVal + 1 ) ; NEW_LINE sieve ( prime , maxVal ) ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( 2 , maxVal + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT sum += i ; NEW_LINE DEDENT DEDENT return sum ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT d = 3 ; NEW_LINE print ( sumPrime ( d ) ) ; NEW_LINE DEDENT"],"bleu":0.8295300468053869,"rouge_l":0.8822512183618928}
{"id":706,"predictions":["MAX_CHAR = 256 NEW_LINE def kthNonRepeating ( str , k ) : NEW_LINE INDENT n = len ( str ) NEW_LINE count = [ 0 for i in range ( MAX_CHAR ) ] NEW_LINE count = [ 0 for i in range ( MAX_CHAR ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = str [ i ] NEW_LINE count [ x ] += 1 NEW_LINE if ( count [ x ] == 1 ) : NEW_LINE INDENT index [ x ] = i NEW_LINE DEDENT if ( count [ x ] == 2 ) : NEW_LINE INDENT index [ x ] = i NEW_LINE DEDENT if ( count [ x ] == 2 ) : NEW_LINE INDENT index [ x ] = n NEW_LINE DEDENT DEDENT index . sort ( ) NEW_LINE return index [ k - 1 ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeksforgeeks \" NEW_LINE k = 3 NEW_LINE res = kthNonRepeating ( str , k ) NEW_LINE if ( res == - 1 ) : NEW_LINE INDENT print ( \" There ▁ are ▁ less ▁ are ▁ \" , str [ res ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" k ' ) NEW_LINE DEDENT DEDENT"],"references":["MAX_CHAR = 256 NEW_LINE def kthNonRepeating ( str , k ) : NEW_LINE INDENT n = len ( str ) NEW_LINE count = [ 0 ] * MAX_CHAR NEW_LINE index = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT count [ i ] = 0 NEW_LINE index [ i ] = n NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT x = str [ i ] NEW_LINE count [ ord ( x ) ] += 1 NEW_LINE if ( count [ ord ( x ) ] == 1 ) : NEW_LINE INDENT index [ ord ( x ) ] = i NEW_LINE DEDENT if ( count [ ord ( x ) ] == 2 ) : NEW_LINE INDENT index [ ord ( x ) ] = n NEW_LINE DEDENT DEDENT index . sort ( ) NEW_LINE return index [ k - 1 ] if ( index [ k - 1 ] != n ) else - 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeksforgeeks \" NEW_LINE k = 3 NEW_LINE res = kthNonRepeating ( str , k ) NEW_LINE if ( res == - 1 ) : NEW_LINE INDENT print ( \" There ▁ are ▁ less ▁ than ▁ k \" , \" non - repeating ▁ characters \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" k ' th ▁ non - repeating ▁ character ▁ is \" , str [ res ] ) NEW_LINE DEDENT DEDENT"],"bleu":0.6543312035282811,"rouge_l":0.7721007289595759}
{"id":707,"predictions":["def squareDigitSum ( number ) : NEW_LINE INDENT summ = 0 NEW_LINE num = int ( number ) NEW_LINE squareNum = num * num NEW_LINE while ( squareNum ) : NEW_LINE INDENT summ = summ + ( squareNum % 10 ) NEW_LINE squareNum = ( squareNum \/\/ 10 ) NEW_LINE DEDENT return summ NEW_LINE DEDENT N = \"1111\" NEW_LINE print ( squareDigitSum ( N ) ) NEW_LINE"],"references":["def squareDigitSum ( num ) : NEW_LINE INDENT summ = 0 NEW_LINE num = int ( num ) NEW_LINE squareNum = num * num NEW_LINE while squareNum > 0 : NEW_LINE INDENT summ = summ + ( squareNum % 10 ) NEW_LINE squareNum = squareNum \/\/ 10 NEW_LINE DEDENT return summ NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = \"1111\" NEW_LINE print ( squareDigitSum ( N ) ) NEW_LINE DEDENT"],"bleu":0.6331073147882564,"rouge_l":0.8234122593494135}
{"id":708,"predictions":["def maxCost ( a , n , l , r ) : NEW_LINE INDENT mx = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mx = max ( mx , a [ i ] ) NEW_LINE DEDENT count = [ 0 ] * ( mx + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ a [ i ] ] += 1 NEW_LINE DEDENT res = [ 0 ] * ( mx + 1 ) NEW_LINE res [ 0 ] = 0 NEW_LINE l = min ( l , r ) NEW_LINE for num in range ( 1 , mx + 1 ) : NEW_LINE INDENT k = max ( num - l - 1 , 0 ) NEW_LINE res [ num ] = max ( res [ num - 1 ] , num * count [ num ] + res [ k ] ) NEW_LINE DEDENT return res [ mx ] NEW_LINE DEDENT a = [ 2 , 1 , 2 , 3 , 2 , 2 , 1 ] NEW_LINE l = 1 NEW_LINE r = 1 NEW_LINE n = len ( a ) NEW_LINE print ( maxCost ( a , n , l , r ) ) NEW_LINE"],"references":["def maxCost ( a , n , l , r ) : NEW_LINE INDENT mx = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mx = max ( mx , a [ i ] ) NEW_LINE DEDENT count = [ 0 ] * ( mx + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ a [ i ] ] += 1 NEW_LINE DEDENT res = [ 0 ] * ( mx + 1 ) NEW_LINE res [ 0 ] = 0 NEW_LINE l = min ( l , r ) NEW_LINE for num in range ( 1 , mx + 1 ) : NEW_LINE INDENT k = max ( num - l - 1 , 0 ) NEW_LINE res [ num ] = max ( res [ num - 1 ] , num * count [ num ] + res [ k ] ) NEW_LINE DEDENT return res [ mx ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 2 , 1 , 2 , 3 , 2 , 2 , 1 ] NEW_LINE l , r = 1 , 1 NEW_LINE n = len ( a ) NEW_LINE print ( maxCost ( a , n , l , r ) ) NEW_LINE DEDENT"],"bleu":0.9077783836711633,"rouge_l":0.9486355140186916}
{"id":709,"predictions":["def findPosition ( k , n ) : NEW_LINE INDENT f1 = 0 NEW_LINE f2 = 1 NEW_LINE i = 2 NEW_LINE while ( i != 0 ) : NEW_LINE INDENT f3 = f1 + f2 NEW_LINE f1 = f3 NEW_LINE f2 = f3 NEW_LINE if ( f2 % k == 0 ) : NEW_LINE INDENT return n * i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 NEW_LINE k = 4 NEW_LINE print ( \" Position ▁ of ▁ n ' th ▁ of ▁ n ' th ▁ multiple ▁ is \" , findPosition ( k , n ) ) NEW_LINE DEDENT"],"references":["def findPosition ( k , n ) : NEW_LINE INDENT f1 = 0 NEW_LINE f2 = 1 NEW_LINE i = 2 ; NEW_LINE while i != 0 : NEW_LINE INDENT f3 = f1 + f2 ; NEW_LINE f1 = f2 ; NEW_LINE f2 = f3 ; NEW_LINE if f2 % k == 0 : NEW_LINE INDENT return n * i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return NEW_LINE DEDENT n = 5 ; NEW_LINE k = 4 ; NEW_LINE print ( \" Position ▁ of ▁ n ' th ▁ multiple ▁ of ▁ k ▁ in \" \" Fibonacci ▁ Seires ▁ is \" , findPosition ( k , n ) ) ; NEW_LINE"],"bleu":0.6371526733943227,"rouge_l":0.8328506412908565}
{"id":710,"predictions":["def printTheArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def generateAllBinaryStrings ( n , arr , i ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT printTheArray ( arr , n ) NEW_LINE return NEW_LINE DEDENT arr [ i ] = 0 NEW_LINE generateAllBinaryStrings ( n , arr , i + 1 ) NEW_LINE arr [ i ] = 1 NEW_LINE generateAllBinaryStrings ( n , arr , i + 1 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 NEW_LINE arr = [ 0 ] * n NEW_LINE generateAllBinaryStrings ( n , arr , 0 ) NEW_LINE DEDENT"],"references":["def printTheArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def generateAllBinaryStrings ( n , arr , i ) : NEW_LINE INDENT if i == n : NEW_LINE INDENT printTheArray ( arr , n ) NEW_LINE return NEW_LINE DEDENT arr [ i ] = 0 NEW_LINE generateAllBinaryStrings ( n , arr , i + 1 ) NEW_LINE arr [ i ] = 1 NEW_LINE generateAllBinaryStrings ( n , arr , i + 1 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 NEW_LINE arr = [ None ] * n NEW_LINE generateAllBinaryStrings ( n , arr , 0 ) NEW_LINE DEDENT"],"bleu":0.93770401756101,"rouge_l":0.9790209790209791}
{"id":711,"predictions":["X = \" AGGT12B \" NEW_LINE Y = \"12A \" NEW_LINE Z = \"12A \" NEW_LINE def lcsOf3 ( i , j , k ) : NEW_LINE INDENT if ( i == - 1 or j == - 1 or k == - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ j ] [ k ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] [ k ] NEW_LINE DEDENT if ( X [ i ] == Y [ j ] and Y [ j ] == Z [ k ] ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT if ( X [ i ] == Y [ j ] and Y [ j ] == Z [ k ] ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = 1 + lcsOf3 ( i - 1 , j - 1 , k - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = max ( max ( lcsOf3 ( i - 1 , j , k ) , lcsOf3 ( i , j , k - 1 , k - 1 ) ) , lcsOf3 ( i , j , j , k - 1 ) ) NEW_LINE DEDENT DEDENT return len ( X ) NEW_LINE n = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE n = len ( Y ) NEW_LINE o = len ( Y ) NEW_LINE print ( \" Length ▁ of ▁ LCS ▁ is \" , lcsOf3 ( m - 1 , n - 1 , o - 1 ) ) NEW_LINE"],"references":["X = \" AGGT12\" NEW_LINE Y = \"12TXAYB \" NEW_LINE Z = \"12XBA \" NEW_LINE dp = [ [ [ - 1 for i in range ( 100 ) ] for j in range ( 100 ) ] for k in range ( 100 ) ] NEW_LINE def lcsOf3 ( i , j , k ) : NEW_LINE INDENT if ( i == - 1 or j == - 1 or k == - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ j ] [ k ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] [ k ] NEW_LINE DEDENT if ( X [ i ] == Y [ j ] and Y [ j ] == Z [ k ] ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = 1 + lcsOf3 ( i - 1 , j - 1 , k - 1 ) NEW_LINE return dp [ i ] [ j ] [ k ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = max ( max ( lcsOf3 ( i - 1 , j , k ) , lcsOf3 ( i , j - 1 , k ) ) , lcsOf3 ( i , j , k - 1 ) ) NEW_LINE return dp [ i ] [ j ] [ k ] NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT m = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE o = len ( Z ) NEW_LINE print ( \" Length ▁ of ▁ LCS ▁ is \" , lcsOf3 ( m - 1 , n - 1 , o - 1 ) ) NEW_LINE DEDENT"],"bleu":0.7778507588100125,"rouge_l":0.7781529720748245}
{"id":712,"predictions":["def checkTriangularSum ( n ) : NEW_LINE INDENT tri = set ( ) NEW_LINE i = 1 NEW_LINE while True : NEW_LINE INDENT x = i * ( i + 1 ) \/ 2 NEW_LINE if x >= n : NEW_LINE INDENT break NEW_LINE DEDENT tri . add ( x ) NEW_LINE i += 1 NEW_LINE DEDENT for tm in tri : NEW_LINE INDENT if n - tm in tri . keys ( ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT n = 24 NEW_LINE if ( checkTriangularSum Representation ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def checkTriangularSumRepresentation ( n ) : NEW_LINE INDENT tri = list ( ) ; NEW_LINE i = 1 ; NEW_LINE while ( 1 ) : NEW_LINE INDENT x = i * ( i + 1 ) \/\/ 2 ; NEW_LINE if ( x >= n ) : NEW_LINE INDENT break ; NEW_LINE DEDENT tri . append ( x ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT for tm in tri : NEW_LINE INDENT if n - tm in tri : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT return False ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 24 ; NEW_LINE if checkTriangularSumRepresentation ( n ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.5669950050468946,"rouge_l":0.8132329342056536}
{"id":713,"predictions":["import math NEW_LINE eps = 1e-6 NEW_LINE def getArea ( base , powers ) : NEW_LINE INDENT height = math . sqrt ( dividend + base * base ) NEW_LINE return 0.5 * base NEW_LINE DEDENT def printRightAngleTriangle ( height ) : NEW_LINE INDENT hsquare = pow ( height , powers ) ** 2.5 NEW_LINE sideForMaxArea = math . sqrt ( hsquare \/ 2.0 ) NEW_LINE maxArea = getArea ( sideForMaxArea ) NEW_LINE if ( area > maxArea ) : NEW_LINE INDENT print ( \" Not ▁ possible \" ) NEW_LINE return NEW_LINE DEDENT height = 0 NEW_LINE height = 0 NEW_LINE while ( height > 0.0 ) : NEW_LINE INDENT height = ( height + hih ) \/ 2 NEW_LINE if ( volumeArea ( height , height ) >= 0.0 ) : NEW_LINE INDENT height = b NEW_LINE DEDENT else : NEW_LINE INDENT height = height NEW_LINE DEDENT DEDENT height = 0.0 NEW_LINE height = 0 NEW_LINE while ( height < Max ) : NEW_LINE INDENT height = ( height + height ) \/ 2 NEW_LINE if ( Geeks [ height ] >= area ) : NEW_LINE INDENT height = height NEW_LINE DEDENT else : NEW_LINE INDENT length = b NEW_LINE DEDENT DEDENT height = abs ( height - base * base ) NEW_LINE print ( ( round , ( height ) , ( height ) ) ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT slope = 5 NEW_LINE divide = 5 NEW_LINE printRightAngleTriangle ( slope ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def getArea ( base , hypotenuse ) : NEW_LINE INDENT height = math . sqrt ( hypotenuse * hypotenuse - base * base ) ; NEW_LINE return 0.5 * base * height NEW_LINE DEDENT def printRightAngleTriangle ( hypotenuse , area ) : NEW_LINE INDENT hsquare = hypotenuse * hypotenuse NEW_LINE sideForMaxArea = math . sqrt ( hsquare \/ 2.0 ) NEW_LINE maxArea = getArea ( sideForMaxArea , hypotenuse ) NEW_LINE if ( area > maxArea ) : NEW_LINE INDENT print ( \" Not ▁ possiblen \" ) NEW_LINE return NEW_LINE DEDENT low = 0.0 NEW_LINE high = sideForMaxArea NEW_LINE while ( abs ( high - low ) > 1e-6 ) : NEW_LINE INDENT base = ( low + high ) \/ 2.0 NEW_LINE if ( getArea ( base , hypotenuse ) >= area ) : NEW_LINE INDENT high = base NEW_LINE DEDENT else : NEW_LINE INDENT low = base NEW_LINE DEDENT DEDENT height = math . ceil ( math . sqrt ( hsquare - base * base ) ) NEW_LINE base = math . floor ( base ) NEW_LINE print ( base , height ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT hypotenuse = 5 NEW_LINE area = 6 NEW_LINE printRightAngleTriangle ( hypotenuse , area ) NEW_LINE DEDENT"],"bleu":0.4136401737268162,"rouge_l":0.6584720384427886}
{"id":714,"predictions":["def Findder ( st , R ) : NEW_LINE INDENT l = len ( st ) NEW_LINE rem = 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT Num = rem * 10 + ( ord ( st [ i ] ) - ord ( '0' ) ) ) NEW_LINE rem = Num % R NEW_LINE DEDENT return rem NEW_LINE DEDENT st = \"13589234356546756\" NEW_LINE R = 13 NEW_LINE print ( Rearder ( st , R ) ) NEW_LINE"],"references":["def Remainder ( str , R ) : NEW_LINE INDENT l = len ( str ) NEW_LINE Rem = 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT Num = Rem * 10 + ( ord ( str [ i ] ) - ord ( '0' ) ) NEW_LINE Rem = Num % R NEW_LINE DEDENT return Rem NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \"13589234356546756\" NEW_LINE R = 13 NEW_LINE print ( Remainder ( str , R ) ) NEW_LINE DEDENT"],"bleu":0.5703141039880355,"rouge_l":0.7806215722120659}
{"id":715,"predictions":["def xorGivenSetBits ( arr , n , k ) : NEW_LINE INDENT v = list ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( bin ( arr [ i ] ) . count ( '1' ) == k ) : NEW_LINE INDENT v . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT result = v [ 0 ] NEW_LINE for i in range ( 1 , len ( v ) ) : NEW_LINE INDENT result = result ^ v [ i ] NEW_LINE DEDENT return result NEW_LINE DEDENT arr = [ 2 , 13 , 1 , 19 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE print ( xorGivenSetBits ( arr , n , k ) ) NEW_LINE"],"references":["def xorGivenSetBits ( arr , n , k ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( bin ( arr [ i ] ) . count ( '1' ) == k ) : NEW_LINE INDENT v . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT result = v [ 0 ] NEW_LINE for i in range ( 1 , len ( v ) , 1 ) : NEW_LINE INDENT result = result ^ v [ i ] NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 13 , 1 , 19 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE print ( xorGivenSetBits ( arr , n , k ) ) NEW_LINE DEDENT"],"bleu":0.8021814471023548,"rouge_l":0.9014436739797657}
{"id":716,"predictions":["def addBinaryUtil ( a , b ) : NEW_LINE INDENT result = \" \" NEW_LINE s = 0 NEW_LINE i = len ( a ) - 1 NEW_LINE j = len ( b ) - 1 NEW_LINE while ( i >= 0 or j >= 0 or s == 1 ) : NEW_LINE INDENT s += ( a [ i ] ) - ord ( '0' ) NEW_LINE DEDENT if ( j >= 0 ) : NEW_LINE INDENT s += ( b [ j ] ) NEW_LINE DEDENT s += ( s % 2 + result ) NEW_LINE s \/\/= 2 NEW_LINE s \/\/= 2 NEW_LINE i -= 1 NEW_LINE j -= 1 NEW_LINE DEDENT return result NEW_LINE DEDENT def addBinary ( arr , n ) : NEW_LINE INDENT result = \" \" NEW_LINE for i in range ( n ) : NEW_LINE INDENT result = addBinaryUtil ( result , arr [ i ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ \"1\" , \"10\" , \"11\" ] NEW_LINE n = len ( arr ) NEW_LINE print ( addBinary ( arr , n ) ) NEW_LINE DEDENT"],"references":["def addBinaryUtil ( a , b ) : NEW_LINE INDENT result = \" \" ; NEW_LINE s = 0 ; NEW_LINE i = len ( a ) - 1 ; NEW_LINE j = len ( b ) - 1 ; NEW_LINE while ( i >= 0 or j >= 0 or s == 1 ) : NEW_LINE INDENT s += ( ord ( a [ i ] ) - ord ( '0' ) ) if ( i >= 0 ) else 0 ; NEW_LINE s += ( ord ( b [ j ] ) - ord ( '0' ) ) if ( j >= 0 ) else 0 ; NEW_LINE result = chr ( s % 2 + ord ( '0' ) ) + result ; NEW_LINE s \/\/= 2 ; NEW_LINE i -= 1 ; NEW_LINE j -= 1 ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT def addBinary ( arr , n ) : NEW_LINE INDENT result = \" \" ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT result = addBinaryUtil ( result , arr [ i ] ) ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT arr = [ \"1\" , \"10\" , \"11\" ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( addBinary ( arr , n ) ) ; NEW_LINE"],"bleu":0.6401903699601775,"rouge_l":0.8162563083040221}
{"id":717,"predictions":["def absoluteComplement ( arr1 , arr2 , n , m ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE while ( i < n and j < m ) : NEW_LINE INDENT if ( arr1 [ i ] < arr2 [ j ] ) : NEW_LINE INDENT print ( arr1 [ i ] , end = \" ▁ \" ) NEW_LINE i += 1 NEW_LINE DEDENT elif ( arr1 [ i ] > arr2 [ j ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT elif ( arr1 [ i ] == arr2 [ j ] ) : NEW_LINE INDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT while ( i < n ) : NEW_LINE INDENT print ( arr1 [ i ] , end = \" \" ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT while ( i < n ) : NEW_LINE INDENT print ( arr1 [ i ] , end = \" ▁ \" ) NEW_LINE j = j + 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr1 = [ 3 , 6 , 10 , 12 , 10 ] NEW_LINE arr2 = [ 1 , 3 , 5 , 10 , 10 ] NEW_LINE n = len ( arr1 ) NEW_LINE m = len ( arr2 ) NEW_LINE absoluteComplement ( arr1 , arr2 , n , m ) NEW_LINE DEDENT"],"references":["def relativeComplement ( arr1 , arr2 , n , m ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE while ( i < n and j < m ) : NEW_LINE INDENT if ( arr1 [ i ] < arr2 [ j ] ) : NEW_LINE INDENT print ( arr1 [ i ] , \" ▁ \" , end = \" \" ) NEW_LINE i += 1 NEW_LINE DEDENT elif ( arr1 [ i ] > arr2 [ j ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT elif ( arr1 [ i ] == arr2 [ j ] ) : NEW_LINE INDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT while ( i < n ) : NEW_LINE INDENT print ( arr1 [ i ] , \" ▁ \" , end = \" \" ) NEW_LINE DEDENT DEDENT arr1 = [ 3 , 6 , 10 , 12 , 15 ] NEW_LINE arr2 = [ 1 , 3 , 5 , 10 , 16 ] NEW_LINE n = len ( arr1 ) NEW_LINE m = len ( arr2 ) NEW_LINE relativeComplement ( arr1 , arr2 , n , m ) NEW_LINE"],"bleu":0.7436527158998545,"rouge_l":0.8781992687385741}
{"id":718,"predictions":["if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" ABCdpba \" NEW_LINE u = [ 0 ] * 26 NEW_LINE n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT u [ ord ( s [ i ] ) - ord ( ' a ' ) - ord ( ' a ' ) ] -= 1 NEW_LINE DEDENT DEDENT f1 = True NEW_LINE po = 0 NEW_LINE ne = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if u [ i ] > 0 : NEW_LINE INDENT po += u [ i ] NEW_LINE DEDENT if ( u [ i ] < 0 ) : NEW_LINE INDENT ne += u [ i ] NEW_LINE DEDENT DEDENT if ( po == 0 and ne == 0 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT elif ( po == 1 and ne == 0 ) : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"references":["s = \" ABCdcba \" NEW_LINE u = [ 0 ] * 26 NEW_LINE n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] . isupper ( ) ) : NEW_LINE INDENT u [ ord ( s [ i ] ) - 65 ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT u [ ord ( s [ i ] ) - 97 ] -= 1 NEW_LINE DEDENT DEDENT fl = True NEW_LINE po = 0 NEW_LINE ne = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( u [ i ] > 0 ) : NEW_LINE INDENT po += u [ i ] NEW_LINE DEDENT if ( u [ i ] < 0 ) : NEW_LINE INDENT ne += u [ i ] NEW_LINE DEDENT DEDENT if ( po == 0 and ne == 0 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT elif ( po == 1 and ne == 0 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT elif ( po == 0 and ne == - 1 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"],"bleu":0.7687061681942566,"rouge_l":0.8190683369589679}
{"id":719,"predictions":["def isPalindrome ( s ) : NEW_LINE INDENT i = 0 NEW_LINE j = len ( s ) - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT if ( s [ i ] != s [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def getIndex ( S1 , S2 , n ) : NEW_LINE INDENT S = \" \" NEW_LINE for i in range ( n ) : NEW_LINE INDENT S = S + S1 [ i ] NEW_LINE temp = \" \" NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT temp += S2 [ j ] NEW_LINE DEDENT if ( isPalindrome ( S + temp ) ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT S1 = \" abcdf \" NEW_LINE S2 = \" sfgba \" NEW_LINE n = len ( S1 ) NEW_LINE print ( getIndex ( S1 , S2 , n ) ) NEW_LINE"],"references":["def isPalindrome ( s ) : NEW_LINE INDENT i = 0 ; NEW_LINE j = len ( s ) - 1 ; NEW_LINE while ( i < j ) : NEW_LINE INDENT if ( s [ i ] is not s [ j ] ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT i += 1 ; NEW_LINE j -= 1 ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT def getIndex ( S1 , S2 , n ) : NEW_LINE INDENT S = \" \" ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT S = S + S1 [ i ] ; NEW_LINE Temp = \" \" ; NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT Temp += S2 [ j ] ; NEW_LINE DEDENT if ( isPalindrome ( S + Temp ) ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT S1 = \" abcdf \" ; S2 = \" sfgba \" ; NEW_LINE n = len ( S1 ) ; NEW_LINE print ( getIndex ( S1 , S2 , n ) ) ; NEW_LINE"],"bleu":0.7328808626880827,"rouge_l":0.9229490991778905}
{"id":720,"predictions":["def XorSum ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 != 0 ) : NEW_LINE INDENT result += arr [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT arr = [ 1 , 2 , 6 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( XorSum ( arr , n ) ) NEW_LINE"],"references":["def XorSum ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 != 0 ) : NEW_LINE INDENT result += arr [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT arr = [ 1 , 2 , 6 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( XorSum ( arr , n ) ) NEW_LINE"],"bleu":1.0,"rouge_l":1.0}
{"id":721,"predictions":["import math NEW_LINE def count ( arr , n , x ) : NEW_LINE INDENT if ( x == 1 ) : NEW_LINE INDENT ans = pow ( 2 , n ) - 1 NEW_LINE return ans NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % x == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT ans = pow ( 2 , count ) - 1 NEW_LINE return ans NEW_LINE DEDENT arr = [ 2 , 4 , 3 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE x = 1 NEW_LINE print ( count ( arr , n , x ) ) NEW_LINE"],"references":["def count ( arr , n , x ) : NEW_LINE INDENT if ( x == 1 ) : NEW_LINE INDENT ans = pow ( 2 , n ) - 1 NEW_LINE return ans ; NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % x == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT ans = pow ( 2 , count ) - 1 NEW_LINE return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 4 , 3 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE x = 1 NEW_LINE print ( count ( arr , n , x ) ) NEW_LINE DEDENT"],"bleu":0.864074587117074,"rouge_l":0.9224952741020793}
{"id":722,"predictions":["def removeSpecialCharacter ( str ) : NEW_LINE INDENT j = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( ( ( ord ( ' A ' ) ) >= ' A ' and ord ( str [ i ] ) <= ord ( ' Z ' ) and ( ord ( s [ i ] ) >= ord ( ' a ' ) and ord ( s [ i ] ) <= ord ( ' z ' ) and ord ( ord ( s [ i ] ) >= ord ( ' a ' ) and ord ( s [ i ] ) <= ord ( ' z ' ) and ord ( s [ i ] ) <= ord ( ' z ' ) ) ) ) ) : NEW_LINE INDENT s [ j ] = s [ i ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT print ( s ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" Gee * k ; NEW_LINE s = \" Gee * k ; s . fo , ▁ r ' Ge ^ eks ? \" ; NEW_LINE removeSpecialCharacter ( s ) ; NEW_LINE DEDENT"],"references":["def removeSpecialCharacter ( s ) : NEW_LINE INDENT t = \" \" NEW_LINE for i in s : NEW_LINE INDENT if ( i >= ' A ' and i <= ' Z ' ) or ( i >= ' a ' and i <= ' z ' ) : NEW_LINE INDENT t += i NEW_LINE DEDENT DEDENT print ( t ) NEW_LINE DEDENT s = \" $ Gee * k ; s . . fo , ▁ r ' Ge ^ eks ? \" NEW_LINE removeSpecialCharacter ( s ) NEW_LINE"],"bleu":0.2288344547498558,"rouge_l":0.5587786259541985}
{"id":723,"predictions":["def calculate ( a , b , n , m ) : NEW_LINE INDENT mul = 1 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if ( b [ i ] ) : NEW_LINE INDENT mul = mul * b [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT x = floor ( a [ i ] \/ mul ) NEW_LINE print ( x , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT a = [ 5 , 100 , 8 ] NEW_LINE b = [ 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE calculate ( a , b , n , m ) NEW_LINE"],"references":["import math NEW_LINE def calculate ( a , b , n , m ) : NEW_LINE INDENT mul = 1 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if ( b [ i ] != 0 ) : NEW_LINE INDENT mul = mul * b [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT x = math . floor ( a [ i ] \/ mul ) NEW_LINE print ( x , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT a = [ 5 , 100 , 8 ] NEW_LINE b = [ 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE calculate ( a , b , n , m ) NEW_LINE"],"bleu":0.9236249166389535,"rouge_l":0.9684960620077508}
{"id":724,"predictions":["from math import sqrt NEW_LINE def sieve ( maxEle , prime ) : NEW_LINE INDENT prime [ 0 ] = prime [ 1 ] = 1 NEW_LINE for i in range ( 2 , int ( sqrt ( maxEle ) ) + 1 , 1 ) : NEW_LINE INDENT if ( prime [ i ] == 0 ) : NEW_LINE INDENT for j in range ( 2 * i , maxEle + 1 , i ) : NEW_LINE INDENT prime [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT def digitSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT sum += n % 10 NEW_LINE n = int ( n \/ 10 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT def printAdditivePrime ( arr , n ) : NEW_LINE INDENT maxEle = max ( arr ) NEW_LINE prime = [ 0 for i in range ( maxEle + 1 ) ] NEW_LINE sieve ( maxEle , prime ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] == 0 ) : NEW_LINE INDENT sum = digitSum ( arr [ i ] ) NEW_LINE if ( prime [ sum ] == 0 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 2 , 4 , 6 , 10 , 10 , 10 , 12 , 7 ] NEW_LINE n = len ( a ) NEW_LINE printAdditivePrime ( a , n ) NEW_LINE DEDENT"],"references":["from math import sqrt NEW_LINE def sieve ( maxEle , prime ) : NEW_LINE INDENT prime [ 0 ] , prime [ 1 ] = 1 , 1 NEW_LINE for i in range ( 2 , int ( sqrt ( maxEle ) ) + 1 ) : NEW_LINE INDENT if ( not prime [ i ] ) : NEW_LINE INDENT for j in range ( 2 * i , maxEle + 1 , i ) : NEW_LINE INDENT prime [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT def digitSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n ) : NEW_LINE INDENT sum += n % 10 NEW_LINE n = n \/\/ 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT def printAdditivePrime ( arr , n ) : NEW_LINE INDENT maxEle = max ( arr ) NEW_LINE prime = [ 0 ] * ( maxEle + 1 ) NEW_LINE sieve ( maxEle , prime ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] == 0 ) : NEW_LINE INDENT sum = digitSum ( arr [ i ] ) NEW_LINE if ( prime [ sum ] == 0 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 2 , 4 , 6 , 11 , 12 , 18 , 7 ] NEW_LINE n = len ( a ) NEW_LINE printAdditivePrime ( a , n ) NEW_LINE DEDENT"],"bleu":0.876277509111356,"rouge_l":0.9475306812118337}
{"id":725,"predictions":["def check ( n , m ) : NEW_LINE INDENT if ( m % n == 0 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT n = 5 NEW_LINE m = 10 NEW_LINE check ( n , m ) NEW_LINE"],"references":["def check ( n , m ) : NEW_LINE INDENT if ( m % n == 0 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT n = 5 NEW_LINE m = 10 NEW_LINE check ( n , m ) NEW_LINE"],"bleu":1.0,"rouge_l":1.0}
{"id":726,"predictions":["def findPowerOfP ( N , p ) : NEW_LINE INDENT count = 0 NEW_LINE r = p NEW_LINE while ( r <= N ) : NEW_LINE INDENT count += ( N \/\/ r ) NEW_LINE r = r * p NEW_LINE DEDENT return count NEW_LINE DEDENT def primeFactorso_B ( B ) : NEW_LINE INDENT ans = [ ] NEW_LINE for B != 1 : NEW_LINE INDENT if ( B % i == 0 ) : NEW_LINE INDENT count = 0 NEW_LINE while ( B % i == 0 ) : NEW_LINE INDENT B = B \/\/ i NEW_LINE count += 1 NEW_LINE DEDENT ans . append ( [ i , count ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def largestPowerOfB ( N , B ) : NEW_LINE INDENT vec = [ ] NEW_LINE vec = primeFactorsofB ( B ) NEW_LINE ans = 10 ** 9 NEW_LINE for i in range ( len ( vec ) ) : NEW_LINE INDENT ans = min ( ans , findPowerOfP ( N , vec [ i ] [ 0 ] ) \/ vec [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( largestPowerOfB ( 5 , 2 ) ) NEW_LINE print ( largestPowerOfB ( 6 , 9 ) ) NEW_LINE print ( largestPowerOfB ( 6 , 9 ) ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE def findPowerOfP ( N , p ) : NEW_LINE INDENT count = 0 NEW_LINE r = p NEW_LINE while ( r <= N ) : NEW_LINE INDENT count += int ( N \/ r ) NEW_LINE r = r * p NEW_LINE DEDENT return count NEW_LINE DEDENT def primeFactorsofB ( B ) : NEW_LINE INDENT ans = [ ] NEW_LINE i = 2 NEW_LINE while ( B != 1 ) : NEW_LINE INDENT if ( B % i == 0 ) : NEW_LINE INDENT count = 0 NEW_LINE while ( B % i == 0 ) : NEW_LINE INDENT B = int ( B \/ i ) NEW_LINE count += 1 NEW_LINE DEDENT ans . append ( ( i , count ) ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT def largestPowerOfB ( N , B ) : NEW_LINE INDENT vec = [ ] NEW_LINE vec = primeFactorsofB ( B ) NEW_LINE ans = sys . maxsize NEW_LINE ans = min ( ans , int ( findPowerOfP ( N , vec [ 0 ] [ 0 ] ) \/ vec [ 0 ] [ 1 ] ) ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( largestPowerOfB ( 5 , 2 ) ) NEW_LINE print ( largestPowerOfB ( 6 , 9 ) ) NEW_LINE DEDENT"],"bleu":0.7716219019774758,"rouge_l":0.8532065179383173}
{"id":727,"predictions":["def printCombination ( n ) : NEW_LINE INDENT print ( 1 , end = \" ▁ \" ) NEW_LINE if ( ( n - 2 ) % 3 == 0 ) : NEW_LINE INDENT print ( 2 , ( n - 3 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 , ( n - 2 ) ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 256 NEW_LINE printCombination ( n ) NEW_LINE DEDENT"],"references":["def printCombination ( n ) : NEW_LINE INDENT print ( \"1 ▁ \" , end = \" \" ) ; NEW_LINE if ( ( n - 2 ) % 3 == 0 ) : NEW_LINE INDENT print ( \"2\" , n - 3 , end = \" \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \"1\" , ( n - 2 ) , end = \" \" ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 233 ; NEW_LINE printCombination ( n ) ; NEW_LINE DEDENT"],"bleu":0.570330603090547,"rouge_l":0.8168695652173914}
{"id":728,"predictions":["import math NEW_LINE def createHash ( hash , maxElement ) : NEW_LINE INDENT prev = 0 NEW_LINE curr = 1 NEW_LINE hash . add ( prev ) NEW_LINE hash . add ( curr ) NEW_LINE while ( curr <= maxElement ) : NEW_LINE INDENT temp = curr + prev NEW_LINE hash . add ( temp ) NEW_LINE prev = curr NEW_LINE curr = temp NEW_LINE DEDENT DEDENT def countFibonacciDivisors ( n ) : NEW_LINE INDENT hash = set ( ) NEW_LINE createHash ( hash , n ) NEW_LINE cnt = 0 NEW_LINE for i in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( ( n \/ i == i ) and ( int ( n \/ i ) in hash . keys ( ) ) ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( n \/ i ) in hash . keys ( ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT if ( int ( n \/ ( n \/ ( n \/ ( n \/ i ) ) ) ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT n = 12 NEW_LINE print ( countFibonacciDivisors ( n ) ) NEW_LINE"],"references":["from math import sqrt , ceil , floor NEW_LINE def createHash ( maxElement ) : NEW_LINE INDENT prev = 0 NEW_LINE curr = 1 NEW_LINE d = dict ( ) NEW_LINE d [ prev ] = 1 NEW_LINE d [ curr ] = 1 NEW_LINE while ( curr <= maxElement ) : NEW_LINE INDENT temp = curr + prev NEW_LINE d [ temp ] = 1 NEW_LINE prev = curr NEW_LINE curr = temp NEW_LINE DEDENT return d NEW_LINE DEDENT def countFibonacciDivisors ( n ) : NEW_LINE INDENT hash = createHash ( n ) NEW_LINE cnt = 0 NEW_LINE for i in range ( 1 , ceil ( sqrt ( n ) ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( ( n \/\/ i == i ) and ( n \/\/ i in hash ) ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( n \/\/ i in hash ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT if ( n \/\/ ( n \/\/ i ) in hash ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT n = 12 NEW_LINE print ( countFibonacciDivisors ( n ) ) NEW_LINE"],"bleu":0.6417898515378057,"rouge_l":0.7955731107467581}
{"id":729,"predictions":["MAX = 1000000 NEW_LINE prime = [ True for i in range ( MAX + 1 ) ] NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE prime [ 0 ] = False NEW_LINE for p in range ( 2 , int ( sqrt ( MAX ) ) + 1 ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def SumOfKthPrimes ( arr , n , k ) : NEW_LINE INDENT c = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if prime [ arr [ arr [ i ] ] : NEW_LINE INDENT c += 1 NEW_LINE if c % k == 0 : NEW_LINE INDENT sum += arr [ i ] NEW_LINE c = 0 NEW_LINE DEDENT DEDENT DEDENT print ( sum ) NEW_LINE DEDENT SieveOfEratosthenes ( ) NEW_LINE arr = [ 2 , 3 , 5 , 7 , 11 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE SumOfKthPrimes ( arr , n , k ) NEW_LINE"],"references":["MAX = 100000 ; NEW_LINE prime = [ True ] * ( MAX + 1 ) ; NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 1 ] = False ; NEW_LINE prime [ 0 ] = False ; NEW_LINE p = 2 ; NEW_LINE while ( p * p <= MAX ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT i = p * 2 ; NEW_LINE while ( i <= MAX ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE i += p ; NEW_LINE DEDENT DEDENT p += 1 ; NEW_LINE DEDENT DEDENT def SumOfKthPrimes ( arr , n , k ) : NEW_LINE INDENT c = 0 ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] ) : NEW_LINE INDENT c += 1 ; NEW_LINE if ( c % k == 0 ) : NEW_LINE INDENT sum += arr [ i ] ; NEW_LINE c = 0 ; NEW_LINE DEDENT DEDENT DEDENT print ( sum ) ; NEW_LINE DEDENT SieveOfEratosthenes ( ) ; NEW_LINE arr = [ 2 , 3 , 5 , 7 , 11 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE k = 2 ; NEW_LINE SumOfKthPrimes ( arr , n , k ) ; NEW_LINE"],"bleu":0.5912088919156501,"rouge_l":0.8117277180668275}
{"id":730,"predictions":["def sieveofEratosthenes ( N , s ) : NEW_LINE INDENT prime = [ True ] * ( N + 1 ) NEW_LINE for i in range ( 2 , N + 1 , 2 ) : NEW_LINE INDENT s [ i ] = 2 NEW_LINE DEDENT for i in range ( 3 , N + 1 , 2 ) : NEW_LINE INDENT if ( prime [ i ] == False ) : NEW_LINE INDENT s [ i ] = i NEW_LINE for j in range ( i , int ( sqrt ( N ) ) + 1 , 2 ) : NEW_LINE INDENT if ( prime [ i * j ] == False ) : NEW_LINE INDENT prime [ i * j ] = True NEW_LINE s [ i * j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def generatePrimeFactors ( N , s ) : NEW_LINE INDENT s = [ 0 ] * ( N + 1 ) NEW_LINE sieveOfEratosthenes ( N , s ) NEW_LINE curr = 1 NEW_LINE while ( N > 1 ) : NEW_LINE INDENT N \/\/= s [ N ] NEW_LINE if ( curr == s [ N ] ) : NEW_LINE INDENT count += 1 NEW_LINE continue NEW_LINE DEDENT print ( curr , \" \\t \" , count ) NEW_LINE curr = s [ N ] NEW_LINE cnt = 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 350 NEW_LINE generatePrimeFactors ( N ) NEW_LINE DEDENT"],"references":["def sieveOfEratosthenes ( N , s ) : NEW_LINE INDENT prime = [ False ] * ( N + 1 ) NEW_LINE for i in range ( 2 , N + 1 , 2 ) : NEW_LINE INDENT s [ i ] = 2 NEW_LINE DEDENT for i in range ( 3 , N + 1 , 2 ) : NEW_LINE INDENT if ( prime [ i ] == False ) : NEW_LINE INDENT s [ i ] = i NEW_LINE for j in range ( i , int ( N \/ i ) + 1 , 2 ) : NEW_LINE INDENT if ( prime [ i * j ] == False ) : NEW_LINE INDENT prime [ i * j ] = True NEW_LINE s [ i * j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def generatePrimeFactors ( N ) : NEW_LINE INDENT s = [ 0 ] * ( N + 1 ) NEW_LINE sieveOfEratosthenes ( N , s ) NEW_LINE print ( \" Factor ▁ Power \" ) NEW_LINE curr = s [ N ] NEW_LINE cnt = 1 NEW_LINE while ( N > 1 ) : NEW_LINE INDENT N \/\/= s [ N ] NEW_LINE if ( curr == s [ N ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE continue NEW_LINE DEDENT print ( str ( curr ) + \" \\t \" + str ( cnt ) ) NEW_LINE curr = s [ N ] NEW_LINE cnt = 1 NEW_LINE DEDENT DEDENT N = 360 NEW_LINE generatePrimeFactors ( N ) NEW_LINE"],"bleu":0.8314189894507601,"rouge_l":0.8877661264696536}
{"id":731,"predictions":["import math NEW_LINE def nearest ( n ) : NEW_LINE INDENT prevSquare = math . sqrt ( n ) NEW_LINE nextSquare = prevSquare + 1 NEW_LINE prevSquare = prevSquare * prevSquare NEW_LINE nextSquare = nextSquare * nextSquare NEW_LINE nextSquare = nextSquare * nextSquare NEW_LINE nextSquare = nextSquare * nextSquare NEW_LINE return ( nextSquare - n ) if ( n - prevSquare ) < ( nextSquare - n ) else ( nextSquare - n ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 14 NEW_LINE print ( nearest ( n ) ) NEW_LINE n = 16 NEW_LINE print ( nearest ( n ) ) NEW_LINE n = 18 NEW_LINE print ( nearest ( n ) ) NEW_LINE DEDENT"],"references":["from math import sqrt NEW_LINE def nearest ( n ) : NEW_LINE INDENT prevSquare = int ( sqrt ( n ) ) ; NEW_LINE nextSquare = prevSquare + 1 ; NEW_LINE prevSquare = prevSquare * prevSquare ; NEW_LINE nextSquare = nextSquare * nextSquare ; NEW_LINE ans = ( prevSquare - n ) if ( n - prevSquare ) < ( nextSquare - n ) else ( nextSquare - n ) ; NEW_LINE return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 14 ; NEW_LINE print ( nearest ( n ) ) ; NEW_LINE n = 16 ; NEW_LINE print ( nearest ( n ) ) ; NEW_LINE n = 18 ; NEW_LINE print ( nearest ( n ) ) ; NEW_LINE DEDENT"],"bleu":0.622886138117411,"rouge_l":0.8299319727891156}
{"id":732,"predictions":["import sys NEW_LINE def checkIfSortRotated ( arr , n ) : NEW_LINE INDENT minEle = sys . maxsize ; NEW_LINE maxEle = - 10 ** 9 ; NEW_LINE minIndex = - 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < minEle ) : NEW_LINE INDENT minEle = arr [ i ] ; NEW_LINE minIndex = i ; NEW_LINE DEDENT DEDENT flag1 = True ; NEW_LINE for i in range ( 1 , minIndex ) : NEW_LINE INDENT if ( arr [ i ] < arr [ i - 1 ] ) : NEW_LINE INDENT flag1 = False ; NEW_LINE break ; NEW_LINE DEDENT DEDENT flag2 = True ; NEW_LINE for i in range ( minIndex + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] < arr [ i - 1 ] ) : NEW_LINE INDENT flag2 = False ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( minIndex == 0 ) : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE return ; NEW_LINE DEDENT if ( flag1 and flag2 and ( arr [ n - 1 ] < arr [ minIndex - 1 ] ) ) : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE DEDENT DEDENT arr = [ 3 , 4 , 5 , 1 , 2 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE checkIfSortRotated ( arr , n ) ; NEW_LINE"],"references":["import sys NEW_LINE def checkIfSortRotated ( arr , n ) : NEW_LINE INDENT minEle = sys . maxsize NEW_LINE maxEle = - sys . maxsize - 1 NEW_LINE minIndex = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] < minEle : NEW_LINE INDENT minEle = arr [ i ] NEW_LINE minIndex = i NEW_LINE DEDENT DEDENT flag1 = 1 NEW_LINE for i in range ( 1 , minIndex ) : NEW_LINE INDENT if arr [ i ] < arr [ i - 1 ] : NEW_LINE INDENT flag1 = 0 NEW_LINE break NEW_LINE DEDENT DEDENT flag2 = 2 NEW_LINE for i in range ( minIndex + 1 , n ) : NEW_LINE INDENT if arr [ i ] < arr [ i - 1 ] : NEW_LINE INDENT flag2 = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag1 and flag2 and arr [ n - 1 ] < arr [ minIndex - 1 ] ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT arr = [ 3 , 4 , 5 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE checkIfSortRotated ( arr , n ) NEW_LINE"],"bleu":0.6664446860032823,"rouge_l":0.8870103666597092}
{"id":733,"predictions":["def printSquares ( n ) : NEW_LINE INDENT square = 0 NEW_LINE prev_x = 0 NEW_LINE for x in range ( n ) : NEW_LINE INDENT square = ( square + x + prev_x ) NEW_LINE print ( square , end = \" ▁ \" ) NEW_LINE prev_x = x NEW_LINE DEDENT DEDENT n = 5 NEW_LINE printSquares ( n ) NEW_LINE"],"references":["def printSquares ( n ) : NEW_LINE INDENT square = 0 ; prev_x = 0 ; NEW_LINE for x in range ( 0 , n ) : NEW_LINE INDENT square = ( square + x + prev_x ) NEW_LINE print ( square , end = \" ▁ \" ) NEW_LINE prev_x = x NEW_LINE DEDENT DEDENT n = 5 ; NEW_LINE printSquares ( n ) ; NEW_LINE"],"bleu":0.8014932172809391,"rouge_l":0.9391721352852095}
{"id":734,"predictions":["from math import gcd NEW_LINE def solveProposition ( a , b1 , b2 , c ) : NEW_LINE INDENT A = a * b2 NEW_LINE B = b1 * c NEW_LINE C = gcd ( gcd ( A , B ) , C ) NEW_LINE print ( A \/\/ gcd , \" : \" , B \/\/ gcd , \" : \" , B \/\/ gcd ) NEW_LINE DEDENT a = 3 NEW_LINE b1 = 4 NEW_LINE b2 = 8 NEW_LINE c = 9 NEW_LINE solveProportion ( a , b1 , b2 , c ) NEW_LINE"],"references":["import math NEW_LINE def solveProportion ( a , b1 , b2 , c ) : NEW_LINE INDENT A = a * b2 NEW_LINE B = b1 * b2 NEW_LINE C = b1 * c NEW_LINE gcd1 = math . gcd ( math . gcd ( A , B ) , C ) NEW_LINE print ( str ( A \/\/ gcd1 ) + \" : \" + str ( B \/\/ gcd1 ) + \" : \" + str ( C \/\/ gcd1 ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 3 NEW_LINE b1 = 4 NEW_LINE b2 = 8 NEW_LINE c = 9 NEW_LINE solveProportion ( a , b1 , b2 , c ) NEW_LINE DEDENT"],"bleu":0.519569703957613,"rouge_l":0.7261904761904763}
{"id":735,"predictions":["def countPairs ( arr , N ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT if arr [ i ] not in mp . keys ( ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT maxFreq = 0 NEW_LINE for i in mp : NEW_LINE INDENT maxFreq = max ( maxFreq , mp [ i ] ) NEW_LINE DEDENT print ( N - maxFreq ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 8 , 5 , 9 , 8 , 8 , 7 , 5 , 7 , 7 ] NEW_LINE N = len ( arr ) NEW_LINE countPairs ( arr , N ) NEW_LINE DEDENT"],"references":["def countPairs ( arr , N ) : NEW_LINE INDENT M = dict . fromkeys ( arr , 0 ) ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT M [ arr [ i ] ] += 1 ; NEW_LINE DEDENT maxFreq = 0 ; NEW_LINE for it in M . values ( ) : NEW_LINE INDENT maxFreq = max ( maxFreq , it ) ; NEW_LINE DEDENT print ( N - maxFreq ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 8 , 5 , 9 , 8 , 8 , 7 , 7 , 5 , 7 , 7 ] ; NEW_LINE N = len ( arr ) ; NEW_LINE countPairs ( arr , N ) ; NEW_LINE DEDENT"],"bleu":0.6244147584946073,"rouge_l":0.7893953275309208}
{"id":736,"predictions":["def numberOfSubarrays ( arr , n ) : NEW_LINE INDENT v = [ ] NEW_LINE v [ 0 ] = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT v [ i + 1 ] = v [ i ] + arr [ i ] NEW_LINE DEDENT mp = dict ( ) NEW_LINE begin = 0 NEW_LINE end = 0 NEW_LINE answer = 0 NEW_LINE while ( begin < n ) : NEW_LINE INDENT while ( end < n and v [ end + 1 ] in mp . keys ( ) ) : NEW_LINE INDENT end += 1 NEW_LINE mp [ v ] = 1 NEW_LINE DEDENT answer = answer + end - begin NEW_LINE mp [ begin ] -= 1 NEW_LINE DEDENT print ( answer ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 4 , - 6 ] NEW_LINE size = len ( arr ) NEW_LINE numberOfSubarrays ( arr , size ) NEW_LINE DEDENT"],"references":["def numberOfSubarrays ( arr , n ) : NEW_LINE INDENT v = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT v [ i + 1 ] = v [ i ] + arr [ i ] NEW_LINE DEDENT mp = { } NEW_LINE begin , end , answer = 0 , 0 , 0 NEW_LINE mp [ 0 ] = 1 NEW_LINE while ( begin < n ) : NEW_LINE INDENT while ( end < n and ( v [ end + 1 ] ) not in mp ) : NEW_LINE INDENT end += 1 NEW_LINE mp [ v [ end ] ] = 1 NEW_LINE DEDENT answer = answer + end - begin NEW_LINE del mp [ v [ begin ] ] NEW_LINE begin += 1 NEW_LINE DEDENT print ( answer ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 4 , - 6 ] NEW_LINE size = len ( arr ) NEW_LINE numberOfSubarrays ( arr , size ) NEW_LINE DEDENT"],"bleu":0.749246094475409,"rouge_l":0.8487631866133138}
{"id":737,"predictions":["def minimizeDiff ( arr , n , k ) : NEW_LINE INDENT max = max ( arr ) NEW_LINE min = min ( arr ) NEW_LINE if ( ( max - min ) <= k ) : NEW_LINE INDENT return ( max - min ) NEW_LINE DEDENT avg = ( max + min ) \/\/ 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > avg ) : NEW_LINE INDENT arr [ i ] -= k NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] += k NEW_LINE DEDENT DEDENT max = max + min ( arr ) NEW_LINE min = min ( arr ) NEW_LINE return ( max - min ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 16 , 12 , 9 , 20 ] NEW_LINE n = 5 NEW_LINE k = 3 NEW_LINE print ( \" Max ▁ height ▁ difference ▁ = \" , minimumDiff ( arr , n , k ) ) NEW_LINE DEDENT"],"references":["def minimizeDiff ( arr , n , k ) : NEW_LINE INDENT max_element = max ( arr ) NEW_LINE min_element = min ( arr ) NEW_LINE if ( ( max_element - min_element ) <= k ) : NEW_LINE INDENT return ( max_element - min_element ) NEW_LINE DEDENT avg = ( max_element + min_element ) \/\/ 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > avg ) : NEW_LINE INDENT arr [ i ] -= k NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] += k NEW_LINE DEDENT DEDENT max_element = max ( arr ) NEW_LINE min_element = min ( arr ) NEW_LINE return ( max_element - min_element ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 16 , 12 , 9 , 20 ] NEW_LINE n = 5 NEW_LINE k = 3 NEW_LINE print ( \" Max ▁ height ▁ difference ▁ = \" , minimizeDiff ( arr , n , k ) ) NEW_LINE DEDENT"],"bleu":0.8119745740464838,"rouge_l":0.92056750406651}
{"id":738,"predictions":["class Graph : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . graph = [ ] NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def addEdge ( self , v , w ) : NEW_LINE INDENT self . graph [ u ] . append ( v ) NEW_LINE DEDENT def BFS ( self , s ) : NEW_LINE INDENT visited = [ 0 ] * V NEW_LINE q = [ ] NEW_LINE visited [ s ] = True NEW_LINE visited [ s ] = True NEW_LINE while ( len ( q ) != 0 ) : NEW_LINE INDENT s = q . pop ( ) NEW_LINE print ( s , end = \" ▁ \" ) NEW_LINE i = 0 NEW_LINE while ( i > 0 ) : NEW_LINE INDENT if ( visited [ i ] == False ) : NEW_LINE INDENT visited [ i ] = True NEW_LINE DEDENT print ( s , end = \" ▁ \" ) NEW_LINE i = 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT g = Graph ( ) NEW_LINE g . addEdge ( 0 , 1 ) NEW_LINE g . addEdge ( 1 , 2 ) NEW_LINE g . addEdge ( 2 , 0 ) NEW_LINE g . addEdge ( 2 , 3 ) NEW_LINE g . addEdge ( 3 , 3 ) NEW_LINE g . addEdge ( 3 , 3 ) NEW_LINE print ( \" Following ▁ is ▁ Traversal \" ) NEW_LINE g . BFS ( 2 ) NEW_LINE DFS ( 2 ) NEW_LINE DEDENT"],"references":["from collections import defaultdict NEW_LINE class Graph : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . graph = defaultdict ( list ) NEW_LINE DEDENT def addEdge ( self , u , v ) : NEW_LINE INDENT self . graph [ u ] . append ( v ) NEW_LINE DEDENT def BFS ( self , s ) : NEW_LINE INDENT visited = [ False ] * ( len ( self . graph ) ) NEW_LINE queue = [ ] NEW_LINE queue . append ( s ) NEW_LINE visited [ s ] = True NEW_LINE while queue : NEW_LINE INDENT s = queue . pop ( 0 ) NEW_LINE print ( s , end = \" ▁ \" ) NEW_LINE for i in self . graph [ s ] : NEW_LINE INDENT if visited [ i ] == False : NEW_LINE INDENT queue . append ( i ) NEW_LINE visited [ i ] = True NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT g = Graph ( ) NEW_LINE g . addEdge ( 0 , 1 ) NEW_LINE g . addEdge ( 0 , 2 ) NEW_LINE g . addEdge ( 1 , 2 ) NEW_LINE g . addEdge ( 2 , 0 ) NEW_LINE g . addEdge ( 2 , 3 ) NEW_LINE g . addEdge ( 3 , 3 ) NEW_LINE print ( \" Following ▁ is ▁ Breadth ▁ First ▁ Traversal \" \" ▁ ( starting ▁ from ▁ vertex ▁ 2 ) \" ) NEW_LINE g . BFS ( 2 ) NEW_LINE"],"bleu":0.6534270360917083,"rouge_l":0.729235776428616}
{"id":739,"predictions":["from math import ceil , ceil NEW_LINE def cal ( n ) : NEW_LINE INDENT res = pow ( 10 ** ( ( pow ( 10 , ( n - 1 ) ) ) , 1 \/ 4 ) ) , 4 NEW_LINE return res NEW_LINE DEDENT n = 1 NEW_LINE print ( cal ( n ) ) NEW_LINE"],"references":["from math import * NEW_LINE def cal ( n ) : NEW_LINE INDENT res = pow ( ceil ( ( pow ( pow ( 10 , ( n - 1 ) ) , 1 \/ 4 ) ) ) , 4 ) NEW_LINE return int ( res ) NEW_LINE DEDENT n = 1 NEW_LINE print ( cal ( n ) ) NEW_LINE"],"bleu":0.7520484092273216,"rouge_l":0.8721338009171836}
{"id":740,"predictions":["def bit ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE n = n & ( n - 1 ) NEW_LINE DEDENT return count NEW_LINE DEDENT def maxSumOfBits ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = bit ( arr [ i ] ) NEW_LINE DEDENT incl = arr [ 0 ] NEW_LINEex = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( incl > ex ) : NEW_LINE INDENT continue NEW_LINE DEDENT incl = excl + arr [ i ] NEW_LINE excl = excl + arr [ i ] NEW_LINE DEDENT return ( if ( incl > excl ) else excl ) NEW_LINE DEDENT arr = [ 1 , 2 , 4 , 5 , 6 , 7 , 20 , 25 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxSumOfBits ( arr , n ) ) NEW_LINE"],"references":["def bit ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT count += 1 NEW_LINE n = n & ( n - 1 ) NEW_LINE DEDENT return count NEW_LINE DEDENT def maxSumOfBits ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = bit ( arr [ i ] ) NEW_LINE DEDENT incl = arr [ 0 ] NEW_LINE excl = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if incl > excl : NEW_LINE INDENT excl_new = incl NEW_LINE DEDENT else : NEW_LINE INDENT excl_new = excl NEW_LINE DEDENT incl = excl + arr [ i ] ; NEW_LINE excl = excl_new NEW_LINE DEDENT if incl > excl : NEW_LINE INDENT return incl NEW_LINE DEDENT else : NEW_LINE INDENT return excl NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 5 , 6 , 7 , 20 , 25 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxSumOfBits ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.6964146775304666,"rouge_l":0.8118165635331017}
{"id":741,"predictions":["import math NEW_LINE def subsetXOR ( arr , n , K ) : NEW_LINE INDENT max_ele = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i ] > max_ele : NEW_LINE INDENT max_ele = arr [ i ] NEW_LINE DEDENT DEDENT m = ( 1 << int ( math . log2 ( max_ele ) \/ 2 ) + 1 ) - 1 NEW_LINE dp = [ [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE dp = [ [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = 0 NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( m + 1 ) : NEW_LINE INDENT for k in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = dp [ i - 1 ] [ j ] [ k ] NEW_LINE if ( k != 0 ) : NEW_LINE INDENT dp [ i ] [ j ] += k * dp [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans += dp [ n ] [ K ] [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 2 , 3 ] NEW_LINE k = 1 NEW_LINE n = len ( arr ) NEW_LINE print ( subsetXOR ( arr , n , k ) ) NEW_LINE"],"references":["from math import log2 NEW_LINE def subsetXOR ( arr , n , K ) : NEW_LINE INDENT max_ele = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > max_ele ) : NEW_LINE INDENT max_ele = arr [ i ] NEW_LINE DEDENT DEDENT m = ( 1 << int ( log2 ( max_ele ) + 1 ) ) - 1 NEW_LINE dp = [ [ [ 0 for i in range ( n + 1 ) ] for j in range ( m + 1 ) ] for k in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( m + 1 ) : NEW_LINE INDENT for k in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = 0 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( m + 1 ) : NEW_LINE INDENT for k in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = dp [ i - 1 ] [ j ] [ k ] NEW_LINE if ( k != 0 ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] += k * dp [ i - 1 ] [ j ^ arr [ i - 1 ] ] [ k - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans += dp [ n ] [ K ] [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 ] NEW_LINE k = 1 NEW_LINE n = len ( arr ) NEW_LINE print ( subsetXOR ( arr , n , k ) ) NEW_LINE DEDENT"],"bleu":0.787857148560699,"rouge_l":0.8479723747122366}
{"id":742,"predictions":["def MaximumHeight ( a , n ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT y = ( i * ( i + 1 ) ) \/ 2 NEW_LINE if y < n : NEW_LINE INDENT result = i NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT arr = [ 40 , 100 , 20 , 30 ] NEW_LINE n = len ( arr ) NEW_LINE print ( MaximumHeight ( arr , n ) ) NEW_LINE"],"references":["def MaximumHeight ( a , n ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT y = ( i * ( i + 1 ) ) \/ 2 NEW_LINE if ( y < n ) : NEW_LINE INDENT result = i NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT arr = [ 40 , 100 , 20 , 30 ] NEW_LINE n = len ( arr ) NEW_LINE print ( MaximumHeight ( arr , n ) ) NEW_LINE"],"bleu":0.9300777533346645,"rouge_l":0.9789473684210526}
{"id":743,"predictions":["def toNegativeBase ( n , negBase ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return \"0\" NEW_LINE DEDENT converted = \" \" NEW_LINE while ( n != 0 ) : NEW_LINE INDENT remainder = n % negBase NEW_LINE n \/\/= negBase NEW_LINE if ( remainder < 0 ) : NEW_LINE INDENT remainder += ( - negBase ) NEW_LINE n += 1 NEW_LINE DEDENT if ( remainder < 0 ) : NEW_LINE INDENT remainder += ( - negBase ) NEW_LINE n += 1 NEW_LINE DEDENT DEDENT return str ( remainder ) + converted NEW_LINE DEDENT n = 13 NEW_LINE negBase = - 2 NEW_LINE print ( toNegativeBase ( n , negBase ) ) NEW_LINE"],"references":["def toNegativeBase ( n , negBase ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return \"0\" NEW_LINE DEDENT converted = \"01\" NEW_LINE while ( n != 0 ) : NEW_LINE INDENT remainder = n % ( negBase ) NEW_LINE n = int ( n \/ negBase ) NEW_LINE if ( remainder < 0 ) : NEW_LINE INDENT remainder += ( ( - 1 ) * negBase ) NEW_LINE n += 1 NEW_LINE DEDENT converted = str ( remainder ) + converted NEW_LINE DEDENT return converted NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 13 NEW_LINE negBase = - 2 NEW_LINE print ( toNegativeBase ( n , negBase ) ) NEW_LINE DEDENT"],"bleu":0.6916907048459943,"rouge_l":0.7696644295302013}
{"id":744,"predictions":["m = 6 NEW_LINE n = 4 NEW_LINE def compareRow ( ar1 , a2 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( a1 [ i ] < a2 [ i ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( a1 [ i ] > a2 [ i ] ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT def binaryCheck ( ar , arr ) : NEW_LINE INDENT l = 0 NEW_LINE r = m - 1 NEW_LINE while ( l <= r ) : NEW_LINE INDENT mid = ( l + r ) \/\/ 2 NEW_LINE temp = compareRow ( ar [ mid ] , arr ) NEW_LINE if ( temp == 0 ) : NEW_LINE INDENT return mid + 1 NEW_LINE DEDENT elif ( temp == 1 ) : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = mid - 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT mat = [ 0 , 0 , 1 , 0 ] , [ 10 , 9 , 22 , 23 ] , [ 40 , 40 , 55 , 55 ] , [ 43 , 75 , 100 , 133 ] , [ 81 , 75 , 100 ] ] NEW_LINE row = [ 10 , 9 , 22 , 23 ] NEW_LINE print ( binaryCheck ( mat , row ) ) NEW_LINE DEDENT"],"references":["m = 6 ; NEW_LINE n = 4 ; NEW_LINE def compareRow ( a1 , a2 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( a1 [ i ] < a2 [ i ] ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT elif ( a1 [ i ] > a2 [ i ] ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT DEDENT return 0 ; NEW_LINE DEDENT def binaryCheck ( ar , arr ) : NEW_LINE INDENT l = 0 ; r = m - 1 ; NEW_LINE while ( l <= r ) : NEW_LINE INDENT mid = ( l + r ) \/\/ 2 ; NEW_LINE temp = compareRow ( ar [ mid ] , arr ) ; NEW_LINE if ( temp == 0 ) : NEW_LINE INDENT return mid + 1 ; NEW_LINE DEDENT elif ( temp == 1 ) : NEW_LINE INDENT l = mid + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT r = mid - 1 ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT mat = [ [ 0 , 0 , 1 , 0 ] , [ 10 , 9 , 22 , 23 ] , [ 40 , 40 , 40 , 40 ] , [ 43 , 44 , 55 , 68 ] , [ 81 , 73 , 100 , 132 ] , [ 100 , 75 , 125 , 133 ] ] ; NEW_LINE row = [ 10 , 9 , 22 , 23 ] ; NEW_LINE print ( binaryCheck ( mat , row ) ) ; NEW_LINE DEDENT"],"bleu":0.7553690795120096,"rouge_l":0.9070225725546399}
{"id":745,"predictions":["def longestSubArray ( arr , n ) : NEW_LINE INDENT isZeroPresent = False NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT isZeroPresent = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( isZeroPresent ) : NEW_LINE INDENT return n NEW_LINE DEDENT return 0 NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 0 , 1 , 2 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE print ( longestSubArray ( arr , n ) ) NEW_LINE"],"references":["def longestSubArray ( arr , n ) : NEW_LINE INDENT isZeroPresent = False NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT isZeroPresent = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( isZeroPresent ) : NEW_LINE INDENT return n NEW_LINE DEDENT return 0 NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 0 , 1 , 2 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE print ( longestSubArray ( arr , n ) ) NEW_LINE"],"bleu":0.9630273502353404,"rouge_l":0.9875990354805374}
{"id":746,"predictions":["def PrintMinNumberForPattern ( arr ) : NEW_LINE INDENT curr_max = 0 NEW_LINE last_element = 0 NEW_LINE for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT noOfNextD = 0 NEW_LINE if ( arr [ i ] == ' I ' ) : NEW_LINE INDENT j = i + 1 NEW_LINE while ( j < len ( arr ) and arr [ j ] == ' D ' ) : NEW_LINE INDENT noOfNextD += 1 NEW_LINE j += 1 NEW_LINE DEDENT if ( i == 0 ) : NEW_LINE INDENT curr_max = noOfNextD + 2 NEW_LINE print ( \" ▁ \" , last_element ) NEW_LINE print ( \" ▁ \" , last_element ) NEW_LINE last_element = curr_max NEW_LINE DEDENT else : NEW_LINE INDENT curr_max = curr_max + last_element NEW_LINE last_element = curr_max NEW_LINE print ( \" ▁ \" , last_element , end = \" \" ) NEW_LINE print ( curr_element , end = \" \" ) NEW_LINE last_element = curr_max NEW_LINE print ( \" ▁ \" , last_element , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT printMinNumberForPattern ( arr ) : NEW_LINE INDENT printMinNumberForPattern ( arr ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT"],"references":["def PrintMinNumberForPattern ( arr ) : NEW_LINE INDENT curr_max = 0 NEW_LINE last_entry = 0 NEW_LINE i = 0 NEW_LINE while i < len ( arr ) : NEW_LINE INDENT noOfNextD = 0 NEW_LINE if arr [ i ] == \" I \" : NEW_LINE INDENT j = i + 1 NEW_LINE while j < len ( arr ) and arr [ j ] == \" D \" : NEW_LINE INDENT noOfNextD += 1 NEW_LINE j += 1 NEW_LINE DEDENT if i == 0 : NEW_LINE INDENT curr_max = noOfNextD + 2 NEW_LINE last_entry += 1 NEW_LINE print ( \" \" , last_entry , end = \" \" ) NEW_LINE print ( \" \" , curr_max , end = \" \" ) NEW_LINE last_entry = curr_max NEW_LINE DEDENT else : NEW_LINE INDENT curr_max += noOfNextD + 1 NEW_LINE last_entry = curr_max NEW_LINE print ( \" \" , last_entry , end = \" \" ) NEW_LINE DEDENT for k in range ( noOfNextD ) : NEW_LINE INDENT last_entry -= 1 NEW_LINE print ( \" \" , last_entry , end = \" \" ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT elif arr [ i ] == \" D \" : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT j = i + 1 NEW_LINE while j < len ( arr ) and arr [ j ] == \" D \" : NEW_LINE INDENT noOfNextD += 1 NEW_LINE j += 1 NEW_LINE DEDENT curr_max = noOfNextD + 2 NEW_LINE print ( \" \" , curr_max , curr_max - 1 , end = \" \" ) NEW_LINE last_entry = curr_max - 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" \" , last_entry - 1 , end = \" \" ) NEW_LINE last_entry -= 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT print ( ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT PrintMinNumberForPattern ( \" IDID \" ) NEW_LINE PrintMinNumberForPattern ( \" I \" ) NEW_LINE PrintMinNumberForPattern ( \" DD \" ) NEW_LINE PrintMinNumberForPattern ( \" II \" ) NEW_LINE PrintMinNumberForPattern ( \" DIDI \" ) NEW_LINE PrintMinNumberForPattern ( \" IIDDD \" ) NEW_LINE PrintMinNumberForPattern ( \" DDIDDIID \" ) NEW_LINE DEDENT"],"bleu":0.30807874791786355,"rouge_l":0.5652383502945902}
{"id":747,"predictions":["def findNumbers ( n ) : NEW_LINE INDENT i = 1 NEW_LINE while ( i <= n ) : NEW_LINE INDENT print ( ( 3 * i * ( i - 1 ) + 1 ) , end = \" ▁ \" ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT n = 4 NEW_LINE findNumber ( n ) NEW_LINE"],"references":["def findNumbers ( n ) : NEW_LINE INDENT i = 1 NEW_LINE while ( i <= n ) : NEW_LINE INDENT print ( ( 3 * i * ( i - 1 ) + 1 ) , end = \" ▁ \" ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT n = 4 NEW_LINE findNumbers ( n ) NEW_LINE"],"bleu":0.9566758893610273,"rouge_l":0.9830508474576272}
{"id":748,"predictions":["MOD = 1000000007 NEW_LINE def number_of_ways ( arr , n , k ) : NEW_LINE INDENT if ( k == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT dp = [ - 1 ] * ( k + 1 ) NEW_LINE dp [ 0 ] = 1 NEW_LINE dp [ 1 ] = 1 NEW_LINE for i in range ( 2 , k + 1 ) : NEW_LINE INDENT dp [ arr [ i ] ] = 0 NEW_LINE DEDENT dp [ 0 ] = 1 NEW_LINE if ( dp [ 1 ] == - 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT dp [ 1 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 1 ] = dp [ 1 ] + dp [ i - 2 ] NEW_LINE dp [ i ] %= MOD NEW_LINE DEDENT return dp [ k ] NEW_LINE DEDENT arr = [ 3 ] NEW_LINE n = len ( arr ) NEW_LINE k = 6 NEW_LINE print ( number_of_ways ( arr , n , k ) ) NEW_LINE"],"references":["MOD = 1000000007 ; NEW_LINE def number_of_ways ( arr , n , k ) : NEW_LINE INDENT if ( k == 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT dp = [ - 1 ] * ( k + 1 ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ arr [ i ] ] = 0 ; NEW_LINE DEDENT dp [ 0 ] = 1 ; NEW_LINE dp [ 1 ] = 1 if ( dp [ 1 ] == - 1 ) else dp [ 1 ] ; NEW_LINE for i in range ( 2 , k + 1 ) : NEW_LINE INDENT if ( dp [ i ] == 0 ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] ; NEW_LINE dp [ i ] %= MOD ; NEW_LINE DEDENT return dp [ k ] ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE k = 6 ; NEW_LINE print ( number_of_ways ( arr , n , k ) ) ; NEW_LINE DEDENT"],"bleu":0.6251865633801619,"rouge_l":0.7487766442730365}
{"id":749,"predictions":["import sys NEW_LINE def maxProfit ( prices , n , k ) : NEW_LINE INDENT profit = [ [ 0 for i in range ( n + 1 ) ] for j in range ( k + 1 ) ] NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT prevDiff = - 10 ** 9 NEW_LINE for j in range ( 1 , n ) : NEW_LINE INDENT prevDiff = max ( prevDiff , profit [ i - 1 ] [ j - 1 ] ) NEW_LINE prevDiff = max ( profit [ i ] [ j - 1 ] , prices [ j ] + prevDiff ) NEW_LINE DEDENT DEDENT return profit [ n - 1 ] NEW_LINE DEDENT k = 3 NEW_LINE prices = [ 12 , 14 , 17 , 10 , 14 , 13 , 12 , 15 ] NEW_LINE n = len ( prices ) NEW_LINE print ( \" Maximum ▁ profit ▁ is : \" , maxProfit ( prices , n , k ) ) NEW_LINE"],"references":["def maxProfit ( price , n , k ) : NEW_LINE INDENT profit = [ [ 0 for i in range ( n + 1 ) ] for j in range ( k + 1 ) ] NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT prevDiff = float ( ' - inf ' ) NEW_LINE for j in range ( 1 , n ) : NEW_LINE INDENT prevDiff = max ( prevDiff , profit [ i - 1 ] [ j - 1 ] - price [ j - 1 ] ) NEW_LINE profit [ i ] [ j ] = max ( profit [ i ] [ j - 1 ] , price [ j ] + prevDiff ) NEW_LINE DEDENT DEDENT return profit [ k ] [ n - 1 ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT k = 3 NEW_LINE price = [ 12 , 14 , 17 , 10 , 14 , 13 , 12 , 15 ] NEW_LINE n = len ( price ) NEW_LINE print ( \" Maximum ▁ profit ▁ is : \" , maxProfit ( price , n , k ) ) NEW_LINE DEDENT"],"bleu":0.7226471062608146,"rouge_l":0.8482157815379462}
{"id":750,"predictions":["def originalArray ( another , n ) : NEW_LINE INDENT temp = [ ] ; NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT temp . append ( i ) ; NEW_LINE DEDENT arr = [ 0 ] * n ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT k = n - greater [ i ] - i ; NEW_LINE arr [ i ] = temp [ k ] ; NEW_LINE temp . remove ( k ) ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT Ar = [ 6 , 3 , 2 , 1 , 0 , 1 , 0 ] ; NEW_LINE n = len ( Ar ) ; NEW_LINE originalArray ( Ar , n ) ; NEW_LINE DEDENT"],"references":["def originalArray ( greater , n ) : NEW_LINE INDENT temp = [ ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT temp . append ( i ) NEW_LINE DEDENT arr = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT k = n - greater [ i ] - i NEW_LINE arr [ i ] = temp [ k ] NEW_LINE del temp [ k ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 6 , 3 , 2 , 1 , 0 , 1 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE originalArray ( arr , n ) NEW_LINE"],"bleu":0.6606418060023199,"rouge_l":0.8541576906505816}
{"id":751,"predictions":["MAX = 1000 NEW_LINE f = [ 0 ] * 10 NEW_LINE def fib ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 1 or n == 2 ) : NEW_LINE INDENT f [ n ] = 1 NEW_LINE DEDENT if ( f [ n ] ) : NEW_LINE INDENT return f [ n ] NEW_LINE DEDENT k = ( n + 1 ) \/\/ 2 if ( n & 1 ) else n \/\/ 2 NEW_LINE f [ n ] = ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) ) if ( n & 1 ) else ( ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ) ) NEW_LINE return f [ n ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 9 NEW_LINE f = [ 0 ] * MAX NEW_LINE print ( fib ( n ) ) NEW_LINE DEDENT"],"references":["MAX = 1000 NEW_LINE f = [ 0 ] * MAX NEW_LINE def fib ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 1 or n == 2 ) : NEW_LINE INDENT f [ n ] = 1 NEW_LINE return ( f [ n ] ) NEW_LINE DEDENT if ( f [ n ] ) : NEW_LINE INDENT return f [ n ] NEW_LINE DEDENT if ( n & 1 ) : NEW_LINE INDENT k = ( n + 1 ) \/\/ 2 NEW_LINE DEDENT else : NEW_LINE INDENT k = n \/\/ 2 NEW_LINE DEDENT if ( ( n & 1 ) ) : NEW_LINE INDENT f [ n ] = ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT f [ n ] = ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ) NEW_LINE DEDENT return f [ n ] NEW_LINE DEDENT n = 9 NEW_LINE print ( fib ( n ) ) NEW_LINE"],"bleu":0.7694963155738076,"rouge_l":0.7893348718371385}
{"id":752,"predictions":["def getCount ( l , r , p ) : NEW_LINE INDENT cnt = 0 NEW_LINE val = p NEW_LINE while True : NEW_LINE INDENT a = r \/\/ val NEW_LINE b = ( l - 1 ) \/\/ val NEW_LINE val *= p NEW_LINE if ( ( a - b ) ) : NEW_LINE INDENT cnt += ( a - b ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT l , r , p = 2 , 8 , 2 NEW_LINE print ( getCount ( l , r , p ) ) NEW_LINE DEDENT"],"references":["def getCount ( l , r , p ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE val = p ; NEW_LINE while ( True ) : NEW_LINE INDENT a = r \/\/ val ; NEW_LINE b = ( l - 1 ) \/\/ val ; NEW_LINE val *= p ; NEW_LINE if ( a - b ) : NEW_LINE INDENT cnt += ( a - b ) ; NEW_LINE DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT return int ( cnt ) ; NEW_LINE DEDENT l = 2 ; NEW_LINE r = 8 ; NEW_LINE p = 2 ; NEW_LINE print ( getCount ( l , r , p ) ) ; NEW_LINE"],"bleu":0.6091130532123777,"rouge_l":0.8045667281236704}
{"id":753,"predictions":["def findMaxLen ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE stk = [ ] NEW_LINE stk . append ( - 1 ) NEW_LINE result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if st [ i ] == ' ( ' : NEW_LINE INDENT stk . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT stk . pop ( ) NEW_LINE if stk [ i ] == ' ( ' ) : NEW_LINE INDENT stk . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT stk . pop ( ) NEW_LINE if stk . pop ( ) != 0 : NEW_LINE INDENT result = max ( i - stk [ - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT stk . pop ( ) NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT st = \" ( ( ) ( ) ( ) ) \" NEW_LINE print ( findMaxLen ( st ) ) ) \" NEW_LINE st = \" ( ( ) ( ) ) ) \" NEW_LINE print ( findMaxLen ( st ) ) NEW_LINE"],"references":["def findMaxLen ( string ) : NEW_LINE INDENT n = len ( string ) NEW_LINE stk = [ ] NEW_LINE stk . append ( - 1 ) NEW_LINE result = 0 NEW_LINE for i in xrange ( n ) : NEW_LINE INDENT if string [ i ] == ' ( ' : NEW_LINE INDENT stk . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT stk . pop ( ) NEW_LINE if len ( stk ) != 0 : NEW_LINE INDENT result = max ( result , i - stk [ len ( stk ) - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT stk . append ( i ) NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT string = \" ( ( ( ) ( ) \" NEW_LINE print findMaxLen ( string ) NEW_LINE string = \" ( ) ( ( ) ) ) ) ) \" NEW_LINE print findMaxLen ( string ) NEW_LINE"],"bleu":0.601147666046411,"rouge_l":0.8092379200154934}
{"id":754,"predictions":["def printbinomial ( max ) : NEW_LINE INDENT for m in range ( max ) : NEW_LINE INDENT print ( m , end = \" ▁ \" ) NEW_LINE prev = 1 NEW_LINE for x in range ( 0 , m + 1 ) : NEW_LINE INDENT if ( m != 0 and x != 0 ) : NEW_LINE INDENT a =nom * ( m - x + 1 ) \/\/ x NEW_LINE DEDENT print ( a , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT max = 10 NEW_LINE printbinomial ( max ) NEW_LINE DEDENT"],"references":["def printbinomial ( max ) : NEW_LINE INDENT for m in range ( max + 1 ) : NEW_LINE INDENT print ( ' % ▁ 2d ' % m , end = ' ▁ ' ) NEW_LINE binom = 1 NEW_LINE for x in range ( m + 1 ) : NEW_LINE INDENT if m != 0 and x != 0 : NEW_LINE INDENT binom = binom * ( m - x + 1 ) \/ x NEW_LINE DEDENT print ( ' % ▁ 4d ' % binom , end = ' ▁ ' ) NEW_LINE DEDENT print ( \" \\n \" , end = ' ' ) NEW_LINE DEDENT DEDENT max = 10 NEW_LINE printbinomial ( max ) NEW_LINE"],"bleu":0.5482645901312847,"rouge_l":0.7460736622654621}
{"id":755,"predictions":["def getmax ( arr , n , x ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = s + arr [ i ] NEW_LINE DEDENT print ( min ( s , x ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE x = 5 NEW_LINE arr_size = len ( arr ) NEW_LINE getmax ( arr , arr_size , x ) NEW_LINE DEDENT"],"references":["def getmax ( arr , n , x ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = s + arr [ i ] NEW_LINE DEDENT print ( min ( s , x ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE x = 5 NEW_LINE arr_size = len ( arr ) NEW_LINE getmax ( arr , arr_size , x ) NEW_LINE DEDENT"],"bleu":0.9453194398324472,"rouge_l":0.978494623655914}
{"id":756,"predictions":["def isPossible ( w , h , x , y ) : NEW_LINE INDENT if x * 2 == w and y * 2 == h : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT w = 1 NEW_LINE h = 2 NEW_LINE x = 1 NEW_LINE y = 2 NEW_LINE if isPossible ( w , h , x , y ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def isPossible ( w , h , x , y ) : NEW_LINE INDENT if ( x * 2 == w and y * 2 == h ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT w = 1 NEW_LINE h = 2 NEW_LINE x = 1 NEW_LINE y = 2 NEW_LINE if ( isPossible ( w , h , x , y ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.7472976274346637,"rouge_l":0.891183879093199}
{"id":757,"predictions":["def daldx_y ( x , y ) : NEW_LINE INDENT return ( x + y - 2 ) NEW_LINE DEDENT def computegeKutta ( x0 , y0 , x , h ) : NEW_LINE INDENT n = int ( ( x - x0 ) \/ h ) NEW_LINE k1 = y0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT k1 = h * didalx ( x0 , y ) NEW_LINE k2 = h * didalx ( x0 + 0.5 * h , y + 0.5 * k1 ) NEW_LINE y = y + ( 1.0 \/ 6.0 ) * ( 1.0 + 2 * k2 ) NEW_LINE x0 = y + ( 1.0 + 2 * k2 ) NEW_LINE x0 = x0 + ( 1.0 + 2 * k2 ) NEW_LINE DEDENT return y NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x0 = 0 NEW_LINE y = 1 NEW_LINE x = 2 NEW_LINE h = 0 NEW_LINE print ( computegeKatta ( x0 , y , x , h ) ) NEW_LINE DEDENT"],"references":["def dydx ( x , y ) : NEW_LINE INDENT return ( x + y - 2 ) ; NEW_LINE DEDENT def rungeKutta ( x0 , y0 , x , h ) : NEW_LINE INDENT n = round ( ( x - x0 ) \/ h ) ; NEW_LINE y = y0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT k1 = h * dydx ( x0 , y ) ; NEW_LINE k2 = h * dydx ( x0 + 0.5 * h , y + 0.5 * k1 ) ; NEW_LINE y = y + ( 1.0 \/ 6.0 ) * ( k1 + 2 * k2 ) ; NEW_LINE x0 = x0 + h ; NEW_LINE DEDENT return y ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x0 = 0 ; y = 1 ; NEW_LINE x = 2 ; h = 0.2 ; NEW_LINE print ( \" y ( x ) ▁ = \" , rungeKutta ( x0 , y , x , h ) ) ; NEW_LINE DEDENT"],"bleu":0.670932204384721,"rouge_l":0.8334209143457698}
{"id":758,"predictions":["MAX_CHAR = 26 NEW_LINE def countPalindrome ( str1 ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE sum = 0 NEW_LINE hashTable = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( n ) : NEW_LINE INDENT hashTable [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( hashTable [ i ] != 0 ) : NEW_LINE INDENT sum += ( hashTable [ i ] * ( hashTable [ i ] + 1 ) \/\/ 2 ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" anomananddd \" NEW_LINE print ( countPalindrome ( str1 ) ) NEW_LINE DEDENT"],"references":["MAX_CHAR = 26 NEW_LINE def countPalindrome ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE sum = 0 NEW_LINE hashTable = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( n ) : NEW_LINE INDENT hashTable [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( hashTable [ i ] ) : NEW_LINE INDENT sum += ( hashTable [ i ] * ( hashTable [ i ] + 1 ) \/\/ 2 ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" ananananddd \" NEW_LINE print ( countPalindrome ( str ) ) NEW_LINE DEDENT"],"bleu":0.8650399406557465,"rouge_l":0.9501557632398755}
{"id":759,"predictions":["def __gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return __gcd ( a - b , b ) NEW_LINE DEDENT return __gcd ( a , b - a ) NEW_LINE DEDENT def NumberOfSquares ( x , y ) : NEW_LINE INDENT s = __gcd ( x , y ) NEW_LINE ans = ( x * y ) \/ ( s * s ) NEW_LINE return ans NEW_LINE DEDENT m = 60 NEW_LINE n = 60 NEW_LINE print ( NumberOfSquares ( m , n ) ) NEW_LINE"],"references":["def __gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a ; NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return __gcd ( a - b , b ) ; NEW_LINE DEDENT return __gcd ( a , b - a ) ; NEW_LINE DEDENT def NumberOfSquares ( x , y ) : NEW_LINE INDENT s = __gcd ( x , y ) ; NEW_LINE ans = ( x * y ) \/ ( s * s ) ; NEW_LINE return int ( ans ) ; NEW_LINE DEDENT m = 385 ; NEW_LINE n = 60 ; NEW_LINE print ( NumberOfSquares ( m , n ) ) ; NEW_LINE"],"bleu":0.7844647501294221,"rouge_l":0.9351238655874416}
{"id":760,"predictions":["import sys NEW_LINE def divisibilityCheck ( arr , n ) : NEW_LINE INDENT s = [ ] NEW_LINE max_ele = - 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . append ( arr [ i ] ) NEW_LINE max_ele = max ( max_ele , arr [ i ] ) NEW_LINE DEDENT res = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] != 0 ) : NEW_LINE INDENT for j in range ( arr [ i ] * 2 , max_ele + 1 , arr [ i ] ) : NEW_LINE INDENT if ( j in s ) : NEW_LINE INDENT res . add ( j ) NEW_LINE DEDENT DEDENT DEDENT DEDENT list . reverse ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 3 , 8 , 6 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE divisibilityCheck ( arr , n ) NEW_LINE DEDENT"],"references":["import math as mt NEW_LINE def divisibilityCheck ( arr , n ) : NEW_LINE INDENT s = dict ( ) NEW_LINE max_ele = - 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s [ arr [ i ] ] = 1 NEW_LINE max_ele = max ( max_ele , arr [ i ] ) NEW_LINE DEDENT res = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] != 0 ) : NEW_LINE INDENT for j in range ( arr [ i ] * 2 , max_ele + 1 , arr [ i ] ) : NEW_LINE INDENT if ( j in s . keys ( ) ) : NEW_LINE INDENT res [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT for x in res : NEW_LINE INDENT print ( x , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 2 , 3 , 8 , 6 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE divisibilityCheck ( arr , n ) NEW_LINE"],"bleu":0.746737990734696,"rouge_l":0.8439144457647259}
{"id":761,"predictions":["def leftRotate ( arr , d , n ) : NEW_LINE INDENT d = d % n NEW_LINE g_c_c_d_d = gcd ( d , n ) NEW_LINE for i in range ( g_c_c_d ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE j = i NEW_LINE while True : NEW_LINE INDENT k = j + d NEW_LINE if k >= n : NEW_LINE INDENT k = k - n NEW_LINE DEDENT if k == i : NEW_LINE INDENT break NEW_LINE DEDENT arr [ j ] = arr [ k ] NEW_LINE j = k NEW_LINE DEDENT arr [ j ] = temp NEW_LINE DEDENT arr [ j ] = temp NEW_LINE DEDENT DEDENT def printArray ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] NEW_LINE leftRotate ( arr , 2 , 7 ) NEW_LINE printArray ( arr , 7 ) NEW_LINE"],"references":["def leftRotate ( arr , d , n ) : NEW_LINE INDENT d = d % n NEW_LINE g_c_d = gcd ( d , n ) NEW_LINE for i in range ( g_c_d ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE j = i NEW_LINE while 1 : NEW_LINE INDENT k = j + d NEW_LINE if k >= n : NEW_LINE INDENT k = k - n NEW_LINE DEDENT if k == i : NEW_LINE INDENT break NEW_LINE DEDENT arr [ j ] = arr [ k ] NEW_LINE j = k NEW_LINE DEDENT arr [ j ] = temp NEW_LINE DEDENT DEDENT def printArray ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( \" % ▁ d \" % arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT def gcd ( a , b ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT return a ; NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( b , a % b ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE d = 2 NEW_LINE leftRotate ( arr , d , n ) NEW_LINE printArray ( arr , n ) NEW_LINE"],"bleu":0.679634450715421,"rouge_l":0.8038067349926792}
{"id":762,"predictions":["def isCorrectOrder ( n ) : NEW_LINE INDENT flag = True NEW_LINE prev = - 1 NEW_LINE type = - 1 NEW_LINE while ( n ) : NEW_LINE INDENT if ( type == - 1 ) : NEW_LINE INDENT if ( prev == - 1 ) : NEW_LINE INDENT prev = n % 10 NEW_LINE n = n \/\/ 10 NEW_LINE continue NEW_LINE DEDENT if ( prev == n % 10 ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT if ( prev == n % 10 ) : NEW_LINE INDENT flag = 1 NEW_LINE prev = n % 10 NEW_LINE n = n \/\/ 10 NEW_LINE continue NEW_LINE DEDENT prev = n % 10 NEW_LINE n = n \/\/ 10 NEW_LINE DEDENT else : NEW_LINE INDENT if ( prev == n % 10 ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT prev = n % 10 NEW_LINE n = n \/\/ 10 NEW_LINE DEDENT DEDENT return flag NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 123454321 NEW_LINE if ( isCorrectOrder ( n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"references":["def isCorrectOrder ( n ) : NEW_LINE INDENT flag = True ; NEW_LINE prev = - 1 ; NEW_LINE type = - 1 ; NEW_LINE while ( n != 0 ) : NEW_LINE INDENT if ( type == - 1 ) : NEW_LINE INDENT if ( prev == - 1 ) : NEW_LINE INDENT prev = n % 10 ; NEW_LINE n = int ( n \/ 10 ) ; NEW_LINE continue ; NEW_LINE DEDENT if ( prev == n % 10 ) : NEW_LINE INDENT flag = False ; NEW_LINE break ; NEW_LINE DEDENT if ( prev > n % 10 ) : NEW_LINE INDENT type = 1 ; NEW_LINE prev = n % 10 ; NEW_LINE n = int ( n \/ 10 ) ; NEW_LINE continue ; NEW_LINE DEDENT prev = n % 10 ; NEW_LINE n = int ( n \/ 10 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( prev == n % 10 ) : NEW_LINE INDENT flag = False ; NEW_LINE break ; NEW_LINE DEDENT if ( prev < n % 10 ) : NEW_LINE INDENT flag = False ; NEW_LINE break ; NEW_LINE DEDENT prev = n % 10 ; NEW_LINE n = int ( n \/ 10 ) ; NEW_LINE DEDENT DEDENT return flag ; NEW_LINE DEDENT n = 123454321 ; NEW_LINE if ( isCorrectOrder ( n ) ) : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE DEDENT"],"bleu":0.5802176636508948,"rouge_l":0.8116511547742159}
{"id":763,"predictions":["def K_multiple ( a , n , k ) : NEW_LINE INDENT a . sort ( ) NEW_LINE s = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( ( a [ i ] % k == 0 and not in s ) or a [ i ] % k != 0 ) : NEW_LINE INDENT s . add ( a [ i ] ) NEW_LINE DEDENT DEDENT for i in s : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT a = [ 2 , 3 , 4 , 5 , 6 , 10 ] NEW_LINE k = 2 NEW_LINE n = len ( a ) NEW_LINE K_multiple ( a , n , k ) NEW_LINE"],"references":["def K_multiple ( a , n , k ) : NEW_LINE INDENT a . sort ( ) ; NEW_LINE s = set ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( a [ i ] % k == 0 and a [ i ] \/\/ k not in s ) or a [ i ] % k != 0 ) : NEW_LINE INDENT s . add ( a [ i ] ) ; NEW_LINE DEDENT DEDENT for i in s : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 2 , 3 , 4 , 5 , 6 , 10 ] ; NEW_LINE k = 2 ; NEW_LINE n = len ( a ) ; NEW_LINE K_multiple ( a , n , k ) ; NEW_LINE DEDENT"],"bleu":0.7307342272751246,"rouge_l":0.8890743213173121}
{"id":764,"predictions":["import numpy as np NEW_LINE maxN = 20 NEW_LINE maxM = 10 NEW_LINE dp = np . zeros ( ( maxN , maxM ) ) ; NEW_LINE v = np . zeros ( ( maxN , maxM ) ) ; NEW_LINE def findCnt ( arr , i , curr , n , m ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT if ( curr == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT if ( v [ i ] [ curr ] ) : NEW_LINE INDENT return dp [ i ] [ curr ] ; NEW_LINE DEDENT v [ i ] [ curr ] = 1 ; NEW_LINE return dp [ i ] [ curr ] ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 3 , 3 , 3 , 3 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE m = 6 ; NEW_LINE print ( findCnt ( arr , 0 , 0 , n , m ) - 1 ) ; NEW_LINE DEDENT"],"references":["maxN = 20 NEW_LINE maxM = 10 NEW_LINE dp = [ [ 0 for i in range ( maxN ) ] for i in range ( maxM ) ] NEW_LINE v = [ [ 0 for i in range ( maxN ) ] for i in range ( maxM ) ] NEW_LINE def findCnt ( arr , i , curr , n , m ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT if ( curr == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if ( v [ i ] [ curr ] ) : NEW_LINE INDENT return dp [ i ] [ curr ] NEW_LINE DEDENT v [ i ] [ curr ] = 1 NEW_LINE dp [ i ] [ curr ] = findCnt ( arr , i + 1 , curr , n , m ) +   \\ NEW_LINE INDENT findCnt ( arr , i + 1 , ( curr + arr [ i ] ) % m , n , m ) NEW_LINE DEDENT return dp [ i ] [ curr ] NEW_LINE DEDENT arr = [ 3 , 3 , 3 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE m = 6 NEW_LINE print ( findCnt ( arr , 0 , 0 , n , m ) - 1 ) NEW_LINE"],"bleu":0.5540757841073806,"rouge_l":0.6954027270695179}
{"id":765,"predictions":["def minSteps ( str ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( str ) - 2 ) : NEW_LINE INDENT if ( ( str [ i ] == '0' ) ) : NEW_LINE INDENT if ( str [ i + 1 ] == '1' ) : NEW_LINE INDENT if ( str [ i + 2 ] == '1' ) : NEW_LINE INDENT count += 1 NEW_LINE i += 2 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT str = \"0101010\" NEW_LINE print ( minSteps ( str ) ) NEW_LINE"],"references":["def minSteps ( str ) : NEW_LINE INDENT count = 0 NEW_LINE i = 0 NEW_LINE while i < len ( str ) - 2 : NEW_LINE INDENT if str [ i ] == '0' : NEW_LINE INDENT if ( str [ i + 1 ] == '1' ) : NEW_LINE INDENT if ( str [ i + 2 ] == '0' ) : NEW_LINE INDENT count = count + 1 NEW_LINE i = i + 2 NEW_LINE DEDENT DEDENT DEDENT i = i + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT str = \"0101010\" NEW_LINE print ( minSteps ( str ) ) NEW_LINE"],"bleu":0.6922269832183845,"rouge_l":0.8404927865132111}
{"id":766,"predictions":["def checkSemiprime ( num ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE i = 2 ; NEW_LINE while ( cnt < 2 and i * i <= num ) : NEW_LINE INDENT num \/\/= i ; NEW_LINE cnt += 1 ; NEW_LINE DEDENT if ( num > 1 ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT return cnt == 2 if ( num > 1 ) else 0 ; NEW_LINE DEDENT def semiprime ( n ) : NEW_LINE INDENT if ( checkSemiprime ( n ) ) : NEW_LINE INDENT print ( \" True \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" False \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 6 ; NEW_LINE semiprime ( n ) ; NEW_LINE n = 8 ; NEW_LINE semiprime ( n ) ; NEW_LINE DEDENT"],"references":["import math NEW_LINE def checkSemiprime ( num ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( 2 , int ( math . sqrt ( num ) ) + 1 ) : NEW_LINE INDENT while num % i == 0 : NEW_LINE INDENT num \/= i NEW_LINE cnt += 1 NEW_LINE DEDENT if cnt >= 2 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( num > 1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT return cnt == 2 NEW_LINE DEDENT def semiprime ( n ) : NEW_LINE INDENT if checkSemiprime ( n ) == True : NEW_LINE INDENT print ( \" True \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" False \" ) NEW_LINE DEDENT DEDENT n = 6 NEW_LINE semiprime ( n ) NEW_LINE n = 8 NEW_LINE semiprime ( n ) ; NEW_LINE"],"bleu":0.5519146578242298,"rouge_l":0.708114744949213}
{"id":767,"predictions":["def XandYandZintercept ( A , B , C , D ) : NEW_LINE INDENT x1 = - D \/ A NEW_LINE y = - D \/ B NEW_LINE z = - D \/ C NEW_LINE x2 = - D \/ C NEW_LINE x2 = - D [ 0 ] NEW_LINE x2 = q [ 0 ] NEW_LINE x2 = q [ 1 ] NEW_LINE y2 = q [ 0 ] NEW_LINE x3 = x2 - x1 NEW_LINE a1 = x2 - x1 NEW_LINE a1 = x2 - x1 NEW_LINE a1 = x2 - x1 NEW_LINE a1 = x2 - x1 NEW_LINE b1 = x2 - x1 NEW_LINE a1 = x2 - x1 NEW_LINE a1 = x2 - x1 NEW_LINE b1 = y2 - x1 NEW_LINE a2 = x3 - y1 NEW_LINE a2 = x1 * c1 - x1 NEW_LINE B = a1 * c2 - a1 NEW_LINE B = a1 * b2 - a1 NEW_LINE C = ( - A * x1 - B * y1 - a1 ) NEW_LINE B = ( - A * x1 - B * y1 - B1 ) NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT print ( res [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT x1 = - 1 NEW_LINE y1 = 2 NEW_LINE z2 = 1 NEW_LINE x2 = 0 NEW_LINE y2 = 1 NEW_LINE x2 = 1 NEW_LINE y1 = 1 NEW_LINE x2 = 1 NEW_LINE y2 = 1 NEW_LINE x2 = 1 NEW_LINE y2 = 1 NEW_LINE x2 = 1 NEW_LINE x2 = 1 NEW_LINE y2 = 1 NEW_LINE x2 = 1 NEW_LINE p1 = 1 NEW_LINE q2 = - 1 NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT print ( res [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT"],"references":["def XandYandZintercept ( A , B , C , D ) : NEW_LINE INDENT x = - D \/ A NEW_LINE y = - D \/ B NEW_LINE z = - D \/ C NEW_LINE return [ x , y , z ] NEW_LINE DEDENT def equation_plane ( p , q , r ) : NEW_LINE INDENT x1 = p [ 0 ] NEW_LINE y1 = p [ 1 ] NEW_LINE z1 = p [ 2 ] NEW_LINE x2 = q [ 0 ] NEW_LINE y2 = q [ 1 ] NEW_LINE z2 = q [ 2 ] NEW_LINE x3 = r [ 0 ] NEW_LINE y3 = r [ 1 ] NEW_LINE z3 = r [ 2 ] NEW_LINE a1 = x2 - x1 NEW_LINE b1 = y2 - y1 NEW_LINE c1 = z2 - z1 NEW_LINE a2 = x3 - x1 NEW_LINE b2 = y3 - y1 NEW_LINE c2 = z3 - z1 NEW_LINE A = b1 * c2 - b2 * c1 NEW_LINE B = a2 * c1 - a1 * c2 NEW_LINE C = a1 * b2 - b1 * a2 NEW_LINE D = ( - A * x1 - B * y1 - C * z1 ) NEW_LINE print ( XandYandZintercept ( A , B , C , D ) ) NEW_LINE DEDENT x1 = - 1 NEW_LINE y1 = 2 NEW_LINE z1 = 1 NEW_LINE x2 = 0 NEW_LINE y2 = - 3 NEW_LINE z2 = 2 NEW_LINE x3 = 1 NEW_LINE y3 = 1 NEW_LINE z3 = - 4 NEW_LINE equation_plane ( ( x1 , y1 , z1 ) , ( x2 , y2 , z2 ) , ( x3 , y3 , z3 ) ) NEW_LINE"],"bleu":0.4062650463907311,"rouge_l":0.5486898709425108}
{"id":768,"predictions":["def mulmod ( a , b , mod ) : NEW_LINE INDENT res = 0 ; NEW_LINE a = a % mod ; NEW_LINE while ( b > 0 ) : NEW_LINE INDENT if ( b % 2 == 1 ) : NEW_LINE INDENT res = ( res + a ) % mod ; NEW_LINE DEDENT a = ( a * 2 ) % mod ; NEW_LINE b \/\/= 2 ; NEW_LINE DEDENT return res % mod ; NEW_LINE DEDENT a = 9223372036854775807 ; NEW_LINE b = 9223375807 ; NEW_LINE print ( mulmod ( a , b , 100000000000 ) ) ; NEW_LINE"],"references":["def mulmod ( a , b , mod ) : NEW_LINE INDENT res = 0 ; NEW_LINE a = a % mod ; NEW_LINE while ( b > 0 ) : NEW_LINE INDENT if ( b % 2 == 1 ) : NEW_LINE INDENT res = ( res + a ) % mod ; NEW_LINE DEDENT a = ( a * 2 ) % mod ; NEW_LINE b \/\/= 2 ; NEW_LINE DEDENT return res % mod ; NEW_LINE DEDENT a = 9223372036854775807 ; NEW_LINE b = 9223372036854775807 ; NEW_LINE print ( mulmod ( a , b , 100000000000 ) ) ; NEW_LINE"],"bleu":0.9754238144469,"rouge_l":0.9902912621359221}
{"id":769,"predictions":["MAX_CHAR = 26 NEW_LINE def sortString ( Str ) : NEW_LINE INDENT letters = [ 0 ] * MAX_CHAR NEW_LINE for x in Str : NEW_LINE INDENT letters [ ord ( x ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( MAX_CHAR ) : NEW_LINE INDENT for j in range ( letters [ i ] ) : NEW_LINE INDENT print ( chr ( i + ord ( ' a ' ) ) , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT sortString ( \" geeksforgeeks \" ) NEW_LINE DEDENT"],"references":["MAX_CHAR = 26 NEW_LINE def sortString ( str ) : NEW_LINE INDENT charCount = [ 0 for i in range ( MAX_CHAR ) ] NEW_LINE for i in range ( 0 , len ( str ) , 1 ) : NEW_LINE INDENT charCount [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 0 , MAX_CHAR , 1 ) : NEW_LINE INDENT for j in range ( 0 , charCount [ i ] , 1 ) : NEW_LINE INDENT print ( chr ( ord ( ' a ' ) + i ) , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" geeksforgeeks \" NEW_LINE sortString ( s ) NEW_LINE DEDENT"],"bleu":0.5025455660563124,"rouge_l":0.7478513650151669}
{"id":770,"predictions":["def pentagon_pyramidal ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT p = ( 3 * i * i - i ) \/ 2 NEW_LINE sum = sum + p NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 4 NEW_LINE print ( int ( pentagon_pyramidal ( n ) ) ) NEW_LINE"],"references":["def pentagon_pyramidal ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT p = ( 3 * i * i - i ) \/ 2 NEW_LINE sum = sum + p NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 4 NEW_LINE print ( int ( pentagon_pyramidal ( n ) ) ) NEW_LINE"],"bleu":1.0,"rouge_l":1.0}
{"id":771,"predictions":["def count ( n ) : NEW_LINE INDENT table = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT table [ i ] += table [ i - 3 ] NEW_LINE DEDENT for i in range ( 5 , n + 1 ) : NEW_LINE INDENT table [ i ] += table [ i - 5 ] NEW_LINE DEDENT for i in range ( 10 , n + 1 ) : NEW_LINE INDENT table [ i ] += table [ i - 5 ] NEW_LINE DEDENT return table [ n ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 20 NEW_LINE print ( \" Count ▁ for \" , n , \" is \" , count ( n ) ) NEW_LINE n = 10 NEW_LINE print ( \" Count ▁ for \" , n , \" is \" , count ( n ) ) NEW_LINE DEDENT"],"references":["def count ( n ) : NEW_LINE INDENT table = [ 0 for i in range ( n + 1 ) ] NEW_LINE table [ 0 ] = 1 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT table [ i ] += table [ i - 3 ] NEW_LINE DEDENT for i in range ( 5 , n + 1 ) : NEW_LINE INDENT table [ i ] += table [ i - 5 ] NEW_LINE DEDENT for i in range ( 10 , n + 1 ) : NEW_LINE INDENT table [ i ] += table [ i - 10 ] NEW_LINE DEDENT return table [ n ] NEW_LINE DEDENT n = 20 NEW_LINE print ( ' Count ▁ for ' , n , ' is ' , count ( n ) ) NEW_LINE n = 13 NEW_LINE print ( ' Count ▁ for ' , n , ' is ' , count ( n ) ) NEW_LINE"],"bleu":0.7686278545582664,"rouge_l":0.8823415202407532}
{"id":772,"predictions":["MAX = 26 NEW_LINE def maximum_element ( freq ) : NEW_LINE INDENT max_ele = freq [ 0 ] NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if ( max_ele < freq [ i ] ) : NEW_LINE INDENT max_ele = freq [ i ] NEW_LINE DEDENT DEDENT return max_ele NEW_LINE DEDENT def minimumAddition ( str , l ) : NEW_LINE INDENT freq = [ 0 ] * MAX NEW_LINE for i in range ( l ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT maxFreq = max ( freq ) NEW_LINE minAddition = 0 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if ( freq [ i ] > 0 ) : NEW_LINE INDENT minAddition += abs ( maxFreq - freq [ i ] ) NEW_LINE DEDENT DEDENT return minAddition NEW_LINE DEDENT str = \" geeksforgeeks \" NEW_LINE l = len ( str ) NEW_LINE print ( minimumAddition ( str , l ) ) NEW_LINE"],"references":["MAX = 26 NEW_LINE def minimumAddition ( str1 , Len ) : NEW_LINE INDENT freq = [ 0 for i in range ( MAX ) ] NEW_LINE for i in range ( Len ) : NEW_LINE INDENT freq [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT maxFreq = max ( freq ) NEW_LINE minAddition = 0 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if ( freq [ i ] > 0 ) : NEW_LINE INDENT minAddition += abs ( maxFreq - freq [ i ] ) NEW_LINE DEDENT DEDENT return minAddition NEW_LINE DEDENT str1 = \" geeksforgeeks \" NEW_LINE Len = len ( str1 ) NEW_LINE print ( minimumAddition ( str1 , Len ) ) NEW_LINE"],"bleu":0.6005717523405505,"rouge_l":0.7976462896371364}
{"id":773,"predictions":["N = 9 NEW_LINE def addEgcd ( adj , u , v ) : NEW_LINE INDENT adj [ u ] . append ( v ) NEW_LINE adj [ v ] . append ( u ) NEW_LINE DEDENT def DFS ( node , parent , G , leaf , val ) : NEW_LINE INDENT if ( node == leaf ) : NEW_LINE INDENT G = __gcd ( G , val [ node ] ) NEW_LINE print ( G ) NEW_LINE return NEW_LINE DEDENT for it in adj [ node ] : NEW_LINE INDENT if ( it != parent ) : NEW_LINE INDENT DEDENT DEDENT for it in adj [ node ] : NEW_LINE INDENT if ( it != parent ) : NEW_LINE INDENT DFS ( it , node , __gcd ( G , val [ it ] ) , leaf , val ) NEW_LINE DEDENT DEDENT DEDENT n = 8 NEW_LINE adj = [ [ ] for i in range ( n + 1 ) ] NEW_LINE addEgcd ( adj , 1 , 2 ) NEW_LINE addEgcd ( adj , 1 , 2 ) NEW_LINE addEgde ( adj , 1 , 4 ) NEW_LINE addEgde ( adj , 3 , 6 ) NEW_LINE addEgde ( adj , 3 , 6 ) NEW_LINE addEgcd ( adj , 6 , 8 ) NEW_LINE addEgde ( adj , 6 , 8 ) NEW_LINE addEgde ( adj , 6 , 7 ) NEW_LINE addEgde ( adj , 6 , 8 ) NEW_LINE addEgcd ( adj , 6 , 8 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ ' : NEW_LINE INDENT N = 8 NEW_LINE adj = [ - 1 , 6 , 2 , 6 , 3 , 4 , 12 , 10 , 10 , 18 ] NEW_LINE G = val [ - 1 , 6 , 2 , 6 , 8 , 10 , 10 , 10 , 10 , 18 ] NEW_LINE DEDENT"],"references":["from math import gcd NEW_LINE N = 9 NEW_LINE def addEgde ( adj , u , v ) : NEW_LINE INDENT adj [ u ] . append ( v ) NEW_LINE adj [ v ] . append ( u ) NEW_LINE DEDENT def DFS ( node , parent , G , leaf , val , adj ) : NEW_LINE INDENT if ( node == leaf ) : NEW_LINE INDENT G = gcd ( G , val [ node ] ) NEW_LINE print ( G , end = \" \" ) NEW_LINE return NEW_LINE DEDENT for it in adj [ node ] : NEW_LINE INDENT if ( it != parent ) : NEW_LINE INDENT DFS ( it , node , gcd ( G , val [ it ] ) , leaf , val , adj ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 8 NEW_LINE adj = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE addEgde ( adj , 1 , 2 ) NEW_LINE addEgde ( adj , 2 , 4 ) NEW_LINE addEgde ( adj , 1 , 3 ) NEW_LINE addEgde ( adj , 3 , 5 ) NEW_LINE addEgde ( adj , 3 , 6 ) NEW_LINE addEgde ( adj , 6 , 7 ) NEW_LINE addEgde ( adj , 6 , 8 ) NEW_LINE leaf = 5 NEW_LINE val = [ - 1 , 6 , 2 , 6 , 3 , 4 , 12 , 10 , 18 ] NEW_LINE G = val [ 1 ] NEW_LINE DFS ( 1 , - 1 , G , leaf , val , adj ) NEW_LINE DEDENT"],"bleu":0.693583626169514,"rouge_l":0.7665193546669505}
{"id":774,"predictions":["def countNums ( l , r ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT lastDigit = ( i % 10 ) NEW_LINE if ( ( ( lastDigit % 10 ) == 2 or ( lastDigit % 10 ) == 3 or ( lastDigit % 10 ) == 9 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT l = 11 NEW_LINE r = 33 NEW_LINE print ( countNums ( l , r ) ) NEW_LINE"],"references":["def countNums ( l , r ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT lastDigit = ( i % 10 ) ; NEW_LINE if ( ( lastDigit % 10 ) == 2 or ( lastDigit % 10 ) == 3 or ( lastDigit % 10 ) == 9 ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT return cnt ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT l = 11 ; r = 33 ; NEW_LINE print ( countNums ( l , r ) ) ; NEW_LINE DEDENT"],"bleu":0.6984236311185739,"rouge_l":0.8744157058273605}
{"id":775,"predictions":["def countMaxSetBits ( left , right ) : NEW_LINE INDENT max_count = - 1 NEW_LINE num = 0 NEW_LINE for i in range ( left , right + 1 ) : NEW_LINE INDENT temp = i NEW_LINE cnt = 0 NEW_LINE while ( temp ) : NEW_LINE INDENT if ( temp % 2 == 1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT temp >>= 1 NEW_LINE DEDENT if ( cnt > max_count ) : NEW_LINE INDENT max_count = cnt NEW_LINE num = i NEW_LINE DEDENT DEDENT return num NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT l = 1 NEW_LINE r = 5 NEW_LINE print ( countMaxSetBits ( l , r ) ) NEW_LINE l = 1 NEW_LINE r = 10 NEW_LINE print ( countMaxSetBits ( l , r ) ) NEW_LINE DEDENT"],"references":["def countMaxSetBits ( left , right ) : NEW_LINE INDENT max_count = - 1 NEW_LINE for i in range ( left , right + 1 ) : NEW_LINE INDENT temp = i NEW_LINE cnt = 0 NEW_LINE while temp : NEW_LINE INDENT if temp & 1 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT temp = temp >> 1 NEW_LINE DEDENT if cnt > max_count : NEW_LINE INDENT max_count = cnt NEW_LINE num = i NEW_LINE DEDENT DEDENT return num NEW_LINE DEDENT l = 1 NEW_LINE r = 5 NEW_LINE print ( countMaxSetBits ( l , r ) ) NEW_LINE l = 1 NEW_LINE r = 10 NEW_LINE print ( countMaxSetBits ( l , r ) ) NEW_LINE"],"bleu":0.7156643349813443,"rouge_l":0.8917671197743011}
{"id":776,"predictions":["import math NEW_LINE def checkPerfectcube ( n ) : NEW_LINE INDENT cube_root = n ** ( 1. \/ 3. ) NEW_LINE if round ( cube_root ) ** 3 == n : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT mini = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( checkPerfectcube ( a [ i ] ) ) : NEW_LINE INDENT mini = min ( a [ i ] , mini ) NEW_LINE DEDENT DEDENT return mini NEW_LINE DEDENT a = [ 16 , 8 , 25 , 2 , 3 , 10 ] NEW_LINE n = len ( a ) NEW_LINE print ( smallestPerfectCube ( a , n ) ) NEW_LINE"],"references":["import sys NEW_LINE def checkPerfectcube ( n ) : NEW_LINE INDENT d = int ( n ** ( 1 \/ 3 ) ) ; NEW_LINE if ( d * d * d == n ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT def smallestPerfectCube ( a , n ) : NEW_LINE INDENT mini = sys . maxsize ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( checkPerfectcube ( a [ i ] ) ) : NEW_LINE INDENT mini = min ( a [ i ] , mini ) ; NEW_LINE DEDENT DEDENT return mini ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 16 , 8 , 25 , 2 , 3 , 10 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( smallestPerfectCube ( a , n ) ) ; NEW_LINE DEDENT"],"bleu":0.5384741877173321,"rouge_l":0.77711465626076}
{"id":777,"predictions":["def delete ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = 0 NEW_LINE maximum = 0 NEW_LINE for j in range ( i , min ( n , i + 60 ) ) : NEW_LINE INDENT s += a [ j ] NEW_LINE maximum = max ( a [ j ] , maximum ) NEW_LINE if ( s % 2 == 0 and 2 * maximum > s ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT def countSubarrays ( a , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT a [ i ] = bin ( a [ i ] ) NEW_LINE DEDENT pre = [ 0 ] * n NEW_LINE even = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT pre [ i ] = a [ i ] NEW_LINE if ( i != 0 ) : NEW_LINE INDENT pre [ i ] += pre [ i - 1 ] NEW_LINE DEDENT DEDENT odd = 0 NEW_LINE even = 0 NEW_LINE answer = ( odd * ( odd - 1 ) \/\/ 2 ) + ( even * ( even - 1 ) \/\/ 2 ) NEW_LINE print ( answer ) NEW_LINE answer = answer - remove ( a , n ) NEW_LINE return answer NEW_LINE DEDENT a = [ 6 , 7 , 14 , 14 ] NEW_LINE n = len ( a ) NEW_LINE print ( countSubarrays ( a , n ) ) NEW_LINE"],"references":["def exclude ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT s = 0 NEW_LINE maximum = 0 NEW_LINE for j in range ( i , min ( n , i + 60 ) ) : NEW_LINE INDENT s += a [ j ] NEW_LINE maximum = max ( a [ j ] , maximum ) NEW_LINE if s % 2 == 0 and 2 * maximum > s : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT def countSubarrays ( a , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT a [ i ] = bin ( a [ i ] ) . count ( '1' ) NEW_LINE DEDENT pre = [ None ] * n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT pre [ i ] = a [ i ] NEW_LINE if i != 0 : NEW_LINE INDENT pre [ i ] += pre [ i - 1 ] NEW_LINE DEDENT DEDENT odd , even = 0 , 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if pre [ i ] & 1 : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT even = n - odd NEW_LINE even += 1 NEW_LINE answer = ( ( odd * ( odd - 1 ) \/\/ 2 ) + ( even * ( even - 1 ) \/\/ 2 ) ) NEW_LINE print ( answer ) NEW_LINE answer = answer - exclude ( a , n ) NEW_LINE return answer NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 6 , 7 , 14 ] NEW_LINE n = len ( a ) NEW_LINE print ( countSubarrays ( a , n ) ) NEW_LINE DEDENT"],"bleu":0.7176399500384715,"rouge_l":0.841832884097035}
{"id":778,"predictions":["def printPermutation ( N , K ) : NEW_LINE INDENT res = [ ] NEW_LINE l = 1 NEW_LINE r = N NEW_LINE flag = 0 NEW_LINE for i in range ( K ) : NEW_LINE INDENT if ( flag == 0 ) : NEW_LINE INDENT res . append ( l ) NEW_LINE l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT res . append ( r ) NEW_LINE r -= 1 NEW_LINE DEDENT flag ^= 1 NEW_LINE DEDENT if ( flag != 1 ) : NEW_LINE INDENT for i in range ( r , l + 1 , - 1 ) : NEW_LINE INDENT res . append ( i ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( l , r + 1 ) : NEW_LINE INDENT res . append ( i ) NEW_LINE DEDENT DEDENT for i in range ( l , r + 1 ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 10 NEW_LINE K = 4 NEW_LINE printPermutation ( N , K ) NEW_LINE DEDENT"],"references":["def printPermutation ( N , K ) : NEW_LINE INDENT res = list ( ) ; NEW_LINE l , r , flag = 1 , N , 0 NEW_LINE for i in range ( K ) : NEW_LINE INDENT if flag == False : NEW_LINE INDENT res . append ( l ) NEW_LINE l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT res . append ( r ) ; NEW_LINE r -= 1 ; NEW_LINE DEDENT flag = flag ^ 1 ; NEW_LINE DEDENT if flag == False : NEW_LINE INDENT for i in range ( r , 2 , - 1 ) : NEW_LINE INDENT res . append ( i ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( l , r ) : NEW_LINE INDENT res . append ( i ) NEW_LINE DEDENT DEDENT for i in res : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT N , K = 10 , 4 NEW_LINE printPermutation ( N , K ) NEW_LINE"],"bleu":0.6589871213969514,"rouge_l":0.8205790645879733}
{"id":779,"predictions":["def solve ( A , B , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if ( bin ( A [ i ] | A [ j ] ) == B [ j ] : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT A = [ 5 , 3 , 2 , 4 , 6 , 1 ] NEW_LINE B = [ 2 , 2 , 1 , 4 , 2 , 3 ] NEW_LINE size = len ( A ) NEW_LINE print ( solve ( A , B , size ) ) NEW_LINE"],"references":["def solve ( A , B , n ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if ( bin ( A [ i ] | A [ j ] ) . count ( '1' ) == B [ j ] ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 5 , 3 , 2 , 4 , 6 , 1 ] ; NEW_LINE B = [ 2 , 2 , 1 , 4 , 2 , 3 ] ; NEW_LINE size = len ( A ) ; NEW_LINE print ( solve ( A , B , size ) ) ; NEW_LINE DEDENT"],"bleu":0.7251956199720473,"rouge_l":0.8882788254953451}
{"id":780,"predictions":["def sum ( n ) : NEW_LINE INDENT s = 0.0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT s = s + 1 \/ i NEW_LINE DEDENT return s NEW_LINE DEDENT n = 5 NEW_LINE print ( \" Sum ▁ is \" , sum ( n ) ) NEW_LINE"],"references":["def sum ( n ) : NEW_LINE INDENT i = 1 NEW_LINE s = 0.0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT s = s + 1 \/ i ; NEW_LINE DEDENT return s ; NEW_LINE DEDENT n = 5 NEW_LINE print ( \" Sum ▁ is \" , round ( sum ( n ) , 6 ) ) NEW_LINE"],"bleu":0.7200651416150393,"rouge_l":0.8977536793183579}
{"id":781,"predictions":["M = 3 NEW_LINE N = 2 NEW_LINE def getIndex ( n , shuffle ) : NEW_LINE INDENT for i in range ( 3 ) : NEW_LINE INDENT if ( shuffle [ i ] [ 0 ] == n ) : NEW_LINE INDENT n = shuffle [ i ] [ 1 ] NEW_LINE DEDENT elif ( shuffle [ i ] [ 1 ] == n ) : NEW_LINE INDENT n = shuffle [ i ] [ 0 ] NEW_LINE DEDENT DEDENT print ( n ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE shuffle = [ [ 3 , 1 ] , [ 2 , 1 ] , [ 1 , 2 ] ] NEW_LINE getIndex ( n , shuffle ) NEW_LINE DEDENT"],"references":["M = 3 ; N = 2 ; NEW_LINE def getIndex ( n , shuffle ) : NEW_LINE INDENT for i in range ( 3 ) : NEW_LINE INDENT if ( shuffle [ i ] [ 0 ] == n ) : NEW_LINE INDENT n = shuffle [ i ] [ 1 ] ; NEW_LINE DEDENT elif ( shuffle [ i ] [ 1 ] == n ) : NEW_LINE INDENT n = shuffle [ i ] [ 0 ] ; NEW_LINE DEDENT DEDENT print ( n ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 ; NEW_LINE shuffle = [ [ 3 , 1 ] , [ 2 , 1 ] , [ 1 , 2 ] ] ; NEW_LINE getIndex ( n , shuffle ) ; NEW_LINE DEDENT"],"bleu":0.855699107641902,"rouge_l":0.9628530738191313}
{"id":782,"predictions":["def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT def findArrangement ( arr , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT print ( \" - 1\" , end = \" \" ) NEW_LINE return NEW_LINE DEDENT minVal = arr [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == maxVal ) : NEW_LINE INDENT arr [ i ] = arr [ i ] NEW_LINE DEDENT DEDENT arr [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT arr [ i ] = arr [ i ] NEW_LINE DEDENT if ( arr [ n - 1 ] == arr [ n - 1 ] ) : NEW_LINE INDENT printArr ( arr , n ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" - 1\" , end = \" \" ) NEW_LINE DEDENT DEDENT arr = [ 1 , 5 , 3 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE findArrangement ( arr , n ) NEW_LINE"],"references":["def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT def findArrangement ( arr , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT print ( \" - 1\" , end = \" \" ) ; NEW_LINE return ; NEW_LINE DEDENT minVal = min ( arr ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == minVal ) : NEW_LINE INDENT arr [ i ] , arr [ n - 1 ] = arr [ n - 1 ] , arr [ i ] ; NEW_LINE break ; NEW_LINE DEDENT DEDENT andVal = arr [ 0 ] ; NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT andVal &= arr [ i ] ; NEW_LINE DEDENT if ( andVal == arr [ n - 1 ] ) : NEW_LINE INDENT printArr ( arr , n ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" - 1\" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 5 , 3 , 3 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE findArrangement ( arr , n ) ; NEW_LINE DEDENT"],"bleu":0.6978698837545204,"rouge_l":0.8285593637835176}
{"id":783,"predictions":["def findOccurrences ( str1 , substr ) : NEW_LINE INDENT counter = 0 NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT if ( str1 [ i ] == substr [ 0 ] ) : NEW_LINE INDENT for j in range ( i + 1 , len ( str1 ) ) : NEW_LINE INDENT if ( str1 [ j ] == substr [ 1 ] ) : NEW_LINE INDENT for k in range ( j + 1 , len ( str1 ) ) : NEW_LINE INDENT if ( str1 [ k ] == substr [ 2 ] ) : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return counter NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" GFGFGYSYIOIWIN \" NEW_LINE substr = \" GFG \" NEW_LINE print ( findOccurrences ( str1 , substr ) ) NEW_LINE DEDENT"],"references":["def findOccurrences ( str , substr ) : NEW_LINE INDENT counter = 0 NEW_LINE for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == substr [ 0 ] ) : NEW_LINE INDENT for j in range ( i + 1 , len ( str ) ) : NEW_LINE INDENT if ( str [ j ] == substr [ 1 ] ) : NEW_LINE INDENT for k in range ( j + 1 , len ( str ) ) : NEW_LINE INDENT if ( str [ k ] == substr [ 2 ] ) : NEW_LINE INDENT counter = counter + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT return counter NEW_LINE DEDENT str = \" GFGFGYSYIOIWIN \" NEW_LINE substr = \" GFG \" NEW_LINE print ( findOccurrences ( str , substr ) ) NEW_LINE"],"bleu":0.7360206211080796,"rouge_l":0.87515058591611}
{"id":784,"predictions":["def decimalToBinary ( num , k_prec ) : NEW_LINE INDENT binary = \" \" ; NEW_LINE Integral = num ; NEW_LINE fractional = num - Integator ; NEW_LINE while ( Integral ) : NEW_LINE INDENT rem = Integ % 2 ; NEW_LINE binary += chr ( ( rem + ord ( '0' ) ) ) ; NEW_LINE Integral \/\/= 2 ; NEW_LINE DEDENT binary = binary [ binary : : : - 1 ] ; NEW_LINE binary = binary [ : : : - 1 ] ; NEW_LINE binary += ' . ' ; NEW_LINE while ( k_prec ) : NEW_LINE INDENT fractional *= 2 ; NEW_LINE fract_bit \/\/= 2 ; NEW_LINE if ( fract_bit == 1 ) : NEW_LINE INDENT fractional -= fract_bit ; NEW_LINE binary += chr ( 1 + ord ( '0' ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT binary += chr ( 0 + ord ( '0' ) ) ; NEW_LINE DEDENT DEDENT return binary ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4.47 ; NEW_LINE k = 3 ; NEW_LINE print ( int ( decimalToBinary ( n , k_prec ) ) ; NEW_LINE n = 6 ; NEW_LINE k = 5 ; NEW_LINE print ( int ( decimalToBinary ( n , k ) ) ; NEW_LINE DEDENT"],"references":["def decimalToBinary ( num , k_prec ) : NEW_LINE INDENT binary = \" \" NEW_LINE Integral = int ( num ) NEW_LINE fractional = num - Integral NEW_LINE while ( Integral ) : NEW_LINE INDENT rem = Integral % 2 NEW_LINE binary += str ( rem ) ; NEW_LINE Integral \/\/= 2 NEW_LINE DEDENT binary = binary [ : : - 1 ] NEW_LINE binary += ' . ' NEW_LINE while ( k_prec ) : NEW_LINE INDENT fractional *= 2 NEW_LINE fract_bit = int ( fractional ) NEW_LINE if ( fract_bit == 1 ) : NEW_LINE INDENT fractional -= fract_bit NEW_LINE binary += '1' NEW_LINE DEDENT else : NEW_LINE INDENT binary += '0' NEW_LINE DEDENT k_prec -= 1 NEW_LINE DEDENT return binary NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4.47 NEW_LINE k = 3 NEW_LINE print ( decimalToBinary ( n , k ) ) NEW_LINE n = 6.986 NEW_LINE k = 5 NEW_LINE print ( decimalToBinary ( n , k ) ) NEW_LINE DEDENT"],"bleu":0.5210520009254814,"rouge_l":0.8020903573836817}
{"id":785,"predictions":["def evenDecimalValue ( str , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT decimalValue = 0 NEW_LINE powerOf2 = 1 NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT decimalValue += ( ord ( str [ k ] ) - ord ( '0' ) ) * powerOf2 *= 2 NEW_LINE DEDENT if ( decimalValue % 2 == 0 ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT str = \"10010\" NEW_LINE n = 5 NEW_LINE print ( evenDecimalValue ( str , n ) ) NEW_LINE"],"references":["import math NEW_LINE def evenDecimalValue ( str , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT decimalValue = 0 ; NEW_LINE powerOf2 = 1 ; NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT decimalValue += ( ( int ( str [ k ] ) - 0 ) * powerOf2 ) NEW_LINE powerOf2 *= 2 NEW_LINE DEDENT if ( decimalValue % 2 == 0 ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT str = \"10010\" NEW_LINE n = 5 NEW_LINE print ( evenDecimalValue ( str , n ) ) NEW_LINE"],"bleu":0.8332856939677415,"rouge_l":0.9220557308096742}
{"id":786,"predictions":["def isSubSeqDivisible ( str ) : NEW_LINE INDENT l = len ( str ) NEW_LINE arr = [ 0 for i in range ( l ) ] NEW_LINE for i in range ( l ) : NEW_LINE INDENT arr [ i ] = ord ( str [ i ] ) - ord ( '0' ) NEW_LINE DEDENT for i in range ( l ) : NEW_LINE INDENT for j in range ( i , l ) : NEW_LINE INDENT for k in range ( j , l , 1 ) : NEW_LINE INDENT if ( arr [ i ] % 8 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 and i != j ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( ( arr [ i ] * 100 + arr [ j ] ) % 8 == 0 and i != j ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 and i != j and i != j and i != j and i != k and j != k and i != j and i != j and i != j and i != j and i != j and i != j and j != k and i != k and i != j and i != j and i != j and j and i != j and j != k and i != j and is True : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \"3144\" NEW_LINE if ( isSubSeqDivisible ( str ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT DEDENT"],"references":["def isSubSeqDivisible ( st ) : NEW_LINE INDENT l = len ( st ) NEW_LINE arr = [ int ( ch ) for ch in st ] NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT for j in range ( i , l ) : NEW_LINE INDENT for k in range ( j , l ) : NEW_LINE INDENT if ( arr [ i ] % 8 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 and i != j ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 and i != j and j != k and i != k ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT st = \"3144\" NEW_LINE if ( isSubSeqDivisible ( st ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.5105012894808186,"rouge_l":0.7296835443037973}
{"id":787,"predictions":["def sub_segments ( st , n ) : NEW_LINE INDENT l = len ( st ) NEW_LINE for x in range ( 0 , l , n ) : NEW_LINE INDENT newlist = st [ x : x + n ] NEW_LINE arr = [ ] NEW_LINE for y in range ( new ) : NEW_LINE INDENT if ( y not in arr ) : NEW_LINE INDENT arr . append ( y ) NEW_LINE DEDENT DEDENT for y in arr : NEW_LINE INDENT print ( y , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT st = \" geeksforgeeks \" NEW_LINE n = 4 NEW_LINE sub_segments ( st , n ) NEW_LINE"],"references":["def sub_segments ( string , n ) : NEW_LINE INDENT l = len ( string ) NEW_LINE for x in range ( 0 , l , n ) : NEW_LINE INDENT newlist = string [ x : x + n ] NEW_LINE arr = [ ] NEW_LINE for y in newlist : NEW_LINE INDENT if y not in arr : NEW_LINE INDENT arr . append ( y ) NEW_LINE DEDENT DEDENT print ( ' ' . join ( arr ) ) NEW_LINE DEDENT DEDENT string = \" geeksforgeeksgfg \" NEW_LINE n = 4 NEW_LINE sub_segments ( string , n ) NEW_LINE"],"bleu":0.6186241978321579,"rouge_l":0.8181679622008841}
{"id":788,"predictions":["def remAnagram ( str1 , str2 ) : NEW_LINE INDENT count1 = [ 0 for i in range ( 26 ) ] NEW_LINE count2 = [ 0 for i in range ( 26 ) ] NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT count1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( len ( str2 ) ) : NEW_LINE INDENT count2 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT result += abs ( count1 [ i ] - count2 [ i ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT str1 = \" bcadeh \" NEW_LINE str2 = \" hea \" NEW_LINE print ( remAnagram ( str1 , str2 ) ) NEW_LINE"],"references":["CHARS = 26 NEW_LINE def remAnagram ( str1 , str2 ) : NEW_LINE INDENT count1 = [ 0 ] * CHARS NEW_LINE count2 = [ 0 ] * CHARS NEW_LINE i = 0 NEW_LINE while i < len ( str1 ) : NEW_LINE INDENT count1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE i += 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < len ( str2 ) : NEW_LINE INDENT count2 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE i += 1 NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT result += abs ( count1 [ i ] - count2 [ i ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" bcadeh \" NEW_LINE str2 = \" hea \" NEW_LINE print ( remAnagram ( str1 , str2 ) ) NEW_LINE DEDENT"],"bleu":0.6981354879637899,"rouge_l":0.7970791698693312}
{"id":789,"predictions":["def minOperations ( s , t , n ) : NEW_LINE INDENT ct0 = 0 NEW_LINE ct1 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == t [ i ] : NEW_LINE INDENT continue NEW_LINE DEDENT if s [ i ] == '0' : NEW_LINE INDENT ct0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ct1 += 1 NEW_LINE DEDENT DEDENT return max ( ct0 , ct1 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \"010\" NEW_LINE t = \"101\" NEW_LINE n = len ( s ) NEW_LINE print ( minOperations ( s , t , n ) ) NEW_LINE DEDENT"],"references":["def minOperations ( s , t , n ) : NEW_LINE INDENT ct0 = 0 NEW_LINE ct1 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == t [ i ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT ct0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ct1 += 1 NEW_LINE DEDENT DEDENT return max ( ct0 , ct1 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \"010\" NEW_LINE t = \"101\" NEW_LINE n = len ( s ) NEW_LINE print ( minOperations ( s , t , n ) ) NEW_LINE DEDENT"],"bleu":0.9182515681967706,"rouge_l":0.9808637873754154}
{"id":790,"predictions":["def toggleLastMBits ( n , m ) : NEW_LINE INDENT num = ( 1 << m ) - 1 NEW_LINE return ( n ^ num ) NEW_LINE DEDENT n = 107 NEW_LINE m = 4 NEW_LINE n = toggleLastMBits ( n , m ) NEW_LINE print ( n ) NEW_LINE"],"references":["def toggleLastMBits ( n , m ) : NEW_LINE INDENT num = ( 1 << m ) - 1 NEW_LINE return ( n ^ num ) NEW_LINE DEDENT n = 107 NEW_LINE m = 4 NEW_LINE print ( toggleLastMBits ( n , m ) ) NEW_LINE"],"bleu":0.8451984423351157,"rouge_l":0.9236063317274604}
{"id":791,"predictions":["def printmaxSubseq ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( i + 1 < n and arr [ i ] < arr [ i + 1 ] ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 9 , 8 , 12 , 10 , 10 , 10 , 10 , 10 , 15 , 10 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE printmaxSubseq ( arr , n ) ; NEW_LINE DEDENT"],"references":["def printmaxSubseq ( arr , n ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT if ( arr [ i ] < arr [ i + 1 ] ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ i ] ) ; NEW_LINE DEDENT DEDENT print ( arr [ n - 1 ] ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 9 , 8 , 11 , 13 , 10 , 15 , 14 , 16 , 20 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE printmaxSubseq ( arr , n ) ; NEW_LINE DEDENT"],"bleu":0.773208707008735,"rouge_l":0.8565770523283724}
{"id":792,"predictions":["def printFibonacciNumbers ( n ) : NEW_LINE INDENT f1 = 0 NEW_LINE f2 = 1 NEW_LINE if ( n < 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( f2 , end = \" ▁ \" ) NEW_LINE n2 = f2 + f2 NEW_LINE f2 = n2 NEW_LINE DEDENT DEDENT printFibonacciNumbers ( 7 ) NEW_LINE"],"references":["def printFibonacciNumbers ( n ) : NEW_LINE INDENT f1 = 0 NEW_LINE f2 = 1 NEW_LINE if ( n < 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT for x in range ( 0 , n ) : NEW_LINE INDENT print ( f2 , end = \" ▁ \" ) NEW_LINE next = f1 + f2 NEW_LINE f1 = f2 NEW_LINE f2 = next NEW_LINE DEDENT DEDENT printFibonacciNumbers ( 7 ) NEW_LINE"],"bleu":0.7584797635963609,"rouge_l":0.8850760018424689}
{"id":793,"predictions":["def cal_energy ( dist , time ) : NEW_LINE INDENT print ( \" \\n ▁ distance ▁ : ▁ \" , time ) ; NEW_LINE print ( \" \\n \" , end = \" \" ) ; NEW_LINE print ( \" \\n \" , time ) ; NEW_LINE print ( \" \\n \" , time ) ; NEW_LINE print ( \" \\n \" , time ) ; NEW_LINE return int ( time \/ time ) ; NEW_LINE DEDENT def cal_time ( sp , time ) : NEW_LINE INDENT print ( \" \\n \" , time ) ; NEW_LINE print ( \" \\n \" , time ) ; NEW_LINE print ( \" \\t ▁ \" , time ) ; NEW_LINE print ( \" \\n ▁ Time \" , end = \" \" ) ; NEW_LINE return rate * time ; NEW_LINE DEDENT def cal_time ( distance , time ) ) : NEW_LINE INDENT print ( \" \\n \" , end = \" \" ) ; NEW_LINE print ( \" \\n \" , end = \" \" ) ; NEW_LINE print ( \" \\n \" , end = \" \" ) ; NEW_LINE print ( \" \\n \" , end = \" \" ) ; NEW_LINE print ( \" The ▁ the ▁ 24\" ) ; NEW_LINE print ( \" The ▁ The ▁ The ▁ The ▁ Sy \" , end = \" \" ) ; NEW_LINE print ( \" \" ) ; NEW_LINE print ( \" The ▁ The ▁ passing \" , end = \" \" ) ; NEW_LINE print ( \" \" ) ; NEW_LINE print ( \" The ▁ The ▁ Computer ▁ \" , math .5 ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( \" \" ) ; NEW_LINE print ( \" \\n \" ) ; NEW_LINE DEDENT"],"references":["def cal_speed ( dist , time ) : NEW_LINE INDENT print ( \" ▁ Distance ( km ) ▁ : \" , dist ) ; NEW_LINE print ( \" ▁ Time ( hr ) ▁ : \" , time ) ; NEW_LINE return dist \/ time ; NEW_LINE DEDENT def cal_dis ( speed , time ) : NEW_LINE INDENT print ( \" ▁ Time ( hr ) ▁ : \" , time ) ; NEW_LINE print ( \" ▁ Speed ( km ▁ \/ ▁ hr ) ▁ : \" , speed ) ; NEW_LINE return speed * time ; NEW_LINE DEDENT def cal_time ( dist , speed ) : NEW_LINE INDENT print ( \" ▁ Distance ( km ) ▁ : \" , dist ) ; NEW_LINE print ( \" ▁ Speed ( km ▁ \/ ▁ hr ) ▁ : \" , speed ) ; NEW_LINE return speed * dist ; NEW_LINE DEDENT print ( \" ▁ The ▁ calculated ▁ Speed ( km ▁ \/ ▁ hr ) ▁ is ▁ : \" , cal_speed ( 45.9 , 2.0 ) ) ; NEW_LINE print ( \" \" ) ; NEW_LINE print ( \" ▁ The ▁ calculated ▁ Distance ( km ) ▁ : \" , cal_dis ( 62.9 , 2.5 ) ) ; NEW_LINE print ( \" \" ) ; NEW_LINE print ( \" ▁ The ▁ calculated ▁ Time ( hr ) ▁ : \" , cal_time ( 48.0 , 4.5 ) ) ; NEW_LINE"],"bleu":0.3200968800719562,"rouge_l":0.5583358098068351}
{"id":794,"predictions":["import math NEW_LINE def fermatFactors ( n ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT print ( \" [ \" , n , \" ] \" ) NEW_LINE return NEW_LINE DEDENT if ( ( n & 1 ) == 0 ) : NEW_LINE INDENT print ( \" [ \" , n \/\/ 2.0 , \" , \" , \" , \" ] \" , \" ] \" ) NEW_LINE return NEW_LINE DEDENT a = ceil ( math . sqrt ( n ) ) NEW_LINE if ( a * a == n ) : NEW_LINE INDENT print ( \" [ \" , a , \" , \" , \" , \" ] \" ) NEW_LINE return NEW_LINE DEDENT a = ceil ( math . sqrt ( n ) ) NEW_LINE if ( a * a == n ) : NEW_LINE INDENT print ( \" [ \" , a , \" , \" , a , \" ] \" ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT a = a * a - n NEW_LINE b = int ( math . sqrt ( b ) ) NEW_LINE if ( b * b == b ) : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT a += 1 NEW_LINE DEDENT DEDENT print ( \" [ \" , a - b ) , \" , ( a + b ) , \" ] \" ) NEW_LINE return NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT"],"references":["from math import ceil , sqrt NEW_LINE def FermatFactors ( n ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return [ n ] NEW_LINE DEDENT if ( n & 1 ) == 0 : NEW_LINE INDENT return [ n \/ 2 , 2 ] NEW_LINE DEDENT a = ceil ( sqrt ( n ) ) NEW_LINE if ( a * a == n ) : NEW_LINE INDENT return [ a , a ] NEW_LINE DEDENT while ( True ) : NEW_LINE INDENT b1 = a * a - n NEW_LINE b = int ( sqrt ( b1 ) ) NEW_LINE if ( b * b == b1 ) : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT a += 1 NEW_LINE DEDENT DEDENT return [ a - b , a + b ] NEW_LINE DEDENT print ( FermatFactors ( 6557 ) ) NEW_LINE"],"bleu":0.35568083752551183,"rouge_l":0.6377932675960558}
{"id":795,"predictions":["def perfectCube ( N ) : NEW_LINE INDENT cube = i * i * i ; NEW_LINE if ( cube == N ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE return ; NEW_LINE DEDENT elif ( cube > N ) : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE return ; NEW_LINE DEDENT DEDENT N = 24 ; NEW_LINE perfectCube ( N ) ; NEW_LINE"],"references":["def perfectCube ( N ) : NEW_LINE INDENT cube = 0 ; NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT cube = i * i * i ; NEW_LINE if ( cube == N ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE return ; NEW_LINE DEDENT elif ( cube > N ) : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE return ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 216 ; NEW_LINE perfectCube ( N ) ; NEW_LINE DEDENT"],"bleu":0.5795602180642171,"rouge_l":0.7676454495714025}
{"id":796,"predictions":["def removeDuplicates ( str , n ) : NEW_LINE INDENT index = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( str [ i ] == str [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( j == i ) : NEW_LINE INDENT str [ index ] = str [ i ] NEW_LINE index += 1 NEW_LINE index += 1 NEW_LINE DEDENT DEDENT return str [ index ] NEW_LINE DEDENT str = \" geeksforgeeks \" NEW_LINE n = len ( str ) NEW_LINE print ( removeDuplicates ( str , n ) ) NEW_LINE"],"references":["def removeDuplicate ( str , n ) : NEW_LINE INDENT index = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , i + 1 ) : NEW_LINE INDENT if ( str [ i ] == str [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( j == i ) : NEW_LINE INDENT str [ index ] = str [ i ] NEW_LINE index += 1 NEW_LINE DEDENT DEDENT return \" \" . join ( str [ : index ] ) NEW_LINE DEDENT str = \" geeksforgeeks \" NEW_LINE n = len ( str ) NEW_LINE print ( removeDuplicate ( list ( str ) , n ) ) NEW_LINE"],"bleu":0.758021652935238,"rouge_l":0.8901431718061675}
{"id":797,"predictions":["def compareSeq ( s , x , y , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if s [ x ] < s [ y ] : NEW_LINE INDENT return True NEW_LINE DEDENT x = ( x + 1 ) % n NEW_LINE y = ( y + 1 ) % n NEW_LINE DEDENT return True NEW_LINE DEDENT def smallestSequence ( S , n ) : NEW_LINE INDENT index = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if compareSeq ( S , index , i , n ) == True : NEW_LINE INDENT index = i NEW_LINE DEDENT DEDENT return index NEW_LINE DEDENT def smallestSequence ( S , n ) : NEW_LINE INDENT index = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if compareSeq ( S , index + i ) % n == 0 : NEW_LINE INDENT index = i NEW_LINE DEDENT DEDENT return index NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = \" DECACBCBCAA \" NEW_LINE n = 8 NEW_LINE printSmallestSequence ( S , n ) NEW_LINE DEDENT"],"references":["import copy NEW_LINE def printSmallestSequence ( s ) : NEW_LINE INDENT m = copy . copy ( s ) NEW_LINE for i in range ( len ( s ) - 1 ) : NEW_LINE INDENT if m > s [ i : ] + s [ : i ] : NEW_LINE INDENT m = s [ i : ] + s [ : i ] NEW_LINE DEDENT DEDENT return m NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT st = ' DCACBCAA ' NEW_LINE print ( printSmallestSequence ( st ) ) NEW_LINE DEDENT"],"bleu":0.1478245737726506,"rouge_l":0.4125947521865889}
{"id":798,"predictions":["def partSort ( arr , N , a , b ) : NEW_LINE INDENT l = min ( arr , N ) NEW_LINE r = max ( a ) NEW_LINE temp = [ 0 for i in range ( r - l + 1 ) ] NEW_LINE j = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT temp [ j ] = arr [ i ] NEW_LINE j += 1 NEW_LINE DEDENT temp . sort ( ) NEW_LINE j = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT arr [ i ] = temp [ j ] NEW_LINE j += 1 NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 7 , 8 , 4 , 5 , 2 ] NEW_LINE a = 1 NEW_LINE b = 4 NEW_LINE N = len ( arr ) NEW_LINE partSort ( arr , N , a , b ) NEW_LINE DEDENT"],"references":["def partSort ( arr , N , a , b ) : NEW_LINE INDENT l = min ( a , b ) NEW_LINE r = max ( a , b ) NEW_LINE temp = [ 0 for i in range ( r - l + 1 ) ] NEW_LINE j = 0 NEW_LINE for i in range ( l , r + 1 , 1 ) : NEW_LINE INDENT temp [ j ] = arr [ i ] NEW_LINE j += 1 NEW_LINE DEDENT temp . sort ( reverse = False ) NEW_LINE j = 0 NEW_LINE for i in range ( l , r + 1 , 1 ) : NEW_LINE INDENT arr [ i ] = temp [ j ] NEW_LINE j += 1 NEW_LINE DEDENT for i in range ( 0 , N , 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 7 , 8 , 4 , 5 , 2 ] NEW_LINE a = 1 NEW_LINE b = 4 NEW_LINE N = len ( arr ) NEW_LINE partSort ( arr , N , a , b ) NEW_LINE DEDENT"],"bleu":0.8611038648466307,"rouge_l":0.9435234393590861}
{"id":799,"predictions":["def checkYear ( year ) : NEW_LINE INDENT if ( year % 400 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( year % 100 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( year % 4 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT year = 2000 NEW_LINE if ( checkYear ( year ) ) : NEW_LINE INDENT print ( \" Leap ▁ Year \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ a ▁ Leap ▁ Year \" ) NEW_LINE DEDENT"],"references":["def checkYear ( year ) : NEW_LINE INDENT if ( year % 4 ) == 0 : NEW_LINE INDENT if ( year % 100 ) == 0 : NEW_LINE INDENT if ( year % 400 ) == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT year = 2000 NEW_LINE if ( checkYear ( year ) ) : NEW_LINE INDENT print ( \" Leap ▁ Year \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ a ▁ Leap ▁ Year \" ) NEW_LINE DEDENT"],"bleu":0.7144963162612622,"rouge_l":0.7973856209150325}
{"id":800,"predictions":["def countPairs ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE right , left = 0 , 0 NEW_LINE visited = [ False ] * n NEW_LINE while ( right < n ) : NEW_LINE INDENT while ( right < n and visited [ arr [ right ] ] ) : NEW_LINE INDENT count += ( right - left ) NEW_LINE visited [ arr [ right ] ] = True NEW_LINE right += 1 NEW_LINE DEDENT while ( left < right and ( right != n and visited [ arr [ right ] ] ) : NEW_LINE INDENT visited [ arr [ right ] ] = False NEW_LINE left += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 4 , 2 , 4 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE DEDENT"],"references":["def countPairs ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE right = 0 NEW_LINE left = 0 NEW_LINE visited = [ False for i in range ( n ) ] NEW_LINE while ( right < n ) : NEW_LINE INDENT while ( right < n and visited [ arr [ right ] ] == False ) : NEW_LINE INDENT count += ( right - left ) NEW_LINE visited [ arr [ right ] ] = True NEW_LINE right += 1 NEW_LINE DEDENT while ( left < right and ( right != n and visited [ arr [ right ] ] == True ) ) : NEW_LINE INDENT visited [ arr [ left ] ] = False NEW_LINE left += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 4 , 2 , 4 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.8303515652084204,"rouge_l":0.9200603318250375}
{"id":801,"predictions":["def binarySearch ( arr , n , x ) : NEW_LINE INDENT l , r = 0 , len ( arr ) NEW_LINE while ( l <= r ) : NEW_LINE INDENT m = l + ( r - l ) \/\/ 2 NEW_LINE if ( arr [ m ] == x ) : NEW_LINE INDENT return m NEW_LINE DEDENT if ( arr [ m ] < x ) : NEW_LINE INDENT return m NEW_LINE DEDENT else : NEW_LINE INDENT r = m - 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 10 , 40 ] NEW_LINE x = 10 NEW_LINE result = binarySearch ( arr , x ) NEW_LINE if ( result == - 1 ) : NEW_LINE INDENT print ( \" Element ▁ is ▁ present ▁ at ▁ index \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Element ▁ is ▁ % d \" % result ) NEW_LINE DEDENT"],"references":["def binarySearch ( arr , l , r , x ) : NEW_LINE INDENT while l <= r : NEW_LINE INDENT mid = l + ( r - l ) \/\/ 2 ; NEW_LINE if arr [ mid ] == x : NEW_LINE INDENT return mid NEW_LINE DEDENT elif arr [ mid ] < x : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = mid - 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 10 , 40 ] NEW_LINE x = 10 NEW_LINE result = binarySearch ( arr , 0 , len ( arr ) - 1 , x ) NEW_LINE if result != - 1 : NEW_LINE INDENT print ( \" Element ▁ is ▁ present ▁ at ▁ index ▁ % ▁ d \" % result ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Element ▁ is ▁ not ▁ present ▁ in ▁ array \" ) NEW_LINE DEDENT"],"bleu":0.6576860192005961,"rouge_l":0.7859443631039531}
{"id":802,"predictions":["def isComposite ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT print ( \" False\" ) NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT print ( \" False \" ) NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return False NEW_LINE DEDENT if ( isComposite ( 11 ) ) : NEW_LINE INDENT print ( \" false \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" false \" ) NEW_LINE DEDENT DEDENT if ( isComposite ( 11 ) ) : NEW_LINE INDENT print ( \" false \" ) NEW_LINE if ( isComposite ( 15 ) ) : NEW_LINE INDENT print ( \" true \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" false \" ) NEW_LINE DEDENT DEDENT if ( isComposite ( 15 ) ) : NEW_LINE INDENT print ( \" false \" ) NEW_LINE if ( isComposite ( 15 ) ) : NEW_LINE INDENT print ( \" false \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" false \" ) NEW_LINE DEDENT DEDENT"],"references":["def isComposite ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return False NEW_LINE DEDENT print ( \" true \" ) if ( isComposite ( 11 ) ) else print ( \" false \" ) NEW_LINE print ( \" true \" ) if ( isComposite ( 15 ) ) else print ( \" false \" ) NEW_LINE"],"bleu":0.5333359617916186,"rouge_l":0.7700388418079095}
{"id":803,"predictions":["def decToBinary ( n ) : NEW_LINE INDENT binaryNum = [ 0 ] * 32 NEW_LINE i = 0 NEW_LINE while ( n ) : NEW_LINE INDENT binaryNum [ i ] = n % 2 NEW_LINE n = n \/\/ 2 NEW_LINE i += 1 NEW_LINE DEDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( binaryNum [ j ] , end = \" \" ) NEW_LINE DEDENT DEDENT n = 17 NEW_LINE decToBinary ( n ) NEW_LINE"],"references":["def decToBinary ( n ) : NEW_LINE INDENT binaryNum = [ 0 ] * n ; NEW_LINE i = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT binaryNum [ i ] = n % 2 ; NEW_LINE n = int ( n \/ 2 ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( binaryNum [ j ] , end = \" \" ) ; NEW_LINE DEDENT DEDENT n = 17 ; NEW_LINE decToBinary ( n ) ; NEW_LINE"],"bleu":0.6971959928423955,"rouge_l":0.8999491266745803}
{"id":804,"predictions":["def calculateSum ( n ) : NEW_LINE INDENT return ( n * ( pow ( n , 2 ) + 3 * n + 5 ) ) \/ 3 NEW_LINE DEDENT n = 25 NEW_LINE print ( int ( solveSum ( n ) ) ) ) NEW_LINE"],"references":["def findSum ( n ) : NEW_LINE INDENT return ( n * ( pow ( n , 2 ) + 3 * n + 5 ) ) \/ 3 NEW_LINE DEDENT n = 25 NEW_LINE print ( int ( findSum ( n ) ) ) NEW_LINE"],"bleu":0.8856232059835971,"rouge_l":0.9480748851995762}
{"id":805,"predictions":["def isPerfectSquare ( n ) : NEW_LINE INDENT i = 1 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( ( n % i == 0 ) and ( n \/\/ i == i ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 36 NEW_LINE if ( isPerfectSquare ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def isPerfectSquare ( n ) : NEW_LINE INDENT i = 1 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( ( n % i == 0 ) and ( n \/ i == i ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 36 NEW_LINE if ( isPerfectSquare ( n ) ) : NEW_LINE INDENT print ( \" Yes , ▁ it ▁ is ▁ a ▁ perfect ▁ square . \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No , ▁ it ▁ is ▁ not ▁ a ▁ perfect ▁ square . \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.7061440508594423,"rouge_l":0.8475650883582895}
{"id":806,"predictions":["def getSum ( x , y , z ) : NEW_LINE INDENT N = 101 NEW_LINE mod = 10 ** 9 + 7 NEW_LINE expectednum = [ [ 0 for i in range ( N + 1 ) ] for j in range ( N + 1 ) ] NEW_LINE x = [ [ 0 for i in range ( N + 1 ) ] for j in range ( N + 1 ) ] NEW_LINE def getSum ( x , y , z ) : NEW_LINE INDENT ans = 0 NEW_LINE existsnum [ 0 ] [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( x + 1 ) : NEW_LINE INDENT for j in range ( y + 1 ) : NEW_LINE INDENT for k in range ( z + 1 ) : NEW_LINE INDENT if ( i > 0 ) : NEW_LINE INDENT if ( i > 0 ) : NEW_LINE INDENT existssum [ i ] [ j ] += ( Fixedsum [ i - 1 ] [ j ] * 10 + 4 * existsnum [ i - 1 ] [ j ] ) % mod NEW_LINEexnum [ i ] [ j ] += x NEW_LINE DEDENT if ( j > 0 ) : NEW_LINE INDENT existssum [ i ] [ j ] += ( minimalsum [ i ] [ j ] * 10 + 5 * discretenum [ i ] [ j ] ) % mod NEW_LINE x ] [ j ] += x NEW_LINE DEDENT if ( j > 0 ) : NEW_LINE INDENT existssum [ i ] [ j ] += ( absolutesum [ i ] [ j ] * 10 + 5 * expectnum [ i ] [ j ] ) % mod NEW_LINE xx [ i ] [ j ] += x ] [ j ] % mod NEW_LINE DEDENT ans += x [ i ] [ j ] [ k ] % mod NEW_LINE x ] [ j ] %= mod NEW_LINE DEDENT ans += x NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 1 NEW_LINE y = 1 NEW_LINE z = 1 NEW_LINE print ( getSum ( x , y , z ) ) NEW_LINE DEDENT"],"references":["import numpy as np NEW_LINE N = 101 ; NEW_LINE mod = int ( 1e9 ) + 7 ; NEW_LINE exactsum = np . zeros ( ( N , N , N ) ) ; NEW_LINE exactnum = np . zeros ( ( N , N , N ) ) ; NEW_LINE def getSum ( x , y , z ) : NEW_LINE INDENT ans = 0 ; NEW_LINE exactnum [ 0 ] [ 0 ] [ 0 ] = 1 ; NEW_LINE for i in range ( x + 1 ) : NEW_LINE INDENT for j in range ( y + 1 ) : NEW_LINE INDENT for k in range ( z + 1 ) : NEW_LINE INDENT if ( i > 0 ) : NEW_LINE INDENT exactsum [ i ] [ j ] [ k ] += ( exactsum [ i - 1 ] [ j ] [ k ] * 10 + 4 * exactnum [ i - 1 ] [ j ] [ k ] ) % mod ; NEW_LINE exactnum [ i ] [ j ] [ k ] += exactnum [ i - 1 ] [ j ] [ k ] % mod ; NEW_LINE DEDENT if ( j > 0 ) : NEW_LINE INDENT exactsum [ i ] [ j ] [ k ] += ( exactsum [ i ] [ j - 1 ] [ k ] * 10 + 5 * exactnum [ i ] [ j - 1 ] [ k ] ) % mod ; NEW_LINE exactnum [ i ] [ j ] [ k ] += exactnum [ i ] [ j - 1 ] [ k ] % mod ; NEW_LINE DEDENT if ( k > 0 ) : NEW_LINE INDENT exactsum [ i ] [ j ] [ k ] += ( exactsum [ i ] [ j ] [ k - 1 ] * 10 + 6 * exactnum [ i ] [ j ] [ k - 1 ] ) % mod ; NEW_LINE exactnum [ i ] [ j ] [ k ] += exactnum [ i ] [ j ] [ k - 1 ] % mod ; NEW_LINE DEDENT ans += exactsum [ i ] [ j ] [ k ] % mod ; NEW_LINE ans %= mod ; NEW_LINE DEDENT DEDENT DEDENT return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = 1 ; y = 1 ; z = 1 ; NEW_LINE print ( ( getSum ( x , y , z ) % mod ) ) ; NEW_LINE DEDENT"],"bleu":0.4875437889761679,"rouge_l":0.693698286341712}
{"id":807,"predictions":["def countPairs ( s ) : NEW_LINE INDENT st = set ( ) NEW_LINE st . add ( ' a ' ) NEW_LINE st . add ( ' e ' ) NEW_LINE count = 0 NEW_LINE for i in range ( len ( s ) - 1 ) : NEW_LINE INDENT if s [ i ] in st : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT s = \" geeksforgeeks \" NEW_LINE print ( countPairs ( s ) ) NEW_LINE"],"references":["def countPairs ( s ) : NEW_LINE INDENT st = set ( ) ; NEW_LINE st . add ( ' a ' ) ; NEW_LINE st . add ( ' e ' ) ; NEW_LINE st . add ( ' i ' ) ; NEW_LINE st . add ( ' o ' ) ; NEW_LINE st . add ( ' u ' ) ; NEW_LINE count = 0 ; NEW_LINE n = len ( s ) ; NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( s [ i ] not in st and s [ i + 1 ] in st ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" geeksforgeeks \" ; NEW_LINE print ( countPairs ( s ) ) ; NEW_LINE DEDENT"],"bleu":0.33323778764155215,"rouge_l":0.6442821749902203}
{"id":808,"predictions":["MOD = 10 ** 9 + 7 NEW_LINE def modulo_13 ( s , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 13 ) ] for j in range ( n + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT nxt = ord ( s [ i ] ) - ord ( '0' ) NEW_LINE if ( s [ i ] == ' ? ' ) : NEW_LINE INDENT nxt = j NEW_LINE if ( s [ i ] == ' ? ' ) : NEW_LINE INDENT nxt = j NEW_LINE DEDENT for k in range ( 10 * k + nxt ) : NEW_LINE INDENT rem = ( 10 * k + nxt ) % 13 NEW_LINE dp [ i + 1 ] [ rem ] += dp [ i ] [ rem ] NEW_LINE dp [ i + 1 ] [ rem ] %= MOD NEW_LINE DEDENT if ( s [ i ] != ' ? ' ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ 5 ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" ? \" NEW_LINE n = len ( s ) NEW_LINE print ( modulo_13 ( s , n ) ) NEW_LINE DEDENT"],"references":["import numpy as np NEW_LINE MOD = ( int ) ( 1e9 + 7 ) NEW_LINE def modulo_13 ( s , n ) : NEW_LINE INDENT dp = np . zeros ( ( n + 1 , 13 ) ) ; NEW_LINE dp [ 0 ] [ 0 ] = 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT nxt = ord ( s [ i ] ) - ord ( '0' ) ; NEW_LINE if ( s [ i ] == ' ? ' ) : NEW_LINE INDENT nxt = j ; NEW_LINE DEDENT for k in range ( 13 ) : NEW_LINE INDENT rem = ( 10 * k + nxt ) % 13 ; NEW_LINE dp [ i + 1 ] [ rem ] += dp [ i ] [ k ] ; NEW_LINE dp [ i + 1 ] [ rem ] %= MOD ; NEW_LINE DEDENT if ( s [ i ] != ' ? ' ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT DEDENT return int ( dp [ n ] [ 5 ] ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" ? 44\" ; NEW_LINE n = len ( s ) ; NEW_LINE print ( modulo_13 ( s , n ) ) ; NEW_LINE DEDENT"],"bleu":0.7239669444064295,"rouge_l":0.8420055484132891}
{"id":809,"predictions":["def max_ profit ( a , b , n , profit ) : NEW_LINE INDENT l = 0 NEW_LINE r = 1 NEW_LINE b [ 0 ] = diff_time NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT l = 0 NEW_LINE r = diff_time NEW_LINE sum = 0 NEW_LINE for j in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT profit = ( a [ r ] - a [ l ] ) - f NEW_LINE if profit > 0 : NEW_LINE INDENT sum = sum + profit NEW_LINE DEDENT l += 1 NEW_LINE r += 1 NEW_LINE DEDENT if b [ 0 ] < sum : NEW_LINE INDENT b [ 0 ] = sum NEW_LINE b [ 1 ] = diff NEW_LINE DEDENT diff_date += 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 6 , 1 , 7 , 2 , 8 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE b = [ 0 for i in range ( 2 ) ] NEW_LINE print ( b [ 0 ] , \" , \" , \" , b [ 1 ] ) NEW_LINE DEDENT"],"references":["def max_profit ( a , b , n , fee ) : NEW_LINE INDENT i , j , profit = 1 , n - 1 , 0 NEW_LINE l , r , diff_day = 0 , 0 , 1 NEW_LINE b [ 0 ] = 0 NEW_LINE b [ 1 ] = diff_day NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT l = 0 NEW_LINE r = diff_day NEW_LINE Sum = 0 NEW_LINE for j in range ( n - 1 , i - 1 , - 1 ) : NEW_LINE INDENT profit = ( a [ r ] - a [ l ] ) - fee NEW_LINE if ( profit > 0 ) : NEW_LINE INDENT Sum = Sum + profit NEW_LINE DEDENT l += 1 NEW_LINE r += 1 NEW_LINE DEDENT if ( b [ 0 ] < Sum ) : NEW_LINE INDENT b [ 0 ] = Sum NEW_LINE b [ 1 ] = diff_day NEW_LINE DEDENT DEDENT diff_day += 1 NEW_LINE return 0 NEW_LINE DEDENT arr = [ 6 , 1 , 7 , 2 , 8 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE b = [ 0 for i in range ( 2 ) ] NEW_LINE tranFee = 2 NEW_LINE max_profit ( arr , b , n , tranFee ) NEW_LINE print ( b [ 0 ] , \" , \" , b [ 1 ] ) NEW_LINE"],"bleu":0.6284148510993339,"rouge_l":0.7938415588109798}
{"id":810,"predictions":["MAX = 25 NEW_LINE def getMinSum ( arr , n ) : NEW_LINE INDENT bits_count = [ 0 for i in range ( MAX ) ] NEW_LINE max_bit = 0 NEW_LINE sum = 0 NEW_LINE ans = 0 NEW_LINE for d in range ( n ) : NEW_LINE INDENT e = arr [ d ] NEW_LINE f = 0 NEW_LINE while ( e > 0 ) : NEW_LINE INDENT rem = e % 2 NEW_LINE e = e \/\/ 2 NEW_LINE if ( rem == 1 ) : NEW_LINE INDENT bits_count [ f ] += rem NEW_LINE DEDENT f += 1 NEW_LINE DEDENT max_bit = max ( max_bit , f ) NEW_LINE DEDENT for d in range ( max_bit ) : NEW_LINE INDENT temp = int ( pow ( 2 , d ) ) NEW_LINE if ( bits_count [ d ] > n \/\/ 2 ) : NEW_LINE INDENT ans = ans + temp NEW_LINE DEDENT DEDENT for d in range ( n ) : NEW_LINE INDENT arr [ d ] = arr [ d ] ^ ans NEW_LINE sum = sum + arr [ d ] NEW_LINE DEDENT return sum NEW_LINE DEDENT arr = [ 3 , 5 , 7 , 11 , 15 ] NEW_LINE n = len ( arr ) NEW_LINE print ( getMinSum ( arr , n ) ) NEW_LINE"],"references":["MAX = 25 ; NEW_LINE def getMinSum ( arr , n ) : NEW_LINE INDENT bits_count = [ 0 ] * MAX NEW_LINE max_bit = 0 ; sum = 0 ; ans = 0 ; NEW_LINE for d in range ( n ) : NEW_LINE INDENT e = arr [ d ] ; f = 0 ; NEW_LINE while ( e > 0 ) : NEW_LINE INDENT rem = e % 2 ; NEW_LINE e = e \/\/ 2 ; NEW_LINE if ( rem == 1 ) : NEW_LINE INDENT bits_count [ f ] += rem ; NEW_LINE DEDENT f += 1 NEW_LINE DEDENT max_bit = max ( max_bit , f ) ; NEW_LINE DEDENT for d in range ( max_bit ) : NEW_LINE INDENT temp = pow ( 2 , d ) ; NEW_LINE if ( bits_count [ d ] > n \/\/ 2 ) : NEW_LINE INDENT ans = ans + temp ; NEW_LINE DEDENT DEDENT for d in range ( n ) : NEW_LINE INDENT arr [ d ] = arr [ d ] ^ ans ; NEW_LINE sum = sum + arr [ d ] ; NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 5 , 7 , 11 , 15 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( getMinSum ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.7419567015339896,"rouge_l":0.8970588235294117}
{"id":811,"predictions":["def findNums ( arr , n ) : NEW_LINE INDENT S = 0 NEW_LINE X = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT S += arr [ i ] NEW_LINE X ^= arr [ i ] NEW_LINE DEDENT print ( X , X + S ) NEW_LINE DEDENT arr = [ 1 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE findNums ( arr , n ) NEW_LINE"],"references":["def findNums ( arr , n ) : NEW_LINE INDENT S = 0 ; X = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT S += arr [ i ] ; NEW_LINE X ^= arr [ i ] ; NEW_LINE DEDENT print ( X , X + S ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 7 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE findNums ( arr , n ) ; NEW_LINE DEDENT"],"bleu":0.6124621287497198,"rouge_l":0.8467454511348715}
{"id":812,"predictions":["def bin ( n ) : NEW_LINE INDENT if ( n > 1 ) : NEW_LINE INDENT bin ( n >> 1 ) ; NEW_LINE DEDENT print ( n & 1 ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 131 ; NEW_LINE print ( n ) ; NEW_LINE DEDENT"],"references":["def bin ( n ) : NEW_LINE INDENT if ( n > 1 ) : NEW_LINE INDENT bin ( n >> 1 ) NEW_LINE DEDENT print ( n & 1 , end = \" \" ) NEW_LINE DEDENT bin ( 131 ) NEW_LINE print ( ) NEW_LINE bin ( 3 ) NEW_LINE"],"bleu":0.529645029611927,"rouge_l":0.7055160142348754}
{"id":813,"predictions":["def Square ( row , column , moves ) : NEW_LINE INDENT a = 0 NEW_LINE b = 0 NEW_LINE c = 0 NEW_LINE total = 0 NEW_LINE d = column + moves NEW_LINE c = column - moves NEW_LINE d = column + moves NEW_LINE if ( a < 1 ) : NEW_LINE INDENT a = 1 NEW_LINE DEDENT if ( c < 1 ) : NEW_LINE INDENT c = 1 NEW_LINE DEDENT if ( b > 8 ) : NEW_LINE INDENT d = 8 NEW_LINE DEDENT if ( d > 8 ) : NEW_LINE INDENT d = 8 NEW_LINE DEDENT total = ( b - a + 1 ) * ( d - c + 1 ) - 1 NEW_LINE return total NEW_LINE DEDENT R = 4 NEW_LINE C = 5 NEW_LINE M = 2 NEW_LINE print ( Square ( R , C , M ) ) NEW_LINE"],"references":["def Square ( row , column , moves ) : NEW_LINE INDENT a = 0 ; b = 0 ; c = 0 ; NEW_LINE d = 0 ; total = 0 ; NEW_LINE a = row - moves ; NEW_LINE b = row + moves ; NEW_LINE c = column - moves ; NEW_LINE d = column + moves ; NEW_LINE if ( a < 1 ) : NEW_LINE INDENT a = 1 ; NEW_LINE DEDENT if ( c < 1 ) : NEW_LINE INDENT c = 1 ; NEW_LINE DEDENT if ( b > 8 ) : NEW_LINE INDENT b = 8 ; NEW_LINE DEDENT if ( d > 8 ) : NEW_LINE INDENT d = 8 ; NEW_LINE DEDENT total = ( b - a + 1 ) * ( d - c + 1 ) - 1 ; NEW_LINE return total ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT R = 4 ; C = 5 ; M = 2 ; NEW_LINE print ( Square ( R , C , M ) ) ; NEW_LINE DEDENT"],"bleu":0.5867017536527134,"rouge_l":0.8293401787412055}
{"id":814,"predictions":["import math NEW_LINE def firstkdigits ( n , k ) : NEW_LINE INDENT product = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT product *= n NEW_LINE DEDENT while ( ( product \/\/ pow ( 10 , k ) ) != 0 ) : NEW_LINE INDENT product = product \/\/ 10 NEW_LINE DEDENT return product NEW_LINE DEDENT n = 15 NEW_LINE k = 4 NEW_LINE print ( firstkdigits ( n , k ) ) NEW_LINE"],"references":["def firstkdigits ( n , k ) : NEW_LINE INDENT product = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT product *= n NEW_LINE DEDENT while ( ( product \/\/ pow ( 10 , k ) ) != 0 ) : NEW_LINE INDENT product = product \/\/ 10 NEW_LINE DEDENT return product NEW_LINE DEDENT n = 15 NEW_LINE k = 4 NEW_LINE print ( firstkdigits ( n , k ) ) NEW_LINE"],"bleu":0.9617755306166065,"rouge_l":0.9840798132031415}
{"id":815,"predictions":["def solve ( X , Y , N , K ) : NEW_LINE INDENT count = [ [ 0 ] * ( N + 1 ) NEW_LINE sol = 0 NEW_LINE count [ 0 ] = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT count [ i ] = count [ i - 1 ] + abs ( X [ i - 1 ] ) NEW_LINE DEDENT j = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT while ( ( count [ i ] - count [ j ] ) > K ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT sol = max ( sol , i - j ) NEW_LINE DEDENT return sol NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 4 NEW_LINE X = \" abcd \" NEW_LINE Y = \" bcde \" NEW_LINE K = 3 NEW_LINE print ( solve ( X , Y , N , K ) ) ) NEW_LINE DEDENT"],"references":["def solve ( X , Y , N , K ) : NEW_LINE INDENT count = [ 0 ] * ( N + 1 ) ; NEW_LINE sol = 0 ; NEW_LINE count [ 0 ] = 0 ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT count [ i ] = ( count [ i - 1 ] + abs ( ord ( X [ i - 1 ] ) - ord ( Y [ i - 1 ] ) ) ) ; NEW_LINE DEDENT j = 0 ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT while ( ( count [ i ] - count [ j ] ) > K ) : NEW_LINE INDENT j += 1 ; NEW_LINE DEDENT sol = max ( sol , i - j ) ; NEW_LINE DEDENT return sol ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 ; NEW_LINE X = \" abcd \" ; NEW_LINE Y = \" bcde \" ; NEW_LINE K = 3 ; NEW_LINE print ( solve ( X , Y , N , K ) ) ; NEW_LINE DEDENT"],"bleu":0.7250604443118975,"rouge_l":0.9019770726034225}
{"id":816,"predictions":["MAX = 1000 NEW_LINE f = [ 0 for i in range ( MAX ) ] NEW_LINE def fib ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 1 or n == 2 ) : NEW_LINE INDENT f [ n ] = 1 NEW_LINE DEDENT if ( f [ n ] != 0 ) : NEW_LINE INDENT return f [ n ] NEW_LINE DEDENT k = 0 NEW_LINE if ( ( n & 1 ) != 0 ) : NEW_LINE INDENT k = ( n + 1 ) \/\/ 2 NEW_LINE DEDENT if ( ( n & 1 ) != 0 ) : NEW_LINE INDENT f [ n ] = ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT f [ n ] = ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ) ) NEW_LINE DEDENT return f [ n ] NEW_LINE DEDENT def gcd ( a , b ) : NEW_LINE INDENT return ( fib ( a ) * fib ( b ) ) \/\/ fib ( gcd ( a , b ) ) NEW_LINE DEDENT a = 3 NEW_LINE b = 12 NEW_LINE print ( findLCMFibonacci ( a , b ) ) NEW_LINE"],"references":["MAX = 1000 NEW_LINE f = [ 0 ] * MAX NEW_LINE def fib ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 1 or n == 2 ) : NEW_LINE INDENT f [ n ] = 1 NEW_LINE return f [ n ] NEW_LINE DEDENT if ( f [ n ] ) : NEW_LINE INDENT return f [ n ] NEW_LINE DEDENT k = ( n + 1 ) \/\/ 2 if ( n & 1 ) else n \/\/ 2 NEW_LINE if ( n & 1 ) : NEW_LINE INDENT f [ n ] = ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT f [ n ] = ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ) NEW_LINE DEDENT return f [ n ] NEW_LINE DEDENT def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def findLCMFibonacci ( a , b ) : NEW_LINE INDENT return ( fib ( a ) * fib ( b ) ) \/\/ fib ( gcd ( a , b ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 3 NEW_LINE b = 12 NEW_LINE print ( findLCMFibonacci ( a , b ) ) NEW_LINE DEDENT"],"bleu":0.7564546641648116,"rouge_l":0.8127736769673465}
{"id":817,"predictions":["def find_digit ( s , n ) : NEW_LINE INDENT first_digit = - 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] < '0' or s [ i ] > '9' ) : NEW_LINE INDENT first_digit = i NEW_LINE break NEW_LINE DEDENT DEDENT first_digit += 1 NEW_LINE s_len = first_digit NEW_LINE num = first_digit NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( s [ i ] >= '0' and s [ i ] <= '9' ) : NEW_LINE INDENT digit = ord ( s [ i ] ) - ord ( '0' ) NEW_LINE num = num + ( pw * digit ) NEW_LINE if ( num >= s_len ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT pw = pw * 10 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT num = num * 10 NEW_LINE req = s_len - num NEW_LINE if ( ( req > 9 or req < 0 ) ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return req NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" abcd0\" NEW_LINE n = len ( s ) NEW_LINE print ( find_digit ( s , n ) ) NEW_LINE DEDENT"],"references":["def find_digit ( s , n ) : NEW_LINE INDENT first_digit = - 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if s [ i ] < '0' or s [ i ] > '9' : NEW_LINE INDENT first_digit = i NEW_LINE break NEW_LINE DEDENT DEDENT first_digit += 1 NEW_LINE s_len = first_digit NEW_LINE num = 0 NEW_LINE pw = 1 NEW_LINE i = n - 1 NEW_LINE while i >= 0 : NEW_LINE INDENT if s [ i ] >= '0' and s [ i ] <= '9' : NEW_LINE INDENT digit = ord ( s [ i ] ) - ord ( '0' ) NEW_LINE num = num + ( pw * digit ) NEW_LINE if num >= s_len : NEW_LINE INDENT return - 1 NEW_LINE DEDENT pw = pw * 10 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT num = num * 10 NEW_LINE req = s_len - num NEW_LINE if req > 9 or req < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return req NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" abcd0\" NEW_LINE n = len ( s ) NEW_LINE print ( find_digit ( s , n ) ) NEW_LINE DEDENT"],"bleu":0.8665585649651443,"rouge_l":0.9467149508535956}
{"id":818,"predictions":["def findNthNumber ( A , B , N ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT sum = A + B NEW_LINE A = B NEW_LINE B = sum NEW_LINE DEDENT return sum NEW_LINE DEDENT A = 5 NEW_LINE B = 7 NEW_LINE N = 10 NEW_LINE print ( findNthNumber ( A , B , N ) ) NEW_LINE"],"references":["def findNthNumber ( A , B , N ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT sum = A + B NEW_LINE A = B NEW_LINE B = sum NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = 5 NEW_LINE B = 7 NEW_LINE N = 10 NEW_LINE print ( findNthNumber ( A , B , N ) ) NEW_LINE DEDENT"],"bleu":0.8032501596745566,"rouge_l":0.8957600827300931}
{"id":819,"predictions":["def calculateSum ( n ) : NEW_LINE INDENT return ( ( pow ( 10 , n + 1 ) * ( 9 * n - 1 ) + 10 ) \/ pow ( 9 , 3 ) - n * ( n + 1 ) \/ 18 ) NEW_LINE DEDENT n = 3 NEW_LINE print ( \" Sum = \" , calculateSum ( n ) ) NEW_LINE"],"references":["def solve_sum ( n ) : NEW_LINE INDENT return ( pow ( 10 , n + 1 ) * ( 9 * n - 1 ) + 10 ) \/ pow ( 9 , 3 ) - n * ( n + 1 ) \/ 18 NEW_LINE DEDENT n = 3 NEW_LINE print ( int ( solve_sum ( n ) ) ) NEW_LINE"],"bleu":0.7966083992091595,"rouge_l":0.8972863302054274}
{"id":820,"predictions":["def summation ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) * ( 2 * n + 1 ) ) \/\/ 6 NEW_LINE DEDENT n = 10 NEW_LINE print ( summation ( n ) ) NEW_LINE"],"references":["def summation ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) * ( 2 * n + 1 ) ) \/ 6 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE print ( summation ( n ) ) NEW_LINE DEDENT"],"bleu":0.6451004705978576,"rouge_l":0.8157208088714937}
{"id":821,"predictions":["from math import sqrt NEW_LINE def mean ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + arr [ i ] NEW_LINE DEDENT return sum \/ n NEW_LINE DEDENT def SSD ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + ( arr [ i ] - mean ( arr , n ) ) * ( arr [ i ] - mean ( arr , n ) ) NEW_LINE DEDENT return sqrt ( sum \/ ( n - 1 ) ) NEW_LINE DEDENT def sampleError ( arr , n ) : NEW_LINE INDENT return ( arr , n ) \/ sqrt ( n ) NEW_LINE DEDENT arr = [ 78.53 , 79.2 , 80.25f , 81.21 NEW_LINE n = len ( arr ) NEW_LINE print ( sampleError ( arr , n ) ) NEW_LINE"],"references":["import math NEW_LINE def mean ( arr , n ) : NEW_LINE INDENT sm = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sm = sm + arr [ i ] NEW_LINE DEDENT return sm \/ n NEW_LINE DEDENT def SSD ( arr , n ) : NEW_LINE INDENT sm = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sm = sm + ( arr [ i ] - mean ( arr , n ) ) * ( arr [ i ] - mean ( arr , n ) ) NEW_LINE DEDENT return ( math . sqrt ( sm \/ ( n - 1 ) ) ) NEW_LINE DEDENT def sampleError ( arr , n ) : NEW_LINE INDENT return SSD ( arr , n ) \/ ( math . sqrt ( n ) ) NEW_LINE DEDENT arr = [ 78.53 , 79.62 , 80.25 , 81.05 , 83.21 , 83.46 ] NEW_LINE n = len ( arr ) NEW_LINE print ( sampleError ( arr , n ) ) NEW_LINE"],"bleu":0.704140618388251,"rouge_l":0.8663801158661933}
{"id":822,"predictions":["INF = 9999999 NEW_LINE def sqrtByLongDivision ( n ) : NEW_LINE INDENT i = cur_divisor = 0 NEW_LINE quotient = 0 NEW_LINE cur_digient = 0 NEW_LINE for j in range ( 10 ) : NEW_LINE INDENT a [ i ] = n % 100 NEW_LINE n = int ( n \/ 100 ) NEW_LINE i += 1 NEW_LINE DEDENT i -= 1 NEW_LINE for j in range ( i , - 1 , - 1 ) : NEW_LINE INDENT cur_remend = in range ( INF_d ) NEW_LINE cur_dividend = cur_dividend * 100 + a [ j ] NEW_LINE for udigit in range ( i , 10 ) : NEW_LINE INDENT cur_remainder = in range ( 10 ** 10 + a [ j ] ) NEW_LINE for udigit in range ( 10 , 10 + udigit ) : NEW_LINE INDENT if cur_remainder > ( ( cur_divisor * 10 + udigit ) * udigit ) and cur_divid ) >= 0 : NEW_LINE INDENT cur_remainder = cur_dividend - ( ( cur_divisor * 10 + udigit ) * udigit ) NEW_LINE quotient_units_digit_digits_digit_digit_digit ) += 1 NEW_LINE DEDENT DEDENT cur_quotient = cur_quotient * 10 + quotient NEW_LINE cur_divisor = cur_quotient NEW_LINE DEDENT return cur_quotient NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = 1225 NEW_LINE print ( sqrtByLongDivision ( x ) ) NEW_LINE DEDENT"],"references":["INFINITY_ = 9999999 NEW_LINE def sqrtByLongDivision ( n ) : NEW_LINE INDENT i = 0 NEW_LINE udigit , j = 0 , 0 NEW_LINE cur_divisor = 0 NEW_LINE quotient_units_digit = 0 NEW_LINE cur_quotient = 0 NEW_LINE cur_dividend = 0 NEW_LINE cur_remainder = 0 NEW_LINE a = [ 0 ] * 10 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT a [ i ] = n % 100 NEW_LINE n = n \/\/ 100 NEW_LINE i += 1 NEW_LINE DEDENT i -= 1 NEW_LINE for j in range ( i , - 1 , - 1 ) : NEW_LINE INDENT cur_remainder = INFINITY_ NEW_LINE cur_dividend = cur_dividend * 100 + a [ j ] NEW_LINE for udigit in range ( 10 ) : NEW_LINE INDENT if ( cur_remainder >= cur_dividend - ( ( cur_divisor * 10 + udigit ) * udigit ) and cur_dividend - ( ( cur_divisor * 10 + udigit ) * udigit ) >= 0 ) : NEW_LINE INDENT cur_remainder = cur_dividend - ( ( cur_divisor * 10 + udigit ) * udigit ) NEW_LINE quotient_units_digit = udigit NEW_LINE DEDENT DEDENT cur_quotient = cur_quotient * 10 + quotient_units_digit NEW_LINE cur_divisor = cur_quotient * 2 NEW_LINE cur_dividend = cur_remainder NEW_LINE DEDENT return cur_quotient NEW_LINE DEDENT x = 1225 NEW_LINE print ( sqrtByLongDivision ( x ) ) NEW_LINE"],"bleu":0.6215895763557283,"rouge_l":0.7179109966899595}
{"id":823,"predictions":["def CountAllPairs ( N , K ) : NEW_LINE INDENT count = 0 NEW_LINE if ( N > K ) : NEW_LINE INDENT count = N - K NEW_LINE for i in range ( K + 1 , N + 1 ) : NEW_LINE INDENT count = count + ( ( N - K ) \/\/ i ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT N = 11 NEW_LINE K = 5 NEW_LINE print ( CountAllPairs ( N , K ) ) NEW_LINE"],"references":["import math NEW_LINE def CountAllPairs ( N , K ) : NEW_LINE INDENT count = 0 NEW_LINE if ( N > K ) : NEW_LINE INDENT count = N - K NEW_LINE for i in range ( K + 1 , N + 1 ) : NEW_LINE INDENT count = count + ( ( N - K ) \/\/ i ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT N = 11 NEW_LINE K = 5 NEW_LINE print ( CountAllPairs ( N , K ) ) NEW_LINE"],"bleu":0.9645008374979939,"rouge_l":0.9791142912396055}
{"id":824,"predictions":["def checkNumber ( N ) : NEW_LINE INDENT temp = N NEW_LINE while ( temp ) : NEW_LINE INDENT if ( temp % 1000 == 144 ) : NEW_LINE INDENT temp \/\/= 1000 NEW_LINE DEDENT elif ( temp % 100 == 14 ) : NEW_LINE INDENT temp \/\/= 100 NEW_LINE DEDENT elif ( temp % 10 == 1 ) : NEW_LINE INDENT temp \/\/= 10 NEW_LINE DEDENT else : NEW_LINE INDENT return \" NO \" NEW_LINE DEDENT DEDENT return \" YES \" NEW_LINE DEDENT N = 1414 NEW_LINE print ( checkNumber ( N ) ) NEW_LINE"],"references":["def checkNumber ( N ) : NEW_LINE INDENT temp = N NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT if ( temp % 1000 == 144 ) : NEW_LINE INDENT temp \/= 1000 NEW_LINE DEDENT elif ( temp % 100 == 14 ) : NEW_LINE INDENT temp \/= 100 NEW_LINE DEDENT elif ( temp % 10 == 1 ) : NEW_LINE INDENT temp \/= 10 NEW_LINE DEDENT else : NEW_LINE INDENT return \" YES \" NEW_LINE DEDENT DEDENT return \" NO \" NEW_LINE DEDENT N = 1414 ; NEW_LINE print ( checkNumber ( N ) ) ; NEW_LINE"],"bleu":0.8376151740865299,"rouge_l":0.9251666666666668}
{"id":825,"predictions":["def printNumbers ( N ) : NEW_LINE INDENT flag = 1 NEW_LINE x = N NEW_LINE if ( N > 0 ) : NEW_LINE INDENT while ( x > 0 and flag == 1 ) : NEW_LINE INDENT digit = x % 10 NEW_LINE if ( digit != 1 and digit != 3 ) : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT x = x \/\/ 10 NEW_LINE DEDENT if ( flag == 1 ) : NEW_LINE INDENT print ( N , end = \" ▁ \" ) NEW_LINE DEDENT printNumbers ( N - 1 ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 25 NEW_LINE printNumbers ( N ) NEW_LINE DEDENT"],"references":["def printNumbers ( N ) : NEW_LINE INDENT flag = 1 NEW_LINE x = N NEW_LINE if ( N > 0 ) : NEW_LINE INDENT while ( x > 0 and flag == 1 ) : NEW_LINE INDENT digit = x % 10 NEW_LINE if ( digit != 1 and digit != 3 ) : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT x = x \/\/ 10 NEW_LINE DEDENT if ( flag == 1 ) : NEW_LINE INDENT print ( N , end = \" ▁ \" ) NEW_LINE DEDENT printNumbers ( N - 1 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 20 NEW_LINE printNumbers ( N ) NEW_LINE DEDENT"],"bleu":0.9375886983457306,"rouge_l":0.9754098360655737}
{"id":826,"predictions":["def getPosition ( a , n , m ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT a [ i ] = ( a [ i ] \/\/ m + ( a [ i ] % m ) ) NEW_LINE DEDENT ans = - 1 NEW_LINE max = - 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( max < a [ i ] ) : NEW_LINE INDENT max = a [ i ] NEW_LINE ans = i NEW_LINE DEDENT DEDENT return ans + 1 NEW_LINE DEDENT a = [ 2 , 5 , 4 ] NEW_LINE n = len ( a ) NEW_LINE m = 2 NEW_LINE print ( getPosition ( a , n , m ) ) NEW_LINE"],"references":["import math as mt NEW_LINE def getPosition ( a , n , m ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT a [ i ] = ( a [ i ] \/\/ m + ( a [ i ] % m != 0 ) ) NEW_LINE DEDENT ans , maxx = - 1 , - 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( maxx < a [ i ] ) : NEW_LINE INDENT maxx = a [ i ] NEW_LINE ans = i NEW_LINE DEDENT DEDENT return ans + 1 NEW_LINE DEDENT a = [ 2 , 5 , 4 ] NEW_LINE n = len ( a ) NEW_LINE m = 2 NEW_LINE print ( getPosition ( a , n , m ) ) NEW_LINE"],"bleu":0.8645151706073634,"rouge_l":0.9357554786620531}
{"id":827,"predictions":["def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT def sortArr ( arr , n , k ) : NEW_LINE INDENT prev = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % k == 0 ) : NEW_LINE INDENT if ( arr [ i ] % k == 0 ) : NEW_LINE INDENT arr . sort ( arr , prev + 1 , i ) NEW_LINE DEDENT prev = i NEW_LINE DEDENT DEDENT printArr ( arr , n ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 1 , 15 , 3 , 7 , 8 , 10 , 15 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE sortArr ( arr , n , k ) NEW_LINE DEDENT"],"references":["def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT def sortArr ( arr , n , k ) : NEW_LINE INDENT prev = - 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % k == 0 ) : NEW_LINE INDENT if ( prev != - 1 ) : NEW_LINE INDENT temp = arr [ prev + 1 : i ] ; NEW_LINE temp . sort ( ) ; NEW_LINE arr = arr [ : prev + 1 ] + temp + arr [ i : ] ; NEW_LINE DEDENT prev = i ; NEW_LINE DEDENT DEDENT printArr ( arr , n ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 1 , 13 , 3 , 7 , 8 , 21 , 13 , 12 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE k = 2 ; NEW_LINE sortArr ( arr , n , k ) ; NEW_LINE DEDENT"],"bleu":0.6635765549913307,"rouge_l":0.8328355661745883}
{"id":828,"predictions":["from queue import Queue NEW_LINE def countOfBinaryNumberLessThanN ( N ) : NEW_LINE INDENT q = Queue ( ) NEW_LINE q . put ( 1 ) NEW_LINE cnt = 0 NEW_LINE while ( q . empty ( ) ) : NEW_LINE INDENT t = q . queue [ 0 ] NEW_LINE q . get ( ) NEW_LINE if ( t <= N ) : NEW_LINE INDENT cnt += 1 NEW_LINE q . put ( t * 10 ) NEW_LINE q . put ( t * 10 + 1 ) NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 200 NEW_LINE print ( countOfBinaryNumberLessThanN ( N ) ) NEW_LINE DEDENT"],"references":["from collections import deque NEW_LINE def countOfBinaryNumberLessThanN ( N ) : NEW_LINE INDENT q = deque ( ) NEW_LINE q . append ( 1 ) NEW_LINE cnt = 0 NEW_LINE while ( q ) : NEW_LINE INDENT t = q . popleft ( ) NEW_LINE if ( t <= N ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE q . append ( t * 10 ) NEW_LINE q . append ( t * 10 + 1 ) NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 200 NEW_LINE print ( countOfBinaryNumberLessThanN ( N ) ) NEW_LINE DEDENT"],"bleu":0.6943501577495851,"rouge_l":0.8643899674082473}
{"id":829,"predictions":["mod = 10 ** 9 + 7 NEW_LINE def power ( p ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 1 , p + 1 ) : NEW_LINE INDENT res *= 2 NEW_LINE res %= mod NEW_LINE DEDENT return res % mod NEW_LINE DEDENT def subset_square_sum ( A ) : NEW_LINE INDENT n = len ( A ) NEW_LINE ans = 0 NEW_LINE for i in A : NEW_LINE INDENT ans += ( 1 * i * i ) % mod NEW_LINE ans %= mod NEW_LINE DEDENT return ( 1 * ans * ans ) % mod NEW_LINE DEDENT A = [ 3 , 7 ] NEW_LINE print ( subset_square_sum ( A ) ) NEW_LINE"],"references":["mod = 10 ** 9 + 7 NEW_LINE def power ( p ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 1 , p + 1 ) : NEW_LINE INDENT res *= 2 NEW_LINE res %= mod NEW_LINE DEDENT return res % mod NEW_LINE DEDENT def subset_square_sum ( A ) : NEW_LINE INDENT n = len ( A ) NEW_LINE ans = 0 NEW_LINE for i in A : NEW_LINE INDENT ans += i * i % mod NEW_LINE ans %= mod NEW_LINE DEDENT return ans * power ( n - 1 ) % mod NEW_LINE DEDENT A = [ 3 , 7 ] NEW_LINE print ( subset_square_sum ( A ) ) NEW_LINE"],"bleu":0.8877682471189801,"rouge_l":0.947310038824182}
{"id":830,"predictions":["def performQueries ( A , q ) : NEW_LINE INDENT n = len ( A ) NEW_LINE pref_xor = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT pref_xor [ i ] = pref_xor [ i - 1 ] ^ A [ i - 1 ] NEW_LINE DEDENT for i in range ( q ) : NEW_LINE INDENT L = i [ 0 ] [ 0 ] NEW_LINE R = i [ 1 ] NEW_LINE if ( L > R ) : NEW_LINE INDENT temp = L NEW_LINE L = R NEW_LINE R = temp NEW_LINE DEDENT if ( L != R and pref_xor [ R ] == pref_xor [ L - 1 ] ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT Arr = [ 1 , 1 , 2 , 2 , 1 ] NEW_LINE q = [ [ 1 , 5 ] , [ 1 , 4 ] , [ 3 , 4 ] , [ 3 , 4 ] ] NEW_LINE performQueries ( Arr , q ) NEW_LINE DEDENT"],"references":["def performQueries ( A , q ) : NEW_LINE INDENT n = len ( A ) NEW_LINE pref_xor = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT pref_xor [ i ] = pref_xor [ i - 1 ] ^ A [ i - 1 ] NEW_LINE DEDENT for i in q : NEW_LINE INDENT L = i [ 0 ] NEW_LINE R = i [ 1 ] NEW_LINE if ( L > R ) : NEW_LINE INDENT L , R = R , L NEW_LINE DEDENT if ( L != R and pref_xor [ R ] == pref_xor [ L - 1 ] ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT DEDENT Arr = [ 1 , 1 , 2 , 2 , 1 ] NEW_LINE q = [ [ 1 , 5 ] , [ 1 , 4 ] , [ 3 , 4 ] ] NEW_LINE performQueries ( Arr , q ) ; NEW_LINE"],"bleu":0.815546415025473,"rouge_l":0.9171826003055399}
{"id":831,"predictions":["if __name__ == \" _ _ main _ \" : NEW_LINE INDENT one = \" one ▁ one ▁ \" , \" two ▁ \" , \" two ▁ \" , \" ten ▁ \" , \" seven ▁ \" , \" eight ▁ \" , \" seven ▁ \" , \" eight ▁ \" , \" seven ▁ \" , \" eight ▁ \" , \" eight ▁ \" , \" eight ▁ \" , \" eight ▁ \" , \" eight ▁ \" , \" eight ▁ \" , \" eight ▁ \" , \" eight ▁ \" , \" eight ▁ \" , \" seven \" , \" seven \" ] NEW_LINE a = \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \""],"references":["one = [ \" \" , \" one ▁ \" , \" two ▁ \" , \" three ▁ \" , \" four ▁ \" , \" five ▁ \" , \" six ▁ \" , \" seven ▁ \" , \" eight ▁ \" , \" nine ▁ \" , \" ten ▁ \" , \" eleven ▁ \" , \" twelve ▁ \" , \" thirteen ▁ \" , \" fourteen ▁ \" , \" fifteen ▁ \" , \" sixteen ▁ \" , \" seventeen ▁ \" , \" eighteen ▁ \" , \" nineteen ▁ \" ] ; NEW_LINE ten = [ \" \" , \" \" , \" twenty ▁ \" , \" thirty ▁ \" , \" forty ▁ \" , \" fifty ▁ \" , \" sixty ▁ \" , \" seventy ▁ \" , \" eighty ▁ \" , \" ninety ▁ \" ] ; NEW_LINE def numToWords ( n , s ) : NEW_LINE INDENT str = \" \" ; NEW_LINE if ( n > 19 ) : NEW_LINE INDENT str += ten [ n \/\/ 10 ] + one [ n % 10 ] ; NEW_LINE DEDENT else : NEW_LINE INDENT str += one [ n ] ; NEW_LINE DEDENT if ( n ) : NEW_LINE INDENT str += s ; NEW_LINE DEDENT return str ; NEW_LINE DEDENT def convertToWords ( n ) : NEW_LINE INDENT out = \" \" ; NEW_LINE out += numToWords ( ( n \/\/ 10000000 ) , \" crore ▁ \" ) ; NEW_LINE out += numToWords ( ( ( n \/\/ 100000 ) % 100 ) , \" lakh ▁ \" ) ; NEW_LINE out += numToWords ( ( ( n \/\/ 1000 ) % 100 ) , \" thousand ▁ \" ) ; NEW_LINE out += numToWords ( ( ( n \/\/ 100 ) % 10 ) , \" hundred ▁ \" ) ; NEW_LINE if ( n > 100 and n % 100 ) : NEW_LINE INDENT out += \" and ▁ \" ; NEW_LINE DEDENT out += numToWords ( ( n % 100 ) , \" \" ) ; NEW_LINE return out ; NEW_LINE DEDENT n = 438237764 ; NEW_LINE print ( convertToWords ( n ) ) ; NEW_LINE"],"bleu":0.14117178413467082,"rouge_l":0.28513630293031655}
{"id":832,"predictions":["def factorial ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res *= i NEW_LINE DEDENT return res NEW_LINE DEDENT num = 5 NEW_LINE print ( \" Factorial ▁ of \" , num , \" is \" , factorial ( num ) ) NEW_LINE"],"references":["def factorial ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res *= i NEW_LINE DEDENT return res NEW_LINE DEDENT num = 5 ; NEW_LINE print ( \" Factorial ▁ of \" , num , \" is \" , factorial ( num ) ) NEW_LINE"],"bleu":0.9574206856844987,"rouge_l":0.9900962861072903}
{"id":833,"predictions":["def getMinCost ( n , m ) : NEW_LINE INDENT cost = ( ( n - 1 ) * m + ( m - 1 ) * n ) NEW_LINE return cost NEW_LINE DEDENT n = 4 NEW_LINE m = 5 NEW_LINE print ( getMinCost ( n , m ) ) NEW_LINE"],"references":["def getMinCost ( n , m ) : NEW_LINE INDENT cost = ( n - 1 ) * m + ( m - 1 ) * n NEW_LINE return cost NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n , m = 4 , 5 NEW_LINE print ( getMinCost ( n , m ) ) NEW_LINE DEDENT"],"bleu":0.6331325573800924,"rouge_l":0.7955049944506104}
{"id":834,"predictions":["def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT a = 2 NEW_LINE b = 4 NEW_LINE print ( gcd ( a , b ) ) NEW_LINE"],"references":["def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT a = 2 NEW_LINE b = 4 NEW_LINE print ( gcd ( a , b ) ) NEW_LINE"],"bleu":1.0,"rouge_l":1.0}
{"id":835,"predictions":["def calculateSum ( n ) : NEW_LINE INDENT return n * ( n + 1 ) \/\/ 2 + pow ( ( n * ( n + 1 ) \/\/ 2 ) , 2 ) NEW_LINE DEDENT n = 3 NEW_LINE print ( \" Sum ▁ = \" , calculateSum ( n ) ) NEW_LINE"],"references":["def calculateSum ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) \/\/ 2 + pow ( ( n * ( n + 1 ) \/\/ 2 ) , 2 ) ) NEW_LINE DEDENT n = 3 NEW_LINE print ( \" Sum ▁ = ▁ \" , calculateSum ( n ) ) NEW_LINE"],"bleu":0.8789703920627397,"rouge_l":0.9688131677736066}
{"id":836,"predictions":["def findLength ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE maxlen = 0 NEW_LINE sum = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum [ i ] [ i ] = ord ( str [ i ] ) - ord ( '0' ) NEW_LINE DEDENT for len in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( n - len + 1 ) : NEW_LINE INDENT j = i + l - 1 NEW_LINE k = len \/\/ 2 NEW_LINE sum [ i ] [ j ] = ( sum [ i ] [ j - k ] + sum [ j - k + 1 ] [ j - k + 1 ] ) NEW_LINE if ( len % 2 == 0 and sum [ i ] [ j - k ] == sum [ j - k + 1 ] ) : NEW_LINE INDENT maxlen = len NEW_LINE DEDENT DEDENT DEDENT return maxlen NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \"153\" NEW_LINE print ( \" Length ▁ of ▁ the ▁ substring ▁ is \" , findLength ( str ) ) NEW_LINE DEDENT"],"references":["def findLength ( string ) : NEW_LINE INDENT n = len ( string ) NEW_LINE maxlen = 0 NEW_LINE Sum = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT Sum [ i ] [ i ] = int ( string [ i ] ) NEW_LINE DEDENT for length in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( 0 , n - length + 1 ) : NEW_LINE INDENT j = i + length - 1 NEW_LINE k = length \/\/ 2 NEW_LINE Sum [ i ] [ j ] = ( Sum [ i ] [ j - k ] + Sum [ j - k + 1 ] [ j ] ) NEW_LINE if ( length % 2 == 0 and Sum [ i ] [ j - k ] == Sum [ ( j - k + 1 ) ] [ j ] and length > maxlen ) : NEW_LINE INDENT maxlen = length NEW_LINE DEDENT DEDENT DEDENT return maxlen NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \"153803\" NEW_LINE print ( \" Length ▁ of ▁ the ▁ substring ▁ is \" , findLength ( string ) ) NEW_LINE DEDENT"],"bleu":0.6950274450391815,"rouge_l":0.8650345703400593}
{"id":837,"predictions":["def solve ( a , b , n ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s += ( a [ i ] + b [ i ] ) NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return a [ 0 ] + b [ 0 ] NEW_LINE DEDENT if ( s % n != 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT x = s \/\/ n NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] > x ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( i > 0 ) : NEW_LINE INDENT a [ i ] += b [ i - 1 ] NEW_LINE b [ i - 1 ] = 0 NEW_LINE DEDENT if ( a [ i ] == x ) : NEW_LINE INDENT break NEW_LINE DEDENT y = a [ i ] + b [ i ] NEW_LINE if ( i + 1 < n ) : NEW_LINE INDENT y += b [ i + 1 ] NEW_LINE DEDENT if ( y == x ) : NEW_LINE INDENT a [ i ] += b [ i ] NEW_LINE b [ i ] = 0 NEW_LINE continue NEW_LINE DEDENT if ( a [ i ] + b [ i ] == x ) : NEW_LINE INDENT a [ i ] += b [ i + 1 ] NEW_LINE b [ i ] = 0 NEW_LINE continue NEW_LINE DEDENT if ( i + 1 < n and a [ i ] + b [ i + 1 ] == x ) : NEW_LINE INDENT a [ i ] += b [ i + 1 ] NEW_LINE b [ i + 1 ] = 0 NEW_LINE continue NEW_LINE DEDENT return - 1 NEW_LINE DEDENT a = [ 6 , 14 , 21 , 1 ] NEW_LINE b = [ 15 , 7 , 10 , 10 , 10 ] NEW_LINE n = len ( a ) NEW_LINE print ( solve ( a , b , n ) ) NEW_LINE"],"references":["def solve ( a , b , n ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT s += a [ i ] + b [ i ] NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return a [ 0 ] + b [ 0 ] NEW_LINE DEDENT if s % n != 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT x = s \/\/ n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if a [ i ] > x : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if i > 0 : NEW_LINE INDENT a [ i ] += b [ i - 1 ] NEW_LINE b [ i - 1 ] = 0 NEW_LINE DEDENT if a [ i ] == x : NEW_LINE INDENT continue NEW_LINE DEDENT y = a [ i ] + b [ i ] NEW_LINE if i + 1 < n : NEW_LINE INDENT y += b [ i + 1 ] NEW_LINE DEDENT if y == x : NEW_LINE INDENT a [ i ] = y NEW_LINE b [ i ] = 0 NEW_LINE if i + 1 < n : b [ i + 1 ] = 0 NEW_LINE continue NEW_LINE DEDENT if a [ i ] + b [ i ] == x : NEW_LINE INDENT a [ i ] += b [ i ] NEW_LINE b [ i ] = 0 NEW_LINE continue NEW_LINE DEDENT if i + 1 < n and a [ i ] + b [ i + 1 ] == x : NEW_LINE INDENT a [ i ] += b [ i + 1 ] NEW_LINE b [ i + 1 ] = 0 NEW_LINE continue NEW_LINE DEDENT return - 1 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if b [ i ] != 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT return x NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 6 , 14 , 21 , 1 ] NEW_LINE b = [ 15 , 7 , 10 , 10 ] NEW_LINE n = len ( a ) NEW_LINE print ( solve ( a , b , n ) ) NEW_LINE DEDENT"],"bleu":0.7410170815350455,"rouge_l":0.871015055433329}
{"id":838,"predictions":["def sumOfSeries ( n ) : NEW_LINE INDENT res = 0 NEW_LINE sum = 0 NEW_LINE prod = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += i NEW_LINE prod *= i NEW_LINE res += ( sum \/ prod ) NEW_LINE DEDENT return res NEW_LINE DEDENT n = 4 NEW_LINE print ( sumOfSeries ( n ) ) NEW_LINE"],"references":["def sumOfSeries ( n ) : NEW_LINE INDENT res = 0.0 NEW_LINE sum = 0 NEW_LINE prod = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + i NEW_LINE prod = prod * i NEW_LINE res = res + ( sum \/ prod ) NEW_LINE DEDENT return res NEW_LINE DEDENT n = 4 NEW_LINE print ( round ( sumOfSeries ( n ) , 5 ) ) NEW_LINE"],"bleu":0.6958243614759547,"rouge_l":0.8572384563908098}
{"id":839,"predictions":["def number_of_digits ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE i = 4 NEW_LINE res = 1 NEW_LINE res = 1 NEW_LINE while True : NEW_LINE INDENT sum += i NEW_LINE if ( sum >= n ) : NEW_LINE INDENT break NEW_LINE DEDENT i *= 4 NEW_LINE res += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT n = 21 NEW_LINE print ( number_of_digits ( n ) ) NEW_LINE"],"references":["def number_of_digits ( n ) : NEW_LINE INDENT i = 4 ; NEW_LINE res = 1 ; NEW_LINE sum = 0 ; NEW_LINE while ( True ) : NEW_LINE INDENT i *= 4 ; NEW_LINE res += 1 ; NEW_LINE sum += i ; NEW_LINE if ( sum >= n ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT return res ; NEW_LINE DEDENT n = 21 ; NEW_LINE print ( number_of_digits ( n ) ) ; NEW_LINE"],"bleu":0.5175525320578213,"rouge_l":0.7494515138218517}
{"id":840,"predictions":["from math import sqrt NEW_LINE def nonsquare ( n ) : NEW_LINE INDENT return ( n + ( 0.5 + ( sqrt ( n ) ) ) ) NEW_LINE DEDENT def printNonSquare ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( nonsquare ( i ) , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT n = 10 NEW_LINE printNonSquare ( n ) NEW_LINE"],"references":["import math NEW_LINE def nonsquare ( n ) : NEW_LINE INDENT return n + ( int ) ( 0.5 + math . sqrt ( n ) ) NEW_LINE DEDENT def printNonSquare ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( nonsquare ( i ) , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT n = 10 NEW_LINE printNonSquare ( n ) NEW_LINE"],"bleu":0.8529110096870965,"rouge_l":0.9161124222269899}
{"id":841,"predictions":["def distance ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT return math . sqrt ( x2 - x1 , 2 ) + pow ( y2 - y1 , 2 ) * 1 NEW_LINE DEDENT print ( distance ( 3 , 4 , 4 , 3 ) ) NEW_LINE"],"references":["import math NEW_LINE def distance ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT return math . sqrt ( math . pow ( x2 - x1 , 2 ) + math . pow ( y2 - y1 , 2 ) * 1.0 ) NEW_LINE DEDENT print ( \" % .6f \" % distance ( 3 , 4 , 4 , 3 ) ) NEW_LINE"],"bleu":0.6540968467283665,"rouge_l":0.838092672413793}
{"id":842,"predictions":["def evenOddInsertion ( arr , n ) : NEW_LINE INDENT for i in range ( 2 , n ) : NEW_LINE INDENT j = i - 2 NEW_LINE temp = arr [ i ] NEW_LINE if ( ( ( i + 1 ) & 1 ) : NEW_LINE INDENT while ( j >= 0 and temp >= arr [ j ] ) : NEW_LINE INDENT arr [ j + 2 ] = arr [ j ] NEW_LINE j -= 2 NEW_LINE DEDENT arr [ j + 2 ] = temp NEW_LINE DEDENT else : NEW_LINE INDENT while ( j >= 0 and temp <= arr [ j ] ) : NEW_LINE INDENT arr [ j + 2 ] = arr [ j ] NEW_LINE j -= 2 NEW_LINE DEDENT arr [ j + 2 ] = temp NEW_LINE DEDENT DEDENT DEDENT def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT arr = [ 10 , 10 , 15 , 15 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE evenOddionSort ( arr , n ) NEW_LINE printArray ( arr , n ) NEW_LINE"],"references":["def evenOddInsertionSort ( arr , n ) : NEW_LINE INDENT for i in range ( 2 , n ) : NEW_LINE INDENT j = i - 2 NEW_LINE temp = arr [ i ] NEW_LINE if ( ( i + 1 ) & 1 == 1 ) : NEW_LINE INDENT while ( temp >= arr [ j ] and j >= 0 ) : NEW_LINE INDENT arr [ j + 2 ] = arr [ j ] NEW_LINE j -= 2 NEW_LINE DEDENT arr [ j + 2 ] = temp NEW_LINE DEDENT else : NEW_LINE INDENT while ( temp <= arr [ j ] and j >= 0 ) : NEW_LINE INDENT arr [ j + 2 ] = arr [ j ] NEW_LINE j -= 2 NEW_LINE DEDENT arr [ j + 2 ] = temp NEW_LINE DEDENT DEDENT DEDENT def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 12 , 11 , 13 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE evenOddInsertionSort ( arr , n ) NEW_LINE printArray ( arr , n ) NEW_LINE"],"bleu":0.8556313823825071,"rouge_l":0.9139614074914869}
{"id":843,"predictions":["def search ( arr , l , h , key ) : NEW_LINE INDENT if ( l > h ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( l + h ) \/\/ 2 NEW_LINE if ( arr [ mid ] == key ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( ( arr [ l ] == arr [ mid ] ) and ( arr [ h ] == arr [ mid ] ) ) : NEW_LINE INDENT l += 1 NEW_LINE h -= 1 NEW_LINE DEDENT if ( arr [ l ] <= arr [ mid ] ) : NEW_LINE INDENT if ( key >= arr [ l ] and key <= arr [ mid ] ) ) : NEW_LINE INDENT return search ( arr , l , mid - 1 , key ) NEW_LINE DEDENT return search ( arr , mid + 1 , h , key ) NEW_LINE DEDENT if ( key >= arr [ mid ] and key <= arr [ h ] ) : NEW_LINE INDENT return search ( arr , mid + 1 , h , key ) NEW_LINE DEDENT return search ( arr , l , mid - 1 , key ) NEW_LINE DEDENT arr = [ 3 , 3 , 1 , 2 , 3 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE key = 3 NEW_LINE print ( search ( arr , 0 , n - 1 , key ) ) NEW_LINE"],"references":["def search ( arr , l , h , key ) : NEW_LINE INDENT if ( l > h ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT mid = ( l + h ) \/\/ 2 ; NEW_LINE if ( arr [ mid ] == key ) : NEW_LINE INDENT return mid ; NEW_LINE DEDENT if ( ( arr [ l ] == arr [ mid ] ) and ( arr [ h ] == arr [ mid ] ) ) : NEW_LINE INDENT l += 1 ; NEW_LINE h -= 1 ; NEW_LINE DEDENT if ( arr [ l ] <= arr [ mid ] ) : NEW_LINE INDENT if ( key >= arr [ l ] and key <= arr [ mid ] ) : NEW_LINE INDENT return search ( arr , l , mid - 1 , key ) ; NEW_LINE DEDENT return search ( arr , mid + 1 , h , key ) ; NEW_LINE DEDENT if ( key >= arr [ mid ] and key <= arr [ h ] ) : NEW_LINE INDENT return search ( arr , mid + 1 , h , key ) ; NEW_LINE DEDENT return search ( arr , l , mid - 1 , key ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 3 , 1 , 2 , 3 , 3 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE key = 3 ; NEW_LINE print ( search ( arr , 0 , n - 1 , key ) ) ; NEW_LINE DEDENT"],"bleu":0.8198478827547676,"rouge_l":0.9381705426356588}
{"id":844,"predictions":["def check ( s1 , s2 ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( 0 , len ( s1 ) ) : NEW_LINE INDENT mp [ s1 [ i ] ] += 1 NEW_LINE DEDENT for i in range ( 0 , len ( s2 ) ) : NEW_LINE INDENT if mp [ s2 [ i ] ] > 0 : NEW_LINE INDENT mp [ s1 [ i ] ] += 1 NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s1 = \" geeksforgeeks \" NEW_LINE s2 = \" geeks \" NEW_LINE yes_or_no = check ( s1 , s2 ) NEW_LINE if ( yes_or_no == True ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def is_member ( List , key ) : NEW_LINE INDENT for i in range ( 0 , len ( List ) ) : NEW_LINE INDENT if key == List [ i ] : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def overlap ( List1 , List2 ) : NEW_LINE INDENT for key in List1 : NEW_LINE INDENT if is_member ( List2 , key ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s1 = ' geeksforgeeks ' NEW_LINE s2 = ' geeks ' NEW_LINE List1 = list ( s1 ) NEW_LINE List2 = list ( s2 ) NEW_LINE yes_or_no = str ( overlap ( List1 , List2 ) ) NEW_LINE if ( yes_or_no ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.44905755418971643,"rouge_l":0.6181127295756808}
{"id":845,"predictions":["def nthTerm ( n ) : NEW_LINE INDENT return 2 * pow ( n , 2 ) + 3 * n - 5 NEW_LINE DEDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE"],"references":["def nthTerm ( n ) : NEW_LINE INDENT return 2 * pow ( n , 2 ) + 3 * n - 5 NEW_LINE DEDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE"],"bleu":1.0,"rouge_l":1.0}
{"id":846,"predictions":["arr = [ 0 ] * 33 NEW_LINE def balTernary ( ter ) : NEW_LINE INDENT carry = 0 NEW_LINE base = 10 NEW_LINE i = 32 NEW_LINE while ( ter ) : NEW_LINE INDENT rem = ter % base NEW_LINE rem = rem + carry NEW_LINE if ( rem == 0 ) : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE i -= 1 NEW_LINE carry = 0 NEW_LINE DEDENT elif ( rem == 1 ) : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE i -= 1 NEW_LINE carry = 0 NEW_LINE DEDENT elif ( rem == 2 ) : NEW_LINE INDENT arr [ i ] = - 1 NEW_LINE i -= 1 NEW_LINE carry = 1 NEW_LINE DEDENT elif ( rem == 3 ) : NEW_LINE INDENT arr [ i ] = - 1 NEW_LINE i -= 1 NEW_LINE DEDENT elif ( rem == 3 ) : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE i -= 1 NEW_LINE carry = 1 NEW_LINE DEDENT t = int ( t \/ base ) NEW_LINE DEDENT if ( carry == 1 ) : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT DEDENT def ternary ( number ) : NEW_LINE INDENT ans = 0 NEW_LINE rem = 1 NEW_LINE base = 1 NEW_LINE while ( number > 0 ) : NEW_LINE INDENT rem = number % 3 NEW_LINE ans = ans + rem * base NEW_LINE number = ( number \/\/ 3 ) NEW_LINE base = ( number \/\/ 3 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT number = 3056 NEW_LINE t = ternary ( number ) NEW_LINE bal = tnary ( number ) NEW_LINE print ( arr ) NEW_LINE DEDENT"],"references":["arr = [ 0 ] * 32 NEW_LINE def balTernary ( ter ) : NEW_LINE INDENT carry , base , i = 0 , 10 , 31 NEW_LINE while ter > 0 : NEW_LINE INDENT rem = ( ter % base ) + carry NEW_LINE if rem == 0 : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE carry , i = 0 , i - 1 NEW_LINE DEDENT elif rem == 1 : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE carry , i = 0 , i - 1 NEW_LINE DEDENT elif rem == 2 : NEW_LINE INDENT arr [ i ] = - 1 NEW_LINE carry , i = 1 , i - 1 NEW_LINE DEDENT elif rem == 3 : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE carry , i = 1 , i - 1 NEW_LINE DEDENT ter = ter \/\/ base NEW_LINE DEDENT if carry == 1 : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT DEDENT def ternary ( number ) : NEW_LINE INDENT ans , rem , base = 0 , 1 , 1 NEW_LINE while number > 0 : NEW_LINE INDENT rem = number % 3 NEW_LINE ans = ans + rem * base NEW_LINE number \/\/= 3 NEW_LINE base = base * 10 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT number = 3056 NEW_LINE ter = ternary ( number ) NEW_LINE balTernary ( ter ) NEW_LINE i = 0 NEW_LINE while arr [ i ] == 0 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT for j in range ( i , 32 ) : NEW_LINE INDENT if arr [ j ] == - 1 : NEW_LINE INDENT print ( ' Z ' , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ j ] , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT"],"bleu":0.4920044902536549,"rouge_l":0.6693928257156168}
{"id":847,"predictions":["class Node : NEW_LINE INDENT def __init__ ( self , value ) : NEW_LINE INDENT self . data = value NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def particular_level_order ( root ) : NEW_LINE INDENT q = [ ] NEW_LINE s = [ ] NEW_LINE q . append ( root ) NEW_LINE sz = [ ] NEW_LINE sz = 0 NEW_LINE while ( len ( q ) ) : NEW_LINE INDENT v = q . popleft ( ) NEW_LINE v . append ( temp . data ) NEW_LINE if ( temp . left ) : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE DEDENT if ( temp . right ) : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE DEDENT if ( temp . right ) : NEW_LINE INDENT q . append ( temp . right ) NEW_LINE DEDENT DEDENT while ( len ( s ) > 0 ) : NEW_LINE INDENT v = s [ ] NEW_LINE s . pop ( ) NEW_LINE for i in range ( len ( v ) - 1 , 1 ) : NEW_LINE INDENT print ( v [ i ] , \" ▁ \" , v [ i ] , end = \" \" ) NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT print ( root . data ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT root = Node ( 1 ) NEW_LINE root . left = Node ( 2 ) NEW_LINE root . right = Node ( 3 ) NEW_LINE root . right = Node ( 3 ) NEW_LINE root . right = Node ( 3 ) NEW_LINE print ( \" Specific ▁ Level ▁ traversal ▁ of ▁ \" , end = \" \" ) NEW_LINE compute_level_order ( root ) NEW_LINE DEDENT"],"references":["class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def specific_level_order_traversal ( root ) : NEW_LINE INDENT q = [ ] NEW_LINE s = [ ] NEW_LINE q . append ( root ) NEW_LINE sz = 0 NEW_LINE while ( len ( q ) > 0 ) : NEW_LINE INDENT v = [ ] NEW_LINE sz = len ( q ) NEW_LINE i = 0 NEW_LINE while ( i < sz ) : NEW_LINE INDENT temp = q [ 0 ] NEW_LINE q . pop ( 0 ) NEW_LINE v . append ( temp . data ) NEW_LINE if ( temp . left != None ) : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE DEDENT if ( temp . right != None ) : NEW_LINE INDENT q . append ( temp . right ) NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT s . append ( v ) NEW_LINE DEDENT while ( len ( s ) > 0 ) : NEW_LINE INDENT v = s [ - 1 ] NEW_LINE s . pop ( ) NEW_LINE i = 0 NEW_LINE j = len ( v ) - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT print ( v [ i ] , \" ▁ \" , v [ j ] , end = \" ▁ \" ) NEW_LINE j = j - 1 NEW_LINE i = i + 1 NEW_LINE DEDENT DEDENT print ( root . data ) NEW_LINE DEDENT root = Node ( 1 ) NEW_LINE root . left = Node ( 2 ) NEW_LINE root . right = Node ( 3 ) NEW_LINE print ( \" Specific ▁ Level ▁ Order ▁ traversal ▁ of ▁ binary ▁ tree ▁ is \" ) NEW_LINE specific_level_order_traversal ( root ) NEW_LINE"],"bleu":0.6789946984767284,"rouge_l":0.7601538461538461}
{"id":848,"predictions":["def sum ( h ) : NEW_LINE INDENT return pow ( 2 , h - 1 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT L = 3 NEW_LINE print ( sum ( L ) ) NEW_LINE DEDENT"],"references":["def summ ( h ) : NEW_LINE INDENT return pow ( 2 , h - 1 ) NEW_LINE DEDENT L = 3 NEW_LINE print ( summ ( L ) ) NEW_LINE"],"bleu":0.5501615554665087,"rouge_l":0.7893797411869701}
{"id":849,"predictions":["def countDivisors ( N , a , b ) : NEW_LINE INDENT count1 = N \/\/ a NEW_LINE count2 = N \/\/ b NEW_LINE count3 = ( N \/\/ ( a * b ) ) NEW_LINE return count1 + count2 - count3 NEW_LINE DEDENT N = 1000 NEW_LINE a = 3 NEW_LINE b = 4 NEW_LINE print ( countDivisors ( N , a , b ) ) NEW_LINE"],"references":["def countDivisors ( N , a , b ) : NEW_LINE INDENT count1 = N \/\/ a NEW_LINE count2 = N \/\/ b NEW_LINE count3 = ( N \/\/ ( a * b ) ) NEW_LINE return count1 + count2 - count3 NEW_LINE DEDENT N = 1000 NEW_LINE a = 3 NEW_LINE b = 4 NEW_LINE print ( countDivisors ( N , a , b ) ) NEW_LINE"],"bleu":1.0,"rouge_l":1.0}
{"id":850,"predictions":["def number_ascal ( n ) : NEW_LINE INDENT return ( n * n * n + 5 * n + 6 ) \/\/ 6 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 2 NEW_LINE print ( number_ascal ( n ) ) NEW_LINE n = 8 NEW_LINE print ( number_ascal ( n ) ) NEW_LINE n = 25 NEW_LINE print ( number_ cake ( n ) ) NEW_LINE DEDENT"],"references":["def number_cake ( n ) : NEW_LINE INDENT return ( n * n * n + 5 * n + 6 ) \/\/ 6 NEW_LINE DEDENT n = 2 NEW_LINE print ( number_cake ( n ) ) NEW_LINE n = 8 NEW_LINE print ( number_cake ( n ) ) NEW_LINE n = 25 NEW_LINE print ( number_cake ( n ) ) NEW_LINE"],"bleu":0.6589376878422283,"rouge_l":0.8510945393312485}
{"id":851,"predictions":["MAX = 100000000 NEW_LINE prime = [ True for i in range ( MAX + 1 ) ] NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= MAX : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT def find_Prime ( sum ) : NEW_LINE INDENT for i in range ( sum \/\/ 2 , 1 , - 1 ) : NEW_LINE INDENT if ( prime [ i ] and prime [ sum - i ] ) : NEW_LINE INDENT print ( i , ( sum - i ) ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( \" Cannot ▁ be ▁ which ▁ of ▁ two ▁ primes \" ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT MAX = 100000000 NEW_LINE prime = [ True ] * ( MAX + 1 ) NEW_LINE find_Prime ( sum ) NEW_LINE DEDENT"],"references":["from math import sqrt NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT MAX = 1000001 NEW_LINE prime = [ True for i in range ( MAX + 1 ) ] NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( sqrt ( MAX ) ) + 1 , 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT return prime NEW_LINE DEDENT def find_Prime ( sum ) : NEW_LINE INDENT prime = SieveOfEratosthenes ( ) NEW_LINE i = int ( sum \/ 2 ) NEW_LINE while ( i > 1 ) : NEW_LINE INDENT if ( prime [ i ] and prime [ sum - i ] ) : NEW_LINE INDENT print ( i , ( sum - i ) ) NEW_LINE return NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT print ( \" Cannot ▁ be ▁ represented ▁ as ▁ sum \" , \" of ▁ two ▁ primes \" ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT sum = 1002 NEW_LINE find_Prime ( sum ) NEW_LINE DEDENT"],"bleu":0.6850268290070787,"rouge_l":0.7418855062359594}
{"id":852,"predictions":["def generateNumbers ( factor , n , k ) : NEW_LINE INDENT next = [ 0 ] * k ; NEW_LINE output = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT toIncrement = 0 ; NEW_LINE for j in range ( k ) : NEW_LINE INDENT if ( next [ j ] < next [ toIncrement ] ) : NEW_LINE INDENT toIncrement = j ; NEW_LINE DEDENT DEDENT if ( output != next [ toIncrement ] ) : NEW_LINE INDENT output = next [ toIncrement ] ; NEW_LINE print ( next [ toIncrement ] , end = \" ▁ \" ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT DEDENT DEDENT factor = [ 3 , 5 , 7 ] ; NEW_LINE n = 10 ; NEW_LINE k = len ( factor ) ; NEW_LINE generateNumbers ( factor , n , k ) ; NEW_LINE"],"references":["def generateNumbers ( factor , n , k ) : NEW_LINE INDENT next = [ 0 ] * k ; NEW_LINE output = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT toincrement = 0 ; NEW_LINE for j in range ( k ) : NEW_LINE INDENT if ( next [ j ] < next [ toincrement ] ) : NEW_LINE INDENT toincrement = j ; NEW_LINE DEDENT DEDENT if ( output != next [ toincrement ] ) : NEW_LINE INDENT output = next [ toincrement ] ; NEW_LINE print ( next [ toincrement ] , end = \" ▁ \" ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT next [ toincrement ] += factor [ toincrement ] ; NEW_LINE DEDENT DEDENT factor = [ 3 , 5 , 7 ] ; NEW_LINE n = 10 ; NEW_LINE k = len ( factor ) ; NEW_LINE generateNumbers ( factor , n , k ) ; NEW_LINE"],"bleu":0.769190487942895,"rouge_l":0.8876160990712072}
{"id":853,"predictions":["def lengthOfSmallestSubsequence ( K , v ) : NEW_LINE INDENT pq = [ ] NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT pq . append ( v [ i ] ) NEW_LINE DEDENT sum = 0 NEW_LINE count = 0 NEW_LINE while ( len ( pq ) > 0 and sum < K ) : NEW_LINE INDENT sum += pq [ 0 ] NEW_LINE pq . pop ( ) NEW_LINE count += 1 NEW_LINE DEDENT if ( sum < K ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT v = [ 2 , 3 , 1 , 5 , 6 , 3 , 7 , 9 , 14 , 10 , 2 , 5 ] NEW_LINE K = 35 NEW_LINE print ( lengthOfSmallestSubsequence ( K , v ) ) NEW_LINE DEDENT"],"references":["def lengthOfSmallestSubsequence ( K , v ) : NEW_LINE INDENT pq = [ ] NEW_LINE for i in v : NEW_LINE INDENT pq . append ( i ) NEW_LINE DEDENT pq . sort ( ) NEW_LINE sum = 0 NEW_LINE count = 0 NEW_LINE while ( len ( pq ) > 0 and sum < K ) : NEW_LINE INDENT sum += pq [ - 1 ] NEW_LINE del pq [ - 1 ] NEW_LINE count += 1 NEW_LINE DEDENT if ( sum < K ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return count NEW_LINE DEDENT v = [ 2 , 3 , 1 , 5 , 6 , 3 , 7 , 9 , 14 , 10 , 2 , 5 ] NEW_LINE K = 35 NEW_LINE print ( lengthOfSmallestSubsequence ( K , v ) ) NEW_LINE"],"bleu":0.7606016453654195,"rouge_l":0.8689848569826135}
{"id":854,"predictions":["def search ( arr , n , x ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( arr [ i ] == x ) : NEW_LINE INDENT return i NEW_LINE DEDENT i = i + abs ( arr [ i ] - x ) NEW_LINE DEDENT i = i + abs ( arr [ i ] - x ) NEW_LINE DEDENT print ( \" number ▁ is ▁ not ▁ present ! \" ) NEW_LINE return - 1 NEW_LINE DEDENT arr = [ 8 , 7 , 6 , 7 , 6 , 5 , 4 , 3 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE x = 3 NEW_LINE print ( \" number ▁ is ▁ present ▁ at ▁ index \" , search ( arr , n , 3 ) ) NEW_LINE"],"references":["def search ( arr , n , x ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( arr [ i ] == x ) : NEW_LINE INDENT return i NEW_LINE DEDENT i = i + abs ( arr [ i ] - x ) NEW_LINE DEDENT print ( \" number ▁ is ▁ not ▁ present ! \" ) NEW_LINE return - 1 NEW_LINE DEDENT arr = [ 8 , 7 , 6 , 7 , 6 , 5 , 4 , 3 , 2 , 3 , 4 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE x = 3 NEW_LINE print ( \" Element \" , x , \" ▁ is ▁ present ▁ at ▁ index ▁ \" , search ( arr , n , 3 ) ) NEW_LINE"],"bleu":0.8716558221514289,"rouge_l":0.9106521495117299}
{"id":855,"predictions":["def CheckArray ( arr , n ) : NEW_LINE INDENT prod = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT prod *= arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == prod \/\/ arr [ i ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT arr = [ 1 , 2 , 12 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE if ( CheckArray ( arr , n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"],"references":["def CheckArray ( arr , n ) : NEW_LINE INDENT prod = 1 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT prod *= arr [ i ] NEW_LINE DEDENT for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( arr [ i ] == prod \/ arr [ i ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 12 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE if ( CheckArray ( arr , n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.7737604537810684,"rouge_l":0.8956319588890249}
{"id":856,"predictions":["def minRemove ( arr , n ) : NEW_LINE INDENT LIS = [ 0 for i in range ( n ) ] NEW_LINE len = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT LIS [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) : NEW_LINE INDENT LIS [ i ] = max ( LIS [ i ] , LIS [ j ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT return n - lIS [ i ] NEW_LINE DEDENT arr = [ 1 , 2 , 6 , 5 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minRemove ( arr , n ) ) NEW_LINE"],"references":["def minRemove ( arr , n ) : NEW_LINE INDENT LIS = [ 0 for i in range ( n ) ] NEW_LINE len = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT LIS [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) : NEW_LINE INDENT LIS [ i ] = max ( LIS [ i ] , LIS [ j ] + 1 ) NEW_LINE DEDENT DEDENT len = max ( len , LIS [ i ] ) NEW_LINE DEDENT return ( n - len ) NEW_LINE DEDENT arr = [ 1 , 2 , 6 , 5 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minRemove ( arr , n ) ) NEW_LINE"],"bleu":0.8969237891530738,"rouge_l":0.9380984621336687}
{"id":857,"predictions":["import sys NEW_LINE def charVal ( s , i ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( s [ i ] == '1' ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 NEW_LINE DEDENT DEDENT def countMinimalReplacements ( s , i , prev , dp , n ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ prev ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ prev ] NEW_LINE DEDENT val = strVal ( s , i ) NEW_LINE ans = sys . maxsize NEW_LINE if ( val == prev ) : NEW_LINE INDENT val = 0 NEW_LINE for cur in range ( 2 , 2 + 1 , cur , dp , n ) : NEW_LINE INDENT if ( cur == prev ) : NEW_LINE INDENT continue NEW_LINE DEDENT val = 1 NEW_LINE for cur in range ( 2 ) : NEW_LINE INDENT if ( cur == prev ) : NEW_LINE INDENT continue NEW_LINE DEDENT val = 1 + countMinimalReplacements ( s , i + 1 , cur , dp , n ) NEW_LINE ans = min ( ans , val , dp , n ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT ans = countMinimalReplacements ( s , 0 ) NEW_LINE DEDENT dp [ i ] [ val ] = ans NEW_LINE return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \"201220211\" NEW_LINE n = len ( s ) NEW_LINE print ( countMinimalReplacements ( s , 1 , val , dp , dp , n ) ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE def charVal ( s , i ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( s [ i ] == '1' ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 NEW_LINE DEDENT DEDENT def countMinimalReplacements ( s , i , prev , dp , n ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ prev ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ prev ] NEW_LINE DEDENT val = charVal ( s , i ) NEW_LINE ans = sys . maxsize NEW_LINE if ( val == prev ) : NEW_LINE INDENT val = 0 NEW_LINE for cur in range ( 3 ) : NEW_LINE INDENT if ( cur == prev ) : NEW_LINE INDENT continue NEW_LINE DEDENT val = 1 + countMinimalReplacements ( s , i + 1 , cur , dp , n ) NEW_LINE ans = min ( ans , val ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT ans = countMinimalReplacements ( s , i + 1 , val , dp , n ) NEW_LINE DEDENT dp [ i ] [ val ] = ans NEW_LINE return dp [ i ] [ val ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \"201220211\" NEW_LINE n = len ( s ) NEW_LINE dp = [ [ - 1 for i in range ( 3 ) ] for i in range ( n ) ] NEW_LINE val = charVal ( s , 0 ) NEW_LINE print ( countMinimalReplacements ( s , 1 , val , dp , n ) ) NEW_LINE DEDENT"],"bleu":0.8387653510603088,"rouge_l":0.833441769681197}
{"id":858,"predictions":["defountPercentage ( S , M ) : NEW_LINE INDENT disp = M - S NEW_LINE disPercent = ( ( WP \/ M ) * 100 NEW_LINE return ( rep % . D ) NEW_LINE DEDENT if __name__ == ' _ main _ _ ' : NEW_LINE INDENT M = 120 NEW_LINE S = 100 NEW_LINE print ( \" % .2f \" ) NEW_LINE M = 1000 NEW_LINE S = 1000 NEW_LINE print ( \" % . \" ) NEW_LINE print ( \" % . \" ) NEW_LINE DEDENT"],"references":["def discountPercentage ( S , M ) : NEW_LINE INDENT discount = M - S NEW_LINE disPercent = ( discount \/ M ) * 100 NEW_LINE return disPercent NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT M = 120 NEW_LINE S = 100 NEW_LINE print ( discountPercentage ( S , M ) , \" % \" ) NEW_LINE M = 1000 NEW_LINE S = 500 NEW_LINE print ( discountPercentage ( S , M ) , \" % \" ) NEW_LINE DEDENT"],"bleu":0.6177581952914084,"rouge_l":0.7727272727272727}
{"id":859,"predictions":["import math NEW_LINE def sumOfSeries ( n ) : NEW_LINE INDENT return ( 0.6172 * ( pow ( 10 , n ) - 1 ) - 0.55 * n ) NEW_LINE DEDENT n = 2 NEW_LINE print ( sumOfSeries ( n ) ) NEW_LINE"],"references":["def sumOfSeries ( n ) : NEW_LINE INDENT return ( int ) ( 0.6172 * ( pow ( 10 , n ) - 1 ) - 0.55 * n ) NEW_LINE DEDENT n = 2 NEW_LINE print ( sumOfSeries ( n ) ) NEW_LINE"],"bleu":0.9130175707729784,"rouge_l":0.9318181818181817}
{"id":860,"predictions":["def Move ( a , x , b ) : NEW_LINE INDENT if ( ( ( b - a ) % x == 0 ) or ( ( b - a - 1 ) % x == 0 ) and b >= a ) and b >= a : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT a = 3 NEW_LINE x = 2 NEW_LINE b = 7 NEW_LINE if ( Move ( a , x , b ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def Move ( a , x , b ) : NEW_LINE INDENT if ( ( ( ( b - a ) % x == 0 ) or ( ( b - a - 1 ) % x == 0 ) and a + 1 != b ) and b >= a ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 3 NEW_LINE x = 2 NEW_LINE b = 7 NEW_LINE if ( Move ( a , x , b ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.7911706632439238,"rouge_l":0.8908265986105203}
{"id":861,"predictions":["def No_of_Pairs ( N ) : NEW_LINE INDENT i = 1 NEW_LINE while ( ( i * i * i ) + ( 2 * i ) + i <= N ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT return ( i - 1 ) NEW_LINE DEDENT def print_pairs ( pairs ) : NEW_LINE INDENT i = 1 NEW_LINE mul = 0 NEW_LINE for i in range ( 1 , pairs + 1 ) : NEW_LINE INDENT mul = i * ( i + 1 ) NEW_LINE print ( \" Pair ▁ \" , i , \" ▁ - - > ▁ \" , mul * ( i + 1 ) , \" ) \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 5 NEW_LINE pairs = N_Of_Pairs ( N ) NEW_LINE print ( \" No . \" ) NEW_LINE print_pairs ( pairs ) NEW_LINE print_pairs ( pairs ) NEW_LINE DEDENT"],"references":["def No_Of_Pairs ( N ) : NEW_LINE INDENT i = 1 ; NEW_LINE while ( ( i * i * i ) + ( 2 * i * i ) + i <= N ) : NEW_LINE INDENT i += 1 ; NEW_LINE DEDENT return ( i - 1 ) ; NEW_LINE DEDENT def print_pairs ( pairs ) : NEW_LINE INDENT i = 1 ; NEW_LINE mul = 0 ; NEW_LINE for i in range ( 1 , pairs + 1 ) : NEW_LINE INDENT mul = i * ( i + 1 ) ; NEW_LINE print ( \" Pair ▁ no . \" , i , \" ▁ - - > ▁ ( \" , ( mul * i ) , \" , ▁ \" , mul * ( i + 1 ) , \" ) \" ) ; NEW_LINE DEDENT DEDENT N = 500 ; NEW_LINE i = 1 ; NEW_LINE pairs = No_Of_Pairs ( N ) ; NEW_LINE print ( \" No . ▁ of ▁ pairs ▁ = ▁ \" , pairs ) ; NEW_LINE print_pairs ( pairs ) ; NEW_LINE"],"bleu":0.6348731712875318,"rouge_l":0.8068933395435492}
{"id":862,"predictions":["def power ( x , a ) : NEW_LINE INDENT res = 1 NEW_LINE while ( a ) : NEW_LINE INDENT if ( a & 1 ) : NEW_LINE INDENT res = res * x NEW_LINE DEDENT x = x * x NEW_LINE a >>= 1 NEW_LINE DEDENT return res NEW_LINE DEDENT def breakInteger ( N ) : NEW_LINE INDENT if ( N == 2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( N == 3 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT maxProduct = - 1 NEW_LINE if ( N % 3 == 1 ) : NEW_LINE INDENT maxProduct = power ( 3 , N \/\/ 3 ) NEW_LINE DEDENT elif ( N % 3 ) == 1 : NEW_LINE INDENT maxProduct = 2 * power ( 3 , ( N \/\/ 3 ) - 1 ) NEW_LINE DEDENT return maxProduct NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT maxProduct = break NEW_LINE print ( maxProduct ) NEW_LINE DEDENT"],"references":["def power ( x , a ) : NEW_LINE INDENT res = 1 ; NEW_LINE while ( a ) : NEW_LINE INDENT if ( a & 1 ) : NEW_LINE INDENT res = res * x ; NEW_LINE DEDENT x = x * x ; NEW_LINE a >>= 1 ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT def breakInteger ( N ) : NEW_LINE INDENT if ( N == 2 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT if ( N == 3 ) : NEW_LINE INDENT return 2 ; NEW_LINE DEDENT maxProduct = 0 ; NEW_LINE if ( N % 3 == 0 ) : NEW_LINE INDENT maxProduct = power ( 3 , int ( N \/ 3 ) ) ; NEW_LINE return maxProduct ; NEW_LINE DEDENT elif ( N % 3 == 1 ) : NEW_LINE INDENT maxProduct = 2 * 2 * power ( 3 , int ( N \/ 3 ) - 1 ) ; NEW_LINE return maxProduct ; NEW_LINE DEDENT elif ( N % 3 == 2 ) : NEW_LINE INDENT maxProduct = 2 * power ( 3 , int ( N \/ 3 ) ) ; NEW_LINE return maxProduct ; NEW_LINE DEDENT DEDENT maxProduct = breakInteger ( 10 ) ; NEW_LINE print ( maxProduct ) ; NEW_LINE"],"bleu":0.5584313249423931,"rouge_l":0.7756399531537561}
{"id":863,"predictions":["def printTrib ( n ) : NEW_LINE INDENT dp = [ 0 ] * n NEW_LINE dp [ 0 ] = 0 NEW_LINE dp [ 2 ] = 1 NEW_LINE dp [ 2 ] = 1 NEW_LINE for i in range ( 3 , n ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + dp [ i - 3 ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( dp [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT n = 10 NEW_LINE printTrib ( n ) NEW_LINE"],"references":["def printTrib ( n ) : NEW_LINE INDENT dp = [ 0 ] * n NEW_LINE dp [ 0 ] = dp [ 1 ] = 0 ; NEW_LINE dp [ 2 ] = 1 ; NEW_LINE for i in range ( 3 , n ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + dp [ i - 3 ] ; NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( dp [ i ] , \" ▁ \" , end = \" \" ) NEW_LINE DEDENT DEDENT n = 10 NEW_LINE printTrib ( n ) NEW_LINE"],"bleu":0.8248961385570526,"rouge_l":0.9254329469013883}
{"id":864,"predictions":["def findCount ( d ) : NEW_LINE INDENT return 9 * ( pow ( 10 , d - 1 ) ) - int ( pow ( d , d - 1 ) ) ) NEW_LINE DEDENT d = 1 NEW_LINE print ( findCount ( d ) ) NEW_LINE d = 2 NEW_LINE print ( findCount ( d ) ) NEW_LINE d = 4 NEW_LINE print ( findCount ( d ) ) NEW_LINE"],"references":["import math NEW_LINE def findCount ( d ) : NEW_LINE INDENT return 9 * ( ( int ) ( math . pow ( 10 , d - 1 ) ) - ( int ) ( math . pow ( 9 , d - 1 ) ) ) ; NEW_LINE DEDENT d = 1 NEW_LINE print ( findCount ( d ) ) NEW_LINE d = 2 NEW_LINE print ( findCount ( d ) ) NEW_LINE d = 4 NEW_LINE print ( findCount ( d ) ) NEW_LINE"],"bleu":0.7251823026602808,"rouge_l":0.8845996732026143}
{"id":865,"predictions":["def Convert ( n ) : NEW_LINE INDENT return ( n - 32.0 ) * 5.0 NEW_LINE DEDENT n = 40 NEW_LINE print ( Convert ( n ) ) NEW_LINE"],"references":["def Conversion ( n ) : NEW_LINE INDENT return ( n - 32.0 ) * 5.0 \/ 9.0 NEW_LINE DEDENT n = 40 NEW_LINE x = Conversion ( n ) NEW_LINE print ( x ) NEW_LINE"],"bleu":0.5861312599339497,"rouge_l":0.7751710654936461}
{"id":866,"predictions":["def isPalin ( string ) : NEW_LINE INDENT l = len ( string ) \/\/ 2 NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( string [ i ] != string [ len ( string ) - i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def palindromicPath ( string , a , i , j , m , n ) : NEW_LINE INDENT if ( j < m - 1 or i < n - 1 ) : NEW_LINE INDENT if ( i < n - 1 ) : NEW_LINE INDENT if ( i < n - 1 ) : NEW_LINE INDENT palindromic ( string + a [ i ] [ j ] , a , i + 1 , j , m , n ) NEW_LINE DEDENT if ( j < m - 1 ) : NEW_LINE INDENT palindromic ( string + a [ i ] [ j ] , a , i , j + 1 , m , n ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT string = string + a [ n - 1 ] [ m - 1 ] NEW_LINE if ( isPalin ( string ) ) : NEW_LINE INDENT print ( string ) NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT string = string + a [ n - 1 ] [ m - 1 ] NEW_LINE if ( isPalin ( string ) ) : NEW_LINE INDENT print ( string ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ \" : NEW_LINE INDENT arr = [ [ ' a ' , ' a ' , ' a ' , ' a ' , ' a ' , ' b ' ] , [ ' b ' , ' a ' , ' a ' , ' a ' ] , [ ' b ' , ' a ' , ' a ' , ' a ' ] ] NEW_LINE string = \" \" NEW_LINE palindromicPath ( string , 0 , 0 , 4 , 4 , 3 ) NEW_LINE DEDENT"],"references":["def isPalin ( str ) : NEW_LINE INDENT l = len ( str ) \/\/ 2 NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( str [ i ] != str [ len ( str ) - i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def palindromicPath ( str , a , i , j , m , n ) : NEW_LINE INDENT if ( j < m - 1 or i < n - 1 ) : NEW_LINE INDENT if ( i < n - 1 ) : NEW_LINE INDENT palindromicPath ( str + a [ i ] [ j ] , a , i + 1 , j , m , n ) NEW_LINE DEDENT if ( j < m - 1 ) : NEW_LINE INDENT palindromicPath ( str + a [ i ] [ j ] , a , i , j + 1 , m , n ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT str = str + a [ n - 1 ] [ m - 1 ] NEW_LINE if isPalin ( str ) : NEW_LINE INDENT print ( str ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ [ ' a ' , ' a ' , ' a ' , ' b ' ] , [ ' b ' , ' a ' , ' a ' , ' a ' ] , [ ' a ' , ' b ' , ' b ' , ' a ' ] ] NEW_LINE str = \" \" NEW_LINE palindromicPath ( str , arr , 0 , 0 , 4 , 3 ) NEW_LINE DEDENT"],"bleu":0.6998413345335056,"rouge_l":0.855767753827249}
{"id":867,"predictions":["def checkDivisors ( a , n ) : NEW_LINE INDENT X = max ( a ) NEW_LINE b = [ ] NEW_LINE for i in range ( 1 , int ( sqrt ( X ) ) + 1 ) : NEW_LINE INDENT if ( X % i == 0 ) : NEW_LINE INDENT b . append ( i ) NEW_LINE if ( X \/\/ i != i ) : NEW_LINE INDENT b . append ( X \/\/ i ) NEW_LINE DEDENT DEDENT DEDENT if ( len ( b ) != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( b [ i ] != a [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( b [ i ] != a [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 8 , 1 , 2 , 12 , 48 , 4 , 24 , 16 , 16 , 16 , 16 ] NEW_LINE N = len ( arr ) NEW_LINE if ( checkDivisors ( arr , N ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["from math import sqrt NEW_LINE def checkDivisors ( a , n ) : NEW_LINE INDENT X = max ( a ) NEW_LINE b = [ ] NEW_LINE for i in range ( 1 , int ( sqrt ( X ) ) + 1 ) : NEW_LINE INDENT if ( X % i == 0 ) : NEW_LINE INDENT b . append ( i ) NEW_LINE if ( X \/\/ i != i ) : NEW_LINE INDENT b . append ( X \/\/ i ) NEW_LINE DEDENT DEDENT DEDENT if ( len ( b ) != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT a . sort ( reverse = False ) NEW_LINE b . sort ( reverse = False ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( b [ i ] != a [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 8 , 1 , 2 , 12 , 48 , 6 , 4 , 24 , 16 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE if ( checkDivisors ( arr , N ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.786549613128146,"rouge_l":0.8842931240856496}
{"id":868,"predictions":["def printAllAPAPTriplets ( arr , n ) : NEW_LINE INDENT s = [ ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT diff = arr [ j ] - arr [ i ] NEW_LINE exists = s . keys ( ) NEW_LINE if ( arr [ i ] - diff ) : NEW_LINE INDENT print ( arr [ i ] - diff , \" ▁ \" , arr [ i ] , \" ▁ \" , arr [ j ] ) NEW_LINE DEDENT DEDENT s . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 6 , 9 , 10 , 12 , 12 , 15 , 30 , 30 , 40 ] NEW_LINE n = len ( arr ) NEW_LINE printAllAPTriplets ( arr , n ) NEW_LINE DEDENT"],"references":["def printAllAPTriplets ( arr , n ) : NEW_LINE INDENT s = [ ] ; NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT diff = arr [ j ] - arr [ i ] ; NEW_LINE if ( ( arr [ i ] - diff ) in arr ) : NEW_LINE INDENT print ( \" { } ▁ { } ▁ { } \" . format ( ( arr [ i ] - diff ) , arr [ i ] , arr [ j ] ) , end = \" \\n \" ) ; NEW_LINE DEDENT DEDENT DEDENT s . append ( arr [ i ] ) ; NEW_LINE DEDENT arr = [ 2 , 6 , 9 , 12 , 17 , 22 , 31 , 32 , 35 , 42 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE printAllAPTriplets ( arr , n ) ; NEW_LINE"],"bleu":0.6242149718792666,"rouge_l":0.7513471901462664}
{"id":869,"predictions":["def isPowerOfTwo ( x ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( ( x & ( x - 1 ) ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def countNum ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( isPowerOfTwo ( a [ i ] ) or isPowerOfTwo ( a [ i ] + 1 ) ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 5 , 6 , 9 , 3 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countNum ( arr , n ) ) NEW_LINE"],"references":["def isPowerOfTwo ( x ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( ( x & ( x - 1 ) ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def countNum ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( isPowerOfTwo ( a [ i ] ) or isPowerOfTwo ( a [ i ] + 1 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 6 , 9 , 3 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countNum ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.8535541074121138,"rouge_l":0.9264641608391609}
{"id":870,"predictions":["import math NEW_LINE pi = 3.14159 NEW_LINE def volume ( r ) : NEW_LINE INDENT vol = ( 4 \/ 3 ) * ( pi * r * r * r ) NEW_LINE return vol NEW_LINE DEDENT def surface_area ( r ) : NEW_LINE INDENT er_ar = 4 NEW_LINE gr_ar = 4 * pi * r * r NEW_LINE return sur_ar NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT radius = 12 NEW_LINE vol = volume ( radius ) NEW_LINE vol = volume ( radius ) NEW_LINE vol_area = surface_area ( radius ) NEW_LINE print ( \" Volume ▁ Of ▁ Surface ▁ : \" , vol ) NEW_LINE print ( \" Volume ▁ Of ▁ Area ▁ Of ▁ : \" , vol ) NEW_LINE print ( \" Surface ▁ Area ▁ Of ▁ Area ▁ Of ▁ Area ▁ of ▁ Surface ▁ : \" , Sur_area ) NEW_LINE DEDENT"],"references":["import math NEW_LINE pi = math . pi NEW_LINE def volume ( r ) : NEW_LINE INDENT vol = ( 4 \/ 3 ) * pi * r * r * r NEW_LINE return vol NEW_LINE DEDENT def surfacearea ( r ) : NEW_LINE INDENT sur_ar = 4 * pi * r * r NEW_LINE return sur_ar NEW_LINE DEDENT radius = float ( 12 ) NEW_LINE print ( \" Volume ▁ Of ▁ Sphere ▁ : ▁ \" , volume ( radius ) ) NEW_LINE print ( \" Surface ▁ Area ▁ Of ▁ Sphere ▁ : ▁ \" , surfacearea ( radius ) ) NEW_LINE"],"bleu":0.44453961219007626,"rouge_l":0.6890001283532282}
{"id":871,"predictions":["def isPower ( 10 , 1 ) : NEW_LINE INDENT if ( x == 1 ) : NEW_LINE INDENT return ( y == 1 ) NEW_LINE DEDENT if ( x == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( isPower ( 2 , 30 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT def isPower ( x , y ) : NEW_LINE INDENT if x == 1 : NEW_LINE INDENT return ( y == 1 ) NEW_LINE DEDENT if ( x == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT pow = 1 NEW_LINE while ( pow < y ) : NEW_LINE INDENT pow = pow * x NEW_LINE DEDENT return ( pow == y ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( isPower ( 10 , 1 ) ) NEW_LINE if ( isPower ( x , y ) ) : NEW_LINE INDENT print ( x ) NEW_LINE DEDENT DEDENT"],"references":["def isPower ( x , y ) : NEW_LINE INDENT if ( x == 1 ) : NEW_LINE INDENT return ( y == 1 ) NEW_LINE DEDENT pow = 1 NEW_LINE while ( pow < y ) : NEW_LINE INDENT pow = pow * x NEW_LINE DEDENT return ( pow == y ) NEW_LINE DEDENT if ( isPower ( 10 , 1 ) ) : print ( \" True \" ) NEW_LINE else : print ( \" False \" ) NEW_LINE if ( isPower ( 1 , 20 ) ) : print ( \" True \" ) NEW_LINE else : print ( \" False \" ) NEW_LINE if ( isPower ( 2 , 128 ) ) : print ( \" True \" ) NEW_LINE else : print ( \" False \" ) NEW_LINE if ( isPower ( 2 , 30 ) ) : print ( \" True \" ) NEW_LINE else : print ( \" False \" ) NEW_LINE"],"bleu":0.5190140119959685,"rouge_l":0.49548177479947203}
{"id":872,"predictions":["def getSum ( BITree , index ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( index > 0 ) : NEW_LINE INDENT sum += BIT [ index ] NEW_LINE index -= index ** ( - index ) NEW_LINE DEDENT return sum NEW_LINE DEDENT def updateBit ( BITTree , n , index , val ) : NEW_LINE INDENT while ( index <= n ) : NEW_LINE INDENT BITree [ index ] += val NEW_LINE index += index & ( - index ) NEW_LINE DEDENT DEDENT def getInvCount ( arr , n ) : NEW_LINE INDENT invcount = 0 NEW_LINE maxElement = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( maxElement < arr [ i ] ) : NEW_LINE INDENT maxElement = arr [ i ] NEW_LINE DEDENT DEDENT BIT = [ 0 ] * ( maxElement + 1 ) NEW_LINE for i in range ( 1 , maxElement + 1 ) : NEW_LINE INDENT if ( maxElement < arr [ i ] ) : NEW_LINE INDENT maxElement = arr [ i ] NEW_LINE DEDENT updateBIT ( BIT , arr [ i ] - 1 ) NEW_LINE DEDENT return invcount NEW_LINE DEDENT arr = [ 8 , 4 , 2 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Number ▁ of ▁ inversions ▁ are ▁ : \" , getInvCount ( arr , n ) ) NEW_LINE"],"references":["def getSum ( BITree , index ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( index > 0 ) : NEW_LINE INDENT sum += BITree [ index ] NEW_LINE index -= index & ( - index ) NEW_LINE DEDENT return sum NEW_LINE DEDENT def updateBIT ( BITree , n , index , val ) : NEW_LINE INDENT while ( index <= n ) : NEW_LINE INDENT BITree [ index ] += val NEW_LINE index += index & ( - index ) NEW_LINE DEDENT DEDENT def getInvCount ( arr , n ) : NEW_LINE INDENT invcount = 0 NEW_LINE maxElement = max ( arr ) NEW_LINE BIT = [ 0 ] * ( maxElement + 1 ) NEW_LINE for i in range ( 1 , maxElement + 1 ) : NEW_LINE INDENT BIT [ i ] = 0 NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT invcount += getSum ( BIT , arr [ i ] - 1 ) NEW_LINE updateBIT ( BIT , maxElement , arr [ i ] , 1 ) NEW_LINE DEDENT return invcount NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 8 , 4 , 2 , 1 ] NEW_LINE n = 4 NEW_LINE print ( \" Inversion ▁ Count ▁ : ▁ \" , getInvCount ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.7249929411758699,"rouge_l":0.775}
{"id":873,"predictions":["def calSum ( n ) : NEW_LINE INDENT a = 3 NEW_LINE b = 0 NEW_LINE c = 2 NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return 3 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 3 NEW_LINE DEDENT sum = 5 NEW_LINE while ( n > 2 ) : NEW_LINE INDENT d = a + b NEW_LINE sum += d NEW_LINE a = b NEW_LINE b = c NEW_LINE n -= 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 9 NEW_LINE print ( calSum ( n ) ) NEW_LINE"],"references":["def calSum ( n ) : NEW_LINE INDENT a = 3 NEW_LINE b = 0 NEW_LINE c = 2 NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return 3 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 3 NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return 5 NEW_LINE DEDENT sum = 5 NEW_LINE while ( n > 2 ) : NEW_LINE INDENT d = a + b NEW_LINE sum = sum + d NEW_LINE a = b NEW_LINE b = c NEW_LINE c = d NEW_LINE n = n - 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 9 NEW_LINE print ( calSum ( n ) ) NEW_LINE"],"bleu":0.7587889092938915,"rouge_l":0.8696168696168697}
{"id":874,"predictions":["import sys NEW_LINE def steps ( cur , x , n ) : NEW_LINE INDENT if x == 0 : NEW_LINE INDENT return sys . maxsize NEW_LINE DEDENT if x > 0 : NEW_LINE INDENT return abs ( ( n - cur ) \/\/ x ) NEW_LINE DEDENT else : NEW_LINE INDENT return abs ( ( cur - 1 ) \/\/ x ) NEW_LINE DEDENT DEDENT def countSteps ( curx , cury , n , m , moves ) : NEW_LINE INDENT count = 0 NEW_LINE k = len ( steps ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT x = moves [ i ] [ 0 ] NEW_LINE y = moves [ i ] [ 1 ] NEW_LINE stepct = min ( steps ( curx , x , n ) , steps ( cury , y , m ) ) ) NEW_LINE count += stepct * x NEW_LINE curx += stepct * x NEW_LINE cury += stepct * x NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 NEW_LINE m = 5 NEW_LINE x = 1 NEW_LINE y = 1 NEW_LINE moves = [ [ 1 , 1 ] , [ 1 , 1 ] , [ 0 , - 2 ] ] NEW_LINE print ( countSteps ( x , y , n , m , moves ) ) NEW_LINE DEDENT"],"references":["def steps ( cur , x , n ) : NEW_LINE INDENT if x == 0 : NEW_LINE INDENT return float ( ' inf ' ) NEW_LINE DEDENT elif x > 0 : NEW_LINE INDENT return abs ( ( n - cur ) \/\/ x ) NEW_LINE DEDENT else : NEW_LINE INDENT return abs ( int ( ( cur - 1 ) \/ x ) ) NEW_LINE DEDENT DEDENT def countSteps ( curx , cury , n , m , moves ) : NEW_LINE INDENT count = 0 NEW_LINE k = len ( moves ) NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT x = moves [ i ] [ 0 ] NEW_LINE y = moves [ i ] [ 1 ] NEW_LINE stepct = min ( steps ( curx , x , n ) , steps ( cury , y , m ) ) NEW_LINE count += stepct NEW_LINE curx += stepct * x NEW_LINE cury += stepct * y NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n , m , x , y = 4 , 5 , 1 , 1 NEW_LINE moves = [ [ 1 , 1 ] , [ 1 , 1 ] , [ 0 , - 2 ] ] NEW_LINE print ( countSteps ( x , y , n , m , moves ) ) NEW_LINE DEDENT"],"bleu":0.8378014172855364,"rouge_l":0.9034878165312948}
{"id":875,"predictions":["def SUM ( n , m ) : NEW_LINE INDENT if ( m == 1 ) : NEW_LINE INDENT return ( n * ( n + 1 ) \/ 2 ) NEW_LINE DEDENT sum = SUM ( n , m - 1 ) NEW_LINE return ( sum * ( sum + 1 ) \/ 2 ) NEW_LINE DEDENT n = 5 NEW_LINE m = 3 NEW_LINE print ( \" SUM ( \" , n , \" , \" , m , \" ) ) NEW_LINE"],"references":["def SUM ( n , m ) : NEW_LINE INDENT if ( m == 1 ) : NEW_LINE INDENT return ( n * ( n + 1 ) \/ 2 ) NEW_LINE DEDENT sum = SUM ( n , m - 1 ) NEW_LINE return int ( sum * ( sum + 1 ) \/ 2 ) NEW_LINE DEDENT n = 5 NEW_LINE m = 3 NEW_LINE print ( \" SUM ( \" , n , \" , ▁ \" , m , \" ) : \" , SUM ( n , m ) ) NEW_LINE"],"bleu":0.8385804249622741,"rouge_l":0.929044974018993}
{"id":876,"predictions":["def printInitials ( str ) : NEW_LINE INDENT l = len ( str ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( str [ i ] != ' ▁ ' ) : NEW_LINE INDENT str = str ( str [ i ] ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT str = \" \" NEW_LINE for i in str : NEW_LINE INDENT if ( str [ i ] != ' ▁ ' ) : NEW_LINE INDENT str += str [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT str += str [ i ] NEW_LINE DEDENT DEDENT print ( str ) NEW_LINE DEDENT DEDENT if __name__ == \" _ main _ _ \" : NEW_LINE INDENT str = \" ihita ▁ bh \" NEW_LINE print ( str ) NEW_LINE DEDENT"],"references":["def printInitials ( string : str ) : NEW_LINE INDENT length = len ( string ) NEW_LINE string . strip ( ) NEW_LINE t = \" \" NEW_LINE for i in range ( length ) : NEW_LINE INDENT ch = string [ i ] NEW_LINE if ch != ' ▁ ' : NEW_LINE INDENT t += ch NEW_LINE DEDENT else : NEW_LINE INDENT print ( t [ 0 ] . upper ( ) + \" . ▁ \" , end = \" \" ) NEW_LINE t = \" \" NEW_LINE DEDENT DEDENT temp = \" \" NEW_LINE for j in range ( len ( t ) ) : NEW_LINE INDENT if j == 0 : NEW_LINE INDENT temp += t [ 0 ] . upper ( ) NEW_LINE DEDENT else : NEW_LINE INDENT temp += t [ j ] . lower ( ) NEW_LINE DEDENT DEDENT print ( temp ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" ishita ▁ bhuiya \" NEW_LINE printInitials ( string ) NEW_LINE DEDENT"],"bleu":0.30867115317225763,"rouge_l":0.5777574091047968}
{"id":877,"predictions":["def check ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return ( ( st [ 0 ] - '0' ) % 8 == 0 ) NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return ( ( ( st [ n - 2 ] - ord ( '0' ) ) % 10 == 0 ) NEW_LINE DEDENT last = ( int ) ( st [ n - 1 ] ) - ord ( '0' ) NEW_LINE second_last = ( st [ n - 2 ] ) - ord ( st [ n - 1 ] ) ) % 8 == 0 ) NEW_LINE return ( ( third_last * 100 + second_last * 10 + last ) % 8 == 0 ) NEW_LINE DEDENT st = \"76952\" NEW_LINE if ( check ( st ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def check ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return ( ( int ) ( st [ 0 ] ) % 8 == 0 ) NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return ( ( int ) ( st [ n - 2 ] ) * 10 + ( ( int ) ( str [ n - 1 ] ) % 8 == 0 ) ) NEW_LINE DEDENT last = ( int ) ( st [ n - 1 ] ) NEW_LINE second_last = ( int ) ( st [ n - 2 ] ) NEW_LINE third_last = ( int ) ( st [ n - 3 ] ) NEW_LINE return ( ( third_last * 100 + second_last * 10 + last ) % 8 == 0 ) NEW_LINE DEDENT st = \"76952\" NEW_LINE if ( check ( st ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No ▁ \" ) NEW_LINE DEDENT"],"bleu":0.7935290317164598,"rouge_l":0.8623743825583376}
{"id":878,"predictions":["import math NEW_LINE def check ( n ) : NEW_LINE INDENT d = math . sqrt ( n ) NEW_LINE if ( d * d == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def largestNonPerfectSquareNumber ( a , n ) : NEW_LINE INDENT maxi = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( check ( a [ i ] ) == False ) : NEW_LINE INDENT maxi = max ( a [ i ] , maxi ) NEW_LINE DEDENT DEDENT return maxi NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 16 , 20 , 25 , 2 , 3 , 10 ] NEW_LINE n = len ( a ) NEW_LINE print ( largestNonPerfectSquareNumber ( a , n ) ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def check ( n ) : NEW_LINE INDENT d = int ( math . sqrt ( n ) ) NEW_LINE if ( d * d == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def largestNonPerfectSquareNumber ( a , n ) : NEW_LINE INDENT maxi = - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( check ( a [ i ] ) == False ) : NEW_LINE INDENT maxi = max ( a [ i ] , maxi ) NEW_LINE DEDENT DEDENT return maxi NEW_LINE DEDENT a = [ 16 , 20 , 25 , 2 , 3 , 10 ] NEW_LINE n = len ( a ) NEW_LINE print ( largestNonPerfectSquareNumber ( a , n ) ) NEW_LINE"],"bleu":0.8651002912178501,"rouge_l":0.9373522458628841}
{"id":879,"predictions":["def findValueAtX ( n ) : NEW_LINE INDENT return ( n * n * n ) + n NEW_LINE DEDENT print ( findValueAtX ( 10 ) ) NEW_LINE print ( findValueAtX ( 2 ) ) NEW_LINE"],"references":["def findValueAtX ( n ) : NEW_LINE INDENT return ( n * n * n ) + n NEW_LINE DEDENT print ( findValueAtX ( 10 ) ) NEW_LINE print ( findValueAtX ( 2 ) ) NEW_LINE"],"bleu":1.0,"rouge_l":1.0}
{"id":880,"predictions":["from math import sqrt NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * sqrt ( n ) ) <= sqrt ( i + 2 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT def isThreeDectFactors ( n ) : NEW_LINE INDENT sq = int ( sqrt ( n ) ) NEW_LINE if ( 1L * sq != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT return isPrime ( sq ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT num = 9 NEW_LINE if ( isThreeDectFactors ( num ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT num = 15 NEW_LINE if ( isThreeDistctors ( num ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT num = 15 NEW_LINE if ( isThreeDectors ( num ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["from math import sqrt NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT k = int ( sqrt ( n ) ) + 1 NEW_LINE for i in range ( 5 , k , 6 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def isThreeDisctFactors ( n ) : NEW_LINE INDENT sq = int ( sqrt ( n ) ) NEW_LINE if ( 1 * sq * sq != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( isPrime ( sq ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT num = 9 NEW_LINE if ( isThreeDisctFactors ( num ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT num = 15 NEW_LINE if ( isThreeDisctFactors ( num ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT num = 12397923568441 NEW_LINE if ( isThreeDisctFactors ( num ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.7861400554746859,"rouge_l":0.8772162864568293}
{"id":881,"predictions":["def maxPartitions ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE max_so_far = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT max_so_far = max ( max_so_far , arr [ i ] ) NEW_LINE if ( max_so_far == i ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 0 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxPartitions ( arr , n ) ) NEW_LINE"],"references":["def maxPartitions ( arr , n ) : NEW_LINE INDENT ans = 0 ; max_so_far = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT max_so_far = max ( max_so_far , arr [ i ] ) NEW_LINE if ( max_so_far == i ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 0 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxPartitions ( arr , n ) ) NEW_LINE"],"bleu":0.9336656541325128,"rouge_l":0.9760877382236606}
{"id":882,"predictions":["def greaterK ( n , k ) : NEW_LINE INDENT p = [ 0 ] * ( len ( str ( n ) ) + 2 ) NEW_LINE index = 0 NEW_LINE x = n NEW_LINE while ( x ) : NEW_LINE INDENT p [ index ] = ( x % k ) NEW_LINE x \/\/= k NEW_LINE index += 1 NEW_LINE DEDENT idx = 0 NEW_LINE for i in range ( 0 , len ( p ) - 1 ) : NEW_LINE INDENT if ( p [ i ] >= 2 ) : NEW_LINE INDENT p [ i ] = 0 NEW_LINE p [ i + 1 ] += 1 NEW_LINE for j in range ( idx , i ) : NEW_LINE INDENT p [ j ] = 0 NEW_LINE DEDENT idx = i + 1 NEW_LINE DEDENT if ( p [ i ] == k ) : NEW_LINE INDENT p [ i ] = 0 NEW_LINE p [ i + 1 ] += 1 NEW_LINE DEDENT DEDENT j = len ( p ) - 1 NEW_LINE if ( p [ j ] >= 2 ) : NEW_LINE INDENT p [ index ] = 1 NEW_LINE index += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( len ( p ) - 1 , - 1 ) : NEW_LINE INDENT ans = ans * k + p [ i ] NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 29 NEW_LINE k = 7 NEW_LINE greaterK ( n , k ) NEW_LINE DEDENT"],"references":["def greaterK ( n , k ) : NEW_LINE INDENT index = 0 NEW_LINE p = [ 0 for i in range ( n + 2 ) ] NEW_LINE x = n NEW_LINE while ( x > 0 ) : NEW_LINE INDENT p [ index ] = x % k NEW_LINE x \/\/= k NEW_LINE index += 1 NEW_LINE DEDENT idx = 0 NEW_LINE for i in range ( 0 , len ( p ) - 1 , 1 ) : NEW_LINE INDENT if ( p [ i ] >= 2 ) : NEW_LINE INDENT p [ i ] = 0 NEW_LINE p [ i + 1 ] += 1 NEW_LINE for j in range ( idx , i , 1 ) : NEW_LINE INDENT p [ j ] = 0 NEW_LINE DEDENT idx = i + 1 NEW_LINE DEDENT if ( p [ i ] == k ) : NEW_LINE INDENT p [ i ] = 0 NEW_LINE p [ i + 1 ] += 1 NEW_LINE DEDENT DEDENT j = len ( p ) - 1 NEW_LINE if ( p [ j ] >= 2 ) : NEW_LINE INDENT p [ index ] = 1 NEW_LINE index += 1 NEW_LINE DEDENT ans = 0 NEW_LINE i = len ( p ) - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT ans = ans * k + p [ i ] NEW_LINE i -= 1 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 29 NEW_LINE k = 7 NEW_LINE greaterK ( n , k ) NEW_LINE DEDENT"],"bleu":0.8708871427061872,"rouge_l":0.9125725569983845}
{"id":883,"predictions":["def longestPrefixSuffix ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE lps = [ 0 for i in range ( n ) ] NEW_LINE lps [ 0 ] = 0 NEW_LINE Len = 0 NEW_LINE i = 1 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( s [ i ] == s [ Len ] ) : NEW_LINE INDENT Len += 1 NEW_LINE lps [ i ] = lps [ i ] NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( Len != 0 ) : NEW_LINE INDENT Len = lps [ Len - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lps [ i ] = 0 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT DEDENT res = lps [ n - 1 ] NEW_LINE print ( ( longestPrefixSuffix ( s ) ) NEW_LINE"],"references":["def longestPrefixSuffix ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE lps = [ 0 ] * n NEW_LINE l = 0 NEW_LINE i = 1 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( s [ i ] == s [ l ] ) : NEW_LINE INDENT l = l + 1 NEW_LINE lps [ i ] = l NEW_LINE i = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( l != 0 ) : NEW_LINE INDENT l = lps [ l - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lps [ i ] = 0 NEW_LINE i = i + 1 NEW_LINE DEDENT DEDENT DEDENT res = lps [ n - 1 ] NEW_LINE if ( res > n \/ 2 ) : NEW_LINE INDENT return n \/\/ 2 NEW_LINE DEDENT else : NEW_LINE INDENT return res NEW_LINE DEDENT DEDENT s = \" abcab \" NEW_LINE print ( longestPrefixSuffix ( s ) ) NEW_LINE"],"bleu":0.6025957568998591,"rouge_l":0.7405831690360071}
{"id":884,"predictions":["def printBracketNumber ( exp , n ) : NEW_LINE INDENT left_bnum = 1 NEW_LINE right_bnum = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if exp [ i ] == ' ( ' ) : NEW_LINE INDENT print ( left_bnum , end = \" ▁ \" ) NEW_LINE right_bnum += 1 NEW_LINE DEDENT elif ( exp [ i ] == ' ) ' ) : NEW_LINE INDENT print ( right_bnum , end = \" ▁ \" ) NEW_LINE return NEW_LINE DEDENT elif ( exp [ i ] == ' ) ' ) ' : NEW_LINE INDENT print ( right_bnum [ i ] , end = \" ▁ \" ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT exp = \" ( a + ( b * c ) ) + ( d \/\/ e ) ) \" NEW_LINE n = len ( exp ) NEW_LINE printBracketNumber ( exp , n ) NEW_LINE DEDENT"],"references":["def printBracketNumber ( exp , n ) : NEW_LINE INDENT left_bnum = 1 NEW_LINE right_bnum = list ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if exp [ i ] == ' ( ' : NEW_LINE INDENT print ( left_bnum , end = \" ▁ \" ) NEW_LINE right_bnum . append ( left_bnum ) NEW_LINE left_bnum += 1 NEW_LINE DEDENT elif exp [ i ] == ' ) ' : NEW_LINE INDENT print ( right_bnum [ - 1 ] , end = \" ▁ \" ) NEW_LINE right_bnum . pop ( ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT exp = \" ( a + ( b * c ) ) + ( d \/ e ) \" NEW_LINE n = len ( exp ) NEW_LINE printBracketNumber ( exp , n ) NEW_LINE DEDENT"],"bleu":0.7189349089983212,"rouge_l":0.8397121701950151}
{"id":885,"predictions":["N = 10E6 NEW_LINE fourDiv = [ True ] * ( N + 1 ) ; NEW_LINE def fourDistinctFactors ( ) : NEW_LINE INDENT primeAll = [ True ] * ( N + 1 ) ; NEW_LINE p = 2 ; NEW_LINE while ( p * p <= N ) : NEW_LINE INDENT if ( primeAll [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , N + 1 , p ) : NEW_LINE INDENT primeAll [ i ] = False ; NEW_LINE DEDENT DEDENT DEDENT prime = [ ] ; NEW_LINE for p in range ( 2 , N + 1 ) : NEW_LINE INDENT if ( primeAll [ p ] ) : NEW_LINE INDENT prime . append ( p ) ; NEW_LINE DEDENT DEDENT for i in range ( len ( prime ) ) : NEW_LINE INDENT p = prime [ i ] ; NEW_LINE if ( 1L * p * p <= N ) : NEW_LINE INDENT fourDiv [ p * p ] = True ; NEW_LINE DEDENT for j in range ( i + 1 , len ( prime ) ) : NEW_LINE INDENT q = prime [ j ] ; NEW_LINE if ( 1L * q > N ) : NEW_LINE INDENT break ; NEW_LINE DEDENT fourDiv [ p * q ] = True ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT 4 = 10 ; NEW_LINE if ( fourDiv [ num ] ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT num = 12 ; NEW_LINE if ( fourDiv [ num ] ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT num = 12 ; NEW_LINE if ( fourDiv [ num ] ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT DEDENT"],"references":["N = 1000001 ; NEW_LINE fourDiv = [ False ] * ( N + 1 ) ; NEW_LINE def fourDistinctFactors ( ) : NEW_LINE INDENT primeAll = [ True ] * ( N + 1 ) ; NEW_LINE p = 2 ; NEW_LINE while ( p * p <= N ) : NEW_LINE INDENT if ( primeAll [ p ] == True ) : NEW_LINE INDENT i = p * 2 ; NEW_LINE while ( i <= N ) : NEW_LINE INDENT primeAll [ i ] = False ; NEW_LINE i += p ; NEW_LINE DEDENT DEDENT p += 1 ; NEW_LINE DEDENT prime = [ ] ; NEW_LINE for p in range ( 2 , N + 1 ) : NEW_LINE INDENT if ( primeAll [ p ] ) : NEW_LINE INDENT prime . append ( p ) ; NEW_LINE DEDENT DEDENT for i in range ( len ( prime ) ) : NEW_LINE INDENT p = prime [ i ] ; NEW_LINE if ( 1 * p * p * p <= N ) : NEW_LINE INDENT fourDiv [ p * p * p ] = True ; NEW_LINE DEDENT for j in range ( i + 1 , len ( prime ) ) : NEW_LINE INDENT q = prime [ j ] ; NEW_LINE if ( 1 * p * q > N ) : NEW_LINE INDENT break ; NEW_LINE DEDENT fourDiv [ p * q ] = True ; NEW_LINE DEDENT DEDENT DEDENT fourDistinctFactors ( ) ; NEW_LINE num = 10 ; NEW_LINE if ( fourDiv [ num ] ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT num = 12 ; NEW_LINE if ( fourDiv [ num ] ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT"],"bleu":0.8202534143920952,"rouge_l":0.8867933795000246}
{"id":886,"predictions":["N = 3 NEW_LINE def summarProductMat ( mat , k ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT mat [ i ] [ j ] = mat [ i ] [ j ] * k NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT mat = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] , [ 7 , 8 , 9 ] ] NEW_LINE k = 4 NEW_LINE summarProductMat ( mat , k ) NEW_LINE print ( \" Fillar ▁ Product ▁ is ▁ : ▁ \" , end = \" \" ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT"],"references":["N = 3 NEW_LINE def scalarProductMat ( mat , k ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT mat [ i ] [ j ] = mat [ i ] [ j ] * k NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT mat = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE k = 4 NEW_LINE scalarProductMat ( mat , k ) NEW_LINE print ( \" Scalar ▁ Product ▁ Matrix ▁ is ▁ : ▁ \" ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT"],"bleu":0.8492256781799576,"rouge_l":0.9329000191168036}
{"id":887,"predictions":["if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" geeksforgeeks \" NEW_LINE print ( str ) NEW_LINE DEDENT"],"references":["str = \" geeksforgeeks \" ; NEW_LINE str = \" \" . join ( reversed ( str ) ) NEW_LINE print ( str ) ; NEW_LINE"],"bleu":0.3224170212491624,"rouge_l":0.4298526585522101}
{"id":888,"predictions":["def countDistinct ( arr , n ) : NEW_LINE INDENT hs = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hs [ arr [ i ] ] = 1 NEW_LINE DEDENT return len ( hs ) NEW_LINE DEDENT arr = [ 6 , 10 , 5 , 4 , 9 , 120 , 4 , 6 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countDistinct ( arr , n ) ) NEW_LINE"],"references":["def countDistinct ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] not in s ) : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT arr = [ 6 , 10 , 5 , 4 , 9 , 120 , 4 , 6 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countDistinct ( arr , n ) ) NEW_LINE"],"bleu":0.6305380583807508,"rouge_l":0.7854532799721594}
{"id":889,"predictions":["x = 32 NEW_LINE def toggleCase ( a ) : NEW_LINE INDENT for i in range ( len ( a ) ) : NEW_LINE INDENT a [ i ] ^= 32 NEW_LINE DEDENT return a NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = 32 NEW_LINE print ( \" Case ▁ case : ▁ \" , end = \" \" ) NEW_LINE print ( str1 ) NEW_LINE print ( str1 ) NEW_LINE print ( \" Case ▁ string : ▁ \" , end = \" \" ) NEW_LINE print ( str1 ) NEW_LINE str2 = toggleCase ( str1 ) NEW_LINE print ( str1 ) NEW_LINE DEDENT"],"references":["x = 32 ; NEW_LINE def toggleCase ( a ) : NEW_LINE INDENT for i in range ( len ( a ) ) : NEW_LINE INDENT a = a [ : i ] + chr ( ord ( a [ i ] ) ^ 32 ) + a [ i + 1 : ] ; NEW_LINE DEDENT return a ; NEW_LINE DEDENT str = \" CheRrY \" ; NEW_LINE print ( \" Toggle ▁ case : ▁ \" , end = \" \" ) ; NEW_LINE str = toggleCase ( str ) ; NEW_LINE print ( str ) ; NEW_LINE print ( \" Original ▁ string : ▁ \" , end = \" \" ) ; NEW_LINE str = toggleCase ( str ) ; NEW_LINE print ( str ) ; NEW_LINE"],"bleu":0.4493289690756023,"rouge_l":0.6853026698387523}
{"id":890,"predictions":["MAX = 1000000 NEW_LINE arr = [ ] NEW_LINE prime = [ True ] * ( MAX ) NEW_LINE def SieveofEratosthenes ( ) : NEW_LINE INDENT p = 2 NEW_LINE while p * p < MAX : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT for p in range ( 2 , MAX ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT arr . append ( p ) NEW_LINE DEDENT DEDENT DEDENT def isPrimorial ( n ) : NEW_LINE INDENT if prime [ n ] : NEW_LINE INDENT return False NEW_LINE DEDENT product = 1 NEW_LINE i = 0 NEW_LINE while product < n : NEW_LINE INDENT product = product * arr [ i ] NEW_LINE if product + 1 == n or product - 1 == n : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT SieveOfEratosthenes ( ) NEW_LINE n = 31 NEW_LINE if isPrimorial ( n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"],"references":["from math import sqrt NEW_LINE MAX = 100000 NEW_LINE prime = [ True ] * MAX NEW_LINE arr = [ ] NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT for p in range ( 2 , int ( sqrt ( MAX ) ) + 1 ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for p in range ( 2 , MAX ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT arr . append ( p ) NEW_LINE DEDENT DEDENT DEDENT def isPrimorialPrime ( n ) : NEW_LINE INDENT if not prime [ n ] : NEW_LINE INDENT return False NEW_LINE DEDENT product , i = 1 , 0 NEW_LINE while product < n : NEW_LINE INDENT product *= arr [ i ] NEW_LINE if product + 1 == n or product - 1 == n : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE n = 31 NEW_LINE if ( isPrimorialPrime ( n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.7344560925033217,"rouge_l":0.8267941218433442}
{"id":891,"predictions":["def countNumbers ( X , Y , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( ( i % X == 0 and ( i % Y != 0 ) ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT X = 2 NEW_LINE Y = 3 NEW_LINE N = 10 NEW_LINE print ( countNumbers ( X , Y , N ) ) NEW_LINE"],"references":["def countNumbers ( X , Y , N ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( ( i % X == 0 ) and ( i % Y != 0 ) ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT X = 2 ; NEW_LINE Y = 3 ; NEW_LINE N = 10 ; NEW_LINE print ( countNumbers ( X , Y , N ) ) ; NEW_LINE"],"bleu":0.7799811824785692,"rouge_l":0.9424314879529152}
{"id":892,"predictions":["def countSubseq ( arr , n ) : NEW_LINE INDENT um = dict ( ) NEW_LINE count = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ arr [ i ] ] in um . keys ( ) : NEW_LINE INDENT um [ arr [ i ] ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT um [ arr [ i ] ] += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 4 , 7 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Count ▁ = \" , countSubseq ( arr , n ) ) NEW_LINE"],"references":["def countSubseq ( arr , n ) : NEW_LINE INDENT um = { i : 0 for i in range ( 8 ) } NEW_LINE count = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT um [ arr [ i ] ] += 1 NEW_LINE DEDENT for key , values in um . items ( ) : NEW_LINE INDENT if ( values > 0 ) : NEW_LINE INDENT count *= values NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 7 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Count ▁ = \" , countSubseq ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.6291391586921913,"rouge_l":0.7118419307784114}
{"id":893,"predictions":["import math NEW_LINE def check ( a , b ) : NEW_LINE INDENT c = 0 NEW_LINE while ( a != 0 ) : NEW_LINE INDENT c = c + a % 10 NEW_LINE a = a \/\/ 10 NEW_LINE DEDENT return ( c == b ) NEW_LINE DEDENT def root ( n ) : NEW_LINE INDENT found = False NEW_LINE mx = 1E1818 NEW_LINE for i in range ( 0 , 90 ) : NEW_LINE INDENT s = i * i + 4 * n NEW_LINE sq = math . sqrt ( s ) NEW_LINE if ( sq * sq == s and check ( ( sq - i ) \/\/ 2 , i ) ) : NEW_LINE INDENT found = True NEW_LINE mx = min ( mx , ( sq - i ) \/\/ 2 ) NEW_LINE DEDENT DEDENT if ( found ) : NEW_LINE INDENT return mx NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT n = 110 NEW_LINE print ( root ( n ) ) NEW_LINE"],"references":["import math NEW_LINE def check ( a , b ) : NEW_LINE INDENT c = 0 ; NEW_LINE while ( a != 0 ) : NEW_LINE INDENT c = c + a % 10 ; NEW_LINE a = int ( a \/ 10 ) ; NEW_LINE DEDENT return True if ( c == b ) else False ; NEW_LINE DEDENT def root ( n ) : NEW_LINE INDENT found = False ; NEW_LINE mx = 1000000000000000001 ; NEW_LINE for i in range ( 91 ) : NEW_LINE INDENT s = i * i + 4 * n ; NEW_LINE sq = int ( math . sqrt ( s ) ) ; NEW_LINE if ( sq * sq == s and check ( int ( ( sq - i ) \/ 2 ) , i ) ) : NEW_LINE INDENT found = True ; NEW_LINE mx = min ( mx , int ( ( sq - i ) \/ 2 ) ) ; NEW_LINE DEDENT DEDENT if ( found ) : NEW_LINE INDENT return mx ; NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT DEDENT n = 110 ; NEW_LINE print ( root ( n ) ) ; NEW_LINE"],"bleu":0.6492718851206024,"rouge_l":0.8765272758561349}
{"id":894,"predictions":["def Fraction ( n , d ) : NEW_LINE INDENT num = n NEW_LINE den = d NEW_LINE DEDENT def maxFraction ( first , sec ) : NEW_LINE INDENT a = first . num NEW_LINE b = first . den NEW_LINE d = sec . den . den NEW_LINE Y = a * d - b * c NEW_LINE return first NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT first = [ 3 , 2 , 2 ] NEW_LINE sec = [ 3 , 4 ) , 4 NEW_LINE res = maxFraction ( first , sec ) NEW_LINE print ( res . num , \" \/ \" , res . den ) NEW_LINE DEDENT"],"references":["def maxFraction ( first , sec ) : NEW_LINE INDENT a = first [ 0 ] ; b = first [ 1 ] NEW_LINE c = sec [ 0 ] ; d = sec [ 1 ] NEW_LINE Y = a * d - b * c NEW_LINE return first if Y else sec NEW_LINE DEDENT first = ( 3 , 2 ) NEW_LINE sec = ( 3 , 4 ) NEW_LINE res = maxFraction ( first , sec ) NEW_LINE print ( str ( res [ 0 ] ) + \" \/ \" + str ( res [ 1 ] ) ) NEW_LINE"],"bleu":0.3915555995265713,"rouge_l":0.5947702762594179}
{"id":895,"predictions":["def Permutation ( n , k ) : NEW_LINE INDENT p = [ 0 ] * ( n + 1 ) ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT p [ i ] = i ; NEW_LINE DEDENT for i in range ( 1 , n - k ) : NEW_LINE INDENT p [ i + 1 ] = i ; NEW_LINE DEDENT p [ 1 ] = n - k ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( p [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 ; k = 2 ; NEW_LINE Permutation ( n , k ) ; NEW_LINE DEDENT"],"references":["def Permutation ( n , k ) : NEW_LINE INDENT p = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT p [ i ] = i NEW_LINE DEDENT for i in range ( 1 , n - k ) : NEW_LINE INDENT p [ i + 1 ] = i NEW_LINE DEDENT p [ 1 ] = n - k NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( p [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE k = 2 NEW_LINE Permutation ( n , k ) NEW_LINE DEDENT"],"bleu":0.7980049725420956,"rouge_l":0.9314605431868515}
{"id":896,"predictions":["def reverse ( x ) : NEW_LINE INDENT rev = 0 NEW_LINE while ( x > 0 ) : NEW_LINE INDENT rev = ( rev * 10 ) + x % 10 NEW_LINE x = x \/\/ 10 NEW_LINE DEDENT return rev NEW_LINE DEDENT def printEmirp ( n ) : NEW_LINE INDENT prime = [ True for i in range ( n + 1 ) ] NEW_LINE p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT rev = reverse ( p ) NEW_LINE if ( p != rev and rev <= n and prime [ rev ] ) : NEW_LINE INDENT print ( p , \" ▁ \" , end = \" \" ) NEW_LINE prime [ rev ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT n = 100 NEW_LINE printEmirp ( n ) NEW_LINE"],"references":["def reverse ( x ) : NEW_LINE INDENT rev = 0 ; NEW_LINE while ( x > 0 ) : NEW_LINE INDENT rev = ( rev * 10 ) + x % 10 ; NEW_LINE x = int ( x \/ 10 ) ; NEW_LINE DEDENT return rev ; NEW_LINE DEDENT def printEmirp ( n ) : NEW_LINE INDENT prime = [ 1 ] * ( n + 1 ) ; NEW_LINE p = 2 ; NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == 1 ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = 0 ; NEW_LINE DEDENT DEDENT p += 1 ; NEW_LINE DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] == 1 ) : NEW_LINE INDENT rev = reverse ( p ) ; NEW_LINE if ( p != rev and rev <= n and prime [ rev ] == 1 ) : NEW_LINE INDENT print ( p , rev , end = \" ▁ \" ) ; NEW_LINE prime [ rev ] = 0 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT n = 100 ; NEW_LINE printEmirp ( n ) ; NEW_LINE"],"bleu":0.7384209855588355,"rouge_l":0.8972607879924953}
{"id":897,"predictions":["def largest ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE return arr [ n - 1 ] NEW_LINE DEDENT arr = [ 10 , 324 , 45 , 90 , 9808 ] NEW_LINE n = len ( arr ) NEW_LINE print ( largest ( arr , n ) ) NEW_LINE"],"references":["def largest ( arr , n ) : NEW_LINE INDENT return max ( arr ) NEW_LINE DEDENT arr = [ 10 , 324 , 45 , 90 , 9808 ] NEW_LINE n = len ( arr ) NEW_LINE print ( largest ( arr , n ) ) NEW_LINE"],"bleu":0.7584614067667067,"rouge_l":0.8775575447570332}
{"id":898,"predictions":["class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def maxLevelProduct ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT result = root . data NEW_LINE q = [ ] NEW_LINE q . append ( root ) NEW_LINE while ( len ( q ) != 0 ) : NEW_LINE INDENT count = len ( q ) NEW_LINE product = 1 NEW_LINE while ( count ) : NEW_LINE INDENT temp = q [ 0 ] NEW_LINE q . pop ( 0 ) NEW_LINE product = product * temp . data NEW_LINE if ( temp . left ) : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE DEDENT if ( temp . right ) : NEW_LINE INDENT q . append ( temp . right ) NEW_LINE DEDENT DEDENT result = max ( product , result ) NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 1 ) NEW_LINE root . left = newNode ( 2 ) NEW_LINE root . right = newNode ( 3 ) NEW_LINE root . left . left = newNode ( 4 ) NEW_LINE root . left . left . left = newNode ( 4 ) NEW_LINE root . left . left . right = newNode ( 4 ) NEW_LINE root . right . right . right = newNode ( 8 ) NEW_LINE print ( \" Maximum ▁ level ▁ product ▁ is \" , maxLevelProduct ( root ) ) NEW_LINE DEDENT"],"references":["class newNode : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . data = key NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def maxLevelProduct ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT result = root . data NEW_LINE q = [ ] NEW_LINE q . append ( root ) NEW_LINE while ( len ( q ) ) : NEW_LINE INDENT count = len ( q ) NEW_LINE product = 1 NEW_LINE while ( count ) : NEW_LINE INDENT count -= 1 NEW_LINE temp = q [ 0 ] NEW_LINE q . pop ( 0 ) NEW_LINE product = product * temp . data NEW_LINE if ( temp . left != None ) : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE DEDENT if ( temp . right != None ) : NEW_LINE INDENT q . append ( temp . right ) NEW_LINE DEDENT DEDENT result = max ( product , result ) NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 1 ) NEW_LINE root . left = newNode ( 2 ) NEW_LINE root . right = newNode ( 3 ) NEW_LINE root . left . left = newNode ( 4 ) NEW_LINE root . left . right = newNode ( 5 ) NEW_LINE root . right . right = newNode ( 8 ) NEW_LINE root . right . right . left = newNode ( 6 ) NEW_LINE root . right . right . right = newNode ( 7 ) NEW_LINE print ( \" Maximum ▁ level ▁ product ▁ is \" , maxLevelProduct ( root ) ) NEW_LINE DEDENT"],"bleu":0.8622668961821944,"rouge_l":0.9258868008451018}
{"id":899,"predictions":["def fact ( n ) : NEW_LINE INDENT fact = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fact *= i NEW_LINE DEDENT return fact NEW_LINE DEDENT def countStrings ( st , n ) : NEW_LINE INDENT distinct_char = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT distinct_char [ st [ i ] ] = 1 NEW_LINE DEDENT return fact ( len ( distinct_char ) ) NEW_LINE DEDENT st = \" geeksforgeeks \" NEW_LINE n = len ( st ) NEW_LINE print ( countStrings ( st , n ) ) NEW_LINE"],"references":["def fact ( n ) : NEW_LINE INDENT fact = 1 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fact *= i ; NEW_LINE DEDENT return fact ; NEW_LINE DEDENT def countStrings ( string , n ) : NEW_LINE INDENT distinct_char = set ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT distinct_char . add ( string [ i ] ) ; NEW_LINE DEDENT return fact ( len ( distinct_char ) ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" geeksforgeeks \" ; NEW_LINE n = len ( string ) ; NEW_LINE print ( countStrings ( string , n ) ) ; NEW_LINE DEDENT"],"bleu":0.5749165078839736,"rouge_l":0.8096225632517626}
{"id":900,"predictions":["def printMaxValPair ( v , n ) : NEW_LINE INDENT v . sort ( ) NEW_LINE N = v [ n - 1 ] NEW_LINE if ( N % 2 == 1 ) : NEW_LINE INDENT first_max = N \/\/ 2 NEW_LINE second_max = first_min + 1 NEW_LINE ans1 = 3e18 NEW_LINE ans2 = 3e18 NEW_LINE from range ( n ) : NEW_LINE INDENT if ( v [ i ] > first_max ) : NEW_LINE INDENT from = i NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT diff = first_max - v [ i ] NEW_LINE if ( v [ i ] > first_max ) : NEW_LINE INDENT from = i NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT diff = first_max - v [ i ] NEW_LINE if ( diff < ans1 ) : NEW_LINE INDENT ans1 = diff NEW_LINE from_left = v [ i ] NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( len ( v ) ) : NEW_LINE INDENT if ( v [ i ] < ans1 ) : NEW_LINE INDENT print ( N , end = \" ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( N , end = \" ▁ \" ) NEW_LINE DEDENT print ( \" N \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT v = [ 1 , 1 , 2 , 3 , 6 , 1 ] NEW_LINE ans = [ 1 , 1 , 2 , 3 , 6 , 1 ] NEW_LINE printMaxValPair ( v , len ( v ) ) NEW_LINE DEDENT"],"references":["def printMaxValPair ( v , n ) : NEW_LINE INDENT v . sort ( ) NEW_LINE N = v [ n - 1 ] NEW_LINE if N % 2 == 1 : NEW_LINE INDENT first_maxima = N \/\/ 2 NEW_LINE second_maxima = first_maxima + 1 NEW_LINE ans1 , ans2 = 3 * ( 10 ** 18 ) , 3 * ( 10 ** 18 ) NEW_LINE from_left , from_right = - 1 , - 1 NEW_LINE _from = - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if v [ i ] > first_maxima : NEW_LINE INDENT _from = i NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT diff = first_maxima - v [ i ] NEW_LINE if diff < ans1 : NEW_LINE INDENT ans1 = diff NEW_LINE from_left = v [ i ] NEW_LINE DEDENT DEDENT DEDENT from_right = v [ _from ] NEW_LINE diff1 = first_maxima - from_left NEW_LINE diff2 = from_right - second_maxima NEW_LINE if diff1 < diff2 : NEW_LINE INDENT print ( N , from_left ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( N , from_right ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT maxima = N \/\/ 2 NEW_LINE ans1 = 3 * ( 10 ** 18 ) NEW_LINE R = - 1 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT diff = abs ( v [ i ] - maxima ) NEW_LINE if diff < ans1 : NEW_LINE INDENT ans1 = diff NEW_LINE R = v [ i ] NEW_LINE DEDENT DEDENT print ( N , R ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT v = [ 1 , 1 , 2 , 3 , 6 , 1 ] NEW_LINE n = len ( v ) NEW_LINE printMaxValPair ( v , n ) NEW_LINE DEDENT"],"bleu":0.5171552099200412,"rouge_l":0.593477059148701}
{"id":901,"predictions":["def triangle ( n ) : NEW_LINE INDENT k = 2 * n - 2 NEW_LINE ch = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( k ) : NEW_LINE INDENT print ( \" ▁ \" , end = \" \" ) NEW_LINE DEDENT k = k - 1 NEW_LINE for j in range ( i ) : NEW_LINE INDENT print ( ch , end = \" ▁ \" ) NEW_LINE DEDENT print ( \" \" ) NEW_LINE DEDENT DEDENT def max eight ( n ) : NEW_LINE INDENT return ( ( ord ( 1 + 65 * n ) ) - 1 ) \/\/ 2 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 9 NEW_LINE triangle ( N ) NEW_LINE DEDENT"],"references":["from math import sqrt NEW_LINE def triangle ( n ) : NEW_LINE INDENT k = 2 * n - 2 ; NEW_LINE ch = 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( k ) : NEW_LINE INDENT print ( \" ▁ \" , end = \" \" ) ; NEW_LINE DEDENT k = k - 1 ; NEW_LINE for j in range ( i + 1 ) : NEW_LINE INDENT print ( ch , end = \" ▁ \" ) ; NEW_LINE ch += 1 ; NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT def maxHeight ( n ) : NEW_LINE INDENT ans = ( sqrt ( 1 + 8.0 * n ) - 1 ) \/\/ 2 ; NEW_LINE return int ( ans ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 9 ; NEW_LINE triangle ( maxHeight ( N ) ) ; NEW_LINE DEDENT"],"bleu":0.6430482111317902,"rouge_l":0.841069361119882}
{"id":902,"predictions":["def longestInteger ( str , l ) : NEW_LINE INDENT count = 0 NEW_LINE max = 0 NEW_LINE pos = - 1 NEW_LINE pre_len = len ( str ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT pre_pos = pos NEW_LINE pre_len = len NEW_LINE if ( str [ i ] . isdigit ( ) ) : NEW_LINE INDENT pos = i NEW_LINE DEDENT while ( str [ i ] ) : NEW_LINE INDENT count = i NEW_LINE i += 1 NEW_LINE DEDENT if ( count > max ) : NEW_LINE INDENT max = count NEW_LINE DEDENT else : NEW_LINE INDENT pos = pre_pos NEW_LINE length = pre_len NEW_LINE DEDENT DEDENT return ( str [ pos : pos : pos + len ] ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeksfor123434\" NEW_LINE l = len ( str ) NEW_LINE print ( longestInteger ( str , l ) ) NEW_LINE DEDENT"],"references":["def longestInteger ( s , length ) : NEW_LINE INDENT count = 0 NEW_LINE maximum = 0 NEW_LINE pos = - 1 NEW_LINE l = 0 NEW_LINE for i in range ( length ) : NEW_LINE INDENT pre_pos = pos NEW_LINE pre_len = l NEW_LINE count = 0 NEW_LINE l = 0 NEW_LINE if ( s [ i ] . isdecimal ( ) ) : NEW_LINE INDENT pos = i NEW_LINE DEDENT while ( s [ i ] . isdecimal ( ) ) : NEW_LINE INDENT count += 1 NEW_LINE i += 1 NEW_LINE l += 1 NEW_LINE DEDENT if ( count > maximum ) : NEW_LINE INDENT maximum = count NEW_LINE DEDENT else : NEW_LINE INDENT pos = pre_pos NEW_LINE l = pre_len NEW_LINE DEDENT DEDENT return ( s [ pos : pos + l ] ) NEW_LINE DEDENT s = \" geeks100for1234geeks \" NEW_LINE length = len ( s ) NEW_LINE print ( longestInteger ( s , length ) ) NEW_LINE"],"bleu":0.5568055750582932,"rouge_l":0.7508255779045332}
{"id":903,"predictions":["def findSum ( n , a , b ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i % a == 0 or i % b == 0 ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT n = 10 NEW_LINE a = 3 NEW_LINE b = 5 NEW_LINE print ( findSum ( n , a , b ) ) NEW_LINE"],"references":["def findSum ( n , a , b ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( i % a == 0 or i % b == 0 ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE a = 3 NEW_LINE b = 5 NEW_LINE print ( findSum ( n , a , b ) ) NEW_LINE DEDENT"],"bleu":0.7518565104355958,"rouge_l":0.8787652011225445}
{"id":904,"predictions":["n = 4 NEW_LINE print ( seriesSum ( n ) ) NEW_LINE"],"references":["def seriesSum ( n ) : NEW_LINE INDENT return int ( ( n * ( n + 1 ) * ( n + 2 ) ) \/ 6 ) NEW_LINE DEDENT n = 4 NEW_LINE print ( seriesSum ( n ) ) NEW_LINE"],"bleu":0.07552184450877376,"rouge_l":0.3961038961038961}
{"id":905,"predictions":["def find_count ( ele ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( ele ) ) : NEW_LINE INDENT p = [ ] NEW_LINE c = 0 NEW_LINE for j in range ( len ( ele ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT p . append ( ele [ j ] ) NEW_LINE DEDENT j = len ( ele ) - 1 NEW_LINE k = 0 NEW_LINE while ( j >= 0 ) : NEW_LINE INDENT if ( ele [ j ] != p [ k ] ) : NEW_LINE INDENT break NEW_LINE DEDENT j -= 1 NEW_LINE k += 1 NEW_LINE if ( k == len ( p ) ) : NEW_LINE INDENT c += 1 NEW_LINE k = 0 NEW_LINE DEDENT DEDENT count = max ( count , c ) NEW_LINE DEDENT return count NEW_LINE DEDENT def solve ( n ) : NEW_LINE INDENT count = 1 NEW_LINE ele = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( count , end = \" \" ) NEW_LINE ele . append ( ele ) NEW_LINE count = find_count ( ele ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 10 NEW_LINE solve ( n ) NEW_LINE DEDENT"],"references":["def find_count ( ele ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( ele ) ) : NEW_LINE INDENT p = [ ] NEW_LINE c = 0 NEW_LINE j = len ( ele ) - 1 NEW_LINE while j >= ( len ( ele ) - 1 - i ) and j >= 0 : NEW_LINE INDENT p . append ( ele [ j ] ) NEW_LINE j -= 1 NEW_LINE DEDENT j = len ( ele ) - 1 NEW_LINE k = 0 NEW_LINE while j >= 0 : NEW_LINE INDENT if ele [ j ] != p [ k ] : NEW_LINE INDENT break NEW_LINE DEDENT j -= 1 NEW_LINE k += 1 NEW_LINE if k == len ( p ) : NEW_LINE INDENT c += 1 NEW_LINE k = 0 NEW_LINE DEDENT DEDENT count = max ( count , c ) NEW_LINE DEDENT return count NEW_LINE DEDENT def solve ( n ) : NEW_LINE INDENT count = 1 NEW_LINE ele = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( count , end = \" ▁ \" ) NEW_LINE ele . append ( count ) NEW_LINE count = find_count ( ele ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 10 NEW_LINE solve ( n ) NEW_LINE DEDENT"],"bleu":0.8387994423320498,"rouge_l":0.9212138481265137}
{"id":906,"predictions":["def getMinimumOps ( ar , k ) : NEW_LINE INDENT n = len ( ar ) NEW_LINE dp = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE dp [ 0 ] [ 1 ] = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT maxGroups = min ( k , i + 1 ) NEW_LINE for j in range ( 1 , maxGroups ) : NEW_LINE INDENT dp [ i ] [ j ] = 10 ** 9 NEW_LINE if ( j == 1 ) : NEW_LINE INDENT freq = [ 0 ] * 100000 NEW_LINE if ( j == 1 ) : NEW_LINE INDENT freq = [ 0 ] * 100000 NEW_LINE freq = freq [ ar [ j ] ] NEW_LINE if ( j == 1 ) : NEW_LINE INDENT freqOfDepth = freq NEW_LINE DEDENT DEDENT dp [ i ] [ 1 ] = ( i + 1 ) - freq NEW_LINE for it in range ( i , j + 1 ) : NEW_LINE INDENT freq [ ar [ ar [ it ] ] += 1 NEW_LINE if ( newElementFreq > freq ) : NEW_LINE INDENT freq = newElement NEW_LINE DEDENT DEDENT dp [ i ] [ 1 ] = ( i + 1 ) - freq NEW_LINE for it in range ( i , j - 1 , - 1 ) : NEW_LINE INDENT freq [ ar [ it ] ] += 1 NEW_LINE newElement = freq [ ar [ it ] ] NEW_LINE if ( newElementFreq > freq ) : NEW_LINE INDENT freqOfModq = newElement NEW_LINE DEDENT elementsToChange = i - it + 1 NEW_LINE elementsToChange ( dp [ it - 1 ] + elements , dp [ i ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n - 1 ] [ k ] NEW_LINE DEDENT k = 3 NEW_LINE ar = [ 3 , 1 , 3 , 3 , 2 , 1 , 8 , 5 ] NEW_LINE print ( getMinimumOps ( ar , k ) ) NEW_LINE"],"references":["def getMinimumOps ( ar , k ) : NEW_LINE INDENT n = len ( ar ) NEW_LINE dp = [ [ 0 for i in range ( k + 1 ) ] for i in range ( n ) ] NEW_LINE dp [ 0 ] [ 1 ] = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT maxGroups = min ( k , i + 1 ) NEW_LINE for j in range ( 1 , maxGroups + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = 10 ** 9 NEW_LINE if ( j == 1 ) : NEW_LINE INDENT freq1 = dict ( ) NEW_LINE freqOfMode = 0 NEW_LINE for it in range ( 0 , i + 1 ) : NEW_LINE INDENT freq1 [ ar [ it ] ] = freq1 . get ( ar [ it ] , 0 ) + 1 NEW_LINE newElementFreq = freq1 [ ar [ it ] ] NEW_LINE if ( newElementFreq > freqOfMode ) : NEW_LINE INDENT freqOfMode = newElementFreq NEW_LINE DEDENT DEDENT dp [ i ] [ 1 ] = ( i + 1 ) - freqOfMode NEW_LINE DEDENT else : NEW_LINE INDENT freq = dict ( ) NEW_LINE freqOfMode = 0 NEW_LINE for it in range ( i , j - 2 , - 1 ) : NEW_LINE INDENT freq [ ar [ it ] ] = freq . get ( ar [ it ] , 0 ) + 1 NEW_LINE newElementFreq = freq [ ar [ it ] ] NEW_LINE if ( newElementFreq > freqOfMode ) : NEW_LINE INDENT freqOfMode = newElementFreq NEW_LINE DEDENT elementsToChange = i - it + 1 NEW_LINE elementsToChange -= freqOfMode NEW_LINE dp [ i ] [ j ] = min ( dp [ it - 1 ] [ j - 1 ] + elementsToChange , dp [ i ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return dp [ n - 1 ] [ k ] NEW_LINE DEDENT k = 3 NEW_LINE ar = [ 3 , 1 , 3 , 3 , 2 , 1 , 8 , 5 ] NEW_LINE print ( getMinimumOps ( ar , k ) ) NEW_LINE"],"bleu":0.7199393510828462,"rouge_l":0.7754237288135593}
{"id":907,"predictions":["def findCount ( N ) : NEW_LINE INDENT list = [ ] NEW_LINE sum = 0 NEW_LINE for i in range ( 20 ) : NEW_LINE INDENT sum += pow ( 2 , i ) NEW_LINE list . append ( sum ) NEW_LINE DEDENT for i in range ( 20 ) : NEW_LINE INDENT if list [ i ] > N : NEW_LINE INDENT return ( list [ i ] + 1 ) NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT N = 10 NEW_LINE print ( findCount ( N ) ) NEW_LINE"],"references":["def findCount ( N ) : NEW_LINE INDENT list = [ ] NEW_LINE sum = 0 NEW_LINE for i in range ( 0 , 20 ) : NEW_LINE INDENT sum += 2 ** i NEW_LINE list . append ( sum ) NEW_LINE DEDENT for value in list : NEW_LINE INDENT if ( value > N ) : NEW_LINE INDENT return ( list . index ( value ) + 1 ) NEW_LINE DEDENT DEDENT DEDENT N = 10 NEW_LINE print ( findCount ( N ) ) NEW_LINE"],"bleu":0.6712334727639534,"rouge_l":0.8252409191994069}
{"id":908,"predictions":["def fry ( n ) : NEW_LINE INDENT x1 = 0 NEW_LINE y1 = 1 NEW_LINE x2 = 1 NEW_LINE y2 = n NEW_LINE print ( x1 , y1 , x2 , y2 ) NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE while ( y != 100 ) : NEW_LINE INDENT x = For ( ( y1 + n ) \/ y1 ) * x1 - x1 NEW_LINE y = x2 - x1 NEW_LINE y = y2 - y2 NEW_LINE DEDENT print ( \" { } . format ( x , y1 ) ) NEW_LINE x1 = x2 NEW_LINE y2 = y2 NEW_LINE y2 = y2 NEW_LINE DEDENT DEDENT n = 7 NEW_LINE print ( \" Found ▁ Sequence ▁ of ▁ order ▁ \" , n , \" isy ( n ) ) NEW_LINE"],"references":["import math NEW_LINE def farey ( n ) : NEW_LINE INDENT x1 = 0 ; NEW_LINE y1 = 1 ; NEW_LINE x2 = 1 ; NEW_LINE y2 = n ; NEW_LINE print ( x1 , end = \" \" ) NEW_LINE print ( \" \/ \" , end = \" \" ) NEW_LINE print ( y1 , x2 , end = \" \" ) NEW_LINE print ( \" \/ \" , end = \" \" ) NEW_LINE print ( y2 , end = \" ▁ \" ) ; NEW_LINE x = 0 ; NEW_LINE y = 0 ; NEW_LINE while ( y != 1.0 ) : NEW_LINE INDENT x = math . floor ( ( y1 + n ) \/ y2 ) * x2 - x1 ; NEW_LINE y = math . floor ( ( y1 + n ) \/ y2 ) * y2 - y1 ; NEW_LINE print ( x , end = \" \" ) NEW_LINE print ( \" \/ \" , end = \" \" ) NEW_LINE print ( y , end = \" ▁ \" ) ; NEW_LINE x1 = x2 ; NEW_LINE x2 = x ; NEW_LINE y1 = y2 ; NEW_LINE y2 = y ; NEW_LINE DEDENT DEDENT n = 7 ; NEW_LINE print ( \" Farey ▁ Sequence ▁ of ▁ order \" , n , \" is \" ) ; NEW_LINE farey ( n ) ; NEW_LINE"],"bleu":0.23923869426735625,"rouge_l":0.5760539629005059}
{"id":909,"predictions":["def Fib_length ( volume_ distance , value_ distance ) : NEW_LINE INDENT return ( 1 \/ ( ( 1 \/ distance ) + ( 1 \/ value_ distance ) ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT input_ distance = 2 ; NEW_LINE value_length = 50 ; NEW_LINE print ( \" Foc ▁ length ▁ of ▁ a ▁ lens ▁ is ▁ \" , longest_length ( map_length , value_length ) , \" un \" ) ; NEW_LINE DEDENT"],"references":["def focal_length ( image_distance , object_distance ) NEW_LINE INDENT : return 1 \/ ( ( 1 \/ image_distance ) + ( 1 \/ object_distance ) ) NEW_LINE DEDENT image_distance = 2 NEW_LINE object_distance = 50 NEW_LINE result = focal_length ( image_distance , object_distance ) NEW_LINE print ( \" Focal ▁ length ▁ of ▁ a ▁ lens ▁ is ▁ \" , result , \" ▁ units . \" ) NEW_LINE"],"bleu":0.32179006042638736,"rouge_l":0.6284693019343985}
{"id":910,"predictions":["def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y % 2 == 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def findModuloByM ( X , N , M ) : NEW_LINE INDENT if ( N < 6 ) : NEW_LINE INDENT temp = \" \" NEW_LINE for i in range ( N ) : NEW_LINE INDENT temp = temp + chr ( X + 48 ) NEW_LINE DEDENT res = int ( temp ) % M NEW_LINE return res NEW_LINE DEDENT if ( N % 2 == 0 ) : NEW_LINE INDENT half = findModuloByM ( X , N \/\/ 2 , M ) % M NEW_LINE res = ( half * power ( 10 , N \/\/ 2 + 1 , M ) + half * 10 + X ) % M NEW_LINE return res NEW_LINE DEDENT else : NEW_LINE INDENT half = findModuloByM ( X , N \/\/ 2 + 1 , M ) % M NEW_LINE res = ( half * power ( 10 , N \/\/ 2 + 1 , M ) + half * 10 + X ) % M NEW_LINE return res NEW_LINE DEDENT DEDENT X = 6 NEW_LINE N = 14 NEW_LINE M = 9 NEW_LINE print ( findModuloByM ( X , N , M ) ) NEW_LINE"],"references":["def power ( x , y , p ) : NEW_LINE INDENT res = 1 ; NEW_LINE x = x % p ; NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y and 1 ) : NEW_LINE INDENT res = ( res * x ) % p ; NEW_LINE DEDENT y = y >> 1 ; NEW_LINE x = ( x * x ) % p ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT def findModuloByM ( X , N , M ) : NEW_LINE INDENT if ( N < 6 ) : NEW_LINE INDENT temp = chr ( 48 + X ) * N NEW_LINE res = int ( temp ) % M ; NEW_LINE return res ; NEW_LINE DEDENT if ( N % 2 == 0 ) : NEW_LINE INDENT half = findModuloByM ( X , N \/\/ 2 , M ) % M ; NEW_LINE res = ( half * power ( 10 , N \/\/ 2 , M ) + half ) % M ; NEW_LINE return res ; NEW_LINE DEDENT else : NEW_LINE INDENT half = findModuloByM ( X , N \/\/ 2 , M ) % M ; NEW_LINE res = ( half * power ( 10 , N \/\/ 2 + 1 , M ) + half * 10 + X ) % M ; NEW_LINE return res ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT X = 6 ; N = 14 ; M = 9 ; NEW_LINE print ( findModuloByM ( X , N , M ) ) ; NEW_LINE DEDENT"],"bleu":0.7285369761645402,"rouge_l":0.8696912946293724}
{"id":911,"predictions":["def getTotalXorOfSubarrayXors ( arr , N ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i , N ) : NEW_LINE INDENT for k in range ( i , j + 1 ) : NEW_LINE INDENT res = res ^ arr [ k ] NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT arr = [ 3 , 5 , 2 , 4 , 6 ] NEW_LINE N = len ( arr ) NEW_LINE print ( getTotalXorOfSubarrayXors ( arr , N ) ) NEW_LINE"],"references":["def getTotalXorOfSubarrayXors ( arr , N ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( i , N ) : NEW_LINE INDENT for k in range ( i , j + 1 ) : NEW_LINE INDENT res = res ^ arr [ k ] NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT arr = [ 3 , 5 , 2 , 4 , 6 ] NEW_LINE N = len ( arr ) NEW_LINE print ( getTotalXorOfSubarrayXors ( arr , N ) ) NEW_LINE"],"bleu":0.96416321899136,"rouge_l":0.9879779595925865}
{"id":912,"predictions":["def innerCirclearea ( radius ) : NEW_LINE INDENT if ( radius < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT r = radius \/ 2 NEW_LINE Area = ( 3.14 * pow ( r , 2 ) ) NEW_LINE return Area NEW_LINE DEDENT radius = 4 NEW_LINE print ( \" Area ▁ of ▁ circle ▁ c2 ▁ = \" , innerCirclearea ( radius ) ) NEW_LINE"],"references":["def innerCirclearea ( radius ) : NEW_LINE INDENT if ( radius < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT r = radius \/ 2 ; NEW_LINE Area = ( 3.14 * pow ( r , 2 ) ) ; NEW_LINE return Area ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT radius = 4 ; NEW_LINE print ( \" Area ▁ of ▁ circle ▁ c2 ▁ = \" , innerCirclearea ( radius ) ) ; NEW_LINE DEDENT"],"bleu":0.6389942566598149,"rouge_l":0.8539257455873404}
{"id":913,"predictions":["if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT P , R , T = 1 , 1 , 1 NEW_LINE SI = ( P * T * R ) \/ 100 NEW_LINE print ( \" Specific ▁ interest ▁ = ▁ \" , SI ) NEW_LINE DEDENT"],"references":["P = 1 NEW_LINE R = 1 NEW_LINE T = 1 NEW_LINE SI = ( P * R * T ) \/ 100 NEW_LINE print ( \" simple ▁ interest ▁ is \" , SI ) NEW_LINE"],"bleu":0.3740890592135799,"rouge_l":0.6257598784194529}
{"id":914,"predictions":["def findSubArr ( arr , n ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT if ( abs ( arr [ i ] - arr [ i + 1 ] ) >= 2 ) : NEW_LINE INDENT print ( arr [ i ] , arr [ i + 1 ] ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( - 1 ) NEW_LINE DEDENT arr = [ 1 , 2 , 4 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE findSubArr ( arr , n ) NEW_LINE"],"references":["def findSubArr ( arr , n ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT if ( abs ( arr [ i ] - arr [ i + 1 ] ) >= 2 ) : NEW_LINE INDENT print ( arr [ i ] , arr [ i + 1 ] , end = \" \" ) ; NEW_LINE return ; NEW_LINE DEDENT DEDENT print ( - 1 ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 6 , 7 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE findSubArr ( arr , n ) ; NEW_LINE DEDENT"],"bleu":0.6926233550327904,"rouge_l":0.8691480081419017}
{"id":915,"predictions":["import math NEW_LINE def Min_glass ( n , k , a ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT ans = math . ceil ( sum \/ 100 ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n , k = 4 , 3 NEW_LINE a = [ 200 , 150 , 140 , 300 ] NEW_LINE a = sorted ( a ) NEW_LINE print ( Min_glass ( n , k , a ) ) NEW_LINE DEDENT"],"references":["from math import ceil NEW_LINE def Min_glass ( n , k , a ) : NEW_LINE INDENT a . sort ( ) NEW_LINE return ceil ( sum ( a [ : k ] ) \/ 100 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n , k = 4 , 3 NEW_LINE a = [ 200 , 150 , 140 , 300 ] NEW_LINE print ( Min_glass ( n , k , a ) ) NEW_LINE DEDENT"],"bleu":0.6335975581240426,"rouge_l":0.7725593667546173}
{"id":916,"predictions":["def findModulo ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE i = 0 NEW_LINE modulus = 0 NEW_LINE if ( s . count ( \" + \" ) in s ) : NEW_LINE INDENT i = s . find ( \" + \" ) NEW_LINE DEDENT real = s [ : i ] NEW_LINE imaginary = s [ i + 1 : l - 1 ] NEW_LINE x = int ( real ) NEW_LINE y = int ( imaginary ) NEW_LINE print ( math . sqrt ( x * x + y * y ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \"3 + 4i \"i \" NEW_LINE findModulo ( s ) NEW_LINE DEDENT"],"references":["from math import sqrt NEW_LINE def findModulo ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE modulus = 0 NEW_LINE if ( ' + ' in s ) : NEW_LINE INDENT i = s . index ( ' + ' ) NEW_LINE DEDENT else : NEW_LINE INDENT i = s . index ( ' - ' ) NEW_LINE DEDENT real = s [ 0 : i ] NEW_LINE imaginary = s [ i + 1 : l - 1 ] NEW_LINE x = int ( real ) NEW_LINE y = int ( imaginary ) NEW_LINE print ( int ( sqrt ( x * x + y * y ) ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \"3 + 4i \" NEW_LINE findModulo ( s ) NEW_LINE DEDENT"],"bleu":0.7252810632713278,"rouge_l":0.8207906644439154}
{"id":917,"predictions":["def printRepeating ( arr , size ) : NEW_LINE INDENT print ( \" The ▁ repeating ▁ elements ▁ are ▁ \" ) NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT if arr [ abs ( arr [ i ] ) ] > 0 : NEW_LINE INDENT arr [ abs ( arr [ i ] ) ] = - arr [ abs ( arr [ i ] ) ] NEW_LINE DEDENT else : NEW_LINE INDENT print ( abs ( arr [ i ] ) , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 4 , 2 , 4 , 5 , 2 , 3 , 1 ] NEW_LINE arr_size = len ( arr ) NEW_LINE printRepeating ( arr , arr_size ) NEW_LINE"],"references":["def printRepeating ( arr , size ) : NEW_LINE INDENT print ( \" ▁ The ▁ repeating ▁ elements ▁ are \" , end = \" ▁ \" ) NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT if ( arr [ abs ( arr [ i ] ) ] > 0 ) : NEW_LINE INDENT arr [ abs ( arr [ i ] ) ] = ( - 1 ) * arr [ abs ( arr [ i ] ) ] NEW_LINE DEDENT else : NEW_LINE INDENT print ( abs ( arr [ i ] ) , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 4 , 2 , 4 , 5 , 2 , 3 , 1 ] NEW_LINE arr_size = len ( arr ) NEW_LINE printRepeating ( arr , arr_size ) NEW_LINE"],"bleu":0.8544481214521767,"rouge_l":0.949080622347949}
{"id":918,"predictions":["def countZeros ( x ) : NEW_LINE INDENT n = 32 NEW_LINE y = x >> 16 NEW_LINE if ( y != 0 ) : NEW_LINE INDENT n = n - 16 NEW_LINE x = y NEW_LINE DEDENT y = x >> 8 NEW_LINE if ( y != 0 ) : NEW_LINE INDENT n = n - 8 NEW_LINE x = y NEW_LINE DEDENT y = x >> 4 NEW_LINE if ( y != 0 ) : NEW_LINE INDENT n = n - 4 NEW_LINE x = y NEW_LINE DEDENT y = x >> 2 NEW_LINE if ( y != 0 ) : NEW_LINE INDENT n = n - 2 NEW_LINE x = y NEW_LINE DEDENT y = x >> 1 NEW_LINE if ( y != 0 ) : NEW_LINE INDENT return n - 2 NEW_LINE DEDENT return n - x NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = 101 NEW_LINE print ( countZeros ( x ) ) NEW_LINE DEDENT"],"references":["def countZeros ( x ) : NEW_LINE INDENT n = 32 ; NEW_LINE y = x >> 16 ; NEW_LINE if ( y != 0 ) : NEW_LINE INDENT n = n - 16 ; NEW_LINE x = y ; NEW_LINE DEDENT y = x >> 8 ; NEW_LINE if ( y != 0 ) : NEW_LINE INDENT n = n - 8 ; NEW_LINE x = y ; NEW_LINE DEDENT y = x >> 4 ; NEW_LINE if ( y != 0 ) : NEW_LINE INDENT n = n - 4 ; NEW_LINE x = y ; NEW_LINE DEDENT y = x >> 2 ; NEW_LINE if ( y != 0 ) : NEW_LINE INDENT n = n - 2 ; NEW_LINE x = y ; NEW_LINE DEDENT y = x >> 1 ; NEW_LINE if ( y != 0 ) : NEW_LINE INDENT return n - 2 ; NEW_LINE DEDENT return n - x ; NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT x = 101 ; NEW_LINE print ( countZeros ( x ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"bleu":0.680670502842664,"rouge_l":0.8596846648462962}
{"id":919,"predictions":["def pairORSum ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 32 ) : NEW_LINE INDENT k1 = 0 NEW_LINE k0 = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( ( arr [ j ] & ( 1 << i ) ) != 0 ) : NEW_LINE INDENT k1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT k0 += 1 NEW_LINE DEDENT DEDENT ans = ans + ( 1 << i ) * ( k1 * ( k1 - 1 ) \/\/ 2 ) + ( 1 << i ) NEW_LINE DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( pairORSum ( arr , n ) ) NEW_LINE"],"references":["def pairORSum ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , 32 ) : NEW_LINE INDENT k1 = 0 NEW_LINE k0 = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( ( arr [ j ] & ( 1 << i ) ) ) : NEW_LINE INDENT k1 = k1 + 1 NEW_LINE DEDENT else : NEW_LINE INDENT k0 = k0 + 1 NEW_LINE DEDENT DEDENT ans = ans + ( 1 << i ) * ( k1 * ( k1 - 1 ) \/\/ 2 ) + ( 1 << i ) * ( k1 * k0 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( pairORSum ( arr , n ) ) NEW_LINE"],"bleu":0.836234505515823,"rouge_l":0.9241387049713837}
{"id":920,"predictions":["def binaryToDecimal ( n ) : NEW_LINE INDENT num = n NEW_LINE dec_value = 0 NEW_LINE base = 1 NEW_LINE l = len ( num ) NEW_LINE for i in range ( l - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( num [ i ] == '1' ) : NEW_LINE INDENT dec_value += base NEW_LINE DEDENT base = base * 2 NEW_LINE DEDENT return dec_value NEW_LINE DEDENT num = \"10101001001\" NEW_LINE print ( binaryToDecimal ( num ) ) NEW_LINE"],"references":["def binaryToDecimal ( n ) : NEW_LINE INDENT num = n ; NEW_LINE dec_value = 0 ; NEW_LINE base1 = 1 ; NEW_LINE len1 = len ( num ) ; NEW_LINE for i in range ( len1 - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( num [ i ] == '1' ) : NEW_LINE INDENT dec_value += base1 ; NEW_LINE DEDENT base1 = base1 * 2 ; NEW_LINE DEDENT return dec_value ; NEW_LINE DEDENT num = \"10101001\" ; NEW_LINE print ( binaryToDecimal ( num ) ) ; NEW_LINE"],"bleu":0.6273661057721968,"rouge_l":0.8636776184425486}
{"id":921,"predictions":["def countStrings ( n , k ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE dp [ 1 ] [ 0 ] = 1 NEW_LINE dp [ 1 ] [ 0 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT j = 0 NEW_LINE while j < i and j < k + 1 : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j ] [ 1 ] NEW_LINE dp [ i ] [ j ] = dp [ i - 1 ] [ j ] [ j ] [ 1 ] NEW_LINE if j - 1 >= 0 : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 NEW_LINE k = 2 NEW_LINE print ( countStrings ( n , k ) ) ) NEW_LINE DEDENT"],"references":["def countStrings ( n , k ) : NEW_LINE INDENT dp = [ [ [ 0 , 0 ] for __ in range ( k + 1 ) ] for _ in range ( n + 1 ) ] NEW_LINE dp [ 1 ] [ 0 ] [ 0 ] = 1 NEW_LINE dp [ 1 ] [ 0 ] [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( k + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] [ 0 ] = ( dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] ) NEW_LINE dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ] NEW_LINE if j >= 1 : NEW_LINE INDENT dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] [ 1 ] NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE k = 2 NEW_LINE print ( countStrings ( n , k ) ) NEW_LINE DEDENT"],"bleu":0.7730626950636229,"rouge_l":0.8638571526304987}
{"id":922,"predictions":["import sys NEW_LINE def print2largest ( arr , arr_size ) : NEW_LINE INDENT if ( arr_size < 2 ) : NEW_LINE INDENT print ( \" ▁ Invalid ▁ Input ▁ \" ) NEW_LINE return NEW_LINE DEDENT first , second = - sys . maxsize - 1 NEW_LINE for i in range ( arr_size ) : NEW_LINE INDENT if ( arr [ i ] > first ) : NEW_LINE INDENT first = first NEW_LINE first = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > second and arr [ i ] != second ) : NEW_LINE INDENT second = arr [ i ] NEW_LINE DEDENT DEDENT if ( arr [ i ] > second and arr [ i ] != first ) : NEW_LINE INDENT second = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" The ▁ secon ▁ largest ▁ largest \" , second ) NEW_LINE DEDENT DEDENT arr = [ 2 , 5 , 1 , 10 , 10 , 4 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print2largest ( arr , n ) NEW_LINE"],"references":["def print2largest ( arr , arr_size ) : NEW_LINE INDENT if ( arr_size < 2 ) : NEW_LINE INDENT print ( \" ▁ Invalid ▁ Input ▁ \" ) NEW_LINE return NEW_LINE DEDENT first = second = - 2147483648 NEW_LINE for i in range ( arr_size ) : NEW_LINE INDENT if ( arr [ i ] > first ) : NEW_LINE INDENT second = first NEW_LINE first = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > second and arr [ i ] != first ) : NEW_LINE INDENT second = arr [ i ] NEW_LINE DEDENT DEDENT if ( second == - 2147483648 ) : NEW_LINE INDENT print ( \" There ▁ is ▁ no ▁ second ▁ largest ▁ element \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" The ▁ second ▁ largest ▁ element ▁ is \" , second ) NEW_LINE DEDENT DEDENT arr = [ 12 , 35 , 1 , 10 , 34 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print2largest ( arr , n ) NEW_LINE"],"bleu":0.7488012478993868,"rouge_l":0.8303721382480331}
{"id":923,"predictions":["def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def print_gcd ( n , m , query , arr ) : NEW_LINE INDENT max_gcd = 0 NEW_LINE i = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT max_gcd = gcd ( max_gcd , arr [ i ] ) NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT query [ i ] [ 0 ] -= 1 NEW_LINE arr [ query [ i ] [ 0 ] ] \/\/= query [ i ] [ 1 ] NEW_LINE max_gcd = gcd ( arr [ query [ i ] [ 0 ] ] , max_gcd ) NEW_LINE print ( max_gcd ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE m = 3 NEW_LINE query = [ [ 0 for i in range ( 2 ) ] for i in range ( 2 ) ] NEW_LINE query = [ [ 0 ] [ 0 ] for i in range ( 2 ) ] NEW_LINE query [ 0 ] [ 1 ] = 1 NEW_LINE query [ 1 ] [ 0 ] = 2 NEW_LINE query [ 1 ] [ 1 ] = 2 NEW_LINE query [ 2 ] [ 0 ] = 2 NEW_LINE query [ 2 ] [ 0 ] = 4 NEW_LINE query [ 2 ] [ 1 ] = 4 NEW_LINE query [ 2 ] [ 1 ] = 4 NEW_LINE query [ 2 ] [ 1 ] = 4 NEW_LINE query [ 2 ] [ 1 ] = 4 NEW_LINE query [ 2 ] [ 1 ] = 4 NEW_LINE query [ 2 ] [ 1 ] = 4 NEW_LINE query [ 2 ] [ 1 ] = 4 NEW_LINE query [ 2 ] [ 1 ] = 4 NEW_LINE query [ 2 ] [ 1 ] = 4 NEW_LINE query [ 2 ] [ 1 ] = 4 NEW_LINE query [ 2 ] [ 1 ] = 4 NEW_LINE print_gcd_LINE DEDENT"],"references":["def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def print_gcd_online ( n , m , query , arr ) : NEW_LINE INDENT max_gcd = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT max_gcd = gcd ( max_gcd , arr [ i ] ) NEW_LINE DEDENT for i in range ( 0 , m ) : NEW_LINE INDENT query [ i ] [ 0 ] -= 1 NEW_LINE arr [ query [ i ] [ 0 ] ] \/\/= query [ i ] [ 1 ] NEW_LINE max_gcd = gcd ( arr [ query [ i ] [ 0 ] ] , max_gcd ) NEW_LINE print ( max_gcd ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n , m = 3 , 3 NEW_LINE query = [ [ 1 , 3 ] , [ 3 , 12 ] , [ 2 , 4 ] ] NEW_LINE arr = [ 36 , 24 , 72 ] NEW_LINE print_gcd_online ( n , m , query , arr ) NEW_LINE DEDENT"],"bleu":0.42089514492041924,"rouge_l":0.6443921284558735}
{"id":924,"predictions":["def countSubstr ( str , n , x , y ) : NEW_LINE INDENT tot_count = 0 NEW_LINE count_x = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str [ i ] == x ) : NEW_LINE INDENT count_x += 1 NEW_LINE DEDENT if ( str [ i ] == y ) : NEW_LINE INDENT tot_count += count_x NEW_LINE DEDENT DEDENT return tot_count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" abbcaceghcak \" NEW_LINE n = len ( str ) NEW_LINE x = ' a ' NEW_LINE y = ' c ' NEW_LINE print ( \" Count ▁ = \" , countSubstr ( str , n , x , y ) ) NEW_LINE DEDENT"],"references":["def countSubstr ( str , n , x , y ) : NEW_LINE INDENT tot_count = 0 NEW_LINE count_x = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if str [ i ] == x : NEW_LINE INDENT count_x += 1 NEW_LINE DEDENT if str [ i ] == y : NEW_LINE INDENT tot_count += count_x NEW_LINE DEDENT DEDENT return tot_count NEW_LINE DEDENT str = ' abbcaceghcak ' NEW_LINE n = len ( str ) NEW_LINE x , y = ' a ' , ' c ' NEW_LINE print ( ' Count ▁ = ' , countSubstr ( str , n , x , y ) ) NEW_LINE"],"bleu":0.6929414055080071,"rouge_l":0.8795660532820654}
{"id":925,"predictions":["def centered_cube ( n ) : NEW_LINE INDENT return ( 2 * n + 1 ) * ( n * n + n + 1 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE print ( n , \" th ▁ Centered \" , \" number : \" , centered_cube ( n ) ) NEW_LINE n = 10 NEW_LINE print ( n , \" th ▁ Centered \" , \" number : ▁ \" , cen_cube ( n ) ) NEW_LINE DEDENT"],"references":["def centered_cube ( n ) : NEW_LINE INDENT return ( 2 * n + 1 ) * ( n * n + n + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE print ( n , \" th ▁ Centered ▁ cube ▁ \" + \" number ▁ : ▁ \" , centered_cube ( n ) ) NEW_LINE n = 10 NEW_LINE print ( n , \" th ▁ Centered ▁ cube ▁ \" + \" number ▁ : ▁ \" , centered_cube ( n ) ) NEW_LINE DEDENT"],"bleu":0.732912539449,"rouge_l":0.895114223778556}
{"id":926,"predictions":["import math NEW_LINE MAX = 10000 NEW_LINE primes = [ ] NEW_LINE def sieveSundaram ( ) : NEW_LINE INDENT marked = [ False ] * ( MAX \/ 2 + 100 ) NEW_LINE for i in range ( 1 , int ( ( ( math . sqrt ( MAX ) - 1 ) \/ 2 ) + 1 ) : NEW_LINE INDENT for j in range ( ( i * ( i + 1 ) ) << 1 , 1 ) : NEW_LINE INDENT marked [ j ] = True NEW_LINE DEDENT DEDENT primes . append ( 2 ) NEW_LINE for i in range ( 1 , int ( MAX \/ 2 ) + 1 ) : NEW_LINE INDENT if ( marked [ i ] == False ) : NEW_LINE INDENT primes . append ( 2 * i + 1 ) NEW_LINE DEDENT DEDENT primes . append ( 2 ) NEW_LINE for i in range ( 1 , int ( math . sqrt ( MAX \/ 2 ) ) + 1 ) : NEW_LINE INDENT if ( marked [ i ] == False ) : NEW_LINE INDENT primes . append ( 2 * i + 1 ) NEW_LINE DEDENT DEDENT DEDENT def findPrimes ( n ) : NEW_LINE INDENT if ( n <= 2 or n % 2 != 0 ) : NEW_LINE INDENT print ( \" Invalid ▁ Input ▁ \" , diff , \" = \" , n ) NEW_LINE return NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT findPrimes ( 4 ) NEW_LINE findPrimes ( 4 ) NEW_LINE findPrimes ( 100 ) NEW_LINE findPrimes ( 100 ) NEW_LINE DEDENT"],"references":["import math NEW_LINE MAX = 10000 ; NEW_LINE primes = [ ] ; NEW_LINE def sieveSundaram ( ) : NEW_LINE INDENT marked = [ False ] * ( int ( MAX \/ 2 ) + 100 ) ; NEW_LINE for i in range ( 1 , int ( ( math . sqrt ( MAX ) - 1 ) \/ 2 ) + 1 ) : NEW_LINE INDENT for j in range ( ( i * ( i + 1 ) ) << 1 , int ( MAX \/ 2 ) + 1 , 2 * i + 1 ) : NEW_LINE INDENT marked [ j ] = True ; NEW_LINE DEDENT DEDENT primes . append ( 2 ) ; NEW_LINE for i in range ( 1 , int ( MAX \/ 2 ) + 1 ) : NEW_LINE INDENT if ( marked [ i ] == False ) : NEW_LINE INDENT primes . append ( 2 * i + 1 ) ; NEW_LINE DEDENT DEDENT DEDENT def findPrimes ( n ) : NEW_LINE INDENT if ( n <= 2 or n % 2 != 0 ) : NEW_LINE INDENT print ( \" Invalid ▁ Input \" ) ; NEW_LINE return ; NEW_LINE DEDENT i = 0 ; NEW_LINE while ( primes [ i ] <= n \/\/ 2 ) : NEW_LINE INDENT diff = n - primes [ i ] ; NEW_LINE if diff in primes : NEW_LINE INDENT print ( primes [ i ] , \" + \" , diff , \" = \" , n ) ; NEW_LINE return ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT DEDENT sieveSundaram ( ) ; NEW_LINE findPrimes ( 4 ) ; NEW_LINE findPrimes ( 38 ) ; NEW_LINE findPrimes ( 100 ) ; NEW_LINE"],"bleu":0.6773867720062348,"rouge_l":0.7260664046927501}
{"id":927,"predictions":["N = 100005 NEW_LINE d = [ 0 ] * N NEW_LINE pre = [ 0 ] * N NEW_LINE def Positive_Divisors ( ) : NEW_LINE INDENT for i in range ( 1 , N ) : NEW_LINE INDENT j = 1 NEW_LINE while ( j * j <= i ) : NEW_LINE INDENT if ( j * j == i ) : NEW_LINE INDENT d [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ i ] += 2 NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT if ( d [ i ] == d [ i - 1 ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT pre [ i ] = ans NEW_LINE DEDENT DEDENT DEDENT Positive_Divisors ( ) NEW_LINE n = 15 NEW_LINE print ( pre [ n ] ) NEW_LINE"],"references":["from math import sqrt ; NEW_LINE N = 100005 NEW_LINE d = [ 0 ] * N NEW_LINE pre = [ 0 ] * N NEW_LINE def Positive_Divisors ( ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( 1 , int ( sqrt ( i ) ) + 1 ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT if ( j * j == i ) : NEW_LINE INDENT d [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ i ] += 2 NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT if ( d [ i ] == d [ i - 1 ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT pre [ i ] = ans NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT Positive_Divisors ( ) NEW_LINE n = 15 NEW_LINE print ( pre [ n ] ) NEW_LINE DEDENT"],"bleu":0.7231890317310239,"rouge_l":0.8300910397700048}
{"id":928,"predictions":["def leibnizisonicTriangle ( n ) : NEW_LINE INDENT C = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , n ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( \"1 \/ \" , i * C [ i - 1 ] [ j - 1 ] , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE LibHarmHarmonicTriangle ( n ) NEW_LINE DEDENT"],"references":["def LeibnizHarmonicTriangle ( n ) : NEW_LINE INDENT C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] ; NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , min ( i , n ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) ; NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( \"1 \/ \" , end = \" \" ) ; NEW_LINE print ( i * C [ i - 1 ] [ j - 1 ] , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( ) ; NEW_LINE DEDENT DEDENT LeibnizHarmonicTriangle ( 4 ) ; NEW_LINE"],"bleu":0.7972212702196654,"rouge_l":0.8854991460953267}
{"id":929,"predictions":["def ansQueries ( prefe , prefodd , l , r ) : NEW_LINE INDENT if ( ( r - l + 1 ) % 2 == 0 ) : NEW_LINE INDENT print ( \"0\" ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( l % 2 == 0 ) : NEW_LINE INDENT print ( prefeven [ r ] ^ prefeven [ l - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT def wrapper ( arr , n , l , r , q ) : NEW_LINE INDENT prefodd = [ 0 ] * 100 NEW_LINE prefeven = [ 0 ] * 100 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( ( i ) % 2 == 0 ) : NEW_LINE INDENT prefeven [ i ] = arr [ i - 1 ] ^ prefeven [ i - 1 ] NEW_LINE prefodd [ i ] = prefodd [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT prefeven [ i ] = prefe [ i - 1 ] NEW_LINE prefodd [ i ] = prefodd [ i - 1 ] NEW_LINE DEDENT DEDENT i = 0 NEW_LINE while ( i != q ) : NEW_LINE INDENT ansQueries ( prefeven , prefodd , l [ i ] , r [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE l = [ 1 , 1 , 2 ] NEW_LINE r = len ( arr ) NEW_LINE wrapper ( arr , n , l , r , q ) NEW_LINE DEDENT"],"references":["N = 100 NEW_LINE def ansQueries ( prefeven , prefodd , l , r ) : NEW_LINE INDENT if ( ( r - l + 1 ) % 2 == 0 ) : NEW_LINE INDENT print ( \"0\" ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( l % 2 == 0 ) : NEW_LINE INDENT print ( prefeven [ r ] ^ prefeven [ l - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( prefodd [ r ] ^ prefodd [ l - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT def wrapper ( arr , n , l , r , q ) : NEW_LINE INDENT prefodd = [ 0 ] * N NEW_LINE prefeven = [ 0 ] * N NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( ( i ) % 2 == 0 ) : NEW_LINE INDENT prefeven [ i ] = arr [ i - 1 ] ^ prefeven [ i - 1 ] NEW_LINE prefodd [ i ] = prefodd [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT prefeven [ i ] = prefeven [ i - 1 ] NEW_LINE prefodd [ i ] = prefodd [ i - 1 ] ^ arr [ i - 1 ] NEW_LINE DEDENT DEDENT i = 0 NEW_LINE while ( i != q ) : NEW_LINE INDENT ansQueries ( prefeven , prefodd , l [ i ] , r [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE l = [ 1 , 1 , 2 ] NEW_LINE r = [ 2 , 3 , 4 ] NEW_LINE q = len ( l ) NEW_LINE wrapper ( arr , n , l , r , q ) NEW_LINE DEDENT"],"bleu":0.8313768188961851,"rouge_l":0.907662795520531}
{"id":930,"predictions":["def squaresum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( i * i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 4 NEW_LINE print ( squaresum ( n ) ) NEW_LINE"],"references":["def squaresum ( n ) : NEW_LINE INDENT sm = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sm = sm + ( i * i ) NEW_LINE DEDENT return sm NEW_LINE DEDENT n = 4 NEW_LINE print ( squaresum ( n ) ) NEW_LINE"],"bleu":0.7953312450737161,"rouge_l":0.9007225887527491}
{"id":931,"predictions":["MAX = 10 NEW_LINE def isFactorion ( n ) : NEW_LINE INDENT fact = [ 0 for i in range ( MAX ) ] NEW_LINE fact [ 0 ] = 1 NEW_LINE for i in range ( 1 , MAX ) : NEW_LINE INDENT fact [ i ] = i * fact [ i - 1 ] NEW_LINE DEDENT org = n NEW_LINE sum = 0 NEW_LINE while ( n ) : NEW_LINE INDENT d = n % 10 NEW_LINE sum += fact [ d ] NEW_LINE n \/\/= 10 NEW_LINE DEDENT if ( sum == org ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 40585 NEW_LINE if ( isFactorionion ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["MAX = 10 NEW_LINE def isFactorion ( n ) : NEW_LINE INDENT fact = [ 0 ] * MAX NEW_LINE fact [ 0 ] = 1 NEW_LINE for i in range ( 1 , MAX ) : NEW_LINE INDENT fact [ i ] = i * fact [ i - 1 ] NEW_LINE DEDENT org = n NEW_LINE sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT d = n % 10 NEW_LINE sum += fact [ d ] NEW_LINE n = n \/\/ 10 NEW_LINE DEDENT if ( sum == org ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT n = 40585 NEW_LINE if ( isFactorion ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.8005499145588093,"rouge_l":0.9045037069824057}
{"id":932,"predictions":["import math NEW_LINE def minInsertions ( H , n , K ) : NEW_LINE INDENT inser = 0 ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT diff = abs ( H [ i ] - H [ i - 1 ] ) ; NEW_LINE if ( diff <= K ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT else : NEW_LINE INDENT inser += math . ceil ( diff \/ K ) - 1 ; NEW_LINE DEDENT DEDENT return inser ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT H = [ 2 , 4 , 8 , 16 ] ; NEW_LINE K = 3 ; NEW_LINE n = len ( H ) ; NEW_LINE print ( minInsertions ( H , n , K ) ) ; NEW_LINE DEDENT"],"references":["import math NEW_LINE def minInsertions ( H , n , K ) : NEW_LINE INDENT inser = 0 ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT diff = abs ( H [ i ] - H [ i - 1 ] ) ; NEW_LINE if ( diff <= K ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT else : NEW_LINE INDENT inser += math . ceil ( diff \/ K ) - 1 ; NEW_LINE DEDENT DEDENT return inser ; NEW_LINE DEDENT H = [ 2 , 4 , 8 , 16 ] ; NEW_LINE K = 3 ; NEW_LINE n = len ( H ) ; NEW_LINE print ( minInsertions ( H , n , K ) ) ; NEW_LINE"],"bleu":0.8895655063027059,"rouge_l":0.9567741138693343}
{"id":933,"predictions":["def ReplaceElements ( arr , n ) : NEW_LINE INDENT X = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT X ^= arr [ i ] ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = X ^ arr [ i ] ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 3 , 3 , 5 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE ReplaceElements ( arr , n ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT"],"references":["def ReplaceElements ( arr , n ) : NEW_LINE INDENT X = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT X ^= arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = X ^ arr [ i ] NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 3 , 3 , 5 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE ReplaceElements ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.8621290426878425,"rouge_l":0.9772076061474343}
{"id":934,"predictions":["def makePalindrome ( string ) : NEW_LINE INDENT i , j = 0 , len ( string ) - 1 NEW_LINE while ( i <= j ) : NEW_LINE INDENT if ( string [ i ] == ' * ' and string [ j ] == ' * ' ) : NEW_LINE INDENT string [ i ] = ' a ' NEW_LINE string [ j ] = ' a ' NEW_LINE DEDENT elif ( string [ j ] == ' * ' ) : NEW_LINE INDENT string [ j ] = ' a ' NEW_LINE DEDENT elif ( string [ i ] == ' * ' ) : NEW_LINE INDENT string [ i ] = ' a ' NEW_LINE DEDENT elif ( string [ i ] == ' * ' ) : NEW_LINE INDENT string [ i ] = string [ j ] NEW_LINE DEDENT elif ( string [ i ] != string [ j ] ) : NEW_LINE INDENT return \" - 1\" NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return ' ' . join ( string ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" na * an \" NEW_LINE print ( makePalindrome ( string ) ) ) NEW_LINE DEDENT"],"references":["def makePalindrome ( str1 ) : NEW_LINE INDENT i = 0 NEW_LINE j = len ( str1 ) - 1 NEW_LINE str1 = list ( str1 ) NEW_LINE while ( i <= j ) : NEW_LINE INDENT if ( str1 [ i ] == ' * ' and str1 [ j ] == ' * ' ) : NEW_LINE INDENT str1 [ i ] = ' a ' NEW_LINE str1 [ j ] = ' a ' NEW_LINE DEDENT elif ( str1 [ j ] == ' * ' ) : NEW_LINE INDENT str1 [ j ] = str1 [ i ] NEW_LINE DEDENT elif ( str1 [ i ] == ' * ' ) : NEW_LINE INDENT str1 [ i ] = str1 [ j ] NEW_LINE DEDENT elif ( str1 [ i ] != str1 [ j ] ) : NEW_LINE INDENT str1 = ' ' . join ( str1 ) NEW_LINE return \" - 1\" NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT str1 = ' ' . join ( str1 ) NEW_LINE return str1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = \" na * an \" NEW_LINE print ( makePalindrome ( str1 ) ) NEW_LINE DEDENT"],"bleu":0.6111185263439403,"rouge_l":0.7888735843281298}
{"id":935,"predictions":["def countSubstr ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE auxArr = [ 0 ] * n NEW_LINE if ( s [ 0 ] == '1' ) : NEW_LINE INDENT auxArr [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT auxArr [ i ] = auxArr [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT auxArr [ i ] = auxArr [ i - 1 ] NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT count += auxArr [ i ] NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \"1101\" NEW_LINE print ( countSubstr ( s ) ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def countSubstr ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE auxArr = [ 0 for i in range ( n ) ] NEW_LINE if ( s [ 0 ] == '1' ) : NEW_LINE INDENT auxArr [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT auxArr [ i ] = auxArr [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT auxArr [ i ] = auxArr [ i - 1 ] NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT count += auxArr [ i ] NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT s = \"1101\" NEW_LINE print ( countSubstr ( s ) ) NEW_LINE"],"bleu":0.8733458336520917,"rouge_l":0.9205765696043339}
{"id":936,"predictions":["class Graph : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . graph = None NEW_LINE DEDENT DEDENT def addEdge ( self , v , w ) : NEW_LINE INDENT self . graph [ u ] . append ( v ) NEW_LINE DEDENT def BFS ( self , s ) : NEW_LINE INDENT visited = [ None ] * V NEW_LINE q = [ None ] * V NEW_LINE visited [ s ] = True NEW_LINE visited [ s ] = True NEW_LINE q . add ( s ) NEW_LINE while ( len ( q ) ) : NEW_LINE INDENT s = q . pop ( 0 ) NEW_LINE print ( s , end = \" ▁ \" ) NEW_LINE i = 0 NEW_LINE while ( i > 0 ) : NEW_LINE INDENT if ( visited [ i ] == False ) : NEW_LINE INDENT visited [ i ] = True NEW_LINE q . pop ( ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ ' : NEW_LINE INDENT g = Graph ( ) NEW_LINE g . addEdge ( 0 , 1 ) NEW_LINE g . addEdge ( 0 , 2 ) NEW_LINE g . addEdge ( 1 , 2 ) NEW_LINE g . addEdge ( 2 , 3 ) NEW_LINE g . addEdge ( 3 , 3 ) NEW_LINE g . addEdge ( 3 , 3 ) NEW_LINE g . addEdge ( 3 , 3 ) NEW_LINE print ( \" Following ▁ is ▁ pr , \" Given ▁ from ▁ from ▁ vertex ▁ 2 ) NEW_LINE g . BFS ( 2 ) NEW_LINE DFS ( 2 ) NEW_LINE DEDENT"],"references":["from collections import defaultdict NEW_LINE class Graph : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . graph = defaultdict ( list ) NEW_LINE DEDENT def addEdge ( self , u , v ) : NEW_LINE INDENT self . graph [ u ] . append ( v ) NEW_LINE DEDENT def BFS ( self , s ) : NEW_LINE INDENT visited = [ False ] * ( len ( self . graph ) ) NEW_LINE queue = [ ] NEW_LINE queue . append ( s ) NEW_LINE visited [ s ] = True NEW_LINE while queue : NEW_LINE INDENT s = queue . pop ( 0 ) NEW_LINE print ( s , end = \" ▁ \" ) NEW_LINE for i in self . graph [ s ] : NEW_LINE INDENT if visited [ i ] == False : NEW_LINE INDENT queue . append ( i ) NEW_LINE visited [ i ] = True NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT g = Graph ( ) NEW_LINE g . addEdge ( 0 , 1 ) NEW_LINE g . addEdge ( 0 , 2 ) NEW_LINE g . addEdge ( 1 , 2 ) NEW_LINE g . addEdge ( 2 , 0 ) NEW_LINE g . addEdge ( 2 , 3 ) NEW_LINE g . addEdge ( 3 , 3 ) NEW_LINE print ( \" Following ▁ is ▁ Breadth ▁ First ▁ Traversal \" \" ▁ ( starting ▁ from ▁ vertex ▁ 2 ) \" ) NEW_LINE g . BFS ( 2 ) NEW_LINE"],"bleu":0.6466262689307449,"rouge_l":0.7570191067149967}
{"id":937,"predictions":["def vowel_calc ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE arr = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT arr [ i ] = n NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = ( ( n - i ) + arr [ i - 1 ] - i ) NEW_LINE DEDENT DEDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ch = s [ i ] NEW_LINE if ( ch == ' a ' or ch == ' e ' or ch == ' o ' or ch == ' u ' ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT s = \" daceh \" NEW_LINE print ( vowel_calc ( s ) ) NEW_LINE"],"references":["def sumVowel ( string ) : NEW_LINE INDENT n = len ( string ) NEW_LINE sum = 0 NEW_LINE string = string . lower ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT s = string [ i ] NEW_LINE if ( s == \" a \" or s == \" e \" or s == \" i \" or s == \" o \" or s == \" u \" ) : NEW_LINE INDENT sum += ( ( n - i ) * ( i + 1 ) ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT string = \" abhay \" NEW_LINE print ( vovel ( string ) ) NEW_LINE DEDENT"],"bleu":0.30619114590866586,"rouge_l":0.4969022487379532}
{"id":938,"predictions":["def findOddPair ( A , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if A [ i ] % 2 == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count * ( N - count ) NEW_LINE DEDENT a = [ 5 , 4 , 7 , 2 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( findOddPair ( a , n ) ) NEW_LINE"],"references":["def findOddPair ( A , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( A [ i ] % 2 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count * ( N - count ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 5 , 4 , 7 , 2 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( findOddPair ( a , n ) ) NEW_LINE DEDENT"],"bleu":0.7445577509548996,"rouge_l":0.8865347574855543}
{"id":939,"predictions":["def smallestDivisor ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT for i in range ( 3 , n + 1 , 2 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT n = 31 NEW_LINE print ( smallestDivisor ( n ) ) NEW_LINE"],"references":["def smallestDivisor ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return 2 ; NEW_LINE DEDENT i = 3 ; NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT i += 2 ; NEW_LINE DEDENT return n ; NEW_LINE DEDENT n = 31 ; NEW_LINE print ( smallestDivisor ( n ) ) ; NEW_LINE"],"bleu":0.6119903448346672,"rouge_l":0.8062246855681092}
{"id":940,"predictions":["def areaOfKite ( d1 , d2 ) : NEW_LINE INDENT area = ( d1 * d2 ) \/ 2 NEW_LINE return area NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT d1 = 4 NEW_LINE d2 = 6 NEW_LINE print ( \" Area ▁ of ▁ Kite ▁ = \" , areaOfKite ( d1 , d2 ) ) NEW_LINE DEDENT"],"references":["def areaOfKite ( d1 , d2 ) : NEW_LINE INDENT area = ( d1 * d2 ) \/ 2 ; NEW_LINE return area ; NEW_LINE DEDENT d1 = 4 ; NEW_LINE d2 = 6 ; NEW_LINE print ( \" Area ▁ of ▁ Kite ▁ = ▁ \" , areaOfKite ( d1 , d2 ) ) ; NEW_LINE"],"bleu":0.6301261054754488,"rouge_l":0.848582129481006}
{"id":941,"predictions":["def isPossible ( v , str ) : NEW_LINE INDENT str1 = sorted ( str1 ) NEW_LINE for i in range ( len ( v ) - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , len ( v ) ) : NEW_LINE INDENT temp = v [ i ] + v [ j ] NEW_LINE temp = sortString ( temp ) NEW_LINE if temp < str1 : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT str1 = \" amazon \" NEW_LINE arr = [ \" fds \" , \" oxq \" , \" zoa \" , \" epw \" , \" amn \" ] NEW_LINE if ( isPossible ( v , str1 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def isPossible ( v , string ) : NEW_LINE INDENT char_list = list ( string ) NEW_LINE char_list . sort ( ) NEW_LINE for i in range ( len ( v ) - 1 ) : NEW_LINE INDENT for j in range ( len ( v ) ) : NEW_LINE INDENT temp = v [ i ] + v [ j ] ; NEW_LINE temp_list = list ( temp ) NEW_LINE temp_list . sort ( ) NEW_LINE if ( temp_list == char_list ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT DEDENT return False ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" amazon \" ; NEW_LINE v = [ \" fds \" , \" oxq \" , \" zoa \" , \" epw \" , \" amn \" ] ; NEW_LINE if ( isPossible ( v , string ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"],"bleu":0.5894411699100269,"rouge_l":0.792522066845185}
{"id":942,"predictions":["def seriessum ( n ) : NEW_LINE INDENT i = 1 NEW_LINE res = 0.0 NEW_LINE sign = True NEW_LINE while ( n ) : NEW_LINE INDENT n -= 1 NEW_LINE if ( sign == sign ) : NEW_LINE INDENT sign = not sign NEW_LINE res = res + int ( i \/ i ) NEW_LINE DEDENT else : NEW_LINE INDENT sign = not sign NEW_LINE res = res - int ( i \/ i ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT n = 5 NEW_LINE print ( seriessum ( n ) ) NEW_LINE"],"references":["def seriesSum ( n ) : NEW_LINE INDENT i = 1 ; NEW_LINE res = 0.0 ; NEW_LINE sign = True ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n = n - 1 ; NEW_LINE if ( sign ) : NEW_LINE INDENT sign = False ; NEW_LINE res = res + ( i + 1 ) \/ ( i + 2 ) ; NEW_LINE i = i + 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT sign = True ; NEW_LINE res = res - ( i + 1 ) \/ ( i + 2 ) ; NEW_LINE i = i + 2 ; NEW_LINE DEDENT DEDENT return res ; NEW_LINE DEDENT n = 5 ; NEW_LINE print ( round ( seriesSum ( n ) , 6 ) ) ; NEW_LINE"],"bleu":0.3552780924561539,"rouge_l":0.7082239115411195}
{"id":943,"predictions":["MAX = 1000000 NEW_LINE sieve_Prime = [ 0 ] * MAX + 4 ; NEW_LINE sieve_count = [ 0 ] * ( MAX + 4 ) ; NEW_LINE def form_sieve ( ) : NEW_LINE INDENT sieve_Prime [ 1 ] = 1 ; NEW_LINE for i in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if ( sieve_Prime [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i * 2 , MAX + 1 , i ) : NEW_LINE INDENT if ( sieve_Prime [ j ] == 0 ) : NEW_LINE INDENT sieve_Prime [ j ] = 1 ; NEW_LINE sieve_count [ i ] += 1 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT form_sieve ( ) ; NEW_LINE n = 2 ; NEW_LINE print ( \" Count ▁ = \" , ( sieve_count [ n ] + 1 ) ) ; NEW_LINE n = 3 ; NEW_LINE print ( \" Count ▁ = \" , ( sieve_count [ n ] + 1 ) ) ; NEW_LINE DEDENT"],"references":["MAX = 1000000 NEW_LINE sieve_Prime = [ 0 for i in range ( MAX + 4 ) ] NEW_LINE sieve_count = [ 0 for i in range ( MAX + 4 ) ] NEW_LINE def form_sieve ( ) : NEW_LINE INDENT sieve_Prime [ 1 ] = 1 NEW_LINE for i in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if sieve_Prime [ i ] == 0 : NEW_LINE INDENT for j in range ( i * 2 , MAX + 1 , i ) : NEW_LINE INDENT if sieve_Prime [ j ] == 0 : NEW_LINE INDENT sieve_Prime [ j ] = 1 NEW_LINE sieve_count [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT form_sieve ( ) NEW_LINE n = 2 NEW_LINE print ( \" Count ▁ = \" , sieve_count [ n ] + 1 ) NEW_LINE n = 3 NEW_LINE print ( \" Count ▁ = \" , sieve_count [ n ] + 1 ) NEW_LINE"],"bleu":0.652086447982469,"rouge_l":0.8736602485061179}
{"id":944,"predictions":["N = 4 NEW_LINE def MaximumDecimalValue ( mat , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE if ( mat [ 0 ] [ 0 ] == 1 ) : NEW_LINE INDENT dp [ 0 ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( mat [ 0 ] [ i ] == 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = ( dp [ 0 ] [ i - 1 ] + pow ( 2 , i ) ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( mat [ i ] [ 0 ] == 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = ( dp [ i - 1 ] [ 0 ] + pow ( 2 , i ) ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = ( max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) + pow ( 2 , i + 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n - 1 ] [ n - 1 ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT mat = [ [ 1 , 1 , 0 , 1 ] , [ 0 , 1 , 1 ] , [ 1 , 0 , 0 ,"],"references":["N = 4 NEW_LINE def MaximumDecimalValue ( mat , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE if ( mat [ 0 ] [ 0 ] == 1 ) : NEW_LINE INDENT dp [ 0 ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( mat [ 0 ] [ i ] == 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + 2 ** i NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( mat [ i ] [ 0 ] == 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + 2 ** i NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) + ( 2 ** ( i + j ) ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n - 1 ] [ n - 1 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT mat = [ [ 1 , 1 , 0 , 1 ] , [ 0 , 1 , 1 , 0 ] , [ 1 , 0 , 0 , 1 ] , [ 1 , 0 , 1 , 1 ] ] NEW_LINE print ( MaximumDecimalValue ( mat , 4 ) ) NEW_LINE DEDENT"],"bleu":0.8720846351894443,"rouge_l":0.9272019780308866}
{"id":945,"predictions":["MAX = 100 NEW_LINE def checkBilateral ( m , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( m [ i ] [ j ] != m [ j ] [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n - i ) : NEW_LINE INDENT if ( m [ i ] [ j ] != m [ n - j - 1 ] [ n - i - i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE m = [ [ 1 , 2 , 3 ] , [ 2 , 5 , 2 ] , [ 3 , 2 , 1 ] ] NEW_LINE if ( checkBilateral ( m , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def checkBisymmetric ( m , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , i ) : NEW_LINE INDENT if ( m [ i ] [ j ] != m [ j ] [ i ] ) : NEW_LINE INDENT return false NEW_LINE DEDENT DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n - i ) : NEW_LINE INDENT if ( m [ i ] [ j ] != m [ n - j - 1 ] [ n - i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True ; NEW_LINE DEDENT n = 3 ; NEW_LINE m = [ [ 1 , 2 , 3 ] , [ 2 , 5 , 2 ] , [ 3 , 2 , 1 ] ] NEW_LINE if ( checkBisymmetric ( m , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.8145045845971601,"rouge_l":0.9128072228724292}
{"id":946,"predictions":["def Divison ( a , n ) : NEW_LINE INDENT maxi = - 10 ** 9 NEW_LINE mini = - 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT maxi = max ( a [ i ] , maxi ) NEW_LINE mini = min ( a [ i ] , mini ) NEW_LINE DEDENT return maxi \/ mini NEW_LINE DEDENT a = [ 3 , 7 , 9 , 3 , 11 ] NEW_LINE n = len ( a ) NEW_LINE print ( Divison ( a , n ) ) NEW_LINE"],"references":["def Divison ( a , n ) : NEW_LINE INDENT maxi = - 10 ** 9 NEW_LINE mini = 10 ** 9 NEW_LINE for i in a : NEW_LINE INDENT maxi = max ( i , maxi ) NEW_LINE mini = min ( i , mini ) NEW_LINE DEDENT return maxi \/\/ mini NEW_LINE DEDENT a = [ 3 , 7 , 9 , 3 , 11 ] NEW_LINE n = len ( a ) NEW_LINE print ( Divison ( a , n ) ) NEW_LINE"],"bleu":0.7786039701743471,"rouge_l":0.9323144104803494}
{"id":947,"predictions":["MAX = 10 NEW_LINE F = [ [ [ - 1 for i in range ( MAX ) ] for j in range ( MAX ) ] for k in range ( MAX ) ] NEW_LINE C = [ 0 for i in range ( MAX ) ] NEW_LINE def noOfAssignments ( S , n , i , c_x ) : NEW_LINE INDENT if ( F [ i ] [ c_x ] != - 1 ) : NEW_LINE INDENT return F [ i ] [ c_x ] NEW_LINE DEDENT if ( i == n ) : NEW_LINE INDENT if ( c_x == 1 ) : NEW_LINE INDENT F [ i ] [ c_x ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT F [ i ] [ c_x ] = 1 NEW_LINE DEDENT return F [ i ] [ c_y ] NEW_LINE DEDENT c_y = C [ i ] - c_x NEW_LINE if ( S [ i ] == ' ( ' ) : NEW_LINE INDENT F [ i ] [ c_x ] = noOfAssignments ( S , n , i + 1 , i + 1 , c_x ) NEW_LINE return F [ i ] [ c_x ] NEW_LINE DEDENT F [ i ] [ c_x ] = 0 NEW_LINE if ( c_x == 1 ) : NEW_LINE INDENT F [ i ] [ c_x ] += noOfAssignments ( S , n , i + 1 , i + 1 , c_x ) NEW_LINE DEDENT if ( c_y == 1 ) : NEW_LINE INDENT F [ i ] [ c_x ] +=   \\ NEW_LINE INDENT noOfAssignments ( S , n , i + 1 , c_x ) NEW_LINE DEDENT return F [ i ] [ c_x ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = \" ( ) \" NEW_LINE n = len ( S ) NEW_LINE print ( noOfAssignments ( S , n , 0 ) ) NEW_LINE DEDENT"],"references":["MAX = 10 NEW_LINE F = [ [ - 1 for i in range ( MAX ) ] for j in range ( MAX ) ] NEW_LINE C = [ None ] * MAX NEW_LINE def noOfAssignments ( S , n , i , c_x ) : NEW_LINE INDENT if F [ i ] [ c_x ] != - 1 : NEW_LINE INDENT return F [ i ] [ c_x ] NEW_LINE DEDENT if i == n : NEW_LINE INDENT F [ i ] [ c_x ] = not c_x NEW_LINE return F [ i ] [ c_x ] NEW_LINE DEDENT c_y = C [ i ] - c_x NEW_LINE if S [ i ] == ' ( ' : NEW_LINE INDENT F [ i ] [ c_x ] =   \\ NEW_LINE INDENT noOfAssignments ( S , n , i + 1 , c_x + 1 ) +   \\ NEW_LINE noOfAssignments ( S , n , i + 1 , c_x ) NEW_LINE DEDENT return F [ i ] [ c_x ] NEW_LINE DEDENT F [ i ] [ c_x ] = 0 NEW_LINE if c_x : NEW_LINE INDENT F [ i ] [ c_x ] +=   \\ NEW_LINE INDENT noOfAssignments ( S , n , i + 1 , c_x - 1 ) NEW_LINE DEDENT DEDENT if c_y : NEW_LINE INDENT F [ i ] [ c_x ] +=   \\ NEW_LINE INDENT noOfAssignments ( S , n , i + 1 , c_x ) NEW_LINE DEDENT DEDENT return F [ i ] [ c_x ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = \" ( ) \" NEW_LINE n = len ( S ) NEW_LINE C [ 0 ] = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if S [ i ] == ' ( ' : NEW_LINE INDENT C [ i + 1 ] = C [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i + 1 ] = C [ i ] - 1 NEW_LINE DEDENT DEDENT print ( noOfAssignments ( S , n , 0 , 0 ) ) NEW_LINE DEDENT"],"bleu":0.7163031320090572,"rouge_l":0.7595570667156772}
{"id":948,"predictions":["def nextPowerOf2 ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE if ( n > 0 and ( n & ( n - 1 ) ) == 0 ) : NEW_LINE INDENT return n ; NEW_LINE DEDENT while ( n != 0 ) : NEW_LINE INDENT n >>= 1 ; NEW_LINE count += 1 ; NEW_LINE DEDENT return 1 << count ; NEW_LINE DEDENT n = 0 ; NEW_LINE print ( nextPowerOf2 ( n ) ) ; NEW_LINE"],"references":["def nextPowerOf2 ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE if ( n and not ( n & ( n - 1 ) ) ) : NEW_LINE INDENT return n NEW_LINE DEDENT while ( n != 0 ) : NEW_LINE INDENT n >>= 1 NEW_LINE count += 1 NEW_LINE DEDENT return 1 << count ; NEW_LINE DEDENT n = 0 NEW_LINE print ( nextPowerOf2 ( n ) ) NEW_LINE"],"bleu":0.7472055916959421,"rouge_l":0.9431620209059233}
{"id":949,"predictions":["from math import gcd NEW_LINE def nthElement ( a , b , n ) : NEW_LINE INDENT lcm = ( a * b ) \/\/ gcd ( a , b ) NEW_LINE l = 1 NEW_LINE r = min ( a , b ) NEW_LINE while ( l <= r ) : NEW_LINE INDENT mid = ( l + r ) \/\/ a NEW_LINE val = mid \/\/ a + mid \/\/ b - mid \/\/ lcm NEW_LINE if ( val == n ) : NEW_LINE INDENT return max ( mid \/\/ a , ( mid \/\/ a ) * ( mid \/\/ b ) * b ) NEW_LINE DEDENT if ( val < n ) : NEW_LINE INDENT l = mid \/\/ a , ( mid \/\/ b ) * b ) NEW_LINE DEDENT if ( val < n ) : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT if ( val < n ) : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = mid - 1 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT a = 5 NEW_LINE b = 3 NEW_LINE n = 5 NEW_LINE print ( nthElement ( a , b , n ) ) NEW_LINE"],"references":["import math NEW_LINE def nthElement ( a , b , n ) : NEW_LINE INDENT lcm = ( a * b ) \/ int ( math . gcd ( a , b ) ) NEW_LINE l = 1 NEW_LINE r = min ( a , b ) * n NEW_LINE while ( l <= r ) : NEW_LINE INDENT mid = ( l + r ) >> 1 NEW_LINE val = ( int ( mid \/ a ) + int ( mid \/ b ) - int ( mid \/ lcm ) ) NEW_LINE if ( val == n ) : NEW_LINE INDENT return int ( max ( int ( mid \/ a ) * a , int ( mid \/ b ) * b ) ) NEW_LINE DEDENT if ( val < n ) : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = mid - 1 NEW_LINE DEDENT DEDENT DEDENT a = 5 NEW_LINE b = 3 NEW_LINE n = 5 NEW_LINE print ( nthElement ( a , b , n ) ) NEW_LINE"],"bleu":0.6226195052556297,"rouge_l":0.7854523748614308}
{"id":950,"predictions":["MAX = 10000 ; NEW_LINE arr = [ ] ; NEW_LINE def SieveofEratosthenes ( ) : NEW_LINE INDENT prime = [ True ] * p ; NEW_LINE p = 2 ; NEW_LINE while ( p * p < MAX ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT DEDENT p += 1 ; NEW_LINE DEDENT for p in range ( 2 , MAX ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT arr . append ( p ) ; NEW_LINE DEDENT DEDENT DEDENT def isEuclid ( n ) : NEW_LINE INDENT product = 1 ; NEW_LINE i = 0 ; NEW_LINE while ( product < n ) : NEW_LINE INDENT product = product * arr [ i ] ; NEW_LINE if ( product + 1 == n ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT SieveOfEratosthenes ( ) ; NEW_LINE n = 31 ; NEW_LINE if ( isEuclid ( n ) ) : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE DEDENT n = 42 ; NEW_LINE if ( isEuclid ( n ) ) : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE DEDENT DEDENT"],"references":["MAX = 10000 NEW_LINE arr = [ ] NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime = [ True ] * MAX NEW_LINE p = 2 NEW_LINE while p * p < MAX : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT for p in range ( 2 , MAX ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT arr . append ( p ) NEW_LINE DEDENT DEDENT DEDENT def isEuclid ( n ) : NEW_LINE INDENT product = 1 NEW_LINE i = 0 NEW_LINE while ( product < n ) : NEW_LINE INDENT product = product * arr [ i ] NEW_LINE if ( product + 1 == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE n = 31 NEW_LINE if ( isEuclid ( n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT n = 42 NEW_LINE if ( isEuclid ( n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.780657440046562,"rouge_l":0.956788592684439}
{"id":951,"predictions":["def minElements ( arr , n ) : NEW_LINE INDENT halfSum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT halfSum = halfSum + arr [ i ] NEW_LINE DEDENT halfSum = halfSum \/\/ 2 NEW_LINE arr . sort ( ) NEW_LINE res = 0 NEW_LINE curr_sum = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT curr_sum += arr [ i ] NEW_LINE res += 1 NEW_LINE if ( curr_sum > halfSum ) : NEW_LINE INDENT return res NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT arr = [ 3 , 1 , 7 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minElements ( arr , n ) ) NEW_LINE"],"references":["def minElements ( arr , n ) : NEW_LINE INDENT halfSum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT halfSum = halfSum + arr [ i ] NEW_LINE DEDENT halfSum = int ( halfSum \/ 2 ) NEW_LINE arr . sort ( reverse = True ) NEW_LINE res = 0 NEW_LINE curr_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_sum += arr [ i ] NEW_LINE res += 1 NEW_LINE if curr_sum > halfSum : NEW_LINE INDENT return res NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT arr = [ 3 , 1 , 7 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minElements ( arr , n ) ) NEW_LINE"],"bleu":0.8471637179480254,"rouge_l":0.9323144104803494}
{"id":952,"predictions":["def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def lcm ( a , b ) : NEW_LINE INDENT return ( a * b ) \/ gcd ( a , b ) NEW_LINE DEDENT a = 15 NEW_LINE b = 20 NEW_LINE print ( ' LCM ▁ of ' , a , ' and ' , b , ' is ' , lcm ( a , b ) ) NEW_LINE"],"references":["def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def lcm ( a , b ) : NEW_LINE INDENT return ( a * b ) \/ gcd ( a , b ) NEW_LINE DEDENT a = 15 NEW_LINE b = 20 NEW_LINE print ( ' LCM ▁ of ' , a , ' and ' , b , ' is ' , lcm ( a , b ) ) NEW_LINE"],"bleu":1.0,"rouge_l":1.0}
{"id":953,"predictions":["MAX = 1000005 NEW_LINE prime = [ True for i in range ( MAX ) ] NEW_LINE def SieveofEratosthenes ( prime ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE prime [ 0 ] = False NEW_LINE for p in range ( 2 , int ( sqrt ( MAX ) ) + 1 ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def prime_xor ( arr , n , k ) : NEW_LINE INDENT for i in range ( MAX ) : NEW_LINE INDENT if prime [ arr [ i ] ] : NEW_LINE INDENT if ( ( i + 1 ) % k == 0 ) : NEW_LINE INDENT ans ^= arr [ i ] NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 3 , 5 , 7 , 11 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE K = 2 NEW_LINE prime_xor ( arr , n , K ) NEW_LINE DEDENT"],"references":["MAX = 1000005 NEW_LINE def SieveOfEratosthenes ( prime ) : NEW_LINE INDENT prime [ 1 ] = False ; NEW_LINE prime [ 0 ] = False ; NEW_LINE for p in range ( 2 , int ( MAX ** ( 1 \/ 2 ) ) ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def prime_xor ( arr , n , k ) : NEW_LINE INDENT prime = [ True ] * MAX ; NEW_LINE SieveOfEratosthenes ( prime ) ; NEW_LINE ans = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] ) : NEW_LINE INDENT if ( ( i + 1 ) % k == 0 ) : NEW_LINE INDENT ans ^= arr [ i ] ; NEW_LINE DEDENT DEDENT DEDENT print ( ans ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 3 , 5 , 7 , 11 , 8 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE K = 2 ; NEW_LINE prime_xor ( arr , n , K ) ; NEW_LINE DEDENT"],"bleu":0.7143479335766407,"rouge_l":0.8588382721509655}
{"id":954,"predictions":["def computeTotient ( n ) : NEW_LINE INDENT phi = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT phi [ i ] = i NEW_LINE DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( phi [ p ] == p ) : NEW_LINE INDENT phi [ p ] = p - 1 NEW_LINE for i in range ( 2 * p , n + 1 , p ) : NEW_LINE INDENT phi [ i ] = ( phi [ i ] \/\/ p ) * ( p - 1 ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( \" Total ▁ of \" , i , \" is \" , phi [ i ] ) NEW_LINE DEDENT DEDENT n = 12 NEW_LINE computeTotient ( n ) NEW_LINE"],"references":["def computeTotient ( n ) : NEW_LINE INDENT phi = [ ] NEW_LINE for i in range ( n + 2 ) : NEW_LINE INDENT phi . append ( 0 ) NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT phi [ i ] = i NEW_LINE DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( phi [ p ] == p ) : NEW_LINE INDENT phi [ p ] = p - 1 NEW_LINE for i in range ( 2 * p , n + 1 , p ) : NEW_LINE INDENT phi [ i ] = ( phi [ i ] \/\/ p ) * ( p - 1 ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( \" Totient ▁ of ▁ \" , i , \" ▁ is ▁ \" , phi [ i ] ) NEW_LINE DEDENT DEDENT n = 12 NEW_LINE computeTotient ( n ) NEW_LINE"],"bleu":0.8594445253107442,"rouge_l":0.9327921464980179}
{"id":955,"predictions":["def countDigit ( n ) : NEW_LINE INDENT temp = n NEW_LINE count = 0 NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT d = temp % 10 NEW_LINE temp \/\/= 10 NEW_LINE if ( d == 2 or d == 3 or d == 5 or d == 7 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT n = 1234567890 NEW_LINE print ( countDigit ( n ) ) NEW_LINE"],"references":["def countDigit ( n ) : NEW_LINE INDENT temp = n NEW_LINE count = 0 NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT d = temp % 10 NEW_LINE temp \/\/= 10 NEW_LINE if ( d == 2 or d == 3 or d == 5 or d == 7 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 1234567890 NEW_LINE print ( countDigit ( n ) ) NEW_LINE DEDENT"],"bleu":0.8192542263932164,"rouge_l":0.904218928164196}
{"id":956,"predictions":["def getChar ( str ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT sum += ( ord ( str [ i ] ) - ord ( ' a ' ) + 1 ) NEW_LINE DEDENT if ( sum % 26 == 0 ) : NEW_LINE INDENT return ' z ' NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum % 26 NEW_LINE return ( ord ( ' a ' ) + sum - 1 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" gfg \" NEW_LINE print ( getChar ( str ) ) NEW_LINE DEDENT"],"references":["def getChar ( strr ) : NEW_LINE INDENT summ = 0 NEW_LINE for i in range ( len ( strr ) ) : NEW_LINE INDENT summ += ( ord ( strr [ i ] ) - ord ( ' a ' ) + 1 ) NEW_LINE DEDENT if ( summ % 26 == 0 ) : NEW_LINE INDENT return ord ( ' z ' ) NEW_LINE DEDENT else : NEW_LINE INDENT summ = summ % 26 NEW_LINE return chr ( ord ( ' a ' ) + summ - 1 ) NEW_LINE DEDENT DEDENT strr = \" gfg \" NEW_LINE print ( getChar ( strr ) ) NEW_LINE"],"bleu":0.601795670839574,"rouge_l":0.8296285463585844}
{"id":957,"predictions":["def countWays ( n , arr ) : NEW_LINE INDENT count = [ 0 ] * ( n + 1 ) NEW_LINE count [ 0 ] = 1 NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT no_ways = 0 NEW_LINE for j in range ( l ) : NEW_LINE INDENT if ( i - arr [ j ] >= 0 ) : NEW_LINE INDENT no_ways += count [ i - arr [ j ] ] NEW_LINE DEDENT count [ i ] = no_ways NEW_LINE DEDENT DEDENT return count [ n ] NEW_LINE DEDENT arr = [ 1 , 3 , 5 ] NEW_LINE length = len ( arr ) NEW_LINE n = 5 NEW_LINE print ( countWays ( n , arr ) ) NEW_LINE"],"references":["def countWays ( n , arr ) : NEW_LINE INDENT count = [ 0 ] * ( n + 1 ) NEW_LINE count [ 0 ] = 1 NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT no_ways = 0 NEW_LINE for j in arr : NEW_LINE INDENT if ( i - j >= 0 ) : NEW_LINE INDENT no_ways += count [ i - j ] NEW_LINE DEDENT count [ i ] = no_ways NEW_LINE DEDENT DEDENT return count [ n ] NEW_LINE DEDENT arr = [ 1 , 3 , 5 ] NEW_LINE n = 5 NEW_LINE print ( countWays ( n , arr ) ) NEW_LINE"],"bleu":0.8368275267073878,"rouge_l":0.9438352826510721}
{"id":958,"predictions":["from collections import defaultdict NEW_LINE def primeOccurrence ( arr , k ) : NEW_LINE INDENT map = dict ( ) NEW_LINE for val in arr : NEW_LINE INDENT val = arr [ val ] NEW_LINE freq += 1 NEW_LINE DEDENT for key , value in map . items ( ) : NEW_LINE INDENT if ( isPrime ( value ) and value >= k ) : NEW_LINE INDENT print ( key ) NEW_LINE DEDENT DEDENT DEDENT def isPrime ( n ) : NEW_LINE INDENT if ( n > 2 and n % 2 == 0 ) or n == 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 3 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT arr = [ 11 , 11 , 11 , 23 , 11 , 37 , 37 , 51 , 51 , 51 , 51 ] NEW_LINE k = 2 NEW_LINE primeOccurrence ( arr , k ) NEW_LINE"],"references":["def primeOccurences ( arr , k ) : NEW_LINE INDENT map = { } NEW_LINE for val in arr : NEW_LINE INDENT freq = 0 NEW_LINE if val in map : NEW_LINE INDENT freq = map [ val ] NEW_LINE freq += 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq = 1 NEW_LINE DEDENT map [ val ] = freq NEW_LINE DEDENT for entry in map : NEW_LINE INDENT value = map [ entry ] NEW_LINE if isPrime ( value ) and value >= k : NEW_LINE INDENT print ( entry ) NEW_LINE DEDENT DEDENT DEDENT def isPrime ( n ) : NEW_LINE INDENT if ( n > 2 and not n % 2 ) or n == 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 3 , int ( n ** 0.5 + 1 ) , 2 ) : NEW_LINE INDENT if not n % i : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT arr = [ 11 , 11 , 11 , 23 , 11 , 37 , 37 , 51 , 51 , 51 , 51 , 51 ] NEW_LINE k = 2 NEW_LINE primeOccurences ( arr , k ) NEW_LINE"],"bleu":0.6261439553129983,"rouge_l":0.7802743414962552}
{"id":959,"predictions":["def Nth_Term ( n ) : NEW_LINE INDENT return ( 3 * pow ( n , 2 ) - n + 2 ) \/\/ ( 2 ) ) NEW_LINE DEDENT N = 5 NEW_LINE print ( Nth_Term ( N ) ) NEW_LINE"],"references":["def Nth_Term ( n ) : NEW_LINE INDENT return ( 3 * pow ( n , 2 ) - n + 2 ) \/\/ ( 2 ) NEW_LINE DEDENT N = 5 NEW_LINE print ( Nth_Term ( N ) ) NEW_LINE"],"bleu":0.9570496550137908,"rouge_l":0.9901029295328583}
{"id":960,"predictions":["import math NEW_LINE def sum ( n ) : NEW_LINE INDENT root = math . sqrt ( n ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , root + 1 ) : NEW_LINE INDENT ans += n \/ i NEW_LINE DEDENT ans = 2 * ans - ( root * root ) NEW_LINE return ans NEW_LINE DEDENT n = 35 NEW_LINE print ( sum ( n ) ) NEW_LINE"],"references":["import math NEW_LINE def sum ( n ) : NEW_LINE INDENT root = ( int ) ( math . sqrt ( n ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , root + 1 ) : NEW_LINE INDENT ans = ans + n \/\/ i NEW_LINE DEDENT ans = 2 * ans - ( root * root ) NEW_LINE return ans NEW_LINE DEDENT n = 35 NEW_LINE print ( sum ( n ) ) NEW_LINE"],"bleu":0.825300533363168,"rouge_l":0.9205100956429331}
{"id":961,"predictions":["n = int ( input ( ) ) NEW_LINE def isOibe ( num ) : NEW_LINE INDENT totalStr = str ( num ) NEW_LINE for i in range ( len ( numStr ) ) : NEW_LINE INDENT index = int ( num ** ( i ) + \" \" ) NEW_LINE cnt = 0 NEW_LINE for j in range ( 0 , len ( numberStr ) ) : NEW_LINE INDENT number = int ( numberStr [ j ] ) NEW_LINE if number == i : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if ( cnt != index ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def findNonBYS ( n ) : NEW_LINE INDENT low = 0 NEW_LINE low = pow ( 10.0 , n ) NEW_LINE high = pow ( 10.0 , n ) - 1.0 NEW_LINE for i in range ( low , high + 1 ) : NEW_LINE INDENT if ( isOibe ( i ) ) : NEW_LINE INDENT flag = 1 NEW_LINE print ( i , \" , \" , \" , \" , \" , \" ) NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT print ( \" There ▁ is ▁ no \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 4 NEW_LINE findOi ( N ) NEW_LINE DEDENT"],"references":["from math import pow NEW_LINE def isAutoBio ( num ) : NEW_LINE INDENT autoStr = str ( num ) NEW_LINE for i in range ( 0 , len ( autoStr ) ) : NEW_LINE INDENT index = int ( autoStr [ i ] ) NEW_LINE cnt = 0 NEW_LINE for j in range ( 0 , len ( autoStr ) ) : NEW_LINE INDENT number = int ( autoStr [ j ] ) NEW_LINE if number == i : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if cnt != index : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def findAutoBios ( n ) : NEW_LINE INDENT low = int ( pow ( 10 , n - 1 ) ) NEW_LINE high = int ( pow ( 10 , n ) - 1 ) NEW_LINE flag = 0 NEW_LINE for i in range ( low , high + 1 ) : NEW_LINE INDENT if isAutoBio ( i ) : NEW_LINE INDENT flag = 1 NEW_LINE print ( i , end = ' , ▁ ' ) NEW_LINE DEDENT DEDENT if flag == 0 : NEW_LINE INDENT print ( \" There ▁ is ▁ no ▁ Autobiographical ▁ Number ▁ with ▁ \" + str ( n ) + \" ▁ digits \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 0 NEW_LINE findAutoBios ( N ) NEW_LINE N = 4 NEW_LINE findAutoBios ( N ) NEW_LINE DEDENT"],"bleu":0.6297041136329163,"rouge_l":0.7713253495684753}
{"id":962,"predictions":["def isLucky ( n ) : NEW_LINE INDENT arr = [ True ] * 10 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT arr [ digit ] = False NEW_LINE DEDENT while ( n > 0 ) : NEW_LINE INDENT digit = n % 10 NEW_LINE if ( arr [ digit ] == arr [ digit ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT arr [ digit ] = True NEW_LINE n = n \/\/ 10 NEW_LINE DEDENT return True NEW_LINE DEDENT arr = [ 1291 , 897 , 4566 , 1232 , 80 , 700 ] NEW_LINE n = len ( arr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( isLucky ( arr [ i ] ) ) : NEW_LINE INDENT print ( arr [ i ] , \" is ▁ Odd \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ i ] , \" is ▁ not ▁ Bad \" ) NEW_LINE DEDENT DEDENT"],"references":["import math NEW_LINE def isLucky ( n ) : NEW_LINE INDENT ar = [ 0 ] * 10 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT digit = math . floor ( n % 10 ) NEW_LINE if ( ar [ digit ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ar [ digit ] = 1 NEW_LINE n = n \/ 10 NEW_LINE DEDENT return 1 NEW_LINE DEDENT arr = [ 1291 , 897 , 4566 , 1232 , 80 , 700 ] NEW_LINE n = len ( arr ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT k = arr [ i ] NEW_LINE if ( isLucky ( k ) ) : NEW_LINE INDENT print ( k , \" ▁ is ▁ Lucky ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( k , \" ▁ is ▁ not ▁ Lucky ▁ \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.5829473475361971,"rouge_l":0.7711367313915858}
{"id":963,"predictions":["def printSeriessumm ( N ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( i % 2 == 1 ) : NEW_LINE INDENT sum += i \/ ( i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT sum -= ( i + 1 ) NEW_LINE DEDENT DEDENT print ( sum ) NEW_LINE DEDENT N = 10 NEW_LINE printSeriessumm ( N ) NEW_LINE"],"references":["def printSeriesSum ( N ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( i & 1 ) : NEW_LINE INDENT sum += i \/ ( i + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT sum -= i \/ ( i + 1 ) ; NEW_LINE DEDENT DEDENT print ( sum ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 10 ; NEW_LINE printSeriesSum ( N ) ; NEW_LINE DEDENT"],"bleu":0.5715912689132534,"rouge_l":0.8107808750230755}
{"id":964,"predictions":["def power ( x , y , m ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT p = power ( x , y \/\/ 2 , m ) % m NEW_LINE p = ( p * p ) % m NEW_LINE p = ( p * p ) % m NEW_LINE return ( ( y * p ) == 0 ) NEW_LINE DEDENT def modInverse ( a , m ) : NEW_LINE INDENT if ( gcd ( a , m ) != 0 ) : NEW_LINE INDENT print ( \" Inverse ▁ doesn ' t ▁ exist \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Modular ▁ multiplicative ▁ inverse ▁ is \" , power ( a , m - 2 , m ) ) NEW_LINE DEDENT DEDENT a = 3 NEW_LINE m = 10 NEW_LINE modInverse ( a , m ) NEW_LINE"],"references":["def __gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return __gcd ( b , a % b ) NEW_LINE DEDENT DEDENT def power ( x , y , m ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT p = power ( x , y \/\/ 2 , m ) % m NEW_LINE p = ( p * p ) % m NEW_LINE return p if ( y % 2 == 0 ) else ( x * p ) % m NEW_LINE DEDENT def modInverse ( a , m ) : NEW_LINE INDENT if ( __gcd ( a , m ) != 1 ) : NEW_LINE INDENT print ( \" Inverse ▁ doesn ' t ▁ exist \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Modular ▁ multiplicative ▁ inverse ▁ is ▁ \" , power ( a , m - 2 , m ) ) NEW_LINE DEDENT DEDENT a = 3 NEW_LINE m = 11 NEW_LINE modInverse ( a , m ) NEW_LINE"],"bleu":0.6777133143083925,"rouge_l":0.7834241892266468}
{"id":965,"predictions":["from math import sqrt NEW_LINE def countPrimeFactors ( x ) : NEW_LINE INDENT res = 0 NEW_LINE if ( x % 2 == 0 ) : NEW_LINE INDENT res += 1 NEW_LINE while ( x % 2 == 0 ) : NEW_LINE INDENT x = x \/\/ 2 NEW_LINE DEDENT DEDENT for i in range ( 3 , int ( sqrt ( x ) ) + 1 , 2 ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT x = x \/\/ 2 NEW_LINE DEDENT DEDENT for i in range ( 3 , int ( sqrt ( x ) ) + 1 , 2 ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT res += 1 NEW_LINE while ( x % i == 0 ) : NEW_LINE INDENT x = x \/\/ i NEW_LINE DEDENT DEDENT DEDENT if ( x > 2 ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT def countCommonFactors ( a , b ) : NEW_LINE INDENT gcd = gcd ( a , b ) NEW_LINE return countPrimeFactors ( gcd ) NEW_LINE DEDENT a = 6 NEW_LINE b = 12 NEW_LINE print ( countCommonPrimeFactors ( a , b ) ) NEW_LINE"],"references":["from math import sqrt , gcd NEW_LINE def countPrimeFactors ( x ) : NEW_LINE INDENT res = 0 NEW_LINE if ( x % 2 == 0 ) : NEW_LINE INDENT res += 1 NEW_LINE while ( x % 2 == 0 ) : NEW_LINE INDENT x = x \/ 2 NEW_LINE DEDENT DEDENT k = int ( sqrt ( x ) ) + 1 NEW_LINE for i in range ( 3 , k , 2 ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT res += 1 NEW_LINE while ( x % i == 0 ) : NEW_LINE INDENT x = x \/ i NEW_LINE DEDENT DEDENT DEDENT if ( x > 2 ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT def countCommonPrimeFactors ( a , b ) : NEW_LINE INDENT gcd__ = gcd ( a , b ) NEW_LINE return countPrimeFactors ( gcd__ ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 6 NEW_LINE b = 12 NEW_LINE print ( countCommonPrimeFactors ( a , b ) ) NEW_LINE DEDENT"],"bleu":0.7229385358948415,"rouge_l":0.8358233594717293}
{"id":966,"predictions":["def factorial ( n ) : NEW_LINE INDENT return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 ) ; NEW_LINE DEDENT num = 5 ; NEW_LINE print ( \" Factorial ▁ of \" , num , \" is \" , factorial ( num ) ) ; NEW_LINE"],"references":["def factorial ( n ) : NEW_LINE INDENT return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 ) NEW_LINE DEDENT num = 5 NEW_LINE print ( \" Factorial ▁ of \" , num , \" is \" , factorial ( num ) ) NEW_LINE"],"bleu":0.8804416897348929,"rouge_l":0.9781341107871719}
{"id":967,"predictions":["def getFirstDigit ( x ) : NEW_LINE INDENT while ( x >= 10 ) : NEW_LINE INDENT x \/\/= 10 NEW_LINE DEDENT return x NEW_LINE DEDENT def getCountWithSameStartAndEndFrom1 ( x ) : NEW_LINE INDENT if ( x < 10 ) : NEW_LINE INDENT return x NEW_LINE DEDENT tens = tens + 9 NEW_LINE res = tens + 9 NEW_LINE firstDigit = x % 10 NEW_LINE if ( lastDigit < firstDigit ) : NEW_LINE INDENT res -= 1 NEW_LINE DEDENT return res NEW_LINE DEDENT def getCountWithSameStartAndEnd ( start , end ) : NEW_LINE INDENT return ( getCountWithSameStartAndEnd ( end ) - getDigit ( start - 1 ) ) NEW_LINE DEDENT start = 5 NEW_LINE end = 40 NEW_LINE print ( getCountWithSameStartAndEnd ( start , end ) ) NEW_LINE"],"references":["def getFirstDigit ( x ) : NEW_LINE INDENT while ( x >= 10 ) : NEW_LINE INDENT x \/= 10 NEW_LINE DEDENT return x NEW_LINE DEDENT def getCountWithSameStartAndEndFrom1 ( x ) : NEW_LINE INDENT if ( x < 10 ) : NEW_LINE INDENT return x NEW_LINE DEDENT tens = x \/ 10 NEW_LINE res = tens + 9 NEW_LINE firstDigit = getFirstDigit ( x ) NEW_LINE lastDigit = x % 10 NEW_LINE if ( lastDigit < firstDigit ) : NEW_LINE INDENT res = res - 1 NEW_LINE DEDENT return res NEW_LINE DEDENT def getCountWithSameStartAndEnd ( start , end ) : NEW_LINE INDENT return ( getCountWithSameStartAndEndFrom1 ( end ) - getCountWithSameStartAndEndFrom1 ( start - 1 ) ) NEW_LINE DEDENT start = 5 NEW_LINE end = 40 NEW_LINE print ( getCountWithSameStartAndEnd ( start , end ) ) NEW_LINE"],"bleu":0.8174416246560422,"rouge_l":0.9069508115475158}
{"id":968,"predictions":["def find_number ( N , K ) : NEW_LINE INDENT r = \" \" ; NEW_LINE if ( N % 100 == 0 ) : NEW_LINE INDENT N += 1 ; NEW_LINE r = str ( N ) ; NEW_LINE DEDENT else : NEW_LINE INDENT r = str ( N ) ; NEW_LINE DEDENT for i in range ( 1 , K + 1 ) : NEW_LINE INDENT r += \"00\" ; NEW_LINE DEDENT return r ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 1000 ; K = 2 ; NEW_LINE ans = find_number ( N , K ) ; NEW_LINE print ( ans ) ; NEW_LINE DEDENT"],"references":["def find_number ( N , K ) : NEW_LINE INDENT r = \" \" NEW_LINE if ( N % 100 == 0 ) : NEW_LINE INDENT N += 1 ; NEW_LINE r = str ( N ) NEW_LINE DEDENT else : NEW_LINE INDENT r = str ( N ) NEW_LINE DEDENT for i in range ( 1 , K + 1 ) : NEW_LINE INDENT r += \"00\" NEW_LINE DEDENT return r NEW_LINE DEDENT N = 1000 NEW_LINE K = 2 ; NEW_LINE ans = find_number ( N , K ) NEW_LINE print ( ans ) NEW_LINE"],"bleu":0.7030177459244481,"rouge_l":0.9090344613474076}
{"id":969,"predictions":["def digitSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while n > 0 : NEW_LINE INDENT sum += n % 10 NEW_LINE n = n \/\/ 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT def totalPairs ( arr1 , arr2 , n , m ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if digitSum ( arr1 [ i ] ) == digitSum ( arr2 [ i ] ) : NEW_LINE INDENT if ( arr1 [ i ] < arr2 [ j ] ) : NEW_LINE INDENT s . add ( ( arr1 [ i ] , arr2 [ j ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT s . add ( ( arr2 [ j ] , arr1 [ i ] ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return len ( s ) NEW_LINE DEDENT arr1 = [ 100 , 3 , 7 , 50 ] NEW_LINE arr2 = [ 5 , 1 , 10 , 4 ] NEW_LINE n = len ( arr1 ) NEW_LINE m = len ( arr2 ) NEW_LINE print ( totalPairs ( arr1 , arr2 , n , m ) ) NEW_LINE"],"references":["def digitSum ( n ) : NEW_LINE INDENT Sum = 0 NEW_LINE while n > 0 : NEW_LINE INDENT Sum += n % 10 NEW_LINE n = n \/\/ 10 NEW_LINE DEDENT return Sum NEW_LINE DEDENT def totalPairs ( arr1 , arr2 , n , m ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , m ) : NEW_LINE INDENT if digitSum ( arr1 [ i ] ) == digitSum ( arr2 [ j ] ) : NEW_LINE INDENT if arr1 [ i ] < arr2 [ j ] : NEW_LINE INDENT s . add ( ( arr1 [ i ] , arr2 [ j ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT s . add ( ( arr2 [ j ] , arr1 [ i ] ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return len ( s ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr1 = [ 100 , 3 , 7 , 50 ] NEW_LINE arr2 = [ 5 , 1 , 10 , 4 ] NEW_LINE n = len ( arr1 ) NEW_LINE m = len ( arr2 ) NEW_LINE print ( totalPairs ( arr1 , arr2 , n , m ) ) NEW_LINE DEDENT"],"bleu":0.8438798506341639,"rouge_l":0.9302635475273914}
{"id":970,"predictions":["N = 5 NEW_LINE def func ( idx , cur , cur , a , dp , n , x ) : NEW_LINE INDENT if ( idx == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ idx ] [ cur ] != - 1 ) : NEW_LINE INDENT return dp [ idx ] [ cur ] NEW_LINE DEDENT ans = 0 NEW_LINE if cur == 0 : NEW_LINE INDENT ans = max ( ans , a [ idx ] + func ( idx + 1 , 0 , a , dp , n , x ) ) NEW_LINE ans = max ( ans , x * a [ idx ] + func ( idx + 1 , 1 , a , dp , x ) ) NEW_LINE DEDENT elif ( cur == 1 ) : NEW_LINE INDENT ans = max ( ans , x * a [ idx ] + func ( idx + 1 , 1 , a , dp , n , x ) ) NEW_LINE ans = max ( ans , a [ idx ] + func ( idx + 1 , 2 , a , dp , x ) ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( ans , a [ idx ] + func ( idx + 1 , 2 , a , dp , n , x ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def getMaximumSum ( a ) : NEW_LINE INDENT dp = [ - 3 , 8 , - 2 , 1 , - 6 ] NEW_LINE n = len ( a ) NEW_LINE x = - 1 NEW_LINE print ( getMaximumSum ( a , n , x ) ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ - 3 , 8 , - 2 , 1 , - 6 ] NEW_LINE n = len ( a ) NEW_LINE x = - 1 NEW_LINE print ( getMaximumSum ( a , n , x ) ) NEW_LINE DEDENT"],"references":["N = 5 NEW_LINE def func ( idx , cur , a , dp , n , x ) : NEW_LINE INDENT if ( idx == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ idx ] [ cur ] != - 1 ) : NEW_LINE INDENT return dp [ idx ] [ cur ] NEW_LINE DEDENT ans = 0 NEW_LINE if ( cur == 0 ) : NEW_LINE INDENT ans = max ( ans , a [ idx ] + func ( idx + 1 , 0 , a , dp , n , x ) ) NEW_LINE ans = max ( ans , x * a [ idx ] + func ( idx + 1 , 1 , a , dp , n , x ) ) NEW_LINE DEDENT elif ( cur == 1 ) : NEW_LINE INDENT ans = max ( ans , x * a [ idx ] + func ( idx + 1 , 1 , a , dp , n , x ) ) NEW_LINE ans = max ( ans , a [ idx ] + func ( idx + 1 , 2 , a , dp , n , x ) ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( ans , a [ idx ] + func ( idx + 1 , 2 , a , dp , n , x ) ) NEW_LINE DEDENT dp [ idx ] [ cur ] = ans NEW_LINE return dp [ idx ] [ cur ] NEW_LINE DEDENT def getMaximumSum ( a , n , x ) : NEW_LINE INDENT dp = [ [ - 1 for i in range ( 3 ) ] for j in range ( n ) ] NEW_LINE maxi = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT maxi = max ( maxi , func ( i , 0 , a , dp , n , x ) ) NEW_LINE DEDENT return maxi NEW_LINE DEDENT a = [ - 3 , 8 , - 2 , 1 , - 6 ] NEW_LINE n = len ( a ) NEW_LINE x = - 1 NEW_LINE print ( getMaximumSum ( a , n , x ) ) NEW_LINE"],"bleu":0.7772558179861457,"rouge_l":0.8477938199973013}
{"id":971,"predictions":["def exponent ( A , B ) : NEW_LINE INDENT if ( A == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( B == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT y = 0 NEW_LINE if ( B % 2 == 0 ) : NEW_LINE INDENT y = exponent ( A , B \/ 2 ) NEW_LINE y = ( y * y ) NEW_LINE DEDENT else : NEW_LINE INDENT y = A NEW_LINE y = ( y * exponent ( A , B - 1 ) ) NEW_LINE DEDENT return y NEW_LINE DEDENT def sum ( k , n ) : NEW_LINE INDENT sum = exponent ( k , n + 1 ) - exponent ( k - 1 , n + 1 ) NEW_LINE return sum NEW_LINE DEDENT n = 3 NEW_LINE K = 3 NEW_LINE print ( sum ( K , n ) ) NEW_LINE"],"references":["def exponent ( A , B ) : NEW_LINE INDENT if ( A == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( B == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT if ( B % 2 == 0 ) : NEW_LINE INDENT y = exponent ( A , B \/ 2 ) ; NEW_LINE y = ( y * y ) ; NEW_LINE DEDENT else : NEW_LINE INDENT y = A ; NEW_LINE y = ( y * exponent ( A , B - 1 ) ) ; NEW_LINE DEDENT return y ; NEW_LINE DEDENT def sum ( k , n ) : NEW_LINE INDENT sum = exponent ( k , n + 1 ) - exponent ( k - 1 , n + 1 ) ; NEW_LINE return sum ; NEW_LINE DEDENT n = 3 ; NEW_LINE K = 3 ; NEW_LINE print ( sum ( K , n ) ) ; NEW_LINE"],"bleu":0.7990574516953352,"rouge_l":0.9383639954266706}
{"id":972,"predictions":["import math NEW_LINE MAX = 1000000 NEW_LINE primes = [ ] NEW_LINE def sieve ( ) : NEW_LINE INDENT nNew = int ( ( n ) \/ 2 ) NEW_LINE marked = [ False for i in range ( nNew + 100 ) ] NEW_LINE tmp = int ( math . sqrt ( n ) ) NEW_LINE for i in range ( 1 , int ( ( tmp ) \/ 2 ) + 1 ) : NEW_LINE INDENT for j in range ( ( ( ( i * ( i + 1 ) ) << 1 , nNew + 1 ) ) : NEW_LINE INDENT marked [ j ] = True NEW_LINE DEDENT DEDENT primes . append ( 2 ) NEW_LINE for i in range ( 1 , nNew + 1 ) : NEW_LINE INDENT if ( marked [ i ] == False ) : NEW_LINE INDENT primes . append ( 2 * i + 1 ) NEW_LINE DEDENT DEDENT primes . append ( 2 ) NEW_LINE for i in range ( 1 , nNew + 1 ) : NEW_LINE INDENT if ( marked [ i ] == False ) : NEW_LINE INDENT primes . append ( 2 * i + 1 ) NEW_LINE DEDENT DEDENT DEDENT def primeLcm ( arr , n ) : NEW_LINE INDENT factors = [ 0 ] * MAX NEW_LINE for i in range ( n ) : NEW_LINE INDENT copy = arr [ i ] NEW_LINE sqr = int ( sqrt ( copy ) ) NEW_LINE for j in range ( 0 , sqrt + 1 ) ) : NEW_LINE INDENT if ( copy % primes [ j ] == 0 ) : NEW_LINE INDENT while ( copy % primes [ j ] == 0 ) : NEW_LINE INDENT copy = copy \/\/ primes [ j ] NEW_LINE DEDENT factors [ primes [ primes [ j ] ] = 1 NEW_LINE DEDENT DEDENT if ( factors [ 2 ] == 1 ) : NEW_LINE INDENT factors [ copy ] = 1 NEW_LINE DEDENT DEDENT if ( factors [ 2 ] == 1 ) : NEW_LINE INDENT print ( \"2 ▁ \" , end = \" \" ) NEW_LINE DEDENT DEDENT if __name"],"references":["import math ; NEW_LINE MAX = 10000 ; NEW_LINE primes = [ ] ; NEW_LINE def sieve ( ) : NEW_LINE INDENT n = MAX ; NEW_LINE nNew = int ( n \/ 2 ) ; NEW_LINE marked = [ False ] * ( nNew + 100 ) ; NEW_LINE tmp = int ( math . sqrt ( n ) ) ; NEW_LINE for i in range ( 1 , int ( ( tmp - 1 ) \/ 2 ) + 1 ) : NEW_LINE INDENT for j in range ( ( i * ( i + 1 ) ) << 1 , nNew + 1 , 2 * i + 1 ) : NEW_LINE INDENT marked [ j ] = True ; NEW_LINE DEDENT DEDENT primes . append ( 2 ) ; NEW_LINE for i in range ( 1 , nNew + 1 ) : NEW_LINE INDENT if ( marked [ i ] == False ) : NEW_LINE INDENT primes . append ( 2 * i + 1 ) ; NEW_LINE DEDENT DEDENT DEDENT def primeLcm ( arr , n ) : NEW_LINE INDENT factors = [ 0 ] * ( MAX ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT copy = arr [ i ] ; NEW_LINE sqr = int ( math . sqrt ( copy ) ) ; NEW_LINE j = 0 ; NEW_LINE while ( primes [ j ] <= sqr ) : NEW_LINE INDENT if ( copy % primes [ j ] == 0 ) : NEW_LINE INDENT while ( copy % primes [ j ] == 0 ) : NEW_LINE INDENT copy = int ( copy \/ primes [ j ] ) ; NEW_LINE DEDENT factors [ primes [ j ] ] = 1 ; NEW_LINE DEDENT j += 1 ; NEW_LINE DEDENT if ( copy > 1 ) : NEW_LINE INDENT factors [ copy ] = 1 ; NEW_LINE DEDENT DEDENT if ( factors [ 2 ] == 1 ) : NEW_LINE INDENT print ( \"2 ▁ \" , end = \" \" ) ; NEW_LINE DEDENT for i in range ( 3 , MAX + 1 , 2 ) : NEW_LINE INDENT if ( factors [ i ] == 1 ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT DEDENT sieve ( ) ; NEW_LINE arr = [ 20 , 10 , 15 , 60 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE primeLcm ( arr , n ) ; NEW_LINE"],"bleu":0.6429037448571632,"rouge_l":0.7284398434952722}
{"id":973,"predictions":["defAlc ( n ) : NEW_LINE INDENT _n = n NEW_LINE ans = ( ( ( _n * _n ) \/ 12 ) - floor ( _n \/ 4 ) * floor ( _n + 2 ) * floor ( ( _n + 2 ) \/ 4 ) ) NEW_LINE return ans NEW_LINE DEDENT def solve ( n ) : NEW_LINE INDENT i = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( alcin ( i ) , end = \" , ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 10 NEW_LINE solve ( n ) NEW_LINE DEDENT"],"references":["from math import ceil , floor NEW_LINE def Alcuin ( n ) : NEW_LINE INDENT _n = n NEW_LINE ans = 0 NEW_LINE ans = ( round ( ( _n * _n ) \/ 12 ) - floor ( _n \/ 4 ) * floor ( ( _n + 2 ) \/ 4 ) ) NEW_LINE return ans NEW_LINE DEDENT def solve ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( Alcuin ( i ) , end = \" , ▁ \" ) NEW_LINE DEDENT DEDENT n = 15 NEW_LINE solve ( n ) NEW_LINE"],"bleu":0.7185582590332917,"rouge_l":0.8147502903600464}
{"id":974,"predictions":["def getMSB ( n ) : NEW_LINE INDENT n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE return ( ( n + 1 ) >> 2 ) NEW_LINE DEDENT def multiply ( F , M ) : NEW_LINE INDENT x = ( F [ 0 ] [ 0 ] * M [ 0 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 0 ] [ 1 ] + F [ 0 ] [ 1 ] ) NEW_LINE y = ( F [ 1 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 1 ] ) NEW_LINE z = ( F [ 1 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 1 ] [ 1 ] ) NEW_LINE F [ 0 ] [ 0 ] = x NEW_LINE F [ 1 ] [ 1 ] = y NEW_LINE F [ 1 ] [ 1 ] = z NEW_LINE F [ 1 ] [ 1 ] = z NEW_LINE DEDENT def power ( F , n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT M = [ [ 1 , 1 ] , [ 1 , 0 ] ] NEW_LINE for m in range ( getMSB ( n ) , 1 ) : NEW_LINE INDENT multiply ( F , F ) NEW_LINE if ( ( n & m ) ) : NEW_LINE INDENT multiply ( F , M ) NEW_LINE DEDENT DEDENT DEDENT def power ( n ) : NEW_LINE INDENT F = [ [ [ 1 , 1 ] , [ 1 , 0 ] ] NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT power ( F , n - 1 ) NEW_LINE return F [ 0 ] [ 1 ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 6 NEW_LINE print ( fib ( n ) ) NEW_LINE DEDENT"],"references":["def getMSB ( n ) : NEW_LINE INDENT n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE return ( ( n + 1 ) >> 2 ) NEW_LINE DEDENT def multiply ( F , M ) : NEW_LINE INDENT x = F [ 0 ] [ 0 ] * M [ 0 ] [ 0 ] + F [ 0 ] [ 1 ] * M [ 1 ] [ 0 ] NEW_LINE y = F [ 0 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 0 ] [ 1 ] * M [ 1 ] [ 1 ] NEW_LINE z = F [ 1 ] [ 0 ] * M [ 0 ] [ 0 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 0 ] NEW_LINE w = F [ 1 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 1 ] NEW_LINE F [ 0 ] [ 0 ] = x NEW_LINE F [ 0 ] [ 1 ] = y NEW_LINE F [ 1 ] [ 0 ] = z NEW_LINE F [ 1 ] [ 1 ] = w NEW_LINE DEDENT def power ( F , n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT M = [ [ 1 , 1 ] , [ 1 , 0 ] ] NEW_LINE m = getMSB ( n ) NEW_LINE while m : NEW_LINE INDENT multiply ( F , F ) NEW_LINE if ( n & m ) : NEW_LINE INDENT multiply ( F , M ) NEW_LINE DEDENT m = m >> 1 NEW_LINE DEDENT DEDENT def fib ( n ) : NEW_LINE INDENT F = [ [ 1 , 1 ] , [ 1 , 0 ] ] NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT power ( F , n - 1 ) NEW_LINE return F [ 0 ] [ 0 ] NEW_LINE DEDENT n = 6 NEW_LINE print ( fib ( n ) ) NEW_LINE"],"bleu":0.8222336586899894,"rouge_l":0.8576764878703936}
{"id":975,"predictions":["import sys NEW_LINE def printMinIndexChar ( str , patt ) : NEW_LINE INDENT minIndex = 10 ** 9 NEW_LINE m = len ( str ) NEW_LINE n = len ( str ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( patt [ i ] == str [ j ] and j < minIndex ) : NEW_LINE INDENT minIndex = j NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if ( minIndex != sys . maxsize - 1 ) : NEW_LINE INDENT print ( \" Minimum ▁ Index ▁ = ▁ \" , str ( minIndex ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No ▁ Special ▁ present ▁ = \" , str ( minIndex ) ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeksforgeeks \" NEW_LINE pat = \" seg \" NEW_LINE printMinIndexChar ( str , pat ) NEW_LINE DEDENT"],"references":["def printMinIndexChar ( Str , patt ) : NEW_LINE INDENT minIndex = 10 ** 9 NEW_LINE m = len ( Str ) NEW_LINE n = len ( patt ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( patt [ i ] == Str [ j ] and j < minIndex ) : NEW_LINE INDENT minIndex = j NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if ( minIndex != 10 ** 9 ) : NEW_LINE INDENT print ( \" Minimum ▁ Index ▁ Character ▁ = ▁ \" , Str [ minIndex ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No ▁ character ▁ present \" ) NEW_LINE DEDENT DEDENT Str = \" geeksforgeeks \" NEW_LINE patt = \" set \" NEW_LINE printMinIndexChar ( Str , patt ) NEW_LINE"],"bleu":0.6252416789292209,"rouge_l":0.820222339862361}
{"id":976,"predictions":["from math import ceil NEW_LINE def squares ( l , b , a ) : NEW_LINE INDENT return ( ( l \/\/ ( a ) * ceil ( b \/ ( a ) ) ) NEW_LINE DEDENT l = 11 NEW_LINE b = 23 NEW_LINE a = 14 NEW_LINE print ( squares ( l , b , a ) ) NEW_LINE"],"references":["import math NEW_LINE def squares ( l , b , a ) : NEW_LINE INDENT return math . ceil ( l \/ a ) * math . ceil ( b \/ a ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT l = 11 NEW_LINE b = 23 NEW_LINE a = 14 NEW_LINE print ( squares ( l , b , a ) ) NEW_LINE DEDENT"],"bleu":0.5853924494117062,"rouge_l":0.7637852155068625}
{"id":977,"predictions":["def insert ( self , new_data ) : NEW_LINE INDENT new_node = Node ( data = data ) NEW_LINE last = None NEW_LINE new_node . next = None NEW_LINE if self . head is not None : NEW_LINE INDENT new_node . prev = None NEW_LINE self . prev = None NEW_LINE DEDENT while last . next is not None : NEW_LINE INDENT new_node . next = None NEW_LINE DEDENT while last . next is not None : NEW_LINE INDENT last = current . next NEW_LINE DEDENT last . next = new_node NEW_LINE new_node . prev = last NEW_LINE return NEW_LINE DEDENT while last . next is not None : NEW_LINE INDENT last = last . next NEW_LINE DEDENT last . next = new_node NEW_LINE new_node . prev = last NEW_LINE new_node . prev = last NEW_LINE new_node . prev = last NEW_LINE new_node . prev = last NEW_LINE new_node . prev = last NEW_LINE new_node . prev = last NEW_LINE return NEW_LINE DEDENT"],"references":["def append ( self , new_data ) : NEW_LINE INDENT new_node = Node ( data = new_data ) NEW_LINE last = self . head NEW_LINE new_node . next = None NEW_LINE if self . head is None : NEW_LINE INDENT new_node . prev = None NEW_LINE self . head = new_node NEW_LINE return NEW_LINE DEDENT while ( last . next is not None ) : NEW_LINE INDENT last = last . next NEW_LINE DEDENT last . next = new_node NEW_LINE new_node . prev = last NEW_LINE DEDENT"],"bleu":0.4126074856473776,"rouge_l":0.668655473844873}
{"id":978,"predictions":["import sys NEW_LINE def maxProductSum ( str , m ) : NEW_LINE INDENT n = len ( str ) NEW_LINE maxProd = - sys . maxsize - 1 NEW_LINE maxSum = - 10 ** 9 NEW_LINE for i in range ( n - m ) : NEW_LINE INDENT product = 1 NEW_LINE sum = 0 NEW_LINE for j in range ( i , m + i ) : NEW_LINE INDENT product = product * ( ord ( str [ j ] ) - ord ( '0' ) ) NEW_LINE sum = sum + ( ord ( str [ j ] ) - ord ( '0' ) ) ) NEW_LINE DEDENT maxProd = max ( maxProd , product ) NEW_LINE maxSum = max ( maxSum , sum ) NEW_LINE DEDENT print ( \" Maximum ▁ Product ▁ = \" , maxSum ) NEW_LINE print ( \" Maximum ▁ Sum ▁ = ▁ \" , maxSum ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \"3675356\" NEW_LINE m = 5 NEW_LINE maxProductSum ( str , m ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE def maxProductSum ( string , m ) : NEW_LINE INDENT n = len ( string ) NEW_LINE maxProd , maxSum = ( - ( sys . maxsize ) - 1 , - ( sys . maxsize ) - 1 ) NEW_LINE for i in range ( n - m ) : NEW_LINE INDENT product , sum = 1 , 0 NEW_LINE for j in range ( i , m + i ) : NEW_LINE INDENT product = product * ( ord ( string [ j ] ) - ord ( '0' ) ) NEW_LINE sum = sum + ( ord ( string [ j ] ) - ord ( '0' ) ) NEW_LINE DEDENT maxProd = max ( maxProd , product ) NEW_LINE maxSum = max ( maxSum , sum ) NEW_LINE DEDENT print ( \" Maximum ▁ Product ▁ = \" , maxProd ) NEW_LINE print ( \" Maximum ▁ sum ▁ = \" , maxSum ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \"3675356291\" NEW_LINE m = 5 NEW_LINE maxProductSum ( string , m ) NEW_LINE DEDENT"],"bleu":0.7441666361488457,"rouge_l":0.8758000345960907}
{"id":979,"predictions":["def findNextNumber ( n ) : NEW_LINE INDENT temp = n ; NEW_LINE sum = 0 ; NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT sum += temp % 10 ; NEW_LINE temp = temp \/\/ 10 ; NEW_LINE DEDENT if ( sum < 10 ) : NEW_LINE INDENT print ( n , sum ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( n , \"0\" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 98732 ; NEW_LINE findSingleNumber ( n ) ; NEW_LINE DEDENT"],"references":["def findPhoneNumber ( n ) : NEW_LINE INDENT temp = n NEW_LINE sum = 0 NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT sum += temp % 10 NEW_LINE temp = temp \/\/ 10 NEW_LINE DEDENT if ( sum < 10 ) : NEW_LINE INDENT print ( n , \"0\" , sum ) NEW_LINE DEDENT else : NEW_LINE INDENT n = str ( n ) NEW_LINE sum = str ( sum ) NEW_LINE n += sum NEW_LINE print ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 98765432 NEW_LINE findPhoneNumber ( n ) NEW_LINE DEDENT"],"bleu":0.5847422520357328,"rouge_l":0.8007501172058135}
{"id":980,"predictions":["def countOfSubarrays ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE v = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT v [ arr [ i ] ] = i NEW_LINE DEDENT maximum = - 10 ** 9 NEW_LINE minimum = - 10 ** 9 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT maximum = max ( maximum , v [ i ] ) NEW_LINE minimum = min ( minimum , v [ i ] ) NEW_LINE if ( maximum - minimum < i ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 4 , 1 , 3 , 2 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countOfSubarrays ( arr , n ) ) NEW_LINE"],"references":["import sys NEW_LINE INT_MAX = sys . maxsize ; NEW_LINE INT_MIN = - ( sys . maxsize - 1 ) ; NEW_LINE def countOfSubarrays ( arr , n ) : NEW_LINE INDENT count = 0 ; NEW_LINE v = [ 0 ] * ( n + 1 ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT v [ arr [ i ] ] = i ; NEW_LINE DEDENT maximum = INT_MIN ; NEW_LINE minimum = INT_MAX ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT maximum = max ( maximum , v [ i ] ) ; NEW_LINE minimum = min ( minimum , v [ i ] ) ; NEW_LINE if ( maximum - minimum < i ) : NEW_LINE INDENT count = count + 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 4 , 1 , 3 , 2 , 5 , 6 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( countOfSubarrays ( arr , n ) ) ; NEW_LINE DEDENT"],"bleu":0.6169869294224174,"rouge_l":0.8010324216627422}
{"id":981,"predictions":["def maxSum ( p0 , p1 , a , a , pos , n ) : NEW_LINE INDENT if ( pos == n ) : NEW_LINE INDENT if ( p0 == p1 ) : NEW_LINE INDENT return p0 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT ans = maxSum ( p0 , p1 , a , pos + 1 , n ) NEW_LINE ans = max ( ans , maxSum ( p0 , p1 + a [ pos ] , a , pos + 1 , n ) ) NEW_LINE ans = max ( ans , maxSum ( p0 , p1 + a [ pos ] , a , pos + 1 , n ) ) NEW_LINE return ans NEW_LINE DEDENT n = 4 NEW_LINE a = [ 1 , 2 , 3 , 6 ] NEW_LINE print ( maxSum ( 0 , 0 , a , 0 , n ) ) NEW_LINE"],"references":["def maxSum ( p0 , p1 , a , pos , n ) : NEW_LINE INDENT if ( pos == n ) : NEW_LINE INDENT if ( p0 == p1 ) : NEW_LINE INDENT return p0 ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT ans = maxSum ( p0 , p1 , a , pos + 1 , n ) ; NEW_LINE ans = max ( ans , maxSum ( p0 + a [ pos ] , p1 , a , pos + 1 , n ) ) ; NEW_LINE ans = max ( ans , maxSum ( p0 , p1 + a [ pos ] , a , pos + 1 , n ) ) ; NEW_LINE return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 ; NEW_LINE a = [ 1 , 2 , 3 , 6 ] ; NEW_LINE print ( maxSum ( 0 , 0 , a , 0 , n ) ) ; NEW_LINE DEDENT"],"bleu":0.7604857031311294,"rouge_l":0.9026479750778816}
{"id":982,"predictions":["MAXN = 1000000 NEW_LINE def minimumSteps ( n , m , a , b ) : NEW_LINE INDENT if ( n > m ) : NEW_LINE INDENT return MAXN NEW_LINE DEDENT if ( n == m ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return min ( 1 + minimumSteps ( n * a , m , a , b ) , 1 + minimumSteps ( n * b , m , a , b ) ) NEW_LINE DEDENT n = 120 NEW_LINE m = 51840 NEW_LINE a = 2 NEW_LINE b = 3 NEW_LINE print ( minimumSteps ( n , m , a , b ) ) NEW_LINE"],"references":["MAXN = 10000000 NEW_LINE def minimumSteps ( n , m , a , b ) : NEW_LINE INDENT if ( n > m ) : NEW_LINE INDENT return MAXN NEW_LINE DEDENT if ( n == m ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return min ( 1 + minimumSteps ( n * a , m , a , b ) , 1 + minimumSteps ( n * b , m , a , b ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 120 NEW_LINE m = 51840 NEW_LINE a = 2 NEW_LINE b = 3 NEW_LINE print ( minimumSteps ( n , m , a , b ) ) NEW_LINE DEDENT"],"bleu":0.8487604193935252,"rouge_l":0.9210121627289248}
{"id":983,"predictions":["def printLargestString ( s , l , r ) : NEW_LINE INDENT freq = [ 0 ] * 26 NEW_LINE l -= 1 NEW_LINE r -= 1 NEW_LINE for i in range ( min ( l , r ) , max ( l , r ) ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT ans = \" \" NEW_LINE for i in range ( 25 , - 1 , - 1 ) : NEW_LINE INDENT while ( freq [ i ] > 0 ) : NEW_LINE INDENT ans += chr ( ord ( ' a ' ) + i ) NEW_LINE freq [ i ] -= 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT s = \" striver \" NEW_LINE l , r = 3 , 5 NEW_LINE print ( printLargestString ( s , l , r ) ) NEW_LINE"],"references":["def printLargestString ( s , l , r ) : NEW_LINE INDENT freq = [ 0 ] * 26 NEW_LINE l -= 1 NEW_LINE r -= 1 NEW_LINE for i in range ( min ( l , r ) , max ( l , r ) + 1 ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT ans = \" \" NEW_LINE for i in range ( 25 , - 1 , - 1 ) : NEW_LINE INDENT while ( freq [ i ] ) : NEW_LINE INDENT ans += chr ( ord ( ' a ' ) + i ) NEW_LINE freq [ i ] -= 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" striver \" NEW_LINE l = 3 NEW_LINE r = 5 NEW_LINE print ( printLargestString ( s , l , r ) ) NEW_LINE DEDENT"],"bleu":0.8450938843261576,"rouge_l":0.919750024799127}
{"id":984,"predictions":["def findsyPairs ( arr , n ) : NEW_LINE INDENT hm = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT first = arr [ i ] [ 0 ] NEW_LINE sec = arr [ i ] [ 1 ] NEW_LINE val = arr [ i ] [ 1 ] NEW_LINE val = hm . get ( sec ) NEW_LINE if ( val and val == first ) : NEW_LINE INDENT print ( \" ( \" , sec , \" , first , \" ) \" ) NEW_LINE DEDENT else : NEW_LINE INDENT hm [ first ] [ second ] = first NEW_LINE DEDENT DEDENT DEDENT arr = [ [ 0 for i in range ( 5 ) ] for i in range ( 5 ) ] NEW_LINE arr [ 0 ] [ 1 ] = 1 NEW_LINE arr [ 0 ] [ 1 ] = 2 NEW_LINE arr [ 1 ] [ 1 ] = 2 NEW_LINE arr [ 2 ] [ 0 ] = 1 NEW_LINE arr [ 2 ] [ 1 ] = 1 NEW_LINE arr [ 3 ] [ 0 ] = 1 NEW_LINE arr [ 3 ] [ 1 ] = 1 NEW_LINE arr [ 4 ] [ 1 ] = 1 NEW_LINE arr [ 4 ] [ 1 ] = 1 NEW_LINE arr [ 4 ] [ 1 ] = 1 NEW_LINE arr [ 4 ] [ 1 ] = 1 NEW_LINE findsyPairs ( arr ) NEW_LINE"],"references":["def findSymPairs ( arr , row ) : NEW_LINE INDENT hM = dict ( ) NEW_LINE for i in range ( row ) : NEW_LINE INDENT first = arr [ i ] [ 0 ] NEW_LINE sec = arr [ i ] [ 1 ] NEW_LINE if ( sec in hM . keys ( ) and hM [ sec ] == first ) : NEW_LINE INDENT print ( \" ( \" , sec , \" , \" , first , \" ) \" ) NEW_LINE DEDENT else : NEW_LINE INDENT hM [ first ] = sec NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ [ 0 for i in range ( 2 ) ] for i in range ( 5 ) ] NEW_LINE arr [ 0 ] [ 0 ] , arr [ 0 ] [ 1 ] = 11 , 20 NEW_LINE arr [ 1 ] [ 0 ] , arr [ 1 ] [ 1 ] = 30 , 40 NEW_LINE arr [ 2 ] [ 0 ] , arr [ 2 ] [ 1 ] = 5 , 10 NEW_LINE arr [ 3 ] [ 0 ] , arr [ 3 ] [ 1 ] = 40 , 30 NEW_LINE arr [ 4 ] [ 0 ] , arr [ 4 ] [ 1 ] = 10 , 5 NEW_LINE findSymPairs ( arr , 5 ) NEW_LINE DEDENT"],"bleu":0.59675932016137,"rouge_l":0.7304656141289805}
{"id":985,"predictions":["def fact ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT return res NEW_LINE DEDENT def nCr ( n , r ) : NEW_LINE INDENT return fact ( n ) \/\/ ( 1 * fact ( r ) * fact ( n - r ) ) NEW_LINE DEDENT def number_of_subsequences ( arr , k , n ) : NEW_LINE INDENT s = 0 NEW_LINE mp = dict ( ) NEW_LINE for i in mp : NEW_LINE INDENT mp [ arr [ i ] ] = mp . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT for j in mp . keys ( ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT return s NEW_LINE DEDENT arr = [ 1 , 1 , 1 , 1 , 2 , 2 ] NEW_LINE k = 2 NEW_LINE n = len ( arr ) NEW_LINE print ( number_of_subsequences ( arr , k , n ) ) NEW_LINE"],"references":["def fact ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT return res NEW_LINE DEDENT def nCr ( n , r ) : NEW_LINE INDENT return fact ( n ) \/\/ ( fact ( r ) * fact ( n - r ) ) NEW_LINE DEDENT def number_of_subsequences ( arr , k , n ) : NEW_LINE INDENT s = 0 NEW_LINE m = dict ( ) NEW_LINE for i in arr : NEW_LINE INDENT m [ i ] = m . get ( i , 0 ) + 1 NEW_LINE DEDENT for j in m : NEW_LINE INDENT s = s + nCr ( m [ j ] , k ) NEW_LINE DEDENT return s NEW_LINE DEDENT arr = [ 1 , 1 , 1 , 1 , 2 , 2 , 2 ] NEW_LINE k = 2 NEW_LINE n = len ( arr ) NEW_LINE print ( number_of_subsequences ( arr , k , n ) ) NEW_LINE"],"bleu":0.7947232884883336,"rouge_l":0.8884818157447949}
{"id":986,"predictions":["import numpy as np NEW_LINE SIZE = 26 NEW_LINE def SieveOfEratosthenes ( prime , p_size ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , p_size + 1 ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT for i in range ( p * 2 , p_size + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def printChar ( string , n ) : NEW_LINE INDENT prime = [ True for i in range ( n + 1 ) ] NEW_LINE SieveOfEratosthenes ( prime , len ( string ) + 1 ) NEW_LINE freq = [ 0 ] * SIZE NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( string [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT freq [ ord ( string [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if prime [ ord ( string [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" geeksforgeeks \" NEW_LINE n = len ( string ) NEW_LINE printChar ( string , n ) NEW_LINE DEDENT"],"references":["SIZE = 26 NEW_LINE from math import sqrt NEW_LINE def SieveOfEratosthenes ( prime , p_size ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( sqrt ( p_size ) ) , 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( p * 2 , p_size , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def printChar ( str , n ) : NEW_LINE INDENT prime = [ True for i in range ( n + 1 ) ] NEW_LINE SieveOfEratosthenes ( prime , len ( str ) + 1 ) NEW_LINE freq = [ 0 for i in range ( SIZE ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( prime [ freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] ] ) : NEW_LINE INDENT print ( str [ i ] , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" geeksforgeeks \" NEW_LINE n = len ( str ) NEW_LINE printChar ( str , n ) NEW_LINE DEDENT"],"bleu":0.7329032891824954,"rouge_l":0.831359062539804}
{"id":987,"predictions":["def calculateSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + ( 1 << i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 10 NEW_LINE print ( \" Sum ▁ of ▁ the ▁ series ▁ : ▁ \" , calculate ( n ) ) NEW_LINE"],"references":["def calculateSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum = sum + ( 1 << i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 10 NEW_LINE print ( \" Sum ▁ of ▁ series ▁ \" , calculateSum ( n ) ) NEW_LINE"],"bleu":0.8417632654340919,"rouge_l":0.9371967654986525}
{"id":988,"predictions":["def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT def SumOfPrimeDivisors ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( isPrime ( i ) ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 60 NEW_LINE print ( \" Sum ▁ of ▁ prime ▁ divisors ▁ of ▁ 60 ▁ is \" , SumOfPrimeDivisors ( n ) ) NEW_LINE DEDENT"],"references":["N = 1000005 NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT if n <= 3 : NEW_LINE INDENT return True NEW_LINE DEDENT if n % 2 == 0 or n % 3 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT def SumOfPrimeDivisors ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT if isPrime ( i ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT DEDENT return sum NEW_LINE DEDENT n = 60 NEW_LINE print ( \" Sum ▁ of ▁ prime ▁ divisors ▁ of ▁ 60 ▁ is ▁ \" + str ( SumOfPrimeDivisors ( n ) ) ) NEW_LINE"],"bleu":0.7649506363014619,"rouge_l":0.9161772109414331}
{"id":989,"predictions":["def elementCount ( arr1 , n1 , arr2 , n2 ) : NEW_LINE INDENT count = 0 NEW_LINE hash = dict ( ) NEW_LINE for i in range ( n2 ) : NEW_LINE INDENT hash [ arr2 [ i ] ] = 1 NEW_LINE DEDENT for i in range ( n1 ) : NEW_LINE INDENT j = 1 NEW_LINE while ( j * j <= arr1 [ i ] ) : NEW_LINE INDENT if ( j * j > arr1 [ len ( hash ) - 1 ] == 0 ) : NEW_LINE INDENT if ( j in hash ) : NEW_LINE INDENT if ( j in hash ) : NEW_LINE INDENT if ( j in hash and j != int ( hash . keys ( ) ) and ( arr1 [ i ] \/\/ j ) in hash . keys ( ) ) ) : NEW_LINE INDENT count += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT arr1 = [ 10 , 2 , 13 , 4 , 15 ] NEW_LINE arr2 = [ 2 , 4 , 5 , 6 ] NEW_LINE n1 = len ( arr1 ) NEW_LINE n2 = len ( arr2 ) NEW_LINE n2 = len ( arr2 ) NEW_LINE n2 = len ( arr2 ) NEW_LINE print ( elementCount ( arr1 , n1 , arr2 , n2 ) ) NEW_LINE"],"references":["from math import sqrt NEW_LINE def elementCount ( arr1 , arr2 ) : NEW_LINE INDENT count = 0 NEW_LINE hash = frozenset ( arr2 ) NEW_LINE for x in arr1 : NEW_LINE INDENT for j in range ( 1 , int ( sqrt ( x ) ) + 1 ) : NEW_LINE INDENT if x % j == 0 : NEW_LINE INDENT if ( j in hash or x \/ j in hash ) : NEW_LINE INDENT count += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT arr1 = [ 10 , 2 , 13 , 4 , 15 ] NEW_LINE arr2 = [ 2 , 4 , 5 , 6 ] NEW_LINE print ( elementCount ( arr1 , arr2 ) ) NEW_LINE"],"bleu":0.37368008971709843,"rouge_l":0.6131245771721272}
{"id":990,"predictions":["def countSubarrays ( arr , n , k ) : NEW_LINE INDENT s = 0 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( arr [ i ] > k ) : NEW_LINE INDENT i += 1 NEW_LINE continue NEW_LINE DEDENT count = 0 NEW_LINE while ( i < n and arr [ i ] <= k ) : NEW_LINE INDENT i += 1 NEW_LINE count += 1 NEW_LINE DEDENT s += ( count * ( count + 1 ) ) \/\/ 2 NEW_LINE DEDENT return ( n * ( n + 1 ) \/\/ 2 - s ) NEW_LINE DEDENT arr = [ 1 , 2 , 3 ] NEW_LINE k = 2 NEW_LINE n = len ( arr ) NEW_LINE print ( countSubarrays ( arr , n , k ) ) NEW_LINE"],"references":["def countSubarray ( arr , n , k ) : NEW_LINE INDENT s = 0 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( arr [ i ] > k ) : NEW_LINE INDENT i = i + 1 NEW_LINE continue NEW_LINE DEDENT count = 0 NEW_LINE while ( i < n and arr [ i ] <= k ) : NEW_LINE INDENT i = i + 1 NEW_LINE count = count + 1 NEW_LINE DEDENT s = s + ( ( count * ( count + 1 ) ) \/\/ 2 ) NEW_LINE DEDENT return ( n * ( n + 1 ) \/\/ 2 - s ) NEW_LINE DEDENT arr = [ 1 , 2 , 3 ] NEW_LINE k = 2 NEW_LINE n = len ( arr ) NEW_LINE print ( countSubarray ( arr , n , k ) ) NEW_LINE"],"bleu":0.8253652396959741,"rouge_l":0.9189822564445932}
{"id":991,"predictions":["def countNum ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] != arr [ i + 1 ] and arr [ i ] != arr [ i + 1 ] - 1 ) : NEW_LINE INDENT count += arr [ i + 1 ] - arr [ i ] - 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 3 , 5 , 8 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countNum ( arr , n ) ) NEW_LINE"],"references":["def countNum ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] != arr [ i + 1 ] and arr [ i ] != arr [ i + 1 ] - 1 ) : NEW_LINE INDENT count += arr [ i + 1 ] - arr [ i ] - 1 ; NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 3 , 5 , 8 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countNum ( arr , n ) ) NEW_LINE"],"bleu":0.9783983857244524,"rouge_l":0.9949381327334083}
{"id":992,"predictions":["def max_element ( a , n ) : NEW_LINE INDENT pre = [ 0 for i in range ( n ) ] NEW_LINE pre [ 0 ] = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT pre [ i ] = max ( pre [ i - 1 ] , a [ i ] ) NEW_LINE DEDENT suf = [ 0 ] * n NEW_LINE suf [ n - 1 ] = a [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT suf [ i ] = max ( suf [ i + 1 ] , a [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT print ( suf [ i + 1 ] , end = \" ▁ \" ) NEW_LINE DEDENT elif ( i == n - 1 ) : NEW_LINE INDENT print ( pre [ i - 1 ] , end = \" ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( max ( pre [ i - 1 ] , suf [ i + 1 ] ) , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT a = [ 2 , 5 , 6 , 1 , 3 ] NEW_LINE n = len ( a ) NEW_LINE max_element ( a , n ) NEW_LINE"],"references":["def max_element ( a , n ) : NEW_LINE INDENT pre = [ 0 ] * n ; NEW_LINE pre [ 0 ] = a [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT pre [ i ] = max ( pre [ i - 1 ] , a [ i ] ) ; NEW_LINE DEDENT suf = [ 0 ] * n ; NEW_LINE suf [ n - 1 ] = a [ n - 1 ] ; NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT suf [ i ] = max ( suf [ i + 1 ] , a [ i ] ) ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT print ( suf [ i + 1 ] , end = \" ▁ \" ) ; NEW_LINE DEDENT elif ( i == n - 1 ) : NEW_LINE INDENT print ( pre [ i - 1 ] , end = \" ▁ \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( max ( pre [ i - 1 ] , suf [ i + 1 ] ) , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 2 , 5 , 6 , 1 , 3 ] ; NEW_LINE n = len ( a ) ; NEW_LINE max_element ( a , n ) ; NEW_LINE DEDENT"],"bleu":0.8220626507505584,"rouge_l":0.9266493055555557}
{"id":993,"predictions":["def isRotated ( str1 , str2 ) : NEW_LINE INDENT if len ( str1 ) != len ( str2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT clock_rot = \" \" NEW_LINE anticun_rot = \" \" NEW_LINE l = len ( str2 ) NEW_LINE antic = ( str2 ) NEW_LINE for i in range ( len ( str2 ) ) : NEW_LINE INDENT if i == \" YES \" : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return \" NO \" NEW_LINE DEDENT DEDENT str1 = \" geeks \" NEW_LINE str2 = \" eksge \" NEW_LINE if ( isRotated ( str1 , str2 ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def isRotated ( str1 , str2 ) : NEW_LINE INDENT if ( len ( str1 ) != len ( str2 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT clock_rot = \" \" NEW_LINE anticlock_rot = \" \" NEW_LINE l = len ( str2 ) NEW_LINE anticlock_rot = ( anticlock_rot + str2 [ l - 2 : ] + str2 [ 0 : l - 2 ] ) NEW_LINE clock_rot = clock_rot + str2 [ 2 : ] + str2 [ 0 : 2 ] NEW_LINE return ( str1 == clock_rot or str1 == anticlock_rot ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" geeks \" NEW_LINE str2 = \" eksge \" NEW_LINE DEDENT if isRotated ( str1 , str2 ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.5602339090475333,"rouge_l":0.6916884000453566}
{"id":994,"predictions":["def findMax ( num ) : NEW_LINE INDENT size_of_int = 4 NEW_LINE num_copy = num NEW_LINE j = size_of_int * 8 - 1 NEW_LINE i = 0 NEW_LINE while ( i < j ) : NEW_LINE INDENT m = ( num_copy >> i ) & 1 NEW_LINE n = ( num_copy >> j ) & 1 NEW_LINE if ( m > n ) : NEW_LINE INDENT x = ( 1 << i ) NEW_LINE num = num ^ x NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return num NEW_LINE DEDENT num = 4 NEW_LINE print ( findMax ( num ) ) NEW_LINE"],"references":["def findMax ( num ) : NEW_LINE INDENT num_copy = num NEW_LINE j = 4 * 8 - 1 ; NEW_LINE i = 0 NEW_LINE while ( i < j ) : NEW_LINE INDENT m = ( num_copy >> i ) & 1 NEW_LINE n = ( num_copy >> j ) & 1 NEW_LINE if ( m > n ) : NEW_LINE INDENT x = ( 1 << i | 1 << j ) NEW_LINE num = num ^ x NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return num NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT num = 4 NEW_LINE print ( findMax ( num ) ) NEW_LINE DEDENT"],"bleu":0.7689478387693344,"rouge_l":0.8793890950613759}
{"id":995,"predictions":["def check ( s , l ) : NEW_LINE INDENT pos = [ ] NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT pos . append ( i ) NEW_LINE DEDENT DEDENT t = len ( pos ) NEW_LINE for i in range ( 1 , t ) : NEW_LINE INDENT if ( ( pos [ i ] - pos [ i - 1 ] ) != ( pos [ 1 ] - pos [ 0 ] ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \"100010001000\" NEW_LINE l = len ( s ) NEW_LINE if ( check ( s , l ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def check ( s , l ) : NEW_LINE INDENT pos = [ ] NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT pos . append ( i ) NEW_LINE DEDENT DEDENT t = len ( pos ) NEW_LINE for i in range ( 1 , t ) : NEW_LINE INDENT if ( ( pos [ i ] - pos [ i - 1 ] ) != ( pos [ 1 ] - pos [ 0 ] ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT s = \"100010001000\" NEW_LINE l = len ( s ) NEW_LINE if ( check ( s , l ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.9039403884781372,"rouge_l":0.962678609511623}
{"id":996,"predictions":["def maximum_one ( s , n ) : NEW_LINE INDENT cnt_one = 0 NEW_LINE max_cnt = 0 NEW_LINE temp = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT cnt_one += 1 NEW_LINE temp += 1 NEW_LINE DEDENT else : NEW_LINE INDENT max_cnt = max ( max_cnt , temp ) NEW_LINE temp = 0 NEW_LINE DEDENT DEDENT max_cnt = max ( max_cnt , temp ) NEW_LINE left = [ 0 for i in range ( n ) ] NEW_LINE if ( s [ 0 ] == '1' ) : NEW_LINE INDENT left [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT left [ 0 ] = 0 NEW_LINE DEDENT if ( s [ n - 1 ] == '1' ) : NEW_LINE INDENT left [ n - 1 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT right [ n - 1 ] = 0 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT left [ i ] = left [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT left [ i ] = 0 NEW_LINE DEDENT DEDENT for i in range ( n - 2 , - 1 ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT right [ i ] = ( left [ i - 1 ] + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT right [ i ] = 0 NEW_LINE DEDENT DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT sum = left [ i - 1 ] + right [ i + 1 ] NEW_LINE if ( sum < cnt_one ) : NEW_LINE INDENT max_cnt = ( max_cnt , sum + 1 ) NEW_LINE DEDENT else : NEW_"],"references":["def maximum_one ( s , n ) : NEW_LINE INDENT cnt_one = 0 NEW_LINE cnt , max_cnt = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT cnt_one += 1 NEW_LINE cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT max_cnt = max ( max_cnt , cnt ) NEW_LINE cnt = 0 NEW_LINE DEDENT DEDENT max_cnt = max ( max_cnt , cnt ) NEW_LINE left = [ 0 ] * n NEW_LINE right = [ 0 ] * n NEW_LINE if ( s [ 0 ] == '1' ) : NEW_LINE INDENT left [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT left [ 0 ] = 0 NEW_LINE DEDENT if ( s [ n - 1 ] == '1' ) : NEW_LINE INDENT right [ n - 1 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT right [ n - 1 ] = 0 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT left [ i ] = left [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT left [ i ] = 0 NEW_LINE DEDENT DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT right [ i ] = right [ i + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT right [ i ] = 0 NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT sum = left [ i - 1 ] + right [ i + 1 ] NEW_LINE if ( sum < cnt_one ) : NEW_LINE INDENT max_cnt = max ( max_cnt , sum + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT max_cnt = max ( max_cnt , sum ) NEW_LINE DEDENT DEDENT DEDENT return max_cnt NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \"111011101\" NEW_LINE print ( maximum_one ( s , len ( s ) ) ) NEW_LINE DEDENT"],"bleu":0.7538139960314603,"rouge_l":0.8584661975594549}
{"id":997,"predictions":["from math import ceil , ceil NEW_LINE def nDigitPerfectCubes ( n ) : NEW_LINE INDENT print ( pow ( 10 , ceil ( pow ( 10 , ( 10 , ( n - 1 ) ) ) ) , end = \" ▁ \" ) ; NEW_LINE print ( pow ( 10 , ( 10 ** ( n - 1 ) ) ) - 1 , 3 ) ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE nDigitPerfectCubes ( n ) ; NEW_LINE DEDENT"],"references":["from math import ceil NEW_LINE def nDigitPerfectCubes ( n ) : NEW_LINE INDENT print ( pow ( ceil ( ( pow ( 10 , ( n - 1 ) ) ) ** ( 1 \/ 3 ) ) , 3 ) , end = \" ▁ \" ) NEW_LINE print ( pow ( ceil ( ( pow ( 10 , ( n ) ) ) ** ( 1 \/ 3 ) ) - 1 , 3 ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE nDigitPerfectCubes ( n ) NEW_LINE DEDENT"],"bleu":0.6917626897417901,"rouge_l":0.8189259986902422}
{"id":998,"predictions":["def isMultipleof5 ( n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT n <<= 1 ; NEW_LINE DEDENT x = n ; NEW_LINE x = ( ( x * 0.1 ) ) * 10 ; NEW_LINE if ( x == n ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT i = 19 ; NEW_LINE if ( isMultipleof5 ( i ) == True ) : NEW_LINE INDENT print ( i , \" is ▁ multiple ▁ of ▁ 5\" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( i , \" is ▁ not ▁ a ▁ multiple ▁ of ▁ 5\" ) ; NEW_LINE DEDENT"],"references":["def isMultipleof5 ( n ) : NEW_LINE INDENT if ( ( n & 1 ) == 1 ) : NEW_LINE INDENT n <<= 1 ; NEW_LINE DEDENT x = n NEW_LINE x = ( ( int ) ( x * 0.1 ) ) * 10 NEW_LINE if ( x == n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT i = 19 NEW_LINE if ( isMultipleof5 ( i ) == 1 ) : NEW_LINE INDENT print ( i , \" is ▁ multiple ▁ of ▁ 5\" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( i , \" is ▁ not ▁ a ▁ multiple ▁ of ▁ 5\" ) NEW_LINE DEDENT"],"bleu":0.791958021851162,"rouge_l":0.9145299145299145}
{"id":999,"predictions":["def minsteps ( n , m ) : NEW_LINE INDENT if ( m > n ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( ( n + 1 ) \/ 2 + m - 1 ) \/ m * m ; NEW_LINE DEDENT DEDENT n = 17 ; m = 4 ; NEW_LINE ans = minsteps ( n , m ) ; NEW_LINE print ( ans ) ; NEW_LINE"],"references":["def minsteps ( n , m ) : NEW_LINE INDENT if ( m > n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( n + 1 ) \/\/ 2 + m - 1 ) \/\/ m * m ; NEW_LINE DEDENT DEDENT n = 17 NEW_LINE m = 4 NEW_LINE ans = minsteps ( n , m ) NEW_LINE print ( ans ) NEW_LINE"],"bleu":0.7566107776175187,"rouge_l":0.9318131503210095}
{"id":1000,"predictions":["from math import sqrt NEW_LINE def gridStr ( st ) : NEW_LINE INDENT l = len ( st ) NEW_LINE k = floor ( sqrt ( l ) ) NEW_LINE column = ceil ( sqrt ( l ) ) NEW_LINE if row * column < l : NEW_LINE INDENT row = column NEW_LINE DEDENT s = [ [ 0 for i in range ( row ) ] for j in range ( row ) ] NEW_LINE for i in range ( row ) : NEW_LINE INDENT for j in range ( 0 , column ) : NEW_LINE INDENT if k < len ( st ) : NEW_LINE INDENT s [ i ] [ j ] = st [ k ] NEW_LINE DEDENT k += 1 NEW_LINE DEDENT DEDENT for i in range ( row ) : NEW_LINE INDENT for j in range ( column ) : NEW_LINE INDENT if ( st [ i ] [ j ] == 0 ) : NEW_LINE INDENT s [ i ] [ j ] = st [ k ] NEW_LINE DEDENT k += 1 NEW_LINE DEDENT DEDENT for i in range ( row ) : NEW_LINE INDENT for j in range ( column ) : NEW_LINE INDENT if ( s [ i ] [ j ] == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT print ( s [ i ] [ j ] , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT st = \" GEEKSFORGEEKS \" NEW_LINE grid ( st ) NEW_LINE DEDENT"],"references":["from math import sqrt , floor , ceil NEW_LINE def gridStr ( string ) : NEW_LINE INDENT l = len ( string ) NEW_LINE k = 0 NEW_LINE row = floor ( sqrt ( l ) ) NEW_LINE column = ceil ( sqrt ( l ) ) NEW_LINE if ( row * column < l ) : NEW_LINE INDENT row = column NEW_LINE DEDENT s = [ [ 0 for j in range ( column ) ] for i in range ( row ) ] NEW_LINE for i in range ( row ) : NEW_LINE INDENT for j in range ( column ) : NEW_LINE INDENT if k >= l : NEW_LINE INDENT s [ i ] [ j ] = \" ▁ \" NEW_LINE k += 1 NEW_LINE DEDENT else : NEW_LINE INDENT s [ i ] [ j ] = string [ k ] NEW_LINE k += 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( row ) : NEW_LINE INDENT for j in range ( column ) : NEW_LINE INDENT if s [ i ] [ j ] == \" ▁ \" : NEW_LINE INDENT break NEW_LINE DEDENT print ( s [ i ] [ j ] , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" GEEKSFORGEEKS \" NEW_LINE gridStr ( string ) NEW_LINE DEDENT"],"bleu":0.7039601901226664,"rouge_l":0.8376830458835015}
{"id":1001,"predictions":["def maxProfit ( prices , start , end ) : NEW_LINE INDENT if ( end <= start ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT profit = 0 NEW_LINE for i in range ( start , end ) : NEW_LINE INDENT for j in range ( i + 1 , end + 1 ) : NEW_LINE INDENT if ( price [ j ] > price [ i ] ) : NEW_LINE INDENT curr_ Profit = ( prices [ j ] - prices [ i ] + maxProfit ( prices , start , i - 1 ) + maxProfit ( prices , j + 1 , end ) ) NEW_LINE profit = max ( profit , curr_ Profit ) NEW_LINE DEDENT DEDENT DEDENT return profit NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT price = [ 100 , 180 , 260 , 260 , 40 , 535 , 695 ] NEW_LINE n = len ( prices ) NEW_LINE print ( maxProfit ( prices , 0 , n - 1 ) ) NEW_LINE DEDENT"],"references":["def maxProfit ( price , start , end ) : NEW_LINE INDENT if ( end <= start ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT profit = 0 ; NEW_LINE for i in range ( start , end , 1 ) : NEW_LINE INDENT for j in range ( i + 1 , end + 1 ) : NEW_LINE INDENT if ( price [ j ] > price [ i ] ) : NEW_LINE INDENT curr_profit = price [ j ] - price [ i ] + \\ NEW_LINE INDENT maxProfit ( price , start , i - 1 ) +   \\ NEW_LINE maxProfit ( price , j + 1 , end ) ; NEW_LINE DEDENT profit = max ( profit , curr_profit ) ; NEW_LINE DEDENT DEDENT DEDENT return profit ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT price = [ 100 , 180 , 260 , 310 , 40 , 535 , 695 ] ; NEW_LINE n = len ( price ) ; NEW_LINE print ( maxProfit ( price , 0 , n - 1 ) ) ; NEW_LINE DEDENT"],"bleu":0.6709509139974698,"rouge_l":0.8704368379585049}
{"id":1002,"predictions":["def maximum_middle_value ( n , k , arr ) : NEW_LINE INDENT ans = - 1 NEW_LINE low = ( n + 1 - k ) \/\/ 2 NEW_LINE high = ( n + 1 - k ) \/\/ 2 + k NEW_LINE for i in range ( low , high + 1 ) : NEW_LINE INDENT ans = max ( ans , arr [ i - 1 ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT n = 5 NEW_LINE k = 2 NEW_LINE arr = [ 9 , 5 , 3 , 7 , 10 ] NEW_LINE print ( maximum_middle_value ( n , k , arr ) ) NEW_LINE n = 9 NEW_LINE k = 3 NEW_LINE arr1 = [ 2 , 4 , 3 , 9 , 5 , 8 , 7 , 6 , 10 ] NEW_LINE print ( maximum_middle_value ( n , k , arr ) ) NEW_LINE"],"references":["def maximum_middle_value ( n , k , arr ) : NEW_LINE INDENT ans = - 1 NEW_LINE low = ( n + 1 - k ) \/\/ 2 NEW_LINE high = ( n + 1 - k ) \/\/ 2 + k NEW_LINE for i in range ( low , high + 1 ) : NEW_LINE INDENT ans = max ( ans , arr [ i - 1 ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n , k = 5 , 2 NEW_LINE arr = [ 9 , 5 , 3 , 7 , 10 ] NEW_LINE print ( maximum_middle_value ( n , k , arr ) ) NEW_LINE n , k = 9 , 3 NEW_LINE arr1 = [ 2 , 4 , 3 , 9 , 5 , 8 , 7 , 6 , 10 ] NEW_LINE print ( maximum_middle_value ( n , k , arr1 ) ) NEW_LINE DEDENT"],"bleu":0.8294879268257134,"rouge_l":0.9047667757774142}
{"id":1003,"predictions":["def countRec ( n , Sum ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return Sum == 0 NEW_LINE DEDENT if ( Sum == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT if ( Sum - i >= 0 ) : NEW_LINE INDENT ans += countRec ( n - 1 , Sum - i ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def finalCount ( n , Sum ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT if ( Sum - i >= 0 ) : NEW_LINE INDENT ans += countRec ( n - 1 , Sum - i ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n , Sum = 2 , 5 NEW_LINE print ( finalCount ( n , Sum ) ) NEW_LINE DEDENT"],"references":["def countRec ( n , sum ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return ( sum == 0 ) NEW_LINE DEDENT if ( sum == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 0 , 10 ) : NEW_LINE INDENT if ( sum - i >= 0 ) : NEW_LINE INDENT ans = ans + countRec ( n - 1 , sum - i ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def finalCount ( n , sum ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT if ( sum - i >= 0 ) : NEW_LINE INDENT ans = ans + countRec ( n - 1 , sum - i ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT n = 2 NEW_LINE sum = 5 NEW_LINE print ( finalCount ( n , sum ) ) NEW_LINE"],"bleu":0.6969039647491839,"rouge_l":0.8530628323813276}
{"id":1004,"predictions":["def calculateSum ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE MOD = 1000000007 NEW_LINE while ( k ) : NEW_LINE INDENT if ( ( k & 1 ) == 1 ) : NEW_LINE INDENT res = ( res * n ) % MOD NEW_LINE DEDENT k = k \/\/ 2 NEW_LINE n = ( n * n ) % MOD NEW_LINE DEDENT return res NEW_LINE DEDENT n = 4 NEW_LINE k = 3 NEW_LINE print ( calculateSum ( n , k ) ) NEW_LINE"],"references":["def calculateSum ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE MOD = 1000000007 NEW_LINE while k > 0 : NEW_LINE INDENT if ( k & 1 ) == 1 : NEW_LINE INDENT res = ( res * n ) % MOD NEW_LINE DEDENT k = k \/\/ 2 NEW_LINE n = ( n * n ) % MOD NEW_LINE DEDENT return res NEW_LINE DEDENT n = 4 NEW_LINE k = 3 NEW_LINE print ( calculateSum ( n , k ) ) NEW_LINE"],"bleu":0.9014814338891617,"rouge_l":0.967522658610272}
{"id":1005,"predictions":["def countPairs ( s , K ) : NEW_LINE INDENT if ( K > s or ( s - K ) % 2 == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( ( s - K ) \/\/ 2 == 1 and K == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT setBits = bin ( K ) NEW_LINE pairsCount = pow ( 2 , setBits ) NEW_LINE if ( s == K ) : NEW_LINE INDENT pairsCount -= 2 NEW_LINE DEDENT return pairsCount NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = 9 NEW_LINE K = 5 NEW_LINE print ( countPairs ( s , K ) ) NEW_LINE DEDENT"],"references":["def countPairs ( s , K ) : NEW_LINE INDENT if ( K > s or ( s - K ) % 2 == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT setBits = ( str ( bin ( K ) ) [ 2 : ] ) . count ( \"1\" ) NEW_LINE pairsCount = pow ( 2 , setBits ) NEW_LINE if ( s == K ) : NEW_LINE INDENT pairsCount -= 2 NEW_LINE DEDENT return pairsCount NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s , K = 9 , 5 NEW_LINE print ( countPairs ( s , K ) ) NEW_LINE DEDENT"],"bleu":0.7158295819913787,"rouge_l":0.8227030064624894}
{"id":1006,"predictions":["def splitString ( st ) : NEW_LINE INDENT alpha = [ ] NEW_LINE num = [ ] NEW_LINE special = [ ] NEW_LINE for i in range ( len ( st ) ) : NEW_LINE INDENT if ( st [ i ] . isdigit ( ) ) : NEW_LINE INDENT num . append ( st [ i ] ) NEW_LINE DEDENT elif ( st [ i ] . isalpha ( ) ) : NEW_LINE INDENT alpha . append ( st [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT alpha . append ( st [ i ] ) NEW_LINE DEDENT DEDENT print ( alpha ) NEW_LINE print ( special ) NEW_LINE print ( special ) NEW_LINE print ( special ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT st = \" geeks1\" NEW_LINE splitString ( st ) NEW_LINE DEDENT"],"references":["def splitString ( str ) : NEW_LINE INDENT alpha = \" \" NEW_LINE num = \" \" NEW_LINE special = \" \" NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] . isdigit ( ) ) : NEW_LINE INDENT num = num + str [ i ] NEW_LINE DEDENT elif ( ( str [ i ] >= ' A ' and str [ i ] <= ' Z ' ) or ( str [ i ] >= ' a ' and str [ i ] <= ' z ' ) ) : NEW_LINE INDENT alpha += str [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT special += str [ i ] NEW_LINE DEDENT DEDENT print ( alpha ) NEW_LINE print ( num ) NEW_LINE print ( special ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeks01 $ $ for02geeks03 ! @ ! ! \" NEW_LINE splitString ( str ) NEW_LINE DEDENT"],"bleu":0.46229105231186296,"rouge_l":0.675118221149009}
{"id":1007,"predictions":["def atMostK ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE left = 0 NEW_LINE right = 0 NEW_LINE m = 0 NEW_LINE while ( right < n ) : NEW_LINE INDENT map [ arr [ right ] ] = map . get ( arr [ right ] , 0 ) + 1 NEW_LINE while ( len ( map ) > k ) : NEW_LINE INDENT map [ arr [ left ] ] = map . get ( arr [ left ] , 0 ) + 1 NEW_LINE if ( map [ arr [ left ] ] == 0 ) : NEW_LINE INDENT map [ arr [ left ] ] = - 1 NEW_LINE DEDENT left += 1 NEW_LINE DEDENT count += right - left + 1 NEW_LINE right += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def sameK ( arr , n , k ) : NEW_LINE INDENT return ( atMostK ( arr , n , k ) - atMostK ( arr , n , k - 1 ) ) NEW_LINE DEDENT arr = [ 2 , 1 , 2 , 1 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE print ( atK ( arr , n , k ) ) NEW_LINE"],"references":["def atMostK ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE left = 0 NEW_LINE right = 0 NEW_LINE map = { } NEW_LINE while ( right < n ) : NEW_LINE INDENT if arr [ right ] not in map : NEW_LINE INDENT map [ arr [ right ] ] = 0 NEW_LINE DEDENT map [ arr [ right ] ] += 1 NEW_LINE while ( len ( map ) > k ) : NEW_LINE INDENT if arr [ left ] not in map : NEW_LINE INDENT map [ arr [ left ] ] = 0 NEW_LINE DEDENT map [ arr [ left ] ] -= 1 NEW_LINE if map [ arr [ left ] ] == 0 : NEW_LINE INDENT del map [ arr [ left ] ] NEW_LINE DEDENT left += 1 NEW_LINE DEDENT count += right - left + 1 NEW_LINE right += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def exactlyK ( arr , n , k ) : NEW_LINE INDENT return ( atMostK ( arr , n , k ) - atMostK ( arr , n , k - 1 ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 1 , 2 , 1 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE print ( exactlyK ( arr , n , k ) ) NEW_LINE DEDENT"],"bleu":0.6931010106727774,"rouge_l":0.822992059588223}
{"id":1008,"predictions":["def display ( n ) : NEW_LINE INDENT sp = n \/\/ 2 NEW_LINE st = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , sp + 1 ) : NEW_LINE INDENT print ( end = \" ▁ \" ) NEW_LINE DEDENT count = 1 NEW_LINE for k in range ( 1 , st + 1 ) : NEW_LINE INDENT if ( k % 2 == 0 ) : NEW_LINE INDENT print ( \" * \" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( count + 1 , end = \" \" ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE if ( i <= n \/\/ 2 ) : NEW_LINE INDENT sp += 1 NEW_LINE st += 2 NEW_LINE DEDENT else : NEW_LINE INDENT sp += 1 NEW_LINE st -= 2 NEW_LINE DEDENT DEDENT DEDENT n = 5 NEW_LINE display ( n ) NEW_LINE"],"references":["def display ( n ) : NEW_LINE INDENT sp = n \/\/ 2 NEW_LINE st = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , sp + 1 ) : NEW_LINE INDENT print ( end = \" ▁ \" ) NEW_LINE DEDENT count = 1 NEW_LINE for k in range ( 1 , st + 1 ) : NEW_LINE INDENT if ( k % 2 == 0 ) : NEW_LINE INDENT print ( \" * \" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( count , end = \" \" ) NEW_LINE count += 1 NEW_LINE DEDENT DEDENT print ( ) NEW_LINE if ( i <= n \/\/ 2 ) : NEW_LINE INDENT sp = sp - 1 NEW_LINE st = st + 2 NEW_LINE DEDENT else : NEW_LINE INDENT sp = sp + 1 NEW_LINE st = st - 2 NEW_LINE DEDENT DEDENT DEDENT n = 5 NEW_LINE display ( n ) NEW_LINE"],"bleu":0.8660754701983593,"rouge_l":0.9299498263218834}
{"id":1009,"predictions":["R = 3 NEW_LINE C = 5 NEW_LINE def maxArea ( mat ) : NEW_LINE INDENT hist = [ [ 0 for i in range ( R + 1 ) ] for j in range ( C + 1 ) ] NEW_LINE for i in range ( C ) : NEW_LINE INDENT hist [ 0 ] [ i ] = mat [ 0 ] [ i ] NEW_LINE for j in range ( 1 , R ) : NEW_LINE INDENT if ( mat [ j ] [ i ] == 0 ) : NEW_LINE INDENT hist [ j ] [ i ] = True NEW_LINE DEDENT DEDENT DEDENT for i in range ( R ) : NEW_LINE INDENT count = [ 0 ] * ( R + 1 ) NEW_LINE for j in range ( R + 1 ) : NEW_LINE INDENT count [ hist [ i ] [ j ] += 1 NEW_LINE DEDENT col_no = 0 NEW_LINE for j in range ( R , C , - 1 ) : NEW_LINE INDENT if ( count [ j ] > 0 ) : NEW_LINE INDENT for k in range ( count [ j ] ) : NEW_LINE INDENT hist [ i ] [ col_no ] = j NEW_LINE col_no += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT curr_area = 0 NEW_LINE for i in range ( R ) : NEW_LINE INDENT for j in range ( C ) : NEW_LINE INDENT curr_area = ( j + 1 ) * hist [ i ] [ j ] NEW_LINE if ( curr_area > max_area ) : NEW_LINE INDENT max_area = curr_area NEW_LINE DEDENT DEDENT DEDENT return max_area NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT mat = [ [ 0 , 1 , 0 , 1 , 0 ] , [ 0 , 1 , 0 , 1 ] , [ 1 , 1 , 0 , 1 ] , [ 1 , 1 , 0 , 1 ] ] NEW_LINE print ( \" Area ▁ of ▁ the ▁ largest ▁ rectangle ▁ is \" , maxArea ( mat ) ) NEW_LINE DEDENT"],"references":["R = 3 NEW_LINE C = 5 NEW_LINE def maxArea ( mat ) : NEW_LINE INDENT hist = [ [ 0 for i in range ( C + 1 ) ] for i in range ( R + 1 ) ] NEW_LINE for i in range ( 0 , C , 1 ) : NEW_LINE INDENT hist [ 0 ] [ i ] = mat [ 0 ] [ i ] NEW_LINE for j in range ( 1 , R , 1 ) : NEW_LINE INDENT if ( ( mat [ j ] [ i ] == 0 ) ) : NEW_LINE INDENT hist [ j ] [ i ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT hist [ j ] [ i ] = hist [ j - 1 ] [ i ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 0 , R , 1 ) : NEW_LINE INDENT count = [ 0 for i in range ( R + 1 ) ] NEW_LINE for j in range ( 0 , C , 1 ) : NEW_LINE INDENT count [ hist [ i ] [ j ] ] += 1 NEW_LINE DEDENT col_no = 0 NEW_LINE j = R NEW_LINE while ( j >= 0 ) : NEW_LINE INDENT if ( count [ j ] > 0 ) : NEW_LINE INDENT for k in range ( 0 , count [ j ] , 1 ) : NEW_LINE INDENT hist [ i ] [ col_no ] = j NEW_LINE col_no += 1 NEW_LINE DEDENT DEDENT j -= 1 NEW_LINE DEDENT DEDENT max_area = 0 NEW_LINE for i in range ( 0 , R , 1 ) : NEW_LINE INDENT for j in range ( 0 , C , 1 ) : NEW_LINE INDENT curr_area = ( j + 1 ) * hist [ i ] [ j ] NEW_LINE if ( curr_area > max_area ) : NEW_LINE INDENT max_area = curr_area NEW_LINE DEDENT DEDENT DEDENT return max_area NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT mat = [ [ 0 , 1 , 0 , 1 , 0 ] , [ 0 , 1 , 0 , 1 , 1 ] , [ 1 , 1 , 0 , 1 , 0 ] ] NEW_LINE print ( \" Area ▁ of ▁ the ▁ largest ▁ rectangle ▁ is \" , maxArea ( mat ) ) NEW_LINE DEDENT"],"bleu":0.7455112355331392,"rouge_l":0.8506846429323783}
{"id":1010,"predictions":["def lcs ( dp , a , b , m , n ) : NEW_LINE INDENT for i in range ( 100 ) : NEW_LINE INDENT dp [ i ] [ j ] = - 1 NEW_LINE DEDENT if ( m < 0 or n < 0 ) : NEW_LINE INDENT return dp [ m ] [ n ] NEW_LINE DEDENT if ( dp [ m ] [ n ] != - 1 ) : NEW_LINE INDENT return dp [ m ] [ n ] NEW_LINE DEDENT ans = 0 NEW_LINE if ( a [ m ] == b [ n ] ) : NEW_LINE INDENT ans = ( ( a [ m ] - 48 ) + lcs ( dp , a , b , m - 1 , n - 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( lcs ( dp , a , b , m - 1 , n ) , lcs ( dp , a , b , b , m , n - 1 ) ) NEW_LINE DEDENT dp [ m ] [ n ] = ans NEW_LINE return ans NEW_LINE DEDENT def costOfString ( str ) : NEW_LINE INDENT cost = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT cost += ( ord ( str [ i ] ) - 48 ) NEW_LINE DEDENT return cost NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = \"9142\" NEW_LINE b = [ [ - 1 for i in range ( 101 ) ] for i in range ( 101 ) ] for j in range ( 101 ) ] NEW_LINE print ( ( ( costOfString ( a ) + costOfString ( b ) - 2 * lcs ( dp , a , b , len ( b ) - 1 ) ) ) ) NEW_LINE DEDENT"],"references":["def lcs ( dp , a , b , m , n ) : NEW_LINE INDENT for i in range ( 100 ) : NEW_LINE INDENT for j in range ( 100 ) : NEW_LINE INDENT dp [ i ] [ j ] = - 1 NEW_LINE DEDENT DEDENT if ( m < 0 or n < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ m ] [ n ] != - 1 ) : NEW_LINE INDENT return dp [ m ] [ n ] NEW_LINE DEDENT ans = 0 NEW_LINE if ( a [ m ] == b [ n ] ) : NEW_LINE INDENT ans = ( ord ( a [ m ] ) - 48 ) + lcs ( dp , a , b , m - 1 , n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( lcs ( dp , a , b , m - 1 , n ) , lcs ( dp , a , b , m , n - 1 ) ) NEW_LINE DEDENT dp [ m ] [ n ] = ans NEW_LINE return ans NEW_LINE DEDENT def costOfString ( s ) : NEW_LINE INDENT cost = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT cost += ( ord ( s [ i ] ) - 48 ) NEW_LINE DEDENT return cost NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = \"9142\" NEW_LINE b = \"1429\" NEW_LINE dp = [ [ 0 for x in range ( 101 ) ] for y in range ( 101 ) ] NEW_LINE print ( costOfString ( a ) + costOfString ( b ) - 2 * lcs ( dp , a , b , len ( a ) - 1 , len ( b ) - 1 ) ) NEW_LINE DEDENT"],"bleu":0.8711898468315376,"rouge_l":0.9063247341372818}
{"id":1011,"predictions":["def max_UniqueNum ( arr , N , M ) : NEW_LINE INDENT maxUnique = 0 NEW_LINE for i in range ( N - M ) : NEW_LINE INDENT currentUnique = 0 NEW_LINE map = { } NEW_LINE for k in range ( i , i + M ) : NEW_LINE INDENT if arr [ k ] not in map : NEW_LINE INDENT map [ arr [ i ] ] = 1 NEW_LINE currentUnique += 1 NEW_LINE continue NEW_LINE DEDENT DEDENT if ( currentUnique > maxUnique ) : NEW_LINE INDENT maxUnique = currentUnique NEW_LINE DEDENT DEDENT return maxUnique NEW_LINE DEDENT arr = [ 5 , 3 , 5 , 2 , 3 , 2 ] NEW_LINE N = 6 NEW_LINE M = 3 NEW_LINE print ( maxUniqueNum ( arr , N , M ) ) NEW_LINE"],"references":["def maxUniqueNum ( a , N , M ) : NEW_LINE INDENT maxUnique = 0 NEW_LINE for i in range ( N - M ) : NEW_LINE INDENT s = set ( ) NEW_LINE for j in range ( M ) : NEW_LINE INDENT s . add ( a [ i + j ] ) NEW_LINE DEDENT if ( len ( s ) > maxUnique ) : NEW_LINE INDENT maxUnique = len ( s ) NEW_LINE DEDENT DEDENT return maxUnique NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 3 , 5 , 2 , 3 , 2 ] NEW_LINE M = 3 NEW_LINE N = len ( arr ) NEW_LINE print ( maxUniqueNum ( arr , N , M ) ) NEW_LINE DEDENT"],"bleu":0.5706459855628775,"rouge_l":0.674074074074074}
{"id":1012,"predictions":["def complement ( s ) : NEW_LINE INDENT comps = \" \" NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT comps += '1' NEW_LINE DEDENT else : NEW_LINE INDENT comps += '0' NEW_LINE DEDENT DEDENT return comps NEW_LINE DEDENT def nthTerm ( n ) : NEW_LINE INDENT s = \"0\" NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT s += complement ( s ) NEW_LINE DEDENT return s NEW_LINE DEDENT n = 4 NEW_LINE print ( nthTerm ( n ) ) NEW_LINE"],"references":["def complement ( s ) : NEW_LINE INDENT comps = \" \" ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT comps += '1' ; NEW_LINE DEDENT else : NEW_LINE INDENT comps += '0' ; NEW_LINE DEDENT DEDENT return comps ; NEW_LINE DEDENT def nthTerm ( n ) : NEW_LINE INDENT s = \"0\" ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT s += complement ( s ) ; NEW_LINE DEDENT return s ; NEW_LINE DEDENT n = 4 ; NEW_LINE print ( nthTerm ( n ) ) ; NEW_LINE"],"bleu":0.7872994571685928,"rouge_l":0.9448296208880366}
{"id":1013,"predictions":["def evenFibSum ( limit ) : NEW_LINE INDENT if ( limit < 2 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT ef1 = 0 ; ef2 = 2 ; NEW_LINE sum = ef1 + ef2 ; NEW_LINE while ( ef2 <= limit ) : NEW_LINE INDENT ef3 = 4 * ef2 + ef1 ; NEW_LINE if ( ef3 > limit ) : NEW_LINE INDENT break ; NEW_LINE DEDENT ef1 = ef2 ; NEW_LINE ef2 = ef3 ; NEW_LINE sum += ef2 ; NEW_LINE DEDENT return int ( sum ) ; NEW_LINE DEDENT limit = 400 ; NEW_LINE print ( evenFibSum ( limit ) ) ; NEW_LINE"],"references":["def evenFibSum ( limit ) : NEW_LINE INDENT if ( limit < 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ef1 = 0 NEW_LINE ef2 = 2 NEW_LINE sm = ef1 + ef2 NEW_LINE while ( ef2 <= limit ) : NEW_LINE INDENT ef3 = 4 * ef2 + ef1 NEW_LINE if ( ef3 > limit ) : NEW_LINE INDENT break NEW_LINE DEDENT ef1 = ef2 NEW_LINE ef2 = ef3 NEW_LINE sm = sm + ef2 NEW_LINE DEDENT return sm NEW_LINE DEDENT limit = 400 NEW_LINE print ( evenFibSum ( limit ) ) NEW_LINE"],"bleu":0.6399790103549561,"rouge_l":0.8807219031993436}
{"id":1014,"predictions":["def factorial ( N ) : NEW_LINE INDENT fact = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT fact = fact * i NEW_LINE DEDENT return fact NEW_LINE DEDENT def nthTerm ( N ) : NEW_LINE INDENT return ( factorial ( N ) * ( N + 2 ) \/\/ 2 ) NEW_LINE DEDENT N = 6 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE"],"references":["def factorial ( N ) : NEW_LINE INDENT fact = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT fact = fact * i NEW_LINE DEDENT return fact NEW_LINE DEDENT def nthTerm ( N ) : NEW_LINE INDENT return ( factorial ( N ) * ( N + 2 ) \/\/ 2 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 6 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT"],"bleu":0.8104420845269639,"rouge_l":0.899561578318055}
{"id":1015,"predictions":["def answer ( X , K ) : NEW_LINE INDENT MAX = pow ( 10 , K ) - 1 NEW_LINE return ( MAX - ( MAX % X ) ) NEW_LINE DEDENT X = 30 NEW_LINE K = 3 NEW_LINE print ( answer ( X , K ) ) NEW_LINE"],"references":["def answer ( X , K ) : NEW_LINE INDENT MAX = pow ( 10 , K ) - 1 NEW_LINE return ( MAX - ( MAX % X ) ) NEW_LINE DEDENT X = 30 ; NEW_LINE K = 3 ; NEW_LINE print ( answer ( X , K ) ) ; NEW_LINE"],"bleu":0.8703520589426701,"rouge_l":0.9664492078285183}
{"id":1016,"predictions":["def maxLength ( a , n ) : NEW_LINE INDENT maximum = 1 NEW_LINE left = [ 0 for i in range ( n ) ] NEW_LINE right = [ None ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT left [ i ] = 1 NEW_LINE right [ i ] = 1 NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( a [ i ] > a [ i + 1 ] ) : NEW_LINE INDENT right [ i ] = right [ i + 1 ] + 1 NEW_LINE DEDENT maximum = max ( maximum , right [ i ] ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( a [ i ] < a [ i - 1 ] ) : NEW_LINE INDENT left [ i ] = left [ i - 1 ] + 1 NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( a [ i - 1 ] > a [ i + 1 ] ) : NEW_LINE INDENT maximum = max ( maximum , left [ i - 1 ] + right [ i + 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return maximum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 8 , 7 , 3 , 5 , 2 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxLength ( arr , n ) ) NEW_LINE DEDENT"],"references":["def maxLength ( a , n ) : NEW_LINE INDENT maximum = 1 ; NEW_LINE left = [ 0 ] * n ; NEW_LINE right = [ 0 ] * n ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT left [ i ] = 1 ; NEW_LINE right [ i ] = 1 ; NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( a [ i ] > a [ i + 1 ] ) : NEW_LINE INDENT right [ i ] = right [ i + 1 ] + 1 ; NEW_LINE DEDENT maximum = max ( maximum , right [ i ] ) ; NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( a [ i ] < a [ i - 1 ] ) : NEW_LINE INDENT left [ i ] = left [ i - 1 ] + 1 ; NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( a [ i - 1 ] > a [ i + 1 ] ) : NEW_LINE INDENT maximum = max ( maximum , left [ i - 1 ] + right [ i + 1 ] ) ; NEW_LINE DEDENT DEDENT DEDENT return maximum ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 8 , 7 , 3 , 5 , 2 , 9 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( maxLength ( arr , n ) ) ; NEW_LINE DEDENT"],"bleu":0.8704021452450236,"rouge_l":0.9560912125841678}
{"id":1017,"predictions":["n = 3 NEW_LINE a = [ 1 , 2 , 3 ] NEW_LINE i = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT x = sum \/\/ n NEW_LINE if ( x * n == sum ) : NEW_LINE INDENT print ( x ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT"],"references":["if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE a = [ 1 , 2 , 3 ] NEW_LINE i = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT x = sum \/\/ n NEW_LINE if ( x * n == sum ) : NEW_LINE INDENT print ( x ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT DEDENT"],"bleu":0.8297202637161937,"rouge_l":0.9007678676904902}
{"id":1018,"predictions":["def getPerfectSquares ( n ) : NEW_LINE INDENT perfectSquares = [ ] NEW_LINE current = 1 NEW_LINE i = 1 NEW_LINE while ( current <= n ) : NEW_LINE INDENT perfectSquares . append ( current ) NEW_LINE current = i + 1 NEW_LINE DEDENT return perfectSquares NEW_LINE DEDENT def countTriplets ( n ) : NEW_LINE INDENT perfectSquares = getPerfectSquares ( n ** 2 ) NEW_LINE count = 0 NEW_LINE for a in range ( 1 , n + 1 ) : NEW_LINE INDENT aSquare = perfectSquares [ a ] NEW_LINE for i in range ( len ( perfectSquares ) ) : NEW_LINE INDENT cSquare = perfectSquares [ i ] NEW_LINE bSquare = cSquare - aSquare NEW_LINE b = ( bSquare ) NEW_LINE if ( c < a or not in perfectSquares ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( b >= a ) and ( bSquare + bSquare == cSquare ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( ( b >= a ) and ( bSquare + bSquare ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 10 NEW_LINE print ( countTriplets ( n ) ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def getPerfectSquares ( n ) : NEW_LINE INDENT perfectSquares = [ ] NEW_LINE current = 1 NEW_LINE i = 1 NEW_LINE while ( current <= n ) : NEW_LINE INDENT perfectSquares . append ( current ) NEW_LINE i += 1 NEW_LINE current = i ** 2 NEW_LINE DEDENT return perfectSquares NEW_LINE DEDENT def countTriplets ( n ) : NEW_LINE INDENT perfectSquares = getPerfectSquares ( n ** 2 ) NEW_LINE count = 0 NEW_LINE for a in range ( 1 , n + 1 ) : NEW_LINE INDENT aSquare = a ** 2 NEW_LINE for i in range ( len ( perfectSquares ) ) : NEW_LINE INDENT cSquare = perfectSquares [ i ] NEW_LINE bSquare = abs ( cSquare - aSquare ) NEW_LINE b = math . sqrt ( bSquare ) NEW_LINE b = int ( b ) NEW_LINE c = math . sqrt ( cSquare ) NEW_LINE c = int ( c ) NEW_LINE if ( c < a or ( bSquare not in perfectSquares ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( ( b >= a ) and ( b <= c ) and ( aSquare + bSquare == cSquare ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 10 NEW_LINE print ( countTriplets ( n ) ) NEW_LINE DEDENT"],"bleu":0.7485509887789141,"rouge_l":0.8298423666594686}
{"id":1019,"predictions":["def centered_ pentagonal_num ( n ) : NEW_LINE INDENT return ( 5 * n * n - 5 * n + 2 ) \/\/ 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 7 NEW_LINE print ( n , \" th ▁ Centered ▁ number ▁ : ▁ \" , centered_octagonal_Num ( n ) ) NEW_LINE DEDENT"],"references":["def centered_pentagonal_Num ( n ) : NEW_LINE INDENT return ( 5 * n * n - 5 * n + 2 ) \/\/ 2 NEW_LINE DEDENT n = 7 NEW_LINE print ( \" % sth ▁ Centered ▁ pentagonal ▁ number ▁ : ▁ \" % n , centered_pentagonal_Num ( n ) ) NEW_LINE"],"bleu":0.5789293680061107,"rouge_l":0.7807456872565387}
{"id":1020,"predictions":["def PossibleValues ( b , x , n ) : NEW_LINE INDENT leastdivisible = ( b \/\/ x + 1 ) * x NEW_LINE flag = 1 NEW_LINE while ( leastdivisible <= n ) : NEW_LINE INDENT if ( leastdivisible - b >= 1 ) : NEW_LINE INDENT print ( leastdivisible - b , end = \" ▁ \" ) NEW_LINE leastdivisible += x NEW_LINE flag = 0 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( flag > 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT b = 10 NEW_LINE x = 6 NEW_LINE n = 40 NEW_LINE PossibleValues ( b , x , n ) NEW_LINE DEDENT"],"references":["def PossibleValues ( b , x , n ) : NEW_LINE INDENT leastdivisible = int ( b \/ x + 1 ) * x NEW_LINE flag = 1 NEW_LINE while ( leastdivisible <= n ) : NEW_LINE INDENT if ( leastdivisible - b >= 1 ) : NEW_LINE INDENT print ( leastdivisible - b , end = \" ▁ \" ) NEW_LINE leastdivisible += x NEW_LINE flag = 0 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( flag != 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT b = 10 NEW_LINE x = 6 NEW_LINE n = 40 NEW_LINE PossibleValues ( b , x , n ) NEW_LINE DEDENT"],"bleu":0.9048479263140746,"rouge_l":0.9648506151142355}
{"id":1021,"predictions":["def findLongestRepeatingSubSeq ( str1 ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE dp = [ [ 0 for i in range ( n + 2 ) ] for j in range ( n + 1 ) ] NEW_LINE dp = [ [ 0 for j in range ( n + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( str1 [ i - 1 ] == str1 [ j - 1 ] and i != j != j ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ n ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = len ( str1 ) NEW_LINE findLongestRepeatingSubSeq ( str1 ) NEW_LINE DEDENT"],"references":["def findLongestRepeatingSubSeq ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE dp = [ [ 0 for k in range ( n + 1 ) ] for l in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( str [ i - 1 ] == str [ j - 1 ] and i != j ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ n ] NEW_LINE DEDENT"],"bleu":0.5822731090346341,"rouge_l":0.7854506684163044}
{"id":1022,"predictions":["def countIntegralSolutions ( n ) : NEW_LINE INDENT return ( ( n + 1 ) * ( n + 2 ) ) \/\/ 2 NEW_LINE DEDENT n = 3 NEW_LINE print ( countIntegralSolutions ( n ) ) NEW_LINE"],"references":["def countIntegralSolutions ( n ) : NEW_LINE INDENT return int ( ( ( n + 1 ) * ( n + 2 ) ) \/ 2 ) NEW_LINE DEDENT n = 3 NEW_LINE print ( countIntegralSolutions ( n ) ) NEW_LINE"],"bleu":0.8022709117874298,"rouge_l":0.930338004946414}
{"id":1023,"predictions":["def check ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count & 1 ) != 0 : NEW_LINE INDENT return \" Odd \" NEW_LINE DEDENT else : NEW_LINE INDENT return \" Even \" NEW_LINE DEDENT DEDENT arr = [ 3 , 9 , 12 , 13 , 15 ] NEW_LINE n = len ( arr ) NEW_LINE print ( check ( arr , n ) ) NEW_LINE"],"references":["def check ( arr , n ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT count = count + 1 ; NEW_LINE DEDENT DEDENT if ( count & 1 ) : NEW_LINE INDENT return \" Odd \" ; NEW_LINE DEDENT else : NEW_LINE INDENT return \" Even \" ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 9 , 12 , 13 , 15 ] NEW_LINE n = len ( arr ) NEW_LINE print ( check ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.7274840031269939,"rouge_l":0.8779556469378762}
{"id":1024,"predictions":["def dfs ( graph , node , dist , vis , vis , c ) : NEW_LINE INDENT if ( vis [ node ] ) : NEW_LINE INDENT return NEW_LINE DEDENT vis [ node ] = True NEW_LINE dist [ node ] = c NEW_LINE for i in graph [ node ] : NEW_LINE INDENT if ( not vis [ graph [ node ] [ i ] ) : NEW_LINE INDENT dfs ( graph , graph [ node ] [ i ] , dist , vis , c + 1 ) NEW_LINE DEDENT DEDENT DEDENT def countOfNodes ( graph , n ) : NEW_LINE INDENT vis = [ False ] * ( n + 1 ) NEW_LINE dist = [ 0 for i in range ( n + 1 ) ] NEW_LINE dfs ( graph , 1 , dist , vis , 0 ) NEW_LINE even = 0 NEW_LINE odd = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( dist [ i ] % 2 == 0 ) : NEW_LINE INDENT even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT ans = ( ( even * ( even - 1 ) ) + ( odd * ( odd - 1 ) ) ) \/\/ 2 NEW_LINE return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 NEW_LINE graph = [ ] NEW_LINE graph = [ ] NEW_LINE graph . append ( 2 ) NEW_LINE graph . append ( 1 ) NEW_LINE graph [ 2 ] = [ 1 , 3 ] NEW_LINE graph [ 3 ] = [ 1 , 3 ] NEW_LINE graph [ 3 ] = [ 2 ] NEW_LINE graph [ 3 ] = [ 2 ] NEW_LINE graph [ 3 ] = countOfNodes ( graph , n ) NEW_LINE print ( ans ) NEW_LINE DEDENT"],"references":["def dfs ( graph , node , dist , vis , c ) : NEW_LINE INDENT if ( vis [ node ] ) : NEW_LINE INDENT return ; NEW_LINE DEDENT vis [ node ] = True ; NEW_LINE dist [ node ] = c ; NEW_LINE for i in range ( len ( graph [ node ] ) ) : NEW_LINE INDENT if ( not vis [ graph [ node ] [ i ] ] ) : NEW_LINE INDENT dfs ( graph , graph [ node ] [ i ] , dist , vis , c + 1 ) ; NEW_LINE DEDENT DEDENT DEDENT def countOfNodes ( graph , n ) : NEW_LINE INDENT vis = [ False ] * ( n + 1 ) ; NEW_LINE dist = [ 0 ] * ( n + 1 ) ; NEW_LINE dfs ( graph , 1 , dist , vis , 0 ) ; NEW_LINE even = 0 ; odd = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( dist [ i ] % 2 == 0 ) : NEW_LINE INDENT even += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 ; NEW_LINE DEDENT DEDENT ans = ( ( even * ( even - 1 ) ) + ( odd * ( odd - 1 ) ) ) \/\/ 2 ; NEW_LINE return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 ; NEW_LINE graph = [ [ ] , [ 2 ] , [ 1 , 3 ] , [ 2 ] ] ; NEW_LINE ans = countOfNodes ( graph , n ) ; NEW_LINE print ( ans ) ; NEW_LINE DEDENT"],"bleu":0.7100904109521288,"rouge_l":0.8687888611362067}
{"id":1025,"predictions":["def flipsPossible ( a , n ) : NEW_LINE INDENT count_odd = 0 NEW_LINE count_even = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( a [ i ] & 1 ) == 1 ) : NEW_LINE INDENT count_odd += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_even += 1 NEW_LINE DEDENT DEDENT if ( count_odd % 2 == 1 and count_even % 2 == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT a = [ 1 , 0 , 1 , 1 , 1 , 0 , 1 ] NEW_LINE n = len ( a ) NEW_LINE if ( flipsPossible ( a , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def flipsPossible ( a , n ) : NEW_LINE INDENT count_odd = 0 ; count_even = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] & 1 ) : NEW_LINE INDENT count_odd += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT count_even += 1 ; NEW_LINE DEDENT DEDENT if ( count_odd % 2 and count_even % 2 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT else : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 0 , 1 , 1 , 0 , 1 ] ; NEW_LINE n = len ( a ) ; NEW_LINE if ( flipsPossible ( a , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"],"bleu":0.7133988463592067,"rouge_l":0.8784937059953061}
{"id":1026,"predictions":["def findSeries ( num , first , sec ) : NEW_LINE INDENT print ( first , second , second , sep = \" \" ) NEW_LINE flag = 0 NEW_LINE while ( count < num - 2 ) : NEW_LINE INDENT sm = first + second NEW_LINE print ( sm , end = \" ▁ \" ) NEW_LINE first = sec NEW_LINE sec = sm NEW_LINE DEDENT DEDENT num = 5 NEW_LINE first = 2 NEW_LINE sec = 4 NEW_LINE findSeries ( num , first , sec ) NEW_LINE"],"references":["def findSeries ( num , first , sec ) : NEW_LINE INDENT print ( \" { } ▁ { } ▁ \" . format ( first , sec ) , end = \" \" ) NEW_LINE counter = 0 NEW_LINE while ( counter < num - 2 ) : NEW_LINE INDENT sum = first + sec NEW_LINE print ( \" { } ▁ \" . format ( sum ) , end = \" \" ) NEW_LINE first = sec NEW_LINE sec = sum NEW_LINE counter = counter + 1 NEW_LINE DEDENT DEDENT n = 5 NEW_LINE first = 2 NEW_LINE sec = 4 NEW_LINE findSeries ( n , first , sec ) NEW_LINE"],"bleu":0.49906008612476893,"rouge_l":0.736691562053075}
{"id":1027,"predictions":["def countOdd ( n ) : NEW_LINE INDENT coun = 0 NEW_LINE for i in range ( n - 2 , 0 , - 1 ) : NEW_LINE INDENT if ( i >= 1 ) : NEW_LINE INDENT m = ( n - i ) \/\/ 2 NEW_LINE j = ( i * ( i + 1 ) ) \/\/ 2 NEW_LINE coun += j * m NEW_LINE DEDENT else : NEW_LINE INDENT m = ( ( n - 1 ) - i ) \/\/ 2 NEW_LINE j = ( i * ( i + 1 ) ) \/\/ 2 NEW_LINE coun += j * m NEW_LINE DEDENT DEDENT return coun NEW_LINE DEDENT def countEven ( n ) : NEW_LINE INDENT coun = 0 NEW_LINE for i in range ( n - 2 , 0 , - 1 ) : NEW_LINE INDENT if ( i >= 1 ) : NEW_LINE INDENT m = ( ( n - 1 ) - i ) \/\/ 2 NEW_LINE j = ( i * ( i + 1 ) ) ) \/\/ 2 NEW_LINE coun += j * m NEW_LINE DEDENT else : NEW_LINE INDENT m = ( n - i ) \/\/ 2 NEW_LINE j = ( i * ( i + 1 ) ) \/\/ 2 NEW_LINE coun += j * m NEW_LINE DEDENT DEDENT return coun NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 NEW_LINE if ( n >= 1 ) : NEW_LINE INDENT print ( countOdd ( n ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( countOdd ( n ) ) NEW_LINE DEDENT DEDENT"],"references":["def countOdd ( n ) : NEW_LINE INDENT coun = 0 NEW_LINE i = n - 2 NEW_LINE while ( i >= 1 ) : NEW_LINE INDENT if ( i & 1 ) : NEW_LINE INDENT m = int ( ( n - i ) \/ 2 ) NEW_LINE j = int ( ( i * ( i + 1 ) ) \/ 2 ) NEW_LINE coun += j * m NEW_LINE DEDENT else : NEW_LINE INDENT m = int ( ( ( n - 1 ) - i ) \/ 2 ) NEW_LINE j = int ( ( i * ( i + 1 ) ) \/ 2 ) NEW_LINE coun += j * m NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT return coun NEW_LINE DEDENT def countEven ( n ) : NEW_LINE INDENT coun = 0 NEW_LINE i = n - 2 NEW_LINE while ( i >= 1 ) : NEW_LINE INDENT if ( i & 1 ) : NEW_LINE INDENT m = int ( ( ( n - 1 ) - i ) \/ 2 ) NEW_LINE j = int ( ( i * ( i + 1 ) ) \/ 2 ) NEW_LINE coun += j * m NEW_LINE DEDENT else : NEW_LINE INDENT m = int ( ( n - i ) \/ 2 ) NEW_LINE j = ( i * ( i + 1 ) ) \/\/ 2 NEW_LINE coun += j * m NEW_LINE DEDENT DEDENT return coun NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE if ( n & 1 ) : NEW_LINE INDENT print ( countOdd ( n ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( countEven ( n ) ) NEW_LINE DEDENT DEDENT"],"bleu":0.6906021820174958,"rouge_l":0.8547505126452495}
{"id":1028,"predictions":["mod = 10 ** 9 + 7 NEW_LINE def factorial ( n , p ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res = ( res * i ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( ( y & 1 ) == 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def modInverse ( n , p , p ) : NEW_LINE INDENT return power ( n , p - 2 , p ) NEW_LINE DEDENT def nCrModP ( n , r , p ) : NEW_LINE INDENT if ( r == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT fac = [ 0 ] * ( n + 1 ) NEW_LINE fac [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fac [ i ] = fac [ i - 1 ] * i % p NEW_LINE DEDENT return ( fac [ n ] * modInverse ( fac [ r ] , p ) % p * modInverse ( fac [ n - 1 ] , p ) % p ) % p NEW_LINE DEDENT def countArrangement ( n , k , p ) : NEW_LINE INDENT return ( factorial ( n , p ) * nCrModP ( k , n , p ) ) % p NEW_LINE DEDENT N = 5 NEW_LINE K = 8 NEW_LINE print ( countArrangement ( N , K , mod ) ) NEW_LINE"],"references":["mod = 10 ** 9 + 7 NEW_LINE def factorial ( n , p ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res = ( res * i ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def modInverse ( n , p ) : NEW_LINE INDENT return power ( n , p - 2 , p ) NEW_LINE DEDENT def nCrModP ( n , r , p ) : NEW_LINE INDENT if ( r == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT fac = [ 0 for i in range ( n + 1 ) ] NEW_LINE fac [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fac [ i ] = fac [ i - 1 ] * i % p NEW_LINE DEDENT return ( fac [ n ] * modInverse ( fac [ r ] , p ) % p * modInverse ( fac [ n - r ] , p ) % p ) % p NEW_LINE DEDENT def countArrangements ( n , k , p ) : NEW_LINE INDENT return ( factorial ( n , p ) * nCrModP ( k , n , p ) ) % p NEW_LINE DEDENT N = 5 NEW_LINE K = 8 NEW_LINE print ( countArrangements ( N , K , mod ) ) NEW_LINE"],"bleu":0.9382041095018957,"rouge_l":0.9708138932089165}
{"id":1029,"predictions":["def subString ( s , n ) : NEW_LINE INDENT for l in range ( 1 , n + 1 ) : NEW_LINE INDENT for i in range ( n - l + 1 ) : NEW_LINE INDENT j = i + l [ j ] NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT print ( s [ k ] , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = [ ' a ' , ' b ' , ' c ' ] NEW_LINE subString ( s , len ) NEW_LINE DEDENT"],"references":["def subString ( Str , n ) : NEW_LINE INDENT for Len in range ( 1 , n + 1 ) : NEW_LINE INDENT for i in range ( n - Len + 1 ) : NEW_LINE INDENT j = i + Len - 1 NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT print ( Str [ k ] , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT DEDENT Str = \" abc \" NEW_LINE subString ( Str , len ( Str ) ) NEW_LINE"],"bleu":0.5597280634779264,"rouge_l":0.7709760925841327}
{"id":1030,"predictions":["def sumofseries ( n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT res += ( i * ( i + 1 ) * ( i + 2 ) ) NEW_LINE DEDENT return res NEW_LINE DEDENT print ( sumofseries ( 3 ) ) NEW_LINE"],"references":["def sumofseries ( n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT res += ( i ) * ( i + 1 ) * ( i + 2 ) NEW_LINE DEDENT return res NEW_LINE DEDENT print ( sumofseries ( 3 ) ) NEW_LINE"],"bleu":0.9452226833707934,"rouge_l":0.9824561403508771}
{"id":1031,"predictions":["def countWaysToJump ( arr , n ) : NEW_LINE INDENT count_ jumps = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] >= n - i - 1 ) : NEW_LINE INDENT count_ jumps [ i ] += 1 NEW_LINE DEDENT for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT if ( count_ jumps [ j ] != - 1 ) : NEW_LINE INDENT count_ jumps [ i ] += count_ jumps [ j ] NEW_LINE DEDENT DEDENT if ( count_ jumps [ i ] == 0 ) : NEW_LINE INDENT count_ jumps [ i ] = - 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( count_ jumps [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 1 , 3 , 5 , 8 , 9 , 1 , 8 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE countWaysToJump ( arr , n ) NEW_LINE"],"references":["def countWaysToJump ( arr , n ) : NEW_LINE INDENT count_jump = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] >= n - i - 1 ) : NEW_LINE INDENT count_jump [ i ] += 1 NEW_LINE DEDENT j = i + 1 NEW_LINE while ( j < n - 1 and j <= arr [ i ] + i ) : NEW_LINE INDENT if ( count_jump [ j ] != - 1 ) : NEW_LINE INDENT count_jump [ i ] += count_jump [ j ] NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( count_jump [ i ] == 0 ) : NEW_LINE INDENT count_jump [ i ] = - 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( count_jump [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 1 , 3 , 5 , 8 , 9 , 1 , 0 , 7 , 6 , 8 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE countWaysToJump ( arr , n ) NEW_LINE"],"bleu":0.7440399670899562,"rouge_l":0.8617210203422667}
{"id":1032,"predictions":["def calculateSum ( n ) : NEW_LINE INDENT return 2 * ( pow ( n , 6 ) + 15 * pow ( n , 4 ) + 15 * pow ( n , 2 ) + 1 ) ) NEW_LINE DEDENT n = 1.4142 NEW_LINE print ( ceil ( n ) ) NEW_LINE"],"references":["import math NEW_LINE def calculateSum ( n ) : NEW_LINE INDENT a = int ( n ) NEW_LINE return ( 2 * ( pow ( n , 6 ) + 15 * pow ( n , 4 ) + 15 * pow ( n , 2 ) + 1 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 1.4142 NEW_LINE print ( math . ceil ( calculateSum ( n ) ) ) NEW_LINE DEDENT"],"bleu":0.5059617335741659,"rouge_l":0.7530864197530865}
{"id":1033,"predictions":["def isMajority ( a , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] in mp . keys ( ) : NEW_LINE INDENT mp [ a [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ a [ i ] ] = 1 NEW_LINE DEDENT DEDENT for key , value in mp . items ( ) : NEW_LINE INDENT if ( value >= n \/\/ 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT a = [ 2 , 3 , 9 , 2 , 2 ] NEW_LINE n = len ( a ) NEW_LINE if ( isMajority ( a , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def isMajority ( a ) : NEW_LINE INDENT mp = { } NEW_LINE for i in a : NEW_LINE INDENT if i in mp : mp [ i ] += 1 NEW_LINE else : mp [ i ] = 1 NEW_LINE DEDENT for x in mp : NEW_LINE INDENT if mp [ x ] >= len ( a ) \/\/ 2 : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT a = [ 2 , 3 , 9 , 2 , 2 ] NEW_LINE print ( \" Yes \" if isMajority ( a ) else \" No \" ) NEW_LINE"],"bleu":0.4090662749550743,"rouge_l":0.7045001991238551}
{"id":1034,"predictions":["def return maxPossible ( A , B , n ) : NEW_LINE INDENT mp = set ( ) NEW_LINE result = 0 NEW_LINE curr_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while A [ curr_start ] in mp . keys ( ) : NEW_LINE INDENT curr_sum -= B [ curr_sum ] NEW_LINE curr_sum -= B [ curr_start ] NEW_LINE curr_sum += 1 NEW_LINE DEDENT mp . add ( A [ i ] ) NEW_LINE curr_sum += B [ i ] NEW_LINE result = max ( result , curr_sum ) NEW_LINE DEDENT return result NEW_LINE DEDENT A = [ 0 , 1 , 2 , 3 , 0 , 1 , 4 ] NEW_LINE B = [ 9 , 8 , 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( A ) NEW_LINE print ( returnMaxSum ( A , B , n ) ) NEW_LINE"],"references":["def returnMaxSum ( A , B , n ) : NEW_LINE INDENT mp = set ( ) NEW_LINE result = 0 NEW_LINE curr_sum = curr_begin = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT while A [ i ] in mp : NEW_LINE INDENT mp . remove ( A [ curr_begin ] ) NEW_LINE curr_sum -= B [ curr_begin ] NEW_LINE curr_begin += 1 NEW_LINE DEDENT mp . add ( A [ i ] ) NEW_LINE curr_sum += B [ i ] NEW_LINE result = max ( result , curr_sum ) NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 0 , 1 , 2 , 3 , 0 , 1 , 4 ] NEW_LINE B = [ 9 , 8 , 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( A ) NEW_LINE print ( returnMaxSum ( A , B , n ) ) NEW_LINE DEDENT"],"bleu":0.7530317030936484,"rouge_l":0.8643479984145858}
{"id":1035,"predictions":["def hasPath ( root , arr , x ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return False NEW_LINE DEDENT arr . append ( root . data ) NEW_LINE if ( root . data == x ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( hasPath ( root . left , arr , x ) or hasPath ( root . right , arr , x ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT arr . pop ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No ▁ Path \" ) NEW_LINE DEDENT DEDENT def printPath ( root , x ) : NEW_LINE INDENT arr = [ ] NEW_LINE if ( hasPath ( root , arr , x ) ) : NEW_LINE INDENT for i in range ( 0 , len ( arr ) - 1 ) : NEW_LINE INDENT print ( arr [ i ] , \" - > \" , end = \" \" ) NEW_LINE DEDENT print ( arr [ - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = Node ( 1 ) NEW_LINE root . left = Node ( 2 ) NEW_LINE root . right = Node ( 3 ) NEW_LINE root . left . left = Node ( 4 ) NEW_LINE root . left . right = Node ( 5 ) NEW_LINE root . left . left . right = Node ( 5 ) NEW_LINE root . right . left . right = Node ( 5 ) NEW_LINE root . right . left = Node ( 7 ) NEW_LINE root . right . right = Node ( 5 ) NEW_LINE printPath ( root , x ) NEW_LINE DEDENT DEDENT"],"references":["class getNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = self . right = None NEW_LINE DEDENT DEDENT def hasPath ( root , arr , x ) : NEW_LINE INDENT if ( not root ) : NEW_LINE INDENT return False NEW_LINE DEDENT arr . append ( root . data ) NEW_LINE if ( root . data == x ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( hasPath ( root . left , arr , x ) or hasPath ( root . right , arr , x ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT arr . pop ( - 1 ) NEW_LINE return False NEW_LINE DEDENT def printPath ( root , x ) : NEW_LINE INDENT arr = [ ] NEW_LINE if ( hasPath ( root , arr , x ) ) : NEW_LINE INDENT for i in range ( len ( arr ) - 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" - > \" ) NEW_LINE DEDENT print ( arr [ len ( arr ) - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No ▁ Path \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = getNode ( 1 ) NEW_LINE root . left = getNode ( 2 ) NEW_LINE root . right = getNode ( 3 ) NEW_LINE root . left . left = getNode ( 4 ) NEW_LINE root . left . right = getNode ( 5 ) NEW_LINE root . right . left = getNode ( 6 ) NEW_LINE root . right . right = getNode ( 7 ) NEW_LINE x = 5 NEW_LINE printPath ( root , x ) NEW_LINE DEDENT"],"bleu":0.7695505189475129,"rouge_l":0.8164995733788397}
{"id":1036,"predictions":["def SieveofEratosthenes ( prime , p_size ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , p_size + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( p * 2 , p_size + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def xorOfElements ( arr , n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) NEW_LINE SieveOfEratosthenes ( prime , n + 1 ) NEW_LINE m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT m [ arr [ i ] ] = m . get ( arr [ i ] , 0 ) + 1 NEW_LINE if ( prime [ arr [ i ] ] ) : NEW_LINE INDENT xor ^= ( key ) NEW_LINE DEDENT DEDENT return xor NEW_LINE DEDENT arr = [ 5 , 4 , 4 , 6 , 5 , 4 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( xorOfElements ( arr , n ) ) NEW_LINE"],"references":["from math import sqrt NEW_LINE def SieveOfEratosthenes ( prime , p_size ) : NEW_LINE INDENT prime [ 0 ] = False ; NEW_LINE prime [ 1 ] = False ; NEW_LINE for p in range ( 2 , int ( sqrt ( p_size ) ) + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( p * 2 , p_size + 1 , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT DEDENT return prime NEW_LINE DEDENT def xorPrimeFreq ( arr , n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) ; NEW_LINE prime = SieveOfEratosthenes ( prime , n + 1 ) ; NEW_LINE m = dict . fromkeys ( arr , 0 ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT m [ arr [ i ] ] += 1 ; NEW_LINE DEDENT xorVal = 0 ; NEW_LINE for key , value in m . items ( ) : NEW_LINE INDENT if ( prime [ value ] ) : NEW_LINE INDENT xorVal ^= key ; NEW_LINE DEDENT DEDENT return xorVal ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 5 , 4 , 6 , 5 , 4 , 6 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( xorPrimeFreq ( arr , n ) ) ; NEW_LINE DEDENT"],"bleu":0.6033710827398848,"rouge_l":0.772311291543384}
{"id":1037,"predictions":["def minimumFlip ( s , x , y ) : NEW_LINE INDENT s = s + s NEW_LINE isOpposite = False NEW_LINE if ( x > y ) : NEW_LINE INDENT x , y = x , y NEW_LINE isOppwise = True NEW_LINE DEDENT val_curwise = 0 NEW_LINE cur = s [ x ] NEW_LINE for i in range ( x , y + 1 ) : NEW_LINE INDENT if ( s [ i ] != cur ) : NEW_LINE INDENT cur = s [ i ] NEW_LINE val_wise += 1 NEW_LINE DEDENT DEDENT val != 0 NEW_LINE cur = s [ y ] NEW_LINE x = s [ y ] NEW_LINE x += len ( s ) NEW_LINE for i in range ( y , x ) : NEW_LINE INDENT if ( s [ i ] != cur ) : NEW_LINE INDENT cur = s [ i ] NEW_LINE valPainwise += 1 NEW_LINE DEDENT DEDENT if ( val != 0 ) : NEW_LINE INDENT if ( not isOppwise ) : NEW_LINE INDENT print ( \" Equwise \" , valLenwise ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Previous - clockwise \" ) NEW_LINE DEDENT DEDENT if ( not ( isOppwise ) ) : NEW_LINE INDENT print ( \" Altwise \" , valLen ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Characterwise \" , valLongwise ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x , y = 0 , 8 NEW_LINE minimumFlip ( s , x , y ) NEW_LINE DEDENT"],"references":["def minimumFlip ( s , x , y ) : NEW_LINE INDENT s = s + s NEW_LINE isOpposite = False NEW_LINE if ( x > y ) : NEW_LINE INDENT temp = y NEW_LINE y = x ; NEW_LINE x = temp NEW_LINE isOpposite = True NEW_LINE DEDENT valClockwise = 0 NEW_LINE cur = s [ x ] NEW_LINE for i in range ( x , y + 1 , 1 ) : NEW_LINE INDENT if ( s [ i ] != cur ) : NEW_LINE INDENT cur = s [ i ] NEW_LINE valClockwise += 1 NEW_LINE DEDENT DEDENT valAnticlockwise = 0 NEW_LINE cur = s [ y ] NEW_LINE x += len ( s ) - 1 NEW_LINE for i in range ( y , x + 1 , 1 ) : NEW_LINE INDENT if ( s [ i ] != cur ) : NEW_LINE INDENT cur = s [ i ] NEW_LINE valAnticlockwise += 1 NEW_LINE DEDENT DEDENT if ( valClockwise <= valAnticlockwise ) : NEW_LINE INDENT if ( isOpposite == False ) : NEW_LINE INDENT print ( \" Clockwise \" , valClockwise ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Anti - clockwise \" , valAnticlockwise ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( isOpposite == False ) : NEW_LINE INDENT print ( \" Anti - clockwise \" , valAnticlockwise ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Clockwise \" , valClockwise ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 0 NEW_LINE y = 8 NEW_LINE s = \"000110\" NEW_LINE minimumFlip ( s , x , y ) NEW_LINE DEDENT"],"bleu":0.6688891059509905,"rouge_l":0.8211817965213247}
{"id":1038,"predictions":["MAX = 26 NEW_LINE def maxSubStr ( str1 , len1 , str2 , len2 ) : NEW_LINE INDENT if ( len1 > len2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT freq1 = [ 0 for i in range ( MAX ) ] NEW_LINE for i in range ( len1 ) : NEW_LINE INDENT freq1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT freq2 = [ 0 for i in range ( MAX ) ] NEW_LINE for i in range ( len2 ) : NEW_LINE INDENT freq2 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( MAX ) : NEW_LINE INDENT freq2 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT minPoss = 10 ** 9 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT freq2 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT minPoss = sys . maxsize NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if ( freq1 [ i ] == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( freq1 [ i ] > freq2 [ i ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT minPoss = min ( minPoss , freq2 [ i ] \/\/ freq1 [ i ] ) NEW_LINE DEDENT return minPoss NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" geeks \" NEW_LINE str2 = \" gskebe \" NEW_LINE len1 = len1 NEW_LINE len2 = len ( str1 ) NEW_LINE print ( maxSubStr ( str1 , len1 , str2 ) ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE MAX = 26 ; NEW_LINE def maxSubStr ( str1 , len1 , str2 , len2 ) : NEW_LINE INDENT if ( len1 > len2 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT freq1 = [ 0 ] * MAX ; NEW_LINE for i in range ( len1 ) : NEW_LINE INDENT freq1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT freq2 = [ 0 ] * MAX ; NEW_LINE for i in range ( len2 ) : NEW_LINE INDENT freq2 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT minPoss = sys . maxsize ; NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if ( freq1 [ i ] == 0 ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT if ( freq1 [ i ] > freq2 [ i ] ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT minPoss = min ( minPoss , freq2 [ i ] \/ freq1 [ i ] ) ; NEW_LINE DEDENT return int ( minPoss ) ; NEW_LINE DEDENT str1 = \" geeks \" ; str2 = \" gskefrgoekees \" ; NEW_LINE len1 = len ( str1 ) ; NEW_LINE len2 = len ( str2 ) ; NEW_LINE print ( maxSubStr ( str1 , len1 , str2 , len2 ) ) ; NEW_LINE"],"bleu":0.578837520795318,"rouge_l":0.7693760662929564}
{"id":1039,"predictions":["def isValidString ( st , n ) : NEW_LINE INDENT index = st . find ( \" b \" ) ; NEW_LINE if ( index == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT while ( index != - 1 ) : NEW_LINE INDENT if ( st [ index - 1 ] != ' a ' ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT if ( index + 1 < n and st [ index + 1 ] != ' b ' ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT if ( index + 2 < n and st [ index + 2 ] == ' b ' ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT if ( index + 2 < n and st [ index + 2 ] == ' b ' ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT if ( index == n - 1 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT index = st . index ( \" b \" , index + 2 ) ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT st = \" abbaaabbabba \" ; NEW_LINE n = len ( st ) ; NEW_LINE print ( isValidString ( st , n ) ) ; NEW_LINE DEDENT"],"references":["def isValidString ( str , n ) : NEW_LINE INDENT idx = str . find ( \" b \" ) NEW_LINE if ( idx == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( idx != - 1 ) : NEW_LINE INDENT if ( str [ idx - 1 ] != ' a ' ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( idx + 1 < n and str [ idx + 1 ] != ' b ' ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( idx + 2 < n and str [ idx + 2 ] == ' b ' ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( idx == n - 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT idx = str . find ( \" b \" , idx + 2 ) NEW_LINE DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" abbaaabbabba \" NEW_LINE n = len ( str ) NEW_LINE print ( isValidString ( str , n ) ) NEW_LINE DEDENT"],"bleu":0.5339258039640955,"rouge_l":0.8203414398453859}
{"id":1040,"predictions":["def gcd ( a , b ) : NEW_LINE INDENT if ( ( a % b ) == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT def firstFactorialDivisibleNumber ( x ) : NEW_LINE INDENT i = 1 NEW_LINE new_x = x NEW_LINE for i in range ( 1 , x ) : NEW_LINE INDENT new_x \/= gcd ( i , new_x ) NEW_LINE if ( new_x == 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return i NEW_LINE DEDENT x = 16 NEW_LINE print ( firstFactorialDivisibleNumber ( x ) ) NEW_LINE"],"references":["def gcd ( a , b ) : NEW_LINE INDENT if ( ( a % b ) == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT def firstFactorialDivisibleNumber ( x ) : NEW_LINE INDENT i = 1 NEW_LINE new_x = x NEW_LINE for i in range ( 1 , x ) : NEW_LINE INDENT new_x \/= gcd ( i , new_x ) NEW_LINE if ( new_x == 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return i NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT x = 16 NEW_LINE print ( firstFactorialDivisibleNumber ( x ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"bleu":0.7673741120494363,"rouge_l":0.8714285714285713}
{"id":1041,"predictions":["def xorLessK ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT tempXor = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT tempXor ^= arr [ j ] NEW_LINE if ( tempXor < k ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT k = 3 NEW_LINE arr = [ 8 , 9 , 10 , 11 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE print ( xorLessK ( arr , n , k ) ) NEW_LINE"],"references":["def xorLessK ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT tempXor = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT tempXor ^= arr [ j ] NEW_LINE if ( tempXor < k ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT k = 3 NEW_LINE arr = [ 8 , 9 , 10 , 11 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE print ( xorLessK ( arr , n , k ) ) NEW_LINE DEDENT"],"bleu":0.863664760853872,"rouge_l":0.927690100430416}
{"id":1042,"predictions":["def findNumbers ( arr , n ) : NEW_LINE INDENT num = [ 0 for i in range ( n ) ] NEW_LINE b_minus_a = arr [ n - 1 ] - arr [ 1 ] NEW_LINE num [ 1 ] = ( arr [ 0 ] + b_minus_a ) \/\/ 2 NEW_LINE num [ 0 ] = arr [ 0 ] - num [ 1 ] NEW_LINE for i in range ( 1 , ( n - 2 ) + 1 ) : NEW_LINE INDENT num [ i + 1 ] = arr [ i ] - num [ 0 ] NEW_LINE DEDENT num [ 0 ] = arr [ 0 ] - num [ 1 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT num [ i + 1 ] = arr [ i ] - num [ 0 ] NEW_LINE DEDENT print ( \" Numbers ▁ are : ▁ \" , end = \" \" ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( num [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 10 , 0 , 4 , 5 , 5 , 6 , 8 , 30 , 31 ] NEW_LINE n = 5 NEW_LINE findNumbers ( arr , n ) NEW_LINE DEDENT"],"references":["def findNumbers ( arr , n ) : NEW_LINE INDENT num = [ 0 for i in range ( n ) ] NEW_LINE b_minus_a = arr [ n - 1 ] - arr [ 1 ] NEW_LINE num [ 1 ] = ( arr [ 0 ] + b_minus_a ) \/\/ 2 NEW_LINE num [ 0 ] = arr [ 0 ] - num [ 1 ] NEW_LINE for i in range ( 1 , ( n - 2 ) + 1 ) : NEW_LINE INDENT num [ i + 1 ] = arr [ i ] - num [ 0 ] NEW_LINE DEDENT print ( \" Numbers ▁ are : ▁ \" , end = \" \" ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( num [ i ] , end = \" , ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 13 , 10 , 14 , 9 , 17 , 21 , 16 , 18 , 13 , 17 ] NEW_LINE n = 5 NEW_LINE findNumbers ( arr , n ) NEW_LINE"],"bleu":0.6717534121037096,"rouge_l":0.8343465045592705}
{"id":1043,"predictions":["pr = [ ] NEW_LINE prime = [ True for i in range ( 10000000 + 1 ) ] NEW_LINE def sieve ( n ) : NEW_LINE INDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT prime [ i ] = True NEW_LINE DEDENT p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT pr . append ( p ) NEW_LINE DEDENT DEDENT DEDENT def SemiPrimeSum ( N ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , len ( pr ) ) : NEW_LINE INDENT for j in range ( i , len ( pr ) , 1 ) : NEW_LINE INDENT if ( pr [ i ] * pr [ j ] > N ) : NEW_LINE INDENT break NEW_LINE DEDENT ans += pr [ i ] * pr [ j ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT N = 6 NEW_LINE sieve ( N ) NEW_LINE print ( SemiPrimeSum ( N ) ) NEW_LINE"],"references":["pr = [ ] NEW_LINE prime = [ 1 for i in range ( 10000000 + 1 ) ] NEW_LINE def sieve ( n ) : NEW_LINE INDENT for p in range ( 2 , n ) : NEW_LINE INDENT if p * p > n : NEW_LINE INDENT break NEW_LINE DEDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( 2 * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT pr . append ( p ) NEW_LINE DEDENT DEDENT DEDENT def SemiPrimeSum ( N ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( len ( pr ) ) : NEW_LINE INDENT for j in range ( i , len ( pr ) ) : NEW_LINE INDENT if ( pr [ i ] * pr [ j ] > N ) : NEW_LINE INDENT break NEW_LINE DEDENT ans += pr [ i ] * pr [ j ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT N = 6 NEW_LINE sieve ( N ) NEW_LINE print ( SemiPrimeSum ( N ) ) NEW_LINE"],"bleu":0.8251714382070805,"rouge_l":0.9276738540625445}
{"id":1044,"predictions":["def largestPalinSub ( s ) : NEW_LINE INDENT res = \" \" NEW_LINE mx = s [ 0 ] NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT mx = chr ( mx , s [ i ] ) NEW_LINE DEDENT for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == mx ) : NEW_LINE INDENT res += s [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT s = \" geeksforgeeks \" NEW_LINE print ( largestPalinSub ( s ) ) NEW_LINE"],"references":["def largestPalinSub ( s ) : NEW_LINE INDENT res = \" \" NEW_LINE mx = s [ 0 ] NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT mx = max ( mx , s [ i ] ) NEW_LINE DEDENT for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT if s [ i ] == mx : NEW_LINE INDENT res += s [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" geeksforgeeks \" NEW_LINE print ( largestPalinSub ( s ) ) NEW_LINE DEDENT"],"bleu":0.8087477754229484,"rouge_l":0.907574391343553}
{"id":1045,"predictions":["def allAllPalindrome ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( * s [ i ] == n ) : NEW_LINE INDENT return ( arr [ i ] [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT allPalindrome ( s ) : NEW_LINE INDENT allPalindrome ( s ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT for j in range ( len ( s ) ) : NEW_LINE INDENT print ( arr [ i ] [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"references":["def isPalindrome ( string : str , low : int , high : int ) : NEW_LINE INDENT while low < high : NEW_LINE INDENT if string [ low ] != string [ high ] : NEW_LINE INDENT return False NEW_LINE DEDENT low += 1 NEW_LINE high -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def allPalPartUtil ( allPart : list , currPart : list , start : int , n : int , string : str ) : NEW_LINE INDENT if start >= n : NEW_LINE INDENT x = currPart . copy ( ) NEW_LINE allPart . append ( x ) NEW_LINE return NEW_LINE DEDENT for i in range ( start , n ) : NEW_LINE INDENT if isPalindrome ( string , start , i ) : NEW_LINE INDENT currPart . append ( string [ start : i + 1 ] ) NEW_LINE allPalPartUtil ( allPart , currPart , i + 1 , n , string ) NEW_LINE currPart . pop ( ) NEW_LINE DEDENT DEDENT DEDENT def allPalPartitions ( string : str ) : NEW_LINE INDENT n = len ( string ) NEW_LINE allPart = [ ] NEW_LINE currPart = [ ] NEW_LINE allPalPartUtil ( allPart , currPart , 0 , n , string ) NEW_LINE for i in range ( len ( allPart ) ) : NEW_LINE INDENT for j in range ( len ( allPart [ i ] ) ) : NEW_LINE INDENT print ( allPart [ i ] [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" nitin \" NEW_LINE allPalPartitions ( string ) NEW_LINE DEDENT"],"bleu":0.21324002505696021,"rouge_l":0.4739670321690509}
{"id":1046,"predictions":["def findLength ( str , n ) : NEW_LINE INDENT current_sum = 0 NEW_LINE max_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT current_sum += ( str [ i ] == '0' ) NEW_LINE DEDENT if ( current_sum < 0 ) : NEW_LINE INDENT current_sum = 0 NEW_LINE DEDENT max_sum = max ( current_sum , max_sum ) NEW_LINE DEDENT return - 1 if ( max_sum == 0 else max_sum ) NEW_LINE DEDENT str = \"1100001001\" NEW_LINE n = len ( str ) NEW_LINE print ( findLength ( str , n ) ) NEW_LINE"],"references":["def findLength ( string , n ) : NEW_LINE INDENT current_sum = 0 NEW_LINE max_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT current_sum += ( 1 if string [ i ] == '0' else - 1 ) NEW_LINE if current_sum < 0 : NEW_LINE INDENT current_sum = 0 NEW_LINE DEDENT max_sum = max ( current_sum , max_sum ) NEW_LINE DEDENT return max_sum if max_sum else 0 NEW_LINE DEDENT s = \"11000010001\" NEW_LINE n = 11 NEW_LINE print ( findLength ( s , n ) ) NEW_LINE"],"bleu":0.6334722569951309,"rouge_l":0.8363415480735857}
{"id":1047,"predictions":["def Ans ( Arr , N , K ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( Arr [ i ] == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( K >= ( N - count ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT Arr = [ 5 , 1 , 2 ] NEW_LINE N = len ( Arr ) NEW_LINE K = 2 NEW_LINE result = Print ( \" Not ▁ Possible \" ) NEW_LINE if ( result == 1 ) : NEW_LINE INDENT print ( \" Possible \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ Possible \" ) NEW_LINE DEDENT DEDENT"],"references":["def Series ( Arr , N , K ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if Arr [ i ] == 1 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if K >= ( N - count ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT Arr = [ 5 , 1 , 2 ] NEW_LINE N = len ( Arr ) NEW_LINE K = 2 NEW_LINE result = Series ( Arr , N , K ) NEW_LINE if result == 1 : NEW_LINE INDENT print ( \" Possible \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ Possible \" ) NEW_LINE DEDENT"],"bleu":0.7536797175695987,"rouge_l":0.9060966158615347}
{"id":1048,"predictions":["def countDigit ( n ) : NEW_LINE INDENT prime = [ True ] * 10 NEW_LINE prime [ 2 ] = prime [ 3 ] = True NEW_LINE prime [ 5 ] = True NEW_LINE temp = n NEW_LINE count = 0 NEW_LINE while ( temp ) : NEW_LINE INDENT d = temp % 10 NEW_LINE temp \/\/= 10 NEW_LINE if ( d > 0 and n % d == 0 and prime [ d ] == 0 and prime [ d ] == True ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 1032 NEW_LINE print ( countDigit ( n ) ) NEW_LINE DEDENT"],"references":["def countDigit ( n ) : NEW_LINE INDENT prime = [ False ] * 10 NEW_LINE prime [ 2 ] = True NEW_LINE prime [ 3 ] = True ; NEW_LINE prime [ 5 ] = True NEW_LINE prime [ 7 ] = True ; NEW_LINE temp = n NEW_LINE count = 0 ; NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT d = temp % 10 ; NEW_LINE temp \/\/= 10 ; NEW_LINE if ( d > 0 and n % d == 0 and prime [ d ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT n = 1032 NEW_LINE print ( countDigit ( n ) ) NEW_LINE"],"bleu":0.7129958258400393,"rouge_l":0.8356164383561645}
{"id":1049,"predictions":["from math import tan NEW_LINE def polyapotEm ( n , a ) : NEW_LINE INDENT if ( a < 0 and n < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ( a \/ ( 2 * tan ( ( 180 \/ n ) * 3.14159 \/ 180 ) ) ) NEW_LINE DEDENT a = 9 NEW_LINE n = 6 NEW_LINE print ( polyapom ( n , a ) ) NEW_LINE"],"references":["from math import tan NEW_LINE def polyapothem ( n , a ) : NEW_LINE INDENT if ( a < 0 and n < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return a \/ ( 2 * tan ( ( 180 \/ n ) * 3.14159 \/ 180 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 9 NEW_LINE n = 6 NEW_LINE print ( ' { 0 : . 6 } ' . format ( polyapothem ( n , a ) ) ) NEW_LINE DEDENT"],"bleu":0.6287075288827404,"rouge_l":0.7939754555596876}
{"id":1050,"predictions":["def evenPowerSum ( n ) : NEW_LINE INDENT return ( 8 * n * ( n + 1 ) * ( 2 * n + 1 ) * ( 3 * n * n + 3 * n - 1 ) ) \/\/ 15 NEW_LINE DEDENT n = 4 NEW_LINE print ( evenPowerSum ( n ) ) NEW_LINE"],"references":["def evenPowerSum ( n ) : NEW_LINE INDENT return ( 8 * n * ( n + 1 ) * ( 2 * n + 1 ) * ( 3 * n * n + 3 * n - 1 ) ) \/ 15 ; NEW_LINE DEDENT n = 4 ; NEW_LINE print ( int ( evenPowerSum ( n ) ) ) ; NEW_LINE"],"bleu":0.8003231454000165,"rouge_l":0.9262120404901438}
{"id":1051,"predictions":["def printModulus ( X , Y ) : NEW_LINE INDENT n = max ( X , Y ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( X % i == Y % i ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT X = 10 NEW_LINE Y = 25 NEW_LINE printModulus ( X , Y ) NEW_LINE"],"references":["def printModulus ( X , Y ) : NEW_LINE INDENT n = max ( X , Y ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( X % i == Y % i ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT X = 10 NEW_LINE Y = 20 NEW_LINE printModulus ( X , Y ) NEW_LINE"],"bleu":0.949135758036098,"rouge_l":0.9786813186813189}
{"id":1052,"predictions":["def __gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a ; NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return __gcd ( a - b , b ) ; NEW_LINE DEDENT return __gcd ( a , b - a ) ; NEW_LINE DEDENT def minValidNumber ( p , q ) : NEW_LINE INDENT if ( q % p == 0 ) : NEW_LINE INDENT return __gcd ( p , q ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT p = 2 ; q = 6 ; NEW_LINE print ( minValidNumber ( p , q ) ) ; NEW_LINE DEDENT"],"references":["from math import gcd NEW_LINE def minValidNumber ( p , q ) : NEW_LINE INDENT if ( q % p == 0 ) : NEW_LINE INDENT return gcd ( p , q ) NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT p , q = 2 , 6 ; NEW_LINE print ( minValidNumber ( p , q ) ) NEW_LINE DEDENT"],"bleu":0.4029655863235083,"rouge_l":0.6486404374905059}
{"id":1053,"predictions":["def maxSum ( arr , n , k ) : NEW_LINE INDENT if ( n < k ) : NEW_LINE INDENT print ( \" Invalid \" ) NEW_LINE return - 1 NEW_LINE DEDENT max_sum = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT max_sum += arr [ i ] NEW_LINE DEDENT window_sum = max_sum NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT window_sum += arr [ i ] - arr [ i - k ] NEW_LINE max_sum = max ( max_sum , window_sum ) NEW_LINE DEDENT return max_sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 4 , 2 , 10 , 2 , 3 , 1 , 0 , 20 ] NEW_LINE k = 4 NEW_LINE n = len ( arr ) NEW_LINE print ( maxSum ( arr , n , k ) ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE INT_MIN = - sys . maxsize - 1 NEW_LINE def maxSum ( arr , n , k ) : NEW_LINE INDENT if not n > k : NEW_LINE INDENT print ( \" Invalid \" ) NEW_LINE return - 1 NEW_LINE DEDENT max_sum = INT_MIN NEW_LINE window_sum = sum ( arr [ : k ] ) NEW_LINE for i in range ( n - k ) : NEW_LINE INDENT window_sum = window_sum - arr [ i ] + arr [ i + k ] NEW_LINE max_sum = max ( window_sum , max_sum ) NEW_LINE DEDENT return max_sum NEW_LINE DEDENT arr = [ 1 , 4 , 2 , 10 , 2 , 3 , 1 , 0 , 20 ] NEW_LINE k = 4 NEW_LINE n = len ( arr ) NEW_LINE print ( maxSum ( arr , n , k ) ) NEW_LINE"],"bleu":0.6403119643332696,"rouge_l":0.7686291548989789}
{"id":1054,"predictions":["def sort ( a , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( ( a [ i ] + a [ j ] ) < a [ j ] + a [ i ] ) : NEW_LINE INDENT s = a [ i ] NEW_LINE a [ i ] = a [ j ] NEW_LINE a [ j ] = s NEW_LINE DEDENT DEDENT DEDENT DEDENT def lexsmallest ( a , n ) : NEW_LINE INDENT a = sorted ( a , n ) NEW_LINE answer = \" \" NEW_LINE for i in range ( n ) : NEW_LINE INDENT answer += a [ i ] NEW_LINE DEDENT return answer NEW_LINE DEDENT a = [ \" c \" , \" cb \" , \" cba \" ] NEW_LINE n = 3 NEW_LINE print ( \" lextographical ▁ smallest ▁ string ▁ = ▁ \" , lexsmallest ( a , n ) ) NEW_LINE"],"references":["def lexSmallest ( a , n ) : NEW_LINE INDENT a . sort ( reverse = True ) NEW_LINE answer = \" \" NEW_LINE for i in range ( n ) : NEW_LINE INDENT answer += a [ i ] NEW_LINE DEDENT return answer NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ \" c \" , \" cb \" , \" cba \" ] NEW_LINE n = len ( a ) NEW_LINE print ( lexSmallest ( a , n ) ) NEW_LINE DEDENT"],"bleu":0.3657241320664071,"rouge_l":0.543236964377904}
{"id":1055,"predictions":["from collections import defaultdict NEW_LINE def printAnagrams ( arr , n ) : NEW_LINE INDENT map = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT word = arr [ i ] NEW_LINE letters . sort ( ) NEW_LINE newWord = [ ] NEW_LINE if ( newWord in sorted ( letters ) ) : NEW_LINE INDENT map . append ( word ) NEW_LINE DEDENT else : NEW_LINE INDENT words = [ ] NEW_LINE words . append ( word ) NEW_LINE DEDENT DEDENT for s in map : NEW_LINE INDENT if ( len ( values ) > 1 ) : NEW_LINE INDENT print ( values ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ \" cat \" , \" dog \" , \" pet \" , \" pet \" \" , \" pet \" ] NEW_LINE printAnagrams ( arr ) NEW_LINE DEDENT"],"references":["from collections import defaultdict NEW_LINE def printAnagramsTogether ( words ) : NEW_LINE INDENT groupedWords = defaultdict ( list ) NEW_LINE for word in words : NEW_LINE INDENT groupedWords [ \" \" . join ( sorted ( word ) ) ] . append ( word ) NEW_LINE DEDENT for group in groupedWords . values ( ) : NEW_LINE INDENT print ( \" ▁ \" . join ( group ) ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ \" cat \" , \" dog \" , \" tac \" , \" god \" , \" act \" ] NEW_LINE printAnagramsTogether ( arr ) NEW_LINE DEDENT"],"bleu":0.38539189627690884,"rouge_l":0.6559950556242273}
{"id":1056,"predictions":["def commonPrefixUtil ( str1 , str2 ) : NEW_LINE INDENT result = \" \" NEW_LINE n1 = len ( str1 ) NEW_LINE n2 = len ( str2 ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while ( i <= n1 - 1 and j <= n2 - 1 ) : NEW_LINE INDENT if ( str1 [ i ] != str2 [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT result += str1 [ i ] NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT return ( result ) NEW_LINE DEDENT def commonPrefix ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE print ( commonPrefixUtil ( arr [ 0 ] , arr [ n - 1 ] ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ \" geeksforgeeks \" , \" geeks \" , \" geeks \" ] NEW_LINE n = len ( arr ) NEW_LINE commonPrefix ( arr , n ) NEW_LINE DEDENT"],"references":["def commonPrefixUtil ( str1 , str2 ) : NEW_LINE INDENT n1 = len ( str1 ) NEW_LINE n2 = len ( str2 ) NEW_LINE result = \" \" NEW_LINE j = 0 NEW_LINE i = 0 NEW_LINE while ( i <= n1 - 1 and j <= n2 - 1 ) : NEW_LINE INDENT if ( str1 [ i ] != str2 [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT result += ( str1 [ i ] ) NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT return ( result ) NEW_LINE DEDENT def commonPrefix ( arr , n ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE print ( commonPrefixUtil ( arr [ 0 ] , arr [ n - 1 ] ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ \" geeksforgeeks \" , \" geeks \" , \" geek \" , \" geezer \" ] NEW_LINE n = len ( arr ) NEW_LINE commonPrefix ( arr , n ) NEW_LINE DEDENT"],"bleu":0.8600225794989125,"rouge_l":0.914130734577549}
{"id":1057,"predictions":["def changeTheArray ( arr , n ) : NEW_LINE INDENT minEle = min ( arr ) NEW_LINE maxEle = max ( arr ) NEW_LINE maxEle = max ( arr ) NEW_LINE minEle = max ( arr ) NEW_LINE for num in range ( minEle , maxEle + 1 ) : NEW_LINE INDENT operations = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] != num ) : NEW_LINE INDENT operations += ( abs ( num - arr [ i ] ) - 1 ) NEW_LINE DEDENT DEDENT minOperations = min ( minOperations , operations ) NEW_LINE DEDENT return minOperations NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 10 , 1 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( changeTheArray ( arr , n ) ) NEW_LINE DEDENT"],"references":["import math NEW_LINE import sys NEW_LINE def changeTheArray ( arr , n ) : NEW_LINE INDENT minEle = min ( arr ) NEW_LINE maxEle = max ( arr ) NEW_LINE minOperations = sys . maxsize NEW_LINE for num in range ( minEle , maxEle + 1 ) : NEW_LINE INDENT operations = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] != num : NEW_LINE INDENT operations += ( abs ( num - arr [ i ] ) - 1 ) NEW_LINE DEDENT DEDENT minOperations = min ( minOperations , operations ) NEW_LINE DEDENT return minOperations NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 10 , 1 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( changeTheArray ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.8731061060407451,"rouge_l":0.9216940553656117}
{"id":1058,"predictions":["def findElements ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( arr [ j ] > arr [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count >= 2 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 2 , - 6 , 3 , 5 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE findElements ( arr , n ) NEW_LINE"],"references":["def findElements ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if arr [ j ] > arr [ i ] : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT if count >= 2 : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 2 , - 6 , 3 , 5 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE findElements ( arr , n ) NEW_LINE"],"bleu":0.8692515502445557,"rouge_l":0.9545454545454546}
{"id":1059,"predictions":["def cntSubArrays ( arr , n , k ) : NEW_LINE INDENT res = 0 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT j = i + 1 NEW_LINE while ( j < n and arr [ j ] >= arr [ j - 1 ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT res += max ( j - i - k + 1 , 0 ) NEW_LINE i = j NEW_LINE DEDENT return res NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 2 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE print ( cntSubArrays ( arr , n , k ) ) NEW_LINE"],"references":["def cntSubArrays ( arr , n , k ) : NEW_LINE INDENT res = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT j = i + 1 ; NEW_LINE while ( j < n and arr [ j ] >= arr [ j - 1 ] ) : NEW_LINE INDENT j += 1 ; NEW_LINE DEDENT res += max ( j - i - k + 1 , 0 ) ; NEW_LINE i = j ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 2 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE k = 2 ; NEW_LINE print ( cntSubArrays ( arr , n , k ) ) ; NEW_LINE DEDENT"],"bleu":0.6949572992134516,"rouge_l":0.8921122033085592}
{"id":1060,"predictions":["def match_ways ( dictionary , sentence , n , m ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if dictionary [ i ] in mp . keys ( ) : NEW_LINE INDENT mp [ dictionary [ dictionary [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ sentence [ i ] ] = 1 NEW_LINE DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT if sentence [ i ] in mp . keys ( ) : NEW_LINE INDENT mp [ sentence [ i ] ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT dictionary = [ \" find \" , \" a \" , \" geeks \" , \" \" geeks \" , \" all \" , \" are \" , \" on \" , \" geeks \" ] NEW_LINE n = len ( dictionary ) NEW_LINE if ( match_ways ( dictionary , sentence , n , m ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"references":["def match_words ( dictionary , sentence , n , m ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ dictionary [ i ] ] = mp . get ( dictionary [ i ] , 0 ) + 1 NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT if ( mp [ sentence [ i ] ] ) : NEW_LINE INDENT mp [ sentence [ i ] ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT dictionary = [ \" find \" , \" a \" , \" geeks \" , \" all \" , \" for \" , \" on \" , \" geeks \" , \" answers \" , \" inter \" ] NEW_LINE n = len ( dictionary ) NEW_LINE sentence = [ \" find \" , \" all \" , \" answers \" , \" on \" , \" geeks \" , \" for \" , \" geeks \" ] NEW_LINE m = len ( sentence ) NEW_LINE if ( match_words ( dictionary , sentence , n , m ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"],"bleu":0.7049442309952695,"rouge_l":0.739283309643151}
{"id":1061,"predictions":["def sumofproduct ( n ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for x in range ( 1 , n + 1 ) : NEW_LINE INDENT y = n \/\/ x ; NEW_LINE ans += ( y * x ) ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT n = 10 ; NEW_LINE print ( sumofproduct ( n ) ) ; NEW_LINE"],"references":["def sumofproduct ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for x in range ( 1 , n + 1 ) : NEW_LINE INDENT y = int ( n \/ x ) NEW_LINE ans += ( y * x ) NEW_LINE DEDENT return ans NEW_LINE DEDENT n = 10 NEW_LINE print ( sumofproduct ( n ) ) NEW_LINE"],"bleu":0.7216995908193014,"rouge_l":0.9145917001338688}
{"id":1062,"predictions":["def isUnique ( a , n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT sum += n - 1 NEW_LINE return ( sum == k ) NEW_LINE DEDENT a = [ 3 , 3 , 3 ] NEW_LINE n = len ( a ) NEW_LINE k = 12 NEW_LINE if ( isUnique ( a , n , k ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def isUnique ( a , n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT sum += n - 1 NEW_LINE return ( sum == k ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 3 , 3 , 3 ] NEW_LINE n = len ( a ) NEW_LINE k = 12 NEW_LINE if ( isUnique ( a , n , k ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.8084237826701175,"rouge_l":0.9065069975472515}
{"id":1063,"predictions":["if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT first = 1 NEW_LINE second = 1 NEW_LINE second = 1 NEW_LINE for second in range ( 1 , 5 ) : NEW_LINE INDENT for second in range ( 1 , 5 ) : NEW_LINE INDENT print ( 5 * first + second - 5 ) NEW_LINE DEDENT DEDENT DEDENT"],"references":["if name == ' _ _ main _ _ ' : NEW_LINE INDENT for first in range ( 1 , 6 ) : NEW_LINE INDENT for second in range ( 1 , 6 ) : NEW_LINE INDENT print ( 5 * first + second - 5 ) NEW_LINE DEDENT DEDENT DEDENT"],"bleu":0.6461992640002493,"rouge_l":0.8405159777191439}
{"id":1064,"predictions":["def calculate_ ( s ) : NEW_LINE INDENT if len ( s ) == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT count_ = 0 NEW_LINE for i in range ( len ( s ) - 1 , 0 , - 1 ) : NEW_LINE INDENT if s [ i ] == '0' and i != '1' and s [ i + 2 ] == '1' : NEW_LINE INDENT count_ += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_ += 1 NEW_LINE DEDENT DEDENT return count_ NEW_LINE DEDENT def calculate_ ( s ) : NEW_LINE INDENT count_ = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == '1' and i == '1' : NEW_LINE INDENT count_ += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_ += 1 NEW_LINE DEDENT DEDENT return count_ NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \"0000\" NEW_LINE print ( calculate_ ( s ) ) NEW_LINE DEDENT"],"references":["def calculate_ ( s ) : NEW_LINE INDENT if len ( s ) == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT count_ = 0 NEW_LINE i = len ( s ) - 1 NEW_LINE while i > 0 : NEW_LINE INDENT if s [ i ] == '0' : NEW_LINE INDENT count_ += 1 NEW_LINE i -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_ += 1 NEW_LINE while s [ i ] == '1' and i > 0 : NEW_LINE INDENT count_ += 1 NEW_LINE i -= 1 NEW_LINE DEDENT if i == 0 : NEW_LINE INDENT count_ += 1 NEW_LINE DEDENT s = s [ : i ] + \"1\" + s [ i + 1 : ] NEW_LINE DEDENT DEDENT return count_ NEW_LINE DEDENT s = \"10000100000\" NEW_LINE print ( calculate_ ( s ) ) NEW_LINE"],"bleu":0.5330737278581344,"rouge_l":0.6531049250535332}
{"id":1065,"predictions":["def getWinner ( str , len ) : NEW_LINE INDENT total = 0 NEW_LINE for i in range ( len ) : NEW_LINE INDENT if ( str [ i ] == ' S ' ) : NEW_LINE INDENT total += 1 NEW_LINE DEDENT DEDENT if ( ( total % 2 ) == 1 ) : NEW_LINE INDENT return \" First \" NEW_LINE DEDENT return \" Second \" NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" GSSS \" NEW_LINE len = len ( str ) NEW_LINE print ( getWinner ( str , len ) ) NEW_LINE DEDENT"],"references":["def getWinner ( string , length ) : NEW_LINE INDENT total = 0 ; NEW_LINE for i in range ( length ) : NEW_LINE INDENT if ( string [ i ] == ' S ' ) : NEW_LINE INDENT total += 1 ; NEW_LINE DEDENT DEDENT if ( ( total % 2 ) == 1 ) : NEW_LINE INDENT return \" First \" ; NEW_LINE DEDENT return \" Second \" ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" GSSS \" ; NEW_LINE length = len ( string ) ; NEW_LINE print ( getWinner ( string , length ) ) ; NEW_LINE DEDENT"],"bleu":0.6608696705256842,"rouge_l":0.8807680857398036}
{"id":1066,"predictions":["def countPermutations ( N , B ) : NEW_LINE INDENT x = pow ( B , N ) NEW_LINE y = pow ( B , N - 1 ) NEW_LINE print ( x - y ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 6 NEW_LINE B = 4 NEW_LINE countPermutations ( N , B ) NEW_LINE DEDENT"],"references":["def countPermutations ( N , B ) : NEW_LINE INDENT x = B ** N NEW_LINE y = B ** ( N - 1 ) NEW_LINE print ( x - y ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N , B = 6 , 4 NEW_LINE countPermutations ( N , B ) NEW_LINE DEDENT"],"bleu":0.7391444276236787,"rouge_l":0.8818158762363683}
{"id":1067,"predictions":["def check ( k , d0 , d1 ) : NEW_LINE INDENT s = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 NEW_LINE a = ( k - 3 ) % 4 NEW_LINE x = 0 NEW_LINE if a == 0 : NEW_LINE INDENT x = ( 2 * ( d0 + d1 ) ) % 10 NEW_LINE DEDENT elif a == 1 : NEW_LINE INDENT x = ( 2 * ( d0 + d1 ) ) % 10 NEW_LINE DEDENT elif a == 1 : NEW_LINE INDENT x = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 NEW_LINE DEDENT DEDENT sum = d0 + d1 + ( ( ( k - 3 ) \/\/ 4 ) * s + x ) ) % 10 NEW_LINE if ( sum % 3 == 0 ) : NEW_LINE INDENT return \" YES \" NEW_LINE DEDENT return \" NO \" NEW_LINE DEDENT k = 13 NEW_LINE d0 = 8 NEW_LINE d1 = 8 NEW_LINE d1 = 1 NEW_LINE d1 = 1 NEW_LINE d1 = 3 NEW_LINE print ( check ( k , d0 , d1 , d1 ) ) NEW_LINE k = 5 NEW_LINE print ( check ( k , d0 , d1 ) ) NEW_LINE"],"references":["def check ( k , d0 , d1 ) : NEW_LINE INDENT s = ( ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 + ( 6 * ( d0 + d1 ) ) % 10 ) NEW_LINE a = ( k - 3 ) % 4 NEW_LINE if ( a == 0 ) : NEW_LINE INDENT x = 0 NEW_LINE DEDENT elif ( a == 1 ) : NEW_LINE INDENT x = ( 2 * ( d0 + d1 ) ) % 10 NEW_LINE DEDENT elif ( a == 2 ) : NEW_LINE INDENT x = ( ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 ) NEW_LINE DEDENT elif ( a == 3 ) : NEW_LINE INDENT x = ( ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 ) NEW_LINE DEDENT sum = d0 + d1 + ( ( k - 3 ) \/\/ 4 ) * s + x NEW_LINE if ( sum % 3 == 0 ) : NEW_LINE INDENT return \" YES \" NEW_LINE DEDENT else : NEW_LINE INDENT return \" NO \" NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT k = 13 NEW_LINE d0 = 8 NEW_LINE d1 = 1 NEW_LINE print ( check ( k , d0 , d1 ) ) NEW_LINE k = 5 NEW_LINE d0 = 3 NEW_LINE d1 = 4 NEW_LINE print ( check ( k , d0 , d1 ) ) NEW_LINE DEDENT"],"bleu":0.6439051287516465,"rouge_l":0.7799247902805901}
{"id":1068,"predictions":["n = 5 NEW_LINE num = 1 NEW_LINE gap = n - 1 NEW_LINE for j in range ( 1 , n + 1 ) : NEW_LINE INDENT num = j NEW_LINE for i in range ( 1 , gap + 1 ) : NEW_LINE INDENT print ( ' ▁ ' , end = ' ' ) NEW_LINE DEDENT num -= 1 NEW_LINE num -= 1 NEW_LINE for i in range ( 1 , j + 1 ) : NEW_LINE INDENT print ( num , end = ' ' ) NEW_LINE num += 1 NEW_LINE DEDENT num -= 1 NEW_LINE num -= 1 NEW_LINE for i in range ( 1 , j ) : NEW_LINE INDENT print ( num , end = ' ' ) NEW_LINE num -= 1 NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE num = 1 NEW_LINE print ( \" \\n \" , end = \" \" ) NEW_LINE DEDENT"],"references":["n = 5 NEW_LINE num = 1 NEW_LINE gap = n - 1 NEW_LINE for j in range ( 1 , n + 1 ) : NEW_LINE INDENT num = j NEW_LINE for i in range ( 1 , gap + 1 ) : NEW_LINE INDENT print ( \" ▁ \" , end = \" \" ) NEW_LINE DEDENT gap = gap - 1 NEW_LINE for i in range ( 1 , j + 1 ) : NEW_LINE INDENT print ( num , end = \" \" ) NEW_LINE num = num + 1 NEW_LINE DEDENT num = num - 2 NEW_LINE for i in range ( 1 , j ) : NEW_LINE INDENT print ( num , end = \" \" ) NEW_LINE num = num - 1 NEW_LINE DEDENT print ( ) NEW_LINE DEDENT"],"bleu":0.6297573507534493,"rouge_l":0.7715625340748009}
{"id":1069,"predictions":["import sys NEW_LINE def isKthBitSet ( x , k ) : NEW_LINE INDENT rslt = 1 if ( x & ( 1 << ( k - 1 ) ) ) else 0 NEW_LINE return rslt NEW_LINE DEDENT def isPalindrome ( x ) : NEW_LINE INDENT l = 1 NEW_LINE r = ( int ) ( sys . stdin . readline ( ) ) * 8 NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( isKthBitSet ( x , l ) != isKthBitSet ( x , r ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT x = 1 << 15 + 1 << 16 NEW_LINE print ( isPalindrome ( x ) ) NEW_LINE x = ( 1 << 31 ) + 1 NEW_LINE print ( isPalindrome ( x ) ) NEW_LINE x = ( 1 << 31 ) + 1 NEW_LINE print ( isPalindrome ( x ) ) NEW_LINE"],"references":["import sys NEW_LINE def isKthBitSet ( x , k ) : NEW_LINE INDENT if ( ( x & ( 1 << ( k - 1 ) ) ) != 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def isPalindrome ( x ) : NEW_LINE INDENT l = 1 NEW_LINE r = 2 * 8 NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( isKthBitSet ( x , l ) != isKthBitSet ( x , r ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 1 << 15 + 1 << 16 NEW_LINE print ( int ( isPalindrome ( x ) ) ) NEW_LINE x = 1 << 31 + 1 NEW_LINE print ( int ( isPalindrome ( x ) ) ) NEW_LINE DEDENT"],"bleu":0.6723906741215635,"rouge_l":0.7724598663874763}
{"id":1070,"predictions":["def getSum ( a , n ) : NEW_LINE INDENT P = [ None ] * n NEW_LINE P [ 0 ] = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT P [ i ] = a [ i ] + P [ i - 1 ] NEW_LINE DEDENT S = P [ n - 1 ] NEW_LINE hash = dict ( ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT hash [ P [ P [ i ] ] = 1 NEW_LINE DEDENT res = set ( ) NEW_LINE for i in range ( 1 , int ( sqrt ( S ) ) + 1 ) : NEW_LINE INDENT if ( S % i == 0 ) : NEW_LINE INDENT pres = True NEW_LINE div1 = i NEW_LINE div2 = S \/\/ i NEW_LINE for j in range ( div1 , S + 1 ) : NEW_LINE INDENT if ( hash [ j ] == 0 ) : NEW_LINE INDENT pres = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( pres and div1 != S ) : NEW_LINE INDENT res . add ( div1 ) NEW_LINE DEDENT pres = True NEW_LINE for j in range ( S \/\/ i , S + 1 ) : NEW_LINE INDENT if ( hash [ j ] == None or hash [ j ] != 1 ) : NEW_LINE INDENT pres = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( pres and div2 != S ) : NEW_LINE INDENT res . add ( div2 ) NEW_LINE DEDENT DEDENT DEDENT if ( len ( res ) == 0 ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE return NEW_LINE DEDENT for i in range ( len ( res ) ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT a = [ 1 , 2 , 1 , 1 , 1 , 1 , 2 , 1 , 1 , 3 ] NEW_LINE n = len ( a ) NEW_LINE getSum ( a , n ) NEW_LINE"],"references":["from math import sqrt NEW_LINE def getSum ( a , n ) : NEW_LINE INDENT P = [ 0 ] * n NEW_LINE P [ 0 ] = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT P [ i ] = a [ i ] + P [ i - 1 ] NEW_LINE DEDENT S = P [ n - 1 ] NEW_LINE hash = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ P [ i ] ] = 1 NEW_LINE DEDENT res = set ( ) NEW_LINE for i in range ( 1 , int ( sqrt ( S ) ) + 1 ) : NEW_LINE INDENT if ( S % i == 0 ) : NEW_LINE INDENT pres = True ; NEW_LINE div1 = i NEW_LINE div2 = S \/\/ i NEW_LINE for j in range ( div1 , S + 1 , div1 ) : NEW_LINE INDENT if j not in hash . keys ( ) : NEW_LINE INDENT pres = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( pres and div1 != S ) : NEW_LINE INDENT res . add ( div1 ) NEW_LINE DEDENT pres = True NEW_LINE for j in range ( S \/\/ i , S + 1 , S \/\/ i ) : NEW_LINE INDENT if j not in hash . keys ( ) : NEW_LINE INDENT pres = False ; NEW_LINE break NEW_LINE DEDENT DEDENT if ( pres and div2 != S ) : NEW_LINE INDENT res . add ( div2 ) NEW_LINE DEDENT DEDENT DEDENT if ( len ( res ) == 0 ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE return NEW_LINE DEDENT for i in res : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 2 , 1 , 1 , 1 , 2 , 1 , 3 ] NEW_LINE n = len ( a ) NEW_LINE getSum ( a , n ) NEW_LINE DEDENT"],"bleu":0.8376498715374102,"rouge_l":0.8914870295944465}
{"id":1071,"predictions":["MAX_CHAR = 26 NEW_LINE def removeChars ( arr , k ) : NEW_LINE INDENT hash = [ 0 ] * MAX_CHAR NEW_LINE n = len ( arr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ ord ( arr [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT ans = \" \" NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( hash [ ord ( arr [ i ] ) - ord ( ' a ' ) ] != k ) : NEW_LINE INDENT ans += arr [ i ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeksforgeeks \" NEW_LINE k = 2 NEW_LINE print ( removeChars ( str , k ) ) NEW_LINE DEDENT"],"references":["MAX_CHAR = 26 NEW_LINE def removeChars ( arr , k ) : NEW_LINE INDENT hash = [ 0 ] * MAX_CHAR NEW_LINE n = len ( arr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ ord ( arr [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT ans = \" \" NEW_LINE index = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( hash [ ord ( arr [ i ] ) - ord ( ' a ' ) ] != k ) : NEW_LINE INDENT ans += arr [ i ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeksforgeeks \" NEW_LINE k = 2 NEW_LINE print ( removeChars ( str , k ) ) NEW_LINE DEDENT"],"bleu":0.9681179187677071,"rouge_l":0.9841949292064538}
{"id":1072,"predictions":["def firstEven ( arr , n ) : NEW_LINE INDENT m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT m [ arr [ i ] ] = m . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT j = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( m [ arr [ j ] ] == True ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return arr [ j ] NEW_LINE DEDENT arr = [ 2 , 4 , 6 , 8 , 1 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( firstEven ( arr , n ) ) NEW_LINE"],"references":["def firstEven ( arr , n ) : NEW_LINE INDENT map1 = { } NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] not in map1 : NEW_LINE INDENT map1 [ arr [ i ] ] = False NEW_LINE DEDENT else : NEW_LINE INDENT map1 [ arr [ i ] ] = not map1 [ arr [ i ] ] NEW_LINE DEDENT DEDENT for j in range ( 0 , n ) : NEW_LINE INDENT if map1 [ arr [ j ] ] == True : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return arr [ j ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 4 , 6 , 8 , 1 , 6 ] NEW_LINE print ( firstEven ( arr , 6 ) ) NEW_LINE DEDENT"],"bleu":0.5002425559143261,"rouge_l":0.6771305800907139}
{"id":1073,"predictions":["def ReverseString ( s ) : NEW_LINE INDENT s = \" \" NEW_LINE for i in range ( len ( s ) \/\/ 2 ) : NEW_LINE INDENT s % 2 NEW_LINE s += str ( s ) NEW_LINE DEDENT DEDENT def binary_conference ( m ) : NEW_LINE INDENT while ( m != 0 ) : NEW_LINE INDENT tmp = m % 2 NEW_LINE s += str ( tmp ) NEW_LINE m = ( int ) ( m \/ 2 ) NEW_LINE DEDENT s = reverseString ( s ) NEW_LINE DEDENT def find_Character ( n , m , i ) : NEW_LINE INDENT binary_conversions ( m ) NEW_LINE s1 = \" \" NEW_LINE for x in range ( n ) : NEW_LINE INDENT for y in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ y ] == '1' ) : NEW_LINE INDENT s1 += \"10\" NEW_LINE DEDENT else : NEW_LINE INDENT s1 += \"01\" NEW_LINE DEDENT DEDENT s = s1 NEW_LINE s1 = \" \" NEW_LINE s1 = \" \" NEW_LINE s1 = \" \" \" NEW_LINE DEDENT return ord ( s ) NEW_LINE DEDENT m = 5 NEW_LINE n = 2 NEW_LINE i = 8 NEW_LINE print ( find_Character ( n , m , i ) ) NEW_LINE"],"references":["def binary_conversion ( s , m ) : NEW_LINE INDENT while ( m ) : NEW_LINE INDENT temp = m % 2 NEW_LINE s += str ( temp ) NEW_LINE m = m \/\/ 2 NEW_LINE DEDENT return s [ : : - 1 ] NEW_LINE DEDENT def find_character ( n , m , i ) : NEW_LINE INDENT s = \" \" NEW_LINE s = binary_conversion ( s , m ) NEW_LINE s1 = \" \" NEW_LINE for x in range ( n ) : NEW_LINE INDENT for j in range ( len ( s ) ) : NEW_LINE INDENT if s [ j ] == \"1\" : NEW_LINE INDENT s1 += \"10\" NEW_LINE DEDENT else : NEW_LINE INDENT s1 += \"01\" NEW_LINE DEDENT DEDENT s = s1 NEW_LINE s1 = \" \" NEW_LINE DEDENT e = ord ( s [ i ] ) NEW_LINE r = ord ( '0' ) NEW_LINE return e - r NEW_LINE DEDENT m , n , i = 5 , 2 , 8 NEW_LINE print ( find_character ( n , m , i ) ) NEW_LINE"],"bleu":0.5231381901981944,"rouge_l":0.6832734263980608}
{"id":1074,"predictions":["def cntSquares ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) * ( 2 * n + 1 ) \/\/ 6 ) NEW_LINE DEDENT print ( cntSquares ( 4 ) ) NEW_LINE"],"references":["def cntSquares ( n ) : NEW_LINE INDENT return int ( n * ( n + 1 ) * ( 2 * n + 1 ) \/ 6 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( cntSquares ( 4 ) ) ; NEW_LINE DEDENT"],"bleu":0.5407044504053997,"rouge_l":0.7798894263994472}
{"id":1075,"predictions":["def multiplyWith3Point5 ( x ) : NEW_LINE INDENT return ( x << 1 ) + x + ( x >> 1 ) NEW_LINE DEDENT x = 2 NEW_LINE print ( multiplyWith3Point ( x ) ) NEW_LINE"],"references":["def multiplyWith3Point5 ( x ) : NEW_LINE INDENT return ( x << 1 ) + x + ( x >> 1 ) NEW_LINE DEDENT x = 4 NEW_LINE print ( multiplyWith3Point5 ( x ) ) NEW_LINE"],"bleu":0.8543474855325978,"rouge_l":0.9444444444444445}
{"id":1076,"predictions":["def countSubSeq ( str1 , lenn ) : NEW_LINE INDENT ans = 0 NEW_LINE mul = 1 NEW_LINE for i in range ( lenn ) : NEW_LINE INDENT if ( str1 [ i ] == '0' ) : NEW_LINE INDENT ans += mul NEW_LINE DEDENT mul *= 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT str1 = \"10010\" NEW_LINE lenn = len ( str1 ) NEW_LINE print ( countSubSeq ( str1 , lenn ) ) NEW_LINE"],"references":["def countSubSeq ( strr , lenn ) : NEW_LINE INDENT ans = 0 NEW_LINE mul = 1 NEW_LINE for i in range ( lenn ) : NEW_LINE INDENT if ( strr [ i ] == '0' ) : NEW_LINE INDENT ans += mul NEW_LINE DEDENT mul *= 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT strr = \"10010\" NEW_LINE lenn = len ( strr ) NEW_LINE print ( countSubSeq ( strr , lenn ) ) NEW_LINE"],"bleu":0.8274038507366062,"rouge_l":0.9333333333333336}
{"id":1077,"predictions":["def swapThree ( a , b , c ) : NEW_LINE INDENT a = a + b + c NEW_LINE b = a - ( b + c ) NEW_LINE c = a - ( b + c ) NEW_LINE a = a - ( b + c ) NEW_LINE DEDENT a = 10 NEW_LINE b = 20 NEW_LINE c = 30 NEW_LINE print ( \" Before ▁ swapping ▁ a ▁ = ▁ \" , a , \" , ▁ b ▁ = ▁ \" , b ▁ = ▁ \" , c ) NEW_LINE swapThree ( a , b , c ) NEW_LINE print ( \" After ▁ swapping ▁ = ▁ \" , a , \" , ▁ b ▁ = ▁ \" , c ▁ = ▁ \" , c ) NEW_LINE print ( \" After ▁ swapping ▁ a ▁ = ▁ \" , a , \" , ▁ b ▁ = ▁ \" , b ▁ = ▁ \" , c ▁ = ▁ \" , c ▁ = ▁ \" , c ) NEW_LINE DEDENT"],"references":["def swapThree ( a , b , c ) : NEW_LINE INDENT a = a + b + c NEW_LINE b = a - ( b + c ) NEW_LINE c = a - ( b + c ) NEW_LINE a = a - ( b + c ) NEW_LINE print ( \" After ▁ swapping ▁ a ▁ = \" , a , \" , ▁ b ▁ = \" , b , \" , ▁ c ▁ = \" , c ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 10 NEW_LINE b = 20 NEW_LINE c = 30 NEW_LINE print ( \" Before ▁ swapping ▁ a ▁ = \" , a , \" , ▁ b ▁ = \" , b , \" , ▁ c ▁ = \" , c ) NEW_LINE swapThree ( a , b , c ) NEW_LINE DEDENT"],"bleu":0.6843462557652535,"rouge_l":0.7260476096793232}
{"id":1078,"predictions":["def countSubarrays ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE pre = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT pre [ i ] = pre [ i - 1 ] + a [ i - 1 ] NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT sum1 = pre [ j ] - pre [ i - 1 ] NEW_LINE count1 = j - i + 1 NEW_LINE sum2 = count2 NEW_LINE count2 = ( n - count1 ) NEW_LINE count2 = ( n - count1 ) NEW_LINE if ( ( n - count1 ) == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( ( n - count1 ) == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 6 , 3 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countSubarrays ( arr , n ) ) NEW_LINE"],"references":["def countSubarrays ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE pre = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT pre [ i ] = pre [ i - 1 ] + a [ i - 1 ] NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT sum1 = pre [ j ] - pre [ i - 1 ] NEW_LINE count1 = j - i + 1 NEW_LINE sum2 = pre [ n ] - sum1 NEW_LINE if n - count1 == 0 : NEW_LINE INDENT count2 = 1 NEW_LINE DEDENT else : NEW_LINE INDENT count2 = n - count1 NEW_LINE DEDENT includ = sum1 \/\/ count1 NEW_LINE exclud = sum2 \/\/ count2 NEW_LINE if ( includ > exclud ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 6 , 3 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countSubarrays ( arr , n ) ) NEW_LINE"],"bleu":0.8050248693092755,"rouge_l":0.8514359056634044}
{"id":1079,"predictions":["def reverse ( arr , n , k , m ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT left = i NEW_LINE right = min ( i + k - 1 , n - 1 ) NEW_LINE while ( left < right ) : NEW_LINE INDENT arr [ left ] = arr [ left ] NEW_LINE left += 1 NEW_LINE right -= 1 NEW_LINE DEDENT DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 ] NEW_LINE k = 3 NEW_LINE m = 2 NEW_LINE n = len ( arr ) NEW_LINE reverse ( arr , n , k , m ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT"],"references":["def reverse ( arr , n , k , m ) : NEW_LINE INDENT for i in range ( 0 , n , k + m ) : NEW_LINE INDENT left = i ; NEW_LINE right = min ( i + k - 1 , n - 1 ) ; NEW_LINE while ( left < right ) : NEW_LINE INDENT arr = swap ( arr , left , right ) ; NEW_LINE left += 1 ; NEW_LINE right -= 1 ; NEW_LINE DEDENT DEDENT return arr ; NEW_LINE DEDENT def swap ( arr , i , j ) : NEW_LINE INDENT temp = arr [ i ] ; NEW_LINE arr [ i ] = arr [ j ] ; NEW_LINE arr [ j ] = temp ; NEW_LINE return arr ; NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 ] ; NEW_LINE k = 3 ; NEW_LINE m = 2 ; NEW_LINE n = len ( arr ) ; NEW_LINE arr = reverse ( arr , n , k , m ) ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT"],"bleu":0.5226561383577247,"rouge_l":0.7652874709205717}
{"id":1080,"predictions":["def count ( n ) : NEW_LINE INDENT return pow ( 2 , n - 1 ) NEW_LINE DEDENT n = 4 NEW_LINE print ( count ( n ) ) NEW_LINE"],"references":["def count ( n ) : NEW_LINE INDENT return pow ( 2 , n - 1 ) NEW_LINE DEDENT n = 4 NEW_LINE print ( count ( n ) ) NEW_LINE"],"bleu":1.0,"rouge_l":1.0}
{"id":1081,"predictions":["def isSubsetSum ( set , n , sum ) : NEW_LINE INDENT subset = [ [ False for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT subset [ 0 ] [ i ] = True NEW_LINE DEDENT for i in range ( 1 , sum + 1 ) : NEW_LINE INDENT subset [ i ] [ 0 ] = False NEW_LINE DEDENT for i in range ( 1 , sum + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT subset [ i ] [ j ] = subset [ i ] [ j - 1 ] NEW_LINE if ( i >= set [ j - 1 ] ) : NEW_LINE INDENT subset [ i ] [ j ] = subset [ i ] [ j ] or subset [ i - set [ j - set [ j - 1 ] ] ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT return subset [ sum ] [ n ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT set = [ 3 , 34 , 4 , 12 , 5 , 2 ] NEW_LINE sum = 9 NEW_LINE n = len ( set ) NEW_LINE if ( isSubsetSum ( set , n , sum ) == True ) : NEW_LINE INDENT print ( \" Found ▁ a ▁ subset ▁ with ▁ given ▁ sum \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No ▁ subset ▁ with ▁ given ▁ sum \" ) NEW_LINE DEDENT DEDENT"],"references":["def isSubsetSum ( set , n , sum ) : NEW_LINE INDENT subset = ( [ [ False for i in range ( sum + 1 ) ] for i in range ( n + 1 ) ] ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT subset [ i ] [ 0 ] = True NEW_LINE DEDENT for i in range ( 1 , sum + 1 ) : NEW_LINE INDENT subset [ 0 ] [ i ] = False NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , sum + 1 ) : NEW_LINE INDENT if j < set [ i - 1 ] : NEW_LINE INDENT subset [ i ] [ j ] = subset [ i - 1 ] [ j ] NEW_LINE DEDENT if j >= set [ i - 1 ] : NEW_LINE INDENT subset [ i ] [ j ] = ( subset [ i - 1 ] [ j ] or subset [ i - 1 ] [ j - set [ i - 1 ] ] ) NEW_LINE DEDENT DEDENT DEDENT return subset [ n ] [ sum ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT set = [ 3 , 34 , 4 , 12 , 5 , 2 ] NEW_LINE sum = 9 NEW_LINE n = len ( set ) NEW_LINE if ( isSubsetSum ( set , n , sum ) == True ) : NEW_LINE INDENT print ( \" Found ▁ a ▁ subset ▁ with ▁ given ▁ sum \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No ▁ subset ▁ with ▁ given ▁ sum \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.8249588174026825,"rouge_l":0.8893882920412189}
{"id":1082,"predictions":["def colourVisible ( height , colour , K ) : NEW_LINE INDENT arr = [ 0 ] * ( K + 1 ) ; NEW_LINE printed = 0 ; NEW_LINE max = height [ K - 1 ] ; NEW_LINE arr [ colour [ K - 1 ] ] = 1 ; NEW_LINE for i in range ( K - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( height [ i ] > max ) : NEW_LINE INDENT max = height [ i ] ; NEW_LINE arr [ colour [ i ] ] = 1 ; NEW_LINE DEDENT DEDENT for i in range ( 1 , K + 1 ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT DEDENT return bool ; NEW_LINE DEDENT height = [ 3 , 5 , 1 , 2 , 3 ] ; NEW_LINE colour = [ 1 , 2 , 3 , 4 , 3 ] ; NEW_LINE K = len ( colour ) ; NEW_LINE print ( colourVisible ( height , colour , K ) ) ; NEW_LINE"],"references":["def colourVisible ( height , colour , K ) : NEW_LINE INDENT arr = [ 0 for i in range ( K + 1 ) ] NEW_LINE visible = 0 NEW_LINE max = height [ K - 1 ] NEW_LINE arr [ colour [ K - 1 ] ] = 1 NEW_LINE i = K - 2 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( height [ i ] > max ) : NEW_LINE INDENT max = height [ i ] NEW_LINE arr [ colour [ i ] ] = 1 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT for i in range ( 1 , K + 1 , 1 ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT visible += 1 NEW_LINE DEDENT DEDENT return visible NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT height = [ 3 , 5 , 1 , 2 , 3 ] NEW_LINE colour = [ 1 , 2 , 3 , 4 , 3 ] NEW_LINE K = len ( colour ) NEW_LINE print ( colourVisible ( height , colour , K ) ) NEW_LINE DEDENT"],"bleu":0.7048534950029491,"rouge_l":0.8329031720922488}
{"id":1083,"predictions":["MAXRows ( mat , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT mat [ i ] . sort ( ) NEW_LINE DEDENT DEDENT def findAndPrintCommonElements ( mat , n ) : NEW_LINE INDENT sortRows ( mat , n ) NEW_LINE curr_index = [ 0 ] * n NEW_LINE fr_index [ 0 ] = 0 NEW_LINE for curr_index [ 0 ] in range ( n ) : NEW_LINE INDENT value = mat [ 0 ] [ curr_index [ 0 ] ] NEW_LINE present = True NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT while ( curr_index [ i ] < n and mat [ i ] [ curr_index [ curr_index [ i ] ] ] <= value ) : NEW_LINE INDENT curr_index [ i ] += 1 NEW_LINE DEDENT if ( mat [ i ] [ curr_index [ curr_index [ i ] - 1 ] != value ) ) : NEW_LINE INDENT present = False NEW_LINE break NEW_LINE DEDENT if ( curr_index [ i ] == n ) : NEW_LINE INDENT f = 1 NEW_LINE break NEW_LINE DEDENT if ( curr_index [ i ] == n ) : NEW_LINE INDENT f = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( present ) : NEW_LINE INDENT print ( value , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT mat = [ 10 , 1 , 1 , 3 , 3 , 10 ] , [ 10 , 2 , 1 , 3 , 3 , 3 , 10 ] , [ 1 , 10 , 10 , 1 ] , [ 1 , 10 , 30 , 2 , 1 ] ] NEW_LINE n = 5 NEW_LINE findAndPrintCommonElements ( mat , n ) NEW_LINE DEDENT"],"references":["MAX = 100 NEW_LINE def sortRows ( mat , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT mat [ i ] . sort ( ) ; NEW_LINE DEDENT DEDENT def findAndPrintCommonElements ( mat , n ) : NEW_LINE INDENT sortRows ( mat , n ) NEW_LINE curr_index = [ 0 ] * n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT curr_index [ i ] = 0 NEW_LINE DEDENT f = 0 NEW_LINE while ( curr_index [ 0 ] < n ) : NEW_LINE INDENT value = mat [ 0 ] [ curr_index [ 0 ] ] NEW_LINE present = True NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT while ( curr_index [ i ] < n and mat [ i ] [ curr_index [ i ] ] <= value ) : NEW_LINE INDENT curr_index [ i ] = curr_index [ i ] + 1 NEW_LINE DEDENT if ( mat [ i ] [ curr_index [ i ] - 1 ] != value ) : NEW_LINE INDENT present = False NEW_LINE DEDENT if ( curr_index [ i ] == n ) : NEW_LINE INDENT f = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( present ) : NEW_LINE INDENT print ( value , end = \" ▁ \" ) NEW_LINE DEDENT if ( f == 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT curr_index [ 0 ] = curr_index [ 0 ] + 1 NEW_LINE DEDENT DEDENT mat = [ [ 12 , 1 , 14 , 3 , 16 ] , [ 14 , 2 , 1 , 3 , 35 ] , [ 14 , 1 , 14 , 3 , 11 ] , [ 14 , 25 , 3 , 2 , 1 ] , [ 1 , 18 , 3 , 21 , 14 ] ] NEW_LINE n = 5 NEW_LINE findAndPrintCommonElements ( mat , n ) NEW_LINE"],"bleu":0.717433540928197,"rouge_l":0.7723482151937353}
{"id":1084,"predictions":["def MaximumProduct ( a , n ) : NEW_LINE INDENT cntnegzero = 0 NEW_LINE cntzero = 0 NEW_LINE pos = - 1 NEW_LINE pos = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT used [ i ] = 1 NEW_LINE cntzero += 1 NEW_LINE DEDENT if ( a [ i ] < 0 ) : NEW_LINE INDENT cntneg += 1 NEW_LINE if ( pos == - 1 or abs ( a [ pos ] ) > abs ( a [ i ] ) ) : NEW_LINE INDENT pos = i NEW_LINE DEDENT DEDENT if ( cntneg % 2 == 1 ) : NEW_LINE INDENT used [ pos ] = 1 NEW_LINE DEDENT if ( cntzero == n or ( cntzero == n - 1 and cntneg == 1 and cntneg == 1 ) ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT print ( 1 , ( i + 1 ) , ( i + 2 ) ) NEW_LINE DEDENT return NEW_LINE DEDENT lst = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( maxsize [ i ] == 1 ) : NEW_LINE INDENT print ( 1 , ( lst + 1 ) , ( i + 1 ) ) NEW_LINE DEDENT lst = i NEW_LINE DEDENT DEDENT if ( snt != - 1 ) : NEW_LINE INDENT print ( 2 , ( lst + 1 ) , ( lst + 1 ) ) NEW_LINE DEDENT lst = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( len ( lst ) == 0 ) : NEW_LINE INDENT print ( 1 , ( lst + 1 ) , ( lst + 1 ) ) NEW_LINE DEDENT lst = i NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT MaximumProduct ( a , n ) NEW_LINE DEDENT"],"references":["def MaximumProduct ( a , n ) : NEW_LINE INDENT cntneg = 0 NEW_LINE cntzero = 0 NEW_LINE used = [ 0 ] * n NEW_LINE pos = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT used [ i ] = 1 NEW_LINE cntzero += 1 NEW_LINE DEDENT if ( a [ i ] < 0 ) : NEW_LINE INDENT cntneg += 1 NEW_LINE if ( pos == - 1 or abs ( a [ pos ] ) > abs ( a [ i ] ) ) : NEW_LINE INDENT pos = i NEW_LINE DEDENT DEDENT DEDENT if ( cntneg % 2 == 1 ) : NEW_LINE INDENT used [ pos ] = 1 NEW_LINE DEDENT if ( cntzero == n or ( cntzero == n - 1 and cntneg == 1 ) ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT print ( 1 , \" ▁ \" , i + 1 , \" ▁ \" , i + 2 ) NEW_LINE DEDENT return NEW_LINE DEDENT lst = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( used [ i ] ) : NEW_LINE INDENT if ( lst != - 1 ) : NEW_LINE INDENT print ( 1 , \" ▁ \" , lst + 1 , \" ▁ \" , i + 1 ) NEW_LINE DEDENT lst = i NEW_LINE DEDENT DEDENT if ( lst != - 1 ) : NEW_LINE INDENT print ( 2 , \" ▁ \" , lst + 1 ) NEW_LINE DEDENT lst = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( not used [ i ] ) : NEW_LINE INDENT if ( lst != - 1 ) : NEW_LINE INDENT print ( 1 , \" ▁ \" , lst + 1 , \" ▁ \" , i + 1 ) NEW_LINE DEDENT lst = i NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 5 , - 2 , 0 , 1 , - 3 ] NEW_LINE n = len ( a ) NEW_LINE MaximumProduct ( a , n ) NEW_LINE DEDENT"],"bleu":0.6985148937173735,"rouge_l":0.8221537912259562}
{"id":1085,"predictions":["def getSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT sum = sum + n % 10 NEW_LINE n = n \/\/ 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 687 NEW_LINE print ( getSum ( n ) ) NEW_LINE"],"references":["def getSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT sum = sum + int ( n % 10 ) NEW_LINE n = int ( n \/ 10 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 687 NEW_LINE print ( getSum ( n ) ) NEW_LINE"],"bleu":0.7649495005510725,"rouge_l":0.9182408500590319}
{"id":1086,"predictions":["def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT count += 1 NEW_LINE n &= ( n - 1 ) NEW_LINE DEDENT return count NEW_LINE DEDENT defFlippedCount ( a , b ) : NEW_LINE INDENT return countSetBits ( a ^ b ) NEW_LINE DEDENT a = 10 NEW_LINE b = 20 NEW_LINE print (FlippedCount ( a , b ) ) NEW_LINE"],"references":["def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while n : NEW_LINE INDENT count += 1 NEW_LINE n &= ( n - 1 ) NEW_LINE DEDENT return count NEW_LINE DEDENT def FlippedCount ( a , b ) : NEW_LINE INDENT return countSetBits ( a ^ b ) NEW_LINE DEDENT a = 10 NEW_LINE b = 20 NEW_LINE print ( FlippedCount ( a , b ) ) NEW_LINE"],"bleu":0.8693939053388711,"rouge_l":0.9436619718309859}
{"id":1087,"predictions":["def findSum ( arr , N ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT if arr [ i ] in mp . keys ( ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT maxFreq = 0 NEW_LINE for key , value in mp . items ( ) : NEW_LINE INDENT if ( value == maxFreq ) : NEW_LINE INDENT maxFreq = value NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 1 , 2 , 2 , 2 , 2 , 2 , 3 , 3 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE print ( findSum ( arr , N ) ) NEW_LINE DEDENT"],"references":["def findSum ( arr , N ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT mp [ arr [ i ] ] = mp . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT maxFreq = 0 NEW_LINE for itr in mp : NEW_LINE INDENT if ( mp [ itr ] > maxFreq ) : NEW_LINE INDENT maxFreq = mp [ itr ] NEW_LINE DEDENT DEDENT Sum = 0 NEW_LINE for itr in mp : NEW_LINE INDENT if ( mp [ itr ] == maxFreq ) : NEW_LINE INDENT Sum += itr * mp [ itr ] NEW_LINE DEDENT DEDENT return Sum NEW_LINE DEDENT arr = [ 1 , 1 , 2 , 2 , 2 , 2 , 3 , 3 , 3 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE print ( findSum ( arr , N ) ) NEW_LINE"],"bleu":0.6142349028560996,"rouge_l":0.692823954568921}
{"id":1088,"predictions":["def mdas_factorial ( N ) : NEW_LINE INDENT if ( N <= 2 ) : NEW_LINE INDENT return N NEW_LINE DEDENT if ( N <= 4 ) : NEW_LINE INDENT return ( N + 3 ) NEW_LINE DEDENT if ( ( N - 4 ) % 4 == 0 ) : NEW_LINE INDENT return ( N + 1 ) NEW_LINE DEDENT elif ( ( N - 4 ) % 4 <= 2 ) : NEW_LINE INDENT return ( N + 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( N - 1 ) NEW_LINE DEDENT DEDENT N = 4 NEW_LINE print (md **Factorial ( N ) ) NEW_LINE N = 10 NEW_LINE print (mdSub_Factorial ( N ) ) NEW_LINE"],"references":["def MDAS_Factorial ( N ) : NEW_LINE INDENT if N <= 2 : NEW_LINE INDENT return N NEW_LINE DEDENT if N <= 4 : NEW_LINE INDENT return N + 3 NEW_LINE DEDENT if ( N - 4 ) % 4 == 0 : NEW_LINE INDENT return N + 1 NEW_LINE DEDENT elif ( N - 4 ) % 4 <= 2 : NEW_LINE INDENT return N + 2 NEW_LINE DEDENT else : NEW_LINE INDENT return N - 1 NEW_LINE DEDENT DEDENT N = 4 NEW_LINE print ( MDAS_Factorial ( N ) ) NEW_LINE N = 10 NEW_LINE print ( MDAS_Factorial ( N ) ) NEW_LINE"],"bleu":0.5950421498352787,"rouge_l":0.8997050147492625}
{"id":1089,"predictions":["def maxAND ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT res = res if ( res > ( arr [ i ] & arr [ j ] ) ) else : NEW_LINE INDENT res = ( arr [ i ] & arr [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT arr = [ 4 , 8 , 6 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Maximum ▁ AND ▁ Value ▁ = \" , maxAND ( arr , n ) ) NEW_LINE"],"references":["def maxAND ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT res = max ( res , arr [ i ] & arr [ j ] ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT arr = [ 4 , 8 , 6 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Maximum ▁ AND ▁ Value ▁ = ▁ \" , maxAND ( arr , n ) ) NEW_LINE"],"bleu":0.7579485616132947,"rouge_l":0.8878657359275212}
{"id":1090,"predictions":["import math NEW_LINE def check ( arr , x , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT y = math . sqrt ( arr [ i ] ) NEW_LINE if ( floor ( y ) == ceil ( y ) ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT DEDENT if ( sum % x == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT arr = [ 2 , 3 , 4 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE x = 13 NEW_LINE if ( check ( arr , x , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def check ( a , y ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT x = math . sqrt ( a [ i ] ) NEW_LINE if ( math . floor ( x ) == math . ceil ( x ) ) : NEW_LINE INDENT sum = sum + a [ i ] NEW_LINE DEDENT DEDENT if ( sum % y == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT a = [ 2 , 3 , 4 , 9 , 10 ] NEW_LINE x = 13 NEW_LINE if check ( a , x ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.6970579490731289,"rouge_l":0.8445520036019809}
{"id":1091,"predictions":["MAX_SIZE = 10000 NEW_LINE prime = [ True for i in range ( MAX_SIZE + 1 ) ] NEW_LINE def sieve ( ) : NEW_LINE INDENT p * p = 2 NEW_LINE while ( p * p <= MAX_SIZE ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , MAX_SIZE , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def kthPrimeGreaterThanN ( n , k ) : NEW_LINE INDENT res = - 1 NEW_LINE for i in range ( n + 1 , MAX_SIZE ) : NEW_LINE INDENT if ( prime [ i ] == True ) : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT if ( k == 0 ) : NEW_LINE INDENT res = i NEW_LINE break NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT sieve ( ) NEW_LINE n = 2 NEW_LINE k = 15 NEW_LINE print ( kthPrimeerN ( n , k ) ) NEW_LINE"],"references":["MAX_SIZE = int ( 1e6 ) NEW_LINE prime = [ True ] * ( MAX_SIZE + 1 ) NEW_LINE def seive ( ) : NEW_LINE INDENT p = 2 NEW_LINE while ( p * p <= MAX_SIZE ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , MAX_SIZE , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT def kthPrimeGreaterThanN ( n , k ) : NEW_LINE INDENT res = - 1 NEW_LINE for i in range ( n + 1 , MAX_SIZE ) : NEW_LINE INDENT if ( prime [ i ] == True ) : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT if ( k == 0 ) : NEW_LINE INDENT res = i NEW_LINE break NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 2 NEW_LINE k = 15 NEW_LINE seive ( ) NEW_LINE print ( kthPrimeGreaterThanN ( n , k ) ) NEW_LINE DEDENT"],"bleu":0.7839156471230209,"rouge_l":0.8756246025256657}
{"id":1092,"predictions":["def minimumSets ( arr , n , key ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE i = 0 NEW_LINE j = n - 1 NEW_LINE while ( i <= j ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] <= key ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT DEDENT return i NEW_LINE DEDENT arr = [ 3 , 5 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE key = 5 NEW_LINE print ( minimumSets ( arr , n , key ) ) NEW_LINE"],"references":["def minimumSets ( arr , n , key ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE j = n - 1 NEW_LINE for i in range ( 0 , j + 1 , 1 ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] <= key ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT DEDENT return i + 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 5 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE key = 5 NEW_LINE print ( minimumSets ( arr , n , key ) ) NEW_LINE DEDENT"],"bleu":0.6860808623089059,"rouge_l":0.8215488215488216}
{"id":1093,"predictions":["def isPalindrome ( string ) : NEW_LINE INDENT l = len ( string ) NEW_LINE if ( l == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT ptr1 = string [ 0 ] NEW_LINE ptr2 = string [ l - 1 ] NEW_LINE while ( ptr2 > ptr1 ) : NEW_LINE INDENT if ( ptr1 != ptr2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT ptr1 += 1 NEW_LINE ptr2 -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def noOfList ( s ) : NEW_LINE INDENT if ( isPalindrome ( s ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT s = s [ 1 : 1 ] NEW_LINE return 1 + noOfMake ( s ) NEW_LINE DEDENT s = \" abpe \" NEW_LINE print ( noOfEach ( s ) ) NEW_LINE"],"references":["def isPalindrome ( Str ) : NEW_LINE INDENT Len = len ( Str ) NEW_LINE if ( Len == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT ptr1 = 0 NEW_LINE ptr2 = Len - 1 NEW_LINE while ( ptr2 > ptr1 ) : NEW_LINE INDENT if ( Str [ ptr1 ] != Str [ ptr2 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT ptr1 += 1 NEW_LINE ptr2 -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def noOfAppends ( s ) : NEW_LINE INDENT if ( isPalindrome ( s ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT del s [ 0 ] NEW_LINE return 1 + noOfAppends ( s ) NEW_LINE DEDENT se = \" abede \" NEW_LINE s = [ i for i in se ] NEW_LINE print ( noOfAppends ( s ) ) NEW_LINE"],"bleu":0.6238645340674656,"rouge_l":0.8167364016736403}
{"id":1094,"predictions":["import math NEW_LINE def add_factors ( n , mp ) : NEW_LINE INDENT for i in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT if n \/\/ i == i : NEW_LINE INDENT if i in ( n \/\/ i == i ) : NEW_LINE INDENT mp [ i ] = mp [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ i ] = 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if i in mp . keys ( ) : NEW_LINE INDENT mp [ i ] = mp [ i ] + 1 NEW_LINE DEDENT mp [ i ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT def count_divisors ( a , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] in mp . keys ( ) : NEW_LINE INDENT print ( 0 , end = \" ▁ \" ) NEW_LINE DEDENT mp [ a [ i ] ] = 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 8 , 1 , 20 , 4 , 2 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE count_divisors ( arr , n ) NEW_LINE DEDENT"],"references":["from collections import defaultdict NEW_LINE import math NEW_LINE def add_factors ( n , mp ) : NEW_LINE INDENT for i in range ( 1 , int ( math . sqrt ( n ) ) + 1 , ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n \/\/ i == i ) : NEW_LINE INDENT mp [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ i ] += 1 NEW_LINE mp [ n \/\/ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT def count_divisors ( a , n ) : NEW_LINE INDENT mp = defaultdict ( int ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( mp [ a [ i ] ] , end = \" ▁ \" ) NEW_LINE add_factors ( a [ i ] , mp ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 8 , 1 , 28 , 4 , 2 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE count_divisors ( arr , n ) NEW_LINE DEDENT"],"bleu":0.6427979896477848,"rouge_l":0.7937148074874448}
{"id":1095,"predictions":["def isPossible ( arr , n , C , mid ) : NEW_LINE INDENT a = 1 NEW_LINE currPosition = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] - currPosition >= mid ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( arr [ i ] - currPosition >= mid ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def binarySearch ( n , C , arr ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE lo = 0 NEW_LINE hi = arr [ n - 1 ] NEW_LINE ans = 0 NEW_LINE while ( lo <= hi ) : NEW_LINE INDENT mid = ( lo + hi ) \/\/ 2 NEW_LINE if ( not isPossible ( arr , n , C , mid ) ) : NEW_LINE INDENT hi = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( ans , mid ) NEW_LINE lo = mid + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT C = 4 NEW_LINE arr = [ 1 , 2 , 5 , 8 , 10 , 18 ] NEW_LINE n = len ( arr ) NEW_LINE print ( binarySearch ( n , C , arr ) ) NEW_LINE DEDENT"],"references":["def isPossible ( arr , n , C , mid ) : NEW_LINE INDENT magnet = 1 NEW_LINE currPosition = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] - currPosition >= mid ) : NEW_LINE INDENT magnet += 1 NEW_LINE currPosition = arr [ i ] NEW_LINE if ( magnet == C ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT def binarySearch ( n , C , arr ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE lo = 0 NEW_LINE hi = arr [ n - 1 ] NEW_LINE ans = 0 NEW_LINE while ( lo <= hi ) : NEW_LINE INDENT mid = int ( ( lo + hi ) \/ 2 ) NEW_LINE if ( isPossible ( arr , n , C , mid ) == False ) : NEW_LINE INDENT hi = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( ans , mid ) NEW_LINE lo = mid + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT C = 4 NEW_LINE arr = [ 1 , 2 , 5 , 8 , 10 , 18 ] NEW_LINE n = len ( arr ) NEW_LINE print ( binarySearch ( n , C , arr ) ) NEW_LINE DEDENT"],"bleu":0.8347772040673647,"rouge_l":0.9186118146348142}
{"id":1096,"predictions":["def makePalindrome ( n , odd ) : NEW_LINE INDENT res = n NEW_LINE if ( odd ) : NEW_LINE INDENT n = n \/\/ 10 NEW_LINE DEDENT while ( n > 0 ) : NEW_LINE INDENT res = 10 * res + n % 10 NEW_LINE n \/\/= 10 NEW_LINE DEDENT return res NEW_LINE DEDENT def isPalindrome ( n , base ) : NEW_LINE INDENT reversed = 0 NEW_LINE temp = n NEW_LINE while ( temp ) : NEW_LINE INDENT reversed = reversed * base + temp % base NEW_LINE temp \/\/= base NEW_LINE DEDENT return reversed == n NEW_LINE DEDENT def sumPalindrome ( n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE i = 1 NEW_LINE p = makePalindrome ( i , True ) NEW_LINE while ( p < n ) : NEW_LINE INDENT if ( isPalindrome ( p , k ) ) : NEW_LINE INDENT sum += p NEW_LINE DEDENT i += 1 NEW_LINE p = makePalindrome ( i , True ) NEW_LINE DEDENT i = 1 NEW_LINE p = 1 NEW_LINE while ( p < n ) : NEW_LINE INDENT if ( isPalindrome ( p , k ) ) : NEW_LINE INDENT sum += p NEW_LINE DEDENT i += 1 NEW_LINE p = makePalindrome ( i , False ) NEW_LINE DEDENT print ( \" Total ▁ sum ▁ is \" , sum ) NEW_LINE DEDENT n = 100 NEW_LINE k = 2 NEW_LINE makePalindrome ( n , k ) NEW_LINE"],"references":["def makePalindrome ( n , odd ) : NEW_LINE INDENT res = n ; NEW_LINE if ( odd ) : NEW_LINE INDENT n = int ( n \/ 10 ) ; NEW_LINE DEDENT while ( n > 0 ) : NEW_LINE INDENT res = 10 * res + n % 10 ; NEW_LINE n = int ( n \/ 10 ) ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT def isPalindrome ( n , base ) : NEW_LINE INDENT reversed = 0 ; NEW_LINE temp = n ; NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT reversed = reversed * base + temp % base ; NEW_LINE temp = int ( temp \/ base ) ; NEW_LINE DEDENT return reversed == n ; NEW_LINE DEDENT def sumPalindrome ( n , k ) : NEW_LINE INDENT sum = 0 ; NEW_LINE i = 1 ; NEW_LINE p = makePalindrome ( i , True ) ; NEW_LINE while ( p < n ) : NEW_LINE INDENT if ( isPalindrome ( p , k ) ) : NEW_LINE INDENT sum += p ; NEW_LINE DEDENT i += 1 ; NEW_LINE p = makePalindrome ( i , True ) ; NEW_LINE DEDENT i = 1 ; NEW_LINE p = makePalindrome ( i , False ) ; NEW_LINE while ( p < n ) : NEW_LINE INDENT if ( isPalindrome ( p , k ) ) : NEW_LINE INDENT sum += p ; NEW_LINE DEDENT i += 1 ; NEW_LINE p = makePalindrome ( i , False ) ; NEW_LINE DEDENT print ( \" Total ▁ sum ▁ is \" , sum ) ; NEW_LINE DEDENT n = 1000000 ; NEW_LINE k = 2 ; NEW_LINE sumPalindrome ( n , k ) ; NEW_LINE"],"bleu":0.665241927732797,"rouge_l":0.8805485384337783}
{"id":1097,"predictions":["class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT res = ' ' : NEW_LINE INDENT newNode = data NEW_LINE newNode . left = newNode . right = None NEW_LINE return ( newNode ) NEW_LINE DEDENT def countTo ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT l = countIn ( root . left ) NEW_LINE r = countTo ( root . right ) NEW_LINE if ( root . data == 1 ) : NEW_LINE INDENT maxCount = l + r + 1 NEW_LINE DEDENT else : NEW_LINE INDENT maxCount = l + r NEW_LINE DEDENT res = max ( res , maxCount ) NEW_LINE if ( root . data == 1 ) : NEW_LINE INDENT return max ( l , r ) + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return max ( l , r ) NEW_LINE DEDENT DEDENT def findMaxCount ( root ) : NEW_LINE INDENT res = - 10 ** 9 NEW_LINE countUtil ( root ) NEW_LINE return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 1 ) NEW_LINE root . left = newNode ( 0 ) NEW_LINE root . left = newNode ( 1 ) NEW_LINE root . left . left = newNode ( 1 ) NEW_LINE root . left . left . left = newNode ( 1 ) NEW_LINE root . left . left . left = newNode ( 1 ) NEW_LINE root . left . right = newNode ( 1 ) NEW_LINE root . left . left . right = newNode ( 1 ) NEW_LINE print ( findMaxCount ( root ) ) NEW_LINE DEDENT"],"references":["class Node : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . data = 0 NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def newNode ( data ) : NEW_LINE INDENT newNode = Node ( ) NEW_LINE newNode . data = data NEW_LINE newNode . left = newNode . right = None NEW_LINE return ( newNode ) NEW_LINE DEDENT res = 0 NEW_LINE def countUntil ( root ) : NEW_LINE INDENT global res NEW_LINE if ( root == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT l = countUntil ( root . left ) NEW_LINE r = countUntil ( root . right ) NEW_LINE maxCount = 0 NEW_LINE if ( root . data == 1 ) : NEW_LINE INDENT maxCount = l + r + 1 NEW_LINE DEDENT else : NEW_LINE INDENT maxCount = l + r NEW_LINE DEDENT res = max ( res , maxCount ) NEW_LINE if ( root . data == 1 ) : NEW_LINE INDENT return max ( l , r ) + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return max ( l , r ) NEW_LINE DEDENT DEDENT def findMaxCount ( root ) : NEW_LINE INDENT global res NEW_LINE res = - 999999 NEW_LINE countUntil ( root ) NEW_LINE return res NEW_LINE DEDENT root = newNode ( 1 ) NEW_LINE root . left = newNode ( 0 ) NEW_LINE root . right = newNode ( 1 ) NEW_LINE root . left . left = newNode ( 1 ) NEW_LINE root . left . right = newNode ( 1 ) NEW_LINE root . left . right . left = newNode ( 1 ) NEW_LINE root . left . right . right = newNode ( 0 ) NEW_LINE print ( findMaxCount ( root ) ) NEW_LINE"],"bleu":0.7935320502697476,"rouge_l":0.8676256667205429}
{"id":1098,"predictions":["import math NEW_LINE def countDigits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT count += 1 NEW_LINE n \/\/= 10 NEW_LINE DEDENT return count NEW_LINE DEDENT def getDistinct ( d , count ) : NEW_LINE INDENT num = 0 NEW_LINE count = math . pow ( 10 , count - 1 ) NEW_LINE while ( count > 0 ) : NEW_LINE INDENT num += ( count * d ) NEW_LINE count \/\/= 10 NEW_LINE DEDENT return num NEW_LINE DEDENT def findCount ( L , R ) : NEW_LINE INDENT count = 0 NEW_LINE countDigitsL = countDigits ( L ) NEW_LINE countDigitsL = countDigits ( L ) NEW_LINE firstDigitsL = countDigits ( 10 , countDigitsL - 1 ) NEW_LINE firstDigitR = ( R \/\/ pow ( 10 , countDigitsL - 1 ) ) NEW_LINE if ( countDigitsL < countDigitsR ) : NEW_LINE INDENT count += ( 9 * ( countDigitsL + 1 ) ) ) NEW_LINE if ( countDigitsL ) : NEW_LINE INDENT count += ( 9 - firstDigitsL + 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT count += ( 9 - firstDigitL ) NEW_LINE DEDENT if ( getDistinct ( firstDigitR , countDigitsL ) <= R ) : NEW_LINE INDENT count += ( 9 - firstDigitL ) NEW_LINE DEDENT else : NEW_LINE INDENT count += ( 9 - firstDigitL ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT L = 10 NEW_LINE R = 50 NEW_LINE print ( findCount ( L , R ) ) NEW_LINE DEDENT"],"references":["def countDigits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT count += 1 NEW_LINE n \/\/= 10 NEW_LINE DEDENT return count NEW_LINE DEDENT def getDistinct ( d , count ) : NEW_LINE INDENT num = 0 NEW_LINE count = pow ( 10 , count - 1 ) NEW_LINE while ( count > 0 ) : NEW_LINE INDENT num += ( count * d ) NEW_LINE count \/\/= 10 NEW_LINE DEDENT return num NEW_LINE DEDENT def findCount ( L , R ) : NEW_LINE INDENT count = 0 NEW_LINE countDigitsL = countDigits ( L ) NEW_LINE countDigitsR = countDigits ( R ) NEW_LINE firstDigitL = ( L \/\/ pow ( 10 , countDigitsL - 1 ) ) NEW_LINE firstDigitR = ( R \/\/ pow ( 10 , countDigitsR - 1 ) ) NEW_LINE if ( countDigitsL < countDigitsR ) : NEW_LINE INDENT count += ( 9 * ( countDigitsR - countDigitsL - 1 ) ) NEW_LINE if ( getDistinct ( firstDigitL , countDigitsL ) >= L ) : NEW_LINE INDENT count += ( 9 - firstDigitL + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT count += ( 9 - firstDigitL ) NEW_LINE DEDENT if ( getDistinct ( firstDigitR , countDigitsR ) <= R ) : NEW_LINE INDENT count += firstDigitR NEW_LINE DEDENT else : NEW_LINE INDENT count += ( firstDigitR - 1 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( getDistinct ( firstDigitL , countDigitsL ) >= L ) : NEW_LINE INDENT count += ( 9 - firstDigitL + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT count += ( 9 - firstDigitL ) NEW_LINE DEDENT if ( getDistinct ( firstDigitR , countDigitsR ) <= R ) : NEW_LINE INDENT count -= ( 9 - firstDigitR ) NEW_LINE DEDENT else : NEW_LINE INDENT count -= ( 9 - firstDigitR + 1 ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT L = 10 NEW_LINE R = 50 NEW_LINE print ( findCount ( L , R ) ) NEW_LINE"],"bleu":0.6575405361991787,"rouge_l":0.7795424664738365}
{"id":1099,"predictions":["def isPalindrome ( n ) : NEW_LINE INDENT divisor = 1 NEW_LINE while ( n \/\/ divisor >= 10 ) : NEW_LINE INDENT divisor *= 10 NEW_LINE DEDENT while ( n != 0 ) : NEW_LINE INDENT leading = n \/\/ divisor NEW_LINE trailing = n % 10 NEW_LINE if ( leading != trailing ) : NEW_LINE INDENT return False NEW_LINE DEDENT n = ( ( n % divisor ) \/\/ 10 NEW_LINE divisor = divisor \/\/ 100 NEW_LINE DEDENT return True NEW_LINE DEDENT def largestPalindrome ( A , n ) : NEW_LINE INDENT A . sort ( ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( isPalindrome ( A [ i ] ) ) : NEW_LINE INDENT return A [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT A = [ 1 , 232 , 5454545 , 999991 ] NEW_LINE n = len ( A ) NEW_LINE print ( largestPalindrome ( A , n ) ) NEW_LINE"],"references":["def isPalindrome ( n ) : NEW_LINE INDENT divisor = 1 NEW_LINE while ( n \/ divisor >= 10 ) : NEW_LINE INDENT divisor *= 10 NEW_LINE DEDENT while ( n != 0 ) : NEW_LINE INDENT leading = n \/\/ divisor NEW_LINE trailing = n % 10 NEW_LINE if ( leading != trailing ) : NEW_LINE INDENT return False NEW_LINE DEDENT n = ( n % divisor ) \/\/ 10 NEW_LINE divisor = divisor \/\/ 100 NEW_LINE DEDENT return True NEW_LINE DEDENT def largestPalindrome ( A , n ) : NEW_LINE INDENT A . sort ( ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( isPalindrome ( A [ i ] ) ) : NEW_LINE INDENT return A [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 1 , 232 , 54545 , 999991 ] NEW_LINE n = len ( A ) NEW_LINE print ( largestPalindrome ( A , n ) ) NEW_LINE DEDENT"],"bleu":0.8828094826885828,"rouge_l":0.9409309500045369}
{"id":1100,"predictions":["def getPerfectSquares ( n ) : NEW_LINE INDENT perfectSquares ( n ) NEW_LINE current = 1 NEW_LINE i = 1 NEW_LINE while ( current <= n ) : NEW_LINE INDENT perfectSquares . add ( current ) NEW_LINE current = i + 1 NEW_LINE DEDENT return perfectSquares NEW_LINE DEDENT def maxPairSum ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE if ( arr [ 0 ] > arr [ 1 ] ) : NEW_LINE INDENT max = arr [ 0 ] NEW_LINE secondMax = arr [ 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT max = arr [ 1 ] NEW_LINE secondMax = arr [ 0 ] NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if ( arr [ i ] > max ) : NEW_LINE INDENT secondMax = max NEW_LINE max = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > secondMax ) : NEW_LINE INDENT secondMax = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > secondMax ) : NEW_LINE INDENT secondMax = arr [ i ] NEW_LINE DEDENT DEDENT return ( max + secondMax ) NEW_LINE DEDENT def countPairsWith ( n , perfectSquares , nums ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( perfectSquares ) ) : NEW_LINE INDENT temp = perfectSquares [ i ] - n NEW_LINE if ( temp > n and nums . count ( temp in nums ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 3 , 6 , 9 , 10 , 20 ] NEW_LINE print ( countPairs ( arr ) ) NEW_LINE DEDENT"],"references":["def getPerfectSquares ( n ) : NEW_LINE INDENT perfectSquares = [ ] ; NEW_LINE current = 1 ; NEW_LINE i = 1 ; NEW_LINE while ( current <= n ) : NEW_LINE INDENT perfectSquares . append ( current ) ; NEW_LINE i += 1 ; NEW_LINE current = int ( pow ( i , 2 ) ) ; NEW_LINE DEDENT return perfectSquares ; NEW_LINE DEDENT def maxPairSum ( arr ) : NEW_LINE INDENT n = len ( arr ) ; NEW_LINE max = 0 ; NEW_LINE secondMax = 0 ; NEW_LINE if ( arr [ 0 ] > arr [ 1 ] ) : NEW_LINE INDENT max = arr [ 0 ] ; NEW_LINE secondMax = arr [ 1 ] ; NEW_LINE DEDENT else : NEW_LINE INDENT max = arr [ 1 ] ; NEW_LINE secondMax = arr [ 0 ] ; NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if ( arr [ i ] > max ) : NEW_LINE INDENT secondMax = max ; NEW_LINE max = arr [ i ] ; NEW_LINE DEDENT elif ( arr [ i ] > secondMax ) : NEW_LINE INDENT secondMax = arr [ i ] ; NEW_LINE DEDENT DEDENT return ( max + secondMax ) ; NEW_LINE DEDENT def countPairsWith ( n , perfectSquares , nums ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( len ( perfectSquares ) ) : NEW_LINE INDENT temp = perfectSquares [ i ] - n ; NEW_LINE if ( temp > n and ( temp in nums ) ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT def countPairs ( arr ) : NEW_LINE INDENT n = len ( arr ) ; NEW_LINE max = maxPairSum ( arr ) ; NEW_LINE perfectSquares = getPerfectSquares ( max ) ; NEW_LINE nums = [ ] ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT nums . append ( arr [ i ] ) ; NEW_LINE DEDENT count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT count += countPairsWith ( arr [ i ] , perfectSquares , nums ) ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT arr = [ 2 , 3 , 6 , 9 , 10 , 20 ] ; NEW_LINE print ( countPairs ( arr ) ) ; NEW_LINE"],"bleu":0.5509300044746072,"rouge_l":0.7218277808119424}
{"id":1101,"predictions":["if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT space = 4 NEW_LINE prt = ' $ ' NEW_LINE for i in range ( 1 , 5 ) : NEW_LINE INDENT for sp in range ( space , 1 , - 1 ) : NEW_LINE INDENT print ( end = \" ▁ \" ) NEW_LINE DEDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( end = \" ▁ \" ) NEW_LINE DEDENT for k in range ( 1 , ( i - 1 ) ) : NEW_LINE INDENT print ( end = \" \" ) NEW_LINE DEDENT for k in range ( 1 , i - 1 ) : NEW_LINE INDENT for j in range ( 1 , i - 1 ) : NEW_LINE INDENT print ( end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT print ( ) NEW_LINE space -= 1 NEW_LINE DEDENT space = 1 NEW_LINE for i in range ( 4 , 0 , - 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( end = \" \" ) NEW_LINE DEDENT for j in range ( 1 , i - 1 ) : NEW_LINE INDENT print ( start , end = \" \" ) NEW_LINE DEDENT for k in range ( 1 , i - 1 ) : NEW_LINE INDENT print ( start , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT space = 3 NEW_LINE for i in range ( 2 , i + 1 ) : NEW_LINE INDENT if ( ( i % 2 ) != 2 ) : NEW_LINE INDENT for j in range ( 1 , 2 ) : NEW_LINE INDENT print ( start , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT DEDENT"],"references":["if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT space = 4 NEW_LINE prt = ' $ ' NEW_LINE for i in range ( 1 , 6 ) : NEW_LINE INDENT for sp in range ( space , 0 , - 1 ) : NEW_LINE INDENT print ( end = \" ▁ \" ) NEW_LINE DEDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( prt , end = \" \" ) NEW_LINE DEDENT for k in range ( 1 , i ) : NEW_LINE INDENT if ( i == 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT print ( prt , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE space -= 1 NEW_LINE DEDENT space = 1 NEW_LINE for i in range ( 4 , 0 , - 1 ) : NEW_LINE INDENT for sp in range ( space , 0 , - 1 ) : NEW_LINE INDENT print ( end = \" ▁ \" ) NEW_LINE DEDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( prt , end = \" \" ) NEW_LINE DEDENT for k in range ( 1 , i ) : NEW_LINE INDENT print ( prt , end = \" \" ) NEW_LINE DEDENT space += 1 NEW_LINE print ( ) NEW_LINE DEDENT space = 3 NEW_LINE for i in range ( 2 , 6 ) : NEW_LINE INDENT if ( ( i % 2 ) != 0 ) : NEW_LINE INDENT for sp in range ( space , 0 , - 1 ) : NEW_LINE INDENT print ( \" ▁ \" , end = \" \" ) NEW_LINE DEDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( prt , end = \" \" ) NEW_LINE DEDENT DEDENT if ( ( i % 2 ) != 0 ) : NEW_LINE INDENT print ( ) NEW_LINE space -= 1 NEW_LINE DEDENT DEDENT DEDENT"],"bleu":0.7606897619800819,"rouge_l":0.7958370680211134}
{"id":1102,"predictions":["def maxLen ( arr , n ) : NEW_LINE INDENT min_val = min ( arr ) NEW_LINE freq = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == min_val ) : NEW_LINE INDENT freq += 1 NEW_LINE DEDENT DEDENT return freq NEW_LINE DEDENT arr = [ 1 , 3 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE ans = maxLen ( arr , n ) NEW_LINE print ( ans ) NEW_LINE"],"references":["def maxLen ( arr , n ) : NEW_LINE INDENT min_val = min ( arr ) ; NEW_LINE freq = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == min_val ) : NEW_LINE INDENT freq += 1 ; NEW_LINE DEDENT DEDENT return freq ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 3 , 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( maxLen ( arr , n ) ) ; NEW_LINE DEDENT"],"bleu":0.6420796848952844,"rouge_l":0.8294979079497908}
{"id":1103,"predictions":["def printKDistinct ( arr , n , k ) : NEW_LINE INDENT h = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT h [ arr [ i ] ] += 1 NEW_LINE DEDENT if ( len ( h ) < k ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT dist_count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if h [ arr [ i ] ] == 1 : NEW_LINE INDENT dist_count += 1 NEW_LINE DEDENT if ( dist_count == k ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT ar = [ 1 , 2 , 1 , 3 , 4 , 2 ] NEW_LINE n = len ( ar ) NEW_LINE print ( printKDistinct ( ar , n , 2 ) ) NEW_LINE"],"references":["def printKDistinct ( arr , size , KthIndex ) : NEW_LINE INDENT dict = { } NEW_LINE vect = [ ] NEW_LINE for i in range ( size ) : NEW_LINE INDENT if ( arr [ i ] in dict ) : NEW_LINE INDENT dict [ arr [ i ] ] = dict [ arr [ i ] ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dict [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT for i in range ( size ) : NEW_LINE INDENT if ( dict [ arr [ i ] ] > 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT KthIndex = KthIndex - 1 NEW_LINE DEDENT if ( KthIndex == 0 ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 1 , 2 , 1 , 3 , 4 , 2 ] NEW_LINE size = len ( arr ) NEW_LINE print ( printKDistinct ( arr , size , 2 ) ) NEW_LINE"],"bleu":0.45053686893810946,"rouge_l":0.6699244332493703}
{"id":1104,"predictions":["def checkSubarraySum ( arr , n , k , sum ) : NEW_LINE INDENT curr_sum = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT curr_sum += arr [ i ] NEW_LINE DEDENT if ( curr_sum == sum ) : NEW_LINE INDENT return True NEW_LINE DEDENT for j in range ( k , n ) : NEW_LINE INDENT curr_sum = curr_sum + arr [ j ] - arr [ j - k ] NEW_LINE if ( curr_sum == sum ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT arr = [ 1 , 4 , 2 , 10 , 2 , 10 , 2 , 3 , 1 , 0 , 20 ] NEW_LINE k = 4 NEW_LINE sum = 18 NEW_LINE n = len ( arr ) NEW_LINE if ( checkSubarraySum ( arr , n , k , sum ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"],"references":["def checkSubarraySum ( arr , n , k , sumV ) : NEW_LINE INDENT curr_sum = 0 NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT curr_sum += arr [ i ] NEW_LINE DEDENT if ( curr_sum == sumV ) : NEW_LINE INDENT return true NEW_LINE DEDENT for j in range ( k , n ) : NEW_LINE INDENT curr_sum = ( curr_sum + arr [ j ] - arr [ j - k ] ) NEW_LINE if ( curr_sum == sumV ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT arr = [ 1 , 4 , 2 , 10 , 2 , 3 , 1 , 0 , 20 ] NEW_LINE k = 4 NEW_LINE sumV = 18 NEW_LINE n = len ( arr ) NEW_LINE if ( checkSubarraySum ( arr , n , k , sumV ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"],"bleu":0.8618384065495781,"rouge_l":0.9418604651162791}
{"id":1105,"predictions":["def printCombination ( n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( i % 3 != 0 ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if ( j % 3 != 0 and ( i + j + k ) == n ) : NEW_LINE INDENT print ( i , j , \" ▁ \" , j , k ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 25 NEW_LINE printCombination ( n ) NEW_LINE DEDENT"],"references":["def printCombination ( n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( i % 3 != 0 ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if ( j % 3 != 0 ) : NEW_LINE INDENT for k in range ( 1 , n ) : NEW_LINE INDENT if ( k % 3 != 0 and ( i + j + k ) == n ) : NEW_LINE INDENT print ( i , j , k ) ; NEW_LINE return ; NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT n = 233 ; NEW_LINE printCombination ( n ) ; NEW_LINE"],"bleu":0.7148119154761056,"rouge_l":0.7757930837382109}
{"id":1106,"predictions":["import math NEW_LINE def countNumbersWith4 ( n ) : NEW_LINE INDENT if ( n < 4 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT d = 10 ** 10 NEW_LINE a = [ 0 for i in range ( d + 2 ) ] NEW_LINE a [ 0 ] = 0 NEW_LINE a [ 1 ] = 1 NEW_LINE a [ 1 ] = 1 NEW_LINE for i in range ( 2 , d + 1 ) : NEW_LINE INDENT a [ i ] = a [ i - 1 ] * 9 + int ( math . ceil ( pow ( 10 , i - 1 ) ) ) NEW_LINE DEDENT p = int ( math . ceil ( 10 , d ) ) NEW_LINE msd = n \/\/ p NEW_LINE if ( msd == 4 ) : NEW_LINE INDENT return ( msd ) * a [ d ] + ( n % p ) + 1 NEW_LINE DEDENT if ( msd > 4 ) : NEW_LINE INDENT return ( msd - 1 ) * a [ d ] + ( n % p ) ) NEW_LINE DEDENT return ( msd ) * a [ d ] + countNumbersWith4 ( n % p ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 328 NEW_LINE print ( \" Count ▁ of ▁ numbers ▁ from ▁ 1 ▁ to \" , n , \" ▁ as ▁ a [ d ] ) NEW_LINE DEDENT"],"references":["import math as mt NEW_LINE def countNumbersWith4 ( n ) : NEW_LINE INDENT if ( n < 4 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT d = int ( mt . log10 ( n ) ) NEW_LINE a = [ 1 for i in range ( d + 1 ) ] NEW_LINE a [ 0 ] = 0 NEW_LINE if len ( a ) > 1 : NEW_LINE INDENT a [ 1 ] = 1 NEW_LINE DEDENT for i in range ( 2 , d + 1 ) : NEW_LINE INDENT a [ i ] = a [ i - 1 ] * 9 + mt . ceil ( pow ( 10 , i - 1 ) ) NEW_LINE DEDENT p = mt . ceil ( pow ( 10 , d ) ) NEW_LINE msd = n \/\/ p NEW_LINE if ( msd == 4 ) : NEW_LINE INDENT return ( msd ) * a [ d ] + ( n % p ) + 1 NEW_LINE DEDENT if ( msd > 4 ) : NEW_LINE INDENT return ( ( msd - 1 ) * a [ d ] + p + countNumbersWith4 ( n % p ) ) NEW_LINE DEDENT return ( msd ) * a [ d ] + countNumbersWith4 ( n % p ) NEW_LINE DEDENT n = 328 NEW_LINE print ( \" Count ▁ of ▁ numbers ▁ from ▁ 1 ▁ to \" , n , \" that ▁ have ▁ 4 ▁ as ▁ a ▁ digit ▁ is \" , countNumbersWith4 ( n ) ) NEW_LINE"],"bleu":0.7644649331307035,"rouge_l":0.8464740759429797}
{"id":1107,"predictions":["import math NEW_LINE arr = [ ] NEW_LINE def generateDivisors ( n ) : NEW_LINE INDENT for i in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT arr . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT arr . append ( i ) NEW_LINE arr . append ( n \/ i ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def harmonicMean ( n ) : NEW_LINE INDENT generateDivisors ( n ) NEW_LINE sum = 0.0 NEW_LINE l = len ( arr ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT sum = sum + n \/ arr [ i ] NEW_LINE DEDENT sum = sum \/ n NEW_LINE if ( mean - floor ( mean ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 28 NEW_LINE if ( isKingNumber ( n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"references":["arr = [ ] NEW_LINE def generateDivisors ( n ) : NEW_LINE INDENT for i in range ( 1 , int ( n ** ( 0.5 ) ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT if n \/\/ i == i : NEW_LINE INDENT arr . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT arr . append ( i ) NEW_LINE arr . append ( n \/\/ i ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def harmonicMean ( n ) : NEW_LINE INDENT generateDivisors ( n ) NEW_LINE Sum = 0 NEW_LINE length = len ( arr ) NEW_LINE for i in range ( 0 , length ) : NEW_LINE INDENT Sum = Sum + ( n \/ arr [ i ] ) NEW_LINE DEDENT Sum = Sum \/ n NEW_LINE return length \/ Sum NEW_LINE DEDENT def isOreNumber ( n ) : NEW_LINE INDENT mean = harmonicMean ( n ) NEW_LINE if mean - int ( mean ) == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 28 NEW_LINE if isOreNumber ( n ) == True : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.684081916082414,"rouge_l":0.8238402818555491}
{"id":1108,"predictions":["import math NEW_LINE def powOfPositive ( n ) : NEW_LINE INDENT pos = floor ( math . log ( n ) ) NEW_LINE return pow ( 2 , pos ) NEW_LINE DEDENT def powOfNegative ( n ) : NEW_LINE INDENT pos = math . ceil ( ( log2 ( n ) ) ) NEW_LINE return - 1 * pow ( 2 , pos ) NEW_LINE DEDENT def highestPowerOfNegative ( n ) : NEW_LINE INDENT pos = ceil ( math . log2 ( n ) ) NEW_LINE return - 1 * pow ( 2 , pos ) NEW_LINE DEDENT def highestPowerOf2 ( n ) : NEW_LINE INDENT if ( n ) : NEW_LINE INDENT print ( powOfPositive ( n ) ) NEW_LINE DEDENT else : NEW_LINE INDENT n = - n NEW_LINE print ( powOfNegative ( n ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = - 24 NEW_LINE highestPowerOf2 ( n ) NEW_LINE DEDENT"],"references":["from math import floor , ceil , log2 NEW_LINE def powOfPositive ( n ) : NEW_LINE INDENT pos = floor ( log2 ( n ) ) ; NEW_LINE return 2 ** pos ; NEW_LINE DEDENT def powOfNegative ( n ) : NEW_LINE INDENT pos = ceil ( log2 ( n ) ) ; NEW_LINE return ( - 1 * pow ( 2 , pos ) ) ; NEW_LINE DEDENT def highestPowerOf2 ( n ) : NEW_LINE INDENT if ( n > 0 ) : NEW_LINE INDENT print ( powOfPositive ( n ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT n = - n ; NEW_LINE print ( powOfNegative ( n ) ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = - 24 ; NEW_LINE highestPowerOf2 ( n ) ; NEW_LINE DEDENT"],"bleu":0.5837691453535354,"rouge_l":0.7893885473956648}
{"id":1109,"predictions":["prime = [ True for i in range ( 1000000 + 5 ) ] NEW_LINE def findPrime ( ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= 1000000 : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , 1000000 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT def lenOfLongSubarr ( arr , n ) : NEW_LINE INDENT um = dict ( ) NEW_LINE Sum = 0 NEW_LINE maxLen = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum += prime [ arr [ i ] ] == False NEW_LINE DEDENT if Sum == 1 : NEW_LINE INDENT Sum += i + 1 NEW_LINE DEDENT if Sum == 1 : NEW_LINE INDENT um [ Sum ] = i + 1 NEW_LINE DEDENT elif Sum in um . keys ( ) : NEW_LINE INDENT um [ Sum ] = i NEW_LINE DEDENT if Sum not in um . keys ( ) : NEW_LINE INDENT um [ Sum ] = i NEW_LINE DEDENT if Sum not in um . keys ( ) : NEW_LINE INDENT if ( Sum - 1 ) : NEW_LINE INDENT if ( maxLen < ( i - um [ Sum - 1 ] ) ) : NEW_LINE INDENT maxLen = i - um [ Sum - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT return maxLen NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT findPrime ( ) NEW_LINE arr = [ 1 , 9 , 3 , 4 , 5 , 6 , 7 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( lenOfLongSubarr ( arr , n ) ) NEW_LINE DEDENT"],"references":["prime = [ True ] * ( 1000000 + 5 ) NEW_LINE def findPrime ( ) : NEW_LINE INDENT prime [ 0 ] , prime [ 1 ] = False , False NEW_LINE for p in range ( 2 , 1001 ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , 1000001 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def lenOfLongSubarr ( arr , n ) : NEW_LINE INDENT um = { } NEW_LINE Sum , maxLen = 0 , 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT Sum = Sum - 1 if prime [ arr [ i ] ] == False else Sum + 1 NEW_LINE if Sum == 1 : NEW_LINE INDENT maxLen = i + 1 NEW_LINE DEDENT elif Sum not in um : NEW_LINE INDENT um [ Sum ] = i NEW_LINE DEDENT if ( Sum - 1 ) in um : NEW_LINE INDENT if maxLen < ( i - um [ Sum - 1 ] ) : NEW_LINE INDENT maxLen = i - um [ Sum - 1 ] NEW_LINE DEDENT DEDENT DEDENT return maxLen NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT findPrime ( ) NEW_LINE arr = [ 1 , 9 , 3 , 4 , 5 , 6 , 7 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( lenOfLongSubarr ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.6734525754751123,"rouge_l":0.8186041176807938}
{"id":1110,"predictions":["def turnOffK ( n , k ) : NEW_LINE INDENT if ( k <= 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return ( n & ~ ( 1 << ( k - 1 ) ) ) NEW_LINE DEDENT n = 15 NEW_LINE k = 4 NEW_LINE print ( turnOnK ( n , k ) ) NEW_LINE"],"references":["def turnOffK ( n , k ) : NEW_LINE INDENT if ( k <= 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return ( n & ~ ( 1 << ( k - 1 ) ) ) NEW_LINE DEDENT n = 15 NEW_LINE k = 4 NEW_LINE print ( turnOffK ( n , k ) ) NEW_LINE"],"bleu":0.9559112197162899,"rouge_l":0.9827586206896551}
{"id":1111,"predictions":["import sys NEW_LINE def longestSubarray ( a , n ) : NEW_LINE INDENT hash = [ [ 0 for i in range ( 10 ) ] for j in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT num = a [ i ] NEW_LINE while ( num != 0 ) : NEW_LINE INDENT hash [ i ] [ num % 10 ] = 1 NEW_LINE num \/\/= 10 NEW_LINE DEDENT DEDENT longest = - 10 ** 9 NEW_LINE count = - 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT if ( hash [ i ] [ j ] == 1 and hash [ i + 1 ] [ j ] == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( j == 10 ) : NEW_LINE INDENT longest = max ( longest , count + 1 ) NEW_LINE count = 0 NEW_LINE DEDENT DEDENT longest = max ( longest , count + 1 ) NEW_LINE return longest NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 11 , 22 , 33 , 44 , 54 , 56 , 56 ] NEW_LINE n = len ( a ) NEW_LINE print ( longestSubarray ( a , n ) ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE def longestSubarray ( a , n ) : NEW_LINE INDENT hash = [ [ 0 for i in range ( 10 ) ] for j in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT num = a [ i ] NEW_LINE while ( num ) : NEW_LINE INDENT hash [ i ] [ num % 10 ] = 1 NEW_LINE num = int ( num \/ 10 ) NEW_LINE DEDENT DEDENT longest = - sys . maxsize - 1 NEW_LINE count = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT if ( hash [ i ] [ j ] and hash [ i + 1 ] [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( j == 10 ) : NEW_LINE INDENT longest = max ( longest , count + 1 ) NEW_LINE count = 0 NEW_LINE DEDENT DEDENT longest = max ( longest , count + 1 ) NEW_LINE return longest NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 11 , 22 , 33 , 44 , 54 , 56 , 63 ] NEW_LINE n = len ( a ) NEW_LINE print ( longestSubarray ( a , n ) ) NEW_LINE DEDENT"],"bleu":0.9031605005340294,"rouge_l":0.9453781512605042}
{"id":1112,"predictions":["def find_Solution ( x , n ) : NEW_LINE INDENT sum = x NEW_LINE e = 2 NEW_LINE o = 1 NEW_LINE p = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT p += 2 NEW_LINE sum += ( o \/\/ e ) * ( x ** p ) NEW_LINE o = o * ( e + 2 ) NEW_LINE e = e * ( e + 2 ) NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT x = - 0.5 NEW_LINE if ( abs ( x ) >= 1 ) : NEW_LINE INDENT print ( \" Invalid ▁ Input \" ) NEW_LINE DEDENT n = 8 NEW_LINE find_Solution ( x , n ) NEW_LINE"],"references":["def find_Solution ( x , n ) : NEW_LINE INDENT Sum = x NEW_LINE e = 2 NEW_LINE o = 1 NEW_LINE p = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT p += 2 NEW_LINE Sum += ( o \/ e ) * ( pow ( x , p ) \/ p ) NEW_LINE o = o * ( o + 2 ) NEW_LINE e = e * ( e + 2 ) NEW_LINE DEDENT print ( round ( Sum , 10 ) ) NEW_LINE DEDENT x = - 0.5 NEW_LINE if ( abs ( x ) >= 1 ) : NEW_LINE INDENT print ( \" Invalid ▁ Input \\n \" ) NEW_LINE DEDENT n = 8 NEW_LINE find_Solution ( x , n ) NEW_LINE"],"bleu":0.7844448396150314,"rouge_l":0.9035320926699582}
{"id":1113,"predictions":["def replaceOriginal ( s , n ) : NEW_LINE INDENT r = [ None ] * n ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT r [ i ] = s [ n - 1 - i ] ; NEW_LINE if ( s [ i ] != ' a ' and s [ i ] != ' e ' and s [ i ] != ' o ' and s [ i ] != ' o ' and s [ i ] != ' u ' and s [ i ] != ' u ' ) : NEW_LINE INDENT print ( r [ i ] ) ; NEW_LINE DEDENT DEDENT print ( \" \" ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" geeksforgeeks \" ; NEW_LINE n = len ( s ) ; NEW_LINE replaceOriginal ( s , n ) ; NEW_LINE DEDENT"],"references":["def replaceOriginal ( s , n ) : NEW_LINE INDENT r = [ ' ▁ ' ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT r [ i ] = s [ n - 1 - i ] NEW_LINE if ( s [ i ] != ' a ' and s [ i ] != ' e ' and s [ i ] != ' i ' and s [ i ] != ' o ' and s [ i ] != ' u ' ) : NEW_LINE INDENT print ( r [ i ] , end = \" \" ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" geeksforgeeks \" NEW_LINE n = len ( s ) NEW_LINE replaceOriginal ( s , n ) NEW_LINE DEDENT"],"bleu":0.7889559247190621,"rouge_l":0.9114264215844352}
{"id":1114,"predictions":["def SieveofEratosthenes ( prime , p_size ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , p_size + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( p * 2 , p_size + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def xorOfPrime ( s ) : NEW_LINE INDENT prime = [ True ] * 100005 NEW_LINE SieveOfEratosthenes ( prime , 10005 ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE m = dict ( ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT m [ s [ i ] ] = m . get ( s [ i ] , 0 ) + 1 NEW_LINE DEDENT m [ s [ i ] ] = 1 NEW_LINE DEDENT result = 0 NEW_LINE flag = 0 NEW_LINE for i in range ( len ( m ) ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT result ^= m [ i ] NEW_LINE flag = 1 NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" ggggeeekskks \" NEW_LINE print ( xorOfPrime ( s ) ) NEW_LINE DEDENT"],"references":["from collections import defaultdict NEW_LINE def SieveOfEratosthenes ( prime , p_size ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= p_size : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT for i in range ( p * 2 , p_size + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT def xorOfPrime ( s ) : NEW_LINE INDENT prime = [ True ] * 100005 NEW_LINE SieveOfEratosthenes ( prime , 10005 ) NEW_LINE m = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT m [ s [ i ] ] += 1 NEW_LINE DEDENT result = flag = 0 NEW_LINE for it in m : NEW_LINE INDENT if prime [ m [ it ] ] : NEW_LINE INDENT result ^= m [ it ] NEW_LINE flag = 1 NEW_LINE DEDENT DEDENT if not flag : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" gggggeeekkkks \" NEW_LINE print ( xorOfPrime ( s ) ) NEW_LINE DEDENT"],"bleu":0.6547171593939234,"rouge_l":0.8129892109160144}
{"id":1115,"predictions":["def findNumbers ( n , d ) : NEW_LINE INDENT for i in range ( n - 2 ) : NEW_LINE INDENT print ( \"1\" , end = \" ▁ \" ) NEW_LINE DEDENT print ( n + d ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 3 NEW_LINE D = 5 NEW_LINE findNumbers ( N , D ) NEW_LINE DEDENT"],"references":["def pattern ( n , d ) : NEW_LINE INDENT for i in range ( 0 , n - 2 ) : NEW_LINE INDENT print ( \"1\" , end = \" ▁ \" ) NEW_LINE DEDENT print ( \"2\" , end = \" ▁ \" ) NEW_LINE print ( n + d ) NEW_LINE DEDENT N = 3 NEW_LINE D = 5 NEW_LINE pattern ( N , D ) NEW_LINE"],"bleu":0.7003382393851945,"rouge_l":0.7811408614668219}
{"id":1116,"predictions":["PI = 3.142 NEW_LINE def x ( x ) : NEW_LINE INDENT x = 60.0 NEW_LINE val = PI \/ 180.0 NEW_LINE ret = cos ( x * val ) NEW_LINE print ( \" The ▁ cosine ▁ of \" , x , \" is \" ) NEW_LINE print ( \" The ▁ coses \" ) NEW_LINE print ( \" The ▁ degrees \" ) NEW_LINE print ( \" The ▁ degrees \" ) NEW_LINE x = 90.0 NEW_LINE if ( x ) : NEW_LINE INDENT P = 80.0 NEW_LINE DEDENT x = 90.0 NEW_LINE if ( x ) : NEW_LINE INDENT P = 80.0 NEW_LINE DEDENT x = 90.0 NEW_LINE if ( x ) : NEW_LINE INDENT P = 80.0 NEW_LINE DEDENT print ( \" The ▁ complement ▁ of \" , x , \" is \" ) NEW_LINE print ( \" Test ▁ of \" , x , \" is \" , end = \" \" ) NEW_LINE print ( \" Test ▁ of \" , x , \" is \" ) NEW_LINE DEDENT"],"references":["import math NEW_LINE if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT PI = 3.14159265 NEW_LINE x = 60.0 NEW_LINE val = PI \/ 180.0 NEW_LINE ret = math . cos ( x * val ) NEW_LINE print ( \" The ▁ cosine ▁ of ▁ is ▁ \" , x , end = \" ▁ \" ) NEW_LINE print ( \" ▁ degrees \" , ret ) NEW_LINE x = 90.0 NEW_LINE val = PI \/ 180.0 NEW_LINE ret = math . cos ( x * val ) NEW_LINE print ( \" The ▁ cosine ▁ of ▁ is ▁ \" , x , end = \" ▁ \" ) NEW_LINE print ( \" degrees \" , ret ) NEW_LINE DEDENT"],"bleu":0.34027128307407445,"rouge_l":0.5870635631154879}
{"id":1117,"predictions":["N = 100 NEW_LINE INF = 1000000 NEW_LINE dp = [ [ [ 0 for i in range ( N ) ] for j in range ( N ) ] NEW_LINE vis = [ [ 0 for i in range ( N ) ] for i in range ( N ) ] NEW_LINE def findSum ( arr , n , k , l , r ) : NEW_LINE INDENT if ( ( l ) + ( n - 1 - r ) == k ) : NEW_LINE INDENT return arr [ r ] - arr [ l ] NEW_LINE DEDENT if ( vis [ l ] [ r ] ) : NEW_LINE INDENT return dp [ l ] [ r ] NEW_LINE DEDENT vis [ l ] [ r ] = 1 NEW_LINE dp [ l ] [ r ] = min ( findSum ( arr , n , k , l , r - 1 ) , findSum ( arr , n , k , l + 1 , r ) ) NEW_LINE return dp [ l ] [ r ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 100 , 120 , 140 ] NEW_LINE k = 2 NEW_LINE n = len ( arr ) NEW_LINE print ( findSum ( arr , n , k , 0 , n - 1 ) ) NEW_LINE DEDENT"],"references":["import numpy as np NEW_LINE N = 100 NEW_LINE INF = 1000000 NEW_LINE dp = np . zeros ( ( N , N ) ) ; NEW_LINE vis = np . zeros ( ( N , N ) ) ; NEW_LINE def findSum ( arr , n , k , l , r ) : NEW_LINE INDENT if ( ( l ) + ( n - 1 - r ) == k ) : NEW_LINE INDENT return arr [ r ] - arr [ l ] ; NEW_LINE DEDENT if ( vis [ l ] [ r ] ) : NEW_LINE INDENT return dp [ l ] [ r ] ; NEW_LINE DEDENT vis [ l ] [ r ] = 1 ; NEW_LINE dp [ l ] [ r ] = min ( findSum ( arr , n , k , l , r - 1 ) , findSum ( arr , n , k , l + 1 , r ) ) ; NEW_LINE return dp [ l ] [ r ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 100 , 120 , 140 ] ; NEW_LINE k = 2 ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( findSum ( arr , n , k , 0 , n - 1 ) ) ; NEW_LINE DEDENT"],"bleu":0.7901907041863678,"rouge_l":0.8799890087243251}
{"id":1118,"predictions":["def totalPairs ( s1 , s2 ) : NEW_LINE INDENT count = 0 NEW_LINE arr1 = [ 0 for i in range ( 7 ) ] NEW_LINE arr2 = [ 0 for i in range ( 7 ) ] NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT set_bits = bin ( s1 [ i ] ) . count ( '1' ) NEW_LINE arr1 [ set_bits ] += 1 NEW_LINE DEDENT for i in range ( len ( s2 ) ) : NEW_LINE INDENT set_bits = bin ( s2 [ i ] ) NEW_LINE arr2 [ set_bits ] += 1 NEW_LINE DEDENT for i in range ( 1 , 6 ) : NEW_LINE INDENT count += ( arr1 [ i ] * arr2 [ i ] ) NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s1 = \" geeks \" NEW_LINE s2 = \" forgeeks \" NEW_LINE print ( totalPairs ( s1 , s2 ) ) NEW_LINE DEDENT"],"references":["def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT count += n & 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def totalPairs ( s1 , s2 ) : NEW_LINE INDENT count = 0 ; NEW_LINE arr1 = [ 0 ] * 7 ; arr2 = [ 0 ] * 7 ; NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT set_bits = countSetBits ( ord ( s1 [ i ] ) ) NEW_LINE arr1 [ set_bits ] += 1 ; NEW_LINE DEDENT for i in range ( len ( s2 ) ) : NEW_LINE INDENT set_bits = countSetBits ( ord ( s2 [ i ] ) ) ; NEW_LINE arr2 [ set_bits ] += 1 ; NEW_LINE DEDENT for i in range ( 1 , 7 ) : NEW_LINE INDENT count += ( arr1 [ i ] * arr2 [ i ] ) ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s1 = \" geeks \" ; NEW_LINE s2 = \" forgeeks \" ; NEW_LINE print ( totalPairs ( s1 , s2 ) ) ; NEW_LINE DEDENT"],"bleu":0.620816971780719,"rouge_l":0.7808657571163888}
{"id":1119,"predictions":["def minOperations ( n ) : NEW_LINE INDENT count = 0 NEW_LINE d = 0 NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( n > 9 ) : NEW_LINE INDENT d = max ( n % 10 , d ) NEW_LINE n \/\/= 10 NEW_LINE count += 10 NEW_LINE DEDENT d = max ( d , n - 1 ) NEW_LINE count += abs ( d ) NEW_LINE return count - 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 240 NEW_LINE print ( minOperations ( n ) ) NEW_LINE DEDENT"],"references":["def minOperations ( n ) : NEW_LINE INDENT count = 0 NEW_LINE d = 0 NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( n > 9 ) : NEW_LINE INDENT d = max ( n % 10 , d ) NEW_LINE n \/\/= 10 NEW_LINE count += 10 NEW_LINE DEDENT d = max ( d , n - 1 ) NEW_LINE count += abs ( d ) NEW_LINE return count - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 240 NEW_LINE print ( minOperations ( n ) ) NEW_LINE DEDENT"],"bleu":0.9530291128076775,"rouge_l":0.9814814814814815}
{"id":1120,"predictions":["def myCopy ( s1 , s2 ) : NEW_LINE INDENT for i in range ( len ( s1 ) ) : NEW_LINE INDENT s2 [ i ] = s1 [ i ] NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s1 = \" GEEKSFORGEEKS \" NEW_LINE s2 = [ 0 ] * ( len ( s1 ) ) NEW_LINE myCopy ( s1 , s2 ) NEW_LINE print ( \" \" . join ( s2 ) ) NEW_LINE DEDENT"],"references":["def myCopy ( s1 , s2 ) : NEW_LINE INDENT for i in range ( len ( s1 ) ) : NEW_LINE INDENT s2 [ i ] = s1 [ i ] ; NEW_LINE DEDENT DEDENT s1 = \" GEEKSFORGEEKS \" ; NEW_LINE s2 = [ ' ' ] * ( len ( s1 ) ) ; NEW_LINE myCopy ( s1 , s2 ) ; NEW_LINE print ( ( \" \" . join ( s2 ) ) ) ; NEW_LINE"],"bleu":0.698684744342027,"rouge_l":0.8610337972166999}
{"id":1121,"predictions":["def bitonicGenerator ( arr , n ) : NEW_LINE INDENT evenArr = [ ] NEW_LINE oddArr = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i % 2 != 1 ) : NEW_LINE INDENT evenArr . append ( arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT oddArr . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT evenArr . sort ( reverseArr ) NEW_LINE oddArr . sort ( reverseArr ) NEW_LINE i = 0 NEW_LINE for j in range ( len ( evenArr ) ) : NEW_LINE INDENT arr [ i ] = evenArr [ j ] NEW_LINE i += 1 NEW_LINE DEDENT for j in range ( len ( oddArr ) ) : NEW_LINE INDENT arr [ i ] = oddArr [ j ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT arr = [ 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE bitonicGenerator ( arr , n ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT"],"references":["def bitonicGenerator ( arr , n ) : NEW_LINE INDENT evenArr = [ ] NEW_LINE oddArr = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( i % 2 ) == 0 ) : NEW_LINE INDENT evenArr . append ( arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT oddArr . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT evenArr = sorted ( evenArr ) NEW_LINE oddArr = sorted ( oddArr ) NEW_LINE oddArr = oddArr [ : : - 1 ] NEW_LINE i = 0 NEW_LINE for j in range ( len ( evenArr ) ) : NEW_LINE INDENT arr [ i ] = evenArr [ j ] NEW_LINE i += 1 NEW_LINE DEDENT for j in range ( len ( oddArr ) ) : NEW_LINE INDENT arr [ i ] = oddArr [ j ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT arr = [ 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE bitonicGenerator ( arr , n ) NEW_LINE for i in arr : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT"],"bleu":0.8551637055121395,"rouge_l":0.9079644638403989}
{"id":1122,"predictions":["def ReverseCharBridge ( n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( ' A ' , ' A ' + ( 2 * n ) - 1 ) : NEW_LINE INDENT if ( j >= ( ' A ' + n - 1 ) + i ) : NEW_LINE INDENT print ( chr ( ( ord ( ' A ' ) + i ) ) ) ; NEW_LINE DEDENT elif ( j <= ( ' A ' + n - 1 ) - i ) - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' ▁ ' , end = ' ' ) ; NEW_LINE DEDENT DEDENT print ( ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 6 ; NEW_LINE Reverse ( n ) ; NEW_LINE DEDENT"],"references":["def ReverseCharBridge ( n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( ord ( ' A ' ) , ord ( ' A ' ) + ( 2 * n ) - 1 ) : NEW_LINE INDENT if j >= ( ord ( ' A ' ) + n - 1 ) + i : NEW_LINE INDENT print ( chr ( ( ord ( ' A ' ) + n - 1 ) - ( j % ( ord ( ' A ' ) + n - 1 ) ) ) , end = ' ' ) NEW_LINE DEDENT elif j <= ( ord ( ' A ' ) + n - 1 ) - i : NEW_LINE INDENT print ( chr ( j ) , end = ' ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( end = \" ▁ \" ) NEW_LINE DEDENT DEDENT print ( \" \\n \" , end = ' ' ) NEW_LINE DEDENT DEDENT n = 6 NEW_LINE ReverseCharBridge ( n ) NEW_LINE"],"bleu":0.5005003358275346,"rouge_l":0.6995278018695191}
{"id":1123,"predictions":["n = 4 NEW_LINE m = 4 NEW_LINE def calcProbability ( M , k ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE sum = [ 0 ] * n NEW_LINE for j in range ( n ) : NEW_LINE INDENT dp [ 0 ] [ j ] = M [ 0 ] [ j ] NEW_LINE sum [ 0 ] = sum [ 0 ] + dp [ 0 ] [ j ] NEW_LINE DEDENT for i in range ( 1 , m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i - 1 ] [ j ] \/ sum [ i - 1 ] + M [ i ] [ j ] NEW_LINE sum [ i ] += dp [ i ] [ j ] NEW_LINE DEDENT DEDENT return dp [ n - 1 ] [ k - 1 ] \/ sum [ k ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT M = [ [ 1 , 1 , 0 , 3 ] , [ 2 , 3 , 2 , 3 ] , [ 9 , 3 , 0 , 2 ] , [ 2 , 3 , 2 , 2 ] ] NEW_LINE k = 3 NEW_LINE print ( calcProbability ( M , k ) ) NEW_LINE DEDENT"],"references":["n = 4 NEW_LINE m = 4 NEW_LINE def calcProbability ( M , k ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( m ) ] NEW_LINE Sum = [ 0 for i in range ( n ) ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT dp [ 0 ] [ j ] = M [ 0 ] [ j ] NEW_LINE Sum [ 0 ] += dp [ 0 ] [ j ] NEW_LINE DEDENT for i in range ( 1 , m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT dp [ i ] [ j ] += ( dp [ i - 1 ] [ j ] \/ Sum [ i - 1 ] + M [ i ] [ j ] ) NEW_LINE Sum [ i ] += dp [ i ] [ j ] NEW_LINE DEDENT DEDENT return dp [ n - 1 ] [ k - 1 ] \/ Sum [ n - 1 ] NEW_LINE DEDENT M = [ [ 1 , 1 , 0 , 3 ] , [ 2 , 3 , 2 , 3 ] , [ 9 , 3 , 0 , 2 ] , [ 2 , 3 , 2 , 2 ] ] NEW_LINE k = 3 NEW_LINE print ( calcProbability ( M , k ) ) NEW_LINE"],"bleu":0.8116246634891768,"rouge_l":0.8988370556363156}
{"id":1124,"predictions":["def largestSubset ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE dp = [ 0 for i in range ( n ) ] NEW_LINE dp [ n - 1 ] = 1 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT mxm = 0 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( a [ j ] % a [ i ] == 0 ) : NEW_LINE INDENT mxm = max ( mxm , dp [ j ] ) NEW_LINE DEDENT DEDENT dp [ i ] = 1 + mxm NEW_LINE DEDENT return max ( dp ) NEW_LINE DEDENT a = [ 1 , 3 , 6 , 13 , 17 , 18 ] NEW_LINE n = len ( a ) NEW_LINE print ( largestSubset ( a , n ) ) NEW_LINE"],"references":["def largestSubset ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE dp = [ 0 for i in range ( n ) ] NEW_LINE dp [ n - 1 ] = 1 ; NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT mxm = 0 ; NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if a [ j ] % a [ i ] == 0 : NEW_LINE INDENT mxm = max ( mxm , dp [ j ] ) NEW_LINE DEDENT DEDENT dp [ i ] = 1 + mxm NEW_LINE DEDENT return max ( dp ) NEW_LINE DEDENT a = [ 1 , 3 , 6 , 13 , 17 , 18 ] NEW_LINE n = len ( a ) NEW_LINE print ( largestSubset ( a , n ) ) NEW_LINE"],"bleu":0.9475539761574979,"rouge_l":0.9870967741935484}
{"id":1125,"predictions":["def findLargest ( N ) : NEW_LINE INDENT largest = strings ( N , '7' ) ; NEW_LINE return largest ; NEW_LINE DEDENT def findSmallest ( N ) : NEW_LINE INDENT smallest = \"1\" + strings ( ( N - 1 ) , '0' ) ; NEW_LINE return smallest ; NEW_LINE DEDENT def printLargest ( N ) : NEW_LINE INDENT print ( \" Largest : \" , findLargest ( N , c ) ) ; NEW_LINE print ( \" Smallest : \" , findLargest ( N ) ) ; NEW_LINE print ( \" Smallest : \" , findSmallest ( N ) ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 4 ; NEW_LINE printLargestSmallest ( N ) ; NEW_LINE DEDENT"],"references":["def findLargest ( N ) : NEW_LINE INDENT largest = strings ( N , '7' ) ; NEW_LINE return largest ; NEW_LINE DEDENT def findSmallest ( N ) : NEW_LINE INDENT smallest = \"1\" + strings ( ( N - 1 ) , '0' ) ; NEW_LINE return smallest ; NEW_LINE DEDENT def strings ( N , c ) : NEW_LINE INDENT temp = \" \" ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT temp += c ; NEW_LINE DEDENT return temp ; NEW_LINE DEDENT def printLargestSmallest ( N ) : NEW_LINE INDENT print ( \" Largest : ▁ \" , findLargest ( N ) ) ; NEW_LINE print ( \" Smallest : ▁ \" , findSmallest ( N ) ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 ; NEW_LINE printLargestSmallest ( N ) ; NEW_LINE DEDENT"],"bleu":0.6988323202252914,"rouge_l":0.8149120803836492}
{"id":1126,"predictions":["def findMaxNum ( arr , n ) : NEW_LINE INDENT hash = [ 0 for i in range ( 10 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( 9 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( Hash [ i ] ) : NEW_LINE INDENT print ( i , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE findMaxNum ( arr , n ) NEW_LINE DEDENT"],"references":["def findMaxNum ( arr , n ) : NEW_LINE INDENT hash = [ 0 ] * 10 NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( 9 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( hash [ i ] ) : NEW_LINE INDENT print ( i , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE findMaxNum ( arr , n ) NEW_LINE DEDENT"],"bleu":0.9106944457101634,"rouge_l":0.9602580645161288}
{"id":1127,"predictions":["def countDigits ( n ) : NEW_LINE INDENT c = 0 NEW_LINE while True : NEW_LINE INDENT c += 1 NEW_LINE n = n \/\/ 10 NEW_LINE if n == 0 : NEW_LINE INDENT c += 1 NEW_LINE n = n \/\/ 10 NEW_LINE DEDENT DEDENT return c NEW_LINE DEDENT def isseium ( x ) : NEW_LINE INDENT temp = x NEW_LINE p = countDigits ( x ) NEW_LINE sum = 0 NEW_LINE while x != 0 : NEW_LINE INDENT sum += pow ( x , p ) NEW_LINE p -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = 105 NEW_LINE if ises ( x ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def countDigits ( n ) : NEW_LINE INDENT c = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT c += 1 NEW_LINE n = int ( n \/ 10 ) NEW_LINE DEDENT return c NEW_LINE DEDENT def isDeserium ( x ) : NEW_LINE INDENT temp = x NEW_LINE p = countDigits ( x ) NEW_LINE sum = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT digit = int ( x % 10 ) NEW_LINE sum += pow ( digit , p ) NEW_LINE p -= 1 NEW_LINE x = int ( x \/ 10 ) NEW_LINE DEDENT return ( sum == temp ) NEW_LINE DEDENT x = 135 NEW_LINE if ( isDeserium ( x ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.5929266382417433,"rouge_l":0.7400226757369615}
{"id":1128,"predictions":["def polyarea ( n , r ) : NEW_LINE INDENT if ( r < 0 and n < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT A = ( ( r * r * n ) * sin ( ( 360 \/ n ) * 3.14159 \/ 180 ) ) ) \/ 2 NEW_LINE return A NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT r , n = 9 , 6 NEW_LINE print ( polyarea ( n , r ) ) NEW_LINE DEDENT"],"references":["from math import sin NEW_LINE def polyarea ( n , r ) : NEW_LINE INDENT if ( r < 0 and n < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT A = ( ( ( r * r * n ) * sin ( ( 360 \/ n ) * 3.14159 \/ 180 ) ) \/ 2 ) ; NEW_LINE return round ( A , 3 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT r , n = 9 , 6 NEW_LINE print ( polyarea ( n , r ) ) NEW_LINE DEDENT"],"bleu":0.7816851862442702,"rouge_l":0.8982461945731304}
{"id":1129,"predictions":["def smallestSumSubarr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = - arr [ i ] NEW_LINE DEDENT sum_here = arr [ 0 ] NEW_LINE max_sum = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT sum_here = max ( sum_here + arr [ i ] , arr [ i ] ) NEW_LINE max_sum = max ( max_sum , sum_here ) NEW_LINE DEDENT return ( - 1 ) * max_sum NEW_LINE DEDENT arr = [ 3 , - 4 , 2 , - 3 , - 1 , - 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Smallest ▁ sum : \" , smallestSumSubarr ( arr , n ) ) NEW_LINE"],"references":["def smallestSumSubarr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = - arr [ i ] NEW_LINE DEDENT sum_here = arr [ 0 ] NEW_LINE max_sum = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT sum_here = max ( sum_here + arr [ i ] , arr [ i ] ) NEW_LINE max_sum = max ( max_sum , sum_here ) NEW_LINE DEDENT return ( - 1 ) * max_sum NEW_LINE DEDENT arr = [ 3 , - 4 , 2 , - 3 , - 1 , 7 , - 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Smallest ▁ sum : \" , smallestSumSubarr ( arr , n ) ) NEW_LINE"],"bleu":0.9801711937314871,"rouge_l":0.9915194346289753}
{"id":1130,"predictions":["def countSub ( arr , n , x ) : NEW_LINE INDENT st = 0 NEW_LINE end = 0 NEW_LINE sum = 0 NEW_LINE cnt = 0 NEW_LINE while ( end < n ) : NEW_LINE INDENT sum += arr [ end ] NEW_LINE while ( st <= end and sum > x ) : NEW_LINE INDENT sum -= arr [ st ] NEW_LINE st += 1 NEW_LINE DEDENT cnt += ( end - st + 1 ) NEW_LINE end += 1 NEW_LINE DEDENT return cnt NEW_LINE DEDENT def findSubSumLtoR ( arr , n , L , R ) : NEW_LINE INDENT Rcnt = countSub ( arr , n , L ) NEW_LINE Lcnt = countSub ( arr , n , L - 1 ) NEW_LINE return Rcnt - Lcnt NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 4 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE L = 3 NEW_LINE R = 8 NEW_LINE print ( findSubSumLtoR ( arr , n , L , R ) ) NEW_LINE DEDENT"],"references":["def countSub ( arr , n , x ) : NEW_LINE INDENT st = 0 NEW_LINE end = 0 NEW_LINE sum = 0 NEW_LINE cnt = 0 NEW_LINE while end < n : NEW_LINE INDENT sum += arr [ end ] NEW_LINE while ( st <= end and sum > x ) : NEW_LINE INDENT sum -= arr [ st ] NEW_LINE st += 1 NEW_LINE DEDENT cnt += ( end - st + 1 ) NEW_LINE end += 1 NEW_LINE DEDENT return cnt NEW_LINE DEDENT def findSubSumLtoR ( arr , n , L , R ) : NEW_LINE INDENT Rcnt = countSub ( arr , n , R ) NEW_LINE Lcnt = countSub ( arr , n , L - 1 ) NEW_LINE return Rcnt - Lcnt NEW_LINE DEDENT arr = [ 1 , 4 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE L = 3 NEW_LINE R = 8 NEW_LINE print ( findSubSumLtoR ( arr , n , L , R ) ) NEW_LINE"],"bleu":0.8748300715169378,"rouge_l":0.9569520963675412}
{"id":1131,"predictions":["def minCost ( cost , m , n ) : NEW_LINE INDENT tc = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE tc [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT tc [ i ] [ 0 ] = tc [ i - 1 ] [ 0 ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT tc [ i ] [ 0 ] = tc [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] NEW_LINE DEDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT tc [ 0 ] [ j ] = tc [ 0 ] [ j - 1 ] + cost [ i ] [ j ] NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT c [ i ] [ j ] = min ( tc [ i - 1 ] [ j - 1 ] , c [ i ] [ j ] ) + cost [ i ] [ j ] NEW_LINE DEDENT DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT tc [ i ] [ j ] = min ( tc [ i - 1 ] [ j - 1 ] , c [ i - 1 ] [ j ] , cost [ i ] [ j - 1 ] ) + cost [ i ] [ j ] NEW_LINE DEDENT DEDENT return c [ m ] [ n ] NEW_LINE DEDENT cost = [ [ 1 , 2 , 3 ] , [ 4 , 8 , 2 ] , [ 1 , 5 , 3 ] ] NEW_LINE print ( minCost ( cost , 2 ) ) NEW_LINE"],"references":["R = 3 NEW_LINE C = 3 NEW_LINE def minCost ( cost , m , n ) : NEW_LINE INDENT tc = [ [ 0 for x in range ( C ) ] for x in range ( R ) ] NEW_LINE tc [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT tc [ i ] [ 0 ] = tc [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] NEW_LINE DEDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT tc [ 0 ] [ j ] = tc [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT tc [ i ] [ j ] = min ( tc [ i - 1 ] [ j - 1 ] , tc [ i - 1 ] [ j ] , tc [ i ] [ j - 1 ] ) + cost [ i ] [ j ] NEW_LINE DEDENT DEDENT return tc [ m ] [ n ] NEW_LINE DEDENT cost = [ [ 1 , 2 , 3 ] , [ 4 , 8 , 2 ] , [ 1 , 5 , 3 ] ] NEW_LINE print ( minCost ( cost , 2 , 2 ) ) NEW_LINE"],"bleu":0.6693785275103339,"rouge_l":0.8163017031630171}
{"id":1132,"predictions":["def msbPos ( n ) : NEW_LINE INDENT msb_p_p = - 1 NEW_LINE while ( n ) : NEW_LINE INDENT n = n >> 1 NEW_LINE msb_p_p += 1 NEW_LINE DEDENT return msb NEW_LINE DEDENT def andOperator ( x , y ) : NEW_LINE INDENT res = 0 NEW_LINE while ( x > 0 and y > 0 ) : NEW_LINE INDENT msb_p1 = msbPos ( x ) NEW_LINE msb_p_p2 = msbPos ( y ) NEW_LINE if ( msb1 != msb_p2 ) : NEW_LINE INDENT break NEW_LINE DEDENT msb_val = ( 1 << msb_val ) NEW_LINE res = res + msb_val NEW_LINE x = x - msb_val NEW_LINE y = y - msb_val NEW_LINE DEDENT return res NEW_LINE DEDENT x = 10 NEW_LINE y = 15 NEW_LINE print ( andOperator ( x , y ) ) NEW_LINE"],"references":["def msbPos ( n ) : NEW_LINE INDENT msb_p = - 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n = n >> 1 NEW_LINE msb_p += 1 NEW_LINE DEDENT return msb_p NEW_LINE DEDENT def andOperator ( x , y ) : NEW_LINE INDENT res = 0 NEW_LINE while ( x > 0 and y > 0 ) : NEW_LINE INDENT msb_p1 = msbPos ( x ) NEW_LINE msb_p2 = msbPos ( y ) NEW_LINE if ( msb_p1 != msb_p2 ) : NEW_LINE INDENT break NEW_LINE DEDENT msb_val = ( 1 << msb_p1 ) NEW_LINE res = res + msb_val NEW_LINE x = x - msb_val NEW_LINE y = y - msb_val NEW_LINE DEDENT return res NEW_LINE DEDENT x , y = 10 , 15 NEW_LINE print ( andOperator ( x , y ) ) NEW_LINE"],"bleu":0.8244790525328634,"rouge_l":0.9263257800450825}
{"id":1133,"predictions":["count_COLOR = [ 0 ] * 2 NEW_LINE def dfs ( adj , node , parent , color ) : NEW_LINE INDENT count_COLOR [ 0 ] = 0 NEW_LINE for i in range ( len ( adj [ node ] ) ) : NEW_LINE INDENT if ( color == 0 ) : NEW_LINE INDENT count_COLOR [ node ] += 1 NEW_LINE DEDENT for i in range ( len ( adj [ node ] ) ) : NEW_LINE INDENT if ( adj [ node ] [ i ] != parent ) : NEW_LINE INDENT dfs ( adj , adj [ node ] [ i ] , node , not connection ) NEW_LINE DEDENT DEDENT DEDENT def findMaxEdges ( adj , n ) : NEW_LINE INDENT dfs ( adj , 1 , 0 ) NEW_LINE return ( count_ Color [ 0 ] * count_count [ 1 ] ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 NEW_LINE adj = [ ] NEW_LINE adj [ 1 ] . append ( 2 ) NEW_LINE adj [ 2 ] . append ( 2 ) NEW_LINE adj [ 2 ] . append ( 4 ) NEW_LINE adj [ 3 ] . append ( 4 ) NEW_LINE print ( findMaxEdges ( adj , n ) ) NEW_LINE DEDENT"],"references":["def dfs ( adj , node , parent , color ) : NEW_LINE INDENT count_color [ color ] += 1 NEW_LINE for i in range ( len ( adj [ node ] ) ) : NEW_LINE INDENT if ( adj [ node ] [ i ] != parent ) : NEW_LINE INDENT dfs ( adj , adj [ node ] [ i ] , node , not color ) NEW_LINE DEDENT DEDENT DEDENT def findMaxEdges ( adj , n ) : NEW_LINE INDENT dfs ( adj , 1 , 0 , 0 ) NEW_LINE return ( count_color [ 0 ] * count_color [ 1 ] - ( n - 1 ) ) NEW_LINE DEDENT count_color = [ 0 , 0 ] NEW_LINE n = 5 NEW_LINE adj = [ [ ] for i in range ( n + 1 ) ] NEW_LINE adj [ 1 ] . append ( 2 ) NEW_LINE adj [ 1 ] . append ( 3 ) NEW_LINE adj [ 2 ] . append ( 4 ) NEW_LINE adj [ 3 ] . append ( 5 ) NEW_LINE print ( findMaxEdges ( adj , n ) ) NEW_LINE"],"bleu":0.6666275737451377,"rouge_l":0.7798504462490955}
{"id":1134,"predictions":["def steps ( str , str ) : NEW_LINE INDENT flag = False NEW_LINE x = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT flag = True NEW_LINE DEDENT if ( x == n - 1 ) : NEW_LINE INDENT flag = False NEW_LINE DEDENT for j in range ( x ) : NEW_LINE INDENT print ( \" * \" , end = \" \" ) NEW_LINE DEDENT print ( str [ i ] , end = \" \" ) NEW_LINE if ( flag == True ) : NEW_LINE INDENT x += 1 NEW_LINE DEDENT else : NEW_LINE INDENT x -= 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" GeeksForGeeks \" NEW_LINE print ( str ) NEW_LINE print ( \" Maximum ▁ length ▁ of ▁ Steps : \" , n ) NEW_LINE steps ( str , n ) NEW_LINE DEDENT"],"references":["import math as mt NEW_LINE def steps ( string , n ) : NEW_LINE INDENT flag = False NEW_LINE x = 0 NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT flag = True NEW_LINE DEDENT if ( x == n - 1 ) : NEW_LINE INDENT flag = False NEW_LINE DEDENT for j in range ( x ) : NEW_LINE INDENT print ( \" * \" , end = \" \" ) NEW_LINE DEDENT print ( string [ i ] ) NEW_LINE if ( flag == True ) : NEW_LINE INDENT x += 1 NEW_LINE DEDENT else : NEW_LINE INDENT x -= 1 NEW_LINE DEDENT DEDENT DEDENT n = 4 NEW_LINE string = \" GeeksForGeeks \" NEW_LINE print ( \" String : ▁ \" , string ) NEW_LINE print ( \" Max ▁ Length ▁ of ▁ Steps : ▁ \" , n ) NEW_LINE steps ( string , n ) NEW_LINE"],"bleu":0.7463223240597645,"rouge_l":0.8479634490133178}
{"id":1135,"predictions":["def max_xor ( arr , n ) : NEW_LINE INDENT maxx , mask = 0 , 0 NEW_LINE se = set ( ) NEW_LINE for i in range ( 30 , - 1 , - 1 ) : NEW_LINE INDENT mask |= ( 1 << i ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT se . add ( arr [ j ] & mask ) NEW_LINE DEDENT newMaxx = maxx | ( 1 << i ) NEW_LINE for prefix in se : NEW_LINE INDENT if ( newMaxx ^ prefix ) : NEW_LINE INDENT maxx = newMaxx NEW_LINE break NEW_LINE DEDENT DEDENT se . clear ( ) NEW_LINE DEDENT return maxx NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 25 , 10 , 2 , 8 , 5 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( max_xor ( arr , n ) ) NEW_LINE DEDENT"],"references":["def max_xor ( arr , n ) : NEW_LINE INDENT maxx = 0 NEW_LINE mask = 0 ; NEW_LINE se = set ( ) NEW_LINE for i in range ( 30 , - 1 , - 1 ) : NEW_LINE INDENT mask |= ( 1 << i ) NEW_LINE newMaxx = maxx | ( 1 << i ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT se . add ( arr [ i ] & mask ) NEW_LINE DEDENT for prefix in se : NEW_LINE INDENT if ( newMaxx ^ prefix ) in se : NEW_LINE INDENT maxx = newMaxx NEW_LINE break NEW_LINE DEDENT DEDENT se . clear ( ) NEW_LINE DEDENT return maxx NEW_LINE DEDENT arr = [ 25 , 10 , 2 , 8 , 5 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( max_xor ( arr , n ) ) NEW_LINE"],"bleu":0.8111250646561,"rouge_l":0.8561851890646276}
{"id":1136,"predictions":["N = 1000000007 ; NEW_LINE def exponentiation ( bas , exp ) : NEW_LINE INDENT t = 1 ; NEW_LINE while ( exp ) : NEW_LINE INDENT if ( exp % 2 != 0 ) : NEW_LINE INDENT t = ( t * base ) % N ; NEW_LINE DEDENT base = ( bas * base ) % N ; NEW_LINE exp \/\/= 2 ; NEW_LINE DEDENT return t % N ; NEW_LINE DEDENT bas = 5 ; NEW_LINE exp = 100000 ; NEW_LINE modulo = exponentiation ( bas , exp ) ; NEW_LINE print ( modulo ) ; NEW_LINE"],"references":["N = 1000000007 ; NEW_LINE def exponentiation ( bas , exp ) : NEW_LINE INDENT t = 1 ; NEW_LINE while ( exp > 0 ) : NEW_LINE INDENT if ( exp % 2 != 0 ) : NEW_LINE INDENT t = ( t * bas ) % N ; NEW_LINE DEDENT bas = ( bas * bas ) % N ; NEW_LINE exp = int ( exp \/ 2 ) ; NEW_LINE DEDENT return t % N ; NEW_LINE DEDENT bas = 5 ; NEW_LINE exp = 100000 ; NEW_LINE modulo = exponentiation ( bas , exp ) ; NEW_LINE print ( modulo ) ; NEW_LINE"],"bleu":0.8149871446371796,"rouge_l":0.9219143576826198}
{"id":1137,"predictions":["def countMaxIntersect ( n ) : NEW_LINE INDENT return ( n * ( n - 1 ) \/\/ 2 ) NEW_LINE DEDENT n = 8 NEW_LINE print ( countMaxIntersect ( n ) ) NEW_LINE"],"references":["def countMaxIntersect ( n ) : NEW_LINE INDENT return int ( n * ( n - 1 ) \/ 2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 8 NEW_LINE print ( countMaxIntersect ( n ) ) NEW_LINE DEDENT"],"bleu":0.5310015924573408,"rouge_l":0.7700841622035195}
{"id":1138,"predictions":["def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT def findArray ( n , k , s ) : NEW_LINE INDENT vs = [ 0 for i in range ( n + 1 ) ] NEW_LINE cnt = 0 NEW_LINE arr = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ i ] = s NEW_LINE vs [ i ] = 1 NEW_LINE cnt += 1 NEW_LINE DEDENT vl = s NEW_LINE if ( s % 2 == 0 ) : NEW_LINE INDENT vl += 1 NEW_LINE DEDENT else : NEW_LINE INDENT v = v NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( vs [ i ] == 0 ) : NEW_LINE INDENT arr [ i ] = v NEW_LINE DEDENT DEDENT printArr ( arr , n ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 8 NEW_LINE k = 3 NEW_LINE s = 10 NEW_LINE findArray ( n , k , s ) NEW_LINE DEDENT"],"references":["def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT def findArray ( n , k , s ) : NEW_LINE INDENT vis = [ 0 ] * n ; NEW_LINE cnt = 0 ; NEW_LINE arr = [ 0 ] * n ; NEW_LINE i = 0 ; NEW_LINE while ( i < n and cnt < k ) : NEW_LINE INDENT arr [ i ] = s ; NEW_LINE vis [ i ] = 1 ; NEW_LINE cnt += 1 ; NEW_LINE i += 2 ; NEW_LINE DEDENT val = s ; NEW_LINE if ( s % 2 == 0 ) : NEW_LINE INDENT val += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT val = val + 2 ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( vis [ i ] == 0 ) : NEW_LINE INDENT arr [ i ] = val ; NEW_LINE DEDENT DEDENT printArr ( arr , n ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 8 ; k = 3 ; s = 12 ; NEW_LINE findArray ( n , k , s ) ; NEW_LINE DEDENT"],"bleu":0.6351123789360721,"rouge_l":0.8181885179453166}
{"id":1139,"predictions":["def modInverse ( a , m ) : NEW_LINE INDENT a = a % m NEW_LINE for x in range ( 1 , m ) : NEW_LINE INDENT if ( ( a * x ) % m == 1 ) : NEW_LINE INDENT return x NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT a = 3 NEW_LINE m = 11 NEW_LINE print ( modInverse ( a , m ) ) NEW_LINE"],"references":["def modInverse ( a , m ) : NEW_LINE INDENT a = a % m ; NEW_LINE for x in range ( 1 , m ) : NEW_LINE INDENT if ( ( a * x ) % m == 1 ) : NEW_LINE INDENT return x NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT a = 3 NEW_LINE m = 11 NEW_LINE print ( modInverse ( a , m ) ) NEW_LINE"],"bleu":0.9641422058873443,"rouge_l":0.9916395726892707}
{"id":1140,"predictions":["def countDistinctNumber ( str ) : NEW_LINE INDENT values = set ( ) NEW_LINE for i in range ( len ( str ) - 1 ) : NEW_LINE INDENT codes . add ( str [ i : i + 2 ] ) NEW_LINE DEDENT return len ( codes ) NEW_LINE DEDENT str = \" UPSP \" NEW_LINE print ( countDistinctNumber ( str ) ) NEW_LINE"],"references":["def countDistinctCode ( string ) : NEW_LINE INDENT codes = set ( ) NEW_LINE for i in range ( 0 , len ( string ) - 1 ) : NEW_LINE INDENT codes . add ( string [ i : i + 2 ] ) NEW_LINE DEDENT return len ( codes ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" UPUP \" NEW_LINE print ( countDistinctCode ( string ) ) NEW_LINE DEDENT"],"bleu":0.5122640215006413,"rouge_l":0.7522572120678265}
{"id":1141,"predictions":["def OR ( a , n ) : NEW_LINE INDENT ans = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans |= a [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT a = [ 1 , 4 , 6 ] NEW_LINE n = len ( a ) NEW_LINE print ( OR ( a , n ) ) NEW_LINE"],"references":["def OR ( a , n ) : NEW_LINE INDENT ans = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans |= a [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 4 , 6 ] NEW_LINE n = len ( a ) NEW_LINE print ( OR ( a , n ) ) NEW_LINE DEDENT"],"bleu":0.7954936086081942,"rouge_l":0.8916595012897679}
{"id":1142,"predictions":["def kthSmallest ( arr , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE return arr [ k - 1 ] NEW_LINE DEDENT arr = [ 12 , 3 , 5 , 7 , 19 ] NEW_LINE k = 2 NEW_LINE print ( \" K ' th ▁ smallest ▁ element ▁ is ▁ \" , kthSmallest ( arr , k ) ) NEW_LINE"],"references":["def kthSmallest ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE return arr [ k - 1 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 12 , 3 , 5 , 7 , 19 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE print ( \" K ' th ▁ smallest ▁ element ▁ is \" , kthSmallest ( arr , n , k ) ) NEW_LINE DEDENT"],"bleu":0.6258627381471648,"rouge_l":0.810838445807771}
{"id":1143,"predictions":["def findOddPair ( A , N ) : NEW_LINE INDENT oddPair = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( ( A [ i ] ^ A [ j ] ) % 2 != 0 ) : NEW_LINE INDENT oddPair += 1 NEW_LINE DEDENT DEDENT DEDENT return oddPair NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 5 , 4 , 7 , 2 , 1 ] NEW_LINE N = len ( A ) NEW_LINE print ( findOddPair ( A , N ) ) NEW_LINE DEDENT"],"references":["def findOddPair ( A , N ) : NEW_LINE INDENT oddPair = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( ( A [ i ] ^ A [ j ] ) % 2 != 0 ) : NEW_LINE INDENT oddPair += 1 NEW_LINE DEDENT DEDENT DEDENT return oddPair NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 5 , 4 , 7 , 2 , 1 ] NEW_LINE N = len ( A ) NEW_LINE print ( findOddPair ( A , N ) ) NEW_LINE DEDENT"],"bleu":0.969740778513838,"rouge_l":0.989840553125441}
{"id":1144,"predictions":["def ReplaceElements ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] not in mp . keys ( ) : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = n - mp [ arr [ i ] ] NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 5 , 2 , 2 , 5 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE ReplaceElements ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT"],"references":["def ReplaceElements ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] = mp . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = n - mp [ arr [ i ] ] NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 5 , 2 , 2 , 5 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE ReplaceElements ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT"],"bleu":0.7269842452114473,"rouge_l":0.8599239203401209}
{"id":1145,"predictions":["def printCombination ( arr , n , r , index , data ) : NEW_LINE INDENT if ( index == r ) : NEW_LINE INDENT for j in range ( r ) : NEW_LINE INDENT print ( data [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE return NEW_LINE DEDENT if ( i > n ) : NEW_LINE INDENT return NEW_LINE DEDENT data = arr [ index ] NEW_LINE combinationUtil ( arr , n , r , index + 1 , data , i + 1 ) NEW_LINE combinationUtil ( arr , n , r , index , data , i + 1 ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE r = 3 NEW_LINE n = len ( arr ) NEW_LINE printCombination ( arr , n , r ) NEW_LINE"],"references":["def printCombination ( arr , n , r ) : NEW_LINE INDENT data = [ 0 ] * r NEW_LINE combinationUtil ( arr , n , r , 0 , data , 0 ) NEW_LINE DEDENT def combinationUtil ( arr , n , r , index , data , i ) : NEW_LINE INDENT if ( index == r ) : NEW_LINE INDENT for j in range ( r ) : NEW_LINE INDENT print ( data [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE return NEW_LINE DEDENT if ( i >= n ) : NEW_LINE INDENT return NEW_LINE DEDENT data [ index ] = arr [ i ] NEW_LINE combinationUtil ( arr , n , r , index + 1 , data , i + 1 ) NEW_LINE combinationUtil ( arr , n , r , index , data , i + 1 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE r = 3 NEW_LINE n = len ( arr ) NEW_LINE printCombination ( arr , n , r ) NEW_LINE DEDENT"],"bleu":0.6509491012471186,"rouge_l":0.8061429092234779}
{"id":1146,"predictions":["def countPair ( a , n ) : NEW_LINE INDENT maxm = a [ 0 ] NEW_LINE prime [ 1 ] = 1 NEW_LINE for i in range ( 2 , int ( sqrt ( maxm ) ) + 1 ) : NEW_LINE INDENT if ( a [ i ] > maxm ) : NEW_LINE INDENT maxm = a [ i ] NEW_LINE DEDENT DEDENT prime = [ 0 ] * ( maxm + 1 ) NEW_LINE for i in range ( 2 , int ( sqrt ( maxm ) ) + 1 , 1 ) : NEW_LINE INDENT if ( prime [ i ] == 0 ) : NEW_LINE INDENT for j in range ( 2 * i , maxm + 1 , i ) : NEW_LINE INDENT prime [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT def countPair ( a , n ) : NEW_LINE INDENT maxm = a [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ i ] == 0 ) : NEW_LINE INDENT countPrimes += 1 NEW_LINE DEDENT DEDENT nonPrimes = n - countPrimes NEW_LINE pairswith1Prime = ( countPrimes * countPrimes ) NEW_LINE pairsWith2Primes = ( countPrimes * ( countPrimes - 1 ) ) \/\/ 2 NEW_LINE return pairswith1 + pairsWith2Primes NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 3 , 5 , 4 , 4 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPair ( arr , n ) ) NEW_LINE DEDENT"],"references":["def sieve ( maxm , prime ) : NEW_LINE INDENT prime [ 0 ] = prime [ 1 ] = 1 ; NEW_LINE i = 2 ; NEW_LINE while ( i * i <= maxm ) : NEW_LINE INDENT if ( prime [ i ] == 0 ) : NEW_LINE INDENT for j in range ( 2 * i , maxm + 1 , i ) : NEW_LINE INDENT prime [ j ] = 1 ; NEW_LINE DEDENT DEDENT i += 1 ; NEW_LINE DEDENT DEDENT def countPair ( a , n ) : NEW_LINE INDENT maxm = max ( a ) ; NEW_LINE prime = [ 0 ] * ( maxm + 1 ) ; NEW_LINE sieve ( maxm , prime ) ; NEW_LINE countPrimes = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ a [ i ] ] == 0 ) : NEW_LINE INDENT countPrimes += 1 ; NEW_LINE DEDENT DEDENT nonPrimes = n - countPrimes ; NEW_LINE pairswith1Prime = nonPrimes * countPrimes ; NEW_LINE pairsWith2Primes = ( countPrimes * ( countPrimes - 1 ) ) \/\/ 2 ; NEW_LINE return pairswith1Prime + pairsWith2Primes ; NEW_LINE DEDENT arr = [ 2 , 3 , 5 , 4 , 7 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( countPair ( arr , n ) ) ; NEW_LINE"],"bleu":0.5710160694388221,"rouge_l":0.7156379149446741}
{"id":1147,"predictions":["import math NEW_LINE def nextPerfectCube ( N ) : NEW_LINE INDENT nextN = math . ceil ( N ** ( 1 \/ 3. ) ) + 1 NEW_LINE return nextN * nextN * nextN NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 35 NEW_LINE print ( nextPerfectCube ( N ) ) NEW_LINE DEDENT"],"references":["from math import * NEW_LINE def nextPerfectCube ( N ) : NEW_LINE INDENT nextN = floor ( N ** ( 1 \/ 3 ) ) + 1 NEW_LINE return nextN ** 3 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 35 NEW_LINE print ( nextPerfectCube ( n ) ) NEW_LINE DEDENT"],"bleu":0.6839004256613785,"rouge_l":0.838544474393531}
{"id":1148,"predictions":["def reverse ( arr , n , k ) : NEW_LINE INDENT for i in range ( 0 , n , k ) : NEW_LINE INDENT left = i NEW_LINE right = min ( i + k - 1 , n - 1 ) NEW_LINE arr [ left ] = arr [ right ] NEW_LINE left += 1 NEW_LINE right -= 1 NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ] NEW_LINE k = 3 NEW_LINE n = len ( arr ) NEW_LINE reverse ( arr , n , k ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT"],"references":["def reverse ( arr , n , k ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT left = i NEW_LINE right = min ( i + k - 1 , n - 1 ) NEW_LINE while ( left < right ) : NEW_LINE INDENT arr [ left ] , arr [ right ] = arr [ right ] , arr [ left ] NEW_LINE left += 1 ; NEW_LINE right - + 1 NEW_LINE DEDENT i += k NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ] NEW_LINE k = 3 NEW_LINE n = len ( arr ) NEW_LINE reverse ( arr , n , k ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT"],"bleu":0.7195957217683433,"rouge_l":0.8449508489722967}
{"id":1149,"predictions":["def printChar ( str , n ) : NEW_LINE INDENT freq = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] % 2 == 1 ) : NEW_LINE INDENT print ( str [ i ] , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeksforgeeks \" NEW_LINE n = len ( str ) NEW_LINE printChar ( str , n ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE import math NEW_LINE def printChar ( str_ , n ) : NEW_LINE INDENT freq = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( str_ [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( freq [ ord ( str_ [ i ] ) - ord ( ' a ' ) ] ) % 2 == 1 : NEW_LINE INDENT print ( \" { } \" . format ( str_ [ i ] ) , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str_ = \" geeksforgeeks \" NEW_LINE n = len ( str_ ) NEW_LINE printChar ( str_ , n ) NEW_LINE DEDENT"],"bleu":0.7133156737139396,"rouge_l":0.8734090909090908}
{"id":1150,"predictions":["def isSafe ( x , y ) : NEW_LINE INDENT return ( x < 4 and y < 3 ) NEW_LINE DEDENT def minJump ( height , x , y ) : NEW_LINE INDENT if x == 4 and y == 3 : NEW_LINE INDENT return 0 NEW_LINE DEDENT diag = 10 ** 9 NEW_LINE if isSafe ( x + 1 , y + 1 ) : NEW_LINE INDENT diag = minJump ( height , x + 1 , y + 1 ) + abs ( height [ x ] [ y ] - height [ x + 1 ] [ y + 1 ] ) NEW_LINE DEDENT down = 10 ** 9 NEW_LINE if ( isSafe ( x + 1 , y ) ) : NEW_LINE INDENT down = minJump ( height , x + 1 , y ) + abs ( height [ x ] [ y ] - height [ x + 1 ] [ y + 1 ] ) ) NEW_LINE DEDENT right = 10 ** 9 NEW_LINE if ( isSafe ( x , y + 1 ) ) : NEW_LINE INDENT right = minJump ( height , x , y + 1 ) + abs ( height [ x ] [ y ] - height [ x + 1 ] [ y + 1 ] ) NEW_LINE DEDENT return min ( down , min ( right , diag ) ) NEW_LINE DEDENT height = [ [ 5 , 4 , 2 ] , [ 9 , 2 , 1 ] , [ 2 , 5 , 9 ] , [ 1 , 3 , 11 ] ] NEW_LINE print ( minJump ( height , 0 , 0 ) ) NEW_LINE"],"references":["R = 4 NEW_LINE C = 3 NEW_LINE def isSafe ( x , y ) : NEW_LINE INDENT return ( x < R and y < C ) NEW_LINE DEDENT def minJump ( height , x , y ) : NEW_LINE INDENT if ( x == R - 1 and y == C - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT diag = 10 ** 9 NEW_LINE if ( isSafe ( x + 1 , y + 1 ) ) : NEW_LINE INDENT diag = ( minJump ( height , x + 1 , y + 1 ) + abs ( height [ x ] [ y ] - height [ x + 1 ] [ y + 1 ] ) ) NEW_LINE DEDENT down = 10 ** 9 NEW_LINE if ( isSafe ( x + 1 , y ) ) : NEW_LINE INDENT down = ( minJump ( height , x + 1 , y ) + abs ( height [ x ] [ y ] - height [ x + 1 ] [ y ] ) ) NEW_LINE DEDENT right = 10 ** 9 NEW_LINE if ( isSafe ( x , y + 1 ) ) : NEW_LINE INDENT right = ( minJump ( height , x , y + 1 ) + abs ( height [ x ] [ y ] - height [ x ] [ y + 1 ] ) ) NEW_LINE DEDENT return min ( [ down , right , diag ] ) NEW_LINE DEDENT height = [ [ 5 , 4 , 2 ] , [ 9 , 2 , 1 ] , [ 2 , 5 , 9 ] , [ 1 , 3 , 11 ] ] NEW_LINE print ( minJump ( height , 0 , 0 ) ) NEW_LINE"],"bleu":0.842558036083274,"rouge_l":0.9305717944435165}
{"id":1151,"predictions":["def segregate ( arr , size ) : NEW_LINE INDENT j = 0 NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT if ( arr [ i ] <= 0 ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE arr [ i ] = arr [ j ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return j NEW_LINE DEDENT def findMissingPositive ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT x = abs ( arr [ i ] ) NEW_LINE if ( x - 1 < size and arr [ x - 1 ] > 0 ) : NEW_LINE INDENT arr [ x - 1 ] = - arr [ x - 1 ] NEW_LINE DEDENT DEDENT for i in range ( size ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT return size + 1 NEW_LINE DEDENT def findMissingPositive ( arr , size ) : NEW_LINE INDENT shift = segregate ( arr , size ) NEW_LINE arr2 = [ 0 for i in range ( size - shift ) ] NEW_LINE j = 0 NEW_LINE for i in range ( shift , size ) : NEW_LINE INDENT arr2 [ j ] = arr [ i ] NEW_LINE j += 1 NEW_LINE DEDENT return findMissingPositive ( arr2 , j ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 0 , 10 , 2 , - 10 , - 20 ] NEW_LINE arr_size = len ( arr ) NEW_LINE missing = findMissing ( arr , arr_size ) NEW_LINE print ( \" The ▁ smallest ▁ missing ▁ number ▁ is \" , missing ) NEW_LINE DEDENT"],"references":["def segregate ( arr , size ) : NEW_LINE INDENT j = 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT if ( arr [ i ] <= 0 ) : NEW_LINE INDENT arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return j NEW_LINE DEDENT def findMissingPositive ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT if ( abs ( arr [ i ] ) - 1 < size and arr [ abs ( arr [ i ] ) - 1 ] > 0 ) : NEW_LINE INDENT arr [ abs ( arr [ i ] ) - 1 ] = - arr [ abs ( arr [ i ] ) - 1 ] NEW_LINE DEDENT DEDENT for i in range ( size ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT return size + 1 NEW_LINE DEDENT def findMissing ( arr , size ) : NEW_LINE INDENT shift = segregate ( arr , size ) NEW_LINE return findMissingPositive ( arr [ shift : ] , size - shift ) NEW_LINE DEDENT arr = [ 0 , 10 , 2 , - 10 , - 20 ] NEW_LINE arr_size = len ( arr ) NEW_LINE missing = findMissing ( arr , arr_size ) NEW_LINE print ( \" The ▁ smallest ▁ positive ▁ missing ▁ number ▁ is ▁ \" , missing ) NEW_LINE"],"bleu":0.712307017338765,"rouge_l":0.8028177179962893}
{"id":1152,"predictions":["from __gcd NEW_LINE def minStepsNeeded ( k , d1 , d2 , x ) : NEW_LINE INDENT __gcd = __gcd ( d1 , d2 ) NEW_LINE if ( ( k - x ) % gcd != 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT gcd = [ ] NEW_LINE visited = [ ] NEW_LINE q . append ( k , 0 ) NEW_LINE visited . append ( k ) NEW_LINE while ( not ( len ( q ) ) ) : NEW_LINE INDENT s = q [ 0 ] [ 0 ] NEW_LINE stp = q [ 0 ] [ 1 ] NEW_LINE if ( s == x ) : NEW_LINE INDENT return stp NEW_LINE DEDENT q . remove ( s + dp ) NEW_LINE if ( s == x ) : NEW_LINE INDENT return stp NEW_LINE DEDENT q . remove ( s + d1 , st1 ) NEW_LINE if ( s + d1 in visited ) : NEW_LINE INDENT return stp NEW_LINE DEDENT q . remove ( s + d2 , st1 ) NEW_LINE if ( s + d1 in visited ) : NEW_LINE INDENT q . append ( ( [ s + d1 , st2 + 1 ] ) ) NEW_LINE visited . add ( s + d2 ) NEW_LINE DEDENT if ( not visited ) : NEW_LINE INDENT q . append ( [ s + d2 , st1 ] ) NEW_LINE visited . add ( s + d2 , st1 ) NEW_LINE visited . add ( s - d1 ) NEW_LINE DEDENT if ( not visited ) : NEW_LINE INDENT q . append ( [ s - d1 , st1 ] ) NEW_LINE visited . add ( s - d2 ) NEW_LINE visited . add ( s - d2 ) NEW_LINE DEDENT DEDENT return - 10 ** 9 NEW_LINE DEDENT k = 10 NEW_LINE d1 = 4 NEW_LINE d2 = 4 NEW_LINE x = 8 NEW_LINE print ( minStepsNeeded ( k , d1 , d2 ) ) NEW_LINE"],"references":["from math import gcd as __gcd NEW_LINE from collections import deque as queue NEW_LINE def minStepsNeeded ( k , d1 , d2 , x ) : NEW_LINE INDENT gcd = __gcd ( d1 , d2 ) NEW_LINE if ( ( k - x ) % gcd != 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT q = queue ( ) NEW_LINE visited = dict ( ) NEW_LINE q . appendleft ( [ k , 0 ] ) NEW_LINE visited [ k ] = 1 NEW_LINE while ( len ( q ) > 0 ) : NEW_LINE INDENT sr = q . pop ( ) NEW_LINE s , stp = sr [ 0 ] , sr [ 1 ] NEW_LINE if ( s == x ) : NEW_LINE INDENT return stp NEW_LINE DEDENT if ( s + d1 not in visited ) : NEW_LINE INDENT q . appendleft ( [ ( s + d1 ) , stp + 1 ] ) NEW_LINE visited [ ( s + d1 ) ] = 1 NEW_LINE DEDENT if ( s + d2 not in visited ) : NEW_LINE INDENT q . appendleft ( [ ( s + d2 ) , stp + 1 ] ) NEW_LINE visited [ ( s + d2 ) ] = 1 NEW_LINE DEDENT if ( s - d1 not in visited ) : NEW_LINE INDENT q . appendleft ( [ ( s - d1 ) , stp + 1 ] ) NEW_LINE visited [ ( s - d1 ) ] = 1 NEW_LINE DEDENT if ( s - d2 not in visited ) : NEW_LINE INDENT q . appendleft ( [ ( s - d2 ) , stp + 1 ] ) NEW_LINE visited [ ( s - d2 ) ] = 1 NEW_LINE DEDENT DEDENT DEDENT k = 10 NEW_LINE d1 = 4 NEW_LINE d2 = 6 NEW_LINE x = 8 NEW_LINE print ( minStepsNeeded ( k , d1 , d2 , x ) ) NEW_LINE"],"bleu":0.5263708501373472,"rouge_l":0.6913635238802277}
{"id":1153,"predictions":["def minAbsAbsSumPair ( arr , arr_size ) : NEW_LINE INDENT inv_count = 0 NEW_LINE min_r = 1 NEW_LINE min_r = arr [ 0 ] + arr [ 1 ] NEW_LINE min_r = arr [ 0 ] + arr [ 1 ] NEW_LINE for l in range ( arr_size - 1 ) : NEW_LINE INDENT for r in range ( l + 1 , arr_size ) : NEW_LINE INDENT sum = arr [ l ] + arr [ r ] NEW_LINE if ( abs ( min_sum ) > abs ( sum_sum ) ) : NEW_LINE INDENT min_sum = sum NEW_LINE min_l = l NEW_LINE min_r = r NEW_LINE DEDENT DEDENT print ( \" The ▁ two ▁ elements ▁ are \" , arr [ min_l ] , \" and \" , arr [ min_r ] ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 1 , 6 , - 1 , - 1 , 0 , 85 ] NEW_LINE minAbsSumPair ( arr , 6 ) NEW_LINE DEDENT"],"references":["def minAbsSumPair ( arr , arr_size ) : NEW_LINE INDENT inv_count = 0 NEW_LINE if arr_size < 2 : NEW_LINE INDENT print ( \" Invalid ▁ Input \" ) NEW_LINE return NEW_LINE DEDENT min_l = 0 NEW_LINE min_r = 1 NEW_LINE min_sum = arr [ 0 ] + arr [ 1 ] NEW_LINE for l in range ( 0 , arr_size - 1 ) : NEW_LINE INDENT for r in range ( l + 1 , arr_size ) : NEW_LINE INDENT sum = arr [ l ] + arr [ r ] NEW_LINE if abs ( min_sum ) > abs ( sum ) : NEW_LINE INDENT min_sum = sum NEW_LINE min_l = l NEW_LINE min_r = r NEW_LINE DEDENT DEDENT DEDENT print ( \" The ▁ two ▁ elements ▁ whose ▁ sum ▁ is ▁ minimum ▁ are \" , arr [ min_l ] , \" and ▁ \" , arr [ min_r ] ) NEW_LINE DEDENT arr = [ 1 , 60 , - 10 , 70 , - 80 , 85 ] NEW_LINE minAbsSumPair ( arr , 6 ) ; NEW_LINE"],"bleu":0.69738266319663,"rouge_l":0.7821925230269098}
{"id":1154,"predictions":["def findSubsequence ( arr , n ) : NEW_LINE INDENT Len = 1 NEW_LINE tmp = [ 0 for i in range ( 10 ) ] NEW_LINE cnt = [ 0 for i in range ( 10 ) ] NEW_LINE locMax = [ 0 for i in range ( 10 ) ] NEW_LINE locMax = arr [ 0 ] NEW_LINE tmp = arr [ 0 ] NEW_LINE while ( tmp ) : NEW_LINE INDENT dp [ tmp % 10 ] = 1 NEW_LINE tmp \/\/= 10 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT tmp = arr [ i ] NEW_LINE locMax = 1 NEW_LINE while ( tmp ) : NEW_LINE INDENT cnt [ tmp % 10 ] = 1 NEW_LINE tmp \/\/= 10 NEW_LINE DEDENT for d in range ( 10 ) : NEW_LINE INDENT if ( cnt [ d ] == 1 ) : NEW_LINE INDENT dp [ d ] += 1 NEW_LINE locMax = max ( locMax , dp [ d ] ) NEW_LINE DEDENT DEDENT for d in range ( 10 ) : NEW_LINE INDENT if ( cnt [ d ] == 1 ) : NEW_LINE INDENT dp [ d ] += 1 NEW_LINE locMax = max ( locMax , dp [ d ] ) NEW_LINE DEDENT DEDENT return len NEW_LINE DEDENT arr = [ 1 , 12 , 44 , 29 , 33 , 96 , 89 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findSubsequence ( arr , n ) ) NEW_LINE"],"references":["def findSubsequence ( arr , n ) : NEW_LINE INDENT length = 1 ; NEW_LINE dp = [ 0 ] * 10 ; NEW_LINE tmp = arr [ 0 ] ; NEW_LINE while ( tmp > 0 ) : NEW_LINE INDENT dp [ tmp % 10 ] = 1 ; NEW_LINE tmp \/\/= 10 ; NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT tmp = arr [ i ] ; NEW_LINE locMax = 1 ; NEW_LINE cnt = [ 0 ] * 10 NEW_LINE while ( tmp > 0 ) : NEW_LINE INDENT cnt [ tmp % 10 ] = 1 ; NEW_LINE tmp \/\/= 10 ; NEW_LINE DEDENT for d in range ( 10 ) : NEW_LINE INDENT if ( cnt [ d ] ) : NEW_LINE INDENT dp [ d ] += 1 ; NEW_LINE locMax = max ( locMax , dp [ d ] ) ; NEW_LINE DEDENT DEDENT for d in range ( 10 ) : NEW_LINE INDENT if ( cnt [ d ] ) : NEW_LINE INDENT dp [ d ] = locMax ; NEW_LINE DEDENT DEDENT length = max ( length , locMax ) ; NEW_LINE DEDENT return length ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 12 , 44 , 29 , 33 , 96 , 89 ] ; NEW_LINE n = len ( arr ) NEW_LINE print ( findSubsequence ( arr , n ) ) ; NEW_LINE DEDENT"],"bleu":0.6646668012183208,"rouge_l":0.7896187119512976}
{"id":1155,"predictions":["dp = [ [ [ - 1 for i in range ( 5 ) ] for j in range ( 5 ) ] for k in range ( 5 ) ] NEW_LINE def countWaysUtil ( n , part , nextPart ) : NEW_LINE INDENT if ( s == 0 and n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n <= 0 orParts <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ n ] [ nextPart ] [ nextPart ] [ 2 ] != - 1 ) : NEW_LINE INDENT return dp [ n ] [ nextPart ] [ nextPart ] [ 2 ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( nextPart , n + 1 ) : NEW_LINE INDENT ans += countWaysUtil ( n - i , partitions - 1 , i ) NEW_LINE DEDENT return dp [ n ] [ nextPart ] [ nextPart ] [ 2 ] NEW_LINE DEDENT def countWays ( n ) : NEW_LINE INDENT for i in range ( 0 , 5001 ) : NEW_LINE INDENT for j in range ( 5001 ) : NEW_LINE INDENT dp [ i ] [ j ] [ l ] = - 1 NEW_LINE DEDENT DEDENT return countWaysUtil ( n , 4 , 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 8 NEW_LINE print ( countWays ( n ) ) NEW_LINE DEDENT"],"references":["dp = [ [ [ - 1 for i in range ( 5 ) ] for i in range ( 501 ) ] for i in range ( 501 ) ] NEW_LINE def countWaysUtil ( n , parts , nextPart ) : NEW_LINE INDENT if ( parts == 0 and n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n <= 0 or parts <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ n ] [ nextPart ] [ parts ] != - 1 ) : NEW_LINE INDENT return dp [ n ] [ nextPart ] [ parts ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( nextPart , n + 1 ) : NEW_LINE INDENT ans += countWaysUtil ( n - i , parts - 1 , i ) NEW_LINE DEDENT dp [ n ] [ nextPart ] [ parts ] = ans NEW_LINE return ( ans ) NEW_LINE DEDENT def countWays ( n ) : NEW_LINE INDENT return countWaysUtil ( n , 4 , 1 ) NEW_LINE DEDENT n = 8 NEW_LINE print ( countWays ( n ) ) NEW_LINE"],"bleu":0.6277660327178889,"rouge_l":0.8096935679611652}
{"id":1156,"predictions":["import random NEW_LINE def nthRoot ( A , N ) : NEW_LINE INDENT xPre = random . randint ( 1 , 10 % 10 % 10 ) NEW_LINE eps = 1e-3 NEW_LINE delX = 10 ** 9 NEW_LINE xK = 0 NEW_LINE while ( delX > eps ) : NEW_LINE INDENT xK = ( ( N - 1.0 ) * xPre + A \/ pow ( xPre , N - 1 ) ) \/ N NEW_LINE delX = abs ( xK - xPre ) NEW_LINE xPre = xK NEW_LINE DEDENT return xK NEW_LINE DEDENT def countPowers ( a , b , k ) : NEW_LINE INDENT return ( floor ( ( nthRoot ( b , k ) ) - ceil ( nthRoot ( a , k ) ) ) + 1 ) NEW_LINE DEDENT a = 7 NEW_LINE b = 28 NEW_LINE k = 2 NEW_LINE print ( \" Count ▁ of ▁ Power ▁ is \" , countPowers ( a , b , k ) ) NEW_LINE"],"references":["import sys NEW_LINE from math import pow , ceil , floor NEW_LINE import random NEW_LINE def nthRoot ( A , N ) : NEW_LINE INDENT xPre = ( random . randint ( 0 , 9 ) ) % 10 NEW_LINE eps = 1e-3 NEW_LINE delX = sys . maxsize NEW_LINE while ( delX > eps ) : NEW_LINE INDENT xK = ( ( N - 1.0 ) * xPre + A \/ pow ( xPre , N - 1 ) ) \/ N NEW_LINE delX = abs ( xK - xPre ) NEW_LINE xPre = xK NEW_LINE DEDENT return xK NEW_LINE DEDENT def countPowers ( a , b , k ) : NEW_LINE INDENT return ( floor ( nthRoot ( b , k ) ) - ceil ( nthRoot ( a , k ) ) + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 7 NEW_LINE b = 28 NEW_LINE k = 2 NEW_LINE print ( \" Count ▁ of ▁ Powers ▁ is \" , countPowers ( a , b , k ) ) NEW_LINE DEDENT"],"bleu":0.759640443417117,"rouge_l":0.8509299781181618}
{"id":1157,"predictions":["def minSwaps ( str1 , str2 ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT if ( str1 [ i ] != str2 [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count % 2 == 0 ) : NEW_LINE INDENT print ( count \/\/ 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ Possible \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT b = \"110000\" NEW_LINE b = \"0000\" NEW_LINE minSwaps ( b , b ) NEW_LINE DEDENT"],"references":["def minSwaps ( str1 , str2 ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT if str1 [ i ] != str2 [ i ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if count % 2 == 0 : NEW_LINE INDENT print ( count \/\/ 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ Possible \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT binaryString1 = \"1110000\" NEW_LINE binaryString2 = \"0001101\" NEW_LINE minSwaps ( binaryString1 , binaryString2 ) NEW_LINE DEDENT"],"bleu":0.7966413551300435,"rouge_l":0.9296816055530406}
{"id":1158,"predictions":["def countOrderedPairs ( A , n ) : NEW_LINE INDENT o = 0 NEW_LINE m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if A [ A [ i ] ] in m . keys ( ) : NEW_LINE INDENT m [ A [ i ] ] += 1 NEW_LINE DEDENT A [ A [ i ] ] += 1 NEW_LINE DEDENT return o NEW_LINE DEDENT A = [ 1 , 1 , 2 , 2 , 3 ] NEW_LINE n = len ( A ) NEW_LINE print ( countOrderedPairs ( A , n ) ) NEW_LINE"],"references":["from collections import defaultdict NEW_LINE def countOrderedPairs ( A , n ) : NEW_LINE INDENT orderedPairs = 0 NEW_LINE m = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT m [ A [ i ] ] += 1 NEW_LINE DEDENT for X , Y in m . items ( ) : NEW_LINE INDENT for j in range ( 1 , Y + 1 ) : NEW_LINE INDENT if m [ j ] >= X : NEW_LINE INDENT orderedPairs += 1 NEW_LINE DEDENT DEDENT DEDENT return orderedPairs NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 1 , 1 , 2 , 2 , 3 ] NEW_LINE n = len ( A ) NEW_LINE print ( countOrderedPairs ( A , n ) ) NEW_LINE DEDENT"],"bleu":0.47451564800308954,"rouge_l":0.658273381294964}
{"id":1159,"predictions":["def makeAP ( arr , n ) : NEW_LINE INDENT if ( n == 3 ) : NEW_LINE INDENT common_difference = arr [ 2 ] - arr [ 1 ] NEW_LINE initial_term = arr [ 1 ] - common_difference NEW_LINE DEDENT elif ( ( arr [ 1 ] - arr [ 0 ] ) == arr [ 2 ] ) : NEW_LINE INDENT original_term = arr [ 0 ] NEW_LINE common_difference = arr [ 1 ] - arr [ 0 ] NEW_LINE DEDENT elif ( ( arr [ 2 ] - arr [ 1 ] ) == arr [ 2 ] ) : NEW_LINE INDENT common_difference = arr [ 2 ] - arr [ 1 ] NEW_LINE initial_term = arr [ 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT common_difference = ( arr [ 3 ] - arr [ 0 ] ) \/\/ 3 NEW_LINE initial_term = arr [ 0 ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( initial_term + ( i * common_difference ) , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT arr = [ 1 , 3 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE makeAP ( arr , n ) NEW_LINE"],"references":["def makeAP ( arr , n ) : NEW_LINE INDENT initial_term , common_difference = 0 , 0 NEW_LINE if ( n == 3 ) : NEW_LINE INDENT common_difference = arr [ 2 ] - arr [ 1 ] NEW_LINE initial_term = arr [ 1 ] - common_difference NEW_LINE DEDENT elif ( ( arr [ 1 ] - arr [ 0 ] ) == arr [ 2 ] - arr [ 1 ] ) : NEW_LINE INDENT initial_term = arr [ 0 ] NEW_LINE common_difference = arr [ 1 ] - arr [ 0 ] NEW_LINE DEDENT elif ( ( arr [ 2 ] - arr [ 1 ] ) == ( arr [ 3 ] - arr [ 2 ] ) ) : NEW_LINE INDENT common_difference = arr [ 2 ] - arr [ 1 ] NEW_LINE initial_term = arr [ 1 ] - common_difference NEW_LINE DEDENT else : NEW_LINE INDENT common_difference = ( arr [ 3 ] - arr [ 0 ] ) \/ 3 NEW_LINE initial_term = arr [ 0 ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( int ( initial_term + ( i * common_difference ) ) , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT arr = [ 1 , 3 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE makeAP ( arr , n ) NEW_LINE"],"bleu":0.8337447531677249,"rouge_l":0.9254558716265497}
{"id":1160,"predictions":["def countIncreasing ( arr , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE len = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( arr [ i + 1 ] > arr [ i ] ) : NEW_LINE INDENT len += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += ( ( ( len - 1 ) * len ) \/ 2 ) NEW_LINE len = 1 NEW_LINE DEDENT DEDENT if ( len > 1 ) : NEW_LINE INDENT cnt += ( ( ( len - 1 ) * len ) \/ 2 ) NEW_LINE DEDENT return cnt NEW_LINE DEDENT arr = [ 1 , 2 , 2 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Count ▁ of ▁ surprise ▁ increasing ▁ is ▁ \" , countIncreasing ( arr , n ) ) NEW_LINE"],"references":["def countIncreasing ( arr , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE len = 1 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if arr [ i + 1 ] > arr [ i ] : NEW_LINE INDENT len += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += ( ( ( len - 1 ) * len ) \/ 2 ) NEW_LINE len = 1 NEW_LINE DEDENT DEDENT if len > 1 : NEW_LINE INDENT cnt += ( ( ( len - 1 ) * len ) \/ 2 ) NEW_LINE DEDENT return cnt NEW_LINE DEDENT arr = [ 1 , 2 , 2 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Count ▁ of ▁ strictly ▁ increasing ▁ subarrays ▁ is \" , int ( countIncreasing ( arr , n ) ) ) NEW_LINE"],"bleu":0.8663025983926678,"rouge_l":0.9525048796356539}
{"id":1161,"predictions":["def harmonicMean ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + 1 \/ arr [ i ] NEW_LINE DEDENT return n \/ sum NEW_LINE DEDENT arr = [ 13.5 , 14.5 , 14 , 15 , 15 , 16 ] NEW_LINE n = len ( arr ) NEW_LINE print ( harmonicMean ( arr , n ) ) NEW_LINE"],"references":["def harmonicMean ( arr , n ) : NEW_LINE INDENT sm = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sm = sm + ( 1 ) \/ arr [ i ] ; NEW_LINE DEDENT return n \/ sm NEW_LINE DEDENT arr = [ 13.5 , 14.5 , 14.8 , 15.2 , 16.1 ] ; NEW_LINE n = len ( arr ) NEW_LINE print ( harmonicMean ( arr , n ) ) NEW_LINE"],"bleu":0.652372129903716,"rouge_l":0.8531468531468531}
{"id":1162,"predictions":["def asPowerSum ( w , m ) : NEW_LINE INDENT while ( m > 0 ) : NEW_LINE INDENT if ( ( m - 1 ) % w == 0 ) : NEW_LINE INDENT m = ( m - 1 ) \/\/ w NEW_LINE DEDENT elif ( ( m + 1 ) % w == 0 ) : NEW_LINE INDENT m = ( m + 1 ) \/\/ w NEW_LINE DEDENT elif ( m % w == 0 ) : NEW_LINE INDENT m = ( m + 1 ) \/\/ w NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return ( m == 0 ) NEW_LINE DEDENT w = 3 NEW_LINE m = 7 NEW_LINE if ( asPowerSum ( w , m ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def asPowerSum ( w , m ) : NEW_LINE INDENT while ( m > 0 ) : NEW_LINE INDENT if ( ( m - 1 ) % w == 0 ) : NEW_LINE INDENT m = ( m - 1 ) \/ w ; NEW_LINE DEDENT elif ( ( m + 1 ) % w == 0 ) : NEW_LINE INDENT m = ( m + 1 ) \/ w ; NEW_LINE DEDENT elif ( m % w == 0 ) : NEW_LINE INDENT m = m \/ w ; NEW_LINE DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT return ( m == 0 ) ; NEW_LINE DEDENT w = 3 ; NEW_LINE m = 7 ; NEW_LINE if ( asPowerSum ( w , m ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT"],"bleu":0.8117617130318904,"rouge_l":0.9345128924371562}
{"id":1163,"predictions":["def result ( n , k , t ) : NEW_LINE INDENT if ( t <= k ) : NEW_LINE INDENT print ( t ) NEW_LINE DEDENT elif ( t <= n ) : NEW_LINE INDENT print ( k ) NEW_LINE DEDENT else : NEW_LINE INDENT temp = t - n NEW_LINE temp = k - temp NEW_LINE print ( temp ) NEW_LINE DEDENT DEDENT n = 10 NEW_LINE k = 5 NEW_LINE t = 12 NEW_LINE result ( n , k , t ) NEW_LINE"],"references":["def result ( n , k , t ) : NEW_LINE INDENT if ( t <= k ) : NEW_LINE INDENT print ( t ) NEW_LINE DEDENT elif ( t <= n ) : NEW_LINE INDENT print ( k ) NEW_LINE DEDENT else : NEW_LINE INDENT temp = t - n NEW_LINE temp = k - temp NEW_LINE print ( temp ) NEW_LINE DEDENT DEDENT n = 10 NEW_LINE k = 5 NEW_LINE t = 12 NEW_LINE result ( n , k , t ) NEW_LINE"],"bleu":1.0,"rouge_l":1.0}
{"id":1164,"predictions":["import math NEW_LINE table = [ - 1 for i in range ( 2 ) ] NEW_LINE table = [ [ - 1 for i in range ( height + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE def preprocess ( ) : NEW_LINE INDENT table [ i ] [ 0 ] = - 1 NEW_LINE table = [ [ 0 for i in range ( height + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE DEDENT def calculateSparse ( ) : NEW_LINE INDENT table [ v ] [ 0 ] = u NEW_LINE for i in range ( 1 , height + 1 ) : NEW_LINE INDENT table [ v ] [ i ] = table [ table [ v ] [ i - 1 ] ] ] NEW_LINE if table [ v ] [ i ] == - 1 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT def kthent ( V , k ) : NEW_LINE INDENT for i in range ( height + 1 ) : NEW_LINE INDENT if ( k & ( 1 << i ) ) != 0 ) : NEW_LINE INDENT V = table [ V ] [ i ] NEW_LINE if ( V == - 1 ) : NEW_LINE INDENT V = table [ V ] [ i ] NEW_LINE if ( V == - 1 ) : NEW_LINE INDENT V = table [ V ] [ i ] NEW_LINE if ( V == - 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT DEDENT return V NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 6 NEW_LINE preprocess ( ) NEW_LINE calculateSparse ( ) NEW_LINE calculateSparse ( 1 , 2 ) NEW_LINE calculateSparse ( 1 , 3 ) NEW_LINE calculateSparse ( 2 , 5 ) NEW_LINE calculateSparse ( 3 , 6 ) NEW_LINE K = 5 NEW_LINE print ( kthentor ( V , K ) ) NEW_LINE DEDENT"],"references":["import math NEW_LINE class GfG : NEW_LINE INDENT def __init__ ( self , n ) : NEW_LINE INDENT self . height = int ( math . ceil ( math . log10 ( n ) \/ math . log10 ( 2 ) ) ) NEW_LINE self . table = [ 0 ] * ( n + 1 ) NEW_LINE DEDENT def preprocessing ( self ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i < len ( self . table ) ) : NEW_LINE INDENT self . table [ i ] = [ - 1 ] * ( self . height + 1 ) NEW_LINE i = i + 1 NEW_LINE DEDENT DEDENT def calculateSparse ( self , u , v ) : NEW_LINE INDENT self . table [ v ] [ 0 ] = u NEW_LINE i = 1 NEW_LINE while ( i <= self . height ) : NEW_LINE INDENT self . table [ v ] [ i ] = self . table [ self . table [ v ] [ i - 1 ] ] [ i - 1 ] NEW_LINE if ( self . table [ v ] [ i ] == - 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT DEDENT def kthancestor ( self , V , k ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i <= self . height ) : NEW_LINE INDENT if ( ( k & ( 1 << i ) ) != 0 ) : NEW_LINE INDENT V = self . table [ V ] [ i ] NEW_LINE if ( V == - 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT i = i + 1 NEW_LINE DEDENT return V NEW_LINE DEDENT DEDENT n = 6 NEW_LINE obj = GfG ( n ) NEW_LINE obj . preprocessing ( ) NEW_LINE obj . calculateSparse ( 1 , 2 ) NEW_LINE obj . calculateSparse ( 1 , 3 ) NEW_LINE obj . calculateSparse ( 2 , 4 ) NEW_LINE obj . calculateSparse ( 2 , 5 ) NEW_LINE obj . calculateSparse ( 3 , 6 ) NEW_LINE K = 2 NEW_LINE V = 5 NEW_LINE print ( obj . kthancestor ( V , K ) ) NEW_LINE"],"bleu":0.45460405817218635,"rouge_l":0.6045369823157702}
{"id":1165,"predictions":["def factors ( n , i ) : NEW_LINE INDENT if ( i <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT factors ( n , i + 1 ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 10 NEW_LINE factors ( N , 1 ) NEW_LINE factors ( N , 1 ) NEW_LINE DEDENT"],"references":["def factors ( n , i ) : NEW_LINE INDENT if ( i <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) ; NEW_LINE DEDENT factors ( n , i + 1 ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 16 ; NEW_LINE factors ( N , 1 ) ; NEW_LINE DEDENT"],"bleu":0.773111104096282,"rouge_l":0.9011227102619658}
{"id":1166,"predictions":["def sumKRepeating ( arr , n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ arr [ i ] not in mp . keys ( ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT DEDENT for x in mp : NEW_LINE INDENT if ( mp [ x ] == k ) : NEW_LINE INDENT sum += x NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT arr = [ 9 , 9 , 10 , 11 , 8 , 8 , 8 , 9 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE print ( sumKRepeating ( arr , n , k ) ) NEW_LINE"],"references":["import math as mt NEW_LINE def sumKRepeating ( arr , n , k ) : NEW_LINE INDENT Sum = 0 NEW_LINE mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in mp . keys ( ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT for x in mp : NEW_LINE INDENT if ( mp [ x ] == k ) : NEW_LINE INDENT Sum += x NEW_LINE DEDENT DEDENT return Sum NEW_LINE DEDENT arr = [ 9 , 9 , 10 , 11 , 8 , 8 , 9 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE print ( sumKRepeating ( arr , n , k ) ) NEW_LINE"],"bleu":0.8089235350094228,"rouge_l":0.8828490028490028}
{"id":1167,"predictions":["def power ( num , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT elif ( n % 2 == 0 ) : NEW_LINE INDENT return power ( num , n \/\/ 2 ) * power ( num , n \/\/ 2 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return num * power ( num , n \/\/ 2 ) * power ( num , n \/\/ 2 ) ; NEW_LINE DEDENT DEDENT def checkRecursive ( x , n , curr_sum ) : NEW_LINE INDENT solutions = 0 ; NEW_LINE p = power ( curr_num , n ) ; NEW_LINE while ( p + curr_sum < x ) : NEW_LINE INDENT solutions += checkRecursive ( x , n , curr_num + 1 , p + curr_sum ) ; NEW_LINE curr_num += 1 ; NEW_LINE p = power ( curr_num , n ) ; NEW_LINE DEDENT if ( p + curr_sum == x ) : NEW_LINE INDENT solutions += 1 ; NEW_LINE DEDENT return solutions ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = 10 ; n = 2 ; NEW_LINE print ( checkRecursive ( x , n , 1 , 0 ) ) ; NEW_LINE DEDENT"],"references":["def power ( num , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( n % 2 == 0 ) : NEW_LINE INDENT return power ( num , n \/\/ 2 ) * power ( num , n \/\/ 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return num * power ( num , n \/\/ 2 ) * power ( num , n \/\/ 2 ) NEW_LINE DEDENT DEDENT def checkRecursive ( x , n , curr_num = 1 , curr_sum = 0 ) : NEW_LINE INDENT results = 0 NEW_LINE p = power ( curr_num , n ) NEW_LINE while ( p + curr_sum < x ) : NEW_LINE INDENT results += checkRecursive ( x , n , curr_num + 1 , p + curr_sum ) NEW_LINE curr_num = curr_num + 1 NEW_LINE p = power ( curr_num , n ) NEW_LINE DEDENT if ( p + curr_sum == x ) : NEW_LINE INDENT results = results + 1 NEW_LINE DEDENT return results NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 10 NEW_LINE n = 2 NEW_LINE print ( checkRecursive ( x , n ) ) NEW_LINE DEDENT"],"bleu":0.7450901332387936,"rouge_l":0.8989969135802469}
{"id":1168,"predictions":["def nCr ( n , r ) : NEW_LINE INDENT fac = [ 0 for i in range ( 100 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT fac [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fac [ i ] = fac [ i - 1 ] * i NEW_LINE DEDENT ans = fac [ n ] \/ ( fac [ n - r ] * fac [ r ] ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE k = 3 NEW_LINE ans = nCr ( n + k - 1 , k ) + nCr ( k - 1 , n - 1 ) NEW_LINE print ( ans ) NEW_LINE DEDENT"],"references":["def nCr ( n , r ) : NEW_LINE INDENT fac = list ( ) NEW_LINE fac . append ( 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fac . append ( fac [ i - 1 ] * i ) NEW_LINE DEDENT ans = fac [ n ] \/ ( fac [ n - r ] * fac [ r ] ) NEW_LINE return ans NEW_LINE DEDENT n = 3 NEW_LINE k = 3 NEW_LINE ans = nCr ( n + k - 1 , k ) + nCr ( k - 1 , n - 1 ) NEW_LINE print ( ans ) NEW_LINE"],"bleu":0.6541015007476402,"rouge_l":0.8260252772762445}
{"id":1169,"predictions":["def pairORSum ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT ans += arr [ i ] ^ arr [ j ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 5 , 9 , 7 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( pairORSum ( arr , n ) ) NEW_LINE"],"references":["def pairORSum ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT ans = ans + ( arr [ i ] ^ arr [ j ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 5 , 9 , 7 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( pairORSum ( arr , n ) ) NEW_LINE"],"bleu":0.9102216312976305,"rouge_l":0.9623922216107137}
{"id":1170,"predictions":["def alphabetPattern ( N ) : NEW_LINE INDENT top = 1 NEW_LINE Of = 1 NEW_LINE Diagonal = N - 1 NEW_LINE for index in range ( N ) : NEW_LINE INDENT print ( First , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE for index in range ( 1 , N - 1 ) : NEW_LINE INDENT for side_index in range ( 0 , 2 * ( N - index - 1 ) ) : NEW_LINE INDENT print ( \" ▁ \" , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT for index in range ( 1 , N - 1 ) : NEW_LINE INDENT for side_index in range ( 0 , N - index ) : NEW_LINE INDENT print ( \" ▁ \" , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 5 NEW_LINE alphabetPattern ( N ) NEW_LINE DEDENT"],"references":["def alphabetPattern ( N ) : NEW_LINE INDENT Top , Bottom , Diagonal = 1 , 1 , N - 1 NEW_LINE for index in range ( N ) : NEW_LINE INDENT print ( Top , end = ' ▁ ' ) NEW_LINE Top += 1 NEW_LINE DEDENT print ( ) NEW_LINE for index in range ( 1 , N - 1 ) : NEW_LINE INDENT for side_index in range ( 2 * ( N - index - 1 ) ) : NEW_LINE INDENT print ( ' ▁ ' , end = ' ' ) NEW_LINE DEDENT print ( Diagonal , end = ' ' ) NEW_LINE Diagonal -= 1 NEW_LINE print ( ) NEW_LINE DEDENT for index in range ( N ) : NEW_LINE INDENT print ( Bottom , end = ' ▁ ' ) NEW_LINE Bottom += 1 NEW_LINE DEDENT DEDENT N = 5 NEW_LINE alphabetPattern ( N ) NEW_LINE"],"bleu":0.5637999189601117,"rouge_l":0.7152849207981896}
{"id":1171,"predictions":["def areElementsContiguous ( arr , n ) : NEW_LINE INDENT us = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT us . add ( arr [ i ] ) NEW_LINE DEDENT count = 1 NEW_LINE curr_ele = arr [ 0 ] - 1 NEW_LINE while ( curr_ele in us ) : NEW_LINE INDENT count += 1 NEW_LINE curr_ele -= 1 NEW_LINE DEDENT curr_ele = arr [ 0 ] + 1 NEW_LINE while ( us ) : NEW_LINE INDENT count += 1 NEW_LINE curr_ele += 1 NEW_LINE DEDENT return ( count == ( len ( us ) ) ) NEW_LINE DEDENT arr = [ 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE if ( areElementsContiguous ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def areElementsContiguous ( arr ) : NEW_LINE INDENT us = set ( ) NEW_LINE for i in arr : us . add ( i ) NEW_LINE count = 1 NEW_LINE curr_ele = arr [ 0 ] - 1 NEW_LINE while curr_ele in us : NEW_LINE INDENT count += 1 NEW_LINE curr_ele -= 1 NEW_LINE DEDENT curr_ele = arr [ 0 ] + 1 NEW_LINE while curr_ele in us : NEW_LINE INDENT count += 1 NEW_LINE curr_ele += 1 NEW_LINE DEDENT return ( count == len ( us ) ) NEW_LINE DEDENT arr = [ 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 ] NEW_LINE if areElementsContiguous ( arr ) : print ( \" Yes \" ) NEW_LINE else : print ( \" No \" ) NEW_LINE"],"bleu":0.651691242396843,"rouge_l":0.8897116571300349}
{"id":1172,"predictions":["def flotBinarySearch ( arr , n , key ) : NEW_LINE INDENT pivot = findPivot ( arr , 0 , n - 1 ) NEW_LINE if ( pivot == - 1 ) : NEW_LINE INDENT return binarySearch ( arr , 0 , n - 1 , key ) NEW_LINE DEDENT if ( arr [ 0 ] <= key ) : NEW_LINE INDENT return binarySearch ( arr , 0 , pivot - 1 , key ) NEW_LINE DEDENT return binarySearch ( arr , pivot + 1 , n - 1 , key ) NEW_LINE DEDENT def findPivot ( arr , low , high ) : NEW_LINE INDENT if ( high < low ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( high == low ) : NEW_LINE INDENT return low NEW_LINE DEDENT mid = ( low + high ) \/\/ 2 NEW_LINE if ( mid < high and arr [ mid ] < arr [ mid ] ) : NEW_LINE INDENT return ( mid - 1 ) NEW_LINE DEDENT if ( mid > low and arr [ mid ] < arr [ mid ] ) : NEW_LINE INDENT return ( mid - 1 ) NEW_LINE DEDENT if ( arr [ low ] >= arr [ mid ] ) : NEW_LINE INDENT return findPivot ( arr , low , mid - 1 ) NEW_LINE DEDENT return findPivot ( arr , mid + 1 , high ) NEW_LINE DEDENT def binarySearch ( arr , low , low , high , key ) : NEW_LINE INDENT if ( high < low ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( low + high ) \/\/ 2 NEW_LINE if ( key == arr [ mid ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( key == arr [ mid ] ) : NEW_LINE INDENT return binarySearch ( arr , ( mid + 1 ) , high , key ) ) NEW_LINE DEDENT return binarySearch ( arr , low , ( mid - 1 ) , key ) NEW_LINE DEDENT arr1 = [ 5 , 6 , 7 , 8 , 10 , 1 , 2 , 3 ] NEW_LINE n = len ( arr1 ) NEW_LINE key = 3 NEW_LINE print ( \" Index �"],"references":["def pivotedBinarySearch ( arr , n , key ) : NEW_LINE INDENT pivot = findPivot ( arr , 0 , n - 1 ) ; NEW_LINE if pivot == - 1 : NEW_LINE INDENT return binarySearch ( arr , 0 , n - 1 , key ) ; NEW_LINE DEDENT if arr [ pivot ] == key : NEW_LINE INDENT return pivot NEW_LINE DEDENT if arr [ 0 ] <= key : NEW_LINE INDENT return binarySearch ( arr , 0 , pivot - 1 , key ) ; NEW_LINE DEDENT return binarySearch ( arr , pivot + 1 , n - 1 , key ) ; NEW_LINE DEDENT def findPivot ( arr , low , high ) : NEW_LINE INDENT if high < low : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if high == low : NEW_LINE INDENT return low NEW_LINE DEDENT mid = int ( ( low + high ) \/ 2 ) NEW_LINE if mid < high and arr [ mid ] > arr [ mid + 1 ] : NEW_LINE INDENT return mid NEW_LINE DEDENT if mid > low and arr [ mid ] < arr [ mid - 1 ] : NEW_LINE INDENT return ( mid - 1 ) NEW_LINE DEDENT if arr [ low ] >= arr [ mid ] : NEW_LINE INDENT return findPivot ( arr , low , mid - 1 ) NEW_LINE DEDENT return findPivot ( arr , mid + 1 , high ) NEW_LINE DEDENT def binarySearch ( arr , low , high , key ) : NEW_LINE INDENT if high < low : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = int ( ( low + high ) \/ 2 ) NEW_LINE if key == arr [ mid ] : NEW_LINE INDENT return mid NEW_LINE DEDENT if key > arr [ mid ] : NEW_LINE INDENT return binarySearch ( arr , ( mid + 1 ) , high , key ) ; NEW_LINE DEDENT return binarySearch ( arr , low , ( mid - 1 ) , key ) ; NEW_LINE DEDENT arr1 = [ 5 , 6 , 7 , 8 , 9 , 10 , 1 , 2 , 3 ] NEW_LINE n = len ( arr1 ) NEW_LINE key = 3 NEW_LINE print ( \" Index ▁ of ▁ the ▁ element ▁ is ▁ : ▁ \" , pivotedBinarySearch ( arr1 , n , key ) ) NEW_LINE"],"bleu":0.7249729105232494,"rouge_l":0.8754641411823606}
{"id":1173,"predictions":["def findDandZeroes ( a , b , n ) : NEW_LINE INDENT mpp = dict ( ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( b [ i ] != 0 and a [ i ] != 0 ) : NEW_LINE INDENT val = ( - 1.0 * b [ i ] ) \/ ( a [ i ] ) NEW_LINE if ( val in mpp . keys ( ) ) : NEW_LINE INDENT val += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mpp [ val ] = 1 NEW_LINE DEDENT DEDENT elif ( b [ i ] == 0 and a [ i ] == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT maxi = 0 NEW_LINE for key , value in mpp . items ( ) : NEW_LINE INDENT maxi = max ( value , maxi ) NEW_LINE DEDENT for key , value in mpp . items ( ) : NEW_LINE INDENT if ( value == maxi ) : NEW_LINE INDENT print ( \" Value ▁ of ▁ d ▁ is : \" , value [ value ] ) NEW_LINE break NEW_LINE DEDENT DEDENT print ( \" The ▁ number ▁ of ▁ zeros ▁ in ▁ array ▁ is : ▁ \" , ( maxi + count ) ) NEW_LINE DEDENT a = [ 3 , 2 , 3 , 39 ] NEW_LINE n = len ( a ) NEW_LINE findDandZeroes ( a , b , n ) NEW_LINE"],"references":["def findDandZeros ( a , b , n ) : NEW_LINE INDENT mpp = { } ; NEW_LINE count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( b [ i ] != 0 and a [ i ] != 0 ) : NEW_LINE INDENT val = ( - 1.0 * b [ i ] ) \/ a [ i ] ; NEW_LINE if val not in mpp : NEW_LINE INDENT mpp [ val ] = 0 ; NEW_LINE DEDENT mpp [ val ] += 1 ; NEW_LINE DEDENT elif ( b [ i ] == 0 and a [ i ] == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT maxi = 0 ; NEW_LINE for item in mpp : NEW_LINE INDENT maxi = max ( mpp [ item ] , maxi ) ; NEW_LINE DEDENT for keys , values in mpp . items ( ) : NEW_LINE INDENT if ( values == maxi ) : NEW_LINE INDENT print ( \" Value ▁ of ▁ d ▁ is : \" , keys ) ; NEW_LINE break ; NEW_LINE DEDENT DEDENT print ( \" The ▁ number ▁ of ▁ zeros ▁ in ▁ array ▁ C ▁ is : \" , maxi + count ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 13 , 37 , 39 ] ; NEW_LINE b = [ 1 , 2 , 3 ] ; NEW_LINE n = len ( a ) ; NEW_LINE findDandZeros ( a , b , n ) ; NEW_LINE DEDENT"],"bleu":0.6213797627024746,"rouge_l":0.7975823362526213}
{"id":1174,"predictions":["def count_odd_even_pair ( n , a ) : NEW_LINE INDENT odd = 0 NEW_LINE even = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] % 2 == 0 ) : NEW_LINE INDENT even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT ans = odd * even * 2 NEW_LINE return ans NEW_LINE DEDENT def count_even_pair ( odd_sum_pairs , n ) : NEW_LINE INDENT total_pairs = ( n * ( n - 1 ) ) NEW_LINE ans = total_pairs - odd_sum_pairs NEW_LINE return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 6 NEW_LINE a = [ 2 , 4 , 5 , 9 , 1 , 8 ] NEW_LINE odd_sum_pairs = count_even_pair ( n , a ) NEW_LINE even_sum_pairs = count_even_pair ( odd_sum_pairs , n ) NEW_LINE print ( \" Even ▁ Sum ▁ = ▁ \" , even_sum_pairs ) NEW_LINE print ( \" Odd ▁ Sum ▁ = ▁ \" , odd_sum_pairs ) NEW_LINE DEDENT"],"references":["def count_odd_pair ( n , a ) : NEW_LINE INDENT odd = 0 NEW_LINE even = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( a [ i ] % 2 == 0 ) : NEW_LINE INDENT even = even + 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd = odd + 1 NEW_LINE DEDENT DEDENT ans = odd * even * 2 NEW_LINE return ans NEW_LINE DEDENT def count_even_pair ( odd_sum_pairs , n ) : NEW_LINE INDENT total_pairs = ( n * ( n - 1 ) ) NEW_LINE ans = total_pairs - odd_sum_pairs NEW_LINE return ans NEW_LINE DEDENT n = 6 NEW_LINE a = [ 2 , 4 , 5 , 9 , 1 , 8 ] NEW_LINE odd_sum_pairs = count_odd_pair ( n , a ) NEW_LINE even_sum_pairs = count_even_pair ( odd_sum_pairs , n ) NEW_LINE print ( \" Even ▁ Sum ▁ Pairs ▁ = \" , even_sum_pairs ) NEW_LINE print ( \" Odd ▁ Sum ▁ Pairs = \" , odd_sum_pairs ) NEW_LINE"],"bleu":0.8193253172968293,"rouge_l":0.9102789878580034}
{"id":1175,"predictions":["def printQueries ( n , a , q , qy ) : NEW_LINE INDENT occ = set ( ) NEW_LINE suffixCount = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT occ [ a [ i ] ] = 1 NEW_LINE suffixCount [ i + 1 ] = len ( occ ) NEW_LINE DEDENT for i in range ( q ) : NEW_LINE INDENT print ( suffixCount [ qy [ i ] ] ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 NEW_LINE q = 3 NEW_LINE a = [ 2 , 4 , 6 , 10 , 2 ] NEW_LINE qnt = [ 1 , 3 , 2 ] NEW_LINE printQueries ( n , a , q , q , qry ) NEW_LINE DEDENT"],"references":["def printQueries ( n , a , q , qry ) : NEW_LINE INDENT occ = dict ( ) NEW_LINE suffixCount = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT occ [ a [ i ] ] = 1 NEW_LINE suffixCount [ i + 1 ] = len ( occ ) NEW_LINE DEDENT for i in range ( q ) : NEW_LINE INDENT print ( suffixCount [ qry [ i ] ] ) NEW_LINE DEDENT DEDENT n = 5 NEW_LINE q = 3 NEW_LINE a = [ 2 , 4 , 6 , 10 , 2 ] NEW_LINE qry = [ 1 , 3 , 2 ] NEW_LINE printQueries ( n , a , q , qry ) NEW_LINE"],"bleu":0.789001155928885,"rouge_l":0.9027484143763213}
{"id":1176,"predictions":["def countRotations ( n ) : NEW_LINE INDENT l = len ( n ) NEW_LINE if ( l == 1 ) : NEW_LINE INDENT oneDigit = ord ( n [ 0 ] ) - ord ( '0' ) NEW_LINE if ( oneDigit % 4 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT twoDigit = 0 NEW_LINE count = 0 NEW_LINE for i in range ( 0 , ( l - 1 ) ) : NEW_LINE INDENT twoDigit = ( ( n [ i ] ) - ord ( '0' ) ) * 10 + ( ord ( n [ i + 1 ] ) - ord ( '0' ) ) ) NEW_LINE if ( twoDigit % 4 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT twoDigit = ( ( ord ( n [ l - 1 ] ) - ord ( '0' ) ) * 10 + ( ord ( n [ 0 ] ) - ord ( '0' ) ) ) NEW_LINE if ( twoDigit % 4 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT n = \"4834\" NEW_LINE print ( \" Rotations : \" , countRotations ( n ) ) NEW_LINE"],"references":["def countRotations ( n ) : NEW_LINE INDENT l = len ( n ) NEW_LINE if ( l == 1 ) : NEW_LINE INDENT oneDigit = ( int ) ( n [ 0 ] ) NEW_LINE if ( oneDigit % 4 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 0 , l - 1 ) : NEW_LINE INDENT twoDigit = ( int ) ( n [ i ] ) * 10 + ( int ) ( n [ i + 1 ] ) NEW_LINE if ( twoDigit % 4 == 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT twoDigit = ( int ) ( n [ l - 1 ] ) * 10 + ( int ) ( n [ 0 ] ) NEW_LINE if ( twoDigit % 4 == 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT n = \"4834\" NEW_LINE print ( \" Rotations : ▁ \" , countRotations ( n ) ) NEW_LINE"],"bleu":0.6991724008538404,"rouge_l":0.8527876031665825}
{"id":1177,"predictions":["def smallestX ( n ) : NEW_LINE INDENT temp = [ None ] * 10 NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT count = 0 NEW_LINE x = 0 NEW_LINE while ( count < 10 ) : NEW_LINE INDENT y = x * n NEW_LINE while ( y % 10 ) : NEW_LINE INDENT if ( temp [ y % 10 ] == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE temp [ y % 10 ] = 1 NEW_LINE DEDENT y \/\/= 10 NEW_LINE DEDENT DEDENT return x - 1 NEW_LINE DEDENT n = 5 NEW_LINE print ( smallestX ( n ) ) NEW_LINE"],"references":["def smallestX ( n ) : NEW_LINE INDENT temp = [ 0 ] * 10 NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT count = 0 NEW_LINE x = 1 NEW_LINE while ( count < 10 ) : NEW_LINE INDENT y = x * n NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( temp [ y % 10 ] == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE temp [ y % 10 ] = 1 NEW_LINE DEDENT y = int ( y \/ 10 ) NEW_LINE DEDENT x += 1 NEW_LINE DEDENT return x - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( smallestX ( n ) ) NEW_LINE DEDENT"],"bleu":0.7140405040161945,"rouge_l":0.8544076072988949}
{"id":1178,"predictions":["def distinctAdjacentElement ( a , n ) : NEW_LINE INDENT m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT m [ a [ i ] ] = m [ a [ i ] ] + 1 NEW_LINE DEDENT mx = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( mx < m [ a [ i ] ] ) : NEW_LINE INDENT mx = m [ a [ i ] ] NEW_LINE DEDENT DEDENT if ( mx > ( n + 1 ) \/ 2 ) : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT DEDENT a = [ 7 , 7 , 7 , 7 ] NEW_LINE n = 4 NEW_LINE distinctAdjacentElement ( a , n ) NEW_LINE"],"references":["def distantAdjacentElement ( a , n ) : NEW_LINE INDENT m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] in m : NEW_LINE INDENT m [ a [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ a [ i ] ] = 1 NEW_LINE DEDENT DEDENT mx = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if mx < m [ a [ i ] ] : NEW_LINE INDENT mx = m [ a [ i ] ] NEW_LINE DEDENT DEDENT if mx > ( n + 1 ) \/\/ 2 : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 7 , 7 , 7 , 7 ] NEW_LINE n = len ( a ) NEW_LINE distantAdjacentElement ( a , n ) NEW_LINE DEDENT"],"bleu":0.6725877856780437,"rouge_l":0.8267242244754542}
{"id":1179,"predictions":["def fnMod ( n ) : NEW_LINE INDENT rem = n % 4 NEW_LINE if ( rem == 0 or rem == 3 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( rem == 1 or rem == 2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT n = 6 NEW_LINE print ( fnMod ( n ) ) NEW_LINE"],"references":["def fnMod ( n ) : NEW_LINE INDENT rem = n % 4 NEW_LINE if ( rem == 0 or rem == 3 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( rem == 1 or rem == 2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 6 NEW_LINE print ( fnMod ( n ) ) NEW_LINE DEDENT"],"bleu":0.7781827145636676,"rouge_l":0.8653488372093022}
{"id":1180,"predictions":["def isRectangle ( a , b , c , d ) : NEW_LINE INDENT if ( ( a ^ b ^ c ^ d ) != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT a = 3 NEW_LINE b = 2 NEW_LINE c = 3 NEW_LINE d = 2 NEW_LINE if ( isRectangle ( a , b , c , d ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def isRectangle ( a , b , c , d ) : NEW_LINE INDENT if a ^ b ^ c ^ d : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT a , b , c , d = 3 , 2 , 3 , 2 NEW_LINE print ( \" Yes \" if isRectangle ( a , b , c , d ) else \" No \" ) NEW_LINE"],"bleu":0.4807822262985098,"rouge_l":0.7015738498789346}
{"id":1181,"predictions":["def merge ( arr , temp , left , mid , right ) : NEW_LINE INDENT inv_count = 0 NEW_LINE i = left NEW_LINE j = mid NEW_LINE k = left NEW_LINE while ( ( ( i <= mid - 1 ) and ( j <= right ) ) : NEW_LINE INDENT if ( arr [ i ] <= arr [ j ] ) : NEW_LINE INDENT temp [ k ] = arr [ i ] NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT temp [ k ] = arr [ j ] NEW_LINE j += 1 NEW_LINE inv_count = inv_count + ( mid - i ) NEW_LINE DEDENT DEDENT while ( i <= mid - 1 ) : NEW_LINE INDENT temp [ k ] = arr [ i ] NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT while ( j <= right ) : NEW_LINE INDENT temp [ k ] = arr [ j ] NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT while ( j <= right ) : NEW_LINE INDENT temp [ k ] = arr [ j ] NEW_LINE i += 1 NEW_LINE DEDENT for i in range ( left , right + 1 ) : NEW_LINE INDENT arr [ i ] = temp [ i ] NEW_LINE DEDENT return inv_count NEW_LINE DEDENT def _mergeSort ( arr , temp , left , right ) : NEW_LINE INDENT inv_count = 0 NEW_LINE if ( right > left ) : NEW_LINE INDENT mid = ( right + left ) \/\/ 2 NEW_LINE inv_count = _mergeSort ( arr , temp , left , mid ) NEW_LINE inv_count += _mergeSort ( arr , temp , left , mid + 1 , right ) NEW_LINE inv_count += merge ( arr , temp , left , mid + 1 , right ) NEW_LINE DEDENT return inv_count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 5 , 3 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE res = minSwgeSort ( arr , N ) NEW_LINE res = minSw"],"references":["def merge ( arr , temp , left , mid , right ) : NEW_LINE INDENT inv_count = 0 NEW_LINE i = left NEW_LINE j = mid NEW_LINE k = left NEW_LINE while ( i <= mid - 1 ) and ( j <= right ) : NEW_LINE INDENT if arr [ i ] <= arr [ j ] : NEW_LINE INDENT temp [ k ] = arr [ i ] NEW_LINE k , i = k + 1 , i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT temp [ k ] = arr [ j ] NEW_LINE k , j = k + 1 , j + 1 NEW_LINE inv_count = inv_count + ( mid - i ) NEW_LINE DEDENT DEDENT while i <= mid - 1 : NEW_LINE INDENT temp [ k ] = arr [ i ] NEW_LINE k , i = k + 1 , i + 1 NEW_LINE DEDENT while j <= right : NEW_LINE INDENT temp [ k ] = arr [ j ] NEW_LINE k , j = k + 1 , j + 1 NEW_LINE DEDENT for i in range ( left , right + 1 ) : NEW_LINE INDENT arr [ i ] = temp [ i ] NEW_LINE DEDENT return inv_count NEW_LINE DEDENT def _mergeSort ( arr , temp , left , right ) : NEW_LINE INDENT inv_count = 0 NEW_LINE if right > left : NEW_LINE INDENT mid = ( right + left ) \/\/ 2 NEW_LINE inv_count = _mergeSort ( arr , temp , left , mid ) NEW_LINE inv_count += _mergeSort ( arr , temp , mid + 1 , right ) NEW_LINE inv_count += merge ( arr , temp , left , mid + 1 , right ) NEW_LINE DEDENT return inv_count NEW_LINE DEDENT def mergeSort ( arr , array_size ) : NEW_LINE INDENT temp = [ None ] * array_size NEW_LINE return _mergeSort ( arr , temp , 0 , array_size - 1 ) NEW_LINE DEDENT def minSwapToReachArr ( arr , N ) : NEW_LINE INDENT for i in range ( 0 , N ) : NEW_LINE INDENT if ( arr [ i ] - 1 ) - i > 2 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT numOfInversion = mergeSort ( arr , N ) NEW_LINE return numOfInversion NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 5 , 3 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE res = minSwapToReachArr ( arr , N ) NEW_LINE if res == - 1 : NEW_LINE INDENT print ( \" Not ▁ Possible \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res ) NEW_LINE DEDENT DEDENT"],"bleu":0.6220970024143752,"rouge_l":0.737845455257183}
{"id":1182,"predictions":["import math NEW_LINE def Prime ( n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def primeCountDivisors ( n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT a = n NEW_LINE c = 0 NEW_LINE while ( a % i == 0 ) : NEW_LINE INDENT a = a \/\/ i NEW_LINE c += 1 NEW_LINE DEDENT if ( a == 1 and Prime ( c + 1 ) == True ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT n = 13 NEW_LINE if ( primeCountDivisors ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["from math import sqrt NEW_LINE def Prime ( n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT for i in range ( 2 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT def primeCountDivisors ( n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT for i in range ( 2 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT a = n ; c = 0 ; NEW_LINE while ( a % i == 0 ) : NEW_LINE INDENT a \/\/= i ; NEW_LINE c += 1 ; NEW_LINE DEDENT if ( a == 1 and Prime ( c + 1 ) ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT DEDENT return True ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 13 ; NEW_LINE if ( primeCountDivisors ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"],"bleu":0.7453220074539664,"rouge_l":0.8997943408268918}
{"id":1183,"predictions":["def countSubSeq ( a , n , k ) : NEW_LINE INDENT a . sort ( ) NEW_LINE arr = sorted ( list ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT count = 1 NEW_LINE x = a [ i ] NEW_LINE i += 1 NEW_LINE while ( i < n and a [ i ] == x ) : NEW_LINE INDENT count += 1 NEW_LINE i += 1 NEW_LINE DEDENT arr . append ( count ) NEW_LINE DEDENT m = len ( arr ) NEW_LINE n = min ( m , k ) NEW_LINE count = 1 NEW_LINE dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( m + 1 , - 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( m , 0 , - 1 ) : NEW_LINE INDENT if ( j > m - i ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i ] [ j + 1 ] + arr [ j ] * dp [ i - 1 ] [ j + 1 ] ) NEW_LINE DEDENT DEDENT count = count + dp [ i ] [ 0 ] NEW_LINE DEDENT return count NEW_LINE DEDENT a = [ 2 , 2 , 3 , 3 , 5 ] NEW_LINE n = len ( a ) NEW_LINE k = 3 NEW_LINE print ( countSubSeq ( a , n , k ) ) NEW_LINE"],"references":["def countSubSeq ( a , n , k ) : NEW_LINE INDENT a . sort ( reverse = False ) NEW_LINE arr = [ ] NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT count = 1 NEW_LINE x = a [ i ] NEW_LINE i += 1 NEW_LINE while ( i < n and a [ i ] == x ) : NEW_LINE INDENT count += 1 NEW_LINE i += 1 NEW_LINE DEDENT arr . append ( count ) NEW_LINE DEDENT m = len ( arr ) NEW_LINE n = min ( m , k ) NEW_LINE count = 1 NEW_LINE dp = [ [ 0 for i in range ( m + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT j = m NEW_LINE while ( j >= 0 ) : NEW_LINE INDENT if ( j > m - i ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j + 1 ] +   \\ NEW_LINE INDENT arr [ j ] * dp [ i - 1 ] [ j + 1 ] NEW_LINE DEDENT DEDENT j -= 1 NEW_LINE DEDENT count = count + dp [ i ] [ 0 ] NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 2 , 2 , 3 , 3 , 5 ] NEW_LINE n = len ( a ) NEW_LINE k = 3 NEW_LINE print ( countSubSeq ( a , n , k ) ) NEW_LINE DEDENT"],"bleu":0.8184016546577602,"rouge_l":0.8907876339909896}
{"id":1184,"predictions":["def isVowel ( ch ) : NEW_LINE INDENT if ch in [ ' a ' , ' e ' , ' , ' u ' ] : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def isSatisfied ( string , n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( isVowel ( string [ i ] ) and isVowel ( string [ i - 1 ] ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( isVowel ( string [ i ] ) and isVowel ( string [ i - 1 ] ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" acaba \" NEW_LINE n = len ( string ) NEW_LINE if ( isSatisfies ( string , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def isVowel ( ch ) : NEW_LINE INDENT if ch in [ ' i ' , ' a ' , ' e ' , ' o ' , ' u ' ] : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def isSatisfied ( st , n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( isVowel ( st [ i ] ) == False and isVowel ( st [ i - 1 ] ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( isVowel ( st [ i ] ) and isVowel ( st [ i - 1 ] ) == False and isVowel ( st [ i + 1 ] ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT st = \" acaba \" NEW_LINE n = len ( st ) NEW_LINE if ( isSatisfied ( st , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.7548661109634304,"rouge_l":0.8543555699481867}
{"id":1185,"predictions":["def equal_xor_sum ( arr , n ) : NEW_LINE INDENT Sum = 0 NEW_LINE Xor = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum = Sum + arr [ i ] NEW_LINE Xor = Xor ^ arr [ i ] NEW_LINE DEDENT if ( Sum == Xor ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT arr = [ 6 , 3 , 7 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE equal_xor_sum ( arr , n ) NEW_LINE"],"references":["def equal_xor_sum ( arr , n ) : NEW_LINE INDENT Sum = 0 ; NEW_LINE Xor = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum = Sum + arr [ i ] ; NEW_LINE Xor = Xor ^ arr [ i ] ; NEW_LINE DEDENT if ( Sum == Xor ) : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 6 , 3 , 7 , 10 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE equal_xor_sum ( arr , n ) ; NEW_LINE DEDENT"],"bleu":0.6828147644285802,"rouge_l":0.8835606806356349}
{"id":1186,"predictions":["def getMinLength ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE result = 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( count != 0 ) : NEW_LINE INDENT result = min ( result , count ) NEW_LINE DEDENT count = 0 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT arr = [ 1 , 1 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( getMinLength ( arr , n ) ) NEW_LINE"],"references":["import sys NEW_LINE def getMinLength ( arr , n ) : NEW_LINE INDENT count = 0 ; NEW_LINE result = sys . maxsize ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( count != 0 ) : NEW_LINE INDENT result = min ( result , count ) ; NEW_LINE DEDENT count = 0 ; NEW_LINE DEDENT DEDENT return result ; NEW_LINE DEDENT arr = [ 1 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 1 , 1 , 1 , 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( getMinLength ( arr , n ) ) ; NEW_LINE"],"bleu":0.771776260639313,"rouge_l":0.9104477611940299}
{"id":1187,"predictions":["def isPowerOfTwo ( n ) : NEW_LINE INDENT return ( n and not ( not ( n & ( n - 1 ) ) ) ) NEW_LINE DEDENT def findPosition ( n ) : NEW_LINE INDENT if not isPowerOfTwo ( n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT i = 1 NEW_LINE pos = 1 NEW_LINE while ( ( i & n ) == 0 ) : NEW_LINE INDENT i = i << 1 NEW_LINE pos += 1 NEW_LINE DEDENT return pos NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 16 NEW_LINE pos = findPosition ( n ) NEW_LINE if ( pos == - 1 ) : NEW_LINE INDENT print ( \" n ▁ = \" , n , \" , ▁ Position \" , pos ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" n ▁ = \" , n , \" Position \" , pos ) NEW_LINE DEDENT n = 128 NEW_LINE pos = findPosition ( n ) NEW_LINE if ( pos == - 1 ) : NEW_LINE INDENT print ( \" n ▁ = \" , n , \" , ▁ Position \" , pos ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" n ▁ = ▁ \" , n , \" Position \" , pos ) NEW_LINE DEDENT n = 128 NEW_LINE pos = findPosition ( n ) NEW_LINE if ( pos == - 1 ) : NEW_LINE INDENT print ( \" n ▁ = \" , n , \" , n , \" Invalid ▁ number \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" n ▁ = \" , n , \" Position \" , pos ) NEW_LINE DEDENT DEDENT"],"references":["def isPowerOfTwo ( n ) : NEW_LINE INDENT return ( True if ( n > 0 and ( ( n & ( n - 1 ) ) > 0 ) ) else False ) ; NEW_LINE DEDENT def findPosition ( n ) : NEW_LINE INDENT if ( isPowerOfTwo ( n ) == True ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT i = 1 ; NEW_LINE pos = 1 ; NEW_LINE while ( ( i & n ) == 0 ) : NEW_LINE INDENT i = i << 1 ; NEW_LINE pos += 1 ; NEW_LINE DEDENT return pos ; NEW_LINE DEDENT n = 16 ; NEW_LINE pos = findPosition ( n ) ; NEW_LINE if ( pos == - 1 ) : NEW_LINE INDENT print ( \" n ▁ = \" , n , \" , ▁ Invalid ▁ number \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" n ▁ = \" , n , \" , ▁ Position ▁ \" , pos ) ; NEW_LINE DEDENT n = 12 ; NEW_LINE pos = findPosition ( n ) ; NEW_LINE if ( pos == - 1 ) : NEW_LINE INDENT print ( \" n ▁ = \" , n , \" , ▁ Invalid ▁ number \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" n ▁ = \" , n , \" , ▁ Position ▁ \" , pos ) ; NEW_LINE DEDENT n = 128 ; NEW_LINE pos = findPosition ( n ) ; NEW_LINE if ( pos == - 1 ) : NEW_LINE INDENT print ( \" n ▁ = \" , n , \" , ▁ Invalid ▁ number \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" n ▁ = \" , n , \" , ▁ Position ▁ \" , pos ) ; NEW_LINE DEDENT"],"bleu":0.6842588668370898,"rouge_l":0.8656202967103848}
{"id":1188,"predictions":["def totalNumber ( n ) : NEW_LINE INDENT return 8 * pow ( 9 , n - 1 ) NEW_LINE DEDENT n = 3 NEW_LINE print ( totalNumber ( n ) ) NEW_LINE"],"references":["def totalNumber ( n ) : NEW_LINE INDENT return 8 * pow ( 9 , n - 1 ) ; NEW_LINE DEDENT n = 3 NEW_LINE print ( totalNumber ( n ) ) NEW_LINE"],"bleu":0.9235076009084147,"rouge_l":0.9824304538799414}
{"id":1189,"predictions":["rev_num = 0 NEW_LINE base_pos = 1 NEW_LINE def reversDigits ( num ) : NEW_LINE INDENT global rev_num NEW_LINE global base_pos NEW_LINE if ( num > 0 ) : NEW_LINE INDENT reversDigits ( int ) ( ( num \/ 10 ) ) NEW_LINE rev_num += ( num % 10 ) * base_pos NEW_LINE base_pos *= 10 NEW_LINE DEDENT return rev_num NEW_LINE DEDENT num = 4562 NEW_LINE print ( \" Reverse ▁ of ▁ size ) NEW_LINE"],"references":["rev_num = 0 NEW_LINE base_pos = 1 NEW_LINE def reversDigits ( num ) : NEW_LINE INDENT global rev_num NEW_LINE global base_pos NEW_LINE if ( num > 0 ) : NEW_LINE INDENT reversDigits ( ( int ) ( num \/ 10 ) ) NEW_LINE rev_num += ( num % 10 ) * base_pos NEW_LINE base_pos *= 10 NEW_LINE DEDENT return rev_num NEW_LINE DEDENT num = 4562 NEW_LINE print ( \" Reverse ▁ of ▁ no . ▁ is ▁ \" , reversDigits ( num ) ) NEW_LINE"],"bleu":0.8261639656262529,"rouge_l":0.9035228182546037}
{"id":1190,"predictions":["def check ( s ) : NEW_LINE INDENT l = sorted ( s ) NEW_LINE for i in range ( 1 , l ) : NEW_LINE INDENT if ( s [ i ] - s [ i - 1 ] != 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT str1 = \" dcef \" NEW_LINE if ( check ( str1 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT if ( check ( str1 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def check ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE s = ' ' . join ( sorted ( s ) ) NEW_LINE for i in range ( 1 , l ) : NEW_LINE INDENT if ord ( s [ i ] ) - ord ( s [ i - 1 ] ) != 1 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" dcef \" NEW_LINE if check ( string ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT string = \" xyza \" NEW_LINE if check ( string ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.6159782074131014,"rouge_l":0.8044112498541253}
{"id":1191,"predictions":["def maxAnions ( n ) : NEW_LINE INDENT num = n * ( n + 1 ) \/\/ 2 + 1 ; NEW_LINE print ( num ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 10 ; NEW_LINE maxAnions ( n ) ; NEW_LINE DEDENT"],"references":["def maxRegions ( n ) : NEW_LINE INDENT num = n * ( n + 1 ) \/\/ 2 + 1 NEW_LINE print ( num ) NEW_LINE DEDENT n = 10 NEW_LINE maxRegions ( n ) NEW_LINE"],"bleu":0.4728031984087171,"rouge_l":0.7886959734022905}
{"id":1192,"predictions":["def bestAPAPadjacent ( x , y ) : NEW_LINE INDENT n = len ( x ) NEW_LINE sum_x = 0 NEW_LINE sum_y = 0 NEW_LINE sum_xy = 0 NEW_LINE sum_xy = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum_x += x [ i ] NEW_LINE sum_xy += x [ i ] * y [ i ] NEW_LINE sum_x += x [ i ] * y [ i ] NEW_LINE sum_x2 += x [ i ] NEW_LINE DEDENT m = ( n * sum_xy - sum_x * sum_x ) \/ ( n * sum_x2 - pow ( sum_x , 2 ) ) ) NEW_LINE c = ( sum_y - m * sum_x ) \/ n NEW_LINE print ( \" c ▁ = ▁ \" , c ) NEW_LINE print ( \" c ▁ = ▁ \" , c ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE y = [ 10 , 7 , 7 , 4 , 5 ] NEW_LINE best = [ 10 , 7 , 7 , 8 ] NEW_LINE bestAlternimates ( x , y ) NEW_LINE DEDENT"],"references":["def bestApproximate ( x , y , n ) : NEW_LINE INDENT sum_x = 0 NEW_LINE sum_y = 0 NEW_LINE sum_xy = 0 NEW_LINE sum_x2 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum_x += x [ i ] NEW_LINE sum_y += y [ i ] NEW_LINE sum_xy += x [ i ] * y [ i ] NEW_LINE sum_x2 += pow ( x [ i ] , 2 ) NEW_LINE DEDENT m = ( float ) ( ( n * sum_xy - sum_x * sum_y ) \/ ( n * sum_x2 - pow ( sum_x , 2 ) ) ) ; NEW_LINE c = ( float ) ( sum_y - m * sum_x ) \/ n ; NEW_LINE print ( \" m ▁ = ▁ \" , m ) ; NEW_LINE print ( \" c ▁ = ▁ \" , c ) ; NEW_LINE DEDENT x = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE y = [ 14 , 27 , 40 , 55 , 68 ] NEW_LINE n = len ( x ) NEW_LINE bestApproximate ( x , y , n ) NEW_LINE"],"bleu":0.6244630123938116,"rouge_l":0.7823068126123183}
{"id":1193,"predictions":["def printPrevGreater ( arr , n ) : NEW_LINE INDENT ts = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT c = ts [ arr [ i ] ] NEW_LINE if ( c == None ) : NEW_LINE INDENT print ( - 1 , end = \" ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( c , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 10 , 5 , 10 , 10 , 10 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE printPrevGreater ( arr , n ) NEW_LINE"],"references":["def printPrevGreater ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT it = [ x for x in s if x >= arr [ i ] ] NEW_LINE if len ( it ) == 0 : NEW_LINE INDENT print ( \" - 1\" , end = \" ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( min ( it ) , end = \" ▁ \" ) NEW_LINE DEDENT s . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 10 , 5 , 11 , 10 , 20 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE printPrevGreater ( arr , n ) NEW_LINE DEDENT"],"bleu":0.5071731743904582,"rouge_l":0.7475108501404136}
{"id":1194,"predictions":["MAX = 1000005 NEW_LINE prime = [ True for i in range ( MAX ) ] NEW_LINE def seIni ( ) : NEW_LINE INDENT for i in range ( MAX ) : NEW_LINE INDENT prime [ i ] = True NEW_LINE DEDENT DEDENT def seive ( N ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT for j in range ( 2 , N + 1 ) : NEW_LINE INDENT prime [ i * j ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def countLogNeeded ( N ) : NEW_LINE INDENT count = 0 NEW_LINE seive ( N ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT vecIni ( ) NEW_LINE N = 6 NEW_LINE print ( countLogNeeded ( N ) ) NEW_LINE"],"references":["MAX = 1000005 NEW_LINE prime = [ True for i in range ( MAX ) ] NEW_LINE def seive ( N ) : NEW_LINE INDENT prime [ 0 ] , prime [ 1 ] = False , False NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT for j in range ( 2 , N + 1 ) : NEW_LINE INDENT if ( i * j > N ) : NEW_LINE INDENT break NEW_LINE DEDENT prime [ i * j ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def countLogNeeded ( N ) : NEW_LINE INDENT count = 0 NEW_LINE seive ( N ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 6 NEW_LINE print ( countLogNeeded ( N ) ) NEW_LINE DEDENT"],"bleu":0.8028764898217232,"rouge_l":0.819672131147541}
{"id":1195,"predictions":["def findMinimumOperation ( n , d , arr ) : NEW_LINE INDENT cnt = 0 NEW_LINE first = - 10 ** 9 NEW_LINE end = - 10 ** 9 NEW_LINE while ( n ) : NEW_LINE INDENT arr = [ arr [ cnt ] [ 0 ] , arr [ cnt ] [ 1 ] NEW_LINE arr . sort ( ) NEW_LINE first = max ( first , arr [ 0 ] ) NEW_LINE end = cnt + 1 NEW_LINE n -= 1 NEW_LINE DEDENT if ( first > end ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( d >= first and d <= end ) : NEW_LINE INDENT print ( \"0\" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( d >= first and d <= end : NEW_LINE INDENT print ( \"0\" , end = \" \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( min ( abs ( first - d ) , abs ( d - end ) ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE d = 3 NEW_LINE arr = [ 0 , 7 ] , [ 2 , 14 ] , [ 4 , 6 ] , [ 4 , 6 ] NEW_LINE findMinimumOperation ( n , d , arr ) NEW_LINE DEDENT"],"references":["def findMinimumOperation ( n , d , arrays ) : NEW_LINE INDENT cnt = 0 NEW_LINE first = - 10 ** 9 NEW_LINE end = 10 ** 9 NEW_LINE while ( n ) : NEW_LINE INDENT arr = [ arrays [ cnt ] [ 0 ] , arrays [ cnt ] [ 1 ] ] NEW_LINE arr = sorted ( arr ) NEW_LINE first = max ( first , arr [ 0 ] ) NEW_LINE end = min ( end , arr [ 1 ] ) NEW_LINE cnt += 1 NEW_LINE n -= 1 NEW_LINE DEDENT if ( first > end ) : NEW_LINE INDENT print ( \" - 1\" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( d >= first and d <= end ) : NEW_LINE INDENT print ( \"0\" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( min ( abs ( first - d ) , abs ( d - end ) ) , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE d = 3 NEW_LINE arrays = [ [ 0 , 7 ] , [ 2 , 14 ] , [ 4 , 6 ] ] NEW_LINE findMinimumOperation ( n , d , arrays ) NEW_LINE DEDENT"],"bleu":0.7575190904672123,"rouge_l":0.8562295879369051}
{"id":1196,"predictions":["MAX = 90 NEW_LINE index1 = [ 0 ] * MAX NEW_LINE index2 = [ 0 ] * MAX NEW_LINE index2 = [ 0 ] * MAX NEW_LINE arr [ 0 ] = 0 NEW_LINE index4 = [ 0 ] * MAX NEW_LINE arr [ 0 ] = 1 NEW_LINE for i in range ( 2 , MAX ) : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] + arr [ i - 2 ] + arr [ i - 2 ] NEW_LINE DEDENT c1 = 0 NEW_LINE c2 = c3 = 0 NEW_LINE c4 = 0 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if arr [ i ] % 2 == 0 : NEW_LINE INDENT index1 [ c1 ] = i NEW_LINE c1 += 1 NEW_LINE DEDENT if arr [ i ] % 3 == 0 : NEW_LINE INDENT index1 [ c2 ] = i NEW_LINE c2 += 1 NEW_LINE DEDENT if arr [ i ] % 5 == 0 : NEW_LINE INDENT index2 [ c2 ] = i NEW_LINE c2 += 1 NEW_LINE DEDENT if arr [ i ] % 8 == 0 : NEW_LINE INDENT index3 [ c2 ] = i NEW_LINE c3 += 1 NEW_LINE DEDENT if arr [ i ] % 8 == 0 : NEW_LINE INDENT index4 [ c4 ] = i NEW_LINE c4 += 1 NEW_LINE DEDENT DEDENT print ( \" Index ▁ of ▁ Fibonacci ▁ numbers ▁ divisible ▁ by ▁ 2 ▁ are \" , end = \" \" ) NEW_LINE for i in range ( c1 ) : NEW_LINE INDENT print ( index [ i ] , \" ▁ \" , end = \" \" ) NEW_LINE DEDENT print ( \" Index ▁ of ▁ Fibonacci ▁ number ▁ are ▁ : \" ) NEW_LINE for i in range ( c1 ) : NEW_LINE INDENT print ( index [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( \" Index ▁ of ▁ Fibonacci ▁ number ▁ of ▁ \" , end = \" \" ) NEW_LINE for"],"references":["MAX = 90 ; NEW_LINE arr = [ 0 ] * ( MAX ) ; NEW_LINE index1 = [ 0 ] * ( MAX ) ; NEW_LINE index2 = [ 0 ] * ( MAX ) ; NEW_LINE index3 = [ 0 ] * ( MAX ) ; NEW_LINE index4 = [ 0 ] * ( MAX ) ; NEW_LINE arr [ 0 ] = 0 ; NEW_LINE arr [ 1 ] = 1 ; NEW_LINE for i in range ( 2 , MAX ) : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] + arr [ i - 2 ] ; NEW_LINE DEDENT c1 , c2 , c3 , c4 = 0 , 0 , 0 , 0 ; NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT index1 [ c1 ] = i ; NEW_LINE c1 += 1 ; NEW_LINE DEDENT if ( arr [ i ] % 3 == 0 ) : NEW_LINE INDENT index2 [ c2 ] = i ; NEW_LINE c2 += 1 ; NEW_LINE DEDENT if ( arr [ i ] % 5 == 0 ) : NEW_LINE INDENT index3 [ c3 ] = i ; NEW_LINE c3 += 1 ; NEW_LINE DEDENT if ( arr [ i ] % 8 == 0 ) : NEW_LINE INDENT index4 [ c4 ] = i ; NEW_LINE c4 += 1 ; NEW_LINE DEDENT DEDENT print ( \" Index ▁ of ▁ Fibonacci ▁ numbers \" , \" divisible ▁ by ▁ 2 ▁ are ▁ : \" ) ; NEW_LINE for i in range ( c1 ) : NEW_LINE INDENT print ( index1 [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( \" \" ) ; NEW_LINE print ( \" Index ▁ of ▁ Fibonacci ▁ number \" , \" divisible ▁ by ▁ 3 ▁ are ▁ : \" ) ; NEW_LINE for i in range ( c2 ) : NEW_LINE INDENT print ( index2 [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( \" \" ) ; NEW_LINE print ( \" Index ▁ of ▁ Fibonacci ▁ number \" , \" divisible ▁ by ▁ 5 ▁ are ▁ : \" ) ; NEW_LINE for i in range ( c3 ) : NEW_LINE INDENT print ( index3 [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( \" \" ) ; NEW_LINE print ( \" Index ▁ of ▁ Fibonacci ▁ number \" , \" divisible ▁ by ▁ 8 ▁ are ▁ : \" ) ; NEW_LINE for i in range ( c4 ) : NEW_LINE INDENT print ( index4 [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( \" \" ) ; NEW_LINE"],"bleu":0.4600208948031853,"rouge_l":0.6875856816450876}
{"id":1197,"predictions":["def check ( s ) : NEW_LINE INDENT freq = [ 0 for i in range ( 26 ) ] NEW_LINE n = len ( s ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - 97 ] += 1 NEW_LINE DEDENT for i in range ( 0 , len ( freq ) ) : NEW_LINE INDENT if ( freq [ i ] % 2 == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" abaccaba \" NEW_LINE if ( check ( s ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def check ( s ) : NEW_LINE INDENT freq = [ 0 ] * 26 NEW_LINE n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - 97 ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( freq [ i ] % 2 == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT s = \" abaccaba \" NEW_LINE if ( check ( s ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.7498893830109012,"rouge_l":0.8832719420805285}
{"id":1198,"predictions":["def getMinMax ( arr , low , high ) : NEW_LINE INDENT minmax = [ ] NEW_LINE mml = [ ] NEW_LINE mmr = dict ( ) NEW_LINE if ( low == high ) : NEW_LINE INDENT minmax . maxm = arr [ low ] NEW_LINE minm = arr [ low ] NEW_LINE return minm NEW_LINE DEDENT if ( high == low + 1 ) : NEW_LINE INDENT if ( arr [ low ] > arr [ high ] ) : NEW_LINE INDENT minm = arr [ low ] NEW_LINE minm = arr [ high ] NEW_LINE DEDENT else : NEW_LINE INDENT minm = arr [ high ] NEW_LINE minm = arr [ high ] NEW_LINE DEDENT return minm NEW_LINE DEDENT mid = ( low + high ) \/\/ 2 NEW_LINE mn = getMinMax ( arr , low , mid ) NEW_LINE mmr = getMinMax ( arr , mid + 1 , mid ) NEW_LINE if ( mm . minm . minm . minm . minm . minm . get ( arr , mid + 1 , high ) ) : NEW_LINE INDENT minmax . minm . minm = mn . minm . minm . min ( arr , mid + 1 , high ) NEW_LINE DEDENT else : NEW_LINE INDENT minm = mmr . maxm NEW_LINE DEDENT return minm NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1000 , 11 , 11 , 445 , 1 , 330 , 3000 ] NEW_LINE mn = getMinMax ( arr ) NEW_LINE minmax = getMinMax ( arr , 0 , arr_size - 1 NEW_LINE print ( \" Minimum ▁ element ▁ is \" , mn ) NEW_LINE print ( \" Maximum ▁ element ▁ is \" , minm ) NEW_LINE DEDENT"],"references":["def getMinMax ( low , high , arr ) : NEW_LINE INDENT arr_max = arr [ low ] NEW_LINE arr_min = arr [ low ] NEW_LINE if low == high : NEW_LINE INDENT arr_max = arr [ low ] NEW_LINE arr_min = arr [ low ] NEW_LINE return ( arr_max , arr_min ) NEW_LINE DEDENT elif high == low + 1 : NEW_LINE INDENT if arr [ low ] > arr [ high ] : NEW_LINE INDENT arr_max = arr [ low ] NEW_LINE arr_min = arr [ high ] NEW_LINE DEDENT else : NEW_LINE INDENT arr_max = arr [ high ] NEW_LINE arr_min = arr [ low ] NEW_LINE DEDENT return ( arr_max , arr_min ) NEW_LINE DEDENT else : NEW_LINE INDENT mid = int ( ( low + high ) \/ 2 ) NEW_LINE arr_max1 , arr_min1 = getMinMax ( low , mid , arr ) NEW_LINE arr_max2 , arr_min2 = getMinMax ( mid + 1 , high , arr ) NEW_LINE DEDENT return ( max ( arr_max1 , arr_max2 ) , min ( arr_min1 , arr_min2 ) ) NEW_LINE DEDENT arr = [ 1000 , 11 , 445 , 1 , 330 , 3000 ] NEW_LINE high = len ( arr ) - 1 NEW_LINE low = 0 NEW_LINE arr_max , arr_min = getMinMax ( low , high , arr ) NEW_LINE print ( ' Minimum ▁ element ▁ is ▁ ' , arr_min ) NEW_LINE print ( ' nMaximum ▁ element ▁ is ▁ ' , arr_max ) NEW_LINE"],"bleu":0.37052227604182414,"rouge_l":0.6437315322921064}
{"id":1199,"predictions":["from queue import Queue NEW_LINE def countUnvisited ( n , m ) : NEW_LINE INDENT X = ( m * n ) - m - n NEW_LINE Queue . put ( X ) NEW_LINE q . put ( X ) NEW_LINE count = 0 NEW_LINE while ( len ( Queue ) ) : NEW_LINE INDENT curr = Queue . queue [ 0 ] NEW_LINE count += 1 NEW_LINE if ( curr - m > 0 ) : NEW_LINE INDENT Queue . append ( curr - m ) NEW_LINE DEDENT if ( curr - n > 0 ) : NEW_LINE INDENT Queue . put ( curr - n ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 2 NEW_LINE m = 5 NEW_LINE print ( countUnvisited ( n , m ) ) NEW_LINE DEDENT"],"references":["def countUnvisited ( n , m ) : NEW_LINE INDENT i = 0 NEW_LINE X = ( m * n ) - m - n NEW_LINE queue = [ ] NEW_LINE queue . append ( X ) NEW_LINE count = 0 NEW_LINE while ( len ( queue ) > 0 ) : NEW_LINE INDENT curr = queue [ 0 ] NEW_LINE queue . remove ( queue [ 0 ] ) NEW_LINE count += 1 NEW_LINE if ( curr - m > 0 ) : NEW_LINE INDENT queue . append ( curr - m ) NEW_LINE DEDENT if ( curr - n > 0 ) : NEW_LINE INDENT queue . append ( curr - n ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 2 NEW_LINE m = 5 NEW_LINE print ( countUnvisited ( n , m ) ) NEW_LINE DEDENT"],"bleu":0.718377256748071,"rouge_l":0.8403297537693892}
{"id":1200,"predictions":["def uppercasingAlphabets ( ) : NEW_LINE INDENT for c in range ( 65 , 100 ) : NEW_LINE INDENT print ( \" ▁ \" , end = \" \" ) NEW_LINE DEDENT print ( \" \" ) NEW_LINE DEDENT def gppercaseAlphabets ( ) : NEW_LINE INDENT for c in range ( 90 , 10 ) : NEW_LINE INDENT print ( \" ▁ \" , end = \" \" ) NEW_LINE DEDENT print ( \" \" ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( ch ) NEW_LINE DEDENT DEDENT"],"references":["def lowercaseAlphabets ( ) : NEW_LINE INDENT for c in range ( 97 , 123 ) : NEW_LINE INDENT print ( chr ( c ) , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( \" \" ) ; NEW_LINE DEDENT def uppercaseAlphabets ( ) : NEW_LINE INDENT for c in range ( 65 , 91 ) : NEW_LINE INDENT print ( chr ( c ) , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( \" \" ) ; NEW_LINE DEDENT print ( \" Uppercase ▁ Alphabets \" ) ; NEW_LINE uppercaseAlphabets ( ) ; NEW_LINE print ( \" Lowercase ▁ Alphabets ▁ \" ) ; NEW_LINE lowercaseAlphabets ( ) ; NEW_LINE"],"bleu":0.4394213606170913,"rouge_l":0.6684178925247674}
{"id":1201,"predictions":["import math NEW_LINE def countNums ( a , b , c , d , d ) : NEW_LINE INDENT x = b \/\/ c - ( a - 1 ) \/\/ d NEW_LINE y = b \/\/ d NEW_LINE k = ( c * d ) \/\/ k NEW_LINE z = ( c * d ) \/\/ k NEW_LINE return b - a + 1 - x - y + z NEW_LINE DEDENT a = 10 NEW_LINE b = 50 NEW_LINE c = 4 NEW_LINE print ( countNums ( a , b , c , d ) ) NEW_LINE"],"references":["from math import gcd NEW_LINE def countNums ( a , b , c , d ) : NEW_LINE INDENT x = b \/\/ c - ( a - 1 ) \/\/ c ; NEW_LINE y = b \/\/ d - ( a - 1 ) \/\/ d ; NEW_LINE k = ( c * d ) \/\/ gcd ( c , d ) ; NEW_LINE z = b \/\/ k - ( a - 1 ) \/\/ k ; NEW_LINE return ( b - a + 1 - x - y + z ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 10 ; b = 50 ; c = 4 ; d = 6 ; NEW_LINE print ( countNums ( a , b , c , d ) ) ; NEW_LINE DEDENT"],"bleu":0.46748206706679457,"rouge_l":0.712186803095894}
{"id":1202,"predictions":["def countSubarrays ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if ( sum + arr [ j ] < k ) : NEW_LINE INDENT sum = arr [ j ] + sum NEW_LINE count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT array = [ 1 , 11 , 2 , 3 , 15 ] NEW_LINE k = 10 NEW_LINE size = len ( array ) NEW_LINE count = countSubarr ( array , size , k ) NEW_LINE print ( count ) NEW_LINE DEDENT"],"references":["def countSubarray ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if ( sum + arr [ j ] < k ) : NEW_LINE INDENT sum = arr [ j ] + sum NEW_LINE count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT array = [ 1 , 11 , 2 , 3 , 15 ] NEW_LINE k = 10 NEW_LINE size = len ( array ) NEW_LINE count = countSubarray ( array , size , k ) ; NEW_LINE print ( count ) NEW_LINE"],"bleu":0.8125842105240481,"rouge_l":0.919446503582901}
{"id":1203,"predictions":["def printPattern ( n ) : NEW_LINE INDENT if ( n == 0 or n < 0 ) : NEW_LINE INDENT print ( n , end = \" ▁ \" ) NEW_LINE return NEW_LINE DEDENT print ( n , end = \" ▁ \" ) NEW_LINE printPattern ( n - 5 ) NEW_LINE print ( n , end = \" ▁ \" ) NEW_LINE DEDENT n = 10 NEW_LINE printPattern ( n ) NEW_LINE"],"references":["def printPattern ( n ) : NEW_LINE INDENT if ( n == 0 or n < 0 ) : NEW_LINE INDENT print ( n , end = \" , ▁ \" ) NEW_LINE return NEW_LINE DEDENT print ( n , end = \" , ▁ \" ) NEW_LINE printPattern ( n - 5 ) NEW_LINE print ( n , end = \" , ▁ \" ) NEW_LINE DEDENT n = 16 NEW_LINE printPattern ( n ) NEW_LINE"],"bleu":0.8658338906503397,"rouge_l":0.9634357421029858}
{"id":1204,"predictions":["MAX = 100 NEW_LINE def countCommon ( mat , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT mat = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE print ( countCommon ( mat , 3 ) ) NEW_LINE"],"references":["Max = 100 NEW_LINE def countCommon ( mat , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] : NEW_LINE INDENT res = res + 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT mat = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE print ( countCommon ( mat , 3 ) ) NEW_LINE"],"bleu":0.9449772875065613,"rouge_l":0.9682539682539683}
{"id":1205,"predictions":["def getMinimumOps ( ar ) : NEW_LINE INDENT n = len ( ar ) NEW_LINE small = min ( ar ) NEW_LINE largest = max ( ar ) NEW_LINE dp = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE for j in range ( small , total + 1 ) : NEW_LINE INDENT dp [ 0 ] [ j ] = abs ( ar [ 0 ] - j ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT minimum = 10 ** 9 NEW_LINE for j in range ( small , total + 1 ) : NEW_LINE INDENT minimum = min ( minimum , dp [ i - 1 ] [ j ] ) NEW_LINE dp [ i ] [ j ] = minimum + abs ( ar [ i ] - j ) NEW_LINE DEDENT DEDENT ans = 10 ** 9 NEW_LINE for j in range ( small , total + 1 ) : NEW_LINE INDENT ans = min ( ans , dp [ n - 1 ] [ j ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 2 , 1 , 4 , 3 ] NEW_LINE print ( getMinimumOps ( arr ) ) NEW_LINE"],"references":["def getMinimumOps ( ar ) : NEW_LINE INDENT n = len ( ar ) NEW_LINE small = min ( ar ) NEW_LINE large = max ( ar ) NEW_LINE dp = [ [ 0 for i in range ( large + 1 ) ] for i in range ( n ) ] NEW_LINE for j in range ( small , large + 1 ) : NEW_LINE INDENT dp [ 0 ] [ j ] = abs ( ar [ 0 ] - j ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT minimum = 10 ** 9 NEW_LINE for j in range ( small , large + 1 ) : NEW_LINE INDENT minimum = min ( minimum , dp [ i - 1 ] [ j ] ) NEW_LINE dp [ i ] [ j ] = minimum + abs ( ar [ i ] - j ) NEW_LINE DEDENT DEDENT ans = 10 ** 9 NEW_LINE for j in range ( small , large + 1 ) : NEW_LINE INDENT ans = min ( ans , dp [ n - 1 ] [ j ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT ar = [ 1 , 2 , 1 , 4 , 3 ] NEW_LINE print ( getMinimumOps ( ar ) ) NEW_LINE"],"bleu":0.8874332533053816,"rouge_l":0.9537636810364083}
{"id":1206,"predictions":["def find ( s1 , s2 ) : NEW_LINE INDENT l = len ( s1 ) NEW_LINE len_1 = len ( s2 ) NEW_LINE if ( l != len_1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT d = [ 0 for i in range ( l ) ] NEW_LINE d [ 0 ] = ord ( s2 [ 0 ] ) - s1 [ 0 ] NEW_LINE for i in range ( 1 , l ) : NEW_LINE INDENT if ( s1 [ i ] > s2 [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT d [ i ] = ord ( s2 [ i ] ) - s1 [ i ] NEW_LINE DEDENT DEDENT for i in range ( l - - 1 ) : NEW_LINE INDENT if ( d1 [ i ] < d [ i + 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s1 = \" abcd \" NEW_LINE s2 = \" bcdd \" NEW_LINE if ( find ( s1 , s2 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def find ( s1 , s2 ) : NEW_LINE INDENT len__ = len ( s1 ) NEW_LINE len_1 = len ( s2 ) NEW_LINE if ( len__ != len_1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT d = [ 0 for i in range ( len__ ) ] NEW_LINE d [ 0 ] = ord ( s2 [ 0 ] ) - ord ( s1 [ 0 ] ) NEW_LINE for i in range ( 1 , len__ , 1 ) : NEW_LINE INDENT if ( s1 [ i ] > s2 [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT d [ i ] = ord ( s2 [ i ] ) - ord ( s1 [ i ] ) NEW_LINE DEDENT DEDENT for i in range ( len__ - 1 ) : NEW_LINE INDENT if ( d [ i ] < d [ i + 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s1 = \" abcd \" NEW_LINE s2 = \" bcdd \" NEW_LINE if ( find ( s1 , s2 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.8471096802985194,"rouge_l":0.9414131070801638}
{"id":1207,"predictions":["def solveQuery ( start , end , arr ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT if arr [ arr [ i ] ] in mp . keys ( ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for key , value in mp . items ( ) : NEW_LINE INDENT if ( key == value ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 1 , 2 , 2 , 3 , 3 , 3 , 3 ] NEW_LINE n = len ( A ) NEW_LINE queries = [ [ 0 , 1 ] , [ 1 , 2 ] , [ 1 , 3 ] , [ 3 , 5 ] , [ 0 , 5 ] , [ 0 , 5 ] ] NEW_LINE q = len ( queries ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT start = queries [ i ] [ 0 ] NEW_LINE end = queries [ i ] [ 1 ] NEW_LINE print ( \" Answer ▁ for ▁ Query \" , i + 1 ) NEW_LINE DEDENT DEDENT"],"references":["import math as mt NEW_LINE def solveQuery ( start , end , arr ) : NEW_LINE INDENT frequency = dict ( ) NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT if arr [ i ] in frequency . keys ( ) : NEW_LINE INDENT frequency [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT frequency [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for x in frequency : NEW_LINE INDENT if x == frequency [ x ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT A = [ 1 , 2 , 2 , 3 , 3 , 3 ] NEW_LINE n = len ( A ) NEW_LINE queries = [ [ 0 , 1 ] , [ 1 , 1 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 3 , 5 ] , [ 0 , 5 ] ] NEW_LINE q = len ( queries ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT start = queries [ i ] [ 0 ] NEW_LINE end = queries [ i ] [ 1 ] NEW_LINE print ( \" Answer ▁ for ▁ Query ▁ \" , ( i + 1 ) , \" ▁ = ▁ \" , solveQuery ( start , end , A ) ) NEW_LINE DEDENT"],"bleu":0.7837270267407748,"rouge_l":0.833984375}
{"id":1208,"predictions":["def solve ( N , K ) : NEW_LINE INDENT composite = [ 0 ] * 50 NEW_LINE composite [ 0 ] = 1 NEW_LINE for i in range ( 1 , K + 1 ) : NEW_LINE INDENT for j in range ( 0 , N + 1 ) : NEW_LINE INDENT if ( j >= i ) : NEW_LINE INDENT composite [ j ] += composite [ j - i ] NEW_LINE DEDENT DEDENT DEDENT return composite [ N ] NEW_LINE DEDENT N = 29 NEW_LINE K = 5 NEW_LINE print ( solve ( N , K ) ) NEW_LINE solve ( N , K ) NEW_LINE"],"references":["def solve ( N , K ) : NEW_LINE INDENT combo = [ 0 ] * ( N + 1 ) NEW_LINE combo [ 0 ] = 1 NEW_LINE for i in range ( 1 , K + 1 ) : NEW_LINE INDENT for j in range ( 0 , N + 1 ) : NEW_LINE INDENT if j >= i : NEW_LINE INDENT combo [ j ] += combo [ j - i ] NEW_LINE DEDENT DEDENT DEDENT return combo [ N ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N , K = 29 , 5 NEW_LINE print ( solve ( N , K ) ) NEW_LINE DEDENT"],"bleu":0.6577221076596318,"rouge_l":0.7960705578660549}
{"id":1209,"predictions":[" deno = [ 1 , 2 , 5 , 10 , 20 , 50 , 100 , 1000 , 1000 ] NEW_LINE n = len ( deno ) NEW_LINE def findMin ( V ) : NEW_LINE INDENT ans = [ ] NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT while ( V >= deno [ i ] ) : NEW_LINE INDENT V -= deno [ i ] NEW_LINE ans . append ( deno [ i ] ) NEW_LINE DEDENT DEDENT for i in range ( len ( ans ) ) : NEW_LINE INDENT print ( ans [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 9 NEW_LINE print ( \" Following ▁ is ▁ minimal ▁ number ▁ of ▁ change ▁ for \" , n , \" : ▁ \" , findMin ( n ) ) NEW_LINE DEDENT"],"references":["def findMin ( V ) : NEW_LINE INDENT deno = [ 1 , 2 , 5 , 10 , 20 , 50 , 100 , 500 , 1000 ] NEW_LINE n = len ( deno ) NEW_LINE ans = [ ] NEW_LINE i = n - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT while ( V >= deno [ i ] ) : NEW_LINE INDENT V -= deno [ i ] NEW_LINE ans . append ( deno [ i ] ) NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT for i in range ( len ( ans ) ) : NEW_LINE INDENT print ( ans [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 93 NEW_LINE print ( \" Following ▁ is ▁ minimal ▁ number \" , \" of ▁ change ▁ for \" , n , \" : ▁ \" , end = \" \" ) NEW_LINE findMin ( n ) NEW_LINE DEDENT"],"bleu":0.764122632020118,"rouge_l":0.832705705140275}
{"id":1210,"predictions":["def checkPalindrome ( num ) : NEW_LINE INDENT str1 = str ( num ) NEW_LINE l , r = 0 , len ( str1 ) - 1 NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( str1 [ l ] != str1 [ r ] ) : NEW_LINE INDENT print ( \" No \" ) NEW_LINE return NEW_LINE DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT print ( \" Yes \" ) NEW_LINE return NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 19 NEW_LINE k = 3 NEW_LINE checkPalindrome ( n + k ) NEW_LINE DEDENT"],"references":["def checkPalindrome ( num ) : NEW_LINE INDENT string = str ( num ) NEW_LINE l = 0 NEW_LINE r = len ( string ) - 1 ; NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( string [ l ] != string [ r ] ) : NEW_LINE INDENT print ( \" No \" ) NEW_LINE return ; NEW_LINE DEDENT l = l + 1 ; NEW_LINE r = r - 1 ; NEW_LINE DEDENT print ( \" Yes \" ) NEW_LINE return ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 19 NEW_LINE k = 3 NEW_LINE checkPalindrome ( n + k ) ; NEW_LINE DEDENT"],"bleu":0.6314999364343368,"rouge_l":0.8541725601131542}
{"id":1211,"predictions":["def updateArray ( arr , n ) : NEW_LINE INDENT for i in range ( n - 2 + 1 ) : NEW_LINE INDENT arr [ i ] = arr [ i + 1 ] NEW_LINE DEDENT arr [ n - 1 ] = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 5 , 1 , 3 , 2 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE updateArray ( arr , N ) NEW_LINE DEDENT"],"references":["def updateArray ( arr , n ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT arr [ i ] = arr [ i + 1 ] NEW_LINE DEDENT arr [ n - 1 ] = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 5 , 1 , 3 , 2 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE updateArray ( arr , N ) NEW_LINE DEDENT"],"bleu":0.9692817763533064,"rouge_l":0.9927985020884345}
{"id":1212,"predictions":["import sys NEW_LINE def maxProduct ( arr , n ) : NEW_LINE INDENT if ( n < 3 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT max_product = - sys . maxsize - 1 NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT max_product = max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] ) NEW_LINE DEDENT DEDENT DEDENT return max_product NEW_LINE DEDENT arr = [ 10 , 3 , 5 , 6 , 20 ] NEW_LINE n = len ( arr ) NEW_LINE max = maxProduct ( arr , n ) NEW_LINE if ( max == - 1 ) : NEW_LINE INDENT print ( \" No ▁ Triplet ▁ Exists \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Maximum ▁ product ▁ is \" , max ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE def maxProduct ( arr , n ) : NEW_LINE INDENT if n < 3 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT max_product = - ( sys . maxsize - 1 ) NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT max_product = max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] ) NEW_LINE DEDENT DEDENT DEDENT return max_product NEW_LINE DEDENT arr = [ 10 , 3 , 5 , 6 , 20 ] NEW_LINE n = len ( arr ) NEW_LINE max = maxProduct ( arr , n ) NEW_LINE if max == - 1 : NEW_LINE INDENT print ( \" No ▁ Tripplet ▁ Exits \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Maximum ▁ product ▁ is \" , max ) NEW_LINE DEDENT"],"bleu":0.8972614727607024,"rouge_l":0.9661016949152543}
{"id":1213,"predictions":["def count ( S , X ) : NEW_LINE INDENT count = 0 NEW_LINE N = len ( S ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( S [ i ] != '0' ) : NEW_LINE INDENT for j in range ( 1 , N + 1 ) : NEW_LINE INDENT num = int ( S [ i : i + j ] ) NEW_LINE if ( num > X ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = \"2222\" NEW_LINE X = 97 NEW_LINE print ( count ( S , X ) ) NEW_LINE DEDENT"],"references":["def countSubStr ( S , X ) : NEW_LINE INDENT cnt = 0 NEW_LINE N = len ( S ) NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( S [ i ] != '0' ) : NEW_LINE INDENT j = 1 NEW_LINE while ( ( j + i ) <= N ) : NEW_LINE INDENT num = int ( S [ i : i + j ] ) NEW_LINE if ( num > X ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE DEDENT j = j + 1 NEW_LINE DEDENT DEDENT DEDENT return cnt ; NEW_LINE DEDENT S = \"2222\" ; NEW_LINE X = 97 ; NEW_LINE print ( countSubStr ( S , X ) ) NEW_LINE"],"bleu":0.6390807228377545,"rouge_l":0.7748821372446307}
{"id":1214,"predictions":["import math NEW_LINE def printPattern ( radius ) : NEW_LINE INDENT for i in range ( 2 * radius + 1 ) : NEW_LINE INDENT for j in range ( 2 * radius + 1 ) : NEW_LINE INDENT dist = math . sqrt ( ( i - radius ) + ( j - radius ) * ( j - radius ) ) ; NEW_LINE if ( dist > radius - 0.0 and dist < radius + 0.5 ) : NEW_LINE INDENT print ( \" * \" , end = \" \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" ▁ \" , end = \" \" ) ; NEW_LINE DEDENT DEDENT print ( ) ; NEW_LINE DEDENT DEDENT radius = 6 ; NEW_LINE printPattern ( radius ) ; NEW_LINE"],"references":["import math NEW_LINE def printPattern ( radius ) : NEW_LINE INDENT for i in range ( ( 2 * radius ) + 1 ) : NEW_LINE INDENT for j in range ( ( 2 * radius ) + 1 ) : NEW_LINE INDENT dist = math . sqrt ( ( i - radius ) * ( i - radius ) + ( j - radius ) * ( j - radius ) ) NEW_LINE if ( dist > radius - 0.5 and dist < radius + 0.5 ) : NEW_LINE INDENT print ( \" * \" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" ▁ \" , end = \" \" ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT radius = 6 NEW_LINE printPattern ( radius ) NEW_LINE"],"bleu":0.8100146219262891,"rouge_l":0.9308465544386582}
{"id":1215,"predictions":["def findSum ( arr , N ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT if arr [ arr [ i ] ] % 2 != 0 : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT arr = [ 10 , 20 , 20 , 10 , 40 , 40 , 10 ] NEW_LINE N = len ( arr ) NEW_LINE print ( findSum ( arr , N ) ) NEW_LINE"],"references":["import collections NEW_LINE def findsum ( arr , N ) : NEW_LINE INDENT mp = collections . defaultdict ( int ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT sum = 0 NEW_LINE for i in mp : NEW_LINE INDENT if ( mp [ i ] % 2 != 0 ) : NEW_LINE INDENT sum += ( i * mp [ i ] ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT arr = [ 10 , 20 , 20 , 10 , 40 , 40 , 10 ] NEW_LINE N = len ( arr ) NEW_LINE print ( findsum ( arr , N ) ) NEW_LINE"],"bleu":0.6629540299095493,"rouge_l":0.7499642601858472}
{"id":1216,"predictions":["def findFrequencyUtil ( arr , low , high , freq ) : NEW_LINE INDENT if ( arr [ low ] == arr [ high ] ) : NEW_LINE INDENT freq [ arr [ low ] ] += high - low + 1 NEW_LINE DEDENT else : NEW_LINE INDENT mid = ( low + high ) \/\/ 2 NEW_LINE findFrequencyUtil ( arr , low , mid , mid , freq ) NEW_LINE findFrequencyUtil ( arr , mid + 1 , high , freq ) NEW_LINE findFrequencyUtil ( arr , mid + 1 , high , freq ) NEW_LINE DEDENT DEDENT def findFrequency ( arr , n ) : NEW_LINE INDENT freq = [ 0 ] * ( arr [ n - 1 ] + 1 ) NEW_LINE findFrequencyUtil ( arr , 0 , n - 1 , 1 , freq ) NEW_LINE for i in range ( arr [ n - 1 ] + 1 ) : NEW_LINE INDENT if ( freq [ i ] != 0 ) : NEW_LINE INDENT print ( \" Element \" , i , \" ▁ exists \" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 1 , 1 , 1 , 2 , 3 , 3 , 5 , 5 , 8 , 8 , 8 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE findFrequency ( arr , n ) NEW_LINE"],"references":["def findFrequencyUtil ( arr , low , high , freq ) : NEW_LINE INDENT if ( arr [ low ] == arr [ high ] ) : NEW_LINE INDENT freq [ arr [ low ] ] += high - low + 1 NEW_LINE DEDENT else : NEW_LINE INDENT mid = int ( ( low + high ) \/ 2 ) NEW_LINE findFrequencyUtil ( arr , low , mid , freq ) NEW_LINE findFrequencyUtil ( arr , mid + 1 , high , freq ) NEW_LINE DEDENT DEDENT def findFrequency ( arr , n ) : NEW_LINE INDENT freq = [ 0 for i in range ( n - 1 + 1 ) ] NEW_LINE findFrequencyUtil ( arr , 0 , n - 1 , freq ) NEW_LINE for i in range ( 0 , arr [ n - 1 ] + 1 , 1 ) : NEW_LINE INDENT if ( freq [ i ] != 0 ) : NEW_LINE INDENT print ( \" Element \" , i , \" occurs \" , freq [ i ] , \" times \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 1 , 1 , 2 , 3 , 3 , 5 , 5 , 8 , 8 , 8 , 9 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE findFrequency ( arr , n ) NEW_LINE DEDENT"],"bleu":0.7986749967171923,"rouge_l":0.8609797875984927}
{"id":1217,"predictions":["def sumOfSeries ( num ) : NEW_LINE INDENT res = 0 NEW_LINE fact = 1 NEW_LINE for i in range ( 1 , num + 1 ) : NEW_LINE INDENT fact = fact * i NEW_LINE res = res + ( i \/ fact ) NEW_LINE DEDENT return ( res ) NEW_LINE DEDENT n = 5 NEW_LINE print ( \" Sum : ▁ \" , sumOfSeries ( n ) ) ) NEW_LINE"],"references":["def sumOfSeries ( num ) : NEW_LINE INDENT res = 0 NEW_LINE fact = 1 NEW_LINE for i in range ( 1 , num + 1 ) : NEW_LINE INDENT fact *= i NEW_LINE res = res + ( i \/ fact ) NEW_LINE DEDENT return res NEW_LINE DEDENT n = 5 NEW_LINE print ( \" Sum : ▁ \" , sumOfSeries ( n ) ) NEW_LINE"],"bleu":0.8583921178097826,"rouge_l":0.9558404558404557}
{"id":1218,"predictions":["def calcSum ( arr , n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT print ( sum , end = \" ▁ \" ) NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT sum = ( sum - arr [ i - k ] ) + arr [ i ] NEW_LINE print ( sum , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE calcSum ( arr , n , k ) NEW_LINE"],"references":["def calcSum ( arr , n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT print ( sum , end = \" ▁ \" ) NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT sum = ( sum - arr [ i - k ] ) + arr [ i ] NEW_LINE print ( sum , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE calcSum ( arr , n , k ) NEW_LINE DEDENT"],"bleu":0.8822759806271514,"rouge_l":0.9375309866137829}
{"id":1219,"predictions":["def minChanges ( A , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT if ( ( i - 1 >= 0 ) and A [ i + 1 ] == 1 and A [ i + 1 ] == 1 and A [ i ] == 0 ) : NEW_LINE INDENT A [ i + 1 ] = 0 NEW_LINE cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT A = [ 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 ] NEW_LINE n = len ( A ) NEW_LINE print ( minChanges ( A , n ) ) NEW_LINE"],"references":["def minChanges ( A , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT if ( ( i - 1 >= 0 ) and A [ i - 1 ] == 1 and A [ i + 1 ] == 1 and A [ i ] == 0 ) : NEW_LINE INDENT A [ i + 1 ] = 0 NEW_LINE cnt = cnt + 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT A = [ 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 0 ] NEW_LINE n = len ( A ) NEW_LINE print ( minChanges ( A , n ) ) NEW_LINE"],"bleu":0.9149470026658431,"rouge_l":0.9551486199575373}
{"id":1220,"predictions":["def calcNodes ( N , I ) : NEW_LINE INDENT result = 0 NEW_LINE result = I * ( N - 1 ) + 1 NEW_LINE return result NEW_LINE DEDENT N = 5 NEW_LINE I = 2 NEW_LINE print ( \" Leaf ▁ nodes ▁ = \" , calcNodes ( N , I ) ) NEW_LINE"],"references":["def calcNodes ( N , I ) : NEW_LINE INDENT result = 0 NEW_LINE result = I * ( N - 1 ) + 1 NEW_LINE return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 NEW_LINE I = 2 NEW_LINE print ( \" Leaf ▁ nodes ▁ = ▁ \" , calcNodes ( N , I ) ) NEW_LINE DEDENT"],"bleu":0.7223310689467696,"rouge_l":0.8634984833164813}
{"id":1221,"predictions":["def countSum ( arr , n ) : NEW_LINE INDENT NumberOfOddss = 0 NEW_LINE NumberOfEvens = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] % 2 == 1 : NEW_LINE INDENT NumberOfOdds += 1 NEW_LINE DEDENT DEDENT NumberOfEvens = n - NumberOfOdds NEW_LINE NumberOfOddSubsequences = ( 1 << NumberOfOdds ) * ( 1 << ( NumberOfOdd - 1 ) ) NEW_LINE NumberOfEvenSubsequences = ( 1 << n ) - 1 - NumberOfOddSubsequences NEW_LINE return [ NumberOfEvenSubsequences ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE ans = countSum ( arr , n ) NEW_LINE print ( \" EvenSum ▁ = \" , ans [ 0 ] ) NEW_LINE print ( \" EvenSum ▁ = \" , ans [ 1 ] ) NEW_LINE print ( \" OddSum ▁ = ▁ \" , ans [ 1 ] ) NEW_LINE DEDENT"],"references":["def countSum ( arr , n ) : NEW_LINE INDENT NumberOfOdds = 0 ; NumberOfEvens = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT NumberOfOdds += 1 ; NEW_LINE DEDENT DEDENT NumberOfEvens = n - NumberOfOdds ; NEW_LINE NumberOfOddSubsequences = ( 1 << NumberOfEvens ) *   \\ NEW_LINE INDENT ( 1 << ( NumberOfOdds - 1 ) ) ; NEW_LINE DEDENT NumberOfEvenSubsequences = ( 1 << n ) - 1 -   \\ NEW_LINE INDENT NumberOfOddSubsequences ; NEW_LINE DEDENT return ( NumberOfEvenSubsequences , NumberOfOddSubsequences ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 2 , 3 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE ans = countSum ( arr , n ) ; NEW_LINE print ( \" EvenSum ▁ = \" , ans [ 0 ] , end = \" ▁ \" ) ; NEW_LINE print ( \" OddSum ▁ = \" , ans [ 1 ] ) ; NEW_LINE DEDENT"],"bleu":0.6402129793098615,"rouge_l":0.8331386467786863}
{"id":1222,"predictions":["from math import * NEW_LINE def findMinNumber ( n ) : NEW_LINE INDENT count = 0 ; ans = 1 ; NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE n \/\/= 2 ; NEW_LINE DEDENT if ( count % 3 != 0 ) : NEW_LINE INDENT ans *= pow ( 2 , ( count % 3 ) ) ; NEW_LINE DEDENT for i in range ( 3 , int ( sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE n \/\/= i ; NEW_LINE DEDENT if ( count % 3 != 0 ) : NEW_LINE INDENT ans *= pow ( i , ( count % 3 ) ) ; NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT ans *= n ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 128 ; NEW_LINE print ( findMinNumber ( n ) ) ; NEW_LINE DEDENT"],"references":["def findMinNumber ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE ans = 1 ; NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE n \/= 2 ; NEW_LINE DEDENT if ( count % 3 != 0 ) : NEW_LINE INDENT ans *= pow ( 2 , ( count % 3 ) ) ; NEW_LINE DEDENT for i in range ( 3 , int ( pow ( n , 1 \/ 2 ) ) , 2 ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE n \/= i ; NEW_LINE DEDENT if ( count % 3 != 0 ) : NEW_LINE INDENT ans *= pow ( i , ( count % 3 ) ) ; NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT ans *= n ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 128 ; NEW_LINE print ( findMinNumber ( n ) ) ; NEW_LINE DEDENT"],"bleu":0.8796132895076973,"rouge_l":0.9438870940316272}
{"id":1223,"predictions":["def is_vow ( c ) : NEW_LINE INDENT return ( c == ' a ' ) or ( c == ' e ' ) or ( c == ' o ' ) or ( c == ' o ' ) or ( c == ' u ' ) ) ; NEW_LINE DEDENT def removeVowels ( str ) : NEW_LINE INDENT print ( str [ 0 ] ) ; NEW_LINE for i in range ( 1 , len ( str ) ) : NEW_LINE INDENT if ( ( not ( is_vow ( str [ i - 1 ] ) ) or ( is_vow ( str [ i ] ) == False ) ) : NEW_LINE INDENT print ( str [ i ] , end = \" \" ) ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeks ▁ for ▁ geeks \" ; NEW_LINE removeVowels ( str ) ; NEW_LINE DEDENT"],"references":["def is_vow ( c ) : NEW_LINE INDENT return ( ( c == ' a ' ) or ( c == ' e ' ) or ( c == ' i ' ) or ( c == ' o ' ) or ( c == ' u ' ) ) ; NEW_LINE DEDENT def removeVowels ( str ) : NEW_LINE INDENT print ( str [ 0 ] , end = \" \" ) ; NEW_LINE for i in range ( 1 , len ( str ) ) : NEW_LINE INDENT if ( ( is_vow ( str [ i - 1 ] ) != True ) or ( is_vow ( str [ i ] ) != True ) ) : NEW_LINE INDENT print ( str [ i ] , end = \" \" ) ; NEW_LINE DEDENT DEDENT DEDENT str = \" ▁ geeks ▁ for ▁ geeks \" ; NEW_LINE removeVowels ( str ) ; NEW_LINE"],"bleu":0.8206063131285055,"rouge_l":0.906408007429574}
{"id":1224,"predictions":["def areacircumscribed ( a ) : NEW_LINE INDENT PI = 3.14159265 NEW_LINE return ( a * a * ( PI \/ 2 ) ) NEW_LINE DEDENT a = 6 NEW_LINE print ( \" Area ▁ of ▁ a ▁ circumscribed ( a ) ) NEW_LINE print ( \" Area ▁ of ▁ a ▁ circumscribed ( a ) ) NEW_LINE"],"references":["PI = 3.14159265 NEW_LINE def areacircumscribed ( a ) : NEW_LINE INDENT return ( a * a * ( PI \/ 2 ) ) NEW_LINE DEDENT a = 6 NEW_LINE print ( \" ▁ Area ▁ of ▁ an ▁ circumscribed ▁ circle ▁ is ▁ : \" , round ( areacircumscribed ( a ) , 2 ) ) NEW_LINE"],"bleu":0.6029055124566732,"rouge_l":0.7166666666666666}
{"id":1225,"predictions":["import math NEW_LINE def breakEvenPoint ( exp , S , M ) : NEW_LINE INDENT sell = S - M NEW_LINE exp = exp1 NEW_LINE res = exp1 NEW_LINE res = int ( exp \/ ( exp ) ) NEW_LINE return res1 NEW_LINE DEDENT exp = 3550 NEW_LINE S = 90 NEW_LINE M = 65 NEW_LINE print ( breakEvenPoint ( exp , S , M ) ) NEW_LINE"],"references":["import math NEW_LINE def breakEvenPoint ( exp , S , M ) : NEW_LINE INDENT earn = S - M NEW_LINE res = math . ceil ( exp \/ earn ) NEW_LINE return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT exp = 3550 NEW_LINE S = 90 NEW_LINE M = 65 NEW_LINE print ( int ( breakEvenPoint ( exp , S , M ) ) ) NEW_LINE DEDENT"],"bleu":0.5855048115121072,"rouge_l":0.7365831842576029}
{"id":1226,"predictions":["MAX = 256 NEW_LINE def countPairs ( s ) : NEW_LINE INDENT cnt = [ 0 for i in range ( MAX ) ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT cnt [ ord ( s [ i ] ) ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT ans += cnt [ i ] * cnt [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT s = \" geeksforgeeks \" NEW_LINE print ( countPairs ( s ) ) NEW_LINE"],"references":["MAX = 256 NEW_LINE def countPairs ( s ) : NEW_LINE INDENT cnt = [ 0 for i in range ( 0 , MAX ) ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT cnt [ ord ( s [ i ] ) - 97 ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 0 , MAX ) : NEW_LINE INDENT ans += cnt [ i ] * cnt [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" geeksforgeeks \" NEW_LINE print ( countPairs ( s ) ) NEW_LINE DEDENT"],"bleu":0.7616825938740218,"rouge_l":0.8915172517703782}
{"id":1227,"predictions":["def sumOfSeries ( n ) : NEW_LINE INDENT return 0.0246 * ( pow ( 10 , n ) - 1 - ( 9 * n ) ) NEW_LINE DEDENT n = 3 NEW_LINE print ( sumOfSeries ( n ) ) NEW_LINE"],"references":["import math NEW_LINE def sumOfSeries ( n ) : NEW_LINE INDENT return 0.0246 * ( math . pow ( 10 , n ) - 1 - ( 9 * n ) ) NEW_LINE DEDENT n = 3 NEW_LINE print ( sumOfSeries ( n ) ) NEW_LINE"],"bleu":0.8513275084307346,"rouge_l":0.9328608728086535}
{"id":1228,"predictions":["def maxLenSub ( arr , n ) : NEW_LINE INDENT mls = [ 1 for i in range ( n ) ] NEW_LINE max = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT mls [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( abs ( arr [ i ] - arr [ j ] ) <= 1 and mls [ i ] < mls [ j ] + 1 ) : NEW_LINE INDENT mls [ i ] = mls [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( max < mls [ i ] ) : NEW_LINE INDENT max = mls [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT arr = [ 2 , 5 , 6 , 3 , 7 , 6 , 5 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Maximum ▁ length ▁ subsequence ▁ = ▁ \" , maxLenSub ( arr , n ) ) NEW_LINE"],"references":["def maxLenSub ( arr , n ) : NEW_LINE INDENT mls = [ ] NEW_LINE max = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mls . append ( 1 ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( abs ( arr [ i ] - arr [ j ] ) <= 1 and mls [ i ] < mls [ j ] + 1 ) : NEW_LINE INDENT mls [ i ] = mls [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( max < mls [ i ] ) : NEW_LINE INDENT max = mls [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT arr = [ 2 , 5 , 6 , 3 , 7 , 6 , 5 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Maximum ▁ length ▁ subsequence ▁ = ▁ \" , maxLenSub ( arr , n ) ) NEW_LINE"],"bleu":0.8949823748717043,"rouge_l":0.9535320748270264}
{"id":1229,"predictions":["mod = 1000000007 NEW_LINE dp = [ [ [ - 1 for i in range ( 1000 ) ] for j in range ( 1000 ) ] NEW_LINE def calculate ( pos , prev , s , s , index ) : NEW_LINE INDENT if ( pos == len ( s ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( dp [ pos ] [ prev ] != - 1 ) : NEW_LINE INDENT return dp [ pos ] [ prev ] NEW_LINE DEDENT answer = 0 NEW_LINE for i in range ( len ( index ) ) : NEW_LINE INDENT if ( index [ i ] >= prev ) : NEW_LINE INDENT answer = ( answer % mod + calculate ( pos + 1 , index [ i ] , s , index ) % mod ) % mod NEW_LINE DEDENT DEDENT dp [ pos ] [ prev ] = answer NEW_LINE return dp [ pos ] [ prev ] NEW_LINE DEDENT def countWays ( a , s ) : NEW_LINE INDENT n = len ( a ) NEW_LINE index = [ ] NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT for j in range ( len ( a [ i ] ) ) : NEW_LINE INDENT index [ ord ( a [ i ] ) - ord ( ' a ' ) ] . append ( j + 1 ) NEW_LINE DEDENT DEDENT return calculate ( 0 , 0 , s , index [ 0 ] ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ \" adc \" , \" aec \" NEW_LINE S = \" ac \" NEW_LINE print ( countWays ( A , S ) ) NEW_LINE DEDENT"],"references":["mod = 1000000007 NEW_LINE dp = [ [ - 1 for i in range ( 1000 ) ] for j in range ( 1000 ) ] ; NEW_LINE def calculate ( pos , prev , s , index ) : NEW_LINE INDENT if ( pos == len ( s ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( dp [ pos ] [ prev ] != - 1 ) : NEW_LINE INDENT return dp [ pos ] [ prev ] NEW_LINE DEDENT c = ord ( s [ pos ] ) - ord ( ' a ' ) ; NEW_LINE answer = 0 NEW_LINE for i in range ( len ( index ) ) : NEW_LINE INDENT if ( index [ i ] > prev ) : NEW_LINE INDENT answer = ( answer % mod + calculate ( pos + 1 , index [ i ] , s , index ) % mod ) % mod NEW_LINE DEDENT DEDENT dp [ pos ] [ prev ] = 4 NEW_LINE return dp [ pos ] [ prev ] NEW_LINE DEDENT def countWays ( a , s ) : NEW_LINE INDENT n = len ( a ) NEW_LINE index = [ [ ] for i in range ( 26 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( len ( a [ i ] ) ) : NEW_LINE INDENT index [ ord ( a [ i ] [ j ] ) - ord ( ' a ' ) ] . append ( j + 1 ) ; NEW_LINE DEDENT DEDENT return calculate ( 0 , 0 , s , index [ 0 ] ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ ] NEW_LINE A . append ( \" adc \" ) NEW_LINE A . append ( \" aec \" ) NEW_LINE A . append ( \" erg \" ) NEW_LINE S = \" ac \" NEW_LINE print ( countWays ( A , S ) ) NEW_LINE DEDENT"],"bleu":0.7773681947722303,"rouge_l":0.8820605512878447}
{"id":1230,"predictions":["def divisibleBy36 ( num ) : NEW_LINE INDENT l = len ( num ) NEW_LINE if ( l == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( l == 1 and num [ 0 ] != '0' ) : NEW_LINE INDENT return False NEW_LINE DEDENT two_digit_num = ( ( num [ l - 2 ] ) * 10 + ( ord ( num [ l - 1 ] ) - ord ( '0' ) ) ) * 10 + ( ord ( num [ l - 1 ] ) - ord ( '0' ) ) ) NEW_LINE if ( two_digit_num % 4 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT sum += ( ord ( num [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT if ( sum % 9 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT num = \"925678127966231384\" NEW_LINE if ( divisibleBy36 ( num ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def divisibleBy36 ( num ) : NEW_LINE INDENT l = len ( num ) NEW_LINE if ( l == 0 ) : NEW_LINE INDENT return ( \" No \" ) NEW_LINE DEDENT if ( l == 1 and num [ 0 ] != '0' ) : NEW_LINE INDENT return ( \" No \" ) NEW_LINE DEDENT two_digit_num = ( ( ( int ) ( num [ l - 2 ] ) ) * 10 + ( int ) ( num [ l - 1 ] ) ) NEW_LINE if ( two_digit_num % 4 != 0 ) : NEW_LINE INDENT return \" No \" NEW_LINE DEDENT sm = 0 NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT sm = sm + ( int ) ( num [ i ] ) NEW_LINE DEDENT if ( sm % 9 != 0 ) : NEW_LINE INDENT return ( \" No \" ) NEW_LINE DEDENT return ( \" Yes \" ) NEW_LINE DEDENT num = \"92567812197966231384\" NEW_LINE print ( divisibleBy36 ( num ) ) NEW_LINE"],"bleu":0.5854523782782527,"rouge_l":0.7194871794871794}
{"id":1231,"predictions":["sum = [ 0 ] * 1000005 for i in range ( 1000005 ) : NEW_LINE INDENT return - ord ( '0' ) NEW_LINE DEDENT def query ( s ) : NEW_LINE INDENT sum [ 0 ] = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT sum [ i + 1 ] = sum [ i ] + int ( s [ i ] ) NEW_LINE DEDENT DEDENT def query ( l , r ) : NEW_LINE INDENT if ( ( sum [ r + 1 ] - sum [ l ] ) % 3 == 0 ) : NEW_LINE INDENT print ( \" Divisible ▁ by ▁ 3\" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No ▁ divisible ▁ by ▁ 3\" ) NEW_LINE DEDENT DEDENT def query ( l , r ) : NEW_LINE INDENT if ( ( ( sum [ r + 1 ] - sum [ l ] ) % 3 == 0 ) ) : NEW_LINE INDENT print ( \" Divisible ▁ by ▁ 3\" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ divisible ▁ by ▁ 3\" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = \"12461646464646\" NEW_LINE convertSum ( n ) NEW_LINE query ( 0 , 1 ) NEW_LINE query ( 0 , 1 ) NEW_LINE query ( 0 , 2 ) NEW_LINE query ( 0 , 10 , 6 ) NEW_LINE DEDENT"],"references":["sum = [ 0 for i in range ( 1000005 ) ] NEW_LINE def toInt ( x ) : NEW_LINE INDENT return int ( x ) NEW_LINE DEDENT def prepareSum ( s ) : NEW_LINE INDENT sum [ 0 ] = 0 NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT sum [ i + 1 ] = sum [ i ] + toInt ( s [ i ] ) NEW_LINE DEDENT DEDENT def query ( l , r ) : NEW_LINE INDENT if ( ( sum [ r + 1 ] - sum [ l ] ) % 3 == 0 ) : NEW_LINE INDENT print ( \" Divisible ▁ by ▁ 3\" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ divisible ▁ by ▁ 3\" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = \"12468236544\" NEW_LINE prepareSum ( n ) NEW_LINE query ( 0 , 1 ) NEW_LINE query ( 1 , 2 ) NEW_LINE query ( 3 , 6 ) NEW_LINE query ( 0 , 10 ) NEW_LINE DEDENT"],"bleu":0.6188749739430712,"rouge_l":0.7889908256880733}
{"id":1232,"predictions":["def distanceum ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE res = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res += ( arr [ i ] * i - sum ) NEW_LINE sum += arr [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT def totaldistsum ( x , y , n ) : NEW_LINE INDENT return distanceum ( x , n ) + distanceum ( y , n ) NEW_LINE DEDENT x = [ - 1 , 1 , 3 , 2 ] NEW_LINE y = [ 5 , 6 , 5 , 3 ] NEW_LINE n = len ( x ) NEW_LINE print ( totaldistumerum ( x , y , n ) ) NEW_LINE"],"references":["def distancesum ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE res = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res += ( arr [ i ] * i - sum ) NEW_LINE sum += arr [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT def totaldistancesum ( x , y , n ) : NEW_LINE INDENT return distancesum ( x , n ) + distancesum ( y , n ) NEW_LINE DEDENT x = [ - 1 , 1 , 3 , 2 ] NEW_LINE y = [ 5 , 6 , 5 , 3 ] NEW_LINE n = len ( x ) NEW_LINE print ( totaldistancesum ( x , y , n ) ) NEW_LINE"],"bleu":0.9088619931640681,"rouge_l":0.9618320610687022}
{"id":1233,"predictions":["def squareSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( 2 * i ) * ( 2 * i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT print ( squareSum ( 8 ) ) NEW_LINE"],"references":["def squareSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT sum += ( 2 * i ) * ( 2 * i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT ans = squareSum ( 8 ) NEW_LINE print ( ans ) NEW_LINE"],"bleu":0.8080228813157888,"rouge_l":0.9031684927450401}
{"id":1234,"predictions":["def findAndSum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE mul = 1 NEW_LINE for i in range ( 30 ) : NEW_LINE INDENT count_on = False NEW_LINE l = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( arr [ j ] & ( 1 << i ) ) : NEW_LINE INDENT if ( count_on ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_on = True NEW_LINE l += 1 NEW_LINE DEDENT elif ( count_on ) : NEW_LINE INDENT sum_on = True NEW_LINE l = 0 NEW_LINE DEDENT elif ( count_on ) : NEW_LINE INDENT sum += ( ( mul * l * ( l + 1 ) ) ) \/\/ 2 ) NEW_LINE count_on = False NEW_LINE l = 0 NEW_LINE DEDENT DEDENT if ( count_on ) : NEW_LINE INDENT sum += ( ( mul * l + 1 ) ) \/\/ 2 ) NEW_LINE count_on = False NEW_LINE l = 0 NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT arr = [ 7 , 1 , 1 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findAndSum ( arr , n ) ) NEW_LINE"],"references":["import math as mt NEW_LINE def findAndSum ( arr , n ) : NEW_LINE INDENT Sum = 0 NEW_LINE mul = 1 NEW_LINE for i in range ( 30 ) : NEW_LINE INDENT count_on = 0 NEW_LINE l = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( ( arr [ j ] & ( 1 << i ) ) > 0 ) : NEW_LINE INDENT if ( count_on ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_on = 1 NEW_LINE l += 1 NEW_LINE DEDENT DEDENT elif ( count_on ) : NEW_LINE INDENT Sum += ( ( mul * l * ( l + 1 ) ) \/\/ 2 ) NEW_LINE count_on = 0 NEW_LINE l = 0 NEW_LINE DEDENT DEDENT if ( count_on ) : NEW_LINE INDENT Sum += ( ( mul * l * ( l + 1 ) ) \/\/ 2 ) NEW_LINE count_on = 0 NEW_LINE l = 0 NEW_LINE DEDENT mul *= 2 NEW_LINE DEDENT return Sum NEW_LINE DEDENT arr = [ 7 , 1 , 1 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findAndSum ( arr , n ) ) NEW_LINE"],"bleu":0.8077485974204514,"rouge_l":0.8823529411764706}
{"id":1235,"predictions":["def isAlphabaticOrder ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE c = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT c [ i ] = s [ i ] NEW_LINE DEDENT c . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( c [ i ] != s [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT s = \" aabbbcc \" NEW_LINE if ( isAlphaticOrder ( s ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def isAlphabaticOrder ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE c = [ s [ i ] for i in range ( len ( s ) ) ] NEW_LINE c . sort ( reverse = False ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( c [ i ] != s [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" aabbbcc \" NEW_LINE if ( isAlphabaticOrder ( s ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.749153637829553,"rouge_l":0.8217115689381933}
{"id":1236,"predictions":["class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def push ( self , new_data ) : NEW_LINE INDENT new_node = Node ( new_data ) NEW_LINE new_node . next = None NEW_LINE new_node . prev = None NEW_LINE new_node . prev = None NEW_LINE if head is not None : NEW_LINE INDENT self . head . prev = new_node NEW_LINE DEDENT new_node = Node ( new_data ) NEW_LINE new_node . prev = new_node NEW_LINE new_node . prev = new_node NEW_LINE new_node . prev = new_node NEW_LINE new_node . prev = new_node NEW_LINE if new_node . next is not None : NEW_LINE INDENT new_node . prev = new_node NEW_LINE DEDENT new_node . next = new_node NEW_LINE new_node . prev = new_node NEW_LINE new_node . prev = new_node NEW_LINE if new_node . next is not None : NEW_LINE INDENT new_node . prev = new_node NEW_LINE DEDENT DEDENT new_node = Node ( new_data ) NEW_LINE new_node . next = new_node NEW_LINE new_node . next = new_node NEW_LINE new_node . next = new_node NEW_LINE new_node . next = new_node NEW_LINE new_node . next = new_node NEW_LINE new_node . next = new_node NEW_LINE new_node . next = new_node NEW_LINE new_node . next = new_node NEW_LINE new_node . next = new_node NEW_LINE DEDENT def insert ( node ) : NEW_LINE INDENT last = Node ( new_node ) NEW_LINE new_node . next = new_node NEW_LINE new_node . next = new_node NEW_LINE new_node . next = new_node NEW_LINE new_node . next = new_node NEW_LINE new_node . next = new_node"],"references":["class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE self . prev = None NEW_LINE DEDENT DEDENT class DoublyLinkedList : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . head = None NEW_LINE DEDENT def push ( self , new_data ) : NEW_LINE INDENT new_node = Node ( new_data ) NEW_LINE new_node . next = self . head NEW_LINE if self . head is not None : NEW_LINE INDENT self . head . prev = new_node NEW_LINE DEDENT self . head = new_node NEW_LINE DEDENT def insertAfter ( self , prev_node , new_data ) : NEW_LINE INDENT if prev_node is None : NEW_LINE INDENT print \" the ▁ given ▁ previous ▁ node ▁ cannot ▁ be ▁ NULL \" NEW_LINE return NEW_LINE DEDENT new_node = Node ( new_data ) NEW_LINE new_node . next = prev_node . next NEW_LINE prev_node . next = new_node NEW_LINE new_node . prev = prev_node NEW_LINE if new_node . next is not None : NEW_LINE INDENT new_node . next . prev = new_node NEW_LINE DEDENT DEDENT def append ( self , new_data ) : NEW_LINE INDENT new_node = Node ( new_data ) NEW_LINE new_node . next = None NEW_LINE if self . head is None : NEW_LINE INDENT new_node . prev = None NEW_LINE self . head = new_node NEW_LINE return NEW_LINE DEDENT last = self . head NEW_LINE while ( last . next is not None ) : NEW_LINE INDENT last = last . next NEW_LINE DEDENT last . next = new_node NEW_LINE new_node . prev = last NEW_LINE return NEW_LINE DEDENT def printList ( self , node ) : NEW_LINE INDENT print \" \\n Traversal ▁ in ▁ forward ▁ direction \" NEW_LINE while ( node is not None ) : NEW_LINE INDENT print \" ▁ % ▁ d \" % ( node . data ) , NEW_LINE last = node NEW_LINE node = node . next NEW_LINE DEDENT print \" \\n Traversal ▁ in ▁ reverse ▁ direction \" NEW_LINE while ( last is not None ) : NEW_LINE INDENT print \" ▁ % ▁ d \" % ( last . data ) , NEW_LINE last = last . prev NEW_LINE DEDENT DEDENT DEDENT llist = DoublyLinkedList ( ) NEW_LINE llist . append ( 6 ) NEW_LINE llist . push ( 7 ) NEW_LINE llist . push ( 1 ) NEW_LINE llist . append ( 4 ) NEW_LINE llist . insertAfter ( llist . head . next , 8 ) NEW_LINE print \" Created ▁ DLL ▁ is : ▁ \" , NEW_LINE llist . printList ( llist . head ) NEW_LINE"],"bleu":0.3080144533022163,"rouge_l":0.4819740080307413}
{"id":1237,"predictions":["size = 10001 NEW_LINE prime = [ 0 ] * size NEW_LINE freq = [ 0 ] * size NEW_LINE def sieve ( a , b ) : NEW_LINE INDENT prime [ 1 ] = 1 NEW_LINE i = 2 NEW_LINE while ( i * i < size ) : NEW_LINE INDENT if ( prime [ i ] == 0 ) : NEW_LINE INDENT j = i * 2 NEW_LINE while ( j < size ) : NEW_LINE INDENT prime [ j ] = 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT for p in range ( 1 , size ) : NEW_LINE INDENT for q in range ( 1 , size ) : NEW_LINE INDENT if ( prime [ p ] == 0 and prime [ q ] == 0 and a * q + b < size ) : NEW_LINE INDENT freq [ a * p + b + b ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT queries = 2 NEW_LINE a = 1 NEW_LINE b = 2 NEW_LINE sieve ( a , b ) NEW_LINE arr = [ 15 , 25 ] NEW_LINE for i in range ( queries ) : NEW_LINE INDENT print ( freq [ arr [ i ] ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT"],"references":["from math import sqrt NEW_LINE size = 1000 NEW_LINE prime = [ 0 for i in range ( size ) ] NEW_LINE freq = [ 0 for i in range ( size ) ] NEW_LINE def sieve ( a , b ) : NEW_LINE INDENT prime [ 1 ] = 1 NEW_LINE for i in range ( 2 , int ( sqrt ( size ) ) + 1 , 1 ) : NEW_LINE INDENT if ( prime [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i * 2 , size , i ) : NEW_LINE INDENT prime [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT for p in range ( 1 , size , 1 ) : NEW_LINE INDENT for q in range ( 1 , size , 1 ) : NEW_LINE INDENT if ( prime [ p ] == 0 and prime [ q ] == 0 and a * p + b * q < size ) : NEW_LINE INDENT freq [ a * p + b * q ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT queries = 2 NEW_LINE a = 1 NEW_LINE b = 2 NEW_LINE sieve ( a , b ) NEW_LINE arr = [ 15 , 25 ] NEW_LINE for i in range ( queries ) : NEW_LINE INDENT print ( freq [ arr [ i ] ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.720339218184637,"rouge_l":0.8375753516409912}
{"id":1238,"predictions":["def replaceConsonants ( str ) : NEW_LINE INDENT res = \" \" \" NEW_LINE i = 0 NEW_LINE count = 0 NEW_LINE while ( i < len ( str ) ) : NEW_LINE INDENT if ( str [ i ] != ' a ' and str [ i ] != ' i ' and str [ i ] != ' u ' ) : NEW_LINE INDENT i += 1 NEW_LINE count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( count > 0 ) : NEW_LINE INDENT res += count NEW_LINE DEDENT res += str [ i ] NEW_LINE i += 1 NEW_LINE count = 0 NEW_LINE DEDENT DEDENT if ( count > 0 ) : NEW_LINE INDENT res += count NEW_LINE DEDENT return res NEW_LINE DEDENT str = \" abcde \" NEW_LINE print ( replaceConsonants ( str ) ) NEW_LINE"],"references":["def replaceConsonants ( string ) : NEW_LINE INDENT res = \" \" ; NEW_LINE i = 0 ; count = 0 ; NEW_LINE while ( i < len ( string ) ) : NEW_LINE INDENT if ( string [ i ] != ' a ' and string [ i ] != ' e ' and string [ i ] != ' i ' and string [ i ] != ' o ' and string [ i ] != ' u ' ) : NEW_LINE INDENT i += 1 ; NEW_LINE count += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( count > 0 ) : NEW_LINE INDENT res += str ( count ) ; NEW_LINE DEDENT res += string [ i ] ; NEW_LINE i += 1 NEW_LINE count = 0 ; NEW_LINE DEDENT DEDENT if ( count > 0 ) : NEW_LINE INDENT res += str ( count ) ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" abcdeiop \" ; NEW_LINE print ( replaceConsonants ( string ) ) ; NEW_LINE DEDENT"],"bleu":0.4958573891167611,"rouge_l":0.7691049085659287}
{"id":1239,"predictions":["def count ( S , m , n ) : NEW_LINE INDENT table = [ [ 0 ] * ( n + 1 ) for i in range ( n + 1 ) ] NEW_LINE table [ 0 ] = 1 NEW_LINE for i in range ( m ) : NEW_LINE INDENT table [ 0 ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT table [ 0 ] = 1 NEW_LINE for j in range ( m ) : NEW_LINE INDENT for j in range ( S [ i ] , n + 1 ) : NEW_LINE INDENT table [ j ] += table [ j - S [ i ] ] ] NEW_LINE DEDENT DEDENT DEDENT return table [ n ] NEW_LINE DEDENT return table [ n ] NEW_LINE DEDENT def count ( S , m , n ) : NEW_LINE INDENT table = [ ] NEW_LINE table [ 0 ] = 1 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( S [ i ] , n + 1 ) : NEW_LINE INDENT table [ j ] = table [ j ] [ j - S [ i ] ] NEW_LINE DEDENT DEDENT return table [ n ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S [ 0 ] = 1 NEW_LINE print ( count ( S , m , n ) ) NEW_LINE DEDENT"],"references":["def count ( S , m , n ) : NEW_LINE INDENT table = [ 0 for k in range ( n + 1 ) ] NEW_LINE table [ 0 ] = 1 NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT for j in range ( S [ i ] , n + 1 ) : NEW_LINE INDENT table [ j ] += table [ j - S [ i ] ] NEW_LINE DEDENT DEDENT return table [ n ] NEW_LINE DEDENT arr = [ 1 , 2 , 3 ] NEW_LINE m = len ( arr ) NEW_LINE n = 4 NEW_LINE x = count ( arr , m , n ) NEW_LINE print ( x ) NEW_LINE"],"bleu":0.3586267373740784,"rouge_l":0.6077847099357483}
{"id":1240,"predictions":["def minReplacement ( str ) : NEW_LINE INDENT if ( len ( str ) > 26 ) : NEW_LINE INDENT print ( \" IMPOSSIBLE \" ) NEW_LINE DEDENT else : NEW_LINE INDENT hash = [ 0 for i in range ( 26 ) ] NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT hash [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( hash [ ord ( str [ i ] ) - ord ( ' a ' ) ] > 1 ) : NEW_LINE INDENT for j in range ( 26 ) : NEW_LINE INDENT if ( hash [ ord ( str [ i ] ) - ord ( ' a ' ) ] ] -= 1 NEW_LINE str [ j ] += 1 NEW_LINE str [ j ] += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( str ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" xxxxyyyy \" NEW_LINE minReplacement ( str ) NEW_LINE DEDENT"],"references":["def minReplacement ( string ) : NEW_LINE INDENT if len ( string ) > 26 : NEW_LINE INDENT print ( \" IMPOSSIBLE \" ) NEW_LINE DEDENT else : NEW_LINE INDENT Hash = [ 0 ] * 26 NEW_LINE for i in range ( 0 , len ( string ) ) : NEW_LINE INDENT Hash [ ord ( string [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 0 , len ( string ) ) : NEW_LINE INDENT if Hash [ ord ( string [ i ] ) - ord ( ' a ' ) ] > 1 : NEW_LINE INDENT for j in range ( 0 , 26 ) : NEW_LINE INDENT if Hash [ j ] == 0 : NEW_LINE INDENT Hash [ ord ( string [ i ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE string [ i ] = chr ( j + ord ( ' a ' ) ) NEW_LINE Hash [ j ] += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( ' ' . join ( string ) ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" xxxxyyyy \" NEW_LINE minReplacement ( list ( string ) ) NEW_LINE DEDENT"],"bleu":0.5902482706747332,"rouge_l":0.7893634527638567}
{"id":1241,"predictions":["N = 3 NEW_LINE def findStepsForDDM ( arr ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( N ) : NEW_LINE INDENT sum += abs ( arr [ i ] [ j ] ) NEW_LINE DEDENT sum -= abs ( arr [ i ] [ i ] ) NEW_LINE if ( abs ( arr [ i ] [ i ] ) < abs ( sum ) ) : NEW_LINE INDENT result += abs ( arr [ i ] [ i ] ) - abs ( sum ) ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , - 2 , 1 ] , [ 1 , - 3 , 2 ] , [ - 1 , 2 , 4 ] ] NEW_LINE print ( findStepsForDDM ( arr ) ) NEW_LINE DEDENT"],"references":["N = 3 NEW_LINE def findStepsForDDM ( arr ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( N ) : NEW_LINE INDENT sum += abs ( arr [ i ] [ j ] ) NEW_LINE DEDENT sum -= abs ( arr [ i ] [ i ] ) NEW_LINE if ( abs ( arr [ i ] [ i ] ) < abs ( sum ) ) : NEW_LINE INDENT result += abs ( abs ( arr [ i ] [ i ] ) - abs ( sum ) ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT arr = [ [ 3 , - 2 , 1 ] , [ 1 , - 3 , 2 ] , [ - 1 , 2 , 4 ] ] NEW_LINE print ( findStepsForDDM ( arr ) ) NEW_LINE"],"bleu":0.8994793215105986,"rouge_l":0.9526321232805876}
{"id":1242,"predictions":["from math import pow NEW_LINE def isArmstrong ( x , n ) : NEW_LINE INDENT sum1 = 0 NEW_LINE temp = x NEW_LINE while ( temp ) : NEW_LINE INDENT digit = temp % 10 NEW_LINE sum1 += pow ( digit , n ) NEW_LINE temp \/\/= 10 NEW_LINE DEDENT return sum1 == x NEW_LINE DEDENT def CalculateXORandOR ( n ) : NEW_LINE INDENT CalculateXOR = 0 NEW_LINE start = int ( pow ( 10 , n - 1 ) ) NEW_LINE end = ( pow ( 10 , n ) ) - 1 NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT if ( isArmstrong ( i , n ) ) : NEW_LINE INDENT CalculateXOR = CalculateXOR ^ i NEW_LINE CalculateOR = CalculateOR | i NEW_LINE DEDENT DEDENT print ( \" XOR ▁ = \" , CalculateXOR ) NEW_LINE print ( \" XOR ▁ = \" , CalculateOR ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 NEW_LINE CalculateXORandOR ( n ) NEW_LINE DEDENT"],"references":["def isArmstrong ( x , n ) : NEW_LINE INDENT sum1 = 0 NEW_LINE temp = x NEW_LINE while temp > 0 : NEW_LINE INDENT digit = temp % 10 NEW_LINE sum1 += digit ** n NEW_LINE temp \/\/= 10 NEW_LINE DEDENT return sum1 == x NEW_LINE DEDENT def CalculateXORandOR ( n ) : NEW_LINE INDENT CalculateXOR = 0 NEW_LINE CalculateOR = 0 NEW_LINE start = 10 ** ( n - 1 ) NEW_LINE end = ( 10 ** n ) - 1 NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT if ( isArmstrong ( i , n ) ) : NEW_LINE INDENT CalculateXOR = CalculateXOR ^ i NEW_LINE CalculateOR = CalculateOR | i NEW_LINE DEDENT DEDENT print ( \" XOR ▁ = ▁ \" , CalculateXOR ) NEW_LINE print ( \" OR ▁ = ▁ \" , CalculateOR ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 ; NEW_LINE CalculateXORandOR ( n ) ; NEW_LINE DEDENT"],"bleu":0.7786036304094679,"rouge_l":0.8989711743442396}
{"id":1243,"predictions":["import math NEW_LINE def decToOctal ( n ) : NEW_LINE INDENT octalNum = [ 0 ] * 100 NEW_LINE i = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT octalNum [ i ] = n % 8 NEW_LINE n = n \/\/ 8 NEW_LINE i += 1 NEW_LINE DEDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( octalNum [ j ] , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def nDigitPerfectSquares ( n ) : NEW_LINE INDENT decimal = pow ( math . ceil ( math . ceil ( pow ( 8 , n ) ) ) - 1 , 2 ) NEW_LINE decToOctal ( decimal ) NEW_LINE DEDENT n = 2 NEW_LINE nDigitPerfectSquares ( n ) NEW_LINE"],"references":["from math import sqrt , ceil NEW_LINE def decToOctal ( n ) : NEW_LINE INDENT octalNum = [ 0 ] * 100 ; NEW_LINE i = 0 ; NEW_LINE while ( n != 0 ) : NEW_LINE INDENT octalNum [ i ] = n % 8 ; NEW_LINE n = n \/\/ 8 ; NEW_LINE i += 1 ; NEW_LINE DEDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( octalNum [ j ] , end = \" \" ) ; NEW_LINE DEDENT print ( ) ; NEW_LINE DEDENT def nDigitPerfectSquares ( n ) : NEW_LINE INDENT decimal = pow ( ceil ( sqrt ( pow ( 8 , n ) ) ) - 1 , 2 ) ; NEW_LINE decToOctal ( decimal ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 2 ; NEW_LINE nDigitPerfectSquares ( n ) ; NEW_LINE DEDENT"],"bleu":0.6693213597909285,"rouge_l":0.8641339343206696}
{"id":1244,"predictions":["def getFinalElement ( n ) : NEW_LINE INDENT finalnum = 2 NEW_LINE while ( finalNum * 2 <= n ) : NEW_LINE INDENT finalNum *= 2 NEW_LINE DEDENT return finalNum NEW_LINE DEDENT N = 12 NEW_LINE print ( getFinalElement ( N ) ) NEW_LINE"],"references":["def getFinalElement ( n ) : NEW_LINE INDENT finalNum = 2 NEW_LINE while finalNum * 2 <= n : NEW_LINE INDENT finalNum *= 2 NEW_LINE DEDENT return finalNum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 12 NEW_LINE print ( getFinalElement ( N ) ) NEW_LINE DEDENT"],"bleu":0.5959385851892666,"rouge_l":0.8026315789473683}
{"id":1245,"predictions":["def maxSum ( arr , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT ans = arr [ 0 ] + arr [ 1 ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = min ( ans , ( arr [ i ] + arr [ i + 1 ] ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 12 , 2 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxSum ( arr , n ) ) NEW_LINE"],"references":["def maxSum ( arr , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT ans = arr [ 0 ] + arr [ 1 ] NEW_LINE for i in range ( 1 , n - 1 , 1 ) : NEW_LINE INDENT ans = min ( ans , ( arr [ i ] + arr [ i + 1 ] ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 12 , 2 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxSum ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.82538074994326,"rouge_l":0.9087523277467411}
{"id":1246,"predictions":["def findCount ( str ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( i == ( ord ( str [ i ] ) - ord ( ' a ' ) ) or i == ( ord ( str [ i ] ) - ord ( ' A ' ) ) ) ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT str = \" AbgdeF \" NEW_LINE print ( findCount ( str ) ) NEW_LINE"],"references":["def findCount ( str ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( ( i == ord ( str [ i ] ) - ord ( ' a ' ) ) or ( i == ord ( str [ i ] ) - ord ( ' A ' ) ) ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT str = ' AbgdeF ' NEW_LINE print ( findCount ( str ) ) NEW_LINE"],"bleu":0.8697124180435107,"rouge_l":0.952279581337591}
{"id":1247,"predictions":["def power ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT elif ( y % 2 == 0 ) : NEW_LINE INDENT return power ( x , int ( y \/ 2 ) ) * power ( x , int ( y \/ 2 ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return x * power ( x , int ( y \/ 2 ) ) * power ( x , int ( y \/ 2 ) ) ; NEW_LINE DEDENT DEDENT def sieveOfEratosthenes ( n , isPrime ) : NEW_LINE INDENT isPrime [ 0 ] = isPrime [ 1 ] = False ; NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT isPrime [ i ] = True ; NEW_LINE DEDENT for p in range ( 2 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( isPrime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT isPrime [ i ] = False ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def leftTruosthenes ( n ) : NEW_LINE INDENT temp = n ; cnt = 0 ; NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE temp1 = temp % 10 ; NEW_LINE if ( temp1 == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT temp = temp \/\/ 10 ; NEW_LINE DEDENT isPrime = [ 0 ] * ( n + 1 ) ; NEW_LINE sieveOfEratosthenes ( n , isPrime ) ; NEW_LINE for i in range ( cnt , 0 , - 1 ) : NEW_LINE INDENT mod = power ( 10 , i ) ; NEW_LINE if ( not isPrime [ n % mod ] ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 127 ; NEW_LINE if ( leftT"],"references":["def power ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( y % 2 == 0 ) : NEW_LINE INDENT return ( power ( x , y \/\/ 2 ) * power ( x , y \/\/ 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( x * power ( x , y \/\/ 2 ) * power ( x , y \/\/ 2 ) ) NEW_LINE DEDENT DEDENT def sieveOfEratosthenes ( n , isPrime ) : NEW_LINE INDENT isPrime [ 0 ] = isPrime [ 1 ] = False NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT isPrime [ i ] = True NEW_LINE DEDENT p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( isPrime [ p ] == True ) : NEW_LINE INDENT i = p * 2 NEW_LINE while ( i <= n ) : NEW_LINE INDENT isPrime [ i ] = False NEW_LINE i = i + p NEW_LINE DEDENT DEDENT p = p + 1 NEW_LINE DEDENT DEDENT def leftTruPrime ( n ) : NEW_LINE INDENT temp = n NEW_LINE cnt = 0 NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE temp1 = temp % 10 ; NEW_LINE if ( temp1 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT temp = temp \/\/ 10 NEW_LINE DEDENT isPrime = [ None ] * ( n + 1 ) NEW_LINE sieveOfEratosthenes ( n , isPrime ) NEW_LINE for i in range ( cnt , 0 , - 1 ) : NEW_LINE INDENT mod = power ( 10 , i ) NEW_LINE if ( isPrime [ n % mod ] != True ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT n = 113 NEW_LINE if ( leftTruPrime ( n ) ) : NEW_LINE INDENT print ( n , \" is ▁ left ▁ truncatable ▁ prime \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n , \" is ▁ not ▁ left ▁ truncatable ▁ prime \" ) NEW_LINE DEDENT"],"bleu":0.6227082484272892,"rouge_l":0.786032890290606}
{"id":1248,"predictions":["def findExtraCharcter ( strA , strB ) : NEW_LINE INDENT m1 = [ 0 ] * 256 NEW_LINE for i in range ( n ) : NEW_LINE INDENT m1 [ strB [ i ] ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT m1 [ strA [ i ] ] -= 1 NEW_LINE DEDENT for i in range ( len ( m1 ) ) : NEW_LINE INDENT if ( m1 [ i ] == 1 ) : NEW_LINE INDENT return chr ( i ) NEW_LINE DEDENT DEDENT return - 10 ** 9 NEW_LINE DEDENT strA = \" abcd \" NEW_LINE strB = \" cbdad \" NEW_LINE print ( findExtraCharcter ( strA , strB ) ) NEW_LINE"],"references":["def findExtraCharacter ( strA , strB ) : NEW_LINE INDENT m1 = { } NEW_LINE for i in strB : NEW_LINE INDENT if i in m1 : NEW_LINE INDENT m1 [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m1 [ i ] = 1 NEW_LINE DEDENT DEDENT for i in strA : NEW_LINE INDENT m1 [ i ] -= 1 NEW_LINE DEDENT for h1 in m1 : NEW_LINE INDENT if m1 [ h1 ] == 1 : NEW_LINE INDENT return h1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT strA = ' abcd ' NEW_LINE strB = ' cbdad ' NEW_LINE print ( findExtraCharacter ( strA , strB ) ) NEW_LINE DEDENT"],"bleu":0.40517625439957416,"rouge_l":0.6250998136811285}
{"id":1249,"predictions":["def AvgofSquareN ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( i * i ) NEW_LINE DEDENT return int ( sum \/ n ) NEW_LINE DEDENT n = 2 NEW_LINE print ( AvgofSquareN ( n ) ) NEW_LINE"],"references":["def AvgofSquareN ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( i * i ) NEW_LINE DEDENT return sum \/ n NEW_LINE DEDENT n = 2 NEW_LINE print ( AvgofSquareN ( n ) ) NEW_LINE"],"bleu":0.8900196368705081,"rouge_l":0.9773276904474001}
{"id":1250,"predictions":["def lcm_fun ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return lcm_fun ( b , a % b ) NEW_LINE DEDENT def digitLCM ( n ) : NEW_LINE INDENT lcm = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT lcm = ( n % 10 * lcm ) \/\/ lcm_fun ( n % 10 , lcm ) NEW_LINE if ( lcm == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT n = n \/\/ 10 NEW_LINE DEDENT return lcm NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 397 NEW_LINE print ( digitLCM ( n ) ) NEW_LINE DEDENT"],"references":["def lcm_fun ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a ; NEW_LINE DEDENT return lcm_fun ( b , a % b ) ; NEW_LINE DEDENT def digitLCM ( n ) : NEW_LINE INDENT lcm = 1 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT lcm = int ( ( n % 10 * lcm ) \/ lcm_fun ( n % 10 , lcm ) ) ; NEW_LINE if ( lcm == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT n = int ( n \/ 10 ) ; NEW_LINE DEDENT return lcm ; NEW_LINE DEDENT n = 397 ; NEW_LINE print ( digitLCM ( n ) ) ; NEW_LINE"],"bleu":0.7059193771500799,"rouge_l":0.8668421052631577}
{"id":1251,"predictions":["def fact ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n * fact ( n - 1 ) NEW_LINE DEDENT def nPr ( n , r ) : NEW_LINE INDENT return fact ( n ) \/\/ fact ( n - r ) NEW_LINE DEDENT n = 5 NEW_LINE r = 2 NEW_LINE print ( n , \" P \" , r , \" = \" , nPr ( n , r ) ) NEW_LINE"],"references":["import math NEW_LINE def fact ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n * fact ( n - 1 ) NEW_LINE DEDENT def nPr ( n , r ) : NEW_LINE INDENT return math . floor ( fact ( n ) \/ fact ( n - r ) ) NEW_LINE DEDENT n = 5 NEW_LINE r = 2 NEW_LINE print ( n , \" P \" , r , \" = \" , nPr ( n , r ) ) NEW_LINE"],"bleu":0.859483926037616,"rouge_l":0.9369353089989158}
{"id":1252,"predictions":["def isPossible ( a , n ) : NEW_LINE INDENT cur = a [ 0 ] NEW_LINE cur -= 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT nxt = a [ i ] NEW_LINE if ( nxt > cur ) : NEW_LINE INDENT nxt -= 1 NEW_LINE DEDENT elif ( nxt < cur ) : NEW_LINE INDENT return False NEW_LINE DEDENT cur = nxt NEW_LINE DEDENT return True NEW_LINE DEDENT a = [ 1 , 2 , 1 , 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE if ( isPossible ( a , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def isPossible ( a , n ) : NEW_LINE INDENT cur = a [ 0 ] ; NEW_LINE cur -= 1 ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT nxt = a [ i ] ; NEW_LINE if ( nxt > cur ) : NEW_LINE INDENT nxt -= 1 ; NEW_LINE DEDENT elif ( nxt < cur ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT cur = nxt ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 2 , 1 , 2 , 3 ] ; NEW_LINE n = len ( a ) ; NEW_LINE if ( isPossible ( a , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"],"bleu":0.7060884214216315,"rouge_l":0.8973657201505303}
{"id":1253,"predictions":["def fact ( n ) : NEW_LINE INDENT num = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT num = num * i NEW_LINE DEDENT return num NEW_LINE DEDENT def Special_Factorial_Number ( k ) : NEW_LINE INDENT for i in range ( 1 , k + 1 ) : NEW_LINE INDENT if ( fact ( i ) % k == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT k = 16 NEW_LINE print ( Special_Factorial_Number ( k ) ) NEW_LINE"],"references":["def fact ( n ) : NEW_LINE INDENT num = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT num = num * i NEW_LINE DEDENT return num NEW_LINE DEDENT def Special_Factorial_Number ( k ) : NEW_LINE INDENT for i in range ( 1 , k + 1 ) : NEW_LINE INDENT if ( fact ( i ) % k == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT k = 16 NEW_LINE print ( Special_Factorial_Number ( k ) ) NEW_LINE DEDENT"],"bleu":0.8476113677549276,"rouge_l":0.9192048733568452}
{"id":1254,"predictions":["mod = 1000000007 NEW_LINE def noOfBinaryStrings ( N , k ) : NEW_LINE INDENT dp = [ 0 for i in range ( 100002 ) ] NEW_LINE dp [ k ] = 2 NEW_LINE for i in range ( k + 1 , N + 1 ) : NEW_LINE INDENT dp [ i ] = ( dp [ i - 1 ] + dp [ i - k ] ) % mod NEW_LINE DEDENT return dp [ N ] NEW_LINE DEDENT N = 4 NEW_LINE K = 2 NEW_LINE print ( noOfBinaryStrings ( N , K ) ) NEW_LINE"],"references":["mod = 1000000007 ; NEW_LINE def noOfBinaryStrings ( N , k ) : NEW_LINE INDENT dp = [ 0 ] * 100002 ; NEW_LINE for i in range ( 1 , K ) : NEW_LINE INDENT dp [ i ] = 1 ; NEW_LINE DEDENT dp [ k ] = 2 ; NEW_LINE for i in range ( k + 1 , N + 1 ) : NEW_LINE INDENT dp [ i ] = ( dp [ i - 1 ] + dp [ i - k ] ) % mod ; NEW_LINE DEDENT return dp [ N ] ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 4 ; NEW_LINE K = 2 ; NEW_LINE print ( noOfBinaryStrings ( N , K ) ) ; NEW_LINE DEDENT"],"bleu":0.5570560405852195,"rouge_l":0.8070743890914001}
{"id":1255,"predictions":["def reverse ( arr , n , k ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT left = i NEW_LINE right = min ( i + k - 1 , n - 1 ) NEW_LINE while left < right : NEW_LINE INDENT arr [ left ] = arr [ left ] NEW_LINE left += 1 NEW_LINE right -= 1 NEW_LINE DEDENT DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 13 , 14 ] NEW_LINE k = 3 NEW_LINE n = len ( arr ) NEW_LINE reverse ( arr , n , k ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT"],"references":["def reverse ( arr , n , k ) : NEW_LINE INDENT for i in range ( 0 , n , 2 * k ) : NEW_LINE INDENT left = i NEW_LINE right = min ( i + k - 1 , n - 1 ) NEW_LINE while ( left < right ) : NEW_LINE INDENT temp = arr [ left ] NEW_LINE arr [ left ] = arr [ right ] NEW_LINE arr [ right ] = temp NEW_LINE left += 1 NEW_LINE right -= 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 ] NEW_LINE k = 3 NEW_LINE n = len ( arr ) NEW_LINE reverse ( arr , n , k ) NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.7037755314562347,"rouge_l":0.8549197757587473}
{"id":1256,"predictions":["MAX = 100 NEW_LINE mat = [ [ 0 for i in range ( MAX ) ] for j in range ( MAX ) ] NEW_LINE def fillRemain ( i , j , n ) : NEW_LINE INDENT x = 2 NEW_LINE for k in range ( i + 1 , n ) : NEW_LINE INDENT mat [ k ] [ j ] = x NEW_LINE DEDENT for k in range ( i ) : NEW_LINE INDENT mat [ k ] [ j ] = x NEW_LINE DEDENT DEDENT def constructRemain ( n ) : NEW_LINE INDENT right = n - 1 NEW_LINE left = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT mat [ i ] [ right ] = 1 NEW_LINE fill ( i , right , n ) NEW_LINE right -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT mat [ i ] [ left ] = 1 NEW_LINE fillRemain ( i , left , n ) NEW_LINE left += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 NEW_LINE constructMatrix ( n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT"],"references":["MAX = 100 ; NEW_LINE mat = [ [ 0 for x in range ( MAX ) ] for y in range ( MAX ) ] ; NEW_LINE def fillRemaining ( i , j , n ) : NEW_LINE INDENT x = 2 ; NEW_LINE for k in range ( i + 1 , n ) : NEW_LINE INDENT mat [ k ] [ j ] = x ; NEW_LINE x += 1 ; NEW_LINE DEDENT for k in range ( i ) : NEW_LINE INDENT mat [ k ] [ j ] = x ; NEW_LINE x += 1 ; NEW_LINE DEDENT DEDENT def constructMatrix ( n ) : NEW_LINE INDENT right = n - 1 ; NEW_LINE left = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT mat [ i ] [ right ] = 1 ; NEW_LINE fillRemaining ( i , right , n ) ; NEW_LINE right -= 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT mat [ i ] [ left ] = 1 ; NEW_LINE fillRemaining ( i , left , n ) ; NEW_LINE left += 1 ; NEW_LINE DEDENT DEDENT DEDENT n = 5 ; NEW_LINE constructMatrix ( n ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( \" \" ) ; NEW_LINE DEDENT"],"bleu":0.7287437273163415,"rouge_l":0.8876691345417412}
{"id":1257,"predictions":["import sys NEW_LINE def printMaxOfMin ( arr , n ) : NEW_LINE INDENT for k in range ( 1 , n + 1 ) : NEW_LINE INDENT maxOfMin = - sys . maxsize - 1 NEW_LINE for i in range ( n - k + 1 ) : NEW_LINE INDENT minOfMin = arr [ i ] NEW_LINE for j in range ( 1 , k ) : NEW_LINE INDENT if ( arr [ i + j ] < min ) : NEW_LINE INDENT min = arr [ i + j ] NEW_LINE DEDENT DEDENT if ( min > maxOfMin ) : NEW_LINE INDENT maxOfMin = min NEW_LINE DEDENT DEDENT print ( maxOfMin , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 10 , 20 , 30 , 50 , 10 , 70 , 30 ] NEW_LINE n = len ( arr ) NEW_LINE printMaxOfMin ( arr , n ) NEW_LINE"],"references":["INT_MIN = - 1000000 NEW_LINE def printMaxOfMin ( arr , n ) : NEW_LINE INDENT for k in range ( 1 , n + 1 ) : NEW_LINE INDENT maxOfMin = INT_MIN ; NEW_LINE for i in range ( n - k + 1 ) : NEW_LINE INDENT min = arr [ i ] NEW_LINE for j in range ( k ) : NEW_LINE INDENT if ( arr [ i + j ] < min ) : NEW_LINE INDENT min = arr [ i + j ] NEW_LINE DEDENT DEDENT if ( min > maxOfMin ) : NEW_LINE INDENT maxOfMin = min NEW_LINE DEDENT DEDENT print ( maxOfMin , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 10 , 20 , 30 , 50 , 10 , 70 , 30 ] NEW_LINE n = len ( arr ) NEW_LINE printMaxOfMin ( arr , n ) NEW_LINE"],"bleu":0.9017333440070213,"rouge_l":0.9430270270270271}
{"id":1258,"predictions":["def countSubArrays ( arr , n , K ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT bitwise_or = 0 NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT bitwise_or = bitwise_or | arr [ k ] NEW_LINE DEDENT if ( bitwise_or >= K ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE k = 6 NEW_LINE print ( countSubArrays ( arr , n , k ) ) NEW_LINE"],"references":["def countSubArrays ( arr , n , K ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT bitwise_or = 0 NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT bitwise_or = bitwise_or | arr [ k ] NEW_LINE DEDENT if ( bitwise_or >= K ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE k = 6 NEW_LINE print ( countSubArrays ( arr , n , k ) ) NEW_LINE DEDENT"],"bleu":0.8589279070370782,"rouge_l":0.9307603538915246}
{"id":1259,"predictions":["CHARS = dict ( ) NEW_LINE MAX = 26 NEW_LINE def getString ( string , n ) : NEW_LINE INDENT uMap = dict ( ) NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT uMap [ ( i + 1 ) ] = CHARS [ ( i + 1 ) % MAX ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT uMap [ ord ( string [ i ] ) ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT string [ i ] = uMap [ string [ i ] ] NEW_LINE DEDENT return string NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" geeks \" NEW_LINE n = len ( string ) NEW_LINE print ( getString ( string , n ) ) NEW_LINE DEDENT"],"references":["CHARS = \" qwertyuiopasdfghjklzxcvbnm \" ; NEW_LINE MAX = 26 ; NEW_LINE def getString ( string , n ) : NEW_LINE INDENT string = list ( string ) ; NEW_LINE uMap = { } ; NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT uMap [ CHARS [ i ] ] = CHARS [ ( i + 1 ) % MAX ] ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT string [ i ] = uMap [ string [ i ] ] ; NEW_LINE DEDENT return \" \" . join ( string ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" geeks \" ; NEW_LINE n = len ( string ) ; NEW_LINE print ( getString ( string , n ) ) ; NEW_LINE DEDENT"],"bleu":0.6593872313278129,"rouge_l":0.7834735167083428}
{"id":1260,"predictions":["def printOrder ( arr , k ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE arr = sort ( ) NEW_LINE arr . sort ( reverse = True ) NEW_LINE arr . sort ( reverse = True ) NEW_LINE return NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 5 , 4 , 6 , 2 , 1 , 3 , 8 , 8 , 9 , - 1 ] NEW_LINE k = 4 NEW_LINE print ( arr ) NEW_LINE DEDENT"],"references":["def printOrder ( arr , n , k ) : NEW_LINE INDENT a = arr [ 0 : k ] ; NEW_LINE a . sort ( ) ; NEW_LINE b = arr [ k : n ] ; NEW_LINE b . sort ( ) ; NEW_LINE b . reverse ( ) ; NEW_LINE return a + b ; NEW_LINE DEDENT arr = [ 5 , 4 , 6 , 2 , 1 , 3 , 8 , 9 , - 1 ] ; NEW_LINE k = 4 ; NEW_LINE n = len ( arr ) ; NEW_LINE arr = printOrder ( arr , n , k ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT"],"bleu":0.3225386973929708,"rouge_l":0.536731843575419}
{"id":1261,"predictions":["import math NEW_LINE def countSteps ( n ) : NEW_LINE INDENT steps = 0 NEW_LINE while ( n ) : NEW_LINE INDENT largest = math . sqrt ( n ) NEW_LINE n -= ( largest * largest ) NEW_LINE steps += 1 NEW_LINE DEDENT return steps NEW_LINE DEDENT n = 85 NEW_LINE print ( countSteps ( n ) ) NEW_LINE"],"references":["from math import sqrt NEW_LINE def countSteps ( n ) : NEW_LINE INDENT steps = 0 ; NEW_LINE while ( n ) : NEW_LINE INDENT largest = int ( sqrt ( n ) ) ; NEW_LINE n -= ( largest * largest ) ; NEW_LINE steps += 1 ; NEW_LINE DEDENT return steps ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 85 ; NEW_LINE print ( countSteps ( n ) ) ; NEW_LINE DEDENT"],"bleu":0.47512251900441443,"rouge_l":0.7685676392572945}
{"id":1262,"predictions":["def Area ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT h = 1. 445 * a NEW_LINE A = 0.70477 * pow ( h , 2 ) NEW_LINE return A NEW_LINE DEDENT a = 5 NEW_LINE print ( Area ( a ) ) NEW_LINE"],"references":["import math NEW_LINE def Area ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT h = 1.268 * a NEW_LINE A = 0.70477 * math . pow ( h , 2 ) NEW_LINE return A NEW_LINE DEDENT a = 5 NEW_LINE print ( Area ( a ) , end = \" \\n \" ) NEW_LINE"],"bleu":0.739798473658808,"rouge_l":0.8723516949152543}
{"id":1263,"predictions":["SIZEIZE = 26 NEW_LINE def isVowel ( ch ) : NEW_LINE INDENT if ( ch == ' a ' or ch == ' e ' or ch == ' i ' or ch == ' u ' ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def createAltStr ( str1 , str2 , start , start , l ) : NEW_LINE INDENT finalStr = \" \" NEW_LINE i = 0 NEW_LINE j = start NEW_LINE while j < l : NEW_LINE INDENT finalStr = ( finalStr + str1 [ i ] ) + str2 [ j ] NEW_LINE i += 1 NEW_LINE DEDENT return finalStr NEW_LINE DEDENT def findAltStr ( str1 , str2 , start , l ) : NEW_LINE INDENT finalStr = \" \" NEW_LINE i = 0 NEW_LINE j = start NEW_LINE while i < l : NEW_LINE INDENT finalStr = ( finalStr + str1 [ i ] ) + str2 [ j ] NEW_LINE j += 1 NEW_LINE DEDENT return finalStr NEW_LINE DEDENT def findAltStr ( str1 ) : NEW_LINE INDENT char_freq = [ 0 ] * SIZE NEW_LINE nv = 0 NEW_LINE vstr = \" \" NEW_LINE cstr = \" \" NEW_LINE l = len ( str1 ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT ch = str1 [ i ] NEW_LINE if ( isVowel ( ch ) ) : NEW_LINE INDENT nv += 1 NEW_LINE DEDENT else : NEW_LINE INDENT nc += 1 NEW_LINE DEDENT char_freq [ ch - 97 ] += 1 NEW_LINE DEDENT if ( abs ( nv [ ch ] ) >= 2 ) : NEW_LINE INDENT return \" no ▁ such \" NEW_LINE DEDENT for i in range ( 1 , len ( str1 ) ) : NEW_LINE INDENT ch = ( ch1 ) ( ch2 ) ( i + 97 ) ) NEW_LINE for j in range ( 1 , ord ( ch ) ) : NEW_LINE INDENT if ( isVow ( ch ) ) : NEW_LINE INDENT"],"references":["SIZE = 26 NEW_LINE def isVowel ( ch ) : NEW_LINE INDENT if ( ch == ' a ' or ch == ' e ' or ch == ' i ' or ch == ' o ' or ch == ' u ' ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def createAltStr ( str1 , str2 , start , l ) : NEW_LINE INDENT finalStr = \" \" NEW_LINE i = 0 NEW_LINE j = start NEW_LINE while j < l : NEW_LINE INDENT finalStr += str1 [ i ] + str2 [ j ] NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT return finalStr NEW_LINE DEDENT def findAltStr ( string ) : NEW_LINE INDENT char_freq = [ 0 ] * SIZE NEW_LINE nv = 0 NEW_LINE nc = 0 NEW_LINE vstr = \" \" NEW_LINE cstr = \" \" NEW_LINE l = len ( string ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT ch = string [ i ] NEW_LINE if isVowel ( ch ) : NEW_LINE INDENT nv += 1 NEW_LINE DEDENT else : NEW_LINE INDENT nc += 1 NEW_LINE DEDENT char_freq [ ord ( ch ) - 97 ] += 1 NEW_LINE DEDENT if abs ( nv - nc ) >= 2 : NEW_LINE INDENT return \" no ▁ such ▁ string \" NEW_LINE DEDENT for i in range ( SIZE ) : NEW_LINE INDENT ch = chr ( i + 97 ) NEW_LINE for j in range ( 1 , char_freq [ i ] + 1 ) : NEW_LINE INDENT if isVowel ( ch ) : NEW_LINE INDENT vstr += ch NEW_LINE DEDENT else : NEW_LINE INDENT cstr += ch NEW_LINE DEDENT DEDENT DEDENT if nv > nc : NEW_LINE INDENT return vstr [ 0 ] + createAltStr ( cstr , vstr , 1 , nv ) NEW_LINE DEDENT if nc > nv : NEW_LINE INDENT return cstr [ 0 ] + createAltStr ( vstr , cstr , 1 , nc ) NEW_LINE DEDENT if cstr [ 0 ] < vstr [ 0 ] : NEW_LINE INDENT return createAltStr ( cstr , vstr , 0 , nv ) NEW_LINE DEDENT return createAltStr ( vstr , cstr , 0 , nc ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" aeroplane \" NEW_LINE print ( findAltStr ( string ) ) NEW_LINE DEDENT"],"bleu":0.561831752386157,"rouge_l":0.6500369709886478}
{"id":1264,"predictions":["N = 5 NEW_LINE M = 5 NEW_LINE def minOperation ( arr ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( M - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] [ j ] == True ) : NEW_LINE INDENT ans += 1 NEW_LINE for k in range ( i + 1 , j + 1 ) : NEW_LINE INDENT if ( arr [ k ] [ h ] == True ) : NEW_LINE INDENT arr [ k ] [ h ] = False NEW_LINE DEDENT else : NEW_LINE INDENT arr [ k ] [ h ] = True NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT mat = [ [ 0 , 0 , 1 , 1 , 1 , 1 ] , [ 0 , 0 , 0 , 1 , 1 , 1 ] , [ 1 , 0 , 1 , 1 , 1 ] , [ 1 , 1 , 1 , 1 , 1 ] ] NEW_LINE print ( minOperation ( mat ) ) NEW_LINE DEDENT"],"references":["def minOperation ( arr ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( M - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] [ j ] == 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE for k in range ( i + 1 ) : NEW_LINE INDENT for h in range ( j + 1 ) : NEW_LINE INDENT if ( arr [ k ] [ h ] == 1 ) : NEW_LINE INDENT arr [ k ] [ h ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ k ] [ h ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT mat = [ [ 0 , 0 , 1 , 1 , 1 ] , [ 0 , 0 , 0 , 1 , 1 ] , [ 0 , 0 , 0 , 1 , 1 ] , [ 1 , 1 , 1 , 1 , 1 ] , [ 1 , 1 , 1 , 1 , 1 ] ] NEW_LINE M = 5 NEW_LINE N = 5 NEW_LINE print ( minOperation ( mat ) ) NEW_LINE"],"bleu":0.8493543632508793,"rouge_l":0.8554378636431448}
{"id":1265,"predictions":["def decToOctal ( n ) : NEW_LINE INDENT octal = [ 0 ] * 100 ; NEW_LINE i = 0 ; NEW_LINE while ( n ) : NEW_LINE INDENT octalNum [ i ] = n % 8 ; NEW_LINE n = n \/\/ 8 ; NEW_LINE i += 1 ; NEW_LINE DEDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( octal [ j ] , end = \" \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 33 ; decToOctal ( n ) ; NEW_LINE DEDENT"],"references":["def decToOctal ( n ) : NEW_LINE INDENT octalNum = [ 0 ] * 100 ; NEW_LINE i = 0 ; NEW_LINE while ( n != 0 ) : NEW_LINE INDENT octalNum [ i ] = n % 8 ; NEW_LINE n = int ( n \/ 8 ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( octalNum [ j ] , end = \" \" ) ; NEW_LINE DEDENT DEDENT n = 33 ; NEW_LINE decToOctal ( n ) ; NEW_LINE"],"bleu":0.7468482905121574,"rouge_l":0.8833696667704765}
{"id":1266,"predictions":["def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT def isFactorial ( n ) : NEW_LINE INDENT if ( isPrime ( n ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT fact = 1 NEW_LINE i = 1 NEW_LINE while ( fact <= n + 1 ) : NEW_LINE INDENT fact = fact * i NEW_LINE if ( n + 1 == fact or n - 1 == fact ) : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT n = 23 NEW_LINE if ( isFactorialPrime ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["from math import sqrt NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 5 , int ( sqrt ( n ) ) + 1 , 6 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def isFactorialPrime ( n ) : NEW_LINE INDENT if ( not isPrime ( n ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT fact = 1 NEW_LINE i = 1 NEW_LINE while ( fact <= n + 1 ) : NEW_LINE INDENT fact = fact * i NEW_LINE if ( n + 1 == fact or n - 1 == fact ) : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 23 NEW_LINE if ( isFactorialPrime ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.8043669637588359,"rouge_l":0.8817916399629708}
{"id":1267,"predictions":["def convert ( m , n ) : NEW_LINE INDENT if ( m == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( m > n ) : NEW_LINE INDENT return m - n NEW_LINE DEDENT if ( m <= 0 and n > 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return 1 + convert ( m , n + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return 1 + convert ( m , n \/ 2 ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT m = 3 NEW_LINE n = 11 NEW_LINE print ( \" Minimum ▁ number ▁ of ▁ solutions ▁ : ▁ \" , convert ( m , n ) ) NEW_LINE DEDENT"],"references":["def conver ( m , n ) : NEW_LINE INDENT if ( m == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( m > n ) : NEW_LINE INDENT return m - n NEW_LINE DEDENT if ( m <= 0 and n > 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return 1 + conver ( m , n + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return 1 + conver ( m , n \/ 2 ) NEW_LINE DEDENT DEDENT m = 3 NEW_LINE n = 11 NEW_LINE print ( \" Minimum ▁ number ▁ of ▁ operations ▁ : \" , conver ( m , n ) ) NEW_LINE"],"bleu":0.7930186138427049,"rouge_l":0.9169008920933645}
{"id":1268,"predictions":["MAX = 1000000 NEW_LINE prime = [ True for i in range ( MAX ) ] NEW_LINE def sieve ( ) : NEW_LINE INDENT p = 2 NEW_LINE while ( p * p <= MAX ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT def printPrimeQuad ( n ) : NEW_LINE INDENT for i in range ( n - 7 ) : NEW_LINE INDENT if ( prime [ i ] and prime [ i + 2 ] and prime [ i + 6 ] and prime [ i + 6 ] ) : NEW_LINE INDENT print ( i , ( i + 2 ) , ( i + 6 ) , ( i + 8 ) ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 25 NEW_LINE printPrime ( n ) NEW_LINE printPrimeQuad ( n ) NEW_LINE DEDENT"],"references":["from math import sqrt NEW_LINE MAX = 100000 NEW_LINE prime = [ True ] * MAX NEW_LINE def sieve ( ) : NEW_LINE INDENT for p in range ( 2 , int ( sqrt ( MAX ) ) + 1 ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def printPrimeQuad ( n ) : NEW_LINE INDENT for i in range ( n - 7 ) : NEW_LINE INDENT if ( prime [ i ] and prime [ i + 2 ] and prime [ i + 6 ] and prime [ i + 8 ] ) : NEW_LINE INDENT print ( i , i + 2 , i + 6 , i + 8 ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT sieve ( ) NEW_LINE n = 20 NEW_LINE printPrimeQuad ( 20 ) NEW_LINE DEDENT"],"bleu":0.6968237308210693,"rouge_l":0.8338879395629103}
{"id":1269,"predictions":["def sum ( mat , r , c ) : NEW_LINE INDENT upper_sum = 0 NEW_LINE lower_sum = 0 NEW_LINE for i in range ( r ) : NEW_LINE INDENT for j in range ( c ) : NEW_LINE INDENT upper_sum += mat [ i ] [ j ] NEW_LINE DEDENT DEDENT print ( \" Upper ▁ sum ▁ is \" , upper_sum ) NEW_LINE for i in range ( r ) : NEW_LINE INDENT for j in range ( c ) : NEW_LINE INDENT if ( i <= j ) : NEW_LINE INDENT upper_sum += mat [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT print ( \" Lower ▁ sum ▁ is \" , lower_sum ) NEW_LINE DEDENT print ( \" Lower ▁ sum ▁ is \" , lower_sum ) NEW_LINE DEDENT r = 3 NEW_LINE c = 3 NEW_LINE mat = [ [ 6 , 5 , 4 ] , [ 1 , 2 , 5 ] , [ 7 , 9 , 9 , 7 ] ] NEW_LINE sum ( mat , r , c ) NEW_LINE"],"references":["def Sum ( mat , r , c ) : NEW_LINE INDENT i , j = 0 , 0 ; NEW_LINE upper_sum = 0 ; NEW_LINE lower_sum = 0 ; NEW_LINE for i in range ( r ) : NEW_LINE INDENT for j in range ( c ) : NEW_LINE INDENT if ( i <= j ) : NEW_LINE INDENT upper_sum += mat [ i ] [ j ] ; NEW_LINE DEDENT DEDENT DEDENT print ( \" Upper ▁ sum ▁ is ▁ \" , upper_sum ) ; NEW_LINE for i in range ( r ) : NEW_LINE INDENT for j in range ( c ) : NEW_LINE INDENT if ( j <= i ) : NEW_LINE INDENT lower_sum += mat [ i ] [ j ] ; NEW_LINE DEDENT DEDENT DEDENT print ( \" Lower ▁ sum ▁ is ▁ \" , lower_sum ) ; NEW_LINE DEDENT r = 3 ; NEW_LINE c = 3 ; NEW_LINE mat = [ [ 6 , 5 , 4 ] , [ 1 , 2 , 5 ] , [ 7 , 9 , 7 ] ] ; NEW_LINE Sum ( mat , r , c ) ; NEW_LINE"],"bleu":0.7171539269783931,"rouge_l":0.8488232262497852}
{"id":1270,"predictions":["def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT def removeMin ( arr , n ) : NEW_LINE INDENT minVal = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT minVal = min ( minVal , arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = arr [ i ] - minVal NEW_LINE DEDENT DEDENT def removeFromMax ( arr , n ) : NEW_LINE INDENT maxVal = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT maxVal = max ( maxVal , arr [ i ] ) NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT arr [ i ] = maxVal - arr [ i ] NEW_LINE DEDENT DEDENT def replaceArray ( arr , n , k ) : NEW_LINE INDENT if ( k % 2 == 0 ) : NEW_LINE INDENT removeMin ( arr , n ) NEW_LINE DEDENT else : NEW_LINE INDENT removeFromMax ( arr , n ) NEW_LINE DEDENT printArray ( arr , n ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 4 , 8 , 12 , 15 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE removeArray ( arr , n , k ) NEW_LINE DEDENT"],"references":["def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT def removeMin ( arr , n ) : NEW_LINE INDENT minVal = arr [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT minVal = min ( minVal , arr [ i ] ) ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = arr [ i ] - minVal ; NEW_LINE DEDENT DEDENT def removeFromMax ( arr , n ) : NEW_LINE INDENT maxVal = arr [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT maxVal = max ( maxVal , arr [ i ] ) ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = maxVal - arr [ i ] ; NEW_LINE DEDENT DEDENT def modifyArray ( arr , n , k ) : NEW_LINE INDENT if ( k % 2 == 0 ) : NEW_LINE INDENT removeMin ( arr , n ) ; NEW_LINE DEDENT else : NEW_LINE INDENT removeFromMax ( arr , n ) ; NEW_LINE DEDENT printArray ( arr , n ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 4 , 8 , 12 , 16 ] ; NEW_LINE n = len ( arr ) NEW_LINE k = 2 ; NEW_LINE modifyArray ( arr , n , k ) ; NEW_LINE DEDENT"],"bleu":0.8536052915056974,"rouge_l":0.9579811784451236}
{"id":1271,"predictions":["def LongestSubarray ( a , n , k ) : NEW_LINE INDENT pre = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] > k ) : NEW_LINE INDENT pre [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT pre [ i ] = - 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT pre [ i ] = pre [ i - 1 ] + pre [ i ] NEW_LINE DEDENT len = 0 NEW_LINE lo = 1 NEW_LINE hi = n NEW_LINE while ( lo <= hi ) : NEW_LINE INDENT mid = ( lo + hi ) \/\/ 2 NEW_LINE ok = False NEW_LINE for i in range ( mid - 1 , n ) : NEW_LINE INDENT x = pre [ i ] NEW_LINE if ( i - mid >= 0 ) : NEW_LINE INDENT x -= pre [ i - mid ] NEW_LINE DEDENT if ( x > 0 ) : NEW_LINE INDENT ok = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( ok == True ) : NEW_LINE INDENT Len = mid NEW_LINE lo = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT hi = mid - 1 NEW_LINE DEDENT DEDENT return Len NEW_LINE DEDENT a = [ 2 , 3 , 4 , 5 , 3 , 7 ] NEW_LINE k = 3 NEW_LINE n = len ( a ) NEW_LINE print ( LongestSubarray ( a , n , k ) ) NEW_LINE"],"references":["def LongestSubarray ( a , n , k ) : NEW_LINE INDENT pre = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] > k ) : NEW_LINE INDENT pre [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT pre [ i ] = - 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT pre [ i ] = pre [ i - 1 ] + pre [ i ] NEW_LINE DEDENT Len = 0 NEW_LINE lo = 1 NEW_LINE hi = n NEW_LINE while ( lo <= hi ) : NEW_LINE INDENT mid = ( lo + hi ) \/\/ 2 NEW_LINE ok = False NEW_LINE for i in range ( mid - 1 , n ) : NEW_LINE INDENT x = pre [ i ] NEW_LINE if ( i - mid >= 0 ) : NEW_LINE INDENT x -= pre [ i - mid ] NEW_LINE DEDENT if ( x > 0 ) : NEW_LINE INDENT ok = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( ok == True ) : NEW_LINE INDENT Len = mid NEW_LINE lo = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT hi = mid - 1 NEW_LINE DEDENT DEDENT return Len NEW_LINE DEDENT a = [ 2 , 3 , 4 , 5 , 3 , 7 ] NEW_LINE k = 3 NEW_LINE n = len ( a ) NEW_LINE print ( LongestSubarray ( a , n , k ) ) NEW_LINE"],"bleu":0.9906275896386185,"rouge_l":0.996268656716418}
{"id":1272,"predictions":["def findSum ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT ans += ( i \/\/ j ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT N = 2 NEW_LINE print ( findSum ( N ) ) NEW_LINE"],"references":["def findSum ( N ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 1 , N + 1 ) : NEW_LINE INDENT ans += i \/\/ j NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT N = 2 NEW_LINE print ( findSum ( N ) ) NEW_LINE"],"bleu":0.8027357080673733,"rouge_l":0.9410723318158826}
{"id":1273,"predictions":["def permutation ( arr , n ) : NEW_LINE INDENT hash = set ( ) NEW_LINE maxEle = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash . add ( arr [ i ] ) NEW_LINE maxEle = max ( maxEle , arr [ i ] ) NEW_LINE DEDENT if ( maxEle != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( len ( hash ) == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT arr = [ 1 , 2 , 5 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE if ( permutation ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def permutation ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE maxEle = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . add ( arr [ i ] ) ; NEW_LINE maxEle = max ( maxEle , arr [ i ] ) ; NEW_LINE DEDENT if ( maxEle != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( len ( s ) == n ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 5 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE if ( permutation ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.7668913866878254,"rouge_l":0.9053803339517627}
{"id":1274,"predictions":["N = 5 NEW_LINE def printHosoya ( n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( N ) ] for j in range ( N ) ] NEW_LINE dp [ 0 ] [ 0 ] = dp [ 1 ] [ 0 ] = 1 NEW_LINE dp [ 1 ] [ 1 ] = 1 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( i > j ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 2 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + dp [ i - 2 ] [ j - 2 ] ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT print ( dp [ i ] [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT n = 5 NEW_LINE printHosoya ( n ) NEW_LINE"],"references":["N = 5 NEW_LINE def printHosoya ( n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( N ) ] for i in range ( N ) ] NEW_LINE dp [ 0 ] [ 0 ] = dp [ 1 ] [ 0 ] = dp [ 1 ] [ 1 ] = 1 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( i > j ) : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + dp [ i - 2 ] [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 2 ] [ j - 2 ] ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT print ( dp [ i ] [ j ] , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT n = 5 NEW_LINE printHosoya ( n ) NEW_LINE"],"bleu":0.9279878759892327,"rouge_l":0.9715428743961351}
{"id":1275,"predictions":["def pairs_count ( arr , n , sum ) : NEW_LINE INDENT ans = 0 ; NEW_LINE arr . sort ( ) ; NEW_LINE i = 0 ; j = n - 1 ; NEW_LINE while ( i < j ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] < sum ) : NEW_LINE INDENT i += 1 ; NEW_LINE DEDENT elif ( arr [ i ] + arr [ j ] > sum ) : NEW_LINE INDENT j -= 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT x = arr [ i ] ; NEW_LINE xx = i ; NEW_LINE while ( ( i < j ) and ( arr [ i ] == x ) ) : NEW_LINE INDENT i += 1 ; NEW_LINE DEDENT y = arr [ j ] ; NEW_LINE y = arr [ j ] ; NEW_LINE while ( ( j >= i and ( arr [ j ] == y ) ) : NEW_LINE INDENT j -= 1 ; NEW_LINE DEDENT if ( x == y ) : NEW_LINE INDENT temp = i - xx + yy - 1 ; NEW_LINE ans += ( temp * ( temp + 1 ) ) ) \/ 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( i - xx ) * ( yy - j ) ) ; NEW_LINE DEDENT DEDENT DEDENT return ans ; NEW_LINE DEDENT arr = [ 1 , 5 , 7 , 5 , - 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE sum = 6 ; NEW_LINE print ( pairs_count ( arr , n , sum ) ) ; NEW_LINE"],"references":["def pairs_count ( arr , n , sum ) : NEW_LINE INDENT ans = 0 NEW_LINE arr = sorted ( arr ) NEW_LINE i , j = 0 , n - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] < sum ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT elif ( arr [ i ] + arr [ j ] > sum ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT x = arr [ i ] NEW_LINE xx = i NEW_LINE while ( i < j and arr [ i ] == x ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT y = arr [ j ] NEW_LINE yy = j NEW_LINE while ( j >= i and arr [ j ] == y ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT if ( x == y ) : NEW_LINE INDENT temp = i - xx + yy - j - 1 NEW_LINE ans += ( temp * ( temp + 1 ) ) \/\/ 2 NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( i - xx ) * ( yy - j ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 5 , 7 , 5 , - 1 ] NEW_LINE n = len ( arr ) NEW_LINE sum = 6 NEW_LINE print ( pairs_count ( arr , n , sum ) ) NEW_LINE"],"bleu":0.7170172830018863,"rouge_l":0.9187999752060992}
{"id":1276,"predictions":["MAX = 10005 NEW_LINE fibonacci = set ( ) NEW_LINE def createHash ( ) : NEW_LINE INDENT prev = 0 NEW_LINE curr = 1 NEW_LINE fibonacci . add ( prev ) NEW_LINE fibonacci . add ( curr ) NEW_LINE while curr <= MAX : NEW_LINE INDENT temp = curr + prev NEW_LINE fibonacci . add ( temp ) NEW_LINE prev = curr NEW_LINE curr = temp NEW_LINE DEDENT DEDENT def checkArray ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if fibonacci . count in arr [ i ] : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT DEDENT if ( fibonacci . keys ( ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 8 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE createHash ( ) NEW_LINE if checkArray ( arr , n ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["MAX = 100005 NEW_LINE fibonacci = set ( ) NEW_LINE def createHash ( ) : NEW_LINE INDENT global fibonacci NEW_LINE prev , curr = 0 , 1 NEW_LINE fibonacci . add ( prev ) NEW_LINE fibonacci . add ( curr ) NEW_LINE while ( curr <= MAX ) : NEW_LINE INDENT temp = curr + prev NEW_LINE if temp <= MAX : NEW_LINE INDENT fibonacci . add ( temp ) NEW_LINE DEDENT prev = curr NEW_LINE curr = temp NEW_LINE DEDENT DEDENT def checkArray ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] in fibonacci ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT DEDENT if ( sum in fibonacci ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 8 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE createHash ( ) NEW_LINE if ( checkArray ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.8124159807048138,"rouge_l":0.9061767005473026}
{"id":1277,"predictions":["def makearrayequal ( arr , n ) : NEW_LINE INDENT x = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT x += ( arr [ i ] & 1 ) ; NEW_LINE DEDENT print ( min ( x , n - x ) ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 4 , 3 , 2 , 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE makearrayequal ( arr , n ) ; NEW_LINE DEDENT"],"references":["def makearrayequal ( arr , n ) : NEW_LINE INDENT x = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT x += arr [ i ] & 1 ; NEW_LINE DEDENT print ( min ( x , n - x ) ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 4 , 3 , 2 , 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE makearrayequal ( arr , n ) ; NEW_LINE DEDENT"],"bleu":0.9464905905577607,"rouge_l":0.9912633234317665}
{"id":1278,"predictions":["def countRotations ( arr , n ) : NEW_LINE INDENT min = arr [ 0 ] NEW_LINE min_index = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( min > arr [ arr [ i ] ] ) : NEW_LINE INDENT min = arr [ i ] NEW_LINE min_index = i NEW_LINE DEDENT DEDENT return min_index NEW_LINE DEDENT arr = [ 15 , 18 , 2 , 3 , 6 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countRotations ( arr , n ) ) NEW_LINE"],"references":["def countRotations ( arr , n ) : NEW_LINE INDENT min = arr [ 0 ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( min > arr [ i ] ) : NEW_LINE INDENT min = arr [ i ] NEW_LINE min_index = i NEW_LINE DEDENT DEDENT return min_index ; NEW_LINE DEDENT arr = [ 15 , 18 , 2 , 3 , 6 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countRotations ( arr , n ) ) NEW_LINE"],"bleu":0.8661620259963163,"rouge_l":0.9463134042182326}
{"id":1279,"predictions":["def check ( s ) : NEW_LINE INDENT freq = [ 0 ] * 10 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT freq [ i ] = 0 NEW_LINE DEDENT while ( s != 0 ) : NEW_LINE INDENT r = s % 10 NEW_LINE s = ( s \/\/ 10 ) NEW_LINE freq [ r ] += 1 NEW_LINE DEDENT xor__ = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT xor__ = xor__ ^ freq [ i ] NEW_LINE if ( xor__ == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = 122233 NEW_LINE if ( check ( s ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def check ( s ) : NEW_LINE INDENT freq = [ 0 ] * 10 NEW_LINE while ( s != 0 ) : NEW_LINE INDENT r = s % 10 NEW_LINE s = s \/\/ 10 NEW_LINE freq [ r ] += 1 NEW_LINE DEDENT xor = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT xor = xor ^ freq [ i ] NEW_LINE DEDENT if ( xor == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT s = 122233 NEW_LINE if ( check ( s ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.6655623074051986,"rouge_l":0.8561403508771931}
{"id":1280,"predictions":["def count ( n ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE p = 1 ; NEW_LINE while ( p <= n ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE p *= 2 ; NEW_LINE DEDENT return cnt ; NEW_LINE DEDENT n = 7 ; NEW_LINE print ( count ( n ) ) ; NEW_LINE"],"references":["def count ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE p = 1 NEW_LINE while ( p <= n ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE p *= 2 NEW_LINE DEDENT return cnt NEW_LINE DEDENT n = 7 NEW_LINE print ( count ( n ) ) ; NEW_LINE"],"bleu":0.688606933345639,"rouge_l":0.9150915091509152}
{"id":1281,"predictions":["def powerSet ( string , index , curr ) : NEW_LINE INDENT n = len ( string ) NEW_LINE if index == n : NEW_LINE INDENT return NEW_LINE DEDENT print ( curr ) NEW_LINE for i in range ( index + 1 , n ) : NEW_LINE INDENT curr += string [ i ] NEW_LINE powerSet ( string , i , curr ) NEW_LINE curr = curr [ 0 : len ( curr ) - 1 ] NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" abc \" NEW_LINE index = - 1 NEW_LINE curr = \" \" NEW_LINE powerSet ( string , index , curr ) NEW_LINE DEDENT"],"references":["def powerSet ( str1 , index , curr ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE if ( index == n ) : NEW_LINE INDENT return NEW_LINE DEDENT print ( curr ) NEW_LINE for i in range ( index + 1 , n ) : NEW_LINE INDENT curr += str1 [ i ] NEW_LINE powerSet ( str1 , i , curr ) NEW_LINE curr = curr . replace ( curr [ len ( curr ) - 1 ] , \" \" ) NEW_LINE DEDENT return NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" abc \" ; NEW_LINE powerSet ( str , - 1 , \" \" ) NEW_LINE DEDENT"],"bleu":0.604740776303174,"rouge_l":0.803176326863038}
{"id":1282,"predictions":["def findMinimumX ( a , n ) : NEW_LINE INDENT st = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT st . add ( a [ i ] ) NEW_LINE DEDENT if ( len ( st ) == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( len ( st ) == 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( len ( st ) == 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( len ( st ) == 3 ) : NEW_LINE INDENT return ( st [ len ( st ) ] ) NEW_LINE DEDENT DEDENT if ( len ( st ) == 3 ) : NEW_LINE INDENT elif ( e2 - e1 ) % 2 == 0 ) : NEW_LINE INDENT return ( e2 - e1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( e2 - e ) NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT a = [ 1 , 4 , 4 , 7 , 4 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( findMinimumX ( a , n ) ) NEW_LINE"],"references":["def findMinimumX ( a , n ) : NEW_LINE INDENT st = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT st . add ( a [ i ] ) NEW_LINE DEDENT if ( len ( st ) == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( len ( st ) == 2 ) : NEW_LINE INDENT st = list ( st ) NEW_LINE el1 = st [ 0 ] NEW_LINE el2 = st [ 1 ] NEW_LINE if ( ( el2 - el1 ) % 2 == 0 ) : NEW_LINE INDENT return int ( ( el2 - el1 ) \/ 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( el2 - el1 ) NEW_LINE DEDENT DEDENT if ( len ( st ) == 3 ) : NEW_LINE INDENT st = list ( st ) NEW_LINE el1 = st [ 0 ] NEW_LINE el2 = st [ 1 ] NEW_LINE el3 = st [ 2 ] NEW_LINE if ( ( el2 - el1 ) == ( el3 - el2 ) ) : NEW_LINE INDENT return el2 - el1 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 4 , 4 , 7 , 4 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( findMinimumX ( a , n ) ) NEW_LINE DEDENT"],"bleu":0.5594275295092357,"rouge_l":0.6922855911506967}
{"id":1283,"predictions":["def printFirstNegativeInteger ( arr , n , k ) : NEW_LINE INDENT for i in range ( n - k + 1 ) : NEW_LINE INDENT flag = False NEW_LINE for j in range ( k ) : NEW_LINE INDENT if ( arr [ i + j ] < 0 ) : NEW_LINE INDENT print ( arr [ i + j ] , end = \" ▁ \" ) NEW_LINE flag = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( not flag ) : NEW_LINE INDENT print ( \"0\" , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 10 , - 1 , - 7 , 8 , - 10 , - 10 , 30 , 10 , 20 , 30 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE printFirstNegativeInteger ( arr , n , k ) NEW_LINE DEDENT"],"references":["def printFirstNegativeInteger ( arr , n , k ) : NEW_LINE INDENT for i in range ( 0 , ( n - k + 1 ) ) : NEW_LINE INDENT flag = False NEW_LINE for j in range ( 0 , k ) : NEW_LINE INDENT if ( arr [ i + j ] < 0 ) : NEW_LINE INDENT print ( arr [ i + j ] , end = \" ▁ \" ) NEW_LINE flag = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( not ( flag ) ) : NEW_LINE INDENT print ( \"0\" , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 12 , - 1 , - 7 , 8 , - 15 , 30 , 16 , 28 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE printFirstNegativeInteger ( arr , n , k ) NEW_LINE"],"bleu":0.7754745235628706,"rouge_l":0.8891568791946309}
{"id":1284,"predictions":["def printArray ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE return NEW_LINE DEDENT def printSequencesRecur ( arr , n , k , index ) : NEW_LINE INDENT if ( k == 0 ) : NEW_LINE INDENT printArray ( arr , index ) NEW_LINE DEDENT if ( k > 0 ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT arr [ index ] = i NEW_LINE printSequencesRecur ( arr , n , k - 1 , index + 1 ) NEW_LINE DEDENT DEDENT DEDENT def printSequences ( n , k ) : NEW_LINE INDENT arr = [ 0 ] * k NEW_LINE printSequencesRecur ( arr , n , k , 0 ) NEW_LINE return NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE k = 2 NEW_LINE printSequences ( n , k ) NEW_LINE DEDENT"],"references":["def printArray ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( \" \" ) ; NEW_LINE return ; NEW_LINE DEDENT def printSequencesRecur ( arr , n , k , index ) : NEW_LINE INDENT if ( k == 0 ) : NEW_LINE INDENT printArray ( arr , index ) ; NEW_LINE DEDENT if ( k > 0 ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT arr [ index ] = i ; NEW_LINE printSequencesRecur ( arr , n , k - 1 , index + 1 ) ; NEW_LINE DEDENT DEDENT DEDENT def printSequences ( n , k ) : NEW_LINE INDENT arr = [ 0 ] * n ; NEW_LINE printSequencesRecur ( arr , n , k , 0 ) ; NEW_LINE return ; NEW_LINE DEDENT n = 3 ; NEW_LINE k = 2 ; NEW_LINE printSequences ( n , k ) ; NEW_LINE"],"bleu":0.8127080202356054,"rouge_l":0.9175824175824175}
{"id":1285,"predictions":["n_of_word = 256 NEW_LINE def findSubString ( string , pat ) : NEW_LINE INDENT len1 = len ( string ) NEW_LINE len2 = len ( string ) NEW_LINE if ( len1 < len2 ) : NEW_LINE INDENT print ( \" No ▁ such ▁ window ▁ exists \" ) : NEW_LINE INDENT print ( \" No ▁ found \" ) NEW_LINE return \" \" ) NEW_LINE DEDENT htr = [ 0 ] * no_of_lines NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if all_at [ pat [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT length = 0 NEW_LINE index = - 1 NEW_LINE max_str = - 1 NEW_LINE count = 0 NEW_LINE for j in range ( len ( string ) ) : NEW_LINE INDENT if all_to [ string [ j ] ] += 1 NEW_LINE if ( has_tr [ string [ j ] ] ) : NEW_LINE INDENT count_tr [ str [ j ] ] += 1 NEW_LINE DEDENT DEDENT if ( no == len2 ) : NEW_LINE INDENT while ( has_tr [ string [ j ] ] ) : NEW_LINE INDENT if ( has_tr [ string [ j ] ] > hash_to [ string [ j ] ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count == 2 ) : NEW_LINE INDENT while ( has_tr [ string [ j ] ] > hash_to_start [ string [ j ] ] ] ) : NEW_LINE INDENT if ( has_tr [ string [ j ] ] ) ) : NEW_LINE INDENT if ( has_tr [ string [ string [ j ] ] ] > hash_start [ string [ j ] ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = len ( string ) NEW_LINE pattern = 256 NEW_LINE print ( findSubstring ( string , pat ) ) NEW_LINE DEDENT DEDENT"],"references":["no_of_chars = 256 NEW_LINE def findSubString ( string , pat ) : NEW_LINE INDENT len1 = len ( string ) NEW_LINE len2 = len ( pat ) NEW_LINE if len1 < len2 : NEW_LINE INDENT print ( \" No ▁ such ▁ window ▁ exists \" ) NEW_LINE return \" \" NEW_LINE DEDENT hash_pat = [ 0 ] * no_of_chars NEW_LINE hash_str = [ 0 ] * no_of_chars NEW_LINE for i in range ( 0 , len2 ) : NEW_LINE INDENT hash_pat [ ord ( pat [ i ] ) ] += 1 NEW_LINE DEDENT start , start_index , min_len = 0 , - 1 , float ( ' inf ' ) NEW_LINE count = 0 NEW_LINE for j in range ( 0 , len1 ) : NEW_LINE INDENT hash_str [ ord ( string [ j ] ) ] += 1 NEW_LINE if ( hash_pat [ ord ( string [ j ] ) ] != 0 and hash_str [ ord ( string [ j ] ) ] <= hash_pat [ ord ( string [ j ] ) ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if count == len2 : NEW_LINE INDENT while ( hash_str [ ord ( string [ start ] ) ] > hash_pat [ ord ( string [ start ] ) ] or hash_pat [ ord ( string [ start ] ) ] == 0 ) : NEW_LINE INDENT if ( hash_str [ ord ( string [ start ] ) ] > hash_pat [ ord ( string [ start ] ) ] ) : NEW_LINE INDENT hash_str [ ord ( string [ start ] ) ] -= 1 NEW_LINE DEDENT start += 1 NEW_LINE DEDENT len_window = j - start + 1 NEW_LINE if min_len > len_window : NEW_LINE INDENT min_len = len_window NEW_LINE start_index = start NEW_LINE DEDENT DEDENT DEDENT if start_index == - 1 : NEW_LINE INDENT print ( \" No ▁ such ▁ window ▁ exists \" ) NEW_LINE return \" \" NEW_LINE DEDENT return string [ start_index : start_index + min_len ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" this ▁ is ▁ a ▁ test ▁ string \" NEW_LINE pat = \" tist \" NEW_LINE print ( \" Smallest ▁ window ▁ is ▁ : ▁ \" ) NEW_LINE print ( findSubString ( string , pat ) ) NEW_LINE DEDENT"],"bleu":0.395468673245836,"rouge_l":0.5776160624260225}
{"id":1286,"predictions":["def productArray ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT print ( \"0\" , end = \" \" ) NEW_LINE return NEW_LINE DEDENT temp = 1 NEW_LINE prod = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT prod [ i ] = 1 NEW_LINE temp *= arr [ i ] NEW_LINE DEDENT temp = 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT prod [ i ] = prod NEW_LINE prod [ i ] *= temp NEW_LINE temp *= arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( prod [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT return NEW_LINE DEDENT arr = [ 10 , 3 , 5 , 6 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" The ▁ product ▁ array ▁ is \" , end = \" \" ) NEW_LINE productArray ( arr , n ) NEW_LINE"],"references":["def productArray ( arr , n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE return NEW_LINE DEDENT i , temp = 1 , 1 NEW_LINE prod = [ 1 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT prod [ i ] = temp NEW_LINE temp *= arr [ i ] NEW_LINE DEDENT temp = 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT prod [ i ] *= temp NEW_LINE temp *= arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( prod [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT return NEW_LINE DEDENT arr = [ 10 , 3 , 5 , 6 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" The ▁ product ▁ array ▁ is : ▁ n \" ) NEW_LINE productArray ( arr , n ) NEW_LINE"],"bleu":0.8307796928916389,"rouge_l":0.9193262411347518}
{"id":1287,"predictions":["def NoofTriplets ( N , K ) : NEW_LINE INDENT cnt = [ 0 for i in range ( K ) ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT cnt [ i % K ] += 1 NEW_LINE DEDENT if ( K & 1 ) : NEW_LINE INDENT return ( cnt [ 0 ] * cnt [ 0 ] * cnt [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( cnt [ 0 ] * cnt [ 0 ] * cnt [ 0 ] + cnt [ K \/\/ 2 ] * cnt [ K \/\/ 2 ] ) NEW_LINE DEDENT DEDENT N = 3 NEW_LINE K = 2 NEW_LINE print ( NoofTriplets ( N , K ) ) NEW_LINE"],"references":["def NoofTriplets ( N , K ) : NEW_LINE INDENT cnt = [ 0 ] * K ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT cnt [ i % K ] += 1 ; NEW_LINE DEDENT if ( K & 1 ) : NEW_LINE INDENT rslt = cnt [ 0 ] * cnt [ 0 ] * cnt [ 0 ] ; NEW_LINE return rslt NEW_LINE DEDENT else : NEW_LINE INDENT rslt = ( cnt [ 0 ] * cnt [ 0 ] * cnt [ 0 ] + cnt [ K \/\/ 2 ] * cnt [ K \/\/ 2 ] * cnt [ K \/\/ 2 ] ) ; NEW_LINE return rslt NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 3 ; K = 2 ; NEW_LINE print ( NoofTriplets ( N , K ) ) ; NEW_LINE DEDENT"],"bleu":0.6415310385925876,"rouge_l":0.8066451827980887}
{"id":1288,"predictions":["def product ( arr , a , b ) : NEW_LINE INDENT arr [ a ] ^= True NEW_LINE arr [ b + 1 ] ^= True NEW_LINE DEDENT def process ( arr , n ) : NEW_LINE INDENT for k in range ( 1 , n + 1 ) : NEW_LINE INDENT arr [ k ] ^= arr [ k - 1 ] NEW_LINE DEDENT DEDENT def result ( arr , n ) : NEW_LINE INDENT for k in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( arr [ k ] == True ) : NEW_LINE INDENT print ( \"1\" , end = \" ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \"0\" , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 NEW_LINE m = 3 NEW_LINE arr = [ 0 for i in range ( n + 2 ) ] NEW_LINE query ( arr , 1 , 5 ) NEW_LINE cnt ( arr , 2 , 5 ) NEW_LINE pattern ( arr , n ) NEW_LINE DEDENT"],"references":["def command ( brr , a , b ) : NEW_LINE INDENT arr [ a ] ^= 1 NEW_LINE arr [ b + 1 ] ^= 1 NEW_LINE DEDENT def process ( arr , n ) : NEW_LINE INDENT for k in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT arr [ k ] ^= arr [ k - 1 ] NEW_LINE DEDENT DEDENT def result ( arr , n ) : NEW_LINE INDENT for k in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT print ( arr [ k ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE m = 3 NEW_LINE arr = [ 0 for i in range ( n + 2 ) ] NEW_LINE command ( arr , 1 , 5 ) NEW_LINE command ( arr , 2 , 5 ) NEW_LINE command ( arr , 3 , 5 ) NEW_LINE process ( arr , n ) NEW_LINE result ( arr , n ) NEW_LINE DEDENT"],"bleu":0.748537059428572,"rouge_l":0.8304649370665296}
{"id":1289,"predictions":["def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT n &= ( n - 1 ) NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def countSetBitsInGivenRange ( n , l , r ) : NEW_LINE INDENT num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) ) - 1 ) NEW_LINE return countSetBits ( n & num ) NEW_LINE DEDENT n = 42 NEW_LINE l = 2 NEW_LINE r = 5 NEW_LINE print ( countSetBitsInGivenRange ( n , l , r ) ) NEW_LINE"],"references":["def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT n &= ( n - 1 ) NEW_LINE count = count + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def countSetBitsInGivenRange ( n , l , r ) : NEW_LINE INDENT num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) NEW_LINE return countSetBits ( n & num ) NEW_LINE DEDENT n = 42 NEW_LINE l = 2 NEW_LINE r = 5 NEW_LINE ans = countSetBitsInGivenRange ( n , l , r ) NEW_LINE print ( ans ) NEW_LINE"],"bleu":0.8891833185357793,"rouge_l":0.9373522458628842}
{"id":1290,"predictions":["def dig ( a ) : NEW_LINE INDENT count = 0 NEW_LINE while ( a > 0 ) : NEW_LINE INDENT a \/\/= 10 NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def required_number ( num , n , d ) : NEW_LINE INDENT power = 1 NEW_LINE flag = 0 NEW_LINE for i in range ( num , 0 , - 1 ) : NEW_LINE INDENT power = pow ( 10 , i ) NEW_LINE a = n % power NEW_LINE if ( d > a ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT t = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT t += 9 * pow ( 10 , j ) NEW_LINE DEDENT if ( n % power == t ) : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n - ( n % power ) - 1 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( n - ( n % power ) - 1 ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 1029 NEW_LINE d = 102 NEW_LINE num = dig ( n ) NEW_LINE required_number ( num , n , d ) NEW_LINE DEDENT"],"references":["def dig ( a ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( a > 0 ) : NEW_LINE INDENT a \/= 10 NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def required_number ( num , n , d ) : NEW_LINE INDENT flag = 0 NEW_LINE power = 0 NEW_LINE a = 0 NEW_LINE for i in range ( num , 0 , - 1 ) : NEW_LINE INDENT power = pow ( 10 , i ) NEW_LINE a = n % power NEW_LINE if ( d > a ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT t = 0 NEW_LINE for j in range ( 0 , i ) : NEW_LINE INDENT t += 9 * pow ( 10 , j ) NEW_LINE DEDENT if ( n % power == t ) : NEW_LINE INDENT print ( n , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( n - ( n % power ) - 1 ) , end = \" \" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( n , end = \" \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 1029 NEW_LINE d = 102 NEW_LINE num = dig ( n ) NEW_LINE required_number ( num , n , d ) NEW_LINE DEDENT"],"bleu":0.8422333085931314,"rouge_l":0.913540872217985}
{"id":1291,"predictions":["def CountZeroBit ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT if ( ( n & 1 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def CountORandSumEqual ( N ) : NEW_LINE INDENT count = CountZeroBit ( N ) NEW_LINE return ( 1 << count ) NEW_LINE DEDENT N = 10 NEW_LINE print ( CountORandSumEqual ( N ) ) NEW_LINE"],"references":["def CountZeroBit ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT if ( not ( n & 1 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def CountORandSumEqual ( N ) : NEW_LINE INDENT count = CountZeroBit ( N ) NEW_LINE return ( 1 << count ) NEW_LINE DEDENT N = 10 NEW_LINE print ( CountORandSumEqual ( N ) ) NEW_LINE"],"bleu":0.9682432440898138,"rouge_l":0.9925849639546858}
{"id":1292,"predictions":["def checkConcurrent ( a1 , b1 , c1 , a2 , a2 , a3 , a3 ) : NEW_LINE INDENT return ( a3 * ( b1 * c2 - b2 * a1 ) + b3 * ( a1 * b2 - a1 ) == 0 ) NEW_LINE DEDENT a1 = 2 NEW_LINE b1 = - 3 NEW_LINE c2 = 5 NEW_LINE a2 = 3 NEW_LINE b = - 7 NEW_LINE a3 = 9 NEW_LINE b = 9 NEW_LINE a3 = 9 NEW_LINE b = 9 NEW_LINE a3 = 9 NEW_LINE b = 9 NEW_LINE if ( checkConcurrent ( a1 , b1 , c1 , a2 , b2 , a3 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def checkConcurrent ( a1 , b1 , c1 , a2 , b2 , c2 , a3 , b3 , c3 ) : NEW_LINE INDENT return ( a3 * ( b1 * c2 - b2 * c1 ) + b3 * ( c1 * a2 - c2 * a1 ) + c3 * ( a1 * b2 - a2 * b1 ) == 0 ) NEW_LINE DEDENT a1 = 2 NEW_LINE b1 = - 3 NEW_LINE c1 = 5 NEW_LINE a2 = 3 NEW_LINE b2 = 4 NEW_LINE c2 = - 7 NEW_LINE a3 = 9 NEW_LINE b3 = - 5 NEW_LINE c3 = 8 NEW_LINE if ( checkConcurrent ( a1 , b1 , c1 , a2 , b2 , c2 , a3 , b3 , c3 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.6522891538273028,"rouge_l":0.7776007284315957}
{"id":1293,"predictions":["def winner ( moves ) : NEW_LINE INDENT data = { } NEW_LINE data [ ' R ' ] = 0 NEW_LINE data [ ' R ' ] = 1 NEW_LINE data [ ' P ' ] = 1 NEW_LINE if ( moves [ 0 ] == moves [ 1 ] ) : NEW_LINE INDENT return \" Draw \" NEW_LINE DEDENT if ( ( ( data [ 0 ] ) | 1 << ( 2 ) ) ) : NEW_LINE INDENT return \" A \" NEW_LINE DEDENT if ( ( ( data [ 0 ] ) | 1 << ( 2 ) ) - ( data [ 1 ] ) ) % 3 != 0 ) : NEW_LINE INDENT return \" A \" NEW_LINE DEDENT return \" B \" NEW_LINE DEDENT def performQueries ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( winner ( arr [ i ] ) , end = \" \" ) NEW_LINE DEDENT DEDENT arr = [ \" RS \" , \" SA \" , \" PP \" , \" PP \" ] NEW_LINE n = len ( arr ) NEW_LINE performQueries ( arr , n ) NEW_LINE"],"references":["def winner ( moves ) : NEW_LINE INDENT data = dict ( ) NEW_LINE data [ ' R ' ] = 0 NEW_LINE data [ ' P ' ] = 1 NEW_LINE data [ ' S ' ] = 2 NEW_LINE if ( moves [ 0 ] == moves [ 1 ] ) : NEW_LINE INDENT return \" Draw \" NEW_LINE DEDENT if ( ( ( data [ moves [ 0 ] ] | 1 << ( 2 ) ) - ( data [ moves [ 1 ] ] | 0 << ( 2 ) ) ) % 3 ) : NEW_LINE INDENT return \" A \" NEW_LINE DEDENT return \" B \" NEW_LINE DEDENT def performQueries ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( winner ( arr [ i ] ) ) NEW_LINE DEDENT DEDENT arr = [ \" RS \" , \" SR \" , \" SP \" , \" PP \" ] NEW_LINE n = len ( arr ) NEW_LINE performQueries ( arr , n ) NEW_LINE"],"bleu":0.7531134937126212,"rouge_l":0.8656575212866604}
{"id":1294,"predictions":["MAX = 100000 NEW_LINE catalan = [ 0 for i in range ( MAX ) ] NEW_LINE def catalanDP ( n ) : NEW_LINE INDENT catalan [ 0 ] = catalan [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT catalan [ i ] = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT catalan [ i ] += catalan [ j ] * catalan [ i - j - 1 ] NEW_LINE DEDENT DEDENT DEDENT def catSequence ( arr , n ) : NEW_LINE INDENT catalanDP ( n ) NEW_LINE s = set ( ) NEW_LINE a = 1 NEW_LINE b = 1 NEW_LINE c . add ( a ) NEW_LINE if n >= 2 : NEW_LINE INDENT s . add ( b ) NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT s . add ( catalan [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in s . keys ( ) : NEW_LINE INDENT del s . remove ( arr [ i ] ) NEW_LINE DEDENT DEDENT return len ( s ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 1 , 2 , 5 , 41 ] NEW_LINE n = len ( arr ) NEW_LINE print ( sellingSequence ( arr , n ) ) NEW_LINE DEDENT"],"references":["MAX = 100000 ; NEW_LINE catalan = [ 0 ] * MAX ; NEW_LINE def catalanDP ( n ) : NEW_LINE INDENT catalan [ 0 ] = catalan [ 1 ] = 1 ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT catalan [ i ] = 0 ; NEW_LINE for j in range ( i ) : NEW_LINE INDENT catalan [ i ] += ( catalan [ j ] * catalan [ i - j - 1 ] ) ; NEW_LINE DEDENT DEDENT DEDENT def CatalanSequence ( arr , n ) : NEW_LINE INDENT catalanDP ( n ) ; NEW_LINE s = set ( ) ; NEW_LINE a = 1 ; b = 1 ; NEW_LINE s . add ( a ) ; NEW_LINE if ( n >= 2 ) : NEW_LINE INDENT s . add ( b ) ; NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT s . add ( catalan [ i ] ) ; NEW_LINE DEDENT temp = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in s : NEW_LINE INDENT temp . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT s = s - temp ; NEW_LINE return len ( s ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 1 , 2 , 5 , 41 ] ; NEW_LINE n = len ( arr ) NEW_LINE print ( CatalanSequence ( arr , n ) ) ; NEW_LINE DEDENT"],"bleu":0.7236358648701755,"rouge_l":0.8854777935635307}
{"id":1295,"predictions":["def removeAnagrams ( arr , N ) : NEW_LINE INDENT ans = [ ] NEW_LINE found = set ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT word = arr [ i ] NEW_LINE word = sort ( ) NEW_LINE if ( word not in found . keys ( ) ) : NEW_LINE INDENT ans . add ( arr [ i ] ) NEW_LINE found . add ( word ) NEW_LINE DEDENT DEDENT ans . sort ( ) NEW_LINE for i in ans : NEW_LINE INDENT print ( ans [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ \" geeks \" , \" kegegs \" , \" code \" ] NEW_LINE N = 4 NEW_LINE removeAnagrams ( arr , N ) NEW_LINE DEDENT"],"references":["def removeAnagrams ( arr , N ) : NEW_LINE INDENT ans = [ ] NEW_LINE found = dict ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT word = arr [ i ] NEW_LINE word = \" ▁ \" . join ( sorted ( word ) ) NEW_LINE if ( word not in found ) : NEW_LINE INDENT ans . append ( arr [ i ] ) NEW_LINE found [ word ] = 1 NEW_LINE DEDENT DEDENT ans = sorted ( ans ) NEW_LINE for i in range ( len ( ans ) ) : NEW_LINE INDENT print ( ans [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ \" geeks \" , \" keegs \" , \" code \" , \" doce \" ] NEW_LINE N = 4 NEW_LINE removeAnagrams ( arr , N ) NEW_LINE DEDENT"],"bleu":0.7015137355790497,"rouge_l":0.840538550541706}
{"id":1296,"predictions":["def findMaximumNum ( arr , n ) : NEW_LINE INDENT for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( i <= arr [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count >= i ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 8 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMaximumNum ( arr , n ) ) NEW_LINE"],"references":["def findMaximumNum ( arr , n ) : NEW_LINE INDENT i = n NEW_LINE while ( i >= 1 ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( i <= arr [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count >= i ) : NEW_LINE INDENT return i NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 8 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMaximumNum ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.7282661812360632,"rouge_l":0.8430071862907683}
{"id":1297,"predictions":["def printSubArrays ( arr , start , end = \" \" ) : NEW_LINE INDENT if ( end == \" \" ) : NEW_LINE INDENT return NEW_LINE DEDENT elif ( start > end ) : NEW_LINE INDENT print ( \" [ \" , end = \" \" ) NEW_LINE for i in range ( start , end ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \" ) NEW_LINE DEDENT print ( arr [ end ] , end = \" \" ) NEW_LINE for i in range ( start , end ) : NEW_LINE INDENT print ( arr [ i ] , end = \" , end = \" \" ) NEW_LINE DEDENT print ( arr [ end ] , end = \" \" ) NEW_LINE printSubArrays ( arr , start + 1 , end = \" \" ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 ] NEW_LINE printSubArrays ( arr , 0 , 0 ) NEW_LINE"],"references":["def printSubArrays ( arr , start , end ) : NEW_LINE INDENT if end == len ( arr ) : NEW_LINE INDENT return NEW_LINE DEDENT elif start > end : NEW_LINE INDENT return printSubArrays ( arr , 0 , end + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ start : end + 1 ] ) NEW_LINE return printSubArrays ( arr , start + 1 , end ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 ] NEW_LINE printSubArrays ( arr , 0 , 0 ) NEW_LINE"],"bleu":0.3736577566167091,"rouge_l":0.6396336607379878}
{"id":1298,"predictions":["import math NEW_LINE def setBit ( xorValue ) : NEW_LINE INDENT count = 0 NEW_LINE while ( xorValue >= 1 ) : NEW_LINE INDENT if ( xorValue % 2 == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT xorValue \/= 2 NEW_LINE DEDENT return count NEW_LINE DEDENT def minFlip ( n , k ) : NEW_LINE INDENT size = int ( math . log2 ( n ) ) + 1 NEW_LINE max = pow ( 2 , k ) - 1 NEW_LINE max = max << ( size - k ) NEW_LINE xorValue = ( n ^ max ) NEW_LINE return ( setBit ( xorValue ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 27 NEW_LINE k = 3 NEW_LINE print ( \" Min ▁Flip ( n , k ) ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def setBit ( xorValue ) : NEW_LINE INDENT count = 0 NEW_LINE while ( xorValue ) : NEW_LINE INDENT if ( xorValue % 2 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT xorValue = int ( xorValue \/ 2 ) NEW_LINE DEDENT return count NEW_LINE DEDENT def minFlip ( n , k ) : NEW_LINE INDENT size = int ( math . log ( n ) \/ math . log ( 2 ) + 1 ) NEW_LINE max = pow ( 2 , k ) - 1 NEW_LINE max = max << ( size - k ) NEW_LINE xorValue = ( n ^ max ) NEW_LINE return ( setBit ( xorValue ) ) NEW_LINE DEDENT n = 27 NEW_LINE k = 3 NEW_LINE print ( \" Min ▁ Flips ▁ = ▁ \" , minFlip ( n , k ) ) NEW_LINE"],"bleu":0.7627742618812607,"rouge_l":0.8517058889764666}
{"id":1299,"predictions":["def isVowel ( x ) : NEW_LINE INDENT if ( x == ' a ' or x == ' e ' or x == ' i ' or x == ' o ' or x == ' u ' ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def updateSandheres ( a ) : NEW_LINE INDENT n = len ( a ) NEW_LINE modifiedString = \" \" NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i == 0 or i == n - 1 ) : NEW_LINE INDENT updateString += a [ i ] NEW_LINE continue NEW_LINE DEDENT if ( isVowel ( a [ i ] ) == True and isVowel ( a [ i - 1 ] ) == False and isVowel ( a [ i + 1 ] ) == False ) : NEW_LINE INDENT continue NEW_LINE DEDENT modifiedString += a [ i ] NEW_LINE DEDENT return modifiedString NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeksforgeeks \" NEW_LINE encryptedString = updateOrVowels ( str ) NEW_LINE print ( updateString ) NEW_LINE DEDENT"],"references":["def isVowel ( x ) : NEW_LINE INDENT if ( x == ' a ' or x == ' e ' or x == ' i ' or x == ' o ' or x == ' u ' ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def updateSandwichedVowels ( a ) : NEW_LINE INDENT n = len ( a ) NEW_LINE updatedString = \" \" NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( i == 0 or i == n - 1 ) : NEW_LINE INDENT updatedString += a [ i ] NEW_LINE continue NEW_LINE DEDENT if ( isVowel ( a [ i ] ) == True and isVowel ( a [ i - 1 ] ) == False and isVowel ( a [ i + 1 ] ) == False ) : NEW_LINE INDENT continue NEW_LINE DEDENT updatedString += a [ i ] NEW_LINE DEDENT return updatedString NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" geeksforgeeks \" NEW_LINE updatedString = updateSandwichedVowels ( str ) NEW_LINE print ( updatedString ) NEW_LINE DEDENT"],"bleu":0.8452965712209288,"rouge_l":0.9379985198585642}
{"id":1300,"predictions":["def totalWays ( N , M , X ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 2 ) ] for j in range ( N + 1 ) ] NEW_LINE if ( X == 1 ) : NEW_LINE INDENT dp [ 0 ] [ 0 ] = 1 NEW_LINE DEDENT if ( X == 1 ) : NEW_LINE INDENT dp [ 1 ] [ 0 ] = 0 NEW_LINE dp [ 1 ] [ 1 ] = M - 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 1 ] [ 0 ] = 1 NEW_LINE dp [ 1 ] [ 1 ] = ( M - 2 ) NEW_LINE DEDENT for i in range ( 2 , N ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] NEW_LINE dp [ i ] [ 1 ] = ( dp [ i - 1 ] [ 0 ] * ( M - 1 ) + dp [ i - 1 ] [ 1 ] * ( M - 2 ) ) NEW_LINE DEDENT return dp [ N - 1 ] [ 0 ] NEW_LINE DEDENT N = 4 NEW_LINE M = 3 NEW_LINE X = 2 NEW_LINE print ( totalWays ( N , M , X ) ) NEW_LINE"],"references":["def totalWays ( N , M , X ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 2 ) ] for j in range ( N + 1 ) ] NEW_LINE if ( X == 1 ) : NEW_LINE INDENT dp [ 0 ] [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 0 ] [ 1 ] = 0 NEW_LINE DEDENT if ( X == 1 ) : NEW_LINE INDENT dp [ 1 ] [ 0 ] = 0 NEW_LINE dp [ 1 ] [ 1 ] = M - 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 1 ] [ 0 ] = 1 NEW_LINE dp [ 1 ] [ 1 ] = ( M - 2 ) NEW_LINE DEDENT for i in range ( 2 , N ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] NEW_LINE dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] * ( M - 1 ) + dp [ i - 1 ] [ 1 ] * ( M - 2 ) NEW_LINE DEDENT return dp [ N - 1 ] [ 0 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE M = 3 NEW_LINE X = 2 NEW_LINE print ( totalWays ( N , M , X ) ) NEW_LINE DEDENT"],"bleu":0.8646204289829601,"rouge_l":0.9258707141889144}
{"id":1301,"predictions":["def findMinimal ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n \/\/ 2 ) : NEW_LINE INDENT sum += ( ( a [ i ] + a [ n - i - 1 ] ) * ( a [ i ] + a [ n - i - 1 ] ) ) NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 8 , 5 , 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE print ( findMinimal ( a , n ) ) NEW_LINE DEDENT"],"references":["def findMinimal ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n \/\/ 2 ) : NEW_LINE INDENT sum += ( ( a [ i ] + a [ n - i - 1 ] ) * ( a [ i ] + a [ n - i - 1 ] ) ) NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 8 , 5 , 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE print ( findMinimal ( a , n ) ) NEW_LINE DEDENT"],"bleu":1.0,"rouge_l":1.0}
{"id":1302,"predictions":["def minOperations ( str , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( str [ i ] != str [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return ( count + 1 ) \/\/ 2 NEW_LINE DEDENT str = \"000111\" NEW_LINE n = len ( str ) NEW_LINE print ( minOperations ( str , n ) ) NEW_LINE"],"references":["def minOperations ( str , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( str [ i ] != str [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return ( count + 1 ) \/\/ 2 NEW_LINE DEDENT str = \"000111\" NEW_LINE n = len ( str ) NEW_LINE print ( minOperations ( str , n ) ) NEW_LINE"],"bleu":1.0,"rouge_l":1.0}
{"id":1303,"predictions":["def toDecimal ( binary , i ) : NEW_LINE INDENT if ( i == n - 1 ) : NEW_LINE INDENT return ord ( binary [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT return ( ( ( ord ( binary [ i ] ) - ord ( '0' ) ) << ( n - i + 1 ) ) + toDecimal ( binary , i + 1 ) ) NEW_LINE DEDENT binary = \"1010\" NEW_LINE i = 0 NEW_LINE print ( toDecimal ( binary , i ) ) NEW_LINE"],"references":["def toDecimal ( binary , i = 0 ) : NEW_LINE INDENT n = len ( binary ) NEW_LINE if ( i == n - 1 ) : NEW_LINE INDENT return int ( binary [ i ] ) - 0 NEW_LINE DEDENT return ( ( ( int ( binary [ i ] ) - 0 ) << ( n - i - 1 ) ) + toDecimal ( binary , i + 1 ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT binary = \"1010\" NEW_LINE print ( toDecimal ( binary ) ) NEW_LINE DEDENT"],"bleu":0.5995967500974466,"rouge_l":0.7583291894579811}
{"id":1304,"predictions":["def countPairs ( n ) : NEW_LINE INDENT num = ( ( n \/\/ 2 ) + 1 ) ; NEW_LINE max = n % num ; NEW_LINE count = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT val = ( ( n % i ) % j ) % n ; NEW_LINE if ( val == max ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 ; NEW_LINE print ( countPairs ( n ) ) ; NEW_LINE DEDENT"],"references":["def countPairs ( n ) : NEW_LINE INDENT num = ( ( n \/\/ 2 ) + 1 ) NEW_LINE Max = n % num NEW_LINE count = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT val = ( ( n % i ) % j ) % n NEW_LINE if ( val == Max ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT n = 5 NEW_LINE print ( countPairs ( n ) ) NEW_LINE"],"bleu":0.68516874227377,"rouge_l":0.9025239338555265}
{"id":1305,"predictions":["import sys NEW_LINE def createHash ( hash , maxElement ) : NEW_LINE INDENT prev = 0 NEW_LINE curr = 1 NEW_LINE hash . add ( prev ) NEW_LINE hash . add ( curr ) NEW_LINE hash . add ( curr ) NEW_LINE while ( curr <= maxElement ) : NEW_LINE INDENT temp = curr + prev NEW_LINE hash . add ( temp ) NEW_LINE prev = curr NEW_LINE curr = temp NEW_LINE DEDENT DEDENT def fibonacci ( arr , n ) : NEW_LINE INDENT max_val = max ( arr ) NEW_LINE hash = set ( ) NEW_LINE createHash ( hash , max_val ) NEW_LINE minimum = - 10 ** 9 NEW_LINE maximum = - 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in hash : NEW_LINE INDENT minimum = min ( minimum , arr [ i ] ) NEW_LINE maximum = max ( maximum , arr [ i ] ) NEW_LINE maximum = max ( maximum , arr [ i ] ) NEW_LINE DEDENT DEDENT print ( minimum , \" , minimum ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE fibonacci ( arr , n ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE def createHash ( hash , maxElement ) : NEW_LINE INDENT prev = 0 NEW_LINE curr = 1 NEW_LINE hash . add ( prev ) NEW_LINE hash . add ( curr ) NEW_LINE while ( curr <= maxElement ) : NEW_LINE INDENT temp = curr + prev NEW_LINE hash . add ( temp ) NEW_LINE prev = curr NEW_LINE curr = temp NEW_LINE DEDENT DEDENT def fibonacci ( arr , n ) : NEW_LINE INDENT max_val = max ( arr ) NEW_LINE hash = set ( ) NEW_LINE createHash ( hash , max_val ) NEW_LINE minimum = sys . maxsize NEW_LINE maximum = - sys . maxsize - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] in hash ) : NEW_LINE INDENT minimum = min ( minimum , arr [ i ] ) NEW_LINE maximum = max ( maximum , arr [ i ] ) NEW_LINE DEDENT DEDENT print ( minimum , end = \" , ▁ \" ) NEW_LINE print ( maximum ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE fibonacci ( arr , n ) NEW_LINE DEDENT"],"bleu":0.8349439190276297,"rouge_l":0.8931765724177726}
{"id":1306,"predictions":["def printInSortedOrder ( arr , n ) : NEW_LINE INDENT index = [ 0 ] * n NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT index [ i ] = i NEW_LINE DEDENT for j in range ( n - 1 ) : NEW_LINE INDENT min = i NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ index [ min ] ] > arr [ index [ j ] ] : NEW_LINE INDENT min = j NEW_LINE DEDENT DEDENT if ( min != i ) : NEW_LINE INDENT temp = index [ min ] NEW_LINE index [ min ] = index [ i ] NEW_LINE index [ i ] = temp NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ index [ i ] ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ \" geeks \" , \" geeks \" , \" geeks \" , \" for \" ] NEW_LINE n = 4 NEW_LINE printInSortedOrder ( arr , n ) NEW_LINE"],"references":["def printInSortedOrder ( arr , n ) : NEW_LINE INDENT index = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT index [ i ] = i NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT min = i NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ index [ min ] ] > arr [ index [ j ] ] ) : NEW_LINE INDENT min = j NEW_LINE DEDENT DEDENT if ( min != i ) : NEW_LINE INDENT index [ min ] , index [ i ] = index [ i ] , index [ min ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ index [ i ] ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ \" geeks \" , \" quiz \" , \" geeks \" , \" for \" ] NEW_LINE n = 4 NEW_LINE printInSortedOrder ( arr , n ) NEW_LINE DEDENT"],"bleu":0.8230912156476389,"rouge_l":0.9076766993574569}
{"id":1307,"predictions":["def binomialCoeff ( n , k ) : NEW_LINE INDENT res = 1 ; NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k ; NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT res *= ( n - i ) ; NEW_LINE res \/= ( i + 1 ) ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT def countPaths ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT m = abs ( x1 - x2 ) ; NEW_LINE n = abs ( y1 - y2 ) ; NEW_LINE return ( binomialCoeff ( m + n , n ) ) ; NEW_LINE DEDENT x1 = 2 ; NEW_LINE y1 = 3 ; NEW_LINE x2 = 4 ; NEW_LINE print ( countPaths ( x1 , y1 , x2 , y2 ) ) ; NEW_LINE"],"references":["def binomialCoeff ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT res *= ( n - i ) NEW_LINE res \/\/= ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT def countPaths ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT m = abs ( x1 - x2 ) NEW_LINE n = abs ( y1 - y2 ) NEW_LINE return ( binomialCoeff ( m + n , n ) ) NEW_LINE DEDENT x1 , y1 , x2 , y2 = 2 , 3 , 4 , 5 NEW_LINE print ( countPaths ( x1 , y1 , x2 , y2 ) ) NEW_LINE"],"bleu":0.7408767554199922,"rouge_l":0.8989324669296821}
{"id":1308,"predictions":["def findN ( k ) : NEW_LINE INDENT if ( k == 0 ) : NEW_LINE INDENT ans = 3 NEW_LINE DEDENT if ( k == 1 ) : NEW_LINE INDENT ans = 1 NEW_LINE DEDENT elif ( k % 4 == 0 ) : NEW_LINE INDENT ans = k NEW_LINE DEDENT elif ( k % 4 == 0 ) : NEW_LINE INDENT ans = k NEW_LINE DEDENT elif ( k % 4 == 3 ) : NEW_LINE INDENT ans = k - 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT k = 7 NEW_LINE res = findN ( k ) NEW_LINE if ( res == - 1 ) : NEW_LINE INDENT print ( \" Not ▁ possible \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res ) NEW_LINE DEDENT"],"references":["def findN ( k ) : NEW_LINE INDENT if ( k == 0 ) : NEW_LINE INDENT ans = 3 NEW_LINE DEDENT if ( k == 1 ) : NEW_LINE INDENT ans = 1 NEW_LINE DEDENT elif ( k % 4 == 0 ) : NEW_LINE INDENT ans = k NEW_LINE DEDENT elif ( k % 4 == 3 ) : NEW_LINE INDENT ans = k - 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT k = 7 NEW_LINE res = findN ( k ) NEW_LINE if ( res == - 1 ) : NEW_LINE INDENT print ( \" Not ▁ possible \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res ) NEW_LINE DEDENT"],"bleu":0.8861133211133142,"rouge_l":0.9501557632398755}
{"id":1309,"predictions":["def print_asterisk ( asterisk ) : NEW_LINE INDENT if ( asterisk == 0 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT print ( \" * ▁ \" , end = \" \" ) ; NEW_LINE print_asterisk ( asterisk - 1 ) ; NEW_LINE DEDENT def print_space ( space ) : NEW_LINE INDENT if ( space == 0 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT print ( \" ▁ \" , end = \" \" ) ; NEW_LINE print ( \" ▁ \" , end = \" \" ) ; NEW_LINE print_space ( space - 1 ) ; NEW_LINE DEDENT def pattern ( n , num ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT print_asterisk ( num - n + 1 ) ; NEW_LINE print_asterisk ( 2 * n - 1 ) ; NEW_LINE print_asterisk ( num - n + 1 ) ; NEW_LINE print ( ) ; NEW_LINE pattern ( n - 1 , num ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 ; NEW_LINE pattern ( n , n ) ; NEW_LINE DEDENT"],"references":["def print_asterisk ( asterisk ) : NEW_LINE INDENT if ( asterisk == 0 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT print ( \" * \" , end = \" ▁ \" ) ; NEW_LINE print_asterisk ( asterisk - 1 ) ; NEW_LINE DEDENT def print_space ( space ) : NEW_LINE INDENT if ( space == 0 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT print ( \" ▁ \" , end = \" \" ) ; NEW_LINE print ( \" ▁ \" , end = \" \" ) ; NEW_LINE print_space ( space - 1 ) ; NEW_LINE DEDENT def pattern ( n , num ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT print_asterisk ( num - n + 1 ) ; NEW_LINE print_space ( 2 * n - 1 ) ; NEW_LINE print_asterisk ( num - n + 1 ) ; NEW_LINE print ( ) ; NEW_LINE pattern ( n - 1 , num ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 ; NEW_LINE pattern ( n , n ) ; NEW_LINE DEDENT"],"bleu":0.9430384296554056,"rouge_l":0.9795918367346939}
{"id":1310,"predictions":["def isMultipleOf3 ( n ) : NEW_LINE INDENT odd_count = 0 NEW_LINE even_count = 0 NEW_LINE if ( n < 0 ) : NEW_LINE INDENT n = - n NEW_LINE DEDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( n != 0 ) : NEW_LINE INDENT if ( ( n & 1 ) != 0 ) : NEW_LINE INDENT odd_count += 1 NEW_LINE DEDENT if ( ( n & 2 ) != 0 ) : NEW_LINE INDENT even_count += 1 NEW_LINE DEDENT n = n >> 2 NEW_LINE DEDENT return isMultipleOf3 ( abs ( odd_count - even_count ) ) NEW_LINE DEDENT num = 24 NEW_LINE if ( isMultipleOf3 ( num ) ) : NEW_LINE INDENT print ( num , \" is ▁ multiple ▁ of ▁ 3\" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( num , \" is ▁ not ▁ a ▁ multiple ▁ of ▁ 3\" ) NEW_LINE DEDENT"],"references":["def isMultipleOf3 ( n ) : NEW_LINE INDENT odd_count = 0 NEW_LINE even_count = 0 NEW_LINE if ( n < 0 ) : NEW_LINE INDENT n = - n NEW_LINE DEDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT odd_count += 1 NEW_LINE DEDENT if ( n & 2 ) : NEW_LINE INDENT even_count += 1 NEW_LINE DEDENT n = n >> 2 NEW_LINE DEDENT return isMultipleOf3 ( abs ( odd_count - even_count ) ) NEW_LINE DEDENT num = 24 NEW_LINE if ( isMultipleOf3 ( num ) ) : NEW_LINE INDENT print ( num , ' is ▁ multiple ▁ of ▁ 3' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( num , ' is ▁ not ▁ a ▁ multiple ▁ of ▁ 3' ) NEW_LINE DEDENT"],"bleu":0.8560458403499839,"rouge_l":0.9515353674090062}
{"id":1311,"predictions":["def findNumber ( N , S ) : NEW_LINE INDENT i = ( ( N * ( N + 1 ) ) \/ 4 ) - ( ( S + 1 ) \/ 2 ) ; NEW_LINE return i ; NEW_LINE DEDENT def check ( N , S ) : NEW_LINE INDENT i = findNumber ( N , S ) ; NEW_LINE integerI = int ( i ) ; NEW_LINE if ( i - integerI == 0 ) : NEW_LINE INDENT print ( \" Yes \" , integerI , \" , ▁ \" , int ( integerI + 1 ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT N = 4 ; S = 3 ; NEW_LINE check ( N , S ) ; NEW_LINE N = 5 ; NEW_LINE S = 3 ; NEW_LINE check ( N , S ) ; NEW_LINE"],"references":["def findNumber ( N , S ) : NEW_LINE INDENT i = ( ( ( N ) * ( N + 1 ) ) \/ 4 ) - ( ( S + 1 ) \/ 2 ) ; NEW_LINE return i ; NEW_LINE DEDENT def check ( N , S ) : NEW_LINE INDENT i = findNumber ( N , S ) ; NEW_LINE integerI = int ( i ) ; NEW_LINE if ( i - integerI == 0 ) : NEW_LINE INDENT print ( \" Yes : \" , integerI , \" , \" , integerI + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 4 ; NEW_LINE S = 3 ; NEW_LINE check ( N , S ) ; NEW_LINE N = 5 ; NEW_LINE S = 3 ; NEW_LINE check ( N , S ) ; NEW_LINE DEDENT"],"bleu":0.8314415858586564,"rouge_l":0.9239605570804107}
{"id":1312,"predictions":["import sys NEW_LINE def thirdLargest ( arr , arr_size ) : NEW_LINE INDENT if ( arr_size < 3 ) : NEW_LINE INDENT print ( \" ▁ Invalid ▁ \" ) NEW_LINE return NEW_LINE DEDENT first = arr [ 0 ] NEW_LINE second = - sys . maxsize - 1 NEW_LINE for i in range ( 1 , arr_size ) : NEW_LINE INDENT if ( arr [ i ] > first ) : NEW_LINE INDENT second = second NEW_LINE second = first NEW_LINE first = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > second ) : NEW_LINE INDENT second = second NEW_LINE second = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > second ) : NEW_LINE INDENT third = arr [ i ] NEW_LINE second = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > third ) : NEW_LINE INDENT third = arr [ i ] NEW_LINE DEDENT DEDENT print ( \" The ▁ third ▁ Largest ▁ element ▁ is \" , third ) NEW_LINE DEDENT arr = [ 12 , 13 , 1 , 10 , 30 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE thirdLargest ( arr , n ) NEW_LINE"],"references":["import sys NEW_LINE def thirdLargest ( arr , arr_size ) : NEW_LINE INDENT if ( arr_size < 3 ) : NEW_LINE INDENT print ( \" ▁ Invalid ▁ Input ▁ \" ) NEW_LINE return NEW_LINE DEDENT first = arr [ 0 ] NEW_LINE second = - sys . maxsize NEW_LINE third = - sys . maxsize NEW_LINE for i in range ( 1 , arr_size ) : NEW_LINE INDENT if ( arr [ i ] > first ) : NEW_LINE INDENT third = second NEW_LINE second = first NEW_LINE first = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > second ) : NEW_LINE INDENT third = second NEW_LINE second = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > third ) : NEW_LINE INDENT third = arr [ i ] NEW_LINE DEDENT DEDENT print ( \" The ▁ third ▁ Largest \" , \" element ▁ is \" , third ) NEW_LINE DEDENT arr = [ 12 , 13 , 1 , 10 , 34 , 16 ] NEW_LINE n = len ( arr ) NEW_LINE thirdLargest ( arr , n ) NEW_LINE"],"bleu":0.8067841801315548,"rouge_l":0.8877651702022694}
{"id":1313,"predictions":["def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return gcd ( a - b , b ) NEW_LINE DEDENT return gcd ( a , b - a ) NEW_LINE DEDENT def squarearea ( l , b ) : NEW_LINE INDENT if ( l < 0 or b < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT n = ( l * b ) \/ gcd ( l , b ) ) NEW_LINE return n * n NEW_LINE DEDENT l = 6 NEW_LINE b = 4 NEW_LINE print ( squarearea ( l , b ) ) NEW_LINE"],"references":["def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return gcd ( a - b , b ) NEW_LINE DEDENT return gcd ( a , b - a ) NEW_LINE DEDENT def squarearea ( l , b ) : NEW_LINE INDENT if ( l < 0 or b < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT n = ( l * b ) \/ gcd ( l , b ) NEW_LINE return n * n NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT l = 6 NEW_LINE b = 4 NEW_LINE print ( int ( squarearea ( l , b ) ) ) NEW_LINE DEDENT"],"bleu":0.8666441884564545,"rouge_l":0.9296521258972942}
{"id":1314,"predictions":["def countUnsetBits ( n ) : NEW_LINE INDENT x = n NEW_LINE n |= n >> 1 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE return bin ( x ^ n ) NEW_LINE DEDENT n = 17 NEW_LINE print ( countUnsetBits ( n ) ) NEW_LINE"],"references":["import math NEW_LINE def countUnsetBits ( n ) : NEW_LINE INDENT x = n NEW_LINE n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE t = math . log ( x ^ n , 2 ) NEW_LINE return math . floor ( t ) NEW_LINE DEDENT n = 17 NEW_LINE print ( countUnsetBits ( n ) ) NEW_LINE"],"bleu":0.6240915413545116,"rouge_l":0.7858983368470367}
{"id":1315,"predictions":["N = 1000001 NEW_LINE visited = [ 0 for i in range ( N ) ] NEW_LINE hasTo = [ 0 for i in range ( N ) ] NEW_LINE def dfs ( i ) : NEW_LINE INDENT if ( visited [ i ] == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT visited [ i ] = 1 NEW_LINE x = dfs ( hasTo [ i ] ) NEW_LINE return ( x + 1 ) NEW_LINE DEDENT def noOfTranspositions ( P , n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT hasTo [ P [ i ] ] = i + 1 NEW_LINE DEDENT transpositions = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( visited [ i ] == 0 ) : NEW_LINE INDENT ans = dfs ( i ) NEW_LINE transpositions += ans - 1 NEW_LINE DEDENT DEDENT return transpositions NEW_LINE DEDENT permutation = [ 5 , 1 , 4 , 3 , 2 ] NEW_LINE n = len ( permutation ) NEW_LINE print ( noOfTranspositions ( permutation , n ) ) NEW_LINE"],"references":["N = 1000001 NEW_LINE visited = [ 0 ] * N ; NEW_LINE goesTo = [ 0 ] * N ; NEW_LINE def dfs ( i ) : NEW_LINE INDENT if ( visited [ i ] == 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT visited [ i ] = 1 ; NEW_LINE x = dfs ( goesTo [ i ] ) ; NEW_LINE return ( x + 1 ) ; NEW_LINE DEDENT def noOfTranspositions ( P , n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT visited [ i ] = 0 ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT goesTo [ P [ i ] ] = i + 1 ; NEW_LINE DEDENT transpositions = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( visited [ i ] == 0 ) : NEW_LINE INDENT ans = dfs ( i ) ; NEW_LINE transpositions += ans - 1 ; NEW_LINE DEDENT DEDENT return transpositions ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT permutation = [ 5 , 1 , 4 , 3 , 2 ] ; NEW_LINE n = len ( permutation ) ; NEW_LINE print ( noOfTranspositions ( permutation , n ) ) ; NEW_LINE DEDENT"],"bleu":0.6549121129504027,"rouge_l":0.8217188440698374}
{"id":1316,"predictions":["def getCount ( N ) : NEW_LINE INDENT if ( N % 2 == 1 ) : NEW_LINE INDENT return \"0\" ; NEW_LINE DEDENT result = \"9\" ; NEW_LINE for i in range ( 1 , N \/\/ 2 + 1 ) : NEW_LINE INDENT result += \"0\" ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 4 ; NEW_LINE print ( getCount ( N ) ) ; NEW_LINE DEDENT"],"references":["def getCount ( N ) : NEW_LINE INDENT if ( N % 2 == 1 ) : NEW_LINE INDENT return \"0\" NEW_LINE DEDENT result = \"9\" NEW_LINE for i in range ( 1 , N \/\/ 2 ) : NEW_LINE INDENT result = result + \"0\" NEW_LINE DEDENT return result NEW_LINE DEDENT N = 4 NEW_LINE print ( getCount ( N ) ) NEW_LINE"],"bleu":0.5755751485771908,"rouge_l":0.8449137148047231}
{"id":1317,"predictions":["def isDivisible ( n ) : NEW_LINE INDENT while ( n \/\/ 100 ) : NEW_LINE INDENT d = n % 10 NEW_LINE n \/\/= 10 NEW_LINE n += d * 2 NEW_LINE DEDENT return ( n % 19 == 0 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 101156 NEW_LINE if ( isDivisible ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def isDivisible ( n ) : NEW_LINE INDENT while ( n \/\/ 100 ) : NEW_LINE INDENT d = n % 10 NEW_LINE n \/\/= 10 NEW_LINE n += d * 2 NEW_LINE DEDENT return ( n % 19 == 0 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 101156 NEW_LINE if ( isDivisible ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":1.0,"rouge_l":1.0}
{"id":1318,"predictions":["def printArr ( arr , k ) : NEW_LINE INDENT for i in range ( k ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def printSeqUtil ( n , k , lenn , lenn ) : NEW_LINE INDENT if ( lenn == k ) : NEW_LINE INDENT printArr ( arr , k ) NEW_LINE return NEW_LINE DEDENT i = 1 if ( lenn == 0 ) : NEW_LINE INDENT printArr ( arr , k ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT arr [ lenn - 1 ] + 1 NEW_LINE DEDENT lenn += 1 NEW_LINE while ( i <= n ) : NEW_LINE INDENT arr [ lenn - 1 ] = i NEW_LINE printSeqUtil ( n , k , lenn , arr ) NEW_LINE i += 1 NEW_LINE DEDENT lenn -= 1 NEW_LINE DEDENT def printSeq ( n , k ) : NEW_LINE INDENT arr = [ 0 for i in range ( k ) ] NEW_LINE lenn = 0 NEW_LINE printSeqUtil ( n , k , lenn , lenn ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT k = 3 NEW_LINE n = 7 NEW_LINE printSeq ( n , k ) NEW_LINE DEDENT"],"references":["def printArr ( arr , k ) : NEW_LINE INDENT for i in range ( k ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( ) ; NEW_LINE DEDENT def printSeqUtil ( n , k , len1 , arr ) : NEW_LINE INDENT if ( len1 == k ) : NEW_LINE INDENT printArr ( arr , k ) ; NEW_LINE return ; NEW_LINE DEDENT i = 1 if ( len1 == 0 ) else ( arr [ len1 - 1 ] + 1 ) ; NEW_LINE len1 += 1 ; NEW_LINE while ( i <= n ) : NEW_LINE INDENT arr [ len1 - 1 ] = i ; NEW_LINE printSeqUtil ( n , k , len1 , arr ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT len1 -= 1 ; NEW_LINE DEDENT def printSeq ( n , k ) : NEW_LINE INDENT arr = [ 0 ] * k ; NEW_LINE len1 = 0 ; NEW_LINE printSeqUtil ( n , k , len1 , arr ) ; NEW_LINE DEDENT k = 3 ; NEW_LINE n = 7 ; NEW_LINE printSeq ( n , k ) ; NEW_LINE"],"bleu":0.579141696106423,"rouge_l":0.8119323520200438}
{"id":1319,"predictions":["MAXN = 1000001 NEW_LINE spf = [ 0 for i in range ( MAXN ) ] NEW_LINE hash1 = [ 0 for i in range ( MAXN ) ] NEW_LINE hash1 = [ 0 for i in range ( MAXN ) ] NEW_LINE def sieve ( ) : NEW_LINE INDENT spf [ 1 ] = 1 NEW_LINE for i in range ( 2 , MAXN ) : NEW_LINE INDENT spf [ i ] = i NEW_LINE DEDENT for i in range ( 4 , MAXN , 2 ) : NEW_LINE INDENT spf [ i ] = 2 NEW_LINE DEDENT i in range ( 3 , MAXN ) : NEW_LINE INDENT if ( spf [ i ] == i ) : NEW_LINE INDENT for j in range ( i * i , MAXN , i ) : NEW_LINE INDENT if ( spf [ j ] == j ) : NEW_LINE INDENT spf [ j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def getFactorization ( x ) : NEW_LINE INDENT while ( x != 1 ) : NEW_LINE INDENT temp = spf [ x ] NEW_LINE if ( x % temp == 0 ) : NEW_LINE INDENT hash1 [ spf [ x ] ] += 1 NEW_LINE x = x \/\/ spf [ x ] NEW_LINE DEDENT while ( x % temp == 0 ) : NEW_LINE INDENT x = x \/\/ temp NEW_LINE DEDENT DEDENT DEDENT def check ( x ) : NEW_LINE INDENT while ( x != 1 ) : NEW_LINE INDENT temp = spf [ x ] NEW_LINE if ( x % temp == 0 and hash1 [ temp ] > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( x % temp == 0 and hash1 [ temp ] > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 8 , 4 , 10 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE if ( hasValidNum ( arr , n )"],"references":["MAXN = 1000001 NEW_LINE spf = [ i for i in range ( MAXN ) ] NEW_LINE hash1 = [ 0 for i in range ( MAXN ) ] NEW_LINE def sieve ( ) : NEW_LINE INDENT for i in range ( 4 , MAXN , 2 ) : NEW_LINE INDENT spf [ i ] = 2 NEW_LINE DEDENT for i in range ( 3 , MAXN ) : NEW_LINE INDENT if i * i < MAXN : NEW_LINE INDENT break NEW_LINE DEDENT if ( spf [ i ] == i ) : NEW_LINE INDENT for j in range ( i * i , MAXN , i ) : NEW_LINE INDENT if ( spf [ j ] == j ) : NEW_LINE INDENT spf [ j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def getFactorization ( x ) : NEW_LINE INDENT while ( x != 1 ) : NEW_LINE INDENT temp = spf [ x ] NEW_LINE if ( x % temp == 0 ) : NEW_LINE INDENT hash1 [ spf [ x ] ] += 1 NEW_LINE x = x \/\/ spf [ x ] NEW_LINE DEDENT while ( x % temp == 0 ) : NEW_LINE INDENT x = x \/\/ temp NEW_LINE DEDENT DEDENT DEDENT def check ( x ) : NEW_LINE INDENT while ( x != 1 ) : NEW_LINE INDENT temp = spf [ x ] NEW_LINE if ( x % temp == 0 and hash1 [ temp ] > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( x % temp == 0 ) : NEW_LINE INDENT x = x \/\/ temp NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def hasValidNum ( arr , n ) : NEW_LINE INDENT sieve ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT getFactorization ( arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( check ( arr [ i ] ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT arr = [ 2 , 8 , 4 , 10 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE if ( hasValidNum ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.7491472765431962,"rouge_l":0.7804342207288706}
{"id":1320,"predictions":["from math import gcd NEW_LINE def printRatio ( a , b , c , d ) : NEW_LINE INDENT if ( b * c > a * d ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( b * c > a * d ) : NEW_LINE INDENT temp = c NEW_LINE d = d NEW_LINE a = b NEW_LINE b = temp NEW_LINE DEDENT lcm = ( a * c ) \/\/ gcd ( a , c ) NEW_LINE x = lcm \/\/ c NEW_LINE y = lcm \/\/ c NEW_LINE d *= x NEW_LINE d \/\/= k NEW_LINE d \/\/= k NEW_LINE print ( b , \" : \" , d ) NEW_LINE DEDENT a , b , c , d = 4 , 2 , 2 NEW_LINE printRatio ( a , b , c , d ) NEW_LINE"],"references":["import math NEW_LINE def printRatio ( a , b , c , d ) : NEW_LINE INDENT if ( b * c > a * d ) : NEW_LINE INDENT swap ( c , d ) NEW_LINE swap ( a , b ) NEW_LINE DEDENT lcm = ( a * c ) \/ math . gcd ( a , c ) NEW_LINE x = lcm \/ a NEW_LINE b = int ( b * x ) NEW_LINE y = lcm \/ c NEW_LINE d = int ( d * y ) NEW_LINE k = math . gcd ( b , d ) NEW_LINE b = int ( b \/ k ) NEW_LINE d = int ( d \/ k ) NEW_LINE print ( b , \" : \" , d ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 4 NEW_LINE b = 3 NEW_LINE c = 2 NEW_LINE d = 2 NEW_LINE printRatio ( a , b , c , d ) NEW_LINE DEDENT"],"bleu":0.4846298481943255,"rouge_l":0.6153454249031995}
{"id":1321,"predictions":["def SieveofAtan ( limit ) : NEW_LINE INDENT if ( limit > 2 ) : NEW_LINE INDENT print ( 2 , end = \" ▁ \" ) NEW_LINE DEDENT if ( limit > 3 ) : NEW_LINE INDENT print ( 3 , end = \" ▁ \" ) NEW_LINE DEDENT sieve = [ 0 for i in range ( limit ) ] NEW_LINE for x in range ( 1 , int ( sqrt ( limit ) ) ) : NEW_LINE INDENT for y in range ( 1 , int ( sqrt ( limit ) ) + 1 ) : NEW_LINE INDENT for y in range ( 1 , y * y ) : NEW_LINE INDENT n = ( 4 * x ) + ( y % y * y ) NEW_LINE if ( n <= ( n % 10 and ( n % 10 == 0 or ( n % 10 ) == 0 ) ) ) : NEW_LINE INDENT sieve [ n ] ^= True NEW_LINE DEDENT n = ( 3 * x ) + ( y * y * y ) NEW_LINE if ( n < 2 and ( x % 10 == 0 and y % 10 == 0 ) ) : NEW_LINE INDENT sieve [ n ] ^= 1 NEW_LINE DEDENT n = ( 3 * x ) - ( y * y ) NEW_LINE if ( x > y and ( x % 10 == 0 and y % 10 == 0 ) : NEW_LINE INDENT sieve [ n ] = False NEW_LINE DEDENT DEDENT DEDENT for i in range ( 5 , limit ) : NEW_LINE INDENT if ( sieve [ i ] ) : NEW_LINE INDENT for i in range ( r * r , limit + 1 ) : NEW_LINE INDENT sieve [ i ] = False NEW_LINE DEDENT DEDENT DEDENT return 0 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT limit = 20 NEW_LINE SieveOfAtIT ( limit ) NEW_LINE DEDENT"],"references":["def SieveOfAtkin ( limit ) : NEW_LINE INDENT if ( limit > 2 ) : NEW_LINE INDENT print ( 2 , end = \" ▁ \" ) NEW_LINE DEDENT if ( limit > 3 ) : NEW_LINE INDENT print ( 3 , end = \" ▁ \" ) NEW_LINE DEDENT sieve = [ False ] * limit NEW_LINE for i in range ( 0 , limit ) : NEW_LINE INDENT sieve [ i ] = False NEW_LINE DEDENT x = 1 NEW_LINE while ( x * x < limit ) : NEW_LINE INDENT y = 1 NEW_LINE while ( y * y < limit ) : NEW_LINE INDENT n = ( 4 * x * x ) + ( y * y ) NEW_LINE if ( n <= limit and ( n % 12 == 1 or n % 12 == 5 ) ) : NEW_LINE INDENT sieve [ n ] ^= True NEW_LINE DEDENT n = ( 3 * x * x ) + ( y * y ) NEW_LINE if ( n <= limit and n % 12 == 7 ) : NEW_LINE INDENT sieve [ n ] ^= True NEW_LINE DEDENT n = ( 3 * x * x ) - ( y * y ) NEW_LINE if ( x > y and n <= limit and n % 12 == 11 ) : NEW_LINE INDENT sieve [ n ] ^= True NEW_LINE DEDENT y += 1 NEW_LINE DEDENT x += 1 NEW_LINE DEDENT r = 5 NEW_LINE while ( r * r < limit ) : NEW_LINE INDENT if ( sieve [ r ] ) : NEW_LINE INDENT for i in range ( r * r , limit , r * r ) : NEW_LINE INDENT sieve [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for a in range ( 5 , limit ) : NEW_LINE INDENT if ( sieve [ a ] ) : NEW_LINE INDENT print ( a , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT limit = 20 NEW_LINE SieveOfAtkin ( limit ) NEW_LINE"],"bleu":0.6062908565713269,"rouge_l":0.6973102785782901}
{"id":1322,"predictions":["def calculateSide ( n , r ) : NEW_LINE INDENT theta = 360 \/ n NEW_LINE theta_in_radians = theta * 3.14 \/ 180 NEW_LINE return 2 * r * sin ( theta_in_radians \/ 2 ) NEW_LINE DEDENT n = 3 NEW_LINE r = 5 NEW_LINE print ( calculateSide ( n , r ) ) NEW_LINE"],"references":["from math import sin NEW_LINE def calculateSide ( n , r ) : NEW_LINE INDENT theta = 360 \/ n NEW_LINE theta_in_radians = theta * 3.14 \/ 180 NEW_LINE return 2 * r * sin ( theta_in_radians \/ 2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE r = 5 NEW_LINE print ( ' { 0 : . 5 } ' . format ( calculateSide ( n , r ) ) ) NEW_LINE DEDENT"],"bleu":0.541967452694946,"rouge_l":0.7503914113173787}
{"id":1323,"predictions":["def findSum ( n ) : NEW_LINE INDENT arr = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT arr [ i ] [ j ] = abs ( i - j ) NEW_LINE DEDENT DEDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT sum += arr [ i ] [ j ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE print ( findSum ( n ) ) NEW_LINE DEDENT"],"references":["def findSum ( n ) : NEW_LINE INDENT arr = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT arr [ i ] [ j ] = abs ( i - j ) NEW_LINE DEDENT DEDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT sum += arr [ i ] [ j ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE print ( findSum ( n ) ) NEW_LINE DEDENT"],"bleu":1.0,"rouge_l":1.0}
{"id":1324,"predictions":["def solve ( Array , N , K ) : NEW_LINE INDENT count_Arr = [ 0 ] * ( N + 2 ) NEW_LINE factor = 1 NEW_LINE size = N NEW_LINE while ( size > 0 ) : NEW_LINE INDENT start = 1 NEW_LINE end = size NEW_LINE count_Arr [ 1 ] += factor * N NEW_LINE count_Arr [ end + 1 ] -= factor * N NEW_LINE factor += 1 NEW_LINE factor += 1 NEW_LINE DEDENT for i in range ( 2 , N + 1 ) : NEW_LINE INDENT count_Arr [ i ] += count_Arr [ i - 1 ] NEW_LINE DEDENT element = [ ] NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT count_Arr [ i ] += count_Arr [ i ] NEW_LINE DEDENT element = 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT count_Arr [ i ] += count_Arr [ i ] NEW_LINE element += 1 NEW_LINE if ( K >= start and K <= end ) : NEW_LINE INDENT return element [ i ] [ 0 ] NEW_LINE DEDENT start += element [ i ] NEW_LINE DEDENT return - 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 4 , 5 , 1 ] NEW_LINE N = len ( arr ) NEW_LINE K = 13 NEW_LINE print ( solve ( arr , N , K ) ) NEW_LINE DEDENT"],"references":["def solve ( Array , N , K ) : NEW_LINE INDENT count_Arr = [ 0 ] * ( N + 2 ) ; NEW_LINE factor = 1 ; NEW_LINE size = N ; NEW_LINE while ( size ) : NEW_LINE INDENT start = 1 ; NEW_LINE end = size ; NEW_LINE count_Arr [ 1 ] += factor * N ; NEW_LINE count_Arr [ end + 1 ] -= factor * N ; NEW_LINE factor += 1 ; NEW_LINE size \/\/= 2 ; NEW_LINE DEDENT for i in range ( 2 , N + 1 ) : NEW_LINE INDENT count_Arr [ i ] += count_Arr [ i - 1 ] ; NEW_LINE DEDENT element = [ ] ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT element . append ( ( Array [ i ] , count_Arr [ i + 1 ] ) ) ; NEW_LINE DEDENT element . sort ( ) ; NEW_LINE start = 1 ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT end = start + element [ i ] [ 1 ] - 1 ; NEW_LINE if ( K >= start and K <= end ) : NEW_LINE INDENT return element [ i ] [ 0 ] ; NEW_LINE DEDENT start += element [ i ] [ 1 ] ; NEW_LINE DEDENT return - 1 ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 4 , 5 , 1 ] ; NEW_LINE N = len ( arr ) ; NEW_LINE K = 13 ; NEW_LINE print ( solve ( arr , N , K ) ) ; NEW_LINE DEDENT"],"bleu":0.653256297845135,"rouge_l":0.8579990215264187}
{"id":1325,"predictions":["def display ( n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , int ( n \/ 2 ) + 1 ) : NEW_LINE INDENT if ( ( j == 0 or i != n \/ 2 ) and ( i != 0 and i == n \/ 2 ) ) : NEW_LINE INDENT print ( \" * \" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT n = 0 NEW_LINE display ( 7 ) NEW_LINE"],"references":["def display ( n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( ( n \/\/ 2 ) + 1 ) : NEW_LINE INDENT if ( ( j == 0 or j == n \/\/ 2 ) and i != 0 or i == 0 and j != 0 and j != n \/\/ 2 or i == n \/\/ 2 ) : NEW_LINE INDENT print ( \" * \" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" ▁ \" , end = \" \" ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT display ( 7 ) NEW_LINE"],"bleu":0.6763527339679063,"rouge_l":0.8177410154021677}
{"id":1326,"predictions":["def maxSum ( arr1 , arr2 , n ) : NEW_LINE INDENT initialParity = 0 NEW_LINE finalParity = 0 NEW_LINE sum = 0 NEW_LINE minPositive = - 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT finalParity += arr2 [ i ] NEW_LINE if ( arr1 [ i ] >= 0 ) : NEW_LINE INDENT finalParity += 1 NEW_LINE sum += arr1 [ i ] NEW_LINE minPositive = min ( minPositive , arr1 [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT maxNegative = max ( maxNegative , arr1 [ i ] ) NEW_LINE DEDENT DEDENT if ( finalParity % 2 == finalParity % 2 == 0 ) : NEW_LINE INDENT return sum NEW_LINE DEDENT else : NEW_LINE INDENT if ( minPositive + maxNegative >= 0 ) : NEW_LINE INDENT return sum + maxNegative NEW_LINE DEDENT else : NEW_LINE INDENT return sum - minPositive NEW_LINE DEDENT DEDENT DEDENT arr1 = [ 2 , - 4 , 5 , 3 ] NEW_LINE arr2 = [ 0 , 1 , 0 , 1 ] NEW_LINE n = len ( arr1 ) NEW_LINE print ( maxSum ( arr1 , arr2 , n ) ) NEW_LINE"],"references":["import sys NEW_LINE def maxSum ( arr1 , arr2 , n ) : NEW_LINE INDENT initialParity , finalParity = 0 , 0 NEW_LINE sum = 0 NEW_LINE minPositive = sys . maxsize NEW_LINE maxNegative = - sys . maxsize - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT initialParity += arr2 [ i ] ; NEW_LINE if ( arr1 [ i ] >= 0 ) : NEW_LINE INDENT finalParity += 1 NEW_LINE sum += arr1 [ i ] NEW_LINE minPositive = min ( minPositive , arr1 [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT maxNegative = max ( maxNegative , arr1 [ i ] ) NEW_LINE DEDENT DEDENT if ( initialParity % 2 == finalParity % 2 ) : NEW_LINE INDENT return sum NEW_LINE DEDENT else : NEW_LINE INDENT if ( minPositive + maxNegative >= 0 ) : NEW_LINE INDENT return sum + maxNegative NEW_LINE DEDENT else : NEW_LINE INDENT return sum - minPositive NEW_LINE DEDENT DEDENT DEDENT arr1 = [ 2 , - 4 , 5 , 3 ] NEW_LINE arr2 = [ 0 , 1 , 0 , 1 ] NEW_LINE n = len ( arr1 ) NEW_LINE print ( maxSum ( arr1 , arr2 , n ) ) NEW_LINE"],"bleu":0.8555225480037293,"rouge_l":0.922013185399582}
{"id":1327,"predictions":["def printXababab2 ( N ) : NEW_LINE INDENT i = 1 NEW_LINE count = 0 NEW_LINE while ( count < N ) : NEW_LINE INDENT int_count = 0 NEW_LINE for j in range ( 1 , pow ( i , 1 \/ 3 ) + 1 ) : NEW_LINE INDENT for k in range ( j + 1 , pow ( i , 1.0 \/ 3 ) + 1 ) : NEW_LINE INDENT if ( j * j * j + k * k == i ) : NEW_LINE INDENT count_count += 1 NEW_LINE DEDENT DEDENT DEDENT if ( int ( count ) == 2 ) : NEW_LINE INDENT count += 1 NEW_LINE print ( count , \" ▁ \" , i ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT N = 5 NEW_LINE print ( N ) NEW_LINE"],"references":["def printTaxicab2 ( N ) : NEW_LINE INDENT i , count = 1 , 0 NEW_LINE while ( count < N ) : NEW_LINE INDENT int_count = 0 NEW_LINE for j in range ( 1 , int ( pow ( i , 1.0 \/ 3 ) ) + 1 ) : NEW_LINE INDENT for k in range ( j + 1 , int ( pow ( i , 1.0 \/ 3 ) ) + 1 ) : NEW_LINE INDENT if ( j * j * j + k * k * k == i ) : NEW_LINE INDENT int_count += 1 NEW_LINE DEDENT DEDENT DEDENT if ( int_count == 2 ) : NEW_LINE INDENT count += 1 NEW_LINE print ( count , \" ▁ \" , i ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT N = 5 NEW_LINE printTaxicab2 ( N ) NEW_LINE"],"bleu":0.797188095000926,"rouge_l":0.902408256880734}
{"id":1328,"predictions":["def findIndex ( a , n , key ) : NEW_LINE INDENT start = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == key ) : NEW_LINE INDENT start = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( start == - 1 ) : NEW_LINE INDENT print ( \" Key ▁ not ▁ present ▁ in ▁ array ▁ in ▁ array \" ) NEW_LINE return NEW_LINE DEDENT end = start NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT if ( a [ i ] == key ) : NEW_LINE INDENT end = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( start == end ) : NEW_LINE INDENT print ( \" Key ▁ is ▁ present ▁ at ▁ index ▁ : ▁ \" , start ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" First ▁ index ▁ is ▁ present ▁ at ▁ index ▁ : ▁ \" , start ) NEW_LINE print ( \" There ▁ is ▁ \" , start ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 7 , 7 , 8 , 8 , 9 , 8 , 8 , 8 , 0 , 0 , 0 , 8 ] NEW_LINE k = 8 NEW_LINE findIndex ( a , len ( a ) ) NEW_LINE DEDENT"],"references":["def findIndex ( a , n , key ) : NEW_LINE INDENT start = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == key : NEW_LINE INDENT start = i NEW_LINE break NEW_LINE DEDENT DEDENT if start == - 1 : NEW_LINE INDENT print ( \" Key ▁ not ▁ present ▁ in ▁ array \" ) NEW_LINE return 0 NEW_LINE DEDENT end = start NEW_LINE for i in range ( n - 1 , start - 1 , - 1 ) : NEW_LINE INDENT if a [ i ] == key : NEW_LINE INDENT end = i NEW_LINE break NEW_LINE DEDENT DEDENT if start == end : NEW_LINE INDENT print ( \" Only ▁ one ▁ key ▁ is ▁ present ▁ at ▁ index ▁ : ▁ \" , start ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Start ▁ index : ▁ \" , start ) NEW_LINE print ( \" Last ▁ index : ▁ \" , end ) NEW_LINE DEDENT DEDENT a = [ 1 , 2 , 7 , 8 , 8 , 9 , 8 , 0 , 0 , 0 , 8 ] NEW_LINE n = len ( a ) NEW_LINE key = 8 NEW_LINE findIndex ( a , n , key ) NEW_LINE"],"bleu":0.6919421670331134,"rouge_l":0.844602192859151}
{"id":1329,"predictions":["ans = 0 NEW_LINE gr = [ ] NEW_LINE def Add_Edge ( u , v ) : NEW_LINE INDENT gr [ u ] . append ( u ) NEW_LINE gr [ v ] . append ( u ) NEW_LINE DEDENT def dfs ( node , par , color ) : NEW_LINE INDENT if ( color [ child ] != 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT for i in range ( 0 , len ( gr [ child ] ) ) : NEW_LINE INDENT if ( gr [ child ] [ i ] == par ) : NEW_LINE INDENT continue NEW_LINE DEDENT dfs ( gr [ child ] [ i ] , child , color ) NEW_LINE DEDENT DEDENT color = [ 0 , 1 , 2 , 3 , 2 , 2 , 3 ] NEW_LINE Add_Edge ( 1 , 2 ) NEW_LINE Add_Edge ( 1 , 3 ) NEW_LINE Add_Edge ( 1 , 4 ) NEW_LINE Add_Edge ( 2 , 5 ) NEW_LINE Add_Edge ( 2 , 4 ) NEW_LINE Add_Edge ( 3 , 6 ) NEW_LINE Add_Edge ( 2 , 5 ) NEW_LINE Add_Edge ( 3 , 6 ) NEW_LINE Add_Edge ( 3 , 6 ) NEW_LINE Add_Edge ( 3 , 6 ) NEW_LINE print ( ans ) NEW_LINE"],"references":["ans = 0 NEW_LINE gr = [ [ ] for i in range ( 100005 ) ] NEW_LINE def Add_Edge ( u , v ) : NEW_LINE INDENT gr [ u ] . append ( v ) NEW_LINE gr [ v ] . append ( u ) NEW_LINE DEDENT def dfs ( child , par , color ) : NEW_LINE INDENT global ans NEW_LINE if ( color [ child ] != color [ par ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT for it in gr [ child ] : NEW_LINE INDENT if ( it == par ) : NEW_LINE INDENT continue NEW_LINE DEDENT dfs ( it , child , color ) NEW_LINE DEDENT DEDENT color = [ 0 , 1 , 2 , 3 , 2 , 2 , 3 ] NEW_LINE Add_Edge ( 1 , 2 ) NEW_LINE Add_Edge ( 1 , 3 ) NEW_LINE Add_Edge ( 2 , 4 ) NEW_LINE Add_Edge ( 2 , 5 ) NEW_LINE Add_Edge ( 3 , 6 ) NEW_LINE dfs ( 1 , 0 , color ) NEW_LINE print ( ans ) NEW_LINE"],"bleu":0.6816134786048456,"rouge_l":0.8083173597799815}
{"id":1330,"predictions":["import sys NEW_LINE def longestFibonacciSubarray ( n , a ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT len = 2 NEW_LINE mx = - sys . maxsize - 1 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( a [ i ] == a [ i - 1 ] + a [ i - 2 ] ) : NEW_LINE INDENT len += 1 NEW_LINE DEDENT else : NEW_LINE INDENT len = 2 NEW_LINE DEDENT mx = max ( mx , len ) NEW_LINE DEDENT return mx NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 NEW_LINE a = [ 2 , 4 , 6 , 10 , 2 ] NEW_LINE print ( longestFibonacciSubarray ( n , a ) ) NEW_LINE DEDENT"],"references":["def longestFibonacciSubarray ( n , a ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT Len = 2 NEW_LINE mx = - 10 ** 9 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( a [ i ] == a [ i - 1 ] + a [ i - 2 ] ) : NEW_LINE INDENT Len += 1 NEW_LINE DEDENT else : NEW_LINE INDENT Len = 2 NEW_LINE DEDENT mx = max ( mx , Len ) NEW_LINE DEDENT return mx NEW_LINE DEDENT n = 5 NEW_LINE a = [ 2 , 4 , 6 , 10 , 2 ] NEW_LINE print ( longestFibonacciSubarray ( n , a ) ) NEW_LINE"],"bleu":0.7558669222586046,"rouge_l":0.8894743291263325}
{"id":1331,"predictions":["def answerMatrix ( root , matrix , size ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( root == None ) : NEW_LINE INDENT return NEW_LINE DEDENT inverseMatrix ( root . left , matrix , size ) NEW_LINE if ( root . left != None ) : NEW_LINE INDENT matrix [ root . data ] [ root . left . data ] = 1 NEW_LINE for i in range ( size ) : NEW_LINE INDENT if ( matrix [ root . left . data ] [ i ] == 1 ) : NEW_LINE INDENT matrix [ root . data ] [ i ] = 1 NEW_LINE DEDENT DEDENT DEDENT if ( root . right != None ) : NEW_LINE INDENT matrix [ root . data ] [ root . right . data ] = 1 NEW_LINE for i in range ( size ) : NEW_LINE INDENT if ( matrix [ root . right . data ] [ i ] == 1 ) : NEW_LINE INDENT matrix [ root . data ] [ i ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( root . right ) : NEW_LINE INDENT matrix [ root . data ] [ root . right . left ] = 1 NEW_LINE for i in range ( size ) : NEW_LINE INDENT if ( matrix [ root . right . data ] [ i ] == 1 ) : NEW_LINE INDENT matrix [ root . data ] [ i ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root_root = newNode ( 5 ) NEW_LINE root_root . left = newNode ( 1 ) NEW_LINE root_root . left = newNode ( 2 ) NEW_LINE root_root . left . left = newNode ( 0 ) NEW_LINE root_root . left . left = newNode ( 4 ) NEW_LINE root_root . right . left = newNode ( 0 for i in range ( size ) : NEW_LINE INDENT for j in range ( size ) : NEW_LINE INDENT print ( matrix [ i ] [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE D"],"references":["class newnode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = self . right = None NEW_LINE DEDENT DEDENT def ancestorMatrixRec ( root , anc ) : NEW_LINE INDENT global mat , MAX NEW_LINE if root == None : NEW_LINE INDENT return 0 NEW_LINE DEDENT data = root . data NEW_LINE for i in range ( len ( anc ) ) : NEW_LINE INDENT mat [ anc [ i ] ] [ data ] = 1 NEW_LINE DEDENT anc . append ( data ) NEW_LINE l = ancestorMatrixRec ( root . left , anc ) NEW_LINE r = ancestorMatrixRec ( root . right , anc ) NEW_LINE anc . pop ( - 1 ) NEW_LINE return l + r + 1 NEW_LINE DEDENT def ancestorMatrix ( root ) : NEW_LINE INDENT anc = [ ] NEW_LINE n = ancestorMatrixRec ( root , anc ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT MAX = 100 NEW_LINE mat = [ [ 0 ] * MAX for i in range ( MAX ) ] NEW_LINE root = newnode ( 5 ) NEW_LINE root . left = newnode ( 1 ) NEW_LINE root . right = newnode ( 2 ) NEW_LINE root . left . left = newnode ( 0 ) NEW_LINE root . left . right = newnode ( 4 ) NEW_LINE root . right . left = newnode ( 3 ) NEW_LINE ancestorMatrix ( root ) NEW_LINE"],"bleu":0.30124348095963105,"rouge_l":0.4567542787286064}
{"id":1332,"predictions":["def OddDivCount ( a , b ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT divCount = 0 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT divCount += 1 NEW_LINE DEDENT DEDENT if ( ( divCount % 2 ) != 0 ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT a = 1 NEW_LINE b = 10 NEW_LINE print ( OddCount ( a , b ) ) NEW_LINE"],"references":["def OddDivCount ( a , b ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT divCount = 0 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT divCount += 1 NEW_LINE DEDENT DEDENT if ( divCount % 2 ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 1 NEW_LINE b = 10 NEW_LINE print ( OddDivCount ( a , b ) ) NEW_LINE DEDENT"],"bleu":0.8238451892823746,"rouge_l":0.9008054892601433}
{"id":1333,"predictions":["def findNDigitNumsUtil ( n , sum , out , index ) : NEW_LINE INDENT if index > n or sum < 0 : NEW_LINE INDENT return NEW_LINE DEDENT if ( index == n ) : NEW_LINE INDENT if ( sum == 0 ) : NEW_LINE INDENT if ( sum == 0 ) : NEW_LINE INDENT out [ index ] = ' NEW_LINE print ( out , end = \" \" ) NEW_LINE print ( \" ▁ \" ) NEW_LINE print ( \" ▁ \" , end = \" \" ) NEW_LINE DEDENT return NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT out [ index ] = chr ( i + ord ( '0' ) ) ) NEW_LINE findNDigitNumsUtil ( n , sum - i , out , index + 1 ) NEW_LINE DEDENT DEDENT def findNDigNums ( n , sum ) : NEW_LINE INDENT out = [ ] NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT out . append ( i + ord ( '0' ) ) NEW_LINE findNDigitNumsUtil ( n , sum - i , out , 1 ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 2 NEW_LINE sum = 3 NEW_LINE findNDigitNums ( n , sum ) NEW_LINE DEDENT"],"references":["def findNDigitNumsUtil ( n , sum , out , index ) : NEW_LINE INDENT if ( index > n or sum < 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT f = \" \" NEW_LINE if ( index == n ) : NEW_LINE INDENT if ( sum == 0 ) : NEW_LINE INDENT out [ index ] = \" \" NEW_LINE for i in out : NEW_LINE INDENT f = f + i NEW_LINE DEDENT print ( f , end = \" ▁ \" ) NEW_LINE DEDENT return NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT out [ index ] = chr ( i + ord ( '0' ) ) NEW_LINE findNDigitNumsUtil ( n , sum - i , out , index + 1 ) NEW_LINE DEDENT DEDENT def findNDigitNums ( n , sum ) : NEW_LINE INDENT out = [ False ] * ( n + 1 ) NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT out [ 0 ] = chr ( i + ord ( '0' ) ) NEW_LINE findNDigitNumsUtil ( n , sum - i , out , 1 ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 2 NEW_LINE sum = 3 NEW_LINE findNDigitNums ( n , sum ) NEW_LINE DEDENT"],"bleu":0.8062674059314204,"rouge_l":0.8506422018348624}
{"id":1334,"predictions":["def minimumIncrease ( a , b , c ) : NEW_LINE INDENT arr = [ a , b , c ] NEW_LINE arr . sort ( ) NEW_LINE if ( arr [ 0 ] + arr [ 1 ] >= arr [ 2 ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return arr [ 2 ] - ( arr [ 0 ] + arr [ 1 ] ) NEW_LINE DEDENT DEDENT a = 3 NEW_LINE b = 5 NEW_LINE c = 10 NEW_LINE print ( minimumIncrease ( a , b , c ) ) NEW_LINE"],"references":["def minimumIncrease ( a , b , c ) : NEW_LINE INDENT arr = [ a , b , c ] NEW_LINE arr . sort ( ) NEW_LINE if arr [ 0 ] + arr [ 1 ] >= arr [ 2 ] : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return arr [ 2 ] - ( arr [ 0 ] + arr [ 1 ] ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a , b , c = 3 , 5 , 10 NEW_LINE print ( minimumIncrease ( a , b , c ) ) NEW_LINE DEDENT"],"bleu":0.7573219746020092,"rouge_l":0.8591549295774648}
{"id":1335,"predictions":["def breakSum ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return max ( ( breakSum ( n \/ 2 ) + breakSum ( n \/ 3 ) + breakSum ( n \/\/ 4 ) ) , n ) NEW_LINE DEDENT n = 12 NEW_LINE print ( breakSum ( n ) ) NEW_LINE"],"references":["def breakSum ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return max ( ( breakSum ( n \/\/ 2 ) + breakSum ( n \/\/ 3 ) + breakSum ( n \/\/ 4 ) ) , n ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 12 NEW_LINE print ( breakSum ( n ) ) NEW_LINE DEDENT"],"bleu":0.7301817801332633,"rouge_l":0.8636462644304075}
{"id":1336,"predictions":["def maxLengthSquare ( row , column , arr , k ) : NEW_LINE INDENT sum = [ [ 0 for i in range ( column + 1 ) ] for j in range ( row + 1 ) ] NEW_LINE cur_max = 1 NEW_LINE max = 0 NEW_LINE for i in range ( 1 , row + 1 ) : NEW_LINE INDENT for j in range ( 1 , column + 1 ) : NEW_LINE INDENT sum [ i ] [ j ] = sum [ i - 1 ] [ j ] + sum [ i ] [ j - 1 ] + arr [ i - 1 ] [ j - 1 ] - sum [ i - 1 ] [ j - 1 ] ) NEW_LINE if ( i >= cur_max and j >= cur_max and sum [ i ] [ j ] - sum [ i - cur_max ] [ j - cur_max ] ) : NEW_LINE INDENT max = cur_max + 1 NEW_LINE DEDENT DEDENT DEDENT return max NEW_LINE DEDENT row = 4 NEW_LINE column = 4 NEW_LINE matrix = [ [ 1 , 1 , 1 , 1 ] , [ 1 , 0 , 0 , 0 ] , [ 1 , 0 , 0 , 0 ] , [ 1 , 0 , 0 , 0 ] , [ 1 , 0 , 0 ] ] NEW_LINE k = 6 NEW_LINE ans = maxLengthSquare ( row , column , matrix , k ) NEW_LINE print ( ans ) NEW_LINE"],"references":["import numpy as np NEW_LINE def maxLengthSquare ( row , column , arr , k ) : NEW_LINE INDENT sum = np . zeros ( ( row + 1 , column + 1 ) ) ; NEW_LINE cur_max = 1 ; NEW_LINE max = 0 ; NEW_LINE for i in range ( 1 , row + 1 ) : NEW_LINE INDENT for j in range ( 1 , column + 1 ) : NEW_LINE INDENT sum [ i ] [ j ] = sum [ i - 1 ] [ j ] + sum [ i ] [ j - 1 ] +   \\ NEW_LINE INDENT arr [ i - 1 ] [ j - 1 ] -   \\ NEW_LINE sum [ i - 1 ] [ j - 1 ] ; NEW_LINE DEDENT if ( i >= cur_max and j >= cur_max and sum [ i ] [ j ] - sum [ i - cur_max ] [ j ] - sum [ i ] [ j - cur_max ] + sum [ i - cur_max ] [ j - cur_max ] <= k ) : NEW_LINE INDENT max = cur_max ; NEW_LINE cur_max += 1 ; NEW_LINE DEDENT DEDENT DEDENT return max ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT row = 4 ; NEW_LINE column = 4 ; NEW_LINE matrix = [ [ 1 , 1 , 1 , 1 ] , [ 1 , 0 , 0 , 0 ] , [ 1 , 0 , 0 , 0 ] , [ 1 , 0 , 0 , 0 ] ] ; NEW_LINE k = 6 ; NEW_LINE ans = maxLengthSquare ( row , column , matrix , k ) ; NEW_LINE print ( ans ) ; NEW_LINE DEDENT"],"bleu":0.6803542110122057,"rouge_l":0.806090203964378}
{"id":1337,"predictions":["def minimumChanges ( arr , n ) : NEW_LINE INDENT changes = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT j = j NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ j ] == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT i = j - 1 NEW_LINE changes += 1 NEW_LINE DEDENT DEDENT return changes NEW_LINE DEDENT arr = [ 1 , 1 , 0 , 0 , 0 , 1 , 0 , 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Minimum ▁ operations : ▁ \" , minimumChanges ( arr , n ) ) NEW_LINE"],"references":["def minimumChanges ( arr , n ) : NEW_LINE INDENT changes = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if arr [ i ] == 1 : NEW_LINE INDENT j = i + 1 NEW_LINE while j < n : NEW_LINE INDENT if arr [ j ] == 0 : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT i = j - 1 NEW_LINE changes += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return changes NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 1 , 0 , 0 , 0 , 1 , 0 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Minimum ▁ operations : \" , minimumChanges ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.6473163395654252,"rouge_l":0.8057003823427181}
{"id":1338,"predictions":["MAX = 100005 NEW_LINE def addPrimes ( ) : NEW_LINE INDENT n = MAX NEW_LINE prime = [ True ] * ( n + 1 ) NEW_LINE p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT i = p * p NEW_LINE while ( i <= n ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT ans = [ ] NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT ans . append ( p ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def is_prime ( n ) : NEW_LINE INDENT return ( n == 3 or n == 5 or n == 7 ) NEW_LINE DEDENT def find_Sum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE v = addPrimes ( ) NEW_LINE i = 0 NEW_LINE while ( i < len ( v ) and n > 0 ) : NEW_LINE INDENT flag = 1 NEW_LINE a = v [ i ] NEW_LINE while ( a != 0 ) : NEW_LINE INDENT d = a % 10 NEW_LINE a = a \/\/ 10 NEW_LINE if ( is_prime ( d ) ) : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == 1 ) : NEW_LINE INDENT n -= 1 NEW_LINE sum = sum + v [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 7 NEW_LINE print ( find_Sum ( n ) ) NEW_LINE DEDENT"],"references":["MAX = 100005 NEW_LINE def addPrimes ( ) : NEW_LINE INDENT n = MAX NEW_LINE prime = [ True for i in range ( n + 1 ) ] NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if p * p > n : NEW_LINE INDENT break NEW_LINE DEDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( 2 * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT ans = [ ] NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT ans . append ( p ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def is_prime ( n ) : NEW_LINE INDENT if n in [ 3 , 5 , 7 ] : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def find_Sum ( n ) : NEW_LINE INDENT Sum = 0 NEW_LINE v = addPrimes ( ) NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT flag = 1 NEW_LINE a = v [ i ] NEW_LINE while ( a != 0 ) : NEW_LINE INDENT d = a % 10 ; NEW_LINE a = a \/\/ 10 ; NEW_LINE if ( is_prime ( d ) ) : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == 1 ) : NEW_LINE INDENT n -= 1 NEW_LINE Sum = Sum + v [ i ] NEW_LINE DEDENT if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return Sum NEW_LINE DEDENT n = 7 NEW_LINE print ( find_Sum ( n ) ) NEW_LINE"],"bleu":0.6937802946168352,"rouge_l":0.7964591977869986}
{"id":1339,"predictions":["deflicksentials ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for k in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += k * k * k * k NEW_LINE DEDENT triNo = n * ( n + 1 ) \/\/ 2 NEW_LINE if ( sum == triNo * triNo ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 NEW_LINEeries ( n ) NEW_LINE DEDENT"],"references":["def NicomachuTheorum_sum ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for k in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += k * k * k ; NEW_LINE DEDENT triNo = n * ( n + 1 ) \/ 2 ; NEW_LINE if ( sum == triNo * triNo ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT n = 5 ; NEW_LINE NicomachuTheorum_sum ( n ) ; NEW_LINE"],"bleu":0.6901856907833752,"rouge_l":0.8480737018425462}
{"id":1340,"predictions":["MAX = 1000 NEW_LINE sequence = [ 0 ] * MAX NEW_LINE def vanEckSequence ( ) : NEW_LINE INDENT for i in range ( MAX - 1 ) : NEW_LINE INDENT for j in range ( i - 1 , - 1 ) : NEW_LINE INDENT if ( sequence [ j ] == sequence [ i ] ) : NEW_LINE INDENT sequence [ i + 1 ] = i - j NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT def getNthTerm ( n ) : NEW_LINE INDENT return sequence [ n ] NEW_LINE DEDENT vanEckSequence ( ) NEW_LINE n = 6 NEW_LINE print ( getNthTerm ( n ) ) NEW_LINE n = 100 NEW_LINE print ( getNthTerm ( n ) ) NEW_LINE n = 100 NEW_LINE print ( getNthTerm ( n ) ) NEW_LINE n = 100 NEW_LINE print ( getNthTerm ( n ) ) NEW_LINE"],"references":["MAX = 1000 NEW_LINE sequence = [ 0 ] * ( MAX + 1 ) ; NEW_LINE def vanEckSequence ( ) : NEW_LINE INDENT for i in range ( MAX ) : NEW_LINE INDENT sequence [ i ] = 0 ; NEW_LINE DEDENT for i in range ( MAX ) : NEW_LINE INDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( sequence [ j ] == sequence [ i ] ) : NEW_LINE INDENT sequence [ i + 1 ] = i - j ; NEW_LINE break ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def getNthTerm ( n ) : NEW_LINE INDENT return sequence [ n ] ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT vanEckSequence ( ) ; NEW_LINE n = 6 ; NEW_LINE print ( getNthTerm ( n ) ) ; NEW_LINE n = 100 ; NEW_LINE print ( getNthTerm ( n ) ) ; NEW_LINE DEDENT"],"bleu":0.6159523930502033,"rouge_l":0.7504393673110721}
{"id":1341,"predictions":["def maximum FixedMinimumPoints ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE swapping = 0 NEW_LINE pos = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT pos [ a [ i ] ] = i NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == i ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT elif ( swapping == 0 and pos [ i ] == a [ i ] ) : NEW_LINE INDENT count += 2 NEW_LINE swaps = 1 NEW_LINE DEDENT DEDENT if ( swapping == 0 and count < n - 1 ) : NEW_LINE INDENT count += 2 NEW_LINE DEDENT return count NEW_LINE DEDENT a = [ 0 , 1 , 3 , 4 , 2 ] NEW_LINE n = len ( a ) NEW_LINE print ( maximum FixedPoints ( a , n ) ) NEW_LINE"],"references":["def maximumFixedPoints ( a , n ) : NEW_LINE INDENT pos = [ None ] * n NEW_LINE count , swapped = 0 , 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT pos [ a [ i ] ] = i NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if a [ i ] == i : NEW_LINE INDENT count += 1 NEW_LINE DEDENT elif swapped == 0 and pos [ i ] == a [ i ] : NEW_LINE INDENT count += 2 NEW_LINE swapped = 1 NEW_LINE DEDENT DEDENT if swapped == 0 and count < n - 1 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 0 , 1 , 3 , 4 , 2 ] NEW_LINE n = len ( a ) NEW_LINE print ( maximumFixedPoints ( a , n ) ) NEW_LINE DEDENT"],"bleu":0.6740484167229012,"rouge_l":0.825790513833992}
{"id":1342,"predictions":["def countCurrency ( amount ) : NEW_LINE INDENTNotes = [ 2000 , 500 , 200 , 100 , 50 , 20 , 10 , 10 , 10 , 5 , 1 ] NEW_LINE for i in range ( 9 ) : NEW_LINE INDENT if ( amount >= queries [ i ] ) : NEW_LINE INDENT display [ i ] = int ( amount \/ queries [ i ] ) NEW_LINE amount = amount - total NEW_LINE DEDENT DEDENT print ( \" Currency ▁ - > \" ) NEW_LINE for i in range ( 9 ) : NEW_LINE INDENT if ( frequency [ i ] != 0 ) : NEW_LINE INDENT print ( str ( i ) ) NEW_LINE DEDENT DEDENT DEDENT print ( \" Operation ▁ Count ▁ - > \" ) NEW_LINE for i in range ( 9 ) : NEW_LINE INDENT if ( counter [ i ] != 0 ) : NEW_LINE INDENT print ( str ( str ( i ) ) , \" ▁ : \" , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT amount = 868 NEW_LINE countCruit ( amount ) NEW_LINE DEDENT"],"references":["def countCurrency ( amount ) : NEW_LINE INDENT notes = [ 2000 , 500 , 200 , 100 , 50 , 20 , 10 , 5 , 1 ] NEW_LINE noteCounter = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] NEW_LINE print ( \" Currency ▁ Count ▁ - > ▁ \" ) NEW_LINE for i , j in zip ( notes , noteCounter ) : NEW_LINE INDENT if amount >= i : NEW_LINE INDENT j = amount \/\/ i NEW_LINE amount = amount - j * i NEW_LINE print ( i , \" ▁ : ▁ \" , j ) NEW_LINE DEDENT DEDENT DEDENT amount = 868 NEW_LINE countCurrency ( amount ) NEW_LINE"],"bleu":0.2983427923927395,"rouge_l":0.5237696335078534}
{"id":1343,"predictions":["MAX_CHAR = 256 NEW_LINE def isPalindrome ( str , l , h ) : NEW_LINE INDENT while ( h > l ) : NEW_LINE INDENT if ( str [ l ] != str [ l ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT h += 1 NEW_LINE h -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def check ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE freq = [ 0 for i in range ( MAX_CHAR ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) ] += 1 NEW_LINE if ( freq [ ord ( str [ i ] ) ] > 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT k = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( freq [ str [ i ] ] > 1 ) : NEW_LINE INDENT str [ ord ( str [ i ] ) ] += 1 NEW_LINE k += 1 NEW_LINE DEDENT DEDENT if ( isPalindrome ( str , 0 , k - 1 ) ) : NEW_LINE INDENT if ( ( k & 1 ) == 1 ) : NEW_LINE INDENT if ( k \/\/ 2 >= 1 ) : NEW_LINE INDENT return ( str [ k \/\/ 2 ] == str [ k \/\/ 2 - 1 ] ) NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" ABCABD \" NEW_LINE if ( check ( str ) ) : NEW_LINE INDENT print ( \" Repeated ▁ Subsequence ▁ Subsequence ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Impossible ▁ \" ) NEW_LINE DEDENT DEDENT"],"references":["MAX_CHAR = 256 NEW_LINE def isPalindrome ( Str , l , h ) : NEW_LINE INDENT while ( h > l ) : NEW_LINE INDENT if ( Str [ l ] != Str [ h ] ) : NEW_LINE INDENT l += 1 NEW_LINE h -= 1 NEW_LINE return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def check ( Str ) : NEW_LINE INDENT n = len ( Str ) NEW_LINE freq = [ 0 for i in range ( MAX_CHAR ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( Str [ i ] ) ] += 1 NEW_LINE if ( freq [ ord ( Str [ i ] ) ] > 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT k = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( freq [ ord ( Str [ i ] ) ] > 1 ) : NEW_LINE INDENT Str [ k ] = Str [ i ] NEW_LINE k += 1 NEW_LINE DEDENT DEDENT Str [ k ] = ' \\0' NEW_LINE if ( isPalindrome ( Str , 0 , k - 1 ) ) : NEW_LINE INDENT if ( k & 1 ) : NEW_LINE INDENT return Str [ k \/\/ 2 ] == Str [ k \/\/ 2 - 1 ] NEW_LINE DEDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT S = \" ABCABD \" NEW_LINE Str = [ i for i in S ] NEW_LINE if ( check ( Str ) ) : NEW_LINE INDENT print ( \" Repeated ▁ Subsequence ▁ Exists \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Repeated ▁ Subsequence ▁ Doesn ' t ▁ Exists \" ) NEW_LINE DEDENT"],"bleu":0.696894259094753,"rouge_l":0.8086108676599474}
{"id":1344,"predictions":["N = 100005 NEW_LINE mod = 1000000007 NEW_LINE cnt = [ 0 ] * N NEW_LINE def Divisors ( ) : NEW_LINE INDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( 1 , int ( sqrt ( N ) ) + 1 ) : NEW_LINE INDENT cnt [ i * j ] += 1 NEW_LINE DEDENT DEDENT DEDENT def Sumofdivisors ( ) : NEW_LINE INDENT Sum = 0 NEW_LINE Divisors ( ) NEW_LINE for i in range ( 1 , A + 1 ) : NEW_LINE INDENT for j in range ( 1 , B + 1 ) : NEW_LINE INDENT x = i * j * k NEW_LINE Sum += cnt [ x ] NEW_LINE if ( Sum >= mod ) : NEW_LINE INDENT Sum -= mod NEW_LINE DEDENT DEDENT DEDENT return Sum NEW_LINE DEDENT A = 5 NEW_LINE B = 6 NEW_LINE C = 7 NEW_LINE print ( Sumofdivisors ( A , B , C ) ) NEW_LINE"],"references":["N = 100005 NEW_LINE mod = 1000000007 NEW_LINE cnt = [ 0 ] * N ; NEW_LINE def Divisors ( ) : NEW_LINE INDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( 1 , N \/\/ i ) : NEW_LINE INDENT cnt [ i * j ] += 1 ; NEW_LINE DEDENT DEDENT DEDENT def Sumofdivisors ( A , B , C ) : NEW_LINE INDENT sum = 0 ; NEW_LINE Divisors ( ) ; NEW_LINE for i in range ( 1 , A + 1 ) : NEW_LINE INDENT for j in range ( 1 , B + 1 ) : NEW_LINE INDENT for k in range ( 1 , C + 1 ) : NEW_LINE INDENT x = i * j * k ; NEW_LINE sum += cnt [ x ] ; NEW_LINE if ( sum >= mod ) : NEW_LINE INDENT sum -= mod ; NEW_LINE DEDENT DEDENT DEDENT DEDENT return sum ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = 5 ; B = 6 ; C = 7 ; NEW_LINE print ( Sumofdivisors ( A , B , C ) ) ; NEW_LINE DEDENT"],"bleu":0.6053808038538637,"rouge_l":0.8044874539693414}
{"id":1345,"predictions":["def factorial ( N ) : NEW_LINE INDENT fact = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT fact = fact * i NEW_LINE DEDENT return fact NEW_LINE DEDENT def nthTerm ( N ) : NEW_LINE INDENT return ( factorial ( N + 1 ) \/ 2 ) NEW_LINE DEDENT N = 6 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE"],"references":["def factorial ( N ) : NEW_LINE INDENT fact = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT fact = fact * i NEW_LINE DEDENT return fact NEW_LINE DEDENT def nthTerm ( N ) : NEW_LINE INDENT return ( factorial ( N + 1 ) \/\/ 2 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 6 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT"],"bleu":0.770696112772801,"rouge_l":0.8816506074570589}
{"id":1346,"predictions":["def prefix ( string ) : NEW_LINE INDENT k = 1 NEW_LINE n = len ( string ) NEW_LINE g = [ ] NEW_LINE flag = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( string [ i ] == string [ 0 ] ) : NEW_LINE INDENT g . append ( i ) NEW_LINE flag = 1 NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT print ( string ) NEW_LINE DEDENT else : NEW_LINE INDENT length = len ( g ) NEW_LINE while ( k < g [ 0 ] ) : NEW_LINE INDENT cnt = 0 NEW_LINE for j in range ( 0 , length ) : NEW_LINE INDENT if ( ( g [ j ] + k ) < n and string [ g [ g [ j ] + k ] == string [ k ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if ( cnt == length ) : NEW_LINE INDENT k += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in range ( k ) : NEW_LINE INDENT print ( string [ i ] , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" abcab \" NEW_LINE prefix ( string ) NEW_LINE DEDENT"],"references":["def prefix ( string ) : NEW_LINE INDENT k = 1 ; NEW_LINE n = len ( string ) ; NEW_LINE g = [ ] ; NEW_LINE flag = 0 ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( string [ i ] == string [ 0 ] ) : NEW_LINE INDENT g . append ( i ) ; NEW_LINE flag = 1 ; NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT print ( string ) ; NEW_LINE DEDENT else : NEW_LINE INDENT length = len ( g ) ; NEW_LINE while ( k < g [ 0 ] ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for j in range ( length ) : NEW_LINE INDENT if ( string [ g [ j ] + k ] == string [ k ] ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT if ( cnt == len ) : NEW_LINE INDENT k += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT for i in range ( k + 1 ) : NEW_LINE INDENT print ( string [ i ] , end = \" \" ) ; NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" abcab \" ; NEW_LINE prefix ( string ) ; NEW_LINE DEDENT"],"bleu":0.8025117748343278,"rouge_l":0.9281699794379712}
{"id":1347,"predictions":["def findTerm ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT else : NEW_LINE INDENT term = 7 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT term = term * 2 + ( i - 1 ) NEW_LINE DEDENT return term NEW_LINE DEDENT DEDENT n = 5 NEW_LINE print ( findTerm ( n ) ) NEW_LINE"],"references":["def findTerm ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return n NEW_LINE DEDENT else : NEW_LINE INDENT term = 7 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT term = term * 2 + ( i - 1 ) ; NEW_LINE DEDENT DEDENT return term ; NEW_LINE DEDENT print ( findTerm ( 5 ) ) NEW_LINE"],"bleu":0.76680096167949,"rouge_l":0.9201670921327452}
{"id":1348,"predictions":["INT_SIZE = 32 NEW_LINE def Right_most_setbit ( num ) : NEW_LINE INDENT pos = 1 NEW_LINE for i in range ( INT_SIZE ) : NEW_LINE INDENT if ( ( num & ( 1 << i ) ) == 0 ) : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return pos NEW_LINE DEDENT num = 18 NEW_LINE pos = Right_most_setbit ( num ) NEW_LINE print ( pos ) NEW_LINE"],"references":["INT_SIZE = 32 NEW_LINE def Right_most_setbit ( num ) : NEW_LINE INDENT pos = 1 NEW_LINE for i in range ( INT_SIZE ) : NEW_LINE INDENT if not ( num & ( 1 << i ) ) : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return pos NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT num = 18 NEW_LINE pos = Right_most_setbit ( num ) NEW_LINE print ( pos ) NEW_LINE DEDENT"],"bleu":0.7776937508456211,"rouge_l":0.8728139904610492}
{"id":1349,"predictions":["def subarrayXor ( arr , n , m ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT xorSum = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT xorSum = xorSum ^ arr [ j ] NEW_LINE if xorSum == m : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 4 , 2 , 2 , 6 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE m = 6 NEW_LINE print ( \" Number ▁ of ▁ subarrays ▁ having ▁ given ▁ XOR ▁ is ▁ \" , subarrayXor ( arr , n , m ) ) NEW_LINE"],"references":["def subarrayXor ( arr , n , m ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT xorSum = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT xorSum = xorSum ^ arr [ j ] NEW_LINE if ( xorSum == m ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT arr = [ 4 , 2 , 2 , 6 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE m = 6 NEW_LINE print ( \" Number ▁ of ▁ subarrays ▁ having ▁ given ▁ XOR ▁ is ▁ \" , subarrayXor ( arr , n , m ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"bleu":0.7443574101474789,"rouge_l":0.8741698706745893}
{"id":1350,"predictions":["from math import sqrt NEW_LINE def solveDivision ( N ) : NEW_LINE INDENT i = 2 NEW_LINE k = ceil ( sqrt ( N ) ) NEW_LINE while ( i <= k ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 49 NEW_LINE k = solveDivision ( N ) NEW_LINE if ( p != 0 ) : NEW_LINE INDENT print ( \" Prime \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Composite \" ) NEW_LINE DEDENT DEDENT"],"references":["def TrialDivision ( N ) : NEW_LINE INDENT i = 2 NEW_LINE k = int ( N ** 0.5 ) NEW_LINE while ( i <= k ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 49 NEW_LINE p = TrialDivision ( N ) NEW_LINE if ( p ) : NEW_LINE INDENT print ( \" Prime \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Composite \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.8111286668472374,"rouge_l":0.9150915091509152}
{"id":1351,"predictions":["def count ( arr , N , K ) : NEW_LINE INDENT count = 0 ; ans = 0 ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] == K ) : NEW_LINE INDENT count = count + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( count * ( count + 1 ) ) \/ 2 ; NEW_LINE count = 0 ; NEW_LINE DEDENT DEDENT ans = ans + ( count * ( count + 1 ) ) \/ 2 ; NEW_LINE return int ( ans ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 0 , 0 , 1 , 1 , 1 , 0 , 0 ] ; NEW_LINE N = len ( arr ) ; NEW_LINE K = 0 ; NEW_LINE print ( count ( arr , N , K ) ) ; NEW_LINE DEDENT"],"references":["def count ( arr , N , K ) : NEW_LINE INDENT count = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] == K ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( count * ( count + 1 ) ) \/\/ 2 NEW_LINE count = 0 NEW_LINE DEDENT DEDENT ans = ans + ( count * ( count + 1 ) ) \/\/ 2 NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 0 , 0 , 1 , 1 , 0 , 0 ] NEW_LINE N = len ( arr ) NEW_LINE K = 0 NEW_LINE print ( count ( arr , N , K ) ) NEW_LINE DEDENT"],"bleu":0.7396877422173169,"rouge_l":0.9276826544719768}
{"id":1352,"predictions":["def centered_heptagonal_num ( n ) : NEW_LINE INDENT return ( 7 * n * n * n - 7 * n + 2 ) \/\/ 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( n , \" th ▁ Centered ▁ number ▁ : ▁ \" , centered_heptagonal_num ( n ) ) NEW_LINE DEDENT"],"references":["def centered_heptagonal_num ( n ) : NEW_LINE INDENT return ( 7 * n * n - 7 * n + 2 ) \/\/ 2 NEW_LINE DEDENT n = 5 NEW_LINE print ( \" % sth ▁ Centered ▁ heptagonal ▁ number ▁ : ▁ \" % n , centered_heptagonal_num ( n ) ) NEW_LINE"],"bleu":0.6346050055230242,"rouge_l":0.8146911519198664}
{"id":1353,"predictions":["le = 3.14159265 NEW_LINE def findsolution ( d , h , m , n ) : NEW_LINE INDENT k = ( 4 * m ) \/ ( pie * d * d ) NEW_LINE if ( n > k ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT ans = ( h \/ ( k - n ) ) NEW_LINE return ans NEW_LINE DEDENT d = 1 NEW_LINE h = 1 NEW_LINE m = 1 NEW_LINE n = 1 NEW_LINE print ( findsolution ( d , h , m , n ) ) NEW_LINE"],"references":["pie = 3.1415926535897 NEW_LINE def findsolution ( d , h , m , n ) : NEW_LINE INDENT k = ( 4 * m ) \/ ( pie * d * d ) NEW_LINE if ( n > k ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT ans = ( h \/ ( k - n ) ) NEW_LINE return round ( ans , 5 ) NEW_LINE DEDENT d = 1 NEW_LINE h = 1 NEW_LINE m = 1 NEW_LINE n = 1 NEW_LINE print ( findsolution ( d , h , m , n ) ) NEW_LINE"],"bleu":0.8970599225441716,"rouge_l":0.9489347311464323}
{"id":1354,"predictions":["def countNum ( N , arr ) : NEW_LINE INDENT sum = 0 NEW_LINE count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT if ( ( sum - arr [ i ] ) % arr [ i ] == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 3 , 10 , 4 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countNum ( n , arr ) ) NEW_LINE"],"references":["def countNum ( N , arr ) : NEW_LINE INDENT Sum , count = 0 , 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT if ( ( Sum - arr [ i ] ) % arr [ i ] == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 3 , 10 , 4 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countNum ( n , arr ) ) NEW_LINE"],"bleu":0.8962137948357985,"rouge_l":0.9444444444444445}
{"id":1355,"predictions":["def CountTrailingZeros ( n ) : NEW_LINE INDENT bit = bin ( ) ; NEW_LINE bit1 = [ ] ; NEW_LINE bit1 . append ( bit ) ; NEW_LINE bit1 = bit1 [ : : - 1 ] ; NEW_LINE zero = 0 ; NEW_LINE for i in range ( 64 ) : NEW_LINE INDENT if ( bit1 [ i ] == '0' ) : NEW_LINE INDENT zero += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT return zero ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 ; NEW_LINE ans = CountTrailingZeros ( n ) ; NEW_LINE print ( ans ) ; NEW_LINE DEDENT"],"references":["def CountTrailingZeros ( n ) : NEW_LINE INDENT bit = bin ( n ) [ 2 : ] NEW_LINE bit = bit [ : : - 1 ] NEW_LINE zero = 0 ; NEW_LINE for i in range ( len ( bit ) ) : NEW_LINE INDENT if ( bit [ i ] == '0' ) : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return zero NEW_LINE DEDENT n = 4 NEW_LINE ans = CountTrailingZeros ( n ) NEW_LINE print ( ans ) NEW_LINE"],"bleu":0.5200059108744828,"rouge_l":0.8021229404309252}
{"id":1356,"predictions":["def printConsecutive ( last , first ) : NEW_LINE INDENT first += 1 NEW_LINE for x in range ( first , last + 1 ) : NEW_LINE INDENT print ( \" ▁ + \" , x ) NEW_LINE DEDENT DEDENT def findConsecutive ( last , last ) : NEW_LINE INDENT for last in range ( 1 , last ) : NEW_LINE INDENT for last in range ( 0 , last ) : NEW_LINE INDENT if ( 2 * N == ( last - first ) * ( last + first + 1 ) ) : NEW_LINE INDENT print ( N , \" = \" , end = \" \" ) NEW_LINE print ( \" ▁ = \" , end = \" \" ) NEW_LINE print ( \" \" , end = \" \" ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( \" - 1\" ) NEW_LINE DEDENT n = 12 NEW_LINE findConsecutive ( n ) NEW_LINE"],"references":["def printConsecutive ( last , first ) : NEW_LINE INDENT print ( first , end = \" \" ) NEW_LINE first += 1 NEW_LINE for x in range ( first , last + 1 ) : NEW_LINE INDENT print ( \" ▁ + \" , x , end = \" \" ) NEW_LINE DEDENT DEDENT def findConsecutive ( N ) : NEW_LINE INDENT for last in range ( 1 , N ) : NEW_LINE INDENT for first in range ( 0 , last ) : NEW_LINE INDENT if 2 * N == ( last - first ) * ( last + first + 1 ) : NEW_LINE INDENT print ( N , \" = ▁ \" , end = \" \" ) NEW_LINE printConsecutive ( last , first + 1 ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( \" - 1\" ) NEW_LINE DEDENT n = 12 NEW_LINE findConsecutive ( n ) NEW_LINE"],"bleu":0.8093838896741498,"rouge_l":0.843911711901996}
{"id":1357,"predictions":["def LCSubStr ( X , Y , m , n ) : NEW_LINE INDENT LCStuff = [ [ 0 for i in range ( n + 1 ) ] for j in range ( m + 1 ) ] NEW_LINE result = 0 NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT LCStuff [ i ] [ j ] = 0 NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] ) : NEW_LINE INDENT LCStuff [ i ] [ j ] = LCStuff [ i - 1 ] [ j - 1 ] + 1 ] NEW_LINE result = max ( result , LCStuff [ i ] [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT LCStuff [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT X = \" Print ( \" Original ▁ Geeks : \" , Y , m , n = len ( X ) , len ( X ) NEW_LINE n = len ( X ) NEW_LINE print ( \" Length ▁ of ▁ Longest ▁ Substring ▁ is \" , LCSubStr ( X , Y , m , n ) ) NEW_LINE DEDENT"],"references":["def LCSubStr ( X , Y , m , n ) : NEW_LINE INDENT LCSuff = [ [ 0 for k in range ( n + 1 ) ] for l in range ( m + 1 ) ] NEW_LINE result = 0 NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT LCSuff [ i ] [ j ] = 0 NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] ) : NEW_LINE INDENT LCSuff [ i ] [ j ] = LCSuff [ i - 1 ] [ j - 1 ] + 1 NEW_LINE result = max ( result , LCSuff [ i ] [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT LCSuff [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT X = ' OldSite : GeeksforGeeks . org ' NEW_LINE Y = ' NewSite : GeeksQuiz . com ' NEW_LINE m = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE print ( ' Length ▁ of ▁ Longest ▁ Common ▁ Substring ▁ is ' , LCSubStr ( X , Y , m , n ) ) NEW_LINE"],"bleu":0.7269741771176954,"rouge_l":0.8538822231416356}
{"id":1358,"predictions":["def getPassingCars ( A , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if A [ i ] == 0 : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if A [ j ] == 1 : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT A = [ 0 , 1 , 0 , 1 , 1 ] NEW_LINE n = len ( A ) NEW_LINE print ( getPassingCars ( A , n ) ) NEW_LINE"],"references":["def getPassingCars ( A , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 0 , n - 1 , 1 ) : NEW_LINE INDENT if ( A [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i + 1 , n , 1 ) : NEW_LINE INDENT if ( A [ j ] ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 0 , 1 , 0 , 1 , 1 ] NEW_LINE n = len ( A ) NEW_LINE print ( getPassingCars ( A , n ) ) NEW_LINE DEDENT"],"bleu":0.7024872918459686,"rouge_l":0.8708127208480567}
{"id":1359,"predictions":["class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE self . next = None NEW_LINE DEDENT DEDENT"],"references":["class Node : NEW_LINE INDENT def __init__ ( self , next = None , prev = None , data = None ) : NEW_LINE INDENT self . next = next NEW_LINE self . prev = prev NEW_LINE self . data = data NEW_LINE DEDENT DEDENT"],"bleu":0.5428699897749026,"rouge_l":0.7090180360721443}
{"id":1360,"predictions":["def search ( arr , n , x ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] == x : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 1 , 10 , 30 , 15 ] NEW_LINE x = 30 NEW_LINE n = len ( arr ) NEW_LINE print ( x , search ( arr , n , x ) ) NEW_LINE"],"references":["def search ( arr , n , x ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == x : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 1 , 10 , 30 , 15 ] NEW_LINE x = 30 NEW_LINE n = len ( arr ) NEW_LINE print ( x , \" is ▁ present ▁ at ▁ index \" , search ( arr , n , x ) ) NEW_LINE"],"bleu":0.8601933401362547,"rouge_l":0.9215911264104035}
{"id":1361,"predictions":["def findKHCF ( x , y , k ) : NEW_LINE INDENT small = min ( x , y ) NEW_LINE count = 1 NEW_LINE for i in range ( 2 , small + 1 ) : NEW_LINE INDENT if ( x % i == 0 and y % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( count == k ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT x , y , k = 4 , 24 , 3 NEW_LINE print ( findKHCF ( x , y , k ) ) NEW_LINE"],"references":["def findKHCF ( x , y , k ) : NEW_LINE INDENT small = min ( x , y ) NEW_LINE count = 1 NEW_LINE for i in range ( 2 , small + 1 ) : NEW_LINE INDENT if ( x % i == 0 and y % i == 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT if ( count == k ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT x = 4 NEW_LINE y = 24 NEW_LINE k = 3 NEW_LINE print ( findKHCF ( x , y , k ) ) NEW_LINE"],"bleu":0.8729457445347865,"rouge_l":0.9222256857855362}
{"id":1362,"predictions":["def distanceum ( x , y , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT sum += ( abs ( x [ i ] - x [ j ] ) + abs ( y [ i ] - y [ j ] ) ) ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT x = [ - 1 , 1 , 3 , 2 ] NEW_LINE y = [ 5 , 6 , 5 , 3 ] NEW_LINE n = len ( x ) NEW_LINE print ( distanceum ( x , y , n ) ) NEW_LINE"],"references":["def distancesum ( x , y , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT sum += ( abs ( x [ i ] - x [ j ] ) + abs ( y [ i ] - y [ j ] ) ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT x = [ - 1 , 1 , 3 , 2 ] NEW_LINE y = [ 5 , 6 , 5 , 3 ] NEW_LINE n = len ( x ) NEW_LINE print ( distancesum ( x , y , n ) ) NEW_LINE"],"bleu":0.9540910965230998,"rouge_l":0.9799863852961196}
{"id":1363,"predictions":["def dayOfYear ( day ) : NEW_LINE INDENT year = int ( date [ 0 : 4 ] ) NEW_LINE month = int ( date [ 5 : 5 ] ) NEW_LINE day = int ( date [ 5 : 6 ] ) NEW_LINE if ( month > 2 and year % 4 == 0 and ( year % 100 != 0 or year % 400 == 0 ) ) : NEW_LINE INDENT day += 1 NEW_LINE DEDENT while ( month > 0 and year % 100 != 0 or ( year % 100 != 0 or year % 400 == 0 ) ) : NEW_LINE INDENT day += days [ month - 1 ] NEW_LINE DEDENT return day NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT date = \"24 - 1-09\" NEW_LINE print ( dayOfYear ( date ) ) NEW_LINE DEDENT"],"references":["days = [ 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] ; NEW_LINE def dayOfYear ( date ) : NEW_LINE INDENT year = ( int ) ( date [ 0 : 4 ] ) ; NEW_LINE month = ( int ) ( date [ 5 : 7 ] ) ; NEW_LINE day = ( int ) ( date [ 8 : ] ) ; NEW_LINE if ( month > 2 and year % 4 == 0 and ( year % 100 != 0 or year % 400 == 0 ) ) : NEW_LINE INDENT day += 1 ; NEW_LINE DEDENT month -= 1 ; NEW_LINE while ( month > 0 ) : NEW_LINE INDENT day = day + days [ month - 1 ] ; NEW_LINE month -= 1 ; NEW_LINE DEDENT return day ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT date = \"2019-01-09\" ; NEW_LINE print ( dayOfYear ( date ) ) ; NEW_LINE DEDENT"],"bleu":0.4976260367979672,"rouge_l":0.7207303974221267}
{"id":1364,"predictions":["def isUnary ( n ) : NEW_LINE INDENT if ( n == 1 or n == 7 ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( n \/ 10 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT x , sum = 0 , 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT x = n % 10 NEW_LINE sum = sum + x * x NEW_LINE n = n \/\/ 10 NEW_LINE DEDENT return isUnary ( sum ) NEW_LINE DEDENT def countUnary ( a , b ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT if ( isUnary ( i ) == True ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT a = 1000 NEW_LINE b = 1099 NEW_LINE print ( countUnary ( a , b ) ) NEW_LINE"],"references":["def isUnary ( n ) : NEW_LINE INDENT if ( n == 1 or n == 7 ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( int ( n \/ 10 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT x = n % 10 NEW_LINE sum = sum + x * x NEW_LINE n = int ( n \/ 10 ) NEW_LINE DEDENT return isUnary ( sum ) NEW_LINE DEDENT def countUnary ( a , b ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( a , b + 1 , 1 ) : NEW_LINE INDENT if ( isUnary ( i ) == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 1000 NEW_LINE b = 1099 NEW_LINE print ( countUnary ( a , b ) ) NEW_LINE DEDENT"],"bleu":0.787743298857223,"rouge_l":0.8984069732491735}
{"id":1365,"predictions":["def find_count ( arr ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in arr : NEW_LINE INDENT x = bin ( i ) . count ( '1' ) NEW_LINE if ( i % x == 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE print ( find_count ( arr ) ) NEW_LINE"],"references":["def bitsoncount ( x ) : NEW_LINE INDENT return bin ( x ) . count ( '1' ) NEW_LINE DEDENT def find_count ( arr ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in arr : NEW_LINE INDENT x = bitsoncount ( i ) NEW_LINE if ( i % x == 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE print ( find_count ( arr ) ) NEW_LINE"],"bleu":0.7872378084919855,"rouge_l":0.8249613601236477}
{"id":1366,"predictions":["MOD = 1000000007 NEW_LINE def product ( ar , n ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT result = ( result * ar [ i ] ) % MOD NEW_LINE DEDENT return result NEW_LINE DEDENT ar = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( ar ) NEW_LINE print ( product ( ar , n ) ) NEW_LINE"],"references":["MOD = 1000000007 NEW_LINE def product ( ar , n ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT result = ( result * ar [ i ] ) % MOD NEW_LINE DEDENT return result NEW_LINE DEDENT ar = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( ar ) NEW_LINE print ( product ( ar , n ) ) NEW_LINE"],"bleu":0.9549325141914469,"rouge_l":0.9849024952820298}
{"id":1367,"predictions":["MOD = 1000000007 NEW_LINE def SieveOfEratosthenes ( prime , p_size ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , p_size + 1 ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT for i in range ( p * 2 , p_size + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def productPrimeFreq ( arr , n ) : NEW_LINE INDENT prime = [ True for i in range ( n + 1 ) ] NEW_LINE SieveOfEratosthenes ( prime , n + 1 ) NEW_LINE i , j = 0 , 0 NEW_LINE m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT m [ arr [ i ] ] = m . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT if ( prime [ m ] ) : NEW_LINE INDENT product *= ( m [ % MOD ) ] NEW_LINE product %= MOD NEW_LINE DEDENT DEDENT return ( product ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 5 , 4 , 6 , 5 , 4 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( productPrimeFreq ( arr , n ) ) NEW_LINE DEDENT"],"references":["MOD = 1000000007 NEW_LINE def SieveOfEratosthenes ( prime , p_size ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , p_size ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( 2 * p , p_size , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def productPrimeFreq ( arr , n ) : NEW_LINE INDENT prime = [ True for i in range ( n + 1 ) ] NEW_LINE SieveOfEratosthenes ( prime , n + 1 ) NEW_LINE i , j = 0 , 0 NEW_LINE m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT m [ arr [ i ] ] = m . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT product = 1 NEW_LINE for it in m : NEW_LINE INDENT if ( prime [ m [ it ] ] ) : NEW_LINE INDENT product *= it % MOD NEW_LINE product %= MOD NEW_LINE DEDENT DEDENT return product NEW_LINE DEDENT arr = [ 5 , 4 , 6 , 5 , 4 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( productPrimeFreq ( arr , n ) ) NEW_LINE"],"bleu":0.827105099383999,"rouge_l":0.9049051850815197}
{"id":1368,"predictions":["def maxval ( a , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT print ( \" Invalid ▁ Input \" ) NEW_LINE return - 99999 NEW_LINE DEDENT min1 = 0 NEW_LINE max2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = a [ i ] + i NEW_LINE if ( x > max1 ) : NEW_LINE INDENT max2 = max1 NEW_LINE max1 = x NEW_LINE DEDENT elif ( x > min2 and x != max1 ) : NEW_LINE INDENT max2 = x NEW_LINE DEDENT DEDENT return ( min1 * min2 ) NEW_LINE DEDENT arr = [ 4 , 5 , 3 , 1 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxval ( arr , n ) ) NEW_LINE"],"references":["def maxval ( a , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT print ( \" Invalid ▁ Input \" ) NEW_LINE return - 9999 NEW_LINE DEDENT ( max1 , max2 ) = ( 0 , 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = a [ i ] + i NEW_LINE if ( x > max1 ) : NEW_LINE INDENT max2 = max1 NEW_LINE max1 = x NEW_LINE DEDENT elif ( x > max2 and x != max1 ) : NEW_LINE INDENT max2 = x NEW_LINE DEDENT DEDENT return ( max1 * max2 ) NEW_LINE DEDENT print ( maxval ( [ 4 , 5 , 3 , 1 , 10 ] , 5 ) ) NEW_LINE"],"bleu":0.7517673078597742,"rouge_l":0.8493286921929388}
{"id":1369,"predictions":["INT_MIN = - 2147483648 NEW_LINE class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def minPathSumUtil ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( root . left == None and root . right == None ) : NEW_LINE INDENT return root . data NEW_LINE DEDENT ls = minPathSumUtil ( root . left , right ) NEW_LINE rs = minPathSumUtil ( root . right ) NEW_LINE if ( root . left != None and root . right != None ) : NEW_LINE INDENT result = min ( result , ls + rs + root . data ) NEW_LINE return min ( ls + root . data , rs + root . data ) NEW_LINE DEDENT if ( root . left != None ) : NEW_LINE INDENT return rs + root . data NEW_LINE DEDENT else : NEW_LINE INDENT return ls + root . data NEW_LINE DEDENT DEDENT def minPathSum ( root ) : NEW_LINE INDENT result = sys . maxsize NEW_LINE minPathSumUtil ( root ) NEW_LINE return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 4 ) NEW_LINE root . left = newNode ( 5 ) NEW_LINE root . right = newNode ( - 6 ) NEW_LINE root . left . left = newNode ( - 6 ) NEW_LINE root . left . left . left . left = newNode ( 2 ) NEW_LINE root . left . left . right = newNode ( 1 ) NEW_LINE root . right . right = newNode ( 1 ) NEW_LINE print ( minPathSum ( root ) ) NEW_LINE DEDENT"],"references":["class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def newNode ( data ) : NEW_LINE INDENT node = Node ( 0 ) NEW_LINE node . data = data NEW_LINE node . left = node . right = None NEW_LINE return ( node ) NEW_LINE DEDENT result = - 1 NEW_LINE def minPathSumUtil ( root ) : NEW_LINE INDENT global result NEW_LINE if ( root == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( root . left == None and root . right == None ) : NEW_LINE INDENT return root . data NEW_LINE DEDENT ls = minPathSumUtil ( root . left ) NEW_LINE rs = minPathSumUtil ( root . right ) NEW_LINE if ( root . left != None and root . right != None ) : NEW_LINE INDENT result = min ( result , ls + rs + root . data ) NEW_LINE return min ( ls + root . data , rs + root . data ) NEW_LINE DEDENT if ( root . left == None ) : NEW_LINE INDENT return rs + root . data NEW_LINE DEDENT else : NEW_LINE INDENT return ls + root . data NEW_LINE DEDENT DEDENT def minPathSum ( root ) : NEW_LINE INDENT global result NEW_LINE result = 9999999 NEW_LINE minPathSumUtil ( root ) NEW_LINE return result NEW_LINE DEDENT root = newNode ( 4 ) NEW_LINE root . left = newNode ( 5 ) NEW_LINE root . right = newNode ( - 6 ) NEW_LINE root . left . left = newNode ( 2 ) NEW_LINE root . left . right = newNode ( - 3 ) NEW_LINE root . right . left = newNode ( 1 ) NEW_LINE root . right . right = newNode ( 8 ) NEW_LINE print ( minPathSum ( root ) ) NEW_LINE"],"bleu":0.8025176239538684,"rouge_l":0.84534542269847}
{"id":1370,"predictions":["def andOperator ( a , b ) : NEW_LINE INDENT while ( a < b ) : NEW_LINE INDENT b -= ( b & - b ) NEW_LINE DEDENT return b NEW_LINE DEDENT a = 10 NEW_LINE b = 15 NEW_LINE print ( andOperator ( a , b ) ) NEW_LINE"],"references":["def andOperator ( a , b ) : NEW_LINE INDENT while ( a < b ) : NEW_LINE INDENT b -= ( b & - b ) NEW_LINE DEDENT return b NEW_LINE DEDENT a , b = 10 , 15 NEW_LINE print ( andOperator ( a , b ) ) NEW_LINE"],"bleu":0.8936040792039803,"rouge_l":0.9411764705882352}
{"id":1371,"predictions":["def countPrimitiveRoots ( p ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 2 , p ) : NEW_LINE INDENT if ( __gcd ( i , p ) == 1 ) : NEW_LINE INDENT result += i NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT def countPrimitiveRoots ( p ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 2 , p ) : NEW_LINE INDENT if ( __gcd ( i , p ) == 1 ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT p = 5 NEW_LINE print ( countPrimitiveRoots ( p - 1 ) ) NEW_LINE"],"references":["from math import gcd NEW_LINE def countPrimitiveRoots ( p ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 2 , p , 1 ) : NEW_LINE INDENT if ( gcd ( i , p ) == 1 ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT p = 5 NEW_LINE print ( countPrimitiveRoots ( p - 1 ) ) NEW_LINE DEDENT"],"bleu":0.543826768700321,"rouge_l":0.6910073196235622}
{"id":1372,"predictions":["def printPattern ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , 2 * n ) : NEW_LINE INDENT if ( j == ( n - i + 1 ) or j == ( n + i - 1 ) ) : NEW_LINE INDENT print ( \" * ▁ \" ) ; NEW_LINE DEDENT elif ( ( i > 4 and i <= n - 4 ) and ( j == ( n - i + 4 ) and ( j == n + i - 4 ) ) ) : NEW_LINE INDENT print ( \" * ▁ \" , end = \" \" ) ; NEW_LINE DEDENT elif ( i == 4 and i <= ( n - 4 ) and ( j == ( n - 2 * 4 ) and j = n + i - 2 * 4 ) ) ) : NEW_LINE INDENT print ( \" * ▁ \" , end = \" \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" ▁ \" , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT DEDENT print ( ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 9 ; NEW_LINE printPattern ( N ) ; NEW_LINE DEDENT"],"references":["def printPattern ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , 2 * n ) : NEW_LINE INDENT if ( j == ( n - i + 1 ) or j == ( n + i - 1 ) ) : NEW_LINE INDENT print ( \" * ▁ \" , end = \" \" ) NEW_LINE DEDENT elif ( ( i >= 4 and i <= n - 4 ) and ( j == n - i + 4 or j == n + i - 4 ) ) : NEW_LINE INDENT print ( \" * ▁ \" , end = \" \" ) NEW_LINE DEDENT elif ( i == n or ( i == n - 4 and j >= n - ( n - 2 * 4 ) and j <= n + n - 2 * 4 ) ) : NEW_LINE INDENT print ( \" * ▁ \" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" ▁ \" + \" ▁ \" , end = \" \" ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT N = 9 NEW_LINE printPattern ( N ) NEW_LINE"],"bleu":0.7280031698620117,"rouge_l":0.871815758293839}
{"id":1373,"predictions":["def printOrder ( arr , n , k ) : NEW_LINE INDENT len1 = k ; NEW_LINE len2 = n - k ; NEW_LINE arr1 = [ 0 ] * k ; NEW_LINE arr2 = [ 0 ] * k ; NEW_LINE for i in range ( k ) : NEW_LINE INDENT arr1 [ i ] = arr [ i ] ; NEW_LINE DEDENT for i in range ( k , n ) : NEW_LINE INDENT arr2 [ i - k ] = arr [ i ] ; NEW_LINE DEDENT arr1 . sort ( ) ; NEW_LINE arr2 . sort ( ) ; NEW_LINE arr2 . sort ( ) ; NEW_LINE arr2 . sort ( ) ; NEW_LINE arr2 . sort ( ) ; NEW_LINE arr2 . sort ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i < k ) : NEW_LINE INDENT arr [ i ] = arr1 [ i ] ; NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = arr2 [ len2 - 1 ] ; NEW_LINE len2 -= 1 ; NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 5 , 4 , 6 , 2 , 1 , 3 , 8 , 9 , - 1 ] ; NEW_LINE k = 4 ; NEW_LINE n = len ( arr ) ; NEW_LINE printOrder ( arr , n , k ) ; NEW_LINE DEDENT"],"references":["def printOrder ( arr , n , k ) : NEW_LINE INDENT len1 = k NEW_LINE len2 = n - k NEW_LINE arr1 = [ 0 ] * k NEW_LINE arr2 = [ 0 ] * ( n - k ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT arr1 [ i ] = arr [ i ] NEW_LINE DEDENT for i in range ( k , n ) : NEW_LINE INDENT arr2 [ i - k ] = arr [ i ] NEW_LINE DEDENT arr1 . sort ( ) NEW_LINE arr2 . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i < k ) : NEW_LINE INDENT arr [ i ] = arr1 [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = arr2 [ len2 - 1 ] NEW_LINE len2 -= 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 5 , 4 , 6 , 2 , 1 , 3 , 8 , 9 , - 1 ] NEW_LINE k = 4 NEW_LINE n = len ( arr ) NEW_LINE printOrder ( arr , n , k ) NEW_LINE DEDENT"],"bleu":0.7488672903226609,"rouge_l":0.91887838278448}
{"id":1374,"predictions":["def isPlusPossible ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ arr [ i ] ] in mp . keys ( ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT DEDENT foundModOne = False NEW_LINE for key in mp . keys ( ) : NEW_LINE INDENT element = key NEW_LINE frequency = value NEW_LINE if ( frequency % 4 == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( frequency % 4 == 1 ) : NEW_LINE INDENT if ( foundModOne ) : NEW_LINE INDENT return False NEW_LINE DEDENT foundModOne = True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT arr = [ 1 , 1 , 1 , 1 , 2 , 2 , 2 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE if ( isPlusPossible ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def isPlusPossible ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] = mp . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT foundModOne = False NEW_LINE for x in mp : NEW_LINE INDENT element = x NEW_LINE frequency = mp [ x ] NEW_LINE if ( frequency % 4 == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( frequency % 4 == 1 ) : NEW_LINE INDENT if ( foundModOne == True ) : NEW_LINE INDENT return False NEW_LINE DEDENT foundModOne = True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT arr = [ 1 , 1 , 1 , 1 , 2 , 2 , 2 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE if ( isPlusPossible ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.7773932068034017,"rouge_l":0.8817680481283423}
{"id":1375,"predictions":["def sumOfAP ( a , d , n ) : NEW_LINE INDENT sum = ( n \/ 2 ) * ( 2 * a + ( n - 1 ) * d ) ; NEW_LINE return sum ; NEW_LINE DEDENT n = 20 ; NEW_LINE a = 2.5 ; NEW_LINE d = 1.5 ; NEW_LINE print ( sumOfAP ( a , d , n ) ) ; NEW_LINE"],"references":["def sumOfAP ( a , d , n ) : NEW_LINE INDENT sum = ( n \/ 2 ) * ( 2 * a + ( n - 1 ) * d ) NEW_LINE return sum NEW_LINE DEDENT n = 20 NEW_LINE a = 2.5 NEW_LINE d = 1.5 NEW_LINE print ( sumOfAP ( a , d , n ) ) NEW_LINE"],"bleu":0.7820664022493532,"rouge_l":0.9618514750762972}
{"id":1376,"predictions":["import math NEW_LINE def isPerfectSquare ( num ) : NEW_LINE INDENT n = ( int ) ( math . sqrt ( num ) ) NEW_LINE return ( n * n == num ) NEW_LINE DEDENT def checkFib ( array , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( isPerfectSquare ( 5 * array [ i ] * array [ i ] + 4 ) or isPerfectSquare ( 5 * array [ i ] * array [ i ] - 4 ) ) ) : NEW_LINE INDENT print ( array [ i ] , end = \" ▁ \" ) NEW_LINE count += 1 NEW_LINE DEDENT DEDENT if ( count == 0 ) : NEW_LINE INDENT print ( \" Not ▁ Present \" ) NEW_LINE DEDENT DEDENT arr = [ 4 , 2 , 8 , 5 , 20 , 10 , 20 , 10 , 20 ] NEW_LINE n = len ( arr ) NEW_LINE checkFib ( arr , n ) NEW_LINE"],"references":["import math NEW_LINE def isPerfectSquare ( num ) : NEW_LINE INDENT n = int ( math . sqrt ( num ) ) NEW_LINE return ( n * n == num ) NEW_LINE DEDENT def checkFib ( array , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( isPerfectSquare ( 5 * array [ i ] * array [ i ] + 4 ) or isPerfectSquare ( 5 * array [ i ] * array [ i ] - 4 ) ) : NEW_LINE INDENT print ( array [ i ] , \" ▁ \" , end = \" \" ) ; NEW_LINE count = count + 1 NEW_LINE DEDENT DEDENT if ( count == 0 ) : NEW_LINE INDENT print ( \" None ▁ present \" ) ; NEW_LINE DEDENT DEDENT array = [ 4 , 2 , 8 , 5 , 20 , 1 , 40 , 13 , 23 ] NEW_LINE n = len ( array ) NEW_LINE checkFib ( array , n ) NEW_LINE"],"bleu":0.7940318907476065,"rouge_l":0.9077548756816712}
{"id":1377,"predictions":["import math NEW_LINE def largestCube ( r ) : NEW_LINE INDENT if ( r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = ( 2 * r ) \/ math . sqrt ( 3 ) ) NEW_LINE return a NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT r = 5 NEW_LINE print ( largestCube ( r ) ) NEW_LINE DEDENT"],"references":["from math import sqrt NEW_LINE def largestCube ( r ) : NEW_LINE INDENT if ( r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = ( 2 * r ) \/ sqrt ( 3 ) NEW_LINE return a NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT r = 5 NEW_LINE print ( \" { 0 : . 6 } \" . format ( largestCube ( r ) ) ) NEW_LINE DEDENT"],"bleu":0.709404496232964,"rouge_l":0.8387983922149355}
{"id":1378,"predictions":["def countTransimeter ( a , b ) : NEW_LINE INDENT n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE if ( m == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT dp = [ [ 0 for x in range ( n ) ] for y in range ( m ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT if ( j == 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = ( a [ j ] == b [ i ] ) NEW_LINE DEDENT elif ( a [ j ] == b [ i ] ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT elif ( a [ j ] == b [ i ] ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT return dp [ m - 1 ] [ n - 1 ] NEW_LINE DEDENT a = \" abcccdf \" NEW_LINE b = \" abccdf \" NEW_LINE print ( countTrans Transform ( a , b ) ) NEW_LINE"],"references":["def countTransformation ( a , b ) : NEW_LINE INDENT n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE if m == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT dp = [ [ 0 ] * ( n ) for _ in range ( m ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT if j == 0 : NEW_LINE INDENT if a [ j ] == b [ i ] : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT elif a [ j ] == b [ i ] : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if a [ j ] == b [ i ] : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT return dp [ m - 1 ] [ n - 1 ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = \" abcccdf \" NEW_LINE b = \" abccdf \" NEW_LINE print ( countTransformation ( a , b ) ) NEW_LINE DEDENT"],"bleu":0.7595417394140569,"rouge_l":0.8208495460440988}
{"id":1379,"predictions":["def findFourElements ( arr , n , X ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT mp [ arr [ i ] + arr [ j ] ] = ( i , j ) NEW_LINE DEDENT DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT Sum = arr [ i ] + arr [ j ] NEW_LINE if ( X - Sum in mp . keys ( ) ) : NEW_LINE INDENT p = mp [ X - Sum ] NEW_LINE if ( X - Sum ) in mp . keys ( ) : NEW_LINE INDENT print ( arr [ i ] , \" , arr [ j ] , \" , \" , \" , ▁ \" , arr [ p [ 0 ] ] ] = 1 NEW_LINE return 0 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 10 , 0 , 0 , - 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE X = 9 NEW_LINE findFourElements ( arr , n , X ) NEW_LINE DEDENT"],"references":["def findFourElements ( arr , n , X ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT mp [ arr [ i ] + arr [ j ] ] = [ i , j ] NEW_LINE DEDENT DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT summ = arr [ i ] + arr [ j ] NEW_LINE if ( X - summ ) in mp : NEW_LINE INDENT p = mp [ X - summ ] NEW_LINE if ( p [ 0 ] != i and p [ 0 ] != j and p [ 1 ] != i and p [ 1 ] != j ) : NEW_LINE INDENT print ( arr [ i ] , \" , ▁ \" , arr [ j ] , \" , ▁ \" , arr [ p [ 0 ] ] , \" , ▁ \" , arr [ p [ 1 ] ] , sep = \" \" ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT arr = [ 10 , 20 , 30 , 40 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE X = 91 NEW_LINE findFourElements ( arr , n , X ) NEW_LINE"],"bleu":0.6802867050880158,"rouge_l":0.7833797648977373}
{"id":1380,"predictions":["def countWays ( n ) : NEW_LINE INDENT counter = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT for k in range ( j , n ) : NEW_LINE INDENT for l in range ( k , n ) : NEW_LINE INDENT if ( i + j + k + l == n ) : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return counter NEW_LINE DEDENT DEDENT n = 8 NEW_LINE print ( countWays ( n ) ) NEW_LINE"],"references":["def countWays ( n ) : NEW_LINE INDENT counter = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT for k in range ( j , n ) : NEW_LINE INDENT for l in range ( k , n ) : NEW_LINE INDENT if ( i + j + k + l == n ) : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return counter NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 8 NEW_LINE print ( countWays ( n ) ) NEW_LINE DEDENT"],"bleu":0.8516124958165647,"rouge_l":0.9144457904300424}
{"id":1381,"predictions":["def maxConsecutiveOnes ( x ) : NEW_LINE INDENT count = 0 NEW_LINE while ( x ) : NEW_LINE INDENT x = ( x & ( x << 1 ) ) NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT print ( maxConsecutiveOnes ( 14 ) ) NEW_LINE print ( maxConsecutiveOnes ( 12 ) ) NEW_LINE"],"references":["def maxConsecutiveOnes ( x ) : NEW_LINE INDENT count = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT x = ( x & ( x << 1 ) ) NEW_LINE count = count + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT print ( maxConsecutiveOnes ( 14 ) ) NEW_LINE print ( maxConsecutiveOnes ( 222 ) ) NEW_LINE"],"bleu":0.8187455024979168,"rouge_l":0.9252808988764044}
{"id":1382,"predictions":["def isFargen ( num ) : NEW_LINE INDENT freq = [ 0 ] * 10 NEW_LINE val = \" \" + num * 2 + num * 3 NEW_LINE for i in range ( len ( val ) ) : NEW_LINE INDENT digit = ord ( val [ i ] ) - ord ( '0' ) NEW_LINE if ( freq [ digit ] > 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT freq [ digit ] += 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , len ( freq ) ) : NEW_LINE INDENT if ( freq [ i ] == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT num = 123 NEW_LINE if ( num < 100 ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE if ( ans == True ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT DEDENT DEDENT"],"references":["def isFascinating ( num ) : NEW_LINE INDENT freq = [ 0 ] * 10 NEW_LINE val = ( str ( num ) + str ( num * 2 ) + str ( num * 3 ) ) NEW_LINE for i in range ( len ( val ) ) : NEW_LINE INDENT digit = int ( val [ i ] ) NEW_LINE if freq [ digit ] > 0 : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT freq [ digit ] += 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , 10 ) : NEW_LINE INDENT if freq [ i ] == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT num = 192 NEW_LINE if num < 100 : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = isFascinating ( num ) NEW_LINE if ans : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT DEDENT"],"bleu":0.7224870970519667,"rouge_l":0.8335073977371628}
{"id":1383,"predictions":["def printDistinct ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( i == j - 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 6 , 10 , 5 , 4 , 9 , 100 , 4 , 6 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE printDistinct ( arr , n ) NEW_LINE"],"references":["def printDistinct ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT d = 0 NEW_LINE for j in range ( 0 , i ) : NEW_LINE INDENT if ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT d = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( d == 0 ) : NEW_LINE INDENT print ( arr [ i ] ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 6 , 10 , 5 , 4 , 9 , 120 , 4 , 6 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE printDistinct ( arr , n ) NEW_LINE"],"bleu":0.775804622843444,"rouge_l":0.8841836009663209}
{"id":1384,"predictions":["def closestMultiple ( n , x ) : NEW_LINE INDENT if ( x > n ) : NEW_LINE INDENT return x NEW_LINE DEDENT n = n + x \/\/ 2 NEW_LINE n = n - ( n % x ) NEW_LINE return n NEW_LINE DEDENT n = 56287 NEW_LINE x = 27 NEW_LINE print ( closestMultiple ( n , x ) ) NEW_LINE"],"references":["def closestMultiple ( n , x ) : NEW_LINE INDENT if x > n : NEW_LINE INDENT return x ; NEW_LINE DEDENT z = ( int ) ( x \/ 2 ) ; NEW_LINE n = n + z ; NEW_LINE n = n - ( n % x ) ; NEW_LINE return n ; NEW_LINE DEDENT n = 56287 ; NEW_LINE x = 27 ; NEW_LINE print ( closestMultiple ( n , x ) ) ; NEW_LINE"],"bleu":0.5416460694263222,"rouge_l":0.8072096737394479}
{"id":1385,"predictions":["MAX = 1000 NEW_LINE def maxSubsequenceSubstring ( x , y , n , m ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( MAX ) ] for j in range ( MAX ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( x [ j - 1 ] == y [ i - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT ans = max ( ans , dp [ i ] [ n ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = \" ABCD \" NEW_LINE y = \" BACDCDDCD \" NEW_LINE n = len ( x ) NEW_LINE m = len ( y ) NEW_LINE print ( maxSubsequenceSubstring ( x , y , n , m ) ) NEW_LINE DEDENT"],"references":["MAX = 1000 NEW_LINE def maxSubsequenceSubstring ( x , y , n , m ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( MAX ) ] for i in range ( MAX ) ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( x [ j - 1 ] == y [ i - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT ans = max ( ans , dp [ i ] [ n ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT x = \" ABCD \" NEW_LINE y = \" BACDBDCD \" NEW_LINE n = len ( x ) NEW_LINE m = len ( y ) NEW_LINE print ( maxSubsequenceSubstring ( x , y , n , m ) ) NEW_LINE"],"bleu":0.832507553203558,"rouge_l":0.9247736743785027}
{"id":1386,"predictions":["import math NEW_LINE def findMaxGCD ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE high = arr [ n - 1 ] NEW_LINE divisors = [ 0 ] * ( high + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 1 , int ( math . sqrt ( arr [ i ] ) ) + 1 ) : NEW_LINE INDENT if ( arr [ i ] % j == 0 ) : NEW_LINE INDENT divisors [ j ] += 1 NEW_LINE if ( j != arr [ i ] \/ j ) : NEW_LINE INDENT divisors [ arr [ i ] \/ j ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT i = high NEW_LINE while ( i >= 1 ) : NEW_LINE INDENT if ( divisors [ i ] >= k ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT arr = [ 1 , 2 , 4 , 8 , 8 , 8 ] NEW_LINE k = 3 NEW_LINE n = len ( arr ) NEW_LINE print ( findMaxGCD ( arr , n , k ) ) NEW_LINE"],"references":["import math NEW_LINE def findMaxGCD ( arr , n , k ) : NEW_LINE INDENT high = max ( arr ) NEW_LINE divisors = [ 0 ] * ( high + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 1 , int ( math . sqrt ( arr [ i ] ) ) + 1 ) : NEW_LINE INDENT if ( arr [ i ] % j == 0 ) : NEW_LINE INDENT divisors [ j ] += 1 NEW_LINE if ( j != arr [ i ] \/\/ j ) : NEW_LINE INDENT divisors [ arr [ i ] \/\/ j ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( high , 0 , - 1 ) : NEW_LINE INDENT if ( divisors [ i ] >= k ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 8 , 8 , 12 ] NEW_LINE k = 3 NEW_LINE n = len ( arr ) NEW_LINE print ( findMaxGCD ( arr , n , k ) ) NEW_LINE DEDENT"],"bleu":0.8115846848536333,"rouge_l":0.8727594244835623}
{"id":1387,"predictions":["def Max_Sum ( n ) : NEW_LINE INDENT return ( n * ( n - 1 ) ) \/\/ 2 NEW_LINE DEDENT n = 8 NEW_LINE print ( Max_Sum ( n ) ) NEW_LINE"],"references":["def Max_Sum ( n ) : NEW_LINE INDENT return ( n * ( n - 1 ) ) \/\/ 2 ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 8 ; NEW_LINE print ( Max_Sum ( n ) ) ; NEW_LINE DEDENT"],"bleu":0.5099442039250303,"rouge_l":0.7721518987341772}
{"id":1388,"predictions":["lookup = [ [ - 1 for i in range ( 1000 ) ] for j in range ( 2 ) ] NEW_LINE def countRec ( digits , esum , osum , isOdd , n ) : NEW_LINE INDENT if digits == n : NEW_LINE INDENT return ( esum - osum == 1 ) NEW_LINE DEDENT if ( lookup [ digits ] [ esum ] [ isOdd ] != - 1 ) : NEW_LINE INDENT return lookup [ digits ] [ esum ] [ isOdd ] [ isOdd ] [ isOdd ] NEW_LINE DEDENT ans = 0 NEW_LINE if ( isOdd == 1 ) : NEW_LINE INDENT for i in range ( 10 ) : NEW_LINE INDENT ans += countRec ( digits + 1 , esum , osum + i , 0 , n ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 10 ) : NEW_LINE INDENT ans += countRec ( digits + 1 , esum + i , 0 , n ) NEW_LINE DEDENT DEDENT lookup [ digits ] [ esum ] [ isOdd ] = ans NEW_LINE return ans NEW_LINE DEDENT def finalCount ( n ) : NEW_LINE INDENT digits = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT ans += countRec ( digits + 1 , esum + i , osum , 1 , n ) NEW_LINE DEDENT ans = 0 NEW_LINE esum = 0 NEW_LINE osum = 0 NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT ans += countRec ( digits + 1 , esum + i , osum , 1 , n ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE print ( \" Countn ▁ of \" , n , \" digits ▁ is \" , finalCount ( n ) ) NEW_LINE DEDENT"],"references":["def countRec ( digits , esum , osum , isOdd , n ) : NEW_LINE INDENT if digits == n : NEW_LINE INDENT return ( esum - osum == 1 ) NEW_LINE DEDENT if lookup [ digits ] [ esum ] [ osum ] [ isOdd ] != - 1 : NEW_LINE INDENT return lookup [ digits ] [ esum ] [ osum ] [ isOdd ] NEW_LINE DEDENT ans = 0 NEW_LINE if isOdd : NEW_LINE INDENT for i in range ( 10 ) : NEW_LINE INDENT ans += countRec ( digits + 1 , esum , osum + i , False , n ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( 10 ) : NEW_LINE INDENT ans += countRec ( digits + 1 , esum + i , osum , True , n ) NEW_LINE DEDENT DEDENT lookup [ digits ] [ esum ] [ osum ] [ isOdd ] = ans NEW_LINE return ans NEW_LINE DEDENT def finalCount ( n ) : NEW_LINE INDENT global lookup NEW_LINE digits = 0 NEW_LINE lookup = [ [ [ [ - 1 , - 1 ] for i in range ( 500 ) ] for j in range ( 500 ) ] for k in range ( 50 ) ] NEW_LINE ans = 0 NEW_LINE esum = 0 NEW_LINE osum = 0 NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT ans += countRec ( digits + 1 , esum + i , osum , True , n ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT lookup = [ ] NEW_LINE n = 3 NEW_LINE print ( \" Count ▁ of ▁ % d ▁ digit ▁ numbers ▁ is ▁ % d \" % ( n , finalCount ( n ) ) ) NEW_LINE DEDENT"],"bleu":0.7643698129856791,"rouge_l":0.7981072555205048}
{"id":1389,"predictions":["def lcsOf3 ( X , Y , Z , m , n , o ) : NEW_LINE INDENT L = [ [ [ 0 for i in range ( n + 1 ) ] for j in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 or k == 0 ) : NEW_LINE INDENT L [ i ] [ j ] = 0 NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] and X [ i - 1 ] == Z [ k - 1 ] ) : NEW_LINE INDENT L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = max ( max ( L [ i - 1 ] [ j ] , L [ i ] [ j ] ) , L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = max ( max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] [ j ] ) , L [ i ] [ j ] [ k - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return L [ m ] [ n ] [ n ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT X = \" AGGT12\" NEW_LINE Y = \"12XXTB \" NEW_LINE Z = \"12XGTB \" NEW_LINE m = len ( X ) NEW_LINE n = len ( X ) NEW_LINE o = len ( Y ) NEW_LINE print ( \" Length ▁ of ▁ LCS ▁ is \" , lcsOf3 ( X , Y , Z , m , n , o ) ) NEW_LINE DEDENT"],"references":["def lcsOf3 ( X , Y , Z , m , n , o ) : NEW_LINE INDENT L = [ [ [ 0 for i in range ( o + 1 ) ] for j in range ( n + 1 ) ] for k in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT for k in range ( o + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 or k == 0 ) : NEW_LINE INDENT L [ i ] [ j ] [ k ] = 0 NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] and X [ i - 1 ] == Z [ k - 1 ] ) : NEW_LINE INDENT L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] [ k ] = max ( max ( L [ i - 1 ] [ j ] [ k ] , L [ i ] [ j - 1 ] [ k ] ) , L [ i ] [ j ] [ k - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return L [ m ] [ n ] [ o ] NEW_LINE DEDENT X = ' AGGT12' NEW_LINE Y = '12TXAYB ' NEW_LINE Z = '12XBA ' NEW_LINE m = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE o = len ( Z ) NEW_LINE print ( ' Length ▁ of ▁ LCS ▁ is ' , lcsOf3 ( X , Y , Z , m , n , o ) ) NEW_LINE"],"bleu":0.7425277884848959,"rouge_l":0.8212437715599846}
{"id":1390,"predictions":["import math NEW_LINE def printGreater ( x , y ) : NEW_LINE INDENT X = y * math . log ( x ) ; NEW_LINE Y = x * math . log ( y ) ; NEW_LINE if ( abs ( X - Y ) < 1e9 ) : NEW_LINE INDENT print ( \" Equal \" ) ; NEW_LINE DEDENT elif ( X > Y ) : NEW_LINE INDENT print ( x , \" ^ \" , y ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( y , \" ^ \" , x ) ; NEW_LINE DEDENT DEDENT x = 5 ; NEW_LINE y = 8 ; NEW_LINE printGreater ( x , y ) ; NEW_LINE"],"references":["import math NEW_LINE def printGreater ( x , y ) : NEW_LINE INDENT X = y * math . log ( x ) ; NEW_LINE Y = x * math . log ( y ) ; NEW_LINE if ( abs ( X - Y ) < 1e-9 ) : NEW_LINE INDENT print ( \" Equal \" ) ; NEW_LINE DEDENT elif ( X > Y ) : NEW_LINE INDENT print ( x , \" ^ \" , y ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( y , \" ^ \" , x ) ; NEW_LINE DEDENT DEDENT x = 5 ; NEW_LINE y = 8 ; NEW_LINE printGreater ( x , y ) ; NEW_LINE"],"bleu":0.9785826525822038,"rouge_l":0.9915254237288138}
{"id":1391,"predictions":["def getElement ( a , n , S ) : NEW_LINE INDENT a . sort ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( sum + ( a [ i ] * ( n - i ) ) == S ) : NEW_LINE INDENT return a [ i ] NEW_LINE DEDENT sum += a [ i ] NEW_LINE DEDENT return - 1 NEW_LINE DEDENT S = 5 NEW_LINE a = [ 1 , 3 , 2 , 5 , 8 ] NEW_LINE n = len ( a ) NEW_LINE print ( getElement ( a , n , S ) ) NEW_LINE"],"references":["def getElement ( a , n , S ) : NEW_LINE INDENT a . sort ( ) ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( sum + ( a [ i ] * ( n - i ) ) == S ) : NEW_LINE INDENT return a [ i ] ; NEW_LINE DEDENT sum += a [ i ] ; NEW_LINE DEDENT return - 1 ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = 5 ; NEW_LINE a = [ 1 , 3 , 2 , 5 , 8 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( getElement ( a , n , S ) ) ; NEW_LINE DEDENT"],"bleu":0.7051307714977688,"rouge_l":0.8910382945124359}
{"id":1392,"predictions":["def canMakeEqual ( a , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT while ( a [ i ] % 5 == 0 ) : NEW_LINE INDENT a [ i ] \/\/= 5 ; NEW_LINE DEDENT while ( a [ i ] % 3 == 0 ) : NEW_LINE INDENT a [ i ] \/\/= 3 ; NEW_LINE DEDENT DEDENT last = a [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( a [ i ] != last ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 18 , 30 , 54 , 90 , 90 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE if ( canMakeEqual ( arr , n ) ) : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE DEDENT DEDENT"],"references":["def canMakeEqual ( a , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT while ( a [ i ] % 5 == 0 ) : NEW_LINE INDENT a [ i ] \/\/= 5 ; NEW_LINE DEDENT while ( a [ i ] % 3 == 0 ) : NEW_LINE INDENT a [ i ] \/\/= 3 ; NEW_LINE DEDENT DEDENT last = a [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( a [ i ] != last ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 18 , 30 , 54 , 90 , 162 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE if ( canMakeEqual ( arr , n ) ) : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE DEDENT DEDENT"],"bleu":0.9860906831507594,"rouge_l":0.9944751381215471}
{"id":1393,"predictions":["x = 10 NEW_LINE y = 5 NEW_LINE x = x ^ y NEW_LINE y = x ^ y NEW_LINE x = x ^ y NEW_LINE print ( \" After ▁ swap : ▁ x ▁ = ▁ \" , x , \" ▁ y ▁ = \" , y ) NEW_LINE"],"references":["x = 10 NEW_LINE y = 5 NEW_LINE x = x ^ y ; NEW_LINE y = x ^ y ; NEW_LINE x = x ^ y ; NEW_LINE print ( \" After ▁ Swapping : ▁ x ▁ = ▁ \" , x , \" ▁ y ▁ = \" , y ) NEW_LINE"],"bleu":0.8093339427711247,"rouge_l":0.9484756097560976}
{"id":1394,"predictions":["def minimumOperations ( a , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] not in mp . keys ( ) : NEW_LINE INDENT mp [ a [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ a [ i ] ] += 1 NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for key , value in mp . items ( ) : NEW_LINE INDENT if ( value > 1 ) : NEW_LINE INDENT count += ( value - 1 ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT a = [ 2 , 1 , 2 , 3 , 3 , 4 , 3 ] NEW_LINE n = len ( a ) NEW_LINE print ( minimumOperations ( a , n ) ) NEW_LINE"],"references":["def minimumOperations ( a , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] in mp . keys ( ) : NEW_LINE INDENT mp [ a [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ a [ i ] ] = 1 NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for it in mp : NEW_LINE INDENT if ( mp [ it ] > 1 ) : NEW_LINE INDENT count += mp [ it ] - 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT a = [ 2 , 1 , 2 , 3 , 3 , 4 , 3 ] NEW_LINE n = len ( a ) NEW_LINE print ( minimumOperations ( a , n ) ) NEW_LINE"],"bleu":0.8366112295996306,"rouge_l":0.9204875217643648}
{"id":1395,"predictions":["def xorRange ( pre , l , r ) : NEW_LINE INDENT cntOnes = pre [ r ] NEW_LINE if ( l - 1 >= 0 ) : NEW_LINE INDENT cntOnes -= pre [ l - 1 ] NEW_LINE DEDENT if ( cntOnes % 2 == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT def performQueries ( queries , q , a , n ) : NEW_LINE INDENT pre = [ 0 ] * n NEW_LINE pre [ 0 ] = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT pre [ i ] = pre [ i - 1 ] + a [ i ] NEW_LINE DEDENT for i in range ( q ) : NEW_LINE INDENT pre [ i ] = pre [ i - 1 ] + a [ i ] NEW_LINE DEDENT for i in range ( q ) : NEW_LINE INDENT print ( xorRange ( pre , queries [ i ] [ 0 ] , queries [ i ] [ 1 ] ) ) NEW_LINE DEDENT DEDENT a = [ 1 , 0 , 1 , 1 , 1 , 0 , 1 ] NEW_LINE n = len ( a ) NEW_LINE queries = [ [ 0 , 3 ] , [ 0 , 2 ] ] NEW_LINE q = len ( queries ) NEW_LINE performQueries ( queries , q , a , n ) NEW_LINE"],"references":["def xorRange ( pre , l , r ) : NEW_LINE INDENT cntOnes = pre [ r ] NEW_LINE if ( l - 1 >= 0 ) : NEW_LINE INDENT cntOnes -= pre [ l - 1 ] NEW_LINE DEDENT if ( cntOnes % 2 == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT def performQueries ( queries , q , a , n ) : NEW_LINE INDENT pre = [ 0 for i in range ( n ) ] NEW_LINE pre [ 0 ] = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT pre [ i ] = pre [ i - 1 ] + a [ i ] NEW_LINE DEDENT for i in range ( q ) : NEW_LINE INDENT print ( xorRange ( pre , queries [ i ] [ 0 ] , queries [ i ] [ 1 ] ) ) NEW_LINE DEDENT DEDENT a = [ 1 , 0 , 1 , 1 , 0 , 1 , 1 ] NEW_LINE n = len ( a ) NEW_LINE queries = [ [ 0 , 3 ] , [ 0 , 2 ] ] NEW_LINE q = len ( queries ) NEW_LINE performQueries ( queries , q , a , n ) NEW_LINE"],"bleu":0.8850783849627871,"rouge_l":0.9259800849523014}
{"id":1396,"predictions":["def countNums ( n , x , y ) : NEW_LINE INDENT arr = [ True ] * ( n + 1 ) NEW_LINE if ( x <= n ) : NEW_LINE INDENT arr [ x ] = True NEW_LINE DEDENT if ( y <= n ) : NEW_LINE INDENT arr [ y ] = True NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( min ( x , y ) , n + 1 ) : NEW_LINE INDENT if ( arr [ i ] ) : NEW_LINE INDENT if ( i + x <= n ) : NEW_LINE INDENT arr [ i + x ] = True NEW_LINE DEDENT if ( i + y <= n ) : NEW_LINE INDENT arr [ i + y ] = True NEW_LINE DEDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 15 NEW_LINE x = 5 NEW_LINE y = 7 NEW_LINE print ( countNums ( n , x , y ) ) NEW_LINE DEDENT"],"references":["def countNums ( n , x , y ) : NEW_LINE INDENT arr = [ False for i in range ( n + 2 ) ] NEW_LINE if ( x <= n ) : NEW_LINE INDENT arr [ x ] = True NEW_LINE DEDENT if ( y <= n ) : NEW_LINE INDENT arr [ y ] = True NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( min ( x , y ) , n + 1 ) : NEW_LINE INDENT if ( arr [ i ] ) : NEW_LINE INDENT if ( i + x <= n ) : NEW_LINE INDENT arr [ i + x ] = True NEW_LINE DEDENT if ( i + y <= n ) : NEW_LINE INDENT arr [ i + y ] = True NEW_LINE DEDENT result = result + 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT n = 15 NEW_LINE x = 5 NEW_LINE y = 7 NEW_LINE print ( countNums ( n , x , y ) ) NEW_LINE"],"bleu":0.8594024544429353,"rouge_l":0.9220864047774564}
{"id":1397,"predictions":["def get_max_splits ( num_string ) : NEW_LINE INDENT count = 0 NEW_LINE current_num = 0 NEW_LINE running_sum = 0 NEW_LINE for i in range ( len ( num_String ) ) : NEW_LINE INDENT current_num = ord ( num_String [ i ] ) - ord ( '0' ) NEW_LINE running_sum += current_sum NEW_LINE if ( current_num % 3 == 0 and running_sum % 3 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE running_sum = 0 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ \" : NEW_LINE INDENT print ( get_max_splits ( \"12345\" ) ) NEW_LINE DEDENT"],"references":["def get_max_splits ( num_string ) : NEW_LINE INDENT count = 0 NEW_LINE running_sum = 0 NEW_LINE for i in range ( len ( num_string ) ) : NEW_LINE INDENT current_num = int ( num_string [ i ] ) NEW_LINE running_sum += current_num NEW_LINE if current_num % 3 == 0 or ( running_sum != 0 and running_sum % 3 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE running_sum = 0 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT print get_max_splits ( \"12345\" ) NEW_LINE"],"bleu":0.61564850771092,"rouge_l":0.8134779516358465}
{"id":1398,"predictions":["def term ( n ) : NEW_LINE INDENT return n * ( n + 1 ) \/\/ 2 NEW_LINE DEDENT n = 4 NEW_LINE print ( term ( n ) ) NEW_LINE"],"references":["def term ( n ) : NEW_LINE INDENT return n * ( n + 1 ) \/ 2 NEW_LINE DEDENT n = 4 NEW_LINE print term ( n ) NEW_LINE"],"bleu":0.7848271093555107,"rouge_l":0.9409574468085108}
{"id":1399,"predictions":["def anglequichord ( z ) : NEW_LINE INDENT print ( \" The ▁ angle ▁ is \" , z , \" degrees \" ) ; NEW_LINE DEDENT z = 48 ; NEW_LINE angleichord ( z ) ; NEW_LINE"],"references":["def anglequichord ( z ) : NEW_LINE INDENT print ( \" The ▁ angle ▁ is ▁ \" , z , \" ▁ degrees \" ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT z = 48 NEW_LINE anglequichord ( z ) NEW_LINE DEDENT"],"bleu":0.44981117043779495,"rouge_l":0.7444364680545584}
{"id":1400,"predictions":["def findLength ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE maxlen = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n , 2 ) : NEW_LINE INDENT length = j - i + 1 NEW_LINE leftsum = 0 NEW_LINE rightsum = 0 NEW_LINE for k in range ( length \/\/ 2 ) : NEW_LINE INDENT leftsum += ( ord ( str [ i + k ] ) - ord ( '0' ) ) NEW_LINE rightsum += ( ord ( str [ i + k + length \/\/ 2 ) - ord ( '0' ) ) ) NEW_LINE DEDENT if leftsum == right : NEW_LINE INDENT maxlen = length NEW_LINE DEDENT DEDENT DEDENT return maxlen NEW_LINE DEDENT str = \"1538023\" NEW_LINE print ( \" Length ▁ of ▁ the ▁ substring ▁ is \" , findLength ( str ) ) NEW_LINE"],"references":["def findLength ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE maxlen = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n , 2 ) : NEW_LINE INDENT length = j - i + 1 NEW_LINE leftsum = 0 NEW_LINE rightsum = 0 NEW_LINE for k in range ( 0 , int ( length \/ 2 ) ) : NEW_LINE INDENT leftsum += ( int ( str [ i + k ] ) - int ( '0' ) ) NEW_LINE rightsum += ( int ( str [ i + k + int ( length \/ 2 ) ] ) - int ( '0' ) ) NEW_LINE DEDENT if ( leftsum == rightsum and maxlen < length ) : NEW_LINE INDENT maxlen = length NEW_LINE DEDENT DEDENT DEDENT return maxlen NEW_LINE DEDENT str = \"1538023\" NEW_LINE print ( \" Length ▁ of ▁ the ▁ substring ▁ is \" , findLength ( str ) ) NEW_LINE"],"bleu":0.7681363256664111,"rouge_l":0.8958292539651458}
{"id":1401,"predictions":["MOD = 2019 NEW_LINE def min_modulo ( l , r ) : NEW_LINE INDENT if ( r - l >= MOD ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT ans = MOD - 1 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , r + 1 ) : NEW_LINE INDENT ans = min ( ans , ( i * j ) % MOD ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT l = 2020 NEW_LINE r = 2040 NEW_LINE print ( min_modulo ( l , r ) ) NEW_LINE"],"references":["MOD = 2019 ; NEW_LINE def min_modulo ( l , r ) : NEW_LINE INDENT if ( r - l >= MOD ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT ans = MOD - 1 ; NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , r + 1 ) : NEW_LINE INDENT ans = min ( ans , ( i * j ) % MOD ) ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT l = 2020 ; r = 2040 ; NEW_LINE print ( min_modulo ( l , r ) ) ; NEW_LINE DEDENT"],"bleu":0.7175641930906422,"rouge_l":0.8896691424713032}
{"id":1402,"predictions":["def countPairsWithProdK ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] * arr [ j ] == k : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 1 , 5 , 3 , 4 , 2 ] NEW_LINE N = len ( arr ) NEW_LINE K = 3 NEW_LINE print ( countPairsWithProdK ( arr , N , K ) ) NEW_LINE"],"references":["def countPairsWithProdK ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] * arr [ j ] == k ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 1 , 5 , 3 , 4 , 2 ] NEW_LINE N = len ( arr ) NEW_LINE K = 3 NEW_LINE print ( countPairsWithProdK ( arr , N , K ) ) NEW_LINE"],"bleu":0.951579699747513,"rouge_l":0.9886703383162864}
{"id":1403,"predictions":["def Xor_Sum ( arr , n ) : NEW_LINE INDENT sum = 0 ; index = - 1 ; NEW_LINE left_xor = 0 ; right_xor = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT left_xor = left_xor ^ arr [ i ] ; NEW_LINE right_xor = 0 ; NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT right_xor = right_xor ^ arr [ j ] ; NEW_LINE DEDENT if ( left_xor + right_xor > sum ) : NEW_LINE INDENT sum = left_xor + right_xor ; NEW_LINE index = i ; NEW_LINE DEDENT DEDENT return index + 1 ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 4 , 6 , 3 , 8 , 13 , 2 , 21 , 10 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( Xor_Sum ( arr , n ) ) ; NEW_LINE DEDENT"],"references":["def Xor_Sum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE index , left_xor = 0 , 0 NEW_LINE right_xor = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT left_xor = left_xor ^ arr [ i ] NEW_LINE right_xor = 0 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT right_xor = right_xor ^ arr [ j ] NEW_LINE DEDENT if ( left_xor + right_xor > sum ) : NEW_LINE INDENT sum = left_xor + right_xor NEW_LINE index = i NEW_LINE DEDENT DEDENT return index + 1 NEW_LINE DEDENT arr = [ 1 , 4 , 6 , 3 , 8 , 13 , 34 , 2 , 21 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( Xor_Sum ( arr , n ) ) NEW_LINE"],"bleu":0.6898045451811824,"rouge_l":0.889842325431728}
{"id":1404,"predictions":["def prints ( a , n , ind ) : NEW_LINE INDENT for i in range ( ind , n + ind ) : NEW_LINE INDENT print ( a [ ( i % n ) ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT a = [ ' A ' , ' B ' , ' C ' , ' D ' , ' E ' ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( a , n , 3 ) ; NEW_LINE"],"references":["def prints ( a , n , ind ) : NEW_LINE INDENT i = ind NEW_LINE while i < n + ind : NEW_LINE INDENT print ( a [ ( i % n ) ] , end = \" ▁ \" ) NEW_LINE i = i + 1 NEW_LINE DEDENT DEDENT a = [ ' A ' , ' B ' , ' C ' , ' D ' , ' E ' , ' F ' ] NEW_LINE n = len ( a ) ; NEW_LINE prints ( a , n , 3 ) ; NEW_LINE"],"bleu":0.7317470960626631,"rouge_l":0.8605015673981192}
{"id":1405,"predictions":["def printPattern ( i , j , n ) : NEW_LINE INDENT if ( j >= n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( i >= n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( j == i or j == n - 1 - i ) : NEW_LINE INDENT if ( i == n - 1 - j ) : NEW_LINE INDENT print ( \" \/ \" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" \\n \" , end = \" \" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( \" * \" , end = \" \" ) NEW_LINE DEDENT if ( printPattern ( i , j + 1 , n ) == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT print ( ) NEW_LINE return printPattern ( i + 1 , 0 , n ) NEW_LINE DEDENT N = 9 NEW_LINE printPattern ( 0 , 0 , N ) NEW_LINE"],"references":["def printPattern ( i , j , n ) : NEW_LINE INDENT if ( j >= n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( i >= n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( j == i or j == n - 1 - i ) : NEW_LINE INDENT if ( i == n - 1 - j ) : NEW_LINE INDENT print ( \" \/ \" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" \\\\ \" , end = \" \" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( \" * \" , end = \" \" ) NEW_LINE DEDENT if ( printPattern ( i , j + 1 , n ) == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT print ( ) NEW_LINE return printPattern ( i + 1 , 0 , n ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 9 NEW_LINE printPattern ( 0 , 0 , N ) NEW_LINE DEDENT"],"bleu":0.8835788095169712,"rouge_l":0.9439731518597931}
{"id":1406,"predictions":["import sys NEW_LINE def findMaxValue ( arr , n ) : NEW_LINE INDENT if ( n < 4 ) : NEW_LINE INDENT print ( \" The ▁ array ▁ doesn ' ) : NEW_LINE INDENT print ( ' The ▁ array ▁ doesn ' ) NEW_LINE DEDENT type1 = [ 0 ] * ( n + 1 ) NEW_LINE t2 = [ None ] * ( n + 1 ) NEW_LINE t1 . sort ( ) NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT a1 [ i ] = [ 0 ] * ( n - 2 ) NEW_LINE a2 [ i ] = [ 0 ] * ( n - 2 ) NEW_LINE DEDENT for i in range ( n - 1 , - 1 ) : NEW_LINE INDENT for j in range ( n - 1 , i + 1 ) : NEW_LINE INDENT a1 [ j ] = mat [ j ] [ i ] NEW_LINE DEDENT DEDENT for i in range ( n - 2 , n - 1 , - 1 ) : NEW_LINE INDENT a2 [ i ] = max ( a1 [ i ] , a [ i ] ) NEW_LINE DEDENT for i in range ( n - 2 , n - 1 , 0 ) : NEW_LINE INDENT a2 [ i ] = max ( a2 [ i ] , a2 [ i ] ) NEW_LINE DEDENT for i in range ( n - 2 , n - 1 , - 1 ) : NEW_LINE INDENT a2 [ i ] = max ( a1 [ i ] , a [ 1 ] ) NEW_LINE DEDENT for i in range ( n - 2 , n - 1 ) : NEW_LINE INDENT a2 [ i ] = max ( a2 [ i ] , a [ i ] ) NEW_LINE DEDENT for i in range ( n - 3 , 2 ) : NEW_LINE INDENT a2 [ i ] = ( a2 [ i ] , a2 [ i ] ) NEW_LINE DEDENT for i in range ( n - 3 ) : NEW_LINE INDENT a [ i ] = mat [ a [ i ] , a [ i ] ] + a [ i ] ) NEW_LINE DEDENT for i in range ( n - 3 ,"],"references":["def findMaxValue ( arr , n ) : NEW_LINE INDENT if n < 4 : NEW_LINE INDENT print ( \" The ▁ array ▁ should ▁ have ▁ atlest ▁ 4 ▁ elements \" ) NEW_LINE return MIN NEW_LINE DEDENT table1 , table2 = [ MIN ] * ( n + 1 ) , [ MIN ] * n NEW_LINE table3 , table4 = [ MIN ] * ( n - 1 ) , [ MIN ] * ( n - 2 ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT table1 [ i ] = max ( table1 [ i + 1 ] , arr [ i ] ) NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT table2 [ i ] = max ( table2 [ i + 1 ] , table1 [ i + 1 ] - arr [ i ] ) NEW_LINE DEDENT for i in range ( n - 3 , - 1 , - 1 ) : NEW_LINE INDENT table3 [ i ] = max ( table3 [ i + 1 ] , table2 [ i + 1 ] + arr [ i ] ) NEW_LINE DEDENT for i in range ( n - 4 , - 1 , - 1 ) : NEW_LINE INDENT table4 [ i ] = max ( table4 [ i + 1 ] , table3 [ i + 1 ] - arr [ i ] ) NEW_LINE DEDENT return table4 [ 0 ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 4 , 8 , 9 , 2 , 20 ] NEW_LINE n = len ( arr ) NEW_LINE MIN = - 100000000 NEW_LINE print ( findMaxValue ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.4039846087045657,"rouge_l":0.5913968373493976}
{"id":1407,"predictions":["def printElements ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE a . sort ( ) NEW_LINE cnt = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( a [ i ] != a [ i + 1 ] ) : NEW_LINE INDENT print ( a [ i ] , end = \" ▁ \" ) NEW_LINE cnt = 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT print ( a [ n - 1 ] , end = \" ▁ \" ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 1 , 1 , 2 , 3 , 4 , 9 , 10 ] NEW_LINE n = len ( a ) NEW_LINE printElements ( a , n ) NEW_LINE DEDENT"],"references":["def printElements ( a , n ) : NEW_LINE INDENT a . sort ( reverse = True ) NEW_LINE cnt = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( a [ i ] != a [ i + 1 ] ) : NEW_LINE INDENT print ( a [ i ] , \" ▁ occurs ▁ \" , cnt , \" times \" ) NEW_LINE cnt = 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT print ( a [ n - 1 ] , \" occurs \" , cnt , \" times \" ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 1 , 1 , 2 , 3 , 4 , 9 , 9 , 10 ] NEW_LINE n = len ( a ) NEW_LINE printElements ( a , n ) NEW_LINE DEDENT"],"bleu":0.8342422762190481,"rouge_l":0.8942951237650059}
{"id":1408,"predictions":["def findMin ( arr , n ) : NEW_LINE INDENT m = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT m = max ( m , arr [ i ] ) NEW_LINE DEDENT freq = [ 0 for i in range ( m + 2 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT j = i NEW_LINE cnt = 0 NEW_LINE while ( j <= m ) : NEW_LINE INDENT cnt += freq [ j ] NEW_LINE j += i NEW_LINE DEDENT if ( cnt == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return m + 1 NEW_LINE DEDENT arr = [ 2 , 12 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMin ( arr , n ) ) NEW_LINE"],"references":["def findMin ( arr , n ) : NEW_LINE INDENT m = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT m = max ( m , arr [ i ] ) NEW_LINE DEDENT freq = [ 0 ] * ( m + 2 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( 1 , m + 2 ) : NEW_LINE INDENT j = i NEW_LINE cnt = 0 NEW_LINE while ( j <= m ) : NEW_LINE INDENT cnt += freq [ j ] NEW_LINE j += i NEW_LINE DEDENT if ( not cnt ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return m + 1 NEW_LINE DEDENT arr = [ 2 , 12 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMin ( arr , n ) ) NEW_LINE"],"bleu":0.9099733040654752,"rouge_l":0.9648943769772426}
{"id":1409,"predictions":["def swapOperations ( a , b , c ) : NEW_LINE INDENT l = len ( a ) NEW_LINE i = 0 NEW_LINE total_swaps = 0 NEW_LINE temp = 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( a [ i ] == b [ i ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( a [ i ] == c [ i ] ) : NEW_LINE INDENT temp = b [ i ] NEW_LINE b [ i ] = c [ i ] NEW_LINE c [ i ] = temp NEW_LINE total_swaps += 1 NEW_LINE continue NEW_LINE DEDENT if ( b [ i ] == c [ i ] ) : NEW_LINE INDENT temp = a [ i ] NEW_LINE a [ i ] = c [ i ] NEW_LINE c [ i ] = temp NEW_LINE total_swaps += 1 NEW_LINE continue NEW_LINE DEDENT break NEW_LINE DEDENT if ( i == l ) : NEW_LINE INDENT print ( total_swaps ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = \" xyz \" NEW_LINE b = \" y \" NEW_LINE c = \" yyx \" NEW_LINE swapOperations ( a , b , c ) NEW_LINE DEDENT"],"references":["def swapOperations ( a , b , c ) : NEW_LINE INDENT l = len ( a ) ; NEW_LINE i = 0 ; NEW_LINE total_swaps = 0 ; NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( a [ i ] == b [ i ] ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT if ( a [ i ] == c [ i ] ) : NEW_LINE INDENT b [ i ] , c [ i ] = c [ i ] , b [ i ] ; NEW_LINE total_swaps += 1 ; NEW_LINE continue ; NEW_LINE DEDENT if ( b [ i ] == c [ i ] ) : NEW_LINE INDENT a [ i ] , c [ i ] = c [ i ] , a [ i ] ; NEW_LINE total_swaps += 1 ; NEW_LINE continue ; NEW_LINE DEDENT break ; NEW_LINE DEDENT i += 1 ; NEW_LINE if ( i == l ) : NEW_LINE INDENT print ( total_swaps ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = \" xyz \" ; NEW_LINE b = \" yzx \" ; NEW_LINE c = \" yzx \" ; NEW_LINE swapOperations ( list ( a ) , list ( b ) , list ( c ) ) ; NEW_LINE DEDENT"],"bleu":0.6671590728326725,"rouge_l":0.8575847040629834}
{"id":1410,"predictions":["def findMinimumZ ( n , a , b ) : NEW_LINE INDENT if ( a > b ) : NEW_LINE INDENT a , b = b , a NEW_LINE minDist = ( a - 1 ) + ( n - b + 1 ) NEW_LINE if ( minDist == 1 ) : NEW_LINE INDENT return 3 NEW_LINE DEDENT return minDist NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 NEW_LINE a = 1 NEW_LINE b = 2 NEW_LINE print ( findMinimumZ ( n , a , b ) ) NEW_LINE DEDENT"],"references":["def findMinimumZ ( n , a , b ) : NEW_LINE INDENT if ( a > b ) : NEW_LINE INDENT temp = a NEW_LINE a = b NEW_LINE b = temp NEW_LINE DEDENT distClock = b - a NEW_LINE distAntiClock = ( a - 1 ) + ( n - b + 1 ) NEW_LINE minDist = min ( distClock , distAntiClock ) NEW_LINE if ( minDist == 1 ) : NEW_LINE INDENT return 3 NEW_LINE DEDENT return minDist NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE a = 1 NEW_LINE b = 2 NEW_LINE print ( findMinimumZ ( n , a , b ) ) NEW_LINE DEDENT"],"bleu":0.7149974846980073,"rouge_l":0.8497067448680353}
{"id":1411,"predictions":["def solve ( ang , n ) : NEW_LINE INDENT if ( ( ang * n ) > ( 180 * ( n - 2 ) ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( ( ang * n ) % 180 != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = 1 NEW_LINE freq = ( ang * n ) \/\/ 180 NEW_LINE ans = ans * ( n - 1 - freq ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT ang , n = 90 , 4 NEW_LINE print ( solve ( ang , n ) ) NEW_LINE DEDENT"],"references":["def solve ( ang , n ) : NEW_LINE INDENT if ( ( ang * n ) > ( 180 * ( n - 2 ) ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( ( ang * n ) % 180 != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = 1 NEW_LINE freq = ( ang * n ) \/\/ 180 NEW_LINE ans = ans * ( n - 1 - freq ) NEW_LINE ans = ans * n NEW_LINE return ans NEW_LINE DEDENT ang = 90 NEW_LINE n = 4 NEW_LINE print ( solve ( ang , n ) ) NEW_LINE"],"bleu":0.8214399098684073,"rouge_l":0.8896582203889216}
{"id":1412,"predictions":["def bitsAreInAltPatrnInGiven ( n , l , r ) : NEW_LINE INDENT num = n >> ( l - 1 ) NEW_LINE prev = num & 1 NEW_LINE num = num >> 1 NEW_LINE for i in range ( 1 , ( r - l + 1 ) ) : NEW_LINE INDENT curr = num & 1 NEW_LINE if ( curr == prev ) : NEW_LINE INDENT return False NEW_LINE DEDENT prev = curr NEW_LINE num = num >> 1 NEW_LINE DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 18 NEW_LINE l = 1 NEW_LINE r = 3 NEW_LINE if ( bitsAreInAltPatange ( n , l , r ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def bitsAreInAltPatrnInGivenTRange ( n , l , r ) : NEW_LINE INDENT num = n >> ( l - 1 ) ; NEW_LINE prev = num & 1 ; NEW_LINE num = num >> 1 ; NEW_LINE for i in range ( 1 , ( r - l ) ) : NEW_LINE INDENT curr = num & 1 ; NEW_LINE if ( curr == prev ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT prev = curr ; NEW_LINE num = num >> 1 ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 18 ; NEW_LINE l = 1 ; NEW_LINE r = 3 ; NEW_LINE if ( bitsAreInAltPatrnInGivenTRange ( n , l , r ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"],"bleu":0.7447076102843133,"rouge_l":0.9311975919157172}
{"id":1413,"predictions":["def countFibs ( low , high ) : NEW_LINE INDENT f1 = 0 NEW_LINE f2 = 1 NEW_LINE f3 = 1 NEW_LINE result = 0 NEW_LINE while ( f1 <= high ) : NEW_LINE INDENT if ( f1 >= low ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT f1 = f2 NEW_LINE f2 = f3 NEW_LINE f3 = f1 + f2 NEW_LINE DEDENT return result NEW_LINE DEDENT low = 10 NEW_LINE high = 100 NEW_LINE print ( \" Count ▁ of ▁ Fibonacci ▁ Numbers ▁ is \" , countFibs ( low , high ) ) NEW_LINE"],"references":["def countFibs ( low , high ) : NEW_LINE INDENT f1 , f2 , f3 = 0 , 1 , 1 NEW_LINE result = 0 NEW_LINE while ( f1 <= high ) : NEW_LINE INDENT if ( f1 >= low ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT f1 = f2 NEW_LINE f2 = f3 NEW_LINE f3 = f1 + f2 NEW_LINE DEDENT return result NEW_LINE DEDENT low , high = 10 , 100 NEW_LINE print ( \" Count ▁ of ▁ Fibonacci ▁ Numbers ▁ is \" , countFibs ( low , high ) ) NEW_LINE"],"bleu":0.8538458293754403,"rouge_l":0.9081632653061225}
{"id":1414,"predictions":["def Sum_upto_nth_Term ( n ) : NEW_LINE INDENT r = n * ( n + 1 ) * ( 2 * n + 7 ) \/\/ 3 NEW_LINE print ( r ) NEW_LINE DEDENT if __name__ == \" _ _ main _ \" : NEW_LINE INDENT N = 5 NEW_LINE Sum_upto_nth_Term ( N ) NEW_LINE DEDENT"],"references":["def Sum_upto_nth_Term ( n ) : NEW_LINE INDENT return n * ( n + 1 ) * ( 2 * n + 7 ) \/\/ 3 NEW_LINE DEDENT N = 5 NEW_LINE print ( Sum_upto_nth_Term ( N ) ) NEW_LINE"],"bleu":0.5553268125136568,"rouge_l":0.7732394366197185}
{"id":1415,"predictions":["class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT first = first NEW_LINE last = last NEW_LINE last = 0 NEW_LINE def printList ( node ) : NEW_LINE INDENT while ( node != None ) : NEW_LINE INDENT print ( node . data , end = \" ▁ \" ) NEW_LINE node = node . next NEW_LINE DEDENT DEDENT def pushToFront ( head , p , m ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT return NEW_LINE DEDENT p = head NEW_LINE head = head . next NEW_LINE m += 1 NEW_LINE if ( length == m ) : NEW_LINE INDENT p . next = first NEW_LINE last . next = head NEW_LINE first = head NEW_LINE DEDENT else : NEW_LINE INDENT giveToFront ( head , p , m ) NEW_LINE DEDENT DEDENT def push ( head_ref , new_data ) : NEW_LINE INDENT new_node = Node ( new_data ) NEW_LINE new_node . data = new_data NEW_LINE new_node . next = head_ref NEW_LINE if ( length == 0 ) : NEW_LINE INDENT first = head_ref NEW_LINE DEDENT else : NEW_LINE INDENT first = head_ref NEW_LINE DEDENT length += 1 NEW_LINE DEDENT return head_ref NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT start = None NEW_LINE start = None NEW_LINE start = start NEW_LINE start = push ( start , 5 ) NEW_LINE start = push ( start , 4 ) NEW_LINE start = push ( start , 3 ) NEW_LINE start = push ( start , 2 ) NEW_LINE head = push ( start , 1 ) NEW_LINE print ( \" \\n Minimum ▁ Linked ▁ list \" ) NEW_LINE printList ( start ) NEW_LINE print ( \" \\n Initial ▁ Linked ▁ list \" ) ) NEW_LINE DEDENT"],"references":["class Node : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . data = 0 NEW_LINE self . next = None NEW_LINE DEDENT DEDENT first = None NEW_LINE last = None NEW_LINE length = 0 NEW_LINE def printList ( node ) : NEW_LINE INDENT while ( node != None ) : NEW_LINE INDENT print ( node . data , end = \" ▁ \" ) NEW_LINE node = node . next NEW_LINE DEDENT DEDENT def moveToFront ( head , p , m ) : NEW_LINE INDENT global first NEW_LINE global last NEW_LINE global length NEW_LINE if ( head == None ) : NEW_LINE INDENT return head NEW_LINE DEDENT p = head NEW_LINE head = head . next NEW_LINE m = m + 1 NEW_LINE if ( length == m ) : NEW_LINE INDENT p . next = None NEW_LINE last . next = first NEW_LINE first = head NEW_LINE DEDENT else : NEW_LINE INDENT moveToFront ( head , p , m ) NEW_LINE DEDENT DEDENT def push ( head_ref , new_data ) : NEW_LINE INDENT global first NEW_LINE global last NEW_LINE global length NEW_LINE new_node = Node ( ) NEW_LINE new_node . data = new_data NEW_LINE new_node . next = ( head_ref ) NEW_LINE ( head_ref ) = new_node NEW_LINE if ( length == 0 ) : NEW_LINE INDENT last = head_ref NEW_LINE DEDENT else : NEW_LINE INDENT first = head_ref NEW_LINE DEDENT length = length + 1 NEW_LINE return head_ref NEW_LINE DEDENT start = None NEW_LINE start = push ( start , 5 ) NEW_LINE start = push ( start , 4 ) NEW_LINE start = push ( start , 3 ) NEW_LINE start = push ( start , 2 ) NEW_LINE start = push ( start , 1 ) NEW_LINE start = push ( start , 0 ) NEW_LINE print ( \" \\n ▁ Initial ▁ Linked ▁ list \" ) NEW_LINE printList ( start ) NEW_LINE m = 4 NEW_LINE temp = None NEW_LINE moveToFront ( start , temp , m ) NEW_LINE print ( \" \\n ▁ Final ▁ Linked ▁ list \" ) NEW_LINE start = first NEW_LINE printList ( start ) NEW_LINE"],"bleu":0.6973174517349879,"rouge_l":0.8134882834825681}
{"id":1416,"predictions":["def printRepeating ( arr , size ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in s : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE print ( s ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 3 , 2 , 2 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE printRepeating ( arr , n ) NEW_LINE DEDENT"],"references":["def printRepeating ( arr , size ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT if arr [ i ] not in s : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT for i in s : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 3 , 2 , 2 , 1 ] NEW_LINE size = len ( arr ) NEW_LINE printRepeating ( arr , size ) NEW_LINE DEDENT"],"bleu":0.5856378602947636,"rouge_l":0.7768772742308964}
{"id":1417,"predictions":["def maxsum_SIS ( arr , n ) : NEW_LINE INDENT max_sum = 0 NEW_LINE current_sum = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i - 1 ] < arr [ i ] ) : NEW_LINE INDENT current_sum = current_sum + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT max_sum = max ( max_sum , current_sum ) NEW_LINE current_sum = arr [ i ] NEW_LINE DEDENT DEDENT return max ( max_sum , current_sum ) NEW_LINE DEDENT arr = [ 1 , 2 , 2 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Maximum ▁ sum ▁ : ▁ \" , maxsum_SIS ( arr , n ) ) NEW_LINE"],"references":["def maxsum_SIS ( arr , n ) : NEW_LINE INDENT max_sum = 0 NEW_LINE current_sum = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i - 1 ] < arr [ i ] ) : NEW_LINE INDENT current_sum = current_sum + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT max_sum = max ( max_sum , current_sum ) NEW_LINE current_sum = arr [ i ] NEW_LINE DEDENT DEDENT return max ( max_sum , current_sum ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT arr = [ 1 , 2 , 2 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Maximum ▁ sum ▁ : ▁ \" , maxsum_SIS ( arr , n ) ) , NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"bleu":0.7983743548993707,"rouge_l":0.8900576857821512}
{"id":1418,"predictions":["def sumoflength ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE j , ans = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( j < n and arr [ j ] not in s . keys ( ) ) : NEW_LINE INDENT s [ arr [ i ] ] = 1 NEW_LINE j += 1 NEW_LINE DEDENT ans += ( ( j - i ) * ( j - i + 1 ) ) \/\/ 2 NEW_LINE s . remove ( arr [ i ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( sumoflength ( arr , n ) ) NEW_LINE"],"references":["def sumoflength ( arr , n ) : NEW_LINE INDENT s = [ ] NEW_LINE j = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( j < n and ( arr [ j ] not in s ) ) : NEW_LINE INDENT s . append ( arr [ j ] ) NEW_LINE j += 1 NEW_LINE DEDENT ans += ( ( j - i ) * ( j - i + 1 ) ) \/\/ 2 NEW_LINE s . remove ( arr [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( sumoflength ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.7556593838277021,"rouge_l":0.8516579406631763}
{"id":1419,"predictions":["def printVector ( v , i ) : NEW_LINE INDENT for j in range ( i , len ( v ) ) : NEW_LINE INDENT print ( v [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( \" \" ) NEW_LINE DEDENT path = [ ] NEW_LINE root = [ ] NEW_LINE def printKPathUtil ( root , k ) : NEW_LINE INDENT for j in range ( len ( v ) ) : NEW_LINE INDENT print ( v [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT printKPathUtil ( root , k ) NEW_LINE printKPathUtil ( root . left , k ) NEW_LINE printKPathUtil ( root . data , k ) NEW_LINE printKPathUtil ( root . left , k ) NEW_LINE f = 0 NEW_LINE for j in range ( len ( pattern ) - 1 , - 1 ) : NEW_LINE INDENT f += arr [ j ] NEW_LINE DEDENT if ( f == k ) : NEW_LINE INDENT printVPathUtil ( arr , j ) ) NEW_LINE DEDENT DEDENT def printKPath ( root , k ) : NEW_LINE INDENT root . append ( [ ] ) NEW_LINE printKPathUtil ( root , k ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT root = [ ] NEW_LINE root = Node ( 1 ) NEW_LINE root . left = Node ( 2 ) NEW_LINE root . left = Node ( 1 ) NEW_LINE root . left . right = Node ( 1 ) NEW_LINE root . right . right = Node ( 1 ) NEW_LINE root . right . left = Node ( 1 ) NEW_LINE root . right . right = Node ( 1 ) NEW_LINE root . right . right . left = Node ( 1 ) NEW_LINE root . right . right = Node ( 4 ) NEW_LINE root . right . left = Node ( 1 ) NEW_LINE root . right . right = Node ( 1 ) NEW_LINE root . right . left = Node ( 2 ) NEW_LINE root . right . right = Node ( 2 ) NEW_LINE root . right . left = Node ( 1 ) NEW_"],"references":["def printVector ( v , i ) : NEW_LINE INDENT for j in range ( i , len ( v ) ) : NEW_LINE INDENT print ( v [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT class newNode : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . data = key NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def printKPathUtil ( root , path , k ) : NEW_LINE INDENT if ( not root ) : NEW_LINE INDENT return NEW_LINE DEDENT path . append ( root . data ) NEW_LINE printKPathUtil ( root . left , path , k ) NEW_LINE printKPathUtil ( root . right , path , k ) NEW_LINE f = 0 NEW_LINE for j in range ( len ( path ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT f += path [ j ] NEW_LINE if ( f == k ) : NEW_LINE INDENT printVector ( path , j ) NEW_LINE DEDENT DEDENT path . pop ( - 1 ) NEW_LINE DEDENT def printKPath ( root , k ) : NEW_LINE INDENT path = [ ] NEW_LINE printKPathUtil ( root , path , k ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 1 ) NEW_LINE root . left = newNode ( 3 ) NEW_LINE root . left . left = newNode ( 2 ) NEW_LINE root . left . right = newNode ( 1 ) NEW_LINE root . left . right . left = newNode ( 1 ) NEW_LINE root . right = newNode ( - 1 ) NEW_LINE root . right . left = newNode ( 4 ) NEW_LINE root . right . left . left = newNode ( 1 ) NEW_LINE root . right . left . right = newNode ( 2 ) NEW_LINE root . right . right = newNode ( 5 ) NEW_LINE root . right . right . right = newNode ( 2 ) NEW_LINE k = 5 NEW_LINE printKPath ( root , k ) NEW_LINE DEDENT"],"bleu":0.6158802645954842,"rouge_l":0.7165252344796784}
{"id":1420,"predictions":["def reverseArray ( arr , n ) : NEW_LINE INDENT for i in range ( n \/\/ 2 ) : NEW_LINE INDENT arr [ i ] , arr [ n + ~ i + 1 ] + ~ 1 + 1 NEW_LINE DEDENT DEDENT arr = [ 5 , 3 , 7 , 2 , 1 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE reverseArray ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT"],"references":["def reverseArray ( arr , n ) : NEW_LINE INDENT for i in range ( n \/\/ 2 ) : NEW_LINE INDENT arr [ i ] , arr [ ( n + ~ i + 1 ) + ~ 1 + 1 ] = arr [ ( n + ~ i + 1 ) + ~ 1 + 1 ] , arr [ i ] NEW_LINE DEDENT DEDENT arr = [ 5 , 3 , 7 , 2 , 1 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE reverseArray ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT"],"bleu":0.745938145229111,"rouge_l":0.8748370273794002}
{"id":1421,"predictions":["import math NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def push ( data ) : NEW_LINE INDENT new_node = Node ( data ) NEW_LINE new_node . next = None NEW_LINE new_node . next = None NEW_LINE return new_node NEW_LINE DEDENT def push ( head_ref , new_node ) : NEW_LINE INDENT new_node . prev = None NEW_LINE new_node . next = head_ref NEW_LINE if ( head_ref != None ) : NEW_LINE INDENT head_ref . prev = new_node NEW_LINE DEDENT head_ref = new_node NEW_LINE return head_ref NEW_LINE DEDENT def reverseList ( head_ref ) : NEW_LINE INDENT if ( head_ref == None or ( head_ref ) . next == None ) : NEW_LINE INDENT return None NEW_LINE DEDENT new_head = None NEW_LINE curr = head_ref NEW_LINE while ( curr != None ) : NEW_LINE INDENT next = curr . next NEW_LINE new_head = push ( new_head , curr ) NEW_LINE curr = next NEW_LINE DEDENT head_ref = new_head NEW_LINE return head_ref NEW_LINE DEDENT def printList ( head ) : NEW_LINE INDENT if ( head != None ) : NEW_LINE INDENT print ( head . data , end = \" ▁ \" ) NEW_LINE head = head . next NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT head = None NEW_LINE head = push ( head , 2 ) NEW_LINE head = push ( head , 1 ) NEW_LINE head = push ( head , 4 ) NEW_LINE head = push ( head , 8 ) NEW_LINE head = push ( head , None ) NEW_LINE head = push ( head , None ) NEW_LINE head = push ( head , None ) NEW_LINE printList ( head ) NEW_LINE printList ( head ) NEW_LINE DEDENT"],"references":["import math NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def getNode ( data ) : NEW_LINE INDENT new_node = Node ( data ) NEW_LINE new_node . data = data NEW_LINE new_node . next = None NEW_LINE new_node . prev = None NEW_LINE return new_node NEW_LINE DEDENT def push ( head_ref , new_node ) : NEW_LINE INDENT new_node . prev = None NEW_LINE new_node . next = head_ref NEW_LINE if ( head_ref != None ) : NEW_LINE INDENT head_ref . prev = new_node NEW_LINE DEDENT head_ref = new_node NEW_LINE return head_ref NEW_LINE DEDENT def reverseList ( head_ref ) : NEW_LINE INDENT if ( head_ref == None or ( head_ref ) . next == None ) : NEW_LINE INDENT return None NEW_LINE DEDENT new_head = None NEW_LINE curr = head_ref NEW_LINE while ( curr != None ) : NEW_LINE INDENT next = curr . next NEW_LINE new_head = push ( new_head , curr ) NEW_LINE curr = next NEW_LINE DEDENT head_ref = new_head NEW_LINE return head_ref NEW_LINE DEDENT def prList ( head ) : NEW_LINE INDENT while ( head != None ) : NEW_LINE INDENT print ( head . data , end = \" ▁ \" ) NEW_LINE head = head . next NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = None NEW_LINE head = push ( head , getNode ( 2 ) ) ; NEW_LINE head = push ( head , getNode ( 4 ) ) ; NEW_LINE head = push ( head , getNode ( 8 ) ) ; NEW_LINE head = push ( head , getNode ( 10 ) ) ; NEW_LINE print ( \" Original ▁ list : ▁ \" , end = \" \" ) NEW_LINE prList ( head ) NEW_LINE head = reverseList ( head ) NEW_LINE print ( \" \\n Reversed ▁ list : ▁ \" , end = \" \" ) NEW_LINE prList ( head ) NEW_LINE DEDENT"],"bleu":0.7446975584014155,"rouge_l":0.8627537945988566}
{"id":1422,"predictions":["def decdiagonal ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT d = 1.9 NEW_LINE return d NEW_LINE DEDENT a = 9 NEW_LINE print ( decdiagonal ( a ) ) NEW_LINE"],"references":["def decdiagonal ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT d = 1.902 * a NEW_LINE return d NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 9 NEW_LINE print ( decdiagonal ( a ) ) NEW_LINE DEDENT"],"bleu":0.6151013342767,"rouge_l":0.7970044614404079}
{"id":1423,"predictions":["def findSum ( N , k ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT sum += pow ( i , k ) NEW_LINE DEDENT return sum NEW_LINE DEDENT N = 8 NEW_LINE k = 4 NEW_LINE print ( findSum ( N , k ) ) NEW_LINE"],"references":["from math import pow NEW_LINE def findSum ( N , k ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , N + 1 , 1 ) : NEW_LINE INDENT sum += pow ( i , k ) NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 8 NEW_LINE k = 4 NEW_LINE print ( int ( findSum ( N , k ) ) ) NEW_LINE DEDENT"],"bleu":0.6320050808632713,"rouge_l":0.8090185676392573}
{"id":1424,"predictions":["def reverse ( k ) : NEW_LINE INDENT s = [ ] NEW_LINE k = k . split ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . append ( k ) NEW_LINE DEDENT while len ( s ) != 0 : NEW_LINE INDENT print ( s [ - 1 ] , end = \" ▁ \" ) NEW_LINE s . pop ( ) NEW_LINE DEDENT DEDENT k = \" geeks ▁ for ▁ geeks \" NEW_LINE revers ( k ) NEW_LINE"],"references":["def reverse ( k ) : NEW_LINE INDENT s = [ ] NEW_LINE token = k . split ( ) NEW_LINE for word in token : NEW_LINE INDENT s . append ( word ) ; NEW_LINE DEDENT while ( len ( s ) ) : NEW_LINE INDENT print ( s . pop ( ) , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT k = \" geeks ▁ for ▁ geeks \" ; NEW_LINE reverse ( k ) ; NEW_LINE DEDENT"],"bleu":0.5519912815723914,"rouge_l":0.7258035872846741}
{"id":1425,"predictions":["import sys NEW_LINE def subArray ( arr , n , m ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] = i + 1 NEW_LINE DEDENT sumcur = 0 NEW_LINE p = sys . maxsize - 1 NEW_LINE ans = [ ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT sumcur += mp [ i ] NEW_LINE p = min ( p , mp [ i ] ) NEW_LINE val = p * i - i + ( i * ( i + 1 ) ) NEW_LINE if ( i == m ) : NEW_LINE INDENT if ( val == sumcur ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT arr = [ 4 , 5 , 1 , 3 , 2 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE m = 3 NEW_LINE if ( subArray ( arr , n , m ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def subArray ( arr , n , m ) : NEW_LINE INDENT i = 0 NEW_LINE mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] = i + 1 NEW_LINE DEDENT sumcur = 0 NEW_LINE p = 10 ** 9 NEW_LINE ans = [ ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT sumcur += mp [ i ] NEW_LINE p = min ( p , mp [ i ] ) NEW_LINE val = p * i - i + ( i * ( i + 1 ) ) \/ 2 NEW_LINE if ( i == m ) : NEW_LINE INDENT if ( val == sumcur ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT DEDENT arr = [ 4 , 5 , 1 , 3 , 2 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE m = 3 NEW_LINE if ( subArray ( arr , n , m ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.9192381136765857,"rouge_l":0.9527490731245563}
{"id":1426,"predictions":["class Graph : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . V = V NEW_LINE self . adj = [ [ ] for i in range ( V ) ] NEW_LINE DEDENT def addEdge ( self , v , w ) : NEW_LINE INDENT self . adj [ v ] . append ( v ) NEW_LINE DEDENT def DFS ( self , s ) : NEW_LINE INDENT visited = [ False for i in range ( V ) ] NEW_LINE for i in range ( len ( self ) ) : NEW_LINE INDENT visited . append ( False ) NEW_LINE DEDENT stack = [ ] NEW_LINE stack . append ( s ) NEW_LINE while ( len ( stack ) != 0 ) : NEW_LINE INDENT s = stack [ - 1 ] NEW_LINE stack . pop ( ) NEW_LINE if ( visited [ s ] == True ) : NEW_LINE INDENT print ( s , end = \" ▁ \" ) NEW_LINE visited [ s ] = True NEW_LINE DEDENT i = self . j NEW_LINE while ( i > 0 ) : NEW_LINE INDENT if ( not visited [ i ] ) : NEW_LINE INDENT stack . append ( i ) NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT g = Graph ( 5 ) NEW_LINE g . addEdge ( 1 , 0 ) NEW_LINE g . addEdge ( 0 , 1 ) NEW_LINE g . addEdge ( 2 , 1 ) NEW_LINE g . addEdge ( 0 , 3 ) NEW_LINE g . addEdge ( 1 , 4 ) NEW_LINE g . addEdge ( 1 , 4 ) NEW_LINE print ( \" Following ▁ is ▁ the ▁ Depth ▁ First ▁ First ▁ Traversal \" ) NEW_LINE g . DFS ( 0 ) NEW_LINE g . DFS ( 0 ) NEW_LINE DEDENT"],"references":["class Graph : NEW_LINE INDENT def __init__ ( self , V ) : NEW_LINE INDENT self . V = V NEW_LINE self . adj = [ [ ] for i in range ( V ) ] NEW_LINE DEDENT def addEdge ( self , v , w ) : NEW_LINE INDENT self . adj [ v ] . append ( w ) NEW_LINE DEDENT def DFS ( self , s ) : NEW_LINE INDENT visited = [ False for i in range ( self . V ) ] NEW_LINE stack = [ ] NEW_LINE stack . append ( s ) NEW_LINE while ( len ( stack ) ) : NEW_LINE INDENT s = stack [ - 1 ] NEW_LINE stack . pop ( ) NEW_LINE if ( not visited [ s ] ) : NEW_LINE INDENT print ( s , end = ' ▁ ' ) NEW_LINE visited [ s ] = True NEW_LINE DEDENT for node in self . adj [ s ] : NEW_LINE INDENT if ( not visited [ node ] ) : NEW_LINE INDENT stack . append ( node ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT g = Graph ( 5 ) ; NEW_LINE g . addEdge ( 1 , 0 ) ; NEW_LINE g . addEdge ( 0 , 2 ) ; NEW_LINE g . addEdge ( 2 , 1 ) ; NEW_LINE g . addEdge ( 0 , 3 ) ; NEW_LINE g . addEdge ( 1 , 4 ) ; NEW_LINE print ( \" Following ▁ is ▁ Depth ▁ First ▁ Traversal \" ) NEW_LINE g . DFS ( 0 ) NEW_LINE"],"bleu":0.6606694499962708,"rouge_l":0.8403621232568602}
{"id":1427,"predictions":["class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def diagonalPrint ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return NEW_LINE DEDENT q = [ ] NEW_LINE q . append ( root ) NEW_LINE q . append ( None ) NEW_LINE while ( q != None ) : NEW_LINE INDENT temp = q [ 0 ] NEW_LINE q . pop ( 0 ) NEW_LINE if ( temp == None ) : NEW_LINE INDENT if ( len ( q ) == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT print ( ) NEW_LINE q . append ( None ) NEW_LINE DEDENT else : NEW_LINE INDENT while ( temp != None ) : NEW_LINE INDENT print ( 0 , end = \" ▁ \" ) NEW_LINE if ( temp . left ) : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE DEDENT temp = temp . right NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ main _ _ ' : NEW_LINE INDENT root = newNode ( 8 ) NEW_LINE root . left = newNode ( 3 ) NEW_LINE root . left = newNode ( 10 ) NEW_LINE root . left . right = newNode ( 1 ) NEW_LINE root . left . left . left = newNode ( 1 ) NEW_LINE root . right . right . left = newNode ( 14 ) NEW_LINE root . left . left . right = newNode ( 14 ) NEW_LINE root . right . left . right . right = newNode ( 14 ) NEW_LINE root . left . right . right = newNode ( 14 ) NEW_LINE root . left . right . right = newNode ( 7 ) NEW_LINE root . left . right . right . left = newNode ( 14 ) NEW_LINE root . left . right . right = newNode ( 7 ) NEW_LINE diagonalPrint ( root ) NEW_LINE DEDENT"],"references":["class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . val = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def diagonalprint ( root ) : NEW_LINE INDENT if root is None : NEW_LINE INDENT return NEW_LINE DEDENT q = [ ] NEW_LINE q . append ( root ) NEW_LINE q . append ( None ) NEW_LINE while len ( q ) > 0 : NEW_LINE INDENT temp = q . pop ( 0 ) NEW_LINE if not temp : NEW_LINE INDENT if len ( q ) == 0 : NEW_LINE INDENT return NEW_LINE DEDENT print ( ' ▁ ' ) NEW_LINE q . append ( None ) NEW_LINE DEDENT else : NEW_LINE INDENT while temp : NEW_LINE INDENT print ( temp . val , end = ' ▁ ' ) NEW_LINE if temp . left : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE DEDENT temp = temp . right NEW_LINE DEDENT DEDENT DEDENT DEDENT root = Node ( 8 ) NEW_LINE root . left = Node ( 3 ) NEW_LINE root . right = Node ( 10 ) NEW_LINE root . left . left = Node ( 1 ) NEW_LINE root . left . right = Node ( 6 ) NEW_LINE root . right . right = Node ( 14 ) NEW_LINE root . right . right . left = Node ( 13 ) NEW_LINE root . left . right . left = Node ( 4 ) NEW_LINE root . left . right . right = Node ( 7 ) NEW_LINE diagonalprint ( root ) NEW_LINE"],"bleu":0.5779996579976674,"rouge_l":0.8084889461257782}
{"id":1428,"predictions":["def getWinner ( arr , n ) : NEW_LINE INDENT gcd = arr [ 0 ] NEW_LINE maxEle = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT gcd = __gcd ( gcd , arr [ i ] ) NEW_LINE maxEle = max ( maxEle , arr [ i ] ) NEW_LINE DEDENT totalMoves = ( maxEle \/\/ gcd ) - n NEW_LINE if ( totalMoves % 2 == 1 ) : NEW_LINE INDENT return ' A ' NEW_LINE DEDENT return ' B ' NEW_LINE DEDENT arr = [ 5 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( getWinner ( arr , n ) ) NEW_LINE"],"references":["from math import gcd NEW_LINE def getWinner ( arr , n ) : NEW_LINE INDENT __gcd = arr [ 0 ] ; NEW_LINE maxEle = arr [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT __gcd = gcd ( __gcd , arr [ i ] ) ; NEW_LINE maxEle = max ( maxEle , arr [ i ] ) ; NEW_LINE DEDENT totalMoves = ( maxEle \/ __gcd ) - n ; NEW_LINE if ( totalMoves % 2 == 1 ) : NEW_LINE INDENT return ' A ' ; NEW_LINE DEDENT return ' B ' ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 5 , 6 , 7 ] ; NEW_LINE n = len ( arr ) NEW_LINE print ( getWinner ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.630435913654959,"rouge_l":0.839818029450497}
{"id":1429,"predictions":["def CountingEvenOdd ( arr , arr_size ) : NEW_LINE INDENT even_count = 0 NEW_LINE odd_count = 0 NEW_LINE for i in range ( 0 , arr_size ) : NEW_LINE INDENT if ( ( arr [ i ] & 1 ) : NEW_LINE INDENT odd_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even_count += 1 NEW_LINE DEDENT DEDENT print ( \" Number ▁ of ▁ even ▁ elements ▁ = \" , even_count , \" Number ▁ of ▁ odd ▁ elements ▁ = ▁ \" , odd_count ) NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE CountingEvenOdd ( arr , n ) NEW_LINE"],"references":["def CountingEvenOdd ( arr , arr_size ) : NEW_LINE INDENT even_count = 0 NEW_LINE odd_count = 0 NEW_LINE for i in range ( arr_size ) : NEW_LINE INDENT if ( arr [ i ] & 1 == 1 ) : NEW_LINE INDENT odd_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even_count += 1 NEW_LINE DEDENT DEDENT print ( \" Number ▁ of ▁ even ▁ elements ▁ = ▁ \" , even_count ) NEW_LINE print ( \" Number ▁ of ▁ odd ▁ elements ▁ = ▁ \" , odd_count ) NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE CountingEvenOdd ( arr , n ) NEW_LINE"],"bleu":0.8933668186587482,"rouge_l":0.9522193565901995}
{"id":1430,"predictions":["def findSum ( str ) : NEW_LINE INDENT temp = \" \" NEW_LINE sum = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if str [ i ] . isdigit ( ) : NEW_LINE INDENT temp += str [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT sum += int ( str [ i ] ) NEW_LINE temp = \"0\" NEW_LINE DEDENT DEDENT return int ( sum + str ) NEW_LINE DEDENT str = \"12abc20z \" NEW_LINE print ( findSum ( str ) ) NEW_LINE"],"references":["def findSum ( str1 ) : NEW_LINE INDENT temp = \" \" NEW_LINE Sum = 0 NEW_LINE for ch in str1 : NEW_LINE INDENT if ( ch . isdigit ( ) ) : NEW_LINE INDENT temp += ch NEW_LINE DEDENT else : NEW_LINE INDENT Sum += int ( temp ) NEW_LINE temp = \"0\" NEW_LINE DEDENT DEDENT return Sum + int ( temp ) NEW_LINE DEDENT str1 = \"12abc20yz68\" NEW_LINE print ( findSum ( str1 ) ) NEW_LINE"],"bleu":0.45685170360454896,"rouge_l":0.740407204385278}
{"id":1431,"predictions":["def fibonacci ( n ) : NEW_LINE INDENT f = [ 0 ] * ( n + 2 ) ; NEW_LINE f [ 0 ] = 0 ; NEW_LINE f [ 1 ] = 1 ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT f [ i ] = f [ i - 1 ] + f [ i - 2 ] ; NEW_LINE DEDENT return f [ n ] ; NEW_LINE DEDENT n = 9 ; NEW_LINE print ( fibonacci ( n ) ) ; NEW_LINE"],"references":["def fibonacci ( n ) : NEW_LINE INDENT FibArray = [ 0 , 1 ] NEW_LINE while len ( FibArray ) < n + 1 : NEW_LINE INDENT FibArray . append ( 0 ) NEW_LINE DEDENT if n <= 1 : NEW_LINE INDENT return n NEW_LINE DEDENT else : NEW_LINE INDENT if FibArray [ n - 1 ] == 0 : NEW_LINE INDENT FibArray [ n - 1 ] = fibonacci ( n - 1 ) NEW_LINE DEDENT if FibArray [ n - 2 ] == 0 : NEW_LINE INDENT FibArray [ n - 2 ] = fibonacci ( n - 2 ) NEW_LINE DEDENT DEDENT FibArray [ n ] = FibArray [ n - 2 ] + FibArray [ n - 1 ] NEW_LINE return FibArray [ n ] NEW_LINE DEDENT print ( fibonacci ( 9 ) ) NEW_LINE"],"bleu":0.1529011292947969,"rouge_l":0.4622462787550744}
{"id":1432,"predictions":["def oddNumSum ( n ) : NEW_LINE INDENT j = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT j = ( 2 * i - 1 ) NEW_LINE sum = sum + ( j * j * j ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 6 NEW_LINE print ( oddNumSum ( n ) ) NEW_LINE"],"references":["def oddNumSum ( n ) : NEW_LINE INDENT j = 0 NEW_LINE sm = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT j = ( 2 * i - 1 ) NEW_LINE sm = sm + ( j * j * j * j ) NEW_LINE DEDENT return sm NEW_LINE DEDENT n = 6 ; NEW_LINE print ( oddNumSum ( n ) ) NEW_LINE"],"bleu":0.8030487115294156,"rouge_l":0.9184618948343756}
{"id":1433,"predictions":["from math import sqrt NEW_LINE def findAandB ( N ) : NEW_LINE INDENT val = N * N - 4.0 * N ; NEW_LINE if ( val < 0 ) : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE return ; NEW_LINE DEDENT a = ( N + sqrt ( val ) ) \/ 2.0 ; NEW_LINE b = ( N - sqrt ( val ) ) \/ 2.0 ; NEW_LINE print ( \" a ▁ = \" , a ) ; NEW_LINE print ( \" b ▁ = ▁ \" , b ) ; NEW_LINE print ( \" b ▁ = ▁ \" , b ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 69.0 ; NEW_LINE findAandB ( N ) ; NEW_LINE DEDENT"],"references":["from math import sqrt NEW_LINE def findAandB ( N ) : NEW_LINE INDENT val = N * N - 4.0 * N NEW_LINE if ( val < 0 ) : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE return NEW_LINE DEDENT a = ( N + sqrt ( val ) ) \/ 2.0 NEW_LINE b = ( N - sqrt ( val ) ) \/ 2.0 NEW_LINE print ( \" a ▁ = \" , ' { 0 : . 6 } ' . format ( a ) ) NEW_LINE print ( \" b ▁ = \" , ' { 0 : . 6 } ' . format ( b ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 69.0 NEW_LINE findAandB ( N ) NEW_LINE DEDENT"],"bleu":0.7004500158292737,"rouge_l":0.8358155605862028}
{"id":1434,"predictions":["def reverse ( st ) : NEW_LINE INDENT r = len ( st ) - 1 NEW_LINE l = 0 NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( st [ l ] . isalpha ( ) ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT elif ( st [ r ] . isalpha ( ) ) : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT tmp = st [ l ] NEW_LINE st [ l ] = st [ r ] NEW_LINE l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT st = \" a ! \" NEW_LINE l = 0 NEW_LINE while ( l < r . diri ( ) ) : NEW_LINE INDENT st = st [ l ] NEW_LINE st [ l ] = st [ r ] NEW_LINE l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT DEDENT"],"references":["def reverseSting ( text ) : NEW_LINE INDENT index = - 1 NEW_LINE for i in range ( len ( text ) - 1 , int ( len ( text ) \/ 2 ) , - 1 ) : NEW_LINE INDENT if text [ i ] . isalpha ( ) : NEW_LINE INDENT temp = text [ i ] NEW_LINE while True : NEW_LINE INDENT index += 1 NEW_LINE if text [ index ] . isalpha ( ) : NEW_LINE INDENT text [ i ] = text [ index ] NEW_LINE text [ index ] = temp NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT return text NEW_LINE DEDENT string = \" a ! ! ! b . c . d , e ' f , ghi \" NEW_LINE print ( \" Input ▁ string : ▁ \" , string ) NEW_LINE string = reverseSting ( list ( string ) ) NEW_LINE print ( \" Output ▁ string : ▁ \" , \" \" . join ( string ) ) NEW_LINE"],"bleu":0.1959242131995168,"rouge_l":0.3939334637964775}
{"id":1435,"predictions":["import math NEW_LINE def geometricMean ( n ) : NEW_LINE INDENT return math . sqrt ( n ) NEW_LINE DEDENT n = 16 NEW_LINE print ( geometricMean ( n ) ) NEW_LINE"],"references":["from math import sqrt NEW_LINE def geometricMean ( n ) : NEW_LINE INDENT return int ( sqrt ( n ) ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 16 ; NEW_LINE print ( geometricMean ( n ) ) ; NEW_LINE DEDENT"],"bleu":0.3500674651082214,"rouge_l":0.6620508982035929}
{"id":1436,"predictions":["def kPresentProbability ( a , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == k : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count \/ n NEW_LINE DEDENT A = [ 4 , 7 , 2 , 0 , 8 , 7 , 5 ] NEW_LINE K = 2 NEW_LINE N = len ( A ) NEW_LINE n = kPresentProbability ( A , N , K ) NEW_LINE p = round ( n * 100 ) \/ 100 NEW_LINE print ( p ) NEW_LINE"],"references":["def kPresentProbability ( a , n , k ) : NEW_LINE INDENT count = a . count ( k ) NEW_LINE return round ( count \/ n , 2 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 4 , 7 , 2 , 0 , 8 , 7 , 5 ] NEW_LINE K = 2 NEW_LINE N = len ( A ) NEW_LINE print ( kPresentProbability ( A , N , K ) ) NEW_LINE DEDENT"],"bleu":0.5397114342724258,"rouge_l":0.6704466154919749}
{"id":1437,"predictions":["def checkEvenOdd ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if arr [ i ] % 2 == 0 : NEW_LINE INDENT print ( \" Even \" , end = \" \" ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( \" Odd \" ) NEW_LINE DEDENT arr = [ 2 , 12 , 20 , 36 , 38 ] NEW_LINE n = len ( arr ) NEW_LINE checkEvenOdd ( arr , n ) NEW_LINE"],"references":["def checkEvenOdd ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT print ( \" Even \" , end = \" \" ) ; NEW_LINE return ; NEW_LINE DEDENT DEDENT print ( \" Odd \" , end = \" \" ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 12 , 20 , 36 , 38 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE checkEvenOdd ( arr , n ) ; NEW_LINE DEDENT"],"bleu":0.6080834601761833,"rouge_l":0.8405511811023623}
{"id":1438,"predictions":["def toggleLastMBits ( n , m ) : NEW_LINE INDENT if ( m == 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT num = ( 1 << m ) - 1 NEW_LINE return ( n ^ num ) NEW_LINE DEDENT def largestNumWithNSetAndMUnsetBits ( n , m ) : NEW_LINE INDENT num = ( 1 << ( n + m ) ) - 1 NEW_LINE return toggleLastMBits ( num , m ) NEW_LINE DEDENT n = 2 NEW_LINE m = 2 NEW_LINE print ( largestNumWithNSetAndMUnsetBits ( n , m ) ) NEW_LINE"],"references":["def toggleLastMBits ( n , m ) : NEW_LINE INDENT if ( m == 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT num = ( 1 << m ) - 1 NEW_LINE return ( n ^ num ) NEW_LINE DEDENT def largeNumWithNSetAndMUnsetBits ( n , m ) : NEW_LINE INDENT num = ( 1 << ( n + m ) ) - 1 NEW_LINE return toggleLastMBits ( num , m ) NEW_LINE DEDENT n = 2 NEW_LINE m = 2 NEW_LINE print ( largeNumWithNSetAndMUnsetBits ( n , m ) ) NEW_LINE"],"bleu":0.9447144130502939,"rouge_l":0.9782608695652174}
{"id":1439,"predictions":["def series ( A , X , n ) : NEW_LINE INDENT term = pow ( A , n ) NEW_LINE print ( term , end = \" ▁ \" ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT tmp = term * X * ( n - i + 1 ) \/ ( i * A ) NEW_LINE print ( tmp , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT A = 3 NEW_LINE X = 4 NEW_LINE n = 5 NEW_LINE series ( A , X , n ) NEW_LINE"],"references":["def series ( A , X , n ) : NEW_LINE INDENT term = pow ( A , n ) NEW_LINE print ( term , end = \" ▁ \" ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT term = int ( term * X * ( n - i + 1 ) \/ ( i * A ) ) NEW_LINE print ( term , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT A = 3 ; X = 4 ; n = 5 NEW_LINE series ( A , X , n ) NEW_LINE"],"bleu":0.8558354869835405,"rouge_l":0.9432989690721648}
{"id":1440,"predictions":["def merge ( arr , l , m , r ) : NEW_LINE INDENT n1 = m - l + 1 NEW_LINE n2 = r - m NEW_LINE R = [ 0 for i in range ( n1 ) ] NEW_LINE R = [ 0 for i in range ( n2 ) ] NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT L [ i ] = arr [ l + i ] NEW_LINE DEDENT for j in range ( n2 ) : NEW_LINE INDENT R [ j ] = arr [ l + 1 + 1 NEW_LINE DEDENT i = 0 NEW_LINE j = 0 NEW_LINE k = l NEW_LINE while ( i < n1 and j < n2 ) : NEW_LINE INDENT if ( L [ i ] <= R [ j ] ) : NEW_LINE INDENT arr [ k ] = L [ i ] NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ k ] = R [ j ] NEW_LINE j += 1 NEW_LINE DEDENT k += 1 NEW_LINE DEDENT while ( i < n1 ) : NEW_LINE INDENT arr [ k ] = L [ i ] NEW_LINE i += 1 NEW_LINE k += 1 NEW_LINE DEDENT while ( j < n1 ) : NEW_LINE INDENT arr [ k ] = R [ j ] NEW_LINE i += 1 NEW_LINE k += 1 NEW_LINE DEDENT while ( j < n2 ) : NEW_LINE INDENT arr [ k ] = R [ j ] NEW_LINE j += 1 NEW_LINE k += 1 NEW_LINE DEDENT DEDENT while ( j < n2 ) : NEW_LINE INDENT arr [ k ] = R [ j ] NEW_LINE j += 1 NEW_LINE k += 1 NEW_LINE DEDENT DEDENT def sort ( arr , l , r ) : NEW_LINE INDENT if ( l < r ) : NEW_LINE INDENT m = ( l + r ) \/\/ 2 NEW_LINE DEDENT arr . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE D"],"references":["def mergeSort ( a ) : NEW_LINE INDENT if len ( a ) > 1 : NEW_LINE INDENT mid = len ( a ) \/\/ 2 NEW_LINE L = a [ : mid ] NEW_LINE R = a [ mid : ] NEW_LINE mergeSort ( L ) NEW_LINE mergeSort ( R ) NEW_LINE a . clear ( ) NEW_LINE while len ( L ) > 0 and len ( R ) < 0 : NEW_LINE INDENT if L [ 0 ] <= R [ 0 ] : NEW_LINE INDENT a . append ( L [ 0 ] ) NEW_LINE L . pop ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT a . append ( R [ 0 ] ) NEW_LINE R . pop ( 0 ) NEW_LINE DEDENT DEDENT for i in L : NEW_LINE INDENT a . append ( i ) NEW_LINE DEDENT for i in R : NEW_LINE INDENT a . append ( i ) NEW_LINE DEDENT DEDENT DEDENT a = [ 12 , 11 , 13 , 5 , 6 , 7 ] NEW_LINE print ( \" Given ▁ array ▁ is \" ) NEW_LINE print ( * a ) NEW_LINE mergeSort ( a ) NEW_LINE print ( \" Sorted ▁ array ▁ is ▁ : ▁ \" ) NEW_LINE print ( * a ) NEW_LINE"],"bleu":0.11558906477322123,"rouge_l":0.3630524454920448}
{"id":1441,"predictions":["def answer ( arr , ranges , reversals , index ) : NEW_LINE INDENT for i in range ( reversals - 1 , - 1 ) : NEW_LINE INDENT left = ranges [ i ] [ 0 ] NEW_LINE right = ranges [ i ] [ 1 ] NEW_LINE if ( left <= index and right >= index ) : NEW_LINE INDENT index = right + left - index NEW_LINE DEDENT DEDENT return arr [ index ] NEW_LINE DEDENT arr = [ 10 , 20 , 30 , 40 , 50 ] NEW_LINE reversals = 2 NEW_LINE ranges = [ [ 1 , 4 ] , [ 0 , 2 ] ] NEW_LINE index = 1 NEW_LINE print ( answer ( arr , ranges , reversals , index ) ) NEW_LINE"],"references":["def answer ( arr , ranges , reversals , index ) : NEW_LINE INDENT i = reversals - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT left = ranges [ i ] [ 0 ] NEW_LINE right = ranges [ i ] [ 1 ] NEW_LINE if ( left <= index and right >= index ) : NEW_LINE INDENT index = right + left - index NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT return arr [ index ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 10 , 20 , 30 , 40 , 50 ] NEW_LINE reversals = 2 NEW_LINE ranges = [ [ 1 , 4 ] , [ 0 , 2 ] ] NEW_LINE index = 1 NEW_LINE print ( answer ( arr , ranges , reversals , index ) ) NEW_LINE DEDENT"],"bleu":0.7819012088935867,"rouge_l":0.8755643014237758}
{"id":1442,"predictions":["def isDivisibleBy25 ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return ( ( ( ( ord [ n - 1 ] ) - '0' == 0 and str [ n - 2 ] == 0 ) or ( ( ord ( str [ n - 2 ] ) - ord ( str [ n - 2 ] ) ) * 10 + ( ord ( str [ n - 1 ] ) - ord ( '0' ) ) ) % 25 == 0 ) ) NEW_LINE DEDENT DEDENT str = \"76955\" NEW_LINE if ( isDivisibleBy25 ( str ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def isDivisibleBy25 ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return ( ( int ) ( st [ n - 1 ] ) == 0 and ( ( int ) ( st [ n - 2 ] ) == 0 ) or ( ( int ) ( st [ n - 2 ] ) * 10 + ( int ) ( st [ n - 1 ] ) % 25 == 0 ) ) NEW_LINE DEDENT st = \"76955\" NEW_LINE if ( isDivisibleBy25 ( st ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.6459861002757232,"rouge_l":0.8200542673902318}
{"id":1443,"predictions":["def square ( n ) : NEW_LINE INDENT return n * n NEW_LINE DEDENT def sum ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return square ( n + 1 ) \/\/ 2 + sum ( n \/\/ 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return square ( n \/\/ 2 ) + sum ( n \/\/ 2 ) NEW_LINE DEDENT DEDENT def oddDivSum ( a , b ) : NEW_LINE INDENT return sum ( b ) - sum ( a - 1 ) NEW_LINE DEDENT a = 3 NEW_LINE b = 9 NEW_LINE print ( oddDivSum ( a , b ) ) NEW_LINE"],"references":["def square ( n ) : NEW_LINE INDENT return n * n ; NEW_LINE DEDENT def sum ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return ( square ( int ( ( n + 1 ) \/ 2 ) ) + sum ( int ( n \/ 2 ) ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return ( square ( int ( n \/ 2 ) ) + sum ( int ( n \/ 2 ) ) ) ; NEW_LINE DEDENT DEDENT def oddDivSum ( a , b ) : NEW_LINE INDENT return sum ( b ) - sum ( a - 1 ) ; NEW_LINE DEDENT a , b = 3 , 9 ; NEW_LINE print ( oddDivSum ( a , b ) ) ; NEW_LINE"],"bleu":0.6172238906472438,"rouge_l":0.8465363709957212}
{"id":1444,"predictions":["def removeOddFrequencyCharacters ( s ) : NEW_LINE INDENT m = dict ( ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT p = s [ i ] NEW_LINE count = m [ p ] NEW_LINE if ( count is not None ) : NEW_LINE INDENT count = 0 NEW_LINE DEDENT else : NEW_LINE INDENT m [ p ] = count + 1 NEW_LINE DEDENT DEDENT new_string = \" \" NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( m [ s [ i ] ] & 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT new_string += s [ i ] NEW_LINE DEDENT return new_string NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeksforgeeks \" NEW_LINE str = removeOddFrequency ( str ) NEW_LINE print ( str ) NEW_LINE DEDENT"],"references":["def removeOddFrequencyCharacters ( s ) : NEW_LINE INDENT m = dict ( ) NEW_LINE for i in s : NEW_LINE INDENT m [ i ] = m . get ( i , 0 ) + 1 NEW_LINE DEDENT new_s = \" \" NEW_LINE for i in s : NEW_LINE INDENT if ( m [ i ] & 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT new_s += i NEW_LINE DEDENT return new_s NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" geeksforgeeks \" NEW_LINE str = removeOddFrequencyCharacters ( str ) NEW_LINE print ( str ) NEW_LINE DEDENT"],"bleu":0.47552142555434385,"rouge_l":0.7553681991832432}
{"id":1445,"predictions":["def countNonDecreasing ( n ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( 10 ) ] for y in range ( 10 ) ] NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT dp [ i ] [ 1 ] = 1 NEW_LINE DEDENT for digit in range ( 10 ) : NEW_LINE INDENT dp [ digit ] [ len ] = 1 NEW_LINE DEDENT for digit in range ( 10 ) : NEW_LINE INDENT for l in range ( 2 , n + 1 ) : NEW_LINE INDENT dp [ digit ] [ l ] += dp [ x ] [ l ] NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT count += dp [ i ] [ n ] NEW_LINE DEDENT return count NEW_LINE DEDENT n = 3 NEW_LINE print ( countNonDecreasing ( n ) ) NEW_LINE"],"references":["def countNonDecreasing ( n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n + 1 ) ] for i in range ( 10 ) ] NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT dp [ i ] [ 1 ] = 1 NEW_LINE DEDENT for digit in range ( 10 ) : NEW_LINE INDENT for len in range ( 2 , n + 1 ) : NEW_LINE INDENT for x in range ( digit + 1 ) : NEW_LINE INDENT dp [ digit ] [ len ] += dp [ x ] [ len - 1 ] NEW_LINE DEDENT DEDENT DEDENT count = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT count += dp [ i ] [ n ] NEW_LINE DEDENT return count NEW_LINE DEDENT n = 3 NEW_LINE print ( countNonDecreasing ( n ) ) NEW_LINE"],"bleu":0.8172732066268765,"rouge_l":0.8713349801310277}
{"id":1446,"predictions":["def maxCount ( n , a ) : NEW_LINE INDENT freq = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ a [ i ] ] = freq . get ( a [ i ] , 0 ) + 1 NEW_LINE DEDENT ans = 0 NEW_LINE for key in freq . keys ( ) : NEW_LINE INDENT if ( key + 1 ) in freq . keys ( ) : NEW_LINE INDENT ans = max ( ans , freq [ key ] + freq [ key + 1 ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT n = 5 NEW_LINE arr = [ 2 , 2 , 3 , 4 , 5 ] NEW_LINE print ( maxCount ( n , arr ) ) NEW_LINE"],"references":["def maxCount ( a ) : NEW_LINE INDENT freq = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] in freq ) : NEW_LINE INDENT freq [ a [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ a [ i ] ] = 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for key , value in freq . items ( ) : NEW_LINE INDENT if ( key + 1 in freq ) : NEW_LINE INDENT ans = max ( ans , freq [ key ] + freq [ key + 1 ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT n = 5 NEW_LINE arr = [ 2 , 2 , 3 , 4 , 5 ] NEW_LINE print ( maxCount ( arr ) ) NEW_LINE"],"bleu":0.6993168908839704,"rouge_l":0.8156638013371538}
{"id":1447,"predictions":["import math NEW_LINE def dist ( x1 , y1 , x2 , y2 , r ) : NEW_LINE INDENT print ( \" The ▁ shortest ▁ distance ▁ between ▁ a ▁ and ▁ a ▁ circle ▁ is ▁ \" , math . sqrt ( ( ( ( 2 - x1 ) , 2 ) ) + ( math . sqrt ( ( 2 - x1 ) , 2 ) ) ) - 1 NEW_LINE DEDENT x1 = 4 NEW_LINE y1 = 6 NEW_LINE x2 = 30 NEW_LINE x2 = 30 NEW_LINE x2 = 30 NEW_LINE r = 0 NEW_LINE dist ( x1 , y1 , 2 , y2 , r ) NEW_LINE"],"references":["def dist ( x1 , y1 , x2 , y2 , r ) : NEW_LINE INDENT print ( \" The ▁ shortest ▁ distance ▁ between ▁ a ▁ point ▁ and ▁ a ▁ circle ▁ is ▁ \" , ( ( ( ( x2 - x1 ) ** 2 ) + ( ( y2 - y1 ) ** 2 ) ) ** ( 1 \/ 2 ) ) - r ) ; NEW_LINE DEDENT x1 = 4 ; NEW_LINE y1 = 6 ; NEW_LINE x2 = 35 ; NEW_LINE y2 = 42 ; NEW_LINE r = 5 ; NEW_LINE dist ( x1 , y1 , x2 , y2 , r ) ; NEW_LINE"],"bleu":0.5721282039654497,"rouge_l":0.7679542203147354}
{"id":1448,"predictions":["def dfs ( x , adj ) : NEW_LINE INDENT sz = 1 NEW_LINE vis [ x ] = 1 NEW_LINE for i in range ( len ( adj [ x ] ) ) : NEW_LINE INDENT if ( vis [ adj [ x ] [ i ] == 0 ) : NEW_LINE INDENT sz += dfs ( adj [ x ] [ i ] , adj ) NEW_LINE DEDENT DEDENT return sz NEW_LINE DEDENT def maxValue ( n , adj ) : NEW_LINE INDENT val = 0 NEW_LINE vis = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT vis [ i ] = 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( vis [ i ] == 0 ) : NEW_LINE INDENT val += dfs ( i , adj ) - 1 NEW_LINE DEDENT DEDENT return val NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE adj = [ 0 ] NEW_LINE adj = [ 0 for i in range ( n ) ] NEW_LINE v1 = [ 0 for i in range ( n ) ] NEW_LINE v1 . append ( 1 ) NEW_LINE adj . append ( [ 1 ] ) NEW_LINE adj . append ( [ 1 ] ) NEW_LINE adj . append ( [ 2 ] ) NEW_LINE adj . append ( [ 2 ] ) NEW_LINE adj . append ( [ 1 ] ) NEW_LINE print ( maxValue ( n , adj ) ) NEW_LINE DEDENT"],"references":["def dfs ( x , adj , vis ) : NEW_LINE INDENT sz = 1 NEW_LINE vis [ x ] = 1 NEW_LINE for ch in adj : NEW_LINE INDENT if ( not vis [ ch ] ) : NEW_LINE INDENT sz += dfs ( ch , adj , vis ) NEW_LINE DEDENT DEDENT return sz NEW_LINE DEDENT def maxValue ( n , adj ) : NEW_LINE INDENT val = 0 NEW_LINE vis = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( not vis [ i ] ) : NEW_LINE INDENT val += dfs ( i , adj , vis ) - 1 NEW_LINE DEDENT DEDENT return val NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE adj = [ 1 , 2 , 2 , 3 ] NEW_LINE print ( maxValue ( n , adj ) ) NEW_LINE DEDENT"],"bleu":0.43413267840988257,"rouge_l":0.6870970247805485}
{"id":1449,"predictions":["from math import sqrt NEW_LINE def area_of_rectgon ( n , lenn ) : NEW_LINE INDENT P = ( l * n ) NEW_LINE A = l \/\/ ( 2 * tan ( ( 180 \/ n ) * 3.14159 \/ 180 ) ) NEW_LINE area = ( P * A ) \/ 2 NEW_LINE return area NEW_LINE DEDENT def area_of_triangle_ips ( n , le ) : NEW_LINE INDENT area = area_of_tight ( n , le ) NEW_LINE triangle = area \/\/ n NEW_LINE ins_tri = ( triangle * 3 ) NEW_LINE return st_tri NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 6 NEW_LINE lenn = 10 NEW_LINE print ( area_of_triangle_ips ( n , lenn ) ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def area_of_regular_polygon ( n , len ) : NEW_LINE INDENT P = ( len * n ) ; NEW_LINE A = len \/ ( 2 * math . tan ( ( 180 \/ n ) * 3.14159 \/ 180 ) ) NEW_LINE area = ( P * A ) \/ 2 NEW_LINE return area NEW_LINE DEDENT def area_of_triangle_inscribed ( n , len ) : NEW_LINE INDENT area = area_of_regular_polygon ( n , len ) NEW_LINE triangle = area \/ n NEW_LINE ins_tri = ( triangle * 3 ) ; NEW_LINE return ins_tri NEW_LINE DEDENT n = 6 NEW_LINE len = 10 NEW_LINE print ( round ( area_of_triangle_inscribed ( n , len ) , 3 ) ) NEW_LINE"],"bleu":0.5328408942016615,"rouge_l":0.7813208805870581}
{"id":1450,"predictions":["def centeredHexagonalNumber ( n ) : NEW_LINE INDENT return ( 3 * n * ( n - 1 ) + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE print ( n , \" th ▁ centered ▁ number : ▁ \" , centeredH hexagonalNumber ( n ) ) NEW_LINE DEDENT"],"references":["def centeredHexagonalNumber ( n ) : NEW_LINE INDENT return 3 * n * ( n - 1 ) + 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE print ( n , \" th ▁ centered ▁ hexagonal ▁ number : ▁ \" , centeredHexagonalNumber ( n ) ) NEW_LINE DEDENT"],"bleu":0.8479227922589185,"rouge_l":0.945363803519832}
{"id":1451,"predictions":["def isOrthogonal ( a , m , n ) : NEW_LINE INDENT if ( m != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for k in range ( n ) : NEW_LINE INDENT sum = sum + ( a [ i ] * a [ k ] * a [ j , k ] ) NEW_LINE DEDENT if ( i == j and sum != 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( i != j and sum != 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT a = [ [ 1 , 0 , 0 ] , [ 0 , 1 , 0 ] , [ 0 , 0 , 1 ] ] NEW_LINE if ( isOrthogonal ( a , 3 , 3 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def isOrthogonal ( a , m , n ) : NEW_LINE INDENT if ( m != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for k in range ( 0 , n ) : NEW_LINE INDENT sum = sum + ( a [ i ] [ k ] * a [ j ] [ k ] ) NEW_LINE DEDENT DEDENT if ( i == j and sum != 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( i != j and sum != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT a = [ [ 1 , 0 , 0 ] , [ 0 , 1 , 0 ] , [ 0 , 0 , 1 ] ] NEW_LINE if ( isOrthogonal ( a , 3 , 3 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.8995803954928541,"rouge_l":0.9556135770234986}
{"id":1452,"predictions":["def getAvg ( prev_avg , x , n ) : NEW_LINE INDENT return ( prev_avg * n + x ) \/ ( n + 1 ) NEW_LINE DEDENT def streamAvg ( arr , n ) : NEW_LINE INDENT avg = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT avg = getAvg ( avg , arr [ i ] , i ) NEW_LINE print ( \" Maximum ▁ of \" , arr [ i ] , \" numbers ▁ is \" , avg ) NEW_LINE DEDENT DEDENT arr = [ 10 , 10 , 30 , 40 , 54 ] NEW_LINE n = len ( arr ) NEW_LINE getAvg ( arr , n ) NEW_LINE"],"references":["def getAvg ( prev_avg , x , n ) : NEW_LINE INDENT return ( ( prev_avg * n + x ) \/ ( n + 1 ) ) ; NEW_LINE DEDENT def streamAvg ( arr , n ) : NEW_LINE INDENT avg = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT avg = getAvg ( avg , arr [ i ] , i ) ; NEW_LINE print ( \" Average ▁ of ▁ \" , i + 1 , \" ▁ numbers ▁ is ▁ \" , avg ) ; NEW_LINE DEDENT DEDENT arr = [ 10 , 20 , 30 , 40 , 50 , 60 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE streamAvg ( arr , n ) ; NEW_LINE"],"bleu":0.6718417128951204,"rouge_l":0.8832507174536918}
{"id":1453,"predictions":["import sys NEW_LINE def costOfOperation ( n , h , cost , q ) : NEW_LINE INDENT c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT c += abs ( h [ i ] - q ) * cost [ i ] NEW_LINE DEDENT return c NEW_LINE DEDENT def Bsearch ( n , h , cost ) : NEW_LINE INDENT max_h = max ( h ) NEW_LINE ans = sys . maxsize NEW_LINE high = 1 + max_h NEW_LINE low = 1 + max_h NEW_LINE low = 0 NEW_LINE while ( high > low ) : NEW_LINE INDENT mid = ( low + high ) >> 1 NEW_LINE bm = costOfOperation ( n , h , cost , mid - 1 ) if ( mid > 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT m = costOfOperation ( n , h , cost , mid ) NEW_LINE m = costOfOperation ( n , h , cost , mid + 1 ) NEW_LINE m = costOfOperation ( n , h , cost , mid + 1 ) NEW_LINE if ( ans == m ) : NEW_LINE INDENT break NEW_LINE DEDENT ans = min ( ans , m ) NEW_LINE if ( bm <= m ) : NEW_LINE INDENT high = mid NEW_LINE DEDENT else : NEW_LINE INDENT return m NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT h = [ 1 , 2 , 3 ] NEW_LINE cost = [ 10 , 100 , 1000 ] NEW_LINE n = len ( h ) NEW_LINE print ( Bsearch ( n , h , cost ) ) NEW_LINE"],"references":["import sys NEW_LINE def costOfOperation ( n , h , cost , eq_h ) : NEW_LINE INDENT c = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT c += abs ( h [ i ] - eq_h ) * cost [ i ] NEW_LINE DEDENT return c NEW_LINE DEDENT def Bsearch ( n , h , cost ) : NEW_LINE INDENT max_h = h [ 0 ] NEW_LINE for i in range ( len ( h ) ) : NEW_LINE INDENT if ( h [ i ] > max_h ) : NEW_LINE INDENT max_h = h [ i ] NEW_LINE DEDENT DEDENT ans = sys . maxsize NEW_LINE high = 1 + max_h NEW_LINE low = 0 NEW_LINE while ( high > low ) : NEW_LINE INDENT mid = ( low + high ) >> 1 NEW_LINE if ( mid > 0 ) : NEW_LINE INDENT bm = costOfOperation ( n , h , cost , mid - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT bm = sys . maxsize NEW_LINE DEDENT m = costOfOperation ( n , h , cost , mid ) NEW_LINE am = costOfOperation ( n , h , cost , mid + 1 ) NEW_LINE if ( ans == m ) : NEW_LINE INDENT break NEW_LINE DEDENT ans = min ( ans , m ) NEW_LINE if ( bm <= m ) : NEW_LINE INDENT high = mid NEW_LINE DEDENT elif ( am <= m ) : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return m ; NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT h = [ 1 , 2 , 3 ] NEW_LINE cost = [ 10 , 100 , 1000 ] NEW_LINE n = len ( h ) NEW_LINE print ( Bsearch ( n , h , cost ) ) NEW_LINE DEDENT"],"bleu":0.6885496246814955,"rouge_l":0.7881818673298372}
{"id":1454,"predictions":["def check ( a , n ) : NEW_LINE INDENT for i in a : NEW_LINE INDENT if ( a [ i ] == 1 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT return False ; NEW_LINE DEDENT a = [ 0 , 1 , 0 , 1 ] ; NEW_LINE n = len ( a ) ; NEW_LINE if ( check ( a , n ) ) : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE DEDENT"],"references":["def check ( a , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 0 , 1 , 0 , 1 ] NEW_LINE n = len ( a ) NEW_LINE if ( check ( a , n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.6925162283041304,"rouge_l":0.8573296290243503}
{"id":1455,"predictions":["def findIndex ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT a = 0 NEW_LINE b = 1 NEW_LINE c = 1 NEW_LINE res = 1 NEW_LINE while ( c < n ) : NEW_LINE INDENT c = a + b NEW_LINE res += 1 NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT result = findIndex ( 21 ) NEW_LINE print ( result ) NEW_LINE DEDENT"],"references":["def findIndex ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT a = 0 NEW_LINE b = 1 NEW_LINE c = 1 NEW_LINE res = 1 NEW_LINE while ( c < n ) : NEW_LINE INDENT c = a + b NEW_LINE res = res + 1 NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return res NEW_LINE DEDENT result = findIndex ( 21 ) NEW_LINE print ( result ) NEW_LINE"],"bleu":0.808801476167757,"rouge_l":0.9099384672757784}
{"id":1456,"predictions":["def sumNth ( A , B , m , n ) : NEW_LINE INDENT res = 0 NEW_LINE if ( n == 1 ) : NEW_LINE INDENT for i in range ( m ) : NEW_LINE INDENT res = res + A [ i ] NEW_LINE DEDENT DEDENT elif ( n == 2 ) : NEW_LINE INDENT for i in range ( m ) : NEW_LINE INDENT res = res + B [ i ] * m NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT f = [ 0 ] * n NEW_LINE f [ 0 ] = 0 NEW_LINE f [ 1 ] = 1 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT f [ i ] = f [ i - 1 ] + f [ i - 2 ] NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT res = res + ( m * ( B [ i ] * f [ n - 1 ] ) ) + ( m * ( A [ i ] * f [ n - 2 ] ) ) ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT A = [ 1 , 2 , 3 ] NEW_LINE B = [ 4 , 5 , 6 ] NEW_LINE n = len ( A ) NEW_LINE print ( sumNth ( A , B , m , n ) ) NEW_LINE"],"references":["def sumNth ( A , B , m , n ) : NEW_LINE INDENT res = 0 ; NEW_LINE if ( n == 1 ) : NEW_LINE INDENT for i in range ( m ) : NEW_LINE INDENT res = res + A [ i ] ; NEW_LINE DEDENT DEDENT elif ( n == 2 ) : NEW_LINE INDENT for i in range ( m ) : NEW_LINE INDENT res = res + B [ i ] * m ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT f = [ 0 ] * n ; NEW_LINE f [ 0 ] = 0 ; NEW_LINE f [ 1 ] = 1 ; NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT f [ i ] = f [ i - 1 ] + f [ i - 2 ] ; NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT res = ( res + ( m * ( B [ i ] * f [ n - 1 ] ) ) + ( m * ( A [ i ] * f [ n - 2 ] ) ) ) ; NEW_LINE DEDENT DEDENT return res ; NEW_LINE DEDENT A = [ 1 , 2 , 3 ] ; NEW_LINE B = [ 4 , 5 , 6 ] ; NEW_LINE n = 3 ; NEW_LINE m = len ( A ) ; NEW_LINE print ( sumNth ( A , B , m , n ) ) ; NEW_LINE"],"bleu":0.837804753734605,"rouge_l":0.9546419098143238}
{"id":1457,"predictions":["def isVowel ( c ) : NEW_LINE INDENT return ( c == ' a ' or c == ' e ' or c == ' E ' or c == ' I ' or c == ' I ' or c == ' O ' or c == ' O ' or c == ' U ' ) ; NEW_LINE DEDENT def reverseVowel ( str1 ) : NEW_LINE INDENT j = 0 ; NEW_LINE str1 = \" \" ; NEW_LINE vowel = \" \" ; NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT if ( isVowel ( str1 [ i ] ) ) : NEW_LINE INDENT j += 1 ; NEW_LINE vowel += str [ i ] ; NEW_LINE DEDENT DEDENT for i in range ( len ( str1 ) ) : NEW_LINE INDENT if ( isVowel ( str1 [ i ] ) ) : NEW_LINE INDENT str1 [ i ] = vowel [ j ] ; NEW_LINE DEDENT DEDENT return str ; NEW_LINE DEDENT str = \" hello \" ; NEW_LINE print ( reverseVowel ( str1 ) ) ; NEW_LINE"],"references":["def isVowel ( c ) : NEW_LINE INDENT if ( c == ' a ' or c == ' A ' or c == ' e ' or c == ' E ' or c == ' i ' or c == ' I ' or c == ' o ' or c == ' O ' or c == ' u ' or c == ' U ' ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def reverserVowel ( string ) : NEW_LINE INDENT j = 0 NEW_LINE vowel = [ 0 ] * len ( string ) NEW_LINE string = list ( string ) NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if isVowel ( string [ i ] ) : NEW_LINE INDENT vowel [ j ] = string [ i ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT for i in range ( len ( string ) ) : NEW_LINE INDENT if isVowel ( string [ i ] ) : NEW_LINE INDENT j -= 1 NEW_LINE string [ i ] = vowel [ j ] NEW_LINE DEDENT DEDENT return ' ' . join ( string ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" hello ▁ world \" NEW_LINE print ( reverserVowel ( string ) ) NEW_LINE DEDENT"],"bleu":0.47512327157178175,"rouge_l":0.6902470941420983}
{"id":1458,"predictions":["def minimumCost ( cost , n ) : NEW_LINE INDENT dp1 = 0 NEW_LINE dp2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp0 = cost [ i ] + min ( dp1 , dp2 ) NEW_LINE dp2 = dp1 NEW_LINE DEDENT return min ( dp1 , dp2 ) NEW_LINE DEDENT a = [ 2 , 5 , 3 , 1 , 7 , 3 , 4 ] NEW_LINE n = len ( a ) NEW_LINE print ( minimumCost ( a , n ) ) NEW_LINE"],"references":["def minimumCost ( cost , n ) : NEW_LINE INDENT dp1 = 0 NEW_LINE dp2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp0 = cost [ i ] + min ( dp1 , dp2 ) NEW_LINE dp2 = dp1 NEW_LINE dp1 = dp0 NEW_LINE DEDENT return min ( dp1 , dp2 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 2 , 5 , 3 , 1 , 7 , 3 , 4 ] NEW_LINE n = len ( a ) NEW_LINE print ( minimumCost ( a , n ) ) NEW_LINE DEDENT"],"bleu":0.7997189404425046,"rouge_l":0.8954670108081948}
{"id":1459,"predictions":["N = 2 NEW_LINE def isVowel ( ch ) : NEW_LINE INDENT return ( ch == ' a ' or ch == ' e ' or ch == ' o ' or ch == ' u ' ) NEW_LINE DEDENT def countVowels ( str1 , l , r ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if ( isVowel ( str1 [ i ] ) ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT def performQueries ( str1 , queries , q ) : NEW_LINE INDENT for i in range ( q ) : NEW_LINE INDENT print ( countVowels ( str1 , queries [ i ] [ 0 ] , queries [ i ] [ 1 ] ) ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" geeksforgeeks \" NEW_LINE queries = [ [ 1 , 3 ] , [ 2 , 4 ] , [ 1 , 9 ] ] NEW_LINE q = len ( queries ) NEW_LINE performQueries ( str1 , queries , q ) NEW_LINE DEDENT"],"references":["N = 2 ; NEW_LINE def isVowel ( ch ) : NEW_LINE INDENT return ( ch == ' a ' or ch == ' e ' or ch == ' i ' or ch == ' o ' or ch == ' u ' ) ; NEW_LINE DEDENT def countVowels ( string , l , r ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if ( isVowel ( string [ i ] ) ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT return cnt ; NEW_LINE DEDENT def performQueries ( string , queries , q ) : NEW_LINE INDENT for i in range ( q ) : NEW_LINE INDENT print ( countVowels ( string , queries [ i ] [ 0 ] , queries [ i ] [ 1 ] ) ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" geeksforgeeks \" ; NEW_LINE queries = [ [ 1 , 3 ] , [ 2 , 4 ] , [ 1 , 9 ] ] ; NEW_LINE q = len ( queries ) NEW_LINE performQueries ( string , queries , q ) ; NEW_LINE DEDENT"],"bleu":0.7911778739400324,"rouge_l":0.9285432605095039}
{"id":1460,"predictions":["def removeAlternate ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return 2 * removeAlternate ( n \/ 2 ) - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 * removeAlternate ( ( ( n - 1 ) \/\/ 2 ) ) + 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 NEW_LINE print ( removeAlternate ( n ) ) NEW_LINE n = 10 NEW_LINE print ( removeAlternate ( n ) ) NEW_LINE n = 10 NEW_LINE print ( removeAlternate ( n ) ) NEW_LINE DEDENT"],"references":["def removeAlternate ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return 2 * removeAlternate ( n \/ 2 ) - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 * removeAlternate ( ( ( n - 1 ) \/ 2 ) ) + 1 NEW_LINE DEDENT DEDENT n = 5 NEW_LINE print ( removeAlternate ( n ) ) NEW_LINE n = 10 NEW_LINE print ( removeAlternate ( n ) ) NEW_LINE"],"bleu":0.7463318574662962,"rouge_l":0.8875533765617586}
{"id":1461,"predictions":["import math NEW_LINE def lowerWythian ( n ) : NEW_LINE INDENT phi = ( 1 + math . sqrt ( 5 ) ) \/ 2.0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = floor ( i * phi ) NEW_LINE print ( \" , end = \" \" ) NEW_LINE if ( i != n - 1 ) : NEW_LINE INDENT print ( \" ▁ , ▁ \" , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT n = 5 NEW_LINE lowerWytho ( n ) NEW_LINE"],"references":["from math import sqrt , floor NEW_LINE def lowerWythoff ( n ) : NEW_LINE INDENT phi = ( 1 + sqrt ( 5 ) ) \/ 2 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = floor ( i * phi ) ; NEW_LINE print ( ans , end = \" \" ) ; NEW_LINE if ( i != n ) : NEW_LINE INDENT print ( \" , ▁ \" , end = \" \" ) ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 ; NEW_LINE lowerWythoff ( n ) ; NEW_LINE DEDENT"],"bleu":0.5732254366133066,"rouge_l":0.8021406727828747}
{"id":1462,"predictions":["def countPairs ( str ) : NEW_LINE INDENT result = 0 ; NEW_LINE n = len ( str ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( abs ( str [ i ] - str [ j ] ) == abs ( i - j ) ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result ; NEW_LINE DEDENT str = \" geeksforgeeks \" ; NEW_LINE print ( countPairs ( str ) ) ; NEW_LINE"],"references":["def countPairs ( str1 ) : NEW_LINE INDENT result = 0 ; NEW_LINE n = len ( str1 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( abs ( ord ( str1 [ i ] ) - ord ( str1 [ j ] ) ) == abs ( i - j ) ) : NEW_LINE INDENT result += 1 ; NEW_LINE DEDENT DEDENT DEDENT return result ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" geeksforgeeks \" ; NEW_LINE print ( countPairs ( str1 ) ) ; NEW_LINE DEDENT"],"bleu":0.6212272635152326,"rouge_l":0.819940915805022}
{"id":1463,"predictions":["import math NEW_LINE def checkPowerof8 ( n ) : NEW_LINE INDENT i = math . log ( n ) \/ math . log ( i ) ; NEW_LINE return ( i - math . floor ( i ) < 0.000001 ) ; NEW_LINE DEDENT n = 65 ; NEW_LINE if ( checkPowerof8 ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT"],"references":["from math import log , trunc NEW_LINE def checkPowerof8 ( n ) : NEW_LINE INDENT i = log ( n , 8 ) NEW_LINE return ( i - trunc ( i ) < 0.000001 ) ; NEW_LINE DEDENT n = 65 NEW_LINE if checkPowerof8 ( n ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.6045843754454614,"rouge_l":0.8321232123212321}
{"id":1464,"predictions":["def digitsNum ( N ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT print ( \"0\" ) NEW_LINE DEDENT if ( N % 9 != 0 ) : NEW_LINE INDENT print ( N % 9 , end = \" \" ) NEW_LINE DEDENT for i in range ( 1 , ( N \/\/ 9 ) + 1 ) : NEW_LINE INDENT print ( \"9\" , end = \" \" ) NEW_LINE DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( \"0\" , end = \" \" ) NEW_LINE DEDENT print ( \" \" ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 5 NEW_LINE print ( \" The ▁ number ▁ is ▁ : ▁ \" , digitsNum ( N ) ) NEW_LINE digitsNum ( N ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def digitsNum ( N ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT print ( \"0\" , end = \" \" ) NEW_LINE DEDENT if ( N % 9 != 0 ) : NEW_LINE INDENT print ( N % 9 , end = \" \" ) NEW_LINE DEDENT for i in range ( 1 , int ( N \/ 9 ) + 1 ) : NEW_LINE INDENT print ( \"9\" , end = \" \" ) NEW_LINE DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( \"0\" , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT N = 5 NEW_LINE print ( \" The ▁ number ▁ is ▁ : ▁ \" , end = \" \" ) NEW_LINE digitsNum ( N ) NEW_LINE"],"bleu":0.8174419198580509,"rouge_l":0.8843560350640592}
{"id":1465,"predictions":["def printFirstNegativeInteger ( arr , n , k ) : NEW_LINE INDENT Di = dict ( ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT Di . append ( i ) NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( Di > 0 ) : NEW_LINE INDENT print ( arr [ Di [ 0 ] ] , end = \" ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" ▁ \" , end = \" \" ) NEW_LINE DEDENT while ( ( not ( D ) ) and ( i > 0 ) ) : NEW_LINE INDENT if ( i > 0 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if ( ( D [ i ] < 0 ) : NEW_LINE INDENT print ( arr [ Di [ i ] ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if ( D [ i ] < 0 ) : NEW_LINE INDENT print ( arr [ D [ i ] ] , end = \" ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \"0\" , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 10 , 6 , - 7 , 8 , - 1 , - 1 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE printFirstNegativeInteger ( arr , n , k ) NEW_LINE DEDENT"],"references":["from collections import deque NEW_LINE def printFirstNegativeInteger ( arr , n , k ) : NEW_LINE INDENT Di = deque ( ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT Di . append ( i ) ; NEW_LINE DEDENT DEDENT for i in range ( k , n ) : NEW_LINE INDENT if ( not Di ) : NEW_LINE INDENT print ( 0 , end = ' ▁ ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ Di [ 0 ] ] , end = ' ▁ ' ) ; NEW_LINE DEDENT while Di and Di [ 0 ] <= ( i - k ) : NEW_LINE INDENT Di . popleft ( ) NEW_LINE DEDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT Di . append ( i ) ; NEW_LINE DEDENT DEDENT if not Di : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ Di [ 0 ] ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 12 , - 1 , - 7 , 8 , - 15 , 30 , 16 , 28 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE printFirstNegativeInteger ( arr , n , k ) ; NEW_LINE DEDENT"],"bleu":0.6131605588474413,"rouge_l":0.731479156202913}
{"id":1466,"predictions":["def findFirstAndLast ( arr , x ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE first = - 1 NEW_LINE last = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if x != arr [ i ] : NEW_LINE INDENT continue NEW_LINE DEDENT if first == - 1 : NEW_LINE INDENT first = i NEW_LINE DEDENT last = i NEW_LINE DEDENT if first != - 1 : NEW_LINE INDENT print ( \" First ▁ Occurrence ▁ = ▁ \" , first ) NEW_LINE print ( \" Last ▁ Occurrence ▁ = ▁ \" , last ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ Frequency \" ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 2 , 2 , 2 , 3 , 4 , 7 , 8 ] NEW_LINE x = 8 NEW_LINE findFirstAndLast ( arr , x ) NEW_LINE"],"references":["def findFirstAndLast ( arr , n , x ) : NEW_LINE INDENT first = - 1 NEW_LINE last = - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( x != arr [ i ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( first == - 1 ) : NEW_LINE INDENT first = i NEW_LINE DEDENT last = i NEW_LINE DEDENT if ( first != - 1 ) : NEW_LINE INDENT print ( \" First ▁ Occurrence ▁ = ▁ \" , first , \" ▁ \\n Last ▁ Occurrence ▁ = ▁ \" , last ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ Found \" ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 2 , 2 , 2 , 3 , 4 , 7 , 8 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE x = 8 NEW_LINE findFirstAndLast ( arr , n , x ) NEW_LINE"],"bleu":0.7655324791947501,"rouge_l":0.8775635139271503}
{"id":1467,"predictions":["NO_OF_CHARS = 256 NEW_LINE def areAnagram ( str1 , str2 ) : NEW_LINE INDENT count = [ 0 ] * NO_OF_CHARS NEW_LINE i = 0 NEW_LINE while ( i < len ( str1 ) and i < len ( str2 ) ) : NEW_LINE INDENT count [ ord ( str1 [ i ] ) ] += 1 NEW_LINE count [ ord ( str2 [ i ] ) ] -= 1 NEW_LINE i += 1 NEW_LINE DEDENT if ( len ( str1 ) != len ( str2 ) != len ( str2 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( NO_OF_CHARS ) : NEW_LINE INDENT if ( count [ i ] != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def findAllAnagrams ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( areAnagram ( arr [ i ] , arr [ j ] ) ) ) : NEW_LINE INDENT print ( arr [ i ] , \" is ▁ a [ j ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ \" geeks \" , \" geeksforgeeks \" , \" geeks \" , \" for i in range ( n ) ] NEW_LINE findAllAnagrams ( arr , n ) NEW_LINE DEDENT"],"references":["NO_OF_CHARS = 256 NEW_LINE def areAnagram ( str1 : str , str2 : str ) -> bool : NEW_LINE INDENT count = [ 0 ] * NO_OF_CHARS NEW_LINE i = 0 NEW_LINE while i < len ( str1 ) and i < len ( str2 ) : NEW_LINE INDENT count [ ord ( str1 [ i ] ) ] += 1 NEW_LINE count [ ord ( str2 [ i ] ) ] -= 1 NEW_LINE i += 1 NEW_LINE DEDENT if len ( str1 ) != len ( str2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( NO_OF_CHARS ) : NEW_LINE INDENT if count [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT DEDENT def findAllAnagrams ( arr : list , n : int ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if areAnagram ( arr [ i ] , arr [ j ] ) : NEW_LINE INDENT print ( arr [ i ] , \" is ▁ anagram ▁ of \" , arr [ j ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ \" geeksquiz \" , \" geeksforgeeks \" , \" abcd \" , \" forgeeksgeeks \" , \" zuiqkeegs \" ] NEW_LINE n = len ( arr ) NEW_LINE findAllAnagrams ( arr , n ) NEW_LINE DEDENT"],"bleu":0.7853211119662676,"rouge_l":0.885547634478289}
{"id":1468,"predictions":["MAX = 100 NEW_LINE arr = [ 0 for i in range ( MAX ) ] NEW_LINE arr [ 0 ] = 0 NEW_LINE arr [ 1 ] = 1 NEW_LINE for i in range ( 2 , MAX ) : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] + arr [ i - 2 ] NEW_LINE DEDENT print ( \" Fibonacci ▁ numbers ▁ divisible ▁ by \" , \" the ▁ indexes ▁ are ▁ : ▁ \" ) NEW_LINE for i in range ( 1 , MAX ) : NEW_LINE INDENT if arr [ i % i ] % i == 0 : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 0 for i in range ( MAX ) ] NEW_LINE arr [ 1 ] = 1 NEW_LINE arr [ 2 ] = 1 NEW_LINE for i in range ( 1 , MAX ) : NEW_LINE INDENT if arr [ i % i ] % i == 0 : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT"],"references":["if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT MAX = 100 NEW_LINE arr = [ 0 for i in range ( MAX ) ] NEW_LINE arr [ 0 ] = 0 NEW_LINE arr [ 1 ] = 1 NEW_LINE for i in range ( 2 , MAX ) : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] + arr [ i - 2 ] NEW_LINE DEDENT print ( \" Fibonacci ▁ numbers ▁ divisible ▁ by ▁ their ▁ indexes ▁ are ▁ : \" ) NEW_LINE for i in range ( 1 , MAX ) : NEW_LINE INDENT if ( arr [ i ] % i == 0 ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT"],"bleu":0.6076846924964143,"rouge_l":0.7302859404373208}
{"id":1469,"predictions":["def isPossible ( Sx , Sy , Dx , Y ) : NEW_LINE INDENT if ( abs ( Sx - Dx ) % x == 0 and abs ( Sy - Dx ) % y == 0 and ( abs ( Sx - Dx ) \/\/ x ) % 2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT Sx = 0 NEW_LINE Sy = 0 NEW_LINE Dx = 0 NEW_LINE Den = 0 NEW_LINE y = 3 NEW_LINE x = 3 NEW_LINE y = 4 NEW_LINE y = 4 NEW_LINE if ( isPossible ( Sx , Sy , Dx , D ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def isPossible ( Sx , Sy , Dx , Dy , x , y ) : NEW_LINE INDENT if ( abs ( Sx - Dx ) % x == 0 and abs ( Sy - Dy ) % y == 0 and ( abs ( Sx - Dx ) \/ x ) % 2 == ( abs ( Sy - Dy ) \/ y ) % 2 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT Sx = 0 ; NEW_LINE Sy = 0 ; NEW_LINE Dx = 0 ; NEW_LINE Dy = 0 ; NEW_LINE x = 3 ; NEW_LINE y = 4 ; NEW_LINE if ( isPossible ( Sx , Sy , Dx , Dy , x , y ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT"],"bleu":0.6064594440511921,"rouge_l":0.8172116257947322}
{"id":1470,"predictions":["from math import sqrt NEW_LINE def isPerfectSquareString ( str1 ) : NEW_LINE INDENT sum = 0 NEW_LINE l = len ( str1 ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT sum += ord ( str1 [ i ] ) NEW_LINE DEDENT squareRoot = int ( sqrt ( sum ) ) NEW_LINE return ( ( squareRoot - floor ( squareRoot ) ) == 0 ) NEW_LINE DEDENT str1 = \" d \" NEW_LINE if ( isPerfectSquareString ( str1 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["import math ; NEW_LINE def isPerfectSquareString ( str ) : NEW_LINE INDENT sum = 0 ; NEW_LINE l = len ( str ) ; NEW_LINE for i in range ( l ) : NEW_LINE INDENT sum = sum + ord ( str [ i ] ) ; NEW_LINE DEDENT squareRoot = math . sqrt ( sum ) ; NEW_LINE return ( ( squareRoot - math . floor ( squareRoot ) ) == 0 ) ; NEW_LINE DEDENT str = \" d \" ; NEW_LINE if ( isPerfectSquareString ( str ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT"],"bleu":0.5883476319331717,"rouge_l":0.8400234397890419}
{"id":1471,"predictions":["def arePermutation ( str1 , str2 ) : NEW_LINE INDENT n1 = len ( str1 ) NEW_LINE n2 = len ( str2 ) NEW_LINE if ( n1 != n2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT ch1 = list ( str1 ) NEW_LINE for i in range ( len ( str2 ) ) : NEW_LINE INDENT if ( ch1 [ i ] != ch2 [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT str1 = \" test \" NEW_LINE str2 = \" test \" NEW_LINE if ( arePermutation ( str11 , str2 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def arePermutation ( str1 , str2 ) : NEW_LINE INDENT n1 = len ( str1 ) NEW_LINE n2 = len ( str2 ) NEW_LINE if ( n1 != n2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT a = sorted ( str1 ) NEW_LINE str1 = \" ▁ \" . join ( a ) NEW_LINE b = sorted ( str2 ) NEW_LINE str2 = \" ▁ \" . join ( b ) NEW_LINE for i in range ( 0 , n1 , 1 ) : NEW_LINE INDENT if ( str1 [ i ] != str2 [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = \" test \" NEW_LINE str2 = \" ttew \" NEW_LINE if ( arePermutation ( str1 , str2 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.5871924946271375,"rouge_l":0.7617548050819852}
{"id":1472,"predictions":["def catalanDP ( n ) : NEW_LINE INDENT catalan = [ 1 ] * ( n + 2 ) NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT catalan [ i ] = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT catalan [ i ] += ( catalan [ j ] * catalan [ i - j - 1 ] ) NEW_LINE DEDENT DEDENT return catalan [ n ] NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT print ( catalanDP ( i ) , end = \" ▁ \" ) NEW_LINE DEDENT"],"references":["def catalan ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT catalan = [ 0 for i in range ( n + 1 ) ] NEW_LINE catalan [ 0 ] = 1 NEW_LINE catalan [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT catalan [ i ] = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT catalan [ i ] = catalan [ i ] + catalan [ j ] * catalan [ i - j - 1 ] NEW_LINE DEDENT DEDENT return catalan [ n ] NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT print ( catalan ( i ) , end = \" ▁ \" ) NEW_LINE DEDENT"],"bleu":0.5845348534559223,"rouge_l":0.7587843036676071}
{"id":1473,"predictions":["def findGeometricTriplets ( arr , n ) : NEW_LINE INDENT for j in range ( 1 , n - 1 ) : NEW_LINE INDENT i = j - 1 NEW_LINE k = j + 1 NEW_LINE while ( i >= 0 and k <= n - 1 ) : NEW_LINE INDENT while ( i >= 0 and arr [ j ] % arr [ i ] == 0 and arr [ j ] % arr [ j ] == 0 and arr [ j ] % arr [ j ] == 0 and arr [ j ] \/\/ arr [ j ] == arr [ k ] ) : NEW_LINE INDENT print ( arr [ i ] , \" \" , arr [ j ] , \" \" , arr [ k ] ) NEW_LINE k += 1 NEW_LINE i -= 1 NEW_LINE DEDENT if ( i >= 0 and arr [ j ] % arr [ i ] == 0 and arr [ k ] % arr [ j ] == 0 ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT k += 1 NEW_LINE DEDENT DEDENT if ( i > 0 and arr [ j ] % arr [ i ] == 0 and arr [ k ] % arr [ j ] == 0 ) : NEW_LINE INDENT k += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT arr = [ 1 , 2 , 4 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE findGeometricTriplets ( arr , n ) NEW_LINE"],"references":["def findGeometricTriplets ( arr , n ) : NEW_LINE INDENT for j in range ( 1 , n - 1 ) : NEW_LINE INDENT i = j - 1 NEW_LINE k = j + 1 NEW_LINE while ( i >= 0 and k <= n - 1 ) : NEW_LINE INDENT while ( arr [ j ] % arr [ i ] == 0 and arr [ k ] % arr [ j ] == 0 and arr [ j ] \/\/ arr [ i ] == arr [ k ] \/\/ arr [ j ] ) : NEW_LINE INDENT print ( arr [ i ] , \" ▁ \" , arr [ j ] , \" ▁ \" , arr [ k ] ) NEW_LINE k += 1 NEW_LINE i -= 1 NEW_LINE DEDENT if ( arr [ j ] % arr [ i ] == 0 and arr [ k ] % arr [ j ] == 0 ) : NEW_LINE INDENT if ( arr [ j ] \/\/ arr [ i ] < arr [ k ] \/\/ arr [ j ] ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT k += 1 NEW_LINE DEDENT DEDENT elif ( arr [ j ] % arr [ i ] == 0 ) : NEW_LINE INDENT k += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 16 ] NEW_LINE n = len ( arr ) NEW_LINE findGeometricTriplets ( arr , n ) NEW_LINE DEDENT"],"bleu":0.8098774324077042,"rouge_l":0.8433684462532919}
{"id":1474,"predictions":["def fib ( n ) : NEW_LINE INDENT F = [ [ 1 , 1 ] , [ 1 , 0 ] ] NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT power ( F , n - 1 ) NEW_LINE return F [ 0 ] [ 0 ] NEW_LINE DEDENT def multiply ( F , M ) : NEW_LINE INDENT x = ( F [ 0 ] [ 0 ] * M [ 0 ] [ 0 ] + F [ 0 ] [ 1 ] ) NEW_LINE y = ( F [ 0 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 1 ] ) NEW_LINE z = ( F [ 1 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 1 ] [ 1 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 1 ] ) NEW_LINE w = ( F [ 1 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 1 ] ) NEW_LINE F [ 0 ] [ 0 ] = x NEW_LINE F [ 0 ] [ 1 ] = y NEW_LINE F [ 1 ] [ 0 ] = z NEW_LINE F [ 1 ] [ 0 ] = z NEW_LINE F [ 1 ] [ 1 ] = z NEW_LINE DEDENT def power ( F , n ) : NEW_LINE INDENT multiply ( F , M ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 9 NEW_LINE print ( fib ( n ) ) NEW_LINE DEDENT"],"references":["def fib ( n ) : NEW_LINE INDENT F = [ [ 1 , 1 ] , [ 1 , 0 ] ] NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT power ( F , n - 1 ) NEW_LINE return F [ 0 ] [ 0 ] NEW_LINE DEDENT def multiply ( F , M ) : NEW_LINE INDENT x = ( F [ 0 ] [ 0 ] * M [ 0 ] [ 0 ] + F [ 0 ] [ 1 ] * M [ 1 ] [ 0 ] ) NEW_LINE y = ( F [ 0 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 0 ] [ 1 ] * M [ 1 ] [ 1 ] ) NEW_LINE z = ( F [ 1 ] [ 0 ] * M [ 0 ] [ 0 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 0 ] ) NEW_LINE w = ( F [ 1 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 1 ] ) NEW_LINE F [ 0 ] [ 0 ] = x NEW_LINE F [ 0 ] [ 1 ] = y NEW_LINE F [ 1 ] [ 0 ] = z NEW_LINE F [ 1 ] [ 1 ] = w NEW_LINE DEDENT def power ( F , n ) : NEW_LINE INDENT M = [ [ 1 , 1 ] , [ 1 , 0 ] ] NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT multiply ( F , M ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 9 NEW_LINE print ( fib ( n ) ) NEW_LINE DEDENT"],"bleu":0.851880861333195,"rouge_l":0.8947884923299416}
{"id":1475,"predictions":["def largest_alphens ( a , n ) : NEW_LINE INDENT max = ' A ' NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] > max ) : NEW_LINE INDENT max = a [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT def smallest_alph alphabet ( a , n ) : NEW_LINE INDENT min = ' Z ' NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( a [ i ] < min ) : NEW_LINE INDENT min = a [ i ] NEW_LINE DEDENT DEDENT return min NEW_LINE DEDENT a = \" GeEksforGeeks \" NEW_LINE size = len ( a ) NEW_LINE print ( ' Largest ▁ and ▁ smallest ▁ alphabet ▁ is ▁ : ▁ \" , end = ' ▁ ' ) NEW_LINE print ( smallest_alphators ( a , size ) ) NEW_LINE print ( smallest_alphacent ( a , size ) ) NEW_LINE"],"references":["def largest_alphabet ( a , n ) : NEW_LINE INDENT max = ' A ' NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] > max ) : NEW_LINE INDENT max = a [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT def smallest_alphabet ( a , n ) : NEW_LINE INDENT min = ' z ' ; NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( a [ i ] < min ) : NEW_LINE INDENT min = a [ i ] NEW_LINE DEDENT DEDENT return min NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = \" GeEksforGeeks \" NEW_LINE size = len ( a ) NEW_LINE print ( \" Largest ▁ and ▁ smallest ▁ alphabet ▁ is ▁ : ▁ \" , end = \" \" ) NEW_LINE print ( largest_alphabet ( a , size ) , end = \" ▁ and ▁ \" ) NEW_LINE print ( smallest_alphabet ( a , size ) ) NEW_LINE DEDENT"],"bleu":0.7519899127454498,"rouge_l":0.8715924045873286}
{"id":1476,"predictions":["def Check_is_possible ( l , r , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if ( i % k == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count > 1 NEW_LINE DEDENT l = 4 NEW_LINE r = 12 NEW_LINE k = 5 NEW_LINE if ( Check_is_possible ( l , r , k ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"],"references":["def Check_is_possible ( l , r , k ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if ( i % k == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return ( count > 1 ) ; NEW_LINE DEDENT l = 4 ; NEW_LINE r = 12 ; NEW_LINE k = 5 ; NEW_LINE if ( Check_is_possible ( l , r , k ) ) : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE DEDENT"],"bleu":0.7760171703330428,"rouge_l":0.9437412095639943}
{"id":1477,"predictions":["def pushZerosToEnd ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] != 0 ) : NEW_LINE INDENT arr [ count ] = arr [ i ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT while ( count < n ) : NEW_LINE INDENT arr [ count ] = 0 NEW_LINE count += 1 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 9 , 8 , 4 , 0 , 2 , 7 , 0 , 6 , 0 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE pushZerosToEnd ( arr , n ) NEW_LINE print ( \" Array ▁ after ▁ zeros ▁ to ▁ the ▁ back : ▁ \" , end = \" \" ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT"],"references":["def pushZerosToEnd ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] != 0 : NEW_LINE INDENT arr [ count ] = arr [ i ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT while count < n : NEW_LINE INDENT arr [ count ] = 0 NEW_LINE count += 1 NEW_LINE DEDENT DEDENT arr = [ 1 , 9 , 8 , 4 , 0 , 0 , 2 , 7 , 0 , 6 , 0 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE pushZerosToEnd ( arr , n ) NEW_LINE print ( \" Array ▁ after ▁ pushing ▁ all ▁ zeros ▁ to ▁ end ▁ of ▁ array : \" ) NEW_LINE print ( arr ) NEW_LINE"],"bleu":0.661951028091181,"rouge_l":0.8410693611198822}
{"id":1478,"predictions":["def check ( s , k ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] != s [ i % k ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def countCommonDivisors ( a , b ) : NEW_LINE INDENT ct = 0 NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE for i in range ( 1 , min ( n , m ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 and m % i == 0 ) : NEW_LINE INDENT if ( a [ 0 : i ] == b [ 0 : i ] ) : NEW_LINE INDENT if ( a [ 0 : i ] == b [ 0 : i ] ) : NEW_LINE INDENT if ( check ( a , i ) and check ( b , i ) ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return ct NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = \" xaxa \" NEW_LINE b = \" xaxaxa \" NEW_LINE print ( countCommonDivisors ( a , b ) ) NEW_LINE DEDENT"],"references":["def check ( s , k ) : NEW_LINE INDENT for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] != s [ i % k ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def countCommonDivisors ( a , b ) : NEW_LINE INDENT ct = 0 NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE for i in range ( 1 , min ( n , m ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 and m % i == 0 ) : NEW_LINE INDENT if ( a [ 0 : i ] == b [ 0 : i ] ) : NEW_LINE INDENT if ( check ( a , i ) and check ( b , i ) ) : NEW_LINE INDENT ct = ct + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return ct NEW_LINE DEDENT a = \" xaxa \" NEW_LINE b = \" xaxaxaxa \" NEW_LINE print ( countCommonDivisors ( a , b ) ) NEW_LINE"],"bleu":0.8039009590324883,"rouge_l":0.904145288704292}
{"id":1479,"predictions":["n = 4562 ; NEW_LINE rev = 0 NEW_LINE while ( n ) : NEW_LINE INDENT a = n % 10 NEW_LINE rev = rev * 10 + a NEW_LINE n = n \/\/ 10 NEW_LINE DEDENT print ( rev ) NEW_LINE"],"references":["n = 4562 ; NEW_LINE rev = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT a = n % 10 NEW_LINE rev = rev * 10 + a NEW_LINE n = n \/\/ 10 NEW_LINE DEDENT print ( rev ) NEW_LINE"],"bleu":0.9179279052562411,"rouge_l":0.9726651480637813}
{"id":1480,"predictions":["def center_nonadecagon_num ( n ) : NEW_LINE INDENT return ( 19 * n * n * n - 19 * n + 2 ) \/\/ 2 NEW_LINE DEDENT if __name__ == ' _ main _ _ ' : NEW_LINE INDENT n = 2 NEW_LINE print ( n , \" th ▁ centered ▁ centered ▁ \" number ▁ : ▁ \" , center_noncagonal_num ( n ) ) NEW_LINE n = 7 NEW_LINE print ( center_nonadecagonal_num ( n ) ) NEW_LINE DEDENT"],"references":["def center_nonadecagon_num ( n ) : NEW_LINE INDENT return ( 19 * n * n - 19 * n + 2 ) \/\/ 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 2 NEW_LINE print ( n , \" nd ▁ centered ▁ nonadecagonal ▁ \" + \" number ▁ : ▁ \" , center_nonadecagon_num ( n ) ) NEW_LINE n = 7 NEW_LINE print ( n , \" nd ▁ centered ▁ nonadecagonal ▁ \" + \" number ▁ : ▁ \" , center_nonadecagon_num ( n ) ) NEW_LINE DEDENT"],"bleu":0.6688275757125981,"rouge_l":0.8133333333333334}
{"id":1481,"predictions":["def countkDist ( str1 , k ) : NEW_LINE INDENT res = 0 NEW_LINE n = len ( str1 ) NEW_LINE cnt = [ 0 for i in range ( 26 ) ] NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT dist_count = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if ( cnt [ ord ( str1 [ j ] ) - ord ( ' a ' ) ] == 0 ) : NEW_LINE INDENT dist_count += 1 NEW_LINE DEDENT cnt [ ord ( str1 [ j ] ) - ord ( ' a ' ) ] += 1 NEW_LINE if ( dist_count == k ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT ch = \" abcbaa \" NEW_LINE k = 3 NEW_LINE print ( \" Total ▁ substrings ▁ with \" , k , \" characters ▁ : ▁ \" , countkDistDist ( ch , k ) ) NEW_LINE"],"references":["def countkDist ( str1 , k ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE res = 0 NEW_LINE cnt = [ 0 ] * 27 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT dist_count = 0 NEW_LINE cnt = [ 0 ] * 27 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if ( cnt [ ord ( str1 [ j ] ) - 97 ] == 0 ) : NEW_LINE INDENT dist_count += 1 NEW_LINE DEDENT cnt [ ord ( str1 [ j ] ) - 97 ] += 1 NEW_LINE if ( dist_count == k ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT if ( dist_count > k ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" abcbaa \" NEW_LINE k = 3 NEW_LINE print ( \" Total ▁ substrings ▁ with ▁ exactly \" , k , \" distinct ▁ characters ▁ : ▁ \" , end = \" \" ) NEW_LINE print ( countkDist ( str1 , k ) ) NEW_LINE DEDENT"],"bleu":0.6257320277633154,"rouge_l":0.7528227571115975}
{"id":1482,"predictions":["def percent ( n , x ) : NEW_LINE INDENT p = n * x NEW_LINE p \/= 100 NEW_LINE return p NEW_LINE DEDENT def getLoss ( price , q , X , n ) : NEW_LINE INDENT loss = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT originalPrice = price [ i ] NEW_LINE sellingPrice = originalPrice + percent ( originalPrice , X [ i ] ) NEW_LINE afterRemove = sellingPrice - percent ( sellingPrice , X [ i ] ) NEW_LINE loss += ( ( originalPrice - remPrice , X [ i ] ) ) NEW_LINE DEDENT return loss NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT price = [ 20 48 , 48 , 200 , 100 ] NEW_LINE q = [ 20 , 48 , 1 , 1 ] NEW_LINE X = [ 0 , 48 , 200 , 5 ] NEW_LINE n = len ( X ) NEW_LINE print ( getLoss ( prices , quantity , X , n ) ) NEW_LINE DEDENT"],"references":["def percent ( n , x ) : NEW_LINE INDENT p = ( int ) ( n ) * x ; NEW_LINE p \/= 100 ; NEW_LINE return p ; NEW_LINE DEDENT def getLoss ( price , quantity , X , n ) : NEW_LINE INDENT loss = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT originalPrice = price [ i ] ; NEW_LINE sellingPrice = originalPrice + percent ( originalPrice , X [ i ] ) ; NEW_LINE afterDiscount = sellingPrice - percent ( sellingPrice , X [ i ] ) ; NEW_LINE loss += ( ( originalPrice - afterDiscount ) * quantity [ i ] ) ; NEW_LINE DEDENT return round ( loss , 2 ) ; NEW_LINE DEDENT price = [ 20 , 48 , 200 , 100 ] ; NEW_LINE quantity = [ 20 , 48 , 1 , 1 ] ; NEW_LINE X = [ 0 , 48 , 200 , 5 ] ; NEW_LINE n = len ( X ) ; NEW_LINE print ( getLoss ( price , quantity , X , n ) ) ; NEW_LINE"],"bleu":0.6495513599156475,"rouge_l":0.8463933113937561}
{"id":1483,"predictions":["def minCost ( s ) : NEW_LINE INDENT alphabets = [ False ] * 26 ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT alphabets [ ord ( s [ i ] ) - 97 ] = True ; NEW_LINE DEDENT count = 0 ; NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( alphabets [ i ] ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" geeksforgeeks \" ; NEW_LINE print ( \" Total ▁ cost ▁ to ▁ construct \" , s , \" is \" , minCost ( s ) ) ; NEW_LINE DEDENT"],"references":["def minCost ( s ) : NEW_LINE INDENT alphabets = [ False for i in range ( 26 ) ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT alphabets [ ord ( s [ i ] ) - 97 ] = True NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( alphabets [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" geeksforgeeks \" NEW_LINE print ( \" Total ▁ cost ▁ to ▁ construct \" , s , \" is \" , minCost ( s ) ) NEW_LINE DEDENT"],"bleu":0.8040236270057998,"rouge_l":0.9237719521506743}
{"id":1484,"predictions":["import math NEW_LINE def nextPowerOfFour ( n ) : NEW_LINE INDENT x = math . floor ( math . sqrt ( n ) ) NEW_LINE if ( pow ( x , 4 ) == n ) : NEW_LINE INDENT return n NEW_LINE DEDENT else : NEW_LINE INDENT x = x + 1 NEW_LINE return x NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 122 NEW_LINE print ( nextPowerOfFour ( n ) ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def nextPowerOfFour ( n ) : NEW_LINE INDENT x = math . floor ( ( n ** ( 1 \/ 2 ) ) ** ( 1 \/ 2 ) ) ; NEW_LINE if ( ( x ** 4 ) == n ) : NEW_LINE INDENT return n ; NEW_LINE DEDENT else : NEW_LINE INDENT x = x + 1 ; NEW_LINE return ( x ** 4 ) ; NEW_LINE DEDENT DEDENT n = 122 ; NEW_LINE print ( nextPowerOfFour ( n ) ) ; NEW_LINE"],"bleu":0.5438211027881061,"rouge_l":0.7526575550493546}
{"id":1485,"predictions":["def findCost ( s1 , s2 , a , b , c , d , d , n ) : NEW_LINE INDENT cost = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s1 [ i ] == s2 [ i ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT if ( ( ( s1 [ i ] == '1' and s2 [ i ] == '2' ) or ( s2 [ i ] == '1' and s1 [ i ] == '2' ) ) : NEW_LINE INDENT cost += min ( d , min ( a , b + c ) ) NEW_LINE DEDENT elif ( ( s1 [ i ] == '2' and s2 [ i ] == '3' and s1 [ i ] == '3' ) ) ) : NEW_LINE INDENT cost += min ( d , min ( b , a + c ) ) NEW_LINE DEDENT elif ( ( s1 [ i ] == '1' and s2 [ i ] == '3' and s1 [ i ] == '3' ) ) : NEW_LINE INDENT cost += min ( d , min ( c , a + b ) ) ) NEW_LINE DEDENT elif ( ( s1 [ i ] == '1' and s2 [ i ] == '3' and s1 [ i ] == '3' ) ) : NEW_LINE INDENT cost += min ( d , min ( c , a + b ) ) NEW_LINE DEDENT DEDENT DEDENT return cost NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s1 = \" 121\" NEW_LINE s2 = \"223\" NEW_LINE a = 2 NEW_LINE b = 3 NEW_LINE c = 10 NEW_LINE d = 10 NEW_LINE n = len ( s1 ) NEW_LINE print ( findCost ( s1 , s2 , a , b , c , d , d , n ) ) NEW_LINE DEDENT"],"references":["def findCost ( s1 , s2 , a , b , c , d , n ) : NEW_LINE INDENT cost = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s1 [ i ] == s2 [ i ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT if ( ( s1 [ i ] == '1' and s2 [ i ] == '2' ) or ( s2 [ i ] == '1' and s1 [ i ] == '2' ) ) : NEW_LINE INDENT cost += min ( d , min ( a , b + c ) ) NEW_LINE DEDENT elif ( ( s1 [ i ] == '2' and s2 [ i ] == '3' ) or ( s2 [ i ] == '2' and s1 [ i ] == '3' ) ) : NEW_LINE INDENT cost += min ( d , min ( b , a + c ) ) NEW_LINE DEDENT elif ( ( s1 [ i ] == '1' and s2 [ i ] == '3' ) or ( s2 [ i ] == '1' and s1 [ i ] == '3' ) ) : NEW_LINE INDENT cost += min ( d , min ( c , a + b ) ) NEW_LINE DEDENT DEDENT DEDENT return cost NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s1 = \"121\" NEW_LINE s2 = \"223\" NEW_LINE a = 2 NEW_LINE b = 3 NEW_LINE c = 4 NEW_LINE d = 10 NEW_LINE n = len ( s1 ) NEW_LINE print ( findCost ( s1 , s2 , a , b , c , d , n ) ) NEW_LINE DEDENT"],"bleu":0.8238693883260014,"rouge_l":0.9032641591007351}
{"id":1486,"predictions":["def Twentyonematch ( arr , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT print ( 5 - arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 4 , 2 , 2 , 2 ] NEW_LINE N = len ( arr ) NEW_LINE ToneMatch ( arr , N ) NEW_LINE DEDENT"],"references":["def TwentyoneMatchstick ( arr , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT print ( 5 - arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 3 , 4 , 2 , 2 ] NEW_LINE N = len ( arr ) NEW_LINE TwentyoneMatchstick ( arr , N ) NEW_LINE"],"bleu":0.680982740561077,"rouge_l":0.8587647593097184}
{"id":1487,"predictions":["def Perimeter ( s , n ) : NEW_LINE INDENT perimeter = 1 NEW_LINE perimeter = n * s NEW_LINE return perimeter NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 NEW_LINE s = 2.5 NEW_LINE peri = 2.5 NEW_LINE peri = Perimeter ( s , n ) NEW_LINE print ( \" Perimeter ▁ of ▁ Regular ▁ Polygon \" , \" with ▁ length ▁ of ▁ length \" , s , \" ▁ = ▁ \" , Peri ) NEW_LINE DEDENT"],"references":["def Perimeter ( s , n ) : NEW_LINE INDENT perimeter = 1 NEW_LINE perimeter = n * s NEW_LINE return perimeter NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE s = 2.5 NEW_LINE peri = Perimeter ( s , n ) NEW_LINE print ( \" Perimeter ▁ of ▁ Regular ▁ Polygon ▁ with \" , n , \" sides ▁ of ▁ length \" , s , \" = \" , peri ) NEW_LINE DEDENT"],"bleu":0.7643249188778185,"rouge_l":0.8924652523774688}
{"id":1488,"predictions":["def checkPalindrome ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE count = 0 NEW_LINE for i in range ( n \/\/ 2 ) : NEW_LINE INDENT if ( str [ i ] != str [ n - i - 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return ( count <= 1 ) NEW_LINE DEDENT str = \" abccaa \" NEW_LINE if ( checkPalindrome ( str ) ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def checkPalindrome ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE count = 0 NEW_LINE for i in range ( 0 , int ( n \/ 2 ) ) : NEW_LINE INDENT if ( str [ i ] != str [ n - i - 1 ] ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT if ( count <= 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT str = \" abccaa \" NEW_LINE if ( checkPalindrome ( str ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.7276212521237635,"rouge_l":0.8599040837087631}
{"id":1489,"predictions":["def getSum ( n ) : NEW_LINE INDENT sm = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT sm = sm + n % 10 NEW_LINE n = n \/\/ 10 NEW_LINE DEDENT return sm NEW_LINE DEDENT def largestDigitSumdivisior ( n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT res = max ( res , getSum ( i ) ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT n = 14 NEW_LINE print ( largestDigitSumdivisior ( n ) ) NEW_LINE"],"references":["def getSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while n != 0 : NEW_LINE INDENT sum = sum + n % 10 NEW_LINE n = int ( n \/ 10 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT def largestDigitSumdivisior ( n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT res = max ( res , getSum ( i ) ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT n = 14 NEW_LINE print ( largestDigitSumdivisior ( n ) ) NEW_LINE"],"bleu":0.7809284779909116,"rouge_l":0.9209674934524729}
{"id":1490,"predictions":["def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def lcm ( n , m ) : NEW_LINE INDENT return ( n * m ) \/\/ gcd ( n , m ) ) NEW_LINE DEDENT n = 2 NEW_LINE m = 3 NEW_LINE k = 5 NEW_LINE print ( int ( k \/ lcm ( n , m ) ) ) NEW_LINE"],"references":["def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b ; NEW_LINE DEDENT return gcd ( b % a , a ) ; NEW_LINE DEDENT def lcm ( n , m ) : NEW_LINE INDENT return ( n * m ) \/\/ gcd ( n , m ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 2 ; m = 3 ; k = 5 ; NEW_LINE print ( k \/\/ lcm ( n , m ) ) ; NEW_LINE DEDENT"],"bleu":0.5884212921237365,"rouge_l":0.8207693634638606}
{"id":1491,"predictions":["import math NEW_LINE def checkPrime ( number ) : NEW_LINE INDENT num = str ( number ) NEW_LINE for i in range ( 2 , int ( math . sqrt ( num ) ) + 1 ) : NEW_LINE INDENT if ( ( num % i ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def splitIntoPrimes ( number ) : NEW_LINE INDENT if ( len ( number ) == 0 ) : NEW_LINE INDENT if ( len ( number ) == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( len ( number ) <= 6 and checkPrime ( number ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT numLen = len ( number ) NEW_LINE ans = 1000000 NEW_LINE for i in range ( 1 , 6 + 1 ) : NEW_LINE INDENT if ( checkPrime ( number [ 0 : i ] ) ) : NEW_LINE INDENT val = splitIntoPrimes ( number [ i ] ) NEW_LINE if ( val != - 1 ) : NEW_LINE INDENT val = splitIntoPrimes ( number [ i ] ) NEW_LINE if ( val != - 1 ) : NEW_LINE INDENT ans = min ( ans , 1 + val ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( ans == 1000000 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT print ( splitIntoPrimes ( \"13499315\" ) ) NEW_LINE print ( splitIntoPrimes ( \"43\" ) ) NEW_LINE print ( splitIntoPrimes ( \"43\" ) ) NEW_LINE"],"references":["def checkPrime ( number ) : NEW_LINE INDENT num = int ( number ) NEW_LINE for i in range ( 2 , int ( num ** 0.5 ) ) : NEW_LINE INDENT if ( ( num % i ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def splitIntoPrimes ( number ) : NEW_LINE INDENT if ( number == ' ' ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( len ( number ) <= 6 and checkPrime ( number ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT numLen = len ( number ) NEW_LINE ans = 1000000 NEW_LINE for i in range ( 1 , ( min ( 6 , numLen ) + 1 ) ) : NEW_LINE INDENT if ( checkPrime ( number [ : i ] ) ) : NEW_LINE INDENT val = splitIntoPrimes ( number [ i : ] ) NEW_LINE if ( val != - 1 ) : NEW_LINE INDENT ans = min ( ans , 1 + val ) NEW_LINE DEDENT DEDENT DEDENT if ( ans == 1000000 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT print ( splitIntoPrimes ( \"13499315\" ) ) NEW_LINE print ( splitIntoPrimes ( \"43\" ) ) NEW_LINE"],"bleu":0.7394360672472228,"rouge_l":0.8722187347422753}
{"id":1492,"predictions":["def findKthChar ( s , k ) : NEW_LINE INDENT length = len ( s ) NEW_LINE i = 0 NEW_LINE total_len = 0 NEW_LINE while ( i < length ) : NEW_LINE INDENT if ( s [ i ] is_len ) : NEW_LINE INDENT total_len += 1 NEW_LINE if ( total_len == k ) : NEW_LINE INDENT return s [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT n = 0 NEW_LINE while ( i < length and not ( s [ i ] ) ) : NEW_LINE INDENT n = n * 10 + ( ord ( s [ i ] ) - ord ( '0' ) ) NEW_LINE i += 1 NEW_LINE DEDENT next_len = total_len * n NEW_LINE if ( k <= next_len ) : NEW_LINE INDENT pos = k % total_len NEW_LINE if ( pos == 0 ) : NEW_LINE INDENT pos = total_len NEW_LINE DEDENT return findKthChar ( s , pos ) NEW_LINE DEDENT else : NEW_LINE INDENT total_len = next_total_len NEW_LINE DEDENT DEDENT DEDENT return ' ▁ ' . join ( s ) NEW_LINE DEDENT s = \" ab2c3\" NEW_LINE k = 5 NEW_LINE print ( findKthChar ( s , k ) ) NEW_LINE"],"references":["def findKthChar ( s , k ) : NEW_LINE INDENT len1 = len ( s ) NEW_LINE i = 0 NEW_LINE total_len = 0 NEW_LINE while ( i < len1 ) : NEW_LINE INDENT if ( s [ i ] . isalpha ( ) ) : NEW_LINE INDENT total_len += 1 NEW_LINE if ( total_len == k ) : NEW_LINE INDENT return s [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT n = 0 NEW_LINE while ( i < len1 and s [ i ] . isalpha ( ) == False ) : NEW_LINE INDENT n = n * 10 + ( ord ( s [ i ] ) - ord ( '0' ) ) NEW_LINE i += 1 NEW_LINE DEDENT next_total_len = total_len * n NEW_LINE if ( k <= next_total_len ) : NEW_LINE INDENT pos = k % total_len NEW_LINE if ( pos == 0 ) : NEW_LINE INDENT pos = total_len NEW_LINE DEDENT return findKthChar ( s , pos ) NEW_LINE DEDENT else : NEW_LINE INDENT total_len = next_total_len NEW_LINE DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" ab2c3\" NEW_LINE k = 5 NEW_LINE print ( findKthChar ( s , k ) ) NEW_LINE DEDENT"],"bleu":0.8036549460292224,"rouge_l":0.8914307574598316}
{"id":1493,"predictions":["def Nth_Term ( n ) : NEW_LINE INDENT return ( 2 * pow ( n , 3 ) - 3 * pow ( n , 2 ) + n + 6 ) \/\/ 6 NEW_LINE DEDENT N = 8 NEW_LINE print ( Nth_Term ( N ) ) NEW_LINE"],"references":["def Nth_Term ( n ) : NEW_LINE INDENT return ( 2 * pow ( n , 3 ) - 3 * pow ( n , 2 ) + n + 6 ) \/\/ 6 NEW_LINE DEDENT N = 8 NEW_LINE print ( Nth_Term ( N ) ) NEW_LINE"],"bleu":1.0,"rouge_l":1.0}
{"id":1494,"predictions":["def solve ( A , B , C ) : NEW_LINE INDENT i = len ( A ) - 1 NEW_LINE j = len ( B ) - 1 NEW_LINE k = len ( C ) - 1 NEW_LINE min_diff = [ abs ( A [ j ] , C [ k ] ) - min ( A [ j ] , min ( A [ j ] , C [ k ] ) ) ] NEW_LINE while ( i != - 1 and j != - 1 and k != - 1 ) : NEW_LINE INDENT current_diff = abs ( A [ i ] , max ( B [ j ] , C [ k ] ) ) - min ( A [ i ] , min ( B [ j ] , min ( B [ j ] , C [ k ] ) ) ) NEW_LINE if ( current_diff < min_diff ) : NEW_LINE INDENT min_diff = current_diff NEW_LINE DEDENT max_term = max ( A [ i ] , max ( B [ j ] , C [ k ] ) ) NEW_LINE if ( A [ i ] == max_term ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT elif ( B [ j ] == max_term ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT elif ( B [ j ] == max_term ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT elif ( B [ j ] == max_term ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT DEDENT return min_diff NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT D = [ 5 , 8 , 10 , 10 , 15 ] NEW_LINE E = [ 6 , 8 , 9 , 10 , 15 ] NEW_LINE F = [ 2 , 3 , 6 , 6 , 8 , 8 , 8 , 8 , 8 , 10 ] NEW_LINE print ( solve ( D , E , F ) ) NEW_LINE DEDENT"],"references":["def solve ( A , B , C ) : NEW_LINE INDENT i = len ( A ) - 1 NEW_LINE j = len ( B ) - 1 NEW_LINE k = len ( C ) - 1 NEW_LINE min_diff = abs ( max ( A [ i ] , B [ j ] , C [ k ] ) - min ( A [ i ] , B [ j ] , C [ k ] ) ) NEW_LINE while i != - 1 and j != - 1 and k != - 1 : NEW_LINE INDENT current_diff = abs ( max ( A [ i ] , B [ j ] , C [ k ] ) - min ( A [ i ] , B [ j ] , C [ k ] ) ) NEW_LINE if current_diff < min_diff : NEW_LINE INDENT min_diff = current_diff NEW_LINE DEDENT max_term = max ( A [ i ] , B [ j ] , C [ k ] ) NEW_LINE if A [ i ] == max_term : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT elif B [ j ] == max_term : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT DEDENT return min_diff NEW_LINE DEDENT A = [ 5 , 8 , 10 , 15 ] NEW_LINE B = [ 6 , 9 , 15 , 78 , 89 ] NEW_LINE C = [ 2 , 3 , 6 , 6 , 8 , 8 , 10 ] NEW_LINE print ( solve ( A , B , C ) ) NEW_LINE"],"bleu":0.6212630295100511,"rouge_l":0.8262895535327266}
{"id":1495,"predictions":["class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def CheckPerfectTree ( root ) : NEW_LINE INDENT q = [ ] NEW_LINE q . append ( root ) NEW_LINE flag = 0 NEW_LINE while ( len ( q ) > 0 ) : NEW_LINE INDENT temp = q . popleft ( ) NEW_LINE if ( temp . left and temp . right ) : NEW_LINE INDENT if ( flag == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE q . append ( temp . right ) NEW_LINE DEDENT DEDENT elif ( temp . left == None and temp . right == None ) : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT elif ( temp . left == None or temp . right == None ) : NEW_LINE INDENT return False NEW_LINE DEDENT elif ( temp . left == None and temp . right == None ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 7 ) NEW_LINE root . left = newNode ( 5 ) NEW_LINE root . right = newNode ( 6 ) NEW_LINE root . left . left = newNode ( 8 ) NEW_LINE root . left . left . left = newNode ( 1 ) NEW_LINE root . left . right = newNode ( 1 ) NEW_LINE root . right . left . right = newNode ( 10 ) NEW_LINE if ( CheckPerfectTree ( root ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["import sys NEW_LINE import math NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def newNode ( data ) : NEW_LINE INDENT return Node ( data ) NEW_LINE DEDENT def CheckPerfectTree ( root ) : NEW_LINE INDENT q = [ ] NEW_LINE q . append ( root ) NEW_LINE flag = 0 NEW_LINE while ( q ) : NEW_LINE INDENT temp = q [ 0 ] NEW_LINE q . pop ( 0 ) NEW_LINE if ( temp . left and temp . right ) : NEW_LINE INDENT if ( flag == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE q . append ( temp . right ) NEW_LINE DEDENT DEDENT elif ( not temp . left and not temp . right ) : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT elif ( not temp . left or not temp . right ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 7 ) NEW_LINE root . left = newNode ( 5 ) NEW_LINE root . left . left = newNode ( 8 ) NEW_LINE root . left . right = newNode ( 1 ) NEW_LINE root . right = newNode ( 6 ) NEW_LINE root . right . left = newNode ( 3 ) NEW_LINE root . right . right = newNode ( 9 ) NEW_LINE root . right . right . left = newNode ( 10 ) NEW_LINE root . right . right . right = newNode ( 13 ) NEW_LINE if CheckPerfectTree ( root ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.776337592926949,"rouge_l":0.8245322035608009}
{"id":1496,"predictions":["Set = set ( ) NEW_LINE def generateNumber ( count , a , n , num , k ) : NEW_LINE INDENT if ( count == k ) : NEW_LINE INDENT set ( num ) NEW_LINE return NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT generateNumber ( count + 1 , a , n , num + a [ i ] , k ) NEW_LINE DEDENT DEDENT def printDistinctIntegers ( k , a , n ) : NEW_LINE INDENT generateNumber ( 0 , a , n , 0 , k ) NEW_LINE print ( \" The \" , len ( set ) ) NEW_LINE DEDENT def printDistinctIntegers ( k , a , n ) : NEW_LINE INDENT generateNumber ( 0 , a , n , 0 , k ) NEW_LINE print ( \" The \" , len ( set ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 8 , 10 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE printDistinctIntegers ( k , arr , n ) NEW_LINE DEDENT"],"references":["s = set ( ) NEW_LINE def generateNumber ( count , a , n , num , k ) : NEW_LINE INDENT if k == count : NEW_LINE INDENT s . add ( num ) NEW_LINE return NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT generateNumber ( count + 1 , a , n , num + a [ i ] , k ) NEW_LINE DEDENT DEDENT def printDistinctIntegers ( k , a , n ) : NEW_LINE INDENT generateNumber ( 0 , a , n , 0 , k ) NEW_LINE print ( \" The \" , len ( s ) , \" distinct ▁ integers ▁ are : \" ) NEW_LINE for i in sorted ( s ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 3 , 8 , 17 , 5 ] NEW_LINE n , k = len ( a ) , 2 NEW_LINE printDistinctIntegers ( k , a , n ) NEW_LINE DEDENT"],"bleu":0.6922876893443556,"rouge_l":0.7945311826101958}
{"id":1497,"predictions":["import math NEW_LINE def findMin ( a , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += math . log ( a [ i ] ) NEW_LINE DEDENT x = math . exp ( sum \/ n ) NEW_LINE return x + 1 NEW_LINE DEDENT a = [ 3 , 2 , 1 , 4 ] NEW_LINE n = len ( a ) NEW_LINE print ( findMin ( a , n ) ) NEW_LINE"],"references":["import math as m NEW_LINE def findMin ( a , n ) : NEW_LINE INDENT _sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT _sum += m . log ( a [ i ] ) NEW_LINE DEDENT x = m . exp ( _sum \/ n ) NEW_LINE return int ( x + 1 ) NEW_LINE DEDENT a = [ 3 , 2 , 1 , 4 ] NEW_LINE n = len ( a ) NEW_LINE print ( findMin ( a , n ) ) NEW_LINE"],"bleu":0.760660487794717,"rouge_l":0.9106155547364541}
{"id":1498,"predictions":["def printPaths ( in range ( C ) : NEW_LINE INDENT for i in range ( C ) : NEW_LINE INDENT dfs ( input , \" \" , 0 , i , R , C ) NEW_LINE print ( ) NEW_LINE DEDENT DEDENT def dfs ( input , res , i , j , R , C ) : NEW_LINE INDENT if ( i == R ) : NEW_LINE INDENT print ( res , end = \" ▁ \" ) NEW_LINE return NEW_LINE DEDENT res = res + [ [ i ] [ j ] NEW_LINE for k in range ( C ) : NEW_LINE INDENT dfs ( Input , res , i + 1 , k , R , C ) NEW_LINE if ( i + 1 == R ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( i + 1 == R ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT Input = [ ' a ' , ' b ' ] , [ ' d ' , ' e ' ] , [ ' e ' ] ] NEW_LINE R = len ( Input ) NEW_LINE C = len ( Input ) NEW_LINE printPaths ( Input , R , C ) NEW_LINE DEDENT"],"references":["def printPaths ( inputchar , R , C ) : NEW_LINE INDENT for i in range ( C ) : NEW_LINE INDENT dfs ( inputchar , \" \" , 0 , i , R , C ) ; NEW_LINE print ( ) NEW_LINE DEDENT DEDENT def dfs ( inputchar , res , i , j , R , C ) : NEW_LINE INDENT if ( i == R ) : NEW_LINE INDENT print ( res , end = \" ▁ \" ) ; NEW_LINE return ; NEW_LINE DEDENT res = res + inputchar [ i ] [ j ] ; NEW_LINE for k in range ( C ) : NEW_LINE INDENT dfs ( inputchar , res , i + 1 , k , R , C ) ; NEW_LINE if ( i + 1 == R ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT inputchar = [ [ ' a ' , ' b ' ] , [ ' d ' , ' e ' ] ] ; NEW_LINE R = len ( inputchar ) ; NEW_LINE C = len ( inputchar [ 0 ] ) ; NEW_LINE printPaths ( inputchar , R , C ) ; NEW_LINE DEDENT"],"bleu":0.7343716814147543,"rouge_l":0.8701722437210714}
{"id":1499,"predictions":["mod = 10 ** 9 + 7 NEW_LINE def power ( a , m1 ) : NEW_LINE INDENT if ( m1 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( m1 == 1 ) : NEW_LINE INDENT return a NEW_LINE DEDENT elif ( m1 == 2 ) : NEW_LINE INDENT return ( ( 1L * a * a ) % mod ) NEW_LINE DEDENT elif ( m1 % 2 == 1 ) : NEW_LINE INDENT return ( ( 1L * a * power ( power ( a , m1 \/\/ 2 ) , 2 ) ) % mod ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( power ( a , m1 \/\/ 2 ) , 2 ) % mod NEW_LINE DEDENT DEDENT def inverse ( x ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , x + 1 ) : NEW_LINE INDENT ans = ( ( 1L * ans * i ) % mod ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def inverse ( n , r ) : NEW_LINE INDENT if ( r > n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = factorial ( n ) NEW_LINE ans = ( 1L * ans * inverse ( factorial ( r ) ) ) % mod NEW_LINE ans = ( ( 1L * ans ) ) % mod NEW_LINE ans = ( 1L * ans ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 4 NEW_LINE A = 1 NEW_LINE B = 3 NEW_LINE print ( number_of_sets ( N , A , B ) ) NEW_LINE DEDENT"],"references":["mod = 10 ** 9 + 7 NEW_LINE def power ( a , m1 ) : NEW_LINE INDENT if ( m1 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( m1 == 1 ) : NEW_LINE INDENT return a NEW_LINE DEDENT elif ( m1 == 2 ) : NEW_LINE INDENT return ( a * a ) % mod NEW_LINE DEDENT elif ( m1 & 1 ) : NEW_LINE INDENT return ( a * power ( power ( a , m1 \/\/ 2 ) , 2 ) ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT return power ( power ( a , m1 \/\/ 2 ) , 2 ) % mod NEW_LINE DEDENT DEDENT def factorial ( x ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , x + 1 ) : NEW_LINE INDENT ans = ( ans * i ) % mod NEW_LINE DEDENT return ans NEW_LINE DEDENT def inverse ( x ) : NEW_LINE INDENT return power ( x , mod - 2 ) NEW_LINE DEDENT def binomial ( n , r ) : NEW_LINE INDENT if ( r > n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = factorial ( n ) NEW_LINE ans = ( ans * inverse ( factorial ( r ) ) ) % mod NEW_LINE ans = ( ans * inverse ( factorial ( n - r ) ) ) % mod NEW_LINE return ans NEW_LINE DEDENT def number_of_sets ( n , a , b ) : NEW_LINE INDENT ans = power ( 2 , n ) NEW_LINE ans = ans - binomial ( n , a ) NEW_LINE if ( ans < 0 ) : NEW_LINE INDENT ans += mod NEW_LINE DEDENT ans = ans - binomial ( n , b ) NEW_LINE ans -= 1 NEW_LINE if ( ans < 0 ) : NEW_LINE INDENT ans += mod NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE A = 1 NEW_LINE B = 3 NEW_LINE print ( number_of_sets ( N , A , B ) ) NEW_LINE DEDENT"],"bleu":0.6243885060037702,"rouge_l":0.77858104402453}
{"id":1500,"predictions":["n , a = 5 , 2 NEW_LINE print ( sumOfSeries ( a , n ) ) NEW_LINE"],"references":["from __future__ import division NEW_LINE def sumOfSeries ( a , num ) : NEW_LINE INDENT res = 0 NEW_LINE prev = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT prev *= ( a \/ i ) NEW_LINE res = res + prev NEW_LINE DEDENT return res NEW_LINE DEDENT n = 5 NEW_LINE a = 2 NEW_LINE print ( round ( sumOfSeries ( a , n ) , 4 ) ) NEW_LINE"],"bleu":0.021154090225899605,"rouge_l":0.29629629629629634}
{"id":1501,"predictions":["def countNum ( arr , n ) : NEW_LINE INDENT s = dict ( ) NEW_LINE count = 0 NEW_LINE minm = - 10 ** 9 NEW_LINE minm = - 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s [ arr [ i ] ] = 1 NEW_LINE if arr [ i ] < minm : NEW_LINE INDENT minm = arr [ i ] NEW_LINE DEDENT if arr [ i ] > maxm : NEW_LINE INDENT maxm = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( minm , maxm + 1 ) : NEW_LINE INDENT if i not in s . keys ( ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 3 , 5 , 8 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countNum ( arr , n ) ) NEW_LINE"],"references":["def countNum ( arr , n ) : NEW_LINE INDENT s = dict ( ) NEW_LINE count , maxm , minm = 0 , - 10 ** 9 , 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s [ arr [ i ] ] = 1 NEW_LINE if ( arr [ i ] < minm ) : NEW_LINE INDENT minm = arr [ i ] NEW_LINE DEDENT if ( arr [ i ] > maxm ) : NEW_LINE INDENT maxm = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( minm , maxm + 1 ) : NEW_LINE INDENT if i not in s . keys ( ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 3 , 5 , 8 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countNum ( arr , n ) ) NEW_LINE"],"bleu":0.8734426439997492,"rouge_l":0.9444098088113051}
{"id":1502,"predictions":["MAX_CHAR = 256 NEW_LINE def isPresent ( s , q ) : NEW_LINE INDENT freq = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) ] += 1 NEW_LINE DEDENT for i in range ( len ( q ) ) : NEW_LINE INDENT freq [ ord ( q [ i ] ) ] += 1 NEW_LINE if ( freq [ q [ i ] ] < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" abctd \" NEW_LINE q = \" cat \" NEW_LINE if ( isPresent ( s , q ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["MAX_CHAR = 256 NEW_LINE def isPresent ( s , q ) : NEW_LINE INDENT freq = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) ] += 1 NEW_LINE DEDENT for i in range ( 0 , len ( q ) ) : NEW_LINE INDENT freq [ ord ( q [ i ] ) ] -= 1 NEW_LINE if ( freq [ ord ( q [ i ] ) ] < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT s = \" abctd \" NEW_LINE q = \" cat \" NEW_LINE if ( isPresent ( s , q ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.8451871056231514,"rouge_l":0.9289008042895444}
{"id":1503,"predictions":["def area_of_circle ( m , n ) : NEW_LINE INDENT square_of_radius = ( m * n ) \/ 4 NEW_LINE area = ( 3.142 * square_of_radius ) NEW_LINE return area NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 10 NEW_LINE m = 30 NEW_LINE print ( area_of_circle ( m , n ) ) NEW_LINE DEDENT"],"references":["def area_of_circle ( m , n ) : NEW_LINE INDENT square_of_radius = ( m * n ) \/ 4 NEW_LINE area = ( 3.141 * square_of_radius ) NEW_LINE return area NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE m = 30 NEW_LINE print ( area_of_circle ( m , n ) ) NEW_LINE DEDENT"],"bleu":0.8792036237320132,"rouge_l":0.953125}
{"id":1504,"predictions":["def printTwoSetBitNums ( n ) : NEW_LINE INDENT x = 1 NEW_LINE while ( n ) : NEW_LINE INDENT y = 0 NEW_LINE while ( y < x ) : NEW_LINE INDENT print ( ( ( 1 << x ) + \" ▁ \" , end = \" \" ) NEW_LINE n -= 1 NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT y += 1 NEW_LINE DEDENT x += 1 NEW_LINE DEDENT DEDENT n = 4 NEW_LINE printTwoSetBitNums ( n ) NEW_LINE"],"references":["def printTwoSetBitNums ( n ) : NEW_LINE INDENT x = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT y = 0 NEW_LINE while ( y < x ) : NEW_LINE INDENT print ( ( 1 << x ) + ( 1 << y ) , end = \" ▁ \" ) NEW_LINE n -= 1 NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT y += 1 NEW_LINE DEDENT x += 1 NEW_LINE DEDENT DEDENT printTwoSetBitNums ( 4 ) NEW_LINE"],"bleu":0.8250192919708981,"rouge_l":0.896551724137931}
{"id":1505,"predictions":["def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ [ 0 for x in range ( k + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return C [ n ] [ k ] NEW_LINE DEDENT def findMax ( n ) : NEW_LINE INDENT return binomialCoeff ( n , int ( n \/ 2 ) ) NEW_LINE DEDENT n = 5 NEW_LINE print ( findMax ( n ) ) NEW_LINE"],"references":["def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ [ 0 for i in range ( k + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return C [ n ] [ k ] NEW_LINE DEDENT def findMax ( n ) : NEW_LINE INDENT return binomialCoeff ( n , n \/\/ 2 ) NEW_LINE DEDENT n = 5 NEW_LINE print ( findMax ( n ) ) NEW_LINE"],"bleu":0.901294248592765,"rouge_l":0.970131885182312}
{"id":1506,"predictions":["def calculateSum ( arr , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT s = arr [ 0 ] NEW_LINE value = value NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT s = arr [ i ] NEW_LINE value = arr [ i - 1 ] NEW_LINE value = arr [ i - 1 ] [ 0 ] NEW_LINE if ( value == ' + ' ) : NEW_LINE INDENT sum += value NEW_LINE DEDENT else : NEW_LINE INDENT sum -= value NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT arr = [ \" 3\" , \" 4\" , \" - \" , \" - \" , \"7\" , \"7\" ] NEW_LINE n = len ( arr ) NEW_LINE print ( calculateSum ( arr , n ) ) NEW_LINE"],"references":["def calculateSum ( arr , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT s = arr [ 0 ] NEW_LINE value = int ( s ) NEW_LINE sum = value NEW_LINE for i in range ( 2 , n , 2 ) : NEW_LINE INDENT s = arr [ i ] NEW_LINE value = int ( s ) NEW_LINE operation = arr [ i - 1 ] [ 0 ] NEW_LINE if ( operation == ' + ' ) : NEW_LINE INDENT sum += value NEW_LINE DEDENT else : NEW_LINE INDENT sum -= value NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT arr = [ \"3\" , \" + \" , \"4\" , \" - \" , \"7\" , \" + \" , \"13\" ] NEW_LINE n = len ( arr ) NEW_LINE print ( calculateSum ( arr , n ) ) NEW_LINE"],"bleu":0.7730374876961669,"rouge_l":0.8630485243727201}
{"id":1507,"predictions":["def checkmaximumperfect ( x ) : NEW_LINE INDENT temp = x NEW_LINE n = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT x \/\/= 10 NEW_LINE n += 1 NEW_LINE DEDENT x = temp NEW_LINE sum = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT sum += pow ( x % 10 , n ) NEW_LINE x \/\/= 10 NEW_LINE DEDENT return ( sum == temp ) NEW_LINE DEDENT x = 9474 NEW_LINE if ( check + 1 ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def checkplusperfect ( x ) : NEW_LINE INDENT temp = x NEW_LINE n = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT x = x \/\/ 10 NEW_LINE n = n + 1 NEW_LINE DEDENT x = temp NEW_LINE sm = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT sm = sm + ( int ) ( math . pow ( x % 10 , n ) ) NEW_LINE x = x \/\/ 10 NEW_LINE DEDENT return ( sm == temp ) NEW_LINE DEDENT x = 9474 NEW_LINE if ( checkplusperfect ( x ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.658063612128152,"rouge_l":0.8136688668866886}
{"id":1508,"predictions":["def isPossible ( arr , p , n , m ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( p ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT if ( sum == ( n * m ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT n = 3 NEW_LINE m = 4 NEW_LINE arr = [ 6 , 3 , 2 , 1 ] NEW_LINE p = len ( arr ) NEW_LINE if ( isPossible ( arr , p , n , m ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def isPossible ( arr , p , n , m ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( p ) : NEW_LINE INDENT sum += arr [ i ] ; NEW_LINE DEDENT if ( sum == ( n * m ) ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 ; NEW_LINE m = 4 ; NEW_LINE arr = [ 6 , 3 , 2 , 1 ] ; NEW_LINE p = len ( arr ) ; NEW_LINE if ( isPossible ( arr , p , n , m ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"],"bleu":0.7037492112974046,"rouge_l":0.8944281524926685}
{"id":1509,"predictions":["def reverse ( n ) : NEW_LINE INDENT d , s = 0 , 0 NEW_LINE while ( n ) : NEW_LINE INDENT d = n % 10 NEW_LINE s = s * 10 + d NEW_LINE n = n \/\/ 10 NEW_LINE DEDENT return s NEW_LINE DEDENT def isPalin ( n ) : NEW_LINE INDENT return n == reverse ( n ) NEW_LINE DEDENT def sumOfArray ( arr , n ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( arr [ i ] > 10 ) and isPalin ( arr [ i ] ) ) : NEW_LINE INDENT s += arr [ i ] NEW_LINE DEDENT DEDENT return s NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 6 NEW_LINE arr = [ 12 , 322 , 11 , 44 , 9 , 1 ] NEW_LINE print ( sumOfArray ( arr , n ) ) NEW_LINE DEDENT"],"references":["def reverse ( n ) : NEW_LINE INDENT d = 0 ; s = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT d = n % 10 ; NEW_LINE s = s * 10 + d ; NEW_LINE n = n \/\/ 10 ; NEW_LINE DEDENT return s ; NEW_LINE DEDENT def isPalin ( n ) : NEW_LINE INDENT return n == reverse ( n ) ; NEW_LINE DEDENT def sumOfArray ( arr , n ) : NEW_LINE INDENT s = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( arr [ i ] > 10 ) and isPalin ( arr [ i ] ) ) : NEW_LINE INDENT s += arr [ i ] ; NEW_LINE DEDENT DEDENT return s ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 6 ; NEW_LINE arr = [ 12 , 313 , 11 , 44 , 9 , 1 ] ; NEW_LINE print ( sumOfArray ( arr , n ) ) ; NEW_LINE DEDENT"],"bleu":0.7710111487852636,"rouge_l":0.9304315476190478}
{"id":1510,"predictions":["def minCost ( arr , n ) : NEW_LINE INDENT count_even = 0 NEW_LINE count_odd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT count_even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_odd += 1 NEW_LINE DEDENT DEDENT return min ( count_even , count_odd ) NEW_LINE DEDENT arr = [ 2 , 4 , 3 , 1 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minCost ( arr , n ) ) NEW_LINE"],"references":["def minCost ( arr , n ) : NEW_LINE INDENT count_even = 0 NEW_LINE count_odd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT count_even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_odd += 1 NEW_LINE DEDENT DEDENT return min ( count_even , count_odd ) NEW_LINE DEDENT arr = [ 2 , 4 , 3 , 1 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minCost ( arr , n ) ) NEW_LINE"],"bleu":1.0,"rouge_l":1.0}
{"id":1511,"predictions":["def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return gcd ( a - b , b ) NEW_LINE DEDENT return gcd ( a , b - a ) NEW_LINE DEDENT def numOfPairs ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( coprime ( arr [ i ] , arr [ j ] ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 1 , 2 , 5 , 4 , 8 , 3 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE print ( numOfPairs ( arr , n ) ) NEW_LINE"],"references":["def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return gcd ( a - b , b ) NEW_LINE DEDENT return gcd ( a , b - a ) NEW_LINE DEDENT def coprime ( a , b ) : NEW_LINE INDENT return ( gcd ( a , b ) == 1 ) NEW_LINE DEDENT def numOfPairs ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( coprime ( arr [ i ] , arr [ j ] ) ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 1 , 2 , 5 , 4 , 8 , 3 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE print ( numOfPairs ( arr , n ) ) NEW_LINE"],"bleu":0.8260104978226489,"rouge_l":0.9060702326779427}
{"id":1512,"predictions":["def countSubarrays ( a , n , m ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT odd = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if ( a [ j ] % 2 == 0 ) : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT if ( odd == m ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT a = [ 2 , 2 , 5 , 6 , 9 , 2 , 11 ] NEW_LINE n = len ( a ) NEW_LINE m = 2 NEW_LINE print ( countSubarrays ( a , n , m ) ) NEW_LINE"],"references":["def countSubarrays ( a , n , m ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT odd = 0 ; NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if ( a [ j ] % 2 ) : NEW_LINE INDENT odd += 1 ; NEW_LINE DEDENT if ( odd == m ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT a = [ 2 , 2 , 5 , 6 , 9 , 2 , 11 ] ; NEW_LINE n = len ( a ) ; NEW_LINE m = 2 ; NEW_LINE print ( countSubarrays ( a , n , m ) ) ; NEW_LINE"],"bleu":0.8130714577587537,"rouge_l":0.9513906940473096}
{"id":1513,"predictions":["import math NEW_LINE def divide ( n , m ) : NEW_LINE INDENT print ( \" Rearer ▁ = ▁ \" , ( n & ( m - 1 ) ) ) NEW_LINE print ( \" Qder ▁ = ▁ \" , ( n >= ( m ) \/\/ math . gcd ( 2 ) ) ) NEW_LINE DEDENT n = 43 NEW_LINE m = 8 NEW_LINE divide ( n , m ) NEW_LINE"],"references":["import math NEW_LINE def divide ( n , m ) : NEW_LINE INDENT print ( \" Remainder ▁ = ▁ \" , ( ( n ) & ( m - 1 ) ) ) NEW_LINE print ( \" Quotient ▁ = ▁ \" , ( n >> ( int ) ( math . log2 ( m ) ) ) ) NEW_LINE DEDENT n = 43 NEW_LINE m = 8 NEW_LINE divide ( n , m ) NEW_LINE"],"bleu":0.7435232360937387,"rouge_l":0.8842492427520554}
{"id":1514,"predictions":["maxlen = 1001 NEW_LINE def generateSubStrings ( s , mpp ) : NEW_LINE INDENT l = len ( s ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT temp = \" \" NEW_LINE for j in range ( i , l ) : NEW_LINE INDENT temp += s [ j ] NEW_LINE if temp in mpp : NEW_LINE INDENT temp += s [ temp ] NEW_LINE DEDENT else : NEW_LINE INDENT mpp [ temp ] [ temp ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT def binomialCoeff ( C ) : NEW_LINE INDENT for i in range ( 1 , 100 ) : NEW_LINE INDENT for j in range ( 100 ) : NEW_LINE INDENT if j == 0 or j == i : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT def answerQuery ( mpp , C , k ) : NEW_LINE INDENT ans = 0 NEW_LINE for it in mpp : NEW_LINE INDENT if ( mpp [ it ] >= k ) : NEW_LINE INDENT ans += C [ it ] [ k ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" aabaab \" NEW_LINE mpp = dict ( ) NEW_LINE generateSubStrings ( s , mpp ) NEW_LINE C = [ [ 0 for x in range ( maxlen ) ] for y in range ( maxlen ) ] NEW_LINE query = [ 2 , 3 , 4 ] NEW_LINE q = len ( queries ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT print ( answerQuery ( mpp , C , queries [ i ] ) ) NEW_LINE DEDENT DEDENT"],"references":["from collections import defaultdict NEW_LINE maxlen = 100 NEW_LINE def generateSubStrings ( s , mpp ) : NEW_LINE INDENT l = len ( s ) NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT temp = \" \" NEW_LINE for j in range ( i , l ) : NEW_LINE INDENT temp += s [ j ] NEW_LINE mpp [ temp ] += 1 NEW_LINE DEDENT DEDENT DEDENT def binomialCoeff ( C ) : NEW_LINE INDENT for i in range ( 0 , 100 ) : NEW_LINE INDENT for j in range ( 0 , 100 ) : NEW_LINE INDENT if j == 0 or j == i : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT def answerQuery ( mpp , C , k ) : NEW_LINE INDENT ans = 0 NEW_LINE for it in mpp : NEW_LINE INDENT if mpp [ it ] >= k : NEW_LINE INDENT ans += C [ mpp [ it ] ] [ k ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" aabaab \" NEW_LINE mpp = defaultdict ( lambda : 0 ) NEW_LINE generateSubStrings ( s , mpp ) NEW_LINE C = [ [ 0 for i in range ( maxlen ) ] for j in range ( maxlen ) ] NEW_LINE binomialCoeff ( C ) NEW_LINE queries = [ 2 , 3 , 4 ] NEW_LINE q = len ( queries ) NEW_LINE for i in range ( 0 , q ) : NEW_LINE INDENT print ( answerQuery ( mpp , C , queries [ i ] ) ) NEW_LINE DEDENT DEDENT"],"bleu":0.8355436046378426,"rouge_l":0.903178533528728}
{"id":1515,"predictions":["def findProduct ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE prod = 1 * arr [ 0 ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( arr [ i ] != arr [ i + 1 ] ) : NEW_LINE INDENT prod = prod * arr [ i + 1 ] NEW_LINE DEDENT DEDENT return prod NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 1 , 1 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findProduct ( arr , n ) ) NEW_LINE"],"references":["def findProduct ( arr , n ) : NEW_LINE INDENT sorted ( arr ) NEW_LINE prod = 1 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( arr [ i - 1 ] != arr [ i ] ) : NEW_LINE INDENT prod = prod * arr [ i ] NEW_LINE DEDENT DEDENT return prod ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 1 , 1 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findProduct ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.7146106452557182,"rouge_l":0.8383969907407409}
{"id":1516,"predictions":["def SieveofSundaram ( n ) : NEW_LINE INDENT nNew = ( n - 2 ) \/\/ 2 NEW_LINE marked = [ False for i in range ( nNew + 1 ) ] NEW_LINE for i in range ( 1 , nNew + 1 ) : NEW_LINE INDENT j = i NEW_LINE while ( ( ( i + j + 2 * i * j ) <= nNew ) : NEW_LINE INDENT marked [ i + j + 2 * i * i * j ] = True NEW_LINE j += 1 NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT print ( 2 , end = \" ▁ \" ) NEW_LINE DEDENT for i in range ( 1 , nNew + 1 ) : NEW_LINE INDENT if ( marked [ i ] == False ) : NEW_LINE INDENT print ( 2 * i + 1 , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT n = 27 NEW_LINE SieveOfSundaram ( n ) NEW_LINE"],"references":["def SieveOfSundaram ( n ) : NEW_LINE INDENT nNew = int ( ( n - 2 ) \/ 2 ) ; NEW_LINE marked = [ 0 ] * ( nNew + 1 ) ; NEW_LINE for i in range ( 1 , nNew + 1 ) : NEW_LINE INDENT j = i ; NEW_LINE while ( ( i + j + 2 * i * j ) <= nNew ) : NEW_LINE INDENT marked [ i + j + 2 * i * j ] = 1 ; NEW_LINE j += 1 ; NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT print ( 2 , end = \" ▁ \" ) ; NEW_LINE DEDENT for i in range ( 1 , nNew + 1 ) : NEW_LINE INDENT if ( marked [ i ] == 0 ) : NEW_LINE INDENT print ( ( 2 * i + 1 ) , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT DEDENT n = 20 ; NEW_LINE SieveOfSundaram ( n ) ; NEW_LINE"],"bleu":0.7439957184975371,"rouge_l":0.8832267769838287}
{"id":1517,"predictions":["def solve ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT num = 2 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT num = ( num * 10 ) + 3 NEW_LINE DEDENT print ( num ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 NEW_LINE solve ( n ) NEW_LINE DEDENT"],"references":["def solve ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT print ( - 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT num = 2 ; NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT num = ( num * 10 ) + 3 ; NEW_LINE DEDENT print ( num ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 ; NEW_LINE solve ( n ) ; NEW_LINE DEDENT"],"bleu":0.8313343464890004,"rouge_l":0.9600074060359194}
{"id":1518,"predictions":["def minimumOperations ( arr , n ) : NEW_LINE INDENT brr = [ 0 , 0 , 0 , 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT brr [ arr [ i ] % 4 ] += 1 NEW_LINE DEDENT if ( ( brr [ 1 ] + 2 * brr [ 2 ] + 3 * brr [ 3 ] ) % 4 == 0 ) : NEW_LINE INDENT min_posr = min ( brr [ 3 ] , brr [ 1 ] ) NEW_LINE brr [ 3 ] -= min_opr NEW_LINE brr [ 1 ] -= min_opr NEW_LINE brr [ 2 ] -= min_opr NEW_LINE brr [ 2 ] %= 2 NEW_LINE if ( brr [ 3 ] == 1 ) : NEW_LINE INDENT min_opr += 2 NEW_LINE brr [ 2 ] = 0 NEW_LINE if ( brr [ 3 ] == 1 ) : NEW_LINE INDENT brr [ 3 ] -= 2 NEW_LINE DEDENT if ( brr [ 1 ] == 1 ) : NEW_LINE INDENT brr [ 1 ] -= 2 NEW_LINE DEDENT DEDENT if ( brr [ 1 ] == 1 ) : NEW_LINE INDENT min_opr += ( brr [ 1 ] \/\/ 4 ) * 3 NEW_LINE DEDENT return min_opr NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 1 , 2 , 3 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minimumOperations ( arr , n ) ) NEW_LINE DEDENT"],"references":["def minimumOperations ( arr , n ) : NEW_LINE INDENT brr = [ 0 , 0 , 0 , 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT brr [ arr [ i ] % 4 ] += 1 ; NEW_LINE DEDENT if ( ( brr [ 1 ] + 2 * brr [ 2 ] + 3 * brr [ 3 ] ) % 4 == 0 ) : NEW_LINE INDENT min_opr = min ( brr [ 3 ] , brr [ 1 ] ) NEW_LINE brr [ 3 ] -= min_opr NEW_LINE brr [ 1 ] -= min_opr NEW_LINE min_opr += brr [ 2 ] \/\/ 2 NEW_LINE brr [ 2 ] %= 2 NEW_LINE if ( brr [ 2 ] ) : NEW_LINE INDENT min_opr += 2 NEW_LINE brr [ 2 ] = 0 NEW_LINE if ( brr [ 3 ] ) : NEW_LINE INDENT brr [ 3 ] -= 2 NEW_LINE DEDENT if ( brr [ 1 ] ) : NEW_LINE INDENT brr [ 1 ] -= 2 NEW_LINE DEDENT DEDENT if ( brr [ 1 ] ) : NEW_LINE INDENT min_opr += ( brr [ 1 ] \/\/ 4 ) * 3 NEW_LINE DEDENT if ( brr [ 3 ] ) : NEW_LINE INDENT min_opr += ( brr [ 3 ] \/\/ 4 ) * 3 NEW_LINE DEDENT return min_opr NEW_LINE DEDENT return - 1 NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 1 , 2 , 3 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minimumOperations ( arr , n ) ) NEW_LINE"],"bleu":0.8324810309351539,"rouge_l":0.8842208709538726}
{"id":1519,"predictions":["import sys NEW_LINE def minimumFn ( arr ) : NEW_LINE INDENT minN = sys . maxsize - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( arr ) : NEW_LINE INDENT if ( arr [ i ] [ j ] == 0 ) : NEW_LINE INDENT arr [ i ] [ j ] = sys . maxsize NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT min = minFn ( arr [ i ] ) NEW_LINE for j in range ( arr ) : NEW_LINE INDENT if ( ( arr [ i ] [ j ] != min ) or ( arr [ i ] [ j ] == 10 ** 9 ) ) : NEW_LINE INDENT arr [ i ] [ j ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT min = 0 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( arr ) : NEW_LINE INDENT if ( ( arr [ i ] [ j ] != min ) or ( arr [ i ] [ j ] == 10 ** 9 ) ) : NEW_LINE INDENT arr [ i ] [ j ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT min = 0 NEW_LINE DEDENT DEDENT DEDENT for i in range ( len ( arr ) ) : NEW_LINE INDENT for j in range ( len ( arr ) ) : NEW_LINE INDENT print ( arr [ i ] [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ [ 1 , 2 , 4 , 0 ] , [ 0 , 0 , 0 , 5 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ] NEW_LINE minimizeGraph ( arr ) NEW_LINE DEDENT"],"references":["def minFn ( arr ) : NEW_LINE INDENT minimum = float ( ' inf ' ) NEW_LINE for i in range ( 0 , 4 ) : NEW_LINE INDENT if minimum > arr [ i ] : NEW_LINE INDENT minimum = arr [ i ] NEW_LINE DEDENT DEDENT return minimum NEW_LINE DEDENT def minimizeGraph ( arr ) : NEW_LINE INDENT for i in range ( 0 , 4 ) : NEW_LINE INDENT for j in range ( 0 , 4 ) : NEW_LINE INDENT if arr [ i ] [ j ] == 0 : NEW_LINE INDENT arr [ i ] [ j ] = float ( ' inf ' ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( 0 , 4 ) : NEW_LINE INDENT minimum = minFn ( arr [ i ] ) NEW_LINE for j in range ( 0 , 4 ) : NEW_LINE INDENT if ( ( not ( arr [ i ] [ j ] == minimum ) ) or ( arr [ i ] [ j ] == float ( ' inf ' ) ) ) : NEW_LINE INDENT arr [ i ] [ j ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT minimum = 0 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 0 , 4 ) : NEW_LINE INDENT for j in range ( 0 , 4 ) : NEW_LINE INDENT print ( arr [ i ] [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ [ 1 , 2 , 4 , 0 ] , [ 0 , 0 , 0 , 5 ] , [ 0 , 2 , 0 , 3 ] , [ 0 , 0 , 0 , 0 ] ] NEW_LINE minimizeGraph ( arr ) NEW_LINE DEDENT"],"bleu":0.6674237952766038,"rouge_l":0.7454737477368737}
{"id":1520,"predictions":["def getNumToAdd ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE d = arr [ 1 ] - arr [ 0 ] NEW_LINE numToAdd = - 1 NEW_LINE numAdded = 0 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT diff = arr [ i ] - arr [ i - 1 ] NEW_LINE if ( diff != d ) : NEW_LINE INDENT if ( numAdded ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( diff == 2 * d ) : NEW_LINE INDENT numToAdd = arr [ i ] - d NEW_LINE numAdded = True NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT DEDENT if ( numToAdd == - 1 ) : NEW_LINE INDENT return ( arr [ n - 1 ] + d ) NEW_LINE DEDENT return numToAdded NEW_LINE DEDENT arr = [ 1 , 3 , 5 , 5 , 7 , 11 , 15 ] NEW_LINE n = len ( arr ) NEW_LINE print ( getNumToAdd ( arr , n ) ) NEW_LINE"],"references":["def getNumToAdd ( arr , n ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE d = arr [ 1 ] - arr [ 0 ] NEW_LINE numToAdd = - 1 NEW_LINE numAdded = False NEW_LINE for i in range ( 2 , n , 1 ) : NEW_LINE INDENT diff = arr [ i ] - arr [ i - 1 ] NEW_LINE if ( diff != d ) : NEW_LINE INDENT if ( numAdded ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( diff == 2 * d ) : NEW_LINE INDENT numToAdd = arr [ i ] - d NEW_LINE numAdded = True NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT DEDENT if ( numToAdd == - 1 ) : NEW_LINE INDENT return ( arr [ n - 1 ] + d ) NEW_LINE DEDENT return numToAdd NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 3 , 5 , 7 , 11 , 13 , 15 ] NEW_LINE n = len ( arr ) NEW_LINE print ( getNumToAdd ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.8417436433564323,"rouge_l":0.9212625148481248}
{"id":1521,"predictions":["PI = 3.14159265 NEW_LINE def findAnglesA ( a , b , c ) : NEW_LINE INDENT A = acos ( ( ( b * b + c - a * a ) \/ ( 2 * b * c ) ) NEW_LINE return A * 180 \/ PI NEW_LINE DEDENT def findAnglesB ( a , b , c ) : NEW_LINE INDENT B = acos ( ( a * a + c * c - b * b ) \/ ( 2 * a * c ) ) NEW_LINE return A * 180 \/ 180 NEW_LINE DEDENT def printAnglesB ( a , b , c ) : NEW_LINE INDENT B = a NEW_LINE y = b NEW_LINE z = c NEW_LINE A = findAnglesA ( x , y , z ) NEW_LINE B = findAnglesA ( x , y , z ) NEW_LINE print ( \" Angles ▁ are ▁ A ▁ = ▁ \" , A , \" , ▁ B ▁ = ▁ \" , B , \" , ▁ C ▁ = ▁ \" , ( x , y , z ) ) NEW_LINE print ( \" Angles ▁ = ▁ \" , ( x , y , z ) ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( n == 2 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( n == 2 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 0 NEW_LINE c = 0 NEW_LINE if ( n == 2 ) : NEW_LINE INDENT b = 0 NEW_LINE c = 0 NEW_LINE if ( n == 2 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT print ( - 1 ) NEW_LINE DEDENT"],"references":["import math NEW_LINE PI = 3.1415926535 NEW_LINE def findAnglesA ( a , b , c ) : NEW_LINE INDENT A = math . acos ( ( b * b + c * c - a * a ) \/ ( 2 * b * c ) ) NEW_LINE return A * 180 \/ PI NEW_LINE DEDENT def findAnglesB ( a , b , c ) : NEW_LINE INDENT B = math . acos ( ( a * a + c * c - b * b ) \/ ( 2 * a * c ) ) NEW_LINE return B * 180 \/ PI NEW_LINE DEDENT def printAngles ( a , b , c ) : NEW_LINE INDENT x = a NEW_LINE y = b NEW_LINE z = c NEW_LINE A = findAnglesA ( x , y , z ) NEW_LINE B = findAnglesB ( x , y , z ) NEW_LINE print ( \" Angles ▁ are ▁ A ▁ = ▁ \" , A , \" , ▁ B ▁ = ▁ \" , B , \" , ▁ C ▁ = ▁ \" , \"90 ▁ \" ) NEW_LINE DEDENT def printOtherSides ( n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT else : NEW_LINE INDENT b = ( n * n - 1 ) \/\/ 2 NEW_LINE c = ( n * n + 1 ) \/\/ 2 NEW_LINE print ( \" Side ▁ b ▁ = ▁ \" , b , \" ▁ Side ▁ c ▁ = ▁ \" , c ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( n == 2 ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT else : NEW_LINE INDENT b = n * n \/\/ 4 - 1 ; NEW_LINE c = n * n \/\/ 4 + 1 ; NEW_LINE print ( \" Side ▁ b ▁ = ▁ \" , b , \" , ▁ Side ▁ c ▁ = ▁ \" , c ) NEW_LINE DEDENT DEDENT printAngles ( n , b , c ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 12 NEW_LINE printOtherSides ( a ) NEW_LINE DEDENT"],"bleu":0.5969393399195787,"rouge_l":0.6825058887479616}
{"id":1522,"predictions":["import math NEW_LINE def MaximumHeight ( a , n ) : NEW_LINE INDENT return math . floor ( ( - 1 + math . sqrt ( 1 + ( 8 * n ) ) ) \/ 2 ) NEW_LINE DEDENT arr = [ 40 , 100 , 20 , 30 ] NEW_LINE n = len ( arr ) NEW_LINE print ( MaximumHeight ( arr , n ) ) NEW_LINE"],"references":["import math NEW_LINE def MaximumHeight ( a , n ) : NEW_LINE INDENT return ( - 1 + int ( math . sqrt ( 1 + ( 8 * n ) ) ) ) \/\/ 2 NEW_LINE DEDENT arr = [ 40 , 100 , 20 , 30 ] NEW_LINE n = len ( arr ) NEW_LINE print ( MaximumHeight ( arr , n ) ) NEW_LINE"],"bleu":0.8393623631982747,"rouge_l":0.9289340101522842}
{"id":1523,"predictions":["def firstElement ( arr , n , k ) : NEW_LINE INDENT count_map = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT a = 0 NEW_LINE if a [ i ] in count_map . keys ( ) : NEW_LINE INDENT a = count_map [ arr [ i ] ] NEW_LINE DEDENT count_map [ arr [ i ] ] = a + 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if count_map [ arr [ i ] ] == k : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 1 , 7 , 4 , 3 , 4 , 8 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE print ( firstElement ( arr , n , k ) ) NEW_LINE"],"references":["def firstElement ( arr , n , k ) : NEW_LINE INDENT count_map = { } ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] in count_map . keys ( ) ) : NEW_LINE INDENT count_map [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_map [ arr [ i ] ] = 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( count_map [ arr [ i ] ] == k ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 7 , 4 , 3 , 4 , 8 , 7 ] ; NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE print ( firstElement ( arr , n , k ) ) NEW_LINE DEDENT"],"bleu":0.6310231186618412,"rouge_l":0.8196476560167214}
{"id":1524,"predictions":["def calculate ( a , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT r = i + 1 NEW_LINE for j in range ( r , n ) : NEW_LINE INDENT if ( a [ i ] == a [ j ] ) : NEW_LINE INDENT r += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT d = r - i NEW_LINE ans += ( d * ( d + 1 ) \/ 2 ) NEW_LINE i = r - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT a = [ 2 , 4 , 5 , 3 , 3 , 3 ] NEW_LINE print ( calculate ( a ) ) NEW_LINE"],"references":["def calculate ( a , n ) : NEW_LINE INDENT ans = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT r = i + 1 ; NEW_LINE for j in range ( r , n ) : NEW_LINE INDENT if ( a [ i ] == a [ j ] ) : NEW_LINE INDENT r = r + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT d = r - i ; NEW_LINE ans = ans + ( d * ( d + 1 ) \/ 2 ) ; NEW_LINE i = r - 1 ; NEW_LINE i = i + 1 ; NEW_LINE DEDENT return int ( ans ) ; NEW_LINE DEDENT a = [ 2 , 4 , 5 , 3 , 3 , 3 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( calculate ( a , n ) ) ; NEW_LINE"],"bleu":0.583237618251671,"rouge_l":0.8139664183253642}
{"id":1525,"predictions":["def nth_group ( n ) : NEW_LINE INDENT return n * ( 2 * pow ( n , 2 ) + 1 ) NEW_LINE DEDENT N = 5 NEW_LINE print ( nth_group ( N ) ) NEW_LINE"],"references":["def nth_group ( n ) : NEW_LINE INDENT return n * ( 2 * pow ( n , 2 ) + 1 ) NEW_LINE DEDENT N = 5 NEW_LINE print ( nth_group ( N ) ) NEW_LINE"],"bleu":1.0,"rouge_l":1.0}
{"id":1526,"predictions":["def printAnagramsAre ( wordArr , size ) : NEW_LINE INDENT word = [ ] NEW_LINE size = len ( word ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT array . append ( ( ( string [ i ] [ i ] ) ) NEW_LINE DEDENT DEDENT def printAnagramsAre ( wordArr , size ) : NEW_LINE INDENT dupArray . sort ( ) NEW_LINE DEDENT def printAnagramsAre ( wordArr , size ) : NEW_LINE INDENT dupArray . sort ( ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT print ( wordArr [ i ] [ 0 ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT wordArr = [ \" cat \" , \" dog \" , \" pet \" pet \" , \" pet \" , \" pet \" ] NEW_LINE size = len ( wordArr ) NEW_LINE printAnagramsairs . sort ( ) NEW_LINE DEDENT"],"references":["class Word ( object ) : NEW_LINE INDENT def __init__ ( self , string , index ) : NEW_LINE INDENT self . string = string NEW_LINE self . index = index NEW_LINE DEDENT DEDENT def createDupArray ( string , size ) : NEW_LINE INDENT dupArray = [ ] NEW_LINE for i in xrange ( size ) : NEW_LINE INDENT dupArray . append ( Word ( string [ i ] , i ) ) NEW_LINE DEDENT return dupArray NEW_LINE DEDENT def printAnagramsTogether ( wordArr , size ) : NEW_LINE INDENT dupArray = createDupArray ( wordArr , size ) NEW_LINE for i in xrange ( size ) : NEW_LINE INDENT dupArray [ i ] . string = ' ' . join ( sorted ( dupArray [ i ] . string ) ) NEW_LINE DEDENT dupArray = sorted ( dupArray , key = lambda k : k . string ) NEW_LINE for word in dupArray : NEW_LINE INDENT print wordArr [ word . index ] , NEW_LINE DEDENT DEDENT wordArr = [ \" cat \" , \" dog \" , \" tac \" , \" god \" , \" act \" ] NEW_LINE size = len ( wordArr ) NEW_LINE printAnagramsTogether ( wordArr , size ) NEW_LINE"],"bleu":0.3936520477657149,"rouge_l":0.553143255732845}
{"id":1527,"predictions":["import sys NEW_LINE def minAbsSumPair ( arr , n ) : NEW_LINE INDENT min_sum = 999999 NEW_LINE l = 0 NEW_LINE r = n - 1 NEW_LINE min_l = n - 1 NEW_LINE min_r = n - 1 NEW_LINE if ( n < 2 ) : NEW_LINE INDENT print ( \" Invalid ▁ Input \" ) NEW_LINE return NEW_LINE DEDENT min ( arr , l , r ) NEW_LINE while ( l < r ) : NEW_LINE INDENT sum = arr [ l ] + arr [ r ] NEW_LINE if ( sum < min_sum ) : NEW_LINE INDENT min_sum = sum NEW_LINE min_l = l NEW_LINE min_r = r NEW_LINE DEDENT if ( sum < 0 ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT DEDENT print ( \" The ▁ two ▁ elements ▁ with \" , arr [ min_l ] , \" and \" and \" , arr [ min_r ] ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 1 , 64 , - 10 , 7 , 0 , 85 ] NEW_LINE minAbsSumPair ( arr , len ( arr ) ) NEW_LINE DEDENT"],"references":["def partition ( arr , si , ei ) : NEW_LINE INDENT x = arr [ ei ] NEW_LINE i = ( si - 1 ) NEW_LINE for j in range ( si , ei ) : NEW_LINE INDENT if ( arr [ j ] <= x ) : NEW_LINE INDENT i += 1 NEW_LINE arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE DEDENT DEDENT arr [ i + 1 ] , arr [ ei ] = arr [ ei ] , arr [ i + 1 ] NEW_LINE return ( i + 1 ) NEW_LINE DEDENT def quickSort ( arr , si , ei ) : NEW_LINE INDENT pi = 0 NEW_LINE if ( si < ei ) : NEW_LINE INDENT pi = partition ( arr , si , ei ) NEW_LINE quickSort ( arr , si , pi - 1 ) NEW_LINE quickSort ( arr , pi + 1 , ei ) NEW_LINE DEDENT DEDENT def minAbsSumPair ( arr , n ) : NEW_LINE INDENT sum , min_sum = 0 , 10 ** 9 NEW_LINE l = 0 NEW_LINE r = n - 1 NEW_LINE min_l = l NEW_LINE min_r = n - 1 NEW_LINE if ( n < 2 ) : NEW_LINE INDENT print ( \" Invalid ▁ Input \" , end = \" \" ) NEW_LINE return NEW_LINE DEDENT quickSort ( arr , l , r ) NEW_LINE while ( l < r ) : NEW_LINE INDENT sum = arr [ l ] + arr [ r ] NEW_LINE if ( abs ( sum ) < abs ( min_sum ) ) : NEW_LINE INDENT min_sum = sum NEW_LINE min_l = l NEW_LINE min_r = r NEW_LINE DEDENT if ( sum < 0 ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT DEDENT print ( \" The ▁ two ▁ elements ▁ whose ▁ sum ▁ is ▁ minimum ▁ are \" , arr [ min_l ] , \" and \" , arr [ min_r ] ) NEW_LINE DEDENT arr = [ 1 , 60 , - 10 , 70 , - 80 , 85 ] NEW_LINE n = len ( arr ) NEW_LINE minAbsSumPair ( arr , n ) NEW_LINE"],"bleu":0.337052015795195,"rouge_l":0.562536023054755}
{"id":1528,"predictions":["def countFreq ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in mp . keys ( ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( mp [ arr [ i ] ] != - 1 ) : NEW_LINE INDENT print ( arr [ i ] , mp [ arr [ i ] ] ) NEW_LINE mp [ arr [ i ] ] ] = - 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 10 , 20 , 20 , 10 , 10 , 20 , 20 , 5 , 20 ] NEW_LINE n = len ( arr ) NEW_LINE countFreq ( arr , n ) NEW_LINE DEDENT"],"references":["def countFreq ( arr , n ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] not in mp : NEW_LINE INDENT mp [ arr [ i ] ] = 0 NEW_LINE DEDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( mp [ arr [ i ] ] != - 1 ) : NEW_LINE INDENT print ( arr [ i ] , mp [ arr [ i ] ] ) NEW_LINE DEDENT mp [ arr [ i ] ] = - 1 NEW_LINE DEDENT DEDENT arr = [ 10 , 20 , 20 , 10 , 10 , 20 , 5 , 20 ] NEW_LINE n = len ( arr ) NEW_LINE countFreq ( arr , n ) NEW_LINE"],"bleu":0.754408061266988,"rouge_l":0.8950196321554039}
{"id":1529,"predictions":["import math NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT sr = math . sqrt ( x ) NEW_LINE return ( ( sr - math . floor ( sr ) ) == 0 ) NEW_LINE DEDENT def isFibonacci ( n ) : NEW_LINE INDENT return ( ( sr - math . floor ( sr ) ) ) == 0 NEW_LINE DEDENT def totalPairs ( a , b , n , m ) : NEW_LINE INDENT return ( isPerfectSquare ( 5 * n * n + 4 ) or isPerfectSquare ( 5 * n - 4 ) ) ) NEW_LINE DEDENT def totalPairs ( a , b , n , m ) : NEW_LINE INDENT s = [ ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if isFibonacci ( a [ i ] + b [ j ] ) == True : NEW_LINE INDENT if ( a [ i ] < b [ j ] ) : NEW_LINE INDENT s . append ( [ a [ i ] , b [ j ] ] ) ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( checkDuplicates ( s , ( b [ j ] , a [ i ] ) ) ) : NEW_LINE INDENT s . append ( [ b [ j ] , a [ i ] ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return len ( s ) NEW_LINE DEDENT def checkDuplicates ( a , b , n , m ) : NEW_LINE INDENT for p in range ( a ) : NEW_LINE INDENT if ( p [ 0 ] == newPair [ 0 ] and p [ 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT a = [ 99 , 1 , 33 , 2 ] NEW_LINE b = [ 1 , 11 , 2 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( a ) NEW_LINE print ( totalPairs ( a , b , n , m ) ) NEW_LINE"],"references":["from math import sqrt , floor NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT sr = sqrt ( x ) NEW_LINE return ( ( sr - floor ( sr ) ) == 0 ) NEW_LINE DEDENT def isFibonacci ( n ) : NEW_LINE INDENT return ( isPerfectSquare ( 5 * n * n + 4 ) or isPerfectSquare ( 5 * n * n - 4 ) ) NEW_LINE DEDENT def totalPairs ( a , b , n , m ) : NEW_LINE INDENT s = set ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( isFibonacci ( a [ i ] + b [ j ] ) == True ) : NEW_LINE INDENT if ( a [ i ] < b [ j ] ) : NEW_LINE INDENT s . add ( ( a [ i ] , b [ j ] ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT s . add ( ( b [ j ] , a [ i ] ) ) ; NEW_LINE DEDENT DEDENT DEDENT DEDENT return len ( s ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 99 , 1 , 33 , 2 ] ; NEW_LINE b = [ 1 , 11 , 2 ] ; NEW_LINE n = len ( a ) ; NEW_LINE m = len ( b ) ; NEW_LINE print ( totalPairs ( a , b , n , m ) ) ; NEW_LINE DEDENT"],"bleu":0.5855261749890305,"rouge_l":0.7677118368232613}
{"id":1530,"predictions":["def countSolutions ( n ) : NEW_LINE INDENT res = 0 NEW_LINE x = 0 NEW_LINE while ( x * x < n ) : NEW_LINE INDENT if ( x * x + y * y ) < n : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT print ( \" Total ▁ Number ▁ of ▁ distinct ▁ \" , countSolutions ( 6 ) ) NEW_LINE"],"references":["def countSolutions ( n ) : NEW_LINE INDENT res = 0 NEW_LINE x = 0 NEW_LINE while ( x * x < n ) : NEW_LINE INDENT y = 0 NEW_LINE while ( x * x + y * y < n ) : NEW_LINE INDENT res = res + 1 NEW_LINE y = y + 1 NEW_LINE DEDENT x = x + 1 NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( \" Total ▁ Number ▁ of ▁ distinct ▁ Non - Negative ▁ pairs ▁ is ▁ \" , countSolutions ( 6 ) ) NEW_LINE DEDENT"],"bleu":0.46690440626314816,"rouge_l":0.7187662450181944}
{"id":1531,"predictions":["def findLength ( string , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT l = i NEW_LINE r = i + 1 NEW_LINE lsum = 0 NEW_LINE rsum = 0 NEW_LINE while ( r < n and l >= 0 ) : NEW_LINE INDENT lsum += ord ( string [ l ] ) - ord ( '0' ) NEW_LINE rsum += ord ( string [ l ] ) - ord ( '0' ) NEW_LINE if ( lsum == rsum ) : NEW_LINE INDENT ans = max ( ans , r - l + 1 ) NEW_LINE DEDENT l -= 1 NEW_LINE r += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \"123123123\" NEW_LINE print ( \" Length ▁ of ▁ the ▁ substring ▁ is \" , findLength ( string , len ( string ) ) ) NEW_LINE DEDENT"],"references":["def findLength ( st , n ) : NEW_LINE INDENT total = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT total [ i ] = ( total [ i - 1 ] + int ( st [ i - 1 ] ) - int ( '0' ) ) NEW_LINE DEDENT ans = 0 NEW_LINE l = 2 NEW_LINE while ( l <= n ) : NEW_LINE INDENT for i in range ( n - l + 1 ) : NEW_LINE INDENT j = i + l - 1 NEW_LINE if ( total [ i + int ( l \/ 2 ) ] - total [ i ] == total [ i + l ] - total [ i + int ( l \/ 2 ) ] ) : NEW_LINE INDENT ans = max ( ans , l ) NEW_LINE DEDENT DEDENT l = l + 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT st = \"123123\" NEW_LINE print ( \" Length ▁ of ▁ the ▁ substring ▁ is \" , findLength ( st , len ( st ) ) ) NEW_LINE"],"bleu":0.3557458983263708,"rouge_l":0.5329410715877686}
{"id":1532,"predictions":["def findLength ( x , y ) : NEW_LINE INDENT return x if x < y else y NEW_LINE DEDENT def findLength ( arr , n ) : NEW_LINE INDENT max_len = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT mx = arr [ i ] NEW_LINE mx = arr [ i ] NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT mn = min ( mn , arr [ j ] ) NEW_LINE mx = max ( mx , arr [ j ] ) NEW_LINE if ( ( ( mx - mn ) == j - i ) == j - i ) : NEW_LINE INDENT max_len = max ( max_len , mx - mn + 1 ) NEW_LINE DEDENT DEDENT DEDENT return maxlen NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT largest = 1 NEW_LINE arr = [ 1 , 56 , 58 , 57 , 90 , 90 , 90 , 90 , 91 , 45 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Length ▁ of ▁ the ▁ longest ▁ contiguous ▁ subarray ▁ is \" , findLength ( arr , n ) ) NEW_LINE DEDENT"],"references":["def min ( x , y ) : NEW_LINE INDENT return x if ( x < y ) else y NEW_LINE DEDENT def max ( x , y ) : NEW_LINE INDENT return x if ( x > y ) else y NEW_LINE DEDENT def findLength ( arr , n ) : NEW_LINE INDENT max_len = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT mn = arr [ i ] NEW_LINE mx = arr [ i ] NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT mn = min ( mn , arr [ j ] ) NEW_LINE mx = max ( mx , arr [ j ] ) NEW_LINE if ( ( mx - mn ) == j - i ) : NEW_LINE INDENT max_len = max ( max_len , mx - mn + 1 ) NEW_LINE DEDENT DEDENT DEDENT return max_len NEW_LINE DEDENT arr = [ 1 , 56 , 58 , 57 , 90 , 92 , 94 , 93 , 91 , 45 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Length ▁ of ▁ the ▁ longest ▁ contiguous ▁ subarray ▁ is ▁ \" , findLength ( arr , n ) ) NEW_LINE"],"bleu":0.8078015748112168,"rouge_l":0.8574484339190221}
{"id":1533,"predictions":["def findCombinationsUtil ( arr , index , num , reducedNum ) : NEW_LINE INDENT if ( reducedNum < 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( reducedNum == 0 ) : NEW_LINE INDENT for i in range ( index ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE return NEW_LINE DEDENT prev = 1 if ( index == 0 ) else arr [ index - 1 ] NEW_LINE for k in range ( prev , num + 1 ) : NEW_LINE INDENT arr [ index ] = k NEW_LINE findCombinationsUtil ( arr , index + 1 , num , reduceNum - k ) NEW_LINE DEDENT DEDENT def findCombinations ( n ) : NEW_LINE INDENT arr = [ 0 ] * n NEW_LINE findCombinationsUtil ( arr , 0 , n , n ) NEW_LINE DEDENT arr = [ 0 ] * n NEW_LINE findCombinationsUtil ( arr , 0 , n , n ) NEW_LINE"],"references":["def findCombinationsUtil ( arr , index , num , reducedNum ) : NEW_LINE INDENT if ( reducedNum < 0 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT if ( reducedNum == 0 ) : NEW_LINE INDENT for i in range ( index ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( \" \" ) ; NEW_LINE return ; NEW_LINE DEDENT prev = 1 if ( index == 0 ) else arr [ index - 1 ] ; NEW_LINE for k in range ( prev , num + 1 ) : NEW_LINE INDENT arr [ index ] = k ; NEW_LINE findCombinationsUtil ( arr , index + 1 , num , reducedNum - k ) ; NEW_LINE DEDENT DEDENT def findCombinations ( n ) : NEW_LINE INDENT arr = [ 0 ] * n ; NEW_LINE findCombinationsUtil ( arr , 0 , n , n ) ; NEW_LINE DEDENT n = 5 ; NEW_LINE findCombinations ( n ) ; NEW_LINE"],"bleu":0.7840618645442056,"rouge_l":0.9076509551694345}
{"id":1534,"predictions":["import math NEW_LINE def fib ( n ) : NEW_LINE INDENT phi = ( 1 + math . sqrt ( 5 ) ) \/ 2 NEW_LINE return round ( pow ( phi , n ) \/ math . sqrt ( 5 ) ) NEW_LINE DEDENT def calculateSum ( l , r ) : NEW_LINE INDENT sum = fib ( r + 2 ) - fib ( l + 1 ) NEW_LINE return sum NEW_LINE DEDENT l = 4 NEW_LINE r = 8 NEW_LINE print ( calculateSum ( l , r ) ) NEW_LINE"],"references":["import math NEW_LINE def fib ( n ) : NEW_LINE INDENT phi = ( 1 + math . sqrt ( 5 ) ) \/ 2 ; NEW_LINE return int ( round ( pow ( phi , n ) \/ math . sqrt ( 5 ) ) ) ; NEW_LINE DEDENT def calculateSum ( l , r ) : NEW_LINE INDENT sum = fib ( r + 2 ) - fib ( l + 1 ) ; NEW_LINE return sum ; NEW_LINE DEDENT l = 4 ; NEW_LINE r = 8 ; NEW_LINE print ( calculateSum ( l , r ) ) ; NEW_LINE"],"bleu":0.7865485762763728,"rouge_l":0.9403281949278965}
{"id":1535,"predictions":["def MinimumValue ( x , y ) : NEW_LINE INDENT if ( x > y ) : NEW_LINE INDENT temp = x NEW_LINE x = y NEW_LINE y = temp NEW_LINE DEDENT a = 1 NEW_LINE b = x - 1 NEW_LINE c = y - b NEW_LINE print ( a , b , \" ▁ \" , c ) NEW_LINE DEDENT x = 12 NEW_LINE y = 10 NEW_LINE MinimumValue ( x , y ) NEW_LINE"],"references":["def MinimumValue ( x , y ) : NEW_LINE INDENT if ( x > y ) : NEW_LINE INDENT x , y = y , x NEW_LINE DEDENT a = 1 NEW_LINE b = x - 1 NEW_LINE c = y - b NEW_LINE print ( a , b , c ) NEW_LINE DEDENT x = 123 NEW_LINE y = 13 NEW_LINE MinimumValue ( x , y ) NEW_LINE"],"bleu":0.7319253141211697,"rouge_l":0.8716262190973009}
{"id":1536,"predictions":["def maximumChars ( str1 ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE res = - 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( str1 [ i ] == str1 [ j ] ) : NEW_LINE INDENT res = max ( res , abs ( j - i - 1 ) ) NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT str1 = \" abba \" NEW_LINE print ( maximumChars ( str1 ) ) NEW_LINE"],"references":["def maximumChars ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE res = - 1 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( str [ i ] == str [ j ] ) : NEW_LINE INDENT res = max ( res , abs ( j - i - 1 ) ) NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" abba \" NEW_LINE print ( maximumChars ( str ) ) NEW_LINE DEDENT"],"bleu":0.7013408600828664,"rouge_l":0.8562709795544704}
{"id":1537,"predictions":["def printTribRec ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 or n == 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n == 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return ( 5 - 1 ) + printTrib ( n - 2 ) + printTrib ( n - 2 ) NEW_LINE DEDENT DEDENT def printTrib ( n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT print ( printTribRec ( i ) , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT n = 10 NEW_LINE printTrib ( n ) NEW_LINE"],"references":["def printTribRec ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 or n == 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( n == 3 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( printTribRec ( n - 1 ) + printTribRec ( n - 2 ) + printTribRec ( n - 3 ) ) NEW_LINE DEDENT DEDENT def printTrib ( n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT print ( printTribRec ( i ) , \" ▁ \" , end = \" \" ) NEW_LINE DEDENT DEDENT n = 10 NEW_LINE printTrib ( n ) NEW_LINE"],"bleu":0.7803291299609655,"rouge_l":0.9018131101813112}
{"id":1538,"predictions":["def steps ( N , M ) : NEW_LINE INDENT if ( N == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( N == 2 ) : NEW_LINE INDENT return M NEW_LINE DEDENT return 2 * M + ( N - 3 ) NEW_LINE DEDENT N = 4 NEW_LINE M = 4 NEW_LINE print ( steps ( N , M ) ) NEW_LINE"],"references":["def steps ( N , M ) : NEW_LINE INDENT if ( N == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( N == 2 ) : NEW_LINE INDENT return M NEW_LINE DEDENT return 2 * M + ( N - 3 ) NEW_LINE DEDENT N = 4 NEW_LINE M = 4 NEW_LINE print ( steps ( N , M ) ) NEW_LINE"],"bleu":1.0,"rouge_l":1.0}
{"id":1539,"predictions":["def waysToKAdjacentSetBits ( n , k , currentIndex , adj = 0 ) : NEW_LINE INDENT if ( currentIndex == n ) : NEW_LINE INDENT if ( adjSetBits == k ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT noOfWays = 0 NEW_LINE if ( lastBit == 1 ) : NEW_LINE INDENT noOfWays += ways . count ( n , k , currentIndex + 1 ) NEW_LINE noOfWays += ways . count ( n , k , currentIndex + 1 ) NEW_LINE DEDENT elif ( lastBit == 0 ) : NEW_LINE INDENT noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , currentIndex ) NEW_LINE noOfWays += ways [ n , k ] NEW_LINE DEDENT return noOfWays NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 NEW_LINE k = 2 NEW_LINE totalWays = 2 NEW_LINE totalWays ( n , k , 1 , 0 , 1 ) + waysSetBits ( n , k , currentIndex + 1 , currentIndex ) NEW_LINE print ( \" Number ▁ of ▁ ways ▁ = \" , totalWays ) NEW_LINE DEDENT"],"references":["def waysToKAdjacentSetBits ( n , k , currentIndex , adjacentSetBits , lastBit ) : NEW_LINE INDENT if ( currentIndex == n ) : NEW_LINE INDENT if ( adjacentSetBits == k ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT return 0 NEW_LINE DEDENT noOfWays = 0 NEW_LINE if ( lastBit == 1 ) : NEW_LINE INDENT noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits + 1 , 1 ) ; NEW_LINE noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits , 0 ) ; NEW_LINE DEDENT elif ( lastBit != 1 ) : NEW_LINE INDENT noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits , 1 ) ; NEW_LINE noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits , 0 ) ; NEW_LINE DEDENT return noOfWays ; NEW_LINE DEDENT n = 5 ; k = 2 ; NEW_LINE totalWays = ( waysToKAdjacentSetBits ( n , k , 1 , 0 , 1 ) + waysToKAdjacentSetBits ( n , k , 1 , 0 , 0 ) ) ; NEW_LINE print ( \" Number ▁ of ▁ ways ▁ = \" , totalWays ) ; NEW_LINE"],"bleu":0.6107314525693888,"rouge_l":0.7747156968539886}
{"id":1540,"predictions":["def canPlace ( a , n , p , sep ) : NEW_LINE INDENT barr_search = 1 NEW_LINE last_reper_ replaced = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT current_cells = a [ i ] NEW_LINE if ( current_space - last_last >= sep ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def maxDistance ( cell , n , p ) : NEW_LINE INDENT cells . sort ( ) NEW_LINE start = 0 NEW_LINE end = 0 NEW_LINE end = cell [ n - 1 ] - cell [ 0 ] NEW_LINE ans = 0 NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = start + ( ( end - start ) \/\/ 2 ) NEW_LINE if ( canPlace ( cell , n , p , mid ) ) : NEW_LINE INDENT ans = mid NEW_LINE start = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT cell = [ 1 , 2 , 8 , 4 , 9 ] NEW_LINE n = len ( cell ) NEW_LINE p = 3 NEW_LINE print ( maxDistance ( cell , n , p ) ) NEW_LINE DEDENT"],"references":["def canPlace ( a , n , p , sep ) : NEW_LINE INDENT prisoners_placed = 1 NEW_LINE last_prisoner_placed = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT current_cell = a [ i ] NEW_LINE if ( current_cell - last_prisoner_placed >= sep ) : NEW_LINE INDENT prisoners_placed += 1 NEW_LINE last_prisoner_placed = current_cell NEW_LINE if ( prisoners_placed == p ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT def maxDistance ( cell , n , p ) : NEW_LINE INDENT cell = sorted ( cell ) NEW_LINE start = 0 NEW_LINE end = cell [ n - 1 ] - cell [ 0 ] NEW_LINE ans = 0 NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = start + ( ( end - start ) \/\/ 2 ) NEW_LINE if ( canPlace ( cell , n , p , mid ) ) : NEW_LINE INDENT ans = mid NEW_LINE start = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT cell = [ 1 , 2 , 8 , 4 , 9 ] NEW_LINE n = len ( cell ) NEW_LINE p = 3 NEW_LINE print ( maxDistance ( cell , n , p ) ) NEW_LINE"],"bleu":0.8331213954513338,"rouge_l":0.873265024344161}
{"id":1541,"predictions":["def foundElement ( arr , n ) : NEW_LINE INDENT xorArr = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT xorArr ^= arr [ i ] ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT x = xorArr ^ arr [ i ] ; NEW_LINE if ( arr [ i ] == x ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT return False ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 8 , 2 , 4 , 15 , 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE if ( foundElement ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"],"references":["def containsElement ( arr , n ) : NEW_LINE INDENT xorArr = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT xorArr ^= arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT x = xorArr ^ arr [ i ] NEW_LINE if ( arr [ i ] == x ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT arr = [ 8 , 2 , 4 , 15 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE if ( containsElement ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.7114803707677807,"rouge_l":0.9149999999999999}
{"id":1542,"predictions":["from collections import defaultdict NEW_LINE def solve ( s ) : NEW_LINE INDENT m = dict ( ) NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT m [ s [ i ] ] += 1 NEW_LINE DEDENT new_string = \" \" NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT if m [ s [ i ] ] % 2 == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT new_string = new_string + s [ i ] NEW_LINE DEDENT print ( new_string ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" aabbbddeeecc \" NEW_LINE solve ( s ) NEW_LINE DEDENT"],"references":["def solve ( s ) : NEW_LINE INDENT m = dict ( ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] in m : NEW_LINE INDENT m [ s [ i ] ] = m [ s [ i ] ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ s [ i ] ] = 1 NEW_LINE DEDENT DEDENT new_string = \" \" NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if m [ s [ i ] ] % 2 == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT new_string = new_string + s [ i ] NEW_LINE DEDENT print ( new_string ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" aabbbddeeecc \" NEW_LINE solve ( s ) NEW_LINE DEDENT"],"bleu":0.6831001221141851,"rouge_l":0.8071833648393195}
{"id":1543,"predictions":["def getTotalXorOfSubarrayXors ( arr , N ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT freq = ( i + 1 ) * ( N - i ) NEW_LINE if ( freq % 2 == 1 ) : NEW_LINE INDENT res = res ^ arr [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT arr = [ 3 , 5 , 2 , 4 , 6 ] NEW_LINE N = len ( arr ) NEW_LINE print ( getTotalXorOfSubarrayXors ( arr , N ) ) NEW_LINE"],"references":["def getTotalXorOfSubarrayXors ( arr , N ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT freq = ( i + 1 ) * ( N - i ) NEW_LINE if ( freq % 2 == 1 ) : NEW_LINE INDENT res = res ^ arr [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT arr = [ 3 , 5 , 2 , 4 , 6 ] NEW_LINE N = len ( arr ) NEW_LINE print ( getTotalXorOfSubarrayXors ( arr , N ) ) NEW_LINE"],"bleu":0.9634138912331919,"rouge_l":0.9877279700017044}
{"id":1544,"predictions":["def sum ( N ) : NEW_LINE INDENT S1 = ( ( N \/\/ 3 ) ) * ( 2 * 3 + ( N \/\/ 3 - 1 ) * 3 ) \/\/ 2 NEW_LINE S2 = ( ( N \/\/ 4 ) ) * ( 2 * 4 + ( N \/\/ 4 - 1 ) * 4 ) \/\/ 2 NEW_LINE S3 = ( ( N \/\/ 12 ) ) * ( 2 * 12 + ( N \/\/ 12 - 1 ) * 12 ) \/\/ 2 NEW_LINE return S1 + S2 - S3 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 20 NEW_LINE print ( sum ( 12 ) ) NEW_LINE DEDENT"],"references":["def sum ( N ) : NEW_LINE INDENT global S1 , S2 , S3 NEW_LINE S1 = ( ( ( N \/\/ 3 ) ) * ( 2 * 3 + ( N \/\/ 3 - 1 ) * 3 ) \/\/ 2 ) NEW_LINE S2 = ( ( ( N \/\/ 4 ) ) * ( 2 * 4 + ( N \/\/ 4 - 1 ) * 4 ) \/\/ 2 ) NEW_LINE S3 = ( ( ( N \/\/ 12 ) ) * ( 2 * 12 + ( N \/\/ 12 - 1 ) * 12 ) \/\/ 2 ) NEW_LINE return int ( S1 + S2 - S3 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 12 NEW_LINE print ( sum ( N ) ) NEW_LINE DEDENT"],"bleu":0.7785344910888794,"rouge_l":0.9155168240135559}
{"id":1545,"predictions":["def count ( S , m , n ) : NEW_LINE INDENT table = [ [ 0 ] * ( n + 1 ) ] NEW_LINE table [ 0 ] = 1 NEW_LINE for i in range ( m ) : NEW_LINE INDENT table [ 0 ] = 1 NEW_LINE DEDENT table [ 0 ] = 1 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( S [ i ] , n + 1 ) : NEW_LINE INDENT for j in range ( S [ i ] , n + 1 ) : NEW_LINE INDENT table [ j ] += table [ j - S [ i ] ] NEW_LINE DEDENT DEDENT return table [ n ] NEW_LINE DEDENT return table [ n ] NEW_LINE DEDENT def count ( S , m , n ) : NEW_LINE INDENT table [ 0 ] = 1 NEW_LINE table [ 0 ] = 1 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( S [ i ] , n + 1 ) : NEW_LINE INDENT table [ j ] [ j ] += table [ j - S [ i ] ] NEW_LINE DEDENT DEDENT return table [ n ] [ n ] NEW_LINE DEDENT return table [ n ] NEW_LINE DEDENT def count ( S , m , n ) : NEW_LINE INDENT table = [ ] NEW_LINE table [ 0 ] = 1 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( S [ i ] , n + 1 ) : NEW_LINE INDENT for j in range ( S [ i ] , n + 1 ) : NEW_LINE INDENT table [ j ] += table [ j - S [ i ] ] [ j ] NEW_LINE DEDENT DEDENT return table [ n ] [ j ] NEW_LINE DEDENT return table [ n ] NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ ' : NEW_LINE INDENT"],"references":["def count ( S , m , n ) : NEW_LINE INDENT table = [ 0 for k in range ( n + 1 ) ] NEW_LINE table [ 0 ] = 1 NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT for j in range ( S [ i ] , n + 1 ) : NEW_LINE INDENT table [ j ] += table [ j - S [ i ] ] NEW_LINE DEDENT DEDENT return table [ n ] NEW_LINE DEDENT arr = [ 1 , 2 , 3 ] NEW_LINE m = len ( arr ) NEW_LINE n = 4 NEW_LINE x = count ( arr , m , n ) NEW_LINE print ( x ) NEW_LINE"],"bleu":0.2577351442852644,"rouge_l":0.4884132727692664}
{"id":1546,"predictions":["def countSolutions ( a ) : NEW_LINE INDENT count = bin ( a ) . count ( '1' ) NEW_LINE count = pow ( 2 , count ) NEW_LINE return count NEW_LINE DEDENT a = 3 NEW_LINE print ( countSolutions ( a ) ) NEW_LINE"],"references":["def countSolutions ( a ) : NEW_LINE INDENT count = bin ( a ) . count ( '1' ) NEW_LINE return 2 ** count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 3 NEW_LINE print ( countSolutions ( a ) ) NEW_LINE DEDENT"],"bleu":0.6245072100202448,"rouge_l":0.7327327327327328}
{"id":1547,"predictions":["def countNumbers ( n ) : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT return 9 * pow ( 10 , n \/\/ 2 - 1 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 2 NEW_LINE print ( countNumbers ( n ) ) NEW_LINE DEDENT"],"references":["def countNumbers ( n ) : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( 9 * pow ( 10 , n \/\/ 2 - 1 ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 2 NEW_LINE print ( countNumbers ( n ) ) NEW_LINE DEDENT"],"bleu":0.931756511310307,"rouge_l":0.981318111053451}
{"id":1548,"predictions":["def getMinDiff ( arr , n , k ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT arr . sort ( ) NEW_LINE ans = arr [ n - 1 ] - arr [ 0 ] NEW_LINE small = arr [ 0 ] + k NEW_LINE temp = 0 NEW_LINE if ( small > big ) : NEW_LINE INDENT temp = small NEW_LINE small = big NEW_LINE add = temp NEW_LINE DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT subtract = arr [ i ] - k NEW_LINE add = arr [ i ] + k NEW_LINE if ( subtract >= small or add <= big ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( big - subtract <= add - small ) : NEW_LINE INDENT small = subtract NEW_LINE DEDENT else : NEW_LINE INDENT big = add NEW_LINE DEDENT DEDENT return min ( ans , big - small ) NEW_LINE DEDENT arr = [ 4 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE k = 10 NEW_LINE print ( \" Maximum ▁ difference ▁ is \" , getMinDiff ( arr , n , k ) ) NEW_LINE"],"references":["def getMinDiff ( arr , n , k ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT arr . sort ( ) NEW_LINE ans = arr [ n - 1 ] - arr [ 0 ] NEW_LINE small = arr [ 0 ] + k NEW_LINE big = arr [ n - 1 ] - k NEW_LINE if ( small > big ) : NEW_LINE INDENT small , big = big , small NEW_LINE DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT subtract = arr [ i ] - k NEW_LINE add = arr [ i ] + k NEW_LINE if ( subtract >= small or add <= big ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( big - subtract <= add - small ) : NEW_LINE INDENT small = subtract NEW_LINE DEDENT else : NEW_LINE INDENT big = add NEW_LINE DEDENT DEDENT return min ( ans , big - small ) NEW_LINE DEDENT arr = [ 4 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE k = 10 NEW_LINE print ( \" Maximum ▁ difference ▁ is \" , getMinDiff ( arr , n , k ) ) NEW_LINE"],"bleu":0.9120662525020257,"rouge_l":0.9433485876597759}
{"id":1549,"predictions":["def minimumChanges ( n , a ) : NEW_LINE INDENT sf = [ 0 ] * ( n + 1 ) NEW_LINE sf [ n ] = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT sf [ i ] = sf [ i + 1 ] NEW_LINE if ( a [ i ] <= 0 ) : NEW_LINE INDENT sf [ i ] += 1 NEW_LINE DEDENT DEDENT pos = 0 NEW_LINE mn = n NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( a [ i ] >= 0 ) : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT mn = min ( mn , pos + sf [ i + 1 ] ) NEW_LINE DEDENT return mn NEW_LINE DEDENT a = [ - 1 , - 2 , - 3 , 3 , - 5 , 3 , 4 ] NEW_LINE n = len ( a ) NEW_LINE print ( minimumChanges ( n , a ) ) NEW_LINE"],"references":["def minimumChanges ( n , a ) : NEW_LINE INDENT sf = [ 0 ] * ( n + 1 ) NEW_LINE sf [ n ] = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT sf [ i ] = sf [ i + 1 ] NEW_LINE if ( a [ i ] <= 0 ) : NEW_LINE INDENT sf [ i ] += 1 NEW_LINE DEDENT DEDENT pos = 0 NEW_LINE mn = n NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( a [ i ] >= 0 ) : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT mn = min ( mn , pos + sf [ i + 1 ] ) NEW_LINE DEDENT return mn NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ - 1 , - 2 , - 3 , 3 , - 5 , 3 , 4 ] NEW_LINE n = len ( a ) NEW_LINE print ( minimumChanges ( n , a ) ) NEW_LINE DEDENT"],"bleu":0.9160424910130176,"rouge_l":0.9554021767985136}
{"id":1550,"predictions":["def printFirstRepeating ( arr , n ) : NEW_LINE INDENT min = - 1 NEW_LINE set = set ( ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if arr [ i ] in set : NEW_LINE INDENT min = i NEW_LINE DEDENT else : NEW_LINE INDENT set . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT if ( min != - 1 ) : NEW_LINE INDENT print ( \" The ▁ first ▁ repeating ▁ element ▁ is \" , arr [ min ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" There ▁ are ▁ no ▁ Repeating ▁ elements \" ) NEW_LINE DEDENT DEDENT arr = [ 10 , 1 , 2 , 3 , 5 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE printFirstRepeating ( arr , n ) NEW_LINE"],"references":["def printFirstRepeating ( arr , n ) : NEW_LINE INDENT Min = - 1 NEW_LINE myset = dict ( ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if arr [ i ] in myset . keys ( ) : NEW_LINE INDENT Min = i NEW_LINE DEDENT else : NEW_LINE INDENT myset [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT if ( Min != - 1 ) : NEW_LINE INDENT print ( \" The ▁ first ▁ repeating ▁ element ▁ is \" , arr [ Min ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" There ▁ are ▁ no ▁ repeating ▁ elements \" ) NEW_LINE DEDENT DEDENT arr = [ 10 , 5 , 3 , 4 , 3 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE printFirstRepeating ( arr , n ) NEW_LINE"],"bleu":0.7701017032527533,"rouge_l":0.8761794925560913}
{"id":1551,"predictions":["def solveEven ( n , arr , b ) : NEW_LINE INDENT left = n - 1 NEW_LINE for i in range ( int ( n \/ 2 ) ) : NEW_LINE INDENT b [ i ] = arr [ left ] NEW_LINE left = left - 2 NEW_LINE if ( left < 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT right = 0 NEW_LINE for i in range ( n \/\/ 2 , n - 1 ) : NEW_LINE INDENT b [ i ] = arr [ right ] NEW_LINE right = right + 2 NEW_LINE if ( right > n - 2 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT def solveOdd ( n , arr , b ) : NEW_LINE INDENT left = n - 1 NEW_LINE for i in range ( ( int ( n \/ 2 ) + 1 ) : NEW_LINE INDENT b [ i ] = arr [ left ] NEW_LINE left = left + 2 NEW_LINE if ( left < 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT right = 1 NEW_LINE for i in range ( ( int ( n \/ 2 ) + 1 , n - 1 ) + 1 ) : NEW_LINE INDENT b [ i ] = arr [ right ] NEW_LINE right = right + 2 NEW_LINE if ( left > n - 2 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT def solve ( n , arr ) : NEW_LINE INDENT b = [ ] NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT solveEven ( n , arr , b ) NEW_LINE DEDENT else : NEW_LINE INDENT solveOdd ( n , arr , b ) NEW_LINE DEDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT print ( b [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE solve ( n , arr ) NEW_LINE DEDENT"],"references":["def solveEven ( n , arr , b ) : NEW_LINE INDENT left = n - 1 NEW_LINE for i in range ( ( n \/\/ 2 ) ) : NEW_LINE INDENT b [ i ] = arr [ left ] NEW_LINE left = left - 2 NEW_LINE if ( left < 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT right = 0 NEW_LINE for i in range ( n \/\/ 2 , n , 1 ) : NEW_LINE INDENT b [ i ] = arr [ right ] NEW_LINE right = right + 2 NEW_LINE if ( right > n - 2 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT def solveOdd ( n , arr , b ) : NEW_LINE INDENT left = n - 1 NEW_LINE for i in range ( n \/\/ 2 + 1 ) : NEW_LINE INDENT b [ i ] = arr [ left ] NEW_LINE left = left - 2 NEW_LINE if ( left < 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT right = 1 NEW_LINE for i in range ( n \/\/ 2 + 1 , n , 1 ) : NEW_LINE INDENT b [ i ] = arr [ right ] NEW_LINE right = right + 2 NEW_LINE if ( right > n - 2 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT def solve ( n , arr ) : NEW_LINE INDENT b = [ 0 for i in range ( n ) ] NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT solveEven ( n , arr , b ) NEW_LINE DEDENT else : NEW_LINE INDENT solveOdd ( n , arr , b ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( b [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE solve ( n , arr ) NEW_LINE DEDENT"],"bleu":0.8762645606721373,"rouge_l":0.9429217423403469}
{"id":1552,"predictions":["def findpair ( l , r ) : NEW_LINE INDENT c = 0 ; NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , r + 1 ) : NEW_LINE INDENT if ( j % i == 0 and j != i ) : NEW_LINE INDENT print ( i , \" , ▁ \" , j ) ; NEW_LINE c = 1 ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( c == 1 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT DEDENT l = 1 ; NEW_LINE r = 10 ; NEW_LINE findpair ( l , r ) ; NEW_LINE"],"references":["def findpair ( l , r ) : NEW_LINE INDENT c = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , r + 1 ) : NEW_LINE INDENT if ( j % i == 0 and j != i ) : NEW_LINE INDENT print ( i , \" , ▁ \" , j ) NEW_LINE c = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( c == 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT l = 1 NEW_LINE r = 10 NEW_LINE findpair ( l , r ) NEW_LINE DEDENT"],"bleu":0.7767019048199381,"rouge_l":0.9034558420186507}
{"id":1553,"predictions":["def nthEven ( n ) : NEW_LINE INDENT return ( 2 * n ) NEW_LINE DEDENT n = 10 NEW_LINE print ( nthEven ( n ) ) NEW_LINE"],"references":["def nthEven ( n ) : NEW_LINE INDENT return ( 2 * n ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE print ( nthEven ( n ) ) NEW_LINE DEDENT"],"bleu":0.5717904208544105,"rouge_l":0.7721518987341772}
{"id":1554,"predictions":["def checkUtil ( num , dig , base ) : NEW_LINE INDENT if dig == 1 and num < base : NEW_LINE INDENT return True NEW_LINE DEDENT if dig > 1 and num >= base : NEW_LINE INDENT return checkUtil ( num \/ base , dig , dig ) NEW_LINE DEDENT return False NEW_LINE DEDENT def check ( num , dig ) : NEW_LINE INDENT for base in range ( 2 , 32 + 1 ) : NEW_LINE INDENT if checkUtil ( num , dig , base ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT num = 8 NEW_LINE dig = 3 NEW_LINE if ( check ( num , dig ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def checkUtil ( num , dig , base ) : NEW_LINE INDENT if ( dig == 1 and num < base ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( dig > 1 and num >= base ) : NEW_LINE INDENT return checkUtil ( num \/ base , - - dig , base ) NEW_LINE DEDENT return False NEW_LINE DEDENT def check ( num , dig ) : NEW_LINE INDENT for base in range ( 2 , 33 ) : NEW_LINE INDENT if ( checkUtil ( num , dig , base ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT num = 8 NEW_LINE dig = 3 NEW_LINE if ( check ( num , dig ) == True ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.8278125164639122,"rouge_l":0.9397371998187585}
{"id":1555,"predictions":["def smallestSubWithSum ( arr , n , x ) : NEW_LINE INDENT min_len = n + 1 NEW_LINE for start in range ( n ) : NEW_LINE INDENT curr_sum = arr [ start ] NEW_LINE if ( curr_sum > x ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT for end in range ( start + 1 , n ) : NEW_LINE INDENT curr_sum += arr [ end ] NEW_LINE if ( curr_sum > x and ( end - start + 1 ) < min_len ) : NEW_LINE INDENT min_len = ( end - start + 1 ) NEW_LINE DEDENT DEDENT DEDENT return min_len NEW_LINE DEDENT arr1 = [ 1 , 4 , 45 , 6 , 10 , 19 ] NEW_LINE x = 51 NEW_LINE n1 = len ( arr1 ) NEW_LINE res1 = smallestSubWithSum ( arr1 , n1 , x ) NEW_LINE if ( res1 == n1 + 1 ) : NEW_LINE INDENT print ( \" Not ▁ possible \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res1 ) NEW_LINE arr2 = [ 1 , 10 , 5 , 2 , 7 ] NEW_LINE n2 = smallestSubWithSum ( arr2 , n1 , x ) NEW_LINE n2 = len ( arr2 ) NEW_LINE x = 9 NEW_LINE res2 = smallestSubWithSum ( arr2 , n1 , x ) NEW_LINE print ( \" Not ▁ possible \" ) if ( res2 == n2 + 1 ) else print ( res3 ) NEW_LINE arr3 = [ 1 , 10 , 1 , 1 , 0 , 3 , 2 , 1 , 2 , 1 , 3 , 2 , 1 ] NEW_LINE n3 = len ( arr3 ) NEW_LINE x = smallestSubWithSum ( arr3 , n3 , x ) NEW_LINE print ( \" Not ▁ possible \" ) if ( res3 == n3 + 1 ) else print ( res3 ) NEW_LINE arr3 = [ 1 , 10 , 100 , 1 , 3 , 2 , 3 , 2 , 1 , 3 , 2 , 3 , 2 , 1 , 3 , 2 , 1 ] NEW_LINE n3 ="],"references":["def smallestSubWithSum ( arr , n , x ) : NEW_LINE INDENT min_len = n + 1 NEW_LINE for start in range ( 0 , n ) : NEW_LINE INDENT curr_sum = arr [ start ] NEW_LINE if ( curr_sum > x ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT for end in range ( start + 1 , n ) : NEW_LINE INDENT curr_sum += arr [ end ] NEW_LINE if curr_sum > x and ( end - start + 1 ) < min_len : NEW_LINE INDENT min_len = ( end - start + 1 ) NEW_LINE DEDENT DEDENT DEDENT return min_len ; NEW_LINE DEDENT arr1 = [ 1 , 4 , 45 , 6 , 10 , 19 ] NEW_LINE x = 51 NEW_LINE n1 = len ( arr1 ) NEW_LINE res1 = smallestSubWithSum ( arr1 , n1 , x ) ; NEW_LINE if res1 == n1 + 1 : NEW_LINE INDENT print ( \" Not ▁ possible \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res1 ) NEW_LINE DEDENT arr2 = [ 1 , 10 , 5 , 2 , 7 ] NEW_LINE n2 = len ( arr2 ) NEW_LINE x = 9 NEW_LINE res2 = smallestSubWithSum ( arr2 , n2 , x ) ; NEW_LINE if res2 == n2 + 1 : NEW_LINE INDENT print ( \" Not ▁ possible \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res2 ) NEW_LINE DEDENT arr3 = [ 1 , 11 , 100 , 1 , 0 , 200 , 3 , 2 , 1 , 250 ] NEW_LINE n3 = len ( arr3 ) NEW_LINE x = 280 NEW_LINE res3 = smallestSubWithSum ( arr3 , n3 , x ) NEW_LINE if res3 == n3 + 1 : NEW_LINE INDENT print ( \" Not ▁ possible \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res3 ) NEW_LINE DEDENT"],"bleu":0.7085778944015224,"rouge_l":0.8117179741807349}
{"id":1556,"predictions":["import math NEW_LINE def getSum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sqrtCurrentCurrent = math . sqrt ( arr [ i ] ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT x = arr [ j ] NEW_LINE if x == sqrtCurrent : NEW_LINE INDENT sum += ( sqrtCurrentCurrent * sqrtCurrent ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT return sum NEW_LINE DEDENT arr = [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( getSum ( arr , n ) ) NEW_LINE"],"references":["import math NEW_LINE def getSum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sqrtCurrent = math . sqrt ( arr [ i ] ) NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT x = arr [ j ] NEW_LINE if ( x == sqrtCurrent ) : NEW_LINE INDENT sum += ( sqrtCurrent * sqrtCurrent ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT return int ( sum ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( getSum ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.7158159072206598,"rouge_l":0.8807281858129316}
{"id":1557,"predictions":["def findCountOfPairs ( a , b , n ) : NEW_LINE INDENT ans = 0 NEW_LINE ans += n * ( a \/\/ n ) * ( b \/\/ n ) NEW_LINE ans += ( a % n ) * ( b % n ) NEW_LINE ans += ( ( a % n ) + ( b % n ) ) \/\/ n NEW_LINE return ans NEW_LINE DEDENT a = 5 NEW_LINE b = 13 NEW_LINE n = 3 NEW_LINE print ( findCountOfPairs ( a , b , n ) ) NEW_LINE"],"references":["def findCountOfPairs ( a , b , n ) : NEW_LINE INDENT ans = 0 NEW_LINE ans += n * int ( a \/ n ) * int ( b \/ n ) NEW_LINE ans += int ( a \/ n ) * ( b % n ) NEW_LINE ans += ( a % n ) * int ( b \/ n ) NEW_LINE ans += int ( ( ( a % n ) + ( b % n ) ) \/ n ) ; NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 5 NEW_LINE b = 13 NEW_LINE n = 3 NEW_LINE print ( findCountOfPairs ( a , b , n ) ) NEW_LINE DEDENT"],"bleu":0.5710857313066562,"rouge_l":0.7770700636942675}
{"id":1558,"predictions":["def bsearch ( prefix , n , k ) : NEW_LINE INDENT ans = - 1 NEW_LINE left = 1 NEW_LINE right = n NEW_LINE while ( left <= right ) : NEW_LINE INDENT mid = ( left + right ) \/\/ 2 NEW_LINE i = mid NEW_LINE for i in range ( mid , n + 1 ) : NEW_LINE INDENT if ( prefixsum [ i ] - prefixsum [ i - mid ] > k ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( i == n + 1 ) : NEW_LINE INDENT left = mid + 1 NEW_LINE ans = mid NEW_LINE DEDENT else : NEW_LINE INDENT right = mid - 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def maxSize ( arr , n , k ) : NEW_LINE INDENT prefixsum = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT prefixsum [ i + 1 ] = prefixsum [ i ] + arr [ i ] NEW_LINE DEDENT return bsearch ( prefixsum , n , k ) NEW_LINE DEDENT arr = [ 1 , 2 , 10 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE k = 14 NEW_LINE print ( maxSize ( arr , n , k ) ) NEW_LINE"],"references":["def bsearch ( prefixsum , n , k ) : NEW_LINE INDENT ans , left , right = - 1 , 1 , n NEW_LINE while ( left <= right ) : NEW_LINE INDENT mid = ( left + right ) \/\/ 2 NEW_LINE for i in range ( mid , n + 1 ) : NEW_LINE INDENT if ( prefixsum [ i ] - prefixsum [ i - mid ] > k ) : NEW_LINE INDENT i = i - 1 NEW_LINE break NEW_LINE DEDENT DEDENT i = i + 1 NEW_LINE if ( i == n + 1 ) : NEW_LINE INDENT left = mid + 1 NEW_LINE ans = mid NEW_LINE DEDENT else : NEW_LINE INDENT right = mid - 1 NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT def maxSize ( arr , n , k ) : NEW_LINE INDENT prefixsum = [ 0 for x in range ( n + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT prefixsum [ i + 1 ] = prefixsum [ i ] + arr [ i ] NEW_LINE DEDENT return bsearch ( prefixsum , n , k ) ; NEW_LINE DEDENT arr = [ 1 , 2 , 10 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE k = 14 NEW_LINE print ( maxSize ( arr , n , k ) ) NEW_LINE"],"bleu":0.859000901674758,"rouge_l":0.9221334854535083}
{"id":1559,"predictions":["from math import sqrt NEW_LINE def isprime ( x ) : NEW_LINE INDENT for i in range ( 2 , int ( sqrt ( x ) ) + 1 ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def isSumOfKprimes ( N , K ) : NEW_LINE INDENT if ( N < 2 * K ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( K == 1 ) : NEW_LINE INDENT return isprime ( N ) NEW_LINE DEDENT if ( K == 2 ) : NEW_LINE INDENT if ( N % 2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return isprime ( N - 2 ) NEW_LINE DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 10 NEW_LINE k = 2 NEW_LINE if ( isSumOfKprimes ( n , k ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def isprime ( x ) : NEW_LINE INDENT i = 2 NEW_LINE while ( i * i <= x ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT def isSumOfKprimes ( N , K ) : NEW_LINE INDENT if ( N < 2 * K ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( K == 1 ) : NEW_LINE INDENT return isprime ( N ) NEW_LINE DEDENT if ( K == 2 ) : NEW_LINE INDENT if ( N % 2 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return isprime ( N - 2 ) ; NEW_LINE DEDENT return 1 NEW_LINE DEDENT n = 10 NEW_LINE k = 2 NEW_LINE if ( isSumOfKprimes ( n , k ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.7261729647073804,"rouge_l":0.8691785406904465}
{"id":1560,"predictions":["def CountCharacters ( str , k ) : NEW_LINE INDENT cnt = 0 NEW_LINE l = len ( str ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( ord ( str [ i ] ) < k ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT str = \" GeeksForGeeks \" NEW_LINE k = 90 NEW_LINE count = CountCharacters ( str , k ) NEW_LINE print ( \" characters ▁ with ▁ ASCII ▁ values ▁ are \" , count ) NEW_LINE print ( \" characters ▁ with ▁ ASCII ▁ values ▁ are \" , count ) NEW_LINE print ( \" characters ▁ with ▁ ASCII ▁ values ▁ are \" , count ) NEW_LINE print ( \" characters ▁ with ▁ ASCII ▁ values ▁ are ▁ \" , count ) NEW_LINE DEDENT"],"references":["def CountCharacters ( str , k ) : NEW_LINE INDENT cnt = 0 NEW_LINE l = len ( str ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( ord ( str [ i ] ) < k ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" GeeksForGeeks \" NEW_LINE k = 90 NEW_LINE count = CountCharacters ( str , k ) NEW_LINE print ( \" Characters ▁ with ▁ ASCII ▁ values \" , \" less ▁ than ▁ K ▁ are \" , count ) NEW_LINE print ( \" Characters ▁ with ▁ ASCII ▁ values \" , \" greater ▁ than ▁ or ▁ equal ▁ to ▁ K ▁ are \" , len ( str ) - count ) NEW_LINE DEDENT"],"bleu":0.6826638233724468,"rouge_l":0.8043213296398891}
{"id":1561,"predictions":["def printUncommon ( arr1 , arr2 , n1 , n1 , n2 ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE k = 0 NEW_LINE while ( i < n1 and j < n2 ) : NEW_LINE INDENT if ( arr1 [ i ] < arr2 [ j ] ) : NEW_LINE INDENT print ( arr1 [ i ] , end = \" ▁ \" ) NEW_LINE i += 1 NEW_LINE k += 1 NEW_LINE DEDENT elif ( arr2 [ j ] < arr1 [ i ] ) : NEW_LINE INDENT print ( arr2 [ j ] , end = \" ▁ \" ) NEW_LINE k += 1 NEW_LINE j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT while ( i < n ) : NEW_LINE INDENT print ( arr1 [ i ] , end = \" ▁ \" ) NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT while ( i < n ) : NEW_LINE INDENT print ( arr1 [ i ] , end = \" ▁ \" ) NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE while ( j < n ) : NEW_LINE INDENT print ( arr2 [ j ] , end = \" ▁ \" ) NEW_LINE j += 1 NEW_LINE print ( arr2 [ j ] , end = \" ▁ \" ) NEW_LINE j += 1 NEW_LINE k += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr1 = [ 10 , 10 , 5 , 0 ] NEW_LINE arr1 = [ 20 , 10 , 5 , 0 ] NEW_LINE n1 = len ( arr2 ) NEW_LINE n1 = len ( arr1 ) NEW_LINE n2 = len ( arr2 ) NEW_LINE printUncommon ( arr1 , arr2 , n1 ) NEW_LINE DEDENT"],"references":["def printUncommon ( arr1 , arr2 , n1 , n2 ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE k = 0 NEW_LINE while ( i < n1 and j < n2 ) : NEW_LINE INDENT if ( arr1 [ i ] < arr2 [ j ] ) : NEW_LINE INDENT print ( arr1 [ i ] , end = \" ▁ \" ) NEW_LINE i = i + 1 NEW_LINE k = k + 1 NEW_LINE DEDENT elif ( arr2 [ j ] < arr1 [ i ] ) : NEW_LINE INDENT print ( arr2 [ j ] , end = \" ▁ \" ) NEW_LINE k = k + 1 NEW_LINE j = j + 1 NEW_LINE DEDENT else : NEW_LINE INDENT i = i + 1 NEW_LINE j = j + 1 NEW_LINE DEDENT DEDENT while ( i < n1 ) : NEW_LINE INDENT print ( arr1 [ i ] , end = \" ▁ \" ) NEW_LINE i = i + 1 NEW_LINE k = k + 1 NEW_LINE DEDENT while ( j < n2 ) : NEW_LINE INDENT print ( arr2 [ j ] , end = \" ▁ \" ) NEW_LINE j = j + 1 NEW_LINE k = k + 1 NEW_LINE DEDENT DEDENT arr1 = [ 10 , 20 , 30 ] NEW_LINE arr2 = [ 20 , 25 , 30 , 40 , 50 ] NEW_LINE n1 = len ( arr1 ) NEW_LINE n2 = len ( arr2 ) NEW_LINE printUncommon ( arr1 , arr2 , n1 , n2 ) NEW_LINE"],"bleu":0.6162440090468865,"rouge_l":0.7843510349997117}
{"id":1562,"predictions":["def findExtraCharacter ( s1 , s2 ) : NEW_LINE INDENT smallStr = \" \" NEW_LINE if ( len ( s2 ) > len ( s2 ) ) : NEW_LINE INDENT smallStr = s2 NEW_LINE largeStr = s1 NEW_LINE DEDENT else : NEW_LINE INDENT smallStr = s1 NEW_LINE largeStr = s2 NEW_LINE DEDENT smallStr2 = 0 NEW_LINE largeStrCount = 0 NEW_LINE i = 0 NEW_LINE for i in range ( len ( smallStr ) ) : NEW_LINE INDENT smallStrCount += ( smallStr [ i ] ) NEW_LINE largeStrCount += ( largeStr [ i ] ) NEW_LINE DEDENT smallStr += largeStr [ i ] NEW_LINE DEDENT largeStrCount += largeStr [ i ] NEW_LINE return ch NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s1 = \" abcd \" NEW_LINE s2 = \" cbdae \" NEW_LINE extraChar = findExtraChar ( s1 , s2 ) NEW_LINE print ( \" Alternate ▁ character : \" , extraChar ) NEW_LINE DEDENT"],"references":["def findExtraCharacter ( s1 , s2 ) : NEW_LINE INDENT smallStr = \" \" NEW_LINE largeStr = \" \" NEW_LINE if ( len ( s1 ) > len ( s2 ) ) : NEW_LINE INDENT smallStr = s2 NEW_LINE largeStr = s1 NEW_LINE DEDENT else : NEW_LINE INDENT smallStr = s1 NEW_LINE largeStr = s2 NEW_LINE DEDENT smallStrCodeTotal = 0 NEW_LINE largeStrCodeTotal = 0 NEW_LINE i = 0 NEW_LINE while ( i < len ( smallStr ) ) : NEW_LINE INDENT smallStrCodeTotal += ord ( smallStr [ i ] ) NEW_LINE largeStrCodeTotal += ord ( largeStr [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT largeStrCodeTotal += ord ( largeStr [ i ] ) NEW_LINE intChar = largeStrCodeTotal - smallStrCodeTotal NEW_LINE return chr ( intChar ) NEW_LINE DEDENT s1 = \" abcd \" NEW_LINE s2 = \" cbdae \" NEW_LINE extraChar = findExtraCharacter ( s1 , s2 ) NEW_LINE print ( \" Extra ▁ Character : \" , extraChar ) NEW_LINE"],"bleu":0.6462723521317761,"rouge_l":0.7901234567901234}
{"id":1563,"predictions":["def sortMat ( mat , row , col ) : NEW_LINE INDENT size = row * col NEW_LINE for i in range ( size ) : NEW_LINE INDENT for j in range ( size - 1 ) : NEW_LINE INDENT if ( ( data [ j \/\/ col ] [ j % col ] > data [ ( j + 1 ) \/\/ col ] ) : NEW_LINE INDENT temp = data [ j \/\/ col ] [ j % col ] NEW_LINE data [ j \/\/ col ] = data [ ( ( j + 1 ) \/\/ col ] [ ( j + 1 ) % col ] [ ( j + 1 ) % col ] = temp NEW_LINE DEDENT DEDENT DEDENT DEDENT def printMat ( mat , row , col ) : NEW_LINE INDENT for i in range ( row ) : NEW_LINE INDENT for j in range ( col ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT mat = [ [ 5 , 4 , 7 ] , [ 1 , 3 , 8 ] , [ 2 , 9 , 6 ] , [ 2 , 9 , 6 ] ] NEW_LINE row = len ( mat ) NEW_LINE col = len ( mat ) NEW_LINE sortMat ( mat , row , col ) NEW_LINE printMat ( mat , row , col ) NEW_LINE printMat ( mat , row , col ) NEW_LINE DEDENT"],"references":["def sortMat ( data , row , col ) : NEW_LINE INDENT size = row * col NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT for j in range ( 0 , size - 1 ) : NEW_LINE INDENT if ( data [ j \/\/ col ] [ j % col ] > \\ data [ ( j + 1 ) \/\/ col ] [ ( j + 1 ) % col ] ) : NEW_LINE INDENT temp = data [ j \/\/ col ] [ j % col ] NEW_LINE data [ j \/\/ col ] [ j % col ] = \\ NEW_LINE INDENT data [ ( j + 1 ) \/\/ col ] [ ( j + 1 ) % col ] NEW_LINE DEDENT data [ ( j + 1 ) \/\/ col ] [ ( j + 1 ) % col ] = \\ NEW_LINE INDENT temp NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def printMat ( mat , row , col ) : NEW_LINE INDENT for i in range ( row ) : NEW_LINE INDENT for j in range ( col ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT mat = [ [ 5 , 4 , 7 ] , [ 1 , 3 , 8 ] , [ 2 , 9 , 6 ] ] NEW_LINE row = len ( mat ) NEW_LINE col = len ( mat [ 0 ] ) NEW_LINE sortMat ( mat , row , col ) NEW_LINE printMat ( mat , row , col ) NEW_LINE DEDENT"],"bleu":0.8178355582486635,"rouge_l":0.8846660934365148}
{"id":1564,"predictions":["def distinctDigitSum ( n ) : NEW_LINE INDENT used = [ False ] * 10 NEW_LINE sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT digit = n % 10 NEW_LINE if ( not first [ digit ] ) : NEW_LINE INDENT used [ digit ] = True NEW_LINE sum += digit NEW_LINE DEDENT n = n \/\/ 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT def checkSum ( m , n ) : NEW_LINE INDENT sumM = distinctDigitSum ( m ) NEW_LINE sumN = distinctDigitSum ( n ) NEW_LINE if ( sumM == sumN ) : NEW_LINE INDENT return \" YES \" NEW_LINE DEDENT return \" NO \" NEW_LINE DEDENT m = 2452 NEW_LINE n = 922 NEW_LINE print ( checkSum ( m , n ) ) NEW_LINE"],"references":["def distinctDigitSum ( n ) : NEW_LINE INDENT used = [ False ] * 10 NEW_LINE sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT digit = n % 10 NEW_LINE if ( not used [ digit ] ) : NEW_LINE INDENT used [ digit ] = True NEW_LINE sum += digit NEW_LINE DEDENT n = n \/\/ 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT def checkSum ( m , n ) : NEW_LINE INDENT sumM = distinctDigitSum ( m ) NEW_LINE sumN = distinctDigitSum ( n ) NEW_LINE if ( sumM == sumN ) : NEW_LINE INDENT return \" YES \" NEW_LINE DEDENT return \" NO \" NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT m = 2452 NEW_LINE n = 9222 NEW_LINE print ( checkSum ( m , n ) ) NEW_LINE DEDENT"],"bleu":0.8543979179453441,"rouge_l":0.9268349696119681}
{"id":1565,"predictions":["def initializeDiffArray ( A , D ) : NEW_LINE INDENT n = len ( A ) NEW_LINE D [ 0 ] = A [ 0 ] NEW_LINE D [ n ] = 0 NEW_LINE def update ( D , l , r , x ) : NEW_LINE INDENT D [ l ] += x NEW_LINE D [ l + 1 ] -= x NEW_LINE DEDENT def update ( D , l , r , x ) : NEW_LINE INDENT D [ l ] += x NEW_LINE D [ l + 1 ] -= x NEW_LINE DEDENT def printArray ( A , D ) : NEW_LINE INDENT for i in range ( A ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT A [ i ] = D [ i ] + A [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT A [ i ] = D [ i ] + A [ i - 1 ] NEW_LINE DEDENT print ( A [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE return NEW_LINE DEDENT A = [ 10 , 5 , 20 , 40 ] NEW_LINE n = len ( A ) NEW_LINE updateDiffArray ( A , D ) NEW_LINE update ( A , D ) NEW_LINE update ( A , D ) NEW_LINE update ( D , D ) NEW_LINE update ( A , D ) NEW_LINE update ( A , D ) NEW_LINE update ( D , D ) NEW_LINE update ( A , D ) NEW_LINE update ( A , D ) NEW_LINE update ( D ) NEW_LINE update ( A , D ) NEW_LINE update ( D ) NEW_LINE update ( A , D ) NEW_LINE update ( A , D ) NEW_LINE update ( A , D ) NEW_LINE update ( A , D ) NEW_LINE update ( D ) NEW_LINE update ( A , D ) NEW_LINE"],"references":["def initializeDiffArray ( A ) : NEW_LINE INDENT n = len ( A ) NEW_LINE D = [ 0 for i in range ( 0 , n + 1 ) ] NEW_LINE D [ 0 ] = A [ 0 ] ; D [ n ] = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT D [ i ] = A [ i ] - A [ i - 1 ] NEW_LINE DEDENT return D NEW_LINE DEDENT def update ( D , l , r , x ) : NEW_LINE INDENT D [ l ] += x NEW_LINE D [ r + 1 ] -= x NEW_LINE DEDENT def printArray ( A , D ) : NEW_LINE INDENT for i in range ( 0 , len ( A ) ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT A [ i ] = D [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT A [ i ] = D [ i ] + A [ i - 1 ] NEW_LINE DEDENT print ( A [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( \" \" ) NEW_LINE DEDENT A = [ 10 , 5 , 20 , 40 ] NEW_LINE D = initializeDiffArray ( A ) NEW_LINE update ( D , 0 , 1 , 10 ) NEW_LINE printArray ( A , D ) NEW_LINE update ( D , 1 , 3 , 20 ) NEW_LINE update ( D , 2 , 2 , 30 ) NEW_LINE printArray ( A , D ) NEW_LINE"],"bleu":0.5825709466642071,"rouge_l":0.7182909050128967}
{"id":1566,"predictions":["MAX = 100 NEW_LINE def printPrincipalDiagonal ( mat , n ) : NEW_LINE INDENT print ( \" Principal ▁ Diagonal : ▁ \" , end = \" \" ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , \" , ▁ \" , end = \" \" ) NEW_LINE DEDENT DEDENT print ( \" \" ) NEW_LINE DEDENT print ( \" \" ) NEW_LINE DEDENT def printSecondaryDiagonal ( mat , n ) : NEW_LINE INDENT print ( \" Secondary ▁ Diagonal : ▁ \" , end = \" \" ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( mat [ j ] [ j ] == n ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , \" , ▁ \" , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT print ( ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 NEW_LINE a = [ [ 1 , 2 , 3 , 4 ] , [ 5 , 6 , 7 , 8 ] , [ 1 , 2 , 3 , 4 ] , [ 5 , 6 , 7 , 8 ] ] NEW_LINE printSecondaryDiagonal ( a , n ) NEW_LINE printSecondaryDiagonal ( a , n ) NEW_LINE printSecondaryDiagonal ( a , n ) NEW_LINE DEDENT"],"references":["MAX = 100 NEW_LINE def printPrincipalDiagonal ( mat , n ) : NEW_LINE INDENT print ( \" Principal ▁ Diagonal : ▁ \" , end = \" \" ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = \" , ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT print ( ) NEW_LINE DEDENT def printSecondaryDiagonal ( mat , n ) : NEW_LINE INDENT print ( \" Secondary ▁ Diagonal : ▁ \" , end = \" \" ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( ( i + j ) == ( n - 1 ) ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = \" , ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT print ( ) NEW_LINE DEDENT n = 4 NEW_LINE a = [ [ 1 , 2 , 3 , 4 ] , [ 5 , 6 , 7 , 8 ] , [ 1 , 2 , 3 , 4 ] , [ 5 , 6 , 7 , 8 ] ] NEW_LINE printPrincipalDiagonal ( a , n ) NEW_LINE printSecondaryDiagonal ( a , n ) NEW_LINE"],"bleu":0.7857966576643189,"rouge_l":0.8896918730701006}
{"id":1567,"predictions":["import sys NEW_LINE def FindMinNumber ( arr , n , k ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE min_num = 10 ** 9 NEW_LINE found = False NEW_LINE sum = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT sum = sum + arr [ i ] NEW_LINE if ( sum == k ) : NEW_LINE INDENT min_num = min ( min_num , ( n - ( i + 1 ) ) + j ) NEW_LINE found = True NEW_LINE DEDENT elif ( sum > k ) : NEW_LINE INDENT while ( sum > k ) : NEW_LINE INDENT sum = sum - arr [ j ] NEW_LINE j += 1 NEW_LINE DEDENT if ( sum == k ) : NEW_LINE INDENT min_num = min ( min_num , ( n - ( i + 1 ) ) + j ) ) NEW_LINE found = True NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT if ( found ) : NEW_LINE INDENT return min_num NEW_LINE DEDENT return - 1 NEW_LINE DEDENT arr = [ 1 , 3 , 2 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE k = 5 NEW_LINE print ( FindMinNumber ( arr , n , k ) ) NEW_LINE"],"references":["def FindMinNumber ( arr , n , k ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE min_num = 10 ** 9 NEW_LINE found = False NEW_LINE Sum = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT Sum = Sum + arr [ i ] NEW_LINE if ( Sum == k ) : NEW_LINE INDENT min_num = min ( min_num , ( ( n - ( i + 1 ) ) + j ) ) NEW_LINE found = True NEW_LINE DEDENT elif ( Sum > k ) : NEW_LINE INDENT while ( Sum > k ) : NEW_LINE INDENT Sum = Sum - arr [ j ] NEW_LINE j += 1 NEW_LINE DEDENT if ( Sum == k ) : NEW_LINE INDENT min_num = min ( min_num , ( ( n - ( i + 1 ) ) + j ) ) NEW_LINE found = True NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT if ( found ) : NEW_LINE INDENT return min_num NEW_LINE DEDENT return - 1 NEW_LINE DEDENT arr = [ 1 , 3 , 2 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE k = 5 NEW_LINE print ( FindMinNumber ( arr , n , k ) ) NEW_LINE"],"bleu":0.8746657087346166,"rouge_l":0.9436619718309859}
{"id":1568,"predictions":["def minProduct ( arr , n , k ) : NEW_LINE INDENT pq = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT pq . append ( arr [ i ] ) NEW_LINE DEDENT count = 0 NEW_LINE ans = 1 NEW_LINE while ( len ( pq ) == 0 and count < k ) : NEW_LINE INDENT ans = ans * pq [ 0 ] NEW_LINE pq . pop ( ) NEW_LINE count += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 66 , 76 , 544 , 123 , 154 , 675 ] NEW_LINE k = 2 NEW_LINE n = len ( arr ) NEW_LINE print ( \" Minimum ▁ product ▁ is \" , minProduct ( arr , n , k ) ) NEW_LINE DEDENT"],"references":["import math NEW_LINE import heapq NEW_LINE def minProduct ( arr , n , k ) : NEW_LINE INDENT heapq . heapify ( arr ) NEW_LINE count = 0 NEW_LINE ans = 1 NEW_LINE while ( arr ) and count < k : NEW_LINE INDENT x = heapq . heappop ( arr ) NEW_LINE ans = ans * x NEW_LINE count = count + 1 NEW_LINE DEDENT return ans ; NEW_LINE DEDENT arr = [ 198 , 76 , 544 , 123 , 154 , 675 ] NEW_LINE k = 2 NEW_LINE n = len ( arr ) NEW_LINE print ( \" Minimum ▁ product ▁ is \" , minProduct ( arr , n , k ) ) NEW_LINE"],"bleu":0.5276980602286935,"rouge_l":0.7237157642307206}
{"id":1569,"predictions":["WordsSetTable = [ 0 ] * 256 NEW_LINE def initialize ( ) : NEW_LINE INDENT CountSetTable [ 0 ] = 0 NEW_LINE for i in range ( 256 ) : NEW_LINE INDENT CountSetTable [ i ] = ( i & 1 ) + CountSetTable [ int ( i \/ 2 ) ] NEW_LINE DEDENT DEDENT def countSetBits ( n ) : NEW_LINE INDENT return ( ( CountSetTable [ n & 0 ) ] + CountSetTable [ ( int ( n >> 8 ) ) ] + CountSetTable [ ( int ( n >> 16 ) ) ] ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT initialize ( ) NEW_LINE n = 9 NEW_LINE print ( countSetBits ( n ) ) NEW_LINE DEDENT"],"references":["BitsSetTable256 = [ 0 ] * 256 NEW_LINE def initialize ( ) : NEW_LINE INDENT BitsSetTable256 [ 0 ] = 0 NEW_LINE for i in range ( 256 ) : NEW_LINE INDENT BitsSetTable256 [ i ] = ( i & 1 ) + BitsSetTable256 [ i \/\/ 2 ] NEW_LINE DEDENT DEDENT def countSetBits ( n ) : NEW_LINE INDENT return ( BitsSetTable256 [ n & 0xff ] + BitsSetTable256 [ ( n >> 8 ) & 0xff ] + BitsSetTable256 [ ( n >> 16 ) & 0xff ] + BitsSetTable256 [ n >> 24 ] ) NEW_LINE DEDENT initialize ( ) NEW_LINE n = 9 NEW_LINE print ( countSetBits ( n ) ) NEW_LINE"],"bleu":0.5913108438327639,"rouge_l":0.7885806625370322}
{"id":1570,"predictions":["def numberOfBST ( n ) : NEW_LINE INDENT dp = [ 0 ] * ( n + 1 ) ; NEW_LINE dp [ 0 ] = 1 ; NEW_LINE dp [ 1 ] = 1 ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT dp [ i ] = dp [ i ] + ( dp [ i - j ] * dp [ j - 1 ] ) ; NEW_LINE DEDENT DEDENT return dp [ n ] ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE print ( \" Number ▁ of ▁ struct ▁ \" , n , \" are \" , numberOfBST ( n ) ) ; NEW_LINE DEDENT"],"references":["def numberOfBST ( n ) : NEW_LINE INDENT dp = [ 0 ] * ( n + 1 ) NEW_LINE dp [ 0 ] , dp [ 1 ] = 1 , 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT dp [ i ] = dp [ i ] + ( dp [ i - j ] * dp [ j - 1 ] ) NEW_LINE DEDENT DEDENT return dp [ n ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE print ( \" Number ▁ of ▁ structurally ▁ Unique ▁ BST ▁ with \" , n , \" keys ▁ are ▁ : \" , numberOfBST ( n ) ) NEW_LINE DEDENT"],"bleu":0.8191699870612137,"rouge_l":0.9192532613585246}
{"id":1571,"predictions":["def countdig ( m ) : NEW_LINE INDENT if ( m == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 + countdig ( m \/ 10 ) NEW_LINE DEDENT DEDENT def countSteps ( x ) : NEW_LINE INDENT c = 0 NEW_LINE last = x NEW_LINE while ( last > 0 ) : NEW_LINE INDENT digits = countdig ( last ) NEW_LINE digits -= 1 NEW_LINE divisor = pow ( 10 , digits ) NEW_LINE first = last \/\/ divisor NEW_LINE lastnumber = first * divisor NEW_LINE lastnumber = first * divisor NEW_LINE last = last - ( first * skipped ) NEW_LINE DEDENT return c NEW_LINE DEDENT n = 14 NEW_LINE print ( countSteps ( n ) ) NEW_LINE"],"references":["def countdig ( m ) : NEW_LINE INDENT if ( m == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 + countdig ( m \/\/ 10 ) NEW_LINE DEDENT DEDENT def countSteps ( x ) : NEW_LINE INDENT c = 0 NEW_LINE last = x NEW_LINE while ( last ) : NEW_LINE INDENT digits = countdig ( last ) NEW_LINE digits -= 1 NEW_LINE divisor = pow ( 10 , digits ) NEW_LINE first = last \/\/ divisor NEW_LINE lastnumber = first * divisor NEW_LINE skipped = ( last - lastnumber ) \/\/ first NEW_LINE skipped += 1 NEW_LINE c += skipped NEW_LINE last = last - ( first * skipped ) NEW_LINE DEDENT return c NEW_LINE DEDENT n = 14 NEW_LINE print ( countSteps ( n ) ) NEW_LINE"],"bleu":0.837493107712505,"rouge_l":0.9104477611940299}
{"id":1572,"predictions":["def Add ( x , y ) : NEW_LINE INDENT while ( y != 0 ) : NEW_LINE INDENT carry = x & y NEW_LINE x = x ^ y NEW_LINE y = carry << 1 NEW_LINE DEDENT return x NEW_LINE DEDENT print ( Add ( 15 , 32 ) ) NEW_LINE"],"references":["def Add ( x , y ) : NEW_LINE INDENT while ( y != 0 ) : NEW_LINE INDENT carry = x & y NEW_LINE x = x ^ y NEW_LINE y = carry << 1 NEW_LINE DEDENT return x NEW_LINE DEDENT print ( Add ( 15 , 32 ) ) NEW_LINE"],"bleu":1.0,"rouge_l":1.0}
{"id":1573,"predictions":["def isOverflow ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT result = a * b NEW_LINE if ( a == result \/ b ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT a = \"0000000000100000\" NEW_LINE b = \" - 10000000000\" NEW_LINE if ( isOverflow ( a , b ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def isOverflow ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT result = a * b NEW_LINE if ( result >= 9223372036854775807 or result <= - 9223372036854775808 ) : NEW_LINE INDENT result = 0 NEW_LINE DEDENT if ( a == ( result \/\/ b ) ) : NEW_LINE INDENT print ( result \/\/ b ) NEW_LINE return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 10000000000 NEW_LINE b = - 10000000000 NEW_LINE if ( isOverflow ( a , b ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.5694198336692592,"rouge_l":0.7711244178310046}
{"id":1574,"predictions":["def pairWithEqualSum ( A , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT p = [ A [ i ] , A [ j ] ] NEW_LINE pp = [ ] NEW_LINE if A [ i ] + A [ j ] in mp . keys ( ) : NEW_LINE INDENT pp . append ( mp [ A [ i ] + A [ j ] ] ) NEW_LINE DEDENT pp . append ( p ) NEW_LINE mp [ A [ i ] + A [ j ] ] ] = pp NEW_LINE DEDENT DEDENT for i in mp : NEW_LINE INDENT if ( len ( mp ) ) > 1 ) : NEW_LINE INDENT print ( \" Pairs ▁ : ▁ \" , end = \" \" ) NEW_LINE for i in range ( len ( mp ) ) : NEW_LINE INDENT print ( \" ( \" ) , end = \" \" ) NEW_LINE DEDENT print ( i , mp [ i ] [ 0 ] , end = \" \" ) NEW_LINE DEDENT print ( \" ▁ having ▁ sum ▁ : \" , mp [ i ] [ 1 ] = \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 6 , 4 , 1 , 10 , 20 , 20 , 2 , 2 , 1 , 2 , 1 , 2 , 1 , 2 ] NEW_LINE n = len ( A ) NEW_LINE a = len ( A ) NEW_LINE a = len ( A ) NEW_LINE a = len ( A ) NEW_LINE a = [ ] NEW_LINE for i in range ( len ( A ) ) : NEW_LINE INDENT print ( \" P ) NEW_LINE DEDENT DEDENT if __name__ == \" _ main _ _ \" : NEW_LINE INDENT A = [ 6 , 4 , 1 , 10 , 4 , 20 , 2 , 12 , 2 , 12 , 2 , 1 , 2 , 4 , 2 , 1 , 2 ] NEW_LINE n = len ( A ) NEW_LINE a = len ( A ) NEW_LINE a = len ( A )"],"references":["def pairWithEqualSum ( A , n ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if A [ i ] + A [ j ] in mp : NEW_LINE INDENT mp [ A [ i ] + A [ j ] ] . append ( ( A [ i ] , A [ j ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT mp [ A [ i ] + A [ j ] ] = [ ( A [ i ] , A [ j ] ) ] NEW_LINE DEDENT DEDENT DEDENT for itr in mp : NEW_LINE INDENT if len ( mp [ itr ] ) > 1 : NEW_LINE INDENT print ( \" Pairs ▁ : ▁ \" , end = \" \" ) NEW_LINE for i in range ( 0 , len ( mp [ itr ] ) ) : NEW_LINE INDENT print ( \" ( \" , mp [ itr ] [ i ] [ 0 ] , \" , \" , mp [ itr ] [ i ] [ 1 ] , \" ) \" , end = \" ▁ \" ) NEW_LINE DEDENT print ( \" have ▁ sum ▁ : \" , itr ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 6 , 4 , 12 , 10 , 22 , 54 , 32 , 42 , 21 , 11 , 8 , 2 ] NEW_LINE n = len ( A ) NEW_LINE pairWithEqualSum ( A , n ) NEW_LINE DEDENT"],"bleu":0.47397201364802904,"rouge_l":0.6417563963252001}
{"id":1575,"predictions":["def findValues ( m , n , mth , nth , p ) : NEW_LINE INDENT d = ( ( abs ( mth - nth ) ) \/ abs ( ( m - 1 ) - ( n - 1 ) ) ) NEW_LINE a = mth - ( ( m - 1 ) * d ) NEW_LINE res = [ ] NEW_LINE return res NEW_LINE DEDENT def findSum ( m , n , mth , nth , p ) : NEW_LINE INDENT a = findValues ( m , n , mth , nth ) NEW_LINE a = ad [ 0 ] NEW_LINE d = ad [ 1 ] NEW_LINE sum = ( p * ( 2 * a + ( p - 1 ) * d ) ) ) \/\/ 2 NEW_LINE return sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT m = 6 NEW_LINE n = 10 NEW_LINE mth , nth , p = 12 , 12 , 5 NEW_LINE print ( findSum ( m , n , m ) ) NEW_LINE DEDENT"],"references":["import math as mt NEW_LINE def findingValues ( m , n , mth , nth ) : NEW_LINE INDENT d = ( ( abs ( mth - nth ) ) \/ abs ( ( m - 1 ) - ( n - 1 ) ) ) NEW_LINE a = mth - ( ( m - 1 ) * d ) NEW_LINE return a , d NEW_LINE DEDENT def findSum ( m , n , mth , nth , p ) : NEW_LINE INDENT a , d = findingValues ( m , n , mth , nth ) NEW_LINE Sum = ( p * ( 2 * a + ( p - 1 ) * d ) ) \/ 2 NEW_LINE return Sum NEW_LINE DEDENT m = 6 NEW_LINE n = 10 NEW_LINE mTerm = 12 NEW_LINE nTerm = 20 NEW_LINE p = 5 NEW_LINE print ( findSum ( m , n , mTerm , nTerm , p ) ) NEW_LINE"],"bleu":0.6478199816770935,"rouge_l":0.779100145137881}
{"id":1576,"predictions":["def sameOccurrence ( arr , n , x , y ) : NEW_LINE INDENT countX = [ 0 ] * n NEW_LINE countY = [ 0 ] * n NEW_LINE m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == x ) : NEW_LINE INDENT if ( i != x ) : NEW_LINE INDENT countX [ i ] = countX [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT countX [ i ] = 1 NEW_LINE DEDENT DEDENT if ( arr [ i ] == y ) : NEW_LINE INDENT countX [ i ] = countX [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT countX [ i ] = 0 NEW_LINE DEDENT DEDENT if ( countX [ i ] == y ) : NEW_LINE INDENT if ( i != 0 ) : NEW_LINE INDENT countY [ i ] = countY [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT countY [ i ] = 1 NEW_LINE DEDENT DEDENT if ( countX [ i ] - countY [ i ] ) in m . keys ( ) ) : NEW_LINE INDENT countY [ countX [ i ] = countY [ i ] = countY [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT countX [ countX [ i ] = countY [ i ] NEW_LINE DEDENT DEDENT result = m [ 0 ] NEW_LINE for i in m : NEW_LINE INDENT result = ( result + ( ( ( countX [ i ] ) * ( ( ( countX [ i ] ) - countY [ i ] ) ) ) \/\/ 2 NEW_LINE DEDENT return ( result ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 2 , 3 , 4 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE x = 2 NEW_LINE y = 3 NEW_LINE print ( sameOccurrence ( arr , n , x , y ) ) NEW_LINE DEDENT"],"references":["def sameOccurrence ( arr , n , x , y ) : NEW_LINE INDENT countX = [ 0 for i in range ( n ) ] NEW_LINE countY = [ 0 for i in range ( n ) ] NEW_LINE m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == x ) : NEW_LINE INDENT if ( i != 0 ) : NEW_LINE INDENT countX [ i ] = countX [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT countX [ i ] = 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( i != 0 ) : NEW_LINE INDENT countX [ i ] = countX [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT countX [ i ] = 0 NEW_LINE DEDENT DEDENT if ( arr [ i ] == y ) : NEW_LINE INDENT if ( i != 0 ) : NEW_LINE INDENT countY [ i ] = countY [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT countY [ i ] = 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( i != 0 ) : NEW_LINE INDENT countY [ i ] = countY [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT countY [ i ] = 0 NEW_LINE DEDENT DEDENT m [ countX [ i ] - countY [ i ] ] = m . get ( countX [ i ] - countY [ i ] , 0 ) + 1 NEW_LINE DEDENT result = m [ 0 ] NEW_LINE for j in m : NEW_LINE INDENT result += ( m [ j ] * ( m [ j ] - 1 ) ) \/\/ 2 NEW_LINE DEDENT return result NEW_LINE DEDENT arr = [ 1 , 2 , 2 , 3 , 4 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE x , y = 2 , 3 NEW_LINE print ( sameOccurrence ( arr , n , x , y ) ) NEW_LINE"],"bleu":0.7469270759216894,"rouge_l":0.795689373042218}
{"id":1577,"predictions":["def findNonPalinString ( s ) : NEW_LINE INDENT freq = [ 0 ] * 26 ; NEW_LINE flag = 0 ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] != s [ 0 ] ) : NEW_LINE INDENT flag = 1 ; NEW_LINE DEDENT freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT if ( flag == 0 ) : NEW_LINE INDENT print ( \" - 1\" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 0 , 26 ) : NEW_LINE INDENT for j in range ( 0 , freq [ i ] ) : NEW_LINE INDENT print ( chr ( 97 + i ) , end = \" \" ) ; NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" abba \" ; NEW_LINE findNonPalinString ( s ) ; NEW_LINE DEDENT"],"references":["def findNonPalinString ( s ) : NEW_LINE INDENT freq = [ 0 ] * ( 26 ) NEW_LINE flag = 0 NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT if s [ i ] != s [ 0 ] : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT if not flag : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 0 , 26 ) : NEW_LINE INDENT for j in range ( 0 , freq [ i ] ) : NEW_LINE INDENT print ( chr ( ord ( ' a ' ) + i ) , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" abba \" NEW_LINE findNonPalinString ( s ) NEW_LINE DEDENT"],"bleu":0.794700435182738,"rouge_l":0.9263610315186247}
{"id":1578,"predictions":["def isFrequencyEqual ( str , len ) : NEW_LINE INDENT if ( len % 2 == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT freq = [ 0 ] * 26 NEW_LINE for i in range ( 0 , len ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( freq [ i ] == int ( l \/ 2 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT str = \" geeksforgeeks \" NEW_LINE l = len ( str ) NEW_LINE if ( isFrequencyEqual ( str , l ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def isFrequencyEqual ( string , length ) : NEW_LINE INDENT if length % 2 == 1 : NEW_LINE INDENT return False NEW_LINE DEDENT freq = [ 0 ] * 26 NEW_LINE for i in range ( 0 , length ) : NEW_LINE INDENT freq [ ord ( string [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 0 , 26 ) : NEW_LINE INDENT if freq [ i ] == length \/\/ 2 : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" geeksforgeeks \" NEW_LINE length = len ( string ) NEW_LINE if isFrequencyEqual ( string , length ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.6685451864662437,"rouge_l":0.8337129840546698}
{"id":1579,"predictions":["import math NEW_LINE def summ ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( n % 9 == 0 ) NEW_LINE DEDENT def printDigitalRoot ( n ) : NEW_LINE INDENT maxi = 1 NEW_LINE dig = 1 NEW_LINE for i in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT d1 = summ ( n \/\/ i ) NEW_LINE d2 = summ ( i ) NEW_LINE if ( d1 > maxi ) : NEW_LINE INDENT dig = n \/\/ i NEW_LINE maxi = d1 NEW_LINE DEDENT if ( d2 > maxi ) : NEW_LINE INDENT dig = i NEW_LINE maxi = d2 NEW_LINE DEDENT if ( d1 == maxi ) : NEW_LINE INDENT dig = i NEW_LINE maxi = d2 NEW_LINE DEDENT if ( d1 == maxi ) : NEW_LINE INDENT dig = n \/\/ i NEW_LINE maxi = d1 NEW_LINE DEDENT DEDENT print ( dig , mini ) NEW_LINE DEDENT n = 10 NEW_LINE printDigitalRoot ( n ) NEW_LINE"],"references":["def summ ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( n % 9 == 0 ) : NEW_LINE INDENT return 9 ; NEW_LINE DEDENT else : NEW_LINE INDENT return ( n % 9 ) ; NEW_LINE DEDENT DEDENT def printDigitalRoot ( n ) : NEW_LINE INDENT maxi = 1 ; NEW_LINE dig = 1 ; NEW_LINE for i in range ( 1 , int ( pow ( n , 1 \/ 2 ) + 1 ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT d1 = summ ( n \/ i ) ; NEW_LINE d2 = summ ( i ) ; NEW_LINE if ( d1 > maxi ) : NEW_LINE INDENT dig = n \/ i ; NEW_LINE maxi = d1 ; NEW_LINE DEDENT if ( d2 > maxi ) : NEW_LINE INDENT dig = i ; NEW_LINE maxi = d2 ; NEW_LINE DEDENT if ( d1 == maxi ) : NEW_LINE INDENT if ( dig < ( n \/ i ) ) : NEW_LINE INDENT dig = n \/ i ; NEW_LINE maxi = d1 ; NEW_LINE DEDENT DEDENT if ( d2 == maxi ) : NEW_LINE INDENT if ( dig < i ) : NEW_LINE INDENT dig = i ; NEW_LINE maxi = d2 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( int ( dig ) , \" ▁ \" , int ( maxi ) ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 ; NEW_LINE printDigitalRoot ( n ) ; NEW_LINE DEDENT"],"bleu":0.4725992721135486,"rouge_l":0.7296749341082651}
{"id":1580,"predictions":["def countSubarrays ( arr , n ) : NEW_LINE INDENT difference = 0 NEW_LINE ans = 0 NEW_LINE hash_positive = [ 0 for i in range ( n + 1 ) ] NEW_LINE hash_negative = [ 0 for i in range ( n + 1 ) ] NEW_LINE hash_positive [ 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( arr [ i ] & 1 ) == 1 ) : NEW_LINE INDENT difference += 1 NEW_LINE DEDENT else : NEW_LINE INDENT difference -= 1 NEW_LINE DEDENT if ( difference < 0 ) : NEW_LINE INDENT ans += hash_negative [ - difference ] NEW_LINE hash_negative [ - difference ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += hash_positive [ difference ] NEW_LINE hash_positive [ difference ] += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 3 , 4 , 4 , 6 , 8 , 1 , 10 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Total ▁ Number ▁ of ▁ Even - Odd ▁ are \" , countSubarrays ( arr , n ) ) NEW_LINE"],"references":["def countSubarrays ( arr , n ) : NEW_LINE INDENT difference = 0 NEW_LINE ans = 0 NEW_LINE hash_positive = [ 0 ] * ( n + 1 ) NEW_LINE hash_negative = [ 0 ] * ( n + 1 ) NEW_LINE hash_positive [ 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 == 1 ) : NEW_LINE INDENT difference = difference + 1 NEW_LINE DEDENT else : NEW_LINE INDENT difference = difference - 1 NEW_LINE DEDENT if ( difference < 0 ) : NEW_LINE INDENT ans += hash_negative [ - difference ] NEW_LINE hash_negative [ - difference ] = hash_negative [ - difference ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += hash_positive [ difference ] NEW_LINE hash_positive [ difference ] = hash_positive [ difference ] + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 3 , 4 , 6 , 8 , 1 , 10 , 5 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Total ▁ Number ▁ of ▁ Even - Odd ▁ subarrays ▁ are ▁ \" + str ( countSubarrays ( arr , n ) ) ) NEW_LINE"],"bleu":0.7605461234968776,"rouge_l":0.8690437862202189}
{"id":1581,"predictions":["MAX = 1000000 NEW_LINE prime = [ True for i in range ( MAX + 1 ) ] NEW_LINE def sieve ( ) : NEW_LINE INDENT prime [ 0 ] = prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= MAX : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def distinctSum ( arr1 , arr2 , m , n ) : NEW_LINE INDENT sieve ( ) NEW_LINE sumSet = set ( ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( prime [ arr1 [ i ] ] and prime [ arr2 [ j ] ] ] ) : NEW_LINE INDENT sumSet . add ( arr1 [ i ] + arr2 [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return len ( sumSet ) NEW_LINE DEDENT arr1 = [ 2 , 3 ] NEW_LINE arr2 = [ 2 , 2 , 4 , 7 ] NEW_LINE m = len ( arr1 ) NEW_LINE n = len ( arr2 ) NEW_LINE print ( distinctSum ( arr1 , arr2 , m , n ) ) NEW_LINE"],"references":["MAX = 1000000 NEW_LINE prime = [ True for i in range ( MAX + 1 ) ] NEW_LINE def sieve ( ) : NEW_LINE INDENT prime [ 0 ] , prime [ 1 ] = False , False NEW_LINE for p in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if p * p > MAX : NEW_LINE INDENT break NEW_LINE DEDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( 2 * p , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def distinctSum ( arr1 , arr2 , m , n ) : NEW_LINE INDENT sieve ( ) NEW_LINE sumSet = dict ( ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( prime [ arr1 [ i ] ] and prime [ arr2 [ j ] ] ) : NEW_LINE INDENT sumSet [ arr1 [ i ] + arr2 [ j ] ] = 1 NEW_LINE DEDENT DEDENT DEDENT return len ( sumSet ) NEW_LINE DEDENT arr1 = [ 2 , 3 ] NEW_LINE arr2 = [ 2 , 2 , 4 , 7 ] NEW_LINE m = len ( arr1 ) NEW_LINE n = len ( arr2 ) NEW_LINE print ( distinctSum ( arr1 , arr2 , m , n ) ) NEW_LINE"],"bleu":0.842536638071279,"rouge_l":0.9194929770469339}
{"id":1582,"predictions":["def shufleArray ( a , n ) : NEW_LINE INDENT n = int ( n \/ 2 ) NEW_LINE start = n + 1 NEW_LINE j = n + 1 NEW_LINE done = 0 NEW_LINE while ( done < 2 * n - 2 ) : NEW_LINE INDENT if ( start == j ) : NEW_LINE INDENT start -= 1 NEW_LINE j -= 1 NEW_LINE DEDENT i = 2 * i - 1 NEW_LINE DEDENT temp = a [ start ] NEW_LINE if ( j > n - 2 * n - 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT j = a [ start ] NEW_LINE a [ start ] = 2 * i - 1 NEW_LINE DEDENT DEDENT a = [ - 1 , 1 , 3 , 5 , 7 , 2 , 4 , 6 , 8 ] NEW_LINE n = len ( a ) NEW_LINE shufleArray ( a , n ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT print ( a [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT"],"references":["def shufleArray ( a , n ) : NEW_LINE INDENT n = n \/\/ 2 NEW_LINE start = n + 1 NEW_LINE j = n + 1 NEW_LINE for done in range ( 2 * n - 2 ) : NEW_LINE INDENT if ( start == j ) : NEW_LINE INDENT start -= 1 NEW_LINE j -= 1 NEW_LINE DEDENT i = j - n if j > n else j NEW_LINE j = 2 * i if j > n else 2 * i - 1 NEW_LINE a [ start ] , a [ j ] = a [ j ] , a [ start ] NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ - 1 , 1 , 3 , 5 , 7 , 2 , 4 , 6 , 8 ] NEW_LINE n = len ( a ) NEW_LINE shufleArray ( a , n ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT print ( a [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.7184407746793051,"rouge_l":0.7834271639690359}
{"id":1583,"predictions":["MAX = 100005 NEW_LINE def Min_Replace ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE freq = [ 0 ] * MAX NEW_LINE p = 0 NEW_LINE freq [ p ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i - 1 ] ) : NEW_LINE INDENT freq [ p ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ p ] += 1 NEW_LINE DEDENT DEDENT freq . sort ( reverse = True ) NEW_LINE ans = 0 NEW_LINE for i in range ( k , p + 1 ) : NEW_LINE INDENT ans += freq [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 2 , 7 , 8 , 2 , 3 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE print ( Min_Replace ( arr , n , k ) ) NEW_LINE"],"references":["MAX = 100005 NEW_LINE def Min_Replace ( arr , n , k ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE freq = [ 0 for i in range ( MAX ) ] NEW_LINE p = 0 NEW_LINE freq [ p ] = 1 NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i - 1 ] ) : NEW_LINE INDENT freq [ p ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT p += 1 NEW_LINE freq [ p ] += 1 NEW_LINE DEDENT DEDENT freq . sort ( reverse = True ) NEW_LINE ans = 0 NEW_LINE for i in range ( k , p + 1 , 1 ) : NEW_LINE INDENT ans += freq [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 7 , 8 , 2 , 3 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE print ( Min_Replace ( arr , n , k ) ) NEW_LINE DEDENT"],"bleu":0.7874080698292915,"rouge_l":0.8966732571133842}
{"id":1584,"predictions":["MAX = 1000 NEW_LINE size = 1 NEW_LINE def factorial ( prevFact , prev , n ) : NEW_LINE INDENT for x in range ( prev + 1 , n + 1 ) : NEW_LINE INDENT size = multiply ( x , prevFact , size ) NEW_LINE DEDENT for i in range ( size - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( prevFact [ i ] , end = \" \" ) NEW_LINE DEDENT print ( \" ▁ \" , end = \" \" ) NEW_LINE DEDENT def factorialFactorials ( limit ) : NEW_LINE INDENT if ( limit < 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT a = 1 NEW_LINE b = 1 NEW_LINE c = 2 NEW_LINE print ( a , b , end = \" ▁ \" ) NEW_LINE a = [ 0 ] * MAX NEW_LINE b = [ 0 ] * MAX NEW_LINE while ( c < limit ) : NEW_LINE INDENT find ( preFact , b , c ) NEW_LINE a = b NEW_LINE b = c NEW_LINE c = a + b NEW_LINE DEDENT DEDENT def fact ( x , prevFactorials ( x , prev ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT prev = preFactorial [ i ] * x + curr [ c ] NEW_LINE a = b NEW_LINE b = c NEW_LINE c = a + b NEW_LINE DEDENT return size NEW_LINE DEDENT if __name__ == \" _ _ main _ \" : NEW_LINE INDENT limit = 20 NEW_LINE print ( largestFactorials ( MAX ) ) NEW_LINE DEDENT"],"references":["MAX = 500 NEW_LINE size = 1 NEW_LINE def factorial ( prevFact , prev , n ) : NEW_LINE INDENT global size NEW_LINE for x in range ( ( prev + 1 ) , n + 1 ) : NEW_LINE INDENT size = multiply ( x , prevFact , size ) NEW_LINE DEDENT for i in range ( ( size - 1 ) , - 1 , - 1 ) : NEW_LINE INDENT print ( prevFact [ i ] , end = \" \" ) NEW_LINE DEDENT print ( end = \" ▁ \" ) NEW_LINE DEDENT def printfibFactorials ( limit ) : NEW_LINE INDENT if ( limit < 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT a = 1 NEW_LINE b = 1 NEW_LINE c = 2 NEW_LINE print ( a , b , end = \" ▁ \" ) NEW_LINE prevFact = [ 0 ] * MAX NEW_LINE prevFact [ 0 ] = 1 NEW_LINE while ( c < limit ) : NEW_LINE INDENT factorial ( prevFact , b , c ) NEW_LINE a = b NEW_LINE b = c NEW_LINE c = a + b NEW_LINE DEDENT DEDENT def multiply ( x , prevFact , size ) : NEW_LINE INDENT carry = 0 NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT prod = prevFact [ i ] * x + carry NEW_LINE prevFact [ i ] = prod % 10 NEW_LINE carry = prod \/\/ 10 NEW_LINE DEDENT while ( carry != 0 ) : NEW_LINE INDENT prevFact [ size ] = carry % 10 NEW_LINE carry = carry \/\/ 10 NEW_LINE size = size + 1 NEW_LINE DEDENT return size NEW_LINE DEDENT limit = 20 NEW_LINE printfibFactorials ( limit ) NEW_LINE"],"bleu":0.6605634473925602,"rouge_l":0.802076124567474}
{"id":1585,"predictions":["MAX = 3000 ; NEW_LINE def fastNumber ( n ) : NEW_LINE INDENT primes = [ 0 ] * MAX ; NEW_LINE result = [ ] ; NEW_LINE for i in range ( 2 , MAX ) : NEW_LINE INDENT if ( primes [ i ] == 0 ) : NEW_LINE INDENT primes [ i ] = 1 ; NEW_LINE for j in range ( i * 2 , MAX , i ) : NEW_LINE INDENT primes [ j ] -= 1 ; NEW_LINE if ( primes [ j ] + 3 ) == 0 : NEW_LINE INDENT result . append ( j ) ; NEW_LINE DEDENT DEDENT DEDENT result . sort ( ) ; NEW_LINE return result [ n - 1 ] ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 50 ; NEW_LINE print ( kindNumber ( n ) ) ; NEW_LINE DEDENT"],"references":["MAX = 3000 ; NEW_LINE def smartNumber ( n ) : NEW_LINE INDENT primes = [ 0 ] * MAX ; NEW_LINE result = [ ] ; NEW_LINE for i in range ( 2 , MAX ) : NEW_LINE INDENT if ( primes [ i ] == 0 ) : NEW_LINE INDENT primes [ i ] = 1 ; NEW_LINE j = i * 2 ; NEW_LINE while ( j < MAX ) : NEW_LINE INDENT primes [ j ] -= 1 ; NEW_LINE if ( ( primes [ j ] + 3 ) == 0 ) : NEW_LINE INDENT result . append ( j ) ; NEW_LINE DEDENT j = j + i ; NEW_LINE DEDENT DEDENT DEDENT result . sort ( ) ; NEW_LINE return result [ n - 1 ] ; NEW_LINE DEDENT n = 50 ; NEW_LINE print ( smartNumber ( n ) ) ; NEW_LINE"],"bleu":0.7836167862601128,"rouge_l":0.8638918918918917}
{"id":1586,"predictions":["def countPairs ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for x in range ( 1 , n ) : NEW_LINE INDENT for y in range ( x + 1 , n + 1 ) : NEW_LINE INDENT if ( ( y + x ) % ( y ^ x ) == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 6 NEW_LINE print ( countPairs ( n ) ) NEW_LINE DEDENT"],"references":["def countPairs ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE for x in range ( 1 , n ) : NEW_LINE INDENT for y in range ( x + 1 , n + 1 ) : NEW_LINE INDENT if ( ( y + x ) % ( y ^ x ) == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 6 ; NEW_LINE print ( countPairs ( n ) ) ; NEW_LINE DEDENT"],"bleu":0.874958388069239,"rouge_l":0.9701789264413518}
{"id":1587,"predictions":["class G : NEW_LINE INDENT def __init__ ( self , x , x , start = None ) : NEW_LINE INDENT if ( start == len ) : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT return x NEW_LINE DEDENT DEDENT smallIndex = LeftIndexesRecursive ( input , x , start , start , start + 1 ) NEW_LINE if ( Input [ start ] == x ) : NEW_LINE INDENT myAns = [ ] NEW_LINE myAns [ 0 ] = start NEW_LINE for i in range ( smallIndex ) : NEW_LINE INDENT myAns [ i + 1 ] = smallIndex [ i ] NEW_LINE DEDENT return myAns NEW_LINE DEDENT else : NEW_LINE INDENT return smallIndexes NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 , 2 , 2 , 5 ] NEW_LINE x = 2 NEW_LINE output = 2 NEW_LINE output = [ ] NEW_LINE for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT print ( output [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 2 , 2 , 5 ] NEW_LINE x = 2 NEW_LINE output = [ ] NEW_LINE for i in range ( 0 , len ( output ) ) : NEW_LINE INDENT print ( output ) NEW_LINE DEDENT DEDENT"],"references":["def AllIndexesRecursive ( input , x , start ) : NEW_LINE INDENT if ( start == len ( input ) ) : NEW_LINE INDENT ans = [ ] NEW_LINE return ans NEW_LINE DEDENT smallIndex = AllIndexesRecursive ( input , x , start + 1 ) NEW_LINE if ( input [ start ] == x ) : NEW_LINE INDENT myAns = [ 0 for i in range ( len ( smallIndex ) + 1 ) ] NEW_LINE myAns [ 0 ] = start NEW_LINE for i in range ( len ( smallIndex ) ) : NEW_LINE INDENT myAns [ i + 1 ] = smallIndex [ i ] NEW_LINE DEDENT return myAns NEW_LINE DEDENT else : NEW_LINE INDENT return smallIndex NEW_LINE DEDENT DEDENT def AllIndexes ( input , x ) : NEW_LINE INDENT return AllIndexesRecursive ( input , x , 0 ) NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 2 , 2 , 5 ] NEW_LINE x = 2 NEW_LINE output = AllIndexes ( arr , x ) NEW_LINE for i in output : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT"],"bleu":0.5333561801923027,"rouge_l":0.6585119602360983}
{"id":1588,"predictions":["import math NEW_LINE def fib ( n ) : NEW_LINE INDENT phi = ( 1 + math . sqrt ( 5 ) ) \/ 2 NEW_LINE return round ( pow ( phi , n ) \/ math . sqrt ( 5 ) ) NEW_LINE DEDENT def calculateSum ( l , r ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT sum += fib ( i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT l = 4 NEW_LINE r = 8 NEW_LINE print ( calculateSum ( l , r ) ) NEW_LINE"],"references":["def fib ( n ) : NEW_LINE INDENT phi = ( ( 1 + ( 5 ** ( 1 \/ 2 ) ) ) \/ 2 ) ; NEW_LINE return round ( ( phi ** n ) \/ ( 5 ** ( 1 \/ 2 ) ) ) ; NEW_LINE DEDENT def calculateSum ( l , r ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT sum += fib ( i ) ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT l , r = 4 , 8 ; NEW_LINE print ( calculateSum ( l , r ) ) ; NEW_LINE DEDENT"],"bleu":0.5090089000492697,"rouge_l":0.7558123346791035}
{"id":1589,"predictions":["def findSum ( N ) : NEW_LINE INDENT return ( N * ( N + 1 ) * ( 2 * N - 5 ) + 4 * N ) \/\/ 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE print ( findSum ( N ) ) NEW_LINE DEDENT"],"references":["def findSum ( N ) : NEW_LINE INDENT return ( ( N * ( N + 1 ) * ( 2 * N - 5 ) + 4 * N ) \/ 2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE print ( findSum ( N ) ) NEW_LINE DEDENT"],"bleu":0.9007012285408049,"rouge_l":0.9643622722400859}
{"id":1590,"predictions":["def sumOfPrevK ( N , K ) : NEW_LINE INDENT arr = [ 0 ] * N ; NEW_LINE arr [ 0 ] = 1 ; NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT j = i - 1 ; NEW_LINE count = 0 ; NEW_LINE sum = 0 ; NEW_LINE while ( j >= 0 and count < K ) : NEW_LINE INDENT sum += arr [ j ] ; NEW_LINE j -= 1 ; NEW_LINE count += 1 ; NEW_LINE DEDENT arr [ i ] = sum ; NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT N = 10 ; NEW_LINE K = 4 ; NEW_LINE sumOfPrevK ( N , K ) ; NEW_LINE"],"references":["def sumOfPrevK ( N , K ) : NEW_LINE INDENT arr = [ 0 for i in range ( N ) ] NEW_LINE arr [ 0 ] = 1 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT j = i - 1 NEW_LINE count = 0 NEW_LINE sum = 0 NEW_LINE while ( j >= 0 and count < K ) : NEW_LINE INDENT sum = sum + arr [ j ] NEW_LINE j = j - 1 NEW_LINE count = count + 1 NEW_LINE DEDENT arr [ i ] = sum NEW_LINE DEDENT for i in range ( 0 , N ) : NEW_LINE INDENT print ( arr [ i ] ) NEW_LINE DEDENT DEDENT N = 10 NEW_LINE K = 4 NEW_LINE sumOfPrevK ( N , K ) NEW_LINE"],"bleu":0.6611536547137203,"rouge_l":0.8522377456784276}
{"id":1591,"predictions":["def productDivisible ( n , k ) : NEW_LINE INDENT product = 1 NEW_LINE position = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( position % 2 == 0 ) : NEW_LINE INDENT product *= n % 10 NEW_LINE DEDENT n = n \/\/ 10 NEW_LINE position += 1 NEW_LINE DEDENT if ( product % k == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT n = 321922 NEW_LINE k = 3 NEW_LINE if ( productDivisible ( n , k ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"],"references":["def productDivisible ( n , k ) : NEW_LINE INDENT product = 1 NEW_LINE position = 1 NEW_LINE while n > 0 : NEW_LINE INDENT if position % 2 == 0 : NEW_LINE INDENT product *= n % 10 NEW_LINE DEDENT n = n \/ 10 NEW_LINE position += 1 NEW_LINE DEDENT if product % k == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT n = 321922 NEW_LINE k = 3 NEW_LINE if productDivisible ( n , k ) == True : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"],"bleu":0.7975475611659785,"rouge_l":0.9510222091484042}
{"id":1592,"predictions":["import math NEW_LINE def countPairs ( N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , n ** ( 1. \/ 3 ) ) : NEW_LINE INDENT cb = i * i * i NEW_LINE diff = N - cb NEW_LINE cbrtDiff = ( diff ) NEW_LINE if ( cbrtDiff * cbrtDiff == diff ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT N = 1 NEW_LINE for i in range ( 1 , 11 ) : NEW_LINE INDENT print ( \" For ▁ n ▁ = \" , i , \" , ▁ \" , countPairs ( i ) ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def countPairs ( N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , int ( math . pow ( N , 1 \/ 3 ) + 1 ) ) : NEW_LINE INDENT cb = i * i * i NEW_LINE diff = N - cb NEW_LINE cbrtDiff = int ( math . pow ( diff , 1 \/ 3 ) ) NEW_LINE if ( cbrtDiff * cbrtDiff * cbrtDiff == diff ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT for i in range ( 1 , 11 ) : NEW_LINE INDENT print ( ' For ▁ n ▁ = ▁ ' , i , ' , ▁ ' , countPairs ( i ) , ' ▁ pair ▁ exists ' ) NEW_LINE DEDENT"],"bleu":0.6332584221081109,"rouge_l":0.8036582246098748}
{"id":1593,"predictions":["MAX = 100 NEW_LINE Prefix = [ ] NEW_LINE def repeated_digit ( n ) : NEW_LINE INDENT a = set ( ) NEW_LINE d = 0 NEW_LINE while ( n ) : NEW_LINE INDENT d = n % 10 NEW_LINE if d in a : NEW_LINE INDENT return 0 NEW_LINE DEDENT a . add ( d ) NEW_LINE n \/\/= 10 NEW_LINE DEDENT return 1 NEW_LINE DEDENT def pre_calculations ( ) : NEW_LINE INDENT Prefix . append ( 0 ) NEW_LINE Prefix . append ( repeated_digit ( 1 ) ) NEW_LINE for i in range ( 2 , MAX + 1 ) : NEW_LINE INDENT Prefix . append ( repeated_digit ( i ) + Prefix [ i - 1 ] ) NEW_LINE DEDENT DEDENT def calculate ( L , R ) : NEW_LINE INDENT return Prefix [ R ] - Prefix [ L - 1 ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT L = 1 NEW_LINE R = 100 NEW_LINE pre_calculations ( ) NEW_LINE print ( calculate ( L , R ) ) NEW_LINE DEDENT"],"references":["Prefix = [ 0 ] NEW_LINE def repeated_digit ( n ) : NEW_LINE INDENT a = [ ] NEW_LINE while n != 0 : NEW_LINE INDENT d = n % 10 NEW_LINE if d in a : NEW_LINE INDENT return 0 NEW_LINE DEDENT a . append ( d ) NEW_LINE n = n \/\/ 10 NEW_LINE DEDENT return 1 NEW_LINE DEDENT def pre_calculation ( MAX ) : NEW_LINE INDENT global Prefix NEW_LINE Prefix . append ( repeated_digit ( 1 ) ) NEW_LINE for i in range ( 2 , MAX + 1 ) : NEW_LINE INDENT Prefix . append ( repeated_digit ( i ) + Prefix [ i - 1 ] ) NEW_LINE DEDENT DEDENT def calculate ( L , R ) : NEW_LINE INDENT return Prefix [ R ] - Prefix [ L - 1 ] NEW_LINE DEDENT MAX = 1000 NEW_LINE pre_calculation ( MAX ) NEW_LINE L = 1 NEW_LINE R = 100 NEW_LINE print ( calculate ( L , R ) ) NEW_LINE"],"bleu":0.7285716530879965,"rouge_l":0.8420953101361572}
{"id":1594,"predictions":["def Profitives ( n ) : NEW_LINE INDENT i = 2 NEW_LINE while ( True ) : NEW_LINE INDENT if ( i > n ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT n -= n \/\/ i NEW_LINE DEDENT DEDENT n = 17 NEW_LINE if ( True Yesives ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def Survives ( n ) : NEW_LINE INDENT i = 2 NEW_LINE while ( True ) : NEW_LINE INDENT if ( i > n ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT n -= n \/\/ i ; NEW_LINE i += 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 17 ; NEW_LINE if ( Survives ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"],"bleu":0.6344735726687791,"rouge_l":0.8399810066476733}
{"id":1595,"predictions":["def maxPerimeter ( arr1 , n ) : NEW_LINE INDENT maxi = 0 ; NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT a = arr [ i ] ; NEW_LINE b = arr [ j ] ; NEW_LINE c = arr [ k ] ; NEW_LINE if ( a < b + c and b < c + a and c < a + b ) : NEW_LINE INDENT maxi = max ( maxi , a + b + c ) ; NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( maxi ) : NEW_LINE INDENT print ( \" Maximum ▁ Perimeter ▁ is : ▁ \" , maxi ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Maximum ▁ formation ▁ formation ▁ is ▁ \" + str ( maxi ) ) ; NEW_LINE DEDENT DEDENT arr1 = [ 6 , 1 , 6 , 5 , 5 , 8 , 4 ] ; NEW_LINE maxPerimeter ( arr1 ) ; NEW_LINE arr2 = [ 2 , 20 , 6 , 5 , 1 , 10 , 4 ] ; NEW_LINE a = [ 2 , 20 , 1 , 1 , 10 , 1 , 3 , 12 , 4 ] ; NEW_LINE a = [ 2 , 20 , 1 , 10 , 10 , 1 , 10 , 10 , 10 , 4 ] ; NEW_LINE a = [ 3 , 1 , 1 , 10 , 10 , 10 , 12 , 5 , 1 ] ; NEW_LINE print ( \" Maximum ▁ Perimeter ▁ is ▁ is : \" \" ) ; NEW_LINE DEDENT"],"references":["def maxPerimeter ( arr ) : NEW_LINE INDENT maxi = 0 NEW_LINE n = len ( arr ) NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT a = arr [ i ] NEW_LINE b = arr [ j ] NEW_LINE c = arr [ k ] NEW_LINE if ( a < b + c and b < a + c and c < a + b ) : NEW_LINE INDENT maxi = max ( maxi , a + b + c ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( maxi == 0 ) : NEW_LINE INDENT return \" Triangle ▁ formation ▁ is ▁ not ▁ possible \" NEW_LINE DEDENT else : NEW_LINE INDENT return \" Maximum ▁ Perimeter ▁ is : ▁ \" + str ( maxi ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT arr1 = [ 6 , 1 , 6 , 5 , 8 , 4 ] NEW_LINE a = maxPerimeter ( arr1 ) NEW_LINE print ( a ) NEW_LINE arr2 = [ 2 , 20 , 7 , 55 , 1 , 33 , 12 , 4 ] NEW_LINE a = maxPerimeter ( arr2 ) NEW_LINE print ( a ) NEW_LINE arr3 = [ 33 , 6 , 20 , 1 , 8 , 12 , 5 , 55 , 4 , 9 ] NEW_LINE a = maxPerimeter ( arr3 ) NEW_LINE print ( a ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"bleu":0.5682367909588546,"rouge_l":0.7081204176849589}
{"id":1596,"predictions":["import math NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT s = ( int ) ( math . sqrt ( x ) ) NEW_LINE return ( s * s == x ) NEW_LINE DEDENT def isFibonacci ( N ) : NEW_LINE INDENT return ( isPerfectSquare ( 5 * N * N + 4 ) or isPerfectSquare ( 5 * N * N - 4 ) ) NEW_LINE DEDENT def nextNonFibonacci ( N ) : NEW_LINE INDENT if ( N <= 3 ) : NEW_LINE INDENT return 4 NEW_LINE DEDENT if ( isFibonacci ( N + 1 ) ) : NEW_LINE INDENT return N + 2 NEW_LINE DEDENT else : NEW_LINE INDENT return N + 1 NEW_LINE DEDENT DEDENT N = 3 NEW_LINE print ( nextNonFibonacci ( N ) ) NEW_LINE N = 5 NEW_LINE print ( nextNonFibonacci ( N ) ) NEW_LINE N = 5 NEW_LINE print ( nextNonFibonacci ( N ) ) NEW_LINE N = 7 NEW_LINE print ( nextNonFibonacci ( N ) ) NEW_LINE N = 7 NEW_LINE print ( nextNonFibonacci ( N ) ) NEW_LINE"],"references":["from math import sqrt NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT s = sqrt ( x ) NEW_LINE return ( s * s == x ) NEW_LINE DEDENT def isFibonacci ( N ) : NEW_LINE INDENT return isPerfectSquare ( 5 * N * N + 4 ) or   \\ NEW_LINE INDENT isPerfectSquare ( 5 * N * N - 4 ) NEW_LINE DEDENT DEDENT def nextNonFibonacci ( N ) : NEW_LINE INDENT if ( N <= 3 ) : NEW_LINE INDENT return 4 NEW_LINE DEDENT if ( isFibonacci ( N + 1 ) ) : NEW_LINE INDENT return N + 2 NEW_LINE DEDENT else : NEW_LINE INDENT return N NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE print ( nextNonFibonacci ( N ) ) NEW_LINE N = 4 NEW_LINE print ( nextNonFibonacci ( N ) ) NEW_LINE N = 7 NEW_LINE print ( nextNonFibonacci ( N ) ) NEW_LINE DEDENT"],"bleu":0.7284235119429474,"rouge_l":0.8288202085924792}
{"id":1597,"predictions":["def bit_check ( n ) : NEW_LINE INDENT if ( n & ( n - 1 ) ) == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT n = 14 NEW_LINE if ( bit_check ( n ) ) : NEW_LINE INDENT print ( \"1\" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \"0\" ) NEW_LINE DEDENT"],"references":["def bit_check ( n ) : NEW_LINE INDENT if ( ( n & ( n - 1 ) ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 14 NEW_LINE if ( bit_check ( n ) ) : NEW_LINE INDENT print ( '1' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( '0' ) NEW_LINE DEDENT DEDENT"],"bleu":0.6530555362349421,"rouge_l":0.8375610891319525}
{"id":1598,"predictions":["def center_ hex_ hexadecagonal_num ( n ) : NEW_LINE INDENT return ( 8 * n * n - 8 * n + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 2 NEW_LINE print ( n , \" th ▁ centered ▁ hexadecagonal ▁ \" + \" number : ▁ \" , center_exadecagonal_num ( n ) ) NEW_LINE n = 11 NEW_LINE print ( n , \" th ▁ centered ▁ hexadecagonal ▁ number : ▁ \" , center_ hexadecagonal_num ( n ) ) NEW_LINE DEDENT"],"references":["def center_hexadecagonal_num ( n ) : NEW_LINE INDENT return 8 * n * n - 8 * n + 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 2 NEW_LINE print ( n , \" nd ▁ centered ▁ hexadecagonal ▁ \" + \" number ▁ : ▁ \" , center_hexadecagonal_num ( n ) ) NEW_LINE n = 12 NEW_LINE print ( n , \" th ▁ centered ▁ hexadecagonal ▁ \" + \" number ▁ : ▁ \" , center_hexadecagonal_num ( n ) ) NEW_LINE DEDENT"],"bleu":0.7455646421525863,"rouge_l":0.8958333333333334}
{"id":1599,"predictions":["def fib ( n ) : NEW_LINE INDENT a = 0 NEW_LINE b = 1 NEW_LINE if ( n >= 0 ) : NEW_LINE INDENT print ( a , end = \" ▁ \" ) NEW_LINE DEDENT if ( n >= 1 ) : NEW_LINE INDENT print ( b , end = \" ▁ \" ) NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT print ( a + b , end = \" ▁ \" ) NEW_LINE b = a + b NEW_LINE a = b - a NEW_LINE DEDENT DEDENT fib ( 9 ) NEW_LINE"],"references":["def fib ( n ) : NEW_LINE INDENT a = 0 NEW_LINE b = 1 NEW_LINE if ( n >= 0 ) : NEW_LINE INDENT print ( a , end = ' ▁ ' ) NEW_LINE DEDENT if ( n >= 1 ) : NEW_LINE INDENT print ( b , end = ' ▁ ' ) NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT print ( a + b , end = ' ▁ ' ) NEW_LINE b = a + b NEW_LINE a = b - a NEW_LINE DEDENT DEDENT fib ( 9 ) NEW_LINE"],"bleu":0.8752482202425949,"rouge_l":0.9423076923076921}
{"id":1600,"predictions":["from math import sqrt NEW_LINE def prime ( n ) : NEW_LINE INDENT for i in range ( 2 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def thirdNumber ( a , b ) : NEW_LINE INDENT sum = 0 NEW_LINE temp = 0 NEW_LINE sum = a + b NEW_LINE temp = 1 NEW_LINE if ( sum == 0 ) : NEW_LINE INDENT temp = 2 NEW_LINE DEDENT while ( not ( sum ( sum + temp ) ) : NEW_LINE INDENT temp += 2 NEW_LINE DEDENT print ( temp ) NEW_LINE DEDENT DEDENT a = 3 NEW_LINE b = 5 NEW_LINE thirdNumber ( a , b ) NEW_LINE"],"references":["def prime ( n ) : NEW_LINE INDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if i * i > n + 1 : NEW_LINE INDENT break NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def thirdNumber ( a , b ) : NEW_LINE INDENT summ = 0 NEW_LINE temp = 0 NEW_LINE summ = a + b NEW_LINE temp = 1 NEW_LINE if ( summ & 1 ) : NEW_LINE INDENT temp = 2 NEW_LINE DEDENT while ( prime ( summ + temp ) == False ) : NEW_LINE INDENT temp += 2 NEW_LINE DEDENT print ( temp ) NEW_LINE DEDENT a = 3 NEW_LINE b = 5 NEW_LINE thirdNumber ( a , b ) NEW_LINE"],"bleu":0.7465785554581335,"rouge_l":0.8383126195028681}
{"id":1601,"predictions":["def isMinimum ( a , b , c ) : NEW_LINE INDENT return ( min ( a , b ) <= c and c <= max ( a , b ) ) NEW_LINE DEDENT def canJump ( x , y , i , j , k ) : NEW_LINE INDENT return ( x [ k ] == x [ k ] or x [ k ] == x [ j ] ) and isMinimum ( y [ i ] , y [ k ] , x [ k ] ) and isLeave ( x [ i ] , x [ k ] ) and isMinimum ( x [ i ] , x [ k ] , x [ k ] ) ) ) NEW_LINE DEDENT def countLineSegments ( x , y ) : NEW_LINE INDENT if ( ( x [ 0 ] == x [ 1 ] and x [ 1 ] == x [ 1 ] and y [ k ] == y [ 1 ] ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( ( x , y , 0 , 1 , 2 ) or ( y [ 0 ] == y [ 1 ] and y [ 1 ] == y [ 1 ] ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( ( x , y , 0 , 1 , 2 ) or ( y [ 0 ] == y [ 1 ] and not ( x , y , 0 , 2 , 1 ) ) ) ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT else : NEW_LINE INDENT return 3 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ \" : NEW_LINE INDENT x = [ - 1 for i in range ( 3 ) ] NEW_LINE y = - 1 NEW_LINE y = [ - 1 for i in range ( 3 ) ] NEW_LINE x [ 0 ] = - 1 NEW_LINE y [ 1 ] = - 1 NEW_LINE x [ 1 ] = 3 NEW_LINE y [ 2 ] = 3 NEW_LINE print ( countLineSegments ( x , y ) ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def isBetween ( a , b , c ) : NEW_LINE INDENT return min ( a , b ) <= c and c <= max ( a , b ) NEW_LINE DEDENT def canJoin ( x , y , i , j , k ) : NEW_LINE INDENT return ( x [ k ] == x [ i ] or x [ k ] == x [ j ] ) and isBetween ( y [ i ] , y [ j ] , y [ k ] ) or ( y [ k ] == y [ i ] or y [ k ] == y [ j ] ) and isBetween ( x [ i ] , x [ j ] , x [ k ] ) NEW_LINE DEDENT def countLineSegments ( x , y ) : NEW_LINE INDENT if ( ( x [ 0 ] == x [ 1 ] and x [ 1 ] == x [ 2 ] ) or ( y [ 0 ] == y [ 1 ] and y [ 1 ] == y [ 2 ] ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( canJoin ( x , y , 0 , 1 , 2 ) or canJoin ( x , y , 0 , 2 , 1 ) or canJoin ( x , y , 1 , 2 , 0 ) ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT else : NEW_LINE INDENT return 3 NEW_LINE DEDENT DEDENT x = [ - 1 , - 1 , 4 ] NEW_LINE y = [ - 1 , 3 , 3 ] NEW_LINE print ( countLineSegments ( x , y ) ) NEW_LINE"],"bleu":0.6203560060363978,"rouge_l":0.7577247554474406}
{"id":1602,"predictions":["def ReplaceElements ( arr , n ) : NEW_LINE INDENT min_ele = arr [ 0 ] NEW_LINE arr [ 0 ] = - 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( min_ele < arr [ i ] ) : NEW_LINE INDENT arr [ i ] = min_ele NEW_LINE DEDENT elif ( min_ele >= arr [ i ] ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE arr [ i ] = min_ele NEW_LINE min_ele = temp NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 4 , 5 , 2 , 1 , 7 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE ReplaceElements ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT"],"references":["def ReplaceElements ( arr , n ) : NEW_LINE INDENT min_ele = arr [ 0 ] NEW_LINE arr [ 0 ] = - 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( min_ele < arr [ i ] ) : NEW_LINE INDENT arr [ i ] = min_ele NEW_LINE DEDENT elif ( min_ele >= arr [ i ] ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE arr [ i ] = min_ele NEW_LINE min_ele = temp NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 4 , 5 , 2 , 1 , 7 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE ReplaceElements ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT"],"bleu":1.0,"rouge_l":1.0}
{"id":1603,"predictions":["def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT def gMin ( arr , i , j ) : NEW_LINE INDENT minVal = arr [ i + 1 ] NEW_LINE while ( i <= j ) : NEW_LINE INDENT minVal = max ( minVal , arr [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT return minVal NEW_LINE DEDENT def getMax ( arr , i , j ) : NEW_LINE INDENT maxVal = arr [ i + 1 ] NEW_LINE while ( i <= j ) : NEW_LINE INDENT maxVal = max ( maxVal , arr [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT return minVal NEW_LINE DEDENT def generateArr ( arr , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT print ( arr [ 0 ] ) NEW_LINE return NEW_LINE DEDENT pArr = [ 0 for i in range ( n ) ] NEW_LINE pArr [ 0 ] = gcd ( arr , 1 , n - 1 ) NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT pArr [ i ] = abs ( gMin ( arr , i + 1 , n - 1 ) - getMin ( arr , 0 , i - 1 ) ) NEW_LINE DEDENT pArr [ n - 1 ] = gArr [ n - 1 ] NEW_LINE printArray ( pArr , n ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 5 , 2 , 4 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE generateArr ( arr , n ) NEW_LINE DEDENT"],"references":["def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT def getMin ( arr , i , j ) : NEW_LINE INDENT minVal = arr [ i ] NEW_LINE i += 1 NEW_LINE while ( i <= j ) : NEW_LINE INDENT minVal = min ( minVal , arr [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT return minVal NEW_LINE DEDENT def getMax ( arr , i , j ) : NEW_LINE INDENT maxVal = arr [ i ] NEW_LINE i += 1 NEW_LINE while ( i <= j ) : NEW_LINE INDENT maxVal = max ( maxVal , arr [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT return maxVal NEW_LINE DEDENT def generateArr ( arr , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT print ( arr [ 0 ] , end = \" \" ) NEW_LINE return NEW_LINE DEDENT tmpArr = [ 0 for i in range ( n ) ] NEW_LINE tmpArr [ 0 ] = getMax ( arr , 1 , n - 1 ) NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT tmpArr [ i ] = abs ( getMax ( arr , i + 1 , n - 1 ) - getMin ( arr , 0 , i - 1 ) ) NEW_LINE DEDENT tmpArr [ n - 1 ] = getMin ( arr , 0 , n - 2 ) NEW_LINE printArray ( tmpArr , n ) NEW_LINE DEDENT arr = [ 1 , 5 , 2 , 4 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE generateArr ( arr , n ) NEW_LINE"],"bleu":0.8222179471798504,"rouge_l":0.9016629028946829}
{"id":1604,"predictions":["def totEdge ( n ) : NEW_LINE INDENT result = 0 ; NEW_LINE result = ( n * ( n - 1 ) ) \/ 2 ; NEW_LINE return result ; NEW_LINE DEDENT n = 6 ; NEW_LINE print ( totEdge ( n ) ) ; NEW_LINE"],"references":["def totEdge ( n ) : NEW_LINE INDENT result = ( n * ( n - 1 ) ) \/\/ 2 NEW_LINE return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 6 NEW_LINE print ( totEdge ( n ) ) NEW_LINE DEDENT"],"bleu":0.5512845674180236,"rouge_l":0.7407285854939285}
{"id":1605,"predictions":["def countNumbers ( L , R , K ) : NEW_LINE INDENT if ( K == 9 ) : NEW_LINE INDENT K = 0 NEW_LINE DEDENT totalnumbers = R - L + 1 NEW_LINE factor9 = totalnumbers % 9 NEW_LINE rem = totalnumbers % 9 NEW_LINE ans = factor9 NEW_LINE for i in range ( R , R - rem , - 1 ) : NEW_LINE INDENT rem1 = i % 9 NEW_LINE if ( rem1 == K ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT L = 10 NEW_LINE R = 22 NEW_LINE K = 3 NEW_LINE print ( countNumbers ( L , R , K ) ) NEW_LINE"],"references":["def countNumbers ( L , R , K ) : NEW_LINE INDENT if ( K == 9 ) : NEW_LINE INDENT K = 0 NEW_LINE DEDENT totalnumbers = R - L + 1 NEW_LINE factor9 = totalnumbers \/\/ 9 NEW_LINE rem = totalnumbers % 9 NEW_LINE ans = factor9 NEW_LINE for i in range ( R , R - rem , - 1 ) : NEW_LINE INDENT rem1 = i % 9 NEW_LINE if ( rem1 == K ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT L = 10 NEW_LINE R = 22 NEW_LINE K = 3 NEW_LINE print ( countNumbers ( L , R , K ) ) NEW_LINE"],"bleu":0.9782092189509323,"rouge_l":0.9913793103448276}
{"id":1606,"predictions":["def SieveofEratosthenes ( n , prime , primes , a ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT prime [ 1 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= n : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT j = 0 NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT j = 0 NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT a [ j ] = p NEW_LINE primes [ p * p ] = True NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT def countDivisors ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT prime = [ 0 ] * ( n + 1 ) NEW_LINE primesquare = [ 0 for i in range ( n ) ] NEW_LINE SieveOfEratosthenes ( n , prime , primes ) NEW_LINE ans = 1 NEW_LINE while ( n % a [ i ] == 0 ) : NEW_LINE INDENT if ( a [ i ] * a [ i ] * a [ i ] > n ) : NEW_LINE INDENT break NEW_LINE DEDENT cnt = 1 NEW_LINE while ( n % a [ i ] == 0 ) : NEW_LINE INDENT n = n \/\/ a [ i ] NEW_LINE cnt = cnt + 1 NEW_LINE DEDENT ans = ans * cnt NEW_LINE DEDENT if ( primes [ n ] ) : NEW_LINE INDENT ans = ans * 4 NEW_LINE DEDENT return ans NEW_LINE DEDENT"],"references":["def SieveOfEratosthenes ( n , prime , primesquare , a ) : NEW_LINE INDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT prime [ i ] = True NEW_LINE DEDENT for i in range ( ( n * n + 1 ) + 1 ) : NEW_LINE INDENT primesquare [ i ] = False NEW_LINE DEDENT prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT i = p * 2 NEW_LINE while ( i <= n ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE i += p NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT j = 0 NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT a [ j ] = p NEW_LINE primesquare [ p * p ] = True NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT def countDivisors ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT prime = [ False ] * ( n + 2 ) NEW_LINE primesquare = [ False ] * ( n * n + 2 ) NEW_LINE a = [ 0 ] * n NEW_LINE SieveOfEratosthenes ( n , prime , primesquare , a ) NEW_LINE ans = 1 NEW_LINE i = 0 NEW_LINE while ( 1 ) : NEW_LINE INDENT if ( a [ i ] * a [ i ] * a [ i ] > n ) : NEW_LINE INDENT break NEW_LINE DEDENT cnt = 1 NEW_LINE while ( n % a [ i ] == 0 ) : NEW_LINE INDENT n = n \/ a [ i ] NEW_LINE cnt = cnt + 1 NEW_LINE DEDENT ans = ans * cnt NEW_LINE i += 1 NEW_LINE DEDENT n = int ( n ) NEW_LINE if ( prime [ n ] == True ) : NEW_LINE INDENT ans = ans * 2 NEW_LINE DEDENT elif ( primesquare [ n ] == True ) : NEW_LINE INDENT ans = ans * 3 NEW_LINE DEDENT elif ( n != 1 ) : NEW_LINE INDENT ans = ans * 4 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( \" Total ▁ distinct ▁ divisors ▁ of ▁ 100 ▁ are ▁ : \" , countDivisors ( 100 ) ) NEW_LINE DEDENT"],"bleu":0.5825485533695497,"rouge_l":0.673041559396837}
{"id":1607,"predictions":["def subArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT for k in range ( i , j + 1 ) : NEW_LINE INDENT print ( arr [ k ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE subArray ( arr , n ) NEW_LINE subArray ( arr , n ) NEW_LINE subArray ( arr , n ) NEW_LINE"],"references":["def subArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT for k in range ( i , j + 1 ) : NEW_LINE INDENT print ( arr [ k ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( \" \\n \" , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" All ▁ Non - empty ▁ Subarrays \" ) NEW_LINE subArray ( arr , n ) ; NEW_LINE"],"bleu":0.751916776034988,"rouge_l":0.8284170560747665}
{"id":1608,"predictions":["def findCullen ( n ) : NEW_LINE INDENT return ( 1 << n ) * n + 1 NEW_LINE DEDENT n = 2 NEW_LINE print ( findCullen ( n ) ) NEW_LINE"],"references":["def findCullen ( n ) : NEW_LINE INDENT return ( 1 << n ) * n + 1 NEW_LINE DEDENT n = 2 NEW_LINE print ( findCullen ( n ) ) NEW_LINE"],"bleu":1.0,"rouge_l":1.0}
{"id":1609,"predictions":["def printProbability ( L , n ) : NEW_LINE INDENT p = ( 1 << ( n - 1 ) ) NEW_LINE return 1.0 - ( n ) \/ ( p ) NEW_LINE DEDENT n = 3 NEW_LINE L = 5 NEW_LINE print ( printProbability ( L , n ) ) NEW_LINE"],"references":["def printProbability ( L , n ) : NEW_LINE INDENT p = ( 1 << ( n - 1 ) ) NEW_LINE return 1.0 - ( float ( n ) \/ float ( p ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE L = 5 NEW_LINE print ( printProbability ( L , n ) ) NEW_LINE DEDENT"],"bleu":0.6420842855479253,"rouge_l":0.8303664921465969}
{"id":1610,"predictions":["def firstLetterWord ( str ) : NEW_LINE INDENT result = \" \" NEW_LINE v = True NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == ' ▁ ' ) : NEW_LINE INDENT v = True NEW_LINE DEDENT elif ( str [ i ] != ' ▁ ' and v == True ) : NEW_LINE INDENT result += ( str [ i ] ) NEW_LINE v = False NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeks ▁ for ▁ geeks \" NEW_LINE print ( firstLetterWord ( str ) ) NEW_LINE DEDENT"],"references":["def firstLetterWord ( str ) : NEW_LINE INDENT result = \" \" NEW_LINE v = True NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == ' ▁ ' ) : NEW_LINE INDENT v = True NEW_LINE DEDENT elif ( str [ i ] != ' ▁ ' and v == True ) : NEW_LINE INDENT result += ( str [ i ] ) NEW_LINE v = False NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeks ▁ for ▁ geeks \" NEW_LINE print ( firstLetterWord ( str ) ) NEW_LINE DEDENT"],"bleu":1.0,"rouge_l":1.0}
{"id":1611,"predictions":["def find previous previous ( number , n ) : NEW_LINE INDENT i = n - 1 NEW_LINE j = 0 NEW_LINE while i > 0 : NEW_LINE INDENT if number [ i ] < number [ i - 1 ] : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if i == 0 : NEW_LINE INDENT print ( \" Previous ▁ number ▁ is ▁ not ▁ possible \" ) NEW_LINE return NEW_LINE DEDENT x = num [ i - 1 ] NEW_LINE g = i NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if number [ j ] < x and numbers [ j ] >= num [ j ] : NEW_LINE INDENT g [ j ] = j NEW_LINE DEDENT DEDENT DEDENT number = str ( i ) NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if num [ j ] < x and num [ j ] > num [ j ] : NEW_LINE INDENT g [ j ] = j NEW_LINE DEDENT DEDENT number = 100 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if number [ j ] < x and num [ j ] > \" same \" : NEW_LINE INDENT break NEW_LINE DEDENT num1 = num1 [ j ] NEW_LINE str1 [ j ] NEW_LINE str1 = str ( str1 [ j ] ) NEW_LINE str1 [ j ] = str1 [ j ] NEW_LINE str1 [ j ] = str1 [ j ] NEW_LINE str1 [ j ] = str1 [ j ] NEW_LINE str1 [ j ] NEW_LINE str1 [ j ] = str1 [ j ] NEW_LINE str2 [ j ] = str1 [ j ] NEW_LINE str1 [ j ] = str1 [ j ] NEW_LINE str1 = str1 [ j ] NEW_LINE str1 [ j ] NEW_LINE str1 [ j ] = str1 [ j ] NEW_LINE str1 [ j ] = str2 [ j ] NEW_LINE str1 [ j ] = str1 [ j ] NEW_LINE str1 [ j ] = str1 [ j ] NEW_LINE str1 [ j"],"references":["def findPrevious ( number , n ) : NEW_LINE INDENT number = list ( number ) NEW_LINE i , j = - 1 , - 1 NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT if number [ i ] < number [ i - 1 ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if i == 0 : NEW_LINE INDENT print ( \" Previous ▁ number ▁ is ▁ not ▁ possible \" ) NEW_LINE return NEW_LINE DEDENT x , greatest = number [ i - 1 ] , i NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if ( number [ j ] < x and number [ j ] > number [ greatest ] ) : NEW_LINE INDENT greatest = j NEW_LINE DEDENT DEDENT ( number [ greatest ] , number [ i - 1 ] ) = ( number [ i - 1 ] , number [ greatest ] ) NEW_LINE l = number [ i : ] NEW_LINE del number [ i : ] NEW_LINE l . sort ( reverse = True ) NEW_LINE number += l NEW_LINE number = ' ' . join ( number ) NEW_LINE print ( \" Greatest ▁ smaller ▁ number ▁ with \" , \" same ▁ set ▁ of ▁ digits ▁ is \" , number ) NEW_LINE return NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT digits = \"262345\" NEW_LINE n = len ( digits ) NEW_LINE findPrevious ( digits , n ) NEW_LINE DEDENT"],"bleu":0.2976324456159292,"rouge_l":0.45707557268250915}
{"id":1612,"predictions":["def countDecreasing ( A , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE len = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if A [ i + 1 ] < A [ i ] : NEW_LINE INDENT len += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += ( ( ( len - 1 ) * len ) \/ 2 ) NEW_LINE len = 1 NEW_LINE DEDENT DEDENT if ( len > 1 ) : NEW_LINE INDENT cnt += ( ( ( len - 1 ) * len ) \/ 2 ) NEW_LINE DEDENT return cnt NEW_LINE DEDENT A = [ 100 , 3 , 1 , 13 ] NEW_LINE n = len ( A ) NEW_LINE print ( countDecreasing ( A , n ) ) NEW_LINE"],"references":["def countDecreasing ( A , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE len = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( A [ i + 1 ] < A [ i ] ) : NEW_LINE INDENT len += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += ( ( ( len - 1 ) * len ) \/\/ 2 ) ; NEW_LINE len = 1 NEW_LINE DEDENT DEDENT if ( len > 1 ) : NEW_LINE INDENT cnt += ( ( ( len - 1 ) * len ) \/\/ 2 ) NEW_LINE DEDENT return cnt NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 100 , 3 , 1 , 13 ] NEW_LINE n = len ( A ) NEW_LINE print ( countDecreasing ( A , n ) ) NEW_LINE DEDENT"],"bleu":0.8097527663653894,"rouge_l":0.9170340228325986}
{"id":1613,"predictions":["def count ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( n * count ( n - 1 ) ) + ( ( n - 1 ) * count ( n - 2 ) ) ) NEW_LINE DEDENT DEDENT A = [ 1 , 2 , 3 , 9 ] NEW_LINE n = len ( A ) NEW_LINE print ( count ( n - 1 ) ) NEW_LINE"],"references":["def count ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( n * count ( n - 1 ) ) + ( ( n - 1 ) * count ( n - 2 ) ) NEW_LINE DEDENT DEDENT A = [ 1 , 2 , 3 , 9 ] NEW_LINE print ( count ( len ( A ) - 1 ) ) NEW_LINE"],"bleu":0.797699044378723,"rouge_l":0.9161451814768461}
{"id":1614,"predictions":["def splitAndAdd ( A , length , rotation ) : NEW_LINE INDENT a = [ 0 for i in range ( length * 2 ) ] NEW_LINE for i in range ( 0 , rotation + length ) : NEW_LINE INDENT A [ i - rotation ] = a [ i ] NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 12 , 10 , 5 , 6 , 52 , 36 ] NEW_LINE n = len ( arr ) NEW_LINE position = 2 NEW_LINE splitAndAdd ( arr , n , position ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT"],"references":["def SplitAndAdd ( A , length , rotation ) : NEW_LINE INDENT tmp = [ 0 for i in range ( length * 2 ) ] NEW_LINE for i in range ( length ) : NEW_LINE INDENT tmp [ i ] = A [ i ] NEW_LINE tmp [ i + length ] = A [ i ] NEW_LINE DEDENT for i in range ( rotation , rotation + length , 1 ) : NEW_LINE INDENT A [ i - rotation ] = tmp [ i ] ; NEW_LINE DEDENT DEDENT arr = [ 12 , 10 , 5 , 6 , 52 , 36 ] NEW_LINE n = len ( arr ) NEW_LINE position = 2 NEW_LINE SplitAndAdd ( arr , n , position ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE"],"bleu":0.6276403512397031,"rouge_l":0.7563672922252009}
{"id":1615,"predictions":["def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT defcommDiv ( a , b ) : NEW_LINE INDENT n = gcd ( a , b ) NEW_LINE a = a \/\/ n NEW_LINE b = b \/\/ n NEW_LINE print ( \" A ▁ = \" , a , \" , \" , a ) NEW_LINE DEDENT a = 10 NEW_LINE b = 10 NEW_LINEcommDiv ( a , b ) NEW_LINE"],"references":["def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def commDiv ( a , b ) : NEW_LINE INDENT n = gcd ( a , b ) NEW_LINE a = a \/\/ n NEW_LINE b = b \/\/ n NEW_LINE print ( \" A ▁ = \" , a , \" , ▁ B ▁ = \" , b ) NEW_LINE DEDENT a , b = 10 , 15 NEW_LINE commDiv ( a , b ) NEW_LINE"],"bleu":0.8110976808851782,"rouge_l":0.9041501976284585}
{"id":1616,"predictions":["def adjSet ( n ) : NEW_LINE INDENT x = ( n & ( n >> 1 ) ) NEW_LINE if ( x == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE if ( adjSet ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def adjacentSet ( n ) : NEW_LINE INDENT return ( n & ( n >> 1 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE if ( adjacentSet ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.6149538017847423,"rouge_l":0.8180076628352491}
{"id":1617,"predictions":["def MinimumMoves ( a , n , x ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( a [ i ] <= a [ i - 1 ] ) : NEW_LINE INDENT p = ( a [ i - 1 ] - a [ i ] ) \/ x + 1 NEW_LINE ans += p NEW_LINE a [ i ] += p NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 3 , 3 , 2 ] NEW_LINE x = 2 NEW_LINE n = len ( arr ) NEW_LINE print ( MinimumMoves ( arr , n , x ) ) NEW_LINE DEDENT"],"references":["def MinimumMoves ( a , n , x ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if a [ i ] <= a [ i - 1 ] : NEW_LINE INDENT p = ( a [ i - 1 ] - a [ i ] ) \/\/ x + 1 NEW_LINE ans += p NEW_LINE a [ i ] += p * x NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 3 , 3 , 2 ] NEW_LINE x = 2 NEW_LINE n = len ( arr ) NEW_LINE print ( MinimumMoves ( arr , n , x ) ) NEW_LINE DEDENT"],"bleu":0.9300819789761849,"rouge_l":0.9770992366412214}
{"id":1618,"predictions":["def avg_of_even_num ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += 2 * i NEW_LINE DEDENT return ( int ( sum \/ n ) ) NEW_LINE DEDENT n = 9 NEW_LINE print ( avg_of_even_num ( n ) ) NEW_LINE"],"references":["def avg_of_even_num ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + 2 * i NEW_LINE DEDENT return sum \/ n NEW_LINE DEDENT n = 9 NEW_LINE print ( avg_of_even_num ( n ) ) NEW_LINE"],"bleu":0.8069477986216899,"rouge_l":0.9220072551390568}
{"id":1619,"predictions":["def findX ( A , B ) : NEW_LINE INDENT j = 0 NEW_LINE x = 0 NEW_LINE while ( A != 0 or B != 0 ) : NEW_LINE INDENT if ( ( A % 2 == 1 ) and ( B % 2 == 1 ) ) : NEW_LINE INDENT x += ( 1 << j ) NEW_LINE DEDENT A >>= 1 NEW_LINE B >>= 1 NEW_LINE j += 1 NEW_LINE DEDENT return x NEW_LINE DEDENT A = 2 NEW_LINE B = 3 NEW_LINE X = findX ( A , B ) NEW_LINE print ( \" X ▁ = \" , X , \" , ▁ Sum ▁ = \" , ( A ^ X ) + ( B ^ X ) ) NEW_LINE"],"references":["def findX ( A , B ) : NEW_LINE INDENT j = 0 NEW_LINE x = 0 NEW_LINE while ( A or B ) : NEW_LINE INDENT if ( ( A & 1 ) and ( B & 1 ) ) : NEW_LINE INDENT x += ( 1 << j ) NEW_LINE DEDENT A >>= 1 NEW_LINE B >>= 1 NEW_LINE j += 1 NEW_LINE DEDENT return x NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = 2 NEW_LINE B = 3 NEW_LINE X = findX ( A , B ) NEW_LINE print ( \" X ▁ = \" , X , \" , ▁ Sum ▁ = \" , ( A ^ X ) + ( B ^ X ) ) NEW_LINE DEDENT"],"bleu":0.8227945201585961,"rouge_l":0.8954695013920525}
{"id":1620,"predictions":["MAX = 1000001 NEW_LINE factor = [ 0 ] * MAX NEW_LINE def cal_factor ( ) : NEW_LINE INDENT factor [ 1 ] = 1 NEW_LINE for i in range ( 2 , MAX , 1 ) : NEW_LINE INDENT factor [ i ] = i NEW_LINE DEDENT for i in range ( 4 , MAX , 2 ) : NEW_LINE INDENT factor [ i ] = 2 NEW_LINE DEDENT for i in range ( 3 , MAX , 2 ) : NEW_LINE INDENT if ( factor [ i ] == i ) : NEW_LINE INDENT for j in range ( i * i , MAX , i ) : NEW_LINE INDENT if ( factor [ j ] == j ) : NEW_LINE INDENT factor [ j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def no_of_representations ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp = a [ i ] NEW_LINE flag = 0 NEW_LINE while ( factor [ temp ] != 1 ) : NEW_LINE INDENT flag = - 1 NEW_LINE count += 1 NEW_LINE temp = temp \/\/ factor [ temp ] NEW_LINE DEDENT count += flag NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT cal_factor ( ) NEW_LINE a = [ 4 , 4 , 4 ] NEW_LINE n = len ( a ) NEW_LINE print ( no_of_representations ( a , n ) ) NEW_LINE DEDENT"],"references":["MAX = 1000001 NEW_LINE factor = [ 0 ] * MAX NEW_LINE def cal_factor ( ) : NEW_LINE INDENT factor [ 1 ] = 1 NEW_LINE for i in range ( 2 , MAX ) : NEW_LINE INDENT factor [ i ] = i NEW_LINE DEDENT for i in range ( 4 , MAX , 2 ) : NEW_LINE INDENT factor [ i ] = 2 NEW_LINE DEDENT i = 3 NEW_LINE while i * i < MAX : NEW_LINE INDENT if ( factor [ i ] == i ) : NEW_LINE INDENT for j in range ( i * i , MAX , i ) : NEW_LINE INDENT if ( factor [ j ] == j ) : NEW_LINE INDENT factor [ j ] = i NEW_LINE DEDENT DEDENT DEDENT i += 1 NEW_LINE DEDENT DEDENT def no_of_representations ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp = a [ i ] NEW_LINE flag = 0 NEW_LINE while ( factor [ temp ] != 1 ) : NEW_LINE INDENT flag = - 1 NEW_LINE count += 1 NEW_LINE temp = temp \/\/ factor [ temp ] NEW_LINE DEDENT count += flag NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT cal_factor ( ) NEW_LINE a = [ 4 , 4 , 4 ] NEW_LINE n = len ( a ) NEW_LINE print ( no_of_representations ( a , n ) ) NEW_LINE DEDENT"],"bleu":0.9314992688680618,"rouge_l":0.9587273191924354}
{"id":1621,"predictions":["def maxSumPair ( arr1 , n1 , arr2 , n2 ) : NEW_LINE INDENT max1 = - 10 ** 9 NEW_LINE max2 = - 10 ** 9 NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT if ( arr1 [ i ] > max1 ) : NEW_LINE INDENT max1 = arr1 [ i ] NEW_LINE DEDENT DEDENT for i in range ( n2 ) : NEW_LINE INDENT if ( arr2 [ i ] > max2 ) : NEW_LINE INDENT max2 = arr2 [ i ] NEW_LINE DEDENT DEDENT return max1 + max2 NEW_LINE DEDENT arr1 = [ 10 , 2 , 3 ] NEW_LINE arr2 = [ 3 , 4 , 7 ] NEW_LINE n1 = len ( arr2 ) NEW_LINE n1 = len ( arr2 ) NEW_LINE n2 = len ( arr2 ) NEW_LINE print ( maxSumPair ( arr1 , n1 , arr2 , n2 ) ) NEW_LINE"],"references":["import sys NEW_LINE def maxSumPair ( arr1 , n1 , arr2 , n2 ) : NEW_LINE INDENT max1 = - sys . maxsize - 1 NEW_LINE max2 = - sys . maxsize - 1 NEW_LINE for i in range ( 0 , n1 ) : NEW_LINE INDENT if ( arr1 [ i ] > max1 ) : NEW_LINE INDENT max1 = arr1 [ i ] NEW_LINE DEDENT DEDENT for i in range ( 0 , n2 ) : NEW_LINE INDENT if ( arr2 [ i ] > max2 ) : NEW_LINE INDENT max2 = arr2 [ i ] NEW_LINE DEDENT DEDENT return max1 + max2 NEW_LINE DEDENT arr1 = [ 10 , 2 , 3 ] NEW_LINE arr2 = [ 3 , 4 , 7 ] NEW_LINE n1 = len ( arr1 ) NEW_LINE n2 = len ( arr2 ) NEW_LINE print ( maxSumPair ( arr1 , n1 , arr2 , n2 ) ) NEW_LINE"],"bleu":0.835133923732645,"rouge_l":0.8933190807055051}
{"id":1622,"predictions":["def remainder ( str ) : NEW_LINE INDENT l = len ( str ) NEW_LINE rem = 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT num = rem * 10 + ( ord ( str [ i ] ) - ord ( '0' ) ) ) NEW_LINE rem = num % 11 NEW_LINE DEDENT return rem NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \"3434645652506643245786778\" NEW_LINE print ( remainder ( str ) ) NEW_LINE DEDENT"],"references":["def remainder ( st ) : NEW_LINE INDENT ln = len ( st ) NEW_LINE rem = 0 NEW_LINE for i in range ( 0 , ln ) : NEW_LINE INDENT num = rem * 10 + ( int ) ( st [ i ] ) NEW_LINE rem = num % 11 NEW_LINE DEDENT return rem NEW_LINE DEDENT st = \"3435346456547566345436457867978\" NEW_LINE print ( remainder ( st ) ) NEW_LINE"],"bleu":0.4994242869567955,"rouge_l":0.7495762711864408}
{"id":1623,"predictions":["def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT def rromList ( m , n ) : NEW_LINE INDENT arr = [ 0 for i in range ( m ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ ( i * m ) ] += 1 NEW_LINE DEDENT printArr ( arr , m ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT m = 4 NEW_LINE n = 8 NEW_LINE findList ( m , n ) NEW_LINE DEDENT"],"references":["from random import randint NEW_LINE def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT def randomList ( m , n ) : NEW_LINE INDENT arr = [ 0 ] * m ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ randint ( 0 , n ) % m ] += 1 ; NEW_LINE DEDENT printArr ( arr , m ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT m = 4 ; n = 8 ; NEW_LINE randomList ( m , n ) ; NEW_LINE DEDENT"],"bleu":0.6976068336644304,"rouge_l":0.8515022600372242}
{"id":1624,"predictions":["N = 100005 NEW_LINE def SieveofEratosthenes ( prime , p_size ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , p_size + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( p * 2 , p_size + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def longestPrimeSubsequence ( arr , n ) : NEW_LINE INDENT prime = [ True for i in range ( N + 1 ) ] NEW_LINE SieveOfEratosthenes ( prime , N ) NEW_LINE answer = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] ] ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT arr = [ 3 , 4 , 11 , 2 , 9 , 21 ] NEW_LINE n = len ( arr ) NEW_LINE print ( longestPrimeSubsequence ( arr , n ) ) NEW_LINE"],"references":["N = 100005 NEW_LINE def SieveOfEratosthenes ( prime , p_size ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= p_size : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( p * 2 , p_size + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT def longestPrimeSubsequence ( arr , n ) : NEW_LINE INDENT prime = [ True ] * ( N + 1 ) NEW_LINE SieveOfEratosthenes ( prime , N ) NEW_LINE answer = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 4 , 11 , 2 , 9 , 21 ] NEW_LINE n = len ( arr ) NEW_LINE print ( longestPrimeSubsequence ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.798206222606393,"rouge_l":0.881713992473486}
{"id":1625,"predictions":["def catalan ( n ) : NEW_LINE INDENT res = 0 NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT res += catalan ( i ) * catalan ( n - i - 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT print ( catalan ( i ) ) NEW_LINE"],"references":["def catalan ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res += catalan ( i ) * catalan ( n - i - 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT print catalan ( i ) , NEW_LINE DEDENT"],"bleu":0.7059646887913608,"rouge_l":0.8003339694656486}
{"id":1626,"predictions":["def smallestIndex ( a , n ) : NEW_LINE INDENT right1 = 0 NEW_LINE right0 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 1 ) : NEW_LINE INDENT right1 = i NEW_LINE DEDENT else : NEW_LINE INDENT right0 = i NEW_LINE DEDENT DEDENT return min ( right1 , right0 ) NEW_LINE DEDENT a = [ 1 , 1 , 1 , 1 , 0 , 1 , 0 , 1 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( smallestIndex ( a , n ) ) NEW_LINE"],"references":["def smallestIndex ( a , n ) : NEW_LINE INDENT right1 = 0 NEW_LINE right0 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 1 ) : NEW_LINE INDENT right1 = i NEW_LINE DEDENT else : NEW_LINE INDENT right0 = i NEW_LINE DEDENT DEDENT return min ( right1 , right0 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( smallestIndex ( a , n ) ) NEW_LINE DEDENT"],"bleu":0.8449972353696675,"rouge_l":0.9167526152939443}
{"id":1627,"predictions":["def polygonArea ( X , Y , n ) : NEW_LINE INDENT area = 0.0 NEW_LINE j = n - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT area += ( X [ j ] + X [ i ] + Y [ i ] ) * ( Y [ j ] - Y [ i ] ) NEW_LINE j = i NEW_LINE DEDENT return abs ( area \/ 2.0 ) NEW_LINE DEDENT X = [ 0 , 2 , 4 ] NEW_LINE Y = [ 1 , 3 , 7 ] NEW_LINE n = len ( X ) NEW_LINE print ( polygonArea ( X , Y , n ) ) NEW_LINE"],"references":["def polygonArea ( X , Y , n ) : NEW_LINE INDENT area = 0.0 NEW_LINE j = n - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT area = area + ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) NEW_LINE j = i NEW_LINE DEDENT return abs ( area \/\/ 2.0 ) NEW_LINE DEDENT X = [ 0 , 2 , 4 ] NEW_LINE Y = [ 1 , 3 , 7 ] NEW_LINE n = len ( X ) NEW_LINE print ( polygonArea ( X , Y , n ) ) NEW_LINE"],"bleu":0.9016793780462895,"rouge_l":0.9444602272727273}
{"id":1628,"predictions":["PI = 3.14 NEW_LINE def areaOfInscribedCircle ( a ) : NEW_LINE INDENT return ( PI \/ 4 ) * a * a NEW_LINE DEDENT a = 8 NEW_LINE print ( \" Area ▁ of ▁ an ▁ inscribed : \" , area ) NEW_LINE"],"references":["PI = 3.14 NEW_LINE def areaOfInscribedCircle ( a ) : NEW_LINE INDENT return ( PI \/ 4 ) * a * a NEW_LINE DEDENT a = 8 NEW_LINE print ( \" Area ▁ of ▁ an ▁ inscribed ▁ circle : \" , round ( areaOfInscribedCircle ( a ) , 2 ) ) NEW_LINE"],"bleu":0.7261588459699635,"rouge_l":0.861695137976347}
{"id":1629,"predictions":["def divisorSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT j = 1 NEW_LINE while ( j * j <= i ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT sum += j NEW_LINE DEDENT else : NEW_LINE INDENT sum += j + i \/\/ j NEW_LINE DEDENT j += 1 NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 NEW_LINE print ( divisorSum ( n ) ) NEW_LINE n = 5 NEW_LINE print ( divisorSum ( n ) ) NEW_LINE DEDENT"],"references":["def divisorSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT j = 1 NEW_LINE while j * j <= i : NEW_LINE INDENT if i % j == 0 : NEW_LINE INDENT if i \/ j == j : NEW_LINE INDENT sum += j NEW_LINE DEDENT else : NEW_LINE INDENT sum += j + i \/ j NEW_LINE DEDENT DEDENT j = j + 1 NEW_LINE DEDENT DEDENT return int ( sum ) NEW_LINE DEDENT n = 4 NEW_LINE print ( divisorSum ( n ) ) NEW_LINE n = 5 NEW_LINE print ( divisorSum ( n ) ) NEW_LINE"],"bleu":0.7362476633811743,"rouge_l":0.8431593794076162}
{"id":1630,"predictions":["MAX = 32 NEW_LINE def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT n &= ( n - 1 ) NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def pairs ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE f = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT f [ countSetBits ( arr [ i ] ) ] += 1 NEW_LINE DEDENT for i in range ( MAX + 1 ) : NEW_LINE INDENT for j in range ( i , MAX + 1 ) : NEW_LINE INDENT if ( i + j == k ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT count += ( f [ i ] * ( f [ i ] - 1 ) ) \/\/ 2 NEW_LINE DEDENT else : NEW_LINE INDENT count += ( f [ i ] * f [ j ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE k = 4 NEW_LINE print ( pairs ( arr , n , k ) ) NEW_LINE"],"references":["MAX = 32 NEW_LINE def countSetBits ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( n ) : NEW_LINE INDENT n &= ( n - 1 ) ; NEW_LINE count += 1 ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT def pairs ( arr , n , k ) : NEW_LINE INDENT count = 0 ; NEW_LINE f = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT f [ countSetBits ( arr [ i ] ) ] += 1 ; NEW_LINE DEDENT for i in range ( MAX + 1 ) : NEW_LINE INDENT for j in range ( 1 , MAX + 1 ) : NEW_LINE INDENT if ( i + j == k ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT count += ( ( f [ i ] * ( f [ i ] - 1 ) ) \/ 2 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT count += ( f [ i ] * f [ j ] ) ; NEW_LINE DEDENT DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE k = 4 NEW_LINE print ( pairs ( arr , n , k ) ) NEW_LINE"],"bleu":0.871966493139126,"rouge_l":0.9633170455350188}
{"id":1631,"predictions":["def oneDigit ( num ) : NEW_LINE INDENT if ( ( num == 0 ) and ( num < 10 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def isPalindromil ( num , dupNum ) : NEW_LINE INDENT if ( num == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def isPalind ( num , dupNum ) : NEW_LINE INDENT if ( num == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT dupNum = isPalUtil ( num \/ 10 , dupNum ) NEW_LINE DEDENT if ( num % 10 == dupNum % 10 ) : NEW_LINE INDENT return dupNum NEW_LINE DEDENT else : NEW_LINE INDENT raise ValueError ( ) NEW_LINE DEDENT DEDENT DEDENT def isPal ( num ) : NEW_LINE INDENT if ( num < 0 ) : NEW_LINE INDENT num = ( - num ) NEW_LINE DEDENT dupNum = ( num ) NEW_LINE return isPal ( num , dupNum ) NEW_LINE DEDENT if ( num < 0 ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT n = 1242 NEW_LINE if ( isPal ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT n = 8 NEW_LINE if ( isPal ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def oneDigit ( num ) : NEW_LINE INDENT return ( ( num >= 0 ) and ( num < 10 ) ) ; NEW_LINE DEDENT def isPalUtil ( num , dupNum ) : NEW_LINE INDENT if ( oneDigit ( num ) ) : NEW_LINE INDENT return ( num == ( dupNum ) % 10 ) ; NEW_LINE DEDENT if ( isPalUtil ( int ( num \/ 10 ) , dupNum ) == False ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT dupNum = int ( dupNum \/ 10 ) ; NEW_LINE return ( num % 10 == ( dupNum ) % 10 ) ; NEW_LINE DEDENT def isPal ( num ) : NEW_LINE INDENT if ( num < 0 ) : NEW_LINE INDENT num = ( - num ) ; NEW_LINE DEDENT dupNum = ( num ) ; NEW_LINE return isPalUtil ( num , dupNum ) ; NEW_LINE DEDENT n = 12321 ; NEW_LINE if ( isPal ( n ) == 0 ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT n = 12 ; NEW_LINE if ( isPal ( n ) == 0 ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT n = 88 ; NEW_LINE if ( isPal ( n ) == 1 ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT n = 8999 ; NEW_LINE if ( isPal ( n ) == 0 ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT"],"bleu":0.5689421196618735,"rouge_l":0.7143961993149928}
{"id":1632,"predictions":["def isSumDivides ( N ) : NEW_LINE INDENT temp = N NEW_LINE sum = 0 NEW_LINE while ( temp ) : NEW_LINE INDENT sum += temp % 10 NEW_LINE temp \/\/= 10 NEW_LINE DEDENT if ( N % sum == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT N = 12 NEW_LINE if ( isSumDivides ( N ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"],"references":["def isSumDivides ( N ) : NEW_LINE INDENT temp = N NEW_LINE sum = 0 NEW_LINE while ( temp ) : NEW_LINE INDENT sum += temp % 10 NEW_LINE temp = int ( temp \/ 10 ) NEW_LINE DEDENT if ( N % sum == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 12 NEW_LINE if ( isSumDivides ( N ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.7477943053208231,"rouge_l":0.871982210927573}
{"id":1633,"predictions":["def nextZero ( i , occurrences ) : NEW_LINE INDENT while ( i < len ) : NEW_LINE INDENT if ( occurrences [ i ] == 0 ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT return - 1 ; NEW_LINE DEDENT def getModifiedString ( string ) : NEW_LINE INDENT n = len ( string ) ; NEW_LINE if ( n > 26 ) : NEW_LINE INDENT return \" - 1\" ; NEW_LINE DEDENT ch = [ 0 ] * 26 ; NEW_LINE occurrences = [ 0 ] * 26 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT occurrences [ ord ( ch [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT index = nextZero ( 0 , occurrences ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( occurrences [ ord ( ch [ i ] ) - ord ( ' a ' ) ] > 1 ) : NEW_LINE INDENT occurrences [ ord ( ch [ i ] ) - ord ( ' a ' ) ] -= 1 ; NEW_LINE occurrences [ index ] = chr ( ord ( ' a ' ) + index ) ; NEW_LINE occurrences [ index ] = 1 ; NEW_LINE index = nextZero ( index + 1 , occurrences ) ; NEW_LINE DEDENT DEDENT return str ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" geeksforgeeks \" ; NEW_LINE print ( getModifiedString ( string ) ) ; NEW_LINE DEDENT"],"references":["def nextZero ( i , occurrences ) : NEW_LINE INDENT while i < 26 : NEW_LINE INDENT if occurrences [ i ] == 0 : NEW_LINE INDENT return i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT def getModifiedString ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE if n > 26 : NEW_LINE INDENT return \" - 1\" NEW_LINE DEDENT ch = str NEW_LINE ch = list ( ch ) NEW_LINE occurrences = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT occurrences [ ord ( ch [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT index = nextZero ( 0 , occurrences ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if occurrences [ ord ( ch [ i ] ) - ord ( ' a ' ) ] > 1 : NEW_LINE INDENT occurrences [ ord ( ch [ i ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE ch [ i ] = chr ( ord ( ' a ' ) + index ) NEW_LINE occurrences [ index ] = 1 NEW_LINE index = nextZero ( index + 1 , occurrences ) NEW_LINE DEDENT DEDENT ch = ' ' . join ( ch ) NEW_LINE print ( ch ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeksforgeeks \" NEW_LINE getModifiedString ( str ) NEW_LINE DEDENT"],"bleu":0.6942187798020847,"rouge_l":0.8714827007888689}
{"id":1634,"predictions":["from collections import defaultdict NEW_LINE def calculateCyique ( l , n ) : NEW_LINE INDENT cycle_operations = 0 NEW_LINE while ( l != 0 ) : NEW_LINE INDENT len \/\/= 3 NEW_LINE cycle_operations += 1 NEW_LINE DEDENT return cycle_operations NEW_LINE DEDENT def minimumOperations ( p , n ) : NEW_LINE INDENT visited = [ 0 ] * ( n + 1 ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ele = p [ i ] NEW_LINE if ( visited [ ele ] == 0 ) : NEW_LINE INDENT visited [ ele ] = 1 NEW_LINE len = 1 NEW_LINE ele = p [ ele ] NEW_LINE while ( visited [ ele ] == 0 ) : NEW_LINE INDENT visited [ ele ] = 1 NEW_LINE len += 1 NEW_LINE ele = p [ ele ] NEW_LINE DEDENT operations = calculateCycycleOperations ( l , operations ) NEW_LINE if ( num != len ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT ans = max ( ans , operations ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT P = [ - 1 , 4 , 6 , 5 , 3 , 2 , 7 , 8 , 9 , 1 ] NEW_LINE n = len ( P ) - 1 NEW_LINE print ( minimumOperations ( P , n ) ) NEW_LINE DEDENT"],"references":["def calculateCycleOperations ( length ) : NEW_LINE INDENT cycle_operations = 0 NEW_LINE while length > 0 : NEW_LINE INDENT length \/\/= 3 NEW_LINE cycle_operations += 1 NEW_LINE DEDENT return cycle_operations - 1 NEW_LINE DEDENT def minimumOperations ( p , n ) : NEW_LINE INDENT visited = [ 0 ] * ( n + 1 ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ele = p [ i ] NEW_LINE if not visited [ ele ] : NEW_LINE INDENT visited [ ele ] = 1 NEW_LINE length = 1 NEW_LINE ele = p [ ele ] NEW_LINE while not visited [ ele ] : NEW_LINE INDENT visited [ ele ] = 1 NEW_LINE length += 1 NEW_LINE ele = p [ ele ] NEW_LINE DEDENT operations = calculateCycleOperations ( length ) NEW_LINE num = pow ( 3 , operations ) NEW_LINE if num != length : NEW_LINE INDENT return - 1 NEW_LINE DEDENT ans = max ( ans , operations ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT P = [ - 1 , 4 , 6 , 5 , 3 , 2 , 7 , 8 , 9 , 1 ] NEW_LINE n = len ( P ) - 1 NEW_LINE print ( minimumOperations ( P , n ) ) NEW_LINE DEDENT"],"bleu":0.79672557825514,"rouge_l":0.8989561301767073}
{"id":1635,"predictions":["R = 3 NEW_LINE R = 7 NEW_LINE pi = 3.14159 NEW_LINE pi = 3.14159 NEW_LINE Volume = 2 * pi * pi * R * r NEW_LINE print ( \" Volume : \" , end = \" \" ) NEW_LINE Surface = 2 * pi * pi * R * r NEW_LINE print ( \" Surface : \" , Surface ) NEW_LINE Surface = 4 * pi * pi * pi * R * r NEW_LINE print ( \" Surface : \" , Surface ) NEW_LINE"],"references":["r = 3 NEW_LINE R = 7 NEW_LINE pi = 3.14159 NEW_LINE Volume = ( float ) ( 2 * pi * pi * R * r * r ) ; NEW_LINE print ( \" Volume : ▁ \" , Volume ) ; NEW_LINE Surface = ( float ) ( 4 * pi * pi * R * r ) ; NEW_LINE print ( \" Surface : ▁ \" , Surface ) ; NEW_LINE"],"bleu":0.48167419484307883,"rouge_l":0.7059309774746849}
{"id":1636,"predictions":["def numberOfPaths ( m , n ) : NEW_LINE INDENT dp = [ 0 for i in range ( n ) ] NEW_LINE dp [ 0 ] = 1 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT dp [ j ] += dp [ j - 1 ] NEW_LINE DEDENT DEDENT return dp [ n - 1 ] NEW_LINE DEDENT print ( numberOfPaths ( m , n ) ) NEW_LINE"],"references":["def numberOfPaths ( p , q ) : NEW_LINE INDENT dp = [ 1 for i in range ( q ) ] NEW_LINE for i in range ( p - 1 ) : NEW_LINE INDENT for j in range ( 1 , q ) : NEW_LINE INDENT dp [ j ] += dp [ j - 1 ] NEW_LINE DEDENT DEDENT return dp [ q - 1 ] NEW_LINE DEDENT print ( numberOfPaths ( 3 , 3 ) ) NEW_LINE"],"bleu":0.6504869340265228,"rouge_l":0.840959040959041}
{"id":1637,"predictions":["def alternate ( a , b , x ) : NEW_LINE INDENT return x [ a ^ b ^ x ] NEW_LINE DEDENT a = - 10 NEW_LINE b = 15 NEW_LINE x = a NEW_LINE print ( \" x ▁ is ▁ : ▁ \" , x ) NEW_LINE x = alternate ( a , b , x ) NEW_LINE print ( \" x ▁ exchange ▁ \" ) NEW_LINE x = alternate ( a , b , x ) NEW_LINE print ( \" \" x ▁ exchange ▁ : ▁ \" , x ) NEW_LINE"],"references":["def alternate ( a , b , x ) : NEW_LINE INDENT x = a ^ b ^ x NEW_LINE print ( \" After ▁ exchange \" ) NEW_LINE print ( \" x ▁ is \" , x ) NEW_LINE DEDENT a = - 10 NEW_LINE b = 15 NEW_LINE x = a NEW_LINE print ( \" x ▁ is \" , x ) NEW_LINE alternate ( a , b , x ) NEW_LINE"],"bleu":0.6015602274311139,"rouge_l":0.6352918058557673}
{"id":1638,"predictions":["def surface_area_area ( side ) : NEW_LINE INDENT return ( 2 * ( math . sqrt ( 3 ) ) * ( side * side ) ) NEW_LINE DEDENT side = 7 NEW_LINE print ( \" Surface ▁ area ▁ of ▁ octahedron ▁ = \" , surface_octahedron ( side ) ) NEW_LINE"],"references":["import math NEW_LINE def surface_area_octahedron ( side ) : NEW_LINE INDENT return ( 2 * ( math . sqrt ( 3 ) ) * ( side * side ) ) NEW_LINE DEDENT side = 7 NEW_LINE print ( \" Surface ▁ area ▁ of ▁ octahedron ▁ = \" , surface_area_octahedron ( side ) ) NEW_LINE"],"bleu":0.8674290351253457,"rouge_l":0.9311583358275963}
{"id":1639,"predictions":["def CenteredDodeca_num ( n ) : NEW_LINE INDENT return ( 2 * n + 1 ) * ( 5 * n * n + 5 * n + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ ' : NEW_LINE INDENT n = 3 NEW_LINE print ( ( n , \" th ▁ Centered \" , \" th ▁ Centered \" , \" number ▁ : ▁ \" , int ( CenteredDodahedral_num ( n ) ) ) NEW_LINE n = 10 NEW_LINE print ( CenteredDodecahedral_num ( n ) ) NEW_LINE DEDENT"],"references":["def CenteredDodecahedral_num ( n ) : NEW_LINE INDENT return ( 2 * n + 1 ) * ( 5 * n * n + 5 * n + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE print ( n , \" rd ▁ centered ▁ dodecahedral ▁ number : ▁ \" , CenteredDodecahedral_num ( n ) ) NEW_LINE n = 10 NEW_LINE print ( n , \" th ▁ centered ▁ dodecahedral ▁ number ▁ : ▁ \" , CenteredDodecahedral_num ( n ) ) NEW_LINE DEDENT"],"bleu":0.7275311243353103,"rouge_l":0.7942171119377749}
{"id":1640,"predictions":["def longestSubstring ( s ) : NEW_LINE INDENT cnt = 1 NEW_LINE maxi = 1 NEW_LINE n = len ( s ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] != s [ i - 1 ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT maxi = max ( cnt , maxi ) NEW_LINE cnt = 1 NEW_LINE DEDENT DEDENT maxi = max ( cnt , maxi ) NEW_LINE return maxi NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" ccccdedff \" NEW_LINE print ( longestSubstring ( s ) ) NEW_LINE DEDENT"],"references":["def longestSubstring ( s ) : NEW_LINE INDENT cnt = 1 ; NEW_LINE maxi = 1 ; NEW_LINE n = len ( s ) ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] != s [ i - 1 ] ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT maxi = max ( cnt , maxi ) ; NEW_LINE cnt = 1 ; NEW_LINE DEDENT DEDENT maxi = max ( cnt , maxi ) ; NEW_LINE return maxi ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" ccccdeededff \" ; NEW_LINE print ( longestSubstring ( s ) ) ; NEW_LINE DEDENT"],"bleu":0.739867172763324,"rouge_l":0.9275710284113645}
{"id":1641,"predictions":["def firstDigit ( x ) : NEW_LINE INDENT while x >= 10 : NEW_LINE INDENT x = x \/\/ 10 NEW_LINE DEDENT return x NEW_LINE DEDENT print ( firstDigit ( 12345 ) ) NEW_LINE print ( firstDigit ( 5432 ) ) NEW_LINE print ( firstDigit ( 5432 ) ) NEW_LINE"],"references":["def firstDigit ( x ) : NEW_LINE INDENT while ( x >= 10 ) : NEW_LINE INDENT x = x \/\/ 10 NEW_LINE DEDENT return x NEW_LINE DEDENT print ( firstDigit ( 12345 ) ) NEW_LINE print ( firstDigit ( 5432 ) ) NEW_LINE"],"bleu":0.7838697626447643,"rouge_l":0.9040225829216654}
{"id":1642,"predictions":[" C = [ [ 0 for i in range ( 1000 ) ] for j in range ( 1000 ) ] NEW_LINE def binomialCoeff ( n ) : NEW_LINE INDENT for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT def numberOfWays ( x , y , z ) : NEW_LINE INDENT binomialCoeff ( max ( x , max ( y , z ) ) ) NEW_LINE sum = 0 NEW_LINE for i in range ( 1 , y + 1 ) : NEW_LINE INDENT sum = ( sum + C [ z ] [ i ] ) ) NEW_LINE DEDENT sum1 = 0 NEW_LINE for i in range ( 1 , y + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , x + 1 ) : NEW_LINE INDENT sum1 = ( sum1 + ( C [ y ] [ i ] * C [ x ] [ j ] ) ) NEW_LINE DEDENT DEDENT sum1 = ( sum * sum1 ) NEW_LINE return sum1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = 3 NEW_LINE y = 2 NEW_LINE z = 1 NEW_LINE print ( numberOfWays ( x , y , z ) ) NEW_LINE DEDENT"],"references":["C = [ [ 0 for i in range ( 1000 ) ] for i in range ( 1000 ) ] NEW_LINE def binomialCoeff ( n ) : NEW_LINE INDENT i , j = 0 , 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] +   \\ NEW_LINE INDENT C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def numberOfWays ( x , y , z ) : NEW_LINE INDENT binomialCoeff ( max ( x , max ( y , z ) ) ) NEW_LINE sum = 0 NEW_LINE for i in range ( 1 , z + 1 ) : NEW_LINE INDENT sum = ( sum + C [ z ] [ i ] ) NEW_LINE DEDENT sum1 = 0 NEW_LINE for i in range ( 1 , y + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , x + 1 ) : NEW_LINE INDENT sum1 = ( sum1 + ( C [ y ] [ i ] * C [ x ] [ j ] ) ) NEW_LINE DEDENT DEDENT sum1 = ( sum * sum1 ) NEW_LINE return sum1 NEW_LINE DEDENT x = 3 NEW_LINE y = 2 NEW_LINE z = 1 NEW_LINE print ( numberOfWays ( x , y , z ) ) NEW_LINE"],"bleu":0.9157050727611581,"rouge_l":0.9413580246913581}
{"id":1643,"predictions":["def isDivisible ( n ) : NEW_LINE INDENT while n \/\/ 100 : NEW_LINE INDENT d = n % 10 NEW_LINE n \/\/= 10 NEW_LINE n = abs ( n - ( d * 14 ) ) NEW_LINE DEDENT return ( n % 47 == 0 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 59142 NEW_LINE if ( isDivisible ( N ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def isDivisible ( n ) : NEW_LINE INDENT while n \/\/ 100 : NEW_LINE INDENT d = n % 10 NEW_LINE n \/\/= 10 NEW_LINE n = abs ( n - ( d * 14 ) ) NEW_LINE DEDENT return ( n % 47 == 0 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 59173 NEW_LINE if ( isDivisible ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.9293268540260099,"rouge_l":0.9690721649484536}
{"id":1644,"predictions":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT SIZE = 1001 NEW_LINE ans = sum ( 4 * n for n in range ( 3 , eulerlib . sqrt ( n - 1 ) ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["def compute ( ) : NEW_LINE INDENT SIZE = 1001 NEW_LINE ans = 1 NEW_LINE ans += sum ( 4 * i * i - 6 * ( i - 1 ) for i in range ( 3 , SIZE + 1 , 2 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.6649042763686713,"rouge_l":0.7668571428571429}
{"id":1645,"predictions":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 9 NEW_LINE sum = 0 NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if isstrong and isprime ( m ) : NEW_LINE INDENT sum += m NEW_LINE DEDENT if m % s == 0 : NEW_LINE INDENT return sum NEW_LINE DEDENT DEDENT DEDENT def find_Harshad_primes ( n , digitSum , isprime ) : NEW_LINE INDENT m = n * 10 NEW_LINE s = digitSum NEW_LINE i = 0 NEW_LINE while i < 10 and m < LIMIT : NEW_LINE INDENT if isStrongad and is_prime ( m ) : NEW_LINE INDENT sum += m NEW_LINE DEDENT if m % s == 0 : NEW_LINE INDENT return sum NEW_LINE DEDENT i += 1 NEW_LINE s += 1 NEW_LINE s += 1 NEW_LINE s += 1 NEW_LINE s += 1 NEW_LINE DEDENT DEDENT DEDENT def is_prime ( x ) : NEW_LINE INDENT if x < 0 : NEW_LINE INDENT raise ValueError ( ) NEW_LINE DEDENT if x == 0 or x == 1 : NEW_LINE INDENT return False NEW_LINE DEDENT if x == 0 or x == 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , eulerlib . sqrt ( x ) ) : NEW_LINE INDENT if x % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 14 NEW_LINE ans = [ 0 ] NEW_LINE def find_harshad_primes ( n , digitsum , isstrong ) : NEW_LINE INDENT m = n * 10 NEW_LINE s = digitsum NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT if m >= LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT if isstrong and eulerlib . is_prime ( m ) : NEW_LINE INDENT ans [ 0 ] += m NEW_LINE DEDENT if m % s == 0 : NEW_LINE INDENT find_harshad_primes ( m , s , eulerlib . is_prime ( m \/\/ s ) ) NEW_LINE DEDENT m += 1 NEW_LINE s += 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , 10 ) : NEW_LINE INDENT find_harshad_primes ( i , i , False ) NEW_LINE DEDENT return str ( ans [ 0 ] ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.39427568592412815,"rouge_l":0.5436720142602496}
{"id":1646,"predictions":["def compute ( ) : NEW_LINE INDENT LENGTH = 50 NEW_LINE ways = [ 0 ] * ( LENGTH + 1 ) NEW_LINE for n in range ( 1 , LENGTH + 1 ) : NEW_LINE INDENT for k in range ( 1 , n + 1 ) : NEW_LINE INDENT ways [ n ] += ways [ n - k ] NEW_LINE DEDENT DEDENT return str ( ways [ - 1 ] ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["def compute ( ) : NEW_LINE INDENT LENGTH = 50 NEW_LINE ways = [ 1 ] + [ 0 ] * LENGTH NEW_LINE for n in range ( 1 , len ( ways ) ) : NEW_LINE INDENT ways [ n ] += sum ( ways [ max ( n - 4 , 0 ) : n ] ) NEW_LINE DEDENT return str ( ways [ - 1 ] ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.6793528082545075,"rouge_l":0.7924822449333102}
{"id":1647,"predictions":["import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT return str ( itertools . count ( 1 ) ) NEW_LINE DEDENT def eulerlib . set ( range ( 177755 , 1855 ) ) : NEW_LINE INDENT if y == 1 : NEW_LINE INDENT return x % m NEW_LINE DEDENT else : NEW_LINE INDENT return ( x % m ) NEW_LINE DEDENT DEDENT return eulerlib . get ( x , y ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import eulerlib , sys NEW_LINE def compute ( ) : NEW_LINE INDENT x , y , m = 1777 , 1855 , 10 ** 8 NEW_LINE sys . setrecursionlimit ( y + 30 ) NEW_LINE ans = tetration_mod ( x , y , m ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def tetration_mod ( x , y , m ) : NEW_LINE INDENT if y == 1 : NEW_LINE INDENT return x % m NEW_LINE DEDENT else : NEW_LINE INDENT return pow ( x , tetration_mod ( x , y - 1 , totient ( m ) ) , m ) NEW_LINE DEDENT DEDENT def totient ( n ) : NEW_LINE INDENT assert n > 0 NEW_LINE p = 1 NEW_LINE i = 2 NEW_LINE end = eulerlib . sqrt ( n ) NEW_LINE while i <= end : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT p *= i - 1 NEW_LINE n \/\/= i NEW_LINE while n % i == 0 : NEW_LINE INDENT p *= i NEW_LINE n \/\/= i NEW_LINE DEDENT end = eulerlib . sqrt ( n ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if n != 1 : NEW_LINE INDENT p *= n - 1 NEW_LINE DEDENT return p NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.1658121454187156,"rouge_l":0.4273204903677759}
{"id":1648,"predictions":["import eulerlib , itertools NEW_LINE def factorialSuffix ( n ) : NEW_LINE INDENT twos = count_factors ( n , 2 ) - count_factors ( n , 5 ) NEW_LINE if twos >= 2505 : NEW_LINE INDENT twos = ( twos - 5 ) % 2500 + 5 NEW_LINE DEDENT return factorial ( n ) * eulerlib . factorial ( n ) NEW_LINE DEDENT def factorial_sqrt ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return factorial ( n ) * oddFactorial ( n ) * factorial ( 2 , twos , 100000 ) % 100000 NEW_LINE DEDENT DEDENT def factorial ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return factorial ( n ) * oddFactorial ( n ) NEW_LINE DEDENT DEDENT def factorial_factorial ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( int ( end \/ 2 ) ) NEW_LINE DEDENT DEDENT def factorial_factorial ( n ) : NEW_LINE INDENT n %= 100000 NEW_LINE product = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if i % 2 != 0 : NEW_LINE INDENT product = i * product % 5 NEW_LINE DEDENT DEDENT return product NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["def compute ( ) : NEW_LINE INDENT ans = factorial_suffix ( 10 ** 12 ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def factorial_suffix ( n ) : NEW_LINE INDENT twos = count_factors ( n , 2 ) - count_factors ( n , 5 ) NEW_LINE if twos >= 2505 : NEW_LINE INDENT twos = ( twos - 5 ) % 2500 + 5 NEW_LINE DEDENT return factorialish ( n ) * pow ( 2 , twos , 100000 ) % 100000 NEW_LINE DEDENT def factorialish ( n ) : NEW_LINE INDENT return even_factorialish ( n ) * odd_factorialish ( n ) % 100000 NEW_LINE DEDENT def even_factorialish ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return factorialish ( n \/\/ 2 ) NEW_LINE DEDENT DEDENT def odd_factorialish ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return odd_factorialish ( n \/\/ 5 ) * factorial_coprime ( n ) % 100000 NEW_LINE DEDENT DEDENT def factorial_coprime ( n ) : NEW_LINE INDENT n %= 100000 NEW_LINE product = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if i % 2 != 0 and i % 5 != 0 : NEW_LINE INDENT product = i * product % 100000 NEW_LINE DEDENT DEDENT return product NEW_LINE DEDENT def count_factors ( end , n ) : NEW_LINE INDENT if end == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return end \/\/ n + count_factors ( end \/\/ n , n ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.653515803688505,"rouge_l":0.7159374818430074}
{"id":1649,"predictions":["def compute ( ) : NEW_LINE INDENT count = 0 NEW_LINE num = [ 1 ] * 8 NEW_LINE while True : NEW_LINE INDENT a , b , c , d = num [ 1 ] , num [ 2 ] , num [ 5 ] , d NEW_LINE e = num [ 4 ] NEW_LINE i = num [ 4 ] NEW_LINE j = num [ 4 ] NEW_LINE k = num [ 6 ] NEW_LINE m = num [ 7 ] NEW_LINE k = num [ 7 ] NEW_LINE m = num [ 7 ] NEW_LINE while ( m < 0 or m < 9 ) : NEW_LINE INDENT m = a + b + d - i NEW_LINE if ( m < 0 or m > 9 ) : NEW_LINE INDENT continue NEW_LINE DEDENT j = a + b + c - i - k NEW_LINE if ( m < 0 or j > 9 ) : NEW_LINE INDENT continue NEW_LINE DEDENT j = a + b + d - i - k NEW_LINE if ( j < 0 or f > 9 ) or ( j < 9 - i - j - k ) : NEW_LINE INDENT continue NEW_LINE DEDENT l = a + b + d - e - i - k NEW_LINE if ( f < 0 or f > 9 ) : NEW_LINE INDENT continue NEW_LINE DEDENT h = a + b + d - i - 1 NEW_LINE if ( h < 0 or h > 9 ) or ( h > 9 ) : NEW_LINE INDENT continue NEW_LINE DEDENT h = a + b + c - 1 NEW_LINE if ( h < 0 or p > 9 ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( n < 0 or h > 9 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return str ( count ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["def compute ( ) : NEW_LINE INDENT ans = 0 NEW_LINE digits = tuple ( range ( 10 ) ) NEW_LINE for b in digits : NEW_LINE INDENT for c in digits : NEW_LINE INDENT for d in digits : NEW_LINE INDENT for e in digits : NEW_LINE INDENT for i in digits : NEW_LINE INDENT m = b + c + d - e - i NEW_LINE if m < 0 or m > 9 : continue NEW_LINE for k in digits : NEW_LINE INDENT f = b + c + d * 2 - e - i - k NEW_LINE if f < 0 or f > 9 : continue NEW_LINE for a in digits : NEW_LINE INDENT for g in digits : NEW_LINE INDENT o = a + b + d - g - k NEW_LINE if o < 0 or o > 9 : continue NEW_LINE j = a + b + c - g - m NEW_LINE if j < 0 or j > 9 : continue NEW_LINE l = a + b + c + d - i - j - k NEW_LINE if l < 0 or l > 9 : continue NEW_LINE h = a + b + c + d - e - f - g NEW_LINE if h < 0 or h > 9 : continue NEW_LINE n = a + c + d - f - j NEW_LINE if n < 0 or n > 9 : continue NEW_LINE p = a + b + c - h - l NEW_LINE if p < 0 or p > 9 : continue NEW_LINE ans += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.40989850495066055,"rouge_l":0.5647005261027924}
{"id":1650,"predictions":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT modulus = 2 * 10 NEW_LINE modulus = 2 NEW_LINE for i in range ( 2 , 10 ) : NEW_LINE INDENT n = ( 2 * 1430 + modulus ) % modulus NEW_LINE n = n + 1 % modulus NEW_LINE DEDENT return str ( n ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["def compute ( ) : NEW_LINE INDENT MOD = 10 ** 10 NEW_LINE ans = ( 28433 * pow ( 2 , 7830457 , MOD ) + 1 ) % MOD NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.4356202966831287,"rouge_l":0.6704898446833931}
{"id":1651,"predictions":["import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT start_num = 1 NEW_LINE end_num = 500_number NEW_LINE primes = [ ] NEW_LINE crOQUALS = \" PARGET_Numerator ( ) : NEW_LINE INDENT if 0 <= end_num < end_num : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT NUM_JUM = eulerlib . list_primality ( ) NEW_LINE for i in range ( start_num ) : NEW_LINE INDENT pos = i NEW_LINE consecutiveNumerator = 1 NEW_LINE if is_prime [ pos ] == ' P ' : NEW_LINE INDENT consecutiveNumerator = 1 NEW_LINE DEDENT elif isprime [ pos ] == ' P ' : NEW_LINE INDENT pos -= 1 NEW_LINE DEDENT elif isprime [ pos ] == ' P ' : NEW_LINE INDENT pos -= 1 NEW_LINE DEDENT elif isprime [ pos ] == ' P ' : NEW_LINE INDENT pos -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT pos -= 1 NEW_LINE DEDENT if ( ( ( j >> k ) & 1 ) == 0 : NEW_LINE INDENT pos -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT pos -= 1 NEW_LINE DEDENT if ( ( j >> k ) & 1 ) == 0 ) : NEW_LINE INDENT pos -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT pos -= 1 NEW_LINE DEDENT if ( ( ( ( j >> k ) & 1 ) == 0 ) : NEW_LINE INDENT pos -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT pos -= 1 NEW_LINE DEDENT if ( ( ( j >> k ) & 1 ) == 0 ) : NEW_LINE INDENT return fraction ( [ pos ] , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import eulerlib , fractions NEW_LINE def compute ( ) : NEW_LINE INDENT START_NUM = 1 NEW_LINE END_NUM = 500 NEW_LINE CROAK_SEQ = \" PPPPNNPPPNPPNPN \" NEW_LINE assert 0 <= START_NUM < END_NUM NEW_LINE assert 1 <= len ( CROAK_SEQ ) NEW_LINE NUM_JUMPS = len ( CROAK_SEQ ) - 1 NEW_LINE NUM_TRIALS = 2 ** NUM_JUMPS NEW_LINE globalnumerator = 0 NEW_LINE isprime = eulerlib . list_primality ( END_NUM ) NEW_LINE for i in range ( START_NUM , END_NUM + 1 ) : NEW_LINE INDENT for j in range ( NUM_TRIALS ) : NEW_LINE INDENT pos = i NEW_LINE trialnumerator = 1 NEW_LINE if isprime [ pos ] == ( CROAK_SEQ [ 0 ] == ' P ' ) : NEW_LINE INDENT trialnumerator *= 2 NEW_LINE DEDENT for k in range ( NUM_JUMPS ) : NEW_LINE INDENT if pos <= START_NUM : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT elif pos >= END_NUM : NEW_LINE INDENT pos -= 1 NEW_LINE DEDENT elif ( j >> k ) & 1 == 0 : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT else : NEW_LINE INDENT pos -= 1 NEW_LINE DEDENT if isprime [ pos ] == ( CROAK_SEQ [ k + 1 ] == ' P ' ) : NEW_LINE INDENT trialnumerator *= 2 NEW_LINE DEDENT DEDENT globalnumerator += trialnumerator NEW_LINE DEDENT DEDENT globaldenominator = ( END_NUM + 1 - START_NUM ) * 2 ** NUM_JUMPS * 3 ** len ( CROAK_SEQ ) NEW_LINE ans = fractions . Fraction ( globalnumerator , globaldenominator ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.400541693434811,"rouge_l":0.5377525903028222}
{"id":1652,"predictions":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 8 NEW_LINE isprime = eulerlib . list_primality ( LIMIT - 1 ) NEW_LINE ans = 0 NEW_LINE isprime = eulerlib . list_primality ( LIMIT - 1 ) NEW_LINE for x in range ( 1 , len ( isprime ) ) : NEW_LINE INDENT a = x * y ** 2 - 1 NEW_LINE if a >= len ( isprime ) : NEW_LINE INDENT break NEW_LINE DEDENT if not isprime [ a ] : NEW_LINE INDENT continue NEW_LINE DEDENT for z in range ( y + 1 ) : NEW_LINE INDENT if eulerlib . gcd ( y , z ) != 1 : NEW_LINE INDENT continue NEW_LINE DEDENT b = x * y * y - 1 NEW_LINE c = x * z - 1 NEW_LINE if c >= len ( isprime ) : NEW_LINE INDENT break NEW_LINE DEDENT if c >= len ( isprime ) : NEW_LINE INDENT break NEW_LINE DEDENT if isprime [ b ] and is_prime [ c ] : NEW_LINE INDENT addend = a + b + c NEW_LINE if addend < sum : NEW_LINE INDENT break NEW_LINE DEDENT addend = a + b + c NEW_LINE if add + addend < sum : NEW_LINE INDENT raise AssertionError ( ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import eulerlib , fractions , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 8 NEW_LINE ans = 0 NEW_LINE isprime = eulerlib . list_primality ( LIMIT - 1 ) NEW_LINE for x in range ( 1 , LIMIT \/\/ 4 + 1 ) : NEW_LINE INDENT for y in itertools . count ( 1 ) : NEW_LINE INDENT a = x * y * y - 1 NEW_LINE if a >= LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT if not isprime [ a ] : NEW_LINE INDENT continue NEW_LINE DEDENT for z in itertools . count ( y + 1 ) : NEW_LINE INDENT if fractions . gcd ( y , z ) != 1 : NEW_LINE INDENT continue NEW_LINE DEDENT c = x * z * z - 1 NEW_LINE if c >= LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT if isprime [ c ] : NEW_LINE INDENT b = x * y * z - 1 NEW_LINE if isprime [ b ] : NEW_LINE INDENT ans += a + b + c NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.6448920495245922,"rouge_l":0.7393674245140931}
{"id":1653,"predictions":["import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT TGrie = 10 NEW_LINE ans = 0 NEW_LINE for k in range ( 1 , endGrees + 1 ) : NEW_LINE INDENT for n in range ( k + 1 ) : NEW_LINE INDENT if ( n == TGrees + 2 ) : NEW_LINE INDENT raise AssertionError ( ) NEW_LINE DEDENT DEDENT if ( ans [ n ] == 1 ) : NEW_LINE INDENT return str ( ans ) NEW_LINE DEDENT else : NEW_LINE INDENT return str ( ans ) NEW_LINE DEDENT DEDENT DEDENT def str ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT product = Fraction ( i ) NEW_LINE for j in range ( 1 , k + 1 ) : NEW_LINE INDENT if j != i : NEW_LINE INDENT product = product * Fraction ( n - j ) NEW_LINE for j in range ( 1 , k + 1 ) NEW_LINE if ( j != i ) : NEW_LINE INDENT product *= Fraction ( n - j ) NEW_LINE DEDENT DEDENT DEDENT sum += product NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import itertools NEW_LINE from fractions import Fraction NEW_LINE DEGREE = 10 NEW_LINE def compute ( ) : NEW_LINE INDENT ans = Fraction ( 0 , 1 ) NEW_LINE for k in range ( 1 , DEGREE + 1 ) : NEW_LINE INDENT for n in itertools . count ( k + 1 ) : NEW_LINE INDENT if n == DEGREE + 2 : NEW_LINE INDENT raise AssertionError ( ) NEW_LINE DEDENT reference = Fraction ( generating_function ( n ) , 1 ) NEW_LINE term = optimum_polynomial ( k , n ) NEW_LINE if term != reference : NEW_LINE INDENT ans += term NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT return str ( ans . numerator ) + ( \" \" if ans . denominator == 1 else \" \/ \" + str ( ans . denominator ) ) NEW_LINE DEDENT def optimum_polynomial ( k , n ) : NEW_LINE INDENT sum = Fraction ( 0 , 1 ) NEW_LINE for i in range ( k + 1 ) : NEW_LINE INDENT product = Fraction ( generating_function ( i ) , 1 ) NEW_LINE for j in range ( 1 , k + 1 ) : NEW_LINE INDENT if j != i : NEW_LINE INDENT product *= Fraction ( n - j , i - j ) NEW_LINE DEDENT DEDENT sum += product NEW_LINE DEDENT return sum NEW_LINE DEDENT def generating_function ( n ) : NEW_LINE INDENT return sum ( ( - n ) ** i for i in range ( DEGREE + 1 ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.5266461082493037,"rouge_l":0.6502697148728487}
{"id":1654,"predictions":["import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT MODULUS = 10 ** 9 NEW_LINE numSubsets = 1 NEW_LINE numSubsets = 1 NEW_LINE for i in range ( 1 , 25 ) : NEW_LINE INDENT temp = pow ( i , i , 250 ) NEW_LINE for j in range ( len ( numSubsets ) ) : NEW_LINE INDENT new_sets [ ( j + temp ) % 250 ] = ( numSubsets [ j ] + numSubsets [ ( j + temp ) % 250 ] ) % MODULUS NEW_LINE DEDENT numSubsets = [ ] NEW_LINE DEDENT return str ( ( numSubsets [ 0 ] - 1 + MODULUS ) % MODULUS ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["def compute ( ) : NEW_LINE INDENT MOD = 10 ** 16 NEW_LINE subsets = [ 0 ] * 250 NEW_LINE subsets [ 0 ] = 1 NEW_LINE for i in range ( 1 , 250250 + 1 ) : NEW_LINE INDENT offset = pow ( i , i , 250 ) NEW_LINE subsets = [ ( val + subsets [ ( j - offset ) % 250 ] ) % MOD for ( j , val ) in enumerate ( subsets ) ] NEW_LINE DEDENT ans = ( subsets [ 0 ] - 1 ) % MOD NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.4862470121381657,"rouge_l":0.6443395054057413}
{"id":1655,"predictions":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 6 NEW_LINE totients = 0 NEW_LINE for i in range ( 2 , len ( totients ) ) : NEW_LINE INDENT totients [ i ] += totients [ i ] NEW_LINE DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT totients = eulerlib . list_totients ( 10 ** 6 ) NEW_LINE ans = sum ( itertools . islice ( totients , 2 , None ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.5464280368508364,"rouge_l":0.715626466447677}
{"id":1656,"predictions":["def compute ( ) : NEW_LINE INDENT total = 200 NEW_LINE COins = [ 1 , 2 , 5 , 10 , 20 , 50 , 100 ] NEW_LINE for i in range ( total + 1 ) : NEW_LINE INDENT coins = coins [ i ] NEW_LINE for j in range ( total ) : NEW_LINE INDENT if j >= coin : NEW_LINE INDENT break NEW_LINE DEDENT ways [ i + 1 ] [ j ] = ways [ i ] [ j ] + ( ways [ i + 1 ] [ j - coin ] if j >= coin else 0 ) NEW_LINE DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["def compute ( ) : NEW_LINE INDENT TOTAL = 200 NEW_LINE ways = [ 1 ] + [ 0 ] * TOTAL NEW_LINE for coin in [ 1 , 2 , 5 , 10 , 20 , 50 , 100 , 200 ] : NEW_LINE INDENT for i in range ( len ( ways ) - coin ) : NEW_LINE INDENT ways [ i + coin ] += ways [ i ] NEW_LINE DEDENT DEDENT return str ( ways [ - 1 ] ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.49112696618639884,"rouge_l":0.6476833976833977}
{"id":1657,"predictions":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT i = 1000000 NEW_LINE y = - 1 NEW_LINE i = 0 NEW_LINE while i > 0 : NEW_LINE INDENT if i > 0 and x == y == y : NEW_LINE INDENT break NEW_LINE DEDENT x = f ( x ) NEW_LINE y = f ( x ) % i NEW_LINE DEDENT rem = f ( i ) % i NEW_LINE while rem > 0 : NEW_LINE INDENT x = f ( x ) NEW_LINE y = f ( x ) NEW_LINE DEDENT rem = ( x + f ( x ) % i ) NEW_LINE if rem > 0.0 : NEW_LINE INDENT return ( math . f ( x ) NEW_LINE DEDENT else : NEW_LINE INDENT return f ( x + f ( x ) \/ 10 ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def compute ( ) : NEW_LINE INDENT def f ( x ) : NEW_LINE INDENT return math . floor ( 2.0 ** ( 30.403243784 - x * x ) ) \/ 1.0e9 NEW_LINE DEDENT ITERATIONS = 10 ** 12 NEW_LINE x = - 1.0 NEW_LINE y = - 1.0 NEW_LINE i = 0 NEW_LINE while i < ITERATIONS : NEW_LINE INDENT if i > 0 and x == y : NEW_LINE INDENT break NEW_LINE DEDENT x = f ( x ) NEW_LINE y = f ( f ( y ) ) NEW_LINE i += 1 NEW_LINE DEDENT remain = ( ITERATIONS - i ) % i NEW_LINE for i in range ( remain ) : NEW_LINE INDENT x = f ( x ) NEW_LINE DEDENT ans = x + f ( x ) NEW_LINE ans = math . floor ( ans * 1.0e9 ) \/ 1.0e9 NEW_LINE return f \" { ans : .9f } \" NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.5189499057343355,"rouge_l":0.6242020277882088}
{"id":1658,"predictions":["def compute ( ) : NEW_LINE INDENT ans = sum ( 1 for i in range ( 1 , 100 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["def compute ( ) : NEW_LINE INDENT ans = max ( sum ( int ( c ) for c in str ( a ** b ) ) for a in range ( 100 ) for b in range ( 100 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.5521063442356107,"rouge_l":0.748368572174367}
{"id":1659,"predictions":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( len ( NUMBER ) ) : NEW_LINE INDENT prod = 1 NEW_LINE for j in range ( n ) : NEW_LINE INDENT prod *= ord ( NUMBER [ i + j ] ) - ord ( '0' ) NEW_LINE DEDENT maxprod = max ( prod , maxprod ) NEW_LINE DEDENT return str ( ans ) NEW_LINE DEDENT def main_function ( ) : NEW_LINE INDENT NUMBER = 13 NEW_LINE for i in range ( len ( NUMBER ) ) : NEW_LINE INDENT prod = 1 NEW_LINE for j in range ( i + j ) ) : NEW_LINE INDENT prod = 1 NEW_LINE for j in range ( n ) : NEW_LINE INDENT prod *= ord ( NUMBER [ i + j ] ) - ord ( '0' ) NEW_LINE DEDENT max_d = max ( prod , max_d ) NEW_LINE DEDENT return str ( prod , max_d ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["def compute ( ) : NEW_LINE INDENT ans = max ( digit_product ( NUMBER [ i : i + ADJACENT ] ) for i in range ( len ( NUMBER ) - ADJACENT + 1 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def digit_product ( s ) : NEW_LINE INDENT result = 1 NEW_LINE for c in s : NEW_LINE INDENT result *= int ( c ) NEW_LINE DEDENT return result NEW_LINE DEDENT NUMBER = \"7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450\" NEW_LINE ADJACENT = 13 NEW_LINE if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.3182460750277298,"rouge_l":0.5307466196355085}
{"id":1660,"predictions":["import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT BASE = 10 NEW_LINE DIGITS = 20 NEW_LINE DIGITS = 3 NEW_LINE MAX_SUM = 9 NEW_LINE MAX_SUM = 9 NEW_LINE def compute ( ) : NEW_LINE INDENT BASE = [ ] NEW_LINE DIGITS = [ ] NEW_LINE for prefix in range ( DIGITS + 1 ) : NEW_LINE INDENT for prefix in range ( DIGITS + 1 ) : NEW_LINE INDENT ways . append ( 0 ) NEW_LINE DEDENT for prefix in range ( DIGITS + 1 ) : NEW_LINE INDENT for prefix in range ( DIGITS ) : NEW_LINE INDENT for prefix in range ( len ( ways ) ) : NEW_LINE INDENT sum = 0 NEW_LINE if digitsum ( prefix ) <= MAX_SUM : NEW_LINE INDENT nextdigit = 0 NEW_LINE DEDENT DEDENT DEDENT ways [ digits ] [ 0 ] = sum NEW_LINE DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["def compute ( ) : NEW_LINE INDENT BASE = 10 NEW_LINE DIGITS = 20 NEW_LINE CONSECUTIVE = 3 NEW_LINE MAX_SUM = 9 NEW_LINE innerlen = BASE ** CONSECUTIVE NEW_LINE ways = [ [ 1 ] + [ 0 ] * ( innerlen - 1 ) ] NEW_LINE for digits in range ( 1 , DIGITS + CONSECUTIVE + 1 ) : NEW_LINE INDENT newrow = [ ] NEW_LINE for prefix in range ( innerlen ) : NEW_LINE INDENT sum = 0 NEW_LINE if digit_sum ( prefix ) <= MAX_SUM : NEW_LINE INDENT for nextdigit in range ( BASE ) : NEW_LINE INDENT sum += ways [ digits - 1 ] [ prefix % ( BASE ** ( CONSECUTIVE - 1 ) ) * BASE + nextdigit ] NEW_LINE DEDENT DEDENT newrow . append ( sum ) NEW_LINE DEDENT ways . append ( newrow ) NEW_LINE DEDENT ans = ways [ - 1 ] [ 0 ] - ways [ - 2 ] [ 0 ] NEW_LINE return str ( ans ) NEW_LINE DEDENT def digit_sum ( n ) : NEW_LINE INDENT return sum ( int ( c ) for c in str ( n ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.43451428524227126,"rouge_l":0.5611364376424618}
{"id":1661,"predictions":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 9 NEW_LINE MODULUS = 10 ** 9 NEW_LINE splitAtIT = eulerlib . sqrt ( LIMIT ) NEW_LINE subsetcount = max ( ( splitCount \/\/ 3 ) ) NEW_LINE for i in range ( 1 , splitAtA + 1 ) : NEW_LINE INDENT count = LIMIT \/\/ i % MODULUS NEW_LINE term = i * i % MODULUS NEW_LINE term = term * i % MODULUS NEW_LINE sum = ( ( i + 1 ) % MODULUS ) NEW_LINE sum = ( sum + term ) % MODULUS NEW_LINE DEDENT for i in range ( splitCount , 0 , - 1 ) : NEW_LINE INDENT start = LIMIT \/\/ ( i + 1 ) NEW_LINE end = LIMIT \/\/ i NEW_LINE end = ( LIMIT \/\/ ( end ) NEW_LINE sumsquares = ( sum + sumsquares % MODULUS ) % MODULUS NEW_LINE sumsquares = ( sum + i * sumsquares % MODULUS ) % MODULUS NEW_LINE sum = ( sum + i * sumsquares % MODULUS ) % MODULUS NEW_LINE DEDENT return str ( sum ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 15 NEW_LINE MODULUS = 10 ** 9 NEW_LINE splitcount = eulerlib . sqrt ( LIMIT ) NEW_LINE splitat = LIMIT \/\/ ( splitcount + 1 ) NEW_LINE def sum_squares ( s , e ) : NEW_LINE INDENT return ( e * ( e + 1 ) * ( e * 2 + 1 ) - s * ( s + 1 ) * ( s * 2 + 1 ) ) \/\/ 6 NEW_LINE DEDENT ans = sum ( ( i * i * ( LIMIT \/\/ i ) ) for i in range ( 1 , splitat + 1 ) ) NEW_LINE ans += sum ( ( sum_squares ( LIMIT \/\/ ( i + 1 ) , LIMIT \/\/ i ) * i ) for i in range ( 1 , splitcount + 1 ) ) NEW_LINE return str ( ans % MODULUS ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.4130379391668565,"rouge_l":0.5352683091461357}
{"id":1662,"predictions":["def compute ( ) : NEW_LINE INDENT ans = sum ( 1 for i in range ( - 1000 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def num_consecutive_primes ( a , b ) : NEW_LINE INDENT return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT ans = max ( ( ( a , b ) for a in range ( - 999 , 1000 ) for b in range ( 2 , 1000 ) ) , key = count_consecutive_primes ) NEW_LINE return str ( ans [ 0 ] * ans [ 1 ] ) NEW_LINE DEDENT def count_consecutive_primes ( ab ) : NEW_LINE INDENT a , b = ab NEW_LINE for i in itertools . count ( ) : NEW_LINE INDENT n = i * i + i * a + b NEW_LINE if not is_prime ( n ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT DEDENT isprimecache = eulerlib . list_primality ( 1000 ) NEW_LINE def is_prime ( n ) : NEW_LINE INDENT if n < 0 : NEW_LINE INDENT return False NEW_LINE DEDENT elif n < len ( isprimecache ) : NEW_LINE INDENT return isprimecache [ n ] NEW_LINE DEDENT else : NEW_LINE INDENT return eulerlib . is_prime ( n ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.10843811973527,"rouge_l":0.4279470960322025}
{"id":1663,"predictions":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 5000 NEW_LINE MODULUS = 10 ** 9 NEW_LINE numSubsets = eulerlib . list_primality ( LIMIT * LIMIT \/\/ 2 ) NEW_LINE numSubsets = [ 0 ] * ( LIMIT * LIMIT \/\/ 2 ) NEW_LINE numSubsets [ 0 ] = 1 NEW_LINE maxsum = 0 NEW_LINE for i in range ( LIMIT ) : NEW_LINE INDENT if isprime [ i ] : NEW_LINE INDENT continue NEW_LINE DEDENT maxSum += i NEW_LINE for j in range ( LIMIT ) : NEW_LINE INDENT temp = numSubsets [ j ] + numSubsets [ j - i ] NEW_LINE if temp < MODULUS : NEW_LINE INDENT numSubsets [ j ] = temp NEW_LINE DEDENT else : NEW_LINE INDENT numSubsets [ j ] = temp - MODULUS NEW_LINE DEDENT DEDENT DEDENT ans = sum ( numSubsets ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 5000 NEW_LINE MODULUS = 10 ** 16 NEW_LINE count = [ 0 ] * ( LIMIT ** 2 \/\/ 2 ) NEW_LINE count [ 0 ] = 1 NEW_LINE s = 0 NEW_LINE for p in eulerlib . list_primes ( LIMIT ) : NEW_LINE INDENT for i in reversed ( range ( s + 1 ) ) : NEW_LINE INDENT count [ i + p ] = ( count [ i + p ] + count [ i ] ) % MODULUS NEW_LINE DEDENT s += p NEW_LINE DEDENT isprime = eulerlib . list_primality ( s + 1 ) NEW_LINE ans = sum ( count [ i ] for i in range ( s + 1 ) if isprime [ i ] ) % MODULUS NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.4974170250348578,"rouge_l":0.6040190272789049}
{"id":1664,"predictions":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT N = 5 NEW_LINE two_Pow_N = 1 << N - 1 NEW_LINE end = 1 << ( 2 ** ( 2 - N - 1 ) ) + 1 NEW_LINE for i in range ( start , end , 2 ) : NEW_LINE INDENT if check_arrangement ( i ) : NEW_LINE INDENT ans += i NEW_LINE DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT def check_set ( digits ) : NEW_LINE INDENT seen = 0 NEW_LINE temp = ( digits & ( 2x >> ( 2x >> 2 ) << 2 ) ) NEW_LINE for i in range ( 2 , eulerlib . sqrt ( digits ) ) : NEW_LINE INDENT seen = 0 NEW_LINE temp = ( digits & 1 << ( ( ( temp >> i ) & 1 ) << 2 ) ) NEW_LINE for i in seen ) : NEW_LINE INDENT seen |= 1 << ( ( temp >> i ) & 1 ) NEW_LINE DEDENT return seen == TOTAL_set NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["def compute ( ) : NEW_LINE INDENT N = 5 NEW_LINE TWO_POW_N = 2 ** N NEW_LINE MASK = TWO_POW_N - 1 NEW_LINE def check_arrangement ( digits ) : NEW_LINE INDENT seen = set ( ) NEW_LINE digits |= digits << TWO_POW_N NEW_LINE for i in range ( TWO_POW_N ) : NEW_LINE INDENT seen . add ( ( digits >> i ) & MASK ) NEW_LINE DEDENT return len ( seen ) == TWO_POW_N NEW_LINE DEDENT start = 2 ** ( TWO_POW_N - N - 1 ) + 1 NEW_LINE end = 2 ** ( TWO_POW_N - N ) NEW_LINE ans = sum ( i for i in range ( start , end , 2 ) if check_arrangement ( i ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.4323197913742037,"rouge_l":0.4980309288252809}
{"id":1665,"predictions":["def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 7 NEW_LINE numDivisors = [ 0 ] * LIMIT NEW_LINE for i in range ( 2 , len ( numDivisors ) ) : NEW_LINE INDENT for j in range ( i * 2 , len ( numDivisors ) , i ) : NEW_LINE INDENT numDivisors [ j ] += 1 NEW_LINE DEDENT DEDENT ans = sum ( numDivisors [ 2 ] for i in range ( 2 , len ( numDivisors ) ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["def compute ( ) : NEW_LINE INDENT divisors = [ 2 ] * ( 10 ** 7 + 1 ) NEW_LINE for i in range ( 2 , ( len ( divisors ) + 1 ) \/\/ 2 ) : NEW_LINE INDENT for j in range ( i * 2 , len ( divisors ) , i ) : NEW_LINE INDENT divisors [ j ] += 1 NEW_LINE DEDENT DEDENT ans = sum ( ( 1 if divisors [ i ] == divisors [ i + 1 ] else 0 ) for i in range ( 2 , len ( divisors ) - 1 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.6188957080506972,"rouge_l":0.7832684824902724}
{"id":1666,"predictions":["def compute ( ) : NEW_LINE INDENT for i in range ( len ( triangle ) ) : NEW_LINE INDENT for j in range ( len ( triangle [ i ] ) ) : NEW_LINE INDENT triangle [ i ] [ j ] += max ( triangle [ i + 1 ] [ j ] , tri [ i + 1 ] [ j + 1 ] ) NEW_LINE DEDENT DEDENT return str ( triangle [ 0 ] [ 0 ] ) NEW_LINE DEDENT triangle = [ [ 25 ] NEW_LINE for i in range ( 1 , len ( triangle ) ) : NEW_LINE INDENT for j in range ( len ( triangle [ i ] ) ) : NEW_LINE INDENT triangle [ i ] [ j ] += max ( triangle [ i + 1 ] [ j ] , tri [ i + 1 ] [ j + 1 ] [ j + 1 ] ) NEW_LINE DEDENT DEDENT return str ( triangle [ 0 ] [ 0 ] ) ) NEW_LINE DEDENT triangle = [ [ 75 ] , \" ab \" , \" ] NEW_LINE print ( compute ( ) ) NEW_LINE"],"references":["def compute ( ) : NEW_LINE INDENT for i in reversed ( range ( len ( triangle ) - 1 ) ) : NEW_LINE INDENT for j in range ( len ( triangle [ i ] ) ) : NEW_LINE INDENT triangle [ i ] [ j ] += max ( triangle [ i + 1 ] [ j ] , triangle [ i + 1 ] [ j + 1 ] ) NEW_LINE DEDENT DEDENT return str ( triangle [ 0 ] [ 0 ] ) NEW_LINE DEDENT triangle = [ [ 75 ] , [ 95 , 64 ] , [ 17 , 47 , 82 ] , [ 18 , 35 , 87 , 10 ] , [ 20 , 4 , 82 , 47 , 65 ] , [ 19 , 1 , 23 , 75 , 3 , 34 ] , [ 88 , 2 , 77 , 73 , 7 , 63 , 67 ] , [ 99 , 65 , 4 , 28 , 6 , 16 , 70 , 92 ] , [ 41 , 41 , 26 , 56 , 83 , 40 , 80 , 70 , 33 ] , [ 41 , 48 , 72 , 33 , 47 , 32 , 37 , 16 , 94 , 29 ] , [ 53 , 71 , 44 , 65 , 25 , 43 , 91 , 52 , 97 , 51 , 14 ] , [ 70 , 11 , 33 , 28 , 77 , 73 , 17 , 78 , 39 , 68 , 17 , 57 ] , [ 91 , 71 , 52 , 38 , 17 , 14 , 91 , 43 , 58 , 50 , 27 , 29 , 48 ] , [ 63 , 66 , 4 , 68 , 89 , 53 , 67 , 30 , 73 , 16 , 69 , 87 , 40 , 31 ] , [ 4 , 62 , 98 , 27 , 23 , 9 , 70 , 98 , 73 , 93 , 38 , 53 , 60 , 4 , 23 ] , ] NEW_LINE if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.20082258019957397,"rouge_l":0.4059089699228108}
{"id":1667,"predictions":["def compute ( ) : NEW_LINE INDENT return binomial ( 40 , 20 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT return str ( eulerlib . binomial ( 40 , 20 ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.7532512255419554,"rouge_l":0.886836935166994}
{"id":1668,"predictions":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 50000000 NEW_LINE ans = set ( eulerlib . list_primes ( eulerlib . sqrt ( LIMIT ) ) ) NEW_LINE for p in primes : NEW_LINE INDENT newsums = set ( ) NEW_LINE for p in primes : NEW_LINE INDENT newsums = set ( ) NEW_LINE for j in range ( i ) : NEW_LINE INDENT q = 1 NEW_LINE for j in range ( i ) : NEW_LINE INDENT q *= p NEW_LINE DEDENT if q > LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT r = q NEW_LINE for x in sorted ( sorted_primes ) : NEW_LINE INDENT if x + r <= LIMIT : NEW_LINE INDENT newsums . add ( x + r ) NEW_LINE DEDENT DEDENT DEDENT sums = new_sum NEW_LINE DEDENT return str ( len ( sums ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 50000000 NEW_LINE primes = eulerlib . list_primes ( eulerlib . sqrt ( LIMIT ) ) NEW_LINE sums = { 0 } NEW_LINE for i in range ( 2 , 5 ) : NEW_LINE INDENT newsums = set ( ) NEW_LINE for p in primes : NEW_LINE INDENT q = p ** i NEW_LINE if q > LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT for x in sums : NEW_LINE INDENT if x + q <= LIMIT : NEW_LINE INDENT newsums . add ( x + q ) NEW_LINE DEDENT DEDENT DEDENT sums = newsums NEW_LINE DEDENT return str ( len ( sums ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.6357568022830686,"rouge_l":0.7908268874605077}
{"id":1669,"predictions":["import itertools NEW_LINE def compute ( ) : NEW_LINE INDENT modulus = 10 ** 10 NEW_LINE modulus = 10 ** 10 NEW_LINE for i in range ( 1 , 100000000 ) : NEW_LINE INDENT s += i ** ( i ** 2 ** ( i ** modulus ) ) NEW_LINE DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["def compute ( ) : NEW_LINE INDENT MOD = 10 ** 10 NEW_LINE ans = sum ( pow ( i , i , MOD ) for i in range ( 1 , 1001 ) ) % MOD NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.56159494931406,"rouge_l":0.7150080441277866}
{"id":1670,"predictions":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 6 NEW_LINE maxnumer = 1 NEW_LINE totients = 1 NEW_LINE for i in range ( 1 , len ( totients ) ) : NEW_LINE INDENT if i * denom > totients [ i ] : NEW_LINE INDENT maxnumer = i NEW_LINE maxnumer = totients [ i ] NEW_LINE DEDENT DEDENT return str ( maxnumer ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import eulerlib , fractions NEW_LINE def compute ( ) : NEW_LINE INDENT totients = eulerlib . list_totients ( 10 ** 6 ) NEW_LINE ans = max ( range ( 2 , len ( totients ) ) , key = ( lambda i : fractions . Fraction ( i , totients [ i ] ) ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.4648250935318854,"rouge_l":0.671455223880597}
{"id":1671,"predictions":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT isprime = eulerlib . list_primality ( 10 , 8 ) NEW_LINE ans = sum ( i for i in range ( 5 , len ( isprime ) ) if isprime [ i ] ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def s ( p ) : NEW_LINE INDENT return str ( p - 3 ) * eulerlib . sqrt ( 8 % p , p ) % p ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT def s ( p ) : NEW_LINE INDENT return ( p - 3 ) * eulerlib . reciprocal_mod ( 8 % p , p ) % p NEW_LINE DEDENT ans = sum ( s ( p ) for p in eulerlib . prime_generator ( 10 ** 8 ) if p >= 5 ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.6368487199267594,"rouge_l":0.6190798376184032}
{"id":1672,"predictions":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 6 NEW_LINE def find_least_divisible_repunit ( n ) : NEW_LINE INDENT if ( n % 2 == 0 or n % 5 == 0 ) : NEW_LINE INDENT return str ( n ) NEW_LINE DEDENT DEDENT def find_least_divisible_repunit ( n ) : NEW_LINE INDENT if ( n % 2 == 0 or n % 5 == 0 ) : NEW_LINE INDENT return str ( n ) NEW_LINE DEDENT sum = 1 NEW_LINE pow = 1 NEW_LINE k = 1 NEW_LINE while ( sum % n != 0 ) : NEW_LINE INDENT k += 1 NEW_LINE pow = pow * 10 % n NEW_LINE sum = ( pow + pow ) % n NEW_LINE DEDENT return k NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import itertools NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 6 NEW_LINE for n in itertools . count ( LIMIT ) : NEW_LINE INDENT if least_divisible_repunit ( n ) > LIMIT : NEW_LINE INDENT return str ( n ) NEW_LINE DEDENT DEDENT DEDENT def least_divisible_repunit ( n ) : NEW_LINE INDENT if n % 2 == 0 or n % 5 == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT k = 1 NEW_LINE s = 1 NEW_LINE p = 1 NEW_LINE while s % n != 0 : NEW_LINE INDENT k += 1 NEW_LINE p = p * 10 % n NEW_LINE s = ( s + p ) % n NEW_LINE DEDENT return k NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.61879081400804,"rouge_l":0.8180599016540009}
{"id":1673,"predictions":["def compute ( ) : NEW_LINE INDENT ans = sum ( i for i in range ( 1 , 10000 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT ans = sum ( i for i in range ( 1 , 10000 ) if has_pandigital_product ( i ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def has_pandigital_product ( n ) : NEW_LINE INDENT for i in range ( 1 , eulerlib . sqrt ( n ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT temp = str ( n ) + str ( i ) + str ( n \/\/ i ) NEW_LINE if \" \" . join ( sorted ( temp ) ) == \"123456789\" : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.17102535793596776,"rouge_l":0.4926365795724465}
{"id":1674,"predictions":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10000000 NEW_LINE possible = eulerlib . list_primes ( LIMIT \/\/ 2 ) NEW_LINE for i in range ( len ( primes ) ) : NEW_LINE INDENT p = primes [ i ] NEW_LINE if p > end : NEW_LINE INDENT break NEW_LINE DEDENT for j in range ( i + 1 , len ( primes ) ) : NEW_LINE INDENT p = primes [ j ] NEW_LINE lcm = p * q NEW_LINE if lcm > LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT for j in range ( i + 1 , len ( primes ) ) : NEW_LINE INDENT q = primes [ j ] NEW_LINE lcm = p * q NEW_LINE if lcm > LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT multlimit = Lcm NEW_LINE multiplier = 1 NEW_LINE while ( multiplier % p == 0 ) : NEW_LINE INDENT multiplier *= p NEW_LINE DEDENT maxMult = multiplier NEW_LINE while ( multiplier % p == 0 ) : NEW_LINE INDENT multiplier *= p NEW_LINE DEDENT maxMult = multiplier NEW_LINE while ( multiplier % p == 0 ) : NEW_LINE INDENT multiplier *= p NEW_LINE DEDENT maxMult = multiplier NEW_LINE DEDENT maxMult = max ( multiplier , maxMult ) NEW_LINE DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10000000 NEW_LINE possible = set ( ) NEW_LINE primes = eulerlib . list_primes ( LIMIT \/\/ 2 ) NEW_LINE end = eulerlib . sqrt ( LIMIT ) NEW_LINE for i in range ( len ( primes ) ) : NEW_LINE INDENT p = primes [ i ] NEW_LINE if p > end : NEW_LINE INDENT break NEW_LINE DEDENT for j in range ( i + 1 , len ( primes ) ) : NEW_LINE INDENT q = primes [ j ] NEW_LINE lcm = p * q NEW_LINE if lcm > LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT multlimit = LIMIT \/\/ lcm NEW_LINE multiplier = 1 NEW_LINE while multiplier * p <= multlimit : NEW_LINE INDENT multiplier *= p NEW_LINE DEDENT maxmult = multiplier NEW_LINE while multiplier % p == 0 : NEW_LINE INDENT multiplier \/\/= p NEW_LINE while multiplier * q <= multlimit : NEW_LINE INDENT multiplier *= q NEW_LINE DEDENT maxmult = max ( multiplier , maxmult ) NEW_LINE DEDENT possible . add ( maxmult * lcm ) NEW_LINE DEDENT DEDENT ans = sum ( possible ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.6522104305207957,"rouge_l":0.7534628016564329}
{"id":1675,"predictions":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT ans = 0 NEW_LINE primes = list_primes ( 2000000 ) NEW_LINE for i in range ( 2 , 1000000 ) : NEW_LINE INDENT p = primes [ i ] NEW_LINE q = primes [ i + 1 ] NEW_LINE k = 1 NEW_LINE while k < p : NEW_LINE INDENT k = k * 10 NEW_LINE DEDENT k = 1 NEW_LINE while k < p : NEW_LINE INDENT k = k * 10 NEW_LINE DEDENT m = ( q - p ) * eulerlib . reciprocal_mod ( k % q , q ) % q NEW_LINE ans += m * k + p NEW_LINE DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT ans = 0 NEW_LINE primes = eulerlib . list_primes ( 2000000 ) NEW_LINE for i in itertools . count ( 2 ) : NEW_LINE INDENT p = primes [ i ] NEW_LINE q = primes [ i + 1 ] NEW_LINE if p > 1000000 : NEW_LINE INDENT break NEW_LINE DEDENT k = 1 NEW_LINE while k < p : NEW_LINE INDENT k *= 10 NEW_LINE DEDENT m = ( q - p ) * eulerlib . reciprocal_mod ( k % q , q ) % q NEW_LINE ans += m * k + p NEW_LINE DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.7991225608628141,"rouge_l":0.8963206770894557}
{"id":1676,"predictions":["class Solution : NEW_LINE INDENT class Solution : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . queue = [ ] [ ] NEW_LINE self . size = len ( self ) NEW_LINE if self . size == 0 : NEW_LINE INDENT return self . size NEW_LINE DEDENT self . queue . append ( None ) NEW_LINE DEDENT self . queue . append ( Node ( sr , sc ) ) NEW_LINE while ( len ( self ) > 0 ) : NEW_LINE INDENT curr = self . pop ( 0 ) NEW_LINE r = curr . next NEW_LINE if ( map [ r ] [ c ] == self . size ) : NEW_LINE INDENT self . queue [ r ] [ c ] = newColor NEW_LINE if ( r - 1 >= 0 ) : NEW_LINE INDENT self . queue . append ( r - 1 , c ) NEW_LINE DEDENT if ( r + 1 >= 0 ) : NEW_LINE INDENT self . queue . append ( ( r + 1 , c ) ) NEW_LINE DEDENT if ( r + 1 >= 0 ) : NEW_LINE INDENT self . queue . append ( ( r + 1 , c ) ) NEW_LINE DEDENT if ( c - 1 >= 0 ) : NEW_LINE INDENT self . queue . put ( ( r , c + 1 ) ) NEW_LINE DEDENT if ( c + 1 < 0 ) : NEW_LINE INDENT self . q . append ( ( ( r , c + 1 ) ) NEW_LINE DEDENT DEDENT DEDENT return self . buffer NEW_LINE DEDENT DEDENT DEDENT"],"references":["class Solution ( object ) : NEW_LINE INDENT def floodFill ( self , image , sr , sc , newColor ) : NEW_LINE INDENT r_ls , c_ls = len ( image ) , len ( image [ 0 ] ) NEW_LINE color = image [ sr ] [ sc ] NEW_LINE if color == newColor : NEW_LINE INDENT return image NEW_LINE DEDENT queue = [ ( sr , sc ) ] NEW_LINE while len ( queue ) > 0 : NEW_LINE INDENT r , c = queue . pop ( 0 ) NEW_LINE if image [ r ] [ c ] == color : NEW_LINE INDENT image [ r ] [ c ] = newColor NEW_LINE if r - 1 >= 0 : queue . append ( ( r - 1 , c ) ) NEW_LINE if r + 1 < r_ls : queue . append ( ( r + 1 , c ) ) NEW_LINE if c - 1 >= 0 : queue . append ( ( r , c - 1 ) ) NEW_LINE if c + 1 < c_ls : queue . append ( ( r , c + 1 ) ) NEW_LINE DEDENT DEDENT return image NEW_LINE DEDENT DEDENT"],"bleu":0.37310550632984435,"rouge_l":0.6365366988648381}
{"id":1677,"predictions":["class Solution ( object ) : NEW_LINE INDENT def thirdMax ( self , nums ) : NEW_LINE INDENT pq = [ ] NEW_LINE nums . append ( i ) NEW_LINE for i in nums : NEW_LINE INDENT if nums . count ( i ) : NEW_LINE INDENT continue NEW_LINE DEDENT pq . append ( i ) NEW_LINE DEDENT if len ( pq ) > 3 : NEW_LINE INDENT set . pop ( ) NEW_LINE DEDENT DEDENT while len ( pq ) < 3 and len ( pq ) > 1 : NEW_LINE INDENT pq . pop ( ) NEW_LINE DEDENT return pq [ 0 ] NEW_LINE DEDENT DEDENT"],"references":["class Solution ( object ) : NEW_LINE INDENT def thirdMax ( self , nums ) : NEW_LINE INDENT import Queue NEW_LINE pq = Queue . PriorityQueue ( 4 ) NEW_LINE check = set ( ) NEW_LINE for n in nums : NEW_LINE INDENT if n in check : NEW_LINE INDENT continue NEW_LINE DEDENT pq . put ( n ) NEW_LINE check . add ( n ) NEW_LINE if len ( check ) > 3 : NEW_LINE INDENT check . remove ( pq . get ( ) ) NEW_LINE DEDENT DEDENT total = len ( check ) NEW_LINE while total < 3 and total > 1 : NEW_LINE INDENT total -= 1 NEW_LINE DEDENT return pq . get ( ) NEW_LINE DEDENT DEDENT"],"bleu":0.4308849674773066,"rouge_l":0.645093062605753}
{"id":1678,"predictions":["class Solution ( object ) : NEW_LINE INDENT def coinKeyAtZero ( self , s , k ) : NEW_LINE INDENT sb = [ ] NEW_LINE for i in range ( 0 , - 1 , - 1 ) : NEW_LINE INDENT if s [ i ] != k + 1 : NEW_LINE INDENT sb . append ( ' - ' ) NEW_LINE DEDENT else : NEW_LINE INDENT sb . append ( ' ' . join ( sb ) ) NEW_LINE DEDENT DEDENT return sb [ DEDENT DEDENT"],"references":["class Solution ( object ) : NEW_LINE INDENT def licenseKeyFormatting ( self , S , K ) : NEW_LINE INDENT S = S . upper ( ) . replace ( ' - ' , ' ' ) NEW_LINE ls = len ( S ) NEW_LINE if ls % K == 0 : NEW_LINE INDENT pos = K NEW_LINE DEDENT else : NEW_LINE INDENT pos = ls % K NEW_LINE DEDENT res = S [ : pos ] NEW_LINE while pos < ls : NEW_LINE INDENT res += ' - ' + S [ pos : pos + K ] NEW_LINE pos += K NEW_LINE DEDENT return res NEW_LINE DEDENT DEDENT"],"bleu":0.23766452845161667,"rouge_l":0.39771801140994284}
{"id":1679,"predictions":["class Queue : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . lst = [ ] NEW_LINE DEDENT DEDENT class Queue : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . lst . append ( t ) NEW_LINE DEDENT return len ( self . lst ) NEW_LINE DEDENT DEDENT"],"references":["class RecentCounter ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . queue = [ ] NEW_LINE DEDENT def ping ( self , t ) : NEW_LINE INDENT self . queue . append ( t ) NEW_LINE while self . queue and self . queue [ 0 ] < t - 3000 : NEW_LINE INDENT self . queue . pop ( 0 ) NEW_LINE DEDENT return len ( self . queue ) NEW_LINE DEDENT DEDENT"],"bleu":0.40016677327789496,"rouge_l":0.625495222558844}
{"id":1680,"predictions":["class Solution ( object ) : NEW_LINE INDENT def uniqueMower ( self , words ) : NEW_LINE INDENT morose = [ \" . \" , \" - \" , \" - \" , \" - \" , \" - \" , \" . \" , \" . \" , \" . \" , \" - \" , \" . \" , \" . \" ] NEW_LINE seen = [ \" . \" , \" - \" , \" - \" , \" - \" , \" - \" , \" . \" , \" - \" , \" . \" , \" . \" , \" - \" , \" . \" , \" . \" , \" \" . \" , \" . \" , \" . \" , \" . \" , \" . \" ] NEW_LINE seen = [ \" . \" , \" - \" , \" - \" , \" - \" , \" - \" , \" - \" , \" \" . \" , \" - - \" , \" - \" , \" - \" , \" - \" , \" - \" , \" . \" , \" - \" , \" - \" , \" - - \" , \" - \" , \" - \" ] NEW_LINE DEDENT return len ( seen ) NEW_LINE DEDENT"],"references":["Morse_tab = [ \" . - \" , \" - . . . \" , \" - . - . \" , \" - . . \" , \" . \" , \" . . - . \" , \" - - . \" , \" . . . . \" , \" . . \" , \" . - - - \" , \" - . - \" , \" . - . . \" , \" - - \" , \" - . \" , \" - - - \" , \" . - - . \" , \" - - . - \" , \" . - . \" , \" . . . \" , \" - \" , \" . . - \" , \" . . . - \" , \" . - - \" , \" - . . - \" , \" - . - - \" , \" - - . . \" ] NEW_LINE class Solution ( object ) : NEW_LINE INDENT def uniqueMorseRepresentations ( self , words ) : NEW_LINE INDENT if len ( words ) == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans_set = set ( ) NEW_LINE for word in words : NEW_LINE INDENT morsed = \" \" NEW_LINE for c in word : NEW_LINE INDENT morsed += Morse_tab [ ord ( c ) - ord ( ' a ' ) ] NEW_LINE DEDENT ans_set . add ( morsed ) NEW_LINE DEDENT return len ( ans_set ) NEW_LINE DEDENT DEDENT"],"bleu":0.44327845750932954,"rouge_l":0.55118004045853}
{"id":1681,"predictions":["class Solution ( object ) : NEW_LINE INDENT def running_sum ( self , nums ) : NEW_LINE INDENT if nums is None or len ( nums ) == 0 : NEW_LINE INDENT return nums NEW_LINE DEDENT for i in range ( 1 , len ( nums ) ) : NEW_LINE INDENT nums [ i ] += nums [ i - 1 ] NEW_LINE DEDENT return nums NEW_LINE DEDENT DEDENT"],"references":["class Solution : NEW_LINE INDENT def runningSum ( self , nums : List [ int ] ) -> List [ int ] : NEW_LINE INDENT if nums is None or len ( nums ) == 0 : NEW_LINE INDENT return nums NEW_LINE DEDENT for i in range ( 1 , len ( nums ) ) : NEW_LINE INDENT nums [ i ] += nums [ i - 1 ] NEW_LINE DEDENT return nums NEW_LINE DEDENT DEDENT"],"bleu":0.782697640284566,"rouge_l":0.8888141672270791}
{"id":1682,"predictions":["class Node : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . data = list ( ) NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def get ( self , key ) : NEW_LINE INDENT i = idx ( key ) NEW_LINE if ( nodes [ i ] == None ) : NEW_LINE INDENT nodes [ i ] = Node ( - 1 , - 1 ) NEW_LINE DEDENT prev = self . find ( key , key ) NEW_LINE if ( prev . next == None ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT prev = self . find ( key , key ) NEW_LINE if ( prev . next is is None ) : NEW_LINE INDENT prev . next = self . get ( key , key ) NEW_LINE DEDENT else : NEW_LINE INDENT prev . next = value NEW_LINE DEDENT DEDENT DEDENT def remove ( self ) : NEW_LINE INDENT i = idx NEW_LINE if ( nodes [ i ] is not None ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( self . keys ( ) ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT prev = self . next NEW_LINE DEDENT DEDENT def remove ( key ) : NEW_LINE INDENT i = idx NEW_LINE if ( self . nodes [ i ] is None ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT prev = self . next NEW_LINE if ( prev . next is None ) : NEW_LINE INDENT return NEW_LINE DEDENT prev = self . next NEW_LINE return prev NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = Node ( ) NEW_LINE nodes = list ( ) NEW_LINE nodes = list ( ) NEW_LINE node = Node ( 0 ) NEW_LINE node = Node ( 0 ) NEW_LINE node . val = Node ( 0 ) NEW_LINE while ( node . data != key ) : NEW_LINE INDENT prev = Node ( node ) NEW_LINE node = node . next NEW_LINE node = node . next NEW_LINE DEDENT"],"references":["class MyHashMap ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . size = 10000 NEW_LINE self . nodes = [ None ] * self . size NEW_LINE DEDENT def put ( self , key , value ) : NEW_LINE INDENT index = hash ( key ) % self . size NEW_LINE if self . nodes [ index ] is None : NEW_LINE INDENT self . nodes [ index ] = ListNode ( - 1 , - 1 ) NEW_LINE DEDENT prev = find ( self . nodes [ index ] , key ) NEW_LINE if prev . next is None : NEW_LINE INDENT prev . next = ListNode ( key , value ) NEW_LINE DEDENT else : NEW_LINE INDENT prev . next . val = value NEW_LINE DEDENT DEDENT def get ( self , key ) : NEW_LINE INDENT index = hash ( key ) % self . size NEW_LINE if self . nodes [ index ] is None : NEW_LINE INDENT return - 1 NEW_LINE DEDENT prev = find ( self . nodes [ index ] , key ) NEW_LINE if prev . next is None : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return prev . next . val NEW_LINE DEDENT DEDENT def remove ( self , key ) : NEW_LINE INDENT index = hash ( key ) % self . size NEW_LINE if self . nodes [ index ] is None : NEW_LINE INDENT return NEW_LINE DEDENT prev = find ( self . nodes [ index ] , key ) NEW_LINE if prev . next is None : NEW_LINE INDENT return NEW_LINE DEDENT prev . next = prev . next . next NEW_LINE DEDENT DEDENT def find ( bucket , key ) : NEW_LINE INDENT node = bucket NEW_LINE prev = None NEW_LINE while node is not None and node . key != key : NEW_LINE INDENT prev = node NEW_LINE node = node . next NEW_LINE DEDENT return prev NEW_LINE DEDENT class ListNode ( ) : NEW_LINE INDENT def __init__ ( self , key , val ) : NEW_LINE INDENT self . key = key NEW_LINE self . val = val NEW_LINE self . next = None NEW_LINE NEW_LINE DEDENT DEDENT"],"bleu":0.4414553212451296,"rouge_l":0.5953617478510028}
{"id":1683,"predictions":["class Node : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . val = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def push ( self , x ) : NEW_LINE INDENT node = dll . next NEW_LINE if x in self . keys ( ) : NEW_LINE INDENT self . map [ x ] . append ( node ) NEW_LINE DEDENT else : NEW_LINE INDENT self . map [ x ] . append ( node ) NEW_LINE DEDENT DEDENT def pop ( self ) : NEW_LINE INDENT val = dll = self . pop ( val ) NEW_LINE if x in self . empty ( ) : NEW_LINE INDENT return val NEW_LINE DEDENT return val NEW_LINE DEDENT def pop ( ) : NEW_LINE INDENT val = self . pop ( val ) NEW_LINE DEDENT def pop ( self ) : NEW_LINE INDENT val = self . pop ( val ) NEW_LINE L = self . pop ( ) NEW_LINE if len ( L ) == 0 : NEW_LINE INDENT return val NEW_LINE DEDENT return val NEW_LINE DEDENT def pop ( self , val ) : NEW_LINE INDENT if len ( L ) > 0 : NEW_LINE INDENT del val NEW_LINE DEDENT return val NEW_LINE DEDENT def pop ( self , val ) : NEW_LINE INDENT return val NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT self . Node ( 0 ) NEW_LINE DEDENT DEDENT"],"references":["class MaxStack ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . stack = [ ] NEW_LINE self . max_stack = [ ] NEW_LINE DEDENT def push ( self , x ) : NEW_LINE INDENT self . stack . append ( x ) NEW_LINE if len ( self . max_stack ) == 0 : NEW_LINE INDENT self . max_stack . append ( x ) NEW_LINE return NEW_LINE DEDENT if self . max_stack [ - 1 ] > x : NEW_LINE INDENT self . max_stack . append ( self . max_stack [ - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT self . max_stack . append ( x ) NEW_LINE DEDENT DEDENT def pop ( self ) : NEW_LINE INDENT if len ( self . stack ) != 0 : NEW_LINE INDENT self . max_stack . pop ( - 1 ) NEW_LINE return self . stack . pop ( - 1 ) NEW_LINE DEDENT DEDENT def top ( self ) : NEW_LINE INDENT return self . stack [ - 1 ] NEW_LINE DEDENT def peekMax ( self ) : NEW_LINE INDENT if len ( self . max_stack ) != 0 : NEW_LINE INDENT return self . max_stack [ - 1 ] NEW_LINE DEDENT DEDENT def popMax ( self ) : NEW_LINE INDENT val = self . peekMax ( ) NEW_LINE buff = [ ] NEW_LINE while self . top ( ) != val : NEW_LINE INDENT buff . append ( self . pop ( ) ) NEW_LINE DEDENT self . pop ( ) NEW_LINE while len ( buff ) != 0 : NEW_LINE INDENT self . push ( buff . pop ( - 1 ) ) NEW_LINE DEDENT return val NEW_LINE DEDENT DEDENT"],"bleu":0.39062637861905186,"rouge_l":0.5224681826406901}
{"id":1684,"predictions":["class Solution ( object ) : NEW_LINE INDENT def canReorderTwo ( self , A ) : NEW_LINE INDENT valueMap = { } NEW_LINE A = { } NEW_LINE for a , b , c in enumerate ( A ) : NEW_LINE INDENT valueMap [ a , b ] = { } NEW_LINE DEDENT for n in A : NEW_LINE INDENT valueMap [ n ] += 1 NEW_LINE DEDENT for n in A : NEW_LINE INDENT valueMap [ n ] += 1 NEW_LINE DEDENT for n in A : NEW_LINE INDENT if ( valueMap [ n ] <= 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( 2 * n ) in valueMap [ 2 * n ] and valueMap [ 2 * n ] > 0 : NEW_LINE INDENT valueMap [ n ] = valueMap [ 2 * n ] - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT DEDENT"],"references":["class Solution ( object ) : NEW_LINE INDENT def canReorderDoubled ( self , A ) : NEW_LINE INDENT v_map = { } NEW_LINE A . sort ( key = lambda x : abs ( x ) ) NEW_LINE for n in A : NEW_LINE INDENT v_map [ n ] = v_map . get ( n , 0 ) + 1 NEW_LINE DEDENT for n in A : NEW_LINE INDENT if v_map [ n ] <= 0 : NEW_LINE INDENT continue NEW_LINE DEDENT if 2 * n in v_map and v_map [ 2 * n ] > 0 : NEW_LINE INDENT v_map [ n ] -= 1 NEW_LINE v_map [ 2 * n ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = Solution ( ) NEW_LINE print s . canReorderDoubled ( [ 3 , 1 , 3 , 6 ] ) NEW_LINE print s . canReorderDoubled ( [ 2 , 1 , 2 , 6 ] ) NEW_LINE print s . canReorderDoubled ( [ 4 , - 2 , 2 , - 4 ] ) NEW_LINE print s . canReorderDoubled ( [ 1 , 2 , 4 , 16 , 8 , 4 ] ) NEW_LINE DEDENT"],"bleu":0.3495160140465709,"rouge_l":0.511273153968653}
{"id":1685,"predictions":["class Solution ( object ) : NEW_LINE INDENT def repeatedNTimes ( self , A ) : NEW_LINE INDENT _map = { } NEW_LINE ans = A [ 0 ] NEW_LINE for n in A : NEW_LINE INDENT count = Hash . get ( n , 0 ) + 1 NEW_LINE if count >= Hash [ ans ] : NEW_LINE INDENT ans = n NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT"],"references":["import collections NEW_LINE class Solution ( object ) : NEW_LINE INDENT def repeatedNTimes ( self , A ) : NEW_LINE INDENT counter = collections . Counter ( A ) NEW_LINE return counter . most_common ( 1 ) [ 0 ] [ 0 ] NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = Solution ( ) NEW_LINE print s . repeatedNTimes ( [ 1 , 2 , 3 , 3 ] ) NEW_LINE print s . repeatedNTimes ( [ 2 , 1 , 2 , 5 , 3 , 2 ] ) NEW_LINE print s . repeatedNTimes ( [ 5 , 1 , 5 , 2 , 5 , 3 , 5 , 4 ] ) NEW_LINE DEDENT"],"bleu":0.16802544669572192,"rouge_l":0.3672951988591348}
{"id":1686,"predictions":["class Solution : NEW_LINE INDENT def smallestNumbersThan ( self , nums ) : NEW_LINE INDENT countList = [ 0 ] * 101 NEW_LINE res = [ 0 ] * 101 NEW_LINE for i in nums : NEW_LINE INDENT countList [ nums [ i ] ] += 1 NEW_LINE DEDENT for i in range ( 1 , 101 ) : NEW_LINE INDENT countList [ i ] += countList [ i - 1 ] NEW_LINE DEDENT for i in range ( 1 , 101 ) : NEW_LINE INDENT countList [ i ] += countList [ i - 1 ] NEW_LINE DEDENT return [ - 1 ] NEW_LINE DEDENT DEDENT"],"references":["class Solution : NEW_LINE INDENT def smallerNumbersThanCurrent ( self , nums : List [ int ] ) -> List [ int ] : NEW_LINE INDENT count_list = [ 0 ] * 101 NEW_LINE for v in nums : NEW_LINE INDENT count_list [ v ] += 1 NEW_LINE DEDENT for i in range ( 1 , 101 ) : NEW_LINE INDENT count_list [ i ] += count_list [ i - 1 ] NEW_LINE DEDENT res = [ ] NEW_LINE for v in nums : NEW_LINE INDENT if v == 0 : NEW_LINE INDENT res . append ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT res . append ( count_list [ v - 1 ] ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT DEDENT"],"bleu":0.40940426425666665,"rouge_l":0.6269182035759538}
{"id":1687,"predictions":["class Solution ( object ) : NEW_LINE INDENT def isenglishSorted ( self , words , word ) : NEW_LINE INDENT for i in range ( len ( words ) ) : NEW_LINE INDENT if order [ order [ i ] ] != i : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT DEDENT"],"references":["class Solution ( object ) : NEW_LINE INDENT def isAlienSorted ( self , words , order ) : NEW_LINE INDENT order_map = { } NEW_LINE for i , v in enumerate ( order ) : NEW_LINE INDENT order_map [ v ] = i NEW_LINE DEDENT def cmp_alien ( x , y ) : NEW_LINE INDENT ls = min ( len ( x ) , len ( y ) ) NEW_LINE index = 0 NEW_LINE while index < ls : NEW_LINE INDENT if x [ index ] != y [ index ] : NEW_LINE INDENT return order_map [ x [ index ] ] - order_map [ y [ index ] ] NEW_LINE DEDENT index += 1 NEW_LINE DEDENT return len ( x ) - len ( y ) NEW_LINE DEDENT pos = 0 NEW_LINE while pos + 1 < len ( words ) : NEW_LINE INDENT if cmp_alien ( words [ pos ] , words [ pos + 1 ] ) > 0 : NEW_LINE INDENT return False NEW_LINE DEDENT pos += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = Solution ( ) NEW_LINE print s . isAlienSorted ( [ \" hello \" , \" leetcode \" ] , \" hlabcdefgijkmnopqrstuvwxyz \" ) NEW_LINE print s . isAlienSorted ( [ \" word \" , \" world \" , \" row \" ] , \" worldabcefghijkmnpqstuvxyz \" ) NEW_LINE print s . isAlienSorted ( [ \" apple \" , \" app \" ] , \" abcdefghijklmnopqrstuvwxyz \" ) NEW_LINE DEDENT"],"bleu":0.014735613915297081,"rouge_l":0.263801987486198}
{"id":1688,"predictions":["class Solution ( object ) : NEW_LINE INDENT def find disappachableNumbers ( self , nums ) : NEW_LINE INDENT return [ int ( nums [ 0 ] ) - 1 for num in range ( len ( nums ) ) ] NEW_LINE DEDENT DEDENT"],"references":["class Solution ( object ) : NEW_LINE INDENT def findDisappearedNumbers ( self , nums ) : NEW_LINE INDENT res = [ ] NEW_LINE if nums : NEW_LINE INDENT n = len ( nums ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT val = abs ( nums [ i ] ) - 1 NEW_LINE if nums [ val ] > 0 : NEW_LINE INDENT nums [ val ] = - nums [ val ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if nums [ i ] > 0 : NEW_LINE INDENT res . append ( i + 1 ) NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT DEDENT"],"bleu":0.10953279950505272,"rouge_l":0.3904367469879519}
{"id":1689,"predictions":["n = int ( input ( ) ) NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return \"0\" NEW_LINE DEDENT hex_map = \"0123456789abcdef \" NEW_LINE if ( num == 0 ) : NEW_LINE INDENT return \"0\" NEW_LINE DEDENT res = \" \"1\" NEW_LINE while ( num != 0 and len ( res ) < 8 ) : NEW_LINE INDENT res = hex_map [ num & 15 ] + res NEW_LINE num = num >> 4 NEW_LINE DEDENT return res NEW_LINE DEDENT"],"references":["class Solution ( object ) : NEW_LINE INDENT def toHex ( self , num ) : NEW_LINE INDENT if num == 0 : NEW_LINE INDENT return '0' NEW_LINE DEDENT mp = '0123456789abcdef ' NEW_LINE ans = ' ' NEW_LINE for _ in range ( 8 ) : NEW_LINE INDENT n = num & 15 NEW_LINE c = mp [ n ] NEW_LINE ans = c + ans NEW_LINE num = num >> 4 NEW_LINE DEDENT return ans . lstrip ( '0' ) NEW_LINE DEDENT DEDENT"],"bleu":0.2841938191167349,"rouge_l":0.5108081791626096}
{"id":1690,"predictions":["class Solution ( object ) : NEW_LINE INDENT def kStrongestRows ( self , mat , k ) : NEW_LINE INDENT res = [ ] NEW_LINE col = 0 NEW_LINE flag = True NEW_LINE while col < len ( mat [ 0 ] ) and flag : NEW_LINE INDENT for i in range ( col ) : NEW_LINE INDENT if i in res : NEW_LINE INDENT continue NEW_LINE DEDENT if ( res [ i ] [ col ] == 0 ) : NEW_LINE INDENT res . append ( i ) NEW_LINE DEDENT if ( len ( res ) == k ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT col += 1 NEW_LINE DEDENT if ( flag ) : NEW_LINE INDENT for i in range ( len ( mat ) ) : NEW_LINE INDENT if i in res : NEW_LINE INDENT continue NEW_LINE DEDENT res . append ( i ) NEW_LINE if ( len ( res ) == k ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT DEDENT"],"references":["class Solution ( object ) : NEW_LINE INDENT def kWeakestRows ( self , mat , k ) : NEW_LINE INDENT res = [ ] NEW_LINE num_row = len ( mat ) NEW_LINE num_col = len ( mat [ 0 ] ) NEW_LINE col = 0 NEW_LINE flag = 1 NEW_LINE while col < num_col and flag : NEW_LINE INDENT for i in range ( num_row ) : NEW_LINE INDENT if i in res : NEW_LINE INDENT continue NEW_LINE DEDENT if mat [ i ] [ col ] == 0 : NEW_LINE INDENT res . append ( i ) NEW_LINE DEDENT if len ( res ) == k : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT DEDENT col += 1 NEW_LINE DEDENT if len ( res ) == k : NEW_LINE INDENT return res NEW_LINE DEDENT for i in range ( num_row ) : NEW_LINE INDENT if i in res : NEW_LINE INDENT continue NEW_LINE DEDENT res . append ( i ) NEW_LINE if len ( res ) == k : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT DEDENT"],"bleu":0.7336882912048092,"rouge_l":0.8401897290887531}
{"id":1691,"predictions":["class Solution ( object ) : NEW_LINE INDENT def flipAndInvertImage ( self , A [ 0 ] ) : NEW_LINE INDENT C = len ( A [ 0 ] ) NEW_LINE for row in A : NEW_LINE INDENT row = row [ row ] ^ 1 NEW_LINE row [ row ] = row [ C - 1 - i ] ^ 1 NEW_LINE DEDENT return row NEW_LINE DEDENT DEDENT"],"references":["class Solution ( object ) : NEW_LINE INDENT def flipAndInvertImage ( self , A ) : NEW_LINE INDENT for row in A : NEW_LINE INDENT for i in xrange ( ( len ( row ) + 1 ) \/ 2 ) : NEW_LINE INDENT row [ i ] , row [ ~ i ] = row [ ~ i ] ^ 1 , row [ i ] ^ 1 NEW_LINE DEDENT DEDENT return A NEW_LINE DEDENT DEDENT"],"bleu":0.4515472341833144,"rouge_l":0.6239715365799421}
{"id":1692,"predictions":["class Solution ( object ) : NEW_LINE INDENT def sortedSquares ( self , A ) : NEW_LINE INDENT pos = [ 0 ] * len ( A ) NEW_LINE while pos < len ( A ) and A [ pos ] < 0 : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT npos = pos - 1 NEW_LINE while pos < len ( A ) and npos >= 0 : NEW_LINE INDENT if A [ pos ] * A [ pos ] < A [ pos ] : NEW_LINE INDENT res [ curr ] = A [ pos ] * A [ pos ] NEW_LINE pos += 1 NEW_LINE DEDENT else : NEW_LINE INDENT res [ curr ] = A [ pos ] * A [ pos ] NEW_LINE pos += 1 NEW_LINE npos -= 1 NEW_LINE DEDENT DEDENT while npos >= 0 : NEW_LINE INDENT res [ curr ] = A [ npos ] * A [ npos ] NEW_LINE npos -= 1 NEW_LINE DEDENT return res NEW_LINE DEDENT DEDENT"],"references":["class Solution ( object ) : NEW_LINE INDENT def sortedSquares ( self , A ) : NEW_LINE INDENT pos = 0 NEW_LINE while pos < len ( A ) and A [ pos ] < 0 : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT npos = pos - 1 NEW_LINE res = [ ] NEW_LINE while pos < len ( A ) and npos >= 0 : NEW_LINE INDENT if A [ npos ] ** 2 < A [ pos ] ** 2 : NEW_LINE INDENT res . append ( A [ npos ] ** 2 ) NEW_LINE npos -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT res . append ( A [ pos ] ** 2 ) NEW_LINE pos += 1 NEW_LINE DEDENT DEDENT while npos >= 0 : NEW_LINE INDENT res . append ( A [ npos ] ** 2 ) NEW_LINE npos -= 1 NEW_LINE DEDENT while pos < len ( A ) : NEW_LINE INDENT res . append ( A [ pos ] ** 2 ) NEW_LINE pos += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT DEDENT"],"bleu":0.6552371578513995,"rouge_l":0.7025822032323983}
{"id":1693,"predictions":["class Solution ( object ) : NEW_LINE INDENT def posangad ( self , a ) : NEW_LINE INDENT return ' ' . join ( a ) NEW_LINE DEDENT DEDENT"],"references":["class Solution : NEW_LINE INDENT def defangIPaddr ( self , address : str ) -> str : NEW_LINE INDENT return address . replace ( ' . ' , ' [ . ] ' ) NEW_LINE DEDENT DEDENT"],"bleu":0.2684947673073018,"rouge_l":0.6227515799708313}
{"id":1694,"predictions":["class Solution ( object ) : NEW_LINE INDENT def searchBST ( self , root , val ) : NEW_LINE INDENT while root is not None and root . val != val : NEW_LINE INDENT root = root . left NEW_LINE DEDENT return root NEW_LINE DEDENT DEDENT"],"references":["class Solution ( object ) : NEW_LINE INDENT def searchBST ( self , root , val ) : NEW_LINE INDENT while root : NEW_LINE INDENT if root . val == val : NEW_LINE INDENT return root NEW_LINE DEDENT elif root . val > val : NEW_LINE INDENT root = root . left NEW_LINE DEDENT else : NEW_LINE INDENT root = root . right NEW_LINE DEDENT DEDENT return root NEW_LINE DEDENT DEDENT"],"bleu":0.4661504192997032,"rouge_l":0.6748515920129519}
{"id":1695,"predictions":["class Solution : NEW_LINE INDENT def ipToCID ( self ) : NEW_LINE INDENT ans = [ ] NEW_LINE ans = [ ] NEW_LINE while n > 0 : NEW_LINE INDENT mask = max ( 33 - bit_length ( start ) , 32 - bit_length ( n ) ) NEW_LINE ans . append ( x ) NEW_LINE start += 1 << ( 32 - mask ) NEW_LINE n -= 1 << ( 32 - mask ) NEW_LINE n -= 1 << ( 32 - mask ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT"],"references":["class Solution ( object ) : NEW_LINE INDENT def ipToInt ( self , ip ) : NEW_LINE INDENT ans = 0 NEW_LINE for x in ip . split ( ' . ' ) : NEW_LINE INDENT ans = 256 * ans + int ( x ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def intToIP ( self , x ) : NEW_LINE INDENT return \" . \" . join ( str ( ( x >> i ) % 256 ) for i in ( 24 , 16 , 8 , 0 ) ) NEW_LINE DEDENT def ipToCIDR ( self , ip , n ) : NEW_LINE INDENT start = self . ipToInt ( ip ) NEW_LINE ans = [ ] NEW_LINE while n : NEW_LINE INDENT mask = max ( 33 - ( start & - start ) . bit_length ( ) , 33 - n . bit_length ( ) ) NEW_LINE ans . append ( self . intToIP ( start ) + ' \/ ' + str ( mask ) ) NEW_LINE start += 1 << ( 32 - mask ) NEW_LINE n -= 1 << ( 32 - mask ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT"],"bleu":0.21271521254884226,"rouge_l":0.4787865931268562}
{"id":1696,"predictions":["class Solution ( object ) : NEW_LINE INDENT def diameterOfBinaryTree ( self , root ) : NEW_LINE INDENT ans = 1 NEW_LINE depth = depth ( root . left ) NEW_LINE ans = max ( ans , L + R + 1 ) NEW_LINE return ans - 1 NEW_LINE DEDENT DEDENT"],"references":["class Solution ( object ) : NEW_LINE INDENT def diameterOfBinaryTree ( self , root ) : NEW_LINE INDENT self . ans = 1 NEW_LINE def depth ( node ) : NEW_LINE INDENT if not node : return 0 NEW_LINE L = depth ( node . left ) NEW_LINE R = depth ( node . right ) NEW_LINE self . ans = max ( self . ans , L + R + 1 ) NEW_LINE return max ( L , R ) + 1 NEW_LINE DEDENT depth ( root ) NEW_LINE return self . ans - 1 NEW_LINE DEDENT DEDENT"],"bleu":0.3059012747823292,"rouge_l":0.6302955156023972}
{"id":1697,"predictions":["class Solution ( object ) : NEW_LINE INDENT def findSecondMinimumValue ( self , root ) : NEW_LINE INDENT if root is None : NEW_LINE INDENT return - 1 NEW_LINE DEDENT stack = [ ] NEW_LINE min_val = root . val NEW_LINE stack . append ( root ) NEW_LINE while len ( stack ) > 0 : NEW_LINE INDENT node = stack . pop ( 0 ) NEW_LINE if node is None : NEW_LINE INDENT continue NEW_LINE DEDENT if node . val < ans and node . val > min_val : NEW_LINE INDENT ans = node . val NEW_LINE DEDENT elif node . val == min_val : NEW_LINE INDENT stack . append ( node . left ) NEW_LINE stack . append ( node . right ) NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT DEDENT"],"references":["class Solution ( object ) : NEW_LINE INDENT def findSecondMinimumValue ( self , root ) : NEW_LINE INDENT if not root : NEW_LINE INDENT return - 1 NEW_LINE DEDENT ans = float ( ' inf ' ) NEW_LINE min_val = root . val NEW_LINE stack = [ root ] NEW_LINE while stack : NEW_LINE INDENT curr = stack . pop ( ) NEW_LINE if not curr : NEW_LINE INDENT continue NEW_LINE DEDENT if min_val < curr . val < ans : NEW_LINE INDENT ans = curr . val NEW_LINE DEDENT elif curr . val == min_val : NEW_LINE INDENT stack . append ( curr . left ) NEW_LINE stack . append ( curr . right ) NEW_LINE DEDENT DEDENT return ans if ans < float ( ' inf ' ) else - 1 NEW_LINE DEDENT DEDENT"],"bleu":0.5918599172800263,"rouge_l":0.769342711617754}
{"id":1698,"predictions":["class Solution ( object ) : NEW_LINE INDENT def removeNthFromEnd ( self , head , n ) : NEW_LINE INDENT slow = None NEW_LINE fast = None NEW_LINE while fast : NEW_LINE INDENT fast = fast . next NEW_LINE DEDENT if fast == None : NEW_LINE INDENT head = slow . next NEW_LINE DEDENT while fast : NEW_LINE INDENT fast = fast . next NEW_LINE slow = slow . next NEW_LINE DEDENT curr = slow . next NEW_LINE slow . next = curr . next NEW_LINE return head NEW_LINE DEDENT DEDENT"],"references":["class Solution ( object ) : NEW_LINE INDENT def removeNthFromEnd ( self , head , n ) : NEW_LINE INDENT if head is None : NEW_LINE INDENT return None NEW_LINE DEDENT slow = fast = head NEW_LINE for i in range ( n ) : NEW_LINE INDENT fast = fast . next NEW_LINE DEDENT if fast is None : NEW_LINE INDENT head = head . next NEW_LINE return head NEW_LINE DEDENT while fast . next is not None : NEW_LINE INDENT fast = fast . next NEW_LINE slow = slow . next NEW_LINE DEDENT curr = slow . next NEW_LINE slow . next = curr . next NEW_LINE return head NEW_LINE DEDENT DEDENT"],"bleu":0.6413306921988295,"rouge_l":0.8078196437017185}
