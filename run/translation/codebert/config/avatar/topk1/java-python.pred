{"id":0,"predictions":["a , b = map ( int , input ( ) . split ( ) ) NEW_LINE ans = max ( a , b ) NEW_LINE print ( ans ) NEW_LINE"],"references":["x , y = map ( int , str ( input ( ) ) . split ( ' ▁ ' ) ) NEW_LINE print ( ' { } ' . format ( x if x > y else y ) ) NEW_LINE"],"bleu":0.26705882420117527,"rouge_l":0.5067774376912987}
{"id":1,"predictions":["s = input ( ) NEW_LINE if len ( s ) == 26 : NEW_LINE INDENT print ( s [ 0 ] ) NEW_LINE sys . exit ( ) NEW_LINE DEDENT elif len ( s ) > 26 : NEW_LINE INDENT if len ( set ( s [ i ] ) > 26 : NEW_LINE INDENT print ( s [ 0 : i ] + s [ i ] ) NEW_LINE exit ( ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( 26 , 26 + 1 ) : NEW_LINE INDENT if ord ( s [ i ] ) - ord ( s [ i ] ) > ord ( s [ i ] ) - ord ( ' z ' ) : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT print ( ord ( s [ ord ( s [ i ] ) - ord ( ' a ' ) ] ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT"],"references":["s = input ( ) NEW_LINE if len ( s ) != 26 : NEW_LINE INDENT se = set ( [ ] ) NEW_LINE for w in s : NEW_LINE INDENT se . add ( w ) NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT w = chr ( ord ( ' a ' ) + i ) NEW_LINE if w not in se : NEW_LINE INDENT print ( s + w ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT DEDENT if s == \" zyxwvutsrqponmlkjihgfedcba \" : NEW_LINE INDENT print ( - 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT se = set ( [ ] ) NEW_LINE for i in reversed ( range ( 26 ) ) : NEW_LINE INDENT se . add ( s [ i ] ) NEW_LINE for j in range ( ord ( s [ i ] ) - ord ( ' a ' ) + 1 , 26 ) : NEW_LINE INDENT if chr ( ord ( ' a ' ) + j ) in se : NEW_LINE INDENT print ( s [ : i ] + chr ( ord ( ' a ' ) + j ) ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT DEDENT"],"bleu":0.4182253612304912,"rouge_l":0.5678859779205799}
{"id":2,"predictions":["n , t = map ( int , input ( ) . split ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE temp = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] > A [ i - 1 ] : NEW_LINE INDENT temp += T NEW_LINE DEDENT else : NEW_LINE INDENT ans += T NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["def getInt ( ) : return int ( input ( ) ) NEW_LINE def getIntList ( ) : return [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE def dmp ( x ) : NEW_LINE INDENT global debug NEW_LINE if debug : NEW_LINE INDENT print ( x ) NEW_LINE DEDENT DEDENT def probC ( ) : NEW_LINE INDENT N , T = getIntList ( ) NEW_LINE Ts = getIntList ( ) NEW_LINE dmp ( ( N , T , Ts ) ) NEW_LINE total = Ts [ 0 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT total += min ( T , Ts [ i ] - Ts [ i - 1 ] ) NEW_LINE DEDENT return total + T NEW_LINE DEDENT debug = False NEW_LINE print ( probC ( ) ) NEW_LINE"],"bleu":0.16834366019653085,"rouge_l":0.4126082251082251}
{"id":3,"predictions":["n = int ( input ( ) ) NEW_LINE if n % 2 == 0 : NEW_LINE INDENT ans = n + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = n + 1 NEW_LINE DEDENT print ( ans ) NEW_LINE"],"references":["n = int ( input ( ) ) NEW_LINE if n % 2 == 0 : NEW_LINE INDENT print ( n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n + 1 ) NEW_LINE DEDENT"],"bleu":0.624900904097619,"rouge_l":0.7902214793146678}
{"id":4,"predictions":["n = int ( input ( ) ) NEW_LINE k = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( string [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE"],"references":["import math NEW_LINE def main ( ) : NEW_LINE INDENT [ K , N ] = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE r = [ ] NEW_LINE if K == 1 : NEW_LINE INDENT r = [ 1 ] * ( ( N + 1 ) \/\/ 2 ) NEW_LINE DEDENT elif K % 2 == 0 : NEW_LINE INDENT r = [ K \/\/ 2 ] NEW_LINE r += [ K ] * ( N - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT t = N \/\/ 2 NEW_LINE x = int ( math . log ( N * ( K - 1 ) + 1 , K ) - 1 ) NEW_LINE while t < ( ( K ** ( x + 1 ) - 1 ) \/ ( K - 1 ) + x ) \/\/ 2 : NEW_LINE INDENT x -= 1 NEW_LINE DEDENT x += 1 NEW_LINE r = [ ( K + 1 ) \/\/ 2 ] * ( N - x ) NEW_LINE r += [ 0 ] * x NEW_LINE t = ( ( K ** ( x + 1 ) - 1 ) \/ ( K - 1 ) + x ) \/\/ 2 - t NEW_LINE for i in range ( x , 0 , - 1 ) : NEW_LINE INDENT r [ N - i ] = 1 NEW_LINE t -= 1 NEW_LINE for j in range ( K - 1 ) : NEW_LINE INDENT if t == 0 : NEW_LINE INDENT break NEW_LINE DEDENT if K ** i - 1 <= t * ( K - 1 ) : NEW_LINE INDENT r [ N - i ] += 1 NEW_LINE t -= ( K ** i - 1 ) \/\/ ( K - 1 ) NEW_LINE DEDENT DEDENT if t == 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in range ( len ( r ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if r [ i ] == 0 : NEW_LINE INDENT r . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT print ( ' ▁ ' . join ( list ( map ( str , r ) ) ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"bleu":0.00017549373210340013,"rouge_l":0.14228077917165732}
{"id":5,"predictions":["x , y = map ( int , input ( ) . split ( ) ) NEW_LINE print ( \" Yay ! \" if x else \" Yay ! \" ) NEW_LINE"],"references":["A , B = map ( int , input ( ) . split ( ) ) NEW_LINE if A <= 8 and B <= 8 : NEW_LINE INDENT print ( ' Yay ! ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' : ( ' ) NEW_LINE DEDENT"],"bleu":0.28748740822275126,"rouge_l":0.5161538461538462}
{"id":6,"predictions":["def gcd ( a , b ) : NEW_LINE INDENT return ( b * a + 1 ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n , a , b = map ( int , input ( ) . split ( ' ▁ ' ) ) NEW_LINE fromkeys ( a , b ) NEW_LINE if n == 1 : NEW_LINE INDENT return n NEW_LINE DEDENT f = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT *= a NEW_LINE DEDENT f = [ 0 ] * ( n - 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT f [ i ] = f [ i - 1 ] * f [ i + 1 ] NEW_LINE DEDENT return f [ n - 1 ] * n NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE A -= 1 NEW_LINE B = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( b ) : NEW_LINE INDENT db ( a , b ) NEW_LINE if i == n - 1 : NEW_LINE INDENT f = i NEW_LINE break NEW_LINE DEDENT DEDENT return f NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT fromkeys ( map ( int , input ( ) . split ( ) ) ) NEW_LINE INDENT db = iterate ( map ( int , input ( ) . split ( ) ) ) NEW_LINE DEDENT print ( f . values ( ) ) NEW_LINE DEDENT"],"references":["import heapq NEW_LINE N , A , B = map ( int , input ( ) . split ( ) ) NEW_LINE src = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if A == 1 : NEW_LINE INDENT for v in sorted ( src ) : NEW_LINE INDENT print ( v ) NEW_LINE DEDENT exit ( ) NEW_LINE DEDENT mem = [ ] NEW_LINE maxv = 0 NEW_LINE for i , v in enumerate ( src ) : NEW_LINE INDENT mem . append ( ( v , i ) ) NEW_LINE if v > maxv : maxv = v NEW_LINE DEDENT heapq . heapify ( mem ) NEW_LINE while True : NEW_LINE INDENT v , i = heapq . heappop ( mem ) NEW_LINE if B == 0 or ( v * A > maxv and B % N == 0 ) : NEW_LINE INDENT heapq . heappush ( mem , ( v , i ) ) NEW_LINE break NEW_LINE DEDENT maxv = max ( maxv , v * A ) NEW_LINE heapq . heappush ( mem , ( v * A , i ) ) NEW_LINE B -= 1 NEW_LINE DEDENT MOD = 10 ** 9 + 7 NEW_LINE p = pow ( A , B \/\/ N , MOD ) NEW_LINE while mem : NEW_LINE INDENT v , i = heapq . heappop ( mem ) NEW_LINE print ( ( v * p ) % MOD ) NEW_LINE DEDENT"],"bleu":0.23557503861036905,"rouge_l":0.3771251931993818}
{"id":7,"predictions":["m , n = map ( int , input ( ) . split ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT if m + l [ i ] >= m : NEW_LINE INDENT l . append ( n % m ) NEW_LINE DEDENT DEDENT print ( n \/\/ m ) NEW_LINE"],"references":["m , n , N = [ int ( _ ) for _ in input ( ) . split ( ) ] NEW_LINE result = N NEW_LINE s = N NEW_LINE while s >= m : NEW_LINE INDENT x , s = divmod ( s , m ) NEW_LINE s += x * n NEW_LINE result += x * n NEW_LINE DEDENT print ( result ) NEW_LINE"],"bleu":0.2445189731999441,"rouge_l":0.4618879353861686}
{"id":8,"predictions":["w , h = map ( int , input ( ) . split ( ) ) NEW_LINE x , y = map ( int , input ( ) . split ( ) ) NEW_LINE if x < y : NEW_LINE INDENT x , y = x , y NEW_LINE DEDENT elif y > x : NEW_LINE INDENT if y < x : NEW_LINE INDENT y = y NEW_LINE DEDENT else : NEW_LINE INDENT x = x NEW_LINE DEDENT DEDENT if x < 4 : NEW_LINE INDENT y = y NEW_LINE DEDENT if y == 4 : NEW_LINE INDENT if y < y : NEW_LINE INDENT y = y NEW_LINE DEDENT elif y > y : NEW_LINE INDENT y = y NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if y < 4 : NEW_LINE INDENT y = y NEW_LINE DEDENT DEDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT"],"references":["w , h , n = map ( int , input ( ) . split ( ) ) NEW_LINE x1 = [ ] NEW_LINE x2 = [ ] NEW_LINE y3 = [ ] NEW_LINE y4 = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT x , y , a = map ( int , input ( ) . split ( ) ) NEW_LINE if a == 1 : NEW_LINE INDENT x1 . append ( x ) NEW_LINE DEDENT elif a == 2 : NEW_LINE INDENT x2 . append ( x ) NEW_LINE DEDENT elif a == 3 : NEW_LINE INDENT y3 . append ( y ) NEW_LINE DEDENT else : NEW_LINE INDENT y4 . append ( y ) NEW_LINE DEDENT DEDENT for t in [ x1 , y3 ] : NEW_LINE INDENT if not t : NEW_LINE INDENT t . append ( 0 ) NEW_LINE DEDENT DEDENT if not x2 : NEW_LINE INDENT x2 . append ( w ) NEW_LINE DEDENT if not y4 : NEW_LINE INDENT y4 . append ( h ) NEW_LINE DEDENT if max ( x1 ) >= min ( x2 ) or max ( y3 ) >= min ( y4 ) : NEW_LINE INDENT print ( 0 ) NEW_LINE exit ( ) NEW_LINE DEDENT print ( ( min ( x2 ) - max ( x1 ) ) * ( min ( y4 ) - max ( y3 ) ) ) NEW_LINE"],"bleu":0.25559936499090724,"rouge_l":0.4426634768740031}
{"id":9,"predictions":["s = input ( ) NEW_LINE l = len ( s ) NEW_LINE if ( s [ 0 ] != s [ - 1 ] ) : NEW_LINE INDENT print ( \" First \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" First \" ) NEW_LINE DEDENT"],"references":["S = input ( ) NEW_LINE if S [ 0 ] == S [ - 1 ] : NEW_LINE INDENT if len ( S ) % 2 == 0 : NEW_LINE INDENT print ( \" First \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Second \" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if len ( S ) % 2 == 1 : NEW_LINE INDENT print ( \" First \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Second \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.2857727931204892,"rouge_l":0.5054871220604703}
{"id":10,"predictions":["s = input ( ) NEW_LINE lO = len ( s ) NEW_LINE ans = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( j % 2 == 1 ) : NEW_LINE INDENT ans += s [ lOoIndex ] [ j ] NEW_LINE DEDENT lOo += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["print ( ( lambda S : sum ( eval ( ' ' . join ( ' ' . join ( i ) for i in zip ( S , ( [ ' ' , ' + ' ] [ int ( i ) ] for i in ' { :0 > { } b } 0' . format ( i , len ( S ) - 1 ) ) ) ) ) for i in range ( 1 << len ( S ) - 1 ) ) ) ( input ( ) ) ) NEW_LINE"],"bleu":0.10151920927880911,"rouge_l":0.255862726406101}
{"id":11,"predictions":["import math NEW_LINE from fractions import gcd NEW_LINE def gcd ( x , y ) : NEW_LINE INDENT if y == gcd ( x , y ) : NEW_LINE INDENT return math . gcd ( x , y ) NEW_LINE DEDENT else : NEW_LINE INDENT return math . gcd ( y , x % gcd , y ) ) NEW_LINE DEDENT DEDENT n = int ( input ( ) ) NEW_LINE gcd ( n , n ) NEW_LINE print ( solve ( n , 2 ) ) NEW_LINE"],"references":["N , M = ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE S = input ( ) NEW_LINE T = input ( ) NEW_LINE def gcd ( x , y ) : NEW_LINE INDENT x , y = min ( x , y ) , max ( x , y ) NEW_LINE if y % x == 0 : NEW_LINE INDENT return x NEW_LINE DEDENT return gcd ( x , y % x ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT if S [ 0 ] != T [ 0 ] : NEW_LINE INDENT return - 1 NEW_LINE DEDENT g = gcd ( N , M ) NEW_LINE n = N \/\/ g NEW_LINE m = M \/\/ g NEW_LINE for i in range ( g ) : NEW_LINE INDENT if S [ n * i ] != T [ m * i ] : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT return N * M \/\/ g NEW_LINE DEDENT print ( main ( ) ) NEW_LINE"],"bleu":0.15085255101925507,"rouge_l":0.3654377880184332}
{"id":12,"predictions":["set = int ( input ( ) ) NEW_LINE count = 0 NEW_LINE l = [ ] NEW_LINE for i in range ( len ( set ( l ) ) ) : NEW_LINE INDENT if l [ i ] not in l [ i ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE"],"references":["print ( len ( set ( map ( int , input ( ) . split ( ) ) ) ) ) NEW_LINE"],"bleu":0.1470482953593026,"rouge_l":0.29598588442876045}
{"id":13,"predictions":["s = input ( ) NEW_LINE result = \" \" NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] != ' ' : NEW_LINE INDENT result += s [ i ] NEW_LINE DEDENT DEDENT print ( points ) NEW_LINE"],"references":["a , b , c = input ( ) . split ( ' , ' ) NEW_LINE print ( a , b , c ) NEW_LINE"],"bleu":0.10155891129087555,"rouge_l":0.3387320684868117}
{"id":14,"predictions":["x , y = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE for x in range ( y ) : NEW_LINE INDENT *= 2 NEW_LINE ans += 1 NEW_LINE DEDENT print ( ans ) NEW_LINE"],"references":["x , y = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 1 NEW_LINE a = x NEW_LINE for _ in range ( 61 ) : NEW_LINE INDENT a *= 2 NEW_LINE if a <= y : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"bleu":0.4679699173068613,"rouge_l":0.7347238542890717}
{"id":15,"predictions":["def solve ( ) : NEW_LINE INDENT i = 0 NEW_LINE j = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT ali [ i ] = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE DEDENT ali = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ali [ i ] > ali [ j - 1 ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = 0 NEW_LINE DEDENT DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ali [ i ] > 0 and ali [ i ] > ar [ i ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["from sys import exit , setrecursionlimit NEW_LINE from itertools import product NEW_LINE def read ( ) : NEW_LINE INDENT return int ( input ( ) ) NEW_LINE DEDENT def reads ( ) : NEW_LINE INDENT return [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE DEDENT def argmin ( ll ) : NEW_LINE INDENT ll = list ( ll ) NEW_LINE return ll . index ( min ( ll ) ) NEW_LINE DEDENT setrecursionlimit ( 1000000 ) NEW_LINE ( N , K ) = reads ( ) NEW_LINE parent = [ x - 1 for x in reads ( ) ] NEW_LINE result = 0 NEW_LINE if parent [ 0 ] != 0 : NEW_LINE INDENT parent [ 0 ] = 0 NEW_LINE result += 1 NEW_LINE DEDENT children = [ [ ] for _ in range ( N ) ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT children [ parent [ i ] ] . append ( i ) NEW_LINE DEDENT color = [ 0 ] * N NEW_LINE def walk ( i ) : NEW_LINE INDENT global result NEW_LINE for x in children [ i ] : NEW_LINE INDENT walk ( x ) NEW_LINE if color [ x ] == 1 and parent [ x ] != 0 : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT color [ i ] = min ( [ K ] + [ color [ x ] - 1 for x in children [ i ] if color [ x ] >= 2 ] ) NEW_LINE DEDENT walk ( 0 ) NEW_LINE print ( result ) NEW_LINE"],"bleu":0.1753175559612157,"rouge_l":0.3874655939021808}
{"id":16,"predictions":["import sys NEW_LINE input = sys . stdin . readline NEW_LINE sys . setrecursionlimit ( 10 ** 5 ) NEW_LINE N , M = map ( int , input ( ) . split ( ) ) NEW_LINE l = map ( int , input ( ) . split ( ) ) NEW_LINE RC = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] NEW_LINE RC = [ [ 0 ] * ( N + 1 ) for _ in range ( N + 1 ) ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT for j in range ( 1 , N + 1 ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE L [ j - 1 ] -= 1 NEW_LINE DEDENT DEDENT for i in range ( N + 1 ) : NEW_LINE INDENT for j in range ( N + 1 ) : NEW_LINE INDENT if i + 1 >= N : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( len ( res ) ) NEW_LINE DEDENT"],"references":["from itertools import accumulate NEW_LINE N , M , Q = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ [ 0 ] * ( N + 1 ) for i in range ( N + 1 ) ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT L , R = map ( int , input ( ) . split ( ) ) NEW_LINE a [ L ] [ R ] += 1 NEW_LINE DEDENT b = [ list ( accumulate ( a [ i ] ) ) for i in range ( N + 1 ) ] NEW_LINE k = [ [ b [ j ] [ i ] for j in range ( i + 1 ) ] for i in range ( N + 1 ) ] NEW_LINE ans = [ list ( accumulate ( reversed ( k [ i ] ) ) ) [ : : - 1 ] for i in range ( N + 1 ) ] NEW_LINE for i in range ( Q ) : NEW_LINE INDENT p , q = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ans [ q ] [ p - q - 1 ] ) NEW_LINE DEDENT"],"bleu":0.4916688807281837,"rouge_l":0.49516078676241015}
{"id":17,"predictions":["n , m , x = map ( int , input ( ) . split ( ) ) ; a = list ( map ( int , input ( ) . split ( ) ) ) ; a = [ 0 ] * ( n + 1 ) ; for i in range ( x , n + 1 ) : a [ i ] += a [ i - 1 ] ; print ( min ( a ) , sep = ' ' ) NEW_LINE"],"references":["N , M , X = ( int ( x ) for x in input ( ) . split ( ) ) NEW_LINE A = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE Z = [ 0 ] * N NEW_LINE for a in A : NEW_LINE INDENT Z [ a ] = 1 NEW_LINE DEDENT lower = 0 NEW_LINE for i in range ( 0 , X + 1 ) : NEW_LINE INDENT lower += Z [ i ] NEW_LINE DEDENT higher = 0 NEW_LINE for i in range ( X , N ) : NEW_LINE INDENT higher += Z [ i ] NEW_LINE DEDENT print ( min ( lower , higher ) ) NEW_LINE"],"bleu":0.22567760962276792,"rouge_l":0.4769924812030075}
{"id":18,"predictions":["def main ( ) : NEW_LINE"],"references":["import sys NEW_LINE from collections import deque NEW_LINE def dfs ( edges , start ) : NEW_LINE INDENT visited = [ 0 ] * len ( edges ) NEW_LINE visited [ start ] = 1 NEW_LINE ans , dist = 0 , 0 NEW_LINE stack = deque ( [ ( start , 0 ) ] ) NEW_LINE pop , append = stack . pop , stack . append NEW_LINE while stack : NEW_LINE INDENT v , _dist = pop ( ) NEW_LINE if _dist > dist : NEW_LINE INDENT ans , dist = v , _dist NEW_LINE DEDENT for e in edges [ v ] : NEW_LINE INDENT if visited [ e ] : NEW_LINE INDENT continue NEW_LINE DEDENT visited [ e ] = 1 NEW_LINE append ( ( e , _dist + 1 ) ) NEW_LINE DEDENT DEDENT return ans , dist NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE edges = [ [ ] for _ in [ 0 ] * N ] NEW_LINE for ( a , b ) in ( map ( int , l . split ( ) ) for l in sys . stdin ) : NEW_LINE INDENT edges [ a - 1 ] . append ( b - 1 ) NEW_LINE edges [ b - 1 ] . append ( a - 1 ) NEW_LINE DEDENT v , _ = dfs ( edges , 0 ) NEW_LINE print ( v + 1 , dfs ( edges , v ) [ 0 ] + 1 ) NEW_LINE DEDENT"],"bleu":3.9538481094417927e-20,"rouge_l":0.03708206686930091}
{"id":19,"predictions":["from fractions import gcd NEW_LINE t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT a , b , d = map ( int , input ( ) . split ( ) ) NEW_LINE if a > b : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT elif b > d : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT DEDENT"],"references":["T = int ( input ( ) ) NEW_LINE ABCD = [ [ int ( _ ) for _ in input ( ) . split ( ) ] for _ in range ( T ) ] NEW_LINE def gcd ( x , y ) : NEW_LINE INDENT if x < y : NEW_LINE INDENT return gcd ( y , x ) NEW_LINE DEDENT elif x % y == 0 : NEW_LINE INDENT return y NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( y , x % y ) NEW_LINE DEDENT DEDENT for a , b , c , d in ABCD : NEW_LINE INDENT if a < b or d < b : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT else : NEW_LINE INDENT g = gcd ( b , d ) NEW_LINE x = g * ( c \/\/ g ) + ( a % g ) NEW_LINE if x <= c : NEW_LINE INDENT x += g NEW_LINE DEDENT if x >= b : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE NEW_LINE DEDENT DEDENT DEDENT"],"bleu":0.18381953630579645,"rouge_l":0.39912758996728465}
{"id":20,"predictions":["N , K = map ( int , input ( ) . split ( ) ) NEW_LINE if K == 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT for _ in range ( N ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a == 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT ans = [ n * ( K + 3 ) for _ in range ( N ) ] NEW_LINE for r in range ( N ) : NEW_LINE INDENT for c in range ( 0 , N - c ) : NEW_LINE INDENT if r % 2 == 1 and ( r + c ) % N != 1 : NEW_LINE INDENT ans [ c ] = n + ( r + c ) % n NEW_LINE DEDENT else : NEW_LINE INDENT ans [ r ] [ c ] += 1 NEW_LINE DEDENT DEDENT DEDENT print ( * ans ) NEW_LINE"],"references":["import math NEW_LINE k = int ( input ( ) ) NEW_LINE if k == 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE print ( 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT n = math . ceil ( k \/ 4 ) * 2 NEW_LINE ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT tmp = [ ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT tmp . append ( ( i + j ) % n + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT tmp . append ( n + ( i + j ) % n + 1 ) NEW_LINE DEDENT DEDENT ans . append ( tmp ) NEW_LINE DEDENT kazu = n * 2 NEW_LINE while kazu != k : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ans [ i ] [ j ] == kazu : NEW_LINE INDENT ans [ i ] [ j ] -= n NEW_LINE DEDENT DEDENT DEDENT kazu -= 1 NEW_LINE DEDENT print ( n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( * ans [ i ] ) NEW_LINE DEDENT"],"bleu":0.30423032923576887,"rouge_l":0.44924751841178356}
{"id":21,"predictions":["n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if s [ 0 ] == s [ 0 ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["n = int ( input ( ) ) NEW_LINE a = [ int ( input ( ) ) for i in range ( n ) ] NEW_LINE b = list ( set ( a ) ) NEW_LINE print ( len ( a ) - len ( b ) ) NEW_LINE"],"bleu":0.2751002514786798,"rouge_l":0.5106976744186048}
{"id":22,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) )   x = [ 0 ] * ( n + 1 ) y = list ( map ( int , input ( ) . split ( ) ) ) x = ( n + 1 ) * ( a [ 0 ] + x ) for i in range ( 1 , n - 1 ) : if abs ( x [ i ] - x ) >= abs ( y [ i ] - y ) : x = i + y else : print ( x , y [ i ] ) NEW_LINE"],"references":["def main ( ) : NEW_LINE INDENT n = input ( ) NEW_LINE a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE ai = max ( a ) NEW_LINE a . remove ( ai ) NEW_LINE aj = float ( ' inf ' ) NEW_LINE tmp = float ( ' inf ' ) NEW_LINE for aa in a : NEW_LINE INDENT diff = abs ( ai \/ 2 - aa ) NEW_LINE if diff < tmp : NEW_LINE INDENT tmp = diff NEW_LINE aj = aa NEW_LINE DEDENT DEDENT print ( ai , aj ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"bleu":0.1885030954991911,"rouge_l":0.3866877971473851}
{"id":23,"predictions":["n , m = map ( int , input ( ) . split ( ' ▁ ' ) ) NEW_LINE a = [ 0 ] * m NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i + 1 ] = a [ i + 1 ] NEW_LINE DEDENT print ( sum ( a ) ) NEW_LINE"],"references":["N , M = map ( int , input ( ) . split ( ) ) NEW_LINE zahyo = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE zahyo . sort ( ) NEW_LINE sa = [ 0 for _ in range ( M - 1 ) ] NEW_LINE for i in range ( M - 1 ) : NEW_LINE INDENT sa [ i ] = zahyo [ i + 1 ] - zahyo [ i ] NEW_LINE DEDENT sa . sort ( reverse = True ) NEW_LINE sa = sa [ N - 1 : ] NEW_LINE print ( sum ( sa ) ) NEW_LINE"],"bleu":0.20428675011337113,"rouge_l":0.5126050420168067}
{"id":24,"predictions":["from fractions import * NEW_LINE a , b , k = map ( int , input ( ) . split ( ) ) NEW_LINE k = k \/\/ l NEW_LINE if k == 0 : NEW_LINE INDENT k = n \/\/ l NEW_LINE DEDENT else : NEW_LINE INDENT k -= k * l NEW_LINE DEDENT print ( k * a ) NEW_LINE"],"references":["import sys NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE input = sys . stdin . readline NEW_LINE A , B , K , L = map ( int , input ( ) . split ( ) ) NEW_LINE s = K \/\/ L NEW_LINE print ( min ( K * A , s * B + ( K - s * L ) * A , ( s + 1 ) * B ) ) NEW_LINE"],"bleu":0.20783302735245301,"rouge_l":0.3609467455621302}
{"id":25,"predictions":["n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE i = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if a [ j ] % 2 == 0 : NEW_LINE INDENT ans += a [ i ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if a [ j ] % 2 == 1 : NEW_LINE INDENT ans += int ( ( a [ j ] \/ 2 ) ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT ans = 0 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["N = input ( ) NEW_LINE L = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def aoki ( i , array ) : NEW_LINE INDENT maxi = - 100000000 NEW_LINE for j in range ( len ( array ) ) : NEW_LINE INDENT tmp = 0 NEW_LINE if j != i : NEW_LINE INDENT if j < i : NEW_LINE INDENT T = array [ j : i + 1 ] NEW_LINE DEDENT elif j > i : NEW_LINE INDENT T = array [ i : j + 1 ] NEW_LINE DEDENT for k in range ( len ( T ) ) : NEW_LINE INDENT if k % 2 == 1 : NEW_LINE INDENT tmp += T [ k ] NEW_LINE DEDENT DEDENT if maxi < tmp : NEW_LINE INDENT choice = j NEW_LINE maxi = tmp NEW_LINE DEDENT DEDENT DEDENT return choice NEW_LINE DEDENT maxi = - 10000000000000 NEW_LINE for i in range ( len ( L ) ) : NEW_LINE INDENT aoki_choice = aoki ( i , L ) NEW_LINE tmp = 0 NEW_LINE if i < aoki_choice : NEW_LINE INDENT T = L [ i : aoki_choice + 1 ] NEW_LINE for j in range ( len ( T ) ) : NEW_LINE INDENT if j % 2 == 0 : NEW_LINE INDENT tmp += T [ j ] NEW_LINE DEDENT DEDENT DEDENT elif i > aoki_choice : NEW_LINE INDENT T = L [ aoki_choice : i + 1 ] NEW_LINE for j in range ( len ( T ) ) : NEW_LINE INDENT if j % 2 == 0 : NEW_LINE INDENT tmp += T [ j ] NEW_LINE DEDENT DEDENT DEDENT maxi = max ( tmp , maxi ) NEW_LINE DEDENT print ( maxi ) NEW_LINE"],"bleu":0.11805403454472975,"rouge_l":0.3780900900900901}
{"id":26,"predictions":["N , K = map ( int , input ( ) . split ( ) ) NEW_LINE c = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if c * ( N - K ) > abs ( K ) : NEW_LINE INDENT c += ( 2 * K ) * 2 NEW_LINE DEDENT else : NEW_LINE INDENT c += ( 2 * K ) * 2 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE"],"references":["N = int ( input ( ) ) NEW_LINE K = int ( input ( ) ) NEW_LINE X = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE sum_len = 0 NEW_LINE for i in range ( len ( X ) ) : NEW_LINE INDENT if X [ i ] < abs ( K - X [ i ] ) : NEW_LINE INDENT sum_len += X [ i ] * 2 NEW_LINE DEDENT else : NEW_LINE INDENT sum_len += abs ( K - X [ i ] ) * 2 NEW_LINE DEDENT DEDENT print ( sum_len ) NEW_LINE"],"bleu":0.3769362324910969,"rouge_l":0.6109480227939906}
{"id":27,"predictions":["n = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE even = 0 NEW_LINE gcd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if A [ i ] % 2 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT gcd = gcd ( gcd , a [ i : i ] ) NEW_LINE DEDENT DEDENT if all ( gcd ) == 1 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( main ( ) ) NEW_LINE DEDENT"],"references":["from fractions import gcd NEW_LINE def gcdL ( L ) : NEW_LINE INDENT g = L [ 0 ] NEW_LINE for i in range ( 1 , len ( L ) ) : NEW_LINE INDENT if g == 1 : NEW_LINE INDENT return ( g ) NEW_LINE DEDENT g = gcd ( g , L [ i ] ) NEW_LINE DEDENT return g NEW_LINE DEDENT def play ( A , i ) : NEW_LINE INDENT A [ i ] -= 1 NEW_LINE g = gcdL ( A ) NEW_LINE return [ x \/\/ g for x in A ] NEW_LINE DEDENT def cnt ( A ) : NEW_LINE INDENT odd , even = 0 , 0 NEW_LINE for a in A : NEW_LINE INDENT if a % 2 : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even += 1 NEW_LINE DEDENT DEDENT return odd , even NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE First = 1 NEW_LINE while True : NEW_LINE INDENT odd , even = cnt ( A ) NEW_LINE if even % 2 : NEW_LINE INDENT print ( ' First ' if First else ' Second ' ) NEW_LINE break NEW_LINE DEDENT elif odd > 1 : NEW_LINE INDENT print ( ' Second ' if First else ' First ' ) NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if A [ i ] % 2 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if A [ i ] == 1 : NEW_LINE INDENT print ( ' Second ' if First else ' First ' ) NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT A = play ( A , i ) NEW_LINE First ^= 1 NEW_LINE DEDENT DEDENT DEDENT"],"bleu":0.13115931493961844,"rouge_l":0.3021256105111096}
{"id":28,"predictions":["s = input ( ) NEW_LINE s = str ( input ( ) ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == ' * ' or s [ i ] == ' * ' : NEW_LINE INDENT continue NEW_LINE DEDENT if not in s : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT print ( ' NO ' ) NEW_LINE"],"references":["s = input ( ) NEW_LINE t = s [ : : - 1 ] NEW_LINE for x , y in zip ( s , t ) : NEW_LINE INDENT if x != ' * ' and y != ' * ' and x != y : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT print ( ' YES ' ) NEW_LINE"],"bleu":0.4533324993545625,"rouge_l":0.6019286835613367}
{"id":29,"predictions":["import math NEW_LINE def check ( t , n , t ) : NEW_LINE INDENT a , b = [ int ( x ) for x in input ( ) . split ( ' ▁ ' ) ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if a [ i ] <= n : NEW_LINE INDENT return ' no ' NEW_LINE DEDENT DEDENT if a [ i ] <= n : NEW_LINE INDENT print ( ' yes ' ) NEW_LINE exit ( 0 ) NEW_LINE DEDENT DEDENT print ( ' no ' ) NEW_LINE"],"references":["t = int ( input ( ) ) NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE m = int ( input ( ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if n < m : NEW_LINE INDENT print ( \" no \" ) NEW_LINE exit ( ) NEW_LINE DEDENT for i in b : NEW_LINE INDENT for l in range ( len ( a ) ) : NEW_LINE INDENT if i - t - 1 < a [ l ] < i + 1 : NEW_LINE INDENT a . pop ( l ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if len ( a ) == n - m : NEW_LINE INDENT print ( \" yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" no \" ) NEW_LINE DEDENT"],"bleu":0.14450566634152837,"rouge_l":0.39312567132116005}
{"id":30,"predictions":["N , D , X = map ( int , input ( ) . split ( ' ▁ ' ) ) NEW_LINE d = list ( map ( int , input ( ) . split ( ' ▁ ' ) ) ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT data = list ( map ( int , input ( ) . split ( ' ▁ ' ) ) ) NEW_LINE DEDENT print ( X + d ) ) NEW_LINE"],"references":["N = int ( input ( ) ) NEW_LINE D , X = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT A = int ( input ( ) ) NEW_LINE ans += ( D - 1 ) \/\/ A + 1 NEW_LINE DEDENT print ( ans + X ) NEW_LINE"],"bleu":0.4053074623322724,"rouge_l":0.6154858521605616}
{"id":31,"predictions":["sq = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE t = input ( ) NEW_LINE for j in range ( q ) : NEW_LINE INDENT if s [ j ] == \" R \" : NEW_LINE INDENT t += 1 NEW_LINE DEDENT elif t == \" B \" : NEW_LINE INDENT if t == \" D \" : NEW_LINE INDENT print ( \" DRAW \" ) NEW_LINE DEDENT elif t == \" R \" : NEW_LINE INDENT print ( \" TAK \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" TAK \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"references":["* a , = open ( 0 ) . read ( ) ; s , t = map ( a . count , \" RB \" ) ; print ( [ \" ADORKAIW \" [ s == t : : 2 ] , \" TAKAHASHI \" ] [ s > t ] ) NEW_LINE"],"bleu":0.02989368283534155,"rouge_l":0.25650780937124545}
{"id":32,"predictions":["A , B , C , T , K = map ( int , input ( ) . split ( ) ) NEW_LINE if S + T * T : NEW_LINE INDENT ans = A * C + B * T NEW_LINE DEDENT print ( ans ) NEW_LINE"],"references":["a , b , c , k = map ( int , input ( ) . split ( ) ) NEW_LINE s , t = map ( int , input ( ) . split ( ) ) NEW_LINE total = s + t NEW_LINE discount = 0 NEW_LINE if total >= k : NEW_LINE INDENT discount = total * c NEW_LINE DEDENT adm = ( s * a ) + ( t * b ) NEW_LINE print ( adm - discount ) NEW_LINE"],"bleu":0.18808558791928912,"rouge_l":0.45152817574021015}
{"id":33,"predictions":["N = int ( input ( ) ) NEW_LINE W = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT w = input ( ) NEW_LINE v = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if ( w - 1 ) in v : NEW_LINE INDENT ans = max ( v , w ) NEW_LINE DEDENT else : NEW_LINE INDENT if w <= N : NEW_LINE INDENT return ans NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return ans NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N , W = map ( int , input ( ) . split ( ) ) NEW_LINE W . append ( ( w , v ) ) NEW_LINE DEDENT"],"references":["n , W = map ( int , input ( ) . split ( ) ) NEW_LINE iw , v = map ( int , input ( ) . split ( ) ) NEW_LINE d = { 0 : [ v ] , 1 : [ ] , 2 : [ ] , 3 : [ ] } NEW_LINE for _ in range ( 1 , n ) : NEW_LINE INDENT w , v = map ( int , input ( ) . split ( ) ) NEW_LINE d [ w - iw ] . append ( v ) NEW_LINE DEDENT for i in range ( 4 ) : NEW_LINE INDENT d [ i ] = sorted ( d [ i ] , reverse = True ) NEW_LINE DEDENT ret = - 1 NEW_LINE for i in range ( min ( n , len ( d [ 0 ] ) ) + 1 ) : NEW_LINE INDENT if i * iw > W : NEW_LINE INDENT break NEW_LINE DEDENT for j in range ( min ( n - i , len ( d [ 1 ] ) ) + 1 ) : NEW_LINE INDENT if i * iw + j * ( iw + 1 ) > W : NEW_LINE INDENT break NEW_LINE DEDENT for k in range ( min ( n - ( i + j ) , len ( d [ 2 ] ) ) + 1 ) : NEW_LINE INDENT if i * iw + j * ( iw + 1 ) + k * ( iw + 2 ) > W : NEW_LINE INDENT break NEW_LINE DEDENT for l in range ( min ( n - ( i + j + k ) , len ( d [ 3 ] ) ) + 1 ) : NEW_LINE INDENT if i * iw + j * ( iw + 1 ) + k * ( iw + 2 ) + l * ( iw + 3 ) > W : NEW_LINE INDENT continue NEW_LINE DEDENT V = sum ( d [ 0 ] [ : i ] ) + sum ( d [ 1 ] [ : j ] ) + sum ( d [ 2 ] [ : k ] ) + sum ( d [ 3 ] [ : l ] ) NEW_LINE ret = max ( ret , V ) NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( ret ) NEW_LINE"],"bleu":0.08734941854780089,"rouge_l":0.3109375847296784}
{"id":34,"predictions":["from collections import deque NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE d = deque ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE d = [ [ - 1 for _ in range ( m ) ] for _ in range ( n ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT d [ i ] [ 0 ] = d [ i ] [ 0 ] + d [ i ] [ 1 ] = d [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if d [ i ] [ 0 ] != - d [ i ] [ 1 ] : NEW_LINE INDENT d [ i ] [ 1 ] = d [ i ] [ 1 ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT d [ i ] [ 1 ] = d [ i ] [ 1 ] NEW_LINE DEDENT DEDENT"],"references":["def inpl ( ) : return [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE def find ( x ) : NEW_LINE INDENT if par [ x ] == x : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT par [ x ] , dist [ x ] = find ( par [ x ] ) , dist [ x ] + dist [ par [ x ] ] NEW_LINE return par [ x ] NEW_LINE DEDENT DEDENT N , M = inpl ( ) NEW_LINE par = list ( range ( N + 1 ) ) NEW_LINE dist = [ 0 for _ in range ( N + 1 ) ] NEW_LINE for _ in range ( M ) : NEW_LINE INDENT l , r , d = inpl ( ) NEW_LINE fl = find ( l ) NEW_LINE fr = find ( r ) NEW_LINE if fl != fr : NEW_LINE INDENT par [ fr ] = fl NEW_LINE dist [ fr ] = d + dist [ l ] - dist [ r ] NEW_LINE DEDENT elif d + dist [ l ] - dist [ r ] != 0 : NEW_LINE INDENT print ( ' No ' ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT"],"bleu":0.18795562910472155,"rouge_l":0.34735843087630497}
{"id":35,"predictions":["a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE if a == b : NEW_LINE INDENT print ( a ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( b ) NEW_LINE DEDENT"],"references":["A , B , C = map ( int , input ( ) . split ( ) ) NEW_LINE if A == B : NEW_LINE INDENT print ( C ) NEW_LINE DEDENT elif A == C : NEW_LINE INDENT print ( B ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( A ) NEW_LINE DEDENT"],"bleu":0.48128249890689856,"rouge_l":0.7046204620462047}
{"id":36,"predictions":["y , m = map ( int , input ( ) . split ( ) ) NEW_LINE if m % 4 == 0 : NEW_LINE INDENT y -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( 7 ) NEW_LINE DEDENT"],"references":["y = int ( input ( ) ) NEW_LINE m = int ( input ( ) ) NEW_LINE d = int ( input ( ) ) NEW_LINE def f ( x ) : NEW_LINE INDENT return int ( x \/\/ 1 ) NEW_LINE DEDENT def F ( y , m , d ) : NEW_LINE INDENT if m == 1 or m == 2 : NEW_LINE INDENT y -= 1 NEW_LINE m += 12 NEW_LINE DEDENT return int ( 365 * y + f ( y \/ 4 ) - f ( y \/ 100 ) + f ( y \/ 400 ) + f ( 306 * ( m + 1 ) \/ 10 ) + d - 429 ) NEW_LINE DEDENT print ( F ( 2014 , 5 , 17 ) - F ( y , m , d ) ) NEW_LINE"],"bleu":0.03073504760332926,"rouge_l":0.2750845546786923}
{"id":37,"predictions":["from collections import defaultdict NEW_LINE m , n = map ( int , input ( ) . split ( ) ) NEW_LINE K = set ( ) NEW_LINE for m in range ( 1 , 10 ** 18 + 1 ) : NEW_LINE INDENT for j in range ( i * m + 1 ) : NEW_LINE INDENT if K * j <= n : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , 10 ** 18 + 1 ) : NEW_LINE INDENT K = set ( ) NEW_LINE for j in range ( i + 1 , m + 1 ) : NEW_LINE INDENT if K * j <= n : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( str ( K ) ) NEW_LINE DEDENT"],"references":["f = lambda x : sum ( map ( int , str ( x ) ) ) NEW_LINE ans = [ ] NEW_LINE def check ( x ) : NEW_LINE INDENT y = f ( x ) NEW_LINE while ans : NEW_LINE INDENT p = ans [ - 1 ] NEW_LINE if p * y > x * f ( p ) : ans . pop ( - 1 ) NEW_LINE else : break NEW_LINE DEDENT ans . append ( x ) NEW_LINE DEDENT k = int ( input ( ) ) NEW_LINE for i in range ( 1 , 100 ) : NEW_LINE INDENT check ( i ) NEW_LINE DEDENT a , b = 0 , 1 NEW_LINE while a < 1e12 : NEW_LINE INDENT for i in range ( 100 , 1000 ) : NEW_LINE INDENT check ( i * b + a ) NEW_LINE DEDENT a = a * 10 + 9 NEW_LINE b *= 10 NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT print ( ans [ i ] ) NEW_LINE DEDENT"],"bleu":0.19495936953214354,"rouge_l":0.3867075664621677}
{"id":38,"predictions":["import sys NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE input = sys . stdin . readline NEW_LINE N = int ( input ( ) ) NEW_LINE x = input ( ) NEW_LINE for _ in range ( n ) : NEW_LINE INDENT s = input ( ) NEW_LINE x = input ( ) NEW_LINE y = input ( ) NEW_LINE x = y [ : : - 1 ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT x , y = input ( ) . split ( ) NEW_LINE x = y [ : : - 1 ] NEW_LINE if x % 2 == 0 : NEW_LINE INDENT x = x NEW_LINE y = y \/\/ 2 + 1 NEW_LINE DEDENT DEDENT DEDENT print ( s ) NEW_LINE"],"references":["def solve ( ) : NEW_LINE INDENT s = input ( ) NEW_LINE n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT l , r = ( int ( i ) for i in input ( ) . split ( ) ) NEW_LINE tmp = s [ l - 1 : r ] NEW_LINE s = s [ 0 : l - 1 ] + tmp [ : : - 1 ] + s [ r : : ] NEW_LINE DEDENT print ( s ) NEW_LINE DEDENT solve ( ) NEW_LINE"],"bleu":0.33695983595408197,"rouge_l":0.4627827082736903}
{"id":39,"predictions":["x , y = map ( int , input ( ) . split ( \" ▁ \" ) ) NEW_LINE if x <= t : NEW_LINE INDENT print ( x - t ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT"],"references":["a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a - b > 0 : NEW_LINE INDENT print ( a - b ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT"],"bleu":0.6302053369126825,"rouge_l":0.7881136950904394}
{"id":40,"predictions":["import math NEW_LINE import sys NEW_LINE def upperRoot ( a ) : NEW_LINE INDENT if a < b : NEW_LINE INDENT return 2 * a NEW_LINE DEDENT if a == b : NEW_LINE INDENT return 2 * a NEW_LINE DEDENT if a == b : NEW_LINE INDENT return 2 * c NEW_LINE DEDENT if a < b : NEW_LINE INDENT return 2 * a - 2 NEW_LINE DEDENT elif a == b : NEW_LINE INDENT return 2 * b NEW_LINE DEDENT else : NEW_LINE INDENT if a == b : NEW_LINE INDENT return 2 * c NEW_LINE DEDENT else : NEW_LINE INDENT return 2 * a + b NEW_LINE DEDENT DEDENT DEDENT q = int ( input ( ) ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT print ( i + 1 ) NEW_LINE DEDENT"],"references":["import math NEW_LINE q = int ( input ( ) ) NEW_LINE for j in range ( q ) : NEW_LINE INDENT AB = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE AB . sort ( ) NEW_LINE ab = AB [ 0 ] * AB [ 1 ] NEW_LINE for i in range ( int ( math . sqrt ( ab ) ) , AB [ 1 ] + 1 ) : NEW_LINE INDENT if i * i >= ab : NEW_LINE INDENT x = i - 1 NEW_LINE break NEW_LINE DEDENT DEDENT if x == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE continue NEW_LINE DEDENT for i in range ( int ( ab \/ x ) , ab + 1 ) : NEW_LINE INDENT if x * i >= ab : NEW_LINE INDENT y = i - 1 NEW_LINE break NEW_LINE DEDENT DEDENT cnt1 = 2 * x NEW_LINE cnts = 1 if x == y else 0 NEW_LINE cntdd = 1 if x - AB [ 0 ] >= 0 else 0 NEW_LINE cntdu = 1 if AB [ 1 ] - y >= 0 and ( AB [ 1 ] + 1 ) * ( x - AB [ 1 ] + y ) >= ab else 0 NEW_LINE print ( cnt1 - cnts - cntdd - cntdu ) NEW_LINE DEDENT"],"bleu":0.14491110136338173,"rouge_l":0.27006933422437557}
{"id":41,"predictions":["import sys NEW_LINE stdin = sys . stdin NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE def li ( ) : return map ( int , stdin . readline ( ) . split ( ) ) NEW_LINE def li_ ( ) : return map ( lambda x : int ( x ) - 1 , stdin . readline ( ) . split ( ) ) NEW_LINE def lf ( ) : return map ( float , stdin . readline ( ) . split ( ) ) NEW_LINE def ls ( ) : return stdin . readline ( ) . split ( ) NEW_LINE def ns ( ) : return stdin . readline ( ) . rstrip ( ) NEW_LINE def lc ( ) : return list ( ns ( ) ) NEW_LINE def ni ( ) : return int ( stdin . readline ( ) ) NEW_LINE def nf ( ) : return float ( stdin . readline ( ) ) NEW_LINE mod = 10 ** 9 + 7 NEW_LINE def ni ( ) : return int ( stdin . readline ( ) ) NEW_LINE def nf ( ) : NEW_LINE INDENT a = nb ( ) NEW_LINE b = 1 NEW_LINE for i in range ( 1 , h + 1 ) : NEW_LINE INDENT if i < h - 1 : NEW_LINE INDENT a *= n NEW_LINE b %= MOD NEW_LINE DEDENT b += 1 NEW_LINE DEDENT return a NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT H , W = map ( int , input ( ) . split ( ) ) NEW_LINE print ( main ( ) ) NEW_LINE DEDENT"],"references":["H , W , A , B = map ( int , input ( ) . split ( ) ) NEW_LINE P = 10 ** 9 + 7 NEW_LINE N = H + W NEW_LINE def fact ( N , P ) : NEW_LINE INDENT ret = [ 1 ] * ( N + 1 ) NEW_LINE for n in range ( 2 , N + 1 ) : NEW_LINE INDENT ret [ n ] = ( ret [ n - 1 ] * n ) % P NEW_LINE DEDENT return ret NEW_LINE DEDENT def pow_r ( a , b , P ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if b % 2 == 0 : NEW_LINE INDENT return pow_r ( ( a ** 2 ) % P , b \/\/ 2 , P ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( a * pow_r ( ( a ** 2 ) % P , ( b - 1 ) \/\/ 2 , P ) ) % P NEW_LINE DEDENT DEDENT def inv_fact ( N , P ) : NEW_LINE INDENT ret = [ 1 ] * ( N + 1 ) NEW_LINE fac = fact ( N , P ) NEW_LINE ret [ N ] = pow_r ( fac [ N ] , P - 2 , P ) NEW_LINE for n in reversed ( range ( 2 , N ) ) : NEW_LINE INDENT ret [ n ] = ( ret [ n + 1 ] * ( n + 1 ) ) % P NEW_LINE DEDENT return ret NEW_LINE DEDENT fac = fact ( N , P ) NEW_LINE inv = inv_fact ( N , P ) NEW_LINE def combination ( n , r , P ) : NEW_LINE INDENT return ( fac [ n ] * inv [ r ] * inv [ n - r ] ) % P NEW_LINE DEDENT sub = 0 NEW_LINE for a in range ( A ) : NEW_LINE INDENT sub = ( sub + combination ( ( H - 1 - a ) + ( B - 1 ) , B - 1 , P ) * combination ( a + ( W - 1 - B ) , a , P ) ) % P NEW_LINE DEDENT print ( ( combination ( ( H - 1 ) + ( W - 1 ) , H - 1 , P ) - sub ) % P ) NEW_LINE"],"bleu":0.12111193434483224,"rouge_l":0.29275139222166885}
{"id":42,"predictions":["def main ( ) : NEW_LINE INDENT n , a = map ( int , input ( ) . split ( ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE answer = 0 NEW_LINE for i in range ( a ) : NEW_LINE INDENT if a [ i ] not in b : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT else : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT print ( answer ) NEW_LINE DEDENT"],"references":["from collections import Counter NEW_LINE L , R = map ( int , input ( ) . split ( ) ) NEW_LINE inputs_l = Counter ( [ int ( i ) for i in input ( ) . split ( ) ] ) NEW_LINE inputs_r = Counter ( [ int ( i ) for i in input ( ) . split ( ) ] ) NEW_LINE print ( sum ( [ min ( inputs_r [ key ] , value ) for key , value in inputs_l . items ( ) ] ) ) NEW_LINE"],"bleu":0.2723289882368304,"rouge_l":0.4478868194842407}
{"id":43,"predictions":["n = int ( input ( ) ) NEW_LINE L = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT m = i * i NEW_LINE while m <= x : NEW_LINE INDENT m = m * i NEW_LINE x *= i NEW_LINE DEDENT DEDENT print ( max ( m ) ) NEW_LINE"],"references":["x = int ( input ( ) ) NEW_LINE y = [ ] NEW_LINE for i in range ( 1 , 33 ) : NEW_LINE INDENT for j in range ( 2 , 11 ) : NEW_LINE INDENT y . append ( i ** j ) NEW_LINE DEDENT DEDENT ans = 1 NEW_LINE for i in y : NEW_LINE INDENT if i <= x : NEW_LINE INDENT ans = max ( ans , i ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"bleu":0.3183617506976872,"rouge_l":0.5164884135472371}
{"id":44,"predictions":["n = int ( input ( ) ) NEW_LINE prev = - 1 NEW_LINE ans = 0 NEW_LINE for i in range ( 2 * n ) : NEW_LINE INDENT if prev == arr [ i % n ] : NEW_LINE INDENT ans = ans + 1 NEW_LINE DEDENT else : NEW_LINE INDENT if prev < count : NEW_LINE INDENT ans = count + 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT ans = 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["a = [ int ( input ( ) ) for _ in [ 0 ] * int ( input ( ) ) ] * 2 NEW_LINE if len ( set ( a ) ) < 2 : NEW_LINE INDENT print ( - 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT b = c = m = 0 NEW_LINE for i in a : NEW_LINE INDENT if i : NEW_LINE INDENT b += 1 NEW_LINE m = max ( m , b , c ) NEW_LINE c = 0 NEW_LINE DEDENT else : NEW_LINE INDENT c += 1 NEW_LINE m = max ( m , b , c ) NEW_LINE b = 0 NEW_LINE DEDENT DEDENT print ( ~ - m \/\/ 2 + 1 ) NEW_LINE"],"bleu":0.1956750827591362,"rouge_l":0.3967629708062321}
{"id":45,"predictions":["n , m = map ( int , input ( ) . split ( ) ) NEW_LINE s = list ( input ( ) ) NEW_LINE if n == m1 or n == 0 : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT elif n == m1 and n == m2 : NEW_LINE INDENT if s == \" NO \" : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT elif n == 10000 : NEW_LINE INDENT if n == m1 : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"references":["import sys NEW_LINE N = int ( input ( ) ) NEW_LINE NG1 = int ( input ( ) ) NEW_LINE NG2 = int ( input ( ) ) NEW_LINE NG3 = int ( input ( ) ) NEW_LINE if N == NG1 or N == NG2 or N == NG3 : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE sys . exit ( ) NEW_LINE DEDENT queue = [ ] NEW_LINE queue . append ( ( 0 , N ) ) NEW_LINE judge = [ ] NEW_LINE while queue : NEW_LINE INDENT a = queue . pop ( 0 ) NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT b = a [ 1 ] - [ 1 , 2 , 3 ] [ i ] NEW_LINE if b != NG1 and b != NG2 and b != NG3 and a [ 0 ] < 100 : NEW_LINE INDENT num = ( a [ 0 ] + 1 , b ) NEW_LINE if b > 0 and num [ 0 ] < 100 and num not in judge and ( 100 - num [ 0 ] ) * 3 >= b : NEW_LINE INDENT queue . append ( num ) NEW_LINE judge . append ( num ) NEW_LINE DEDENT elif b == 0 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE sys . exit ( ) NEW_LINE DEDENT else : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( ' NO ' ) NEW_LINE"],"bleu":0.11838948964261184,"rouge_l":0.34544130733759404}
{"id":46,"predictions":["def inpl ( ) : return [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE"],"references":["N , M = ( int ( _ ) for _ in input ( ) . split ( ) ) NEW_LINE E = [ ] NEW_LINE V = [ [ i + 1 , 0 ] for i in range ( N ) ] NEW_LINE searched_vertex = [ ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT u , v = ( int ( _ ) for _ in input ( ) . split ( ) ) NEW_LINE E . append ( [ u , v , True ] ) NEW_LINE DEDENT cnt_trees = 0 NEW_LINE def find_tree ( vertex ) : NEW_LINE INDENT flag = True NEW_LINE index , reached = vertex NEW_LINE if reached == 0 : NEW_LINE INDENT V [ index - 1 ] [ 1 ] = 1 NEW_LINE DEDENT searched_vertex . append ( index ) NEW_LINE while searched_vertex : NEW_LINE INDENT i = searched_vertex [ len ( searched_vertex ) - 1 ] NEW_LINE for edge_index in range ( len ( E ) ) : NEW_LINE INDENT u , v , unused = E [ edge_index ] NEW_LINE if unused : NEW_LINE INDENT if u == i : NEW_LINE INDENT E [ edge_index ] [ 2 ] = False NEW_LINE for ind in range ( len ( searched_vertex ) ) : NEW_LINE INDENT if v == searched_vertex [ ind ] : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT V [ v - 1 ] [ 1 ] = 1 NEW_LINE searched_vertex . append ( v ) NEW_LINE break NEW_LINE DEDENT DEDENT elif v == i : NEW_LINE INDENT E [ edge_index ] [ 2 ] = False NEW_LINE for ind in range ( len ( searched_vertex ) ) : NEW_LINE INDENT if u == searched_vertex [ ind ] : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT V [ u - 1 ] [ 1 ] = 1 NEW_LINE searched_vertex . append ( u ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT else : NEW_LINE INDENT searched_vertex . pop ( ) NEW_LINE DEDENT DEDENT return flag NEW_LINE DEDENT for index , reached in V : NEW_LINE INDENT if reached == 0 : NEW_LINE INDENT for j in range ( len ( E ) ) : NEW_LINE INDENT E [ j ] [ 2 ] = True NEW_LINE DEDENT if find_tree ( ( index , reached ) ) : NEW_LINE INDENT cnt_trees += 1 NEW_LINE DEDENT DEDENT DEDENT print ( cnt_trees ) NEW_LINE"],"bleu":1.544720779600751e-8,"rouge_l":0.06963911968034503}
{"id":47,"predictions":["R , G = map ( int , input ( ) . split ( ) ) NEW_LINE print ( K + ( G - R ) ) NEW_LINE"],"references":["R = int ( input ( ) ) NEW_LINE G = int ( input ( ) ) NEW_LINE print ( 2 * G - R ) NEW_LINE"],"bleu":0.3948821678356559,"rouge_l":0.6202153110047847}
{"id":48,"predictions":["a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( a * b - 1 ) NEW_LINE"],"references":["a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( a - 1 ) * ( b - 1 ) ) NEW_LINE"],"bleu":0.6848973447500101,"rouge_l":0.8801331853496115}
{"id":49,"predictions":["H , W = map ( int , input ( ) . split ( ) ) NEW_LINE s = [ ] NEW_LINE for i in range ( H ) : NEW_LINE INDENT s . append ( input ( ) ) NEW_LINE DEDENT print ( len ( s ) ) NEW_LINE"],"references":["import sys , re NEW_LINE from collections import deque , defaultdict , Counter NEW_LINE from math import ceil , sqrt , hypot , factorial , pi , sin , cos , radians NEW_LINE from itertools import permutations , combinations , product NEW_LINE from operator import itemgetter , mul NEW_LINE from copy import deepcopy NEW_LINE from string import ascii_lowercase , ascii_uppercase , digits NEW_LINE def input ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def INT ( ) : return int ( input ( ) ) NEW_LINE def MAP ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE INF = float ( ' inf ' ) NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE H , W = MAP ( ) NEW_LINE C = [ input ( ) for _ in range ( H ) ] NEW_LINE for x in C : NEW_LINE INDENT print ( x ) NEW_LINE print ( x ) NEW_LINE DEDENT"],"bleu":0.02764825794636512,"rouge_l":0.22905421262614414}
{"id":50,"predictions":["def main ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if N [ i ] != count : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( main ( ) ) NEW_LINE DEDENT"],"references":["print ( len ( set ( [ input ( ) for _ in range ( int ( input ( ) ) ) ] ) ) ) NEW_LINE"],"bleu":0.13300938468572748,"rouge_l":0.31088460138332724}
{"id":51,"predictions":["n = input ( ) NEW_LINE print ( \" \" . join ( map ( str , n ) ) ) NEW_LINE"],"references":["n = int ( input ( ) ) NEW_LINE print ( 111 + 999 - n ) NEW_LINE"],"bleu":0.28489318277723963,"rouge_l":0.5601001669449083}
{"id":52,"predictions":["from math import gcd , gcd , sqrt NEW_LINE"],"references":["import sys NEW_LINE from collections import defaultdict , Counter NEW_LINE from itertools import product , groupby , count , permutations , combinations NEW_LINE from math import pi , sqrt , ceil , floor NEW_LINE from collections import deque NEW_LINE from bisect import bisect , bisect_left , bisect_right NEW_LINE from string import ascii_lowercase NEW_LINE INF = float ( \" inf \" ) NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE dy = [ 0 , - 1 , 0 , 1 ] NEW_LINE dx = [ 1 , 0 , - 1 , 0 ] NEW_LINE def inside ( y : int , x : int , H : int , W : int ) -> bool : return 0 <= y < H and 0 <= x < W NEW_LINE def main ( ) : NEW_LINE INDENT X , Y = map ( int , input ( ) . split ( \" \/ \" ) ) NEW_LINE ans_list = [ ] NEW_LINE for n in range ( max ( 0 , 2 * X \/\/ Y - 10 ) , 2 * X \/\/ Y + 10 ) : NEW_LINE INDENT a = n * ( Y + n * Y - 2 * X ) NEW_LINE if a % ( 2 * Y ) == 0 : NEW_LINE INDENT m = a \/\/ ( 2 * Y ) NEW_LINE if 0 < m <= n : NEW_LINE INDENT ans_list . append ( \" { 0 } ▁ { 1 } \" . format ( n , m ) ) NEW_LINE DEDENT DEDENT DEDENT if ans_list : NEW_LINE INDENT print ( * ans_list , sep = \" \\n \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Impossible \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"bleu":5.753405374096623e-16,"rouge_l":0.03164721141374838}
{"id":53,"predictions":["n , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE s = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , n + 1 ) : NEW_LINE INDENT s += ( j ) % 10 NEW_LINE DEDENT DEDENT print ( s ) NEW_LINE"],"references":["N , A , B = map ( int , input ( ) . split ( \" ▁ \" ) ) NEW_LINE total = 0 NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT sum = 0 NEW_LINE temp = i NEW_LINE for m in range ( 5 ) : NEW_LINE INDENT sum += temp % 10 NEW_LINE temp = temp \/\/ 10 NEW_LINE DEDENT if A <= sum and sum <= B : NEW_LINE INDENT total += i NEW_LINE DEDENT DEDENT print ( total ) NEW_LINE"],"bleu":0.3364855570046419,"rouge_l":0.5943970767356883}
{"id":54,"predictions":["a , b , c = input ( ) . split ( ) n = int ( n ) for i in range ( a ) : if i == a or i == b and i == c : print ( \" eval \" ) else : a = list ( map ( int , input ( ) . split ( ) ) ) print ( len ( a ) ) NEW_LINE"],"references":["s = input ( ) NEW_LINE a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE print ( s [ 0 : a ] + ' \" ' + s [ a : b ] + ' \" ' + s [ b : c ] + ' \" ' + s [ c : d ] + ' \" ' + s [ d : ] ) NEW_LINE"],"bleu":0.25922364916964363,"rouge_l":0.3241232731137088}
{"id":55,"predictions":["n = int ( input ( ) ) for i in range ( n + 1 ) : NEW_LINE"],"references":["N = int ( input ( ) ) NEW_LINE for cake in range ( 26 ) : NEW_LINE INDENT flag = False NEW_LINE for donut in range ( 15 ) : NEW_LINE INDENT if 4 * cake + 7 * donut == N : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE flag = True NEW_LINE break NEW_LINE DEDENT DEDENT if flag : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT"],"bleu":0.018008926991300543,"rouge_l":0.2669973737963233}
{"id":56,"predictions":["a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE if c <= a : NEW_LINE INDENT print ( \" safe \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" safe \" ) NEW_LINE DEDENT"],"references":["x , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if 0 < b - a <= x : print ( \" safe \" ) NEW_LINE else : print ( \" ddealnigceiroouuss \" [ b - a > x : : 2 ] ) NEW_LINE"],"bleu":0.4545107914543248,"rouge_l":0.6900452488687783}
{"id":57,"predictions":["n , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if b % 2 == 0 : NEW_LINE INDENT print ( \" Alice \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Borys \" ) NEW_LINE DEDENT"],"references":["n , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if ( ( b - a ) % 2 == 0 ) : NEW_LINE INDENT print ( \" Alice \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Borys \" ) NEW_LINE DEDENT"],"bleu":0.8101595594571319,"rouge_l":0.931297709923664}
{"id":58,"predictions":["s = input ( ) s = ' ' for i in range ( len ( s ) ) : if s [ i ] == '0' : print ( \" None \" ) else : for j in range ( len ( s [ j ] ) ) : NEW_LINE"],"references":["S = str ( input ( ) ) NEW_LINE ascii_letters = \" abcdefghijklmnopqrstuvwxyz \" NEW_LINE for letter in ascii_letters : NEW_LINE INDENT if letter not in S : NEW_LINE INDENT print ( letter ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT print ( \" None \" ) NEW_LINE"],"bleu":0.1743222856442951,"rouge_l":0.3453213453213453}
{"id":59,"predictions":["N = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( \" ▁ \" ) ) ) NEW_LINE max = sum ( A ) NEW_LINE if max < sum : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["N = int ( input ( ) ) NEW_LINE L = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE L . sort ( reverse = 1 ) NEW_LINE length = 0 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT length += L [ i ] NEW_LINE DEDENT if L [ 0 ] < length : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.47499732879193113,"rouge_l":0.6931818181818181}
{"id":60,"predictions":["n = int ( input ( ) ) NEW_LINE l = [ ] NEW_LINE for x in range ( n - 1000 ) : NEW_LINE INDENT l . append ( x % 10 ) NEW_LINE DEDENT print ( len ( set ( ) ) ) NEW_LINE"],"references":["n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( max ( 1 , n - 200 ) , n ) : NEW_LINE INDENT if i + sum ( [ int ( x ) for x in list ( str ( i ) ) ] ) == n : NEW_LINE INDENT a . append ( i ) NEW_LINE DEDENT DEDENT print ( len ( a ) ) NEW_LINE for x in a : NEW_LINE INDENT print ( x ) NEW_LINE DEDENT"],"bleu":0.21068015264029402,"rouge_l":0.514123006833713}
{"id":61,"predictions":["n = int ( input ( ) ) NEW_LINE L = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if c <= l [ i ] : NEW_LINE INDENT c += abs ( l [ i ] ) + 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE"],"references":["N = int ( input ( ) ) NEW_LINE lr = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( N ) ] NEW_LINE print ( sum ( list ( zip ( * lr ) ) [ 1 ] ) - sum ( list ( zip ( * lr ) ) [ 0 ] ) + N ) NEW_LINE"],"bleu":0.402495423381817,"rouge_l":0.5666511843938691}
{"id":62,"predictions":["n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE c = 0 NEW_LINE j = 1 NEW_LINE while i < n : NEW_LINE INDENT j = 0 NEW_LINE while j < ( n + 2 ) & 1 : NEW_LINE INDENT if c [ j ] == \" o \" : NEW_LINE INDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT j += 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return c NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE s = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE t = [ 0 ] * ( n + 2 ) NEW_LINE for i in range ( 2 , n + 2 ) : NEW_LINE INDENT s [ i ] = t [ 0 ] + s [ i - 1 ] NEW_LINE DEDENT print ( - 1 ) NEW_LINE"],"references":["n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE s = list ( map ( lambda x : 1 if x == \" o \" else - 1 , list ( s ) ) ) NEW_LINE flag = False NEW_LINE for start in [ [ 1 , 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] , [ - 1 , - 1 ] ] : NEW_LINE INDENT circle = start + [ 0 ] * ( n - 2 ) NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT circle [ i + 1 ] = circle [ i ] * s [ i ] * circle [ i - 1 ] NEW_LINE DEDENT if circle [ - 2 ] == circle [ - 1 ] * s [ - 1 ] * circle [ 0 ] and circle [ - 1 ] == circle [ 0 ] * s [ 0 ] * circle [ 1 ] : NEW_LINE INDENT flag = True NEW_LINE break NEW_LINE DEDENT DEDENT if flag : NEW_LINE INDENT ans = \" \" NEW_LINE for i in circle : NEW_LINE INDENT if i == 1 : NEW_LINE INDENT ans += \" S \" NEW_LINE DEDENT else : NEW_LINE INDENT ans += \" W \" NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT"],"bleu":0.25390758715868744,"rouge_l":0.3434896636840481}
{"id":63,"predictions":["n , d = input ( ) . split ( ) NEW_LINE if m % d == 0 : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"],"references":["print ( \" YNEOS \" [ eval ( input ( ) . replace ( ' ▁ ' , ' % ' ) ) > 0 : : 2 ] ) NEW_LINE"],"bleu":0.14774508970143815,"rouge_l":0.3134049509574965}
{"id":64,"predictions":["import sys NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE input = sys . stdin . readline NEW_LINE N = int ( input ( ) ) NEW_LINE dpc = [ [ - 1 for _ in range ( N ) ] NEW_LINE dp = [ [ - 1 for _ in range ( 4 ) ] for _ in range ( N ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE dp [ 1 ] [ 2 ] = dp [ 0 ] [ 1 ] = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if dp [ i ] [ 1 ] : NEW_LINE INDENT dp [ i ] = - 1 NEW_LINE if dp [ i ] [ 2 ] = dp [ i - 1 ] [ 0 ] NEW_LINE INDENT dp [ i ] [ 1 ] = ( dp [ i - 1 ] [ 1 ] + dp [ i - 1 ] [ 1 ] + 1 ) % m NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ 2 ] = ( dp [ i - 1 ] [ 1 ] + dp [ i ] [ 2 ] ) % m NEW_LINE dp [ i ] [ 1 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i ] [ 1 ] ) % m NEW_LINE dp [ i ] [ 2 ] % m NEW_LINE dp [ i ] [ 1 ] = ( dp [ i ] [ 2 ] + dp [ i - 1 ] [ 1 ] ) % m NEW_LINE dp [ i ] [ 1 ] = ( dp [ i ] [ 3 ] + dp [ i - 1 ] [ 1 ] ) % m NEW_LINE dp [ i ] [ 2 ] %= m NEW_LINE DEDENT print ( dp [ n ] [ 3 ] ) % m NEW_LINE"],"references":["from bisect import bisect NEW_LINE n = int ( input ( ) ) NEW_LINE d = [ int ( input ( ) ) for i in range ( n ) ] NEW_LINE a , d , mod , ans = [ ] , sorted ( d ) , 10 ** 9 + 7 , 0 NEW_LINE for i in range ( n ) : a . append ( n - bisect ( d , d [ i ] * 2 - 1 ) ) NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : a [ i ] += a [ i + 1 ] NEW_LINE for i in range ( n ) : ans = ( ans + bisect ( d , d [ i ] \/\/ 2 ) * a [ min ( n - 1 , bisect ( d , d [ i ] * 2 - 1 ) ) ] ) % mod NEW_LINE print ( ans ) NEW_LINE"],"bleu":0.09466680624563283,"rouge_l":0.3498805052919085}
{"id":65,"predictions":["N = int ( input ( ) ) NEW_LINE B = list ( map ( int , input ( ) . split ( \" ▁ \" ) ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( \" ▁ \" ) ) ) NEW_LINE B = sorted ( A , key = lambda x : x [ 0 ] ) NEW_LINE answer = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( i % 2 == 0 ) % 2 : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT print ( answer \/\/ 2 ) NEW_LINE"],"references":["import bisect NEW_LINE n = int ( input ( ) ) NEW_LINE l = [ ] NEW_LINE e = [ ] NEW_LINE for i in range ( n \/\/ 2 ) : NEW_LINE INDENT j = int ( input ( ) ) NEW_LINE e . append ( j ) NEW_LINE l . append ( j ) NEW_LINE j = int ( input ( ) ) NEW_LINE l . append ( j ) NEW_LINE DEDENT if n % 2 == 1 : NEW_LINE INDENT j = int ( input ( ) ) NEW_LINE e . append ( j ) NEW_LINE l . append ( j ) NEW_LINE DEDENT l . sort ( ) NEW_LINE e . sort ( ) NEW_LINE res = 0 NEW_LINE for i in range ( 0 , n , 2 ) : NEW_LINE INDENT if e [ min ( len ( e ) - 1 , bisect . bisect_left ( e , l [ i ] ) ) ] != l [ i ] : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE"],"bleu":0.17078522181503053,"rouge_l":0.4169921875}
{"id":66,"predictions":["n , l = sorted ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT l . append ( l [ i ] - l [ i ] ) NEW_LINE ans += max ( l [ i ] , l [ 0 ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE"],"references":["import sys NEW_LINE from operator import itemgetter NEW_LINE N = int ( input ( ) ) NEW_LINE sorted_l = sorted ( ( tuple ( map ( int , l . split ( ) ) ) for l in sys . stdin ) , reverse = True ) NEW_LINE sorted_r = sorted ( sorted_l , key = itemgetter ( 1 ) ) NEW_LINE pos1 , ans1 = 0 , 0 NEW_LINE pos2 , ans2 = 0 , 0 NEW_LINE for i , j in enumerate ( i \/\/ 2 for i in range ( N ) ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT dist1 , dist2 = max ( sorted_l [ j ] [ 0 ] - pos1 , 0 ) , max ( pos2 - sorted_r [ j ] [ 1 ] , 0 ) NEW_LINE pos1 , ans1 = pos1 + dist1 , ans1 + dist1 NEW_LINE pos2 , ans2 = pos2 - dist2 , ans2 + dist2 NEW_LINE DEDENT else : NEW_LINE INDENT dist1 , dist2 = max ( pos1 - sorted_r [ j ] [ 1 ] , 0 ) , max ( sorted_l [ j ] [ 0 ] - pos2 , 0 ) NEW_LINE pos1 , ans1 = pos1 - dist1 , ans1 + dist1 NEW_LINE pos2 , ans2 = pos2 + dist2 , ans2 + dist2 NEW_LINE DEDENT DEDENT print ( max ( ans1 + abs ( pos1 ) , ans2 + abs ( pos2 ) ) ) NEW_LINE"],"bleu":0.052711430024549075,"rouge_l":0.3040227839088644}
{"id":67,"predictions":["n , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE ans = float ( ' inf ' ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT ans = max ( ans , ( a [ j ] ) ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["n , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE s = [ int ( input ( ) ) for i in range ( n ) ] NEW_LINE d = max ( s ) - min ( s ) NEW_LINE if d != 0 : NEW_LINE INDENT print ( b \/ d , a - ( sum ( s ) \/ n ) * ( b \/ d ) ) NEW_LINE DEDENT else : NEW_LINE INDENT if b != 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 , a - s [ 0 ] ) NEW_LINE DEDENT DEDENT"],"bleu":0.2557199190219716,"rouge_l":0.482903823479872}
{"id":68,"predictions":["n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE people = [ 0 ] * n NEW_LINE maxA = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == 0 : NEW_LINE INDENT a [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT b . append ( a [ i ] ) NEW_LINE DEDENT DEDENT b . sort ( ) NEW_LINE now = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] + b [ i - 1 ] == i : NEW_LINE INDENT b [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( b ) NEW_LINE"],"references":["n = int ( input ( ) ) NEW_LINE k = 1000000 NEW_LINE nums = [ 0 for _ in range ( k + 2 ) ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE nums [ a ] += 1 NEW_LINE nums [ b + 1 ] -= 1 NEW_LINE DEDENT for i in range ( 1 , k + 1 ) : NEW_LINE INDENT nums [ i ] += nums [ i - 1 ] NEW_LINE DEDENT print ( max ( nums ) ) NEW_LINE"],"bleu":0.3100501143978808,"rouge_l":0.4909927175162898}
{"id":69,"predictions":["x , y = map ( int , input ( ) . split ( ) ) NEW_LINE s = [ \" R \" for i in range ( 9 ) ] NEW_LINE for i in range ( 9 ) : NEW_LINE INDENT a , b = map ( str , input ( ) . split ( ) ) NEW_LINE if a == \" R \" or b == \" U \" : NEW_LINE INDENT if a == \" U \" : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif a == \" D \" : NEW_LINE INDENT b = a NEW_LINE DEDENT elif b == \" U \" : NEW_LINE INDENT if a == \" U \" : NEW_LINE INDENT b = b NEW_LINE DEDENT else : NEW_LINE INDENT b = a NEW_LINE DEDENT DEDENT elif a == \" C \" : NEW_LINE INDENT b = [ ] NEW_LINE DEDENT if len ( b ) == 3 : NEW_LINE INDENT if b == 4 : NEW_LINE INDENT print ( b ) NEW_LINE DEDENT elif b == 3 : NEW_LINE INDENT if b == \" U \" : NEW_LINE INDENT print ( a ) NEW_LINE DEDENT else : NEW_LINE INDENT b += b NEW_LINE DEDENT else : NEW_LINE INDENT b = b NEW_LINE DEDENT DEDENT DEDENT if len ( b ) == 1 : NEW_LINE INDENT print ( b ) NEW_LINE DEDENT"],"references":["x , y , w = input ( ) . split ( ) NEW_LINE x , y = int ( x ) + 7 , int ( y ) + 7 NEW_LINE A = [ input ( ) for i in range ( 9 ) ] NEW_LINE B = [ a [ 1 : ] [ : : - 1 ] + a + a [ : - 1 ] [ : : - 1 ] for a in A ] NEW_LINE C = B [ 1 : ] [ : : - 1 ] + B + B [ : - 1 ] [ : : - 1 ] NEW_LINE D = { ' R ' : ( 1 , 0 ) , ' L ' : ( - 1 , 0 ) , ' U ' : ( 0 , - 1 ) , ' D ' : ( 0 , 1 ) , ' RU ' : ( 1 , - 1 ) , ' RD ' : ( 1 , 1 ) , ' LU ' : ( - 1 , - 1 ) , ' LD ' : ( - 1 , 1 ) } NEW_LINE ans = C [ y ] [ x ] NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT dx , dy = D [ w ] NEW_LINE x += dx NEW_LINE y += dy NEW_LINE ans += C [ y ] [ x ] NEW_LINE DEDENT print ( ans ) NEW_LINE"],"bleu":0.14000393647939466,"rouge_l":0.2694057815845824}
{"id":70,"predictions":["n , k = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE"],"references":["N , K = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( ( K - 1 ) * ( N - K ) * 6 + ( N - 1 ) * 3 + 1 ) \/ N ** 3 ) NEW_LINE"],"bleu":0.2762118043982618,"rouge_l":0.529433962264151}
{"id":71,"predictions":["n = int ( input ( ) ) s = input ( ) ans = 0 for i in range ( 1 , n - 1 ) : if ( s [ i ] == ' o ' ) : ans += 1 print ( ans ) NEW_LINE"],"references":["H , W = ( 10 , 10 ) NEW_LINE field = [ list ( input ( ) ) for _ in range ( H ) ] NEW_LINE Around = [ [ 0 ] * W for _ in range ( H ) ] NEW_LINE cnt_islands = 0 NEW_LINE def dfs ( x , y ) : NEW_LINE INDENT if x < 0 or x >= W or y < 0 or y >= H or field [ y ] [ x ] == \" r \" : NEW_LINE INDENT return NEW_LINE DEDENT if field [ y ] [ x ] == \" x \" : NEW_LINE INDENT field [ y ] [ x ] = \" r \" NEW_LINE Around [ y ] [ x ] += 1 NEW_LINE return NEW_LINE DEDENT field [ y ] [ x ] = \" r \" NEW_LINE dfs ( x + 1 , y ) NEW_LINE dfs ( x - 1 , y ) NEW_LINE dfs ( x , y + 1 ) NEW_LINE dfs ( x , y - 1 ) NEW_LINE DEDENT for y in range ( H ) : NEW_LINE INDENT for x in range ( W ) : NEW_LINE INDENT if field [ y ] [ x ] == \" o \" : NEW_LINE INDENT for yr in range ( H ) : NEW_LINE INDENT for xr in range ( W ) : NEW_LINE INDENT if field [ yr ] [ xr ] == \" r \" : NEW_LINE INDENT field [ yr ] [ xr ] = \" x \" NEW_LINE DEDENT DEDENT DEDENT dfs ( x , y ) NEW_LINE cnt_islands += 1 NEW_LINE DEDENT DEDENT DEDENT if cnt_islands == 1 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT f = False NEW_LINE for y in range ( H ) : NEW_LINE INDENT for x in range ( W ) : NEW_LINE INDENT if Around [ y ] [ x ] == cnt_islands : NEW_LINE INDENT f = True NEW_LINE print ( ' YES ' ) NEW_LINE break NEW_LINE DEDENT DEDENT if f : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if not f : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT"],"bleu":0.0002389626029572697,"rouge_l":0.1366042345276873}
{"id":72,"predictions":["s = input ( ) NEW_LINE count = 0 NEW_LINE for c in s : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if count % 2 != 0 : NEW_LINE INDENT print ( \" No \" ) NEW_LINE exit ( ) NEW_LINE DEDENT print ( \" Yes \" ) NEW_LINE"],"references":["import collections NEW_LINE letter = collections . Counter ( input ( ) ) NEW_LINE counter = 0 NEW_LINE for v in letter . values ( ) : NEW_LINE INDENT if v % 2 == 1 : NEW_LINE INDENT counter += 1 NEW_LINE break NEW_LINE DEDENT DEDENT print ( \" Yes \" ) if counter == 0 else print ( \" No \" ) NEW_LINE"],"bleu":0.3248418855408559,"rouge_l":0.5149127743387732}
{"id":73,"predictions":["n , m = map ( int , input ( ) . split ( ) ) NEW_LINE x , y = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE Y = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT x1 , y = map ( int , input ( ) . split ( ) ) NEW_LINE x2 , y1 = ( x - 1 ) , y * 2 + y2 NEW_LINE if x1 < y : NEW_LINE INDENT max ( max ( max ( x1 - 1 ) + y2 , x2 - y2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT max = max ( max ( abs ( x1 - 1 ) + abs ( y2 - y2 ) - y1 ) * 2 + y2 ) NEW_LINE DEDENT DEDENT print ( max ( 9 - n ) ) NEW_LINE"],"references":["L , N = map ( int , input ( ) . split ( ) ) NEW_LINE X = [ 0 ] NEW_LINE for _ in range ( N ) : NEW_LINE INDENT X . append ( int ( input ( ) ) ) NEW_LINE DEDENT s = [ 0 ] * ( N + 1 ) NEW_LINE t = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT s [ i ] = s [ i - 1 ] + X [ i ] NEW_LINE t [ i ] = t [ i - 1 ] + ( L - X [ N - i + 1 ] ) NEW_LINE DEDENT Y = [ 0 ] + [ L - X [ N - i ] for i in range ( N ) ] NEW_LINE def get_d ( s , x , i ) : NEW_LINE INDENT if i == N : NEW_LINE INDENT return x [ N ] NEW_LINE DEDENT a = i + ( N - i ) \/\/ 2 NEW_LINE return ( 2 * ( s [ a ] - s [ i - 1 ] + L * ( N - a ) - s [ N ] + s [ a ] ) - ( x [ a ] if ( N - i ) % 2 == 0 else ( L - x [ a + 1 ] ) ) ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT ans = max ( ans , get_d ( s , X , i ) , get_d ( t , Y , i ) ) NEW_LINE DEDENT print ( ans ) NEW_LINE"],"bleu":0.1717271913771777,"rouge_l":0.36460299484082037}
{"id":74,"predictions":["import sys NEW_LINE import collections NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE INF = float ( ' inf ' ) NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def f ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( sys . stdin . readline ( ) . strip ( ) ) NEW_LINE a = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a = a . readline ( ) . split ( ) ) NEW_LINE count = collections . Counter ( a ) NEW_LINE DEDENT print ( count ( a ) ) NEW_LINE"],"references":["from collections import Counter NEW_LINE input ( ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE A . sort ( reverse = True ) NEW_LINE C = Counter ( A ) NEW_LINE ans = 0 NEW_LINE for a in A : NEW_LINE INDENT if not C [ a ] : NEW_LINE INDENT continue NEW_LINE DEDENT C [ a ] -= 1 NEW_LINE t = 2 ** a . bit_length ( ) - a NEW_LINE if C [ t ] : NEW_LINE INDENT C [ t ] -= 1 NEW_LINE ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"bleu":0.13152768853665006,"rouge_l":0.32189973614775724}
{"id":75,"predictions":["N , C = map ( int , input ( ) . split ( ) ) NEW_LINE X = list ( map ( int , input ( ) . split ( ' ▁ ' ) ) ) NEW_LINE V = list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE dp = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT x = list ( map ( int , input ( ) . split ( ' ▁ ' ) ) ) [ i + 1 ] NEW_LINE dp [ i + 1 ] = 0 NEW_LINE DEDENT dp = [ 0 for i in range ( N + 1 ) ] NEW_LINE dp [ 1 ] = [ 0 ] * ( N + 1 ) NEW_LINE dp [ 2 ] = [ - 1 ] * ( N + 1 ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if dp [ i ] [ 1 ] > X : NEW_LINE INDENT dp [ i + 1 ] = max ( dp [ i ] , dp [ i + 1 ] [ 0 ] - x [ 1 ] ) NEW_LINE DEDENT dp [ - 1 ] = max ( dp [ - 1 ] , dp [ - 1 ] ) + dp [ i + 1 ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT ans = max ( ans , dp [ i ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE"],"references":["N , C = [ int ( _ ) for _ in input ( ) . split ( ) ] NEW_LINE X = [ 0 ] * N NEW_LINE V = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT X [ i ] , V [ i ] = [ int ( _ ) for _ in input ( ) . split ( ) ] NEW_LINE DEDENT def calc ( X , V ) : NEW_LINE INDENT Vcumsum = [ 0 ] NEW_LINE for v in V : NEW_LINE INDENT Vcumsum += [ Vcumsum [ - 1 ] + v ] NEW_LINE DEDENT cumsum = [ 0 ] * ( N + 1 ) NEW_LINE cumsum_r = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT cumsum [ i + 1 ] = Vcumsum [ i + 1 ] - X [ i ] NEW_LINE cumsum_r [ i + 1 ] = Vcumsum [ N ] - Vcumsum [ N - i - 1 ] - ( C - X [ - 1 - i ] ) NEW_LINE DEDENT cumsum_max = [ 0 ] * ( N + 1 ) NEW_LINE cumsum_r_max = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT cumsum_max [ i + 1 ] = max ( cumsum [ i + 1 ] , cumsum_max [ i ] ) NEW_LINE cumsum_r_max [ i + 1 ] = max ( cumsum_r [ i + 1 ] , cumsum_r_max [ i ] ) NEW_LINE DEDENT res = max ( cumsum_max [ - 1 ] , cumsum_r_max [ - 1 ] ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT res = max ( res , cumsum_max [ i + 1 ] + cumsum_r_max [ N - i - 1 ] - X [ i ] , cumsum_r_max [ i + 1 ] + cumsum_max [ N - i - 1 ] - ( C - X [ - 1 - i ] ) ) NEW_LINE DEDENT return res NEW_LINE DEDENT print ( calc ( X , V ) ) NEW_LINE"],"bleu":0.35709859192086535,"rouge_l":0.48740196078431364}
{"id":76,"predictions":["a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( a - 1 ) * b - 1 ) NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( n - 1 ) * ( m - 1 ) ) NEW_LINE"],"bleu":0.6614980770342949,"rouge_l":0.8338590956887485}
{"id":77,"predictions":["n , ma , m = map ( int , input ( ) . split ( ) ) NEW_LINE marks = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE marks . append ( ( a - b , c ) ) NEW_LINE DEDENT dp = [ [ 0 for _ for _ in range ( n + 1 ) ] for _ in range ( m ) ] NEW_LINE dp [ 0 ] [ 1 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( m * n + 1 ) : NEW_LINE INDENT if j >= n : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ j ] [ k - i - b ] , c + dp [ i - b ] [ j ] ) NEW_LINE DEDENT DEDENT if dp [ k ] [ k ] == 1 : NEW_LINE INDENT dp [ k ] [ 0 ] = min ( dp [ 0 ] [ k - 1 ] , dp [ 1 ] [ 0 ] ) NEW_LINE DEDENT DEDENT ans = sys . maxsize NEW_LINE print ( ans ) NEW_LINE"],"references":["NM = 40 NEW_LINE ABM = 10 NEW_LINE MM = 400 NEW_LINE N , M1 , M2 = map ( int , input ( ) . split ( ) ) NEW_LINE A = [ ] NEW_LINE B = [ ] NEW_LINE C = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE A . append ( a ) NEW_LINE B . append ( b ) NEW_LINE C . append ( c ) NEW_LINE DEDENT cmax = max ( C ) NEW_LINE CM = N * cmax + 10 NEW_LINE dp = [ [ [ CM for broop in range ( 401 ) ] for aroop in range ( 401 ) ] for nroop in range ( N + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] [ 0 ] = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for cb in range ( 401 ) : NEW_LINE INDENT for ca in range ( 401 ) : NEW_LINE INDENT if dp [ i ] [ ca ] [ cb ] == CM : NEW_LINE INDENT continue NEW_LINE DEDENT dp [ i + 1 ] [ ca ] [ cb ] = min ( dp [ i + 1 ] [ ca ] [ cb ] , dp [ i ] [ ca ] [ cb ] ) NEW_LINE if ca + A [ i ] < 401 and cb + B [ i ] < 401 : NEW_LINE INDENT dp [ i + 1 ] [ ca + A [ i ] ] [ cb + B [ i ] ] = min ( dp [ i + 1 ] [ ca + A [ i ] ] [ cb + B [ i ] ] , dp [ i ] [ ca ] [ cb ] + C [ i ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = CM NEW_LINE for cb in range ( 400 ) : NEW_LINE INDENT for ca in range ( 400 ) : NEW_LINE INDENT CB = cb + 1 NEW_LINE CA = ca + 1 NEW_LINE if CA * M2 == CB * M1 : NEW_LINE INDENT ans = min ( ans , dp [ N ] [ CA ] [ CB ] ) NEW_LINE DEDENT DEDENT DEDENT if ans == CM : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT"],"bleu":0.22478833374536483,"rouge_l":0.4777767292629989}
{"id":78,"predictions":["a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( 100 * ( 100 ** ( 100 * b ) ) ) NEW_LINE"],"references":["D , N = map ( int , input ( ) . split ( ) ) NEW_LINE count = 0 NEW_LINE x = 0 NEW_LINE while count != N : NEW_LINE INDENT x += 1 NEW_LINE if x % 100 ** D == 0 and x % 100 ** ( D + 1 ) != 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( x ) NEW_LINE"],"bleu":0.1606456739720383,"rouge_l":0.40421686746987956}
{"id":79,"predictions":["N = int ( input ( ) ) NEW_LINE print ( N \/\/ 3 ) NEW_LINE"],"references":["print ( int ( input ( ) ) \/\/ 3 ) NEW_LINE"],"bleu":0.5312583871630396,"rouge_l":0.7331730769230769}
{"id":80,"predictions":["C = input ( ) NEW_LINE print ( ' A ' + C \" C \" , \" C \" if C \" in C else \" ) NEW_LINE"],"references":["print ( \" A \" + input ( ) [ 8 ] + \" C \" ) NEW_LINE"],"bleu":0.16436148154531297,"rouge_l":0.3998543335761107}
{"id":81,"predictions":["S = input ( ) NEW_LINE l = len ( S ) NEW_LINE for i in range ( len ( S ) ) : NEW_LINE INDENT if L [ len ( s ) - 1 ] == ' T ' : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"references":["s = input ( ) NEW_LINE if ( s [ - 1 ] == \" T \" ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"],"bleu":0.4815282420378727,"rouge_l":0.7139141742522757}
{"id":82,"predictions":["n = int ( input ( ) ) NEW_LINE prev = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if prev == prev : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT prev = 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if a [ i ] == a [ i - 1 ] : NEW_LINE INDENT ans += 1 NEW_LINE a [ i ] = ' x ' NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"bleu":0.3665978121175001,"rouge_l":0.6012814194184327}
{"id":83,"predictions":["def inpl ( ) : return [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE N , X = inpl ( ) NEW_LINE pre = [ 0 ] * N NEW_LINE i = 0 NEW_LINE while i <= N : NEW_LINE INDENT i += 1 NEW_LINE if i >= 0 : NEW_LINE INDENT break NEW_LINE DEDENT pre [ i + 1 ] = pre [ i ] NEW_LINE i += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print ( X * N + 5 ) NEW_LINE"],"references":["iN , iX = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE aX = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE aCum = [ 0 ] * iN NEW_LINE aCum [ 0 ] = aX [ 0 ] NEW_LINE for i in range ( 1 , iN ) : NEW_LINE INDENT aCum [ i ] = aCum [ i - 1 ] + aX [ i ] NEW_LINE DEDENT def fCeil ( iT , iR ) : NEW_LINE INDENT return - 1 * iT \/\/ iR * - 1 NEW_LINE DEDENT def fCalcCost ( iN , iX , aCum , iK ) : NEW_LINE INDENT return ( iN + iK ) * iX + 5 * aCum [ - 1 ] + sum ( 2 * aCum [ - i * iK - 1 ] for i in range ( 2 , fCeil ( iN , iK ) ) ) NEW_LINE DEDENT iTotalCost = fCalcCost ( iN , iX , aCum , 1 ) NEW_LINE iULim = fCeil ( iN , 2 ) + 1 NEW_LINE for iK in range ( 2 , fCeil ( iN , 2 ) + 1 ) : NEW_LINE INDENT iThisCost = fCalcCost ( iN , iX , aCum , iK ) NEW_LINE if iThisCost > iTotalCost : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT iTotalCost = iThisCost NEW_LINE DEDENT DEDENT print ( iTotalCost ) NEW_LINE"],"bleu":0.0658094947019858,"rouge_l":0.2984187996855071}
{"id":84,"predictions":["a , b = map ( int , input ( ) . split ( ) ) NEW_LINE h , a = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( a + b \/\/ 2 ) * ( a + b \/\/ 2 ) ) NEW_LINE"],"references":["a , b , h = map ( int , open ( 0 ) . read ( ) . split ( ) ) NEW_LINE S = int ( ( a + b ) * h \/ 2 ) NEW_LINE print ( S ) NEW_LINE"],"bleu":0.38525499743167674,"rouge_l":0.629082158817463}
{"id":85,"predictions":["n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s [ i ] = input ( ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT if s [ j ] . is True : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["field = [ ] NEW_LINE n = int ( input ( ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT field . append ( list ( map ( str , input ( ) ) ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ' . ' in field [ i ] : NEW_LINE INDENT j = n - field [ i ] [ : : - 1 ] . index ( ' . ' ) - 1 NEW_LINE field [ i ] = [ ' o ' ] * n NEW_LINE if i != n - 1 : NEW_LINE INDENT field [ i + 1 ] [ j : ] = [ ' O ' ] * len ( field [ i + 1 ] [ j : ] ) NEW_LINE DEDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"bleu":0.19878679899046553,"rouge_l":0.45173017369058843}
{"id":86,"predictions":["n = int ( input ( ) ) NEW_LINE t = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT t . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT tot = 0 NEW_LINE t = [ 0 ] * ( n + 2 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if t [ i ] < t [ i ] : NEW_LINE INDENT tot += t [ i ] NEW_LINE DEDENT elif t [ i ] > t [ i - 1 ] : NEW_LINE INDENT tot += t [ i - 1 ] [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT tot += t [ i ] [ 1 ] = 1 NEW_LINE DEDENT DEDENT return tot NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = input ( ) NEW_LINE print ( solve ( ) ) NEW_LINE DEDENT"],"references":["n = int ( input ( ) ) NEW_LINE t = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE v = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE maxspeed = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT maxspeed [ i ] = min ( v [ i ] , v [ i - 1 ] , t [ i ] + maxspeed [ i + 1 ] ) NEW_LINE DEDENT def dist ( i , first ) : NEW_LINE INDENT ta = v [ i ] - first NEW_LINE tb = v [ i ] - maxspeed [ i + 1 ] NEW_LINE if ta + tb <= t [ i ] : NEW_LINE INDENT c = ( first + v [ i ] ) * ta \/ 2 + v [ i ] * ( t [ i ] - ta - tb ) + ( maxspeed [ i + 1 ] + v [ i ] ) * tb \/ 2 NEW_LINE lastspeed = maxspeed [ i + 1 ] NEW_LINE DEDENT elif maxspeed [ i + 1 ] - first > t [ i ] : NEW_LINE INDENT c = ( first + first + t [ i ] ) * t [ i ] \/ 2 NEW_LINE lastspeed = first + t [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT a = ( maxspeed [ i + 1 ] + t [ i ] - first ) \/ 2 NEW_LINE c = ( first + first + a ) * a \/ 2 + ( first + a + maxspeed [ i + 1 ] ) * ( t [ i ] - a ) \/ 2 NEW_LINE lastspeed = maxspeed [ i + 1 ] NEW_LINE DEDENT return c , lastspeed NEW_LINE DEDENT ans = 0 NEW_LINE firstspeed = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT d , firstspeed = dist ( i , firstspeed ) NEW_LINE ans += d NEW_LINE DEDENT print ( ans ) NEW_LINE"],"bleu":0.1774865335984506,"rouge_l":0.4072898423817864}
{"id":87,"predictions":["n , m = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE t = [ 0 ] * n NEW_LINE for i in range ( m ) : NEW_LINE INDENT l , r = map ( int , input ( ) . split ( ) ) NEW_LINE s [ l - 1 ] -= 1 NEW_LINE t [ i ] += s [ i - 1 ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if t [ i ] != m - 1 : NEW_LINE INDENT ans += s [ i ] - s [ i ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["import itertools NEW_LINE N , M = map ( int , input ( ) . split ( ) ) NEW_LINE score = [ 0 ] * ( M + 1 ) NEW_LINE s_sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT l , r , s = map ( int , input ( ) . split ( ) ) NEW_LINE score [ ( l - 1 ) ] += s NEW_LINE score [ r ] += - s NEW_LINE s_sum += s NEW_LINE DEDENT score_list = list ( itertools . accumulate ( score ) ) NEW_LINE ans = s_sum - min ( score_list [ : - 1 ] ) NEW_LINE print ( ans ) NEW_LINE"],"bleu":0.43684297381567727,"rouge_l":0.6063129617192747}
{"id":88,"predictions":["D = list ( input ( ) ) NEW_LINE if D [ d for d in range ( 22 ) ] [ 0 ] == 23 : NEW_LINE INDENT for i in range ( 1 , 22 ) : NEW_LINE INDENT if S [ i ] [ 0 ] == 18 : NEW_LINE INDENT l = i + 1 NEW_LINE DEDENT elif s [ i ] [ 1 ] == 26 : NEW_LINE INDENT l = 3 NEW_LINE DEDENT elif s [ i ] == 26 : NEW_LINE INDENT l = list ( l ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( l ) NEW_LINE DEDENT"],"references":["D = int ( input ( ) ) NEW_LINE print ( \" Christmas \" + \" ▁ Eve \" * ( 25 - D ) ) NEW_LINE"],"bleu":0.06919032690457734,"rouge_l":0.23257080610021785}
{"id":89,"predictions":["n , a = map ( int , input ( ) . split ( \" ▁ \" ) ) NEW_LINE flag = True NEW_LINE if n == 1 : NEW_LINE INDENT print ( \" Not ▁ Ant \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ Ant \" ) NEW_LINE DEDENT"],"references":["n , a , b = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE num = n % ( a + b ) NEW_LINE if num == 0 : NEW_LINE INDENT print ( \" Bug \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Ant \" if num <= a else \" Bug \" ) NEW_LINE DEDENT"],"bleu":0.3749015770071666,"rouge_l":0.6222861626994507}
{"id":90,"predictions":["s = input ( ) NEW_LINE b = ' ' NEW_LINE for i in range ( len ( b ) ) : NEW_LINE INDENT if b [ i ] == ' L ' : NEW_LINE INDENT b += ' < ' NEW_LINE DEDENT elif b [ i ] == ' R ' : NEW_LINE INDENT b += ' < ' NEW_LINE DEDENT elif b [ i ] == ' L ' : NEW_LINE INDENT b += ' A ' NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT b += ' < ' : NEW_LINE DEDENT DEDENT print ( b ) NEW_LINE"],"references":["n = input ( ) NEW_LINE print ( n . replace ( \" Right \" , \" > \" ) . replace ( \" AtCoder \" , \" A \" ) . replace ( \" Left \" , \" < \" ) ) NEW_LINE"],"bleu":0.06292194559892642,"rouge_l":0.17923604309500493}
{"id":91,"predictions":["a = input ( ) . split ( ) NEW_LINE X = input ( ) NEW_LINE if X [ 0 ] == X [ 1 ] and X [ 2 ] == X [ 3 ] : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["num = input ( ) NEW_LINE print ( \" Yes \" if num [ 0 ] == num [ 1 ] == num [ 2 ] or num [ 1 ] == num [ 2 ] == num [ 3 ] else \" No \" ) NEW_LINE"],"bleu":0.3084846429701901,"rouge_l":0.5200505209977897}
{"id":92,"predictions":["import sys NEW_LINE input = sys . stdin . readline NEW_LINE N , K = map ( int , input ( ) . split ( ) ) NEW_LINE d = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT d = { } NEW_LINE for x in d : NEW_LINE INDENT if x in d : NEW_LINE INDENT d [ x ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ x ] = 1 NEW_LINE DEDENT DEDENT d [ K ] = sorted ( d . items ( ) ) NEW_LINE d . sort ( reverse = True ) NEW_LINE if d [ K ] < 0 : NEW_LINE INDENT print ( d [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( d [ K ] ) NEW_LINE DEDENT DEDENT"],"references":["def main ( ) : NEW_LINE INDENT from collections import Counter NEW_LINE n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for index , ( key , value ) in enumerate ( sorted ( Counter ( a ) . items ( ) , key = lambda x : x [ 1 ] , reverse = True ) , 1 ) : NEW_LINE INDENT if index > k : NEW_LINE INDENT ans += value NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"bleu":0.2481894081375479,"rouge_l":0.39644389944819136}
{"id":93,"predictions":["n , a , b , c , d = map ( int , input ( ) . split ( ' ▁ ' ) ) NEW_LINE a * b NEW_LINE b = list ( map ( int , input ( ) . split ( ' ▁ ' ) ) ) NEW_LINE ans = max ( a * b , c ) NEW_LINE print ( ans ) NEW_LINE"],"references":["a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if a [ 0 ] * a [ 1 ] == a [ 2 ] * a [ 3 ] : NEW_LINE INDENT print ( a [ 0 ] * a [ 1 ] ) NEW_LINE DEDENT elif a [ 0 ] * a [ 1 ] > a [ 2 ] * a [ 3 ] : NEW_LINE INDENT print ( a [ 0 ] * a [ 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a [ 2 ] * a [ 3 ] ) NEW_LINE DEDENT"],"bleu":0.1490445701036823,"rouge_l":0.3247559893522626}
{"id":94,"predictions":["a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( b - a % b ) % b ) NEW_LINE"],"references":["a = int ( input ( ) ) NEW_LINE b = int ( input ( ) ) NEW_LINE print ( b - a % b if a % b != 0 else 0 ) NEW_LINE"],"bleu":0.37510744551933123,"rouge_l":0.6373134328358209}
{"id":95,"predictions":["W , h = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 10 ** 9 + 7 NEW_LINE def calc ( W , h ) : NEW_LINE INDENT if w == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = 1 NEW_LINE DEDENT for i in range ( 1 , W + 1 ) : NEW_LINE INDENT a *= i NEW_LINE b = 2 * i NEW_LINE DEDENT return a NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( solve ( W , h ) ) NEW_LINE DEDENT"],"references":["x , y = map ( int , input ( ) . split ( ) ) NEW_LINE x , y = x - 1 , y - 1 NEW_LINE mod = 1000000007 NEW_LINE c = 1 NEW_LINE for i in range ( min ( x , y ) ) : NEW_LINE INDENT c = ( c * ( x + y - i ) * pow ( i + 1 , mod - 2 , mod ) % mod ) NEW_LINE DEDENT print ( c % mod ) NEW_LINE"],"bleu":0.24562586278326026,"rouge_l":0.4339430894308943}
{"id":96,"predictions":["def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return a \/ b NEW_LINE DEDENT return gcd ( a , b ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE c = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( \" Takahashi \" ) NEW_LINE DEDENT"],"references":["def extgcd ( a , b ) : NEW_LINE INDENT if b : NEW_LINE INDENT d , y , x = extgcd ( b , a % b ) NEW_LINE y -= ( a \/ b ) * x NEW_LINE return d , x , y NEW_LINE DEDENT else : NEW_LINE INDENT return a , 1 , 0 NEW_LINE DEDENT DEDENT N = int ( input ( ) ) NEW_LINE grundy = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT a , k = map ( int , input ( ) . split ( ) ) NEW_LINE while a % k : NEW_LINE INDENT p , q = divmod ( a , k ) NEW_LINE a -= ( p + 1 ) * ( ( q + p ) \/\/ ( p + 1 ) ) NEW_LINE DEDENT grundy ^= a \/\/ k NEW_LINE DEDENT print ( ' Takahashi ' if grundy else ' Aoki ' ) NEW_LINE"],"bleu":0.19412522118752387,"rouge_l":0.43289342629482075}
{"id":97,"predictions":["import sys NEW_LINE input = sys . stdin . readline NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE x = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] NEW_LINE y = sorted ( a ) NEW_LINE if x == 0 : NEW_LINE INDENT print ( a [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT x [ 1 ] = x [ 0 ] + 1 NEW_LINE DEDENT"],"references":["N , M = map ( int , input ( ) . split ( ) ) NEW_LINE py = [ ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT py . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE py [ i ] . append ( i ) NEW_LINE DEDENT py . sort ( key = lambda x : ( x [ 0 ] , x [ 1 ] ) ) NEW_LINE number = [ ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT ct = 1 NEW_LINE number . append ( ( str ( py [ i ] [ 0 ] ) . zfill ( 6 ) + str ( ct ) . zfill ( 6 ) , py [ i ] [ 2 ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT if py [ i - 1 ] [ 0 ] == py [ i ] [ 0 ] : NEW_LINE INDENT ct += 1 NEW_LINE number . append ( ( str ( py [ i ] [ 0 ] ) . zfill ( 6 ) + str ( ct ) . zfill ( 6 ) , py [ i ] [ 2 ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT ct = 1 NEW_LINE number . append ( ( str ( py [ i ] [ 0 ] ) . zfill ( 6 ) + str ( ct ) . zfill ( 6 ) , py [ i ] [ 2 ] ) ) NEW_LINE DEDENT DEDENT DEDENT number . sort ( key = lambda x : x [ 1 ] ) NEW_LINE for i in number : NEW_LINE INDENT print ( i [ 0 ] ) NEW_LINE DEDENT"],"bleu":0.08869064824005758,"rouge_l":0.32882915259110185}
{"id":98,"predictions":["import heapq NEW_LINE n , k = map ( int , input ( ) . split ( ) ) NEW_LINE b = [ 0 ] * ( n + 1 ) NEW_LINE c = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE b = [ ] NEW_LINE c = [ ] for i in range ( n ) : NEW_LINE"],"references":["N , K , Q = map ( int , input ( ) . split ( ) ) NEW_LINE As = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 10 ** 9 NEW_LINE for Y in sorted ( As ) [ : N - Q - K + 2 ] : NEW_LINE INDENT cands = [ ] NEW_LINE cs = [ ] NEW_LINE for A in As + [ 0 ] : NEW_LINE INDENT if A < Y : NEW_LINE INDENT if len ( cs ) >= K : NEW_LINE INDENT cands += sorted ( cs ) [ : len ( cs ) - K + 1 ] NEW_LINE DEDENT cs = [ ] NEW_LINE DEDENT else : NEW_LINE INDENT cs += [ A ] NEW_LINE DEDENT DEDENT if len ( cands ) < Q : continue NEW_LINE X = sorted ( cands ) [ Q - 1 ] NEW_LINE ans = min ( ans , X - Y ) NEW_LINE DEDENT print ( ans ) NEW_LINE"],"bleu":0.08693568489890897,"rouge_l":0.30134617759664073}
{"id":99,"predictions":["List = [ input ( ) for i in range ( 2 ) ] NEW_LINE"],"references":["a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( b , a ) NEW_LINE"],"bleu":0.09992242441705818,"rouge_l":0.34463276836158196}
{"id":100,"predictions":["n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE s = ' ' NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == s [ j ] : NEW_LINE INDENT continue NEW_LINE DEDENT x = s . replace ( ' . ' , ' L ' ) + s [ j ] NEW_LINE y = len ( x ) NEW_LINE if y == k : NEW_LINE INDENT y = ' ' . join ( y ) NEW_LINE DEDENT DEDENT DEDENT print ( len ( y ) ) NEW_LINE"],"references":["from itertools import product NEW_LINE import re NEW_LINE def inpl ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE N = int ( input ( ) ) NEW_LINE C = input ( ) NEW_LINE ans = 2000 NEW_LINE for X in product ( \" ABXY \" , repeat = 4 ) : NEW_LINE INDENT L = \" \" . join ( X [ : 2 ] ) NEW_LINE R = \" \" . join ( X [ 2 : ] ) NEW_LINE ans = min ( ans , len ( C . replace ( L , \" L \" ) . replace ( R , \" R \" ) ) ) NEW_LINE DEDENT print ( ans ) NEW_LINE"],"bleu":0.17983713064343818,"rouge_l":0.366293034427542}
{"id":101,"predictions":["N = int ( input ( ) ) NEW_LINE a = sorted ( [ int ( x ) for x in input ( ) . split ( ' ▁ ' ) ] ) NEW_LINE print ( a ) NEW_LINE"],"references":["N = int ( input ( ) ) NEW_LINE A = sorted ( [ int ( i ) for i in input ( ) . split ( ) ] , reverse = True ) NEW_LINE print ( sum ( A [ : : 2 ] ) ) NEW_LINE"],"bleu":0.4631070130114317,"rouge_l":0.722160562338143}
{"id":102,"predictions":["n = int ( input ( ) ) NEW_LINE x = [ ] NEW_LINE for i in range ( n ) : x = input ( ) NEW_LINE x = list ( input ( ) ) NEW_LINE y = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if x [ i ] == \" x \" : NEW_LINE INDENT x = i NEW_LINE DEDENT elif x [ i ] == \" x \" : NEW_LINE INDENT y = list ( \" . \" ) NEW_LINE ans = 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if y [ i ] == \" x \" : NEW_LINE INDENT ans = sorted ( ans ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["n = int ( input ( ) ) NEW_LINE l = [ input ( ) for i in range ( n ) ] NEW_LINE sum = 0 NEW_LINE for i in range ( len ( l ) ) : NEW_LINE INDENT for j in range ( 9 ) : NEW_LINE INDENT if l [ i ] [ j ] == ' x ' : NEW_LINE INDENT sum += 1 NEW_LINE DEDENT elif l [ i ] [ j ] == ' o ' and ( i + 1 == len ( l ) or l [ i + 1 ] [ j ] != ' o ' ) : NEW_LINE INDENT sum += 1 NEW_LINE DEDENT DEDENT DEDENT print ( sum ) NEW_LINE"],"bleu":0.33091427288990716,"rouge_l":0.5226535116188499}
{"id":103,"predictions":["from collections import defaultdict , deque NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE red = defaultdict ( int ) NEW_LINE for _ in range ( m ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a != b : NEW_LINE INDENT return False NEW_LINE DEDENT red [ a ] = True NEW_LINE for b in range ( m ) : NEW_LINE INDENT if red [ b ] ] > NEW_LINE red [ b ] = True NEW_LINE DEDENT DEDENT def g ( a , b ) : NEW_LINE INDENT if b == 1 : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT def b ( c ) : NEW_LINE INDENT if b == 1 : NEW_LINE INDENT return False NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if b [ i ] in visited : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT input ( ) = sys . stdin . readline ( ) . split ( ) NEW_LINE N , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = map ( int , input ( ) . split ( ) ) NEW_LINE b = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE A . append ( ( b ) ) NEW_LINE b [ x ] = 1 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if check ( A , i ) ) : NEW_LINE INDENT b [ i ] = False NEW_LINE DEDENT DEDENT print ( b ) NEW_LINE DEDENT"],"references":["n , m = map ( int , input ( ) . split ( ) ) NEW_LINE X = [ [ ] for _ in range ( n ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE X [ a - 1 ] . append ( b - 1 ) NEW_LINE X [ b - 1 ] . append ( a - 1 ) NEW_LINE DEDENT path = [ i for i in range ( 2 , n + 1 ) ] NEW_LINE visited = [ 1 ] + [ 0 ] * ( n - 1 ) NEW_LINE def dfs ( v ) : NEW_LINE INDENT if visited == [ 1 ] * n : NEW_LINE INDENT return 1 NEW_LINE DEDENT res = 0 NEW_LINE for x in X [ v ] : NEW_LINE INDENT if visited [ x ] == 0 : NEW_LINE INDENT visited [ x ] = 1 NEW_LINE res += dfs ( x ) NEW_LINE visited [ x ] = 0 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT print ( dfs ( 0 ) ) NEW_LINE"],"bleu":0.29231594379370013,"rouge_l":0.4701112451414019}
{"id":104,"predictions":["n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE count = 0 NEW_LINE m = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] % 2 == 0 : NEW_LINE INDENT m += ( 2 * n - i ) \/\/ 2 NEW_LINE DEDENT else : NEW_LINE INDENT count += m \/\/ 2 * n NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE"],"references":["N , M = map ( int , input ( ) . split ( ) ) NEW_LINE S_num = N NEW_LINE cc_num = M \/\/ 2 NEW_LINE if ( S_num <= cc_num ) : NEW_LINE INDENT ans = ( S_num + cc_num ) \/\/ 2 NEW_LINE DEDENT else : NEW_LINE INDENT ans = cc_num NEW_LINE DEDENT print ( ans ) NEW_LINE"],"bleu":0.28721402241690086,"rouge_l":0.5280242371781}
{"id":105,"predictions":["s = input ( ) NEW_LINE k = 0 NEW_LINE l = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( '1' == '1' ) : NEW_LINE INDENT k = 1 NEW_LINE DEDENT else : NEW_LINE INDENT l += 1 NEW_LINE DEDENT DEDENT print ( \"1\" ) NEW_LINE"],"references":["s = input ( ) NEW_LINE K = int ( input ( ) ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if i == K - 1 : NEW_LINE INDENT print ( s [ i ] ) NEW_LINE break NEW_LINE DEDENT if s [ i ] == '1' : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT print ( s [ i ] ) NEW_LINE break NEW_LINE DEDENT DEDENT"],"bleu":0.35258722269433057,"rouge_l":0.5556088207094918}
{"id":106,"predictions":["n = int ( input ( ) ) NEW_LINE a = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] != a [ - 1 ] : NEW_LINE INDENT print ( i + 1 ) NEW_LINE break NEW_LINE DEDENT DEDENT print ( a [ - 1 ] ) NEW_LINE"],"references":["n = int ( input ( ) ) NEW_LINE a = [ int ( input ( ) ) for i in range ( n ) ] NEW_LINE a = sorted ( set ( a ) , reverse = True ) NEW_LINE if len ( a ) > 1 : NEW_LINE INDENT print ( a [ 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a [ 0 ] ) NEW_LINE DEDENT"],"bleu":0.4402002845439801,"rouge_l":0.596047079724628}
{"id":107,"predictions":["n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT a = list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE x = a * b NEW_LINE y = y * c NEW_LINE print ( mod ) NEW_LINE DEDENT"],"references":["A , B , C = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( A * B * C ) % 1000000007 ) NEW_LINE"],"bleu":0.27295504833062295,"rouge_l":0.4302507836990596}
{"id":108,"predictions":["N , P = map ( int , input ( ) . split ( ) ) NEW_LINE even = 0 NEW_LINE if p % 2 == 0 : NEW_LINE INDENT even += 1 NEW_LINE DEDENT elif p % 2 == 0 : NEW_LINE INDENT even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT if odd == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT"],"references":["N , P = map ( int , input ( ) . split ( ) ) NEW_LINE lst_A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE lst_odd_even = [ x % 2 for x in lst_A ] NEW_LINE if 1 in lst_odd_even : NEW_LINE INDENT ans = 2 ** ( N - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT if P == 0 : NEW_LINE INDENT ans = 2 ** N NEW_LINE DEDENT else : NEW_LINE INDENT ans = 0 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"bleu":0.3643207226303982,"rouge_l":0.5382676030974249}
{"id":109,"predictions":["n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( len ( l ) ) : if ( l [ i ] [ i + 1 ] ) >= 3 : print ( i ) else : print ( 1 ) NEW_LINE"],"references":["s = input ( ) . split ( ) NEW_LINE t = input ( ) NEW_LINE r = input ( ) . split ( ) NEW_LINE if s == r : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT elif len ( set ( s + [ t ] ) & set ( r ) ) == 6 : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT f = 8 - len ( set ( s ) & set ( r ) ) NEW_LINE if f < 6 : NEW_LINE INDENT print ( f ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT"],"bleu":0.11161804623573333,"rouge_l":0.34969544965962024}
{"id":110,"predictions":["import sys NEW_LINE from collections import deque NEW_LINE class Graph : NEW_LINE INDENT def __init__ ( self , x , y ) : NEW_LINE INDENT self . children = [ ] NEW_LINE self . append ( x , y ) NEW_LINE DEDENT DEDENT def read_input ( ) : NEW_LINE INDENT return sys . stdin . readline ( ) . strip ( ) NEW_LINE DEDENT def read_input ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a <= b : NEW_LINE INDENT t = self . gcd ( a , b ) NEW_LINE DEDENT else : NEW_LINE INDENT t = b NEW_LINE c = c + 1 NEW_LINE DEDENT DEDENT return len ( t ) == 0 NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE v = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a <= b : NEW_LINE INDENT continue NEW_LINE DEDENT v . add ( a ) NEW_LINE if v [ 0 ] < y [ 1 ] : NEW_LINE INDENT v . add ( abs ( a [ 1 ] - b [ 1 ] ) ) * 5 + 1 NEW_LINE DEDENT else : NEW_LINE INDENT v . add ( b ) NEW_LINE DEDENT DEDENT return n - 1 NEW_LINE DEDENT print ( len ( v ) ) NEW_LINE DEDENT"],"references":["def LIS ( L ) : NEW_LINE INDENT from bisect import bisect NEW_LINE best = [ ] NEW_LINE for i in L : NEW_LINE INDENT pos = bisect ( best , i ) NEW_LINE if len ( best ) <= pos : NEW_LINE INDENT best . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT best [ pos ] = i NEW_LINE DEDENT DEDENT return len ( best ) NEW_LINE DEDENT import math NEW_LINE x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) NEW_LINE N = int ( input ( ) ) NEW_LINE W = abs ( x2 - x1 ) NEW_LINE H = abs ( y2 - y1 ) NEW_LINE xsgn = 2 * ( x2 > x1 ) - 1 NEW_LINE ysgn = 2 * ( y2 > y1 ) - 1 NEW_LINE XY = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE if ( x - x1 ) * ( x - x2 ) <= 0 and ( y - y1 ) * ( y - y2 ) <= 0 : NEW_LINE INDENT XY += [ [ xsgn * ( x - x1 ) , ysgn * ( y - y1 ) ] ] NEW_LINE DEDENT DEDENT N = len ( XY ) NEW_LINE short = 20 - 5 * math . pi NEW_LINE long = 10 * math . pi - 20 NEW_LINE straight = 100 * ( W + H ) NEW_LINE XY . sort ( ) NEW_LINE Y = [ y for x , y in XY ] NEW_LINE fountain = LIS ( Y ) NEW_LINE if fountain < min ( W , H ) + 1 : NEW_LINE INDENT print ( straight - short * fountain ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( straight - short * ( fountain - 1 ) + long ) NEW_LINE DEDENT"],"bleu":0.25924014840969,"rouge_l":0.3699844479004666}
{"id":111,"predictions":["n , y = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n + 1 ) ] NEW_LINE ans = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if b > 10000 : NEW_LINE INDENT ans [ i ] = b NEW_LINE break NEW_LINE DEDENT DEDENT print ( ans [ - 1 ] , - 1 ) NEW_LINE"],"references":["def find ( n , y ) : NEW_LINE INDENT for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( n + 1 - i ) : NEW_LINE INDENT if 10000 * i + 5000 * j + 1000 * ( n - i - j ) == y : NEW_LINE INDENT return i , j , n - i - j NEW_LINE DEDENT DEDENT DEDENT return - 1 , - 1 , - 1 NEW_LINE DEDENT N , Y = map ( int , input ( ) . split ( ) ) NEW_LINE i , j , k = find ( N , Y ) NEW_LINE print ( \" { } ▁ { } ▁ { } \" . format ( i , j , k ) ) NEW_LINE"],"bleu":0.286966484656804,"rouge_l":0.34709540823077945}
{"id":112,"predictions":["a , b , c = sorted ( map ( int , input ( ) . split ( ) ) ) print ( c * 2 ) NEW_LINE"],"references":["A , B , C = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE print ( A * B * 2 + B * C * 2 + A * C * 2 ) NEW_LINE"],"bleu":0.2083408438340135,"rouge_l":0.4540280210157618}
{"id":113,"predictions":["import sys NEW_LINE stdin = sys . stdin NEW_LINE sys . setrecursionlimit ( 10 ** 5 ) NEW_LINE def li ( ) : return map ( int , stdin . readline ( ) . split ( ) ) NEW_LINE def li_ ( ) : return map ( lambda x : int ( x ) - 1 , stdin . readline ( ) . split ( ) ) NEW_LINE def lf ( ) : return map ( float , stdin . readline ( ) . split ( ) ) NEW_LINE def ls ( ) : return stdin . readline ( ) . split ( ) ) NEW_LINE def ns ( ) : return stdin . readline ( ) . rstrip ( ) NEW_LINE def lc ( ) : return list ( ns ( ) ) NEW_LINE def ni ( ) : return int ( stdin . readline ( ) ) NEW_LINE def nf ( ) : return list ( ns ( ) ) NEW_LINE def ni ( ) : return int ( stdin . readline ( ) ) NEW_LINE def nf ( ) : return list ( ns ( ) ) NEW_LINE def ni ( ) : return int ( stdin . readline ( ) ) NEW_LINE def ip ( ) : return stdin . readline ( ) ) NEW_LINE def main ( ) : return input ( ) NEW_LINE def main ( ) : NEW_LINE INDENT n = input ( ) NEW_LINE s = stdin . readline ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n - len ( s ) ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT if s [ i + j ] != t [ i + 1 ] : NEW_LINE INDENT ans = i + 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["N = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE t = input ( ) NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT if s [ i : ] == t [ : N - i ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( len ( s + t [ N - i : ] ) ) NEW_LINE"],"bleu":0.10748012013150281,"rouge_l":0.2758056758056758}
{"id":114,"predictions":["import sys NEW_LINE input = sys . stdin . readline NEW_LINE sys . setrecursionlimit ( 10 ** 5 ) NEW_LINE N = int ( input ( ) ) NEW_LINE for _ in range ( N ) : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE if a < b : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT elif b >= a and b >= 2 * c : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT"],"references":["import math NEW_LINE A , B = map ( int , input ( ) . split ( ) ) NEW_LINE N = int ( input ( ) ) NEW_LINE C = [ 0 ] * N NEW_LINE D = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT C [ i ] , D [ i ] = map ( int , input ( ) . split ( ) ) NEW_LINE DEDENT res = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT curr = False NEW_LINE if A <= C [ i ] and B <= D [ i ] : NEW_LINE INDENT curr = True NEW_LINE DEDENT if B <= C [ i ] and A <= D [ i ] : NEW_LINE INDENT curr = True NEW_LINE DEDENT if curr == False : NEW_LINE INDENT for j in range ( 2 ) : NEW_LINE INDENT if j == 1 : NEW_LINE INDENT temp = A NEW_LINE A = B NEW_LINE B = temp NEW_LINE DEDENT lo = math . atan ( B \/ A ) NEW_LINE hi = math . pi \/ 2 NEW_LINE mid = 0 NEW_LINE cnt = 0 NEW_LINE while lo < hi and cnt < 50 : NEW_LINE INDENT mid = ( lo + hi ) \/ 2 NEW_LINE if A * math . sin ( mid ) + B * math . cos ( mid ) < max ( C [ i ] , D [ i ] ) : NEW_LINE INDENT lo = mid NEW_LINE DEDENT else : NEW_LINE INDENT hi = mid NEW_LINE DEDENT cnt += 1 NEW_LINE DEDENT if A * math . cos ( lo ) + B * math . sin ( lo ) <= min ( C [ i ] , D [ i ] ) : NEW_LINE INDENT curr |= True NEW_LINE DEDENT DEDENT DEDENT if curr == True : NEW_LINE INDENT res . append ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT res . append ( \" NO \" ) NEW_LINE DEDENT DEDENT print ( \" \\n \" . join ( map ( str , res ) ) ) NEW_LINE"],"bleu":0.03661008660071442,"rouge_l":0.2631447327289778}
{"id":115,"predictions":["import sys NEW_LINE from collections import defaultdict as dd NEW_LINE sys . setrecursionlimit ( 10 ** 5 ) NEW_LINE def li ( ) : return map ( int , stdin . readline ( ) . split ( ) ) ) NEW_LINE def li_ ( ) : return map ( lambda x : int ( x ) - 1 , stdin . readline ( ) . split ( ) ) NEW_LINE def lf ( ) : return map ( float , stdin . readline ( ) . split ( ) ) NEW_LINE def ls ( ) : return stdin . readline ( ) . split ( ) ) NEW_LINE def ns ( ) : return stdin . readline ( ) . rstrip ( ) NEW_LINE def lf ( ) : return list ( ns ( ) ) NEW_LINE def ni ( ) : return int ( stdin . readline ( ) ) NEW_LINE def nf ( ) : return list ( ns ( ) ) NEW_LINE def ni ( ) : return int ( stdin . readline ( ) ) NEW_LINE def nf ( ) : return float ( stdin . readline ( ) ) NEW_LINE def nf ( ) : return int ( stdin . readline ( ) ) NEW_LINE def ni ( ) : return int ( stdin . readline ( ) ) NEW_LINE def nf ( ) : return list ( nm ( ) ) NEW_LINE def si ( ) : return int ( stdin . readline ( ) ) NEW_LINE def nf ( ) : return list ( mi ( ) ) NEW_LINE def main ( ) : NEW_LINE INDENT n , m = li ( ) NEW_LINE a = li ( ) NEW_LINE return list ( map ( int , input ( ) . split ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] ) NEW_LINE DEDENT DEDENT try : NEW_LINE INDENT print ( a ) NEW_LINE DEDENT"],"references":["n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ 0 ] * n NEW_LINE for i in range ( m ) : NEW_LINE INDENT b , c = map ( int , input ( ) . split ( ) ) NEW_LINE a [ b - 1 ] += 1 NEW_LINE a [ c - 1 ] += 1 NEW_LINE DEDENT for i in a : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT"],"bleu":0.11802298318384984,"rouge_l":0.25799629923341266}
{"id":116,"predictions":["def get_mod ( a , b ) : NEW_LINE INDENT if a % 2 == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return get_mod ( a * ( b + c ) - b * c ) NEW_LINE DEDENT def get_mod ( a , b ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif n % 2 == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif n % 2 == 0 : NEW_LINE INDENT return get_mod ( a * ( b - c ) , c ) NEW_LINE DEDENT else : NEW_LINE INDENT return get_mod ( a * a + c ) NEW_LINE DEDENT DEDENT print ( f ) NEW_LINE"],"references":["A = int ( input ( ) ) NEW_LINE C = int ( input ( ) ) NEW_LINE B = int ( input ( ) ) NEW_LINE mod = 10 ** 9 + 7 NEW_LINE def power ( x , y ) : NEW_LINE INDENT if y == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif y == 1 : NEW_LINE INDENT return x % mod NEW_LINE DEDENT elif y % 2 == 0 : NEW_LINE INDENT return power ( x , y \/\/ 2 ) ** 2 % mod NEW_LINE DEDENT else : NEW_LINE INDENT return ( power ( x , y \/\/ 2 ) ** 2 ) * x % mod NEW_LINE DEDENT DEDENT inv = power ( A * B + A * C - B * C , mod - 2 ) NEW_LINE i = ( ( ( 2 * B * C - A * B - A * C ) % mod ) * inv ) % mod NEW_LINE j = A * B * inv - 1 NEW_LINE print ( ( i - j ) % mod , j % mod ) NEW_LINE"],"bleu":0.1675981668723472,"rouge_l":0.3839204141711501}
{"id":117,"predictions":["n = int ( input ( ) ) NEW_LINE g = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT g = gcd ( g , b ) NEW_LINE g *= b NEW_LINE DEDENT print ( n \/\/ gcd ( gcd ( n , b ) ) ) NEW_LINE"],"references":["from fractions import gcd NEW_LINE from functools import reduce NEW_LINE N = int ( input ( ) ) NEW_LINE T = map ( int , [ input ( ) for _ in range ( N ) ] ) NEW_LINE def lcm_base ( x , y ) : NEW_LINE INDENT return ( x * y ) \/\/ gcd ( x , y ) NEW_LINE DEDENT def lcm ( numbers ) : NEW_LINE INDENT return reduce ( lcm_base , numbers , 1 ) NEW_LINE DEDENT print ( lcm ( T ) ) NEW_LINE"],"bleu":0.1689411487746681,"rouge_l":0.4044054747647562}
{"id":118,"predictions":["n = int ( input ( ) ) NEW_LINE print ( int ( n - s ) ** 2 ) NEW_LINE"],"references":["k = int ( input ( ) ) NEW_LINE if k % 2 == 0 : NEW_LINE INDENT even = k \/\/ 2 NEW_LINE odd = k \/\/ 2 NEW_LINE DEDENT else : NEW_LINE INDENT even = k \/\/ 2 NEW_LINE odd = k \/\/ 2 + 1 NEW_LINE DEDENT print ( even * odd ) NEW_LINE"],"bleu":0.07704298701266094,"rouge_l":0.28405122235157154}
{"id":119,"predictions":["import sys NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE input = sys . stdin . readline NEW_LINE r = lambda x : list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE x , y , z = ( ) , [ ] , [ 0 ] NEW_LINE for i in range ( len ( x ) ) : NEW_LINE INDENT l . append ( x [ i ] ) NEW_LINE DEDENT for i in range ( 1 , 3 ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT if x [ i ] [ j ] != x [ i - 1 ] [ j ] : NEW_LINE INDENT l [ i ] [ j ] = l [ i - 1 ] [ j ] + l [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"references":["c = [ [ 0 , 0 , 0 ] , [ 0 , 0 , 0 ] , [ 0 , 0 , 0 ] ] NEW_LINE for i in range ( 0 , 3 ) : NEW_LINE INDENT c [ i ] = [ int ( j ) for j in input ( ) . split ( \" ▁ \" ) ] NEW_LINE DEDENT f = True NEW_LINE for i in range ( 0 , 2 ) : NEW_LINE INDENT f = f and c [ i ] [ 0 ] - c [ i ] [ 1 ] == c [ i + 1 ] [ 0 ] - c [ i + 1 ] [ 1 ] NEW_LINE f = f and c [ i ] [ 1 ] - c [ i ] [ 2 ] == c [ i + 1 ] [ 1 ] - c [ i + 1 ] [ 2 ] NEW_LINE DEDENT for i in range ( 0 , 2 ) : NEW_LINE INDENT f = f and c [ 0 ] [ i ] - c [ 1 ] [ i ] == c [ 0 ] [ i + 1 ] - c [ 1 ] [ i + 1 ] NEW_LINE f = f and c [ 1 ] [ i ] - c [ 2 ] [ i ] == c [ 1 ] [ i + 1 ] - c [ 2 ] [ i + 1 ] NEW_LINE DEDENT if f : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.1577216199203159,"rouge_l":0.35543840177580466}
{"id":120,"predictions":["import sys NEW_LINE input = sys . stdin . readline NEW_LINE collections = { } NEW_LINE for i in range ( len ( 3 ) ) : NEW_LINE INDENT input = . split ( ) NEW_LINE A . sort ( reverse = True ) NEW_LINE B . reverse ( ) NEW_LINE for i in range ( len ( A ) ) : NEW_LINE INDENT print ( find ( A [ i ] ) + 1 ) NEW_LINE DEDENT DEDENT"],"references":["A = [ int ( input ( ) ) for i in range ( 3 ) ] NEW_LINE s = sorted ( A ) [ : : - 1 ] NEW_LINE for i in A : NEW_LINE INDENT print ( s . index ( i ) + 1 ) NEW_LINE DEDENT"],"bleu":0.24210408771865255,"rouge_l":0.4961952243505641}
{"id":121,"predictions":["n = int ( input ( ) ) NEW_LINE s = [ input ( ) for i in range ( n ) ] NEW_LINE a , b = map ( int , input ( ) . split ( ) ) NEW_LINE nodes = [ input ( ) for i in range ( n ) ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE nodes . append ( b ) ) NEW_LINE DEDENT if a != b : NEW_LINE INDENT print ( \" Alice \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Bob \" ) NEW_LINE DEDENT"],"references":["import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE inf = 10 ** 20 NEW_LINE gosa = 1.0 \/ 10 ** 10 NEW_LINE mod = 10 ** 9 + 7 NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def F ( ) : return float ( sys . stdin . readline ( ) ) NEW_LINE def S ( ) : return input ( ) NEW_LINE def main ( ) : NEW_LINE INDENT n = I ( ) NEW_LINE e = collections . defaultdict ( set ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT a , b = LI ( ) NEW_LINE e [ a ] . add ( b ) NEW_LINE e [ b ] . add ( a ) NEW_LINE DEDENT def f ( i , c ) : NEW_LINE INDENT r = 0 NEW_LINE for j in e [ i ] : NEW_LINE INDENT if j == c : NEW_LINE INDENT continue NEW_LINE DEDENT t = f ( j , i ) NEW_LINE r ^= t NEW_LINE DEDENT return r + 1 NEW_LINE DEDENT if f ( 1 , - 1 ) == 1 : NEW_LINE INDENT return ' Bob ' NEW_LINE DEDENT return ' Alice ' NEW_LINE DEDENT print ( main ( ) ) NEW_LINE"],"bleu":0.058271646823938025,"rouge_l":0.28625784767581963}
{"id":122,"predictions":["from collections import defaultdict NEW_LINE n , g , e = map ( int , input ( ) . split ( ) ) NEW_LINE edges = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE if x == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if x [ i ] [ j ] != j : NEW_LINE INDENT x = j NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT print ( max ( x , y ) ) NEW_LINE DEDENT"],"references":["class Ford_Fulkerson : NEW_LINE INDENT def __init__ ( self , N ) : NEW_LINE INDENT self . used = [ False ] * ( N + 1 ) NEW_LINE self . G = [ [ 0 ] * ( N + 1 ) for i in range ( N + 1 ) ] NEW_LINE DEDENT def add_edge ( self , fr , to , cap ) : NEW_LINE INDENT self . G [ fr ] [ to ] = cap NEW_LINE DEDENT def dfs ( self , v , t , f ) : NEW_LINE INDENT if v == t : NEW_LINE INDENT return f NEW_LINE DEDENT self . used [ v ] = True NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT if v == i : NEW_LINE INDENT continue NEW_LINE DEDENT if ( not self . used [ i ] ) and self . G [ v ] [ i ] > 0 : NEW_LINE INDENT d = self . dfs ( i , t , min ( f , self . G [ v ] [ i ] ) ) NEW_LINE if d > 0 : NEW_LINE INDENT self . G [ v ] [ i ] -= d NEW_LINE self . G [ i ] [ v ] += d NEW_LINE return d NEW_LINE DEDENT DEDENT DEDENT return 0 NEW_LINE DEDENT DEDENT N , G , E = map ( int , input ( ) . split ( ) ) NEW_LINE p = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE F = Ford_Fulkerson ( N ) NEW_LINE for i in range ( G ) : NEW_LINE INDENT F . add_edge ( p [ i ] , N , 1 ) NEW_LINE DEDENT for i in range ( E ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE F . add_edge ( a , b , 1 ) NEW_LINE F . add_edge ( b , a , 1 ) NEW_LINE DEDENT num = 0 NEW_LINE while True : NEW_LINE INDENT F . used = [ False ] * ( N + 1 ) NEW_LINE f = F . dfs ( 0 , N , 10 ** 9 ) NEW_LINE if f == 0 : NEW_LINE INDENT break NEW_LINE DEDENT num += f NEW_LINE DEDENT print ( num ) NEW_LINE"],"bleu":0.08217726029143291,"rouge_l":0.28133750617690656}
{"id":123,"predictions":["x , y , a , b = [ int ( x ) for x in input ( ) . split ( ) ] if a <= b : print ( \" A \" ) else : print ( \" B \" ) NEW_LINE"],"references":["X , A , B = map ( int , input ( ) . split ( ) ) NEW_LINE print ( [ \" A \" , \" B \" ] [ not ( abs ( X - A ) < abs ( X - B ) ) ] ) NEW_LINE"],"bleu":0.22650552365670257,"rouge_l":0.4417241379310345}
{"id":124,"predictions":["def solve ( s , a , b , c ) : NEW_LINE INDENT c = 0 NEW_LINE for i in range ( 3 , 3 ) : NEW_LINE INDENT if ( a == b ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT c += a NEW_LINE DEDENT return c NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"references":["import math NEW_LINE N , Q = map ( int , input ( ) . split ( ) ) NEW_LINE X = [ 0 ] * N NEW_LINE R = [ 0 ] * N NEW_LINE H = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT X [ i ] , R [ i ] , H [ i ] = map ( int , input ( ) . split ( ) ) NEW_LINE DEDENT A = [ 0 ] * Q NEW_LINE B = [ 0 ] * Q NEW_LINE for i in range ( Q ) : NEW_LINE INDENT A [ i ] , B [ i ] = map ( int , input ( ) . split ( ) ) NEW_LINE DEDENT MAX_X = 3 * 10 ** 4 NEW_LINE V = [ 0 ] * MAX_X NEW_LINE for x in range ( MAX_X ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT if X [ i ] > x or X [ i ] + H [ i ] < x : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT Rleft = ( X [ i ] + H [ i ] - x ) * R [ i ] \/ H [ i ] NEW_LINE Rright = max ( 0 , ( X [ i ] + H [ i ] - ( x + 1 ) ) * R [ i ] \/ H [ i ] ) NEW_LINE Vleft = math . pi * Rleft ** 2 * ( X [ i ] + H [ i ] - x ) \/ 3 NEW_LINE Vright = math . pi * Rright ** 2 * ( X [ i ] + H [ i ] - ( x + 1 ) ) \/ 3 NEW_LINE V [ x ] += Vleft - Vright NEW_LINE DEDENT DEDENT DEDENT cum_sum = [ 0 ] * ( MAX_X + 1 ) NEW_LINE for x in range ( MAX_X ) : NEW_LINE INDENT cum_sum [ x + 1 ] = V [ x ] + cum_sum [ x ] NEW_LINE DEDENT for i in range ( Q ) : NEW_LINE INDENT res = cum_sum [ B [ i ] ] - cum_sum [ A [ i ] ] NEW_LINE print ( res ) NEW_LINE DEDENT"],"bleu":0.0025349776418363192,"rouge_l":0.1467522052927025}
{"id":125,"predictions":["h , m = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE if h == 0 : NEW_LINE INDENT print ( h , end = ' ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( h , m , s ) NEW_LINE DEDENT"],"references":["n = int ( input ( ) ) NEW_LINE h = n \/\/ ( 60 * 60 ) NEW_LINE m = ( n % ( 60 * 60 ) ) \/\/ 60 NEW_LINE s = ( n % ( 60 * 60 ) ) % 60 NEW_LINE print ( ' { :02 } : { : 02 } : { : 02 } ' . format ( h , m , s ) ) NEW_LINE"],"bleu":0.17781570718582201,"rouge_l":0.38920245398773007}
{"id":126,"predictions":["n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE x = k NEW_LINE y = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == 1 : NEW_LINE INDENT x = ( 1 + k ) \/\/ x NEW_LINE y = n - 1 NEW_LINE DEDENT else : NEW_LINE INDENT y = ( x + k ) \/\/ x NEW_LINE DEDENT DEDENT print ( y ) NEW_LINE"],"references":["import math NEW_LINE N , K = map ( int , input ( ) . split ( ) ) NEW_LINE A_ = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = math . ceil ( ( N - 1 ) \/ ( K - 1 ) ) NEW_LINE print ( ans ) NEW_LINE"],"bleu":0.32777148200261524,"rouge_l":0.577044355686357}
{"id":127,"predictions":["n = int ( input ( ) ) s = input ( ) count = 0 for i in range ( n ) : if ( s [ i ] > 0 ) : count += 1 else : count += 1 print ( count ) NEW_LINE"],"references":["import copy as co NEW_LINE class circle ( ) : NEW_LINE INDENT def __init__ ( self , numlist , amount_of_can ) : NEW_LINE INDENT self . numcircle = numlist NEW_LINE self . til = 0 NEW_LINE self . cansee = amount_of_can NEW_LINE self . times = 1 NEW_LINE DEDENT def right_rotation ( self , num , length ) : NEW_LINE INDENT a = self . numcircle [ : length - num ] NEW_LINE b = self . numcircle [ length - num : ] NEW_LINE return b + a NEW_LINE DEDENT DEDENT def sup_and ( str1 , str2 , length ) : NEW_LINE INDENT count = 0 NEW_LINE for x in range ( 0 , length ) : NEW_LINE INDENT str1 [ x ] = str1 [ x ] or str2 [ x ] NEW_LINE count += str1 [ x ] NEW_LINE DEDENT return count NEW_LINE DEDENT def search ( circlelist , length , TV ) : NEW_LINE INDENT list1 = [ ] NEW_LINE for x in range ( circlelist . til + 1 , length ) : NEW_LINE INDENT circlelist2 = co . deepcopy ( circlelist ) NEW_LINE circlelist2 . cansee = sup_and ( circlelist2 . numcircle , TV . right_rotation ( x , length ) , length ) NEW_LINE circlelist2 . til = x NEW_LINE circlelist2 . times += 1 NEW_LINE list1 . append ( circlelist2 ) NEW_LINE DEDENT return list1 NEW_LINE DEDENT inp1 = input ( ) NEW_LINE amount_of_can = 0 NEW_LINE numlist = [ ] NEW_LINE for x in inp1 : NEW_LINE INDENT if x == ' x ' : NEW_LINE INDENT numlist . append ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT numlist . append ( 1 ) NEW_LINE amount_of_can += 1 NEW_LINE DEDENT DEDENT length = len ( numlist ) NEW_LINE if amount_of_can == length : NEW_LINE INDENT print ( 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT else : NEW_LINE INDENT circlelist = circle ( numlist , amount_of_can ) NEW_LINE alllist1 = [ circlelist ] NEW_LINE TV = co . deepcopy ( circlelist ) NEW_LINE while True : NEW_LINE INDENT alllist2 = [ ] NEW_LINE while alllist1 : NEW_LINE INDENT alllist2 . extend ( search ( alllist1 . pop ( ) , length , TV ) ) NEW_LINE DEDENT alllist1 = alllist2 NEW_LINE for x in alllist1 : NEW_LINE INDENT if x . cansee == length : NEW_LINE INDENT print ( x . times ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT DEDENT DEDENT"],"bleu":0.00008406098475447625,"rouge_l":0.11813581558068344}
{"id":128,"predictions":["n , m = map ( int , input ( ) . split ( \" ▁ \" ) ) NEW_LINE t = [ int ( x ) for x in input ( ) . split ( \" ▁ \" ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT t = t [ i ] NEW_LINE cnt = 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if t [ i ] != 1 : NEW_LINE INDENT cnt += 1 NEW_LINE cnt += 1 NEW_LINE DEDENT DEDENT print ( cnt ) NEW_LINE"],"references":["n = int ( input ( ) ) NEW_LINE t = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT t [ i ] = int ( input ( ) ) NEW_LINE DEDENT t . sort ( ) NEW_LINE m = 10 ** 9 + 7 NEW_LINE res = 0 NEW_LINE ass = 1 NEW_LINE p = [ 1 ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT p . append ( p [ - 1 ] * i % m ) NEW_LINE DEDENT c = 0 NEW_LINE k = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT c += t [ i ] NEW_LINE res += c NEW_LINE if i != n - 1 : NEW_LINE INDENT if t [ i ] != t [ i + 1 ] : NEW_LINE INDENT ass = ass * p [ k ] % m NEW_LINE k = 1 NEW_LINE DEDENT else : NEW_LINE INDENT k += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT ass = ass * p [ k ] % m NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE print ( ass ) NEW_LINE"],"bleu":0.1808222079142082,"rouge_l":0.42244627762501274}
{"id":129,"predictions":["n , c , k = map ( int , input ( ) . split ( ) ) NEW_LINE t = 0 NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if t [ i ] < c : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE"],"references":["from math import ceil NEW_LINE def main ( ) : NEW_LINE INDENT N , C , K = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE Ts = [ ] NEW_LINE for _ in range ( N ) : NEW_LINE INDENT Ts . append ( int ( input ( ) ) ) NEW_LINE DEDENT Ts . sort ( ) NEW_LINE bus_ct = 0 NEW_LINE in_bus = 1 NEW_LINE st = Ts . pop ( 0 ) + K NEW_LINE for Ti in Ts : NEW_LINE INDENT if Ti > st : NEW_LINE INDENT bus_ct += 1 NEW_LINE in_bus = 1 NEW_LINE st = Ti + K NEW_LINE DEDENT elif Ti <= st : NEW_LINE INDENT in_bus += 1 NEW_LINE DEDENT if in_bus > C : NEW_LINE INDENT bus_ct += 1 NEW_LINE in_bus = 1 NEW_LINE st = Ti + K NEW_LINE DEDENT DEDENT if in_bus : NEW_LINE INDENT bus_ct += 1 NEW_LINE DEDENT print ( bus_ct ) NEW_LINE DEDENT main ( ) NEW_LINE"],"bleu":0.11753696028908346,"rouge_l":0.36035696329813977}
{"id":130,"predictions":["import sys   def C ( ) : return int ( sys . stdin . readline ( ) . strip ( ) )   def C ( ) : return map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ' ▁ ' ) )     def C ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE"],"references":["import heapq NEW_LINE n , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE h = [ int ( input ( ) ) for i in range ( n ) ] NEW_LINE h . sort ( ) NEW_LINE p = a - b NEW_LINE def c ( w ) : NEW_LINE INDENT k = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT l [ i ] = l [ i ] - b * w NEW_LINE if l [ i ] > 0 : NEW_LINE INDENT k += l [ i ] \/\/ p NEW_LINE if l [ i ] % p != 0 : NEW_LINE INDENT k += 1 NEW_LINE DEDENT DEDENT DEDENT if w >= k : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT s = 0 NEW_LINE f = 10 ** 14 NEW_LINE while f - s >= 2 : NEW_LINE INDENT m = ( f + s ) \/\/ 2 NEW_LINE l = h [ : : ] NEW_LINE if c ( m ) : NEW_LINE INDENT f = m NEW_LINE DEDENT else : NEW_LINE INDENT s = m NEW_LINE DEDENT DEDENT l = h [ : : ] NEW_LINE if c ( s ) : NEW_LINE INDENT print ( s ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( f ) NEW_LINE DEDENT"],"bleu":0.02710356999034322,"rouge_l":0.1830590513068732}
{"id":131,"predictions":["n , k = map ( int , input ( ) . split ( ) ) NEW_LINE S = [ input ( ) for i in range ( n ) ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if S [ i ] == ' A ' : NEW_LINE INDENT swap ^= True NEW_LINE DEDENT else : NEW_LINE INDENT S [ i ] = False NEW_LINE DEDENT DEDENT for i in range ( k ) : NEW_LINE INDENT if S [ i ] == ' A ' : NEW_LINE INDENT continue NEW_LINE DEDENT print ( \" B \" . join ( map ( str , True ) ) ) NEW_LINE x = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT if x [ i ] != ' A ' : NEW_LINE INDENT x = ' B ' NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT x = S [ i ] [ k ] + flip NEW_LINE DEDENT DEDENT"],"references":["import sys NEW_LINE from itertools import accumulate NEW_LINE from collections import deque NEW_LINE def solve ( ) : NEW_LINE INDENT N , K = map ( int , input ( ) . split ( ) ) NEW_LINE S = input ( ) NEW_LINE q = deque ( [ 1 if c == ' A ' else 0 for c in S ] ) NEW_LINE cb = 0 NEW_LINE for i in range ( min ( K , 2 * N + K % 2 ) ) : NEW_LINE INDENT if q [ 0 ] == ( cb ^ 1 ) : NEW_LINE INDENT q [ 0 ] ^= 1 NEW_LINE DEDENT else : NEW_LINE INDENT q . popleft ( ) NEW_LINE q . append ( cb ) NEW_LINE cb ^= 1 NEW_LINE DEDENT DEDENT ans = [ ' A ' if ( c ^ cb ) else ' B ' for c in q ] NEW_LINE print ( ' ' . join ( ans ) ) NEW_LINE DEDENT def debug ( x , table ) : NEW_LINE INDENT for name , val in table . items ( ) : NEW_LINE INDENT if x is val : NEW_LINE INDENT print ( ' DEBUG : { } ▁ - > ▁ { } ' . format ( name , val ) , file = sys . stderr ) NEW_LINE return None NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT"],"bleu":0.22339303553501796,"rouge_l":0.41321692006623517}
{"id":132,"predictions":["a , b = map ( int , input ( ) . split ( \" + \" ) ) NEW_LINE if b == \" + \" : NEW_LINE INDENT print ( a + b ) NEW_LINE DEDENT elif b == \" - \" : NEW_LINE INDENT print ( a + b ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a - b ) NEW_LINE DEDENT"],"references":["print ( eval ( input ( ) ) ) NEW_LINE"],"bleu":0.05592939339786432,"rouge_l":0.21243781094527364}
{"id":133,"predictions":["S = input ( ) NEW_LINE c = 0 NEW_LINE for i in range ( len ( S ) ) : NEW_LINE INDENT if S [ i ] == ' U ' : NEW_LINE INDENT c += 1 NEW_LINE DEDENT elif S [ i : i ] == ' D ' : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE"],"references":["import sys NEW_LINE stdin = sys . stdin NEW_LINE def li ( ) : return map ( int , stdin . readline ( ) . split ( ) ) NEW_LINE def li_ ( ) : return map ( lambda x : int ( x ) - 1 , stdin . readline ( ) . split ( ) ) NEW_LINE def lf ( ) : return map ( float , stdin . readline ( ) . split ( ) ) NEW_LINE def ls ( ) : return stdin . readline ( ) . split ( ) NEW_LINE def ns ( ) : return stdin . readline ( ) . rstrip ( ) NEW_LINE def lc ( ) : return list ( ns ( ) ) NEW_LINE def ni ( ) : return int ( stdin . readline ( ) ) NEW_LINE def nf ( ) : return float ( stdin . readline ( ) ) NEW_LINE s = ns ( ) NEW_LINE n = len ( s ) NEW_LINE ans = 0 NEW_LINE for idx , si in enumerate ( s ) : NEW_LINE INDENT if si == ' U ' : NEW_LINE INDENT ans += ( n - idx - 1 ) + 2 * idx NEW_LINE DEDENT else : NEW_LINE INDENT ans += 2 * ( n - idx - 1 ) + idx NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"bleu":0.024052586948318005,"rouge_l":0.23149905123339656}
{"id":134,"predictions":["import sys NEW_LINE from fractions import gcd NEW_LINE def main ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE X = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT X = abs ( X - X ) ) NEW_LINE Y = min ( X , X ) NEW_LINE DEDENT for j in range ( N ) : NEW_LINE INDENT print ( X [ j ] , X [ j ] ) NEW_LINE DEDENT DEDENT"],"references":["def gcd ( a , b ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( b , a % b ) NEW_LINE DEDENT DEDENT N , A = map ( int , input ( ) . split ( ) ) NEW_LINE X = sorted ( map ( int , input ( ) . split ( ) ) ) NEW_LINE Y = [ ] NEW_LINE for x in X : NEW_LINE INDENT Y . append ( abs ( A - x ) ) NEW_LINE DEDENT ans = max ( Y ) NEW_LINE for y in Y : NEW_LINE INDENT ans = gcd ( y , ans ) NEW_LINE DEDENT print ( ans ) NEW_LINE"],"bleu":0.2822948312128889,"rouge_l":0.4907340899296077}
{"id":135,"predictions":["N , K = map ( int , input ( ) . split ( ) ) NEW_LINE print ( N - K + 1 ) NEW_LINE"],"references":["N , i = map ( int , input ( ) . split ( ) ) NEW_LINE print ( N - i + 1 ) NEW_LINE"],"bleu":0.8058778374128266,"rouge_l":0.9230769230769234}
{"id":136,"predictions":["n , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if ( a + b > n + 1 or b < sqrt : NEW_LINE INDENT print ( - 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT elif a + b > n + 1 : NEW_LINE INDENT for i in range ( b + 1 ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT for i in range ( b , n + 1 ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT"],"references":["N , A , B = map ( int , input ( ) . split ( ) ) NEW_LINE ans = list ( range ( A ) ) NEW_LINE m = 0 NEW_LINE rest = N - A NEW_LINE B -= 1 NEW_LINE if rest < B : NEW_LINE INDENT print ( - 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT if rest \/ A > B : NEW_LINE INDENT print ( - 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT while rest > B : NEW_LINE INDENT s = min ( A , rest - B + 1 ) NEW_LINE ans += list ( range ( m - s , m ) ) NEW_LINE m -= s NEW_LINE rest -= s NEW_LINE B -= 1 NEW_LINE DEDENT ans += list ( range ( m - B , m ) ) [ : : - 1 ] NEW_LINE m -= B NEW_LINE print ( \" ▁ \" . join ( [ str ( x - m + 1 ) for x in ans ] ) ) NEW_LINE"],"bleu":0.23617050797326747,"rouge_l":0.42586224861936023}
{"id":137,"predictions":["s = ' ' NEW_LINE s = ' ' NEW_LINE count = 1 NEW_LINE for i in range ( 1 , len ( s ) + 1 ) : NEW_LINE INDENT s = str ( input ( ) ) NEW_LINE t = s [ : : - 1 ] NEW_LINE for j in range ( len ( s ) - 1 ) : NEW_LINE INDENT if s [ j ] == t [ j + 1 : ] : NEW_LINE INDENT count = i - j NEW_LINE DEDENT DEDENT DEDENT print ( count ) NEW_LINE"],"references":["from string import ascii_lowercase NEW_LINE s = input ( ) NEW_LINE ans = 100 NEW_LINE for c in ascii_lowercase : NEW_LINE INDENT ans = min ( ans , max ( [ len ( x ) for x in s . split ( c ) ] ) ) NEW_LINE DEDENT print ( ans ) NEW_LINE"],"bleu":0.08039141043586885,"rouge_l":0.3672146330169021}
{"id":138,"predictions":["n , h = map ( int , input ( ) . split ( ) ) l1 = list ( map ( int , input ( ) . split ( ) ) ) l2 = list ( map ( int , input ( ) . split ( ) ) ) ) for i in l1 : if l1 [ i ] < l1 : print ( l1 ) else : print ( 0 ) NEW_LINE"],"references":["l , h = map ( int , input ( ) . split ( ) ) NEW_LINE n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT a = int ( input ( ) ) NEW_LINE if a < l : NEW_LINE INDENT print ( l - a ) NEW_LINE DEDENT elif l <= a <= h : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT"],"bleu":0.30383258202881797,"rouge_l":0.48731775514279996}
{"id":139,"predictions":["from collections import defaultdict NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT if a [ i ] == 0 : NEW_LINE INDENT c [ a [ i ] ] -= 1 NEW_LINE DEDENT if c [ a [ i ] ] >= 0 and c [ b [ i - 1 ] ] < 0 : NEW_LINE INDENT l [ b [ i ] ] = 1 NEW_LINE DEDENT DEDENT DEDENT print ( l ) NEW_LINE"],"references":["from collections import Counter NEW_LINE N , M = map ( int , input ( ) . split ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE src = [ tuple ( map ( int , input ( ) . split ( ) ) ) for i in range ( M ) ] NEW_LINE ctr = Counter ( A ) NEW_LINE cover = [ 0 ] * ( 2 * N + 1 ) NEW_LINE for k , v in ctr . items ( ) : NEW_LINE INDENT for i in range ( k , k - v , - 1 ) : NEW_LINE INDENT cover [ i + N ] += 1 NEW_LINE DEDENT DEDENT ans = cover [ N + 1 : ] . count ( 0 ) NEW_LINE for x , y in src : NEW_LINE INDENT ctr [ A [ x - 1 ] ] -= 1 NEW_LINE ai = A [ x - 1 ] + N - ctr [ A [ x - 1 ] ] NEW_LINE cover [ ai ] -= 1 NEW_LINE if ai > N and cover [ ai ] == 0 : ans += 1 NEW_LINE A [ x - 1 ] = y NEW_LINE bi = y + N - ctr [ y ] NEW_LINE if bi > N and cover [ bi ] == 0 : ans -= 1 NEW_LINE cover [ bi ] += 1 NEW_LINE ctr [ y ] += 1 NEW_LINE print ( ans ) NEW_LINE DEDENT"],"bleu":0.23955012588548674,"rouge_l":0.48745837957824645}
{"id":140,"predictions":["import heapqn , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE pq = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT j , k = map ( int , input ( ) . split ( ) ) NEW_LINE pq . append ( [ q for q in range ( k ) ] ) NEW_LINE DEDENT heapq . heappush ( pq , ( - 1 , n ) ) NEW_LINE"],"references":["import heapq NEW_LINE N , K = map ( int , input ( ) . split ( ) ) NEW_LINE src = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE hq = [ ] NEW_LINE heapq . heapify ( hq ) NEW_LINE for i , a in enumerate ( src [ : K ] ) : NEW_LINE INDENT heapq . heappush ( hq , ( - a , i + 1 ) ) NEW_LINE DEDENT for i , a in enumerate ( src [ K : ] ) : NEW_LINE INDENT b , j = hq [ 0 ] NEW_LINE print ( j ) NEW_LINE if a < - b : NEW_LINE INDENT heapq . heappop ( hq ) NEW_LINE heapq . heappush ( hq , ( - a , K + i + 1 ) ) NEW_LINE DEDENT DEDENT b , j = hq [ 0 ] NEW_LINE print ( j ) NEW_LINE"],"bleu":0.24857184746317393,"rouge_l":0.5066811123149152}
{"id":141,"predictions":["N = int ( input ( ) ) NEW_LINE b = sorted ( map ( int , input ( ) . split ( ' ▁ ' ) ) ) NEW_LINE c = sorted ( b ) NEW_LINE n = int ( input ( ) ) NEW_LINE b = [ int ( x ) for x in input ( ) . split ( ' ▁ ' ) ] ) NEW_LINE c = sorted ( b ) NEW_LINE print ( c ) NEW_LINE"],"references":["n = int ( input ( ) ) NEW_LINE list = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE list . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans += ( - 1 ) ** ( i - 1 ) * list [ - i ] NEW_LINE DEDENT print ( ans ) NEW_LINE"],"bleu":0.3152715323242574,"rouge_l":0.538122243226213}
{"id":142,"predictions":["s = \" S \" NEW_LINE for i in range ( 7 ) : NEW_LINE INDENT if s [ i ] == \"7\" : NEW_LINE INDENT ans = max ( 5 - i , 0 ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["day = input ( ) NEW_LINE if day == \" Monday \" : NEW_LINE INDENT print ( 5 ) NEW_LINE DEDENT elif day == \" Tuesday \" : NEW_LINE INDENT print ( 4 ) NEW_LINE DEDENT elif day == \" Wednesday \" : NEW_LINE INDENT print ( 3 ) NEW_LINE DEDENT elif day == \" Thursday \" : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT elif day == \" Friday \" : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT"],"bleu":0.05778835139084251,"rouge_l":0.306672760511883}
{"id":143,"predictions":["import sys NEW_LINE def solve ( n , M , a ) : NEW_LINE INDENT if M < 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( len ( n ) - 1 ) : NEW_LINE INDENT a = map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ' ▁ ' ) ) NEW_LINE for j in range ( 1 , N - 1 ) : NEW_LINE INDENT if a [ j ] >= a : NEW_LINE INDENT m = ( a [ j ] - a [ i ] ) \/\/ a NEW_LINE DEDENT else : NEW_LINE INDENT m = max ( m , a [ j ] - a [ i - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return m NEW_LINE DEDENT t = int ( raw_input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT N , M = map ( int , raw_input ( ) . split ( ' ▁ ' ) ) NEW_LINE print \" Case ▁ # % d : ▁ % d \" % ( i + 1 , t ) NEW_LINE DEDENT"],"references":["def solve ( ) : NEW_LINE INDENT N = input ( ) NEW_LINE ar = [ int ( _ ) for _ in raw_input ( ) . split ( ) ] NEW_LINE diffs = [ a - b for a , b in zip ( ar , ar [ 1 : ] ) ] NEW_LINE eat1 = sum ( max ( x , 0 ) for x in diffs ) NEW_LINE rate = max ( diffs + [ 0 ] ) NEW_LINE eat2 = sum ( min ( x , rate ) for x in ar [ : - 1 ] ) NEW_LINE return eat1 , eat2 NEW_LINE DEDENT T = input ( ) NEW_LINE for t in range ( 1 , T + 1 ) : NEW_LINE INDENT a , b = solve ( ) NEW_LINE print ' Case ▁ # % d : ▁ % d ▁ % d ' % ( t , a , b ) NEW_LINE DEDENT"],"bleu":0.21832459743886493,"rouge_l":0.4515591746090497}
{"id":144,"predictions":["import sys NEW_LINE try : NEW_LINE INDENT import sys NEW_LINE f = open ( sys . argv [ 1 ] , ' r ' ) NEW_LINE f = open ( sys . argv [ 1 ] , ' r ' ) NEW_LINE t = int ( f . readline ( ) ) NEW_LINE for case in xrange ( 1 , t + 1 ) : NEW_LINE INDENT n = int ( f . readline ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT q = map ( int , f . readline ( ) . split ( ) ) NEW_LINE r = [ i ] NEW_LINE for j in x : NEW_LINE INDENT if j == n : NEW_LINE INDENT t [ j ] = ( i + 1 ) \/\/ 3 NEW_LINE t [ k ] = t [ k ] + r [ j ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT f = f . readline NEW_LINE DEDENT DEDENT DEDENT for i in range ( t ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT f = open ( 0 ) NEW_LINE DEDENT elif n == 2 : NEW_LINE INDENT f = f . readline ( ) NEW_LINE if f == 1 : NEW_LINE INDENT f = open ( f . readline ( ) ) NEW_LINE DEDENT else : NEW_LINE INDENT f = open ( 0 ) NEW_LINE DEDENT DEDENT print \" Case ▁ # % d : ▁ \" % f \" % ( i + 1 ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE from math import sqrt NEW_LINE class Obj : NEW_LINE INDENT pass NEW_LINE DEDENT def dist ( o1 , o2 ) : NEW_LINE INDENT return ( sqrt ( ( o1 . x - o2 . x ) ** 2 + ( o1 . y - o2 . y ) ** 2 ) + o2 . r + o1 . r ) \/ 2.0 NEW_LINE DEDENT def solve ( a ) : NEW_LINE INDENT n = len ( a ) NEW_LINE if n == 1 : NEW_LINE INDENT return a [ 0 ] . r NEW_LINE DEDENT if n == 2 : NEW_LINE INDENT return max ( a [ 0 ] . r , a [ 1 ] . r ) NEW_LINE DEDENT res = max ( dist ( a [ 0 ] , a [ 1 ] ) , a [ 2 ] . r ) NEW_LINE res = min ( res , max ( dist ( a [ 0 ] , a [ 2 ] ) , a [ 1 ] . r ) ) NEW_LINE res = min ( res , max ( dist ( a [ 1 ] , a [ 2 ] ) , a [ 0 ] . r ) ) NEW_LINE return res NEW_LINE DEDENT nCases = int ( sys . stdin . readline ( ) ) NEW_LINE for c in xrange ( 1 , nCases + 1 ) : NEW_LINE INDENT n = int ( sys . stdin . readline ( ) ) NEW_LINE a = [ ] NEW_LINE for i in xrange ( n ) : NEW_LINE INDENT o = Obj ( ) ; NEW_LINE ( o . x , o . y , o . r ) = [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE a . append ( o ) NEW_LINE DEDENT print \" Case ▁ # \" + str ( c ) + \" : ▁ \" + repr ( solve ( a ) ) NEW_LINE DEDENT"],"bleu":0.22866718554383375,"rouge_l":0.33872759003649056}
{"id":145,"predictions":["import sys NEW_LINE def solve ( n , a ) : NEW_LINE INDENT s = [ \" Z \" , \" X \" , \" Y \" , \" G \" , \" E \" , \" E \" , \" F \" , \" E \" , \" F \" , \" E \" , \" E \" , \" F \" , \" E \" , \" K \" , \" , \" E \" , \" E \" , \" N \" , \" E \" , \" O \" , \" K \" , \" E \" , \" K \" , \" E \" ] NEW_LINE for i in range ( 0 , len ( a ) ) : NEW_LINE INDENT c = a [ i ] NEW_LINE cnt = 0 NEW_LINE for j in range ( len ( a ) ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE cnt += cnt [ j ] NEW_LINE cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT fn = sys . stdin . readline NEW_LINE T = int ( sys . stdin . readline ( ) ) NEW_LINE for case in xrange ( 1 , T + 1 ) : NEW_LINE INDENT print \" Case ▁ # % d : ▁ \" % ( i + 1 ) NEW_LINE DEDENT DEDENT"],"references":["import sys NEW_LINE sys . setrecursionlimit ( 100000 ) NEW_LINE inp = sys . stdin NEW_LINE outp = sys . stdout NEW_LINE words = [ \" ZERO \" , \" ONE \" , \" TWO \" , \" THREE \" , \" FOUR \" , \" FIVE \" , \" SIX \" , \" SEVEN \" , \" EIGHT \" , \" NINE \" ] NEW_LINE m = [ ( 0 , ' Z ' ) , ( 2 , ' W ' ) , ( 4 , ' U ' ) , ( 6 , ' X ' ) , ( 7 , ' S ' ) , ( 5 , ' V ' ) , ( 1 , ' O ' ) , ( 3 , ' R ' ) , ( 8 , ' H ' ) , ( 9 , ' E ' ) ] NEW_LINE def solve ( ) : NEW_LINE INDENT x = sys . stdin . readline ( ) . strip ( ) NEW_LINE f = [ 0 ] * 10 NEW_LINE for ( d , c ) in m : NEW_LINE INDENT cnt = x . count ( c ) NEW_LINE f [ d ] += cnt NEW_LINE for c2 in words [ d ] : NEW_LINE INDENT x = x . replace ( c2 , ' ' , cnt ) NEW_LINE DEDENT DEDENT assert x == ' ' NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT outp . write ( ( ' % d ' % i ) * f [ i ] ) NEW_LINE DEDENT print NEW_LINE DEDENT T = int ( inp . readline ( ) ) NEW_LINE for i in range ( T ) : NEW_LINE INDENT outp . write ( ' Case ▁ # % d : ▁ ' % ( i + 1 ) ) NEW_LINE solve ( ) NEW_LINE DEDENT"],"bleu":0.20777447250477815,"rouge_l":0.4265245300320954}
{"id":146,"predictions":["import sys NEW_LINE import itertools NEW_LINE def main ( ) : NEW_LINE INDENT t = sys . stdin . readline NEW_LINE n = int ( n ) NEW_LINE if n == 1 : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if n % k != 0 : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT def main ( ) : NEW_LINE INDENT n = int ( sys . stdin . readline ( ) ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT data = map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) NEW_LINE if len ( data ) == 1 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT m = { } NEW_LINE for i in xrange ( len ( data ) ) : NEW_LINE INDENT if data [ i ] [ 0 ] == 1 : NEW_LINE INDENT m [ i ] = False NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT m [ i ] = 1 NEW_LINE DEDENT DEDENT ans = { } NEW_LINE for i in range ( len ( data ) ) ) : NEW_LINE INDENT if data [ i ] [ 0 ] > data [ i ] [ 1 ] : NEW_LINE INDENT ans [ i ] = False NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"references":["import os , sys NEW_LINE def convertToBase ( number , base ) : NEW_LINE INDENT digits = [ ] NEW_LINE mod = base NEW_LINE prevMod = 1 NEW_LINE while number > 0 : NEW_LINE INDENT digit = ( number % mod ) \/ prevMod NEW_LINE digits . append ( digit ) NEW_LINE number = number - digit * prevMod NEW_LINE prevMod = mod NEW_LINE mod *= base NEW_LINE DEDENT if len ( digits ) == 0 : NEW_LINE INDENT digits = [ 0 ] NEW_LINE DEDENT return digits NEW_LINE DEDENT def squareDigits ( digits ) : NEW_LINE INDENT return sum ( [ x * x for x in digits ] ) NEW_LINE DEDENT def isHappy ( number , base ) : NEW_LINE INDENT foundNums = set ( ) NEW_LINE while True : NEW_LINE INDENT digits = convertToBase ( number , base ) NEW_LINE number = squareDigits ( digits ) NEW_LINE if number == 1 : NEW_LINE INDENT return True NEW_LINE DEDENT if number in foundNums : NEW_LINE INDENT return False NEW_LINE DEDENT foundNums . add ( number ) NEW_LINE DEDENT DEDENT def main ( filename ) : NEW_LINE INDENT fileLines = open ( filename , ' r ' ) . readlines ( ) NEW_LINE index = 0 NEW_LINE words = [ ] NEW_LINE numCases = int ( fileLines [ index ] [ : - 1 ] ) NEW_LINE index += 1 NEW_LINE for caseNum in range ( numCases ) : NEW_LINE INDENT bases = [ int ( x ) for x in fileLines [ index ] [ : - 1 ] . split ( ' ▁ ' ) ] NEW_LINE index += 1 NEW_LINE i = 2 NEW_LINE while True : NEW_LINE INDENT happy = True NEW_LINE for base in bases : NEW_LINE INDENT if ( not isHappy ( i , base ) ) : NEW_LINE INDENT happy = False NEW_LINE break NEW_LINE DEDENT DEDENT if happy : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print \" Case ▁ # % d : ▁ % d \" % ( caseNum + 1 , i ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 ] ) NEW_LINE DEDENT"],"bleu":0.20318254345132922,"rouge_l":0.38715867158671585}
{"id":147,"predictions":["import sys NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , n ) : NEW_LINE INDENT self . children = [ None ] * ( n + 1 ) NEW_LINE self . children = [ None ] * ( n + 1 ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT t = sys . stdin . readline ( ) NEW_LINE for i in xrange ( 1 , t + 1 ) : NEW_LINE INDENT if t [ i ] == x : NEW_LINE INDENT t [ i ] = t [ i - 1 ] NEW_LINE t [ i ] = t [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT t [ i ] = t [ i - 1 ] = t [ i ] NEW_LINE DEDENT DEDENT for i in xrange ( 1 , t + 1 ) : NEW_LINE INDENT if t [ i ] != x [ 0 ] : NEW_LINE INDENT t [ i ] = t [ i ] + 1 NEW_LINE DEDENT DEDENT return t [ 0 ] NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT n = int ( sys . stdin . readline ( ) ) NEW_LINE for i in xrange ( 1 , n + 1 ) : NEW_LINE INDENT db = open ( sys . stdin . readline ( ) ) NEW_LINE s = open ( sys . argv [ 1 ] ) NEW_LINE DEDENT main ( ) NEW_LINE"],"references":["from collections import defaultdict NEW_LINE from heapq import nlargest NEW_LINE def maxSize ( adj , node , parent ) : NEW_LINE INDENT children = adj [ node ] - { parent } NEW_LINE if len ( children ) == 1 : return 1 NEW_LINE return sum ( nlargest ( 2 , ( maxSize ( adj , child , node ) for child in children ) ) ) + 1 NEW_LINE DEDENT for t in range ( int ( input ( ) ) ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE adj = defaultdict ( set ) NEW_LINE for _ in range ( N - 1 ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE adj [ a ] . add ( b ) NEW_LINE adj [ b ] . add ( a ) NEW_LINE DEDENT result = N - max ( maxSize ( adj , root , None ) for root in range ( 1 , N + 1 ) ) NEW_LINE assert 0 <= result <= N NEW_LINE print ( ' Case ▁ # { } : ▁ { } ' . format ( t + 1 , result ) ) NEW_LINE DEDENT"],"bleu":0.1188977358336052,"rouge_l":0.31777729542001304}
{"id":148,"predictions":["import sys NEW_LINE def main ( ) : NEW_LINE INDENT s = sys . argv [ 1 for x in range ( 210 ) ] NEW_LINE n = int ( n raw_input ( ) ) NEW_LINE a = [ int ( x ) for x in raw_input ( ) . split ( ) ] NEW_LINE b = [ [ 0 for x in raw_input ( ) ] for x in range ( n + 1 ) ] NEW_LINE t = [ 0 for x in range ( n ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if a % 2 == 0 : NEW_LINE INDENT t [ i ] = str ( x ) NEW_LINE b [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT b [ i ] = b [ i ] NEW_LINE DEDENT DEDENT for x in range ( 1 , n + 1 ) : NEW_LINE INDENT if x % 2 == 0 : NEW_LINE INDENT b [ i ] = b [ x ] NEW_LINE DEDENT DEDENT return a NEW_LINE DEDENT if __name__ == ' _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"references":["ops = [ int . __add__ , int . __sub__ ] NEW_LINE ugly_count = 0 NEW_LINE def is_ugly ( num ) : NEW_LINE INDENT return num % 2 == 0 or num % 3 == 0 or num % 5 == 0 or num % 7 == 0 NEW_LINE DEDENT def count_ugly ( left_slice_num , right_slice , op ) : NEW_LINE INDENT global ugly_count NEW_LINE if is_ugly ( op ( left_slice_num , int ( right_slice ) ) ) : NEW_LINE INDENT ugly_count += 1 NEW_LINE DEDENT if len ( right_slice ) > 1 : NEW_LINE INDENT for i in xrange ( - 1 , - len ( right_slice ) , - 1 ) : NEW_LINE INDENT for sub_op in ops : NEW_LINE INDENT count_ugly ( op ( left_slice_num , int ( right_slice [ : i ] ) ) , right_slice [ i : ] , sub_op ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT testsCount = int ( raw_input ( ) ) NEW_LINE for i in xrange ( testsCount ) : NEW_LINE INDENT ugly_count = 0 NEW_LINE count_ugly ( 0 , raw_input ( ) , int . __add__ ) NEW_LINE print \" Case ▁ # % d : ▁ % d \" % ( i + 1 , ugly_count ) NEW_LINE DEDENT DEDENT"],"bleu":0.2144719190229782,"rouge_l":0.3243694925554543}
{"id":149,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["inp_file = file ( \" B - small . in \" ) NEW_LINE out_file = file ( \" B - small . out \" , \" w \" ) NEW_LINE def solve ( line ) : NEW_LINE INDENT A , B , P = [ int ( c1 ) for c1 in line . split ( \" ▁ \" ) ] NEW_LINE numbers = range ( A , B + 1 ) NEW_LINE sets = range ( B - A + 1 ) NEW_LINE for c1 in primes : NEW_LINE INDENT if c1 < P : continue NEW_LINE if c1 > B \/ 2 + 1 : break NEW_LINE same = [ ] NEW_LINE for c2 in numbers : NEW_LINE INDENT if not c2 % c1 : same . append ( c2 - A ) NEW_LINE DEDENT sets = merge_sets ( sets , same ) NEW_LINE DEDENT counted = [ ] NEW_LINE c2 = 0 NEW_LINE for c1 in sets : NEW_LINE INDENT if not c1 in counted : NEW_LINE INDENT counted . append ( c1 ) NEW_LINE c2 += 1 NEW_LINE DEDENT DEDENT return str ( c2 ) NEW_LINE DEDENT def merge_sets ( sets , same ) : NEW_LINE INDENT to_change = [ sets [ c1 ] for c1 in same ] NEW_LINE for c1 in range ( len ( sets ) ) : NEW_LINE INDENT if sets [ c1 ] in to_change : NEW_LINE INDENT sets [ c1 ] = to_change [ 0 ] NEW_LINE DEDENT DEDENT return sets NEW_LINE DEDENT p_file = file ( \" primes1000 . txt \" ) NEW_LINE primes = [ int ( c1 ) for c1 in p_file . read ( ) . split ( \" \\n \" ) ] NEW_LINE p_file . close ( ) NEW_LINE num = int ( inp_file . readline ( ) ) NEW_LINE for case in range ( num ) : NEW_LINE INDENT line = inp_file . readline ( ) [ : - 1 ] NEW_LINE out_file . write ( \" Case ▁ # % s : ▁ \" % ( case + 1 ) + solve ( line ) + \" \\n \" ) NEW_LINE DEDENT inp_file . close ( ) NEW_LINE out_file . close ( ) NEW_LINE"],"bleu":0.0003198698458175502,"rouge_l":0.1217397288555502}
{"id":150,"predictions":["import sys NEW_LINE class Graph : NEW_LINE INDENT def __init__ ( self , x ) : NEW_LINE INDENT self . x = x NEW_LINE self . y = y NEW_LINE DEDENT DEDENT class Solution ( object ) : NEW_LINE INDENT def __init__ ( self , x ) ** 2 == 0 : NEW_LINE INDENT self . graph = x NEW_LINE self . y = y - p NEW_LINE DEDENT def dfs ( self , x ) : NEW_LINE INDENT return self . graph [ x ] NEW_LINE DEDENT def dfs ( self , x ) : NEW_LINE INDENT return self . dfs ( x , x ) NEW_LINE DEDENT def + ( self ) : NEW_LINE INDENT return self . dfs ( x * x + y , y ) NEW_LINE DEDENT DEDENT def merge ( self , x ) : NEW_LINE INDENT return self . gcd ( x , y ) NEW_LINE DEDENT DEDENT"],"references":["import math NEW_LINE eps = 0.0000001 NEW_LINE def Solve ( H , W , D , c ) : NEW_LINE INDENT angles = [ ] NEW_LINE W = W - 2 NEW_LINE H = H - 2 NEW_LINE found = False NEW_LINE y = - 0.5 NEW_LINE for line in c : NEW_LINE INDENT x = - 0.5 NEW_LINE for char in line : NEW_LINE INDENT if char == \" X \" : NEW_LINE INDENT found = True NEW_LINE break NEW_LINE DEDENT x = x + 1 NEW_LINE DEDENT if found : NEW_LINE INDENT break NEW_LINE DEDENT y = y + 1 NEW_LINE DEDENT mx = x NEW_LINE my = y NEW_LINE co = 0 NEW_LINE for xcopy in range ( - 50 , 50 ) : NEW_LINE INDENT for ycopy in range ( - 50 , 50 ) : NEW_LINE INDENT if ( xcopy == 0 and ycopy == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if xcopy % 2 != 0 : NEW_LINE INDENT mx = ( xcopy + 1 ) * ( W ) - x NEW_LINE DEDENT else : NEW_LINE INDENT mx = xcopy * ( W ) + x NEW_LINE DEDENT if ycopy % 2 != 0 : NEW_LINE INDENT my = ( ycopy + 1 ) * ( H ) - y NEW_LINE DEDENT else : NEW_LINE INDENT my = ycopy * ( H ) + y NEW_LINE DEDENT dist = math . sqrt ( ( mx - x ) ** 2 + ( my - y ) ** 2 ) NEW_LINE if dist <= D : NEW_LINE INDENT a = 0 NEW_LINE a = math . atan2 ( ( my - y ) , ( mx - x ) ) NEW_LINE if not hasAngle ( a , angles ) : NEW_LINE INDENT co = co + 1 NEW_LINE angles . append ( a ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return co NEW_LINE DEDENT def hasAngle ( a , angles ) : NEW_LINE INDENT for an in angles : NEW_LINE INDENT if abs ( an - a ) < eps : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT f = open ( ' d . in ' ) NEW_LINE T = int ( f . readline ( ) ) NEW_LINE for t in range ( T ) : NEW_LINE INDENT H , W , D = map ( int , f . readline ( ) . split ( ) ) NEW_LINE c = [ ] NEW_LINE for x in range ( H ) : NEW_LINE INDENT c . append ( f . readline ( ) ) NEW_LINE DEDENT result = Solve ( H , W , D , c ) NEW_LINE print \" Case ▁ # % d : ▁ % s \" % ( t + 1 , result ) NEW_LINE DEDENT"],"bleu":0.03197369097275352,"rouge_l":0.24471082668704333}
{"id":151,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["import sys NEW_LINE def solve ( n , s ) : NEW_LINE INDENT cnt = 0 NEW_LINE while n > 0 : NEW_LINE INDENT m = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if s [ i ] < s [ m ] : NEW_LINE INDENT m = i NEW_LINE DEDENT DEDENT cnt += min ( m , n - 1 - m ) NEW_LINE n = n - 1 NEW_LINE del s [ m ] NEW_LINE DEDENT return cnt NEW_LINE DEDENT t = int ( sys . stdin . readline ( ) ) NEW_LINE for test_case in range ( 1 , t + 1 ) : NEW_LINE INDENT n = int ( sys . stdin . readline ( ) ) NEW_LINE s = [ int ( y ) for y in sys . stdin . readline ( ) . split ( ) ] NEW_LINE print ( ' Case ▁ # % d : ▁ % d ' % ( test_case , solve ( n , s ) ) ) NEW_LINE DEDENT"],"bleu":0.027677904931705122,"rouge_l":0.23218270114188214}
{"id":152,"predictions":["import sys NEW_LINE f = open ( sys . argv [ 1 ] ) NEW_LINE f = open ( sys . argv [ 1 ] ) NEW_LINE f = open ( sys . argv [ 1 ] , ' r ' ) NEW_LINE f = open ( ' r ' ) NEW_LINE f = int ( f . readline ( ) ) NEW_LINE def solve ( ) : NEW_LINE INDENT res = [ ] NEW_LINE for i in xrange ( len ( res ) ) : NEW_LINE INDENT res . append ( res ) NEW_LINE DEDENT f . close ( ) NEW_LINE res = [ ] NEW_LINE for i in xrange ( len ( req ) ) : NEW_LINE INDENT res . append ( res ) NEW_LINE DEDENT for i in range ( len ( req ) ) : NEW_LINE INDENT if len ( req ) > 0 : NEW_LINE INDENT res . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT res . append ( res [ - 1 ] ) NEW_LINE DEDENT DEDENT for i in range ( len ( res ) ) : NEW_LINE INDENT res . append ( res [ i ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT def solve ( * res ) : NEW_LINE INDENT f = open ( f . readline ( ) . strip ( ) ) NEW_LINE res = int ( f . readline ( ) ) NEW_LINE for r in range ( len ( res ) ) : NEW_LINE INDENT res = f . readline ( ) NEW_LINE f . readline ( ) NEW_LINE N = int ( f . readline ( ) ) NEW_LINE res = int ( f . readline ( ) ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT res = int ( f . readline ( ) ) NEW_LINE DEDENT res = int ( f . readline ( ) ) NEW_LINE for j in range ( N ) : NEW_LINE INDENT res = solve ( i + 1 , j - 1 , 1 ) NEW_LINE res = min ( res , res ) NEW_LINE DEDENT return res NEW_LINE DEDENT print \" Case ▁ # % d : ▁ % d \" % ( test + 1 , res"],"references":["inf = 2 * 10 ** 20 NEW_LINE def inv ( x ) : NEW_LINE INDENT return P - int ( x ) NEW_LINE DEDENT def xl ( l ) : NEW_LINE INDENT return xrange ( len ( l ) ) NEW_LINE DEDENT debug = False NEW_LINE for case in range ( input ( ) ) : NEW_LINE INDENT print \" Case ▁ # \" + str ( case + 1 ) + \" : \" , NEW_LINE P = input ( ) NEW_LINE need = map ( inv , raw_input ( ) . split ( ) ) NEW_LINE costs = [ ] NEW_LINE for i in xrange ( P ) : NEW_LINE INDENT costs = map ( int , raw_input ( ) . split ( ) ) + costs NEW_LINE DEDENT v = [ [ inf for i in xrange ( P + 1 ) ] for j in xrange ( 2 ** ( P + 1 ) - 1 ) ] NEW_LINE if debug : print len ( v ) , 2 ** ( P + 1 ) - 1 , 2 ** P NEW_LINE leaves = 2 ** P - 1 NEW_LINE for ( i , x ) in enumerate ( need ) : NEW_LINE INDENT for j in xrange ( x , P + 1 ) : NEW_LINE INDENT v [ leaves + i ] [ j ] = 0 NEW_LINE DEDENT DEDENT for n in xrange ( leaves - 1 , - 1 , - 1 ) : NEW_LINE INDENT if debug : print n , 2 * n + 1 , 2 * n + 2 NEW_LINE for i in xrange ( P + 1 ) : NEW_LINE INDENT if i == P : NEW_LINE INDENT buy = inf NEW_LINE DEDENT else : NEW_LINE INDENT buy = v [ 2 * n + 1 ] [ i + 1 ] + v [ 2 * n + 2 ] [ i + 1 ] + costs [ n ] NEW_LINE DEDENT skip = v [ 2 * n + 1 ] [ i ] + v [ 2 * n + 2 ] [ i ] NEW_LINE v [ n ] [ i ] = min ( buy , skip ) NEW_LINE DEDENT DEDENT print v [ 0 ] [ 0 ] NEW_LINE if debug : NEW_LINE INDENT print costs NEW_LINE for ( i , x ) in enumerate ( v ) : print i , x NEW_LINE DEDENT DEDENT"],"bleu":0.19756226779743247,"rouge_l":0.31683775714694695}
{"id":153,"predictions":["import sys NEW_LINE fin = sys . argv = open ( \" output . txt \" , \" r \" ) NEW_LINE fg = open ( \" output . txt \" , \" w \" ) NEW_LINE cases = int ( fin . readline ( ) ) NEW_LINE for case in range ( 0 , cases + 1 ) : NEW_LINE INDENT line = map ( int , fin . readline ( ) . split ( ) ) NEW_LINE q = int ( q \/ 2 ) NEW_LINE if ( q \/ 2 ) == 0 : NEW_LINE INDENTp = ( q \/ 2 ) NEW_LINE DEDENT elif ( q % 2 == 0 ) : NEW_LINE INDENT print \" Impossible \" NEW_LINE DEDENT else : NEW_LINE INDENT print \" impossible \" NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print \" impossible \" NEW_LINE DEDENT"],"references":["import functools NEW_LINE import multiprocessing NEW_LINE import fractions NEW_LINE def pow2 ( x ) : NEW_LINE INDENT return x != 0 and ( ( x & ( x - 1 ) ) == 0 ) NEW_LINE DEDENT def solve ( cs , f ) : NEW_LINE INDENT if not pow2 ( f . denominator ) : NEW_LINE INDENT return cs , ' impossible ' NEW_LINE DEDENT ret = 1 NEW_LINE while f < fractions . Fraction ( 1 , 2 ) : NEW_LINE INDENT ret += 1 NEW_LINE f *= 2 NEW_LINE DEDENT return cs , ret NEW_LINE DEDENT def reducer ( l , result ) : NEW_LINE INDENT l . append ( result ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT T = int ( input ( ) ) NEW_LINE l = [ ] NEW_LINE with multiprocessing . Pool ( processes = 8 ) as pool : NEW_LINE INDENT for cs in range ( T ) : NEW_LINE INDENT f = fractions . Fraction ( input ( ) ) NEW_LINE solve ( cs , f ) NEW_LINE pool . apply_async ( solve , args = ( cs + 1 , f , ) , callback = functools . partial ( reducer , l ) ) NEW_LINE DEDENT pool . close ( ) NEW_LINE pool . join ( ) NEW_LINE DEDENT for cs , result in sorted ( l , key = lambda x : x [ 0 ] ) : NEW_LINE INDENT print ( ' Case ▁ # { } : ▁ { } ' . format ( cs , result ) ) NEW_LINE DEDENT DEDENT"],"bleu":0.0701082765815946,"rouge_l":0.2525693160813309}
{"id":154,"predictions":["import sys NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( sys . stdin . readline ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT line = f . readline ( ) NEW_LINE flag = True NEW_LINE if ( flag ) == 0 and flag == 0 : NEW_LINE INDENT print \" Buzz \" NEW_LINE DEDENT elif flag == 100 : NEW_LINE INDENT print \" Possible \" NEW_LINE DEDENT elif flag == 100 : NEW_LINE INDENT print \" Possible \" NEW_LINE DEDENT elif flag == 100 : NEW_LINE INDENT print \" Possible \" NEW_LINE DEDENT else : NEW_LINE INDENT print \" Possible \" NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"references":["import sys , time NEW_LINE start_time = time . time ( ) NEW_LINE try : NEW_LINE INDENT if len ( sys . argv ) > 1 : NEW_LINE INDENT inname = sys . argv [ 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT inname = input ( \" Enter ▁ input ▁ filename : ▁ \" ) NEW_LINE DEDENT assert inname . endswith ( ' . in ' ) NEW_LINE outname = inname . replace ( ' . in ' , ' . out ' ) NEW_LINE with open ( inname ) as fin : NEW_LINE INDENT with open ( outname , ' w ' ) as fout : NEW_LINE INDENT num_cases = int ( fin . readline ( ) ) NEW_LINE for case_idx in range ( 1 , 1 + num_cases ) : NEW_LINE INDENT if time . time ( ) >= start_time + 5 : NEW_LINE INDENT print ( \" [ = = ▁ Case ▁ % d ▁ of ▁ % d ▁ = = ] \" % ( case_idx , num_cases ) ) NEW_LINE DEDENT N , pD , pG = [ int ( x ) for x in fin . readline ( ) . split ( ) ] NEW_LINE answer = True NEW_LINE N = min ( N , 100 ) NEW_LINE if pG == 100 and pD != 100 : answer = False NEW_LINE if pG == 0 and pD != 0 : answer = False NEW_LINE if all ( ( pD * D ) % 100 for D in range ( 1 , 1 + N ) ) : answer = False NEW_LINE print ( \" Case ▁ # { } : ▁ { } \" . format ( case_idx , ' Possible ' if answer else ' Broken ' ) , file = fout ) NEW_LINE DEDENT DEDENT DEDENT DEDENT except : NEW_LINE INDENT import traceback NEW_LINE print ( \" Exception ▁ caught : \" , file = sys . stderr ) NEW_LINE print ( ' - ' * 60 , file = sys . stderr ) NEW_LINE traceback . print_exc ( file = sys . stderr ) NEW_LINE print ( ' - ' * 60 , file = sys . stderr ) NEW_LINE input ( \" Press ▁ Enter ▁ to ▁ close \" ) NEW_LINE DEDENT else : NEW_LINE INDENT total_time = time . time ( ) - start_time NEW_LINE print ( \" Completed ▁ in ▁ % .1f ▁ seconds \" % total_time , file = sys . stderr ) NEW_LINE time . sleep ( 3 ) NEW_LINE DEDENT"],"bleu":0.02928424145843784,"rouge_l":0.24361022364217252}
{"id":155,"predictions":["import math NEW_LINE def solve ( ) : NEW_LINE INDENT d = { } NEW_LINE for i in xrange ( len ( d ) ) : NEW_LINE INDENT if d [ i ] . is None : NEW_LINE INDENT d [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ i ] = 1 NEW_LINE DEDENT DEDENT for j in range ( len ( d ) ) : NEW_LINE INDENT if d [ j ] > 2 : NEW_LINE INDENT d [ j ] = d [ j ] + d [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT d [ j ] = d [ j ] NEW_LINE DEDENT DEDENT return d [ 0 ] NEW_LINE DEDENT for i in range ( 1 , len ( d ) ) : NEW_LINE INDENT if d [ i ] > max ( d [ i ] ) : NEW_LINE INDENT d [ i ] = d [ i ] + d [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT if d [ i ] > 0 : NEW_LINE INDENT d [ i ] = d [ i ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return d [ i ] NEW_LINE DEDENT DEDENT print \" Case ▁ # % d : ▁ % d \" % ( c + 1 , d ) ) NEW_LINE DEDENT"],"references":["import os , sys , time , random NEW_LINE time . clock ( ) NEW_LINE sys . stdin = open ( ' C - small - 1 - attempt0 . in ' ) NEW_LINE sys . stdout = open ( ' C - small - 1 - attempt0 . out ' , ' w ' ) NEW_LINE def Work ( ) : NEW_LINE INDENT n = int ( input ( ) . strip ( ) ) NEW_LINE sb = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT d , h , m = map ( int , input ( ) . strip ( ) . split ( ) ) NEW_LINE for j in range ( h ) : NEW_LINE INDENT sb . append ( ( d , 360 \/ ( m + j ) ) ) NEW_LINE DEDENT DEDENT sb . sort ( key = lambda d : d [ - 1 ] , reverse = True ) NEW_LINE if sb [ 0 ] [ 1 ] == sb [ 1 ] [ 1 ] : return 0 NEW_LINE ar1 = ( 360 - sb [ 1 ] [ 0 ] ) \/ sb [ 1 ] [ 1 ] NEW_LINE meet = ( 360 + sb [ 1 ] [ 0 ] - sb [ 0 ] [ 0 ] ) \/ ( sb [ 0 ] [ 1 ] - sb [ 1 ] [ 1 ] ) NEW_LINE if meet <= ar1 + 1e-8 : return 1 NEW_LINE return 0 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT T = int ( input ( ) ) NEW_LINE for i in range ( T ) : NEW_LINE INDENT print ( ' Case ▁ # % d : ▁ % d ' % ( i + 1 , Work ( ) ) ) NEW_LINE DEDENT sys . stderr . write ( ' completed ▁ % .3f \\n ' % time . clock ( ) ) NEW_LINE DEDENT"],"bleu":0.12953052181764924,"rouge_l":0.3322957198443579}
{"id":156,"predictions":["import sys NEW_LINE def fract ( n , c ) : NEW_LINE INDENT seen = False NEW_LINE x = 0 NEW_LINE while True : NEW_LINE INDENT seen = \" \" + str ( x ) NEW_LINE if len ( seen ) == 10 : NEW_LINE INDENT seen [ ord ( c ) - ord ( '0' ) ] = True NEW_LINE seen [ ord ( c ) - ord ( '0' ) ] = True NEW_LINE if not seen [ False ] : NEW_LINE INDENT seen [ ord ( c ) - ord ( '0' ) ] = False NEW_LINE n += 1 NEW_LINE DEDENT DEDENT if not seen [ 1 ] : NEW_LINE INDENT return x NEW_LINE DEDENT DEDENT for i in range ( 1 , cases ) : NEW_LINE INDENT if seen [ i ] == 0 : NEW_LINE INDENT return \" + str ( i ) NEW_LINE DEDENT DEDENT print ( \" Case ▁ # % d : \" % ( i + 1 ) , sep = \" \" ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE def sheep ( N ) : NEW_LINE INDENT if N == 0 : return \" INSOMNIA \" NEW_LINE d = 0 ; t = N NEW_LINE while 1 : NEW_LINE INDENT for x in str ( t ) : d |= 1 << int ( x ) NEW_LINE if d == 1023 : return t NEW_LINE t += N NEW_LINE DEDENT DEDENT case = 0 NEW_LINE for x in sys . stdin : NEW_LINE INDENT if case > 0 : NEW_LINE INDENT N = int ( x . strip ( ) ) NEW_LINE print \" Case ▁ # % d : \" % case , sheep ( N ) NEW_LINE DEDENT case += 1 NEW_LINE DEDENT"],"bleu":0.1906658104568582,"rouge_l":0.4144403500690926}
{"id":157,"predictions":["for s in [ * open ( 0 ) ] [ 1 : ] : NEW_LINE INDENT t = int ( f . readline ( ) ) NEW_LINE for i in xrange ( t ) : NEW_LINE INDENT n , m = map ( int , s . split ( ) ) NEW_LINE arr . sort ( ) NEW_LINE for i in arr : NEW_LINE INDENT print \" Case ▁ # % d : ▁ % d \" % ( i , arr [ 1 : ] ) NEW_LINE DEDENT DEDENT DEDENT"],"references":["import collections NEW_LINE import sys NEW_LINE if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT f = sys . stdin NEW_LINE if len ( sys . argv ) >= 2 : NEW_LINE INDENT fn = sys . argv [ 1 ] NEW_LINE if fn != ' - ' : NEW_LINE INDENT f = open ( fn ) NEW_LINE DEDENT DEDENT T = int ( f . readline ( ) ) NEW_LINE for _T in xrange ( T ) : NEW_LINE INDENT N , X = map ( int , f . readline ( ) . split ( ) ) NEW_LINE disks = map ( int , f . readline ( ) . split ( ) ) NEW_LINE assert len ( disks ) == N NEW_LINE disks . sort ( ) NEW_LINE disks = collections . deque ( disks ) NEW_LINE r = 0 NEW_LINE while disks : NEW_LINE INDENT x1 = disks . pop ( ) NEW_LINE if disks and x1 + disks [ 0 ] <= X : NEW_LINE INDENT disks . popleft ( ) NEW_LINE DEDENT r += 1 NEW_LINE DEDENT print \" Case ▁ # % d : ▁ % d \" % ( _T + 1 , r ) NEW_LINE DEDENT DEDENT"],"bleu":0.1384381760339907,"rouge_l":0.4021298174442191}
{"id":158,"predictions":["tt = int ( raw_input ( ) ) NEW_LINE for t in xrange ( 1 , tt + 1 ) : NEW_LINE INDENT L = list ( map ( int , raw_input ( ) . split ( ) ) ) NEW_LINE count = 0 NEW_LINE l = [ 0 ] * ( 2 * n - 1 ) NEW_LINE for x in l : NEW_LINE INDENT if x % 2 != 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if count % 2 != 0 : NEW_LINE INDENT l [ i ] = 1 NEW_LINE DEDENT DEDENT DEDENT print ( ' Case ▁ # % d : ▁ % s ' % ( t + 1 ) ) NEW_LINE DEDENT"],"references":["t = int ( raw_input ( ) ) NEW_LINE for cas in xrange ( 1 , t + 1 ) : NEW_LINE INDENT n = int ( raw_input ( ) ) NEW_LINE ct = dict ( zip ( xrange ( 1 , 2501 ) , [ 0 for i in xrange ( 1 , 2501 ) ] ) ) NEW_LINE for i in xrange ( 1 , 2 * n ) : NEW_LINE INDENT nums = map ( int , raw_input ( ) . split ( ) ) NEW_LINE for num in nums : NEW_LINE INDENT ct [ num ] += 1 NEW_LINE DEDENT DEDENT ans = [ ] NEW_LINE for i in ct : NEW_LINE INDENT if ct [ i ] % 2 == 1 : NEW_LINE INDENT ans . append ( i ) NEW_LINE DEDENT DEDENT ans . sort ( ) NEW_LINE ans = \" ▁ \" . join ( map ( str , ans ) ) NEW_LINE print \" Case ▁ # { } : ▁ { } \" . format ( cas , ans ) NEW_LINE DEDENT"],"bleu":0.29186207386045626,"rouge_l":0.4511389409328469}
{"id":159,"predictions":["import sys NEW_LINE def main ( ) : NEW_LINE INDENT d = { } NEW_LINE l = [ ] NEW_LINE for x in sys . stdin . readline ( ) . strip ( ) : NEW_LINE INDENT if x < l : NEW_LINE INDENT return ' { } ' . format ( x , 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return l NEW_LINE DEDENT DEDENT DEDENT return ' \\n ' . join ( map ( str , raw_input ( ) . split ( \" ▁ \" ) ) ) NEW_LINE DEDENT import sys NEW_LINE"],"references":["A = 3 NEW_LINE B = 1 NEW_LINE n = 1 NEW_LINE tmp = 0 NEW_LINE X = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] NEW_LINE Y = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] NEW_LINE while n < 31 : NEW_LINE INDENT X [ n ] = A NEW_LINE Y [ n ] = B NEW_LINE tmp = 3 * A + B * 5 NEW_LINE B = A + 3 * B NEW_LINE A = tmp NEW_LINE n = n + 1 NEW_LINE DEDENT d = 22360679774997896964091736687312762354406183596115257242708972454105209256378048 NEW_LINE N = input ( ) NEW_LINE n = 0 NEW_LINE while n < N : NEW_LINE INDENT n = n + 1 NEW_LINE f = input ( ) NEW_LINE p = X [ f ] + int ( Y [ f ] * d \/ 10000000000000000000000000000000000000000000000000000000000000000000000000000000 ) NEW_LINE print \" Case ▁ # % d : ▁ % .3d \" % ( n , int ( p ) % 1000 ) NEW_LINE DEDENT"],"bleu":0.006268341716988452,"rouge_l":0.1278290025146689}
{"id":160,"predictions":["import sys NEW_LINE def simplify ( x , d , V ) : NEW_LINE INDENT if x < 31 : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT return x NEW_LINE DEDENT DEDENT L = int ( sys . stdin . readline ( ) ) NEW_LINE for i in xrange ( 1 ) : NEW_LINE INDENT L , d = map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE R = map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE l = 0 NEW_LINE r = 0 NEW_LINE for c in sys . stdin . readline ( ) . split ( ) : NEW_LINE INDENT l = [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE m = max ( 0 , l ) NEW_LINE c = 0 NEW_LINE for i in xrange ( D ) : NEW_LINE INDENT if x + l [ i ] == 31 : NEW_LINE INDENT c += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m = max ( m , c ) NEW_LINE DEDENT DEDENT DEDENT print \" Case ▁ # % d : ▁ % d \" % ( c + 1 , d ) NEW_LINE DEDENT"],"references":["testSum = input ( ) NEW_LINE for test in xrange ( testSum ) : NEW_LINE INDENT c , d , v = map ( int , raw_input ( ) . split ( ) ) NEW_LINE coins = map ( int , raw_input ( ) . split ( ) ) NEW_LINE ansCoins = [ ] NEW_LINE now = 0 NEW_LINE ans = 0 NEW_LINE i = 0 NEW_LINE while now < v : NEW_LINE INDENT if i < len ( coins ) and ( coins [ i ] <= now + 1 ) : NEW_LINE INDENT ansCoins . append ( coins [ i ] ) NEW_LINE now = now + coins [ i ] * c NEW_LINE i = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ansCoins . append ( now + 1 ) NEW_LINE ans = ans + 1 NEW_LINE now = now + ( now + 1 ) * c NEW_LINE DEDENT DEDENT print \" Case ▁ # \" + str ( test + 1 ) + \" : \" , ans NEW_LINE DEDENT"],"bleu":0.24620935451150355,"rouge_l":0.45158875395108966}
{"id":161,"predictions":["import sys NEW_LINE def main ( ) : NEW_LINE INDENT r = list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) NEW_LINE g = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( len ( g ) ) ] NEW_LINE for i in range ( 0 , len ( b ) ) : NEW_LINE INDENT for j in range ( 0 , len ( b ) ) : NEW_LINE INDENT if i > j : NEW_LINE INDENT g [ i ] += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT b [ i ] = [ j ] NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 0 , len ( b ) ) : NEW_LINE INDENT if b [ i ] [ 2 ] == b [ i ] [ 3 ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["from __future__ import division NEW_LINE import collections NEW_LINE import itertools NEW_LINE import sys NEW_LINE import copy NEW_LINE class gcj : NEW_LINE INDENT IN = sys . stdin NEW_LINE number = 0 NEW_LINE @ classmethod NEW_LINE def case ( cls ) : NEW_LINE INDENT cls . number += 1 NEW_LINE return ' Case ▁ # % d : ' % cls . number NEW_LINE DEDENT @ classmethod NEW_LINE def line ( cls , type = str ) : NEW_LINE INDENT line = cls . IN . readline ( ) NEW_LINE return type ( line . strip ( ' \\n ' ) ) NEW_LINE DEDENT @ classmethod NEW_LINE def splitline ( cls , type = str ) : NEW_LINE INDENT line = cls . IN . readline ( ) NEW_LINE return [ type ( x ) for x in line . split ( ) ] NEW_LINE DEDENT DEDENT def go ( ) : NEW_LINE INDENT c = gcj . line ( int ) NEW_LINE for _ in xrange ( c ) : NEW_LINE INDENT r = gcj . line ( int ) NEW_LINE grid = [ [ 0 ] * 101 for _ in xrange ( 101 ) ] NEW_LINE for _ in xrange ( r ) : NEW_LINE INDENT x1 , y1 , x2 , y2 = gcj . splitline ( int ) NEW_LINE for x in xrange ( x1 , x2 + 1 ) : NEW_LINE INDENT for y in xrange ( y1 , y2 + 1 ) : NEW_LINE INDENT grid [ x ] [ y ] = 1 NEW_LINE DEDENT DEDENT DEDENT print gcj . case ( ) , solve ( grid ) NEW_LINE DEDENT DEDENT def solve ( grid ) : NEW_LINE INDENT t = 0 NEW_LINE while True : NEW_LINE INDENT done = True NEW_LINE for x in xrange ( 100 , 0 , - 1 ) : NEW_LINE INDENT for y in xrange ( 100 , 0 , - 1 ) : NEW_LINE INDENT if grid [ x ] [ y ] == 1 : NEW_LINE INDENT done = False NEW_LINE DEDENT if grid [ x - 1 ] [ y ] == grid [ x ] [ y - 1 ] : NEW_LINE INDENT grid [ x ] [ y ] = grid [ x ] [ y - 1 ] NEW_LINE DEDENT DEDENT DEDENT if done : NEW_LINE INDENT return t NEW_LINE DEDENT t += 1 NEW_LINE DEDENT DEDENT go ( ) NEW_LINE"],"bleu":0.0765593133267727,"rouge_l":0.3279227557411274}
{"id":162,"predictions":["def solve ( ) : NEW_LINE INDENT if len ( v ) == 10 : NEW_LINE INDENT return v NEW_LINE DEDENT return v NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT f = open ( sys . argv [ 1 : ] ) NEW_LINE t = int ( f . readline ( ) ) NEW_LINE for x in xrange ( t ) : NEW_LINE INDENT m = int ( f . readline ( ) ) NEW_LINE if x != n : NEW_LINE INDENT return t - 1 NEW_LINE DEDENT else : NEW_LINE INDENT n = int ( f . readline ( ) . strip ( ) ) NEW_LINE DEDENT DEDENT print \" Case ▁ # % d : ▁ % d \" % ( x + 1 ) NEW_LINE DEDENT"],"references":["import os , sys , time , random NEW_LINE time . clock ( ) NEW_LINE sys . stdin = open ( ' A - large . in ' ) NEW_LINE sys . stdout = open ( ' A - large . out ' , ' w ' ) NEW_LINE def flip ( x ) : NEW_LINE INDENT return int ( str ( x ) [ : : - 1 ] . lstrip ( '0' ) ) NEW_LINE DEDENT def Preprocess ( ) : NEW_LINE INDENT global f NEW_LINE n = 100002 NEW_LINE f = [ n ] * n NEW_LINE f [ 1 ] = 1 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT f [ i + 1 ] = min ( f [ i + 1 ] , f [ i ] + 1 ) NEW_LINE if flip ( i ) < n : NEW_LINE INDENT f [ flip ( i ) ] = min ( f [ flip ( i ) ] , f [ i ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT def GetCheckPoint ( x ) : NEW_LINE INDENT l = len ( str ( x ) ) NEW_LINE if str ( x ) . endswith ( '0' * ( l - l \/\/ 2 ) ) : NEW_LINE INDENT return GetCheckPoint ( x - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ret = int ( str ( x ) [ : l \/\/ 2 ] + '0' * ( l - l \/\/ 2 - 1 ) + '1' ) NEW_LINE if str ( x ) [ : l \/\/ 2 ] == '1' + '0' * ( l \/\/ 2 - 1 ) : NEW_LINE INDENT return GetCheckPoint ( ret - 2 ) NEW_LINE DEDENT return ret NEW_LINE DEDENT DEDENT def Calc ( n ) : NEW_LINE INDENT if n < 100 : return f [ n ] NEW_LINE cp = GetCheckPoint ( n ) NEW_LINE return Calc ( flip ( cp ) ) + 1 + n - cp NEW_LINE DEDENT def Work ( ) : NEW_LINE INDENT n = int ( input ( ) . strip ( ) ) NEW_LINE return Calc ( n ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT Preprocess ( ) NEW_LINE T = int ( input ( ) ) NEW_LINE for i in range ( T ) : NEW_LINE INDENT print ( ' Case ▁ # % d : ▁ % d ' % ( i + 1 , Work ( ) ) ) NEW_LINE DEDENT sys . stderr . write ( ' completed ▁ % .3f \\n ' % time . clock ( ) ) NEW_LINE DEDENT"],"bleu":0.047742054438800974,"rouge_l":0.26602837234949117}
{"id":163,"predictions":["import sys NEW_LINE def solve ( a , b , k ) : NEW_LINE INDENT if ( a < b and b < k ) : NEW_LINE INDENT return a NEW_LINE DEDENT for i in range ( a ) : NEW_LINE INDENT for j in range ( b ) : NEW_LINE INDENT if ( i & j ) < k : NEW_LINE INDENT l += 1 NEW_LINE DEDENT DEDENT DEDENT return l NEW_LINE DEDENT T = int ( raw_input ( ) ) NEW_LINE for case in range ( 1 , t + 1 ) : NEW_LINE INDENT print ( \" Case ▁ # % d : ▁ % d \" % ( case + 1 ) ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE from itertools import zip_longest as zip NEW_LINE T = int ( sys . stdin . readline ( ) . strip ( ) ) NEW_LINE for t in range ( T ) : NEW_LINE INDENT A , B , K = tuple ( int ( i ) for i in sys . stdin . readline ( ) . strip ( ) . split ( ) ) NEW_LINE cnt = 0 NEW_LINE for a in range ( A ) : NEW_LINE INDENT for b in range ( B ) : NEW_LINE INDENT if a & b < K : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT print ( \" Case ▁ # % d : ▁ % d \" % ( t + 1 , cnt ) ) NEW_LINE DEDENT"],"bleu":0.35660315305046003,"rouge_l":0.47932500322040444}
{"id":164,"predictions":["import sys NEW_LINE def solve ( L , P ) : NEW_LINE INDENT if R == 1 : NEW_LINE INDENT return ' ▁ % s ' NEW_LINE DEDENT else : NEW_LINE INDENT return '0' NEW_LINE DEDENT DEDENT T = int ( raw_input ( ) ) NEW_LINE for t in xrange ( 1 , T + 1 ) : NEW_LINE INDENT N , L = map ( int , raw_input ( ) . split ( ' ▁ ' ) ) NEW_LINE P = map ( int , raw_input ( ) . split ( ' ▁ ' ) ) NEW_LINE if N == 1 : NEW_LINE INDENT print ' Case ▁ # % s : ▁ % s ' % ( tc + 1 ) ) NEW_LINE DEDENT DEDENT"],"references":["import sys NEW_LINE def ntests ( L , P , C ) : NEW_LINE INDENT ratio = P * 1.0 \/ L NEW_LINE if ratio <= C : return 0 NEW_LINE if L == 1 and P == 3 : return 1 NEW_LINE testpoint = int ( L * ( ratio ** 0.5 ) ) NEW_LINE count = max ( 1 + ntests ( L , testpoint , C ) , 1 + ntests ( testpoint , P , C ) ) NEW_LINE if ( testpoint * testpoint == L * P or testpoint + 1 == P ) : NEW_LINE INDENT return count NEW_LINE DEDENT count2 = max ( 1 + ntests ( L , testpoint + 1 , C ) , 1 + ntests ( testpoint + 1 , P , C ) ) NEW_LINE return min ( count , count2 ) NEW_LINE DEDENT infile = sys . stdin NEW_LINE T = int ( infile . readline ( ) . strip ( ) ) NEW_LINE for i in xrange ( T ) : NEW_LINE INDENT L , P , C = map ( int , infile . readline ( ) . strip ( ) . split ( ) ) NEW_LINE result = ntests ( L , P , C ) NEW_LINE print ( \" Case ▁ # % d : ▁ % s \" % ( i + 1 , str ( result ) ) ) NEW_LINE DEDENT"],"bleu":0.13987648996413202,"rouge_l":0.40270842149809566}
{"id":165,"predictions":["import sys NEW_LINE def main ( ) : NEW_LINE INDENT t = int ( sys . stdin . readline ( ) ) NEW_LINE for c in xrange ( len ( x ) ) : NEW_LINE INDENT n = int ( sys . stdin . readline ( ) ) NEW_LINE A = sorted ( [ int ( x ) for x in sys . stdin . readline ( ) . strip ( ) ] ) NEW_LINE K = sorted ( A ) NEW_LINE if K < len ( A ) : NEW_LINE INDENT print ' Case ▁ # % d : ' % ( c + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT k = 0 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ' Case ▁ # % d : ▁ ' % s ' % ( tc ) NEW_LINE DEDENT"],"references":["def war ( n , k ) : NEW_LINE INDENT n = [ float ( block ) for block in n . split ( \" ▁ \" ) ] NEW_LINE k = [ float ( block ) for block in k . split ( \" ▁ \" ) ] NEW_LINE points = 0 NEW_LINE n = reversed ( sorted ( n ) ) NEW_LINE for nblock in n : NEW_LINE INDENT if nblock > max ( k ) : NEW_LINE INDENT points += 1 NEW_LINE k . remove ( min ( k ) ) NEW_LINE DEDENT else : NEW_LINE INDENT k . remove ( min ( [ block for block in k if block > nblock ] ) ) NEW_LINE DEDENT DEDENT return str ( points ) NEW_LINE DEDENT def dwar ( n , k ) : NEW_LINE INDENT n = [ float ( block ) for block in n . split ( \" ▁ \" ) ] NEW_LINE k = [ float ( block ) for block in k . split ( \" ▁ \" ) ] NEW_LINE points = 0 NEW_LINE n = sorted ( n ) NEW_LINE for nblock in n : NEW_LINE INDENT if nblock > min ( k ) : NEW_LINE INDENT points += 1 NEW_LINE k . remove ( min ( k ) ) NEW_LINE DEDENT else : NEW_LINE INDENT k . remove ( max ( k ) ) NEW_LINE DEDENT DEDENT return str ( points ) NEW_LINE DEDENT input_text = open ( \" input . in \" ) NEW_LINE lines = input_text . readlines ( ) NEW_LINE input_text . close ( ) NEW_LINE with open ( \" output \" , \" a \" ) as outputfile : NEW_LINE INDENT for num in range ( 0 , int ( lines [ 0 ] ) ) : NEW_LINE INDENT outputfile . write ( \" Case ▁ # \" + str ( num + 1 ) + \" : ▁ \" + dwar ( lines [ num * 3 + 2 ] , lines [ num * 3 + 3 ] ) + \" ▁ \" + war ( lines [ num * 3 + 2 ] , lines [ num * 3 + 3 ] ) + \" \\n \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.05251364915298147,"rouge_l":0.26964808542396235}
{"id":166,"predictions":["t = int ( raw_input ( ) ) NEW_LINE for t in range ( t ) : NEW_LINE INDENT m , t , n , t = map ( int , raw_input ( ) . split ( ) ) NEW_LINE l = [ ] NEW_LINE c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if t >= n : NEW_LINE INDENT l = ( c + t \/\/ 2 ) NEW_LINE c += 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = t NEW_LINE c += 1 NEW_LINE DEDENT DEDENT if c <= n : NEW_LINE INDENT print \" Case ▁ # % d : ▁ % s \" % ( t + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print \" Case ▁ # % d : ▁ % s \" % ( t + 1 ) NEW_LINE DEDENT DEDENT"],"references":["import sys NEW_LINE from itertools import islice NEW_LINE def solve ( L , t , N , C , a ) : NEW_LINE INDENT tot_dist = 0 NEW_LINE eff_dists = [ ] NEW_LINE for s in xrange ( N ) : NEW_LINE INDENT d = a [ s % len ( a ) ] NEW_LINE if tot_dist + d <= t : NEW_LINE INDENT eff_dists . append ( ( d , 0 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT if tot_dist >= t : NEW_LINE INDENT eff_dists . append ( ( d , d ) ) NEW_LINE DEDENT else : NEW_LINE INDENT eff_dists . append ( ( d , d - ( t - tot_dist ) ) ) NEW_LINE DEDENT DEDENT tot_dist += d NEW_LINE DEDENT tot_time = 0 NEW_LINE for dist , eff_dist in sorted ( eff_dists , key = lambda x : x [ 1 ] , reverse = True ) : NEW_LINE INDENT if L > 0 : NEW_LINE INDENT tot_time += eff_dist + 2 * ( dist - eff_dist ) NEW_LINE L -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT tot_time += dist * 2 NEW_LINE DEDENT DEDENT return tot_time \/\/ 2 NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT T = int ( next ( sys . stdin ) ) NEW_LINE for test in xrange ( 1 , T + 1 ) : NEW_LINE INDENT print >> sys . stderr , test NEW_LINE line = next ( sys . stdin ) NEW_LINE L , t , N , C , a = line . split ( None , 4 ) NEW_LINE L , t , N , C = map ( int , ( L , t , N , C ) ) NEW_LINE a = list ( int ( ai ) * 2 for ai in a . split ( ) ) NEW_LINE print \" Case ▁ # % s : ▁ % s \" % ( test , solve ( L , t , N , C , a ) ) NEW_LINE DEDENT DEDENT main ( ) NEW_LINE"],"bleu":0.10257713770297225,"rouge_l":0.29807632832312736}
{"id":167,"predictions":["import sys NEW_LINE def main ( ) : NEW_LINE INDENT K = int ( sys . argv [ 1 ] ) NEW_LINE for i in xrange ( K ) : NEW_LINE INDENT K = int ( sys . stdin . readline ( ) ) NEW_LINE L = map ( int , sys . stdin . readline ( ) . strip ( ) . split ( \" A \" ) ) NEW_LINE S = [ 0 ] * 26 NEW_LINE for i in xrange ( K ) : NEW_LINE INDENT if K [ i ] != 0 : NEW_LINE INDENT continue NEW_LINE DEDENT seen [ i ] = False NEW_LINE DEDENT if not seen [ i ] : NEW_LINE INDENT m = 1 NEW_LINE DEDENT seen = [ 0 ] * 26 NEW_LINE for i in xrange ( L ) : NEW_LINE INDENT c = 0 NEW_LINE for j in xrange ( L - 1 , - 1 , - 1 ) : NEW_LINE INDENT if c [ i ] [ j ] == 0 : NEW_LINE INDENT m = c [ j ] NEW_LINE c = 1 NEW_LINE DEDENT DEDENT elif c == DEDENT if c == 2 : NEW_LINE INDENT b = c + 1 NEW_LINE DEDENT DEDENT result = \" Case ▁ # % d : ▁ % d \" % ( i + 1 , result ) NEW_LINE print \" Case ▁ # % d : ▁ % i ▁ % ( i + 1 , result ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE import math NEW_LINE from collections import defaultdict NEW_LINE f = open ( ' B - large . in ' ) NEW_LINE tests = int ( f . readline ( ) ) NEW_LINE def getOffset ( keys , target ) : NEW_LINE INDENT s = set ( list ( keys ) ) NEW_LINE for c in target : NEW_LINE INDENT if c not in s : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT offset = 1 NEW_LINE while offset < len ( target ) : NEW_LINE INDENT if target [ : len ( target ) - offset ] == target [ offset : ] : NEW_LINE INDENT break NEW_LINE DEDENT offset += 1 NEW_LINE DEDENT return offset NEW_LINE DEDENT def getExp ( keys , target , s ) : NEW_LINE INDENT d = defaultdict ( lambda : 0.0 ) NEW_LINE for c in keys : NEW_LINE INDENT d [ c ] += 1.0 \/ len ( keys ) NEW_LINE DEDENT tot = 1.0 NEW_LINE for c in target : NEW_LINE INDENT tot *= d [ c ] NEW_LINE DEDENT return tot * ( s - len ( target ) + 1 ) NEW_LINE DEDENT for t in xrange ( tests ) : NEW_LINE INDENT k , l , s = map ( int , f . readline ( ) . rstrip ( ) . split ( ) ) NEW_LINE keys = f . readline ( ) . rstrip ( ) NEW_LINE target = f . readline ( ) . rstrip ( ) NEW_LINE offset = getOffset ( keys , target ) NEW_LINE if offset == 0 : NEW_LINE INDENT print \" Case ▁ # \" + str ( t + 1 ) + \" : ▁ 0.0\" NEW_LINE continue NEW_LINE DEDENT needed = 1 + ( s - len ( target ) ) \/\/ offset NEW_LINE ans = max ( 0.0 , needed - getExp ( keys , target , s ) ) NEW_LINE if ans < 0.000000001 : NEW_LINE INDENT ans = 0.0 NEW_LINE DEDENT print \" Case ▁ # \" + str ( t + 1 ) + \" : ▁ \" + str ( ans ) NEW_LINE DEDENT"],"bleu":0.1662750486160789,"rouge_l":0.3208374155623163}
{"id":168,"predictions":["def solve ( s ) : NEW_LINE INDENT memo = { } NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] < 0 ) : NEW_LINE INDENT memo [ i ] += ' NEW_LINE DEDENT else : NEW_LINE INDENT memo [ i ] = ' NEW_LINE DEDENT DEDENT return ' ' NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = input ( ) NEW_LINE y = map ( int , input ( ) . split ( ) ) NEW_LINE if ( x == ' S ' ) : NEW_LINE INDENT print \" F \" NEW_LINE DEDENT else : NEW_LINE INDENT print \"0\" NEW_LINE DEDENT DEDENT"],"references":["import sys NEW_LINE T = int ( sys . stdin . readline ( ) ) NEW_LINE for ca in xrange ( 1 , T + 1 ) : NEW_LINE INDENT [ X , Y ] = [ int ( v ) for v in sys . stdin . readline ( ) . split ( \" ▁ \" ) ] NEW_LINE print \" Case ▁ # % d : ▁ \" % ca , NEW_LINE if X > 0 : NEW_LINE INDENT for i in range ( X ) : NEW_LINE INDENT sys . stdout . write ( \" W \" ) , NEW_LINE sys . stdout . write ( \" E \" ) , NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT X = - X NEW_LINE for i in range ( X ) : NEW_LINE INDENT sys . stdout . write ( \" E \" ) , NEW_LINE sys . stdout . write ( \" W \" ) , NEW_LINE DEDENT DEDENT if Y > 0 : NEW_LINE INDENT for i in range ( Y ) : NEW_LINE INDENT sys . stdout . write ( \" S \" ) , NEW_LINE sys . stdout . write ( \" N \" ) , NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT Y = - Y NEW_LINE for i in range ( Y ) : NEW_LINE INDENT sys . stdout . write ( \" N \" ) , NEW_LINE sys . stdout . write ( \" S \" ) , NEW_LINE DEDENT DEDENT print \" \" NEW_LINE DEDENT"],"bleu":0.14336612396546825,"rouge_l":0.3133148952983011}
{"id":169,"predictions":["s = input ( ) ans = [ ]   for i in range ( len ( s ) - 1 ) : if ( s [ i ] == '0' ) : ans . append ( i ) print ( len ( ans ) ) return else : for i in range ( len ( s ) ) : if ( s [ i ] == '0' ) : ans . append ( s [ i ] ) else : ans . append ( s [ i ] ) print ( len ( ans ) )     NEW_LINE"],"references":["import re     def is_int ( s : str ) -> bool : if len ( s ) > 0 and ( s [ 0 ] == \"0\" and len ( s ) > 1 ) : return False else : try : int ( s ) return True except : return False     def partition ( pred , iterable ) : trues = [ ] falses = [ ] for item in iterable : if pred ( item ) : trues . append ( item ) else : falses . append ( item ) return trues , falses     def print_ans ( s ) : if len ( s ) > 0 : print ( \" \\ \" { } \\ \" \" . format ( \" , \" . join ( s ) ) ) else : print ( \" - \" )     s = re . split ( \" ; | , \" , input ( ) ) s_int , s_str = partition ( is_int , s ) print_ans ( s_int ) print_ans ( s_str ) NEW_LINE"],"bleu":0.09854060539010161,"rouge_l":0.3196506550218341}
{"id":170,"predictions":["for t in range ( int ( input ( ) ) ) : b , c , h , f = map ( int , input ( ) . split ( ) ) if b > f : p = q * 2 - f = ( b \/\/ 2 ) * p if b > f : q = p * 2 - f else : q = = q \/\/ 2 - f = ( b \/\/ 2 ) * p if q >= f : q += p * q - f else : q *= 2 - f m % 2 print ( p ) NEW_LINE"],"references":["def solve ( ) : b , p , f = map ( int , input ( ) . split ( ) ) h , c = map ( int , input ( ) . split ( ) )   NEW_LINE"],"bleu":0.1979067783348251,"rouge_l":0.38973024136299106}
{"id":171,"predictions":["h1 , m2 = map ( int , input ( ) . split ( ) ) h1 , m2 = str ( input ( ) . split ( \" : \" ) ) h1 , m2 = map ( int , input ( ) . split ( \" : \" ) ) m1 = min ( h1 , m1 ) m2 = min ( h1 , m2 ) print ( ( \" : : \" , end = \" : \" ) ) NEW_LINE"],"references":["a = input ( ) . split ( ' : ' ) b = input ( ) . split ( ' : ' )       x = int ( a [ 0 ] ) * 60 + int ( a [ 1 ] ) y = int ( b [ 0 ] ) * 60 + int ( b [ 1 ] )     if y > x : x = ( ( int ( a [ 0 ] ) + 24 ) * 60 ) + int ( a [ 1 ] )     z = x - y   hr = str ( z \/\/ 60 ) . rjust ( 2 , '0' ) z %= 60 mi = str ( z ) . rjust ( 2 , '0' )   print ( f \" { hr } : { mi } \" )   NEW_LINE"],"bleu":0.10149195285755591,"rouge_l":0.33029582673005814}
{"id":172,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) m = int ( input ( ) ) l = [ ] for i in range ( n ) : a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) for i in range ( n ) : print ( abs ( a [ i ] - l [ i ] ) ) + 1 NEW_LINE"],"references":["n = int ( input ( ) ) nn = list ( map ( int , input ( ) . split ( ) ) ) m = int ( input ( ) ) mm = list ( map ( int , input ( ) . split ( ) ) ) nn . sort ( ) mm . sort ( ) i = 0j = 0 count = 0   while i < n and j < m : if abs ( nn [ i ] - mm [ j ] ) <= 1 : count += 1 i += 1 j += 1 elif nn [ i ] < mm [ j ] : i += 1 else : j += 1 print ( count ) NEW_LINE"],"bleu":0.3903361000104838,"rouge_l":0.561267708485468}
{"id":173,"predictions":["n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) if n % 2 == 0 : print ( ' EAB ' ) elif n % 2 == 0 : print ( ' EABOSS ' ) else : print ( ' EAB ' ) NEW_LINE"],"references":["n = int ( input ( ) )     if n == 1 : print ( ' Ehab ' ) elif n % 2 == 0 : print ( ' Mahmoud ' ) else : print ( ' Ehab ' ) NEW_LINE"],"bleu":0.48438299236295684,"rouge_l":0.7318417639429312}
{"id":174,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = [ ] for i in range ( n ) : b . append ( list ( map ( int , input ( ) . split ( ) ) ) ) s = Falsefor i in range ( n ) : if b [ i ] != b [ i - 1 ] : s . append ( b [ i ] , i ) print ( len ( s ) ) NEW_LINE"],"references":["import sysinput = sys . stdin . buffer . readline   n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) )   ''' diffs ▁ = [ ] miss ▁ = ▁ set ( list ( range ( 1 , n + 1 ) ) ) for ▁ i ▁ in ▁ range ( n ) : ▁ ▁ ▁ ▁ if ▁ a [ i ] ▁ ! = ▁ b [ i ] : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ diffs . append ( i ) ▁ ▁ ▁ ▁ miss . discard ( a [ i ] )  if ▁ len ( diffs ) ▁ = = ▁ 1 : ▁ ▁ ▁ ▁ # ▁ no ▁ other ▁ option ▁ ▁ ▁ ▁ a [ diffs [ 0 ] ] ▁ = ▁ list ( miss ) [0 ] else : ▁ ▁ ▁ ▁ # ▁ must ▁ be ▁ 2 ▁ ▁ ▁ ▁ if ▁ { a [ diffs [ 0 ] ] , b [ diffs [ 1 ] ] } ▁ = = ▁ miss : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ a [ diffs [ 1 ] ] ▁ = ▁ b [ diffs [ 1 ] ] ▁ ▁ ▁ ▁ else : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ a [ diffs [ 0 ] ] ▁ = ▁ b [ diffs [ 0 ] ] '''   two = - 1 missing = - 1   counts = [ [ ] for i in range ( n + 1 ) ] for i in range ( n ) : counts [ a [ i ] ] . append ( i ) if len ( counts [ a [ i ] ] ) == 2 : two = a [ i ]   for i in range ( 1 , n + 1 ) : if len ( counts [ i ] ) == 0 : missing = i break   def diff ( a , b ) : diffs = 0 for i in range ( n ) : diffs += a [ i ] != b [ i ] return diffs   for i in range ( 2 ) : perm = a . copy ( ) perm [ counts [ two ] [ i ] ] = missing   if diff ( perm , b ) == 1 : print ( * perm ) break NEW_LINE"],"bleu":0.023262145666952994,"rouge_l":0.2618166210633618}
{"id":175,"predictions":["l , d , v , p = map ( int , input ( ) . split ( ) ) x = ( l * v \/ v + r \/ v ) * ( g + r - v ) ** 0.5 = ( l + r - v ) \/ ( g + r ) \/ vprint ( p ) NEW_LINE"],"references":["import sysimport mathdef fn ( l , d , v , g , r ) : t = float ( d ) \/ float ( v ) if t < g : return float ( l ) \/ float ( v ) elif t <= g + r : t = g + r return t + ( float ( l ) - float ( d ) ) \/ float ( v ) elif t > g + r : t1 = t k = t \/\/ ( g + r ) t = t - k * ( g + r ) if t < g : return float ( l ) \/ float ( v ) elif t <= g + r : t = g + r return ( k + 1 ) * t + ( float ( l ) - float ( d ) ) \/ float ( v ) if __name__ == ' _ _ main _ _ ' : input = sys . stdin . read ( ) data = list ( map ( int , input . split ( ) ) ) l = ( data [ 0 ] ) d = data [ 1 ] v = data [ 2 ] g = data [ 3 ] r = data [ 4 ] print ( fn ( l , d , v , g , r ) ) NEW_LINE"],"bleu":0.025240472377556406,"rouge_l":0.24055999211278717}
{"id":176,"predictions":["import sysfrom math import * from collections import * import * NEW_LINE"],"references":["from itertools import permutationsfrom sys import stdin , stdoutly , lx = map ( int , input ( ) . split ( ) ) grid = [ [ c for c in inp ] for inp in stdin . read ( ) . splitlines ( ) ]   first = set ( ) bl = [ ] bpattern = [ ] bcost = 1e6 flip_row = False   for l in permutations ( ' AGCT ' ) : if bcost == 0 : break if ' ' . join ( l [ : 2 ] ) in first : continue   first |= set ( [ ' ' . join ( l [ : 2 ] ) , ' ' . join ( l [ 1 : : - 1 ] ) ] ) NEW_LINE"],"bleu":0.000005931552260857478,"rouge_l":0.04728682170542635}
{"id":177,"predictions":["import sysfrom functools import lru_cache , cmp_to_keyfrom heapq import merge , heapify , heappop , heappushfrom math import * from collections import defaultdict as dd , deque , Counter as Cfrom itertools import combinations as comb , permutations as permfrom bisect import bisect_left as bl , bisect_right as br , bisect , insortfrom time import perf_counterfrom fractions import Fractionimport copyfrom copy import deepcopyimport timestarttime = time . time ( ) mod = int ( pow ( 10 , 9 ) + 7 ) mod2 = 998244353   def data ( ) : return sys . stdin . readline ( ) . strip ( ) def out ( * var , end = \" \\n \" ) : sys . stdout . write ( ' ▁ ' . join ( map ( str , var ) ) + end ) def L ( ) : return list ( sp ( ) ) def sl ( ) : return list ( ssp ( ) ) def sp ( ) : return map ( int , data ( ) . split ( ) ) def ssp ( ) : return map ( str , data ( ) . split ( ) ) def l1d ( n , val = 0 ) : return [ val for i in range ( n ) ] def l2d ( n , m , val = 0 ) : return [ l1d ( n , val ) for j in range ( m ) ] try : NEW_LINE"],"references":["line1 = input ( ) . split ( \" ▁ \" ) line2 = input ( ) . split ( \" ▁ \" ) A1 = int ( line1 [ 0 ] ) A2 = int ( line2 [ 0 ] ) B1 = int ( line1 [ 1 ] ) B2 = int ( line2 [ 1 ] ) C1 = int ( line1 [ 2 ] ) C2 = int ( line2 [ 2 ] )   Z = lambda x , y , z : not x and not y and z   if A1 * B2 - A2 * B1 : print ( 1 ) elif Z ( A1 , B1 , C1 ) or Z ( A2 , B2 , C2 ) or ( C1 * B2 - C2 * B1 ) or ( A1 * C2 - A2 * C1 ) : print ( 0 ) else : print ( - 1 )   NEW_LINE"],"bleu":0.05619440665066918,"rouge_l":0.22740452323751134}
{"id":178,"predictions":["n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n - 1 ) : if arr [ i ] [ 0 ] == arr [ i - 1 ] [ 1 ] : arr [ i ] [ 1 ] = arr [ i ] [ 0 ] else : arr [ i ] [ 1 ] = arr [ i ] [ 0 ] for i in range ( n ) : if arr [ i ] [ 0 ] == arr [ i ] [ 0 ] : arr [ i ] [ 1 ] = arr [ i ] [ 0 ] + arr [ i ] [ 1 ] else : arr [ i ] [ 1 ] = arr [ i ] [ 0 ] + arr [ i ] [ 1 ] [ 1 ] = arr [ i ] [ 1 ] + arr [ i ] [ 1 ] for i in range ( 1 , n ) : print ( \" \" . join ( arr [ i ] [ 1 ] ) ) NEW_LINE"],"references":["import sysinput = sys . stdin . readline   from bisect import bisect_left as bs   '''   '''   def solve ( n , a ) : b = a [ : : ] b . sort ( ) done = [ 0 ] * n   res = [ ] for i in range ( n ) : if not done [ i ] : if a [ i ] == b [ i ] : res . append ( [ i + 1 ] ) done [ i ] = 1 else : r = [ ] while not done [ i ] : r . append ( i + 1 ) done [ i ] = 1 i = bs ( b , a [ i ] ) res . append ( r ) return res                                   n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) )   res = solve ( n , a ) print ( len ( res ) ) for r in res : print ( len ( r ) , * r ) NEW_LINE"],"bleu":0.2533697843511775,"rouge_l":0.318537859007833}
{"id":179,"predictions":["n , m = map ( int , input ( ) . strip ( ) . split ( \" ▁ \" ) ) t = list ( map ( int , input ( ) . split ( \" ▁ \" ) ) ) for i in range ( n - 1 ) : a = list ( map ( int , input ( ) . split ( ) ) ) if a [ 0 ] == 1 : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"references":["for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) s = input ( ) m = n - 1 for i in range ( n ) : if s [ i ] == ' > ' or s [ n - 1 - i ] == ' < ' : m = min ( m , i ) print ( m ) NEW_LINE"],"bleu":0.16882512906538819,"rouge_l":0.4127363184079602}
{"id":180,"predictions":["import matht = int ( input ( ) ) for i in range ( t ) : n , m = map ( int , input ( ) . split ( ) ) s = input ( ) [ : : n ] s = list ( map ( int , input ( ) . split ( ) ) ) s = [ ] for i in range ( n ) : s . append ( input ( ) ) s . append ( s [ 0 ] ) ) for i in range ( n ) : if s [ i ] [ 0 ] == 1 : print ( \" NO \" ) else : print ( \" YES \" ) NEW_LINE"],"references":["import sys , io , os NEW_LINE if os . environ [ ' USERNAME ' ] == ' kissz ' : inp1 = inp2 = open ( ' in . txt ' , ' r ' ) . readline NEW_LINE def debug ( * args ) : print ( * args , file = sys . stderr ) NEW_LINE else : NEW_LINE"],"bleu":0.03758203866883448,"rouge_l":0.24024756189047264}
{"id":181,"predictions":["n = int ( input ( ) )   import sysdef get_ints ( ) : return list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) )   arr = get_ints ( )   arr = sorted ( arr ) arr = arr [ : : - 1 ] maxs = arr [ 0 ] times = 0 for index , elem in enumerate ( arr ) : if index == n - 1 : break times += maxs - elem     lastelem = arr [ - 1 ] NEW_LINE"],"references":["import sys , os , ioimport math , bisect , operatorinf , mod = float ( ' inf ' ) , 10 ** 9 + 7 NEW_LINE"],"bleu":0.01776579178857841,"rouge_l":0.11954087346024632}
{"id":182,"predictions":["import sysfrom functools import lru_cache , cmp_to_keyfrom heapq import merge , heapify , heappop , heappushfrom math import * from collections import defaultdict as dd , deque , Counter as Cfrom itertools import combinations as comb , permutations as permfrom bisect import bisect_left as bl , bisect_right as br , bisect , insortfrom time import perf_counterfrom fractions import Fractionimport copyfrom copy import deepcopyimport timestarttime = time . time ( ) mod = int ( pow ( 10 , 9 ) + 7 ) mod2 = 998244353   def data ( ) : return sys . stdin . readline ( ) . strip ( ) def out ( * var , end = \" \\n \" ) : sys . stdout . write ( ' ▁ ' . join ( map ( str , var ) ) + end ) def L ( ) : return list ( sp ( ) ) def sl ( ) : return list ( ssp ( ) ) def sp ( ) : return map ( int , data ( ) . split ( ) ) def ssp ( ) : return map ( str , data ( ) . split ( ) ) def l1d ( n , val = 0 ) : return [ val for i in range ( n ) ] def l2d ( n , m , n , val = 0 ) : return [ l1d ( n , val ) for j in range ( m ) ] try : NEW_LINE"],"references":["n , k = map ( int , input ( ) . split ( ) ) ; s = [ i for i in str ( n ) ] ; i = 0 n = len ( s ) for i in range ( n ) : x = i for j in range ( i + 1 , min ( n , i + k + 1 ) ) : if s [ x ] < s [ j ] : x = j NEW_LINE"],"bleu":0.09956291118823707,"rouge_l":0.2395711707886636}
{"id":183,"predictions":["t = int ( input ( ) ) for i in range ( t ) : n = int ( input ( ) ) if ( n % 4 != 0 ) : print ( ' NO ' ) elif ( n % 2 == 0 ) : print ( ' YES ' ) else : print ( ' NO ' ) NEW_LINE"],"references":["for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) if ( n * ( n - 1 ) \/ 2 ) % 2 == 0 : a = list ( range ( 2 , n + 1 , 2 ) ) b = list ( range ( 1 , n - 1 , 2 ) ) print ( \" YES \" ) print ( * list ( a + b + [ sum ( a ) - sum ( b ) ] ) ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.22440290086591844,"rouge_l":0.4442577030812325}
{"id":184,"predictions":["import mathn = input ( ) s = input ( ) count = 0 for i in s : count += 1 if i in s : print ( count ) NEW_LINE"],"references":["word = input ( ) ans = 0 num = { }   for i in word : num [ i ] = num . get ( i , 0 ) + 1   for j in num . values ( ) : ans += j ** 2   print ( ans ) NEW_LINE"],"bleu":0.11489612726595262,"rouge_l":0.3779154518950437}
{"id":185,"predictions":["def fun ( lt ) : for i in range ( len ( lt ) ) : if ( lt [ i ] == lt [ i ] ) : return lt = list ( lt [ i ] ) for i in range ( len ( lt ) ) : if ( lt [ i ] ) > lt [ i ] : lt . append ( lt [ i ] ) return - len ( l ) for j in range ( len ( lt ) ) : print ( l [ j ] ) NEW_LINE"],"references":["from sys import stdin , stdoutfrom os import pathif path . exists ( \" input . txt \" ) : stdin = open ( \" input . txt \" , ' r ' ) wr = stdout . writerd = lambda : stdin . readline ( ) . strip ( ) NEW_LINE"],"bleu":0.026111767084014317,"rouge_l":0.1834798704303563}
{"id":186,"predictions":["n = int ( input ( ) ) a = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) + [ 0 ] * ( n + 1 ) for i in range ( 1 , n + 1 ) : if a [ i ] == 0 : return a [ i ] = min ( a [ i - 1 ] , a [ i - 1 ] ) print ( max ( a ) ) NEW_LINE"],"references":["for _ in range ( int ( input ( ) ) ) : n , k = map ( int , input ( ) . split ( ) ) NEW_LINE l = list ( ) NEW_LINE for i in range ( n ) : x = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l . append ( x ) NEW_LINE for i in l : c = 1 NEW_LINE for j in l : if NEW_LINE abs ( i [ 0 ] - j [ 0 ] ) + abs ( i [ 1 ] - j [ 1 ] ) > k : c = 0 NEW_LINE break NEW_LINE if c == 1 : print ( 1 ) NEW_LINE break NEW_LINE if c == 0 : print ( - 1 )   NEW_LINE"],"bleu":0.21662361823787396,"rouge_l":0.39712464397124647}
{"id":187,"predictions":["n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) )   print ( 2 * n \/\/ 2 ) NEW_LINE"],"references":["n = int ( input ( ) ) if n % 2 == 0 : print ( n \/\/ 2 ) print ( '2 ▁ ' * ( n \/\/ 2 ) ) else : n = n - 3 print ( n \/\/ 2 + 1 ) print ( '2 ▁ ' * ( n \/\/ 2 ) + '3' ) NEW_LINE"],"bleu":0.16516115053989633,"rouge_l":0.42698059179128217}
{"id":188,"predictions":["n = int ( input ( ) ) arr = sorted ( map ( int , input ( ) . split ( ) ) )   print ( arr [ n \/\/ 2 ] ) NEW_LINE"],"references":["import mathinfo = [ int ( x ) for x in input ( ) . split ( ) ] lanes = info [ 0 ] desks = info [ 1 ] location = info [ 2 ] seats_in_lane = 2 * deskslane = math . ceil ( location \/ seats_in_lane ) starting_group = ( ( lane - 1 ) * seats_in_lane ) + 1 NEW_LINE"],"bleu":0.10925206048409031,"rouge_l":0.3012345679012346}
{"id":189,"predictions":["n = int ( input ( ) ) for i in range ( n ) : a = sorted ( [ int ( i ) for i in input ( ) . split ( ) ] ) if a [ n - 4 ] == 0 : print ( \" NO \" ) else : print ( \" YES \" ) NEW_LINE"],"references":["for _ in range ( int ( input ( ) ) ) : input ( ) NEW_LINE n = [ i for i in input ( ) ] NEW_LINE n . sort ( ) NEW_LINE print ( \" \" . join ( n ) ) NEW_LINE"],"bleu":0.2718496880341992,"rouge_l":0.5137242669993761}
{"id":190,"predictions":["n , m = map ( int , input ( ) . split ( ) ) S = [ input ( ) for i in range ( n ) ]   res = [ [ 0 ] * m for i in range ( n ) ] d = [ [ 0 ] * ( n + 1 ) for i in range ( m ) ] for j in range ( n - 1 ) : for k in range ( m ) : if S [ k ] [ 0 ] == ' * ' : for i in range ( n - 1 ) : for j in range ( m - 1 , - 1 ) : if S [ i ] [ j ] == ' * ' : for di , j in d : ni , nj = i + di , j + dj if 0 <= nj < n and 0 <= nj < m : if S [ ni ] [ nj ] = '0' else : res [ nj ] += 1 NEW_LINE"],"references":["def gcd ( a , b ) : while a % b : a , b = b , a % b return ba , b = map ( int , input ( ) . split ( ) ) g = gcd ( a , b ) a \/\/= gb \/\/= gcnt = 0 for i in [ 2 , 3 , 5 ] : while a % i == 0 : a \/\/= i cnt += 1 while b % i == 0 : b \/\/= i cnt += 1 if a == 1 and b == 1 : print ( cnt ) else : print ( - 1 ) NEW_LINE"],"bleu":0.11454625177198156,"rouge_l":0.2826691380908248}
{"id":191,"predictions":["n , t = map ( int , input ( ) . strip ( input ( ) . split ( \" ▁ \" ) ) NEW_LINE"],"references":["n , t = list ( map ( int , input ( ) . split ( ) ) ) a = list ( map ( int , input ( ) . split ( ) ) ) i = 1 while i < t : i += a [ i - 1 ] print ( ' YES ' if i == t else ' NO ' ) NEW_LINE"],"bleu":0.12352783846256869,"rouge_l":0.43827563683866755}
{"id":192,"predictions":["n , l = map ( int , input ( ) . split ( ) ) d = l [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) a = sorted ( l [ 1 ] ) for i in range ( n - 1 ) : k = ( a [ i + 1 ] - a [ i ] ) \/ 2 print ( k - 1 ) NEW_LINE"],"references":["n , l = map ( int , input ( ) . split ( ) ) lights = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True )   max_dif = 0   for i in range ( len ( lights ) - 1 ) : max_dif = max ( max_dif , lights [ i ] - lights [ i + 1 ] )   print ( format ( max ( max_dif \/ 2 , lights [ - 1 ] , l - lights [ 0 ] ) , ' . 10f ' ) ) NEW_LINE"],"bleu":0.4348559170844612,"rouge_l":0.6086588871977}
{"id":193,"predictions":["from sys import stdin   NEW_LINE"],"references":["n = [ int ( i ) for i in input ( ) ] for x in [ 1 , 6 , 8 , 9 ] : for i in range ( len ( n ) ) : if n [ i ] == x : del n [ i ] break   prefix = [ 1869 , 6189 , 1689 , 6198 , 1698 , 9861 , 1896 ] res = sum ( [ n [ i ] * pow ( 10 , len ( n ) - i - 1 , 7 ) for i in range ( len ( n ) ) ] ) print ( prefix [ - res * pow ( 10 , 5 * len ( n ) , 7 ) % 7 ] , end = ' ' ) print ( * n , sep = ' ' ) NEW_LINE"],"bleu":1.5455301585785122e-13,"rouge_l":0.02241822859242925}
{"id":194,"predictions":["n , m = map ( int , input ( ) . split ( ) ) for _ in range ( n ) : a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) : for j in range ( m ) : if a [ i ] [ j ] == 1 : b [ i ] = 1 if a [ i ] [ j ] == 1 : b [ i ] = 1 if b [ i ] == 2 : print ( \" Takk \" ) else : print ( \" Takahk \" ) NEW_LINE"],"references":["t = int ( input ( ) ) s = [ ] for i in range ( t ) : k = 0 x = list ( map ( int , input ( ) . split ( ) ) ) n = x [ 0 ] m = x [ 1 ] indices1 = [ ] mylist = [ ] for j in range ( n ) : y = list ( map ( str , input ( ) . split ( ) ) ) indices = [ o for o , z in enumerate ( y ) if z == \"1\" ] NEW_LINE"],"bleu":0.34154353854615777,"rouge_l":0.44322553070237924}
{"id":195,"predictions":["n = int ( input ( ) ) s = input ( ) ans = 0 for i in range ( len ( s ) - 1 ) : if s [ i ] == '1' : ans += i + 1 print ( ans ) NEW_LINE"],"references":["n = int ( input ( ) ) s = str ( input ( ) ) ans = 0 for i in range ( n ) : if int ( s [ i ] ) % 2 == 0 : ans += ( i + 1 ) print ( ans ) NEW_LINE"],"bleu":0.5469560829384913,"rouge_l":0.8007876599934363}
{"id":196,"predictions":["from sys import stdin , stdoutfrom os import pathrd = lambda : stdin . readline ( ) . strip ( ) wr = stdout . writeif ( path . exists ( ' input . txt ' ) ) : stdin = open ( \" input . txt \" , \" r \" ) import time , math NEW_LINE"],"references":["from math import log2   def main ( ) : t = int ( input ( ) ) allAns = [ ] MOD = 10 ** 9 + 7 for _ in range ( t ) : n , p = readIntArr ( ) a = readIntArr ( ) if p == 1 : NEW_LINE"],"bleu":0.05633294412316094,"rouge_l":0.24897959183673468}
{"id":197,"predictions":["import sys NEW_LINE from fractions import gcd NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT return gcd ( b , a % b ) NEW_LINE DEDENT def hcf ( a , b ) : NEW_LINE INDENT if gcd ( a , b ) == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( ' ▁ ' , end = ' ' ) NEW_LINE print ( ) NEW_LINE DEDENT"],"references":["def isquare ( n ) : h = n l = 1 while h - l > 1 : m = ( h + l ) \/\/ 2 if m * m <= n : l = m elif m * m > n : h = m return la , b = map ( int , input ( ) . split ( ) ) lsta = [ ] lstb = [ ] for i in range ( 3 , a ) : if isquare ( a * a - i * i ) ** 2 == a * a - i * i : lsta . append ( [ i , isquare ( a * a - i * i ) ] ) for i in range ( 3 , b ) : if isquare ( b * b - i * i ) ** 2 == b * b - i * i : lstb . append ( [ i , isquare ( b * b - i * i ) ] ) flag = Falsefor p , q in lsta : for r , s in lstb : if p * r == q * s : if q == s : p , q , r , s = p , q , r , - s else : p , q , r , s = p , q , - r , s flag = True break if flag : breakif flag : print ( \" YES \\n \" , 0 , 0 , ' \\n ' , p , q , ' \\n ' , r , s ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.028038626495365863,"rouge_l":0.19999999999999998}
{"id":198,"predictions":["n , k = map ( int , input ( ) . split ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) )   arr = [ 0 ] * ( n + 1 )   for i in arr [ 1 : ] : if i <= k : arr [ i + 1 ] += k - i else : arr [ i ] += k \/\/= 2   print ( arr ) NEW_LINE"],"references":["m , k = [ int ( i ) for i in input ( ) . split ( ) ]   days = [ int ( i ) for i in input ( ) . split ( ) ]     s1 = 0 for q in range ( 1 , m ) : if days [ q ] + days [ q - 1 ] < k : s1 += k - ( days [ q ] + days [ q - 1 ] ) days [ q ] += k - ( days [ q ] + days [ q - 1 ] )   print ( s1 ) print ( * days ) NEW_LINE"],"bleu":0.20252149275078435,"rouge_l":0.42977923907938}
{"id":199,"predictions":["n = int ( input ( ) ) s = str ( input ( ) ) s = str ( '0' ) for i in range ( 1 , 10 ) : s [ i ] = s [ i : : - 1 ] s = set ( s ) if len ( s ) == 1 : print ( s ) exit ( 0 ) for i in range ( 1 , len ( s ) ) : d = s [ i : len ( s ) for j in d ] k = d [ s [ i : j ] if d == 1 : k = d [ i ] print ( \" \" . join ( map ( str , d ) ) ) ) NEW_LINE"],"references":["n = int ( input ( ) ) A = [ int ( d ) for d in input ( ) ] f = [ int ( x ) for x in input ( ) . split ( ) ] flag = Falsefor i in range ( n ) : d = A [ i ] x = f [ A [ i ] - 1 ] if x > d : flag = True A [ i ] = x elif x == d : continue else : if flag : breakA = list ( map ( str , A ) ) print ( ' ' . join ( A ) ) NEW_LINE"],"bleu":0.2184846721480031,"rouge_l":0.4680306905370844}
{"id":200,"predictions":["s = input ( ) NEW_LINE dp = [ ] NEW_LINE for i in range ( len ( s ) - 1 ) : NEW_LINE INDENT if s [ i ] == '1' : NEW_LINE INDENT dp . append ( s [ i : i + 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp . append ( s [ 0 ] + s [ i + 1 : ] ) NEW_LINE DEDENT DEDENT ans = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if dp [ i ] == '1' : NEW_LINE INDENT ans . append ( dp [ i ] ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["import sysfrom math import gcd , sqrt , ceil , log2from collections import defaultdict , Counter , dequefrom bisect import bisect_left , bisect_rightimport mathimport heapqfrom itertools import permutations   NEW_LINE"],"bleu":0.010922246194083766,"rouge_l":0.02971985383678441}
{"id":201,"predictions":["for s in [ 0 ] * ( input ( ) . split ( ) ) : NEW_LINE INDENT a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE count = 0 , 0 NEW_LINE if a == 0 : NEW_LINE INDENT while b < 0 and c <= 1 : NEW_LINE INDENT count += 3 NEW_LINE 3 = c - 3 NEW_LINE DEDENT if a == 0 : NEW_LINE INDENT count += 3 NEW_LINE DEDENT else : NEW_LINE INDENT while a < b and b > 1 : NEW_LINE INDENT count += 3 NEW_LINE a = b - 2 NEW_LINE b = c - 2 NEW_LINE c = b - 2 NEW_LINE DEDENT c += 3 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE"],"references":["t = int ( input ( ) ) for i in range ( t ) : a , b , c = map ( int , input ( ) . split ( ) ) count = 0 if b > 0 and c > 1 : while b > 0 and c > 1 : b = b - 1 c = c - 2 count += 1 if a > 0 and b > 1 : while a > 0 and b > 1 : a = a - 1 b = b - 2 count += 1 print ( count * 3 )       NEW_LINE"],"bleu":0.28399156287471394,"rouge_l":0.5496996176952486}
{"id":202,"predictions":["import sysfrom functools import lru_cache , cmp_to_keyfrom heapq import merge , heapify , heappop , heappushfrom math import * from collections import defaultdict as dd , deque , Counter as Cfrom itertools import combinations as comb , permutations as permfrom bisect import bisect_left as bl , bisect_right as br , bisect , insortfrom time import perf_counterfrom fractions import Fractionimport copyfrom copy import deepcopyimport timestarttime = time . time ( ) mod = int ( pow ( 10 , 9 ) + 7 ) mod2 = 998244353   def data ( ) : return sys . stdin . readline ( ) . strip ( ) def out ( * var , end = \" \\n \" ) : sys . stdout . write ( ' ▁ ' . join ( map ( str , var ) ) + end ) def L ( ) : return list ( sp ( ) ) def sl ( ) : return list ( ssp ( ) ) def sp ( ) : return map ( int , data ( ) . split ( ) ) def ssp ( ) : return map ( str , data ( ) . split ( ) ) def l1d ( n , val = 0 ) : return [ val for i in range ( n - 1 ) ] def l2d ( n , m , val = 0 ) : return [ l1d ( n , val ) for j in range ( n - 1 ) ] NEW_LINE"],"references":["f = lambda : map ( int , input ( ) . split ( ) ) n , m = f ( ) t = list ( f ( ) ) p = [ 1e9 ] + [ abs ( b - a ) for a , b in zip ( t , t [ 1 : ] ) ] + [ 1e9 ] L , R = [ 0 ] * n , [ 0 ] * nfor i in range ( 1 , n ) : j = n - i x , y = i - 1 , j + 1 a , b = p [ i ] , p [ j ] while a > p [ x ] : x = L [ x ] while b >= p [ y ] : y = R [ y ] L [ i ] , R [ j ] = x , yfor k in range ( m ) : l , r = f ( ) print ( sum ( ( i - max ( l - 1 , L [ i ] ) ) * ( min ( r , R [ i ] ) - i ) * p [ i ] for i in range ( l , r ) ) ) NEW_LINE"],"bleu":0.09877352133462773,"rouge_l":0.22155479499895228}
{"id":203,"predictions":["for t in range ( 1 ) : n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l . sort ( ) count = 0 for i in l : if i % 2 == 0 : count += 1 else : l [ i ] = count + 1 print ( count ) NEW_LINE"],"references":["cases = int ( input ( ) ) while cases : cases -= 1 x = int ( input ( ) ) arrx = list ( map ( int , input ( ) . split ( ) ) ) y = int ( input ( ) ) arry = list ( map ( int , input ( ) . split ( ) ) )   ans = sum ( 1 for i in arrx if i % 2 == 0 ) * sum ( 1 for i in arry if i % 2 == 0 ) + sum ( 1 for i in arrx if i % 2 != 0 ) * sum ( 1 for i in arry if i % 2 != 0 ) print ( ans ) NEW_LINE"],"bleu":0.19129789298931488,"rouge_l":0.44168849175781855}
{"id":204,"predictions":["for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) )   print ( \" yes \" if arr [ n \/\/ 2 ] else \" no \" ) NEW_LINE"],"references":["MAX_LEN = int ( 1e5 ) n = int ( input ( ) ) a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] m = int ( input ( ) ) b = list ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) curr , k , c , res = 0 , 0 , [ ] , [ ] for i in range ( n ) : t = a [ i ] last = curr if t [ 0 ] == 1 : curr += 1 if len ( c ) < MAX_LEN : c . append ( t [ 1 ] ) if k < m and b [ k ] == curr - 1 : res . append ( t [ 1 ] ) k += 1 else : curr += t [ 1 ] * t [ 2 ] while t [ 2 ] > 0 and len ( c ) < MAX_LEN : c . extend ( c [ : t [ 1 ] ] ) t [ 2 ] -= 1 while k < m and last <= b [ k ] < curr : res . append ( c [ ( b [ k ] - last ) % t [ 1 ] ] ) k += 1 print ( ' ▁ ' . join ( map ( str , res [ : m ] ) ) ) NEW_LINE"],"bleu":0.013235793318260731,"rouge_l":0.21554770318021202}
{"id":205,"predictions":["n = int ( input ( ) ) ar = [ ] for i in range ( n ) : l = list ( map ( int , input ( ) . split ( ) ) ) ar = [ ] ar = [ ] for i in range ( n ) : l . append ( l [ i ] ) ar . append ( l [ i ] + 1 ) for i in range ( n ) : if ar [ i ] [ 0 ] == ar [ i ] [ 1 ] : ar = ar [ i ] ar = ar [ i ] for i in range ( n ) : if ar [ i ] [ 1 ] > ar [ i ] [ 1 ] : ar . append ( ar [ i ] [ 0 ] ) ar [ i ] ] [ 1 ] = ar [ 0 ] ar = [ 0 ] for i in range ( n ) : if ar [ i ] [ 1 ] == ar [ i ] [ 1 ] : ar = ar [ i ] ar = ar [ i ] [ 1 ] x = ar [ i ] ; ar = ar [ i - 1 ] ; ar = ar [ ] ; print ( \" \\n \" . join ( ar ) )     if __name__ == \" _ _ main _ _ \" : main ( ) NEW_LINE"],"references":["def get_key ( my_dict , val ) : for key , value in my_dict . items ( ) : if val == value : return key return - 1   n = int ( input ( ) ) arr = { } for _ in range ( n ) : a , b = input ( ) . split ( ) x = get_key ( arr , a ) if x == - 1 : arr [ a ] = b   else : arr [ x ] = b   print ( len ( arr ) ) for i , j in arr . items ( ) : print ( i , j ) NEW_LINE"],"bleu":0.10814549888480861,"rouge_l":0.28907212586484693}
{"id":206,"predictions":["a , b = map ( int , input ( ) . split ( ) ) for i in range ( a , b ) : if b > 0 : print ( \" Val \" ) exit ( ) elif a > 0 and b > 0 : print ( \" Val \" ) else : print ( \" Valer \" ) NEW_LINE"],"references":["a , b = map ( int , input ( ) . split ( ) ) print ( ' VVlaaldeirka ' [ ( ( 4 * b + 1 ) ** .5 - 1 ) \/\/ 2 < a ** .5 \/\/ 1 : : 2 ] ) NEW_LINE"],"bleu":0.286593315724809,"rouge_l":0.45332936979785976}
{"id":207,"predictions":["from sys import stdin , stdoutinput = stdin . readline def main ( ) : n , k = map ( int , input ( ) . split ( ) ) ar = [ 1 ] * 5001 ai = list ( map ( int , input ( ) . split ( ) ) ) ans = [ 0 ] * 5000 ar2 = [ ] for i in range ( n ) : ans [ i ] = ar [ ai [ i ] ] ar [ i ] ] += 1 if ans [ i ] > k : print ( \" NO \" ) main ( ) NEW_LINE"],"references":["def main ( ) : n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) a . sort ( ) c = [ ] for i in range ( n - 1 ) : c += [ a [ i + 1 ] - a [ i ] ] print ( min ( c ) , c . count ( min ( c ) ) )   if __name__ == ' _ _ main _ _ ' : main ( ) NEW_LINE"],"bleu":0.35130598476267844,"rouge_l":0.5256103398755385}
{"id":208,"predictions":["n = int ( input ( ) ) arr = sorted ( map ( int , input ( ) . split ( ) ) )   print ( arr [ n \/\/ 2 ] ) NEW_LINE"],"references":["n , L = map ( int , input ( ) . split ( ) ) kefa = list ( map ( int , input ( ) . split ( ) ) ) sasha = list ( map ( int , input ( ) . split ( ) ) ) def check ( kefa , sasha ) : X = [ ( kefa [ i ] - sasha [ i ] + L ) % L for i in range ( n ) ] if len ( set ( X ) ) == 1 : return True else : return Falsedef rotate ( arr , n ) : x = arr [ n - 1 ] for i in range ( n - 1 , 0 , - 1 ) : arr [ i ] = arr [ i - 1 ] arr [ 0 ] = x return arrok = Falsefor l in range ( n + 1 ) : sasha = rotate ( sasha , n ) if check ( kefa , sasha ) == True : ok = Trueif ok == True : print ( \" Yes \" ) else : print ( \" No \" ) NEW_LINE"],"bleu":0.004882833620721034,"rouge_l":0.2249262536873156}
{"id":209,"predictions":["from math import sqrt , ceil   NEW_LINE"],"references":["n = 1000000 a = [ 1 ] * ns = set ( ) for i in range ( 2 , n ) : if a [ i ] : s . add ( i * i ) for j in range ( i * i , n , i ) : a [ j ] = 0 input ( ) for x in map ( int , input ( ) . split ( ) ) : print ( [ \" NO \" , \" YES \" ] [ x in s ] ) NEW_LINE"],"bleu":7.132650351060847e-7,"rouge_l":0.03370165745856354}
{"id":210,"predictions":["n = int ( input ( ) ) a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ]   ans = [ 0 ] * n   for i in range ( 1 , n ) : if a [ i ] [ 0 ] > a [ i ] [ 1 ] : ans += 1 elif a [ i ] [ 1 ] > 0 : ans . append ( [ i ] [ 0 ] - 1 ) print ( len ( ans ) ) print ( * ans ) NEW_LINE"],"references":["n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) neg , neg1 = 0 , [ ] pos , pos1 = 0 , [ ] for i in range ( n ) : if l [ i ] >= 0 : l [ i ] = - l [ i ] - 1 if n % 2 == 0 : print ( * l ) else : l1 = sorted ( l ) l [ l . index ( l1 [ 0 ] ) ] = - l1 [ 0 ] - 1 print ( * l ) NEW_LINE"],"bleu":0.3721220500959468,"rouge_l":0.5666182873730045}
{"id":211,"predictions":["import sysfrom collections import Counter   n , b = map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ' ▁ ' ) ) c = [ int ( x ) for x in sys . stdin . readline ( ) . strip ( ) . split ( ' ▁ ' ) ] c = [ int ( x ) for x in sys . stdin . readline ( ) . strip ( ) . split ( ' ▁ ' ) ] maxm = [ int ( x ) for x in sys . stdin . readline ( ) . strip ( ) . split ( ' ▁ ' ) ]   print ( max ( max ( c , - b ) ) ) NEW_LINE"],"references":["    n , b = map ( int , input ( ) . split ( ) )   t = list ( map ( int , input ( ) . split ( ) ) )   ans = 0   ma = 999999999 mi = 0 for i in range ( n ) :   if t [ i ] < ma : ma = t [ i ] elif t [ i ] > ma : temp = b \/\/ ma   rest = b - ( b \/\/ ma ) * ma rest += ( temp ) * t [ i ]   ans = max ( rest , ans )   print ( max ( ans , b ) )                             NEW_LINE"],"bleu":0.17732727323902145,"rouge_l":0.3392350471002156}
{"id":212,"predictions":["s = input ( ) ans = [ ] for i in range ( len ( s ) - 1 ) : if s [ i ] == ' r ' : ans . append ( i + 1 ) print ( len ( ans ) ) for i in range ( len ( s ) - 1 , - 1 , - 1 ) : print ( i + 1 ) NEW_LINE"],"references":["import osimport sysfrom io import BytesIO , IOBase   sys . setrecursionlimit ( 95000 )     def main ( ) : pass     NEW_LINE"],"bleu":0.03144521618151044,"rouge_l":0.15465411082940964}
{"id":213,"predictions":["import sys , os , ioimport math , bisect , operatorinf , mod = float ( ' inf ' ) , 10 ** 9 + 7 NEW_LINE"],"references":["x , t , a , b , da , db = [ int ( i ) for i in input ( ) . split ( ) ]   if x == 0 : print ( \" YES \" ) exit ( 0 )   for i in range ( t ) : for j in range ( t ) : if ( a - i * da + b - j * db == x ) or ( a - i * da == x ) or ( b - j * db == x ) : print ( \" YES \" ) exit ( 0 )   print ( \" NO \" ) NEW_LINE"],"bleu":0.0028456470540273193,"rouge_l":0.12574726860441146}
{"id":214,"predictions":["st = list ( map ( int , input ( ) . split ( ) ) ) l = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) if len ( l ) == 2 : print ( \" NO \" ) else : print ( \" YES \" ) NEW_LINE"],"references":["from itertools import combinations   def solve ( ) : n = int ( input ( ) ) ls = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) for x , y , z in zip ( ls , ls [ 1 : ] , ls [ 2 : ] ) : if x > z - y and x <= y + z : print ( ' YES ' ) return print ( ' NO ' )   if __name__ == ' _ _ main _ _ ' : solve ( ) NEW_LINE"],"bleu":0.22163097288406977,"rouge_l":0.41876430205949655}
{"id":215,"predictions":["n = int ( input ( ) ) s = input ( ) ans = 0 for i in range ( len ( s ) ) : if s [ i ] == s [ i + 1 ] : ans += 1 else : ans += 1 print ( ans ) NEW_LINE"],"references":["def solution ( s ) : s = sorted ( s , reverse = True ) n = len ( s ) ans = s [ 0 ] for i in range ( 1 , n ) : if ( s [ i - 1 ] == s [ i ] ) : ans += ( s [ i ] ) else : return ans return ans   s = input ( ) print ( solution ( s ) ) NEW_LINE"],"bleu":0.26175948271551974,"rouge_l":0.5178024050931385}
{"id":216,"predictions":["n = int ( input ( ) ) if ( n % 2 == 1 ) : print ( int ( n ) ) else : print ( 9 , \" ▁ \" , int ( n ) ) NEW_LINE"],"references":["n = int ( input ( ) ) if n % 2 == 0 : print ( 4 , n - 4 ) else : print ( 9 , n - 9 ) NEW_LINE"],"bleu":0.46833500254573895,"rouge_l":0.7405575539568345}
{"id":217,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["raw = input ( ) R , C = ( int ( token ) for token in raw . split ( ' ▁ ' ) ) mat = list ( ) for i in range ( R ) : row = input ( ) mat . append ( row )   count = 0 for i in range ( 1 , R ) : for j in range ( 1 , C ) : sq = [ mat [ i - 1 ] [ j - 1 ] , mat [ i - 1 ] [ j ] , mat [ i ] [ j - 1 ] , mat [ i ] [ j ] ] sq . sort ( ) if ' ' . join ( sq ) == ' acef ' : count += 1 print ( count )   NEW_LINE"],"bleu":0.022608261319199845,"rouge_l":0.24941028463594905}
{"id":218,"predictions":["for _ in range ( int ( input ( ) ) ) : n , k = map ( int , input ( ) . split ( ) ) NEW_LINE li = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE li = [ x for x in l ] NEW_LINE r = k + 1 NEW_LINE while i < n : if NEW_LINE l [ i ] < n and li [ i ] > li [ i - 1 ] : l [ i ] = True NEW_LINE i += 1 NEW_LINE elif l == 1 : NEW_LINE r = 1 NEW_LINE c += 1 NEW_LINE DEDENT print ( lb ) NEW_LINE"],"references":["import sys   def answer ( n , k , a ) : peaks = [ False ] * n NEW_LINE"],"bleu":0.028023184489504263,"rouge_l":0.1774662787622322}
{"id":219,"predictions":["n = int ( input ( ) ) s = input ( ) s = input ( ) ans = 0 for i in range ( len ( s ) ) : if ( s [ i ] == s [ i + 1 ] ) : ans += 1 print ( ans ) NEW_LINE"],"references":["n = int ( input ( ) ) s = input ( ) k = [ s [ i : i + 2 ] for i in range ( n - 1 ) ] print ( max ( k , key = k . count ) ) NEW_LINE"],"bleu":0.3789558410068729,"rouge_l":0.4914598775378667}
{"id":220,"predictions":["for _ in range ( int ( input ( ) ) ) : s = input ( ) NEW_LINE f = True NEW_LINE ans = [ ] * ( n + 1 ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT f . append ( s [ i ] ) NEW_LINE DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT x = s [ i ] NEW_LINE ans . append ( x ) NEW_LINE DEDENT print ( ans ) NEW_LINE"],"references":["def main ( ) : t = int ( input ( ) ) allans = [ ] for _ in range ( t ) : x = int ( input ( ) ) arr = [ int ( z ) for z in input ( ) ] n = len ( arr ) j = 1 for i in range ( x ) : if j == n : break for yy in range ( arr [ i ] - 1 ) : if len ( arr ) > x : break for zz in range ( i + 1 , n ) : if len ( arr ) > x : break arr . append ( arr [ zz ] ) n += ( ( n - j + MOD ) % MOD ) * ( arr [ i ] - 1 ) j += 1 n %= MOD NEW_LINE"],"bleu":0.14191495399669593,"rouge_l":0.35598495655556994}
{"id":221,"predictions":["def smallest ( x ) : if ( x == 0 ) : return 1 else : return smallest ( x \/\/ 2 , x % 2 ) def main ( ) : t = __ ( ) x = int ( x \/ 2 ) if ( x % 2 == 0 ) : return ( t + ' ▁ ' ) + x = x if ( t [ 0 ] == 0 ) : return ( t [ int ( x ) for x in input ( ) . split ( ) ] )   print ( solve ( ) ) NEW_LINE"],"references":["a = input ( ) b = input ( )   def dfs ( sa , sb ) : if sa == sb : return True if len ( sa ) & 1 : return False n = len ( sa ) \/\/ 2 sa1 = sa [ : n ] sa2 = sa [ n : ] sb1 = sb [ : n ] sb2 = sb [ n : ] if dfs ( sa1 , sb2 ) and dfs ( sa2 , sb1 ) : return True if dfs ( sa1 , sb1 ) and dfs ( sa2 , sb2 ) : return True return False   if dfs ( a , b ) : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.0631193721883742,"rouge_l":0.30595092856174594}
{"id":222,"predictions":["arr = list ( map ( int , input ( ) . split ( ) ) ) n = arr [ 0 ] m = arr [ 1 ] k = ( 10 ** 9 ) + 7 print ( pow ( 2 ** m - 1 , n , k ) ) NEW_LINE"],"references":["n , m , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) a1 = [ ] for i in range ( n ) : a1 . append ( ( a [ i ] , i ) ) a1 . sort ( reverse = True ) _max = [ 0 ] * nans = 0 for i in range ( m * k ) : _max [ a1 [ i ] [ 1 ] ] = 1 ans += a1 [ i ] [ 0 ] print ( ans ) _sum = 0 ans_ar = [ ] for i in range ( n ) : _sum += _max [ i ] if _sum == m : ans_ar . append ( i + 1 ) _sum = 0 ans_ar . pop ( ) print ( * ans_ar )           NEW_LINE"],"bleu":0.06054599919623188,"rouge_l":0.2844993141289437}
{"id":223,"predictions":["def fun ( n , k ) : n = int ( n ) k = int ( k ) a = list ( map ( int , input ( ) . split ( ) ) ) if k > n : a . sort ( ) print ( a [ - 1 ] ) exit ( 0 ) p = a [ 0 ] s = 0 for i in range ( 1 , n ) : if p > a [ i ] : s += 1 else : p = a [ i ] s = 1 if s < k : continue break print ( p ) a , b = input ( ) . split ( ) fun ( int ( a ) , int ( b ) ) NEW_LINE"],"references":["import reimport sysexit = sys . exitfrom bisect import bisect_left as bsl , bisect_right as bsrfrom collections import Counter , defaultdict as ddict , dequefrom functools import lru_cachecache = lru_cache ( None ) from heapq import * from itertools import * from math import inffrom pprint import pprint as ppenum = enumerateri = lambda : int ( rln ( ) ) ris = lambda : list ( map ( int , rfs ( ) ) ) rln = sys . stdin . readlinerl = lambda : rln ( ) . rstrip ( ' \\n ' ) rfs = lambda : rln ( ) . split ( ) mod = 1000000007 d4 = [ ( 0 , - 1 ) , ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 0 ) ] d8 = [ ( - 1 , - 1 ) , ( 0 , - 1 ) , ( 1 , - 1 ) , ( - 1 , 0 ) , ( 1 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) ] NEW_LINE"],"bleu":0.0980421916367024,"rouge_l":0.3263590331518105}
{"id":224,"predictions":["for _ in range ( int ( input ( ) ) ) : s = input ( ) a = input ( ) b = input ( ) c = input ( ) L = len ( s ) R = 0 for i in range ( len ( s ) ) : if ( a [ i ] == ' R ' ) : c += 1 elif ( a [ i ] == ' P ' ) : z += 1 else : c += 1 print ( c ) NEW_LINE"],"references":["from sys import stdin , stdoutstdin . readlinedef mp ( ) : return list ( map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) ) def it ( ) : return int ( stdin . readline ( ) . strip ( ) ) from collections import defaultdict as dd , Counter as C , dequefrom math import ceil , gcd     NEW_LINE"],"bleu":0.07184534711587004,"rouge_l":0.26052471018913975}
{"id":225,"predictions":["n = int ( input ( ) ) arr = sorted ( map ( int , input ( ) . split ( ) ) )   print ( arr [ n \/\/ 2 ] ) NEW_LINE"],"references":["import sysimport mathfrom collections import OrderedDictdef input ( ) : return sys . stdin . readline ( ) . strip ( ) def iinput ( ) : return int ( input ( ) ) def minput ( ) : return map ( int , input ( ) . split ( ) ) def listinput ( ) : return list ( map ( int , input ( ) . split ( ) ) ) n , p = minput ( ) s = input ( ) s1 = s [ : ( n - p ) ] s2 = s [ p : ] if ( s1 == s2 and s1 . count ( ' . ' ) == 0 and s2 . count ( ' . ' ) == 0 ) or n == 1 or n == p : print ( ' NO ' ) else : for i in range ( n - p ) : if s [ i ] == ' . ' : if s [ p + i ] == '0' or s [ p + i ] == ' . ' : s = s [ : i ] + '1' + s [ i + 1 : ] else : s = s [ : i ] + '0' + s [ i + 1 : ] break elif s [ p + i ] == ' . ' : if s [ i ] == '0' or s [ i ] == ' . ' : s = s [ : p + i ] + '1' + s [ p + i + 1 : ] else : s = s [ : p + i ] + '0' + s [ p + i + 1 : ] break s = s . replace ( ' . ' , '0' ) print ( s ) NEW_LINE"],"bleu":0.0001903371233905979,"rouge_l":0.1288174139051332}
{"id":226,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n - 1 ) : if ( a [ i ] == \"1\" ) : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"references":["for _ in range ( int ( input ( ) ) ) : a , b = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE print ( a ^ b ) NEW_LINE"],"bleu":0.20635286946106585,"rouge_l":0.4225440806045341}
{"id":227,"predictions":["def STR ( ) : return list ( input ( ) ) def INT ( ) : return int ( input ( ) ) def MAP ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE"],"references":["    n , r = map ( int , input ( ) . split ( ) )     t = list ( map ( int , input ( ) . split ( ) ) )       arr = [ 0 ] * ( n + 1 )     for i in range ( n ) :   if t [ i ] == 1 : arr [ max ( i - r + 1 , 0 ) ] += 1 arr [ min ( n , i + r ) ] -= 1         for j in range ( 1 , n + 1 ) : arr [ j ] += arr [ j - 1 ]         if 0 in arr [ : n ] : print ( - 1 ) else : ans = 0   for i in range ( n ) : st = max ( 0 , i - r + 1 ) en = min ( i + r , n )   h = 0   for j in range ( st , en ) : if arr [ j ] == 1 : h += 1 if h == 0 : ans += 1 for j in range ( st , en ) : arr [ j ] -= 1   print ( sum ( t ) - ans )                     NEW_LINE"],"bleu":0.007099783819168703,"rouge_l":0.15304448518768698}
{"id":228,"predictions":["n = int ( input ( ) ) st = input ( ) ans = 0 for i in range ( n ) : if ( st [ i ] + ' ) ' ) : ans += ( st [ i : i ] ) print ( ans ) NEW_LINE"],"references":["ans = [ ] for i in range ( 27 ) : for j in range ( 27 ) : for t in range ( 27 ) : tempa = [ i , j , t ] s = ' ' for q in range ( len ( tempa ) ) : if ( tempa [ q ] == 26 ) : continue ; else : s += chr ( tempa [ q ] + 97 ) ans . append ( [ len ( s ) , s ] )   ans . sort ( ) pg = [ ]   x = int ( input ( ) ) for i in range ( x ) : s = input ( ) pg . append ( s ) for i in range ( len ( ans ) ) : flag = 0 for j in range ( len ( pg ) ) : if ( ans [ i ] [ 1 ] in pg [ j ] ) : flag += 1 if ( flag == 0 ) : print ( ans [ i ] [ 1 ] ) exit ( )                                               NEW_LINE"],"bleu":0.027868845956095727,"rouge_l":0.22474669941664108}
{"id":229,"predictions":["t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : n = int ( input ( ) ) NEW_LINE li = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if n % 2 == 1 : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT else : NEW_LINE"],"references":["for t in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE r = [ int ( i ) for i in s [ 0 : : 2 ] ] NEW_LINE b = [ int ( i ) for i in s [ 1 : : 2 ] ] NEW_LINE win = 0 NEW_LINE if n % 2 == 1 : win = 2 NEW_LINE for i in r : if NEW_LINE i % 2 == 1 : win = 1 NEW_LINE break else : win = 1 NEW_LINE for i in b : if NEW_LINE i % 2 == 0 : win = 2 NEW_LINE break NEW_LINE print ( win ) NEW_LINE"],"bleu":0.160653723984605,"rouge_l":0.3840813690668389}
{"id":230,"predictions":["n = int ( input ( ) ) NEW_LINE if n ABCB > CBA : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["from itertools import permutations   flag = 0 a = input ( ) a_list = list ( permutations ( \" ABC \" ) ) a_list = [ \" \" . join ( x ) for x in a_list ] for x in a_list : if x in a : flag = 1 if flag == 1 : print ( \" Yes \" ) else : print ( \" No \" ) NEW_LINE"],"bleu":0.14826310526736472,"rouge_l":0.381575206141598}
{"id":231,"predictions":["import matht = int ( input ( ) ) NEW_LINE for _ in range ( t ) : n = int ( input ( ) ) NEW_LINE"],"references":["from sys import stdin NEW_LINE input = stdin . readline NEW_LINE input ( ) NEW_LINE * a , = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s , r = [ 0 ] * 2 NEW_LINE cnt = [ 0 ] * 100002 NEW_LINE for i in a : NEW_LINE INDENT cnt [ i ] += 1 NEW_LINE if cnt [ i ] % 4 == 0 : NEW_LINE INDENT s += 1 NEW_LINE DEDENT if cnt [ i ] % 2 == 0 : NEW_LINE INDENT r += 1 NEW_LINE DEDENT DEDENT q = int ( input ( ) ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT sign , n = input ( ) . split ( ) NEW_LINE n = int ( n ) NEW_LINE if sign == ' + ' : NEW_LINE INDENT cnt [ n ] += 1 NEW_LINE if cnt [ n ] % 4 == 0 : NEW_LINE INDENT s += 1 NEW_LINE DEDENT if cnt [ n ] % 2 == 0 : NEW_LINE INDENT r += 1 NEW_LINE DEDENT DEDENT elif sign == ' - ' : NEW_LINE INDENT if cnt [ n ] % 4 == 0 : NEW_LINE INDENT s -= 1 NEW_LINE DEDENT if cnt [ n ] % 2 == 0 : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT cnt [ n ] -= 1 NEW_LINE DEDENT print ( ' YES ' if s > 1 or ( s == 1 and r > 3 ) else ' NO ' ) NEW_LINE DEDENT"],"bleu":0.00007623225111301189,"rouge_l":0.13591010365203915}
{"id":232,"predictions":["k = int ( input ( ) ) for i in range ( k ) : n = int ( input ( ) ) cnt = 0 while ( k > 0 ) : if ( k == i ) : cnt += 1 else : i += 1 print ( k ) NEW_LINE"],"references":["k , s , o = int ( input ( ) ) , \" z \" , 97 while k : q = int ( ( ( 1 + 8 * k ) ** .5 - 1 ) \/ 2 ) + 1 k -= q * ( q - 1 ) \/\/ 2 s += chr ( o ) * q o += 1 print ( s ) NEW_LINE"],"bleu":0.1760197565568559,"rouge_l":0.40981912144702837}
{"id":233,"predictions":["n , cost = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) )   ans = 0 for i in range ( n - 1 ) : ans += min ( max ( ans , abs ( a [ i + 1 ] - a [ i ] ) ) ) print ( ans ) NEW_LINE"],"references":["n , c = map ( int , input ( ) . split ( ) ) prices = list ( map ( int , input ( ) . split ( ) ) )   max_i = Nonemax_p = Nonefor i , p in enumerate ( prices ) : if max_p is None or ( i < len ( prices ) - 1 and p - prices [ i + 1 ] > max_p ) : max_i = i max_p = p - prices [ i + 1 ]   print ( max ( 0 , prices [ max_i ] - c - prices [ max_i + 1 ] ) ) NEW_LINE"],"bleu":0.32663391227270083,"rouge_l":0.548337856173677}
{"id":234,"predictions":["n , k = map ( int , input ( ) . split ( ) ) check = [ ] for i in range ( n ) : check . append ( i ) for i in range ( len ( set ( i ) ) ) : for j in range ( len ( num ) ) : if check not check [ i ] ) : check . update ( [ i ] ) print ( len ( check ) ) NEW_LINE"],"references":["import sysinput = sys . stdin . readlineimport math   def inpit ( ) : NEW_LINE"],"bleu":0.026509727973525955,"rouge_l":0.15956651718983555}
{"id":235,"predictions":["import sys , os , ioimport math , bisect , operatorinf , mod = float ( ' inf ' ) , 10 ** 9 + 7 NEW_LINE"],"references":["from sys import stdin ''' class ▁ PriorityQueueBase : ▁ ▁ ▁ ▁ class ▁ _ Item : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ _ _ slots _ _ ▁ = ▁ ' _ key ' , ' _ value '   ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ def ▁ _ _ init _ _ ( self , k , v ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ self . _ key ▁ = ▁ k ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ self . _ value ▁ = ▁ v  ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ def ▁ _ _ lt _ _ ( self , other ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ return ▁ self . _ key ▁ < ▁ other . _ key  ▁ ▁ ▁ ▁ def ▁ is _ empty ( self ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ return ▁ len ( self ) ▁ = = ▁ 0 def ▁ queue _ time ( customers , n ) : ▁ ▁ ▁ ▁ for ▁ i ▁ in ▁ range ( 1 , len ( customers ) ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ i ▁ = ▁ i % n ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ while ▁ i % n < n ▁ and ▁ customers [ i % n ] > customers [ ( i + 1 ) % n ] : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ i + = 1 ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ customers [ i % n ] ▁ = customers [ i % n ] ▁ + ▁ customers [ i ] ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ customers [ i ] ▁ = ▁ 0 ▁ ▁ ▁ ▁ return ▁ customers def ▁ phi ( n ) : ▁ ▁ ▁ ▁ result ▁ = ▁ n ▁ ▁ ▁ ▁ for ▁ i ▁ in ▁ range ( 2 , int ( pow ( n , 0.5 ) ) + 1 ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ while ▁ n % i ▁ = = ▁ 0 : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ n \/ = i ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ result - = result \/ i ▁ ▁ ▁ ▁ if ▁ n > 1 : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ result ▁ - = ▁ result \/ n ▁ ▁ ▁ ▁ return ▁ result ''' def main ( ) : input = stdin . buffer . readline for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) a . sort ( ) cur = 0 ans = 0 for i in range ( n ) : cur += 1 if cur == a [ i ] : ans += 1 cur = 0 print ( ans ) main ( ) NEW_LINE"],"bleu":1.6157216722880026e-10,"rouge_l":0.034832262669521774}
{"id":236,"predictions":["n = int ( input ( ) ) s = ' ' . join ( s + '0' * ( n - 1 ) ) ) NEW_LINE"],"references":["n = int ( input ( ) ) s = list ( str ( input ( ) ) ) r = [ \" \" ] * nif n % 2 != 0 : j = n \/\/ 2 for i in range ( n ) : if i % 2 == 0 : r [ j + i ] = s [ i ] j += i else : r [ j - i ] = s [ i ] j -= ielse : j = ( n \/\/ 2 ) - 1 for i in range ( n ) : if i % 2 != 0 : r [ j + i ] = s [ i ] j += i else : r [ j - i ] = s [ i ] j -= i   print ( \" \" . join ( r ) ) NEW_LINE"],"bleu":0.0058538096165253834,"rouge_l":0.2008230452674897}
{"id":237,"predictions":["import sysfrom math import * NEW_LINE def main ( ) : NEW_LINE"],"references":["mod = 1000000007 eps = 10 ** - 9     def main ( ) : import sys from bisect import bisect_left input = sys . stdin . buffer . readline   def calc ( r , g , b ) : return ( r - g ) ** 2 + ( g - b ) ** 2 + ( b - r ) ** 2   for _ in range ( int ( input ( ) ) ) : NR , NG , NB = map ( int , input ( ) . split ( ) ) R = list ( map ( int , input ( ) . split ( ) ) ) G = list ( map ( int , input ( ) . split ( ) ) ) B = list ( map ( int , input ( ) . split ( ) ) ) R . sort ( ) B . sort ( ) G . sort ( ) ans = float ( ' inf ' )   NEW_LINE"],"bleu":8.758901602587219e-7,"rouge_l":0.06505179768433882}
{"id":238,"predictions":["import mathn = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) : if ( l [ i ] % 2 == 0 ) : arr . append ( i ) else : arr . append ( i )   if ( len ( arr ) ) % 2 == 0 : print ( ( ans ) ) else : print ( - ( len ( arr ) ) \/\/ 2 ) NEW_LINE"],"references":["import math   def total ( l , r ) : l -= 1 if l % 2 == 0 : l \/= 2 else : l = int ( math . ceil ( l \/ 2 ) * - 1 ) if r % 2 == 0 : r \/= 2 else : r = int ( math . ceil ( r \/ 2 ) * - 1 ) return int ( r - l )   q = int ( input ( ) ) ans = \" \"   for i in range ( q ) : l , r = map ( int , input ( ) . split ( ) ) ans += str ( total ( l , r ) ) + \" \\n \"   print ( ans ) NEW_LINE"],"bleu":0.2437532729975929,"rouge_l":0.31990063483301134}
{"id":239,"predictions":["from sys import stdin , stdoutfrom os import pathrd = lambda : stdin . readline ( ) . strip ( ) wr = stdout . writeif ( path . exists ( ' input . txt ' ) ) : stdin = open ( \" input . txt \" , \" r \" ) import time , math NEW_LINE"],"references":["n = int ( input ( ) ) a = [ int ( x ) for x in input ( ) . split ( ) ] a . sort ( ) print ( min ( a [ - 2 ] - a [ 0 ] , a [ - 1 ] - a [ 1 ] ) ) NEW_LINE"],"bleu":0.06347677331732142,"rouge_l":0.23894795747062117}
{"id":240,"predictions":["a = int ( input ( ) ) b = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( 3 ) ]   for i in range ( a ) : for j in range ( i + 1 ) : if ( i + j == 2 ) % 2 == 0 : if ( a [ i + 1 ] + a [ i ] + a [ j ] ) % 2 == 0 : print ( 1 ) else : print ( 0 ) NEW_LINE"],"references":["lights = [ [ 1 for _ in range ( 3 ) ] for _ in range ( 3 ) ] count = [ ] for _ in range ( 3 ) : count . append ( [ int ( i ) for i in input ( ) . split ( ' ▁ ' ) ] )   for i , row in enumerate ( count ) : for j , val in enumerate ( row ) : if val % 2 == 1 : lights [ i ] [ j ] = 0 if lights [ i ] [ j ] == 1 else 1 if i > 0 : lights [ i - 1 ] [ j ] = 0 if lights [ i - 1 ] [ j ] == 1 else 1 if i < 2 : lights [ i + 1 ] [ j ] = 0 if lights [ i + 1 ] [ j ] == 1 else 1 if j > 0 : lights [ i ] [ j - 1 ] = 0 if lights [ i ] [ j - 1 ] == 1 else 1 if j < 2 : lights [ i ] [ j + 1 ] = 0 if lights [ i ] [ j + 1 ] == 1 else 1   for row in lights : print ( ' ' . join ( [ str ( i ) for i in row ] ) ) NEW_LINE"],"bleu":0.07594075270682905,"rouge_l":0.31033888074502025}
{"id":241,"predictions":["import sysfrom math import * input = sys . stdin . buffer . readline   def main ( ) : n , m = map ( int , input ( ) . split ( ) ) a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) ans = 1 for _ in range ( n ) : a = list ( map ( int , input ( ) . split ( ) ) ) ans = max ( ans , min ( a ) ) print ( ans ) NEW_LINE"],"bleu":0.5600223424950027,"rouge_l":0.5879518072289156}
{"id":242,"predictions":["n = int ( input ( ) ) a = [ - 1 ] + list ( map ( int , input ( ) . split ( ) ) ) s = set ( ) s . add ( - 1 ) a . sort ( ) count , add = 0 , 0 flag = 0 for i in range ( 1 , n + 1 ) : if a [ i ] in s and a [ i ] - 1 in s : if a [ i ] - 1 in s : flag = 1 break if a [ i ] - 1 in s : add += 1 if ( add == 2 ) : flag = 1 break if ( add == 3 ) : print ( \" s \" ) NEW_LINE"],"references":["n = int ( input ( ) ) a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] solved = [ 0 for i in range ( 5 ) ] score = [ 0 for i in range ( 5 ) ] for i in range ( n ) : for j in range ( 5 ) : solved [ j ] += int ( a [ i ] [ j ] > - 1 ) for k in range ( 31 * n + 1 ) : for i in range ( 5 ) : tot = n + k cur = solved [ i ] if a [ 0 ] [ i ] > - 1 and a [ 1 ] [ i ] > - 1 and a [ 0 ] [ i ] > a [ 1 ] [ i ] : cur += k score [ i ] = 500 while score [ i ] < 3000 and 2 * cur <= tot : cur *= 2 ; score [ i ] += 500 res = [ 0 , 0 ] for j in range ( 2 ) : for i in range ( 5 ) : if a [ j ] [ i ] > - 1 : res [ j ] += score [ i ] \/ 250 * ( 250 - a [ j ] [ i ] ) if res [ 0 ] > res [ 1 ] : print ( k ) exit ( ) print ( \" - 1\" ) NEW_LINE"],"bleu":0.1452973223463284,"rouge_l":0.367142220240749}
{"id":243,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["import osimport sysfrom io import BytesIO , IOBase   BUFSIZE = 8192     class FastIO ( IOBase ) : newlines = 0   def __init__ ( self , file ) : self . _fd = file . fileno ( ) self . buffer = BytesIO ( ) self . writable = \" x \" in file . mode or \" r \" not in file . mode self . write = self . buffer . write if self . writable else None   def read ( self ) : while True : b = os . read ( self . _fd , max ( os . fstat ( self . _fd ) . st_size , BUFSIZE ) ) if not b : break ptr = self . buffer . tell ( ) self . buffer . seek ( 0 , 2 ) , self . buffer . write ( b ) , self . buffer . seek ( ptr ) self . newlines = 0 return self . buffer . read ( )   def readline ( self ) : while self . newlines == 0 : b = os . read ( self . _fd , max ( os . fstat ( self . _fd ) . st_size , BUFSIZE ) ) self . newlines = b . count ( b \" \\n \" ) + ( not b ) ptr = self . buffer . tell ( ) self . buffer . seek ( 0 , 2 ) , self . buffer . write ( b ) , self . buffer . seek ( ptr ) self . newlines -= 1 return self . buffer . readline ( )   def flush ( self ) : if self . writable : os . write ( self . _fd , self . buffer . getvalue ( ) ) self . buffer . truncate ( 0 ) , self . buffer . seek ( 0 )     class IOWrapper ( IOBase ) : def __init__ ( self , file ) : self . buffer = FastIO ( file ) self . flush = self . buffer . flush self . writable = self . buffer . writable self . write = lambda s : self . buffer . write ( s . encode ( \" ascii \" ) ) self . read = lambda : self . buffer . read ( ) . decode ( \" ascii \" ) self . readline = lambda : self . buffer . readline ( ) . decode ( \" ascii \" )     sys . stdin , sys . stdout = IOWrapper ( sys . stdin ) , IOWrapper ( sys . stdout ) input = lambda : sys . stdin . readline ( ) . rstrip ( \" \\n \" ) NEW_LINE"],"bleu":0.000043094922102096533,"rouge_l":0.09383068724935449}
{"id":244,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for i in range ( 1 ) : NEW_LINE"],"references":["import sys   from collections import defaultdict   POINTS_WIN = 3 POINTS_DRAW = 1 POINTS_LOSS = 0     def sort_order ( item : dict ) -> tuple : return - item [ \" points \" ] , - item [ \" score _ diff \" ] , - item [ \" score \" ]     def standings ( teams : list , games : list ) -> list : teams_data = { t : defaultdict ( int , { \" name \" : t } ) for t in teams } for lt , rt , ls , rs in games : teams_data [ lt ] [ \" score \" ] += ls teams_data [ rt ] [ \" score \" ] += rs   if ls == rs : teams_data [ lt ] [ \" points \" ] += POINTS_DRAW teams_data [ rt ] [ \" points \" ] += POINTS_DRAW elif ls < rs : teams_data [ lt ] [ \" points \" ] += POINTS_LOSS teams_data [ lt ] [ \" score _ diff \" ] -= rs - ls teams_data [ rt ] [ \" points \" ] += POINTS_WIN teams_data [ rt ] [ \" score _ diff \" ] += rs - ls else : teams_data [ lt ] [ \" points \" ] += POINTS_WIN teams_data [ lt ] [ \" score _ diff \" ] += ls - rs teams_data [ rt ] [ \" points \" ] += POINTS_LOSS teams_data [ rt ] [ \" score _ diff \" ] -= ls - rs   return list ( sorted ( teams_data . values ( ) , key = sort_order ) )     def parse_teams ( n : int ) -> list : teams = [ ] for i in range ( n ) : teams . append ( input ( ) ) return teams     def parse_games ( n : int ) -> list : games = [ ] for _ in range ( int ( n * ( n - 1 ) \/ 2 ) ) : line = sys . stdin . readline ( ) . strip ( ) teams , scores = line . split ( \" ▁ \" ) left_team , right_team = teams . split ( \" - \" ) left_score , right_score = map ( int , scores . split ( \" : \" ) ) games . append ( ( left_team , right_team , left_score , right_score ) )   return games     if __name__ == \" _ _ main _ _ \" : n = int ( input ( ) ) teams = parse_teams ( n ) games = parse_games ( n )   NEW_LINE"],"bleu":0.00008765738116649833,"rouge_l":0.10727860668292959}
{"id":245,"predictions":["t = int ( input ( ) ) for i in range ( t ) : n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) print ( sum ( a ) * ( b - 1 ) \/\/ 2 ) NEW_LINE"],"references":["from math import log2   for t in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) )   d = dict ( )   for i in range ( len ( a ) ) : a [ i ] = int ( log2 ( a [ i ] ) )   NEW_LINE"],"bleu":0.5344449189214499,"rouge_l":0.5946175037084128}
{"id":246,"predictions":["for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : print ( arr [ i - 1 ] , l [ 0 ] ) NEW_LINE"],"references":["t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT"],"bleu":0.32733806344200284,"rouge_l":0.4704748132080019}
{"id":247,"predictions":["def STR ( ) : return list ( input ( ) ) def INT ( ) : return int ( input ( ) ) def MAP ( ) : return map ( int , input ( ) . split ( ) ) for i in range ( n ) : NEW_LINE"],"references":["class Stack ( ) : def __init__ ( self ) : self . stack = [ ] self . len = 0   def top ( self ) : assert not self . empty ( ) return self . stack [ self . len - 1 ]   def pop ( self ) : assert not self . empty ( ) self . len -= 1 return self . stack . pop ( )   def push ( self , x ) : self . len += 1 self . stack . append ( x )   def empty ( self ) : return self . len == 0   def calc ( n , pos ) : st = Stack ( ) last_pos = - 1 ans = 0 for i in range ( n ) : if pos [ i ] == \" R \" : if st . empty ( ) : ans += i - last_pos - 1 st . push ( i ) elif pos [ i ] == \" L \" : if st . empty ( ) : last_pos = i else : left_R = st . pop ( ) ; ans += ( i - left_R + 1 ) % 2 last_pos = i if st . empty ( ) : ans += n - last_pos - 1 return ans     n = int ( input ( ) ) pos = str ( input ( ) ) print ( calc ( n , pos ) ) NEW_LINE"],"bleu":0.009148704620583911,"rouge_l":0.20350776856353064}
{"id":248,"predictions":["n = int ( input ( ) ) k = [ int ( x ) for x in input ( ) . split ( ) ] a = [ ] for i in range ( n ) : a . append ( a [ i ] + k ) a . append ( a ) ) for i in range ( len ( a ) ) : len ( a ) print ( a ) NEW_LINE"],"references":["from functools import cmp_to_key           def calc_lcp ( s , sa ) :   rank = [ 0 for _ in range ( len ( s ) ) ]   for i in range ( len ( s ) ) :   rank [ sa [ i ] ] = i   lcp = [ 0 for _ in range ( len ( s ) - 1 ) ]   h = 0   for i in range ( len ( s ) ) :   if rank [ i ] < len ( s ) - 1 :   while max ( i , sa [ rank [ i ] + 1 ] ) + h < len ( s ) and s [ i + h ] == s [ sa [ rank [ i ] + 1 ] + h ] :   h += 1   lcp [ rank [ i ] ] = h   if h > 0 :   h -= 1   return lcp , rank       def suffix_array ( s ) :   sa = [ i for i in range ( len ( s ) ) ]   rank = [ ord ( s [ i ] ) for i in range ( len ( s ) ) ]   k = 1   while k < len ( s ) :   key = [ 0 for _ in range ( len ( s ) ) ]   base = max ( rank ) + 2   for i in range ( len ( s ) ) :   key [ i ] = rank [ i ] * base + ( rank [ i + k ] + 1 if i + k < len ( s ) else 0 )   sa . sort ( key = ( lambda i : key [ i ] ) )       rank [ sa [ 0 ] ] = 0   for i in range ( 1 , len ( s ) ) :   rank [ sa [ i ] ] = rank [ sa [ i - 1 ] ] if key [ sa [ i - 1 ] ] == key [ sa [ i ] ] else i   k *= 2   NEW_LINE"],"bleu":0.006829498157649838,"rouge_l":0.18500866551126516}
{"id":249,"predictions":["n = int ( input ( ) )   t = int ( input ( ) )   for i in range ( n ) : x = list ( map ( int , input ( ) . split ( ) ) )   if x >= 1000 : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"references":["from sys import stdin     for _ in range ( int ( stdin . readline ( ) ) ) : n = int ( stdin . readline ( ) ) a = list ( map ( int , stdin . readline ( ) . split ( ) ) ) res = False total = 0 for i in a : if i < 2048 : total += i elif i == 2048 : res = True break if total >= 2048 : res = True   print ( ' YES ' if res else ' NO ' ) NEW_LINE"],"bleu":0.20883540301747747,"rouge_l":0.42230769230769233}
{"id":250,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) s = set ( ) for i in range ( n ) : if a [ i ] not in s . keys ( ) : print ( i ) NEW_LINE"],"references":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) k = 0 pas = 0 a = a [ : : - 1 ] for i in set ( a ) : s = a . count ( i ) if s > k : pas = i k = s elif s == k : if a . index ( i ) > a . index ( pas ) : pas = i k = a . count ( i ) print ( pas ) NEW_LINE"],"bleu":0.25912997172597624,"rouge_l":0.5135082223962413}
{"id":251,"predictions":["def isPrime ( n ) : for i in range ( 2 , int ( input ( ) ) ) : NEW_LINE"],"references":["for _ in range ( int ( input ( ) ) ) : d = int ( input ( ) ) NEW_LINE def prime ( a ) : for NEW_LINE i in range ( 2 , int ( a ** 0.5 ) + 1 ) : NEW_LINE if a % i == 0 : return False NEW_LINE return True NEW_LINE k = 1 NEW_LINE b = k + d NEW_LINE while not prime ( b ) : b += 1 NEW_LINE k *= b NEW_LINE p = k + d NEW_LINE while not prime ( p ) : p += 1 NEW_LINE print ( k * p ) NEW_LINE"],"bleu":0.013907556050789884,"rouge_l":0.24541797049620026}
{"id":252,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) s = sum ( l )   def solve ( ) : if s < n : return [ - 1 ] for i in range ( m ) : if l [ i ] > n - i : return [ - 1 ]   ov = s - n idx = 1 sln = [ ]   for i in range ( m ) : if ov > 0 and idx != 1 : d = min ( ov , l [ i - 1 ] - 1 ) idx -= d ov -= d sln . append ( idx ) idx += l [ i ]   return sln   print ( * solve ( ) ) NEW_LINE"],"bleu":0.04101220199939896,"rouge_l":0.2814406905789552}
{"id":253,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["n = int ( input ( ) ) mn1 , mx1 = map ( int , input ( ) . split ( ) ) mn2 , mx2 = map ( int , input ( ) . split ( ) ) mn3 , mx3 = map ( int , input ( ) . split ( ) )   fd = n - mn2 - mn3if fd > mx1 : fd = mx1n -= fdsd = n - mn3if sd > mx2 : sd = mx2td = n - sdprint ( fd , sd , td ) NEW_LINE"],"bleu":0.09426876079614727,"rouge_l":0.3293025264521702}
{"id":254,"predictions":["def main_function ( ) : n = int ( input ( ) ) socks = [ int ( i ) for i in input ( ) . split ( \" ▁ \" ) ] d = [ 0 for i in range ( n + 2 ) ] sum = 0 current_max = 0 for i in socks : if d [ i ] == 0 : d [ i ] = 1 sum += 1 else : d [ i ] = 0 sum += 1 if sum > current_max : current_max = sum return current_max       print ( main_function ( ) ) NEW_LINE"],"references":["n , k = map ( int , input ( ) . split ( ) ) s = input ( ) d = { }   val = 0 ; i = 0 while i < n : count = 1 ch = s [ i ] i += 1 while i < n : if s [ i ] == s [ i - 1 ] : count += 1 i += 1 else : break d [ ch ] = d . get ( ch , 0 ) + ( count \/\/ k )   print ( max ( d . values ( ) ) ) NEW_LINE"],"bleu":0.19466241098159281,"rouge_l":0.4159721169874223}
{"id":255,"predictions":["from sys import stdin , stdoutfrom os import pathrd = lambda : stdin . readline ( ) . strip ( ) wr = stdout . writeif ( path . exists ( ' input . txt ' ) ) : stdin = open ( \" input . txt \" , \" r \" ) import time , math NEW_LINE"],"references":["from collections import defaultdict as dcdef mlt ( ) : return map ( int , input ( ) . split ( ) ) def arp ( ) : return [ * mlt ( ) ]     s = input ( ) mp = dc ( lambda : 0 ) for n in s : mp [ ord ( n ) - 97 ] += 1 cntr = 0 for n in s : if mp [ ord ( n ) - 97 ] % 2 : cntr += 1   if cntr <= 1 : print ( ' First ' ) else : s1 = [ ' Second ' , ' First ' ] print ( s1 [ len ( s ) % 2 ] ) NEW_LINE"],"bleu":0.025726952246274658,"rouge_l":0.20138659623638164}
{"id":256,"predictions":["n = int ( input ( ) ) s = 0 for i in range ( 1 , n \/\/ 2 + 1 ) : if ( s % 2 == 0 ) : s += 2 print ( s ) NEW_LINE"],"references":["def dp ( n ) : if n < 0 : return 0 if not n : return 1 return 2 * dp ( n - 2 ) print ( dp ( int ( input ( ) ) ) ) NEW_LINE"],"bleu":0.2121521386286447,"rouge_l":0.2897862232779097}
{"id":257,"predictions":["from math import ceilfor _ in range ( int ( input ( ) ) ) : x , y , z = map ( int , input ( ) . split ( ) ) z = math . ceil ( x \/ y \/ z ) NEW_LINE"],"references":["def add ( vertex , neighbour ) : if vertex in graph : graph [ vertex ] . append ( neighbour ) else : graph [ vertex ] = [ neighbour ] if neighbour in graph : NEW_LINE"],"bleu":0.046588455183847084,"rouge_l":0.19189933149823044}
{"id":258,"predictions":["n = int ( input ( ) ) ; print ( 1 ) ; NEW_LINE"],"references":["n = int ( input ( ) ) NEW_LINE for i in range ( n , 0 , - 1 ) : if NEW_LINE n % i == 0 : n = i NEW_LINE print ( i , end = ' ▁ ' ) NEW_LINE"],"bleu":0.08197562005057978,"rouge_l":0.3669172932330827}
{"id":259,"predictions":["n = int ( input ( ) ) possible = Truefor _ in range ( n ) : s = list ( str ( input ( ) ) ) for i in range ( 0 , len ( s ) ) : if i == 0 : if s [ i ] == ' ? ' : if i == len ( s ) - 1 : s [ i ] = ' a ' if s [ i + 1 ] != ' a ' else ' b ' if s [ i + 1 ] != ' b ' else ' c ' else : s [ i ] = ' b ' elif i == len ( s ) - 1 and s [ i ] == ' ? ' : s [ i ] = ' a ' if s [ i - 1 ] != ' b ' else ' b ' else : s [ i ] = ' b ' if s [ i - 1 ] != ' a ' else ' b ' if s [ i - 1 ] != ' b ' else ' c ' else : s [ i ] = ' b ' if s [ i - 1 ] != ' b ' else ' c ' else : s [ i ] = ' b ' if s [ i + 1 ] != ' b ' else ' c ' else : s [ i + 1 ] = ' b ' if s [ i + 1 ] != ' c ' else ' a ' else : s [ i - 1 ] = ' b ' if s [ i + 1 ] != ' b ' else ' c ' print ( \" . join ( map ( str , s ) ) if possible else - 1 ) possible = True NEW_LINE"],"references":["import sysimport math   n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) i = 1 ans = [ a [ 0 ] ] while i < n : if math . gcd ( ans [ - 1 ] , a [ i ] ) == 1 : ans . append ( a [ i ] ) i += 1 else : ans . append ( 1 ) print ( len ( ans ) - n ) print ( * ans ) NEW_LINE"],"bleu":0.06815084782237116,"rouge_l":0.2876371742112483}
{"id":260,"predictions":["n , m = map ( int , input ( ) . split ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) : arr [ i ] = list ( map ( int , input ( ) . split ( ) ) ) if ( arr [ m - 1 ] ) : count = 0 for i in arr : if ( i == arr [ i ] ) : count += 1 else : count += 1 print ( count ) NEW_LINE"],"references":["t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : n , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE s = list ( s ) NEW_LINE sum = 1 NEW_LINE j = 0 NEW_LINE for i in range ( n ) : if NEW_LINE s [ i ] == ' W ' : j = i NEW_LINE break NEW_LINE l = j NEW_LINE j = j + 1 NEW_LINE lst = [ ] NEW_LINE while j < n : if NEW_LINE s [ l ] == s [ j ] and j - l == 1 : j += 1 NEW_LINE l += 1 elif s [ l ] == s [ j ] and j - l > 1 : lst . append ( [ j - l - 1 , l + 1 ] ) NEW_LINE l = j NEW_LINE j += 1 else : j += 1 NEW_LINE"],"bleu":0.16706335296467922,"rouge_l":0.34889041409288496}
{"id":261,"predictions":["for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) if n == 1 : print ( ' YES ' ) elif n == 2 : print ( ' NO ' ) else : print ( ' YES ' ) NEW_LINE"],"references":["t = int ( input ( ) ) for _ in range ( t ) : n = int ( input ( ) ) s = input ( ) if n == 2 : if int ( s [ 0 ] ) >= int ( s [ 1 ] ) : print ( \" NO \" ) else : print ( \" YES \" ) print ( 2 ) print ( s [ 0 ] , s [ 1 ] ) else : print ( \" YES \" ) print ( 2 ) print ( s [ 0 ] , s [ 1 : ] ) NEW_LINE"],"bleu":0.1904475322902838,"rouge_l":0.4262422360248447}
{"id":262,"predictions":["n = int ( input ( ) ) s = input ( ) if n == 1 : print ( \" NO \" ) else : print ( \" YES \" ) NEW_LINE"],"references":["n = int ( input ( ) ) s = input ( ) t = s . upper ( ) if len ( set ( t ) ) == 26 : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.5657463595374336,"rouge_l":0.713018943974204}
{"id":263,"predictions":["from collections import deque   intersections = int ( input ( ) ) shortcuts = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) costs = [ float ( ' inf ' ) ] * ( intersections + 1 ) costs [ 1 ] = 0 queue = deque ( [ 1 ] )   while queue : t = queue . popleft ( )   if t + 1 <= intersections and costs [ t ] + 1 < costs [ t + 1 ] : costs [ t + 1 ] = costs [ t + 1 ] + 1 queue . append ( t + 1 )   if t + 1 >= costs [ t + 1 ] : costs [ t - 1 ] = costs [ t + 1 ] + costs [ t - 1 ] = costs [ t ] + 1 queue . append ( t + 1 )   if t + 1 < costs [ t + 1 ] : costs [ t ] = costs [ t ] + 1 queue . append ( shortcuts [ t ] )   print ( ' ▁ ' . join ( str ( i ) for i in costs [ 1 : ] ) ) NEW_LINE"],"references":["a = input ( ) . rjust ( 10 ** 6 , \"0\" ) b = input ( ) . rjust ( 10 ** 6 , \"0\" ) if a > b : print ( \" > \" ) elif a < b : print ( \" < \" ) elif a == b : print ( \" = \" ) NEW_LINE"],"bleu":0.03145775978493583,"rouge_l":0.19409443808069232}
{"id":264,"predictions":["n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( 1 , n + 1 ) : if arr [ i ] == arr [ i ] : count += 1 else : count = 1 for i in range ( 1 , n + 1 ) : if arr [ i ] == arr [ i - 1 ] : count += 1 print ( count ) NEW_LINE"],"references":["n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) c = 1 ans = 0 for i in range ( n - 1 ) : if 2 * l [ i ] >= l [ i + 1 ] : c = c + 1 else : ans = max ( c , ans ) c = 1 ans = max ( ans , c ) print ( ans ) NEW_LINE"],"bleu":0.40476363360223816,"rouge_l":0.6035094269180511}
{"id":265,"predictions":["n = int ( input ( ) ) v_arr = list ( map ( int , input ( ) . split ( ' ▁ ' ) ) ) u_arr = v_arr . copy ( ) u_arr . sort ( ) m = int ( input ( ) )   def sum_calc ( arr ) : sum_ = 0 sum_arr = [ 0 ] for item in arr : sum_ += item sum_arr . append ( sum_ ) return sum_arr   sum_v = sum_calc ( v_arr ) for i in range ( m ) : inp = list ( map ( int , input ( ) . split ( ' ▁ ' ) ) ) : inp = list ( map ( int , input ( ) . split ( ' ▁ ' ) ) ) for j in range ( n ) : sum_v [ j ] = sum_u [ j ] - 1 NEW_LINE"],"references":["'''   ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Online ▁ Python ▁ Compiler . ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Code , ▁ Compile , ▁ Run ▁ and ▁ Debug ▁ python ▁ program ▁ online . Write ▁ your ▁ code ▁ in ▁ this ▁ editor ▁ and ▁ press ▁ \" Run \" ▁ button ▁ to ▁ execute ▁ it .   '''   n , a , b = map ( int , input ( ) . split ( ) ) mnn = - 1 for i in range ( 1 , n ) : k = n - i p = a \/\/ i q = b \/\/ k mn = min ( p , q ) NEW_LINE"],"bleu":0.11910665663218674,"rouge_l":0.19208565130681224}
{"id":266,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["s = input ( ) n = len ( s ) sett = { }   for i in range ( n ) : if s [ i ] not in sett : sett [ s [ i ] ] = [ ] sett [ s [ i ] ] . append ( s [ i + 1 : ] + s [ : i ] ) ans = 0   NEW_LINE"],"bleu":0.0495910212308292,"rouge_l":0.21051234404035044}
{"id":267,"predictions":["import osimport sysfrom io import BytesIO , IOBase   BUFSIZE = 8192     class FastIO ( IOBase ) : newlines = 0   def __init__ ( self , file ) : self . _fd = file . fileno ( ) self . buffer = BytesIO ( ) self . writable = \" x \" in file . mode or \" r \" not in file . mode self . write = self . buffer . write if self . writable else None   def read ( self ) : while True : b = os . read ( self . _fd , max ( os . fstat ( self . _fd ) . st_size , BUFSIZE ) ) if not b : break ptr = self . buffer . tell ( ) self . buffer . seek ( 0 , 2 ) , self . buffer . write ( b ) , self . buffer . seek ( ptr ) self . newlines = 0 return self . buffer . read ( )   def readline ( self ) : while self . newlines == 0 : b = os . read ( self . _fd , max ( os . fstat ( self . _fd ) . st_size , BUFSIZE ) ) self . newlines = b . count ( b \" \\n \" ) + ( not b ) ptr = self . buffer . tell ( ) self . buffer . seek ( 0 , 2 ) , self . buffer . write ( b ) , self . buffer . seek ( ptr ) self . newlines -= 1 return self . buffer . readline ( )   def flush ( self ) : if self . writable : os . write ( self . _fd , self . buffer . getvalue ( ) ) self . buffer . truncate ( 0 ) , self . buffer . seek ( 0 )     class IOWrapper ( IOBase ) : def __init__ ( self , file ) : self . buffer = FastIO ( file ) self . flush = self . buffer . flush self . writable = self . buffer . writable self . write = lambda s : self . buffer . write ( s . encode ( \" ascii \" ) ) self . read = lambda : self . buffer . read ( ) . decode ( \" ascii \" ) self . readline = lambda : self . buffer . readline ( ) . decode ( \" ascii \" )     sys . stdin , sys"],"references":["a = list ( input ( ) ) x = a . index ( \" ^ \" ) l = 0 r = 0 for i , j in enumerate ( a ) : if i < x and j != \" = \" : l += int ( j ) * ( x - i ) if i > x and j != \" = \" : r += int ( j ) * ( i - x ) if l > r : print ( \" left \" ) elif r > l : print ( \" right \" ) else : print ( \" balance \" ) NEW_LINE"],"bleu":0.017031377078824843,"rouge_l":0.17957982068780945}
{"id":268,"predictions":["import math     q = int ( input ( ) ) for i in range ( q ) : l , r , d = map ( int , input ( ) . split ( ) ) if ( r + 1 ) % d == 0 : print ( 1 ) else : if ( ( l - 1 ) \/\/ d + 1 ) * d % 2 == 0 : print ( ( l - 1 ) \/\/ d ) else : print ( ( r + 1 ) \/\/ d \/\/ d ) NEW_LINE"],"references":["t = int ( input ( ) ) for _ in range ( t ) : a , b , c = map ( int , input ( ) . split ( ) ) if c < a : print ( c ) else : if b % c == 0 : print ( b + c ) else : print ( ( c + b ) - b % c ) NEW_LINE"],"bleu":0.36310085296476335,"rouge_l":0.6215951401136586}
{"id":269,"predictions":["x , y , z = [ int ( s ) for s in input ( ) . split ( ) ] for i in range ( z ) : a , b = map ( int , input ( ) . split ( ) ) if a > z : s += sum ( a + z ) \/\/ 2 print ( s ) NEW_LINE"],"references":["l , r , a = map ( int , input ( ) . split ( ) ) while a > 0 : if l < r : l = l + 1 else : r = r + 1 a = a - 1 print ( min ( l , r ) * 2 ) NEW_LINE"],"bleu":0.24809839013130444,"rouge_l":0.39546191247974066}
{"id":270,"predictions":["N = int ( input ( ) ) NEW_LINE T = sorted ( map ( int , input ( ) . split ( ' ▁ ' ) ) ) NEW_LINE t = sorted ( t , key = lambda x : x [ 1 ] ) NEW_LINE print ( t [ 1 ] ) NEW_LINE"],"references":["from statistics import moden = int ( input ( ) ) list_of_numbers = [ int ( x ) for x in input ( ) . split ( ) ] m = mode ( list_of_numbers ) print ( n - list_of_numbers . count ( m ) ) NEW_LINE"],"bleu":0.26310305500599696,"rouge_l":0.4574502771437887}
{"id":271,"predictions":["inp = input ( ) . split ( ' ▁ ' ) n = int ( inp [ 0 ] ) c = list ( map ( int , inp [ 1 ] . split ( ) ) ) dp = [ 0 ] * nfor i in range ( n ) : dp [ i ] = max ( dp [ i - 1 ] - c * c for i in range ( n ) ] ) : dp [ i ] [ 1 ] = max ( dp [ i ] - ( dp [ i - 1 ] [ 0 ] ) + max ( dp [ i ] [ 1 ] - c * dp [ i ] [ 1 ] ) print ( max ( dp ) ) ) NEW_LINE"],"references":["def main ( ) : petya_score = 0 vigen_score = 0 petya_time = 0 vigen_time = 0 n , c = map ( int , input ( ) . split ( ) ) task_price = list ( map ( int , input ( ) . split ( ) ) ) task_time = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( 0 , n ) : NEW_LINE"],"bleu":0.18244739863790016,"rouge_l":0.34391108247422675}
{"id":272,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) dp = [ 0 ] * nfor i in range ( n ) : dp [ i ] [ dp [ i - 1 ] = dp [ i - 1 ] for i in range ( i + 1 , n ) : dp [ i ] [ i ] = max ( dp [ i - 1 ] [ i - 1 ] , dp [ i - 1 ] ) dp [ i ] [ 1 ] = dp [ i - 1 ] [ i - 1 ] for i in range ( 1 , n ) : dp [ i ] [ 1 ] = max ( dp [ i - 1 ] [ i - 1 ] , dp [ i ] [ 0 ] ) ans = max ( ans , dp [ i ] [ 1 ] ) print ( ans ) NEW_LINE"],"references":["n = int ( input ( ) ) x = FalseA = [ int ( i ) for i in input ( ) . split ( ) ] for i in range ( n - 2 ) : x1 , x2 = min ( A [ i ] , A [ i + 1 ] ) , max ( A [ i ] , A [ i + 1 ] ) for j in range ( i + 1 , n - 1 ) : X1 , X2 = min ( A [ j ] , A [ j + 1 ] ) , max ( A [ j ] , A [ j + 1 ] ) if ( x1 < X1 and X1 < x2 and x2 < X2 ) : x = True elif ( X1 < x1 and X2 > x1 and X2 < x2 ) : x = Trueif ( x ) : print ( \" yes \" ) else : print ( \" no \" ) NEW_LINE"],"bleu":0.23231919095845843,"rouge_l":0.4247271358675198}
{"id":273,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n - m + 1 ) : if a [ i ] [ 0 ] > a [ i + 1 ] [ 0 ] : a [ i + 1 ] [ 1 ] = a [ i + 1 ] [ 0 ] * mprint ( * n ) NEW_LINE"],"references":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) R1 , R2 = map ( int , input ( ) . split ( ) ) print ( sum ( a [ R1 - 1 : R2 - 1 ] ) ) NEW_LINE"],"bleu":0.37232123375626036,"rouge_l":0.5062240663900415}
{"id":274,"predictions":["n = int ( input ( ) ) total = 0 for i in range ( 1 , n + 1 ) : if ( i % 7 == 0 or i % 7 == 0 ) : total += 1 elif ( i % 7 == 2 ) : total += 1 print ( total ) NEW_LINE"],"references":["n = int ( input ( ) ) mx = n \/\/ 7 * 2 + min ( n % 7 , 2 ) mn = n \/\/ 7 * 2 + max ( n % 7 - 5 , 0 )   print ( mn , mx )     NEW_LINE"],"bleu":0.19703715011933906,"rouge_l":0.4223359422034919}
{"id":275,"predictions":["s = input ( ) NEW_LINE n = int ( input ( ) ) NEW_LINE if n [ 0 ] == s [ 1 ] or s [ 1 ] == s [ 1 ] : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"],"references":["tk = input ( ) m = tk [ 0 ] n = tk [ 1 ] flag = 0 inp2 = list ( map ( str , input ( ) . split ( ) ) )   for st in inp2 : if st [ 0 ] == m : print ( \" YES \" ) flag = 1 break elif st [ 1 ] == n : print ( \" YES \" ) flag = 1 break     if flag == 0 : print ( \" NO \" )                                   NEW_LINE"],"bleu":0.22235564314887238,"rouge_l":0.4059149722735675}
{"id":276,"predictions":["n , m = map ( int , input ( ) . split ( ) ) k = 2 * ( m - 1 ) p = [ 0 ] * nfor i in range ( n ) : s , f , t = map ( int , input ( ) . split ( ) ) d = t % k if s < f : p [ d ] = ( k if s <= d else 0 ) + f - 1 + t - d elif f < s : p [ d ] = ( k if d + s > k + 1 else 0 ) + k + 1 - f + t - d else : p [ d ] = tprint ( ' \\n ' . join ( map ( str , p ) ) ) NEW_LINE"],"references":["def main ( ) : a = b = 1 for _ in range ( int ( input ( ) ) ) : s = input ( ) if s in ( \" UL \" , \" DR \" ) : a += 1 elif s in ( \" UR \" , \" DL \" ) : b += 1 elif s == \" ULDR \" : a += 1 b += 1 print ( a * b )     if __name__ == ' _ _ main _ _ ' : main ( ) NEW_LINE"],"bleu":0.05885246311269882,"rouge_l":0.2746974387841261}
{"id":277,"predictions":["t = int ( input ( ) ) for i in range ( t ) : n , k = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) x = k + 1 c = 0 for i in range ( n ) : if l [ i ] <= k : x = i + 1 c = x + 1 print ( c ) NEW_LINE"],"references":["import sysfrom os import pathif ( path . exists ( ' input . txt ' ) and path . exists ( ' output . txt ' ) ) : sys . stdout = open ( ' output . txt ' , ' w ' ) sys . stdin = open ( ' input . txt ' , ' r ' )   NEW_LINE"],"bleu":0.03460168322194023,"rouge_l":0.23209489704565797}
{"id":278,"predictions":["for z in range ( 1 ) : co = 0 n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) for e in range ( 1 , 25 ) : po = 2 ** e re = sorted ( [ k % po for k in l ] ) b = n r = 0 for a in range ( n ) : b -= 1 while re [ b ] + re [ a ] >= po and b >= 0 : b -= 1 b += 1 r += n - b - ( a >= b ) r \/\/= 2 if r % 2 : co += 2 ** e if n % 2 == 0 : for k in l : co = co ^ k print ( co ) NEW_LINE"],"references":["import io , osinput = io . BytesIO ( os . read ( 0 , os . fstat ( 0 ) . st_size ) ) . readlinefrom collections import defaultdict , dequedef bfs ( node ) : vis [ node ] = 1 q = deque ( [ node ] ) while q : cur = q . popleft ( ) dict1 = { } for j in edge [ cur ] : if vis [ j ] == 0 : vis [ j ] = 1 q . append ( j ) if topic [ j - 1 ] == topic [ cur - 1 ] : return False if topic [ j - 1 ] < topic [ cur - 1 ] : dict1 [ topic [ j - 1 ] ] = 1 b = len ( dict1 . keys ( ) ) if b != topic [ cur - 1 ] - 1 : return False return Truen , m = list ( map ( int , input ( ) . split ( ) ) ) edge = defaultdict ( list ) for i in range ( m ) : u , v = list ( map ( int , input ( ) . split ( ) ) ) edge [ u ] . append ( v ) edge [ v ] . append ( u ) topic = list ( map ( int , input ( ) . split ( ) ) ) vis = [ 0 ] * ( n + 1 ) s = 0 for i in range ( 1 , n + 1 ) : if vis [ i ] == 0 : temp = bfs ( i ) if temp == False : s += 1 breakif s == 1 : print ( - 1 ) else : ans = [ ] for i in range ( n ) : ans . append ( [ topic [ i ] , i + 1 ] ) ans . sort ( key = lambda x : x [ 0 ] , reverse = False ) num = [ ] for i in range ( n ) : num . append ( ans [ i ] [ 1 ] ) print ( \" ▁ \" . join ( str ( x ) for x in num ) ) NEW_LINE"],"bleu":0.05108281556254414,"rouge_l":0.23004825023570516}
{"id":279,"predictions":["from __future__ import division , print_functionfrom collections import * from math import * from itertools import * import osimport sysfrom io import BytesIO , IOBaseimport math NEW_LINE"],"references":["import sys , functools , collections , bisect , math , NEW_LINE INDENT heapqinput = sys . stdin . readline NEW_LINE DEDENT"],"bleu":0.06143498010483918,"rouge_l":0.2494887525562372}
{"id":280,"predictions":["t = int ( input ( ) )   for t in range ( t ) : n = int ( input ( ) ) if ( n % 2020 ) : print ( ' YES ' ) else : print ( ' NO ' ) NEW_LINE"],"references":["def solve ( ) : n = int ( input ( ) ) NEW_LINE i = 0 NEW_LINE while 2021 * i <= n : if NEW_LINE ( n - ( i * 2021 ) ) % 2020 == 0 : NEW_LINE return True NEW_LINE i += 1 NEW_LINE return False       for t in range ( int ( input ( ) ) ) : if NEW_LINE solve ( ) : print ( ' YES ' ) else : print ( ' NO ' ) NEW_LINE"],"bleu":0.32355529599917593,"rouge_l":0.533732443011743}
{"id":281,"predictions":["from collections import defaultdictimport heapqn = int ( input ( ) ) NEW_LINE s = open ( \" input . txt \" , \" w \" ) [ 0 ] NEW_LINE x = list ( map ( int , input ( ) . split ( \" ▁ \" ) ) ) NEW_LINE t = list ( map ( int , input ( ) . split ( \" ▁ \" ) ) ) NEW_LINE for i in range ( s [ 1 ] ) : NEW_LINE"],"references":["from collections import Counter     def gcd ( a , b ) : return a if b == 0 else gcd ( b , a % b )     n = int ( input ( ) ) count = Counter ( ) for e in map ( int , input ( ) . split ( ) ) : count [ e ] += 1 res = [ ] while sum ( count . values ( ) ) > 0 : cur = max ( count . keys ( ) ) count [ cur ] -= 1 if count [ cur ] == 0 : del count [ cur ] for e in res : g = gcd ( cur , e ) count [ g ] -= 2 if count [ g ] == 0 : del count [ g ] res . append ( cur ) print ( * res ) NEW_LINE"],"bleu":0.1196558113618055,"rouge_l":0.3166774821544452}
{"id":282,"predictions":["t = int ( input ( ) ) for i in range ( t ) : NEW_LINE"],"references":["res = [ ]   for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEW_LINE if n < 0 : NEW_LINE INDENT res . append ( - n ) else : NEW_LINE s = 0 NEW_LINE DEDENT i = 0 NEW_LINE while s < n : i += 1 NEW_LINE s += i NEW_LINE if s == n or s - n > 1 : NEW_LINE INDENT res . append ( i ) else : NEW_LINE res . append ( i + 1 )   for i in res : print ( i ) NEW_LINE DEDENT"],"bleu":0.003392484960705715,"rouge_l":0.18386274055182006}
{"id":283,"predictions":["n = int ( input ( ) ) a1 = [ 0 ] + [ int ( x ) for x in input ( ) . strip ( ) . split ( \" ▁ \" ) ]   out = [ ]   for i in range ( 1 , n + 1 ) : a = a1 . copy ( ) j = a [ i ] NEW_LINE"],"references":["s = input ( ) horizontal = - 1 vertical = - 1 v = [ ] h = [ ] for i in range ( len ( s ) ) : if s [ i ] == \"0\" : vertical += 1 vertical %= 2 if vertical == 0 : ans = 1 else : ans = 3 print ( ans , 1 ) else : horizontal += 1 horizontal %= 4 print ( horizontal + 1 , 2 ) NEW_LINE"],"bleu":0.16328384460851536,"rouge_l":0.3130211674150096}
{"id":284,"predictions":["n , s = map ( int , input ( ) . split ( ) )     if n == 1 : print ( 0 ) else : n = int ( n ** 2 - 1 ) + ( n ** 2 ) NEW_LINE"],"references":["import mathn = int ( input ( ) ) if ( n == 0 ) : print ( 1 ) elif ( n == 1 ) : print ( 4 ) elif ( n == 2 ) : print ( 8 ) elif ( n == 3 ) : print ( 16 ) else : k = 4 + 8 * ( int ( math . sqrt ( n * n \/ 2 ) ) ) p = int ( math . sqrt ( n * n \/ 2 ) ) if ( p * p + ( p + 1 ) * ( p + 1 ) > n * n ) : k -= 4 print ( k ) NEW_LINE"],"bleu":0.041248090054116476,"rouge_l":0.3191988451822447}
{"id":285,"predictions":["t = int ( input ( ) ) for _ in range ( t ) : n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) i = 0 while ( i < n ) : if ( l [ i ] - l [ i - 1 ] ) % 2 == 0 : i += 1 else : i += 1 print ( i ) NEW_LINE"],"references":["import math as m   t = int ( input ( ) )   for i in range ( t ) : a , b = map ( int , input ( ) . split ( ) ) mx , mn = max ( a , b ) , min ( a , b ) c = 2 * ( mx - mn ) d = 1 ** 2 + 4 * c ds = m . sqrt ( d ) n = ( ds - 1 ) \/ 2 n = int ( n ) if int ( n ) == n else int ( n ) + 1 n += ( n * ( n + 1 ) \/\/ 2 ) % 2 != ( mx - mn ) % 2 n += ( n * ( n + 1 ) \/\/ 2 ) % 2 != ( mx - mn ) % 2 print ( n )   NEW_LINE"],"bleu":0.1548329506559007,"rouge_l":0.36259011002908814}
{"id":286,"predictions":["a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE if c < a : NEW_LINE INDENT print ( \" YES \" ) else : NEW_LINE DEDENT"],"references":["from collections import Counterimport math   def solve ( ) : a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) n = int ( input ( ) ) sum1 , sum2 = 0 , 0   for i in a : sum1 += i for i in b : sum2 += i   if math . ceil ( sum1 \/ 5 ) + math . ceil ( sum2 \/ 10 ) <= n : return \" YES \"   return \" NO \"                 print ( solve ( ) ) NEW_LINE"],"bleu":0.05718113506450315,"rouge_l":0.26754385964912275}
{"id":287,"predictions":["n = int ( input ( ) ) num = 0 while n : x = input ( ) . split ( ) n = int ( n ) x = 0 while ( n ) != 1 : num += 1 n >>= 1 print ( num ) NEW_LINE"],"references":["print ( bin ( int ( input ( ) ) ) . count ( '1' ) ) NEW_LINE"],"bleu":0.14803136625607138,"rouge_l":0.38566912539515275}
{"id":288,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) )   b = list ( map ( int , input ( ) . split ( ) ) ) )   ans = 0   for i in range ( n - 1 ) : if a [ i ] < b [ i + 1 ] : ans += a [ i ]   print ( ans ) NEW_LINE"],"references":["I = lambda : list ( map ( int , input ( ) . split ( ) ) ) R = range ( I ( ) [ 0 ] ) a = I ( ) b = I ( ) c = I ( ) print ( min ( c [ i ] + c [ j ] + sum ( a [ : i ] + a [ : j ] + b [ i : ] + b [ j : ] ) for i in R for j in R if i != j ) ) NEW_LINE"],"bleu":0.2640133651489472,"rouge_l":0.40666666666666673}
{"id":289,"predictions":["import sysinput = sys . stdin . readlineimport bisectn , m = map ( int , input ( ) . split ( ) ) t = list ( map ( int , input ( ) . split ( ) ) ) x , y = map ( int , input ( ) . split ( ) ) ) if t == n : print ( 0 ) elif t == 1 : print ( 0 ) else : res = [ ] for i in range ( 1 , n ) : if t [ i ] != t [ i ] : res . append ( i ) t [ i ] = [ 0 ] * ( n ) for i in range ( 1 , n - 1 ) : t [ i ] = bisect . bisect_left ( t , n - 1 ) if t [ i ] == t [ i ] : res . append ( t [ i ] ) elif t [ i ] == n : res . append ( i + 1 ) else : res . append ( abs ( t [ i ] ) ) t = bisect . bisect_left ( t [ x ] , t [ i ] ) ) if not in res : print ( * res ) else : print ( ' Impossible ' ) NEW_LINE"],"references":["n = int ( input ( ) ) a = [ 0 ] * nb = [ 0 ] * nfor i in range ( n * ( n - 1 ) \/\/ 2 - 1 ) : c , d = list ( map ( int , input ( ) . split ( ) ) ) a [ c - 1 ] += 1 b [ c - 1 ] += 1 b [ d - 1 ] += 1 f = - 1 g = - 1 for i in range ( n ) : if b [ i ] == n - 2 : if f == - 1 : f = i + 1 else : g = i + 1 breakif a [ f - 1 ] > a [ g - 1 ] : print ( f , g ) else : print ( g , f ) NEW_LINE"],"bleu":0.21606265271996725,"rouge_l":0.37357830271216097}
{"id":290,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) cnt = 0 ans = 0 for i in range ( n ) : if cnt [ i ] == 1 : ans += 1 else : ans += abs ( sum ( a [ i ] ) \/ 2 ) if cnt == 1 : print ( - 1 ) else : print ( ans ) NEW_LINE"],"references":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) cnt = { } for x in a : cnt [ x ] = cnt . get ( x , 0 ) + 1 for x in b : cnt [ x ] = cnt . get ( x , 0 ) - 1 if any ( [ abs ( v ) % 2 == 1 for v in cnt . values ( ) ] ) : print ( - 1 ) else : ans = sum ( [ v for v in cnt . values ( ) if v > 0 ] ) \/\/ 2 print ( ans ) NEW_LINE"],"bleu":0.2605195328611022,"rouge_l":0.46448843970649306}
{"id":291,"predictions":["from sys import stdin , stdoutfrom os import pathrd = lambda : stdin . readline ( ) . strip ( ) wr = stdout . writeif ( path . exists ( ' input . txt ' ) ) : stdin = open ( \" input . txt \" , \" r \" ) import time , math NEW_LINE"],"references":["from sys import stdout   first_rez = [ ]     def req ( x1 , y1 , x2 , y2 ) : print ( ' ? ' , x1 , y1 , x2 , y2 ) stdout . flush ( ) x = int ( input ( ) ) if first_rez : if x1 <= first_rez [ 0 ] <= first_rez [ 2 ] <= x2 and y1 <= first_rez [ 1 ] <= first_rez [ 3 ] <= y2 : x -= 1 NEW_LINE"],"bleu":0.05307346569578358,"rouge_l":0.2281126264848218}
{"id":292,"predictions":["import sys NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE input = sys . stdin . readline NEW_LINE N = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE bs = [ ] NEW_LINE cs = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( a - ls [ i ] == 0 ) : NEW_LINE INDENT bs . append ( l [ i ] + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT cs . append ( a - b [ i ] ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if i < j : NEW_LINE INDENT cs [ j ] = 2 NEW_LINE bs [ i ] = 2 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if i + j == n : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( \" NO \" ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT print ( \" YES \" ) NEW_LINE"],"references":["import sysfrom collections import defaultdict as ddinput = sys . stdin . readlineI = lambda : list ( map ( int , input ( ) . split ( ) ) )   n , a , b = I ( ) l = I ( ) dic = dd ( int ) for i in range ( n ) : dic [ l [ i ] ] = 1 bs = [ ] pa = dd ( int ) for i in range ( n ) : if dic [ a - l [ i ] ] == 0 : bs . append ( l [ i ] ) else : pa [ l [ i ] ] = a - l [ i ] j = 0 while j < len ( bs ) : for i in range ( j , len ( bs ) ) : cr = bs [ i ] dic [ cr ] = 2 if dic [ b - cr ] == 0 : print ( \" NO \" ) ; exit ( ) dic [ b - cr ] = 2 if dic [ a - b + cr ] == 1 : dic [ a - b + cr ] = 2 bs . append ( a - b + cr ) j += 1 NEW_LINE"],"bleu":0.31581389061593845,"rouge_l":0.4220540540540541}
{"id":293,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) count = 0 for i in a : if i % 2 == 0 : count += 1 else : count += 1 print ( count ) NEW_LINE"],"references":["import mathn = int ( input ( ) )   arr = [ ]   for i in range ( n ) : arr . append ( int ( input ( ) ) )   res = [ ] flag = Falsefor i in arr : if i % 2 == 0 : res . append ( int ( i \/ 2 ) ) continue if flag : res . append ( math . floor ( i \/ 2 ) ) flag = False else : res . append ( math . ceil ( i \/ 2 ) ) flag = True for i in res : print ( i ) NEW_LINE"],"bleu":0.13343174122833573,"rouge_l":0.3757700205338809}
{"id":294,"predictions":["import math , sys , itertoolsfrom collections import Counter , deque , defaultdictfrom bisect import bisect_left , bisect_right NEW_LINE"],"references":["from math import sqrtdef NEW_LINE dist ( a , b ) : NEW_LINE return ( sqrt ( a ** 2 + b ** 2 ) ) NEW_LINE def solve ( ) : n = int ( input ( ) ) NEW_LINE d = [ ] NEW_LINE m = [ ] NEW_LINE for p in range ( 2 * n ) : a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a == 0 : NEW_LINE INDENT m . append ( abs ( b ) ) else : NEW_LINE d . append ( abs ( a ) ) NEW_LINE DEDENT d . sort ( ) NEW_LINE m . sort ( ) NEW_LINE ans = 0 NEW_LINE for x in range ( n ) : ans += dist ( d [ x ] , m [ x ] ) NEW_LINE print ( ans ) NEW_LINE for _ in range ( int ( input ( ) ) ) : solve ( ) NEW_LINE"],"bleu":0.00003394341972246152,"rouge_l":0.05580118920567159}
{"id":295,"predictions":["import sysinput = sys . stdin . readlinefrom collections import deque   class Graph ( object ) : \"\"\" docstring ▁ for ▁ Graph \"\"\" def __init__ ( self , n ) : NEW_LINE"],"references":["years = { \"2013\" , \"2014\" , \"2015\" } base = set ( ) for i in range ( 1 , 29 ) : if i < 10 : base . add ( \"0\" + str ( i ) ) else : base . add ( str ( i ) ) info1 = base . copy ( ) info1 . add ( \"29\" ) info1 . add ( \"30\" ) info2 = info1 . copy ( ) info2 . add ( \"31\" ) months = { \"02\" : base } for i in [ 4 , 6 , 9 , 11 ] : if i < 10 : months [ \"0\" + str ( i ) ] = info1 else : months [ str ( i ) ] = info1for i in [ 1 , 3 , 5 , 7 , 8 , 10 , 12 ] : k = ( \"0\" + str ( i ) ) if i < 10 else str ( i ) months [ k ] = info2   s = input ( )   def solve ( s , years , months ) : maps = { } i = 0 while i < len ( s ) - 9 : if s [ i + 2 ] != \" - \" or s [ i + 5 ] != \" - \" : i += 1 continue d , m , y = s [ i : i + 2 ] , s [ i + 3 : i + 5 ] , s [ i + 6 : i + 10 ] if y in years and m in months and d in months [ m ] : k = s [ i : i + 10 ] maps [ k ] = maps . get ( k , 0 ) + 1 i += 1 ans , count = \" \" , 0 for k , v in maps . items ( ) : if count < v : ans , count = k , v return ans             ans = solve ( s , years , months ) print ( ans ) NEW_LINE"],"bleu":0.000003896930746037575,"rouge_l":0.05553999159546155}
{"id":296,"predictions":["n , p , q = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) )   dp = [ 0 ] * nfor i in range ( n ) : p = list ( map ( int , input ( ) . split ( ) ) ) dp [ p - 1 ] = max ( p ) for i in range ( n ) : dp [ p ] = max ( p [ i - 1 ] , p [ i - 1 ] ) print ( max ( dp [ p ] , dp [ p - 1 ] ) ) NEW_LINE"],"references":["a = list ( map ( int , input ( ) . split ( ) ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) n = a [ 0 ] dp = [ [ 0 for i in range ( 4 ) ] for j in range ( n + 1 ) ] for i in range ( 4 ) : dp [ 0 ] [ i ] = ( - 10 ) ** ( 27 ) for i in range ( 1 , n + 1 ) : for j in range ( 1 , 4 ) : x = arr [ i - 1 ] * a [ j ] + dp [ i ] [ j - 1 ] y = dp [ i - 1 ] [ j ] dp [ i ] [ j ] = max ( x , y ) print ( dp [ n ] [ 3 ] ) NEW_LINE"],"bleu":0.34926712679220545,"rouge_l":0.518696173552818}
{"id":297,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) count = 0 for i in range ( 1 , n - 1 ) : if b [ i ] == 1 and a [ i + 1 ] == 1 : count += 1 print ( count ) NEW_LINE"],"references":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in range ( 1 , n - 1 ) : if ( a [ i ] == 0 and a [ i - 1 ] == 1 and a [ i + 1 ] == 1 ) : a [ i + 1 ] = 0 c += 1 print ( c ) NEW_LINE"],"bleu":0.6473632804789432,"rouge_l":0.733346472211273}
{"id":298,"predictions":["for _ in range ( int ( input ( ) ) ) : n , k = map ( int , input ( ) . split ( ) ) NEW_LINE if k == 0 : NEW_LINE INDENT print ( len ( set ( map ( int , input ( ) . split ( ) ) ) ) != 1 : NEW_LINE INDENT print ( len ( set ( set ( ) ) ) ) NEW_LINE DEDENT elif k == 1 : NEW_LINE INDENT print ( len ( set ( ) ) + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( count ) NEW_LINE DEDENT DEDENT"],"references":["R = lambda : map ( int , input ( ) . split ( ) ) NEW_LINE t , = R ( ) NEW_LINE exec ( t * ' n , k = R ( ) ; a = { * R ( ) } ; i = 0 \\n while { i } & a : i + = 1 \\n print ( n + ( k > 0 ) * ( k , i + max ( a ) + 1 > > 1not ▁ in ▁ a ) [ i < n ] ) \\n ' ) NEW_LINE"],"bleu":0.1993286506442359,"rouge_l":0.328632546347647}
{"id":299,"predictions":["import sysfrom math import gcd , sqrt , ceil , log2from collections import defaultdict , Counter , dequefrom bisect import bisect_left , bisect_rightimport mathsys . setrecursionlimit ( 2 * 10 ** 5 + 10 ) import heapqfrom itertools import permutations   NEW_LINE"],"references":["import mathn , m = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) q = list ( map ( int , input ( ) . split ( ) ) ) if m > n : print ( \"0\/1\" ) elif n > m : if ( l [ 0 ] > 0 and q [ 0 ] > 0 ) or ( l [ 0 ] < 0 and q [ 0 ] < 0 ) : print ( \" Infinity \" ) else : print ( \" - Infinity \" )           else : a = abs ( l [ 0 ] ) b = abs ( q [ 0 ] ) while math . gcd ( a , b ) > 1 : c = math . gcd ( a , b ) a = a \/\/ c b = b \/\/ c if l [ 0 ] > 0 and q [ 0 ] > 0 : print ( str ( a ) + \" \/ \" + str ( b ) ) elif l [ 0 ] < 0 and q [ 0 ] < 0 : print ( str ( a ) + \" \/ \" + str ( b ) ) else : print ( \" - \" + str ( a ) + \" \/ \" + str ( b ) )   \t \t       \t \t   NEW_LINE"],"bleu":0.00029709187557101877,"rouge_l":0.06751521859435529}
{"id":300,"predictions":["n = int ( input ( ) ) for i in range ( n ) : a = list ( map ( int , input ( ) . split ( ) ) ) l . sort ( reverse = True ) for i in range ( len ( l ) ) : if abs ( l [ i ] - l [ i + 1 ] ) > abs ( l [ i ] - l [ i ] ) : print ( abs ( l [ i ] - l [ i ] ) ) NEW_LINE"],"references":["t = int ( input ( ) )   for tc in range ( t ) : n = int ( input ( ) )   athletes = [ int ( z ) for z in input ( ) . split ( ) ]   athletes . sort ( )   res = [ ]   for i in range ( 1 , n ) : a = athletes [ : i ] b = athletes [ i : ]   res . append ( abs ( max ( a ) - min ( b ) ) )   print ( min ( res ) ) NEW_LINE"],"bleu":0.31846102691288514,"rouge_l":0.49561892623864906}
{"id":301,"predictions":["t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = 0 NEW_LINE for i in range ( n ) : if NEW_LINE j < k : NEW_LINE INDENT c += a [ j ] NEW_LINE DEDENT print ( c ) NEW_LINE"],"references":["n = int ( input ( ) ) arr = [ [ 0 , 0 ] for i in range ( n ) ]   for i in range ( n ) : arr [ i ] [ 0 ] , arr [ i ] [ 1 ] = map ( int , input ( ) . split ( ) )   NEW_LINE"],"bleu":0.27590121978422183,"rouge_l":0.377864959735701}
{"id":302,"predictions":["for _ in range ( int ( input ( ) ) ) : n , k = map ( int , input ( ) . split ( ) ) ; s = input ( ) ; print ( s + ' b ' * ( k + 1 ) \/\/ 2 ) NEW_LINE"],"references":["def binary ( data , target , low , high ) : if low > high : return high else : mid = int ( ( low + high ) \/ 2 ) if data [ mid ] <= target : return binary ( data , target , mid + 1 , high ) else : return binary ( data , target , low , mid - 1 ) for _ in range ( int ( input ( ) ) ) : a , b = map ( int , input ( ) . split ( ) ) l = [ 1 ] n = 1 for i in range ( 1 , a - 1 ) : l . append ( l [ - 1 ] + n ) n += 1 result = [ \" a \" ] * a k = binary ( l , b , 0 , len ( l ) - 1 ) k += 1 result [ a - 1 - k ] = \" b \" result [ - 1 - ( b - l [ k - 1 ] ) ] = \" b \" print ( * result , sep = \" \" )   NEW_LINE"],"bleu":0.031184018514451836,"rouge_l":0.27216565610342064}
{"id":303,"predictions":["n , t = map ( int , input ( ) . split ( ) ) l = [ ] for i in range ( n ) : a = list ( map ( int , input ( ) . split ( ) ) ) l . sort ( ) print ( l [ 1 ] [ 0 ] ) NEW_LINE"],"references":["n , t = [ int ( item ) for item in input ( ) . split ( ' ▁ ' ) ] cont , ans = [ ] , 2 for i in range ( n ) : hcenter , hlen = [ float ( item ) for item in input ( ) . split ( ' ▁ ' ) ] NEW_LINE"],"bleu":0.35089944173805887,"rouge_l":0.5467967308199313}
{"id":304,"predictions":["n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l . sort ( ) i = 1 while i < ( n ) : if ( i + 1 > n ) : breakprint ( 1 ) NEW_LINE"],"references":["n = int ( input ( ) ) x = 1 s = 1 while s <= n : x += 1 s += ( x * ( x + 1 ) ) \/\/ 2 print ( x - 1 ) NEW_LINE"],"bleu":0.21920806850322253,"rouge_l":0.4689028651292803}
{"id":305,"predictions":["def STR ( ) : return list ( input ( ) ) def INT ( ) : return int ( input ( ) ) def MAP ( ) : return map ( int , input ( ) . split ( ) ) def MAP2 ( ) : return map ( float , input ( ) . split ( ) ) def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) def STRING ( ) : return input ( ) import stringimport sysfrom heapq import heappop , heappushfrom bisect import * from collections import deque , Counter , defaultdictfrom math import * from itertools import permutations , accumulatedx = [ - 1 , 1 , 0 , 0 ] dy = [ 0 , 0 , 1 , - 1 ] NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) adj = [ [ ] for i in range ( n ) ] used = [ 0 for i in range ( n ) ] mark = [ 0 for i in range ( n ) ] S = [ i for i in range ( n ) ]   for i in range ( m ) : u , v = map ( int , input ( ) . split ( ) ) u , v = u - 1 , v - 1 adj [ u ] . append ( v ) adj [ v ] . append ( u ) def dfs ( v ) : global S used [ v ] = 1 S2 , S3 = [ ] , [ ] for to in adj [ v ] : mark [ to ] = 1 for to in S : if mark [ to ] == 0 : S3 . append ( to ) else : S2 . append ( to ) for to in adj [ v ] : mark [ to ] = 0 S = S2 . copy ( ) for to in S3 : dfs ( to ) ans = - 1 for i in range ( n ) : if not used [ i ] : S . remove ( i ) ans += 1 dfs ( i )   print ( ans ) NEW_LINE"],"bleu":0.11184633340062378,"rouge_l":0.2568727157158748}
{"id":306,"predictions":["def max_sum ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for n in range ( 10 ) : NEW_LINE INDENT if n > 10 : NEW_LINE INDENT ans = max ( ans , n \/\/ 10 ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT print ( solve ( n ) ) NEW_LINE"],"references":["def pod ( n ) : ans = 1 while n > 0 : ans *= ( n % 10 ) n = n \/\/ 10 return ansn = input ( ) ans = ( len ( n ) - 1 ) * 9 ans = max ( ans , pod ( int ( n ) ) ) sz = len ( n ) for i in range ( 1 , sz ) : ind = sz - i num = n [ : ind ] + '9' * ( sz - ind ) if int ( num ) > int ( n ) : if num [ ind - 1 ] == '0' : num = num [ : ind - 1 ] + '9' + num [ ind : ] else : num = num [ : ind - 1 ] + str ( int ( num [ ind - 1 ] ) - 1 ) + num [ ind : ] if int ( num ) <= int ( n ) : ans = max ( ans , pod ( int ( num ) ) ) print ( ans ) NEW_LINE"],"bleu":0.021716962403617,"rouge_l":0.2049436045116391}
{"id":307,"predictions":["n , m = map ( int , input ( ) . split ( ) ) i = 0 while i < n and ( i < n ) : if ( 8 == n ) : ans = 9 else : if ( i != n and ( i != n ) ) : ans = ans + 1 print ( ans ) NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) a = '9' * 200 + '0' * 199 + '1' b = '9' * 200 print ( a ) print ( b ) NEW_LINE"],"bleu":0.27455024338805617,"rouge_l":0.47210577233150586}
{"id":308,"predictions":["from math import gcd , floor NEW_LINE def main ( ) : NEW_LINE INDENT d = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( \" ▁ \" ) ) ) NEW_LINE abc = [ gcd ( a , b ) for i in range ( 100001 ) ] NEW_LINE a , b = map ( int , input ( ) . split ( ) ) NEW_LINE abc = gcd ( a , b ) NEW_LINE abc = gcd ( a , b ) NEW_LINE a , b = d [ b ] , abc = gcd ( a , b ) NEW_LINE c = d [ gcd ( a , b ) for i in range ( 3 ) ] NEW_LINE left = d [ gcd ( a , b ) ] NEW_LINE right = d [ gcd ( a , b + 1 ) ] * ( b - a + c ) NEW_LINE left = d [ gcd ( a , b + c ) ] = d [ gcd ( a , c ) NEW_LINE if left > right : NEW_LINE INDENT right = left NEW_LINE DEDENT else : NEW_LINE INDENT left = a [ gcd ( a , b ) ] NEW_LINE right = d [ gcd ( a , b ) ] NEW_LINE DEDENT d = left [ gcd ( a , b ) for i in range ( 1 , 1001 + 1 ) : NEW_LINE INDENT if ( ( a , b ) * ( b + c ) + ( b * ( b + c ) ) : NEW_LINE INDENT leftc = right + ( ( a + b + c ) * ( b + c + d ) ) * ( b + ( b + c * d ) + ( b + c ) * ( b + c ) ) NEW_LINE DEDENT else : NEW_LINE INDENT left = mid - left NEW_LINE right = left - ( abs ( a + b * c ) - ( b + c ) * d + ( b + c ) * d + ( ( d + left ) ** 2 + ( b * ( b + c ) ** 2 + d + ( b + c ) ** 2 + ( b + c ) ** 2 ) NEW_LINE DEDENT DEDENT return ( \" % d"],"references":["from sys import stdinfrom math import gcd     def main ( ) : input ( ) l = stdin . read ( ) . splitlines ( ) d = [ 3. , 1. , 2. , 2. , 2. , 1. ] * 16667 for i in range ( 4 , 100001 ) : for j in range ( i , 100001 , i ) : d [ j ] += 1. for i , s in enumerate ( l ) : a , b , c = map ( int , s . split ( ) ) k = gcd ( b , c ) ab = d [ gcd ( a , b ) ] ac = d [ gcd ( a , c ) ] bc = d [ k ] abc = d [ gcd ( a , k ) ] asz = d [ a ] - ab - ac + abc bsz = d [ b ] - bc - ab + abc csz = d [ c ] - ac - bc + abc absz = ab - abc bcsz = bc - abc acsz = ac - abc l [ i ] = ' % d ' % ( asz * bsz * csz + ( absz * ( asz + bsz ) * csz ) + ( bcsz * ( bsz + csz ) * asz ) + ( acsz * ( asz + csz ) * bsz ) + ( abc * ( asz * bsz + asz * csz + bsz * csz ) ) + ( abc * ( absz + bcsz + acsz ) * ( asz + bsz + csz ) ) + ( ( asz + bsz + csz + absz + bcsz + acsz ) * ( abc * ( abc + 1 ) * .5 ) ) + ( absz * bcsz * acsz ) + ( ( absz * ( absz + 1. ) * d [ c ] ) + ( bcsz * ( bcsz + 1. ) * d [ a ] ) + ( acsz * ( acsz + 1. ) * d [ b ] ) ) * .5 + ( ( asz + bsz + csz + abc ) * ( absz * acsz + absz * bcsz + bcsz * acsz ) ) + ( abc + ( abc * ( abc - 1. ) ) + ( abc * ( abc - 1. ) * ( abc - 2. ) \/ 6. ) ) ) print ( ' \\n ' . join ( map ( str , l ) ) )     if __name__ == ' _ _ main _ _ ' : main ( )         NEW_LINE"],"bleu":0.18397510516345528,"rouge_l":0.39213165338133193}
{"id":309,"predictions":["n = int ( input ( ) ) print ( pow ( n - 2 ) + 1 ) NEW_LINE"],"references":["m = [ ] for _ in range ( int ( input ( ) ) ) : l = list ( map ( int , input ( ) . split ( ) ) ) x = sum ( l ) m . append ( x ) j = sorted ( m , reverse = True ) NEW_LINE"],"bleu":0.05275385561512055,"rouge_l":0.286833855799373}
{"id":310,"predictions":["n , m = map ( int , input ( ) . split ( ) ) arr = sorted ( list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n - 1 ) : count = 0 for j in range ( len ( arr ) ) : if arr [ i ] [ j ] == '1' : count += 1   print ( \" YES \" ) NEW_LINE"],"references":["from sys import stdin , stdoutfrom itertools import accumulatenmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"bleu":0.2248153019606726,"rouge_l":0.49437908496732014}
{"id":311,"predictions":["arr = list ( map ( int , input ( ) . split ( ) ) ) n = arr [ 0 ] m = arr [ 1 ] k = ( 10 ** 9 ) + 7 print ( pow ( 2 ** m - 1 , n , k ) ) NEW_LINE"],"references":["import sysimport itertoolsimport collections   n = int ( input ( ) ) A = [ int ( x ) for x in input ( ) . split ( ) ] perms = [ ]   def bits ( lst ) : a = [ ] for val in lst : s = [ ] for shift in range ( 29 , - 1 , - 1 ) : s += [ str ( val >> shift & 1 ) ] a += [ ' ' . join ( s [ : : - 1 ] ) ] return a   def calcCost ( perm ) : f = lambda a , b : ( ( a | b ) - b ) a = f ( perm [ 0 ] , perm [ 1 ] ) for i in range ( 2 , len ( perm ) ) : a = f ( a , perm [ i ] ) return a   def bruteForce ( ) : global perms for perm in list ( itertools . permutations ( A ) ) : perms += [ ( perm , calcCost ( perm ) ) ] print ( * perms , sep = \" \\n \" )   NEW_LINE"],"bleu":0.016536020424661742,"rouge_l":0.20622041920216364}
{"id":312,"predictions":["from collections import defaultdictfor _ in range ( int ( input ( ) ) ) : q = list ( map ( int , input ( ) . split ( ) ) ) d = [ ' E ' , ' E ' , ' A ' ] for i in range ( q ) : d [ x ] = list ( d [ x ] ) - ord ( ' A ' ) if ord ( d [ x ] ) > ord ( ' S ' ) and d [ x ] [ x ] == 0 : d [ x ] = abs ( s [ x ] ) - ord ( ' A ' ) + 1 c = 0 for i in range ( len ( d ) ) : if ord ( d [ i ] ) - ord ( ' A ' ) != ord ( d [ i ] ) - ord ( ' A ' ) and d [ ord ( s [ i ] ) - ord ( ' A ' ) ] += 1 if c < 0 and d [ ord ( x ) - ord ( ' A ' ) - ord ( ' A ' ) ] [ 0 ] -= 1 d [ x ] [ 0 ] -= 1 NEW_LINE"],"references":["t , sx , sy , ex , ey = map ( int , input ( ) . split ( ) ) winds = list ( input ( ) ) def dist ( x , y ) : return abs ( x - ex ) + abs ( y - ey ) for zzz in range ( t ) : new_x , new_y = sx , sy if ( winds [ zzz ] == ' N ' ) : new_y += 1 if ( winds [ zzz ] == ' S ' ) : new_y -= 1 if ( winds [ zzz ] == ' E ' ) : new_x += 1 if ( winds [ zzz ] == ' W ' ) : new_x -= 1 if ( dist ( new_x , new_y ) < dist ( sx , sy ) ) : sx = new_x sy = new_y if ( sx == ex and sy == ey ) : if ( zzz + 1 <= t ) : print ( zzz + 1 ) breakelse : print ( - 1 ) NEW_LINE"],"bleu":0.1468895696507618,"rouge_l":0.3372631921294414}
{"id":313,"predictions":["n = int ( input ( ) ) l = [ ] for i in range ( n ) : a , b = map ( int , input ( ) . split ( ) ) l . append ( a , b ) print ( p ) NEW_LINE"],"references":["days = int ( input ( ) ) dailyReq = [ ] dailyPrice = [ ] totalCost = 0 for day in range ( days ) : a , p = input ( ) . split ( ) dailyReq . append ( int ( a ) ) dailyPrice . append ( int ( p ) )   minPrice = dailyPrice [ 0 ] for day in range ( days ) : if ( dailyPrice [ day ] < minPrice ) : minPrice = dailyPrice [ day ] totalCost += dailyReq [ day ] * minPrice   print ( totalCost )   NEW_LINE"],"bleu":0.15798782212277912,"rouge_l":0.4359812129875434}
{"id":314,"predictions":["n = int ( input ( ) ) s = input ( ) ans = 0 for i in range ( len ( s ) - 1 ) : if s [ i ] == s [ i ] : ans = 1 else : for j in range ( 2 * j , n + 1 ) : if s [ j ] == s [ i ] : ans = min ( ans , n - 2 * j ) print ( ans ) NEW_LINE"],"references":["import sysimport mathfrom collections import defaultdict , dequeimport heapqs = sys . stdin . readline ( ) [ : - 1 ] ans = 0 n = len ( s ) mink = nfor i in range ( n - 1 , - 1 , - 1 ) : k = 1 z = True while i + 2 * k < n and z : if s [ i ] == s [ i + k ] == s [ i + 2 * k ] : z = False continue k += 1 if not z : mink = min ( mink , i + 2 * k ) NEW_LINE"],"bleu":0.2367640261429904,"rouge_l":0.3931045593684549}
{"id":315,"predictions":["from sys import stdin , stdoutfrom os import pathrd = lambda : stdin . readline ( ) . strip ( ) wr = stdout . writeif ( path . exists ( ' input . txt ' ) ) : stdin = open ( \" input . txt \" , \" r \" ) import time , math NEW_LINE"],"references":["c = 0 def backtracking ( actuales , restantes , l , r , x ) : global c if sum ( actuales ) <= r and sum ( actuales ) >= l : if max ( actuales ) - min ( actuales ) >= x : c += 1 if restantes : for i in range ( len ( restantes ) ) : backtracking ( actuales + [ restantes [ i ] ] , restantes [ i + 1 : ] , l , r , x ) return 0 def main ( ) : n , l , r , x = input ( ) . split ( \" ▁ \" ) n , l , r , x = int ( n ) , int ( l ) , int ( r ) , int ( x ) difficulties = input ( ) . split ( \" ▁ \" ) for i in range ( len ( difficulties ) ) : difficulties [ i ] = int ( difficulties [ i ] ) difficulties . sort ( ) backtracking ( [ ] , difficulties , l , r , x ) global c return c if __name__ == \" _ _ main _ _ \" : print ( main ( ) ) NEW_LINE"],"bleu":0.0059111139406622035,"rouge_l":0.1520702362887492}
{"id":316,"predictions":["import math   def main ( ) : n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( 1 , n + 1 ) : if a [ i ] == a [ i ] : a [ i + 1 ] = a [ i ] + 1 else : a [ i ] = a [ i - 1 ] + 1   print ( a ) NEW_LINE"],"references":["n = int ( input ( ) ) NEW_LINE start , end = 0 , 0 NEW_LINE flag = 0 l NEW_LINE s = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( 1 , ( n + 1 ) ) : if NEW_LINE ls [ i - 1 ] != i : start = i NEW_LINE breakfor NEW_LINE j in range ( n , i - 1 , - 1 ) : NEW_LINE if ls [ j - 1 ] != j : end = j NEW_LINE breakif NEW_LINE start == 0 and end == 0 : flag = 1 NEW_LINE print ( \"0 ▁ 0\" ) else : for i in range ( start - 1 , end - 1 ) : if NEW_LINE ls [ i ] < ls [ i + 1 ] : print ( \"0 ▁ 0\" ) NEW_LINE flag = 1 NEW_LINE breakif NEW_LINE flag == 0 : print ( str ( start ) + \" ▁ \" + str ( end ) ) NEW_LINE"],"bleu":0.16993438785653908,"rouge_l":0.4193148523777327}
{"id":317,"predictions":["n , m , x = map ( int , input ( ) . split ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) )   f = [ 0 ] * mfor i in range ( n ) : if arr [ i ] [ 0 ] >= arr [ i - 1 ] [ 1 ] : f = max ( 0 , arr [ i ] [ 1 ] + arr [ i ] [ 1 ] ) print ( f ) NEW_LINE"],"references":["n , m , x , y = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) outputs , l = [ ] , 0 for i in range ( n ) : minm = max ( 1 , a [ i ] - x ) while l < m and b [ l ] < minm : l += 1 if l < m and b [ l ] <= a [ i ] + y : outputs . append ( f ' { i + 1 } ▁ { l + 1 } ' ) l += 1 print ( len ( outputs ) ) for output in outputs : print ( output )   NEW_LINE"],"bleu":0.25557827793026605,"rouge_l":0.4892230576441103}
{"id":318,"predictions":["n , m = map ( int , input ( ) . split ( ) ) grid = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] ans = [ ] for i in range ( m ) : row . append ( input ( ) ) for i in range ( n ) : for j in range ( m ) : if grid [ i ] [ j ] == ' S ' : for row in range ( m ) : NEW_LINE"],"references":["import sys   window = set ( )   n , k , q = [ int ( x ) for x in input ( ) . split ( ) ] arr = [ int ( x ) for x in input ( ) . split ( ) ]   for i in range ( q ) : a , b = [ int ( x ) for x in input ( ) . split ( ) ] if ( a == 1 ) : if ( len ( window ) < k ) : window . add ( arr [ b - 1 ] ) else : window . add ( arr [ b - 1 ] ) m = min ( window ) window . remove ( m ) else : print ( \" YES \" if arr [ b - 1 ] in window else \" NO \" ) NEW_LINE"],"bleu":0.16484065693397926,"rouge_l":0.3884865134865135}
{"id":319,"predictions":["import sys , os , ioimport math , bisect , operatorinf , mod = float ( ' inf ' ) , 10 ** 9 + 7 NEW_LINE"],"references":["n = int ( input ( ) ) x = int ( input ( ) ) a = [ 0 ] * 3 a [ x ] = 1 for i in range ( n % 6 + 1 , 7 ) : if i % 2 == 1 : a [ 0 ] , a [ 1 ] = a [ 1 ] , a [ 0 ] else : a [ 1 ] , a [ 2 ] = a [ 2 ] , a [ 1 ] for i in range ( 3 ) : if a [ i ] == 1 : print ( i ) NEW_LINE"],"bleu":0.003131829678397529,"rouge_l":0.10447441661314494}
{"id":320,"predictions":["n , m = map ( int , input ( ) . split ( ) ) ans = 0 for i in range ( n ) : groupn = list ( map ( int , input ( ) . split ( ) ) ) if ( groupn ( m ) > m ) : ans += 1   print ( ans ) NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) current , ans = 0 , 1 for x in a : if current + x <= m : current += x else : current = x ans += 1   print ( ans ) NEW_LINE"],"bleu":0.5751601513911506,"rouge_l":0.6612466124661246}
{"id":321,"predictions":["first = input ( ) second = input ( ) lo = 0 a , hi = len ( a ) if lo == 1 : print ( ' YES ' ) else : print ( ' NO ' ) NEW_LINE"],"references":["s = input ( ) s1 = s [ : len ( s ) \/\/ 2 ] if len ( s ) % 2 == 0 : s2 = s [ len ( s ) \/\/ 2 : ] else : s2 = s [ len ( s ) \/\/ 2 + 1 : ]   s2 = s2 [ - 1 : : - 1 ] NEW_LINE"],"bleu":0.07457643719326838,"rouge_l":0.33371724733659663}
{"id":322,"predictions":["import sysfrom NEW_LINE os NEW_LINE import pathif NEW_LINE ( path . exists ( ' input . txt ' ) ) : sys . stdout = open ( ' output . txt ' , ' w ' ) NEW_LINE sys . stdout = open ( ' input . txt ' , ' r ' ) NEW_LINE"],"references":["for _ in range ( int ( input ( ) ) ) : S = input ( ) if S . count ( \"1\" ) == 0 : print ( 0 ) else : A = S [ S . index ( \"1\" ) : S . rfind ( \"1\" ) + 1 ] print ( A . count ( \"0\" ) ) NEW_LINE"],"bleu":0.05471286296498626,"rouge_l":0.24870888828485999}
{"id":323,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["import itertools as it   def powerset ( iterable ) : \" powerset ( [1,2,3 ] ) ▁ - - > ▁ ( ) ▁ ( 1 , ) ▁ ( 2 , ) ▁ ( 3 , ) ▁ ( 1,2 ) ▁ ( 1,3 ) ▁ ( 2,3 ) ▁ ( 1,2,3 ) \" s = list ( iterable ) return it . chain . from_iterable ( it . combinations ( s , r )   \\ for r in range ( len ( s ) + 1 ) )     n , k , A = map ( int , input ( ) . split ( ) )   best_result = 0   missing = 0   senators = [ ] for _ in range ( n ) : level , loyality = map ( int , input ( ) . split ( ) ) senators += [ [ level , loyality ] ] missing += 10 - loyality \/\/ 10   k = min ( [ k , missing ] ) NEW_LINE"],"bleu":0.026336211764121674,"rouge_l":0.22524066991955688}
{"id":324,"predictions":["import mathn , c = map ( int , input ( ) . split ( ) ) x = list ( map ( int , input ( ) . split ( ) ) ) y = list ( map ( int , input ( ) . split ( ) ) ) ) v = [ 0 ] * nfor i in range ( n ) : v [ i ] = abs ( v [ i ] [ 0 ] - v [ i - 1 ] [ 1 ] ) ) y = abs ( v [ i ] [ 1 ] - v [ i ] [ 1 ] ) for i in range ( n ) : v = abs ( v [ i ] [ 0 ] - v [ i - 1 ] [ 1 ] ) if abs ( v [ i ] [ 1 ] - v [ i - 1 ] [ 1 ] ) > abs ( v [ i ] [ 1 ] - v [ 1 ] [ 0 ] ) else : v = abs ( v [ i ] [ 1 ] - v [ i ] [ 1 ] ) t = abs ( v [ i ] [ 1 ] - v [ i ] [ 1 ] ) ) print ( \" \\n \" . join ( map ( str , input ( ) . split ( ) ) ) ) NEW_LINE"],"references":["PI = 3.141592653589793 n , a , b = map ( int , input ( ) . split ( ) ) arr , res = [ ] , [ ] for _ in range ( n ) : u , v = input ( ) . split ( ) arr . append ( ( int ( u ) - a , int ( v ) - b ) ) x0 , y0 = arr [ - 1 ] for x1 , y1 in arr : res . append ( x1 * x1 + y1 * y1 ) dx , dy = x1 - x0 , y1 - y0 if ( x0 * dx + y0 * dy ) * ( x1 * dx + y1 * dy ) < 0 : x0 = x0 * y1 - x1 * y0 res . append ( ( x0 * x0 ) \/ ( dx * dx + dy * dy ) ) x0 , y0 = x1 , y1print ( ( max ( res ) - min ( res ) ) * PI ) NEW_LINE"],"bleu":0.13623558530490257,"rouge_l":0.3243665936815765}
{"id":325,"predictions":["n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( 0 , n - k ) : if a [ i ] >= k and a [ i + 1 ] > 0 : print ( n - i ) break NEW_LINE"],"references":["n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in a : if i > 0 and i >= a [ k - 1 ] : c = c + 1 print ( c ) NEW_LINE"],"bleu":0.5707544121980089,"rouge_l":0.7308068459657702}
{"id":326,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 0 ) : NEW_LINE"],"references":["holes , water_have , water_plant = map ( int , input ( ) . split ( ) ) hole_ratio = list ( map ( int , input ( ) . split ( ) ) ) plant_A = hole_ratio [ 0 ] hole_ratio = hole_ratio [ 1 : ] hole_ratio . sort ( ) hole_ratio . reverse ( ) blocked = 0 sum_non_blocked = sum ( hole_ratio ) + plant_A   for each in hole_ratio : if ( water_have * plant_A \/ sum_non_blocked >= water_plant ) : break sum_non_blocked -= each blocked += 1 print ( blocked )   NEW_LINE"],"bleu":0.11558803940420212,"rouge_l":0.37328550327073223}
{"id":327,"predictions":["for _ in range ( int ( input ( ) ) ) : a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE if b % 3 == 0 : NEW_LINE INDENT a += 1 NEW_LINE DEDENT elif b % 3 == 1 : NEW_LINE INDENT a += 1 NEW_LINE b -= e NEW_LINE DEDENT else : NEW_LINE INDENT b += e NEW_LINE DEDENT DEDENT print ( b ) NEW_LINE"],"references":["''' a = [ int ( i ) ▁ for ▁ i ▁ in ▁ input ( ) . split ( ) ] x = a [ 0 ] y = a [ 1 ] z = a [ 2 ] if ▁ y = = x ▁ and ▁ z = = 0 : ▁ ▁ ▁ ▁ print ( '0 ' ) elif ▁ x > y + z : ▁ ▁ ▁ ▁ print ( ' + ' ) elif ▁ y > x + z : ▁ ▁ ▁ ▁ print ( ' - ' ) else : ▁ ▁ ▁ ▁ print ( ' ? ' ) n = int ( input ( ) ) z = [ int ( i ) ▁ for ▁ i ▁ in ▁ input ( ) . split ( ) ] x = [ ] d = 0v = ' ' for ▁ i ▁ in ▁ range ( n ) : ▁ ▁ ▁ ▁ c = 0 ▁ ▁ ▁ ▁ e = 0 ▁ ▁ ▁ ▁ for ▁ f ▁ in ▁ range ( len ( z ) ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ z [ f ] > c ▁ and ▁ f + 1 ▁ not ▁ in ▁ x : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ c = z [ f ] ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ e = f + 1 ▁ ▁ ▁ ▁ d + = ( i * c ) + 1 ▁ ▁ ▁ ▁ x . append ( e ) print ( d ) for ▁ i ▁ in ▁ x : ▁ ▁ ▁ ▁ v + = str ( i ) ▁ ▁ ▁ ▁ v + = ' ▁ ' print ( v )  f = int ( input ( ) ) g = [ int ( i ) ▁ for ▁ i ▁ in ▁ input ( ) . split ( ) ] for ▁ i ▁ in ▁ range ( len ( g ) -1 ) : ▁ ▁ ▁ ▁ for ▁ f ▁ in ▁ range ( len ( g ) -1 - i ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ g [ f ] > g [ f + 1 ] : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ g [ f ] , g [ f + 1 ] = g [ f + 1 ] , g [ f ] if ▁ g [ 0 ] * g [ 1 ] > g [ -2 ] * g [ -3 ] ▁ and ▁ g [ -1 ] > 0 : ▁ ▁ ▁ ▁ print ( g [ -1 ] * g [ 0 ] * g [ 1 ] ) else : ▁ ▁ ▁ ▁ print ( g [ -1 ] * g [ -2 ] * g [ -3 ] ) for ▁ u ▁ in ▁ range ( int ( input ( ) ) ) : ▁ ▁ ▁ ▁ z = int ( input ( ) ) ▁ ▁ ▁ ▁ y = [ int ( f ) ▁ for ▁ f ▁ in ▁ input ( ) . split ( ) ] ▁ ▁ ▁ ▁ y . sort ( ) ▁ ▁ ▁ ▁ d = 0 ▁ ▁ ▁ ▁ for ▁ i ▁ in ▁ y : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ d + = i ▁ ▁ ▁ ▁ if ▁ d < 2048 : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( ' No ' ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ continue ▁ ▁ ▁ ▁ if ▁ 2048 ▁ in ▁ y : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( ' yes ' ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ continue ▁ ▁ ▁ ▁ for ▁ x ▁ in ▁ range ( z + 1 ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ 2048 ▁ in ▁ y : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( ' yes ' ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ break ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ for ▁ i ▁ in ▁ range ( len ( y ) -1 ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ y [ i ] = = y [ i + 1 ] : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ y [ i + 1 ] = y [ i ] *2 ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ y . pop ( i ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ i > len ( y ) -3 : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ break ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ y . sort ( ) ▁ ▁ ▁ ▁ else : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( ' no ' ) n = int ( input ( ) ) x = [ ] for ▁ i ▁ in ▁ range ( 1 , ( ( n * *2 ) \/ \/2 ) + 1 ) : ▁ ▁ ▁ ▁ x . append ( n * *2 + 1 - i ) ▁ ▁ ▁ ▁ x . append ( i ) ▁ ▁ ▁ ▁ if ▁ len ( x ) = = n : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( * x ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ x = [ ] ''' for z in range ( int ( input ( ) ) ) : z = int ( input ( ) ) x = [ int ( i ) for i in input ( ) . split ( ) ] f = 0 o = 0 t = 0 for i in range ( z ) : if x [ i ] % 3 == 0 : f += 1 elif x [ i ] % 3 == 1 : o += 1 else : t += 1 if o < t : print ( f + o + ( t - o ) \/\/ 3 ) else : print ( f + t + ( o - t ) \/\/ 3 ) NEW_LINE"],"bleu":5.399182118736668e-7,"rouge_l":0.06948738812042311}
{"id":328,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for i in range ( 1 ) : NEW_LINE"],"references":["import heapqn = int ( input ( ) ) p = list ( map ( int , input ( ) . split ( ) ) ) f = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) m = int ( input ( ) ) choice = list ( map ( int , input ( ) . split ( ) ) ) dic = { } dic [ 1 ] = [ ] dic [ 2 ] = [ ] dic [ 3 ] = [ ] pdic = { }   for i in range ( n ) : pdic [ p [ i ] ] = 0 dic [ f [ i ] ] . append ( p [ i ] ) dic [ b [ i ] ] . append ( p [ i ] ) heapq . heapify ( dic [ 1 ] ) heapq . heapify ( dic [ 2 ] ) heapq . heapify ( dic [ 3 ] ) for i in range ( m ) : try : z = heapq . heappop ( dic [ choice [ i ] ] ) while pdic [ z ] != 0 : z = heapq . heappop ( dic [ choice [ i ] ] ) pdic [ z ] = 1 print ( z , end = ' ▁ ' ) except : print ( - 1 , end = ' ▁ ' )                   NEW_LINE"],"bleu":0.004226756069362455,"rouge_l":0.18310232188575964}
{"id":329,"predictions":["for t in range ( int ( input ( ) ) ) : listc = input ( ) NEW_LINE x = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = 0 NEW_LINE while 1 : NEW_LINE INDENT if x [ 0 ] not in x : NEW_LINE INDENT x += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE"],"references":["n = int ( input ( ) ) arr = [ ] ans = 0 for i in range ( n ) : s = input ( ) if s not in arr : arr . append ( s ) ans += 1 print ( ans ) NEW_LINE"],"bleu":0.18403484250072136,"rouge_l":0.4092765460910152}
{"id":330,"predictions":["n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) )   b = list ( map ( int , input ( ) . split ( ) ) )   if k == 1 : print ( \" Yes \" ) else : print ( \" No \" ) NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) ab = list ( map ( int , input ( ) . split ( ) ) ) ab . sort ( reverse = True ) for i in range ( n ) : if arr [ i ] == 0 : arr [ i ] = ab . pop ( 0 )   if arr == sorted ( arr ) : print ( \" NO \" ) else : print ( \" YES \" ) NEW_LINE"],"bleu":0.4335370044933467,"rouge_l":0.6820405310971349}
{"id":331,"predictions":["n , m , t = map ( int , input ( ) . split ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) : if arr [ i ] != arr [ t ] : arr [ i ] = arr [ i - 1 ] + n   print ( n ) NEW_LINE"],"references":["a , b = input ( ) . split ( ) print ( int ( a ) + int ( str ( b ) [ : : - 1 ] ) ) NEW_LINE"],"bleu":0.1499164923496917,"rouge_l":0.46564885496183206}
{"id":332,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) [ : : - 1 ] x = sum ( a ) y = 0 for i in range ( n ) : if x [ i ] != '7' : y = x [ i ] + y [ i + 1 ] if x [ i ] == '7' : x = False NEW_LINE"],"references":["n = int ( input ( ) ) t = list ( input ( ) ) A = 0 B = 0 r = 1 for i in t : if int ( i ) != 7 and int ( i ) != 4 : r = 0 if r > 0 : i = ( int ( n \/ 2 ) ) - 1 j = int ( n \/ 2 )   while i >= 0 : A = A + int ( t [ i ] ) B = B + int ( t [ j ] ) i -= 1 j += 1 if r == 1 and A == B : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.11892097368204041,"rouge_l":0.36196410028185727}
{"id":333,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) t = [ 0 ] * ( max ( a ) + 1 ) for i in range ( 1 , n + 1 ) : t [ i ] = max ( t [ i ] , a [ i - 1 ] ) + 1 print ( * ans ) NEW_LINE"],"references":["l , s , l = input ( ) , ' ' , list ( map ( int , input ( ) . split ( ) ) ) for i in range ( len ( l ) ) : if l [ i ] != 0 : if ( len ( s ) < 2 or s [ - 1 ] == ' R ' ) and l [ i ] == 1 : s += ' PR ' else : if i != 0 : s += ' PLR ' * l [ i ] else : s += ' PRL ' * l [ i ] s += ' R ' else : s += ' R ' print ( s [ : - 1 ] ) NEW_LINE"],"bleu":0.1954773644974454,"rouge_l":0.37722473604826545}
{"id":334,"predictions":["n = int ( input ( ) ) check = [ int ( x ) for x in input ( ) . split ( ' ▁ ' ) ] check = [ int ( x ) for x in input ( ) . split ( ' ▁ ' ) ] check = [ int ( x ) for x in input ( ) . split ( ' ▁ ' ) ] for i in range ( n ) : check . append ( check [ i ] )   print ( \" YES \" ) NEW_LINE"],"references":["s = input ( ) print ( s + s [ : : - 1 ] ) NEW_LINE"],"bleu":0.0421646718821215,"rouge_l":0.20013123359580048}
{"id":335,"predictions":["def gcd ( a , b ) : NEW_LINE INDENT if b == 1 : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE t = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if t [ i ] == 1 : NEW_LINE INDENT t = t * ( i + 1 ) NEW_LINE break NEW_LINE DEDENT DEDENT print ( t ) NEW_LINE"],"references":["import math NEW_LINE def simply ( a , b ) : NEW_LINE INDENT g = math . gcd ( a , b ) NEW_LINE a = a \/\/ g NEW_LINE b = b \/\/ g NEW_LINE return ( a , b ) NEW_LINE DEDENT def mul ( a , b , c , d ) : NEW_LINE INDENT return simply ( a * c , b * d ) NEW_LINE DEDENT def add ( a , b , c , d ) : NEW_LINE INDENT return simply ( a * d + b * c , b * d ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE nxt = 0 NEW_LINE depth = 0 NEW_LINE node = 1 NEW_LINE total_node = 1 NEW_LINE p = 0 NEW_LINE q = 1 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT depth = depth + 1 NEW_LINE n = n \/\/ 2 NEW_LINE DEDENT nxt = depth NEW_LINE if ( n == 1 ) : NEW_LINE INDENT print ( str ( depth ) + \" \/ 1\" ) NEW_LINE return NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT node = node * 2 NEW_LINE total_node = total_node * 2 NEW_LINE depth = depth + 1 NEW_LINE p = p * 2 NEW_LINE q = q * 2 NEW_LINE if ( node >= n ) : NEW_LINE INDENT p = p + n * depth NEW_LINE node -= n NEW_LINE DEDENT if ( node == 1 ) : NEW_LINE INDENT nxt = depth - nxt NEW_LINE break NEW_LINE DEDENT DEDENT p , q = mul ( p , q , total_node , total_node - 1 ) NEW_LINE s , t = ( total_node - 1 ) * nxt * total_node * total_node , total_node * total_node * ( total_node - 1 ) * ( total_node - 1 ) NEW_LINE s , t = simply ( s , t ) NEW_LINE x , y = add ( p , q , s , t ) NEW_LINE print ( str ( x ) + \" \/ \" + str ( y ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"bleu":0.01456778092990326,"rouge_l":0.24978285147040574}
{"id":336,"predictions":["def STR ( ) : return list ( input ( ) ) def INT ( ) : return int ( input ( ) ) def MAP ( ) : return map ( int , input ( ) . split ( ) ) def MAP2 ( ) : return map ( float , input ( ) . split ( ) ) def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) def STRING ( ) : return input ( ) import stringimport sysfrom heapq import heappop , heappushfrom bisect import * from collections import deque , Counter , defaultdictfrom math import * from itertools import permutations , accumulatedx = [ - 1 , 1 , 0 , 0 ] dy = [ 0 , 0 , 1 , - 1 ] NEW_LINE"],"references":["from collections import defaultdict , deque , Counterfrom sys import stdin , stdoutfrom heapq import heappush , heappopimport mathimport ioimport osimport mathimport bisect   NEW_LINE"],"bleu":0.02431023328217102,"rouge_l":0.12337078651685393}
{"id":337,"predictions":["n , m = map ( int , input ( ) . split ( ) ) cells = 0 for i in range ( n ) : cells = 0   for i in range ( m ) : l , r = input ( ) . split ( ) if l == 1 : print ( 0 ) exit ( )   for i in range ( 0 , n - 1 ) : for j in range ( 0 , ( 0 , - 1 ) ) : if l [ i ] [ j ] == ' . ' : rows [ i ] [ j ] = rows [ i ] [ j ] = 0 NEW_LINE"],"references":["num = int ( input ( ) ) s = input ( ) s1 = s . count ( '1' ) s0 = s . count ( '0' ) output = abs ( s1 - s0 ) print ( output ) NEW_LINE"],"bleu":0.05805812224273726,"rouge_l":0.2957901697156712}
{"id":338,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["t = int ( input ( ) ) for _ in range ( t ) : n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) p = list ( map ( int , input ( ) . split ( ) ) ) p = set ( p ) while ( 1 ) : f = 0 for i in range ( n - 1 ) : if a [ i ] > a [ i + 1 ] and i + 1 in p : a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i ] f = 1 if not f : break if a == sorted ( a ) : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.03991588309635344,"rouge_l":0.27715462161010934}
{"id":339,"predictions":["n = int ( input ( ) ) x = list ( map ( int , input ( ) . split ( ) ) ) m = min ( x ) l = mc = 0 a = x [ 0 ] d = x [ 0 ] flag = 0 for i in range ( 1 , n - 1 ) : if x [ i ] == 0 : m = min ( m , x [ i - 1 ] ) break elif x [ i ] == 1 : m = min ( m , x [ i - 1 ] ) - x [ i ] = x [ i - 1 ] break elif x [ i ] > a [ i ] : m = min ( m , x [ i - 1 ] ) c = mprint ( c ) NEW_LINE"],"references":["import sysinput = sys . stdin . readline   n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) adj = [ [ ] for i in range ( n ) ] for i in range ( n - 1 ) : u , v , w = map ( int , input ( ) . split ( ) ) u -= 1 v -= 1 adj [ u ] . append ( ( v , w ) ) adj [ v ] . append ( ( u , w ) ) best = [ 0 ] * nans = 0   def dfs ( u ) : stack = list ( ) visit = [ False ] * n stack . append ( ( u , - 1 ) ) while stack : u , par = stack [ - 1 ] if not visit [ u ] : visit [ u ] = True for v , w in adj [ u ] : if v != par : stack . append ( ( v , u ) ) else : cand = [ ] for v , w in adj [ u ] : if v != par : cand . append ( best [ v ] + a [ v ] - w ) cand . sort ( reverse = True ) cur = a [ u ] for i in range ( 2 ) : if i < len ( cand ) and cand [ i ] > 0 : cur += cand [ i ] global ans ans = max ( ans , cur ) best [ u ] = cand [ 0 ] if len ( cand ) > 0 and cand [ 0 ] > 0 else 0 stack . pop ( )   dfs ( 0 ) print ( ans ) NEW_LINE"],"bleu":0.09697184935332848,"rouge_l":0.30724525377760553}
{"id":340,"predictions":["import sys , os , ioimport math , bisect , operatorinf , mod = float ( ' inf ' ) , 10 ** 9 + 7 NEW_LINE"],"references":["s = input ( ) k = int ( input ( ) ) l = len ( s )   if l % k : print ( \" NO \" ) else : f = True t = l \/\/ k for i in range ( 0 , l , t ) : sub = s [ i : i + t ] if sub != sub [ : : - 1 ] : f = False break   print ( \" YES \" if f else \" NO \" )       NEW_LINE"],"bleu":0.006159705058598284,"rouge_l":0.08937728937728939}
{"id":341,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["from bisect import bisect_left   n , m , ta , tb , k = map ( int , input ( ) . split ( ) ) a = [ int ( X ) + ta for X in input ( ) . split ( ) ] b = [ int ( X ) for X in input ( ) . split ( ) ] an = - 1 NEW_LINE"],"bleu":0.16012881990032762,"rouge_l":0.39621109607577804}
{"id":342,"predictions":["n , m = map ( int , input ( ) . split ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( 1 , n + 1 ) : if arr [ i ] == \" # \" : arr [ i ] [ 0 ] = arr [ i - 1 ] [ 0 ] + arr [ i ] [ 1 ] else : arr [ i ] [ 1 ] = arr [ i ] [ 1 ] + arr [ i ] [ 0 ] NEW_LINE"],"references":["for i in range ( int ( input ( ) ) ) : print ( max ( 0 , int ( input ( ) ) - 2 ) ) NEW_LINE"],"bleu":0.1033163539891401,"rouge_l":0.27801608579088466}
{"id":343,"predictions":["n , k = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) s = sum ( l ) for i in range ( k ) : s = sum ( l [ i % k ] ) if i == 0 : s = i else : s = 0 print ( s + 1 ) NEW_LINE"],"references":["a , b = map ( int , input ( ) . split ( ) ) c = list ( map ( int , input ( ) . split ( ) ) ) ans = 0 mini = sum ( c ) for i in range ( b ) : d = i su = 0 while ( d < a ) :   su += c [ d ] d += b if su < mini :   mini = su ans = iprint ( ans + 1 ) NEW_LINE"],"bleu":0.43515964021920805,"rouge_l":0.6303099885189437}
{"id":344,"predictions":["import sysfrom io import * from bisect import * NEW_LINE"],"references":["n , x = map ( int , input ( ) . split ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) dp = [ 0 ] * ( 1 << 18 ) ans = 0 NEW_LINE"],"bleu":0.0031209009618122945,"rouge_l":0.06167846309403437}
{"id":345,"predictions":["def sum_of_digits ( n ) : sum = 0 for digit in str ( n ) : sum += int ( digit ) return sum   n = int ( input ( ) ) fs = 0 ans = 0 if n > 9 : fs = sum_of_digits ( n ) ans += 1 while fs > 9 : fs = sum_of_digits ( fs ) ans += 1 print ( ans )     NEW_LINE"],"references":["x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) x , y = map ( int , input ( ) . split ( ) ) if ( x2 - x1 ) % x == 0 and ( y2 - y1 ) % y == 0 : if ( ( x2 - x1 ) \/\/ x + ( y2 - y1 ) \/\/ y ) % 2 == 0 : print ( \" YES \" ) else : print ( \" NO \" ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.04455175151188651,"rouge_l":0.262224610424503}
{"id":346,"predictions":["n = int ( input ( ) ) r = lambda : list ( map ( int , input ( ) . split ( ) ) ) arr = r ( )   while r : r += 1   n = ( r + 1 ) \/\/ 10   if n % 10 == 0 : print ( r ) NEW_LINE"],"references":["def new ( n ) : while n % 10 == 0 : n = n \/\/ 10 return n if __name__ == ' _ _ main _ _ ' : n = int ( input ( ) ) d = dict ( ) c = 1 flag = 1 d . setdefault ( n , 1 ) while flag == 1 : n = n + 1 n = new ( n ) d . setdefault ( n , 0 ) if d [ n ] == 0 : d [ n ] = 1 c += 1 else : flag = 0 print ( c ) NEW_LINE"],"bleu":0.13395789899000818,"rouge_l":0.3343076360979174}
{"id":347,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["T_ON = 0 DEBUG_ON = 0 MOD = 998244353     def solve ( ) : a , b = read_ints ( ) x , y , z = read_ints ( ) print ( max ( 0 , 2 * x + y - a ) + max ( 0 , y + 3 * z - b ) )     def main ( ) : T = read_int ( ) if T_ON else 1 for i in range ( T ) : solve ( )     def debug ( * xargs ) : if DEBUG_ON : print ( * xargs )     from collections import * import math     NEW_LINE"],"bleu":0.02906459419656342,"rouge_l":0.2295390404515522}
{"id":348,"predictions":["n , m = map ( int , input ( ) . split ( ) ) arr = [ 0 ] * ( n + 1 )   for i in range ( 1 , n + 1 ) : arr [ i ] = list ( map ( int , input ( ) . split ( ) ) )   curr = 0 for i in range ( 1 , n + 1 ) : if arr [ i ] [ 0 ] == 1 : curr += 1 arr [ i ] [ 1 ] = arr [ i ] [ 1 ] + arr [ i - 1 ] [ 1 ] % 2 == 0 : curr += 1   print ( curr ) NEW_LINE"],"references":["n = input ( )   p0 = [ 1 ] p1 = [ 0 , 1 ]   if n == 1 : print 1 print 0 , 1 print 0 print 1 exit ( )   for i in xrange ( 2 , n + 1 ) : p = [ 0 for j in xrange ( i + 1 ) ]   for j in xrange ( len ( p1 ) ) : p [ j + 1 ] = p1 [ j ] for j in xrange ( len ( p0 ) ) : p [ j ] += p0 [ j ]   for j in xrange ( len ( p ) ) : p [ j ] %= 2   if i == n : print i print ' ▁ ' . join ( map ( str , p ) ) print i - 1 print ' ▁ ' . join ( map ( str , p1 ) )   p0 = [ p1 [ j ] for j in xrange ( len ( p1 ) ) ] p1 = [ p [ j ] for j in xrange ( len ( p ) ) ] NEW_LINE"],"bleu":0.10421728086910564,"rouge_l":0.31273141555112505}
{"id":349,"predictions":["st = str ( input ( ) ) NEW_LINE l = len ( st ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( l1 > l2 ) : NEW_LINE INDENT print ( \"0\" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \"1\" ) NEW_LINE DEDENT DEDENT"],"references":["x = input ( ) . lower ( ) y = input ( ) . lower ( ) if ( x < y ) : print ( \" - 1\" ) elif ( x > y ) : print ( \"1\" ) else : print ( \"0\" ) NEW_LINE"],"bleu":0.20054699912036383,"rouge_l":0.4778067885117494}
{"id":350,"predictions":["import sysfrom functools import lru_cache , cmp_to_keyfrom heapq import merge , heapify , heappop , heappushfrom math import * from collections import defaultdict as dd , deque , Counter as Cfrom itertools import combinations as comb , permutations as permfrom bisect import bisect_left as bl , bisect_right as br , bisect , insortfrom time import perf_counterfrom fractions import Fractionimport copyfrom copy import deepcopyimport timestarttime = time . time ( ) mod = int ( pow ( 10 , 9 ) + 7 ) mod2 = 998244353   def data ( ) : return sys . stdin . readline ( ) . strip ( ) def out ( * var , end = \" \\n \" ) : sys . stdout . write ( ' ▁ ' . join ( map ( str , var ) ) + 1 ) def L ( ) : return list ( sp ( ) ) def sl ( ) : return list ( ssp ( ) ) def sp ( ) : return map ( int , data ( ) . split ( ) ) def ssp ( ) : return map ( str , data ( ) . split ( ) ) def l1d ( n , val = 0 ) : return [ val for i in range ( n ) ] def l2d ( n , m , val = 0 ) : return [ l1d ( n , val ) for j in range ( m ) ] try : NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) used = [ 0 ] * ( n + 1 ) ans = [ 0 ] * ( n + 1 )   for x , y in zip ( a , a [ 1 : ] ) : z = ( y - x ) % n or n if ans [ x ] == 0 and used [ z ] or ans [ x ] != 0 and ans [ x ] != z : print ( - 1 ) exit ( ) used [ z ] = 1 ans [ x ] = z   i = 1 for j in range ( 1 , n + 1 ) : if ans [ j ] == 0 : while used [ i ] : i += 1 ans [ j ] = i i += 1   print ( * ans [ 1 : ] ) NEW_LINE"],"bleu":0.1143415450640476,"rouge_l":0.2465987716706833}
{"id":351,"predictions":["n = int ( input ( ) ) a = [ int ( x ) for x in input ( ) . split ( ) ] if a [ 1 ] == 1 : print ( '0' ) elif a [ 1 ] == 1 : print ( '1' ) elif a [ 1 ] == 1 : print ( '0' ) else : print ( '4' ) NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) while n > 0 and m > 0 : if n >= 2 * m : n = n % ( 2 * m ) elif m >= 2 * n : m = m % ( 2 * n ) else : breakprint ( n , m , sep = \" ▁ \" )   NEW_LINE"],"bleu":0.15355899581520321,"rouge_l":0.3363197794624397}
{"id":352,"predictions":["import sysfrom functools import lru_cache , cmp_to_keyfrom heapq import merge , heapify , heappop , heappush NEW_LINE"],"references":["inp = input ( )   n = int ( inp [ 0 : ( len ( inp ) - 1 ) ] )   n -= 1   base = ( n \/\/ 4 ) * 16 + ( n % 2 ) * 7   def cnt ( s ) : if s == ' f ' : return 1 if s == ' e ' : return 2 if s == ' d ' : return 3 if s == ' a ' : return 4 if s == ' b ' : return 5 if s == ' c ' : return 6   print ( base + cnt ( inp [ len ( inp ) - 1 ] ) ) NEW_LINE"],"bleu":0.0001591893362730207,"rouge_l":0.012295908083047773}
{"id":353,"predictions":["from collections import defaultdict , deque , Counterfrom sys import stdin , stdoutfrom heapq import heappush , heappopimport mathimport ioimport osimport mathimport bisect   NEW_LINE"],"references":["n = int ( input ( ) ) arr = [ i for i in range ( n ) ] NEW_LINE"],"bleu":0.050661968099322066,"rouge_l":0.0441708906589428}
{"id":354,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["import sysfrom collections import Counterdef fmax ( n , m , a ) : c = [ 0 ] * m b = [ 0 ] * n   if n == 3 * m : for i in range ( n \/\/ 3 ) : for j in range ( 3 ) : b [ a [ i ] [ j ] - 1 ] = j + 1 for i in range ( m ) : flag = 1 for j in range ( 3 ) : if b [ a [ i ] [ j ] - 1 ] != 0 : index = b [ a [ i ] [ j ] - 1 ] if j == 0 and index == 1 : continue b [ a [ i ] [ index - 1 ] - 1 ] = j + 1 continue b [ a [ i ] [ j ] - 1 ] = j + 1 return b if __name__ == ' _ _ main _ _ ' : input = sys . stdin . read ( ) data = list ( map ( int , input . split ( ) ) ) n = data [ 0 ] m = data [ 1 ] l = 0 a = [ ] for i in range ( m ) : a . append ( list ( map ( int , ( data [ l + 2 : l + 5 ] ) ) ) ) l = l + 3 print ( * fmax ( n , m , a ) ) NEW_LINE"],"bleu":0.002746229448627862,"rouge_l":0.16183331808617693}
{"id":355,"predictions":["arr = list ( map ( int , input ( ) . split ( ) ) ) n = 1 if ( n == 1 ) : print ( 1 , 2 ) elif ( n == 2 ) : print ( 1 , 2 ) else : print ( 1 , 1 ) print ( 2 , 3 ) NEW_LINE"],"references":["def odd ( lst , n ) : for i in range ( 1 , n + 1 , 2 ) : lst . append ( i ) def even ( lst , n ) : start = 2 if len ( lst ) == 1 or n == 3 : start = 4 for j in range ( start , n + 1 , 2 ) : lst . append ( j )           n = int ( input ( ) ) lst = [ ]   if n % 2 == 0 and n > 2 : even ( lst , n ) odd ( lst , n ) else : odd ( lst , n ) even ( lst , n ) print ( len ( lst ) ) print ( * lst ) NEW_LINE"],"bleu":0.07144630493501218,"rouge_l":0.32384604040701964}
{"id":356,"predictions":["n , a = map ( int , input ( ) . split ( ) ) x = list ( map ( int , input ( ) . split ( ) ) ) x . sort ( ) print ( 0 if n == 1 else min ( abs ( a - x [ 1 ] ) + x [ n - 1 ] - x [ 1 ] ) ) NEW_LINE"],"references":["def count ( x1 , y1 , z1 , x2 , y2 , z2 ) : if x2 == 0 and a != 0 or y2 == 0 and b != 0 or z2 == 0 and c != 0 : return False if x2 == 0 : x2 = 1 if y2 == 0 : y2 = 1 if z2 == 0 : z2 = 1 return ( x1 \/ x2 ) ** a * ( y1 \/ y2 ) ** b * ( z1 \/ z2 ) ** c < 1     n = int ( input ( ) ) a , b , c = map ( int , input ( ) . split ( ) ) l1 , r1 = 0 , nfor i in range ( 200 ) : x1 = l1 + ( r1 - l1 ) \/ 3 l2 , r2 = 0 , n - x1 for j in range ( 200 ) : y1 = l2 + ( r2 - l2 ) \/ 3 y2 = r2 - ( r2 - l2 ) \/ 3 if count ( x1 , y1 , n - x1 - y1 , x1 , y2 , n - x1 - y2 ) : l2 = y1 else : r2 = y2 y11 = l2 x2 = r1 - ( r1 - l1 ) \/ 3 l2 , r2 = 0 , n - x2 for j in range ( 200 ) : y1 = l2 + ( r2 - l2 ) \/ 3 y2 = r2 - ( r2 - l2 ) \/ 3 if count ( x2 , y1 , n - x2 - y1 , x2 , y2 , n - x2 - y2 ) : l2 = y1 else : r2 = y2 y22 = l2 if count ( x1 , y11 , n - x1 - y11 , x2 , y22 , n - x2 - y22 ) : l1 = x1 p = y11 else : r1 = x2 p = y22print ( l1 , p , n - l1 - p ) NEW_LINE"],"bleu":0.005527891173494946,"rouge_l":0.1631687242798354}
{"id":357,"predictions":["n , m = map ( int , input ( ) . split ( ) ) grid = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] ans = [ ] for i in range ( m ) : grid [ i ] . append ( input ( ) ) for i in range ( n ) : for j in range ( m ) : grid [ j ] [ i ] = 0 for j in range ( m ) : for k in range ( m ) : grid [ j ] [ k ] -= mini for _ in range ( mini ) : ans . append ( \" row ▁ \" + str ( i + 1 ) for i in range ( n ) : mini = min ( grid [ j ] [ i ] ) for j in range ( mini ) : grid [ j ] [ k ] -= mini for _ in range ( mini ) : ans . append ( \" row ▁ \" + str ( i + 1 ) ) for i in range ( m ) : mini = float ( ' inf ' ) for j in range ( n ) : grid [ j ] [ i ] -= mini for j in range ( mini ) : mini = min ( grid [ j ] [ i ] ) for j in range ( m ) : grid [ j ] [ i ] -= mini for j in range ( mini ) : ans . append ( \" col ▁ \" + str ( i + 1 ) ) for i in grid : print ( ans ) for i in ans : print ( * ans ) else : print ( \" NO \" ) NEW_LINE"],"references":["s = input ( ) n = len ( s ) ans = s [ - 1 ] for i in range ( n - 2 , - 1 , - 1 ) : if s [ i ] >= ans [ - 1 ] : ans += s [ i ] print ( ans [ : : - 1 ] ) NEW_LINE"],"bleu":0.04625528820913111,"rouge_l":0.2192752355970077}
{"id":358,"predictions":["from math import sqrtfor _ in range ( int ( input ( ) ) ) : a , b = list ( map ( int , input ( ) . split ( ) ) ) if a - b != 1 : print ( \" NO \" ) else : c = a \/\/ 2 if c % 2 == 0 : print ( \" YES \" ) print ( c ) else : print ( \" NO \" ) NEW_LINE"],"references":["n , k = map ( int , input ( ) . split ( ) ) lst = sorted ( [ int ( i ) % k for i in input ( ) . split ( ) ] ) low , high = 0 , n - 1 count = 0   while low < high : if lst [ low ] + lst [ high ] == k : low += 1 high -= 1 count += 2 elif lst [ low ] + lst [ high ] < k : low += 1 else : high -= 1   print ( count + 2 * ( lst . count ( 0 ) \/\/ 2 ) ) NEW_LINE"],"bleu":0.14751224523552528,"rouge_l":0.29006181645268664}
{"id":359,"predictions":["t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if b >= a : NEW_LINE INDENT print ( m ) NEW_LINE return NEW_LINE DEDENT DEDENT"],"references":["import sys NEW_LINE def main ( ) : NEW_LINE INDENT n , m = map ( int , sys . stdin . read ( ) . strip ( ) . split ( ) ) NEW_LINE m %= ( 1 + n ) * n \/\/ 2 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT m -= i NEW_LINE if not m : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif m < 0 : NEW_LINE INDENT return m + i NEW_LINE DEDENT DEDENT DEDENT print ( main ( ) ) NEW_LINE"],"bleu":0.17025995879875866,"rouge_l":0.3818864774624374}
{"id":360,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["a , b , c = map ( int , input ( ) . split ( ) ) data = list ( map ( int , input ( ) . split ( ) ) ) datb = list ( map ( int , input ( ) . split ( ) ) ) res = [ ] for i in range ( 1 , a + 1 ) : if i in data : res . append ( \"1\" ) else : res . append ( \"2\" ) print ( \" ▁ \" . join ( res ) ) NEW_LINE"],"bleu":0.12807782446899607,"rouge_l":0.41190124498839414}
{"id":361,"predictions":["for _ in range ( int ( input ( ) ) ) : n , x = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) ) l . sort ( ) b = sorted ( l ) if ( b < x ) : print ( \" No \" ) else : print ( \" Yes \" ) NEW_LINE"],"references":["n = int ( input ( ) ) NEW_LINE for p in range ( n ) : n1 , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) [ : : - 1 ] NEW_LINE if p != n - 1 : z = input ( ) NEW_LINE for x in range ( n1 ) : if NEW_LINE a [ x ] + b [ x ] > k : print ( ' No ' ) NEW_LINE break else : print ( ' Yes ' ) NEW_LINE"],"bleu":0.2966883312166337,"rouge_l":0.5538740920096853}
{"id":362,"predictions":["import sys , os , ioimport collections , bisect , operatorinf , mod = float ( ' inf ' ) , 10 ** 9 + 7 NEW_LINE"],"references":["import ren = int ( input ( ) ) NEW_LINE ans , sumL = 1 , 0 NEW_LINE for s in re . split ( \" [ . ? ! ] \" , input ( ) ) : s = s . strip ( ) + ' . ' NEW_LINE L = len ( s ) NEW_LINE if L > 1 : if NEW_LINE L > n : print ( \" Impossible \" ) NEW_LINE exit ( ) NEW_LINE if sumL + L + ( sumL > 0 ) > n : ans += 1 NEW_LINE sumL = L else : sumL = sumL + L + ( sumL > 0 ) NEW_LINE print ( ans ) NEW_LINE"],"bleu":0.0024165916450558786,"rouge_l":0.13629900467194803}
{"id":363,"predictions":["import bisectimport collectionsimport copyimport functoolsimport heapqimport sysimport mathimport randomimport randomimport reimport sysimport timeimport stringfrom typing import List NEW_LINE"],"references":["k , d , t = map ( int , input ( ) . split ( ) ) d = ( ( k + d - 1 ) \/\/ d ) * dn = 2 * t \/\/ ( d + k ) x = 2 * t % ( d + k ) if ( x <= 2 * k ) : ans = x \/ 2 + d * nelse : ans = x - k + d * nprint ( ans ) NEW_LINE"],"bleu":0.0015575453610183264,"rouge_l":0.01720248166948675}
{"id":364,"predictions":["n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE result = 0 NEW_LINE for i in range ( 0 , n ) : t = input ( ) . split ( ) ) NEW_LINE if t [ 0 ] != a [ 1 ] : NEW_LINE INDENT result += float ( \" inf \" ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT result += int ( input ( ) ) NEW_LINE DEDENT print ( result ) NEW_LINE"],"references":["n = int ( input ( ) ) NEW_LINE r = lambda : list ( map ( str , input ( ) . split ( ) ) ) NEW_LINE ans = - float ( ' inf ' ) NEW_LINE winner = \" xx \" NEW_LINE for _ in range ( n ) : name , * score = r ( ) NEW_LINE point = 0 NEW_LINE for i in score [ 2 : ] : point += int ( i )     NEW_LINE"],"bleu":0.3257287696040112,"rouge_l":0.5362396842482957}
{"id":365,"predictions":["t = int ( input ( ) ) NEW_LINE for i in range ( t ) : n = int ( input ( ) ) NEW_LINE x = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l = set ( ) NEW_LINE for j in x : if NEW_LINE j not in l : l . add ( j ) else : l . add ( j + 1 ) NEW_LINE l1 = set ( ) NEW_LINE"],"references":["def prime ( n ) : c = 0 for i in range ( 2 , int ( pow ( n , 0.5 ) ) + 1 ) : if ( n % i == 0 ) : c = 1 break return c       n = int ( input ( ) ) if ( n == 1 ) : print ( 3 ) elif ( n == 2 ) : print ( 4 ) else : for i in range ( 1 , n + 1 ) : c1 = prime ( n * i + 1 ) if ( c1 == 1 ) : break print ( i ) NEW_LINE"],"bleu":0.15608223279641364,"rouge_l":0.3525445496869481}
{"id":366,"predictions":["import sys , os , ioimport math , bisect , operatorinf , mod = float ( ' inf ' ) , 10 ** 9 + 7 NEW_LINE"],"references":["import mathh , w = map ( int , input ( ) . split ( ) ) NEW_LINE if h \/ w >= 0.8 and h \/ w <= 1.25 and ( ( math . log ( h , 2 ) % 1 == 0 ) or ( math . log ( w , 2 ) % 1 == 0 ) ) : NEW_LINE INDENT print ( h , w ) else : NEW_LINE w1 = 2 ** ( math . log ( w , 2 ) \/\/ 1 ) NEW_LINE DEDENT h1 = min ( h , ( w1 * 1.25 ) \/\/ 1 ) NEW_LINE h2 = 2 ** ( math . log ( h , 2 ) \/\/ 1 ) NEW_LINE w2 = min ( w , ( h2 * 1.25 ) \/\/ 1 ) NEW_LINE if ( h1 \/ w1 >= 0.8 and h1 \/ w1 <= 1.25 ) and ( h2 \/ w2 >= 0.8 and h2 \/ w2 <= 1.25 ) : if NEW_LINE h1 >= h2 and h1 * w1 >= h2 * w2 : print ( int ( h1 ) , int ( w1 ) ) else : print ( int ( h2 ) , int ( w2 ) ) elif ( h1 \/ w1 >= 0.8 and h1 \/ w1 <= 1.25 ) : print ( int ( h1 ) , int ( w1 ) ) else : print ( int ( h2 ) , int ( w2 ) ) NEW_LINE"],"bleu":0.0000224895102970579,"rouge_l":0.08196382428940568}
{"id":367,"predictions":["def STR ( ) : return list ( input ( ) ) def INT ( ) : return int ( input ( ) ) def MAP ( ) : return map ( int , input ( ) . split ( ) ) def MAP2 ( ) : return map ( float , input ( ) . split ( ) ) def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) def STRING ( ) : return input ( ) import stringimport sysfrom heapq import heappop , heappushfrom bisect import * from collections import deque , Counter , defaultdictfrom math import * from itertools import permutations , accumulatedx = [ - 1 , 1 , 0 , 0 ] dy = [ 0 , 0 , 1 , - 1 ] NEW_LINE"],"references":["n , k = map ( int , input ( ) . split ( ) ) if n < k : print ( k + n ) else : ans = [ ] ; i = 1 while i * i <= n : if n % i == 0 and n % ( n \/\/ i ) == 0 : ans . append ( [ i , n \/\/ i ] ) i += 1 ans1 = [ ] for j in ans : if k > j [ 0 ] : ans1 . append ( k * j [ 1 ] + j [ 0 ] ) if k > j [ 1 ] : ans1 . append ( k * j [ 0 ] + j [ 1 ] ) print ( min ( ans1 ) ) NEW_LINE"],"bleu":0.1277973519334457,"rouge_l":0.24043589149084163}
{"id":368,"predictions":["from math import ceilfor NEW_LINE ad in range ( int ( input ( ) ) ) : NEW_LINE"],"references":["import sys , mathfrom collections import defaultdict , dequeinput = sys . stdin . readline   n = int ( input ( ) ) c = 0 for i in range ( 1 , n + 1 ) : for j in range ( i + 1 , n + 1 ) : k = i ^ j if ( i < j < k <= n and i + j > k and j + k > i and i + k > j ) : NEW_LINE"],"bleu":0.009803411898615208,"rouge_l":0.16860143725815366}
{"id":369,"predictions":["n , m = map ( int , input ( ) . split ( ) ) grid = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] ans = [ ] for i in range ( m ) : for j in range ( m ) : grid [ i ] [ j ] = grid [ i ] [ j ] for i in range ( n ) : grid [ i ] [ j ] = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) : grid [ i ] [ j ] ) for j in range ( m ) : grid [ i ] [ j ] -= mini for _ in range ( mini ) : ans . append ( \"0\" ) else : for i in range ( m ) : mini = min ( grid [ i ] [ j ] , mini ) for j in range ( m ) : grid [ i ] [ j ] ) for i in range ( mini ) : ans . append ( \" row ▁ \" + str ( i + 1 ) ) for i in range ( n - 1 , m ) : for j in range ( m ) : mini = min ( grid [ j ] [ i ] ) for j in range ( m ) : grid [ i ] [ j ] -= mini for _ in range ( mini ) : ans . append ( \" col ▁ \" + str ( i + 1 ) ) print ( len ( ans ) ) NEW_LINE"],"references":["from math import sqrtn , v1 , v2 = list ( map ( int , input ( ) . split ( ) ) ) a = list ( map ( int , input ( ) . split ( ) ) ) x , y = list ( map ( int , input ( ) . split ( ) ) ) b = [ ] c = [ ] d = [ ] for i in range ( n ) : b . append ( sqrt ( ( x - a [ i ] ) ** 2 + y ** 2 ) ) d . append ( a [ i ] \/ v1 + b [ i ] \/ v2 ) e = sorted ( d [ 1 : ] ) [ 0 ] f = [ ] for i in range ( n ) : if d [ i ] == e : f . append ( i ) g = 0 h = - 1 for i in f : if h == - 1 or b [ i ] < h : h = b [ i ] g = i + 1 print ( g ) NEW_LINE"],"bleu":0.2676387616248531,"rouge_l":0.44401360544217694}
{"id":370,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( len ( lst ) ) : NEW_LINE"],"references":["t = int ( input ( ) ) for i in range ( t ) : s = input ( ) c1 = c2 = c3 = x = y = z = 0 ans = 200000 i = 0 f = False while i < len ( s ) : if s [ i ] == '1' : c1 += 1 x = i elif s [ i ] == '2' : c2 += 1 y = i elif s [ i ] == '3' : c3 += 1 z = i                                     if c1 >= 1 and c2 >= 1 and c3 >= 1 : f = True p = max ( x , y , z ) - min ( x , y , z ) + 1 ans = min ( ans , p ) c1 = c2 = c3 = x = y = z = 0 i = i - 2 i += 1 if f == False : print ( 0 ) else : print ( ans ) NEW_LINE"],"bleu":0.009762582844610283,"rouge_l":0.1246311010215664}
{"id":371,"predictions":["n , m , k = map ( int , input ( ) . split ( ) ) cells = 0 for i in range ( 0 , k ) : cells += 2 * ( m + n - 2 - i * ( 8 ) ) print ( cells ) NEW_LINE"],"references":["s = str ( input ( ) ) a = s . find ( ' a ' ) b = s . find ( ' b ' ) c = s . find ( ' c ' ) if ( ' a ' in s ) and ( ' b ' in s ) and ( ' b ' in s ) and ( a < b < c ) and ( ' ba ' not in s ) and ( ' ca ' not in s ) and ( ' cb ' not in s ) : if s . count ( ' a ' ) == s . count ( ' c ' ) or s . count ( ' b ' ) == s . count ( ' c ' ) : print ( \" YES \" ) else : print ( \" NO \" ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.01231774664355729,"rouge_l":0.19135890489091684}
{"id":372,"predictions":["n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) c = sum ( l ) s = 0 for i in l : if i % 2 == 0 : c += i else : c += 1 print ( c ) NEW_LINE"],"references":["dontcare = input ( ) NEW_LINE a = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE sum = 0 NEW_LINE for i in a : sum += iif NEW_LINE sum % 2 == 1 : print ( sum ) else : max = sum NEW_LINE for i in a : if NEW_LINE i % 2 == 1 : max -= i NEW_LINE break NEW_LINE for i in a : if NEW_LINE i % 2 == 1 and sum - i > max : max = sum - i NEW_LINE if max % 2 == 1 : NEW_LINE INDENT print ( max ) else : NEW_LINE print ( 0 ) NEW_LINE DEDENT"],"bleu":0.09329598383706089,"rouge_l":0.3684210526315789}
{"id":373,"predictions":["n , m , a , b = map ( int , input ( ) . split ( ) ) s = input ( )   dp = [ [ 0 ] * n for i in range ( n ) ] for i in range ( m ) : x , y = map ( int , input ( ) . split ( ) ) if dp [ x ] [ y ] == ' * ' : dp [ x - 1 ] [ y ] = min ( dp [ x - 1 ] [ y - 1 ] , dp [ x - 1 ] [ y - 1 ] ) dp [ x - 1 ] [ y - 1 ] = dp [ x - 1 ] [ y - 1 ] if y == 1 : dp [ x - 1 ] [ y - 1 ] = max ( dp [ x - 1 ] [ y ] , y ) print ( ' ▁ ' . join ( dp ) ) NEW_LINE"],"references":["from sys import stdin   input = stdin . readlinek , n = map ( int , input ( ) . split ( ) ) NEW_LINE a = input ( ) NEW_LINE b = input ( ) NEW_LINE dp = [ [ 0 for i in range ( n + 1 ) ] for __ in range ( k + 1 ) ] NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , k + 1 ) : for NEW_LINE j in range ( 1 , n + 1 ) : NEW_LINE if a [ i - 1 ] == b [ j - 1 ] : dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j - 1 ] + 2 ) NEW_LINE ans = max ( ans , dp [ i ] [ j ] ) else : dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) - 1 NEW_LINE dp [ i ] [ j ] = max ( 0 , dp [ i ] [ j ] ) NEW_LINE print ( ans ) NEW_LINE"],"bleu":0.2734474067554722,"rouge_l":0.519169976493475}
{"id":374,"predictions":["n = int ( input ( ) ) NEW_LINE for i in range ( n ) : a = int ( input ( ) ) NEW_LINE s = [ int ( i ) for i in input ( ) . split ( ' ▁ ' ) ] NEW_LINE count = { } NEW_LINE for j in range ( a ) : for NEW_LINE k in range ( j + 1 , a ) : compute = s [ k ] - a [ j ] NEW_LINE if compute not in count : count [ compute ] = 1 NEW_LINE print ( len ( count ) ) NEW_LINE"],"references":["def test ( i ) : aa = input ( ) . split ( ' ▁ ' ) ar = [ ] for j in aa : ar . append ( int ( j ) ) ark = [ ] for jj in ar : while jj in ark : if jj <= 0 : break jj -= 1 ark . append ( jj ) count = 0 for n in ark : count += n if len ( ark ) == i : print ( count ) i = int ( input ( ) ) if i <= 26 and i >= 2 : test ( i ) NEW_LINE"],"bleu":0.2348072930941081,"rouge_l":0.3401657874905802}
{"id":375,"predictions":["t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a % b == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT a -= ( a % b ) NEW_LINE DEDENT DEDENT"],"references":["t = int ( input ( ) ) while ( t ) : a , b = map ( int , input ( ) . split ( ) ) if ( a % b == 0 ) : print ( '0' ) else : print ( b - ( a % b ) ) t -= 1 NEW_LINE"],"bleu":0.5170333967075909,"rouge_l":0.7557231349313225}
{"id":376,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) print ( ( ( ' Yes ' , ' No ' ) [ any ( a [ 1 ] - 1 ) for i in range ( n ) ] ) ) NEW_LINE"],"references":["nr_threads = int ( input ( ) ) old_position = list ( map ( int , input ( ) . split ( ) ) ) ans = nr_threads - 1   if ( nr_threads == 1 ) : print ( 0 ) quit ( )   i = ans     while ( i > 0 ) : if ( old_position [ i - 1 ] > old_position [ i ] ) : print ( ans ) quit ( ) else : i -= 1 ans -= 1   print ( ans ) NEW_LINE"],"bleu":0.2630387108767564,"rouge_l":0.4795200661977658}
{"id":377,"predictions":["x , y , z = [ int ( x ) for x in input ( ) . split ( ) ] n , a , b , p , p = sorted ( [ int ( x ) for x in input ( ) . split ( ) ] ) ) print ( ' NO ' ) NEW_LINE"],"references":["import sysdef get_ints ( ) : return list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) li1 = get_ints ( ) li2 = get_ints ( ) if li2 [ 0 ] - li1 [ 0 ] >= 0 : li2 [ 0 ] -= li1 [ 0 ] summ = sum ( li2 ) if sum ( li2 [ : 2 ] ) >= li1 [ 1 ] : if summ - ( li1 [ 1 ] ) >= li1 [ 2 ] : print ( ' yes ' ) else : print ( ' No ' ) else : print ( ' no ' ) else : print ( ' NO ' )       NEW_LINE"],"bleu":0.07839014364791375,"rouge_l":0.27428938493656657}
{"id":378,"predictions":["import sysfrom functools import lru_cache , cmp_to_keyfrom heapq import merge , heapify , heappop , heappushfrom math import * from collections import Counter as Cfrom bisect import bisect_left as bst = lambda : list ( map ( int , input ( ) . split ( ) ) ) mod = 10 ** 9 + 7 NEW_LINE"],"references":["h , w = map ( int , input ( ) . split ( ) ) r = list ( map ( int , input ( ) . split ( ) ) ) c = list ( map ( int , input ( ) . split ( ) ) ) mod = 1000000007 grid = [ [ \" ? \" for i in range ( w + 1 ) ] for j in range ( h + 1 ) ] def try_set ( row , col , target ) : if grid [ row ] [ col ] == \" ? \" : grid [ row ] [ col ] = target elif grid [ row ] [ col ] != target : raise ValueErrordef go ( ) : try : for row in range ( h ) : for col in range ( r [ row ] ) : try_set ( row , col , \" FULL \" ) try_set ( row , r [ row ] , \" EMPTY \" ) for col in range ( w ) : for row in range ( c [ col ] ) : try_set ( row , col , \" FULL \" ) try_set ( c [ col ] , col , \" EMPTY \" ) except ValueError : return 0 answer = 1 for i in range ( h ) : for j in range ( w ) : if grid [ i ] [ j ] == \" ? \" : answer = answer * 2 % mod return answerprint ( go ( ) ) NEW_LINE"],"bleu":0.0075847554565906875,"rouge_l":0.12740646567381037}
{"id":379,"predictions":["n , k = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) ans = [ ] for i in range ( n - 1 ) : if l [ i ] != 1 : ans . append ( abs ( l [ i + 1 ] - l [ i ] ) ) ) else : ans . append ( 0 ) for i in range ( n - 1 ) : print ( * ans [ i + 1 ] ) print ( * ans )   NEW_LINE"],"references":["from sys import stdin , stdoutfrom os import pathrd = lambda : stdin . readline ( ) . strip ( ) wr = stdout . writeif ( path . exists ( ' input . txt ' ) ) : stdin = open ( \" input . txt \" , \" r \" ) import time , math NEW_LINE"],"bleu":0.03873753391154749,"rouge_l":0.23956180239768501}
{"id":380,"predictions":["def main ( ) : t = int ( input ( ) ) for _ in range ( t ) : n = int ( input ( ) ) NEW_LINE"],"references":["t = int ( input ( ) ) for i in range ( t ) : n = int ( input ( ) ) arr = map ( int , input ( ) . split ( ) ) arr = set ( arr ) print ( len ( arr ) ) NEW_LINE"],"bleu":0.3624718938437015,"rouge_l":0.5583524027459955}
{"id":381,"predictions":["a , b = map ( int , input ( ) . split ( ) ) if a == 1 : print ( - 1 ) exit ( ) print ( 0 ) NEW_LINE"],"references":["l , r = map ( int , input ( ) . split ( ) ) def f ( n ) : NEW_LINE"],"bleu":0.4013423610237056,"rouge_l":0.6179976162097734}
{"id":382,"predictions":["t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT q , c = map ( int , input ( ) . split ( ) ) NEW_LINE A = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( R ) ] NEW_LINE for r in range ( C ) : NEW_LINE INDENT if c [ r - 1 ] == ' R ' : NEW_LINE INDENT x += 1 NEW_LINE DEDENT DEDENT DEDENT print ( x ) NEW_LINE"],"references":["for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , m = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( input ( ) . strip ( ) ) NEW_LINE DEDENT x = 0 NEW_LINE for i in a [ - 1 ] : NEW_LINE INDENT x += int ( i == ' D ' ) NEW_LINE DEDENT for i in a : NEW_LINE INDENT x += int ( i [ - 1 ] == ' R ' ) NEW_LINE DEDENT print ( x ) NEW_LINE DEDENT"],"bleu":0.3455779383861833,"rouge_l":0.5090030742204655}
{"id":383,"predictions":["n , k = map ( int , input ( ) . split ( ) ) letters = [ ] for i in range ( n ) : letters . append ( input ( ) )   t = \" abcdefghijklwxyz \" NEW_LINE"],"references":["import sysfrom string import ascii_lowercase as az   def main ( ) : n , k = map ( int , sys . stdin . read ( ) . strip ( ) . split ( ) ) return n \/\/ k * az [ : k ] + az [ : n % k ]   print ( main ( ) ) NEW_LINE"],"bleu":0.24184138782771689,"rouge_l":0.4196829195333532}
{"id":384,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["from itertools import repeatfrom math import floor , ceildef fill ( s , a1 , a2 , a3 , a4 , c4 , c7 ) : if a1 < c4 or a2 < c7 : return None f = s . index ( '4' ) sv = s . rindex ( '7' ) s = ' ' . join ( [ s [ : f ] , '4' * ( a1 - c4 ) , s [ f : sv ] , '7' * ( a2 - c7 ) , s [ sv : ] ] ) return sa1 , a2 , a3 , a4 = [ int ( x ) for x in input ( ) . split ( ) ] if abs ( a3 - a4 ) > 1 : print ( - 1 ) else : s = ' ' if a3 > a1 or a3 > a2 or a4 > a1 or a4 > a2 : print ( - 1 ) exit ( 0 ) c4 = 0 c7 = 0 if a3 > a4 : s = ' ' . join ( repeat ( '47' , a3 ) ) c4 = int ( len ( s ) \/ 2 ) c7 = len ( s ) - c4 s = fill ( s , a1 , a2 , a3 , a4 , c4 , c7 ) if s : print ( s ) else : print ( - 1 ) elif a3 < a4 : s = ' ' . join ( repeat ( '74' , a4 ) ) c7 = int ( len ( s ) \/ 2 ) c4 = len ( s ) - c7 s = fill ( s , a1 , a2 , a3 , a4 , c4 , c7 ) if s : print ( s ) else : print ( - 1 ) elif a3 == a4 : s = ' ' . join ( repeat ( '47' , a3 ) ) + '4' c4 = ceil ( len ( s ) \/ 2 ) c7 = len ( s ) - c4 s = fill ( s , a1 , a2 , a3 , a4 , c4 , c7 ) if s : print ( s ) else : s = ' ' . join ( repeat ( '74' , a3 ) ) + '7' c7 = ceil ( len ( s ) \/ 2 ) c4 = len ( s ) - c7 s = fill ( s , a1 , a2 , a3 , a4 , c4 , c7 ) if s : print ( s ) else : print ( - 1 ) NEW_LINE"],"bleu":0.00003939503869965084,"rouge_l":0.10181294964028777}
{"id":385,"predictions":["import sys , os , ioimport math , bisect , operatorinf , mod = float ( ' inf ' ) , 10 ** 9 + 7 NEW_LINE"],"references":["n = int ( input ( ) ) l = [ [ ] for i in range ( n ) ] for i in range ( n ) : for a in range ( i ) : l [ i ] += [ a ]   for i in range ( n ) :   print ( ( ( n - 1 - i ) * 2 + 1 ) * \" ▁ \" , * l [ i ] , 1 * i , * list ( reversed ( l [ i ] ) ) )   for i in range ( n ) : print ( i , end = \" ▁ \" ) print ( n , end = \" ▁ \" ) for i in range ( n - 1 , 0 , - 1 ) : print ( i , end = \" ▁ \" ) print ( 0 )       for i in range ( n - 1 , - 1 , - 1 ) :     print ( ( ( n - 1 - i ) * 2 + 1 ) * \" ▁ \" , * l [ i ] , 1 * i , * list ( reversed ( l [ i ] ) ) )     NEW_LINE"],"bleu":0.00007714362705757338,"rouge_l":0.07774301934885876}
{"id":386,"predictions":["n = int ( input ( ) ) arr = sorted ( map ( int , input ( ) . split ( ) ) )   print ( arr [ n \/\/ 2 ] ) NEW_LINE"],"references":["import sysdef input ( ) : return sys . stdin . readline ( ) . strip ( ) def iinput ( ) : return int ( input ( ) ) def minput ( ) : return map ( int , input ( ) . split ( ) ) def listinput ( ) : return list ( map ( int , input ( ) . split ( ) ) ) a , b , pos = minput ( ) for i in range ( b ) : a *= 10 c = a \/\/ b a = a % b if c == pos : print ( i + 1 ) exit ( ) print ( \" - 1\" ) NEW_LINE"],"bleu":0.05163332562870744,"rouge_l":0.28045977011494255}
{"id":387,"predictions":["n , k = map ( int , input ( ) . split ( ) ) s = list ( input ( ) ) count = 0 for i in range ( n ) : if ord ( s [ i ] ) != ' a ' : count += 1 * 2 if count < n : count += 1 print ( count ) NEW_LINE"],"references":["n , k = map ( int , input ( ) . split ( ) ) a = input ( ) b = input ( ) res = 0 ans = 0 for i in range ( 0 , n ) : res = min ( res * 2 + ( b [ i ] == ' b ' ) - ( a [ i ] == ' b ' ) , k ) ans += min ( res + 1 , k ) print ( ans ) NEW_LINE"],"bleu":0.3034704892268023,"rouge_l":0.5529460238978162}
{"id":388,"predictions":["def testCase ( k , a , b ) : NEW_LINE INDENT if ( a == 0 and b == 0 or a % k == 0 or ( a % k == 0 and b % k == 0 ) or ( a % k == 0 and b % k == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( b > 0 and a < 0 and b < k ) or ( b % k == 0 and a % k == 0 and b % k != 0 ) : NEW_LINE INDENT result = ( b - a + 1 ) \/\/ k + 1 NEW_LINE DEDENT elif ( a > 0 and b > 0 and a < 0 and b > 0 ) : NEW_LINE INDENT result = ( b \/\/ k ) \/\/ k NEW_LINE DEDENT else : NEW_LINE INDENT result = ( b \/\/ k ) + 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT k , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE a = int ( input ( ) ) NEW_LINE b = 0 NEW_LINE print ( int ( testCase ( k , a , b ) ) ) NEW_LINE DEDENT"],"references":["k , a , b = map ( int , input ( ) . split ( ) ) if ( a >= 0 and b >= 0 ) or ( a < 0 and b < 0 ) : if a < 0 and b < 0 : temp = - b b = - a a = temp c = b \/\/ k - a \/\/ k if a % k == 0 : c += 1 elif a < 0 and b >= 0 : a = - a c = a \/\/ k + b \/\/ k + 1 print ( c ) NEW_LINE"],"bleu":0.20913834917739346,"rouge_l":0.37776844757006406}
{"id":389,"predictions":["def gcd ( a , b ) : if ( a % b == 0 ) : return b else : return gcd ( b , a % b )   [ t1 , t2 = input ( ) . split ( ' ▁ ' ) ] t = int ( input ( ) ) NEW_LINE"],"references":["n = int ( input ( ) ) s = input ( )   arr = set ( list ( s ) ) if len ( arr ) < n : print ( \" NO \" )   else : ans = [ ] d = { }   for i in s : if i in d : ans [ - 1 ] += i else : d [ i ] = 1 ans . append ( i ) print ( \" YES \" ) for i in ans [ : n - 1 ] : print ( i )   print ( ' ' . join ( ans [ n - 1 : ] ) )   NEW_LINE"],"bleu":0.07627636484773163,"rouge_l":0.22395104895104892}
{"id":390,"predictions":["for _ in range ( int ( input ( ) ) ) : a , b , c = map ( int , input ( ) . split ( ) ) if a != - 1 and b != c : print ( \" YES \" ) else : print ( \" NO \" ) else : if a == b and b != c : print ( \" NO \" ) else : print ( \" YES \" ) NEW_LINE"],"references":["def mingrid ( ) : for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) segcost = input ( ) . split ( ) minodd = int ( segcost [ 0 ] ) mineven = int ( segcost [ 1 ] ) sumodd = minodd sumeven = mineven codd = 1 ceven = 1 res = sumodd + minodd * ( n - codd ) + sumeven + mineven * ( n - ceven ) for i in range ( 2 , n ) : now = int ( segcost [ i ] ) if ( i + 1 ) % 2 : NEW_LINE"],"bleu":0.17928390057586993,"rouge_l":0.3364152473641525}
{"id":391,"predictions":["n , s , t = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) ) c = list ( map ( int , input ( ) . split ( ) ) ) ) e = set ( ) for x in b : if x in b : c . add ( x ) else : e . add ( b ) if len ( e ) == 2 : print ( ' NO ' ) else : print ( ' YES ' ) NEW_LINE"],"references":["import sys     def get_list ( ) : return list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) )   n = int ( input ( ) )   a = get_list ( ) b = get_list ( )   print ( \" Karen \" ) NEW_LINE"],"bleu":0.1762180768079391,"rouge_l":0.40504648074369193}
{"id":392,"predictions":["n = int ( input ( ) ) arr = sorted ( map ( int , input ( ) . split ( ) ) )   print ( arr [ n - 1 ] ) NEW_LINE"],"references":["import sys       n , m , c = map ( int , input ( ) . split ( ) )   free = n   nums = [ 0 ] * n       for i in range ( m ) :   pi = int ( input ( ) )   if ( pi > c \/\/ 2 ) :   current = n - 1   while ( nums [ current ] > 0 and nums [ current ] >= pi and current >= 0 ) : current -= 1   if ( current == - 1 ) : current = 0   if ( nums [ current ] == 0 ) : free -= 1   nums [ current ] = pi   print ( current + 1 )   else :   current = 0   while ( current < n and nums [ current ] > 0 and nums [ current ] <= pi ) : current += 1   if ( current == n ) : current = n - 1   if ( nums [ current ] == 0 ) : free -= 1   nums [ current ] = pi   print ( current + 1 )       if ( free == 0 ) : break               NEW_LINE"],"bleu":0.006044919119620541,"rouge_l":0.18083003952569168}
{"id":393,"predictions":["s = input ( ) s = input ( ) i = 0 while i < len ( s ) : if ( i == '1' ) : i += 1 else : if ( s [ i ] == '2' ) : i += 1 else : break i += 1 print ( i ) NEW_LINE"],"references":["from sys import stdin , stdoutimport math , bisectfrom collections import Counter , deque , defaultdictL = lambda : list ( map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) ) M = lambda : map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) I = lambda : int ( stdin . readline ( ) . strip ( ) ) S = lambda : stdin . readline ( ) . strip ( ) C = lambda : stdin . readline ( ) . strip ( ) . split ( ) def pr ( a ) : return ( \" \" . join ( list ( map ( str , a ) ) ) ) NEW_LINE"],"bleu":0.015112122684407052,"rouge_l":0.18654434250764526}
{"id":394,"predictions":["s = input ( ) s = input ( ) count = 0 l1 = [ ] for i in range ( len ( s ) ) : if s1 [ i ] == \" a \" : l1 += 1 elif s1 [ i ] == \" o \" or len ( l1 ) == 3 : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"references":["print ( ' YES ' if len ( [ i for i in input ( ) if i in ' aeiou ' ] ) == 5 and len ( [ i for i in input ( ) if i in ' aeiou ' ] ) == 7 and len ( [ i for i in input ( ) if i in ' aeiou ' ] ) == 5 else ' NO ' ) NEW_LINE"],"bleu":0.09302026293655605,"rouge_l":0.3261305413232346}
{"id":395,"predictions":["s = input ( ) e = 0 i = 0 while i < len ( s ) : if s [ i ] == '0' and s [ i ] == '1' : e += 1 if i == len ( s ) and s [ i ] == '0' : print ( \" YES \" ) else : print ( \" NO \" ) break NEW_LINE"],"references":["import syspassword = input ( ) ; n = int ( input ( ) ) ; first = second = 0 ; words = [ ] for i in range ( 0 , n ) : words . append ( input ( ) ) for word in words : if password [ 0 ] == word [ 1 ] : first = 1 if password [ 1 ] == word [ 0 ] : second = 1 if password == word : first = second = 1 if first == second == 1 : print ( \" YES \" ) sys . exit ( 0 ) print ( \" NO \" ) NEW_LINE"],"bleu":0.13587169278190453,"rouge_l":0.40187239944521497}
{"id":396,"predictions":["n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = 0 NEW_LINE for i in range ( n ) : NEW_LINE if s [ i ] == \" \" : NEW_LINE INDENT s += 1 NEW_LINE DEDENT if s == m : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"],"references":["for _ in range ( int ( input ( ) ) ) : n , m = map ( int , input ( ) . split ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if m == sum ( arr ) : print ( ' YES ' )   else : print ( ' NO ' ) NEW_LINE"],"bleu":0.4221964050740311,"rouge_l":0.6016026299568523}
{"id":397,"predictions":["w , m , k = map ( int , input ( ) . split ( ) ) x = 10 ** 9 + 7 y = list ( map ( int , input ( ) . split ( ) ) ) y = list ( map ( int , input ( ) . split ( ) ) ) dp = [ [ 0 ] * 10 + [ 18 ] * 10 for i in range ( 10 ) ] for i in range ( 1 , 18 ) : dp [ i ] [ 0 ] = dp [ i ] [ 1 ] for i in range ( 1 , 18 ) : dp [ i ] [ 0 ] = min ( dp [ i ] [ 0 ] , dp [ i ] [ 1 ] ) NEW_LINE"],"references":["w , m , k = map ( int , input ( ) . split ( ) ) z = mdig = 0 while z > 0 : dig += 1 ; z = z \/\/ 10 if ( dig * k > w ) : print ( 0 ) exit ( 0 ) lo = m - 1 hi = w + m + 5 while lo + 1 < hi : mid = ( lo + hi ) \/\/ 2 cost , t , d = 0 , 0 , 0 x = mid while x > 0 : x = x \/\/ 10 d += 1 if ( d == dig ) : cost = ( mid - m + 1 ) * d * k else : t = pow ( 10 , dig ) last = m c = dig while t <= mid : cost += ( t - last ) * c * k c += 1 last = t t = t * 10 t = t \/\/ 10 cost += ( mid - t + 1 ) * c * k if ( cost <= w ) : lo = mid else : hi = midprint ( lo - m + 1 ) NEW_LINE"],"bleu":0.11262504032024276,"rouge_l":0.2712799074979988}
{"id":398,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) m = sum ( a ) ans = 0 for i in range ( len ( a ) ) : if b [ i ] >= 2 : ans += i else : ans += 1 print ( ans ) NEW_LINE"],"references":["from collections import Counterfrom itertools import combinations   if __name__ == ' _ _ main _ _ ' : n = int ( input ( ) ) a = [ int ( i ) for i in input ( ) . split ( ) ] s = sum ( a ) t = s s \/= 2   while n > 0 and t > s : t -= a [ n - 1 ] n -= 1 print ( n + 1 if t < s else n ) NEW_LINE"],"bleu":0.2520492885030552,"rouge_l":0.4086479902557856}
{"id":399,"predictions":["for _ in range ( input ( ) ) : n = int ( input ( ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( ' - ' , end = ' ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' ' . join ( map ( str , str ) ) ) NEW_LINE DEDENT"],"references":["from sys import stdin , stdoutfrom math import floor , gcd , fabs , factorial , fmod , sqrt , inf , logfrom collections import defaultdict as dd , dequefrom heapq import merge , heapify , heappop , heappush , nsmallestfrom bisect import bisect_left as bl , bisect_right as br , bisect mod = pow ( 10 , 9 ) + 7 mod2 = 998244353 def inp ( ) : return stdin . readline ( ) . strip ( ) def iinp ( ) : return int ( inp ( ) ) def out ( var , end = \" \\n \" ) : stdout . write ( str ( var ) + \" \\n \" ) def outa ( * var , end = \" \\n \" ) : stdout . write ( ' ▁ ' . join ( map ( str , var ) ) + end ) def lmp ( ) : return list ( mp ( ) ) def mp ( ) : return map ( int , inp ( ) . split ( ) ) def smp ( ) : return map ( str , inp ( ) . split ( ) ) def l1d ( n , val = 0 ) : return [ val for i in range ( n ) ] def l2d ( n , m , val = 0 ) : return [ l1d ( m , val ) for j in range ( n ) ] def remadd ( x , y ) : return 1 if x % y else 0 def ceil ( a , b ) : return ( a + b - 1 ) \/\/ b def isprime ( x ) : if x <= 1 : return False if x in ( 2 , 3 ) : return True if x % 2 == 0 : return False for i in range ( 3 , int ( sqrt ( x ) ) + 1 , 2 ) : if x % i == 0 : return False return True n = iinp ( ) s = inp ( ) for i in range ( n ) : print ( s [ i ] , end = ' ' ) if n - i >= 3 and i % 2 : print ( ' - ' , end = ' ' ) print ( ) NEW_LINE"],"bleu":0.0014938236924846293,"rouge_l":0.12631777108433737}
{"id":400,"predictions":["import sysfrom os import pathif ( path . exists ( ' a ' ) ) : sys . stdout = open ( \" input . txt \" , \" r \" ) sys . stdout = open ( \" output . txt \" , \" w \" ) sys . stdout = open ( \" input . txt \" , \" r \" )   t = int ( input ( ) ) for _ in range ( t ) : n = int ( input ( ) ) l = input ( ) . split ( ) li = [ ] ans = [ ] for i in range ( n ) : s . append ( input ( ) ) for i in range ( n ) : if ( s [ i ] > 100 ) : if ( s [ i ] >= 100 ) : ans . append ( True ) else : ans . append ( 0 ) l = list ( ans ) for i in range ( n ) : if ( l [ i ] >= 100 ) : print ( \" YES \" ) for i in range ( n ) : print ( \" NO \" ) else : print ( \" NO \" ) NEW_LINE"],"references":["def p2 ( a ) : n = len ( a ) last = [ [ - 1 ] * 26 for _ in range ( n ) ] last [ 0 ] [ ord ( a [ 0 ] ) - 97 ] = 0 for i in range ( 1 , n ) : for j in range ( 26 ) : last [ i ] [ j ] = last [ i - 1 ] [ j ] last [ i ] [ ord ( a [ i ] ) - 97 ] = i dp = [ ' ' ] * n for i in range ( n - 1 , - 1 , - 1 ) : for j in range ( n - 1 , i , - 1 ) : k = last [ j ] [ ord ( a [ i ] ) - 97 ] if k > i : if ( k - i ) == 1 and len ( dp [ j ] ) < 2 : dp [ j ] = a [ i ] + a [ i ] elif len ( dp [ j ] ) < ( len ( dp [ k - 1 ] ) + 2 ) : dp [ j ] = a [ i ] + dp [ k - 1 ] + a [ i ] if len ( dp [ j ] ) >= 100 : if len ( dp [ j ] ) == 101 : return dp [ j ] [ : 50 ] + dp [ j ] [ 51 : ] else : return dp [ j ] dp [ i ] = a [ i ] return dp [ n - 1 ]     a = input ( ) print ( p2 ( a ) ) NEW_LINE"],"bleu":0.10969154619100183,"rouge_l":0.288062645705063}
{"id":401,"predictions":["n = int ( input ( ) ) arr = sorted ( map ( int , input ( ) . split ( ) ) )   print ( arr [ n \/\/ 2 ] ) NEW_LINE"],"references":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) p = [ 0 ] * nfor i in range ( n ) : p [ a [ i ] - 1 ] = i + 1 s = 0 for i in range ( n - 1 ) : s += abs ( p [ i ] - p [ i + 1 ] ) print ( s ) NEW_LINE"],"bleu":0.15302951512065016,"rouge_l":0.44269269269269274}
{"id":402,"predictions":["from math import factorialn = int ( input ( ) ) NEW_LINE"],"references":["def count ( a ) : n = len ( a ) cnt = 0 for i in range ( n ) : for j in range ( i + 1 , n ) : if a [ i ] > a [ j ] : cnt += 1 return cnt                       n = int ( input ( ) ) p = list ( map ( int , input ( ) . split ( ) ) ) num = count ( p )   print ( num * 2 - num % 2 ) NEW_LINE"],"bleu":0.0006974231579920944,"rouge_l":0.1099099099099099}
{"id":403,"predictions":["n , f = map ( int , input ( ) . split ( ) ) gain = [ ] sold = 0 for i in range ( n ) : k , l = map ( int , input ( ) . split ( ) ) sold += min ( l , k ) if l == 0 or k == 0 or l == k : gain . append ( 0 ) else : if 2 * k > l : gain . append ( l - k ) else : gain . append ( k )   gain = sorted ( gain , reverse = True ) for i in range ( f ) : sold += gain [ i ] print ( sold ) NEW_LINE"],"references":["def STR ( ) : return list ( input ( ) ) def INT ( ) : return int ( input ( ) ) def MAP ( ) : return map ( int , input ( ) . split ( ) ) def MAP2 ( ) : return map ( float , input ( ) . split ( ) ) def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) def STRING ( ) : return input ( ) import stringimport sysfrom heapq import heappop , heappushfrom bisect import * from collections import deque , Counter , defaultdictfrom math import * from itertools import permutations , accumulatedx = [ - 1 , 1 , 0 , 0 ] dy = [ 0 , 0 , 1 , - 1 ] NEW_LINE"],"bleu":0.20147467069954966,"rouge_l":0.3146215665107352}
{"id":404,"predictions":["import mathfor _ in range ( 1 ) : n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) g = 0 for i in range ( len ( a ) ) : g = math . gcd ( a [ i ] , g ) maxi = max ( a ) \/\/ g if ( n - maxi ) % 2 == 0 : print ( \" Bob \" ) else : print ( \" Alice \" ) NEW_LINE"],"references":["sum , xor = map ( int , input ( ) . split ( ) )   andr = ( sum - xor ) \/ 2   if sum < xor or ( sum - xor ) % 2 == 1 or int ( andr ) & xor : print ( 0 ) else : perm = 2 ** bin ( xor ) . count ( \"1\" ) if sum == xor : perm = perm - 2 print ( perm ) NEW_LINE"],"bleu":0.21621486830326667,"rouge_l":0.37534961775125864}
{"id":405,"predictions":["n = int ( input ( ) ) s = input ( ) a = [ m for i in range ( 9 ) ] a = [ 0 for i in range ( n ) ] b = [ 0 for i in range ( n ) ] a = ord ( a [ i ] ) - ord ( '0' ) ] c = 0 for i in range ( n ) : if ord ( a [ i ] ) - ord ( '0' ) == ord ( '0' ) : c = 1 breakprint ( \" YES \" ) NEW_LINE"],"references":["import sys   n = int ( sys . stdin . readline ( ) ) digits = [ int ( x ) for x in sys . stdin . readline ( ) . strip ( ) ]   NEW_LINE"],"bleu":0.059521739431742667,"rouge_l":0.28946053946053946}
{"id":406,"predictions":["def gcd ( a , b ) : if ( a % b == 0 ) : return b else : return gcd ( b , a % b )   [ t1 , t2 , x1 , t1 , t2 ] = input ( ) . split ( ' ▁ ' ) NEW_LINE"],"references":["r = lambda : list ( map ( int , input ( ) . split ( ) ) ) arr = r ( ) size = \" S , ▁ M , ▁ L , ▁ XL , ▁ XXL \" . split ( \" , ▁ \" ) NEW_LINE"],"bleu":0.14505210379122876,"rouge_l":0.3292063492063492}
{"id":407,"predictions":["def main ( ) : t = int ( input ( ) ) for _ in range ( t ) : n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) if n == 1 : print ( \" NO \" ) elif n == 2 : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"references":["for _ in range ( int ( input ( ) ) ) : a , b = map ( int , input ( ) . split ( ) ) x = set ( map ( int , input ( ) . split ( ) ) ) y = set ( map ( int , input ( ) . split ( ) ) ) z = x . intersection ( y ) if len ( z ) : print ( \" YES \" ) print ( 1 , list ( z ) [ 0 ] ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.37693226848949324,"rouge_l":0.5380137590403951}
{"id":408,"predictions":["def solve ( ) : n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) d = { } for i in range ( len ( a ) ) : if a [ i ] not in d : d [ a [ i ] ] = 1 else : d [ a [ i ] ] = 1 if d . get ( d [ i ] , ' ▁ ' ) : d [ a [ i ] ] = 1 else : d [ i ] = 1 print ( max ( d . values ( ) ) ) NEW_LINE"],"references":["def solution ( ) : st1 = input ( ) st2 = input ( )   dicty1 = { } dicty2 = { } LET = ' ABCDEFGHIJKLMNOPQRSTUVWXYZ ' LET += LET . lower ( )   for c in LET : dicty1 [ c ] = 0 dicty2 [ c ] = 0   for c in st1 : if c != ' ▁ ' : dicty1 [ c ] += 1   for c in st2 : if c != ' ▁ ' : dicty2 [ c ] += 1     for c in dicty2 : if dicty2 [ c ] > dicty1 [ c ] : print ( ' NO ' ) return print ( ' YES ' ) \t         return         solution ( ) NEW_LINE"],"bleu":0.0741896221929019,"rouge_l":0.3405227099720883}
{"id":409,"predictions":["from sys import stdin , stdoutfrom os import pathrd = lambda : stdin . readline ( ) . strip ( ) wr = stdout . writeif ( path . exists ( ' input . txt ' ) ) : stdin = open ( \" input . txt \" , \" r \" ) import time , math NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) d = { } ans = cnt = 0 for i in map ( int , input ( ) . split ( ) ) : d [ i ] = d . get ( i , 0 ) + 1 for i in range ( 1 , m + 1 ) : cnt = 0 for v in d . items ( ) : cnt += v [ 1 ] \/\/ i if cnt >= n : ans = iprint ( ans ) NEW_LINE"],"bleu":0.039218107598428115,"rouge_l":0.24158415841584158}
{"id":410,"predictions":["import sys , os , ioimport math , bisect , operatorinf , mod = float ( ' inf ' ) , 10 ** 9 + 7 NEW_LINE"],"references":["a , b , c = map ( int , input ( ) . split ( ) )   while c >= 0 : if c % b == 0 : print ( ' Yes ' ) break c -= aelse : print ( ' No ' ) NEW_LINE"],"bleu":0.04061036834064014,"rouge_l":0.2000820008200082}
{"id":411,"predictions":["for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE f = True NEW_LINE for i in arr : NEW_LINE INDENT if f : NEW_LINE INDENT f = i NEW_LINE break NEW_LINE DEDENT DEDENT print ( f ) NEW_LINE"],"references":["for s in [ * open ( 0 ) ] [ 2 : : 2 ] : NEW_LINE INDENT b = [ 0 ] ; NEW_LINE r = 0 NEW_LINE for x in s . split ( ) : b += - 1 , ; b [ max ( - len ( b ) , ~ int ( x ) ) ] += 1 NEW_LINE for x in b [ : - 1 ] : r += x ; print ( + ( r > 0 ) ) NEW_LINE DEDENT"],"bleu":0.09073990936188217,"rouge_l":0.29486404833836855}
{"id":412,"predictions":["import matht = int ( input ( ) ) for _ in range ( t ) : n = int ( input ( ) ) a , b , c = map ( int , input ( ) . split ( ) ) st = input ( ) ans = 0 st1 = \" \" for x in st : if ( x == \" R \" and b > 0 ) : ans += 1 b -= 1 st1 += \" P \" elif ( x == \" S \" and a > 0 ) : ans += 1 a -= 1 st1 += \" S \" elif ( x == \" P \" and b > 0 ) : ans += 1 c -= 1 st1 += \" S \" else : st1 += \" * \"   ans_str = \" \" for x in st1 : if ( x == ' * ' ) : if ( a > 0 ) : ans_str += \" R \" a -= 1 elif ( b > 0 ) : ans_str += \" P \" c -= 1 elif ( c > 0 ) : ans_str += \" S \" c -= 1 else : ans_str += x if ( ans >= math . ceil ( n \/ 2 ) ) : print ( \" YES \" ) print ( ans_str ) else : print ( \" NO \" )                                                                         NEW_LINE"],"references":["import sys   def main ( ) :   for _ in range ( int ( sys . stdin . readline ( ) . strip ( ) ) ) : n = int ( sys . stdin . readline ( ) . strip ( ) ) arr = list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) i = 0 while i < n and arr [ i ] >= i : i += 1 j = n - 1 while j >= 0 and arr [ j ] >= ( n - j - 1 ) : j -= 1 if ( i - j ) == 1 and arr [ i ] == arr [ j ] : print ( ' No ' ) elif i > j : print ( \" Yes \" ) else : print ( \" No \" )   main ( ) NEW_LINE"],"bleu":0.14748445950271155,"rouge_l":0.2982340922358436}
{"id":413,"predictions":["if __name__ == ' _ _ main _ _ ' : for _ in ' : input = input ( ) a = list ( input ( ) ) for i in range ( len ( a ) ) : if int ( a [ i ] ) > int ( a [ i ] ) : int ( a [ i ] ) > 2 : int ( a [ i ] ) ans = max ( ans , to ) print ( ans ) NEW_LINE"],"references":["import syss1 , s2 = input ( ) . split ( \" : \" ) def convert ( n , base ) : ans = 0 for i in range ( len ( n ) ) : x = 0 if n [ i ] . isalpha ( ) : x = int ( ord ( n [ i ] ) - ord ( ' A ' ) + 10 ) else : x = int ( n [ i ] ) ans += x * pow ( base , len ( n ) - i - 1 ) return answork = [ ] minm = 0 for c in s1 + s2 : if c . isalpha ( ) : minm = max ( minm , ord ( c ) - ord ( ' A ' ) + 10 ) else : minm = max ( minm , int ( c ) )   for base in range ( max ( minm + 1 , 2 ) , 60 ) : if convert ( s1 , base ) < 24 and convert ( s2 , base ) < 60 : work . append ( base ) else : breakif len ( work ) == 0 : print ( 0 ) elif ( len ( s1 ) == 1 or s1 [ : len ( s1 ) - 1 ] == '0' * ( len ( s1 ) - 1 ) ) and ( len ( s2 ) == 1 or s2 [ : len ( s2 ) - 1 ] == '0' * ( len ( s2 ) - 1 ) ) : print ( - 1 ) else : print ( \" ▁ \" . join ( map ( str , work ) ) ) NEW_LINE"],"bleu":0.025497073321573013,"rouge_l":0.22692397116949545}
{"id":414,"predictions":["n , k = [ int ( x ) for x in input ( ) . split ( ) ] a = list ( map ( int , input ( ) . split ( ) ) ) for x in range ( k ) : if a [ x ] == a [ n - 1 ] : print ( - 1 ) else : print ( - 1 ) NEW_LINE"],"references":["def solution ( ) : n , k = map ( int , input ( ) . split ( ) )   arr = list ( map ( int , input ( ) . split ( ) ) )   k -= 1 num = arr [ k ] for i in range ( k , n ) : if arr [ i ] != num : print ( - 1 ) return   curr = k - 1 while curr >= 0 and arr [ curr ] == num : curr -= 1   \t   print ( curr + 1 )     return         solution ( ) NEW_LINE"],"bleu":0.3274333313799591,"rouge_l":0.5187957135567273}
{"id":415,"predictions":["s = input ( ) s1 = s . count ( ' L ' ) s2 = s . count ( ' R ' ) if s1 != 0 and s2 > 0 : print ( ' L ' ) elif s1 > 0 : print ( ' L ' ) else : print ( ' U ' ) NEW_LINE"],"references":["a = input ( ) b = input ( ) c = 8   print ( max ( max ( ord ( a [ 0 ] ) , ord ( b [ 0 ] ) ) - min ( ord ( a [ 0 ] ) , ord ( b [ 0 ] ) ) , max ( int ( a [ 1 ] ) , int ( b [ 1 ] ) ) - min ( int ( a [ 1 ] ) , int ( b [ 1 ] ) ) ) ) d = ord ( a [ 0 ] ) - ord ( b [ 0 ] ) e = int ( a [ 1 ] ) - int ( b [ 1 ] ) while c > 0 : c -= 1 if d < 0 : if d != 0 : d += 1 print ( \" R \" , end = \" \" ) if d > 0 : print ( \" L \" , end = \" \" ) d -= 1 if e < 0 : print ( \" U \" , end = \" \" ) e += 1 if e > 0 : e -= 1 print ( \" D \" , end = \" \" ) print ( )       NEW_LINE"],"bleu":0.01436831104231402,"rouge_l":0.190625}
{"id":416,"predictions":["n = int ( input ( ) ) b = [ list ( map ( int , input ( ) . split ( ' ▁ ' ) ) ) for i in range ( 4 ) ]   for j in range ( 4 ) : if b [ i ] [ j ] == 1 : s = ( int ( b ) [ i ] [ j ] ) * ( i + 1 )   print ( s ) NEW_LINE"],"references":["def f ( t ) : z = 1.000000011 p = 1 while t : if t % 2 : t -= 1 p *= z else : t \/\/= 2 z *= z return pn , t = map ( int , input ( ) . split ( ) ) print ( n * f ( t ) ) NEW_LINE"],"bleu":0.18493760555628713,"rouge_l":0.29992975883867945}
{"id":417,"predictions":["n , m = map ( int , input ( ) . split ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) : arr [ i ] = list ( map ( int , input ( ) . split ( ) ) ) if arr [ - 1 ] [ 0 ] != arr [ - 2 ] [ 1 ] : print ( \" NO \" ) else : print ( \" YES \" ) NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) ; a = list ( map ( int , input ( ) . split ( ) ) )   b = [ ( list ( map ( int , input ( ) . split ( ) ) ) ) for i in range ( m ) ]   count = 0 for i in range ( m ) : sum = 0 ; for j in range ( b [ i ] [ 0 ] - 1 , b [ i ] [ 1 ] ) : sum += a [ j ]   if ( sum > 0 ) : count += sum     print ( count ) NEW_LINE"],"bleu":0.46744254685126846,"rouge_l":0.5795307326903699}
{"id":418,"predictions":["import mathn = int ( input ( ) ) NEW_LINE"],"references":["n = int ( input ( ) ) m = list ( map ( int , input ( ) . split ( ) ) ) gc = m [ 0 ] import mathfor i in range ( 1 , n ) : gc = math . gcd ( gc , m [ i ] ) k = max ( m ) prime = [ 0 ] * ( k + 1 ) pfac = [ 0 ] * ( k + 1 ) for i in range ( 2 , k + 1 ) : if prime [ i ] == 0 : for j in range ( i * i , k + 1 , i ) : prime [ j ] = ifor i in range ( 1 , k + 1 ) : if not prime [ i ] : prime [ i ] = ifor i in range ( n ) : v = m [ i ] \/\/ gc while v > 1 : fac = prime [ v ] pfac [ fac ] += 1 while v % fac == 0 : v \/\/= facma = 0 ma = max ( pfac ) if ma : print ( n - ma ) else : print ( - 1 ) NEW_LINE"],"bleu":8.39276741407062e-10,"rouge_l":0.06080239222526788}
{"id":419,"predictions":["import mathn , k = map ( int , input ( ) . split ( ) ) m = [ int ( x ) for x in input ( ) . split ( ) ] if k == 1 : print ( n ) exit ( 0 ) if k > 1 : print ( 0 ) exit ( 0 ) else : if m > n % p = [ int ( x ) for x in input ( ) . split ( ) ] for i in range ( k ) : if n % p == 0 : print ( i ) exit ( ) print ( - 1 )     NEW_LINE"],"references":["import mathn , k = map ( int , input ( ) . split ( ) )   result = [ ]   while ( n % 2 == 0 ) : result . append ( 2 ) n = n \/\/ 2   NEW_LINE"],"bleu":0.18472555968181095,"rouge_l":0.431858407079646}
{"id":420,"predictions":["n = int ( input ( ) ) s = input ( ) if ( n == - 1 ) : if ( s [ : : - 1 ] != '0' ) : print ( s [ : n - 1 ] ) else : s = list ( s [ : ] ) for i in range ( n - 1 , - 1 ) : if ( s [ i ] == '0' ) : s . remove ( i ) print ( s [ : i ] ) NEW_LINE"],"references":["for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) li = list ( map ( int , input ( ) ) ) od = 0 ev = 0 res = [ ] cnt = 0 for i in range ( n ) : if li [ i ] % 2 == 0 : res . append ( li [ i ] ) else : cnt += 1 res . append ( li [ i ] ) if cnt == 2 : break if res [ - 1 ] % 2 != 0 and cnt >= 2 : print ( * res , sep = ' ' ) else : print ( - 1 )   NEW_LINE"],"bleu":0.20585036318085673,"rouge_l":0.3607384970431271}
{"id":421,"predictions":["n , m = map ( int , input ( ) . split ( ) ) r = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( 1 , n + 1 ) ]   graph = [ [ ] for i in range ( n ) ]   for i in range ( m ) : v , v = map ( int , input ( ) . split ( ) ) graph [ v ] . append ( [ v ] ) graph [ v ] . append ( ( v , True ) ) for i in range ( n ) : for j in range ( m ) : x = map ( int , input ( ) . split ( ) ) graph [ i ] [ j ] = Truegraph [ i ] [ j ] . append ( ( i , j ) )   graph = { } s = 0 for i in range ( n ) : i = 0 for j in range ( m ) : x , y = map ( int , input ( ) . split ( ) ) ) graph [ u ] . append ( d [ v ] )   graph [ u ] . append ( i ) for j in range ( m ) : graph [ i ] . append ( i ) NEW_LINE"],"references":["import osimport sysfrom io import BytesIO , IOBaseBUFSIZE = 8192 class FastIO ( IOBase ) : newlines = 0 def __init__ ( self , file ) : self . _fd = file . fileno ( ) self . buffer = BytesIO ( ) self . writable = \" x \" in file . mode or \" r \" not in file . mode self . write = self . buffer . write if self . writable else None def read ( self ) : while True : b = os . read ( self . _fd , max ( os . fstat ( self . _fd ) . st_size , BUFSIZE ) ) if not b : break ptr = self . buffer . tell ( ) self . buffer . seek ( 0 , 2 ) , self . buffer . write ( b ) , self . buffer . seek ( ptr ) self . newlines = 0 return self . buffer . read ( ) def readline ( self ) : while self . newlines == 0 : b = os . read ( self . _fd , max ( os . fstat ( self . _fd ) . st_size , BUFSIZE ) ) self . newlines = b . count ( b \" \\n \" ) + ( not b ) ptr = self . buffer . tell ( ) self . buffer . seek ( 0 , 2 ) , self . buffer . write ( b ) , self . buffer . seek ( ptr ) self . newlines -= 1 return self . buffer . readline ( ) def flush ( self ) : if self . writable : os . write ( self . _fd , self . buffer . getvalue ( ) ) self . buffer . truncate ( 0 ) , self . buffer . seek ( 0 ) class IOWrapper ( IOBase ) : def __init__ ( self , file ) : self . buffer = FastIO ( file ) self . flush = self . buffer . flush self . writable = self . buffer . writable self . write = lambda s : self . buffer . write ( s . encode ( \" ascii \" ) ) self . read = lambda : self . buffer . read ( ) . decode ( \" ascii \" ) self . readline = lambda : self . buffer . readline ( ) . decode ( \" ascii \" ) sys . stdin , sys . stdout = IOWrapper ( sys . stdin ) , IOWrapper ( sys . stdout ) input = lambda : sys . stdin . readline ( ) . rstrip ( \" \\n \" ) NEW_LINE"],"bleu":0.019148527864012818,"rouge_l":0.2410961310438716}
{"id":422,"predictions":["n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( 1 , n + 1 ) : if i % 3 != 0 and j % 3 != 0 : print ( i , j ) break NEW_LINE"],"references":["n = int ( input ( ) ) q = n \/\/ 3 r = n % 3 if ( r == 0 ) : if ( q % 3 != 0 ) : print ( q , q , q ) else : print ( q + 2 , q - 1 , q - 1 ) elif ( r == 1 ) : if ( q % 3 != 0 and ( q + 1 ) % 3 != 0 ) : print ( q , q , q + 1 ) elif ( q % 3 != 0 and ( q + 1 ) % 3 == 0 ) : print ( q - 1 , q , q + 2 ) elif ( q % 3 == 0 and ( q + 1 ) % 3 != 0 ) : print ( q - 1 , q + 1 , q + 1 ) else : if ( q % 3 != 0 and ( q + 2 ) % 3 != 0 ) : print ( q , q , q + 2 ) elif ( q % 3 != 0 and ( q + 2 ) % 3 == 0 ) : print ( q , q + 1 , q + 1 ) elif ( q % 3 == 0 and ( q + 2 ) % 3 != 0 ) : print ( q - 1 , q + 1 , q + 2 ) NEW_LINE"],"bleu":0.011689642308850093,"rouge_l":0.2360770247309798}
{"id":423,"predictions":["n = int ( input ( ) ) s = input ( ) if ( n == 1 ) : print ( s1 = '0' + s . count ( '1' ) ) elif n == 1 : print ( s1' ) else : ans = 0 for i in range ( n - 1 , - 1 ) : if ( s [ i ] == '1' ) : ans += s [ i ] print ( ans ) NEW_LINE"],"references":["n = int ( input ( ) ) p , s , t = 1 , 0 , \"1\" for x in input ( ) . split ( ) : if x == \"0\" : print ( 0 ) quit ( ) elif x == \"1\" + \"0\" * ( len ( x ) - 1 ) : s += len ( x ) - 1 else : t = str ( x ) print ( t + \"0\" * s ) NEW_LINE"],"bleu":0.21883417444593148,"rouge_l":0.4258926790345103}
{"id":424,"predictions":["for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) print ( 1 , n - 1 ) NEW_LINE"],"references":["for i in [ * open ( 0 ) ] [ 1 : ] : print ( int ( i ) - 1 , 1 ) NEW_LINE"],"bleu":0.15245978266016233,"rouge_l":0.46051103368176527}
{"id":425,"predictions":["import matht = int ( input ( ) ) for _ in range ( t ) : n = int ( input ( ) ) a , b , c = map ( int , input ( ) . split ( ) ) st = input ( ) ans = 0 st1 = \" \" for x in st : if ( x == \" R \" and b > 0 ) : ans += 1 b -= 1 st1 += \" P \" elif ( x == \" S \" and a > 0 ) : ans += 1 a -= 1 st1 += \" S \" elif ( x == \" P \" and c > 0 ) : ans += 1 c -= 1 st1 += \" S \" else : st1 += \" * \"   ans_str = \" \" for x in st1 : if ( x == ' * ' ) : if ( a > 0 ) : ans_str += \" R \" c -= 1 elif ( b > 0 ) : ans_str += \" P \" c -= 1 elif ( c > 0 ) : ans_str += \" S \" c -= 1 else : ans_str += x if ( ans >= math . ceil ( n \/ 2 ) ) print ( ans_str ) print ( ans_str ) else : print ( \" \" . join ( ans_str ) ) NEW_LINE"],"references":["import mathfrom collections import deque     def Work ( ) : n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) IDX = [ 0 ] * n   for i in range ( n ) : IDX [ a [ i ] - 1 ] = i   l , r = n , 0 s = \" \"   for i in range ( n ) : l , r = min ( l , IDX [ i ] ) , max ( r , IDX [ i ] ) s += '1' if r - l == i else '0'   print ( s )     if __name__ == \" _ _ main _ _ \" : t = int ( input ( ) ) for _ in range ( t ) : Work ( ) NEW_LINE"],"bleu":0.1908320538147105,"rouge_l":0.3388309690651171}
{"id":426,"predictions":["for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) + [ 0 ] ans [ ] = 0 for i in range ( n ) : for j in range ( i + 1 , n - 1 ) : if a [ i ] [ j ] == 1 : ans [ i ] [ j ] = ans [ i ] [ j ] = 1 else : ans [ i ] [ j ] = 1 for i in range ( n - 1 , - 1 , - 1 ) : if ans [ i ] [ j ] == 1 : ans [ i ] [ j ] = ans [ i ] [ j ] = ans [ j ] [ i ] = 1 print ( ans [ n - 1 ] ) for i in range ( n - 1 ) : print ( \" ▁ \" . join ( ans [ i ] ) ) NEW_LINE"],"references":["( k , n , m ) = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( k ) : s = input ( ) NEW_LINE a . append ( [ ] ) NEW_LINE for j in range ( n ) : a [ - 1 ] . append ( list ( input ( ) ) ) NEW_LINE s = input ( ) ( x , y ) = map ( int , input ( ) . split ( ) ) NEW_LINE x -= 1 NEW_LINE y -= 1   start = ( 0 , x , y ) NEW_LINE sosed = set ( ) NEW_LINE sosed . add ( start ) NEW_LINE posetil = set ( ) NEW_LINE posetil . add ( start ) NEW_LINE while len ( sosed ) > 0 : sosed2 = set ( ) NEW_LINE for i in sosed : for NEW_LINE dk in [ - 1 , 0 , 1 ] : NEW_LINE for dx in [ - 1 , 0 , 1 ] : for NEW_LINE dy in [ - 1 , 0 , 1 ] : NEW_LINE if abs ( dk ) + abs ( dx ) + abs ( dy ) == 1 : if NEW_LINE ( i [ 0 ] + dk < k ) and ( i [ 0 ] + dk >= 0 ) and ( i [ 1 ] + dx < n ) and ( i [ 1 ] + dx >= 0 ) and ( i [ 2 ] + dy < m ) and ( i [ 2 ] + dy >= 0 ) : NEW_LINE if a [ i [ 0 ] + dk ] [ i [ 1 ] + dx ] [ i [ 2 ] + dy ] == ' . ' : if NEW_LINE ( i [ 0 ] + dk , i [ 1 ] + dx , i [ 2 ] + dy ) in posetil : NEW_LINE continue else : posetil . add ( ( i [ 0 ] + dk , i [ 1 ] + dx , i [ 2 ] + dy ) ) NEW_LINE sosed2 . add ( ( i [ 0 ] + dk , i [ 1 ] + dx , i [ 2 ] + dy ) ) NEW_LINE sosed = sosed2 . copy ( ) NEW_LINE print ( len ( posetil ) ) NEW_LINE"],"bleu":0.08799500416571386,"rouge_l":0.29629444166249375}
{"id":427,"predictions":["s = input ( ) NEW_LINE for i in range ( s [ i : i + 1 ] ) : NEW_LINE"],"references":["t = int ( input ( ) )   for i in range ( t ) : p = input ( ) h = input ( ) cnts = { } for c in p : cnts [ c ] = cnts . get ( c , 0 ) + 1 yes = False for i in range ( len ( h ) ) : seq = { } for c in h [ i : ] : yes |= seq == cnts if c not in cnts : seq = { } else : seq [ c ] = seq . get ( c , 0 ) + 1 yes |= seq == cnts print ( \" YES \" if yes else \" NO \" ) NEW_LINE"],"bleu":0.0036384279133197155,"rouge_l":0.20104691740984876}
{"id":428,"predictions":["n , m , k = map ( int , input ( ) . split ( ) ) cells = 0 for i in range ( 0 , m ) : cells += 2 * ( m + n - 2 - i * ( 8 ) ) print ( cells ) NEW_LINE"],"references":["v1 , v2 = map ( int , input ( ) . split ( ) ) t , d = map ( int , input ( ) . split ( ) ) t -= 1 u = [ 0 ] * ( t + 1 ) u [ 0 ] = v1for i in range ( 1 , t + 1 ) : u [ i ] = min ( u [ i - 1 ] + d , v2 + ( t - i ) * d ) ans = 0 for i in range ( 0 , t + 1 ) : ans += u [ i ] print ( ans ) NEW_LINE"],"bleu":0.145495816300468,"rouge_l":0.3906678865507777}
{"id":429,"predictions":["n , k = map ( int , input ( ) . strip ( ) . split ( ' ▁ ' ) ) NEW_LINE"],"references":["n = int ( input ( ) ) a = sorted ( [ int ( x ) for x in input ( ) . split ( ) ] ) s = sum ( a ) if a [ 0 ] != 0 : print ( - 1 ) exit ( 0 ) if s % 3 != 0 : for x in a : if x % 3 == s % 3 : a . remove ( x ) break else : for x in a : if x % 3 : a . remove ( x ) break for x in a : if x % 3 : a . remove ( x ) breakwhile len ( a ) > 1 and a [ - 1 ] == 0 : a . pop ( ) a = a [ : : - 1 ] print ( ' ' . join ( str ( x ) for x in a ) ) NEW_LINE"],"bleu":0.001068751886930923,"rouge_l":0.16032776747062458}
{"id":430,"predictions":["import math   def main ( ) : n , a = map ( int , input ( ) . split ( ) ) c = math . ceil ( n \/ 2 ) if c == n : print ( \" Final ! \" ) else : cnt = 0 for i in range ( len ( n ) ) : if a [ i ] == i : cnt += 1 else : cnt += 1 print ( cnt ) NEW_LINE"],"references":["import math   n , a , b = map ( int , input ( ) . split ( ' ▁ ' ) ) rounds = math . log ( n , 2 ) r = int ( rounds ) for i in range ( 1 , int ( rounds ) + 1 ) : a = math . ceil ( a \/ 2 ) b = math . ceil ( b \/ 2 ) if ( a == b ) : if ( i == r ) : print ( ' Final ! ' ) break else : print ( i ) break NEW_LINE"],"bleu":0.26707031015918437,"rouge_l":0.5000853970964987}
{"id":431,"predictions":["for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) print ( n \/\/ 2 ) NEW_LINE"],"references":["for x in range ( int ( input ( ) ) ) : n = int ( input ( ) ) if n % 2 == 0 : print ( n \/\/ 2 ) else : print ( ( n \/\/ 2 ) + 1 ) NEW_LINE"],"bleu":0.4349752704153352,"rouge_l":0.6885451505016723}
{"id":432,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 8 ) : NEW_LINE"],"references":["if __name__ == ' _ _ main _ _ ' : cin = input a = [ cin ( ) for i in range ( 8 ) ] mw , mb = 8 , 8   for c in range ( 8 ) : for r in range ( 8 ) : if a [ r ] [ c ] == \" W \" : mw = min ( mw , r ) if a [ r ] [ c ] != \" . \" : break for r in range ( 7 , - 1 , - 1 ) : if a [ r ] [ c ] == \" B \" : mb = min ( mb , 7 - r ) if a [ r ] [ c ] != \" . \" : break print ( \" AB \" [ mb < mw ] ) NEW_LINE"],"bleu":0.02043955895440052,"rouge_l":0.1669961977186312}
{"id":433,"predictions":["n , k = map ( int , input ( ) . split ( ) ) s = 1 l = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( 1 , n - 1 ) : if s [ i ] != 1 : l [ i ] = 1 elif s [ i ] == 1 : l [ len ( l ) - 1 ] = 1 l [ 0 ] += 1 else : l [ len ( l ) - 1 ] = 1 l [ 0 ] = 1 for i in range ( 1 , n ) : if l [ i ] < k [ i - 1 ] : l [ k - i ] = max ( l [ i - k ] , l [ k - 1 ] ) - 1 : l [ k ] = max ( l [ k - 1 ] , l [ k - 1 ] ) print ( * l ) NEW_LINE"],"references":["while True : try : n , m = list ( map ( int , input ( ) . split ( ) ) ) res = 1 while m % 2 == 0 : res += 1 m \/= 2 print ( res ) except : break NEW_LINE"],"bleu":0.10630958386068949,"rouge_l":0.2720611659764256}
{"id":434,"predictions":["t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : q , d = map ( int , input ( ) . split ( ) ) NEW_LINE ali = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE q = 23 * 60 NEW_LINE ans = 0 NEW_LINE for i in range ( t ) : if NEW_LINE j < 60 : ans += 60 - min ( 60 , 60 ) NEW_LINE print ( ans ) NEW_LINE"],"references":["for _ in range ( int ( input ( ) ) ) : h , m = map ( int , input ( ) . split ( ) ) s = 0 s = ( 24 - h - 1 ) * 60 + ( 60 - m ) print ( s ) NEW_LINE"],"bleu":0.2835884880614175,"rouge_l":0.5174363807728557}
{"id":435,"predictions":["for t in range ( int ( input ( ) ) ) : a , b , x , y = map ( int , input ( ) . split ( ) ) z = max ( a , b - 1 ) print ( max ( z , a - x , b ) ) ) NEW_LINE"],"references":["def solve ( a , b , p , q ) : area1 = a * q area2 = a * ( b - q - 1 ) area3 = b * p area4 = b * ( a - p - 1 ) return max ( area1 , area2 , area3 , area4 ) if __name__ == ' _ _ main _ _ ' : S = int ( input ( ) ) for s in range ( S ) : a , b , p , q = tuple ( map ( int , input ( ) . split ( ) ) ) print ( solve ( a , b , p , q ) ) NEW_LINE"],"bleu":0.18843626468892205,"rouge_l":0.39361702127659576}
{"id":436,"predictions":["n , m = map ( int , input ( ) . split ( ) )   houses = [ ] for i in range ( n ) : tiles . append ( input ( ) )   for i in range ( n ) : for j in range ( m ) : if ( i [ j ] [ i ] != ' B ' ) : for k in range ( 1 , n + 1 ) : if ( i [ j ] [ k ] != ' B ' ) : continue   [ ( i ] [ j ] = ' B ' + ' if ( i == ' B ' and j != ' B ' ) : continue   for i in range ( n ) : for j in range ( 1 , m + 1 ) : if check ( i , j ) != ' A ' and check ( i , j ) == ' B ' : continue   if check ( i , j ) == ' B ' : print ( ' . join ( i ) ) NEW_LINE"],"references":["import sys   input = sys . stdin . readline   def check ( x , y ) : for i in range ( min ( x [ 0 ] , y [ 0 ] ) , max ( x [ 0 ] , y [ 0 ] ) + 1 ) : if not plan [ i ] [ x [ 1 ] ] == \" B \" : return False for i in range ( min ( x [ 1 ] , y [ 1 ] ) , max ( x [ 1 ] , y [ 1 ] ) + 1 ) : if not plan [ y [ 0 ] ] [ i ] == \" B \" : return False return True   n , m = map ( int , input ( ) . split ( ) ) plan = tuple ( tuple ( i for i in input ( ) . strip ( ) ) for j in range ( n ) ) start = [ ( i , j ) for i in range ( n ) for j in range ( m ) if plan [ i ] [ j ] == \" B \" ] for i in range ( len ( start ) ) : for j in range ( i + 1 , len ( start ) ) : if not check ( start [ i ] , start [ j ] ) and not check ( start [ j ] , start [ i ] ) : print ( \" NO \" ) sys . exit ( ) print ( \" YES \" ) NEW_LINE"],"bleu":0.2641227606668825,"rouge_l":0.3688772424914332}
{"id":437,"predictions":["n = int ( input ( ) ) s = input ( ) e = [ ] for i in range ( n ) : e = list ( map ( int , input ( ) . split ( ) ) ) e = [ ] for j in range ( n - 1 , 0 , - 1 ) : if e [ j ] > e : e . append ( e [ j ] ) e . append ( e [ j ] ) if e [ 1 ] [ 1 ] > e [ 1 ] [ 1 ] : e . append ( e [ 0 ] , e [ 1 ] [ 1 ] ) print ( e ) NEW_LINE"],"references":["I = lambda : map ( int , input ( ) . split ( ) ) n , s = I ( ) l = [ 0 ] for i in range ( n ) : q , w = I ( ) q = q * 60 + w l += [ q ] if l [ 1 ] - l [ 0 ] > s : exit ( print ( 0 , 0 ) ) for i in range ( n ) : if l [ i + 1 ] - l [ i ] > 2 * s + 1 : l [ i ] += s + 1 exit ( print ( l [ i ] \/\/ 60 , l [ i ] % 60 ) ) l [ - 1 ] += s + 1 print ( l [ - 1 ] \/\/ 60 , l [ - 1 ] % 60 ) NEW_LINE"],"bleu":0.22349415940338635,"rouge_l":0.41244083840432727}
{"id":438,"predictions":["import sysfrom os import pathif ( path . exists ( ' input . txt ' ) ) : sys . stdout = open ( ' input . txt ' , ' r ' ) sys . stdout = open ( ' output . txt ' , ' w ' ) s = input ( ) n = len ( s ) for i in range ( n - 1 ) : if ( s [ i ] != ' t ' ) : print ( i , end = ' \/ ' ) elif ( s [ i ] == ' \/ ' and s [ i + 1 ] != ' \/ ' and s [ i + 1 ] != ' \/ ' ) : print ( i + 1 ) ; break NEW_LINE"],"references":["s = input ( ) ans = \" \" if s . startswith ( ' http ' ) : s = s [ 4 : ] ans = ' http : \/ \/ ' else : ans = \" ftp : \/ \/ \" s = s [ 3 : ]   if s . count ( ' ru ' ) > 1 and s . index ( ' ru ' ) == 0 : x = s [ 1 : ] . index ( ' ru ' ) + 1 else : x = s . index ( ' ru ' )     ans += s [ : x ] + ' . ' + ' ru ' s = s [ x + 2 : ] if s : ans += ' \/ ' + s   print ( ans )     NEW_LINE"],"bleu":0.09737232940883751,"rouge_l":0.35089737689829725}
{"id":439,"predictions":["for i in range ( int ( input ( ) ) ) : l = list ( map ( str , input ( ) . split ( ) ) ) for j in range ( len ( l ) ) : if ( l [ i ] [ j ] != 11 [ i ] ) : print ( \" NO \" ) else : print ( \" YES \" ) NEW_LINE"],"references":["tests = int ( input ( ) ) t = 0 for t in range ( 0 , tests ) : n = int ( input ( ) ) s = input ( ) bol = False for i in range ( 0 , len ( s ) ) : if s [ i ] == '8' : bol = True cnt = i break if ( bol ) : if n - cnt >= 11 : print ( ' YES ' ) else : print ( ' NO ' ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.2641771156798115,"rouge_l":0.4857407407407407}
{"id":440,"predictions":["n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) : if arr [ i ] % 2 == 0 : arr [ i ] -= 1 else : arr [ i ] -= 1   print ( * arr ) NEW_LINE"],"references":["def solve ( arr ) : for i in range ( len ( arr ) ) : if arr [ i ] % 2 == 0 : arr [ i ] -= 1 return \" ▁ \" . join ( str ( i ) for i in arr )   input ( ) arr = list ( map ( int , input ( ) . split ( ) ) ) print ( solve ( arr ) ) NEW_LINE"],"bleu":0.5423543520400983,"rouge_l":0.45666969147005443}
{"id":441,"predictions":["def main_function ( ) : n , m = map ( int , input ( ) . split ( \" ▁ \" ) ) d = [ 0 ] * ( n + 1 ) for i in range ( m ) : x = list ( map ( int , input ( ) . split ( ) ) ) d . append ( d [ x ] . count ( \" * \" ) ) for i in range ( n ) : if d [ i ] [ 0 ] == \"1\" : d [ i ] = 1 if d [ 0 ] == 1 : d [ i ] = 1 else : d [ i ] = 1 if d [ i ] == \"1\" : d [ i ] = 1 if d [ i + 1 ] [ 0 ] == 2 : d [ i ] = 1 d [ i ] = 1 for j in range ( n - 1 , - 1 , - 1 ) : if d [ j ] == \"1\" : d [ j ] = 1 else : d [ i + 1 ] = 1 print ( max ( d [ - 1 ] [ j + 1 ] ) ) NEW_LINE"],"references":["from collections import defaultdictfrom sys import stdin   def put ( ) : return map ( int , stdin . readline ( ) . split ( ) )   def dfs ( ) : s = [ ( 1 , 0 ) ] ans = 0 vis = [ 0 ] * ( n + 1 ) while s : i , p = s . pop ( ) if vis [ i ] == 0 : vis [ i ] = 1 s . append ( ( i , p ) ) for j in tree [ i ] : if j != p : s . append ( ( j , i ) ) elif vis [ i ] == 1 : vis [ i ] = 2 for j in tree [ i ] : if j != p : mark [ i ] += mark [ j ] ans += min ( mark [ i ] , 2 * k - mark [ i ] ) print ( ans )                         n , k = put ( ) l = list ( put ( ) )   edge = defaultdict ( ) tree = [ [ ] for i in range ( n + 1 ) ] mark = [ 0 ] * ( n + 1 ) for i in l : mark [ i ] = 1 for _ in range ( n - 1 ) : x , y = put ( ) tree [ x ] . append ( y ) tree [ y ] . append ( x ) dfs ( ) NEW_LINE"],"bleu":0.26417120202736993,"rouge_l":0.37094852987273524}
{"id":442,"predictions":["if __name__ == ' _ _ main _ _ ' : for _ in range ( int ( input ( ) ) ) : s = input ( ) NEW_LINE cin = input ( ) NEW_LINE for i in range ( len ( s ) ) : ship = False NEW_LINE for i in range ( len ( s ) ) : if s [ i ] == cin [ i ] : NEW_LINE s = True NEW_LINE break NEW_LINE DEDENT"],"references":["for _ in range ( int ( input ( ) ) ) : a = input ( ) b = input ( ) c = input ( ) case = True for i in range ( len ( a ) ) : if a [ i ] != c [ i ] and b [ i ] != c [ i ] : case = False print ( \" NO \" ) break if case : print ( \" YES \" ) NEW_LINE"],"bleu":0.3776582895944428,"rouge_l":0.547576301615799}
{"id":443,"predictions":["from collections import defaultdict , deque , Counterfrom sys import stdin , stdoutfrom heapq import heappush , heappopimport mathimport ioimport osimport bisect   NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) g = [ set ( ) for i in range ( n ) ] for i in range ( m ) : a , b = map ( int , input ( ) . split ( ) ) g [ a - 1 ] . add ( b - 1 ) g [ b - 1 ] . add ( a - 1 ) a = [ ] p = [ - 1 ] * nfor i in range ( n ) : if p [ i ] != - 1 : continue p [ i ] = 0 a . append ( i ) while a : x = a . pop ( ) for node in g [ x ] : if p [ node ] == p [ x ] : print ( - 1 ) exit ( ) if p [ node ] == - 1 : p [ node ] = not p [ x ] a . append ( node ) print ( p . count ( 0 ) ) for i in range ( n ) : if p [ i ] == 0 : print ( i + 1 , end = \" ▁ \" ) print ( ) print ( p . count ( 1 ) ) for i in range ( n ) : if p [ i ] == 1 : print ( i + 1 , end = \" ▁ \" ) print ( ) NEW_LINE"],"bleu":0.00000195993502339997,"rouge_l":0.030186064924782267}
{"id":444,"predictions":["x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) )   if x1 != x2 : if y1 == x2 : print ( \" - 1\" ) exit ( 0 )   y1 = abs ( y1 - y2 ) y1 = abs ( x2 - y1 ) x2 = abs ( y1 - x2 )   if x1 != x1 and y1 != y2 : print ( x1 , y1 , x2 , y2 , x1 , y2 )   else : print ( x1 , y1 , x2 , y2 ) NEW_LINE"],"references":["x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) )   if x1 == x2 : x3 = x1 + abs ( y2 - y1 ) x4 = x3 y3 = y1 y4 = y2 NEW_LINE"],"bleu":0.26515565250001566,"rouge_l":0.5303101503759399}
{"id":445,"predictions":["n , m = map ( int , input ( ) . split ( ) ) grid = [ [ ] for i in range ( n ) ] for i in range ( n ) : for j in range ( m ) : grid [ i ] [ j ] = 0 for i in range ( n ) : for j in range ( m ) : grid [ i ] [ j ] = grid [ i ] [ j ] for _ in range ( n ) : for i in range ( m ) : for j in range ( m ) : grid [ i ] [ j ] = False for i in range ( n ) : for j in range ( m ) : grid [ i ] [ j ] -= 1 for _ in range ( n ) : for x in range ( m ) : if not grid [ i ] [ j ] : grid [ i ] [ j ] = True for j in range ( m ) : if not grid [ i ] [ j ] : grid [ i ] [ j ] = Falsefor i in range ( n ) : for j in range ( m ) : if grid [ i ] [ j ] == mat [ i ] [ j ] and not grid [ i ] [ j ] [ i ] : print ( i + 1 ) return NEW_LINE"],"references":["def checkRow ( i , c ) : cnt = 0 NEW_LINE for j in range ( m ) : if NEW_LINE g [ i ] [ j ] == c : cnt += 1   if cnt >= 2 : return True NEW_LINE return False     NEW_LINE def checkCol ( j , c ) : cnt = 0 NEW_LINE for i in range ( n ) : if NEW_LINE g [ i ] [ j ] == c : cnt += 1   if cnt >= 2 : return True NEW_LINE return False   n , m = map ( int , input ( ) . split ( ) )   g = [ ]   for i in range ( n ) : g . append ( list ( input ( ) ) )     res = [ [ 0 ] * m for i in range ( n ) ] NEW_LINE for i in range ( n ) : for NEW_LINE j in range ( m ) : NEW_LINE if ( checkRow ( i , g [ i ] [ j ] ) ) or checkCol ( j , g [ i ] [ j ] ) : res [ i ] [ j ] = 1     for i in range ( n ) : for NEW_LINE j in range ( m ) : NEW_LINE if res [ i ] [ j ] == 0 : print ( g [ i ] [ j ] , end = ' ' )         NEW_LINE"],"bleu":0.4454857757389351,"rouge_l":0.483609136097653}
{"id":446,"predictions":["def mingrid ( ) : for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) segcost = input ( ) . split ( ) minodd = int ( segcost [ 0 ] ) minodd = int ( segcost [ 1 ] ) for i in range ( 1 , n + 1 ) : if segcost [ i ] > maxodd : print ( ' NO ' ) else : print ( ' YES ' )   NEW_LINE"],"references":["n , M = map ( int , input ( ) . strip ( ) . split ( ) ) a = list ( map ( int , input ( ) . strip ( ) . split ( ) ) )   a . insert ( 0 , 0 ) n += 1   lit = [ 0 ] * ( n + 1 ) for i in range ( 1 , n ) : if i % 2 == 0 : lit [ i ] = lit [ i - 1 ] else : lit [ i ] = lit [ i - 1 ] + a [ i ] - a [ i - 1 ] if n % 2 == 0 : lit [ n ] = lit [ n - 1 ] else : lit [ n ] = lit [ n - 1 ] + M - a [ n - 1 ] NEW_LINE"],"bleu":0.14539859473505287,"rouge_l":0.3299786136620958}
{"id":447,"predictions":["n = int ( input ( ) ) t = list ( map ( int , input ( ) . split ( \" ▁ \" ) ) )   x = [ ] for i in range ( n ) : x . append ( input ( ) )   x . append ( x [ 0 ] . append ( x [ 1 ] ) )   if len ( x ) == 0 : print ( \" NO \" ) exit ( )   for i in range ( n ) : if t [ i ] == t [ i ] : print ( \" YES \" ) exit ( )   for i in range ( len ( x ) - 1 , x ) : if t [ i ] [ 0 ] == x [ i + 1 ] [ i + 1 ] == x [ i ] [ 1 ] : print ( \" NO \" ) exit ( )   print ( \" YES \" ) NEW_LINE"],"references":["import sysdef input ( ) : return sys . stdin . readline ( ) . strip ( ) def iinput ( ) : return int ( input ( ) ) def minput ( ) : return map ( int , input ( ) . split ( ) ) def listinput ( ) : return list ( map ( int , input ( ) . split ( ) ) ) c = 0 for _ in range ( iinput ( ) ) : km , dirr = map ( str , input ( ) . split ( ) ) km = int ( km ) if dirr == ' North ' : c -= km elif dirr == ' South ' : c += km elif c == 0 or c == 20000 : print ( \" NO \" ) exit ( ) if c < 0 or c > 20000 : print ( \" NO \" ) exit ( ) if c == 0 : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.3044148833928013,"rouge_l":0.41488970588235297}
{"id":448,"predictions":["import mathfor NEW_LINE m in range ( m ) : n , m = map ( int , input ( ) . split ( ) ) NEW_LINE"],"references":["n , m = list ( map ( int , input ( ) . split ( \" ▁ \" ) ) )   if m % 2 != 0 : mid = int ( ( m + 1 ) \/ 2 ) i = mid j = mid       else :   mid = int ( ( m \/ 2 ) ) i = mid j = mid + 1     detector = 1 if m == 1 : for x in range ( n ) : print ( 1 ) else : for _ in range ( n ) : if i == j : print ( mid ) i -= 1 j += 1 detector = 1 continue if m % 2 != 0 : if detector == - 1 : print ( j ) j += 1 if j == m + 1 : j = mid detector *= - 1 elif detector == 1 : print ( i ) i -= 1 if i == 0 : i = mid detector *= - 1   elif m % 2 == 0 : if detector == 1 : print ( i ) i -= 1 if i == 0 : i = mid detector *= - 1 elif detector == - 1 : print ( j )   j += 1 if j == m + 1 : j = mid + 1 detector *= - 1     NEW_LINE"],"bleu":0.00025300218421861514,"rouge_l":0.10880285384534677}
{"id":449,"predictions":["from math import ceiln , x , y = map ( int , input ( ) . split ( ) ) if ( p < x ) : NEW_LINE INDENT print ( 0 ) elif ( p > x ) : NEW_LINE INDENT print ( y - x ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( abs ( p - x ) ) NEW_LINE DEDENT DEDENT"],"references":["import mathfrom math import gcd , floor , sqrt , logdef iin ( ) : return int ( input ( ) ) def sin ( ) : return input ( ) . strip ( ) def listin ( ) : return list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) def liststr ( ) : return list ( map ( str , input ( ) . strip ( ) . split ( ) ) ) def ceill ( x ) : return int ( x ) if ( x == int ( x ) ) else int ( x ) + 1 def ceilldiv ( x , d ) : return x \/\/ d if ( x % d == 0 ) else x \/\/ d + 1 def LCM ( a , b ) : return ( a * b ) \/\/ gcd ( a , b )     def solve ( ) : n , x , y = listin ( ) wiz = x people = n - x req = ceill ( ( y \/ 100 ) * n ) print ( max ( 0 , req - wiz ) ) t = 1 NEW_LINE"],"bleu":0.042810387979051186,"rouge_l":0.2576069301570114}
{"id":450,"predictions":["n = int ( input ( ) ) a = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) : j = i + 1 while j < n : if a [ j ] > a [ j ] : j += 1 else : a [ j ] -= 1 if a [ i ] == 0 : j += 1   print ( - 1 ) NEW_LINE"],"references":["n = int ( input ( ) ) vals = list ( map ( int , input ( ) . split ( ) ) ) vals = [ ( i , vals [ i ] ) for i in range ( n ) ] vals = [ vals [ 0 ] ] + sorted ( vals [ 1 : ] , key = lambda x : x [ 1 ] , reverse = True ) most_left_idx = 0 count = 0 output = ' ' for i in range ( n ) : if ( most_left_idx >= i ) : for j in range ( 1 , vals [ i ] [ 1 ] + 1 ) : if ( most_left_idx + j < n ) : count += 1 output += ' { } ▁ { } ▁ \\n ' . format ( vals [ i ] [ 0 ] + 1 , vals [ most_left_idx + j ] [ 0 ] + 1 ) most_left_idx += vals [ i ] [ 1 ] if ( most_left_idx >= n - 1 ) : print ( count ) print ( output ) else : print ( - 1 ) NEW_LINE"],"bleu":0.1342156299064587,"rouge_l":0.38389333333333336}
{"id":451,"predictions":["n , k = map ( int , input ( ) . split ( ) ) s = input ( ) t = input ( ) [ 1 : k ] = [ 0 ] * 26for i in range ( 26 ) : s [ ord ( i ) - ord ( i ) - ord ( ' a ' ) ] = ord ( t [ i ) - 97 ] = 0 found = Truefor i in range ( s [ 0 ] ) : if t [ i ] [ 0 ] == 1 : found [ i ] = 1 break if not found : print ( \" NO \" ) else : print ( \" YES \" ) print ( \" NO \" ) NEW_LINE"],"references":["l = [ - 1 ] * 122 g = [ - 1 ] * 122 r = 0 ch = 0 n , k = map ( int , input ( ) . split ( ) ) s = input ( ) j = nfor i in range ( 0 , n ) : j -= 1 indf = ord ( s [ i ] ) indb = ord ( s [ j ] ) if ( l [ indf ] != - 1 ) : pass else : l [ indf ] = i if ( g [ indb ] != - 1 ) : pass else : g [ indb ] = j   for i in range ( 0 , n ) : indx = ord ( s [ i ] ) if ( l [ indx ] == i ) : r += 1 if ( r > k ) : ch = 1 break if ( g [ indx ] == i ) : r -= 1 if ( ch == 1 ) : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.2752395768776492,"rouge_l":0.4740165128703254}
{"id":452,"predictions":["import n , l = map ( int , input ( ) . split ( ) ) n , l = map ( int , input ( ) . split ( ) ) ans = [ 0 ] * ( l ** 2 + 1 ) for i in range ( n - 1 ) : ans . append ( i ) print ( ans ) NEW_LINE"],"references":["a , b = list ( map ( int , input ( ) . split ( ) ) ) print ( format ( ( ( b * b ) - ( a * a ) ) \/ ( a * 2 ) , ' . 12f ' ) ) NEW_LINE"],"bleu":0.24386006232994575,"rouge_l":0.47395683453237414}
{"id":453,"predictions":["n = int ( input ( ) ) s = input ( ) ans = 1000 for i in range ( 1 , n - 1 ) : if s . count ( '0' ) == 1 : ans = max ( ans , count ) print ( ans ) NEW_LINE"],"references":["s = input ( ) w = len ( s ) q = - 1 for i in range ( w - 2 ) : for j in range ( i + 1 , w - 1 ) : a , b , c = s [ : i + 1 ] , s [ i + 1 : j + 1 ] , s [ j + 1 : ] if len ( a ) == len ( str ( int ( a ) ) ) and len ( b ) == len ( str ( int ( b ) ) ) and len ( c ) == len ( str ( int ( c ) ) ) : if int ( a ) <= 10 ** 6 and int ( b ) <= 10 ** 6 and int ( c ) <= 10 ** 6 : q = max ( q , int ( a ) + int ( b ) + int ( c ) ) print ( q ) NEW_LINE"],"bleu":0.028489122753517844,"rouge_l":0.26701153999204136}
{"id":454,"predictions":["import matht = int ( input ( ) ) for _ in range ( t ) : n = int ( input ( ) ) a , b , c = map ( int , input ( ) . split ( ) ) st = input ( ) ans = 0 st1 = \" \" for x in st : if ( x == \" R \" and b > 0 ) : ans += 1 b -= 1 st1 += \" P \" elif ( x == \" S \" and a > 0 ) : ans += 1 a -= 1 st1 += \" S \" elif ( x == \" P \" and c > 0 ) : ans += 1 c -= 1 st1 += \" S \" else : st1 += \" * \"   ans_str = \" \" for x in st1 : if ( x == ' * ' ) : if ( a > 0 ) : ans_str += \" S \" a -= 1 elif ( b > 0 ) : ans_str += \" P \" b -= 1 elif ( c > 0 ) : ans_str += \" S \" c -= 1 else : ans_str += x if ( ans >= math . ceil ( n \/ 2 ) ) : print ( \" YES \" ) print ( ans_str ) else : print ( \" NO \" )                                           NEW_LINE"],"references":["x = int ( input ( ) ) for i in range ( x ) : n , m = [ int ( a ) for a in input ( ) . split ( ) ] if ( 2 * min ( n , m ) < max ( m , n ) or ( n + m ) % 3 ) : print ( \" NO \" ) else : print ( \" YES \" ) NEW_LINE"],"bleu":0.14475875359030077,"rouge_l":0.31558125380401697}
{"id":455,"predictions":["import math NEW_LINE input = sys . stdin . readline NEW_LINE sys . setrecursionlimit ( 10 ** 5 ) NEW_LINE"],"references":["from sys import * ; from math import * ; from collections import * ; from bisect import * ; from itertools import * INF = maxsizedef get_ints ( ) : return map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) def get_array ( ) : return list ( map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) ) def input ( ) : return stdin . readline ( ) . strip ( ) mod = 1000000007   n = int ( input ( ) ) arr = [ ] for i in range ( n ) : temp = get_array ( ) arr . append ( temp ) for i in range ( n ) : ans = ( arr [ i ] [ ( i + 1 ) % n ] * arr [ i ] [ ( i + 2 ) % n ] ) \/\/ arr [ ( i + 1 ) % n ] [ ( i + 2 ) % n ] print ( int ( sqrt ( ans ) ) , end = ' ▁ ' ) NEW_LINE"],"bleu":0.000018659752164822395,"rouge_l":0.08593750000000001}
{"id":456,"predictions":["for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( len ( arr ) ) : if i == arr [ i ] : print ( max ( arr [ i - 1 ] , arr [ i ] ) ) ) else : print ( max ( arr ) ) NEW_LINE"],"references":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) [ : n ] res = [ a . index ( 1 ) , a . index ( n ) ] print ( max ( max ( res ) , n - min ( res ) - 1 ) ) NEW_LINE"],"bleu":0.3521764625234659,"rouge_l":0.5014441235281049}
{"id":457,"predictions":["cases = int ( input ( ) )   arr1 = ( map ( int , input ( ) . split ( ) ) ) arr2 = ( map ( int , input ( ) . split ( ) ) )   lost = 0 win = 0   for i , j in zip ( arr1 , arr2 ) : if i == 1 and j == 0 : win += 1 elif i == 0 and j == 1 : lost += 1   if win == 0 : print ( - 1 ) else : ans += 1 print ( ans )     NEW_LINE"],"references":["n = int ( input ( ) ) num = [ int ( i ) for i in input ( ) . split ( \" ▁ \" ) ]   odd = 0 even = 0   for i in num : if even and odd : break if i % 2 == 0 : even = 1 else : odd = 1 if even and odd : num = sorted ( num ) s = \" \" for i in range ( 0 , len ( num ) ) : s += str ( num [ i ] ) + \" ▁ \" print ( s ) NEW_LINE"],"bleu":0.19227293823690048,"rouge_l":0.43282004830917875}
{"id":458,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) c = list ( map ( int , input ( ) . split ( ) ) ) for x in range ( len ( a ) ) : if c [ x ] == 1 : c -= 1 print ( c ) NEW_LINE"],"references":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) k = ns = set ( ) for i in a : s . add ( i ) while k in s : print ( k , end = ' ▁ ' ) k -= 1 print ( ) NEW_LINE"],"bleu":0.4520020332185655,"rouge_l":0.6002460024600246}
{"id":459,"predictions":["for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( 1 ) else : NEW_LINE print ( 1 ) NEW_LINE DEDENT"],"references":["for t in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEW_LINE b = input ( ) NEW_LINE a = ' ' NEW_LINE d = ' ' NEW_LINE for i in b : try : if 1 + int ( i ) == int ( d [ - 1 ] ) : NEW_LINE INDENT a += '0' else : NEW_LINE a += '1' except : a = '1' NEW_LINE DEDENT d = str ( int ( a [ - 1 ] ) + int ( i ) ) NEW_LINE print ( a ) NEW_LINE"],"bleu":0.1910218192167673,"rouge_l":0.4935275080906149}
{"id":460,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["from math import ceiln , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) m = 10 ** ( k - 1 ) ans = 1 for i in range ( n \/\/ k ) : an = ( 10 ** k - 1 ) \/\/ a [ i ] + 1 l = b [ i ] * m r = ( b [ i ] + 1 ) * m - 1 count = r \/\/ a [ i ] - ceil ( l \/ a [ i ] ) + 1 ans = ( ans * ( an - count ) ) % ( 10 ** 9 + 7 ) print ( ans ) NEW_LINE"],"bleu":0.034593190841605004,"rouge_l":0.2948586494800059}
{"id":461,"predictions":["print ( int ( input ( ) ) ) NEW_LINE"],"references":["x = ( int ( input ( ) ) + 1 ) \/\/ 3 print ( x \/\/ 12 , x % 12 ) NEW_LINE"],"bleu":0.17460878649879533,"rouge_l":0.47739130434782606}
{"id":462,"predictions":["n , b , d = input ( ) . split ( ' ▁ ' ) n = int ( input ( ) ) k = int ( n ) arr = list ( map ( int , input ( ) . split ( ' ▁ ' ) ) ) for i in range ( n ) : x += arr [ i ] if x > d : k -= 1 print ( c ) NEW_LINE"],"references":["n , b , d = map ( int , input ( ) . split ( ) ) summa = 0 ans = 0 a = [ int ( i ) for i in input ( ) . split ( ) ] for i in a : if i <= b : summa += i if summa > d : summa = 0 ans += 1 print ( ans ) NEW_LINE"],"bleu":0.3478587103722205,"rouge_l":0.5445213122070965}
{"id":463,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["n , m , b , mod = list ( map ( int , input ( ) . split ( ) ) ) a = list ( map ( int , input ( ) . split ( ) ) )   A = [ [ 0 for i in range ( m + 1 ) ] for j in range ( b + 1 ) ]   A [ 0 ] [ 0 ] = 1   for i in range ( n ) : for j in range ( a [ i ] , b + 1 ) : for k in range ( m ) : A [ j ] [ k + 1 ] = ( A [ j ] [ k + 1 ] + A [ j - a [ i ] ] [ k ] ) % mod NEW_LINE"],"bleu":0.04813867514991136,"rouge_l":0.29569976544175136}
{"id":464,"predictions":["from sys import stdin   input = stdin . readline   n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = [ 0 ] * ( n + 1 ) b [ 0 ] = bfor i in range ( 2 , n + 1 ) : while i % 2 == 0 : b [ i - 1 ] = b [ i - 2 ] + a [ i - 1 ] a [ i ] = b [ i - 1 ] + a [ i - 1 ] if b [ i - 2 ] == 2 : b [ i - 1 ] = a [ i - 1 ] + b [ i - 1 ] if a [ i ] == 2 : print ( \" < \" ) else : print ( \" < \" : \" , end = ' ▁ ' ) else : print ( \" < \" ) NEW_LINE"],"references":["def clean ( d ) : ans = [ '0' ] for c in list ( d ) : ans . append ( c ) i = len ( ans ) - 1 NEW_LINE"],"bleu":0.01845354734897943,"rouge_l":0.1612618963694043}
{"id":465,"predictions":["import sysfrom functools import lru_cache , cmp_to_keyfrom heapq import merge , heapify , heappop , heappushfrom math import * from collections import defaultdict as dd , deque , Counter as Cfrom itertools import combinations as comb , permutations as permfrom bisect import bisect_left as bl , bisect_right as br , bisect , insortfrom time import perf_counterfrom fractions import Fractionimport copyfrom copy import deepcopyimport timestarttime = time . time ( ) mod = int ( pow ( 10 , 9 + 7 ) ) mod2 = 998244353   def data ( ) : return sys . stdin . readline ( ) . strip ( ) def out ( * var , end = \" \\n \" ) : sys . stdout . write ( ' ▁ ' . join ( map ( str , var ) ) + end ) def L ( ) : return list ( sp ( ) ) def sl ( ) : return list ( ssp ( ) ) def sp ( ) : return map ( int , data ( ) . split ( ) ) def ssp ( ) : return map ( str , data ( ) . split ( ) ) def l1d ( n , val = 0 ) : return [ val for i in range ( n ) ] def l2d ( n , m , val = 0 ) : return [ l1d ( n , val ) for j in range ( m ) ] try : NEW_LINE"],"references":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) d = [ 0 ] * 4 for i in a : if i == 1 : d [ 0 ] += 1 d [ 2 ] = max ( d [ 2 ] + 1 , d [ 1 ] + 1 ) else : d [ 1 ] = max ( d [ 1 ] + 1 , d [ 0 ] + 1 ) d [ 3 ] = max ( d [ 3 ] + 1 , d [ 2 ] + 1 ) print ( max ( d ) ) NEW_LINE"],"bleu":0.06754161489699695,"rouge_l":0.22951744896999346}
{"id":466,"predictions":["import sysimport collectionsimport itertools   n = int ( input ( ) ) if n <= 10 : print ( '0' ) elif n > 21 : print ( '0' ) elif n < 20 : print ( '4' ) elif n == 20 : print ( '15' ) else : print ( '4' ) NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) a = [ int ( i ) for i in input ( ) . split ( ) ] b = [ 0 ] * ( 10 ** 5 + 1 ) p = [ 0 ] * n + [ 0 ] for i in range ( len ( a ) - 1 , - 1 , - 1 ) : if b [ a [ i ] ] == 0 : b [ a [ i ] ] += 1 p [ i ] = p [ i + 1 ] + 1 else : p [ i ] = p [ i + 1 ] for i in range ( m ) : k = int ( input ( ) ) print ( p [ k - 1 ] ) NEW_LINE"],"bleu":0.03235987162035279,"rouge_l":0.20742164399763452}
{"id":467,"predictions":["s = input ( ) s = set ( s ) if len ( s ) == s : print ( s ) else : print ( s1 ) NEW_LINE"],"references":["a , b = map ( int , input ( ) . split ( ) ) if a == b : print ( a ) else : print ( \"1\" ) NEW_LINE"],"bleu":0.2548346103424781,"rouge_l":0.5772870662460569}
{"id":468,"predictions":["from collections import defaultdictn = int ( input ( ) ) a = [ int ( x ) for x in input ( ) . split ( ' ▁ ' ) ] b = [ int ( x ) for x in input ( ) . split ( ' ▁ ' ) ] arr = [ int ( x ) for x in input ( ) . split ( ' ▁ ' ) ] arr = [ [ int ( x ) for x in input ( ) . split ( ' ▁ ' ) ] arr [ 0 ] [ 0 ] = 0   for i in range ( n ) : for j in range ( 1 , 300 ) : if a [ i ] [ 1 ] == 1 : arr [ j ] [ 0 ] += 1   elif a [ i ] [ 1 ] == 1 : arr [ j ] [ 1 ] = 1   else : arr [ j ] [ 1 ] = 1   for i in range ( m - 1 ) : arr [ i ] [ 1 ] = arr [ i ] [ 0 ] + arr [ i - 1 ] [ 0 ] = arr [ i ] [ 1 ]   print ( \" NO \" ) NEW_LINE"],"references":["from sys import stdin , stdoutn = int ( input ( ) ) arr = [ ] d = dict ( ) for i in range ( n ) : x = tuple ( [ int ( x ) for x in stdin . readline ( ) . split ( ) ] ) d [ x ] = 1 arr . append ( x ) cnt = 0 for i in range ( n - 1 ) : for j in range ( i + 1 , n ) : sum1 = arr [ i ] [ 0 ] + arr [ j ] [ 0 ] sum2 = arr [ i ] [ 1 ] + arr [ j ] [ 1 ] if ( sum1 \/ 2 == sum1 \/\/ 2 ) and ( sum2 \/ 2 == sum2 \/\/ 2 ) : tup = ( sum1 \/\/ 2 , sum2 \/\/ 2 ) if d . get ( tup ) : cnt += 1 ; print ( cnt ) NEW_LINE"],"bleu":0.3313910577584309,"rouge_l":0.4797122061407177}
{"id":469,"predictions":["n = int ( input ( ) ) v_arr = list ( map ( int , input ( ) . split ( \" ▁ \" ) ) ) u_arr = v_arr . copy ( ) u_arr . sort ( ) m = int ( input ( ) )   def sum_calc ( arr ) : sum_ = 0 sum_arr = [ 0 ] for item in arr : sum_ += item sum_arr . append ( sum_ ) return sum_arr   sum_v = sum_calc ( v_arr ) for i in range ( m ) : sum_v = list ( map ( int , input ( ) . split ( \" ▁ \" ) ) ) _type = inp [ 0 ] l = inp [ 1 ] r = list ( map ( int , input ( ) . split ( \" ▁ \" ) ) ) for _ in range ( n ) : l , r = input ( ) . split ( \" ▁ \" ) ) if r > n : print ( l , r ) else : print ( \" yes \" ) print ( l , r ) NEW_LINE"],"references":["import sys     def ints_input ( ) : return [ int ( i ) for i in sys . stdin . readline ( ) . strip ( \" \\n \" ) . split ( \" ▁ \" ) ]     def print_list ( arr ) : sys . stdout . writelines ( str ( x ) + \" ▁ \" for x in arr ) sys . stdout . write ( \" \\n \" )     def fast_input ( type = str ) : return type ( sys . stdin . readline ( ) . strip ( \" \\n \" ) )     X = ints_input ( ) n , x = X [ 0 ] , X [ 1 : ] Y = ints_input ( ) m , y = Y [ 0 ] , Y [ 1 : ]   Z = ints_input ( ) p , z = Z [ 0 ] , Z [ 1 : ]   a , b = ints_input ( ) r2 = max ( x ) * ( b * max ( y ) \/ ( a * min ( z ) + b * max ( y ) ) ) ** 0.5 print ( r2 ) NEW_LINE"],"bleu":0.14972224199456757,"rouge_l":0.33261165904899365}
{"id":470,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["def lower_bound ( arr , left , right , target ) : if arr [ right ] < target : return right + 1 while left < right : mid = ( left + right ) >> 1 if arr [ mid ] >= target : right = mid else : left = mid + 1 return left   T = int ( input ( ) ) arr = [ 0 ] * Tdp = [ 0 ] * ( T + 1 ) for i in range ( T ) : arr [ i ] = int ( input ( ) ) for i in range ( T ) : dp [ i + 1 ] = dp [ i ] + 20 dp [ i + 1 ] = min ( dp [ i + 1 ] , dp [ lower_bound ( arr , 0 , T - 1 , arr [ i ] - 89 ) ] + 50 ) dp [ i + 1 ] = min ( dp [ i + 1 ] , dp [ lower_bound ( arr , 0 , T - 1 , arr [ i ] - 1439 ) ] + 120 ) print ( dp [ i + 1 ] - dp [ i ] ) NEW_LINE"],"bleu":0.0037303599383471625,"rouge_l":0.15611438744853678}
{"id":471,"predictions":["import sysfrom math import * input = sys . stdin . readline   NEW_LINE"],"references":["import math as mtimport sys , stringfrom collections import Counter , defaultdictinput = sys . stdin . readline MOD = 1000000007 I = lambda : int ( input ( ) ) M = lambda : map ( int , input ( ) . split ( ) ) Ms = lambda : map ( str , input ( ) . split ( ) ) ARR = lambda : list ( map ( int , input ( ) . split ( ) ) ) def solve ( ) : n , m = M ( ) mat = [ ARR ( ) for _ in range ( n ) ]   setLengths = [ ] for i in range ( n ) : black , white = 0 , 0 for j in range ( m ) : if mat [ i ] [ j ] == 0 : black += 1 elif mat [ i ] [ j ] == 1 : white += 1 if white > 0 : setLengths . append ( white ) if black > 0 : setLengths . append ( black )   for j in range ( m ) : black , white = 0 , 0 for i in range ( n ) : if mat [ i ] [ j ] == 0 : black += 1 elif mat [ i ] [ j ] == 1 : white += 1 if white > 0 : setLengths . append ( white ) if black > 0 : setLengths . append ( black )   ans = n * m for e in setLengths : ans += ( 1 << e ) ans -= ( e + 1 ) print ( ans )     tc = 1 NEW_LINE"],"bleu":2.8138868406450736e-10,"rouge_l":0.06116681859617137}
{"id":472,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) print ( ( ( a [ ( n - 1 ) \/\/ 2 ] ) ) NEW_LINE"],"references":["n = int ( input ( ) ) print ( sorted ( map ( int , input ( ) . split ( ) ) ) [ ( n - 1 ) \/\/ 2 ] ) NEW_LINE"],"bleu":0.734341738445791,"rouge_l":0.8580562659846547}
{"id":473,"predictions":["n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ]   NEW_LINE"],"references":["import java . util . * ;   public class aerg {   static Scanner in = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { String s = in . next ( ) ; String u = in . next ( ) ; int ans = 0 ; for ( int i = 0 ; i < s . length ( ) ; i + + ) { for ( int j = 0 ; j < u . length ( ) ; j + + ) { int k = 0 ; if ( s . charAt ( i ) == u . charAt ( j ) ) { k + + ; for ( int z = j + 1 , t = i + 1 ; z < u . length ( ) & & t < s . length ( ) ; z + + , t + + ) { if ( s . charAt ( t ) == u . charAt ( z ) ) { k + + ; } } \/\/ System . out . println ( i + \" ▁ \" + k ) ; } ans = Math . max ( ans , k ) ; } if ( ans > s . length ( ) - i ) break ; } \/\/ System . out . println ( u . length ( ) ) ; System . out . println ( u . length ( ) - ans ) ; } } NEW_LINE"],"bleu":0.0007972548668062977,"rouge_l":0.14299109235818097}
{"id":474,"predictions":["s = input ( ) ans = [ ] for i in range ( len ( s ) ) : if ( s [ i ] == \" # \" ) : ans . append ( s [ i ] ) print ( len ( ans ) ) for i in range ( len ( s ) ) : if NEW_LINE"],"references":["import syskek = \" \" bol = 1 for s in sys . stdin : ok = 0 for i in range ( len ( s ) ) : if s [ i ] == ' ▁ ' : continue if s [ i ] == ' # ' : ok = 1 else : ok = 0 break kekw = ( bol == 0 and ok == 0 ) for j in range ( len ( kek ) - kekw ) : if bol == 1 or kek [ j ] != ' ▁ ' : sys . stdout . write ( kek [ j ] ) kek = s bol = ok   for j in range ( len ( kek ) ) : if bol == 1 or kek [ j ] != ' ▁ ' : sys . stdout . write ( kek [ j ] ) NEW_LINE"],"bleu":0.10522603707664656,"rouge_l":0.3574389023867372}
{"id":475,"predictions":["n = input ( ) lst = list ( map ( int , input ( ) . split ( ) ) ) ds = [ ] ds . append ( 0 ) for i , elem in enumerate ( lst [ 1 : ] ) : ds . append ( ds [ i ] * elem + lst [ i ] * elem ) ans = 2 * sum ( ds ) + sum ( lst ) print ( ans ) NEW_LINE"],"references":["from sys import stdin , stdout n , m , k = map ( int , input ( ) . split ( ) ) l = [ [ 0 ] * m ] * n for i in range ( n ) : l [ i ] = list ( map ( int , stdin . readline ( ) . split ( ) ) ) t = [ [ 0 ] * 2 ] * ke = [ 0 ] * nc = [ 0 ] * m for i in range ( k ) : t0 , t1 = map ( int , stdin . readline ( ) . split ( ) ) e [ t0 - 1 ] -= 1 c [ t1 - 1 ] += 1 p = [ \" \" ] * nfor i in range ( n ) : for j in range ( m ) : e [ i ] = e [ i ] + c [ j ] * l [ i ] [ j ] p [ i ] = str ( e [ i ] ) stdout . write ( \" ▁ \" . join ( p ) ) NEW_LINE"],"bleu":0.07259268198824663,"rouge_l":0.31531337497307776}
{"id":476,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["c , d = [ int ( i ) for i in input ( ) . split ( \" ▁ \" ) ] n , m = [ int ( i ) for i in input ( ) . split ( \" ▁ \" ) ] k = int ( input ( ) )   s = n * m - ks = max ( s , 0 )   if c < d * n : stuff = s \/\/ n try1 = c * stuff + d * ( s - n * stuff ) try2 = c * ( stuff + 1 ) print ( min ( try1 , try2 ) ) else : print ( d * s ) NEW_LINE"],"bleu":0.03738935474991606,"rouge_l":0.23798545841461252}
{"id":477,"predictions":["t = int ( input ( ) ) NEW_LINE for i in range ( t ) : n = int ( input ( ) ) NEW_LINE x = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l = set ( ) NEW_LINE for j in x : if NEW_LINE j not in l : l . add ( j ) else : l . add ( j + 1 ) NEW_LINE l1 = set ( ) NEW_LINE"],"references":["a , b = map ( int , input ( ) . split ( ) )   s = input ( )   obs = b * ' # ' if obs in s : print ( \" NO \" ) else : print ( \" YES \" ) NEW_LINE"],"bleu":0.1883123829393843,"rouge_l":0.4040764331210191}
{"id":478,"predictions":["n = int ( input ( ) ) lst = list ( map ( int , input ( ) . split ( ) ) ) x = list ( map ( int , input ( ) . split ( ) ) ) y = list ( map ( int , input ( ) . split ( ) ) ) print ( x , y ) NEW_LINE"],"references":["na , ma = map ( int , input ( ) . split ( ) ) a = [ list ( map ( int , input ( ) ) ) for _ in range ( na ) ] nb , mb = map ( int , input ( ) . split ( ) ) b = [ list ( map ( int , input ( ) ) ) for _ in range ( nb ) ]   best = 0 points = ( 0 , 0 ) for x in range ( - 50 , 51 ) : for y in range ( - 50 , 51 ) : ct = 0 for i in range ( na ) : if x + i < 0 : continue if x + i >= nb : break for j in range ( ma ) : if y + j < 0 : continue if y + j >= mb : break ct += a [ i ] [ j ] * b [ i + x ] [ j + y ] if ct >= best : best = ct points = ( x , y ) print ( points [ 0 ] , points [ 1 ] ) NEW_LINE"],"bleu":0.07713861755826211,"rouge_l":0.34575975583169827}
{"id":479,"predictions":["n , k = map ( int , input ( ) . split ( ) ) print ( ( ( n - k ) ) ) NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l . sort ( ) print ( l [ ( - 1 ) * m ] ) NEW_LINE"],"bleu":0.2553614026137404,"rouge_l":0.5344484269215453}
{"id":480,"predictions":["n , bx , y = map ( int , input ( ) . split ( ) ) x , yx = map ( int , input ( ) . split ( ) ) [ 1 : ] , yx = map ( int , input ( ) . split ( ) ) [ 1 : ] if y > a : print ( \" < \" ) elif y > a : print ( \" < \" ) else : print ( \" < \" ) NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) first = int ( 0 ) second = int ( 0 ) now = int ( 1 ) for i in range ( len ( l ) - 1 , - 1 , - 1 ) : first = first + now * l [ i ] now = now * m   n1 , m1 = map ( int , input ( ) . split ( ) ) l1 = list ( map ( int , input ( ) . split ( ) ) )   now = 1 for i in range ( len ( l1 ) - 1 , - 1 , - 1 ) : second = second + now * l1 [ i ] now = now * m1   if second == first : print ( ' = ' ) elif second > first : print ( ' < ' ) else : print ( ' > ' ) NEW_LINE"],"bleu":0.16903329568054679,"rouge_l":0.44713460684140377}
{"id":481,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["l = int ( input ( ) ) a = [ int ( bruh ) for bruh in input ( ) . split ( ) ]   a1 = sorted ( a )   cnt = 0 for x in range ( l ) : if a [ x ] != a1 [ x ] : cnt += 1   if cnt <= 2 : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.11516970155430292,"rouge_l":0.3459926017262639}
{"id":482,"predictions":["import sysfrom math import sqrt   input = sys . stdin . readline   collections . rstrip ( \" \\n \" )   t = list ( map ( int , input ( ) . split ( \" ▁ \" ) ) )   stones = [ 0 for i in range ( n + 1 ) ] for i in range ( 1 , n + 1 ) : if ( list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) ) == 0 : nodes [ i ] = list ( ) for i in range ( 1 , n ) : if ( nodes [ i ] ) > 0 ) : nodes [ i ] = nodes [ i ]   for i in range ( n - 2 , - 1 , - 1 ) : node = nodes [ i ] nodes [ i ] node . append ( node )   m = 0 for i in range ( n - 2 , - 1 , - 1 ) : if ( nodes [ i ] < 0 ) : m = nodes [ i ] [ node ] n = nodes [ i ] [ node ] mn %= mn + 1 print ( m )   NEW_LINE"],"references":["class CodeforcesTask226BSolution : def __init__ ( self ) : self . result = ' ' self . n = 0 self . piles = [ ] self . q = 0 self . variants = [ ]   def read_input ( self ) : self . n = int ( input ( ) ) self . piles = [ int ( x ) for x in input ( ) . split ( \" ▁ \" ) ] self . q = int ( input ( ) ) self . variants = [ int ( x ) for x in input ( ) . split ( \" ▁ \" ) ]   def process_task ( self ) : self . piles . sort ( reverse = True ) sums = [ 0 ] * self . n sums [ 0 ] = self . piles [ 0 ] for x in range ( self . n - 1 ) : sums [ x + 1 ] = self . piles [ x + 1 ] + sums [ x ] anwsers = { } results = [ ] for query in self . variants : if query in anwsers . keys ( ) : results . append ( anwsers [ query ] ) else : anwser = 0 factor = 1 k = 1 width = query x = 1 while x + width < self . n : anwser += ( sums [ x + width - 1 ] - sums [ x - 1 ] ) * factor factor += 1 x += width k += 1 width = query ** k anwser += ( sums [ - 1 ] - sums [ x - 1 ] ) * factor results . append ( anwser ) anwsers [ query ] = anwser self . result = \" ▁ \" . join ( [ str ( x ) for x in results ] )   def get_result ( self ) : return self . result     if __name__ == \" _ _ main _ _ \" : Solution = CodeforcesTask226BSolution ( ) Solution . read_input ( ) Solution . process_task ( ) print ( Solution . get_result ( ) ) NEW_LINE"],"bleu":0.08581893604990011,"rouge_l":0.27906609875374666}
{"id":483,"predictions":["a = int ( input ( ) ) b = lambda : list ( map ( int , input ( ) . split ( ) ) ) arr = sorted ( map ( int , input ( ) . split ( ) ) )   print ( \" NO \" ) NEW_LINE"],"references":["def binaryToDecimal ( n ) : return int ( n , 2 ) s = input ( ) s = s . replace ( \" > \" , \"1000\" ) s = s . replace ( \" < \" , \"1001\" ) s = s . replace ( \" + \" , \"1010\" ) s = s . replace ( \" - \" , \"1011\" ) s = s . replace ( \" . \" , \"1100\" ) s = s . replace ( \" , \" , \"1101\" ) s = s . replace ( \" [ \" , \"1110\" ) s = s . replace ( \" ] \" , \"1111\" ) p = binaryToDecimal ( s ) ans = p % ( ( 10 ** 6 ) + 3 ) print ( ans ) NEW_LINE"],"bleu":0.019636453241067046,"rouge_l":0.2822271857051691}
{"id":484,"predictions":["n = int ( input ( ) ) m = list ( map ( int , input ( ) . split ( ) ) ) t = list ( map ( int , input ( ) . split ( ) ) ) ) for i in range ( 0 , n ) : t [ i ] = 0 ; t [ i ] = 0 for i in range ( 0 , n ) : if t [ i ] == 1 : t [ i ] = 1 else : t [ i ] = 1 breakprint ( t ) NEW_LINE"],"references":["def gcd ( a , b ) : a , b = max ( a , b ) , min ( a , b ) while a % b != 0 : a %= b a , b = b , a return b   def gsd ( a , b ) : return a * b \/\/ gcd ( a , b )   n = int ( input ( ) ) m = list ( map ( int , input ( ) . split ( ) ) ) r = list ( map ( int , input ( ) . split ( ) ) ) x = m [ 0 ] for i in range ( 1 , n ) : x = gsd ( x , m [ i ] ) count = 0 for i in range ( x ) : for j in range ( n ) : if i % m [ j ] == r [ j ] : count += 1 breakprint ( count \/ x ) NEW_LINE"],"bleu":0.2910827887883587,"rouge_l":0.5202558635394456}
{"id":485,"predictions":["import sysinput = sys . stdin . readline   n , r , c = map ( int , input ( ) . split ( ) )   if n > r * c : print ( - 1 ) else : for i in range ( n ) : c = n \/\/ C if c % 2 != 0 : print ( - 1 ) else : for i in range ( c ) : print ( c [ i ] ) , end = ' ▁ ' ) print ( ) NEW_LINE"],"references":["n , a , b = map ( int , input ( ) . split ( ) ) if n > a * b : print ( - 1 ) else : arr = [ [ 0 ] * b for _ in range ( a ) ] x = 1 y = 2   for i in range ( a ) : for j in range ( b ) :   if ( i + j ) % 2 == 0 : if x <= n : arr [ i ] [ j ] = x x += 2 else : if y <= n : arr [ i ] [ j ] = y y += 2 NEW_LINE"],"bleu":0.28050022851748635,"rouge_l":0.45556385362210605}
{"id":486,"predictions":["n = int ( input ( ) ) ans = 0 for a in range ( 1 , n ) : ans += ( n - a ) * aprint ( ans + n ) NEW_LINE"],"references":["s = input ( ) t = input ( ) v = [ ' a ' , ' e ' , ' i ' , ' o ' , ' u ' ] if len ( s ) == len ( t ) : for i in range ( len ( s if len ( s ) < len ( t ) else t ) ) : if s [ i ] in v and t [ i ] in v : continue elif s [ i ] in v or t [ i ] in v : print ( \" NO \" ) exit ( ) else : continue print ( ' YES ' ) else : print ( ' NO ' ) NEW_LINE"],"bleu":0.011269959838576742,"rouge_l":0.19203703703703706}
{"id":487,"predictions":["n = int ( input ( ) ) x = list ( map ( int , input ( ) . split ( ) ) ) m = min ( x ) l = mc = 0 a = x [ 0 ] b = x [ - 1 ] flag = 1 while True : m = 2 ** 20 for i in range ( 1 , n - 1 ) : x [ i ] -= l if x [ i - 1 ] <= 0 and x [ i - 1 ] > 0 : m = min ( m , x [ i - 1 ] ) c += l [ i ] [ - 1 ] if c > a [ i ] : c += 1 b . append ( i ) flag = 1 breakprint ( min ( c , a , b ) ) NEW_LINE"],"references":["import sysinput = sys . stdin . readlinefrom collections import defaultdict as dcfrom collections import Counterfrom bisect import bisect_right , bisect_leftimport mathfrom operator import itemgetterfrom heapq import heapify , heappop , heappushfrom queue import PriorityQueue as pqfor _ in range ( int ( input ( ) ) ) : n , d = map ( int , input ( ) . split ( ) ) f = 0 s = math . ceil ( math . sqrt ( d ) ) i = s while ( i > 0 and f == 0 ) : if i + math . ceil ( d \/ ( i + 1 ) ) <= n : f = 1 break i -= 1 if f or d <= n : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.17464554816128583,"rouge_l":0.3011669658886894}
{"id":488,"predictions":["n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) : arr [ i ] = arr [ i ] NEW_LINE"],"references":["  n = int ( input ( ) ) lis = list ( map ( int , input ( ) . split ( ) ) ) m = int ( input ( ) ) edges = [ ] for d in range ( m ) : edges . append ( list ( map ( int , input ( ) . split ( ) ) ) ) edges . sort ( key = lambda x : x [ 2 ] ) visited = [ ] count = 0 for i in range ( m ) : if edges [ i ] [ 1 ] not in visited : visited . append ( edges [ i ] [ 1 ] ) count += edges [ i ] [ 2 ]   if len ( visited ) == n - 1 : print ( count ) else : print ( - 1 ) NEW_LINE"],"bleu":0.058204512004022484,"rouge_l":0.35601290124404855}
{"id":489,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["Into = str ( input ( ) ) NEW_LINE Into = list ( Into ) NEW_LINE hello = [ ' h ' , ' e ' , ' l ' , ' l ' , ' o ' ] NEW_LINE cur = 0 l NEW_LINE ist1 = [ ] NEW_LINE for i in Into : if NEW_LINE i == hello [ cur ] : list1 . append ( i ) NEW_LINE cur += 1 NEW_LINE if len ( list1 ) == 5 : breakif NEW_LINE list1 == hello : print ( ' YES ' ) else : print ( ' NO ' ) NEW_LINE"],"bleu":0.024747827559283925,"rouge_l":0.22321610083350277}
{"id":490,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = [ int ( x ) for x in input ( ) . split ( ' ▁ ' ) ] count = 0 for i in range ( n ) : count += 1 if ( m > a [ i ] ) : count += 1 print ( count ) NEW_LINE"],"references":["n = int ( input ( ) ) m = int ( input ( ) ) l = [ ] for i in range ( n ) : l . append ( int ( input ( ) ) ) l . sort ( reverse = True ) s = 0 for i in range ( n ) : s += l [ i ] if s >= m : print ( i + 1 ) break NEW_LINE"],"bleu":0.2455941367319124,"rouge_l":0.5154547476095175}
{"id":491,"predictions":["n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) s = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) : if ( a [ i ] < 0 ) : s += abs ( a [ i ] - a [ i + 1 ] ) if ( k % 2 == 0 ) : s -= abs ( a [ k ] ) print ( s ) NEW_LINE"],"references":["n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) i = 0 while i < n and k > 0 and a [ i ] < 0 : a [ i ] = - 1 * a [ i ] i += 1 k -= 1 a = sorted ( a ) if k % 2 == 1 : a [ 0 ] = - 1 * a [ 0 ] print ( sum ( a ) ) NEW_LINE"],"bleu":0.462147063910128,"rouge_l":0.6307378975403415}
{"id":492,"predictions":["n = int ( input ( ) ) s = input ( ) count = 0 for i in range ( 1 , n - 1 ) : if s [ i : i + 1 ] == ' F ' : count += 1 if count > count : print ( \" NO \" ) else : print ( \" YES \" ) NEW_LINE"],"references":["n = int ( input ( ) ) S = input ( ) A = S . count ( \" SF \" ) B = S . count ( \" FS \" ) if A > B : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.3868784984106455,"rouge_l":0.5525049532974808}
{"id":493,"predictions":["import syssys . stdin = open ( \" input . txt \" , \" r \" ) sys . stdout = open ( \" output . txt \" , \" w \" ) n = int ( input ( ) ) s = input ( ) for i in range ( n ) : s = input ( ) if s [ i ] == '1' : if len ( s ) == 1 : print ( \" NO \" ) exit ( ) print ( \" YES \" ) t = input ( ) for i in range ( n ) : print ( \" NO \" ) NEW_LINE"],"references":["with open ( ' input . txt ' , ' r ' ) as f : fs = f . read ( ) . strip ( ) . split ( ' \\n ' )   n = [ int ( i ) for i in fs [ 1 ] ] c = - 1 i , ans = 0 , \" YES \" while i < len ( n ) : if n [ i ] == 1 : count = 0 while i + 1 < len ( n ) : if n [ i + 1 ] == 1 : break count += 1 i += 1 else : count = c if c == - 1 : c = count elif c != count : ans = \" NO \" break i += 1   with open ( ' output . txt ' , ' w ' ) as f : f . write ( ans ) NEW_LINE"],"bleu":0.11893339479347864,"rouge_l":0.33547858647320383}
{"id":494,"predictions":["import matht = int ( input ( ) ) for i in range ( t ) : n , m , d = map ( int , input ( ) . split ( ) ) c , d = 0 , 0 for i in range ( m ) : c = max ( min ( c , ( i - 1 ) \/\/ a + d ) ) \/\/ a += c if c < n : c += 1 if c >= a : m += ( c + d ) \/\/ a , b = c \/\/ a print ( c ) NEW_LINE"],"references":["BigNum = 10 ** 20   n , m , a , d = map ( int , input ( ) . split ( ' ▁ ' ) ) ts = [ 0 ] + list ( map ( int , input ( ) . split ( ' ▁ ' ) ) ) + [ BigNum ]   def empsInRange ( l , r ) : em1 = l \/\/ a + 1 em2 = r \/\/ a return ( em1 , min ( em2 , n ) )   empDoorGroup = d \/\/ a + 1   def moveEmps ( emps , last ) : em1 , em2 = emps if em1 > em2 : return last , 0 if em1 * a <= last + d : gr1 = ( last + d - em1 * a ) \/\/ a em1 += 1 + gr1 if em1 > em2 : return last , 0   doorGroups = ( em2 - em1 + 1 + empDoorGroup - 1 ) \/\/ empDoorGroup last = ( em1 + empDoorGroup * ( doorGroups - 1 ) ) * a   return last , doorGroups   res = 0 last = - BigNum   for i in range ( 1 , len ( ts ) ) : NEW_LINE"],"bleu":0.11932491458119433,"rouge_l":0.31116458132820024}
{"id":495,"predictions":["n = int ( input ( ) ) a = [ int ( i ) for i in input ( ) . split ( ) ] d = [ ] for i in range ( n ) ]   for i in range ( n - 1 ) : if d [ i ] [ 0 ] > a [ i ] [ 1 ] : d [ i ] = min ( d [ i ] [ 0 ] , d [ i ] [ 1 ] ) : d [ i ] [ 1 ] = min ( d [ i ] [ 0 ] , a [ i ] [ 0 ] ) ] = min ( d [ i ] [ 1 ] , d [ i ] [ 0 ] ) print ( ' YES ' ) else : print ( ' NO ' ) NEW_LINE"],"references":["n = int ( input ( ) ) ans = \" YES \" num = 0 for i in range ( n ) : w , h = map ( int , input ( ) . split ( ) ) if i == 0 : num = max ( w , h ) else : if max ( w , h ) <= num : num = max ( w , h ) elif min ( w , h ) <= num : num = min ( w , h ) else : ans = \" NO \" print ( ans ) NEW_LINE"],"bleu":0.175195650461709,"rouge_l":0.3668314846986503}
{"id":496,"predictions":["import heapqn , m , k = map ( int , input ( ) . split ( ) ) p = list ( map ( int , input ( ) . split ( ) ) ) p = list ( map ( int , input ( ) . split ( ) ) ) p = [ 0 ] * mfor i in range ( n ) : p = list ( map ( int , input ( ) . split ( ) ) ) if p [ 0 ] < k : p = 0 else : p = 0 for i in range ( m ) : p = math . floor ( p [ 1 ] ) if p [ 0 ] > k [ 1 ] : p [ p [ i ] ] += 1 else : p [ i ] = 0 p = 0 for i in range ( n ) : p = list ( map ( int , input ( ) . split ( ) ) ) if p [ 0 ] : print ( \" NO \" ) else : print ( \" YES \" ) NEW_LINE"],"references":["n , m , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) ans , result = 0 , 0 page , new_result = None , 1 for i in range ( m ) : if ( a [ i ] - result ) \/\/ k != page : ans += 1 result = new_result page = ( a [ i ] - result ) \/\/ k new_result += 1 print ( ans ) NEW_LINE"],"bleu":0.23375834232199633,"rouge_l":0.4724737845567207}
{"id":497,"predictions":["def result ( n , k , s ) : NEW_LINE"],"references":["import math NEW_LINE cases = int ( input ( ) ) NEW_LINE for c in range ( cases ) : NEW_LINE INDENT length , k = map ( int , input ( ) . split ( ) ) NEW_LINE string = input ( ) NEW_LINE start = string . index ( ' * ' ) NEW_LINE end = length - 1 - string [ : : - 1 ] . index ( ' * ' ) NEW_LINE count = 1 NEW_LINE while start < end : NEW_LINE INDENT ind = start + k NEW_LINE if ind >= end : NEW_LINE INDENT count += 1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT while ind > start : NEW_LINE INDENT if string [ ind ] == ' * ' : NEW_LINE INDENT count += 1 NEW_LINE break NEW_LINE DEDENT ind -= 1 NEW_LINE DEDENT DEDENT start = ind NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT"],"bleu":5.591538274920765e-7,"rouge_l":0.07292912040990607}
{"id":498,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) c = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) : c = 0 c = n - a [ i ] if c <= 2 : c += 1 print ( c ) NEW_LINE"],"references":["n , a , b , c , T = map ( int , input ( ) . split ( ) ) ts = list ( map ( int , input ( ) . split ( ) ) ) ts . sort ( ) ans = 0 for t in ts : temp = - 10 ** 18 for u in range ( t , T + 1 ) : temp = max ( temp , c * ( u - t ) + a - b * ( u - t ) ) NEW_LINE"],"bleu":0.33614830283584834,"rouge_l":0.5092979127134725}
{"id":499,"predictions":["def solution ( ) : n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) d = { } for i in range ( len ( d ) ) : if a [ i ] != b [ i ] : d [ a [ i ] ] = 1 + 1 if a [ i ] == b [ i ] : d [ i ] = 1 + 1 if d [ i ] == a [ i ] : d [ i ] = 1 + d [ i ] else : if d [ i ] == a [ i ] : d [ i ] = 1 + 1 + 1 else : d [ i ] = d [ i ] return d [ ( d [ i ] , d - a [ i ] ] ) if d [ i ] == 1 : d [ i ] = 1 + 1 print ( 1 ) NEW_LINE"],"references":["f = lambda : [ int ( q ) - 1 for q in input ( ) . split ( ) ] def g ( ) : for i in p : if h [ i ] == k and not v [ i ] : return i   r = range ( int ( input ( ) ) ) t , h = 1e9 , f ( ) u = [ set ( f ( ) [ 1 : ] ) for i in r ]   for k in ( 0 , 1 , 2 ) : p = list ( r ) d = - 1 v = [ q . copy ( ) for q in u ]   while p : i = g ( ) while i != None : d += 1 p . remove ( i ) for q in v : q . discard ( i ) i = g ( ) k = ( k + 1 ) % 3 d += 1   t = min ( d , t )   print ( t ) NEW_LINE"],"bleu":0.1625321779250301,"rouge_l":0.3139865104721335}
{"id":500,"predictions":["s = str ( input ( ) ) s = ' ' v = s . count ( '0' ) if len ( s ) == 0 or s . count ( ' NO ' ) == 1 : print ( ' YES ' ) else : print ( ' NO ' ) NEW_LINE"],"references":["def cc ( w , me , fe ) : global m , f if w . endswith ( me ) : m = True return True elif w . endswith ( fe ) : f = True return True else : return Falsedef ad ( w ) : return cc ( w , ' lios ' , ' liala ' ) def nn ( w ) : return cc ( w , ' etr ' , ' etra ' ) def vb ( w ) : return cc ( w , ' initis ' , ' inites ' ) s , n , m , f = input ( ) . split ( ) , False , False , False for w in s : if not n : if ad ( w ) or vb ( w ) and len ( s ) == 1 : pass elif nn ( w ) : n = True else : print ( \" NO \" ) exit ( ) elif not vb ( w ) : print ( \" NO \" ) exit ( ) print ( ' YES ' if len ( s ) == 1 or ( n and ( m ^ f ) ) else ' NO ' ) NEW_LINE"],"bleu":0.021512810783668956,"rouge_l":0.2232202262142382}
{"id":501,"predictions":["s = input ( ) s = \" { } \" for i in s : if i not in s : s . append ( i ) print ( len ( s ) ) NEW_LINE"],"references":["letters = list ( map ( str , input ( ) ) ) c = set ( ) for letter in letters : if letter . isalpha ( ) : c . add ( letter ) print ( len ( c ) ) NEW_LINE"],"bleu":0.17694987840360688,"rouge_l":0.4911433172302737}
{"id":502,"predictions":["l1 , r2 = map ( int , input ( ) . split ( ) ) l1 , r2 , k = min ( l1 , r2 ) , l1 = min ( r1 , l2 ) , r2 = min ( r1 , l2 ) , r2 = min ( l1 , r2 ) , max ( r1 , l2 ) print ( r - l + 1 ) NEW_LINE"],"references":["if __name__ == \" _ _ main _ _ \" : a , b , c , d , k = map ( int , input ( ) . split ( ) ) start = max ( a , c ) end = min ( b , d ) ans = end - start if ans < 0 : ans = 0 elif k < start or k > end : ans = ans + 1 print ( ans ) NEW_LINE"],"bleu":0.23071624362124377,"rouge_l":0.37710509486250265}
{"id":503,"predictions":["n , k = [ int ( x ) for x in input ( ) . split ( \" ▁ \" ) ] a = [ int ( x ) for x in input ( ) . split ( \" ▁ \" ) ] d = { } for i in range ( k ) : d [ i ] = 1 if d [ i ] == 1 : d [ i ] = 1 if d [ i ] == 0 : d [ i ] = 1 else : d [ i ] = 0 ans = [ ] for i in range ( k , n ) : ans . append ( d [ i ] ) d [ i ] = [ ] for i in range ( k ) : for j in range ( j , k ) : if d [ i ] [ j ] == 1 : ans . append ( d [ i ] [ j ] , end = \" ▁ \" ) print ( \" ▁ \" ) for i in ans : print ( * ans ) NEW_LINE"],"references":["def main ( ) : start , end , t = map ( int , input ( ) . split ( ) ) n = int ( input ( ) ) people = [ ] if n != 0 : people = list ( map ( int , input ( ) . split ( ) ) ) time = start ans = 1e16 answer = 0 for p in people : if p + t > end : break if p - 1 >= 0 : if ans > max ( 0 , time - ( p - 1 ) ) : ans = max ( 0 , time - ( p - 1 ) ) answer = p - 1   time = max ( time , p ) + t   if time + t > end : break   if time + t <= end : answer = time print ( answer )   main ( ) NEW_LINE"],"bleu":0.10239685358415226,"rouge_l":0.299358248395621}
{"id":504,"predictions":["s = input ( ) if len ( s ) == 1 : print ( \" YES \" ) else : for i in range ( len ( s ) ) : if s [ i ] == ' A ' and s [ i ] == ' A ' ) : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"references":["s = input ( ) if ( s . find ( \" AB \" ) != - 1 and s . find ( \" BA \" ) != - 1 and ( s . find ( \" AB \" ) + 1 < s . rfind ( \" BA \" ) or s . find ( \" BA \" ) + 1 < s . rfind ( \" AB \" ) ) ) : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.27625684363978925,"rouge_l":0.462594794015167}
{"id":505,"predictions":["n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) sum = 0 for i in range ( n ) : sum += l [ i ] if sum > 0 : sum += 1 print ( sum ) NEW_LINE"],"references":["c = 0 for i in range ( int ( input ( ) . split ( ) [ 0 ] ) ) : a = input ( ) . split ( ) while len ( a ) : if '1' in [ a . pop ( ) , a . pop ( ) ] : c += 1 print ( c ) NEW_LINE"],"bleu":0.3287894869350427,"rouge_l":0.4520999176502882}
{"id":506,"predictions":["n = int ( input ( ) ) print ( int ( ( n \/\/ 2 ) + 3 ) * 3 ) NEW_LINE"],"references":["n = int ( input ( ) ) NEW_LINE print ( n \/\/ 2 * 3 ) NEW_LINE"],"bleu":0.5289153452794635,"rouge_l":0.8309294871794871}
{"id":507,"predictions":["n = int ( input ( ) ) s = input ( ) ans = 0 while ( n > 0 ) : ans += ( n % 10 ) n = n \/\/ 10 print ( ans ) NEW_LINE"],"references":["print ( ( int ( input ( ) ) - 1 ) % 9 + 1 ) NEW_LINE"],"bleu":0.17423644106955566,"rouge_l":0.37014563106796117}
{"id":508,"predictions":["for _ in range ( int ( input ( ) ) ) : a , b = map ( int , input ( ) . split ( ) ) print ( max ( a , b ) ) ) NEW_LINE"],"references":["a = int ( input ( ) ) for i in range ( a ) : c , d = map ( int , input ( ) . split ( ) ) c , d = min ( c , d ) , max ( c , d ) if ( 2 * c > d ) : print ( 2 * 2 * c * c ) else : print ( d * d ) NEW_LINE"],"bleu":0.21899274729202253,"rouge_l":0.48515376458112414}
{"id":509,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) : if a [ i ] != a [ i - 1 ] : a [ i ] = a [ i - 1 ] + 1 else : a [ i ] = a [ i - 1 ] + 1 a . sort ( ) print ( * a ) NEW_LINE"],"references":["n = int ( input ( ) )   a = [ int ( i ) for i in input ( ) . split ( ' ▁ ' ) ]   m = int ( input ( ) ) b = [ int ( i ) for i in input ( ) . split ( ' ▁ ' ) ]     store = { } vasya , petya = 0 , 0   max_stored = 0   for bi in b :   if bi not in store :   i = max_stored while bi not in store : store [ a [ i ] ] = ( i + 1 , n - i ) i += 1 max_stored = i vasya += store [ bi ] [ 0 ] petya += store [ bi ] [ 1 ]   print ( vasya , petya ) NEW_LINE"],"bleu":0.16228194840562316,"rouge_l":0.38282814795032716}
{"id":510,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , input ( ) . split ( ) ) ) for i in range ( 1 ) : NEW_LINE"],"references":["n = int ( input ( ) ) b = [ 0 ] * 26 result = 0 for i in range ( n ) : s = input ( ) b [ ord ( s [ 0 ] ) - 97 ] += 1 for i in b : result += ( ( i \/\/ 2 ) * ( i \/\/ 2 - 1 ) ) \/\/ 2 result += ( ( i - i \/\/ 2 ) * ( i - i \/\/ 2 - 1 ) ) \/\/ 2 print ( result ) NEW_LINE"],"bleu":0.06428605944491174,"rouge_l":0.2642408490361707}
{"id":511,"predictions":["arr = list ( map ( int , input ( ) . split ( ) ) ) n = arr [ 0 ] m = arr [ 1 ] k = ( 10 ** 9 ) + 7 print ( pow ( 2 ** m - 1 , n , k ) ) NEW_LINE"],"references":["def find_company ( friends , d ) :   def mergesort_tuples ( tuples , index ) :   def merge ( A , B ) : i , j = 0 , 0 result = [ ] while i < len ( A ) and j < len ( B ) : if A [ i ] [ index ] < B [ j ] [ index ] : result . append ( A [ i ] ) i += 1 else : result . append ( B [ j ] ) j += 1   result += A [ i : ] result += B [ j : ]   return result   def divide ( tuples ) : if len ( tuples ) > 1 : middle = len ( tuples ) \/\/ 2 return merge ( divide ( tuples [ : middle ] ) , divide ( tuples [ middle : ] ) )   return tuples   return divide ( tuples )   def solve ( friends , d ) : friends = mergesort_tuples ( friends , 0 ) left_ptr = 0 right_ptr = 0 current_friendship = 0 max_friendship = 0 while right_ptr < len ( friends ) : if friends [ right_ptr ] [ 0 ] - friends [ left_ptr ] [ 0 ] < d : current_friendship += friends [ right_ptr ] [ 1 ] right_ptr += 1 else : max_friendship = max ( current_friendship , max_friendship ) current_friendship -= friends [ left_ptr ] [ 1 ] left_ptr += 1   max_friendship = max ( current_friendship , max_friendship )   return max_friendship   return solve ( friends , d )     if __name__ == \" _ _ main _ _ \" : n , d = [ int ( x ) for x in input ( ) . split ( ) ] friends = [ ] for _ in range ( n ) : friends . append ( tuple ( [ int ( x ) for x in input ( ) . split ( ) ] ) ) print ( find_company ( friends , d ) ) NEW_LINE"],"bleu":0.0011862749455734075,"rouge_l":0.12087756546355274}
{"id":512,"predictions":["a , b , c = map ( int , input ( ) . split ( ) ) d = abs ( a - i ) if b < c : d += 1 elif a < c : b += 1 if a > d : a += 1 b -= c else : d = a + 1 print ( a , b ) NEW_LINE"],"references":["a , b = map ( int , input ( ) . split ( ) ) first = 0 second = 0 draw = 0 for i in range ( 1 , 7 ) : if abs ( a - i ) > abs ( b - i ) : second += 1 elif abs ( a - i ) < abs ( b - i ) : first += 1 else : draw += 1 print ( first , draw , second ) NEW_LINE"],"bleu":0.2865009249198223,"rouge_l":0.541077085533263}
{"id":513,"predictions":["for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = set ( arr ) NEW_LINE if len ( s ) == 1 : print ( \" NO \" ) else : print ( \" YES \" ) NEW_LINE"],"references":["from math import ceil   for t in range ( int ( input ( ) ) ) : a , b , c , d = map ( int , input ( ) . split ( ) ) if b >= a : print ( b ) continue if c - d <= 0 : print ( - 1 ) continue s = b + ceil ( ( a - b ) \/ ( c - d ) ) * c if s > a : print ( s ) else : print ( - 1 ) NEW_LINE"],"bleu":0.29636120104775393,"rouge_l":0.48541114058355433}
{"id":514,"predictions":["from collections import defaultdict , deque , Counterfrom sys import stdin , stdoutfrom heapq import heappush , heappopimport mathimport ioimport bisect   NEW_LINE"],"references":["def read ( ) : return list ( map ( int , input ( ) . split ( ) ) )     [ n ] = read ( ) s = input ( ) indices = [ [ ] for i in range ( 26 ) ] for i in range ( n ) : indices [ ord ( s [ i ] ) - ord ( ' a ' ) ] += [ i + 1 ]     def run ( ) : s = input ( ) a = [ 0 for _ in range ( 26 ) ] for i in range ( len ( s ) ) : a [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 ans = 0 for i in range ( 26 ) : if a [ i ] >= 1 : ans = max ( ans , indices [ i ] [ a [ i ] - 1 ] ) return ans     [ t ] = read ( ) for i in range ( t ) : print ( run ( ) ) NEW_LINE"],"bleu":0.000030373427211803167,"rouge_l":0.0318247032737707}
{"id":515,"predictions":["word = input ( )     ans = 0 for i in range ( len ( word ) ) : if word [ i ] == ' A ' : ans += 1 elif word [ i ] == ' B ' : ans += 1 print ( ans ) NEW_LINE"],"references":["s = input ( ) a , b , c = 0 , 0 , 0 for i in s : if i == \" Q \" : c += b a += 1 elif i == \" A \" : b += aprint ( c ) NEW_LINE"],"bleu":0.17492923638212146,"rouge_l":0.4834874504623514}
{"id":516,"predictions":["a , b , m , x = map ( int , input ( ) . split ( ) ) d = { } for i in range ( b ) : x = ( i * x + b ) % m if d [ x ] == 0 : d [ x ] = x + 1 else : d [ x ] = 1 * x = ( y * x + b ) % m print ( d ) NEW_LINE"],"references":["a , b , m , r = map ( int , input ( ) . split ( ) ) d = { } i = 1 while 1 : r = ( a * r + b ) % m ; t = d . get ( r , 0 ) if t : i -= t ; break d [ r ] = i ; i += 1 print ( ) print ( i ) NEW_LINE"],"bleu":0.3620437679400714,"rouge_l":0.5841483292583536}
{"id":517,"predictions":["x , y = map ( int , input ( ) . split ( ) ) s = abs ( x - y ) if s < 2 : print ( ' No ' ) else : print ( ' Yes ' ) NEW_LINE"],"references":["a , b , c = map ( int , input ( ) . split ( ) ) if abs ( a ) + abs ( b ) <= c : if ( c - ( abs ( a ) + abs ( b ) ) ) % 2 == 0 : print ( ' Yes ' ) else : print ( \" No \" ) else : print ( \" No \" ) NEW_LINE"],"bleu":0.27530072862491056,"rouge_l":0.4976315789473684}
{"id":518,"predictions":["n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) )   visited = [ False ] * 4   for i in range ( 4 ) : if i == n : if visited [ i ] == arr [ i ] : visited [ i ] = False breakprint ( repeated ) NEW_LINE"],"references":["print ( 4 - len ( { * input ( ) . split ( ) } ) ) NEW_LINE"],"bleu":0.12318075922726579,"rouge_l":0.3038605230386052}
{"id":519,"predictions":["n = int ( input ( ) ) s = input ( ) c = 0 for i in range ( len ( s ) ) : if i % 2 == 0 and s [ i - 1 ] != s [ i - 2 ] : c += 1 print ( c * ( c + 1 ) \/\/ 2 ) NEW_LINE"],"references":["n = int ( input ( ) ) s = input ( ) c = 0 for i in range ( n , len ( s ) , n ) : tmp = s [ i - 3 : i ] if ' a ' in tmp and ' b ' in tmp : continue c += 1 print ( c ) NEW_LINE"],"bleu":0.5015437046877633,"rouge_l":0.6623578076525336}
{"id":520,"predictions":["import sysfrom functools import lru_cache , cmp_to_keyfrom heapq import merge , heapify , heappop , heappushfrom math import * from collections import defaultdict as dd , deque , Counter as Cfrom itertools import combinations as comb , permutations as permfrom bisect import bisect_left as bl , bisect_right as br , bisect , insortfrom time import perf_counterfrom fractions import Fractionimport copyfrom copy import deepcopyimport timestarttime = time . time ( ) mod = int ( pow ( 10 , 9 ) + 7 ) mod2 = 998244353   def data ( ) : return sys . stdin . readline ( ) . strip ( ) def out ( * var , end = \" \\n \" ) : sys . stdout . write ( ' ▁ ' . join ( map ( str , var ) ) + end ) def L ( ) : return list ( sp ( ) ) def sl ( ) : return list ( ssp ( ) ) def sp ( ) : return map ( int , data ( ) . split ( ) ) def ssp ( ) : return map ( str , data ( ) . split ( ) ) def l1d ( n , val = 0 ) : return [ val for i in range ( n ) ] def l2d ( n , m , val = 0 ) : return [ l1d ( n , val ) for j in range ( n ) ] try : NEW_LINE"],"references":["n , Q = map ( int , input ( ) . strip ( ) . split ( ) )   s = input ( ) d = 1   for q in range ( Q ) : arr = [ 0 ] * ( 10 )   l , r = map ( int , input ( ) . strip ( ) . split ( ) )   su = \" \" for i in range ( l - 1 , r ) : su += s [ i ] su = list ( su ) i = 0 d = 1 NEW_LINE"],"bleu":0.1200609184424959,"rouge_l":0.2983331669827328}
{"id":521,"predictions":["n , m = list ( map ( int , input ( ) . split ( ) ) ) arr = list ( map ( int , input ( ) . split ( ) ) )   x = 0 y = 0 for i in range ( n ) : if arr [ i ] > x : x += 1 arr [ i ] -= i y += 1   print ( x ) NEW_LINE"],"references":["''' import ▁ syssys . stdin = open ( \" input . txt \" , \" r \" ) sys . stdout = open ( \" output . txt \" , \" w \" ) '''   n = input ( ) ans = list ( ) while int ( n ) > 0 : s = \" \" for c in n : if c != '0' : s += '1' else : s += '0' n = str ( int ( n ) - int ( s ) ) ans . append ( s ) print ( len ( ans ) ) for a in ans : print ( a , end = \" ▁ \" ) NEW_LINE"],"bleu":0.05376056956159181,"rouge_l":0.27349879903923136}
{"id":522,"predictions":["import sysinput = sys . stdin . readline   n , q = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( q ) : a , b = map ( int , input ( ) . split ( ) ) if a % 2 != : print ( a + 1 ) \/\/ 2 ) else : print ( ( a + 1 ) \/\/ 2 ) NEW_LINE"],"references":["s = input ( ) t = input ( ) arr = [ x - 1 for x in map ( int , input ( ) . split ( ) ) ] l = 0 r = len ( s ) - 1     def check ( sa , sb ) : j = 0 for i in range ( len ( sb ) ) : while j < len ( sa ) and sa [ j ] != sb [ i ] : j += 1 if j == len ( sa ) : return False j += 1 return True     while l < r : mid = ( l + r + 1 ) >> 1 d = list ( s ) for i in range ( mid ) : d [ arr [ i ] ] = ' ' if check ( \" \" . join ( d ) , t ) : l = mid else : r = mid - 1 print ( l ) NEW_LINE"],"bleu":0.09906335637815056,"rouge_l":0.2878751210067764}
{"id":523,"predictions":["s = input ( ) d = 0 e = 0 for i in range ( len ( s ) ) : if ( s [ i ] == ' ) : if ( s [ i ] == ' ( ' and s [ i + 1 ] == ' ) ) : e += 1 else : if ( e [ len ( s ) - 1 ] == ' ) : e += 1 elif ( s [ - 1 ] == ' ) ' : e += 1 else : e += 1 NEW_LINE"],"references":["from __future__ import division , print_functionfrom collections import * from math import * from itertools import * from time import timeimport osimport sysfrom io import BytesIO , IOBase if sys . version_info [ 0 ] < 3 : from __builtin__ import xrange as range from future_builtins import ascii , filter , hex , map , oct , zip ''' Notes : k ▁ first ▁ latin ▁ lettersn ▁ = ▁ length ▁ of ▁ the ▁ string ▁ s '''   def main ( ) : s = input ( ) st = [ ] res = 0 for i in s : if i == \" ( \" : st . append ( i ) continue if not st and i == \" ) \" : continue if st [ - 1 ] == \" ( \" and i == \" ) \" : st . pop ( ) res += 2 else : continue print ( res ) \t     NEW_LINE"],"bleu":0.08572507038992688,"rouge_l":0.2762812872467223}
{"id":524,"predictions":["n , h , k = map ( int , input ( ) . split ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) ) for i in range ( 0 , n ) : arr [ i ] + ( arr [ i ] - arr [ i - 1 ] ) \/ ( k + 1 ) print ( * arr ) NEW_LINE"],"references":["n , h , k = [ int ( i ) for i in input ( ) . split ( ) ] H = [ int ( i ) for i in input ( ) . split ( ) ]   curr = 0 t = 0   for i in range ( n ) : if curr + H [ i ] <= h : curr += H [ i ] t += curr \/\/ k curr %= k else : t += 1 curr = H [ i ] % k t += H [ i ] \/\/ k   if curr != 0 : t += 1 print ( t )   NEW_LINE"],"bleu":0.2266713627249972,"rouge_l":0.4618169848584595}
{"id":525,"predictions":["def gcd ( a , b ) : if b == 0 : return a return gcd ( b , a % b ) n , m = [ int ( x ) for x in input ( ) . split ( ' ▁ ' ) ] dp = [ [ ] for i in range ( n + 1 ) ] for i in range ( n + 1 ) : for j in range ( m ) : dp [ i ] [ j ] = dp [ i ] [ j ] = dp [ i ] [ j ] + 1 for i in range ( n + 1 ) : dp [ i ] [ j ] = dp [ i ] [ j ] + 1 for i in range ( n + 1 ) : dp [ i ] [ j ] = dp [ i + 1 ] [ j ] + dp [ i ] [ j - 1 ] ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] dp [ i ] [ j ] = dp [ i + 1 ] [ j + 1 ] for i in range ( n + 1 ) : dp [ i ] [ j ] = max ( dp [ i ] [ j ] ) ans = dp [ [ i ] [ j ] for i in range ( n + 1 ) : ans += dp [ i - 1 ] [ j ] print ( ans ) NEW_LINE"],"references":["def solve ( ) : n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) x , ct , max_ct = 0 , 0 , 0 for i in range ( 0 , n ) : if ( x < l [ i ] ) : x = l [ i ] for i in range ( 0 , n ) : if ( l [ i ] == x ) : ct += 1 else : max_ct = max ( ct , max_ct ) ct = 0 max_ct = max ( ct , max_ct ) print ( max_ct ) solve ( ) NEW_LINE"],"bleu":0.09522612042473645,"rouge_l":0.3317020119630234}
{"id":526,"predictions":["print ( ' ? ' , ' ? ' , ' = input ( ) ) s = input ( ) for i in range ( 1 , len ( s ) ) : if s [ i ] != ' ? ' : s [ i % 4 ] = s [ i % 4 ] + s [ i % 4 ] if s [ i % 4 ] == ' ? ' : print ( s [ i % 4 ] , s [ i % 4 ] ) NEW_LINE"],"references":["s = input ( ) if s . count ( ' ! ' ) == 0 : print ( \"0 ▁ 0 ▁ 0 ▁ 0\" ) else : kr = kb = ky = kg = 0 l = len ( s ) k = [ 0 , 0 , 0 , 0 ] for i in range ( l ) : if s [ i ] != ' ! ' : j = i % 4 k [ j ] = s [ i ] for i in range ( l ) : if s [ i ] == ' ! ' : j = k [ i % 4 ] if j == ' R ' : kr += 1 if j == ' B ' : kb += 1 if j == ' Y ' : ky += 1 if j == ' G ' : kg += 1 print ( \" { } ▁ { } ▁ { } ▁ { } \" . format ( kr , kb , ky , kg ) )   NEW_LINE"],"bleu":0.1502184967012492,"rouge_l":0.35045623521459957}
{"id":527,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( 1 , n + 1 ) : if ( i + 1 ) < 5 : a += ( n - i \/\/ 5 ) print ( a ) NEW_LINE"],"references":["a , b = map ( int , input ( ) . split ( \" ▁ \" ) ) m = min ( a , b ) n = max ( a , b ) c = 0 for i in range ( 1 , m + 1 ) : num = i % 5 if num == 0 : num = 5 init = abs ( 5 - num ) ans = ( abs ( n - init ) ) \/\/ 5 if num != 5 and num + n >= 5 : ans += 1 c += ansprint ( c ) NEW_LINE"],"bleu":0.22455496078528667,"rouge_l":0.47060984570168984}
{"id":528,"predictions":["from math import ceil   if __name__ == ' _ _ main _ _ ' : n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) )   tieve = [ 0 ] * ( n + 1 ) for i in range ( 2 , n + 1 ) : for j in range ( i * i , n + 1 , i ) : if arr [ j ] == 1 : tieve . append ( arr [ j ] ) i = j + 1 print ( t ) NEW_LINE"],"references":["import math   n = int ( input ( ) ) answer = \" \" if n < 3 : print ( 1 ) else : print ( 2 )   m = n + 2 numbers = [ True ] * mnumbers [ 0 ] = Falsenumbers [ 1 ] = False   for i in range ( 2 , int ( math . sqrt ( m ) ) + 1 ) : j = 0 while i ** 2 + j * i < m : numbers [ i ** 2 + j * i ] = False j += 1   for i in range ( 2 , m ) : if numbers [ i ] : answer += \"1 ▁ \" else : answer += \"2 ▁ \"   answer = answer [ : - 1 ] print ( answer ) NEW_LINE"],"bleu":0.1760671900051887,"rouge_l":0.3898007768450069}
{"id":529,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( 1 , n - 1 ) : if b [ i ] < n1 and b [ i ] > b [ i + 1 ] : b [ i ] = a [ i - 1 ] if a [ i ] > b [ i - 1 ] and b [ i ] > a [ i + 1 ] : ans = 0 else : ans += 1 print ( ans ) NEW_LINE"],"references":["n = int ( input ( ) ) arr = [ int ( num ) for num in input ( ) . split ( ) ] count = 0 for i in range ( 1 , len ( arr ) - 1 ) : if ( arr [ i - 1 ] < arr [ i ] and arr [ i + 1 ] < arr [ i ] or arr [ i - 1 ] > arr [ i ] and arr [ i + 1 ] > arr [ i ] ) : count += 1 print ( count ) NEW_LINE"],"bleu":0.3786515350848666,"rouge_l":0.629514963880289}
{"id":530,"predictions":["n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) d = [ 0 ] * ( n + 1 ) b = arr [ 0 ] ) i = 0 while i < n : if arr [ i ] <= arr [ i - 1 ] and b [ i ] != arr [ i ] : b [ i ] = True break i += 1 print ( d ) NEW_LINE"],"references":["    n = int ( input ( ) )   t = list ( map ( int , input ( ) . split ( ) ) )     c = 0     a = [ ] p = 0 m = 0 while len ( a ) + len ( t ) != 0 : if len ( a ) == 0 and len ( t ) != 0 : while len ( t ) != 0 : x = t . pop ( 0 ) if x <= c : c += 1 else : a . append ( x ) m += 1 else :   while len ( a ) != 0 : v = a . pop ( ) if v <= c : c += 1 else : t = [ v ] + t m += 1           print ( m - 1 ) NEW_LINE"],"bleu":0.18484735780635303,"rouge_l":0.36341069877125476}
{"id":531,"predictions":["try : t = input ( ) . split ( \" ▁ \" ) NEW_LINE n = int ( t [ 0 ] ) NEW_LINE a = [ int ( 1 ) for 2 in input ( ) . split ( \" ▁ \" ) ] NEW_LINE for i in range ( n ) : print ( i [ 0 ] ) NEW_LINE"],"references":["import sys   def main ( ) : _ , s = sys . stdin . read ( ) . strip ( ) . split ( ' \\n ' ) t = s . replace ( ' ▁ ' , ' ' ) . rstrip ( s [ - 1 ] ) return len ( t ) print ( main ( ) ) NEW_LINE"],"bleu":0.14110375276570844,"rouge_l":0.3302397525135344}
{"id":532,"predictions":["for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE i = 0 NEW_LINE while i < n : if NEW_LINE arr [ i ] == 1 : arr . append ( i ) NEW_LINE i += 1 NEW_LINE while i < n : if NEW_LINE arr [ i ] [ 0 ] == 1 : i += 1 NEW_LINE arr . append ( i ) NEW_LINE DEDENT"],"references":["t = int ( input ( ) ) NEW_LINE ans = [ ]   for _ in range ( t ) : n = int ( input ( ) ) NEW_LINE a = list ( map ( str , input ( ) . split ( ) ) )   ind = [ ] NEW_LINE c = 0   for i in range ( len ( a ) ) : if NEW_LINE a [ i ] == '1' : ind . append ( i )   for i in range ( 0 , len ( ind ) - 1 ) : c += ind [ i + 1 ] - ind [ i ] - 1   ans . append ( c )   for i in ans : print ( i ) NEW_LINE"],"bleu":0.34792663969559423,"rouge_l":0.5393755180989224}
{"id":533,"predictions":["for t in range ( int ( input ( ) ) ) : a , b , c = map ( int , input ( ) . split ( ) ) if a != p : print ( \" NO \" ) else : print ( \" YES \" ) NEW_LINE"],"references":["import sys , os , iofrom sys import stdinfrom math import log , gcd , ceilfrom collections import defaultdict , deque , Counterfrom heapq import heappush , heappop , heapifyfrom bisect import bisect_left , bisect_rightimport math def ii ( ) : return int ( input ( ) ) def li ( ) : return list ( map ( int , input ( ) . split ( ) ) ) if ( os . path . exists ( ' input . txt ' ) ) : sys . stdin = open ( \" input . txt \" , \" r \" ) ; sys . stdout = open ( \" output . txt \" , \" w \" ) else : input = io . BytesIO ( os . read ( 0 , os . fstat ( 0 ) . st_size ) ) . readline   no = \" No \" yes = \" Yes \"     def solve ( ) : a , b = li ( ) x = ( pow ( a * b , 1 \/ 3 ) ) x = round ( x ) if x * x * x == a * b and a % x == b % x == 0 : print ( yes ) else : print ( no )                 t = 1 t = int ( input ( ) ) for _ in range ( t ) : solve ( ) NEW_LINE"],"bleu":0.01496149801478143,"rouge_l":0.1983739837398374}
{"id":534,"predictions":["a , b , c = map ( int , input ( ) . split ( ) ) arr = sorted ( map ( int , input ( ) . split ( ) ) )   ans = arr [ - b ] - arr [ c - 2 ]   print ( ans ) NEW_LINE"],"references":["s1 = input ( ) s2 = input ( ) s3 = input ( )   if ( s1 == s3 [ : : - 1 ] ) and ( s2 [ 0 ] == s2 [ 2 ] ) : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.09623411191468635,"rouge_l":0.375}
{"id":535,"predictions":["def solve ( ) : n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ' ▁ ' ) ) ) ) d = sum ( a ) NEW_LINE"],"references":["import sysinput = sys . stdin . readlinen = int ( input ( ) ) ar = list ( map ( int , input ( ) . split ( ) ) ) dic = { } li = [ ] for i in range ( n ) : xx = [ ] for j in range ( n - i ) : xx . append ( 0 ) li . append ( xx . copy ( ) ) for i in range ( n ) : for j in range ( n - i ) : if ( i == 0 ) : li [ i ] [ j ] = ar [ j ] else : li [ i ] [ j ] = li [ i - 1 ] [ j ] ^ li [ i - 1 ] [ j + 1 ] for i in range ( 1 , n ) : for j in range ( n - i ) : li [ i ] [ j ] = max ( li [ i ] [ j ] , li [ i - 1 ] [ j ] , li [ i - 1 ] [ j + 1 ] ) for _ in range ( int ( input ( ) ) ) : l , r = map ( int , input ( ) . split ( ) ) print ( li [ r - l ] [ l - 1 ] ) NEW_LINE"],"bleu":0.003324242234430496,"rouge_l":0.17037406483790524}
{"id":536,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = { input ( ) for _ in range ( n ) } b = { input ( ) for _ in range ( m ) } u = len ( a . intersection ( b ) ) print ( \" NO \" ) if m - u + u \/\/ 2 >= n - u + ( u + 1 ) \/\/ 2 else print ( \" YES \" ) NEW_LINE"],"references":["def bs ( l , h ) : while l < h : m = ( l + h + 1 ) \/\/ 2 if a [ m ] < i : l = m else : h = m - 1 return l   n , m = map ( int , input ( ) . split ( ) ) c , t = map ( int , input ( ) . split ( ) ) l = c * ta = [ 0 ] for _ in range ( n - 1 ) : c , t = map ( int , input ( ) . split ( ) ) a . append ( l ) l = a [ - 1 ] + c * tb = map ( int , input ( ) . split ( ) ) for i in b : print ( bs ( 0 , n - 1 ) + 1 ) NEW_LINE"],"bleu":0.1691650583594372,"rouge_l":0.3574367285874579}
{"id":537,"predictions":["import mathn , k = map ( int , input ( ) . split ( ) ) d = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE count = 0 NEW_LINE freq = [ 0 ] * ( k + 1 ) NEW_LINE for i in range ( k ) : freq [ i ] += 1 NEW_LINE freq [ i ] += 1 NEW_LINE"],"references":["n , k = map ( int , input ( ) . split ( ) ) A = [ int ( input ( ) ) for i in range ( n ) ] from collections import CounterC = Counter ( A ) B = [ ] ans = 0 r = 0 for k , v in C . items ( ) : if v % 2 == 0 : ans += v else : ans += v - 1 r += 1 ans += ( r + 1 ) \/\/ 2 print ( ans ) NEW_LINE"],"bleu":0.27807848635354754,"rouge_l":0.4125195075429166}
{"id":538,"predictions":["import mathn , k = map ( int , input ( ) . strip ( ) . split ( ' ▁ ' ) ) NEW_LINE"],"references":["import sysfrom collections import dequeimport mathinput_ = lambda : sys . stdin . readline ( ) . strip ( \" \\n \" ) ii = lambda : int ( input_ ( ) ) il = lambda : list ( map ( int , input_ ( ) . split ( ) ) ) ilf = lambda : list ( map ( float , input_ ( ) . split ( ) ) ) ip = lambda : input_ ( ) fi = lambda : float ( input_ ( ) ) li = lambda : list ( input_ ( ) ) pr = lambda x : print ( x ) f = lambda : sys . stdout . flush ( )   a , b , c , d = il ( ) print ( 2 * ( a + b + d + 2 ) ) NEW_LINE"],"bleu":0.003984487585044969,"rouge_l":0.17741659538066723}
{"id":539,"predictions":["n = int ( input ( ) ) s = input ( ) s = s . replace ( ' a ' , ' b ' ) print ( len ( s ) ) NEW_LINE"],"references":["n = int ( input ( ) ) s = input ( ) t , i , count = ' ' , 0 , 0 while i < n - 1 : if s [ i : i + 2 ] != ' ab ' and s [ i : i + 2 ] != ' ba ' : t += ' ab ' count += 1 else : t += s [ i : i + 2 ] i += 2 print ( count ) print ( t ) NEW_LINE"],"bleu":0.09540776397711885,"rouge_l":0.3526860997350036}
{"id":540,"predictions":["import mathn = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) lo , hi = 0 , 1 for i in range ( len ( a ) ) : if i > hi : mid = ( lo + hi + 1 ) if i == n - 1 : hi = mid else : hi = mid - 1 ans = ( ( hi - i ) * 2 + ( 2 * i + 1 ) ) if sum ( a [ i ] ) == n : ans = mid \/\/ 2 + 1 print ( ans ) NEW_LINE"],"references":["n = int ( input ( ) ) x = 1 res = [ ] for i in range ( 64 ) : lo , hi = 0 , int ( 1e15 ) f = 0 ans = 0 while lo + 1 < hi : mid = ( lo + hi ) \/\/ 2 v = ( x - 1 ) * mid + ( mid * mid - mid ) \/\/ 2 if ( v == n ) : f = 1 ; ans = mid break ; if ( v > n ) : hi = mid else : lo = mid if ( f and ans % 2 == 1 ) : res . append ( ans * x ) x = x * 2 if ( len ( res ) == 0 ) : print ( - 1 ) ; exit ( 0 ) for x in res : print ( int ( x ) ) NEW_LINE"],"bleu":0.22847377155537116,"rouge_l":0.3900879296562749}
{"id":541,"predictions":["from math import sqrtfor _ in range ( int ( input ( ) ) ) : r = input ( ) a = list ( input ( ) ) b = list ( map ( int , input ( ) . split ( ' . ' ) ) ) x = 0 for i in range ( 10 ) : if a [ i ] [ j ] == ' . ' : r += 1 if a [ i ] [ j ] == ' X ' : r += 1 if a [ i ] [ j ] == ' X ' else : r += 1 if a [ i ] [ j ] == ' X ' : r += 1 if ( r == 5 ) : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"references":["def checkhor ( x , y ) : c = 0 cy = y + 1 while ( cy < n and grid [ x ] [ cy ] == ' X ' ) : cy += 1 c += 1 if ( c >= 4 ) : return True cy = y - 1 while ( cy >= 0 and grid [ x ] [ cy ] == ' X ' ) : cy -= 1 c += 1 NEW_LINE"],"bleu":0.10202144153961414,"rouge_l":0.3054164770141102}
{"id":542,"predictions":["n , f = map ( int , input ( ) . split ( ) ) gain = [ ] sold = 0 for i in range ( n ) : k , l = map ( int , input ( ) . split ( ) ) sold += min ( l , k ) if l == 0 or k == 0 or l < k : gain . append ( 0 ) else : if 2 * k > l : gain . append ( l - k ) else : gain . append ( k )   gain = sorted ( gain , reverse = True ) for i in range ( f ) : sold += gain [ i ] print ( sold ) NEW_LINE"],"references":["import math   def gcd ( a , b ) : if a < b : a , b = b , a while a % b != 0 : a , b = b , a % b return b   n , k , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) )   r = { } for i in range ( n ) : e = a [ i ] % m if e in r : r [ e ] . append ( a [ i ] ) else : r [ e ] = [ a [ i ] ]   for key in r : if len ( r [ key ] ) >= k : print ( \" Yes \" ) for i in range ( k ) : print ( r [ key ] [ i ] , end = \" ▁ \" ) breakelse : print ( \" No \" )   NEW_LINE"],"bleu":0.24047963394434493,"rouge_l":0.36408700050581694}
{"id":543,"predictions":["import sysfrom functools import lru_cache , cmp_to_keyfrom heapq import merge , heapify , heappop , heappushfrom math import * from collections import defaultdict as dd , deque NEW_LINE"],"references":["t = int ( input ( ) ) NEW_LINE for j in range ( t ) : n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : new = [ ] NEW_LINE if i % 2 == 0 : NEW_LINE INDENT new . append ( a [ count ] ) else : NEW_LINE new . append ( a [ n - count - 1 ] ) NEW_LINE DEDENT count += 1 NEW_LINE print ( * new , end = \" ▁ \" ) NEW_LINE"],"bleu":0.002614419371850161,"rouge_l":0.051174496644295304}
{"id":544,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( 1 , n ) : if len ( a ) > 1 : print ( a [ i ] , end = ' ▁ ' ) else : print ( ) NEW_LINE"],"references":["n = int ( input ( ) ) i = 0 a = [ ] a = list ( map ( int , input ( ) . split ( ) ) ) a . sort ( ) while i < len ( a ) : print ( a [ i ] ) i = i + 1 NEW_LINE"],"bleu":0.5369091176175336,"rouge_l":0.6706981858163827}
{"id":545,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ' ▁ ' ) ) ) count1 , count2 = 0 , 0 for i in range ( n - 1 ) : if a [ i ] != a [ i + 1 ] : count1 = count1left = count1 + 1 rem = a [ i ] + 1 if ( l [ i % 2 ] == 1 ) : count1 = 0 else : count1 = 1 if ( l [ i ] == 1 ) : count2 = count1 + 1 print ( count1 ) NEW_LINE"],"references":["n = int ( input ( ) ) L = [ ] R = [ ]   for _ in range ( n ) : l , r = map ( int , input ( ) . split ( ) ) L . append ( l ) R . append ( r )   l0 = L . count ( 0 ) l1 = n - l0   r0 = R . count ( 0 ) r1 = n - r0   t = 0   if r0 > r1 : t += r1else : t += r0   if l0 > l1 : t += l1else : t += l0   print ( t ) NEW_LINE"],"bleu":0.2242276903946776,"rouge_l":0.3380702003694756}
{"id":546,"predictions":["n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE result = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if a [ i ] == 1 : NEW_LINE INDENT result += 1 NEW_LINE DEDENT else : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 1 , - 1 ) : NEW_LINE INDENT result = result + 1 NEW_LINE DEDENT print ( result ) NEW_LINE"],"references":["n = int ( input ( ) ) string = ' ' . join ( map ( str , input ( ) . split ( ) ) ) maxx = 0 for i in range ( n + 1 ) : maxx = max ( maxx , string [ : i ] . count ( '0' ) + string [ i : ] . count ( '1' ) ) print ( maxx ) NEW_LINE"],"bleu":0.2442974045404124,"rouge_l":0.48895618097613114}
{"id":547,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) )   ans = [ 0 ] * ( n + 1 ) for i in range ( n - 1 ) : ans [ i ] = max ( ans [ i ] - a [ i - 1 ] ) print ( ans ) NEW_LINE"],"references":["def search ( a , x ) : l , r = 0 , len ( a ) - 1 while l <= r : mid = ( l + r ) \/\/ 2 if a [ mid ] >= x and a [ mid - 1 ] < x : return mid elif a [ mid ] < x : l = mid + 1 else : r = mid - 1 return 0   n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( 1 , n ) : a [ i ] += a [ i - 1 ]   q = int ( input ( ) ) qu = list ( map ( int , input ( ) . split ( ) ) ) for x in qu : print ( search ( a , x ) + 1 ) NEW_LINE"],"bleu":0.15408190587612217,"rouge_l":0.37161373946856774}
{"id":548,"predictions":["n , k = list ( map ( int , input ( ) . split ( ) ) ) print ( n + 1 ) NEW_LINE"],"references":["n = input ( ) print ( n + n [ : : - 1 ] ) NEW_LINE"],"bleu":0.24669426816409512,"rouge_l":0.563944530046225}
{"id":549,"predictions":["t = int ( input ( ) ) ; s = input ( ) ; n = len ( s ) ; if ( n == 1 ) : print ( n - 1 ) else : if ( n - 1 ) % 2 == 0 ) : print ( n - 1 ) else : print ( n - 1 ) NEW_LINE"],"references":["for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) odd_str = 0 good_str = 0 bad_str = 0 for i in range ( n ) : s = input ( ) if len ( s ) % 2 != 0 : odd_str += 1 else : if s . count ( '0' ) % 2 == 0 and s . count ( '1' ) % 2 == 0 : good_str += 1 else : bad_str += 1 if bad_str % 2 != 0 and not odd_str : print ( n - 1 ) else : print ( n )       NEW_LINE"],"bleu":0.23063234443420821,"rouge_l":0.45696864111498264}
{"id":550,"predictions":["n = int ( input ( ) ) al = [ ] bl = [ ] for i in range ( n ) : a , b = [ int ( x ) for x in input ( ) . split ( ) ] al . append ( a ) bl . append ( b ) count = 1 for i , bot in enumerate ( al ) : if bot in bl [ : i + 1 ] + bl [ i + 1 : ] count += 1   print ( n - count ) NEW_LINE"],"references":["n , k = [ int ( x ) for x in input ( ) . split ( ) ] cards = input ( )   frequency = { } for card in cards : if card not in frequency : frequency [ card ] = 0 frequency [ card ] += 1   frequent = list ( sorted ( frequency . values ( ) , reverse = True ) )     amount = frequent [ 0 ] leftover = max ( k - amount , 0 ) coins = ( k - leftover ) * ( k - leftover ) i = 1 while leftover > 0 and i >= 0 : temp = min ( leftover , frequent [ i ] ) coins = coins + ( temp * temp ) leftover = leftover - temp i += 1   print ( coins ) NEW_LINE"],"bleu":0.17629269578503554,"rouge_l":0.32939058884031885}
{"id":551,"predictions":["n , t = map ( int , input ( ) . split ( \" ▁ \" ) ) aa = list ( map ( int , input ( ) . split ( \" ▁ \" ) ) )   res = [ ]   for i in range ( n ) : if a [ i ] != va [ i + 1 ] : res . append ( aa [ i ] + \" B \" ) else : res . append ( 0 )   print ( * res ) NEW_LINE"],"references":["from collections import defaultdictfrom bisect import bisect_leftp , n = defaultdict ( int ) , int ( input ( ) ) for i in range ( n ) : a , b = input ( ) . split ( ) p [ a ] = max ( p [ a ] , int ( b ) ) p , n = sorted ( ( b , a ) for a , b in p . items ( ) ) , len ( p ) t = [ 0 ] + [ bisect_left ( p , ( p [ n - 1 - n \/\/ k ] [ 0 ] , ' ' ) ) for k in [ 2 , 5 , 10 , 100 ] ] + [ n ] s = [ ' noob ' , ' random ' , ' average ' , ' hardcore ' , ' pro ' ] for i in range ( 1 , len ( t ) ) : d = s [ i - 1 ] for j in range ( t [ i - 1 ] , t [ i ] ) : p [ j ] = p [ j ] [ 1 ] + ' ▁ ' + dprint ( n ) print ( ' \\n ' . join ( p ) ) NEW_LINE"],"bleu":0.05946998605848993,"rouge_l":0.2966812893381651}
{"id":552,"predictions":["n = int ( input ( ) ) a = [ int ( x ) for x in input ( ) . split ( ) ] a . sort ( ) print ( n \/ 2 ) NEW_LINE"],"references":["n = int ( input ( ) ) x = [ ] for i in range ( n ) : a = list ( map ( int , input ( ) . split ( ) ) ) x . append ( a ) c = 1 x . sort ( key = lambda i : i [ 0 ] , reverse = True ) x . sort ( key = lambda i : i [ 1 ] , reverse = True ) p = 0 for i in x : c -= 1 c += i [ 1 ] p += i [ 0 ] if c == 0 : breakprint ( p ) NEW_LINE"],"bleu":0.061512459075358926,"rouge_l":0.32357563850687626}
{"id":553,"predictions":["def solve ( ) : NEW_LINE INDENT b [ 1 ] = 1 NEW_LINE cnt = 0 NEW_LINE for i in range ( 2 , 2000005 ) : NEW_LINE INDENT if b [ i ] == 0 : NEW_LINE INDENT a [ cnt ] = i NEW_LINE cnt += 1 NEW_LINE DEDENT for j in range ( cnt , 200000 , 1 ) : NEW_LINE INDENT if j * a [ j ] < 2000005 : NEW_LINE INDENT break NEW_LINE DEDENT b [ i * a [ j ] ] = 1 NEW_LINE if i * a [ j ] == 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT for i in range ( 200000 ) : NEW_LINE INDENT b [ i ] = 1 - b [ i ] NEW_LINE b [ i ] += b [ i - 1 ] NEW_LINE y = i NEW_LINE f = 0 NEW_LINE while y > 0 : NEW_LINE INDENT u [ f ] = 1 NEW_LINE b [ i ] += b [ i - 1 ] NEW_LINE f += 1 NEW_LINE DEDENT for j in range ( f + 1 ) : NEW_LINE INDENT if b [ j ] * q <= p [ i ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if j == f + 1 : NEW_LINE INDENT k [ i ] = k [ j ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT k [ i ] = k [ i - 1 ] NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , 200000 ) : NEW_LINE INDENT if b [ i ] * q <= p * k [ i ] : NEW_LINE INDENT ans = i - 1 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT"],"references":["def f ( s ) : for i in range ( len ( s ) \/\/ 2 + 1 ) : if s [ i ] != s [ - 1 - i ] : return False return Truez = 1200000 arr = [ 1 ] * zarr [ 0 ] , arr [ 1 ] = 0 , 0 for i in range ( 2 , 1096 ) : for j in range ( i * i , z , i ) : arr [ j ] = 0 cntpal = cntprm = 0 i = 1 p , q = map ( int , input ( ) . split ( ) ) k = p \/ qm = kwhile i < 1200000 : if f ( str ( i ) ) : cntpal += 1 if arr [ i ] : cntprm += 1 if cntprm \/ cntpal <= k : n = i i += 1 print ( n ) NEW_LINE"],"bleu":0.10882756954453761,"rouge_l":0.298331415420023}
{"id":554,"predictions":["def solve ( ) : n , m = [ int ( x ) for x in input ( ) . split ( ) ] m = max ( n - 2 , 0 ) if ( m + 1 ) >= n \/\/ 2 : m = max ( m + 1 , n ) print ( m + 1 ) NEW_LINE"],"references":["def calculate_sides ( n , m ) : if n == 1 : return m \/\/ 2 if m % 2 == 0 else m \/\/ 2 + 1 if m == 1 : return n \/\/ 2 if n % 2 == 0 else n \/\/ 2 + 1   left , right , top , bottom = 0 , 0 , 0 , 0 top = m \/\/ 2 if m % 2 == 0 else m \/\/ 2 + 1 bottom = top if n % 2 != 0 else m \/\/ 2 n -= 2 m -= 2 left = n \/\/ 2 if m > 0 : right = left if m % 2 != 0 else n \/\/ 2 if n % 2 == 0 else n \/\/ 2 + 1   return top + bottom + left + right     n , m = list ( map ( int , input ( ) . split ( ) ) ) x = int ( input ( ) ) dict = dict ( ) times = 1 while n > 0 and m > 0 : quantity = calculate_sides ( n , m ) dict [ times ] = quantity times += 1 n -= 2 m -= 2 print ( dict [ x ] if x in dict else 0 ) NEW_LINE"],"bleu":0.02025072134059374,"rouge_l":0.19879824829412363}
{"id":555,"predictions":["n = int ( input ( ) ) s = [ ] for i in range ( n ) : b = [ int ( x ) for x in input ( ) . split ( ) ] s = [ ] for i in range ( n ) : s . append ( b [ i ] )   ans = 0 for i in range ( n ) : for j in range ( b [ i ] ) : if ( j ^ i ) [ j ] == b [ i ] [ j ] : ans = i breakprint ( ans ) NEW_LINE"],"references":["for t in range ( int ( input ( ) ) ) : n = int ( input ( ) ) s = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) k = - 1 for i in range ( 1 , 1025 ) : temp = [ ] for j in s : temp . append ( j ^ i ) if sorted ( temp ) == s : k = i break print ( k ) NEW_LINE"],"bleu":0.3005701142814055,"rouge_l":0.4752710027100272}
{"id":556,"predictions":["n , m = map ( int , input ( ) . split ( ) ) print ( ( n , 2 ) [ n != m ] ) NEW_LINE"],"references":["if __name__ == ' _ _ main _ _ ' :   n = int ( input ( ) ) node = [ [ ] for _ in range ( n ) ] for i in range ( n - 1 ) : node [ int ( input ( ) ) - 1 ] . append ( i + 2 ) NEW_LINE"],"bleu":0.0578599123682112,"rouge_l":0.306841046277666}
{"id":557,"predictions":["n = int ( input ( ) ) NEW_LINE t = list ( map ( int , input ( ) . split ( ' ▁ ' ) ) ) NEW_LINE dist = list ( map ( int , input ( ) . split ( ' ▁ ' ) ) ) NEW_LINE c = n - min ( abs ( a [ 1 ] , a [ 0 ] ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT c = min ( abs ( a [ i ] - abs ( a [ i ] ) ) ) NEW_LINE DEDENT ans = 0 NEW_LINE for a in ans : NEW_LINE INDENT if a [ 0 ] < a [ 1 ] : NEW_LINE INDENT cost += abs ( a [ 1 ] - a [ 0 ] ) NEW_LINE ans += min ( cost , abs ( a [ 1 ] - a [ i ] ) ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT sum1 = 0 NEW_LINE n = int ( input ( ) ) NEW_LINE x = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE y = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE x1 , y1 = min ( x ) , min ( y ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT sum1 = sum1 + max ( x [ j ] - x1 , y [ j ] - y1 ) NEW_LINE DEDENT print ( sum1 ) NEW_LINE DEDENT"],"bleu":0.3267622793971543,"rouge_l":0.5300559457207477}
{"id":558,"predictions":["n , k = list ( map ( int , input ( ) . split ( ) ) ) ans = Noneif ( k > n ** 2 ) : print ( ' - 1 ▁ ' . join ( j for j in range ( n ) ) ) ) elif ( k == 1 ) : ans = [ [ 0 ] * n for arr in range ( n ) ] for i in range ( n ) : x = list ( map ( int , input ( ) . split ( ) ) ) in range ( n ) : ans = [ [ 0 ] * n for arr in range ( n ) ] for i in range ( n - 1 ) : for j in range ( n - 1 , - 1 , - 1 ) : ans [ i ] [ j ] = ans [ i ] [ j - 1 ] , ans [ i + 1 ] [ j - 2 ] = ans [ j + 1 ] [ j + 1 ] = ans [ x ] [ j - 1 ] = ans [ 0 ] [ j + 1 ] = 1 for i in range ( n ) : print ( ans [ i ] [ j ] ) NEW_LINE"],"references":["from math import gcddef getDays ( n ) : if n % 100 == 0 and n % 400 == 0 : return 366 if n % 100 != 0 and n % 4 == 0 : return 366 return 365 y = int ( input ( ) ) v = getDays ( y ) sd = getDays ( y ) while True : y += 1 if getDays ( y ) == v and sd % 7 == 0 : print ( y ) break sd += getDays ( y )           NEW_LINE"],"bleu":0.036197656764772934,"rouge_l":0.20123443652229436}
{"id":559,"predictions":["h1 , a1 , c2 , c2 = map ( int , input ( ) . split ( ) ) NEW_LINE"],"references":["h1 , a1 , c1 = map ( int , input ( ) . split ( ) ) h2 , a2 = map ( int , input ( ) . split ( ) ) i = 1 ans = 0 ans1 = [ ] while h2 > 0 : if i == 1 : if h1 - a2 > 0 : h2 -= a1 ans1 . append ( \" STRIKE \" ) ans += 1 elif h2 - a1 <= 0 : h2 -= a1 ans1 . append ( \" STRIKE \" ) ans += 1 else : h1 += c1 ans1 . append ( \" HEAL \" ) ans += 1 i = 0 elif i == 0 : h1 -= a2 i = 1 print ( ans ) for x in ans1 : print ( x ) NEW_LINE"],"bleu":0.0026126942683528855,"rouge_l":0.20826594788858943}
{"id":560,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["a , b , m = map ( int , input ( ) . split ( ) ) c = ( 10 ** 9 ) % mans = - 1 for x in range ( 1 , min ( a + 1 , m ) ) : z = ( x * c ) % m if z == 0 : continue if z + b < m : ans = x breakif ans == - 1 : print ( 2 ) else : s = str ( ans ) s = ( '0' * 9 + s ) [ - 9 : ] print ( 1 , s ) NEW_LINE"],"bleu":0.07403390681849334,"rouge_l":0.25952426996712435}
{"id":561,"predictions":["for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( s . index ( ' X ' ) ) NEW_LINE c = 0 NEW_LINE j = 0 NEW_LINE while i > j : if NEW_LINE j < n - a [ j ] : b += 1 NEW_LINE c += 1 NEW_LINE j += 1 NEW_LINE DEDENT print ( c ) NEW_LINE"],"references":["for i in range ( int ( input ( ) ) ) : n = int ( input ( ) ) l1 = list ( map ( int , input ( ) . split ( ) ) ) l2 = l1 . copy ( ) l2 = l2 [ : : - 1 ] c = 0 for i in range ( n ) : if ( l1 . count ( l1 [ i ] ) > 1 ) : index = n - l2 . index ( l1 [ i ] ) - 1 if ( index != i + 1 and index != i ) : c = 1 if ( c == 1 ) : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.304996132276799,"rouge_l":0.4821477241755247}
{"id":562,"predictions":["n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) )   for i in range ( n ) : a = list ( map ( int , input ( ) . split ( ) ) ) )     t = list ( map ( int , input ( ) . split ( ) ) )   suff = 0   for j in range ( 1 , n - 1 ) : if a [ j ] == 1 : prev = ( abs ( a [ j ] ) \/ 2 ) prev = ( ( a [ j ] - a [ j ] ) + 1 ) \/ 2 prev = 1   if prev == n - 1 : if prev == 1 : print ( 0 ) else : print ( 1 )   NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) s = [ list ( input ( ) ) for i in range ( n ) ] cnt = [ [ 0 ] * ( m + 1 ) for i in range ( n + 1 ) ] for i in range ( n ) : for j in range ( m ) : if s [ i ] [ j ] == \"1\" : cnt [ i + 1 ] [ j + 1 ] += 1 for i in range ( n ) : for j in range ( m + 1 ) : cnt [ i + 1 ] [ j ] += cnt [ i ] [ j ] for i in range ( n + 1 ) : for j in range ( m ) : cnt [ i ] [ j + 1 ] += cnt [ i ] [ j ] ans = 0 for l in range ( m + 1 ) : for r in range ( l + 1 , m + 1 ) : for u in range ( n + 1 ) : for d in range ( u + 1 , n + 1 ) : c = cnt [ d ] [ r ] - cnt [ d ] [ l ] - cnt [ u ] [ r ] + cnt [ u ] [ l ] if c == 0 : ans = max ( ans , ( r - l ) * 2 + ( d - u ) * 2 ) print ( ans ) NEW_LINE"],"bleu":0.12834870196531767,"rouge_l":0.3133561643835617}
{"id":563,"predictions":["for _ in range ( int ( input ( ) ) ) : n , k = map ( int , input ( ) . split ( ) ) NEW_LINE if ( n % 2 == 0 ) : print ( n \/\/ 2 ) else : NEW_LINE"],"references":["import matht = int ( input ( ) ) for _ in range ( t ) : n , k = map ( int , input ( ) . split ( ) ) num = - 1 for i in range ( 2 , math . ceil ( math . sqrt ( n ) ) + 1 ) : if ( n % i == 0 ) : num = i break k -= 1 if ( num == - 1 ) : num = n NEW_LINE"],"bleu":0.2948927726010687,"rouge_l":0.5069252077562327}
{"id":564,"predictions":["n , h = map ( int , input ( ) . split ( ) ) ans = [ ] for i in range ( 1 , n + 1 ) : for j in range ( 1 , i ** 0.5 ) : ans . append ( ( j ** ( i \/ n ) ) ) print ( len ( ans ) ) NEW_LINE"],"references":["import mathn , h = [ int ( x ) for x in input ( ) . split ( ' ▁ ' ) ] for i in range ( n - 1 ) : print ( math . sqrt ( ( i + 1 ) \/ ( n ) ) * h , end = \" ▁ \" ) print ( ) NEW_LINE"],"bleu":0.2812794267883298,"rouge_l":0.5449208779989791}
{"id":565,"predictions":["a , b = map ( int , input ( ) . split ( \" ▁ \" ) ) for i in range ( a , b + 1 ) : print ( \" # \" * ( i % 4 ) ) NEW_LINE"],"references":["a , b = map ( int , input ( ) . split ( ) ) s = ' # ' t = ' . ' flag = 0 for i in range ( a ) : if i % 2 == 0 : print ( s * b ) else : if flag == 0 : print ( t * ( b - 1 ) + s ) flag = 1 elif flag == 1 : print ( s + t * ( b - 1 ) ) flag = 0 NEW_LINE"],"bleu":0.1732351113687476,"rouge_l":0.45256294964028776}
{"id":566,"predictions":["import math     class CodeforcesTask1147BSolution : def __init__ ( self ) : self . result = ' ' self . n_m = [ ] self . points = [ ]   def read_input ( self ) : self . n_m = [ int ( x ) for x in input ( ) . split ( \" ▁ \" ) ] for i in range ( self . n_m [ 1 ] ] ) : self . points . append ( [ int ( y ) for y in input ( ) . split ( \" ▁ \" ) ] )   def process_task ( self ) : can = False segm = { } for point in self . points [ 0 ] : segm [ 0 ] = True for point in self . points : if point == 1 : self . n_m [ 0 ] = False k % 2 elif point == 0 : NEW_LINE"],"references":["a00 , a01 , a10 , a11 = list ( map ( int , input ( ) . split ( ) ) ) if sum ( [ a00 , a01 , a10 , a11 ] ) == 0 : print ( 0 ) exit ( 0 ) z , j = 0 , 0 if a01 != 0 or a10 != 0 : z = j = 1 while z * ( z - 1 ) \/\/ 2 < a00 : z += 1 while j * ( j - 1 ) \/\/ 2 < a11 : j += 1 if any ( [ z * ( z - 1 ) \/\/ 2 != a00 , j * ( j - 1 ) \/\/ 2 != a11 , z * j != a10 + a01 ] ) : print ( ' Impossible ' ) exit ( 0 ) n = z + jfor i in range ( n ) : if z > 0 and a01 >= j : print ( '0' , end = ' ' ) a01 -= j z -= 1 else : print ( '1' , end = ' ' ) j -= 1 NEW_LINE"],"bleu":0.07671917339034542,"rouge_l":0.19670369043353642}
{"id":567,"predictions":["import sysfrom math import gcd , sqrt , ceil , log2from collections import defaultdict , Counter , dequefrom bisect import bisect_left , bisect_rightimport mathsys . setrecursionlimit ( 2 * 10 ** 5 + 10 ) import heapqfrom itertools import permutations   NEW_LINE"],"references":["d = { ' polycarp ' : 1 } for _ in range ( int ( input ( ) ) ) : a , b , c = input ( ) . lower ( ) . split ( ) ; d [ a ] = d [ c ] + 1 print ( max ( d . values ( ) ) ) NEW_LINE"],"bleu":0.024291089655053062,"rouge_l":0.12869198312236285}
{"id":568,"predictions":["def solve ( ) : n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) if len ( a ) == 1 : print ( \" NO \" ) else : print ( \" NO \" ) NEW_LINE"],"references":["from collections import defaultdictfor _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) count = 0 l = [ ] for i in range ( n ) : l . append ( input ( ) . strip ( ) ) res = [ ] count = 0 for i in l : if i not in res : res . append ( i ) else : for j in range ( 10 ) : x = str ( j ) + i [ 1 : ] if x not in res and x not in l : count += 1 res . append ( x ) break print ( count ) for i in res : print ( i ) NEW_LINE"],"bleu":0.08337739530041416,"rouge_l":0.3412868191541879}
{"id":569,"predictions":["from math import ceiln , m = map ( int , input ( ) . split ( ) ) li = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] : li . append ( li [ i + 1 ] ) li . sort ( reverse = True ) s = 0 for i in range ( n ) : if li [ i ] > li [ i ] : s = True breakprint ( \" YES \" ) NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) cur_pos = 0 for i in range ( n ) : a , b = map ( int , input ( ) . split ( ) ) if ( a <= cur_pos ) : if ( b > cur_pos ) : cur_pos = bif ( cur_pos == m ) : print ( ' YES ' ) else : print ( ' NO ' ) NEW_LINE"],"bleu":0.39322800092703913,"rouge_l":0.4796854521625164}
{"id":570,"predictions":["n = int ( input ( ) ) ar = list ( map ( int , input ( ) . split ( ) ) ) ar = sorted ( ar ) if ( ar [ n + 1 ] ) == 1 ) : ar = [ 0 ] * ( n + 1 ) for i in range ( 1 , n + 1 ) : if ar [ i ] > ar [ n - 1 ] : ar [ i ] = ar [ i + 1 ] ar [ i ] = max ( ar ) print ( ar [ n - 1 ] ) NEW_LINE"],"references":["num = int ( input ( ) ) a = [ i for i in range ( 45 ) ] s = 1 idx = 1 while True : idx += 1 if ( s + idx > num ) : n = idx - 1 break   s += idx   left = num - s   a [ n ] += leftprint ( n ) for i in range ( 1 , n + 1 ) : print ( a [ i ] , end = \" ▁ \" ) print ( ) NEW_LINE"],"bleu":0.2513510358672965,"rouge_l":0.4226554946825653}
{"id":571,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) p = list ( map ( int , input ( ) . split ( ) ) ) res = 0 for i in range ( 1 , n - 1 ) : if p [ i ] == 1 : res += a [ i ] - 1 else : res += p [ i ] + 1 print ( res ) NEW_LINE"],"references":["a , b = map ( int , input ( ) . split ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) a = a % 2 ans = 0 i = 1 for n in arr : x = n * a ** ( b - i ) ans += x i += 1     if ans % 2 == 1 : print ( \" odd \" ) else : print ( \" even \" ) NEW_LINE"],"bleu":0.3749917020831328,"rouge_l":0.5191489361702127}
{"id":572,"predictions":["def STR ( ) : return list ( input ( ) ) def INT ( ) : return int ( input ( ) ) def MAP ( ) : return map ( int , input ( ) . split ( ) ) def MAP2 ( ) : return map ( float , input ( ) . split ( ) ) def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) def STRING ( ) : return input ( ) import stringimport sysfrom heapq import heappop , heappushfrom bisect import * from collections import deque , Counter , defaultdictfrom math import * from itertools import permutations , accumulatedx = [ - 1 , 1 , 0 , 0 ] dy = [ 0 , 0 , 1 , - 1 ] NEW_LINE"],"references":["lis = list ( map ( int , input ( ) . split ( ) ) ) sumall = 0 dic = { }   modulo = 1073741824 def number_of_divisors ( a ) : if a in dic : return dic [ a ] res , i , t = 1 , 2 , a while i * i <= a : r = 1 while a % i == 0 : a \/= i r += 1 res = ( res * r ) % modulo i += 1 if a > 1 : res = ( res * 2 ) % modulo dic [ t ] = res return res     for i in range ( 1 , lis [ 0 ] + 1 ) : for j in range ( 1 , lis [ 1 ] + 1 ) : for k in range ( 1 , lis [ 2 ] + 1 ) : s = ( i , j , k ) sumall += number_of_divisors ( i * j * k ) print ( sumall % modulo ) NEW_LINE"],"bleu":0.12700156008201574,"rouge_l":0.23898139079333983}
{"id":573,"predictions":["n , m , k = map ( int , input ( ) . split ( ) ) cells = 0 for i in range ( 0 , k ) : cells += 2 * ( m + n - 2 - i * ( 8 ) ) print ( cells ) NEW_LINE"],"references":["import sysinput = sys . stdin . readlinefrom collections import defaultdict as dcfrom collections import Counterfrom bisect import bisect_right , bisect_leftimport mathfrom operator import itemgetterfrom heapq import heapify , heappop , heappushfrom queue import PriorityQueue as pqn = int ( input ( ) ) s = input ( ) [ : - 1 ] if int ( s , 2 ) == 0 : print ( s ) else : c = 0 for i in s : if i == '0' : c += 1 l = [ '1' ] + [ '0' ] * c print ( ' ' . join ( l ) ) NEW_LINE"],"bleu":0.06424148873326244,"rouge_l":0.2691348551697679}
{"id":574,"predictions":["n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) p = list ( map ( int , input ( ) . split ( ) ) ) ans = 0 for i in range ( n - 1 ) : if p [ a [ i ] ] == 1 : ans += p [ a [ i ] - 1 ]   print ( ans ) NEW_LINE"],"references":["n , k = map ( int , input ( ) . split ( ) )     def printDivisors ( n ) : l = [ ] i = 1 while ( i * i < n ) : if ( n % i == 0 ) : l . append ( i ) if ( len ( l ) >= k ) : break i += 1   for i in range ( int ( n ** 0.5 ) , 0 , - 1 ) : if ( n % i == 0 ) : l . append ( n \/\/ i ) if ( len ( l ) >= k ) : break return l     res = printDivisors ( n ) if len ( res ) >= k : print ( res [ k - 1 ] ) else : print ( - 1 ) NEW_LINE"],"bleu":0.18046773184939358,"rouge_l":0.38762806380495396}
{"id":575,"predictions":["n = int ( input ( ) ) NEW_LINE if n % 2 == 0 : NEW_LINE INDENT print ( \" NO \" ) else : NEW_LINE print ( \" YES \" ) NEW_LINE DEDENT"],"references":["a = input ( ) b = input ( )   f = True   for i , j in zip ( a , b ) : if j > i : f = False break   if f : print ( b )   else : print ( - 1 ) NEW_LINE"],"bleu":0.0886262336405655,"rouge_l":0.3726194753862737}
{"id":576,"predictions":["from sys import stdin , stdoutfrom os import pathrd = lambda : stdin . readline ( ) . strip ( ) wr = stdout . writeif ( path . exists ( ' input . txt ' ) ) : stdin = open ( \" input . txt \" , \" r \" ) import time , math NEW_LINE"],"references":["def xuli ( ) : n = int ( input ( ) ) s = input ( ) dem1 = 0 dem2 = 0 for i in s : if i != '0' : break dem1 += 1 for i in reversed ( s ) : if i != '1' : break dem2 += 1 for i in range ( dem1 + ( dem1 + dem2 < n ) ) : print ( 0 , end = ' ' ) for i in range ( dem2 ) : print ( 1 , end = ' ' ) print ( ' ' )       t = int ( input ( ) ) while ( t > 0 ) : xuli ( ) t -= 1 NEW_LINE"],"bleu":0.023614626278625223,"rouge_l":0.1823314513450681}
{"id":577,"predictions":["m , n = map ( int , input ( ) . split ( ) ) a = [ list ( map ( int , input ( ) . split ( ) ) ) ) for i in range ( 0 , 5 ) ]   sum = 0 NEW_LINE"],"references":["r = lambda : list ( map ( int , input ( ) . split ( ) ) ) arr = r ( ) w = r ( ) hacks = r ( )   score = 0 for i in range ( 5 ) : tot = ( 500 * ( i + 1 ) ) score += max ( 0.3 * tot , tot * ( 1 - arr [ i ] \/ 250 ) - 50 * w [ i ] )     score += 100 * hacks [ 0 ] score -= 50 * hacks [ 1 ]     print ( int ( score ) )   NEW_LINE"],"bleu":0.1403915846792487,"rouge_l":0.34180052297347774}
{"id":578,"predictions":["n , k = map ( int , input ( ) . strip ( ) . split ( ' ▁ ' ) ) NEW_LINE"],"references":["n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) flag = 0 for i in range ( n ) : for j in range ( n ) : if ( i == j ) : continue for k in range ( n ) : if ( i == k or j == k ) : continue if ( arr [ i ] == arr [ j ] + arr [ k ] ) : flag = 1 print ( i + 1 , j + 1 , k + 1 ) break if ( flag ) : break if ( flag ) : breakif ( flag == 0 ) : print ( - 1 ) NEW_LINE"],"bleu":0.005639258743429601,"rouge_l":0.18236173393124067}
{"id":579,"predictions":["import sys NEW_LINE fin = sys . stdin . readline NEW_LINE N , K = map ( int , input ( ) . split ( ) ) NEW_LINE a = sorted ( map ( int , input ( ) . split ( ) ) ) NEW_LINE dist = [ 0 ] * K NEW_LINE for i in range ( K ) : NEW_LINE INDENT for j in range ( left + 1 ) : NEW_LINE INDENT if a [ i ] [ j ] >= x : NEW_LINE INDENT dist += ( abs ( x - i ) + abs ( y - i ) ) * abs ( a - i ) NEW_LINE DEDENT DEDENT return dist NEW_LINE DEDENT print ( solve ( ) ) NEW_LINE"],"references":["n , k = map ( int , input ( ) . split ( ) ) group = list ( map ( int , input ( ) . split ( ) ) ) available = [ [ k , 1 ] for i in range ( k + 1 ) ] center = ( k + 1 ) \/\/ 2 def calc ( center , row , col , num ) : end_col = col + num - 1 distance = abs ( center - row ) * num if col >= center : distance += ( col - center ) * num + ( num - 1 ) * num \/\/ 2 elif end_col <= center : distance += ( center - end_col ) * num + ( num - 1 ) * num \/\/ 2 else : distance += ( center - col ) * ( center - col + 1 ) \/\/ 2 + ( end_col - center ) * ( end_col - center + 1 ) \/\/ 2 return distancefor m in group : close , best_row , best_col = 10 ** 9 , - 1 , - 1 for row in range ( 1 , k + 1 ) : col = 0 if available [ row ] [ 0 ] < m and k - available [ row ] [ 1 ] + 1 < m : continue if available [ row ] [ 0 ] == k : col = center - m \/\/ 2 elif center - available [ row ] [ 0 ] <= available [ row ] [ 1 ] - center : col = available [ row ] [ 0 ] - m + 1 else : col = available [ row ] [ 1 ] distance = calc ( center , row , col , m ) if distance < close : close = distance best_row = row best_col = col if close == 10 ** 9 : print ( - 1 ) else : print ( best_row , best_col , best_col + m - 1 ) available [ best_row ] [ 0 ] = min ( available [ best_row ] [ 0 ] , best_col - 1 ) available [ best_row ] [ 1 ] = max ( available [ best_row ] [ 1 ] , best_col + m ) NEW_LINE"],"bleu":0.03947145940553621,"rouge_l":0.23543982948326517}
{"id":580,"predictions":["n = int ( input ( ) ) print ( * ( n - 1 ) \/\/ 2 ) NEW_LINE"],"references":["def main ( ) : n = int ( input ( ) ) count = 0 for i in range ( 1 , n \/\/ 2 + 1 ) : if n % i == 0 : count += 1 print ( count )     if __name__ == ' _ _ main _ _ ' : main ( ) NEW_LINE"],"bleu":0.07229411498640151,"rouge_l":0.31676557863501487}
{"id":581,"predictions":["for s in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE x = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE y = sorted ( a ) NEW_LINE print ( ( x [ n % 2 ] - x [ n \/\/ 2 ] + 1 ) * ( y [ n % 2 ] ) ) NEW_LINE"],"references":["I = input NEW_LINE exec ( int ( I ( ) ) * ' n = int ( I ( ) ) ; k , m = ( 1 + x [ n > > 1 ] - x [ n - 1 > > 1 ] for ▁ x ▁ in ▁ map ( sorted , zip ( * ( map ( int , I ( ) . split ( ) ) for ▁ _ ▁ in [ 0 ] * n ) ) ) ) ; print ( k * m ) ; ' ) NEW_LINE"],"bleu":0.26232905382762695,"rouge_l":0.4030154158902253}
{"id":582,"predictions":["n = int ( input ( ) ) st = input ( ) ans = 0 for i in range ( n ) : if st [ i ] == ' C ' : ans += 1 elif st [ i ] == ' C ' : ans += 1 print ( ans ) NEW_LINE"],"references":["def fact ( n ) : if n <= 1 : return 1 else : return n * fact ( n - 1 )   def c ( n , r ) : return fact ( n ) \/\/ ( fact ( r ) * fact ( n - r ) )   n = int ( input ( ) ) arr = [ ] h = 0 for _ in range ( n ) : arr . append ( list ( input ( ) ) ) for i in arr : if i . count ( \" C \" ) >= 2 : h += c ( i . count ( \" C \" ) , 2 ) arr = list ( map ( list , zip ( * arr ) ) )   for i in arr : if i . count ( \" C \" ) >= 2 : h += c ( i . count ( \" C \" ) , 2 ) print ( h ) NEW_LINE"],"bleu":0.04402145363164854,"rouge_l":0.2499008854235496}
{"id":583,"predictions":["n , x , y = map ( int , input ( ) . strip ( ) . split ( ' ▁ ' ) ) s = list ( map ( int , input ( ) . split ( ' ▁ ' ) ) )   if x == - 1 : print ( 0 ) exit ( )   ans = 0 for i in range ( len ( s ) ) : if x >= len ( s ) and ( s [ i ] ) >= x : ans += add else : s [ i ] = x ans   print ( ans ) NEW_LINE"],"references":["from collections import defaultdict   n = int ( input ( ) ) p = list ( map ( int , input ( ) . split ( ) ) ) s = list ( map ( int , input ( ) . split ( ) ) )   clds , pars = defaultdict ( list ) , [ 0 ] * ( n + 1 ) for i in range ( n - 1 ) : cur , par = i + 2 , p [ i ] clds [ p [ i ] ] . append ( cur ) pars [ cur ] = par   ans , ok = s [ 0 ] , Truei , q = 0 , [ 1 ] while i < len ( q ) : cur = q [ i ] i += 1 par_v = s [ pars [ cur ] - 1 ] if cur in clds : mmin , summ , k = float ( ' inf ' ) , 0 , 0 for item in clds [ cur ] : mmin = min ( mmin , s [ item - 1 ] ) summ += s [ item - 1 ] k += 1 q . append ( item ) if s [ cur - 1 ] != - 1 : continue if mmin < par_v : ok = False break ans -= par_v ans += ( summ - ( k - 1 ) * mmin ) if ok : print ( ans ) else : print ( - 1 ) NEW_LINE"],"bleu":0.0991883070569544,"rouge_l":0.32422929102952}
{"id":584,"predictions":["for _ in range ( int ( input ( ) ) ) : a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) )   res = 0 for i in range ( len ( a ) ) : if b [ i ] == b [ i ] : res += 1 else : print ( \" NO \" ) break NEW_LINE"],"references":["for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) ans = \" YES \" s = set ( ) for i in range ( n ) : if ( b [ i ] > a [ i ] and ( 1 not in s ) or b [ i ] < a [ i ] and ( - 1 not in s ) ) : ans = \" NO \" break s . add ( a [ i ] ) print ( ans ) NEW_LINE"],"bleu":0.4071908797771335,"rouge_l":0.6307893970288377}
{"id":585,"predictions":["import sysfrom os import pathif ( path . exists ( ' input . txt ' ) ) : sys . stdin = open ( ' input . txt ' , ' r ' ) sys . stdout = open ( ' output . txt ' , ' r ' ) or sys . stdout . write ( str ( input ( ) ) ) NEW_LINE"],"references":["def check ( txt : str ) -> bool : ln = len ( txt ) if ln == 0 or ln > 16 : return False for item in txt : if not ( ' a ' <= item <= ' z ' or ' A ' <= item <= ' Z ' or '0' <= item <= '9' or item == ' _ ' ) : return False return True     def checkHost ( hostName : str ) -> bool : hostLen = len ( hostName ) if hostLen == 0 or hostLen > 32 : return False for token in hostName . split ( ' . ' ) : if not check ( token ) : return False return True     mail = input ( ) isUser , isHost , isRes = False , False , Falseif ' @ ' in mail : atIndex = mail . index ( ' @ ' ) slashInd = mail . index ( ' \/ ' ) if ' \/ ' in mail else - 1 userName = mail [ : atIndex ] isUser = check ( userName ) hostName = mail [ atIndex + 1 : slashInd ] if slashInd != - 1 else mail [ atIndex + 1 : ] isHost = checkHost ( hostName ) if slashInd == - 1 : isRes = True else : resource = mail [ slashInd + 1 : ] isRes = check ( resource ) ''' if ▁ isUser ▁ and ▁ isHost ▁ and ▁ isRes : ▁ ▁ ▁ ▁ print ( ' YES ' ) else : ▁ ▁ ▁ ▁ print ( ' NO ' ) ''' print ( ' YES ' if isUser and isHost and isRes else ' NO ' ) NEW_LINE"],"bleu":0.002507577206232434,"rouge_l":0.14814215170403952}
{"id":586,"predictions":["for _ in range ( int ( input ( ) ) ) : x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) ) abs ( x2 - x1 ) y1 = abs ( y2 - y1 ) + 2 * ( y2 ) print ( int ( input ( ) ) NEW_LINE"],"references":["for _ in range ( int ( input ( ) ) ) : x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) )   if x1 == x2 : print ( abs ( y2 - y1 ) )   elif y1 == y2 : print ( abs ( x2 - x1 ) )   else : print ( abs ( x2 - x1 ) + 2 + abs ( y2 - y1 ) ) NEW_LINE"],"bleu":0.5499900775782124,"rouge_l":0.6711974110032363}
{"id":587,"predictions":["for _ in range ( int ( input ( ) ) ) : a , b , c , d = map ( int , input ( ) . split ( ) )   if b == 0 and c > 0 : print ( \" Bob \" ) elif c == a : print ( \" John \" ) else : print ( \" won \" ) NEW_LINE"],"references":["oro_infinito = False   datos = input ( ) . split ( ) NEW_LINE a = int ( datos [ 0 ] ) NEW_LINE b = int ( datos [ 1 ] ) NEW_LINE c = int ( datos [ 2 ] ) NEW_LINE d = int ( datos [ 3 ] ) NEW_LINE e = int ( datos [ 4 ] ) NEW_LINE f = int ( datos [ 5 ] )   if a != 0 and b != 0 and c != 0 and d != 0 and e != 0 and f != 0 : if NEW_LINE ( b \/ a ) * ( d \/ c ) * ( f \/ e ) > 1 : oro_infinito = Trueelse : if c == 0 and d > 0 : NEW_LINE INDENT oro_infinito = True elif a == 0 and b > 0 and c > 0 and d > 0 : NEW_LINE oro_infinito = True elif e == 0 and f > 0 and a > 0 and b > 0 and c > 0 and d > 0 : NEW_LINE oro_infinito = True   if oro_infinito : NEW_LINE print ( ' Ron ' ) else : NEW_LINE print ( ' Hermione ' ) NEW_LINE DEDENT"],"bleu":0.03279779358412407,"rouge_l":0.25523012552301255}
{"id":588,"predictions":["n = int ( input ( ) ) if ( n == 1 ) : print ( - 1 ) else : l = n \/\/ 4 + 1 if ( n % 4 == 0 ) : print ( - 1 ) else : ans = n * ( n \/\/ 2 + 1 ) \/\/ 2 print ( ans ) NEW_LINE"],"references":["n = int ( input ( ) ) if n % 2 == 0 : print ( n \/\/ 2 ) else : print ( ( n \/\/ 2 + 1 ) * ( - 1 ) )   NEW_LINE"],"bleu":0.3617508006632034,"rouge_l":0.6069651741293532}
{"id":589,"predictions":["from sys import stdinimport stdoutfrom os import pathrd = lambda : stdin . readline ( ) . strip ( ) wr = stdout . writeif ( path . exists ( ' input . txt ' ) ) : stdin = open ( \" input . txt \" , \" r \" ) import time , math NEW_LINE"],"references":["m = input ( ) l = list ( m ) s = list ( set ( l ) ) z = 0   if ( m [ 0 ] == '4' ) : z = 1 elif ( '444' in m ) : z = 1 for i in s : if ( i == '4' or i == '1' ) : pass else : z = 1 break   if ( z == 1 ) : print ( \" NO \" ) else : print ( \" YES \" ) NEW_LINE"],"bleu":0.03304663491039138,"rouge_l":0.2428242195684056}
{"id":590,"predictions":["n , h = map ( int , input ( ) . split ( ) ) h1 = list ( map ( int , input ( ) . split ( ) ) ) h2 = [ ] for i in range ( n ) : if h1 [ i ] != 1 : h2 . append ( h [ i ] , len ( h ) ) if len ( h1 ) > 2 : print ( \" NO \" ) else : print ( \" YES \" ) NEW_LINE"],"references":["a = [ i for i in input ( ) ] b = [ i for i in input ( ) ]   ab = [ i for i in input ( ) ]   c = a + b   ab . sort ( ) c . sort ( )   if ab == c : print ( ' YES ' ) else : print ( ' NO ' ) NEW_LINE"],"bleu":0.13314764419844413,"rouge_l":0.39054109871953735}
{"id":591,"predictions":["if __name__ == ' _ _ main _ _ ' : for _ in range ( 1 ) : n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) a . sort ( ) ans = 0 for i in range ( n ) [ : n - 1 ] : ans += ( i + 2 ) * a [ n - 1 ] ans += n * a [ n - 1 ] print ( ans ) NEW_LINE"],"references":["def equal ( a , b ) : for i in range ( len ( a ) ) : if a [ i ] != b [ i ] and a [ i ] != \" * \" and b [ i ] != \" * \" : return False return True   string , k , best = input ( ) . strip ( ) , int ( input ( ) ) , 0 string += \" * \" * kfor i in range ( len ( string ) + 1 ) : for j in range ( i + 1 , len ( string ) + 1 ) : if not ( j - i ) % 2 : if equal ( string [ i : ( i + j ) \/\/ 2 ] , string [ ( i + j ) \/\/ 2 : j ] ) : best = max ( best , j - i ) print ( best ) NEW_LINE"],"bleu":0.10068894686963978,"rouge_l":0.28487606274697636}
{"id":592,"predictions":["def main ( ) : n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) if a [ n - 1 ] != a [ n - 1 ] : print ( a [ n - 1 ] ) elif a [ n - 1 ] == a [ n - 1 ] : print ( a [ n - 1 ] ) else : print ( a [ n - 1 ] - 1 ) NEW_LINE"],"references":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) res = 0 for j in range ( n - 2 , - 1 , - 1 ) : if a [ j ] >= a [ j + 1 ] : a [ j ] = max ( 0 , a [ j + 1 ] - 1 ) print ( sum ( a ) ) NEW_LINE"],"bleu":0.4075312048703755,"rouge_l":0.5998487140695916}
{"id":593,"predictions":["n , k = [ int ( x ) for x in input ( ) . split ( ) ]   a = [ ]   for i in range ( 4 ) : for j in range ( 1 , n \/\/ 2 ) : if a [ i ] [ j ] == ' # ' : continue   if a [ i ] [ j - 1 ] == ' # ' or a [ i - 1 ] [ j ] == ' # ' : continue   if a [ i ] [ j - 1 ] == ' # ' or a [ i - 1 ] [ j - 2 ] == ' # ' : continue   y = [ input ( ) for i in range ( 1 , n \/\/ 2 ) ] for j in range ( 1 , 4 ) : if a [ i ] [ j ] == ' # ' : x -= 1 continue   y [ x - 1 ] = ' # ' for i in y : print ( \" NO \" ) exit ( )   print ( \" YES \" )   for x in y : print ( \" NO \" ) NEW_LINE"],"references":["n , k = map ( int , input ( ) . split ( ) ) if ( k % 2 == 0 ) : print ( \" YES \" ) print ( ' . ' * n ) print ( ' . ' + ' # ' * ( k \/\/ 2 ) + ' . ' * ( n - 1 - k \/\/ 2 ) ) print ( ' . ' + ' # ' * ( k \/\/ 2 ) + ' . ' * ( n - 1 - k \/\/ 2 ) ) print ( ' . ' * n ) else : print ( \" YES \" ) print ( ' . ' * n ) if ( k <= n - 2 ) : print ( ' . ' * ( ( n - k ) \/\/ 2 ) + ' # ' * k + ' . ' * ( ( n - k ) \/\/ 2 ) ) print ( ' . ' * n ) else : print ( ' . ' + ' # ' * ( n - 2 ) + ' . ' ) print ( ' . ' + ' # ' * ( ( k - n + 2 ) \/\/ 2 ) + ' . ' * ( n - 2 - k + n - 2 ) + ' # ' * ( ( k - n + 2 ) \/\/ 2 ) + ' . ' ) print ( ' . ' * n ) NEW_LINE"],"bleu":0.11653355812040796,"rouge_l":0.2740194435132417}
{"id":594,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["sections , a , divisors , cap = map ( int , input ( ) . split ( ) )   NEW_LINE"],"bleu":0.1981553324621049,"rouge_l":0.4341637010676156}
{"id":595,"predictions":["r , g , b = map ( int , input ( ) . split ( ) ) NEW_LINE if b > 10 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( b + 1 , 10 ** i ) : NEW_LINE INDENT y = ( i % 10 ) * ( i % 10 ) ) NEW_LINE DEDENT DEDENT print ( 1 ) NEW_LINE"],"references":["a , b = [ int ( x ) for x in input ( ) . split ( ) ]   x = b % 10 mul = 1 for i in range ( b , a , - 1 ) : mul *= x x -= 1 if x < 0 and i > a : print ( \"0\" ) mul = - 1 breakif mul != - 1 : mul = mul % 10 print ( mul ) NEW_LINE"],"bleu":0.21307302379382181,"rouge_l":0.3839697859840537}
{"id":596,"predictions":["def fact ( x ) : if ( x == 1 ) : return ( 1 ) else : return ( fact ( x - 1 ) * x ) a , b = [ int ( x ) for x in input ( ) . split ( ' ▁ ' ) ] print ( fact ( min ( a , b ) ) ) NEW_LINE"],"references":["n = int ( input ( ) ) a = pow ( 1 , n , 5 ) b = pow ( 2 , n , 5 ) c = pow ( 3 , n , 5 ) d = pow ( 4 , n , 5 ) print ( ( a + b + c + d ) % 5 )   NEW_LINE"],"bleu":0.07674094669590742,"rouge_l":0.3548305513404148}
{"id":597,"predictions":["for _ in range ( int ( input ( ) ) ) : a , b , c = map ( int , input ( ) . split ( ) ) if a == b : if a >= b : c = b - a   if c >= a : min ( a , b , c ) : min ( a , b , c ) print ( c ) NEW_LINE"],"references":["cases = int ( input ( ) ) while cases : cases -= 1 a , b , c , r = map ( int , input ( ) . split ( ) )   if a > b : a , b = b , a   pot = b - a   cl = c - r cr = c + r   if a <= cl <= cr <= b : ans = b - a - ( cr - cl ) elif cl <= a <= cr <= b : ans = b - cr elif a <= cl <= b <= cr : ans = cl - a elif cl <= a <= b <= cr : ans = 0 else : ans = b - a   print ( ans ) NEW_LINE"],"bleu":0.1921429295967167,"rouge_l":0.4383983572895277}
{"id":598,"predictions":["from sys import stdin , stdoutfrom os import pathrd = lambda : stdin . readline ( ) . strip ( ) wr = stdout . writeif ( path . exists ( ' input . txt ' ) ) : stdin = open ( \" input . txt \" , \" r \" ) import time , math NEW_LINE"],"references":["import mathimport collections def solve ( n , l ) : return max ( l ) - ( sum ( l ) - max ( l ) ) + 1   n = int ( input ( ) ) l = [ int ( s ) for s in input ( ) . split ( ) ] result = solve ( n , l ) print ( result ) NEW_LINE"],"bleu":0.05800281414434512,"rouge_l":0.2919395465994962}
{"id":599,"predictions":["import sysfrom math import gcd , sqrt , ceil , log2from collections import defaultdict , Counter , dequefrom bisect import bisect_left , bisect_rightimport mathsys . setrecursionlimit ( 2 * 10 ** 5 + 10 ) import heapqfrom itertools import permutations   NEW_LINE"],"references":["def main_funtion ( ) : n = int ( input ( ) ) s = [ int ( i ) for i in input ( ) . split ( \" ▁ \" ) ] minimum = min ( s ) the_val = 10000000000000 for i in s : if i > minimum and i < the_val : the_val = i if the_val == 10000000000000 : return \" NO \" return the_val     print ( main_funtion ( ) ) NEW_LINE"],"bleu":0.014980585104813416,"rouge_l":0.07760814249363868}
{"id":600,"predictions":["n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) arr = sorted ( arr ) if ( arr ) >= arr ) : print ( len ( arr ) - arr ) else : print ( 1 ) NEW_LINE"],"references":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) a . sort ( ) cur = 1 for i in range ( n ) : if a [ i ] >= cur : cur += 1 print ( cur - 1 ) NEW_LINE"],"bleu":0.4423437237461659,"rouge_l":0.6276078879679909}
{"id":601,"predictions":["n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( 0 , n + 1 ) : if ( a [ i ] != 1 ) : a [ i ] = 1 else : a [ i ] = 1 ans = 0 for i in range ( 1 , n + 1 ) : if ( a [ i ] != k ) : ans += 1 print ( ans ) NEW_LINE"],"references":["entrada1 = input ( ) . split ( ) NEW_LINE n , k = int ( entrada1 [ 0 ] ) , int ( entrada1 [ 1 ] )   entrada2 = input ( ) . split ( ) NEW_LINE c = int ( entrada2 [ 0 ] ) NEW_LINE festivos = [ ] NEW_LINE for i in range ( c ) : festivos . append ( int ( entrada2 [ i + 1 ] ) )   regalos = 0 NEW_LINE k_esimo = 0 NEW_LINE f = 0   i = 1 NEW_LINE while i <= n : if NEW_LINE f < c and i == festivos [ f ] : regalos = regalos + 1 NEW_LINE f = f + 1 NEW_LINE k_esimo = 0 else : k_esimo = k_esimo + 1 NEW_LINE if k_esimo == k : regalos = regalos + 1 NEW_LINE k_esimo = 0 NEW_LINE i = i + 1 NEW_LINE print ( regalos ) NEW_LINE"],"bleu":0.1506639744678911,"rouge_l":0.37275341480948954}
{"id":602,"predictions":["n , k = map ( int , input ( ) . split ( ) ) for i in range ( n - k ) : if ( n == k ) : print ( 1\" * n ) else : print ( \"1\" * ( n - k ) ) NEW_LINE"],"references":["n , k = map ( int , input ( ) . split ( ) ) e = ( n - k ) \/\/ 2 c = \"0\" * e + \"1\" while ( len ( c ) <= n ) : c = c + cprint ( c [ : n ] ) NEW_LINE"],"bleu":0.4022877357299756,"rouge_l":0.5579268292682926}
{"id":603,"predictions":["t = int ( input ( ) ) for i in range ( t ) : n , k = map ( int , input ( ) . split ( ) ) ) s = [ ] for i in range ( k ) : if ( s [ i ] == ' ? ' ) or ( ' ? ' ) == ' ? ' ) : print ( \" YES \" ) exit ( ) print ( \" NO \" ) NEW_LINE"],"references":["for _ in range ( int ( input ( ) ) ) : n , k = map ( int , input ( ) . split ( ) ) ; s = input ( ) ; l = [ 0 ] * k ; f = k NEW_LINE for i in range ( k ) : v = [ ] ; c = 0 NEW_LINE for j in s [ i : : k ] : if NEW_LINE j != ' ? ' : NEW_LINE if j not in v : v += [ j ] ; c += 1 NEW_LINE if c > 1 : NEW_LINE INDENT break else : NEW_LINE if NEW_LINE DEDENT v : l [ i ] = ( - 1 ) ** int ( v [ 0 ] ) ; NEW_LINE f -= 1 NEW_LINE continue NEW_LINE break else : print ( [ \" NO \" , \" YES \" ] [ abs ( sum ( l ) ) <= f ] ) ; NEW_LINE continue NEW_LINE print ( \" NO \" ) NEW_LINE"],"bleu":0.17790996009206636,"rouge_l":0.43551029962546817}
{"id":604,"predictions":["p = lambda : list ( map ( int , input ( ) . split ( ) ) ) t = int ( input ( ) ) for _ in range ( t ) : n , k = in enumerate ( p ) ans = [ ] for i in range ( n ) : if ( p % k == 0 ) : ans . append ( p % k ) ans . append ( p \/\/ k ) print ( len ( ans ) for i in range ( n ) ) : print ( * ans [ i ] ) NEW_LINE"],"references":["p , k = input ( ) . split ( ) p , k = int ( p ) , int ( k ) s = k - 1 ls = [ 0 ] while s < p : ls . append ( 0 ) ls . append ( 0 ) s = s * k * k + k - 1 n = len ( ls ) for i in range ( n ) : if ( i & 1 ) == 0 : ls [ i ] = k - 1 res = s - pfor i in range ( n ) : t = res % k if i & 1 : ls [ i ] += t else : ls [ i ] -= t res \/\/= kprint ( n ) print ( \" ▁ \" . join ( str ( x ) for x in ls ) )   NEW_LINE"],"bleu":0.2148351939909449,"rouge_l":0.35685557586837297}
{"id":605,"predictions":["n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) ) c = 0 for i in range ( len ( a ) ) : if ( a [ i ] == b [ i ] ) : c += 1 if c >= k : print ( c ) else : print ( c ) NEW_LINE"],"references":["def insertion_sort ( l ) : for i in range ( len ( l ) ) : for j in ( range ( i ) ) : k = i - j if l [ k ] >= l [ k - 1 ] : l [ k - 1 ] , l [ k ] = l [ k ] , l [ k - 1 ] else : break return l       def selection_sort ( l ) : for i in range ( len ( l ) ) : min_ind = i min_val = l [ i ] for j in range ( i , len ( l ) ) : if min_val > l [ j ] : min_val = l [ j ] min_ind = j l [ i ] , l [ min_ind ] = l [ min_ind ] , l [ i ] return l     def bubble_sort ( l ) : for i in range ( len ( l ) - 1 ) : for j in range ( len ( l ) - 1 - i ) : if l [ j ] > l [ j + 1 ] : l [ j ] , l [ j + 1 ] = l [ j + 1 ] , l [ j ] return l     NEW_LINE"],"bleu":0.0466938809397278,"rouge_l":0.23362914525922468}
{"id":606,"predictions":["import sysfrom functools import lru_cache , cmp_to_keyfrom heapq import merge , heapqimport mathfrom NEW_LINE"],"references":["import sysinput = sys . stdin . readlinedef inp ( ) : return ( int ( input ( ) ) ) def inlt ( ) : return ( list ( map ( int , input ( ) . split ( ) ) ) ) def insr ( ) : s = input ( ) return ( list ( s [ : len ( s ) - 1 ] ) ) def invr ( ) : return ( map ( int , input ( ) . split ( ) ) )   inp = invr ( ) inp = [ x for x in inp ] req = inlt ( ) prepared = inlt ( )     j = 0 i = 0 while i < inp [ 0 ] and j < inp [ 1 ] : if req [ i ] <= prepared [ j ] : i += 1 j += 1 print ( inp [ 0 ] - i )     NEW_LINE"],"bleu":0.000002849662539715386,"rouge_l":0.038352719270669605}
{"id":607,"predictions":["n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE if ( x <= y ) : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT DEDENT"],"references":["in_tests = int ( input ( ) )   for i in range ( in_tests ) : [ x , y ] = input ( ) . split ( ) if int ( x ) - int ( y ) == 1 : print ( ' NO ' ) else : print ( ' YES ' )   NEW_LINE"],"bleu":0.44699755727348084,"rouge_l":0.7435082140964495}
{"id":608,"predictions":["from collections import defaultdict , deque , Counterfrom sys import stdin , stdoutfrom heapq import heappush , heappopimport mathimport ioimport osimport mathimport bisect   NEW_LINE"],"references":["n , m , s , f = map ( int , input ( ) . split ( ) ) l = [ ] for i in range ( m ) : t , c , r = map ( int , input ( ) . split ( ) ) l . append ( [ t , c , r ] ) if s > f : st = \" \" t = 1 i = 0 while ( i < m ) : if t == l [ i ] [ 0 ] : if ( s < l [ i ] [ 1 ] or s > l [ i ] [ 2 ] ) and ( s - 1 < l [ i ] [ 1 ] or s - 1 > l [ i ] [ 2 ] ) : s -= 1 st += \" L \" else : st += \" X \" i += 1 if s == f : break else : st += ' L ' s -= 1 if s == f : break t += 1 while ( s > f ) : s -= 1 st += ' L ' print ( st ) if s < f : st = \" \" t = 1 i = 0 while ( i < m ) : if t == l [ i ] [ 0 ] : if ( s < l [ i ] [ 1 ] or s > l [ i ] [ 2 ] ) and ( s + 1 < l [ i ] [ 1 ] or s + 1 > l [ i ] [ 2 ] ) : s += 1 st += \" R \" else : st += \" X \" i += 1 if s == f : break else : st += ' R ' s += 1 if s == f : break t += 1 while ( s < f ) : s += 1 st += ' R ' print ( st ) NEW_LINE"],"bleu":8.066777064909606e-8,"rouge_l":0.022999773772716992}
{"id":609,"predictions":["from collections import deque   n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) )     for t , l , r , x = 0 , 0 for i in range ( n ) : for j in range ( m ) : a [ j ] += x if a [ j ] <= x : a [ j ] += x else : a [ j ] += x else : a [ j ] += x   if t == 1 : print ( ' YES ' ) exit ( )   for _ in range ( n - m + 1 ) : arr = list ( map ( int , input ( ) . split ( ) ) )   print ( ' YES ' ) NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) a = [ 10 ** 9 for _ in range ( n ) ] extra = [ 0 for _ in range ( n ) ] query = list ( ) for _ in range ( m ) : t , l , r , x = map ( int , input ( ) . split ( ) ) l -= 1 r -= 1 query . append ( ( t , l , r , x ) ) if t == 1 : for j in range ( l , r + 1 ) : extra [ j ] += x else : for j in range ( l , r + 1 ) : a [ j ] = min ( a [ j ] , x - extra [ j ] ) extra = a . copy ( ) for t , l , r , x in query : if t == 1 : for j in range ( l , r + 1 ) : a [ j ] += x else : val = - 10 ** 9 for j in range ( l , r + 1 ) : val = max ( val , a [ j ] ) if not val == x : print ( ' NO ' ) exit ( 0 )   print ( ' YES ' ) for x in extra : print ( x , end = ' ▁ ' ) NEW_LINE"],"bleu":0.3391245302936857,"rouge_l":0.46031054999274423}
{"id":610,"predictions":["s = input ( ) i = 0 j = len ( s ) - 1 while i <= j and s [ i ] != s [ j + 1 ] : i += 1 print ( j + 2 ) NEW_LINE"],"references":["a = input ( ) b = input ( ) res = 0 la = len ( a ) lb = len ( b ) sum = la + lb   if la > lb : for i in range ( lb - 1 , - 1 , - 1 ) : la = la - 1 if b [ i ] == a [ la ] : res = res + 1 else : break res = sum - 2 * res print ( res ) else : for i in range ( la - 1 , - 1 , - 1 ) : lb = lb - 1 if a [ i ] == b [ lb ] : res = res + 1 else : break res = sum - 2 * res print ( res )   NEW_LINE"],"bleu":0.02001918119334799,"rouge_l":0.24648456440924515}
{"id":611,"predictions":["n = ( 2 , 4 ) for i in range ( 4 ) : a = list ( map ( int , input ( ) . split ( ) ) ) a = list ( map ( int , input ( ) . split ( ) ) ) a . sort ( ) print ( a [ 1 : 2 ] ) NEW_LINE"],"references":["n = int ( input ( ) ) print ( int ( 2 ** n - ( n > 12 ) * 2 ** ( n - 13 ) * 100 ) ) NEW_LINE"],"bleu":0.08785418351618635,"rouge_l":0.34560906515580736}
{"id":612,"predictions":["n = int ( input ( ) ) arr = [ int ( x ) for x in input ( ) . split ( ) ] m = [ 0 for i in range ( n ) ] for i in range ( m ) : t = [ int ( x ) for x in input ( ) . split ( ) ] print ( arr [ x ] ) NEW_LINE"],"references":["l = lenimport sysc = sys . stdin . readline ( ) d = [ 0 ] * l ( c ) p = c [ 0 ] for i , t in enumerate ( c [ 1 : ] ) : d [ i + 1 ] = d [ i ] + 1 * ( t == p ) p = tfor _ in range ( int ( sys . stdin . readline ( ) ) ) : l , r = map ( int , sys . stdin . readline ( ) . split ( ) ) sys . stdout . write ( str ( d [ r - 1 ] - d [ l - 1 ] ) + \" \\n \" ) NEW_LINE"],"bleu":0.08739145964487084,"rouge_l":0.3331772784019975}
{"id":613,"predictions":["n = int ( input ( ) ) ans = 0 for a in range ( 1 , n ) : ans += ( n - a ) * aprint ( ans + n ) NEW_LINE"],"references":["N , M = ( int ( x ) for x in input ( ) . split ( ) ) A = [ int ( x ) for x in input ( ) . split ( ) ] t = 0 prev = 1   for i , task in enumerate ( A ) : if not task < prev : t += task - prev prev = task else : t += N - prev t += task prev = taskprint ( t ) NEW_LINE"],"bleu":0.03539727089277777,"rouge_l":0.3053053053053053}
{"id":614,"predictions":["from math import ceilfor _ in range ( int ( input ( ) ) ) : x , y , z = map ( int , input ( ) . split ( ) ) g = list ( map ( int , input ( ) . split ( ) ) ) gs = [ 0 ] * yfor i in range ( z ) : gs . append ( i )   g = sorted ( g ) for i in range ( len ( g ) ) : b = g [ i ] if ( g [ i ] ) == 0 : print ( \" NO \" ) NEW_LINE"],"references":["import queue   class Query : def __init__ ( self , t , d , id ) : self . t = t self . d = d self . id = id   n , b = map ( int , input ( ) . split ( ) ) a = [ ] for i in range ( n ) : x , y = map ( int , input ( ) . split ( ) ) a . append ( Query ( x , y , i ) )   i = 0 cur_time = 0 q = queue . Queue ( ) result = [ 0 ] * nwhile i < n : while i < n and a [ i ] . t < cur_time and q . qsize ( ) < b : q . put ( a [ i ] ) i += 1 while i < n and a [ i ] . t < cur_time and q . qsize ( ) == b : result [ i ] = - 1 i += 1 if not q . empty ( ) : processed_query = q . get ( ) cur_time += processed_query . d result [ processed_query . id ] = cur_time else : if i < n : cur_time = a [ i ] . t + a [ i ] . d result [ a [ i ] . id ] = cur_time i += 1 while not q . empty ( ) : processed_query = q . get ( ) cur_time += processed_query . d result [ processed_query . id ] = cur_time for i in range ( n ) : print ( result [ i ] , end = ' ▁ ' ) NEW_LINE"],"bleu":0.08546487944557746,"rouge_l":0.2991973840665874}
{"id":615,"predictions":["n , k = map ( int , input ( ) . split ( ) ) if k == 1 : print ( \" a \" ) else : print ( ' b ' ) NEW_LINE"],"references":["import sys   n , k = map ( int , sys . stdin . readline ( ) . split ( ) ) if k > n or ( k == 1 and n != 1 ) : print ( - 1 ) else : l = [ \" ▁ \" for i in range ( n ) ] last = ord ( \" a \" ) + k - 1 m = n - 1 for i in range ( k - 2 ) : l [ m ] = chr ( last - i ) m -= 1 start = ord ( \" a \" ) for i in range ( n ) : if l [ i ] != \" ▁ \" : break else : l [ i ] = chr ( start ) if i % 2 == 1 : start -= 1 else : start += 1 print ( \" \" . join ( l ) ) NEW_LINE"],"bleu":0.01928672307310604,"rouge_l":0.28689006466784245}
{"id":616,"predictions":["def main ( ) : t = input ( ) if t != ' - 1' : print ( len ( t ) ) else : print ( len ( t ) ) NEW_LINE"],"references":["\"\"\" ▁ Created ▁ by ▁ Henrikh ▁ Kantuni ▁ on ▁ 2\/7\/17 ▁ \"\"\"   a = input ( ) b = input ( ) ans = - 1 if a == b else max ( len ( a ) , len ( b ) ) print ( ans ) NEW_LINE"],"bleu":0.12016455358943226,"rouge_l":0.3585598824393828}
{"id":617,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["print ( * input ( ) . split ( ' WUB ' ) ) NEW_LINE"],"bleu":0.11143093225027423,"rouge_l":0.3201166180758017}
{"id":618,"predictions":["def findSum ( n ) : NEW_LINE INDENT sum2 = ( ( n \/\/ 2 ) * ( 4 + ( n \/\/ 2 - 1 ) * 2 ) ) \/\/ 2 NEW_LINE sum5 = ( ( n \/\/ 5 ) * ( 10 + ( n \/\/ 5 - 1 ) * 5 ) ) \/\/ 2 NEW_LINE sum10 = ( ( n \/\/ 10 ) * ( 20 + ( n \/\/ 10 - 1 ) * 10 ) ) \/\/ 2 NEW_LINE return ( sum2 + sum5 - sum10 ) NEW_LINE DEDENT n = 5 NEW_LINE print ( findSum ( n ) ) NEW_LINE"],"references":["def findSum ( n ) : NEW_LINE INDENT sum2 = ( ( n \/\/ 2 ) * ( 4 + ( n \/\/ 2 - 1 ) * 2 ) ) \/\/ 2 NEW_LINE sum5 = ( ( n \/\/ 5 ) * ( 10 + ( n \/\/ 5 - 1 ) * 5 ) ) \/\/ 2 NEW_LINE sum10 = ( ( n \/\/ 10 ) * ( 20 + ( n \/\/ 10 - 1 ) * 10 ) ) \/\/ 2 NEW_LINE return sum2 + sum5 - sum10 ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( int ( findSum ( n ) ) ) NEW_LINE DEDENT"],"bleu":0.8088548037850173,"rouge_l":0.902568397543272}
{"id":619,"predictions":["def waysToSplit ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE answer = 0 NEW_LINE prefix = [ 0 ] * n NEW_LINE trailing = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT prev = prefix [ i - 1 ] NEW_LINE if ( i - 1 >= 0 ) : NEW_LINE INDENT prefix [ i ] += ( prev + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT prefix [ i ] = prev NEW_LINE DEDENT seen [ ord ( s [ i ] ) - ord ( ' a ' ) ] = 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT prev = suffix [ i ] NEW_LINE if ( seen [ ord ( s [ i ] ) - ord ( ' a ' ) ] == 0 ) : NEW_LINE INDENT suffix [ i - 1 ] += ( prev + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT suffix [ i ] = prev NEW_LINE DEDENT seen [ n - 1 ] = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT prev = suffix [ i ] NEW_LINE if ( seen [ ord ( s [ i ] ) - ord ( ' a ' ) ] == 0 ) : NEW_LINE INDENT suffix [ i - 1 ] += ( prev + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT suffix [ i - 1 ] = prev NEW_LINE DEDENT seen [ ord ( s [ i ] ) - ord ( ' a ' ) ] = 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( prefix [ i ] == suffix [ i ] ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" ababa \" NEW_LINE print ( waysToSplit ( s ) ) NEW_LINE DEDENT"],"references":["def waysToSplit ( s ) : NEW_LINE INDENT n = len ( s ) ; NEW_LINE answer = 0 ; NEW_LINE prefix = [ 0 ] * n ; NEW_LINE suffix = [ 0 ] * n ; NEW_LINE seen = [ 0 ] * 26 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT prev = prefix [ i - 1 ] if ( i - 1 >= 0 ) else 0 ; NEW_LINE if ( seen [ ord ( s [ i ] ) - ord ( ' a ' ) ] == 0 ) : NEW_LINE INDENT prefix [ i ] += ( prev + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT prefix [ i ] = prev ; NEW_LINE DEDENT seen [ ord ( s [ i ] ) - ord ( ' a ' ) ] = 1 ; NEW_LINE DEDENT seen = [ 0 ] * len ( seen ) ; NEW_LINE suffix [ n - 1 ] = 0 ; NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT prev = suffix [ i ] ; NEW_LINE if ( seen [ ord ( s [ i ] ) - ord ( ' a ' ) ] == 0 ) : NEW_LINE INDENT suffix [ i - 1 ] += ( prev + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT suffix [ i - 1 ] = prev ; NEW_LINE DEDENT seen [ ord ( s [ i ] ) - ord ( ' a ' ) ] = 1 ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( prefix [ i ] == suffix [ i ] ) : NEW_LINE INDENT answer += 1 ; NEW_LINE DEDENT DEDENT return answer ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" ababa \" ; NEW_LINE print ( waysToSplit ( s ) ) ; NEW_LINE DEDENT"],"bleu":0.7800091270835829,"rouge_l":0.8138407640255315}
{"id":620,"predictions":["def check ( a , n ) : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( n \/\/ 2 ) : NEW_LINE INDENT if a [ i ] != a [ i + ( n \/\/ 2 ) ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 4 , 1 , 4 ] NEW_LINE n = len ( a ) NEW_LINE if ( check ( a , n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"references":["def check ( a , n ) : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( n \/\/ 2 ) : NEW_LINE INDENT if a [ i ] != a [ i + ( n \/\/ 2 ) ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 4 , 1 , 4 ] NEW_LINE n = len ( a ) NEW_LINE if check ( a , n ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.9664105113775178,"rouge_l":0.9935367114788004}
{"id":621,"predictions":["def solve ( n , k ) : NEW_LINE INDENT if ( n >= ( k * ( k + 1 ) ) \/\/ 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n , k = 12 , 4 NEW_LINE if solve ( n , k ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def solve ( n , k ) : NEW_LINE INDENT if ( n >= ( k * ( k + 1 ) ) \/\/ 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 12 NEW_LINE k = 4 NEW_LINE if ( solve ( n , k ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.8558676891020816,"rouge_l":0.9382917119073472}
{"id":622,"predictions":["def numbersWith3Divisors ( n ) : NEW_LINE INDENT prime = [ True for i in range ( n + 1 ) ] NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( sqrt ( n ) ) + 1 , 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT print ( \" Numbers ▁ with ▁ 3 ▁ divisors ▁ : ▁ \" , end = \" \" ) NEW_LINE for i in range ( 0 , int ( sqrt ( n ) ) + 1 , 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT print ( i * i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 96 NEW_LINE numbersWith3Divisors ( n ) NEW_LINE DEDENT"],"references":["def numbersWith3Divisors ( n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) ; NEW_LINE prime [ 0 ] = prime [ 1 ] = False ; NEW_LINE p = 2 ; NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT p += 1 ; NEW_LINE DEDENT print ( \" Numbers ▁ with ▁ 3 ▁ divisors ▁ : \" ) ; NEW_LINE i = 0 ; NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT print ( i * i , end = \" ▁ \" ) ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT DEDENT n = 96 ; NEW_LINE numbersWith3Divisors ( n ) ; NEW_LINE"],"bleu":0.5827182111005551,"rouge_l":0.7589424572317263}
{"id":623,"predictions":["def countWays ( A , B , C ) : NEW_LINE INDENT minAddA = max ( 0 , ( C + B - A + 2 ) \/\/ 2 ) NEW_LINE count_ways = max ( C - minAddA + 1 , 0 ) NEW_LINE return count_ways NEW_LINE DEDENT A = 3 NEW_LINE B = 5 NEW_LINE C = 5 NEW_LINE print ( countWays ( A , B , C ) ) NEW_LINE"],"references":["def countWays ( A , B , C ) : NEW_LINE INDENT minAddA = max ( 0 , ( C + B - A + 2 ) \/\/ 2 ) NEW_LINE count_ways = max ( C - minAddA + 1 , 0 ) NEW_LINE return count_ways NEW_LINE DEDENT A = 3 NEW_LINE B = 5 NEW_LINE C = 5 NEW_LINE print ( countWays ( A , B , C ) ) NEW_LINE"],"bleu":1.0,"rouge_l":1.0}
{"id":624,"predictions":["def isOperand ( x ) : NEW_LINE INDENT return ( x >= ' a ' and x <= ' z ' ) or ( x >= ' A ' and x <= ' Z ' ) ; NEW_LINE DEDENT def getInfix ( exp ) : NEW_LINE INDENT s = [ ] ; NEW_LINE for i in range ( len ( exp ) ) : NEW_LINE INDENT if ( isOperand ( exp [ i ] ) ) : NEW_LINE INDENT s . append ( exp [ i ] ) ; NEW_LINE DEDENT else : NEW_LINE INDENT op1 = s [ - 1 ] ; NEW_LINE op2 = s [ - 1 ] ; NEW_LINE s . append ( \" ( \" + exp [ i ] + op1 , \" ) \" ) ; NEW_LINE DEDENT DEDENT return s [ - 1 ] ; NEW_LINE DEDENT exp = \" ab * c + \" ; NEW_LINE print ( getInfix ( exp ) ) ; NEW_LINE"],"references":["def isOperand ( x ) : NEW_LINE INDENT return ( ( x >= ' a ' and x <= ' z ' ) or ( x >= ' A ' and x <= ' Z ' ) ) NEW_LINE DEDENT def getInfix ( exp ) : NEW_LINE INDENT s = [ ] NEW_LINE for i in exp : NEW_LINE INDENT if ( isOperand ( i ) ) : NEW_LINE INDENT s . insert ( 0 , i ) NEW_LINE DEDENT else : NEW_LINE INDENT op1 = s [ 0 ] NEW_LINE s . pop ( 0 ) NEW_LINE op2 = s [ 0 ] NEW_LINE s . pop ( 0 ) NEW_LINE s . insert ( 0 , \" ( \" + op2 + i + op1 + \" ) \" ) NEW_LINE DEDENT DEDENT return s [ 0 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT exp = \" ab * c + \" NEW_LINE print ( getInfix ( exp . strip ( ) ) ) NEW_LINE DEDENT"],"bleu":0.5584975846837718,"rouge_l":0.7630825057295646}
{"id":625,"predictions":["def countPairs ( arr , n ) : NEW_LINE INDENT twoCount = 0 NEW_LINE twoArCount = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == 2 ) : NEW_LINE INDENT twoCount += 1 NEW_LINE DEDENT elif ( arr [ i ] > 2 ) : NEW_LINE INDENT twoArCount += 1 NEW_LINE DEDENT DEDENT return twoCount * twoArCount + ( twoTrCount * ( twoTrCount - 1 ) ) \/\/ 2 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE DEDENT"],"references":["def CountPairs ( arr , n ) : NEW_LINE INDENT twoCount = 0 NEW_LINE twoGrCount = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == 2 ) : NEW_LINE INDENT twoCount += 1 NEW_LINE DEDENT elif ( arr [ i ] > 2 ) : NEW_LINE INDENT twoGrCount += 1 NEW_LINE DEDENT DEDENT return ( ( twoCount * twoGrCount ) + ( twoGrCount * ( twoGrCount - 1 ) ) \/ 2 ) NEW_LINE DEDENT arr = [ 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( CountPairs ( arr , n ) ) NEW_LINE"],"bleu":0.6869755533017757,"rouge_l":0.8526698350573105}
{"id":626,"predictions":["def isValidTime ( arr ) : NEW_LINE INDENT regexPattern = \" ( 1 [ 0 ] | [ 1 - 9 ] ) NEW_LINE for i in range ( 1 , len ( arr ) ) : NEW_LINE INDENT if ( \" ( 1 - k ] [ 0 - 9 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( am | pm ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \"12:15 ▁ AM \" NEW_LINE print ( isValidTime ( str1 ) ) NEW_LINE str2 = \"9\" NEW_LINE print ( isValidTime ( str1 ) ) NEW_LINE str3 = \"1\" NEW_LINE print ( isValidTime ( str2 ) ) NEW_LINE str3 = \"17\" NEW_LINE print ( isValidTime ( str3 ) ) NEW_LINE DEDENT"],"references":["import re NEW_LINE def isValidTime ( time ) : NEW_LINE INDENT regexPattern = \" ( 1[012 ] | [ 1-9 ] ) : \" + \" [ 0-5 ] [ 0-9 ] ( \\\\s ) \" + \" ? ( ? i ) ( am | pm ) \" ; NEW_LINE compiledPattern = re . compile ( regexPattern ) ; NEW_LINE if ( time == None ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT if re . search ( compiledPattern , time ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \"12:15 ▁ AM \" ; NEW_LINE print ( isValidTime ( str1 ) ) ; NEW_LINE str2 = \"9:45PM \" ; NEW_LINE print ( isValidTime ( str2 ) ) ; NEW_LINE str3 = \"1:15\" ; NEW_LINE print ( isValidTime ( str3 ) ) ; NEW_LINE str4 = \"17:30\" ; NEW_LINE print ( isValidTime ( str4 ) ) ; NEW_LINE DEDENT"],"bleu":0.4467050138619452,"rouge_l":0.6261815225124504}
{"id":627,"predictions":["def minXOR ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE minXor = sys . maxsize NEW_LINE val = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT val = arr [ i ] ^ arr [ i + 1 ] NEW_LINE minXor = min ( minXor , val ) NEW_LINE DEDENT return minXor NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 9 , 5 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minXOR ( arr , n ) ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE def minXOR ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE minXor = int ( sys . float_info . max ) NEW_LINE val = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT val = arr [ i ] ^ arr [ i + 1 ] ; NEW_LINE minXor = min ( minXor , val ) ; NEW_LINE DEDENT return minXor NEW_LINE DEDENT arr = [ 9 , 5 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minXOR ( arr , n ) ) NEW_LINE"],"bleu":0.7781683984087289,"rouge_l":0.869403563129357}
{"id":628,"predictions":["def sum ( m , n ) : NEW_LINE INDENT return 8 * m * n - 6 * m - 6 * n + 4 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ _ ' : NEW_LINE INDENT m = 3 NEW_LINE n = 2 NEW_LINE print ( sum ( m , n ) ) NEW_LINE DEDENT"],"references":["def summ ( m , n ) : NEW_LINE INDENT return 8 * m * n - 6 * m - 6 * n + 4 NEW_LINE DEDENT m = 3 NEW_LINE n = 2 NEW_LINE print ( summ ( m , n ) ) NEW_LINE"],"bleu":0.6543058545013916,"rouge_l":0.8437598239547313}
{"id":629,"predictions":["def isPossible ( string ) : NEW_LINE INDENT freq = { } NEW_LINE max_freq = 0 NEW_LINE for j in range ( len ( string ) ) : NEW_LINE INDENT if string [ j ] in freq : NEW_LINE INDENT freq [ string [ j ] ] = freq [ string [ j ] ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ string [ j ] ] = 1 NEW_LINE if freq [ string [ j ] ] > max_freq : NEW_LINE INDENT max_freq = freq [ string [ j ] ] NEW_LINE DEDENT DEDENT DEDENT if max_freq <= ( len ( string ) - max_freq + 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" geeksforgeeks \" NEW_LINE if isPossible ( string ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def isPossible ( Str ) : NEW_LINE INDENT freq = dict ( ) NEW_LINE max_freq = 0 NEW_LINE for j in range ( len ( Str ) ) : NEW_LINE INDENT freq [ Str [ j ] ] = freq . get ( Str [ j ] , 0 ) + 1 NEW_LINE if ( freq [ Str [ j ] ] > max_freq ) : NEW_LINE INDENT max_freq = freq [ Str [ j ] ] NEW_LINE DEDENT DEDENT if ( max_freq <= ( len ( Str ) - max_freq + 1 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT Str = \" geeksforgeeks \" NEW_LINE if ( isPossible ( Str ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.5416489258095499,"rouge_l":0.766805156066901}
{"id":630,"predictions":["def isVowel ( c ) : NEW_LINE INDENT return ( c == ' a ' or c == ' e ' or c == ' E ' or c == ' i ' or c == ' i ' or c == ' O ' or c == ' O ' or c == ' O ' or c == ' O ' or c == ' u ' ) ; NEW_LINE DEDENT def reverseVowel ( str ) : NEW_LINE INDENT i = 0 ; j = len ( str ) - 1 ; NEW_LINE while ( i < j ) : NEW_LINE INDENT if ( isVowel ( str1 [ i ] ) ) : NEW_LINE INDENT i += 1 ; NEW_LINE continue ; NEW_LINE DEDENT if ( not isVowel ( str1 [ j ] ) ) : NEW_LINE INDENT j -= 1 ; NEW_LINE continue ; NEW_LINE DEDENT if ( isVowel ( str1 [ j ] ) ) : NEW_LINE INDENT j -= 1 ; NEW_LINE continue ; NEW_LINE DEDENT temp = str1 [ i ] ; NEW_LINE str1 [ j ] = temp ; NEW_LINE i += 1 ; NEW_LINE j -= 1 ; NEW_LINE DEDENT return str2 ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" hello ▁ world \" ; NEW_LINE print ( reverseVowel ( str ) ) ; NEW_LINE DEDENT"],"references":["def isVowel ( c ) : NEW_LINE INDENT return ( c == ' a ' or c == ' A ' or c == ' e ' or c == ' E ' or c == ' i ' or c == ' I ' or c == ' o ' or c == ' O ' or c == ' u ' or c == ' U ' ) NEW_LINE DEDENT def reverseVowel ( str ) : NEW_LINE INDENT i = 0 NEW_LINE j = len ( str ) - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT if not isVowel ( str [ i ] ) : NEW_LINE INDENT i += 1 NEW_LINE continue NEW_LINE DEDENT if ( not isVowel ( str [ j ] ) ) : NEW_LINE INDENT j -= 1 NEW_LINE continue NEW_LINE DEDENT str [ i ] , str [ j ] = str [ j ] , str [ i ] NEW_LINE i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return str NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" hello ▁ world \" NEW_LINE print ( * reverseVowel ( list ( str ) ) , sep = \" \" ) NEW_LINE DEDENT"],"bleu":0.6087564921994737,"rouge_l":0.8086015170483835}
{"id":631,"predictions":["import math NEW_LINE def findBucketNo ( p ) : NEW_LINE INDENT return math . ceil ( ( math . sqrt ( 8 * p + 1 ) - 1 ) \/ 2 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT p = 10 NEW_LINE print ( findBucketNo ( p ) ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def findBucketNo ( p ) : NEW_LINE INDENT return math . ceil ( ( math . sqrt ( 8 * p + 1 ) - 1 ) \/ 2 ) NEW_LINE DEDENT p = 10 NEW_LINE print ( findBucketNo ( p ) ) NEW_LINE"],"bleu":0.7430089794525743,"rouge_l":0.8912029841467206}
{"id":632,"predictions":["class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def insert ( node , data ) : NEW_LINE INDENT if node == None : NEW_LINE INDENT return Node ( data ) NEW_LINE DEDENT else : NEW_LINE INDENT if node . data <= node . data : NEW_LINE INDENT node . left = insert ( node . left , data ) NEW_LINE DEDENT else : NEW_LINE INDENT node . right = insert ( node . right , data ) NEW_LINE DEDENT return node NEW_LINE DEDENT DEDENT def minValue ( node ) : NEW_LINE INDENT if not node . left : NEW_LINE INDENT return node . data NEW_LINE DEDENT return minValue ( node . left ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = None NEW_LINE root = insert ( root , 4 ) NEW_LINE insert ( root , 2 ) NEW_LINE insert ( root , 1 ) NEW_LINE insert ( root , 3 ) NEW_LINE insert ( root , 6 ) NEW_LINE insert ( root , 5 ) NEW_LINE insert ( root , 5 ) NEW_LINE print ( minValue ( root ) ) NEW_LINE DEDENT"],"references":["class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def insert ( node , data ) : NEW_LINE INDENT if node is None : NEW_LINE INDENT return Node ( data ) NEW_LINE DEDENT else : NEW_LINE INDENT if data <= node . data : NEW_LINE INDENT node . left = insert ( node . left , data ) NEW_LINE DEDENT else : NEW_LINE INDENT node . right = insert ( node . right , data ) NEW_LINE DEDENT return node NEW_LINE DEDENT DEDENT def minValue ( node ) : NEW_LINE INDENT if node . left == None : NEW_LINE INDENT return node . data NEW_LINE DEDENT return minValue ( node . left ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT root = None NEW_LINE root = insert ( root , 4 ) NEW_LINE insert ( root , 2 ) NEW_LINE insert ( root , 1 ) NEW_LINE insert ( root , 3 ) NEW_LINE insert ( root , 6 ) NEW_LINE insert ( root , 5 ) NEW_LINE print ( minValue ( root ) ) NEW_LINE DEDENT"],"bleu":0.9090492005276232,"rouge_l":0.9613648534924641}
{"id":633,"predictions":["def removeZeros ( a , n ) : NEW_LINE INDENT ind = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] != 0 ) : NEW_LINE INDENT ind = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( ind == - 1 ) : NEW_LINE INDENT print ( \" Array ▁ has ▁ + \" ) NEW_LINE return NEW_LINE DEDENT b = [ 0 for i in range ( n - ind ) ] NEW_LINE for i in range ( 0 , n - ind ) : NEW_LINE INDENT b [ i ] = a [ ind + i ] NEW_LINE DEDENT for i in range ( 0 , n - ind ) : NEW_LINE INDENT print ( b [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT a = [ 0 , 0 , 0 , 1 , 2 , 0 , 3 ] NEW_LINE n = len ( a ) NEW_LINE removeZeros ( a , n ) NEW_LINE"],"references":["def removeZeros ( a , n ) : NEW_LINE INDENT ind = - 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] != 0 ) : NEW_LINE INDENT ind = i ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( ind == - 1 ) : NEW_LINE INDENT print ( \" Array ▁ has ▁ leading ▁ zeros ▁ only \" ) ; NEW_LINE return ; NEW_LINE DEDENT b = [ 0 ] * ( n - ind ) ; NEW_LINE for i in range ( n - ind ) : NEW_LINE INDENT b [ i ] = a [ ind + i ] ; NEW_LINE DEDENT for i in range ( n - ind ) : NEW_LINE INDENT print ( b [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT a = [ 0 , 0 , 0 , 1 , 2 , 0 , 3 ] ; NEW_LINE n = len ( a ) ; NEW_LINE removeZeros ( a , n ) ; NEW_LINE"],"bleu":0.7840178189977373,"rouge_l":0.91716631307075}
{"id":634,"predictions":["def countCoins ( n ) : NEW_LINE INDENT c = 0 NEW_LINE if ( n < 10 ) : NEW_LINE INDENT return n NEW_LINE DEDENT if ( n > 9 and n < 25 ) : NEW_LINE INDENT c = n \/\/ 10 + n % 10 NEW_LINE return c NEW_LINE DEDENT if ( n > 24 ) : NEW_LINE INDENT c = n \/\/ 25 NEW_LINE if ( n % 25 < 10 ) : NEW_LINE INDENT c = c + n % 25 NEW_LINE return c NEW_LINE DEDENT if ( n % 25 > 9 ) : NEW_LINE INDENT c = c + ( n % 25 ) \/\/ 10 + ( n % 25 ) % 10 NEW_LINE return c NEW_LINE DEDENT DEDENT return c NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 14 NEW_LINE print ( countCoins ( n ) ) NEW_LINE DEDENT"],"references":["def countCoins ( n ) : NEW_LINE INDENT c = 0 NEW_LINE if ( n < 10 ) : NEW_LINE INDENT return n NEW_LINE DEDENT if ( n > 9 and n < 25 ) : NEW_LINE INDENT c = n \/\/ 10 + n % 10 NEW_LINE return c NEW_LINE DEDENT if ( n > 24 ) : NEW_LINE INDENT c = n \/\/ 25 NEW_LINE if ( n % 25 < 10 ) : NEW_LINE INDENT c = c + n % 25 NEW_LINE return c NEW_LINE DEDENT if ( n % 25 > 9 ) : NEW_LINE INDENT c = ( c + ( n % 25 ) \/\/ 10 + ( n % 25 ) % 10 ) NEW_LINE return c NEW_LINE DEDENT DEDENT DEDENT n = 14 NEW_LINE print ( countCoins ( n ) ) NEW_LINE"],"bleu":0.856377084721813,"rouge_l":0.9446301247771836}
{"id":635,"predictions":["def isVowel ( ch ) : NEW_LINE INDENT if ( ch == ' a ' or ch == ' e ' or ch == ' i ' or ch == ' o ' or ch == ' o ' ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def createAltStr ( str1 , str2 , start , l ) : NEW_LINE INDENT finalStr = \" \" NEW_LINE for i in range ( start , l ) : NEW_LINE INDENT finalStr = ( finalStr + ord ( ch1 [ i ] ) ) + str2 [ j ] NEW_LINE DEDENT return finalStr NEW_LINE DEDENT def findAltStr ( str1 ) : NEW_LINE INDENT nv = 0 NEW_LINE nc = 0 NEW_LINE vstr = \" \" NEW_LINE lstr = \" \" NEW_LINE l = len ( str ) NEW_LINE for i in range ( l l ) : NEW_LINE INDENT ch = str [ i ] NEW_LINE if ( isVowel ( ch ) ) : NEW_LINE INDENT nv += 1 NEW_LINE vstr = vstr + ch NEW_LINE DEDENT else : NEW_LINE INDENT nc += 1 NEW_LINE cstr = cstr + ch NEW_LINE DEDENT DEDENT if ( abs ( nv - nc ) >= 2 ) : NEW_LINE INDENT return \" no ▁ such ▁ string \" NEW_LINE DEDENT if ( nc > nc ) : NEW_LINE INDENT return \" no ▁ such ▁ string \" + createAltStr ( vstr , cstr , 1 , nv ) ) NEW_LINE DEDENT if ( nc > nc ) : NEW_LINE INDENT return ( cstr [ 0 ] + createAltStr ( vstr , cstr , 1 , nv ) ) NEW_LINE DEDENT return createAltStr ( vstr , cstr , 0 , nc ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" geeks \" NEW_LINE print ( findAltStr ( string ) ) NEW_LINE DEDENT"],"references":["def isVowel ( ch ) : NEW_LINE INDENT if ( ch == ' a ' or ch == ' e ' or ch == ' i ' or ch == ' o ' or ch == ' u ' ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def createAltStr ( str1 , str2 , start , l ) : NEW_LINE INDENT finalStr = \" \" NEW_LINE i = 0 NEW_LINE for j in range ( start , l ) : NEW_LINE INDENT finalStr = ( finalStr + str1 [ i ] ) + str2 [ j ] NEW_LINE i + 1 NEW_LINE DEDENT return finalStr NEW_LINE DEDENT def findAltStr ( str1 ) : NEW_LINE INDENT nv = 0 NEW_LINE nc = 0 NEW_LINE vstr = \" \" NEW_LINE cstr = \" \" NEW_LINE l = len ( str1 ) NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT if ( isVowel ( str1 [ i ] ) ) : NEW_LINE INDENT nv += 1 NEW_LINE vstr = vstr + str1 [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT nc += 1 NEW_LINE cstr = cstr + str1 [ i ] NEW_LINE DEDENT DEDENT if ( abs ( nv - nc ) >= 2 ) : NEW_LINE INDENT return \" no ▁ such ▁ string \" NEW_LINE DEDENT if ( nv > nc ) : NEW_LINE INDENT return ( vstr [ 0 ] + createAltStr ( cstr , vstr , 1 , nv ) ) NEW_LINE DEDENT if ( nc > nv ) : NEW_LINE INDENT return ( cstr [ 0 ] + createAltStr ( vstr , cstr , 1 , nc ) ) NEW_LINE DEDENT if ( cstr [ 0 ] < vstr [ 0 ] ) : NEW_LINE INDENT return createAltStr ( cstr , vstr , 0 , nv ) NEW_LINE DEDENT return createAltStr ( vstr , cstr , 0 , nc ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" geeks \" NEW_LINE print ( findAltStr ( str1 ) ) NEW_LINE DEDENT"],"bleu":0.7420813963484346,"rouge_l":0.8434946574481459}
{"id":636,"predictions":["import numpy as np NEW_LINE def convertToString ( num ) : NEW_LINE INDENT dp = np . zeros ( ( 15 , 2 ) ) NEW_LINE return dp [ pos ] [ tight ] NEW_LINE DEDENT def calculate ( pos , tight , D , sz , num ) : NEW_LINE INDENT if ( pos == len ( num ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( dp [ pos ] [ tight ] != - 1 ) : NEW_LINE INDENT return dp [ pos ] [ tight ] NEW_LINE DEDENT val = 0 NEW_LINE if ( tight == 0 ) : NEW_LINE INDENT for i in range ( sz ) : NEW_LINE INDENT if ( D [ i ] < ( ord ( num [ pos ] ) - ord ( '0' ) ) ) : NEW_LINE INDENT val += calculate ( pos + 1 , 1 , D , D , num ) NEW_LINE DEDENT elif ( D [ i ] == num [ pos ] ) - ord ( '0' ) ) : NEW_LINE INDENT val += calculate ( pos + 1 , tight , D , sz , num ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( sz ) : NEW_LINE INDENT val += calculate ( pos + 1 , tight , D , dz , num ) NEW_LINE DEDENT DEDENT dp [ pos ] [ tight ] = val NEW_LINE return val NEW_LINE DEDENT def countNumbers ( D , N , sz ) : NEW_LINE INDENT num = convertToString ( N ) NEW_LINE Len = len ( num ) NEW_LINE for i in range ( 15 ) : NEW_LINE INDENT ans += calculate ( i , 1 , D , sz , num ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT sz = 3 NEW_LINE DEDENT"],"references":["import numpy as np ; NEW_LINE dp = np . ones ( ( 15 , 2 ) ) * - 1 ; NEW_LINE def convertToString ( num ) : NEW_LINE INDENT return str ( num ) ; NEW_LINE DEDENT def calculate ( pos , tight , D , sz , num ) : NEW_LINE INDENT if ( pos == len ( num ) ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT if ( dp [ pos ] [ tight ] != - 1 ) : NEW_LINE INDENT return dp [ pos ] [ tight ] ; NEW_LINE DEDENT val = 0 ; NEW_LINE if ( tight == 0 ) : NEW_LINE INDENT for i in range ( sz ) : NEW_LINE INDENT if ( D [ i ] < ( ord ( num [ pos ] ) - ord ( '0' ) ) ) : NEW_LINE INDENT val += calculate ( pos + 1 , 1 , D , sz , num ) ; NEW_LINE DEDENT elif ( D [ i ] == ord ( num [ pos ] ) - ord ( '0' ) ) : NEW_LINE INDENT val += calculate ( pos + 1 , tight , D , sz , num ) ; NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT for i in range ( sz ) : NEW_LINE INDENT val += calculate ( pos + 1 , tight , D , sz , num ) ; NEW_LINE DEDENT DEDENT dp [ pos ] [ tight ] = val ; NEW_LINE return dp [ pos ] [ tight ] ; NEW_LINE DEDENT def countNumbers ( D , N , sz ) : NEW_LINE INDENT num = convertToString ( N ) ; NEW_LINE length = len ( num ) ; NEW_LINE ans = calculate ( 0 , 0 , D , sz , num ) ; NEW_LINE for i in range ( 1 , length ) : NEW_LINE INDENT ans += calculate ( i , 1 , D , sz , num ) ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT sz = 3 ; NEW_LINE D = [ 1 , 4 , 9 ] ; NEW_LINE N = 10 ; NEW_LINE print ( countNumbers ( D , N , sz ) ) ; NEW_LINE DEDENT"],"bleu":0.6994548118520867,"rouge_l":0.825328101745366}
{"id":637,"predictions":["def summation ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( i * i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 2 NEW_LINE print ( summation ( n ) ) NEW_LINE"],"references":["def summation ( n ) : NEW_LINE INDENT return sum ( [ i ** 2 for i in range ( 1 , n + 1 ) ] ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 2 NEW_LINE print ( summation ( n ) ) NEW_LINE DEDENT"],"bleu":0.5634336754042605,"rouge_l":0.6672743846855059}
{"id":638,"predictions":["def countPairs ( arr , n ) : NEW_LINE INDENT frequency = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT frequency [ arr [ i ] ] += 1 NEW_LINE DEDENT count = 0 NEW_LINE for f in frequency . values ( ) : NEW_LINE INDENT count += f * ( f - 1 ) \/\/ 2 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE DEDENT"],"references":["from collections import defaultdict NEW_LINE def countPairs ( a , n ) : NEW_LINE INDENT frequency = defaultdict ( int ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT frequency [ a [ i ] ] += 1 NEW_LINE DEDENT count = 0 NEW_LINE for x in frequency . keys ( ) : NEW_LINE INDENT f = frequency [ x ] NEW_LINE count += f * ( f - 1 ) \/\/ 2 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.7678306463829041,"rouge_l":0.8923098356088047}
{"id":639,"predictions":["import heapq NEW_LINE def search ( a , k , x ) : NEW_LINE INDENT for j in range ( k - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( a [ j ] == x ) : NEW_LINE INDENT return j NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT def genArray ( a , N ) : NEW_LINE INDENT for i in range ( N - 1 ) : NEW_LINE INDENT if search ( a , i , arr [ i ] ) == - 1 : NEW_LINE INDENT arr [ i + 1 ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i + 1 ] = ( i - search ( arr , i , arr [ i ] ) ) NEW_LINE DEDENT DEDENT DEDENT N = 5 NEW_LINE size = N + 1 NEW_LINE a = [ 0 for i in range ( N + 1 ) ] NEW_LINE genArray ( a , N ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT print ( a [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT"],"references":["def search ( a , k , x ) : NEW_LINE INDENT for j in range ( k - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( a [ j ] == x ) : NEW_LINE INDENT return j NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT def genArray ( arr , N ) : NEW_LINE INDENT for i in range ( 0 , N - 1 , 1 ) : NEW_LINE INDENT if ( search ( arr , i , arr [ i ] ) == - 1 ) : NEW_LINE INDENT arr [ i + 1 ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i + 1 ] = ( i - search ( arr , i , arr [ i ] ) ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 5 NEW_LINE size = N + 1 NEW_LINE a = [ 0 ] * N NEW_LINE genArray ( a , N ) NEW_LINE print ( a ) NEW_LINE DEDENT"],"bleu":0.7716392812150625,"rouge_l":0.8543868921775899}
{"id":640,"predictions":["from math import pow NEW_LINE maxN = 20 NEW_LINE maxM = 64 ; NEW_LINE def cntSplits ( s ) : NEW_LINE INDENT if ( s [ len ( s ) - 1 ] == '1' ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT c_zero = 0 ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT c_zero += ( if ( s [ i ] == '0' ) ) else 0 ; NEW_LINE DEDENT return pow ( 2 , c_zero - 1 ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \"10010\" ; NEW_LINE print ( cntSplits ( s ) ) ; NEW_LINE DEDENT"],"references":["def cntSplits ( s ) : NEW_LINE INDENT if ( s [ len ( s ) - 1 ] == '1' ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT c_zero = 0 ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT c_zero += ( s [ i ] == '0' ) ; NEW_LINE DEDENT return int ( pow ( 2 , c_zero - 1 ) ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \"10010\" ; NEW_LINE print ( cntSplits ( s ) ) ; NEW_LINE DEDENT"],"bleu":0.8082373268771641,"rouge_l":0.913552787663108}
{"id":641,"predictions":["MAX = 100 ; NEW_LINE def middleum ( mat , n ) : NEW_LINE INDENT row_sum = 0 NEW_LINE col_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT row_sum += mat [ n \/\/ 2 ] [ i ] NEW_LINE DEDENT print ( \" Sum ▁ of ▁ middle ▁ row ▁ = ▁ \" , row_sum ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT col_sum += mat [ i ] [ n \/\/ 2 ] ; NEW_LINE DEDENT print ( \" Sum ▁ of ▁ middle ▁ column ▁ = ▁ \" , col_sum ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT mat = [ [ 2 , 5 , 7 ] , [ 3 , 7 , 2 ] , [ 5 , 6 , 9 ] ] ; NEW_LINE mdsum ( mat , 3 ) ; NEW_LINE DEDENT"],"references":["def middlesum ( mat , n ) : NEW_LINE INDENT row_sum = 0 NEW_LINE col_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT row_sum += mat [ n \/\/ 2 ] [ i ] NEW_LINE DEDENT print ( \" Sum ▁ of ▁ middle ▁ row ▁ = ▁ \" , row_sum ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT col_sum += mat [ i ] [ n \/\/ 2 ] NEW_LINE DEDENT print ( \" Sum ▁ of ▁ middle ▁ column ▁ = ▁ \" , col_sum ) NEW_LINE DEDENT mat = [ [ 2 , 5 , 7 ] , [ 3 , 7 , 2 ] , [ 5 , 6 , 9 ] ] NEW_LINE middlesum ( mat , 3 ) NEW_LINE"],"bleu":0.7760609525891862,"rouge_l":0.9188399280575539}
{"id":642,"predictions":["def Vertices ( x , y ) : NEW_LINE INDENT val = abs ( x ) + abs ( y ) ; NEW_LINE print ( val * ( x < 0 else 1 if x < 0 else 1 ) , end = \" ▁ \" ) ; NEW_LINE print ( \"0 ▁ \" , val * ( - 1 if y < 0 else 1 ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x , y = 3 , 3 ; NEW_LINE Vertices ( x , y ) ; NEW_LINE DEDENT"],"references":["def Vertices ( x , y ) : NEW_LINE INDENT val = abs ( x ) + abs ( y ) ; NEW_LINE if x < 0 : NEW_LINE INDENT x = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT x = 1 NEW_LINE DEDENT print ( val * x , \"0\" , end = \" ▁ \" ) ; NEW_LINE if y < 0 : NEW_LINE INDENT y = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT y = 1 NEW_LINE DEDENT print ( \"0\" , val * y ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = 3 ; y = 3 ; NEW_LINE Vertices ( x , y ) ; NEW_LINE DEDENT"],"bleu":0.5461450178455832,"rouge_l":0.6599288256227758}
{"id":643,"predictions":["def isPrime ( n ) : NEW_LINE INDENT for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT def printMinCountPrime ( N ) : NEW_LINE INDENT minCount = 0 ; NEW_LINE if ( isPrime ( N ) ) : NEW_LINE INDENT minCount = 2 ; NEW_LINE DEDENT elif ( N % 2 == 0 ) : NEW_LINE INDENT minCount = 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( isPrime ( N - 2 ) ) : NEW_LINE INDENT minCount = 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT minCount = 3 ; NEW_LINE DEDENT DEDENT print ( minCount ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 100 ; NEW_LINE printMinCountPrime ( N ) ; NEW_LINE DEDENT"],"references":["def isPrime ( n ) : NEW_LINE INDENT for i in range ( 2 , int ( n ** ( 1 \/ 2 ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT def printMinCountPrime ( N ) : NEW_LINE INDENT if ( isPrime ( N ) ) : NEW_LINE INDENT minCount = 1 ; NEW_LINE DEDENT elif ( N % 2 == 0 ) : NEW_LINE INDENT minCount = 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( isPrime ( N - 2 ) ) : NEW_LINE INDENT minCount = 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT minCount = 3 ; NEW_LINE DEDENT DEDENT print ( minCount ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 100 ; NEW_LINE printMinCountPrime ( N ) ; NEW_LINE DEDENT"],"bleu":0.9101388591171831,"rouge_l":0.9524441269517298}
{"id":644,"predictions":["def findCount ( d ) : NEW_LINE INDENT return 9 * ( pow ( 10 , d - 1 ) - pow ( 9 , d - 1 ) ) NEW_LINE DEDENT def findCountUpto ( d ) : NEW_LINE INDENT totalCount = 0 NEW_LINE for i in range ( 1 , d + 1 ) : NEW_LINE INDENT totalCount += findCount ( i ) NEW_LINE DEDENT return totalCount NEW_LINE DEDENT d = 1 NEW_LINE print ( findCountUpto ( d ) ) NEW_LINE d = 2 NEW_LINE print ( findCountUpto ( d ) ) NEW_LINE d = 4 NEW_LINE print ( findCountUpto ( d ) ) NEW_LINE d = 4 NEW_LINE print ( findCountUpto ( d ) ) NEW_LINE"],"references":["import math NEW_LINE def findCountUpto ( d ) : NEW_LINE INDENT GP1_Sum = 9 * ( ( int ) ( ( math . pow ( 10 , d ) ) - 1 ) \/\/ 9 ) NEW_LINE GP2_Sum = 9 * ( ( int ) ( ( math . pow ( 9 , d ) ) - 1 ) \/\/ 8 ) NEW_LINE return GP1_Sum - GP2_Sum NEW_LINE DEDENT d = 1 NEW_LINE print ( findCountUpto ( d ) ) NEW_LINE d = 2 NEW_LINE print ( findCountUpto ( d ) ) NEW_LINE d = 4 NEW_LINE print ( findCountUpto ( d ) ) NEW_LINE"],"bleu":0.5132272369746547,"rouge_l":0.625408618127786}
{"id":645,"predictions":["def two_set ( a , n ) : NEW_LINE INDENT a . sort ( ) ; NEW_LINE return ( a [ int ( n \/ 2 ) ] - a [ int ( ( n \/ 2 ) - 1 ) ] ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 4 , 4 , 6 , 7 , 9 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( two_sets ( a , n ) ) ; NEW_LINE DEDENT"],"references":["def two_sets ( a , n ) : NEW_LINE INDENT a . sort ( ) ; NEW_LINE return ( a [ n \/\/ 2 ] - a [ ( n \/\/ 2 ) - 1 ] ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 4 , 4 , 6 , 7 , 9 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( two_sets ( a , n ) ) ; NEW_LINE DEDENT"],"bleu":0.8114950897362398,"rouge_l":0.9342831700801425}
{"id":646,"predictions":["def maximumArea ( l , b , x , y ) : NEW_LINE INDENT left = x * b NEW_LINE right = ( l - x - 1 ) * b NEW_LINE above = l * y NEW_LINE below = ( b - y - 1 ) * l NEW_LINE print ( max ( left , right ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT L = 8 NEW_LINE B = 8 NEW_LINE X = 0 NEW_LINE Y = 0 NEW_LINE maximumArea ( L , B , X , Y ) NEW_LINE DEDENT"],"references":["def maximumArea ( l , b , x , y ) : NEW_LINE INDENT left , right , above , below = 0 , 0 , 0 , 0 NEW_LINE left = x * b NEW_LINE right = ( l - x - 1 ) * b NEW_LINE above = l * y NEW_LINE below = ( b - y - 1 ) * l NEW_LINE print ( max ( max ( left , right ) , max ( above , below ) ) ) NEW_LINE DEDENT l = 8 NEW_LINE b = 8 NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE maximumArea ( l , b , x , y ) NEW_LINE"],"bleu":0.5967152452313683,"rouge_l":0.7333934475503456}
{"id":647,"predictions":["def check ( arr , N , K ) : NEW_LINE INDENT unique = set ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT unique . add ( arr [ i ] ) NEW_LINE DEDENT if ( len ( unique ) == K ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 1 , 2 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE K = 3 NEW_LINE if ( check ( arr , N , K ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def check ( arr , N , K ) : NEW_LINE INDENT unique = dict ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT unique [ arr [ i ] ] = 1 NEW_LINE DEDENT if len ( unique ) == K : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT arr = [ 1 , 1 , 2 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE K = 3 NEW_LINE if ( check ( arr , N , K ) == True ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.7553248652314075,"rouge_l":0.8953676272555885}
{"id":648,"predictions":["def rascalPeaser ( a , b ) : NEW_LINE INDENT res = 0 NEW_LINE while ( b > 0 ) : NEW_LINE INDENT if ( b & 1 ) : NEW_LINE INDENT res = res + a NEW_LINE DEDENT a = a << 1 NEW_LINE b = b >> 1 NEW_LINE DEDENT return res NEW_LINE DEDENT print ( rroughPeasant ( 18 , 1 ) ) NEW_LINE print ( rroughPeasant ( 20 , 12 ) ) NEW_LINE"],"references":["def russianPeasant ( a , b ) : NEW_LINE INDENT res = 0 NEW_LINE while ( b > 0 ) : NEW_LINE INDENT if ( b & 1 ) : NEW_LINE INDENT res = res + a NEW_LINE DEDENT a = a << 1 NEW_LINE b = b >> 1 NEW_LINE DEDENT return res NEW_LINE DEDENT print ( russianPeasant ( 18 , 1 ) ) NEW_LINE print ( russianPeasant ( 20 , 12 ) ) NEW_LINE"],"bleu":0.9093829533404998,"rouge_l":0.9605263157894735}
{"id":649,"predictions":["import sys NEW_LINE def FindMinimumCost ( ind , a , n , k , k , dp ) : NEW_LINE INDENT if ( ind == ( n - 1 ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( dp [ ind ] != - 1 ) : NEW_LINE INDENT return dp [ ind ] NEW_LINE DEDENT else : NEW_LINE INDENT ans = sys . maxsize NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT if ( ind + i < n ) : NEW_LINE INDENT ans = min ( ans , abs ( a [ ind + i ] - a [ ind ] ) + FindMinimumCost ( ind + i , a , n , k , dp ) ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT dp [ ind ] = ans NEW_LINE return ans NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 10 , 30 , 40 , 50 , 20 ] NEW_LINE k = 3 NEW_LINE n = len ( a ) NEW_LINE dp = [ - 1 for i in range ( n ) ] NEW_LINE print ( FindMinimumCost ( 0 , a , n , k , dp ) ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE def FindMinimumCost ( ind , a , n , k , dp ) : NEW_LINE INDENT if ( ind == ( n - 1 ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( dp [ ind ] != - 1 ) : NEW_LINE INDENT return dp [ ind ] NEW_LINE DEDENT else : NEW_LINE INDENT ans = sys . maxsize NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT if ( ind + i < n ) : NEW_LINE INDENT ans = min ( ans , abs ( a [ ind + i ] - a [ ind ] ) + FindMinimumCost ( ind + i , a , n , k , dp ) ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT dp [ ind ] = ans NEW_LINE return ans NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 10 , 30 , 40 , 50 , 20 ] NEW_LINE k = 3 NEW_LINE n = len ( a ) NEW_LINE dp = [ - 1 for i in range ( n ) ] NEW_LINE print ( FindMinimumCost ( 0 , a , n , k , dp ) ) NEW_LINE DEDENT"],"bleu":0.9680012845577204,"rouge_l":0.987114174408151}
{"id":650,"predictions":["def max ( x , y ) : NEW_LINE INDENT if ( x > y ) : NEW_LINE INDENT return x NEW_LINE DEDENT return y NEW_LINE DEDENT def longestPalindromic ( string , i , j , count ) : NEW_LINE INDENT if ( i > j ) : NEW_LINE INDENT return count NEW_LINE DEDENT if ( string [ i ] == string [ j ] ) : NEW_LINE INDENT count = longestPalindromic ( string , i + 1 , j - 1 , count + 2 ) NEW_LINE return max ( count , max ( longestPalindromic ( string , i + 1 , j , 0 ) , longestPalindromic ( string , i , j - 1 , 0 ) ) NEW_LINE DEDENT return max ( longestPalindromic ( string , i + 1 , j , 0 ) , longestPalindromic ( string , i , j - 1 , 0 ) ) NEW_LINE DEDENT def longest_palindromic ( string ) : NEW_LINE INDENT return longestPalindromic ( string , 0 , len ( string ) - 1 , 0 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" aaaabbaa \" NEW_LINE print ( longest_palindromic ( string ) ) NEW_LINE DEDENT"],"references":["def maxi ( x , y ) : NEW_LINE INDENT if x > y : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT return y NEW_LINE DEDENT DEDENT def longestPalindromic ( strn , i , j , count ) : NEW_LINE INDENT if i > j : NEW_LINE INDENT return count NEW_LINE DEDENT if i == j : NEW_LINE INDENT return ( count + 1 ) NEW_LINE DEDENT if strn [ i ] == strn [ j ] : NEW_LINE INDENT count = longestPalindromic ( strn , i + 1 , j - 1 , count + 2 ) NEW_LINE return maxi ( count , maxi ( longestPalindromic ( strn , i + 1 , j , 0 ) , longestPalindromic ( strn , i , j - 1 , 0 ) ) ) NEW_LINE DEDENT return maxi ( longestPalindromic ( strn , i + 1 , j , 0 ) , longestPalindromic ( strn , i , j - 1 , 0 ) ) NEW_LINE DEDENT def longest_palindromic_substr ( strn ) : NEW_LINE INDENT k = len ( strn ) - 1 NEW_LINE return longestPalindromic ( strn , 0 , k , 0 ) NEW_LINE DEDENT strn = \" aaaabbaa \" NEW_LINE print ( longest_palindromic_substr ( strn ) ) NEW_LINE"],"bleu":0.6055749573389592,"rouge_l":0.7821728318308984}
{"id":651,"predictions":["MAX_CHAR = 26 ; NEW_LINE def countPairs ( str ) : NEW_LINE INDENT result = 0 ; NEW_LINE n = len ( str ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT j = 1 ; NEW_LINE while ( ( i + j ) < n and j <= MAX_CHAR ) : NEW_LINE INDENT if ( abs ( ord ( str [ i + j ] ) - ord ( str [ i ] ) ) == j ) : NEW_LINE INDENT result = result + 1 ; NEW_LINE DEDENT j += 1 ; NEW_LINE DEDENT DEDENT return result ; NEW_LINE DEDENT str = \" geeksforgeeks \" ; NEW_LINE print ( countPairs ( str ) ) ; NEW_LINE"],"references":["MAX_CHAR = 26 NEW_LINE def countPairs ( str1 ) : NEW_LINE INDENT result = 0 ; NEW_LINE n = len ( str1 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 1 , MAX_CHAR + 1 ) : NEW_LINE INDENT if ( ( i + j ) < n ) : NEW_LINE INDENT if ( ( abs ( ord ( str1 [ i + j ] ) - ord ( str1 [ i ] ) ) == j ) ) : NEW_LINE INDENT result += 1 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" geeksforgeeks \" ; NEW_LINE print ( countPairs ( str1 ) ) NEW_LINE DEDENT"],"bleu":0.5382059342514794,"rouge_l":0.7480404551201012}
{"id":652,"predictions":["def countSetBits ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( n ) : NEW_LINE INDENT count += n & 1 ; NEW_LINE n >>= 1 ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT def countOfOddsPascal ( n ) : NEW_LINE INDENT c = bin ( n ) ; NEW_LINE return ( 2 ** c ) ; NEW_LINE DEDENT n = 20 ; NEW_LINE print ( countOfOddsPascal ( n ) ) ; NEW_LINE"],"references":["def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while n : NEW_LINE INDENT count += n & 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def countOfOddPascal ( n ) : NEW_LINE INDENT c = countSetBits ( n ) NEW_LINE return pow ( 2 , c ) NEW_LINE DEDENT n = 20 NEW_LINE print ( countOfOddPascal ( n ) ) NEW_LINE"],"bleu":0.520190955196862,"rouge_l":0.8788017379373428}
{"id":653,"predictions":["def rearrange ( arr , n ) : NEW_LINE INDENT i , j = - 1 , n NEW_LINE while ( i < j ) : NEW_LINE INDENT while ( arr [ i ] > 0 ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if ( i < j ) : NEW_LINE INDENT arr [ j ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( i == 0 or i == n ) : NEW_LINE INDENT return NEW_LINE DEDENT k = 0 NEW_LINE while ( k < n and i < n ) : NEW_LINE INDENT swap ( arr [ k ] , arr [ i ] ) NEW_LINE i = i + 1 NEW_LINE k = k + 2 NEW_LINE DEDENT DEDENT def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( \" \" ) NEW_LINE DEDENT arr = [ 2 , 3 , - 4 , - 1 , 6 , - 9 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Given ▁ array ▁ is \" ) NEW_LINE printArray ( arr , n ) NEW_LINE rearrange ( arr , n ) NEW_LINE print ( \" Rearranged ▁ array ▁ is \" ) NEW_LINE printArray ( arr , n ) NEW_LINE"],"references":["def rearrange ( arr , n ) : NEW_LINE INDENT i = 0 NEW_LINE j = n - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT while ( arr [ i ] > 0 ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT while ( arr [ j ] < 0 ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT if ( i < j ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE arr [ i ] = arr [ j ] NEW_LINE arr [ j ] = temp NEW_LINE DEDENT DEDENT if ( i == 0 or i == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT k = 0 NEW_LINE while ( k < n and i < n ) : NEW_LINE INDENT temp = arr [ k ] NEW_LINE arr [ k ] = arr [ i ] NEW_LINE arr [ i ] = temp NEW_LINE i = i + 1 NEW_LINE k = k + 2 NEW_LINE DEDENT DEDENT def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( \" \\n \" ) NEW_LINE DEDENT arr = [ 2 , 3 , - 4 , - 1 , 6 , - 9 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Given ▁ array ▁ is \" ) NEW_LINE printArray ( arr , n ) NEW_LINE rearrange ( arr , n ) NEW_LINE print ( \" Rearranged ▁ array ▁ is \" ) NEW_LINE printArray ( arr , n ) NEW_LINE"],"bleu":0.7810340458765508,"rouge_l":0.8726486881353869}
{"id":654,"predictions":["def countDivisibles ( A , B , M ) : NEW_LINE INDENT if ( A % M == 0 ) : NEW_LINE INDENT return ( B \/\/ M ) - ( A \/\/ M ) + 1 NEW_LINE DEDENT return ( B \/\/ M ) - ( A \/\/ M ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A , B , M = 30 , 30 , 30 NEW_LINE print ( countDivisibles ( A , B , M ) ) NEW_LINE DEDENT"],"references":["def countDivisibles ( A , B , M ) : NEW_LINE INDENT if ( A % M == 0 ) : NEW_LINE INDENT return ( ( B \/ M ) - ( A \/ M ) ) + 1 NEW_LINE DEDENT return ( ( B \/ M ) - ( A \/ M ) ) NEW_LINE DEDENT A = 30 NEW_LINE B = 70 NEW_LINE M = 10 NEW_LINE print ( countDivisibles ( A , B , M ) ) NEW_LINE"],"bleu":0.5908421072971648,"rouge_l":0.7755731073010979}
{"id":655,"predictions":["def findMissing ( arr , n ) : NEW_LINE INDENT l = 0 NEW_LINE h = n - 1 NEW_LINE while ( h > l ) : NEW_LINE INDENT mid = l + ( h - l ) \/\/ 2 NEW_LINE if ( arr [ mid ] - mid == arr [ 0 ] ) : NEW_LINE INDENT if ( arr [ mid + 1 ] - arr [ mid ] > 1 ) : NEW_LINE INDENT return arr [ mid ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( arr [ mid ] - arr [ mid - 1 ] > 1 ) : NEW_LINE INDENT return arr [ mid ] - 1 NEW_LINE DEDENT else : NEW_LINE INDENT h = mid - 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ - 9 , - 8 , - 7 , - 5 , - 4 , - 3 , - 2 , - 1 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMissing ( arr , n ) ) NEW_LINE"],"references":["def findMissing ( arr , n ) : NEW_LINE INDENT l , h = 0 , n - 1 NEW_LINE mid = 0 NEW_LINE while ( h > l ) : NEW_LINE INDENT mid = l + ( h - l ) \/\/ 2 NEW_LINE if ( arr [ mid ] - mid == arr [ 0 ] ) : NEW_LINE INDENT if ( arr [ mid + 1 ] - arr [ mid ] > 1 ) : NEW_LINE INDENT return arr [ mid ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( arr [ mid ] - arr [ mid - 1 ] > 1 ) : NEW_LINE INDENT return arr [ mid ] - 1 NEW_LINE DEDENT else : NEW_LINE INDENT h = mid - 1 NEW_LINE DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ - 9 , - 8 , - 7 , - 5 , - 4 , - 3 , - 2 , - 1 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMissing ( arr , n ) ) NEW_LINE"],"bleu":0.9477591761284747,"rouge_l":0.9697852505410355}
{"id":656,"predictions":["def maxSum ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( 0 , n - 1 , 2 ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT arr = [ 1 , 3 , 2 , 1 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxSum ( arr , n ) ) NEW_LINE"],"references":["def maxSum ( a , n ) : NEW_LINE INDENT a . sort ( ) ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( 0 , n - 1 , 2 ) : NEW_LINE INDENT sum += a [ i ] ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 3 , 2 , 1 , 4 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( maxSum ( arr , n ) ) ; NEW_LINE DEDENT"],"bleu":0.6607248828476582,"rouge_l":0.8672985781990522}
{"id":657,"predictions":["def trailing_zeros ( N ) : NEW_LINE INDENT count_of_two = 0 NEW_LINE count_of_five = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT val = i NEW_LINE while ( val % 2 == 0 and val > 0 ) : NEW_LINE INDENT val \/\/= 2 NEW_LINE count_of_two += i NEW_LINE DEDENT while ( val % 5 == 0 and val > 0 ) : NEW_LINE INDENT val \/\/= 5 NEW_LINE count_of_five += i NEW_LINE DEDENT DEDENT ans = min ( count_of_two , count_of_five ) NEW_LINE return ans NEW_LINE DEDENT N = 12 NEW_LINE print ( trailing_zero ( N ) ) NEW_LINE"],"references":["def trailing_zeros ( N ) : NEW_LINE INDENT count_of_two = 0 NEW_LINE count_of_five = 0 NEW_LINE for i in range ( 1 , N + 1 , 1 ) : NEW_LINE INDENT val = i NEW_LINE while ( val % 2 == 0 and val > 0 ) : NEW_LINE INDENT val \/= 2 NEW_LINE count_of_two += i NEW_LINE DEDENT while ( val % 5 == 0 and val > 0 ) : NEW_LINE INDENT val \/= 5 NEW_LINE count_of_five += i NEW_LINE DEDENT DEDENT ans = min ( count_of_two , count_of_five ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 12 NEW_LINE print ( trailing_zeros ( N ) ) NEW_LINE DEDENT"],"bleu":0.7824567031326988,"rouge_l":0.8940536013400336}
{"id":658,"predictions":["def sumOfSubstrings ( num ) : NEW_LINE INDENT n = len ( num ) ; NEW_LINE sumofdigit = [ 0 ] * n ; NEW_LINE sumofdigit [ 0 ] = num [ 0 ] - ord ( '0' ) ; NEW_LINE res = sumofdigit [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT numi = ord ( num [ i ] ) - ord ( '0' ) ; NEW_LINE sumofdigit [ i ] = ( i + 1 ) * numi + 10 * sumofdigit [ i - 1 ] ; NEW_LINE res += sumofdigit [ i ] ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT num = \"1234\" ; NEW_LINE print ( sumOfSubstrings ( num ) ) ; NEW_LINE DEDENT"],"references":["def sumOfSubstrings ( num ) : NEW_LINE INDENT n = len ( num ) NEW_LINE sumofdigit = [ ] NEW_LINE sumofdigit . append ( int ( num [ 0 ] ) ) NEW_LINE res = sumofdigit [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT numi = int ( num [ i ] ) NEW_LINE sumofdigit . append ( ( i + 1 ) * numi + 10 * sumofdigit [ i - 1 ] ) NEW_LINE res += sumofdigit [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT num = \"1234\" NEW_LINE print ( sumOfSubstrings ( num ) ) NEW_LINE"],"bleu":0.5260468484047702,"rouge_l":0.7955095455767679}
{"id":659,"predictions":["def sumOfDiv ( x ) : NEW_LINE INDENT sum = 1 NEW_LINE for i in range ( 2 , x ) : NEW_LINE INDENT if x % i == 0 : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT def isAmicable ( a ) : NEW_LINE INDENT if sumOfDiv ( a ) == b and sumOfDiv ( b ) == a ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def countPairs ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if sumOfDiv ( arr [ i ] in s ) : NEW_LINE INDENT sum = sumOfDiv ( arr [ i ] ) NEW_LINE if isAmicable ( arr [ i ] , sum ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count \/\/ 2 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr1 = [ 220 , 284 , 1184 , 1210 , 2 , 5 ] NEW_LINE n1 = len ( arr1 ) NEW_LINE print ( countPairs ( arr1 , n1 ) ) NEW_LINE arr2 = [ 2620 , 2924 , 5020 , 5564 , 6232 , 6368 , 6368 ] NEW_LINE n2 = len ( arr2 ) NEW_LINE print ( countPairs ( arr2 , n2 ) ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def sumOfDiv ( x ) : NEW_LINE INDENT sum = 1 ; NEW_LINE for i in range ( 2 , int ( math . sqrt ( x ) ) ) : NEW_LINE INDENT if x % i == 0 : NEW_LINE INDENT sum += i NEW_LINE if i != x \/ i : NEW_LINE INDENT sum += x \/ i NEW_LINE DEDENT DEDENT DEDENT return int ( sum ) ; NEW_LINE DEDENT def isAmbicle ( a , b ) : NEW_LINE INDENT return ( sumOfDiv ( a ) == b and sumOfDiv ( b ) == a ) NEW_LINE DEDENT def countPairs ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if sumOfDiv ( arr [ i ] ) in s : NEW_LINE INDENT sum = sumOfDiv ( arr [ i ] ) NEW_LINE if isAmbicle ( arr [ i ] , sum ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return int ( count \/ 2 ) ; NEW_LINE DEDENT arr1 = [ 220 , 284 , 1184 , 1210 , 2 , 5 ] NEW_LINE n1 = len ( arr1 ) NEW_LINE print ( countPairs ( arr1 , n1 ) ) NEW_LINE arr2 = [ 2620 , 2924 , 5020 , 5564 , 6232 , 6368 ] NEW_LINE n2 = len ( arr2 ) NEW_LINE print ( countPairs ( arr2 , n2 ) ) NEW_LINE"],"bleu":0.7733622586504767,"rouge_l":0.8503165327489652}
{"id":660,"predictions":["def grayNode ( n ) : NEW_LINE INDENT return n ^ ( n >> 1 ) NEW_LINE DEDENT n = 10 NEW_LINE print ( greenCode ( n ) ) NEW_LINE"],"references":["def grayCode ( n ) : NEW_LINE INDENT return n ^ ( n >> 1 ) NEW_LINE DEDENT n = 10 NEW_LINE print ( grayCode ( n ) ) NEW_LINE"],"bleu":0.852101976447847,"rouge_l":0.9333333333333336}
{"id":661,"predictions":["def printNonSquare ( n ) : NEW_LINE INDENT curr_count = 2 NEW_LINE num = 2 NEW_LINE count = 0 NEW_LINE while ( count < n ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i < curr_count and count < n ) : NEW_LINE INDENT print ( str ( num ) + \" ▁ \" , end = \" \" ) NEW_LINE count = num + 1 NEW_LINE DEDENT num = num + 1 NEW_LINE curr_count += 2 NEW_LINE DEDENT DEDENT n = 10 NEW_LINE printNonSquare ( n ) NEW_LINE"],"references":["import math NEW_LINE def printNonSquare ( n ) : NEW_LINE INDENT curr_count = 2 NEW_LINE num = 2 NEW_LINE count = 0 NEW_LINE while ( count < n ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i < curr_count and count < n ) : NEW_LINE INDENT print ( num , end = \" ▁ \" ) NEW_LINE count = count + 1 NEW_LINE num = num + 1 NEW_LINE i = i + 1 NEW_LINE DEDENT num = num + 1 NEW_LINE curr_count = curr_count + 2 NEW_LINE DEDENT DEDENT n = 10 NEW_LINE printNonSquare ( n ) NEW_LINE"],"bleu":0.7611024068573008,"rouge_l":0.8513536236758027}
{"id":662,"predictions":["def sortWithSetbits ( arr , n , k ) : NEW_LINE INDENT v1 = [ ] NEW_LINE v2 = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( bin ( arr [ i ] ) . count ( '1' ) == k ) : NEW_LINE INDENT v1 . append ( i ) NEW_LINE v2 . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT v2 . sort ( reverse = True ) NEW_LINE for i in range ( len ( v1 ) ) : NEW_LINE INDENT arr [ v1 [ i ] ] = v2 [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 14 , 255 , 1 , 7 , 13 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE sortWithSetbits ( arr , n , k ) NEW_LINE DEDENT"],"references":["def sortWithSetbits ( arr , n , k ) : NEW_LINE INDENT v1 = [ ] NEW_LINE v2 = [ ] NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( bin ( arr [ i ] ) . count ( '1' ) == k ) : NEW_LINE INDENT v1 . append ( i ) NEW_LINE v2 . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT v2 . sort ( reverse = False ) NEW_LINE for i in range ( 0 , len ( v1 ) , 1 ) : NEW_LINE INDENT arr [ v1 [ i ] ] = v2 [ i ] NEW_LINE DEDENT for i in range ( 0 , n , 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 14 , 255 , 1 , 7 , 13 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE sortWithSetbits ( arr , n , k ) NEW_LINE DEDENT"],"bleu":0.8566479531901857,"rouge_l":0.9463958859932015}
{"id":663,"predictions":["def isRotation ( x , y ) : NEW_LINE INDENT x64 = x | ( x << 32 ) NEW_LINE while ( x64 >= y ) : NEW_LINE INDENT if ( x64 == y ) : NEW_LINE INDENT return True NEW_LINE DEDENT x64 >>= 1 NEW_LINE DEDENT return False NEW_LINE DEDENT x = 122 NEW_LINE y = 2147483648 NEW_LINE if ( isRotation ( x , y ) == False ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def isRotation ( x , y ) : NEW_LINE INDENT x64 = x | ( x << 32 ) NEW_LINE while ( x64 >= y ) : NEW_LINE INDENT if ( ( x64 ) == y ) : NEW_LINE INDENT return True NEW_LINE DEDENT x64 >>= 1 NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = 122 NEW_LINE y = 2147483678 NEW_LINE if ( isRotation ( x , y ) == False ) : NEW_LINE INDENT print ( \" yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" no \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.739000136502301,"rouge_l":0.8785405664906386}
{"id":664,"predictions":["def findXorSum ( arr , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE mul = 1 ; NEW_LINE for i in range ( 30 ) : NEW_LINE INDENT c_odd = 0 ; NEW_LINE odd = False ; NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( ( arr [ j ] & ( 1 << i ) ) ) : NEW_LINE INDENT odd = ( not odd ) : NEW_LINE DEDENT if ( odd ) : NEW_LINE INDENT c_odd = c_odd + 1 NEW_LINE DEDENT DEDENT for j in range ( n ) : NEW_LINE INDENT sum += ( mul * c_odd ) NEW_LINE if ( ( arr [ j ] & ( 1 << i ) ) ) : NEW_LINE INDENT c_odd = ( n - j - c_odd ) ; NEW_LINE DEDENT DEDENT mul *= 2 ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 8 , 13 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( findXorSum ( arr , n ) ) ; NEW_LINE DEDENT"],"references":["def findXorSum ( arr , n ) : NEW_LINE INDENT Sum = 0 NEW_LINE mul = 1 NEW_LINE for i in range ( 30 ) : NEW_LINE INDENT c_odd = 0 NEW_LINE odd = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( ( arr [ j ] & ( 1 << i ) ) > 0 ) : NEW_LINE INDENT odd = ( ~ odd ) NEW_LINE DEDENT if ( odd ) : NEW_LINE INDENT c_odd += 1 NEW_LINE DEDENT DEDENT for j in range ( n ) : NEW_LINE INDENT Sum += ( mul * c_odd ) NEW_LINE if ( ( arr [ j ] & ( 1 << i ) ) > 0 ) : NEW_LINE INDENT c_odd = ( n - j - c_odd ) NEW_LINE DEDENT DEDENT mul *= 2 NEW_LINE DEDENT return Sum NEW_LINE DEDENT arr = [ 3 , 8 , 13 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findXorSum ( arr , n ) ) NEW_LINE"],"bleu":0.6936952788267793,"rouge_l":0.8935118619698058}
{"id":665,"predictions":["def calTime ( arr , n ) : NEW_LINE INDENT w = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT w += 1 \/ arr [ i ] NEW_LINE DEDENT return 1 \/ w NEW_LINE DEDENT arr = [ 6.0 , 3.0 , 4.0 ] NEW_LINE n = len ( arr ) NEW_LINE print ( calTime ( arr , n ) , \" Hours \" ) NEW_LINE"],"references":["def calTime ( arr , n ) : NEW_LINE INDENT work = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT work += 1 \/ arr [ i ] NEW_LINE DEDENT return 1 \/ work NEW_LINE DEDENT arr = [ 6.0 , 3.0 , 4.0 ] NEW_LINE n = len ( arr ) NEW_LINE print ( calTime ( arr , n ) , \" Hours \" ) NEW_LINE"],"bleu":0.8914711449549652,"rouge_l":0.9577464788732394}
{"id":666,"predictions":["def GetMinSubarrayLength ( a , n ) : NEW_LINE INDENT ans = max ( a [ 0 ] , a [ n - 1 ] ) NEW_LINE lo , hi = 0 , n - 1 NEW_LINE while ( lo < n and a [ lo ] % ans == 0 ) : NEW_LINE INDENT lo += 1 NEW_LINE DEDENT while ( hi > lo and a [ hi ] % ans == 0 ) : NEW_LINE INDENT hi -= 1 NEW_LINE DEDENT return ( hi - lo + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 8 , 2 , 1 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE Length = GetMinSubarrayLength ( arr , N ) NEW_LINE print ( Length ) NEW_LINE DEDENT"],"references":["def GetMinSubarrayLength ( a , n ) : NEW_LINE INDENT ans = max ( a [ 0 ] , a [ n - 1 ] ) NEW_LINE lo = 0 NEW_LINE hi = n - 1 NEW_LINE while ( lo < n and a [ lo ] % ans == 0 ) : NEW_LINE INDENT lo += 1 NEW_LINE DEDENT while ( hi > lo and a [ hi ] % ans == 0 ) : NEW_LINE INDENT hi -= 1 NEW_LINE DEDENT return ( hi - lo + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 8 , 2 , 1 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE length = GetMinSubarrayLength ( arr , N ) NEW_LINE print ( length ) NEW_LINE DEDENT"],"bleu":0.9267123074258636,"rouge_l":0.9647887323943662}
{"id":667,"predictions":["def maxSumBitonicSubArr ( arr , n ) : NEW_LINE INDENT mis = [ 0 for i in range ( n ) ] NEW_LINE msds = [ 0 for i in range ( n ) ] NEW_LINE max_sum = - 10 ** 9 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i - 1 ] ) : NEW_LINE INDENT mps [ i ] = mpp [ i - 1 ] + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT mps [ i ] = arr [ i ] NEW_LINE DEDENT DEDENT msds [ n - 1 ] = arr [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT max_sum = mds [ i ] + msds [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT msds [ i ] = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( max_sum < ( mds [ i ] + msds [ i ] - arr [ i ] ) ) : NEW_LINE INDENT max_sum = mcs [ i ] + msds [ i ] - arr [ i ] NEW_LINE DEDENT DEDENT return max_sum NEW_LINE DEDENT arr = [ 5 , 3 , 9 , 2 , 7 , 6 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Maximum ▁ Sum ▁ = \" , maxSumBitonicSubArr ( arr , n ) ) NEW_LINE"],"references":["def maxSumBitonicSubArr ( arr , n ) : NEW_LINE INDENT msis = [ None ] * n NEW_LINE msds = [ None ] * n NEW_LINE max_sum = 0 NEW_LINE msis [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i - 1 ] ) : NEW_LINE INDENT msis [ i ] = msis [ i - 1 ] + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT msis [ i ] = arr [ i ] NEW_LINE DEDENT DEDENT msds [ n - 1 ] = arr [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT msds [ i ] = msds [ i + 1 ] + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT msds [ i ] = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( max_sum < ( msis [ i ] + msds [ i ] - arr [ i ] ) ) : NEW_LINE INDENT max_sum = ( msis [ i ] + msds [ i ] - arr [ i ] ) NEW_LINE DEDENT DEDENT return max_sum NEW_LINE DEDENT arr = [ 5 , 3 , 9 , 2 , 7 , 6 , 4 ] ; NEW_LINE n = len ( arr ) NEW_LINE print ( \" Maximum ▁ Sum ▁ = ▁ \" + str ( maxSumBitonicSubArr ( arr , n ) ) ) NEW_LINE"],"bleu":0.7927141549343258,"rouge_l":0.8779465095194924}
{"id":668,"predictions":["def minimumDeletions ( s ) : NEW_LINE INDENT freqOfLetter = [ 0 ] * 26 NEW_LINE freq [ 0 ] = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( freqOfLetter [ i ] != 0 ) : NEW_LINE INDENT if ( freqOfLetter [ i ] ] == 0 ) : NEW_LINE INDENT LFreqMap [ freqOfLetter [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT LetterFreqMap [ freqOfLetterOfLetter [ i ] ] = 1 NEW_LINE DEDENT DEDENT DEDENT delete = 0 NEW_LINE set ( ) NEW_LINE for j in range ( 26 ) : NEW_LINE INDENT if ( freqOfLetter [ i ] > 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( freqOfLetter [ i ] > 1 ) : NEW_LINE INDENT leapFreqMap [ freqOfLetter [ i ] ] = LFreqMap [ j ] - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT delFreq [ freq [ freqOfLetter [ i ] ] = 1 NEW_LINE DEDENT DEDENT return deletions NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" geeksforgeeks \" NEW_LINE print ( minimumDeletions ( s ) ) NEW_LINE DEDENT"],"references":["def minimumDeletions ( s ) : NEW_LINE INDENT freqOfLetter = [ 0 ] * 26 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT freqOfLetter [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT LetterFreqMap = dict ( ) NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( freqOfLetter [ i ] != 0 ) : NEW_LINE INDENT LetterFreqMap [ freqOfLetter [ i ] ] =   \\ NEW_LINE LetterFreqMap . get ( freqOfLetter [ i ] , 0 ) + 1 NEW_LINE DEDENT DEDENT deletions = 0 NEW_LINE a = list ( LetterFreqMap . keys ( ) ) NEW_LINE a = a [ : : - 1 ] NEW_LINE a . sort ( ) NEW_LINE while len ( a ) > 0 : NEW_LINE INDENT it = a . pop ( ) NEW_LINE if ( it == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT while ( LetterFreqMap [ it ] > 1 ) : NEW_LINE INDENT deletions += 1 NEW_LINE LetterFreqMap [ it ] -= 1 NEW_LINE if ( it - 1 ) in LetterFreqMap . keys ( ) : NEW_LINE INDENT LetterFreqMap [ it - 1 ] += 1 NEW_LINE DEDENT elif ( it - 1 ) > 0 : NEW_LINE INDENT a . insert ( 0 , it - 1 ) NEW_LINE LetterFreqMap [ it - 1 ] = 1 NEW_LINE DEDENT DEDENT DEDENT return deletions NEW_LINE DEDENT s = \" geeksforgeeks \" NEW_LINE print ( minimumDeletions ( s ) ) NEW_LINE"],"bleu":0.5040677982964252,"rouge_l":0.5936932260576175}
{"id":669,"predictions":["import sys NEW_LINE def findMax ( arr , n ) : NEW_LINE INDENT maxFirst = - sys . maxsize - 2 ; NEW_LINE mid = int ( n \/ 2 ) ; NEW_LINE for i in range ( mid ) : NEW_LINE INDENT maxFirst = max ( maxFirst , arr [ i ] ) ; NEW_LINE DEDENT if ( n % 2 == 1 ) : NEW_LINE INDENT maxFirst = max ( maxFirst , arr [ mid ] ) ; NEW_LINE DEDENT maxSecond = - sys . maxsize ; NEW_LINE for i in range ( mid , n ) : NEW_LINE INDENT maxSecond = max ( maxSecond , arr [ i ] ) ; NEW_LINE DEDENT print ( maxFirst , \" , ▁ \" , maxSecond ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 12 , 14 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE findMax ( arr , n ) ; NEW_LINE DEDENT"],"references":["import sys NEW_LINE def findMax ( arr , n ) : NEW_LINE INDENT maxFirst = - sys . maxsize - 1 NEW_LINE mid = n \/\/ 2 ; NEW_LINE for i in range ( 0 , mid ) : NEW_LINE INDENT maxFirst = max ( maxFirst , arr [ i ] ) NEW_LINE DEDENT if ( n % 2 == 1 ) : NEW_LINE INDENT maxFirst = max ( maxFirst , arr [ mid ] ) NEW_LINE DEDENT maxSecond = - sys . maxsize - 1 NEW_LINE for i in range ( mid , n ) : NEW_LINE INDENT maxSecond = max ( maxSecond , arr [ i ] ) NEW_LINE DEDENT print ( maxFirst , \" , \" , maxSecond ) NEW_LINE DEDENT arr = [ 1 , 12 , 14 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE findMax ( arr , n ) NEW_LINE"],"bleu":0.7134321258416219,"rouge_l":0.9032390745501283}
{"id":670,"predictions":["def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b ; NEW_LINE DEDENT return gcd ( b % a , a ) ; NEW_LINE DEDENT def lcm ( a , b ) : NEW_LINE INDENT return ( a * b ) \/ gcd ( a , b ) ; NEW_LINE DEDENT def printSum ( num1 , den1 , num2 , den2 ) : NEW_LINE INDENT lcd = lcm ( den1 , den2 ) ; NEW_LINE num1 *= ( lcd \/ den1 ) ; NEW_LINE num2 = num1 + num2 ; NEW_LINE print ( res_num , lcd ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT num1 = 1 ; den1 = 6 ; NEW_LINE num2 = 7 ; den2 = 15 ; NEW_LINE printSum ( num1 , den1 , num2 , den2 ) ; NEW_LINE DEDENT"],"references":["def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def lcm ( a , b ) : NEW_LINE INDENT return ( a * b ) \/ gcd ( a , b ) NEW_LINE DEDENT def printSum ( num1 , den1 , num2 , den2 ) : NEW_LINE INDENT lcd = lcm ( den1 , den2 ) ; NEW_LINE num1 *= ( lcd \/ den1 ) NEW_LINE num2 *= ( lcd \/ den2 ) NEW_LINE res_num = num1 + num2 ; NEW_LINE print ( int ( res_num ) , \" \/ \" , int ( lcd ) ) NEW_LINE DEDENT num1 = 1 NEW_LINE den1 = 6 NEW_LINE num2 = 7 NEW_LINE den2 = 15 NEW_LINE printSum ( num1 , den1 , num2 , den2 ) ; NEW_LINE"],"bleu":0.7268989708578611,"rouge_l":0.8614528725794371}
{"id":671,"predictions":["def maxProduct ( arr , n , p ) : NEW_LINE INDENT minVal = arr [ 0 ] NEW_LINE maxVal = arr [ 0 ] NEW_LINE maxProduct = arr [ 0 ] NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT temp = maxVal NEW_LINE maxVal = minVal NEW_LINE minVal = temp NEW_LINE DEDENT maxVal = max ( arr [ i ] , maxVal * arr [ i ] ) NEW_LINE minVal = min ( arr [ i ] , minVal * arr [ i ] ) NEW_LINE if ( minVal == p or maxVal == p ) : NEW_LINE INDENT return True NEW_LINE DEDENT maxProduct = max ( maxProduct , maxVal ) NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , - 5 , - 4 ] NEW_LINE product = - 10 NEW_LINE n = len ( arr ) NEW_LINE if ( maxProduct ( arr , n , product ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"references":["def maxProduct ( arr , n , p ) : NEW_LINE INDENT minVal = arr [ 0 ] NEW_LINE maxVal = arr [ 0 ] NEW_LINE maxProduct = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT maxVal , minVal = minVal , maxVal NEW_LINE DEDENT maxVal = max ( arr [ i ] , maxVal * arr [ i ] ) NEW_LINE minVal = min ( arr [ i ] , minVal * arr [ i ] ) NEW_LINE if ( minVal == p or maxVal == p ) : NEW_LINE INDENT return True NEW_LINE DEDENT maxProduct = max ( maxProduct , maxVal ) NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , - 5 , - 4 ] NEW_LINE product = - 10 NEW_LINE n = len ( arr ) NEW_LINE if ( maxProduct ( arr , n , product ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.9101541144032351,"rouge_l":0.9592256025286447}
{"id":672,"predictions":["import math NEW_LINE def solve ( M , N , s ) : NEW_LINE INDENT ans = ( ( math . ceil ( M \/\/ s ) ) * ( math . ceil ( N \/ s ) ) ) ; NEW_LINE return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N , M , 13 , 4 ; NEW_LINE print ( solve ( M , N , s ) ) ; NEW_LINE DEDENT"],"references":["import math NEW_LINE def solve ( M , N , s ) : NEW_LINE INDENT ans = ( ( math . ceil ( M \/ s ) ) * ( math . ceil ( N \/ s ) ) ) ; NEW_LINE return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 12 NEW_LINE M = 13 NEW_LINE s = 4 NEW_LINE print ( solve ( M , N , s ) ) NEW_LINE DEDENT"],"bleu":0.8049543172697642,"rouge_l":0.909197881937635}
{"id":673,"predictions":["def ifExists ( arr , n ) : NEW_LINE INDENT Sum = [ None ] * n NEW_LINE arr [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT Sum [ i ] = Sum [ i - 1 ] + arr [ i ] NEW_LINE DEDENT max = arr [ n - 1 ] NEW_LINE flag = False NEW_LINE for i in range ( 1 , max + 1 ) : NEW_LINE INDENT findEx = 0 NEW_LINE lindex = 0 NEW_LINE l = 0 NEW_LINE r = n - 1 NEW_LINE while ( l <= r ) : NEW_LINE INDENT m = ( l + r ) \/\/ 2 NEW_LINE if ( arr [ m ] < i ) : NEW_LINE INDENT findex = m NEW_LINE l = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = m - 1 NEW_LINE DEDENT DEDENT l = 1 NEW_LINE r = n NEW_LINE flag = False NEW_LINE while ( l <= r ) : NEW_LINE INDENT m = ( r + l ) \/\/ 2 NEW_LINE if ( arr [ m ] > i ) : NEW_LINE INDENT lindex = m NEW_LINE r = m - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT if ( sum [ findex ] == sum [ n - 1 ] - sum [ lindex - 1 ] ) : NEW_LINE INDENT flag = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 2 , 2 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE if ( flagExists ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT"],"references":["def IfExists ( arr , n ) : NEW_LINE INDENT sum = [ 0 ] * n ; NEW_LINE arr . sort ( ) ; NEW_LINE sum [ 0 ] = arr [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT sum [ i ] = sum [ i - 1 ] + arr [ i ] ; NEW_LINE DEDENT max = arr [ n - 1 ] ; NEW_LINE flag = False ; NEW_LINE for i in range ( 1 , max + 1 ) : NEW_LINE INDENT findex = 0 ; NEW_LINE lindex = 0 ; NEW_LINE l = 0 ; NEW_LINE r = n - 1 ; NEW_LINE while ( l <= r ) : NEW_LINE INDENT m = ( l + r ) \/\/ 2 ; NEW_LINE if ( arr [ m ] < i ) : NEW_LINE INDENT findex = m ; NEW_LINE l = m + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT r = m - 1 ; NEW_LINE DEDENT DEDENT l = 1 ; NEW_LINE r = n ; NEW_LINE flag = False ; NEW_LINE while ( l <= r ) : NEW_LINE INDENT m = ( r + l ) \/\/ 2 ; NEW_LINE if ( arr [ m ] > i ) : NEW_LINE INDENT lindex = m ; NEW_LINE r = m - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 ; NEW_LINE DEDENT DEDENT if ( sum [ findex ] == sum [ n - 1 ] - sum [ lindex - 1 ] ) : NEW_LINE INDENT flag = True ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 2 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE IfExists ( arr , n ) ; NEW_LINE DEDENT"],"bleu":0.6999195955895253,"rouge_l":0.8821592210767468}
{"id":674,"predictions":["def sumOfTheSeries ( n ) : NEW_LINE INDENT return int ( n \/ ( n + 1 ) ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE print ( sumOfTheSeries ( n ) ) ; NEW_LINE DEDENT"],"references":["def sumOfTheSeries ( n ) : NEW_LINE INDENT return ( float ( n ) \/ ( n + 1 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE ans = sumOfTheSeries ( n ) NEW_LINE print ( round ( ans , 6 ) ) NEW_LINE DEDENT"],"bleu":0.6269656569756352,"rouge_l":0.8101418653788108}
{"id":675,"predictions":["def printClosest ( arr , n , x ) : NEW_LINE INDENT res_l = 0 NEW_LINE res_r = 0 NEW_LINE l = 0 NEW_LINE r = n - 1 NEW_LINE diff = INT_LINE while ( r > l ) : NEW_LINE INDENT if ( abs ( arr [ l ] + arr [ r ] - x ) < diff ) : NEW_LINE INDENT res_l = l NEW_LINE res_r = r NEW_LINE diff = abs ( arr [ l ] + x ) NEW_LINE DEDENT if ( arr [ l ] + arr [ r ] > x ) : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT l += 1 NEW_LINE DEDENT DEDENT print ( \" The ▁ closest ▁ pair ▁ is \" , arr [ res_l ] , \" and \" , arr [ res_r ] ) NEW_LINE DEDENT arr = [ 10 , 22 , 28 , 29 , 30 , 40 ] NEW_LINE x = 54 NEW_LINE n = len ( arr ) NEW_LINE printClosest ( arr , n , x ) NEW_LINE"],"references":["MAX_VAL = 1000000000 NEW_LINE def printClosest ( arr , n , x ) : NEW_LINE INDENT res_l , res_r = 0 , 0 NEW_LINE l , r , diff = 0 , n - 1 , MAX_VAL NEW_LINE while r > l : NEW_LINE INDENT if abs ( arr [ l ] + arr [ r ] - x ) < diff : NEW_LINE INDENT res_l = l NEW_LINE res_r = r NEW_LINE diff = abs ( arr [ l ] + arr [ r ] - x ) NEW_LINE DEDENT if arr [ l ] + arr [ r ] > x : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT l += 1 NEW_LINE DEDENT DEDENT print ( ' The ▁ closest ▁ pair ▁ is ▁ { } ▁ and ▁ { } ' . format ( arr [ res_l ] , arr [ res_r ] ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 10 , 22 , 28 , 29 , 30 , 40 ] NEW_LINE n = len ( arr ) NEW_LINE x = 54 NEW_LINE printClosest ( arr , n , x ) NEW_LINE DEDENT"],"bleu":0.6511338411026925,"rouge_l":0.7918097311782932}
{"id":676,"predictions":["def binomialCoeff ( n , k ) : NEW_LINE INDENT res = 1 ; NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k ; NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT res *= ( n - i ) ; NEW_LINE res \/= ( i + 1 ) ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT def power ( x , y ) : NEW_LINE INDENT res = 1 ; NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = res * x ; NEW_LINE DEDENT y = y >> 1 ; NEW_LINE x = x * x ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a ; NEW_LINE DEDENT return gcd ( b , a % b ) ; NEW_LINE DEDENT def FindProbability ( n ) : NEW_LINE INDENT up = binomialCoeff ( 2 * n , n ) ; NEW_LINE down = power ( 2 , 2 * n ) ; NEW_LINE g = gcd ( up , down ) ; NEW_LINE down \/\/= g ; NEW_LINE print ( up , \" \/ \" , down ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 8 ; NEW_LINE FindProbability ( N ) ; NEW_LINE DEDENT"],"references":["import math NEW_LINE def binomialCoeff ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k NEW_LINE DEDENT for i in range ( 0 , k ) : NEW_LINE INDENT res = res * ( n - i ) NEW_LINE res = res \/\/ ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT def power ( x , y ) : NEW_LINE INDENT res = 1 NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = res * x NEW_LINE DEDENT y = y \/\/ 2 NEW_LINE x = x * x NEW_LINE DEDENT return res NEW_LINE DEDENT def FindProbability ( n ) : NEW_LINE INDENT up = binomialCoeff ( 2 * n , n ) NEW_LINE down = power ( 2 , 2 * n ) NEW_LINE g = math . gcd ( up , down ) NEW_LINE up = up \/\/ g NEW_LINE down = down \/\/ g NEW_LINE print ( up , \" \/ \" , down ) NEW_LINE DEDENT N = 8 NEW_LINE FindProbability ( N ) NEW_LINE"],"bleu":0.5771897771689894,"rouge_l":0.8029877237095104}
{"id":677,"predictions":["class Node : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . key = key NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def inorder ( root ) : NEW_LINE INDENT if root : NEW_LINE INDENT inorder ( root . left ) NEW_LINE print ( root . key , end = \" ▁ \" ) NEW_LINE inorder ( root . right ) NEW_LINE DEDENT DEDENT def createTree ( parent , n ) : NEW_LINE INDENT m = { } NEW_LINE temp = Node ( 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i not inorder : NEW_LINE INDENT temp = Node ( i ) NEW_LINE m [ i ] = temp NEW_LINE DEDENT if ( parent [ i ] == - 1 ) : NEW_LINE INDENT root = m [ i ] NEW_LINE DEDENT elif ( parent [ parent [ i ] ] == - 1 ) : NEW_LINE INDENT m [ parent [ i ] ] = m [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT m [ parent [ i ] = m [ i ] NEW_LINE DEDENT DEDENT return root NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT parent = [ - 1 , 0 , 0 , 1 , 1 , 3 , 5 ] NEW_LINE n = len ( parent ) NEW_LINE root = createTree ( parent , n ) NEW_LINE print ( \" Inorder ▁ Traversal ▁ of ▁ coned ▁ tree \" ) NEW_LINE inorder ( root ) NEW_LINE DEDENT"],"references":["class Node : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . key = 0 NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def newNode ( key : int ) -> Node : NEW_LINE INDENT temp = Node ( ) NEW_LINE temp . key = key NEW_LINE temp . left = None NEW_LINE temp . right = None NEW_LINE return temp NEW_LINE DEDENT def inorder ( root : Node ) : NEW_LINE INDENT if root is not None : NEW_LINE INDENT inorder ( root . left ) NEW_LINE print ( root . key , end = \" ▁ \" ) NEW_LINE inorder ( root . right ) NEW_LINE DEDENT DEDENT def createTree ( parent : list , n : int ) -> Node : NEW_LINE INDENT m = dict ( ) NEW_LINE root = Node ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i not in m : NEW_LINE INDENT temp = newNode ( i ) NEW_LINE m [ i ] = temp NEW_LINE DEDENT if parent [ i ] == - 1 : NEW_LINE INDENT root = m [ i ] NEW_LINE DEDENT elif parent [ i ] not in m : NEW_LINE INDENT temp = newNode ( parent [ i ] ) NEW_LINE temp . left = m [ i ] NEW_LINE m [ parent [ i ] ] = temp NEW_LINE DEDENT else : NEW_LINE INDENT if m [ parent [ i ] ] . left is None : NEW_LINE INDENT m [ parent [ i ] ] . left = m [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT m [ parent [ i ] ] . right = m [ i ] NEW_LINE DEDENT DEDENT DEDENT return root NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT parent = [ - 1 , 0 , 0 , 1 , 1 , 3 , 5 ] NEW_LINE n = len ( parent ) NEW_LINE root = createTree ( parent , n ) NEW_LINE print ( \" Inorder ▁ Traversal ▁ of ▁ constructed ▁ tree \" ) NEW_LINE inorder ( root ) NEW_LINE DEDENT"],"bleu":0.6000552244600911,"rouge_l":0.7768197809821118}
{"id":678,"predictions":["def findExtra ( arr1 , arr2 , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr1 [ i ] != arr2 [ i ] ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT arr1 = [ 2 , 4 , 6 , 8 , 10 , 12 , 13 ] NEW_LINE arr2 = [ 2 , 4 , 6 , 8 , 10 , 12 ] NEW_LINE n = len ( arr2 ) NEW_LINE print ( findExtra ( arr1 , arr2 , n ) ) NEW_LINE"],"references":["def findExtra ( arr1 , arr2 , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr1 [ i ] != arr2 [ i ] ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT arr1 = [ 2 , 4 , 6 , 8 , 10 , 12 , 13 ] NEW_LINE arr2 = [ 2 , 4 , 6 , 8 , 10 , 12 ] NEW_LINE n = len ( arr2 ) NEW_LINE print ( findExtra ( arr1 , arr2 , n ) ) NEW_LINE"],"bleu":0.9648824640944856,"rouge_l":0.9882179675994109}
{"id":679,"predictions":["def CountPairs ( n ) : NEW_LINE INDENT k = n ; NEW_LINE imin = 1 ; NEW_LINE ans = 0 ; NEW_LINE while ( imin <= n ) : NEW_LINE INDENT smax = n \/\/ k ; NEW_LINE ans += k * ( imax - imin + 1 ) ; NEW_LINE imin = imax + 1 ; NEW_LINE k = n \/\/ imin ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( CountPairs ( 1 ) ) ; NEW_LINE print ( CountPairs ( 2 ) ) ; NEW_LINE print ( CountPairs ( 3 ) ) ; NEW_LINE DEDENT"],"references":["def CountPairs ( n ) : NEW_LINE INDENT k = n NEW_LINE imin = 1 NEW_LINE ans = 0 NEW_LINE while ( imin <= n ) : NEW_LINE INDENT imax = n \/ k NEW_LINE ans += k * ( imax - imin + 1 ) NEW_LINE imin = imax + 1 NEW_LINE k = n \/ imin NEW_LINE DEDENT return ans NEW_LINE DEDENT print ( CountPairs ( 1 ) ) NEW_LINE print ( CountPairs ( 2 ) ) NEW_LINE print ( CountPairs ( 3 ) ) NEW_LINE"],"bleu":0.560307222391408,"rouge_l":0.8651760387118305}
{"id":680,"predictions":["def find3Numbers ( arr , n ) : NEW_LINE INDENT small = + 2147483647 NEW_LINE large = + 2147483647 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if ( arr [ i ] <= small ) : NEW_LINE INDENT small = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] <= large ) : NEW_LINE INDENT small = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( i == n ) : NEW_LINE INDENT print ( \" No ▁ such ▁ triplet ▁ found \" ) NEW_LINE return NEW_LINE DEDENT for j in range ( i + 1 ) : NEW_LINE INDENT if ( arr [ j ] < large ) : NEW_LINE INDENT small = arr [ j ] NEW_LINE break NEW_LINE DEDENT DEDENT print ( small , \" ▁ \" , large , \" ▁ \" , arr [ i ] ) NEW_LINE return NEW_LINE DEDENT arr = [ 5 , 7 , 4 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE find3Numbers ( arr , n ) NEW_LINE"],"references":["def find3Numbers ( arr , n ) : NEW_LINE INDENT small = + 2147483647 NEW_LINE large = + 2147483647 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] <= small ) : NEW_LINE INDENT small = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] <= large ) : NEW_LINE INDENT large = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( i == n ) : NEW_LINE INDENT print ( \" No ▁ such ▁ triplet ▁ found \" ) NEW_LINE return NEW_LINE DEDENT for j in range ( i + 1 ) : NEW_LINE INDENT if ( arr [ j ] < large ) : NEW_LINE INDENT small = arr [ j ] NEW_LINE break NEW_LINE DEDENT DEDENT print ( small , \" ▁ \" , large , \" ▁ \" , arr [ i ] ) NEW_LINE return NEW_LINE DEDENT arr = [ 5 , 7 , 4 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE find3Numbers ( arr , n ) NEW_LINE"],"bleu":0.9384344712279766,"rouge_l":0.9657977606717983}
{"id":681,"predictions":["def countCharacterType ( str ) : NEW_LINE INDENT vowels = 0 NEW_LINE consonant = 0 NEW_LINE digit = 0 NEW_LINE digit = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT ch = str [ i ] NEW_LINE if ( ( ch >= ord ( ' a ' ) and ch <= ord ( ' z ' ) ) or ( ch >= ord ( ' A ' ) and ord ( ch <= ord ( ' A ' ) ) ) ) : NEW_LINE INDENT ch = chr ( ch ) NEW_LINE if ( ( ch == ' a ' or ch == ' i ' or ch == ' o ' or ch == ' o ' ) : NEW_LINE INDENT vowels += 1 NEW_LINE DEDENT else : NEW_LINE INDENT consonant += 1 NEW_LINE DEDENT DEDENT elif ( ch >= ord ( ch ) and ch <= ord ( '9' ) ) : NEW_LINE INDENT digit += 1 NEW_LINE DEDENT else : NEW_LINE INDENT consonant += 1 NEW_LINE DEDENT DEDENT print ( \" Vowels : ▁ \" , vowels ) ; NEW_LINE print ( \" Consonant : ▁ \" , consonant ) ; NEW_LINE print ( \" Digit : ▁ \" , chr ( ch ) ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeks ▁ for ▁ geeks \" ) ; NEW_LINE countCharacterType ( str ) ; NEW_LINE DEDENT"],"references":["def countCharacterType ( str ) : NEW_LINE INDENT vowels = 0 NEW_LINE consonant = 0 NEW_LINE specialChar = 0 NEW_LINE digit = 0 NEW_LINE for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT ch = str [ i ] NEW_LINE if ( ( ch >= ' a ' and ch <= ' z ' ) or ( ch >= ' A ' and ch <= ' Z ' ) ) : NEW_LINE INDENT ch = ch . lower ( ) NEW_LINE if ( ch == ' a ' or ch == ' e ' or ch == ' i ' or ch == ' o ' or ch == ' u ' ) : NEW_LINE INDENT vowels += 1 NEW_LINE DEDENT else : NEW_LINE INDENT consonant += 1 NEW_LINE DEDENT DEDENT elif ( ch >= '0' and ch <= '9' ) : NEW_LINE INDENT digit += 1 NEW_LINE DEDENT else : NEW_LINE INDENT specialChar += 1 NEW_LINE DEDENT DEDENT print ( \" Vowels : \" , vowels ) NEW_LINE print ( \" Consonant : \" , consonant ) NEW_LINE print ( \" Digit : \" , digit ) NEW_LINE print ( \" Special ▁ Character : \" , specialChar ) NEW_LINE DEDENT str = \" geeks ▁ for ▁ geeks121\" NEW_LINE countCharacterType ( str ) NEW_LINE"],"bleu":0.6188136612745826,"rouge_l":0.8309226232270748}
{"id":682,"predictions":["def calculateSum ( n ) : NEW_LINE INDENT return 2 * ( n * ( n + 1 ) * ( 2 * n + 1 ) \/\/ 6 ) + n * ( n + 1 ) NEW_LINE DEDENT n = 3 NEW_LINE print ( \" Sum ▁ = ▁ \" , calculateSum ( n ) ) NEW_LINE"],"references":["def calculateSum ( n ) : NEW_LINE INDENT return ( 2 * ( n * ( n + 1 ) * ( 2 * n + 1 ) \/\/ 6 ) + n * ( n + 1 ) \/\/ 2 + 2 * ( n ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE print ( \" Sum ▁ = \" , calculateSum ( n ) ) NEW_LINE DEDENT"],"bleu":0.601826820578075,"rouge_l":0.7991868082222723}
{"id":683,"predictions":["def countPairs ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] * arr [ j ] > arr [ i ] + arr [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 5 , 0 , 3 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE DEDENT"],"references":["import math as mt NEW_LINE def countPairs ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] * arr [ j ] > arr [ i ] + arr [ j ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 5 , 0 , 3 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE"],"bleu":0.8014330282160076,"rouge_l":0.9088673513669897}
{"id":684,"predictions":["PI = 3.14159 \/ 180.0 NEW_LINE def areaOfKite ( a , b , angle ) : NEW_LINE INDENT angle = angle * PI NEW_LINE area = a * b * sin ( angle ) NEW_LINE return area NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 4 NEW_LINE b = 7 NEW_LINE angle = 78 NEW_LINE print ( \" Area ▁ of ▁ Kite ▁ = \" , areaOfKite ( a , b , angle ) ) NEW_LINE DEDENT"],"references":["import math NEW_LINE PI = 3.14159 \/ 180 ; NEW_LINE def areaOfKite ( a , b , angle ) : NEW_LINE INDENT angle = angle * PI ; NEW_LINE area = a * b * math . sin ( angle ) ; NEW_LINE return area ; NEW_LINE DEDENT a = 4 ; b = 7 ; angle = 78 ; NEW_LINE print ( \" Area ▁ of ▁ Kite ▁ = ▁ \" , areaOfKite ( a , b , angle ) ) ; NEW_LINE"],"bleu":0.6099897116648932,"rouge_l":0.8156638013371538}
{"id":685,"predictions":["def totalCount number =93 NEW_LINE length = len ( arr ) NEW_LINE totalCount = 0 NEW_LINE for i in range ( 0 , length - 1 ) : NEW_LINE INDENT if ( target % arr [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i + 1 , length - 1 ) : NEW_LINE INDENT if ( target % ( arr [ i ] * arr [ j ] ) == 0 ) : NEW_LINE INDENT toFind = target \/\/ ( arr [ i ] * arr [ j ] ) NEW_LINE for k in range ( j + 1 , length ) : NEW_LINE INDENT if ( arr [ k ] == toFind ) : NEW_LINE INDENT totalCount = totalCount + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT print ( \" Total ▁ number ▁ of ▁ triplets ▁ found ▁ found \" , totalCount ) NEW_LINE"],"references":["target = 93 NEW_LINE arr = [ 1 , 31 , 3 , 1 , 93 , 3 , 31 , 1 , 93 ] NEW_LINE length = len ( arr ) NEW_LINE totalCount = 0 NEW_LINE for i in range ( length - 2 ) : NEW_LINE INDENT if target % arr [ i ] == 0 : NEW_LINE INDENT for j in range ( i + 1 , length - 1 ) : NEW_LINE INDENT if target % ( arr [ i ] * arr [ j ] ) == 0 : NEW_LINE INDENT toFind = target \/\/ ( arr [ i ] * arr [ j ] ) NEW_LINE for k in range ( j + 1 , length ) : NEW_LINE INDENT if arr [ k ] == toFind : NEW_LINE INDENT totalCount += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT print ( ' Total ▁ number ▁ of ▁ triplets ▁ found : ▁ ' , totalCount ) NEW_LINE"],"bleu":0.7054986956924182,"rouge_l":0.8370711725550436}
{"id":686,"predictions":["def checkSpecialPrime ( sieve , num ) : NEW_LINE INDENT while ( num ) : NEW_LINE INDENT if ( sieve [ num ] == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT num = int ( num \/ 10 ) NEW_LINE DEDENT return True NEW_LINE DEDENT def findSpecialPrime ( N ) : NEW_LINE INDENT sieve = [ True for i in range ( N + 10 ) ] NEW_LINE sieve [ 0 ] = False NEW_LINE sieve [ 1 ] = False NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT sieve [ i ] = True NEW_LINE DEDENT for i in range ( 2 , N + 1 ) : NEW_LINE INDENT if ( sieve [ i ] ) : NEW_LINE INDENT for j in range ( i * i , N + 1 , i ) : NEW_LINE INDENT sieve [ j ] = False NEW_LINE DEDENT DEDENT DEDENT while ( True ) : NEW_LINE INDENT if ( checkSpecialPrime ( sieve , N ) ) : NEW_LINE INDENT print ( N ) NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT N -= 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ main _ _ ' : NEW_LINE INDENT findSpecialPrime ( 379 ) NEW_LINE findSpecialPrime ( 100 ) NEW_LINE DEDENT"],"references":["def checkSpecialPrime ( sieve , num ) : NEW_LINE INDENT while ( num ) : NEW_LINE INDENT if ( not sieve [ num ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT num \/\/= 10 NEW_LINE DEDENT return True NEW_LINE DEDENT def findSpecialPrime ( N ) : NEW_LINE INDENT sieve = [ True ] * ( N + 10 ) NEW_LINE sieve [ 0 ] = sieve [ 1 ] = False ; NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT if ( sieve [ i ] ) : NEW_LINE INDENT for j in range ( i * i , N + 1 , i ) : NEW_LINE INDENT sieve [ j ] = False NEW_LINE DEDENT DEDENT DEDENT while ( True ) : NEW_LINE INDENT if ( checkSpecialPrime ( sieve , N ) ) : NEW_LINE INDENT print ( N ) NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT N -= 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT findSpecialPrime ( 379 ) NEW_LINE findSpecialPrime ( 100 ) NEW_LINE DEDENT"],"bleu":0.7577926743358839,"rouge_l":0.8968390100465572}
{"id":687,"predictions":["MAX = 1000005 NEW_LINE fibUpto = [ 0 ] * ( MAX + 1 ) NEW_LINE def compute ( sz ) : NEW_LINE INDENT isFib = [ False ] * ( MAX + 1 ) NEW_LINE prev = 0 NEW_LINE curr = 1 NEW_LINE isFib [ curr ] = True NEW_LINE isFib [ curr ] = True NEW_LINE while ( curr <= sz ) : NEW_LINE INDENT temp = curr + prev NEW_LINE if ( temp <= sz ) : NEW_LINE INDENT isFib [ temp ] = True NEW_LINE DEDENT prev = curr NEW_LINE curr = temp NEW_LINE DEDENT fibUpto [ 0 ] = 1 NEW_LINE for i in range ( 1 , sz + 1 ) : NEW_LINE INDENT fibUpto [ i ] = fibUpt [ i - 1 ] NEW_LINE if ( isFib [ i ] ) : NEW_LINE INDENT fibUpt [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT def countOfNumbers ( N , K ) : NEW_LINE INDENT compute ( N ) NEW_LINE low = 1 NEW_LINE high = N NEW_LINE ans = 0 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) >> 1 NEW_LINE if ( mid - fibUpt [ mid ] >= K ) : NEW_LINE INDENT ans = mid NEW_LINE high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 10 NEW_LINE K = 3 NEW_LINE print ( countOfNumbers ( N , K ) ) NEW_LINE DEDENT"],"references":["MAX = 1000005 NEW_LINE fibUpto = [ 0 ] * ( MAX + 1 ) NEW_LINE def compute ( sz ) : NEW_LINE INDENT isFib = [ False ] * ( sz + 1 ) NEW_LINE prev = 0 NEW_LINE curr = 1 NEW_LINE isFib [ prev ] = True NEW_LINE isFib [ curr ] = True NEW_LINE while ( curr <= sz ) : NEW_LINE INDENT temp = curr + prev NEW_LINE if ( temp <= sz ) : NEW_LINE INDENT isFib [ temp ] = True NEW_LINE DEDENT prev = curr NEW_LINE curr = temp NEW_LINE DEDENT fibUpto [ 0 ] = 1 NEW_LINE for i in range ( 1 , sz + 1 ) : NEW_LINE INDENT fibUpto [ i ] = fibUpto [ i - 1 ] NEW_LINE if ( isFib [ i ] ) : NEW_LINE INDENT fibUpto [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT def countOfNumbers ( N , K ) : NEW_LINE INDENT compute ( N ) NEW_LINE low , high , ans = 1 , N , 0 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) >> 1 NEW_LINE if ( mid - fibUpto [ mid ] >= K ) : NEW_LINE INDENT ans = mid NEW_LINE high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT if ( ans ) : NEW_LINE INDENT return ( N - ans + 1 ) NEW_LINE DEDENT return 0 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 10 NEW_LINE K = 3 NEW_LINE print ( countOfNumbers ( N , K ) ) NEW_LINE DEDENT"],"bleu":0.8565398645783316,"rouge_l":0.9251589570086916}
{"id":688,"predictions":["def setBitNumber ( n ) : NEW_LINE INDENT n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n + 1 NEW_LINE n = n + 1 NEW_LINE return ( n >> 1 ) NEW_LINE DEDENT n = 273 NEW_LINE print ( setBitNumber ( n ) ) NEW_LINE"],"references":["def setBitNumber ( n ) : NEW_LINE INDENT n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE n = n + 1 NEW_LINE return ( n >> 1 ) NEW_LINE DEDENT n = 273 NEW_LINE print ( setBitNumber ( n ) ) NEW_LINE"],"bleu":0.9443716053164669,"rouge_l":0.96875}
{"id":689,"predictions":["def isHaserogram ( s , n ) : NEW_LINE INDENT hash = [ 0 ] * 26 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] != ' ▁ ' ) : NEW_LINE INDENT if ( hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] == 0 ) : NEW_LINE INDENT hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] = 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT DEDENT return True ; NEW_LINE DEDENT s = \" the ▁ big ▁ fractions \" ; NEW_LINE n = len ( s ) ; NEW_LINE if ( isHaserogram ( s , n ) ) : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE DEDENT"],"references":["def isHeterogram ( s , n ) : NEW_LINE INDENT hash = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] != ' ▁ ' : NEW_LINE INDENT if hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] == 0 : NEW_LINE INDENT hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT s = \" the ▁ big ▁ dwarf ▁ only ▁ jumps \" NEW_LINE n = len ( s ) NEW_LINE print ( \" YES \" if isHeterogram ( s , n ) else \" NO \" ) NEW_LINE"],"bleu":0.667017578569922,"rouge_l":0.8560682609183788}
{"id":690,"predictions":["def findgcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return findgcd ( b , a % b ) NEW_LINE DEDENT def minimumCuts ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE gcd = a [ 1 ] - a [ 0 ] NEW_LINE s = gcd NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT gcd = findgcd ( gcd , a [ i ] - a [ i - 1 ] ) NEW_LINE s += a [ i ] - a [ i - 1 ] NEW_LINE DEDENT if ( 360 - s ) : NEW_LINE INDENT gcd = findgcd ( gcd , 360 - s ) NEW_LINE DEDENT return ( 360 \/\/ gcd ) - n NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 30 , 60 , 180 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minimumCuts ( arr , n ) ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def minimumCuts ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE gcd = a [ 1 ] - a [ 0 ] NEW_LINE s = gcd NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT gcd = math . gcd ( gcd , a [ i ] - a [ i - 1 ] ) NEW_LINE s += a [ i ] - a [ i - 1 ] NEW_LINE DEDENT if ( 360 - s > 0 ) : NEW_LINE INDENT gcd = math . gcd ( gcd , 360 - s ) NEW_LINE DEDENT return ( 360 \/\/ gcd ) - n NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 30 , 60 , 180 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minimumCuts ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.7856810911544523,"rouge_l":0.880375823324293}
{"id":691,"predictions":["MAX = 1005 ; NEW_LINE def SieveOfEratosthenes ( primes ) : NEW_LINE INDENT prime = [ True ] * MAX ; NEW_LINE p = 2 ; NEW_LINE while ( p * p < MAX ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT p += 1 ; NEW_LINE DEDENT for p in range ( 2 , MAX ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT primes . append ( p ) ; NEW_LINE DEDENT DEDENT DEDENT def minimumSquareDivisors ( N ) : NEW_LINE INDENT primes = [ ] ; NEW_LINE SieveOfEratosthenes ( primes ) ; NEW_LINE max_count = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( i < len ( primes ) and primes [ i ] * primes [ i ] <= N ) : NEW_LINE INDENT if ( N % primes [ i ] == 0 ) : NEW_LINE INDENT tmp = 0 ; NEW_LINE while ( N % primes [ i ] == 0 ) : NEW_LINE INDENT tmp += 1 ; NEW_LINE N \/\/= primes [ i ] ; NEW_LINE DEDENT max_count = max ( max_count , tmp ) ; NEW_LINE DEDENT if ( max_count == 0 ) : NEW_LINE INDENT max_count = 1 ; NEW_LINE DEDENT return max_count ; NEW_LINE DEDENT if ( max_count == 0 ) : NEW_LINE INDENT max_count = 1 ; NEW_LINE DEDENT return max_count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 24 ; NEW_LINE print ( \" Minimum ▁ Number ▁ of ▁ Square ▁ Not ▁ \" , minimumSquareFreeDivisors ( N ) ) ; NEW_LINE N = 6 ; NEW_LINE print ( \" Minimum ▁ Number ▁ of ▁ Square ▁ Divisors ( N ) ) ;"],"references":["from math import sqrt NEW_LINE MAX = 1005 NEW_LINE def SieveOfEratosthenes ( primes ) : NEW_LINE INDENT prime = [ True for i in range ( MAX ) ] NEW_LINE for p in range ( 2 , int ( sqrt ( MAX ) ) + 1 , 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for p in range ( 2 , MAX , 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT primes . append ( p ) NEW_LINE DEDENT DEDENT return primes NEW_LINE DEDENT def minimumSquareFreeDivisors ( N ) : NEW_LINE INDENT prime = [ ] NEW_LINE primes = [ ] NEW_LINE primes = SieveOfEratosthenes ( prime ) NEW_LINE max_count = 0 NEW_LINE i = 0 NEW_LINE while ( len ( primes ) and primes [ i ] * primes [ i ] <= N ) : NEW_LINE INDENT if ( N % primes [ i ] == 0 ) : NEW_LINE INDENT tmp = 0 NEW_LINE while ( N % primes [ i ] == 0 ) : NEW_LINE INDENT tmp += 1 NEW_LINE N \/= primes [ i ] NEW_LINE DEDENT max_count = max ( max_count , tmp ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( max_count == 0 ) : NEW_LINE INDENT max_count = 1 NEW_LINE DEDENT return max_count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 24 NEW_LINE print ( \" Minimum ▁ Number ▁ of ▁ Square ▁ Free ▁ Divisors ▁ is \" , minimumSquareFreeDivisors ( N ) ) NEW_LINE N = 6 NEW_LINE print ( \" Minimum ▁ Number ▁ of ▁ Square ▁ Free ▁ Divisors ▁ is \" , minimumSquareFreeDivisors ( N ) ) NEW_LINE DEDENT"],"bleu":0.6770655984321149,"rouge_l":0.8237082066869301}
{"id":692,"predictions":["def solve_sum ( n ) : NEW_LINE INDENT return pow ( n * ( n + 1 ) \/\/ 2 , 2 ) NEW_LINE DEDENT n = 4 NEW_LINE print ( int ( solve_sum ( n ) ) ) NEW_LINE"],"references":["def calculateSum ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) \/ 2 ) ** 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE print ( calculateSum ( n ) ) NEW_LINE DEDENT"],"bleu":0.4324205865890015,"rouge_l":0.675357142857143}
{"id":693,"predictions":["def push_digits ( number ) : NEW_LINE INDENT while ( number != 0 ) : NEW_LINE INDENT st . append ( number % 10 ) NEW_LINE number = int ( number \/ 10 ) NEW_LINE DEDENT DEDENT def reverse_number ( number ) : NEW_LINE INDENT push ( number ) NEW_LINE reverse = 0 NEW_LINE i = 1 NEW_LINE while ( len ( st ) != 0 ) : NEW_LINE INDENT reverse = reverse + ( st [ - 1 ] * i ) NEW_LINE st . pop ( ) NEW_LINE i = i * 10 NEW_LINE DEDENT return reverse NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT number = 37997 NEW_LINE print ( reverse_number ( number ) ) NEW_LINE DEDENT"],"references":["st = [ ] ; NEW_LINE def push_digits ( number ) : NEW_LINE INDENT while ( number != 0 ) : NEW_LINE INDENT st . append ( number % 10 ) ; NEW_LINE number = int ( number \/ 10 ) ; NEW_LINE DEDENT DEDENT def reverse_number ( number ) : NEW_LINE INDENT push_digits ( number ) ; NEW_LINE reverse = 0 ; NEW_LINE i = 1 ; NEW_LINE while ( len ( st ) > 0 ) : NEW_LINE INDENT reverse = reverse + ( st [ len ( st ) - 1 ] * i ) ; NEW_LINE st . pop ( ) ; NEW_LINE i = i * 10 ; NEW_LINE DEDENT return reverse ; NEW_LINE DEDENT number = 39997 ; NEW_LINE print ( reverse_number ( number ) ) ; NEW_LINE"],"bleu":0.6501529704320728,"rouge_l":0.8388548568571071}
{"id":694,"predictions":["def inProposition ( arr ) : NEW_LINE INDENT n = 4 NEW_LINE arr . sort ( ) NEW_LINE prints ( arr [ 0 ] * arr [ 3 ] ) NEW_LINE mean = arr [ 1 ] * arr [ 2 ] NEW_LINE if ( differences == mean ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT arr = [ 1 , 2 , 4 , 2 ] NEW_LINE if ( inpossible ( arr ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def inProportion ( arr ) : NEW_LINE INDENT n = 4 ; NEW_LINE arr . sort ( ) NEW_LINE extremes = arr [ 0 ] * arr [ 3 ] ; NEW_LINE means = arr [ 1 ] * arr [ 2 ] ; NEW_LINE if ( extremes == means ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 2 ] ; NEW_LINE if ( inProportion ( arr ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"],"bleu":0.5793767563586474,"rouge_l":0.821725422757237}
{"id":695,"predictions":["M = 100 NEW_LINE memo = [ [ 0 for x in range ( M ) ] for y in range ( M ) ] NEW_LINE def numberOfPermWithKInNumber ( N , K ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( K == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( memo [ N ] [ K ] ) : NEW_LINE INDENT return memo [ N ] [ K ] NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( K + 1 ) : NEW_LINE INDENT if ( i <= N - 1 ) : NEW_LINE INDENT sum += numberOfPermWithKInKInversions ( N - 1 , K - i ) NEW_LINE DEDENT DEDENT memo [ N ] [ K ] = sum NEW_LINE return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE K = 2 NEW_LINE print ( numberOfPermWithKInversions ( N , K ) ) NEW_LINE DEDENT"],"references":["M = 100 NEW_LINE memo = [ [ 0 for i in range ( M ) ] for j in range ( M ) ] NEW_LINE def numberOfPermWithKInversion ( N , K ) : NEW_LINE INDENT if ( N == 0 ) : return 0 NEW_LINE if ( K == 0 ) : return 1 NEW_LINE if ( memo [ N ] [ K ] != 0 ) : NEW_LINE INDENT return memo [ N ] [ K ] NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( K + 1 ) : NEW_LINE INDENT if ( i <= N - 1 ) : NEW_LINE INDENT sum += numberOfPermWithKInversion ( N - 1 , K - i ) NEW_LINE DEDENT DEDENT memo [ N ] [ K ] = sum NEW_LINE return sum NEW_LINE DEDENT N = 4 ; K = 2 NEW_LINE print ( numberOfPermWithKInversion ( N , K ) ) NEW_LINE"],"bleu":0.7418344929082306,"rouge_l":0.9053003533568905}
{"id":696,"predictions":["from math import sqrt NEW_LINE def findkth ( n , k ) : NEW_LINE INDENT v1 = [ ] NEW_LINE v2 = [ ] NEW_LINE for i in range ( 1 , ceil ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT v1 . append ( i ) NEW_LINE if ( i != sqrt ( n ) ) : NEW_LINE INDENT v2 . append ( n \/ i ) NEW_LINE DEDENT DEDENT DEDENT v2 . reverse ( ) NEW_LINE if ( k > ( len ( v1 ) + len ( v2 ) ) : NEW_LINE INDENT print ( \" Doesn ' t ▁ exist \" ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( k <= len ( v1 ) ) : NEW_LINE INDENT print ( v1 [ k - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( v2 [ k - len ( v1 ) - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 15 NEW_LINE k = 2 NEW_LINE findkth ( n , k ) NEW_LINE DEDENT"],"references":["import math as mt NEW_LINE def findkth ( n , k ) : NEW_LINE INDENT v1 = list ( ) NEW_LINE v2 = list ( ) NEW_LINE for i in range ( 1 , mt . ceil ( n ** ( .5 ) ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT v1 . append ( i ) NEW_LINE if ( i != mt . ceil ( mt . sqrt ( n ) ) ) : NEW_LINE INDENT v2 . append ( n \/\/ i ) NEW_LINE DEDENT DEDENT DEDENT v2 [ : : - 1 ] NEW_LINE if ( k > ( len ( v1 ) + len ( v2 ) ) ) : NEW_LINE INDENT print ( \" Doesn ' t ▁ Exist \" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( k <= len ( v1 ) ) : NEW_LINE INDENT print ( v1 [ k - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( v2 [ k - len ( v1 ) - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT n = 15 NEW_LINE k = 2 NEW_LINE findkth ( n , k ) NEW_LINE"],"bleu":0.7610211643363091,"rouge_l":0.8359532446594115}
{"id":697,"predictions":["import sys ; NEW_LINE def maxSubArraySum ( a , size ) : NEW_LINE INDENT max_so_far = - sys . maxsize ; NEW_LINE max_ending_here = 0 ; NEW_LINE for i in range ( size ) : NEW_LINE INDENT max_ending_here = max_ending_here + a [ i ] ; NEW_LINE if ( max_so_far < max_ending_here ) : NEW_LINE INDENT max_so_far = max_ending_here ; NEW_LINE DEDENT if ( max_ending_here < 0 ) : NEW_LINE INDENT max_ending_here = 0 ; NEW_LINE DEDENT DEDENT return max_so_far ; NEW_LINE DEDENT def minimizedSum ( a , n , K ) : NEW_LINE INDENT sum = maxSubArraySum ( a , n ) ; NEW_LINE totalSum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT totalSum += a [ i ] ; NEW_LINE DEDENT if ( sum < 0 ) : NEW_LINE INDENT return totalSum ; NEW_LINE DEDENT totalSum = totalSum - sum + sum \/ K ; NEW_LINE return totalSum ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , - 2 , 3 ] ; NEW_LINE n = len ( a ) ; NEW_LINE K = 2 ; NEW_LINE print ( minimizedSum ( a , n , K ) ) ; NEW_LINE DEDENT"],"references":["import sys NEW_LINE def maxSubArraySum ( a , size ) : NEW_LINE INDENT max_so_far = - ( sys . maxsize - 1 ) ; NEW_LINE max_ending_here = 0 ; NEW_LINE for i in range ( size ) : NEW_LINE INDENT max_ending_here = max_ending_here + a [ i ] ; NEW_LINE if ( max_so_far < max_ending_here ) : NEW_LINE INDENT max_so_far = max_ending_here ; NEW_LINE DEDENT if ( max_ending_here < 0 ) : NEW_LINE INDENT max_ending_here = 0 ; NEW_LINE DEDENT DEDENT return max_so_far ; NEW_LINE DEDENT def minimizedSum ( a , n , K ) : NEW_LINE INDENT sum = maxSubArraySum ( a , n ) ; NEW_LINE totalSum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT totalSum += a [ i ] ; NEW_LINE DEDENT if ( sum < 0 ) : NEW_LINE INDENT return totalSum ; NEW_LINE DEDENT totalSum = totalSum - sum + sum \/ K ; NEW_LINE return totalSum ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , - 2 , 3 ] ; NEW_LINE n = len ( a ) ; NEW_LINE K = 2 ; NEW_LINE print ( minimizedSum ( a , n , K ) ) ; NEW_LINE DEDENT"],"bleu":0.9611118485613616,"rouge_l":0.9869789660220356}
{"id":698,"predictions":["def countSetBits ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE setBits = [ 0 for i in range ( n + 1 ) ] NEW_LINE setBits [ 0 ] = 0 NEW_LINE setBits [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT setBits [ i ] = setBits [ i \/\/ 2 ] NEW_LINE DEDENT else : NEW_LINE INDENT setBits [ i ] = setBits [ i - 1 ] + 1 NEW_LINE DEDENT DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT cnt = cnt + setBits [ i ] NEW_LINE DEDENT return cnt NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 6 NEW_LINE print ( countSetBits ( n ) ) NEW_LINE DEDENT"],"references":["def countSetBits ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE setBits = [ 0 for x in range ( n + 1 ) ] NEW_LINE setBits [ 0 ] = 0 NEW_LINE setBits [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT setBits [ i ] = setBits [ i \/\/ 2 ] NEW_LINE DEDENT else : NEW_LINE INDENT setBits [ i ] = setBits [ i - 1 ] + 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , n + 1 ) : NEW_LINE INDENT cnt = cnt + setBits [ i ] NEW_LINE DEDENT return cnt NEW_LINE DEDENT n = 6 NEW_LINE print ( countSetBits ( n ) ) NEW_LINE"],"bleu":0.86994834688095,"rouge_l":0.9449823442305503}
{"id":699,"predictions":["def areaCircle ( b ) : NEW_LINE INDENT area = 3.14 * b * b NEW_LINE return area NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 10 NEW_LINE b = 8 NEW_LINE print ( areaCircle ( b ) ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def areaCircle ( b ) : NEW_LINE INDENT area = math . pi * b * b NEW_LINE return area NEW_LINE DEDENT a = 10 NEW_LINE b = 8 NEW_LINE print ( areaCircle ( b ) ) NEW_LINE"],"bleu":0.6372440604609679,"rouge_l":0.7831988261188555}
{"id":700,"predictions":["import sys NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def push ( head_ref , new_data ) : NEW_LINE INDENT if not head : NEW_LINE INDENT return Node ( data ) NEW_LINE DEDENT new_node = Node ( new_data ) NEW_LINE new_node . data = new_data NEW_LINE head_ref = new_node NEW_LINE return head_ref NEW_LINE DEDENT def printList ( head ) : NEW_LINE INDENT while ( head != None ) : NEW_LINE INDENT print ( head . data , end = \" - > \" ) NEW_LINE head = head . next NEW_LINE DEDENT DEDENT def sortlist ( arr , N , head ) : NEW_LINE INDENT hashmap = dict ( ) NEW_LINE temp = head NEW_LINE while ( temp ) : NEW_LINE INDENT print ( hash . data , end = \" ▁ \" ) NEW_LINE temp = temp . next NEW_LINE DEDENT temp = temp . next NEW_LINE DEDENT temp = head NEW_LINE for i in range ( N ) : NEW_LINE INDENT frequency = hashmap [ arr [ i ] ] NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE temp = temp . next NEW_LINE DEDENT DEDENT temp = None NEW_LINE for i in range ( N ) : NEW_LINE INDENT frequency = hashmap [ arr [ i ] ] NEW_LINE while ( frequency > 0 ) : NEW_LINE INDENT temp . data = arr [ i ] NEW_LINE temp = temp . next NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = None NEW_LINE head = push ( head , 1 , 3 ) NEW_LINE head = push ( head , 2 ) NEW_LINE head = push ( head , 5 ) NEW_LINE head = push ( head , 5 ) NEW_LINE head = push ( head , 2 ) NEW_LINE head = push ( head , 5 ) NEW_LINE head = push ("],"references":["class Node : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . data = 0 NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def push ( head_ref , new_data ) : NEW_LINE INDENT new_node = Node ( ) NEW_LINE new_node . data = new_data NEW_LINE new_node . next = head_ref NEW_LINE head_ref = new_node NEW_LINE return head_ref NEW_LINE DEDENT def printList ( head ) : NEW_LINE INDENT while ( head != None ) : NEW_LINE INDENT print ( head . data , end = \" - > \" ) NEW_LINE head = head . next NEW_LINE DEDENT DEDENT def sortlist ( arr , N , head ) : NEW_LINE INDENT hash = dict ( ) NEW_LINE temp = head NEW_LINE while ( temp != None ) : NEW_LINE INDENT hash [ temp . data ] = hash . get ( temp . data , 0 ) + 1 NEW_LINE temp = temp . next NEW_LINE DEDENT temp = head NEW_LINE for i in range ( N ) : NEW_LINE INDENT frequency = hash . get ( arr [ i ] , 0 ) NEW_LINE while ( frequency > 0 ) : NEW_LINE INDENT frequency = frequency - 1 NEW_LINE temp . data = arr [ i ] NEW_LINE temp = temp . next NEW_LINE DEDENT DEDENT DEDENT head = None NEW_LINE arr = [ 5 , 1 , 3 , 2 , 8 ] NEW_LINE N = len ( arr ) NEW_LINE head = push ( head , 3 ) NEW_LINE head = push ( head , 2 ) NEW_LINE head = push ( head , 5 ) NEW_LINE head = push ( head , 8 ) NEW_LINE head = push ( head , 5 ) NEW_LINE head = push ( head , 2 ) NEW_LINE head = push ( head , 1 ) NEW_LINE sortlist ( arr , N , head ) NEW_LINE print ( \" Sorted ▁ List : \" ) NEW_LINE printList ( head ) NEW_LINE"],"bleu":0.6835134093809497,"rouge_l":0.729177757344045}
{"id":701,"predictions":["def printPattern ( N ) : NEW_LINE INDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( \" ▁ \" , ( i % 2 == 0 ) ) NEW_LINE DEDENT DEDENT def printPattern ( N ) : NEW_LINE INDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( str ( i ) , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 10 NEW_LINE printPattern ( N ) NEW_LINE DEDENT"],"references":["def printPattern ( N ) : NEW_LINE INDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( i - 1 if i % 2 == 0 else i + 1 , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT N = 10 NEW_LINE printPattern ( N ) NEW_LINE"],"bleu":0.44962630972803386,"rouge_l":0.6888839681133747}
{"id":702,"predictions":["import sys NEW_LINE import sys NEW_LINE def minIndex ( list , sortIndex ) : NEW_LINE INDENT min_index = - 1 NEW_LINE min_value = sys . maxsize NEW_LINE s = len ( list ) NEW_LINE for i in range ( s ) : NEW_LINE INDENT current = list ( ) NEW_LINE if ( current <= min_value and i <= sortIndex ) : NEW_LINE INDENT min_index = i NEW_LINE min_value = current NEW_LINE DEDENT list . append ( current ) NEW_LINE DEDENT return min_index NEW_LINE DEDENT def insertMinToRear ( list , min_index ) : NEW_LINE INDENT min_value = 0 NEW_LINE s = len ( list ( ) NEW_LINE for i in range ( s ) ) : NEW_LINE INDENT current = list [ 0 ] NEW_LINE list [ 0 ] = current NEW_LINE if ( i != min_index ) : NEW_LINE INDENT min_index = i NEW_LINE DEDENT else : NEW_LINE INDENT min_value = current NEW_LINE DEDENT DEDENT list . append ( min_value ) NEW_LINE DEDENT def sortQueue ( list ) : NEW_LINE INDENT for i in range ( 1 , len ( list ) - i ) : NEW_LINE INDENT min_index = minIndex ( list , len ( list ) - i ) NEW_LINE insertMinToRear ( list , min_index ) NEW_LINE DEDENT DEDENT def sortQueue ( list ) : NEW_LINE INDENT for i in range ( 1 , len ( list ) ) : NEW_LINE INDENT min_index = minIndex ( list , len ( list ) - i ) NEW_LINE insertMinToRear ( list , min_index ) NEW_LINE DEDENT DEDENT if __name__ == \" _ main _ _ \" : NEW_LINE INDENT list = Queue ( ) NEW_LINE for i in range ( 1 , len ( list ) ) : NEW_LINE INDENT print ( list [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT"],"references":["from queue import Queue NEW_LINE def minIndex ( q , sortedIndex ) : NEW_LINE INDENT min_index = - 1 NEW_LINE min_val = 999999999999 NEW_LINE n = q . qsize ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr = q . queue [ 0 ] NEW_LINE q . get ( ) NEW_LINE if ( curr <= min_val and i <= sortedIndex ) : NEW_LINE INDENT min_index = i NEW_LINE min_val = curr NEW_LINE DEDENT q . put ( curr ) NEW_LINE DEDENT return min_index NEW_LINE DEDENT def insertMinToRear ( q , min_index ) : NEW_LINE INDENT min_val = None NEW_LINE n = q . qsize ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr = q . queue [ 0 ] NEW_LINE q . get ( ) NEW_LINE if ( i != min_index ) : NEW_LINE INDENT q . put ( curr ) NEW_LINE DEDENT else : NEW_LINE INDENT min_val = curr NEW_LINE DEDENT DEDENT q . put ( min_val ) NEW_LINE DEDENT def sortQueue ( q ) : NEW_LINE INDENT for i in range ( 1 , q . qsize ( ) + 1 ) : NEW_LINE INDENT min_index = minIndex ( q , q . qsize ( ) - i ) NEW_LINE insertMinToRear ( q , min_index ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT q = Queue ( ) NEW_LINE q . put ( 30 ) NEW_LINE q . put ( 11 ) NEW_LINE q . put ( 15 ) NEW_LINE q . put ( 4 ) NEW_LINE sortQueue ( q ) NEW_LINE while ( q . empty ( ) == False ) : NEW_LINE INDENT print ( q . queue [ 0 ] , end = \" ▁ \" ) NEW_LINE q . get ( ) NEW_LINE DEDENT DEDENT"],"bleu":0.42464849460943643,"rouge_l":0.6170426861561275}
{"id":703,"predictions":["def cntRotations ( s , n ) : NEW_LINE INDENT str = s + s NEW_LINE pre = [ 0 ] * 2 * n NEW_LINE for i in range ( 2 * n ) : NEW_LINE INDENT if ( i != 0 ) : NEW_LINE INDENT pre [ i ] += pre [ i - 1 ] NEW_LINE DEDENT if ( str [ i ] == ' a ' or str [ i ] == ' e ' or str [ i ] == ' i ' or str [ i ] == ' o ' or str [ i ] == ' u ' ) : NEW_LINE INDENT pre [ i ] += 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n - 1 , 2 * n - 1 ) : NEW_LINE INDENT r = i NEW_LINE l = i - n NEW_LINE x1 = pre [ r ] NEW_LINE if ( l >= 0 ) : NEW_LINE INDENT x1 -= pre [ l ] NEW_LINE DEDENT r = i - n \/\/ 2 NEW_LINE left = pre [ r ] NEW_LINE if ( l >= 0 ) : NEW_LINE INDENT left -= pre [ l ] NEW_LINE DEDENT right = x1 - left NEW_LINE if ( left > right ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT s = \" abecidft \" NEW_LINE n = len ( s ) NEW_LINE print ( cntRotations ( s , n ) ) NEW_LINE"],"references":["def cntRotations ( s , n ) : NEW_LINE INDENT str = s + s ; NEW_LINE pre = [ 0 ] * ( 2 * n ) ; NEW_LINE for i in range ( 2 * n ) : NEW_LINE INDENT if ( i != 0 ) : NEW_LINE INDENT pre [ i ] += pre [ i - 1 ] ; NEW_LINE DEDENT if ( str [ i ] == ' a ' or str [ i ] == ' e ' or str [ i ] == ' i ' or str [ i ] == ' o ' or str [ i ] == ' u ' ) : NEW_LINE INDENT pre [ i ] += 1 ; NEW_LINE DEDENT DEDENT ans = 0 ; NEW_LINE for i in range ( n - 1 , 2 * n - 1 , 1 ) : NEW_LINE INDENT r = i ; l = i - n ; NEW_LINE x1 = pre [ r ] ; NEW_LINE if ( l >= 0 ) : NEW_LINE INDENT x1 -= pre [ l ] ; NEW_LINE DEDENT r = ( int ) ( i - n \/ 2 ) ; NEW_LINE left = pre [ r ] ; NEW_LINE if ( l >= 0 ) : NEW_LINE INDENT left -= pre [ l ] ; NEW_LINE DEDENT right = x1 - left ; NEW_LINE if ( left > right ) : NEW_LINE INDENT ans += 1 ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT s = \" abecidft \" ; NEW_LINE n = len ( s ) ; NEW_LINE print ( cntRotations ( s , n ) ) ; NEW_LINE"],"bleu":0.7823027151424864,"rouge_l":0.9358437935843794}
{"id":704,"predictions":["def msbase ( N ) : NEW_LINE INDENT msb_p = - 1 ; NEW_LINE while ( N > 0 ) : NEW_LINE INDENT N = N >> 1 ; NEW_LINE msb_p += 1 ; NEW_LINE DEDENT return msb_p ; NEW_LINE DEDENT def findBitwiseOR ( L , R ) : NEW_LINE INDENT res = 0 ; NEW_LINE msb_p1 = msb ( L ) ; NEW_LINE msb_p2 = msp [ R ] ; NEW_LINE while ( msb_p1 == msb_p2 ) : NEW_LINE INDENT res_val = ( 1 << msb_p1 ) ; NEW_LINE res += res_val ; NEW_LINE L -= res_val ; NEW_LINE msb_p1 = mscb ( L ) ; NEW_LINE msb1 = msbPos ; NEW_LINE DEDENT msb_p1 = max ( msb_p1 , msb_p2 ) ; NEW_LINE for i in range ( msb_p1 , - 1 ) : NEW_LINE INDENT res_val = ( 1 << i ) ; NEW_LINE res += res_val ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT L = 12 ; R = 18 ; NEW_LINE print ( findBitwiseOR ( L , R ) ) ; NEW_LINE DEDENT"],"references":["def MSBPosition ( N ) : NEW_LINE INDENT msb_p = - 1 NEW_LINE while ( N ) : NEW_LINE INDENT N = N >> 1 NEW_LINE msb_p += 1 NEW_LINE DEDENT return msb_p NEW_LINE DEDENT def findBitwiseOR ( L , R ) : NEW_LINE INDENT res = 0 NEW_LINE msb_p1 = MSBPosition ( L ) NEW_LINE msb_p2 = MSBPosition ( R ) NEW_LINE while ( msb_p1 == msb_p2 ) : NEW_LINE INDENT res_val = ( 1 << msb_p1 ) NEW_LINE res += res_val NEW_LINE L -= res_val NEW_LINE R -= res_val NEW_LINE msb_p1 = MSBPosition ( L ) NEW_LINE msb_p2 = MSBPosition ( R ) NEW_LINE DEDENT msb_p1 = max ( msb_p1 , msb_p2 ) NEW_LINE for i in range ( msb_p1 , - 1 , - 1 ) : NEW_LINE INDENT res_val = ( 1 << i ) NEW_LINE res += res_val NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT L , R = 12 , 18 NEW_LINE print ( findBitwiseOR ( L , R ) ) NEW_LINE DEDENT"],"bleu":0.6431705612794539,"rouge_l":0.8644052785404304}
{"id":705,"predictions":["from math import sqrt , pow NEW_LINE def sieve ( prime , n ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( sqrt ( n ) ) + 1 , 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , n , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def sumPrime ( d ) : NEW_LINE INDENT maxVal = int ( pow ( 10 , d ) - 1 ) - 1 ; NEW_LINE prime = [ True for i in range ( maxVal + 1 ) ] NEW_LINE for i in range ( 2 , maxVal + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT d = 3 NEW_LINE print ( sumPrime ( d ) ) NEW_LINE DEDENT"],"references":["from math import sqrt NEW_LINE def sieve ( prime , n ) : NEW_LINE INDENT prime [ 0 ] = False ; NEW_LINE prime [ 1 ] = False ; NEW_LINE for p in range ( 2 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def sumPrime ( d ) : NEW_LINE INDENT maxVal = ( 10 ** d ) - 1 ; NEW_LINE prime = [ True ] * ( maxVal + 1 ) ; NEW_LINE sieve ( prime , maxVal ) ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( 2 , maxVal + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT sum += i ; NEW_LINE DEDENT DEDENT return sum ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT d = 3 ; NEW_LINE print ( sumPrime ( d ) ) ; NEW_LINE DEDENT"],"bleu":0.7759396373092803,"rouge_l":0.8893306825712393}
{"id":706,"predictions":["MAX_CHAR = 256 NEW_LINE def kthNonRepeating ( string , k ) : NEW_LINE INDENT n = len ( string ) NEW_LINE count = [ 0 for i in range ( MAX_CHAR ) ] * MAX_CHAR NEW_LINE index = [ n for i in range ( MAX_CHAR ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = ord ( string [ i ] ) NEW_LINE count [ x ] += 1 NEW_LINE if ( count [ x ] == 1 ) : NEW_LINE INDENT index [ x ] = i NEW_LINE DEDENT if ( count [ x ] == 2 ) : NEW_LINE INDENT index [ x ] = n NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT index = sorted ( index ) NEW_LINE if ( index [ k - 1 ] != n ) : NEW_LINE INDENT index [ x ] = n NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return index [ k - 1 ] NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT string = \" geeksforgeeks \" NEW_LINE k = 3 NEW_LINE res = kthNonRepeating ( string , k ) NEW_LINE if ( res == - 1 ) : NEW_LINE INDENT print ( \" There ▁ are ▁ less ▁ k ▁ non - repeating ▁ characters ▁ is ▁ \" , end = \" ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( kthNonRepeating ( string , k ) ) NEW_LINE DEDENT DEDENT"],"references":["MAX_CHAR = 256 NEW_LINE def kthNonRepeating ( str , k ) : NEW_LINE INDENT n = len ( str ) NEW_LINE count = [ 0 ] * MAX_CHAR NEW_LINE index = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT count [ i ] = 0 NEW_LINE index [ i ] = n NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT x = str [ i ] NEW_LINE count [ ord ( x ) ] += 1 NEW_LINE if ( count [ ord ( x ) ] == 1 ) : NEW_LINE INDENT index [ ord ( x ) ] = i NEW_LINE DEDENT if ( count [ ord ( x ) ] == 2 ) : NEW_LINE INDENT index [ ord ( x ) ] = n NEW_LINE DEDENT DEDENT index . sort ( ) NEW_LINE return index [ k - 1 ] if ( index [ k - 1 ] != n ) else - 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeksforgeeks \" NEW_LINE k = 3 NEW_LINE res = kthNonRepeating ( str , k ) NEW_LINE if ( res == - 1 ) : NEW_LINE INDENT print ( \" There ▁ are ▁ less ▁ than ▁ k \" , \" non - repeating ▁ characters \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" k ' th ▁ non - repeating ▁ character ▁ is \" , str [ res ] ) NEW_LINE DEDENT DEDENT"],"bleu":0.6128022001823338,"rouge_l":0.7355429292929293}
{"id":707,"predictions":["def squareDigitSum ( number ) : NEW_LINE INDENT summ = 0 NEW_LINE num = int ( number ) NEW_LINE squareNum = num * num NEW_LINE while squareNum > 0 : NEW_LINE INDENT summ = summ + ( squareNum % 10 ) NEW_LINE squareNum = squareNum \/\/ 10 NEW_LINE DEDENT return summ NEW_LINE DEDENT N = \"1111\" NEW_LINE print ( squareDigitSum ( N ) ) NEW_LINE"],"references":["def squareDigitSum ( num ) : NEW_LINE INDENT summ = 0 NEW_LINE num = int ( num ) NEW_LINE squareNum = num * num NEW_LINE while squareNum > 0 : NEW_LINE INDENT summ = summ + ( squareNum % 10 ) NEW_LINE squareNum = squareNum \/\/ 10 NEW_LINE DEDENT return summ NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = \"1111\" NEW_LINE print ( squareDigitSum ( N ) ) NEW_LINE DEDENT"],"bleu":0.7229293300197155,"rouge_l":0.859923920340121}
{"id":708,"predictions":["def maxCost ( a , n , l , r ) : NEW_LINE INDENT mx = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mx = max ( mx , a [ i ] ) NEW_LINE DEDENT count = [ 0 for i in range ( mx + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ a [ i ] ] += 1 NEW_LINE DEDENT res = [ 0 for i in range ( mx + 1 ) ] NEW_LINE res [ 0 ] = 0 NEW_LINE l = min ( l , r ) NEW_LINE for num in range ( 1 , mx + 1 ) : NEW_LINE INDENT k = max ( num - l - 1 , 0 ) NEW_LINE res [ num ] = max ( res [ num - 1 ] , num * count [ num ] + res [ k ] ) NEW_LINE DEDENT return res [ mx ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 2 , 1 , 2 , 3 , 2 , 2 , 1 ] NEW_LINE l = 1 NEW_LINE r = 1 NEW_LINE n = len ( a ) NEW_LINE print ( maxCost ( a , n , l , r ) ) NEW_LINE DEDENT"],"references":["def maxCost ( a , n , l , r ) : NEW_LINE INDENT mx = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mx = max ( mx , a [ i ] ) NEW_LINE DEDENT count = [ 0 ] * ( mx + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ a [ i ] ] += 1 NEW_LINE DEDENT res = [ 0 ] * ( mx + 1 ) NEW_LINE res [ 0 ] = 0 NEW_LINE l = min ( l , r ) NEW_LINE for num in range ( 1 , mx + 1 ) : NEW_LINE INDENT k = max ( num - l - 1 , 0 ) NEW_LINE res [ num ] = max ( res [ num - 1 ] , num * count [ num ] + res [ k ] ) NEW_LINE DEDENT return res [ mx ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 2 , 1 , 2 , 3 , 2 , 2 , 1 ] NEW_LINE l , r = 1 , 1 NEW_LINE n = len ( a ) NEW_LINE print ( maxCost ( a , n , l , r ) ) NEW_LINE DEDENT"],"bleu":0.9103269453502068,"rouge_l":0.9584144144144143}
{"id":709,"predictions":["def findPosition ( k , n ) : NEW_LINE INDENT f1 = 0 NEW_LINE f2 = 1 NEW_LINE f3 = n NEW_LINE while ( i != 0 ) : NEW_LINE INDENT f3 = f1 + f2 NEW_LINE f1 = f2 NEW_LINE f2 = f3 NEW_LINE if ( f2 % k == 0 ) : NEW_LINE INDENT return n * i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE k = 4 NEW_LINE print ( \" Position ▁ of ▁ n ' th ▁ multiple ▁ of ▁ k ▁ in ▁ Fibonacci ▁ series ▁ is ▁ \" , findPosition ( k , n ) ) NEW_LINE DEDENT"],"references":["def findPosition ( k , n ) : NEW_LINE INDENT f1 = 0 NEW_LINE f2 = 1 NEW_LINE i = 2 ; NEW_LINE while i != 0 : NEW_LINE INDENT f3 = f1 + f2 ; NEW_LINE f1 = f2 ; NEW_LINE f2 = f3 ; NEW_LINE if f2 % k == 0 : NEW_LINE INDENT return n * i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return NEW_LINE DEDENT n = 5 ; NEW_LINE k = 4 ; NEW_LINE print ( \" Position ▁ of ▁ n ' th ▁ multiple ▁ of ▁ k ▁ in \" \" Fibonacci ▁ Seires ▁ is \" , findPosition ( k , n ) ) ; NEW_LINE"],"bleu":0.6194924975962428,"rouge_l":0.8600867678958785}
{"id":710,"predictions":["def printTheArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def generateAllBinaryStrings ( n , arr , i ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT printTheArray ( arr , n ) NEW_LINE return NEW_LINE DEDENT arr [ i ] = 0 NEW_LINE generateAllBinaryStrings ( n , arr , i + 1 ) NEW_LINE arr [ i ] = 1 NEW_LINE generateAllBinaryStrings ( n , arr , i + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE arr = [ 0 for i in range ( n ) ] NEW_LINE generateAllBinaryStrings ( n , arr , 0 ) NEW_LINE DEDENT"],"references":["def printTheArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def generateAllBinaryStrings ( n , arr , i ) : NEW_LINE INDENT if i == n : NEW_LINE INDENT printTheArray ( arr , n ) NEW_LINE return NEW_LINE DEDENT arr [ i ] = 0 NEW_LINE generateAllBinaryStrings ( n , arr , i + 1 ) NEW_LINE arr [ i ] = 1 NEW_LINE generateAllBinaryStrings ( n , arr , i + 1 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 NEW_LINE arr = [ None ] * n NEW_LINE generateAllBinaryStrings ( n , arr , 0 ) NEW_LINE DEDENT"],"bleu":0.8538586881788061,"rouge_l":0.9376130198915009}
{"id":711,"predictions":["import numpy as np NEW_LINE import sys NEW_LINE X = \" AGGT12\" NEW_LINE Z = \"12XAYB \" NEW_LINE dp = np . zeros ( ( 100 , 100 ) ) ; NEW_LINE dp = np . zeros ( ( 1001 , j , k ) ) ; NEW_LINE def lcsOf3 ( i , j , k ) : NEW_LINE INDENT if ( i == - 1 or j == - 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( dp [ i ] [ j ] ) : NEW_LINE INDENT return dp [ i ] [ j ] [ k ] ; NEW_LINE DEDENT if ( X [ i ] == Y [ j ] and Y [ j ] == Z [ k ] ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = 1 + lcsOf3 ( i - 1 , j - 1 , k - 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = max ( max ( lcsOf3 ( i - 1 , j , k ) , lcsOf3 ( i , j - 1 , k ) ) , lcsOf3 ( i , j , k - 1 ) ) ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = max ( max ( lcsOf3 ( i - 1 , j , k ) , lcsOf3 ( i , j - 1 , k - 1 ) ) , lcsOf3 ( i , j , k - 1 ) ) ; NEW_LINE DEDENT DEDENT m = len ( X ) ; NEW_LINE n = len ( Y ) ; NEW_LINE o = len ( Z ) ; NEW_LINE print ( \" Length ▁ of ▁ LCS ▁ is \" , lcsOf3 ( m - 1 , n - 1 , o - 1 ) ) ; NEW_LINE"],"references":["X = \" AGGT12\" NEW_LINE Y = \"12TXAYB \" NEW_LINE Z = \"12XBA \" NEW_LINE dp = [ [ [ - 1 for i in range ( 100 ) ] for j in range ( 100 ) ] for k in range ( 100 ) ] NEW_LINE def lcsOf3 ( i , j , k ) : NEW_LINE INDENT if ( i == - 1 or j == - 1 or k == - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ j ] [ k ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] [ k ] NEW_LINE DEDENT if ( X [ i ] == Y [ j ] and Y [ j ] == Z [ k ] ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = 1 + lcsOf3 ( i - 1 , j - 1 , k - 1 ) NEW_LINE return dp [ i ] [ j ] [ k ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = max ( max ( lcsOf3 ( i - 1 , j , k ) , lcsOf3 ( i , j - 1 , k ) ) , lcsOf3 ( i , j , k - 1 ) ) NEW_LINE return dp [ i ] [ j ] [ k ] NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT m = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE o = len ( Z ) NEW_LINE print ( \" Length ▁ of ▁ LCS ▁ is \" , lcsOf3 ( m - 1 , n - 1 , o - 1 ) ) NEW_LINE DEDENT"],"bleu":0.6865740489188853,"rouge_l":0.7661352335059209}
{"id":712,"predictions":["def checkTriangularSum ( n ) : NEW_LINE INDENT tri = set ( ) NEW_LINE i = 1 NEW_LINE while ( True ) : NEW_LINE INDENT x = i * ( i + 1 ) \/ 2 NEW_LINE if ( x >= n ) : NEW_LINE INDENT break NEW_LINE DEDENT tri . add ( x ) NEW_LINE i += 1 NEW_LINE DEDENT for tt in sorted ( tri ) : NEW_LINE INDENT if ( n - tm in trie ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT n = 24 NEW_LINE if ( checkTriangularSumTree ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def checkTriangularSumRepresentation ( n ) : NEW_LINE INDENT tri = list ( ) ; NEW_LINE i = 1 ; NEW_LINE while ( 1 ) : NEW_LINE INDENT x = i * ( i + 1 ) \/\/ 2 ; NEW_LINE if ( x >= n ) : NEW_LINE INDENT break ; NEW_LINE DEDENT tri . append ( x ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT for tm in tri : NEW_LINE INDENT if n - tm in tri : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT return False ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 24 ; NEW_LINE if checkTriangularSumRepresentation ( n ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.5524712261056037,"rouge_l":0.818192903304475}
{"id":713,"predictions":["import math NEW_LINE eps = 10 ** 6 NEW_LINE def getArea ( base , upten ) : NEW_LINE INDENT height = math . sqrt ( slopeen ) NEW_LINE return 0.5 * base NEW_LINE DEDENT def getRightAngleTriangle , area NEW_LINE def printArea ( base , upten ) : NEW_LINE INDENT hsquare = slopeen ** 2.0 NEW_LINE maxArea = sqrt ( hsquare ( hsquare \/ 2.0 ) ) NEW_LINE return 0.5 * height NEW_LINE if ( area > maxArea ) : NEW_LINE INDENT print ( \" Not ▁ possible \" ) NEW_LINE return NEW_LINE DEDENT low = 0.0 NEW_LINE high = sideForMaxArea NEW_LINE base = 0.0 NEW_LINE while ( abs ( high - low ) > eps ) : NEW_LINE INDENT base = ( low + high ) \/ 2.0 NEW_LINE if ( getArea ( base , coenuse ) >= area ) : NEW_LINE INDENT high = base NEW_LINE DEDENT else : NEW_LINE INDENT low = base NEW_LINE DEDENT DEDENT height = math . sqrt ( hsquare - base * base ) NEW_LINE print ( \" { } \" . format ( base ) , round ( height , 2 ) ) ) NEW_LINE"],"references":["import math NEW_LINE def getArea ( base , hypotenuse ) : NEW_LINE INDENT height = math . sqrt ( hypotenuse * hypotenuse - base * base ) ; NEW_LINE return 0.5 * base * height NEW_LINE DEDENT def printRightAngleTriangle ( hypotenuse , area ) : NEW_LINE INDENT hsquare = hypotenuse * hypotenuse NEW_LINE sideForMaxArea = math . sqrt ( hsquare \/ 2.0 ) NEW_LINE maxArea = getArea ( sideForMaxArea , hypotenuse ) NEW_LINE if ( area > maxArea ) : NEW_LINE INDENT print ( \" Not ▁ possiblen \" ) NEW_LINE return NEW_LINE DEDENT low = 0.0 NEW_LINE high = sideForMaxArea NEW_LINE while ( abs ( high - low ) > 1e-6 ) : NEW_LINE INDENT base = ( low + high ) \/ 2.0 NEW_LINE if ( getArea ( base , hypotenuse ) >= area ) : NEW_LINE INDENT high = base NEW_LINE DEDENT else : NEW_LINE INDENT low = base NEW_LINE DEDENT DEDENT height = math . ceil ( math . sqrt ( hsquare - base * base ) ) NEW_LINE base = math . floor ( base ) NEW_LINE print ( base , height ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT hypotenuse = 5 NEW_LINE area = 6 NEW_LINE printRightAngleTriangle ( hypotenuse , area ) NEW_LINE DEDENT"],"bleu":0.5817737335893233,"rouge_l":0.7021444339325132}
{"id":714,"predictions":["def Retder ( str , R ) : NEW_LINE INDENT l = len ( str ) NEW_LINERem = 0 NEW_LINE for i in range ( lenn ) : NEW_LINE INDENT Num =Rem * 10 + ( ord ( str [ i ] ) - ord ( '0' ) ) NEW_LINE rem = Num % R NEW_LINE DEDENT returnRem NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \"135892343565656546 NEW_LINE R = 13 NEW_LINE print ( Reder ( str , R ) ) NEW_LINE DEDENT"],"references":["def Remainder ( str , R ) : NEW_LINE INDENT l = len ( str ) NEW_LINE Rem = 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT Num = Rem * 10 + ( ord ( str [ i ] ) - ord ( '0' ) ) NEW_LINE Rem = Num % R NEW_LINE DEDENT return Rem NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \"13589234356546756\" NEW_LINE R = 13 NEW_LINE print ( Remainder ( str , R ) ) NEW_LINE DEDENT"],"bleu":0.7008917684482282,"rouge_l":0.8744755244755245}
{"id":715,"predictions":["def xorGivenSetBits ( arr , n , k ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( bin ( arr [ i ] ) . count ( '1' ) ) : NEW_LINE INDENT v . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT result = v [ 0 ] NEW_LINE for i in range ( 1 , len ( v ) ) : NEW_LINE INDENT result = result ^ v [ i ] NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 13 , 1 , 19 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE print ( xorGivenSetBits ( arr , n , k ) ) NEW_LINE DEDENT"],"references":["def xorGivenSetBits ( arr , n , k ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( bin ( arr [ i ] ) . count ( '1' ) == k ) : NEW_LINE INDENT v . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT result = v [ 0 ] NEW_LINE for i in range ( 1 , len ( v ) , 1 ) : NEW_LINE INDENT result = result ^ v [ i ] NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 13 , 1 , 19 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE print ( xorGivenSetBits ( arr , n , k ) ) NEW_LINE DEDENT"],"bleu":0.8771902696538065,"rouge_l":0.9548059964726632}
{"id":716,"predictions":["def addBinaryUtil ( a , b ) : NEW_LINE INDENT result = \" \" ; NEW_LINE s = 0 ; NEW_LINE i = len ( a ) - 1 ; j = len ( b ) - 1 ; NEW_LINE while ( i >= 0 or j >= 0 or s == 1 ) : NEW_LINE INDENT if ( i >= 0 ) : NEW_LINE INDENT s [ i ] = ord ( a [ i ] ) - ord ( '0' ) ; NEW_LINE DEDENT else : NEW_LINE INDENT s += ( ord ( b [ j ] ) - ord ( '0' ) ) ; NEW_LINE DEDENT result = s % 2 + result ; NEW_LINE s \/\/= 2 ; NEW_LINE i -= 1 ; NEW_LINE j -= 1 ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT def addBinary ( arr , n ) : NEW_LINE INDENT result = \" \" ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT result = addBinaryUtil ( result , arr [ i ] ) ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ \"1\" , \"10\" , \"11\" ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( addBinary ( arr , n ) ) ; NEW_LINE DEDENT"],"references":["def addBinaryUtil ( a , b ) : NEW_LINE INDENT result = \" \" ; NEW_LINE s = 0 ; NEW_LINE i = len ( a ) - 1 ; NEW_LINE j = len ( b ) - 1 ; NEW_LINE while ( i >= 0 or j >= 0 or s == 1 ) : NEW_LINE INDENT s += ( ord ( a [ i ] ) - ord ( '0' ) ) if ( i >= 0 ) else 0 ; NEW_LINE s += ( ord ( b [ j ] ) - ord ( '0' ) ) if ( j >= 0 ) else 0 ; NEW_LINE result = chr ( s % 2 + ord ( '0' ) ) + result ; NEW_LINE s \/\/= 2 ; NEW_LINE i -= 1 ; NEW_LINE j -= 1 ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT def addBinary ( arr , n ) : NEW_LINE INDENT result = \" \" ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT result = addBinaryUtil ( result , arr [ i ] ) ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT arr = [ \"1\" , \"10\" , \"11\" ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( addBinary ( arr , n ) ) ; NEW_LINE"],"bleu":0.8271132444668681,"rouge_l":0.8664772727272728}
{"id":717,"predictions":["def absComplement ( arr1 , arr2 , n , m ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE while ( i < n and j < m ) : NEW_LINE INDENT if ( arr1 [ i ] < arr2 [ j ] ) : NEW_LINE INDENT print ( arr1 [ i ] , end = \" ▁ \" ) NEW_LINE i += 1 NEW_LINE DEDENT elif ( arr1 [ i ] > arr2 [ j ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT elif ( arr1 [ i ] == arr2 [ j ] ) : NEW_LINE INDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT while ( i < n ) : NEW_LINE INDENT print ( arr1 [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr1 = [ 3 , 6 , 10 , 12 , 15 ] NEW_LINE arr2 = [ 1 , 3 , 5 , 10 , 16 ] NEW_LINE n = len ( arr1 ) NEW_LINE m = len ( arr2 ) NEW_LINE computeComplement ( arr1 , arr2 , n , m ) NEW_LINE DEDENT"],"references":["def relativeComplement ( arr1 , arr2 , n , m ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE while ( i < n and j < m ) : NEW_LINE INDENT if ( arr1 [ i ] < arr2 [ j ] ) : NEW_LINE INDENT print ( arr1 [ i ] , \" ▁ \" , end = \" \" ) NEW_LINE i += 1 NEW_LINE DEDENT elif ( arr1 [ i ] > arr2 [ j ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT elif ( arr1 [ i ] == arr2 [ j ] ) : NEW_LINE INDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT while ( i < n ) : NEW_LINE INDENT print ( arr1 [ i ] , \" ▁ \" , end = \" \" ) NEW_LINE DEDENT DEDENT arr1 = [ 3 , 6 , 10 , 12 , 15 ] NEW_LINE arr2 = [ 1 , 3 , 5 , 10 , 16 ] NEW_LINE n = len ( arr1 ) NEW_LINE m = len ( arr2 ) NEW_LINE relativeComplement ( arr1 , arr2 , n , m ) NEW_LINE"],"bleu":0.8810286301597864,"rouge_l":0.9340283433784005}
{"id":718,"predictions":["s = \" ABCCD \" NEW_LINE u = 0 NEW_LINE n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] >= \"1\" ) : NEW_LINE INDENT u [ ord ( s [ i ] ) - 65 ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT u [ ord ( s [ i ] ) - 97 ] -= 1 NEW_LINE DEDENT DEDENT f1 = True NEW_LINE po = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( u [ i ] > 0 ) : NEW_LINE INDENT po += u [ i ] NEW_LINE DEDENT if ( u == 0 and ne == 0 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT elif ( po == 1 and ne == 0 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT elif ( po == 0 and ne == - 1 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT elif ( po == 0 and ne == - 1 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"references":["s = \" ABCdcba \" NEW_LINE u = [ 0 ] * 26 NEW_LINE n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] . isupper ( ) ) : NEW_LINE INDENT u [ ord ( s [ i ] ) - 65 ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT u [ ord ( s [ i ] ) - 97 ] -= 1 NEW_LINE DEDENT DEDENT fl = True NEW_LINE po = 0 NEW_LINE ne = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( u [ i ] > 0 ) : NEW_LINE INDENT po += u [ i ] NEW_LINE DEDENT if ( u [ i ] < 0 ) : NEW_LINE INDENT ne += u [ i ] NEW_LINE DEDENT DEDENT if ( po == 0 and ne == 0 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT elif ( po == 1 and ne == 0 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT elif ( po == 0 and ne == - 1 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"],"bleu":0.8370967402555847,"rouge_l":0.8818613056245765}
{"id":719,"predictions":["def isPalindrome ( s ) : NEW_LINE INDENT i = 0 NEW_LINE j = len ( s ) - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT if ( s [ i ] != s [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def getIndex ( S1 , S2 , n ) : NEW_LINE INDENT S = \" \" NEW_LINE for i in range ( n ) : NEW_LINE INDENT S = S + S1 [ i ] NEW_LINE temp = \" \" NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT temp += S2 [ j ] NEW_LINE DEDENT if ( isPalindrome ( S + temp ) ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S1 = \" abcdf \" NEW_LINE S2 = \" sfgba \" NEW_LINE n = len ( S1 ) NEW_LINE print ( getIndex ( S1 , S2 , n ) ) NEW_LINE DEDENT"],"references":["def isPalindrome ( s ) : NEW_LINE INDENT i = 0 ; NEW_LINE j = len ( s ) - 1 ; NEW_LINE while ( i < j ) : NEW_LINE INDENT if ( s [ i ] is not s [ j ] ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT i += 1 ; NEW_LINE j -= 1 ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT def getIndex ( S1 , S2 , n ) : NEW_LINE INDENT S = \" \" ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT S = S + S1 [ i ] ; NEW_LINE Temp = \" \" ; NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT Temp += S2 [ j ] ; NEW_LINE DEDENT if ( isPalindrome ( S + Temp ) ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT S1 = \" abcdf \" ; S2 = \" sfgba \" ; NEW_LINE n = len ( S1 ) ; NEW_LINE print ( getIndex ( S1 , S2 , n ) ) ; NEW_LINE"],"bleu":0.7283263548473583,"rouge_l":0.8955363204344875}
{"id":720,"predictions":["def XorSum ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] % 2 != 0 ) : NEW_LINE INDENT result += arr [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT arr = [ 1 , 2 , 6 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( XorSum ( arr , n ) ) NEW_LINE"],"references":["def XorSum ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 != 0 ) : NEW_LINE INDENT result += arr [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT arr = [ 1 , 2 , 6 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( XorSum ( arr , n ) ) NEW_LINE"],"bleu":0.958789574753965,"rouge_l":0.9903362968689602}
{"id":721,"predictions":["def count ( arr , n , x ) : NEW_LINE INDENT if ( x == 1 ) : NEW_LINE INDENT ans = pow ( 2 , n ) - 1 ; NEW_LINE return ans ; NEW_LINE DEDENT count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % x == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT ans = pow ( 2 , count ) - 1 ; NEW_LINE return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 4 , 3 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE x = 1 ; NEW_LINE print ( count ( arr , n , x ) ) ; NEW_LINE DEDENT"],"references":["def count ( arr , n , x ) : NEW_LINE INDENT if ( x == 1 ) : NEW_LINE INDENT ans = pow ( 2 , n ) - 1 NEW_LINE return ans ; NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % x == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT ans = pow ( 2 , count ) - 1 NEW_LINE return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 4 , 3 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE x = 1 NEW_LINE print ( count ( arr , n , x ) ) NEW_LINE DEDENT"],"bleu":0.8415871312754377,"rouge_l":0.9734042553191491}
{"id":722,"predictions":["def removeSpecialCharacter ( s ) : NEW_LINE INDENT j = 0 ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( ( ord ( s [ i ] ) >= ' A ' and s [ i ] <= ' Z ' ) or ( s [ i ] >= ' a ' and s [ i ] <= ' z ' ) ) : NEW_LINE INDENT s [ j ] = s [ i ] ; NEW_LINE j += 1 ; NEW_LINE DEDENT DEDENT print ( s [ : j ] ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" $ Gee * k ; s . . . . fo , ▁ r ' Ge ^ eks ? \" ; NEW_LINE s = [ : i ] ; NEW_LINE removeSpecialCharacterCharacter ( s ) ; NEW_LINE DEDENT"],"references":["def removeSpecialCharacter ( s ) : NEW_LINE INDENT t = \" \" NEW_LINE for i in s : NEW_LINE INDENT if ( i >= ' A ' and i <= ' Z ' ) or ( i >= ' a ' and i <= ' z ' ) : NEW_LINE INDENT t += i NEW_LINE DEDENT DEDENT print ( t ) NEW_LINE DEDENT s = \" $ Gee * k ; s . . fo , ▁ r ' Ge ^ eks ? \" NEW_LINE removeSpecialCharacter ( s ) NEW_LINE"],"bleu":0.3695340645137307,"rouge_l":0.7091036414565828}
{"id":723,"predictions":["import math NEW_LINE def calculate ( a , b , n , m ) : NEW_LINE INDENT mul = 1 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if ( b [ i ] != 0 ) : NEW_LINE INDENT mul = mul * b [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT x = floor ( a [ i ] \/ mul ) NEW_LINE print ( x , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ _ \" : NEW_LINE INDENT a = [ 5 , 100 , 8 ] NEW_LINE b = [ 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE calculate ( a , b , n , m ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def calculate ( a , b , n , m ) : NEW_LINE INDENT mul = 1 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if ( b [ i ] != 0 ) : NEW_LINE INDENT mul = mul * b [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT x = math . floor ( a [ i ] \/ mul ) NEW_LINE print ( x , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT a = [ 5 , 100 , 8 ] NEW_LINE b = [ 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE calculate ( a , b , n , m ) NEW_LINE"],"bleu":0.8768597246572546,"rouge_l":0.9474055771267207}
{"id":724,"predictions":["prime = [ 1 for i in range ( maxEle , prime ) ] NEW_LINE def sieve ( maxEle , prime ) : NEW_LINE INDENT prime [ 0 ] , prime [ 1 ] = 1 , 1 NEW_LINE for i in range ( 2 , int ( math . sqrt ( maxEle ) ) ) : NEW_LINE INDENT if ( prime [ i ] == 0 ) : NEW_LINE INDENT for j in range ( 2 * i , maxEle + 1 , i ) : NEW_LINE INDENT prime [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT def digitSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT sum += n % 10 NEW_LINE n = int ( n \/ 10 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT def printAdditivePrime ( arr , n ) : NEW_LINE INDENT maxEle = max ( arr ) NEW_LINE prime = [ 0 for i in range ( maxEle + 1 ) ] NEW_LINE sieve ( maxEle , prime ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] == 0 ) : NEW_LINE INDENT sum = digitSum ( arr [ i ] ) NEW_LINE if ( prime [ sum ] == 0 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT DEDENT a = [ 2 , 4 , 6 , 11 , 12 , 18 , 7 ] NEW_LINE n = len ( a ) NEW_LINE printAdditivePrime ( a , n ) NEW_LINE"],"references":["from math import sqrt NEW_LINE def sieve ( maxEle , prime ) : NEW_LINE INDENT prime [ 0 ] , prime [ 1 ] = 1 , 1 NEW_LINE for i in range ( 2 , int ( sqrt ( maxEle ) ) + 1 ) : NEW_LINE INDENT if ( not prime [ i ] ) : NEW_LINE INDENT for j in range ( 2 * i , maxEle + 1 , i ) : NEW_LINE INDENT prime [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT def digitSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n ) : NEW_LINE INDENT sum += n % 10 NEW_LINE n = n \/\/ 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT def printAdditivePrime ( arr , n ) : NEW_LINE INDENT maxEle = max ( arr ) NEW_LINE prime = [ 0 ] * ( maxEle + 1 ) NEW_LINE sieve ( maxEle , prime ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] == 0 ) : NEW_LINE INDENT sum = digitSum ( arr [ i ] ) NEW_LINE if ( prime [ sum ] == 0 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 2 , 4 , 6 , 11 , 12 , 18 , 7 ] NEW_LINE n = len ( a ) NEW_LINE printAdditivePrime ( a , n ) NEW_LINE DEDENT"],"bleu":0.8449508156993688,"rouge_l":0.9049470598791649}
{"id":725,"predictions":["def check ( n , m ) : NEW_LINE INDENT if ( m % n == 0 ) : NEW_LINE INDENT print ( ' YES ' ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) ; NEW_LINE DEDENT DEDENT n = 5 ; NEW_LINE m = 10 ; NEW_LINE check ( n , m ) ; NEW_LINE"],"references":["def check ( n , m ) : NEW_LINE INDENT if ( m % n == 0 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT n = 5 NEW_LINE m = 10 NEW_LINE check ( n , m ) NEW_LINE"],"bleu":0.6851634050490926,"rouge_l":0.8975569128262076}
{"id":726,"predictions":["def findPowerOfP ( N , p ) : NEW_LINE INDENT count = 0 ; NEW_LINE r = p ; NEW_LINE while ( r <= N ) : NEW_LINE INDENT count += ( N \/\/ r ) ; NEW_LINE r = r * p ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT def primeFactorsofB ( B ) : NEW_LINE INDENT ans = [ ] ; NEW_LINE for i in range ( 2 , r ) : NEW_LINE INDENT if ( B % i == 0 ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( B % i == 0 ) : NEW_LINE INDENT B = B \/\/ i ; NEW_LINE count += 1 ; NEW_LINE DEDENT ans . append ( [ i , count ] ) ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT def largestPowerofB ( N , B ) : NEW_LINE INDENT vec = [ ] ; NEW_LINE vec = primeFactorsofB ( B ) ; NEW_LINE ans = sys . maxsize ; NEW_LINE for i in range ( len ( vec ) ) : NEW_LINE INDENT ans = min ( ans , findPowerOfP ( N , vec [ i ] [ 0 ] \/\/ vec [ 1 ] ) ) ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( largestPowerOfB ( 5 , 2 ) ) ; NEW_LINE print ( largestPowerOfB ( 6 , 9 ) ) ; NEW_LINE DEDENT"],"references":["import sys NEW_LINE def findPowerOfP ( N , p ) : NEW_LINE INDENT count = 0 NEW_LINE r = p NEW_LINE while ( r <= N ) : NEW_LINE INDENT count += int ( N \/ r ) NEW_LINE r = r * p NEW_LINE DEDENT return count NEW_LINE DEDENT def primeFactorsofB ( B ) : NEW_LINE INDENT ans = [ ] NEW_LINE i = 2 NEW_LINE while ( B != 1 ) : NEW_LINE INDENT if ( B % i == 0 ) : NEW_LINE INDENT count = 0 NEW_LINE while ( B % i == 0 ) : NEW_LINE INDENT B = int ( B \/ i ) NEW_LINE count += 1 NEW_LINE DEDENT ans . append ( ( i , count ) ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT def largestPowerOfB ( N , B ) : NEW_LINE INDENT vec = [ ] NEW_LINE vec = primeFactorsofB ( B ) NEW_LINE ans = sys . maxsize NEW_LINE ans = min ( ans , int ( findPowerOfP ( N , vec [ 0 ] [ 0 ] ) \/ vec [ 0 ] [ 1 ] ) ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( largestPowerOfB ( 5 , 2 ) ) NEW_LINE print ( largestPowerOfB ( 6 , 9 ) ) NEW_LINE DEDENT"],"bleu":0.6159087796981381,"rouge_l":0.8384163019693653}
{"id":727,"predictions":["def printCombination ( n ) : NEW_LINE INDENT print ( 1 , end = \" ▁ \" ) NEW_LINE if ( ( n - 2 ) % 3 == 0 ) : NEW_LINE INDENT print ( 2 , end = \" ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT printCombination ( n ) NEW_LINE"],"references":["def printCombination ( n ) : NEW_LINE INDENT print ( \"1 ▁ \" , end = \" \" ) ; NEW_LINE if ( ( n - 2 ) % 3 == 0 ) : NEW_LINE INDENT print ( \"2\" , n - 3 , end = \" \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \"1\" , ( n - 2 ) , end = \" \" ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 233 ; NEW_LINE printCombination ( n ) ; NEW_LINE DEDENT"],"bleu":0.42209830503956186,"rouge_l":0.7135849056603775}
{"id":728,"predictions":["from collections import defaultdict NEW_LINE import math NEW_LINE def createHash ( hash1 , maxElement ) : NEW_LINE INDENT prev , curr = 0 , 1 NEW_LINE hash1 . add ( prev ) NEW_LINE hash1 . add ( curr ) NEW_LINE while ( curr <= maxElement ) : NEW_LINE INDENT temp = curr + prev NEW_LINE if ( temp <= maxElement ) : NEW_LINE INDENT hash1 . add ( temp ) NEW_LINE DEDENT prev = curr NEW_LINE curr = temp NEW_LINE DEDENT DEDENT def countFibonacciDivisors ( n ) : NEW_LINE INDENT hash1 = set ( ) NEW_LINE createHash ( hash1 , n ) NEW_LINE cnt = 0 NEW_LINE for i in range ( 1 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n \/\/ i == i ) and ( n \/\/ i ) in hash1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( n \/\/ i ) in hash1 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT if ( n \/\/ ( n \/\/ i ) in hash1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 12 NEW_LINE print ( countFibonacciDivisors ( n ) ) NEW_LINE DEDENT"],"references":["from math import sqrt , ceil , floor NEW_LINE def createHash ( maxElement ) : NEW_LINE INDENT prev = 0 NEW_LINE curr = 1 NEW_LINE d = dict ( ) NEW_LINE d [ prev ] = 1 NEW_LINE d [ curr ] = 1 NEW_LINE while ( curr <= maxElement ) : NEW_LINE INDENT temp = curr + prev NEW_LINE d [ temp ] = 1 NEW_LINE prev = curr NEW_LINE curr = temp NEW_LINE DEDENT return d NEW_LINE DEDENT def countFibonacciDivisors ( n ) : NEW_LINE INDENT hash = createHash ( n ) NEW_LINE cnt = 0 NEW_LINE for i in range ( 1 , ceil ( sqrt ( n ) ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( ( n \/\/ i == i ) and ( n \/\/ i in hash ) ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( n \/\/ i in hash ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT if ( n \/\/ ( n \/\/ i ) in hash ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT n = 12 NEW_LINE print ( countFibonacciDivisors ( n ) ) NEW_LINE"],"bleu":0.6210643312269406,"rouge_l":0.777785966981132}
{"id":729,"predictions":["MAX = 1000000 NEW_LINE prime = [ True for i in range ( MAX + 1 ) ] NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE prime [ 0 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= MAX : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT def SumOfKthPrimes ( arr , n , k ) : NEW_LINE INDENT c = 0 NEW_LINE Sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] ) : NEW_LINE INDENT c += 1 NEW_LINE if ( c % k == 0 ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE c = 0 NEW_LINE DEDENT DEDENT DEDENT print ( Sum ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE arr = [ 2 , 3 , 5 , 7 , 11 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE SumOfKthPrimes ( arr , n , k ) NEW_LINE DEDENT"],"references":["MAX = 100000 ; NEW_LINE prime = [ True ] * ( MAX + 1 ) ; NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 1 ] = False ; NEW_LINE prime [ 0 ] = False ; NEW_LINE p = 2 ; NEW_LINE while ( p * p <= MAX ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT i = p * 2 ; NEW_LINE while ( i <= MAX ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE i += p ; NEW_LINE DEDENT DEDENT p += 1 ; NEW_LINE DEDENT DEDENT def SumOfKthPrimes ( arr , n , k ) : NEW_LINE INDENT c = 0 ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] ) : NEW_LINE INDENT c += 1 ; NEW_LINE if ( c % k == 0 ) : NEW_LINE INDENT sum += arr [ i ] ; NEW_LINE c = 0 ; NEW_LINE DEDENT DEDENT DEDENT print ( sum ) ; NEW_LINE DEDENT SieveOfEratosthenes ( ) ; NEW_LINE arr = [ 2 , 3 , 5 , 7 , 11 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE k = 2 ; NEW_LINE SumOfKthPrimes ( arr , n , k ) ; NEW_LINE"],"bleu":0.6559962012755557,"rouge_l":0.8421576999715341}
{"id":730,"predictions":["def sieveOfEratosthenes ( N , s ) : NEW_LINE INDENT prime = [ False ] * ( N + 1 ) ; NEW_LINE for i in range ( 2 , N + 1 , 2 ) : NEW_LINE INDENT s [ i ] = 2 ; NEW_LINE DEDENT for i in range ( 3 , N + 1 , 2 ) : NEW_LINE INDENT if ( prime [ i ] == False ) : NEW_LINE INDENT s [ i * j ] = i ; NEW_LINE for j in range ( i , int ( sqrt ( N ) ) + 1 , 2 ) : NEW_LINE INDENT if ( prime [ i * j ] == False ) : NEW_LINE INDENT prime [ i * j ] = True ; NEW_LINE s [ i * j ] = i ; NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def generatePrimeFactors ( N ) : NEW_LINE INDENT s = [ 0 ] * ( N + 1 ) ; NEW_LINE sieveOfEratosthenes ( N , s ) ; NEW_LINE print ( \" Fact ▁ Power \" ) ; NEW_LINE curr = s [ N ] ; NEW_LINE cnt = 1 ; NEW_LINE while ( N > 1 ) : NEW_LINE INDENT N \/\/= s [ N ] ; NEW_LINE if ( curr == s [ N ] ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE continue ; NEW_LINE DEDENT print ( curr , \" \\t \" ) ; NEW_LINE curr = s [ N ] ; NEW_LINE cnt = 1 ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 360 ; NEW_LINE generatePrimeFactors ( N ) ; NEW_LINE DEDENT"],"references":["def sieveOfEratosthenes ( N , s ) : NEW_LINE INDENT prime = [ False ] * ( N + 1 ) NEW_LINE for i in range ( 2 , N + 1 , 2 ) : NEW_LINE INDENT s [ i ] = 2 NEW_LINE DEDENT for i in range ( 3 , N + 1 , 2 ) : NEW_LINE INDENT if ( prime [ i ] == False ) : NEW_LINE INDENT s [ i ] = i NEW_LINE for j in range ( i , int ( N \/ i ) + 1 , 2 ) : NEW_LINE INDENT if ( prime [ i * j ] == False ) : NEW_LINE INDENT prime [ i * j ] = True NEW_LINE s [ i * j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def generatePrimeFactors ( N ) : NEW_LINE INDENT s = [ 0 ] * ( N + 1 ) NEW_LINE sieveOfEratosthenes ( N , s ) NEW_LINE print ( \" Factor ▁ Power \" ) NEW_LINE curr = s [ N ] NEW_LINE cnt = 1 NEW_LINE while ( N > 1 ) : NEW_LINE INDENT N \/\/= s [ N ] NEW_LINE if ( curr == s [ N ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE continue NEW_LINE DEDENT print ( str ( curr ) + \" \\t \" + str ( cnt ) ) NEW_LINE curr = s [ N ] NEW_LINE cnt = 1 NEW_LINE DEDENT DEDENT N = 360 NEW_LINE generatePrimeFactors ( N ) NEW_LINE"],"bleu":0.7371388931489714,"rouge_l":0.9149077713940127}
{"id":731,"predictions":["import math NEW_LINE def nearest ( n ) : NEW_LINE INDENT prevSquare = math . sqrt ( n ) NEW_LINE nextSquare = prevSquare + 1 NEW_LINE prevSquare = prevSquare * prevSquare NEW_LINE nextSquare = nextSquare * nextSquare NEW_LINE return ( n - prevSquare - n ) if ( n - prevSquare ) < ( nextSquare - n ) else ( nextSquare - n ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 14 NEW_LINE print ( nearest ( n ) ) NEW_LINE n = 16 NEW_LINE print ( nearest ( n ) ) NEW_LINE n = 18 NEW_LINE print ( nearest ( n ) ) NEW_LINE DEDENT"],"references":["from math import sqrt NEW_LINE def nearest ( n ) : NEW_LINE INDENT prevSquare = int ( sqrt ( n ) ) ; NEW_LINE nextSquare = prevSquare + 1 ; NEW_LINE prevSquare = prevSquare * prevSquare ; NEW_LINE nextSquare = nextSquare * nextSquare ; NEW_LINE ans = ( prevSquare - n ) if ( n - prevSquare ) < ( nextSquare - n ) else ( nextSquare - n ) ; NEW_LINE return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 14 ; NEW_LINE print ( nearest ( n ) ) ; NEW_LINE n = 16 ; NEW_LINE print ( nearest ( n ) ) ; NEW_LINE n = 18 ; NEW_LINE print ( nearest ( n ) ) ; NEW_LINE DEDENT"],"bleu":0.6228318041825327,"rouge_l":0.8569198751300728}
{"id":732,"predictions":["def checkIfSort ( arr , n ) : NEW_LINE INDENT minEle = 10 ** 9 NEW_LINE maxEle = - ( 2 ** 9 ) NEW_LINE minIndex = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < minEle ) : NEW_LINE INDENT minEle = arr [ i ] NEW_LINE minIndex = i NEW_LINE DEDENT DEDENT flag1 = True NEW_LINE for i in range ( 1 , minIndex ) : NEW_LINE INDENT if ( arr [ i ] < arr [ i - 1 ] ) : NEW_LINE INDENT flag1 = False NEW_LINE break NEW_LINE DEDENT DEDENT flag2 = True NEW_LINE for i in range ( minIndex + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] < arr [ i - 1 ] ) : NEW_LINE INDENT flag2 = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag1 and flag2 and ( arr [ n - 1 ] < arr [ minIndex - 1 ] ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT arr = [ 3 , 4 , 5 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE checkIfSortRotated ( arr , n ) ; NEW_LINE"],"references":["import sys NEW_LINE def checkIfSortRotated ( arr , n ) : NEW_LINE INDENT minEle = sys . maxsize NEW_LINE maxEle = - sys . maxsize - 1 NEW_LINE minIndex = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] < minEle : NEW_LINE INDENT minEle = arr [ i ] NEW_LINE minIndex = i NEW_LINE DEDENT DEDENT flag1 = 1 NEW_LINE for i in range ( 1 , minIndex ) : NEW_LINE INDENT if arr [ i ] < arr [ i - 1 ] : NEW_LINE INDENT flag1 = 0 NEW_LINE break NEW_LINE DEDENT DEDENT flag2 = 2 NEW_LINE for i in range ( minIndex + 1 , n ) : NEW_LINE INDENT if arr [ i ] < arr [ i - 1 ] : NEW_LINE INDENT flag2 = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag1 and flag2 and arr [ n - 1 ] < arr [ minIndex - 1 ] ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT arr = [ 3 , 4 , 5 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE checkIfSortRotated ( arr , n ) NEW_LINE"],"bleu":0.8063725168766869,"rouge_l":0.9162700773349197}
{"id":733,"predictions":["def printSquares ( n ) : NEW_LINE INDENT square = 0 ; NEW_LINE prev_x = 0 ; NEW_LINE for x in range ( n ) : NEW_LINE INDENT square = ( square + x + prev_x ) ; NEW_LINE print ( square , end = \" ▁ \" ) ; NEW_LINE prev_x = x ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 ; NEW_LINE printSquares ( n ) ; NEW_LINE DEDENT"],"references":["def printSquares ( n ) : NEW_LINE INDENT square = 0 ; prev_x = 0 ; NEW_LINE for x in range ( 0 , n ) : NEW_LINE INDENT square = ( square + x + prev_x ) NEW_LINE print ( square , end = \" ▁ \" ) NEW_LINE prev_x = x NEW_LINE DEDENT DEDENT n = 5 ; NEW_LINE printSquares ( n ) ; NEW_LINE"],"bleu":0.6660224811218892,"rouge_l":0.8836639179852909}
{"id":734,"predictions":["from math import gcd NEW_LINE def solveProsplit ( a , b1 , b2 , c ) : NEW_LINE INDENT A = a * b2 NEW_LINE B = b1 * b2 NEW_LINE C = gcd ( gcd ( a , b ) , C ) NEW_LINE print ( A \/\/ gcd , \" : \" , C \/\/ gcd , \" : \" , C \/\/ gcd , \" : \" , C \/\/ gcd ) NEW_LINE DEDENT a = 3 NEW_LINE b1 = 4 NEW_LINE b2 = 8 NEW_LINE c = 9 NEW_LINE solveProportion ( a , b1 , b2 , c ) NEW_LINE"],"references":["import math NEW_LINE def solveProportion ( a , b1 , b2 , c ) : NEW_LINE INDENT A = a * b2 NEW_LINE B = b1 * b2 NEW_LINE C = b1 * c NEW_LINE gcd1 = math . gcd ( math . gcd ( A , B ) , C ) NEW_LINE print ( str ( A \/\/ gcd1 ) + \" : \" + str ( B \/\/ gcd1 ) + \" : \" + str ( C \/\/ gcd1 ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 3 NEW_LINE b1 = 4 NEW_LINE b2 = 8 NEW_LINE c = 9 NEW_LINE solveProportion ( a , b1 , b2 , c ) NEW_LINE DEDENT"],"bleu":0.5110311052443824,"rouge_l":0.6974344673731177}
{"id":735,"predictions":["def countPairs ( arr , N ) : NEW_LINE INDENT mp = dict ( ) ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT if arr [ i ] not in mp . keys ( ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 ; NEW_LINE DEDENT DEDENT maxFreq = 0 ; NEW_LINE for it in mp : NEW_LINE INDENT maxFreq = max ( maxFreq , mp [ it ] ) ; NEW_LINE DEDENT print ( N - maxFreq ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 8 , 5 , 9 , 8 , 7 , 5 , 7 , 5 , 7 , 7 ] ; NEW_LINE N = len ( arr ) ; NEW_LINE countPairs ( arr , N ) ; NEW_LINE DEDENT"],"references":["def countPairs ( arr , N ) : NEW_LINE INDENT M = dict . fromkeys ( arr , 0 ) ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT M [ arr [ i ] ] += 1 ; NEW_LINE DEDENT maxFreq = 0 ; NEW_LINE for it in M . values ( ) : NEW_LINE INDENT maxFreq = max ( maxFreq , it ) ; NEW_LINE DEDENT print ( N - maxFreq ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 8 , 5 , 9 , 8 , 8 , 7 , 7 , 5 , 7 , 7 ] ; NEW_LINE N = len ( arr ) ; NEW_LINE countPairs ( arr , N ) ; NEW_LINE DEDENT"],"bleu":0.705232504798457,"rouge_l":0.8330187631841899}
{"id":736,"predictions":["def numberOfSubarrays ( arr , n ) : NEW_LINE INDENT v = [ 0 ] * ( n + 1 ) NEW_LINE v [ 0 ] = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT v [ i + 1 ] = v [ i ] + arr [ i ] NEW_LINE DEDENT mp = { } NEW_LINE begin , end = 0 , 0 NEW_LINE answer = 0 NEW_LINE while begin < n : NEW_LINE INDENT while ( end < n ) : NEW_LINE INDENT if v [ end + 1 ] not in mp : NEW_LINE INDENT end += 1 NEW_LINE DEDENT v [ v [ end ] ] = 1 NEW_LINE DEDENT answer = answer + end - begin NEW_LINE mp [ v [ begin ] ] -= 1 NEW_LINE DEDENT print ( answer ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 4 , - 6 ] NEW_LINE size = len ( arr ) NEW_LINE numberOfSubarrays ( arr , size ) NEW_LINE DEDENT"],"references":["def numberOfSubarrays ( arr , n ) : NEW_LINE INDENT v = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT v [ i + 1 ] = v [ i ] + arr [ i ] NEW_LINE DEDENT mp = { } NEW_LINE begin , end , answer = 0 , 0 , 0 NEW_LINE mp [ 0 ] = 1 NEW_LINE while ( begin < n ) : NEW_LINE INDENT while ( end < n and ( v [ end + 1 ] ) not in mp ) : NEW_LINE INDENT end += 1 NEW_LINE mp [ v [ end ] ] = 1 NEW_LINE DEDENT answer = answer + end - begin NEW_LINE del mp [ v [ begin ] ] NEW_LINE begin += 1 NEW_LINE DEDENT print ( answer ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 4 , - 6 ] NEW_LINE size = len ( arr ) NEW_LINE numberOfSubarrays ( arr , size ) NEW_LINE DEDENT"],"bleu":0.8377884167185083,"rouge_l":0.8984118534291544}
{"id":737,"predictions":["def minimizeDiff ( arr , n , k ) : NEW_LINE INDENT max = max ( arr ) NEW_LINE min = min ( arr ) NEW_LINE if ( ( max - min ) <= k ) : NEW_LINE INDENT return ( max - min ) NEW_LINE DEDENT avg = ( max + min ) \/\/ 2 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > avg ) : NEW_LINE INDENT arr [ i ] -= k ; NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] += k NEW_LINE DEDENT DEDENT max = max ( arr ) NEW_LINE min = min ( arr ) ; NEW_LINE return ( max - min ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 16 , 12 , 9 , 20 ] NEW_LINE n = 5 NEW_LINE k = 3 NEW_LINE print ( \" Max ▁ height ▁ = ▁ \" , minimizeDiff ( arr , n , k ) ) NEW_LINE DEDENT"],"references":["def minimizeDiff ( arr , n , k ) : NEW_LINE INDENT max_element = max ( arr ) NEW_LINE min_element = min ( arr ) NEW_LINE if ( ( max_element - min_element ) <= k ) : NEW_LINE INDENT return ( max_element - min_element ) NEW_LINE DEDENT avg = ( max_element + min_element ) \/\/ 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > avg ) : NEW_LINE INDENT arr [ i ] -= k NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] += k NEW_LINE DEDENT DEDENT max_element = max ( arr ) NEW_LINE min_element = min ( arr ) NEW_LINE return ( max_element - min_element ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 16 , 12 , 9 , 20 ] NEW_LINE n = 5 NEW_LINE k = 3 NEW_LINE print ( \" Max ▁ height ▁ difference ▁ = \" , minimizeDiff ( arr , n , k ) ) NEW_LINE DEDENT"],"bleu":0.7906727240877474,"rouge_l":0.9184924713731853}
{"id":738,"predictions":["from collections import defaultdict NEW_LINE class Graph : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . graph = defaultdict ( list ) NEW_LINE DEDENT def addEdge ( self , u , v ) : NEW_LINE INDENT self . graph [ u ] . append ( v ) NEW_LINE DEDENT def BFS ( self ) : NEW_LINE INDENT visited = [ False ] * ( v ) NEW_LINE q . append ( s ) NEW_LINE visited [ s ] = True NEW_LINE q . append ( s ) NEW_LINE while len ( self . q ) != 0 : NEW_LINE INDENT s = q [ 0 ] NEW_LINE print ( s , end = \" ▁ \" ) NEW_LINE i = len ( self . graph [ s ] ) NEW_LINE while i < len ( self . graph [ s ] ) : NEW_LINE INDENT if visited [ n ] == False : NEW_LINE INDENT visited [ n ] = True NEW_LINE self . visited [ s ] = True NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT g = Graph ( ) NEW_LINE g . addEdge ( 0 , 1 ) NEW_LINE g . addEdge ( 0 , 2 ) NEW_LINE g . addEdge ( 1 , 2 ) NEW_LINE g . addEdge ( 2 , 0 ) NEW_LINE g . addEdge ( 2 , 3 ) NEW_LINE g . addEdge ( 2 , 3 ) NEW_LINE g . addEdge ( 3 , 3 ) NEW_LINE print ( \" Following ▁ is ▁ Binary ▁ from ▁ ( starting ▁ from ▁ vertex ▁ 2 ) \" ) NEW_LINE g . BFS ( 2 ) NEW_LINE"],"references":["from collections import defaultdict NEW_LINE class Graph : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . graph = defaultdict ( list ) NEW_LINE DEDENT def addEdge ( self , u , v ) : NEW_LINE INDENT self . graph [ u ] . append ( v ) NEW_LINE DEDENT def BFS ( self , s ) : NEW_LINE INDENT visited = [ False ] * ( len ( self . graph ) ) NEW_LINE queue = [ ] NEW_LINE queue . append ( s ) NEW_LINE visited [ s ] = True NEW_LINE while queue : NEW_LINE INDENT s = queue . pop ( 0 ) NEW_LINE print ( s , end = \" ▁ \" ) NEW_LINE for i in self . graph [ s ] : NEW_LINE INDENT if visited [ i ] == False : NEW_LINE INDENT queue . append ( i ) NEW_LINE visited [ i ] = True NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT g = Graph ( ) NEW_LINE g . addEdge ( 0 , 1 ) NEW_LINE g . addEdge ( 0 , 2 ) NEW_LINE g . addEdge ( 1 , 2 ) NEW_LINE g . addEdge ( 2 , 0 ) NEW_LINE g . addEdge ( 2 , 3 ) NEW_LINE g . addEdge ( 3 , 3 ) NEW_LINE print ( \" Following ▁ is ▁ Breadth ▁ First ▁ Traversal \" \" ▁ ( starting ▁ from ▁ vertex ▁ 2 ) \" ) NEW_LINE g . BFS ( 2 ) NEW_LINE"],"bleu":0.7501620123578431,"rouge_l":0.8307758673815246}
{"id":739,"predictions":["from math import ceil NEW_LINE def cal ( n ) : NEW_LINE INDENT res = pow ( int ( ceil ( pow ( 10 , ( n - 1 ) ) , 1 \/ 4 ) ) , 4 ) , 4 ; NEW_LINE return res ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 1 ; NEW_LINE print ( cal ( n ) ) ; NEW_LINE DEDENT"],"references":["from math import * NEW_LINE def cal ( n ) : NEW_LINE INDENT res = pow ( ceil ( ( pow ( pow ( 10 , ( n - 1 ) ) , 1 \/ 4 ) ) ) , 4 ) NEW_LINE return int ( res ) NEW_LINE DEDENT n = 1 NEW_LINE print ( cal ( n ) ) NEW_LINE"],"bleu":0.5619758122737037,"rouge_l":0.7923983642049556}
{"id":740,"predictions":["def bit ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT count += 1 NEW_LINE n = n & ( n - 1 ) NEW_LINE DEDENT return count NEW_LINE DEDENT def maxSumOfBits ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = bit ( arr [ i ] ) NEW_LINE DEDENT inc = arr [ 0 ] NEW_LINE excl = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT excl_new = inccla + arr [ i ] NEW_LINE ex = excl + arr [ i ] NEW_LINE DEDENT return ( inc if ( iss > excl ) else expcl ) NEW_LINE DEDENT arr = [ 1 , 2 , 4 , 5 , 6 , 7 , 20 , 25 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxSumOfBits ( arr , n ) ) NEW_LINE"],"references":["def bit ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT count += 1 NEW_LINE n = n & ( n - 1 ) NEW_LINE DEDENT return count NEW_LINE DEDENT def maxSumOfBits ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = bit ( arr [ i ] ) NEW_LINE DEDENT incl = arr [ 0 ] NEW_LINE excl = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if incl > excl : NEW_LINE INDENT excl_new = incl NEW_LINE DEDENT else : NEW_LINE INDENT excl_new = excl NEW_LINE DEDENT incl = excl + arr [ i ] ; NEW_LINE excl = excl_new NEW_LINE DEDENT if incl > excl : NEW_LINE INDENT return incl NEW_LINE DEDENT else : NEW_LINE INDENT return excl NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 5 , 6 , 7 , 20 , 25 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxSumOfBits ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.6716712422362616,"rouge_l":0.7974905676932524}
{"id":741,"predictions":["import math NEW_LINE def subsetXOR ( arr , n , K ) : NEW_LINE INDENT max_ele = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > max_ele ) : NEW_LINE INDENT max_ele = arr [ i ] NEW_LINE DEDENT DEDENT m = ( 1 << ( max_ele ) ) - 1 NEW_LINE dp = [ [ 0 for x in range ( n + 1 ) ] for y in range ( m + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( m + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( m + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = dp [ i - 1 ] [ j ] NEW_LINE if ( k != 0 ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] += k * dp [ i - 1 ] [ j ^ arr [ i - 1 ] ] [ k - 1 ] NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans += dp [ n ] [ K ] [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 2 , 3 ] NEW_LINE k = 1 NEW_LINE n = len ( arr ) NEW_LINE print ( subsetXOR ( arr , n , k ) ) NEW_LINE"],"references":["from math import log2 NEW_LINE def subsetXOR ( arr , n , K ) : NEW_LINE INDENT max_ele = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > max_ele ) : NEW_LINE INDENT max_ele = arr [ i ] NEW_LINE DEDENT DEDENT m = ( 1 << int ( log2 ( max_ele ) + 1 ) ) - 1 NEW_LINE dp = [ [ [ 0 for i in range ( n + 1 ) ] for j in range ( m + 1 ) ] for k in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( m + 1 ) : NEW_LINE INDENT for k in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = 0 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( m + 1 ) : NEW_LINE INDENT for k in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = dp [ i - 1 ] [ j ] [ k ] NEW_LINE if ( k != 0 ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] += k * dp [ i - 1 ] [ j ^ arr [ i - 1 ] ] [ k - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans += dp [ n ] [ K ] [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 ] NEW_LINE k = 1 NEW_LINE n = len ( arr ) NEW_LINE print ( subsetXOR ( arr , n , k ) ) NEW_LINE DEDENT"],"bleu":0.720480911689793,"rouge_l":0.8481773769259676}
{"id":742,"predictions":["def MaximumHeight ( a , n ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT y = ( i * ( i + 1 ) ) \/ 2 NEW_LINE if ( y < n ) : NEW_LINE INDENT result = i NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 40 , 100 , 20 , 30 ] NEW_LINE n = len ( arr ) NEW_LINE print ( MaximumHeight ( arr , n ) ) NEW_LINE DEDENT"],"references":["def MaximumHeight ( a , n ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT y = ( i * ( i + 1 ) ) \/ 2 NEW_LINE if ( y < n ) : NEW_LINE INDENT result = i NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT arr = [ 40 , 100 , 20 , 30 ] NEW_LINE n = len ( arr ) NEW_LINE print ( MaximumHeight ( arr , n ) ) NEW_LINE"],"bleu":0.8275398947160965,"rouge_l":0.9354317998385796}
{"id":743,"predictions":["def toNegativeBase ( n , negBase ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return \"0\" ; NEW_LINE DEDENT formatted = \" \" ; NEW_LINE while ( n != 0 ) : NEW_LINE INDENT remainder = n % negBase ; NEW_LINE n = int ( n \/ negBase ) ; NEW_LINE if ( remainder < 0 ) : NEW_LINE INDENT remainder += ( - negBase ) ; NEW_LINE n += 1 ; NEW_LINE DEDENT formatted = str ( remainder ) + str ; NEW_LINE DEDENT return converted ; NEW_LINE DEDENT n = 13 ; NEW_LINE negBase = - 2 ; NEW_LINE print ( toNegativeBase ( n , negBase ) ) ; NEW_LINE"],"references":["def toNegativeBase ( n , negBase ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return \"0\" NEW_LINE DEDENT converted = \"01\" NEW_LINE while ( n != 0 ) : NEW_LINE INDENT remainder = n % ( negBase ) NEW_LINE n = int ( n \/ negBase ) NEW_LINE if ( remainder < 0 ) : NEW_LINE INDENT remainder += ( ( - 1 ) * negBase ) NEW_LINE n += 1 NEW_LINE DEDENT converted = str ( remainder ) + converted NEW_LINE DEDENT return converted NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 13 NEW_LINE negBase = - 2 NEW_LINE print ( toNegativeBase ( n , negBase ) ) NEW_LINE DEDENT"],"bleu":0.6227529925028027,"rouge_l":0.8297643097643097}
{"id":744,"predictions":["m , n = 6 , 4 ; NEW_LINE def compareRow ( a1 , a2 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( a1 [ i ] < a2 [ i ] ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT elif ( a1 [ i ] > a2 [ i ] ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT DEDENT return 0 ; NEW_LINE DEDENT def binaryCheck ( ar , arr ) : NEW_LINE INDENT l = 0 ; r = m - 1 ; NEW_LINE while ( l <= r ) : NEW_LINE INDENT mid = ( l + r ) \/\/ 2 ; NEW_LINE temp = compareRow ( ar [ mid ] , arr ) ; NEW_LINE if ( temp == 0 ) : NEW_LINE INDENT return mid + 1 ; NEW_LINE DEDENT elif ( temp == 1 ) : NEW_LINE INDENT l = mid + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT r = mid - 1 ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT mat = [ [ 0 , 0 , 1 , 0 ] , [ 10 , 9 , 22 , 23 ] , [ 40 , 40 , 40 , 40 ] , [ 43 , 44 , 55 , 68 ] , [ 81 , 73 , 100 , 132 ] , [ 100 , 75 , 125 , 133 ] ; NEW_LINE row = [ 10 , 9 , 22 , 23 ] ; NEW_LINE print ( binaryCheck ( mat , row ) ) ; NEW_LINE DEDENT"],"references":["m = 6 ; NEW_LINE n = 4 ; NEW_LINE def compareRow ( a1 , a2 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( a1 [ i ] < a2 [ i ] ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT elif ( a1 [ i ] > a2 [ i ] ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT DEDENT return 0 ; NEW_LINE DEDENT def binaryCheck ( ar , arr ) : NEW_LINE INDENT l = 0 ; r = m - 1 ; NEW_LINE while ( l <= r ) : NEW_LINE INDENT mid = ( l + r ) \/\/ 2 ; NEW_LINE temp = compareRow ( ar [ mid ] , arr ) ; NEW_LINE if ( temp == 0 ) : NEW_LINE INDENT return mid + 1 ; NEW_LINE DEDENT elif ( temp == 1 ) : NEW_LINE INDENT l = mid + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT r = mid - 1 ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT mat = [ [ 0 , 0 , 1 , 0 ] , [ 10 , 9 , 22 , 23 ] , [ 40 , 40 , 40 , 40 ] , [ 43 , 44 , 55 , 68 ] , [ 81 , 73 , 100 , 132 ] , [ 100 , 75 , 125 , 133 ] ] ; NEW_LINE row = [ 10 , 9 , 22 , 23 ] ; NEW_LINE print ( binaryCheck ( mat , row ) ) ; NEW_LINE DEDENT"],"bleu":0.9745248773438072,"rouge_l":0.9853414578063923}
{"id":745,"predictions":["def longestSubArray ( arr , n ) : NEW_LINE INDENT isZeroPresent = False NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT isZeroPresent = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( isZeroPresentPresent ) : NEW_LINE INDENT return n NEW_LINE DEDENT return 0 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 0 , 1 , 2 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE print ( longestSubArray ( arr , n ) ) NEW_LINE DEDENT"],"references":["def longestSubArray ( arr , n ) : NEW_LINE INDENT isZeroPresent = False NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT isZeroPresent = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( isZeroPresent ) : NEW_LINE INDENT return n NEW_LINE DEDENT return 0 NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 0 , 1 , 2 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE print ( longestSubArray ( arr , n ) ) NEW_LINE"],"bleu":0.8175902289864972,"rouge_l":0.9215399610136453}
{"id":746,"predictions":["def PrintMinNumberForPattern ( arr ) : NEW_LINE INDENT curr_max = 0 NEW_LINE last_id = 0 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT noOfNextD = 0 NEW_LINE if ( arr [ i ] == ' I ' ) : NEW_LINE INDENT j = i + 1 NEW_LINE while ( j < len ( arr [ j ] ) and ( arr [ j ] == ' D ' ) ) : NEW_LINE INDENT noOfNextD += 1 NEW_LINE j += 1 NEW_LINE DEDENT if ( i == 0 ) : NEW_LINE INDENT curr_max = noOfNext + 2 NEW_LINE print ( \" { \" , end = \" \" ) NEW_LINE curr_max = curr_max NEW_LINE print ( \" { \" . format ( last_element ) , end = \" \" ) NEW_LINE last_row = curr_max NEW_LINE print ( \" { } ▁ \" . format ( last_element ) , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT curr_max = curr_max + 1 NEW_LINE last_id = curr_max NEW_LINE print ( \" { } ▁ \" . format ( last_id , end = \" \" ) ) NEW_LINE last_id = curr_max - 1 NEW_LINE print ( \" { } ▁ \" . format ( curr_max , end = \" \" ) NEW_LINE last_cont = curr_max - 1 NEW_LINE DEDENT DEDENT print ( ) NEW_LINE print ( ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT printMinNumberForPattern ( \" IID \" ) NEW_LINE DEDENT"],"references":["def PrintMinNumberForPattern ( arr ) : NEW_LINE INDENT curr_max = 0 NEW_LINE last_entry = 0 NEW_LINE i = 0 NEW_LINE while i < len ( arr ) : NEW_LINE INDENT noOfNextD = 0 NEW_LINE if arr [ i ] == \" I \" : NEW_LINE INDENT j = i + 1 NEW_LINE while j < len ( arr ) and arr [ j ] == \" D \" : NEW_LINE INDENT noOfNextD += 1 NEW_LINE j += 1 NEW_LINE DEDENT if i == 0 : NEW_LINE INDENT curr_max = noOfNextD + 2 NEW_LINE last_entry += 1 NEW_LINE print ( \" \" , last_entry , end = \" \" ) NEW_LINE print ( \" \" , curr_max , end = \" \" ) NEW_LINE last_entry = curr_max NEW_LINE DEDENT else : NEW_LINE INDENT curr_max += noOfNextD + 1 NEW_LINE last_entry = curr_max NEW_LINE print ( \" \" , last_entry , end = \" \" ) NEW_LINE DEDENT for k in range ( noOfNextD ) : NEW_LINE INDENT last_entry -= 1 NEW_LINE print ( \" \" , last_entry , end = \" \" ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT elif arr [ i ] == \" D \" : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT j = i + 1 NEW_LINE while j < len ( arr ) and arr [ j ] == \" D \" : NEW_LINE INDENT noOfNextD += 1 NEW_LINE j += 1 NEW_LINE DEDENT curr_max = noOfNextD + 2 NEW_LINE print ( \" \" , curr_max , curr_max - 1 , end = \" \" ) NEW_LINE last_entry = curr_max - 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" \" , last_entry - 1 , end = \" \" ) NEW_LINE last_entry -= 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT print ( ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT PrintMinNumberForPattern ( \" IDID \" ) NEW_LINE PrintMinNumberForPattern ( \" I \" ) NEW_LINE PrintMinNumberForPattern ( \" DD \" ) NEW_LINE PrintMinNumberForPattern ( \" II \" ) NEW_LINE PrintMinNumberForPattern ( \" DIDI \" ) NEW_LINE PrintMinNumberForPattern ( \" IIDDD \" ) NEW_LINE PrintMinNumberForPattern ( \" DDIDDIID \" ) NEW_LINE DEDENT"],"bleu":0.35683494073926586,"rouge_l":0.5667936024371668}
{"id":747,"predictions":["def findNumber ( n ) : NEW_LINE INDENT i = 1 NEW_LINE while ( i <= n ) : NEW_LINE INDENT print ( 3 * i * ( i - 1 ) + 1 , end = \" ▁ \" ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT DEDENT n = 4 ; NEW_LINE findNumber ( n ) ; NEW_LINE"],"references":["def findNumbers ( n ) : NEW_LINE INDENT i = 1 NEW_LINE while ( i <= n ) : NEW_LINE INDENT print ( ( 3 * i * ( i - 1 ) + 1 ) , end = \" ▁ \" ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT n = 4 NEW_LINE findNumbers ( n ) NEW_LINE"],"bleu":0.7422736901012977,"rouge_l":0.919429980816662}
{"id":748,"predictions":["MOD = 1000000007 ; NEW_LINE def number_of_ways ( arr , n , k ) : NEW_LINE INDENT if ( k == 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT dp = [ - 1 ] * ( k + 1 ) ; NEW_LINE dp [ 0 ] = 1 ; NEW_LINE dp [ 1 ] = dp [ 1 ] ; NEW_LINE if ( dp [ 1 ] == - 1 ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT dp [ 0 ] = dp [ 1 ] + dp [ i - 2 ] ; NEW_LINE dp [ i ] = dp [ 1 ] ; NEW_LINE for i in range ( 2 , k + 1 ) : NEW_LINE INDENT if ( dp [ i ] == 0 ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] ; NEW_LINE dp [ i ] %= MOD ; NEW_LINE DEDENT return dp [ k ] ; NEW_LINE DEDENT arr = [ 3 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE k = 6 ; NEW_LINE print ( number_of_ways ( arr , n , k ) ) ; NEW_LINE"],"references":["MOD = 1000000007 ; NEW_LINE def number_of_ways ( arr , n , k ) : NEW_LINE INDENT if ( k == 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT dp = [ - 1 ] * ( k + 1 ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ arr [ i ] ] = 0 ; NEW_LINE DEDENT dp [ 0 ] = 1 ; NEW_LINE dp [ 1 ] = 1 if ( dp [ 1 ] == - 1 ) else dp [ 1 ] ; NEW_LINE for i in range ( 2 , k + 1 ) : NEW_LINE INDENT if ( dp [ i ] == 0 ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] ; NEW_LINE dp [ i ] %= MOD ; NEW_LINE DEDENT return dp [ k ] ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE k = 6 ; NEW_LINE print ( number_of_ways ( arr , n , k ) ) ; NEW_LINE DEDENT"],"bleu":0.8342369897000177,"rouge_l":0.8286756714795838}
{"id":749,"predictions":["import sys NEW_LINE def maxProfit ( prices , n , k ) : NEW_LINE INDENT profit = [ [ 0 for i in range ( k + 1 ) ] for j in range ( k + 1 ) ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT prevDiff = - sys . maxsize - 1 NEW_LINE for j in range ( 1 , n ) : NEW_LINE INDENT prevDiff = max ( prevDiff , profit [ i - 1 ] [ j - 1 ] - prices [ j - 1 ] ) NEW_LINE profit [ i ] [ j ] = max ( profit [ i ] [ j - 1 ] , price [ j ] + prevDiff ) NEW_LINE DEDENT DEDENT return profit [ n - 1 ] [ k ] NEW_LINE DEDENT k = 3 NEW_LINE prices = [ 12 , 14 , 17 , 10 , 14 , 13 , 12 , 15 ] NEW_LINE n = len ( prices ) NEW_LINE print ( \" Maximum ▁ profit ▁ is : \" , maxProfit ( prices , n , k ) ) NEW_LINE"],"references":["def maxProfit ( price , n , k ) : NEW_LINE INDENT profit = [ [ 0 for i in range ( n + 1 ) ] for j in range ( k + 1 ) ] NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT prevDiff = float ( ' - inf ' ) NEW_LINE for j in range ( 1 , n ) : NEW_LINE INDENT prevDiff = max ( prevDiff , profit [ i - 1 ] [ j - 1 ] - price [ j - 1 ] ) NEW_LINE profit [ i ] [ j ] = max ( profit [ i ] [ j - 1 ] , price [ j ] + prevDiff ) NEW_LINE DEDENT DEDENT return profit [ k ] [ n - 1 ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT k = 3 NEW_LINE price = [ 12 , 14 , 17 , 10 , 14 , 13 , 12 , 15 ] NEW_LINE n = len ( price ) NEW_LINE print ( \" Maximum ▁ profit ▁ is : \" , maxProfit ( price , n , k ) ) NEW_LINE DEDENT"],"bleu":0.7814789537610057,"rouge_l":0.8701572378019129}
{"id":750,"predictions":["def originalArray ( greater , n ) : NEW_LINE INDENT temp = [ ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT temp . append ( i ) NEW_LINE DEDENT arr = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT k = n - greater [ i ] - i NEW_LINE arr [ i ] = temp [ k ] NEW_LINE temp [ k ] = temp [ k ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT Arr = [ 6 , 3 , 2 , 1 , 0 , 1 , 0 ] NEW_LINE n = len ( Arr ) NEW_LINE originalArray ( Arr , n ) ; NEW_LINE"],"references":["def originalArray ( greater , n ) : NEW_LINE INDENT temp = [ ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT temp . append ( i ) NEW_LINE DEDENT arr = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT k = n - greater [ i ] - i NEW_LINE arr [ i ] = temp [ k ] NEW_LINE del temp [ k ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 6 , 3 , 2 , 1 , 0 , 1 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE originalArray ( arr , n ) NEW_LINE"],"bleu":0.86071403297054,"rouge_l":0.9236111111111112}
{"id":751,"predictions":["MAX = 1000 NEW_LINE f = [ 0 ] * MAX NEW_LINE def fib ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 1 or n == 2 ) : NEW_LINE INDENT f [ n ] = 1 NEW_LINE DEDENT if ( f [ n ] ) : NEW_LINE INDENT return f [ n ] NEW_LINE DEDENT k = ( n + 1 ) \/\/ 2 if ( n & 1 ) else n \/ 2 NEW_LINE f [ n ] = ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) if ( n & 1 ) else ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ) NEW_LINE return f [ n ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 9 NEW_LINE f = [ 0 ] * MAX NEW_LINE print ( fib ( n ) ) NEW_LINE DEDENT"],"references":["MAX = 1000 NEW_LINE f = [ 0 ] * MAX NEW_LINE def fib ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 1 or n == 2 ) : NEW_LINE INDENT f [ n ] = 1 NEW_LINE return ( f [ n ] ) NEW_LINE DEDENT if ( f [ n ] ) : NEW_LINE INDENT return f [ n ] NEW_LINE DEDENT if ( n & 1 ) : NEW_LINE INDENT k = ( n + 1 ) \/\/ 2 NEW_LINE DEDENT else : NEW_LINE INDENT k = n \/\/ 2 NEW_LINE DEDENT if ( ( n & 1 ) ) : NEW_LINE INDENT f [ n ] = ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT f [ n ] = ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ) NEW_LINE DEDENT return f [ n ] NEW_LINE DEDENT n = 9 NEW_LINE print ( fib ( n ) ) NEW_LINE"],"bleu":0.7613727084078392,"rouge_l":0.7993033670592139}
{"id":752,"predictions":["def getCount ( l , r , p ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE val = p ; NEW_LINE while ( 1 ) : NEW_LINE INDENT a = r \/\/ val ; NEW_LINE b = ( l - 1 ) \/\/ val ; NEW_LINE val *= p ; NEW_LINE if ( ( a - b ) ) : NEW_LINE INDENT cnt += ( a - b ) ; NEW_LINE DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT return cnt ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT l = 2 ; r = 8 ; p = 2 ; NEW_LINE print ( getCount ( l , r , p ) ) ; NEW_LINE DEDENT"],"references":["def getCount ( l , r , p ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE val = p ; NEW_LINE while ( True ) : NEW_LINE INDENT a = r \/\/ val ; NEW_LINE b = ( l - 1 ) \/\/ val ; NEW_LINE val *= p ; NEW_LINE if ( a - b ) : NEW_LINE INDENT cnt += ( a - b ) ; NEW_LINE DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT return int ( cnt ) ; NEW_LINE DEDENT l = 2 ; NEW_LINE r = 8 ; NEW_LINE p = 2 ; NEW_LINE print ( getCount ( l , r , p ) ) ; NEW_LINE"],"bleu":0.793096978626927,"rouge_l":0.9128009794585772}
{"id":753,"predictions":["def findMaxLen ( string ) : NEW_LINE INDENT n = len ( string ) NEW_LINE stk = [ ] NEW_LINE stk . append ( - 1 ) NEW_LINE result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( string [ i ] == ' ( ' ) : NEW_LINE INDENT stk . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT stk . pop ( ) NEW_LINE if ( len ( stk ) != 0 ) : NEW_LINE INDENT result = max ( result , i - stk [ - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT stk . append ( i ) NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" ( ) \" NEW_LINE print ( findMaxLen ( string ) ) NEW_LINE string = \" ( ( ) ) NEW_LINE print ( findMaxLen ( string ) ) NEW_LINE DEDENT"],"references":["def findMaxLen ( string ) : NEW_LINE INDENT n = len ( string ) NEW_LINE stk = [ ] NEW_LINE stk . append ( - 1 ) NEW_LINE result = 0 NEW_LINE for i in xrange ( n ) : NEW_LINE INDENT if string [ i ] == ' ( ' : NEW_LINE INDENT stk . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT stk . pop ( ) NEW_LINE if len ( stk ) != 0 : NEW_LINE INDENT result = max ( result , i - stk [ len ( stk ) - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT stk . append ( i ) NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT string = \" ( ( ( ) ( ) \" NEW_LINE print findMaxLen ( string ) NEW_LINE string = \" ( ) ( ( ) ) ) ) ) \" NEW_LINE print findMaxLen ( string ) NEW_LINE"],"bleu":0.7696520528203203,"rouge_l":0.8859568374757083}
{"id":754,"predictions":["def printbinomial ( max ) : NEW_LINE INDENT for m in range ( max + 1 ) : NEW_LINE INDENT print ( m , end = \" ▁ \" ) NEW_LINE binom = 1 NEW_LINE for x in range ( m + 1 ) : NEW_LINE INDENT if ( m != 0 and x != 0 ) : NEW_LINE INDENT binom = binom * ( m - x + 1 ) \/\/ x NEW_LINE DEDENT print ( binom , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT max = 10 NEW_LINE print binomial ( max ) NEW_LINE DEDENT"],"references":["def printbinomial ( max ) : NEW_LINE INDENT for m in range ( max + 1 ) : NEW_LINE INDENT print ( ' % ▁ 2d ' % m , end = ' ▁ ' ) NEW_LINE binom = 1 NEW_LINE for x in range ( m + 1 ) : NEW_LINE INDENT if m != 0 and x != 0 : NEW_LINE INDENT binom = binom * ( m - x + 1 ) \/ x NEW_LINE DEDENT print ( ' % ▁ 4d ' % binom , end = ' ▁ ' ) NEW_LINE DEDENT print ( \" \\n \" , end = ' ' ) NEW_LINE DEDENT DEDENT max = 10 NEW_LINE printbinomial ( max ) NEW_LINE"],"bleu":0.6416127431180925,"rouge_l":0.7914423740510697}
{"id":755,"predictions":["def getmax ( arr , n , x ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = s + arr [ i ] NEW_LINE DEDENT print ( min ( s , x ) ) NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE x = 5 NEW_LINE arr_size = len ( arr ) NEW_LINE getmax ( arr , arr_size , x ) NEW_LINE"],"references":["def getmax ( arr , n , x ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = s + arr [ i ] NEW_LINE DEDENT print ( min ( s , x ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE x = 5 NEW_LINE arr_size = len ( arr ) NEW_LINE getmax ( arr , arr_size , x ) NEW_LINE DEDENT"],"bleu":0.8213311509844652,"rouge_l":0.9053165508172083}
{"id":756,"predictions":["def isPossible ( w , h , x , y ) : NEW_LINE INDENT if ( x * 2 == w and y * 2 == h ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT w = 1 NEW_LINE h = 2 NEW_LINE x = 1 NEW_LINE y = 2 NEW_LINE if ( isPossible ( w , h , x , y ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def isPossible ( w , h , x , y ) : NEW_LINE INDENT if ( x * 2 == w and y * 2 == h ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT w = 1 NEW_LINE h = 2 NEW_LINE x = 1 NEW_LINE y = 2 NEW_LINE if ( isPossible ( w , h , x , y ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.8429909173602332,"rouge_l":0.9167630057803468}
{"id":757,"predictions":["def dzyx ( x , y ) : NEW_LINE INDENT return ( x + y - 2 ) NEW_LINE DEDENT def rungeKUtil ( x0 , y0 , x , h ) : NEW_LINE INDENT n = ( x - x0 ) \/ h NEW_LINE k1 = y0 NEW_LINE y = y0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT k1 = h * dxy ( x0 , y ) NEW_LINE k2 = h * dcd ( x0 + 0.5 * h , y + 0.5 ) NEW_LINE y = y + ( 1.0 \/ 6.0 ) * ( k1 + 2 * k2 ) NEW_LINE x0 = x0 + ( 1.0 ) * ( k1 + 2 * k2 ) NEW_LINE x0 = x0 + h NEW_LINE DEDENT return y NEW_LINE DEDENT x0 = 0 NEW_LINE y = 1 NEW_LINE x = 2 NEW_LINE h = 0.2 NEW_LINE print ( rungeKutta ( x0 , y , x , h ) ) NEW_LINE"],"references":["def dydx ( x , y ) : NEW_LINE INDENT return ( x + y - 2 ) ; NEW_LINE DEDENT def rungeKutta ( x0 , y0 , x , h ) : NEW_LINE INDENT n = round ( ( x - x0 ) \/ h ) ; NEW_LINE y = y0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT k1 = h * dydx ( x0 , y ) ; NEW_LINE k2 = h * dydx ( x0 + 0.5 * h , y + 0.5 * k1 ) ; NEW_LINE y = y + ( 1.0 \/ 6.0 ) * ( k1 + 2 * k2 ) ; NEW_LINE x0 = x0 + h ; NEW_LINE DEDENT return y ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x0 = 0 ; y = 1 ; NEW_LINE x = 2 ; h = 0.2 ; NEW_LINE print ( \" y ( x ) ▁ = \" , rungeKutta ( x0 , y , x , h ) ) ; NEW_LINE DEDENT"],"bleu":0.5986852255681182,"rouge_l":0.7935049577003548}
{"id":758,"predictions":["MAX_CHAR = 26 ; NEW_LINE def countPalindrome ( str ) : NEW_LINE INDENT n = len ( str ) ; NEW_LINE sum = 0 ; NEW_LINE hashTable = [ 0 ] * MAX_CHAR ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT hashTable [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( hashTable [ i ] ) : NEW_LINE INDENT sum += ( hashTable [ i ] * ( hashTable [ i ] + 1 ) \/ 2 ) ; NEW_LINE DEDENT DEDENT return sum ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" anphananddd \" ; NEW_LINE print ( countPalindrome ( str ) ) ; NEW_LINE DEDENT"],"references":["MAX_CHAR = 26 NEW_LINE def countPalindrome ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE sum = 0 NEW_LINE hashTable = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( n ) : NEW_LINE INDENT hashTable [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( hashTable [ i ] ) : NEW_LINE INDENT sum += ( hashTable [ i ] * ( hashTable [ i ] + 1 ) \/\/ 2 ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" ananananddd \" NEW_LINE print ( countPalindrome ( str ) ) NEW_LINE DEDENT"],"bleu":0.8141767286694681,"rouge_l":0.9592770801549114}
{"id":759,"predictions":["def __gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a ; NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return __gcd ( a - b , b ) ; NEW_LINE DEDENT return __gcd ( a , b - a ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT m = 375 ; n = 60 ; NEW_LINE print ( NumberOfSquares ( m , n ) ) ; NEW_LINE DEDENT"],"references":["def __gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a ; NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return __gcd ( a - b , b ) ; NEW_LINE DEDENT return __gcd ( a , b - a ) ; NEW_LINE DEDENT def NumberOfSquares ( x , y ) : NEW_LINE INDENT s = __gcd ( x , y ) ; NEW_LINE ans = ( x * y ) \/ ( s * s ) ; NEW_LINE return int ( ans ) ; NEW_LINE DEDENT m = 385 ; NEW_LINE n = 60 ; NEW_LINE print ( NumberOfSquares ( m , n ) ) ; NEW_LINE"],"bleu":0.6466867044224025,"rouge_l":0.7655582869711477}
{"id":760,"predictions":["def divisibilityCheck ( arr , n ) : NEW_LINE INDENT s = [ ] NEW_LINE max_ele = - 2147483648 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . append ( arr [ i ] ) NEW_LINE max_ele = max ( max_ele , arr [ i ] ) NEW_LINE DEDENT res = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] != 0 ) : NEW_LINE INDENT for j in range ( arr [ i ] * 2 , max_ele + 1 , arr [ i ] ) : NEW_LINE INDENT if j in s : NEW_LINE INDENT res . add ( j ) NEW_LINE DEDENT DEDENT DEDENT DEDENT res = res NEW_LINE return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 3 , 8 , 6 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE divisibilityCheck ( arr , n ) NEW_LINE DEDENT"],"references":["import math as mt NEW_LINE def divisibilityCheck ( arr , n ) : NEW_LINE INDENT s = dict ( ) NEW_LINE max_ele = - 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s [ arr [ i ] ] = 1 NEW_LINE max_ele = max ( max_ele , arr [ i ] ) NEW_LINE DEDENT res = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] != 0 ) : NEW_LINE INDENT for j in range ( arr [ i ] * 2 , max_ele + 1 , arr [ i ] ) : NEW_LINE INDENT if ( j in s . keys ( ) ) : NEW_LINE INDENT res [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT for x in res : NEW_LINE INDENT print ( x , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 2 , 3 , 8 , 6 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE divisibilityCheck ( arr , n ) NEW_LINE"],"bleu":0.7074444852546493,"rouge_l":0.7963446475195822}
{"id":761,"predictions":["def leftRotate ( arr , d , n ) : NEW_LINE INDENT d = d % n NEW_LINE g_c_d = gcd ( d , n ) NEW_LINE for i in range ( g_c_d ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE j = i NEW_LINE while ( True ) : NEW_LINE INDENT k = j + d NEW_LINE if ( k >= n ) : NEW_LINE INDENT k = k - n NEW_LINE DEDENT if ( k == i ) : NEW_LINE INDENT break NEW_LINE DEDENT arr [ j ] = arr [ k ] NEW_LINE j = k NEW_LINE DEDENT arr [ j ] = temp NEW_LINE DEDENT DEDENT def printArray ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] NEW_LINE leftRotate ( arr , 2 , 7 ) NEW_LINE printArray ( arr , 7 ) NEW_LINE"],"references":["def leftRotate ( arr , d , n ) : NEW_LINE INDENT d = d % n NEW_LINE g_c_d = gcd ( d , n ) NEW_LINE for i in range ( g_c_d ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE j = i NEW_LINE while 1 : NEW_LINE INDENT k = j + d NEW_LINE if k >= n : NEW_LINE INDENT k = k - n NEW_LINE DEDENT if k == i : NEW_LINE INDENT break NEW_LINE DEDENT arr [ j ] = arr [ k ] NEW_LINE j = k NEW_LINE DEDENT arr [ j ] = temp NEW_LINE DEDENT DEDENT def printArray ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( \" % ▁ d \" % arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT def gcd ( a , b ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT return a ; NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( b , a % b ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE d = 2 NEW_LINE leftRotate ( arr , d , n ) NEW_LINE printArray ( arr , n ) NEW_LINE"],"bleu":0.6779984179427438,"rouge_l":0.8163533689177691}
{"id":762,"predictions":["def isCorrectOrder ( n ) : NEW_LINE INDENT flag = True NEW_LINE prev = - 1 NEW_LINE type = - 1 NEW_LINE while ( n ) : NEW_LINE INDENT if ( type == - 1 ) : NEW_LINE INDENT if ( prev == - 1 ) : NEW_LINE INDENT prev = n % 10 NEW_LINE n = n \/\/ 10 NEW_LINE continue NEW_LINE DEDENT if ( prev == n % 10 ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT if ( prev > n % 10 ) : NEW_LINE INDENT flag = False NEW_LINE prev = n % 10 NEW_LINE n = n \/\/ 10 NEW_LINE continue NEW_LINE DEDENT prev = n % 10 NEW_LINE n = n \/\/ 10 NEW_LINE DEDENT else : NEW_LINE INDENT if ( prev == n % 10 ) : NEW_LINE INDENT flag = False NEW_LINE DEDENT if ( prev < n % 10 ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT prev = n % 10 NEW_LINE n = n \/\/ 10 NEW_LINE DEDENT DEDENT return flag NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 123454321 NEW_LINE if ( isCorrectOrder ( n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"references":["def isCorrectOrder ( n ) : NEW_LINE INDENT flag = True ; NEW_LINE prev = - 1 ; NEW_LINE type = - 1 ; NEW_LINE while ( n != 0 ) : NEW_LINE INDENT if ( type == - 1 ) : NEW_LINE INDENT if ( prev == - 1 ) : NEW_LINE INDENT prev = n % 10 ; NEW_LINE n = int ( n \/ 10 ) ; NEW_LINE continue ; NEW_LINE DEDENT if ( prev == n % 10 ) : NEW_LINE INDENT flag = False ; NEW_LINE break ; NEW_LINE DEDENT if ( prev > n % 10 ) : NEW_LINE INDENT type = 1 ; NEW_LINE prev = n % 10 ; NEW_LINE n = int ( n \/ 10 ) ; NEW_LINE continue ; NEW_LINE DEDENT prev = n % 10 ; NEW_LINE n = int ( n \/ 10 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( prev == n % 10 ) : NEW_LINE INDENT flag = False ; NEW_LINE break ; NEW_LINE DEDENT if ( prev < n % 10 ) : NEW_LINE INDENT flag = False ; NEW_LINE break ; NEW_LINE DEDENT prev = n % 10 ; NEW_LINE n = int ( n \/ 10 ) ; NEW_LINE DEDENT DEDENT return flag ; NEW_LINE DEDENT n = 123454321 ; NEW_LINE if ( isCorrectOrder ( n ) ) : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE DEDENT"],"bleu":0.6376532407391617,"rouge_l":0.855350553505535}
{"id":763,"predictions":["def K_multiple ( a , n , k ) : NEW_LINE INDENT a . sort ( ) ; NEW_LINE s = set ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( a [ i ] % k == 0 and a [ i ] \/\/ k ) or ( a [ i ] % k != 0 ) ) : NEW_LINE INDENT s . add ( a [ i ] ) ; NEW_LINE DEDENT DEDENT for i in s : NEW_LINE INDENT print ( i , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 2 , 3 , 4 , 5 , 6 , 10 ] ; NEW_LINE k = 2 ; NEW_LINE n = len ( a ) ; NEW_LINE K_multiple ( a , n , k ) ; NEW_LINE DEDENT"],"references":["def K_multiple ( a , n , k ) : NEW_LINE INDENT a . sort ( ) ; NEW_LINE s = set ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( a [ i ] % k == 0 and a [ i ] \/\/ k not in s ) or a [ i ] % k != 0 ) : NEW_LINE INDENT s . add ( a [ i ] ) ; NEW_LINE DEDENT DEDENT for i in s : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 2 , 3 , 4 , 5 , 6 , 10 ] ; NEW_LINE k = 2 ; NEW_LINE n = len ( a ) ; NEW_LINE K_multiple ( a , n , k ) ; NEW_LINE DEDENT"],"bleu":0.94871501510422,"rouge_l":0.9810126582278482}
{"id":764,"predictions":["import numpy as np NEW_LINE maxN = 20 NEW_LINE maxM = 10 NEW_LINE dp = np . zeros ( ( maxN , maxM ) ) ; NEW_LINE v = np . zeros ( ( maxN , maxM ) ) ; NEW_LINE def findCnt ( arr , i , curr , n , m ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT if ( curr == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT if ( v [ i ] [ curr ] ) : NEW_LINE INDENT return dp [ i ] [ curr ] ; NEW_LINE DEDENT v [ i ] [ curr ] = 1 ; NEW_LINE dp [ i ] [ curr ] = findCnt ( arr , i + 1 , curr , n , m ) + findCnt ( arr , i + 1 , ( curr + arr [ i ] ) % m , n , m ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 3 , 3 , 3 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE m = 6 ; NEW_LINE print ( findCnt ( arr , 0 , 0 , n , m ) - 1 ) ; NEW_LINE DEDENT"],"references":["maxN = 20 NEW_LINE maxM = 10 NEW_LINE dp = [ [ 0 for i in range ( maxN ) ] for i in range ( maxM ) ] NEW_LINE v = [ [ 0 for i in range ( maxN ) ] for i in range ( maxM ) ] NEW_LINE def findCnt ( arr , i , curr , n , m ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT if ( curr == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if ( v [ i ] [ curr ] ) : NEW_LINE INDENT return dp [ i ] [ curr ] NEW_LINE DEDENT v [ i ] [ curr ] = 1 NEW_LINE dp [ i ] [ curr ] = findCnt ( arr , i + 1 , curr , n , m ) +   \\ NEW_LINE INDENT findCnt ( arr , i + 1 , ( curr + arr [ i ] ) % m , n , m ) NEW_LINE DEDENT return dp [ i ] [ curr ] NEW_LINE DEDENT arr = [ 3 , 3 , 3 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE m = 6 NEW_LINE print ( findCnt ( arr , 0 , 0 , n , m ) - 1 ) NEW_LINE"],"bleu":0.7205609443478049,"rouge_l":0.8178199846379445}
{"id":765,"predictions":["def minSteps ( str ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( str ) - 2 ) : NEW_LINE INDENT if ( str [ i ] == '0' ) : NEW_LINE INDENT if ( str [ i + 1 ] == '1' ) : NEW_LINE INDENT count += 1 NEW_LINE i += 2 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \"0101010\" NEW_LINE print ( minSteps ( str ) ) NEW_LINE DEDENT"],"references":["def minSteps ( str ) : NEW_LINE INDENT count = 0 NEW_LINE i = 0 NEW_LINE while i < len ( str ) - 2 : NEW_LINE INDENT if str [ i ] == '0' : NEW_LINE INDENT if ( str [ i + 1 ] == '1' ) : NEW_LINE INDENT if ( str [ i + 2 ] == '0' ) : NEW_LINE INDENT count = count + 1 NEW_LINE i = i + 2 NEW_LINE DEDENT DEDENT DEDENT i = i + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT str = \"0101010\" NEW_LINE print ( minSteps ( str ) ) NEW_LINE"],"bleu":0.6272870669323934,"rouge_l":0.7106990482441746}
{"id":766,"predictions":["import math NEW_LINE def checkSemiprime ( num ) : NEW_LINE INDENT cnt = 0 NEW_LINE i = 2 NEW_LINE while cnt < 2 and i * i <= num : NEW_LINE INDENT while num % i == 0 : NEW_LINE INDENT num \/\/= i NEW_LINE cnt += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( num > 1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT return cnt == 2 NEW_LINE DEDENT def semiprime ( n ) : NEW_LINE INDENT if checkSemiprime ( n ) == 1 : NEW_LINE INDENT print ( \" True \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" False \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 6 NEW_LINE semiprime ( n ) NEW_LINE n = 8 NEW_LINE semiprime ( n ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def checkSemiprime ( num ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( 2 , int ( math . sqrt ( num ) ) + 1 ) : NEW_LINE INDENT while num % i == 0 : NEW_LINE INDENT num \/= i NEW_LINE cnt += 1 NEW_LINE DEDENT if cnt >= 2 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( num > 1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT return cnt == 2 NEW_LINE DEDENT def semiprime ( n ) : NEW_LINE INDENT if checkSemiprime ( n ) == True : NEW_LINE INDENT print ( \" True \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" False \" ) NEW_LINE DEDENT DEDENT n = 6 NEW_LINE semiprime ( n ) NEW_LINE n = 8 NEW_LINE semiprime ( n ) ; NEW_LINE"],"bleu":0.7421686712360285,"rouge_l":0.8009961512338691}
{"id":767,"predictions":["def XandYandZintercept ( A , B , C , D ) : NEW_LINE INDENT x1 = - DIRA NEW_LINE x = - D \/ A NEW_LINE y = - D \/ B NEW_LINE z = - D \/ C NEW_LINE return [ 0 ] NEW_LINE DEDENT def equation_plane ( p , q , r ) : NEW_LINE INDENT x1 = p [ 0 ] NEW_LINE y1 = p [ 1 ] NEW_LINE z2 = q [ 2 ] NEW_LINE x2 = q [ 0 ] NEW_LINE y2 = q [ 1 ] NEW_LINE z3 = r [ 2 ] NEW_LINE x3 = x3 - y1 NEW_LINE a1 = x2 - x1 NEW_LINE b2 = y3 - y1 NEW_LINE b = z2 - z1 NEW_LINE c2 = x3 - x1 NEW_LINE a2 = b2 * c1 NEW_LINE b = b1 * c2 - a1 * c2 NEW_LINE C = a1 * b2 - b * c1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x1 = - 1 NEW_LINE x1 = 2 NEW_LINE y1 = 3 NEW_LINE z1 = 2 NEW_LINE x2 = - b1 NEW_LINE y2 = 0 NEW_LINE x = a2 * c1 - b2 NEW_LINE C = ( - A1 * x1 - C * z1 ) NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT print ( rs [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT"],"references":["def XandYandZintercept ( A , B , C , D ) : NEW_LINE INDENT x = - D \/ A NEW_LINE y = - D \/ B NEW_LINE z = - D \/ C NEW_LINE return [ x , y , z ] NEW_LINE DEDENT def equation_plane ( p , q , r ) : NEW_LINE INDENT x1 = p [ 0 ] NEW_LINE y1 = p [ 1 ] NEW_LINE z1 = p [ 2 ] NEW_LINE x2 = q [ 0 ] NEW_LINE y2 = q [ 1 ] NEW_LINE z2 = q [ 2 ] NEW_LINE x3 = r [ 0 ] NEW_LINE y3 = r [ 1 ] NEW_LINE z3 = r [ 2 ] NEW_LINE a1 = x2 - x1 NEW_LINE b1 = y2 - y1 NEW_LINE c1 = z2 - z1 NEW_LINE a2 = x3 - x1 NEW_LINE b2 = y3 - y1 NEW_LINE c2 = z3 - z1 NEW_LINE A = b1 * c2 - b2 * c1 NEW_LINE B = a2 * c1 - a1 * c2 NEW_LINE C = a1 * b2 - b1 * a2 NEW_LINE D = ( - A * x1 - B * y1 - C * z1 ) NEW_LINE print ( XandYandZintercept ( A , B , C , D ) ) NEW_LINE DEDENT x1 = - 1 NEW_LINE y1 = 2 NEW_LINE z1 = 1 NEW_LINE x2 = 0 NEW_LINE y2 = - 3 NEW_LINE z2 = 2 NEW_LINE x3 = 1 NEW_LINE y3 = 1 NEW_LINE z3 = - 4 NEW_LINE equation_plane ( ( x1 , y1 , z1 ) , ( x2 , y2 , z2 ) , ( x3 , y3 , z3 ) ) NEW_LINE"],"bleu":0.559374094592784,"rouge_l":0.6175225473955458}
{"id":768,"predictions":["def mulmod ( a , b , mod ) : NEW_LINE INDENT res = 0 NEW_LINE a = a % mod NEW_LINE while ( b ) : NEW_LINE INDENT if ( b % 2 == 1 ) : NEW_LINE INDENT res = ( res + a ) % mod NEW_LINE DEDENT a = ( a * 2 ) % mod NEW_LINE b \/\/= 2 NEW_LINE DEDENT return res % mod NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 9223372075695 NEW_LINE b = 922337205 NEW_LINE print ( mulmod ( a , b , 100000000000 ) ) NEW_LINE DEDENT"],"references":["def mulmod ( a , b , mod ) : NEW_LINE INDENT res = 0 ; NEW_LINE a = a % mod ; NEW_LINE while ( b > 0 ) : NEW_LINE INDENT if ( b % 2 == 1 ) : NEW_LINE INDENT res = ( res + a ) % mod ; NEW_LINE DEDENT a = ( a * 2 ) % mod ; NEW_LINE b \/\/= 2 ; NEW_LINE DEDENT return res % mod ; NEW_LINE DEDENT a = 9223372036854775807 ; NEW_LINE b = 9223372036854775807 ; NEW_LINE print ( mulmod ( a , b , 100000000000 ) ) ; NEW_LINE"],"bleu":0.6946711801565658,"rouge_l":0.8634790814721611}
{"id":769,"predictions":["MAX_CHAR = 26 ; NEW_LINE def sortString ( str ) : NEW_LINE INDENT letters = [ 0 ] * MAX_CHAR ; NEW_LINE for x in strr : NEW_LINE INDENT letters [ ord ( x ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT for i in range ( MAX_CHAR ) : NEW_LINE INDENT for j in range ( len ( letters ) ) : NEW_LINE INDENT print ( chr ( i + ord ( ' a ' ) ) , end = \" \" ) ; NEW_LINE DEDENT DEDENT DEDENT sortString ( \" geeksforgeeks \" ) ; NEW_LINE"],"references":["MAX_CHAR = 26 NEW_LINE def sortString ( str ) : NEW_LINE INDENT charCount = [ 0 for i in range ( MAX_CHAR ) ] NEW_LINE for i in range ( 0 , len ( str ) , 1 ) : NEW_LINE INDENT charCount [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 0 , MAX_CHAR , 1 ) : NEW_LINE INDENT for j in range ( 0 , charCount [ i ] , 1 ) : NEW_LINE INDENT print ( chr ( ord ( ' a ' ) + i ) , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" geeksforgeeks \" NEW_LINE sortString ( s ) NEW_LINE DEDENT"],"bleu":0.4046723835486736,"rouge_l":0.6586444646806295}
{"id":770,"predictions":["def pentagon_pyramidal ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT p = ( 3 * i * i - i ) \/ 2 NEW_LINE sum = sum + p NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 4 NEW_LINE print ( int ( pentagon_pyramidal ( n ) ) ) NEW_LINE"],"references":["def pentagon_pyramidal ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT p = ( 3 * i * i - i ) \/ 2 NEW_LINE sum = sum + p NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 4 NEW_LINE print ( int ( pentagon_pyramidal ( n ) ) ) NEW_LINE"],"bleu":1.0,"rouge_l":1.0}
{"id":771,"predictions":["def count ( n ) : NEW_LINE INDENT table = [ 0 ] * ( n + 1 ) NEW_LINE table [ 0 ] = 1 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT table [ i ] += table [ i - 3 ] NEW_LINE DEDENT for i in range ( 5 , n + 1 ) : NEW_LINE INDENT table [ i ] += table [ i - 5 ] NEW_LINE DEDENT for i in range ( 10 , n + 1 ) : NEW_LINE INDENT table [ i ] += table [ i - 10 ] NEW_LINE DEDENT return table [ n ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 20 NEW_LINE print ( \" Count ▁ for \" , n , \" is \" , count ( n ) ) NEW_LINE n = 13 NEW_LINE print ( \" Count ▁ for \" , n , \" is \" , count ( n ) ) NEW_LINE DEDENT"],"references":["def count ( n ) : NEW_LINE INDENT table = [ 0 for i in range ( n + 1 ) ] NEW_LINE table [ 0 ] = 1 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT table [ i ] += table [ i - 3 ] NEW_LINE DEDENT for i in range ( 5 , n + 1 ) : NEW_LINE INDENT table [ i ] += table [ i - 5 ] NEW_LINE DEDENT for i in range ( 10 , n + 1 ) : NEW_LINE INDENT table [ i ] += table [ i - 10 ] NEW_LINE DEDENT return table [ n ] NEW_LINE DEDENT n = 20 NEW_LINE print ( ' Count ▁ for ' , n , ' is ' , count ( n ) ) NEW_LINE n = 13 NEW_LINE print ( ' Count ▁ for ' , n , ' is ' , count ( n ) ) NEW_LINE"],"bleu":0.7774141745156268,"rouge_l":0.8973175656186906}
{"id":772,"predictions":["from math import sqrt NEW_LINE MAX = 26 NEW_LINE def max_element ( str1 , len1 ) : NEW_LINE INDENT max_ele = freq [ 0 ] NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if ( max_ele < freq [ i ] ) : NEW_LINE INDENT max_ele = freq [ i ] NEW_LINE DEDENT DEDENT return max_ele NEW_LINE DEDENT def minimumAddition ( str1 , len1 ) : NEW_LINE INDENT freq = [ 0 for i in range ( MAX ) ] NEW_LINE for i in range ( len1 ) : NEW_LINE INDENT freq [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT maxAddition = 0 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if ( freq [ i ] > 0 ) : NEW_LINE INDENT minAddition += abs ( maxFreq - freq [ i ] ) NEW_LINE DEDENT DEDENT return minAddition NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = \" geeksforgeeks \" NEW_LINE len1 = len ( str1 ) NEW_LINE print ( minimumAddition ( str1 , len1 ) ) NEW_LINE DEDENT"],"references":["MAX = 26 NEW_LINE def minimumAddition ( str1 , Len ) : NEW_LINE INDENT freq = [ 0 for i in range ( MAX ) ] NEW_LINE for i in range ( Len ) : NEW_LINE INDENT freq [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT maxFreq = max ( freq ) NEW_LINE minAddition = 0 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if ( freq [ i ] > 0 ) : NEW_LINE INDENT minAddition += abs ( maxFreq - freq [ i ] ) NEW_LINE DEDENT DEDENT return minAddition NEW_LINE DEDENT str1 = \" geeksforgeeks \" NEW_LINE Len = len ( str1 ) NEW_LINE print ( minimumAddition ( str1 , Len ) ) NEW_LINE"],"bleu":0.5653432024048379,"rouge_l":0.7583920430998756}
{"id":773,"predictions":["N = 9 NEW_LINE def addEgde ( adj , u , v ) : NEW_LINE INDENT adj [ u ] . append ( v ) ; NEW_LINE adj [ v ] . append ( u ) ; NEW_LINE DEDENT def DFS ( node , parent , G , val , adj ) : NEW_LINE INDENT if ( node == leaf ) : NEW_LINE INDENT G = gcd ( G , val [ node ] ) ; NEW_LINE print ( G ) ; NEW_LINE return ; NEW_LINE DEDENT for it in adj [ node ] : NEW_LINE INDENT if ( it != parent ) : NEW_LINE INDENT GFS ( it , node , gcd ( G , val [ it ] ) , leaf , val , adj ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 8 ; NEW_LINE adj [ 1 ] = [ 2 ] ; NEW_LINE addEgde ( adj , 1 , 2 ) ; NEW_LINE addEgde ( adj , 1 , 4 ) ; NEW_LINE addEgde ( adj , 2 , 3 ) ; NEW_LINE addEgde ( adj , 3 , 5 ) ; NEW_LINE addEgde ( adj , 6 , 7 ) ; NEW_LINE addEgde ( adj , 3 , 6 ) ; NEW_LINE addEgde ( adj , 6 , 7 ) ; NEW_LINE addEgde ( adj , 6 , 8 ) ; NEW_LINE addEgde ( adj , 6 , 7 ) ; NEW_LINE addEgde ( adj , 6 , 7 ) ; NEW_LINE addEgde ( adj , 6 , 8 ) ; NEW_LINE addEgde ( adj , 6 , 8 ) ; NEW_LINE DEDENT"],"references":["from math import gcd NEW_LINE N = 9 NEW_LINE def addEgde ( adj , u , v ) : NEW_LINE INDENT adj [ u ] . append ( v ) NEW_LINE adj [ v ] . append ( u ) NEW_LINE DEDENT def DFS ( node , parent , G , leaf , val , adj ) : NEW_LINE INDENT if ( node == leaf ) : NEW_LINE INDENT G = gcd ( G , val [ node ] ) NEW_LINE print ( G , end = \" \" ) NEW_LINE return NEW_LINE DEDENT for it in adj [ node ] : NEW_LINE INDENT if ( it != parent ) : NEW_LINE INDENT DFS ( it , node , gcd ( G , val [ it ] ) , leaf , val , adj ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 8 NEW_LINE adj = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE addEgde ( adj , 1 , 2 ) NEW_LINE addEgde ( adj , 2 , 4 ) NEW_LINE addEgde ( adj , 1 , 3 ) NEW_LINE addEgde ( adj , 3 , 5 ) NEW_LINE addEgde ( adj , 3 , 6 ) NEW_LINE addEgde ( adj , 6 , 7 ) NEW_LINE addEgde ( adj , 6 , 8 ) NEW_LINE leaf = 5 NEW_LINE val = [ - 1 , 6 , 2 , 6 , 3 , 4 , 12 , 10 , 18 ] NEW_LINE G = val [ 1 ] NEW_LINE DFS ( 1 , - 1 , G , leaf , val , adj ) NEW_LINE DEDENT"],"bleu":0.6202405680749461,"rouge_l":0.7659069057180024}
{"id":774,"predictions":["def countNums ( l , r ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT lastDigit = ( i % 10 ) NEW_LINE if ( ( lastDigit % 10 ) == 2 or ( lastDigit % 10 ) == 3 or ( lastDigit % 10 ) == 9 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT l , r = 11 , 33 NEW_LINE print ( countNums ( l , r ) ) NEW_LINE DEDENT"],"references":["def countNums ( l , r ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT lastDigit = ( i % 10 ) ; NEW_LINE if ( ( lastDigit % 10 ) == 2 or ( lastDigit % 10 ) == 3 or ( lastDigit % 10 ) == 9 ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT return cnt ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT l = 11 ; r = 33 ; NEW_LINE print ( countNums ( l , r ) ) ; NEW_LINE DEDENT"],"bleu":0.8239766315620604,"rouge_l":0.9408275248405754}
{"id":775,"predictions":["def countMaxSetBits ( left , right ) : NEW_LINE INDENT max_count = - 1 ; num = 0 ; NEW_LINE for i in range ( left , right + 1 ) : NEW_LINE INDENT temp = i ; NEW_LINE cnt = 0 ; NEW_LINE while ( temp ) : NEW_LINE INDENT if ( temp % 2 == 1 ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT temp >>= 1 ; NEW_LINE DEDENT if ( cnt > max_count ) : NEW_LINE INDENT max_count = cnt ; NEW_LINE num = i ; NEW_LINE DEDENT DEDENT return num ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT l = 1 ; r = 5 ; NEW_LINE print ( countMaxSetBits ( l , r ) ) ; NEW_LINE l = 1 ; NEW_LINE r = 10 ; NEW_LINE print ( countMaxSetBits ( l , r ) ) ; NEW_LINE DEDENT"],"references":["def countMaxSetBits ( left , right ) : NEW_LINE INDENT max_count = - 1 NEW_LINE for i in range ( left , right + 1 ) : NEW_LINE INDENT temp = i NEW_LINE cnt = 0 NEW_LINE while temp : NEW_LINE INDENT if temp & 1 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT temp = temp >> 1 NEW_LINE DEDENT if cnt > max_count : NEW_LINE INDENT max_count = cnt NEW_LINE num = i NEW_LINE DEDENT DEDENT return num NEW_LINE DEDENT l = 1 NEW_LINE r = 5 NEW_LINE print ( countMaxSetBits ( l , r ) ) NEW_LINE l = 1 NEW_LINE r = 10 NEW_LINE print ( countMaxSetBits ( l , r ) ) NEW_LINE"],"bleu":0.5148385278005486,"rouge_l":0.8485781115351472}
{"id":776,"predictions":["import math NEW_LINE def checkPerfectcube ( n ) : NEW_LINE INDENT cube_root = n ** ( 1. \/ 3. ) NEW_LINE if round ( cube_root ) ** 3 == n : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def smallestPerfectCube ( a , n ) : NEW_LINE INDENT mini = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( checkPerfectcube ( a [ i ] ) ) : NEW_LINE INDENT mini = min ( a [ i ] , mini ) NEW_LINE DEDENT DEDENT return mini NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 16 , 8 , 25 , 2 , 3 , 10 ] NEW_LINE n = len ( a ) NEW_LINE print ( smallestPerfectCube ( a , n ) ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE def checkPerfectcube ( n ) : NEW_LINE INDENT d = int ( n ** ( 1 \/ 3 ) ) ; NEW_LINE if ( d * d * d == n ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT def smallestPerfectCube ( a , n ) : NEW_LINE INDENT mini = sys . maxsize ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( checkPerfectcube ( a [ i ] ) ) : NEW_LINE INDENT mini = min ( a [ i ] , mini ) ; NEW_LINE DEDENT DEDENT return mini ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 16 , 8 , 25 , 2 , 3 , 10 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( smallestPerfectCube ( a , n ) ) ; NEW_LINE DEDENT"],"bleu":0.7119082921938464,"rouge_l":0.8789997880906972}
{"id":777,"predictions":["def discard ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = 0 NEW_LINE maximum = 0 NEW_LINE for j in range ( i , min ( n , i + 60 ) ) : NEW_LINE INDENT s += a [ j ] NEW_LINE maximum = max ( a [ j ] , maximum ) NEW_LINE if ( s % 2 == 0 and 2 * maximum > s ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT def countSubarrays ( a , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT a [ i ] = a [ i ] NEW_LINE if ( i != 0 ) : NEW_LINE INDENT pre [ i ] += pre [ i - 1 ] NEW_LINE DEDENT DEDENT pre = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( pre [ i ] % 2 == 1 ) : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT even = n - odd NEW_LINE even += 1 NEW_LINE answer = ( ( odd * ( odd - 1 ) \/\/ 2 ) + ( even * ( even - 1 ) \/\/ 2 ) ) NEW_LINE print ( answer ) NEW_LINE answer = answer - merge ( a , n ) NEW_LINE return answer NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 6 , 7 , 14 ] NEW_LINE n = len ( a ) NEW_LINE print ( countSubarrays ( a , n ) ) NEW_LINE DEDENT"],"references":["def exclude ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT s = 0 NEW_LINE maximum = 0 NEW_LINE for j in range ( i , min ( n , i + 60 ) ) : NEW_LINE INDENT s += a [ j ] NEW_LINE maximum = max ( a [ j ] , maximum ) NEW_LINE if s % 2 == 0 and 2 * maximum > s : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT def countSubarrays ( a , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT a [ i ] = bin ( a [ i ] ) . count ( '1' ) NEW_LINE DEDENT pre = [ None ] * n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT pre [ i ] = a [ i ] NEW_LINE if i != 0 : NEW_LINE INDENT pre [ i ] += pre [ i - 1 ] NEW_LINE DEDENT DEDENT odd , even = 0 , 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if pre [ i ] & 1 : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT even = n - odd NEW_LINE even += 1 NEW_LINE answer = ( ( odd * ( odd - 1 ) \/\/ 2 ) + ( even * ( even - 1 ) \/\/ 2 ) ) NEW_LINE print ( answer ) NEW_LINE answer = answer - exclude ( a , n ) NEW_LINE return answer NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 6 , 7 , 14 ] NEW_LINE n = len ( a ) NEW_LINE print ( countSubarrays ( a , n ) ) NEW_LINE DEDENT"],"bleu":0.779799141013414,"rouge_l":0.8657030223390276}
{"id":778,"predictions":["def printPermutation ( N , K ) : NEW_LINE INDENT res = [ ] NEW_LINE l = 1 NEW_LINE r = N NEW_LINE flag = 0 NEW_LINE for i in range ( K ) : NEW_LINE INDENT if ( flag == 0 ) : NEW_LINE INDENT res . append ( l ) NEW_LINE l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT res . append ( r ) NEW_LINE r -= 1 NEW_LINE DEDENT flag ^= 1 NEW_LINE DEDENT if ( flag != 1 ) : NEW_LINE INDENT for i in range ( r , l + 1 ) : NEW_LINE INDENT res . append ( i ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( l , r + 1 ) : NEW_LINE INDENT res . append ( i ) NEW_LINE DEDENT DEDENT for i in res : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 10 NEW_LINE K = 4 NEW_LINE printPermutation ( N , K ) NEW_LINE DEDENT"],"references":["def printPermutation ( N , K ) : NEW_LINE INDENT res = list ( ) ; NEW_LINE l , r , flag = 1 , N , 0 NEW_LINE for i in range ( K ) : NEW_LINE INDENT if flag == False : NEW_LINE INDENT res . append ( l ) NEW_LINE l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT res . append ( r ) ; NEW_LINE r -= 1 ; NEW_LINE DEDENT flag = flag ^ 1 ; NEW_LINE DEDENT if flag == False : NEW_LINE INDENT for i in range ( r , 2 , - 1 ) : NEW_LINE INDENT res . append ( i ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( l , r ) : NEW_LINE INDENT res . append ( i ) NEW_LINE DEDENT DEDENT for i in res : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT N , K = 10 , 4 NEW_LINE printPermutation ( N , K ) NEW_LINE"],"bleu":0.6915443645778083,"rouge_l":0.8337129840546698}
{"id":779,"predictions":["def solve ( A , B , n ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT c = A [ i ] | A [ j ] NEW_LINE if ( bin ( c ) . count ( '1' ) == B [ j ] ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT DEDENT return cnt ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 5 , 3 , 2 , 4 , 6 , 1 ] ; NEW_LINE B = [ 2 , 2 , 1 , 4 , 2 , 3 ] ; NEW_LINE size = len ( A ) ; NEW_LINE print ( solve ( A , B , size ) ) ; NEW_LINE DEDENT"],"references":["def solve ( A , B , n ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if ( bin ( A [ i ] | A [ j ] ) . count ( '1' ) == B [ j ] ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 5 , 3 , 2 , 4 , 6 , 1 ] ; NEW_LINE B = [ 2 , 2 , 1 , 4 , 2 , 3 ] ; NEW_LINE size = len ( A ) ; NEW_LINE print ( solve ( A , B , size ) ) ; NEW_LINE DEDENT"],"bleu":0.9271690331873623,"rouge_l":0.9596853490658801}
{"id":780,"predictions":["def sum ( n ) : NEW_LINE INDENT s = 0.0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT s = s + 1 \/ i NEW_LINE DEDENT return s NEW_LINE DEDENT n = 5 NEW_LINE s = sum ( n ) NEW_LINE print ( \" Sum ▁ is ▁ \" , s ) NEW_LINE"],"references":["def sum ( n ) : NEW_LINE INDENT i = 1 NEW_LINE s = 0.0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT s = s + 1 \/ i ; NEW_LINE DEDENT return s ; NEW_LINE DEDENT n = 5 NEW_LINE print ( \" Sum ▁ is \" , round ( sum ( n ) , 6 ) ) NEW_LINE"],"bleu":0.7008424825186937,"rouge_l":0.8086543271635819}
{"id":781,"predictions":["M = 3 NEW_LINE N = 2 NEW_LINE getIndex ( n , shuffle ) NEW_LINE def getIndex ( n , shuffle ) : NEW_LINE INDENT for i in range ( 3 ) : NEW_LINE INDENT if ( shuffle [ i ] [ 0 ] == n ) : NEW_LINE INDENT n = shuffle [ i ] [ 1 ] NEW_LINE DEDENT elif ( shuffle [ i ] [ 1 ] == n ) : NEW_LINE INDENT n = shuffle [ i ] [ 0 ] NEW_LINE DEDENT DEDENT print ( n ) NEW_LINE DEDENT n = 3 NEW_LINE shuffle = [ [ 3 , 1 ] , [ 2 , 1 ] , [ 1 , 2 ] ] NEW_LINE getIndex ( n , shuffle ) NEW_LINE"],"references":["M = 3 ; N = 2 ; NEW_LINE def getIndex ( n , shuffle ) : NEW_LINE INDENT for i in range ( 3 ) : NEW_LINE INDENT if ( shuffle [ i ] [ 0 ] == n ) : NEW_LINE INDENT n = shuffle [ i ] [ 1 ] ; NEW_LINE DEDENT elif ( shuffle [ i ] [ 1 ] == n ) : NEW_LINE INDENT n = shuffle [ i ] [ 0 ] ; NEW_LINE DEDENT DEDENT print ( n ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 ; NEW_LINE shuffle = [ [ 3 , 1 ] , [ 2 , 1 ] , [ 1 , 2 ] ] ; NEW_LINE getIndex ( n , shuffle ) ; NEW_LINE DEDENT"],"bleu":0.7486814107292619,"rouge_l":0.8797721488304449}
{"id":782,"predictions":["def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT def findArrangement ( arr , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT print ( \" - 1\" , end = \" ▁ \" ) NEW_LINE return NEW_LINE DEDENT minVal = min ( arr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == minVal ) : NEW_LINE INDENT arr [ i ] , arr [ n - 1 ] = arr [ n - 1 ] , arr [ i ] NEW_LINE break NEW_LINE DEDENT DEDENT andVal = arr [ 0 ] NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] == minVal ) : NEW_LINE INDENT arr [ i ] , arr [ i ] = arr [ i ] , arr [ n - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" - 1\" , end = \" \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 5 , 3 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE findArrangement ( arr , n ) NEW_LINE DEDENT"],"references":["def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT def findArrangement ( arr , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT print ( \" - 1\" , end = \" \" ) ; NEW_LINE return ; NEW_LINE DEDENT minVal = min ( arr ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == minVal ) : NEW_LINE INDENT arr [ i ] , arr [ n - 1 ] = arr [ n - 1 ] , arr [ i ] ; NEW_LINE break ; NEW_LINE DEDENT DEDENT andVal = arr [ 0 ] ; NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT andVal &= arr [ i ] ; NEW_LINE DEDENT if ( andVal == arr [ n - 1 ] ) : NEW_LINE INDENT printArr ( arr , n ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" - 1\" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 5 , 3 , 3 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE findArrangement ( arr , n ) ; NEW_LINE DEDENT"],"bleu":0.7802108994542043,"rouge_l":0.8758932182823244}
{"id":783,"predictions":["def findOccurrences ( str1 , substr ) : NEW_LINE INDENT counter = 0 NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT if ( str1 [ i ] == substr [ 0 ] ) : NEW_LINE INDENT for j in range ( i + 1 , len ( str1 ) ) : NEW_LINE INDENT if ( str1 [ j ] == substr [ 1 ] ) : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return counter NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = \" GFGFGYSYIOIWIN \" NEW_LINE substr = \" GFG \" NEW_LINE print ( findOccurrences ( str1 , substr ) ) NEW_LINE DEDENT"],"references":["def findOccurrences ( str , substr ) : NEW_LINE INDENT counter = 0 NEW_LINE for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == substr [ 0 ] ) : NEW_LINE INDENT for j in range ( i + 1 , len ( str ) ) : NEW_LINE INDENT if ( str [ j ] == substr [ 1 ] ) : NEW_LINE INDENT for k in range ( j + 1 , len ( str ) ) : NEW_LINE INDENT if ( str [ k ] == substr [ 2 ] ) : NEW_LINE INDENT counter = counter + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT return counter NEW_LINE DEDENT str = \" GFGFGYSYIOIWIN \" NEW_LINE substr = \" GFG \" NEW_LINE print ( findOccurrences ( str , substr ) ) NEW_LINE"],"bleu":0.5919164356118456,"rouge_l":0.7344088610642908}
{"id":784,"predictions":["def decimalToBinary ( num , k_prec ) : NEW_LINE INDENT binary = \" \" ; NEW_LINE fractal = num ; NEW_LINE fraction = num - Digal ; NEW_LINE while ( Integer > 0 ) : NEW_LINE INDENT rem = int ( num ) ; NEW_LINE binary += ( ( rem + ord ( '0' ) ) ) ; NEW_LINE Input \/\/= 2 ; NEW_LINE DEDENT binary = binary [ : : - 1 ] ; NEW_LINE binary += ( ' . ' ) ; NEW_LINE while ( k_prec ) : NEW_LINE INDENT fraction += pow ( 2 + ord ( '0' ) ) ; NEW_LINE if ( fract_bit == 1 ) : NEW_LINE INDENT fractional -= fract_bit ; NEW_LINE binary += chr ( 1 + ord ( '0' ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT binary += chr ( 0 + ord ( '0' ) ) ; NEW_LINE DEDENT DEDENT return binary ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4.47 ; NEW_LINE k = 3 ; NEW_LINE print ( int ( decimalToBinary ( n , k ) ) ; NEW_LINE n = len ( binaryToBinary ( n , k ) ) ; NEW_LINE k = 5 ; NEW_LINE print ( int ( decimalToBinary ( n , k ) ) ) ; NEW_LINE DEDENT"],"references":["def decimalToBinary ( num , k_prec ) : NEW_LINE INDENT binary = \" \" NEW_LINE Integral = int ( num ) NEW_LINE fractional = num - Integral NEW_LINE while ( Integral ) : NEW_LINE INDENT rem = Integral % 2 NEW_LINE binary += str ( rem ) ; NEW_LINE Integral \/\/= 2 NEW_LINE DEDENT binary = binary [ : : - 1 ] NEW_LINE binary += ' . ' NEW_LINE while ( k_prec ) : NEW_LINE INDENT fractional *= 2 NEW_LINE fract_bit = int ( fractional ) NEW_LINE if ( fract_bit == 1 ) : NEW_LINE INDENT fractional -= fract_bit NEW_LINE binary += '1' NEW_LINE DEDENT else : NEW_LINE INDENT binary += '0' NEW_LINE DEDENT k_prec -= 1 NEW_LINE DEDENT return binary NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4.47 NEW_LINE k = 3 NEW_LINE print ( decimalToBinary ( n , k ) ) NEW_LINE n = 6.986 NEW_LINE k = 5 NEW_LINE print ( decimalToBinary ( n , k ) ) NEW_LINE DEDENT"],"bleu":0.4738948833446635,"rouge_l":0.7628840020144367}
{"id":785,"predictions":["def evenDecimalValue ( str , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT decimalValue = 0 NEW_LINE powerOf2 = 1 NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT decimalValue += ( ( ord ( str [ k ] ) - ord ( '0' ) ) * powerOf2 ) NEW_LINE powerOf2 *= 2 NEW_LINE DEDENT if ( decimalValue % 2 == 0 ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \"10010\" NEW_LINE n = 5 NEW_LINE print ( evenDecimalValue ( str , n ) ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def evenDecimalValue ( str , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT decimalValue = 0 ; NEW_LINE powerOf2 = 1 ; NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT decimalValue += ( ( int ( str [ k ] ) - 0 ) * powerOf2 ) NEW_LINE powerOf2 *= 2 NEW_LINE DEDENT if ( decimalValue % 2 == 0 ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT str = \"10010\" NEW_LINE n = 5 NEW_LINE print ( evenDecimalValue ( str , n ) ) NEW_LINE"],"bleu":0.8102835507121334,"rouge_l":0.9103354711396152}
{"id":786,"predictions":["def isSubSeqDivisible ( str ) : NEW_LINE INDENT l = len ( str ) NEW_LINE arr = [ 0 ] * l NEW_LINE for i in range ( l ) : NEW_LINE INDENT arr [ i ] = ord ( str [ i ] ) - ord ( '0' ) NEW_LINE DEDENT for i in range ( l ) : NEW_LINE INDENT for j in range ( i , l ) : NEW_LINE INDENT if ( arr [ i ] % 8 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 and i != j ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( ( arr [ i ] * 10 + arr [ k ] ) % 8 == 0 and j != k and i != k ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \"3144\" NEW_LINE if ( isSubSeqDivisible ( str ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def isSubSeqDivisible ( st ) : NEW_LINE INDENT l = len ( st ) NEW_LINE arr = [ int ( ch ) for ch in st ] NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT for j in range ( i , l ) : NEW_LINE INDENT for k in range ( j , l ) : NEW_LINE INDENT if ( arr [ i ] % 8 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 and i != j ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 and i != j and j != k and i != k ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT st = \"3144\" NEW_LINE if ( isSubSeqDivisible ( st ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.7483461830444235,"rouge_l":0.82472}
{"id":787,"predictions":["def sub_segments ( string , n ) : NEW_LINE INDENT l = len ( string ) NEW_LINE for x in range ( l , l , n ) : NEW_LINE INDENT newlist = string [ x + n ] NEW_LINE a = [ ] NEW_LINE for y in a : NEW_LINE INDENT if y in a : NEW_LINE INDENT lst . append ( y ) NEW_LINE DEDENT DEDENT DEDENT for y in arr : NEW_LINE INDENT print ( y , end = \" \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ _ main _ _ \" : NEW_LINE INDENT string = \" geeksforgeeks \" NEW_LINE n = 4 NEW_LINE sub_segments ( string , n ) NEW_LINE DEDENT"],"references":["def sub_segments ( string , n ) : NEW_LINE INDENT l = len ( string ) NEW_LINE for x in range ( 0 , l , n ) : NEW_LINE INDENT newlist = string [ x : x + n ] NEW_LINE arr = [ ] NEW_LINE for y in newlist : NEW_LINE INDENT if y not in arr : NEW_LINE INDENT arr . append ( y ) NEW_LINE DEDENT DEDENT print ( ' ' . join ( arr ) ) NEW_LINE DEDENT DEDENT string = \" geeksforgeeksgfg \" NEW_LINE n = 4 NEW_LINE sub_segments ( string , n ) NEW_LINE"],"bleu":0.5920078203020939,"rouge_l":0.7813441832429174}
{"id":788,"predictions":["def remAnagram ( str1 , str2 ) : NEW_LINE INDENT count1 = [ 0 ] * 26 NEW_LINE count2 = [ 0 ] * 26 NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT count1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( len ( str2 ) ) : NEW_LINE INDENT count2 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT result = result + abs ( count1 [ i ] - count2 [ i ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" bcadeh \" NEW_LINE str2 = \" hea \" NEW_LINE print ( remAnagram ( str1 , str2 ) ) NEW_LINE DEDENT"],"references":["CHARS = 26 NEW_LINE def remAnagram ( str1 , str2 ) : NEW_LINE INDENT count1 = [ 0 ] * CHARS NEW_LINE count2 = [ 0 ] * CHARS NEW_LINE i = 0 NEW_LINE while i < len ( str1 ) : NEW_LINE INDENT count1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE i += 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < len ( str2 ) : NEW_LINE INDENT count2 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE i += 1 NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT result += abs ( count1 [ i ] - count2 [ i ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" bcadeh \" NEW_LINE str2 = \" hea \" NEW_LINE print ( remAnagram ( str1 , str2 ) ) NEW_LINE DEDENT"],"bleu":0.7937893922528751,"rouge_l":0.8724190187535518}
{"id":789,"predictions":["def minOperations ( s , t , n ) : NEW_LINE INDENT ct0 = 0 ; ct1 = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == t [ i ] ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT ct0 += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT ct1 += 1 ; NEW_LINE DEDENT DEDENT return max ( ct0 , ct1 ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \"010\" ; t = \"101\" ; NEW_LINE n = len ( s ) ; NEW_LINE print ( minOperations ( s , t , n ) ) ; NEW_LINE DEDENT"],"references":["def minOperations ( s , t , n ) : NEW_LINE INDENT ct0 = 0 NEW_LINE ct1 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == t [ i ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT ct0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ct1 += 1 NEW_LINE DEDENT DEDENT return max ( ct0 , ct1 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \"010\" NEW_LINE t = \"101\" NEW_LINE n = len ( s ) NEW_LINE print ( minOperations ( s , t , n ) ) NEW_LINE DEDENT"],"bleu":0.8082051535121271,"rouge_l":0.958849840255591}
{"id":790,"predictions":["def toggleLastMBits ( n , m ) : NEW_LINE INDENT num = ( 1 << m ) - 1 NEW_LINE return ( n ^ num ) NEW_LINE DEDENT n = 107 NEW_LINE m = 4 NEW_LINE n = toggleLastMBits ( n , m ) NEW_LINE print ( n ) NEW_LINE"],"references":["def toggleLastMBits ( n , m ) : NEW_LINE INDENT num = ( 1 << m ) - 1 NEW_LINE return ( n ^ num ) NEW_LINE DEDENT n = 107 NEW_LINE m = 4 NEW_LINE print ( toggleLastMBits ( n , m ) ) NEW_LINE"],"bleu":0.8451984423351157,"rouge_l":0.9236063317274604}
{"id":791,"predictions":["def printmaxSubseq ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( i + 1 < n and arr [ i ] < arr [ i + 1 ] ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT DEDENT arr = [ 9 , 8 , 11 , 13 , 10 , 15 , 14 , 16 , 20 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE printmaxSubseq ( arr , n ) ; NEW_LINE"],"references":["def printmaxSubseq ( arr , n ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT if ( arr [ i ] < arr [ i + 1 ] ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ i ] ) ; NEW_LINE DEDENT DEDENT print ( arr [ n - 1 ] ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 9 , 8 , 11 , 13 , 10 , 15 , 14 , 16 , 20 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE printmaxSubseq ( arr , n ) ; NEW_LINE DEDENT"],"bleu":0.7532652521154559,"rouge_l":0.8406414432473066}
{"id":792,"predictions":["def printFibonacciNumbers ( n ) : NEW_LINE INDENT f1 = 0 NEW_LINE f2 = 1 NEW_LINE if ( n < 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( f2 , end = \" ▁ \" ) NEW_LINE next = f1 + f2 NEW_LINE f1 = f2 NEW_LINE f2 = next NEW_LINE DEDENT DEDENT printFibonacciNumbers ( 7 ) NEW_LINE"],"references":["def printFibonacciNumbers ( n ) : NEW_LINE INDENT f1 = 0 NEW_LINE f2 = 1 NEW_LINE if ( n < 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT for x in range ( 0 , n ) : NEW_LINE INDENT print ( f2 , end = \" ▁ \" ) NEW_LINE next = f1 + f2 NEW_LINE f1 = f2 NEW_LINE f2 = next NEW_LINE DEDENT DEDENT printFibonacciNumbers ( 7 ) NEW_LINE"],"bleu":0.8860722854088876,"rouge_l":0.9612787032868078}
{"id":793,"predictions":["def cal_cost ( dist , time ) : NEW_LINE INDENT print ( \" \\n ▁ Cost ▁ : ▁ \" , dist ) NEW_LINE print ( \" \\n ▁ : ▁ \" , dist ) NEW_LINE print ( \" \\n \" , dist ) NEW_LINE return dist \/ time NEW_LINE DEDENT def cal_seat ( n ) : NEW_LINE INDENT print ( \" \\n ▁ : ▁ \" , time ) NEW_LINE print ( \" \\n ▁ Time ▁ : ▁ \" , time ) NEW_LINE print ( \" \\n ▁ \" , dist ) NEW_LINE DEDENT def cal_t ( dist , n ) : NEW_LINE INDENT print ( \" \\n ▁ Length ▁ : ▁ \" , dist ) NEW_LINE print ( \" \\n ▁ \" , dist ) NEW_LINE DEDENT def cal_time ( dist , size ) : NEW_LINE INDENT print ( \" \\n ▁ Length ▁ : ▁ \" , dist ) NEW_LINE print ( \" \\n \" , dist ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( ) NEW_LINE DEDENT"],"references":["def cal_speed ( dist , time ) : NEW_LINE INDENT print ( \" ▁ Distance ( km ) ▁ : \" , dist ) ; NEW_LINE print ( \" ▁ Time ( hr ) ▁ : \" , time ) ; NEW_LINE return dist \/ time ; NEW_LINE DEDENT def cal_dis ( speed , time ) : NEW_LINE INDENT print ( \" ▁ Time ( hr ) ▁ : \" , time ) ; NEW_LINE print ( \" ▁ Speed ( km ▁ \/ ▁ hr ) ▁ : \" , speed ) ; NEW_LINE return speed * time ; NEW_LINE DEDENT def cal_time ( dist , speed ) : NEW_LINE INDENT print ( \" ▁ Distance ( km ) ▁ : \" , dist ) ; NEW_LINE print ( \" ▁ Speed ( km ▁ \/ ▁ hr ) ▁ : \" , speed ) ; NEW_LINE return speed * dist ; NEW_LINE DEDENT print ( \" ▁ The ▁ calculated ▁ Speed ( km ▁ \/ ▁ hr ) ▁ is ▁ : \" , cal_speed ( 45.9 , 2.0 ) ) ; NEW_LINE print ( \" \" ) ; NEW_LINE print ( \" ▁ The ▁ calculated ▁ Distance ( km ) ▁ : \" , cal_dis ( 62.9 , 2.5 ) ) ; NEW_LINE print ( \" \" ) ; NEW_LINE print ( \" ▁ The ▁ calculated ▁ Time ( hr ) ▁ : \" , cal_time ( 48.0 , 4.5 ) ) ; NEW_LINE"],"bleu":0.2516657727254777,"rouge_l":0.5212523020257827}
{"id":794,"predictions":["import math NEW_LINE def MermatFactors ( n ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT print ( \" [ \" , n , \" ] \" , end = \" \" ) ; NEW_LINE return ; NEW_LINE DEDENT if ( n & 1 ) : NEW_LINE INDENT print ( \" [ \" , n \/\/ 2.0\" , \" , \" ] \" ) ; NEW_LINE return ; NEW_LINE DEDENT a = math . ceil ( math . sqrt ( n ) ) ; NEW_LINE if ( a * a == n ) : NEW_LINE INDENT print ( \" [ \" , a , \" , \" , a , \" ] \" ) ; NEW_LINE return ; NEW_LINE DEDENT b = math . ceil ( math . sqrt ( b ) ) ; NEW_LINE if ( b * b == c1 ) : NEW_LINE INDENT print ( \" [ \" , a , \" , \" ] \" ) ; NEW_LINE return ; NEW_LINE DEDENT b = math . ceil ( sqrt ( b ) ) ; NEW_LINE print ( \" [ \" , ( a + b ) , \" , \" ] \" ) ; NEW_LINE return ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT mormatFactors ( 6 - b ) ; NEW_LINE DEDENT"],"references":["from math import ceil , sqrt NEW_LINE def FermatFactors ( n ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return [ n ] NEW_LINE DEDENT if ( n & 1 ) == 0 : NEW_LINE INDENT return [ n \/ 2 , 2 ] NEW_LINE DEDENT a = ceil ( sqrt ( n ) ) NEW_LINE if ( a * a == n ) : NEW_LINE INDENT return [ a , a ] NEW_LINE DEDENT while ( True ) : NEW_LINE INDENT b1 = a * a - n NEW_LINE b = int ( sqrt ( b1 ) ) NEW_LINE if ( b * b == b1 ) : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT a += 1 NEW_LINE DEDENT DEDENT return [ a - b , a + b ] NEW_LINE DEDENT print ( FermatFactors ( 6557 ) ) NEW_LINE"],"bleu":0.27560629742155796,"rouge_l":0.544593741545676}
{"id":795,"predictions":["def perfectCube ( N ) : NEW_LINE INDENT for i in range ( N + 1 ) : NEW_LINE INDENT cube = i * i NEW_LINE if cube == N : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE return NEW_LINE DEDENT elif cube > N : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE return NEW_LINE DEDENT elif cube > N : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 257 NEW_LINE perfectCube ( N ) NEW_LINE DEDENT"],"references":["def perfectCube ( N ) : NEW_LINE INDENT cube = 0 ; NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT cube = i * i * i ; NEW_LINE if ( cube == N ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE return ; NEW_LINE DEDENT elif ( cube > N ) : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE return ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 216 ; NEW_LINE perfectCube ( N ) ; NEW_LINE DEDENT"],"bleu":0.6433371757286614,"rouge_l":0.8285394694790668}
{"id":796,"predictions":["def removeDuplicates ( string , n ) : NEW_LINE INDENT index = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( string [ i ] == string [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( j == i ) : NEW_LINE INDENT string [ index ] = string [ i ] NEW_LINE index += 1 NEW_LINE DEDENT DEDENT return string [ index ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" geeksforgeeks \" NEW_LINE n = len ( string ) NEW_LINE print ( removeDuplicates ( string , n ) ) NEW_LINE DEDENT"],"references":["def removeDuplicate ( str , n ) : NEW_LINE INDENT index = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , i + 1 ) : NEW_LINE INDENT if ( str [ i ] == str [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( j == i ) : NEW_LINE INDENT str [ index ] = str [ i ] NEW_LINE index += 1 NEW_LINE DEDENT DEDENT return \" \" . join ( str [ : index ] ) NEW_LINE DEDENT str = \" geeksforgeeks \" NEW_LINE n = len ( str ) NEW_LINE print ( removeDuplicate ( list ( str ) , n ) ) NEW_LINE"],"bleu":0.6173218368832315,"rouge_l":0.787463401650253}
{"id":797,"predictions":["def compareSeq ( S , x , y , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( S [ x ] < S [ y ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT elif ( S [ x ] > S [ y ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT x = ( x + 1 ) % n NEW_LINE y = ( y + 1 ) % n NEW_LINE DEDENT return True NEW_LINE DEDENT def smallestSequence ( S , n ) : NEW_LINE INDENT index = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( compareSeq ( S , index , n ) ) : NEW_LINE INDENT index = i NEW_LINE DEDENT DEDENT return index NEW_LINE DEDENT def smallestSequence ( S , n ) : NEW_LINE INDENT S = str ( S ) NEW_LINE start_index = smallestSequence ( S , n ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( S [ ( start_index + i ) % n ] ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = \" dACBCAA \" NEW_LINE n = 8 NEW_LINE printSmallestSequence ( S , n ) NEW_LINE DEDENT"],"references":["import copy NEW_LINE def printSmallestSequence ( s ) : NEW_LINE INDENT m = copy . copy ( s ) NEW_LINE for i in range ( len ( s ) - 1 ) : NEW_LINE INDENT if m > s [ i : ] + s [ : i ] : NEW_LINE INDENT m = s [ i : ] + s [ : i ] NEW_LINE DEDENT DEDENT return m NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT st = ' DCACBCAA ' NEW_LINE print ( printSmallestSequence ( st ) ) NEW_LINE DEDENT"],"bleu":0.12875504771333515,"rouge_l":0.3533333333333334}
{"id":798,"predictions":["def partSort ( arr , N , a , b ) : NEW_LINE INDENT l = min ( a , b ) NEW_LINE r = max ( a , b ) NEW_LINE temp = [ 0 for i in range ( l - l + 1 ) ] NEW_LINE j = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT temp [ j ] = arr [ i ] NEW_LINE j += 1 NEW_LINE DEDENT temp . sort ( ) NEW_LINE j = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT arr [ i ] = temp [ j ] NEW_LINE j += 1 NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 7 , 8 , 4 , 5 , 2 ] NEW_LINE a = 1 ; NEW_LINE b = 4 NEW_LINE N = len ( arr ) NEW_LINE partSort ( arr , N , a , b ) NEW_LINE"],"references":["def partSort ( arr , N , a , b ) : NEW_LINE INDENT l = min ( a , b ) NEW_LINE r = max ( a , b ) NEW_LINE temp = [ 0 for i in range ( r - l + 1 ) ] NEW_LINE j = 0 NEW_LINE for i in range ( l , r + 1 , 1 ) : NEW_LINE INDENT temp [ j ] = arr [ i ] NEW_LINE j += 1 NEW_LINE DEDENT temp . sort ( reverse = False ) NEW_LINE j = 0 NEW_LINE for i in range ( l , r + 1 , 1 ) : NEW_LINE INDENT arr [ i ] = temp [ j ] NEW_LINE j += 1 NEW_LINE DEDENT for i in range ( 0 , N , 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 7 , 8 , 4 , 5 , 2 ] NEW_LINE a = 1 NEW_LINE b = 4 NEW_LINE N = len ( arr ) NEW_LINE partSort ( arr , N , a , b ) NEW_LINE DEDENT"],"bleu":0.8240170574592874,"rouge_l":0.9200454103146285}
{"id":799,"predictions":["def checkYear ( year ) : NEW_LINE INDENT if ( year % 400 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( year % 100 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( year % 4 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT year = 2000 NEW_LINE if ( checkYear ( year ) ) : NEW_LINE INDENT print ( \" Leap ▁ Year \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ a ▁ Leap ▁ Year \" ) NEW_LINE DEDENT"],"references":["def checkYear ( year ) : NEW_LINE INDENT if ( year % 4 ) == 0 : NEW_LINE INDENT if ( year % 100 ) == 0 : NEW_LINE INDENT if ( year % 400 ) == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT year = 2000 NEW_LINE if ( checkYear ( year ) ) : NEW_LINE INDENT print ( \" Leap ▁ Year \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ a ▁ Leap ▁ Year \" ) NEW_LINE DEDENT"],"bleu":0.7144963162612622,"rouge_l":0.7973856209150325}
{"id":800,"predictions":["def countPairs ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE right , left = 0 , 0 NEW_LINE visited = [ False for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( right < n and visited [ arr [ right ] ] ) : NEW_LINE INDENT count += ( right - left ) NEW_LINE visited [ arr [ right ] ] = True NEW_LINE right += 1 NEW_LINE DEDENT while ( left < right and ( right != n and visited [ arr [ right ] ] ) ) : NEW_LINE INDENT visited [ arr [ left ] ] = False NEW_LINE left += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 4 , 2 , 4 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE DEDENT"],"references":["def countPairs ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE right = 0 NEW_LINE left = 0 NEW_LINE visited = [ False for i in range ( n ) ] NEW_LINE while ( right < n ) : NEW_LINE INDENT while ( right < n and visited [ arr [ right ] ] == False ) : NEW_LINE INDENT count += ( right - left ) NEW_LINE visited [ arr [ right ] ] = True NEW_LINE right += 1 NEW_LINE DEDENT while ( left < right and ( right != n and visited [ arr [ right ] ] == True ) ) : NEW_LINE INDENT visited [ arr [ left ] ] = False NEW_LINE left += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 4 , 2 , 4 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.9018757635707313,"rouge_l":0.9503848650653808}
{"id":801,"predictions":["def binarySearch ( arr , n , x ) : NEW_LINE INDENT l = 0 NEW_LINE r = len ( arr ) - 1 NEW_LINE while ( l <= r ) : NEW_LINE INDENT m = l + ( r - l ) \/\/ 2 NEW_LINE if ( arr [ m ] == x ) : NEW_LINE INDENT return m NEW_LINE DEDENT elif ( arr [ m ] < x ) : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = m - 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 10 , 40 ] NEW_LINE x = len ( arr ) NEW_LINE result = binarySearch ( arr , n , x ) NEW_LINE if ( result != - 1 ) : NEW_LINE INDENT print ( \" Element ▁ is ▁ present ▁ in ▁ array \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Element ▁ is ▁ not ▁ present ▁ in ▁ index \" , result ) NEW_LINE DEDENT"],"references":["def binarySearch ( arr , l , r , x ) : NEW_LINE INDENT while l <= r : NEW_LINE INDENT mid = l + ( r - l ) \/\/ 2 ; NEW_LINE if arr [ mid ] == x : NEW_LINE INDENT return mid NEW_LINE DEDENT elif arr [ mid ] < x : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = mid - 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 10 , 40 ] NEW_LINE x = 10 NEW_LINE result = binarySearch ( arr , 0 , len ( arr ) - 1 , x ) NEW_LINE if result != - 1 : NEW_LINE INDENT print ( \" Element ▁ is ▁ present ▁ at ▁ index ▁ % ▁ d \" % result ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Element ▁ is ▁ not ▁ present ▁ in ▁ array \" ) NEW_LINE DEDENT"],"bleu":0.6508407667411646,"rouge_l":0.8156308851224107}
{"id":802,"predictions":["def isComposite ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT print ( \" False \" ) NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT print ( \" False \" ) NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( isComposite ( 11 ) ) NEW_LINE DEDENT"],"references":["def isComposite ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return False NEW_LINE DEDENT print ( \" true \" ) if ( isComposite ( 11 ) ) else print ( \" false \" ) NEW_LINE print ( \" true \" ) if ( isComposite ( 15 ) ) else print ( \" false \" ) NEW_LINE"],"bleu":0.7435547422823251,"rouge_l":0.7897571035747022}
{"id":803,"predictions":["def decToBinary ( n ) : NEW_LINE INDENT binaryNum = [ 0 ] * 32 ; NEW_LINE i = 0 ; NEW_LINE while ( n ) : NEW_LINE INDENT binaryNum [ i ] = n % 2 ; NEW_LINE n = n \/\/ 2 ; NEW_LINE i += 1 ; NEW_LINE DEDENT for j in range ( i - 1 , - 1 ) : NEW_LINE INDENT print ( binaryNum [ j ] ) ; NEW_LINE DEDENT DEDENT n = 17 ; NEW_LINE decToBinary ( n ) ; NEW_LINE"],"references":["def decToBinary ( n ) : NEW_LINE INDENT binaryNum = [ 0 ] * n ; NEW_LINE i = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT binaryNum [ i ] = n % 2 ; NEW_LINE n = int ( n \/ 2 ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( binaryNum [ j ] , end = \" \" ) ; NEW_LINE DEDENT DEDENT n = 17 ; NEW_LINE decToBinary ( n ) ; NEW_LINE"],"bleu":0.7689799655554485,"rouge_l":0.8999491266745803}
{"id":804,"predictions":["def solve_sum ( n ) : NEW_LINE INDENT return ( n * ( pow ( n , 2 ) + 3 * n + 5 ) ) \/ 3 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 25 NEW_LINE print ( int ( solve_sum ( n ) ) ) NEW_LINE DEDENT"],"references":["def findSum ( n ) : NEW_LINE INDENT return ( n * ( pow ( n , 2 ) + 3 * n + 5 ) ) \/ 3 NEW_LINE DEDENT n = 25 NEW_LINE print ( int ( findSum ( n ) ) ) NEW_LINE"],"bleu":0.6653064444230797,"rouge_l":0.8504435994930292}
{"id":805,"predictions":["def isPerfectSquare ( n ) : NEW_LINE INDENT i = 1 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( n % i == 0 and ( n \/ i == i ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 36 NEW_LINE if isPerfectSquare ( n ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def isPerfectSquare ( n ) : NEW_LINE INDENT i = 1 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( ( n % i == 0 ) and ( n \/ i == i ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 36 NEW_LINE if ( isPerfectSquare ( n ) ) : NEW_LINE INDENT print ( \" Yes , ▁ it ▁ is ▁ a ▁ perfect ▁ square . \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No , ▁ it ▁ is ▁ not ▁ a ▁ perfect ▁ square . \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.6150293516676839,"rouge_l":0.8230758639680573}
{"id":806,"predictions":["N = 101 NEW_LINE mod = 1000000007 NEW_LINE perfectnum = [ [ 0 for x in range ( N ) ] for y in range ( N ) ] for y in range ( N + 1 ) ] NEW_LINE def getSum ( x , y , z ) : NEW_LINE INDENT ans = 0 NEW_LINE exactnum [ 0 for x in range ( N ) ] [ 0 ] = 1 NEW_LINE for i in range ( x + 1 ) : NEW_LINE INDENT for j in range ( y + 1 ) : NEW_LINE INDENT for k in range ( z + 1 ) : NEW_LINE INDENT if ( i > 0 ) : NEW_LINE INDENT exactsum [ i ] [ j ] += ( ( exactsum [ i - 1 ] [ j ] * 10 + 4 * exactnum [ i - 1 ] [ j ] ) % mod NEW_LINE DEDENT if ( j > 0 ) : NEW_LINE INDENT exactnum [ i ] [ j ] += ( exactnum [ i - 1 ] [ j ] [ k ] * 10 + 5 * perfectnum [ i - 1 ] [ k ] ) % mod NEW_LINE DEDENT if ( j > 0 ) : NEW_LINE INDENT exactsum [ i ] [ j ] += ( exactsum [ i ] [ j - 1 ] [ k ] * 10 + 5 * sqnum [ i ] [ j ] ) % mod NEW_LINE DEDENT if ( k > 0 ) : NEW_LINE INDENT exactnum [ i ] [ j ] += ( exactsum [ i ] [ j - 1 ] [ k - 1 ] [ k ] ) % mod NEW_LINE exactnum [ i ] [ j ] += ( perfectsum [ i ] [ j ] [ k - 1 ] [ k ] ) % mod NEW_LINE DEDENT ans += exactsum [ i ] [ j ] [ k ] [ j ] % mod NEW_LINE ans %= mod NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = 1 NEW_LINE y = 1 NEW_LINE z = 1 NEW_LINE print ( getSum ( x , y , z ) % mod ) NEW_LINE DEDENT"],"references":["import numpy as np NEW_LINE N = 101 ; NEW_LINE mod = int ( 1e9 ) + 7 ; NEW_LINE exactsum = np . zeros ( ( N , N , N ) ) ; NEW_LINE exactnum = np . zeros ( ( N , N , N ) ) ; NEW_LINE def getSum ( x , y , z ) : NEW_LINE INDENT ans = 0 ; NEW_LINE exactnum [ 0 ] [ 0 ] [ 0 ] = 1 ; NEW_LINE for i in range ( x + 1 ) : NEW_LINE INDENT for j in range ( y + 1 ) : NEW_LINE INDENT for k in range ( z + 1 ) : NEW_LINE INDENT if ( i > 0 ) : NEW_LINE INDENT exactsum [ i ] [ j ] [ k ] += ( exactsum [ i - 1 ] [ j ] [ k ] * 10 + 4 * exactnum [ i - 1 ] [ j ] [ k ] ) % mod ; NEW_LINE exactnum [ i ] [ j ] [ k ] += exactnum [ i - 1 ] [ j ] [ k ] % mod ; NEW_LINE DEDENT if ( j > 0 ) : NEW_LINE INDENT exactsum [ i ] [ j ] [ k ] += ( exactsum [ i ] [ j - 1 ] [ k ] * 10 + 5 * exactnum [ i ] [ j - 1 ] [ k ] ) % mod ; NEW_LINE exactnum [ i ] [ j ] [ k ] += exactnum [ i ] [ j - 1 ] [ k ] % mod ; NEW_LINE DEDENT if ( k > 0 ) : NEW_LINE INDENT exactsum [ i ] [ j ] [ k ] += ( exactsum [ i ] [ j ] [ k - 1 ] * 10 + 6 * exactnum [ i ] [ j ] [ k - 1 ] ) % mod ; NEW_LINE exactnum [ i ] [ j ] [ k ] += exactnum [ i ] [ j ] [ k - 1 ] % mod ; NEW_LINE DEDENT ans += exactsum [ i ] [ j ] [ k ] % mod ; NEW_LINE ans %= mod ; NEW_LINE DEDENT DEDENT DEDENT return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = 1 ; y = 1 ; z = 1 ; NEW_LINE print ( ( getSum ( x , y , z ) % mod ) ) ; NEW_LINE DEDENT"],"bleu":0.639406327910429,"rouge_l":0.751290272130122}
{"id":807,"predictions":["def countPairs ( s ) : NEW_LINE INDENT st = set ( ) ; NEW_LINE st . add ( ' a ' ) ; NEW_LINE st . add ( ' e ' ) ; NEW_LINE st . add ( ' o ' ) ; NEW_LINE count = 0 ; NEW_LINE n = len ( st ) ; NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if s [ i ] not in st : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" geeksforgeeks \" ; NEW_LINE print ( countPairs ( s ) ) ; NEW_LINE DEDENT"],"references":["def countPairs ( s ) : NEW_LINE INDENT st = set ( ) ; NEW_LINE st . add ( ' a ' ) ; NEW_LINE st . add ( ' e ' ) ; NEW_LINE st . add ( ' i ' ) ; NEW_LINE st . add ( ' o ' ) ; NEW_LINE st . add ( ' u ' ) ; NEW_LINE count = 0 ; NEW_LINE n = len ( s ) ; NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( s [ i ] not in st and s [ i + 1 ] in st ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" geeksforgeeks \" ; NEW_LINE print ( countPairs ( s ) ) ; NEW_LINE DEDENT"],"bleu":0.7448719246249919,"rouge_l":0.8634412344819585}
{"id":808,"predictions":["MOD = 1000000007 ; NEW_LINE def modulo_13 ( s , n ) : NEW_LINE INDENT dp = [ [ 0 ] * 13 for i in range ( n + 1 ) ] ; NEW_LINE dp [ 0 ] [ 0 ] = 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT nxt = ord ( s [ i ] ) - ord ( '0' ) ; NEW_LINE if ( s [ i ] == ' ? ' ) : NEW_LINE INDENT nxt = j ; NEW_LINE DEDENT for k in range ( 13 ) : NEW_LINE INDENT rem = ( 10 * k + nxt ) % 13 ; NEW_LINE dp [ i + 1 ] [ rem ] += dp [ i ] [ rem ] ; NEW_LINE dp [ i + 1 ] [ rem ] %= MOD ; NEW_LINE DEDENT if ( s [ i ] != ' ? ' ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT return dp [ n ] [ 5 ] ; NEW_LINE DEDENT s = \" ? 44\" ; NEW_LINE n = len ( s ) ; NEW_LINE print ( modulo_13 ( s , n ) ) ; NEW_LINE"],"references":["import numpy as np NEW_LINE MOD = ( int ) ( 1e9 + 7 ) NEW_LINE def modulo_13 ( s , n ) : NEW_LINE INDENT dp = np . zeros ( ( n + 1 , 13 ) ) ; NEW_LINE dp [ 0 ] [ 0 ] = 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT nxt = ord ( s [ i ] ) - ord ( '0' ) ; NEW_LINE if ( s [ i ] == ' ? ' ) : NEW_LINE INDENT nxt = j ; NEW_LINE DEDENT for k in range ( 13 ) : NEW_LINE INDENT rem = ( 10 * k + nxt ) % 13 ; NEW_LINE dp [ i + 1 ] [ rem ] += dp [ i ] [ k ] ; NEW_LINE dp [ i + 1 ] [ rem ] %= MOD ; NEW_LINE DEDENT if ( s [ i ] != ' ? ' ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT DEDENT return int ( dp [ n ] [ 5 ] ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" ? 44\" ; NEW_LINE n = len ( s ) ; NEW_LINE print ( modulo_13 ( s , n ) ) ; NEW_LINE DEDENT"],"bleu":0.7845461782362367,"rouge_l":0.8743012756198938}
{"id":809,"predictions":["def max_ profit ( a , b , n , loss ) : NEW_LINE INDENT l = 0 NEW_LINE r = 1 NEW_LINE b [ 0 ] = 0 NEW_LINE b [ 1 ] = diff NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT l = 0 NEW_LINE r = diff_ NEW_LINE sum = 0 NEW_LINE for j in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT profit = ( a [ r ] - a [ l ] ) - loss NEW_LINE if ( profit > 0 ) : NEW_LINE INDENT sum = sum + profit NEW_LINE DEDENT l += 1 NEW_LINE r += 1 NEW_LINE DEDENT if ( b [ 0 ] < sum ) : NEW_LINE INDENT b [ 0 ] = sum NEW_LINE b [ 1 ] = diff NEW_LINE DEDENT diff_odd += 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT arr = [ 6 , 1 , 7 , 2 , 8 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE b = [ 2 , 1 , 7 , 2 , 8 , 4 ] NEW_LINE print ( b [ 0 ] , b [ 1 ] ) NEW_LINE"],"references":["def max_profit ( a , b , n , fee ) : NEW_LINE INDENT i , j , profit = 1 , n - 1 , 0 NEW_LINE l , r , diff_day = 0 , 0 , 1 NEW_LINE b [ 0 ] = 0 NEW_LINE b [ 1 ] = diff_day NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT l = 0 NEW_LINE r = diff_day NEW_LINE Sum = 0 NEW_LINE for j in range ( n - 1 , i - 1 , - 1 ) : NEW_LINE INDENT profit = ( a [ r ] - a [ l ] ) - fee NEW_LINE if ( profit > 0 ) : NEW_LINE INDENT Sum = Sum + profit NEW_LINE DEDENT l += 1 NEW_LINE r += 1 NEW_LINE DEDENT if ( b [ 0 ] < Sum ) : NEW_LINE INDENT b [ 0 ] = Sum NEW_LINE b [ 1 ] = diff_day NEW_LINE DEDENT DEDENT diff_day += 1 NEW_LINE return 0 NEW_LINE DEDENT arr = [ 6 , 1 , 7 , 2 , 8 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE b = [ 0 for i in range ( 2 ) ] NEW_LINE tranFee = 2 NEW_LINE max_profit ( arr , b , n , tranFee ) NEW_LINE print ( b [ 0 ] , \" , \" , b [ 1 ] ) NEW_LINE"],"bleu":0.6436281614837388,"rouge_l":0.8111702127659574}
{"id":810,"predictions":["MAX = 25 NEW_LINE def getMinSum ( arr , n ) : NEW_LINE INDENT bits_count = [ 0 for i in range ( MAX ) ] NEW_LINE max_bit = 0 NEW_LINE sum = 0 NEW_LINE ans = 0 NEW_LINE for d in range ( n ) : NEW_LINE INDENT e = arr [ d ] NEW_LINE f = 0 NEW_LINE while ( e > 0 ) : NEW_LINE INDENT rem = e % 2 NEW_LINE e = e \/\/ 2 NEW_LINE if ( rem == 1 ) : NEW_LINE INDENT bits_count [ f ] += rem NEW_LINE DEDENT f += 1 NEW_LINE DEDENT max_bit = max ( max_bit , f ) NEW_LINE DEDENT for d in range ( max_bit ) : NEW_LINE INDENT temp = pow ( 2 , d ) NEW_LINE if ( bits_count [ d ] > n \/\/ 2 ) : NEW_LINE INDENT ans = ans + temp NEW_LINE DEDENT DEDENT for d in range ( n ) : NEW_LINE INDENT arr [ d ] = arr [ d ] ^ ans NEW_LINE sum = sum + arr [ d ] NEW_LINE DEDENT return sum NEW_LINE DEDENT arr = [ 3 , 5 , 7 , 11 , 15 ] NEW_LINE n = len ( arr ) NEW_LINE print ( getMinSum ( arr , n ) ) NEW_LINE"],"references":["MAX = 25 ; NEW_LINE def getMinSum ( arr , n ) : NEW_LINE INDENT bits_count = [ 0 ] * MAX NEW_LINE max_bit = 0 ; sum = 0 ; ans = 0 ; NEW_LINE for d in range ( n ) : NEW_LINE INDENT e = arr [ d ] ; f = 0 ; NEW_LINE while ( e > 0 ) : NEW_LINE INDENT rem = e % 2 ; NEW_LINE e = e \/\/ 2 ; NEW_LINE if ( rem == 1 ) : NEW_LINE INDENT bits_count [ f ] += rem ; NEW_LINE DEDENT f += 1 NEW_LINE DEDENT max_bit = max ( max_bit , f ) ; NEW_LINE DEDENT for d in range ( max_bit ) : NEW_LINE INDENT temp = pow ( 2 , d ) ; NEW_LINE if ( bits_count [ d ] > n \/\/ 2 ) : NEW_LINE INDENT ans = ans + temp ; NEW_LINE DEDENT DEDENT for d in range ( n ) : NEW_LINE INDENT arr [ d ] = arr [ d ] ^ ans ; NEW_LINE sum = sum + arr [ d ] ; NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 5 , 7 , 11 , 15 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( getMinSum ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.7478427659655039,"rouge_l":0.9017725775940587}
{"id":811,"predictions":["def findNums ( arr , n ) : NEW_LINE INDENT S = 0 NEW_LINE X = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT S += arr [ i ] NEW_LINE X ^= arr [ i ] NEW_LINE DEDENT print ( X , X + S ) NEW_LINE DEDENT arr = [ 1 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE findNums ( arr , n ) NEW_LINE"],"references":["def findNums ( arr , n ) : NEW_LINE INDENT S = 0 ; X = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT S += arr [ i ] ; NEW_LINE X ^= arr [ i ] ; NEW_LINE DEDENT print ( X , X + S ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 7 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE findNums ( arr , n ) ; NEW_LINE DEDENT"],"bleu":0.6124621287497198,"rouge_l":0.8467454511348715}
{"id":812,"predictions":["def bin ( n ) : NEW_LINE INDENT if n > 1 : NEW_LINE INDENT bin ( n >> 1 ) NEW_LINE DEDENT print ( n & 1 , end = \" & 1 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT bin ( 131 ) NEW_LINE print ( \" % d \" ) NEW_LINE bin ( 3 ) NEW_LINE DEDENT"],"references":["def bin ( n ) : NEW_LINE INDENT if ( n > 1 ) : NEW_LINE INDENT bin ( n >> 1 ) NEW_LINE DEDENT print ( n & 1 , end = \" \" ) NEW_LINE DEDENT bin ( 131 ) NEW_LINE print ( ) NEW_LINE bin ( 3 ) NEW_LINE"],"bleu":0.6039527133499896,"rouge_l":0.8309702529886016}
{"id":813,"predictions":["def Square ( row , column , moves ) : NEW_LINE INDENT a , b , c , d = 0 , 0 , 0 , 0 NEW_LINE a = row - moves NEW_LINE b = row + moves NEW_LINE c = column + moves NEW_LINE d = column + moves NEW_LINE if ( a < 1 ) : NEW_LINE INDENT a = 1 NEW_LINE DEDENT if ( b < 1 ) : NEW_LINE INDENT c = 1 NEW_LINE DEDENT if ( b > 8 ) : NEW_LINE INDENT b = 8 NEW_LINE DEDENT if ( d > 8 ) : NEW_LINE INDENT d = 8 NEW_LINE DEDENT total = ( b - a + 1 ) * ( d - c + 1 ) - 1 NEW_LINE return total NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT R , C , M = 4 , 5 , 2 NEW_LINE print ( Square ( R , C , M ) ) NEW_LINE DEDENT"],"references":["def Square ( row , column , moves ) : NEW_LINE INDENT a = 0 ; b = 0 ; c = 0 ; NEW_LINE d = 0 ; total = 0 ; NEW_LINE a = row - moves ; NEW_LINE b = row + moves ; NEW_LINE c = column - moves ; NEW_LINE d = column + moves ; NEW_LINE if ( a < 1 ) : NEW_LINE INDENT a = 1 ; NEW_LINE DEDENT if ( c < 1 ) : NEW_LINE INDENT c = 1 ; NEW_LINE DEDENT if ( b > 8 ) : NEW_LINE INDENT b = 8 ; NEW_LINE DEDENT if ( d > 8 ) : NEW_LINE INDENT d = 8 ; NEW_LINE DEDENT total = ( b - a + 1 ) * ( d - c + 1 ) - 1 ; NEW_LINE return total ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT R = 4 ; C = 5 ; M = 2 ; NEW_LINE print ( Square ( R , C , M ) ) ; NEW_LINE DEDENT"],"bleu":0.6335509491050316,"rouge_l":0.8415320384824833}
{"id":814,"predictions":["import math NEW_LINE def firstkdigits ( n , k ) : NEW_LINE INDENT product = 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT product *= n ; NEW_LINE DEDENT while ( product \/\/ pow ( 10 , k ) ) != 0 : NEW_LINE INDENT product = product \/\/ 10 ; NEW_LINE DEDENT return product ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 15 ; NEW_LINE k = 4 ; NEW_LINE print ( firstkdigits ( n , k ) ) ; NEW_LINE DEDENT"],"references":["def firstkdigits ( n , k ) : NEW_LINE INDENT product = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT product *= n NEW_LINE DEDENT while ( ( product \/\/ pow ( 10 , k ) ) != 0 ) : NEW_LINE INDENT product = product \/\/ 10 NEW_LINE DEDENT return product NEW_LINE DEDENT n = 15 NEW_LINE k = 4 NEW_LINE print ( firstkdigits ( n , k ) ) NEW_LINE"],"bleu":0.6078518263334247,"rouge_l":0.870420362514462}
{"id":815,"predictions":["def solve ( X , Y , N , K ) : NEW_LINE INDENT count = [ 0 ] * ( N + 1 ) NEW_LINE sol = 0 NEW_LINE count [ 0 ] = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT count [ i ] = count [ i - 1 ] + abs ( ord ( X [ i - 1 ] ) - ord ( Y [ i - 1 ] ) ) NEW_LINE DEDENT j = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT while ( count [ i ] - count [ j ] ) > K ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT sol = max ( sol , i - j ) NEW_LINE DEDENT return sol NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 4 NEW_LINE X = \" abcd \" NEW_LINE Y = \" bcde \" NEW_LINE K = 3 NEW_LINE print ( solve ( X , Y , N , K ) ) NEW_LINE DEDENT"],"references":["def solve ( X , Y , N , K ) : NEW_LINE INDENT count = [ 0 ] * ( N + 1 ) ; NEW_LINE sol = 0 ; NEW_LINE count [ 0 ] = 0 ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT count [ i ] = ( count [ i - 1 ] + abs ( ord ( X [ i - 1 ] ) - ord ( Y [ i - 1 ] ) ) ) ; NEW_LINE DEDENT j = 0 ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT while ( ( count [ i ] - count [ j ] ) > K ) : NEW_LINE INDENT j += 1 ; NEW_LINE DEDENT sol = max ( sol , i - j ) ; NEW_LINE DEDENT return sol ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 ; NEW_LINE X = \" abcd \" ; NEW_LINE Y = \" bcde \" ; NEW_LINE K = 3 ; NEW_LINE print ( solve ( X , Y , N , K ) ) ; NEW_LINE DEDENT"],"bleu":0.7871870125164032,"rouge_l":0.9431966145833333}
{"id":816,"predictions":["MAX = 1000 ; NEW_LINE f = [ 0 ] * MAX ; NEW_LINE def fib ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( n == 1 or n == 2 ) : NEW_LINE INDENT f [ n ] = 1 ; NEW_LINE DEDENT if ( f [ n ] ) : NEW_LINE INDENT return f [ n ] ; NEW_LINE DEDENT k = 0 ; NEW_LINE if ( n & 1 ) : NEW_LINE INDENT k = ( n + 1 ) \/\/ 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT k = n \/\/ 2 ; NEW_LINE DEDENT if ( n & 1 ) : NEW_LINE INDENT f [ n ] = ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT f [ n ] = ( 2 * fib ( k - 1 ) + fib ( k ) * fib ( k ) ) ; NEW_LINE DEDENT return f [ n ] ; NEW_LINE DEDENT def gcd ( a , b ) : NEW_LINE INDENT return ( fib ( a ) * fib ( b ) ) \/ fib ( gcd ( a , b ) ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 3 ; NEW_LINE b = 12 ; NEW_LINE print ( findLCMibonacci ( a , b ) ) ; NEW_LINE DEDENT"],"references":["MAX = 1000 NEW_LINE f = [ 0 ] * MAX NEW_LINE def fib ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 1 or n == 2 ) : NEW_LINE INDENT f [ n ] = 1 NEW_LINE return f [ n ] NEW_LINE DEDENT if ( f [ n ] ) : NEW_LINE INDENT return f [ n ] NEW_LINE DEDENT k = ( n + 1 ) \/\/ 2 if ( n & 1 ) else n \/\/ 2 NEW_LINE if ( n & 1 ) : NEW_LINE INDENT f [ n ] = ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT f [ n ] = ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ) NEW_LINE DEDENT return f [ n ] NEW_LINE DEDENT def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def findLCMFibonacci ( a , b ) : NEW_LINE INDENT return ( fib ( a ) * fib ( b ) ) \/\/ fib ( gcd ( a , b ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 3 NEW_LINE b = 12 NEW_LINE print ( findLCMFibonacci ( a , b ) ) NEW_LINE DEDENT"],"bleu":0.7636479922674941,"rouge_l":0.8385385264681056}
{"id":817,"predictions":["def find_digit ( s , n ) : NEW_LINE INDENT first_digit = - 1 NEW_LINE i = n - 1 NEW_LINE while i >= 0 : NEW_LINE INDENT if ( s [ i ] < '0' or s [ i ] > '9' ) : NEW_LINE INDENT first_digit = i NEW_LINE break NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT first_digit += 1 NEW_LINE s_len = first_digit NEW_LINE num = 1 NEW_LINE i = n - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( s [ i ] >= '0' and s [ i ] <= '9' ) : NEW_LINE INDENT digit = ord ( s [ i ] ) - ord ( '0' ) NEW_LINE num = num + ( pw * digit ) NEW_LINE if ( num >= s_len ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT pw = pw * 10 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT num = num * 10 NEW_LINE req = s_len - num NEW_LINE if ( req > 9 or req < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return req NEW_LINE DEDENT s = \" abcd0\" NEW_LINE n = len ( s ) NEW_LINE print ( find_digit ( s , n ) ) NEW_LINE"],"references":["def find_digit ( s , n ) : NEW_LINE INDENT first_digit = - 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if s [ i ] < '0' or s [ i ] > '9' : NEW_LINE INDENT first_digit = i NEW_LINE break NEW_LINE DEDENT DEDENT first_digit += 1 NEW_LINE s_len = first_digit NEW_LINE num = 0 NEW_LINE pw = 1 NEW_LINE i = n - 1 NEW_LINE while i >= 0 : NEW_LINE INDENT if s [ i ] >= '0' and s [ i ] <= '9' : NEW_LINE INDENT digit = ord ( s [ i ] ) - ord ( '0' ) NEW_LINE num = num + ( pw * digit ) NEW_LINE if num >= s_len : NEW_LINE INDENT return - 1 NEW_LINE DEDENT pw = pw * 10 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT num = num * 10 NEW_LINE req = s_len - num NEW_LINE if req > 9 or req < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return req NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" abcd0\" NEW_LINE n = len ( s ) NEW_LINE print ( find_digit ( s , n ) ) NEW_LINE DEDENT"],"bleu":0.7878140614629756,"rouge_l":0.883524441762221}
{"id":818,"predictions":["def findNthNumber ( A , B , N ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT sum = A + B NEW_LINE A = B NEW_LINE B = sum NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = 5 NEW_LINE B = 7 NEW_LINE N = 10 NEW_LINE print ( findNthNumber ( A , B , N ) ) NEW_LINE DEDENT"],"references":["def findNthNumber ( A , B , N ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT sum = A + B NEW_LINE A = B NEW_LINE B = sum NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = 5 NEW_LINE B = 7 NEW_LINE N = 10 NEW_LINE print ( findNthNumber ( A , B , N ) ) NEW_LINE DEDENT"],"bleu":1.0,"rouge_l":1.0}
{"id":819,"predictions":["from math import pow NEW_LINE def calculateSum ( n ) : NEW_LINE INDENT return ( pow ( 10 , n + 1 ) * ( 9 * n - 1 ) + 10 ) \/ pow ( 9 , 3 ) - n * ( n + 1 ) \/ 18 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE print ( \" Sum = \" , calculateSum ( n ) ) NEW_LINE DEDENT"],"references":["def solve_sum ( n ) : NEW_LINE INDENT return ( pow ( 10 , n + 1 ) * ( 9 * n - 1 ) + 10 ) \/ pow ( 9 , 3 ) - n * ( n + 1 ) \/ 18 NEW_LINE DEDENT n = 3 NEW_LINE print ( int ( solve_sum ( n ) ) ) NEW_LINE"],"bleu":0.6183715817958435,"rouge_l":0.8053721830184384}
{"id":820,"predictions":["def summation ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) * ( 2 * n + 1 ) ) \/ 6 ; NEW_LINE DEDENT print ( summation ( 10 ) ) ; NEW_LINE"],"references":["def summation ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) * ( 2 * n + 1 ) ) \/ 6 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE print ( summation ( n ) ) NEW_LINE DEDENT"],"bleu":0.5378909923649621,"rouge_l":0.748342175066313}
{"id":821,"predictions":["import math NEW_LINE def mean ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + arr [ i ] NEW_LINE DEDENT return sum \/ n NEW_LINE DEDENT def satisfies ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + ( arr [ i ] - mean ( arr , n ) ) * ( arr [ i ] - mean ( arr , n ) ) NEW_LINE DEDENT return math . sqrt ( sum \/ ( n - 1 ) ) NEW_LINE DEDENT def sampleError ( arr , n ) : NEW_LINE INDENT return SSD ( arr , n ) \/ math . sqrt ( n ) NEW_LINE DEDENT arr = [ 78.53 , 89.62f , 80.25 NEW_LINE n = len ( arr ) NEW_LINE print ( sampleError ( arr , n ) ) NEW_LINE"],"references":["import math NEW_LINE def mean ( arr , n ) : NEW_LINE INDENT sm = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sm = sm + arr [ i ] NEW_LINE DEDENT return sm \/ n NEW_LINE DEDENT def SSD ( arr , n ) : NEW_LINE INDENT sm = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sm = sm + ( arr [ i ] - mean ( arr , n ) ) * ( arr [ i ] - mean ( arr , n ) ) NEW_LINE DEDENT return ( math . sqrt ( sm \/ ( n - 1 ) ) ) NEW_LINE DEDENT def sampleError ( arr , n ) : NEW_LINE INDENT return SSD ( arr , n ) \/ ( math . sqrt ( n ) ) NEW_LINE DEDENT arr = [ 78.53 , 79.62 , 80.25 , 81.05 , 83.21 , 83.46 ] NEW_LINE n = len ( arr ) NEW_LINE print ( sampleError ( arr , n ) ) NEW_LINE"],"bleu":0.7338019492364104,"rouge_l":0.8927938845902863}
{"id":822,"predictions":["INF = 9999999 NEW_LINE def sqrtToLongDivision ( n ) : NEW_LINE INDENT i = 0 NEW_LINE curr = 0 NEW_LINE quotient_units_digit = 0 NEW_LINE curr_triient = 0 NEW_LINE curr = 0 NEW_LINE a = [ 0 for i in range ( 10 ) ] NEW_LINE while ( n > 0 ) : NEW_LINE INDENT a [ i ] = n % 100 NEW_LINE n = n \/\/ 100 NEW_LINE i += 1 NEW_LINE DEDENT i -= 1 NEW_LINE for j in range ( i , - 1 , - 1 ) : NEW_LINE INDENT curr_remainderr = INFFER NEW_LINE currdividend = curr_dividend * 100 + a [ j ] NEW_LINE for udigit in range ( 0 , 10 , - 1 ) : NEW_LINE INDENT if ( cur_remainderr - ( ( cur_divisor * 10 + udigit ) * udigit ) and curr_dividend - ( ( cur_divisor * 10 + udigit ) * udigit ) >= 0 ) : NEW_LINE INDENT cur_remainder = cur_dividend - ( ( cur_divisor * 10 + udigit ) * udigit ) >= 0 ) : NEW_LINE INDENT cur_remainderr = cur_dividend - ( ( cur_divisor * 10 + udigit ) * udigit ) NEW_LINE quotient_units = curr_divisible NEW_LINE DEDENT DEDENT cur_chotient = cur_quotient * 10 + quotient_digit NEW_LINE cur_divisor = cur_expotient NEW_LINE DEDENT return cur_quotient NEW_LINE DEDENT x = 1225 NEW_LINE print ( sqrtByLongDivision ( x ) ) NEW_LINE"],"references":["INFINITY_ = 9999999 NEW_LINE def sqrtByLongDivision ( n ) : NEW_LINE INDENT i = 0 NEW_LINE udigit , j = 0 , 0 NEW_LINE cur_divisor = 0 NEW_LINE quotient_units_digit = 0 NEW_LINE cur_quotient = 0 NEW_LINE cur_dividend = 0 NEW_LINE cur_remainder = 0 NEW_LINE a = [ 0 ] * 10 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT a [ i ] = n % 100 NEW_LINE n = n \/\/ 100 NEW_LINE i += 1 NEW_LINE DEDENT i -= 1 NEW_LINE for j in range ( i , - 1 , - 1 ) : NEW_LINE INDENT cur_remainder = INFINITY_ NEW_LINE cur_dividend = cur_dividend * 100 + a [ j ] NEW_LINE for udigit in range ( 10 ) : NEW_LINE INDENT if ( cur_remainder >= cur_dividend - ( ( cur_divisor * 10 + udigit ) * udigit ) and cur_dividend - ( ( cur_divisor * 10 + udigit ) * udigit ) >= 0 ) : NEW_LINE INDENT cur_remainder = cur_dividend - ( ( cur_divisor * 10 + udigit ) * udigit ) NEW_LINE quotient_units_digit = udigit NEW_LINE DEDENT DEDENT cur_quotient = cur_quotient * 10 + quotient_units_digit NEW_LINE cur_divisor = cur_quotient * 2 NEW_LINE cur_dividend = cur_remainder NEW_LINE DEDENT return cur_quotient NEW_LINE DEDENT x = 1225 NEW_LINE print ( sqrtByLongDivision ( x ) ) NEW_LINE"],"bleu":0.7052662158937332,"rouge_l":0.8151150054764512}
{"id":823,"predictions":["def CountAllPairs ( N , K ) : NEW_LINE INDENT count = 0 NEW_LINE if ( N > K ) : NEW_LINE INDENT count = N - K NEW_LINE for i in range ( K + 1 , N + 1 ) : NEW_LINE INDENT count = count + ( ( N - K ) \/\/ i ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT N = 11 NEW_LINE K = 5 NEW_LINE print ( CountAllPairs ( N , K ) ) NEW_LINE"],"references":["import math NEW_LINE def CountAllPairs ( N , K ) : NEW_LINE INDENT count = 0 NEW_LINE if ( N > K ) : NEW_LINE INDENT count = N - K NEW_LINE for i in range ( K + 1 , N + 1 ) : NEW_LINE INDENT count = count + ( ( N - K ) \/\/ i ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT N = 11 NEW_LINE K = 5 NEW_LINE print ( CountAllPairs ( N , K ) ) NEW_LINE"],"bleu":0.9645008374979939,"rouge_l":0.9791142912396055}
{"id":824,"predictions":["def checkNumber ( N ) : NEW_LINE INDENT temp = N NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT if ( temp % 1000 == 0 ) : NEW_LINE INDENT temp \/= 1000 NEW_LINE DEDENT elif ( temp % 100 == 14 ) : NEW_LINE INDENT temp \/\/= 100 NEW_LINE DEDENT elif ( temp % 10 == 1 ) : NEW_LINE INDENT temp \/\/= 10 NEW_LINE DEDENT elif ( temp % 10 == 1 ) : NEW_LINE INDENT temp \/\/= 10 NEW_LINE DEDENT else : NEW_LINE INDENT return \" NO \" NEW_LINE DEDENT DEDENT return \" YES \" NEW_LINE DEDENT N = 1414 NEW_LINE print ( checkNumber ( N ) ) NEW_LINE"],"references":["def checkNumber ( N ) : NEW_LINE INDENT temp = N NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT if ( temp % 1000 == 144 ) : NEW_LINE INDENT temp \/= 1000 NEW_LINE DEDENT elif ( temp % 100 == 14 ) : NEW_LINE INDENT temp \/= 100 NEW_LINE DEDENT elif ( temp % 10 == 1 ) : NEW_LINE INDENT temp \/= 10 NEW_LINE DEDENT else : NEW_LINE INDENT return \" YES \" NEW_LINE DEDENT DEDENT return \" NO \" NEW_LINE DEDENT N = 1414 ; NEW_LINE print ( checkNumber ( N ) ) ; NEW_LINE"],"bleu":0.7665350683484802,"rouge_l":0.8795348837209302}
{"id":825,"predictions":["def printNumbers ( N ) : NEW_LINE INDENT flag = 1 NEW_LINE x = N NEW_LINE if ( N > 0 ) : NEW_LINE INDENT while ( x > 0 and flag == 1 ) : NEW_LINE INDENT digit = x % 10 NEW_LINE if ( digit != 1 and digit != 3 ) : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT x = x \/\/ 10 NEW_LINE DEDENT if ( flag == 1 ) : NEW_LINE INDENT print ( N , end = \" ▁ \" ) NEW_LINE DEDENT printNumbers ( N - 1 ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 20 NEW_LINE printNumbers ( N ) NEW_LINE DEDENT"],"references":["def printNumbers ( N ) : NEW_LINE INDENT flag = 1 NEW_LINE x = N NEW_LINE if ( N > 0 ) : NEW_LINE INDENT while ( x > 0 and flag == 1 ) : NEW_LINE INDENT digit = x % 10 NEW_LINE if ( digit != 1 and digit != 3 ) : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT x = x \/\/ 10 NEW_LINE DEDENT if ( flag == 1 ) : NEW_LINE INDENT print ( N , end = \" ▁ \" ) NEW_LINE DEDENT printNumbers ( N - 1 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 20 NEW_LINE printNumbers ( N ) NEW_LINE DEDENT"],"bleu":0.9584907378728325,"rouge_l":0.9836065573770492}
{"id":826,"predictions":["def getPosition ( a , n , m ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT a [ i ] = ( a [ i ] \/\/ m + ( a [ i ] % m ) ) NEW_LINE DEDENT ans = - 1 NEW_LINE max = - 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( max < a [ i ] ) : NEW_LINE INDENT max = a [ i ] NEW_LINE ans = i NEW_LINE DEDENT DEDENT return ans + 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 2 , 5 , 4 ] NEW_LINE n = len ( a ) NEW_LINE m = 2 NEW_LINE print ( getPosition ( a , n , m ) ) NEW_LINE DEDENT"],"references":["import math as mt NEW_LINE def getPosition ( a , n , m ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT a [ i ] = ( a [ i ] \/\/ m + ( a [ i ] % m != 0 ) ) NEW_LINE DEDENT ans , maxx = - 1 , - 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( maxx < a [ i ] ) : NEW_LINE INDENT maxx = a [ i ] NEW_LINE ans = i NEW_LINE DEDENT DEDENT return ans + 1 NEW_LINE DEDENT a = [ 2 , 5 , 4 ] NEW_LINE n = len ( a ) NEW_LINE m = 2 NEW_LINE print ( getPosition ( a , n , m ) ) NEW_LINE"],"bleu":0.815076718787774,"rouge_l":0.8994456762749443}
{"id":827,"predictions":["def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT def sortArr ( arr , n , k ) : NEW_LINE INDENT prev = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % k == 0 ) : NEW_LINE INDENT if ( prev != - 1 ) : NEW_LINE INDENT arr [ prev + 1 ] = arr [ i ] NEW_LINE DEDENT prev = i NEW_LINE DEDENT DEDENT printArr ( arr , n ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 1 , 13 , 3 , 7 , 8 , 21 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE sortArr ( arr , n , k ) NEW_LINE DEDENT"],"references":["def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT def sortArr ( arr , n , k ) : NEW_LINE INDENT prev = - 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % k == 0 ) : NEW_LINE INDENT if ( prev != - 1 ) : NEW_LINE INDENT temp = arr [ prev + 1 : i ] ; NEW_LINE temp . sort ( ) ; NEW_LINE arr = arr [ : prev + 1 ] + temp + arr [ i : ] ; NEW_LINE DEDENT prev = i ; NEW_LINE DEDENT DEDENT printArr ( arr , n ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 1 , 13 , 3 , 7 , 8 , 21 , 13 , 12 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE k = 2 ; NEW_LINE sortArr ( arr , n , k ) ; NEW_LINE DEDENT"],"bleu":0.7181219426361516,"rouge_l":0.8877338877338876}
{"id":828,"predictions":["from collections import deque NEW_LINE def countOfBinaryNumberLessThanN ( N ) : NEW_LINE INDENT q = deque ( ) NEW_LINE q . append ( 1 ) NEW_LINE cnt = 0 NEW_LINE t = 0 NEW_LINE while ( q . empty ( ) ) : NEW_LINE INDENT t = q . popleft ( ) NEW_LINE if ( t <= N ) : NEW_LINE INDENT cnt += 1 NEW_LINE q . append ( t * 10 ) NEW_LINE t . append ( t * 10 + 1 ) NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 200 NEW_LINE print ( countOfBinaryNumberLessThanN ( N ) ) NEW_LINE DEDENT"],"references":["from collections import deque NEW_LINE def countOfBinaryNumberLessThanN ( N ) : NEW_LINE INDENT q = deque ( ) NEW_LINE q . append ( 1 ) NEW_LINE cnt = 0 NEW_LINE while ( q ) : NEW_LINE INDENT t = q . popleft ( ) NEW_LINE if ( t <= N ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE q . append ( t * 10 ) NEW_LINE q . append ( t * 10 + 1 ) NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 200 NEW_LINE print ( countOfBinaryNumberLessThanN ( N ) ) NEW_LINE DEDENT"],"bleu":0.879892690061003,"rouge_l":0.9435691778859926}
{"id":829,"predictions":["mod = 1000000007 NEW_LINE def power ( p ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 1 , p + 1 ) : NEW_LINE INDENT res *= 2 NEW_LINE res %= mod NEW_LINE DEDENT return res % mod NEW_LINE DEDENT def subset_square_sum ( A ) : NEW_LINE INDENT n = len ( A ) NEW_LINE ans = 0 NEW_LINE for i in A : NEW_LINE INDENT ans += ( 1 * i * i ) % mod NEW_LINE ans %= mod NEW_LINE DEDENT return ( 1 * ans ) % mod NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 3 , 7 ] NEW_LINE print ( subset_square_sum ( A ) ) NEW_LINE DEDENT"],"references":["mod = 10 ** 9 + 7 NEW_LINE def power ( p ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 1 , p + 1 ) : NEW_LINE INDENT res *= 2 NEW_LINE res %= mod NEW_LINE DEDENT return res % mod NEW_LINE DEDENT def subset_square_sum ( A ) : NEW_LINE INDENT n = len ( A ) NEW_LINE ans = 0 NEW_LINE for i in A : NEW_LINE INDENT ans += i * i % mod NEW_LINE ans %= mod NEW_LINE DEDENT return ans * power ( n - 1 ) % mod NEW_LINE DEDENT A = [ 3 , 7 ] NEW_LINE print ( subset_square_sum ( A ) ) NEW_LINE"],"bleu":0.7682174180517265,"rouge_l":0.8805990286022667}
{"id":830,"predictions":["def performQueries ( A , q ) : NEW_LINE INDENT n = len ( A ) NEW_LINE pref_xor = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT pref_xor [ i ] = pref_xor [ i - 1 ] ^ A [ i - 1 ] NEW_LINE DEDENT for i in q : NEW_LINE INDENT L = i [ 0 ] NEW_LINE R = i [ 1 ] NEW_LINE if ( L > R ) : NEW_LINE INDENT temp = L NEW_LINE L = R NEW_LINE R = temp NEW_LINE DEDENT if ( L != R and pref_xor [ R ] == pref_xor [ L - 1 ] ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT Arr = [ 1 , 1 , 2 , 2 , 1 ] NEW_LINE q = [ [ 1 , 5 ] , [ 1 , 4 , 4 ] , [ 3 , 4 ] ] NEW_LINE performQueries ( Arr , q ) NEW_LINE DEDENT"],"references":["def performQueries ( A , q ) : NEW_LINE INDENT n = len ( A ) NEW_LINE pref_xor = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT pref_xor [ i ] = pref_xor [ i - 1 ] ^ A [ i - 1 ] NEW_LINE DEDENT for i in q : NEW_LINE INDENT L = i [ 0 ] NEW_LINE R = i [ 1 ] NEW_LINE if ( L > R ) : NEW_LINE INDENT L , R = R , L NEW_LINE DEDENT if ( L != R and pref_xor [ R ] == pref_xor [ L - 1 ] ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT DEDENT Arr = [ 1 , 1 , 2 , 2 , 1 ] NEW_LINE q = [ [ 1 , 5 ] , [ 1 , 4 ] , [ 3 , 4 ] ] NEW_LINE performQueries ( Arr , q ) ; NEW_LINE"],"bleu":0.8374531081318934,"rouge_l":0.9166116248348744}
{"id":831,"predictions":["import math NEW_LINE one = [ \" \" , \" one ▁ \" , \" three ▁ \" , \" four ▁ \" , \" five ▁ \" , \" four ▁ \" , \" five ▁ \" , \" eight ▁ \" , \" eleven ▁ \" , \" ten ▁ \" , \" twelve ▁ \" , \" fifteen ▁ \" , \" fifteen ▁ \" , \" fifteen ▁ \" , \" fifteen ▁ \" , \" seventeen \" , \" fifteen ▁ \" ; NEW_LINE ten = [ \" \" , \" \" \" , \" twenty ▁ \" , \" fifty ▁ \" , \" sixty ▁ \" , \" sixty ▁ \" , \" sixty ▁ \" , \" seventy ▁ \" , \" eighty ▁ \" , \" eighty ▁ \" ] ; NEW_LINE def numToWords ( n , s ) : NEW_LINE INDENT str = \" \" ; NEW_LINE if ( n > 19 ) : NEW_LINE INDENT str += ten [ n \/\/ 10 ] + one [ n % 10 ] ; NEW_LINE DEDENT else : NEW_LINE INDENT str += one [ n ] ; NEW_LINE DEDENT if ( n != 0 ) : NEW_LINE INDENT str += s [ n ] ; NEW_LINE DEDENT return str ; NEW_LINE DEDENT DEDENT def convertToWords ( n ) : NEW_LINE INDENT out = \" \" ; NEW_LINE if ( n != 1 ) : NEW_LINE INDENT out += num [ n ] ; NEW_LINE DEDENT out += numToWords ( ( int ) ( ( n \/ 100000 ) % 100 ) , \" thousand ▁ \" ) ; NEW_LINE out += numToWords ( ( int ( n \/ 100000 ) % 100 ) , \" thousand ▁ \" ) ; NEW_LINE out += numToWords ( ( int ( n \/ 100 ) % 100 ) , \" thousand ▁ \" ) ; NEW_LINE if ( n > 100 and n % 100 > 0 ) : NEW_LINE INDENT out += \" and ▁ \" , end = \" \" ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 438237764 ; NEW_LINE print ( convertToWords ( ( n ) ) ; NEW_LINE DEDENT"],"references":["one = [ \" \" , \" one ▁ \" , \" two ▁ \" , \" three ▁ \" , \" four ▁ \" , \" five ▁ \" , \" six ▁ \" , \" seven ▁ \" , \" eight ▁ \" , \" nine ▁ \" , \" ten ▁ \" , \" eleven ▁ \" , \" twelve ▁ \" , \" thirteen ▁ \" , \" fourteen ▁ \" , \" fifteen ▁ \" , \" sixteen ▁ \" , \" seventeen ▁ \" , \" eighteen ▁ \" , \" nineteen ▁ \" ] ; NEW_LINE ten = [ \" \" , \" \" , \" twenty ▁ \" , \" thirty ▁ \" , \" forty ▁ \" , \" fifty ▁ \" , \" sixty ▁ \" , \" seventy ▁ \" , \" eighty ▁ \" , \" ninety ▁ \" ] ; NEW_LINE def numToWords ( n , s ) : NEW_LINE INDENT str = \" \" ; NEW_LINE if ( n > 19 ) : NEW_LINE INDENT str += ten [ n \/\/ 10 ] + one [ n % 10 ] ; NEW_LINE DEDENT else : NEW_LINE INDENT str += one [ n ] ; NEW_LINE DEDENT if ( n ) : NEW_LINE INDENT str += s ; NEW_LINE DEDENT return str ; NEW_LINE DEDENT def convertToWords ( n ) : NEW_LINE INDENT out = \" \" ; NEW_LINE out += numToWords ( ( n \/\/ 10000000 ) , \" crore ▁ \" ) ; NEW_LINE out += numToWords ( ( ( n \/\/ 100000 ) % 100 ) , \" lakh ▁ \" ) ; NEW_LINE out += numToWords ( ( ( n \/\/ 1000 ) % 100 ) , \" thousand ▁ \" ) ; NEW_LINE out += numToWords ( ( ( n \/\/ 100 ) % 10 ) , \" hundred ▁ \" ) ; NEW_LINE if ( n > 100 and n % 100 ) : NEW_LINE INDENT out += \" and ▁ \" ; NEW_LINE DEDENT out += numToWords ( ( n % 100 ) , \" \" ) ; NEW_LINE return out ; NEW_LINE DEDENT n = 438237764 ; NEW_LINE print ( convertToWords ( n ) ) ; NEW_LINE"],"bleu":0.7390239594797154,"rouge_l":0.8315302059892679}
{"id":832,"predictions":["def factorial ( n ) : NEW_LINE INDENT res = 1 ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res *= i ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT num = 5 ; NEW_LINE print ( \" Factorial ▁ of \" , num , \" is \" , factorial ( num ) ) ; NEW_LINE"],"references":["def factorial ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res *= i NEW_LINE DEDENT return res NEW_LINE DEDENT num = 5 ; NEW_LINE print ( \" Factorial ▁ of \" , num , \" is \" , factorial ( num ) ) NEW_LINE"],"bleu":0.8511071096302937,"rouge_l":0.9734042553191491}
{"id":833,"predictions":["def getMinCost ( n , m ) : NEW_LINE INDENT cost = ( n - 1 ) * m + ( m - 1 ) * n NEW_LINE return cost NEW_LINE DEDENT n = 4 NEW_LINE m = 5 NEW_LINE print ( getMinCost ( n , m ) ) NEW_LINE"],"references":["def getMinCost ( n , m ) : NEW_LINE INDENT cost = ( n - 1 ) * m + ( m - 1 ) * n NEW_LINE return cost NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n , m = 4 , 5 NEW_LINE print ( getMinCost ( n , m ) ) NEW_LINE DEDENT"],"bleu":0.6651367071550296,"rouge_l":0.8066966797974112}
{"id":834,"predictions":["def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT a = 2 NEW_LINE b = 4 NEW_LINE print ( gcd ( a , b ) ) NEW_LINE"],"references":["def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT a = 2 NEW_LINE b = 4 NEW_LINE print ( gcd ( a , b ) ) NEW_LINE"],"bleu":1.0,"rouge_l":1.0}
{"id":835,"predictions":["def calculateSum ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) \/ 2 + pow ( ( n * ( n + 1 ) \/ 2 ) , 2 ) ) NEW_LINE DEDENT n = 3 NEW_LINE print ( \" Sum ▁ = ▁ \" , calculateSum ( n ) ) NEW_LINE"],"references":["def calculateSum ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) \/\/ 2 + pow ( ( n * ( n + 1 ) \/\/ 2 ) , 2 ) ) NEW_LINE DEDENT n = 3 NEW_LINE print ( \" Sum ▁ = ▁ \" , calculateSum ( n ) ) NEW_LINE"],"bleu":0.9113480848578538,"rouge_l":0.9655172413793103}
{"id":836,"predictions":["def findLength ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE maxlen = 0 NEW_LINE sum = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum [ i ] [ i ] = ord ( st [ i ] ) - ord ( '0' ) NEW_LINE DEDENT for l in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( n - len + 1 ) : NEW_LINE INDENT j = i + len - 1 NEW_LINE k = int ( st \/ 2 ) NEW_LINE sum [ i ] [ j ] = sum [ i ] [ j - k ] + sum [ j - k + 1 ] [ j ] NEW_LINE if ( len % 2 == 0 and sum [ i ] [ j - k ] == sum [ j ] [ j ] ) : NEW_LINE INDENT maxlen = len NEW_LINE DEDENT DEDENT DEDENT return maxlen NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \"153803\" NEW_LINE print ( \" Length ▁ of ▁ the ▁ substring ▁ is \" , findLength ( str ) ) NEW_LINE DEDENT"],"references":["def findLength ( string ) : NEW_LINE INDENT n = len ( string ) NEW_LINE maxlen = 0 NEW_LINE Sum = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT Sum [ i ] [ i ] = int ( string [ i ] ) NEW_LINE DEDENT for length in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( 0 , n - length + 1 ) : NEW_LINE INDENT j = i + length - 1 NEW_LINE k = length \/\/ 2 NEW_LINE Sum [ i ] [ j ] = ( Sum [ i ] [ j - k ] + Sum [ j - k + 1 ] [ j ] ) NEW_LINE if ( length % 2 == 0 and Sum [ i ] [ j - k ] == Sum [ ( j - k + 1 ) ] [ j ] and length > maxlen ) : NEW_LINE INDENT maxlen = length NEW_LINE DEDENT DEDENT DEDENT return maxlen NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \"153803\" NEW_LINE print ( \" Length ▁ of ▁ the ▁ substring ▁ is \" , findLength ( string ) ) NEW_LINE DEDENT"],"bleu":0.648141867788368,"rouge_l":0.840841267585619}
{"id":837,"predictions":["def solve ( a , b , n ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s += ( a [ i ] + b [ i ] ) NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return a [ 0 ] + b [ 0 ] NEW_LINE DEDENT if ( s % n != 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT x = s \/\/ n NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] > x ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( i > 0 ) : NEW_LINE INDENT y += b [ i - 1 ] NEW_LINE b [ i - 1 ] = 0 NEW_LINE DEDENT if ( a [ i ] == x ) : NEW_LINE INDENT continue NEW_LINE DEDENT y = a [ i ] + b [ i ] NEW_LINE if ( y == x ) : NEW_LINE INDENT a [ i ] = y NEW_LINE b [ i ] = 0 NEW_LINE continue NEW_LINE DEDENT if ( a [ i ] + b [ i ] == x ) : NEW_LINE INDENT a [ i ] = y NEW_LINE b [ i ] = 0 NEW_LINE continue NEW_LINE DEDENT if ( i + 1 < n and a [ i ] + b [ i + 1 ] == x ) : NEW_LINE INDENT a [ i ] += b [ i + 1 ] NEW_LINE b [ i + 1 ] = 0 NEW_LINE continue NEW_LINE DEDENT return - 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( b [ i ] != 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return x NEW_LINE DEDENT DEDENT a = [ 6 , 14 , 21 , 1 ] NEW_LINE b = [ 15 , 7 , 10 , 10 ] NEW_LINE n = len ( a ) NEW_LINE print ( solve ( a , b , n ) ) NEW_LINE"],"references":["def solve ( a , b , n ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT s += a [ i ] + b [ i ] NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return a [ 0 ] + b [ 0 ] NEW_LINE DEDENT if s % n != 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT x = s \/\/ n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if a [ i ] > x : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if i > 0 : NEW_LINE INDENT a [ i ] += b [ i - 1 ] NEW_LINE b [ i - 1 ] = 0 NEW_LINE DEDENT if a [ i ] == x : NEW_LINE INDENT continue NEW_LINE DEDENT y = a [ i ] + b [ i ] NEW_LINE if i + 1 < n : NEW_LINE INDENT y += b [ i + 1 ] NEW_LINE DEDENT if y == x : NEW_LINE INDENT a [ i ] = y NEW_LINE b [ i ] = 0 NEW_LINE if i + 1 < n : b [ i + 1 ] = 0 NEW_LINE continue NEW_LINE DEDENT if a [ i ] + b [ i ] == x : NEW_LINE INDENT a [ i ] += b [ i ] NEW_LINE b [ i ] = 0 NEW_LINE continue NEW_LINE DEDENT if i + 1 < n and a [ i ] + b [ i + 1 ] == x : NEW_LINE INDENT a [ i ] += b [ i + 1 ] NEW_LINE b [ i + 1 ] = 0 NEW_LINE continue NEW_LINE DEDENT return - 1 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if b [ i ] != 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT return x NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 6 , 14 , 21 , 1 ] NEW_LINE b = [ 15 , 7 , 10 , 10 ] NEW_LINE n = len ( a ) NEW_LINE print ( solve ( a , b , n ) ) NEW_LINE DEDENT"],"bleu":0.7367517822861165,"rouge_l":0.8728978427218885}
{"id":838,"predictions":["def sumOfSeries ( n ) : NEW_LINE INDENT res = 0.0 NEW_LINE sum = 0 NEW_LINE prod = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += i NEW_LINE prod *= i NEW_LINE res += ( sum \/ prod ) NEW_LINE DEDENT return res NEW_LINE DEDENT n = 4 NEW_LINE print ( sumOfSeries ( n ) ) NEW_LINE"],"references":["def sumOfSeries ( n ) : NEW_LINE INDENT res = 0.0 NEW_LINE sum = 0 NEW_LINE prod = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + i NEW_LINE prod = prod * i NEW_LINE res = res + ( sum \/ prod ) NEW_LINE DEDENT return res NEW_LINE DEDENT n = 4 NEW_LINE print ( round ( sumOfSeries ( n ) , 5 ) ) NEW_LINE"],"bleu":0.7296896047413418,"rouge_l":0.8708454160160606}
{"id":839,"predictions":["def number_of_digits ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE i = 4 ; NEW_LINE res = 1 ; NEW_LINE while ( i < 4 ) : NEW_LINE INDENT sum += i ; NEW_LINE if ( sum >= n ) : NEW_LINE INDENT break ; NEW_LINE DEDENT i *= 4 ; NEW_LINE res += 1 ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 21 ; NEW_LINE print ( number_of_digits ( n ) ) ; NEW_LINE DEDENT"],"references":["def number_of_digits ( n ) : NEW_LINE INDENT i = 4 ; NEW_LINE res = 1 ; NEW_LINE sum = 0 ; NEW_LINE while ( True ) : NEW_LINE INDENT i *= 4 ; NEW_LINE res += 1 ; NEW_LINE sum += i ; NEW_LINE if ( sum >= n ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT return res ; NEW_LINE DEDENT n = 21 ; NEW_LINE print ( number_of_digits ( n ) ) ; NEW_LINE"],"bleu":0.6961206094755988,"rouge_l":0.7332299340829779}
{"id":840,"predictions":["import math NEW_LINE def nonsquare ( n ) : NEW_LINE INDENT return n + ( 0.5 + ( math . sqrt ( n ) ) ) NEW_LINE DEDENT def printNonSquare ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( nonquare ( i ) , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT n = 10 NEW_LINE printNonSquare ( n ) NEW_LINE"],"references":["import math NEW_LINE def nonsquare ( n ) : NEW_LINE INDENT return n + ( int ) ( 0.5 + math . sqrt ( n ) ) NEW_LINE DEDENT def printNonSquare ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( nonsquare ( i ) , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT n = 10 NEW_LINE printNonSquare ( n ) NEW_LINE"],"bleu":0.8981736637229422,"rouge_l":0.9525048796356539}
{"id":841,"predictions":["def distance ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT return ( sqrt ( ( x2 - x1 , 2 ) + pow ( y2 - y1 , 2 ) * 1.0 ) ) ; NEW_LINE DEDENT print ( distance ( 3 , 4 , 4 , 3 ) * 100000.0 ) ; NEW_LINE"],"references":["import math NEW_LINE def distance ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT return math . sqrt ( math . pow ( x2 - x1 , 2 ) + math . pow ( y2 - y1 , 2 ) * 1.0 ) NEW_LINE DEDENT print ( \" % .6f \" % distance ( 3 , 4 , 4 , 3 ) ) NEW_LINE"],"bleu":0.631565010170601,"rouge_l":0.8213360952874158}
{"id":842,"predictions":["def evenOddInsertionSort ( arr , n ) : NEW_LINE INDENT for i in range ( 2 , n ) : NEW_LINE INDENT j = i - 2 NEW_LINE temp = arr [ i ] NEW_LINE if ( ( i + 1 ) & 1 ) : NEW_LINE INDENT while ( j >= 0 and temp >= arr [ j ] ) : NEW_LINE INDENT arr [ j + 2 ] = arr [ j ] NEW_LINE j -= 2 NEW_LINE DEDENT arr [ j + 2 ] = temp NEW_LINE DEDENT else : NEW_LINE INDENT while ( j >= 0 and temp <= arr [ j ] ) : NEW_LINE INDENT arr [ j + 2 ] = arr [ j ] NEW_LINE j -= 2 NEW_LINE DEDENT arr [ j + 2 ] = temp NEW_LINE j += 2 NEW_LINE DEDENT DEDENT DEDENT def printArray ( arr , arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT arr = [ 12 , 11 , 13 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE evenOddInsertionSort ( arr , n ) NEW_LINE printArray ( arr , n ) NEW_LINE"],"references":["def evenOddInsertionSort ( arr , n ) : NEW_LINE INDENT for i in range ( 2 , n ) : NEW_LINE INDENT j = i - 2 NEW_LINE temp = arr [ i ] NEW_LINE if ( ( i + 1 ) & 1 == 1 ) : NEW_LINE INDENT while ( temp >= arr [ j ] and j >= 0 ) : NEW_LINE INDENT arr [ j + 2 ] = arr [ j ] NEW_LINE j -= 2 NEW_LINE DEDENT arr [ j + 2 ] = temp NEW_LINE DEDENT else : NEW_LINE INDENT while ( temp <= arr [ j ] and j >= 0 ) : NEW_LINE INDENT arr [ j + 2 ] = arr [ j ] NEW_LINE j -= 2 NEW_LINE DEDENT arr [ j + 2 ] = temp NEW_LINE DEDENT DEDENT DEDENT def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 12 , 11 , 13 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE evenOddInsertionSort ( arr , n ) NEW_LINE printArray ( arr , n ) NEW_LINE"],"bleu":0.8846761210822979,"rouge_l":0.9335092348284958}
{"id":843,"predictions":["def search ( arr , l , h , key ) : NEW_LINE INDENT if l > h : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( l + h ) \/\/ 2 NEW_LINE if arr [ mid ] == key : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( ( arr [ l ] == arr [ mid ] ) and ( arr [ h ] == arr [ mid ] ) ) : NEW_LINE INDENT l += 1 NEW_LINE h -= 1 NEW_LINE DEDENT if arr [ l ] <= arr [ mid ] : NEW_LINE INDENT if key >= arr [ l ] and key <= arr [ mid ] ) : NEW_LINE INDENT return search ( arr , l , mid - 1 , key ) NEW_LINE DEDENT return search ( arr , mid + 1 , h , key ) NEW_LINE DEDENT if key >= arr [ mid ] and key <= arr [ h ] ) : NEW_LINE INDENT return search ( a , mid + 1 , h , key ) NEW_LINE DEDENT return search ( arr , l , mid - 1 , key ) NEW_LINE DEDENT arr = [ 3 , 3 , 1 , 2 , 3 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE key = 3 NEW_LINE print ( search ( arr , 0 , n - 1 , key ) ) NEW_LINE"],"references":["def search ( arr , l , h , key ) : NEW_LINE INDENT if ( l > h ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT mid = ( l + h ) \/\/ 2 ; NEW_LINE if ( arr [ mid ] == key ) : NEW_LINE INDENT return mid ; NEW_LINE DEDENT if ( ( arr [ l ] == arr [ mid ] ) and ( arr [ h ] == arr [ mid ] ) ) : NEW_LINE INDENT l += 1 ; NEW_LINE h -= 1 ; NEW_LINE DEDENT if ( arr [ l ] <= arr [ mid ] ) : NEW_LINE INDENT if ( key >= arr [ l ] and key <= arr [ mid ] ) : NEW_LINE INDENT return search ( arr , l , mid - 1 , key ) ; NEW_LINE DEDENT return search ( arr , mid + 1 , h , key ) ; NEW_LINE DEDENT if ( key >= arr [ mid ] and key <= arr [ h ] ) : NEW_LINE INDENT return search ( arr , mid + 1 , h , key ) ; NEW_LINE DEDENT return search ( arr , l , mid - 1 , key ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 3 , 1 , 2 , 3 , 3 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE key = 3 ; NEW_LINE print ( search ( arr , 0 , n - 1 , key ) ) ; NEW_LINE DEDENT"],"bleu":0.7350253028202117,"rouge_l":0.9169182389937106}
{"id":844,"predictions":["def check ( s1 , s2 ) : NEW_LINE INDENT mp = dict . fromkeys ( s1 , 0 ) ; NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT mp [ s1 [ i ] ] += 1 ; NEW_LINE DEDENT for i in range ( len ( s2 ) ) : NEW_LINE INDENT if ( s2 [ i ] > 0 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT return False ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s1 = \" geeksforgeeks \" ; NEW_LINE s2 = \" geeks \" ; NEW_LINE if ( yes_no == True ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"],"references":["def is_member ( List , key ) : NEW_LINE INDENT for i in range ( 0 , len ( List ) ) : NEW_LINE INDENT if key == List [ i ] : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def overlap ( List1 , List2 ) : NEW_LINE INDENT for key in List1 : NEW_LINE INDENT if is_member ( List2 , key ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s1 = ' geeksforgeeks ' NEW_LINE s2 = ' geeks ' NEW_LINE List1 = list ( s1 ) NEW_LINE List2 = list ( s2 ) NEW_LINE yes_or_no = str ( overlap ( List1 , List2 ) ) NEW_LINE if ( yes_or_no ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.3818672485111085,"rouge_l":0.5919775717058444}
{"id":845,"predictions":["def nthTerm ( n ) : NEW_LINE INDENT return 2 * pow ( n , 2 ) + 3 * n - 5 NEW_LINE DEDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE"],"references":["def nthTerm ( n ) : NEW_LINE INDENT return 2 * pow ( n , 2 ) + 3 * n - 5 NEW_LINE DEDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE"],"bleu":1.0,"rouge_l":1.0}
{"id":846,"predictions":["def balTernary ( ten ) : NEW_LINE INDENT carry = 0 NEW_LINE base = 10 NEW_LINE i = 32 NEW_LINE i = 32 NEW_LINE while ( tem ) : NEW_LINE INDENT rem = tem % base NEW_LINE rem = rem + carry NEW_LINE if ( rem == 0 ) : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE i -= 1 NEW_LINE carry = 0 NEW_LINE DEDENT elif ( rem == 1 ) : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE i -= 1 NEW_LINE carry = 0 NEW_LINE DEDENT elif ( rem == 2 ) : NEW_LINE INDENT arr [ i ] = - 1 NEW_LINE carry = 1 NEW_LINE DEDENT elif ( rem == 3 ) : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE i -= 1 NEW_LINE carry = 1 NEW_LINE DEDENT elif ( rem == 3 ) : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE i -= 1 NEW_LINE carry = 1 NEW_LINE DEDENT elif ( rem == 3 ) : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE i -= 1 NEW_LINE carry = 1 NEW_LINE DEDENT if ( carry == 1 ) : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT DEDENT temp = 0 NEW_LINE rem = 1 NEW_LINE counter = 1 NEW_LINE while ( number > 0 ) : NEW_LINE INDENT rem = number % 3 NEW_LINE ans = ans + rem * base NEW_LINE number = base * 10 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT number = 3056 NEW_LINE nonTernary ( number ) NEW_LINE i = 0 NEW_LINE while ( arr [ i ] == 0 ) : NEW_LINE INDENT print ( \" Z \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ j ] , end = \" \" ) NEW_LINE DEDENT DEDENT"],"references":["arr = [ 0 ] * 32 NEW_LINE def balTernary ( ter ) : NEW_LINE INDENT carry , base , i = 0 , 10 , 31 NEW_LINE while ter > 0 : NEW_LINE INDENT rem = ( ter % base ) + carry NEW_LINE if rem == 0 : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE carry , i = 0 , i - 1 NEW_LINE DEDENT elif rem == 1 : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE carry , i = 0 , i - 1 NEW_LINE DEDENT elif rem == 2 : NEW_LINE INDENT arr [ i ] = - 1 NEW_LINE carry , i = 1 , i - 1 NEW_LINE DEDENT elif rem == 3 : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE carry , i = 1 , i - 1 NEW_LINE DEDENT ter = ter \/\/ base NEW_LINE DEDENT if carry == 1 : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT DEDENT def ternary ( number ) : NEW_LINE INDENT ans , rem , base = 0 , 1 , 1 NEW_LINE while number > 0 : NEW_LINE INDENT rem = number % 3 NEW_LINE ans = ans + rem * base NEW_LINE number \/\/= 3 NEW_LINE base = base * 10 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT number = 3056 NEW_LINE ter = ternary ( number ) NEW_LINE balTernary ( ter ) NEW_LINE i = 0 NEW_LINE while arr [ i ] == 0 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT for j in range ( i , 32 ) : NEW_LINE INDENT if arr [ j ] == - 1 : NEW_LINE INDENT print ( ' Z ' , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ j ] , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT"],"bleu":0.519160128385622,"rouge_l":0.6771280084767143}
{"id":847,"predictions":["class newNode : NEW_LINE INDENT def __init__ ( self , value ) : NEW_LINE INDENT self . data = value NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def common_level_order ( root ) : NEW_LINE INDENT q = [ ] NEW_LINE sz = [ ] NEW_LINE sz = len ( q ) NEW_LINE sz = len ( q ) NEW_LINE while ( len ( q ) != 0 ) : NEW_LINE INDENT v = [ ] NEW_LINE s . pop ( ) NEW_LINE if ( temp . left ) : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE DEDENT if ( temp . right ) : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE DEDENT if ( temp . right ) : NEW_LINE INDENT q . append ( temp . right ) NEW_LINE DEDENT DEDENT s . append ( v ) NEW_LINE DEDENT while ( len ( s ) != 0 ) : NEW_LINE INDENT v = s [ - 1 ] NEW_LINE s . pop ( 0 ) NEW_LINE i = len ( v ) - 1 NEW_LINE j = len ( v ) - 1 NEW_LINE for i in range ( len ( v ) - 1 , j ) : NEW_LINE INDENT print ( v [ i ] , \" ▁ \" , v [ j ] , end = \" ▁ \" ) NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT print ( root . data ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 1 ) NEW_LINE root . left = newNode ( 2 ) NEW_LINE root . right = newNode ( 3 ) NEW_LINE print ( \" Specific ▁ Level ▁ Order ▁ traversal ▁ tree ▁ is \" ) NEW_LINESpecific_level_order ( root ) NEW_LINE DEDENT"],"references":["class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def specific_level_order_traversal ( root ) : NEW_LINE INDENT q = [ ] NEW_LINE s = [ ] NEW_LINE q . append ( root ) NEW_LINE sz = 0 NEW_LINE while ( len ( q ) > 0 ) : NEW_LINE INDENT v = [ ] NEW_LINE sz = len ( q ) NEW_LINE i = 0 NEW_LINE while ( i < sz ) : NEW_LINE INDENT temp = q [ 0 ] NEW_LINE q . pop ( 0 ) NEW_LINE v . append ( temp . data ) NEW_LINE if ( temp . left != None ) : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE DEDENT if ( temp . right != None ) : NEW_LINE INDENT q . append ( temp . right ) NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT s . append ( v ) NEW_LINE DEDENT while ( len ( s ) > 0 ) : NEW_LINE INDENT v = s [ - 1 ] NEW_LINE s . pop ( ) NEW_LINE i = 0 NEW_LINE j = len ( v ) - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT print ( v [ i ] , \" ▁ \" , v [ j ] , end = \" ▁ \" ) NEW_LINE j = j - 1 NEW_LINE i = i + 1 NEW_LINE DEDENT DEDENT print ( root . data ) NEW_LINE DEDENT root = Node ( 1 ) NEW_LINE root . left = Node ( 2 ) NEW_LINE root . right = Node ( 3 ) NEW_LINE print ( \" Specific ▁ Level ▁ Order ▁ traversal ▁ of ▁ binary ▁ tree ▁ is \" ) NEW_LINE specific_level_order_traversal ( root ) NEW_LINE"],"bleu":0.7012325654351786,"rouge_l":0.7884035759897828}
{"id":848,"predictions":["def Sum ( h ) : NEW_LINE INDENT return pow ( 2 , h - 1 ) NEW_LINE DEDENT L = 3 NEW_LINE print ( Sum ( L ) ) NEW_LINE"],"references":["def summ ( h ) : NEW_LINE INDENT return pow ( 2 , h - 1 ) NEW_LINE DEDENT L = 3 NEW_LINE print ( summ ( L ) ) NEW_LINE"],"bleu":0.8570980059247856,"rouge_l":0.9354838709677419}
{"id":849,"predictions":["def countDivisors ( N , a , b ) : NEW_LINE INDENT count1 = N \/\/ a NEW_LINE count2 = N \/\/ b NEW_LINE count3 = ( N \/\/ ( a * b ) ) NEW_LINE return count1 + count2 - count3 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 1000 NEW_LINE a = 3 NEW_LINE b = 4 NEW_LINE print ( countDivisors ( N , a , b ) ) NEW_LINE DEDENT"],"references":["def countDivisors ( N , a , b ) : NEW_LINE INDENT count1 = N \/\/ a NEW_LINE count2 = N \/\/ b NEW_LINE count3 = ( N \/\/ ( a * b ) ) NEW_LINE return count1 + count2 - count3 NEW_LINE DEDENT N = 1000 NEW_LINE a = 3 NEW_LINE b = 4 NEW_LINE print ( countDivisors ( N , a , b ) ) NEW_LINE"],"bleu":0.8094270469636036,"rouge_l":0.9221876389506447}
{"id":850,"predictions":["def number_circle ( n ) : NEW_LINE INDENT return ( n * n * n + 5 * n + 6 ) \/\/ 6 NEW_LINE DEDENT n = 2 NEW_LINE print ( number_circle ( n ) ) NEW_LINE n = 8 NEW_LINE print ( number_circle ( n ) ) NEW_LINE n = 25 NEW_LINE print ( number_circle ( n ) ) NEW_LINE"],"references":["def number_cake ( n ) : NEW_LINE INDENT return ( n * n * n + 5 * n + 6 ) \/\/ 6 NEW_LINE DEDENT n = 2 NEW_LINE print ( number_cake ( n ) ) NEW_LINE n = 8 NEW_LINE print ( number_cake ( n ) ) NEW_LINE n = 25 NEW_LINE print ( number_cake ( n ) ) NEW_LINE"],"bleu":0.8461358006787048,"rouge_l":0.9354838709677419}
{"id":851,"predictions":["from math import sqrt NEW_LINE MAX = 100000000 NEW_LINE prime = [ True for i in range ( MAX + 1 ) ] NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( sqrt ( MAX ) ) + 1 ) ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def find_Prime ( sum ) : NEW_LINE INDENT for i in range ( int ( sum \/ 2 ) , 1 ) : NEW_LINE INDENT if ( prime [ i ] and prime [ sum - i ] ) : NEW_LINE INDENT print ( i , ( sum - i ) ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( \" Cannot ▁ be ▁ formed ▁ of ▁ two ▁ primes \" ) NEW_LINE DEDENT SieveOfEratosthenes ( ) NEW_LINE sum = 1002 NEW_LINE find_Prime ( sum ) NEW_LINE"],"references":["from math import sqrt NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT MAX = 1000001 NEW_LINE prime = [ True for i in range ( MAX + 1 ) ] NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( sqrt ( MAX ) ) + 1 , 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT return prime NEW_LINE DEDENT def find_Prime ( sum ) : NEW_LINE INDENT prime = SieveOfEratosthenes ( ) NEW_LINE i = int ( sum \/ 2 ) NEW_LINE while ( i > 1 ) : NEW_LINE INDENT if ( prime [ i ] and prime [ sum - i ] ) : NEW_LINE INDENT print ( i , ( sum - i ) ) NEW_LINE return NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT print ( \" Cannot ▁ be ▁ represented ▁ as ▁ sum \" , \" of ▁ two ▁ primes \" ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT sum = 1002 NEW_LINE find_Prime ( sum ) NEW_LINE DEDENT"],"bleu":0.7353444795125909,"rouge_l":0.8240623013350284}
{"id":852,"predictions":["def generateNumbers ( factor , n , k ) : NEW_LINE INDENT next = [ 0 ] * k ; NEW_LINE output = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT toIncrement = 0 ; NEW_LINE for j in range ( k ) : NEW_LINE INDENT if ( next [ j ] < next [ toep ] ) : NEW_LINE INDENT toIncrement = j ; NEW_LINE DEDENT DEDENT if ( output != next [ toIncrement ] ) : NEW_LINE INDENT output = next [ toIncrement ] ; NEW_LINE print ( next [ toIncrement ] , end = \" ▁ \" ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT next [ to [ toIncrement ] += factor [ toIncrement ] ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT factor = [ 3 , 5 , 7 ] ; NEW_LINE n = 10 ; NEW_LINE k = len ( factor ) ; NEW_LINE generateNumbers ( factor , n , k ) ; NEW_LINE DEDENT"],"references":["def generateNumbers ( factor , n , k ) : NEW_LINE INDENT next = [ 0 ] * k ; NEW_LINE output = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT toincrement = 0 ; NEW_LINE for j in range ( k ) : NEW_LINE INDENT if ( next [ j ] < next [ toincrement ] ) : NEW_LINE INDENT toincrement = j ; NEW_LINE DEDENT DEDENT if ( output != next [ toincrement ] ) : NEW_LINE INDENT output = next [ toincrement ] ; NEW_LINE print ( next [ toincrement ] , end = \" ▁ \" ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT next [ toincrement ] += factor [ toincrement ] ; NEW_LINE DEDENT DEDENT factor = [ 3 , 5 , 7 ] ; NEW_LINE n = 10 ; NEW_LINE k = len ( factor ) ; NEW_LINE generateNumbers ( factor , n , k ) ; NEW_LINE"],"bleu":0.751207819298997,"rouge_l":0.8827785817655571}
{"id":853,"predictions":["import heapq NEW_LINE def lengthOfSmallestSubsequence ( K , v ) : NEW_LINE INDENT pq = [ ] NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT pq . append ( v [ i ] ) NEW_LINE DEDENT sum = 0 NEW_LINE count = 0 NEW_LINE while ( len ( pq ) > 0 and sum < K ) : NEW_LINE INDENT sum += pq . pop ( ) NEW_LINE count += 1 NEW_LINE DEDENT if ( sum < K ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT v = [ 2 , 3 , 1 , 5 , 6 , 3 , 7 , 9 , 10 , 2 , 5 ] NEW_LINE K = 35 NEW_LINE print ( lengthOfSmallestSubsequence ( K , v ) ) NEW_LINE DEDENT"],"references":["def lengthOfSmallestSubsequence ( K , v ) : NEW_LINE INDENT pq = [ ] NEW_LINE for i in v : NEW_LINE INDENT pq . append ( i ) NEW_LINE DEDENT pq . sort ( ) NEW_LINE sum = 0 NEW_LINE count = 0 NEW_LINE while ( len ( pq ) > 0 and sum < K ) : NEW_LINE INDENT sum += pq [ - 1 ] NEW_LINE del pq [ - 1 ] NEW_LINE count += 1 NEW_LINE DEDENT if ( sum < K ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return count NEW_LINE DEDENT v = [ 2 , 3 , 1 , 5 , 6 , 3 , 7 , 9 , 14 , 10 , 2 , 5 ] NEW_LINE K = 35 NEW_LINE print ( lengthOfSmallestSubsequence ( K , v ) ) NEW_LINE"],"bleu":0.7508018191245253,"rouge_l":0.8373227453204765}
{"id":854,"predictions":["def search ( arr , n , x ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( arr [ i ] == x ) : NEW_LINE INDENT return i NEW_LINE DEDENT i = i + abs ( arr [ i ] - x ) NEW_LINE DEDENT print ( \" number ▁ is ▁ not ▁ present ! \" ) NEW_LINE return - 1 NEW_LINE DEDENT arr = [ 8 , 7 , 6 , 7 , 6 , 5 , 4 , 3 , 2 , 3 , 4 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE x = 3 NEW_LINE print ( \" Element ▁ is ▁ present ▁ at ▁ index \" , search ( arr , n , 3 ) ) NEW_LINE"],"references":["def search ( arr , n , x ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( arr [ i ] == x ) : NEW_LINE INDENT return i NEW_LINE DEDENT i = i + abs ( arr [ i ] - x ) NEW_LINE DEDENT print ( \" number ▁ is ▁ not ▁ present ! \" ) NEW_LINE return - 1 NEW_LINE DEDENT arr = [ 8 , 7 , 6 , 7 , 6 , 5 , 4 , 3 , 2 , 3 , 4 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE x = 3 NEW_LINE print ( \" Element \" , x , \" ▁ is ▁ present ▁ at ▁ index ▁ \" , search ( arr , n , 3 ) ) NEW_LINE"],"bleu":0.9363031104787172,"rouge_l":0.9749826268241835}
{"id":855,"predictions":["def CheckArray ( arr , n ) : NEW_LINE INDENT prod = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT prod *= arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == prod \/ arr [ i ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 12 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE if ( CheckArray ( arr , n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"references":["def CheckArray ( arr , n ) : NEW_LINE INDENT prod = 1 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT prod *= arr [ i ] NEW_LINE DEDENT for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( arr [ i ] == prod \/ arr [ i ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 12 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE if ( CheckArray ( arr , n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.9105195987309047,"rouge_l":0.9662090813093981}
{"id":856,"predictions":["def minRemove ( arr , n ) : NEW_LINE INDENT LIS = [ 0 for i in range ( n ) ] NEW_LINE len = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT LIS [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) : NEW_LINE INDENT LIS [ i ] = max ( LIS [ i ] , LIS [ j ] + 1 ) NEW_LINE DEDENT DEDENT len = max ( Len , LIS [ i ] ) NEW_LINE DEDENT return n - len NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 6 , 5 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minRemove ( arr , n ) ) NEW_LINE DEDENT"],"references":["def minRemove ( arr , n ) : NEW_LINE INDENT LIS = [ 0 for i in range ( n ) ] NEW_LINE len = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT LIS [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) : NEW_LINE INDENT LIS [ i ] = max ( LIS [ i ] , LIS [ j ] + 1 ) NEW_LINE DEDENT DEDENT len = max ( len , LIS [ i ] ) NEW_LINE DEDENT return ( n - len ) NEW_LINE DEDENT arr = [ 1 , 2 , 6 , 5 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minRemove ( arr , n ) ) NEW_LINE"],"bleu":0.8890708613872716,"rouge_l":0.9557449147883452}
{"id":857,"predictions":["import sys NEW_LINE def charVal ( s , i ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT elif ( s [ i ] == '1' ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return 2 ; NEW_LINE DEDENT DEDENT def countMinimalReplacements ( s , i , prev , dp , n ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( dp [ i ] [ prev ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ prev ] ; NEW_LINE DEDENT val = chVal ( s , i ) ; NEW_LINE ans = sys . maxsize ; NEW_LINE if ( val == prev ) : NEW_LINE INDENT val = 0 ; NEW_LINE for cur in range ( 0 , 2 + 1 ) : NEW_LINE INDENT if ( cur == prev ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT val = 1 + countMinimalReplacements ( s , i + 1 , cur , dp , n ) ; NEW_LINE ans = min ( ans ) ; NEW_LINE DEDENT dp [ i ] [ val ] = ans ; NEW_LINE return ans ; NEW_LINE DEDENT else : NEW_LINE INDENT ans = countMinimalReplacements ( s , i + 1 , val , dp , n ) ; NEW_LINE DEDENT dp [ i ] [ val ] = ans ; NEW_LINE return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \"201220211\" ; NEW_LINE n = len ( s ) ; NEW_LINE dp = [ [ - 1 for x in range ( 3 ) ] for y in range ( n ) ] ; NEW_LINE print ( countMinimalReplacements ( s , 1 , val , dp , n ) ) ; NEW_LINE DEDENT"],"references":["import sys NEW_LINE def charVal ( s , i ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( s [ i ] == '1' ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 NEW_LINE DEDENT DEDENT def countMinimalReplacements ( s , i , prev , dp , n ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ prev ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ prev ] NEW_LINE DEDENT val = charVal ( s , i ) NEW_LINE ans = sys . maxsize NEW_LINE if ( val == prev ) : NEW_LINE INDENT val = 0 NEW_LINE for cur in range ( 3 ) : NEW_LINE INDENT if ( cur == prev ) : NEW_LINE INDENT continue NEW_LINE DEDENT val = 1 + countMinimalReplacements ( s , i + 1 , cur , dp , n ) NEW_LINE ans = min ( ans , val ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT ans = countMinimalReplacements ( s , i + 1 , val , dp , n ) NEW_LINE DEDENT dp [ i ] [ val ] = ans NEW_LINE return dp [ i ] [ val ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \"201220211\" NEW_LINE n = len ( s ) NEW_LINE dp = [ [ - 1 for i in range ( 3 ) ] for i in range ( n ) ] NEW_LINE val = charVal ( s , 0 ) NEW_LINE print ( countMinimalReplacements ( s , 1 , val , dp , n ) ) NEW_LINE DEDENT"],"bleu":0.7622420620422998,"rouge_l":0.8968704053770218}
{"id":858,"predictions":["def diffPercentage ( S , M ) : NEW_LINE INDENT diff = M - S NEW_LINE disPercent = ( diff \/ M ) * 100 NEW_LINE return disPercent NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT M = 120 NEW_LINE S = 100 NEW_LINE print ( computePercentile ( S , M ) ) NEW_LINE print ( \" % \" ) NEW_LINE M = 1000 NEW_LINE s = 500 NEW_LINE print ( \" % .2f \" ) NEW_LINE DEDENT"],"references":["def discountPercentage ( S , M ) : NEW_LINE INDENT discount = M - S NEW_LINE disPercent = ( discount \/ M ) * 100 NEW_LINE return disPercent NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT M = 120 NEW_LINE S = 100 NEW_LINE print ( discountPercentage ( S , M ) , \" % \" ) NEW_LINE M = 1000 NEW_LINE S = 500 NEW_LINE print ( discountPercentage ( S , M ) , \" % \" ) NEW_LINE DEDENT"],"bleu":0.7229519954582102,"rouge_l":0.864349140374079}
{"id":859,"predictions":["def sumOfSeries ( n ) : NEW_LINE INDENT return ( 0.6172 * ( pow ( 10 , n ) - 1 ) - 0.55 * n ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 2 ; NEW_LINE print ( sumOfSeries ( n ) ) ; NEW_LINE DEDENT"],"references":["def sumOfSeries ( n ) : NEW_LINE INDENT return ( int ) ( 0.6172 * ( pow ( 10 , n ) - 1 ) - 0.55 * n ) NEW_LINE DEDENT n = 2 NEW_LINE print ( sumOfSeries ( n ) ) NEW_LINE"],"bleu":0.5975221843300701,"rouge_l":0.8243243243243242}
{"id":860,"predictions":["def Move ( a , x , b ) : NEW_LINE INDENT if ( ( ( b - a ) % x == 0 ) or ( ( b - a - 1 ) % x == 0 ) and a + 1 != b ) and a + 1 >= a ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT a , x , b = 3 , 2 , 7 NEW_LINE if ( Move ( a , x , b ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def Move ( a , x , b ) : NEW_LINE INDENT if ( ( ( ( b - a ) % x == 0 ) or ( ( b - a - 1 ) % x == 0 ) and a + 1 != b ) and b >= a ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 3 NEW_LINE x = 2 NEW_LINE b = 7 NEW_LINE if ( Move ( a , x , b ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.7736215092051234,"rouge_l":0.8583170799665646}
{"id":861,"predictions":["def No_Of_Pairs ( N ) : NEW_LINE INDENT i = 1 NEW_LINE while ( ( i * i ) + ( 2 * i * i ) + i <= N ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT return ( i - 1 ) NEW_LINE DEDENT def print_pairs ( pairs ) : NEW_LINE INDENT i = 1 NEW_LINE for i in range ( 1 , pairs + 1 ) : NEW_LINE INDENT mul = i * ( i + 1 ) NEW_LINE print ( \" Pair ▁ no . ▁ - ▁ ( \" , ( mul * i ) , \" , ▁ \" , mul * ( i + 1 ) , \" ) \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 500 NEW_LINE pairs = No_of_Pairs ( N ) NEW_LINE print ( \" No . ▁ of ▁ pairs ▁ = ▁ \" , pairs ) NEW_LINE print_pairs ( pairs ) NEW_LINE DEDENT"],"references":["def No_Of_Pairs ( N ) : NEW_LINE INDENT i = 1 ; NEW_LINE while ( ( i * i * i ) + ( 2 * i * i ) + i <= N ) : NEW_LINE INDENT i += 1 ; NEW_LINE DEDENT return ( i - 1 ) ; NEW_LINE DEDENT def print_pairs ( pairs ) : NEW_LINE INDENT i = 1 ; NEW_LINE mul = 0 ; NEW_LINE for i in range ( 1 , pairs + 1 ) : NEW_LINE INDENT mul = i * ( i + 1 ) ; NEW_LINE print ( \" Pair ▁ no . \" , i , \" ▁ - - > ▁ ( \" , ( mul * i ) , \" , ▁ \" , mul * ( i + 1 ) , \" ) \" ) ; NEW_LINE DEDENT DEDENT N = 500 ; NEW_LINE i = 1 ; NEW_LINE pairs = No_Of_Pairs ( N ) ; NEW_LINE print ( \" No . ▁ of ▁ pairs ▁ = ▁ \" , pairs ) ; NEW_LINE print_pairs ( pairs ) ; NEW_LINE"],"bleu":0.7227306592108435,"rouge_l":0.8666361136571952}
{"id":862,"predictions":["def power ( x , a ) : NEW_LINE INDENT res = 1 NEW_LINE while ( a ) : NEW_LINE INDENT if ( a & 1 ) : NEW_LINE INDENT res = res * x NEW_LINE DEDENT x = x * x NEW_LINE a >>= 1 NEW_LINE DEDENT return res NEW_LINE DEDENT def breakInteger ( N ) : NEW_LINE INDENT if ( N == 2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( N == 3 ) : NEW_LINE INDENT maxProduct = power ( 3 , N \/\/ 3 ) NEW_LINE DEDENT return maxProduct NEW_LINE DEDENT def breakInteger ( N ) : NEW_LINE INDENT if ( N == 2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( N % 3 == 0 ) : NEW_LINE INDENT maxProduct = power ( 3 , N \/\/ 3 ) NEW_LINE DEDENT return maxProduct NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT maxProduct = breakInteger ( 10 ) NEW_LINE print ( maxProduct ) NEW_LINE DEDENT"],"references":["def power ( x , a ) : NEW_LINE INDENT res = 1 ; NEW_LINE while ( a ) : NEW_LINE INDENT if ( a & 1 ) : NEW_LINE INDENT res = res * x ; NEW_LINE DEDENT x = x * x ; NEW_LINE a >>= 1 ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT def breakInteger ( N ) : NEW_LINE INDENT if ( N == 2 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT if ( N == 3 ) : NEW_LINE INDENT return 2 ; NEW_LINE DEDENT maxProduct = 0 ; NEW_LINE if ( N % 3 == 0 ) : NEW_LINE INDENT maxProduct = power ( 3 , int ( N \/ 3 ) ) ; NEW_LINE return maxProduct ; NEW_LINE DEDENT elif ( N % 3 == 1 ) : NEW_LINE INDENT maxProduct = 2 * 2 * power ( 3 , int ( N \/ 3 ) - 1 ) ; NEW_LINE return maxProduct ; NEW_LINE DEDENT elif ( N % 3 == 2 ) : NEW_LINE INDENT maxProduct = 2 * power ( 3 , int ( N \/ 3 ) ) ; NEW_LINE return maxProduct ; NEW_LINE DEDENT DEDENT maxProduct = breakInteger ( 10 ) ; NEW_LINE print ( maxProduct ) ; NEW_LINE"],"bleu":0.5334441057204307,"rouge_l":0.7317560813062313}
{"id":863,"predictions":["def printTrib ( n ) : NEW_LINE INDENT dp = [ 0 ] * n NEW_LINE dp [ 0 ] = dp [ 1 ] = 0 NEW_LINE dp [ 2 ] = 1 NEW_LINE for i in range ( 3 , n ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + dp [ i - 3 ] NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( dp [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT n = 10 NEW_LINE printTrib ( n ) NEW_LINE"],"references":["def printTrib ( n ) : NEW_LINE INDENT dp = [ 0 ] * n NEW_LINE dp [ 0 ] = dp [ 1 ] = 0 ; NEW_LINE dp [ 2 ] = 1 ; NEW_LINE for i in range ( 3 , n ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + dp [ i - 3 ] ; NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( dp [ i ] , \" ▁ \" , end = \" \" ) NEW_LINE DEDENT DEDENT n = 10 NEW_LINE printTrib ( n ) NEW_LINE"],"bleu":0.8875796325608444,"rouge_l":0.9603549448976672}
{"id":864,"predictions":["def findCount ( d ) : NEW_LINE INDENT return 9 * ( pow ( 10 , d - 1 ) ) - pow ( 9 , d - 1 ) ) ; NEW_LINE DEDENT d = 1 ; NEW_LINE print ( findCount ( d ) ) ; NEW_LINE d = 2 ; NEW_LINE print ( findCount ( d ) ) ; NEW_LINE d = 4 ; NEW_LINE print ( findCount ( d ) ) ; NEW_LINE"],"references":["import math NEW_LINE def findCount ( d ) : NEW_LINE INDENT return 9 * ( ( int ) ( math . pow ( 10 , d - 1 ) ) - ( int ) ( math . pow ( 9 , d - 1 ) ) ) ; NEW_LINE DEDENT d = 1 NEW_LINE print ( findCount ( d ) ) NEW_LINE d = 2 NEW_LINE print ( findCount ( d ) ) NEW_LINE d = 4 NEW_LINE print ( findCount ( d ) ) NEW_LINE"],"bleu":0.6641569811965033,"rouge_l":0.8546837469975982}
{"id":865,"predictions":["def conversion ( n ) : NEW_LINE INDENT return ( n - 32.0 ) * 5.0 NEW_LINE DEDENT n = 40 NEW_LINE print ( conversion ( n ) ) NEW_LINE"],"references":["def Conversion ( n ) : NEW_LINE INDENT return ( n - 32.0 ) * 5.0 \/ 9.0 NEW_LINE DEDENT n = 40 NEW_LINE x = Conversion ( n ) NEW_LINE print ( x ) NEW_LINE"],"bleu":0.5861312599339497,"rouge_l":0.7751710654936461}
{"id":866,"predictions":["def isPalin ( string ) : NEW_LINE INDENT length = len ( string ) ; NEW_LINE for i in range ( length ) : NEW_LINE INDENT if ( string [ i ] != string [ len ( string ) - i - 1 ] ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT def palindromicPath ( string , a , i , j , m , n ) : NEW_LINE INDENT if ( j < n - 1 or i < n - 1 ) : NEW_LINE INDENT palindromicPath ( string + a [ i ] [ j ] , a , i + 1 , j , m , n ) ; NEW_LINE DEDENT if ( j < m - 1 ) : NEW_LINE INDENT palindromicPath ( string + a [ i ] [ j ] , a , i + 1 , j + 1 , m , n ) ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT string = string + a [ n - 1 ] [ m - 1 ] ; NEW_LINE if ( isPalin ( string ) ) : NEW_LINE INDENT print ( string ) ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = [ [ ' a ' a ' , ' a ' , ' b ' ] , [ ' a ' , ' a ' , ' b ' , ' a ' , ' b ' , ' a ' ] ; NEW_LINE string = \" \" ; NEW_LINE palindromicPath ( string , 0 , 0 , 0 , 4 , 3 ) ; NEW_LINE DEDENT"],"references":["def isPalin ( str ) : NEW_LINE INDENT l = len ( str ) \/\/ 2 NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( str [ i ] != str [ len ( str ) - i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def palindromicPath ( str , a , i , j , m , n ) : NEW_LINE INDENT if ( j < m - 1 or i < n - 1 ) : NEW_LINE INDENT if ( i < n - 1 ) : NEW_LINE INDENT palindromicPath ( str + a [ i ] [ j ] , a , i + 1 , j , m , n ) NEW_LINE DEDENT if ( j < m - 1 ) : NEW_LINE INDENT palindromicPath ( str + a [ i ] [ j ] , a , i , j + 1 , m , n ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT str = str + a [ n - 1 ] [ m - 1 ] NEW_LINE if isPalin ( str ) : NEW_LINE INDENT print ( str ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ [ ' a ' , ' a ' , ' a ' , ' b ' ] , [ ' b ' , ' a ' , ' a ' , ' a ' ] , [ ' a ' , ' b ' , ' b ' , ' a ' ] ] NEW_LINE str = \" \" NEW_LINE palindromicPath ( str , arr , 0 , 0 , 4 , 3 ) NEW_LINE DEDENT"],"bleu":0.7022856637727835,"rouge_l":0.858864609146204}
{"id":867,"predictions":["def checkDivisors ( a , n ) : NEW_LINE INDENT X = max ( a ) NEW_LINE b = [ ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( X % i == 0 ) : NEW_LINE INDENT b . append ( i ) NEW_LINE if ( X \/\/ i != i ) : NEW_LINE INDENT b = i \/\/ i NEW_LINE DEDENT DEDENT DEDENT if ( len ( b ) != n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( b [ i ] != a [ i ] ) : NEW_LINE INDENT b . append ( X \/\/ i ) NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 8 , 1 , 2 , 12 , 48 , 4 , 24 , 16 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE if ( checkDivisors ( arr , N ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["from math import sqrt NEW_LINE def checkDivisors ( a , n ) : NEW_LINE INDENT X = max ( a ) NEW_LINE b = [ ] NEW_LINE for i in range ( 1 , int ( sqrt ( X ) ) + 1 ) : NEW_LINE INDENT if ( X % i == 0 ) : NEW_LINE INDENT b . append ( i ) NEW_LINE if ( X \/\/ i != i ) : NEW_LINE INDENT b . append ( X \/\/ i ) NEW_LINE DEDENT DEDENT DEDENT if ( len ( b ) != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT a . sort ( reverse = False ) NEW_LINE b . sort ( reverse = False ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( b [ i ] != a [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 8 , 1 , 2 , 12 , 48 , 6 , 4 , 24 , 16 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE if ( checkDivisors ( arr , N ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.8277010562342547,"rouge_l":0.8876420763049301}
{"id":868,"predictions":["def printAllAPTriplets ( arr , n ) : NEW_LINE INDENT s = [ ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT diff = arr [ j ] - arr [ i ] NEW_LINE exists = s . items ( ) NEW_LINE if ( arr [ i ] - diff ) in s . keys ( ) : NEW_LINE INDENT print ( arr [ i ] - diff , \" \" , arr [ i ] , \" \" , arr [ j ] ) NEW_LINE DEDENT DEDENT s . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT arr = [ 2 , 6 , 9 , 12 , 17 , 17 , 22 , 31 , 32 , 35 , 42 ] NEW_LINE n = len ( arr ) NEW_LINE printAllAPTriplets ( arr , n ) NEW_LINE"],"references":["def printAllAPTriplets ( arr , n ) : NEW_LINE INDENT s = [ ] ; NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT diff = arr [ j ] - arr [ i ] ; NEW_LINE if ( ( arr [ i ] - diff ) in arr ) : NEW_LINE INDENT print ( \" { } ▁ { } ▁ { } \" . format ( ( arr [ i ] - diff ) , arr [ i ] , arr [ j ] ) , end = \" \\n \" ) ; NEW_LINE DEDENT DEDENT DEDENT s . append ( arr [ i ] ) ; NEW_LINE DEDENT arr = [ 2 , 6 , 9 , 12 , 17 , 22 , 31 , 32 , 35 , 42 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE printAllAPTriplets ( arr , n ) ; NEW_LINE"],"bleu":0.7097265660545715,"rouge_l":0.8279728533490706}
{"id":869,"predictions":["def isPowerOfTwo ( x ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( ( x & ( x - 1 ) ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def countNum ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( isPowerOfTwo ( a [ i ] ) or isPowerOfTwo ( a [ i ] + 1 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 6 , 9 , 3 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countNum ( arr , n ) ) NEW_LINE DEDENT"],"references":["def isPowerOfTwo ( x ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( ( x & ( x - 1 ) ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def countNum ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( isPowerOfTwo ( a [ i ] ) or isPowerOfTwo ( a [ i ] + 1 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 6 , 9 , 3 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countNum ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.9597056287820104,"rouge_l":0.9848053181386515}
{"id":870,"predictions":["import math NEW_LINE pi = math . pi NEW_LINE def volume ( r ) : NEW_LINE INDENT vol = ( 4 \/ 3 ) * ( pi * r * r * r ) NEW_LINE return vol NEW_LINE DEDENT def surface_area ( r ) : NEW_LINE INDENT Sur_arr = 4 * pi * r * r NEW_LINE return Surr NEW_LINE DEDENT radius = volume ( radius ) NEW_LINE dSurarea = volume ( radius ) NEW_LINE print ( \" Volume ▁ Of ▁ Sphere ▁ : \" , vol ) NEW_LINE print ( \" Surface ▁ Area ▁ of ▁ Sphere ▁ : \" , round ( vol , 6 ) ) NEW_LINE"],"references":["import math NEW_LINE pi = math . pi NEW_LINE def volume ( r ) : NEW_LINE INDENT vol = ( 4 \/ 3 ) * pi * r * r * r NEW_LINE return vol NEW_LINE DEDENT def surfacearea ( r ) : NEW_LINE INDENT sur_ar = 4 * pi * r * r NEW_LINE return sur_ar NEW_LINE DEDENT radius = float ( 12 ) NEW_LINE print ( \" Volume ▁ Of ▁ Sphere ▁ : ▁ \" , volume ( radius ) ) NEW_LINE print ( \" Surface ▁ Area ▁ Of ▁ Sphere ▁ : ▁ \" , surfacearea ( radius ) ) NEW_LINE"],"bleu":0.6819535842422068,"rouge_l":0.8482466747279324}
{"id":871,"predictions":["def isPower ( 10 , 1 ) : NEW_LINE INDENT if ( isPower ( 10 , 1 ) ) == True ) : NEW_LINE INDENT return False NEW_LINE DEDENT if isPower ( 1 , 20 ) : NEW_LINE INDENT return True NEW_LINE DEDENT isPower ( 2 , 30 ) NEW_LINE DEDENT def isPower ( x , y ) : NEW_LINE INDENT if ( x == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT pow = 1 NEW_LINE while ( pow < y ) : NEW_LINE INDENT pow = pow * x NEW_LINE DEDENT return ( pow == y ) NEW_LINE DEDENT def isPower ( x , y ) : NEW_LINE INDENT if ( x == 1 ) : NEW_LINE INDENT return ( y == 1 ) NEW_LINE DEDENT pow = 1 NEW_LINE while ( pow < y ) : NEW_LINE INDENT pow = pow * x NEW_LINE DEDENT return ( pow == y ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( isPower ( 10 , 1 ) ) NEW_LINE DEDENT"],"references":["def isPower ( x , y ) : NEW_LINE INDENT if ( x == 1 ) : NEW_LINE INDENT return ( y == 1 ) NEW_LINE DEDENT pow = 1 NEW_LINE while ( pow < y ) : NEW_LINE INDENT pow = pow * x NEW_LINE DEDENT return ( pow == y ) NEW_LINE DEDENT if ( isPower ( 10 , 1 ) ) : print ( \" True \" ) NEW_LINE else : print ( \" False \" ) NEW_LINE if ( isPower ( 1 , 20 ) ) : print ( \" True \" ) NEW_LINE else : print ( \" False \" ) NEW_LINE if ( isPower ( 2 , 128 ) ) : print ( \" True \" ) NEW_LINE else : print ( \" False \" ) NEW_LINE if ( isPower ( 2 , 30 ) ) : print ( \" True \" ) NEW_LINE else : print ( \" False \" ) NEW_LINE"],"bleu":0.4590952237726304,"rouge_l":0.48804761440140504}
{"id":872,"predictions":["def getSum ( BIT , index ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( index > 0 ) : NEW_LINE INDENT sum += BIT [ index ] NEW_LINE index -= index & ( - index ) NEW_LINE DEDENT return sum NEW_LINE DEDENT def updateBIT ( BITree , n , index , val ) : NEW_LINE INDENT while ( index <= n ) : NEW_LINE INDENT BIT [ index ] += val NEW_LINE index += index & ( - index ) NEW_LINE DEDENT DEDENT def getInvCount ( arr , n ) : NEW_LINE INDENT invcount = 0 NEW_LINE maxElement = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( maxElement < arr [ i ] ) : NEW_LINE INDENT maxElement = arr [ i ] NEW_LINE DEDENT DEDENT BIT = [ 0 ] * ( maxElement + 1 ) NEW_LINE for i in range ( n - 1 , - 1 , 1 ) : NEW_LINE INDENT invcount += getSum ( BIT , arr [ i ] - 1 ) NEW_LINE updateBIT ( BIT , maxElement , arr [ i ] , 1 ) NEW_LINE DEDENT return invcount NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 8 , 4 , 2 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Number ▁ of ▁ inversions ▁ are ▁ : \" , getInvCount ( arr , n ) ) NEW_LINE DEDENT"],"references":["def getSum ( BITree , index ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( index > 0 ) : NEW_LINE INDENT sum += BITree [ index ] NEW_LINE index -= index & ( - index ) NEW_LINE DEDENT return sum NEW_LINE DEDENT def updateBIT ( BITree , n , index , val ) : NEW_LINE INDENT while ( index <= n ) : NEW_LINE INDENT BITree [ index ] += val NEW_LINE index += index & ( - index ) NEW_LINE DEDENT DEDENT def getInvCount ( arr , n ) : NEW_LINE INDENT invcount = 0 NEW_LINE maxElement = max ( arr ) NEW_LINE BIT = [ 0 ] * ( maxElement + 1 ) NEW_LINE for i in range ( 1 , maxElement + 1 ) : NEW_LINE INDENT BIT [ i ] = 0 NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT invcount += getSum ( BIT , arr [ i ] - 1 ) NEW_LINE updateBIT ( BIT , maxElement , arr [ i ] , 1 ) NEW_LINE DEDENT return invcount NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 8 , 4 , 2 , 1 ] NEW_LINE n = 4 NEW_LINE print ( \" Inversion ▁ Count ▁ : ▁ \" , getInvCount ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.8207475530335717,"rouge_l":0.8629567549446865}
{"id":873,"predictions":["def calSum ( n ) : NEW_LINE INDENT a = 3 NEW_LINE b = 0 NEW_LINE c = 2 NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return 3 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 5 NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return 5 NEW_LINE DEDENT sum = 5 NEW_LINE while ( n > 2 ) : NEW_LINE INDENT d = a + b NEW_LINE sum += d NEW_LINE a = b NEW_LINE b = c NEW_LINE c = d NEW_LINE n -= 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 9 NEW_LINE print ( calSum ( n ) ) NEW_LINE"],"references":["def calSum ( n ) : NEW_LINE INDENT a = 3 NEW_LINE b = 0 NEW_LINE c = 2 NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return 3 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 3 NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return 5 NEW_LINE DEDENT sum = 5 NEW_LINE while ( n > 2 ) : NEW_LINE INDENT d = a + b NEW_LINE sum = sum + d NEW_LINE a = b NEW_LINE b = c NEW_LINE c = d NEW_LINE n = n - 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 9 NEW_LINE print ( calSum ( n ) ) NEW_LINE"],"bleu":0.9018062221172275,"rouge_l":0.954323229501327}
{"id":874,"predictions":["def steps ( cur , x , n ) : NEW_LINE INDENT if x == 0 : NEW_LINE INDENT return sys . maxsize ; NEW_LINE DEDENT if x > 0 : NEW_LINE INDENT return abs ( ( ( n - cur ) \/ x ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return abs ( ( cur - 1 ) \/ x ) ; NEW_LINE DEDENT DEDENT def countSteps ( curx , cury , n , m , moves ) : NEW_LINE INDENT count = 0 ; NEW_LINE k = len ( moves ) ; NEW_LINE for i in range ( k ) : NEW_LINE INDENT x = moves [ i ] [ 0 ] NEW_LINE y = moves [ i ] [ 1 ] ; NEW_LINE stepct = min ( steps ( curx , x , n ) , steps ( cury , y , m ) ) ; NEW_LINE count += step ; NEW_LINE curx += step * y ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT n = 4 ; m = 5 ; NEW_LINE x = 1 ; NEW_LINE y = 1 ; NEW_LINE moves = [ [ 1 , 1 ] , [ 1 , 1 ] , [ 0 , - 2 ] ] ; NEW_LINE print ( countSteps ( x , y , n , m , moves ) ) ; NEW_LINE"],"references":["def steps ( cur , x , n ) : NEW_LINE INDENT if x == 0 : NEW_LINE INDENT return float ( ' inf ' ) NEW_LINE DEDENT elif x > 0 : NEW_LINE INDENT return abs ( ( n - cur ) \/\/ x ) NEW_LINE DEDENT else : NEW_LINE INDENT return abs ( int ( ( cur - 1 ) \/ x ) ) NEW_LINE DEDENT DEDENT def countSteps ( curx , cury , n , m , moves ) : NEW_LINE INDENT count = 0 NEW_LINE k = len ( moves ) NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT x = moves [ i ] [ 0 ] NEW_LINE y = moves [ i ] [ 1 ] NEW_LINE stepct = min ( steps ( curx , x , n ) , steps ( cury , y , m ) ) NEW_LINE count += stepct NEW_LINE curx += stepct * x NEW_LINE cury += stepct * y NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n , m , x , y = 4 , 5 , 1 , 1 NEW_LINE moves = [ [ 1 , 1 ] , [ 1 , 1 ] , [ 0 , - 2 ] ] NEW_LINE print ( countSteps ( x , y , n , m , moves ) ) NEW_LINE DEDENT"],"bleu":0.699153728508197,"rouge_l":0.8344559405596833}
{"id":875,"predictions":["def SUM ( n , m ) : NEW_LINE INDENT if ( m == 1 ) : NEW_LINE INDENT return ( n * ( n + 1 ) \/\/ 2 ) ; NEW_LINE DEDENT sum = SUM ( n , m - 1 ) ; NEW_LINE return ( sum * ( sum + 1 ) \/\/ 2 ) ; NEW_LINE DEDENT n = 5 ; NEW_LINE m = 3 ; NEW_LINE print ( SUM ( n , \" , \" , m , \" ) : ▁ \" , SUM ( n , m ) ) ; NEW_LINE"],"references":["def SUM ( n , m ) : NEW_LINE INDENT if ( m == 1 ) : NEW_LINE INDENT return ( n * ( n + 1 ) \/ 2 ) NEW_LINE DEDENT sum = SUM ( n , m - 1 ) NEW_LINE return int ( sum * ( sum + 1 ) \/ 2 ) NEW_LINE DEDENT n = 5 NEW_LINE m = 3 NEW_LINE print ( \" SUM ( \" , n , \" , ▁ \" , m , \" ) : \" , SUM ( n , m ) ) NEW_LINE"],"bleu":0.7195324807865122,"rouge_l":0.9192346766000679}
{"id":876,"predictions":["def printInitials ( str ) : NEW_LINE INDENT l = len ( str ) NEW_LINE t = str . strip ( ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( str [ i ] != ' ▁ ' ) : NEW_LINE INDENT t = str . replace ( str [ 0 ] , ' ▁ ' ) NEW_LINE DEDENT else : NEW_LINE INDENT t = str . replace ( t [ 0 ] ) NEW_LINE DEDENT DEDENT temp = \" \" NEW_LINE for j in x : NEW_LINE INDENT if ( j == '0' ) : NEW_LINE INDENT t = str . replace ( t [ 0 ] , ' . ' ) NEW_LINE DEDENT else : NEW_LINE INDENT t = str . replace ( t [ 0 ] ) NEW_LINE DEDENT DEDENT print ( t ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" ishita ▁ bhouy \" NEW_LINE print1s ( str1 ) NEW_LINE DEDENT"],"references":["def printInitials ( string : str ) : NEW_LINE INDENT length = len ( string ) NEW_LINE string . strip ( ) NEW_LINE t = \" \" NEW_LINE for i in range ( length ) : NEW_LINE INDENT ch = string [ i ] NEW_LINE if ch != ' ▁ ' : NEW_LINE INDENT t += ch NEW_LINE DEDENT else : NEW_LINE INDENT print ( t [ 0 ] . upper ( ) + \" . ▁ \" , end = \" \" ) NEW_LINE t = \" \" NEW_LINE DEDENT DEDENT temp = \" \" NEW_LINE for j in range ( len ( t ) ) : NEW_LINE INDENT if j == 0 : NEW_LINE INDENT temp += t [ 0 ] . upper ( ) NEW_LINE DEDENT else : NEW_LINE INDENT temp += t [ j ] . lower ( ) NEW_LINE DEDENT DEDENT print ( temp ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" ishita ▁ bhuiya \" NEW_LINE printInitials ( string ) NEW_LINE DEDENT"],"bleu":0.43621317639176366,"rouge_l":0.6544453773672917}
{"id":877,"predictions":["def check ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return ( ( ord ( st [ 0 ] ) - ord ( '0' ) ) % 8 == 0 ) NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return ( ( ( ord ( st [ n - 2 ] ) ) * 10 + ( ( ord ( st [ n - 1 ] ) ) % 8 == 0 ) ) NEW_LINE DEDENT last = ( int ) ( st [ n - 1 ] ) NEW_LINE second_last = ( int ) ( st [ n - 2 ] ) NEW_LINE return ( ( third_last * 100 + second_last * 10 + last ) % 8 == 0 ) NEW_LINE DEDENT st = \"76952\" NEW_LINE if ( check ( st ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No ▁ \" ) NEW_LINE DEDENT"],"references":["def check ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return ( ( int ) ( st [ 0 ] ) % 8 == 0 ) NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return ( ( int ) ( st [ n - 2 ] ) * 10 + ( ( int ) ( str [ n - 1 ] ) % 8 == 0 ) ) NEW_LINE DEDENT last = ( int ) ( st [ n - 1 ] ) NEW_LINE second_last = ( int ) ( st [ n - 2 ] ) NEW_LINE third_last = ( int ) ( st [ n - 3 ] ) NEW_LINE return ( ( third_last * 100 + second_last * 10 + last ) % 8 == 0 ) NEW_LINE DEDENT st = \"76952\" NEW_LINE if ( check ( st ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No ▁ \" ) NEW_LINE DEDENT"],"bleu":0.8708689514139971,"rouge_l":0.9085216213929085}
{"id":878,"predictions":["import math NEW_LINE def check ( n ) : NEW_LINE INDENT d = math . sqrt ( n ) NEW_LINE if ( d * d == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def largestNonPerfectSquareNumber ( a , n ) : NEW_LINE INDENT maxi = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( check ( a [ i ] ) == False ) : NEW_LINE INDENT maxi = max ( a [ i ] , maxi ) NEW_LINE DEDENT DEDENT return maxi ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 16 , 20 , 25 , 2 , 3 , 10 ] NEW_LINE n = len ( a ) NEW_LINE print ( largestNonPerfectSquareNumber ( a , n ) ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def check ( n ) : NEW_LINE INDENT d = int ( math . sqrt ( n ) ) NEW_LINE if ( d * d == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def largestNonPerfectSquareNumber ( a , n ) : NEW_LINE INDENT maxi = - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( check ( a [ i ] ) == False ) : NEW_LINE INDENT maxi = max ( a [ i ] , maxi ) NEW_LINE DEDENT DEDENT return maxi NEW_LINE DEDENT a = [ 16 , 20 , 25 , 2 , 3 , 10 ] NEW_LINE n = len ( a ) NEW_LINE print ( largestNonPerfectSquareNumber ( a , n ) ) NEW_LINE"],"bleu":0.8502083871714627,"rouge_l":0.9345904537418974}
{"id":879,"predictions":["def findValueAtX ( n ) : NEW_LINE INDENT return ( n * n * n ) + n NEW_LINE DEDENT print ( findValueAtX ( 10 ) ) NEW_LINE print ( findValueAtX ( 2 ) ) NEW_LINE"],"references":["def findValueAtX ( n ) : NEW_LINE INDENT return ( n * n * n ) + n NEW_LINE DEDENT print ( findValueAtX ( 10 ) ) NEW_LINE print ( findValueAtX ( 2 ) ) NEW_LINE"],"bleu":1.0,"rouge_l":1.0}
{"id":880,"predictions":["import math NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT def isThreedifactors ( n ) : NEW_LINE INDENT sq = int ( math . sqrt ( n ) ) NEW_LINE if ( 1 * sq * sq != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT return isPrime ( sq ) if ( sqrt ( num ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT num = 15 NEW_LINE if ( isThree disFactors ( num ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT num = 15 NEW_LINE if ( isThree disFactors ( num ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["from math import sqrt NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT k = int ( sqrt ( n ) ) + 1 NEW_LINE for i in range ( 5 , k , 6 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def isThreeDisctFactors ( n ) : NEW_LINE INDENT sq = int ( sqrt ( n ) ) NEW_LINE if ( 1 * sq * sq != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( isPrime ( sq ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT num = 9 NEW_LINE if ( isThreeDisctFactors ( num ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT num = 15 NEW_LINE if ( isThreeDisctFactors ( num ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT num = 12397923568441 NEW_LINE if ( isThreeDisctFactors ( num ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.7204656587702739,"rouge_l":0.824768172300329}
{"id":881,"predictions":["def maxPartitions ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE max_so_far = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT max_so_far = max ( max_so_far , arr [ i ] ) NEW_LINE if ( max_so_far == i ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 0 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxPartitions ( arr , n ) ) NEW_LINE DEDENT"],"references":["def maxPartitions ( arr , n ) : NEW_LINE INDENT ans = 0 ; max_so_far = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT max_so_far = max ( max_so_far , arr [ i ] ) NEW_LINE if ( max_so_far == i ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 0 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxPartitions ( arr , n ) ) NEW_LINE"],"bleu":0.8104894110792539,"rouge_l":0.9183017591339647}
{"id":882,"predictions":["def greaterK ( n , k ) : NEW_LINE INDENT p = [ 0 ] * ( len ( n ) + 2 ) ; NEW_LINE index = 0 ; NEW_LINE x = n ; NEW_LINE while ( x ) : NEW_LINE INDENT p [ index ] = x % k ; NEW_LINE x = int ( x \/ k ) ; NEW_LINE index += 1 ; NEW_LINE DEDENT idx = 0 ; NEW_LINE for i in range ( len ( p ) - 1 ) : NEW_LINE INDENT if ( p [ i ] >= 2 ) : NEW_LINE INDENT p [ i ] = 0 ; NEW_LINE p [ i + 1 ] += 1 ; NEW_LINE for j in range ( idx , i ) : NEW_LINE INDENT p [ j ] = 0 ; NEW_LINE DEDENT idx = i + 1 ; NEW_LINE DEDENT if ( p [ i ] == k ) : NEW_LINE INDENT p [ index ] = 1 ; NEW_LINE index += 1 ; NEW_LINE DEDENT DEDENT j = len ( p ) - 1 ; NEW_LINE if ( p [ j ] >= 2 ) : NEW_LINE INDENT p [ index ] = 1 ; NEW_LINE index += 1 ; NEW_LINE DEDENT ans = 0 ; NEW_LINE for i in range ( len ( p ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT ans = ans * k + p [ i ] ; NEW_LINE DEDENT print ( ans ) ; NEW_LINE DEDENT n = 29 ; NEW_LINE k = 7 ; NEW_LINE greaterK ( n , k ) ; NEW_LINE"],"references":["def greaterK ( n , k ) : NEW_LINE INDENT index = 0 NEW_LINE p = [ 0 for i in range ( n + 2 ) ] NEW_LINE x = n NEW_LINE while ( x > 0 ) : NEW_LINE INDENT p [ index ] = x % k NEW_LINE x \/\/= k NEW_LINE index += 1 NEW_LINE DEDENT idx = 0 NEW_LINE for i in range ( 0 , len ( p ) - 1 , 1 ) : NEW_LINE INDENT if ( p [ i ] >= 2 ) : NEW_LINE INDENT p [ i ] = 0 NEW_LINE p [ i + 1 ] += 1 NEW_LINE for j in range ( idx , i , 1 ) : NEW_LINE INDENT p [ j ] = 0 NEW_LINE DEDENT idx = i + 1 NEW_LINE DEDENT if ( p [ i ] == k ) : NEW_LINE INDENT p [ i ] = 0 NEW_LINE p [ i + 1 ] += 1 NEW_LINE DEDENT DEDENT j = len ( p ) - 1 NEW_LINE if ( p [ j ] >= 2 ) : NEW_LINE INDENT p [ index ] = 1 NEW_LINE index += 1 NEW_LINE DEDENT ans = 0 NEW_LINE i = len ( p ) - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT ans = ans * k + p [ i ] NEW_LINE i -= 1 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 29 NEW_LINE k = 7 NEW_LINE greaterK ( n , k ) NEW_LINE DEDENT"],"bleu":0.6608400026277768,"rouge_l":0.816429718636607}
{"id":883,"predictions":["def longestPrefixSuffix ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE lps = [ 0 for i in range ( n ) ] NEW_LINE len1 = 0 NEW_LINE i = 1 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( s [ i ] == s [ len1 ] ) : NEW_LINE INDENT len1 += 1 NEW_LINE lps [ i ] = len1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( len1 != 0 ) : NEW_LINE INDENT len1 = lps [ len1 - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lps [ i ] = 0 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT DEDENT res = lps [ n - 1 ] NEW_LINE if ( res > int ( n \/ 2 ) ) : NEW_LINE INDENT return int ( n \/ 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return res NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" abcab \" NEW_LINE print ( longestPrefixSuffix ( s ) ) NEW_LINE DEDENT"],"references":["def longestPrefixSuffix ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE lps = [ 0 ] * n NEW_LINE l = 0 NEW_LINE i = 1 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( s [ i ] == s [ l ] ) : NEW_LINE INDENT l = l + 1 NEW_LINE lps [ i ] = l NEW_LINE i = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( l != 0 ) : NEW_LINE INDENT l = lps [ l - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lps [ i ] = 0 NEW_LINE i = i + 1 NEW_LINE DEDENT DEDENT DEDENT res = lps [ n - 1 ] NEW_LINE if ( res > n \/ 2 ) : NEW_LINE INDENT return n \/\/ 2 NEW_LINE DEDENT else : NEW_LINE INDENT return res NEW_LINE DEDENT DEDENT s = \" abcab \" NEW_LINE print ( longestPrefixSuffix ( s ) ) NEW_LINE"],"bleu":0.6758020746377482,"rouge_l":0.8467454511348714}
{"id":884,"predictions":["def printBracketNumber ( exp , n ) : NEW_LINE INDENT left_bnum = 1 NEW_LINE right_bnum = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( exp [ i ] == ' ( ' ) ) : NEW_LINE INDENT print ( left_bnum , end = ' ▁ ' ) NEW_LINE right_bnum . append ( left_bnum ) NEW_LINE left_bnum += 1 NEW_LINE DEDENT elif ( exp [ i ] == ' ) ' ) : NEW_LINE INDENT print ( right_bnum [ - 1 ] , end = \" ▁ \" ) NEW_LINE right_bnum . pop ( ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT exp = \" ( a + ( b * c ) ) + int ( d \/ e ) \" NEW_LINE n = len ( exp ) NEW_LINE printBracketNumber ( exp , n ) NEW_LINE DEDENT"],"references":["def printBracketNumber ( exp , n ) : NEW_LINE INDENT left_bnum = 1 NEW_LINE right_bnum = list ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if exp [ i ] == ' ( ' : NEW_LINE INDENT print ( left_bnum , end = \" ▁ \" ) NEW_LINE right_bnum . append ( left_bnum ) NEW_LINE left_bnum += 1 NEW_LINE DEDENT elif exp [ i ] == ' ) ' : NEW_LINE INDENT print ( right_bnum [ - 1 ] , end = \" ▁ \" ) NEW_LINE right_bnum . pop ( ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT exp = \" ( a + ( b * c ) ) + ( d \/ e ) \" NEW_LINE n = len ( exp ) NEW_LINE printBracketNumber ( exp , n ) NEW_LINE DEDENT"],"bleu":0.8624124257545025,"rouge_l":0.953331886260039}
{"id":885,"predictions":["N = 10 ** 6 ; NEW_LINE fourDiv = [ True ] * ( N + 1 ) ; NEW_LINE def twoDistinctFactors ( ) : NEW_LINE INDENT primeAllFact = [ False ] * ( N + 1 ) ; NEW_LINE for p in range ( 2 , N + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , N + 1 , p ) : NEW_LINE INDENT primeAll [ i ] = False ; NEW_LINE DEDENT DEDENT DEDENT prime = [ ] ; NEW_LINE for p in range ( 2 , N + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT prime . append ( p ) ; NEW_LINE DEDENT DEDENT for i in range ( 0 , len ( prime ) ) : NEW_LINE INDENT p = prime [ i ] ; NEW_LINE if ( 1 >= N ) : NEW_LINE INDENT break ; NEW_LINE DEDENT twoDiv [ p * p ] = True ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT fourDistinctFactors ( ) ; NEW_LINE num = 12 ; NEW_LINE if ( fourDiv [ num ] ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"],"references":["N = 1000001 ; NEW_LINE fourDiv = [ False ] * ( N + 1 ) ; NEW_LINE def fourDistinctFactors ( ) : NEW_LINE INDENT primeAll = [ True ] * ( N + 1 ) ; NEW_LINE p = 2 ; NEW_LINE while ( p * p <= N ) : NEW_LINE INDENT if ( primeAll [ p ] == True ) : NEW_LINE INDENT i = p * 2 ; NEW_LINE while ( i <= N ) : NEW_LINE INDENT primeAll [ i ] = False ; NEW_LINE i += p ; NEW_LINE DEDENT DEDENT p += 1 ; NEW_LINE DEDENT prime = [ ] ; NEW_LINE for p in range ( 2 , N + 1 ) : NEW_LINE INDENT if ( primeAll [ p ] ) : NEW_LINE INDENT prime . append ( p ) ; NEW_LINE DEDENT DEDENT for i in range ( len ( prime ) ) : NEW_LINE INDENT p = prime [ i ] ; NEW_LINE if ( 1 * p * p * p <= N ) : NEW_LINE INDENT fourDiv [ p * p * p ] = True ; NEW_LINE DEDENT for j in range ( i + 1 , len ( prime ) ) : NEW_LINE INDENT q = prime [ j ] ; NEW_LINE if ( 1 * p * q > N ) : NEW_LINE INDENT break ; NEW_LINE DEDENT fourDiv [ p * q ] = True ; NEW_LINE DEDENT DEDENT DEDENT fourDistinctFactors ( ) ; NEW_LINE num = 10 ; NEW_LINE if ( fourDiv [ num ] ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT num = 12 ; NEW_LINE if ( fourDiv [ num ] ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT"],"bleu":0.5305242904972027,"rouge_l":0.6888374456552426}
{"id":886,"predictions":["N = 3 ; NEW_LINE def mularProductMat ( mat , k ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT mat [ i ] [ j ] = mat [ i ] [ j ] * k ; NEW_LINE DEDENT DEDENT DEDENT mat = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] ; NEW_LINE k = 4 ; NEW_LINE += 1 ; NEW_LINE summarProductMat ( mat , k ) ; NEW_LINE print ( \" Scalar ▁ Product ▁ is \" ) ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( ) ; NEW_LINE DEDENT"],"references":["N = 3 NEW_LINE def scalarProductMat ( mat , k ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT mat [ i ] [ j ] = mat [ i ] [ j ] * k NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT mat = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE k = 4 NEW_LINE scalarProductMat ( mat , k ) NEW_LINE print ( \" Scalar ▁ Product ▁ Matrix ▁ is ▁ : ▁ \" ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT"],"bleu":0.7684083501506438,"rouge_l":0.8895325609268878}
{"id":887,"predictions":["def reverse ( l ) : NEW_LINE INDENT str = \" geeksforgeeks \" NEW_LINE print ( str ) NEW_LINE DEDENT"],"references":["str = \" geeksforgeeks \" ; NEW_LINE str = \" \" . join ( reversed ( str ) ) NEW_LINE print ( str ) ; NEW_LINE"],"bleu":0.32391617260645134,"rouge_l":0.4672701949860724}
{"id":888,"predictions":["def countDistinct ( arr , n ) : NEW_LINE INDENT hs = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hs . add ( arr [ i ] ) NEW_LINE DEDENT return len ( hs ) NEW_LINE DEDENT arr = [ 6 , 10 , 5 , 4 , 9 , 120 , 4 , 6 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countDistinct ( arr , n ) ) NEW_LINE"],"references":["def countDistinct ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] not in s ) : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT arr = [ 6 , 10 , 5 , 4 , 9 , 120 , 4 , 6 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countDistinct ( arr , n ) ) NEW_LINE"],"bleu":0.678994377704476,"rouge_l":0.8172959805115713}
{"id":889,"predictions":["x = 32 NEW_LINE def toggleCase ( a ) : NEW_LINE INDENT for i in range ( len ( a ) ) : NEW_LINE INDENT a [ i ] = ( a [ i ] ^ 32 ) NEW_LINE DEDENT return ( a ) NEW_LINE DEDENT def toggleCase ( str ) : NEW_LINE INDENT ord ( str ) NEW_LINE print ( \" Previous ▁ case : ▁ \" , end = \" \" ) NEW_LINE str = toggleCase ( str ) NEW_LINE print ( \" Original ▁ string : ▁ \" , end = \" \" ) NEW_LINE str = toggleCase ( str ) NEW_LINE print ( \" Original ▁ string : \" , end = \" \" ) NEW_LINE print ( str ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"references":["x = 32 ; NEW_LINE def toggleCase ( a ) : NEW_LINE INDENT for i in range ( len ( a ) ) : NEW_LINE INDENT a = a [ : i ] + chr ( ord ( a [ i ] ) ^ 32 ) + a [ i + 1 : ] ; NEW_LINE DEDENT return a ; NEW_LINE DEDENT str = \" CheRrY \" ; NEW_LINE print ( \" Toggle ▁ case : ▁ \" , end = \" \" ) ; NEW_LINE str = toggleCase ( str ) ; NEW_LINE print ( str ) ; NEW_LINE print ( \" Original ▁ string : ▁ \" , end = \" \" ) ; NEW_LINE str = toggleCase ( str ) ; NEW_LINE print ( str ) ; NEW_LINE"],"bleu":0.5409937034676996,"rouge_l":0.6968494468494467}
{"id":890,"predictions":["MAX = 1000000 NEW_LINE arr = [ ] NEW_LINE prime = [ False ] * ( MAX ) NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT for p in range ( 2 , int ( sqrt ( MAX ) ) + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for p in range ( 2 , MAX ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT def isPrimorialPrime ( n ) : NEW_LINE INDENT if ( prime [ n ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT product = 1 NEW_LINE i = 0 NEW_LINE while ( product < n ) : NEW_LINE INDENT product = product * arr [ i ] NEW_LINE if ( product + 1 == n or product - 1 == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE n = 31 NEW_LINE if isPrimorialPrime ( n ) == True : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"references":["from math import sqrt NEW_LINE MAX = 100000 NEW_LINE prime = [ True ] * MAX NEW_LINE arr = [ ] NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT for p in range ( 2 , int ( sqrt ( MAX ) ) + 1 ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for p in range ( 2 , MAX ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT arr . append ( p ) NEW_LINE DEDENT DEDENT DEDENT def isPrimorialPrime ( n ) : NEW_LINE INDENT if not prime [ n ] : NEW_LINE INDENT return False NEW_LINE DEDENT product , i = 1 , 0 NEW_LINE while product < n : NEW_LINE INDENT product *= arr [ i ] NEW_LINE if product + 1 == n or product - 1 == n : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE n = 31 NEW_LINE if ( isPrimorialPrime ( n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.7963227603244377,"rouge_l":0.894538477352155}
{"id":891,"predictions":["def countNumbers ( X , Y , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( ( i % X == 0 ) and ( i % Y != 0 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT X , Y , N = 2 , 3 , 10 NEW_LINE print ( countNumbers ( X , Y , N ) ) NEW_LINE DEDENT"],"references":["def countNumbers ( X , Y , N ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( ( i % X == 0 ) and ( i % Y != 0 ) ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT X = 2 ; NEW_LINE Y = 3 ; NEW_LINE N = 10 ; NEW_LINE print ( countNumbers ( X , Y , N ) ) ; NEW_LINE"],"bleu":0.7002589451365407,"rouge_l":0.8327285294625885}
{"id":892,"predictions":["from collections import defaultdict NEW_LINE def countSubseq ( arr , n ) : NEW_LINE INDENT um = defaultdict ( lambda : 0 ) NEW_LINE count = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if um [ arr [ i ] ] != 0 : NEW_LINE INDENT a [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT um [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT for it in um : NEW_LINE INDENT count *= um [ it ] NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 7 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Count ▁ = \" , countSubseq ( arr , n ) ) NEW_LINE DEDENT"],"references":["def countSubseq ( arr , n ) : NEW_LINE INDENT um = { i : 0 for i in range ( 8 ) } NEW_LINE count = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT um [ arr [ i ] ] += 1 NEW_LINE DEDENT for key , values in um . items ( ) : NEW_LINE INDENT if ( values > 0 ) : NEW_LINE INDENT count *= values NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 7 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Count ▁ = \" , countSubseq ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.678556317290441,"rouge_l":0.7583074348553669}
{"id":893,"predictions":["from math import sqrt NEW_LINE def check ( a , b ) : NEW_LINE INDENT c = 0 NEW_LINE while ( a != 0 ) : NEW_LINE INDENT c = c + a % 10 NEW_LINE a = a \/\/ 10 NEW_LINE DEDENT return ( c == b ) NEW_LINE DEDENT def root ( n ) : NEW_LINE INDENT found = False NEW_LINE mx = 1E18 NEW_LINE for i in range ( 90 ) : NEW_LINE INDENT s = i * i + 4 * n NEW_LINE sq = sqrt ( s ) NEW_LINE if ( sq * sq == s and check ( ( sq - i ) \/\/ 2 , i ) ) : NEW_LINE INDENT found = True NEW_LINE mx = min ( mx , ( sq - i ) \/\/ 2 ) NEW_LINE DEDENT DEDENT if ( found ) : NEW_LINE INDENT return mx NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 110 NEW_LINE print ( root ( n ) ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def check ( a , b ) : NEW_LINE INDENT c = 0 ; NEW_LINE while ( a != 0 ) : NEW_LINE INDENT c = c + a % 10 ; NEW_LINE a = int ( a \/ 10 ) ; NEW_LINE DEDENT return True if ( c == b ) else False ; NEW_LINE DEDENT def root ( n ) : NEW_LINE INDENT found = False ; NEW_LINE mx = 1000000000000000001 ; NEW_LINE for i in range ( 91 ) : NEW_LINE INDENT s = i * i + 4 * n ; NEW_LINE sq = int ( math . sqrt ( s ) ) ; NEW_LINE if ( sq * sq == s and check ( int ( ( sq - i ) \/ 2 ) , i ) ) : NEW_LINE INDENT found = True ; NEW_LINE mx = min ( mx , int ( ( sq - i ) \/ 2 ) ) ; NEW_LINE DEDENT DEDENT if ( found ) : NEW_LINE INDENT return mx ; NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT DEDENT n = 110 ; NEW_LINE print ( root ( n ) ) ; NEW_LINE"],"bleu":0.6285681929418496,"rouge_l":0.8391209528602586}
{"id":894,"predictions":["def Fraction ( n , d ) : NEW_LINE INDENT num = n NEW_LINE b = first . den NEW_LINE c = sec . num NEW_LINE d = sec . den NEW_LINE Y = a * d - b * c NEW_LINE return first if Y > 0 else sec NEW_LINE if Y > 0 : NEW_LINE INDENT return x , num = sec NEW_LINE DEDENT else : NEW_LINE INDENT return max ( 0 , sec ) NEW_LINE DEDENT DEDENT first = third ( 3 , 2 ) NEW_LINE sec = [ 3 , 4 ] NEW_LINE print ( maxFraction ( first , sec ) ) NEW_LINE"],"references":["def maxFraction ( first , sec ) : NEW_LINE INDENT a = first [ 0 ] ; b = first [ 1 ] NEW_LINE c = sec [ 0 ] ; d = sec [ 1 ] NEW_LINE Y = a * d - b * c NEW_LINE return first if Y else sec NEW_LINE DEDENT first = ( 3 , 2 ) NEW_LINE sec = ( 3 , 4 ) NEW_LINE res = maxFraction ( first , sec ) NEW_LINE print ( str ( res [ 0 ] ) + \" \/ \" + str ( res [ 1 ] ) ) NEW_LINE"],"bleu":0.4036518945741232,"rouge_l":0.5606792335254712}
{"id":895,"predictions":["def Permutation ( n , k ) : NEW_LINE INDENT p = [ 0 ] * ( n + 1 ) ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT p [ i ] = i ; NEW_LINE DEDENT for i in range ( 1 , n - k ) : NEW_LINE INDENT p [ i + 1 ] = i ; NEW_LINE DEDENT p [ 1 ] = n - k ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( p [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 ; k = 2 ; NEW_LINE Permutation ( n , k ) ; NEW_LINE DEDENT"],"references":["def Permutation ( n , k ) : NEW_LINE INDENT p = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT p [ i ] = i NEW_LINE DEDENT for i in range ( 1 , n - k ) : NEW_LINE INDENT p [ i + 1 ] = i NEW_LINE DEDENT p [ 1 ] = n - k NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( p [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE k = 2 NEW_LINE Permutation ( n , k ) NEW_LINE DEDENT"],"bleu":0.7980049725420956,"rouge_l":0.9314605431868515}
{"id":896,"predictions":["def reverse ( x ) : NEW_LINE INDENT rev = 0 NEW_LINE while ( x > 0 ) : NEW_LINE INDENT rev = ( rev * 10 ) + x % 10 NEW_LINE x = x \/\/ 10 NEW_LINE DEDENT return rev NEW_LINE DEDENT def printEmirp ( n ) : NEW_LINE INDENT prime = [ True for i in range ( n + 1 ) ] NEW_LINE p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT rev = reverse ( p ) NEW_LINE if ( p != rev and rev <= n and prime [ rev ] ) : NEW_LINE INDENT print ( p , rev , end = \" ▁ \" ) NEW_LINE prime [ rev ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT n = 100 NEW_LINE printEmirp ( n ) NEW_LINE"],"references":["def reverse ( x ) : NEW_LINE INDENT rev = 0 ; NEW_LINE while ( x > 0 ) : NEW_LINE INDENT rev = ( rev * 10 ) + x % 10 ; NEW_LINE x = int ( x \/ 10 ) ; NEW_LINE DEDENT return rev ; NEW_LINE DEDENT def printEmirp ( n ) : NEW_LINE INDENT prime = [ 1 ] * ( n + 1 ) ; NEW_LINE p = 2 ; NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == 1 ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = 0 ; NEW_LINE DEDENT DEDENT p += 1 ; NEW_LINE DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] == 1 ) : NEW_LINE INDENT rev = reverse ( p ) ; NEW_LINE if ( p != rev and rev <= n and prime [ rev ] == 1 ) : NEW_LINE INDENT print ( p , rev , end = \" ▁ \" ) ; NEW_LINE prime [ rev ] = 0 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT n = 100 ; NEW_LINE printEmirp ( n ) ; NEW_LINE"],"bleu":0.7562832677808646,"rouge_l":0.9081203007518796}
{"id":897,"predictions":["def largest ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE return arr [ n - 1 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 10 , 324 , 45 , 90 , 9808 ] NEW_LINE n = len ( arr ) NEW_LINE print ( largest ( arr , n ) ) NEW_LINE DEDENT"],"references":["def largest ( arr , n ) : NEW_LINE INDENT return max ( arr ) NEW_LINE DEDENT arr = [ 10 , 324 , 45 , 90 , 9808 ] NEW_LINE n = len ( arr ) NEW_LINE print ( largest ( arr , n ) ) NEW_LINE"],"bleu":0.5902497486980223,"rouge_l":0.7892466935020128}
{"id":898,"predictions":["class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def maxLevelProduct ( root ) : NEW_LINE INDENT if ( not root ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT result = root . data NEW_LINE q = [ ] NEW_LINE q . append ( root ) NEW_LINE while ( len ( q ) != 0 ) : NEW_LINE INDENT count = len ( q ) NEW_LINE product = 1 NEW_LINE while ( count != 0 ) : NEW_LINE INDENT temp = q [ 0 ] NEW_LINE q . pop ( 0 ) NEW_LINE product = product * temp . data NEW_LINE if ( temp . left ) : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE DEDENT if ( temp . right ) : NEW_LINE INDENT q . append ( temp . right ) NEW_LINE DEDENT DEDENT result = max ( product , result ) NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 1 ) NEW_LINE root . left = newNode ( 2 ) NEW_LINE root . right = newNode ( 3 ) NEW_LINE root . left . left = newNode ( 4 ) NEW_LINE root . left . left = newNode ( 5 ) NEW_LINE root . left . left = newNode ( 4 ) NEW_LINE root . left . left = newNode ( 5 ) NEW_LINE root . left . left = newNode ( 4 ) NEW_LINE root . left . left = newNode ( 5 ) NEW_LINE root . right . left = newNode ( 6 ) NEW_LINE print ( \" Maximum ▁ level ▁ product ▁ is \" , maxLevelProduct ( root ) ) NEW_LINE DEDENT"],"references":["class newNode : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . data = key NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def maxLevelProduct ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT result = root . data NEW_LINE q = [ ] NEW_LINE q . append ( root ) NEW_LINE while ( len ( q ) ) : NEW_LINE INDENT count = len ( q ) NEW_LINE product = 1 NEW_LINE while ( count ) : NEW_LINE INDENT count -= 1 NEW_LINE temp = q [ 0 ] NEW_LINE q . pop ( 0 ) NEW_LINE product = product * temp . data NEW_LINE if ( temp . left != None ) : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE DEDENT if ( temp . right != None ) : NEW_LINE INDENT q . append ( temp . right ) NEW_LINE DEDENT DEDENT result = max ( product , result ) NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 1 ) NEW_LINE root . left = newNode ( 2 ) NEW_LINE root . right = newNode ( 3 ) NEW_LINE root . left . left = newNode ( 4 ) NEW_LINE root . left . right = newNode ( 5 ) NEW_LINE root . right . right = newNode ( 8 ) NEW_LINE root . right . right . left = newNode ( 6 ) NEW_LINE root . right . right . right = newNode ( 7 ) NEW_LINE print ( \" Maximum ▁ level ▁ product ▁ is \" , maxLevelProduct ( root ) ) NEW_LINE DEDENT"],"bleu":0.81681184105087,"rouge_l":0.9107888258589321}
{"id":899,"predictions":["def fact ( n ) : NEW_LINE INDENT fact = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fact *= i NEW_LINE DEDENT return fact NEW_LINE DEDENT def countStrings ( string , n ) : NEW_LINE INDENT distinct_char = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT distinct_char . add ( string [ i ] ) NEW_LINE DEDENT return fact ( len ( distinct_char ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" geeksforgeeks \" NEW_LINE n = len ( string ) NEW_LINE print ( countStrings ( string , n ) ) NEW_LINE DEDENT"],"references":["def fact ( n ) : NEW_LINE INDENT fact = 1 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fact *= i ; NEW_LINE DEDENT return fact ; NEW_LINE DEDENT def countStrings ( string , n ) : NEW_LINE INDENT distinct_char = set ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT distinct_char . add ( string [ i ] ) ; NEW_LINE DEDENT return fact ( len ( distinct_char ) ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" geeksforgeeks \" ; NEW_LINE n = len ( string ) ; NEW_LINE print ( countStrings ( string , n ) ) ; NEW_LINE DEDENT"],"bleu":0.8191416538015016,"rouge_l":0.9572728471581169}
{"id":900,"predictions":["def printMaxValPair ( v , n ) : NEW_LINE INDENT v . sort ( ) NEW_LINE N = v [ n - 1 ] NEW_LINE if ( N % 2 == 1 ) : NEW_LINE INDENT first_max = N \/\/ 2 NEW_LINE second_max = first_max + 1 NEW_LINE ans1 = 3e18 NEW_LINE is2 = - 1 NEW_LINE from itertools import - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( v [ i ] > first_max ) : NEW_LINE INDENT from = i NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT diff = first_max - v [ i ] NEW_LINE if ( diff < ans1 ) : NEW_LINE INDENT ans1 = diff NEW_LINE from_left = v [ i ] NEW_LINE DEDENT DEDENT DEDENT return first_right NEW_LINE diff1 = v [ 0 ] NEW_LINE diff1 = 3e18 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT diff = abs ( v [ i ] ) NEW_LINE if ( diff < ans1 ) : NEW_LINE INDENT print ( N , from_left ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( N , \" { } ▁ { } \" . format ( from_right ) ) NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT maxactual = N \/\/ 2 NEW_LINE ans1 = 3e18 NEW_LINE R = - 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT diff = abs ( v [ i ] - maxal ) NEW_LINE if ( diff < ans1 ) : NEW_LINE INDENT ans1 = diff NEW_LINE R = v [ i ] NEW_LINE DEDENT DEDENT print ( N , \" ▁ \" , R ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT v = [ 1 , 1 , 2 , 3 , 6 , 1 ] NEW_LINE n = len ( v ) NEW_LINE printMaxValPair ( v , n ) NEW_LINE DEDENT"],"references":["def printMaxValPair ( v , n ) : NEW_LINE INDENT v . sort ( ) NEW_LINE N = v [ n - 1 ] NEW_LINE if N % 2 == 1 : NEW_LINE INDENT first_maxima = N \/\/ 2 NEW_LINE second_maxima = first_maxima + 1 NEW_LINE ans1 , ans2 = 3 * ( 10 ** 18 ) , 3 * ( 10 ** 18 ) NEW_LINE from_left , from_right = - 1 , - 1 NEW_LINE _from = - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if v [ i ] > first_maxima : NEW_LINE INDENT _from = i NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT diff = first_maxima - v [ i ] NEW_LINE if diff < ans1 : NEW_LINE INDENT ans1 = diff NEW_LINE from_left = v [ i ] NEW_LINE DEDENT DEDENT DEDENT from_right = v [ _from ] NEW_LINE diff1 = first_maxima - from_left NEW_LINE diff2 = from_right - second_maxima NEW_LINE if diff1 < diff2 : NEW_LINE INDENT print ( N , from_left ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( N , from_right ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT maxima = N \/\/ 2 NEW_LINE ans1 = 3 * ( 10 ** 18 ) NEW_LINE R = - 1 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT diff = abs ( v [ i ] - maxima ) NEW_LINE if diff < ans1 : NEW_LINE INDENT ans1 = diff NEW_LINE R = v [ i ] NEW_LINE DEDENT DEDENT print ( N , R ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT v = [ 1 , 1 , 2 , 3 , 6 , 1 ] NEW_LINE n = len ( v ) NEW_LINE printMaxValPair ( v , n ) NEW_LINE DEDENT"],"bleu":0.6638499231293233,"rouge_l":0.8127081732001025}
{"id":901,"predictions":["import math NEW_LINE def triangle ( n ) : NEW_LINE INDENT k = 2 * n - 2 NEW_LINE ch = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( k ) : NEW_LINE INDENT print ( \" ▁ \" , end = \" \" ) NEW_LINE DEDENT k = k - 1 NEW_LINE for j in range ( i + 1 ) : NEW_LINE INDENT print ( chr ( 1 + 8 , end = \" ▁ \" ) , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT def maxHeight ( n ) : NEW_LINE INDENT return ( ( int ) ( math . sqrt ( 1 + 8.0 * n ) ) - 1 ) \/ 2 NEW_LINE DEDENT N = 9 NEW_LINE triangle ( N ) NEW_LINE"],"references":["from math import sqrt NEW_LINE def triangle ( n ) : NEW_LINE INDENT k = 2 * n - 2 ; NEW_LINE ch = 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( k ) : NEW_LINE INDENT print ( \" ▁ \" , end = \" \" ) ; NEW_LINE DEDENT k = k - 1 ; NEW_LINE for j in range ( i + 1 ) : NEW_LINE INDENT print ( ch , end = \" ▁ \" ) ; NEW_LINE ch += 1 ; NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT def maxHeight ( n ) : NEW_LINE INDENT ans = ( sqrt ( 1 + 8.0 * n ) - 1 ) \/\/ 2 ; NEW_LINE return int ( ans ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 9 ; NEW_LINE triangle ( maxHeight ( N ) ) ; NEW_LINE DEDENT"],"bleu":0.6189850955253248,"rouge_l":0.7791854256098838}
{"id":902,"predictions":["def longestInteger ( string , l ) : NEW_LINE INDENT count = 0 NEW_LINE max = 0 NEW_LINE max = 0 NEW_LINE pos = - 1 NEW_LINE length = 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT pre_pos = pos NEW_LINE pre_len = len ( string ) NEW_LINE count = 0 NEW_LINE length = 0 NEW_LINE if ( isDigit ( string [ i ] ) ) : NEW_LINE INDENT pos = i NEW_LINE DEDENT while ( count + 1 ) . count ( \" \" and length + 1 ) : NEW_LINE INDENT count = count + 1 NEW_LINE i += 1 NEW_LINE length += 1 NEW_LINE DEDENT if ( count > max ) : NEW_LINE INDENT max = count NEW_LINE DEDENT else : NEW_LINE INDENT pos = pre_pos NEW_LINE length = pre_len NEW_LINE DEDENT DEDENT return ( string [ pos : pos + length ] ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT string = \" geeks100for1234geeks \" NEW_LINE l = len ( string ) NEW_LINE print ( longestInteger ( string , l ) ) NEW_LINE DEDENT"],"references":["def longestInteger ( s , length ) : NEW_LINE INDENT count = 0 NEW_LINE maximum = 0 NEW_LINE pos = - 1 NEW_LINE l = 0 NEW_LINE for i in range ( length ) : NEW_LINE INDENT pre_pos = pos NEW_LINE pre_len = l NEW_LINE count = 0 NEW_LINE l = 0 NEW_LINE if ( s [ i ] . isdecimal ( ) ) : NEW_LINE INDENT pos = i NEW_LINE DEDENT while ( s [ i ] . isdecimal ( ) ) : NEW_LINE INDENT count += 1 NEW_LINE i += 1 NEW_LINE l += 1 NEW_LINE DEDENT if ( count > maximum ) : NEW_LINE INDENT maximum = count NEW_LINE DEDENT else : NEW_LINE INDENT pos = pre_pos NEW_LINE l = pre_len NEW_LINE DEDENT DEDENT return ( s [ pos : pos + l ] ) NEW_LINE DEDENT s = \" geeks100for1234geeks \" NEW_LINE length = len ( s ) NEW_LINE print ( longestInteger ( s , length ) ) NEW_LINE"],"bleu":0.5307061669030985,"rouge_l":0.7698248257675646}
{"id":903,"predictions":["def findSum ( n , a , b ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i % a == 0 or i % b == 0 ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT n = 10 NEW_LINE a = 3 NEW_LINE b = 5 NEW_LINE print ( findSum ( n , a , b ) ) NEW_LINE"],"references":["def findSum ( n , a , b ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( i % a == 0 or i % b == 0 ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE a = 3 NEW_LINE b = 5 NEW_LINE print ( findSum ( n , a , b ) ) NEW_LINE DEDENT"],"bleu":0.7518565104355958,"rouge_l":0.8787652011225445}
{"id":904,"predictions":["def seriesSum ( n ) : NEW_LINE INDENT return int ( ( n * ( n + 1 ) * ( n + 2 ) ) \/ 6 ) NEW_LINE DEDENT n = 4 NEW_LINE print ( seriesSum ( n ) ) NEW_LINE"],"references":["def seriesSum ( n ) : NEW_LINE INDENT return int ( ( n * ( n + 1 ) * ( n + 2 ) ) \/ 6 ) NEW_LINE DEDENT n = 4 NEW_LINE print ( seriesSum ( n ) ) NEW_LINE"],"bleu":1.0,"rouge_l":1.0}
{"id":905,"predictions":["def find_count ( ele ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( ele ) ) : NEW_LINE INDENT p = [ ] NEW_LINE c = 0 NEW_LINE j = len ( ele ) - 1 NEW_LINE while j >= 0 : NEW_LINE INDENT if ele [ j ] != p [ k ] : NEW_LINE INDENT break NEW_LINE DEDENT j -= 1 NEW_LINE DEDENT j -= 1 NEW_LINE k = len ( ele ) - 1 NEW_LINE while j >= 0 : NEW_LINE INDENT if ele [ j ] != p [ k ] : NEW_LINE INDENT break NEW_LINE DEDENT j -= 1 NEW_LINE k += 1 NEW_LINE if k == len ( p ) : NEW_LINE INDENT c += 1 NEW_LINE k = 0 NEW_LINE DEDENT DEDENT count = max ( count , c ) NEW_LINE DEDENT return count NEW_LINE DEDENT def solve ( n ) : NEW_LINE INDENT count = 1 NEW_LINE ele = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( count , end = \" , ▁ \" ) NEW_LINE ele . append ( count ) NEW_LINE count = 0 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 10 NEW_LINE solve ( n ) NEW_LINE DEDENT"],"references":["def find_count ( ele ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( ele ) ) : NEW_LINE INDENT p = [ ] NEW_LINE c = 0 NEW_LINE j = len ( ele ) - 1 NEW_LINE while j >= ( len ( ele ) - 1 - i ) and j >= 0 : NEW_LINE INDENT p . append ( ele [ j ] ) NEW_LINE j -= 1 NEW_LINE DEDENT j = len ( ele ) - 1 NEW_LINE k = 0 NEW_LINE while j >= 0 : NEW_LINE INDENT if ele [ j ] != p [ k ] : NEW_LINE INDENT break NEW_LINE DEDENT j -= 1 NEW_LINE k += 1 NEW_LINE if k == len ( p ) : NEW_LINE INDENT c += 1 NEW_LINE k = 0 NEW_LINE DEDENT DEDENT count = max ( count , c ) NEW_LINE DEDENT return count NEW_LINE DEDENT def solve ( n ) : NEW_LINE INDENT count = 1 NEW_LINE ele = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( count , end = \" ▁ \" ) NEW_LINE ele . append ( count ) NEW_LINE count = find_count ( ele ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 10 NEW_LINE solve ( n ) NEW_LINE DEDENT"],"bleu":0.8607735212594236,"rouge_l":0.9027023162710897}
{"id":906,"predictions":["import numpy as np NEW_LINE def getMinimumOps ( ar , k ) : NEW_LINE INDENT n = len ( ar ) NEW_LINE dp = np . zeros ( ( k + 1 , n + 1 ) ) ; NEW_LINE dp [ 0 ] [ 1 ] = 0 ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT maxGroups = min ( k , i + 1 ) ; NEW_LINE if ( j == 1 ) : NEW_LINE INDENT freq = sys . maxsize ; NEW_LINE if ( j == 1 ) : NEW_LINE INDENT freq = np . maxsize ; NEW_LINE DEDENT DEDENT dp [ i ] [ 1 ] = ( i + 1 ) - freqOfWindow ; NEW_LINE DEDENT else : NEW_LINE INDENT freq = [ 0 ] * 100000 ; NEW_LINE freq = 0 ; NEW_LINE for it in range ( i , j - 1 , 1 ) : NEW_LINE INDENT freq [ ar [ it ] ] += 1 ; NEW_LINE newElement = freq [ ar [ it ] ] ] ; NEW_LINE if ( newElementFreq > freqOfWindow ) : NEW_LINE INDENT freqOfWindow = newElement ; NEW_LINE DEDENT DEDENT dp [ i ] [ 1 ] = ( i + 1 ) - freqOfMode ; NEW_LINE DEDENT else : NEW_LINE INDENT freq = [ 0 ] * 100000 ; NEW_LINE freq = 0 ; NEW_LINE for it in range ( i , j - 1 , 1 ) : NEW_LINE INDENT freq [ ar [ it ] ] += 1 ; NEW_LINE newElement = freq [ int ( it - 1 ] [ j - 1 ] + elementsToChange , dp [ i ] [ j ] ) ; NEW_LINE DEDENT DEDENT DEDENT return dp [ n - 1 ] [ k ] ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT k = 3 ; NEW_LINE ar = [ 3 , 1 , 3 , 3 , 2 , 8 , 5 ] ; NEW_LINE print ( getMinimumOps ( ar , k ) ) ; NEW_LINE D"],"references":["def getMinimumOps ( ar , k ) : NEW_LINE INDENT n = len ( ar ) NEW_LINE dp = [ [ 0 for i in range ( k + 1 ) ] for i in range ( n ) ] NEW_LINE dp [ 0 ] [ 1 ] = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT maxGroups = min ( k , i + 1 ) NEW_LINE for j in range ( 1 , maxGroups + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = 10 ** 9 NEW_LINE if ( j == 1 ) : NEW_LINE INDENT freq1 = dict ( ) NEW_LINE freqOfMode = 0 NEW_LINE for it in range ( 0 , i + 1 ) : NEW_LINE INDENT freq1 [ ar [ it ] ] = freq1 . get ( ar [ it ] , 0 ) + 1 NEW_LINE newElementFreq = freq1 [ ar [ it ] ] NEW_LINE if ( newElementFreq > freqOfMode ) : NEW_LINE INDENT freqOfMode = newElementFreq NEW_LINE DEDENT DEDENT dp [ i ] [ 1 ] = ( i + 1 ) - freqOfMode NEW_LINE DEDENT else : NEW_LINE INDENT freq = dict ( ) NEW_LINE freqOfMode = 0 NEW_LINE for it in range ( i , j - 2 , - 1 ) : NEW_LINE INDENT freq [ ar [ it ] ] = freq . get ( ar [ it ] , 0 ) + 1 NEW_LINE newElementFreq = freq [ ar [ it ] ] NEW_LINE if ( newElementFreq > freqOfMode ) : NEW_LINE INDENT freqOfMode = newElementFreq NEW_LINE DEDENT elementsToChange = i - it + 1 NEW_LINE elementsToChange -= freqOfMode NEW_LINE dp [ i ] [ j ] = min ( dp [ it - 1 ] [ j - 1 ] + elementsToChange , dp [ i ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return dp [ n - 1 ] [ k ] NEW_LINE DEDENT k = 3 NEW_LINE ar = [ 3 , 1 , 3 , 3 , 2 , 1 , 8 , 5 ] NEW_LINE print ( getMinimumOps ( ar , k ) ) NEW_LINE"],"bleu":0.5639872793899275,"rouge_l":0.6764334655607644}
{"id":907,"predictions":["def findCount ( N ) : NEW_LINE INDENT list = [ ] NEW_LINE sum = 0 NEW_LINE for i in range ( 20 ) : NEW_LINE INDENT sum += pow ( 2 , i ) NEW_LINE list . append ( sum ) NEW_LINE DEDENT for i in range ( 20 ) : NEW_LINE INDENT if ( list [ i ] > N ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 10 NEW_LINE print ( findCount ( N ) ) NEW_LINE DEDENT"],"references":["def findCount ( N ) : NEW_LINE INDENT list = [ ] NEW_LINE sum = 0 NEW_LINE for i in range ( 0 , 20 ) : NEW_LINE INDENT sum += 2 ** i NEW_LINE list . append ( sum ) NEW_LINE DEDENT for value in list : NEW_LINE INDENT if ( value > N ) : NEW_LINE INDENT return ( list . index ( value ) + 1 ) NEW_LINE DEDENT DEDENT DEDENT N = 10 NEW_LINE print ( findCount ( N ) ) NEW_LINE"],"bleu":0.5858282167461539,"rouge_l":0.7596513075965131}
{"id":908,"predictions":["import sys NEW_LINE def buyy ( n ) : NEW_LINE INDENT x1 = 0 NEW_LINE y1 = 1 NEW_LINE x2 = 1 NEW_LINE y2 = n NEW_LINE print ( \" % .0f \" % ( x1 , y1 , x2 ) ) NEW_LINE x , y = 0 , 0.0 NEW_LINE while ( y > 1.0 ) : NEW_LINE INDENT x = math . floor ( ( y1 + n ) \/ y2 ) * x2 - x1 NEW_LINE y = floor ( ( y1 + n ) \/ y2 ) * y2 - y1 ) NEW_LINE print ( \" { } \" . format ( x , y ) , \"0f \" ) NEW_LINE x1 = x2 NEW_LINE y1 = y2 NEW_LINE y1 = y2 NEW_LINE y2 = y2 NEW_LINE DEDENT DEDENT n = 7 NEW_LINE print ( \" Farey ▁ Sequence ▁ of ▁ order \" , n , \" ▁ is \" ) NEW_LINE"],"references":["import math NEW_LINE def farey ( n ) : NEW_LINE INDENT x1 = 0 ; NEW_LINE y1 = 1 ; NEW_LINE x2 = 1 ; NEW_LINE y2 = n ; NEW_LINE print ( x1 , end = \" \" ) NEW_LINE print ( \" \/ \" , end = \" \" ) NEW_LINE print ( y1 , x2 , end = \" \" ) NEW_LINE print ( \" \/ \" , end = \" \" ) NEW_LINE print ( y2 , end = \" ▁ \" ) ; NEW_LINE x = 0 ; NEW_LINE y = 0 ; NEW_LINE while ( y != 1.0 ) : NEW_LINE INDENT x = math . floor ( ( y1 + n ) \/ y2 ) * x2 - x1 ; NEW_LINE y = math . floor ( ( y1 + n ) \/ y2 ) * y2 - y1 ; NEW_LINE print ( x , end = \" \" ) NEW_LINE print ( \" \/ \" , end = \" \" ) NEW_LINE print ( y , end = \" ▁ \" ) ; NEW_LINE x1 = x2 ; NEW_LINE x2 = x ; NEW_LINE y1 = y2 ; NEW_LINE y2 = y ; NEW_LINE DEDENT DEDENT n = 7 ; NEW_LINE print ( \" Farey ▁ Sequence ▁ of ▁ order \" , n , \" is \" ) ; NEW_LINE farey ( n ) ; NEW_LINE"],"bleu":0.3737770604013581,"rouge_l":0.6649172385950748}
{"id":909,"predictions":["def lens_length ( array_length , array_length ) : NEW_LINE INDENT return 1 \/ ( ( ( 1 \/ array_length ) + ( 1 \/ array_length ) ) ) ; NEW_LINE DEDENT array_length = 2 ; NEW_LINE angle_length = 50 ; NEW_LINE print ( \" Foidal ▁ length ▁ of ▁ a ▁ lens ▁ is \" , end = \" \" ) ; NEW_LINE"],"references":["def focal_length ( image_distance , object_distance ) NEW_LINE INDENT : return 1 \/ ( ( 1 \/ image_distance ) + ( 1 \/ object_distance ) ) NEW_LINE DEDENT image_distance = 2 NEW_LINE object_distance = 50 NEW_LINE result = focal_length ( image_distance , object_distance ) NEW_LINE print ( \" Focal ▁ length ▁ of ▁ a ▁ lens ▁ is ▁ \" , result , \" ▁ units . \" ) NEW_LINE"],"bleu":0.3583391072664205,"rouge_l":0.6898460057747835}
{"id":910,"predictions":["def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def findModuloByM ( X , N , M ) : NEW_LINE INDENT if ( N < 6 ) : NEW_LINE INDENT temp = \" \" NEW_LINE for i in range ( N ) : NEW_LINE INDENT temp = temp + chr ( X + 48 ) NEW_LINE DEDENT res = ( temp ) % M NEW_LINE return res NEW_LINE DEDENT if ( N % 2 == 0 ) : NEW_LINE INDENT half = findModuloByM ( X , N \/\/ 2 , M ) % M NEW_LINE res = ( half * power ( 10 , N \/\/ 2 , M ) + half ) % M NEW_LINE return res NEW_LINE DEDENT else : NEW_LINE INDENT half = findModuloByM ( X , N \/\/ 2 , M ) % M NEW_LINE res = ( half * power ( 10 , N \/\/ 2 + 1 , M ) + half ) % M NEW_LINE return res NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT X = 6 NEW_LINE N = 14 NEW_LINE M = 9 NEW_LINE print ( findModuloByM ( X , N , M ) ) NEW_LINE DEDENT"],"references":["def power ( x , y , p ) : NEW_LINE INDENT res = 1 ; NEW_LINE x = x % p ; NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y and 1 ) : NEW_LINE INDENT res = ( res * x ) % p ; NEW_LINE DEDENT y = y >> 1 ; NEW_LINE x = ( x * x ) % p ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT def findModuloByM ( X , N , M ) : NEW_LINE INDENT if ( N < 6 ) : NEW_LINE INDENT temp = chr ( 48 + X ) * N NEW_LINE res = int ( temp ) % M ; NEW_LINE return res ; NEW_LINE DEDENT if ( N % 2 == 0 ) : NEW_LINE INDENT half = findModuloByM ( X , N \/\/ 2 , M ) % M ; NEW_LINE res = ( half * power ( 10 , N \/\/ 2 , M ) + half ) % M ; NEW_LINE return res ; NEW_LINE DEDENT else : NEW_LINE INDENT half = findModuloByM ( X , N \/\/ 2 , M ) % M ; NEW_LINE res = ( half * power ( 10 , N \/\/ 2 + 1 , M ) + half * 10 + X ) % M ; NEW_LINE return res ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT X = 6 ; N = 14 ; M = 9 ; NEW_LINE print ( findModuloByM ( X , N , M ) ) ; NEW_LINE DEDENT"],"bleu":0.7617623322526349,"rouge_l":0.9042231364956439}
{"id":911,"predictions":["def getTotalXorOfSubarrayXors ( arr , N ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i , N + 1 ) : NEW_LINE INDENT res = res ^ arr [ k ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 5 , 2 , 4 , 6 ] NEW_LINE N = len ( arr ) NEW_LINE print ( getTotalXorOfSubarrayXors ( arr , N ) ) NEW_LINE DEDENT"],"references":["def getTotalXorOfSubarrayXors ( arr , N ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( i , N ) : NEW_LINE INDENT for k in range ( i , j + 1 ) : NEW_LINE INDENT res = res ^ arr [ k ] NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT arr = [ 3 , 5 , 2 , 4 , 6 ] NEW_LINE N = len ( arr ) NEW_LINE print ( getTotalXorOfSubarrayXors ( arr , N ) ) NEW_LINE"],"bleu":0.8148284118472603,"rouge_l":0.8520119720651812}
{"id":912,"predictions":["def innerCirclearea ( radius ) : NEW_LINE INDENT if ( radius < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT r = radius \/ 2 NEW_LINE Area = ( 3.14 * pow ( r , 2 ) ) NEW_LINE return Area NEW_LINE DEDENT radius = 4 NEW_LINE print ( \" Area ▁ of ▁ circle ▁ c2 ▁ = ▁ \" , round ( innerCirclearea ( radius ) , 2 ) ) NEW_LINE"],"references":["def innerCirclearea ( radius ) : NEW_LINE INDENT if ( radius < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT r = radius \/ 2 ; NEW_LINE Area = ( 3.14 * pow ( r , 2 ) ) ; NEW_LINE return Area ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT radius = 4 ; NEW_LINE print ( \" Area ▁ of ▁ circle ▁ c2 ▁ = \" , innerCirclearea ( radius ) ) ; NEW_LINE DEDENT"],"bleu":0.6105852030937864,"rouge_l":0.828706438275251}
{"id":913,"predictions":["if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT P = 1 NEW_LINE R = 1 NEW_LINE T = 1 NEW_LINE S = 1 NEW_LINE Index = ( P * T * R ) \/ 100 NEW_LINE print ( \" Small ▁ person ▁ = ▁ \" , SI ) NEW_LINE DEDENT"],"references":["P = 1 NEW_LINE R = 1 NEW_LINE T = 1 NEW_LINE SI = ( P * R * T ) \/ 100 NEW_LINE print ( \" simple ▁ interest ▁ is \" , SI ) NEW_LINE"],"bleu":0.4311941809503208,"rouge_l":0.6921669106881406}
{"id":914,"predictions":["def findSubArr ( arr , n ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT if ( abs ( arr [ i ] - arr [ i + 1 ] ) >= 2 ) : NEW_LINE INDENT print ( arr [ i ] , \" \" , arr [ i + 1 ] ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( - 1 ) NEW_LINE DEDENT arr = [ 1 , 2 , 4 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE findSubArr ( arr , n ) NEW_LINE"],"references":["def findSubArr ( arr , n ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT if ( abs ( arr [ i ] - arr [ i + 1 ] ) >= 2 ) : NEW_LINE INDENT print ( arr [ i ] , arr [ i + 1 ] , end = \" \" ) ; NEW_LINE return ; NEW_LINE DEDENT DEDENT print ( - 1 ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 6 , 7 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE findSubArr ( arr , n ) ; NEW_LINE DEDENT"],"bleu":0.697957967229193,"rouge_l":0.8597727599597296}
{"id":915,"predictions":["import math NEW_LINE def Min_glass ( n , k , a ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT ans = ceil ( sum \/ 100 ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 NEW_LINE k = 3 NEW_LINE a = [ 200 , 150 , 140 , 300 ] NEW_LINE print ( Min_glass ( n , k , a ) ) NEW_LINE DEDENT"],"references":["from math import ceil NEW_LINE def Min_glass ( n , k , a ) : NEW_LINE INDENT a . sort ( ) NEW_LINE return ceil ( sum ( a [ : k ] ) \/ 100 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n , k = 4 , 3 NEW_LINE a = [ 200 , 150 , 140 , 300 ] NEW_LINE print ( Min_glass ( n , k , a ) ) NEW_LINE DEDENT"],"bleu":0.6296858069889946,"rouge_l":0.7708791208791209}
{"id":916,"predictions":["import math NEW_LINE def findModulo ( s ) : NEW_LINE INDENT l = len ( s ) ; NEW_LINE modulus = 0 ; NEW_LINE if ( s . find ( \" + \" ) ) : NEW_LINE INDENT i = s . find ( \" + \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT i = s . find ( \" - \" ) ; NEW_LINE DEDENT real = s [ : i ] ; NEW_LINE imaginary = s [ i + 1 : l - 1 ] ; NEW_LINE x = int ( real ) ; NEW_LINE y = int ( imaginary ) ; NEW_LINE print ( sqrt ( x * x + y * y ) ) ) ; NEW_LINE DEDENT s = \"3 + 4i \" ; NEW_LINE findModulo ( s ) ; NEW_LINE"],"references":["from math import sqrt NEW_LINE def findModulo ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE modulus = 0 NEW_LINE if ( ' + ' in s ) : NEW_LINE INDENT i = s . index ( ' + ' ) NEW_LINE DEDENT else : NEW_LINE INDENT i = s . index ( ' - ' ) NEW_LINE DEDENT real = s [ 0 : i ] NEW_LINE imaginary = s [ i + 1 : l - 1 ] NEW_LINE x = int ( real ) NEW_LINE y = int ( imaginary ) NEW_LINE print ( int ( sqrt ( x * x + y * y ) ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \"3 + 4i \" NEW_LINE findModulo ( s ) NEW_LINE DEDENT"],"bleu":0.59031590695523,"rouge_l":0.8016980693184461}
{"id":917,"predictions":["def printRepeating ( arr , size ) : NEW_LINE INDENT print ( \" The ▁ repeating ▁ elements ▁ are : ▁ \" ) NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT if arr [ abs ( arr [ i ] ) ] > 0 : NEW_LINE INDENT arr [ abs ( arr [ i ] ) ] = - arr [ abs ( arr [ i ] ) ] NEW_LINE DEDENT else : NEW_LINE INDENT print ( abs ( arr [ i ] ) , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 4 , 2 , 4 , 5 , 2 , 3 , 1 ] NEW_LINE_size = len ( arr ) NEW_LINE printRepeating ( arr , arr_size ) NEW_LINE"],"references":["def printRepeating ( arr , size ) : NEW_LINE INDENT print ( \" ▁ The ▁ repeating ▁ elements ▁ are \" , end = \" ▁ \" ) NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT if ( arr [ abs ( arr [ i ] ) ] > 0 ) : NEW_LINE INDENT arr [ abs ( arr [ i ] ) ] = ( - 1 ) * arr [ abs ( arr [ i ] ) ] NEW_LINE DEDENT else : NEW_LINE INDENT print ( abs ( arr [ i ] ) , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 4 , 2 , 4 , 5 , 2 , 3 , 1 ] NEW_LINE arr_size = len ( arr ) NEW_LINE printRepeating ( arr , arr_size ) NEW_LINE"],"bleu":0.829609758657778,"rouge_l":0.9347006129184346}
{"id":918,"predictions":["def countZeros ( x ) : NEW_LINE INDENT y = 32 NEW_LINE y = x >> 16 NEW_LINE if ( y ) : NEW_LINE INDENT n = n - 16 NEW_LINE x = y NEW_LINE DEDENT y = x >> 8 NEW_LINE if ( y ) : NEW_LINE INDENT n = n - 8 NEW_LINE x = y NEW_LINE DEDENT y = x >> 4 NEW_LINE if ( y ) : NEW_LINE INDENT n = n - 4 NEW_LINE x = y NEW_LINE DEDENT y = x >> 2 NEW_LINE if ( y ) : NEW_LINE INDENT n = n - 2 NEW_LINE x = y NEW_LINE DEDENT y = x >> 1 NEW_LINE if ( y ) : NEW_LINE INDENT return n - 2 NEW_LINE DEDENT return n - x NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = 101 NEW_LINE print ( countZeros ( x ) ) NEW_LINE DEDENT"],"references":["def countZeros ( x ) : NEW_LINE INDENT n = 32 ; NEW_LINE y = x >> 16 ; NEW_LINE if ( y != 0 ) : NEW_LINE INDENT n = n - 16 ; NEW_LINE x = y ; NEW_LINE DEDENT y = x >> 8 ; NEW_LINE if ( y != 0 ) : NEW_LINE INDENT n = n - 8 ; NEW_LINE x = y ; NEW_LINE DEDENT y = x >> 4 ; NEW_LINE if ( y != 0 ) : NEW_LINE INDENT n = n - 4 ; NEW_LINE x = y ; NEW_LINE DEDENT y = x >> 2 ; NEW_LINE if ( y != 0 ) : NEW_LINE INDENT n = n - 2 ; NEW_LINE x = y ; NEW_LINE DEDENT y = x >> 1 ; NEW_LINE if ( y != 0 ) : NEW_LINE INDENT return n - 2 ; NEW_LINE DEDENT return n - x ; NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT x = 101 ; NEW_LINE print ( countZeros ( x ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"bleu":0.5660033939153598,"rouge_l":0.8186075835359812}
{"id":919,"predictions":["def pairORSum ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , 32 ) : NEW_LINE INDENT k1 = 0 NEW_LINE k0 = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ j ] & ( 1 << i ) ) : NEW_LINE INDENT k1 = k1 + 1 NEW_LINE DEDENT else : NEW_LINE INDENT k0 += 1 NEW_LINE DEDENT DEDENT ans = ans + ( ( 1 << i ) * ( k1 - 1 ) \/\/ 2 ) + ( 1 << i ) * ( k1 * k0 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( pairORSum ( arr , n ) ) NEW_LINE"],"references":["def pairORSum ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , 32 ) : NEW_LINE INDENT k1 = 0 NEW_LINE k0 = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( ( arr [ j ] & ( 1 << i ) ) ) : NEW_LINE INDENT k1 = k1 + 1 NEW_LINE DEDENT else : NEW_LINE INDENT k0 = k0 + 1 NEW_LINE DEDENT DEDENT ans = ans + ( 1 << i ) * ( k1 * ( k1 - 1 ) \/\/ 2 ) + ( 1 << i ) * ( k1 * k0 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( pairORSum ( arr , n ) ) NEW_LINE"],"bleu":0.9274340544783539,"rouge_l":0.9626972740315638}
{"id":920,"predictions":["def binaryToDecimal ( n ) : NEW_LINE INDENT num = n ; NEW_LINE dec_value = 0 ; NEW_LINE base = 1 ; NEW_LINE l = len ( num ) ; NEW_LINE for i in range ( l - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( num [ i ] == '1' ) : NEW_LINE INDENT dec_value += base ; NEW_LINE DEDENT base = base * 2 ; NEW_LINE DEDENT return dec_value ; NEW_LINE DEDENT num = \"10101001\" ; NEW_LINE print ( binaryToDecimal ( num ) ) ; NEW_LINE"],"references":["def binaryToDecimal ( n ) : NEW_LINE INDENT num = n ; NEW_LINE dec_value = 0 ; NEW_LINE base1 = 1 ; NEW_LINE len1 = len ( num ) ; NEW_LINE for i in range ( len1 - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( num [ i ] == '1' ) : NEW_LINE INDENT dec_value += base1 ; NEW_LINE DEDENT base1 = base1 * 2 ; NEW_LINE DEDENT return dec_value ; NEW_LINE DEDENT num = \"10101001\" ; NEW_LINE print ( binaryToDecimal ( num ) ) ; NEW_LINE"],"bleu":0.8443029644450811,"rouge_l":0.9361702127659575}
{"id":921,"predictions":["def countStrings ( n , k ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE dp [ 1 ] [ 0 ] = 1 NEW_LINE dp [ 1 ] [ 0 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT j = 0 NEW_LINE while ( j < k and 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j ] ) NEW_LINE dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ] NEW_LINE if ( j - 1 >= 0 ) : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i - 1 ] [ j - 1 ] [ 1 ] NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE k = 2 NEW_LINE print ( countStrings ( n , k ) ) NEW_LINE DEDENT"],"references":["def countStrings ( n , k ) : NEW_LINE INDENT dp = [ [ [ 0 , 0 ] for __ in range ( k + 1 ) ] for _ in range ( n + 1 ) ] NEW_LINE dp [ 1 ] [ 0 ] [ 0 ] = 1 NEW_LINE dp [ 1 ] [ 0 ] [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( k + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] [ 0 ] = ( dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] ) NEW_LINE dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ] NEW_LINE if j >= 1 : NEW_LINE INDENT dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] [ 1 ] NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE k = 2 NEW_LINE print ( countStrings ( n , k ) ) NEW_LINE DEDENT"],"bleu":0.8317736667040344,"rouge_l":0.9051184317996189}
{"id":922,"predictions":["import sys NEW_LINE def print2largest ( arr , arr_size ) : NEW_LINE INDENT if ( arr_size < 2 ) : NEW_LINE INDENT print ( \" ▁ Invalid ▁ Input ▁ \" ) NEW_LINE return NEW_LINE DEDENT first = - sys . maxsize - 1 NEW_LINE for i in range ( 0 , arr_size ) : NEW_LINE INDENT if ( arr [ i ] > first ) : NEW_LINE INDENT second = first NEW_LINE first = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > second and arr [ i ] != first ) : NEW_LINE INDENT second = arr [ i ] NEW_LINE DEDENT DEDENT if ( second == - 1 ) : NEW_LINE INDENT print ( \" There ▁ is ▁ no ▁ second ▁ largest \" , \" element \" , \" is \" , second ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" The ▁ second ▁ largest ▁ element \" , \" is \" , second ) NEW_LINE DEDENT DEDENT arr = [ 12 , 35 , 1 , 10 , 34 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print2largest ( arr , n ) NEW_LINE"],"references":["def print2largest ( arr , arr_size ) : NEW_LINE INDENT if ( arr_size < 2 ) : NEW_LINE INDENT print ( \" ▁ Invalid ▁ Input ▁ \" ) NEW_LINE return NEW_LINE DEDENT first = second = - 2147483648 NEW_LINE for i in range ( arr_size ) : NEW_LINE INDENT if ( arr [ i ] > first ) : NEW_LINE INDENT second = first NEW_LINE first = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > second and arr [ i ] != first ) : NEW_LINE INDENT second = arr [ i ] NEW_LINE DEDENT DEDENT if ( second == - 2147483648 ) : NEW_LINE INDENT print ( \" There ▁ is ▁ no ▁ second ▁ largest ▁ element \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" The ▁ second ▁ largest ▁ element ▁ is \" , second ) NEW_LINE DEDENT DEDENT arr = [ 12 , 35 , 1 , 10 , 34 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print2largest ( arr , n ) NEW_LINE"],"bleu":0.8412042131150754,"rouge_l":0.9317397307559543}
{"id":923,"predictions":["from math import gcd as __gcd NEW_LINE def print_gcd ( a , b ) : NEW_LINE INDENT max_gcd = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT max_gcd = gcd ( max_gcd , arr [ i ] ) ; NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT query [ i ] [ 0 ] -= 1 ; NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT query [ i ] [ 0 ] -= 1 ; NEW_LINE arr [ query [ i ] [ 0 ] ] = \/\/ query [ i ] [ 1 ] ] \/\/= query [ i ] [ 1 ] ; NEW_LINE max_gcd = gcd ( arr [ query [ i ] [ 0 ] ] , max_gcd ) ; NEW_LINE print ( max_gcd ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 ; NEW_LINE m = 3 ; NEW_LINE query = [ [ 36 , 24 , 72 ] , [ 0 ] , 1 ] ; NEW_LINE query [ 0 ] [ 1 ] = 1 ; NEW_LINE query [ 1 ] [ 0 ] = 2 ; NEW_LINE query [ 2 ] [ 1 ] = 2 ; NEW_LINE query [ 1 ] [ 0 ] = 2 ; NEW_LINE query [ 2 ] [ 1 ] = 4 ; NEW_LINE query [ 2 ] [ 1 ] = 2 ; NEW_LINE query [ 2 ] [ 0 ] = 2 ; NEW_LINE query [ 2 ] [ 1 ] = 2 ; NEW_LINE query [ 2 ] [ 1 ] = 4 ; NEW_LINE print_gcd [ 2 ] [ 1 ] = 2 ; NEW_LINE DEDENT"],"references":["def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def print_gcd_online ( n , m , query , arr ) : NEW_LINE INDENT max_gcd = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT max_gcd = gcd ( max_gcd , arr [ i ] ) NEW_LINE DEDENT for i in range ( 0 , m ) : NEW_LINE INDENT query [ i ] [ 0 ] -= 1 NEW_LINE arr [ query [ i ] [ 0 ] ] \/\/= query [ i ] [ 1 ] NEW_LINE max_gcd = gcd ( arr [ query [ i ] [ 0 ] ] , max_gcd ) NEW_LINE print ( max_gcd ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n , m = 3 , 3 NEW_LINE query = [ [ 1 , 3 ] , [ 3 , 12 ] , [ 2 , 4 ] ] NEW_LINE arr = [ 36 , 24 , 72 ] NEW_LINE print_gcd_online ( n , m , query , arr ) NEW_LINE DEDENT"],"bleu":0.403858953500823,"rouge_l":0.5816936404539655}
{"id":924,"predictions":["def countSubstr ( str , n , x , y ) : NEW_LINE INDENT tot_count = 0 NEW_LINE count_x = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str [ i ] == x ) : NEW_LINE INDENT count_x += 1 NEW_LINE DEDENT if ( str [ i ] == y ) : NEW_LINE INDENT tot_count += count_x NEW_LINE DEDENT DEDENT return tot_count NEW_LINE DEDENT str = \" abbcce chcak \" NEW_LINE n = len ( str ) NEW_LINE x = ' a ' NEW_LINE y = ' c ' NEW_LINE print ( \" Count ▁ = ▁ \" , countSubstr ( str , n , x , y ) ) NEW_LINE"],"references":["def countSubstr ( str , n , x , y ) : NEW_LINE INDENT tot_count = 0 NEW_LINE count_x = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if str [ i ] == x : NEW_LINE INDENT count_x += 1 NEW_LINE DEDENT if str [ i ] == y : NEW_LINE INDENT tot_count += count_x NEW_LINE DEDENT DEDENT return tot_count NEW_LINE DEDENT str = ' abbcaceghcak ' NEW_LINE n = len ( str ) NEW_LINE x , y = ' a ' , ' c ' NEW_LINE print ( ' Count ▁ = ' , countSubstr ( str , n , x , y ) ) NEW_LINE"],"bleu":0.7700247935576993,"rouge_l":0.9086221712976226}
{"id":925,"predictions":["def centered_cube ( n ) : NEW_LINE INDENT return ( 2 * n + 1 ) * ( n * n + n + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE print ( n , \" th ▁ Centered ▁ cube ▁ number : ▁ \" , centered_cube ( n ) ) NEW_LINE n = 10 NEW_LINE print ( centered_cube ( n ) ) NEW_LINE DEDENT"],"references":["def centered_cube ( n ) : NEW_LINE INDENT return ( 2 * n + 1 ) * ( n * n + n + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE print ( n , \" th ▁ Centered ▁ cube ▁ \" + \" number ▁ : ▁ \" , centered_cube ( n ) ) NEW_LINE n = 10 NEW_LINE print ( n , \" th ▁ Centered ▁ cube ▁ \" + \" number ▁ : ▁ \" , centered_cube ( n ) ) NEW_LINE DEDENT"],"bleu":0.7229550498777313,"rouge_l":0.8603667136812412}
{"id":926,"predictions":["import math NEW_LINE MAX = 10000 ; NEW_LINE primes = [ ] ; NEW_LINE def sieveSundaram ( ) : NEW_LINE INDENT marked = [ False ] * int ( math . sqrt ( MAX ) - 1 ) ; NEW_LINE for i in range ( 1 , ( int ( math . sqrt ( MAX ) - 1 ) \/ 2 ) + 1 ) : NEW_LINE INDENT for j in range ( ( i * ( i + 1 ) ) << 1 , ( MAX \/ 2 ) + 1 , 2 * i + 1 ) ) : NEW_LINE INDENT marked [ j ] = True ; NEW_LINE DEDENT DEDENT primes . append ( 2 ) ; NEW_LINE for i in range ( 1 , int ( MAX \/ 2 ) + 1 ) : NEW_LINE INDENT if ( marked [ i ] == False ) : NEW_LINE INDENT primes . append ( 2 * i + 1 ) ; NEW_LINE DEDENT DEDENT DEDENT def findPrimes ( n ) : NEW_LINE INDENT if ( n <= 2 or n % 2 != 0 ) : NEW_LINE INDENT print ( \" Invalid ▁ Input ▁ \" ) ; NEW_LINE return ; NEW_LINE DEDENT for i in range ( 0 , int ( n \/ 2 ) ) : NEW_LINE INDENT diff = n - primes [ i ] ; NEW_LINE if ( diff in primes ) : NEW_LINE INDENT print ( primes [ i ] , \" + \" , diff , \" = \" , n ) ; NEW_LINE return ; NEW_LINE DEDENT DEDENT sieveSundaram ( ) ; NEW_LINE findPrimes ( 4 ) ; NEW_LINE findPrimes ( 38 ) ; NEW_LINE findPrimes ( 38 ) ; NEW_LINE"],"references":["import math NEW_LINE MAX = 10000 ; NEW_LINE primes = [ ] ; NEW_LINE def sieveSundaram ( ) : NEW_LINE INDENT marked = [ False ] * ( int ( MAX \/ 2 ) + 100 ) ; NEW_LINE for i in range ( 1 , int ( ( math . sqrt ( MAX ) - 1 ) \/ 2 ) + 1 ) : NEW_LINE INDENT for j in range ( ( i * ( i + 1 ) ) << 1 , int ( MAX \/ 2 ) + 1 , 2 * i + 1 ) : NEW_LINE INDENT marked [ j ] = True ; NEW_LINE DEDENT DEDENT primes . append ( 2 ) ; NEW_LINE for i in range ( 1 , int ( MAX \/ 2 ) + 1 ) : NEW_LINE INDENT if ( marked [ i ] == False ) : NEW_LINE INDENT primes . append ( 2 * i + 1 ) ; NEW_LINE DEDENT DEDENT DEDENT def findPrimes ( n ) : NEW_LINE INDENT if ( n <= 2 or n % 2 != 0 ) : NEW_LINE INDENT print ( \" Invalid ▁ Input \" ) ; NEW_LINE return ; NEW_LINE DEDENT i = 0 ; NEW_LINE while ( primes [ i ] <= n \/\/ 2 ) : NEW_LINE INDENT diff = n - primes [ i ] ; NEW_LINE if diff in primes : NEW_LINE INDENT print ( primes [ i ] , \" + \" , diff , \" = \" , n ) ; NEW_LINE return ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT DEDENT sieveSundaram ( ) ; NEW_LINE findPrimes ( 4 ) ; NEW_LINE findPrimes ( 38 ) ; NEW_LINE findPrimes ( 100 ) ; NEW_LINE"],"bleu":0.8609908314681456,"rouge_l":0.9235168778737244}
{"id":927,"predictions":["N = 100005 NEW_LINE d = [ 0 for i in range ( N ) ] NEW_LINE pre = [ 0 for i in range ( N ) ] NEW_LINE def Positive_Divisors ( ) : NEW_LINE INDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT if ( j * j == i ) : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT d [ i ] += 2 NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT if ( d [ i ] == d [ i - 1 ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT pre [ i ] = ans NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT Positive_Divisors ( ) NEW_LINE n = 15 NEW_LINE print ( pre [ n ] ) NEW_LINE DEDENT"],"references":["from math import sqrt ; NEW_LINE N = 100005 NEW_LINE d = [ 0 ] * N NEW_LINE pre = [ 0 ] * N NEW_LINE def Positive_Divisors ( ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( 1 , int ( sqrt ( i ) ) + 1 ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT if ( j * j == i ) : NEW_LINE INDENT d [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ i ] += 2 NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT if ( d [ i ] == d [ i - 1 ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT pre [ i ] = ans NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT Positive_Divisors ( ) NEW_LINE n = 15 NEW_LINE print ( pre [ n ] ) NEW_LINE DEDENT"],"bleu":0.7483764311635102,"rouge_l":0.8369244935543279}
{"id":928,"predictions":["defLeibncm ( n ) : NEW_LINE INDENT C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( 0 , min ( i , n ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) ; NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( \"1 \/ \" , i * C [ i - 1 ] [ j - 1 ] , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( \" \\n \" + i * C [ i - 1 ] [ j - 1 ] ) , end = \" \" ) ; NEW_LINE DEDENT DEDENT n = 4 ; NEW_LINE LeibnaphonicTriangle ( n ) ; NEW_LINE"],"references":["def LeibnizHarmonicTriangle ( n ) : NEW_LINE INDENT C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] ; NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , min ( i , n ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) ; NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( \"1 \/ \" , end = \" \" ) ; NEW_LINE print ( i * C [ i - 1 ] [ j - 1 ] , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( ) ; NEW_LINE DEDENT DEDENT LeibnizHarmonicTriangle ( 4 ) ; NEW_LINE"],"bleu":0.8534854682191612,"rouge_l":0.9122266476290674}
{"id":929,"predictions":["def ansQueries ( precompven , pref , l , r ) : NEW_LINE INDENT if ( ( r - l + 1 ) % 2 == 0 ) : NEW_LINE INDENT print ( \"0\" ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( l % 2 == 0 ) : NEW_LINE INDENT print ( precompvender [ l - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( prefodd [ r ] ^ pref [ l - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT def wrapper ( arr , n , l , r , q ) : NEW_LINE INDENT prefodd = [ 0 ] * 100 NEW_LINE preEle = [ 0 ] * 100 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i ) % 2 == 0 ) : NEW_LINE INDENT prefeven [ i ] = arr [ i - 1 ] ^ pref [ i - 1 ] NEW_LINE prefodd [ i ] = prefodd [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT preFreven [ i ] = pref [ i - 1 ] NEW_LINE prefodd [ i ] = prefodd [ i - 1 ] ^ arr [ i - 1 ] NEW_LINE DEDENT DEDENT i = 0 NEW_LINE while ( i != q ) : NEW_LINE INDENT ansQueries ( prefrven , prefodd , l [ i ] , r [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE l = [ 1 , 1 , 2 ] NEW_LINE r = len ( arr ) NEW_LINE wrapper ( arr , n , l , r , q ) NEW_LINE DEDENT"],"references":["N = 100 NEW_LINE def ansQueries ( prefeven , prefodd , l , r ) : NEW_LINE INDENT if ( ( r - l + 1 ) % 2 == 0 ) : NEW_LINE INDENT print ( \"0\" ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( l % 2 == 0 ) : NEW_LINE INDENT print ( prefeven [ r ] ^ prefeven [ l - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( prefodd [ r ] ^ prefodd [ l - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT def wrapper ( arr , n , l , r , q ) : NEW_LINE INDENT prefodd = [ 0 ] * N NEW_LINE prefeven = [ 0 ] * N NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( ( i ) % 2 == 0 ) : NEW_LINE INDENT prefeven [ i ] = arr [ i - 1 ] ^ prefeven [ i - 1 ] NEW_LINE prefodd [ i ] = prefodd [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT prefeven [ i ] = prefeven [ i - 1 ] NEW_LINE prefodd [ i ] = prefodd [ i - 1 ] ^ arr [ i - 1 ] NEW_LINE DEDENT DEDENT i = 0 NEW_LINE while ( i != q ) : NEW_LINE INDENT ansQueries ( prefeven , prefodd , l [ i ] , r [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE l = [ 1 , 1 , 2 ] NEW_LINE r = [ 2 , 3 , 4 ] NEW_LINE q = len ( l ) NEW_LINE wrapper ( arr , n , l , r , q ) NEW_LINE DEDENT"],"bleu":0.8483570552488329,"rouge_l":0.9267147832231364}
{"id":930,"predictions":["def squaresum ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( i * i ) ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT n = 4 ; NEW_LINE print ( squaresum ( n ) ) ; NEW_LINE"],"references":["def squaresum ( n ) : NEW_LINE INDENT sm = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sm = sm + ( i * i ) NEW_LINE DEDENT return sm NEW_LINE DEDENT n = 4 NEW_LINE print ( squaresum ( n ) ) NEW_LINE"],"bleu":0.6517632969436628,"rouge_l":0.8666868198307135}
{"id":931,"predictions":["MAX = 10 ; NEW_LINE def isFactorion ( n ) : NEW_LINE INDENT fact = [ 0 ] * MAX ; NEW_LINE fact [ 0 ] = 1 ; NEW_LINE for i in range ( 1 , MAX ) : NEW_LINE INDENT fact [ i ] = i * fact [ i - 1 ] ; NEW_LINE DEDENT org = n ; NEW_LINE sum = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT d = n % 10 ; NEW_LINE sum += fact [ d ] ; NEW_LINE n = int ( n \/ 10 ) ; NEW_LINE DEDENT if ( sum == org ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT n = 40585 ; NEW_LINE if ( isFactorion ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT"],"references":["MAX = 10 NEW_LINE def isFactorion ( n ) : NEW_LINE INDENT fact = [ 0 ] * MAX NEW_LINE fact [ 0 ] = 1 NEW_LINE for i in range ( 1 , MAX ) : NEW_LINE INDENT fact [ i ] = i * fact [ i - 1 ] NEW_LINE DEDENT org = n NEW_LINE sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT d = n % 10 NEW_LINE sum += fact [ d ] NEW_LINE n = n \/\/ 10 NEW_LINE DEDENT if ( sum == org ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT n = 40585 NEW_LINE if ( isFactorion ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.7382392086664753,"rouge_l":0.9465170023109938}
{"id":932,"predictions":["import math NEW_LINE def minInsertions ( H , n , K ) : NEW_LINE INDENT inser = 0 ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT diff = abs ( H [ i ] - H [ i - 1 ] ) ; NEW_LINE if ( diff <= K ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT else : NEW_LINE INDENT inser += math . ceil ( diff \/ K ) - 1 ; NEW_LINE DEDENT DEDENT return inser ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT H = [ 2 , 4 , 8 , 16 ] ; NEW_LINE K = 3 ; NEW_LINE n = len ( H ) ; NEW_LINE print ( minInsertions ( H , n , K ) ) ; NEW_LINE DEDENT"],"references":["import math NEW_LINE def minInsertions ( H , n , K ) : NEW_LINE INDENT inser = 0 ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT diff = abs ( H [ i ] - H [ i - 1 ] ) ; NEW_LINE if ( diff <= K ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT else : NEW_LINE INDENT inser += math . ceil ( diff \/ K ) - 1 ; NEW_LINE DEDENT DEDENT return inser ; NEW_LINE DEDENT H = [ 2 , 4 , 8 , 16 ] ; NEW_LINE K = 3 ; NEW_LINE n = len ( H ) ; NEW_LINE print ( minInsertions ( H , n , K ) ) ; NEW_LINE"],"bleu":0.8895655063027059,"rouge_l":0.9567741138693343}
{"id":933,"predictions":["def ReplaceElements ( arr , n ) : NEW_LINE INDENT X = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT X ^= arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = X ^ arr [ i ] NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 3 , 3 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE ReplaceElements ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT"],"references":["def ReplaceElements ( arr , n ) : NEW_LINE INDENT X = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT X ^= arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = X ^ arr [ i ] NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 3 , 3 , 5 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE ReplaceElements ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.9815339825566375,"rouge_l":0.9903394606198846}
{"id":934,"predictions":["def makePalindrome ( string ) : NEW_LINE INDENT i = 0 ; NEW_LINE j = len ( string ) - 1 ; NEW_LINE while ( i <= j ) : NEW_LINE INDENT if ( string [ i ] == ' * ' and string [ j ] == ' * ' ) : NEW_LINE INDENT string [ i ] = ' a ' ; NEW_LINE string [ j ] = ' a ' ; NEW_LINE DEDENT elif ( string [ j ] == ' * ' ) : NEW_LINE INDENT string [ j ] = string [ j ] ; NEW_LINE DEDENT elif ( string [ i ] == ' * ' ) : NEW_LINE INDENT string [ i ] = string [ j ] ; NEW_LINE DEDENT elif ( string [ i ] != string [ j ] ) : NEW_LINE INDENT return \" - 1\" ; NEW_LINE DEDENT i += 1 ; NEW_LINE j -= 1 ; NEW_LINE DEDENT return string ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" na * an \" ; NEW_LINE print ( makePalindrome ( string ) ) ; NEW_LINE DEDENT"],"references":["def makePalindrome ( str1 ) : NEW_LINE INDENT i = 0 NEW_LINE j = len ( str1 ) - 1 NEW_LINE str1 = list ( str1 ) NEW_LINE while ( i <= j ) : NEW_LINE INDENT if ( str1 [ i ] == ' * ' and str1 [ j ] == ' * ' ) : NEW_LINE INDENT str1 [ i ] = ' a ' NEW_LINE str1 [ j ] = ' a ' NEW_LINE DEDENT elif ( str1 [ j ] == ' * ' ) : NEW_LINE INDENT str1 [ j ] = str1 [ i ] NEW_LINE DEDENT elif ( str1 [ i ] == ' * ' ) : NEW_LINE INDENT str1 [ i ] = str1 [ j ] NEW_LINE DEDENT elif ( str1 [ i ] != str1 [ j ] ) : NEW_LINE INDENT str1 = ' ' . join ( str1 ) NEW_LINE return \" - 1\" NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT str1 = ' ' . join ( str1 ) NEW_LINE return str1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = \" na * an \" NEW_LINE print ( makePalindrome ( str1 ) ) NEW_LINE DEDENT"],"bleu":0.539005869072138,"rouge_l":0.8025043588524331}
{"id":935,"predictions":["def countSubstr ( s ) : NEW_LINE INDENT n = len ( s ) ; NEW_LINE auxArr = [ 0 for i in range ( n ) ] ; NEW_LINE if ( s [ 0 ] == '1' ) : NEW_LINE INDENT auxArr [ 0 ] = 1 ; NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT auxArr [ i ] = auxArr [ i - 1 ] + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT auxArr [ i ] = auxArr [ i - 1 ] ; NEW_LINE DEDENT DEDENT count = 0 ; NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT count += auxArr [ i ] ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \"1101\" ; NEW_LINE print ( countSubstr ( s ) ) ; NEW_LINE DEDENT"],"references":["import math NEW_LINE def countSubstr ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE auxArr = [ 0 for i in range ( n ) ] NEW_LINE if ( s [ 0 ] == '1' ) : NEW_LINE INDENT auxArr [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT auxArr [ i ] = auxArr [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT auxArr [ i ] = auxArr [ i - 1 ] NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT count += auxArr [ i ] NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT s = \"1101\" NEW_LINE print ( countSubstr ( s ) ) NEW_LINE"],"bleu":0.7738875577481791,"rouge_l":0.9282113517550413}
{"id":936,"predictions":["from collections import defaultdict NEW_LINE class Graph : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . graph = defaultdict ( list ) NEW_LINE DEDENT def addEdge ( self , u , v ) : NEW_LINE INDENT self . graph [ u ] . append ( v ) NEW_LINE DEDENT def BFS ( self . s ) : NEW_LINE INDENT visited = [ False ] * ( w ) NEW_LINE q . append ( s ) NEW_LINE while q != 0 : NEW_LINE INDENT s = q . queue [ 0 ] NEW_LINE print ( s , end = \" ▁ \" ) NEW_LINE for i in self . graph [ s ] : NEW_LINE INDENT if visited [ n ] == False : NEW_LINE INDENT visited [ n ] = True NEW_LINE DEDENT else : NEW_LINE INDENT print ( s , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT g = Graph ( ) NEW_LINE g . addEdge ( 0 , 1 ) NEW_LINE g . addEdge ( 0 , 2 ) NEW_LINE g . addEdge ( 1 ) NEW_LINE for i in range ( len ( self . graph [ 0 ] ) ) : NEW_LINE INDENT if visited [ i ] == False : NEW_LINE INDENT visited [ n ] = True NEW_LINE DEDENT DEDENT DEDENT g = Graph ( ) NEW_LINE g . addEdge ( 0 , 2 ) NEW_LINE g . addEdge ( 0 , 2 ) NEW_LINE g . addEdge ( 1 , 2 ) NEW_LINE g . addEdge ( 2 , 3 ) NEW_LINE g . addEdge ( 3 , 3 ) NEW_LINE print ( \" Following ▁ is ▁ Stack ▁ from ▁ ( starting ▁ from ▁ vertex ▁ 2 ) \" ) NEW_LINE g . BFS ( 2 ) NEW_LINE"],"references":["from collections import defaultdict NEW_LINE class Graph : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . graph = defaultdict ( list ) NEW_LINE DEDENT def addEdge ( self , u , v ) : NEW_LINE INDENT self . graph [ u ] . append ( v ) NEW_LINE DEDENT def BFS ( self , s ) : NEW_LINE INDENT visited = [ False ] * ( len ( self . graph ) ) NEW_LINE queue = [ ] NEW_LINE queue . append ( s ) NEW_LINE visited [ s ] = True NEW_LINE while queue : NEW_LINE INDENT s = queue . pop ( 0 ) NEW_LINE print ( s , end = \" ▁ \" ) NEW_LINE for i in self . graph [ s ] : NEW_LINE INDENT if visited [ i ] == False : NEW_LINE INDENT queue . append ( i ) NEW_LINE visited [ i ] = True NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT g = Graph ( ) NEW_LINE g . addEdge ( 0 , 1 ) NEW_LINE g . addEdge ( 0 , 2 ) NEW_LINE g . addEdge ( 1 , 2 ) NEW_LINE g . addEdge ( 2 , 0 ) NEW_LINE g . addEdge ( 2 , 3 ) NEW_LINE g . addEdge ( 3 , 3 ) NEW_LINE print ( \" Following ▁ is ▁ Breadth ▁ First ▁ Traversal \" \" ▁ ( starting ▁ from ▁ vertex ▁ 2 ) \" ) NEW_LINE g . BFS ( 2 ) NEW_LINE"],"bleu":0.6910432258577413,"rouge_l":0.7784013705913628}
{"id":937,"predictions":["def vowel_calc ( s ) : NEW_LINE INDENT n = len ( s ) ; NEW_LINE arr = [ 0 for i in range ( n ) ] ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT arr [ i ] = n ; NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = ( n - i ) + arr [ i - 1 ] - i ; NEW_LINE DEDENT DEDENT sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT ch = s [ i ] ; NEW_LINE if ( ch == ' a ' or ch == ' e ' or ch == ' o ' or ch == ' u ' ) : NEW_LINE INDENT sum += arr [ i ] ; NEW_LINE DEDENT DEDENT return sum ; NEW_LINE DEDENT s = \" daceh \" ; NEW_LINE print ( vowel_calc ( s ) ) ; NEW_LINE"],"references":["def sumVowel ( string ) : NEW_LINE INDENT n = len ( string ) NEW_LINE sum = 0 NEW_LINE string = string . lower ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT s = string [ i ] NEW_LINE if ( s == \" a \" or s == \" e \" or s == \" i \" or s == \" o \" or s == \" u \" ) : NEW_LINE INDENT sum += ( ( n - i ) * ( i + 1 ) ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT string = \" abhay \" NEW_LINE print ( vovel ( string ) ) NEW_LINE DEDENT"],"bleu":0.23693629734667557,"rouge_l":0.48575594436967245}
{"id":938,"predictions":["def findOddPair ( A , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( A [ i ] % 2 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count * ( N - count ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 5 , 4 , 7 , 2 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( findOddPair ( a , n ) ) NEW_LINE DEDENT"],"references":["def findOddPair ( A , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( A [ i ] % 2 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count * ( N - count ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 5 , 4 , 7 , 2 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( findOddPair ( a , n ) ) NEW_LINE DEDENT"],"bleu":0.9497210413026634,"rouge_l":0.9801980198019802}
{"id":939,"predictions":["def smallestDivisor ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT for i in range ( 3 , mt . ceil ( mt . sqrt ( n + 1 ) ) , 2 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT n = 31 NEW_LINE print ( smallestDivisor ( n ) ) NEW_LINE"],"references":["def smallestDivisor ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return 2 ; NEW_LINE DEDENT i = 3 ; NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT i += 2 ; NEW_LINE DEDENT return n ; NEW_LINE DEDENT n = 31 ; NEW_LINE print ( smallestDivisor ( n ) ) ; NEW_LINE"],"bleu":0.6170115786675107,"rouge_l":0.7777777777777778}
{"id":940,"predictions":["def areaOfKite ( d1 , d2 ) : NEW_LINE INDENT area = ( d1 * d2 ) \/ 2 NEW_LINE return area NEW_LINE DEDENT d1 = 4 NEW_LINE d2 = 6 NEW_LINE print ( \" Area ▁ of ▁ Kite ▁ = \" , areaOfKite ( d1 , d2 ) ) NEW_LINE"],"references":["def areaOfKite ( d1 , d2 ) : NEW_LINE INDENT area = ( d1 * d2 ) \/ 2 ; NEW_LINE return area ; NEW_LINE DEDENT d1 = 4 ; NEW_LINE d2 = 6 ; NEW_LINE print ( \" Area ▁ of ▁ Kite ▁ = ▁ \" , areaOfKite ( d1 , d2 ) ) ; NEW_LINE"],"bleu":0.7384607248431221,"rouge_l":0.936245572609209}
{"id":941,"predictions":["def isPossible ( v , v , str ) : NEW_LINE INDENT str1 = sorted ( str1 ) NEW_LINE for i in range ( len ( v1 ) - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , len ( v ) ) : NEW_LINE INDENT temp = v [ i ] + v [ j ] NEW_LINE temp = sortString ( temp ) NEW_LINE if ( temp > str1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" amazon \" NEW_LINE arr = [ \" fds \" , \" oxq \" , \" zoa \" , \" epw \" , \" amn \" ] NEW_LINE if ( isPossible ( v , str1 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def isPossible ( v , string ) : NEW_LINE INDENT char_list = list ( string ) NEW_LINE char_list . sort ( ) NEW_LINE for i in range ( len ( v ) - 1 ) : NEW_LINE INDENT for j in range ( len ( v ) ) : NEW_LINE INDENT temp = v [ i ] + v [ j ] ; NEW_LINE temp_list = list ( temp ) NEW_LINE temp_list . sort ( ) NEW_LINE if ( temp_list == char_list ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT DEDENT return False ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" amazon \" ; NEW_LINE v = [ \" fds \" , \" oxq \" , \" zoa \" , \" epw \" , \" amn \" ] ; NEW_LINE if ( isPossible ( v , string ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"],"bleu":0.6725307683982298,"rouge_l":0.8455330864900787}
{"id":942,"predictions":["def seriesSum ( n ) : NEW_LINE INDENT i = 1 NEW_LINE res = 0 NEW_LINE sign = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n -= 1 NEW_LINE if ( sign ) : NEW_LINE INDENT sign = ~ sign NEW_LINE res = res + i \/ += 1 NEW_LINE DEDENT else : NEW_LINE INDENT sign = not sign NEW_LINE res = res - i \/ += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT n = 5 NEW_LINE print ( seriesSum ( n ) ) NEW_LINE"],"references":["def seriesSum ( n ) : NEW_LINE INDENT i = 1 ; NEW_LINE res = 0.0 ; NEW_LINE sign = True ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n = n - 1 ; NEW_LINE if ( sign ) : NEW_LINE INDENT sign = False ; NEW_LINE res = res + ( i + 1 ) \/ ( i + 2 ) ; NEW_LINE i = i + 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT sign = True ; NEW_LINE res = res - ( i + 1 ) \/ ( i + 2 ) ; NEW_LINE i = i + 2 ; NEW_LINE DEDENT DEDENT return res ; NEW_LINE DEDENT n = 5 ; NEW_LINE print ( round ( seriesSum ( n ) , 6 ) ) ; NEW_LINE"],"bleu":0.388480512261744,"rouge_l":0.6839523475823406}
{"id":943,"predictions":["MAX = 1000000 NEW_LINE sieve_Prime = [ 0 ] * ( MAX + 4 ) NEW_LINE sieve_sqrt = [ 0 ] * ( MAX + 4 ) NEW_LINE sieve_count = [ 0 ] * ( MAX + 4 ) NEW_LINE def form_sieve ( ) : NEW_LINE INDENT sieve_Prime [ 1 ] = 1 NEW_LINE for i in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if ( sieve_Prime [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i * 2 , MAX + 1 , i ) : NEW_LINE INDENT if ( sieve_Prime [ j ] == 0 ) : NEW_LINE INDENT sieve_Prime [ j ] = 1 NEW_LINE sieve_count [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT form_sieve ( ) NEW_LINE n = 2 NEW_LINE print ( \" Count ▁ = \" , sieve_count ( ) + 1 ) NEW_LINE n = 3 NEW_LINE print ( \" Count ▁ = \" , sieve_count ( n ) + 1 ) NEW_LINE DEDENT"],"references":["MAX = 1000000 NEW_LINE sieve_Prime = [ 0 for i in range ( MAX + 4 ) ] NEW_LINE sieve_count = [ 0 for i in range ( MAX + 4 ) ] NEW_LINE def form_sieve ( ) : NEW_LINE INDENT sieve_Prime [ 1 ] = 1 NEW_LINE for i in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if sieve_Prime [ i ] == 0 : NEW_LINE INDENT for j in range ( i * 2 , MAX + 1 , i ) : NEW_LINE INDENT if sieve_Prime [ j ] == 0 : NEW_LINE INDENT sieve_Prime [ j ] = 1 NEW_LINE sieve_count [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT form_sieve ( ) NEW_LINE n = 2 NEW_LINE print ( \" Count ▁ = \" , sieve_count [ n ] + 1 ) NEW_LINE n = 3 NEW_LINE print ( \" Count ▁ = \" , sieve_count [ n ] + 1 ) NEW_LINE"],"bleu":0.7028804860051718,"rouge_l":0.8641376687583191}
{"id":944,"predictions":["N = 4 NEW_LINE def MaximumDecimalValue ( mat , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE if ( mat [ 0 ] [ 0 ] == 1 ) : NEW_LINE INDENT dp [ 0 ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( mat [ 0 ] [ i ] == 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + pow ( 2 , i ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( mat [ i ] [ 0 ] == 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + pow ( 2 , i ) ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) + pow ( 2 , i + j ) ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT return dp [ n - 1 ] [ n - 1 ] [ n - 1 ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT mat = [ [ 1 , 1 , 0 , 1 ] , [ 0 , 1 , 1 , 0 , 1 ] , [ 1 , 0 ,"],"references":["N = 4 NEW_LINE def MaximumDecimalValue ( mat , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE if ( mat [ 0 ] [ 0 ] == 1 ) : NEW_LINE INDENT dp [ 0 ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( mat [ 0 ] [ i ] == 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + 2 ** i NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( mat [ i ] [ 0 ] == 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + 2 ** i NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) + ( 2 ** ( i + j ) ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n - 1 ] [ n - 1 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT mat = [ [ 1 , 1 , 0 , 1 ] , [ 0 , 1 , 1 , 0 ] , [ 1 , 0 , 0 , 1 ] , [ 1 , 0 , 1 , 1 ] ] NEW_LINE print ( MaximumDecimalValue ( mat , 4 ) ) NEW_LINE DEDENT"],"bleu":0.8977554690397326,"rouge_l":0.9327292585251405}
{"id":945,"predictions":["MAX = 100 ; NEW_LINE def checkBnyetric ( m , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( m [ i ] [ j ] != m [ j ] ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n - i ) : NEW_LINE INDENT if ( m [ i ] [ j ] != m [ n - j - 1 ] [ n - i - 1 ] ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT DEDENT return True ; NEW_LINE DEDENT n = 3 ; NEW_LINE m = [ [ 1 , 2 , 3 ] , [ 2 , 5 , 2 ] , [ 3 , 2 , 1 ] ] ; NEW_LINE if ( checkBnyetric ( m , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT"],"references":["def checkBisymmetric ( m , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , i ) : NEW_LINE INDENT if ( m [ i ] [ j ] != m [ j ] [ i ] ) : NEW_LINE INDENT return false NEW_LINE DEDENT DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n - i ) : NEW_LINE INDENT if ( m [ i ] [ j ] != m [ n - j - 1 ] [ n - i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True ; NEW_LINE DEDENT n = 3 ; NEW_LINE m = [ [ 1 , 2 , 3 ] , [ 2 , 5 , 2 ] , [ 3 , 2 , 1 ] ] NEW_LINE if ( checkBisymmetric ( m , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.8340362343641754,"rouge_l":0.9238470094977326}
{"id":946,"predictions":["import sys NEW_LINE def Divis ( a , n ) : NEW_LINE INDENT maxi = - sys . maxsize ; NEW_LINE mini = sys . maxsize ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT maxi = max ( a [ i ] , maxi ) ; NEW_LINE mini = min ( a [ i ] , mini ) ; NEW_LINE DEDENT return maxi \/ mini ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 3 , 7 , 9 , 3 , 11 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( Divis ( a , n ) ) ; NEW_LINE DEDENT"],"references":["def Divison ( a , n ) : NEW_LINE INDENT maxi = - 10 ** 9 NEW_LINE mini = 10 ** 9 NEW_LINE for i in a : NEW_LINE INDENT maxi = max ( i , maxi ) NEW_LINE mini = min ( i , mini ) NEW_LINE DEDENT return maxi \/\/ mini NEW_LINE DEDENT a = [ 3 , 7 , 9 , 3 , 11 ] NEW_LINE n = len ( a ) NEW_LINE print ( Divison ( a , n ) ) NEW_LINE"],"bleu":0.43345792184951026,"rouge_l":0.7604986876640419}
{"id":947,"predictions":["MAX = 10 NEW_LINE F = [ [ - 1 for i in range ( MAX ) ] for j in range ( MAX ) ] NEW_LINE C = [ - 1 for i in range ( MAX ) ] for k in range ( MAX ) ] NEW_LINE def noOfAssignments ( S , n , i , c_x ) : NEW_LINE INDENT if ( F [ i ] [ c_x ] != - 1 ) : NEW_LINE INDENT return F [ i ] [ c_x ] NEW_LINE DEDENT else : NEW_LINE INDENT if ( c_x == 1 ) : NEW_LINE INDENT F [ i ] [ c_x ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT F [ i ] [ c_x ] = 1 NEW_LINE DEDENT return F [ i ] [ c_x ] NEW_LINE DEDENT c_y = C [ i ] - c_x NEW_LINE if ( S [ i ] == ' ( ' ) : NEW_LINE INDENT F [ i ] [ c_x ] =   \\ NEW_LINE INDENT noOfAssignments ( S , n , i + 1 , c_x + 1 ) +   \\ NEW_LINE INDENT noOfAssignments ( S , n , i + 1 , c_x - 1 ) NEW_LINE DEDENT return F [ i ] [ c_x ] NEW_LINE DEDENT if ( c_y == 1 ) : NEW_LINE INDENT F [ i ] [ c_x ] +=   \\ NEW_LINE INDENT noOfAssignments ( S , n , i + 1 , c_x - 1 ) NEW_LINE DEDENT DEDENT if ( c_y == 1 ) : NEW_LINE INDENT F [ i ] [ c_x ] +=  \\ NEW_LINE INDENT noOfAssignments ( S , n , i + 1 , c_x ) NEW_LINE DEDENT DEDENT return F [ i ] [ c_x ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = \" ( ) \" NEW_LINE n = len ( S ) NEW_LINE print ( noOfAssignments ( S , n , 0 , 0"],"references":["MAX = 10 NEW_LINE F = [ [ - 1 for i in range ( MAX ) ] for j in range ( MAX ) ] NEW_LINE C = [ None ] * MAX NEW_LINE def noOfAssignments ( S , n , i , c_x ) : NEW_LINE INDENT if F [ i ] [ c_x ] != - 1 : NEW_LINE INDENT return F [ i ] [ c_x ] NEW_LINE DEDENT if i == n : NEW_LINE INDENT F [ i ] [ c_x ] = not c_x NEW_LINE return F [ i ] [ c_x ] NEW_LINE DEDENT c_y = C [ i ] - c_x NEW_LINE if S [ i ] == ' ( ' : NEW_LINE INDENT F [ i ] [ c_x ] =   \\ NEW_LINE INDENT noOfAssignments ( S , n , i + 1 , c_x + 1 ) +   \\ NEW_LINE noOfAssignments ( S , n , i + 1 , c_x ) NEW_LINE DEDENT return F [ i ] [ c_x ] NEW_LINE DEDENT F [ i ] [ c_x ] = 0 NEW_LINE if c_x : NEW_LINE INDENT F [ i ] [ c_x ] +=   \\ NEW_LINE INDENT noOfAssignments ( S , n , i + 1 , c_x - 1 ) NEW_LINE DEDENT DEDENT if c_y : NEW_LINE INDENT F [ i ] [ c_x ] +=   \\ NEW_LINE INDENT noOfAssignments ( S , n , i + 1 , c_x ) NEW_LINE DEDENT DEDENT return F [ i ] [ c_x ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = \" ( ) \" NEW_LINE n = len ( S ) NEW_LINE C [ 0 ] = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if S [ i ] == ' ( ' : NEW_LINE INDENT C [ i + 1 ] = C [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i + 1 ] = C [ i ] - 1 NEW_LINE DEDENT DEDENT print ( noOfAssignments ( S , n , 0 , 0 ) ) NEW_LINE DEDENT"],"bleu":0.76023268207103,"rouge_l":0.7943645355959889}
{"id":948,"predictions":["def nextPowerOf2 ( n ) : NEW_LINE INDENT count = 0 NEW_LINE if ( n and ( n & ( n - 1 ) ) == 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT while ( n ) : NEW_LINE INDENT n >>= 1 NEW_LINE count += 1 NEW_LINE DEDENT return 1 << count NEW_LINE DEDENT n = 0 NEW_LINE print ( nextPowerOf2 ( n ) ) NEW_LINE"],"references":["def nextPowerOf2 ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE if ( n and not ( n & ( n - 1 ) ) ) : NEW_LINE INDENT return n NEW_LINE DEDENT while ( n != 0 ) : NEW_LINE INDENT n >>= 1 NEW_LINE count += 1 NEW_LINE DEDENT return 1 << count ; NEW_LINE DEDENT n = 0 NEW_LINE print ( nextPowerOf2 ( n ) ) NEW_LINE"],"bleu":0.8334769382118984,"rouge_l":0.9467222608292796}
{"id":949,"predictions":["from math import gcd NEW_LINE def nthElement ( a , b , n ) : NEW_LINE INDENT lcm = ( a * b ) \/\/ gcd ( a , b ) NEW_LINE l = 1 ; r = min ( a , b ) * n NEW_LINE while ( l <= r ) : NEW_LINE INDENT mid = ( l + r ) >> 1 ; NEW_LINE val = mid \/\/ a + mid \/\/ b - mid \/\/ lcm ; NEW_LINE if ( val == n ) : NEW_LINE INDENT return max ( ( mid \/\/ a ) * a , ( mid \/\/ b ) * b ) ; NEW_LINE DEDENT if ( val < n ) : NEW_LINE INDENT l = mid + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT r = mid - 1 ; NEW_LINE DEDENT DEDENT return 0 ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 5 ; b = 3 ; n = 5 ; NEW_LINE print ( nthElement ( a , b , n ) ) ; NEW_LINE DEDENT"],"references":["import math NEW_LINE def nthElement ( a , b , n ) : NEW_LINE INDENT lcm = ( a * b ) \/ int ( math . gcd ( a , b ) ) NEW_LINE l = 1 NEW_LINE r = min ( a , b ) * n NEW_LINE while ( l <= r ) : NEW_LINE INDENT mid = ( l + r ) >> 1 NEW_LINE val = ( int ( mid \/ a ) + int ( mid \/ b ) - int ( mid \/ lcm ) ) NEW_LINE if ( val == n ) : NEW_LINE INDENT return int ( max ( int ( mid \/ a ) * a , int ( mid \/ b ) * b ) ) NEW_LINE DEDENT if ( val < n ) : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = mid - 1 NEW_LINE DEDENT DEDENT DEDENT a = 5 NEW_LINE b = 3 NEW_LINE n = 5 NEW_LINE print ( nthElement ( a , b , n ) ) NEW_LINE"],"bleu":0.6223455795937857,"rouge_l":0.8186100248844651}
{"id":950,"predictions":["MAX = 10000 NEW_LINE arr = [ ] NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime = [ True ] * ( MAX ) NEW_LINE p = 2 NEW_LINE while p * p < MAX : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT for p in range ( 2 , MAX ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT def isEuclid ( n ) : NEW_LINE INDENT product = 1 NEW_LINE i = 0 NEW_LINE while ( product < n ) : NEW_LINE INDENT product = product * arr [ i ] NEW_LINE if ( product + 1 == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE n = 31 NEW_LINE if ( isEuclid ( n ) ) == True : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE DEDENT n = 42 NEW_LINE if isEuclid ( n ) == True : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE DEDENT DEDENT"],"references":["MAX = 10000 NEW_LINE arr = [ ] NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime = [ True ] * MAX NEW_LINE p = 2 NEW_LINE while p * p < MAX : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT for p in range ( 2 , MAX ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT arr . append ( p ) NEW_LINE DEDENT DEDENT DEDENT def isEuclid ( n ) : NEW_LINE INDENT product = 1 NEW_LINE i = 0 NEW_LINE while ( product < n ) : NEW_LINE INDENT product = product * arr [ i ] NEW_LINE if ( product + 1 == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE n = 31 NEW_LINE if ( isEuclid ( n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT n = 42 NEW_LINE if ( isEuclid ( n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.9036026575169898,"rouge_l":0.9639795265515037}
{"id":951,"predictions":["def minElements ( arr , n ) : NEW_LINE INDENT halfSum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT halfSum = halfSum + arr [ i ] NEW_LINE DEDENT halfSum = halfSum \/ 2 NEW_LINE arr . sort ( ) NEW_LINE res = 0 NEW_LINE curr_sum = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT curr_sum += arr [ i ] NEW_LINE res += 1 NEW_LINE if ( curr_sum > halfSum ) : NEW_LINE INDENT return res NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT arr = [ 3 , 1 , 7 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minElements ( arr , n ) ) NEW_LINE"],"references":["def minElements ( arr , n ) : NEW_LINE INDENT halfSum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT halfSum = halfSum + arr [ i ] NEW_LINE DEDENT halfSum = int ( halfSum \/ 2 ) NEW_LINE arr . sort ( reverse = True ) NEW_LINE res = 0 NEW_LINE curr_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_sum += arr [ i ] NEW_LINE res += 1 NEW_LINE if curr_sum > halfSum : NEW_LINE INDENT return res NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT arr = [ 3 , 1 , 7 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minElements ( arr , n ) ) NEW_LINE"],"bleu":0.8295185303426389,"rouge_l":0.9341500765696785}
{"id":952,"predictions":["def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def lcm ( a , b ) : NEW_LINE INDENT return ( a * b ) \/ gcd ( a , b ) NEW_LINE DEDENT a = 15 NEW_LINE b = 20 NEW_LINE print ( ' LCM ▁ of ' , a , ' and ' , b , ' is ' , lcm ( a , b ) ) NEW_LINE"],"references":["def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def lcm ( a , b ) : NEW_LINE INDENT return ( a * b ) \/ gcd ( a , b ) NEW_LINE DEDENT a = 15 NEW_LINE b = 20 NEW_LINE print ( ' LCM ▁ of ' , a , ' and ' , b , ' is ' , lcm ( a , b ) ) NEW_LINE"],"bleu":1.0,"rouge_l":1.0}
{"id":953,"predictions":["from math import sqrt NEW_LINE MAX = 1000005 NEW_LINE prime = [ True for i in range ( MAX ) ] NEW_LINE def SieveOfEratosthenes ( prime ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE prime [ 0 ] = False NEW_LINE for p in range ( 2 , int ( sqrt ( MAX ) ) + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def prime_xor ( arr , n , k ) : NEW_LINE INDENT for i in range ( MAX ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] ) : NEW_LINE INDENT if ( ( i + 1 ) % k == 0 ) : NEW_LINE INDENT ans ^= arr [ i ] NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 3 , 5 , 7 , 11 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE K = 2 NEW_LINE prime_xor ( arr , n , K ) ; NEW_LINE DEDENT"],"references":["MAX = 1000005 NEW_LINE def SieveOfEratosthenes ( prime ) : NEW_LINE INDENT prime [ 1 ] = False ; NEW_LINE prime [ 0 ] = False ; NEW_LINE for p in range ( 2 , int ( MAX ** ( 1 \/ 2 ) ) ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def prime_xor ( arr , n , k ) : NEW_LINE INDENT prime = [ True ] * MAX ; NEW_LINE SieveOfEratosthenes ( prime ) ; NEW_LINE ans = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] ) : NEW_LINE INDENT if ( ( i + 1 ) % k == 0 ) : NEW_LINE INDENT ans ^= arr [ i ] ; NEW_LINE DEDENT DEDENT DEDENT print ( ans ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 3 , 5 , 7 , 11 , 8 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE K = 2 ; NEW_LINE prime_xor ( arr , n , K ) ; NEW_LINE DEDENT"],"bleu":0.761423912032521,"rouge_l":0.8609583092067168}
{"id":954,"predictions":["def computeTotient ( n ) : NEW_LINE INDENT phi = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT phi [ p ] = i NEW_LINE DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( phi [ p ] == p ) : NEW_LINE INDENT phi [ p ] = p - 1 NEW_LINE for i in range ( 2 * p , n + 1 , p ) : NEW_LINE INDENT phi [ i ] = ( phi [ i ] \/\/ p ) * ( p - 1 ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( \" Totient ▁ of \" , i , \" is \" , phi [ i ] ) NEW_LINE DEDENT DEDENT n = 12 NEW_LINE computeTotient ( n ) NEW_LINE"],"references":["def computeTotient ( n ) : NEW_LINE INDENT phi = [ ] NEW_LINE for i in range ( n + 2 ) : NEW_LINE INDENT phi . append ( 0 ) NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT phi [ i ] = i NEW_LINE DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( phi [ p ] == p ) : NEW_LINE INDENT phi [ p ] = p - 1 NEW_LINE for i in range ( 2 * p , n + 1 , p ) : NEW_LINE INDENT phi [ i ] = ( phi [ i ] \/\/ p ) * ( p - 1 ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( \" Totient ▁ of ▁ \" , i , \" ▁ is ▁ \" , phi [ i ] ) NEW_LINE DEDENT DEDENT n = 12 NEW_LINE computeTotient ( n ) NEW_LINE"],"bleu":0.8313613832769889,"rouge_l":0.9220458218461831}
{"id":955,"predictions":["def countDigit ( n ) : NEW_LINE INDENT temp = n NEW_LINE count = 0 NEW_LINE while temp != 0 : NEW_LINE INDENT d = temp % 10 NEW_LINE temp \/= 10 NEW_LINE if d == 2 or d == 3 or d == 5 or d == 7 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT n = 1234567890 NEW_LINE print ( countDigit ( n ) ) NEW_LINE"],"references":["def countDigit ( n ) : NEW_LINE INDENT temp = n NEW_LINE count = 0 NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT d = temp % 10 NEW_LINE temp \/\/= 10 NEW_LINE if ( d == 2 or d == 3 or d == 5 or d == 7 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 1234567890 NEW_LINE print ( countDigit ( n ) ) NEW_LINE DEDENT"],"bleu":0.6722907368656719,"rouge_l":0.8626501356063542}
{"id":956,"predictions":["def getChar ( str ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT sum += ( ord ( str [ i ] ) - ord ( ' a ' ) + 1 ) ; NEW_LINE DEDENT if ( sum % 26 == 0 ) : NEW_LINE INDENT return ' z ' ; NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum % 26 ; NEW_LINE return chr ( ord ( str ) + sum - 1 ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" gfg \" ; NEW_LINE print ( getChar ( str ) ) ; NEW_LINE DEDENT"],"references":["def getChar ( strr ) : NEW_LINE INDENT summ = 0 NEW_LINE for i in range ( len ( strr ) ) : NEW_LINE INDENT summ += ( ord ( strr [ i ] ) - ord ( ' a ' ) + 1 ) NEW_LINE DEDENT if ( summ % 26 == 0 ) : NEW_LINE INDENT return ord ( ' z ' ) NEW_LINE DEDENT else : NEW_LINE INDENT summ = summ % 26 NEW_LINE return chr ( ord ( ' a ' ) + summ - 1 ) NEW_LINE DEDENT DEDENT strr = \" gfg \" NEW_LINE print ( getChar ( strr ) ) NEW_LINE"],"bleu":0.48212943944165904,"rouge_l":0.794361763022324}
{"id":957,"predictions":["def countWays ( n , arr , Len ) : NEW_LINE INDENT count = [ 0 for i in range ( n + 1 ) ] NEW_LINE count [ 0 ] = 1 NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT no_ways = 0 NEW_LINE for j in range ( 0 , Len ) : NEW_LINE INDENT if ( i - arr [ j ] >= 0 ) : NEW_LINE INDENT no_ways += count [ i - arr [ j ] ] NEW_LINE DEDENT count [ i ] = no_ways NEW_LINE DEDENT DEDENT return count [ n ] NEW_LINE DEDENT arr = [ 1 , 3 , 5 ] NEW_LINE Len = len ( arr ) NEW_LINE n = 5 NEW_LINE print ( countWays ( n , arr , Len ) ) NEW_LINE"],"references":["def countWays ( n , arr ) : NEW_LINE INDENT count = [ 0 ] * ( n + 1 ) NEW_LINE count [ 0 ] = 1 NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT no_ways = 0 NEW_LINE for j in arr : NEW_LINE INDENT if ( i - j >= 0 ) : NEW_LINE INDENT no_ways += count [ i - j ] NEW_LINE DEDENT count [ i ] = no_ways NEW_LINE DEDENT DEDENT return count [ n ] NEW_LINE DEDENT arr = [ 1 , 3 , 5 ] NEW_LINE n = 5 NEW_LINE print ( countWays ( n , arr ) ) NEW_LINE"],"bleu":0.7371969408921509,"rouge_l":0.9041859362030119}
{"id":958,"predictions":["import math as mt NEW_LINE def primeOccurrences ( arr , k ) : NEW_LINE INDENT map = { } NEW_LINE for i in range ( k ) : NEW_LINE INDENT val = arr [ i ] NEW_LINE if val in map : NEW_LINE INDENT map [ val ] = map + 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq = 1 NEW_LINE DEDENT DEDENT for value in map : NEW_LINE INDENT if ( value > 2 and n % 2 == 0 ) : NEW_LINE INDENT print ( value ) NEW_LINE DEDENT DEDENT return NEW_LINE DEDENT def isPrime ( n ) : NEW_LINE INDENT if ( n > 2 and n % 2 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT arr = [ 11 , 11 , 11 , 23 , 11 , 37 , 51 , 51 , 51 , 51 , 51 , 51 ] NEW_LINE k = 2 NEW_LINE primeOccure ( arr , k ) NEW_LINE"],"references":["def primeOccurences ( arr , k ) : NEW_LINE INDENT map = { } NEW_LINE for val in arr : NEW_LINE INDENT freq = 0 NEW_LINE if val in map : NEW_LINE INDENT freq = map [ val ] NEW_LINE freq += 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq = 1 NEW_LINE DEDENT map [ val ] = freq NEW_LINE DEDENT for entry in map : NEW_LINE INDENT value = map [ entry ] NEW_LINE if isPrime ( value ) and value >= k : NEW_LINE INDENT print ( entry ) NEW_LINE DEDENT DEDENT DEDENT def isPrime ( n ) : NEW_LINE INDENT if ( n > 2 and not n % 2 ) or n == 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 3 , int ( n ** 0.5 + 1 ) , 2 ) : NEW_LINE INDENT if not n % i : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT arr = [ 11 , 11 , 11 , 23 , 11 , 37 , 37 , 51 , 51 , 51 , 51 , 51 ] NEW_LINE k = 2 NEW_LINE primeOccurences ( arr , k ) NEW_LINE"],"bleu":0.6510109429701639,"rouge_l":0.788328784716648}
{"id":959,"predictions":["def Nth_Term ( n ) : NEW_LINE INDENT return ( 3 * pow ( n , 2 ) - n + 2 ) \/\/ ( 2 ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 5 ; NEW_LINE print ( Nth_Term ( N ) ) ; NEW_LINE DEDENT"],"references":["def Nth_Term ( n ) : NEW_LINE INDENT return ( 3 * pow ( n , 2 ) - n + 2 ) \/\/ ( 2 ) NEW_LINE DEDENT N = 5 NEW_LINE print ( Nth_Term ( N ) ) NEW_LINE"],"bleu":0.6126124664400904,"rouge_l":0.8547505126452494}
{"id":960,"predictions":["import math NEW_LINE def sum ( n ) : NEW_LINE INDENT root = math . sqrt ( n ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , root + 1 ) : NEW_LINE INDENT ans = ans + n \/ i NEW_LINE DEDENT ans = 2 * ans - ( root * root ) NEW_LINE return ans NEW_LINE DEDENT n = 35 NEW_LINE print ( sum ( n ) ) NEW_LINE"],"references":["import math NEW_LINE def sum ( n ) : NEW_LINE INDENT root = ( int ) ( math . sqrt ( n ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , root + 1 ) : NEW_LINE INDENT ans = ans + n \/\/ i NEW_LINE DEDENT ans = 2 * ans - ( root * root ) NEW_LINE return ans NEW_LINE DEDENT n = 35 NEW_LINE print ( sum ( n ) ) NEW_LINE"],"bleu":0.8744003792110784,"rouge_l":0.94931650893796}
{"id":961,"predictions":["def isXYBits ( num ) : NEW_LINE INDENT a = str ( num ) NEW_LINE for i in range ( len ( num ) ) : NEW_LINE INDENT index = int ( num ) NEW_LINE cnt = 0 NEW_LINE for j in range ( len ( a ) ) : NEW_LINE INDENT number = int ( a [ j ] ) NEW_LINE if number == i : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if cnt != index : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def findMaximumBio ( n ) : NEW_LINE INDENT low = 0 NEW_LINE high = pow ( 10.0 , n - 1 ) NEW_LINE for i in range ( low + 1 ) : NEW_LINE INDENT number = 0 NEW_LINE for i in range ( low , high + 1 ) : NEW_LINE INDENT number = 1 NEW_LINE print ( i , \" , \" , ▁ \" , end = \" \" ) NEW_LINE DEDENT if flag == 0 : NEW_LINE INDENT print ( \" There ▁ is ▁ no ▁ exist \" , \" with ▁ \" , n , \" digits \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 0 NEW_LINE find167 ( N ) NEW_LINE N = 4 NEW_LINE findMaximumBeries ( N ) NEW_LINE DEDENT"],"references":["from math import pow NEW_LINE def isAutoBio ( num ) : NEW_LINE INDENT autoStr = str ( num ) NEW_LINE for i in range ( 0 , len ( autoStr ) ) : NEW_LINE INDENT index = int ( autoStr [ i ] ) NEW_LINE cnt = 0 NEW_LINE for j in range ( 0 , len ( autoStr ) ) : NEW_LINE INDENT number = int ( autoStr [ j ] ) NEW_LINE if number == i : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if cnt != index : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def findAutoBios ( n ) : NEW_LINE INDENT low = int ( pow ( 10 , n - 1 ) ) NEW_LINE high = int ( pow ( 10 , n ) - 1 ) NEW_LINE flag = 0 NEW_LINE for i in range ( low , high + 1 ) : NEW_LINE INDENT if isAutoBio ( i ) : NEW_LINE INDENT flag = 1 NEW_LINE print ( i , end = ' , ▁ ' ) NEW_LINE DEDENT DEDENT if flag == 0 : NEW_LINE INDENT print ( \" There ▁ is ▁ no ▁ Autobiographical ▁ Number ▁ with ▁ \" + str ( n ) + \" ▁ digits \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 0 NEW_LINE findAutoBios ( N ) NEW_LINE N = 4 NEW_LINE findAutoBios ( N ) NEW_LINE DEDENT"],"bleu":0.6495095698705716,"rouge_l":0.7888462315619318}
{"id":962,"predictions":["def isLucky ( n ) : NEW_LINE INDENT arr = [ True for i in range ( 10 ) ] NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT arr [ i ] = False NEW_LINE DEDENT while ( n > 0 ) : NEW_LINE INDENT digit = n % 10 NEW_LINE if ( arr [ digit ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT arr [ digit ] = True NEW_LINE n = ( n \/\/ 10 ) NEW_LINE DEDENT return True NEW_LINE DEDENT arr = [ 1291 , 897 , 4566 , 1232 , 80 , 70 ] NEW_LINE n = len ( arr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( isLucky ( arr [ i ] ) ) : NEW_LINE INDENT print ( arr [ i ] , \" is ▁ Odd \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ i ] , \" is ▁ not ▁ucked \" ) NEW_LINE DEDENT DEDENT"],"references":["import math NEW_LINE def isLucky ( n ) : NEW_LINE INDENT ar = [ 0 ] * 10 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT digit = math . floor ( n % 10 ) NEW_LINE if ( ar [ digit ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ar [ digit ] = 1 NEW_LINE n = n \/ 10 NEW_LINE DEDENT return 1 NEW_LINE DEDENT arr = [ 1291 , 897 , 4566 , 1232 , 80 , 700 ] NEW_LINE n = len ( arr ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT k = arr [ i ] NEW_LINE if ( isLucky ( k ) ) : NEW_LINE INDENT print ( k , \" ▁ is ▁ Lucky ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( k , \" ▁ is ▁ not ▁ Lucky ▁ \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.5284651557006983,"rouge_l":0.7427047695713423}
{"id":963,"predictions":["def printSeriesSum ( N ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( i % 2 == 1 ) : NEW_LINE INDENT sum += i \/ ( i + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT sum -= i \/ ( i + 1 ) ; NEW_LINE DEDENT DEDENT print ( sum ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 10 ; NEW_LINE printSeriesSum ( N ) ; NEW_LINE DEDENT"],"references":["def printSeriesSum ( N ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( i & 1 ) : NEW_LINE INDENT sum += i \/ ( i + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT sum -= i \/ ( i + 1 ) ; NEW_LINE DEDENT DEDENT print ( sum ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 10 ; NEW_LINE printSeriesSum ( N ) ; NEW_LINE DEDENT"],"bleu":0.9541060922758607,"rouge_l":0.9813976872800403}
{"id":964,"predictions":["def power ( x , y , m ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT p = power ( x , int ( y \/ 2 , m ) % m ) % m NEW_LINE p = ( p * p ) % m NEW_LINE if ( y % 2 == 0 ) : NEW_LINE INDENT print ( \" Inverse ▁ doesn ' t ▁ exist \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Modular ▁ multiplicative ▁ inverse ▁ is \" , power ( a , m - 2 , m ) ) NEW_LINE DEDENT DEDENT def modInverse ( a , m ) : NEW_LINE INDENT if ( gcd ( a , m ) != 1 ) : NEW_LINE INDENT print ( \" Inverse ▁ doesn ' t ▁ exist \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Modular ▁ multiplicative ▁ inverse ▁ is \" , power ( a , m - 2 , m ) ) NEW_LINE DEDENT DEDENT a = 3 ; m = 11 NEW_LINE modInverse ( a , m ) NEW_LINE"],"references":["def __gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return __gcd ( b , a % b ) NEW_LINE DEDENT DEDENT def power ( x , y , m ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT p = power ( x , y \/\/ 2 , m ) % m NEW_LINE p = ( p * p ) % m NEW_LINE return p if ( y % 2 == 0 ) else ( x * p ) % m NEW_LINE DEDENT def modInverse ( a , m ) : NEW_LINE INDENT if ( __gcd ( a , m ) != 1 ) : NEW_LINE INDENT print ( \" Inverse ▁ doesn ' t ▁ exist \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Modular ▁ multiplicative ▁ inverse ▁ is ▁ \" , power ( a , m - 2 , m ) ) NEW_LINE DEDENT DEDENT a = 3 NEW_LINE m = 11 NEW_LINE modInverse ( a , m ) NEW_LINE"],"bleu":0.7431041540690091,"rouge_l":0.7409326424870466}
{"id":965,"predictions":["from math import * NEW_LINE def countPrimeFactors ( x ) : NEW_LINE INDENT res = 0 NEW_LINE if ( x % 2 == 0 ) : NEW_LINE INDENT res += 1 NEW_LINE while ( x % 2 == 0 ) : NEW_LINE INDENT x = x \/\/ 2 NEW_LINE DEDENT DEDENT for i in range ( 3 , int ( sqrt ( x ) ) + 1 , 2 ) : NEW_LINE INDENT if ( x % 2 == 0 ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT for i in range ( 3 , int ( sqrt ( x ) ) , 2 ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT res += 1 NEW_LINE while ( x % i == 0 ) : NEW_LINE INDENT x = x \/\/ i NEW_LINE DEDENT DEDENT DEDENT if ( x > 2 ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT def countCommonPrimeFactors ( a , b ) : NEW_LINE INDENT gcd = gcd ( a , b ) NEW_LINE return countPrimeFactors ( gcd ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 6 NEW_LINE b = 12 NEW_LINE print ( countCommonPrimeFactors ( a , b ) ) NEW_LINE DEDENT"],"references":["from math import sqrt , gcd NEW_LINE def countPrimeFactors ( x ) : NEW_LINE INDENT res = 0 NEW_LINE if ( x % 2 == 0 ) : NEW_LINE INDENT res += 1 NEW_LINE while ( x % 2 == 0 ) : NEW_LINE INDENT x = x \/ 2 NEW_LINE DEDENT DEDENT k = int ( sqrt ( x ) ) + 1 NEW_LINE for i in range ( 3 , k , 2 ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT res += 1 NEW_LINE while ( x % i == 0 ) : NEW_LINE INDENT x = x \/ i NEW_LINE DEDENT DEDENT DEDENT if ( x > 2 ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT def countCommonPrimeFactors ( a , b ) : NEW_LINE INDENT gcd__ = gcd ( a , b ) NEW_LINE return countPrimeFactors ( gcd__ ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 6 NEW_LINE b = 12 NEW_LINE print ( countCommonPrimeFactors ( a , b ) ) NEW_LINE DEDENT"],"bleu":0.7354705828598656,"rouge_l":0.8781237363526082}
{"id":966,"predictions":["def factorial ( n ) : NEW_LINE INDENT return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 ) ; NEW_LINE DEDENT num = 5 ; NEW_LINE print ( \" Factorial ▁ of \" , num , \" is \" , factorial ( num ) ) ; NEW_LINE"],"references":["def factorial ( n ) : NEW_LINE INDENT return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 ) NEW_LINE DEDENT num = 5 NEW_LINE print ( \" Factorial ▁ of \" , num , \" is \" , factorial ( num ) ) NEW_LINE"],"bleu":0.8804416897348929,"rouge_l":0.9781341107871719}
{"id":967,"predictions":["def getFirstDigit ( x ) : NEW_LINE INDENT while ( x >= 10 ) : NEW_LINE INDENT x = x \/\/ 10 NEW_LINE DEDENT return x NEW_LINE DEDENT def getCountWithSameStartAndEnd ( x ) : NEW_LINE INDENT if ( x < 10 ) : NEW_LINE INDENT return x NEW_LINE DEDENT tens = int ( x \/ 10 ) NEW_LINE res = tens + 9 NEW_LINE firstDigit = getFirstDigit ( x ) NEW_LINE lastDigit = x % 10 NEW_LINE if ( lastDigit < firstDigit ) : NEW_LINE INDENT res -= 1 NEW_LINE DEDENT return res NEW_LINE DEDENT def getCountWithSameStartAndEnd ( start , end ) : NEW_LINE INDENT return getCountWithSameStartAndEnd ( end ) - getCountWith1 ( start - 1 ) ) NEW_LINE DEDENT start = 5 NEW_LINE end = 40 NEW_LINE print ( getCountWithSameStart ( start , end ) ) NEW_LINE"],"references":["def getFirstDigit ( x ) : NEW_LINE INDENT while ( x >= 10 ) : NEW_LINE INDENT x \/= 10 NEW_LINE DEDENT return x NEW_LINE DEDENT def getCountWithSameStartAndEndFrom1 ( x ) : NEW_LINE INDENT if ( x < 10 ) : NEW_LINE INDENT return x NEW_LINE DEDENT tens = x \/ 10 NEW_LINE res = tens + 9 NEW_LINE firstDigit = getFirstDigit ( x ) NEW_LINE lastDigit = x % 10 NEW_LINE if ( lastDigit < firstDigit ) : NEW_LINE INDENT res = res - 1 NEW_LINE DEDENT return res NEW_LINE DEDENT def getCountWithSameStartAndEnd ( start , end ) : NEW_LINE INDENT return ( getCountWithSameStartAndEndFrom1 ( end ) - getCountWithSameStartAndEndFrom1 ( start - 1 ) ) NEW_LINE DEDENT start = 5 NEW_LINE end = 40 NEW_LINE print ( getCountWithSameStartAndEnd ( start , end ) ) NEW_LINE"],"bleu":0.8378269783182833,"rouge_l":0.9282290917804936}
{"id":968,"predictions":["def find_number ( N , K ) : NEW_LINE INDENT if ( N % 100 == 0 ) : NEW_LINE INDENT N += 1 NEW_LINE r = str ( N ) NEW_LINE DEDENT else : NEW_LINE INDENT r = str ( N ) NEW_LINE DEDENT for i in range ( 1 , K + 1 ) : NEW_LINE INDENT r += \"00\" NEW_LINE DEDENT return r NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 1000 NEW_LINE K = 2 NEW_LINE ans = find_number ( N , K ) NEW_LINE print ( ans ) NEW_LINE DEDENT"],"references":["def find_number ( N , K ) : NEW_LINE INDENT r = \" \" NEW_LINE if ( N % 100 == 0 ) : NEW_LINE INDENT N += 1 ; NEW_LINE r = str ( N ) NEW_LINE DEDENT else : NEW_LINE INDENT r = str ( N ) NEW_LINE DEDENT for i in range ( 1 , K + 1 ) : NEW_LINE INDENT r += \"00\" NEW_LINE DEDENT return r NEW_LINE DEDENT N = 1000 NEW_LINE K = 2 ; NEW_LINE ans = find_number ( N , K ) NEW_LINE print ( ans ) NEW_LINE"],"bleu":0.8115517531920823,"rouge_l":0.9011818778726198}
{"id":969,"predictions":["def digitSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while n > 0 : NEW_LINE INDENT sum += n % 10 NEW_LINE n = n \/\/ 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT def totalPairs ( arr1 , arr2 , n , m ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if digitSum ( arr1 [ i ] ) == digitSum ( arr2 [ j ] ) : NEW_LINE INDENT s [ ( arr1 [ i ] , arr2 [ j ] ) ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT s [ ( arr2 [ j ] , arr1 [ i ] ) ] = 1 NEW_LINE DEDENT DEDENT DEDENT return len ( s ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr1 = [ 100 , 3 , 7 , 50 ] NEW_LINE arr2 = [ 5 , 1 , 10 , 4 ] NEW_LINE n = len ( arr1 ) NEW_LINE m = len ( arr2 ) NEW_LINE print ( totalPairs ( arr1 , arr2 , n , m ) ) NEW_LINE DEDENT"],"references":["def digitSum ( n ) : NEW_LINE INDENT Sum = 0 NEW_LINE while n > 0 : NEW_LINE INDENT Sum += n % 10 NEW_LINE n = n \/\/ 10 NEW_LINE DEDENT return Sum NEW_LINE DEDENT def totalPairs ( arr1 , arr2 , n , m ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , m ) : NEW_LINE INDENT if digitSum ( arr1 [ i ] ) == digitSum ( arr2 [ j ] ) : NEW_LINE INDENT if arr1 [ i ] < arr2 [ j ] : NEW_LINE INDENT s . add ( ( arr1 [ i ] , arr2 [ j ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT s . add ( ( arr2 [ j ] , arr1 [ i ] ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return len ( s ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr1 = [ 100 , 3 , 7 , 50 ] NEW_LINE arr2 = [ 5 , 1 , 10 , 4 ] NEW_LINE n = len ( arr1 ) NEW_LINE m = len ( arr2 ) NEW_LINE print ( totalPairs ( arr1 , arr2 , n , m ) ) NEW_LINE DEDENT"],"bleu":0.8130611587955258,"rouge_l":0.9019913805914697}
{"id":970,"predictions":["N = 5 NEW_LINE def func ( idx , cur , a , dp , n , x ) : NEW_LINE INDENT if ( idx == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ idx ] [ cur ] != - 1 ) : NEW_LINE INDENT return dp [ idx ] [ cur ] NEW_LINE DEDENT ans = 0 NEW_LINE if ( cur == 0 ) : NEW_LINE INDENT ans = max ( ans , a [ idx ] + func ( idx + 1 , 0 , a , dp , n , x ) ) NEW_LINE ans = max ( ans , a [ idx ] + func ( idx + 1 , 1 , a , dp , n , x ) ) NEW_LINE DEDENT elif ( cur == 1 ) : NEW_LINE INDENT ans = max ( ans , x * a [ idx ] + func ( idx + 1 , 1 , a , dp , n , x ) ) NEW_LINE ans = max ( ans , a [ idx ] + func ( idx + 1 , 2 , a , dp , n , x ) ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( ans , a [ idx ] + func ( idx + 1 , 2 , a , dp , n , x ) ) NEW_LINE DEDENT dp [ idx ] [ cur ] = ans NEW_LINE return dp [ idx ] [ cur ] NEW_LINE DEDENT def getMaximumSum ( a , n , x ) : NEW_LINE INDENT dp = [ x ] * 3 NEW_LINE return dp [ idx ] [ d ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ - 3 , 8 , - 2 , 1 , - 6 ] NEW_LINE n = len ( a ) NEW_LINE x = - 1 NEW_LINE print ( getMaximumSum ( a , n , x ) ) NEW_LINE DEDENT"],"references":["N = 5 NEW_LINE def func ( idx , cur , a , dp , n , x ) : NEW_LINE INDENT if ( idx == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ idx ] [ cur ] != - 1 ) : NEW_LINE INDENT return dp [ idx ] [ cur ] NEW_LINE DEDENT ans = 0 NEW_LINE if ( cur == 0 ) : NEW_LINE INDENT ans = max ( ans , a [ idx ] + func ( idx + 1 , 0 , a , dp , n , x ) ) NEW_LINE ans = max ( ans , x * a [ idx ] + func ( idx + 1 , 1 , a , dp , n , x ) ) NEW_LINE DEDENT elif ( cur == 1 ) : NEW_LINE INDENT ans = max ( ans , x * a [ idx ] + func ( idx + 1 , 1 , a , dp , n , x ) ) NEW_LINE ans = max ( ans , a [ idx ] + func ( idx + 1 , 2 , a , dp , n , x ) ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( ans , a [ idx ] + func ( idx + 1 , 2 , a , dp , n , x ) ) NEW_LINE DEDENT dp [ idx ] [ cur ] = ans NEW_LINE return dp [ idx ] [ cur ] NEW_LINE DEDENT def getMaximumSum ( a , n , x ) : NEW_LINE INDENT dp = [ [ - 1 for i in range ( 3 ) ] for j in range ( n ) ] NEW_LINE maxi = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT maxi = max ( maxi , func ( i , 0 , a , dp , n , x ) ) NEW_LINE DEDENT return maxi NEW_LINE DEDENT a = [ - 3 , 8 , - 2 , 1 , - 6 ] NEW_LINE n = len ( a ) NEW_LINE x = - 1 NEW_LINE print ( getMaximumSum ( a , n , x ) ) NEW_LINE"],"bleu":0.8312487035463754,"rouge_l":0.8809459337485332}
{"id":971,"predictions":["def exponent ( A , B ) : NEW_LINE INDENT if ( A == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( B == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT y = 0 NEW_LINE if ( B % 2 == 0 ) : NEW_LINE INDENT y = exponent ( A , B \/ 2 ) NEW_LINE y = ( y * y ) NEW_LINE DEDENT else : NEW_LINE INDENT y = A NEW_LINE y = ( y * exponent ( A , B - 1 ) ) NEW_LINE DEDENT return y NEW_LINE DEDENT def sum ( k , n ) : NEW_LINE INDENT sum = exponent ( k , n + 1 ) - exponent ( k - 1 , n + 1 ) NEW_LINE return sum NEW_LINE DEDENT n = 3 NEW_LINE K = 3 NEW_LINE print ( sum ( K , n ) ) NEW_LINE"],"references":["def exponent ( A , B ) : NEW_LINE INDENT if ( A == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( B == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT if ( B % 2 == 0 ) : NEW_LINE INDENT y = exponent ( A , B \/ 2 ) ; NEW_LINE y = ( y * y ) ; NEW_LINE DEDENT else : NEW_LINE INDENT y = A ; NEW_LINE y = ( y * exponent ( A , B - 1 ) ) ; NEW_LINE DEDENT return y ; NEW_LINE DEDENT def sum ( k , n ) : NEW_LINE INDENT sum = exponent ( k , n + 1 ) - exponent ( k - 1 , n + 1 ) ; NEW_LINE return sum ; NEW_LINE DEDENT n = 3 ; NEW_LINE K = 3 ; NEW_LINE print ( sum ( K , n ) ) ; NEW_LINE"],"bleu":0.8039854411923001,"rouge_l":0.9447042926930672}
{"id":972,"predictions":["import math NEW_LINE MAX = 10000 ; NEW_LINE primes = [ ] ; NEW_LINE def sieve ( ) : NEW_LINE INDENT n = MAX ; NEW_LINE nNew = int ( ( n ) \/ 2 ) ; NEW_LINE marked = [ False ] * ( nNew + 100 ) ; NEW_LINE tmp = int ( math . sqrt ( n ) ) ; NEW_LINE for i in range ( 1 , int ( ( tmp - 1 ) \/ 2 ) + 1 ) : NEW_LINE INDENT for j in range ( ( ( i * ( i + 1 ) ) << 1 ) , nNew + 1 ) : NEW_LINE INDENT marked [ j ] = True ; NEW_LINE DEDENT DEDENT primes . append ( 2 ) ; NEW_LINE for i in range ( 1 , nNew + 1 ) : NEW_LINE INDENT if ( marked [ i ] == False ) : NEW_LINE INDENT primes . append ( 2 * i + 1 ) ; NEW_LINE DEDENT DEDENT DEDENT def primeLcm ( arr , n ) : NEW_LINE INDENT factors = [ 0 ] * MAX ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT copy = arr [ i ] ; NEW_LINE sqr = int ( math . sqrt ( copy ) ) ; NEW_LINE for j in range ( 0 , sqrt ) : NEW_LINE INDENT if ( copy % primes [ j ] == 0 ) : NEW_LINE INDENT while ( copy % primes [ j ] == 0 ) : NEW_LINE INDENT copy = copy \/\/ primes [ j ] ; NEW_LINE DEDENT factors [ primes [ j ] ] = 1 ; NEW_LINE DEDENT DEDENT if ( copy > 1 ) : NEW_LINE INDENT factors [ copy ] = 1 ; NEW_LINE DEDENT DEDENT if ( copy > 1 ) : NEW_LINE INDENT print ( \"2 ▁ \" , end = \" ▁ \" ) ; NEW_LINE DEDENT for i in range ( 3 , MAX , 2 ) : NEW_LINE INDENT if ( factors [ i ] == 1 ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT DEDENT sieve"],"references":["import math ; NEW_LINE MAX = 10000 ; NEW_LINE primes = [ ] ; NEW_LINE def sieve ( ) : NEW_LINE INDENT n = MAX ; NEW_LINE nNew = int ( n \/ 2 ) ; NEW_LINE marked = [ False ] * ( nNew + 100 ) ; NEW_LINE tmp = int ( math . sqrt ( n ) ) ; NEW_LINE for i in range ( 1 , int ( ( tmp - 1 ) \/ 2 ) + 1 ) : NEW_LINE INDENT for j in range ( ( i * ( i + 1 ) ) << 1 , nNew + 1 , 2 * i + 1 ) : NEW_LINE INDENT marked [ j ] = True ; NEW_LINE DEDENT DEDENT primes . append ( 2 ) ; NEW_LINE for i in range ( 1 , nNew + 1 ) : NEW_LINE INDENT if ( marked [ i ] == False ) : NEW_LINE INDENT primes . append ( 2 * i + 1 ) ; NEW_LINE DEDENT DEDENT DEDENT def primeLcm ( arr , n ) : NEW_LINE INDENT factors = [ 0 ] * ( MAX ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT copy = arr [ i ] ; NEW_LINE sqr = int ( math . sqrt ( copy ) ) ; NEW_LINE j = 0 ; NEW_LINE while ( primes [ j ] <= sqr ) : NEW_LINE INDENT if ( copy % primes [ j ] == 0 ) : NEW_LINE INDENT while ( copy % primes [ j ] == 0 ) : NEW_LINE INDENT copy = int ( copy \/ primes [ j ] ) ; NEW_LINE DEDENT factors [ primes [ j ] ] = 1 ; NEW_LINE DEDENT j += 1 ; NEW_LINE DEDENT if ( copy > 1 ) : NEW_LINE INDENT factors [ copy ] = 1 ; NEW_LINE DEDENT DEDENT if ( factors [ 2 ] == 1 ) : NEW_LINE INDENT print ( \"2 ▁ \" , end = \" \" ) ; NEW_LINE DEDENT for i in range ( 3 , MAX + 1 , 2 ) : NEW_LINE INDENT if ( factors [ i ] == 1 ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT DEDENT sieve ( ) ; NEW_LINE arr = [ 20 , 10 , 15 , 60 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE primeLcm ( arr , n ) ; NEW_LINE"],"bleu":0.7878688067941096,"rouge_l":0.8848482385924993}
{"id":973,"predictions":["import math NEW_LINE def Almuin ( n ) : NEW_LINE INDENT ans = n ; NEW_LINE ans = round ( ( ( axn * _n ) \/ 12 ) - floor ( _n \/ 4 ) * floor ( ( _n + 2 ) \/ 4 ) ) ; NEW_LINE return ans ; NEW_LINE DEDENT def solve ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( Almuin ( i ) , end = \" , ▁ \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 15 ; NEW_LINE solve ( n ) ; NEW_LINE DEDENT"],"references":["from math import ceil , floor NEW_LINE def Alcuin ( n ) : NEW_LINE INDENT _n = n NEW_LINE ans = 0 NEW_LINE ans = ( round ( ( _n * _n ) \/ 12 ) - floor ( _n \/ 4 ) * floor ( ( _n + 2 ) \/ 4 ) ) NEW_LINE return ans NEW_LINE DEDENT def solve ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( Alcuin ( i ) , end = \" , ▁ \" ) NEW_LINE DEDENT DEDENT n = 15 NEW_LINE solve ( n ) NEW_LINE"],"bleu":0.6345102484088463,"rouge_l":0.8324622531939605}
{"id":974,"predictions":["def getMSB ( n ) : NEW_LINE INDENT n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE return ( ( n + 1 ) >> 2 ) NEW_LINE DEDENT def multiply ( F , M ) : NEW_LINE INDENT x = ( F [ 0 ] [ 0 ] * M [ 0 ] [ 0 ] + F [ 0 ] [ 1 ] * M [ 1 ] [ 0 ] ) NEW_LINE y = ( F [ 0 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 0 ] [ 1 ] * M [ 1 ] [ 1 ] ) NEW_LINE z = ( F [ 1 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 0 ] ) NEW_LINE w = ( F [ 1 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 1 ] ) NEW_LINE w = ( F [ 1 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 1 ] ) NEW_LINE F [ 0 ] [ 0 ] = x NEW_LINE F [ 1 ] [ 0 ] = y NEW_LINE DEDENT def power ( F , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT M = [ [ 1 , 1 ] , [ 1 , 0 ] , [ 1 , 0 ] ] NEW_LINE return F [ 0 ] [ 0 ] NEW_LINE DEDENT def fib ( n ) : NEW_LINE INDENT F = [ [ 1 , 1 ] , [ 1 , 0 ] ] NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT power ( F , n - 1 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 6 NEW_LINE print ( fib ( n ) ) NEW_LINE DEDENT"],"references":["def getMSB ( n ) : NEW_LINE INDENT n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE return ( ( n + 1 ) >> 2 ) NEW_LINE DEDENT def multiply ( F , M ) : NEW_LINE INDENT x = F [ 0 ] [ 0 ] * M [ 0 ] [ 0 ] + F [ 0 ] [ 1 ] * M [ 1 ] [ 0 ] NEW_LINE y = F [ 0 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 0 ] [ 1 ] * M [ 1 ] [ 1 ] NEW_LINE z = F [ 1 ] [ 0 ] * M [ 0 ] [ 0 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 0 ] NEW_LINE w = F [ 1 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 1 ] NEW_LINE F [ 0 ] [ 0 ] = x NEW_LINE F [ 0 ] [ 1 ] = y NEW_LINE F [ 1 ] [ 0 ] = z NEW_LINE F [ 1 ] [ 1 ] = w NEW_LINE DEDENT def power ( F , n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT M = [ [ 1 , 1 ] , [ 1 , 0 ] ] NEW_LINE m = getMSB ( n ) NEW_LINE while m : NEW_LINE INDENT multiply ( F , F ) NEW_LINE if ( n & m ) : NEW_LINE INDENT multiply ( F , M ) NEW_LINE DEDENT m = m >> 1 NEW_LINE DEDENT DEDENT def fib ( n ) : NEW_LINE INDENT F = [ [ 1 , 1 ] , [ 1 , 0 ] ] NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT power ( F , n - 1 ) NEW_LINE return F [ 0 ] [ 0 ] NEW_LINE DEDENT n = 6 NEW_LINE print ( fib ( n ) ) NEW_LINE"],"bleu":0.8140195211779975,"rouge_l":0.8302784852406998}
{"id":975,"predictions":["import sys NEW_LINE def printMinIndexChar ( str , patt ) : NEW_LINE INDENT minIndex = sys . maxsize NEW_LINE m = len ( str ) NEW_LINE n = len ( patt ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( patt [ i ] == str [ j ] and j < minIndex ) : NEW_LINE INDENT minIndex = j NEW_LINE break NEW_LINE DEDENT DEDENT if ( minIndex != sys . maxsize ) : NEW_LINE INDENT print ( \" Minimum ▁ Index ▁ Character ▁ = \" , str [ minIndex ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No ▁ character ▁ = \" , str [ minIndex ] ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeksforgeeks \" NEW_LINE patt = \" set \" NEW_LINE printMinIndexCharChar ( str , patt ) NEW_LINE DEDENT"],"references":["def printMinIndexChar ( Str , patt ) : NEW_LINE INDENT minIndex = 10 ** 9 NEW_LINE m = len ( Str ) NEW_LINE n = len ( patt ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( patt [ i ] == Str [ j ] and j < minIndex ) : NEW_LINE INDENT minIndex = j NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if ( minIndex != 10 ** 9 ) : NEW_LINE INDENT print ( \" Minimum ▁ Index ▁ Character ▁ = ▁ \" , Str [ minIndex ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No ▁ character ▁ present \" ) NEW_LINE DEDENT DEDENT Str = \" geeksforgeeks \" NEW_LINE patt = \" set \" NEW_LINE printMinIndexChar ( Str , patt ) NEW_LINE"],"bleu":0.677588124384929,"rouge_l":0.8420545746388444}
{"id":976,"predictions":["import math NEW_LINE def squares ( l , b , a ) : NEW_LINE INDENT return ( math . ceil ( l \/ a ) * math . ceil ( b \/ a ) ) NEW_LINE DEDENT l = 11 NEW_LINE b = 23 NEW_LINE a = 14 NEW_LINE print ( squares ( l , b , a ) ) NEW_LINE"],"references":["import math NEW_LINE def squares ( l , b , a ) : NEW_LINE INDENT return math . ceil ( l \/ a ) * math . ceil ( b \/ a ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT l = 11 NEW_LINE b = 23 NEW_LINE a = 14 NEW_LINE print ( squares ( l , b , a ) ) NEW_LINE DEDENT"],"bleu":0.745078134146624,"rouge_l":0.8666024560558632}
{"id":977,"predictions":["def insert ( self , new_data ) : NEW_LINE INDENT new_node = Node ( data = new_data ) NEW_LINE new_node . prev = None NEW_LINE new_node . next = None NEW_LINE if head is None : NEW_LINE INDENT new_node . prev = None NEW_LINE head = new_node NEW_LINE return NEW_LINE DEDENT while last . next != None : NEW_LINE INDENT last = last . next NEW_LINE DEDENT last . next = new_node NEW_LINE new_node . prev = last NEW_LINE new_node . prev = last NEW_LINE return NEW_LINE DEDENT while last . next != None : NEW_LINE INDENT last = last . next NEW_LINE DEDENT last . next = new_node NEW_LINE new_node . prev = new_node NEW_LINE new_node . prev = last NEW_LINE DEDENT while last . next != None : NEW_LINE INDENT last = last . next NEW_LINE DEDENT last . next = new_node NEW_LINE new_node . next = last NEW_LINE return last NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT"],"references":["def append ( self , new_data ) : NEW_LINE INDENT new_node = Node ( data = new_data ) NEW_LINE last = self . head NEW_LINE new_node . next = None NEW_LINE if self . head is None : NEW_LINE INDENT new_node . prev = None NEW_LINE self . head = new_node NEW_LINE return NEW_LINE DEDENT while ( last . next is not None ) : NEW_LINE INDENT last = last . next NEW_LINE DEDENT last . next = new_node NEW_LINE new_node . prev = last NEW_LINE DEDENT"],"bleu":0.3841993180586156,"rouge_l":0.615657392253137}
{"id":978,"predictions":["def maxProductSum ( str , m ) : NEW_LINE INDENT n = len ( str ) NEW_LINE maxProd = - 10 ** 9 NEW_LINE maxSum = - 10 ** 9 NEW_LINE for i in range ( n - m ) : NEW_LINE INDENT product = 1 NEW_LINE sum = 0 NEW_LINE for j in range ( i , m + i ) : NEW_LINE INDENT product = product * ( ord ( str [ j ] ) - ord ( '0' ) ) NEW_LINE sum = sum + ( ord ( str [ j ] ) - ord ( '0' ) ) NEW_LINE DEDENT maxProd = max ( maxProd , product ) NEW_LINE maxSum = max ( maxSum , sum ) NEW_LINE DEDENT print ( \" Maximum ▁ Product ▁ = \" , maxProd ) NEW_LINE print ( \" Maximum ▁ Sum ▁ = \" , maxSum ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \"3675356291\" NEW_LINE m = 5 NEW_LINE maxProductSum ( str , m ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE def maxProductSum ( string , m ) : NEW_LINE INDENT n = len ( string ) NEW_LINE maxProd , maxSum = ( - ( sys . maxsize ) - 1 , - ( sys . maxsize ) - 1 ) NEW_LINE for i in range ( n - m ) : NEW_LINE INDENT product , sum = 1 , 0 NEW_LINE for j in range ( i , m + i ) : NEW_LINE INDENT product = product * ( ord ( string [ j ] ) - ord ( '0' ) ) NEW_LINE sum = sum + ( ord ( string [ j ] ) - ord ( '0' ) ) NEW_LINE DEDENT maxProd = max ( maxProd , product ) NEW_LINE maxSum = max ( maxSum , sum ) NEW_LINE DEDENT print ( \" Maximum ▁ Product ▁ = \" , maxProd ) NEW_LINE print ( \" Maximum ▁ sum ▁ = \" , maxSum ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \"3675356291\" NEW_LINE m = 5 NEW_LINE maxProductSum ( string , m ) NEW_LINE DEDENT"],"bleu":0.7452710497456585,"rouge_l":0.8571177658733643}
{"id":979,"predictions":["def findMagicNumber ( n ) : NEW_LINE INDENT temp = n NEW_LINE sum = 0 NEW_LINE while temp != 0 : NEW_LINE INDENT sum += temp % 10 NEW_LINE temp = temp \/\/ 10 NEW_LINE DEDENT if sum < 10 : NEW_LINE INDENT print ( n , sum ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n , \"0\" ) NEW_LINE DEDENT DEDENT n = 98765932 NEW_LINE findPhoneNumber ( n ) NEW_LINE"],"references":["def findPhoneNumber ( n ) : NEW_LINE INDENT temp = n NEW_LINE sum = 0 NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT sum += temp % 10 NEW_LINE temp = temp \/\/ 10 NEW_LINE DEDENT if ( sum < 10 ) : NEW_LINE INDENT print ( n , \"0\" , sum ) NEW_LINE DEDENT else : NEW_LINE INDENT n = str ( n ) NEW_LINE sum = str ( sum ) NEW_LINE n += sum NEW_LINE print ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 98765432 NEW_LINE findPhoneNumber ( n ) NEW_LINE DEDENT"],"bleu":0.46656426466583945,"rouge_l":0.7321273264915636}
{"id":980,"predictions":["import sys NEW_LINE def countOfSubarrays ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE v = [ 1 for i in range ( n + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT v [ arr [ i ] ] = i NEW_LINE DEDENT maximum = - sys . maxsize NEW_LINE minimum = sys . maxsize NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT maximum = max ( maximum , v [ i ] ) NEW_LINE minimum = min ( minimum , v [ i ] ) NEW_LINE if maximum - minimum < i : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 1 , 3 , 2 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countOfSubarrays ( arr , n ) ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE INT_MAX = sys . maxsize ; NEW_LINE INT_MIN = - ( sys . maxsize - 1 ) ; NEW_LINE def countOfSubarrays ( arr , n ) : NEW_LINE INDENT count = 0 ; NEW_LINE v = [ 0 ] * ( n + 1 ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT v [ arr [ i ] ] = i ; NEW_LINE DEDENT maximum = INT_MIN ; NEW_LINE minimum = INT_MAX ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT maximum = max ( maximum , v [ i ] ) ; NEW_LINE minimum = min ( minimum , v [ i ] ) ; NEW_LINE if ( maximum - minimum < i ) : NEW_LINE INDENT count = count + 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 4 , 1 , 3 , 2 , 5 , 6 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( countOfSubarrays ( arr , n ) ) ; NEW_LINE DEDENT"],"bleu":0.6730401681160921,"rouge_l":0.8406776685393258}
{"id":981,"predictions":["def maxSum ( p0 , p1 , a , pos + 1 , n ) : NEW_LINE INDENT if ( pos == n ) : NEW_LINE INDENT if ( p0 == p1 ) : NEW_LINE INDENT return p0 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT ans = maxSum ( p0 , p1 , a , pos + 1 , n ) NEW_LINE ans = max ( ans , maxSum ( p0 + a [ pos ] , p1 , pos + 1 , n ) ) NEW_LINE ans = max ( ans , maxSum ( p0 , p1 + a [ pos ] , a , pos + 1 , n ) ) NEW_LINE return ans NEW_LINE DEDENT n = 4 NEW_LINE a = [ 1 , 2 , 3 , 6 ] NEW_LINE print ( maxSum ( 0 , 0 , a , 0 , n ) ) NEW_LINE"],"references":["def maxSum ( p0 , p1 , a , pos , n ) : NEW_LINE INDENT if ( pos == n ) : NEW_LINE INDENT if ( p0 == p1 ) : NEW_LINE INDENT return p0 ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT ans = maxSum ( p0 , p1 , a , pos + 1 , n ) ; NEW_LINE ans = max ( ans , maxSum ( p0 + a [ pos ] , p1 , a , pos + 1 , n ) ) ; NEW_LINE ans = max ( ans , maxSum ( p0 , p1 + a [ pos ] , a , pos + 1 , n ) ) ; NEW_LINE return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 ; NEW_LINE a = [ 1 , 2 , 3 , 6 ] ; NEW_LINE print ( maxSum ( 0 , 0 , a , 0 , n ) ) ; NEW_LINE DEDENT"],"bleu":0.7569248814031843,"rouge_l":0.9070631970260223}
{"id":982,"predictions":["MAXN = 10000000 ; NEW_LINE def minimumSteps ( n , m , a , b ) : NEW_LINE INDENT if ( n > m ) : NEW_LINE INDENT return MAXN ; NEW_LINE DEDENT if ( n == m ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT return min ( 1 + minimumSteps ( n * a , m , a , b ) , 1 + minimumSteps ( n * b , m , a , b ) ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 120 ; m = 51840 ; NEW_LINE a = 2 ; b = 3 ; NEW_LINE print ( minimumSteps ( n , m , a , b ) ) ; NEW_LINE DEDENT"],"references":["MAXN = 10000000 NEW_LINE def minimumSteps ( n , m , a , b ) : NEW_LINE INDENT if ( n > m ) : NEW_LINE INDENT return MAXN NEW_LINE DEDENT if ( n == m ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return min ( 1 + minimumSteps ( n * a , m , a , b ) , 1 + minimumSteps ( n * b , m , a , b ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 120 NEW_LINE m = 51840 NEW_LINE a = 2 NEW_LINE b = 3 NEW_LINE print ( minimumSteps ( n , m , a , b ) ) NEW_LINE DEDENT"],"bleu":0.7831053808605659,"rouge_l":0.9454284970044283}
{"id":983,"predictions":["def printLargestString ( s , l , r ) : NEW_LINE INDENT freq = [ 0 for i in range ( 26 ) ] NEW_LINE l -= 1 NEW_LINE r -= 1 NEW_LINE for i in range ( min ( l , r ) , 1 ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT ans = \" \" NEW_LINE for i in range ( 25 , - 1 , - 1 ) : NEW_LINE INDENT while ( freq [ i ] > 0 ) : NEW_LINE INDENT ans += chr ( ord ( ' a ' ) + i ) NEW_LINE freq [ i ] -= 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" striver \" NEW_LINE l = 3 NEW_LINE r = 5 NEW_LINE print ( printLargestString ( s , l , r ) ) NEW_LINE DEDENT"],"references":["def printLargestString ( s , l , r ) : NEW_LINE INDENT freq = [ 0 ] * 26 NEW_LINE l -= 1 NEW_LINE r -= 1 NEW_LINE for i in range ( min ( l , r ) , max ( l , r ) + 1 ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT ans = \" \" NEW_LINE for i in range ( 25 , - 1 , - 1 ) : NEW_LINE INDENT while ( freq [ i ] ) : NEW_LINE INDENT ans += chr ( ord ( ' a ' ) + i ) NEW_LINE freq [ i ] -= 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" striver \" NEW_LINE l = 3 NEW_LINE r = 5 NEW_LINE print ( printLargestString ( s , l , r ) ) NEW_LINE DEDENT"],"bleu":0.8902533392473813,"rouge_l":0.9356725146198829}
{"id":984,"predictions":["def findSymPairs ( arr ) : NEW_LINE INDENT hM = dict ( ) NEW_LINE for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT first = arr [ i ] [ 0 ] NEW_LINE sec = arr [ i ] [ 1 ] NEW_LINE val = hM [ sec ] [ i ] NEW_LINE if ( val is ( val and val == first ) ) : NEW_LINE INDENT print ( \" ( \" , sec , \" , \" , first , \" ) \" ) NEW_LINE DEDENT else : NEW_LINE INDENT hm [ 0 ] [ 1 ] = sec NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 5 ] for i in range ( 2 ) : NEW_LINE INDENT arr [ 0 ] [ 1 ] = 11 NEW_LINE arr [ 1 ] [ 0 ] = 20 NEW_LINE arr [ 2 ] [ 1 ] = 5 NEW_LINE arr [ 3 ] [ 0 ] = 10 NEW_LINE arr [ 4 ] [ 1 ] = 30 NEW_LINE arr [ 4 ] [ 0 ] = 30 NEW_LINE arr [ 4 ] [ 1 ] = 10 NEW_LINE findMMPairs ( arr ) NEW_LINE DEDENT"],"references":["def findSymPairs ( arr , row ) : NEW_LINE INDENT hM = dict ( ) NEW_LINE for i in range ( row ) : NEW_LINE INDENT first = arr [ i ] [ 0 ] NEW_LINE sec = arr [ i ] [ 1 ] NEW_LINE if ( sec in hM . keys ( ) and hM [ sec ] == first ) : NEW_LINE INDENT print ( \" ( \" , sec , \" , \" , first , \" ) \" ) NEW_LINE DEDENT else : NEW_LINE INDENT hM [ first ] = sec NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ [ 0 for i in range ( 2 ) ] for i in range ( 5 ) ] NEW_LINE arr [ 0 ] [ 0 ] , arr [ 0 ] [ 1 ] = 11 , 20 NEW_LINE arr [ 1 ] [ 0 ] , arr [ 1 ] [ 1 ] = 30 , 40 NEW_LINE arr [ 2 ] [ 0 ] , arr [ 2 ] [ 1 ] = 5 , 10 NEW_LINE arr [ 3 ] [ 0 ] , arr [ 3 ] [ 1 ] = 40 , 30 NEW_LINE arr [ 4 ] [ 0 ] , arr [ 4 ] [ 1 ] = 10 , 5 NEW_LINE findSymPairs ( arr , 5 ) NEW_LINE DEDENT"],"bleu":0.6355413019722854,"rouge_l":0.7515400410677618}
{"id":985,"predictions":["def fact ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT return res NEW_LINE DEDENT def nCr ( n , r ) : NEW_LINE INDENT return fact ( n ) \/\/ ( 1 * fact ( r ) * fact ( n - r ) ) NEW_LINE DEDENT def number_of_subsequences ( arr , k , n ) : NEW_LINE INDENT s = 0 NEW_LINE mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in mp . keys ( ) : NEW_LINE INDENT mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT for j in mp : NEW_LINE INDENT s = s + 1 * nCr ( m [ j ] , k ) NEW_LINE DEDENT return s NEW_LINE DEDENT arr = [ 1 , 1 , 1 , 1 , 2 , 2 , 2 ] NEW_LINE k = 2 NEW_LINE n = len ( arr ) NEW_LINE print ( number_of_subsequences ( arr , k , n ) ) NEW_LINE"],"references":["def fact ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT return res NEW_LINE DEDENT def nCr ( n , r ) : NEW_LINE INDENT return fact ( n ) \/\/ ( fact ( r ) * fact ( n - r ) ) NEW_LINE DEDENT def number_of_subsequences ( arr , k , n ) : NEW_LINE INDENT s = 0 NEW_LINE m = dict ( ) NEW_LINE for i in arr : NEW_LINE INDENT m [ i ] = m . get ( i , 0 ) + 1 NEW_LINE DEDENT for j in m : NEW_LINE INDENT s = s + nCr ( m [ j ] , k ) NEW_LINE DEDENT return s NEW_LINE DEDENT arr = [ 1 , 1 , 1 , 1 , 2 , 2 , 2 ] NEW_LINE k = 2 NEW_LINE n = len ( arr ) NEW_LINE print ( number_of_subsequences ( arr , k , n ) ) NEW_LINE"],"bleu":0.7178013675647908,"rouge_l":0.8680925432756325}
{"id":986,"predictions":["from math import sqrt ; NEW_LINE SIZE = 26 ; NEW_LINE def SieveOfEratosthenes ( prime , p_size ) : NEW_LINE INDENT prime [ 0 ] = False ; NEW_LINE prime [ 1 ] = False ; NEW_LINE for p in range ( 2 , int ( sqrt ( p_size ) ) + 1 ) : NEW_LINE INDENT if ( p * p > p_size ) : NEW_LINE INDENT break ; NEW_LINE DEDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( p * 2 , p_size , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def printChar ( string , n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) ; NEW_LINE SieveOfEratosthenes ( prime , len ( string ) ) ; NEW_LINE freq = [ 0 ] * ( SIZE ) ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT freq [ ord ( string [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( prime [ freq [ ord ( string [ i ] ) - ord ( ' a ' ) ] ] ) : ; NEW_LINE INDENT print ( string [ i ] , end = \" \" ) ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" geeksforgeeks \" ; NEW_LINE n = len ( string ) ; NEW_LINE printChar ( string , n ) ; NEW_LINE DEDENT"],"references":["SIZE = 26 NEW_LINE from math import sqrt NEW_LINE def SieveOfEratosthenes ( prime , p_size ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( sqrt ( p_size ) ) , 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( p * 2 , p_size , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def printChar ( str , n ) : NEW_LINE INDENT prime = [ True for i in range ( n + 1 ) ] NEW_LINE SieveOfEratosthenes ( prime , len ( str ) + 1 ) NEW_LINE freq = [ 0 for i in range ( SIZE ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( prime [ freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] ] ) : NEW_LINE INDENT print ( str [ i ] , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" geeksforgeeks \" NEW_LINE n = len ( str ) NEW_LINE printChar ( str , n ) NEW_LINE DEDENT"],"bleu":0.6762404288831785,"rouge_l":0.8606305974727028}
{"id":987,"predictions":["def calculateSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + ( 1 << i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 10 NEW_LINE print ( \" Sum ▁ of ▁ the ▁ series ▁ : ▁ \" , calculateSum ( n ) ) NEW_LINE"],"references":["def calculateSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum = sum + ( 1 << i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 10 NEW_LINE print ( \" Sum ▁ of ▁ series ▁ \" , calculateSum ( n ) ) NEW_LINE"],"bleu":0.884089786019099,"rouge_l":0.9536388140161726}
{"id":988,"predictions":["def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT def SumOfPrimeDivisors ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 60 NEW_LINE print ( \" Sum ▁ of ▁ prime ▁ divisors ▁ of ▁ 60 ▁ is \" , SumOfPrimeDivisors ( n ) ) NEW_LINE DEDENT"],"references":["N = 1000005 NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT if n <= 3 : NEW_LINE INDENT return True NEW_LINE DEDENT if n % 2 == 0 or n % 3 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT def SumOfPrimeDivisors ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT if isPrime ( i ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT DEDENT return sum NEW_LINE DEDENT n = 60 NEW_LINE print ( \" Sum ▁ of ▁ prime ▁ divisors ▁ of ▁ 60 ▁ is ▁ \" + str ( SumOfPrimeDivisors ( n ) ) ) NEW_LINE"],"bleu":0.787383331738525,"rouge_l":0.8959031177531566}
{"id":989,"predictions":["def elementCount ( arr1 , n1 , arr2 , n2 ) : NEW_LINE INDENT count = 0 NEW_LINE hash = set ( ) NEW_LINE for i in range ( n2 ) : NEW_LINE INDENT hash . add ( arr2 [ i ] ) NEW_LINE DEDENT for i in range ( n1 ) : NEW_LINE INDENT for j in range ( 1 , arr1 [ i ] ) : NEW_LINE INDENT if ( j * j > arr1 [ i ] ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( ( arr1 [ i ] \/\/ j ) and ( arr1 [ i ] \/\/ j ) != 0 ) : NEW_LINE INDENT hash1 = True NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr1 = [ 10 , 2 , 13 , 4 , 15 ] NEW_LINE arr2 = [ 2 , 4 , 5 , 6 ] NEW_LINE n1 = len ( arr1 ) NEW_LINE n1 = len ( arr1 ) NEW_LINE n2 = len ( arr2 ) NEW_LINE print ( elementCount ( arr1 , n1 , arr2 , n2 ) ) NEW_LINE DEDENT"],"references":["from math import sqrt NEW_LINE def elementCount ( arr1 , arr2 ) : NEW_LINE INDENT count = 0 NEW_LINE hash = frozenset ( arr2 ) NEW_LINE for x in arr1 : NEW_LINE INDENT for j in range ( 1 , int ( sqrt ( x ) ) + 1 ) : NEW_LINE INDENT if x % j == 0 : NEW_LINE INDENT if ( j in hash or x \/ j in hash ) : NEW_LINE INDENT count += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT arr1 = [ 10 , 2 , 13 , 4 , 15 ] NEW_LINE arr2 = [ 2 , 4 , 5 , 6 ] NEW_LINE print ( elementCount ( arr1 , arr2 ) ) NEW_LINE"],"bleu":0.3841884586826544,"rouge_l":0.6054116172168826}
{"id":990,"predictions":["def countSubarray ( arr , n , k ) : NEW_LINE INDENT s = 0 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( arr [ i ] > k ) : NEW_LINE INDENT i += 1 NEW_LINE continue NEW_LINE DEDENT count = 0 NEW_LINE while ( i < n and arr [ i ] <= k ) : NEW_LINE INDENT i += 1 NEW_LINE count += 1 NEW_LINE DEDENT s += ( ( count * ( count + 1 ) ) \/ 2 ) NEW_LINE DEDENT return ( n * ( n + 1 ) \/ 2 - s ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 ] NEW_LINE k = 2 NEW_LINE n = len ( arr ) NEW_LINE print ( countSubarray ( arr , n , k ) ) NEW_LINE DEDENT"],"references":["def countSubarray ( arr , n , k ) : NEW_LINE INDENT s = 0 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( arr [ i ] > k ) : NEW_LINE INDENT i = i + 1 NEW_LINE continue NEW_LINE DEDENT count = 0 NEW_LINE while ( i < n and arr [ i ] <= k ) : NEW_LINE INDENT i = i + 1 NEW_LINE count = count + 1 NEW_LINE DEDENT s = s + ( ( count * ( count + 1 ) ) \/\/ 2 ) NEW_LINE DEDENT return ( n * ( n + 1 ) \/\/ 2 - s ) NEW_LINE DEDENT arr = [ 1 , 2 , 3 ] NEW_LINE k = 2 NEW_LINE n = len ( arr ) NEW_LINE print ( countSubarray ( arr , n , k ) ) NEW_LINE"],"bleu":0.8030979571867148,"rouge_l":0.8927465014421536}
{"id":991,"predictions":["def countNum ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( arr [ i ] != arr [ i + 1 ] and arr [ i ] != arr [ i + 1 ] - 1 ) : NEW_LINE INDENT count += arr [ i + 1 ] - arr [ i ] - 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 5 , 8 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countNum ( arr , n ) ) NEW_LINE DEDENT"],"references":["def countNum ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] != arr [ i + 1 ] and arr [ i ] != arr [ i + 1 ] - 1 ) : NEW_LINE INDENT count += arr [ i + 1 ] - arr [ i ] - 1 ; NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 3 , 5 , 8 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countNum ( arr , n ) ) NEW_LINE"],"bleu":0.8542145584628409,"rouge_l":0.9382083108472747}
{"id":992,"predictions":["def max_element ( a , n ) : NEW_LINE INDENT pre = [ 0 ] * n ; NEW_LINE pre [ 0 ] = a [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT pre [ i ] = max ( pre [ i - 1 ] , a [ i ] ) ; NEW_LINE DEDENT suf = [ 0 ] * n ; NEW_LINE suf [ n - 1 ] = a [ n - 1 ] ; NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT suf [ i ] = max ( suf [ i + 1 ] , a [ i ] ) ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT print ( suf [ i + 1 ] , end = \" ▁ \" ) ; NEW_LINE DEDENT elif ( i == n - 1 ) : NEW_LINE INDENT print ( pre [ i - 1 ] , end = \" ▁ \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( max ( pre [ i - 1 ] , suf [ i + 1 ] ) , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 2 , 5 , 6 , 1 , 3 ] ; NEW_LINE n = len ( a ) ; NEW_LINE max_element ( a , n ) ; NEW_LINE DEDENT"],"references":["def max_element ( a , n ) : NEW_LINE INDENT pre = [ 0 ] * n ; NEW_LINE pre [ 0 ] = a [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT pre [ i ] = max ( pre [ i - 1 ] , a [ i ] ) ; NEW_LINE DEDENT suf = [ 0 ] * n ; NEW_LINE suf [ n - 1 ] = a [ n - 1 ] ; NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT suf [ i ] = max ( suf [ i + 1 ] , a [ i ] ) ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT print ( suf [ i + 1 ] , end = \" ▁ \" ) ; NEW_LINE DEDENT elif ( i == n - 1 ) : NEW_LINE INDENT print ( pre [ i - 1 ] , end = \" ▁ \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( max ( pre [ i - 1 ] , suf [ i + 1 ] ) , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 2 , 5 , 6 , 1 , 3 ] ; NEW_LINE n = len ( a ) ; NEW_LINE max_element ( a , n ) ; NEW_LINE DEDENT"],"bleu":1.0,"rouge_l":1.0}
{"id":993,"predictions":["def isRotated ( str1 , str2 ) : NEW_LINE INDENT if ( len ( str1 ) != len ( str2 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT clock_rot = \" \" NEW_LINE occshell_rot = \" \" NEW_LINE length = len ( str2 ) NEW_LINE occclap_rot = ( int ( str2 [ length - 2 : length ) + str2 [ 0 : - 2 ] ) NEW_LINE clock_rot = clock_rot + int ( st2 [ 0 : 2 ] ) NEW_LINE return ( str1 == clock_rot ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = \" geeks \" NEW_LINE str2 = \" eksge \" NEW_LINE if ( isRotated ( str1 , str2 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def isRotated ( str1 , str2 ) : NEW_LINE INDENT if ( len ( str1 ) != len ( str2 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT clock_rot = \" \" NEW_LINE anticlock_rot = \" \" NEW_LINE l = len ( str2 ) NEW_LINE anticlock_rot = ( anticlock_rot + str2 [ l - 2 : ] + str2 [ 0 : l - 2 ] ) NEW_LINE clock_rot = clock_rot + str2 [ 2 : ] + str2 [ 0 : 2 ] NEW_LINE return ( str1 == clock_rot or str1 == anticlock_rot ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" geeks \" NEW_LINE str2 = \" eksge \" NEW_LINE DEDENT if isRotated ( str1 , str2 ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.7165208793521082,"rouge_l":0.868702125364117}
{"id":994,"predictions":["def findMax ( num ) : NEW_LINE INDENT size_of_int = 4 NEW_LINE num_copy = num NEW_LINE j = size_of_int * 8 - 1 NEW_LINE i = 0 NEW_LINE while ( i < j ) : NEW_LINE INDENT m = ( num_copy >> i ) & 1 NEW_LINE n = ( num_copy >> j ) & 1 NEW_LINE if ( m > n ) : NEW_LINE INDENT x = ( 1 << i ) NEW_LINE num = num ^ x NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return num NEW_LINE DEDENT num = 4 NEW_LINE print ( findMax ( num ) ) NEW_LINE"],"references":["def findMax ( num ) : NEW_LINE INDENT num_copy = num NEW_LINE j = 4 * 8 - 1 ; NEW_LINE i = 0 NEW_LINE while ( i < j ) : NEW_LINE INDENT m = ( num_copy >> i ) & 1 NEW_LINE n = ( num_copy >> j ) & 1 NEW_LINE if ( m > n ) : NEW_LINE INDENT x = ( 1 << i | 1 << j ) NEW_LINE num = num ^ x NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return num NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT num = 4 NEW_LINE print ( findMax ( num ) ) NEW_LINE DEDENT"],"bleu":0.7689478387693344,"rouge_l":0.8793890950613759}
{"id":995,"predictions":["def check ( s , l ) : NEW_LINE INDENT pos = [ ] NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT pos . append ( i ) NEW_LINE DEDENT DEDENT t = len ( pos ) NEW_LINE for i in range ( 1 , t ) : NEW_LINE INDENT if ( ( pos [ i ] - pos [ i - 1 ] ) != ( pos [ 1 ] - pos [ 0 ] ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \"100010001000\" NEW_LINE l = len ( s ) NEW_LINE if ( check ( s , l ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def check ( s , l ) : NEW_LINE INDENT pos = [ ] NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT pos . append ( i ) NEW_LINE DEDENT DEDENT t = len ( pos ) NEW_LINE for i in range ( 1 , t ) : NEW_LINE INDENT if ( ( pos [ i ] - pos [ i - 1 ] ) != ( pos [ 1 ] - pos [ 0 ] ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT s = \"100010001000\" NEW_LINE l = len ( s ) NEW_LINE if ( check ( s , l ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.9039403884781372,"rouge_l":0.962678609511623}
{"id":996,"predictions":["def maximum_one ( s , n ) : NEW_LINE INDENT cnt_one = 0 NEW_LINE max_cnt = 0 NEW_LINE temp = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT cnt_one += 1 NEW_LINE temp += 1 NEW_LINE DEDENT else : NEW_LINE INDENT max_cnt = max ( max_cnt , temp ) NEW_LINE temp = 0 NEW_LINE DEDENT DEDENT max_cnt = max ( max_cnt , temp ) NEW_LINE left = [ 0 for i in range ( n ) ] NEW_LINE right = [ 0 for i in range ( n ) ] NEW_LINE if ( s [ 0 ] == '1' ) : NEW_LINE INDENT left [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT left [ 0 ] = 0 NEW_LINE DEDENT if ( s [ n - 1 ] == '1' ) : NEW_LINE INDENT right [ n - 1 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT right [ n - 1 ] = 0 NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT left [ i ] = left [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT left [ i ] = 0 NEW_LINE DEDENT DEDENT for i in range ( n - 2 , - 1 ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT max_cnt [ i ] = right [ i + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT max_cnt = max ( max_cnt , sum ) NEW_LINE DEDENT DEDENT return max_cnt NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \"111011101\" NEW_LINE print ( maximum_one ( s , len ( s ) ) ) NEW_LINE DEDENT"],"references":["def maximum_one ( s , n ) : NEW_LINE INDENT cnt_one = 0 NEW_LINE cnt , max_cnt = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT cnt_one += 1 NEW_LINE cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT max_cnt = max ( max_cnt , cnt ) NEW_LINE cnt = 0 NEW_LINE DEDENT DEDENT max_cnt = max ( max_cnt , cnt ) NEW_LINE left = [ 0 ] * n NEW_LINE right = [ 0 ] * n NEW_LINE if ( s [ 0 ] == '1' ) : NEW_LINE INDENT left [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT left [ 0 ] = 0 NEW_LINE DEDENT if ( s [ n - 1 ] == '1' ) : NEW_LINE INDENT right [ n - 1 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT right [ n - 1 ] = 0 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT left [ i ] = left [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT left [ i ] = 0 NEW_LINE DEDENT DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT right [ i ] = right [ i + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT right [ i ] = 0 NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT sum = left [ i - 1 ] + right [ i + 1 ] NEW_LINE if ( sum < cnt_one ) : NEW_LINE INDENT max_cnt = max ( max_cnt , sum + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT max_cnt = max ( max_cnt , sum ) NEW_LINE DEDENT DEDENT DEDENT return max_cnt NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \"111011101\" NEW_LINE print ( maximum_one ( s , len ( s ) ) ) NEW_LINE DEDENT"],"bleu":0.7253385109178105,"rouge_l":0.8141034311736328}
{"id":997,"predictions":["import math NEW_LINE def nDigitPerfectCubes ( n ) : NEW_LINE INDENT print ( pow ( math . ceil ( math . pow ( 10 , ( n - 1 ) ) ) ) , 3 ) ; NEW_LINE print ( smallest , end = \" ▁ \" ) ; NEW_LINE largest = pow ( math . ceil ( pow ( 10 , ( n ) ) ) - 1 , 3 ) ; NEW_LINE print ( largest ) ; NEW_LINE DEDENT n = 3 ; NEW_LINE nDigitPerfectCubes ( n ) ; NEW_LINE"],"references":["from math import ceil NEW_LINE def nDigitPerfectCubes ( n ) : NEW_LINE INDENT print ( pow ( ceil ( ( pow ( 10 , ( n - 1 ) ) ) ** ( 1 \/ 3 ) ) , 3 ) , end = \" ▁ \" ) NEW_LINE print ( pow ( ceil ( ( pow ( 10 , ( n ) ) ) ** ( 1 \/ 3 ) ) - 1 , 3 ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE nDigitPerfectCubes ( n ) NEW_LINE DEDENT"],"bleu":0.5142016890039002,"rouge_l":0.700565912117177}
{"id":998,"predictions":["def isMultipleof5 ( n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT n <<= 1 NEW_LINE DEDENT x = n NEW_LINE x = ( x * 0.1 ) ) * 10 NEW_LINE if ( x == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT i = 19 NEW_LINE if ( isMultipleof5 ( i ) == 1 ) : NEW_LINE INDENT print ( i , \" is ▁ multiple ▁ of ▁ 5\" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( i , \" is ▁ not ▁ a ▁ multiple ▁ of ▁ 5\" ) NEW_LINE DEDENT"],"references":["def isMultipleof5 ( n ) : NEW_LINE INDENT if ( ( n & 1 ) == 1 ) : NEW_LINE INDENT n <<= 1 ; NEW_LINE DEDENT x = n NEW_LINE x = ( ( int ) ( x * 0.1 ) ) * 10 NEW_LINE if ( x == n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT i = 19 NEW_LINE if ( isMultipleof5 ( i ) == 1 ) : NEW_LINE INDENT print ( i , \" is ▁ multiple ▁ of ▁ 5\" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( i , \" is ▁ not ▁ a ▁ multiple ▁ of ▁ 5\" ) NEW_LINE DEDENT"],"bleu":0.8519129981927461,"rouge_l":0.9354745370370371}
{"id":999,"predictions":["def minsteps ( n , m ) : NEW_LINE INDENT if ( m > n ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( n + 1 ) \/\/ 2 + m - 1 ) \/\/ m * m ; NEW_LINE DEDENT DEDENT n = 17 ; m = 4 ; NEW_LINE ans = minsteps ( n , m ) ; NEW_LINE print ( ans ) ; NEW_LINE"],"references":["def minsteps ( n , m ) : NEW_LINE INDENT if ( m > n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( n + 1 ) \/\/ 2 + m - 1 ) \/\/ m * m ; NEW_LINE DEDENT DEDENT n = 17 NEW_LINE m = 4 NEW_LINE ans = minsteps ( n , m ) NEW_LINE print ( ans ) NEW_LINE"],"bleu":0.8408126719495261,"rouge_l":0.9641585040071238}
{"id":1000,"predictions":["import math NEW_LINE def gridStr ( str ) : NEW_LINE INDENT l = len ( str ) NEW_LINE k = 0 NEW_LINE row = 0 NEW_LINE row = math . floor ( math . sqrt ( l ) ) NEW_LINE if ( row * column < l ) : NEW_LINE INDENT row = column NEW_LINE DEDENT s = [ [ 0 for row in range ( column ) ] for row in range ( row ) ] NEW_LINE for i in range ( 0 , row ) : NEW_LINE INDENT for j in range ( 0 , column ) : NEW_LINE INDENT if ( k < len ( str ) ) : NEW_LINE INDENT s [ i ] [ j ] = str [ k ] NEW_LINE DEDENT k += 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , row ) : NEW_LINE INDENT for j in range ( 0 , column ) : NEW_LINE INDENT if ( s [ i ] [ j ] == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT print ( s [ i ] [ j ] , end = \" \" ) NEW_LINE DEDENT print ( \" \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" GEEKSFORGEEKS \" NEW_LINE gridStr ( str ) NEW_LINE DEDENT"],"references":["from math import sqrt , floor , ceil NEW_LINE def gridStr ( string ) : NEW_LINE INDENT l = len ( string ) NEW_LINE k = 0 NEW_LINE row = floor ( sqrt ( l ) ) NEW_LINE column = ceil ( sqrt ( l ) ) NEW_LINE if ( row * column < l ) : NEW_LINE INDENT row = column NEW_LINE DEDENT s = [ [ 0 for j in range ( column ) ] for i in range ( row ) ] NEW_LINE for i in range ( row ) : NEW_LINE INDENT for j in range ( column ) : NEW_LINE INDENT if k >= l : NEW_LINE INDENT s [ i ] [ j ] = \" ▁ \" NEW_LINE k += 1 NEW_LINE DEDENT else : NEW_LINE INDENT s [ i ] [ j ] = string [ k ] NEW_LINE k += 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( row ) : NEW_LINE INDENT for j in range ( column ) : NEW_LINE INDENT if s [ i ] [ j ] == \" ▁ \" : NEW_LINE INDENT break NEW_LINE DEDENT print ( s [ i ] [ j ] , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" GEEKSFORGEEKS \" NEW_LINE gridStr ( string ) NEW_LINE DEDENT"],"bleu":0.650068483845659,"rouge_l":0.8025192442267319}
{"id":1001,"predictions":["def maxProfit ( prices , start , end ) : NEW_LINE INDENT if ( end <= start ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT profit = 0 NEW_LINE for i in range ( start , end ) : NEW_LINE INDENT for j in range ( i + 1 , end + 1 ) : NEW_LINE INDENT if ( prices [ j ] > price [ i ] ) : NEW_LINE INDENT curr_fit = ( prices [ j ] - prices [ i ] + maxProfit ( prices , start , i - 1 ) + maxProfit ( price , j + 1 , end ) ) NEW_LINE profit = max ( profit , curr_ profit ) NEW_LINE DEDENT DEDENT DEDENT return profit ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT prices = [ 100 , 180 , 260 , 310 , 40 , 535 , 695 ] NEW_LINE n = len ( prices ) NEW_LINE print ( maxProfit ( prices , 0 , n - 1 ) ) NEW_LINE DEDENT"],"references":["def maxProfit ( price , start , end ) : NEW_LINE INDENT if ( end <= start ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT profit = 0 ; NEW_LINE for i in range ( start , end , 1 ) : NEW_LINE INDENT for j in range ( i + 1 , end + 1 ) : NEW_LINE INDENT if ( price [ j ] > price [ i ] ) : NEW_LINE INDENT curr_profit = price [ j ] - price [ i ] + \\ NEW_LINE INDENT maxProfit ( price , start , i - 1 ) +   \\ NEW_LINE maxProfit ( price , j + 1 , end ) ; NEW_LINE DEDENT profit = max ( profit , curr_profit ) ; NEW_LINE DEDENT DEDENT DEDENT return profit ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT price = [ 100 , 180 , 260 , 310 , 40 , 535 , 695 ] ; NEW_LINE n = len ( price ) ; NEW_LINE print ( maxProfit ( price , 0 , n - 1 ) ) ; NEW_LINE DEDENT"],"bleu":0.6836550055045842,"rouge_l":0.8757769412588636}
{"id":1002,"predictions":["def maximum_middle_value ( n , k , arr ) : NEW_LINE INDENT ans = - 1 NEW_LINE low = ( n + 1 - k ) \/\/ 2 NEW_LINE high = ( n + 1 - k ) \/\/ 2 + k NEW_LINE for i in range ( low , high + 1 ) : NEW_LINE INDENT ans = max ( ans , arr [ i - 1 ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT n = 5 NEW_LINE k = 2 NEW_LINE arr = [ 9 , 5 , 3 , 7 , 10 ] NEW_LINE print ( maximum_middle_value ( n , k , arr ) ) NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE arr1 = [ 2 , 4 , 3 , 9 , 5 , 8 , 7 , 6 , 10 ] NEW_LINE print ( maximum_middle_value ( n , k , arr1 ) ) NEW_LINE"],"references":["def maximum_middle_value ( n , k , arr ) : NEW_LINE INDENT ans = - 1 NEW_LINE low = ( n + 1 - k ) \/\/ 2 NEW_LINE high = ( n + 1 - k ) \/\/ 2 + k NEW_LINE for i in range ( low , high + 1 ) : NEW_LINE INDENT ans = max ( ans , arr [ i - 1 ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n , k = 5 , 2 NEW_LINE arr = [ 9 , 5 , 3 , 7 , 10 ] NEW_LINE print ( maximum_middle_value ( n , k , arr ) ) NEW_LINE n , k = 9 , 3 NEW_LINE arr1 = [ 2 , 4 , 3 , 9 , 5 , 8 , 7 , 6 , 10 ] NEW_LINE print ( maximum_middle_value ( n , k , arr1 ) ) NEW_LINE DEDENT"],"bleu":0.8432925813947517,"rouge_l":0.9040706527256115}
{"id":1003,"predictions":["def countRec ( n , sum ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( sum == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT if ( sum - i >= 0 ) : NEW_LINE INDENT ans += countRec ( n - 1 , sum - i ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def finalCount ( n , sum ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT if ( sum - i >= 0 ) : NEW_LINE INDENT ans += countRec ( n - 1 , sum - i ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT n , sum = 2 , 5 NEW_LINE print ( finalCount ( n , sum ) ) NEW_LINE"],"references":["def countRec ( n , sum ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return ( sum == 0 ) NEW_LINE DEDENT if ( sum == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 0 , 10 ) : NEW_LINE INDENT if ( sum - i >= 0 ) : NEW_LINE INDENT ans = ans + countRec ( n - 1 , sum - i ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def finalCount ( n , sum ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT if ( sum - i >= 0 ) : NEW_LINE INDENT ans = ans + countRec ( n - 1 , sum - i ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT n = 2 NEW_LINE sum = 5 NEW_LINE print ( finalCount ( n , sum ) ) NEW_LINE"],"bleu":0.8501808453783012,"rouge_l":0.9255689973344269}
{"id":1004,"predictions":["def calculateSum ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE MOD = 1000000007 NEW_LINE while ( k ) : NEW_LINE INDENT if ( k & 1 ) : NEW_LINE INDENT res = ( res * n ) % MOD NEW_LINE DEDENT k = k \/\/ 2 NEW_LINE n = ( n * n ) % MOD NEW_LINE DEDENT return res NEW_LINE DEDENT n = 4 NEW_LINE k = 3 NEW_LINE print ( calculateSum ( n , k ) ) NEW_LINE"],"references":["def calculateSum ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE MOD = 1000000007 NEW_LINE while k > 0 : NEW_LINE INDENT if ( k & 1 ) == 1 : NEW_LINE INDENT res = ( res * n ) % MOD NEW_LINE DEDENT k = k \/\/ 2 NEW_LINE n = ( n * n ) % MOD NEW_LINE DEDENT return res NEW_LINE DEDENT n = 4 NEW_LINE k = 3 NEW_LINE print ( calculateSum ( n , k ) ) NEW_LINE"],"bleu":0.9082858011025222,"rouge_l":0.9626635873749039}
{"id":1005,"predictions":["def countPairs ( s , K ) : NEW_LINE INDENT if ( K > s or ( s - K ) % 2 == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( ( s - K ) \/\/ 2 == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT setBits = bin ( K ) . count ( '1' ) ; NEW_LINE pairsCount = pow ( 2 , setBits ) ; NEW_LINE if ( s == K ) : NEW_LINE INDENT pairsCount -= 2 ; NEW_LINE DEDENT return pairsCount ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s , K = 9 , 5 ; NEW_LINE print ( countPairs ( s , K ) ) ; NEW_LINE DEDENT"],"references":["def countPairs ( s , K ) : NEW_LINE INDENT if ( K > s or ( s - K ) % 2 == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT setBits = ( str ( bin ( K ) ) [ 2 : ] ) . count ( \"1\" ) NEW_LINE pairsCount = pow ( 2 , setBits ) NEW_LINE if ( s == K ) : NEW_LINE INDENT pairsCount -= 2 NEW_LINE DEDENT return pairsCount NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s , K = 9 , 5 NEW_LINE print ( countPairs ( s , K ) ) NEW_LINE DEDENT"],"bleu":0.6582588488762212,"rouge_l":0.8502323039081716}
{"id":1006,"predictions":["import math NEW_LINE def splitString ( string ) : NEW_LINE INDENT alpha = [ ] NEW_LINE num = [ ] NEW_LINE base = [ ] NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if ( string [ i ] . isdigit ( ) ) : NEW_LINE INDENT num . append ( string [ i ] ) NEW_LINE DEDENT elif ( string [ i ] ) : NEW_LINE INDENT alpha . append ( string [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT final . append ( string [ i ] ) NEW_LINE DEDENT DEDENT print ( num ) NEW_LINE print ( num ) NEW_LINE print ( special ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" geeks01 ^ \" NEW_LINE n = len ( string ) NEW_LINE print ( special ) NEW_LINE DEDENT"],"references":["def splitString ( str ) : NEW_LINE INDENT alpha = \" \" NEW_LINE num = \" \" NEW_LINE special = \" \" NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] . isdigit ( ) ) : NEW_LINE INDENT num = num + str [ i ] NEW_LINE DEDENT elif ( ( str [ i ] >= ' A ' and str [ i ] <= ' Z ' ) or ( str [ i ] >= ' a ' and str [ i ] <= ' z ' ) ) : NEW_LINE INDENT alpha += str [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT special += str [ i ] NEW_LINE DEDENT DEDENT print ( alpha ) NEW_LINE print ( num ) NEW_LINE print ( special ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeks01 $ $ for02geeks03 ! @ ! ! \" NEW_LINE splitString ( str ) NEW_LINE DEDENT"],"bleu":0.4566438557709058,"rouge_l":0.6578789694427802}
{"id":1007,"predictions":["def atMostK ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE left = 0 NEW_LINE right = 0 NEW_LINE result = dict ( ) NEW_LINE while ( right < n ) : NEW_LINE INDENT if arr [ right ] in mp . keys ( ) : NEW_LINE INDENT map [ arr [ right ] ] = map . get ( arr [ left ] , 0 ) + 1 NEW_LINE if ( map [ arr [ left ] ] == 0 ) : NEW_LINE INDENT map [ arr [ left ] ] = 1 NEW_LINE DEDENT left += 1 NEW_LINE right += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def exactK ( arr , n , k ) : NEW_LINE INDENT return ( atMostK ( arr , n , k ) - atMostK ( arr , n , k - 1 ) ) NEW_LINE DEDENT arr = [ 2 , 1 , 2 , 1 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE print ( exactK ( arr , n , k ) ) NEW_LINE"],"references":["def atMostK ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE left = 0 NEW_LINE right = 0 NEW_LINE map = { } NEW_LINE while ( right < n ) : NEW_LINE INDENT if arr [ right ] not in map : NEW_LINE INDENT map [ arr [ right ] ] = 0 NEW_LINE DEDENT map [ arr [ right ] ] += 1 NEW_LINE while ( len ( map ) > k ) : NEW_LINE INDENT if arr [ left ] not in map : NEW_LINE INDENT map [ arr [ left ] ] = 0 NEW_LINE DEDENT map [ arr [ left ] ] -= 1 NEW_LINE if map [ arr [ left ] ] == 0 : NEW_LINE INDENT del map [ arr [ left ] ] NEW_LINE DEDENT left += 1 NEW_LINE DEDENT count += right - left + 1 NEW_LINE right += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def exactlyK ( arr , n , k ) : NEW_LINE INDENT return ( atMostK ( arr , n , k ) - atMostK ( arr , n , k - 1 ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 1 , 2 , 1 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE print ( exactlyK ( arr , n , k ) ) NEW_LINE DEDENT"],"bleu":0.5903065808617883,"rouge_l":0.7528637942502402}
{"id":1008,"predictions":["def display ( n ) : NEW_LINE INDENT sp = n \/\/ 2 NEW_LINE st = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , sp + 1 ) : NEW_LINE INDENT print ( \" ▁ \" , end = \" \" ) NEW_LINE DEDENT count = 1 NEW_LINE for k in range ( 1 , st + 1 ) : NEW_LINE INDENT if ( k % 2 == 0 ) : NEW_LINE INDENT print ( \" * \" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( count , end = \" \" ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE if ( i <= n \/\/ 2 ) : NEW_LINE INDENT sp -= 1 NEW_LINE st = st + 2 NEW_LINE DEDENT else : NEW_LINE INDENT sp += 1 NEW_LINE st = st - 2 NEW_LINE DEDENT DEDENT DEDENT n = 5 NEW_LINE display ( n ) NEW_LINE"],"references":["def display ( n ) : NEW_LINE INDENT sp = n \/\/ 2 NEW_LINE st = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , sp + 1 ) : NEW_LINE INDENT print ( end = \" ▁ \" ) NEW_LINE DEDENT count = 1 NEW_LINE for k in range ( 1 , st + 1 ) : NEW_LINE INDENT if ( k % 2 == 0 ) : NEW_LINE INDENT print ( \" * \" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( count , end = \" \" ) NEW_LINE count += 1 NEW_LINE DEDENT DEDENT print ( ) NEW_LINE if ( i <= n \/\/ 2 ) : NEW_LINE INDENT sp = sp - 1 NEW_LINE st = st + 2 NEW_LINE DEDENT else : NEW_LINE INDENT sp = sp + 1 NEW_LINE st = st - 2 NEW_LINE DEDENT DEDENT DEDENT n = 5 NEW_LINE display ( n ) NEW_LINE"],"bleu":0.9065228176573032,"rouge_l":0.9479454666793784}
{"id":1009,"predictions":["R = 3 NEW_LINE C = 5 NEW_LINE def maxArea ( mat ) : NEW_LINE INDENT hist = [ [ 0 for x + 1 for x in range ( C + 1 ) ] for y in range ( C + 1 ) ] NEW_LINE for i in range ( C ) : NEW_LINE INDENT hist [ 0 ] [ i ] = mat [ 0 ] [ i ] NEW_LINE for j in range ( 1 , R ) : NEW_LINE INDENT if ( mat [ j ] [ i ] == 0 ) : NEW_LINE INDENT hist [ j ] [ i ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT h [ j - 1 ] += 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( R ) : NEW_LINE INDENT count = [ 0 for x in range ( C + 1 ) ] NEW_LINE for j in range ( C , - 1 , - 1 ) : NEW_LINE INDENT if ( count [ j ] > 0 ) : NEW_LINE INDENT for k in range ( count [ i ] [ j ] ) : NEW_LINE INDENT hist [ i ] [ col_no ] = j NEW_LINE col_no += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT curr_area = 0 NEW_LINE for i in range ( R ) : NEW_LINE INDENT for j in range ( C ) : NEW_LINE INDENT curr_area = ( j + 1 ) * hist [ i ] [ j ] NEW_LINE if ( curr_area > max_area ) : NEW_LINE INDENT max_area = curr_area NEW_LINE DEDENT DEDENT DEDENT return max_area NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT mat = [ [ 0 , 1 , 0 , 1 , 0 ] , [ 0 , 1 , 0 , 1 , 1 , 0 , 1 , 1 ] , [ 1 , 1 , 0 , 1 , 0 , 1 , 0 ] ] NEW_LINE print ( \" Area ▁ of ▁ the ▁ largest ▁ rectangle ▁ is \" , maxArea ( mat ) ) NEW_LINE DEDENT"],"references":["R = 3 NEW_LINE C = 5 NEW_LINE def maxArea ( mat ) : NEW_LINE INDENT hist = [ [ 0 for i in range ( C + 1 ) ] for i in range ( R + 1 ) ] NEW_LINE for i in range ( 0 , C , 1 ) : NEW_LINE INDENT hist [ 0 ] [ i ] = mat [ 0 ] [ i ] NEW_LINE for j in range ( 1 , R , 1 ) : NEW_LINE INDENT if ( ( mat [ j ] [ i ] == 0 ) ) : NEW_LINE INDENT hist [ j ] [ i ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT hist [ j ] [ i ] = hist [ j - 1 ] [ i ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 0 , R , 1 ) : NEW_LINE INDENT count = [ 0 for i in range ( R + 1 ) ] NEW_LINE for j in range ( 0 , C , 1 ) : NEW_LINE INDENT count [ hist [ i ] [ j ] ] += 1 NEW_LINE DEDENT col_no = 0 NEW_LINE j = R NEW_LINE while ( j >= 0 ) : NEW_LINE INDENT if ( count [ j ] > 0 ) : NEW_LINE INDENT for k in range ( 0 , count [ j ] , 1 ) : NEW_LINE INDENT hist [ i ] [ col_no ] = j NEW_LINE col_no += 1 NEW_LINE DEDENT DEDENT j -= 1 NEW_LINE DEDENT DEDENT max_area = 0 NEW_LINE for i in range ( 0 , R , 1 ) : NEW_LINE INDENT for j in range ( 0 , C , 1 ) : NEW_LINE INDENT curr_area = ( j + 1 ) * hist [ i ] [ j ] NEW_LINE if ( curr_area > max_area ) : NEW_LINE INDENT max_area = curr_area NEW_LINE DEDENT DEDENT DEDENT return max_area NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT mat = [ [ 0 , 1 , 0 , 1 , 0 ] , [ 0 , 1 , 0 , 1 , 1 ] , [ 1 , 1 , 0 , 1 , 0 ] ] NEW_LINE print ( \" Area ▁ of ▁ the ▁ largest ▁ rectangle ▁ is \" , maxArea ( mat ) ) NEW_LINE DEDENT"],"bleu":0.7465676070123999,"rouge_l":0.8506846429323783}
{"id":1010,"predictions":["def lcs ( dp , a , b , m , n ) : NEW_LINE INDENT for i in range ( 100 ) : NEW_LINE INDENT dp [ i ] [ j ] = - 1 NEW_LINE DEDENT if ( m < 0 or n < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ m ] [ n ] != - 1 ) : NEW_LINE INDENT return dp [ m ] [ n ] NEW_LINE DEDENT ans = 0 NEW_LINE if ( a [ m ] == b [ n ] ) : NEW_LINE INDENT ans = ( a [ m ] - 48 ) + lcs ( dp , a , b , m - 1 , n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( lcs ( dp , a , b , m - 1 , n ) , lcs ( dp , a , b , m , n - 1 ) ) NEW_LINE DEDENT dp [ m ] [ n ] = ans NEW_LINE return ans NEW_LINE DEDENT def costOfString ( str ) : NEW_LINE INDENT cost = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT cost += ( ord ( str [ i ] ) - 48 ) NEW_LINE DEDENT return cost NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = \"9142\" NEW_LINE b = \"14142\" NEW_LINE dp = [ [ [ 0 for i in range ( 101 ) ] for i in range ( 101 ) ] NEW_LINE print ( costOfString ( a ) + costOfString ( b ) - 2 * lcs ( dp , a , b , len ( b ) - 1 , len ( b ) - 1 ) ) NEW_LINE DEDENT"],"references":["def lcs ( dp , a , b , m , n ) : NEW_LINE INDENT for i in range ( 100 ) : NEW_LINE INDENT for j in range ( 100 ) : NEW_LINE INDENT dp [ i ] [ j ] = - 1 NEW_LINE DEDENT DEDENT if ( m < 0 or n < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ m ] [ n ] != - 1 ) : NEW_LINE INDENT return dp [ m ] [ n ] NEW_LINE DEDENT ans = 0 NEW_LINE if ( a [ m ] == b [ n ] ) : NEW_LINE INDENT ans = ( ord ( a [ m ] ) - 48 ) + lcs ( dp , a , b , m - 1 , n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( lcs ( dp , a , b , m - 1 , n ) , lcs ( dp , a , b , m , n - 1 ) ) NEW_LINE DEDENT dp [ m ] [ n ] = ans NEW_LINE return ans NEW_LINE DEDENT def costOfString ( s ) : NEW_LINE INDENT cost = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT cost += ( ord ( s [ i ] ) - 48 ) NEW_LINE DEDENT return cost NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = \"9142\" NEW_LINE b = \"1429\" NEW_LINE dp = [ [ 0 for x in range ( 101 ) ] for y in range ( 101 ) ] NEW_LINE print ( costOfString ( a ) + costOfString ( b ) - 2 * lcs ( dp , a , b , len ( a ) - 1 , len ( b ) - 1 ) ) NEW_LINE DEDENT"],"bleu":0.8907713747696444,"rouge_l":0.9506657033749615}
{"id":1011,"predictions":["def maxUniqueNum ( arr , N , M ) : NEW_LINE INDENT maxUnique = 0 NEW_LINE for i in range ( N - M ) : NEW_LINE INDENT currentUnique = 0 NEW_LINE map = defaultdict ( lambda : 0 ) NEW_LINE for k in range ( i , i + M ) : NEW_LINE INDENT if ( arr [ k ] not in map ) : NEW_LINE INDENT map [ arr [ i ] ] = 1 NEW_LINE currentUnique += 1 NEW_LINE continue NEW_LINE DEDENT DEDENT if ( currentUnique > maxUnique ) : NEW_LINE INDENT maxUnique = currentUnique NEW_LINE DEDENT DEDENT return maxUnique NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 3 , 5 , 2 , 3 , 2 ] NEW_LINE N = len ( arr ) NEW_LINE M = 3 NEW_LINE print ( maxUniqueNum ( arr , N , M ) ) NEW_LINE DEDENT"],"references":["def maxUniqueNum ( a , N , M ) : NEW_LINE INDENT maxUnique = 0 NEW_LINE for i in range ( N - M ) : NEW_LINE INDENT s = set ( ) NEW_LINE for j in range ( M ) : NEW_LINE INDENT s . add ( a [ i + j ] ) NEW_LINE DEDENT if ( len ( s ) > maxUnique ) : NEW_LINE INDENT maxUnique = len ( s ) NEW_LINE DEDENT DEDENT return maxUnique NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 3 , 5 , 2 , 3 , 2 ] NEW_LINE M = 3 NEW_LINE N = len ( arr ) NEW_LINE print ( maxUniqueNum ( arr , N , M ) ) NEW_LINE DEDENT"],"bleu":0.6200793868419873,"rouge_l":0.7754824063564131}
{"id":1012,"predictions":["def complement ( s ) : NEW_LINE INDENT comps = \" \" ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT comps += '1' ; NEW_LINE DEDENT else : NEW_LINE INDENT comps += '0' ; NEW_LINE DEDENT DEDENT return comps ; NEW_LINE DEDENT def nthTerm ( n ) : NEW_LINE INDENT s = \"0\" ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT s += complement ( s ) ; NEW_LINE DEDENT return s ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 ; NEW_LINE print ( nthTerm ( n ) ) ; NEW_LINE DEDENT"],"references":["def complement ( s ) : NEW_LINE INDENT comps = \" \" ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT comps += '1' ; NEW_LINE DEDENT else : NEW_LINE INDENT comps += '0' ; NEW_LINE DEDENT DEDENT return comps ; NEW_LINE DEDENT def nthTerm ( n ) : NEW_LINE INDENT s = \"0\" ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT s += complement ( s ) ; NEW_LINE DEDENT return s ; NEW_LINE DEDENT n = 4 ; NEW_LINE print ( nthTerm ( n ) ) ; NEW_LINE"],"bleu":0.8782900316067092,"rouge_l":0.9520810514786419}
{"id":1013,"predictions":["def evenFibSum ( limit ) : NEW_LINE INDENT if ( limit < 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ef1 = 0 NEW_LINE ef2 = 2 NEW_LINE sum = ef1 + ef2 NEW_LINE while ( ef2 <= limit ) : NEW_LINE INDENT ef3 = 4 * ef2 + ef1 NEW_LINE if ( ef3 > limit ) : NEW_LINE INDENT break NEW_LINE DEDENT ef1 = ef2 NEW_LINE ef2 = ef3 NEW_LINE sum += ef2 NEW_LINE DEDENT return sum NEW_LINE DEDENT limit = 400 NEW_LINE print ( evenFibSum ( limit ) ) NEW_LINE"],"references":["def evenFibSum ( limit ) : NEW_LINE INDENT if ( limit < 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ef1 = 0 NEW_LINE ef2 = 2 NEW_LINE sm = ef1 + ef2 NEW_LINE while ( ef2 <= limit ) : NEW_LINE INDENT ef3 = 4 * ef2 + ef1 NEW_LINE if ( ef3 > limit ) : NEW_LINE INDENT break NEW_LINE DEDENT ef1 = ef2 NEW_LINE ef2 = ef3 NEW_LINE sm = sm + ef2 NEW_LINE DEDENT return sm NEW_LINE DEDENT limit = 400 NEW_LINE print ( evenFibSum ( limit ) ) NEW_LINE"],"bleu":0.8875905754837038,"rouge_l":0.9449956483899041}
{"id":1014,"predictions":["def factorial ( N ) : NEW_LINE INDENT fact = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT fact = fact * i NEW_LINE DEDENT return fact NEW_LINE DEDENT def nthTerm ( N ) : NEW_LINE INDENT return ( factorial ( N ) * ( N + 2 ) \/\/ 2 ) NEW_LINE DEDENT N = 6 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE"],"references":["def factorial ( N ) : NEW_LINE INDENT fact = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT fact = fact * i NEW_LINE DEDENT return fact NEW_LINE DEDENT def nthTerm ( N ) : NEW_LINE INDENT return ( factorial ( N ) * ( N + 2 ) \/\/ 2 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 6 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT"],"bleu":0.8104420845269639,"rouge_l":0.899561578318055}
{"id":1015,"predictions":["def answer ( X , K ) : NEW_LINE INDENT i = 10 NEW_LINE MAX = pow ( i , K ) - 1 NEW_LINE return ( MAX - ( MAX % X ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT X = 30 NEW_LINE K = 3 NEW_LINE print ( answer ( X , K ) ) NEW_LINE DEDENT"],"references":["def answer ( X , K ) : NEW_LINE INDENT MAX = pow ( 10 , K ) - 1 NEW_LINE return ( MAX - ( MAX % X ) ) NEW_LINE DEDENT X = 30 ; NEW_LINE K = 3 ; NEW_LINE print ( answer ( X , K ) ) ; NEW_LINE"],"bleu":0.5962998323241036,"rouge_l":0.8312891796129735}
{"id":1016,"predictions":["def maxLength ( a , n ) : NEW_LINE INDENT maximum = 1 NEW_LINE left = [ 0 for i in range ( n ) ] NEW_LINE right = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( a [ i ] > a [ i + 1 ] ) : NEW_LINE INDENT right [ i ] = right [ i + 1 ] + 1 NEW_LINE DEDENT maximum = max ( maximum , right [ i ] ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( a [ i ] < a [ i - 1 ] ) : NEW_LINE INDENT right [ i ] = left [ i - 1 ] + 1 NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT maximum = max ( maximum , left [ i - 1 ] + right [ i + 1 ] ) NEW_LINE DEDENT DEDENT return maximum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 8 , 7 , 3 , 5 , 2 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxLength ( arr , n ) ) NEW_LINE DEDENT"],"references":["def maxLength ( a , n ) : NEW_LINE INDENT maximum = 1 ; NEW_LINE left = [ 0 ] * n ; NEW_LINE right = [ 0 ] * n ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT left [ i ] = 1 ; NEW_LINE right [ i ] = 1 ; NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( a [ i ] > a [ i + 1 ] ) : NEW_LINE INDENT right [ i ] = right [ i + 1 ] + 1 ; NEW_LINE DEDENT maximum = max ( maximum , right [ i ] ) ; NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( a [ i ] < a [ i - 1 ] ) : NEW_LINE INDENT left [ i ] = left [ i - 1 ] + 1 ; NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( a [ i - 1 ] > a [ i + 1 ] ) : NEW_LINE INDENT maximum = max ( maximum , left [ i - 1 ] + right [ i + 1 ] ) ; NEW_LINE DEDENT DEDENT DEDENT return maximum ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 8 , 7 , 3 , 5 , 2 , 9 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( maxLength ( arr , n ) ) ; NEW_LINE DEDENT"],"bleu":0.7113594607057673,"rouge_l":0.8597732861512625}
{"id":1017,"predictions":["n = 3 ; NEW_LINE a = [ 1 , 2 , 3 ] ; NEW_LINE i = 0 ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += a [ i ] ; NEW_LINE DEDENT x = sum \/ n ; NEW_LINE if ( x * n == sum ) : NEW_LINE INDENT print ( x ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" - 1\" ) ; NEW_LINE DEDENT"],"references":["if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE a = [ 1 , 2 , 3 ] NEW_LINE i = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT x = sum \/\/ n NEW_LINE if ( x * n == sum ) : NEW_LINE INDENT print ( x ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT DEDENT"],"bleu":0.6784879310886383,"rouge_l":0.8550861905663952}
{"id":1018,"predictions":["from math import sqrt NEW_LINE def getPerfectSquares ( n ) : NEW_LINE INDENT perfectSquares = [ ] ; NEW_LINE current = 1 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT perfectSquares . append ( current ) ; NEW_LINE current = pow ( i , 2 ) ; NEW_LINE DEDENT return perfectSquares ; NEW_LINE DEDENT def countTriplets ( n ) : NEW_LINE INDENT perfectSquares = getPerfectSquares ( pow ( n , 2 ) ) ; NEW_LINE count = 0 ; NEW_LINE for a in range ( len ( perfectSquares ) ) : NEW_LINE INDENT aSquare = perfectSquares ; NEW_LINE b = cSquare - aSquare ; NEW_LINE b = math . sqrt ( bSquare ) ; NEW_LINE c = int ( sqrt ( cSquare ) ) ; NEW_LINE if ( c < a or bSquare not in perfectSquares ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT if ( b >= a ) and ( b <= cSquare ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT if ( ( b >= a ) and ( bSquare + bSquare == cSquare ) ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 10 ; NEW_LINE print ( countTriplets ( n ) ) ; NEW_LINE DEDENT"],"references":["import math NEW_LINE def getPerfectSquares ( n ) : NEW_LINE INDENT perfectSquares = [ ] NEW_LINE current = 1 NEW_LINE i = 1 NEW_LINE while ( current <= n ) : NEW_LINE INDENT perfectSquares . append ( current ) NEW_LINE i += 1 NEW_LINE current = i ** 2 NEW_LINE DEDENT return perfectSquares NEW_LINE DEDENT def countTriplets ( n ) : NEW_LINE INDENT perfectSquares = getPerfectSquares ( n ** 2 ) NEW_LINE count = 0 NEW_LINE for a in range ( 1 , n + 1 ) : NEW_LINE INDENT aSquare = a ** 2 NEW_LINE for i in range ( len ( perfectSquares ) ) : NEW_LINE INDENT cSquare = perfectSquares [ i ] NEW_LINE bSquare = abs ( cSquare - aSquare ) NEW_LINE b = math . sqrt ( bSquare ) NEW_LINE b = int ( b ) NEW_LINE c = math . sqrt ( cSquare ) NEW_LINE c = int ( c ) NEW_LINE if ( c < a or ( bSquare not in perfectSquares ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( ( b >= a ) and ( b <= c ) and ( aSquare + bSquare == cSquare ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 10 NEW_LINE print ( countTriplets ( n ) ) NEW_LINE DEDENT"],"bleu":0.6420640276899696,"rouge_l":0.7540857661684592}
{"id":1019,"predictions":["def centered_octagonal_Num ( n ) : NEW_LINE INDENT return ( 5 * n * n - 5 * n + 2 ) \/\/ 2 NEW_LINE DEDENT n = 7 NEW_LINE print ( n , \" th ▁ Centered \" , \" Centered \" , n ) NEW_LINE"],"references":["def centered_pentagonal_Num ( n ) : NEW_LINE INDENT return ( 5 * n * n - 5 * n + 2 ) \/\/ 2 NEW_LINE DEDENT n = 7 NEW_LINE print ( \" % sth ▁ Centered ▁ pentagonal ▁ number ▁ : ▁ \" % n , centered_pentagonal_Num ( n ) ) NEW_LINE"],"bleu":0.6089651865533428,"rouge_l":0.7627444693812119}
{"id":1020,"predictions":["def PossibleValues ( b , x , n ) : NEW_LINE INDENT leastdivisible = ( b \/\/ x + 1 ) * x ; NEW_LINE flag = 1 ; NEW_LINE while ( leastdivisible <= n ) : NEW_LINE INDENT if ( leastdivisible - b >= 1 ) : NEW_LINE INDENT print ( leastdivisible - b , end = \" ▁ \" ) ; NEW_LINE leastdivisible += x ; NEW_LINE flag = 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT print ( - 1 ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT b = 10 ; x = 6 ; n = 40 ; NEW_LINE PossibleValues ( b , x , n ) ; NEW_LINE DEDENT"],"references":["def PossibleValues ( b , x , n ) : NEW_LINE INDENT leastdivisible = int ( b \/ x + 1 ) * x NEW_LINE flag = 1 NEW_LINE while ( leastdivisible <= n ) : NEW_LINE INDENT if ( leastdivisible - b >= 1 ) : NEW_LINE INDENT print ( leastdivisible - b , end = \" ▁ \" ) NEW_LINE leastdivisible += x NEW_LINE flag = 0 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( flag != 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT b = 10 NEW_LINE x = 6 NEW_LINE n = 40 NEW_LINE PossibleValues ( b , x , n ) NEW_LINE DEDENT"],"bleu":0.712704049336101,"rouge_l":0.921631249232281}
{"id":1021,"predictions":["def findLongestSubSeq ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( str [ i - 1 ] == str [ j - 1 ] and i != j ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ n ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( findLongestRepeatingSubSeq ( str ) ) NEW_LINE DEDENT"],"references":["def findLongestRepeatingSubSeq ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE dp = [ [ 0 for k in range ( n + 1 ) ] for l in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( str [ i - 1 ] == str [ j - 1 ] and i != j ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ n ] NEW_LINE DEDENT"],"bleu":0.849372998256908,"rouge_l":0.9301439054607836}
{"id":1022,"predictions":["def countIntegralSolutions ( n ) : NEW_LINE INDENT return ( ( n + 1 ) * ( n + 2 ) ) \/\/ 2 NEW_LINE DEDENT n = 3 NEW_LINE print ( countIntegralSolutions ( n ) ) NEW_LINE"],"references":["def countIntegralSolutions ( n ) : NEW_LINE INDENT return int ( ( ( n + 1 ) * ( n + 2 ) ) \/ 2 ) NEW_LINE DEDENT n = 3 NEW_LINE print ( countIntegralSolutions ( n ) ) NEW_LINE"],"bleu":0.8022709117874298,"rouge_l":0.930338004946414}
{"id":1023,"predictions":["def check ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT if ( count & 1 ) : NEW_LINE INDENT return \" Odd \" NEW_LINE DEDENT else : NEW_LINE INDENT return \" Even \" NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 9 , 12 , 13 , 15 ] NEW_LINE n = len ( arr ) NEW_LINE print ( check ( arr , n ) ) NEW_LINE DEDENT"],"references":["def check ( arr , n ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT count = count + 1 ; NEW_LINE DEDENT DEDENT if ( count & 1 ) : NEW_LINE INDENT return \" Odd \" ; NEW_LINE DEDENT else : NEW_LINE INDENT return \" Even \" ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 9 , 12 , 13 , 15 ] NEW_LINE n = len ( arr ) NEW_LINE print ( check ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.9140319476288729,"rouge_l":0.9798854588629697}
{"id":1024,"predictions":["def dfs ( graph , node , dist , vis , c ) : NEW_LINE INDENT if ( vis [ node ] ) : NEW_LINE INDENT return NEW_LINE DEDENT vis [ node ] = True NEW_LINE dist [ node ] = c NEW_LINE for i in range ( len ( graph [ node ] ) ) : NEW_LINE INDENT if ( not vis [ graph [ node ] [ i ] ) : NEW_LINE INDENT dfs ( graph , graph [ node ] [ i ] , dist , vis , c + 1 ) NEW_LINE DEDENT DEDENT DEDENT def countOfNodes ( graph , n ) : NEW_LINE INDENT global dist NEW_LINE vis = [ False ] * ( n + 1 ) NEW_LINE dist = [ 0 ] * ( n + 1 ) NEW_LINE dfs ( graph , 1 , dist , vis , 0 ) NEW_LINE even , odd = 0 , 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( dist [ i ] % 2 == 0 ) : NEW_LINE INDENT even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT ans = ( ( ( even * ( even - 1 ) ) + ( odd * ( odd - 1 ) ) ) \/\/ 2 ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE graph = [ ] NEW_LINE graph = [ ] for i in range ( n + 1 ) : NEW_LINE INDENT graph [ i ] = [ ] NEW_LINE DEDENT graph [ 0 ] = ( ( even * ( even - 1 ) ) + ( odd * ( odd - 1 ) ) \/\/ 2 NEW_LINE ans = countOfNodes ( graph , n ) ) NEW_LINE print ( ans ) NEW_LINE DEDENT"],"references":["def dfs ( graph , node , dist , vis , c ) : NEW_LINE INDENT if ( vis [ node ] ) : NEW_LINE INDENT return ; NEW_LINE DEDENT vis [ node ] = True ; NEW_LINE dist [ node ] = c ; NEW_LINE for i in range ( len ( graph [ node ] ) ) : NEW_LINE INDENT if ( not vis [ graph [ node ] [ i ] ] ) : NEW_LINE INDENT dfs ( graph , graph [ node ] [ i ] , dist , vis , c + 1 ) ; NEW_LINE DEDENT DEDENT DEDENT def countOfNodes ( graph , n ) : NEW_LINE INDENT vis = [ False ] * ( n + 1 ) ; NEW_LINE dist = [ 0 ] * ( n + 1 ) ; NEW_LINE dfs ( graph , 1 , dist , vis , 0 ) ; NEW_LINE even = 0 ; odd = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( dist [ i ] % 2 == 0 ) : NEW_LINE INDENT even += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 ; NEW_LINE DEDENT DEDENT ans = ( ( even * ( even - 1 ) ) + ( odd * ( odd - 1 ) ) ) \/\/ 2 ; NEW_LINE return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 ; NEW_LINE graph = [ [ ] , [ 2 ] , [ 1 , 3 ] , [ 2 ] ] ; NEW_LINE ans = countOfNodes ( graph , n ) ; NEW_LINE print ( ans ) ; NEW_LINE DEDENT"],"bleu":0.7115205739165069,"rouge_l":0.864602760164118}
{"id":1025,"predictions":["def flipsPossible ( a , n ) : NEW_LINE INDENT count_odd = 0 NEW_LINE count_even = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( a [ i ] & 1 ) == 1 ) : NEW_LINE INDENT count_odd += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_even += 1 NEW_LINE DEDENT DEDENT if ( count_odd % 2 == 1 and count_even % 2 == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 0 , 1 , 1 , 1 , 0 , 1 ] NEW_LINE n = len ( a ) NEW_LINE if ( flipsPossible ( a , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def flipsPossible ( a , n ) : NEW_LINE INDENT count_odd = 0 ; count_even = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] & 1 ) : NEW_LINE INDENT count_odd += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT count_even += 1 ; NEW_LINE DEDENT DEDENT if ( count_odd % 2 and count_even % 2 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT else : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 0 , 1 , 1 , 0 , 1 ] ; NEW_LINE n = len ( a ) ; NEW_LINE if ( flipsPossible ( a , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"],"bleu":0.7723689155839445,"rouge_l":0.9221513780337309}
{"id":1026,"predictions":["def findSeries ( num , first , sec ) : NEW_LINE INDENT print ( first , sec , \" ▁ \" , sec , end = \" ▁ \" ) NEW_LINE counter = 0 NEW_LINE sum = 0 NEW_LINE while ( counter < num - 2 ) : NEW_LINE INDENT sum = first + sec NEW_LINE print ( sum , end = \" ▁ \" ) NEW_LINE first = sec NEW_LINE sec = sum NEW_LINE DEDENT DEDENT n = 5 NEW_LINE first = 2 NEW_LINE sec = 4 NEW_LINE findSeries ( n , first , sec ) NEW_LINE"],"references":["def findSeries ( num , first , sec ) : NEW_LINE INDENT print ( \" { } ▁ { } ▁ \" . format ( first , sec ) , end = \" \" ) NEW_LINE counter = 0 NEW_LINE while ( counter < num - 2 ) : NEW_LINE INDENT sum = first + sec NEW_LINE print ( \" { } ▁ \" . format ( sum ) , end = \" \" ) NEW_LINE first = sec NEW_LINE sec = sum NEW_LINE counter = counter + 1 NEW_LINE DEDENT DEDENT n = 5 NEW_LINE first = 2 NEW_LINE sec = 4 NEW_LINE findSeries ( n , first , sec ) NEW_LINE"],"bleu":0.6961914909897913,"rouge_l":0.823565510892912}
{"id":1027,"predictions":["def countOdd ( n ) : NEW_LINE INDENT coun = 0 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( i >= 1 ) : NEW_LINE INDENT m = ( n - i ) \/\/ 2 NEW_LINE j = ( i * ( i + 1 ) ) \/\/ 2 NEW_LINE coun += j * m NEW_LINE DEDENT else : NEW_LINE INDENT m = ( ( n - 1 ) \/\/ 2 ) \/\/ 2 NEW_LINE j = ( i * ( i + 1 ) ) \/\/ 2 NEW_LINE coun += j * m NEW_LINE DEDENT DEDENT return coun NEW_LINE DEDENT def countEven ( n ) : NEW_LINE INDENT coun = 0 NEW_LINE for i in range ( n - 2 , 0 , - 1 ) : NEW_LINE INDENT if ( i >= 1 ) : NEW_LINE INDENT m = ( ( n - 1 ) - i ) \/\/ 2 NEW_LINE j = ( i * ( i + 1 ) ) \/\/ 2 NEW_LINE coun += j * m NEW_LINE DEDENT else : NEW_LINE INDENT m = ( ( n - i ) \/\/ 2 NEW_LINE j = ( i * ( i + 1 ) ) \/\/ 2 NEW_LINE coun += j * m NEW_LINE DEDENT DEDENT return coun NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE if ( n >= 1 ) : NEW_LINE INDENT print ( countOdd ( n ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( countEven ( n ) ) NEW_LINE DEDENT DEDENT"],"references":["def countOdd ( n ) : NEW_LINE INDENT coun = 0 NEW_LINE i = n - 2 NEW_LINE while ( i >= 1 ) : NEW_LINE INDENT if ( i & 1 ) : NEW_LINE INDENT m = int ( ( n - i ) \/ 2 ) NEW_LINE j = int ( ( i * ( i + 1 ) ) \/ 2 ) NEW_LINE coun += j * m NEW_LINE DEDENT else : NEW_LINE INDENT m = int ( ( ( n - 1 ) - i ) \/ 2 ) NEW_LINE j = int ( ( i * ( i + 1 ) ) \/ 2 ) NEW_LINE coun += j * m NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT return coun NEW_LINE DEDENT def countEven ( n ) : NEW_LINE INDENT coun = 0 NEW_LINE i = n - 2 NEW_LINE while ( i >= 1 ) : NEW_LINE INDENT if ( i & 1 ) : NEW_LINE INDENT m = int ( ( ( n - 1 ) - i ) \/ 2 ) NEW_LINE j = int ( ( i * ( i + 1 ) ) \/ 2 ) NEW_LINE coun += j * m NEW_LINE DEDENT else : NEW_LINE INDENT m = int ( ( n - i ) \/ 2 ) NEW_LINE j = ( i * ( i + 1 ) ) \/\/ 2 NEW_LINE coun += j * m NEW_LINE DEDENT DEDENT return coun NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE if ( n & 1 ) : NEW_LINE INDENT print ( countOdd ( n ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( countEven ( n ) ) NEW_LINE DEDENT DEDENT"],"bleu":0.7133816919478765,"rouge_l":0.8604743757465446}
{"id":1028,"predictions":["mod = 10 ** 9 + 7 NEW_LINE def factorial ( n , p ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res = ( res * i ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def modInverse ( n , p ) : NEW_LINE INDENT return power ( n , p - 2 , p ) NEW_LINE DEDENT def nCrModP ( n , r , p ) : NEW_LINE INDENT if ( r == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT fac = [ 0 for i in range ( n + 1 ) ] NEW_LINE fac [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fac [ i ] = fac [ i - 1 ] * i % p NEW_LINE DEDENT return ( fac [ n ] * modInverse ( fac [ r ] , p ) % p * modInverse ( fac [ n - int ( r ] , p ) ) % p ) % p NEW_LINE DEDENT def countArrangments ( n , k , p ) : NEW_LINE INDENT return ( factorial ( n , p ) * nCrModP ( k , n , p ) ) % p NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 NEW_LINE K = 8 NEW_LINE print ( countArrangement ( N , K , mod ) ) NEW_LINE DEDENT"],"references":["mod = 10 ** 9 + 7 NEW_LINE def factorial ( n , p ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res = ( res * i ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def modInverse ( n , p ) : NEW_LINE INDENT return power ( n , p - 2 , p ) NEW_LINE DEDENT def nCrModP ( n , r , p ) : NEW_LINE INDENT if ( r == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT fac = [ 0 for i in range ( n + 1 ) ] NEW_LINE fac [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fac [ i ] = fac [ i - 1 ] * i % p NEW_LINE DEDENT return ( fac [ n ] * modInverse ( fac [ r ] , p ) % p * modInverse ( fac [ n - r ] , p ) % p ) % p NEW_LINE DEDENT def countArrangements ( n , k , p ) : NEW_LINE INDENT return ( factorial ( n , p ) * nCrModP ( k , n , p ) ) % p NEW_LINE DEDENT N = 5 NEW_LINE K = 8 NEW_LINE print ( countArrangements ( N , K , mod ) ) NEW_LINE"],"bleu":0.9221270004357615,"rouge_l":0.9721486761710795}
{"id":1029,"predictions":["def subString ( s , n ) : NEW_LINE INDENT for l in range ( 1 , n + 1 ) : NEW_LINE INDENT for i in range ( n - l + 1 ) : NEW_LINE INDENT j = i + len ( s ) - 1 NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT print ( s [ k ] , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT DEDENT s = [ ' a ' , ' b ' , ' c ' ] NEW_LINE subString ( s , len ( s ) ) NEW_LINE"],"references":["def subString ( Str , n ) : NEW_LINE INDENT for Len in range ( 1 , n + 1 ) : NEW_LINE INDENT for i in range ( n - Len + 1 ) : NEW_LINE INDENT j = i + Len - 1 NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT print ( Str [ k ] , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT DEDENT Str = \" abc \" NEW_LINE subString ( Str , len ( Str ) ) NEW_LINE"],"bleu":0.6575840129671662,"rouge_l":0.8404357577699455}
{"id":1030,"predictions":["def sumofseries ( n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT res += ( i ) * ( i + 1 ) * ( i + 2 ) NEW_LINE DEDENT return res NEW_LINE DEDENT print ( sumofseries ( 3 ) ) NEW_LINE"],"references":["def sumofseries ( n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT res += ( i ) * ( i + 1 ) * ( i + 2 ) NEW_LINE DEDENT return res NEW_LINE DEDENT print ( sumofseries ( 3 ) ) NEW_LINE"],"bleu":1.0,"rouge_l":1.0}
{"id":1031,"predictions":["def countWaysToJump ( arr , n ) : NEW_LINE INDENT count_Jump = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] >= n - i - 1 ) : NEW_LINE INDENT count_j [ i ] += 1 NEW_LINE DEDENT for j in range ( i + 1 , arr [ i ] + i ) : NEW_LINE INDENT if ( count_j [ j ] != - 1 ) : NEW_LINE INDENT count_j += count_j [ j ] NEW_LINE DEDENT DEDENT if ( count_j [ i ] == 0 ) : NEW_LINE INDENT count_j = - 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( count_j [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 1 , 3 , 5 , 8 , 9 , 1 , 0 , 7 , 6 , 8 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE countWaysToJ ( arr , n ) NEW_LINE"],"references":["def countWaysToJump ( arr , n ) : NEW_LINE INDENT count_jump = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] >= n - i - 1 ) : NEW_LINE INDENT count_jump [ i ] += 1 NEW_LINE DEDENT j = i + 1 NEW_LINE while ( j < n - 1 and j <= arr [ i ] + i ) : NEW_LINE INDENT if ( count_jump [ j ] != - 1 ) : NEW_LINE INDENT count_jump [ i ] += count_jump [ j ] NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( count_jump [ i ] == 0 ) : NEW_LINE INDENT count_jump [ i ] = - 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( count_jump [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 1 , 3 , 5 , 8 , 9 , 1 , 0 , 7 , 6 , 8 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE countWaysToJump ( arr , n ) NEW_LINE"],"bleu":0.7592331159184217,"rouge_l":0.8804533963956619}
{"id":1032,"predictions":["def calculateSum ( n ) : NEW_LINE INDENT return 2 * ( pow ( n , 6 ) + 15 * pow ( n , 4 ) + 15 * pow ( n , 2 ) + 1 ) ; NEW_LINE DEDENT n = 1.4142 ; NEW_LINE print ( int ( ceil ( calculateSum ( n ) ) ) ; NEW_LINE"],"references":["import math NEW_LINE def calculateSum ( n ) : NEW_LINE INDENT a = int ( n ) NEW_LINE return ( 2 * ( pow ( n , 6 ) + 15 * pow ( n , 4 ) + 15 * pow ( n , 2 ) + 1 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 1.4142 NEW_LINE print ( math . ceil ( calculateSum ( n ) ) ) NEW_LINE DEDENT"],"bleu":0.5312964841600593,"rouge_l":0.7509342712684107}
{"id":1033,"predictions":["def isMajority ( a , n ) : NEW_LINE INDENT mp = dict . fromkeys ( a , 0 ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] in mp . keys ( ) ) : NEW_LINE INDENT mp [ a [ i ] ] += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT mp [ a [ i ] ] = 1 ; NEW_LINE DEDENT DEDENT for x in mp : NEW_LINE INDENT if ( mp [ x ] >= n \/ 2 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT return False ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 2 , 3 , 9 , 2 , 2 ] ; NEW_LINE n = len ( a ) ; NEW_LINE if ( isMajority ( a , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"],"references":["def isMajority ( a ) : NEW_LINE INDENT mp = { } NEW_LINE for i in a : NEW_LINE INDENT if i in mp : mp [ i ] += 1 NEW_LINE else : mp [ i ] = 1 NEW_LINE DEDENT for x in mp : NEW_LINE INDENT if mp [ x ] >= len ( a ) \/\/ 2 : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT a = [ 2 , 3 , 9 , 2 , 2 ] NEW_LINE print ( \" Yes \" if isMajority ( a ) else \" No \" ) NEW_LINE"],"bleu":0.3290228168969526,"rouge_l":0.6762914230019493}
{"id":1034,"predictions":["def return maxMaxSum ( A , B , n ) : NEW_LINE INDENT mp = { } NEW_LINE result = 0 NEW_LINE curr_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while A [ i ] in mp : NEW_LINE INDENT mp [ A [ curr_ ] ] -= B [ curr_sum ] NEW_LINE curr_sum -= 1 NEW_LINE DEDENT mp [ a [ i ] ] += 1 NEW_LINE curr_sum += 1 NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 0 , 1 , 2 , 3 , 0 , 1 , 4 ] NEW_LINE B = [ 9 , 8 , 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( A ) NEW_LINE print ( maxMaxSum ( A , B , n ) ) NEW_LINE DEDENT"],"references":["def returnMaxSum ( A , B , n ) : NEW_LINE INDENT mp = set ( ) NEW_LINE result = 0 NEW_LINE curr_sum = curr_begin = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT while A [ i ] in mp : NEW_LINE INDENT mp . remove ( A [ curr_begin ] ) NEW_LINE curr_sum -= B [ curr_begin ] NEW_LINE curr_begin += 1 NEW_LINE DEDENT mp . add ( A [ i ] ) NEW_LINE curr_sum += B [ i ] NEW_LINE result = max ( result , curr_sum ) NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 0 , 1 , 2 , 3 , 0 , 1 , 4 ] NEW_LINE B = [ 9 , 8 , 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( A ) NEW_LINE print ( returnMaxSum ( A , B , n ) ) NEW_LINE DEDENT"],"bleu":0.6613429808011083,"rouge_l":0.8119495596477182}
{"id":1035,"predictions":["def hasPath ( root , arr , x ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return False NEW_LINE DEDENT arr . append ( root . data ) NEW_LINE if ( root . data == x ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( hasPath ( root . left , arr , x ) or hasPath ( root . right , a , x ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT arr . pop ( ) NEW_LINE return False NEW_LINE DEDENT def printPath ( root , x ) : NEW_LINE INDENT arr = [ ] NEW_LINE if ( hasPath ( root . left , x ) ) : NEW_LINE INDENT for i in range ( 0 , len ( arr ) - 1 ) : NEW_LINE INDENT print ( arr [ i ] , \" - > \" , end = \" \" ) NEW_LINE DEDENT print ( arr [ - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No ▁ Path \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = Node ( 1 ) NEW_LINE root . left = Node ( 2 ) NEW_LINE root . right = Node ( 3 ) NEW_LINE root . left . left = Node ( 4 ) NEW_LINE root . left . left = Node ( 5 ) NEW_LINE root . left . left = Node ( 6 ) NEW_LINE root . left . left = Node ( 6 ) NEW_LINE root . right . left = Node ( 7 ) NEW_LINE x = 5 NEW_LINE printPath ( root , x ) NEW_LINE DEDENT"],"references":["class getNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = self . right = None NEW_LINE DEDENT DEDENT def hasPath ( root , arr , x ) : NEW_LINE INDENT if ( not root ) : NEW_LINE INDENT return False NEW_LINE DEDENT arr . append ( root . data ) NEW_LINE if ( root . data == x ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( hasPath ( root . left , arr , x ) or hasPath ( root . right , arr , x ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT arr . pop ( - 1 ) NEW_LINE return False NEW_LINE DEDENT def printPath ( root , x ) : NEW_LINE INDENT arr = [ ] NEW_LINE if ( hasPath ( root , arr , x ) ) : NEW_LINE INDENT for i in range ( len ( arr ) - 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" - > \" ) NEW_LINE DEDENT print ( arr [ len ( arr ) - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No ▁ Path \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = getNode ( 1 ) NEW_LINE root . left = getNode ( 2 ) NEW_LINE root . right = getNode ( 3 ) NEW_LINE root . left . left = getNode ( 4 ) NEW_LINE root . left . right = getNode ( 5 ) NEW_LINE root . right . left = getNode ( 6 ) NEW_LINE root . right . right = getNode ( 7 ) NEW_LINE x = 5 NEW_LINE printPath ( root , x ) NEW_LINE DEDENT"],"bleu":0.7519492989899202,"rouge_l":0.8456841062881664}
{"id":1036,"predictions":["from math import sqrt , sqrt NEW_LINE def SieveOfEratosthenes ( prime , p_size ) : NEW_LINE INDENT prime [ 0 ] = False ; NEW_LINE prime [ 1 ] = False ; NEW_LINE for p in range ( 2 , int ( sqrt ( p_size ) ) + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( 2 * p , p_size , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def xorOfElements ( arr , n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) ; NEW_LINE SieveOfEratosthenes ( prime , n + 1 ) ; NEW_LINE m = dict . fromkeys ( arr , 0 ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT m [ arr [ i ] ] = m . get ( arr [ i ] , 0 ) + 1 ; NEW_LINE DEDENT return xor ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 4 , 6 , 5 , 4 , 6 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( xorOfElements ( arr , n ) ) ; NEW_LINE DEDENT"],"references":["from math import sqrt NEW_LINE def SieveOfEratosthenes ( prime , p_size ) : NEW_LINE INDENT prime [ 0 ] = False ; NEW_LINE prime [ 1 ] = False ; NEW_LINE for p in range ( 2 , int ( sqrt ( p_size ) ) + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( p * 2 , p_size + 1 , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT DEDENT return prime NEW_LINE DEDENT def xorPrimeFreq ( arr , n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) ; NEW_LINE prime = SieveOfEratosthenes ( prime , n + 1 ) ; NEW_LINE m = dict . fromkeys ( arr , 0 ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT m [ arr [ i ] ] += 1 ; NEW_LINE DEDENT xorVal = 0 ; NEW_LINE for key , value in m . items ( ) : NEW_LINE INDENT if ( prime [ value ] ) : NEW_LINE INDENT xorVal ^= key ; NEW_LINE DEDENT DEDENT return xorVal ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 5 , 4 , 6 , 5 , 4 , 6 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( xorPrimeFreq ( arr , n ) ) ; NEW_LINE DEDENT"],"bleu":0.7431055917959556,"rouge_l":0.8653363198262406}
{"id":1037,"predictions":["def minimumFlip ( s , x , y ) : NEW_LINE INDENT s = s + s NEW_LINE isOpposite = False NEW_LINE if ( x > y ) : NEW_LINE INDENT x , y = len ( s ) , y NEW_LINE isOpposite = True NEW_LINE DEDENT val = 0 NEW_LINE cur = s [ x ] NEW_LINE for i in range ( x , y + 1 ) : NEW_LINE INDENT if ( s [ i ] != cur ) : NEW_LINE INDENT cur = s [ i ] NEW_LINE val += 1 NEW_LINE DEDENT DEDENT valCorrectwise = 0 NEW_LINE cur = s [ y ] NEW_LINE x += len ( s ) NEW_LINE for i in range ( y , x ) : NEW_LINE INDENT if ( s [ i ] != cur ) : NEW_LINE INDENT cur = s [ i ] NEW_LINE valPainwise += 1 NEW_LINE DEDENT DEDENT if ( val != valAnticwise ) : NEW_LINE INDENT if ( not isOppwise ) : NEW_LINE INDENT print ( \" Cyclwise \" , valClockwise ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Anti - clockwise \" , end = \" \" ) NEW_LINE DEDENT DEDENT elif ( not isOpposite ) : NEW_LINE INDENT print ( \" Non - clockwise \" , val canticwise ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Correct - clockwise \" , val lipicwise ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x , y = 0 , 8 NEW_LINE s = \"000110\" NEW_LINE minimumFlipwise ( s , x , y ) NEW_LINE DEDENT"],"references":["def minimumFlip ( s , x , y ) : NEW_LINE INDENT s = s + s NEW_LINE isOpposite = False NEW_LINE if ( x > y ) : NEW_LINE INDENT temp = y NEW_LINE y = x ; NEW_LINE x = temp NEW_LINE isOpposite = True NEW_LINE DEDENT valClockwise = 0 NEW_LINE cur = s [ x ] NEW_LINE for i in range ( x , y + 1 , 1 ) : NEW_LINE INDENT if ( s [ i ] != cur ) : NEW_LINE INDENT cur = s [ i ] NEW_LINE valClockwise += 1 NEW_LINE DEDENT DEDENT valAnticlockwise = 0 NEW_LINE cur = s [ y ] NEW_LINE x += len ( s ) - 1 NEW_LINE for i in range ( y , x + 1 , 1 ) : NEW_LINE INDENT if ( s [ i ] != cur ) : NEW_LINE INDENT cur = s [ i ] NEW_LINE valAnticlockwise += 1 NEW_LINE DEDENT DEDENT if ( valClockwise <= valAnticlockwise ) : NEW_LINE INDENT if ( isOpposite == False ) : NEW_LINE INDENT print ( \" Clockwise \" , valClockwise ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Anti - clockwise \" , valAnticlockwise ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( isOpposite == False ) : NEW_LINE INDENT print ( \" Anti - clockwise \" , valAnticlockwise ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Clockwise \" , valClockwise ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 0 NEW_LINE y = 8 NEW_LINE s = \"000110\" NEW_LINE minimumFlip ( s , x , y ) NEW_LINE DEDENT"],"bleu":0.7072236624541032,"rouge_l":0.842590959854229}
{"id":1038,"predictions":["import numpy as np NEW_LINE MAX = 26 NEW_LINE def maxSubStr ( str1 , len1 , str2 , len2 ) : NEW_LINE INDENT if ( len1 > len2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT freq1 = [ 0 for i in range ( MAX ) ] NEW_LINE for i in range ( len1 ) : NEW_LINE INDENT freq1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT freq2 = [ 0 for i in range ( MAX ) ] NEW_LINE for i in range ( len2 ) : NEW_LINE INDENT freq2 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT freq2 = sys . maxsize NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT freq2 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT minPoss = sys . maxsize NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if ( freq1 [ i ] == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( freq1 [ i ] > freq2 [ i ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT minPoss = min ( minPoss , freq2 [ i ] \/\/ freq1 [ i ] ) NEW_LINE DEDENT return minPoss NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = \" geeks \" NEW_LINE str2 = \" gskelegee \" NEW_LINE len1 = len ( str1 ) NEW_LINE len2 = len ( str2 ) NEW_LINE print ( maxSubStr ( str1 , len1 , len1 , len2 ) ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE MAX = 26 ; NEW_LINE def maxSubStr ( str1 , len1 , str2 , len2 ) : NEW_LINE INDENT if ( len1 > len2 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT freq1 = [ 0 ] * MAX ; NEW_LINE for i in range ( len1 ) : NEW_LINE INDENT freq1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT freq2 = [ 0 ] * MAX ; NEW_LINE for i in range ( len2 ) : NEW_LINE INDENT freq2 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT minPoss = sys . maxsize ; NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if ( freq1 [ i ] == 0 ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT if ( freq1 [ i ] > freq2 [ i ] ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT minPoss = min ( minPoss , freq2 [ i ] \/ freq1 [ i ] ) ; NEW_LINE DEDENT return int ( minPoss ) ; NEW_LINE DEDENT str1 = \" geeks \" ; str2 = \" gskefrgoekees \" ; NEW_LINE len1 = len ( str1 ) ; NEW_LINE len2 = len ( str2 ) ; NEW_LINE print ( maxSubStr ( str1 , len1 , str2 , len2 ) ) ; NEW_LINE"],"bleu":0.6382596397619306,"rouge_l":0.8255177188896582}
{"id":1039,"predictions":["def isValidString ( string , n ) : NEW_LINE INDENT index = string . find ( \" b \" ) NEW_LINE if index == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT while index != - 1 : NEW_LINE INDENT if ( string [ index - 1 ] != ' a ' ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( index + 1 < n and string [ index + 1 ] != ' b ' ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( index + 2 < n and string [ index + 2 ] == ' b ' ) : NEW_LINE INDENT return False NEW_LINE DEDENT if index == n - 1 : NEW_LINE INDENT return False NEW_LINE DEDENT index = string . find ( \" b \" , index + 2 ) NEW_LINE DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" abbaaabbabba \" NEW_LINE n = len ( string ) NEW_LINE print ( isValidString ( string , n ) ) NEW_LINE DEDENT"],"references":["def isValidString ( str , n ) : NEW_LINE INDENT idx = str . find ( \" b \" ) NEW_LINE if ( idx == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( idx != - 1 ) : NEW_LINE INDENT if ( str [ idx - 1 ] != ' a ' ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( idx + 1 < n and str [ idx + 1 ] != ' b ' ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( idx + 2 < n and str [ idx + 2 ] == ' b ' ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( idx == n - 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT idx = str . find ( \" b \" , idx + 2 ) NEW_LINE DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" abbaaabbabba \" NEW_LINE n = len ( str ) NEW_LINE print ( isValidString ( str , n ) ) NEW_LINE DEDENT"],"bleu":0.6879552127019694,"rouge_l":0.873122459798551}
{"id":1040,"predictions":["def gcd ( a , b ) : NEW_LINE INDENT if ( ( a % b ) == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT def firstFactorialDivisibleNumber ( x ) : NEW_LINE INDENT i = 1 NEW_LINE new_x = x NEW_LINE for i in range ( 1 , x ) : NEW_LINE INDENT new_x \/= gcd ( i , new_x ) NEW_LINE if ( new_x == 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return i NEW_LINE DEDENT x = 16 NEW_LINE print ( firstFactorialDivisibleNumber ( x ) ) NEW_LINE"],"references":["def gcd ( a , b ) : NEW_LINE INDENT if ( ( a % b ) == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT def firstFactorialDivisibleNumber ( x ) : NEW_LINE INDENT i = 1 NEW_LINE new_x = x NEW_LINE for i in range ( 1 , x ) : NEW_LINE INDENT new_x \/= gcd ( i , new_x ) NEW_LINE if ( new_x == 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return i NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT x = 16 NEW_LINE print ( firstFactorialDivisibleNumber ( x ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"bleu":0.7673741120494363,"rouge_l":0.8714285714285713}
{"id":1041,"predictions":["def xorLessK ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT tempXor = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT tempXor ^= arr [ j ] NEW_LINE if ( tempXor < k ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT k = 3 NEW_LINE arr = [ 8 , 9 , 10 , 11 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE print ( xorLessK ( arr , n , k ) ) NEW_LINE"],"references":["def xorLessK ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT tempXor = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT tempXor ^= arr [ j ] NEW_LINE if ( tempXor < k ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT k = 3 NEW_LINE arr = [ 8 , 9 , 10 , 11 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE print ( xorLessK ( arr , n , k ) ) NEW_LINE DEDENT"],"bleu":0.863664760853872,"rouge_l":0.927690100430416}
{"id":1042,"predictions":["def findNumbers ( arr , n ) : NEW_LINE INDENT num = [ 0 ] * n ; NEW_LINE b_minus_a = arr [ n - 1 ] - arr [ 1 ] ; NEW_LINE num [ 1 ] = ( arr [ 0 ] + b_minus_a ) \/\/ 2 ; NEW_LINE num [ 0 ] = arr [ 0 ] - num [ 1 ] ; NEW_LINE for i in range ( 1 , ( n - 2 ) + 1 ) : NEW_LINE INDENT num [ i + 1 ] = arr [ i ] - num [ 0 ] ; NEW_LINE DEDENT print ( \" Numbers ▁ are : ▁ \" , end = \" \" ) ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( num [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT arr = [ 13 , 10 , 14 , 9 , 17 , 21 , 16 , 18 , 13 , 17 ] ; NEW_LINE n = 5 ; NEW_LINE findNumbers ( arr , n ) ; NEW_LINE"],"references":["def findNumbers ( arr , n ) : NEW_LINE INDENT num = [ 0 for i in range ( n ) ] NEW_LINE b_minus_a = arr [ n - 1 ] - arr [ 1 ] NEW_LINE num [ 1 ] = ( arr [ 0 ] + b_minus_a ) \/\/ 2 NEW_LINE num [ 0 ] = arr [ 0 ] - num [ 1 ] NEW_LINE for i in range ( 1 , ( n - 2 ) + 1 ) : NEW_LINE INDENT num [ i + 1 ] = arr [ i ] - num [ 0 ] NEW_LINE DEDENT print ( \" Numbers ▁ are : ▁ \" , end = \" \" ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( num [ i ] , end = \" , ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 13 , 10 , 14 , 9 , 17 , 21 , 16 , 18 , 13 , 17 ] NEW_LINE n = 5 NEW_LINE findNumbers ( arr , n ) NEW_LINE"],"bleu":0.8282910018917915,"rouge_l":0.943298969072165}
{"id":1043,"predictions":["primes = [ ] ; NEW_LINE prime = [ True ] * ( 10000000 + 1 ) ; NEW_LINE def sieve ( n ) : NEW_LINE INDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT pr . append ( p ) ; NEW_LINE DEDENT DEDENT DEDENT def SemiPrimeSum ( N ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( len ( pr ) ) : NEW_LINE INDENT for j in range ( i , len ( pr ) ) : NEW_LINE INDENT if ( pr [ i ] * pr [ j ] > N ) : NEW_LINE INDENT break ; NEW_LINE DEDENT ans += pr [ i ] * pr [ j ] ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 6 ; NEW_LINE sieve ( N ) ; NEW_LINE print ( SemiPrimeSum ( N ) ) ; NEW_LINE DEDENT"],"references":["pr = [ ] NEW_LINE prime = [ 1 for i in range ( 10000000 + 1 ) ] NEW_LINE def sieve ( n ) : NEW_LINE INDENT for p in range ( 2 , n ) : NEW_LINE INDENT if p * p > n : NEW_LINE INDENT break NEW_LINE DEDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( 2 * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT pr . append ( p ) NEW_LINE DEDENT DEDENT DEDENT def SemiPrimeSum ( N ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( len ( pr ) ) : NEW_LINE INDENT for j in range ( i , len ( pr ) ) : NEW_LINE INDENT if ( pr [ i ] * pr [ j ] > N ) : NEW_LINE INDENT break NEW_LINE DEDENT ans += pr [ i ] * pr [ j ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT N = 6 NEW_LINE sieve ( N ) NEW_LINE print ( SemiPrimeSum ( N ) ) NEW_LINE"],"bleu":0.7798399329355953,"rouge_l":0.8897032145707858}
{"id":1044,"predictions":["def largestPalinSub ( s ) : NEW_LINE INDENT res = \" \" NEW_LINE mx = s [ 0 ] NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT mx = max ( mx , ord ( s [ i ] ) ) NEW_LINE DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == mx ) : NEW_LINE INDENT res += s [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" geeksforgeeks \" NEW_LINE print ( largestPalinSub ( s ) ) NEW_LINE DEDENT"],"references":["def largestPalinSub ( s ) : NEW_LINE INDENT res = \" \" NEW_LINE mx = s [ 0 ] NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT mx = max ( mx , s [ i ] ) NEW_LINE DEDENT for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT if s [ i ] == mx : NEW_LINE INDENT res += s [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" geeksforgeeks \" NEW_LINE print ( largestPalinSub ( s ) ) NEW_LINE DEDENT"],"bleu":0.8530443899162676,"rouge_l":0.9546165884194052}
{"id":1045,"predictions":["def allPalindrome ( input ) : NEW_LINE INDENT if ( len ( input ) ) == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT if len ( input ) == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT for i in range ( len ( inputPartitions ) ) : NEW_LINE INDENT if ( allPartrome ( input , i ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT print ( \" All ▁ possible ▁ part ▁ for ▁ i ▁ in ▁ \" + ▁ are ▁ : ▁ \" , end = \" \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"references":["def isPalindrome ( string : str , low : int , high : int ) : NEW_LINE INDENT while low < high : NEW_LINE INDENT if string [ low ] != string [ high ] : NEW_LINE INDENT return False NEW_LINE DEDENT low += 1 NEW_LINE high -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def allPalPartUtil ( allPart : list , currPart : list , start : int , n : int , string : str ) : NEW_LINE INDENT if start >= n : NEW_LINE INDENT x = currPart . copy ( ) NEW_LINE allPart . append ( x ) NEW_LINE return NEW_LINE DEDENT for i in range ( start , n ) : NEW_LINE INDENT if isPalindrome ( string , start , i ) : NEW_LINE INDENT currPart . append ( string [ start : i + 1 ] ) NEW_LINE allPalPartUtil ( allPart , currPart , i + 1 , n , string ) NEW_LINE currPart . pop ( ) NEW_LINE DEDENT DEDENT DEDENT def allPalPartitions ( string : str ) : NEW_LINE INDENT n = len ( string ) NEW_LINE allPart = [ ] NEW_LINE currPart = [ ] NEW_LINE allPalPartUtil ( allPart , currPart , 0 , n , string ) NEW_LINE for i in range ( len ( allPart ) ) : NEW_LINE INDENT for j in range ( len ( allPart [ i ] ) ) : NEW_LINE INDENT print ( allPart [ i ] [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" nitin \" NEW_LINE allPalPartitions ( string ) NEW_LINE DEDENT"],"bleu":0.12808782231716517,"rouge_l":0.3473699985014237}
{"id":1046,"predictions":["def findLength ( string , n ) : NEW_LINE INDENT current_sum = 0 NEW_LINE max_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT current_sum += ( 1 if ( string [ i ] == '0' ) else - 1 ) NEW_LINE if ( current_sum < 0 ) : NEW_LINE INDENT current_sum = 0 NEW_LINE DEDENT max_sum = max ( current_sum , max_sum ) NEW_LINE DEDENT return max_sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \"11000010001\" NEW_LINE n = len ( string ) NEW_LINE print ( findLength ( string , n ) ) NEW_LINE DEDENT"],"references":["def findLength ( string , n ) : NEW_LINE INDENT current_sum = 0 NEW_LINE max_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT current_sum += ( 1 if string [ i ] == '0' else - 1 ) NEW_LINE if current_sum < 0 : NEW_LINE INDENT current_sum = 0 NEW_LINE DEDENT max_sum = max ( current_sum , max_sum ) NEW_LINE DEDENT return max_sum if max_sum else 0 NEW_LINE DEDENT s = \"11000010001\" NEW_LINE n = 11 NEW_LINE print ( findLength ( s , n ) ) NEW_LINE"],"bleu":0.6664396937682021,"rouge_l":0.8588702998177903}
{"id":1047,"predictions":["def Display ( Arr , N , K ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( Arr [ i ] == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( K >= ( N - count ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT Arr = [ 5 , 1 , 2 ] NEW_LINE N = len ( Arr ) NEW_LINE K = 2 NEW_LINE result = Display ( Arr , N , K ) NEW_LINE if ( result == 1 ) : NEW_LINE INDENT print ( \" Possible \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ Possible \" ) NEW_LINE DEDENT DEDENT"],"references":["def Series ( Arr , N , K ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if Arr [ i ] == 1 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if K >= ( N - count ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT Arr = [ 5 , 1 , 2 ] NEW_LINE N = len ( Arr ) NEW_LINE K = 2 NEW_LINE result = Series ( Arr , N , K ) NEW_LINE if result == 1 : NEW_LINE INDENT print ( \" Possible \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ Possible \" ) NEW_LINE DEDENT"],"bleu":0.7195198865738656,"rouge_l":0.9074005206396429}
{"id":1048,"predictions":["def countDigit ( n ) : NEW_LINE INDENT prime = [ True ] * 10 NEW_LINE prime [ 2 ] = True NEW_LINE prime [ 5 ] = True NEW_LINE t = n NEW_LINE count = 0 NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT d = temp % 10 NEW_LINE temp \/\/= 10 NEW_LINE if ( d > 0 and n % d == 0 and prime [ d ] == True ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 1032 NEW_LINE print ( countDigit ( n ) ) NEW_LINE DEDENT"],"references":["def countDigit ( n ) : NEW_LINE INDENT prime = [ False ] * 10 NEW_LINE prime [ 2 ] = True NEW_LINE prime [ 3 ] = True ; NEW_LINE prime [ 5 ] = True NEW_LINE prime [ 7 ] = True ; NEW_LINE temp = n NEW_LINE count = 0 ; NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT d = temp % 10 ; NEW_LINE temp \/\/= 10 ; NEW_LINE if ( d > 0 and n % d == 0 and prime [ d ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT n = 1032 NEW_LINE print ( countDigit ( n ) ) NEW_LINE"],"bleu":0.7333109355105641,"rouge_l":0.830689316299312}
{"id":1049,"predictions":["import math NEW_LINE def polyapothedm ( n , a ) : NEW_LINE INDENT if ( a < 0 and n < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ( a \/ ( 2 * math . tan ( ( 180 \/ n ) * 3.14159 \/ 180 ) ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a , n = 9 , 6 NEW_LINE print ( polyapapoterson ( n , a ) ) NEW_LINE DEDENT"],"references":["from math import tan NEW_LINE def polyapothem ( n , a ) : NEW_LINE INDENT if ( a < 0 and n < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return a \/ ( 2 * tan ( ( 180 \/ n ) * 3.14159 \/ 180 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 9 NEW_LINE n = 6 NEW_LINE print ( ' { 0 : . 6 } ' . format ( polyapothem ( n , a ) ) ) NEW_LINE DEDENT"],"bleu":0.7073944249341095,"rouge_l":0.8306564245810054}
{"id":1050,"predictions":["def evenPowerSum ( n ) : NEW_LINE INDENT return ( 8 * n * ( n + 1 ) * ( 2 * n + 1 ) * ( 3 * n * n + 3 * n - 1 ) ) \/ 15 NEW_LINE DEDENT n = 4 NEW_LINE print ( evenPowerSum ( n ) ) NEW_LINE"],"references":["def evenPowerSum ( n ) : NEW_LINE INDENT return ( 8 * n * ( n + 1 ) * ( 2 * n + 1 ) * ( 3 * n * n + 3 * n - 1 ) ) \/ 15 ; NEW_LINE DEDENT n = 4 ; NEW_LINE print ( int ( evenPowerSum ( n ) ) ) ; NEW_LINE"],"bleu":0.8283386892671172,"rouge_l":0.9424613745338307}
{"id":1051,"predictions":["def printModulus ( X , Y ) : NEW_LINE INDENT n = max ( X , Y ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( X % i == Y % i ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT X = 10 NEW_LINE Y = 20 NEW_LINE printModulus ( X , Y ) NEW_LINE DEDENT"],"references":["def printModulus ( X , Y ) : NEW_LINE INDENT n = max ( X , Y ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( X % i == Y % i ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT X = 10 NEW_LINE Y = 20 NEW_LINE printModulus ( X , Y ) NEW_LINE"],"bleu":0.8245373855926045,"rouge_l":0.9289340101522843}
{"id":1052,"predictions":["def __gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a ; NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return __gcd ( a - b , b ) ; NEW_LINE DEDENT return __gcd ( a , b - a ) ; NEW_LINE DEDENT def minValidNumber ( p , q ) : NEW_LINE INDENT if ( q % p == 0 ) : NEW_LINE INDENT return __gcd ( p , q ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT p = 2 ; q = 6 ; NEW_LINE print ( minValidNumber ( p , q ) ) ; NEW_LINE DEDENT"],"references":["from math import gcd NEW_LINE def minValidNumber ( p , q ) : NEW_LINE INDENT if ( q % p == 0 ) : NEW_LINE INDENT return gcd ( p , q ) NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT p , q = 2 , 6 ; NEW_LINE print ( minValidNumber ( p , q ) ) NEW_LINE DEDENT"],"bleu":0.4029655863235083,"rouge_l":0.6486404374905059}
{"id":1053,"predictions":["def maxSum ( arr , n , k ) : NEW_LINE INDENT if ( n < k ) : NEW_LINE INDENT print ( \" Invalid \" ) ; NEW_LINE return - 1 ; NEW_LINE DEDENT max_sum = 0 ; NEW_LINE for i in range ( k ) : NEW_LINE INDENT max_sum += arr [ i ] ; NEW_LINE DEDENT window_sum = max_sum ; NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT window_sum += arr [ i ] - arr [ i - k ] ; NEW_LINE max_sum = max ( max_sum , window_sum ) ; NEW_LINE DEDENT return max_sum ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 4 , 2 , 10 , 2 , 3 , 1 , 0 , 20 ] ; NEW_LINE k = 4 ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( maxSum ( arr , n , k ) ) ; NEW_LINE DEDENT"],"references":["import sys NEW_LINE INT_MIN = - sys . maxsize - 1 NEW_LINE def maxSum ( arr , n , k ) : NEW_LINE INDENT if not n > k : NEW_LINE INDENT print ( \" Invalid \" ) NEW_LINE return - 1 NEW_LINE DEDENT max_sum = INT_MIN NEW_LINE window_sum = sum ( arr [ : k ] ) NEW_LINE for i in range ( n - k ) : NEW_LINE INDENT window_sum = window_sum - arr [ i ] + arr [ i + k ] NEW_LINE max_sum = max ( window_sum , max_sum ) NEW_LINE DEDENT return max_sum NEW_LINE DEDENT arr = [ 1 , 4 , 2 , 10 , 2 , 3 , 1 , 0 , 20 ] NEW_LINE k = 4 NEW_LINE n = len ( arr ) NEW_LINE print ( maxSum ( arr , n , k ) ) NEW_LINE"],"bleu":0.5156515193858361,"rouge_l":0.7443719755943614}
{"id":1054,"predictions":["def sort ( a , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( ( a [ i ] + a [ j ] ) > a [ i ] ) : NEW_LINE INDENT s = a [ i ] ; NEW_LINE a [ i ] = a [ j ] ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def lexsmallest ( a , n ) : NEW_LINE INDENT sort ( a , n ) ; NEW_LINE answer = \" \" ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT answer += a [ i ] ; NEW_LINE DEDENT return answer ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ \" c \" , \" cb \" , \" cba \" ] ; NEW_LINE n = 3 ; NEW_LINE print ( \" leyx ▁ smallest ▁ string ▁ = \" , lexsmallest ( a , n ) ) ; NEW_LINE DEDENT"],"references":["def lexSmallest ( a , n ) : NEW_LINE INDENT a . sort ( reverse = True ) NEW_LINE answer = \" \" NEW_LINE for i in range ( n ) : NEW_LINE INDENT answer += a [ i ] NEW_LINE DEDENT return answer NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ \" c \" , \" cb \" , \" cba \" ] NEW_LINE n = len ( a ) NEW_LINE print ( lexSmallest ( a , n ) ) NEW_LINE DEDENT"],"bleu":0.36662933494025796,"rouge_l":0.6370156014091595}
{"id":1055,"predictions":["def printAnagrams ( arr , n ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT word = arr [ i ] NEW_LINE letters = [ ] NEW_LINE if ( newWord in mp . keys ( ) ) : NEW_LINE INDENT map [ newWord ] = ( word . lower ( ) ) NEW_LINE DEDENT else : NEW_LINE INDENT words . append ( word ) NEW_LINE DEDENT DEDENT for s in mp : NEW_LINE INDENT if ( len ( values ) > 1 ) : NEW_LINE INDENT print ( values ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ \" cat \" , \" dog \" , \" cat \" , \" dog \" , \" g \" , \" op \" , \" flag \" ] NEW_LINE printAnagrams ( arr ) NEW_LINE DEDENT"],"references":["from collections import defaultdict NEW_LINE def printAnagramsTogether ( words ) : NEW_LINE INDENT groupedWords = defaultdict ( list ) NEW_LINE for word in words : NEW_LINE INDENT groupedWords [ \" \" . join ( sorted ( word ) ) ] . append ( word ) NEW_LINE DEDENT for group in groupedWords . values ( ) : NEW_LINE INDENT print ( \" ▁ \" . join ( group ) ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ \" cat \" , \" dog \" , \" tac \" , \" god \" , \" act \" ] NEW_LINE printAnagramsTogether ( arr ) NEW_LINE DEDENT"],"bleu":0.3248495779335339,"rouge_l":0.5860262008733624}
{"id":1056,"predictions":["def commonPrefixUtil ( str1 , str2 ) : NEW_LINE INDENT result = \" \" ; NEW_LINE n1 = len ( str1 ) NEW_LINE n2 = len ( str2 ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while i <= n1 - 1 and j <= n2 - 1 : NEW_LINE INDENT if ( str1 [ i ] != str2 [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT result += str1 [ i ] NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT return ( result ) NEW_LINE DEDENT def commonPrefix ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE print ( commonPrefixUtil ( arr [ 0 ] , arr [ n - 1 ] ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ \" geeksforgeeks \" , \" geeks \" , \" geek \" , \" geezer \" ] NEW_LINE n = len ( arr ) NEW_LINE commonPrefix ( arr , n ) NEW_LINE DEDENT"],"references":["def commonPrefixUtil ( str1 , str2 ) : NEW_LINE INDENT n1 = len ( str1 ) NEW_LINE n2 = len ( str2 ) NEW_LINE result = \" \" NEW_LINE j = 0 NEW_LINE i = 0 NEW_LINE while ( i <= n1 - 1 and j <= n2 - 1 ) : NEW_LINE INDENT if ( str1 [ i ] != str2 [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT result += ( str1 [ i ] ) NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT return ( result ) NEW_LINE DEDENT def commonPrefix ( arr , n ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE print ( commonPrefixUtil ( arr [ 0 ] , arr [ n - 1 ] ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ \" geeksforgeeks \" , \" geeks \" , \" geek \" , \" geezer \" ] NEW_LINE n = len ( arr ) NEW_LINE commonPrefix ( arr , n ) NEW_LINE DEDENT"],"bleu":0.8616383268547587,"rouge_l":0.9245799853907962}
{"id":1057,"predictions":["def changeTheArray ( arr , n ) : NEW_LINE INDENT minEle = min ( arr ) NEW_LINE maxEle = max ( arr ) NEW_LINE minEle = max ( arr ) NEW_LINE minEle = max ( arr ) NEW_LINE minOperations = 2147483647 NEW_LINE for num in range ( minEle , maxEle + 1 ) : NEW_LINE INDENT operations = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] != num ) : NEW_LINE INDENT operations += ( abs ( num - arr [ i ] ) - 1 ) NEW_LINE DEDENT DEDENT minOperations = min ( minOperations , operations ) NEW_LINE DEDENT return minOperations NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 10 , 1 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( changeTheArray ( arr , n ) ) NEW_LINE DEDENT"],"references":["import math NEW_LINE import sys NEW_LINE def changeTheArray ( arr , n ) : NEW_LINE INDENT minEle = min ( arr ) NEW_LINE maxEle = max ( arr ) NEW_LINE minOperations = sys . maxsize NEW_LINE for num in range ( minEle , maxEle + 1 ) : NEW_LINE INDENT operations = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] != num : NEW_LINE INDENT operations += ( abs ( num - arr [ i ] ) - 1 ) NEW_LINE DEDENT DEDENT minOperations = min ( minOperations , operations ) NEW_LINE DEDENT return minOperations NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 10 , 1 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( changeTheArray ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.863455305551165,"rouge_l":0.9182938802225374}
{"id":1058,"predictions":["def findElements ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( arr [ j ] > arr [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count >= 2 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 2 , - 6 , 3 , 5 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE findElements ( arr , n ) NEW_LINE"],"references":["def findElements ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if arr [ j ] > arr [ i ] : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT if count >= 2 : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 2 , - 6 , 3 , 5 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE findElements ( arr , n ) NEW_LINE"],"bleu":0.8692515502445557,"rouge_l":0.9545454545454546}
{"id":1059,"predictions":["def cntSubArrays ( arr , n , k ) : NEW_LINE INDENT res = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT j = i + 1 ; NEW_LINE while ( j < n and arr [ j ] >= arr [ j - 1 ] ) : NEW_LINE INDENT j += 1 ; NEW_LINE DEDENT res += max ( j - i - k + 1 , 0 ) ; NEW_LINE i = j ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 2 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE k = 2 ; NEW_LINE print ( cntSubArrays ( arr , n , k ) ) ; NEW_LINE DEDENT"],"references":["def cntSubArrays ( arr , n , k ) : NEW_LINE INDENT res = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT j = i + 1 ; NEW_LINE while ( j < n and arr [ j ] >= arr [ j - 1 ] ) : NEW_LINE INDENT j += 1 ; NEW_LINE DEDENT res += max ( j - i - k + 1 , 0 ) ; NEW_LINE i = j ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 2 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE k = 2 ; NEW_LINE print ( cntSubArrays ( arr , n , k ) ) ; NEW_LINE DEDENT"],"bleu":1.0,"rouge_l":1.0}
{"id":1060,"predictions":["def match_Words ( d , sentence , n , m ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( dictionary [ i ] in mp . keys ( ) ) : NEW_LINE INDENT mp [ dictionary [ i ] ] = mp . get ( dictionary [ i ] , 0 ) + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT mp [ dictionary [ i ] ] = 1 NEW_LINE DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT if ( sentence [ i ] in mp . keys ( ) ) : NEW_LINE INDENT mp [ sentence [ i ] ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT array = [ \" find \" , \" a \" geeks \" , \" geeks \" , \" on \" , \" geeks \" , \" for \" , \" geeks \" ] NEW_LINE n = len ( array ) NEW_LINE sentence = [ \" find \" , \" all \" acknowledges \" , \" on \" , \" geeks \" , \" for \" , \" geeks \" ] NEW_LINE m = len ( sentence ) NEW_LINE if ( match_ words ( dictionary , sentence , n , m ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"references":["def match_words ( dictionary , sentence , n , m ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ dictionary [ i ] ] = mp . get ( dictionary [ i ] , 0 ) + 1 NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT if ( mp [ sentence [ i ] ] ) : NEW_LINE INDENT mp [ sentence [ i ] ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT dictionary = [ \" find \" , \" a \" , \" geeks \" , \" all \" , \" for \" , \" on \" , \" geeks \" , \" answers \" , \" inter \" ] NEW_LINE n = len ( dictionary ) NEW_LINE sentence = [ \" find \" , \" all \" , \" answers \" , \" on \" , \" geeks \" , \" for \" , \" geeks \" ] NEW_LINE m = len ( sentence ) NEW_LINE if ( match_words ( dictionary , sentence , n , m ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"],"bleu":0.7059914855422295,"rouge_l":0.8318941885964912}
{"id":1061,"predictions":["def sumofproduct ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for x in range ( 1 , n + 1 ) : NEW_LINE INDENT y = n \/\/ x NEW_LINE ans += ( y * x ) NEW_LINE DEDENT return ans NEW_LINE DEDENT n = 10 NEW_LINE print ( sumofproduct ( n ) ) NEW_LINE"],"references":["def sumofproduct ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for x in range ( 1 , n + 1 ) : NEW_LINE INDENT y = int ( n \/ x ) NEW_LINE ans += ( y * x ) NEW_LINE DEDENT return ans NEW_LINE DEDENT n = 10 NEW_LINE print ( sumofproduct ( n ) ) NEW_LINE"],"bleu":0.8803558401121171,"rouge_l":0.9528591352859135}
{"id":1062,"predictions":["def isUnique ( a , n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT sum += n - 1 NEW_LINE return ( sum == k ) NEW_LINE DEDENT a = [ 3 , 3 , 3 ] NEW_LINE n = len ( a ) NEW_LINE k = 12 NEW_LINE if ( isUnique ( a , n , k ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def isUnique ( a , n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT sum += n - 1 NEW_LINE return ( sum == k ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 3 , 3 , 3 ] NEW_LINE n = len ( a ) NEW_LINE k = 12 NEW_LINE if ( isUnique ( a , n , k ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.8084237826701175,"rouge_l":0.9065069975472515}
{"id":1063,"predictions":["if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT for first = 1 NEW_LINE second = 1 NEW_LINE for j in range ( 1 , 5 + 1 ) : NEW_LINE INDENT for second in range ( 1 , 5 ) : NEW_LINE INDENT print ( 5 * first + second - 5 ) NEW_LINE DEDENT DEDENT DEDENT"],"references":["if name == ' _ _ main _ _ ' : NEW_LINE INDENT for first in range ( 1 , 6 ) : NEW_LINE INDENT for second in range ( 1 , 6 ) : NEW_LINE INDENT print ( 5 * first + second - 5 ) NEW_LINE DEDENT DEDENT DEDENT"],"bleu":0.6095838548941505,"rouge_l":0.828706438275251}
{"id":1064,"predictions":["def calculate_ ( s ) : NEW_LINE INDENT if ( len ( s ) == 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT count_ = 0 ; NEW_LINE for i in range ( len ( s ) - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT count_ += 1 ; NEW_LINE i -= 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT count_ += 1 ; NEW_LINE while ( s [ i ] == '1' and i > 0 ) : NEW_LINE INDENT count_ += 1 ; NEW_LINE i -= 1 ; NEW_LINE DEDENT if ( i == 0 ) : NEW_LINE INDENT count_ += 1 ; NEW_LINE DEDENT s1 = '1' ; NEW_LINE DEDENT DEDENT return count_ ; NEW_LINE DEDENT s = \"10000100000\" ; NEW_LINE print ( calculate_ ( s ) ) ; NEW_LINE"],"references":["def calculate_ ( s ) : NEW_LINE INDENT if len ( s ) == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT count_ = 0 NEW_LINE i = len ( s ) - 1 NEW_LINE while i > 0 : NEW_LINE INDENT if s [ i ] == '0' : NEW_LINE INDENT count_ += 1 NEW_LINE i -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_ += 1 NEW_LINE while s [ i ] == '1' and i > 0 : NEW_LINE INDENT count_ += 1 NEW_LINE i -= 1 NEW_LINE DEDENT if i == 0 : NEW_LINE INDENT count_ += 1 NEW_LINE DEDENT s = s [ : i ] + \"1\" + s [ i + 1 : ] NEW_LINE DEDENT DEDENT return count_ NEW_LINE DEDENT s = \"10000100000\" NEW_LINE print ( calculate_ ( s ) ) NEW_LINE"],"bleu":0.5536392686950002,"rouge_l":0.8235697940503433}
{"id":1065,"predictions":["def getWinner ( string , length ) : NEW_LINE INDENT total = 0 NEW_LINE for i in range ( length ) : NEW_LINE INDENT if ( string [ i ] == ' S ' ) : NEW_LINE INDENT total += 1 NEW_LINE DEDENT DEDENT if ( ( total % 2 ) == 1 ) : NEW_LINE INDENT return \" First \" NEW_LINE DEDENT return \" Second \" NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" GPSS \" NEW_LINE length = len ( string ) NEW_LINE print ( getWinner ( string , length ) ) NEW_LINE DEDENT"],"references":["def getWinner ( string , length ) : NEW_LINE INDENT total = 0 ; NEW_LINE for i in range ( length ) : NEW_LINE INDENT if ( string [ i ] == ' S ' ) : NEW_LINE INDENT total += 1 ; NEW_LINE DEDENT DEDENT if ( ( total % 2 ) == 1 ) : NEW_LINE INDENT return \" First \" ; NEW_LINE DEDENT return \" Second \" ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" GSSS \" ; NEW_LINE length = len ( string ) ; NEW_LINE print ( getWinner ( string , length ) ) ; NEW_LINE DEDENT"],"bleu":0.8258714823727831,"rouge_l":0.953408752604942}
{"id":1066,"predictions":["def countPermutations ( N , B ) : NEW_LINE INDENT x = pow ( B , N ) NEW_LINE y = pow ( B , N - 1 ) NEW_LINE print ( x - y ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 6 NEW_LINE B = 4 NEW_LINE countPermutations ( N , B ) NEW_LINE DEDENT"],"references":["def countPermutations ( N , B ) : NEW_LINE INDENT x = B ** N NEW_LINE y = B ** ( N - 1 ) NEW_LINE print ( x - y ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N , B = 6 , 4 NEW_LINE countPermutations ( N , B ) NEW_LINE DEDENT"],"bleu":0.6564424563574516,"rouge_l":0.8508749682982503}
{"id":1067,"predictions":["def check ( k , d0 , d1 ) : NEW_LINE INDENT s = ( 2 * ( d0 + d1 ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 NEW_LINE a = ( k - 3 ) % 4 NEW_LINE x = 0 NEW_LINE if ( a == 0 ) : NEW_LINE INDENT x = 0 NEW_LINE DEDENT elif ( a == 0 ) : NEW_LINE INDENT x = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 NEW_LINE DEDENT elif ( a == 3 ) : NEW_LINE INDENT x = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 NEW_LINE DEDENT sum = d0 + d1 + ( ( k - 3 ) \/\/ 4 ) * s + x ) NEW_LINE if ( sum % 3 == 0 ) : NEW_LINE INDENT return \" YES \" NEW_LINE DEDENT return \" NO \" NEW_LINE DEDENT k = 13 NEW_LINE d0 = 8 NEW_LINE d1 = 1 NEW_LINE d1 = 3 NEW_LINE d1 = 4 NEW_LINE print ( check ( k , d0 , d1 ) ) NEW_LINE k = 5 NEW_LINE d1 = 3 NEW_LINE d1 = 4 NEW_LINE print ( check ( k , d0 , d1 , d1 ) ) NEW_LINE"],"references":["def check ( k , d0 , d1 ) : NEW_LINE INDENT s = ( ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 + ( 6 * ( d0 + d1 ) ) % 10 ) NEW_LINE a = ( k - 3 ) % 4 NEW_LINE if ( a == 0 ) : NEW_LINE INDENT x = 0 NEW_LINE DEDENT elif ( a == 1 ) : NEW_LINE INDENT x = ( 2 * ( d0 + d1 ) ) % 10 NEW_LINE DEDENT elif ( a == 2 ) : NEW_LINE INDENT x = ( ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 ) NEW_LINE DEDENT elif ( a == 3 ) : NEW_LINE INDENT x = ( ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 ) NEW_LINE DEDENT sum = d0 + d1 + ( ( k - 3 ) \/\/ 4 ) * s + x NEW_LINE if ( sum % 3 == 0 ) : NEW_LINE INDENT return \" YES \" NEW_LINE DEDENT else : NEW_LINE INDENT return \" NO \" NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT k = 13 NEW_LINE d0 = 8 NEW_LINE d1 = 1 NEW_LINE print ( check ( k , d0 , d1 ) ) NEW_LINE k = 5 NEW_LINE d0 = 3 NEW_LINE d1 = 4 NEW_LINE print ( check ( k , d0 , d1 ) ) NEW_LINE DEDENT"],"bleu":0.7767655301845929,"rouge_l":0.8726365400609926}
{"id":1068,"predictions":["if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE num = 1 NEW_LINE gap = n - 1 NEW_LINE for j in range ( 1 , n + 1 ) : NEW_LINE INDENT num = j NEW_LINE for i in range ( 1 , gap + 1 ) : NEW_LINE INDENT print ( \" ▁ \" , end = \" \" ) NEW_LINE DEDENT gap -= 1 NEW_LINE num -= 1 NEW_LINE for i in range ( 1 , j + 1 ) : NEW_LINE INDENT print ( num , end = \" \" ) NEW_LINE num += 1 NEW_LINE DEDENT num -= 1 NEW_LINE num -= 1 NEW_LINE for i in range ( 1 , j ) : NEW_LINE INDENT print ( num , num , num ) NEW_LINE num -= 1 NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT"],"references":["n = 5 NEW_LINE num = 1 NEW_LINE gap = n - 1 NEW_LINE for j in range ( 1 , n + 1 ) : NEW_LINE INDENT num = j NEW_LINE for i in range ( 1 , gap + 1 ) : NEW_LINE INDENT print ( \" ▁ \" , end = \" \" ) NEW_LINE DEDENT gap = gap - 1 NEW_LINE for i in range ( 1 , j + 1 ) : NEW_LINE INDENT print ( num , end = \" \" ) NEW_LINE num = num + 1 NEW_LINE DEDENT num = num - 2 NEW_LINE for i in range ( 1 , j ) : NEW_LINE INDENT print ( num , end = \" \" ) NEW_LINE num = num - 1 NEW_LINE DEDENT print ( ) NEW_LINE DEDENT"],"bleu":0.7507482492653588,"rouge_l":0.8490894327804197}
{"id":1069,"predictions":["def isKthBitSet ( x , k ) : NEW_LINE INDENT return ( x & ( 1 << ( k - 1 ) ) ) NEW_LINE DEDENT def isPalindrome ( x ) : NEW_LINE INDENT l = 1 NEW_LINE r = ( 32 * 8 ) * 8 NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( isKthBitSet ( x , l ) != isKthBitSet ( x , r ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = 1 NEW_LINE print ( isPalindrome ( x ) ) NEW_LINE x = ( 1 << 31 ) + 1 NEW_LINE print ( isPalindrome ( x ) ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE def isKthBitSet ( x , k ) : NEW_LINE INDENT if ( ( x & ( 1 << ( k - 1 ) ) ) != 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def isPalindrome ( x ) : NEW_LINE INDENT l = 1 NEW_LINE r = 2 * 8 NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( isKthBitSet ( x , l ) != isKthBitSet ( x , r ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 1 << 15 + 1 << 16 NEW_LINE print ( int ( isPalindrome ( x ) ) ) NEW_LINE x = 1 << 31 + 1 NEW_LINE print ( int ( isPalindrome ( x ) ) ) NEW_LINE DEDENT"],"bleu":0.6525881037552267,"rouge_l":0.8173437667488476}
{"id":1070,"predictions":["def getSum ( a , n ) : NEW_LINE INDENT P = [ 0 for i in range ( n ) ] NEW_LINE P [ 0 ] = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT P [ i ] = a [ i ] + P [ i - 1 ] NEW_LINE DEDENT S = set ( ) NEW_LINE for i in range ( 1 , int ( sqrt ( S ) ) + 1 ) : NEW_LINE INDENT if ( S % i == 0 ) : NEW_LINE INDENT pres = 1 NEW_LINE div1 , div2 = i , S \/\/ i NEW_LINE for j in range ( div1 , S + 1 , 1 ) : NEW_LINE INDENT if ( S % i == 0 ) : NEW_LINE INDENT pres = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if ( pres & div1 != S ) : NEW_LINE INDENT res . add ( div1 ) NEW_LINE DEDENT DEDENT if ( pres and div1 != S ) : NEW_LINE INDENT res . add ( div1 ) NEW_LINE DEDENT DEDENT if ( pres and div2 != S ) : NEW_LINE INDENT res . add ( div1 ) NEW_LINE DEDENT DEDENT if ( len ( res ) == 0 ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE return NEW_LINE DEDENT for i in res : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 2 , 1 , 1 , 1 , 1 , 2 , 1 , 3 ] NEW_LINE n = len ( a ) NEW_LINE getSum ( a , n ) NEW_LINE DEDENT"],"references":["from math import sqrt NEW_LINE def getSum ( a , n ) : NEW_LINE INDENT P = [ 0 ] * n NEW_LINE P [ 0 ] = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT P [ i ] = a [ i ] + P [ i - 1 ] NEW_LINE DEDENT S = P [ n - 1 ] NEW_LINE hash = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ P [ i ] ] = 1 NEW_LINE DEDENT res = set ( ) NEW_LINE for i in range ( 1 , int ( sqrt ( S ) ) + 1 ) : NEW_LINE INDENT if ( S % i == 0 ) : NEW_LINE INDENT pres = True ; NEW_LINE div1 = i NEW_LINE div2 = S \/\/ i NEW_LINE for j in range ( div1 , S + 1 , div1 ) : NEW_LINE INDENT if j not in hash . keys ( ) : NEW_LINE INDENT pres = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( pres and div1 != S ) : NEW_LINE INDENT res . add ( div1 ) NEW_LINE DEDENT pres = True NEW_LINE for j in range ( S \/\/ i , S + 1 , S \/\/ i ) : NEW_LINE INDENT if j not in hash . keys ( ) : NEW_LINE INDENT pres = False ; NEW_LINE break NEW_LINE DEDENT DEDENT if ( pres and div2 != S ) : NEW_LINE INDENT res . add ( div2 ) NEW_LINE DEDENT DEDENT DEDENT if ( len ( res ) == 0 ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE return NEW_LINE DEDENT for i in res : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 2 , 1 , 1 , 1 , 2 , 1 , 3 ] NEW_LINE n = len ( a ) NEW_LINE getSum ( a , n ) NEW_LINE DEDENT"],"bleu":0.6978133567291531,"rouge_l":0.7966473368744211}
{"id":1071,"predictions":["MAX_CHAR = 26 ; NEW_LINE def removeChars ( arr , k ) : NEW_LINE INDENT hash = [ 0 ] * MAX_CHAR ; NEW_LINE n = len ( arr ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ ord ( arr [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT ans = \" \" ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( hash [ ord ( arr [ i ] ) - ord ( ' a ' ) ] != k ) : NEW_LINE INDENT ans += arr [ i ] ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeksforgeeks \" ; NEW_LINE k = 2 ; NEW_LINE print ( removeChars ( str , k ) ) ; NEW_LINE DEDENT"],"references":["MAX_CHAR = 26 NEW_LINE def removeChars ( arr , k ) : NEW_LINE INDENT hash = [ 0 ] * MAX_CHAR NEW_LINE n = len ( arr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ ord ( arr [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT ans = \" \" NEW_LINE index = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( hash [ ord ( arr [ i ] ) - ord ( ' a ' ) ] != k ) : NEW_LINE INDENT ans += arr [ i ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeksforgeeks \" NEW_LINE k = 2 NEW_LINE print ( removeChars ( str , k ) ) NEW_LINE DEDENT"],"bleu":0.8383964780498575,"rouge_l":0.9579104796496102}
{"id":1072,"predictions":["def firstEven ( arr , n ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( mp [ arr [ i ] ] == 0 ) : NEW_LINE INDENT mp [ arr [ i ] ] = False NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = False NEW_LINE DEDENT DEDENT for j in range ( n ) : NEW_LINE INDENT if ( mp [ arr [ j ] ] == True ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return arr [ j ] NEW_LINE DEDENT arr = [ 2 , 4 , 6 , 8 , 1 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( firstEven ( arr , n ) ) NEW_LINE"],"references":["def firstEven ( arr , n ) : NEW_LINE INDENT map1 = { } NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] not in map1 : NEW_LINE INDENT map1 [ arr [ i ] ] = False NEW_LINE DEDENT else : NEW_LINE INDENT map1 [ arr [ i ] ] = not map1 [ arr [ i ] ] NEW_LINE DEDENT DEDENT for j in range ( 0 , n ) : NEW_LINE INDENT if map1 [ arr [ j ] ] == True : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return arr [ j ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 4 , 6 , 8 , 1 , 6 ] NEW_LINE print ( firstEven ( arr , 6 ) ) NEW_LINE DEDENT"],"bleu":0.6542034070243713,"rouge_l":0.7967461044912925}
{"id":1073,"predictions":["def ReverseString ( s ) : NEW_LINE INDENT s = \" \" NEW_LINE for i in range ( len ( s ) \/\/ 2 ) : NEW_LINE INDENT arr [ i ] = arr [ len ( s ) - i - 1 ] NEW_LINE arr [ i ] = arr [ len ( s ) - i - 1 ] NEW_LINE DEDENT return \" \" . join ( s ) ; NEW_LINE DEDENT def binary_conversions ( m ) : NEW_LINE INDENT while ( m ) : NEW_LINE INDENT tmp = m % 2 NEW_LINE s += str ( tmp ) NEW_LINE m = ( m \/\/ 2 ) NEW_LINE DEDENT s = reverseString ( s ) NEW_LINE DEDENT def find_char ( n , m , i ) : NEW_LINE INDENT binary_conversions ( m ) NEW_LINE s1 = \" \" \" NEW_LINE for x in range ( n ) : NEW_LINE INDENT for y in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ y ] == '1' ) : NEW_LINE INDENT s1 += \"10\" NEW_LINE DEDENT else : NEW_LINE INDENT s1 += \"01\" NEW_LINE DEDENT DEDENT s = s1 NEW_LINE s1 = \" \" NEW_LINE DEDENT return ord ( s [ i ] ) - ord ( '0' ) NEW_LINE DEDENT m = 5 NEW_LINE n = 2 NEW_LINE i = 8 NEW_LINE print ( find_char ( n , m , i ) ) NEW_LINE"],"references":["def binary_conversion ( s , m ) : NEW_LINE INDENT while ( m ) : NEW_LINE INDENT temp = m % 2 NEW_LINE s += str ( temp ) NEW_LINE m = m \/\/ 2 NEW_LINE DEDENT return s [ : : - 1 ] NEW_LINE DEDENT def find_character ( n , m , i ) : NEW_LINE INDENT s = \" \" NEW_LINE s = binary_conversion ( s , m ) NEW_LINE s1 = \" \" NEW_LINE for x in range ( n ) : NEW_LINE INDENT for j in range ( len ( s ) ) : NEW_LINE INDENT if s [ j ] == \"1\" : NEW_LINE INDENT s1 += \"10\" NEW_LINE DEDENT else : NEW_LINE INDENT s1 += \"01\" NEW_LINE DEDENT DEDENT s = s1 NEW_LINE s1 = \" \" NEW_LINE DEDENT e = ord ( s [ i ] ) NEW_LINE r = ord ( '0' ) NEW_LINE return e - r NEW_LINE DEDENT m , n , i = 5 , 2 , 8 NEW_LINE print ( find_character ( n , m , i ) ) NEW_LINE"],"bleu":0.5099242975128041,"rouge_l":0.6819154840244193}
{"id":1074,"predictions":["def cntSquares ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) * ( 2 * n + 1 ) \/\/ 6 ) ; NEW_LINE DEDENT print ( cntSquares ( 4 ) ) ; NEW_LINE"],"references":["def cntSquares ( n ) : NEW_LINE INDENT return int ( n * ( n + 1 ) * ( 2 * n + 1 ) \/ 6 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( cntSquares ( 4 ) ) ; NEW_LINE DEDENT"],"bleu":0.574554266746521,"rouge_l":0.7873641304347827}
{"id":1075,"predictions":["def multiplyWith3Point5 ( x ) : NEW_LINE INDENT return ( x << 1 ) + x + ( x >> 1 ) NEW_LINE DEDENT x = 2 NEW_LINE print ( multiplyWith3Point5 ( x ) ) NEW_LINE"],"references":["def multiplyWith3Point5 ( x ) : NEW_LINE INDENT return ( x << 1 ) + x + ( x >> 1 ) NEW_LINE DEDENT x = 4 NEW_LINE print ( multiplyWith3Point5 ( x ) ) NEW_LINE"],"bleu":0.9278982724420874,"rouge_l":0.9722222222222222}
{"id":1076,"predictions":["def countSubSeq ( str , len1 ) : NEW_LINE INDENT ans = 0 ; NEW_LINE mul = 1 ; NEW_LINE for i in range ( len1 ) : NEW_LINE INDENT if ( str1 [ i ] == '0' ) : NEW_LINE INDENT ans += mul ; NEW_LINE DEDENT mul *= 2 ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \"10010\" ; NEW_LINE len1 = len ( str ) ; NEW_LINE print ( countSubSeq ( str , len1 ) ) ; NEW_LINE DEDENT"],"references":["def countSubSeq ( strr , lenn ) : NEW_LINE INDENT ans = 0 NEW_LINE mul = 1 NEW_LINE for i in range ( lenn ) : NEW_LINE INDENT if ( strr [ i ] == '0' ) : NEW_LINE INDENT ans += mul NEW_LINE DEDENT mul *= 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT strr = \"10010\" NEW_LINE lenn = len ( strr ) NEW_LINE print ( countSubSeq ( strr , lenn ) ) NEW_LINE"],"bleu":0.43389887169313346,"rouge_l":0.785560975609756}
{"id":1077,"predictions":["def swapThree ( ) : NEW_LINE INDENT a [ 0 ] = a + b + c NEW_LINE b = a - ( b + c ) NEW_LINE c = a - ( b + c ) NEW_LINE c = a - ( b + c ) NEW_LINE a = a - ( b + c ) NEW_LINE DEDENT a = 10 NEW_LINE b = 20 NEW_LINE c = 30 NEW_LINE print ( \" Before ▁ swapping ▁ a ▁ = ▁ \" , a , \" , ▁ b ▁ = ▁ \" , b , \" , ▁ c ▁ = ▁ \" , c ▁ = ▁ \" , c ) NEW_LINE swapThree ( a , b , 0 ) NEW_LINE print ( \" After ▁ swapping ▁ a ▁ = ▁ \" , a , \" , ▁ b ▁ = ▁ \" , b , ▁ = ▁ \" , c [ 0 ] ) NEW_LINE"],"references":["def swapThree ( a , b , c ) : NEW_LINE INDENT a = a + b + c NEW_LINE b = a - ( b + c ) NEW_LINE c = a - ( b + c ) NEW_LINE a = a - ( b + c ) NEW_LINE print ( \" After ▁ swapping ▁ a ▁ = \" , a , \" , ▁ b ▁ = \" , b , \" , ▁ c ▁ = \" , c ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 10 NEW_LINE b = 20 NEW_LINE c = 30 NEW_LINE print ( \" Before ▁ swapping ▁ a ▁ = \" , a , \" , ▁ b ▁ = \" , b , \" , ▁ c ▁ = \" , c ) NEW_LINE swapThree ( a , b , c ) NEW_LINE DEDENT"],"bleu":0.7273769302650296,"rouge_l":0.708640182553677}
{"id":1078,"predictions":["def countSubarrays ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE pre = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT pre [ i ] = pre [ i - 1 ] + a [ i - 1 ] NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT sum1 = pre [ j ] - pre [ i - 1 ] NEW_LINE count1 = pre [ n ] - sum1 NEW_LINE sum2 = ( n - count1 ) if ( ( n - count1 ) == 0 ) ) else : NEW_LINE INDENT count = sum1 \/\/ count1 NEW_LINE DEDENT if ( ( count1 ) == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 6 , 3 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countSubarrays ( arr , n ) ) NEW_LINE DEDENT"],"references":["def countSubarrays ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE pre = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT pre [ i ] = pre [ i - 1 ] + a [ i - 1 ] NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT sum1 = pre [ j ] - pre [ i - 1 ] NEW_LINE count1 = j - i + 1 NEW_LINE sum2 = pre [ n ] - sum1 NEW_LINE if n - count1 == 0 : NEW_LINE INDENT count2 = 1 NEW_LINE DEDENT else : NEW_LINE INDENT count2 = n - count1 NEW_LINE DEDENT includ = sum1 \/\/ count1 NEW_LINE exclud = sum2 \/\/ count2 NEW_LINE if ( includ > exclud ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 6 , 3 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countSubarrays ( arr , n ) ) NEW_LINE"],"bleu":0.8076759398606079,"rouge_l":0.8398058252427184}
{"id":1079,"predictions":["def reverse ( arr , n , k , m ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT left = i NEW_LINE right = min ( i + k - 1 , n - 1 ) NEW_LINE while left < right : NEW_LINE INDENT arr [ left ] , arr [ right ] = arr [ right ] , arr [ right ] NEW_LINE left += 1 NEW_LINE right -= 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 13 , 14 ] NEW_LINE k = 3 NEW_LINE m = 2 NEW_LINE n = len ( arr ) NEW_LINE reverse ( arr , k , m ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT"],"references":["def reverse ( arr , n , k , m ) : NEW_LINE INDENT for i in range ( 0 , n , k + m ) : NEW_LINE INDENT left = i ; NEW_LINE right = min ( i + k - 1 , n - 1 ) ; NEW_LINE while ( left < right ) : NEW_LINE INDENT arr = swap ( arr , left , right ) ; NEW_LINE left += 1 ; NEW_LINE right -= 1 ; NEW_LINE DEDENT DEDENT return arr ; NEW_LINE DEDENT def swap ( arr , i , j ) : NEW_LINE INDENT temp = arr [ i ] ; NEW_LINE arr [ i ] = arr [ j ] ; NEW_LINE arr [ j ] = temp ; NEW_LINE return arr ; NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 ] ; NEW_LINE k = 3 ; NEW_LINE m = 2 ; NEW_LINE n = len ( arr ) ; NEW_LINE arr = reverse ( arr , n , k , m ) ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT"],"bleu":0.5116683434113422,"rouge_l":0.7279352875220246}
{"id":1080,"predictions":["def count ( n ) : NEW_LINE INDENT return pow ( 2 , n - 1 ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 ; NEW_LINE print ( count ( n ) ) ; NEW_LINE DEDENT"],"references":["def count ( n ) : NEW_LINE INDENT return pow ( 2 , n - 1 ) NEW_LINE DEDENT n = 4 NEW_LINE print ( count ( n ) ) NEW_LINE"],"bleu":0.5287430133493595,"rouge_l":0.8164939550949913}
{"id":1081,"predictions":["def isSubsetSum ( set , n , sum ) : NEW_LINE INDENT subset = [ [ 0 for i in range ( sum + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , sum + 1 ) : NEW_LINE INDENT subset [ 0 ] [ i ] = True NEW_LINE DEDENT for i in range ( 1 , sum + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT subset [ i ] [ j ] = subset [ i ] [ j - 1 ] NEW_LINE if ( i >= set [ j - 1 ] ) : NEW_LINE INDENT subset [ i ] [ j ] = ( subset [ i ] [ j ] or subset [ i - set [ j - 1 ] ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return subset [ sum ] [ n ] NEW_LINE DEDENT set = [ 3 , 34 , 4 , 12 , 5 , 2 ] NEW_LINE sum = 9 NEW_LINE n = len ( set ) NEW_LINE if ( isSubsetSum ( set , n , sum ) == True ) : NEW_LINE INDENT print ( \" Found ▁ a ▁ subset ▁ with ▁ given ▁ sum \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No ▁ subset ▁ with ▁ given ▁ sum \" ) NEW_LINE DEDENT"],"references":["def isSubsetSum ( set , n , sum ) : NEW_LINE INDENT subset = ( [ [ False for i in range ( sum + 1 ) ] for i in range ( n + 1 ) ] ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT subset [ i ] [ 0 ] = True NEW_LINE DEDENT for i in range ( 1 , sum + 1 ) : NEW_LINE INDENT subset [ 0 ] [ i ] = False NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , sum + 1 ) : NEW_LINE INDENT if j < set [ i - 1 ] : NEW_LINE INDENT subset [ i ] [ j ] = subset [ i - 1 ] [ j ] NEW_LINE DEDENT if j >= set [ i - 1 ] : NEW_LINE INDENT subset [ i ] [ j ] = ( subset [ i - 1 ] [ j ] or subset [ i - 1 ] [ j - set [ i - 1 ] ] ) NEW_LINE DEDENT DEDENT DEDENT return subset [ n ] [ sum ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT set = [ 3 , 34 , 4 , 12 , 5 , 2 ] NEW_LINE sum = 9 NEW_LINE n = len ( set ) NEW_LINE if ( isSubsetSum ( set , n , sum ) == True ) : NEW_LINE INDENT print ( \" Found ▁ a ▁ subset ▁ with ▁ given ▁ sum \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No ▁ subset ▁ with ▁ given ▁ sum \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.7277870844680245,"rouge_l":0.8313036418464393}
{"id":1082,"predictions":["def colourVisible ( height , colour , K ) : NEW_LINE INDENT arr = [ 0 for i in range ( K + 1 ) ] NEW_LINE vertical = 0 NEW_LINE max = height [ K - 1 ] NEW_LINE arr [ colour [ K - 1 ] ] = 1 NEW_LINE for i in range ( K - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( height [ i ] > max ) : NEW_LINE INDENT max = height [ i ] NEW_LINE arr [ colour [ i ] ] = 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , K + 1 ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT vis += 1 NEW_LINE DEDENT DEDENT return visible NEW_LINE DEDENT height = [ 3 , 5 , 1 , 2 , 3 ] NEW_LINE colour = [ 1 , 2 , 3 , 4 , 3 ] NEW_LINE K = len ( colour ) NEW_LINE print ( colourVisible ( height , colour , K ) ) NEW_LINE"],"references":["def colourVisible ( height , colour , K ) : NEW_LINE INDENT arr = [ 0 for i in range ( K + 1 ) ] NEW_LINE visible = 0 NEW_LINE max = height [ K - 1 ] NEW_LINE arr [ colour [ K - 1 ] ] = 1 NEW_LINE i = K - 2 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( height [ i ] > max ) : NEW_LINE INDENT max = height [ i ] NEW_LINE arr [ colour [ i ] ] = 1 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT for i in range ( 1 , K + 1 , 1 ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT visible += 1 NEW_LINE DEDENT DEDENT return visible NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT height = [ 3 , 5 , 1 , 2 , 3 ] NEW_LINE colour = [ 1 , 2 , 3 , 4 , 3 ] NEW_LINE K = len ( colour ) NEW_LINE print ( colourVisible ( height , colour , K ) ) NEW_LINE DEDENT"],"bleu":0.8045235807285316,"rouge_l":0.88644812436634}
{"id":1083,"predictions":["def sortRows ( mat , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT mat [ i ] . sort ( ) ; NEW_LINE DEDENT DEDENT def findAndPrintCommonElements ( mat , n ) : NEW_LINE INDENT sortRows ( mat , n ) ; NEW_LINE curr_index = [ 0 ] * n ; NEW_LINE f = 0 ; NEW_LINE for curr_index [ 0 ] in range ( n ) : NEW_LINE INDENT value = mat [ 0 ] [ curr_index [ 0 ] ] ; NEW_LINE present = True ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT while ( curr_index [ i ] < n and mat [ i ] [ curr_index [ i ] ] <= value ) : NEW_LINE INDENT curr_index [ i ] += 1 ; NEW_LINE DEDENT if ( mat [ i ] [ curr_index [ i ] - 1 ] != value ) : NEW_LINE INDENT present = False ; NEW_LINE DEDENT if ( curr_index [ i ] == n ) : NEW_LINE INDENT f = 1 ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( not f ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT if ( not f ) : NEW_LINE INDENT print ( value , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT mat = [ [ 12 , 1 , 14 , 3 , 16 ] , [ 14 , 2 , 1 , 3 , 35 , 11 ] , [ 14 , 1 , 14 , 3 , 2 , 1 ] , [ 1 , 18 , 3 , 21 , 14 ] ] ; NEW_LINE n = 5 ; NEW_LINE findAndPrintCommonElements ( mat , n ) ; NEW_LINE DEDENT"],"references":["MAX = 100 NEW_LINE def sortRows ( mat , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT mat [ i ] . sort ( ) ; NEW_LINE DEDENT DEDENT def findAndPrintCommonElements ( mat , n ) : NEW_LINE INDENT sortRows ( mat , n ) NEW_LINE curr_index = [ 0 ] * n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT curr_index [ i ] = 0 NEW_LINE DEDENT f = 0 NEW_LINE while ( curr_index [ 0 ] < n ) : NEW_LINE INDENT value = mat [ 0 ] [ curr_index [ 0 ] ] NEW_LINE present = True NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT while ( curr_index [ i ] < n and mat [ i ] [ curr_index [ i ] ] <= value ) : NEW_LINE INDENT curr_index [ i ] = curr_index [ i ] + 1 NEW_LINE DEDENT if ( mat [ i ] [ curr_index [ i ] - 1 ] != value ) : NEW_LINE INDENT present = False NEW_LINE DEDENT if ( curr_index [ i ] == n ) : NEW_LINE INDENT f = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( present ) : NEW_LINE INDENT print ( value , end = \" ▁ \" ) NEW_LINE DEDENT if ( f == 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT curr_index [ 0 ] = curr_index [ 0 ] + 1 NEW_LINE DEDENT DEDENT mat = [ [ 12 , 1 , 14 , 3 , 16 ] , [ 14 , 2 , 1 , 3 , 35 ] , [ 14 , 1 , 14 , 3 , 11 ] , [ 14 , 25 , 3 , 2 , 1 ] , [ 1 , 18 , 3 , 21 , 14 ] ] NEW_LINE n = 5 NEW_LINE findAndPrintCommonElements ( mat , n ) NEW_LINE"],"bleu":0.7302251445064744,"rouge_l":0.8199175194745684}
{"id":1084,"predictions":["def MaximumProduct ( a , n ) : NEW_LINE INDENT cntneg = 0 ; NEW_LINE cntzero = 0 ; NEW_LINE used = [ 0 ] * n ; NEW_LINE pos = - 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT cnt [ i ] = 1 ; NEW_LINE cntzero += 1 ; NEW_LINE DEDENT if ( a [ i ] < 0 ) : NEW_LINE INDENT cntneg += 1 ; NEW_LINE if ( pos == - 1 or abs ( a [ pos ] ) > abs ( a [ i ] ) ) : NEW_LINE INDENT pos = i ; NEW_LINE DEDENT DEDENT DEDENT if ( cntneg % 2 == 1 ) : NEW_LINE INDENT global cntzero ; NEW_LINE DEDENT if ( cntzero == n or ( cntzero == n - 1 and cntneg == 1 ) ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT print ( 1 , ( i + 1 ) , ( i + 2 ) ) ; NEW_LINE DEDENT return ; NEW_LINE DEDENT lst = - 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i > 1 ) : NEW_LINE INDENT if ( lst != - 1 ) : NEW_LINE INDENT lst != - 1 ) : NEW_LINE INDENT print ( 1 , ( lst + 1 ) , ( i + 2 ) ) ; NEW_LINE DEDENT lst = i ; NEW_LINE DEDENT DEDENT if ( lst != - 1 ) : NEW_LINE INDENT print ( 2 , lst + 1 ) ; NEW_LINE DEDENT lst = - 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( lst != 1 ) : NEW_LINE INDENT print ( lst , lst + 1 ) ; NEW_LINE DEDENT lst = - 1 ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 5 , - 2 , 0 ,"],"references":["def MaximumProduct ( a , n ) : NEW_LINE INDENT cntneg = 0 NEW_LINE cntzero = 0 NEW_LINE used = [ 0 ] * n NEW_LINE pos = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT used [ i ] = 1 NEW_LINE cntzero += 1 NEW_LINE DEDENT if ( a [ i ] < 0 ) : NEW_LINE INDENT cntneg += 1 NEW_LINE if ( pos == - 1 or abs ( a [ pos ] ) > abs ( a [ i ] ) ) : NEW_LINE INDENT pos = i NEW_LINE DEDENT DEDENT DEDENT if ( cntneg % 2 == 1 ) : NEW_LINE INDENT used [ pos ] = 1 NEW_LINE DEDENT if ( cntzero == n or ( cntzero == n - 1 and cntneg == 1 ) ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT print ( 1 , \" ▁ \" , i + 1 , \" ▁ \" , i + 2 ) NEW_LINE DEDENT return NEW_LINE DEDENT lst = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( used [ i ] ) : NEW_LINE INDENT if ( lst != - 1 ) : NEW_LINE INDENT print ( 1 , \" ▁ \" , lst + 1 , \" ▁ \" , i + 1 ) NEW_LINE DEDENT lst = i NEW_LINE DEDENT DEDENT if ( lst != - 1 ) : NEW_LINE INDENT print ( 2 , \" ▁ \" , lst + 1 ) NEW_LINE DEDENT lst = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( not used [ i ] ) : NEW_LINE INDENT if ( lst != - 1 ) : NEW_LINE INDENT print ( 1 , \" ▁ \" , lst + 1 , \" ▁ \" , i + 1 ) NEW_LINE DEDENT lst = i NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 5 , - 2 , 0 , 1 , - 3 ] NEW_LINE n = len ( a ) NEW_LINE MaximumProduct ( a , n ) NEW_LINE DEDENT"],"bleu":0.6985679198265423,"rouge_l":0.8291835298257962}
{"id":1085,"predictions":["def getSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n ) : NEW_LINE INDENT sum = sum + n % 10 NEW_LINE n = n \/\/ 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 687 NEW_LINE print ( getSum ( n ) ) NEW_LINE"],"references":["def getSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT sum = sum + int ( n % 10 ) NEW_LINE n = int ( n \/ 10 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 687 NEW_LINE print ( getSum ( n ) ) NEW_LINE"],"bleu":0.6977542774659412,"rouge_l":0.8954463750748951}
{"id":1086,"predictions":["def flipcount ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while n : NEW_LINE INDENT count += 1 NEW_LINE n &= ( n - 1 ) NEW_LINE DEDENT return count NEW_LINE DEDENT def FlipsCount ( a , b ) : NEW_LINE INDENT return countSetBits ( a ^ b ) NEW_LINE DEDENT a = 10 NEW_LINE b = 20 NEW_LINE print ( flipcount ( a , b ) ) NEW_LINE"],"references":["def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while n : NEW_LINE INDENT count += 1 NEW_LINE n &= ( n - 1 ) NEW_LINE DEDENT return count NEW_LINE DEDENT def FlippedCount ( a , b ) : NEW_LINE INDENT return countSetBits ( a ^ b ) NEW_LINE DEDENT a = 10 NEW_LINE b = 20 NEW_LINE print ( FlippedCount ( a , b ) ) NEW_LINE"],"bleu":0.9028529952145175,"rouge_l":0.9577464788732394}
{"id":1087,"predictions":["def findSum ( arr , N ) : NEW_LINE INDENT mp = { i : 0 for i in range ( N ) } NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] > maxFreq ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT maxFreq = 0 NEW_LINE for key , value in mp . items ( ) : NEW_LINE INDENT if ( value == maxFreq ) : NEW_LINE INDENT maxFreq = key NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 1 , 2 , 2 , 2 , 2 , 3 , 3 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE print ( findSum ( arr , N ) ) NEW_LINE DEDENT"],"references":["def findSum ( arr , N ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT mp [ arr [ i ] ] = mp . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT maxFreq = 0 NEW_LINE for itr in mp : NEW_LINE INDENT if ( mp [ itr ] > maxFreq ) : NEW_LINE INDENT maxFreq = mp [ itr ] NEW_LINE DEDENT DEDENT Sum = 0 NEW_LINE for itr in mp : NEW_LINE INDENT if ( mp [ itr ] == maxFreq ) : NEW_LINE INDENT Sum += itr * mp [ itr ] NEW_LINE DEDENT DEDENT return Sum NEW_LINE DEDENT arr = [ 1 , 1 , 2 , 2 , 2 , 2 , 3 , 3 , 3 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE print ( findSum ( arr , N ) ) NEW_LINE"],"bleu":0.6317180367187367,"rouge_l":0.6760549059481444}
{"id":1088,"predictions":["defCD_Factorial ( N ) : NEW_LINE INDENT if ( N <= 2 ) : NEW_LINE INDENT return N NEW_LINE DEDENT if ( N <= 4 ) : NEW_LINE INDENT return N + 3 NEW_LINE DEDENT if ( ( N - 4 ) % 4 == 0 ) : NEW_LINE INDENT return N + 1 NEW_LINE DEDENT elif ( ( N - 4 ) % 4 <= 2 ) : NEW_LINE INDENT return N + 2 NEW_LINE DEDENT elif ( ( N - 1 ) % 4 <= 2 ) : NEW_LINE INDENT return ( N + 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( N - 1 ) NEW_LINE DEDENT DEDENT N = 4 NEW_LINE print ( DodAsFactorial ( N ) ) NEW_LINE N = 10 NEW_LINE print ( Dodas_Factorial ( N ) ) NEW_LINE"],"references":["def MDAS_Factorial ( N ) : NEW_LINE INDENT if N <= 2 : NEW_LINE INDENT return N NEW_LINE DEDENT if N <= 4 : NEW_LINE INDENT return N + 3 NEW_LINE DEDENT if ( N - 4 ) % 4 == 0 : NEW_LINE INDENT return N + 1 NEW_LINE DEDENT elif ( N - 4 ) % 4 <= 2 : NEW_LINE INDENT return N + 2 NEW_LINE DEDENT else : NEW_LINE INDENT return N - 1 NEW_LINE DEDENT DEDENT N = 4 NEW_LINE print ( MDAS_Factorial ( N ) ) NEW_LINE N = 10 NEW_LINE print ( MDAS_Factorial ( N ) ) NEW_LINE"],"bleu":0.6087338052351616,"rouge_l":0.8551006245662733}
{"id":1089,"predictions":["def maxAND ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT res = res + ( arr [ i ] & arr [ j ] ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT arr = [ 4 , 8 , 6 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Maximum ▁ AND ▁ Value ▁ = ▁ \" , maxAND ( arr , n ) ) NEW_LINE"],"references":["def maxAND ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT res = max ( res , arr [ i ] & arr [ j ] ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT arr = [ 4 , 8 , 6 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Maximum ▁ AND ▁ Value ▁ = ▁ \" , maxAND ( arr , n ) ) NEW_LINE"],"bleu":0.9160113699130822,"rouge_l":0.9629510309278351}
{"id":1090,"predictions":["import math NEW_LINE def check ( arr , x , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT y = math . sqrt ( arr [ i ] ) NEW_LINE if ( math . floor ( y ) == ceil ( y ) ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT DEDENT if ( sum % x == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE x = 13 NEW_LINE if ( check ( arr , x , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["import math NEW_LINE def check ( a , y ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT x = math . sqrt ( a [ i ] ) NEW_LINE if ( math . floor ( x ) == math . ceil ( x ) ) : NEW_LINE INDENT sum = sum + a [ i ] NEW_LINE DEDENT DEDENT if ( sum % y == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT a = [ 2 , 3 , 4 , 9 , 10 ] NEW_LINE x = 13 NEW_LINE if check ( a , x ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.649848851903957,"rouge_l":0.8213054717794055}
{"id":1091,"predictions":["from math import sqrt NEW_LINE MAX_SIZE = int ( 1e6 + 1 ) NEW_LINE prime = [ True for i in range ( MAX_SIZE + 1 ) ] NEW_LINE def sieve ( ) : NEW_LINE INDENT p = 2 NEW_LINE while ( p * p <= MAX_SIZE ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , MAX_SIZE + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT def kthPrimeGreaterN ( n , k ) : NEW_LINE INDENT res = - 1 NEW_LINE for i in range ( n + 1 , MAX_SIZE ) : NEW_LINE INDENT if ( prime [ i ] == True ) : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT if ( k == 0 ) : NEW_LINE INDENT res = i NEW_LINE break NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT sieve ( ) NEW_LINE n = 2 NEW_LINE k = 15 NEW_LINE print ( kthPrimeGreaterThanN ( n , k ) ) NEW_LINE"],"references":["MAX_SIZE = int ( 1e6 ) NEW_LINE prime = [ True ] * ( MAX_SIZE + 1 ) NEW_LINE def seive ( ) : NEW_LINE INDENT p = 2 NEW_LINE while ( p * p <= MAX_SIZE ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , MAX_SIZE , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT def kthPrimeGreaterThanN ( n , k ) : NEW_LINE INDENT res = - 1 NEW_LINE for i in range ( n + 1 , MAX_SIZE ) : NEW_LINE INDENT if ( prime [ i ] == True ) : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT if ( k == 0 ) : NEW_LINE INDENT res = i NEW_LINE break NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 2 NEW_LINE k = 15 NEW_LINE seive ( ) NEW_LINE print ( kthPrimeGreaterThanN ( n , k ) ) NEW_LINE DEDENT"],"bleu":0.7932279213645964,"rouge_l":0.863109444255029}
{"id":1092,"predictions":["def minimumSets ( arr , n , key ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE i = 0 NEW_LINE j = n - 1 NEW_LINE while i <= j : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] <= key ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return i NEW_LINE DEDENT arr = [ 3 , 5 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE key = 5 NEW_LINE print ( minimumSets ( arr , n , key ) ) NEW_LINE"],"references":["def minimumSets ( arr , n , key ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE j = n - 1 NEW_LINE for i in range ( 0 , j + 1 , 1 ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] <= key ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT DEDENT return i + 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 5 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE key = 5 NEW_LINE print ( minimumSets ( arr , n , key ) ) NEW_LINE DEDENT"],"bleu":0.6736139981384792,"rouge_l":0.8067141403865717}
{"id":1093,"predictions":["def isPalindrome ( string ) : NEW_LINE INDENT l = len ( string ) NEW_LINE if ( l == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT ptr1 = string [ 0 ] NEW_LINE ptr2 = string [ l - 1 ] NEW_LINE while ( ptr2 > ptr1 ) : NEW_LINE INDENT if ( ptr1 != ptr2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT ptr1 += 1 NEW_LINE ptr2 -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def noOfBeappush ( s ) : NEW_LINE INDENT if ( isPalindrome ( s ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT s = s [ 1 : len ( s ) ] NEW_LINE return 1 + noOfBeending ( s ) NEW_LINE DEDENT s = \" abde \" NEW_LINE print ( noOfAdending ( s ) ) NEW_LINE"],"references":["def isPalindrome ( Str ) : NEW_LINE INDENT Len = len ( Str ) NEW_LINE if ( Len == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT ptr1 = 0 NEW_LINE ptr2 = Len - 1 NEW_LINE while ( ptr2 > ptr1 ) : NEW_LINE INDENT if ( Str [ ptr1 ] != Str [ ptr2 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT ptr1 += 1 NEW_LINE ptr2 -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def noOfAppends ( s ) : NEW_LINE INDENT if ( isPalindrome ( s ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT del s [ 0 ] NEW_LINE return 1 + noOfAppends ( s ) NEW_LINE DEDENT se = \" abede \" NEW_LINE s = [ i for i in se ] NEW_LINE print ( noOfAppends ( s ) ) NEW_LINE"],"bleu":0.6243820946892451,"rouge_l":0.809478672985782}
{"id":1094,"predictions":["import math as mt NEW_LINE def add_factors ( n , m ) : NEW_LINE INDENT for i in range ( 1 , mt . ceil ( mt . sqrt ( n + 1 ) ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n \/\/ i == i ) : NEW_LINE INDENT m [ i ] = ( m [ i ] + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT m [ i ] = 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( i in m . keys ( ) ) : NEW_LINE INDENT m [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ i ] = 1 NEW_LINE DEDENT if ( n \/\/ i ) : NEW_LINE INDENT m [ n \/\/ i ] = m . get ( n \/\/ i ) + 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ n \/\/ i ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT def count_divisors ( a , n ) : NEW_LINE INDENT m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( 0 , a [ i ] ) NEW_LINE DEDENT add_factors ( a [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 8 , 1 , 28 , 4 , 2 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE count_divisors ( arr , n ) NEW_LINE DEDENT"],"references":["from collections import defaultdict NEW_LINE import math NEW_LINE def add_factors ( n , mp ) : NEW_LINE INDENT for i in range ( 1 , int ( math . sqrt ( n ) ) + 1 , ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n \/\/ i == i ) : NEW_LINE INDENT mp [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ i ] += 1 NEW_LINE mp [ n \/\/ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT def count_divisors ( a , n ) : NEW_LINE INDENT mp = defaultdict ( int ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( mp [ a [ i ] ] , end = \" ▁ \" ) NEW_LINE add_factors ( a [ i ] , mp ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 8 , 1 , 28 , 4 , 2 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE count_divisors ( arr , n ) NEW_LINE DEDENT"],"bleu":0.549602242940209,"rouge_l":0.7359485623464816}
{"id":1095,"predictions":["def isPossible ( arr , n , C , mid ) : NEW_LINE INDENT determin = 1 NEW_LINE currPosition = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] - currPosition >= mid ) : NEW_LINE INDENT determin += 1 NEW_LINE currPosition = arr [ i ] NEW_LINE if ( vis == C ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def binarySearch ( n , C , arr ) ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE lo = 0 NEW_LINE hi = arr [ n - 1 ] NEW_LINE ans = 0 NEW_LINE while ( lo <= hi ) : NEW_LINE INDENT mid = ( lo + hi ) \/\/ 2 NEW_LINE if ( not isPossible ( arr , n , C , mid ) ) : NEW_LINE INDENT hi = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( ans , mid ) NEW_LINE lo = mid + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT C = 4 NEW_LINE arr = [ 1 , 2 , 5 , 8 , 10 , 18 ] NEW_LINE n = len ( arr ) NEW_LINE print ( binarySearch ( n , C , arr ) ) NEW_LINE DEDENT"],"references":["def isPossible ( arr , n , C , mid ) : NEW_LINE INDENT magnet = 1 NEW_LINE currPosition = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] - currPosition >= mid ) : NEW_LINE INDENT magnet += 1 NEW_LINE currPosition = arr [ i ] NEW_LINE if ( magnet == C ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT def binarySearch ( n , C , arr ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE lo = 0 NEW_LINE hi = arr [ n - 1 ] NEW_LINE ans = 0 NEW_LINE while ( lo <= hi ) : NEW_LINE INDENT mid = int ( ( lo + hi ) \/ 2 ) NEW_LINE if ( isPossible ( arr , n , C , mid ) == False ) : NEW_LINE INDENT hi = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( ans , mid ) NEW_LINE lo = mid + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT C = 4 NEW_LINE arr = [ 1 , 2 , 5 , 8 , 10 , 18 ] NEW_LINE n = len ( arr ) NEW_LINE print ( binarySearch ( n , C , arr ) ) NEW_LINE DEDENT"],"bleu":0.8895219068272967,"rouge_l":0.9579849071996736}
{"id":1096,"predictions":["def makePalindrome ( n , odd ) : NEW_LINE INDENT res = n \/\/ 10 NEW_LINE if ( odd ) : NEW_LINE INDENT n = n \/\/ 10 NEW_LINE DEDENT while ( n > 0 ) : NEW_LINE INDENT res = 10 * res + n % 10 NEW_LINE n \/\/= 10 NEW_LINE DEDENT return res NEW_LINE DEDENT def isPalindrome ( n , base ) : NEW_LINE INDENT reversed = 0 NEW_LINE temp = n NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT reversed = reversed * base + temp % base NEW_LINE temp \/\/= base NEW_LINE DEDENT return reversed == n NEW_LINE DEDENT def sumPalindrome ( n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE i = 1 NEW_LINE while ( temp < n ) : NEW_LINE INDENT if ( isPalindrome ( p , k ) ) : NEW_LINE INDENT sum += p NEW_LINE DEDENT i += 1 NEW_LINE p = makePalindrome ( i , True ) NEW_LINE DEDENT i = 1 NEW_LINE p = makePalindrome ( i , False ) NEW_LINE while ( p < n ) : NEW_LINE INDENT if ( isPalindrome ( p , k ) ) : NEW_LINE INDENT sum += p NEW_LINE DEDENT i += 1 NEW_LINE p = makePalindrome ( i , False ) NEW_LINE DEDENT print ( \" Total ▁ sum ▁ is \" , sum ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 1000000 NEW_LINE k = 2 NEW_LINE sumPalindrome ( n , k ) NEW_LINE DEDENT"],"references":["def makePalindrome ( n , odd ) : NEW_LINE INDENT res = n ; NEW_LINE if ( odd ) : NEW_LINE INDENT n = int ( n \/ 10 ) ; NEW_LINE DEDENT while ( n > 0 ) : NEW_LINE INDENT res = 10 * res + n % 10 ; NEW_LINE n = int ( n \/ 10 ) ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT def isPalindrome ( n , base ) : NEW_LINE INDENT reversed = 0 ; NEW_LINE temp = n ; NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT reversed = reversed * base + temp % base ; NEW_LINE temp = int ( temp \/ base ) ; NEW_LINE DEDENT return reversed == n ; NEW_LINE DEDENT def sumPalindrome ( n , k ) : NEW_LINE INDENT sum = 0 ; NEW_LINE i = 1 ; NEW_LINE p = makePalindrome ( i , True ) ; NEW_LINE while ( p < n ) : NEW_LINE INDENT if ( isPalindrome ( p , k ) ) : NEW_LINE INDENT sum += p ; NEW_LINE DEDENT i += 1 ; NEW_LINE p = makePalindrome ( i , True ) ; NEW_LINE DEDENT i = 1 ; NEW_LINE p = makePalindrome ( i , False ) ; NEW_LINE while ( p < n ) : NEW_LINE INDENT if ( isPalindrome ( p , k ) ) : NEW_LINE INDENT sum += p ; NEW_LINE DEDENT i += 1 ; NEW_LINE p = makePalindrome ( i , False ) ; NEW_LINE DEDENT print ( \" Total ▁ sum ▁ is \" , sum ) ; NEW_LINE DEDENT n = 1000000 ; NEW_LINE k = 2 ; NEW_LINE sumPalindrome ( n , k ) ; NEW_LINE"],"bleu":0.6752560912492838,"rouge_l":0.8623939679547596}
{"id":1097,"predictions":["class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def countNode ( data ) : NEW_LINE INDENT newNode = Node ( 0 ) NEW_LINE newNode . data = data NEW_LINE newNode . left = newNode . right = None NEW_LINE return ( newNode ) NEW_LINE DEDENT def countUntil ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT l = countLeave ( root . left ) NEW_LINE r = countNode ( root . right ) NEW_LINE maxCount = max ( root . right ) NEW_LINE if ( root . data == 1 ) : NEW_LINE INDENT maxCount = l + r + 1 NEW_LINE DEDENT else : NEW_LINE INDENT maxCount = l + r + 1 NEW_LINE DEDENT res = max ( res , maxCount ) NEW_LINE if ( root . data == 1 ) : NEW_LINE INDENT return max ( l , r ) + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return max ( l , r ) NEW_LINE DEDENT DEDENT def findMaxCount ( root ) : NEW_LINE INDENT res = - ord ( root ) NEW_LINE countLeave ( root ) NEW_LINE return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 1 ) NEW_LINE root . left = newNode ( 0 ) NEW_LINE root . right = newNode ( 1 ) NEW_LINE root . left . left = newNode ( 1 ) NEW_LINE root . left . left = newNode ( 1 ) NEW_LINE root . left . left = newNode ( 1 ) NEW_LINE root . left . right = newNode ( 1 ) NEW_LINE root . left . left = newNode ( 1 ) NEW_LINE print ( findMaxCount ( root ) ) NEW_LINE DEDENT"],"references":["class Node : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . data = 0 NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def newNode ( data ) : NEW_LINE INDENT newNode = Node ( ) NEW_LINE newNode . data = data NEW_LINE newNode . left = newNode . right = None NEW_LINE return ( newNode ) NEW_LINE DEDENT res = 0 NEW_LINE def countUntil ( root ) : NEW_LINE INDENT global res NEW_LINE if ( root == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT l = countUntil ( root . left ) NEW_LINE r = countUntil ( root . right ) NEW_LINE maxCount = 0 NEW_LINE if ( root . data == 1 ) : NEW_LINE INDENT maxCount = l + r + 1 NEW_LINE DEDENT else : NEW_LINE INDENT maxCount = l + r NEW_LINE DEDENT res = max ( res , maxCount ) NEW_LINE if ( root . data == 1 ) : NEW_LINE INDENT return max ( l , r ) + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return max ( l , r ) NEW_LINE DEDENT DEDENT def findMaxCount ( root ) : NEW_LINE INDENT global res NEW_LINE res = - 999999 NEW_LINE countUntil ( root ) NEW_LINE return res NEW_LINE DEDENT root = newNode ( 1 ) NEW_LINE root . left = newNode ( 0 ) NEW_LINE root . right = newNode ( 1 ) NEW_LINE root . left . left = newNode ( 1 ) NEW_LINE root . left . right = newNode ( 1 ) NEW_LINE root . left . right . left = newNode ( 1 ) NEW_LINE root . left . right . right = newNode ( 0 ) NEW_LINE print ( findMaxCount ( root ) ) NEW_LINE"],"bleu":0.789972310214316,"rouge_l":0.8975792416011813}
{"id":1098,"predictions":["import math NEW_LINE def countDigits ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE n = int ( math . pow ( 10 , count - 1 ) ) ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT def getDistinct ( d , count ) : NEW_LINE INDENT num = 0 ; NEW_LINE count = math . pow ( 10 , count - 1 ) ; NEW_LINE while ( count > 0 ) : NEW_LINE INDENT num += ( count * d ) ; NEW_LINE count \/\/= 10 ; NEW_LINE DEDENT return num ; NEW_LINE DEDENT def findCount ( L , R ) : NEW_LINE INDENT count = 0 ; NEW_LINE countDigitsL = countDigits ( L ) ; NEW_LINE countDigitsL = ( L \/\/ pow ( 10 , countDigitsL - 1 ) ) ; NEW_LINE firstDigitR = ( R \/\/ pow ( 10 , countDigitsR - 1 ) ) ; NEW_LINE if ( countDigitsL < countDigitsR ) : NEW_LINE INDENT count += ( 9 - firstDigitsL + 1 ) ; NEW_LINE if ( getDistinct ( firstDigitL , countDigitsL ) >= L ) : NEW_LINE INDENT count += ( 9 - firstDigitL + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT count += ( firstDigitR - firstDigitsL ) ; NEW_LINE DEDENT if ( getDistinct ( firstDigitR , countDigitsR ) >= R ) : NEW_LINE INDENT count += firstDigitR ; NEW_LINE DEDENT else : NEW_LINE INDENT count += ( 9 - firstDigitL ) ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT L = 10 ; R = 50 ; NEW_LINE print ( findCount ( L , R ) ) ; NEW_LINE DEDENT"],"references":["def countDigits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT count += 1 NEW_LINE n \/\/= 10 NEW_LINE DEDENT return count NEW_LINE DEDENT def getDistinct ( d , count ) : NEW_LINE INDENT num = 0 NEW_LINE count = pow ( 10 , count - 1 ) NEW_LINE while ( count > 0 ) : NEW_LINE INDENT num += ( count * d ) NEW_LINE count \/\/= 10 NEW_LINE DEDENT return num NEW_LINE DEDENT def findCount ( L , R ) : NEW_LINE INDENT count = 0 NEW_LINE countDigitsL = countDigits ( L ) NEW_LINE countDigitsR = countDigits ( R ) NEW_LINE firstDigitL = ( L \/\/ pow ( 10 , countDigitsL - 1 ) ) NEW_LINE firstDigitR = ( R \/\/ pow ( 10 , countDigitsR - 1 ) ) NEW_LINE if ( countDigitsL < countDigitsR ) : NEW_LINE INDENT count += ( 9 * ( countDigitsR - countDigitsL - 1 ) ) NEW_LINE if ( getDistinct ( firstDigitL , countDigitsL ) >= L ) : NEW_LINE INDENT count += ( 9 - firstDigitL + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT count += ( 9 - firstDigitL ) NEW_LINE DEDENT if ( getDistinct ( firstDigitR , countDigitsR ) <= R ) : NEW_LINE INDENT count += firstDigitR NEW_LINE DEDENT else : NEW_LINE INDENT count += ( firstDigitR - 1 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( getDistinct ( firstDigitL , countDigitsL ) >= L ) : NEW_LINE INDENT count += ( 9 - firstDigitL + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT count += ( 9 - firstDigitL ) NEW_LINE DEDENT if ( getDistinct ( firstDigitR , countDigitsR ) <= R ) : NEW_LINE INDENT count -= ( 9 - firstDigitR ) NEW_LINE DEDENT else : NEW_LINE INDENT count -= ( 9 - firstDigitR + 1 ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT L = 10 NEW_LINE R = 50 NEW_LINE print ( findCount ( L , R ) ) NEW_LINE"],"bleu":0.6018814764338316,"rouge_l":0.747821681864235}
{"id":1099,"predictions":["def isPalindrome ( n ) : NEW_LINE INDENT divisor = 1 NEW_LINE while ( int ( n \/ divisor ) >= 10 ) : NEW_LINE INDENT divisor *= 10 NEW_LINE DEDENT while ( n != 0 ) : NEW_LINE INDENT leading = int ( n \/ divisor ) NEW_LINE trailing = n % 10 NEW_LINE if ( leading != trailing ) : NEW_LINE INDENT return False NEW_LINE DEDENT n = int ( ( ( n % divisor ) \/ 10 ) NEW_LINE divisor = int ( divisor \/ 100 ) NEW_LINE DEDENT return True NEW_LINE DEDENT def largestPalindrome ( A , n ) : NEW_LINE INDENT A . sort ( ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( isPalindrome ( A [ i ] ) ) : NEW_LINE INDENT return A [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 1 , 232 , 545 , 999991 ] NEW_LINE n = len ( A ) NEW_LINE print ( largestPalindrome ( A , n ) ) NEW_LINE DEDENT"],"references":["def isPalindrome ( n ) : NEW_LINE INDENT divisor = 1 NEW_LINE while ( n \/ divisor >= 10 ) : NEW_LINE INDENT divisor *= 10 NEW_LINE DEDENT while ( n != 0 ) : NEW_LINE INDENT leading = n \/\/ divisor NEW_LINE trailing = n % 10 NEW_LINE if ( leading != trailing ) : NEW_LINE INDENT return False NEW_LINE DEDENT n = ( n % divisor ) \/\/ 10 NEW_LINE divisor = divisor \/\/ 100 NEW_LINE DEDENT return True NEW_LINE DEDENT def largestPalindrome ( A , n ) : NEW_LINE INDENT A . sort ( ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( isPalindrome ( A [ i ] ) ) : NEW_LINE INDENT return A [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 1 , 232 , 54545 , 999991 ] NEW_LINE n = len ( A ) NEW_LINE print ( largestPalindrome ( A , n ) ) NEW_LINE DEDENT"],"bleu":0.8187463674671533,"rouge_l":0.9407934195870107}
{"id":1100,"predictions":["def getPerfectSquares ( n ) : NEW_LINE INDENT perfectSquares = [ ] NEW_LINE current = 1 NEW_LINE i = 1 NEW_LINE while ( current <= n ) : NEW_LINE INDENT perfectSquares . append ( current ) NEW_LINE current = pow ( i , 2 ) NEW_LINE DEDENT return perfectSquares NEW_LINE DEDENT def maxPairSum ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE if ( arr [ 0 ] > arr [ 1 ] ) : NEW_LINE INDENT max = arr [ 0 ] NEW_LINE secondMax = arr [ 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT max = arr [ 1 ] NEW_LINE secondMax = arr [ 0 ] NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if ( arr [ i ] > max ) : NEW_LINE INDENT secondMax = max NEW_LINE max = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > secondMax ) : NEW_LINE INDENT secondMax = arr [ i ] NEW_LINE DEDENT DEDENT return ( max + secondMax ) NEW_LINE DEDENT def countPairsWith ( n , perfectSquares , nums ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( perfectSquares ) ) : NEW_LINE INDENT temp = perfectSquares [ i ] - n NEW_LINE if ( temp > n and nums [ temp ] in nums ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 3 , 6 , 9 , 10 , 20 ] NEW_LINE max = 0 NEW_LINE print ( countPairs ( arr ) ) NEW_LINE DEDENT"],"references":["def getPerfectSquares ( n ) : NEW_LINE INDENT perfectSquares = [ ] ; NEW_LINE current = 1 ; NEW_LINE i = 1 ; NEW_LINE while ( current <= n ) : NEW_LINE INDENT perfectSquares . append ( current ) ; NEW_LINE i += 1 ; NEW_LINE current = int ( pow ( i , 2 ) ) ; NEW_LINE DEDENT return perfectSquares ; NEW_LINE DEDENT def maxPairSum ( arr ) : NEW_LINE INDENT n = len ( arr ) ; NEW_LINE max = 0 ; NEW_LINE secondMax = 0 ; NEW_LINE if ( arr [ 0 ] > arr [ 1 ] ) : NEW_LINE INDENT max = arr [ 0 ] ; NEW_LINE secondMax = arr [ 1 ] ; NEW_LINE DEDENT else : NEW_LINE INDENT max = arr [ 1 ] ; NEW_LINE secondMax = arr [ 0 ] ; NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if ( arr [ i ] > max ) : NEW_LINE INDENT secondMax = max ; NEW_LINE max = arr [ i ] ; NEW_LINE DEDENT elif ( arr [ i ] > secondMax ) : NEW_LINE INDENT secondMax = arr [ i ] ; NEW_LINE DEDENT DEDENT return ( max + secondMax ) ; NEW_LINE DEDENT def countPairsWith ( n , perfectSquares , nums ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( len ( perfectSquares ) ) : NEW_LINE INDENT temp = perfectSquares [ i ] - n ; NEW_LINE if ( temp > n and ( temp in nums ) ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT def countPairs ( arr ) : NEW_LINE INDENT n = len ( arr ) ; NEW_LINE max = maxPairSum ( arr ) ; NEW_LINE perfectSquares = getPerfectSquares ( max ) ; NEW_LINE nums = [ ] ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT nums . append ( arr [ i ] ) ; NEW_LINE DEDENT count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT count += countPairsWith ( arr [ i ] , perfectSquares , nums ) ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT arr = [ 2 , 3 , 6 , 9 , 10 , 20 ] ; NEW_LINE print ( countPairs ( arr ) ) ; NEW_LINE"],"bleu":0.5395639866984243,"rouge_l":0.7560817685690501}
{"id":1101,"predictions":["if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT space = 4 NEW_LINE prt = ' $ ' $ ' NEW_LINE for i in range ( 1 , 5 ) : NEW_LINE INDENT for j in range ( space , 0 , - 1 ) : NEW_LINE INDENT print ( end = \" ▁ \" ) NEW_LINE DEDENT for j in range ( 1 , i - 1 ) : NEW_LINE INDENT print ( prt , end = \" \" ) NEW_LINE DEDENT for k in range ( 1 , ( i - 1 ) + 1 ) : NEW_LINE INDENT if ( i == 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT print ( prt , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE n = 1 NEW_LINE for i in range ( 4 , 0 , - 1 ) : NEW_LINE INDENT for sp in range ( space , 1 , - 1 ) : NEW_LINE INDENT print ( end = \" ▁ \" ) NEW_LINE DEDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( prt , end = \" ▁ \" ) NEW_LINE DEDENT for k in range ( 1 , i - 1 ) : NEW_LINE INDENT print ( prt , end = \" ▁ \" ) NEW_LINE DEDENT n = 1 NEW_LINE print ( ) NEW_LINE DEDENT space = 3 NEW_LINE for i in range ( 2 , 6 ) : NEW_LINE INDENT if ( i % 2 != 0 ) : NEW_LINE INDENT print ( end = \" ▁ \" , end = \" \" ) NEW_LINE DEDENT DEDENT space = 3 NEW_LINE print ( ) NEW_LINE DEDENT"],"references":["if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT space = 4 NEW_LINE prt = ' $ ' NEW_LINE for i in range ( 1 , 6 ) : NEW_LINE INDENT for sp in range ( space , 0 , - 1 ) : NEW_LINE INDENT print ( end = \" ▁ \" ) NEW_LINE DEDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( prt , end = \" \" ) NEW_LINE DEDENT for k in range ( 1 , i ) : NEW_LINE INDENT if ( i == 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT print ( prt , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE space -= 1 NEW_LINE DEDENT space = 1 NEW_LINE for i in range ( 4 , 0 , - 1 ) : NEW_LINE INDENT for sp in range ( space , 0 , - 1 ) : NEW_LINE INDENT print ( end = \" ▁ \" ) NEW_LINE DEDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( prt , end = \" \" ) NEW_LINE DEDENT for k in range ( 1 , i ) : NEW_LINE INDENT print ( prt , end = \" \" ) NEW_LINE DEDENT space += 1 NEW_LINE print ( ) NEW_LINE DEDENT space = 3 NEW_LINE for i in range ( 2 , 6 ) : NEW_LINE INDENT if ( ( i % 2 ) != 0 ) : NEW_LINE INDENT for sp in range ( space , 0 , - 1 ) : NEW_LINE INDENT print ( \" ▁ \" , end = \" \" ) NEW_LINE DEDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( prt , end = \" \" ) NEW_LINE DEDENT DEDENT if ( ( i % 2 ) != 0 ) : NEW_LINE INDENT print ( ) NEW_LINE space -= 1 NEW_LINE DEDENT DEDENT DEDENT"],"bleu":0.7374952168650704,"rouge_l":0.8382497287802863}
{"id":1102,"predictions":["def maxLen ( arr , n ) : NEW_LINE INDENT min_val = min ( arr ) ; NEW_LINE freq = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == min_val ) : NEW_LINE INDENT freq += 1 ; NEW_LINE DEDENT DEDENT return freq ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 3 , 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( maxLen ( arr , n ) ) ; NEW_LINE DEDENT"],"references":["def maxLen ( arr , n ) : NEW_LINE INDENT min_val = min ( arr ) ; NEW_LINE freq = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == min_val ) : NEW_LINE INDENT freq += 1 ; NEW_LINE DEDENT DEDENT return freq ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 3 , 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( maxLen ( arr , n ) ) ; NEW_LINE DEDENT"],"bleu":1.0,"rouge_l":1.0}
{"id":1103,"predictions":["def printKDistinct ( arr , n , k ) : NEW_LINE INDENT Hash = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( Hash [ i ] in Hash . keys ( ) ) : NEW_LINE INDENT dist_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT Hash [ arr [ i ] ] = 1 ; NEW_LINE DEDENT DEDENT if ( len ( Hash ) < k ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT dist_count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( Hash [ arr [ i ] ] == 1 ) : NEW_LINE INDENT dist_count += 1 NEW_LINE DEDENT if ( dist_count == k ) : NEW_LINE INDENT return arr [ i ] ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 1 , 3 , 4 , 2 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( printKDistinct ( arr , n , 2 ) ) ; NEW_LINE DEDENT"],"references":["def printKDistinct ( arr , size , KthIndex ) : NEW_LINE INDENT dict = { } NEW_LINE vect = [ ] NEW_LINE for i in range ( size ) : NEW_LINE INDENT if ( arr [ i ] in dict ) : NEW_LINE INDENT dict [ arr [ i ] ] = dict [ arr [ i ] ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dict [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT for i in range ( size ) : NEW_LINE INDENT if ( dict [ arr [ i ] ] > 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT KthIndex = KthIndex - 1 NEW_LINE DEDENT if ( KthIndex == 0 ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 1 , 2 , 1 , 3 , 4 , 2 ] NEW_LINE size = len ( arr ) NEW_LINE print ( printKDistinct ( arr , size , 2 ) ) NEW_LINE"],"bleu":0.49069083480616715,"rouge_l":0.6963595505617977}
{"id":1104,"predictions":["def checkSubarraySum ( arr , n , k , sum ) : NEW_LINE INDENT curr_sum = 0 ; NEW_LINE for i in range ( k ) : NEW_LINE INDENT curr_sum += arr [ i ] ; NEW_LINE DEDENT if ( curr_sum == sum ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT for j in range ( k , n ) : NEW_LINE INDENT curr_sum = curr_sum + arr [ j ] - arr [ j - k ] ; NEW_LINE if ( curr_sum == sum ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT return False ; NEW_LINE DEDENT arr = [ 1 , 4 , 2 , 10 , 2 , 3 , 1 , 0 , 20 ] ; NEW_LINE k = 4 ; NEW_LINE sum = 18 ; n = len ( arr ) ; NEW_LINE if ( checkSubarraySum ( arr , n , k , sum ) ) : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE DEDENT"],"references":["def checkSubarraySum ( arr , n , k , sumV ) : NEW_LINE INDENT curr_sum = 0 NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT curr_sum += arr [ i ] NEW_LINE DEDENT if ( curr_sum == sumV ) : NEW_LINE INDENT return true NEW_LINE DEDENT for j in range ( k , n ) : NEW_LINE INDENT curr_sum = ( curr_sum + arr [ j ] - arr [ j - k ] ) NEW_LINE if ( curr_sum == sumV ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT arr = [ 1 , 4 , 2 , 10 , 2 , 3 , 1 , 0 , 20 ] NEW_LINE k = 4 NEW_LINE sumV = 18 NEW_LINE n = len ( arr ) NEW_LINE if ( checkSubarraySum ( arr , n , k , sumV ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"],"bleu":0.737265450685867,"rouge_l":0.9206899784381737}
{"id":1105,"predictions":["def printCombination ( n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( i % 3 != 0 ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if ( k % 3 != 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( k % 3 != 0 and ( i + j + k ) == n ) : NEW_LINE INDENT print ( i , j , \" ▁ \" , k , sep = \" \" ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT n = 232 NEW_LINE printCombination ( n ) NEW_LINE"],"references":["def printCombination ( n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( i % 3 != 0 ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if ( j % 3 != 0 ) : NEW_LINE INDENT for k in range ( 1 , n ) : NEW_LINE INDENT if ( k % 3 != 0 and ( i + j + k ) == n ) : NEW_LINE INDENT print ( i , j , k ) ; NEW_LINE return ; NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT n = 233 ; NEW_LINE printCombination ( n ) ; NEW_LINE"],"bleu":0.7573439565419314,"rouge_l":0.8568388195232691}
{"id":1106,"predictions":["import math NEW_LINE def countNumbersWith4 ( n ) : NEW_LINE INDENT if ( n < 4 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT d = math . log10 ( n ) NEW_LINE a = [ 0 ] * ( d + 2 ) NEW_LINE a [ 0 ] = 0 NEW_LINE a [ 1 ] = 1 NEW_LINE for i in range ( 2 , d + 1 ) : NEW_LINE INDENT a [ i ] = a [ i - 1 ] * 9 + math . ceil ( pow ( 10 , i - 1 ) ) ) NEW_LINE DEDENT p = int ( math . ceil ( math . pow ( 10 , d ) ) NEW_LINE msd = n \/\/ p NEW_LINE if ( msd == 4 ) : NEW_LINE INDENT return ( msd ) * a [ d ] + ( n % p ) + 1 NEW_LINE DEDENT if ( msd > 4 ) : NEW_LINE INDENT return ( msd - 1 ) * a [ d ] + countNumbersWith4 ( n % p ) NEW_LINE DEDENT return ( msd ) * a [ d ] + countNumbersWith4 ( n % p ) NEW_LINE DEDENT n = 328 NEW_LINE print ( \" Count ▁ of ▁ numbers ▁ from ▁ 1 ▁ to ▁ \" , n , \" ▁ that ▁ have ▁ 4 ▁ as ▁ a ▁ digit ▁ is ▁ \" , countNumbersWith4 ( n ) ) NEW_LINE"],"references":["import math as mt NEW_LINE def countNumbersWith4 ( n ) : NEW_LINE INDENT if ( n < 4 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT d = int ( mt . log10 ( n ) ) NEW_LINE a = [ 1 for i in range ( d + 1 ) ] NEW_LINE a [ 0 ] = 0 NEW_LINE if len ( a ) > 1 : NEW_LINE INDENT a [ 1 ] = 1 NEW_LINE DEDENT for i in range ( 2 , d + 1 ) : NEW_LINE INDENT a [ i ] = a [ i - 1 ] * 9 + mt . ceil ( pow ( 10 , i - 1 ) ) NEW_LINE DEDENT p = mt . ceil ( pow ( 10 , d ) ) NEW_LINE msd = n \/\/ p NEW_LINE if ( msd == 4 ) : NEW_LINE INDENT return ( msd ) * a [ d ] + ( n % p ) + 1 NEW_LINE DEDENT if ( msd > 4 ) : NEW_LINE INDENT return ( ( msd - 1 ) * a [ d ] + p + countNumbersWith4 ( n % p ) ) NEW_LINE DEDENT return ( msd ) * a [ d ] + countNumbersWith4 ( n % p ) NEW_LINE DEDENT n = 328 NEW_LINE print ( \" Count ▁ of ▁ numbers ▁ from ▁ 1 ▁ to \" , n , \" that ▁ have ▁ 4 ▁ as ▁ a ▁ digit ▁ is \" , countNumbersWith4 ( n ) ) NEW_LINE"],"bleu":0.8064473721292404,"rouge_l":0.9074957085637995}
{"id":1107,"predictions":["import math NEW_LINE arr = [ ] NEW_LINE def generateDivisors ( n ) : NEW_LINE INDENT for i in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n \/ i == i ) : NEW_LINE INDENT arr . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT arr . append ( i ) NEW_LINE arr . append ( n \/ i ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def harmonicMean ( n ) : NEW_LINE INDENT generateDivisors ( n ) NEW_LINE sum = 0.0 NEW_LINE length = len ( arr ) NEW_LINE for i in range ( length ) : NEW_LINE INDENT sum = sum + n \/ arr [ i ] NEW_LINE DEDENT sum = sum \/ n NEW_LINE return len ( arr ) \/ sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 28 NEW_LINE if ( isOreNumber ( n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"references":["arr = [ ] NEW_LINE def generateDivisors ( n ) : NEW_LINE INDENT for i in range ( 1 , int ( n ** ( 0.5 ) ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT if n \/\/ i == i : NEW_LINE INDENT arr . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT arr . append ( i ) NEW_LINE arr . append ( n \/\/ i ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def harmonicMean ( n ) : NEW_LINE INDENT generateDivisors ( n ) NEW_LINE Sum = 0 NEW_LINE length = len ( arr ) NEW_LINE for i in range ( 0 , length ) : NEW_LINE INDENT Sum = Sum + ( n \/ arr [ i ] ) NEW_LINE DEDENT Sum = Sum \/ n NEW_LINE return length \/ Sum NEW_LINE DEDENT def isOreNumber ( n ) : NEW_LINE INDENT mean = harmonicMean ( n ) NEW_LINE if mean - int ( mean ) == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 28 NEW_LINE if isOreNumber ( n ) == True : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.6395140564961554,"rouge_l":0.7982749646813889}
{"id":1108,"predictions":["import math NEW_LINE def powOfPositive ( n ) : NEW_LINE INDENT pos = int ( math . floor ( math . log ( n , 2 ) ) ) NEW_LINE return pow ( 2 , pos ) NEW_LINE DEDENT def powOfNegative ( n ) : NEW_LINE INDENT pos = math . ceil ( ( math . log2 ( n ) ) ) NEW_LINE return - 1 * pow ( 2 , pos ) NEW_LINE DEDENT def highestPowerOf2 ( n ) : NEW_LINE INDENT if ( n ) : NEW_LINE INDENT print ( powOfPositive ( n ) ) NEW_LINE DEDENT else : NEW_LINE INDENT n = - n NEW_LINE print ( pow ( 2 , pos ) ) NEW_LINE DEDENT DEDENT def highestPowerOf2 ( n ) : NEW_LINE INDENT if ( n ) : NEW_LINE INDENT print ( powOfPositive ( n ) ) NEW_LINE DEDENT else : NEW_LINE INDENT n = - n NEW_LINE print ( powOfNegative ( n ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = - 24 NEW_LINE highestPowerOf2 ( n ) NEW_LINE DEDENT"],"references":["from math import floor , ceil , log2 NEW_LINE def powOfPositive ( n ) : NEW_LINE INDENT pos = floor ( log2 ( n ) ) ; NEW_LINE return 2 ** pos ; NEW_LINE DEDENT def powOfNegative ( n ) : NEW_LINE INDENT pos = ceil ( log2 ( n ) ) ; NEW_LINE return ( - 1 * pow ( 2 , pos ) ) ; NEW_LINE DEDENT def highestPowerOf2 ( n ) : NEW_LINE INDENT if ( n > 0 ) : NEW_LINE INDENT print ( powOfPositive ( n ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT n = - n ; NEW_LINE print ( powOfNegative ( n ) ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = - 24 ; NEW_LINE highestPowerOf2 ( n ) ; NEW_LINE DEDENT"],"bleu":0.49172490707142924,"rouge_l":0.7451898605314058}
{"id":1109,"predictions":["from math import sqrt NEW_LINE prime = [ True for i in range ( 1000000 + 5 ) ] NEW_LINE def findPrime ( ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= 1000000 : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , 1000000 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT def lenOfLongSubarr ( arr , n ) : NEW_LINE INDENT um = dict ( ) NEW_LINE Sum = 0 NEW_LINE maxLen = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ arr [ i ] ] == False ) : NEW_LINE INDENT Sum += 1 NEW_LINE DEDENT else : NEW_LINE INDENT Sum += 1 NEW_LINE DEDENT if ( Sum == 1 ) : NEW_LINE INDENT maxLen = i + 1 NEW_LINE DEDENT elif ( Sum - 1 ) in um . keys ( ) : NEW_LINE INDENT if ( maxLen < ( i - um [ Sum - 1 ] ) ) : NEW_LINE INDENT maxLen = i - um [ Sum - 1 ] NEW_LINE DEDENT DEDENT DEDENT return maxLen NEW_LINE DEDENT if __name__ == ' _ main _ _ ' : NEW_LINE INDENT findPrime ( ) NEW_LINE arr = [ 1 , 9 , 3 , 4 , 5 , 6 , 7 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( lenOfLongSubarr ( arr , n ) ) NEW_LINE DEDENT"],"references":["prime = [ True ] * ( 1000000 + 5 ) NEW_LINE def findPrime ( ) : NEW_LINE INDENT prime [ 0 ] , prime [ 1 ] = False , False NEW_LINE for p in range ( 2 , 1001 ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , 1000001 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def lenOfLongSubarr ( arr , n ) : NEW_LINE INDENT um = { } NEW_LINE Sum , maxLen = 0 , 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT Sum = Sum - 1 if prime [ arr [ i ] ] == False else Sum + 1 NEW_LINE if Sum == 1 : NEW_LINE INDENT maxLen = i + 1 NEW_LINE DEDENT elif Sum not in um : NEW_LINE INDENT um [ Sum ] = i NEW_LINE DEDENT if ( Sum - 1 ) in um : NEW_LINE INDENT if maxLen < ( i - um [ Sum - 1 ] ) : NEW_LINE INDENT maxLen = i - um [ Sum - 1 ] NEW_LINE DEDENT DEDENT DEDENT return maxLen NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT findPrime ( ) NEW_LINE arr = [ 1 , 9 , 3 , 4 , 5 , 6 , 7 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( lenOfLongSubarr ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.6918108551764708,"rouge_l":0.8040942777305309}
{"id":1110,"predictions":["def turnOnK ( n , k ) : NEW_LINE INDENT if ( k <= 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return ( n & ~ ( 1 << ( k - 1 ) ) ) NEW_LINE DEDENT n = 15 NEW_LINE k = 4 NEW_LINE print ( turnOnK ( n , k ) ) NEW_LINE"],"references":["def turnOffK ( n , k ) : NEW_LINE INDENT if ( k <= 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return ( n & ~ ( 1 << ( k - 1 ) ) ) NEW_LINE DEDENT n = 15 NEW_LINE k = 4 NEW_LINE print ( turnOffK ( n , k ) ) NEW_LINE"],"bleu":0.9251768748886328,"rouge_l":0.9655172413793103}
{"id":1111,"predictions":["import sys NEW_LINE def longestSubarray ( a , n ) : NEW_LINE INDENT hash = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT num = a [ i ] NEW_LINE while ( num ) : NEW_LINE INDENT hash [ i ] [ num % 10 ] = 1 NEW_LINE num \/\/= 10 NEW_LINE DEDENT DEDENT longest = - sys . maxsize NEW_LINE count = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT if ( hash [ i ] [ j ] == 1 and hash [ i + 1 ] [ j ] == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( j == 10 ) : NEW_LINE INDENT longest = max ( longest , count + 1 ) NEW_LINE count = 0 NEW_LINE DEDENT DEDENT longest = max ( longest , count + 1 ) NEW_LINE return longest NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 11 , 22 , 33 , 44 , 54 , 56 , 63 ] NEW_LINE n = len ( a ) NEW_LINE print ( longestSubarray ( a , n ) ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE def longestSubarray ( a , n ) : NEW_LINE INDENT hash = [ [ 0 for i in range ( 10 ) ] for j in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT num = a [ i ] NEW_LINE while ( num ) : NEW_LINE INDENT hash [ i ] [ num % 10 ] = 1 NEW_LINE num = int ( num \/ 10 ) NEW_LINE DEDENT DEDENT longest = - sys . maxsize - 1 NEW_LINE count = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT if ( hash [ i ] [ j ] and hash [ i + 1 ] [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( j == 10 ) : NEW_LINE INDENT longest = max ( longest , count + 1 ) NEW_LINE count = 0 NEW_LINE DEDENT DEDENT longest = max ( longest , count + 1 ) NEW_LINE return longest NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 11 , 22 , 33 , 44 , 54 , 56 , 63 ] NEW_LINE n = len ( a ) NEW_LINE print ( longestSubarray ( a , n ) ) NEW_LINE DEDENT"],"bleu":0.8748880833744821,"rouge_l":0.9395836263890842}
{"id":1112,"predictions":["def find_Solution ( x , n ) : NEW_LINE INDENT sum = x ; e = 2 ; o = 1 ; p = 1 ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT p += 2 ; NEW_LINE sum += ( o \/ e ) * ( pow ( x , p ) \/ p ) ; NEW_LINE o = o * ( e + 2 ) ; NEW_LINE e = e * ( e + 2 ) ; NEW_LINE DEDENT print ( sum ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = - 0.5 ; NEW_LINE if __name__ == \" : NEW_LINE INDENT print ( \" Invalid ▁ Input \" ) ; NEW_LINE DEDENT n = 8 ; NEW_LINE find_Solution ( x , n ) ; NEW_LINE DEDENT"],"references":["def find_Solution ( x , n ) : NEW_LINE INDENT Sum = x NEW_LINE e = 2 NEW_LINE o = 1 NEW_LINE p = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT p += 2 NEW_LINE Sum += ( o \/ e ) * ( pow ( x , p ) \/ p ) NEW_LINE o = o * ( o + 2 ) NEW_LINE e = e * ( e + 2 ) NEW_LINE DEDENT print ( round ( Sum , 10 ) ) NEW_LINE DEDENT x = - 0.5 NEW_LINE if ( abs ( x ) >= 1 ) : NEW_LINE INDENT print ( \" Invalid ▁ Input \\n \" ) NEW_LINE DEDENT n = 8 NEW_LINE find_Solution ( x , n ) NEW_LINE"],"bleu":0.5709104530751747,"rouge_l":0.8110365925402989}
{"id":1113,"predictions":["def replaceOriginal ( s , n ) : NEW_LINE INDENT r = \" \" NEW_LINE for i in range ( n ) : NEW_LINE INDENT r = s [ n - 1 - i ] NEW_LINE if ( s [ i ] != ' a ' and s [ i ] != ' e ' and s [ i ] != ' i ' and s [ i ] != ' o ' and s [ i ] != ' o ' and s [ i ] != ' u ' ) : NEW_LINE INDENT print ( r [ i ] , end = \" \" ) NEW_LINE DEDENT DEDENT print ( \" \" ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" geeksforgeeks \" NEW_LINE n = len ( s ) NEW_LINE replaceOriginal ( s , n ) NEW_LINE DEDENT"],"references":["def replaceOriginal ( s , n ) : NEW_LINE INDENT r = [ ' ▁ ' ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT r [ i ] = s [ n - 1 - i ] NEW_LINE if ( s [ i ] != ' a ' and s [ i ] != ' e ' and s [ i ] != ' i ' and s [ i ] != ' o ' and s [ i ] != ' u ' ) : NEW_LINE INDENT print ( r [ i ] , end = \" \" ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" geeksforgeeks \" NEW_LINE n = len ( s ) NEW_LINE replaceOriginal ( s , n ) NEW_LINE DEDENT"],"bleu":0.8649846373815308,"rouge_l":0.9113479072833132}
{"id":1114,"predictions":["def SieveOfEratosthenes ( prime , p_size ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , p_size + 1 ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT for i in range ( p * 2 , p_size + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def xorOfPrime ( s ) : NEW_LINE INDENT prime = [ True ] * 100005 NEW_LINE SieveOfEratosthenes ( prime , 10005 ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT m [ s [ i ] ] = m . get ( s [ i ] , 0 ) + 1 NEW_LINE DEDENT result = 0 NEW_LINE flag = 0 NEW_LINE for it in m . items ( ) : NEW_LINE INDENT if prime [ m [ it ] ] : NEW_LINE INDENT result ^= m [ it ] NEW_LINE flag = 1 NEW_LINE DEDENT DEDENT if flag : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" gghgeeksforgeeks \" NEW_LINE print ( xorOfPrime ( s ) ) NEW_LINE DEDENT"],"references":["from collections import defaultdict NEW_LINE def SieveOfEratosthenes ( prime , p_size ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= p_size : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT for i in range ( p * 2 , p_size + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT def xorOfPrime ( s ) : NEW_LINE INDENT prime = [ True ] * 100005 NEW_LINE SieveOfEratosthenes ( prime , 10005 ) NEW_LINE m = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT m [ s [ i ] ] += 1 NEW_LINE DEDENT result = flag = 0 NEW_LINE for it in m : NEW_LINE INDENT if prime [ m [ it ] ] : NEW_LINE INDENT result ^= m [ it ] NEW_LINE flag = 1 NEW_LINE DEDENT DEDENT if not flag : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" gggggeeekkkks \" NEW_LINE print ( xorOfPrime ( s ) ) NEW_LINE DEDENT"],"bleu":0.7859709530604678,"rouge_l":0.8681681461374807}
{"id":1115,"predictions":["def findNumbers ( n , d ) : NEW_LINE INDENT for i in range ( n - 2 ) : NEW_LINE INDENT print ( \"1\" , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( \"2\" , end = \" ▁ \" ) ; NEW_LINE print ( n + d ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 3 ; D = 5 ; NEW_LINE findNumbers ( N , D ) ; NEW_LINE DEDENT"],"references":["def pattern ( n , d ) : NEW_LINE INDENT for i in range ( 0 , n - 2 ) : NEW_LINE INDENT print ( \"1\" , end = \" ▁ \" ) NEW_LINE DEDENT print ( \"2\" , end = \" ▁ \" ) NEW_LINE print ( n + d ) NEW_LINE DEDENT N = 3 NEW_LINE D = 5 NEW_LINE pattern ( N , D ) NEW_LINE"],"bleu":0.5931561121561824,"rouge_l":0.8445154419595314}
{"id":1116,"predictions":["PI = 3.142 ; NEW_LINE def cosine ( x ) : NEW_LINE INDENT x = 60.0 ; NEW_LINE val = PI \/ 180.0 ; NEW_LINE ret = math . cos ( x * val ) ; NEW_LINE print ( ret , \" The ▁ cosine ▁ of \" , x , \" is \" , ret ) ; NEW_LINE print ( \" ▁ degrees \" ) ; NEW_LINE print ( \" ▁ degrees \" ) ; NEW_LINE print ( \" ▁ degrees \" ) ; NEW_LINE print ( \" ▁ degrees \" ) ; NEW_LINE x = 90.0 ; NEW_LINE val = math . pi \/ 180.0 ; NEW_LINE ret = math . cos ( x * val ) ; NEW_LINE print ( \" The ▁ cosine ▁ of \" , x , \" is \" , end = \" ▁ \" ) ; NEW_LINE print ( ret ) ; NEW_LINE"],"references":["import math NEW_LINE if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT PI = 3.14159265 NEW_LINE x = 60.0 NEW_LINE val = PI \/ 180.0 NEW_LINE ret = math . cos ( x * val ) NEW_LINE print ( \" The ▁ cosine ▁ of ▁ is ▁ \" , x , end = \" ▁ \" ) NEW_LINE print ( \" ▁ degrees \" , ret ) NEW_LINE x = 90.0 NEW_LINE val = PI \/ 180.0 NEW_LINE ret = math . cos ( x * val ) NEW_LINE print ( \" The ▁ cosine ▁ of ▁ is ▁ \" , x , end = \" ▁ \" ) NEW_LINE print ( \" degrees \" , ret ) NEW_LINE DEDENT"],"bleu":0.4585278180998626,"rouge_l":0.6899290097461196}
{"id":1117,"predictions":["N = 100 ; NEW_LINE INF = 1000000 ; NEW_LINE dp = np . zeros ( ( N ) ) ; NEW_LINE def findSum ( arr , n , k , l , r ) : NEW_LINE INDENT if ( ( l ) + ( n - 1 - r ) == k ) : NEW_LINE INDENT return arr [ r ] - arr [ l ] ; NEW_LINE DEDENT if ( vis [ l ] [ r ] ) : NEW_LINE INDENT return dp [ l ] [ r ] ; NEW_LINE DEDENT vis [ l ] [ r ] = 1 ; NEW_LINE dp [ l ] [ r ] = min ( findSum ( arr , n , k , l , r - 1 ) , findSum ( arr , n , k , l + 1 , r ) ) ; NEW_LINE return dp [ l ] [ r ] ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 100 , 120 , 140 ] ; NEW_LINE k = 2 ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( findSum ( arr , n , k , 0 , n - 1 ) ) ; NEW_LINE DEDENT"],"references":["import numpy as np NEW_LINE N = 100 NEW_LINE INF = 1000000 NEW_LINE dp = np . zeros ( ( N , N ) ) ; NEW_LINE vis = np . zeros ( ( N , N ) ) ; NEW_LINE def findSum ( arr , n , k , l , r ) : NEW_LINE INDENT if ( ( l ) + ( n - 1 - r ) == k ) : NEW_LINE INDENT return arr [ r ] - arr [ l ] ; NEW_LINE DEDENT if ( vis [ l ] [ r ] ) : NEW_LINE INDENT return dp [ l ] [ r ] ; NEW_LINE DEDENT vis [ l ] [ r ] = 1 ; NEW_LINE dp [ l ] [ r ] = min ( findSum ( arr , n , k , l , r - 1 ) , findSum ( arr , n , k , l + 1 , r ) ) ; NEW_LINE return dp [ l ] [ r ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 100 , 120 , 140 ] ; NEW_LINE k = 2 ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( findSum ( arr , n , k , 0 , n - 1 ) ) ; NEW_LINE DEDENT"],"bleu":0.8881088898452708,"rouge_l":0.9406725208824159}
{"id":1118,"predictions":["def totalPairs ( s1 , s2 ) : NEW_LINE INDENT count = 0 NEW_LINE arr1 = [ 0 for i in range ( 7 ) ] NEW_LINE arr2 = [ 0 for i in range ( 7 ) ] NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT set_bits = bin ( s1 [ i ] ) . count ( '1' ) NEW_LINE arr1 [ set_bits ] += 1 NEW_LINE DEDENT for i in range ( len ( s2 ) ) : NEW_LINE INDENT set_bits = bin ( s2 [ i ] ) NEW_LINE arr2 [ set_bits ] += 1 NEW_LINE DEDENT for i in range ( 1 , 6 + 1 ) : NEW_LINE INDENT count += ( arr1 [ i ] * arr2 [ i ] ) NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s1 = \" geeks \" NEW_LINE s2 = \" forgeeks \" NEW_LINE print ( totalPairs ( s1 , s2 ) ) NEW_LINE DEDENT"],"references":["def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT count += n & 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def totalPairs ( s1 , s2 ) : NEW_LINE INDENT count = 0 ; NEW_LINE arr1 = [ 0 ] * 7 ; arr2 = [ 0 ] * 7 ; NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT set_bits = countSetBits ( ord ( s1 [ i ] ) ) NEW_LINE arr1 [ set_bits ] += 1 ; NEW_LINE DEDENT for i in range ( len ( s2 ) ) : NEW_LINE INDENT set_bits = countSetBits ( ord ( s2 [ i ] ) ) ; NEW_LINE arr2 [ set_bits ] += 1 ; NEW_LINE DEDENT for i in range ( 1 , 7 ) : NEW_LINE INDENT count += ( arr1 [ i ] * arr2 [ i ] ) ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s1 = \" geeks \" ; NEW_LINE s2 = \" forgeeks \" ; NEW_LINE print ( totalPairs ( s1 , s2 ) ) ; NEW_LINE DEDENT"],"bleu":0.5974092922366643,"rouge_l":0.767359946326736}
{"id":1119,"predictions":["def minOperations ( n ) : NEW_LINE INDENT count = 0 NEW_LINE d = 0 NEW_LINE if n == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT while n > 9 : NEW_LINE INDENT d = max ( n % 10 , d ) NEW_LINE n \/\/= 10 NEW_LINE count += 10 NEW_LINE DEDENT d = max ( d , n - 1 ) NEW_LINE count += abs ( d ) NEW_LINE return count - 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 240 NEW_LINE print ( minOperations ( n ) ) NEW_LINE DEDENT"],"references":["def minOperations ( n ) : NEW_LINE INDENT count = 0 NEW_LINE d = 0 NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( n > 9 ) : NEW_LINE INDENT d = max ( n % 10 , d ) NEW_LINE n \/\/= 10 NEW_LINE count += 10 NEW_LINE DEDENT d = max ( d , n - 1 ) NEW_LINE count += abs ( d ) NEW_LINE return count - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 240 NEW_LINE print ( minOperations ( n ) ) NEW_LINE DEDENT"],"bleu":0.8569578009818555,"rouge_l":0.9590012330456226}
{"id":1120,"predictions":["def myCopy ( s1 , s2 ) : NEW_LINE INDENT i = 0 NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT s2 [ i ] = s1 [ i ] NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s1 = \" GEEKSFORGEEKS \" NEW_LINE s2 = [ 0 for i in range ( len ( s1 ) ) ] NEW_LINE myCopy ( s1 , s2 ) NEW_LINE print ( \" \" . join ( s2 ) ) NEW_LINE DEDENT"],"references":["def myCopy ( s1 , s2 ) : NEW_LINE INDENT for i in range ( len ( s1 ) ) : NEW_LINE INDENT s2 [ i ] = s1 [ i ] ; NEW_LINE DEDENT DEDENT s1 = \" GEEKSFORGEEKS \" ; NEW_LINE s2 = [ ' ' ] * ( len ( s1 ) ) ; NEW_LINE myCopy ( s1 , s2 ) ; NEW_LINE print ( ( \" \" . join ( s2 ) ) ) ; NEW_LINE"],"bleu":0.607324943070496,"rouge_l":0.8086455331412103}
{"id":1121,"predictions":["def bitonicGenerator ( arr , n ) : NEW_LINE INDENT evenArr = [ ] NEW_LINE oddArr = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i % 2 != 1 ) : NEW_LINE INDENT evenArr . append ( arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT oddArr . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT evenArr . sort ( reverse = True ) NEW_LINE oddArr . sort ( reverse = True ) NEW_LINE i = 0 NEW_LINE for j in range ( len ( evenArr ) ) : NEW_LINE INDENT arr [ i ] = evenArr [ j ] NEW_LINE i += 1 NEW_LINE DEDENT for i in range ( len ( oddArr ) ) : NEW_LINE INDENT arr [ i ] = oddArr [ i ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT arr = [ 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 ] NEW_LINE n = len ( arr ) ; NEW_LINE bitonicGenerator ( arr , n ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT"],"references":["def bitonicGenerator ( arr , n ) : NEW_LINE INDENT evenArr = [ ] NEW_LINE oddArr = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( i % 2 ) == 0 ) : NEW_LINE INDENT evenArr . append ( arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT oddArr . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT evenArr = sorted ( evenArr ) NEW_LINE oddArr = sorted ( oddArr ) NEW_LINE oddArr = oddArr [ : : - 1 ] NEW_LINE i = 0 NEW_LINE for j in range ( len ( evenArr ) ) : NEW_LINE INDENT arr [ i ] = evenArr [ j ] NEW_LINE i += 1 NEW_LINE DEDENT for j in range ( len ( oddArr ) ) : NEW_LINE INDENT arr [ i ] = oddArr [ j ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT arr = [ 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE bitonicGenerator ( arr , n ) NEW_LINE for i in arr : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT"],"bleu":0.8167825989830667,"rouge_l":0.8915094339622641}
{"id":1122,"predictions":["def ReverseCharSwitch ( n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( ' A ' , ' A ' ) : NEW_LINE INDENT if ( j >= ( ' A ' + n - 1 ) + i ) : NEW_LINE INDENT print ( chr ( ord ( ' A ' ) + i ) - ( j % ( ord ( ' A ' ) + n - 1 ) ) , end = \" \" ) ; NEW_LINE DEDENT elif ( j <= ( ord ( ' A ' ) - i ) - 1 ) : NEW_LINE INDENT print ( chr ( j , end = \" \" ) , end = \" \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( ch , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT print ( ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 6 ; NEW_LINE ReverseCharQueue ( n ) ; NEW_LINE DEDENT"],"references":["def ReverseCharBridge ( n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( ord ( ' A ' ) , ord ( ' A ' ) + ( 2 * n ) - 1 ) : NEW_LINE INDENT if j >= ( ord ( ' A ' ) + n - 1 ) + i : NEW_LINE INDENT print ( chr ( ( ord ( ' A ' ) + n - 1 ) - ( j % ( ord ( ' A ' ) + n - 1 ) ) ) , end = ' ' ) NEW_LINE DEDENT elif j <= ( ord ( ' A ' ) + n - 1 ) - i : NEW_LINE INDENT print ( chr ( j ) , end = ' ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( end = \" ▁ \" ) NEW_LINE DEDENT DEDENT print ( \" \\n \" , end = ' ' ) NEW_LINE DEDENT DEDENT n = 6 NEW_LINE ReverseCharBridge ( n ) NEW_LINE"],"bleu":0.6136546477183521,"rouge_l":0.7802197802197802}
{"id":1123,"predictions":["n , m = 4 , 4 ; NEW_LINE def calcProbability ( M , k ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( n ) ] for y in range ( m ) ] ; NEW_LINE sum = [ 0 ] * n ; NEW_LINE for j in range ( n ) : NEW_LINE INDENT dp [ 0 ] [ j ] = M [ 0 ] [ j ] ; NEW_LINE sum [ 0 ] = sum [ 0 ] + dp [ 0 ] [ j ] ; NEW_LINE DEDENT for i in range ( 1 , m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i - 1 ] [ j ] \/ sum [ i - 1 ] + M [ i ] [ j ] ; NEW_LINE sum [ i ] += dp [ i ] [ j ] ; NEW_LINE DEDENT DEDENT return dp [ n - 1 ] [ k - 1 ] \/ sum [ n - 1 ] ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT M = [ [ 1 , 1 , 0 , 3 ] , [ 2 , 3 , 2 , 3 ] , [ 9 , 3 , 0 , 2 ] , [ 2 , 3 , 2 , 2 ] ] ; NEW_LINE k = 3 ; NEW_LINE print ( calcProbability ( M , k ) ) ; NEW_LINE DEDENT"],"references":["n = 4 NEW_LINE m = 4 NEW_LINE def calcProbability ( M , k ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( m ) ] NEW_LINE Sum = [ 0 for i in range ( n ) ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT dp [ 0 ] [ j ] = M [ 0 ] [ j ] NEW_LINE Sum [ 0 ] += dp [ 0 ] [ j ] NEW_LINE DEDENT for i in range ( 1 , m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT dp [ i ] [ j ] += ( dp [ i - 1 ] [ j ] \/ Sum [ i - 1 ] + M [ i ] [ j ] ) NEW_LINE Sum [ i ] += dp [ i ] [ j ] NEW_LINE DEDENT DEDENT return dp [ n - 1 ] [ k - 1 ] \/ Sum [ n - 1 ] NEW_LINE DEDENT M = [ [ 1 , 1 , 0 , 3 ] , [ 2 , 3 , 2 , 3 ] , [ 9 , 3 , 0 , 2 ] , [ 2 , 3 , 2 , 2 ] ] NEW_LINE k = 3 NEW_LINE print ( calcProbability ( M , k ) ) NEW_LINE"],"bleu":0.7295841178131705,"rouge_l":0.8838864092114627}
{"id":1124,"predictions":["def largestSubset ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE dp = [ 1 ] * n ; NEW_LINE dp [ n - 1 ] = 1 ; NEW_LINE for i in range ( n - 2 , - 1 ) : NEW_LINE INDENT mxm = 0 ; NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( a [ j ] % a [ i ] == 0 ) : NEW_LINE INDENT mx = max ( mxm , dp [ j ] ) ; NEW_LINE DEDENT DEDENT dp [ i ] = 1 + mxm ; NEW_LINE DEDENT return max ( dp ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 3 , 6 , 13 , 17 , 18 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( largestSubset ( a , n ) ) ; NEW_LINE DEDENT"],"references":["def largestSubset ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE dp = [ 0 for i in range ( n ) ] NEW_LINE dp [ n - 1 ] = 1 ; NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT mxm = 0 ; NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if a [ j ] % a [ i ] == 0 : NEW_LINE INDENT mxm = max ( mxm , dp [ j ] ) NEW_LINE DEDENT DEDENT dp [ i ] = 1 + mxm NEW_LINE DEDENT return max ( dp ) NEW_LINE DEDENT a = [ 1 , 3 , 6 , 13 , 17 , 18 ] NEW_LINE n = len ( a ) NEW_LINE print ( largestSubset ( a , n ) ) NEW_LINE"],"bleu":0.7462193063914823,"rouge_l":0.8873855544252289}
{"id":1125,"predictions":["def findLargest ( N ) : NEW_LINE INDENT largest = strings ( N , '7' ) NEW_LINE return largest ; NEW_LINE DEDENT def findSmallest ( N ) : NEW_LINE INDENT smallest = \"1\" + string ( N - 1 ) NEW_LINE return smallest ; NEW_LINE DEDENT def findSmallest ( N , c ) : NEW_LINE INDENT temp = \" \" ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT temp += c ; NEW_LINE DEDENT return temp ; NEW_LINE DEDENT def printLargest ( N ) : NEW_LINE INDENT print ( \" Largest : ▁ \" , findLargest ( N ) ) ; NEW_LINE print ( \" Smallest : ▁ \" , findSmallest ( N ) ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 4 ; NEW_LINE printLargestSmallestSmallest ( N ) ; NEW_LINE DEDENT"],"references":["def findLargest ( N ) : NEW_LINE INDENT largest = strings ( N , '7' ) ; NEW_LINE return largest ; NEW_LINE DEDENT def findSmallest ( N ) : NEW_LINE INDENT smallest = \"1\" + strings ( ( N - 1 ) , '0' ) ; NEW_LINE return smallest ; NEW_LINE DEDENT def strings ( N , c ) : NEW_LINE INDENT temp = \" \" ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT temp += c ; NEW_LINE DEDENT return temp ; NEW_LINE DEDENT def printLargestSmallest ( N ) : NEW_LINE INDENT print ( \" Largest : ▁ \" , findLargest ( N ) ) ; NEW_LINE print ( \" Smallest : ▁ \" , findSmallest ( N ) ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 ; NEW_LINE printLargestSmallest ( N ) ; NEW_LINE DEDENT"],"bleu":0.839486265652096,"rouge_l":0.9366220189480561}
{"id":1126,"predictions":["def findMaxNum ( arr , n ) : NEW_LINE INDENT hash = [ 0 for i in range ( 10 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( 9 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( hash [ i ] ) : NEW_LINE INDENT print ( i , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE findMaxNum ( arr , n ) NEW_LINE"],"references":["def findMaxNum ( arr , n ) : NEW_LINE INDENT hash = [ 0 ] * 10 NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( 9 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( hash [ i ] ) : NEW_LINE INDENT print ( i , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE findMaxNum ( arr , n ) NEW_LINE DEDENT"],"bleu":0.8406391655252274,"rouge_l":0.8985135135135136}
{"id":1127,"predictions":["import math NEW_LINE def countDigits ( n ) : NEW_LINE INDENT c = 0 NEW_LINE while True : NEW_LINE INDENT c += 1 NEW_LINE n = n \/\/ 10 NEW_LINE DEDENT return c NEW_LINE DEDENT def isdeserium ( x ) : NEW_LINE INDENT temp = x NEW_LINE p = countDigits ( x ) NEW_LINE sum = 0 NEW_LINE while ( x ) : NEW_LINE INDENT digit = x % 10 NEW_LINE sum += pow ( digit , p ) NEW_LINE p -= 1 NEW_LINE DEDENT return ( sum == temp ) NEW_LINE DEDENT x =135 NEW_LINE if ( isdeserium ( x ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def countDigits ( n ) : NEW_LINE INDENT c = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT c += 1 NEW_LINE n = int ( n \/ 10 ) NEW_LINE DEDENT return c NEW_LINE DEDENT def isDeserium ( x ) : NEW_LINE INDENT temp = x NEW_LINE p = countDigits ( x ) NEW_LINE sum = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT digit = int ( x % 10 ) NEW_LINE sum += pow ( digit , p ) NEW_LINE p -= 1 NEW_LINE x = int ( x \/ 10 ) NEW_LINE DEDENT return ( sum == temp ) NEW_LINE DEDENT x = 135 NEW_LINE if ( isDeserium ( x ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.7046331902359629,"rouge_l":0.8599761051373954}
{"id":1128,"predictions":["from math import * NEW_LINE def polyarea ( n , r ) : NEW_LINE INDENT if ( r < 0 and n < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT A = ( ( r * r * n ) * sin ( ( 360 \/ n ) * 3.14159 \/ 180 ) ) \/ 2 NEW_LINE return A NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT r = 9 NEW_LINE n = 6 NEW_LINE print ( ' { 0 : . 6 } ' . format ( polyarea ( n , r ) ) ) NEW_LINE DEDENT"],"references":["from math import sin NEW_LINE def polyarea ( n , r ) : NEW_LINE INDENT if ( r < 0 and n < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT A = ( ( ( r * r * n ) * sin ( ( 360 \/ n ) * 3.14159 \/ 180 ) ) \/ 2 ) ; NEW_LINE return round ( A , 3 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT r , n = 9 , 6 NEW_LINE print ( polyarea ( n , r ) ) NEW_LINE DEDENT"],"bleu":0.7228400727278316,"rouge_l":0.85195530726257}
{"id":1129,"predictions":["def smallestSumSubarr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = - arr [ i ] NEW_LINE DEDENT sum_here = arr [ 0 ] NEW_LINE max_sum = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT sum_here = max ( sum_here + arr [ i ] , arr [ i ] ) NEW_LINE max_sum = max ( max_sum , sum_here ) NEW_LINE DEDENT return ( - 1 ) * max_sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , - 4 , 2 , - 3 , - 1 , 7 , - 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Smallest ▁ sum : \" , smallestSumSubarr ( arr , n ) ) NEW_LINE DEDENT"],"references":["def smallestSumSubarr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = - arr [ i ] NEW_LINE DEDENT sum_here = arr [ 0 ] NEW_LINE max_sum = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT sum_here = max ( sum_here + arr [ i ] , arr [ i ] ) NEW_LINE max_sum = max ( max_sum , sum_here ) NEW_LINE DEDENT return ( - 1 ) * max_sum NEW_LINE DEDENT arr = [ 3 , - 4 , 2 , - 3 , - 1 , 7 , - 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Smallest ▁ sum : \" , smallestSumSubarr ( arr , n ) ) NEW_LINE"],"bleu":0.8989286097039945,"rouge_l":0.9606299212598426}
{"id":1130,"predictions":["def countSub ( arr , n , x ) : NEW_LINE INDENT st = 0 NEW_LINE end = 0 NEW_LINE sum = 0 NEW_LINE cnt = 0 NEW_LINE while ( end < n ) : NEW_LINE INDENT sum += arr [ end ] NEW_LINE while ( st <= end and sum > x ) : NEW_LINE INDENT sum -= arr [ st ] NEW_LINE st += 1 NEW_LINE DEDENT cnt += ( end - st + 1 ) NEW_LINE end += 1 NEW_LINE DEDENT return cnt NEW_LINE DEDENT def findSubSumLtoR ( arr , n , L , R ) : NEW_LINE INDENT Rcnt = countSub ( arr , n , R ) NEW_LINE Lcnt = countSub ( arr , n , L - 1 ) NEW_LINE return Rcnt - Lcnt NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 4 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE L = 3 NEW_LINE R = 8 NEW_LINE print ( findSubSumLtoR ( arr , n , L , R ) ) NEW_LINE DEDENT"],"references":["def countSub ( arr , n , x ) : NEW_LINE INDENT st = 0 NEW_LINE end = 0 NEW_LINE sum = 0 NEW_LINE cnt = 0 NEW_LINE while end < n : NEW_LINE INDENT sum += arr [ end ] NEW_LINE while ( st <= end and sum > x ) : NEW_LINE INDENT sum -= arr [ st ] NEW_LINE st += 1 NEW_LINE DEDENT cnt += ( end - st + 1 ) NEW_LINE end += 1 NEW_LINE DEDENT return cnt NEW_LINE DEDENT def findSubSumLtoR ( arr , n , L , R ) : NEW_LINE INDENT Rcnt = countSub ( arr , n , R ) NEW_LINE Lcnt = countSub ( arr , n , L - 1 ) NEW_LINE return Rcnt - Lcnt NEW_LINE DEDENT arr = [ 1 , 4 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE L = 3 NEW_LINE R = 8 NEW_LINE print ( findSubSumLtoR ( arr , n , L , R ) ) NEW_LINE"],"bleu":0.8885745727072695,"rouge_l":0.9626482397983005}
{"id":1131,"predictions":["M = 3 NEW_LINE def minCost ( cost , m , n ) : NEW_LINE INDENT tc = [ [ 0 for i in range ( n + 1 ) ] for j in range ( m + 1 ) ] NEW_LINE tc [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT tc [ i ] [ 0 ] = tc [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] NEW_LINE DEDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT tc [ 0 ] [ j ] = c [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT tc [ i ] [ j ] = min ( tc [ i - 1 ] [ j - 1 ] , tc [ i ] [ j ] ) + cost [ i ] [ j ] NEW_LINE DEDENT DEDENT return tc [ m ] [ n ] NEW_LINE DEDENT cost = [ [ 1 , 2 , 3 ] , [ 4 , 8 , 2 ] , [ 1 , 5 , 3 ] ] NEW_LINE print ( minCost ( cost , 2 , 2 ) ) NEW_LINE"],"references":["R = 3 NEW_LINE C = 3 NEW_LINE def minCost ( cost , m , n ) : NEW_LINE INDENT tc = [ [ 0 for x in range ( C ) ] for x in range ( R ) ] NEW_LINE tc [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT tc [ i ] [ 0 ] = tc [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] NEW_LINE DEDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT tc [ 0 ] [ j ] = tc [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT tc [ i ] [ j ] = min ( tc [ i - 1 ] [ j - 1 ] , tc [ i - 1 ] [ j ] , tc [ i ] [ j - 1 ] ) + cost [ i ] [ j ] NEW_LINE DEDENT DEDENT return tc [ m ] [ n ] NEW_LINE DEDENT cost = [ [ 1 , 2 , 3 ] , [ 4 , 8 , 2 ] , [ 1 , 5 , 3 ] ] NEW_LINE print ( minCost ( cost , 2 , 2 ) ) NEW_LINE"],"bleu":0.8904236650525224,"rouge_l":0.9358018606370526}
{"id":1132,"predictions":["def msbPos ( n ) : NEW_LINE INDENT msb_p = - 1 NEW_LINE while ( n ) : NEW_LINE INDENT n = n >> 1 NEW_LINE msb_p += 1 NEW_LINE DEDENT return msb_p NEW_LINE DEDENT def andOperator ( x , y ) : NEW_LINE INDENT res = 0 NEW_LINE while ( x > 0 and y > 0 ) : NEW_LINE INDENT msb_p1 = msbPos ( x ) NEW_LINE msb_p2 = msbPos ( y ) NEW_LINE if ( msb_p1 != msb_p2 ) : NEW_LINE INDENT break NEW_LINE DEDENT msb_val = ( 1 << msb_p1 ) NEW_LINE res = res + msb_val NEW_LINE x = x - msb_val NEW_LINE y = y - msb_val NEW_LINE DEDENT return res NEW_LINE DEDENT x = 10 NEW_LINE y = 15 NEW_LINE print ( andOperator ( x , y ) ) NEW_LINE"],"references":["def msbPos ( n ) : NEW_LINE INDENT msb_p = - 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n = n >> 1 NEW_LINE msb_p += 1 NEW_LINE DEDENT return msb_p NEW_LINE DEDENT def andOperator ( x , y ) : NEW_LINE INDENT res = 0 NEW_LINE while ( x > 0 and y > 0 ) : NEW_LINE INDENT msb_p1 = msbPos ( x ) NEW_LINE msb_p2 = msbPos ( y ) NEW_LINE if ( msb_p1 != msb_p2 ) : NEW_LINE INDENT break NEW_LINE DEDENT msb_val = ( 1 << msb_p1 ) NEW_LINE res = res + msb_val NEW_LINE x = x - msb_val NEW_LINE y = y - msb_val NEW_LINE DEDENT return res NEW_LINE DEDENT x , y = 10 , 15 NEW_LINE print ( andOperator ( x , y ) ) NEW_LINE"],"bleu":0.9362167640063754,"rouge_l":0.9697473009846957}
{"id":1133,"predictions":["count_black = [ 0 ] * 2 NEW_LINE def dfs ( node , node , parent , color ) : NEW_LINE INDENT count_black [ node ] += 1 NEW_LINE for i in range ( len ( graph [ node ] ) ) : NEW_LINE INDENT if ( adj [ node ] [ i ] != parent ) : NEW_LINE INDENT dfs ( adj , adj [ node ] [ node ] , node , not color ) NEW_LINE DEDENT DEDENT def dfs ( adj , n ) : NEW_LINE INDENT dfs ( adj , 1 , 0 , False ) NEW_LINE return ( count_black [ 0 ] * count_white [ 1 ] - ( n - 1 ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 NEW_LINE adj = [ [ ] for i in range ( n + 1 ) ] NEW_LINE adj [ 1 ] . append ( 2 ) NEW_LINE adj [ 2 ] . append ( 3 ) NEW_LINE adj [ 1 ] . append ( 4 ) NEW_LINE adj [ 2 ] . append ( 5 ) NEW_LINE print ( findMaxEdges ( adj , n ) ) NEW_LINE DEDENT"],"references":["def dfs ( adj , node , parent , color ) : NEW_LINE INDENT count_color [ color ] += 1 NEW_LINE for i in range ( len ( adj [ node ] ) ) : NEW_LINE INDENT if ( adj [ node ] [ i ] != parent ) : NEW_LINE INDENT dfs ( adj , adj [ node ] [ i ] , node , not color ) NEW_LINE DEDENT DEDENT DEDENT def findMaxEdges ( adj , n ) : NEW_LINE INDENT dfs ( adj , 1 , 0 , 0 ) NEW_LINE return ( count_color [ 0 ] * count_color [ 1 ] - ( n - 1 ) ) NEW_LINE DEDENT count_color = [ 0 , 0 ] NEW_LINE n = 5 NEW_LINE adj = [ [ ] for i in range ( n + 1 ) ] NEW_LINE adj [ 1 ] . append ( 2 ) NEW_LINE adj [ 1 ] . append ( 3 ) NEW_LINE adj [ 2 ] . append ( 4 ) NEW_LINE adj [ 3 ] . append ( 5 ) NEW_LINE print ( findMaxEdges ( adj , n ) ) NEW_LINE"],"bleu":0.7780005903004076,"rouge_l":0.8716457589100275}
{"id":1134,"predictions":["def steps ( string , n ) : NEW_LINE INDENT flag = False NEW_LINE x = 0 NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT flag = True NEW_LINE DEDENT if ( x == n - 1 ) : NEW_LINE INDENT flag = False NEW_LINE DEDENT for j in range ( x ) : NEW_LINE INDENT print ( \" * \" , end = \" \" ) NEW_LINE DEDENT print ( string [ i ] ) NEW_LINE if ( flag == 1 ) : NEW_LINE INDENT x += 1 NEW_LINE DEDENT else : NEW_LINE INDENT x -= 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" GeeksForGeeks \" NEW_LINE print ( \" String : \" , string ) NEW_LINE print ( \" Max ▁ length ▁ of ▁ Steps : \" , n ) NEW_LINE steps ( string , n ) NEW_LINE DEDENT"],"references":["import math as mt NEW_LINE def steps ( string , n ) : NEW_LINE INDENT flag = False NEW_LINE x = 0 NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT flag = True NEW_LINE DEDENT if ( x == n - 1 ) : NEW_LINE INDENT flag = False NEW_LINE DEDENT for j in range ( x ) : NEW_LINE INDENT print ( \" * \" , end = \" \" ) NEW_LINE DEDENT print ( string [ i ] ) NEW_LINE if ( flag == True ) : NEW_LINE INDENT x += 1 NEW_LINE DEDENT else : NEW_LINE INDENT x -= 1 NEW_LINE DEDENT DEDENT DEDENT n = 4 NEW_LINE string = \" GeeksForGeeks \" NEW_LINE print ( \" String : ▁ \" , string ) NEW_LINE print ( \" Max ▁ Length ▁ of ▁ Steps : ▁ \" , n ) NEW_LINE steps ( string , n ) NEW_LINE"],"bleu":0.8618498558406725,"rouge_l":0.9213603586045606}
{"id":1135,"predictions":["def max_xor ( arr , n ) : NEW_LINE INDENT maxx = 0 NEW_LINE mask = 0 NEW_LINE se = set ( ) NEW_LINE for i in range ( 30 , - 1 , - 1 ) : NEW_LINE INDENT mask |= ( 1 << i ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT se . add ( arr [ j ] & mask ) NEW_LINE DEDENT newMaxx = maxx | ( 1 << i ) NEW_LINE for prefix in se : NEW_LINE INDENT if ( newMaxx ^ prefix ) in se : NEW_LINE INDENT maxx = newMaxx NEW_LINE break NEW_LINE DEDENT DEDENT se . clear ( ) NEW_LINE DEDENT return maxx NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 25 , 10 , 2 , 8 , 5 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( max_xor ( arr , n ) ) NEW_LINE DEDENT"],"references":["def max_xor ( arr , n ) : NEW_LINE INDENT maxx = 0 NEW_LINE mask = 0 ; NEW_LINE se = set ( ) NEW_LINE for i in range ( 30 , - 1 , - 1 ) : NEW_LINE INDENT mask |= ( 1 << i ) NEW_LINE newMaxx = maxx | ( 1 << i ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT se . add ( arr [ i ] & mask ) NEW_LINE DEDENT for prefix in se : NEW_LINE INDENT if ( newMaxx ^ prefix ) in se : NEW_LINE INDENT maxx = newMaxx NEW_LINE break NEW_LINE DEDENT DEDENT se . clear ( ) NEW_LINE DEDENT return maxx NEW_LINE DEDENT arr = [ 25 , 10 , 2 , 8 , 5 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( max_xor ( arr , n ) ) NEW_LINE"],"bleu":0.8467069169113619,"rouge_l":0.8835052620610608}
{"id":1136,"predictions":["N = 1000000007 ; NEW_LINE def exponentiation ( bas , exp ) : NEW_LINE INDENT t = 1 ; NEW_LINE while ( exp > 0 ) : NEW_LINE INDENT if ( exp % 2 != 0 ) : NEW_LINE INDENT t = ( t * base ) % N ; NEW_LINE DEDENT base = ( base * base ) % N ; NEW_LINE exp \/\/= 2 ; NEW_LINE DEDENT return t % N ; NEW_LINE DEDENT bas = 5 ; NEW_LINE exp = 100000 ; NEW_LINE modulo = exponentiation ( bas , exp ) ; NEW_LINE print ( modulo ) ; NEW_LINE"],"references":["N = 1000000007 ; NEW_LINE def exponentiation ( bas , exp ) : NEW_LINE INDENT t = 1 ; NEW_LINE while ( exp > 0 ) : NEW_LINE INDENT if ( exp % 2 != 0 ) : NEW_LINE INDENT t = ( t * bas ) % N ; NEW_LINE DEDENT bas = ( bas * bas ) % N ; NEW_LINE exp = int ( exp \/ 2 ) ; NEW_LINE DEDENT return t % N ; NEW_LINE DEDENT bas = 5 ; NEW_LINE exp = 100000 ; NEW_LINE modulo = exponentiation ( bas , exp ) ; NEW_LINE print ( modulo ) ; NEW_LINE"],"bleu":0.8354420009298086,"rouge_l":0.9242424242424242}
{"id":1137,"predictions":["def countMaxIntersect ( n ) : NEW_LINE INDENT return ( n ) * ( n - 1 ) \/ 2 NEW_LINE DEDENT n = 8 NEW_LINE print ( countMaxIntersect ( n ) ) NEW_LINE"],"references":["def countMaxIntersect ( n ) : NEW_LINE INDENT return int ( n * ( n - 1 ) \/ 2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 8 NEW_LINE print ( countMaxIntersect ( n ) ) NEW_LINE DEDENT"],"bleu":0.513831728649587,"rouge_l":0.7700841622035195}
{"id":1138,"predictions":["def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT def findArray ( n , k , s ) : NEW_LINE INDENT vis = [ 0 ] * n ; NEW_LINE cnt = 0 ; NEW_LINE arr = [ 0 ] * n ; NEW_LINE i = 0 ; NEW_LINE while ( i < n and cnt < k ) : NEW_LINE INDENT arr [ i ] = s ; NEW_LINE vis [ i ] = 1 ; NEW_LINE cnt += 1 ; NEW_LINE DEDENT val = s ; NEW_LINE if ( s % 2 == 0 ) : NEW_LINE INDENT val += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT val = val + 2 ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( vis [ i ] == 0 ) : NEW_LINE INDENT arr [ i ] = val ; NEW_LINE DEDENT DEDENT printArr ( arr , n ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 8 ; k = 3 ; s = 12 ; NEW_LINE findArray ( n , k , s ) ; NEW_LINE DEDENT"],"references":["def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT def findArray ( n , k , s ) : NEW_LINE INDENT vis = [ 0 ] * n ; NEW_LINE cnt = 0 ; NEW_LINE arr = [ 0 ] * n ; NEW_LINE i = 0 ; NEW_LINE while ( i < n and cnt < k ) : NEW_LINE INDENT arr [ i ] = s ; NEW_LINE vis [ i ] = 1 ; NEW_LINE cnt += 1 ; NEW_LINE i += 2 ; NEW_LINE DEDENT val = s ; NEW_LINE if ( s % 2 == 0 ) : NEW_LINE INDENT val += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT val = val + 2 ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( vis [ i ] == 0 ) : NEW_LINE INDENT arr [ i ] = val ; NEW_LINE DEDENT DEDENT printArr ( arr , n ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 8 ; k = 3 ; s = 12 ; NEW_LINE findArray ( n , k , s ) ; NEW_LINE DEDENT"],"bleu":0.9768227182151721,"rouge_l":0.9869979774631609}
{"id":1139,"predictions":["def modInverse ( a , m ) : NEW_LINE INDENT a = a % m NEW_LINE for x in range ( 1 , m ) : NEW_LINE INDENT if ( ( a * x ) % m == 1 ) : NEW_LINE INDENT return x NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT a = 3 NEW_LINE m = 11 NEW_LINE print ( modInverse ( a , m ) ) NEW_LINE"],"references":["def modInverse ( a , m ) : NEW_LINE INDENT a = a % m ; NEW_LINE for x in range ( 1 , m ) : NEW_LINE INDENT if ( ( a * x ) % m == 1 ) : NEW_LINE INDENT return x NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT a = 3 NEW_LINE m = 11 NEW_LINE print ( modInverse ( a , m ) ) NEW_LINE"],"bleu":0.9641422058873443,"rouge_l":0.9916395726892707}
{"id":1140,"predictions":["def countDistinctCode ( str ) : NEW_LINE INDENTcodes = set ( ) NEW_LINE for i in range ( len ( str ) - 1 ) : NEW_LINE INDENTcodes . add ( str [ i : i + 2 ] ) NEW_LINE DEDENT return len (codes ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" UOKP \" NEW_LINE print ( countDistinctThree ( str ) ) NEW_LINE DEDENT"],"references":["def countDistinctCode ( string ) : NEW_LINE INDENT codes = set ( ) NEW_LINE for i in range ( 0 , len ( string ) - 1 ) : NEW_LINE INDENT codes . add ( string [ i : i + 2 ] ) NEW_LINE DEDENT return len ( codes ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" UPUP \" NEW_LINE print ( countDistinctCode ( string ) ) NEW_LINE DEDENT"],"bleu":0.6053662750122594,"rouge_l":0.8359634551495017}
{"id":1141,"predictions":["def OR ( a , n ) : NEW_LINE INDENT ans = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans |= a [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 4 , 6 ] NEW_LINE n = len ( a ) NEW_LINE print ( OR ( a , n ) ) NEW_LINE DEDENT"],"references":["def OR ( a , n ) : NEW_LINE INDENT ans = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans |= a [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 4 , 6 ] NEW_LINE n = len ( a ) NEW_LINE print ( OR ( a , n ) ) NEW_LINE DEDENT"],"bleu":1.0,"rouge_l":1.0}
{"id":1142,"predictions":["def kthSmallest ( arr , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE return arr [ k - 1 ] NEW_LINE DEDENT arr = [ 12 , 3 , 5 , 7 , 19 ] NEW_LINE k = 2 NEW_LINE print ( \" K ' th ▁ smallest ▁ element ▁ is \" , kthSmallest ( arr , kthSmallest ( arr , k ) ) ) NEW_LINE"],"references":["def kthSmallest ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE return arr [ k - 1 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 12 , 3 , 5 , 7 , 19 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE print ( \" K ' th ▁ smallest ▁ element ▁ is \" , kthSmallest ( arr , n , k ) ) NEW_LINE DEDENT"],"bleu":0.6641590330487134,"rouge_l":0.8068136272545088}
{"id":1143,"predictions":["def findOddPair ( A , N ) : NEW_LINE INDENT oddPair = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( ( A [ i ] ^ A [ j ] ) % 2 != 0 ) : NEW_LINE INDENT oddPair += 1 NEW_LINE DEDENT DEDENT DEDENT return oddPair ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 5 , 4 , 7 , 2 , 1 ] ; NEW_LINE N = len ( A ) NEW_LINE print findOddPair ( A , N ) NEW_LINE DEDENT"],"references":["def findOddPair ( A , N ) : NEW_LINE INDENT oddPair = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( ( A [ i ] ^ A [ j ] ) % 2 != 0 ) : NEW_LINE INDENT oddPair += 1 NEW_LINE DEDENT DEDENT DEDENT return oddPair NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 5 , 4 , 7 , 2 , 1 ] NEW_LINE N = len ( A ) NEW_LINE print ( findOddPair ( A , N ) ) NEW_LINE DEDENT"],"bleu":0.8925622891260835,"rouge_l":0.9658119658119658}
{"id":1144,"predictions":["def ReplaceElements ( arr , n ) : NEW_LINE INDENT mp = { i : 0 for i in range ( len ( arr ) ) } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] not in mp [ arr [ i ] ] ) : NEW_LINE INDENT mp [ arr [ i ] ] = 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 ; NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = n - mp [ arr [ i ] ] ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 5 , 2 , 2 , 5 , 4 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE ReplaceElements ( arr , n ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT"],"references":["def ReplaceElements ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] = mp . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = n - mp [ arr [ i ] ] NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 5 , 2 , 2 , 5 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE ReplaceElements ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT"],"bleu":0.5752863947557565,"rouge_l":0.801534741932093}
{"id":1145,"predictions":["def printCombination ( arr , n , r , r ) : NEW_LINE INDENT data = [ 0 ] * r ; NEW_LINE for j in range ( r ) : NEW_LINE INDENT print ( data [ j ] , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( ) ; NEW_LINE return ; NEW_LINE DEDENT if ( i >= n ) : NEW_LINE INDENT return ; NEW_LINE DEDENT data [ index ] = arr [ i ] ; NEW_LINE combinationUtil ( arr , n , index + 1 , data , i + 1 ) ; NEW_LINE combinationUtil ( arr , n , r , index + 1 ) ; NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 ] ; NEW_LINE r = 3 ; NEW_LINE n = len ( arr ) ; NEW_LINE printCombination ( arr , n , r ) ; NEW_LINE"],"references":["def printCombination ( arr , n , r ) : NEW_LINE INDENT data = [ 0 ] * r NEW_LINE combinationUtil ( arr , n , r , 0 , data , 0 ) NEW_LINE DEDENT def combinationUtil ( arr , n , r , index , data , i ) : NEW_LINE INDENT if ( index == r ) : NEW_LINE INDENT for j in range ( r ) : NEW_LINE INDENT print ( data [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE return NEW_LINE DEDENT if ( i >= n ) : NEW_LINE INDENT return NEW_LINE DEDENT data [ index ] = arr [ i ] NEW_LINE combinationUtil ( arr , n , r , index + 1 , data , i + 1 ) NEW_LINE combinationUtil ( arr , n , r , index , data , i + 1 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE r = 3 NEW_LINE n = len ( arr ) NEW_LINE printCombination ( arr , n , r ) NEW_LINE DEDENT"],"bleu":0.5595770317607905,"rouge_l":0.7640803820852481}
{"id":1146,"predictions":["from math import sqrt NEW_LINE def countPair ( a , n ) : NEW_LINE INDENT maxm = a [ 0 ] NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT if ( a [ i ] > maxm ) : NEW_LINE INDENT maxm = a [ i ] NEW_LINE DEDENT DEDENT prime = [ 0 for i in range ( maxm + 1 ) ] NEW_LINE prime [ 1 ] = 1 ; NEW_LINE for i in range ( 2 , int ( sqrt ( maxm + 1 ) ) + 1 , 1 ) : NEW_LINE INDENT if ( prime [ i ] == 0 ) : NEW_LINE INDENT for j in range ( 2 * i , maxm + 1 , i ) : NEW_LINE INDENT prime [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT def countPrimes ( a , n ) : NEW_LINE INDENT if ( prime [ a [ i ] ] == 0 ) : NEW_LINE INDENT countPrimes = n - countPrimes NEW_LINE DEDENT DEDENT noPrimes = n - countPrimes NEW_LINE pairswith1Prime = nonPrimes * countPrimes NEW_LINE pairsWith2Primes = ( countPrimes * ( countPrimes - 1 ) ) \/\/ 2 NEW_LINE return pairswith1 + pairsWith2Primes NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 3 , 5 , 4 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPair ( arr , n ) ) NEW_LINE DEDENT"],"references":["def sieve ( maxm , prime ) : NEW_LINE INDENT prime [ 0 ] = prime [ 1 ] = 1 ; NEW_LINE i = 2 ; NEW_LINE while ( i * i <= maxm ) : NEW_LINE INDENT if ( prime [ i ] == 0 ) : NEW_LINE INDENT for j in range ( 2 * i , maxm + 1 , i ) : NEW_LINE INDENT prime [ j ] = 1 ; NEW_LINE DEDENT DEDENT i += 1 ; NEW_LINE DEDENT DEDENT def countPair ( a , n ) : NEW_LINE INDENT maxm = max ( a ) ; NEW_LINE prime = [ 0 ] * ( maxm + 1 ) ; NEW_LINE sieve ( maxm , prime ) ; NEW_LINE countPrimes = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ a [ i ] ] == 0 ) : NEW_LINE INDENT countPrimes += 1 ; NEW_LINE DEDENT DEDENT nonPrimes = n - countPrimes ; NEW_LINE pairswith1Prime = nonPrimes * countPrimes ; NEW_LINE pairsWith2Primes = ( countPrimes * ( countPrimes - 1 ) ) \/\/ 2 ; NEW_LINE return pairswith1Prime + pairsWith2Primes ; NEW_LINE DEDENT arr = [ 2 , 3 , 5 , 4 , 7 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( countPair ( arr , n ) ) ; NEW_LINE"],"bleu":0.5894830011321849,"rouge_l":0.65140797170453}
{"id":1147,"predictions":["import math NEW_LINE def nextPerfectCube ( N ) : NEW_LINE INDENT nextN = math . floor ( N ** ( 1. \/ 3 ) ) + 1 NEW_LINE return nextN * nextN NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 35 NEW_LINE print ( nextPerfectCube ( N ) ) NEW_LINE DEDENT"],"references":["from math import * NEW_LINE def nextPerfectCube ( N ) : NEW_LINE INDENT nextN = floor ( N ** ( 1 \/ 3 ) ) + 1 NEW_LINE return nextN ** 3 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 35 NEW_LINE print ( nextPerfectCube ( n ) ) NEW_LINE DEDENT"],"bleu":0.6295845814644481,"rouge_l":0.8333333333333334}
{"id":1148,"predictions":["def reverse ( arr , n , k ) : NEW_LINE INDENT for i in range ( 0 , n - 1 , k ) : NEW_LINE INDENT left = i NEW_LINE right = min ( i + k - 1 , n - 1 ) NEW_LINE temp = while ( left < right ) : NEW_LINE INDENT temp = arr [ left ] NEW_LINE arr [ left ] = arr [ right ] NEW_LINE arr [ right ] = temp NEW_LINE left += 1 NEW_LINE right -= 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ] NEW_LINE k = 3 NEW_LINE n = len ( arr ) NEW_LINE reverse ( arr , n , k ) ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT"],"references":["def reverse ( arr , n , k ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT left = i NEW_LINE right = min ( i + k - 1 , n - 1 ) NEW_LINE while ( left < right ) : NEW_LINE INDENT arr [ left ] , arr [ right ] = arr [ right ] , arr [ left ] NEW_LINE left += 1 ; NEW_LINE right - + 1 NEW_LINE DEDENT i += k NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ] NEW_LINE k = 3 NEW_LINE n = len ( arr ) NEW_LINE reverse ( arr , n , k ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT"],"bleu":0.7231441690474759,"rouge_l":0.851700408895981}
{"id":1149,"predictions":["def printChar ( str , n ) : NEW_LINE INDENT freq = [ 0 for i in range ( 26 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] % 2 == 1 ) : NEW_LINE INDENT print ( str [ i ] , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" geeksforgeeks \" ; NEW_LINE n = len ( str ) ; NEW_LINE printChar ( str , n ) ; NEW_LINE DEDENT"],"references":["import sys NEW_LINE import math NEW_LINE def printChar ( str_ , n ) : NEW_LINE INDENT freq = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( str_ [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( freq [ ord ( str_ [ i ] ) - ord ( ' a ' ) ] ) % 2 == 1 : NEW_LINE INDENT print ( \" { } \" . format ( str_ [ i ] ) , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str_ = \" geeksforgeeks \" NEW_LINE n = len ( str_ ) NEW_LINE printChar ( str_ , n ) NEW_LINE DEDENT"],"bleu":0.6973920643825262,"rouge_l":0.8539999999999998}
{"id":1150,"predictions":["import sys NEW_LINE def isSafe ( x , y ) : NEW_LINE INDENT return ( x < 4 and y < 3 ) ; NEW_LINE DEDENT def minJump ( height , x , y ) : NEW_LINE INDENT if ( x == 4 - 1 and y == 3 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT diag = sys . maxsize ; NEW_LINE if ( isSafe ( x + 1 , y + 1 ) ) : NEW_LINE INDENT diag = minJump ( height , x + 1 , y + 1 ) + abs ( height [ x ] [ y ] - height [ x + 1 ] [ y + 1 ] ) ; NEW_LINE DEDENT down = sys . maxsize ; NEW_LINE if ( isSafe ( x + 1 , y ) ) : NEW_LINE INDENT down = minJump ( height , x + 1 , y ) + abs ( height [ x ] [ y ] - height [ x + 1 ] [ y + 1 ] ) ; NEW_LINE DEDENT right = sys . maxsize ; NEW_LINE if ( isSafe ( x , y + 1 ) ) : NEW_LINE INDENT right = minJump ( height , x , y + 1 ) + abs ( height [ x ] [ y ] - height [ x + 1 ] [ y + 1 ] ) ; NEW_LINE DEDENT return min ( down , mid , diag ) ; NEW_LINE DEDENT height = [ [ 5 , 4 , 2 ] , [ 9 , 2 , 1 ] , [ 2 , 5 , 9 ] , [ 1 , 3 , 11 ] ] ; NEW_LINE print ( minJump ( height , 0 , 0 ) ) ; NEW_LINE"],"references":["R = 4 NEW_LINE C = 3 NEW_LINE def isSafe ( x , y ) : NEW_LINE INDENT return ( x < R and y < C ) NEW_LINE DEDENT def minJump ( height , x , y ) : NEW_LINE INDENT if ( x == R - 1 and y == C - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT diag = 10 ** 9 NEW_LINE if ( isSafe ( x + 1 , y + 1 ) ) : NEW_LINE INDENT diag = ( minJump ( height , x + 1 , y + 1 ) + abs ( height [ x ] [ y ] - height [ x + 1 ] [ y + 1 ] ) ) NEW_LINE DEDENT down = 10 ** 9 NEW_LINE if ( isSafe ( x + 1 , y ) ) : NEW_LINE INDENT down = ( minJump ( height , x + 1 , y ) + abs ( height [ x ] [ y ] - height [ x + 1 ] [ y ] ) ) NEW_LINE DEDENT right = 10 ** 9 NEW_LINE if ( isSafe ( x , y + 1 ) ) : NEW_LINE INDENT right = ( minJump ( height , x , y + 1 ) + abs ( height [ x ] [ y ] - height [ x ] [ y + 1 ] ) ) NEW_LINE DEDENT return min ( [ down , right , diag ] ) NEW_LINE DEDENT height = [ [ 5 , 4 , 2 ] , [ 9 , 2 , 1 ] , [ 2 , 5 , 9 ] , [ 1 , 3 , 11 ] ] NEW_LINE print ( minJump ( height , 0 , 0 ) ) NEW_LINE"],"bleu":0.7903388890323209,"rouge_l":0.8970099667774086}
{"id":1151,"predictions":["def segregate ( arr , size ) : NEW_LINE INDENT j = 0 NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT if ( arr [ i ] <= 0 ) : NEW_LINE INDENT arr [ i ] , arr [ i ] = arr [ j ] , arr [ i ] NEW_LINE DEDENT DEDENT return j NEW_LINE DEDENT def findMissingPositive ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT x = abs ( arr [ i ] ) NEW_LINE if ( x - 1 < size and arr [ x - 1 ] > 0 ) : NEW_LINE INDENT arr [ x - 1 ] = - arr [ x - 1 ] NEW_LINE DEDENT DEDENT for i in range ( size ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT return size + 1 NEW_LINE DEDENT def findMissing ( arr , size ) : NEW_LINE INDENT shift = segregate ( arr , size ) NEW_LINE arr2 = [ 0 for i in range ( size - shift ) ] NEW_LINE j = 0 NEW_LINE for i in range ( shift , size ) : NEW_LINE INDENT arr2 [ j ] = arr [ i ] NEW_LINE j += 1 NEW_LINE DEDENT return findMissingPositive ( arr2 , j ) NEW_LINE DEDENT arr = [ 0 , 10 , 2 , - 10 , - 20 ] NEW_LINE arr_size = len ( arr ) NEW_LINE missing = findMissingPositive ( arr , size_size ) NEW_LINE print ( \" The ▁ smallest ▁ positive ▁ number ▁ is \" , missing ) NEW_LINE"],"references":["def segregate ( arr , size ) : NEW_LINE INDENT j = 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT if ( arr [ i ] <= 0 ) : NEW_LINE INDENT arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return j NEW_LINE DEDENT def findMissingPositive ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT if ( abs ( arr [ i ] ) - 1 < size and arr [ abs ( arr [ i ] ) - 1 ] > 0 ) : NEW_LINE INDENT arr [ abs ( arr [ i ] ) - 1 ] = - arr [ abs ( arr [ i ] ) - 1 ] NEW_LINE DEDENT DEDENT for i in range ( size ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT return size + 1 NEW_LINE DEDENT def findMissing ( arr , size ) : NEW_LINE INDENT shift = segregate ( arr , size ) NEW_LINE return findMissingPositive ( arr [ shift : ] , size - shift ) NEW_LINE DEDENT arr = [ 0 , 10 , 2 , - 10 , - 20 ] NEW_LINE arr_size = len ( arr ) NEW_LINE missing = findMissing ( arr , arr_size ) NEW_LINE print ( \" The ▁ smallest ▁ positive ▁ missing ▁ number ▁ is ▁ \" , missing ) NEW_LINE"],"bleu":0.7710471993300594,"rouge_l":0.824275469685296}
{"id":1152,"predictions":["from math import gcd as __gcd NEW_LINE def minStepsNeeded ( k , d1 , d2 , x ) : NEW_LINE INDENT gcd = gcd ( d1 , d2 ) NEW_LINE if ( ( k - x ) % gcd != 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT q = set ( ) NEW_LINE visited = set ( ) NEW_LINE q . add ( k ) NEW_LINE while ( len ( q ) != x ) : NEW_LINE INDENT s = q [ 0 ] [ 0 ] NEW_LINE stp = q [ 0 ] [ 1 ] NEW_LINE if ( s == x ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT q . remove ( ( s + d1 , st1 ) ) NEW_LINE visited . add ( s + d1 ) NEW_LINE if ( s + d1 not in visited ) : NEW_LINE INDENT q . add ( ( s + d1 , st2 + 1 ) ) NEW_LINE visited . add ( s + d1 ) NEW_LINE DEDENT if ( not visited ) : NEW_LINE INDENT q . append ( ( ( s + d1 , st2 + 1 ) ) ) NEW_LINE visited . add ( s + d1 ) NEW_LINE DEDENT if ( not visited ) : NEW_LINE INDENT q . append ( ( [ s - d1 , stp + 1 ) ) NEW_LINE visited . append ( ( s - d2 , stp + 1 ) ) NEW_LINE DEDENT if ( not visited ) : NEW_LINE INDENT q . append ( ( [ s - d1 , st2 + 1 ) ) NEW_LINE visited . append ( s - d1 , stp + 1 ) ) NEW_LINE DEDENT DEDENT return - 10 ** 9 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT k = 10 NEW_LINE d1 = 4 NEW_LINE d2 = 6 NEW_LINE x = 8 NEW_LINE print ( minStepsNeeds ( k , d1 , d2 , x ) ) NEW_LINE DEDENT"],"references":["from math import gcd as __gcd NEW_LINE from collections import deque as queue NEW_LINE def minStepsNeeded ( k , d1 , d2 , x ) : NEW_LINE INDENT gcd = __gcd ( d1 , d2 ) NEW_LINE if ( ( k - x ) % gcd != 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT q = queue ( ) NEW_LINE visited = dict ( ) NEW_LINE q . appendleft ( [ k , 0 ] ) NEW_LINE visited [ k ] = 1 NEW_LINE while ( len ( q ) > 0 ) : NEW_LINE INDENT sr = q . pop ( ) NEW_LINE s , stp = sr [ 0 ] , sr [ 1 ] NEW_LINE if ( s == x ) : NEW_LINE INDENT return stp NEW_LINE DEDENT if ( s + d1 not in visited ) : NEW_LINE INDENT q . appendleft ( [ ( s + d1 ) , stp + 1 ] ) NEW_LINE visited [ ( s + d1 ) ] = 1 NEW_LINE DEDENT if ( s + d2 not in visited ) : NEW_LINE INDENT q . appendleft ( [ ( s + d2 ) , stp + 1 ] ) NEW_LINE visited [ ( s + d2 ) ] = 1 NEW_LINE DEDENT if ( s - d1 not in visited ) : NEW_LINE INDENT q . appendleft ( [ ( s - d1 ) , stp + 1 ] ) NEW_LINE visited [ ( s - d1 ) ] = 1 NEW_LINE DEDENT if ( s - d2 not in visited ) : NEW_LINE INDENT q . appendleft ( [ ( s - d2 ) , stp + 1 ] ) NEW_LINE visited [ ( s - d2 ) ] = 1 NEW_LINE DEDENT DEDENT DEDENT k = 10 NEW_LINE d1 = 4 NEW_LINE d2 = 6 NEW_LINE x = 8 NEW_LINE print ( minStepsNeeded ( k , d1 , d2 , x ) ) NEW_LINE"],"bleu":0.5392452335926584,"rouge_l":0.7243375858684985}
{"id":1153,"predictions":["def minAbsSumPair ( arr , n , m ) : NEW_LINE INDENT if ( arr_size < 2 ) : NEW_LINE INDENT print ( \" Invalid ▁ Input ▁ Input \" ) NEW_LINE return NEW_LINE DEDENT min_l = 0 NEW_LINE min_r = 1 NEW_LINE min_sum = arr [ 0 ] + arr [ 1 ] NEW_LINE for l in range ( 0 , arr_size - 1 ) : NEW_LINE INDENT for r in range ( l + 1 , arr_size ) : NEW_LINE INDENT sum = arr [ l ] + arr [ r ] NEW_LINE if ( abs ( min_sum ) > abs ( sum ) ) : NEW_LINE INDENT min_sum = sum NEW_LINE min_l = l NEW_LINE min_r = r NEW_LINE DEDENT DEDENT DEDENT print ( \" The ▁ two ▁ elements ▁ are \" , arr [ min_l ] , \" and \" , arr [ min_r ] ) NEW_LINE DEDENT arr = [ 1 , 60 , - 10 , 70 , - 80 , 85 ] NEW_LINE minAbsoluteSumPair ( arr , 6 ) NEW_LINE"],"references":["def minAbsSumPair ( arr , arr_size ) : NEW_LINE INDENT inv_count = 0 NEW_LINE if arr_size < 2 : NEW_LINE INDENT print ( \" Invalid ▁ Input \" ) NEW_LINE return NEW_LINE DEDENT min_l = 0 NEW_LINE min_r = 1 NEW_LINE min_sum = arr [ 0 ] + arr [ 1 ] NEW_LINE for l in range ( 0 , arr_size - 1 ) : NEW_LINE INDENT for r in range ( l + 1 , arr_size ) : NEW_LINE INDENT sum = arr [ l ] + arr [ r ] NEW_LINE if abs ( min_sum ) > abs ( sum ) : NEW_LINE INDENT min_sum = sum NEW_LINE min_l = l NEW_LINE min_r = r NEW_LINE DEDENT DEDENT DEDENT print ( \" The ▁ two ▁ elements ▁ whose ▁ sum ▁ is ▁ minimum ▁ are \" , arr [ min_l ] , \" and ▁ \" , arr [ min_r ] ) NEW_LINE DEDENT arr = [ 1 , 60 , - 10 , 70 , - 80 , 85 ] NEW_LINE minAbsSumPair ( arr , 6 ) ; NEW_LINE"],"bleu":0.8450109938506561,"rouge_l":0.9254108723135271}
{"id":1154,"predictions":["def findSubsequence ( arr , n ) : NEW_LINE INDENT Len = 1 NEW_LINE tmp = 0 NEW_LINE cnt = [ 0 for i in range ( 10 ) ] NEW_LINE locMax = [ 0 for i in range ( 10 ) ] NEW_LINE locMax = 0 NEW_LINE tmp = arr [ 0 ] NEW_LINE while ( tmp > 0 ) : NEW_LINE INDENT dp [ tmp % 10 ] = 1 NEW_LINE tmp \/\/= 10 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT tmp = arr [ i ] NEW_LINE locMax = 1 NEW_LINE cnt = 0 NEW_LINE while ( tmp > 0 ) : NEW_LINE INDENT cnt [ tmp % 10 ] = 1 NEW_LINE tmp \/\/= 10 NEW_LINE DEDENT for d in range ( 10 ) : NEW_LINE INDENT if ( cnt [ d ] ) : NEW_LINE INDENT dp [ d ] += 1 NEW_LINE locMax = max ( locMax , dp [ d ] ) NEW_LINE DEDENT DEDENT for d in range ( 10 ) : NEW_LINE INDENT if ( cnt [ d ] ) : NEW_LINE INDENT dp [ d ] += 1 NEW_LINE DEDENT DEDENT Len = max ( Len , locMax ) NEW_LINE DEDENT return Len NEW_LINE DEDENT arr = [ 1 , 12 , 44 , 29 , 29 , 33 , 96 , 89 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findSubsequence ( arr , n ) ) NEW_LINE"],"references":["def findSubsequence ( arr , n ) : NEW_LINE INDENT length = 1 ; NEW_LINE dp = [ 0 ] * 10 ; NEW_LINE tmp = arr [ 0 ] ; NEW_LINE while ( tmp > 0 ) : NEW_LINE INDENT dp [ tmp % 10 ] = 1 ; NEW_LINE tmp \/\/= 10 ; NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT tmp = arr [ i ] ; NEW_LINE locMax = 1 ; NEW_LINE cnt = [ 0 ] * 10 NEW_LINE while ( tmp > 0 ) : NEW_LINE INDENT cnt [ tmp % 10 ] = 1 ; NEW_LINE tmp \/\/= 10 ; NEW_LINE DEDENT for d in range ( 10 ) : NEW_LINE INDENT if ( cnt [ d ] ) : NEW_LINE INDENT dp [ d ] += 1 ; NEW_LINE locMax = max ( locMax , dp [ d ] ) ; NEW_LINE DEDENT DEDENT for d in range ( 10 ) : NEW_LINE INDENT if ( cnt [ d ] ) : NEW_LINE INDENT dp [ d ] = locMax ; NEW_LINE DEDENT DEDENT length = max ( length , locMax ) ; NEW_LINE DEDENT return length ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 12 , 44 , 29 , 33 , 96 , 89 ] ; NEW_LINE n = len ( arr ) NEW_LINE print ( findSubsequence ( arr , n ) ) ; NEW_LINE DEDENT"],"bleu":0.7096947265821264,"rouge_l":0.8434274586173323}
{"id":1155,"predictions":["dp = [ [ - 1 for i in range ( 5 ) ] for j in range ( 5001 ) ] NEW_LINE def countWaysUtil ( n , Parts , nextPart ) : NEW_LINE INDENT if (Parts == 0 and n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n <= 0 orParts <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ n ] [ nextPart ] [ segments ] != - 1 ) : NEW_LINE INDENT return dp [ n ] [ nextPart ] [ indexes ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( nextPart , n + 1 ) : NEW_LINE INDENT ans += countWaysUtil ( n - i ,Parts - 1 , i ) NEW_LINE DEDENT dp [ n ] [ nextPart ] [ indexes ] = ans NEW_LINE return countWaysUtil ( n , 4 , 1 ) NEW_LINE DEDENT def countWays ( n ) : NEW_LINE INDENT for i in range ( 5001 ) : NEW_LINE INDENT for j in range ( 5001 ) : NEW_LINE INDENT dp [ i ] [ j ] [ l ] = - 1 NEW_LINE DEDENT DEDENT return countWaysUtil ( n , 4 , 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 8 NEW_LINE print ( countWays ( n , 4 , 1 ) ) NEW_LINE DEDENT"],"references":["dp = [ [ [ - 1 for i in range ( 5 ) ] for i in range ( 501 ) ] for i in range ( 501 ) ] NEW_LINE def countWaysUtil ( n , parts , nextPart ) : NEW_LINE INDENT if ( parts == 0 and n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n <= 0 or parts <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ n ] [ nextPart ] [ parts ] != - 1 ) : NEW_LINE INDENT return dp [ n ] [ nextPart ] [ parts ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( nextPart , n + 1 ) : NEW_LINE INDENT ans += countWaysUtil ( n - i , parts - 1 , i ) NEW_LINE DEDENT dp [ n ] [ nextPart ] [ parts ] = ans NEW_LINE return ( ans ) NEW_LINE DEDENT def countWays ( n ) : NEW_LINE INDENT return countWaysUtil ( n , 4 , 1 ) NEW_LINE DEDENT n = 8 NEW_LINE print ( countWays ( n ) ) NEW_LINE"],"bleu":0.6436058444545246,"rouge_l":0.8065185640710276}
{"id":1156,"predictions":["import sys NEW_LINE import math NEW_LINE import random NEW_LINE import random NEW_LINE def nthRoot ( A , N ) : NEW_LINE INDENT xPre = random . randint NEW_LINE eps = 1e-3 NEW_LINE delX = 10 ** 9 NEW_LINE xK = 0 NEW_LINE while ( delX > eps ) : NEW_LINE INDENT xK = ( ( N - 1.0 ) * xPre + A \/ pow ( xPre , N - 1 ) ) \/ N NEW_LINE delX = abs ( xK - xPre ) NEW_LINE xPre = xK ; NEW_LINE DEDENT return xK NEW_LINE DEDENT def countPowers ( a , b , k ) : NEW_LINE INDENT return ( floor ( nthRoot ( b , k ) ) - ceil ( nthRoot ( a , k ) ) + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 7 NEW_LINE b = 28 NEW_LINE k = 2 NEW_LINE print ( \" Count ▁ of ▁ powers ▁ is ▁ \" , countPowers ( a , b , k ) ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE from math import pow , ceil , floor NEW_LINE import random NEW_LINE def nthRoot ( A , N ) : NEW_LINE INDENT xPre = ( random . randint ( 0 , 9 ) ) % 10 NEW_LINE eps = 1e-3 NEW_LINE delX = sys . maxsize NEW_LINE while ( delX > eps ) : NEW_LINE INDENT xK = ( ( N - 1.0 ) * xPre + A \/ pow ( xPre , N - 1 ) ) \/ N NEW_LINE delX = abs ( xK - xPre ) NEW_LINE xPre = xK NEW_LINE DEDENT return xK NEW_LINE DEDENT def countPowers ( a , b , k ) : NEW_LINE INDENT return ( floor ( nthRoot ( b , k ) ) - ceil ( nthRoot ( a , k ) ) + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 7 NEW_LINE b = 28 NEW_LINE k = 2 NEW_LINE print ( \" Count ▁ of ▁ Powers ▁ is \" , countPowers ( a , b , k ) ) NEW_LINE DEDENT"],"bleu":0.837835251371992,"rouge_l":0.91084997349355}
{"id":1157,"predictions":["def minSwaps ( str1 , str2 ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT if ( str1 [ i ] != str2 [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count % 2 == 0 ) : NEW_LINE INDENT print ( count \/\/ 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ Possible \" ) NEW_LINE DEDENT DEDENT binaryString1 = \"1110000\" NEW_LINE binaryString2 = \"0001101\" NEW_LINE minSwaps ( binaryString1 , binaryString2 ) NEW_LINE"],"references":["def minSwaps ( str1 , str2 ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT if str1 [ i ] != str2 [ i ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if count % 2 == 0 : NEW_LINE INDENT print ( count \/\/ 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ Possible \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT binaryString1 = \"1110000\" NEW_LINE binaryString2 = \"0001101\" NEW_LINE minSwaps ( binaryString1 , binaryString2 ) NEW_LINE DEDENT"],"bleu":0.7921158500961062,"rouge_l":0.9037756890234188}
{"id":1158,"predictions":["def countOrderedPairs ( arr , n ) : NEW_LINE INDENTorderedPairs = 0 NEW_LINE m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( m [ i ] not in m . keys ( ) ) : NEW_LINE INDENT m [ A [ i ] ] += 1 NEW_LINE DEDENT DEDENT for item in m : NEW_LINE INDENT X = item NEW_LINE Y = m [ item ] NEW_LINE for j in range ( 1 , Y + 1 ) : NEW_LINE INDENT if ( m [ j ] >= X ) : NEW_LINE INDENT sortedPairs += 1 NEW_LINE DEDENT DEDENT DEDENT return sortedPairs NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 1 , 1 , 2 , 2 , 3 ] NEW_LINE n = len ( A ) NEW_LINE print ( countOrderedPairs ( A , n ) ) NEW_LINE DEDENT"],"references":["from collections import defaultdict NEW_LINE def countOrderedPairs ( A , n ) : NEW_LINE INDENT orderedPairs = 0 NEW_LINE m = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT m [ A [ i ] ] += 1 NEW_LINE DEDENT for X , Y in m . items ( ) : NEW_LINE INDENT for j in range ( 1 , Y + 1 ) : NEW_LINE INDENT if m [ j ] >= X : NEW_LINE INDENT orderedPairs += 1 NEW_LINE DEDENT DEDENT DEDENT return orderedPairs NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 1 , 1 , 2 , 2 , 3 ] NEW_LINE n = len ( A ) NEW_LINE print ( countOrderedPairs ( A , n ) ) NEW_LINE DEDENT"],"bleu":0.6388766437474335,"rouge_l":0.794723012918765}
{"id":1159,"predictions":["def makeAP ( arr , n ) : NEW_LINE INDENT if ( n == 3 ) : NEW_LINE INDENT common_difference = arr [ 2 ] - arr [ 1 ] NEW_LINE initial_term = arr [ 1 ] - common_difference NEW_LINE DEDENT elif ( ( arr [ 1 ] - arr [ 0 ] ) == arr [ 2 ] - arr [ 1 ] ) : NEW_LINE INDENT initial_term = arr [ 0 ] NEW_LINE common_difference = arr [ 1 ] - arr [ 0 ] NEW_LINE DEDENT elif ( ( arr [ 2 ] - arr [ 1 ] ) == ( arr [ 3 ] - arr [ 2 ] ) ) : NEW_LINE INDENT common_difference = arr [ 2 ] - arr [ 1 ] NEW_LINE current_term = arr [ 1 ] - common_difference NEW_LINE DEDENT else : NEW_LINE INDENT common_difference = ( arr [ 3 ] - arr [ 0 ] ) \/ 3 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( current_term + ( i * common_difference ) , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT arr = [ 1 , 3 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE makeAP ( arr , n ) NEW_LINE"],"references":["def makeAP ( arr , n ) : NEW_LINE INDENT initial_term , common_difference = 0 , 0 NEW_LINE if ( n == 3 ) : NEW_LINE INDENT common_difference = arr [ 2 ] - arr [ 1 ] NEW_LINE initial_term = arr [ 1 ] - common_difference NEW_LINE DEDENT elif ( ( arr [ 1 ] - arr [ 0 ] ) == arr [ 2 ] - arr [ 1 ] ) : NEW_LINE INDENT initial_term = arr [ 0 ] NEW_LINE common_difference = arr [ 1 ] - arr [ 0 ] NEW_LINE DEDENT elif ( ( arr [ 2 ] - arr [ 1 ] ) == ( arr [ 3 ] - arr [ 2 ] ) ) : NEW_LINE INDENT common_difference = arr [ 2 ] - arr [ 1 ] NEW_LINE initial_term = arr [ 1 ] - common_difference NEW_LINE DEDENT else : NEW_LINE INDENT common_difference = ( arr [ 3 ] - arr [ 0 ] ) \/ 3 NEW_LINE initial_term = arr [ 0 ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( int ( initial_term + ( i * common_difference ) ) , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT arr = [ 1 , 3 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE makeAP ( arr , n ) NEW_LINE"],"bleu":0.8860233561621734,"rouge_l":0.9445444724522866}
{"id":1160,"predictions":["def countIncreasing ( arr , n ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE len = 1 ; NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i + 1 ] > arr [ i ] ) : NEW_LINE INDENT len += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT cnt += ( ( ( ( len - 1 ) * len ) \/ 2 ) ) ; NEW_LINE len = 1 ; NEW_LINE DEDENT DEDENT if ( len > 1 ) : NEW_LINE INDENT cnt += ( ( ( len - 1 ) * len ) \/ 2 ) ; NEW_LINE DEDENT return cnt ; NEW_LINE DEDENT arr = [ 1 , 2 , 2 , 4 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( \" Count ▁ of ▁ balls ▁ increasing ▁ subarrays ▁ is \" , countIncreasing ( arr , n ) ) ; NEW_LINE"],"references":["def countIncreasing ( arr , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE len = 1 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if arr [ i + 1 ] > arr [ i ] : NEW_LINE INDENT len += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += ( ( ( len - 1 ) * len ) \/ 2 ) NEW_LINE len = 1 NEW_LINE DEDENT DEDENT if len > 1 : NEW_LINE INDENT cnt += ( ( ( len - 1 ) * len ) \/ 2 ) NEW_LINE DEDENT return cnt NEW_LINE DEDENT arr = [ 1 , 2 , 2 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Count ▁ of ▁ strictly ▁ increasing ▁ subarrays ▁ is \" , int ( countIncreasing ( arr , n ) ) ) NEW_LINE"],"bleu":0.751044678340547,"rouge_l":0.9407106387412733}
{"id":1161,"predictions":["def harmonicMean ( arr , n ) : NEW_LINE INDENT sm = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sm = sm + 1 \/ arr [ i ] NEW_LINE DEDENT return n \/ sm NEW_LINE DEDENT arr = [ 13.5 , 14.5 , 14.8 , 15 , 16.1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( harmonicMean ( arr , n ) ) NEW_LINE"],"references":["def harmonicMean ( arr , n ) : NEW_LINE INDENT sm = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sm = sm + ( 1 ) \/ arr [ i ] ; NEW_LINE DEDENT return n \/ sm NEW_LINE DEDENT arr = [ 13.5 , 14.5 , 14.8 , 15.2 , 16.1 ] ; NEW_LINE n = len ( arr ) NEW_LINE print ( harmonicMean ( arr , n ) ) NEW_LINE"],"bleu":0.8461860349963533,"rouge_l":0.9565585929222292}
{"id":1162,"predictions":["def asPowerSum ( w , m ) : NEW_LINE INDENT while ( m > 0 ) : NEW_LINE INDENT if ( ( m - 1 ) % w == 0 ) : NEW_LINE INDENT m = ( m - 1 ) \/\/ w NEW_LINE DEDENT elif ( ( m + 1 ) % w == 0 ) : NEW_LINE INDENT m = ( m + 1 ) \/\/ w NEW_LINE DEDENT elif ( m % w == 0 ) : NEW_LINE INDENT m = m \/\/ w NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return ( m == 0 ) NEW_LINE DEDENT w = 3 NEW_LINE m = 7 NEW_LINE if ( asPowerSum ( w , m ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def asPowerSum ( w , m ) : NEW_LINE INDENT while ( m > 0 ) : NEW_LINE INDENT if ( ( m - 1 ) % w == 0 ) : NEW_LINE INDENT m = ( m - 1 ) \/ w ; NEW_LINE DEDENT elif ( ( m + 1 ) % w == 0 ) : NEW_LINE INDENT m = ( m + 1 ) \/ w ; NEW_LINE DEDENT elif ( m % w == 0 ) : NEW_LINE INDENT m = m \/ w ; NEW_LINE DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT return ( m == 0 ) ; NEW_LINE DEDENT w = 3 ; NEW_LINE m = 7 ; NEW_LINE if ( asPowerSum ( w , m ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT"],"bleu":0.8158960818466195,"rouge_l":0.9447049841858435}
{"id":1163,"predictions":["def result ( n , k , t ) : NEW_LINE INDENT if ( t <= k ) : NEW_LINE INDENT print ( t ) NEW_LINE DEDENT elif ( t <= n ) : NEW_LINE INDENT print ( k ) NEW_LINE DEDENT else : NEW_LINE INDENT temp = t - n NEW_LINE temp = k - temp NEW_LINE print ( temp ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE k = 5 NEW_LINE t = 12 NEW_LINE result ( n , k , t ) NEW_LINE DEDENT"],"references":["def result ( n , k , t ) : NEW_LINE INDENT if ( t <= k ) : NEW_LINE INDENT print ( t ) NEW_LINE DEDENT elif ( t <= n ) : NEW_LINE INDENT print ( k ) NEW_LINE DEDENT else : NEW_LINE INDENT temp = t - n NEW_LINE temp = k - temp NEW_LINE print ( temp ) NEW_LINE DEDENT DEDENT n = 10 NEW_LINE k = 5 NEW_LINE t = 12 NEW_LINE result ( n , k , t ) NEW_LINE"],"bleu":0.8439751537493221,"rouge_l":0.9374553252323088}
{"id":1164,"predictions":["import math NEW_LINE table = [ ] NEW_LINE def gfG ( n ) : NEW_LINE INDENT height = ceil ( math . log10 ( n ) ) NEW_LINE table = [ [ - 1 for i in range ( height + 1 ) ] for j in range ( height + 1 ) ] NEW_LINE table = [ [ 0 for i in range ( height + 1 ) ] for i in range ( height + 1 ) ] NEW_LINE for i in range ( 1 , height + 1 ) : NEW_LINE INDENT table [ i ] [ 0 ] = table [ i ] [ i - 1 ] NEW_LINE if table [ v ] [ i ] == - 1 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT def calculateSparse ( V , k ) : NEW_LINE INDENT for i in range ( height + 1 ) : NEW_LINE INDENT table [ v ] [ i ] = table [ v ] [ i - 1 ] NEW_LINE if table [ v ] [ i ] == - 1 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT def kthacent ( V , k ) : NEW_LINE INDENT for i in range ( height + 1 ) : NEW_LINE INDENT if k & ( 1 << i ) != 0 : NEW_LINE INDENT V = table [ V ] [ i ] NEW_LINE if V == - 1 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return V NEW_LINE DEDENT n = 6 NEW_LINE preprocess ( ) NEW_LINE calculateSparse ( 1 , 2 ) NEW_LINE calculateSparse ( 2 , 3 ) NEW_LINE calculateSparse ( 2 , 4 ) NEW_LINE , calculateSparse ( 3 , 6 ) NEW_LINE K = 5 NEW_LINE print ( kthphanest ( V , K ) ) NEW_LINE"],"references":["import math NEW_LINE class GfG : NEW_LINE INDENT def __init__ ( self , n ) : NEW_LINE INDENT self . height = int ( math . ceil ( math . log10 ( n ) \/ math . log10 ( 2 ) ) ) NEW_LINE self . table = [ 0 ] * ( n + 1 ) NEW_LINE DEDENT def preprocessing ( self ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i < len ( self . table ) ) : NEW_LINE INDENT self . table [ i ] = [ - 1 ] * ( self . height + 1 ) NEW_LINE i = i + 1 NEW_LINE DEDENT DEDENT def calculateSparse ( self , u , v ) : NEW_LINE INDENT self . table [ v ] [ 0 ] = u NEW_LINE i = 1 NEW_LINE while ( i <= self . height ) : NEW_LINE INDENT self . table [ v ] [ i ] = self . table [ self . table [ v ] [ i - 1 ] ] [ i - 1 ] NEW_LINE if ( self . table [ v ] [ i ] == - 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT DEDENT def kthancestor ( self , V , k ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i <= self . height ) : NEW_LINE INDENT if ( ( k & ( 1 << i ) ) != 0 ) : NEW_LINE INDENT V = self . table [ V ] [ i ] NEW_LINE if ( V == - 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT i = i + 1 NEW_LINE DEDENT return V NEW_LINE DEDENT DEDENT n = 6 NEW_LINE obj = GfG ( n ) NEW_LINE obj . preprocessing ( ) NEW_LINE obj . calculateSparse ( 1 , 2 ) NEW_LINE obj . calculateSparse ( 1 , 3 ) NEW_LINE obj . calculateSparse ( 2 , 4 ) NEW_LINE obj . calculateSparse ( 2 , 5 ) NEW_LINE obj . calculateSparse ( 3 , 6 ) NEW_LINE K = 2 NEW_LINE V = 5 NEW_LINE print ( obj . kthancestor ( V , K ) ) NEW_LINE"],"bleu":0.41369378080922325,"rouge_l":0.616569053466843}
{"id":1165,"predictions":["def factors ( n , i ) : NEW_LINE INDENT if ( i <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) ; NEW_LINE DEDENT factors ( n , i + 1 ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 16 ; NEW_LINE factors ( 1 ) ; NEW_LINE DEDENT"],"references":["def factors ( n , i ) : NEW_LINE INDENT if ( i <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) ; NEW_LINE DEDENT factors ( n , i + 1 ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 16 ; NEW_LINE factors ( N , 1 ) ; NEW_LINE DEDENT"],"bleu":0.8939718414923291,"rouge_l":0.9608239095315023}
{"id":1166,"predictions":["def sumKRepeating ( arr , n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] in mp . keys ( ) ) : NEW_LINE INDENT mp [ arr [ i ] ] = 0 NEW_LINE DEDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT for x in mp : NEW_LINE INDENT if ( mp [ x ] == k ) : NEW_LINE INDENT sum += x NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 9 , 9 , 10 , 11 , 8 , 9 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE print ( sumKRepeating ( arr , n , k ) ) NEW_LINE DEDENT"],"references":["import math as mt NEW_LINE def sumKRepeating ( arr , n , k ) : NEW_LINE INDENT Sum = 0 NEW_LINE mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in mp . keys ( ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT for x in mp : NEW_LINE INDENT if ( mp [ x ] == k ) : NEW_LINE INDENT Sum += x NEW_LINE DEDENT DEDENT return Sum NEW_LINE DEDENT arr = [ 9 , 9 , 10 , 11 , 8 , 8 , 9 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE print ( sumKRepeating ( arr , n , k ) ) NEW_LINE"],"bleu":0.8028444223316716,"rouge_l":0.8704864864864863}
{"id":1167,"predictions":["def power ( num , n ) : NEW_LINE INDENT if ( n == 0 ) : return 1 NEW_LINE elif ( n % 2 == 0 ) : NEW_LINE INDENT return power ( num , int ( n \/ 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return num * power ( num , int ( n \/ 2 ) ) * power ( num , int ( n \/ 2 ) ) NEW_LINE DEDENT DEDENT def checkRecursive ( x , n , curr_num , curr_sum ) : NEW_LINE INDENT result = 0 NEW_LINE p = power ( curr_num , n ) NEW_LINE while ( p + curr_sum < x ) : NEW_LINE INDENT result += checkRecursive ( x , n , curr_sum + 1 , p + curr_sum ) NEW_LINE curr_num += 1 NEW_LINE p = power ( curr_num , n ) NEW_LINE DEDENT if ( p + curr_sum == x ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT return result NEW_LINE DEDENT x = 10 NEW_LINE n = 2 NEW_LINE print ( checkRecursive ( x , n , 1 , 0 ) ) NEW_LINE"],"references":["def power ( num , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( n % 2 == 0 ) : NEW_LINE INDENT return power ( num , n \/\/ 2 ) * power ( num , n \/\/ 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return num * power ( num , n \/\/ 2 ) * power ( num , n \/\/ 2 ) NEW_LINE DEDENT DEDENT def checkRecursive ( x , n , curr_num = 1 , curr_sum = 0 ) : NEW_LINE INDENT results = 0 NEW_LINE p = power ( curr_num , n ) NEW_LINE while ( p + curr_sum < x ) : NEW_LINE INDENT results += checkRecursive ( x , n , curr_num + 1 , p + curr_sum ) NEW_LINE curr_num = curr_num + 1 NEW_LINE p = power ( curr_num , n ) NEW_LINE DEDENT if ( p + curr_sum == x ) : NEW_LINE INDENT results = results + 1 NEW_LINE DEDENT return results NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 10 NEW_LINE n = 2 NEW_LINE print ( checkRecursive ( x , n ) ) NEW_LINE DEDENT"],"bleu":0.665438913167477,"rouge_l":0.8292226292226292}
{"id":1168,"predictions":["def nCr ( n , r ) : NEW_LINE INDENT fac = [ 0 ] * 100 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT fac [ i ] = 1 ; NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fac [ i ] = fac [ i - 1 ] * i ; NEW_LINE DEDENT ans = fac [ n ] \/ ( fac [ n - r ] * fac [ r ] ) ; NEW_LINE return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 ; NEW_LINE k = 3 ; NEW_LINE ans = nCr ( n + k - 1 , k ) + nCr ( k - 1 , n - 1 ) ; NEW_LINE print ( ans ) ; NEW_LINE DEDENT"],"references":["def nCr ( n , r ) : NEW_LINE INDENT fac = list ( ) NEW_LINE fac . append ( 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fac . append ( fac [ i - 1 ] * i ) NEW_LINE DEDENT ans = fac [ n ] \/ ( fac [ n - r ] * fac [ r ] ) NEW_LINE return ans NEW_LINE DEDENT n = 3 NEW_LINE k = 3 NEW_LINE ans = nCr ( n + k - 1 , k ) + nCr ( k - 1 , n - 1 ) NEW_LINE print ( ans ) NEW_LINE"],"bleu":0.5739117680847842,"rouge_l":0.8155080213903744}
{"id":1169,"predictions":["def pairORSum ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( ( i + 1 ) , n ) : NEW_LINE INDENT ans = ans + arr [ i ] ^ arr [ j ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 5 , 9 , 7 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( pairORSum ( arr , n ) ) NEW_LINE"],"references":["def pairORSum ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT ans = ans + ( arr [ i ] ^ arr [ j ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 5 , 9 , 7 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( pairORSum ( arr , n ) ) NEW_LINE"],"bleu":0.9231680988088558,"rouge_l":0.9780219780219781}
{"id":1170,"predictions":["def alphabetPattern ( N ) : NEW_LINE INDENT top = 1 NEW_LINE Bottom = 1 NEW_LINE Diagonal = N - 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT print ( top , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE for index in range ( 1 , N - 1 ) : NEW_LINE INDENT for side_index in range ( 0 , 2 * ( N - index - 1 ) ) : NEW_LINE INDENT print ( \" ▁ \" , end = \" \" ) NEW_LINE DEDENT print ( Diagonal - 1 , end = \" \" ) NEW_LINE Diagonal -= 1 NEW_LINE print ( ) NEW_LINE DEDENT for index in range ( 0 , N ) : NEW_LINE INDENT print (Bottom , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 5 NEW_LINE alphabetPattern ( N ) NEW_LINE DEDENT"],"references":["def alphabetPattern ( N ) : NEW_LINE INDENT Top , Bottom , Diagonal = 1 , 1 , N - 1 NEW_LINE for index in range ( N ) : NEW_LINE INDENT print ( Top , end = ' ▁ ' ) NEW_LINE Top += 1 NEW_LINE DEDENT print ( ) NEW_LINE for index in range ( 1 , N - 1 ) : NEW_LINE INDENT for side_index in range ( 2 * ( N - index - 1 ) ) : NEW_LINE INDENT print ( ' ▁ ' , end = ' ' ) NEW_LINE DEDENT print ( Diagonal , end = ' ' ) NEW_LINE Diagonal -= 1 NEW_LINE print ( ) NEW_LINE DEDENT for index in range ( N ) : NEW_LINE INDENT print ( Bottom , end = ' ▁ ' ) NEW_LINE Bottom += 1 NEW_LINE DEDENT DEDENT N = 5 NEW_LINE alphabetPattern ( N ) NEW_LINE"],"bleu":0.6070634431673931,"rouge_l":0.7859013302608149}
{"id":1171,"predictions":["def areElementsContiguous ( arr , n ) : NEW_LINE INDENT us = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT us . add ( arr [ i ] ) NEW_LINE DEDENT count = 1 NEW_LINE curr_ele = arr [ 0 ] - 1 NEW_LINE while curr_ele < n : NEW_LINE INDENT count += 1 NEW_LINE curr_ele -= 1 NEW_LINE DEDENT curr_ele = arr [ 0 ] + 1 NEW_LINE while curr_ele : NEW_LINE INDENT count += 1 NEW_LINE curr_ele += 1 NEW_LINE DEDENT return ( count == len ( us ) ) NEW_LINE DEDENT arr = [ 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 ] NEW_LINE if areElementsContiguous ( arr , len ( arr ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def areElementsContiguous ( arr ) : NEW_LINE INDENT us = set ( ) NEW_LINE for i in arr : us . add ( i ) NEW_LINE count = 1 NEW_LINE curr_ele = arr [ 0 ] - 1 NEW_LINE while curr_ele in us : NEW_LINE INDENT count += 1 NEW_LINE curr_ele -= 1 NEW_LINE DEDENT curr_ele = arr [ 0 ] + 1 NEW_LINE while curr_ele in us : NEW_LINE INDENT count += 1 NEW_LINE curr_ele += 1 NEW_LINE DEDENT return ( count == len ( us ) ) NEW_LINE DEDENT arr = [ 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 ] NEW_LINE if areElementsContiguous ( arr ) : print ( \" Yes \" ) NEW_LINE else : print ( \" No \" ) NEW_LINE"],"bleu":0.7333200032175833,"rouge_l":0.9065366306745618}
{"id":1172,"predictions":["def divomialBinarySearch ( arr , n , key ) : NEW_LINE INDENT pivot = findPivot ( arr , 0 , n - 1 ) NEW_LINE if ( pivot == - 1 ) : NEW_LINE INDENT return binarySearch ( arr , 0 , n - 1 , key ) NEW_LINE DEDENT if ( arr [ pivot ] == key ) : NEW_LINE INDENT return binarySearch ( arr , 0 , n - 1 , key ) NEW_LINE DEDENT return binarySearch ( arr , pivot + 1 , n - 1 , key ) NEW_LINE DEDENT def findPivot ( arr , low , high ) : NEW_LINE INDENT if ( high < low ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( high == low ) : NEW_LINE INDENT return low NEW_LINE DEDENT mid = ( low + high ) \/\/ 2 NEW_LINE if ( mid < high and arr [ mid ] > arr [ mid + 1 ] ) : NEW_LINE INDENT return mid - 1 NEW_LINE DEDENT if ( mid > low and arr [ mid ] < arr [ mid - 1 ] ) : NEW_LINE INDENT return ( mid - 1 ) NEW_LINE DEDENT if ( arr [ low ] >= arr [ mid ] ) : NEW_LINE INDENT return findPivot ( arr , low , mid - 1 ) NEW_LINE DEDENT return findPivot ( arr , mid + 1 , high ) NEW_LINE DEDENT def binarySearch ( arr , low , high , key ) : NEW_LINE INDENT if ( high < low ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( low + high ) \/ 2 NEW_LINE if ( key == arr [ mid ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( key > arr [ mid ] ) : NEW_LINE INDENT return binarySearch ( arr , ( mid + 1 ) , high , key ) NEW_LINE DEDENT return binarySearch ( arr , low , ( mid - 1 ) , key ) NEW_LINE DEDENT arr1 = [ 5 , 6 , 7 , 8 , 9 , 10 , 1 , 2 , 3 ] NEW_LINE n = len ( arr1 ) NEW_LINE key = 3 NEW_LINE print ( \" Index"],"references":["def pivotedBinarySearch ( arr , n , key ) : NEW_LINE INDENT pivot = findPivot ( arr , 0 , n - 1 ) ; NEW_LINE if pivot == - 1 : NEW_LINE INDENT return binarySearch ( arr , 0 , n - 1 , key ) ; NEW_LINE DEDENT if arr [ pivot ] == key : NEW_LINE INDENT return pivot NEW_LINE DEDENT if arr [ 0 ] <= key : NEW_LINE INDENT return binarySearch ( arr , 0 , pivot - 1 , key ) ; NEW_LINE DEDENT return binarySearch ( arr , pivot + 1 , n - 1 , key ) ; NEW_LINE DEDENT def findPivot ( arr , low , high ) : NEW_LINE INDENT if high < low : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if high == low : NEW_LINE INDENT return low NEW_LINE DEDENT mid = int ( ( low + high ) \/ 2 ) NEW_LINE if mid < high and arr [ mid ] > arr [ mid + 1 ] : NEW_LINE INDENT return mid NEW_LINE DEDENT if mid > low and arr [ mid ] < arr [ mid - 1 ] : NEW_LINE INDENT return ( mid - 1 ) NEW_LINE DEDENT if arr [ low ] >= arr [ mid ] : NEW_LINE INDENT return findPivot ( arr , low , mid - 1 ) NEW_LINE DEDENT return findPivot ( arr , mid + 1 , high ) NEW_LINE DEDENT def binarySearch ( arr , low , high , key ) : NEW_LINE INDENT if high < low : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = int ( ( low + high ) \/ 2 ) NEW_LINE if key == arr [ mid ] : NEW_LINE INDENT return mid NEW_LINE DEDENT if key > arr [ mid ] : NEW_LINE INDENT return binarySearch ( arr , ( mid + 1 ) , high , key ) ; NEW_LINE DEDENT return binarySearch ( arr , low , ( mid - 1 ) , key ) ; NEW_LINE DEDENT arr1 = [ 5 , 6 , 7 , 8 , 9 , 10 , 1 , 2 , 3 ] NEW_LINE n = len ( arr1 ) NEW_LINE key = 3 NEW_LINE print ( \" Index ▁ of ▁ the ▁ element ▁ is ▁ : ▁ \" , pivotedBinarySearch ( arr1 , n , key ) ) NEW_LINE"],"bleu":0.7508230562289743,"rouge_l":0.895823772372648}
{"id":1173,"predictions":["def findDandZeroes ( a , b , n ) : NEW_LINE INDENT mpp = { } NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( b [ i ] != 0 and a [ i ] != 0 ) : NEW_LINE INDENT val = ( - 1.0 * b [ i ] ) \/ ( a [ i ] ) NEW_LINE if ( mpp [ val ] ) : NEW_LINE INDENT mpp [ val ] = mpp . get ( val , 0 ) + 1 NEW_LINE DEDENT else : NEW_LINE INDENT mpp [ val ] = 1 NEW_LINE DEDENT DEDENT elif ( b [ i ] == 0 and a [ i ] == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return ( \" The ▁ number ▁ of ▁ zeros ▁ in ▁ array ▁ \" ) NEW_LINE DEDENT a = [ 13 , 37 , 39 ] NEW_LINE b = [ 1 , 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE findDandZeroes ( a , b , n ) NEW_LINE"],"references":["def findDandZeros ( a , b , n ) : NEW_LINE INDENT mpp = { } ; NEW_LINE count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( b [ i ] != 0 and a [ i ] != 0 ) : NEW_LINE INDENT val = ( - 1.0 * b [ i ] ) \/ a [ i ] ; NEW_LINE if val not in mpp : NEW_LINE INDENT mpp [ val ] = 0 ; NEW_LINE DEDENT mpp [ val ] += 1 ; NEW_LINE DEDENT elif ( b [ i ] == 0 and a [ i ] == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT maxi = 0 ; NEW_LINE for item in mpp : NEW_LINE INDENT maxi = max ( mpp [ item ] , maxi ) ; NEW_LINE DEDENT for keys , values in mpp . items ( ) : NEW_LINE INDENT if ( values == maxi ) : NEW_LINE INDENT print ( \" Value ▁ of ▁ d ▁ is : \" , keys ) ; NEW_LINE break ; NEW_LINE DEDENT DEDENT print ( \" The ▁ number ▁ of ▁ zeros ▁ in ▁ array ▁ C ▁ is : \" , maxi + count ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 13 , 37 , 39 ] ; NEW_LINE b = [ 1 , 2 , 3 ] ; NEW_LINE n = len ( a ) ; NEW_LINE findDandZeros ( a , b , n ) ; NEW_LINE DEDENT"],"bleu":0.4757677481108903,"rouge_l":0.6857221194050311}
{"id":1174,"predictions":["def count_odd_even ( n , a ) : NEW_LINE INDENT odd = 0 NEW_LINE even = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] % 2 == 0 ) : NEW_LINE INDENT even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT ans = odd * even * 2 NEW_LINE return ans NEW_LINE DEDENT def count_even_pair_pairs = n , 4 , 5 , 9 , 1 NEW_LINE odd_sum_pairs = count_pairs - odd_sum_pairs NEW_LINE return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 6 NEW_LINE a = [ 2 , 4 , 5 , 9 , 1 , 8 ] NEW_LINE odd_sum_pairs = count_even_pair_pair_pairs NEW_LINE even_sum_pairs = count_even_pairs ( odd_sum_pairs , n ) NEW_LINE print ( \" Even ▁ Sum ▁ Pairs ▁ = ▁ \" , even_sum_pairs ) NEW_LINE print ( \" Odd ▁ Sum ▁ Pairs ▁ = ▁ \" , odd_sum ) NEW_LINE DEDENT"],"references":["def count_odd_pair ( n , a ) : NEW_LINE INDENT odd = 0 NEW_LINE even = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( a [ i ] % 2 == 0 ) : NEW_LINE INDENT even = even + 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd = odd + 1 NEW_LINE DEDENT DEDENT ans = odd * even * 2 NEW_LINE return ans NEW_LINE DEDENT def count_even_pair ( odd_sum_pairs , n ) : NEW_LINE INDENT total_pairs = ( n * ( n - 1 ) ) NEW_LINE ans = total_pairs - odd_sum_pairs NEW_LINE return ans NEW_LINE DEDENT n = 6 NEW_LINE a = [ 2 , 4 , 5 , 9 , 1 , 8 ] NEW_LINE odd_sum_pairs = count_odd_pair ( n , a ) NEW_LINE even_sum_pairs = count_even_pair ( odd_sum_pairs , n ) NEW_LINE print ( \" Even ▁ Sum ▁ Pairs ▁ = \" , even_sum_pairs ) NEW_LINE print ( \" Odd ▁ Sum ▁ Pairs = \" , odd_sum_pairs ) NEW_LINE"],"bleu":0.6892750494528622,"rouge_l":0.7987475092513522}
{"id":1175,"predictions":["def printQueries ( n , a , q , q , q ) : NEW_LINE INDENT occ = dict ( ) NEW_LINE suffixCount = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT occ . append ( a [ i ] ) NEW_LINE suffixCount [ i + 1 ] = len ( occ ) NEW_LINE DEDENT for i in range ( q ) : NEW_LINE INDENT print ( suffixCount [ qry [ i ] ] ) NEW_LINE DEDENT DEDENT n = 5 NEW_LINE q = 3 NEW_LINE a = [ 2 , 4 , 6 , 10 , 2 ] NEW_LINE qx = [ 1 , 3 , 2 ] NEW_LINE printQueries ( n , a , q , qy ) NEW_LINE"],"references":["def printQueries ( n , a , q , qry ) : NEW_LINE INDENT occ = dict ( ) NEW_LINE suffixCount = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT occ [ a [ i ] ] = 1 NEW_LINE suffixCount [ i + 1 ] = len ( occ ) NEW_LINE DEDENT for i in range ( q ) : NEW_LINE INDENT print ( suffixCount [ qry [ i ] ] ) NEW_LINE DEDENT DEDENT n = 5 NEW_LINE q = 3 NEW_LINE a = [ 2 , 4 , 6 , 10 , 2 ] NEW_LINE qry = [ 1 , 3 , 2 ] NEW_LINE printQueries ( n , a , q , qry ) NEW_LINE"],"bleu":0.842184964425589,"rouge_l":0.9181428736829917}
{"id":1176,"predictions":["def countRotations ( n ) : NEW_LINE INDENT l = len ( n ) NEW_LINE if ( l == 1 ) : NEW_LINE INDENT oneDigit = ord ( n [ 0 ] ) - ord ( '0' ) NEW_LINE if ( oneDigit % 4 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT twoDigit = 0 NEW_LINE for i in range ( l - 1 ) : NEW_LINE INDENT twoDigit = ( ord ( n [ i ] ) - 48 ) * 10 + ( ord ( n [ i + 1 ] ) - ord ( '0' ) ) NEW_LINE if ( twoDigit % 4 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT twoDigit = ( ord ( n [ l - 1 ] ) - ord ( '0' ) ) * 10 + ( ord ( n [ 0 ] ) - ord ( '0' ) ) NEW_LINE if ( twoDigit % 4 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT n = \"4834\" NEW_LINE print ( \" Rotations : ▁ \" , countRotations ( n ) ) NEW_LINE"],"references":["def countRotations ( n ) : NEW_LINE INDENT l = len ( n ) NEW_LINE if ( l == 1 ) : NEW_LINE INDENT oneDigit = ( int ) ( n [ 0 ] ) NEW_LINE if ( oneDigit % 4 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 0 , l - 1 ) : NEW_LINE INDENT twoDigit = ( int ) ( n [ i ] ) * 10 + ( int ) ( n [ i + 1 ] ) NEW_LINE if ( twoDigit % 4 == 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT twoDigit = ( int ) ( n [ l - 1 ] ) * 10 + ( int ) ( n [ 0 ] ) NEW_LINE if ( twoDigit % 4 == 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT n = \"4834\" NEW_LINE print ( \" Rotations : ▁ \" , countRotations ( n ) ) NEW_LINE"],"bleu":0.7430727297002955,"rouge_l":0.864351131847244}
{"id":1177,"predictions":["def smallestX ( n ) : NEW_LINE INDENT temp = [ 1 for i in range ( 10 ) ] NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT count = 0 NEW_LINE x = 0 NEW_LINE for x in range ( 1 , 10 ) : NEW_LINE INDENT y = x * n NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( temp [ y % 10 ] == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE temp [ y % 10 ] = 1 NEW_LINE DEDENT y \/\/= 10 NEW_LINE DEDENT DEDENT return x - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( smallestX ( n ) ) NEW_LINE DEDENT"],"references":["def smallestX ( n ) : NEW_LINE INDENT temp = [ 0 ] * 10 NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT count = 0 NEW_LINE x = 1 NEW_LINE while ( count < 10 ) : NEW_LINE INDENT y = x * n NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( temp [ y % 10 ] == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE temp [ y % 10 ] = 1 NEW_LINE DEDENT y = int ( y \/ 10 ) NEW_LINE DEDENT x += 1 NEW_LINE DEDENT return x - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( smallestX ( n ) ) NEW_LINE DEDENT"],"bleu":0.825023090203686,"rouge_l":0.8785405664906386}
{"id":1178,"predictions":["from collections import defaultdict NEW_LINE def distinctAdjacentElement ( a , n ) : NEW_LINE INDENT m = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT m [ a [ i ] ] += 1 NEW_LINE DEDENT m [ a [ i ] ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if m [ a [ i ] ] : NEW_LINE INDENT m [ a [ i ] ] = m [ a [ i ] ] NEW_LINE DEDENT DEDENT if mx > ( ( n + 1 ) \/\/ 2 ) : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 7 , 7 , 7 , 7 ] NEW_LINE n = 4 NEW_LINE distinctAdjacentElement ( a , n ) NEW_LINE DEDENT"],"references":["def distantAdjacentElement ( a , n ) : NEW_LINE INDENT m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] in m : NEW_LINE INDENT m [ a [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ a [ i ] ] = 1 NEW_LINE DEDENT DEDENT mx = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if mx < m [ a [ i ] ] : NEW_LINE INDENT mx = m [ a [ i ] ] NEW_LINE DEDENT DEDENT if mx > ( n + 1 ) \/\/ 2 : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 7 , 7 , 7 , 7 ] NEW_LINE n = len ( a ) NEW_LINE distantAdjacentElement ( a , n ) NEW_LINE DEDENT"],"bleu":0.7537383707584323,"rouge_l":0.8356959375891923}
{"id":1179,"predictions":["def fnMod ( n ) : NEW_LINE INDENT rem = n % 4 ; NEW_LINE if ( rem == 0 or rem == 3 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT elif ( rem == 1 or rem == 2 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT return 0 ; NEW_LINE DEDENT n = 6 ; NEW_LINE print ( fnMod ( n ) ) ; NEW_LINE"],"references":["def fnMod ( n ) : NEW_LINE INDENT rem = n % 4 NEW_LINE if ( rem == 0 or rem == 3 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( rem == 1 or rem == 2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 6 NEW_LINE print ( fnMod ( n ) ) NEW_LINE DEDENT"],"bleu":0.6928729401923556,"rouge_l":0.8361797752808988}
{"id":1180,"predictions":["def isRectangle ( a , b , c , d ) : NEW_LINE INDENT if ( ( a ^ b ^ c ^ d ) != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT a = 3 NEW_LINE b = 2 NEW_LINE c = 3 NEW_LINE d = 2 NEW_LINE if ( isRectangle ( a , b , c , d ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def isRectangle ( a , b , c , d ) : NEW_LINE INDENT if a ^ b ^ c ^ d : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT a , b , c , d = 3 , 2 , 3 , 2 NEW_LINE print ( \" Yes \" if isRectangle ( a , b , c , d ) else \" No \" ) NEW_LINE"],"bleu":0.4807822262985098,"rouge_l":0.7015738498789346}
{"id":1181,"predictions":["def merge ( arr , temp , left , mid , right ) : NEW_LINE INDENT inv_count = 0 NEW_LINE i = left NEW_LINE j = mid NEW_LINE k = left NEW_LINE while ( ( i <= mid - 1 ) and ( j <= right ) ) : NEW_LINE INDENT if ( arr [ i ] <= arr [ j ] ) : NEW_LINE INDENT temp [ k ] = arr [ i ] NEW_LINE k += 1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT temp [ k ] = arr [ j ] NEW_LINE k += 1 NEW_LINE j += 1 NEW_LINE inv_count = inv_count + ( mid - i ) NEW_LINE DEDENT DEDENT while ( i <= mid - 1 ) : NEW_LINE INDENT temp [ k ] = arr [ i ] NEW_LINE i += 1 NEW_LINE k += 1 NEW_LINE DEDENT while ( j <= right ) : NEW_LINE INDENT temp [ k ] = arr [ j ] NEW_LINE k += 1 NEW_LINE j += 1 NEW_LINE DEDENT for i in range ( left , right + 1 ) : NEW_LINE INDENT arr [ i ] = temp [ i ] NEW_LINE DEDENT return inv_count NEW_LINE DEDENT def _mergeSort ( arr , temp , left , right ) : NEW_LINE INDENT inv_count = 0 NEW_LINE if ( right > left ) : NEW_LINE INDENT mid = ( right + left ) \/\/ 2 NEW_LINE inv_count = _mergeSort ( arr , temp , left , mid ) NEW_LINE inv_count += _mergeSort ( arr , temp , mid + 1 , right ) NEW_LINE inv_count += merge ( arr , temp , left , mid + 1 , right ) NEW_LINE DEDENT return inv_count NEW_LINE DEDENT def mergeSort ( arr , temp_size ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] - 1 ) - i > 2 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return _mergeSort ( arr , temp , 0 , array_size - 1 ) NEW_"],"references":["def merge ( arr , temp , left , mid , right ) : NEW_LINE INDENT inv_count = 0 NEW_LINE i = left NEW_LINE j = mid NEW_LINE k = left NEW_LINE while ( i <= mid - 1 ) and ( j <= right ) : NEW_LINE INDENT if arr [ i ] <= arr [ j ] : NEW_LINE INDENT temp [ k ] = arr [ i ] NEW_LINE k , i = k + 1 , i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT temp [ k ] = arr [ j ] NEW_LINE k , j = k + 1 , j + 1 NEW_LINE inv_count = inv_count + ( mid - i ) NEW_LINE DEDENT DEDENT while i <= mid - 1 : NEW_LINE INDENT temp [ k ] = arr [ i ] NEW_LINE k , i = k + 1 , i + 1 NEW_LINE DEDENT while j <= right : NEW_LINE INDENT temp [ k ] = arr [ j ] NEW_LINE k , j = k + 1 , j + 1 NEW_LINE DEDENT for i in range ( left , right + 1 ) : NEW_LINE INDENT arr [ i ] = temp [ i ] NEW_LINE DEDENT return inv_count NEW_LINE DEDENT def _mergeSort ( arr , temp , left , right ) : NEW_LINE INDENT inv_count = 0 NEW_LINE if right > left : NEW_LINE INDENT mid = ( right + left ) \/\/ 2 NEW_LINE inv_count = _mergeSort ( arr , temp , left , mid ) NEW_LINE inv_count += _mergeSort ( arr , temp , mid + 1 , right ) NEW_LINE inv_count += merge ( arr , temp , left , mid + 1 , right ) NEW_LINE DEDENT return inv_count NEW_LINE DEDENT def mergeSort ( arr , array_size ) : NEW_LINE INDENT temp = [ None ] * array_size NEW_LINE return _mergeSort ( arr , temp , 0 , array_size - 1 ) NEW_LINE DEDENT def minSwapToReachArr ( arr , N ) : NEW_LINE INDENT for i in range ( 0 , N ) : NEW_LINE INDENT if ( arr [ i ] - 1 ) - i > 2 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT numOfInversion = mergeSort ( arr , N ) NEW_LINE return numOfInversion NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 5 , 3 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE res = minSwapToReachArr ( arr , N ) NEW_LINE if res == - 1 : NEW_LINE INDENT print ( \" Not ▁ Possible \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res ) NEW_LINE DEDENT DEDENT"],"bleu":0.6266791374223071,"rouge_l":0.767869084615082}
{"id":1182,"predictions":["import math NEW_LINE def Prime ( n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , mt . ceil ( mt . sqrt ( n ) ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def primeCountDivisors ( n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT a = n NEW_LINE c = c + 1 NEW_LINE DEDENT DEDENT if ( a == 1 and Prime ( c + 1 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT n = 13 NEW_LINE if ( primeCountDivisors ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["from math import sqrt NEW_LINE def Prime ( n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT for i in range ( 2 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT def primeCountDivisors ( n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT for i in range ( 2 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT a = n ; c = 0 ; NEW_LINE while ( a % i == 0 ) : NEW_LINE INDENT a \/\/= i ; NEW_LINE c += 1 ; NEW_LINE DEDENT if ( a == 1 and Prime ( c + 1 ) ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT DEDENT return True ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 13 ; NEW_LINE if ( primeCountDivisors ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"],"bleu":0.6623061087153941,"rouge_l":0.8431732960811705}
{"id":1183,"predictions":["def countSubSeq ( a , n , k ) : NEW_LINE INDENT a . sort ( ) ; NEW_LINE arr = [ ] ; NEW_LINE i = 0 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT count = 1 ; NEW_LINE x = a [ i ] ; NEW_LINE i += 1 ; NEW_LINE DEDENT arr . append ( count ) ; NEW_LINE n = min ( m , k ) ; NEW_LINE count = 1 ; NEW_LINE dp = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ] ; NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( m - i , - 1 , - 1 ) : NEW_LINE INDENT if ( j > m - i ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i ] [ j + 1 ] + arr [ j ] * dp [ i - 1 ] [ j + 1 ] ) ; NEW_LINE DEDENT DEDENT count = count + dp [ i ] [ 0 ] ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 2 , 2 , 3 , 3 , 5 ] ; NEW_LINE n = len ( a ) ; NEW_LINE k = 3 ; NEW_LINE print ( countSubSeq ( a , n , k ) ) ; NEW_LINE DEDENT"],"references":["def countSubSeq ( a , n , k ) : NEW_LINE INDENT a . sort ( reverse = False ) NEW_LINE arr = [ ] NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT count = 1 NEW_LINE x = a [ i ] NEW_LINE i += 1 NEW_LINE while ( i < n and a [ i ] == x ) : NEW_LINE INDENT count += 1 NEW_LINE i += 1 NEW_LINE DEDENT arr . append ( count ) NEW_LINE DEDENT m = len ( arr ) NEW_LINE n = min ( m , k ) NEW_LINE count = 1 NEW_LINE dp = [ [ 0 for i in range ( m + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT j = m NEW_LINE while ( j >= 0 ) : NEW_LINE INDENT if ( j > m - i ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j + 1 ] +   \\ NEW_LINE INDENT arr [ j ] * dp [ i - 1 ] [ j + 1 ] NEW_LINE DEDENT DEDENT j -= 1 NEW_LINE DEDENT count = count + dp [ i ] [ 0 ] NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 2 , 2 , 3 , 3 , 5 ] NEW_LINE n = len ( a ) NEW_LINE k = 3 NEW_LINE print ( countSubSeq ( a , n , k ) ) NEW_LINE DEDENT"],"bleu":0.6287603629868533,"rouge_l":0.8117684784351453}
{"id":1184,"predictions":["def isVowel ( ch ) : NEW_LINE INDENT if ch in [ ' a ' , ' e ' , ' i ' , ' o ' , ' u ' ] : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def isSuffllel ( strr , n ) : NEW_LINE INDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( isVowel ( strr [ i ] ) and isVowel ( strr [ i - 1 ] ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( isVowel ( str [ i ] ) and isVowel ( str [ i - 1 ] ) and isVowel ( strr [ i + 1 ] ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT strr = \" acaba \" NEW_LINE n = len ( strr ) NEW_LINE if ( isSuffied ( strr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def isVowel ( ch ) : NEW_LINE INDENT if ch in [ ' i ' , ' a ' , ' e ' , ' o ' , ' u ' ] : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def isSatisfied ( st , n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( isVowel ( st [ i ] ) == False and isVowel ( st [ i - 1 ] ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( isVowel ( st [ i ] ) and isVowel ( st [ i - 1 ] ) == False and isVowel ( st [ i + 1 ] ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT st = \" acaba \" NEW_LINE n = len ( st ) NEW_LINE if ( isSatisfied ( st , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.7502308340279455,"rouge_l":0.8889248704663213}
{"id":1185,"predictions":["def equal_xor_sum ( arr , n ) : NEW_LINE INDENT Sum = 0 ; Xor = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum = Sum + arr [ i ] ; NEW_LINE Xor = Xor ^ arr [ i ] ; NEW_LINE DEDENT if ( Sum == Xor ) : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE DEDENT DEDENT arr = [ 6 , 3 , 7 , 10 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE equal_xor_sum ( arr , n ) ; NEW_LINE"],"references":["def equal_xor_sum ( arr , n ) : NEW_LINE INDENT Sum = 0 ; NEW_LINE Xor = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum = Sum + arr [ i ] ; NEW_LINE Xor = Xor ^ arr [ i ] ; NEW_LINE DEDENT if ( Sum == Xor ) : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 6 , 3 , 7 , 10 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE equal_xor_sum ( arr , n ) ; NEW_LINE DEDENT"],"bleu":0.8495098385788161,"rouge_l":0.9261386951169471}
{"id":1186,"predictions":["import sys NEW_LINE def getMinLength ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE result = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( count != 0 ) : NEW_LINE INDENT result = min ( result , count ) NEW_LINE DEDENT count = 0 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 1 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( getMinLength ( arr , n ) ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE def getMinLength ( arr , n ) : NEW_LINE INDENT count = 0 ; NEW_LINE result = sys . maxsize ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( count != 0 ) : NEW_LINE INDENT result = min ( result , count ) ; NEW_LINE DEDENT count = 0 ; NEW_LINE DEDENT DEDENT return result ; NEW_LINE DEDENT arr = [ 1 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 1 , 1 , 1 , 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( getMinLength ( arr , n ) ) ; NEW_LINE"],"bleu":0.7582196660485893,"rouge_l":0.9027033325565136}
{"id":1187,"predictions":["def isPowerOfTwo ( n ) : NEW_LINE INDENT return ( n and ( not ( n & ( n - 1 ) ) ) ) NEW_LINE DEDENT def findPosition ( n ) : NEW_LINE INDENT if ( not isPowerOfTwo ( n ) ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT i = 1 NEW_LINE pos = 1 NEW_LINE while ( ( i & n ) ) : NEW_LINE INDENT i = i << 1 NEW_LINE pos += 1 NEW_LINE DEDENT return pos NEW_LINE DEDENT n = 16 NEW_LINE pos = findPosition ( n ) NEW_LINE if ( pos == - 1 ) : NEW_LINE INDENT print ( \" n ▁ = \" , n , \" Invalid ▁ number \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" n ▁ = \" , n , \" Position \" , pos ) NEW_LINE DEDENT n = 12 NEW_LINE pos = findPosition ( n ) NEW_LINE if ( pos == - 1 ) : NEW_LINE INDENT print ( \" n ▁ = \" , n , \" Invalid ▁ number \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" n ▁ = \" , n , \" Position \" , pos ) NEW_LINE DEDENT n = 128 NEW_LINE pos = findPosition ( n ) NEW_LINE if ( pos == - 1 ) : NEW_LINE INDENT print ( \" n ▁ = \" , n , \" Invalid ▁ number \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" n ▁ = \" , n , \" Position \" , pos ) NEW_LINE DEDENT DEDENT"],"references":["def isPowerOfTwo ( n ) : NEW_LINE INDENT return ( True if ( n > 0 and ( ( n & ( n - 1 ) ) > 0 ) ) else False ) ; NEW_LINE DEDENT def findPosition ( n ) : NEW_LINE INDENT if ( isPowerOfTwo ( n ) == True ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT i = 1 ; NEW_LINE pos = 1 ; NEW_LINE while ( ( i & n ) == 0 ) : NEW_LINE INDENT i = i << 1 ; NEW_LINE pos += 1 ; NEW_LINE DEDENT return pos ; NEW_LINE DEDENT n = 16 ; NEW_LINE pos = findPosition ( n ) ; NEW_LINE if ( pos == - 1 ) : NEW_LINE INDENT print ( \" n ▁ = \" , n , \" , ▁ Invalid ▁ number \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" n ▁ = \" , n , \" , ▁ Position ▁ \" , pos ) ; NEW_LINE DEDENT n = 12 ; NEW_LINE pos = findPosition ( n ) ; NEW_LINE if ( pos == - 1 ) : NEW_LINE INDENT print ( \" n ▁ = \" , n , \" , ▁ Invalid ▁ number \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" n ▁ = \" , n , \" , ▁ Position ▁ \" , pos ) ; NEW_LINE DEDENT n = 128 ; NEW_LINE pos = findPosition ( n ) ; NEW_LINE if ( pos == - 1 ) : NEW_LINE INDENT print ( \" n ▁ = \" , n , \" , ▁ Invalid ▁ number \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" n ▁ = \" , n , \" , ▁ Position ▁ \" , pos ) ; NEW_LINE DEDENT"],"bleu":0.6741139165013869,"rouge_l":0.8999944533806644}
{"id":1188,"predictions":["def totalNumber ( n ) : NEW_LINE INDENT return 8 * pow ( 9 , n - 1 ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 ; NEW_LINE print ( totalNumber ( n ) ) ; NEW_LINE DEDENT"],"references":["def totalNumber ( n ) : NEW_LINE INDENT return 8 * pow ( 9 , n - 1 ) ; NEW_LINE DEDENT n = 3 NEW_LINE print ( totalNumber ( n ) ) NEW_LINE"],"bleu":0.5965372531286091,"rouge_l":0.8383185125303153}
{"id":1189,"predictions":["rev_num = 0 NEW_LINE base_pos = 1 NEW_LINE def reversDigits ( num ) : NEW_LINE INDENT global rev_num NEW_LINE global base_pos NEW_LINE if ( num > 0 ) : NEW_LINE INDENT reversDigits ( ( int ) ( num \/ 10 ) ) NEW_LINE rev_num += ( num % 10 ) * base_pos NEW_LINE base_pos *= 10 NEW_LINE DEDENT return rev_num NEW_LINE DEDENT num = 4562 NEW_LINE print ( \" Reverse ▁ of ▁ no . ▁ is ▁ \" , reversDigits ( num ) ) NEW_LINE"],"references":["rev_num = 0 NEW_LINE base_pos = 1 NEW_LINE def reversDigits ( num ) : NEW_LINE INDENT global rev_num NEW_LINE global base_pos NEW_LINE if ( num > 0 ) : NEW_LINE INDENT reversDigits ( ( int ) ( num \/ 10 ) ) NEW_LINE rev_num += ( num % 10 ) * base_pos NEW_LINE base_pos *= 10 NEW_LINE DEDENT return rev_num NEW_LINE DEDENT num = 4562 NEW_LINE print ( \" Reverse ▁ of ▁ no . ▁ is ▁ \" , reversDigits ( num ) ) NEW_LINE"],"bleu":1.0,"rouge_l":1.0}
{"id":1190,"predictions":["def check ( s ) : NEW_LINE l = len ( s ) NEW_LINE if ( check ( s ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT s . sort ( ) NEW_LINE for i in range ( 1 , l ) : NEW_LINE INDENT if ( s [ i ] - s [ i - 1 ] != 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT st = \" dcef \" NEW_LINE if ( check ( st ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def check ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE s = ' ' . join ( sorted ( s ) ) NEW_LINE for i in range ( 1 , l ) : NEW_LINE INDENT if ord ( s [ i ] ) - ord ( s [ i - 1 ] ) != 1 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" dcef \" NEW_LINE if check ( string ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT string = \" xyza \" NEW_LINE if check ( string ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.5965310242985293,"rouge_l":0.7480333179083758}
{"id":1191,"predictions":["def maxBrions ( n ) : NEW_LINE INDENT num = n * ( n + 1 ) \/\/ 2 + 1 NEW_LINE print ( num ) NEW_LINE DEDENT n = 10 NEW_LINE maxHistions ( n ) NEW_LINE"],"references":["def maxRegions ( n ) : NEW_LINE INDENT num = n * ( n + 1 ) \/\/ 2 + 1 NEW_LINE print ( num ) NEW_LINE DEDENT n = 10 NEW_LINE maxRegions ( n ) NEW_LINE"],"bleu":0.8811605932412903,"rouge_l":0.9459459459459459}
{"id":1192,"predictions":["def bestMaxSolution ( x , y ) : NEW_LINE INDENT n = len ( x ) NEW_LINE mx = 0 NEW_LINE sum_xy = 0 NEW_LINE sum_x = 0 NEW_LINE sum_x2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum_x += x [ i ] NEW_LINE sum_xy += x [ i ] * y [ i ] NEW_LINE sum_x2 += x [ i ] * y [ i ] NEW_LINE DEDENT m = ( n * sum_xy - sum_x * sum_y ) \/ n NEW_LINE c = ( sum_y - m * sum_x ) \/ n NEW_LINE print ( \" m ▁ = ▁ \" , m ) NEW_LINE print ( \" c ▁ = ▁ \" , m ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE y = [ 14 , 27 , 40 , 55 , 68 ] NEW_LINE bestEnd = ( ( x , y ) ) NEW_LINE DEDENT"],"references":["def bestApproximate ( x , y , n ) : NEW_LINE INDENT sum_x = 0 NEW_LINE sum_y = 0 NEW_LINE sum_xy = 0 NEW_LINE sum_x2 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum_x += x [ i ] NEW_LINE sum_y += y [ i ] NEW_LINE sum_xy += x [ i ] * y [ i ] NEW_LINE sum_x2 += pow ( x [ i ] , 2 ) NEW_LINE DEDENT m = ( float ) ( ( n * sum_xy - sum_x * sum_y ) \/ ( n * sum_x2 - pow ( sum_x , 2 ) ) ) ; NEW_LINE c = ( float ) ( sum_y - m * sum_x ) \/ n ; NEW_LINE print ( \" m ▁ = ▁ \" , m ) ; NEW_LINE print ( \" c ▁ = ▁ \" , c ) ; NEW_LINE DEDENT x = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE y = [ 14 , 27 , 40 , 55 , 68 ] NEW_LINE n = len ( x ) NEW_LINE bestApproximate ( x , y , n ) NEW_LINE"],"bleu":0.6635608316548258,"rouge_l":0.7663316582914572}
{"id":1193,"predictions":["import sys NEW_LINE def printPrevGreater ( arr , n ) : NEW_LINE INDENT ts = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT c = rs . floor ( arr [ i ] ) NEW_LINE if ( c == None ) : NEW_LINE INDENT print ( - 1 , end = \" ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( c , end = \" ▁ \" ) NEW_LINE DEDENT ts . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 10 , 5 , 11 , 10 , 20 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE printPrevGreater ( arr , n ) NEW_LINE DEDENT"],"references":["def printPrevGreater ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT it = [ x for x in s if x >= arr [ i ] ] NEW_LINE if len ( it ) == 0 : NEW_LINE INDENT print ( \" - 1\" , end = \" ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( min ( it ) , end = \" ▁ \" ) NEW_LINE DEDENT s . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 10 , 5 , 11 , 10 , 20 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE printPrevGreater ( arr , n ) NEW_LINE DEDENT"],"bleu":0.7219865781769916,"rouge_l":0.8481130973244537}
{"id":1194,"predictions":["from math import sqrt NEW_LINE MAX = 1000005 NEW_LINE prime = [ True ] * MAX NEW_LINE def vecIni ( ) : NEW_LINE INDENT for i in range ( MAX ) : NEW_LINE INDENT prime [ i ] = True NEW_LINE DEDENT DEDENT def seive ( N ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT j = 2 NEW_LINE while ( i * j <= N ) : NEW_LINE INDENT prime [ i * j ] = False NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT def countLogNeeded ( N ) : NEW_LINE INDENT count = 0 NEW_LINE seive ( N ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT vecIni ( ) NEW_LINE N = 6 NEW_LINE print ( countLogNeeded ( N ) ) NEW_LINE"],"references":["MAX = 1000005 NEW_LINE prime = [ True for i in range ( MAX ) ] NEW_LINE def seive ( N ) : NEW_LINE INDENT prime [ 0 ] , prime [ 1 ] = False , False NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT for j in range ( 2 , N + 1 ) : NEW_LINE INDENT if ( i * j > N ) : NEW_LINE INDENT break NEW_LINE DEDENT prime [ i * j ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def countLogNeeded ( N ) : NEW_LINE INDENT count = 0 NEW_LINE seive ( N ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 6 NEW_LINE print ( countLogNeeded ( N ) ) NEW_LINE DEDENT"],"bleu":0.7193862739544669,"rouge_l":0.7997873848334516}
{"id":1195,"predictions":["def findMinimumOperation ( n , d , array ) : NEW_LINE INDENT cnt = 0 NEW_LINE first = - 10 ** 9 NEW_LINE end = + 1 NEW_LINE while n > 0 : NEW_LINE INDENT arr = [ array [ cnt ] [ 0 ] , array [ cnt ] [ 1 ] NEW_LINE arr . sort ( ) NEW_LINE first = max ( first , arr [ 0 ] ) NEW_LINE end = min ( end , arr [ 1 ] ) NEW_LINE cnt += 1 NEW_LINE n -= 1 NEW_LINE DEDENT if first > end : NEW_LINE INDENT print ( \" - 1\" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT if d >= first and d <= end : NEW_LINE INDENT print ( \"0\" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( min ( abs ( first - d ) , abs ( d - end ) ) ) NEW_LINE DEDENT DEDENT DEDENT n = 3 NEW_LINE d = 3 NEW_LINE array = [ [ 0 , 7 ] , [ 2 , 14 ] , [ 4 , 6 ] ] NEW_LINE findMinimumOperation ( n , d , array ) NEW_LINE"],"references":["def findMinimumOperation ( n , d , arrays ) : NEW_LINE INDENT cnt = 0 NEW_LINE first = - 10 ** 9 NEW_LINE end = 10 ** 9 NEW_LINE while ( n ) : NEW_LINE INDENT arr = [ arrays [ cnt ] [ 0 ] , arrays [ cnt ] [ 1 ] ] NEW_LINE arr = sorted ( arr ) NEW_LINE first = max ( first , arr [ 0 ] ) NEW_LINE end = min ( end , arr [ 1 ] ) NEW_LINE cnt += 1 NEW_LINE n -= 1 NEW_LINE DEDENT if ( first > end ) : NEW_LINE INDENT print ( \" - 1\" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( d >= first and d <= end ) : NEW_LINE INDENT print ( \"0\" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( min ( abs ( first - d ) , abs ( d - end ) ) , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE d = 3 NEW_LINE arrays = [ [ 0 , 7 ] , [ 2 , 14 ] , [ 4 , 6 ] ] NEW_LINE findMinimumOperation ( n , d , arrays ) NEW_LINE DEDENT"],"bleu":0.7316270648956998,"rouge_l":0.8804404434193883}
{"id":1196,"predictions":["MAX = 90 ; NEW_LINE index1 = [ 0 ] * MAX ; NEW_LINE index2 = [ 0 ] * MAX ; NEW_LINE arr [ 0 ] = 0 ; NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] + arr [ i - 2 ] ; NEW_LINE DEDENT c1 = 0 ; NEW_LINE c2 = 0 ; NEW_LINE c4 = 0 ; NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT index1 += 1 ; NEW_LINE DEDENT if ( arr [ i ] % 3 == 0 ) : NEW_LINE INDENT index2 += 1 ; NEW_LINE c2 += 1 ; NEW_LINE DEDENT if ( arr [ i ] % 5 == 0 ) : NEW_LINE INDENT index2 += 1 ; NEW_LINE c3 += 1 ; NEW_LINE DEDENT if ( arr [ i ] % 8 == 0 ) : NEW_LINE INDENT index4 += 1 ; NEW_LINE DEDENT if ( arr [ i ] % 8 == 0 ) : NEW_LINE INDENT index4 += 1 ; NEW_LINE DEDENT DEDENT print ( \" Index ▁ of ▁ Fibonacci ▁ numbers ▁ by \" , \" ▁ 2 ▁ are \" ) ; NEW_LINE for i in range ( c1 ) : NEW_LINE INDENT print ( index1 [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( \" Index ▁ of ▁ Fibonacci ▁ number ▁ are \" ) ; NEW_LINE for i in range ( c1 ) : NEW_LINE INDENT print ( index1 [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( \" Index ▁ of ▁ Fibonacci ▁ number ▁ are ▁ \" ) ; NEW_LINE for i in range ( c2 ) : NEW_LINE INDENT print ( index2 [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( \" Index ▁ of ▁ Fibonacci ▁ number ▁ are ▁ \" ) ; NEW_LINE DEDENT"],"references":["MAX = 90 ; NEW_LINE arr = [ 0 ] * ( MAX ) ; NEW_LINE index1 = [ 0 ] * ( MAX ) ; NEW_LINE index2 = [ 0 ] * ( MAX ) ; NEW_LINE index3 = [ 0 ] * ( MAX ) ; NEW_LINE index4 = [ 0 ] * ( MAX ) ; NEW_LINE arr [ 0 ] = 0 ; NEW_LINE arr [ 1 ] = 1 ; NEW_LINE for i in range ( 2 , MAX ) : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] + arr [ i - 2 ] ; NEW_LINE DEDENT c1 , c2 , c3 , c4 = 0 , 0 , 0 , 0 ; NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT index1 [ c1 ] = i ; NEW_LINE c1 += 1 ; NEW_LINE DEDENT if ( arr [ i ] % 3 == 0 ) : NEW_LINE INDENT index2 [ c2 ] = i ; NEW_LINE c2 += 1 ; NEW_LINE DEDENT if ( arr [ i ] % 5 == 0 ) : NEW_LINE INDENT index3 [ c3 ] = i ; NEW_LINE c3 += 1 ; NEW_LINE DEDENT if ( arr [ i ] % 8 == 0 ) : NEW_LINE INDENT index4 [ c4 ] = i ; NEW_LINE c4 += 1 ; NEW_LINE DEDENT DEDENT print ( \" Index ▁ of ▁ Fibonacci ▁ numbers \" , \" divisible ▁ by ▁ 2 ▁ are ▁ : \" ) ; NEW_LINE for i in range ( c1 ) : NEW_LINE INDENT print ( index1 [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( \" \" ) ; NEW_LINE print ( \" Index ▁ of ▁ Fibonacci ▁ number \" , \" divisible ▁ by ▁ 3 ▁ are ▁ : \" ) ; NEW_LINE for i in range ( c2 ) : NEW_LINE INDENT print ( index2 [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( \" \" ) ; NEW_LINE print ( \" Index ▁ of ▁ Fibonacci ▁ number \" , \" divisible ▁ by ▁ 5 ▁ are ▁ : \" ) ; NEW_LINE for i in range ( c3 ) : NEW_LINE INDENT print ( index3 [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( \" \" ) ; NEW_LINE print ( \" Index ▁ of ▁ Fibonacci ▁ number \" , \" divisible ▁ by ▁ 8 ▁ are ▁ : \" ) ; NEW_LINE for i in range ( c4 ) : NEW_LINE INDENT print ( index4 [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( \" \" ) ; NEW_LINE"],"bleu":0.5677009085135684,"rouge_l":0.7307897748950782}
{"id":1197,"predictions":["def check ( s ) : NEW_LINE INDENT freq = [ 0 ] * 26 NEW_LINE n = len ( s ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - 97 ] += 1 NEW_LINE DEDENT for i in range ( len ( freq ) ) : NEW_LINE INDENT if ( freq [ i ] & 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" abaccaba \" NEW_LINE if ( check ( s ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def check ( s ) : NEW_LINE INDENT freq = [ 0 ] * 26 NEW_LINE n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - 97 ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( freq [ i ] % 2 == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT s = \" abaccaba \" NEW_LINE if ( check ( s ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.7809472743228717,"rouge_l":0.9012813807531381}
{"id":1198,"predictions":["def getMinMax ( arr ) : NEW_LINE INDENT mx = [ ] NEW_LINE mn = len ( arr ) NEW_LINE mx = max ( arr ) NEW_LINE if ( low == high ) : NEW_LINE INDENT mx = max ( arr [ low ] , arr [ low ] ) NEW_LINE mn = min ( arr [ low ] , arr [ low ] ) NEW_LINE return minmax NEW_LINE DEDENT if ( high == low + 1 ) : NEW_LINE INDENT if ( arr [ low ] > arr [ high ] ) : NEW_LINE INDENT mx = max ( arr [ low ] , arr [ high ] ) NEW_LINE mn = min ( arr [ low ] , arr [ low ] ) NEW_LINE DEDENT else : NEW_LINE INDENT mx = max ( arr [ high ] , arr [ low ] ) NEW_LINE DEDENT return minx NEW_LINE DEDENT mid = ( low + high ) \/\/ 2 NEW_LINE mn = getMinMax ( arr , low , mid ) NEW_LINE mn = getMinMax ( arr , low , mid ) NEW_LINE if ( mn < mn ) : NEW_LINE INDENT mn = mn [ mn ] NEW_LINE DEDENT else : NEW_LINE INDENT mnmax = mm . max NEW_LINE DEDENT if ( mx > mmn ) : NEW_LINE INDENT mn = mnmax NEW_LINE DEDENT return mn NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1000 , 11 , 445 , 1 , 330 , 3000 ] NEW_LINE mx = getMinMax ( arr , 0 , arr_size - 1 ) NEW_LINE print ( \" Minimum ▁ element ▁ is \" , mx ) NEW_LINE DEDENT"],"references":["def getMinMax ( low , high , arr ) : NEW_LINE INDENT arr_max = arr [ low ] NEW_LINE arr_min = arr [ low ] NEW_LINE if low == high : NEW_LINE INDENT arr_max = arr [ low ] NEW_LINE arr_min = arr [ low ] NEW_LINE return ( arr_max , arr_min ) NEW_LINE DEDENT elif high == low + 1 : NEW_LINE INDENT if arr [ low ] > arr [ high ] : NEW_LINE INDENT arr_max = arr [ low ] NEW_LINE arr_min = arr [ high ] NEW_LINE DEDENT else : NEW_LINE INDENT arr_max = arr [ high ] NEW_LINE arr_min = arr [ low ] NEW_LINE DEDENT return ( arr_max , arr_min ) NEW_LINE DEDENT else : NEW_LINE INDENT mid = int ( ( low + high ) \/ 2 ) NEW_LINE arr_max1 , arr_min1 = getMinMax ( low , mid , arr ) NEW_LINE arr_max2 , arr_min2 = getMinMax ( mid + 1 , high , arr ) NEW_LINE DEDENT return ( max ( arr_max1 , arr_max2 ) , min ( arr_min1 , arr_min2 ) ) NEW_LINE DEDENT arr = [ 1000 , 11 , 445 , 1 , 330 , 3000 ] NEW_LINE high = len ( arr ) - 1 NEW_LINE low = 0 NEW_LINE arr_max , arr_min = getMinMax ( low , high , arr ) NEW_LINE print ( ' Minimum ▁ element ▁ is ▁ ' , arr_min ) NEW_LINE print ( ' nMaximum ▁ element ▁ is ▁ ' , arr_max ) NEW_LINE"],"bleu":0.3557764934611855,"rouge_l":0.5674243824308507}
{"id":1199,"predictions":["from queue import Queue NEW_LINE def countUnvisited ( n , m ) : NEW_LINE INDENT X = ( m * n ) - m - n NEW_LINE q = Queue ( ) NEW_LINE count = 0 NEW_LINE while ( not q . empty ( ) ) : NEW_LINE INDENT curr = q . queue [ 0 ] NEW_LINE count += 1 NEW_LINE if ( curr - m > 0 ) : NEW_LINE INDENT q . put ( curr - m ) NEW_LINE DEDENT if ( curr - n > 0 ) : NEW_LINE INDENT Queue . put ( curr - m ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT n = 2 NEW_LINE m = 5 NEW_LINE print ( countUnvisited ( n , m ) ) NEW_LINE"],"references":["def countUnvisited ( n , m ) : NEW_LINE INDENT i = 0 NEW_LINE X = ( m * n ) - m - n NEW_LINE queue = [ ] NEW_LINE queue . append ( X ) NEW_LINE count = 0 NEW_LINE while ( len ( queue ) > 0 ) : NEW_LINE INDENT curr = queue [ 0 ] NEW_LINE queue . remove ( queue [ 0 ] ) NEW_LINE count += 1 NEW_LINE if ( curr - m > 0 ) : NEW_LINE INDENT queue . append ( curr - m ) NEW_LINE DEDENT if ( curr - n > 0 ) : NEW_LINE INDENT queue . append ( curr - n ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 2 NEW_LINE m = 5 NEW_LINE print ( countUnvisited ( n , m ) ) NEW_LINE DEDENT"],"bleu":0.5826037508534286,"rouge_l":0.769583667851818}
{"id":1200,"predictions":["def uppercasingAlphets ( ) : NEW_LINE INDENT for c in range ( 65 , 90 ) : NEW_LINE INDENT print ( c , end = \" ▁ \" ) NEW_LINE DEDENT print ( \" \" ) NEW_LINE DEDENT def lowerCaseAlphabets ( ) : NEW_LINE INDENT for c in range ( 97 , 122 ) : NEW_LINE INDENT print ( \" ▁ \" , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( \" Uppercase ▁ Alphabets \" ) NEW_LINE lower_upperAlphabets ( ) NEW_LINE print ( \" Lower ▁ Alphabets \" ) NEW_LINE lower_caseAlphabets ( ) NEW_LINE DEDENT"],"references":["def lowercaseAlphabets ( ) : NEW_LINE INDENT for c in range ( 97 , 123 ) : NEW_LINE INDENT print ( chr ( c ) , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( \" \" ) ; NEW_LINE DEDENT def uppercaseAlphabets ( ) : NEW_LINE INDENT for c in range ( 65 , 91 ) : NEW_LINE INDENT print ( chr ( c ) , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( \" \" ) ; NEW_LINE DEDENT print ( \" Uppercase ▁ Alphabets \" ) ; NEW_LINE uppercaseAlphabets ( ) ; NEW_LINE print ( \" Lowercase ▁ Alphabets ▁ \" ) ; NEW_LINE lowercaseAlphabets ( ) ; NEW_LINE"],"bleu":0.5416113279952423,"rouge_l":0.7660505150275151}
{"id":1201,"predictions":["import math as mt NEW_LINE def countNums ( a , b , c , d ) : NEW_LINE INDENT x = b \/\/ c - ( a - 1 ) \/\/ c NEW_LINE y = b \/\/ d - ( a - 1 ) \/\/ d NEW_LINE k = ( c * d ) \/\/ gcd ( c , d ) NEW_LINE z = b \/\/ k - ( a - 1 ) \/\/ k NEW_LINE return b - a + 1 - x - y + z NEW_LINE DEDENT a , b , c , d = 10 , 50 , 4 , 6 NEW_LINE print ( countNums ( a , b , c , d ) ) NEW_LINE"],"references":["from math import gcd NEW_LINE def countNums ( a , b , c , d ) : NEW_LINE INDENT x = b \/\/ c - ( a - 1 ) \/\/ c ; NEW_LINE y = b \/\/ d - ( a - 1 ) \/\/ d ; NEW_LINE k = ( c * d ) \/\/ gcd ( c , d ) ; NEW_LINE z = b \/\/ k - ( a - 1 ) \/\/ k ; NEW_LINE return ( b - a + 1 - x - y + z ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 10 ; b = 50 ; c = 4 ; d = 6 ; NEW_LINE print ( countNums ( a , b , c , d ) ) ; NEW_LINE DEDENT"],"bleu":0.6366098360527447,"rouge_l":0.8085419734904271}
{"id":1202,"predictions":["def countSubarrays ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if ( sum + arr [ j ] < k ) : NEW_LINE INDENT sum = arr [ j ] + sum NEW_LINE count = count + 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT array = [ 1 , 11 , 2 , 3 , 15 ] NEW_LINE k = 10 NEW_LINE size = len ( array ) NEW_LINE print ( count ) NEW_LINE DEDENT"],"references":["def countSubarray ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if ( sum + arr [ j ] < k ) : NEW_LINE INDENT sum = arr [ j ] + sum NEW_LINE count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT array = [ 1 , 11 , 2 , 3 , 15 ] NEW_LINE k = 10 NEW_LINE size = len ( array ) NEW_LINE count = countSubarray ( array , size , k ) ; NEW_LINE print ( count ) NEW_LINE"],"bleu":0.7988587447587867,"rouge_l":0.8604651162790695}
{"id":1203,"predictions":["def printPattern ( n ) : NEW_LINE INDENT if n == 0 or n < 0 : NEW_LINE INDENT print ( n , end = \" ▁ \" ) ; NEW_LINE return ; NEW_LINE DEDENT print ( n , end = \" ▁ \" ) ; NEW_LINE printPattern ( n - 5 ) ; NEW_LINE print ( n , end = \" ▁ \" ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 16 ; NEW_LINE printPattern ( n ) ; NEW_LINE DEDENT"],"references":["def printPattern ( n ) : NEW_LINE INDENT if ( n == 0 or n < 0 ) : NEW_LINE INDENT print ( n , end = \" , ▁ \" ) NEW_LINE return NEW_LINE DEDENT print ( n , end = \" , ▁ \" ) NEW_LINE printPattern ( n - 5 ) NEW_LINE print ( n , end = \" , ▁ \" ) NEW_LINE DEDENT n = 16 NEW_LINE printPattern ( n ) NEW_LINE"],"bleu":0.5548047638396839,"rouge_l":0.8616833431430253}
{"id":1204,"predictions":["MAX = 100 NEW_LINE def countCommon ( mat , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT mat = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE print ( countCommon ( mat , 3 ) ) NEW_LINE DEDENT"],"references":["Max = 100 NEW_LINE def countCommon ( mat , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] : NEW_LINE INDENT res = res + 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT mat = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE print ( countCommon ( mat , 3 ) ) NEW_LINE"],"bleu":0.7889194551147446,"rouge_l":0.908769774228229}
{"id":1205,"predictions":["import sys NEW_LINE def getMinimumOps ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE small = min ( arr ) NEW_LINE largest = max ( arr ) NEW_LINE dp = [ [ 0 for i in range ( size + 1 ) ] for j in range ( n ) ] NEW_LINE for i in range ( small , n ) : NEW_LINE INDENT dp [ 0 ] [ j ] = abs ( arr [ 0 ] - j ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT minimum = 10 ** 9 NEW_LINE for j in range ( small , largest + 1 ) : NEW_LINE INDENT minimum = min ( minimum , dp [ i - 1 ] [ j ] ) NEW_LINE dp [ i ] [ j ] = minimum + abs ( arr [ i ] - j ) NEW_LINE DEDENT DEDENT ans = 10 ** 9 NEW_LINE for j in range ( small , high + 1 ) : NEW_LINE INDENT ans = min ( ans , dp [ n - 1 ] [ j ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 1 , 4 , 3 ] NEW_LINE print ( getMinimumOps ( arr ) ) NEW_LINE DEDENT"],"references":["def getMinimumOps ( ar ) : NEW_LINE INDENT n = len ( ar ) NEW_LINE small = min ( ar ) NEW_LINE large = max ( ar ) NEW_LINE dp = [ [ 0 for i in range ( large + 1 ) ] for i in range ( n ) ] NEW_LINE for j in range ( small , large + 1 ) : NEW_LINE INDENT dp [ 0 ] [ j ] = abs ( ar [ 0 ] - j ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT minimum = 10 ** 9 NEW_LINE for j in range ( small , large + 1 ) : NEW_LINE INDENT minimum = min ( minimum , dp [ i - 1 ] [ j ] ) NEW_LINE dp [ i ] [ j ] = minimum + abs ( ar [ i ] - j ) NEW_LINE DEDENT DEDENT ans = 10 ** 9 NEW_LINE for j in range ( small , large + 1 ) : NEW_LINE INDENT ans = min ( ans , dp [ n - 1 ] [ j ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT ar = [ 1 , 2 , 1 , 4 , 3 ] NEW_LINE print ( getMinimumOps ( ar ) ) NEW_LINE"],"bleu":0.7812103107816155,"rouge_l":0.8980946882217089}
{"id":1206,"predictions":["def find ( s1 , s2 ) : NEW_LINE INDENT l = len ( s1 ) NEW_LINE len_1 = len ( s2 ) NEW_LINE if ( l != len_1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT d = [ 0 ] * l2 [ 0 ] NEW_LINE d [ 0 ] = s2 [ 0 ] - s1 [ 0 ] NEW_LINE for i in range ( 1 , l ) : NEW_LINE INDENT if ( s1 [ i ] > s2 [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT d [ i ] = s2 [ i ] - s1 [ i ] NEW_LINE DEDENT DEDENT for i in range ( l - 1 ) : NEW_LINE INDENT if ( d [ i ] < d [ i + 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s1 = \" abcd \" NEW_LINE s2 = \" bcdd \" NEW_LINE if ( find ( s1 , s2 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def find ( s1 , s2 ) : NEW_LINE INDENT len__ = len ( s1 ) NEW_LINE len_1 = len ( s2 ) NEW_LINE if ( len__ != len_1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT d = [ 0 for i in range ( len__ ) ] NEW_LINE d [ 0 ] = ord ( s2 [ 0 ] ) - ord ( s1 [ 0 ] ) NEW_LINE for i in range ( 1 , len__ , 1 ) : NEW_LINE INDENT if ( s1 [ i ] > s2 [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT d [ i ] = ord ( s2 [ i ] ) - ord ( s1 [ i ] ) NEW_LINE DEDENT DEDENT for i in range ( len__ - 1 ) : NEW_LINE INDENT if ( d [ i ] < d [ i + 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s1 = \" abcd \" NEW_LINE s2 = \" bcdd \" NEW_LINE if ( find ( s1 , s2 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.7827762311190841,"rouge_l":0.9072655610916934}
{"id":1207,"predictions":["def solveQuery ( start , end , arr ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT if arr [ i ] in mp . keys ( ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for x in mp : NEW_LINE INDENT if ( x == mp [ x ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 1 , 2 , 2 , 3 , 3 , 3 , 3 ] NEW_LINE n = len ( A ) NEW_LINE queries = [ [ 0 , 1 ] , [ 1 , 1 ] , [ 0 , 2 ] , [ 0 , 5 ] ] NEW_LINE q = len ( queries ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT start = queries [ i ] [ 0 ] NEW_LINE end = queries [ i ] [ 1 ] NEW_LINE print ( \" Answer ▁ for ▁ Query \" , ( i + 1 ) , \" = \" , solveQuery ( start , end , A ) ) NEW_LINE DEDENT DEDENT"],"references":["import math as mt NEW_LINE def solveQuery ( start , end , arr ) : NEW_LINE INDENT frequency = dict ( ) NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT if arr [ i ] in frequency . keys ( ) : NEW_LINE INDENT frequency [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT frequency [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for x in frequency : NEW_LINE INDENT if x == frequency [ x ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT A = [ 1 , 2 , 2 , 3 , 3 , 3 ] NEW_LINE n = len ( A ) NEW_LINE queries = [ [ 0 , 1 ] , [ 1 , 1 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 3 , 5 ] , [ 0 , 5 ] ] NEW_LINE q = len ( queries ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT start = queries [ i ] [ 0 ] NEW_LINE end = queries [ i ] [ 1 ] NEW_LINE print ( \" Answer ▁ for ▁ Query ▁ \" , ( i + 1 ) , \" ▁ = ▁ \" , solveQuery ( start , end , A ) ) NEW_LINE DEDENT"],"bleu":0.8118404096941698,"rouge_l":0.8851369677244373}
{"id":1208,"predictions":["def solve ( N , K ) : NEW_LINE INDENT combinations = [ 0 ] * 50 NEW_LINE combo [ 0 ] = 1 NEW_LINE for i in range ( 1 , K + 1 ) : NEW_LINE INDENT for j in range ( 0 , N + 1 ) : NEW_LINE INDENT if ( j >= i ) : NEW_LINE INDENT combo [ j ] += 1 NEW_LINE DEDENT DEDENT DEDENT return combos [ N ] NEW_LINE DEDENT N = 29 NEW_LINE K = 5 NEW_LINE print ( solve ( N , K ) ) NEW_LINE solve ( N , K ) NEW_LINE"],"references":["def solve ( N , K ) : NEW_LINE INDENT combo = [ 0 ] * ( N + 1 ) NEW_LINE combo [ 0 ] = 1 NEW_LINE for i in range ( 1 , K + 1 ) : NEW_LINE INDENT for j in range ( 0 , N + 1 ) : NEW_LINE INDENT if j >= i : NEW_LINE INDENT combo [ j ] += combo [ j - i ] NEW_LINE DEDENT DEDENT DEDENT return combo [ N ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N , K = 29 , 5 NEW_LINE print ( solve ( N , K ) ) NEW_LINE DEDENT"],"bleu":0.6518871373787701,"rouge_l":0.7838785046728972}
{"id":1209,"predictions":["n deno = [ 1 , 2 , 5 , 10 , 20 , 50 , 100 , 1000 ] NEW_LINE n = len ( deno ) NEW_LINE def findMin ( v ) : NEW_LINE INDENT ans = [ ] NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT while ( V >= deno [ i ] ) : NEW_LINE INDENT V -= deno [ i ] NEW_LINE ans . append ( deno [ i ] ) NEW_LINE DEDENT DEDENT for i in range ( len ( ans ) ) : NEW_LINE INDENT print ( ans [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 92 NEW_LINE print ( \" Following ▁ is ▁ minimal ▁ number ▁ of ▁ change ▁ for ▁ : ▁ \" , n , \" : ▁ \" ) NEW_LINE findMin ( n ) NEW_LINE DEDENT"],"references":["def findMin ( V ) : NEW_LINE INDENT deno = [ 1 , 2 , 5 , 10 , 20 , 50 , 100 , 500 , 1000 ] NEW_LINE n = len ( deno ) NEW_LINE ans = [ ] NEW_LINE i = n - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT while ( V >= deno [ i ] ) : NEW_LINE INDENT V -= deno [ i ] NEW_LINE ans . append ( deno [ i ] ) NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT for i in range ( len ( ans ) ) : NEW_LINE INDENT print ( ans [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 93 NEW_LINE print ( \" Following ▁ is ▁ minimal ▁ number \" , \" of ▁ change ▁ for \" , n , \" : ▁ \" , end = \" \" ) NEW_LINE findMin ( n ) NEW_LINE DEDENT"],"bleu":0.7570915210971096,"rouge_l":0.8307504461350614}
{"id":1210,"predictions":["def checkPalindrome ( num ) : NEW_LINE INDENT st = str ( num ) NEW_LINE l = 0 NEW_LINE r = len ( st ) - 1 NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( st [ l ] != st [ r ] ) : NEW_LINE INDENT print ( \" No \" ) NEW_LINE return NEW_LINE DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT print ( \" Yes \" ) NEW_LINE return NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 19 NEW_LINE k = 3 NEW_LINE checkPalindrome ( n + k ) NEW_LINE DEDENT"],"references":["def checkPalindrome ( num ) : NEW_LINE INDENT string = str ( num ) NEW_LINE l = 0 NEW_LINE r = len ( string ) - 1 ; NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( string [ l ] != string [ r ] ) : NEW_LINE INDENT print ( \" No \" ) NEW_LINE return ; NEW_LINE DEDENT l = l + 1 ; NEW_LINE r = r - 1 ; NEW_LINE DEDENT print ( \" Yes \" ) NEW_LINE return ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 19 NEW_LINE k = 3 NEW_LINE checkPalindrome ( n + k ) ; NEW_LINE DEDENT"],"bleu":0.6772788094016351,"rouge_l":0.8800565770862799}
{"id":1211,"predictions":["def updateArray ( arr , n ) : NEW_LINE INDENT for i in range ( n - 2 ) : NEW_LINE INDENT arr [ i ] = arr [ i + 1 ] NEW_LINE DEDENT arr [ n - 1 ] = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 5 , 1 , 3 , 2 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE updateArray ( arr , N ) NEW_LINE DEDENT"],"references":["def updateArray ( arr , n ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT arr [ i ] = arr [ i + 1 ] NEW_LINE DEDENT arr [ n - 1 ] = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 5 , 1 , 3 , 2 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE updateArray ( arr , N ) NEW_LINE DEDENT"],"bleu":0.9776239904176703,"rouge_l":0.9911504424778761}
{"id":1212,"predictions":["def maxProduct ( arr , n ) : NEW_LINE INDENT if ( n < 3 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT max_product = - 2147483648 NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT max_product = max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] ) NEW_LINE DEDENT DEDENT return max_product NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 10 , 3 , 5 , 6 , 20 ] NEW_LINE n = len ( arr ) NEW_LINE max = maxProduct ( arr , n ) NEW_LINE if ( max == - 1 ) : NEW_LINE INDENT print ( \" No ▁ Triplet ▁ exist \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Maximum ▁ product ▁ is \" , max ) NEW_LINE DEDENT DEDENT"],"references":["import sys NEW_LINE def maxProduct ( arr , n ) : NEW_LINE INDENT if n < 3 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT max_product = - ( sys . maxsize - 1 ) NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT max_product = max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] ) NEW_LINE DEDENT DEDENT DEDENT return max_product NEW_LINE DEDENT arr = [ 10 , 3 , 5 , 6 , 20 ] NEW_LINE n = len ( arr ) NEW_LINE max = maxProduct ( arr , n ) NEW_LINE if max == - 1 : NEW_LINE INDENT print ( \" No ▁ Tripplet ▁ Exits \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Maximum ▁ product ▁ is \" , max ) NEW_LINE DEDENT"],"bleu":0.7746129123310954,"rouge_l":0.844410732909832}
{"id":1213,"predictions":["def count ( S , X ) : NEW_LINE INDENT count = 0 NEW_LINE N = len ( S ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( S [ i ] != '0' ) : NEW_LINE INDENT for len1 in range ( 1 , N + len1 ) : NEW_LINE INDENT num = int ( S [ i : i + len1 ] ) NEW_LINE if ( num > X ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = \"2222\" NEW_LINE X = 97 NEW_LINE print ( count ( S , X ) ) NEW_LINE DEDENT"],"references":["def countSubStr ( S , X ) : NEW_LINE INDENT cnt = 0 NEW_LINE N = len ( S ) NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( S [ i ] != '0' ) : NEW_LINE INDENT j = 1 NEW_LINE while ( ( j + i ) <= N ) : NEW_LINE INDENT num = int ( S [ i : i + j ] ) NEW_LINE if ( num > X ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE DEDENT j = j + 1 NEW_LINE DEDENT DEDENT DEDENT return cnt ; NEW_LINE DEDENT S = \"2222\" ; NEW_LINE X = 97 ; NEW_LINE print ( countSubStr ( S , X ) ) NEW_LINE"],"bleu":0.6122487905947365,"rouge_l":0.7589051859612361}
{"id":1214,"predictions":["from math import sqrt NEW_LINE def printPattern ( radius ) : NEW_LINE INDENT for i in range ( 2 * radius + 1 ) : NEW_LINE INDENT for j in range ( 0 , 2 * radius + 1 ) : NEW_LINE INDENT dist = sqrt ( ( i - radius ) * ( i - radius ) + ( j - radius ) * ( j - radius ) ) ; NEW_LINE if ( dist > radius - 0.5 and dist < radius + 0.5 ) : NEW_LINE INDENT print ( \" * \" , end = \" \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" ▁ \" , end = \" \" ) ; NEW_LINE DEDENT DEDENT DEDENT print ( ) ; NEW_LINE DEDENT radius = 6 ; NEW_LINE printPattern ( radius ) ; NEW_LINE"],"references":["import math NEW_LINE def printPattern ( radius ) : NEW_LINE INDENT for i in range ( ( 2 * radius ) + 1 ) : NEW_LINE INDENT for j in range ( ( 2 * radius ) + 1 ) : NEW_LINE INDENT dist = math . sqrt ( ( i - radius ) * ( i - radius ) + ( j - radius ) * ( j - radius ) ) NEW_LINE if ( dist > radius - 0.5 and dist < radius + 0.5 ) : NEW_LINE INDENT print ( \" * \" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" ▁ \" , end = \" \" ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT radius = 6 NEW_LINE printPattern ( radius ) NEW_LINE"],"bleu":0.7961155002001734,"rouge_l":0.93047179851011}
{"id":1215,"predictions":["def findSum ( arr , N ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT if arr [ i ] not in mp . keys ( ) : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT sum = 0 NEW_LINE for key , value in mp . items ( ) : NEW_LINE INDENT if ( value % 2 != 0 ) : NEW_LINE INDENT sum += ( key ) * ( value ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 10 , 20 , 20 , 10 , 40 , 40 , 10 ] NEW_LINE N = len ( arr ) NEW_LINE print ( findSum ( arr , N ) ) NEW_LINE DEDENT"],"references":["import collections NEW_LINE def findsum ( arr , N ) : NEW_LINE INDENT mp = collections . defaultdict ( int ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT sum = 0 NEW_LINE for i in mp : NEW_LINE INDENT if ( mp [ i ] % 2 != 0 ) : NEW_LINE INDENT sum += ( i * mp [ i ] ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT arr = [ 10 , 20 , 20 , 10 , 40 , 40 , 10 ] NEW_LINE N = len ( arr ) NEW_LINE print ( findsum ( arr , N ) ) NEW_LINE"],"bleu":0.546441875724725,"rouge_l":0.7309766327142}
{"id":1216,"predictions":["def findFrequencyUtil ( arr , low , high , freq ) : NEW_LINE INDENT if ( arr [ low ] == arr [ high ] ) : NEW_LINE INDENT freq [ arr [ low ] ] += high - low + 1 NEW_LINE DEDENT else : NEW_LINE INDENT mid = ( low + high ) \/\/ 2 NEW_LINE findFrequencyUtil ( arr , low , mid , freq ) NEW_LINE findFrequencyUtil ( arr , mid + 1 , freq ) NEW_LINE for i in range ( arr [ n - 1 ] + 1 , freq ) NEW_LINE DEDENT DEDENT def findFrequency ( arr , n ) : NEW_LINE INDENT freq = [ 0 ] * ( arr [ n - 1 ] + 1 , freq ) NEW_LINE findFrequencyUtil ( arr , 0 , n - 1 , freq ) NEW_LINE for i in range ( arr [ n - 1 ] + 1 ) : NEW_LINE INDENT if ( freq [ i ] ) : NEW_LINE INDENT print ( \" Element \" , i , \" occurrences \" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 1 , 1 , 1 , 2 , 3 , 5 , 5 , 8 , 8 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE findFrequency ( arr , n ) NEW_LINE"],"references":["def findFrequencyUtil ( arr , low , high , freq ) : NEW_LINE INDENT if ( arr [ low ] == arr [ high ] ) : NEW_LINE INDENT freq [ arr [ low ] ] += high - low + 1 NEW_LINE DEDENT else : NEW_LINE INDENT mid = int ( ( low + high ) \/ 2 ) NEW_LINE findFrequencyUtil ( arr , low , mid , freq ) NEW_LINE findFrequencyUtil ( arr , mid + 1 , high , freq ) NEW_LINE DEDENT DEDENT def findFrequency ( arr , n ) : NEW_LINE INDENT freq = [ 0 for i in range ( n - 1 + 1 ) ] NEW_LINE findFrequencyUtil ( arr , 0 , n - 1 , freq ) NEW_LINE for i in range ( 0 , arr [ n - 1 ] + 1 , 1 ) : NEW_LINE INDENT if ( freq [ i ] != 0 ) : NEW_LINE INDENT print ( \" Element \" , i , \" occurs \" , freq [ i ] , \" times \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 1 , 1 , 2 , 3 , 3 , 5 , 5 , 8 , 8 , 8 , 9 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE findFrequency ( arr , n ) NEW_LINE DEDENT"],"bleu":0.7638257075140794,"rouge_l":0.8418169209431343}
{"id":1217,"predictions":["def sumOfSeries ( num ) : NEW_LINE INDENT res = 0 NEW_LINE fact = 1 NEW_LINE for i in range ( 1 , num + 1 ) : NEW_LINE INDENT fact = fact * i NEW_LINE res = res + ( i \/ fact ) NEW_LINE DEDENT return ( res ) NEW_LINE DEDENT n = 5 NEW_LINE print ( \" Sum : \" , sumOfSeries ( n ) ) NEW_LINE"],"references":["def sumOfSeries ( num ) : NEW_LINE INDENT res = 0 NEW_LINE fact = 1 NEW_LINE for i in range ( 1 , num + 1 ) : NEW_LINE INDENT fact *= i NEW_LINE res = res + ( i \/ fact ) NEW_LINE DEDENT return res NEW_LINE DEDENT n = 5 NEW_LINE print ( \" Sum : ▁ \" , sumOfSeries ( n ) ) NEW_LINE"],"bleu":0.849821131374244,"rouge_l":0.9526669870254686}
{"id":1218,"predictions":["def calcSum ( arr , n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT print ( sum , end = \" ▁ \" ) NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT sum = ( sum - arr [ i - k ] ) + arr [ i ] NEW_LINE print ( sum , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE calcSum ( arr , n , k ) NEW_LINE"],"references":["def calcSum ( arr , n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT print ( sum , end = \" ▁ \" ) NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT sum = ( sum - arr [ i - k ] ) + arr [ i ] NEW_LINE print ( sum , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE calcSum ( arr , n , k ) NEW_LINE DEDENT"],"bleu":0.8822759806271514,"rouge_l":0.9375309866137829}
{"id":1219,"predictions":["def minChanges ( A , n ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT if ( ( i - 1 >= 0 ) and A [ i - 1 ] == 1 and A [ i + 1 ] == 1 and A [ i ] == 0 ) : NEW_LINE INDENT A [ i + 1 ] = 0 ; NEW_LINE cnt += 1 ; NEW_LINE DEDENT DEDENT return cnt ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 1 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 0 ] ; NEW_LINE n = len ( A ) ; NEW_LINE print ( minChanges ( A , n ) ) ; NEW_LINE DEDENT"],"references":["def minChanges ( A , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT if ( ( i - 1 >= 0 ) and A [ i - 1 ] == 1 and A [ i + 1 ] == 1 and A [ i ] == 0 ) : NEW_LINE INDENT A [ i + 1 ] = 0 NEW_LINE cnt = cnt + 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT A = [ 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 0 ] NEW_LINE n = len ( A ) NEW_LINE print ( minChanges ( A , n ) ) NEW_LINE"],"bleu":0.7566065228740614,"rouge_l":0.9099987671063987}
{"id":1220,"predictions":["def calcNodes ( N , I ) : NEW_LINE INDENT result = 0 ; NEW_LINE result = I * ( N - 1 ) + 1 ; NEW_LINE return result ; NEW_LINE DEDENT N = 5 ; I = 2 ; NEW_LINE print ( \" Leaf ▁ nodes ▁ = ▁ \" , calcNodes ( N , I ) ) ; NEW_LINE"],"references":["def calcNodes ( N , I ) : NEW_LINE INDENT result = 0 NEW_LINE result = I * ( N - 1 ) + 1 NEW_LINE return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 NEW_LINE I = 2 NEW_LINE print ( \" Leaf ▁ nodes ▁ = ▁ \" , calcNodes ( N , I ) ) NEW_LINE DEDENT"],"bleu":0.6376165825317729,"rouge_l":0.8319532391622015}
{"id":1221,"predictions":["def countSum ( arr , n ) : NEW_LINE INDENT NumberOfOdds = 0 NEW_LINE NumberOfEvens = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 ) : NEW_LINE INDENT NumberOfOdds += 1 NEW_LINE DEDENT DEDENT NumberOfEvens = n - NumberOfOdds NEW_LINE NumberOfOddSubsequences = ( 1 << NumberOfOddOfEvens ) * ( 1 << ( NumberOfOdd - 1 ) ) NEW_LINE NumberOfEvenSubsequences = ( 1 << n ) - 1 - NumberOfOddSubsequences ) NEW_LINE return ( NumberOfEvenSubsequences , NumberOfOddSubsequences ) NEW_LINE DEDENT arr = [ 1 , 2 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE countSum ( arr , n ) NEW_LINE print ( \" EvenSum ▁ = \" , countSum ( arr , n ) ) NEW_LINE"],"references":["def countSum ( arr , n ) : NEW_LINE INDENT NumberOfOdds = 0 ; NumberOfEvens = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT NumberOfOdds += 1 ; NEW_LINE DEDENT DEDENT NumberOfEvens = n - NumberOfOdds ; NEW_LINE NumberOfOddSubsequences = ( 1 << NumberOfEvens ) *   \\ NEW_LINE INDENT ( 1 << ( NumberOfOdds - 1 ) ) ; NEW_LINE DEDENT NumberOfEvenSubsequences = ( 1 << n ) - 1 -   \\ NEW_LINE INDENT NumberOfOddSubsequences ; NEW_LINE DEDENT return ( NumberOfEvenSubsequences , NumberOfOddSubsequences ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 2 , 3 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE ans = countSum ( arr , n ) ; NEW_LINE print ( \" EvenSum ▁ = \" , ans [ 0 ] , end = \" ▁ \" ) ; NEW_LINE print ( \" OddSum ▁ = \" , ans [ 1 ] ) ; NEW_LINE DEDENT"],"bleu":0.47362782092002,"rouge_l":0.7407443972751506}
{"id":1222,"predictions":["import math NEW_LINE def findMinNumber ( n ) : NEW_LINE INDENT count = 0 NEW_LINE ans = 1 NEW_LINE while n % 2 == 0 : NEW_LINE INDENT count += 1 NEW_LINE n \/\/= 2 NEW_LINE DEDENT if count % 3 != 0 : NEW_LINE INDENT ans *= pow ( 2 , ( count % 3 ) ) NEW_LINE DEDENT for i in range ( 3 , ( int ) ( math . sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT count = 0 NEW_LINE while n % i == 0 : NEW_LINE INDENT count += 1 NEW_LINE n \/\/= i NEW_LINE DEDENT if count % 3 != 0 : NEW_LINE INDENT ans *= pow ( i , ( count % 3 ) ) NEW_LINE DEDENT DEDENT if n > 2 : NEW_LINE INDENT ans *= n NEW_LINE DEDENT return ans NEW_LINE DEDENT n = 128 NEW_LINE print ( findMinNumber ( n ) ) NEW_LINE"],"references":["def findMinNumber ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE ans = 1 ; NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE n \/= 2 ; NEW_LINE DEDENT if ( count % 3 != 0 ) : NEW_LINE INDENT ans *= pow ( 2 , ( count % 3 ) ) ; NEW_LINE DEDENT for i in range ( 3 , int ( pow ( n , 1 \/ 2 ) ) , 2 ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE n \/= i ; NEW_LINE DEDENT if ( count % 3 != 0 ) : NEW_LINE INDENT ans *= pow ( i , ( count % 3 ) ) ; NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT ans *= n ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 128 ; NEW_LINE print ( findMinNumber ( n ) ) ; NEW_LINE DEDENT"],"bleu":0.5289876667203308,"rouge_l":0.8273460410557185}
{"id":1223,"predictions":["def is_vow ( c ) : NEW_LINE INDENT return ( c == ' a ' ) or ( c == ' e ' ) or ( c == ' i ' or c == ' i ' ) or ( c == ' o ' ) or ( c == ' u ' ) ) NEW_LINE DEDENT def removeVowels ( Str ) : NEW_LINE INDENT print ( Str [ 0 ] ) NEW_LINE for i in range ( 1 , len ( Str ) ) : NEW_LINE INDENT if ( ( not is_vow ( Str [ i - 1 ] ) ) or ( not is_vow ( Str [ i ] ) ) ) : NEW_LINE INDENT print ( Str [ i ] , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT Str = \" geeks ▁ for ▁ geeks \" NEW_LINE removeVowels ( Str ) NEW_LINE DEDENT"],"references":["def is_vow ( c ) : NEW_LINE INDENT return ( ( c == ' a ' ) or ( c == ' e ' ) or ( c == ' i ' ) or ( c == ' o ' ) or ( c == ' u ' ) ) ; NEW_LINE DEDENT def removeVowels ( str ) : NEW_LINE INDENT print ( str [ 0 ] , end = \" \" ) ; NEW_LINE for i in range ( 1 , len ( str ) ) : NEW_LINE INDENT if ( ( is_vow ( str [ i - 1 ] ) != True ) or ( is_vow ( str [ i ] ) != True ) ) : NEW_LINE INDENT print ( str [ i ] , end = \" \" ) ; NEW_LINE DEDENT DEDENT DEDENT str = \" ▁ geeks ▁ for ▁ geeks \" ; NEW_LINE removeVowels ( str ) ; NEW_LINE"],"bleu":0.6401382817311452,"rouge_l":0.8330229671011795}
{"id":1224,"predictions":["def areaccd ( a ) : NEW_LINE INDENT PI = 3.14159265 NEW_LINE return ( a * a * ( PI \/ 2 ) ) NEW_LINE DEDENT a = 6 NEW_LINE print ( \" Area ▁ of ▁ a ▁ circumscribed ▁ circle ▁ is ▁ : \" ) NEW_LINE print ( areacircumscribed ( a ) ) NEW_LINE"],"references":["PI = 3.14159265 NEW_LINE def areacircumscribed ( a ) : NEW_LINE INDENT return ( a * a * ( PI \/ 2 ) ) NEW_LINE DEDENT a = 6 NEW_LINE print ( \" ▁ Area ▁ of ▁ an ▁ circumscribed ▁ circle ▁ is ▁ : \" , round ( areacircumscribed ( a ) , 2 ) ) NEW_LINE"],"bleu":0.7047264120239961,"rouge_l":0.8167364016736403}
{"id":1225,"predictions":["import math NEW_LINE def breakEvenPoint ( exp , S , M ) : NEW_LINE INDENT buy = S - M NEW_LINE exp = exp1 NEW_LINE res = ceil ( exp \/ drinks ) NEW_LINE res1 = res NEW_LINE return res1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT exp = 3550 NEW_LINE S = 90 NEW_LINE M = 65 NEW_LINE print ( breakEvenPoint ( exp1 , S , M ) ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def breakEvenPoint ( exp , S , M ) : NEW_LINE INDENT earn = S - M NEW_LINE res = math . ceil ( exp \/ earn ) NEW_LINE return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT exp = 3550 NEW_LINE S = 90 NEW_LINE M = 65 NEW_LINE print ( int ( breakEvenPoint ( exp , S , M ) ) ) NEW_LINE DEDENT"],"bleu":0.7291607846168843,"rouge_l":0.8692372170997484}
{"id":1226,"predictions":["MAX = 256 NEW_LINE def countPairs ( s ) : NEW_LINE INDENT cnt = [ 0 for i in range ( MAX ) ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT cnt [ ord ( s [ i ] ) ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT ans += cnt [ i ] * cnt [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT s = \" geeksforgeeks \" NEW_LINE print ( countPairs ( s ) ) NEW_LINE"],"references":["MAX = 256 NEW_LINE def countPairs ( s ) : NEW_LINE INDENT cnt = [ 0 for i in range ( 0 , MAX ) ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT cnt [ ord ( s [ i ] ) - 97 ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 0 , MAX ) : NEW_LINE INDENT ans += cnt [ i ] * cnt [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" geeksforgeeks \" NEW_LINE print ( countPairs ( s ) ) NEW_LINE DEDENT"],"bleu":0.7616825938740218,"rouge_l":0.8915172517703782}
{"id":1227,"predictions":["import math NEW_LINE def sumOfSeries ( n ) : NEW_LINE INDENT return 0.0 * ( pow ( 10 , n ) - 1 - ( 9 * n ) ) ; NEW_LINE DEDENT n = 3 ; NEW_LINE print ( sumOfSeries ( n ) ) ; NEW_LINE"],"references":["import math NEW_LINE def sumOfSeries ( n ) : NEW_LINE INDENT return 0.0246 * ( math . pow ( 10 , n ) - 1 - ( 9 * n ) ) NEW_LINE DEDENT n = 3 NEW_LINE print ( sumOfSeries ( n ) ) NEW_LINE"],"bleu":0.7650850090065283,"rouge_l":0.9265277287177676}
{"id":1228,"predictions":["def maxLenSub ( arr , n ) : NEW_LINE INDENT mls = [ 0 for i in range ( n ) ] NEW_LINE max = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mls [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( abs ( arr [ i ] - arr [ j ] ) ) <= 1 and mls [ i ] < mls [ j ] + 1 ) : NEW_LINE INDENT mls [ i ] = mls [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if max < mls [ i ] : NEW_LINE INDENT max = mls [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT arr = [ 2 , 5 , 6 , 3 , 7 , 6 , 5 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Maximum ▁ length ▁ subsequence ▁ = ▁ \" , maxLenSub ( arr , n ) ) NEW_LINE"],"references":["def maxLenSub ( arr , n ) : NEW_LINE INDENT mls = [ ] NEW_LINE max = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mls . append ( 1 ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( abs ( arr [ i ] - arr [ j ] ) <= 1 and mls [ i ] < mls [ j ] + 1 ) : NEW_LINE INDENT mls [ i ] = mls [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( max < mls [ i ] ) : NEW_LINE INDENT max = mls [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT arr = [ 2 , 5 , 6 , 3 , 7 , 6 , 5 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Maximum ▁ length ▁ subsequence ▁ = ▁ \" , maxLenSub ( arr , n ) ) NEW_LINE"],"bleu":0.887780742992854,"rouge_l":0.9491918844566714}
{"id":1229,"predictions":["mod = 1000000007 NEW_LINE dp = [ [ - 1 for i in range ( 1000 ) ] for j in range ( 1000 ) ] NEW_LINE def calculate ( pos , prev , s , index ) : NEW_LINE INDENT if ( pos == len ( s ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( dp [ pos ] [ prev ] != - 1 ) : NEW_LINE INDENT return dp [ pos ] [ prev ] NEW_LINE DEDENT answer = 0 NEW_LINE for i in range ( len ( index ) ) : NEW_LINE INDENT if ( index [ i ] > prev ) : NEW_LINE INDENT answer = ( answer % mod + calculate ( pos + 1 , index [ i ] , s , index ) % mod ) % mod NEW_LINE DEDENT DEDENT dp [ pos ] [ prev ] = answer NEW_LINE return answer NEW_LINE DEDENT def countWays ( a , s ) : NEW_LINE INDENT n = len ( a ) NEW_LINE index = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( len ( a [ i ] ) ) : NEW_LINE INDENT index [ ord ( a [ i ] [ j ] = - 1 ] [ j + 1 ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT index [ i ] [ j ] = - 1 NEW_LINE DEDENT DEDENT return calculate ( 0 , 0 , s , index [ 0 ] ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ \" adc \" , \" aec \" , \" g \" ] NEW_LINE S = \" ac \" NEW_LINE print ( countWays ( A , S ) ) NEW_LINE DEDENT"],"references":["mod = 1000000007 NEW_LINE dp = [ [ - 1 for i in range ( 1000 ) ] for j in range ( 1000 ) ] ; NEW_LINE def calculate ( pos , prev , s , index ) : NEW_LINE INDENT if ( pos == len ( s ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( dp [ pos ] [ prev ] != - 1 ) : NEW_LINE INDENT return dp [ pos ] [ prev ] NEW_LINE DEDENT c = ord ( s [ pos ] ) - ord ( ' a ' ) ; NEW_LINE answer = 0 NEW_LINE for i in range ( len ( index ) ) : NEW_LINE INDENT if ( index [ i ] > prev ) : NEW_LINE INDENT answer = ( answer % mod + calculate ( pos + 1 , index [ i ] , s , index ) % mod ) % mod NEW_LINE DEDENT DEDENT dp [ pos ] [ prev ] = 4 NEW_LINE return dp [ pos ] [ prev ] NEW_LINE DEDENT def countWays ( a , s ) : NEW_LINE INDENT n = len ( a ) NEW_LINE index = [ [ ] for i in range ( 26 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( len ( a [ i ] ) ) : NEW_LINE INDENT index [ ord ( a [ i ] [ j ] ) - ord ( ' a ' ) ] . append ( j + 1 ) ; NEW_LINE DEDENT DEDENT return calculate ( 0 , 0 , s , index [ 0 ] ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ ] NEW_LINE A . append ( \" adc \" ) NEW_LINE A . append ( \" aec \" ) NEW_LINE A . append ( \" erg \" ) NEW_LINE S = \" ac \" NEW_LINE print ( countWays ( A , S ) ) NEW_LINE DEDENT"],"bleu":0.7609038639539414,"rouge_l":0.8255281861551941}
{"id":1230,"predictions":["def divisibleBy36 ( num ) : NEW_LINE INDENT l = len ( num ) ; NEW_LINE if ( l == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT if ( l == 1 and num [ 0 ] != '0' ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT two_num = ( ( ord ( num [ l - 2 ] ) - ord ( '0' ) ) * 10 + ( ord ( num [ l - 1 ] ) - ord ( '0' ) ) ) ; NEW_LINE if ( two_digit_num % 4 != 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT sum = 0 ; NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT sum += ( ord ( num [ i ] ) - ord ( '0' ) ) ; NEW_LINE DEDENT if ( sum % 9 != 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT num = \"92512239\" ; NEW_LINE if ( divisibleBy36 ( num ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT"],"references":["def divisibleBy36 ( num ) : NEW_LINE INDENT l = len ( num ) NEW_LINE if ( l == 0 ) : NEW_LINE INDENT return ( \" No \" ) NEW_LINE DEDENT if ( l == 1 and num [ 0 ] != '0' ) : NEW_LINE INDENT return ( \" No \" ) NEW_LINE DEDENT two_digit_num = ( ( ( int ) ( num [ l - 2 ] ) ) * 10 + ( int ) ( num [ l - 1 ] ) ) NEW_LINE if ( two_digit_num % 4 != 0 ) : NEW_LINE INDENT return \" No \" NEW_LINE DEDENT sm = 0 NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT sm = sm + ( int ) ( num [ i ] ) NEW_LINE DEDENT if ( sm % 9 != 0 ) : NEW_LINE INDENT return ( \" No \" ) NEW_LINE DEDENT return ( \" Yes \" ) NEW_LINE DEDENT num = \"92567812197966231384\" NEW_LINE print ( divisibleBy36 ( num ) ) NEW_LINE"],"bleu":0.5731173667182394,"rouge_l":0.7309251101321587}
{"id":1231,"predictions":["import math as mt NEW_LINE sum = [ 0 for i in range ( 1000005 ) ] NEW_LINE def toString ( x ) : NEW_LINE INDENT return x - ord ( '0' ) NEW_LINE DEDENT def parseSum ( s ) : NEW_LINE INDENT sum [ 0 ] = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT sum [ i + 1 ] = sum [ i ] + toStr ( ord ( s [ i ] ) ) NEW_LINE DEDENT DEDENT def query ( l , r ) : NEW_LINE INDENT if ( ( sum [ r + 1 ] - sum [ l ] ) % 3 == 0 ) : NEW_LINE INDENT print ( \" Divisible ▁ by ▁ 3\" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ divisible ▁ by ▁ 3\" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = \"1246823652365 NEW_LINE query ( 0 , 1 ) NEW_LINE query ( 0 , 1 ) NEW_LINE query ( 1 , 2 ) NEW_LINE query ( 3 , 6 ) NEW_LINE query ( 0 , 10 ) NEW_LINE DEDENT"],"references":["sum = [ 0 for i in range ( 1000005 ) ] NEW_LINE def toInt ( x ) : NEW_LINE INDENT return int ( x ) NEW_LINE DEDENT def prepareSum ( s ) : NEW_LINE INDENT sum [ 0 ] = 0 NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT sum [ i + 1 ] = sum [ i ] + toInt ( s [ i ] ) NEW_LINE DEDENT DEDENT def query ( l , r ) : NEW_LINE INDENT if ( ( sum [ r + 1 ] - sum [ l ] ) % 3 == 0 ) : NEW_LINE INDENT print ( \" Divisible ▁ by ▁ 3\" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ divisible ▁ by ▁ 3\" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = \"12468236544\" NEW_LINE prepareSum ( n ) NEW_LINE query ( 0 , 1 ) NEW_LINE query ( 1 , 2 ) NEW_LINE query ( 3 , 6 ) NEW_LINE query ( 0 , 10 ) NEW_LINE DEDENT"],"bleu":0.8222159920893367,"rouge_l":0.9183232138401395}
{"id":1232,"predictions":["def distanceum ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE res = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res += ( arr [ i ] * i - sum ) NEW_LINE sum += arr [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT x = [ - 1 , 1 , 3 , 2 ] NEW_LINE y = [ 5 , 6 , 5 , 3 ] NEW_LINE n = len ( x ) NEW_LINE print ( totaldistance ( x , y , n ) ) NEW_LINE"],"references":["def distancesum ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE res = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res += ( arr [ i ] * i - sum ) NEW_LINE sum += arr [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT def totaldistancesum ( x , y , n ) : NEW_LINE INDENT return distancesum ( x , n ) + distancesum ( y , n ) NEW_LINE DEDENT x = [ - 1 , 1 , 3 , 2 ] NEW_LINE y = [ 5 , 6 , 5 , 3 ] NEW_LINE n = len ( x ) NEW_LINE print ( totaldistancesum ( x , y , n ) ) NEW_LINE"],"bleu":0.7282409148628934,"rouge_l":0.8450144013166918}
{"id":1233,"predictions":["def squareSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( 2 * i ) * ( 2 * i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT ans = squareSum ( 8 ) NEW_LINE print ( ans ) NEW_LINE"],"references":["def squareSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT sum += ( 2 * i ) * ( 2 * i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT ans = squareSum ( 8 ) NEW_LINE print ( ans ) NEW_LINE"],"bleu":0.9551190479308641,"rouge_l":0.9824561403508771}
{"id":1234,"predictions":["def findAndSum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE mul = 1 NEW_LINE for i in range ( 30 ) : NEW_LINE INDENT count_on = False NEW_LINE l = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( arr [ j ] & ( 1 << i ) ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_on = True NEW_LINE l += 1 NEW_LINE DEDENT elif ( count_on ) : NEW_LINE INDENT sum += ( ( mul * l * ( l + 1 ) ) \/\/ 2 ) NEW_LINE count_on = False NEW_LINE l = 0 NEW_LINE DEDENT DEDENT if ( count_on ) : NEW_LINE INDENT sum += ( ( mul * l * ( l + 1 ) ) \/\/ 2 ) NEW_LINE count_on = False NEW_LINE l = 0 NEW_LINE DEDENT mul *= 2 NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 7 , 1 , 1 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findAndSum ( arr , n ) ) NEW_LINE DEDENT"],"references":["import math as mt NEW_LINE def findAndSum ( arr , n ) : NEW_LINE INDENT Sum = 0 NEW_LINE mul = 1 NEW_LINE for i in range ( 30 ) : NEW_LINE INDENT count_on = 0 NEW_LINE l = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( ( arr [ j ] & ( 1 << i ) ) > 0 ) : NEW_LINE INDENT if ( count_on ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_on = 1 NEW_LINE l += 1 NEW_LINE DEDENT DEDENT elif ( count_on ) : NEW_LINE INDENT Sum += ( ( mul * l * ( l + 1 ) ) \/\/ 2 ) NEW_LINE count_on = 0 NEW_LINE l = 0 NEW_LINE DEDENT DEDENT if ( count_on ) : NEW_LINE INDENT Sum += ( ( mul * l * ( l + 1 ) ) \/\/ 2 ) NEW_LINE count_on = 0 NEW_LINE l = 0 NEW_LINE DEDENT mul *= 2 NEW_LINE DEDENT return Sum NEW_LINE DEDENT arr = [ 7 , 1 , 1 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findAndSum ( arr , n ) ) NEW_LINE"],"bleu":0.8074054641630625,"rouge_l":0.8827714447408846}
{"id":1235,"predictions":["def isAlphabaticOrder ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE c = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT c [ i ] = s [ i ] NEW_LINE DEDENT c . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( c [ i ] != s [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" aabbbcc \" NEW_LINE if ( isAlphabaticOrder ( s ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def isAlphabaticOrder ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE c = [ s [ i ] for i in range ( len ( s ) ) ] NEW_LINE c . sort ( reverse = False ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( c [ i ] != s [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" aabbbcc \" NEW_LINE if ( isAlphabaticOrder ( s ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.7966331825065084,"rouge_l":0.8855087099217369}
{"id":1236,"predictions":["import math NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . prev = None NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def push ( data , new_data ) : NEW_LINE INDENT new_node = new_data NEW_LINE new_node . next = head NEW_LINE if ( head is not None ) : NEW_LINE INDENT head . prev = new_node NEW_LINE DEDENT new_node . next = head NEW_LINE new_node . next = new_node NEW_LINE new_node . prev = new_node NEW_LINE new_node . prev = prev NEW_LINE if ( new_node . next != None ) : NEW_LINE INDENT new_node . prev = new_node NEW_LINE DEDENT DEDENT def appendAfter ( new_data ) : NEW_LINE INDENT new_node = Node ( new_data ) NEW_LINE new_node . next = prev NEW_LINE prev = new_node NEW_LINE new_node . next = None NEW_LINE if ( new_node . next != None ) : NEW_LINE INDENT new_node . prev = new_node NEW_LINE DEDENT DEDENT def printlist ( new_data ) : NEW_LINE INDENT new_node = Node ( new_data ) NEW_LINE last = head NEW_LINE new_node . next = None NEW_LINE if ( head == None ) : NEW_LINE INDENT new_node . prev = None NEW_LINE return NEW_LINE DEDENT while ( last . next != None ) : NEW_LINE INDENT last = last . next NEW_LINE DEDENT last = new_node ( new_data ) NEW_LINE last = new_node NEW_LINE new_node . prev = new_node NEW_LINE DEDENT def printlist ( node ) : NEW_LINE INDENT last = Node ( new_data ) NEW_LINE last = Node ( new_data ) NEW_LINE DED"],"references":["class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE self . prev = None NEW_LINE DEDENT DEDENT class DoublyLinkedList : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . head = None NEW_LINE DEDENT def push ( self , new_data ) : NEW_LINE INDENT new_node = Node ( new_data ) NEW_LINE new_node . next = self . head NEW_LINE if self . head is not None : NEW_LINE INDENT self . head . prev = new_node NEW_LINE DEDENT self . head = new_node NEW_LINE DEDENT def insertAfter ( self , prev_node , new_data ) : NEW_LINE INDENT if prev_node is None : NEW_LINE INDENT print \" the ▁ given ▁ previous ▁ node ▁ cannot ▁ be ▁ NULL \" NEW_LINE return NEW_LINE DEDENT new_node = Node ( new_data ) NEW_LINE new_node . next = prev_node . next NEW_LINE prev_node . next = new_node NEW_LINE new_node . prev = prev_node NEW_LINE if new_node . next is not None : NEW_LINE INDENT new_node . next . prev = new_node NEW_LINE DEDENT DEDENT def append ( self , new_data ) : NEW_LINE INDENT new_node = Node ( new_data ) NEW_LINE new_node . next = None NEW_LINE if self . head is None : NEW_LINE INDENT new_node . prev = None NEW_LINE self . head = new_node NEW_LINE return NEW_LINE DEDENT last = self . head NEW_LINE while ( last . next is not None ) : NEW_LINE INDENT last = last . next NEW_LINE DEDENT last . next = new_node NEW_LINE new_node . prev = last NEW_LINE return NEW_LINE DEDENT def printList ( self , node ) : NEW_LINE INDENT print \" \\n Traversal ▁ in ▁ forward ▁ direction \" NEW_LINE while ( node is not None ) : NEW_LINE INDENT print \" ▁ % ▁ d \" % ( node . data ) , NEW_LINE last = node NEW_LINE node = node . next NEW_LINE DEDENT print \" \\n Traversal ▁ in ▁ reverse ▁ direction \" NEW_LINE while ( last is not None ) : NEW_LINE INDENT print \" ▁ % ▁ d \" % ( last . data ) , NEW_LINE last = last . prev NEW_LINE DEDENT DEDENT DEDENT llist = DoublyLinkedList ( ) NEW_LINE llist . append ( 6 ) NEW_LINE llist . push ( 7 ) NEW_LINE llist . push ( 1 ) NEW_LINE llist . append ( 4 ) NEW_LINE llist . insertAfter ( llist . head . next , 8 ) NEW_LINE print \" Created ▁ DLL ▁ is : ▁ \" , NEW_LINE llist . printList ( llist . head ) NEW_LINE"],"bleu":0.37569507201607366,"rouge_l":0.5351102863649783}
{"id":1237,"predictions":["import math NEW_LINE size = 10001 NEW_LINE prime = [ 0 ] * size NEW_LINE freq = [ 0 ] * size NEW_LINE def sieve ( a , b ) : NEW_LINE INDENT prime [ 1 ] = 1 NEW_LINE i = 2 NEW_LINE while i * i < size : NEW_LINE INDENT if ( prime [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i * 2 , size , i ) : NEW_LINE INDENT prime [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT for p in range ( 1 , size ) : NEW_LINE INDENT for q in range ( 1 , size ) : NEW_LINE INDENT if ( prime [ p ] == 0 and prime [ q ] == 0 and a * p + b * q < size ) : NEW_LINE INDENT freq [ a * p + b * q ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT queries = 2 NEW_LINE a = 1 NEW_LINE b = 2 NEW_LINE sieve ( a , b ) NEW_LINE arr = [ 15 , 25 ] NEW_LINE for i in range ( queries ) : NEW_LINE INDENT print ( freq [ arr [ i ] ] , end = \" ▁ \" ) NEW_LINE DEDENT"],"references":["from math import sqrt NEW_LINE size = 1000 NEW_LINE prime = [ 0 for i in range ( size ) ] NEW_LINE freq = [ 0 for i in range ( size ) ] NEW_LINE def sieve ( a , b ) : NEW_LINE INDENT prime [ 1 ] = 1 NEW_LINE for i in range ( 2 , int ( sqrt ( size ) ) + 1 , 1 ) : NEW_LINE INDENT if ( prime [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i * 2 , size , i ) : NEW_LINE INDENT prime [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT for p in range ( 1 , size , 1 ) : NEW_LINE INDENT for q in range ( 1 , size , 1 ) : NEW_LINE INDENT if ( prime [ p ] == 0 and prime [ q ] == 0 and a * p + b * q < size ) : NEW_LINE INDENT freq [ a * p + b * q ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT queries = 2 NEW_LINE a = 1 NEW_LINE b = 2 NEW_LINE sieve ( a , b ) NEW_LINE arr = [ 15 , 25 ] NEW_LINE for i in range ( queries ) : NEW_LINE INDENT print ( freq [ arr [ i ] ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.7322840569225321,"rouge_l":0.8493141289437584}
{"id":1238,"predictions":["def replaceConsonants ( str ) : NEW_LINE INDENT res = \" \" NEW_LINE i = 0 NEW_LINE count = 0 NEW_LINE while ( i < len ( str ) ) : NEW_LINE INDENT if ( str [ i ] != ' a ' and ( str [ i ] != ' e ' and str [ i ] != ' i ' and str [ i ] != ' o ' and str [ i ] != ' o ' ) ) : NEW_LINE INDENT i += 1 NEW_LINE count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( count > 0 ) : NEW_LINE INDENT res += count NEW_LINE DEDENT res += str [ i ] NEW_LINE i += 1 NEW_LINE count = 0 NEW_LINE DEDENT DEDENT if ( count > 0 ) : NEW_LINE INDENT res += count NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" abcde \" NEW_LINE print ( replaceConsonants ( str ) ) NEW_LINE DEDENT"],"references":["def replaceConsonants ( string ) : NEW_LINE INDENT res = \" \" ; NEW_LINE i = 0 ; count = 0 ; NEW_LINE while ( i < len ( string ) ) : NEW_LINE INDENT if ( string [ i ] != ' a ' and string [ i ] != ' e ' and string [ i ] != ' i ' and string [ i ] != ' o ' and string [ i ] != ' u ' ) : NEW_LINE INDENT i += 1 ; NEW_LINE count += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( count > 0 ) : NEW_LINE INDENT res += str ( count ) ; NEW_LINE DEDENT res += string [ i ] ; NEW_LINE i += 1 NEW_LINE count = 0 ; NEW_LINE DEDENT DEDENT if ( count > 0 ) : NEW_LINE INDENT res += str ( count ) ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" abcdeiop \" ; NEW_LINE print ( replaceConsonants ( string ) ) ; NEW_LINE DEDENT"],"bleu":0.637399192904572,"rouge_l":0.8702630405706642}
{"id":1239,"predictions":["def count ( S , m , n ) : NEW_LINE INDENT table = [ [ 0 for x in range ( n + 1 ) ] for x in range ( m + 1 ) ] NEW_LINE table [ 0 ] [ 1 ] = 1 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( S [ i ] , n + 1 ) : NEW_LINE INDENT table [ j ] += table [ j - S [ i ] ] NEW_LINE DEDENT DEDENT return table [ n ] [ 1 ] NEW_LINE DEDENT"],"references":["def count ( S , m , n ) : NEW_LINE INDENT table = [ 0 for k in range ( n + 1 ) ] NEW_LINE table [ 0 ] = 1 NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT for j in range ( S [ i ] , n + 1 ) : NEW_LINE INDENT table [ j ] += table [ j - S [ i ] ] NEW_LINE DEDENT DEDENT return table [ n ] NEW_LINE DEDENT arr = [ 1 , 2 , 3 ] NEW_LINE m = len ( arr ) NEW_LINE n = 4 NEW_LINE x = count ( arr , m , n ) NEW_LINE print ( x ) NEW_LINE"],"bleu":0.6357071804408573,"rouge_l":0.7479327060165383}
{"id":1240,"predictions":["def minReplacement ( str ) : NEW_LINE INDENT if ( len ( str ) > 26 ) : NEW_LINE INDENT print ( \" IMPOSSIBLE \" ) ; NEW_LINE DEDENT hash = [ 0 ] * 26 ; NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT hash [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT count = 0 ; NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( hash [ ord ( str [ i ] ) - ord ( ' a ' ) ] > 1 ) : NEW_LINE INDENT for j in range ( 26 ) : NEW_LINE INDENT if ( hash [ ord ( str [ i ] ) - ord ( ' a ' ) ] > ord ( ' a ' ) ) : NEW_LINE INDENT hash [ ord ( str [ i ] ) - ord ( ' a ' ) ] -= 1 ; NEW_LINE hash [ j ] += 1 ; NEW_LINE break ; NEW_LINE DEDENT DEDENT DEDENT print ( str ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" xxxxyy \" ; NEW_LINE minReplacement ( str ) ; NEW_LINE DEDENT"],"references":["def minReplacement ( string ) : NEW_LINE INDENT if len ( string ) > 26 : NEW_LINE INDENT print ( \" IMPOSSIBLE \" ) NEW_LINE DEDENT else : NEW_LINE INDENT Hash = [ 0 ] * 26 NEW_LINE for i in range ( 0 , len ( string ) ) : NEW_LINE INDENT Hash [ ord ( string [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 0 , len ( string ) ) : NEW_LINE INDENT if Hash [ ord ( string [ i ] ) - ord ( ' a ' ) ] > 1 : NEW_LINE INDENT for j in range ( 0 , 26 ) : NEW_LINE INDENT if Hash [ j ] == 0 : NEW_LINE INDENT Hash [ ord ( string [ i ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE string [ i ] = chr ( j + ord ( ' a ' ) ) NEW_LINE Hash [ j ] += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( ' ' . join ( string ) ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" xxxxyyyy \" NEW_LINE minReplacement ( list ( string ) ) NEW_LINE DEDENT"],"bleu":0.5565203616236033,"rouge_l":0.7653039152065759}
{"id":1241,"predictions":["N = 3 NEW_LINE def findStepsForDDM ( arr ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( N ) : NEW_LINE INDENT sum += abs ( arr [ i ] [ j ] ) NEW_LINE DEDENT sum -= abs ( arr [ i ] [ i ] ) NEW_LINE if ( abs ( arr [ i ] [ i ] ) < abs ( sum ) ) : NEW_LINE INDENT result += abs ( abs ( arr [ i ] [ i ] ) - abs ( sum ) ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ [ 3 , - 2 , 1 ] , [ 1 , - 3 , 2 ] , [ - 1 , 2 , 4 ] ] NEW_LINE print ( findStepsForDDM ( arr ) ) NEW_LINE DEDENT"],"references":["N = 3 NEW_LINE def findStepsForDDM ( arr ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( N ) : NEW_LINE INDENT sum += abs ( arr [ i ] [ j ] ) NEW_LINE DEDENT sum -= abs ( arr [ i ] [ i ] ) NEW_LINE if ( abs ( arr [ i ] [ i ] ) < abs ( sum ) ) : NEW_LINE INDENT result += abs ( abs ( arr [ i ] [ i ] ) - abs ( sum ) ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT arr = [ [ 3 , - 2 , 1 ] , [ 1 , - 3 , 2 ] , [ - 1 , 2 , 4 ] ] NEW_LINE print ( findStepsForDDM ( arr ) ) NEW_LINE"],"bleu":0.907384695235931,"rouge_l":0.9640804597701149}
{"id":1242,"predictions":["def isArmstrong ( x , n ) : NEW_LINE INDENT sum1 = 0 ; NEW_LINE temp = x ; NEW_LINE while ( temp ) : NEW_LINE INDENT digit = temp % 10 ; NEW_LINE sum1 += pow ( digit , n ) ; NEW_LINE temp \/\/= 10 ; NEW_LINE DEDENT return sum1 == x ; NEW_LINE DEDENT def CalculateXORandOR ( n ) : NEW_LINE INDENT CalculateXOR = 0 ; NEW_LINE CalculateXOR = 0 ; NEW_LINE start = int ( pow ( 10 , n - 1 ) ) ; NEW_LINE end = pow ( 10 , n ) - 1 ; NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT if ( isArmstrong ( i , n ) ) : NEW_LINE INDENT CalculateXOR = CalculateXOR ^ i ; NEW_LINE CalculateOR = CalculateOR | i ; NEW_LINE DEDENT D print ( \" XOR ▁ = \" , CalculateXOR ) ; NEW_LINE print ( \" XOR ▁ = \" , CalculateOR ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 ; NEW_LINE CalculateXOR ( n ) ; NEW_LINE DEDENT"],"references":["def isArmstrong ( x , n ) : NEW_LINE INDENT sum1 = 0 NEW_LINE temp = x NEW_LINE while temp > 0 : NEW_LINE INDENT digit = temp % 10 NEW_LINE sum1 += digit ** n NEW_LINE temp \/\/= 10 NEW_LINE DEDENT return sum1 == x NEW_LINE DEDENT def CalculateXORandOR ( n ) : NEW_LINE INDENT CalculateXOR = 0 NEW_LINE CalculateOR = 0 NEW_LINE start = 10 ** ( n - 1 ) NEW_LINE end = ( 10 ** n ) - 1 NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT if ( isArmstrong ( i , n ) ) : NEW_LINE INDENT CalculateXOR = CalculateXOR ^ i NEW_LINE CalculateOR = CalculateOR | i NEW_LINE DEDENT DEDENT print ( \" XOR ▁ = ▁ \" , CalculateXOR ) NEW_LINE print ( \" OR ▁ = ▁ \" , CalculateOR ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 ; NEW_LINE CalculateXORandOR ( n ) ; NEW_LINE DEDENT"],"bleu":0.6293930764700237,"rouge_l":0.8891488213064602}
{"id":1243,"predictions":["import math NEW_LINE def decToOctal ( n ) : NEW_LINE INDENT octalNum = [ 0 ] * 100 ; NEW_LINE i = 0 ; NEW_LINE while ( n ) : NEW_LINE INDENT octalNum [ i ] = n % 8 ; NEW_LINE n = n \/\/ 8 ; NEW_LINE i += 1 ; NEW_LINE DEDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( octalNum [ j ] , end = \" \" ) ; NEW_LINE DEDENT print ( \" \" ) ; NEW_LINE DEDENT def nDigitPerfectSquares ( n ) : NEW_LINE INDENT dec = pow ( math . ceil ( math . sqrt ( pow ( 8 , n ) ) ) - 1 , 2 ) ; NEW_LINE decToOctal ( decimal ) ; NEW_LINE DEDENT nDigitPerfectSquares ( n ) ; NEW_LINE"],"references":["from math import sqrt , ceil NEW_LINE def decToOctal ( n ) : NEW_LINE INDENT octalNum = [ 0 ] * 100 ; NEW_LINE i = 0 ; NEW_LINE while ( n != 0 ) : NEW_LINE INDENT octalNum [ i ] = n % 8 ; NEW_LINE n = n \/\/ 8 ; NEW_LINE i += 1 ; NEW_LINE DEDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( octalNum [ j ] , end = \" \" ) ; NEW_LINE DEDENT print ( ) ; NEW_LINE DEDENT def nDigitPerfectSquares ( n ) : NEW_LINE INDENT decimal = pow ( ceil ( sqrt ( pow ( 8 , n ) ) ) - 1 , 2 ) ; NEW_LINE decToOctal ( decimal ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 2 ; NEW_LINE nDigitPerfectSquares ( n ) ; NEW_LINE DEDENT"],"bleu":0.7722224589495197,"rouge_l":0.8762146176594846}
{"id":1244,"predictions":["def getFinalElement ( n ) : NEW_LINE INDENT finalNum = 2 NEW_LINE finalNum = 2 NEW_LINE while ( finalNum * 2 <= n ) : NEW_LINE INDENT finalNum *= 2 NEW_LINE DEDENT finalNum *= 2 NEW_LINE return finalNum NEW_LINE DEDENT N = 12 NEW_LINE print ( getFinalElement ( N ) ) NEW_LINE"],"references":["def getFinalElement ( n ) : NEW_LINE INDENT finalNum = 2 NEW_LINE while finalNum * 2 <= n : NEW_LINE INDENT finalNum *= 2 NEW_LINE DEDENT return finalNum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 12 NEW_LINE print ( getFinalElement ( N ) ) NEW_LINE DEDENT"],"bleu":0.6340374999087729,"rouge_l":0.7726176115802171}
{"id":1245,"predictions":["def maxSum ( arr , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT ans = arr [ 0 ] + arr [ 1 ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = min ( ans , ( arr [ i ] + arr [ i + 1 ] ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 12 , 2 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxSum ( arr , n ) ) NEW_LINE"],"references":["def maxSum ( arr , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT ans = arr [ 0 ] + arr [ 1 ] NEW_LINE for i in range ( 1 , n - 1 , 1 ) : NEW_LINE INDENT ans = min ( ans , ( arr [ i ] + arr [ i + 1 ] ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 12 , 2 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxSum ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.82538074994326,"rouge_l":0.9087523277467411}
{"id":1246,"predictions":["def findCount ( str ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( i == ( ord ( str [ i ] ) - ord ( ' a ' ) ) or ( ord ( str [ i ] ) - ord ( ' A ' ) ) ) : NEW_LINE INDENT result = result + 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" abgdeF \" NEW_LINE print ( findCount ( str ) ) NEW_LINE DEDENT"],"references":["def findCount ( str ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( ( i == ord ( str [ i ] ) - ord ( ' a ' ) ) or ( i == ord ( str [ i ] ) - ord ( ' A ' ) ) ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT str = ' AbgdeF ' NEW_LINE print ( findCount ( str ) ) NEW_LINE"],"bleu":0.7261302176800345,"rouge_l":0.8696746058369674}
{"id":1247,"predictions":["def power ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : return 1 NEW_LINE elif ( y % 2 == 0 ) : NEW_LINE INDENT return ( power ( x , int ( y \/ 2 ) ) * power ( x , int ( y \/ 2 ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( x * power ( x , int ( y \/ 2 ) ) * power ( x , int ( y \/ 2 ) ) ) NEW_LINE DEDENT DEDENT def sieveOfEratosthenes ( n , isPrime ) : NEW_LINE INDENT isPrime [ 0 ] = isPrime [ 1 ] = False NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT isPrime [ i ] = True NEW_LINE DEDENT p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT isPrime [ p ] = False NEW_LINE i += 1 NEW_LINE DEDENT DEDENT def leftTruPrime ( n ) : NEW_LINE INDENT temp = n NEW_LINE cnt = 0 NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE temp1 = temp % 10 NEW_LINE if ( temp1 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT temp = temp \/\/ 10 NEW_LINE DEDENT isPrime = [ True for i in range ( n + 1 ) ] NEW_LINE sieveOfEratosthenes ( n , isPrime ) NEW_LINE for i in range ( cnt , 0 , - 1 ) : NEW_LINE INDENT mod = power ( 10 , i ) NEW_LINE if ( not isPrime [ n % mod ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT n = 113 NEW_LINE if ( leftTruPrime ( n ) ) : NEW_LINE INDENT print ( n , \" is ▁ left ▁ truncatable ▁ prime \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n , \" is ▁ not ▁ left ▁ truncatable ▁ prime \" ) NEW_LINE DEDENT"],"references":["def power ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( y % 2 == 0 ) : NEW_LINE INDENT return ( power ( x , y \/\/ 2 ) * power ( x , y \/\/ 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( x * power ( x , y \/\/ 2 ) * power ( x , y \/\/ 2 ) ) NEW_LINE DEDENT DEDENT def sieveOfEratosthenes ( n , isPrime ) : NEW_LINE INDENT isPrime [ 0 ] = isPrime [ 1 ] = False NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT isPrime [ i ] = True NEW_LINE DEDENT p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( isPrime [ p ] == True ) : NEW_LINE INDENT i = p * 2 NEW_LINE while ( i <= n ) : NEW_LINE INDENT isPrime [ i ] = False NEW_LINE i = i + p NEW_LINE DEDENT DEDENT p = p + 1 NEW_LINE DEDENT DEDENT def leftTruPrime ( n ) : NEW_LINE INDENT temp = n NEW_LINE cnt = 0 NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE temp1 = temp % 10 ; NEW_LINE if ( temp1 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT temp = temp \/\/ 10 NEW_LINE DEDENT isPrime = [ None ] * ( n + 1 ) NEW_LINE sieveOfEratosthenes ( n , isPrime ) NEW_LINE for i in range ( cnt , 0 , - 1 ) : NEW_LINE INDENT mod = power ( 10 , i ) NEW_LINE if ( isPrime [ n % mod ] != True ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT n = 113 NEW_LINE if ( leftTruPrime ( n ) ) : NEW_LINE INDENT print ( n , \" is ▁ left ▁ truncatable ▁ prime \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n , \" is ▁ not ▁ left ▁ truncatable ▁ prime \" ) NEW_LINE DEDENT"],"bleu":0.7860829896838386,"rouge_l":0.8823987182421607}
{"id":1248,"predictions":["def findExtraCharcter ( strA , strB ) : NEW_LINE INDENT m1 = [ 0 for i in range ( 256 ) ] NEW_LINE for i in range ( len ( strA ) ) : NEW_LINE INDENT m1 [ ord ( strB [ i ] ) ] += 1 NEW_LINE DEDENT for i in range ( len ( m1 ) ) : NEW_LINE INDENT m1 [ ord ( strA [ i ] ) ] -= 1 NEW_LINE DEDENT for i in range ( len ( m1 ) ) : NEW_LINE INDENT if ( m1 [ i ] == 1 ) : NEW_LINE INDENT return chr ( i ) ; NEW_LINE DEDENT DEDENT DEDENT str2 = \" abcd \" NEW_LINE strB = \" cbdad \" NEW_LINE print ( findExtraCharcter ( strA , strB ) ) NEW_LINE"],"references":["def findExtraCharacter ( strA , strB ) : NEW_LINE INDENT m1 = { } NEW_LINE for i in strB : NEW_LINE INDENT if i in m1 : NEW_LINE INDENT m1 [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m1 [ i ] = 1 NEW_LINE DEDENT DEDENT for i in strA : NEW_LINE INDENT m1 [ i ] -= 1 NEW_LINE DEDENT for h1 in m1 : NEW_LINE INDENT if m1 [ h1 ] == 1 : NEW_LINE INDENT return h1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT strA = ' abcd ' NEW_LINE strB = ' cbdad ' NEW_LINE print ( findExtraCharacter ( strA , strB ) ) NEW_LINE DEDENT"],"bleu":0.3779694213864271,"rouge_l":0.608907089838751}
{"id":1249,"predictions":["def AvgofSquareN ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( i * i ) ; NEW_LINE DEDENT return sum \/ n ; NEW_LINE DEDENT n = 2 ; NEW_LINE print ( AvgofSquareN ( n ) ) ; NEW_LINE"],"references":["def AvgofSquareN ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( i * i ) NEW_LINE DEDENT return sum \/ n NEW_LINE DEDENT n = 2 NEW_LINE print ( AvgofSquareN ( n ) ) NEW_LINE"],"bleu":0.7891072624542853,"rouge_l":0.9627754615842765}
{"id":1250,"predictions":["def lcm_fun ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return lcm_fun ( b , a % b ) NEW_LINE DEDENT def digitLCM ( n ) : NEW_LINE INDENT lcm = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT lcm = ( n % 10 * lcm ) \/ lcm_fun ( n % 10 , lcm ) NEW_LINE if ( lcm == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT n = n \/ 10 NEW_LINE DEDENT return lcm NEW_LINE DEDENT n = 397 NEW_LINE print ( digitLCM ( n ) ) NEW_LINE"],"references":["def lcm_fun ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a ; NEW_LINE DEDENT return lcm_fun ( b , a % b ) ; NEW_LINE DEDENT def digitLCM ( n ) : NEW_LINE INDENT lcm = 1 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT lcm = int ( ( n % 10 * lcm ) \/ lcm_fun ( n % 10 , lcm ) ) ; NEW_LINE if ( lcm == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT n = int ( n \/ 10 ) ; NEW_LINE DEDENT return lcm ; NEW_LINE DEDENT n = 397 ; NEW_LINE print ( digitLCM ( n ) ) ; NEW_LINE"],"bleu":0.7402346980558362,"rouge_l":0.9255172413793104}
{"id":1251,"predictions":["def fact ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n * fact ( n - 1 ) NEW_LINE DEDENT def nPr ( n , r ) : NEW_LINE INDENT return fact ( n ) \/ fact ( n - r ) NEW_LINE DEDENT n = 5 NEW_LINE r = 2 NEW_LINE print ( n , \" P \" , \" P \" , n ▁ = \" , nPr ( n , r ) ) NEW_LINE"],"references":["import math NEW_LINE def fact ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n * fact ( n - 1 ) NEW_LINE DEDENT def nPr ( n , r ) : NEW_LINE INDENT return math . floor ( fact ( n ) \/ fact ( n - r ) ) NEW_LINE DEDENT n = 5 NEW_LINE r = 2 NEW_LINE print ( n , \" P \" , r , \" = \" , nPr ( n , r ) ) NEW_LINE"],"bleu":0.8476650860057877,"rouge_l":0.9135318238545194}
{"id":1252,"predictions":["def isPossible ( a , n ) : NEW_LINE INDENT cur = a [ 0 ] NEW_LINE cur = cur - 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT nxt = a [ i ] NEW_LINE if ( nxt > cur ) : NEW_LINE INDENT nxt -= 1 NEW_LINE DEDENT elif ( nxt < cur ) : NEW_LINE INDENT return False NEW_LINE DEDENT cur = nxt NEW_LINE DEDENT return True NEW_LINE DEDENT a = [ 1 , 2 , 1 , 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE if ( isPossible ( a , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def isPossible ( a , n ) : NEW_LINE INDENT cur = a [ 0 ] ; NEW_LINE cur -= 1 ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT nxt = a [ i ] ; NEW_LINE if ( nxt > cur ) : NEW_LINE INDENT nxt -= 1 ; NEW_LINE DEDENT elif ( nxt < cur ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT cur = nxt ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 2 , 1 , 2 , 3 ] ; NEW_LINE n = len ( a ) ; NEW_LINE if ( isPossible ( a , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"],"bleu":0.6983516102291788,"rouge_l":0.8853611520580563}
{"id":1253,"predictions":["def fact ( n ) : NEW_LINE INDENT num = 1 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT num = num * i ; NEW_LINE DEDENT return num ; NEW_LINE DEDENT def Special_Factorial_Number ( k ) : NEW_LINE INDENT for i in range ( 1 , k + 1 ) : NEW_LINE INDENT if ( fact ( i ) % k == 0 ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT DEDENT return 0 ; NEW_LINE DEDENT k = 16 ; NEW_LINE print ( Special_Factorial_Number ( k ) ) ; NEW_LINE"],"references":["def fact ( n ) : NEW_LINE INDENT num = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT num = num * i NEW_LINE DEDENT return num NEW_LINE DEDENT def Special_Factorial_Number ( k ) : NEW_LINE INDENT for i in range ( 1 , k + 1 ) : NEW_LINE INDENT if ( fact ( i ) % k == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT k = 16 NEW_LINE print ( Special_Factorial_Number ( k ) ) NEW_LINE DEDENT"],"bleu":0.7614737723265191,"rouge_l":0.8941213160767192}
{"id":1254,"predictions":["mod = 1000000007 NEW_LINE def noOfBinaryStrings ( N , k ) : NEW_LINE INDENT dp = [ 0 ] * 100002 NEW_LINE for i in range ( 1 , k - 1 ) : NEW_LINE INDENT dp [ i ] = 1 NEW_LINE DEDENT dp [ k ] = 2 NEW_LINE for i in range ( k + 1 , N + 1 ) : NEW_LINE INDENT dp [ i ] = ( dp [ i - 1 ] + dp [ i - k ] ) % mod NEW_LINE DEDENT return dp [ N ] NEW_LINE DEDENT N = 4 NEW_LINE K = 2 NEW_LINE print ( noOfBinaryStrings ( N , K ) ) NEW_LINE"],"references":["mod = 1000000007 ; NEW_LINE def noOfBinaryStrings ( N , k ) : NEW_LINE INDENT dp = [ 0 ] * 100002 ; NEW_LINE for i in range ( 1 , K ) : NEW_LINE INDENT dp [ i ] = 1 ; NEW_LINE DEDENT dp [ k ] = 2 ; NEW_LINE for i in range ( k + 1 , N + 1 ) : NEW_LINE INDENT dp [ i ] = ( dp [ i - 1 ] + dp [ i - k ] ) % mod ; NEW_LINE DEDENT return dp [ N ] ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 4 ; NEW_LINE K = 2 ; NEW_LINE print ( noOfBinaryStrings ( N , K ) ) ; NEW_LINE DEDENT"],"bleu":0.6951426673597829,"rouge_l":0.8801072522982636}
{"id":1255,"predictions":["def reverse ( arr , n , k ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT left = i NEW_LINE right = min ( i + k - 1 , n - 1 ) NEW_LINE while left < right : NEW_LINE INDENT arr [ left ] , left += 1 , right -= 1 NEW_LINE right -= 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 ] NEW_LINE k = 3 NEW_LINE n = len ( arr ) NEW_LINE reverse ( arr , n , k ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT"],"references":["def reverse ( arr , n , k ) : NEW_LINE INDENT for i in range ( 0 , n , 2 * k ) : NEW_LINE INDENT left = i NEW_LINE right = min ( i + k - 1 , n - 1 ) NEW_LINE while ( left < right ) : NEW_LINE INDENT temp = arr [ left ] NEW_LINE arr [ left ] = arr [ right ] NEW_LINE arr [ right ] = temp NEW_LINE left += 1 NEW_LINE right -= 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 ] NEW_LINE k = 3 NEW_LINE n = len ( arr ) NEW_LINE reverse ( arr , n , k ) NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.7328479182429201,"rouge_l":0.868897010589448}
{"id":1256,"predictions":["MAX = 100 ; NEW_LINE mat = [ [ 0 for i in range ( MAX ) ] for j in range ( MAX ) ] for k in range ( MAX ) ] ; NEW_LINE def fillRemain ( i , j , n ) : NEW_LINE INDENT x = 2 ; NEW_LINE for k in range ( i + 1 , n ) : NEW_LINE INDENT mat [ k ] [ j ] = x + 1 ; NEW_LINE DEDENT for k in range ( i ) : NEW_LINE INDENT mat [ k ] [ j ] = x + 1 ; NEW_LINE DEDENT DEDENT def constructMatrix ( n ) : NEW_LINE INDENT right = n - 1 ; NEW_LINE left = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT mat [ i ] [ right ] = 1 ; NEW_LINE fillRemaining ( i , right , n ) ; NEW_LINE right -= 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT mat [ i ] [ left ] = 1 ; NEW_LINE fillRemaining ( i , left , n ) ; NEW_LINE left += 1 ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 ; NEW_LINE constructMatrix ( n ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( ) ; NEW_LINE DEDENT DEDENT"],"references":["MAX = 100 ; NEW_LINE mat = [ [ 0 for x in range ( MAX ) ] for y in range ( MAX ) ] ; NEW_LINE def fillRemaining ( i , j , n ) : NEW_LINE INDENT x = 2 ; NEW_LINE for k in range ( i + 1 , n ) : NEW_LINE INDENT mat [ k ] [ j ] = x ; NEW_LINE x += 1 ; NEW_LINE DEDENT for k in range ( i ) : NEW_LINE INDENT mat [ k ] [ j ] = x ; NEW_LINE x += 1 ; NEW_LINE DEDENT DEDENT def constructMatrix ( n ) : NEW_LINE INDENT right = n - 1 ; NEW_LINE left = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT mat [ i ] [ right ] = 1 ; NEW_LINE fillRemaining ( i , right , n ) ; NEW_LINE right -= 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT mat [ i ] [ left ] = 1 ; NEW_LINE fillRemaining ( i , left , n ) ; NEW_LINE left += 1 ; NEW_LINE DEDENT DEDENT DEDENT n = 5 ; NEW_LINE constructMatrix ( n ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( \" \" ) ; NEW_LINE DEDENT"],"bleu":0.8663469328717386,"rouge_l":0.9302751174281705}
{"id":1257,"predictions":["import sys NEW_LINE def printMaxOfMin ( arr , n ) : NEW_LINE INDENT for k in range ( 1 , n + 1 ) : NEW_LINE INDENT maxOfMin = sys . maxsize - 1 NEW_LINE for i in range ( n - k + 1 ) : NEW_LINE INDENT min = arr [ i ] NEW_LINE for j in range ( 1 , k ) : NEW_LINE INDENT if ( arr [ i + j ] < min ) : NEW_LINE INDENT min = arr [ i + j ] NEW_LINE DEDENT DEDENT if ( min > maxOfMin ) : NEW_LINE INDENT maxOfMin = min NEW_LINE DEDENT DEDENT print ( maxOfMin , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 10 , 20 , 30 , 30 , 50 , 10 , 70 , 30 ] NEW_LINE n = len ( arr ) NEW_LINE printMaxOfMin ( arr , n ) NEW_LINE DEDENT"],"references":["INT_MIN = - 1000000 NEW_LINE def printMaxOfMin ( arr , n ) : NEW_LINE INDENT for k in range ( 1 , n + 1 ) : NEW_LINE INDENT maxOfMin = INT_MIN ; NEW_LINE for i in range ( n - k + 1 ) : NEW_LINE INDENT min = arr [ i ] NEW_LINE for j in range ( k ) : NEW_LINE INDENT if ( arr [ i + j ] < min ) : NEW_LINE INDENT min = arr [ i + j ] NEW_LINE DEDENT DEDENT if ( min > maxOfMin ) : NEW_LINE INDENT maxOfMin = min NEW_LINE DEDENT DEDENT print ( maxOfMin , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 10 , 20 , 30 , 50 , 10 , 70 , 30 ] NEW_LINE n = len ( arr ) NEW_LINE printMaxOfMin ( arr , n ) NEW_LINE"],"bleu":0.8259346751080265,"rouge_l":0.9126233766233766}
{"id":1258,"predictions":["def countSubArrays ( arr , n , K ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT bitwise_or = 0 NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT bitwise_or = bitwise_or | arr [ k ] NEW_LINE DEDENT if ( bitwise_or >= K ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE k = 6 NEW_LINE print ( countSubArrays ( arr , n , k ) ) NEW_LINE DEDENT"],"references":["def countSubArrays ( arr , n , K ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT bitwise_or = 0 NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT bitwise_or = bitwise_or | arr [ k ] NEW_LINE DEDENT if ( bitwise_or >= K ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE k = 6 NEW_LINE print ( countSubArrays ( arr , n , k ) ) NEW_LINE DEDENT"],"bleu":0.9432589169413769,"rouge_l":0.9806111179285801}
{"id":1259,"predictions":["CHARS = \" qwertyasdfgh \" ; NEW_LINE MAX = 26 ; NEW_LINE def getString ( string , n ) : NEW_LINE INDENT umap = dict ( ) ; NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT umap [ i ] = CHARS [ ( i + 1 ) % MAX ] ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT umap [ ord ( string [ i + 1 ] ) % MOD ; NEW_LINE DEDENT return ( string ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" geeks \" ; NEW_LINE n = len ( string ) ; NEW_LINE print ( getString ( string , n ) ) ; NEW_LINE DEDENT"],"references":["CHARS = \" qwertyuiopasdfghjklzxcvbnm \" ; NEW_LINE MAX = 26 ; NEW_LINE def getString ( string , n ) : NEW_LINE INDENT string = list ( string ) ; NEW_LINE uMap = { } ; NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT uMap [ CHARS [ i ] ] = CHARS [ ( i + 1 ) % MAX ] ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT string [ i ] = uMap [ string [ i ] ] ; NEW_LINE DEDENT return \" \" . join ( string ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" geeks \" ; NEW_LINE n = len ( string ) ; NEW_LINE print ( getString ( string , n ) ) ; NEW_LINE DEDENT"],"bleu":0.7321290423627874,"rouge_l":0.8571088354370089}
{"id":1260,"predictions":["def printOrder ( arr , k ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE arr . sort ( ) NEW_LINE arr . sort ( ) NEW_LINE arr . sort ( ) NEW_LINE return arr [ k : n - 1 ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT k = 4 NEW_LINE k = 4 NEW_LINE printOrder ( arr , k ) NEW_LINE DEDENT"],"references":["def printOrder ( arr , n , k ) : NEW_LINE INDENT a = arr [ 0 : k ] ; NEW_LINE a . sort ( ) ; NEW_LINE b = arr [ k : n ] ; NEW_LINE b . sort ( ) ; NEW_LINE b . reverse ( ) ; NEW_LINE return a + b ; NEW_LINE DEDENT arr = [ 5 , 4 , 6 , 2 , 1 , 3 , 8 , 9 , - 1 ] ; NEW_LINE k = 4 ; NEW_LINE n = len ( arr ) ; NEW_LINE arr = printOrder ( arr , n , k ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT"],"bleu":0.19523345080725993,"rouge_l":0.44380103934669635}
{"id":1261,"predictions":["import math NEW_LINE def countSteps ( n ) : NEW_LINE INDENT steps = 0 NEW_LINE while ( n ) : NEW_LINE INDENT largest = math . sqrt ( n ) NEW_LINE n -= ( largest * largest ) NEW_LINE steps += 1 NEW_LINE DEDENT return steps NEW_LINE DEDENT n = 85 NEW_LINE print ( countSteps ( n ) ) NEW_LINE"],"references":["from math import sqrt NEW_LINE def countSteps ( n ) : NEW_LINE INDENT steps = 0 ; NEW_LINE while ( n ) : NEW_LINE INDENT largest = int ( sqrt ( n ) ) ; NEW_LINE n -= ( largest * largest ) ; NEW_LINE steps += 1 ; NEW_LINE DEDENT return steps ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 85 ; NEW_LINE print ( countSteps ( n ) ) ; NEW_LINE DEDENT"],"bleu":0.47512251900441443,"rouge_l":0.7685676392572945}
{"id":1262,"predictions":["import math as mt NEW_LINE def Area ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT h = 1.464 * a NEW_LINE A = 0.70477 * pow ( h , 2 ) NEW_LINE return A NEW_LINE DEDENT a = 5 NEW_LINE print ( Area ( a ) ) NEW_LINE"],"references":["import math NEW_LINE def Area ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT h = 1.268 * a NEW_LINE A = 0.70477 * math . pow ( h , 2 ) NEW_LINE return A NEW_LINE DEDENT a = 5 NEW_LINE print ( Area ( a ) , end = \" \\n \" ) NEW_LINE"],"bleu":0.7720931203491581,"rouge_l":0.8970588235294117}
{"id":1263,"predictions":["SIZE = 26 NEW_LINE def isVowel ( ch ) : NEW_LINE INDENT if ( ch == ' a ' or ch == ' e ' or ch == ' i ' or ch == ' o ' or ch == ' u ' ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def createAltStr ( str1 , str2 , start , l ) : NEW_LINE INDENT finalStr = \" \" NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT finalStr = ( finalStr + str1 [ i ] ) + str2 [ j ] NEW_LINE DEDENT return finalStr NEW_LINE DEDENT def findAltStr ( str1 ) : NEW_LINE INDENT charStr = [ 0 for i in range ( start , l ) ] NEW_LINE nv = 0 NEW_LINE nc = 0 NEW_LINE l = len ( str ) NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT finalStr = str [ i ] NEW_LINE if ( isVowel ( ch ) ) : NEW_LINE INDENT nv += 1 NEW_LINE DEDENT else : NEW_LINE INDENT nc += 1 NEW_LINE DEDENT char_freq [ ord ( ch ) - 97 ] += 1 NEW_LINE DEDENT if ( abs ( nv - nc ) >= 2 ) : NEW_LINE INDENT return \" no ▁ such ▁ string \" NEW_LINE DEDENT for i in range ( 0 , SIZE ) : NEW_LINE INDENT ch = chr ( i + 97 ) NEW_LINE for j in range ( 1 , char_freq [ i ] + 1 ) ) : NEW_LINE INDENT if ( isVowel ( ch ) ) : NEW_LINE INDENT vstr += ch NEW_LINE DEDENT else : NEW_LINE INDENT cstr += ch NEW_LINE DEDENT DEDENT if ( nv - nc ) >= 2 : NEW_LINE INDENT return \" no ▁ such ▁ Str [ 0 ] + createAltStr ( cstr , vstr , 1 , nv ) ) NEW_LINE DEDENT return \" no ▁ such ▁ string \" + createAltStr ( cstr , cstr ,"],"references":["SIZE = 26 NEW_LINE def isVowel ( ch ) : NEW_LINE INDENT if ( ch == ' a ' or ch == ' e ' or ch == ' i ' or ch == ' o ' or ch == ' u ' ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def createAltStr ( str1 , str2 , start , l ) : NEW_LINE INDENT finalStr = \" \" NEW_LINE i = 0 NEW_LINE j = start NEW_LINE while j < l : NEW_LINE INDENT finalStr += str1 [ i ] + str2 [ j ] NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT return finalStr NEW_LINE DEDENT def findAltStr ( string ) : NEW_LINE INDENT char_freq = [ 0 ] * SIZE NEW_LINE nv = 0 NEW_LINE nc = 0 NEW_LINE vstr = \" \" NEW_LINE cstr = \" \" NEW_LINE l = len ( string ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT ch = string [ i ] NEW_LINE if isVowel ( ch ) : NEW_LINE INDENT nv += 1 NEW_LINE DEDENT else : NEW_LINE INDENT nc += 1 NEW_LINE DEDENT char_freq [ ord ( ch ) - 97 ] += 1 NEW_LINE DEDENT if abs ( nv - nc ) >= 2 : NEW_LINE INDENT return \" no ▁ such ▁ string \" NEW_LINE DEDENT for i in range ( SIZE ) : NEW_LINE INDENT ch = chr ( i + 97 ) NEW_LINE for j in range ( 1 , char_freq [ i ] + 1 ) : NEW_LINE INDENT if isVowel ( ch ) : NEW_LINE INDENT vstr += ch NEW_LINE DEDENT else : NEW_LINE INDENT cstr += ch NEW_LINE DEDENT DEDENT DEDENT if nv > nc : NEW_LINE INDENT return vstr [ 0 ] + createAltStr ( cstr , vstr , 1 , nv ) NEW_LINE DEDENT if nc > nv : NEW_LINE INDENT return cstr [ 0 ] + createAltStr ( vstr , cstr , 1 , nc ) NEW_LINE DEDENT if cstr [ 0 ] < vstr [ 0 ] : NEW_LINE INDENT return createAltStr ( cstr , vstr , 0 , nv ) NEW_LINE DEDENT return createAltStr ( vstr , cstr , 0 , nc ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" aeroplane \" NEW_LINE print ( findAltStr ( string ) ) NEW_LINE DEDENT"],"bleu":0.6136686679570771,"rouge_l":0.7502490147676584}
{"id":1264,"predictions":["N = 5 NEW_LINE M = 5 NEW_LINE def minOperation ( mat ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( M - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] [ j ] == False ) : NEW_LINE INDENT ans += 1 NEW_LINE for k in range ( i + 1 ) : NEW_LINE INDENT if ( arr [ k ] [ h ] == True ) : NEW_LINE INDENT arr [ k ] [ h ] = False NEW_LINE DEDENT else : NEW_LINE INDENT arr [ k ] [ h ] = True NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT mat = [ [ 0 , 0 , 1 , 1 , 1 , 1 , 1 ] , [ 0 , 0 , 0 , 1 , 1 ] , [ 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 ] , [ 1 , 1 , 1 , 1 , 1 , 1 , 1 ] , [ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] ] NEW_LINE DEDENT"],"references":["def minOperation ( arr ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( M - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] [ j ] == 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE for k in range ( i + 1 ) : NEW_LINE INDENT for h in range ( j + 1 ) : NEW_LINE INDENT if ( arr [ k ] [ h ] == 1 ) : NEW_LINE INDENT arr [ k ] [ h ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ k ] [ h ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT mat = [ [ 0 , 0 , 1 , 1 , 1 ] , [ 0 , 0 , 0 , 1 , 1 ] , [ 0 , 0 , 0 , 1 , 1 ] , [ 1 , 1 , 1 , 1 , 1 ] , [ 1 , 1 , 1 , 1 , 1 ] ] NEW_LINE M = 5 NEW_LINE N = 5 NEW_LINE print ( minOperation ( mat ) ) NEW_LINE"],"bleu":0.7877199511327051,"rouge_l":0.8202933985330073}
{"id":1265,"predictions":["def decToOctal ( n ) : NEW_LINE INDENT octalNum = [ 0 ] * 100 ; NEW_LINE i = 0 ; NEW_LINE while ( n ) : NEW_LINE INDENT octalNum [ i ] = n % 8 ; NEW_LINE n = n \/\/ 8 ; NEW_LINE i += 1 ; NEW_LINE DEDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( octalNum [ j ] ) ; NEW_LINE DEDENT DEDENT n = 33 ; NEW_LINE decToOctal ( n ) ; NEW_LINE"],"references":["def decToOctal ( n ) : NEW_LINE INDENT octalNum = [ 0 ] * 100 ; NEW_LINE i = 0 ; NEW_LINE while ( n != 0 ) : NEW_LINE INDENT octalNum [ i ] = n % 8 ; NEW_LINE n = int ( n \/ 8 ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( octalNum [ j ] , end = \" \" ) ; NEW_LINE DEDENT DEDENT n = 33 ; NEW_LINE decToOctal ( n ) ; NEW_LINE"],"bleu":0.8269020946493784,"rouge_l":0.9295043536503683}
{"id":1266,"predictions":["def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT def isFactorialPrime ( n ) : NEW_LINE INDENT if ( isPrime ( n ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT fact = 1 NEW_LINE i = 1 NEW_LINE while ( fact <= n + 1 ) : NEW_LINE INDENT fact = fact * i NEW_LINE if ( n + 1 == fact or n - 1 == fact ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT return False NEW_LINE DEDENT n = 23 NEW_LINE if ( isFactorialPrime ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["from math import sqrt NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 5 , int ( sqrt ( n ) ) + 1 , 6 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def isFactorialPrime ( n ) : NEW_LINE INDENT if ( not isPrime ( n ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT fact = 1 NEW_LINE i = 1 NEW_LINE while ( fact <= n + 1 ) : NEW_LINE INDENT fact = fact * i NEW_LINE if ( n + 1 == fact or n - 1 == fact ) : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 23 NEW_LINE if ( isFactorialPrime ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.8059840350578853,"rouge_l":0.878663166110835}
{"id":1267,"predictions":["def convert ( m , n ) : NEW_LINE INDENT if ( m == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( m > n ) : NEW_LINE INDENT return m - n NEW_LINE DEDENT if ( m <= 0 and n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return 1 + convert ( m , n + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return 1 + convert ( m , n \/ 2 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT m = 3 NEW_LINE n = 11 NEW_LINE print ( \" Minimum ▁ number ▁ of ▁ operations ▁ : ▁ \" , convert ( m , n ) ) NEW_LINE DEDENT"],"references":["def conver ( m , n ) : NEW_LINE INDENT if ( m == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( m > n ) : NEW_LINE INDENT return m - n NEW_LINE DEDENT if ( m <= 0 and n > 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return 1 + conver ( m , n + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return 1 + conver ( m , n \/ 2 ) NEW_LINE DEDENT DEDENT m = 3 NEW_LINE n = 11 NEW_LINE print ( \" Minimum ▁ number ▁ of ▁ operations ▁ : \" , conver ( m , n ) ) NEW_LINE"],"bleu":0.7952325472048378,"rouge_l":0.915037501536948}
{"id":1268,"predictions":["from math import sqrt NEW_LINE MAX = 1000000 NEW_LINE prime = [ True for i in range ( MAX ) ] NEW_LINE def sieve ( ) : NEW_LINE INDENT k = int ( sqrt ( MAX ) ) NEW_LINE for p in range ( 2 , k ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def printPrimeQuad ( n ) : NEW_LINE INDENT for i in range ( n - 7 ) : NEW_LINE INDENT if ( prime [ i ] and prime [ i + 2 ] and prime [ i + 6 ] and prime [ i + 8 ] ) : NEW_LINE INDENT print ( i , ( i + 2 , i + 6 ) , ( i + 6 ) , ( i + 8 ) ) NEW_LINE DEDENT DEDENT DEDENT n = 20 NEW_LINE sieve ( ) NEW_LINE printPrimeQuad ( n ) NEW_LINE"],"references":["from math import sqrt NEW_LINE MAX = 100000 NEW_LINE prime = [ True ] * MAX NEW_LINE def sieve ( ) : NEW_LINE INDENT for p in range ( 2 , int ( sqrt ( MAX ) ) + 1 ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def printPrimeQuad ( n ) : NEW_LINE INDENT for i in range ( n - 7 ) : NEW_LINE INDENT if ( prime [ i ] and prime [ i + 2 ] and prime [ i + 6 ] and prime [ i + 8 ] ) : NEW_LINE INDENT print ( i , i + 2 , i + 6 , i + 8 ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT sieve ( ) NEW_LINE n = 20 NEW_LINE printPrimeQuad ( 20 ) NEW_LINE DEDENT"],"bleu":0.7487920585423951,"rouge_l":0.8229808040565013}
{"id":1269,"predictions":["def sum ( mat , r , c ) : NEW_LINE INDENT upper_sum = 0 NEW_LINE lower_sum = 0 NEW_LINE for i in range ( r ) : NEW_LINE INDENT for j in range ( c ) : NEW_LINE INDENT if ( i <= j ) : NEW_LINE INDENT upper_sum += mat [ i ] [ j ] NEW_LINE DEDENT DEDENT print ( \" Upper ▁ sum ▁ is \" , upper_sum ) NEW_LINE for i in range ( r ) : NEW_LINE INDENT for j in range ( c ) : NEW_LINE INDENT if ( j <= i ) : NEW_LINE INDENT lower_sum += mat [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT print ( \" Lower ▁ sum ▁ is \" , lower_sum ) NEW_LINE DEDENT r = 3 NEW_LINE c = 3 NEW_LINE mat = [ [ 6 , 5 , 4 ] , [ 1 , 2 , 5 ] , [ 7 , 9 , 7 ] ] NEW_LINE sum ( mat , r , c ) NEW_LINE"],"references":["def Sum ( mat , r , c ) : NEW_LINE INDENT i , j = 0 , 0 ; NEW_LINE upper_sum = 0 ; NEW_LINE lower_sum = 0 ; NEW_LINE for i in range ( r ) : NEW_LINE INDENT for j in range ( c ) : NEW_LINE INDENT if ( i <= j ) : NEW_LINE INDENT upper_sum += mat [ i ] [ j ] ; NEW_LINE DEDENT DEDENT DEDENT print ( \" Upper ▁ sum ▁ is ▁ \" , upper_sum ) ; NEW_LINE for i in range ( r ) : NEW_LINE INDENT for j in range ( c ) : NEW_LINE INDENT if ( j <= i ) : NEW_LINE INDENT lower_sum += mat [ i ] [ j ] ; NEW_LINE DEDENT DEDENT DEDENT print ( \" Lower ▁ sum ▁ is ▁ \" , lower_sum ) ; NEW_LINE DEDENT r = 3 ; NEW_LINE c = 3 ; NEW_LINE mat = [ [ 6 , 5 , 4 ] , [ 1 , 2 , 5 ] , [ 7 , 9 , 7 ] ] ; NEW_LINE Sum ( mat , r , c ) ; NEW_LINE"],"bleu":0.7639727546403794,"rouge_l":0.9202930147379436}
{"id":1270,"predictions":["def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT def removeMin ( arr , n ) : NEW_LINE INDENT minVal = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT minVal = min ( minVal , arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = arr [ i ] - minVal NEW_LINE DEDENT DEDENT def removeFromMax ( arr , n ) : NEW_LINE INDENT maxVal = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT maxVal = max ( maxVal , arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = maxVal - arr [ i ] NEW_LINE DEDENT DEDENT def modifyArray ( arr , n , k ) : NEW_LINE INDENT if ( k % 2 == 0 ) : NEW_LINE INDENT removeMin ( arr , n ) NEW_LINE DEDENT else : NEW_LINE INDENT removeFromMax ( arr , n ) NEW_LINE DEDENT printArray ( arr , n ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 8 , 12 , 16 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE modifyArray ( arr , n , k ) NEW_LINE DEDENT"],"references":["def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT def removeMin ( arr , n ) : NEW_LINE INDENT minVal = arr [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT minVal = min ( minVal , arr [ i ] ) ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = arr [ i ] - minVal ; NEW_LINE DEDENT DEDENT def removeFromMax ( arr , n ) : NEW_LINE INDENT maxVal = arr [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT maxVal = max ( maxVal , arr [ i ] ) ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = maxVal - arr [ i ] ; NEW_LINE DEDENT DEDENT def modifyArray ( arr , n , k ) : NEW_LINE INDENT if ( k % 2 == 0 ) : NEW_LINE INDENT removeMin ( arr , n ) ; NEW_LINE DEDENT else : NEW_LINE INDENT removeFromMax ( arr , n ) ; NEW_LINE DEDENT printArray ( arr , n ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 4 , 8 , 12 , 16 ] ; NEW_LINE n = len ( arr ) NEW_LINE k = 2 ; NEW_LINE modifyArray ( arr , n , k ) ; NEW_LINE DEDENT"],"bleu":0.8625296294621589,"rouge_l":0.964528347261468}
{"id":1271,"predictions":["def LongestSubarray ( a , n , k ) : NEW_LINE INDENT pre = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] > k ) : NEW_LINE INDENT pre [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT pre [ i ] = - 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , n , 1 ) : NEW_LINE INDENT pre [ i ] = pre [ i - 1 ] + pre [ i ] NEW_LINE DEDENT len = 0 NEW_LINE lo = 1 NEW_LINE hi = n NEW_LINE while ( lo <= hi ) : NEW_LINE INDENT x = ( lo + hi ) \/\/ 2 NEW_LINE ok = False NEW_LINE for i in range ( mid - 1 , n ) : NEW_LINE INDENT x = pre [ i ] NEW_LINE if ( i - mid >= 0 ) : NEW_LINE INDENT x -= pre [ i - mid ] NEW_LINE DEDENT if ( x > 0 ) : NEW_LINE INDENT ok = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( ok == True ) : NEW_LINE INDENT len = mid NEW_LINE lo = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT hi = mid - 1 NEW_LINE DEDENT DEDENT return len NEW_LINE DEDENT a = [ 2 , 3 , 4 , 5 , 3 , 7 ] NEW_LINE k = 3 NEW_LINE n = len ( a ) NEW_LINE print ( LongestSubarray ( a , n , k ) ) NEW_LINE"],"references":["def LongestSubarray ( a , n , k ) : NEW_LINE INDENT pre = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] > k ) : NEW_LINE INDENT pre [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT pre [ i ] = - 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT pre [ i ] = pre [ i - 1 ] + pre [ i ] NEW_LINE DEDENT Len = 0 NEW_LINE lo = 1 NEW_LINE hi = n NEW_LINE while ( lo <= hi ) : NEW_LINE INDENT mid = ( lo + hi ) \/\/ 2 NEW_LINE ok = False NEW_LINE for i in range ( mid - 1 , n ) : NEW_LINE INDENT x = pre [ i ] NEW_LINE if ( i - mid >= 0 ) : NEW_LINE INDENT x -= pre [ i - mid ] NEW_LINE DEDENT if ( x > 0 ) : NEW_LINE INDENT ok = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( ok == True ) : NEW_LINE INDENT Len = mid NEW_LINE lo = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT hi = mid - 1 NEW_LINE DEDENT DEDENT return Len NEW_LINE DEDENT a = [ 2 , 3 , 4 , 5 , 3 , 7 ] NEW_LINE k = 3 NEW_LINE n = len ( a ) NEW_LINE print ( LongestSubarray ( a , n , k ) ) NEW_LINE"],"bleu":0.922786377195922,"rouge_l":0.9633749155042095}
{"id":1272,"predictions":["def findSum ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = ans + ( i \/\/ j ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT N = 2 NEW_LINE print ( findSum ( N ) ) NEW_LINE"],"references":["def findSum ( N ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 1 , N + 1 ) : NEW_LINE INDENT ans += i \/\/ j NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT N = 2 NEW_LINE print ( findSum ( N ) ) NEW_LINE"],"bleu":0.7640030276007997,"rouge_l":0.914085914085914}
{"id":1273,"predictions":["def permutation ( arr , n ) : NEW_LINE INDENT hash = set ( ) NEW_LINE maxEle = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash . add ( arr [ i ] ) NEW_LINE maxEle = max ( maxEle , arr [ i ] ) NEW_LINE DEDENT if ( maxEle != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( len ( hash ) == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 5 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE if ( permutation ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def permutation ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE maxEle = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . add ( arr [ i ] ) ; NEW_LINE maxEle = max ( maxEle , arr [ i ] ) ; NEW_LINE DEDENT if ( maxEle != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( len ( s ) == n ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 5 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE if ( permutation ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.8703297972483811,"rouge_l":0.9618416903185115}
{"id":1274,"predictions":["N = 5 NEW_LINE def printHosoya ( n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( N ) ] for i in range ( N ) ] NEW_LINE dp [ 0 ] [ 0 ] = dp [ 1 ] [ 0 ] = 1 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( i > j ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 2 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 2 ] [ j - 2 ] ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT print ( dp [ i ] [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( \" \" ) NEW_LINE DEDENT DEDENT n = 5 NEW_LINE printHosoya ( n ) NEW_LINE"],"references":["N = 5 NEW_LINE def printHosoya ( n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( N ) ] for i in range ( N ) ] NEW_LINE dp [ 0 ] [ 0 ] = dp [ 1 ] [ 0 ] = dp [ 1 ] [ 1 ] = 1 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( i > j ) : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + dp [ i - 2 ] [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 2 ] [ j - 2 ] ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT print ( dp [ i ] [ j ] , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT n = 5 NEW_LINE printHosoya ( n ) NEW_LINE"],"bleu":0.9162894234875507,"rouge_l":0.9593831119254849}
{"id":1275,"predictions":["def pairs_count ( arr , n , sum ) : NEW_LINE INDENT ans = 0 NEW_LINE arr . sort ( ) NEW_LINE i = 0 NEW_LINE j = n - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] < sum ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT elif ( arr [ i ] + arr [ j ] > sum ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT y = arr [ j ] NEW_LINE xxy = j NEW_LINE while ( ( i < j ) and ( arr [ i ] == x ) ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT if ( x == y ) : NEW_LINE INDENT temp = i - xx + yy - j - 1 NEW_LINE ans += ( temp * ( temp + 1 ) ) \/\/ 2 NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( i - xx ) * ( yy - j ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 5 , 7 , 5 , - 1 ] NEW_LINE n = len ( arr ) NEW_LINE sum = 6 NEW_LINE print ( pairs_count ( arr , n , sum ) ) NEW_LINE"],"references":["def pairs_count ( arr , n , sum ) : NEW_LINE INDENT ans = 0 NEW_LINE arr = sorted ( arr ) NEW_LINE i , j = 0 , n - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] < sum ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT elif ( arr [ i ] + arr [ j ] > sum ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT x = arr [ i ] NEW_LINE xx = i NEW_LINE while ( i < j and arr [ i ] == x ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT y = arr [ j ] NEW_LINE yy = j NEW_LINE while ( j >= i and arr [ j ] == y ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT if ( x == y ) : NEW_LINE INDENT temp = i - xx + yy - j - 1 NEW_LINE ans += ( temp * ( temp + 1 ) ) \/\/ 2 NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( i - xx ) * ( yy - j ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 5 , 7 , 5 , - 1 ] NEW_LINE n = len ( arr ) NEW_LINE sum = 6 NEW_LINE print ( pairs_count ( arr , n , sum ) ) NEW_LINE"],"bleu":0.7815834515643806,"rouge_l":0.865871219913598}
{"id":1276,"predictions":["MAX = 100005 NEW_LINE fibonacci = set ( ) NEW_LINE def createHash ( ) : NEW_LINE INDENT prev = 0 NEW_LINE curr = 1 NEW_LINE fibonacci . add ( prev ) NEW_LINE fibonacci . add ( curr ) NEW_LINE while ( curr <= MAX ) : NEW_LINE INDENT temp = curr + prev NEW_LINE fibonacci . add ( temp ) NEW_LINE prev = curr NEW_LINE curr = temp NEW_LINE DEDENT DEDENT def checkArray ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] in fibonacci ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT DEDENT if ( sum in fibonacci ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 8 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE createHash ( ) NEW_LINE if ( checkArray ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["MAX = 100005 NEW_LINE fibonacci = set ( ) NEW_LINE def createHash ( ) : NEW_LINE INDENT global fibonacci NEW_LINE prev , curr = 0 , 1 NEW_LINE fibonacci . add ( prev ) NEW_LINE fibonacci . add ( curr ) NEW_LINE while ( curr <= MAX ) : NEW_LINE INDENT temp = curr + prev NEW_LINE if temp <= MAX : NEW_LINE INDENT fibonacci . add ( temp ) NEW_LINE DEDENT prev = curr NEW_LINE curr = temp NEW_LINE DEDENT DEDENT def checkArray ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] in fibonacci ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT DEDENT if ( sum in fibonacci ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 8 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE createHash ( ) NEW_LINE if ( checkArray ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.907437837670594,"rouge_l":0.9549065420560748}
{"id":1277,"predictions":["def makearray ( arr , n ) : NEW_LINE INDENT x = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT x += ( arr [ i ] & 1 ) ; NEW_LINE DEDENT print ( min ( x , n - x ) ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 4 , 3 , 2 , 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE makearray ( arr , n ) ; NEW_LINE DEDENT"],"references":["def makearrayequal ( arr , n ) : NEW_LINE INDENT x = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT x += arr [ i ] & 1 ; NEW_LINE DEDENT print ( min ( x , n - x ) ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 4 , 3 , 2 , 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE makearrayequal ( arr , n ) ; NEW_LINE DEDENT"],"bleu":0.9007445763509232,"rouge_l":0.969945832605277}
{"id":1278,"predictions":["def countRotations ( arr , n ) : NEW_LINE INDENT min_index = arr [ 0 ] NEW_LINE min_index = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( min > arr [ i ] ) : NEW_LINE INDENT min_index = arr [ i ] NEW_LINE min_index = i NEW_LINE DEDENT DEDENT return min_index NEW_LINE DEDENT arr = [ 15 , 18 , 2 , 3 , 6 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countRotations ( arr , n ) ) NEW_LINE"],"references":["def countRotations ( arr , n ) : NEW_LINE INDENT min = arr [ 0 ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( min > arr [ i ] ) : NEW_LINE INDENT min = arr [ i ] NEW_LINE min_index = i NEW_LINE DEDENT DEDENT return min_index ; NEW_LINE DEDENT arr = [ 15 , 18 , 2 , 3 , 6 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countRotations ( arr , n ) ) NEW_LINE"],"bleu":0.850250509613707,"rouge_l":0.9373013069586718}
{"id":1279,"predictions":["def check ( s ) : NEW_LINE INDENT freq = [ 0 ] * 10 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT freq [ i ] = 0 NEW_LINE DEDENT while ( s != 0 ) : NEW_LINE INDENT r = s % 10 NEW_LINE s = ( s \/\/ 10 ) NEW_LINE freq [ r ] += 1 NEW_LINE DEDENT xor_ = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT xor_ = xor_ ^ freq [ i ] NEW_LINE if ( xor_ == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = 122233 NEW_LINE if ( check ( s ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def check ( s ) : NEW_LINE INDENT freq = [ 0 ] * 10 NEW_LINE while ( s != 0 ) : NEW_LINE INDENT r = s % 10 NEW_LINE s = s \/\/ 10 NEW_LINE freq [ r ] += 1 NEW_LINE DEDENT xor = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT xor = xor ^ freq [ i ] NEW_LINE DEDENT if ( xor == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT s = 122233 NEW_LINE if ( check ( s ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.6655623074051986,"rouge_l":0.8561403508771931}
{"id":1280,"predictions":["def count ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE p = 1 NEW_LINE while ( p <= n ) : NEW_LINE INDENT cnt += 1 NEW_LINE p *= 2 NEW_LINE DEDENT return cnt NEW_LINE DEDENT n = 7 NEW_LINE print ( count ( n ) ) NEW_LINE"],"references":["def count ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE p = 1 NEW_LINE while ( p <= n ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE p *= 2 NEW_LINE DEDENT return cnt NEW_LINE DEDENT n = 7 NEW_LINE print ( count ( n ) ) ; NEW_LINE"],"bleu":0.8787901177996896,"rouge_l":0.9464851171627613}
{"id":1281,"predictions":["def powerSet ( string , index , curr ) : NEW_LINE INDENT n = len ( string ) NEW_LINE if ( index == n ) : NEW_LINE INDENT return NEW_LINE DEDENT print ( curr ) NEW_LINE for i in range ( index + 1 , n ) : NEW_LINE INDENT curr += string [ i ] NEW_LINE powerSet ( string , i , curr ) NEW_LINE curr = curr [ : len ( curr ) - 1 ] NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s1 = \" abc \" NEW_LINE index = - 1 NEW_LINE curr = \" \" NEW_LINE powerSet ( s1 , index , curr ) ; NEW_LINE DEDENT"],"references":["def powerSet ( str1 , index , curr ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE if ( index == n ) : NEW_LINE INDENT return NEW_LINE DEDENT print ( curr ) NEW_LINE for i in range ( index + 1 , n ) : NEW_LINE INDENT curr += str1 [ i ] NEW_LINE powerSet ( str1 , i , curr ) NEW_LINE curr = curr . replace ( curr [ len ( curr ) - 1 ] , \" \" ) NEW_LINE DEDENT return NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" abc \" ; NEW_LINE powerSet ( str , - 1 , \" \" ) NEW_LINE DEDENT"],"bleu":0.6511280246523805,"rouge_l":0.8142105972765269}
{"id":1282,"predictions":["def findMinimumX ( a , n ) : NEW_LINE INDENT st = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT st . add ( a [ i ] ) NEW_LINE DEDENT if ( len ( st ) == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( len ( st ) == 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( len ( st ) == 2 ) : NEW_LINE INDENT elif ( el - el1 ) == 2 : NEW_LINE INDENT return ( el2 - el1 ) \/ 2 NEW_LINE DEDENT else : NEW_LINE INDENT return ( el2 - el1 ) NEW_LINE DEDENT DEDENT if ( len ( st ) == 3 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT a = [ 1 , 4 , 4 , 7 , 4 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( findMinimumX ( a , n ) ) NEW_LINE"],"references":["def findMinimumX ( a , n ) : NEW_LINE INDENT st = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT st . add ( a [ i ] ) NEW_LINE DEDENT if ( len ( st ) == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( len ( st ) == 2 ) : NEW_LINE INDENT st = list ( st ) NEW_LINE el1 = st [ 0 ] NEW_LINE el2 = st [ 1 ] NEW_LINE if ( ( el2 - el1 ) % 2 == 0 ) : NEW_LINE INDENT return int ( ( el2 - el1 ) \/ 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( el2 - el1 ) NEW_LINE DEDENT DEDENT if ( len ( st ) == 3 ) : NEW_LINE INDENT st = list ( st ) NEW_LINE el1 = st [ 0 ] NEW_LINE el2 = st [ 1 ] NEW_LINE el3 = st [ 2 ] NEW_LINE if ( ( el2 - el1 ) == ( el3 - el2 ) ) : NEW_LINE INDENT return el2 - el1 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 4 , 4 , 7 , 4 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( findMinimumX ( a , n ) ) NEW_LINE DEDENT"],"bleu":0.5820713609717334,"rouge_l":0.7371058060713234}
{"id":1283,"predictions":["def printFirstNegativeInteger ( arr , n , k ) : NEW_LINE INDENT for i in range ( 0 , ( n - k + 1 ) ) : NEW_LINE INDENT flag = False NEW_LINE for j in range ( 0 , k ) : NEW_LINE INDENT if ( arr [ i + j ] < 0 ) : NEW_LINE INDENT print ( ( arr [ i + j ] , end = \" ▁ \" ) , end = \" \" ) NEW_LINE flag = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( not flag ) : NEW_LINE INDENT print ( 0 , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 12 , - 1 , - 7 , 8 , - 15 , 30 , 16 , 28 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE printFirstNegativeInteger ( arr , n , k ) NEW_LINE"],"references":["def printFirstNegativeInteger ( arr , n , k ) : NEW_LINE INDENT for i in range ( 0 , ( n - k + 1 ) ) : NEW_LINE INDENT flag = False NEW_LINE for j in range ( 0 , k ) : NEW_LINE INDENT if ( arr [ i + j ] < 0 ) : NEW_LINE INDENT print ( arr [ i + j ] , end = \" ▁ \" ) NEW_LINE flag = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( not ( flag ) ) : NEW_LINE INDENT print ( \"0\" , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 12 , - 1 , - 7 , 8 , - 15 , 30 , 16 , 28 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE printFirstNegativeInteger ( arr , n , k ) NEW_LINE"],"bleu":0.9221525862009772,"rouge_l":0.9670094258783205}
{"id":1284,"predictions":["def printArray ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def printSequencesRecur ( arr , n , k , index ) : NEW_LINE INDENT if k == 0 : NEW_LINE INDENT printArray ( arr , index ) NEW_LINE DEDENT if k > 0 : NEW_LINE INDENT for i in range ( 1 , n + 1 , index + 1 ) : NEW_LINE INDENT arr [ index ] = i NEW_LINE printSequencesRecur ( arr , n , k - 1 , index + 1 ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE k = 2 NEW_LINE printSequencesRecur ( arr , n , k ) NEW_LINE DEDENT"],"references":["def printArray ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( \" \" ) ; NEW_LINE return ; NEW_LINE DEDENT def printSequencesRecur ( arr , n , k , index ) : NEW_LINE INDENT if ( k == 0 ) : NEW_LINE INDENT printArray ( arr , index ) ; NEW_LINE DEDENT if ( k > 0 ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT arr [ index ] = i ; NEW_LINE printSequencesRecur ( arr , n , k - 1 , index + 1 ) ; NEW_LINE DEDENT DEDENT DEDENT def printSequences ( n , k ) : NEW_LINE INDENT arr = [ 0 ] * n ; NEW_LINE printSequencesRecur ( arr , n , k , 0 ) ; NEW_LINE return ; NEW_LINE DEDENT n = 3 ; NEW_LINE k = 2 ; NEW_LINE printSequences ( n , k ) ; NEW_LINE"],"bleu":0.6109935546137908,"rouge_l":0.7815958066394874}
{"id":1285,"predictions":["from collections import defaultdict NEW_LINE no_of_chars = 256 NEW_LINE def findSubString ( string , pat ) : NEW_LINE INDENT len1 = len ( string ) NEW_LINE len2 = len ( pat ) NEW_LINE if ( len1 < len2 ) : NEW_LINE INDENT print ( \" No ▁ such ▁ window ▁ exists \" ) NEW_LINE return \" \" NEW_LINE DEDENT hash_pat = [ 0 for i in range ( no_of_chars ) ] NEW_LINE for i in range ( len1 ) : NEW_LINE INDENT hash_pat [ ord ( string [ i ] ) ] += 1 NEW_LINE DEDENT start = 0 NEW_LINE start_index = - 1 NEW_LINE min_len = sys . maxsize NEW_LINE count = 0 NEW_LINE for j in range ( len1 ) : NEW_LINE INDENT hash_str [ ord ( string [ j ] ) ] += 1 NEW_LINE if ( hash_pat [ ord ( string [ j ] ) ] != 0 and hash_str [ ord ( string [ j ] ) ] <= hash_pat [ ord ( string [ j ] ) ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( count == len2 ) : NEW_LINE INDENT while ( hash_str [ ord ( string [ start ] ) ] > hash_pat [ ord ( string [ start ] ) ] > hash_pat [ ord ( string [ start ] ) ] ) : NEW_LINE INDENT hash_str [ ord ( string [ start ] ) ] -= 1 NEW_LINE DEDENT start += 1 NEW_LINE DEDENT len_window = j - start + 1 NEW_LINE if ( min_len > len_window ) : NEW_LINE INDENT min_len = len_window NEW_LINE start_index = start NEW_LINE DEDENT DEDENT if ( start_index == len_window ) : NEW_LINE INDENT min_len = len_window NEW_LINE start_index = start NEW_LINE DEDENT DEDENT if ( start_index == len_window ) : NEW_LINE INDENT print ( \" No ▁ such ▁ window ▁ exists \" ) NEW_LINE return \" \" NEW_LINE DEDENT if __name__"],"references":["no_of_chars = 256 NEW_LINE def findSubString ( string , pat ) : NEW_LINE INDENT len1 = len ( string ) NEW_LINE len2 = len ( pat ) NEW_LINE if len1 < len2 : NEW_LINE INDENT print ( \" No ▁ such ▁ window ▁ exists \" ) NEW_LINE return \" \" NEW_LINE DEDENT hash_pat = [ 0 ] * no_of_chars NEW_LINE hash_str = [ 0 ] * no_of_chars NEW_LINE for i in range ( 0 , len2 ) : NEW_LINE INDENT hash_pat [ ord ( pat [ i ] ) ] += 1 NEW_LINE DEDENT start , start_index , min_len = 0 , - 1 , float ( ' inf ' ) NEW_LINE count = 0 NEW_LINE for j in range ( 0 , len1 ) : NEW_LINE INDENT hash_str [ ord ( string [ j ] ) ] += 1 NEW_LINE if ( hash_pat [ ord ( string [ j ] ) ] != 0 and hash_str [ ord ( string [ j ] ) ] <= hash_pat [ ord ( string [ j ] ) ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if count == len2 : NEW_LINE INDENT while ( hash_str [ ord ( string [ start ] ) ] > hash_pat [ ord ( string [ start ] ) ] or hash_pat [ ord ( string [ start ] ) ] == 0 ) : NEW_LINE INDENT if ( hash_str [ ord ( string [ start ] ) ] > hash_pat [ ord ( string [ start ] ) ] ) : NEW_LINE INDENT hash_str [ ord ( string [ start ] ) ] -= 1 NEW_LINE DEDENT start += 1 NEW_LINE DEDENT len_window = j - start + 1 NEW_LINE if min_len > len_window : NEW_LINE INDENT min_len = len_window NEW_LINE start_index = start NEW_LINE DEDENT DEDENT DEDENT if start_index == - 1 : NEW_LINE INDENT print ( \" No ▁ such ▁ window ▁ exists \" ) NEW_LINE return \" \" NEW_LINE DEDENT return string [ start_index : start_index + min_len ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" this ▁ is ▁ a ▁ test ▁ string \" NEW_LINE pat = \" tist \" NEW_LINE print ( \" Smallest ▁ window ▁ is ▁ : ▁ \" ) NEW_LINE print ( findSubString ( string , pat ) ) NEW_LINE DEDENT"],"bleu":0.6411924208232695,"rouge_l":0.7462435175745754}
{"id":1286,"predictions":["def productArray ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT print ( \"0\" ) NEW_LINE return NEW_LINE DEDENT temp = 1 NEW_LINE prod = [ 1 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT prod [ i ] = temp NEW_LINE temp *= arr [ i ] NEW_LINE DEDENT temp = 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT prod [ i ] *= temp NEW_LINE temp *= arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( prod [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 10 , 3 , 5 , 6 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" The ▁ product ▁ array ▁ is : \" ) NEW_LINE productArray ( arr , n ) NEW_LINE"],"references":["def productArray ( arr , n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE return NEW_LINE DEDENT i , temp = 1 , 1 NEW_LINE prod = [ 1 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT prod [ i ] = temp NEW_LINE temp *= arr [ i ] NEW_LINE DEDENT temp = 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT prod [ i ] *= temp NEW_LINE temp *= arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( prod [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT return NEW_LINE DEDENT arr = [ 10 , 3 , 5 , 6 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" The ▁ product ▁ array ▁ is : ▁ n \" ) NEW_LINE productArray ( arr , n ) NEW_LINE"],"bleu":0.8938372393901458,"rouge_l":0.9631578947368421}
{"id":1287,"predictions":["def NoofTriplets ( N , K ) : NEW_LINE INDENT cnt = [ 0 for i in range ( K + 1 ) ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT cnt [ i % K ] += 1 NEW_LINE DEDENT if ( K & 1 ) : NEW_LINE INDENT return cnt [ 0 ] * cnt [ 0 ] * cnt [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT return ( cnt [ 0 ] * cnt [ 0 ] + cnt [ 0 ] * cnt [ K \/\/ 2 ] * cnt [ K \/\/ 2 ] ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 3 NEW_LINE K = 2 NEW_LINE print ( NoofTriplets ( N , K ) ) NEW_LINE DEDENT"],"references":["def NoofTriplets ( N , K ) : NEW_LINE INDENT cnt = [ 0 ] * K ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT cnt [ i % K ] += 1 ; NEW_LINE DEDENT if ( K & 1 ) : NEW_LINE INDENT rslt = cnt [ 0 ] * cnt [ 0 ] * cnt [ 0 ] ; NEW_LINE return rslt NEW_LINE DEDENT else : NEW_LINE INDENT rslt = ( cnt [ 0 ] * cnt [ 0 ] * cnt [ 0 ] + cnt [ K \/\/ 2 ] * cnt [ K \/\/ 2 ] * cnt [ K \/\/ 2 ] ) ; NEW_LINE return rslt NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 3 ; K = 2 ; NEW_LINE print ( NoofTriplets ( N , K ) ) ; NEW_LINE DEDENT"],"bleu":0.7449690643991067,"rouge_l":0.8612685848753878}
{"id":1288,"predictions":["def process ( arr , a , b ) : NEW_LINE INDENT arr [ a ] ^= True NEW_LINE arr [ b + 1 ] ^= True NEW_LINE DEDENT def process ( arr , n ) : NEW_LINE INDENT for k in range ( 1 , n + 1 ) : NEW_LINE INDENT arr [ k ] ^= arr [ k - 1 ] NEW_LINE DEDENT DEDENT def result ( arr , n ) : NEW_LINE INDENT for k in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( arr [ k ] == True ) : NEW_LINE INDENT print ( \"1\" , end = \" ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE m = 3 NEW_LINE arr = [ 0 for i in range ( n + 2 ) ] NEW_LINE command ( arr , 1 , 5 ) NEW_LINE query ( arr , n ) NEW_LINE result ( arr , n ) NEW_LINE DEDENT"],"references":["def command ( brr , a , b ) : NEW_LINE INDENT arr [ a ] ^= 1 NEW_LINE arr [ b + 1 ] ^= 1 NEW_LINE DEDENT def process ( arr , n ) : NEW_LINE INDENT for k in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT arr [ k ] ^= arr [ k - 1 ] NEW_LINE DEDENT DEDENT def result ( arr , n ) : NEW_LINE INDENT for k in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT print ( arr [ k ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE m = 3 NEW_LINE arr = [ 0 for i in range ( n + 2 ) ] NEW_LINE command ( arr , 1 , 5 ) NEW_LINE command ( arr , 2 , 5 ) NEW_LINE command ( arr , 3 , 5 ) NEW_LINE process ( arr , n ) NEW_LINE result ( arr , n ) NEW_LINE DEDENT"],"bleu":0.8054591553732068,"rouge_l":0.8445266144982372}
{"id":1289,"predictions":["def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while n : NEW_LINE INDENT n &= ( n - 1 ) NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def countSetBitsInGivenRange ( n , l , r ) : NEW_LINE INDENT num = ( ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ) NEW_LINE return countSetBits ( n & num ) NEW_LINE DEDENT n = 42 NEW_LINE l = 2 NEW_LINE r = 5 NEW_LINE print ( countSetBitsInGivenRange ( n , l , r ) ) NEW_LINE"],"references":["def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT n &= ( n - 1 ) NEW_LINE count = count + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def countSetBitsInGivenRange ( n , l , r ) : NEW_LINE INDENT num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) NEW_LINE return countSetBits ( n & num ) NEW_LINE DEDENT n = 42 NEW_LINE l = 2 NEW_LINE r = 5 NEW_LINE ans = countSetBitsInGivenRange ( n , l , r ) NEW_LINE print ( ans ) NEW_LINE"],"bleu":0.8469890492458862,"rouge_l":0.9227346878244104}
{"id":1290,"predictions":["def dig ( a ) : NEW_LINE INDENT count = 0 NEW_LINE while ( a > 0 ) : NEW_LINE INDENT a \/\/= 10 NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def required_number ( num , n , d ) : NEW_LINE INDENT power = 1 NEW_LINE a = a NEW_LINE flag = 0 NEW_LINE for i in range ( num , 0 , - 1 ) : NEW_LINE INDENT power = pow ( 10 , i ) NEW_LINE a = n % power NEW_LINE if ( d > a ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT t = 0 NEW_LINE for j in range ( 0 , i ) : NEW_LINE INDENT t += 9 * pow ( 10 , j ) NEW_LINE DEDENT if ( n % power == t ) : NEW_LINE INDENT print ( n , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n - ( n % power ) - 1 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 1029 NEW_LINE d = 102 NEW_LINE num = dig ( n ) NEW_LINE required_number ( num , n , d ) NEW_LINE DEDENT"],"references":["def dig ( a ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( a > 0 ) : NEW_LINE INDENT a \/= 10 NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def required_number ( num , n , d ) : NEW_LINE INDENT flag = 0 NEW_LINE power = 0 NEW_LINE a = 0 NEW_LINE for i in range ( num , 0 , - 1 ) : NEW_LINE INDENT power = pow ( 10 , i ) NEW_LINE a = n % power NEW_LINE if ( d > a ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT t = 0 NEW_LINE for j in range ( 0 , i ) : NEW_LINE INDENT t += 9 * pow ( 10 , j ) NEW_LINE DEDENT if ( n % power == t ) : NEW_LINE INDENT print ( n , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( n - ( n % power ) - 1 ) , end = \" \" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( n , end = \" \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 1029 NEW_LINE d = 102 NEW_LINE num = dig ( n ) NEW_LINE required_number ( num , n , d ) NEW_LINE DEDENT"],"bleu":0.8886180675614048,"rouge_l":0.9424748241136709}
{"id":1291,"predictions":["def CountZeroBit ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def CountORandSumEqual ( N ) : NEW_LINE INDENT count = CountZeroBit ( N ) NEW_LINE return ( 1 << count ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 10 NEW_LINE print ( CountORandSumEqual ( N ) ) NEW_LINE DEDENT"],"references":["def CountZeroBit ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT if ( not ( n & 1 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def CountORandSumEqual ( N ) : NEW_LINE INDENT count = CountZeroBit ( N ) NEW_LINE return ( 1 << count ) NEW_LINE DEDENT N = 10 NEW_LINE print ( CountORandSumEqual ( N ) ) NEW_LINE"],"bleu":0.8110954536275478,"rouge_l":0.9111542192046558}
{"id":1292,"predictions":["def checkConcurrent ( a1 , b1 , c1 , a2 , b2 , c2 , a3 , b3 , c3 ) : NEW_LINE INDENT return ( a3 * ( b1 * c2 - b2 * c1 ) + b3 * ( c1 * a2 - c2 * a1 ) + c3 * ( a1 * b2 - a2 * b1 ) == 0 ) ; NEW_LINE DEDENT a1 = 2 ; b1 = - 3 ; NEW_LINE c2 = 4 ; NEW_LINE a3 = 9 ; b3 = - 5 ; c3 = 8 ; NEW_LINE if ( checkConcurrent ( a1 , b1 , c1 , a2 , b2 , c2 , a3 , b3 ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT"],"references":["def checkConcurrent ( a1 , b1 , c1 , a2 , b2 , c2 , a3 , b3 , c3 ) : NEW_LINE INDENT return ( a3 * ( b1 * c2 - b2 * c1 ) + b3 * ( c1 * a2 - c2 * a1 ) + c3 * ( a1 * b2 - a2 * b1 ) == 0 ) NEW_LINE DEDENT a1 = 2 NEW_LINE b1 = - 3 NEW_LINE c1 = 5 NEW_LINE a2 = 3 NEW_LINE b2 = 4 NEW_LINE c2 = - 7 NEW_LINE a3 = 9 NEW_LINE b3 = - 5 NEW_LINE c3 = 8 NEW_LINE if ( checkConcurrent ( a1 , b1 , c1 , a2 , b2 , c2 , a3 , b3 , c3 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.7733836321489609,"rouge_l":0.8960605386156243}
{"id":1293,"predictions":["def winner ( moves ( moves ) : NEW_LINE INDENT d = { } NEW_LINE data [ ' R ' , ' P ' ] = 0 NEW_LINE d [ ' S ' ] = 1 NEW_LINE if ( moves [ 0 ] == moves [ 1 ] ) : NEW_LINE INDENT return \" Draw \" NEW_LINE DEDENT if ( ( d [ moves [ 0 ] ] | 1 << ( 2 ) ) - ( data [ 1 ] ] | 0 ) ) % 3 != 0 : NEW_LINE INDENT return \" A \" NEW_LINE DEDENT return \" B \" NEW_LINE DEDENT def performQueries ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( winner ( arr [ i ] ) | \"0\" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ \" RS \" , \" sr \" , \" SP \" , \" SP \" , \" PP \" ] NEW_LINE n = len ( arr ) NEW_LINE performQueries ( arr , n ) NEW_LINE DEDENT"],"references":["def winner ( moves ) : NEW_LINE INDENT data = dict ( ) NEW_LINE data [ ' R ' ] = 0 NEW_LINE data [ ' P ' ] = 1 NEW_LINE data [ ' S ' ] = 2 NEW_LINE if ( moves [ 0 ] == moves [ 1 ] ) : NEW_LINE INDENT return \" Draw \" NEW_LINE DEDENT if ( ( ( data [ moves [ 0 ] ] | 1 << ( 2 ) ) - ( data [ moves [ 1 ] ] | 0 << ( 2 ) ) ) % 3 ) : NEW_LINE INDENT return \" A \" NEW_LINE DEDENT return \" B \" NEW_LINE DEDENT def performQueries ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( winner ( arr [ i ] ) ) NEW_LINE DEDENT DEDENT arr = [ \" RS \" , \" SR \" , \" SP \" , \" PP \" ] NEW_LINE n = len ( arr ) NEW_LINE performQueries ( arr , n ) NEW_LINE"],"bleu":0.754744892480374,"rouge_l":0.8543868921775899}
{"id":1294,"predictions":["MAX = 100000 NEW_LINE catalan = [ 0 for i in range ( MAX ) ] NEW_LINE def catalanSequence ( n ) : NEW_LINE INDENT catalan [ 0 ] = 0 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT catalan [ i ] = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT catalan [ i ] += ( catalan [ j ] * catalan [ i - j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT def narSequence ( arr , n ) : NEW_LINE INDENT catalanDP ( n ) NEW_LINE s = set ( ) NEW_LINE a , b = 1 , 1 NEW_LINE s . add ( a ) NEW_LINE if ( n >= 2 ) : NEW_LINE INDENT s . add ( b ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in s : NEW_LINE INDENT s . remove ( c ) NEW_LINE DEDENT DEDENT return len ( s ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 1 , 2 , 5 , 41 ] NEW_LINE n = len ( arr ) NEW_LINE print ( NobleSequence ( arr , n ) ) NEW_LINE DEDENT"],"references":["MAX = 100000 ; NEW_LINE catalan = [ 0 ] * MAX ; NEW_LINE def catalanDP ( n ) : NEW_LINE INDENT catalan [ 0 ] = catalan [ 1 ] = 1 ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT catalan [ i ] = 0 ; NEW_LINE for j in range ( i ) : NEW_LINE INDENT catalan [ i ] += ( catalan [ j ] * catalan [ i - j - 1 ] ) ; NEW_LINE DEDENT DEDENT DEDENT def CatalanSequence ( arr , n ) : NEW_LINE INDENT catalanDP ( n ) ; NEW_LINE s = set ( ) ; NEW_LINE a = 1 ; b = 1 ; NEW_LINE s . add ( a ) ; NEW_LINE if ( n >= 2 ) : NEW_LINE INDENT s . add ( b ) ; NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT s . add ( catalan [ i ] ) ; NEW_LINE DEDENT temp = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in s : NEW_LINE INDENT temp . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT s = s - temp ; NEW_LINE return len ( s ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 1 , 2 , 5 , 41 ] ; NEW_LINE n = len ( arr ) NEW_LINE print ( CatalanSequence ( arr , n ) ) ; NEW_LINE DEDENT"],"bleu":0.62117456160847,"rouge_l":0.8007017999870036}
{"id":1295,"predictions":["def removeAnagrams ( arr , N ) : NEW_LINE INDENT ans = [ ] NEW_LINE found = True NEW_LINE for i in arr : NEW_LINE INDENT word = arr [ i ] NEW_LINE word = arr [ i ] NEW_LINE if word not in found : NEW_LINE INDENT ans . append ( arr [ i ] ) NEW_LINE found . append ( word ) NEW_LINE DEDENT DEDENT ans . sort ( ) NEW_LINE for i in range ( len ( ans ) ) : NEW_LINE INDENT print ( ans [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ \" geeks \" , \" eegs \" NEW_LINE N = 4 NEW_LINE removeAnagrams ( arr , N ) NEW_LINE DEDENT"],"references":["def removeAnagrams ( arr , N ) : NEW_LINE INDENT ans = [ ] NEW_LINE found = dict ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT word = arr [ i ] NEW_LINE word = \" ▁ \" . join ( sorted ( word ) ) NEW_LINE if ( word not in found ) : NEW_LINE INDENT ans . append ( arr [ i ] ) NEW_LINE found [ word ] = 1 NEW_LINE DEDENT DEDENT ans = sorted ( ans ) NEW_LINE for i in range ( len ( ans ) ) : NEW_LINE INDENT print ( ans [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ \" geeks \" , \" keegs \" , \" code \" , \" doce \" ] NEW_LINE N = 4 NEW_LINE removeAnagrams ( arr , N ) NEW_LINE DEDENT"],"bleu":0.6910973249677238,"rouge_l":0.8214824391294979}
{"id":1296,"predictions":["def findMaximumNum ( arr , n ) : NEW_LINE INDENT for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( i <= arr [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count >= i ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 8 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMaximumNum ( arr , n ) ) NEW_LINE"],"references":["def findMaximumNum ( arr , n ) : NEW_LINE INDENT i = n NEW_LINE while ( i >= 1 ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( i <= arr [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count >= i ) : NEW_LINE INDENT return i NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 8 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMaximumNum ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.7094233609043519,"rouge_l":0.8318953520734763}
{"id":1297,"predictions":["def printSubArrays ( arr , start , end ) : NEW_LINE INDENT if ( end == \" ▁ \" ) : NEW_LINE INDENT return NEW_LINE DEDENT elif ( start > end ) : NEW_LINE INDENT print ( \" \" , end = \" \" ) NEW_LINE for i in range ( start , end ) : NEW_LINE INDENT print ( arr [ i ] , end = \" , ▁ \" ) NEW_LINE DEDENT print ( arr [ end ] , end = \" \" ) NEW_LINE print ( arr [ end ] , end = \" ) NEW_LINE printSubArrays ( arr , start + 1 , end ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 ] NEW_LINE printSubArrays ( arr , 0 , 0 ) NEW_LINE DEDENT"],"references":["def printSubArrays ( arr , start , end ) : NEW_LINE INDENT if end == len ( arr ) : NEW_LINE INDENT return NEW_LINE DEDENT elif start > end : NEW_LINE INDENT return printSubArrays ( arr , 0 , end + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ start : end + 1 ] ) NEW_LINE return printSubArrays ( arr , start + 1 , end ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 ] NEW_LINE printSubArrays ( arr , 0 , 0 ) NEW_LINE"],"bleu":0.424430400217683,"rouge_l":0.670138393494079}
{"id":1298,"predictions":["import math NEW_LINE def setBit ( xorValue ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( xorValue >= 1 ) : NEW_LINE INDENT if ( xorValue % 2 == 1 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT xorValue \/= 2 ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT def minFlip ( n , k ) : NEW_LINE INDENT size = int ( math . log ( n , k ) ) + 1 ; NEW_LINE max = int ( math . pow ( 2 , k ) ) - 1 ; NEW_LINE xorValue = ( n ^ max ) ; NEW_LINE return ( setBit ( xorValue ) ) ; NEW_LINE DEDENT n = 27 ; NEW_LINE k = 3 ; NEW_LINE print ( \" Min ▁ Flip ▁ = ▁ \" , minFlip ( n , k ) ) ; NEW_LINE"],"references":["import math NEW_LINE def setBit ( xorValue ) : NEW_LINE INDENT count = 0 NEW_LINE while ( xorValue ) : NEW_LINE INDENT if ( xorValue % 2 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT xorValue = int ( xorValue \/ 2 ) NEW_LINE DEDENT return count NEW_LINE DEDENT def minFlip ( n , k ) : NEW_LINE INDENT size = int ( math . log ( n ) \/ math . log ( 2 ) + 1 ) NEW_LINE max = pow ( 2 , k ) - 1 NEW_LINE max = max << ( size - k ) NEW_LINE xorValue = ( n ^ max ) NEW_LINE return ( setBit ( xorValue ) ) NEW_LINE DEDENT n = 27 NEW_LINE k = 3 NEW_LINE print ( \" Min ▁ Flips ▁ = ▁ \" , minFlip ( n , k ) ) NEW_LINE"],"bleu":0.6630542435449921,"rouge_l":0.8356164383561644}
{"id":1299,"predictions":["def isVowel ( x ) : NEW_LINE INDENT if ( x == ' a ' or x == ' e ' or x == ' i ' or x == ' o ' or x == ' u ' ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def update desertshedVowels ( a ) : NEW_LINE INDENT n = len ( a ) NEW_LINE updateString = \" \" NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i == 0 or i == n - 1 ) : NEW_LINE INDENT updateString += a [ i ] NEW_LINE continue NEW_LINE DEDENT if ( isVowel ( a [ i ] ) == True and isVowel ( a [ i + 1 ] ) == False and isVowel ( a [ i + 1 ] ) == False ) : NEW_LINE INDENT continue NEW_LINE DEDENT modifiedString += a [ i ] NEW_LINE DEDENT return updateString NEW_LINE DEDENT if __name__ == \" _ _ main _ _ _ \" : NEW_LINE INDENT str = \" geeksforgeeks \" NEW_LINE updateSquiques ( str ) NEW_LINE print ( updateString ) NEW_LINE DEDENT"],"references":["def isVowel ( x ) : NEW_LINE INDENT if ( x == ' a ' or x == ' e ' or x == ' i ' or x == ' o ' or x == ' u ' ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def updateSandwichedVowels ( a ) : NEW_LINE INDENT n = len ( a ) NEW_LINE updatedString = \" \" NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( i == 0 or i == n - 1 ) : NEW_LINE INDENT updatedString += a [ i ] NEW_LINE continue NEW_LINE DEDENT if ( isVowel ( a [ i ] ) == True and isVowel ( a [ i - 1 ] ) == False and isVowel ( a [ i + 1 ] ) == False ) : NEW_LINE INDENT continue NEW_LINE DEDENT updatedString += a [ i ] NEW_LINE DEDENT return updatedString NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" geeksforgeeks \" NEW_LINE updatedString = updateSandwichedVowels ( str ) NEW_LINE print ( updatedString ) NEW_LINE DEDENT"],"bleu":0.8312259846721457,"rouge_l":0.9279664501274568}
{"id":1300,"predictions":["def totalWays ( N , M , X ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 2 ) ] for j in range ( N + 1 ) ] NEW_LINE if ( X == 1 ) : NEW_LINE INDENT dp [ 0 ] [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 0 ] [ 1 ] = 0 NEW_LINE DEDENT if ( X == 1 ) : NEW_LINE INDENT dp [ 1 ] [ 0 ] = 0 NEW_LINE dp [ 1 ] [ 1 ] = M - 2 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 1 ] [ 0 ] = 1 NEW_LINE dp [ 1 ] [ 1 ] = ( M - 2 ) NEW_LINE DEDENT for i in range ( 2 , N ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] NEW_LINE dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] * ( M - 2 ) + dp [ i - 1 ] [ 1 ] * ( M - 2 ) NEW_LINE DEDENT return dp [ N - 1 ] [ 0 ] NEW_LINE DEDENT N = 4 NEW_LINE M = 3 NEW_LINE X = 2 NEW_LINE print ( totalWays ( N , M , X ) ) NEW_LINE"],"references":["def totalWays ( N , M , X ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 2 ) ] for j in range ( N + 1 ) ] NEW_LINE if ( X == 1 ) : NEW_LINE INDENT dp [ 0 ] [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 0 ] [ 1 ] = 0 NEW_LINE DEDENT if ( X == 1 ) : NEW_LINE INDENT dp [ 1 ] [ 0 ] = 0 NEW_LINE dp [ 1 ] [ 1 ] = M - 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 1 ] [ 0 ] = 1 NEW_LINE dp [ 1 ] [ 1 ] = ( M - 2 ) NEW_LINE DEDENT for i in range ( 2 , N ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] NEW_LINE dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] * ( M - 1 ) + dp [ i - 1 ] [ 1 ] * ( M - 2 ) NEW_LINE DEDENT return dp [ N - 1 ] [ 0 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE M = 3 NEW_LINE X = 2 NEW_LINE print ( totalWays ( N , M , X ) ) NEW_LINE DEDENT"],"bleu":0.9172417554960766,"rouge_l":0.9584963203606708}
{"id":1301,"predictions":["def findMinimal ( a , n ) : NEW_LINE INDENT a . sort ( reverse = False ) NEW_LINE sum = 0 NEW_LINE for i in range ( int ( n \/ 2 ) ) : NEW_LINE INDENT sum += ( a [ i ] + a [ n - i - 1 ] ) * ( a [ i ] + a [ n - i - 1 ] ) NEW_LINE DEDENT return sum NEW_LINE DEDENT a = [ 8 , 5 , 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE print ( findMinimal ( a , n ) ) NEW_LINE"],"references":["def findMinimal ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n \/\/ 2 ) : NEW_LINE INDENT sum += ( ( a [ i ] + a [ n - i - 1 ] ) * ( a [ i ] + a [ n - i - 1 ] ) ) NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 8 , 5 , 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE print ( findMinimal ( a , n ) ) NEW_LINE DEDENT"],"bleu":0.7928989811055893,"rouge_l":0.8847055376501611}
{"id":1302,"predictions":["def minOperations ( str , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( str [ i ] != str [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return ( count + 1 ) \/\/ 2 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \"000111\" NEW_LINE n = len ( str ) NEW_LINE print ( minOperations ( str , n ) ) NEW_LINE DEDENT"],"references":["def minOperations ( str , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( str [ i ] != str [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return ( count + 1 ) \/\/ 2 NEW_LINE DEDENT str = \"000111\" NEW_LINE n = len ( str ) NEW_LINE print ( minOperations ( str , n ) ) NEW_LINE"],"bleu":0.833941268650177,"rouge_l":0.9330783938814531}
{"id":1303,"predictions":["def toDecimal ( binary , i ) : NEW_LINE INDENT n = len ( binary ) NEW_LINE if ( i == n - 1 ) : NEW_LINE INDENT return binary [ i ] - ord ( '0' ) NEW_LINE DEDENT return ( ( ord ( binary [ i ] ) - ord ( '0' ) ) << ( n - i - 1 ) ) + toDecimal ( binary , i + 1 ) ) NEW_LINE DEDENT binary = \"1010\" NEW_LINE i = 0 NEW_LINE print ( toDecimal ( binary , i ) ) NEW_LINE"],"references":["def toDecimal ( binary , i = 0 ) : NEW_LINE INDENT n = len ( binary ) NEW_LINE if ( i == n - 1 ) : NEW_LINE INDENT return int ( binary [ i ] ) - 0 NEW_LINE DEDENT return ( ( ( int ( binary [ i ] ) - 0 ) << ( n - i - 1 ) ) + toDecimal ( binary , i + 1 ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT binary = \"1010\" NEW_LINE print ( toDecimal ( binary ) ) NEW_LINE DEDENT"],"bleu":0.672974070187364,"rouge_l":0.8022357389445997}
{"id":1304,"predictions":["def countPairs ( n ) : NEW_LINE INDENT num = ( ( n \/\/ 2 ) + 1 ) ; NEW_LINE max = n % num ; NEW_LINE count = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT val = ( ( n % i ) % j ) % n ; NEW_LINE if ( val == max ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 ; NEW_LINE DEDENT print ( countPairs ( n ) ) ; NEW_LINE"],"references":["def countPairs ( n ) : NEW_LINE INDENT num = ( ( n \/\/ 2 ) + 1 ) NEW_LINE Max = n % num NEW_LINE count = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT val = ( ( n % i ) % j ) % n NEW_LINE if ( val == Max ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT n = 5 NEW_LINE print ( countPairs ( n ) ) NEW_LINE"],"bleu":0.6787823270689446,"rouge_l":0.9025239338555265}
{"id":1305,"predictions":["import sys NEW_LINE import math NEW_LINE def createHash ( hash , maxElement ) : NEW_LINE INDENT prev , curr = 0 , 1 NEW_LINE hash . add ( prev ) NEW_LINE hash . add ( curr ) NEW_LINE while ( curr <= maxElement ) : NEW_LINE INDENT temp = curr + prev NEW_LINE if ( temp <= maxElement ) : NEW_LINE INDENT hash . add ( temp ) NEW_LINE DEDENT prev = curr NEW_LINE curr = temp NEW_LINE DEDENT DEDENT def fibonacci ( arr , n ) : NEW_LINE INDENT max_val = max ( arr ) NEW_LINE createHash ( hash , max_val ) NEW_LINE minimum = - 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] in hash ) : NEW_LINE INDENT minimum = min ( minimum , arr [ i ] ) NEW_LINE maximum = max ( maximum , arr [ i ] ) NEW_LINE DEDENT DEDENT print ( minimum , \" , ▁ \" , maximum ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE fibonacci ( arr , n ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE def createHash ( hash , maxElement ) : NEW_LINE INDENT prev = 0 NEW_LINE curr = 1 NEW_LINE hash . add ( prev ) NEW_LINE hash . add ( curr ) NEW_LINE while ( curr <= maxElement ) : NEW_LINE INDENT temp = curr + prev NEW_LINE hash . add ( temp ) NEW_LINE prev = curr NEW_LINE curr = temp NEW_LINE DEDENT DEDENT def fibonacci ( arr , n ) : NEW_LINE INDENT max_val = max ( arr ) NEW_LINE hash = set ( ) NEW_LINE createHash ( hash , max_val ) NEW_LINE minimum = sys . maxsize NEW_LINE maximum = - sys . maxsize - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] in hash ) : NEW_LINE INDENT minimum = min ( minimum , arr [ i ] ) NEW_LINE maximum = max ( maximum , arr [ i ] ) NEW_LINE DEDENT DEDENT print ( minimum , end = \" , ▁ \" ) NEW_LINE print ( maximum ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE fibonacci ( arr , n ) NEW_LINE DEDENT"],"bleu":0.8358493748546003,"rouge_l":0.8937398253662869}
{"id":1306,"predictions":["def printInSortedOrder ( arr , n ) : NEW_LINE INDENT index = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT min = i NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ index [ min ] ] > arr [ index [ j ] ] ) : NEW_LINE INDENT min = j NEW_LINE DEDENT DEDENT if ( min != i ) : NEW_LINE INDENT temp = index [ min ] NEW_LINE index [ min ] = index [ i ] , index [ i ] = temp NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ index [ i ] ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE"],"references":["def printInSortedOrder ( arr , n ) : NEW_LINE INDENT index = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT index [ i ] = i NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT min = i NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ index [ min ] ] > arr [ index [ j ] ] ) : NEW_LINE INDENT min = j NEW_LINE DEDENT DEDENT if ( min != i ) : NEW_LINE INDENT index [ min ] , index [ i ] = index [ i ] , index [ min ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ index [ i ] ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ \" geeks \" , \" quiz \" , \" geeks \" , \" for \" ] NEW_LINE n = 4 NEW_LINE printInSortedOrder ( arr , n ) NEW_LINE DEDENT"],"bleu":0.6416032252068601,"rouge_l":0.7886959734022904}
{"id":1307,"predictions":["def binomialCoeff ( n , k ) : NEW_LINE INDENT res = 1 ; NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k ; NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT res *= ( n - i ) ; NEW_LINE res \/= ( i + 1 ) ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT def countPaths ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT m = abs ( x1 - x2 ) ; NEW_LINE n = abs ( y1 - y2 ) ; NEW_LINE return ( binomialCoeff ( m + n , n ) ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x1 , y1 , x2 , y2 = 2 , 3 , 4 , 5 ; NEW_LINE print ( countPaths ( x1 , y1 , x2 , y2 ) ) ; NEW_LINE DEDENT"],"references":["def binomialCoeff ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT res *= ( n - i ) NEW_LINE res \/\/= ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT def countPaths ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT m = abs ( x1 - x2 ) NEW_LINE n = abs ( y1 - y2 ) NEW_LINE return ( binomialCoeff ( m + n , n ) ) NEW_LINE DEDENT x1 , y1 , x2 , y2 = 2 , 3 , 4 , 5 NEW_LINE print ( countPaths ( x1 , y1 , x2 , y2 ) ) NEW_LINE"],"bleu":0.7370790586031222,"rouge_l":0.9267021512530496}
{"id":1308,"predictions":["def findN ( k ) : NEW_LINE INDENT ans = 0 NEW_LINE if ( k == 0 ) : NEW_LINE INDENT ans = 3 NEW_LINE DEDENT elif ( k == 1 ) : NEW_LINE INDENT ans = k NEW_LINE DEDENT elif ( k % 4 == 0 ) : NEW_LINE INDENT ans = k - 1 NEW_LINE DEDENT elif ( k % 4 == 3 ) : NEW_LINE INDENT ans = k - 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT k = 7 NEW_LINE res = findN ( k ) NEW_LINE if ( res == - 1 ) : NEW_LINE INDENT print ( \" Not ▁ possible \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res ) NEW_LINE DEDENT DEDENT"],"references":["def findN ( k ) : NEW_LINE INDENT if ( k == 0 ) : NEW_LINE INDENT ans = 3 NEW_LINE DEDENT if ( k == 1 ) : NEW_LINE INDENT ans = 1 NEW_LINE DEDENT elif ( k % 4 == 0 ) : NEW_LINE INDENT ans = k NEW_LINE DEDENT elif ( k % 4 == 3 ) : NEW_LINE INDENT ans = k - 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT k = 7 NEW_LINE res = findN ( k ) NEW_LINE if ( res == - 1 ) : NEW_LINE INDENT print ( \" Not ▁ possible \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res ) NEW_LINE DEDENT"],"bleu":0.817328796708397,"rouge_l":0.923446153846154}
{"id":1309,"predictions":["def print_asterisk ( asterisk ) : NEW_LINE INDENT if ( asterisk == 0 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT print ( \" * ▁ \" , end = \" ▁ \" ) ; NEW_LINE print_asterisk ( asterisk - 1 ) ; NEW_LINE DEDENT def print_space ( space ) : NEW_LINE INDENT if ( space == 0 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT print ( \" ▁ \" , end = \" \" ) ; NEW_LINE print ( \" ▁ \" , end = \" \" ) ; NEW_LINE print_space ( space - 1 ) ; NEW_LINE DEDENT def pattern ( n , num ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT print_asterisk ( num - n + 1 ) ; NEW_LINE print_space ( 2 * n - 1 ) ; NEW_LINE print_asterisk ( num - n + 1 ) ; NEW_LINE print ( ) ; NEW_LINE pattern ( n - 1 , num ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 ; NEW_LINE pattern ( n , n ) ; NEW_LINE DEDENT"],"references":["def print_asterisk ( asterisk ) : NEW_LINE INDENT if ( asterisk == 0 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT print ( \" * \" , end = \" ▁ \" ) ; NEW_LINE print_asterisk ( asterisk - 1 ) ; NEW_LINE DEDENT def print_space ( space ) : NEW_LINE INDENT if ( space == 0 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT print ( \" ▁ \" , end = \" \" ) ; NEW_LINE print ( \" ▁ \" , end = \" \" ) ; NEW_LINE print_space ( space - 1 ) ; NEW_LINE DEDENT def pattern ( n , num ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT print_asterisk ( num - n + 1 ) ; NEW_LINE print_space ( 2 * n - 1 ) ; NEW_LINE print_asterisk ( num - n + 1 ) ; NEW_LINE print ( ) ; NEW_LINE pattern ( n - 1 , num ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 ; NEW_LINE pattern ( n , n ) ; NEW_LINE DEDENT"],"bleu":0.9872277482004734,"rouge_l":0.9979133628244721}
{"id":1310,"predictions":["def isMultipleOf3 ( n ) : NEW_LINE INDENT odd_count = 0 NEW_LINE even_count = 0 NEW_LINE if ( n < 0 ) : NEW_LINE INDENT n = - n NEW_LINE DEDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( n != 0 ) : NEW_LINE INDENT if ( ( n & 1 ) != 0 ) : NEW_LINE INDENT odd_count += 1 NEW_LINE DEDENT if ( ( n & 2 ) != 0 ) : NEW_LINE INDENT even_count += 1 NEW_LINE DEDENT n = n >> 2 NEW_LINE DEDENT return isMultipleOf3 ( abs ( odd_count - even_count ) ) NEW_LINE DEDENT num = 24 NEW_LINE if ( isMultipleOf3 ( num ) ) : NEW_LINE INDENT print ( num , \" is ▁ multiple ▁ of ▁ 3\" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( num , \" is ▁ not ▁ a ▁ multiple ▁ of ▁ 3\" ) NEW_LINE DEDENT"],"references":["def isMultipleOf3 ( n ) : NEW_LINE INDENT odd_count = 0 NEW_LINE even_count = 0 NEW_LINE if ( n < 0 ) : NEW_LINE INDENT n = - n NEW_LINE DEDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT odd_count += 1 NEW_LINE DEDENT if ( n & 2 ) : NEW_LINE INDENT even_count += 1 NEW_LINE DEDENT n = n >> 2 NEW_LINE DEDENT return isMultipleOf3 ( abs ( odd_count - even_count ) ) NEW_LINE DEDENT num = 24 NEW_LINE if ( isMultipleOf3 ( num ) ) : NEW_LINE INDENT print ( num , ' is ▁ multiple ▁ of ▁ 3' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( num , ' is ▁ not ▁ a ▁ multiple ▁ of ▁ 3' ) NEW_LINE DEDENT"],"bleu":0.8560458403499839,"rouge_l":0.9515353674090062}
{"id":1311,"predictions":["def findNumber ( N , S ) : NEW_LINE INDENT i = ( ( ( N ) * ( N + 1 ) \/ 4 ) - ( ( S + 1 ) \/ 2 ) ) ; NEW_LINE return i ; NEW_LINE DEDENT def check ( N , S ) : NEW_LINE INDENT i = findNumber ( N , S ) ; NEW_LINE integerI = i ; NEW_LINE if ( i - integerI == 0 ) : NEW_LINE INDENT print ( \" Yes : \" , \" , int ( integeri + 1 ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 4 ; S = 3 ; NEW_LINE check ( N , S ) ; NEW_LINE N = 5 ; NEW_LINE S = 3 ; NEW_LINE check ( N , S ) ; NEW_LINE DEDENT"],"references":["def findNumber ( N , S ) : NEW_LINE INDENT i = ( ( ( N ) * ( N + 1 ) ) \/ 4 ) - ( ( S + 1 ) \/ 2 ) ; NEW_LINE return i ; NEW_LINE DEDENT def check ( N , S ) : NEW_LINE INDENT i = findNumber ( N , S ) ; NEW_LINE integerI = int ( i ) ; NEW_LINE if ( i - integerI == 0 ) : NEW_LINE INDENT print ( \" Yes : \" , integerI , \" , \" , integerI + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 4 ; NEW_LINE S = 3 ; NEW_LINE check ( N , S ) ; NEW_LINE N = 5 ; NEW_LINE S = 3 ; NEW_LINE check ( N , S ) ; NEW_LINE DEDENT"],"bleu":0.9036046181382085,"rouge_l":0.9517988471476843}
{"id":1312,"predictions":["import sys NEW_LINE def thirdLargest ( arr , arr_size ) : NEW_LINE INDENT if ( arr_size < 3 ) : NEW_LINE INDENT print ( \" ▁ Invalid ▁ Input ▁ \" ) NEW_LINE return NEW_LINE DEDENT first = arr [ 0 ] NEW_LINE second = - sys . maxsize NEW_LINE third = - - sys . maxsize - 1 NEW_LINE for i in range ( 1 , arr_size ) : NEW_LINE INDENT if ( arr [ i ] > first ) : NEW_LINE INDENT third = second NEW_LINE second = first NEW_LINE first = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > second ) : NEW_LINE INDENT third = second NEW_LINE second = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > third ) : NEW_LINE INDENT third = arr [ i ] NEW_LINE DEDENT DEDENT print ( \" The ▁ Third ▁ Largest ▁ element ▁ is \" , third ) NEW_LINE DEDENT arr = [ 12 , 13 , 1 , 10 , 34 , 16 ] NEW_LINE n = len ( arr ) NEW_LINE thirdLargest ( arr , n ) NEW_LINE"],"references":["import sys NEW_LINE def thirdLargest ( arr , arr_size ) : NEW_LINE INDENT if ( arr_size < 3 ) : NEW_LINE INDENT print ( \" ▁ Invalid ▁ Input ▁ \" ) NEW_LINE return NEW_LINE DEDENT first = arr [ 0 ] NEW_LINE second = - sys . maxsize NEW_LINE third = - sys . maxsize NEW_LINE for i in range ( 1 , arr_size ) : NEW_LINE INDENT if ( arr [ i ] > first ) : NEW_LINE INDENT third = second NEW_LINE second = first NEW_LINE first = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > second ) : NEW_LINE INDENT third = second NEW_LINE second = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > third ) : NEW_LINE INDENT third = arr [ i ] NEW_LINE DEDENT DEDENT print ( \" The ▁ third ▁ Largest \" , \" element ▁ is \" , third ) NEW_LINE DEDENT arr = [ 12 , 13 , 1 , 10 , 34 , 16 ] NEW_LINE n = len ( arr ) NEW_LINE thirdLargest ( arr , n ) NEW_LINE"],"bleu":0.9477226664232463,"rouge_l":0.9770810258157963}
{"id":1313,"predictions":["def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return gcd ( a - b , b ) NEW_LINE DEDENT return gcd ( a , b - a ) NEW_LINE DEDENT def squarearea ( l , b ) : NEW_LINE INDENT if ( l < 0 or b < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT n = ( ( l * b ) \/ gcd ( l , b ) ) NEW_LINE return n * n NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT l = 6 NEW_LINE b = 4 NEW_LINE print ( squarearea ( l , b ) ) NEW_LINE DEDENT"],"references":["def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return gcd ( a - b , b ) NEW_LINE DEDENT return gcd ( a , b - a ) NEW_LINE DEDENT def squarearea ( l , b ) : NEW_LINE INDENT if ( l < 0 or b < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT n = ( l * b ) \/ gcd ( l , b ) NEW_LINE return n * n NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT l = 6 NEW_LINE b = 4 NEW_LINE print ( int ( squarearea ( l , b ) ) ) NEW_LINE DEDENT"],"bleu":0.9688092282909766,"rouge_l":0.9832449628844114}
{"id":1314,"predictions":["def countUnsetBits ( n ) : NEW_LINE INDENT x = n NEW_LINE n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 16 NEW_LINE n |= n >> 16 NEW_LINE return count ( x ^ n ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 17 NEW_LINE print ( countUnsetBits ( n ) ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def countUnsetBits ( n ) : NEW_LINE INDENT x = n NEW_LINE n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE t = math . log ( x ^ n , 2 ) NEW_LINE return math . floor ( t ) NEW_LINE DEDENT n = 17 NEW_LINE print ( countUnsetBits ( n ) ) NEW_LINE"],"bleu":0.686262757816798,"rouge_l":0.7674564898301531}
{"id":1315,"predictions":["N = 1000001 NEW_LINE visited = [ 0 for i in range ( N ) ] NEW_LINE movesTo = [ 0 for i in range ( N ) ] NEW_LINE def dfs ( i ) : NEW_LINE INDENT if ( visited [ i ] == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT visited [ i ] = 1 NEW_LINE x = dfs ( hasTo [ i ] ) NEW_LINE return ( x + 1 ) NEW_LINE DEDENT def noOfTranspositions ( P , n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT visited [ P [ i ] ] = i + 1 NEW_LINE DEDENT transpositions = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( visited [ i ] == 0 ) : NEW_LINE INDENT ans = dfs ( i ) NEW_LINE transpositions += ans - 1 NEW_LINE DEDENT DEDENT return transpos NEW_LINE DEDENT permutation = [ 5 , 1 , 4 , 3 , 2 ] NEW_LINE n = len ( permutation ) NEW_LINE print ( noOfTranspositions ( permutation , n ) ) NEW_LINE"],"references":["N = 1000001 NEW_LINE visited = [ 0 ] * N ; NEW_LINE goesTo = [ 0 ] * N ; NEW_LINE def dfs ( i ) : NEW_LINE INDENT if ( visited [ i ] == 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT visited [ i ] = 1 ; NEW_LINE x = dfs ( goesTo [ i ] ) ; NEW_LINE return ( x + 1 ) ; NEW_LINE DEDENT def noOfTranspositions ( P , n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT visited [ i ] = 0 ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT goesTo [ P [ i ] ] = i + 1 ; NEW_LINE DEDENT transpositions = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( visited [ i ] == 0 ) : NEW_LINE INDENT ans = dfs ( i ) ; NEW_LINE transpositions += ans - 1 ; NEW_LINE DEDENT DEDENT return transpositions ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT permutation = [ 5 , 1 , 4 , 3 , 2 ] ; NEW_LINE n = len ( permutation ) ; NEW_LINE print ( noOfTranspositions ( permutation , n ) ) ; NEW_LINE DEDENT"],"bleu":0.6583217934768941,"rouge_l":0.8217188440698374}
{"id":1316,"predictions":["def getCount ( N ) : NEW_LINE INDENT if ( N % 2 == 1 ) : NEW_LINE INDENT return \"0\" NEW_LINE DEDENT result = \"9\" NEW_LINE for i in range ( 1 , int ( N \/ 2 ) + 1 ) : NEW_LINE INDENT result += \"0\" NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == \" _ main _ _ \" : NEW_LINE INDENT N = 4 NEW_LINE print ( getCount ( N ) ) NEW_LINE DEDENT"],"references":["def getCount ( N ) : NEW_LINE INDENT if ( N % 2 == 1 ) : NEW_LINE INDENT return \"0\" NEW_LINE DEDENT result = \"9\" NEW_LINE for i in range ( 1 , N \/\/ 2 ) : NEW_LINE INDENT result = result + \"0\" NEW_LINE DEDENT return result NEW_LINE DEDENT N = 4 NEW_LINE print ( getCount ( N ) ) NEW_LINE"],"bleu":0.6756748636518032,"rouge_l":0.850371747211896}
{"id":1317,"predictions":["def isDivisible ( n ) : NEW_LINE INDENT while n \/\/ 100 : NEW_LINE INDENT d = n % 10 NEW_LINE n = n \/\/ 10 NEW_LINE n += d * 2 NEW_LINE DEDENT return ( n % 19 == 0 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 101156 NEW_LINE if ( isDivisible ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def isDivisible ( n ) : NEW_LINE INDENT while ( n \/\/ 100 ) : NEW_LINE INDENT d = n % 10 NEW_LINE n \/\/= 10 NEW_LINE n += d * 2 NEW_LINE DEDENT return ( n % 19 == 0 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 101156 NEW_LINE if ( isDivisible ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.9167980576638141,"rouge_l":0.967391304347826}
{"id":1318,"predictions":["def printArr ( arr , k ) : NEW_LINE INDENT for i in range ( k ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def printSeqUtil ( n , k , len , arr ) : NEW_LINE INDENT if ( len k == k ) : NEW_LINE INDENT printArr ( arr , k ) NEW_LINE return NEW_LINE DEDENT i = 1 if ( len == 0 ) else 1 NEW_LINE if ( arr [ len - 1 ] + 1 ) : NEW_LINE INDENT printArr ( arr , k ) NEW_LINE return NEW_LINE DEDENT i = 1 if ( i <= n ) : NEW_LINE INDENT printSeqUtil ( n , k , len , arr ) NEW_LINE i += 1 NEW_LINE DEDENT len -= 1 NEW_LINE DEDENT def printSeq ( n , k ) : NEW_LINE INDENT arr = [ 0 for i in range ( k ) ] NEW_LINE len = 0 NEW_LINE printSeqUtil ( n , k , len , arr ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT k = 3 NEW_LINE n = 7 NEW_LINE printSeq ( n , k ) NEW_LINE DEDENT"],"references":["def printArr ( arr , k ) : NEW_LINE INDENT for i in range ( k ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( ) ; NEW_LINE DEDENT def printSeqUtil ( n , k , len1 , arr ) : NEW_LINE INDENT if ( len1 == k ) : NEW_LINE INDENT printArr ( arr , k ) ; NEW_LINE return ; NEW_LINE DEDENT i = 1 if ( len1 == 0 ) else ( arr [ len1 - 1 ] + 1 ) ; NEW_LINE len1 += 1 ; NEW_LINE while ( i <= n ) : NEW_LINE INDENT arr [ len1 - 1 ] = i ; NEW_LINE printSeqUtil ( n , k , len1 , arr ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT len1 -= 1 ; NEW_LINE DEDENT def printSeq ( n , k ) : NEW_LINE INDENT arr = [ 0 ] * k ; NEW_LINE len1 = 0 ; NEW_LINE printSeqUtil ( n , k , len1 , arr ) ; NEW_LINE DEDENT k = 3 ; NEW_LINE n = 7 ; NEW_LINE printSeq ( n , k ) ; NEW_LINE"],"bleu":0.5886595539117425,"rouge_l":0.7924603490874312}
{"id":1319,"predictions":["from math import sqrt NEW_LINE MAXN = 1000001 NEW_LINE spf = [ 0 for i in range ( MAXN ) ] NEW_LINE hash1 = [ 0 for i in range ( MAXN ) ] NEW_LINE hash1 = [ 0 for i in range ( MAXN ) ] NEW_LINE def sieve ( ) : NEW_LINE INDENT spf [ 1 ] = 1 NEW_LINE for i in range ( 2 , MAXN , 2 ) : NEW_LINE INDENT spf [ i ] = 2 NEW_LINE DEDENT for i in range ( 3 , mt . ceil ( sqrt ( MAXN ) ) + 1 , 1 ) : NEW_LINE INDENT if ( spf [ i ] == i ) : NEW_LINE INDENT for j in range ( i * i , MAXN , i ) : NEW_LINE INDENT if ( spf [ j ] == j ) : NEW_LINE INDENT spf [ j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def getFactorization ( x ) : NEW_LINE INDENT while ( x != 1 ) : NEW_LINE INDENT temp = spf [ x ] NEW_LINE if ( x % temp == 0 ) : NEW_LINE INDENT hash1 [ spf [ x ] ] += 1 NEW_LINE x = x \/\/ spf [ x ] NEW_LINE DEDENT DEDENT while ( x % temp == 0 ) : NEW_LINE INDENT x = x \/\/ temp NEW_LINE DEDENT DEDENT def checkValidNum ( x ) : NEW_LINE INDENT temp = spf [ x ] NEW_LINE if ( x % temp == 0 and hash1 [ temp ] > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( x % temp == 0 ) : NEW_LINE INDENT x = x \/\/ temp NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def hasValidNum ( arr , n ) : NEW_LINE INDENT sieve ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT getFactorization ( arr [ i ] ) NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT"],"references":["MAXN = 1000001 NEW_LINE spf = [ i for i in range ( MAXN ) ] NEW_LINE hash1 = [ 0 for i in range ( MAXN ) ] NEW_LINE def sieve ( ) : NEW_LINE INDENT for i in range ( 4 , MAXN , 2 ) : NEW_LINE INDENT spf [ i ] = 2 NEW_LINE DEDENT for i in range ( 3 , MAXN ) : NEW_LINE INDENT if i * i < MAXN : NEW_LINE INDENT break NEW_LINE DEDENT if ( spf [ i ] == i ) : NEW_LINE INDENT for j in range ( i * i , MAXN , i ) : NEW_LINE INDENT if ( spf [ j ] == j ) : NEW_LINE INDENT spf [ j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def getFactorization ( x ) : NEW_LINE INDENT while ( x != 1 ) : NEW_LINE INDENT temp = spf [ x ] NEW_LINE if ( x % temp == 0 ) : NEW_LINE INDENT hash1 [ spf [ x ] ] += 1 NEW_LINE x = x \/\/ spf [ x ] NEW_LINE DEDENT while ( x % temp == 0 ) : NEW_LINE INDENT x = x \/\/ temp NEW_LINE DEDENT DEDENT DEDENT def check ( x ) : NEW_LINE INDENT while ( x != 1 ) : NEW_LINE INDENT temp = spf [ x ] NEW_LINE if ( x % temp == 0 and hash1 [ temp ] > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( x % temp == 0 ) : NEW_LINE INDENT x = x \/\/ temp NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def hasValidNum ( arr , n ) : NEW_LINE INDENT sieve ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT getFactorization ( arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( check ( arr [ i ] ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT arr = [ 2 , 8 , 4 , 10 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE if ( hasValidNum ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.7264610782749896,"rouge_l":0.78541911348906}
{"id":1320,"predictions":["from math import gcd NEW_LINE def printRatio ( a , b , c , d ) : NEW_LINE INDENT if ( b * c > a * d ) : NEW_LINE INDENT temp = c NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return __gcd ( a - b , b ) NEW_LINE DEDENT return __gcd ( a , b - a ) NEW_LINE DEDENT lcm = ( a * c ) \/\/ __gcd ( a , c ) NEW_LINE x = lcm \/\/ a NEW_LINE b *= x NEW_LINE d *= y NEW_LINE k = gcd ( b , d ) NEW_LINE print ( b , \" : \" , d , d ) NEW_LINE"],"references":["import math NEW_LINE def printRatio ( a , b , c , d ) : NEW_LINE INDENT if ( b * c > a * d ) : NEW_LINE INDENT swap ( c , d ) NEW_LINE swap ( a , b ) NEW_LINE DEDENT lcm = ( a * c ) \/ math . gcd ( a , c ) NEW_LINE x = lcm \/ a NEW_LINE b = int ( b * x ) NEW_LINE y = lcm \/ c NEW_LINE d = int ( d * y ) NEW_LINE k = math . gcd ( b , d ) NEW_LINE b = int ( b \/ k ) NEW_LINE d = int ( d \/ k ) NEW_LINE print ( b , \" : \" , d ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 4 NEW_LINE b = 3 NEW_LINE c = 2 NEW_LINE d = 2 NEW_LINE printRatio ( a , b , c , d ) NEW_LINE DEDENT"],"bleu":0.4210163074568547,"rouge_l":0.5485152655792556}
{"id":1321,"predictions":["def SieveOfAtk ( limit ) : NEW_LINE INDENT if ( limit > 2 ) : NEW_LINE INDENT print ( 2 , end = \" ▁ \" ) NEW_LINE DEDENT if ( limit > 3 ) : NEW_LINE INDENT print ( 3 , end = \" ▁ \" ) NEW_LINE DEDENT sieve = [ False for i in range ( limit ) ] NEW_LINE for x in range ( 1 , limit ) : NEW_LINE INDENT y = 1 NEW_LINE while ( y * x ) >= limit : NEW_LINE INDENT n = ( 4 * x ) + ( y * y ) NEW_LINE if ( n % 12 == 1 or n % 12 == 5 ) : NEW_LINE INDENT sieve [ n ] ^= True NEW_LINE DEDENT n = ( 3 * x * x ) + ( y * y ) NEW_LINE if ( n <= limit and n % 12 == 7 ) : NEW_LINE INDENT sieve [ n ] ^= True NEW_LINE DEDENT n = ( 3 * x ) - ( y * y ) NEW_LINE if ( x > y and n <= limit and n % 12 == 11 ) : NEW_LINE INDENT sieve [ n ] ^= True NEW_LINE DEDENT DEDENT DEDENT for r in range ( 5 , r , 1 ) : NEW_LINE INDENT if ( sieve [ r ] ) : NEW_LINE INDENT for i in range ( r * r , limit , r * r ) : NEW_LINE INDENT sieve [ i ] = False NEW_LINE DEDENT DEDENT for r in range ( 5 , 1 ) : NEW_LINE INDENT if ( sieve [ r ] ) : NEW_LINE INDENT print ( a , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT limit = 20 NEW_LINE SieveOfAtAtk ( limit ) NEW_LINE DEDENT"],"references":["def SieveOfAtkin ( limit ) : NEW_LINE INDENT if ( limit > 2 ) : NEW_LINE INDENT print ( 2 , end = \" ▁ \" ) NEW_LINE DEDENT if ( limit > 3 ) : NEW_LINE INDENT print ( 3 , end = \" ▁ \" ) NEW_LINE DEDENT sieve = [ False ] * limit NEW_LINE for i in range ( 0 , limit ) : NEW_LINE INDENT sieve [ i ] = False NEW_LINE DEDENT x = 1 NEW_LINE while ( x * x < limit ) : NEW_LINE INDENT y = 1 NEW_LINE while ( y * y < limit ) : NEW_LINE INDENT n = ( 4 * x * x ) + ( y * y ) NEW_LINE if ( n <= limit and ( n % 12 == 1 or n % 12 == 5 ) ) : NEW_LINE INDENT sieve [ n ] ^= True NEW_LINE DEDENT n = ( 3 * x * x ) + ( y * y ) NEW_LINE if ( n <= limit and n % 12 == 7 ) : NEW_LINE INDENT sieve [ n ] ^= True NEW_LINE DEDENT n = ( 3 * x * x ) - ( y * y ) NEW_LINE if ( x > y and n <= limit and n % 12 == 11 ) : NEW_LINE INDENT sieve [ n ] ^= True NEW_LINE DEDENT y += 1 NEW_LINE DEDENT x += 1 NEW_LINE DEDENT r = 5 NEW_LINE while ( r * r < limit ) : NEW_LINE INDENT if ( sieve [ r ] ) : NEW_LINE INDENT for i in range ( r * r , limit , r * r ) : NEW_LINE INDENT sieve [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for a in range ( 5 , limit ) : NEW_LINE INDENT if ( sieve [ a ] ) : NEW_LINE INDENT print ( a , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT limit = 20 NEW_LINE SieveOfAtkin ( limit ) NEW_LINE"],"bleu":0.7744318764437637,"rouge_l":0.853167641325536}
{"id":1322,"predictions":["import math NEW_LINE def calculateSide ( n , r ) : NEW_LINE INDENT theta = 360 \/ n NEW_LINE theta_in_radians = theta * 3.14 \/ 180 NEW_LINE return 2 * r * math . sin ( theta_in_rad \/ 2 ) NEW_LINE DEDENT n = 3 NEW_LINE r = 5 NEW_LINE print ( calculateSide ( n , r ) ) NEW_LINE"],"references":["from math import sin NEW_LINE def calculateSide ( n , r ) : NEW_LINE INDENT theta = 360 \/ n NEW_LINE theta_in_radians = theta * 3.14 \/ 180 NEW_LINE return 2 * r * sin ( theta_in_radians \/ 2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE r = 5 NEW_LINE print ( ' { 0 : . 5 } ' . format ( calculateSide ( n , r ) ) ) NEW_LINE DEDENT"],"bleu":0.5406498387054839,"rouge_l":0.7432550043516102}
{"id":1323,"predictions":["def findSum ( n ) : NEW_LINE INDENT arr = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT arr [ i ] [ j ] = abs ( i - j ) NEW_LINE DEDENT DEDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT sum += arr [ i ] [ j ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT n = 3 NEW_LINE print ( findSum ( n ) ) NEW_LINE"],"references":["def findSum ( n ) : NEW_LINE INDENT arr = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT arr [ i ] [ j ] = abs ( i - j ) NEW_LINE DEDENT DEDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT sum += arr [ i ] [ j ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE print ( findSum ( n ) ) NEW_LINE DEDENT"],"bleu":0.8776352048362943,"rouge_l":0.9350766456266906}
{"id":1324,"predictions":["def solve ( Array , N , K ) : NEW_LINE INDENT count_Arr = [ 0 for i in range ( N + 2 ) ] NEW_LINE factor = 1 NEW_LINE size = N NEW_LINE while ( size > 0 ) : NEW_LINE INDENT start = 1 NEW_LINE end = size NEW_LINE count_Arr [ 1 ] += factor * N NEW_LINE count_Arr [ end + 1 ] -= factor * N NEW_LINE factor += 1 NEW_LINE size \/\/= 2 NEW_LINE DEDENT for i in range ( 2 , N + 1 ) : NEW_LINE INDENT count_Arr [ i ] += count_Arr [ i - 1 ] NEW_LINE DEDENT start = 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT end = start + count_Arr [ 0 ] NEW_LINE if ( K >= start and K <= end ) : NEW_LINE INDENT return element [ i ] [ 0 ] NEW_LINE DEDENT start += element [ i ] [ 1 ] NEW_LINE DEDENT return - 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 4 , 5 , 1 ] NEW_LINE N = len ( arr ) NEW_LINE K = 13 NEW_LINE print ( solve ( arr , N , K ) ) NEW_LINE DEDENT"],"references":["def solve ( Array , N , K ) : NEW_LINE INDENT count_Arr = [ 0 ] * ( N + 2 ) ; NEW_LINE factor = 1 ; NEW_LINE size = N ; NEW_LINE while ( size ) : NEW_LINE INDENT start = 1 ; NEW_LINE end = size ; NEW_LINE count_Arr [ 1 ] += factor * N ; NEW_LINE count_Arr [ end + 1 ] -= factor * N ; NEW_LINE factor += 1 ; NEW_LINE size \/\/= 2 ; NEW_LINE DEDENT for i in range ( 2 , N + 1 ) : NEW_LINE INDENT count_Arr [ i ] += count_Arr [ i - 1 ] ; NEW_LINE DEDENT element = [ ] ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT element . append ( ( Array [ i ] , count_Arr [ i + 1 ] ) ) ; NEW_LINE DEDENT element . sort ( ) ; NEW_LINE start = 1 ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT end = start + element [ i ] [ 1 ] - 1 ; NEW_LINE if ( K >= start and K <= end ) : NEW_LINE INDENT return element [ i ] [ 0 ] ; NEW_LINE DEDENT start += element [ i ] [ 1 ] ; NEW_LINE DEDENT return - 1 ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 4 , 5 , 1 ] ; NEW_LINE N = len ( arr ) ; NEW_LINE K = 13 ; NEW_LINE print ( solve ( arr , N , K ) ) ; NEW_LINE DEDENT"],"bleu":0.6126744601923897,"rouge_l":0.8197350739105396}
{"id":1325,"predictions":["def display ( ) : NEW_LINE INDENT for i in range ( 0 , int ( input ( ) ) ) : NEW_LINE INDENT for j in range ( 0 , int ( n \/ 2 ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == n \/\/ 2 ) and i != 0 and j != n \/ 2 or i == n \/ 2 ) : NEW_LINE INDENT print ( \" * \" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( end = \" ▁ \" ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT display ( 7 ) NEW_LINE"],"references":["def display ( n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( ( n \/\/ 2 ) + 1 ) : NEW_LINE INDENT if ( ( j == 0 or j == n \/\/ 2 ) and i != 0 or i == 0 and j != 0 and j != n \/\/ 2 or i == n \/\/ 2 ) : NEW_LINE INDENT print ( \" * \" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" ▁ \" , end = \" \" ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT display ( 7 ) NEW_LINE"],"bleu":0.7452166002554809,"rouge_l":0.8551401869158879}
{"id":1326,"predictions":["def maxSum ( arr1 , arr2 , n ) : NEW_LINE INDENT initialParity = 0 NEW_LINE finalParity = 0 NEW_LINE sum = 0 NEW_LINE maxPositive = - 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT initialParity += arr2 [ i ] NEW_LINE if ( arr1 [ i ] >= 0 ) : NEW_LINE INDENT finalParity += 1 NEW_LINE sum += arr1 [ i ] NEW_LINE minPositive = min ( minPositive , arr1 [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT maxNegative = max ( maxNegative , arr1 [ i ] ) NEW_LINE DEDENT DEDENT if ( originalParity % 2 == finalParity % 2 ) : NEW_LINE INDENT return sum NEW_LINE DEDENT else : NEW_LINE INDENT if ( minPositive + maxNegative >= 0 ) : NEW_LINE INDENT return sum + maxNegative NEW_LINE DEDENT else : NEW_LINE INDENT return sum - minPositive NEW_LINE DEDENT DEDENT DEDENT arr1 = [ 2 , - 4 , 5 , 3 ] NEW_LINE arr2 = [ 0 , 1 , 0 , 1 ] NEW_LINE n = len ( arr1 ) NEW_LINE print ( maxSum ( arr1 , arr2 , n ) ) NEW_LINE"],"references":["import sys NEW_LINE def maxSum ( arr1 , arr2 , n ) : NEW_LINE INDENT initialParity , finalParity = 0 , 0 NEW_LINE sum = 0 NEW_LINE minPositive = sys . maxsize NEW_LINE maxNegative = - sys . maxsize - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT initialParity += arr2 [ i ] ; NEW_LINE if ( arr1 [ i ] >= 0 ) : NEW_LINE INDENT finalParity += 1 NEW_LINE sum += arr1 [ i ] NEW_LINE minPositive = min ( minPositive , arr1 [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT maxNegative = max ( maxNegative , arr1 [ i ] ) NEW_LINE DEDENT DEDENT if ( initialParity % 2 == finalParity % 2 ) : NEW_LINE INDENT return sum NEW_LINE DEDENT else : NEW_LINE INDENT if ( minPositive + maxNegative >= 0 ) : NEW_LINE INDENT return sum + maxNegative NEW_LINE DEDENT else : NEW_LINE INDENT return sum - minPositive NEW_LINE DEDENT DEDENT DEDENT arr1 = [ 2 , - 4 , 5 , 3 ] NEW_LINE arr2 = [ 0 , 1 , 0 , 1 ] NEW_LINE n = len ( arr1 ) NEW_LINE print ( maxSum ( arr1 , arr2 , n ) ) NEW_LINE"],"bleu":0.8663619280494463,"rouge_l":0.9257345818534063}
{"id":1327,"predictions":["from math import sqrt ; NEW_LINE def printTaxababab2 ( N ) : NEW_LINE INDENT i = 1 ; NEW_LINE count = 0 ; NEW_LINE while ( count < N ) : NEW_LINE INDENT for j in range ( 1 , int ( pow ( i , 1 \/ 3 ) ) + 1 ) : NEW_LINE INDENT for k in range ( j + 1 , int ( pow ( i , 1 \/ 3 ) + 1 ) ) : NEW_LINE INDENT if ( j * j * j + k * k == i ) : NEW_LINE INDENT int ( string_count + 1 ) ; NEW_LINE DEDENT DEDENT if ( int ( count == 2 ) ) : NEW_LINE INDENT count += 1 ; NEW_LINE print ( count , i ) ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 ; NEW_LINE printTaxicab2 ( N ) ; NEW_LINE DEDENT"],"references":["def printTaxicab2 ( N ) : NEW_LINE INDENT i , count = 1 , 0 NEW_LINE while ( count < N ) : NEW_LINE INDENT int_count = 0 NEW_LINE for j in range ( 1 , int ( pow ( i , 1.0 \/ 3 ) ) + 1 ) : NEW_LINE INDENT for k in range ( j + 1 , int ( pow ( i , 1.0 \/ 3 ) ) + 1 ) : NEW_LINE INDENT if ( j * j * j + k * k * k == i ) : NEW_LINE INDENT int_count += 1 NEW_LINE DEDENT DEDENT DEDENT if ( int_count == 2 ) : NEW_LINE INDENT count += 1 NEW_LINE print ( count , \" ▁ \" , i ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT N = 5 NEW_LINE printTaxicab2 ( N ) NEW_LINE"],"bleu":0.5961428698222629,"rouge_l":0.8008470089994706}
{"id":1328,"predictions":["def findIndex ( a , n , key ) : NEW_LINE INDENT start = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == key ) : NEW_LINE INDENT start = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( start == - 1 ) : NEW_LINE INDENT print ( \" Key ▁ not ▁ present ▁ in ▁ array \" ) NEW_LINE return NEW_LINE DEDENT end = start NEW_LINE for i in range ( n - 1 , start , - 1 ) : NEW_LINE INDENT if ( a [ i ] == key ) : NEW_LINE INDENT end = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( start == end ) : NEW_LINE INDENT print ( \" No ▁ one ▁ key ▁ is ▁ present ▁ at ▁ index ▁ : \" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" start ▁ index : ▁ \" , start ) NEW_LINE print ( \" Last ▁ index : ▁ \" , end = \" \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 2 , 7 , 8 , 8 , 9 , 8 , 9 , 8 , 0 , 0 , 0 , 8 ] NEW_LINE key = 8 NEW_LINE findIndex ( a , len ( a ) , key ) NEW_LINE DEDENT"],"references":["def findIndex ( a , n , key ) : NEW_LINE INDENT start = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == key : NEW_LINE INDENT start = i NEW_LINE break NEW_LINE DEDENT DEDENT if start == - 1 : NEW_LINE INDENT print ( \" Key ▁ not ▁ present ▁ in ▁ array \" ) NEW_LINE return 0 NEW_LINE DEDENT end = start NEW_LINE for i in range ( n - 1 , start - 1 , - 1 ) : NEW_LINE INDENT if a [ i ] == key : NEW_LINE INDENT end = i NEW_LINE break NEW_LINE DEDENT DEDENT if start == end : NEW_LINE INDENT print ( \" Only ▁ one ▁ key ▁ is ▁ present ▁ at ▁ index ▁ : ▁ \" , start ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Start ▁ index : ▁ \" , start ) NEW_LINE print ( \" Last ▁ index : ▁ \" , end ) NEW_LINE DEDENT DEDENT a = [ 1 , 2 , 7 , 8 , 8 , 9 , 8 , 0 , 0 , 0 , 8 ] NEW_LINE n = len ( a ) NEW_LINE key = 8 NEW_LINE findIndex ( a , n , key ) NEW_LINE"],"bleu":0.7447831984676577,"rouge_l":0.8933323945645286}
{"id":1329,"predictions":["ans = 0 NEW_LINE gr = [ ] NEW_LINE def Add_Edge ( u , v ) : NEW_LINE INDENT gr [ u ] . append ( v ) NEW_LINE gr [ v ] . append ( u ) NEW_LINE DEDENT def dfs ( child , par , counter ) : NEW_LINE INDENT if ( color [ child ] != color [ par ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT for i in gr [ child ] : NEW_LINE INDENT if ( gr [ child ] [ i ] == par ) : NEW_LINE INDENT continue NEW_LINE DEDENT dfs ( gr [ child ] , child , color ) NEW_LINE DEDENT DEDENT global dfs ( 0 , 1 ) NEW_LINE color = [ 0 , 1 , 2 , 3 , 2 , 2 , 3 ] NEW_LINE Add_Edge ( gr [ child ] [ i ] , child ) NEW_LINE Add_E ( 2 , 4 ) NEW_LINE Add_E ( 3 , 6 ) NEW_LINE dfs ( 1 , 2 , 4 ) NEW_LINE print ( ans ) NEW_LINE"],"references":["ans = 0 NEW_LINE gr = [ [ ] for i in range ( 100005 ) ] NEW_LINE def Add_Edge ( u , v ) : NEW_LINE INDENT gr [ u ] . append ( v ) NEW_LINE gr [ v ] . append ( u ) NEW_LINE DEDENT def dfs ( child , par , color ) : NEW_LINE INDENT global ans NEW_LINE if ( color [ child ] != color [ par ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT for it in gr [ child ] : NEW_LINE INDENT if ( it == par ) : NEW_LINE INDENT continue NEW_LINE DEDENT dfs ( it , child , color ) NEW_LINE DEDENT DEDENT color = [ 0 , 1 , 2 , 3 , 2 , 2 , 3 ] NEW_LINE Add_Edge ( 1 , 2 ) NEW_LINE Add_Edge ( 1 , 3 ) NEW_LINE Add_Edge ( 2 , 4 ) NEW_LINE Add_Edge ( 2 , 5 ) NEW_LINE Add_Edge ( 3 , 6 ) NEW_LINE dfs ( 1 , 0 , color ) NEW_LINE print ( ans ) NEW_LINE"],"bleu":0.7293434214812718,"rouge_l":0.8097587227554041}
{"id":1330,"predictions":["def longestFibonacciSubarray ( n , a ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT length = 2 NEW_LINE mx = - sys . maxsize - 1 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( a [ i ] == a [ i - 1 ] + a [ i - 2 ] ) : NEW_LINE INDENT len = len + 1 NEW_LINE DEDENT else : NEW_LINE INDENT len = 2 NEW_LINE DEDENT mx = max ( mx , len ) NEW_LINE DEDENT return mx NEW_LINE DEDENT n = 5 NEW_LINE a = [ 2 , 4 , 6 , 10 , 2 ] NEW_LINE print ( longestFibonacciSubarray ( n , a ) ) NEW_LINE"],"references":["def longestFibonacciSubarray ( n , a ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT Len = 2 NEW_LINE mx = - 10 ** 9 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( a [ i ] == a [ i - 1 ] + a [ i - 2 ] ) : NEW_LINE INDENT Len += 1 NEW_LINE DEDENT else : NEW_LINE INDENT Len = 2 NEW_LINE DEDENT mx = max ( mx , Len ) NEW_LINE DEDENT return mx NEW_LINE DEDENT n = 5 NEW_LINE a = [ 2 , 4 , 6 , 10 , 2 ] NEW_LINE print ( longestFibonacciSubarray ( n , a ) ) NEW_LINE"],"bleu":0.8478695863465547,"rouge_l":0.9244798356023634}
{"id":1331,"predictions":["class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def prevMatrix ( root , matrix , size ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return NEW_LINE DEDENT prev = Node ( root . left , matrix , size ) NEW_LINE root . left . data = [ ] NEW_LINE for i in range ( size ) : NEW_LINE INDENT if ( matrix [ root . left . data ] [ i ] == 1 ) : NEW_LINE INDENT matrix [ root . data ] [ i ] = 1 NEW_LINE DEDENT DEDENT if ( root . right ) : NEW_LINE INDENT matrix [ root . data ] [ root . data ] = 1 NEW_LINE for i in range ( size ) : NEW_LINE INDENT if ( matrix [ root . data ] [ i ] == 1 ) : NEW_LINE INDENT matrix [ root . data ] [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT matrix [ root . data ] [ i ] = 1 NEW_LINE for i in range ( size ) : NEW_LINE INDENT if ( matrix [ root . right . data ] [ i ] == 1 ) : NEW_LINE INDENT matrix [ root . data ] [ i ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root_root = new_node ( 5 ) NEW_LINE root . left = newNode ( 1 ) NEW_LINE root . left = newNode ( 1 ) NEW_LINE root . left . left = newNode ( 2 ) NEW_LINE root_root . left = newNode ( 3 ) NEW_LINE root . left . left = newNode ( 4 ) NEW_LINE root_root . left = newNode ( 3 ) NEW_LINE root . left . left = newNode ( 4 ) NEW_LINE root = [ ] * size NEW_LINE rootMatrix ( tree , matrix , size ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT for j in range ( size ) :"],"references":["class newnode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = self . right = None NEW_LINE DEDENT DEDENT def ancestorMatrixRec ( root , anc ) : NEW_LINE INDENT global mat , MAX NEW_LINE if root == None : NEW_LINE INDENT return 0 NEW_LINE DEDENT data = root . data NEW_LINE for i in range ( len ( anc ) ) : NEW_LINE INDENT mat [ anc [ i ] ] [ data ] = 1 NEW_LINE DEDENT anc . append ( data ) NEW_LINE l = ancestorMatrixRec ( root . left , anc ) NEW_LINE r = ancestorMatrixRec ( root . right , anc ) NEW_LINE anc . pop ( - 1 ) NEW_LINE return l + r + 1 NEW_LINE DEDENT def ancestorMatrix ( root ) : NEW_LINE INDENT anc = [ ] NEW_LINE n = ancestorMatrixRec ( root , anc ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT MAX = 100 NEW_LINE mat = [ [ 0 ] * MAX for i in range ( MAX ) ] NEW_LINE root = newnode ( 5 ) NEW_LINE root . left = newnode ( 1 ) NEW_LINE root . right = newnode ( 2 ) NEW_LINE root . left . left = newnode ( 0 ) NEW_LINE root . left . right = newnode ( 4 ) NEW_LINE root . right . left = newnode ( 3 ) NEW_LINE ancestorMatrix ( root ) NEW_LINE"],"bleu":0.34902666609943855,"rouge_l":0.5344335778321109}
{"id":1332,"predictions":["def OddDivCount ( a , b ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT divCount = 0 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT divCount += 1 NEW_LINE DEDENT DEDENT if ( ( divCount % 2 ) != 0 ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 1 NEW_LINE b = 10 NEW_LINE print ( OddDivCount ( a , b ) ) NEW_LINE DEDENT"],"references":["def OddDivCount ( a , b ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT divCount = 0 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT divCount += 1 NEW_LINE DEDENT DEDENT if ( divCount % 2 ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 1 NEW_LINE b = 10 NEW_LINE print ( OddDivCount ( a , b ) ) NEW_LINE DEDENT"],"bleu":0.9096972922332064,"rouge_l":0.9685284944712218}
{"id":1333,"predictions":["def findNDigitNumsUtil ( n , sum , out , index ) : NEW_LINE INDENT if ( index > n or sum < 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( index == n ) : NEW_LINE INDENT if ( sum == 0 ) : NEW_LINE INDENT out [ index ] = \" * \" NEW_LINE print ( out , end = \" ▁ \" ) NEW_LINE DEDENT return NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT out [ index ] = chr ( i + ord ( '0' ) ) NEW_LINE findNDigitNumsUtil ( n , sum - i , out , index + 1 ) NEW_LINE DEDENT DEDENT def findNDigitNums ( n , sum ) : NEW_LINE INDENT out = [ ] NEW_LINE for i in range ( 1 , 10 + 1 ) : NEW_LINE INDENT out [ 0 ] = chr ( i + ord ( '0' ) ) NEW_LINE findNDigitNumsUtil ( n , sum - i , out , 1 ) NEW_LINE DEDENT DEDENT n = 2 NEW_LINE sum = 3 NEW_LINE findNDigitNums ( n , sum ) NEW_LINE"],"references":["def findNDigitNumsUtil ( n , sum , out , index ) : NEW_LINE INDENT if ( index > n or sum < 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT f = \" \" NEW_LINE if ( index == n ) : NEW_LINE INDENT if ( sum == 0 ) : NEW_LINE INDENT out [ index ] = \" \" NEW_LINE for i in out : NEW_LINE INDENT f = f + i NEW_LINE DEDENT print ( f , end = \" ▁ \" ) NEW_LINE DEDENT return NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT out [ index ] = chr ( i + ord ( '0' ) ) NEW_LINE findNDigitNumsUtil ( n , sum - i , out , index + 1 ) NEW_LINE DEDENT DEDENT def findNDigitNums ( n , sum ) : NEW_LINE INDENT out = [ False ] * ( n + 1 ) NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT out [ 0 ] = chr ( i + ord ( '0' ) ) NEW_LINE findNDigitNumsUtil ( n , sum - i , out , 1 ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 2 NEW_LINE sum = 3 NEW_LINE findNDigitNums ( n , sum ) NEW_LINE DEDENT"],"bleu":0.7642100370539323,"rouge_l":0.876875}
{"id":1334,"predictions":["def minimumIncrease ( a , b , c ) : NEW_LINE INDENT arr = [ a , b , c ] NEW_LINE arr . sort ( ) NEW_LINE if ( arr [ 0 ] + arr [ 1 ] >= arr [ 2 ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return arr [ 2 ] - ( arr [ 0 ] + arr [ 1 ] ) NEW_LINE DEDENT DEDENT a = 3 NEW_LINE b = 5 NEW_LINE c = 10 NEW_LINE print ( minimumIncrease ( a , b , c ) ) NEW_LINE"],"references":["def minimumIncrease ( a , b , c ) : NEW_LINE INDENT arr = [ a , b , c ] NEW_LINE arr . sort ( ) NEW_LINE if arr [ 0 ] + arr [ 1 ] >= arr [ 2 ] : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return arr [ 2 ] - ( arr [ 0 ] + arr [ 1 ] ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a , b , c = 3 , 5 , 10 NEW_LINE print ( minimumIncrease ( a , b , c ) ) NEW_LINE DEDENT"],"bleu":0.7573219746020092,"rouge_l":0.8591549295774648}
{"id":1335,"predictions":["def breakSum ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return max ( ( breakSum ( n \/ 2 ) + breakSum ( n \/ 3 ) + breakSum ( n \/ 4 ) ) , n ) NEW_LINE DEDENT n = 12 NEW_LINE print ( breakSum ( n ) ) NEW_LINE"],"references":["def breakSum ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return max ( ( breakSum ( n \/\/ 2 ) + breakSum ( n \/\/ 3 ) + breakSum ( n \/\/ 4 ) ) , n ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 12 NEW_LINE print ( breakSum ( n ) ) NEW_LINE DEDENT"],"bleu":0.6983786796739128,"rouge_l":0.8503593988237856}
{"id":1336,"predictions":["def maxLengthSquare ( row , column , k ) : NEW_LINE INDENT sum = [ [ 0 for i in range ( column + 1 ) ] for j in range ( row + 1 ) ] NEW_LINE cur_max = 1 NEW_LINE max = 0 NEW_LINE for i in range ( 1 , row + 1 ) : NEW_LINE INDENT for j in range ( 1 , column + 1 ) : NEW_LINE INDENT sum [ i ] [ j ] = ( sum [ i - 1 ] [ j ] + sum [ i - 1 ] [ j - 1 ] - sum [ i - 1 ] [ j - 1 ] ) NEW_LINE if ( i >= cur_max and j >= cur_max and sum [ i ] [ j ] - sum [ i - cur_max ] [ j ] ) : NEW_LINE INDENT max = cur_max + 1 NEW_LINE DEDENT DEDENT DEDENT return max NEW_LINE DEDENT row = 4 NEW_LINE column = 4 NEW_LINE matrix = [ [ 1 , 1 , 1 , 1 ] , [ 1 , 0 , 0 , 0 ] , [ 1 , 0 , 0 , 0 ] , [ 1 , 0 , 0 , 0 ] ] NEW_LINE k = 6 NEW_LINE ans = maxLengthSquare ( row , column , column , matrix , k ) NEW_LINE print ( ans ) NEW_LINE"],"references":["import numpy as np NEW_LINE def maxLengthSquare ( row , column , arr , k ) : NEW_LINE INDENT sum = np . zeros ( ( row + 1 , column + 1 ) ) ; NEW_LINE cur_max = 1 ; NEW_LINE max = 0 ; NEW_LINE for i in range ( 1 , row + 1 ) : NEW_LINE INDENT for j in range ( 1 , column + 1 ) : NEW_LINE INDENT sum [ i ] [ j ] = sum [ i - 1 ] [ j ] + sum [ i ] [ j - 1 ] +   \\ NEW_LINE INDENT arr [ i - 1 ] [ j - 1 ] -   \\ NEW_LINE sum [ i - 1 ] [ j - 1 ] ; NEW_LINE DEDENT if ( i >= cur_max and j >= cur_max and sum [ i ] [ j ] - sum [ i - cur_max ] [ j ] - sum [ i ] [ j - cur_max ] + sum [ i - cur_max ] [ j - cur_max ] <= k ) : NEW_LINE INDENT max = cur_max ; NEW_LINE cur_max += 1 ; NEW_LINE DEDENT DEDENT DEDENT return max ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT row = 4 ; NEW_LINE column = 4 ; NEW_LINE matrix = [ [ 1 , 1 , 1 , 1 ] , [ 1 , 0 , 0 , 0 ] , [ 1 , 0 , 0 , 0 ] , [ 1 , 0 , 0 , 0 ] ] ; NEW_LINE k = 6 ; NEW_LINE ans = maxLengthSquare ( row , column , matrix , k ) ; NEW_LINE print ( ans ) ; NEW_LINE DEDENT"],"bleu":0.6195320928905935,"rouge_l":0.7782634376845836}
{"id":1337,"predictions":["def minimumChanges ( arr , n ) : NEW_LINE INDENT changes = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ j ] == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT i = j - 1 NEW_LINE swaps += 1 NEW_LINE DEDENT DEDENT return changes NEW_LINE DEDENT arr = [ 1 , 1 , 0 , 0 , 0 , 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Minimum ▁ operations : \" , minimumChanges ( arr , n ) ) NEW_LINE"],"references":["def minimumChanges ( arr , n ) : NEW_LINE INDENT changes = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if arr [ i ] == 1 : NEW_LINE INDENT j = i + 1 NEW_LINE while j < n : NEW_LINE INDENT if arr [ j ] == 0 : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT i = j - 1 NEW_LINE changes += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return changes NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 1 , 0 , 0 , 0 , 1 , 0 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Minimum ▁ operations : \" , minimumChanges ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.5988789104620775,"rouge_l":0.7982393528432074}
{"id":1338,"predictions":["MAX = 100005 NEW_LINE def addPrimes ( ) : NEW_LINE INDENT n = MAX NEW_LINE prime = [ True for i in range ( n + 1 ) ] NEW_LINE p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT ans = [ ] NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT ans . append ( p ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def is_prime ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE v = addPrimes ( ) NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT flag = 1 NEW_LINE a = v [ i ] NEW_LINE while ( a != 0 ) : NEW_LINE INDENT d = a % 10 NEW_LINE a = a \/\/ 10 NEW_LINE if ( is_prime ( d ) ) : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == 1 ) : NEW_LINE INDENT n -= 1 NEW_LINE sum = sum + v [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 7 NEW_LINE print ( find_Sum ( n ) ) NEW_LINE DEDENT"],"references":["MAX = 100005 NEW_LINE def addPrimes ( ) : NEW_LINE INDENT n = MAX NEW_LINE prime = [ True for i in range ( n + 1 ) ] NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if p * p > n : NEW_LINE INDENT break NEW_LINE DEDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( 2 * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT ans = [ ] NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT ans . append ( p ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def is_prime ( n ) : NEW_LINE INDENT if n in [ 3 , 5 , 7 ] : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def find_Sum ( n ) : NEW_LINE INDENT Sum = 0 NEW_LINE v = addPrimes ( ) NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT flag = 1 NEW_LINE a = v [ i ] NEW_LINE while ( a != 0 ) : NEW_LINE INDENT d = a % 10 ; NEW_LINE a = a \/\/ 10 ; NEW_LINE if ( is_prime ( d ) ) : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == 1 ) : NEW_LINE INDENT n -= 1 NEW_LINE Sum = Sum + v [ i ] NEW_LINE DEDENT if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return Sum NEW_LINE DEDENT n = 7 NEW_LINE print ( find_Sum ( n ) ) NEW_LINE"],"bleu":0.7392961178438258,"rouge_l":0.8354727793696276}
{"id":1339,"predictions":["def consombo_sum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for k in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += k * k NEW_LINE DEDENT triNo = n * ( n + 1 ) \/\/ 2 NEW_LINE if ( sum == triNo * triNo ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def NicomachuTheorum_sum ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for k in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += k * k * k ; NEW_LINE DEDENT triNo = n * ( n + 1 ) \/ 2 ; NEW_LINE if ( sum == triNo * triNo ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT n = 5 ; NEW_LINE NicomachuTheorum_sum ( n ) ; NEW_LINE"],"bleu":0.673499261901433,"rouge_l":0.8559401309635172}
{"id":1340,"predictions":["MAX = 1000 ; NEW_LINE sequence = [ 0 ] * MAX ; NEW_LINE def vanEckSequence ( ) : NEW_LINE INDENT for i in range ( MAX - 1 ) : NEW_LINE INDENT sequence [ i ] = 0 ; NEW_LINE DEDENT for i in range ( MAX - 1 ) : NEW_LINE INDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( sequence [ j ] == sequence [ i ] ) : NEW_LINE INDENT sequence [ i + 1 ] = i - j ; NEW_LINE break ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def getNthTerm ( n ) : NEW_LINE INDENT return sequence [ n ] ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT vanEckSequence ( ) ; NEW_LINE n = 6 ; NEW_LINE print ( getNthTerm ( n ) ) ; NEW_LINE n = 100 ; NEW_LINE print ( getNthTerm ( n ) ) ; NEW_LINE DEDENT"],"references":["MAX = 1000 NEW_LINE sequence = [ 0 ] * ( MAX + 1 ) ; NEW_LINE def vanEckSequence ( ) : NEW_LINE INDENT for i in range ( MAX ) : NEW_LINE INDENT sequence [ i ] = 0 ; NEW_LINE DEDENT for i in range ( MAX ) : NEW_LINE INDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( sequence [ j ] == sequence [ i ] ) : NEW_LINE INDENT sequence [ i + 1 ] = i - j ; NEW_LINE break ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def getNthTerm ( n ) : NEW_LINE INDENT return sequence [ n ] ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT vanEckSequence ( ) ; NEW_LINE n = 6 ; NEW_LINE print ( getNthTerm ( n ) ) ; NEW_LINE n = 100 ; NEW_LINE print ( getNthTerm ( n ) ) ; NEW_LINE DEDENT"],"bleu":0.9324883620093523,"rouge_l":0.9738148544728901}
{"id":1341,"predictions":["def maximumSplitPoints ( a , n ) : NEW_LINE INDENT i , swap = 0 , 0 NEW_LINE pos = 0 NEW_LINE pos = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT pos [ a [ i ] ] = i NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == i ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT elif ( swap == 0 and pos [ i ] == a [ i ] ) : NEW_LINE INDENT count += 2 NEW_LINE swap = 1 NEW_LINE DEDENT DEDENT if ( swap == 0 and count < n - 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT a = [ 0 , 1 , 3 , 4 , 2 ] NEW_LINE n = len ( a ) NEW_LINE print ( maximumDistance ( a , n ) ) NEW_LINE"],"references":["def maximumFixedPoints ( a , n ) : NEW_LINE INDENT pos = [ None ] * n NEW_LINE count , swapped = 0 , 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT pos [ a [ i ] ] = i NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if a [ i ] == i : NEW_LINE INDENT count += 1 NEW_LINE DEDENT elif swapped == 0 and pos [ i ] == a [ i ] : NEW_LINE INDENT count += 2 NEW_LINE swapped = 1 NEW_LINE DEDENT DEDENT if swapped == 0 and count < n - 1 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 0 , 1 , 3 , 4 , 2 ] NEW_LINE n = len ( a ) NEW_LINE print ( maximumFixedPoints ( a , n ) ) NEW_LINE DEDENT"],"bleu":0.6944320650970317,"rouge_l":0.8117532782904322}
{"id":1342,"predictions":["def countCOUNT ( amount ) : NEW_LINE INDENTNotes = [ 2000 , 500 , 500 , 200 , 50 , 20 , 5 , 5 , 1 ] NEW_LINE for i in range ( 9 ) : NEW_LINE INDENT if ( amount >=Notes [ i ] ) : NEW_LINE INDENT length = int ( amount \/Notes [ i ] ) NEW_LINE length = int ( amount - length ) * days [ i ] NEW_LINE DEDENT DEDENT print ( \" Currency ▁ Count ▁ - > \" ) NEW_LINE for i in range ( 9 ) : NEW_LINE INDENT if ( query [ i ] != 0 ) : NEW_LINE INDENT print ( follows [ i ] , \" : \" , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT amount = 868 NEW_LINE countCarts ( amount ) NEW_LINE DEDENT"],"references":["def countCurrency ( amount ) : NEW_LINE INDENT notes = [ 2000 , 500 , 200 , 100 , 50 , 20 , 10 , 5 , 1 ] NEW_LINE noteCounter = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] NEW_LINE print ( \" Currency ▁ Count ▁ - > ▁ \" ) NEW_LINE for i , j in zip ( notes , noteCounter ) : NEW_LINE INDENT if amount >= i : NEW_LINE INDENT j = amount \/\/ i NEW_LINE amount = amount - j * i NEW_LINE print ( i , \" ▁ : ▁ \" , j ) NEW_LINE DEDENT DEDENT DEDENT amount = 868 NEW_LINE countCurrency ( amount ) NEW_LINE"],"bleu":0.31968828848103104,"rouge_l":0.5389850746268657}
{"id":1343,"predictions":["MAX_CHAR = 256 NEW_LINE def isPalindrome ( str , l , h ) : NEW_LINE INDENT while ( h > l ) : NEW_LINE INDENT if ( str [ l ] != str [ l ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def check ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE freq = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) ] += 1 NEW_LINE if ( freq [ ord ( str [ i ] ) ] > 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT k = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( freq [ ord ( str [ i ] ) ] > 1 ) : NEW_LINE INDENT str [ ord ( str [ i ] ) ] = str [ : i ] NEW_LINE k += 1 NEW_LINE DEDENT DEDENT if ( isPalindrome ( str , 0 , k - 1 ) ) : NEW_LINE INDENT if ( k & 1 ) : NEW_LINE INDENT return ( str [ k \/\/ 2 ] == str [ k \/\/ 2 - 1 ] ) NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" ABCABD \" NEW_LINE if ( check ( str ) ) : NEW_LINE INDENT print ( \" Repeated ▁ Subsequence ▁ Exists \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Repeated ▁ Subsequence ▁ Doesn ' t ▁ Exists ' ) NEW_LINE DEDENT DEDENT"],"references":["MAX_CHAR = 256 NEW_LINE def isPalindrome ( Str , l , h ) : NEW_LINE INDENT while ( h > l ) : NEW_LINE INDENT if ( Str [ l ] != Str [ h ] ) : NEW_LINE INDENT l += 1 NEW_LINE h -= 1 NEW_LINE return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def check ( Str ) : NEW_LINE INDENT n = len ( Str ) NEW_LINE freq = [ 0 for i in range ( MAX_CHAR ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( Str [ i ] ) ] += 1 NEW_LINE if ( freq [ ord ( Str [ i ] ) ] > 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT k = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( freq [ ord ( Str [ i ] ) ] > 1 ) : NEW_LINE INDENT Str [ k ] = Str [ i ] NEW_LINE k += 1 NEW_LINE DEDENT DEDENT Str [ k ] = ' \\0' NEW_LINE if ( isPalindrome ( Str , 0 , k - 1 ) ) : NEW_LINE INDENT if ( k & 1 ) : NEW_LINE INDENT return Str [ k \/\/ 2 ] == Str [ k \/\/ 2 - 1 ] NEW_LINE DEDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT S = \" ABCABD \" NEW_LINE Str = [ i for i in S ] NEW_LINE if ( check ( Str ) ) : NEW_LINE INDENT print ( \" Repeated ▁ Subsequence ▁ Exists \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Repeated ▁ Subsequence ▁ Doesn ' t ▁ Exists \" ) NEW_LINE DEDENT"],"bleu":0.7031859379416737,"rouge_l":0.8302120240706372}
{"id":1344,"predictions":["import math as mt NEW_LINE N = 100005 NEW_LINE mod = 1000000007 NEW_LINE cnt = [ 0 for i in range ( N ) ] NEW_LINE def Divisors ( ) : NEW_LINE INDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( 1 , i < N ) : NEW_LINE INDENT cnt [ i * j ] += 1 NEW_LINE DEDENT DEDENT DEDENT def Sumofdivisors ( A , B , C ) : NEW_LINE INDENT sum = 0 NEW_LINE Divisors ( ) NEW_LINE for i in range ( 1 , A + 1 ) : NEW_LINE INDENT for j in range ( 1 , C + 1 ) : NEW_LINE INDENT x = i * j * k NEW_LINE sum += cnt [ x ] NEW_LINE if ( sum >= mod ) : NEW_LINE INDENT sum -= mod NEW_LINE DEDENT DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = 5 NEW_LINE B = 6 NEW_LINE C = 7 NEW_LINE print ( Sumofdivisors ( A , B , C ) ) NEW_LINE DEDENT"],"references":["N = 100005 NEW_LINE mod = 1000000007 NEW_LINE cnt = [ 0 ] * N ; NEW_LINE def Divisors ( ) : NEW_LINE INDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( 1 , N \/\/ i ) : NEW_LINE INDENT cnt [ i * j ] += 1 ; NEW_LINE DEDENT DEDENT DEDENT def Sumofdivisors ( A , B , C ) : NEW_LINE INDENT sum = 0 ; NEW_LINE Divisors ( ) ; NEW_LINE for i in range ( 1 , A + 1 ) : NEW_LINE INDENT for j in range ( 1 , B + 1 ) : NEW_LINE INDENT for k in range ( 1 , C + 1 ) : NEW_LINE INDENT x = i * j * k ; NEW_LINE sum += cnt [ x ] ; NEW_LINE if ( sum >= mod ) : NEW_LINE INDENT sum -= mod ; NEW_LINE DEDENT DEDENT DEDENT DEDENT return sum ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = 5 ; B = 6 ; C = 7 ; NEW_LINE print ( Sumofdivisors ( A , B , C ) ) ; NEW_LINE DEDENT"],"bleu":0.7295182199554102,"rouge_l":0.866307541625857}
{"id":1345,"predictions":["def factorial ( N ) : NEW_LINE INDENT fact = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT fact = fact * i NEW_LINE DEDENT return fact NEW_LINE DEDENT def nthTerm ( N ) : NEW_LINE INDENT return ( factorial ( N + 1 ) \/\/ 2 ) NEW_LINE DEDENT N = 6 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE"],"references":["def factorial ( N ) : NEW_LINE INDENT fact = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT fact = fact * i NEW_LINE DEDENT return fact NEW_LINE DEDENT def nthTerm ( N ) : NEW_LINE INDENT return ( factorial ( N + 1 ) \/\/ 2 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 6 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT"],"bleu":0.800730562836939,"rouge_l":0.8944281524926685}
{"id":1346,"predictions":["def prefix ( string ) : NEW_LINE INDENT k = 1 NEW_LINE n = len ( string ) NEW_LINE g = [ ] NEW_LINE flag = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( string [ i ] == string [ 0 ] ) : NEW_LINE INDENT g . append ( i ) NEW_LINE flag = 1 NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT print ( string ) NEW_LINE DEDENT else : NEW_LINE length = len ( string ) NEW_LINE while ( k < g [ 0 ] ) : NEW_LINE INDENT cnt = 0 NEW_LINE for j in range ( 0 , length ) : NEW_LINE INDENT if ( ( g [ j ] + k ) < n and string [ g [ g [ j ] + k ] == string [ k ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if ( cnt == length ) : NEW_LINE INDENT k += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in range ( k ) : NEW_LINE INDENT print ( string [ i ] , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" abcab \" NEW_LINE prefix ( string ) NEW_LINE DEDENT"],"references":["def prefix ( string ) : NEW_LINE INDENT k = 1 ; NEW_LINE n = len ( string ) ; NEW_LINE g = [ ] ; NEW_LINE flag = 0 ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( string [ i ] == string [ 0 ] ) : NEW_LINE INDENT g . append ( i ) ; NEW_LINE flag = 1 ; NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT print ( string ) ; NEW_LINE DEDENT else : NEW_LINE INDENT length = len ( g ) ; NEW_LINE while ( k < g [ 0 ] ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for j in range ( length ) : NEW_LINE INDENT if ( string [ g [ j ] + k ] == string [ k ] ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT if ( cnt == len ) : NEW_LINE INDENT k += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT for i in range ( k + 1 ) : NEW_LINE INDENT print ( string [ i ] , end = \" \" ) ; NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" abcab \" ; NEW_LINE prefix ( string ) ; NEW_LINE DEDENT"],"bleu":0.7788608843848043,"rouge_l":0.9187757909215957}
{"id":1347,"predictions":["def findTerm ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT else : NEW_LINE INDENT term = 7 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT term = term * 2 + ( i - 1 ) NEW_LINE DEDENT return term NEW_LINE DEDENT DEDENT n = 5 NEW_LINE print ( findTerm ( n ) ) NEW_LINE"],"references":["def findTerm ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return n NEW_LINE DEDENT else : NEW_LINE INDENT term = 7 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT term = term * 2 + ( i - 1 ) ; NEW_LINE DEDENT DEDENT return term ; NEW_LINE DEDENT print ( findTerm ( 5 ) ) NEW_LINE"],"bleu":0.76680096167949,"rouge_l":0.9201670921327452}
{"id":1348,"predictions":["import math NEW_LINE def get_most_setbit ( num ) : NEW_LINE INDENT pos = 0 NEW_LINE for i in range ( 0 , INT_SIZE ) : NEW_LINE INDENT if ( ( num & ( 1 << i ) ) == 0 ) : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return pos NEW_LINE DEDENT num = 18 NEW_LINE pos = Right_most_setbit ( num ) NEW_LINE print ( pos ) NEW_LINE"],"references":["INT_SIZE = 32 NEW_LINE def Right_most_setbit ( num ) : NEW_LINE INDENT pos = 1 NEW_LINE for i in range ( INT_SIZE ) : NEW_LINE INDENT if not ( num & ( 1 << i ) ) : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return pos NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT num = 18 NEW_LINE pos = Right_most_setbit ( num ) NEW_LINE print ( pos ) NEW_LINE DEDENT"],"bleu":0.6690105412743118,"rouge_l":0.8081866719398854}
{"id":1349,"predictions":["def subarrayXor ( arr , n , m ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT xorSum = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT xorSum = xorSum ^ arr [ j ] NEW_LINE if ( xorSum == m ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 4 , 2 , 2 , 6 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE m = 6 NEW_LINE print ( \" Number ▁ of ▁ subarrays ▁ having ▁ given ▁ XOR ▁ is ▁ \" , subarrayXor ( arr , n , m ) ) NEW_LINE"],"references":["def subarrayXor ( arr , n , m ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT xorSum = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT xorSum = xorSum ^ arr [ j ] NEW_LINE if ( xorSum == m ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT arr = [ 4 , 2 , 2 , 6 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE m = 6 NEW_LINE print ( \" Number ▁ of ▁ subarrays ▁ having ▁ given ▁ XOR ▁ is ▁ \" , subarrayXor ( arr , n , m ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"bleu":0.7703012995015196,"rouge_l":0.878717472118959}
{"id":1350,"predictions":["import math NEW_LINE def testDivision ( N ) : NEW_LINE INDENT i = 2 NEW_LINE k = ceil ( math . sqrt ( N ) ) NEW_LINE while ( i <= k ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 49 NEW_LINE p = 47 NEW_LINE if ( p ) : NEW_LINE INDENT print ( \" Prime \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Composite \" ) NEW_LINE DEDENT DEDENT"],"references":["def TrialDivision ( N ) : NEW_LINE INDENT i = 2 NEW_LINE k = int ( N ** 0.5 ) NEW_LINE while ( i <= k ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 49 NEW_LINE p = TrialDivision ( N ) NEW_LINE if ( p ) : NEW_LINE INDENT print ( \" Prime \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Composite \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.8604878191338401,"rouge_l":0.9139275340162056}
{"id":1351,"predictions":["def count ( arr , N , K ) : NEW_LINE INDENT count = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] == K ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( count * ( count + 1 ) ) \/\/ 2 NEW_LINE count = 0 NEW_LINE DEDENT DEDENT ans = ans + ( count * ( count + 1 ) ) \/\/ 2 NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 0 , 0 , 1 , 1 , 1 , 0 ] NEW_LINE N = len ( arr ) NEW_LINE K = 0 NEW_LINE print ( count ( arr , N , K ) ) NEW_LINE DEDENT"],"references":["def count ( arr , N , K ) : NEW_LINE INDENT count = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] == K ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( count * ( count + 1 ) ) \/\/ 2 NEW_LINE count = 0 NEW_LINE DEDENT DEDENT ans = ans + ( count * ( count + 1 ) ) \/\/ 2 NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 0 , 0 , 1 , 1 , 0 , 0 ] NEW_LINE N = len ( arr ) NEW_LINE K = 0 NEW_LINE print ( count ( arr , N , K ) ) NEW_LINE DEDENT"],"bleu":0.9863932896630523,"rouge_l":0.9932432432432432}
{"id":1352,"predictions":["def centered_hptagonal_num ( n ) : NEW_LINE INDENT return ( 7 * n * n - 7 * n + 2 ) \/\/ 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( n , \" th ▁ Centered \" , \" ▁ d ▁ : ▁ \" , centered_he_num ( n ) ) NEW_LINE DEDENT"],"references":["def centered_heptagonal_num ( n ) : NEW_LINE INDENT return ( 7 * n * n - 7 * n + 2 ) \/\/ 2 NEW_LINE DEDENT n = 5 NEW_LINE print ( \" % sth ▁ Centered ▁ heptagonal ▁ number ▁ : ▁ \" % n , centered_heptagonal_num ( n ) ) NEW_LINE"],"bleu":0.5269909784938233,"rouge_l":0.7532930845225028}
{"id":1353,"predictions":["import math NEW_LINE pi = 3.14159265 NEW_LINE def findsolution ( d , h , m , n ) : NEW_LINE INDENT k = ( 4 * m ) \/ ( pie * d * d ) NEW_LINE if ( n > k ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT ans = ( h \/ ( k - n ) ) NEW_LINE return ans NEW_LINE DEDENT d = 1 NEW_LINE h = 1 NEW_LINE m = 1 NEW_LINE n = 1 NEW_LINE print ( findsolution ( d , h , m , n ) ) NEW_LINE"],"references":["pie = 3.1415926535897 NEW_LINE def findsolution ( d , h , m , n ) : NEW_LINE INDENT k = ( 4 * m ) \/ ( pie * d * d ) NEW_LINE if ( n > k ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT ans = ( h \/ ( k - n ) ) NEW_LINE return round ( ans , 5 ) NEW_LINE DEDENT d = 1 NEW_LINE h = 1 NEW_LINE m = 1 NEW_LINE n = 1 NEW_LINE print ( findsolution ( d , h , m , n ) ) NEW_LINE"],"bleu":0.8979457430656173,"rouge_l":0.9370512606445148}
{"id":1354,"predictions":["def countNum ( N , arr ) : NEW_LINE INDENT sum = 0 NEW_LINE count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT if ( ( sum - arr [ i ] ) % arr [ i ] == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 3 , 10 , 4 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countNum ( n , arr ) ) NEW_LINE"],"references":["def countNum ( N , arr ) : NEW_LINE INDENT Sum , count = 0 , 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT if ( ( Sum - arr [ i ] ) % arr [ i ] == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 3 , 10 , 4 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countNum ( n , arr ) ) NEW_LINE"],"bleu":0.8962137948357985,"rouge_l":0.9444444444444445}
{"id":1355,"predictions":["def CountTrailingZeros ( n ) : NEW_LINE INDENT bit = [ 0 ] * ( n ) NEW_LINE bit1 = bit [ : : : - 1 ] NEW_LINE zero = 0 NEW_LINE for i in range ( 64 ) : NEW_LINE INDENT if ( bit1 [ i ] == '0' ) : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return zero NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 NEW_LINE ans = CountTrailingZeros ( n ) NEW_LINE print ( ans ) NEW_LINE DEDENT"],"references":["def CountTrailingZeros ( n ) : NEW_LINE INDENT bit = bin ( n ) [ 2 : ] NEW_LINE bit = bit [ : : - 1 ] NEW_LINE zero = 0 ; NEW_LINE for i in range ( len ( bit ) ) : NEW_LINE INDENT if ( bit [ i ] == '0' ) : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return zero NEW_LINE DEDENT n = 4 NEW_LINE ans = CountTrailingZeros ( n ) NEW_LINE print ( ans ) NEW_LINE"],"bleu":0.6858100203029286,"rouge_l":0.8324803821221426}
{"id":1356,"predictions":["def printConsecutive ( last , first ) : NEW_LINE INDENT print ( \" ▁ \" , end = \" \" ) NEW_LINE for x in range ( first , last + 1 ) : NEW_LINE INDENT print ( \" ▁ \" , x , end = \" \" ) NEW_LINE DEDENT DEDENT def findConsecutive ( N ) : NEW_LINE INDENT for last in range ( 1 , last ) : NEW_LINE INDENT if ( 2 * N == ( last - first ) * ( last + first + 1 ) ) : NEW_LINE INDENT print ( N , \" = ▁ = , end = \" \" ) NEW_LINE printConsecutive ( last , first + 1 ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( \" - 1\" ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 12 NEW_LINE findConsecutive ( n ) NEW_LINE DEDENT"],"references":["def printConsecutive ( last , first ) : NEW_LINE INDENT print ( first , end = \" \" ) NEW_LINE first += 1 NEW_LINE for x in range ( first , last + 1 ) : NEW_LINE INDENT print ( \" ▁ + \" , x , end = \" \" ) NEW_LINE DEDENT DEDENT def findConsecutive ( N ) : NEW_LINE INDENT for last in range ( 1 , N ) : NEW_LINE INDENT for first in range ( 0 , last ) : NEW_LINE INDENT if 2 * N == ( last - first ) * ( last + first + 1 ) : NEW_LINE INDENT print ( N , \" = ▁ \" , end = \" \" ) NEW_LINE printConsecutive ( last , first + 1 ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( \" - 1\" ) NEW_LINE DEDENT n = 12 NEW_LINE findConsecutive ( n ) NEW_LINE"],"bleu":0.8274064849256189,"rouge_l":0.8701298701298701}
{"id":1357,"predictions":["def LCSubStr ( X , Y , m , n ) : NEW_LINE INDENT LCSuff = [ [ 0 for i in range ( n + 1 ) ] for j in range ( m + 1 ) ] NEW_LINE result = 0 NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT LCStuff [ i ] [ j ] = 0 NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] ) : NEW_LINE INDENT LCStuffuff [ i ] [ j ] = LCStuff [ i - 1 ] [ j - 1 ] + 1 NEW_LINE result = max ( result , LCStuff [ i ] [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT LCStuffuff [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT X = \"TwosUtilGeeksforGeeks ( Geeks , Y , m , n ) NEW_LINE m = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE print ( \" Length ▁ of ▁ Longest ▁ Substring ▁ is \" , LCSubStr ( X , Y , m , n ) ) NEW_LINE DEDENT"],"references":["def LCSubStr ( X , Y , m , n ) : NEW_LINE INDENT LCSuff = [ [ 0 for k in range ( n + 1 ) ] for l in range ( m + 1 ) ] NEW_LINE result = 0 NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT LCSuff [ i ] [ j ] = 0 NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] ) : NEW_LINE INDENT LCSuff [ i ] [ j ] = LCSuff [ i - 1 ] [ j - 1 ] + 1 NEW_LINE result = max ( result , LCSuff [ i ] [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT LCSuff [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT X = ' OldSite : GeeksforGeeks . org ' NEW_LINE Y = ' NewSite : GeeksQuiz . com ' NEW_LINE m = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE print ( ' Length ▁ of ▁ Longest ▁ Common ▁ Substring ▁ is ' , LCSubStr ( X , Y , m , n ) ) NEW_LINE"],"bleu":0.791158148730323,"rouge_l":0.8801568957063809}
{"id":1358,"predictions":["def getPassingCars ( A , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( A [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( A [ j ] == 1 ) : NEW_LINE INDENT result = result + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT A = [ 0 , 1 , 0 , 1 , 1 , 1 ] NEW_LINE n = len ( A ) NEW_LINE print ( getPassingCars ( A , n ) ) NEW_LINE"],"references":["def getPassingCars ( A , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 0 , n - 1 , 1 ) : NEW_LINE INDENT if ( A [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i + 1 , n , 1 ) : NEW_LINE INDENT if ( A [ j ] ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 0 , 1 , 0 , 1 , 1 ] NEW_LINE n = len ( A ) NEW_LINE print ( getPassingCars ( A , n ) ) NEW_LINE DEDENT"],"bleu":0.7767787153741567,"rouge_l":0.8720274914089347}
{"id":1359,"predictions":["import math NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , prev ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT"],"references":["class Node : NEW_LINE INDENT def __init__ ( self , next = None , prev = None , data = None ) : NEW_LINE INDENT self . next = next NEW_LINE self . prev = prev NEW_LINE self . data = data NEW_LINE DEDENT DEDENT"],"bleu":0.48511086265792475,"rouge_l":0.6301652892561984}
{"id":1360,"predictions":["def search ( arr , n , x ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == x ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 10 , 30 , 15 ] ; NEW_LINE x = 30 ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( search ( arr , n , x ) ) ; NEW_LINE DEDENT"],"references":["def search ( arr , n , x ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == x : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 1 , 10 , 30 , 15 ] NEW_LINE x = 30 NEW_LINE n = len ( arr ) NEW_LINE print ( x , \" is ▁ present ▁ at ▁ index \" , search ( arr , n , x ) ) NEW_LINE"],"bleu":0.6282926360221548,"rouge_l":0.8270822327874626}
{"id":1361,"predictions":["def findKHCF ( x , y , k ) : NEW_LINE INDENT small = min ( x , y ) NEW_LINE count = 1 NEW_LINE for i in range ( 2 , small + 1 ) : NEW_LINE INDENT if ( x % i == 0 and y % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( count == k ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT x = 4 NEW_LINE y = 24 NEW_LINE k = 3 NEW_LINE print ( findKHCF ( x , y , k ) ) NEW_LINE"],"references":["def findKHCF ( x , y , k ) : NEW_LINE INDENT small = min ( x , y ) NEW_LINE count = 1 NEW_LINE for i in range ( 2 , small + 1 ) : NEW_LINE INDENT if ( x % i == 0 and y % i == 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT if ( count == k ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT x = 4 NEW_LINE y = 24 NEW_LINE k = 3 NEW_LINE print ( findKHCF ( x , y , k ) ) NEW_LINE"],"bleu":0.9570796255844123,"rouge_l":0.979270573566085}
{"id":1362,"predictions":["def distancesum ( x , y , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT sum += ( abs ( x [ i ] - x [ j ] ) + abs ( y [ i ] - y [ j ] ) ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT x = [ - 1 , 1 , 3 , 2 ] NEW_LINE y = [ 5 , 6 , 5 , 3 ] NEW_LINE n = len ( x ) NEW_LINE print ( distancesum ( x , y , n ) ) NEW_LINE"],"references":["def distancesum ( x , y , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT sum += ( abs ( x [ i ] - x [ j ] ) + abs ( y [ i ] - y [ j ] ) ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT x = [ - 1 , 1 , 3 , 2 ] NEW_LINE y = [ 5 , 6 , 5 , 3 ] NEW_LINE n = len ( x ) NEW_LINE print ( distancesum ( x , y , n ) ) NEW_LINE"],"bleu":1.0,"rouge_l":1.0}
{"id":1363,"predictions":["days = [ 31 , 28 , 31 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 , 31 ] NEW_LINE def dayOfYear ( date ) : NEW_LINE INDENT year = int ( date [ 0 : 4 ] ) NEW_LINE month = int ( date [ 5 : 4 ] ) NEW_LINE if ( month > 2 and year % 4 == 0 and ( year % 4 != 0 or year % 400 == 0 ) ) : NEW_LINE INDENT day = day + days [ day - 1 ] NEW_LINE DEDENT while ( month ) : NEW_LINE INDENT day = day + days [ day - 1 ] NEW_LINE DEDENT return day NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT date = \" 2019 - 1 NEW_LINE print ( dayOfYear ( date ) ) NEW_LINE DEDENT"],"references":["days = [ 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] ; NEW_LINE def dayOfYear ( date ) : NEW_LINE INDENT year = ( int ) ( date [ 0 : 4 ] ) ; NEW_LINE month = ( int ) ( date [ 5 : 7 ] ) ; NEW_LINE day = ( int ) ( date [ 8 : ] ) ; NEW_LINE if ( month > 2 and year % 4 == 0 and ( year % 100 != 0 or year % 400 == 0 ) ) : NEW_LINE INDENT day += 1 ; NEW_LINE DEDENT month -= 1 ; NEW_LINE while ( month > 0 ) : NEW_LINE INDENT day = day + days [ month - 1 ] ; NEW_LINE month -= 1 ; NEW_LINE DEDENT return day ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT date = \"2019-01-09\" ; NEW_LINE print ( dayOfYear ( date ) ) ; NEW_LINE DEDENT"],"bleu":0.6038707665551045,"rouge_l":0.8022434967604681}
{"id":1364,"predictions":["def isUnary ( n ) : NEW_LINE INDENT if ( n == 1 or n == 7 ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( n \/ 10 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT elif ( n != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT x = n % 10 NEW_LINE sum = sum + x * x NEW_LINE n = n \/\/ 10 NEW_LINE DEDENT return isUnary ( sum ) NEW_LINE DEDENT def countUnary ( a , b ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT if ( isUnary ( i ) == True ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 1000 NEW_LINE b = 1099 NEW_LINE print ( countUnary ( a , b ) ) NEW_LINE DEDENT"],"references":["def isUnary ( n ) : NEW_LINE INDENT if ( n == 1 or n == 7 ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( int ( n \/ 10 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT x = n % 10 NEW_LINE sum = sum + x * x NEW_LINE n = int ( n \/ 10 ) NEW_LINE DEDENT return isUnary ( sum ) NEW_LINE DEDENT def countUnary ( a , b ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( a , b + 1 , 1 ) : NEW_LINE INDENT if ( isUnary ( i ) == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 1000 NEW_LINE b = 1099 NEW_LINE print ( countUnary ( a , b ) ) NEW_LINE DEDENT"],"bleu":0.8507489590598841,"rouge_l":0.9202338299075993}
{"id":1365,"predictions":["def find_count ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in arr : NEW_LINE INDENT x = bin ( i ) . count ( '1' ) NEW_LINE if ( i % x == 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE print ( find_count ( arr ) ) NEW_LINE DEDENT"],"references":["def bitsoncount ( x ) : NEW_LINE INDENT return bin ( x ) . count ( '1' ) NEW_LINE DEDENT def find_count ( arr ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in arr : NEW_LINE INDENT x = bitsoncount ( i ) NEW_LINE if ( i % x == 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE print ( find_count ( arr ) ) NEW_LINE"],"bleu":0.7797954823225911,"rouge_l":0.7657819225251076}
{"id":1366,"predictions":["MOD = 1000000007 NEW_LINE def product ( ar , n ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT result = ( result * ar [ i ] ) % MOD NEW_LINE DEDENT return result NEW_LINE DEDENT ar = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( ar ) NEW_LINE print ( product ( ar , n ) ) NEW_LINE"],"references":["MOD = 1000000007 NEW_LINE def product ( ar , n ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT result = ( result * ar [ i ] ) % MOD NEW_LINE DEDENT return result NEW_LINE DEDENT ar = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( ar ) NEW_LINE print ( product ( ar , n ) ) NEW_LINE"],"bleu":0.9549325141914469,"rouge_l":0.9849024952820298}
{"id":1367,"predictions":["MOD = 1000000007 NEW_LINE def SieveOfEratosthenes ( prime , p_size ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , p_size + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( p * 2 , p_size + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def productPrimeFreq ( arr , n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) NEW_LINE SieveOfEratosthenes ( prime , n + 1 ) NEW_LINE m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT m [ arr [ i ] ] = m . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT product = 1 NEW_LINE for it in m : NEW_LINE INDENT if ( prime [ m [ it ] ] ) : NEW_LINE INDENT product *= ( it % MOD ) NEW_LINE product %= MOD NEW_LINE DEDENT DEDENT return product NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 5 , 4 , 6 , 5 , 4 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( productPrimeFreq ( arr , n ) ) NEW_LINE DEDENT"],"references":["MOD = 1000000007 NEW_LINE def SieveOfEratosthenes ( prime , p_size ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , p_size ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( 2 * p , p_size , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def productPrimeFreq ( arr , n ) : NEW_LINE INDENT prime = [ True for i in range ( n + 1 ) ] NEW_LINE SieveOfEratosthenes ( prime , n + 1 ) NEW_LINE i , j = 0 , 0 NEW_LINE m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT m [ arr [ i ] ] = m . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT product = 1 NEW_LINE for it in m : NEW_LINE INDENT if ( prime [ m [ it ] ] ) : NEW_LINE INDENT product *= it % MOD NEW_LINE product %= MOD NEW_LINE DEDENT DEDENT return product NEW_LINE DEDENT arr = [ 5 , 4 , 6 , 5 , 4 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( productPrimeFreq ( arr , n ) ) NEW_LINE"],"bleu":0.8471218584467586,"rouge_l":0.920368818105616}
{"id":1368,"predictions":["def maxval ( a , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT print ( \" Invalid ▁ Input \" ) NEW_LINE return - 9999 NEW_LINE DEDENT max1 = 0 NEW_LINE max2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = a [ i ] + i NEW_LINE if ( x > max1 ) : NEW_LINE INDENT max2 = max1 NEW_LINE max1 = x NEW_LINE DEDENT elif ( x > max2 and x != max1 ) : NEW_LINE INDENT max2 = x NEW_LINE DEDENT DEDENT return ( max1 * max2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 5 , 3 , 1 , 10 ] NEW_LINE length = len ( arr ) NEW_LINE print ( maxval ( arr , length ) ) NEW_LINE DEDENT"],"references":["def maxval ( a , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT print ( \" Invalid ▁ Input \" ) NEW_LINE return - 9999 NEW_LINE DEDENT ( max1 , max2 ) = ( 0 , 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = a [ i ] + i NEW_LINE if ( x > max1 ) : NEW_LINE INDENT max2 = max1 NEW_LINE max1 = x NEW_LINE DEDENT elif ( x > max2 and x != max1 ) : NEW_LINE INDENT max2 = x NEW_LINE DEDENT DEDENT return ( max1 * max2 ) NEW_LINE DEDENT print ( maxval ( [ 4 , 5 , 3 , 1 , 10 ] , 5 ) ) NEW_LINE"],"bleu":0.7453565185247286,"rouge_l":0.8502501786990707}
{"id":1369,"predictions":["class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def minPathSumUtil ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( root . left == None and root . right == None ) : NEW_LINE INDENT return root . data NEW_LINE DEDENT ls = minPathSumUtil ( root . left ) NEW_LINE rs = minPathSumUtil ( root . right , None ) NEW_LINE if ( root . left != None and root . right != None ) : NEW_LINE INDENT result = min ( result , ls + root . data ) NEW_LINE return min ( ls + root . data , rs + root . data ) NEW_LINE DEDENT if ( root . left == None ) : NEW_LINE INDENT return rs + root + root . data NEW_LINE DEDENT else : NEW_LINE INDENT return ls + root . data NEW_LINE DEDENT DEDENT def minPathSum ( root ) : NEW_LINE INDENT result = sys . maxsize NEW_LINE return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 4 ) NEW_LINE root . left = newNode ( 5 ) NEW_LINE root . right = newNode ( 5 ) NEW_LINE root . left . left = newNode ( 2 ) NEW_LINE root . left . right = newNode ( - 3 ) NEW_LINE root . left . left = newNode ( 1 ) NEW_LINE root . left . left = newNode ( 2 ) NEW_LINE root . right . left = newNode ( 1 ) NEW_LINE root . right . right = newNode ( 8 ) NEW_LINE print ( minPathSum ( root ) ) NEW_LINE DEDENT"],"references":["class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def newNode ( data ) : NEW_LINE INDENT node = Node ( 0 ) NEW_LINE node . data = data NEW_LINE node . left = node . right = None NEW_LINE return ( node ) NEW_LINE DEDENT result = - 1 NEW_LINE def minPathSumUtil ( root ) : NEW_LINE INDENT global result NEW_LINE if ( root == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( root . left == None and root . right == None ) : NEW_LINE INDENT return root . data NEW_LINE DEDENT ls = minPathSumUtil ( root . left ) NEW_LINE rs = minPathSumUtil ( root . right ) NEW_LINE if ( root . left != None and root . right != None ) : NEW_LINE INDENT result = min ( result , ls + rs + root . data ) NEW_LINE return min ( ls + root . data , rs + root . data ) NEW_LINE DEDENT if ( root . left == None ) : NEW_LINE INDENT return rs + root . data NEW_LINE DEDENT else : NEW_LINE INDENT return ls + root . data NEW_LINE DEDENT DEDENT def minPathSum ( root ) : NEW_LINE INDENT global result NEW_LINE result = 9999999 NEW_LINE minPathSumUtil ( root ) NEW_LINE return result NEW_LINE DEDENT root = newNode ( 4 ) NEW_LINE root . left = newNode ( 5 ) NEW_LINE root . right = newNode ( - 6 ) NEW_LINE root . left . left = newNode ( 2 ) NEW_LINE root . left . right = newNode ( - 3 ) NEW_LINE root . right . left = newNode ( 1 ) NEW_LINE root . right . right = newNode ( 8 ) NEW_LINE print ( minPathSum ( root ) ) NEW_LINE"],"bleu":0.8117177855801064,"rouge_l":0.8368140868140869}
{"id":1370,"predictions":["def andOperator ( a , b ) : NEW_LINE INDENT while ( a < b ) : NEW_LINE INDENT b -= ( b & - b ) NEW_LINE DEDENT return b NEW_LINE DEDENT a = 10 NEW_LINE b = 15 NEW_LINE print ( andOperator ( a , b ) ) NEW_LINE"],"references":["def andOperator ( a , b ) : NEW_LINE INDENT while ( a < b ) : NEW_LINE INDENT b -= ( b & - b ) NEW_LINE DEDENT return b NEW_LINE DEDENT a , b = 10 , 15 NEW_LINE print ( andOperator ( a , b ) ) NEW_LINE"],"bleu":0.8936040792039803,"rouge_l":0.9411764705882352}
{"id":1371,"predictions":["from math import gcd NEW_LINE def countPrimitiveRoots ( p ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 2 , p ) : NEW_LINE INDENT if ( gcd ( i , p ) == 1 ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT p = 5 NEW_LINE print ( countPrimitiveRoots ( p - 1 ) ) NEW_LINE DEDENT"],"references":["from math import gcd NEW_LINE def countPrimitiveRoots ( p ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 2 , p , 1 ) : NEW_LINE INDENT if ( gcd ( i , p ) == 1 ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT p = 5 NEW_LINE print ( countPrimitiveRoots ( p - 1 ) ) NEW_LINE DEDENT"],"bleu":0.8952801163562983,"rouge_l":0.9613006183921803}
{"id":1372,"predictions":["def printPattern ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , 2 * n ) : NEW_LINE INDENT if ( j == ( n - i + 1 ) or j == ( n + i - 1 ) ) : NEW_LINE INDENT print ( \" * ▁ \" , end = \" \" ) ; NEW_LINE DEDENT elif ( ( i >= 4 and i <= n - 4 ) and ( j == n - i + 4 or j == n + i - 4 ) ) : NEW_LINE INDENT print ( \" * ▁ \" , end = \" ▁ \" ) ; NEW_LINE DEDENT elif ( i == n or ( i == n - 4 and j >= n - ( n - 2 * 4 ) and j <= n + 2 * 4 ) ) : NEW_LINE INDENT print ( \" * ▁ \" , end = \" ▁ \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" ▁ \" , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT print ( ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 9 ; NEW_LINE printPattern ( N ) ; NEW_LINE DEDENT"],"references":["def printPattern ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , 2 * n ) : NEW_LINE INDENT if ( j == ( n - i + 1 ) or j == ( n + i - 1 ) ) : NEW_LINE INDENT print ( \" * ▁ \" , end = \" \" ) NEW_LINE DEDENT elif ( ( i >= 4 and i <= n - 4 ) and ( j == n - i + 4 or j == n + i - 4 ) ) : NEW_LINE INDENT print ( \" * ▁ \" , end = \" \" ) NEW_LINE DEDENT elif ( i == n or ( i == n - 4 and j >= n - ( n - 2 * 4 ) and j <= n + n - 2 * 4 ) ) : NEW_LINE INDENT print ( \" * ▁ \" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" ▁ \" + \" ▁ \" , end = \" \" ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT N = 9 NEW_LINE printPattern ( N ) NEW_LINE"],"bleu":0.8293861458949969,"rouge_l":0.93957345971564}
{"id":1373,"predictions":["def printOrder ( arr , n , k ) : NEW_LINE INDENT len1 = k ; NEW_LINE len2 = n - k ; NEW_LINE arr1 = [ 0 ] * k ; NEW_LINE arr2 = [ 0 ] * k ; NEW_LINE for i in range ( k ) : NEW_LINE INDENT arr1 [ i ] = arr [ i ] ; NEW_LINE DEDENT for i in range ( k , n ) : NEW_LINE INDENT arr2 [ i - k ] = arr [ i ] ; NEW_LINE DEDENT arr1 . sort ( ) ; NEW_LINE arr2 . sort ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i < k ) : NEW_LINE INDENT arr [ i ] = arr1 [ i ] ; NEW_LINE DEDENT else : NEW_LINE INDENT arr2 = arr2 [ len2 - 1 ] ; NEW_LINE len2 -= 1 ; NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 5 , 4 , 6 , 2 , 1 , 3 , 8 , 9 , - 1 ] ; NEW_LINE k = 4 ; NEW_LINE n = len ( arr ) ; NEW_LINE printOrder ( arr , n , k ) ; NEW_LINE DEDENT"],"references":["def printOrder ( arr , n , k ) : NEW_LINE INDENT len1 = k NEW_LINE len2 = n - k NEW_LINE arr1 = [ 0 ] * k NEW_LINE arr2 = [ 0 ] * ( n - k ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT arr1 [ i ] = arr [ i ] NEW_LINE DEDENT for i in range ( k , n ) : NEW_LINE INDENT arr2 [ i - k ] = arr [ i ] NEW_LINE DEDENT arr1 . sort ( ) NEW_LINE arr2 . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i < k ) : NEW_LINE INDENT arr [ i ] = arr1 [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = arr2 [ len2 - 1 ] NEW_LINE len2 -= 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 5 , 4 , 6 , 2 , 1 , 3 , 8 , 9 , - 1 ] NEW_LINE k = 4 NEW_LINE n = len ( arr ) NEW_LINE printOrder ( arr , n , k ) NEW_LINE DEDENT"],"bleu":0.8192596197838027,"rouge_l":0.9510302197802197}
{"id":1374,"predictions":["def isPlusPossible ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] in mp . keys ( ) ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT foundModOne = False NEW_LINE for x in mp : NEW_LINE INDENT element = key NEW_LINE frequency = x NEW_LINE if ( frequency % 4 == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( foundModOne ) : NEW_LINE INDENT return False NEW_LINE DEDENT foundModOne = True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT arr = [ 1 , 1 , 1 , 1 , 2 , 2 , 2 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE if ( isPlusPossible ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def isPlusPossible ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] = mp . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT foundModOne = False NEW_LINE for x in mp : NEW_LINE INDENT element = x NEW_LINE frequency = mp [ x ] NEW_LINE if ( frequency % 4 == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( frequency % 4 == 1 ) : NEW_LINE INDENT if ( foundModOne == True ) : NEW_LINE INDENT return False NEW_LINE DEDENT foundModOne = True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT arr = [ 1 , 1 , 1 , 1 , 2 , 2 , 2 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE if ( isPlusPossible ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.8423490791280318,"rouge_l":0.8595262793914246}
{"id":1375,"predictions":["def sumOfAP ( a , d , n ) : NEW_LINE INDENT sum = ( n \/ 2 ) * ( 2 * a + ( n - 1 ) * d ) ; NEW_LINE return sum ; NEW_LINE DEDENT n = 20 ; NEW_LINE a = 2.5 ; d = 1.5 ; NEW_LINE print ( sumOfAP ( a , d , n ) ) ; NEW_LINE"],"references":["def sumOfAP ( a , d , n ) : NEW_LINE INDENT sum = ( n \/ 2 ) * ( 2 * a + ( n - 1 ) * d ) NEW_LINE return sum NEW_LINE DEDENT n = 20 NEW_LINE a = 2.5 NEW_LINE d = 1.5 NEW_LINE print ( sumOfAP ( a , d , n ) ) NEW_LINE"],"bleu":0.7786539243583475,"rouge_l":0.9523931405170207}
{"id":1376,"predictions":["import math NEW_LINE def isPerfectSquare ( num ) : NEW_LINE INDENT n = int ( math . sqrt ( num ) ) NEW_LINE return ( n * n == num ) NEW_LINE DEDENT def checkFib ( array , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( isPerfectSquare ( 5 * array [ i ] * array [ i ] + 4 ) or isPerfectSquare ( 5 * array [ i ] * array [ i ] - 4 ) ) : NEW_LINE INDENT print ( array [ i ] , end = \" ▁ \" ) NEW_LINE count += 1 NEW_LINE DEDENT DEDENT if ( count == 0 ) : NEW_LINE INDENT print ( \" None ▁ Present \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT array = [ 4 , 2 , 8 , 5 , 20 , 1 , 40 , 13 , 23 ] NEW_LINE n = len ( array ) NEW_LINE checkFib ( array , n ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def isPerfectSquare ( num ) : NEW_LINE INDENT n = int ( math . sqrt ( num ) ) NEW_LINE return ( n * n == num ) NEW_LINE DEDENT def checkFib ( array , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( isPerfectSquare ( 5 * array [ i ] * array [ i ] + 4 ) or isPerfectSquare ( 5 * array [ i ] * array [ i ] - 4 ) ) : NEW_LINE INDENT print ( array [ i ] , \" ▁ \" , end = \" \" ) ; NEW_LINE count = count + 1 NEW_LINE DEDENT DEDENT if ( count == 0 ) : NEW_LINE INDENT print ( \" None ▁ present \" ) ; NEW_LINE DEDENT DEDENT array = [ 4 , 2 , 8 , 5 , 20 , 1 , 40 , 13 , 23 ] NEW_LINE n = len ( array ) NEW_LINE checkFib ( array , n ) NEW_LINE"],"bleu":0.8666633887340776,"rouge_l":0.9292410311880297}
{"id":1377,"predictions":["import math NEW_LINE def largestCube ( r ) : NEW_LINE INDENT if ( r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = ( 2 * r ) \/ math . sqrt ( 3 ) ) NEW_LINE return a NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT r = 5 NEW_LINE print ( largestCube ( r ) ) NEW_LINE DEDENT"],"references":["from math import sqrt NEW_LINE def largestCube ( r ) : NEW_LINE INDENT if ( r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = ( 2 * r ) \/ sqrt ( 3 ) NEW_LINE return a NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT r = 5 NEW_LINE print ( \" { 0 : . 6 } \" . format ( largestCube ( r ) ) ) NEW_LINE DEDENT"],"bleu":0.709404496232964,"rouge_l":0.8387983922149355}
{"id":1378,"predictions":["def countTrans transformations ( a , b ) : NEW_LINE INDENT n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE if ( m == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( m ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if ( j == 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = ( a [ j ] == b [ i ] ) NEW_LINE DEDENT elif ( a [ j ] == b [ i ] ) : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + 1 NEW_LINE DEDENT DEDENT elif ( a [ j ] == b [ i ] ) : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT return dp [ m - 1 ] [ n - 1 ] NEW_LINE DEDENT a = \" abcccdf \" NEW_LINE b = \" abccdf \" NEW_LINE print ( countTransization ( a , b ) ) NEW_LINE"],"references":["def countTransformation ( a , b ) : NEW_LINE INDENT n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE if m == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT dp = [ [ 0 ] * ( n ) for _ in range ( m ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT if j == 0 : NEW_LINE INDENT if a [ j ] == b [ i ] : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT elif a [ j ] == b [ i ] : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if a [ j ] == b [ i ] : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT return dp [ m - 1 ] [ n - 1 ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = \" abcccdf \" NEW_LINE b = \" abccdf \" NEW_LINE print ( countTransformation ( a , b ) ) NEW_LINE DEDENT"],"bleu":0.735240808522984,"rouge_l":0.8418821995218431}
{"id":1379,"predictions":["def findFourElements ( arr , n , X ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT mp [ arr [ i ] + arr [ j ] ] = ( i , j ) NEW_LINE DEDENT DEDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT sum = arr [ i ] + arr [ j ] NEW_LINE if ( X - sum in mp . keys ( ) ) : NEW_LINE INDENT p = mp [ X - sum ] NEW_LINE if ( p [ 0 ] != i and p [ 1 ] != j ) : NEW_LINE INDENT print ( arr [ i ] , \" , \" , arr [ j ] , \" , \" , arr [ p [ 1 ] ] ) NEW_LINE return 0 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT arr = [ 10 , 20 , 30 , 40 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE X = 91 NEW_LINE findFourElements ( arr , n , X ) ; NEW_LINE"],"references":["def findFourElements ( arr , n , X ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT mp [ arr [ i ] + arr [ j ] ] = [ i , j ] NEW_LINE DEDENT DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT summ = arr [ i ] + arr [ j ] NEW_LINE if ( X - summ ) in mp : NEW_LINE INDENT p = mp [ X - summ ] NEW_LINE if ( p [ 0 ] != i and p [ 0 ] != j and p [ 1 ] != i and p [ 1 ] != j ) : NEW_LINE INDENT print ( arr [ i ] , \" , ▁ \" , arr [ j ] , \" , ▁ \" , arr [ p [ 0 ] ] , \" , ▁ \" , arr [ p [ 1 ] ] , sep = \" \" ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT arr = [ 10 , 20 , 30 , 40 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE X = 91 NEW_LINE findFourElements ( arr , n , X ) NEW_LINE"],"bleu":0.7639830023263937,"rouge_l":0.8728139904610493}
{"id":1380,"predictions":["def countWays ( n ) : NEW_LINE INDENT counter = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT for k in range ( j , n ) : NEW_LINE INDENT if ( i + j + k + l == n ) : NEW_LINE INDENT counter = counter + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return counter NEW_LINE DEDENT n = 8 NEW_LINE print ( countWays ( n ) ) NEW_LINE"],"references":["def countWays ( n ) : NEW_LINE INDENT counter = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT for k in range ( j , n ) : NEW_LINE INDENT for l in range ( k , n ) : NEW_LINE INDENT if ( i + j + k + l == n ) : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return counter NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 8 NEW_LINE print ( countWays ( n ) ) NEW_LINE DEDENT"],"bleu":0.7033849923853063,"rouge_l":0.828882919892558}
{"id":1381,"predictions":["def maxConsecutiveOnes ( x ) : NEW_LINE INDENT count = 0 NEW_LINE while ( x ) : NEW_LINE INDENT x = ( x & ( x << 1 ) ) NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT print ( maxConsecutiveOnes ( 14 ) ) NEW_LINE print ( maxConsecutiveOnes ( 22 ) ) NEW_LINE"],"references":["def maxConsecutiveOnes ( x ) : NEW_LINE INDENT count = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT x = ( x & ( x << 1 ) ) NEW_LINE count = count + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT print ( maxConsecutiveOnes ( 14 ) ) NEW_LINE print ( maxConsecutiveOnes ( 222 ) ) NEW_LINE"],"bleu":0.8187455024979168,"rouge_l":0.9252808988764044}
{"id":1382,"predictions":["def isFuncinary ( num ) : NEW_LINE INDENT freq = [ 0 for i in range ( 10 ) ] NEW_LINE val = \" \" + num * 2 + num * 3 NEW_LINE for i in range ( len ( val ) ) : NEW_LINE INDENT digit = ord ( val [ i ] ) - ord ( '0' ) NEW_LINE if ( freq [ digit ] ) > 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT freq [ digit ] += 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , len ( freq ) ) : NEW_LINE INDENT if ( freq [ i ] == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT num = 432 NEW_LINE if ( num < 100 ) : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def isFascinating ( num ) : NEW_LINE INDENT freq = [ 0 ] * 10 NEW_LINE val = ( str ( num ) + str ( num * 2 ) + str ( num * 3 ) ) NEW_LINE for i in range ( len ( val ) ) : NEW_LINE INDENT digit = int ( val [ i ] ) NEW_LINE if freq [ digit ] > 0 : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT freq [ digit ] += 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , 10 ) : NEW_LINE INDENT if freq [ i ] == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT num = 192 NEW_LINE if num < 100 : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = isFascinating ( num ) NEW_LINE if ans : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT DEDENT"],"bleu":0.6489727086542374,"rouge_l":0.7748576434515989}
{"id":1383,"predictions":["def printDistinct ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( i == j - 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 6 , 10 , 5 , 4 , 9 , 120 , 4 , 6 , 10 ] NEW_LINE n = len ( arr ) ; NEW_LINE printDistinct ( arr , n ) ; NEW_LINE"],"references":["def printDistinct ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT d = 0 NEW_LINE for j in range ( 0 , i ) : NEW_LINE INDENT if ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT d = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( d == 0 ) : NEW_LINE INDENT print ( arr [ i ] ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 6 , 10 , 5 , 4 , 9 , 120 , 4 , 6 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE printDistinct ( arr , n ) NEW_LINE"],"bleu":0.7779262792253671,"rouge_l":0.8865528432340907}
{"id":1384,"predictions":["def closestMultiple ( n , x ) : NEW_LINE INDENT if ( x > n ) : NEW_LINE INDENT return x NEW_LINE DEDENT n = n + int ( x \/ 2 ) NEW_LINE n = n - ( n % x ) NEW_LINE return n NEW_LINE DEDENT n = 56297 NEW_LINE x = 27 NEW_LINE print ( closestMultiple ( n , x ) ) NEW_LINE"],"references":["def closestMultiple ( n , x ) : NEW_LINE INDENT if x > n : NEW_LINE INDENT return x ; NEW_LINE DEDENT z = ( int ) ( x \/ 2 ) ; NEW_LINE n = n + z ; NEW_LINE n = n - ( n % x ) ; NEW_LINE return n ; NEW_LINE DEDENT n = 56287 ; NEW_LINE x = 27 ; NEW_LINE print ( closestMultiple ( n , x ) ) ; NEW_LINE"],"bleu":0.5707332691185403,"rouge_l":0.8209959623149395}
{"id":1385,"predictions":["MAX = 1000 NEW_LINE def maxSubsequenceSubstring ( x , y , n , m ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( MAX ) ] for j in range ( MAX ) ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( x [ j - 1 ] == y [ i - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT ans = max ( ans , dp [ i ] [ n ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = \" ABCD \" NEW_LINE y = \" BACDCD \" NEW_LINE n = len ( x ) NEW_LINE m = len ( y ) NEW_LINE print ( maxSubsequenceSubstring ( x , y , n , m ) ) NEW_LINE DEDENT"],"references":["MAX = 1000 NEW_LINE def maxSubsequenceSubstring ( x , y , n , m ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( MAX ) ] for i in range ( MAX ) ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( x [ j - 1 ] == y [ i - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT ans = max ( ans , dp [ i ] [ n ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT x = \" ABCD \" NEW_LINE y = \" BACDBDCD \" NEW_LINE n = len ( x ) NEW_LINE m = len ( y ) NEW_LINE print ( maxSubsequenceSubstring ( x , y , n , m ) ) NEW_LINE"],"bleu":0.9092889729525991,"rouge_l":0.9646256464063554}
{"id":1386,"predictions":["import math NEW_LINE def findMaxGCD ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE high = arr [ n - 1 ] NEW_LINE divisors = [ 0 ] * ( high + 1 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT j = 1 NEW_LINE while j <= math . sqrt ( arr [ i ] ) : NEW_LINE INDENT if ( arr [ i ] % j == 0 ) : NEW_LINE INDENT divisors [ j ] = divisors [ j ] + 1 NEW_LINE if ( j != arr [ i ] \/ j ) : NEW_LINE INDENT divisors [ arr [ i ] \/ j ] = divisors [ arr [ i ] \/\/ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( high , 1 , - 1 ) : NEW_LINE INDENT if ( divisors [ i ] >= k ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT arr = [ 1 , 2 , 4 , 8 , 8 , 12 ] NEW_LINE k = 3 NEW_LINE n = len ( arr ) NEW_LINE print findMaxGCD ( arr , n , k ) ) NEW_LINE"],"references":["import math NEW_LINE def findMaxGCD ( arr , n , k ) : NEW_LINE INDENT high = max ( arr ) NEW_LINE divisors = [ 0 ] * ( high + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 1 , int ( math . sqrt ( arr [ i ] ) ) + 1 ) : NEW_LINE INDENT if ( arr [ i ] % j == 0 ) : NEW_LINE INDENT divisors [ j ] += 1 NEW_LINE if ( j != arr [ i ] \/\/ j ) : NEW_LINE INDENT divisors [ arr [ i ] \/\/ j ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( high , 0 , - 1 ) : NEW_LINE INDENT if ( divisors [ i ] >= k ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 8 , 8 , 12 ] NEW_LINE k = 3 NEW_LINE n = len ( arr ) NEW_LINE print ( findMaxGCD ( arr , n , k ) ) NEW_LINE DEDENT"],"bleu":0.7426064487306562,"rouge_l":0.8267276022378064}
{"id":1387,"predictions":["def Max_Sum ( n ) : NEW_LINE INDENT return int ( ( n * ( n - 1 ) ) \/ 2 ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 8 ; NEW_LINE print ( Max_Sum ( n ) ) ; NEW_LINE DEDENT"],"references":["def Max_Sum ( n ) : NEW_LINE INDENT return ( n * ( n - 1 ) ) \/\/ 2 ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 8 ; NEW_LINE print ( Max_Sum ( n ) ) ; NEW_LINE DEDENT"],"bleu":0.7537574234997827,"rouge_l":0.9190207156308852}
{"id":1388,"predictions":["lookup = [ [ - 1 for i in range ( 1000 ) ] for j in range ( 1000 ) ] NEW_LINE def countRec ( digits , eum , osum , isOdd , n ) : NEW_LINE INDENT if ( digits == n ) : NEW_LINE INDENT return 1 if ( esum - osum == 1 ) else 0 NEW_LINE DEDENT if ( lookup [ digits ] [ esum ] [ isOdd ] [ isOdd ] [ isOdd ] ) : NEW_LINE INDENT return lookup [ digits ] [ esum ] [ isOdd ] [ isOdd ] NEW_LINE DEDENT ans = 0 NEW_LINE if ( isOdd == 1 ) : NEW_LINE INDENT for i in range ( 10 ) : NEW_LINE INDENT ans += countRec ( digits + 1 , esum + i , 0 , n ) NEW_LINE DEDENT DEDENT for i in range ( 10 ) : NEW_LINE INDENT ans += countRec ( digits + 1 , esum + i , osum , 1 , n ) NEW_LINE DEDENT lookup [ digits ] [ esum ] [ isOdd ] [ isOdd ] = ans NEW_LINE return ans NEW_LINE DEDENT def finalCount ( n ) : NEW_LINE INDENT digits = 0 NEW_LINE for i in range ( 50 ) : NEW_LINE INDENT for j in range ( 1000 ) : NEW_LINE INDENT lookup [ i ] [ j ] = - 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , 1000 ) : NEW_LINE INDENT ans += countRec ( digits + 1 , eum + i , osum , 1 , n ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE print ( \" Cameln ▁ of \" , n , \" digit ▁ numbers ▁ is \" , finalCount ( n ) ) NEW_LINE DEDENT"],"references":["def countRec ( digits , esum , osum , isOdd , n ) : NEW_LINE INDENT if digits == n : NEW_LINE INDENT return ( esum - osum == 1 ) NEW_LINE DEDENT if lookup [ digits ] [ esum ] [ osum ] [ isOdd ] != - 1 : NEW_LINE INDENT return lookup [ digits ] [ esum ] [ osum ] [ isOdd ] NEW_LINE DEDENT ans = 0 NEW_LINE if isOdd : NEW_LINE INDENT for i in range ( 10 ) : NEW_LINE INDENT ans += countRec ( digits + 1 , esum , osum + i , False , n ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( 10 ) : NEW_LINE INDENT ans += countRec ( digits + 1 , esum + i , osum , True , n ) NEW_LINE DEDENT DEDENT lookup [ digits ] [ esum ] [ osum ] [ isOdd ] = ans NEW_LINE return ans NEW_LINE DEDENT def finalCount ( n ) : NEW_LINE INDENT global lookup NEW_LINE digits = 0 NEW_LINE lookup = [ [ [ [ - 1 , - 1 ] for i in range ( 500 ) ] for j in range ( 500 ) ] for k in range ( 50 ) ] NEW_LINE ans = 0 NEW_LINE esum = 0 NEW_LINE osum = 0 NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT ans += countRec ( digits + 1 , esum + i , osum , True , n ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT lookup = [ ] NEW_LINE n = 3 NEW_LINE print ( \" Count ▁ of ▁ % d ▁ digit ▁ numbers ▁ is ▁ % d \" % ( n , finalCount ( n ) ) ) NEW_LINE DEDENT"],"bleu":0.6912182982616878,"rouge_l":0.780316707071749}
{"id":1389,"predictions":["def lcsOf3 ( X , Y , Z , m , n , o ) : NEW_LINE INDENT L = [ [ 0 for x in range ( n + 1 ) ] for y in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT for k in range ( n + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 or k == 0 ) : NEW_LINE INDENT L [ i ] [ j ] = 0 NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] and X [ i - 1 ] == Z [ k - 1 ] ) : NEW_LINE INDENT L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = max ( L [ i - 1 ] [ j ] [ k ] , L [ k - 1 ] [ k ] ) , L [ i ] [ j ] [ k - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return L [ m ] [ n ] [ o ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT X = \" AGGT12\" NEW_LINE Y = \"12296AYB \" NEW_LINE Z = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE o = len ( Z ) NEW_LINE print ( \" Length ▁ of ▁ LCS ▁ is \" , lcsOf3 ( X , Y , Z , m , n , o ) ) NEW_LINE DEDENT"],"references":["def lcsOf3 ( X , Y , Z , m , n , o ) : NEW_LINE INDENT L = [ [ [ 0 for i in range ( o + 1 ) ] for j in range ( n + 1 ) ] for k in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT for k in range ( o + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 or k == 0 ) : NEW_LINE INDENT L [ i ] [ j ] [ k ] = 0 NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] and X [ i - 1 ] == Z [ k - 1 ] ) : NEW_LINE INDENT L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] [ k ] = max ( max ( L [ i - 1 ] [ j ] [ k ] , L [ i ] [ j - 1 ] [ k ] ) , L [ i ] [ j ] [ k - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return L [ m ] [ n ] [ o ] NEW_LINE DEDENT X = ' AGGT12' NEW_LINE Y = '12TXAYB ' NEW_LINE Z = '12XBA ' NEW_LINE m = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE o = len ( Z ) NEW_LINE print ( ' Length ▁ of ▁ LCS ▁ is ' , lcsOf3 ( X , Y , Z , m , n , o ) ) NEW_LINE"],"bleu":0.8114713384656647,"rouge_l":0.8836933546424705}
{"id":1390,"predictions":["from math import log NEW_LINE def printGreater ( x , y ) : NEW_LINE INDENT X = y * log ( x ) ; NEW_LINE Y = x * log ( y ) ; NEW_LINE if ( abs ( X - Y ) < 1e9 ) : NEW_LINE INDENT print ( \" Equal \" ) ; NEW_LINE DEDENT elif ( X > Y ) : NEW_LINE INDENT print ( x , \" ^ \" , y ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( y , \" ^ \" , x ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = 5 ; y = 8 ; NEW_LINE printGreater ( x , y ) ; NEW_LINE DEDENT"],"references":["import math NEW_LINE def printGreater ( x , y ) : NEW_LINE INDENT X = y * math . log ( x ) ; NEW_LINE Y = x * math . log ( y ) ; NEW_LINE if ( abs ( X - Y ) < 1e-9 ) : NEW_LINE INDENT print ( \" Equal \" ) ; NEW_LINE DEDENT elif ( X > Y ) : NEW_LINE INDENT print ( x , \" ^ \" , y ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( y , \" ^ \" , x ) ; NEW_LINE DEDENT DEDENT x = 5 ; NEW_LINE y = 8 ; NEW_LINE printGreater ( x , y ) ; NEW_LINE"],"bleu":0.7973819217084113,"rouge_l":0.9060618225612204}
{"id":1391,"predictions":["def getElement ( a , n , S ) : NEW_LINE INDENT a . sort ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( sum + ( a [ i ] * ( n - i ) ) == S ) : NEW_LINE INDENT return a [ i ] NEW_LINE DEDENT sum += a [ i ] NEW_LINE DEDENT return - 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = 5 NEW_LINE a = [ 1 , 3 , 2 , 5 , 8 ] NEW_LINE n = len ( a ) NEW_LINE print ( getElement ( a , n , S ) ) NEW_LINE DEDENT"],"references":["def getElement ( a , n , S ) : NEW_LINE INDENT a . sort ( ) ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( sum + ( a [ i ] * ( n - i ) ) == S ) : NEW_LINE INDENT return a [ i ] ; NEW_LINE DEDENT sum += a [ i ] ; NEW_LINE DEDENT return - 1 ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = 5 ; NEW_LINE a = [ 1 , 3 , 2 , 5 , 8 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( getElement ( a , n , S ) ) ; NEW_LINE DEDENT"],"bleu":0.8275714354413811,"rouge_l":0.9592401559944647}
{"id":1392,"predictions":["def canMakeEqual ( a , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT while a [ i ] % 5 == 0 : NEW_LINE INDENT a [ i ] \/\/= 5 NEW_LINE DEDENT while a [ i ] % 3 == 0 : NEW_LINE INDENT a [ i ] \/\/= 3 NEW_LINE DEDENT DEDENT last = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if a [ i ] != last : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 18 , 30 , 54 , 90 , 162 ] NEW_LINE n = len ( arr ) NEW_LINE if canMakeEqual ( arr , n ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"references":["def canMakeEqual ( a , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT while ( a [ i ] % 5 == 0 ) : NEW_LINE INDENT a [ i ] \/\/= 5 ; NEW_LINE DEDENT while ( a [ i ] % 3 == 0 ) : NEW_LINE INDENT a [ i ] \/\/= 3 ; NEW_LINE DEDENT DEDENT last = a [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( a [ i ] != last ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 18 , 30 , 54 , 90 , 162 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE if ( canMakeEqual ( arr , n ) ) : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE DEDENT DEDENT"],"bleu":0.7588674596379275,"rouge_l":0.9423511680482292}
{"id":1393,"predictions":["x = 10 NEW_LINE y = 5 NEW_LINE x = x ^ y NEW_LINE y = x ^ y NEW_LINE x = x ^ y NEW_LINE print ( \" After ▁ swap : ▁ x ▁ = ▁ \" , x , \" , ▁ y ▁ = ▁ \" , y ) ; NEW_LINE"],"references":["x = 10 NEW_LINE y = 5 NEW_LINE x = x ^ y ; NEW_LINE y = x ^ y ; NEW_LINE x = x ^ y ; NEW_LINE print ( \" After ▁ Swapping : ▁ x ▁ = ▁ \" , x , \" ▁ y ▁ = \" , y ) NEW_LINE"],"bleu":0.7402829621318119,"rouge_l":0.9272727272727274}
{"id":1394,"predictions":["def minimumOperations ( a , n ) : NEW_LINE INDENT mp = dict . fromkeys ( a , 0 ) ; NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( mp [ a [ i ] ] ) : NEW_LINE INDENT mp [ a [ i ] ] += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT mp [ a [ i ] ] = 1 ; NEW_LINE DEDENT DEDENT count = 0 ; NEW_LINE for key , value in mp . items ( ) : NEW_LINE INDENT if ( value > 1 ) : NEW_LINE INDENT count += ( value - 1 ) ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 2 , 1 , 1 , 2 , 3 , 3 , 4 , 3 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( minimumOperations ( a , n ) ) ; NEW_LINE DEDENT"],"references":["def minimumOperations ( a , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] in mp . keys ( ) : NEW_LINE INDENT mp [ a [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ a [ i ] ] = 1 NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for it in mp : NEW_LINE INDENT if ( mp [ it ] > 1 ) : NEW_LINE INDENT count += mp [ it ] - 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT a = [ 2 , 1 , 2 , 3 , 3 , 4 , 3 ] NEW_LINE n = len ( a ) NEW_LINE print ( minimumOperations ( a , n ) ) NEW_LINE"],"bleu":0.5939483914074709,"rouge_l":0.8207154297917779}
{"id":1395,"predictions":["def xorRange ( pre , l , r ) : NEW_LINE INDENT cntOnes = pre [ r ] NEW_LINE if ( l - 1 >= 0 ) : NEW_LINE INDENT cntOnes -= pre [ l - 1 ] NEW_LINE DEDENT if ( cntOnes % 2 == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT def performQueries ( queries , q , a , n ) : NEW_LINE INDENT pre = [ 0 ] * n NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT pre [ i ] = pre [ i - 1 ] + a [ i ] NEW_LINE DEDENT for i in range ( q ) : NEW_LINE INDENT print ( xorRange ( pre , queries [ i ] [ 0 ] , queries [ i ] [ 1 ] ) ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 0 , 1 , 1 , 1 , 0 , 1 , 1 ] NEW_LINE n = len ( a ) NEW_LINE queries = [ [ 0 , 3 ] , [ 0 , 2 ] ] NEW_LINE q = len ( queries ) NEW_LINE performQueries ( queries , q , a , n ) NEW_LINE DEDENT"],"references":["def xorRange ( pre , l , r ) : NEW_LINE INDENT cntOnes = pre [ r ] NEW_LINE if ( l - 1 >= 0 ) : NEW_LINE INDENT cntOnes -= pre [ l - 1 ] NEW_LINE DEDENT if ( cntOnes % 2 == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT def performQueries ( queries , q , a , n ) : NEW_LINE INDENT pre = [ 0 for i in range ( n ) ] NEW_LINE pre [ 0 ] = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT pre [ i ] = pre [ i - 1 ] + a [ i ] NEW_LINE DEDENT for i in range ( q ) : NEW_LINE INDENT print ( xorRange ( pre , queries [ i ] [ 0 ] , queries [ i ] [ 1 ] ) ) NEW_LINE DEDENT DEDENT a = [ 1 , 0 , 1 , 1 , 0 , 1 , 1 ] NEW_LINE n = len ( a ) NEW_LINE queries = [ [ 0 , 3 ] , [ 0 , 2 ] ] NEW_LINE q = len ( queries ) NEW_LINE performQueries ( queries , q , a , n ) NEW_LINE"],"bleu":0.9081941016439204,"rouge_l":0.9231047715589025}
{"id":1396,"predictions":["def countNums ( n , x , y ) : NEW_LINE INDENT arr = [ True ] * ( n + 1 ) NEW_LINE if ( x <= n ) : NEW_LINE INDENT arr [ x ] = True NEW_LINE DEDENT if ( y <= n ) : NEW_LINE INDENT arr [ y ] = True NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( min ( x , y ) , n + 1 ) : NEW_LINE INDENT if ( arr [ i ] ) : NEW_LINE INDENT if ( i + x <= n ) : NEW_LINE INDENT arr [ i + x ] = 1 NEW_LINE DEDENT if ( i + y <= n ) : NEW_LINE INDENT arr [ i + y ] = True NEW_LINE DEDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT n = 15 NEW_LINE x = 5 NEW_LINE y = 7 NEW_LINE print ( countNums ( n , x , y ) ) NEW_LINE"],"references":["def countNums ( n , x , y ) : NEW_LINE INDENT arr = [ False for i in range ( n + 2 ) ] NEW_LINE if ( x <= n ) : NEW_LINE INDENT arr [ x ] = True NEW_LINE DEDENT if ( y <= n ) : NEW_LINE INDENT arr [ y ] = True NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( min ( x , y ) , n + 1 ) : NEW_LINE INDENT if ( arr [ i ] ) : NEW_LINE INDENT if ( i + x <= n ) : NEW_LINE INDENT arr [ i + x ] = True NEW_LINE DEDENT if ( i + y <= n ) : NEW_LINE INDENT arr [ i + y ] = True NEW_LINE DEDENT result = result + 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT n = 15 NEW_LINE x = 5 NEW_LINE y = 7 NEW_LINE print ( countNums ( n , x , y ) ) NEW_LINE"],"bleu":0.8997276159984802,"rouge_l":0.9473328831870358}
{"id":1397,"predictions":["def get_max_splits ( num_str ) : NEW_LINE INDENT count = 0 NEW_LINE current_num = 0 NEW_LINE for i in range ( len ( num_num ) ) : NEW_LINE INDENT current_num = ord ( num_string [ i ] ) - ord ( '0' ) NEW_LINE running_sum += current_num NEW_LINE if ( current_num % 3 == 0 or ( running_sum != 0 and current_sum % 3 == 0 ) ) : NEW_LINE INDENT count += 1 NEW_LINE running_sum = 0 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT print ( get_max_splits ( \"12345\" ) ) NEW_LINE"],"references":["def get_max_splits ( num_string ) : NEW_LINE INDENT count = 0 NEW_LINE running_sum = 0 NEW_LINE for i in range ( len ( num_string ) ) : NEW_LINE INDENT current_num = int ( num_string [ i ] ) NEW_LINE running_sum += current_num NEW_LINE if current_num % 3 == 0 or ( running_sum != 0 and running_sum % 3 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE running_sum = 0 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT print get_max_splits ( \"12345\" ) NEW_LINE"],"bleu":0.7034295658189135,"rouge_l":0.9009160590764631}
{"id":1398,"predictions":["def term ( n ) : NEW_LINE INDENT return n * ( n + 1 ) \/\/ 2 NEW_LINE DEDENT n = 4 NEW_LINE print ( term ( n ) ) NEW_LINE"],"references":["def term ( n ) : NEW_LINE INDENT return n * ( n + 1 ) \/ 2 NEW_LINE DEDENT n = 4 NEW_LINE print term ( n ) NEW_LINE"],"bleu":0.7848271093555107,"rouge_l":0.9409574468085108}
{"id":1399,"predictions":["def anglequichord ( z ) : NEW_LINE INDENT print ( \" The ▁ angle ▁ is \" , z , \" degrees \" ) ; NEW_LINE DEDENT z = 48 ; NEW_LINE anglequichord ( z ) ; NEW_LINE"],"references":["def anglequichord ( z ) : NEW_LINE INDENT print ( \" The ▁ angle ▁ is ▁ \" , z , \" ▁ degrees \" ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT z = 48 NEW_LINE anglequichord ( z ) NEW_LINE DEDENT"],"bleu":0.48586171051890314,"rouge_l":0.7663316582914573}
{"id":1400,"predictions":["def findLength ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE maxlen = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n , 2 ) : NEW_LINE INDENT length = j - i + 1 NEW_LINE leftsum = 0 NEW_LINE rightum = 0 NEW_LINE for k in range ( int ( length \/ 2 ) ) : NEW_LINE INDENT leftsum += ( ord ( str [ i + k ) - ord ( '0' ) ) NEW_LINE rightum += ( ord ( str [ i + k + length \/ 2 ) ) NEW_LINE DEDENT if ( leftsum == rightsum and maxlen < length ) : NEW_LINE INDENT maxlen = length NEW_LINE DEDENT DEDENT DEDENT return maxlen NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \"1538023\" NEW_LINE print ( \" Length ▁ of ▁ the ▁ substring ▁ is \" , findLength ( str ) ) NEW_LINE DEDENT"],"references":["def findLength ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE maxlen = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n , 2 ) : NEW_LINE INDENT length = j - i + 1 NEW_LINE leftsum = 0 NEW_LINE rightsum = 0 NEW_LINE for k in range ( 0 , int ( length \/ 2 ) ) : NEW_LINE INDENT leftsum += ( int ( str [ i + k ] ) - int ( '0' ) ) NEW_LINE rightsum += ( int ( str [ i + k + int ( length \/ 2 ) ] ) - int ( '0' ) ) NEW_LINE DEDENT if ( leftsum == rightsum and maxlen < length ) : NEW_LINE INDENT maxlen = length NEW_LINE DEDENT DEDENT DEDENT return maxlen NEW_LINE DEDENT str = \"1538023\" NEW_LINE print ( \" Length ▁ of ▁ the ▁ substring ▁ is \" , findLength ( str ) ) NEW_LINE"],"bleu":0.8022900003399391,"rouge_l":0.8908045977011494}
{"id":1401,"predictions":["MOD = 2019 ; NEW_LINE def min_modulo ( l , r ) : NEW_LINE INDENT if ( r - l >= MOD ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT ans = MOD - 1 ; NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , r + 1 ) : NEW_LINE INDENT ans = min ( ans , ( i * j ) % MOD ) ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT l = 2020 ; r = 2040 ; NEW_LINE print ( min_modulo ( l , r ) ) ; NEW_LINE DEDENT"],"references":["MOD = 2019 ; NEW_LINE def min_modulo ( l , r ) : NEW_LINE INDENT if ( r - l >= MOD ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT ans = MOD - 1 ; NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , r + 1 ) : NEW_LINE INDENT ans = min ( ans , ( i * j ) % MOD ) ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT l = 2020 ; r = 2040 ; NEW_LINE print ( min_modulo ( l , r ) ) ; NEW_LINE DEDENT"],"bleu":1.0,"rouge_l":1.0}
{"id":1402,"predictions":["def countPairsWithProdK ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] * arr [ j ] == k ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 5 , 3 , 4 , 2 ] NEW_LINE N = len ( arr ) NEW_LINE K = 3 NEW_LINE print ( countPairsWithProdK ( arr , N , K ) ) NEW_LINE DEDENT"],"references":["def countPairsWithProdK ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] * arr [ j ] == k ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 1 , 5 , 3 , 4 , 2 ] NEW_LINE N = len ( arr ) NEW_LINE K = 3 NEW_LINE print ( countPairsWithProdK ( arr , N , K ) ) NEW_LINE"],"bleu":0.869032112801554,"rouge_l":0.9481865284974094}
{"id":1403,"predictions":["def Xor_Sum ( arr , n ) : NEW_LINE INDENT sum = 0 ; index = - 1 ; NEW_LINE left_xor = 0 ; right_xor = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT left_xor = left_xor ^ arr [ i ] ; NEW_LINE right_xor = 0 ; NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT right_xor = right_xor ^ arr [ j ] ; NEW_LINE DEDENT if ( left_xor + right_xor > sum ) : NEW_LINE INDENT sum = left_xor + right_xor ; NEW_LINE index = i ; NEW_LINE DEDENT DEDENT return index + 1 ; NEW_LINE DEDENT arr = [ 1 , 4 , 6 , 3 , 8 , 13 , 34 , 2 , 21 , 10 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( Xor_Sum ( arr , n ) ) ; NEW_LINE"],"references":["def Xor_Sum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE index , left_xor = 0 , 0 NEW_LINE right_xor = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT left_xor = left_xor ^ arr [ i ] NEW_LINE right_xor = 0 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT right_xor = right_xor ^ arr [ j ] NEW_LINE DEDENT if ( left_xor + right_xor > sum ) : NEW_LINE INDENT sum = left_xor + right_xor NEW_LINE index = i NEW_LINE DEDENT DEDENT return index + 1 NEW_LINE DEDENT arr = [ 1 , 4 , 6 , 3 , 8 , 13 , 34 , 2 , 21 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( Xor_Sum ( arr , n ) ) NEW_LINE"],"bleu":0.7694711732045364,"rouge_l":0.9329491300011084}
{"id":1404,"predictions":["def prints ( a , n , ind ) : NEW_LINE INDENT for i in range ( ind , n + ind ) : NEW_LINE INDENT print ( a [ ( i % n ] ) , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT a = [ ' A ' , ' B ' , ' C ' , ' E ' , ' F ' , ' F ' ] ; NEW_LINE n = len ( a ) ; NEW_LINE prints ( a , n , 3 ) ; NEW_LINE"],"references":["def prints ( a , n , ind ) : NEW_LINE INDENT i = ind NEW_LINE while i < n + ind : NEW_LINE INDENT print ( a [ ( i % n ) ] , end = \" ▁ \" ) NEW_LINE i = i + 1 NEW_LINE DEDENT DEDENT a = [ ' A ' , ' B ' , ' C ' , ' D ' , ' E ' , ' F ' ] NEW_LINE n = len ( a ) ; NEW_LINE prints ( a , n , 3 ) ; NEW_LINE"],"bleu":0.7450897598421893,"rouge_l":0.8666552550496404}
{"id":1405,"predictions":["def printPattern ( i , j , n ) : NEW_LINE INDENT if ( j >= n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( i >= n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( j == i or j == n - 1 - i ) : NEW_LINE INDENT if ( i == n - 1 - j ) : NEW_LINE INDENT print ( \" \/\/ \" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" * \" , end = \" \" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( \" * \" , end = \" \" ) NEW_LINE DEDENT if ( countPattern ( i , j + 1 , n ) == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT print ( ) NEW_LINE return print ( ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 9 NEW_LINE printPattern ( 0 , 0 , N ) NEW_LINE DEDENT"],"references":["def printPattern ( i , j , n ) : NEW_LINE INDENT if ( j >= n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( i >= n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( j == i or j == n - 1 - i ) : NEW_LINE INDENT if ( i == n - 1 - j ) : NEW_LINE INDENT print ( \" \/ \" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" \\\\ \" , end = \" \" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( \" * \" , end = \" \" ) NEW_LINE DEDENT if ( printPattern ( i , j + 1 , n ) == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT print ( ) NEW_LINE return printPattern ( i + 1 , 0 , n ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 9 NEW_LINE printPattern ( 0 , 0 , N ) NEW_LINE DEDENT"],"bleu":0.8729332601433923,"rouge_l":0.9434428479912146}
{"id":1406,"predictions":["def findMaxValue ( arr , n ) : NEW_LINE INDENT if ( n < 4 ) : NEW_LINE INDENT print ( \" The ▁ array ▁ should ▁ have ▁ at ▁ 4 ▁ elements \" ) NEW_LINE DEDENT table1 = [ 0 ] * ( n + 1 ) NEW_LINE table2 = [ 0 ] * ( n - 2 ) NEW_LINE table4 = [ 0 ] * ( n - 1 ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT table1 [ i ] = max ( table1 [ i + 1 ] , arr [ i ] ) NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT table1 [ i ] = max ( table1 [ i + 1 ] , arr1 [ i + 1 ] - arr [ i ] ) NEW_LINE DEDENT for i in range ( n - 3 , - 1 , - 1 ) : NEW_LINE INDENT table2 [ i ] = max ( table2 [ i + 1 ] , table [ i + 1 ] - arr [ i ] ) NEW_LINE DEDENT for i in range ( n - 3 , - 1 , - 1 ) : NEW_LINE INDENT table3 [ i ] = max ( table3 [ i + 1 ] , table2 [ i + 1 ] + arr [ i ] ) NEW_LINE DEDENT DEDENT for i in range ( n - 4 , - 1 , - 1 ) : NEW_LINE INDENT table4 [ i ] = max ( table4 [ i + 1 ] , table [ i + 1 ] - arr [ i ] ) NEW_LINE DEDENT return table4 [ 0 ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 4 , 8 , 9 , 2 , 20 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMaxValue ( arr , n ) ) NEW_LINE DEDENT"],"references":["def findMaxValue ( arr , n ) : NEW_LINE INDENT if n < 4 : NEW_LINE INDENT print ( \" The ▁ array ▁ should ▁ have ▁ atlest ▁ 4 ▁ elements \" ) NEW_LINE return MIN NEW_LINE DEDENT table1 , table2 = [ MIN ] * ( n + 1 ) , [ MIN ] * n NEW_LINE table3 , table4 = [ MIN ] * ( n - 1 ) , [ MIN ] * ( n - 2 ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT table1 [ i ] = max ( table1 [ i + 1 ] , arr [ i ] ) NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT table2 [ i ] = max ( table2 [ i + 1 ] , table1 [ i + 1 ] - arr [ i ] ) NEW_LINE DEDENT for i in range ( n - 3 , - 1 , - 1 ) : NEW_LINE INDENT table3 [ i ] = max ( table3 [ i + 1 ] , table2 [ i + 1 ] + arr [ i ] ) NEW_LINE DEDENT for i in range ( n - 4 , - 1 , - 1 ) : NEW_LINE INDENT table4 [ i ] = max ( table4 [ i + 1 ] , table3 [ i + 1 ] - arr [ i ] ) NEW_LINE DEDENT return table4 [ 0 ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 4 , 8 , 9 , 2 , 20 ] NEW_LINE n = len ( arr ) NEW_LINE MIN = - 100000000 NEW_LINE print ( findMaxValue ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.7935825051557681,"rouge_l":0.8807793106858529}
{"id":1407,"predictions":["def printElements ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE a = [ : : i + 1 ] NEW_LINE cnt = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( a [ i ] != a [ i + 1 ] ) : NEW_LINE INDENT print ( a [ i ] , \" ▁ \" , cnt , \" times \" ) NEW_LINE cnt = 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT print ( a [ n - 1 ] , \" occurrences \" , cnt , \" times \" ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 1 , 1 , 2 , 3 , 4 , 9 , 10 ] NEW_LINE n = len ( a ) NEW_LINE printElements ( a , n ) NEW_LINE DEDENT"],"references":["def printElements ( a , n ) : NEW_LINE INDENT a . sort ( reverse = True ) NEW_LINE cnt = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( a [ i ] != a [ i + 1 ] ) : NEW_LINE INDENT print ( a [ i ] , \" ▁ occurs ▁ \" , cnt , \" times \" ) NEW_LINE cnt = 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT print ( a [ n - 1 ] , \" occurs \" , cnt , \" times \" ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 1 , 1 , 2 , 3 , 4 , 9 , 9 , 10 ] NEW_LINE n = len ( a ) NEW_LINE printElements ( a , n ) NEW_LINE DEDENT"],"bleu":0.9060445156112255,"rouge_l":0.9420364460002061}
{"id":1408,"predictions":["def findMin ( arr , n ) : NEW_LINE INDENT m = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT m = max ( m , arr [ i ] ) NEW_LINE DEDENT freq = [ 0 for i in range ( m + 2 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT j = i NEW_LINE cnt = 0 NEW_LINE while ( j <= m ) : NEW_LINE INDENT cnt += freq [ j ] NEW_LINE j += i NEW_LINE DEDENT if ( cnt == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return m + 1 NEW_LINE DEDENT arr = [ 2 , 12 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMin ( arr , n ) ) NEW_LINE"],"references":["def findMin ( arr , n ) : NEW_LINE INDENT m = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT m = max ( m , arr [ i ] ) NEW_LINE DEDENT freq = [ 0 ] * ( m + 2 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( 1 , m + 2 ) : NEW_LINE INDENT j = i NEW_LINE cnt = 0 NEW_LINE while ( j <= m ) : NEW_LINE INDENT cnt += freq [ j ] NEW_LINE j += i NEW_LINE DEDENT if ( not cnt ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return m + 1 NEW_LINE DEDENT arr = [ 2 , 12 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMin ( arr , n ) ) NEW_LINE"],"bleu":0.9099733040654752,"rouge_l":0.9648943769772426}
{"id":1409,"predictions":["def swapOperations ( a , b , c ) : NEW_LINE INDENT l = len ( a ) NEW_LINE i = 0 NEW_LINE total_swaps = 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( a [ i ] == b [ i ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( a [ i ] == c [ i ] ) : NEW_LINE INDENT temp = b [ i ] NEW_LINE b [ i ] = c [ i ] NEW_LINE c [ i ] = temp NEW_LINE total_swaps += 1 NEW_LINE continue NEW_LINE DEDENT if ( b [ i ] == c [ i ] ) : NEW_LINE INDENT temp = a [ i ] NEW_LINE a [ i ] = c [ i ] NEW_LINE c [ i ] = temp NEW_LINE total_swaps += 1 NEW_LINE continue NEW_LINE DEDENT break NEW_LINE DEDENT if ( i == l ) : NEW_LINE INDENT print ( total_swaps ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = \" xyz \" NEW_LINE b = \" yzx \" NEW_LINE c = \" yyz \" NEW_LINE swapOperations ( a , b , c ) NEW_LINE DEDENT"],"references":["def swapOperations ( a , b , c ) : NEW_LINE INDENT l = len ( a ) ; NEW_LINE i = 0 ; NEW_LINE total_swaps = 0 ; NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( a [ i ] == b [ i ] ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT if ( a [ i ] == c [ i ] ) : NEW_LINE INDENT b [ i ] , c [ i ] = c [ i ] , b [ i ] ; NEW_LINE total_swaps += 1 ; NEW_LINE continue ; NEW_LINE DEDENT if ( b [ i ] == c [ i ] ) : NEW_LINE INDENT a [ i ] , c [ i ] = c [ i ] , a [ i ] ; NEW_LINE total_swaps += 1 ; NEW_LINE continue ; NEW_LINE DEDENT break ; NEW_LINE DEDENT i += 1 ; NEW_LINE if ( i == l ) : NEW_LINE INDENT print ( total_swaps ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = \" xyz \" ; NEW_LINE b = \" yzx \" ; NEW_LINE c = \" yzx \" ; NEW_LINE swapOperations ( list ( a ) , list ( b ) , list ( c ) ) ; NEW_LINE DEDENT"],"bleu":0.6736325483274188,"rouge_l":0.8679739487469914}
{"id":1410,"predictions":["def findMinimumZ ( n , a , b ) : NEW_LINE INDENT if ( a > b ) : NEW_LINE INDENT a , b = b , a NEW_LINE DEDENT distClock = b - a NEW_LINE distAbs = ( a - 1 ) + ( n - b + 1 ) NEW_LINE minDist = min ( distStack , distNonCounter ) NEW_LINE if ( minDist == 1 ) : NEW_LINE INDENT return 3 NEW_LINE DEDENT return minDist NEW_LINE DEDENT n = 4 NEW_LINE a , b = 1 , 2 NEW_LINE print ( findMinimumZ ( n , a , b ) ) NEW_LINE"],"references":["def findMinimumZ ( n , a , b ) : NEW_LINE INDENT if ( a > b ) : NEW_LINE INDENT temp = a NEW_LINE a = b NEW_LINE b = temp NEW_LINE DEDENT distClock = b - a NEW_LINE distAntiClock = ( a - 1 ) + ( n - b + 1 ) NEW_LINE minDist = min ( distClock , distAntiClock ) NEW_LINE if ( minDist == 1 ) : NEW_LINE INDENT return 3 NEW_LINE DEDENT return minDist NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE a = 1 NEW_LINE b = 2 NEW_LINE print ( findMinimumZ ( n , a , b ) ) NEW_LINE DEDENT"],"bleu":0.6677134344333773,"rouge_l":0.8168850072780205}
{"id":1411,"predictions":["def solve ( ang , n ) : NEW_LINE INDENT if ( ( ang * n ) > ( 180 * ( n - 2 ) ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( ( ang * n ) % 180 != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = 1 NEW_LINE freq = ( ang * n ) \/\/ 180 NEW_LINE ans = ans * n NEW_LINE return ans NEW_LINE DEDENT ang = 90 NEW_LINE n = 4 NEW_LINE print ( solve ( ang , n ) ) NEW_LINE"],"references":["def solve ( ang , n ) : NEW_LINE INDENT if ( ( ang * n ) > ( 180 * ( n - 2 ) ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( ( ang * n ) % 180 != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = 1 NEW_LINE freq = ( ang * n ) \/\/ 180 NEW_LINE ans = ans * ( n - 1 - freq ) NEW_LINE ans = ans * n NEW_LINE return ans NEW_LINE DEDENT ang = 90 NEW_LINE n = 4 NEW_LINE print ( solve ( ang , n ) ) NEW_LINE"],"bleu":0.8824969025845955,"rouge_l":0.931297709923664}
{"id":1412,"predictions":["def bitsAreInAltPatrn ( n , l , r ) : NEW_LINE INDENT num = n >> ( l - 1 ) NEW_LINE prev = num & 1 NEW_LINE num = num >> 1 NEW_LINE for i in range ( 1 , ( r - l ) + 1 ) : NEW_LINE INDENT curr = num & 1 NEW_LINE if ( curr == prev ) : NEW_LINE INDENT return False NEW_LINE DEDENT prev = curr NEW_LINE num = num >> 1 NEW_LINE DEDENT return True NEW_LINE DEDENT n = 18 NEW_LINE l = 1 NEW_LINE r = 3 NEW_LINE if ( bitsAreInAltPatrnInGivenTrange ( n , l , r ) == True ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def bitsAreInAltPatrnInGivenTRange ( n , l , r ) : NEW_LINE INDENT num = n >> ( l - 1 ) ; NEW_LINE prev = num & 1 ; NEW_LINE num = num >> 1 ; NEW_LINE for i in range ( 1 , ( r - l ) ) : NEW_LINE INDENT curr = num & 1 ; NEW_LINE if ( curr == prev ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT prev = curr ; NEW_LINE num = num >> 1 ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 18 ; NEW_LINE l = 1 ; NEW_LINE r = 3 ; NEW_LINE if ( bitsAreInAltPatrnInGivenTRange ( n , l , r ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"],"bleu":0.630921383239713,"rouge_l":0.86736280826483}
{"id":1413,"predictions":["def countFibs ( low , high ) : NEW_LINE INDENT f1 = 0 NEW_LINE f2 = 1 NEW_LINE f3 = 1 NEW_LINE result = 0 NEW_LINE while ( f1 <= high ) : NEW_LINE INDENT if ( f1 >= low ) : NEW_LINE INDENT result = result + 1 NEW_LINE DEDENT f1 = f2 NEW_LINE f2 = f3 NEW_LINE DEDENT return result NEW_LINE DEDENT low = 10 NEW_LINE high = 100 NEW_LINE print ( \" Count ▁ of ▁ Fibonacci ▁ Numbers ▁ is ▁ \" , countFibs ( low , high ) ) NEW_LINE"],"references":["def countFibs ( low , high ) : NEW_LINE INDENT f1 , f2 , f3 = 0 , 1 , 1 NEW_LINE result = 0 NEW_LINE while ( f1 <= high ) : NEW_LINE INDENT if ( f1 >= low ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT f1 = f2 NEW_LINE f2 = f3 NEW_LINE f3 = f1 + f2 NEW_LINE DEDENT return result NEW_LINE DEDENT low , high = 10 , 100 NEW_LINE print ( \" Count ▁ of ▁ Fibonacci ▁ Numbers ▁ is \" , countFibs ( low , high ) ) NEW_LINE"],"bleu":0.7511295824619818,"rouge_l":0.8473657462307302}
{"id":1414,"predictions":["def Sum_upto_nth_Term ( n ) : NEW_LINE INDENT r = n * ( n + 1 ) * ( 2 * n + 7 ) \/\/ 3 NEW_LINE print ( r ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 5 NEW_LINE Sum_upto_nth_Term ( N ) NEW_LINE DEDENT"],"references":["def Sum_upto_nth_Term ( n ) : NEW_LINE INDENT return n * ( n + 1 ) * ( 2 * n + 7 ) \/\/ 3 NEW_LINE DEDENT N = 5 NEW_LINE print ( Sum_upto_nth_Term ( N ) ) NEW_LINE"],"bleu":0.5454941334784107,"rouge_l":0.7664921465968586}
{"id":1415,"predictions":["import math NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT first = None NEW_LINE length = 0 NEW_LINE def printList ( node ) : NEW_LINE INDENT while ( node != None ) : NEW_LINE INDENT print ( node . data , end = \" ▁ \" ) NEW_LINE node = node . next NEW_LINE DEDENT DEDENT def moveToFront ( head , p , m ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT return NEW_LINE DEDENT p = head NEW_LINE head = head . next NEW_LINE m += 1 NEW_LINE if ( length == m ) : NEW_LINE INDENT p . next = None NEW_LINE DEDENT p = head . next NEW_LINE DEDENT else : NEW_LINE INDENT moveToFront ( head , p , m ) NEW_LINE DEDENT DEDENT def push ( head_ref , new_data ) : NEW_LINE INDENT new_node = Node ( new_data ) NEW_LINE new_node . data = new_data NEW_LINE new_node . next = head_ref NEW_LINE if ( length == 0 ) : NEW_LINE INDENT last = head_ref NEW_LINE DEDENT else : NEW_LINE INDENT first = head_ref NEW_LINE DEDENT length += 1 NEW_LINE return head_ref NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT start = None NEW_LINE start = push ( start , 5 ) NEW_LINE start = push ( start , 4 ) NEW_LINE start = push ( start , 3 ) NEW_LINE start = push ( start , 1 ) NEW_LINE start = push ( start , 0 ) NEW_LINE start = push ( start , 2 ) NEW_LINE print ( \" Original ▁ final ▁ list \" ) NEW_LINE start = start NEW_LINE printList ( start ) NEW_LINE"],"references":["class Node : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . data = 0 NEW_LINE self . next = None NEW_LINE DEDENT DEDENT first = None NEW_LINE last = None NEW_LINE length = 0 NEW_LINE def printList ( node ) : NEW_LINE INDENT while ( node != None ) : NEW_LINE INDENT print ( node . data , end = \" ▁ \" ) NEW_LINE node = node . next NEW_LINE DEDENT DEDENT def moveToFront ( head , p , m ) : NEW_LINE INDENT global first NEW_LINE global last NEW_LINE global length NEW_LINE if ( head == None ) : NEW_LINE INDENT return head NEW_LINE DEDENT p = head NEW_LINE head = head . next NEW_LINE m = m + 1 NEW_LINE if ( length == m ) : NEW_LINE INDENT p . next = None NEW_LINE last . next = first NEW_LINE first = head NEW_LINE DEDENT else : NEW_LINE INDENT moveToFront ( head , p , m ) NEW_LINE DEDENT DEDENT def push ( head_ref , new_data ) : NEW_LINE INDENT global first NEW_LINE global last NEW_LINE global length NEW_LINE new_node = Node ( ) NEW_LINE new_node . data = new_data NEW_LINE new_node . next = ( head_ref ) NEW_LINE ( head_ref ) = new_node NEW_LINE if ( length == 0 ) : NEW_LINE INDENT last = head_ref NEW_LINE DEDENT else : NEW_LINE INDENT first = head_ref NEW_LINE DEDENT length = length + 1 NEW_LINE return head_ref NEW_LINE DEDENT start = None NEW_LINE start = push ( start , 5 ) NEW_LINE start = push ( start , 4 ) NEW_LINE start = push ( start , 3 ) NEW_LINE start = push ( start , 2 ) NEW_LINE start = push ( start , 1 ) NEW_LINE start = push ( start , 0 ) NEW_LINE print ( \" \\n ▁ Initial ▁ Linked ▁ list \" ) NEW_LINE printList ( start ) NEW_LINE m = 4 NEW_LINE temp = None NEW_LINE moveToFront ( start , temp , m ) NEW_LINE print ( \" \\n ▁ Final ▁ Linked ▁ list \" ) NEW_LINE start = first NEW_LINE printList ( start ) NEW_LINE"],"bleu":0.6934792058859517,"rouge_l":0.8105329518452064}
{"id":1416,"predictions":["def printRepeating ( arr , size ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( 1 , len ( arr ) ) : NEW_LINE INDENT s . add ( a ) NEW_LINE print ( s ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 3 , 2 , 2 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE printRepeating ( arr , n ) NEW_LINE DEDENT"],"references":["def printRepeating ( arr , size ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT if arr [ i ] not in s : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT for i in s : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 3 , 2 , 2 , 1 ] NEW_LINE size = len ( arr ) NEW_LINE printRepeating ( arr , size ) NEW_LINE DEDENT"],"bleu":0.5574588641463114,"rouge_l":0.741370928536704}
{"id":1417,"predictions":["def maxsum_SIS ( arr , n ) : NEW_LINE INDENT max_sum = 0 NEW_LINE current_sum = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i - 1 ] < arr [ i ] ) : NEW_LINE INDENT current_sum = current_sum + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT max_sum = max ( max_sum , current_sum ) NEW_LINE current_sum = arr [ i ] NEW_LINE DEDENT DEDENT return max ( max_sum , current_sum ) NEW_LINE DEDENT arr = [ 1 , 2 , 2 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Maximum ▁ sum ▁ : \" , maxsum_SIS ( arr , n ) ) NEW_LINE"],"references":["def maxsum_SIS ( arr , n ) : NEW_LINE INDENT max_sum = 0 NEW_LINE current_sum = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i - 1 ] < arr [ i ] ) : NEW_LINE INDENT current_sum = current_sum + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT max_sum = max ( max_sum , current_sum ) NEW_LINE current_sum = arr [ i ] NEW_LINE DEDENT DEDENT return max ( max_sum , current_sum ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT arr = [ 1 , 2 , 2 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Maximum ▁ sum ▁ : ▁ \" , maxsum_SIS ( arr , n ) ) , NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"bleu":0.781126474452579,"rouge_l":0.8856624319419237}
{"id":1418,"predictions":["def sumoflength ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE j = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( j < n and arr [ j ] not in s ) : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE j += 1 NEW_LINE DEDENT ans += ( ( j - i ) * ( j - i + 1 ) ) \/\/ 2 NEW_LINE s . remove ( arr [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( sumoflength ( arr , n ) ) NEW_LINE DEDENT"],"references":["def sumoflength ( arr , n ) : NEW_LINE INDENT s = [ ] NEW_LINE j = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( j < n and ( arr [ j ] not in s ) ) : NEW_LINE INDENT s . append ( arr [ j ] ) NEW_LINE j += 1 NEW_LINE DEDENT ans += ( ( j - i ) * ( j - i + 1 ) ) \/\/ 2 NEW_LINE s . remove ( arr [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( sumoflength ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.9139545109521866,"rouge_l":0.9613378684807256}
{"id":1419,"predictions":["class Node : NEW_LINE INDENT def __init__ ( self , v ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def printArray ( v , i ) : NEW_LINE INDENT for j in range ( i , len ( v ) ) : NEW_LINE INDENT print ( v [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( \" \" ) NEW_LINE DEDENT path = [ ] NEW_LINE path . left = [ ] NEW_LINE def printKPathUtil ( root , k ) : NEW_LINE INDENT global ans NEW_LINE if ( root == None ) : NEW_LINE INDENT return NEW_LINE DEDENT path . append ( root . data ) NEW_LINE printKPathUtil ( root . left , k ) NEW_LINE printKPathUtil ( root . right , k ) NEW_LINE f = 0 NEW_LINE for j in range ( len ( path ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT f += path [ j ] NEW_LINE if ( f == k ) : NEW_LINE INDENT printArray ( path , j ) NEW_LINE DEDENT DEDENT path . pop ( ) NEW_LINE DEDENT def printKPath ( root , k ) : NEW_LINE INDENT path = [ ] NEW_LINE printKPathUtil ( root , k ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = Node ( 1 ) NEW_LINE root . left = Node ( 3 ) NEW_LINE root . left = Node ( 2 ) NEW_LINE root . left . left = Node ( 1 ) NEW_LINE root . left . left = Node ( 2 ) NEW_LINE root . left . right = Node ( 1 ) NEW_LINE root . left . left = Node ( 1 ) NEW_LINE root . left . left = Node ( 1 ) NEW_LINE root . left . left = Node ( 2 ) NEW_LINE root . right . left = Node ( 1 ) NEW_LINE root . right . left = Node ( 2 ) NEW_LINE root . right . left = Node ( 4 ) NEW_LINE k = 5 NEW"],"references":["def printVector ( v , i ) : NEW_LINE INDENT for j in range ( i , len ( v ) ) : NEW_LINE INDENT print ( v [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT class newNode : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . data = key NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def printKPathUtil ( root , path , k ) : NEW_LINE INDENT if ( not root ) : NEW_LINE INDENT return NEW_LINE DEDENT path . append ( root . data ) NEW_LINE printKPathUtil ( root . left , path , k ) NEW_LINE printKPathUtil ( root . right , path , k ) NEW_LINE f = 0 NEW_LINE for j in range ( len ( path ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT f += path [ j ] NEW_LINE if ( f == k ) : NEW_LINE INDENT printVector ( path , j ) NEW_LINE DEDENT DEDENT path . pop ( - 1 ) NEW_LINE DEDENT def printKPath ( root , k ) : NEW_LINE INDENT path = [ ] NEW_LINE printKPathUtil ( root , path , k ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 1 ) NEW_LINE root . left = newNode ( 3 ) NEW_LINE root . left . left = newNode ( 2 ) NEW_LINE root . left . right = newNode ( 1 ) NEW_LINE root . left . right . left = newNode ( 1 ) NEW_LINE root . right = newNode ( - 1 ) NEW_LINE root . right . left = newNode ( 4 ) NEW_LINE root . right . left . left = newNode ( 1 ) NEW_LINE root . right . left . right = newNode ( 2 ) NEW_LINE root . right . right = newNode ( 5 ) NEW_LINE root . right . right . right = newNode ( 2 ) NEW_LINE k = 5 NEW_LINE printKPath ( root , k ) NEW_LINE DEDENT"],"bleu":0.7571243427698687,"rouge_l":0.7790723728433789}
{"id":1420,"predictions":["def reverseArray ( arr , n ) : NEW_LINE INDENT for i in range ( n \/\/ 2 ) : NEW_LINE INDENT arr [ i ] , arr [ ( n + ~ i + 1 ) + ~ 1 + 1 + 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 5 , 3 , 7 , 2 , 1 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE reverseArray ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT"],"references":["def reverseArray ( arr , n ) : NEW_LINE INDENT for i in range ( n \/\/ 2 ) : NEW_LINE INDENT arr [ i ] , arr [ ( n + ~ i + 1 ) + ~ 1 + 1 ] = arr [ ( n + ~ i + 1 ) + ~ 1 + 1 ] , arr [ i ] NEW_LINE DEDENT DEDENT arr = [ 5 , 3 , 7 , 2 , 1 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE reverseArray ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT"],"bleu":0.7960768778657084,"rouge_l":0.8490720524017467}
{"id":1421,"predictions":["import math NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def getNode ( data ) : NEW_LINE INDENT new_node = Node ( data ) NEW_LINE new_node . data = data NEW_LINE new_node . next = None NEW_LINE return new_node NEW_LINE DEDENT def push ( head_ref , new_node ) : NEW_LINE INDENT new_node . prev = None NEW_LINE new_node . next = head_ref NEW_LINE return new_node NEW_LINE DEDENT def push ( head_ref , new_node ) : NEW_LINE INDENT new_node . prev = None NEW_LINE new_node . next = head_ref NEW_LINE if ( head_ref != None ) : NEW_LINE INDENT head_ref . prev = new_node NEW_LINE DEDENT head_ref = new_node NEW_LINE new_node = new_node NEW_LINE return head_ref NEW_LINE DEDENT def reverseList ( head_ref ) : NEW_LINE INDENT if ( head_ref == None ) or ( ( head_ref . next ) . next ) == None ) : NEW_LINE INDENT return None NEW_LINE DEDENT new_head = None NEW_LINE curr = head_ref NEW_LINE while ( curr != None ) : NEW_LINE INDENT next = curr . next NEW_LINE new_head = append ( new_head , curr ) NEW_LINE curr = next NEW_LINE DEDENT head_ref = new_head NEW_LINE return head_ref NEW_LINE DEDENT def prList ( head ) : NEW_LINE INDENT while ( head != None ) : NEW_LINE INDENT print ( head . data , end = \" ▁ \" ) NEW_LINE head = head . next NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = None NEW_LINE head = push ( head , getNode ( 2 ) ) NEW_LINE head = push ( head , getNode ( 4 ) ) NEW_LINE head = push ( head ,"],"references":["import math NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def getNode ( data ) : NEW_LINE INDENT new_node = Node ( data ) NEW_LINE new_node . data = data NEW_LINE new_node . next = None NEW_LINE new_node . prev = None NEW_LINE return new_node NEW_LINE DEDENT def push ( head_ref , new_node ) : NEW_LINE INDENT new_node . prev = None NEW_LINE new_node . next = head_ref NEW_LINE if ( head_ref != None ) : NEW_LINE INDENT head_ref . prev = new_node NEW_LINE DEDENT head_ref = new_node NEW_LINE return head_ref NEW_LINE DEDENT def reverseList ( head_ref ) : NEW_LINE INDENT if ( head_ref == None or ( head_ref ) . next == None ) : NEW_LINE INDENT return None NEW_LINE DEDENT new_head = None NEW_LINE curr = head_ref NEW_LINE while ( curr != None ) : NEW_LINE INDENT next = curr . next NEW_LINE new_head = push ( new_head , curr ) NEW_LINE curr = next NEW_LINE DEDENT head_ref = new_head NEW_LINE return head_ref NEW_LINE DEDENT def prList ( head ) : NEW_LINE INDENT while ( head != None ) : NEW_LINE INDENT print ( head . data , end = \" ▁ \" ) NEW_LINE head = head . next NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = None NEW_LINE head = push ( head , getNode ( 2 ) ) ; NEW_LINE head = push ( head , getNode ( 4 ) ) ; NEW_LINE head = push ( head , getNode ( 8 ) ) ; NEW_LINE head = push ( head , getNode ( 10 ) ) ; NEW_LINE print ( \" Original ▁ list : ▁ \" , end = \" \" ) NEW_LINE prList ( head ) NEW_LINE head = reverseList ( head ) NEW_LINE print ( \" \\n Reversed ▁ list : ▁ \" , end = \" \" ) NEW_LINE prList ( head ) NEW_LINE DEDENT"],"bleu":0.765952737506552,"rouge_l":0.8298699357153536}
{"id":1422,"predictions":["def decdiagonal ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT d = 1.901 * a NEW_LINE return d NEW_LINE DEDENT a = 9 NEW_LINE print ( decdiagonal ( a ) ) NEW_LINE"],"references":["def decdiagonal ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT d = 1.902 * a NEW_LINE return d NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 9 NEW_LINE print ( decdiagonal ( a ) ) NEW_LINE DEDENT"],"bleu":0.6584028492194399,"rouge_l":0.8227728983688835}
{"id":1423,"predictions":["def findSum ( N , k ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT sum += pow ( i , k ) NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 8 ; k = 4 ; NEW_LINE print ( findSum ( N , k ) ) NEW_LINE DEDENT"],"references":["from math import pow NEW_LINE def findSum ( N , k ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , N + 1 , 1 ) : NEW_LINE INDENT sum += pow ( i , k ) NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 8 NEW_LINE k = 4 NEW_LINE print ( int ( findSum ( N , k ) ) ) NEW_LINE DEDENT"],"bleu":0.7415966794855199,"rouge_l":0.8840579710144928}
{"id":1424,"predictions":["def reverse ( k ) : NEW_LINE INDENT s = [ ] NEW_LINE for i in range ( len ( k ) ) : NEW_LINE INDENT s . append ( token [ i ] ) NEW_LINE DEDENT while len ( s ) != 0 : NEW_LINE INDENT print ( s [ - 1 ] , end = \" ▁ \" ) NEW_LINE s . pop ( ) NEW_LINE DEDENT DEDENT k = \" geeks ▁ for ▁ geeks \" NEW_LINE reverse ( k ) NEW_LINE"],"references":["def reverse ( k ) : NEW_LINE INDENT s = [ ] NEW_LINE token = k . split ( ) NEW_LINE for word in token : NEW_LINE INDENT s . append ( word ) ; NEW_LINE DEDENT while ( len ( s ) ) : NEW_LINE INDENT print ( s . pop ( ) , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT k = \" geeks ▁ for ▁ geeks \" ; NEW_LINE reverse ( k ) ; NEW_LINE DEDENT"],"bleu":0.5342046755942256,"rouge_l":0.6667263931195128}
{"id":1425,"predictions":["import sys NEW_LINE def subArray ( arr , n , m ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] = i + 1 NEW_LINE DEDENT sumcur = 0 NEW_LINE p = sys . maxsize NEW_LINE ans = p * i + ( sys . maxsize ) NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT sumcur += mp [ i ] NEW_LINE p = min ( p , mp [ i ] ) NEW_LINE val = p * i - i + ( i * ( i + 1 ) ) \/\/ 2 NEW_LINE if ( i == m ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 4 , 5 , 1 , 3 , 2 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE m = 3 NEW_LINE if ( subArray ( arr , n , m ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def subArray ( arr , n , m ) : NEW_LINE INDENT i = 0 NEW_LINE mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] = i + 1 NEW_LINE DEDENT sumcur = 0 NEW_LINE p = 10 ** 9 NEW_LINE ans = [ ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT sumcur += mp [ i ] NEW_LINE p = min ( p , mp [ i ] ) NEW_LINE val = p * i - i + ( i * ( i + 1 ) ) \/ 2 NEW_LINE if ( i == m ) : NEW_LINE INDENT if ( val == sumcur ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT DEDENT arr = [ 4 , 5 , 1 , 3 , 2 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE m = 3 NEW_LINE if ( subArray ( arr , n , m ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.826592966781291,"rouge_l":0.8807134033353923}
{"id":1426,"predictions":["class Graph : NEW_LINE INDENT def __init__ ( self , V ) : NEW_LINE INDENT self . V = V NEW_LINE self . adj = [ [ ] for i in range ( V ) ] NEW_LINE DEDENT def addEdge ( self , v , w ) : NEW_LINE INDENT self . adj [ v ] . append ( w ) NEW_LINE DEDENT def DFS ( self , s ) : NEW_LINE INDENT visited = [ False ] * self . V NEW_LINE stack . append ( s ) NEW_LINE while stack : NEW_LINE INDENT s = stack . pop ( 0 ) NEW_LINE if visited [ s ] == False : NEW_LINE INDENT print ( s , end = \" ▁ \" ) NEW_LINE visited [ s ] = True NEW_LINE DEDENT i = 0 NEW_LINE while len ( self . adj [ s ] ) != 0 : NEW_LINE INDENT if visited [ s ] == False : NEW_LINE INDENT stack . append ( self . adj [ s ] [ i ] ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT g = Graph ( ) NEW_LINE g . addEdge ( 1 , 0 ) NEW_LINE g . addEdge ( 0 , 2 ) NEW_LINE g . addEdge ( 2 , 1 ) NEW_LINE g . addEdge ( 1 , 3 ) NEW_LINE g . addEdge ( 1 , 4 ) NEW_LINE print ( \" Following ▁ is ▁ the ▁ Depth ▁ First ▁ Traversal \" ) NEW_LINE g . DFS ( 0 ) NEW_LINE"],"references":["class Graph : NEW_LINE INDENT def __init__ ( self , V ) : NEW_LINE INDENT self . V = V NEW_LINE self . adj = [ [ ] for i in range ( V ) ] NEW_LINE DEDENT def addEdge ( self , v , w ) : NEW_LINE INDENT self . adj [ v ] . append ( w ) NEW_LINE DEDENT def DFS ( self , s ) : NEW_LINE INDENT visited = [ False for i in range ( self . V ) ] NEW_LINE stack = [ ] NEW_LINE stack . append ( s ) NEW_LINE while ( len ( stack ) ) : NEW_LINE INDENT s = stack [ - 1 ] NEW_LINE stack . pop ( ) NEW_LINE if ( not visited [ s ] ) : NEW_LINE INDENT print ( s , end = ' ▁ ' ) NEW_LINE visited [ s ] = True NEW_LINE DEDENT for node in self . adj [ s ] : NEW_LINE INDENT if ( not visited [ node ] ) : NEW_LINE INDENT stack . append ( node ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT g = Graph ( 5 ) ; NEW_LINE g . addEdge ( 1 , 0 ) ; NEW_LINE g . addEdge ( 0 , 2 ) ; NEW_LINE g . addEdge ( 2 , 1 ) ; NEW_LINE g . addEdge ( 0 , 3 ) ; NEW_LINE g . addEdge ( 1 , 4 ) ; NEW_LINE print ( \" Following ▁ is ▁ Depth ▁ First ▁ Traversal \" ) NEW_LINE g . DFS ( 0 ) NEW_LINE"],"bleu":0.7237891684751303,"rouge_l":0.8467518045530262}
{"id":1427,"predictions":["class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def diagonalPrint ( root ) : NEW_LINE INDENT if ( not root ) : NEW_LINE INDENT return NEW_LINE DEDENT q = [ ] NEW_LINE q . append ( root ) NEW_LINE q . append ( None ) NEW_LINE while ( len ( q ) != 0 ) : NEW_LINE INDENT temp = q [ 0 ] NEW_LINE q . pop ( 0 ) NEW_LINE if ( temp == None ) : NEW_LINE INDENT return NEW_LINE DEDENT print ( ) NEW_LINE q . append ( None ) NEW_LINE DEDENT else : NEW_LINE INDENT while ( temp != None ) : NEW_LINE INDENT print ( temp . data , end = \" ▁ \" ) NEW_LINE if ( temp . left != None ) : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT else : NEW_LINE INDENT while ( temp != None ) : NEW_LINE INDENT print ( temp . data , end = \" ▁ \" ) NEW_LINE if ( temp . left ) : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE DEDENT temp = temp . right NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 8 ) NEW_LINE root . left = newNode ( 3 ) NEW_LINE root . right = newNode ( 10 ) NEW_LINE root . left . left = newNode ( 1 ) NEW_LINE root . left . left = newNode ( 6 ) NEW_LINE root . left . left = newNode ( 14 ) NEW_LINE root . left . right = newNode ( 14 ) NEW_LINE diagonalPrint ( root ) NEW_LINE DEDENT"],"references":["class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . val = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def diagonalprint ( root ) : NEW_LINE INDENT if root is None : NEW_LINE INDENT return NEW_LINE DEDENT q = [ ] NEW_LINE q . append ( root ) NEW_LINE q . append ( None ) NEW_LINE while len ( q ) > 0 : NEW_LINE INDENT temp = q . pop ( 0 ) NEW_LINE if not temp : NEW_LINE INDENT if len ( q ) == 0 : NEW_LINE INDENT return NEW_LINE DEDENT print ( ' ▁ ' ) NEW_LINE q . append ( None ) NEW_LINE DEDENT else : NEW_LINE INDENT while temp : NEW_LINE INDENT print ( temp . val , end = ' ▁ ' ) NEW_LINE if temp . left : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE DEDENT temp = temp . right NEW_LINE DEDENT DEDENT DEDENT DEDENT root = Node ( 8 ) NEW_LINE root . left = Node ( 3 ) NEW_LINE root . right = Node ( 10 ) NEW_LINE root . left . left = Node ( 1 ) NEW_LINE root . left . right = Node ( 6 ) NEW_LINE root . right . right = Node ( 14 ) NEW_LINE root . right . right . left = Node ( 13 ) NEW_LINE root . left . right . left = Node ( 4 ) NEW_LINE root . left . right . right = Node ( 7 ) NEW_LINE diagonalprint ( root ) NEW_LINE"],"bleu":0.5692212211185144,"rouge_l":0.7434865257743486}
{"id":1428,"predictions":["def __gcd ( a , b ) : NEW_LINE INDENT gcd = arr [ 0 ] NEW_LINE maxEle = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT gcd = __gcd ( gcd , arr [ i ] ) NEW_LINE maxEle = max ( maxEle , arr [ i ] ) NEW_LINE DEDENT totalMoves = ( maxEle \/\/ gcd ) - n NEW_LINE if ( totalMoves % 2 == 1 ) : NEW_LINE INDENT return ' A ' NEW_LINE DEDENT return ' B ' NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( getWinner ( arr , n ) ) NEW_LINE DEDENT"],"references":["from math import gcd NEW_LINE def getWinner ( arr , n ) : NEW_LINE INDENT __gcd = arr [ 0 ] ; NEW_LINE maxEle = arr [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT __gcd = gcd ( __gcd , arr [ i ] ) ; NEW_LINE maxEle = max ( maxEle , arr [ i ] ) ; NEW_LINE DEDENT totalMoves = ( maxEle \/ __gcd ) - n ; NEW_LINE if ( totalMoves % 2 == 1 ) : NEW_LINE INDENT return ' A ' ; NEW_LINE DEDENT return ' B ' ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 5 , 6 , 7 ] ; NEW_LINE n = len ( arr ) NEW_LINE print ( getWinner ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.6720727275258882,"rouge_l":0.8691255888773987}
{"id":1429,"predictions":["def CountingEvenOdd ( arr , arr_size ) : NEW_LINE INDENT even_count = 0 NEW_LINE odd_count = 0 NEW_LINE for i in range ( 0 , arr_size ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT odd_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even_count += 1 NEW_LINE DEDENT DEDENT print ( \" Number ▁ of ▁ even \" , \" elements ▁ = \" , even_count , \" Number ▁ of ▁ odd ▁ elements ▁ = ▁ \" , odd_count ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE CountingEvenOdd ( arr , n ) NEW_LINE DEDENT"],"references":["def CountingEvenOdd ( arr , arr_size ) : NEW_LINE INDENT even_count = 0 NEW_LINE odd_count = 0 NEW_LINE for i in range ( arr_size ) : NEW_LINE INDENT if ( arr [ i ] & 1 == 1 ) : NEW_LINE INDENT odd_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even_count += 1 NEW_LINE DEDENT DEDENT print ( \" Number ▁ of ▁ even ▁ elements ▁ = ▁ \" , even_count ) NEW_LINE print ( \" Number ▁ of ▁ odd ▁ elements ▁ = ▁ \" , odd_count ) NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE CountingEvenOdd ( arr , n ) NEW_LINE"],"bleu":0.7898015822143614,"rouge_l":0.898217514854043}
{"id":1430,"predictions":["def findSum ( str ) : NEW_LINE INDENT temp = \" \" NEW_LINE sum = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if str [ i ] . isdigit ( ) : NEW_LINE INDENT temp += ch NEW_LINE DEDENT else : NEW_LINE INDENT sum += int ( temp ) NEW_LINE DEDENT DEDENT return sum + int ( temp ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \"12abc6868\" NEW_LINE print ( findSum ( str ) ) NEW_LINE DEDENT"],"references":["def findSum ( str1 ) : NEW_LINE INDENT temp = \" \" NEW_LINE Sum = 0 NEW_LINE for ch in str1 : NEW_LINE INDENT if ( ch . isdigit ( ) ) : NEW_LINE INDENT temp += ch NEW_LINE DEDENT else : NEW_LINE INDENT Sum += int ( temp ) NEW_LINE temp = \"0\" NEW_LINE DEDENT DEDENT return Sum + int ( temp ) NEW_LINE DEDENT str1 = \"12abc20yz68\" NEW_LINE print ( findSum ( str1 ) ) NEW_LINE"],"bleu":0.4888845213588184,"rouge_l":0.7296932278603124}
{"id":1431,"predictions":["def fibonacci ( n ) : NEW_LINE INDENT f = [ 0 ] * ( n + 2 ) NEW_LINE f [ 0 ] , f [ 1 ] = 0 , 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT f [ i ] = f [ i - 1 ] + f [ i - 2 ] NEW_LINE DEDENT return f [ n ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 9 NEW_LINE print ( fibonacci ( n ) ) NEW_LINE DEDENT"],"references":["def fibonacci ( n ) : NEW_LINE INDENT FibArray = [ 0 , 1 ] NEW_LINE while len ( FibArray ) < n + 1 : NEW_LINE INDENT FibArray . append ( 0 ) NEW_LINE DEDENT if n <= 1 : NEW_LINE INDENT return n NEW_LINE DEDENT else : NEW_LINE INDENT if FibArray [ n - 1 ] == 0 : NEW_LINE INDENT FibArray [ n - 1 ] = fibonacci ( n - 1 ) NEW_LINE DEDENT if FibArray [ n - 2 ] == 0 : NEW_LINE INDENT FibArray [ n - 2 ] = fibonacci ( n - 2 ) NEW_LINE DEDENT DEDENT FibArray [ n ] = FibArray [ n - 2 ] + FibArray [ n - 1 ] NEW_LINE return FibArray [ n ] NEW_LINE DEDENT print ( fibonacci ( 9 ) ) NEW_LINE"],"bleu":0.1991934907504358,"rouge_l":0.4354263053536021}
{"id":1432,"predictions":["def oddNumSum ( n ) : NEW_LINE INDENT j = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT j = ( 2 * i - 1 ) NEW_LINE sum = sum + ( j * j * j * j ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 6 NEW_LINE print ( oddNumSum ( n ) ) NEW_LINE"],"references":["def oddNumSum ( n ) : NEW_LINE INDENT j = 0 NEW_LINE sm = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT j = ( 2 * i - 1 ) NEW_LINE sm = sm + ( j * j * j * j ) NEW_LINE DEDENT return sm NEW_LINE DEDENT n = 6 ; NEW_LINE print ( oddNumSum ( n ) ) NEW_LINE"],"bleu":0.831655344355288,"rouge_l":0.9358827570414471}
{"id":1433,"predictions":["import math NEW_LINE def findAandB ( N ) : NEW_LINE INDENT val = N * N - 4 * N ; NEW_LINE if ( val < 0 ) : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE return ; NEW_LINE DEDENT a = ( N + math . sqrt ( val ) ) \/ 2.0 ; NEW_LINE b = ( N - math . sqrt ( val ) ) \/ 2.0 ; NEW_LINE print ( \" a ▁ = \" , a ) ; NEW_LINE print ( \" b ▁ = \" , b ) ; NEW_LINE DEDENT n = 69.0 ; NEW_LINE findAandB ( n ) ; NEW_LINE"],"references":["from math import sqrt NEW_LINE def findAandB ( N ) : NEW_LINE INDENT val = N * N - 4.0 * N NEW_LINE if ( val < 0 ) : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE return NEW_LINE DEDENT a = ( N + sqrt ( val ) ) \/ 2.0 NEW_LINE b = ( N - sqrt ( val ) ) \/ 2.0 NEW_LINE print ( \" a ▁ = \" , ' { 0 : . 6 } ' . format ( a ) ) NEW_LINE print ( \" b ▁ = \" , ' { 0 : . 6 } ' . format ( b ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 69.0 NEW_LINE findAandB ( N ) NEW_LINE DEDENT"],"bleu":0.5007452583286052,"rouge_l":0.7405398424383314}
{"id":1434,"predictions":["def reverseString ( string ) : NEW_LINE INDENT r = len ( string ) - 1 ; NEW_LINE l = 0 ; NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( not isalpha ( string [ l ] ) ) : NEW_LINE INDENT l += 1 ; NEW_LINE DEDENT elif ( not isalpha ( string [ r ] ) ) : NEW_LINE INDENT r -= 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT string [ l ] = string [ r ] ; NEW_LINE string [ r ] = string [ r ] ; NEW_LINE l += 1 ; NEW_LINE r -= 1 ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" a ! ! ! ( b . c . d , e ) ; NEW_LINE revStr = \" \" ; NEW_LINE print ( \" Input ▁ string : \" , revStr ) ; NEW_LINE DEDENT"],"references":["def reverseSting ( text ) : NEW_LINE INDENT index = - 1 NEW_LINE for i in range ( len ( text ) - 1 , int ( len ( text ) \/ 2 ) , - 1 ) : NEW_LINE INDENT if text [ i ] . isalpha ( ) : NEW_LINE INDENT temp = text [ i ] NEW_LINE while True : NEW_LINE INDENT index += 1 NEW_LINE if text [ index ] . isalpha ( ) : NEW_LINE INDENT text [ i ] = text [ index ] NEW_LINE text [ index ] = temp NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT return text NEW_LINE DEDENT string = \" a ! ! ! b . c . d , e ' f , ghi \" NEW_LINE print ( \" Input ▁ string : ▁ \" , string ) NEW_LINE string = reverseSting ( list ( string ) ) NEW_LINE print ( \" Output ▁ string : ▁ \" , \" \" . join ( string ) ) NEW_LINE"],"bleu":0.2649777771714009,"rouge_l":0.4618485742379548}
{"id":1435,"predictions":["import math NEW_LINE def geometricMean ( n ) : NEW_LINE INDENT return math . sqrt ( n ) NEW_LINE DEDENT n = 16 NEW_LINE print ( geometricMean ( n ) ) NEW_LINE"],"references":["from math import sqrt NEW_LINE def geometricMean ( n ) : NEW_LINE INDENT return int ( sqrt ( n ) ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 16 ; NEW_LINE print ( geometricMean ( n ) ) ; NEW_LINE DEDENT"],"bleu":0.3500674651082214,"rouge_l":0.6620508982035929}
{"id":1436,"predictions":["def kPresentProbability ( a , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == k ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT return count \/ n ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 4 , 7 , 2 , 0 , 8 , 7 , 5 ] NEW_LINE K = 2 NEW_LINE N = len ( A ) NEW_LINE n = len ( A ) NEW_LINE n = kPresentProbability ( A , N , K ) ; NEW_LINE p = round ( n , 5 ) \/ 100 NEW_LINE print ( p ) NEW_LINE DEDENT"],"references":["def kPresentProbability ( a , n , k ) : NEW_LINE INDENT count = a . count ( k ) NEW_LINE return round ( count \/ n , 2 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 4 , 7 , 2 , 0 , 8 , 7 , 5 ] NEW_LINE K = 2 NEW_LINE N = len ( A ) NEW_LINE print ( kPresentProbability ( A , N , K ) ) NEW_LINE DEDENT"],"bleu":0.5342443799720615,"rouge_l":0.7426252536288434}
{"id":1437,"predictions":["def checkEvenOdd ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT print ( \" Even \" ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( \" Odd \" ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 12 , 20 , 36 , 38 ] NEW_LINE n = len ( arr ) NEW_LINE checkEvenOdd ( arr , n ) NEW_LINE DEDENT"],"references":["def checkEvenOdd ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT print ( \" Even \" , end = \" \" ) ; NEW_LINE return ; NEW_LINE DEDENT DEDENT print ( \" Odd \" , end = \" \" ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 12 , 20 , 36 , 38 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE checkEvenOdd ( arr , n ) ; NEW_LINE DEDENT"],"bleu":0.7094431202222862,"rouge_l":0.8904410610579188}
{"id":1438,"predictions":["def toggleLastMBits ( n , m ) : NEW_LINE INDENT if ( m == 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT num = ( 1 << m ) - 1 NEW_LINE return ( n ^ num ) NEW_LINE DEDENT def largeNumWithNSetBits ( n , m ) : NEW_LINE INDENT num = ( 1 << ( n + m ) ) - 1 NEW_LINE return toggleLastMBits ( num , m ) NEW_LINE DEDENT n = 2 ; m = 2 NEW_LINE print ( largeNumWithNSetBits ( n , m ) ) NEW_LINE"],"references":["def toggleLastMBits ( n , m ) : NEW_LINE INDENT if ( m == 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT num = ( 1 << m ) - 1 NEW_LINE return ( n ^ num ) NEW_LINE DEDENT def largeNumWithNSetAndMUnsetBits ( n , m ) : NEW_LINE INDENT num = ( 1 << ( n + m ) ) - 1 NEW_LINE return toggleLastMBits ( num , m ) NEW_LINE DEDENT n = 2 NEW_LINE m = 2 NEW_LINE print ( largeNumWithNSetAndMUnsetBits ( n , m ) ) NEW_LINE"],"bleu":0.9167980576638141,"rouge_l":0.967391304347826}
{"id":1439,"predictions":["def series ( A , X , n ) : NEW_LINE INDENT term = pow ( A , n ) NEW_LINE print ( term , end = \" ▁ \" ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT term = term * X * ( n - i + 1 ) \/ ( i * A ) NEW_LINE print ( term , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT A = 3 NEW_LINE X = 4 NEW_LINE n = 5 NEW_LINE series ( A , X , n ) NEW_LINE"],"references":["def series ( A , X , n ) : NEW_LINE INDENT term = pow ( A , n ) NEW_LINE print ( term , end = \" ▁ \" ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT term = int ( term * X * ( n - i + 1 ) \/ ( i * A ) ) NEW_LINE print ( term , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT A = 3 ; X = 4 ; n = 5 NEW_LINE series ( A , X , n ) NEW_LINE"],"bleu":0.8983189543095541,"rouge_l":0.9629510309278351}
{"id":1440,"predictions":["def merge ( arr , l , m , r ) : NEW_LINE INDENT n1 = m - l + 1 NEW_LINE n2 = r - m NEW_LINE L = [ 0 for i in range ( n1 ) ] NEW_LINE R = [ 0 for i in range ( n1 ) ] NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT L [ i ] = arr [ l + i ] NEW_LINE DEDENT for j in range ( n2 ) : NEW_LINE INDENT R [ j ] = arr [ m + 1 + j ] NEW_LINE DEDENT i = 0 NEW_LINE j = 0 NEW_LINE k = l NEW_LINE while i < n1 and j < n2 : NEW_LINE INDENT if L [ i ] <= R [ j ] : NEW_LINE INDENT arr [ k ] = L [ i ] NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ k ] = R [ j ] NEW_LINE j += 1 NEW_LINE DEDENT k += 1 NEW_LINE DEDENT while i < n1 : NEW_LINE INDENT arr [ k ] = L [ i ] NEW_LINE k += 1 NEW_LINE DEDENT while j < n2 : NEW_LINE INDENT arr [ k ] = R [ j ] NEW_LINE j += 1 NEW_LINE k += 1 NEW_LINE DEDENT while j < n2 : NEW_LINE INDENT arr [ k ] = R [ j ] NEW_LINE j += 1 NEW_LINE k += 1 NEW_LINE DEDENT DEDENT def printArray ( arr , n , r ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 12 , 11 , 13 , 5 , 6 , 7 ] NEW_LINE print ( \" \\n Sorted ▁ array \" ) NEW_LINE printArray ( arr ) NEW_LINE printArray ( arr ) NEW_LINE DEDENT"],"references":["def mergeSort ( a ) : NEW_LINE INDENT if len ( a ) > 1 : NEW_LINE INDENT mid = len ( a ) \/\/ 2 NEW_LINE L = a [ : mid ] NEW_LINE R = a [ mid : ] NEW_LINE mergeSort ( L ) NEW_LINE mergeSort ( R ) NEW_LINE a . clear ( ) NEW_LINE while len ( L ) > 0 and len ( R ) < 0 : NEW_LINE INDENT if L [ 0 ] <= R [ 0 ] : NEW_LINE INDENT a . append ( L [ 0 ] ) NEW_LINE L . pop ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT a . append ( R [ 0 ] ) NEW_LINE R . pop ( 0 ) NEW_LINE DEDENT DEDENT for i in L : NEW_LINE INDENT a . append ( i ) NEW_LINE DEDENT for i in R : NEW_LINE INDENT a . append ( i ) NEW_LINE DEDENT DEDENT DEDENT a = [ 12 , 11 , 13 , 5 , 6 , 7 ] NEW_LINE print ( \" Given ▁ array ▁ is \" ) NEW_LINE print ( * a ) NEW_LINE mergeSort ( a ) NEW_LINE print ( \" Sorted ▁ array ▁ is ▁ : ▁ \" ) NEW_LINE print ( * a ) NEW_LINE"],"bleu":0.18020097320461964,"rouge_l":0.4061743341404358}
{"id":1441,"predictions":["def answer ( arr , ranges , reversals , index ) : NEW_LINE INDENT for i in range ( revers - 1 , - 1 , - 1 ) : NEW_LINE INDENT left = ranges [ i ] [ 0 ] NEW_LINE right = ranges [ i ] [ 1 ] NEW_LINE if ( left <= index and right >= index ) ) : NEW_LINE INDENT index = right + left - index NEW_LINE DEDENT DEDENT return arr [ index ] NEW_LINE DEDENT arr = [ 10 , 20 , 30 , 40 , 50 ] NEW_LINE reversals = 2 NEW_LINE ranges = [ [ 1 , 4 ] , [ 0 , 2 ] ] NEW_LINE index = 1 NEW_LINE print ( answer ( arr , ranges , reversals , index ) ) NEW_LINE"],"references":["def answer ( arr , ranges , reversals , index ) : NEW_LINE INDENT i = reversals - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT left = ranges [ i ] [ 0 ] NEW_LINE right = ranges [ i ] [ 1 ] NEW_LINE if ( left <= index and right >= index ) : NEW_LINE INDENT index = right + left - index NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT return arr [ index ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 10 , 20 , 30 , 40 , 50 ] NEW_LINE reversals = 2 NEW_LINE ranges = [ [ 1 , 4 ] , [ 0 , 2 ] ] NEW_LINE index = 1 NEW_LINE print ( answer ( arr , ranges , reversals , index ) ) NEW_LINE DEDENT"],"bleu":0.7744053825035738,"rouge_l":0.8585650532097494}
{"id":1442,"predictions":["def isDivisibleBy25 ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return ( ( ( ord ( str [ n - 1 ] ) - ord ( '0' ) ) - ord ( '0' ) == 0 ) or ( ( ord ( str [ n - 2 ] ) - ord ( '0' ) ) ) % 25 == 0 ) or ( ( ( ord ( str [ n - 1 ] ) - ord ( '0' ) ) * 10 + ( ord ( str [ n - 1 ] ) - ord ( '0' ) ) ) % 25 == 0 ) NEW_LINE DEDENT if ( isDivisibleBy25 ( str ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def isDivisibleBy25 ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return ( ( int ) ( st [ n - 1 ] ) == 0 and ( ( int ) ( st [ n - 2 ] ) == 0 ) or ( ( int ) ( st [ n - 2 ] ) * 10 + ( int ) ( st [ n - 1 ] ) % 25 == 0 ) ) NEW_LINE DEDENT st = \"76955\" NEW_LINE if ( isDivisibleBy25 ( st ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.5385147320124444,"rouge_l":0.7622303430390193}
{"id":1443,"predictions":["def square ( n ) : NEW_LINE INDENT return n * n NEW_LINE DEDENT def sum ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return square ( ( n + 1 ) \/\/ 2 ) + sum ( n \/\/ 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return square ( n \/\/ 2 ) + sum ( n \/\/ 2 ) NEW_LINE DEDENT DEDENT def oddDivSum ( a , b ) : NEW_LINE INDENT return sum ( b ) - sum ( a - 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 3 NEW_LINE b = 9 NEW_LINE print ( oddDivSum ( a , b ) ) NEW_LINE DEDENT"],"references":["def square ( n ) : NEW_LINE INDENT return n * n ; NEW_LINE DEDENT def sum ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return ( square ( int ( ( n + 1 ) \/ 2 ) ) + sum ( int ( n \/ 2 ) ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return ( square ( int ( n \/ 2 ) ) + sum ( int ( n \/ 2 ) ) ) ; NEW_LINE DEDENT DEDENT def oddDivSum ( a , b ) : NEW_LINE INDENT return sum ( b ) - sum ( a - 1 ) ; NEW_LINE DEDENT a , b = 3 , 9 ; NEW_LINE print ( oddDivSum ( a , b ) ) ; NEW_LINE"],"bleu":0.6379901064767203,"rouge_l":0.8225931247927489}
{"id":1444,"predictions":["def removeOddFrequency ( s ) : NEW_LINE INDENT m = { } ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT p = s [ i ] ; NEW_LINE count = m [ p ] ; NEW_LINE if ( count == None ) : NEW_LINE INDENT count = 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT m [ p ] = 1 ; NEW_LINE DEDENT DEDENT new_string = \" \" ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( m [ s [ i ] ] & 1 ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT new_string += s [ i ] ; NEW_LINE DEDENT return new_string ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" geeksforgeeks \" ; NEW_LINE string = removeOddFrequency ( string ) ; NEW_LINE print ( string ) ; NEW_LINE DEDENT"],"references":["def removeOddFrequencyCharacters ( s ) : NEW_LINE INDENT m = dict ( ) NEW_LINE for i in s : NEW_LINE INDENT m [ i ] = m . get ( i , 0 ) + 1 NEW_LINE DEDENT new_s = \" \" NEW_LINE for i in s : NEW_LINE INDENT if ( m [ i ] & 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT new_s += i NEW_LINE DEDENT return new_s NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" geeksforgeeks \" NEW_LINE str = removeOddFrequencyCharacters ( str ) NEW_LINE print ( str ) NEW_LINE DEDENT"],"bleu":0.2979024883643147,"rouge_l":0.6655114876139134}
{"id":1445,"predictions":["def countNonDecreasing ( n ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( n + 1 ) ] for y in range ( 10 ) ] NEW_LINE for digit in range ( 10 ) : NEW_LINE INDENT dp [ i ] [ 1 ] = 1 ; NEW_LINE DEDENT for digit in range ( 9 ) : NEW_LINE INDENT for l in range ( 2 , n + 1 ) : NEW_LINE INDENT dp [ digit ] [ l ] += dp [ x ] [ l - 1 ] ; NEW_LINE DEDENT DEDENT count = 0 ; NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT count += dp [ i ] [ n ] ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT n = 3 ; NEW_LINE print ( countNonDecreasing ( n ) ) ; NEW_LINE"],"references":["def countNonDecreasing ( n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n + 1 ) ] for i in range ( 10 ) ] NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT dp [ i ] [ 1 ] = 1 NEW_LINE DEDENT for digit in range ( 10 ) : NEW_LINE INDENT for len in range ( 2 , n + 1 ) : NEW_LINE INDENT for x in range ( digit + 1 ) : NEW_LINE INDENT dp [ digit ] [ len ] += dp [ x ] [ len - 1 ] NEW_LINE DEDENT DEDENT DEDENT count = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT count += dp [ i ] [ n ] NEW_LINE DEDENT return count NEW_LINE DEDENT n = 3 NEW_LINE print ( countNonDecreasing ( n ) ) NEW_LINE"],"bleu":0.7356906541646296,"rouge_l":0.881911488798146}
{"id":1446,"predictions":["def maxCount ( n , a ) : NEW_LINE INDENT freq = { } NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if a [ i ] not in freq . keys ( ) : NEW_LINE INDENT freq [ a [ i ] ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ a [ i ] ] = 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for key in freq : NEW_LINE INDENT if freq [ key ] in freq . keys ( ) : NEW_LINE INDENT ans = max ( ans , freq [ key ] + freq [ key + 1 ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT n = 5 NEW_LINE arr = [ 2 , 2 , 3 , 4 , 5 ] NEW_LINE print ( maxCount ( n , arr ) ) NEW_LINE"],"references":["def maxCount ( a ) : NEW_LINE INDENT freq = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] in freq ) : NEW_LINE INDENT freq [ a [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ a [ i ] ] = 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for key , value in freq . items ( ) : NEW_LINE INDENT if ( key + 1 in freq ) : NEW_LINE INDENT ans = max ( ans , freq [ key ] + freq [ key + 1 ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT n = 5 NEW_LINE arr = [ 2 , 2 , 3 , 4 , 5 ] NEW_LINE print ( maxCount ( arr ) ) NEW_LINE"],"bleu":0.7792852166310176,"rouge_l":0.899211518683579}
{"id":1447,"predictions":["import math NEW_LINE def dist ( x1 , y1 , x2 , y2 , r ) : NEW_LINE INDENT print ( \" The ▁ shortest ▁ distance ▁ between ▁ a ▁ point ▁ and ▁ ( \" , pow ( ( x2 - x1 ) , 2 ) ) + ( ** 2 ) - r ) ) NEW_LINE DEDENT x1 = 4 NEW_LINE y1 = 6 NEW_LINE x2 , y2 = 35 , 42 , 5 NEW_LINE dist ( x1 , y1 , x2 , y2 , r ) NEW_LINE"],"references":["def dist ( x1 , y1 , x2 , y2 , r ) : NEW_LINE INDENT print ( \" The ▁ shortest ▁ distance ▁ between ▁ a ▁ point ▁ and ▁ a ▁ circle ▁ is ▁ \" , ( ( ( ( x2 - x1 ) ** 2 ) + ( ( y2 - y1 ) ** 2 ) ) ** ( 1 \/ 2 ) ) - r ) ; NEW_LINE DEDENT x1 = 4 ; NEW_LINE y1 = 6 ; NEW_LINE x2 = 35 ; NEW_LINE y2 = 42 ; NEW_LINE r = 5 ; NEW_LINE dist ( x1 , y1 , x2 , y2 , r ) ; NEW_LINE"],"bleu":0.544196736921254,"rouge_l":0.7577639751552794}
{"id":1448,"predictions":["v = [ ] NEW_LINE def dfs ( x , adj ) : NEW_LINE INDENT sz = 1 NEW_LINE vis [ x ] = 1 NEW_LINE for i in range ( len ( adj [ x ] ) ) : NEW_LINE INDENT if ( vis [ x ] [ i ] == 0 ) : NEW_LINE INDENT sz += dfs ( adj [ x ] [ i ] , adj ) NEW_LINE DEDENT DEDENT return sz NEW_LINE DEDENT def maxValue ( n , adj ) : NEW_LINE INDENT val = 0 NEW_LINE vis = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( vis [ i ] == 0 ) : NEW_LINE INDENT val += dfs ( i , adj ) - 1 NEW_LINE DEDENT DEDENT return val NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE v = [ 0 ] * ( n + 1 ) NEW_LINE v = [ 1 ] * ( n + 1 ) NEW_LINE v1 . append ( 1 ) NEW_LINE v1 . append ( 2 ) NEW_LINE v1 . append ( v ) NEW_LINE adj . append ( v1 ) NEW_LINE adj . append ( v1 ) NEW_LINE adj . append ( v1 ) NEW_LINE print ( maxValue ( n , adj ) ) NEW_LINE DEDENT"],"references":["def dfs ( x , adj , vis ) : NEW_LINE INDENT sz = 1 NEW_LINE vis [ x ] = 1 NEW_LINE for ch in adj : NEW_LINE INDENT if ( not vis [ ch ] ) : NEW_LINE INDENT sz += dfs ( ch , adj , vis ) NEW_LINE DEDENT DEDENT return sz NEW_LINE DEDENT def maxValue ( n , adj ) : NEW_LINE INDENT val = 0 NEW_LINE vis = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( not vis [ i ] ) : NEW_LINE INDENT val += dfs ( i , adj , vis ) - 1 NEW_LINE DEDENT DEDENT return val NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE adj = [ 1 , 2 , 2 , 3 ] NEW_LINE print ( maxValue ( n , adj ) ) NEW_LINE DEDENT"],"bleu":0.5133942852291,"rouge_l":0.7336507141067402}
{"id":1449,"predictions":["from math import tan NEW_LINE def area_of_single_ polygon ( n , lenngth ) : NEW_LINE INDENT P = ( len * n ) NEW_LINE A = len ( 2 * tan ( ( 180 \/ n ) * 3.14159 \/ 180 ) NEW_LINE area = ( P * A ) \/ 2 NEW_LINE return area NEW_LINE DEDENT def area_of_triangle_inscribed ( n , length ) : NEW_LINE INDENT area = area_of_triangle ( n , length ) NEW_LINE triangle = area \/ n NEW_LINE ins_triangle = ( triangle * 3 ) NEW_LINE return ins_tri NEW_LINE DEDENT n = 6 NEW_LINE length = 10 NEW_LINE print ( area_of_triangle_inscribed ( n , length ) ) NEW_LINE"],"references":["import math NEW_LINE def area_of_regular_polygon ( n , len ) : NEW_LINE INDENT P = ( len * n ) ; NEW_LINE A = len \/ ( 2 * math . tan ( ( 180 \/ n ) * 3.14159 \/ 180 ) ) NEW_LINE area = ( P * A ) \/ 2 NEW_LINE return area NEW_LINE DEDENT def area_of_triangle_inscribed ( n , len ) : NEW_LINE INDENT area = area_of_regular_polygon ( n , len ) NEW_LINE triangle = area \/ n NEW_LINE ins_tri = ( triangle * 3 ) ; NEW_LINE return ins_tri NEW_LINE DEDENT n = 6 NEW_LINE len = 10 NEW_LINE print ( round ( area_of_triangle_inscribed ( n , len ) , 3 ) ) NEW_LINE"],"bleu":0.6515472433368334,"rouge_l":0.8567415730337079}
{"id":1450,"predictions":["def centeredHexagonalNumber ( n ) : NEW_LINE INDENT return ( 3 * n * ( n - 1 ) + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE print ( n , \" th ▁ centered ▁ hexagonal ▁ number : ▁ \" , centeredHexagonalNumber ( n ) ) NEW_LINE DEDENT"],"references":["def centeredHexagonalNumber ( n ) : NEW_LINE INDENT return 3 * n * ( n - 1 ) + 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE print ( n , \" th ▁ centered ▁ hexagonal ▁ number : ▁ \" , centeredHexagonalNumber ( n ) ) NEW_LINE DEDENT"],"bleu":0.9198853691796676,"rouge_l":0.9869519832985386}
{"id":1451,"predictions":["def isOrthogonal ( a , m , n ) : NEW_LINE INDENT if ( m != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for k in range ( n ) : NEW_LINE INDENT sum = sum + ( a [ i , k ] * a [ k ] ) NEW_LINE DEDENT if ( i == j and sum != 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( i != j and sum != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT a = [ [ 1 , 0 , 0 ] , [ 0 , 1 , 0 ] , [ 0 , 0 , 1 ] ] NEW_LINE if ( isOrthogonal ( a , 3 , 3 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def isOrthogonal ( a , m , n ) : NEW_LINE INDENT if ( m != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for k in range ( 0 , n ) : NEW_LINE INDENT sum = sum + ( a [ i ] [ k ] * a [ j ] [ k ] ) NEW_LINE DEDENT DEDENT if ( i == j and sum != 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( i != j and sum != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT a = [ [ 1 , 0 , 0 ] , [ 0 , 1 , 0 ] , [ 0 , 0 , 1 ] ] NEW_LINE if ( isOrthogonal ( a , 3 , 3 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.9004774550474799,"rouge_l":0.9553893532776067}
{"id":1452,"predictions":["def getAvg ( prev_avg , x , n ) : NEW_LINE INDENT return ( prev_avg * n + x ) \/ ( n + 1 ) NEW_LINE DEDENT def streamAvg ( arr , n ) : NEW_LINE INDENT avg = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT avg = getAvg ( avg , arr [ i ] , i ) NEW_LINE print ( \"Average ▁ of ▁ d ▁ numbers ▁ is \" , avg ) NEW_LINE DEDENT DEDENT arr = [ 10 , 20 , 30 , 40 , 50 , 60 ] NEW_LINE n = len ( arr ) NEW_LINE streamAvg ( arr , n ) NEW_LINE"],"references":["def getAvg ( prev_avg , x , n ) : NEW_LINE INDENT return ( ( prev_avg * n + x ) \/ ( n + 1 ) ) ; NEW_LINE DEDENT def streamAvg ( arr , n ) : NEW_LINE INDENT avg = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT avg = getAvg ( avg , arr [ i ] , i ) ; NEW_LINE print ( \" Average ▁ of ▁ \" , i + 1 , \" ▁ numbers ▁ is ▁ \" , avg ) ; NEW_LINE DEDENT DEDENT arr = [ 10 , 20 , 30 , 40 , 50 , 60 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE streamAvg ( arr , n ) ; NEW_LINE"],"bleu":0.7264646679383765,"rouge_l":0.9029870473169442}
{"id":1453,"predictions":["import sys NEW_LINE def costOfOperation ( n , h , cost , e ) : NEW_LINE INDENT c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT c += abs ( h [ i ] - e ) * cost [ i ] NEW_LINE DEDENT return c NEW_LINE DEDENT def Bsearch ( n , h , cost ) : NEW_LINE INDENT max_h = max ( h ) NEW_LINE ans = 1 + max_h NEW_LINE low = 0 NEW_LINE while ( high > low ) : NEW_LINE INDENT mid = ( low + high ) >> 1 NEW_LINE if ( mid > 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT bm = ( low + high ) >> 1 NEW_LINE if ( mid > 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT ans = min ( ans , m ) NEW_LINE if ( ans == m ) : NEW_LINE INDENT break NEW_LINE DEDENT ans = min ( ans , m ) NEW_LINE if ( bm <= m ) : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT elif ( amm <= m ) : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return m NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT h = [ 1 , 2 , 3 ] NEW_LINE cost = [ 10 , 100 , 1000 ] NEW_LINE n = len ( h ) NEW_LINE print ( Bsearch ( n , h , cost ) ) NEW_LINE"],"references":["import sys NEW_LINE def costOfOperation ( n , h , cost , eq_h ) : NEW_LINE INDENT c = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT c += abs ( h [ i ] - eq_h ) * cost [ i ] NEW_LINE DEDENT return c NEW_LINE DEDENT def Bsearch ( n , h , cost ) : NEW_LINE INDENT max_h = h [ 0 ] NEW_LINE for i in range ( len ( h ) ) : NEW_LINE INDENT if ( h [ i ] > max_h ) : NEW_LINE INDENT max_h = h [ i ] NEW_LINE DEDENT DEDENT ans = sys . maxsize NEW_LINE high = 1 + max_h NEW_LINE low = 0 NEW_LINE while ( high > low ) : NEW_LINE INDENT mid = ( low + high ) >> 1 NEW_LINE if ( mid > 0 ) : NEW_LINE INDENT bm = costOfOperation ( n , h , cost , mid - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT bm = sys . maxsize NEW_LINE DEDENT m = costOfOperation ( n , h , cost , mid ) NEW_LINE am = costOfOperation ( n , h , cost , mid + 1 ) NEW_LINE if ( ans == m ) : NEW_LINE INDENT break NEW_LINE DEDENT ans = min ( ans , m ) NEW_LINE if ( bm <= m ) : NEW_LINE INDENT high = mid NEW_LINE DEDENT elif ( am <= m ) : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return m ; NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT h = [ 1 , 2 , 3 ] NEW_LINE cost = [ 10 , 100 , 1000 ] NEW_LINE n = len ( h ) NEW_LINE print ( Bsearch ( n , h , cost ) ) NEW_LINE DEDENT"],"bleu":0.5902478045541263,"rouge_l":0.7558481969217092}
{"id":1454,"predictions":["def check ( a , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == ' _ main _ _ ' : NEW_LINE INDENT a = [ 0 , 1 , 0 , 1 ] NEW_LINE n = len ( a ) NEW_LINE if ( check ( a , n ) == 1 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"references":["def check ( a , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 0 , 1 , 0 , 1 ] NEW_LINE n = len ( a ) NEW_LINE if ( check ( a , n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.9264600026563441,"rouge_l":0.9788128992054836}
{"id":1455,"predictions":["def findIndex ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT a = 0 NEW_LINE b = 1 NEW_LINE c = 1 NEW_LINE res = 1 NEW_LINE while ( c < n ) : NEW_LINE INDENT c = a + b NEW_LINE res += 1 NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( findIndex ( 21 ) ) NEW_LINE DEDENT"],"references":["def findIndex ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT a = 0 NEW_LINE b = 1 NEW_LINE c = 1 NEW_LINE res = 1 NEW_LINE while ( c < n ) : NEW_LINE INDENT c = a + b NEW_LINE res = res + 1 NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return res NEW_LINE DEDENT result = findIndex ( 21 ) NEW_LINE print ( result ) NEW_LINE"],"bleu":0.7741142017522032,"rouge_l":0.8576857305719172}
{"id":1456,"predictions":["def sumNth ( A , B , m , n ) : NEW_LINE INDENT res = 0 NEW_LINE if ( n == 1 ) : NEW_LINE INDENT for i in range ( m ) : NEW_LINE INDENT res = res + A [ i ] NEW_LINE DEDENT DEDENT elif ( n == 2 ) : NEW_LINE INDENT for i in range ( m ) : NEW_LINE INDENT res = res + B [ i ] * m NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT f = [ 0 ] * n NEW_LINE f [ 0 ] = 0 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT f [ i ] = f [ i - 1 ] + f [ i - 2 ] NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT res = res + ( m * ( B [ i ] * f [ n - 1 ] ) ) + ( m * ( A [ i ] * f [ n - 2 ] ) ) ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT A = [ 1 , 2 , 3 ] NEW_LINE B = [ 4 , 5 , 6 ] NEW_LINE n = len ( A ) NEW_LINE m = len ( A ) NEW_LINE print ( sumNth ( A , B , m , n ) ) NEW_LINE"],"references":["def sumNth ( A , B , m , n ) : NEW_LINE INDENT res = 0 ; NEW_LINE if ( n == 1 ) : NEW_LINE INDENT for i in range ( m ) : NEW_LINE INDENT res = res + A [ i ] ; NEW_LINE DEDENT DEDENT elif ( n == 2 ) : NEW_LINE INDENT for i in range ( m ) : NEW_LINE INDENT res = res + B [ i ] * m ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT f = [ 0 ] * n ; NEW_LINE f [ 0 ] = 0 ; NEW_LINE f [ 1 ] = 1 ; NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT f [ i ] = f [ i - 1 ] + f [ i - 2 ] ; NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT res = ( res + ( m * ( B [ i ] * f [ n - 1 ] ) ) + ( m * ( A [ i ] * f [ n - 2 ] ) ) ) ; NEW_LINE DEDENT DEDENT return res ; NEW_LINE DEDENT A = [ 1 , 2 , 3 ] ; NEW_LINE B = [ 4 , 5 , 6 ] ; NEW_LINE n = 3 ; NEW_LINE m = len ( A ) ; NEW_LINE print ( sumNth ( A , B , m , n ) ) ; NEW_LINE"],"bleu":0.8261589773508199,"rouge_l":0.9384615384615383}
{"id":1457,"predictions":["def isVowel ( c ) : NEW_LINE INDENT return ( c == ' a ' or c == ' e ' or c == ' E ' or c == ' E ' or c == ' i ' or c == ' O ' or c == ' O ' or c == ' O ' or c == ' O ' or c == ' u ' ) ; NEW_LINE DEDENT def reverseVowel ( Str ) : NEW_LINE INDENT j = 0 ; NEW_LINE for i in range ( len ( Str ) ) : NEW_LINE INDENT if ( isVowel ( Str [ i ] ) ) : NEW_LINE INDENT j += 1 ; NEW_LINE vowel += Str [ i ] ; NEW_LINE DEDENT DEDENT for i in range ( len ( Str ) ) : NEW_LINE INDENT if ( isVowel ( Str [ i ] ) ) : NEW_LINE INDENT Str [ i ] = vowel [ j ] ; NEW_LINE DEDENT DEDENT return \" \" . join ( Str ) ; NEW_LINE DEDENT Str = \" hello ▁ world \" ; NEW_LINE print ( reverseVowel ( Str ) ) ; NEW_LINE"],"references":["def isVowel ( c ) : NEW_LINE INDENT if ( c == ' a ' or c == ' A ' or c == ' e ' or c == ' E ' or c == ' i ' or c == ' I ' or c == ' o ' or c == ' O ' or c == ' u ' or c == ' U ' ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def reverserVowel ( string ) : NEW_LINE INDENT j = 0 NEW_LINE vowel = [ 0 ] * len ( string ) NEW_LINE string = list ( string ) NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if isVowel ( string [ i ] ) : NEW_LINE INDENT vowel [ j ] = string [ i ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT for i in range ( len ( string ) ) : NEW_LINE INDENT if isVowel ( string [ i ] ) : NEW_LINE INDENT j -= 1 NEW_LINE string [ i ] = vowel [ j ] NEW_LINE DEDENT DEDENT return ' ' . join ( string ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" hello ▁ world \" NEW_LINE print ( reverserVowel ( string ) ) NEW_LINE DEDENT"],"bleu":0.5176663870914817,"rouge_l":0.7260253202941399}
{"id":1458,"predictions":["def minimumCost ( cost , n ) : NEW_LINE INDENT dp1 = 0 NEW_LINE dp2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp0 = cost [ i ] + min ( dp1 , dp2 ) NEW_LINE dp2 = dp1 NEW_LINE dp1 = dp0 NEW_LINE DEDENT return min ( dp1 , dp2 ) NEW_LINE DEDENT a = [ 2 , 5 , 3 , 1 , 7 , 3 , 4 ] NEW_LINE n = len ( a ) NEW_LINE print ( minimumCost ( a , n ) ) NEW_LINE"],"references":["def minimumCost ( cost , n ) : NEW_LINE INDENT dp1 = 0 NEW_LINE dp2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp0 = cost [ i ] + min ( dp1 , dp2 ) NEW_LINE dp2 = dp1 NEW_LINE dp1 = dp0 NEW_LINE DEDENT return min ( dp1 , dp2 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 2 , 5 , 3 , 1 , 7 , 3 , 4 ] NEW_LINE n = len ( a ) NEW_LINE print ( minimumCost ( a , n ) ) NEW_LINE DEDENT"],"bleu":0.8490918135102224,"rouge_l":0.9199872995713605}
{"id":1459,"predictions":["N = 2 NEW_LINE def isVowel ( ch ) : NEW_LINE INDENT return ( ch == ' a ' or ch == ' e ' or ch == ' i ' or ch == ' o ' or ch == ' u ' ) NEW_LINE DEDENT def countVovels ( str , l , r ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if ( isVowel ( str [ i ] ) ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT def performQueries ( str , queries , q ) : NEW_LINE INDENT for i in range ( q ) : NEW_LINE INDENT print ( countVoowels ( str , queries [ i ] [ 0 ] , queries [ i ] [ 1 ] ) ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeksforgeeks \" ; NEW_LINE queries = [ [ 1 , 3 ] , [ 2 , 4 ] , [ 1 , 9 ] ] NEW_LINE q = len ( queries ) NEW_LINE performQueries ( str , queries , q ) NEW_LINE DEDENT"],"references":["N = 2 ; NEW_LINE def isVowel ( ch ) : NEW_LINE INDENT return ( ch == ' a ' or ch == ' e ' or ch == ' i ' or ch == ' o ' or ch == ' u ' ) ; NEW_LINE DEDENT def countVowels ( string , l , r ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if ( isVowel ( string [ i ] ) ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT return cnt ; NEW_LINE DEDENT def performQueries ( string , queries , q ) : NEW_LINE INDENT for i in range ( q ) : NEW_LINE INDENT print ( countVowels ( string , queries [ i ] [ 0 ] , queries [ i ] [ 1 ] ) ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" geeksforgeeks \" ; NEW_LINE queries = [ [ 1 , 3 ] , [ 2 , 4 ] , [ 1 , 9 ] ] ; NEW_LINE q = len ( queries ) NEW_LINE performQueries ( string , queries , q ) ; NEW_LINE DEDENT"],"bleu":0.8164167153352335,"rouge_l":0.9396296872568849}
{"id":1460,"predictions":["def removeAlternate ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return 2 * removeAlternate ( n \/ 2 ) - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 * removeAlternate ( ( int ( ( n \/ 2 ) \/ 2 ) ) + 1 ) + 1 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( removeAlternate ( n ) ) NEW_LINE n = 10 NEW_LINE print ( removeAlternate ( n ) ) NEW_LINE DEDENT"],"references":["def removeAlternate ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return 2 * removeAlternate ( n \/ 2 ) - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 * removeAlternate ( ( ( n - 1 ) \/ 2 ) ) + 1 NEW_LINE DEDENT DEDENT n = 5 NEW_LINE print ( removeAlternate ( n ) ) NEW_LINE n = 10 NEW_LINE print ( removeAlternate ( n ) ) NEW_LINE"],"bleu":0.7814556187062284,"rouge_l":0.9028952504879636}
{"id":1461,"predictions":["import math NEW_LINE def lowerWython ( n ) : NEW_LINE INDENT phi = ( 1 + math . sqrt ( 5 ) ) \/ 2.0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = floor ( i * phi ) NEW_LINE print ( ans ) NEW_LINE if ( i != n ) : NEW_LINE INDENT print ( \" , ▁ \" , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT n = 5 NEW_LINE lowerWython ( n ) NEW_LINE"],"references":["from math import sqrt , floor NEW_LINE def lowerWythoff ( n ) : NEW_LINE INDENT phi = ( 1 + sqrt ( 5 ) ) \/ 2 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = floor ( i * phi ) ; NEW_LINE print ( ans , end = \" \" ) ; NEW_LINE if ( i != n ) : NEW_LINE INDENT print ( \" , ▁ \" , end = \" \" ) ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 ; NEW_LINE lowerWythoff ( n ) ; NEW_LINE DEDENT"],"bleu":0.5552949433453382,"rouge_l":0.7889589905362776}
{"id":1462,"predictions":["def countPairs ( str ) : NEW_LINE INDENT result = 0 NEW_LINE n = len ( str ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( abs ( int ( str [ i ] ) ) == abs ( i - j ) ) : NEW_LINE INDENT result = result + 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT str = \" geeksforgeeks \" NEW_LINE print ( countPairs ( str ) ) NEW_LINE"],"references":["def countPairs ( str1 ) : NEW_LINE INDENT result = 0 ; NEW_LINE n = len ( str1 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( abs ( ord ( str1 [ i ] ) - ord ( str1 [ j ] ) ) == abs ( i - j ) ) : NEW_LINE INDENT result += 1 ; NEW_LINE DEDENT DEDENT DEDENT return result ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" geeksforgeeks \" ; NEW_LINE print ( countPairs ( str1 ) ) ; NEW_LINE DEDENT"],"bleu":0.5275384659296015,"rouge_l":0.7711060948081263}
{"id":1463,"predictions":["import math NEW_LINE def checkPowerof8 ( n ) : NEW_LINE INDENT i = math . log ( n , 8 ) ; NEW_LINE return ( i - math . floor ( i ) < 0.000001 ) ; NEW_LINE DEDENT n = 65 ; NEW_LINE if ( checkPowerof8 ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT"],"references":["from math import log , trunc NEW_LINE def checkPowerof8 ( n ) : NEW_LINE INDENT i = log ( n , 8 ) NEW_LINE return ( i - trunc ( i ) < 0.000001 ) ; NEW_LINE DEDENT n = 65 NEW_LINE if checkPowerof8 ( n ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.6801005527357299,"rouge_l":0.8832579185520363}
{"id":1464,"predictions":["def digitsNum ( N ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT print ( \"0\" ) NEW_LINE DEDENT if ( N % 9 != 0 ) : NEW_LINE INDENT print ( N % 9 ) NEW_LINE DEDENT for i in range ( 1 , ( int ( N \/ 9 ) ) + 1 ) : NEW_LINE INDENT print ( \"9\" , end = \" \" ) NEW_LINE DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( \"0\" , end = \" \" ) NEW_LINE DEDENT print ( \" \" ) NEW_LINE DEDENT N = 5 NEW_LINE print ( \" The ▁ number ▁ is ▁ : \" , end = \" \" ) NEW_LINE digitsNum ( N ) NEW_LINE"],"references":["import math NEW_LINE def digitsNum ( N ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT print ( \"0\" , end = \" \" ) NEW_LINE DEDENT if ( N % 9 != 0 ) : NEW_LINE INDENT print ( N % 9 , end = \" \" ) NEW_LINE DEDENT for i in range ( 1 , int ( N \/ 9 ) + 1 ) : NEW_LINE INDENT print ( \"9\" , end = \" \" ) NEW_LINE DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( \"0\" , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT N = 5 NEW_LINE print ( \" The ▁ number ▁ is ▁ : ▁ \" , end = \" \" ) NEW_LINE digitsNum ( N ) NEW_LINE"],"bleu":0.8542268698354408,"rouge_l":0.928714740941815}
{"id":1465,"predictions":["def printFirstNegInteger ( arr , n , k ) : NEW_LINE INDENT Di = [ ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT Di . append ( i ) NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( not Di ) : NEW_LINE INDENT print ( arr [ Di [ - 1 ] ] , end = \" ▁ \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \"0\" , end = \" ▁ \" ) ; NEW_LINE DEDENT while ( len ( Di ) != 0 and Di [ - 1 ] < ( i - k + 1 ) ) : NEW_LINE INDENT Di . pop ( ) ; NEW_LINE DEDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT Di . append ( i ) ; NEW_LINE DEDENT DEDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \"0\" , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 12 , - 1 , - 7 , 8 , - 15 , 30 , 16 , 28 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE k = 3 ; NEW_LINE printFirstNegativeInteger ( arr , n , k ) ; NEW_LINE DEDENT"],"references":["from collections import deque NEW_LINE def printFirstNegativeInteger ( arr , n , k ) : NEW_LINE INDENT Di = deque ( ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT Di . append ( i ) ; NEW_LINE DEDENT DEDENT for i in range ( k , n ) : NEW_LINE INDENT if ( not Di ) : NEW_LINE INDENT print ( 0 , end = ' ▁ ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ Di [ 0 ] ] , end = ' ▁ ' ) ; NEW_LINE DEDENT while Di and Di [ 0 ] <= ( i - k ) : NEW_LINE INDENT Di . popleft ( ) NEW_LINE DEDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT Di . append ( i ) ; NEW_LINE DEDENT DEDENT if not Di : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ Di [ 0 ] ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 12 , - 1 , - 7 , 8 , - 15 , 30 , 16 , 28 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE printFirstNegativeInteger ( arr , n , k ) ; NEW_LINE DEDENT"],"bleu":0.7116542598477148,"rouge_l":0.8262292977275646}
{"id":1466,"predictions":["def findFirstAndLast ( arr , n , x ) : NEW_LINE INDENT first , last = - 1 , - 1 NEW_LINE last = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( x != arr [ i ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( first == - 1 ) : NEW_LINE INDENT first = i NEW_LINE DEDENT last = i NEW_LINE DEDENT if ( first != - 1 ) : NEW_LINE INDENT print ( \" First ▁ Occurrence � = \" , first ) NEW_LINE print ( \" Last ▁ Occurrence ▁ = ▁ \" , last ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ Found \" ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 2 , 2 , 2 , 3 , 4 , 7 , 8 , 8 ] NEW_LINE x = 8 NEW_LINE findFirstAndLast ( arr , x ) NEW_LINE"],"references":["def findFirstAndLast ( arr , n , x ) : NEW_LINE INDENT first = - 1 NEW_LINE last = - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( x != arr [ i ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( first == - 1 ) : NEW_LINE INDENT first = i NEW_LINE DEDENT last = i NEW_LINE DEDENT if ( first != - 1 ) : NEW_LINE INDENT print ( \" First ▁ Occurrence ▁ = ▁ \" , first , \" ▁ \\n Last ▁ Occurrence ▁ = ▁ \" , last ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ Found \" ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 2 , 2 , 2 , 3 , 4 , 7 , 8 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE x = 8 NEW_LINE findFirstAndLast ( arr , n , x ) NEW_LINE"],"bleu":0.8553835072855841,"rouge_l":0.9172012830793908}
{"id":1467,"predictions":["NO_OF_CHARS = 256 NEW_LINE def areAnagrams ( str1 , str2 ) : NEW_LINE INDENT count = [ 0 for i in range ( NO_OF_CHARS ) ] NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT count [ ord ( str1 [ i ] ) ] += 1 NEW_LINE count [ ord ( str2 [ i ] ) ] -= 1 NEW_LINE DEDENT if ( len ( str1 ) != len ( str2 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( NO_OF_CHARS ) : NEW_LINE INDENT if ( count [ i ] != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def findAllAnagrams ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( areAnagram ( arr [ i ] , arr [ j ] ) ) : NEW_LINE INDENT print ( arr [ i ] , \" is ▁ anagram ▁ of \" , arr [ j ] ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ \" geeksqd \" , \" geeksforgeeks \" , \" geeksforgeeks \" , \" forgeeks \" , \" zuiqs \" ] NEW_LINE n = len ( arr ) NEW_LINE findAllAnagrams ( arr , n ) NEW_LINE DEDENT"],"references":["NO_OF_CHARS = 256 NEW_LINE def areAnagram ( str1 : str , str2 : str ) -> bool : NEW_LINE INDENT count = [ 0 ] * NO_OF_CHARS NEW_LINE i = 0 NEW_LINE while i < len ( str1 ) and i < len ( str2 ) : NEW_LINE INDENT count [ ord ( str1 [ i ] ) ] += 1 NEW_LINE count [ ord ( str2 [ i ] ) ] -= 1 NEW_LINE i += 1 NEW_LINE DEDENT if len ( str1 ) != len ( str2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( NO_OF_CHARS ) : NEW_LINE INDENT if count [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT DEDENT def findAllAnagrams ( arr : list , n : int ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if areAnagram ( arr [ i ] , arr [ j ] ) : NEW_LINE INDENT print ( arr [ i ] , \" is ▁ anagram ▁ of \" , arr [ j ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ \" geeksquiz \" , \" geeksforgeeks \" , \" abcd \" , \" forgeeksgeeks \" , \" zuiqkeegs \" ] NEW_LINE n = len ( arr ) NEW_LINE findAllAnagrams ( arr , n ) NEW_LINE DEDENT"],"bleu":0.7354431574117887,"rouge_l":0.8688663835347926}
{"id":1468,"predictions":["MAX = 100 NEW_LINE arr = [ 0 ] * MAX NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE arr [ i ] = 1 NEW_LINE for i in range ( 2 , MAX ) : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] + arr [ i - 2 ] NEW_LINE DEDENT print ( \" Fibonacci ▁ numbers ▁ divisible ▁ by ▁ indexes ▁ are ▁ \" ) NEW_LINE for i in range ( 1 , MAX ) : NEW_LINE INDENT if ( arr [ i ] % i == 0 ) : NEW_LINE INDENT print ( i , \" ▁ \" , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT"],"references":["if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT MAX = 100 NEW_LINE arr = [ 0 for i in range ( MAX ) ] NEW_LINE arr [ 0 ] = 0 NEW_LINE arr [ 1 ] = 1 NEW_LINE for i in range ( 2 , MAX ) : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] + arr [ i - 2 ] NEW_LINE DEDENT print ( \" Fibonacci ▁ numbers ▁ divisible ▁ by ▁ their ▁ indexes ▁ are ▁ : \" ) NEW_LINE for i in range ( 1 , MAX ) : NEW_LINE INDENT if ( arr [ i ] % i == 0 ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT"],"bleu":0.79507911692557,"rouge_l":0.8749540272158881}
{"id":1469,"predictions":["def isPossible ( Sx , Sy , Dx , Dx , dy , x , y ) : NEW_LINE INDENT if ( abs ( Sx - Dx ) % x == 0 and abs ( Sy - Dx ) % y == 0 and ( abs ( Sx - Dx ) \/\/ x ) % 2 == 0 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT Sx , Sy , Dx , dy , x , y = 0 , 0 , 0 , 3 , 4 NEW_LINE if ( isPossible ( Sx , sy , Dx , x , y ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def isPossible ( Sx , Sy , Dx , Dy , x , y ) : NEW_LINE INDENT if ( abs ( Sx - Dx ) % x == 0 and abs ( Sy - Dy ) % y == 0 and ( abs ( Sx - Dx ) \/ x ) % 2 == ( abs ( Sy - Dy ) \/ y ) % 2 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT Sx = 0 ; NEW_LINE Sy = 0 ; NEW_LINE Dx = 0 ; NEW_LINE Dy = 0 ; NEW_LINE x = 3 ; NEW_LINE y = 4 ; NEW_LINE if ( isPossible ( Sx , Sy , Dx , Dy , x , y ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT"],"bleu":0.5572038203928968,"rouge_l":0.7004390408645728}
{"id":1470,"predictions":["from math import sqrt NEW_LINE def isPerfectSquareString ( str ) : NEW_LINE INDENT sum = 0 NEW_LINE length = len ( str ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT sum += ord ( str [ i ] ) NEW_LINE DEDENT squareRoot = sqrt ( sum ) NEW_LINE return ( squareRoot - floor ( squareRoot ) ) == 0 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" d \" NEW_LINE if ( isPerfectSquare ( str ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["import math ; NEW_LINE def isPerfectSquareString ( str ) : NEW_LINE INDENT sum = 0 ; NEW_LINE l = len ( str ) ; NEW_LINE for i in range ( l ) : NEW_LINE INDENT sum = sum + ord ( str [ i ] ) ; NEW_LINE DEDENT squareRoot = math . sqrt ( sum ) ; NEW_LINE return ( ( squareRoot - math . floor ( squareRoot ) ) == 0 ) ; NEW_LINE DEDENT str = \" d \" ; NEW_LINE if ( isPerfectSquareString ( str ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT"],"bleu":0.6196313042436441,"rouge_l":0.8218692384059}
{"id":1471,"predictions":["def arePermutation ( str1 , str2 ) : NEW_LINE INDENT n1 = len ( str1 ) ; NEW_LINE n2 = len ( str2 ) ; NEW_LINE if ( n1 != n2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT ch1 = str1 . sort ( ) ; NEW_LINE ch2 . sort ( ) ; NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT if ( ch1 [ i ] != ch2 [ i ] ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" test \" ; NEW_LINE str2 = \" tt \" ; NEW_LINE if arePermutation ( str1 , str2 ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"],"references":["def arePermutation ( str1 , str2 ) : NEW_LINE INDENT n1 = len ( str1 ) NEW_LINE n2 = len ( str2 ) NEW_LINE if ( n1 != n2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT a = sorted ( str1 ) NEW_LINE str1 = \" ▁ \" . join ( a ) NEW_LINE b = sorted ( str2 ) NEW_LINE str2 = \" ▁ \" . join ( b ) NEW_LINE for i in range ( 0 , n1 , 1 ) : NEW_LINE INDENT if ( str1 [ i ] != str2 [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = \" test \" NEW_LINE str2 = \" ttew \" NEW_LINE if ( arePermutation ( str1 , str2 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.5911819997402912,"rouge_l":0.8208215297450424}
{"id":1472,"predictions":["def catalanDP ( n ) : NEW_LINE INDENT catalan = [ 1 for i in range ( n + 2 ) ] NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT catalan [ i ] = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT catalan [ i ] += ( catalan [ j ] * catalan [ i - j - 1 ] ) NEW_LINE DEDENT DEDENT return catalan [ n ] NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT print ( catalanDP ( i ) , end = \" ▁ \" ) NEW_LINE DEDENT"],"references":["def catalan ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT catalan = [ 0 for i in range ( n + 1 ) ] NEW_LINE catalan [ 0 ] = 1 NEW_LINE catalan [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT catalan [ i ] = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT catalan [ i ] = catalan [ i ] + catalan [ j ] * catalan [ i - j - 1 ] NEW_LINE DEDENT DEDENT return catalan [ n ] NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT print ( catalan ( i ) , end = \" ▁ \" ) NEW_LINE DEDENT"],"bleu":0.6186304647952097,"rouge_l":0.7902959481773149}
{"id":1473,"predictions":["def findGeometricTriplets ( arr , n ) : NEW_LINE INDENT for j in range ( 1 , n - 1 ) : NEW_LINE INDENT i = j - 1 NEW_LINE k = j + 1 NEW_LINE while ( i >= 0 and k <= n - 1 ) : NEW_LINE INDENT while ( i >= 0 and arr [ j ] % arr [ i ] == 0 and arr [ j ] % arr [ i ] == 0 and arr [ j ] \/\/ arr [ i ] == arr [ j ] ) : NEW_LINE INDENT print ( arr [ i ] , \" \" , arr [ j ] , \" ▁ \" , arr [ k ] ) NEW_LINE k += 1 NEW_LINE i -= 1 NEW_LINE DEDENT if ( i >= 0 and arr [ j ] % arr [ i ] == 0 and arr [ k ] % arr [ j ] == 0 ) : NEW_LINE INDENT if ( i >= 0 and arr [ j ] \/\/ arr [ i ] < arr [ k ] ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT k += 1 NEW_LINE DEDENT DEDENT elif ( i >= 0 and arr [ j ] % arr [ i ] == 0 ) : NEW_LINE INDENT k += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT arr = [ 1 , 2 , 4 , 16 ] NEW_LINE n = len ( arr ) NEW_LINE findGeometricTriplets ( arr , n ) NEW_LINE"],"references":["def findGeometricTriplets ( arr , n ) : NEW_LINE INDENT for j in range ( 1 , n - 1 ) : NEW_LINE INDENT i = j - 1 NEW_LINE k = j + 1 NEW_LINE while ( i >= 0 and k <= n - 1 ) : NEW_LINE INDENT while ( arr [ j ] % arr [ i ] == 0 and arr [ k ] % arr [ j ] == 0 and arr [ j ] \/\/ arr [ i ] == arr [ k ] \/\/ arr [ j ] ) : NEW_LINE INDENT print ( arr [ i ] , \" ▁ \" , arr [ j ] , \" ▁ \" , arr [ k ] ) NEW_LINE k += 1 NEW_LINE i -= 1 NEW_LINE DEDENT if ( arr [ j ] % arr [ i ] == 0 and arr [ k ] % arr [ j ] == 0 ) : NEW_LINE INDENT if ( arr [ j ] \/\/ arr [ i ] < arr [ k ] \/\/ arr [ j ] ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT k += 1 NEW_LINE DEDENT DEDENT elif ( arr [ j ] % arr [ i ] == 0 ) : NEW_LINE INDENT k += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 16 ] NEW_LINE n = len ( arr ) NEW_LINE findGeometricTriplets ( arr , n ) NEW_LINE DEDENT"],"bleu":0.8268946890446848,"rouge_l":0.8942330991034652}
{"id":1474,"predictions":["def fib ( n ) : NEW_LINE INDENT F = [ [ 1 , 1 ] , [ 1 , 0 ] ] NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT power ( F , n - 1 ) NEW_LINE return F [ 0 ] [ 0 ] NEW_LINE DEDENT def multiply ( F , M ) : NEW_LINE INDENT x = ( F [ 0 ] [ 0 ] * M [ 0 ] [ 0 ] + F [ 0 ] [ 1 ] * M [ 1 ] [ 0 ] ) NEW_LINE y = ( F [ 0 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 0 ] [ 1 ] * M [ 1 ] [ 1 ] ) NEW_LINE z = ( F [ 1 ] [ 0 ] * M [ 0 ] [ 0 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 0 ] ) NEW_LINE w = ( F [ 1 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 1 ] ) NEW_LINE w = ( F [ 1 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 1 ] ) NEW_LINE F [ 0 ] [ 0 ] = x NEW_LINE F [ 1 ] [ 1 ] = y NEW_LINE DEDENT def power ( F , n ) : NEW_LINE INDENT M = [ [ 1 , 1 ] , [ 1 , 0 ] NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT multiply ( F , M ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 9 NEW_LINE print ( fib ( n ) ) NEW_LINE DEDENT"],"references":["def fib ( n ) : NEW_LINE INDENT F = [ [ 1 , 1 ] , [ 1 , 0 ] ] NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT power ( F , n - 1 ) NEW_LINE return F [ 0 ] [ 0 ] NEW_LINE DEDENT def multiply ( F , M ) : NEW_LINE INDENT x = ( F [ 0 ] [ 0 ] * M [ 0 ] [ 0 ] + F [ 0 ] [ 1 ] * M [ 1 ] [ 0 ] ) NEW_LINE y = ( F [ 0 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 0 ] [ 1 ] * M [ 1 ] [ 1 ] ) NEW_LINE z = ( F [ 1 ] [ 0 ] * M [ 0 ] [ 0 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 0 ] ) NEW_LINE w = ( F [ 1 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 1 ] ) NEW_LINE F [ 0 ] [ 0 ] = x NEW_LINE F [ 0 ] [ 1 ] = y NEW_LINE F [ 1 ] [ 0 ] = z NEW_LINE F [ 1 ] [ 1 ] = w NEW_LINE DEDENT def power ( F , n ) : NEW_LINE INDENT M = [ [ 1 , 1 ] , [ 1 , 0 ] ] NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT multiply ( F , M ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 9 NEW_LINE print ( fib ( n ) ) NEW_LINE DEDENT"],"bleu":0.9234358840446403,"rouge_l":0.951384433147426}
{"id":1475,"predictions":["def largest_alphumeric ( a , n ) : NEW_LINE INDENT max = ' A ' NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] > max ) : NEW_LINE INDENT max = a [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT def smallest_alphumeric ( a , n ) : NEW_LINE INDENT min = ' z ' NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( a [ i ] < min ) : NEW_LINE INDENT min = a [ i ] NEW_LINE DEDENT DEDENT return min NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = \" GeEksforGeeks \" NEW_LINE size = len ( a ) NEW_LINE print ( \" Largest ▁ and ▁ smallest ▁ inverse ▁ is ▁ : ▁ \" , end = \" \" ) NEW_LINE print ( largest_alphumeric ( a , size ) , \" and \" , end = \" ▁ \" ) NEW_LINE DEDENT"],"references":["def largest_alphabet ( a , n ) : NEW_LINE INDENT max = ' A ' NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] > max ) : NEW_LINE INDENT max = a [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT def smallest_alphabet ( a , n ) : NEW_LINE INDENT min = ' z ' ; NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( a [ i ] < min ) : NEW_LINE INDENT min = a [ i ] NEW_LINE DEDENT DEDENT return min NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = \" GeEksforGeeks \" NEW_LINE size = len ( a ) NEW_LINE print ( \" Largest ▁ and ▁ smallest ▁ alphabet ▁ is ▁ : ▁ \" , end = \" \" ) NEW_LINE print ( largest_alphabet ( a , size ) , end = \" ▁ and ▁ \" ) NEW_LINE print ( smallest_alphabet ( a , size ) ) NEW_LINE DEDENT"],"bleu":0.8607807970906552,"rouge_l":0.925763393673432}
{"id":1476,"predictions":["def Check_is_possible ( l , r , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if ( i % k == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return ( count > 1 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT l , r , k = 4 , 12 NEW_LINE if Check_is_possible ( l , r , k ) == True : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"references":["def Check_is_possible ( l , r , k ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if ( i % k == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return ( count > 1 ) ; NEW_LINE DEDENT l = 4 ; NEW_LINE r = 12 ; NEW_LINE k = 5 ; NEW_LINE if ( Check_is_possible ( l , r , k ) ) : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE DEDENT"],"bleu":0.6901335230043318,"rouge_l":0.8315305971255001}
{"id":1477,"predictions":["def pushZerosToEnd ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] != 0 ) : NEW_LINE INDENT arr [ count ] = arr [ i ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT while ( count < n ) : NEW_LINE INDENT arr [ count ] = 0 NEW_LINE count += 1 NEW_LINE DEDENT DEDENT arr = [ 1 , 9 , 8 , 4 , 0 , 2 , 7 , 0 , 6 , 0 , 9 ] NEW_LINE n = len ( arr ) ; NEW_LINE pushZerosToEnd ( arr , n ) ; NEW_LINE print ( \" Array ▁ after ▁ pushed ▁ zeros ▁ to ▁ the ▁ back : ▁ \" , end = \" ▁ \" ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT"],"references":["def pushZerosToEnd ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] != 0 : NEW_LINE INDENT arr [ count ] = arr [ i ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT while count < n : NEW_LINE INDENT arr [ count ] = 0 NEW_LINE count += 1 NEW_LINE DEDENT DEDENT arr = [ 1 , 9 , 8 , 4 , 0 , 0 , 2 , 7 , 0 , 6 , 0 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE pushZerosToEnd ( arr , n ) NEW_LINE print ( \" Array ▁ after ▁ pushing ▁ all ▁ zeros ▁ to ▁ end ▁ of ▁ array : \" ) NEW_LINE print ( arr ) NEW_LINE"],"bleu":0.6659228854563086,"rouge_l":0.8587883959044369}
{"id":1478,"predictions":["def check ( s , k ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] != s [ i % k ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def countCommonDivisors ( a , b ) : NEW_LINE INDENT ct = 0 NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE for i in range ( 1 , min ( n , m ) ) : NEW_LINE INDENT if ( n % i == 0 and m % i == 0 ) : NEW_LINE INDENT if ( check ( a , i ) and check ( b , i ) ) : NEW_LINE INDENT ct += 1 NEW_LINE DEDENT DEDENT DEDENT return ct NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = \" xaxa \" NEW_LINE b = \" xaxa \" NEW_LINE print ( countCommonDivisors ( a , b ) ) NEW_LINE DEDENT"],"references":["def check ( s , k ) : NEW_LINE INDENT for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] != s [ i % k ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def countCommonDivisors ( a , b ) : NEW_LINE INDENT ct = 0 NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE for i in range ( 1 , min ( n , m ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 and m % i == 0 ) : NEW_LINE INDENT if ( a [ 0 : i ] == b [ 0 : i ] ) : NEW_LINE INDENT if ( check ( a , i ) and check ( b , i ) ) : NEW_LINE INDENT ct = ct + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return ct NEW_LINE DEDENT a = \" xaxa \" NEW_LINE b = \" xaxaxaxa \" NEW_LINE print ( countCommonDivisors ( a , b ) ) NEW_LINE"],"bleu":0.8206288142771284,"rouge_l":0.8746103838275892}
{"id":1479,"predictions":["n = 4562 ; NEW_LINE rev = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT a = n % 10 NEW_LINE rev = rev * 10 + a NEW_LINE n = n \/\/ 10 NEW_LINE DEDENT print ( rev ) NEW_LINE"],"references":["n = 4562 ; NEW_LINE rev = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT a = n % 10 NEW_LINE rev = rev * 10 + a NEW_LINE n = n \/\/ 10 NEW_LINE DEDENT print ( rev ) NEW_LINE"],"bleu":1.0,"rouge_l":1.0}
{"id":1480,"predictions":["def center_nonadecagon_num ( n ) : NEW_LINE INDENT return ( 19 * n * n - 19 * n + 2 ) \/\/ 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 2 NEW_LINE print ( n , \" th ▁ centered ▁ non ▁ non ▁ number ▁ : ▁ \" , center_nonadecagonal_num ( n ) ) NEW_LINE n = 7 NEW_LINE print ( n , \" th ▁ centered ▁ unadecagonal ▁ \" + \" number ▁ : ▁ \" , center_nonadecagon_num ( n ) ) NEW_LINE DEDENT"],"references":["def center_nonadecagon_num ( n ) : NEW_LINE INDENT return ( 19 * n * n - 19 * n + 2 ) \/\/ 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 2 NEW_LINE print ( n , \" nd ▁ centered ▁ nonadecagonal ▁ \" + \" number ▁ : ▁ \" , center_nonadecagon_num ( n ) ) NEW_LINE n = 7 NEW_LINE print ( n , \" nd ▁ centered ▁ nonadecagonal ▁ \" + \" number ▁ : ▁ \" , center_nonadecagon_num ( n ) ) NEW_LINE DEDENT"],"bleu":0.8337401431725675,"rouge_l":0.9237860082304526}
{"id":1481,"predictions":["def countkDist ( str , k ) : NEW_LINE INDENT res = 0 NEW_LINE n = len ( str ) NEW_LINE cnt = [ 0 for i in range ( 26 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT dist_count = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if ( cnt [ ord ( str [ j ] ) - ord ( ' a ' ) ] == 0 ) : NEW_LINE INDENT dist_count += 1 NEW_LINE DEDENT cnt [ ord ( str [ j ] ) - ord ( ' a ' ) ] += 1 NEW_LINE if ( dist_count == k ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT ch = \" abcbaa \" NEW_LINE k = 3 NEW_LINE print ( \" Total ▁ substrings ▁ with \" , k , \" distinct ▁ characters ▁ : ▁ \" , countkDist ( ch , k ) ) NEW_LINE DEDENT"],"references":["def countkDist ( str1 , k ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE res = 0 NEW_LINE cnt = [ 0 ] * 27 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT dist_count = 0 NEW_LINE cnt = [ 0 ] * 27 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if ( cnt [ ord ( str1 [ j ] ) - 97 ] == 0 ) : NEW_LINE INDENT dist_count += 1 NEW_LINE DEDENT cnt [ ord ( str1 [ j ] ) - 97 ] += 1 NEW_LINE if ( dist_count == k ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT if ( dist_count > k ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" abcbaa \" NEW_LINE k = 3 NEW_LINE print ( \" Total ▁ substrings ▁ with ▁ exactly \" , k , \" distinct ▁ characters ▁ : ▁ \" , end = \" \" ) NEW_LINE print ( countkDist ( str1 , k ) ) NEW_LINE DEDENT"],"bleu":0.6424014440097402,"rouge_l":0.7874309978768579}
{"id":1482,"predictions":["def percent ( n , x ) : NEW_LINE INDENT p = n * x NEW_LINE p \/= 100 NEW_LINE return p NEW_LINE DEDENT def getLoss ( price , quantity , X , n ) : NEW_LINE INDENT loss = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT originalPrice = price [ i ] NEW_LINE sellingPrice = originalPrice + percent ( ord ( originalPrice , X [ i ] ) ) NEW_LINE afterMinProduct = sellingPrice - percent ( ord ( sellingPrice ) ) NEW_LINE loss += ( ( originalPrice , X [ i ] ) NEW_LINE DEDENT return loss NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT price = [ 20 , 48 , 200 , 100 ] NEW_LINE probability = [ 20 , 48 , 1 , 1 , 1 ] NEW_LINE X = [ 0 , 48 , 200 , 5 ] NEW_LINE n = len ( X ) NEW_LINE print ( getLoss ( prices , Quantity , X , n ) ) NEW_LINE DEDENT"],"references":["def percent ( n , x ) : NEW_LINE INDENT p = ( int ) ( n ) * x ; NEW_LINE p \/= 100 ; NEW_LINE return p ; NEW_LINE DEDENT def getLoss ( price , quantity , X , n ) : NEW_LINE INDENT loss = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT originalPrice = price [ i ] ; NEW_LINE sellingPrice = originalPrice + percent ( originalPrice , X [ i ] ) ; NEW_LINE afterDiscount = sellingPrice - percent ( sellingPrice , X [ i ] ) ; NEW_LINE loss += ( ( originalPrice - afterDiscount ) * quantity [ i ] ) ; NEW_LINE DEDENT return round ( loss , 2 ) ; NEW_LINE DEDENT price = [ 20 , 48 , 200 , 100 ] ; NEW_LINE quantity = [ 20 , 48 , 1 , 1 ] ; NEW_LINE X = [ 0 , 48 , 200 , 5 ] ; NEW_LINE n = len ( X ) ; NEW_LINE print ( getLoss ( price , quantity , X , n ) ) ; NEW_LINE"],"bleu":0.632404196036381,"rouge_l":0.815653414155821}
{"id":1483,"predictions":["def minCost ( s ) : NEW_LINE INDENT alphabets = [ False ] * 26 ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT alphabets [ ord ( s [ i ] ) - 97 ] = True ; NEW_LINE DEDENT count = 0 ; NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( alphabets [ i ] ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" geeksforgeeks \" ; NEW_LINE print ( \" Total ▁ cost ▁ to ▁ construct \" , s , \" is \" , minCost ( s ) ) ; NEW_LINE DEDENT"],"references":["def minCost ( s ) : NEW_LINE INDENT alphabets = [ False for i in range ( 26 ) ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT alphabets [ ord ( s [ i ] ) - 97 ] = True NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( alphabets [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" geeksforgeeks \" NEW_LINE print ( \" Total ▁ cost ▁ to ▁ construct \" , s , \" is \" , minCost ( s ) ) NEW_LINE DEDENT"],"bleu":0.8040236270057998,"rouge_l":0.9237719521506743}
{"id":1484,"predictions":["import math NEW_LINE def nextPowerOfFour ( n ) : NEW_LINE INDENT x = math . floor ( math . sqrt ( math . sqrt ( n ) ) ) NEW_LINE if ( x ** 4 == n ) : NEW_LINE INDENT return n NEW_LINE DEDENT else : NEW_LINE INDENT x = x + 1 NEW_LINE return pow ( x , 4 ) NEW_LINE DEDENT DEDENT n = 122 NEW_LINE print ( nextPowerOfFour ( n ) ) NEW_LINE"],"references":["import math NEW_LINE def nextPowerOfFour ( n ) : NEW_LINE INDENT x = math . floor ( ( n ** ( 1 \/ 2 ) ) ** ( 1 \/ 2 ) ) ; NEW_LINE if ( ( x ** 4 ) == n ) : NEW_LINE INDENT return n ; NEW_LINE DEDENT else : NEW_LINE INDENT x = x + 1 ; NEW_LINE return ( x ** 4 ) ; NEW_LINE DEDENT DEDENT n = 122 ; NEW_LINE print ( nextPowerOfFour ( n ) ) ; NEW_LINE"],"bleu":0.5721365717292195,"rouge_l":0.8144512075397605}
{"id":1485,"predictions":["def findCost ( s1 , s2 , a , b , c , d , n ) : NEW_LINE INDENT cost = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s1 [ i ] == s2 [ i ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT if ( ( s1 [ i ] == '1' and s2 [ i ] == '2' ) or ( s2 [ i ] == '1' and s1 [ i ] == '2' ) ) : NEW_LINE INDENT cost += min ( d , b + c ) ) NEW_LINE DEDENT elif ( ( s1 [ i ] == '2' and s2 [ i ] == '3' ) or ( s2 [ i ] == '2' and s1 [ i ] == '3' ) ) : NEW_LINE INDENT cost += min ( d , min ( b , a + c ) ) NEW_LINE DEDENT elif ( ( s1 [ i ] == '1' and s2 [ i ] == '1' and s1 [ i ] == '3' ) or ( s2 [ i ] == '1' and s1 [ i ] == '3' ) ) : NEW_LINE INDENT cost += min ( d , min ( c , a + b ) ) NEW_LINE DEDENT DEDENT return cost NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s1 = \"121\" NEW_LINE s2 = \"223\" NEW_LINE a = 2 NEW_LINE b = 3 NEW_LINE c = 4 NEW_LINE d = 10 NEW_LINE n = len ( s1 ) NEW_LINE print ( findCost ( s1 , s2 , a , b , c , d , n ) ) NEW_LINE DEDENT"],"references":["def findCost ( s1 , s2 , a , b , c , d , n ) : NEW_LINE INDENT cost = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s1 [ i ] == s2 [ i ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT if ( ( s1 [ i ] == '1' and s2 [ i ] == '2' ) or ( s2 [ i ] == '1' and s1 [ i ] == '2' ) ) : NEW_LINE INDENT cost += min ( d , min ( a , b + c ) ) NEW_LINE DEDENT elif ( ( s1 [ i ] == '2' and s2 [ i ] == '3' ) or ( s2 [ i ] == '2' and s1 [ i ] == '3' ) ) : NEW_LINE INDENT cost += min ( d , min ( b , a + c ) ) NEW_LINE DEDENT elif ( ( s1 [ i ] == '1' and s2 [ i ] == '3' ) or ( s2 [ i ] == '1' and s1 [ i ] == '3' ) ) : NEW_LINE INDENT cost += min ( d , min ( c , a + b ) ) NEW_LINE DEDENT DEDENT DEDENT return cost NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s1 = \"121\" NEW_LINE s2 = \"223\" NEW_LINE a = 2 NEW_LINE b = 3 NEW_LINE c = 4 NEW_LINE d = 10 NEW_LINE n = len ( s1 ) NEW_LINE print ( findCost ( s1 , s2 , a , b , c , d , n ) ) NEW_LINE DEDENT"],"bleu":0.972436401701612,"rouge_l":0.9799196787148592}
{"id":1486,"predictions":["def Twentyonematch ( arr , N ) : NEW_LINE INDENT for i in range ( 0 , N ) : NEW_LINE INDENT print ( 5 - arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 4 , 2 , 2 ] NEW_LINE N = len ( arr ) NEW_LINE Twentyonematch ( arr , N ) NEW_LINE DEDENT"],"references":["def TwentyoneMatchstick ( arr , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT print ( 5 - arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 3 , 4 , 2 , 2 ] NEW_LINE N = len ( arr ) NEW_LINE TwentyoneMatchstick ( arr , N ) NEW_LINE"],"bleu":0.6618724428509128,"rouge_l":0.8587647593097184}
{"id":1487,"predictions":["def Perimeter ( s , n ) : NEW_LINE INDENT perimeter = 1 NEW_LINE perimeter = n * s NEW_LINE return perimeter NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE s = 2.5 NEW_LINE peri = Perimeter ( s , n ) NEW_LINE print ( \" Perimeter ▁ of ▁ Regular ▁ Polygon ▁ with ▁ length \" + \" ▁ sides ▁ of ▁ length ▁ \" , s , \" ▁ = ▁ \" , peri ) NEW_LINE DEDENT"],"references":["def Perimeter ( s , n ) : NEW_LINE INDENT perimeter = 1 NEW_LINE perimeter = n * s NEW_LINE return perimeter NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE s = 2.5 NEW_LINE peri = Perimeter ( s , n ) NEW_LINE print ( \" Perimeter ▁ of ▁ Regular ▁ Polygon ▁ with \" , n , \" sides ▁ of ▁ length \" , s , \" = \" , peri ) NEW_LINE DEDENT"],"bleu":0.8531520239389069,"rouge_l":0.9482443306510608}
{"id":1488,"predictions":["def checkPalindrome ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE count = 0 NEW_LINE for i in range ( n \/\/ 2 ) : NEW_LINE INDENT if ( str [ i ] != str [ n - i - 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return ( count <= 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" abccaa \" NEW_LINE if ( checkPalindrome ( str ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def checkPalindrome ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE count = 0 NEW_LINE for i in range ( 0 , int ( n \/ 2 ) ) : NEW_LINE INDENT if ( str [ i ] != str [ n - i - 1 ] ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT if ( count <= 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT str = \" abccaa \" NEW_LINE if ( checkPalindrome ( str ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.7519960064405372,"rouge_l":0.8465167915625869}
{"id":1489,"predictions":["def getSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT sum = sum + n % 10 NEW_LINE n = n \/\/ 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT def largestDigitSumdivisior ( n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT res = max ( res , getSum ( i ) ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT n = 14 NEW_LINE print ( largestDigitSumdivisior ( n ) ) NEW_LINE"],"references":["def getSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while n != 0 : NEW_LINE INDENT sum = sum + n % 10 NEW_LINE n = int ( n \/ 10 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT def largestDigitSumdivisior ( n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT res = max ( res , getSum ( i ) ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT n = 14 NEW_LINE print ( largestDigitSumdivisior ( n ) ) NEW_LINE"],"bleu":0.8722811418346215,"rouge_l":0.9585580033893082}
{"id":1490,"predictions":["def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def lcm ( n , m ) : NEW_LINE INDENT return ( n * m ) \/ gcd ( n , m ) ) NEW_LINE DEDENT n = 2 NEW_LINE m = 3 NEW_LINE k = 5 NEW_LINE print ( int ( k \/ lcm ( n , m ) ) ) NEW_LINE"],"references":["def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b ; NEW_LINE DEDENT return gcd ( b % a , a ) ; NEW_LINE DEDENT def lcm ( n , m ) : NEW_LINE INDENT return ( n * m ) \/\/ gcd ( n , m ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 2 ; m = 3 ; k = 5 ; NEW_LINE print ( k \/\/ lcm ( n , m ) ) ; NEW_LINE DEDENT"],"bleu":0.6143011967935346,"rouge_l":0.8241833418847273}
{"id":1491,"predictions":["import math as mt NEW_LINE def checkPrime ( number ) : NEW_LINE INDENT num = int ( number ) NEW_LINE for i in range ( 2 , mt . ceil ( number ) ) + 1 ) : NEW_LINE INDENT if ( not num % i ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT def splitIntoPrimes ( number ) : NEW_LINE INDENT if ( len ( number ) == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( len ( number ) <= 6 and checkPrime ( number ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT numLen = len ( number ) NEW_LINE ans = 1000000 NEW_LINE for i in range ( 1 , num + 1 ) : NEW_LINE INDENT if ( checkPrime ( number [ 0 : i ] ) ) : NEW_LINE INDENT val = splitIntoPrimes ( number [ i ] ) NEW_LINE if ( val != - 1 ) : NEW_LINE INDENT ans = min ( ans , 1 + val ) NEW_LINE DEDENT DEDENT DEDENT if ( ans == 1000000 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( splitIntoPrimes ( \"13499315\" ) ) NEW_LINE print ( splitIntoPrimes ( \"43\" ) ) NEW_LINE DEDENT"],"references":["def checkPrime ( number ) : NEW_LINE INDENT num = int ( number ) NEW_LINE for i in range ( 2 , int ( num ** 0.5 ) ) : NEW_LINE INDENT if ( ( num % i ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def splitIntoPrimes ( number ) : NEW_LINE INDENT if ( number == ' ' ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( len ( number ) <= 6 and checkPrime ( number ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT numLen = len ( number ) NEW_LINE ans = 1000000 NEW_LINE for i in range ( 1 , ( min ( 6 , numLen ) + 1 ) ) : NEW_LINE INDENT if ( checkPrime ( number [ : i ] ) ) : NEW_LINE INDENT val = splitIntoPrimes ( number [ i : ] ) NEW_LINE if ( val != - 1 ) : NEW_LINE INDENT ans = min ( ans , 1 + val ) NEW_LINE DEDENT DEDENT DEDENT if ( ans == 1000000 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT print ( splitIntoPrimes ( \"13499315\" ) ) NEW_LINE print ( splitIntoPrimes ( \"43\" ) ) NEW_LINE"],"bleu":0.7901063161204386,"rouge_l":0.8770830261023448}
{"id":1492,"predictions":["def findKthChar ( s , k ) : NEW_LINE INDENT l = len ( s ) NEW_LINE i = 0 NEW_LINE total_len = 0 NEW_LINE while ( i < l ) : NEW_LINE INDENT if ( s [ i ] == \" \" ) : NEW_LINE INDENT total_len += 1 NEW_LINE if ( total_len == k ) : NEW_LINE INDENT return s [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT n = 0 NEW_LINE while ( i < l and not ( s [ i ] ) ) : NEW_LINE INDENT n = n * 10 + ( ord ( s [ i ] ) - ord ( '0' ) ) NEW_LINE i += 1 NEW_LINE DEDENT next_total_len = total_len * n NEW_LINE if ( k <= next_len ) : NEW_LINE INDENT pos = total_len NEW_LINE DEDENT return findKthChar ( s , pos ) NEW_LINE DEDENT else : NEW_LINE INDENT total_len = next_total_len NEW_LINE DEDENT DEDENT return ' ▁ ' . join ( s , k ) ) NEW_LINE DEDENT s = \" ab2c3\" NEW_LINE k = 5 NEW_LINE print ( findKthChar ( s , k ) ) NEW_LINE"],"references":["def findKthChar ( s , k ) : NEW_LINE INDENT len1 = len ( s ) NEW_LINE i = 0 NEW_LINE total_len = 0 NEW_LINE while ( i < len1 ) : NEW_LINE INDENT if ( s [ i ] . isalpha ( ) ) : NEW_LINE INDENT total_len += 1 NEW_LINE if ( total_len == k ) : NEW_LINE INDENT return s [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT n = 0 NEW_LINE while ( i < len1 and s [ i ] . isalpha ( ) == False ) : NEW_LINE INDENT n = n * 10 + ( ord ( s [ i ] ) - ord ( '0' ) ) NEW_LINE i += 1 NEW_LINE DEDENT next_total_len = total_len * n NEW_LINE if ( k <= next_total_len ) : NEW_LINE INDENT pos = k % total_len NEW_LINE if ( pos == 0 ) : NEW_LINE INDENT pos = total_len NEW_LINE DEDENT return findKthChar ( s , pos ) NEW_LINE DEDENT else : NEW_LINE INDENT total_len = next_total_len NEW_LINE DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" ab2c3\" NEW_LINE k = 5 NEW_LINE print ( findKthChar ( s , k ) ) NEW_LINE DEDENT"],"bleu":0.7416339165067075,"rouge_l":0.8390777647518562}
{"id":1493,"predictions":["def Nth_Term ( N ) : NEW_LINE INDENT return ( 2 * pow ( n , 3 ) - 3 * pow ( n , 2 ) + n + 6 ) \/ 6 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 8 NEW_LINE print ( Nth_Term ( N ) ) NEW_LINE DEDENT"],"references":["def Nth_Term ( n ) : NEW_LINE INDENT return ( 2 * pow ( n , 3 ) - 3 * pow ( n , 2 ) + n + 6 ) \/\/ 6 NEW_LINE DEDENT N = 8 NEW_LINE print ( Nth_Term ( N ) ) NEW_LINE"],"bleu":0.6627830757687935,"rouge_l":0.8560097620500304}
{"id":1494,"predictions":["def solve ( A , B , C ) : NEW_LINE INDENT i = len ( A ) - 1 NEW_LINE j = len ( B ) - 1 NEW_LINE k = len ( C ) - 1 NEW_LINE min_term = abs ( max ( A [ i ] , max ( B [ j ] , C [ k ] ) ) - min ( A [ i ] , C [ k ] ) ) NEW_LINE while ( i != - 1 and j != - 1 and k != - 1 ) : NEW_LINE INDENT current_diff = abs ( max ( A [ i ] , max ( B [ j ] , C [ k ] ) ) - min ( A [ i ] , C [ k ] ) ) NEW_LINE if ( current_diff < min_diff ) : NEW_LINE INDENT min_diff = current_diff NEW_LINE DEDENT max_term = max ( A [ i ] , max ( B [ j ] , C [ k ] ) ) NEW_LINE if ( A [ i ] == max_term ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT elif ( B [ j ] == max_term ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT DEDENT return min_diff NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT DEDENT DEDENT"],"references":["def solve ( A , B , C ) : NEW_LINE INDENT i = len ( A ) - 1 NEW_LINE j = len ( B ) - 1 NEW_LINE k = len ( C ) - 1 NEW_LINE min_diff = abs ( max ( A [ i ] , B [ j ] , C [ k ] ) - min ( A [ i ] , B [ j ] , C [ k ] ) ) NEW_LINE while i != - 1 and j != - 1 and k != - 1 : NEW_LINE INDENT current_diff = abs ( max ( A [ i ] , B [ j ] , C [ k ] ) - min ( A [ i ] , B [ j ] , C [ k ] ) ) NEW_LINE if current_diff < min_diff : NEW_LINE INDENT min_diff = current_diff NEW_LINE DEDENT max_term = max ( A [ i ] , B [ j ] , C [ k ] ) NEW_LINE if A [ i ] == max_term : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT elif B [ j ] == max_term : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT DEDENT return min_diff NEW_LINE DEDENT A = [ 5 , 8 , 10 , 15 ] NEW_LINE B = [ 6 , 9 , 15 , 78 , 89 ] NEW_LINE C = [ 2 , 3 , 6 , 6 , 8 , 8 , 10 ] NEW_LINE print ( solve ( A , B , C ) ) NEW_LINE"],"bleu":0.6730273338288186,"rouge_l":0.7974618965627193}
{"id":1495,"predictions":["_MIN = - 2147483648 NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . left = None NEW_LINE DEDENT DEDENT def CheckPerfectTree ( root ) : NEW_LINE INDENT q = [ ] NEW_LINE q . append ( root ) NEW_LINE flag = 0 NEW_LINE while ( len ( q ) ) : NEW_LINE INDENT temp = q [ 0 ] NEW_LINE q . pop ( 0 ) NEW_LINE if ( temp . left and temp . right ) : NEW_LINE INDENT if ( flag == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE DEDENT DEDENT elif ( temp . left and temp . right ) : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT elif ( temp . left and temp . right ) : NEW_LINE INDENT return False NEW_LINE DEDENT elif ( temp . left and temp . right ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 7 ) NEW_LINE root . left = newNode ( 5 ) NEW_LINE root . right = newNode ( 6 ) NEW_LINE root . left . left = newNode ( 6 ) NEW_LINE root . left . left = newNode ( 8 ) NEW_LINE root . left . left = newNode ( 1 ) NEW_LINE root . left . left = newNode ( 2 ) NEW_LINE root . right . left = newNode ( 3 ) NEW_LINE root . right . left = newNode ( 13 ) NEW_LINE if CheckPerfectTree ( root ) : NEW_LINE INDENT print \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["import sys NEW_LINE import math NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def newNode ( data ) : NEW_LINE INDENT return Node ( data ) NEW_LINE DEDENT def CheckPerfectTree ( root ) : NEW_LINE INDENT q = [ ] NEW_LINE q . append ( root ) NEW_LINE flag = 0 NEW_LINE while ( q ) : NEW_LINE INDENT temp = q [ 0 ] NEW_LINE q . pop ( 0 ) NEW_LINE if ( temp . left and temp . right ) : NEW_LINE INDENT if ( flag == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE q . append ( temp . right ) NEW_LINE DEDENT DEDENT elif ( not temp . left and not temp . right ) : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT elif ( not temp . left or not temp . right ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 7 ) NEW_LINE root . left = newNode ( 5 ) NEW_LINE root . left . left = newNode ( 8 ) NEW_LINE root . left . right = newNode ( 1 ) NEW_LINE root . right = newNode ( 6 ) NEW_LINE root . right . left = newNode ( 3 ) NEW_LINE root . right . right = newNode ( 9 ) NEW_LINE root . right . right . left = newNode ( 10 ) NEW_LINE root . right . right . right = newNode ( 13 ) NEW_LINE if CheckPerfectTree ( root ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.8190086274400135,"rouge_l":0.8551401869158879}
{"id":1496,"predictions":["def generateNumber ( count , a , n , num , k ) : NEW_LINE INDENT if ( count == k ) : NEW_LINE INDENT set = set ( ) NEW_LINE return NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT generateNumber ( count + 1 , a , n , num + a [ i ] , k ) NEW_LINE DEDENT DEDENT def printDistinctIntegers ( k , a , n ) : NEW_LINE INDENT generateNumber ( 0 , a , n , 0 , k ) NEW_LINE print ( \" The ▁ \" , len ( set ) , len ( set ) ) NEW_LINE print ( \" The ▁ \" , len ( set ) , \" distinct ▁ integers ▁ are : \" ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 8 , 17 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE printDistinctIntegers ( k , arr , n ) NEW_LINE DEDENT"],"references":["s = set ( ) NEW_LINE def generateNumber ( count , a , n , num , k ) : NEW_LINE INDENT if k == count : NEW_LINE INDENT s . add ( num ) NEW_LINE return NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT generateNumber ( count + 1 , a , n , num + a [ i ] , k ) NEW_LINE DEDENT DEDENT def printDistinctIntegers ( k , a , n ) : NEW_LINE INDENT generateNumber ( 0 , a , n , 0 , k ) NEW_LINE print ( \" The \" , len ( s ) , \" distinct ▁ integers ▁ are : \" ) NEW_LINE for i in sorted ( s ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 3 , 8 , 17 , 5 ] NEW_LINE n , k = len ( a ) , 2 NEW_LINE printDistinctIntegers ( k , a , n ) NEW_LINE DEDENT"],"bleu":0.7437553581990634,"rouge_l":0.8012069577564784}
{"id":1497,"predictions":["import math NEW_LINE def findMin ( a , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += math . log ( a [ i ] ) ; NEW_LINE DEDENT x = exp ( sum \/ n ) ; NEW_LINE return x + 1 ; NEW_LINE DEDENT a = [ 3 , 2 , 1 , 4 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( findMin ( a , n ) ) ; NEW_LINE"],"references":["import math as m NEW_LINE def findMin ( a , n ) : NEW_LINE INDENT _sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT _sum += m . log ( a [ i ] ) NEW_LINE DEDENT x = m . exp ( _sum \/ n ) NEW_LINE return int ( x + 1 ) NEW_LINE DEDENT a = [ 3 , 2 , 1 , 4 ] NEW_LINE n = len ( a ) NEW_LINE print ( findMin ( a , n ) ) NEW_LINE"],"bleu":0.6566348690449886,"rouge_l":0.8791208791208791}
{"id":1498,"predictions":["def printPaths ( input , R , C ) : NEW_LINE INDENT for i in range ( C ) : NEW_LINE INDENT dfs ( input , 0 , i , R , C ) NEW_LINE print ( ) NEW_LINE return NEW_LINE DEDENT DEDENT def dfs ( input , res , i , j , R , C ) : NEW_LINE INDENT if ( i == R ) : NEW_LINE INDENT print ( res , end = \" ▁ \" ) NEW_LINE return NEW_LINE DEDENT res = res + input [ i ] [ j ] NEW_LINE for k in range ( C ) : NEW_LINE INDENT dfs ( input , res , i + 1 , k , R , C ) NEW_LINE if ( i + 1 == R ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT input = [ [ ' a ' , ' b ' ] , [ ' d ' , ' e ' ] NEW_LINE R = len ( input ) NEW_LINE C = len ( input ) NEW_LINE printPaths ( input , R , C ) NEW_LINE DEDENT"],"references":["def printPaths ( inputchar , R , C ) : NEW_LINE INDENT for i in range ( C ) : NEW_LINE INDENT dfs ( inputchar , \" \" , 0 , i , R , C ) ; NEW_LINE print ( ) NEW_LINE DEDENT DEDENT def dfs ( inputchar , res , i , j , R , C ) : NEW_LINE INDENT if ( i == R ) : NEW_LINE INDENT print ( res , end = \" ▁ \" ) ; NEW_LINE return ; NEW_LINE DEDENT res = res + inputchar [ i ] [ j ] ; NEW_LINE for k in range ( C ) : NEW_LINE INDENT dfs ( inputchar , res , i + 1 , k , R , C ) ; NEW_LINE if ( i + 1 == R ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT inputchar = [ [ ' a ' , ' b ' ] , [ ' d ' , ' e ' ] ] ; NEW_LINE R = len ( inputchar ) ; NEW_LINE C = len ( inputchar [ 0 ] ) ; NEW_LINE printPaths ( inputchar , R , C ) ; NEW_LINE DEDENT"],"bleu":0.718474740846652,"rouge_l":0.8948655256723718}
{"id":1499,"predictions":["mod = 1000000007 NEW_LINE def power ( a , m1 ) : NEW_LINE INDENT if ( m1 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( m1 == 1 ) : NEW_LINE INDENT return a NEW_LINE DEDENT elif ( m1 == 2 ) : NEW_LINE INDENT return ( 1 + a * a ) % mod NEW_LINE DEDENT elif ( m1 & 1 ) : NEW_LINE INDENT return ( ( 1L * a * a ) % mod ) NEW_LINE DEDENT elif ( m1 % 2 == 1 ) : NEW_LINE INDENT return ( ( 1 + a * power ( power ( a , m1 \/\/ 2 ) , 2 ) ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT return power ( a , m * i ) % mod NEW_LINE DEDENT return ans NEW_LINE DEDENT def factorial ( x ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , x + 1 ) : NEW_LINE INDENT ans = ( 1L * ans * i ) % mod NEW_LINE DEDENT return ans NEW_LINE DEDENT def binomial ( n , r ) : NEW_LINE INDENT if ( r > n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = factorial ( n ) NEW_LINE ans = ( ( 1 l * ans * inverse ( factorial ( r ) ) ) % mod ) NEW_LINE ans = ( ( 1 L * ans * inverse ( factorial ( n - r ) ) ) % mod ) NEW_LINE return ans NEW_LINE DEDENT def number_of_sets ( n , a , b ) : NEW_LINE INDENT ans = power ( 2 , n ) NEW_LINE ans = ans - binomial ( n , a ) NEW_LINE if ( ans < 0 ) : NEW_LINE INDENT ans += mod NEW_LINE DEDENT return ans NEW_LINE DEDENT N = 4 NEW_LINE A = 1 NEW_LINE B = 1 NEW_LINE print ( number_of_sets ( N , A , B ) ) NEW_LINE"],"references":["mod = 10 ** 9 + 7 NEW_LINE def power ( a , m1 ) : NEW_LINE INDENT if ( m1 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( m1 == 1 ) : NEW_LINE INDENT return a NEW_LINE DEDENT elif ( m1 == 2 ) : NEW_LINE INDENT return ( a * a ) % mod NEW_LINE DEDENT elif ( m1 & 1 ) : NEW_LINE INDENT return ( a * power ( power ( a , m1 \/\/ 2 ) , 2 ) ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT return power ( power ( a , m1 \/\/ 2 ) , 2 ) % mod NEW_LINE DEDENT DEDENT def factorial ( x ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , x + 1 ) : NEW_LINE INDENT ans = ( ans * i ) % mod NEW_LINE DEDENT return ans NEW_LINE DEDENT def inverse ( x ) : NEW_LINE INDENT return power ( x , mod - 2 ) NEW_LINE DEDENT def binomial ( n , r ) : NEW_LINE INDENT if ( r > n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = factorial ( n ) NEW_LINE ans = ( ans * inverse ( factorial ( r ) ) ) % mod NEW_LINE ans = ( ans * inverse ( factorial ( n - r ) ) ) % mod NEW_LINE return ans NEW_LINE DEDENT def number_of_sets ( n , a , b ) : NEW_LINE INDENT ans = power ( 2 , n ) NEW_LINE ans = ans - binomial ( n , a ) NEW_LINE if ( ans < 0 ) : NEW_LINE INDENT ans += mod NEW_LINE DEDENT ans = ans - binomial ( n , b ) NEW_LINE ans -= 1 NEW_LINE if ( ans < 0 ) : NEW_LINE INDENT ans += mod NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE A = 1 NEW_LINE B = 3 NEW_LINE print ( number_of_sets ( N , A , B ) ) NEW_LINE DEDENT"],"bleu":0.7637536345859022,"rouge_l":0.8140164240388205}
{"id":1500,"predictions":["def sumOfSeries ( a , n ) : NEW_LINE INDENT res = 0 NEW_LINE prev = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT prev *= ( a \/ i ) NEW_LINE res = res + prev NEW_LINE DEDENT return ( res ) NEW_LINE DEDENT def sumOfSeries ( a , n ) : NEW_LINE INDENT res = 0 NEW_LINE prev = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT prev *= ( a \/ i ) NEW_LINE res = res + prev NEW_LINE DEDENT return ( res ) NEW_LINE DEDENT n = 5 NEW_LINE a = 2 NEW_LINE print ( sumOfSeries ( a , n ) ) NEW_LINE"],"references":["from __future__ import division NEW_LINE def sumOfSeries ( a , num ) : NEW_LINE INDENT res = 0 NEW_LINE prev = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT prev *= ( a \/ i ) NEW_LINE res = res + prev NEW_LINE DEDENT return res NEW_LINE DEDENT n = 5 NEW_LINE a = 2 NEW_LINE print ( round ( sumOfSeries ( a , n ) , 4 ) ) NEW_LINE"],"bleu":0.5093758831848916,"rouge_l":0.7081090174966352}
{"id":1501,"predictions":["def countNum ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE count = 0 NEW_LINE maxm = - 2147483648 NEW_LINE minm = 2147483648 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE if ( arr [ i ] < minm ) : NEW_LINE INDENT minm = arr [ i ] NEW_LINE DEDENT if ( arr [ i ] > maxm ) : NEW_LINE INDENT maxm = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( minm , maxm + 1 ) : NEW_LINE INDENT if i not in s : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 3 , 5 , 8 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countNum ( arr , n ) ) NEW_LINE"],"references":["def countNum ( arr , n ) : NEW_LINE INDENT s = dict ( ) NEW_LINE count , maxm , minm = 0 , - 10 ** 9 , 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s [ arr [ i ] ] = 1 NEW_LINE if ( arr [ i ] < minm ) : NEW_LINE INDENT minm = arr [ i ] NEW_LINE DEDENT if ( arr [ i ] > maxm ) : NEW_LINE INDENT maxm = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( minm , maxm + 1 ) : NEW_LINE INDENT if i not in s . keys ( ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 3 , 5 , 8 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countNum ( arr , n ) ) NEW_LINE"],"bleu":0.8167654136906684,"rouge_l":0.8861985472154964}
{"id":1502,"predictions":["MAX_CHAR = 256 NEW_LINE def isPresent ( s , q ) : NEW_LINE INDENT freq = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) ] += 1 NEW_LINE DEDENT for i in range ( len ( q ) ) : NEW_LINE INDENT freq [ ord ( q [ i ] ) ] -= 1 NEW_LINE if ( freq [ q [ i ] ] < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" abctd \" NEW_LINE q = \" cat \" NEW_LINE if ( isPresent ( s , q ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["MAX_CHAR = 256 NEW_LINE def isPresent ( s , q ) : NEW_LINE INDENT freq = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) ] += 1 NEW_LINE DEDENT for i in range ( 0 , len ( q ) ) : NEW_LINE INDENT freq [ ord ( q [ i ] ) ] -= 1 NEW_LINE if ( freq [ ord ( q [ i ] ) ] < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT s = \" abctd \" NEW_LINE q = \" cat \" NEW_LINE if ( isPresent ( s , q ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.8615753293605932,"rouge_l":0.93544235924933}
{"id":1503,"predictions":["def area_of_circle ( m , n ) : NEW_LINE INDENT square_of_radius = ( m * n ) \/ 4 NEW_LINE area = ( 3.141 * square_of_radius ) NEW_LINE return area NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE m = 30 NEW_LINE print ( area_of_circle ( m , n ) ) NEW_LINE DEDENT"],"references":["def area_of_circle ( m , n ) : NEW_LINE INDENT square_of_radius = ( m * n ) \/ 4 NEW_LINE area = ( 3.141 * square_of_radius ) NEW_LINE return area NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE m = 30 NEW_LINE print ( area_of_circle ( m , n ) ) NEW_LINE DEDENT"],"bleu":1.0,"rouge_l":1.0}
{"id":1504,"predictions":["def printTwoSetBitNums ( n ) : NEW_LINE INDENT x = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT y = 0 NEW_LINE while ( y < x ) : NEW_LINE INDENT print ( ( ( 1 << x ) + ( 1 << y ) ) NEW_LINE n -= 1 NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT y += 1 NEW_LINE DEDENT x += 1 NEW_LINE DEDENT DEDENT n = 4 NEW_LINE printTwoSetBitNums ( n ) NEW_LINE"],"references":["def printTwoSetBitNums ( n ) : NEW_LINE INDENT x = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT y = 0 NEW_LINE while ( y < x ) : NEW_LINE INDENT print ( ( 1 << x ) + ( 1 << y ) , end = \" ▁ \" ) NEW_LINE n -= 1 NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT y += 1 NEW_LINE DEDENT x += 1 NEW_LINE DEDENT DEDENT printTwoSetBitNums ( 4 ) NEW_LINE"],"bleu":0.855709559264446,"rouge_l":0.9195402298850576}
{"id":1505,"predictions":["def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ [ 0 for x in range ( k + 1 ) ] for y in range ( k + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) ; NEW_LINE DEDENT DEDENT DEDENT return C [ n ] [ k ] ; NEW_LINE DEDENT def findMax ( n ) : NEW_LINE INDENT return binomialCoeff ( n , int ( n \/ 2 ) ) ; NEW_LINE DEDENT n = 5 ; NEW_LINE print ( findMax ( n ) ) ; NEW_LINE"],"references":["def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ [ 0 for i in range ( k + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return C [ n ] [ k ] NEW_LINE DEDENT def findMax ( n ) : NEW_LINE INDENT return binomialCoeff ( n , n \/\/ 2 ) NEW_LINE DEDENT n = 5 NEW_LINE print ( findMax ( n ) ) NEW_LINE"],"bleu":0.8222425820315816,"rouge_l":0.9503918944752437}
{"id":1506,"predictions":["def calculateSum ( arr , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT s = arr [ 0 ] NEW_LINE value = s NEW_LINE for i in range ( 2 , n , 2 ) : NEW_LINE INDENT s = arr [ i ] NEW_LINE value = s [ i - 1 ] [ 0 ] NEW_LINE value = arr [ i - 1 ] [ 0 ] NEW_LINE if ( operation == ' + ' ) : NEW_LINE INDENT sum += value NEW_LINE DEDENT else : NEW_LINE INDENT sum -= value NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ \"3\" , \" + \" , \"4\" , \" - \" , \"7\" , \"9\" ] NEW_LINE n = len ( arr ) NEW_LINE print ( calculateSum ( arr , n ) ) NEW_LINE DEDENT"],"references":["def calculateSum ( arr , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT s = arr [ 0 ] NEW_LINE value = int ( s ) NEW_LINE sum = value NEW_LINE for i in range ( 2 , n , 2 ) : NEW_LINE INDENT s = arr [ i ] NEW_LINE value = int ( s ) NEW_LINE operation = arr [ i - 1 ] [ 0 ] NEW_LINE if ( operation == ' + ' ) : NEW_LINE INDENT sum += value NEW_LINE DEDENT else : NEW_LINE INDENT sum -= value NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT arr = [ \"3\" , \" + \" , \"4\" , \" - \" , \"7\" , \" + \" , \"13\" ] NEW_LINE n = len ( arr ) NEW_LINE print ( calculateSum ( arr , n ) ) NEW_LINE"],"bleu":0.7996377192544161,"rouge_l":0.8758445945945945}
{"id":1507,"predictions":["def checkperfect ( x ) : NEW_LINE INDENT temp = x NEW_LINE n = 0 NEW_LINE while ( x ) : NEW_LINE INDENT x = x \/\/ 10 NEW_LINE n += 1 NEW_LINE DEDENT x = temp NEW_LINE sum = 0 NEW_LINE while ( x ) : NEW_LINE INDENT sum += pow ( x % 10 , n ) NEW_LINE x = int ( x \/ 10 ) NEW_LINE DEDENT return ( sum == temp ) NEW_LINE DEDENT x = 9474 NEW_LINE if ( check + perfectperfect ( x ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def checkplusperfect ( x ) : NEW_LINE INDENT temp = x NEW_LINE n = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT x = x \/\/ 10 NEW_LINE n = n + 1 NEW_LINE DEDENT x = temp NEW_LINE sm = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT sm = sm + ( int ) ( math . pow ( x % 10 , n ) ) NEW_LINE x = x \/\/ 10 NEW_LINE DEDENT return ( sm == temp ) NEW_LINE DEDENT x = 9474 NEW_LINE if ( checkplusperfect ( x ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.6721009381763187,"rouge_l":0.8300997035839396}
{"id":1508,"predictions":["def isPossible ( arr , p , n , m ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( p ) : NEW_LINE INDENT sum += arr [ i ] ; NEW_LINE DEDENT if ( sum == ( n * m ) ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT n = 3 ; m = 4 ; NEW_LINE arr = [ 6 , 3 , 2 , 1 ] ; NEW_LINE p = len ( arr ) ; NEW_LINE if ( isPossible ( arr , p , n , m ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT"],"references":["def isPossible ( arr , p , n , m ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( p ) : NEW_LINE INDENT sum += arr [ i ] ; NEW_LINE DEDENT if ( sum == ( n * m ) ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 ; NEW_LINE m = 4 ; NEW_LINE arr = [ 6 , 3 , 2 , 1 ] ; NEW_LINE p = len ( arr ) ; NEW_LINE if ( isPossible ( arr , p , n , m ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"],"bleu":0.869165512186378,"rouge_l":0.935783089546914}
{"id":1509,"predictions":["def reverse ( n ) : NEW_LINE INDENT d , s = 0 , 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT d = n % 10 NEW_LINE s = s * 10 + d NEW_LINE n = n \/\/ 10 NEW_LINE DEDENT return s NEW_LINE DEDENT def isPalin ( n ) : NEW_LINE INDENT return n == reverse ( n ) NEW_LINE DEDENT def sumOfArray ( arr , n ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > 10 ) and isPalin ( arr [ i ] ) ) : NEW_LINE INDENT s += arr [ i ] NEW_LINE DEDENT DEDENT return s NEW_LINE DEDENT n = 6 NEW_LINE arr = [ 12 , 33 , 11 , 44 , 9 , 1 ] NEW_LINE print ( sumOfArray ( arr , n ) ) NEW_LINE"],"references":["def reverse ( n ) : NEW_LINE INDENT d = 0 ; s = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT d = n % 10 ; NEW_LINE s = s * 10 + d ; NEW_LINE n = n \/\/ 10 ; NEW_LINE DEDENT return s ; NEW_LINE DEDENT def isPalin ( n ) : NEW_LINE INDENT return n == reverse ( n ) ; NEW_LINE DEDENT def sumOfArray ( arr , n ) : NEW_LINE INDENT s = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( arr [ i ] > 10 ) and isPalin ( arr [ i ] ) ) : NEW_LINE INDENT s += arr [ i ] ; NEW_LINE DEDENT DEDENT return s ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 6 ; NEW_LINE arr = [ 12 , 313 , 11 , 44 , 9 , 1 ] ; NEW_LINE print ( sumOfArray ( arr , n ) ) ; NEW_LINE DEDENT"],"bleu":0.6919613099780939,"rouge_l":0.8833796873501488}
{"id":1510,"predictions":["def minCost ( arr , n ) : NEW_LINE INDENT count_even = 0 NEW_LINE count_odd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT count_even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_odd += 1 NEW_LINE DEDENT DEDENT return min ( count_even , count_odd ) NEW_LINE DEDENT arr = [ 2 , 4 , 3 , 1 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minCost ( arr , n ) ) NEW_LINE"],"references":["def minCost ( arr , n ) : NEW_LINE INDENT count_even = 0 NEW_LINE count_odd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT count_even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_odd += 1 NEW_LINE DEDENT DEDENT return min ( count_even , count_odd ) NEW_LINE DEDENT arr = [ 2 , 4 , 3 , 1 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minCost ( arr , n ) ) NEW_LINE"],"bleu":1.0,"rouge_l":1.0}
{"id":1511,"predictions":["def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return gcd ( a - b , b ) NEW_LINE DEDENT return gcd ( a , b - a ) NEW_LINE DEDENT def coprime ( a , b ) : NEW_LINE INDENT return ( gcd ( a , b ) == 1 ) NEW_LINE DEDENT def numOfPairs ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( coprime ( arr [ i ] , arr [ j ] ) ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 1 , 2 , 5 , 4 , 8 , 3 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE print ( numOfPairs ( arr , n ) ) NEW_LINE"],"references":["def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return gcd ( a - b , b ) NEW_LINE DEDENT return gcd ( a , b - a ) NEW_LINE DEDENT def coprime ( a , b ) : NEW_LINE INDENT return ( gcd ( a , b ) == 1 ) NEW_LINE DEDENT def numOfPairs ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( coprime ( arr [ i ] , arr [ j ] ) ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 1 , 2 , 5 , 4 , 8 , 3 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE print ( numOfPairs ( arr , n ) ) NEW_LINE"],"bleu":0.9712819553990242,"rouge_l":0.9891623207301175}
{"id":1512,"predictions":["def countSubarrays ( a , n , m ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT odd = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if ( a [ j ] % 2 == 0 ) : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT if ( odd == m ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 2 , 2 , 5 , 6 , 9 , 2 , 11 ] NEW_LINE n = len ( a ) NEW_LINE m = 2 NEW_LINE print ( countSubarrays ( a , n , m ) ) NEW_LINE DEDENT"],"references":["def countSubarrays ( a , n , m ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT odd = 0 ; NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if ( a [ j ] % 2 ) : NEW_LINE INDENT odd += 1 ; NEW_LINE DEDENT if ( odd == m ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT a = [ 2 , 2 , 5 , 6 , 9 , 2 , 11 ] ; NEW_LINE n = len ( a ) ; NEW_LINE m = 2 ; NEW_LINE print ( countSubarrays ( a , n , m ) ) ; NEW_LINE"],"bleu":0.7621766566849454,"rouge_l":0.9099950273495775}
{"id":1513,"predictions":["import math NEW_LINE def divide ( n , m ) : NEW_LINE INDENT print ( \" Bridder ▁ = ▁ \" , ( ( n ) & ( m - 1 ) ) ) ; NEW_LINE print ( \" Quotient ▁ = \" , int ( n >> ( m ) ) ) ; NEW_LINE DEDENT n = 43 ; m = 8 ; NEW_LINE divide ( n , m ) ; NEW_LINE"],"references":["import math NEW_LINE def divide ( n , m ) : NEW_LINE INDENT print ( \" Remainder ▁ = ▁ \" , ( ( n ) & ( m - 1 ) ) ) NEW_LINE print ( \" Quotient ▁ = ▁ \" , ( n >> ( int ) ( math . log2 ( m ) ) ) ) NEW_LINE DEDENT n = 43 NEW_LINE m = 8 NEW_LINE divide ( n , m ) NEW_LINE"],"bleu":0.6928606494782756,"rouge_l":0.8757885577550576}
{"id":1514,"predictions":["from collections import defaultdict NEW_LINE maxlen = 100 NEW_LINE def generateSubStrings ( s , mpp ) : NEW_LINE INDENT l = len ( s ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT temp = \" \" NEW_LINE for j in range ( i , l ) : NEW_LINE INDENT temp += s [ j ] NEW_LINE if temp in mpp . keys ( ) : NEW_LINE INDENT mpp [ temp ] [ j ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT mpp [ temp ] [ j ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT def binomialCoeff ( C ) : NEW_LINE INDENT for i in range ( 1 , 100 ) : NEW_LINE INDENT for j in range ( 100 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT def answerQuery ( mpp , M , k ) : NEW_LINE INDENT ans = 0 NEW_LINE for itr in m : NEW_LINE INDENT if ( m == k ) : NEW_LINE INDENT ans += C [ it ] [ k ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" aabaab \" NEW_LINE mpp = [ ] NEW_LINE generateSubStrings ( s , mpp ) NEW_LINE C = [ 2 for i in range ( maxlen ) ] NEW_LINE queries = [ 2 , 3 , 4 ] NEW_LINE q = len ( queries ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT print ( answerQuery ( mpp , C , queries [ i ] ) ) NEW_LINE DEDENT"],"references":["from collections import defaultdict NEW_LINE maxlen = 100 NEW_LINE def generateSubStrings ( s , mpp ) : NEW_LINE INDENT l = len ( s ) NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT temp = \" \" NEW_LINE for j in range ( i , l ) : NEW_LINE INDENT temp += s [ j ] NEW_LINE mpp [ temp ] += 1 NEW_LINE DEDENT DEDENT DEDENT def binomialCoeff ( C ) : NEW_LINE INDENT for i in range ( 0 , 100 ) : NEW_LINE INDENT for j in range ( 0 , 100 ) : NEW_LINE INDENT if j == 0 or j == i : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT def answerQuery ( mpp , C , k ) : NEW_LINE INDENT ans = 0 NEW_LINE for it in mpp : NEW_LINE INDENT if mpp [ it ] >= k : NEW_LINE INDENT ans += C [ mpp [ it ] ] [ k ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" aabaab \" NEW_LINE mpp = defaultdict ( lambda : 0 ) NEW_LINE generateSubStrings ( s , mpp ) NEW_LINE C = [ [ 0 for i in range ( maxlen ) ] for j in range ( maxlen ) ] NEW_LINE binomialCoeff ( C ) NEW_LINE queries = [ 2 , 3 , 4 ] NEW_LINE q = len ( queries ) NEW_LINE for i in range ( 0 , q ) : NEW_LINE INDENT print ( answerQuery ( mpp , C , queries [ i ] ) ) NEW_LINE DEDENT DEDENT"],"bleu":0.813285657134733,"rouge_l":0.8732294974545086}
{"id":1515,"predictions":["def findProduct ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE prod = 1 * arr [ 0 ] NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] != arr [ i + 1 ] ) : NEW_LINE INDENT prod = prod * arr [ i + 1 ] NEW_LINE DEDENT DEDENT return prod NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 1 , 1 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findProduct ( arr , n ) ) NEW_LINE DEDENT"],"references":["def findProduct ( arr , n ) : NEW_LINE INDENT sorted ( arr ) NEW_LINE prod = 1 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( arr [ i - 1 ] != arr [ i ] ) : NEW_LINE INDENT prod = prod * arr [ i ] NEW_LINE DEDENT DEDENT return prod ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 1 , 1 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findProduct ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.7728649601100747,"rouge_l":0.9093271334792122}
{"id":1516,"predictions":["def SieveOfSundaram ( n ) : NEW_LINE INDENT nNew = ( n - 2 ) \/\/ 2 NEW_LINE marked = [ False for i in range ( nNew + 1 ) ] NEW_LINE for i in range ( 1 , nNew + 1 ) : NEW_LINE INDENT for j in range ( i , nNew + 2 * i * j ) : NEW_LINE INDENT marked [ i + j + 2 * i * j ] = True NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT print ( 2 , end = \" ▁ \" ) NEW_LINE DEDENT for i in range ( 1 , nNew + 1 ) : NEW_LINE INDENT if ( marked [ i ] == False ) : NEW_LINE INDENT print ( 2 * i + 1 , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT n = 20 NEW_LINE SieveOfSundaram ( n ) NEW_LINE"],"references":["def SieveOfSundaram ( n ) : NEW_LINE INDENT nNew = int ( ( n - 2 ) \/ 2 ) ; NEW_LINE marked = [ 0 ] * ( nNew + 1 ) ; NEW_LINE for i in range ( 1 , nNew + 1 ) : NEW_LINE INDENT j = i ; NEW_LINE while ( ( i + j + 2 * i * j ) <= nNew ) : NEW_LINE INDENT marked [ i + j + 2 * i * j ] = 1 ; NEW_LINE j += 1 ; NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT print ( 2 , end = \" ▁ \" ) ; NEW_LINE DEDENT for i in range ( 1 , nNew + 1 ) : NEW_LINE INDENT if ( marked [ i ] == 0 ) : NEW_LINE INDENT print ( ( 2 * i + 1 ) , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT DEDENT n = 20 ; NEW_LINE SieveOfSundaram ( n ) ; NEW_LINE"],"bleu":0.6702821778172429,"rouge_l":0.8380417956656345}
{"id":1517,"predictions":["def solve ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT print ( - 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT num = 2 ; NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT num = ( num * 10 ) + 3 ; NEW_LINE DEDENT print ( num ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 ; NEW_LINE solve ( n ) ; NEW_LINE DEDENT"],"references":["def solve ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT print ( - 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT num = 2 ; NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT num = ( num * 10 ) + 3 ; NEW_LINE DEDENT print ( num ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 ; NEW_LINE solve ( n ) ; NEW_LINE DEDENT"],"bleu":1.0,"rouge_l":1.0}
{"id":1518,"predictions":["def minimumOperations ( arr , n ) : NEW_LINE INDENT brr = [ 0 , 0 , 0 , 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT brr [ arr [ i ] % 4 ] += 1 NEW_LINE DEDENT if ( ( brr [ 1 ] + 2 * brr [ 2 ] + 3 * brr [ 3 ] ) % 4 == 0 ) : NEW_LINE INDENT min_opr = min ( brr [ 3 ] , brr [ 1 ] ) NEW_LINE brr [ 3 ] -= min_opr NEW_LINE min_opr NEW_LINE min_opr ( brr [ 1 ] ) -= 2 NEW_LINE if ( brr [ 2 ] == 1 ) : NEW_LINE INDENT min_opr += 2 NEW_LINE DEDENT if ( brr [ 1 ] == 1 ) : NEW_LINE INDENT min_op += 2 NEW_LINE DEDENT if ( brr [ 1 ] == 1 ) : NEW_LINE INDENT brr [ 1 ] -= 2 NEW_LINE DEDENT if ( brr [ 1 ] == 1 ) : NEW_LINE INDENT min_opr += 2 NEW_LINE DEDENT DEDENT if ( brr [ 1 ] == 1 ) : NEW_LINE INDENT min_opr += ( brr [ 1 ] \/\/ 4 ) * 3 NEW_LINE DEDENT return min_opr NEW_LINE DEDENT return - 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 1 , 2 , 3 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minimumOperations ( arr , n ) ) NEW_LINE DEDENT"],"references":["def minimumOperations ( arr , n ) : NEW_LINE INDENT brr = [ 0 , 0 , 0 , 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT brr [ arr [ i ] % 4 ] += 1 ; NEW_LINE DEDENT if ( ( brr [ 1 ] + 2 * brr [ 2 ] + 3 * brr [ 3 ] ) % 4 == 0 ) : NEW_LINE INDENT min_opr = min ( brr [ 3 ] , brr [ 1 ] ) NEW_LINE brr [ 3 ] -= min_opr NEW_LINE brr [ 1 ] -= min_opr NEW_LINE min_opr += brr [ 2 ] \/\/ 2 NEW_LINE brr [ 2 ] %= 2 NEW_LINE if ( brr [ 2 ] ) : NEW_LINE INDENT min_opr += 2 NEW_LINE brr [ 2 ] = 0 NEW_LINE if ( brr [ 3 ] ) : NEW_LINE INDENT brr [ 3 ] -= 2 NEW_LINE DEDENT if ( brr [ 1 ] ) : NEW_LINE INDENT brr [ 1 ] -= 2 NEW_LINE DEDENT DEDENT if ( brr [ 1 ] ) : NEW_LINE INDENT min_opr += ( brr [ 1 ] \/\/ 4 ) * 3 NEW_LINE DEDENT if ( brr [ 3 ] ) : NEW_LINE INDENT min_opr += ( brr [ 3 ] \/\/ 4 ) * 3 NEW_LINE DEDENT return min_opr NEW_LINE DEDENT return - 1 NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 1 , 2 , 3 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minimumOperations ( arr , n ) ) NEW_LINE"],"bleu":0.7891649922180973,"rouge_l":0.8527562419876686}
{"id":1519,"predictions":["import sys NEW_LINE def minFn ( arr ) : NEW_LINE INDENT min = sys . maxsize ; NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT if ( arr [ i ] [ j ] == 0 ) : NEW_LINE INDENT arr [ i ] [ j ] = sys . maxsize ; NEW_LINE DEDENT DEDENT return min ; NEW_LINE DEDENT def minimizeGraph ( arr ) : NEW_LINE INDENT for i in range ( len ( arr ) ) : NEW_LINE INDENT min = minFn ( arr [ i ] ) ; NEW_LINE for j in range ( len ( arr ) ) : NEW_LINE INDENT if ( ( arr [ i ] [ j ] != min ) or ( arr [ i ] [ j ] == INT_MAX ) ) : NEW_LINE INDENT arr [ i ] [ j ] = 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT min = 0 ; NEW_LINE DEDENT DEDENT DEDENT for i in range ( len ( arr ) ) : NEW_LINE INDENT for j in range ( len ( arr ) ) : NEW_LINE INDENT print ( arr [ i ] [ j ] , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ [ 1 , 2 , 4 , 0 ] , [ 0 , 0 , 0 , 5 ] , [ 0 , 0 , 0 , 5 ] , [ 0 , 0 , 0 , 3 ] , [ 0 , 0 , 0 , 0 ] ] ; NEW_LINE minimizeGraph ( arr ) ; NEW_LINE DEDENT"],"references":["def minFn ( arr ) : NEW_LINE INDENT minimum = float ( ' inf ' ) NEW_LINE for i in range ( 0 , 4 ) : NEW_LINE INDENT if minimum > arr [ i ] : NEW_LINE INDENT minimum = arr [ i ] NEW_LINE DEDENT DEDENT return minimum NEW_LINE DEDENT def minimizeGraph ( arr ) : NEW_LINE INDENT for i in range ( 0 , 4 ) : NEW_LINE INDENT for j in range ( 0 , 4 ) : NEW_LINE INDENT if arr [ i ] [ j ] == 0 : NEW_LINE INDENT arr [ i ] [ j ] = float ( ' inf ' ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( 0 , 4 ) : NEW_LINE INDENT minimum = minFn ( arr [ i ] ) NEW_LINE for j in range ( 0 , 4 ) : NEW_LINE INDENT if ( ( not ( arr [ i ] [ j ] == minimum ) ) or ( arr [ i ] [ j ] == float ( ' inf ' ) ) ) : NEW_LINE INDENT arr [ i ] [ j ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT minimum = 0 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 0 , 4 ) : NEW_LINE INDENT for j in range ( 0 , 4 ) : NEW_LINE INDENT print ( arr [ i ] [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ [ 1 , 2 , 4 , 0 ] , [ 0 , 0 , 0 , 5 ] , [ 0 , 2 , 0 , 3 ] , [ 0 , 0 , 0 , 0 ] ] NEW_LINE minimizeGraph ( arr ) NEW_LINE DEDENT"],"bleu":0.6348583804546191,"rouge_l":0.7349005810544272}
{"id":1520,"predictions":["def getNumToAdd ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE d = arr [ 1 ] - arr [ 0 ] NEW_LINE numToAdded = - 1 NEW_LINE numAdded = False NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT diff = arr [ i ] - arr [ i - 1 ] NEW_LINE if ( diff != d ) : NEW_LINE INDENT if ( numAdded ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( diff == 2 * d ) : NEW_LINE INDENT numToAdd = arr [ i ] - d NEW_LINE numAdded = True NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT DEDENT if ( numToAdd == - 1 ) : NEW_LINE INDENT return ( arr [ n - 1 ] + d ) NEW_LINE DEDENT return numToAdded NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 3 , 5 , 7 , 11 , 13 , 15 ] NEW_LINE n = len ( arr ) NEW_LINE print ( getNumToAdd ( arr , n ) ) NEW_LINE DEDENT"],"references":["def getNumToAdd ( arr , n ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE d = arr [ 1 ] - arr [ 0 ] NEW_LINE numToAdd = - 1 NEW_LINE numAdded = False NEW_LINE for i in range ( 2 , n , 1 ) : NEW_LINE INDENT diff = arr [ i ] - arr [ i - 1 ] NEW_LINE if ( diff != d ) : NEW_LINE INDENT if ( numAdded ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( diff == 2 * d ) : NEW_LINE INDENT numToAdd = arr [ i ] - d NEW_LINE numAdded = True NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT DEDENT if ( numToAdd == - 1 ) : NEW_LINE INDENT return ( arr [ n - 1 ] + d ) NEW_LINE DEDENT return numToAdd NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 3 , 5 , 7 , 11 , 13 , 15 ] NEW_LINE n = len ( arr ) NEW_LINE print ( getNumToAdd ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.9091683993404831,"rouge_l":0.9650626235992089}
{"id":1521,"predictions":["import math NEW_LINE PI = 3.14159265 NEW_LINE def findAnglesA ( a , b , c ) : NEW_LINE INDENT A = math . acos ( ( b * b + c * c - a * c ) \/ ( 2 * b * c ) ) NEW_LINE return A * 180 \/ PI NEW_LINE DEDENT def findAnglesA ( a , b , c ) : NEW_LINE INDENT B = acos ( ( a * a + c * c - b * c ) \/ ( 2 * a * c ) ) NEW_LINE return B * 180 \/ pi NEW_LINE DEDENT def findAngles ( a , b , c ) : NEW_LINE INDENT x = a NEW_LINE y = b NEW_LINE z = c NEW_LINE A = findAnglesA ( x , y , z ) NEW_LINE B = findAnglesB ( x , y , z ) NEW_LINE print ( \" Angles ▁ are ▁ A ▁ = ▁ \" , A , \" , ▁ B ▁ = ▁ \" , B , \" , ▁ C ▁ = ▁ \" , 90 ) NEW_LINE DEDENT def printOtherSubes ( a , b , c ) : NEW_LINE INDENT b = 0 NEW_LINE c = 0 NEW_LINE if ( n & 1 ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT b = ( n * n - 1 ) \/ 2 NEW_LINE c = ( n * n + 1 ) \/ 2 NEW_LINE print ( \" Side ▁ b ▁ = ▁ \" , b , \" , ▁ C ▁ = ▁ \" , c ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( n == 2 ) : NEW_LINE INDENT print ( \" - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT b = n * n \/ 4 - 1 NEW_LINE c = ( n * n \/ 4 + 1 ) NEW_LINE print ( \" Side ▁ b ▁ = ▁ \" , b , \" , ▁ Order ▁ c ▁ = ▁ \" , c ) NEW_LINE DEDENT"],"references":["import math NEW_LINE PI = 3.1415926535 NEW_LINE def findAnglesA ( a , b , c ) : NEW_LINE INDENT A = math . acos ( ( b * b + c * c - a * a ) \/ ( 2 * b * c ) ) NEW_LINE return A * 180 \/ PI NEW_LINE DEDENT def findAnglesB ( a , b , c ) : NEW_LINE INDENT B = math . acos ( ( a * a + c * c - b * b ) \/ ( 2 * a * c ) ) NEW_LINE return B * 180 \/ PI NEW_LINE DEDENT def printAngles ( a , b , c ) : NEW_LINE INDENT x = a NEW_LINE y = b NEW_LINE z = c NEW_LINE A = findAnglesA ( x , y , z ) NEW_LINE B = findAnglesB ( x , y , z ) NEW_LINE print ( \" Angles ▁ are ▁ A ▁ = ▁ \" , A , \" , ▁ B ▁ = ▁ \" , B , \" , ▁ C ▁ = ▁ \" , \"90 ▁ \" ) NEW_LINE DEDENT def printOtherSides ( n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT else : NEW_LINE INDENT b = ( n * n - 1 ) \/\/ 2 NEW_LINE c = ( n * n + 1 ) \/\/ 2 NEW_LINE print ( \" Side ▁ b ▁ = ▁ \" , b , \" ▁ Side ▁ c ▁ = ▁ \" , c ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( n == 2 ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT else : NEW_LINE INDENT b = n * n \/\/ 4 - 1 ; NEW_LINE c = n * n \/\/ 4 + 1 ; NEW_LINE print ( \" Side ▁ b ▁ = ▁ \" , b , \" , ▁ Side ▁ c ▁ = ▁ \" , c ) NEW_LINE DEDENT DEDENT printAngles ( n , b , c ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 12 NEW_LINE printOtherSides ( a ) NEW_LINE DEDENT"],"bleu":0.7695314414990856,"rouge_l":0.8721437518897673}
{"id":1522,"predictions":["import math NEW_LINE def MaximumHeight ( a , n ) : NEW_LINE INDENT return math . floor ( ( - 1 + math . sqrt ( 1 + ( 8 * n ) ) ) \/ 2 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 40 , 100 , 20 , 30 ] NEW_LINE n = len ( arr ) NEW_LINE print ( MaximumHeight ( arr , n ) ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def MaximumHeight ( a , n ) : NEW_LINE INDENT return ( - 1 + int ( math . sqrt ( 1 + ( 8 * n ) ) ) ) \/\/ 2 NEW_LINE DEDENT arr = [ 40 , 100 , 20 , 30 ] NEW_LINE n = len ( arr ) NEW_LINE print ( MaximumHeight ( arr , n ) ) NEW_LINE"],"bleu":0.6806861393485553,"rouge_l":0.8564742589703588}
{"id":1523,"predictions":["def firstElement ( arr , n , k ) : NEW_LINE INDENT count_map = { } NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT a = 0 NEW_LINE if ( count_map [ a [ i ] ] != 0 ) : NEW_LINE INDENT count_map [ a [ i ] ] = 0 NEW_LINE DEDENT count_map [ a [ i ] ] = a + 1 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( count_map [ a [ i ] ] == k ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 7 , 4 , 3 , 4 , 8 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE print ( firstElement ( arr , n , k ) ) NEW_LINE DEDENT"],"references":["def firstElement ( arr , n , k ) : NEW_LINE INDENT count_map = { } ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] in count_map . keys ( ) ) : NEW_LINE INDENT count_map [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_map [ arr [ i ] ] = 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( count_map [ arr [ i ] ] == k ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 7 , 4 , 3 , 4 , 8 , 7 ] ; NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE print ( firstElement ( arr , n , k ) ) NEW_LINE DEDENT"],"bleu":0.746679948353114,"rouge_l":0.8675452735374987}
{"id":1524,"predictions":["def calculate ( a , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT r = i + 1 NEW_LINE for j in range ( r , n ) : NEW_LINE INDENT if ( a [ i ] == a [ j ] ) : NEW_LINE INDENT r += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT d = r - i NEW_LINE ans += ( d * ( d + 1 ) \/\/ 2 ) NEW_LINE i = r - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT a = [ 2 , 4 , 5 , 3 , 3 , 3 ] NEW_LINE print ( calculate ( a , n ) ) NEW_LINE"],"references":["def calculate ( a , n ) : NEW_LINE INDENT ans = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT r = i + 1 ; NEW_LINE for j in range ( r , n ) : NEW_LINE INDENT if ( a [ i ] == a [ j ] ) : NEW_LINE INDENT r = r + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT d = r - i ; NEW_LINE ans = ans + ( d * ( d + 1 ) \/ 2 ) ; NEW_LINE i = r - 1 ; NEW_LINE i = i + 1 ; NEW_LINE DEDENT return int ( ans ) ; NEW_LINE DEDENT a = [ 2 , 4 , 5 , 3 , 3 , 3 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( calculate ( a , n ) ) ; NEW_LINE"],"bleu":0.5889359331191493,"rouge_l":0.8162114342585426}
{"id":1525,"predictions":["def nth_group ( n ) : NEW_LINE INDENT return n * ( 2 * pow ( n , 2 ) + 1 ) ; NEW_LINE DEDENT if __name__ == \" _ main _ _ \" : NEW_LINE INDENT N = 5 ; NEW_LINE print ( nth_group ( N ) ) ; NEW_LINE DEDENT"],"references":["def nth_group ( n ) : NEW_LINE INDENT return n * ( 2 * pow ( n , 2 ) + 1 ) NEW_LINE DEDENT N = 5 NEW_LINE print ( nth_group ( N ) ) NEW_LINE"],"bleu":0.5940957332278034,"rouge_l":0.8494542717350394}
{"id":1526,"predictions":["def tri_arrays ( wordArr , size ) : NEW_LINE INDENT word_arr = [ 0 for i in range ( size ) ] NEW_LINE for i in range ( size ) : NEW_LINE INDENT ( string [ i ] , i ) NEW_LINE DEDENT DEDENT def search_arrays ( wordArr , size ) : NEW_LINE INDENT dup_arr = [ ] NEW_LINE for i in range ( size ) : NEW_LINE INDENT temp_arr . append ( ele [ i ] , i ) NEW_LINE DEDENT return temp_arr . sort ( ) NEW_LINE DEDENT def printAnagramsWith ( wordArr , size ) : NEW_LINE INDENT dup_arr = word NEW_LINE for i in range ( size ) : NEW_LINE INDENT print ( wordArr [ i ] [ 0 ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT wordArr = sorted ( wordArr , size ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT print ( wordArr [ i ] [ 1 ] , end = \" ▁ \" ) NEW_LINE DEDENT"],"references":["class Word ( object ) : NEW_LINE INDENT def __init__ ( self , string , index ) : NEW_LINE INDENT self . string = string NEW_LINE self . index = index NEW_LINE DEDENT DEDENT def createDupArray ( string , size ) : NEW_LINE INDENT dupArray = [ ] NEW_LINE for i in xrange ( size ) : NEW_LINE INDENT dupArray . append ( Word ( string [ i ] , i ) ) NEW_LINE DEDENT return dupArray NEW_LINE DEDENT def printAnagramsTogether ( wordArr , size ) : NEW_LINE INDENT dupArray = createDupArray ( wordArr , size ) NEW_LINE for i in xrange ( size ) : NEW_LINE INDENT dupArray [ i ] . string = ' ' . join ( sorted ( dupArray [ i ] . string ) ) NEW_LINE DEDENT dupArray = sorted ( dupArray , key = lambda k : k . string ) NEW_LINE for word in dupArray : NEW_LINE INDENT print wordArr [ word . index ] , NEW_LINE DEDENT DEDENT wordArr = [ \" cat \" , \" dog \" , \" tac \" , \" god \" , \" act \" ] NEW_LINE size = len ( wordArr ) NEW_LINE printAnagramsTogether ( wordArr , size ) NEW_LINE"],"bleu":0.34731549132763306,"rouge_l":0.515611523201656}
{"id":1527,"predictions":["def minAbsolutePair ( arr , n ) : NEW_LINE INDENT min_sum = 999999 NEW_LINE l = 0 NEW_LINE r = n - 1 NEW_LINE min_l = l NEW_LINE if ( n < 2 ) : NEW_LINE INDENT print ( \" Invalid ▁ Input \" ) NEW_LINE return NEW_LINE DEDENT arr [ l ] , r = n - 1 , n - 1 NEW_LINE if ( n < 2 ) : NEW_LINE INDENT print ( \" Invalid ▁ Input \" ) NEW_LINE return NEW_LINE DEDENT arr [ l , r ] NEW_LINE while ( l < r ) : NEW_LINE INDENT sum = arr [ l ] + arr [ r ] NEW_LINE if ( abs ( sum ) < abs ( min_sum ) ) : NEW_LINE INDENT min_sum = sum NEW_LINE min_l = l NEW_LINE DEDENT if ( sum < 0 ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT DEDENT print ( \" The ▁ two ▁ elements ▁ having ▁ sum ▁ are \" , arr [ min_l ] , \" and \" , arr [ min_r ] ) NEW_LINE DEDENT arr = [ 1 , 60 , - 10 , 70 , - 80 , 85 ] NEW_LINE n = len ( arr ) NEW_LINE minAbsolutePair ( arr , n ) NEW_LINE"],"references":["def partition ( arr , si , ei ) : NEW_LINE INDENT x = arr [ ei ] NEW_LINE i = ( si - 1 ) NEW_LINE for j in range ( si , ei ) : NEW_LINE INDENT if ( arr [ j ] <= x ) : NEW_LINE INDENT i += 1 NEW_LINE arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE DEDENT DEDENT arr [ i + 1 ] , arr [ ei ] = arr [ ei ] , arr [ i + 1 ] NEW_LINE return ( i + 1 ) NEW_LINE DEDENT def quickSort ( arr , si , ei ) : NEW_LINE INDENT pi = 0 NEW_LINE if ( si < ei ) : NEW_LINE INDENT pi = partition ( arr , si , ei ) NEW_LINE quickSort ( arr , si , pi - 1 ) NEW_LINE quickSort ( arr , pi + 1 , ei ) NEW_LINE DEDENT DEDENT def minAbsSumPair ( arr , n ) : NEW_LINE INDENT sum , min_sum = 0 , 10 ** 9 NEW_LINE l = 0 NEW_LINE r = n - 1 NEW_LINE min_l = l NEW_LINE min_r = n - 1 NEW_LINE if ( n < 2 ) : NEW_LINE INDENT print ( \" Invalid ▁ Input \" , end = \" \" ) NEW_LINE return NEW_LINE DEDENT quickSort ( arr , l , r ) NEW_LINE while ( l < r ) : NEW_LINE INDENT sum = arr [ l ] + arr [ r ] NEW_LINE if ( abs ( sum ) < abs ( min_sum ) ) : NEW_LINE INDENT min_sum = sum NEW_LINE min_l = l NEW_LINE min_r = r NEW_LINE DEDENT if ( sum < 0 ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT DEDENT print ( \" The ▁ two ▁ elements ▁ whose ▁ sum ▁ is ▁ minimum ▁ are \" , arr [ min_l ] , \" and \" , arr [ min_r ] ) NEW_LINE DEDENT arr = [ 1 , 60 , - 10 , 70 , - 80 , 85 ] NEW_LINE n = len ( arr ) NEW_LINE minAbsSumPair ( arr , n ) NEW_LINE"],"bleu":0.40202110137710007,"rouge_l":0.6167308185783935}
{"id":1528,"predictions":["def countFreq ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] in mp . keys ( ) ) : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = - 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( mp [ arr [ i ] ] != - 1 ) : NEW_LINE INDENT print ( arr [ i ] , \" ▁ \" , mp [ arr [ i ] ] ) NEW_LINE mp [ arr [ i ] ] = - 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 10 , 20 , 20 , 10 , 10 , 20 , 5 , 20 ] NEW_LINE n = len ( arr ) NEW_LINE countFreq ( arr , n ) NEW_LINE DEDENT"],"references":["def countFreq ( arr , n ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] not in mp : NEW_LINE INDENT mp [ arr [ i ] ] = 0 NEW_LINE DEDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( mp [ arr [ i ] ] != - 1 ) : NEW_LINE INDENT print ( arr [ i ] , mp [ arr [ i ] ] ) NEW_LINE DEDENT mp [ arr [ i ] ] = - 1 NEW_LINE DEDENT DEDENT arr = [ 10 , 20 , 20 , 10 , 10 , 20 , 5 , 20 ] NEW_LINE n = len ( arr ) NEW_LINE countFreq ( arr , n ) NEW_LINE"],"bleu":0.7163046708776293,"rouge_l":0.8858662303129473}
{"id":1529,"predictions":["import math NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT sr = math . sqrt ( x ) NEW_LINE return ( ( sr - math . floor ( sr ) ) == 0 ) NEW_LINE DEDENT def isFibonacci ( n ) : NEW_LINE INDENT return ( ( sr - math . floor ( sr ) ) == 0 ) NEW_LINE DEDENT def isFibonacci ( n ) : NEW_LINE INDENT s = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( isFibonacci ( a [ i ] + b [ j ] ) == True ) : NEW_LINE INDENT if ( a [ i ] < b [ j ] ) : NEW_LINE INDENT s . append ( [ a [ i ] , b [ j ] ) ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( checkDuplicates ( s , ( b [ j ] , a [ i ] ) ) ) : NEW_LINE INDENT s . append ( ( a [ j ] , a [ i ] ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return len ( s ) NEW_LINE DEDENT def checkDuplicates ( a , newPair ) : NEW_LINE INDENT s = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( p [ 0 ] == newPair ( s , newPair , n , m ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return len ( s ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 99 , 1 , 33 , 2 ] NEW_LINE b = [ 1 , 11 , 2 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE print ( totalPairs ( a , b , n , m ) ) NEW_LINE DEDENT"],"references":["from math import sqrt , floor NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT sr = sqrt ( x ) NEW_LINE return ( ( sr - floor ( sr ) ) == 0 ) NEW_LINE DEDENT def isFibonacci ( n ) : NEW_LINE INDENT return ( isPerfectSquare ( 5 * n * n + 4 ) or isPerfectSquare ( 5 * n * n - 4 ) ) NEW_LINE DEDENT def totalPairs ( a , b , n , m ) : NEW_LINE INDENT s = set ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( isFibonacci ( a [ i ] + b [ j ] ) == True ) : NEW_LINE INDENT if ( a [ i ] < b [ j ] ) : NEW_LINE INDENT s . add ( ( a [ i ] , b [ j ] ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT s . add ( ( b [ j ] , a [ i ] ) ) ; NEW_LINE DEDENT DEDENT DEDENT DEDENT return len ( s ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 99 , 1 , 33 , 2 ] ; NEW_LINE b = [ 1 , 11 , 2 ] ; NEW_LINE n = len ( a ) ; NEW_LINE m = len ( b ) ; NEW_LINE print ( totalPairs ( a , b , n , m ) ) ; NEW_LINE DEDENT"],"bleu":0.6232770968447442,"rouge_l":0.7638272783424112}
{"id":1530,"predictions":["def countSolutions ( n ) : NEW_LINE INDENT res = 0 NEW_LINE x = 0 NEW_LINE while ( x * x < n ) : NEW_LINE INDENT while ( x * x + y * y < n ) : NEW_LINE INDENT res = res + 1 NEW_LINE DEDENT x += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT print ( \" Total ▁ Number ▁ of ▁ distinct ▁ \" , countSolutions ( 6 ) ) NEW_LINE"],"references":["def countSolutions ( n ) : NEW_LINE INDENT res = 0 NEW_LINE x = 0 NEW_LINE while ( x * x < n ) : NEW_LINE INDENT y = 0 NEW_LINE while ( x * x + y * y < n ) : NEW_LINE INDENT res = res + 1 NEW_LINE y = y + 1 NEW_LINE DEDENT x = x + 1 NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( \" Total ▁ Number ▁ of ▁ distinct ▁ Non - Negative ▁ pairs ▁ is ▁ \" , countSolutions ( 6 ) ) NEW_LINE DEDENT"],"bleu":0.5888901922608257,"rouge_l":0.7829758486742106}
{"id":1531,"predictions":["def findLength ( string , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n - 2 + 1 ) : NEW_LINE INDENT l = i NEW_LINE r = i + 1 NEW_LINE lsum = 0 NEW_LINE rsum = 0 NEW_LINE while rsum > 0 : NEW_LINE INDENT lsum += ord ( string [ l ] ) - ord ( '0' ) NEW_LINE rsum += ord ( string [ r ] ) NEW_LINE if ( lsum == rsum ) : NEW_LINE INDENT ans = max ( ans , r - l + 1 ) NEW_LINE DEDENT l -= 1 NEW_LINE r += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \"123123\" NEW_LINE print ( \" Length ▁ of ▁ the ▁ substring ▁ is \" , findLength ( string , len ( string ) ) ) NEW_LINE DEDENT"],"references":["def findLength ( st , n ) : NEW_LINE INDENT total = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT total [ i ] = ( total [ i - 1 ] + int ( st [ i - 1 ] ) - int ( '0' ) ) NEW_LINE DEDENT ans = 0 NEW_LINE l = 2 NEW_LINE while ( l <= n ) : NEW_LINE INDENT for i in range ( n - l + 1 ) : NEW_LINE INDENT j = i + l - 1 NEW_LINE if ( total [ i + int ( l \/ 2 ) ] - total [ i ] == total [ i + l ] - total [ i + int ( l \/ 2 ) ] ) : NEW_LINE INDENT ans = max ( ans , l ) NEW_LINE DEDENT DEDENT l = l + 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT st = \"123123\" NEW_LINE print ( \" Length ▁ of ▁ the ▁ substring ▁ is \" , findLength ( st , len ( st ) ) ) NEW_LINE"],"bleu":0.36160164035166326,"rouge_l":0.5248143452273138}
{"id":1532,"predictions":["def max ( x , y ) : NEW_LINE INDENT if ( x < y ) : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT return y NEW_LINE DEDENT DEDENT def findLength ( arr , n ) : NEW_LINE INDENT max_len = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT mn = arr [ i ] NEW_LINE mx = arr [ i ] NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT mn = min ( mn , arr [ j ] ) NEW_LINE mx = max ( mx , arr [ j ] ) NEW_LINE if ( ( mx - mn ) == j - i ) : NEW_LINE INDENT max_len = max ( max_len , mx - mn + 1 ) NEW_LINE DEDENT DEDENT DEDENT return max_len NEW_LINE DEDENT arr = [ 1 , 56 , 58 , 57 , 90 , 91 , 85 , 45 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Length ▁ of ▁ the ▁ longest ▁ contiguous ▁ subarray ▁ is \" , findLength ( arr , n ) ) NEW_LINE"],"references":["def min ( x , y ) : NEW_LINE INDENT return x if ( x < y ) else y NEW_LINE DEDENT def max ( x , y ) : NEW_LINE INDENT return x if ( x > y ) else y NEW_LINE DEDENT def findLength ( arr , n ) : NEW_LINE INDENT max_len = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT mn = arr [ i ] NEW_LINE mx = arr [ i ] NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT mn = min ( mn , arr [ j ] ) NEW_LINE mx = max ( mx , arr [ j ] ) NEW_LINE if ( ( mx - mn ) == j - i ) : NEW_LINE INDENT max_len = max ( max_len , mx - mn + 1 ) NEW_LINE DEDENT DEDENT DEDENT return max_len NEW_LINE DEDENT arr = [ 1 , 56 , 58 , 57 , 90 , 92 , 94 , 93 , 91 , 45 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Length ▁ of ▁ the ▁ longest ▁ contiguous ▁ subarray ▁ is ▁ \" , findLength ( arr , n ) ) NEW_LINE"],"bleu":0.848252343868689,"rouge_l":0.9037037037037038}
{"id":1533,"predictions":["def findCombinationsUtil ( arr , index , num , deNum ) : NEW_LINE INDENT if ( reduceNum < 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( reduceNum == 0 ) : NEW_LINE INDENT for i in range ( index ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( \" \\n \" , end = \" \" ) NEW_LINE return NEW_LINE DEDENT if ( index == 0 ) : NEW_LINE INDENT prev = 1 NEW_LINE DEDENT else : NEW_LINE INDENT prev = arr [ index - 1 ] NEW_LINE DEDENT for k in range ( prev , num + 1 , 1 ) : NEW_LINE INDENT arr [ index ] = k NEW_LINE findCombinationsUtil ( arr , index + 1 , num , reduceNum - k ) NEW_LINE DEDENT DEDENT def findCombinations ( n ) : NEW_LINE INDENT arr = [ 0 for i in range ( n + 1 ) ] NEW_LINE findCombinationsUtil ( arr , 0 , n , n ) NEW_LINE DEDENT n = 5 NEW_LINE findCombinations ( n ) NEW_LINE"],"references":["def findCombinationsUtil ( arr , index , num , reducedNum ) : NEW_LINE INDENT if ( reducedNum < 0 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT if ( reducedNum == 0 ) : NEW_LINE INDENT for i in range ( index ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( \" \" ) ; NEW_LINE return ; NEW_LINE DEDENT prev = 1 if ( index == 0 ) else arr [ index - 1 ] ; NEW_LINE for k in range ( prev , num + 1 ) : NEW_LINE INDENT arr [ index ] = k ; NEW_LINE findCombinationsUtil ( arr , index + 1 , num , reducedNum - k ) ; NEW_LINE DEDENT DEDENT def findCombinations ( n ) : NEW_LINE INDENT arr = [ 0 ] * n ; NEW_LINE findCombinationsUtil ( arr , 0 , n , n ) ; NEW_LINE DEDENT n = 5 ; NEW_LINE findCombinations ( n ) ; NEW_LINE"],"bleu":0.6619456750062813,"rouge_l":0.8532253611852397}
{"id":1534,"predictions":["import math NEW_LINE MAX = 1000000 NEW_LINE def fib ( n ) : NEW_LINE INDENT phi = ( 1 + sqrt ( 5 ) ) \/ 2 NEW_LINE return round ( pow ( phi , n ) \/ sqrt ( 5 ) ) NEW_LINE DEDENT def calculateSum ( l , r ) : NEW_LINE INDENT sum = fib ( r + 2 ) - fib ( l + 1 ) NEW_LINE return sum NEW_LINE DEDENT l = 4 NEW_LINE r = 8 NEW_LINE print ( calculateSum ( l , r ) ) NEW_LINE"],"references":["import math NEW_LINE def fib ( n ) : NEW_LINE INDENT phi = ( 1 + math . sqrt ( 5 ) ) \/ 2 ; NEW_LINE return int ( round ( pow ( phi , n ) \/ math . sqrt ( 5 ) ) ) ; NEW_LINE DEDENT def calculateSum ( l , r ) : NEW_LINE INDENT sum = fib ( r + 2 ) - fib ( l + 1 ) ; NEW_LINE return sum ; NEW_LINE DEDENT l = 4 ; NEW_LINE r = 8 ; NEW_LINE print ( calculateSum ( l , r ) ) ; NEW_LINE"],"bleu":0.7065506331507733,"rouge_l":0.8998839714901375}
{"id":1535,"predictions":["def MinimumValue ( x , y ) : NEW_LINE INDENT if ( x > y ) : NEW_LINE INDENT temp = x NEW_LINE x = y NEW_LINE y = temp NEW_LINE DEDENT a = 1 NEW_LINE b = x - 1 NEW_LINE c = y - b NEW_LINE print ( a , \" ▁ \" , b , \" \" , c ) NEW_LINE DEDENT x = 123 NEW_LINE y = 13 NEW_LINE MinimumValue ( x , y ) NEW_LINE"],"references":["def MinimumValue ( x , y ) : NEW_LINE INDENT if ( x > y ) : NEW_LINE INDENT x , y = y , x NEW_LINE DEDENT a = 1 NEW_LINE b = x - 1 NEW_LINE c = y - b NEW_LINE print ( a , b , c ) NEW_LINE DEDENT x = 123 NEW_LINE y = 13 NEW_LINE MinimumValue ( x , y ) NEW_LINE"],"bleu":0.7630148841928501,"rouge_l":0.8842551293487957}
{"id":1536,"predictions":["def maximumChars ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE res = - 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( str [ i ] == str [ j ] ) : NEW_LINE INDENT res = max ( res , abs ( j - i - 1 ) ) NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT str = \" abba \" NEW_LINE print ( maximumChars ( str ) ) NEW_LINE"],"references":["def maximumChars ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE res = - 1 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( str [ i ] == str [ j ] ) : NEW_LINE INDENT res = max ( res , abs ( j - i - 1 ) ) NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" abba \" NEW_LINE print ( maximumChars ( str ) ) NEW_LINE DEDENT"],"bleu":0.8227666704114985,"rouge_l":0.9121147390906318}
{"id":1537,"predictions":["def printTribRec ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 or n == 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 3 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT def printTrib ( n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT print ( printTribRec ( i ) , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT def printTrib ( n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT print ( print ( printTribRec ( i ) , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT n = 10 NEW_LINE printTrib ( n ) NEW_LINE"],"references":["def printTribRec ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 or n == 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( n == 3 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( printTribRec ( n - 1 ) + printTribRec ( n - 2 ) + printTribRec ( n - 3 ) ) NEW_LINE DEDENT DEDENT def printTrib ( n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT print ( printTribRec ( i ) , \" ▁ \" , end = \" \" ) NEW_LINE DEDENT DEDENT n = 10 NEW_LINE printTrib ( n ) NEW_LINE"],"bleu":0.695918404213883,"rouge_l":0.8165042235217673}
{"id":1538,"predictions":["def steps ( N , M ) : NEW_LINE INDENT if ( N == 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT elif ( N == 2 ) : NEW_LINE INDENT return M ; NEW_LINE DEDENT return 2 * M + ( N - 3 ) ; NEW_LINE DEDENT N = 4 ; M = 4 ; NEW_LINE print ( steps ( N , M ) ) ; NEW_LINE"],"references":["def steps ( N , M ) : NEW_LINE INDENT if ( N == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( N == 2 ) : NEW_LINE INDENT return M NEW_LINE DEDENT return 2 * M + ( N - 3 ) NEW_LINE DEDENT N = 4 NEW_LINE M = 4 NEW_LINE print ( steps ( N , M ) ) NEW_LINE"],"bleu":0.7916950411450496,"rouge_l":0.9551915201156349}
{"id":1539,"predictions":["def waysToKAdjacentSetBits , n : NEW_LINE INDENT if ( currentIndex == n ) : NEW_LINE INDENT if ( cardinalSetBits == k ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT noOfWays = 0 NEW_LINE if ( lastBit == 1 ) : NEW_LINE INDENT noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , 1 ) NEW_LINE noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , a ) NEW_LINE DEDENT elif ( lastBit == 0 ) : NEW_LINE INDENT noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adj [ n , k , currentIndex + 1 , 0 ] ) NEW_LINE noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , a ) NEW_LINE DEDENT return noOfWays NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 NEW_LINE k = 2 NEW_LINE totalWays = waysToKAdjacentSetBits ( n , k , 1 , 0 , 1 ) + waysToKAdjacentSetBits ( n , k , 1 , 0 , 0 ) NEW_LINE print ( \" Number ▁ of ▁ ways ▁ = ▁ \" , totalWays ) NEW_LINE DEDENT"],"references":["def waysToKAdjacentSetBits ( n , k , currentIndex , adjacentSetBits , lastBit ) : NEW_LINE INDENT if ( currentIndex == n ) : NEW_LINE INDENT if ( adjacentSetBits == k ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT return 0 NEW_LINE DEDENT noOfWays = 0 NEW_LINE if ( lastBit == 1 ) : NEW_LINE INDENT noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits + 1 , 1 ) ; NEW_LINE noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits , 0 ) ; NEW_LINE DEDENT elif ( lastBit != 1 ) : NEW_LINE INDENT noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits , 1 ) ; NEW_LINE noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits , 0 ) ; NEW_LINE DEDENT return noOfWays ; NEW_LINE DEDENT n = 5 ; k = 2 ; NEW_LINE totalWays = ( waysToKAdjacentSetBits ( n , k , 1 , 0 , 1 ) + waysToKAdjacentSetBits ( n , k , 1 , 0 , 0 ) ) ; NEW_LINE print ( \" Number ▁ of ▁ ways ▁ = \" , totalWays ) ; NEW_LINE"],"bleu":0.7049277745017146,"rouge_l":0.8285059728358697}
{"id":1540,"predictions":["def canPlace ( a , n , p , k ) : NEW_LINE INDENT banned_place = 1 NEW_LINE last_len = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT current_star = a [ i ] NEW_LINE if ( current_star - last_len ) >= sep : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def maxDistance ( cell , n , p ) : NEW_LINE INDENT house . sort ( ) NEW_LINE start = 0 NEW_LINE end = count [ n - 1 ] - row [ 0 ] NEW_LINE ans = 0 NEW_LINE while start <= end : NEW_LINE INDENT mid = start + ( ( end - start ) \/\/ 2 ) NEW_LINE if ( canPlace ( cell , n , p , mid ) ) : NEW_LINE INDENT ans = mid NEW_LINE start = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT cell = [ 1 , 2 , 8 , 4 , 9 ] NEW_LINE n = len ( grid ) NEW_LINE p = 3 NEW_LINE print ( maxDistance ( cell , n , p ) ) NEW_LINE DEDENT"],"references":["def canPlace ( a , n , p , sep ) : NEW_LINE INDENT prisoners_placed = 1 NEW_LINE last_prisoner_placed = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT current_cell = a [ i ] NEW_LINE if ( current_cell - last_prisoner_placed >= sep ) : NEW_LINE INDENT prisoners_placed += 1 NEW_LINE last_prisoner_placed = current_cell NEW_LINE if ( prisoners_placed == p ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT def maxDistance ( cell , n , p ) : NEW_LINE INDENT cell = sorted ( cell ) NEW_LINE start = 0 NEW_LINE end = cell [ n - 1 ] - cell [ 0 ] NEW_LINE ans = 0 NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = start + ( ( end - start ) \/\/ 2 ) NEW_LINE if ( canPlace ( cell , n , p , mid ) ) : NEW_LINE INDENT ans = mid NEW_LINE start = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT cell = [ 1 , 2 , 8 , 4 , 9 ] NEW_LINE n = len ( cell ) NEW_LINE p = 3 NEW_LINE print ( maxDistance ( cell , n , p ) ) NEW_LINE"],"bleu":0.7682800738729505,"rouge_l":0.860480493718316}
{"id":1541,"predictions":["def containsElement ( arr , n ) : NEW_LINE INDENT xorArr = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT xorArr ^= arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT x = xorArr ^ arr [ i ] NEW_LINE if ( arr [ i ] == x ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT arr = [ 8 , 2 , 4 , 15 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE if ( arr ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def containsElement ( arr , n ) : NEW_LINE INDENT xorArr = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT xorArr ^= arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT x = xorArr ^ arr [ i ] NEW_LINE if ( arr [ i ] == x ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT arr = [ 8 , 2 , 4 , 15 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE if ( containsElement ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.9429296526978844,"rouge_l":0.9760000000000001}
{"id":1542,"predictions":["def solve ( s ) : NEW_LINE INDENT m = { } ; NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] in m . keys ( ) ) : NEW_LINE INDENT m [ s [ i ] ] += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT m [ s [ i ] ] = 1 ; NEW_LINE DEDENT DEDENT new_string = \" \" ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( m [ s [ i ] ] % 2 == 0 ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT new_string = new_string + s [ i ] ; NEW_LINE DEDENT print ( new_string ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" aabbbddeecc \" ; NEW_LINE solve ( s ) ; NEW_LINE DEDENT"],"references":["def solve ( s ) : NEW_LINE INDENT m = dict ( ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] in m : NEW_LINE INDENT m [ s [ i ] ] = m [ s [ i ] ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ s [ i ] ] = 1 NEW_LINE DEDENT DEDENT new_string = \" \" NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if m [ s [ i ] ] % 2 == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT new_string = new_string + s [ i ] NEW_LINE DEDENT print ( new_string ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" aabbbddeeecc \" NEW_LINE solve ( s ) NEW_LINE DEDENT"],"bleu":0.675906257888161,"rouge_l":0.8752543098832853}
{"id":1543,"predictions":["def getTotalXorOfSubarrayXors ( arr , N ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT freq = ( i + 1 ) * ( N - i ) NEW_LINE if ( freq % 2 ) : NEW_LINE INDENT res = res ^ arr [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 5 , 2 , 4 , 6 ] NEW_LINE N = len ( arr ) NEW_LINE print ( getTotalXorOfSubarrayXors ( arr , N ) ) NEW_LINE DEDENT"],"references":["def getTotalXorOfSubarrayXors ( arr , N ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT freq = ( i + 1 ) * ( N - i ) NEW_LINE if ( freq % 2 == 1 ) : NEW_LINE INDENT res = res ^ arr [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT arr = [ 3 , 5 , 2 , 4 , 6 ] NEW_LINE N = len ( arr ) NEW_LINE print ( getTotalXorOfSubarrayXors ( arr , N ) ) NEW_LINE"],"bleu":0.8274541342942489,"rouge_l":0.9198962218258474}
{"id":1544,"predictions":["def sum ( N ) : NEW_LINE INDENT S1 = ( ( N \/\/ 3 ) ) * ( 2 * 3 + ( N \/\/ 3 - 1 ) * 3 ) \/\/ 2 NEW_LINE S2 = ( ( N \/\/ 4 ) ) * ( 2 * 4 + ( N \/\/ 4 - 1 ) * 4 ) \/\/ 2 NEW_LINE S3 = ( ( N \/\/ 12 ) ) * ( 2 * 12 + ( N \/\/ 12 - 1 ) * 12 ) \/\/ 2 NEW_LINE return S1 + S2 - S3 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 20 NEW_LINE print ( sum ( 12 ) ) NEW_LINE DEDENT"],"references":["def sum ( N ) : NEW_LINE INDENT global S1 , S2 , S3 NEW_LINE S1 = ( ( ( N \/\/ 3 ) ) * ( 2 * 3 + ( N \/\/ 3 - 1 ) * 3 ) \/\/ 2 ) NEW_LINE S2 = ( ( ( N \/\/ 4 ) ) * ( 2 * 4 + ( N \/\/ 4 - 1 ) * 4 ) \/\/ 2 ) NEW_LINE S3 = ( ( ( N \/\/ 12 ) ) * ( 2 * 12 + ( N \/\/ 12 - 1 ) * 12 ) \/\/ 2 ) NEW_LINE return int ( S1 + S2 - S3 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 12 NEW_LINE print ( sum ( N ) ) NEW_LINE DEDENT"],"bleu":0.7785344910888794,"rouge_l":0.9155168240135559}
{"id":1545,"predictions":["def count ( S , m , n ) : NEW_LINE INDENT table = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE table [ 0 ] [ 1 ] = 1 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( S [ i ] , n + 1 ) : NEW_LINE INDENT table [ j ] += table [ j - S [ i ] ] NEW_LINE DEDENT DEDENT return table [ n ] [ 1 ] NEW_LINE DEDENT"],"references":["def count ( S , m , n ) : NEW_LINE INDENT table = [ 0 for k in range ( n + 1 ) ] NEW_LINE table [ 0 ] = 1 NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT for j in range ( S [ i ] , n + 1 ) : NEW_LINE INDENT table [ j ] += table [ j - S [ i ] ] NEW_LINE DEDENT DEDENT return table [ n ] NEW_LINE DEDENT arr = [ 1 , 2 , 3 ] NEW_LINE m = len ( arr ) NEW_LINE n = 4 NEW_LINE x = count ( arr , m , n ) NEW_LINE print ( x ) NEW_LINE"],"bleu":0.6339913559410201,"rouge_l":0.7479327060165383}
{"id":1546,"predictions":["import math NEW_LINE def countSolutions ( a ) : NEW_LINE INDENT count = bin ( a ) . count ( '1' ) ; NEW_LINE return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 3 ; NEW_LINE print ( countSolutions ( a ) ) ; NEW_LINE DEDENT"],"references":["def countSolutions ( a ) : NEW_LINE INDENT count = bin ( a ) . count ( '1' ) NEW_LINE return 2 ** count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 3 NEW_LINE print ( countSolutions ( a ) ) NEW_LINE DEDENT"],"bleu":0.7599722068733473,"rouge_l":0.9250834091598423}
{"id":1547,"predictions":["def countNumber ( n ) : NEW_LINE INDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT return ( 9 * pow ( 10 , n \/ 2 - 1 ) ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 2 ; NEW_LINE print ( countNumber ( n ) ) ; NEW_LINE DEDENT"],"references":["def countNumbers ( n ) : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( 9 * pow ( 10 , n \/\/ 2 - 1 ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 2 NEW_LINE print ( countNumbers ( n ) ) NEW_LINE DEDENT"],"bleu":0.6753894699321916,"rouge_l":0.917858904785397}
{"id":1548,"predictions":["def getMinDiff ( arr , n , k ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT arr . sort ( ) NEW_LINE ans = arr [ n - 1 ] - arr [ 0 ] NEW_LINE small = arr [ n - 1 ] - k NEW_LINE temp = 0 NEW_LINE if ( small > big ) : NEW_LINE INDENT temp = small NEW_LINE small = big NEW_LINE DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT subtract = arr [ i ] - k NEW_LINE add = arr [ i ] + k NEW_LINE if ( diff >= small ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( big - subtract <= add - small ) : NEW_LINE INDENT small = subtract NEW_LINE DEDENT else : NEW_LINE INDENT big = add NEW_LINE DEDENT DEDENT return min ( ans , big - small ) NEW_LINE DEDENT arr = [ 4 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE k = 10 NEW_LINE print ( \" Maximum ▁ difference ▁ is \" , getMinDiff ( arr , n , k ) ) NEW_LINE"],"references":["def getMinDiff ( arr , n , k ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT arr . sort ( ) NEW_LINE ans = arr [ n - 1 ] - arr [ 0 ] NEW_LINE small = arr [ 0 ] + k NEW_LINE big = arr [ n - 1 ] - k NEW_LINE if ( small > big ) : NEW_LINE INDENT small , big = big , small NEW_LINE DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT subtract = arr [ i ] - k NEW_LINE add = arr [ i ] + k NEW_LINE if ( subtract >= small or add <= big ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( big - subtract <= add - small ) : NEW_LINE INDENT small = subtract NEW_LINE DEDENT else : NEW_LINE INDENT big = add NEW_LINE DEDENT DEDENT return min ( ans , big - small ) NEW_LINE DEDENT arr = [ 4 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE k = 10 NEW_LINE print ( \" Maximum ▁ difference ▁ is \" , getMinDiff ( arr , n , k ) ) NEW_LINE"],"bleu":0.8845886874048144,"rouge_l":0.9302938358351965}
{"id":1549,"predictions":["def minimumChanges ( n , a ) : NEW_LINE INDENT sf = [ 0 for i in range ( n + 1 ) ] NEW_LINE sf [ n ] = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT sf [ i ] = sf [ i + 1 ] NEW_LINE if ( a [ i ] <= 0 ) : NEW_LINE INDENT sf [ i ] += 1 NEW_LINE DEDENT DEDENT pos = 0 NEW_LINE mn = n NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( a [ i ] >= 0 ) : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT mn = min ( mn , pos + sf [ i + 1 ] ) NEW_LINE DEDENT return mn NEW_LINE DEDENT a = [ - 1 , - 2 , - 3 , 3 , 4 ] NEW_LINE n = len ( a ) NEW_LINE print ( minimumChanges ( n , a ) ) NEW_LINE"],"references":["def minimumChanges ( n , a ) : NEW_LINE INDENT sf = [ 0 ] * ( n + 1 ) NEW_LINE sf [ n ] = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT sf [ i ] = sf [ i + 1 ] NEW_LINE if ( a [ i ] <= 0 ) : NEW_LINE INDENT sf [ i ] += 1 NEW_LINE DEDENT DEDENT pos = 0 NEW_LINE mn = n NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( a [ i ] >= 0 ) : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT mn = min ( mn , pos + sf [ i + 1 ] ) NEW_LINE DEDENT return mn NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ - 1 , - 2 , - 3 , 3 , - 5 , 3 , 4 ] NEW_LINE n = len ( a ) NEW_LINE print ( minimumChanges ( n , a ) ) NEW_LINE DEDENT"],"bleu":0.8639009879432441,"rouge_l":0.9216958492578436}
{"id":1550,"predictions":["def printFirstRepeating ( arr , n ) : NEW_LINE INDENT min = - 1 ; NEW_LINE set1 = [ ] ; NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if arr [ i ] not in set1 : NEW_LINE INDENT min = i ; NEW_LINE DEDENT else : NEW_LINE INDENT set1 . add ( arr [ i ] ) ; NEW_LINE DEDENT DEDENT if ( min != - 1 ) : NEW_LINE INDENT print ( \" The ▁ first ▁ repeating ▁ element ▁ is \" , arr [ min ] ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" There ▁ are ▁ no ▁ repeating ▁ elements \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 10 , 5 , 3 , 4 , 3 , 5 , 6 ] ; NEW_LINE printFirstRepeating ( arr ) ; NEW_LINE DEDENT"],"references":["def printFirstRepeating ( arr , n ) : NEW_LINE INDENT Min = - 1 NEW_LINE myset = dict ( ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if arr [ i ] in myset . keys ( ) : NEW_LINE INDENT Min = i NEW_LINE DEDENT else : NEW_LINE INDENT myset [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT if ( Min != - 1 ) : NEW_LINE INDENT print ( \" The ▁ first ▁ repeating ▁ element ▁ is \" , arr [ Min ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" There ▁ are ▁ no ▁ repeating ▁ elements \" ) NEW_LINE DEDENT DEDENT arr = [ 10 , 5 , 3 , 4 , 3 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE printFirstRepeating ( arr , n ) NEW_LINE"],"bleu":0.6510578782923206,"rouge_l":0.8101997363885227}
{"id":1551,"predictions":["def solveEven ( n , arr , b ) : NEW_LINE INDENT left = n - 1 NEW_LINE for i in range ( int ( n \/ 2 ) ) : NEW_LINE INDENT b [ i ] = arr [ left ] NEW_LINE left = left - 2 NEW_LINE if ( left < 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT right = 0 NEW_LINE for i in range ( int ( n \/ 2 ) + 1 ) : NEW_LINE INDENT b [ i ] = arr [ right ] NEW_LINE right = right + 2 NEW_LINE if ( right > n - 2 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT def solveOdd ( n , arr , b ) : NEW_LINE INDENT left = n - 1 NEW_LINE for i in range ( 0 , ( int ( n \/ 2 ) + 1 ) + 1 ) : NEW_LINE INDENT b [ i ] = arr [ left ] NEW_LINE left = left - 2 NEW_LINE if ( left < n - 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT right = 1 NEW_LINE for i in range ( int ( n \/ 2 ) + 1 , n - 1 ) : NEW_LINE INDENT b [ i ] = arr [ right ] NEW_LINE right = right + 2 NEW_LINE if ( right > n - 2 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT def solveOdd ( n , arr ) : NEW_LINE INDENT b = [ 0 ] * n NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT solveEven ( n , arr , b ) NEW_LINE DEDENT else : NEW_LINE INDENT solveOdd ( n , arr ) NEW_LINE DEDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT print ( b [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE solve ( n , arr ) NEW_LINE DEDENT"],"references":["def solveEven ( n , arr , b ) : NEW_LINE INDENT left = n - 1 NEW_LINE for i in range ( ( n \/\/ 2 ) ) : NEW_LINE INDENT b [ i ] = arr [ left ] NEW_LINE left = left - 2 NEW_LINE if ( left < 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT right = 0 NEW_LINE for i in range ( n \/\/ 2 , n , 1 ) : NEW_LINE INDENT b [ i ] = arr [ right ] NEW_LINE right = right + 2 NEW_LINE if ( right > n - 2 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT def solveOdd ( n , arr , b ) : NEW_LINE INDENT left = n - 1 NEW_LINE for i in range ( n \/\/ 2 + 1 ) : NEW_LINE INDENT b [ i ] = arr [ left ] NEW_LINE left = left - 2 NEW_LINE if ( left < 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT right = 1 NEW_LINE for i in range ( n \/\/ 2 + 1 , n , 1 ) : NEW_LINE INDENT b [ i ] = arr [ right ] NEW_LINE right = right + 2 NEW_LINE if ( right > n - 2 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT def solve ( n , arr ) : NEW_LINE INDENT b = [ 0 for i in range ( n ) ] NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT solveEven ( n , arr , b ) NEW_LINE DEDENT else : NEW_LINE INDENT solveOdd ( n , arr , b ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( b [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE solve ( n , arr ) NEW_LINE DEDENT"],"bleu":0.8430559223212565,"rouge_l":0.9263201357985043}
{"id":1552,"predictions":["def findpair ( l , r ) : NEW_LINE INDENT c = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , r + 1 ) : NEW_LINE INDENT if ( j % i == 0 and j != i ) : NEW_LINE INDENT print ( i , \" , \" , j ) NEW_LINE c = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( c == 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT l = 1 NEW_LINE r = 10 NEW_LINE findpair ( l , r ) NEW_LINE"],"references":["def findpair ( l , r ) : NEW_LINE INDENT c = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , r + 1 ) : NEW_LINE INDENT if ( j % i == 0 and j != i ) : NEW_LINE INDENT print ( i , \" , ▁ \" , j ) NEW_LINE c = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( c == 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT l = 1 NEW_LINE r = 10 NEW_LINE findpair ( l , r ) NEW_LINE DEDENT"],"bleu":0.8443140704865477,"rouge_l":0.9235885099759443}
{"id":1553,"predictions":["def nthEven ( n ) : NEW_LINE INDENT return ( 2 * n ) NEW_LINE DEDENT n = 10 NEW_LINE print ( nthEven ( n ) ) NEW_LINE"],"references":["def nthEven ( n ) : NEW_LINE INDENT return ( 2 * n ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE print ( nthEven ( n ) ) NEW_LINE DEDENT"],"bleu":0.5717904208544105,"rouge_l":0.7721518987341772}
{"id":1554,"predictions":["def checkUtil ( num , dig , base ) : NEW_LINE INDENT if ( dig == 1 and num < base ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( dig > 1 and num >= base ) : NEW_LINE INDENT return checkUtil ( num \/ base , dig , base ) NEW_LINE DEDENT return False NEW_LINE DEDENT def check ( num , dig ) : NEW_LINE INDENT for base in range ( 2 , 32 + 1 ) : NEW_LINE INDENT if ( checkUtil ( num , dig , base ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT num = 8 NEW_LINE dig = 3 NEW_LINE if ( check ( num , dig ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def checkUtil ( num , dig , base ) : NEW_LINE INDENT if ( dig == 1 and num < base ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( dig > 1 and num >= base ) : NEW_LINE INDENT return checkUtil ( num \/ base , - - dig , base ) NEW_LINE DEDENT return False NEW_LINE DEDENT def check ( num , dig ) : NEW_LINE INDENT for base in range ( 2 , 33 ) : NEW_LINE INDENT if ( checkUtil ( num , dig , base ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT num = 8 NEW_LINE dig = 3 NEW_LINE if ( check ( num , dig ) == True ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.9350857336713037,"rouge_l":0.9715972376921364}
{"id":1555,"predictions":["def smallestSubWithSum ( arr , n , x ) : NEW_LINE INDENT min_len = n + 1 NEW_LINE for start in range ( 0 , n ) : NEW_LINE INDENT curr_sum = arr [ start ] NEW_LINE if ( curr_sum > x ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT for end in range ( start + 1 ) : NEW_LINE INDENT curr_sum += arr [ end ] NEW_LINE if ( curr_sum > x and ( end - start + 1 ) < min_len ) : NEW_LINE INDENT min_len = ( end - start + 1 ) NEW_LINE DEDENT DEDENT DEDENT return min_len NEW_LINE DEDENT arr1 = [ 1 , 4 , 45 , 6 , 10 , 19 ] NEW_LINE x = 51 NEW_LINE n1 = len ( arr1 ) NEW_LINE res1 = smallestSubWithSum ( arr1 , n1 , x ) NEW_LINE if ( res1 == n1 + 1 ) : NEW_LINE INDENT print ( \" Not ▁ possible \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res1 ) NEW_LINE DEDENT arr2 = [ 1 , 10 , 5 , 2 , 7 ] NEW_LINE n2 = len ( arr2 ) NEW_LINE x = 9 NEW_LINE res2 = smallestSubWithSum ( arr2 , n2 , x ) NEW_LINE if ( res2 == n1 + 1 ) : NEW_LINE INDENT print ( \" Not ▁ possible \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res2 ) NEW_LINE DEDENT arr3 = [ 1 , 11 , 100 , 1 , 0 , 200 , 3 , 2 , 1 , 250 ] NEW_LINE n3 = len ( arr3 ) NEW_LINE x = 280 NEW_LINE res3 = smallestSubWithSum ( arr3 , n3 , x ) NEW_LINE if ( res3 == n3 + 1 ) : NEW_LINE INDENT print ( \" Not ▁ possible \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res3 ) NEW_LINE DEDENT"],"references":["def smallestSubWithSum ( arr , n , x ) : NEW_LINE INDENT min_len = n + 1 NEW_LINE for start in range ( 0 , n ) : NEW_LINE INDENT curr_sum = arr [ start ] NEW_LINE if ( curr_sum > x ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT for end in range ( start + 1 , n ) : NEW_LINE INDENT curr_sum += arr [ end ] NEW_LINE if curr_sum > x and ( end - start + 1 ) < min_len : NEW_LINE INDENT min_len = ( end - start + 1 ) NEW_LINE DEDENT DEDENT DEDENT return min_len ; NEW_LINE DEDENT arr1 = [ 1 , 4 , 45 , 6 , 10 , 19 ] NEW_LINE x = 51 NEW_LINE n1 = len ( arr1 ) NEW_LINE res1 = smallestSubWithSum ( arr1 , n1 , x ) ; NEW_LINE if res1 == n1 + 1 : NEW_LINE INDENT print ( \" Not ▁ possible \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res1 ) NEW_LINE DEDENT arr2 = [ 1 , 10 , 5 , 2 , 7 ] NEW_LINE n2 = len ( arr2 ) NEW_LINE x = 9 NEW_LINE res2 = smallestSubWithSum ( arr2 , n2 , x ) ; NEW_LINE if res2 == n2 + 1 : NEW_LINE INDENT print ( \" Not ▁ possible \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res2 ) NEW_LINE DEDENT arr3 = [ 1 , 11 , 100 , 1 , 0 , 200 , 3 , 2 , 1 , 250 ] NEW_LINE n3 = len ( arr3 ) NEW_LINE x = 280 NEW_LINE res3 = smallestSubWithSum ( arr3 , n3 , x ) NEW_LINE if res3 == n3 + 1 : NEW_LINE INDENT print ( \" Not ▁ possible \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res3 ) NEW_LINE DEDENT"],"bleu":0.9122771924500537,"rouge_l":0.9771384136858475}
{"id":1556,"predictions":["import math NEW_LINE def getSum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sqrtCurrent = math . sqrt ( arr [ i ] ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT x = arr [ j ] NEW_LINE if ( x == sqrtCurrent ) : NEW_LINE INDENT sum += ( sqrtCurrent * sqrtCurrent ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT return sum NEW_LINE DEDENT arr = [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( getSum ( arr , n ) ) NEW_LINE"],"references":["import math NEW_LINE def getSum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sqrtCurrent = math . sqrt ( arr [ i ] ) NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT x = arr [ j ] NEW_LINE if ( x == sqrtCurrent ) : NEW_LINE INDENT sum += ( sqrtCurrent * sqrtCurrent ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT return int ( sum ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( getSum ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.7912910466757219,"rouge_l":0.9056768558951964}
{"id":1557,"predictions":["def findCountofPairs ( a , b , n ) : NEW_LINE INDENT ans = 0 NEW_LINE ans += n * ( a \/\/ n ) * ( b \/\/ n ) NEW_LINE ans += ( a \/\/ n ) * ( b \/\/ n ) NEW_LINE ans += ( a % n ) * ( b \/\/ n ) NEW_LINE return ans NEW_LINE DEDENT a = 5 NEW_LINE b = 13 NEW_LINE n = 3 NEW_LINE print ( findCountofPairs ( a , b , n ) ) NEW_LINE"],"references":["def findCountOfPairs ( a , b , n ) : NEW_LINE INDENT ans = 0 NEW_LINE ans += n * int ( a \/ n ) * int ( b \/ n ) NEW_LINE ans += int ( a \/ n ) * ( b % n ) NEW_LINE ans += ( a % n ) * int ( b \/ n ) NEW_LINE ans += int ( ( ( a % n ) + ( b % n ) ) \/ n ) ; NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 5 NEW_LINE b = 13 NEW_LINE n = 3 NEW_LINE print ( findCountOfPairs ( a , b , n ) ) NEW_LINE DEDENT"],"bleu":0.45066935616275355,"rouge_l":0.7257638072855463}
{"id":1558,"predictions":["def bsearch ( prefixsum , n , k ) : NEW_LINE INDENT ans = - 1 NEW_LINE left = 1 NEW_LINE right = n NEW_LINE while ( left <= right ) : NEW_LINE INDENT mid = ( left + right ) \/\/ 2 NEW_LINE i = mid NEW_LINE for i in range ( mid , n + 1 ) : NEW_LINE INDENT if ( prefixsum [ i ] - prefixsum [ i - mid ] > k ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( i == n + 1 ) : NEW_LINE INDENT left = mid + 1 NEW_LINE ans = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT right = mid - 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def maxSize ( arr , n , k ) : NEW_LINE INDENT prefixsum = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT prefixsum [ i + 1 ] = prefixsum [ i ] + arr [ i ] NEW_LINE DEDENT return bsearch ( prefixsum , n , k ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 10 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE k = 14 NEW_LINE print ( maxSize ( arr , n , k ) ) NEW_LINE DEDENT"],"references":["def bsearch ( prefixsum , n , k ) : NEW_LINE INDENT ans , left , right = - 1 , 1 , n NEW_LINE while ( left <= right ) : NEW_LINE INDENT mid = ( left + right ) \/\/ 2 NEW_LINE for i in range ( mid , n + 1 ) : NEW_LINE INDENT if ( prefixsum [ i ] - prefixsum [ i - mid ] > k ) : NEW_LINE INDENT i = i - 1 NEW_LINE break NEW_LINE DEDENT DEDENT i = i + 1 NEW_LINE if ( i == n + 1 ) : NEW_LINE INDENT left = mid + 1 NEW_LINE ans = mid NEW_LINE DEDENT else : NEW_LINE INDENT right = mid - 1 NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT def maxSize ( arr , n , k ) : NEW_LINE INDENT prefixsum = [ 0 for x in range ( n + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT prefixsum [ i + 1 ] = prefixsum [ i ] + arr [ i ] NEW_LINE DEDENT return bsearch ( prefixsum , n , k ) ; NEW_LINE DEDENT arr = [ 1 , 2 , 10 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE k = 14 NEW_LINE print ( maxSize ( arr , n , k ) ) NEW_LINE"],"bleu":0.8419107793521616,"rouge_l":0.9007903494176372}
{"id":1559,"predictions":["import math as mt NEW_LINE def isprime ( x ) : NEW_LINE INDENT for i in range ( 2 , mt . ceil ( mt . sqrt ( x ) ) + 1 ) NEW_LINE DEDENT return True NEW_LINE DEDENT def isSumOfKprimes ( N , K ) : NEW_LINE INDENT if ( N < 2 * K ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( K == 1 ) : NEW_LINE INDENT return isprime ( N ) NEW_LINE DEDENT if ( K == 2 ) : NEW_LINE INDENT if ( N % 2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return isprime ( N - 2 ) NEW_LINE DEDENT return True NEW_LINE DEDENT n = 10 NEW_LINE k = 2 NEW_LINE if ( isSumOfKprimes ( n , k ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def isprime ( x ) : NEW_LINE INDENT i = 2 NEW_LINE while ( i * i <= x ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT def isSumOfKprimes ( N , K ) : NEW_LINE INDENT if ( N < 2 * K ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( K == 1 ) : NEW_LINE INDENT return isprime ( N ) NEW_LINE DEDENT if ( K == 2 ) : NEW_LINE INDENT if ( N % 2 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return isprime ( N - 2 ) ; NEW_LINE DEDENT return 1 NEW_LINE DEDENT n = 10 NEW_LINE k = 2 NEW_LINE if ( isSumOfKprimes ( n , k ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.7458352959321995,"rouge_l":0.8356164383561643}
{"id":1560,"predictions":["def CountCharacters ( str , k ) : NEW_LINE INDENT cnt = 0 NEW_LINE l = len ( str ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( ( ord ( str [ i ] ) ) < k ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" GeeksForGeeks \" NEW_LINE k = 90 NEW_LINE count = CountCharacters ( str , k ) NEW_LINE print ( \" characters ▁ with ▁ ASCII ▁ values ▁ are \" , count ) NEW_LINE print ( \"Characters ▁ with ▁ ASCII ▁ values ▁ are \" , count ) NEW_LINE DEDENT"],"references":["def CountCharacters ( str , k ) : NEW_LINE INDENT cnt = 0 NEW_LINE l = len ( str ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( ord ( str [ i ] ) < k ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" GeeksForGeeks \" NEW_LINE k = 90 NEW_LINE count = CountCharacters ( str , k ) NEW_LINE print ( \" Characters ▁ with ▁ ASCII ▁ values \" , \" less ▁ than ▁ K ▁ are \" , count ) NEW_LINE print ( \" Characters ▁ with ▁ ASCII ▁ values \" , \" greater ▁ than ▁ or ▁ equal ▁ to ▁ K ▁ are \" , len ( str ) - count ) NEW_LINE DEDENT"],"bleu":0.7264313438701082,"rouge_l":0.8611764705882354}
{"id":1561,"predictions":["def printUncommon ( arr1 , arr2 , n1 , n1 , n2 ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE k = 0 NEW_LINE while ( i < n1 and j < n2 ) : NEW_LINE INDENT if ( arr1 [ i ] < arr2 [ j ] ) : NEW_LINE INDENT print ( arr1 [ i ] , end = \" ▁ \" ) NEW_LINE i += 1 NEW_LINE k += 1 NEW_LINE k += 1 NEW_LINE DEDENT elif ( arr2 [ j ] < arr1 [ i ] ) : NEW_LINE INDENT print ( arr2 [ j ] , end = \" ▁ \" ) NEW_LINE k += 1 NEW_LINE j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT while ( i < n1 ) : NEW_LINE INDENT print ( arr1 [ i ] , end = \" ▁ \" ) NEW_LINE i += 1 NEW_LINE DEDENT while ( j < n2 ) : NEW_LINE INDENT print ( arr2 [ j ] , end = \" ▁ \" ) NEW_LINE j += 1 NEW_LINE k += 1 NEW_LINE DEDENT DEDENT while __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr1 = [ 10 , 20 , 30 ] NEW_LINE arr2 = [ 20 , 25 , 30 , 40 , 50 ] NEW_LINE n1 = len ( arr1 ) NEW_LINE n2 = len ( arr2 ) NEW_LINE printUncommon ( arr1 , arr2 , n1 , n2 ) NEW_LINE DEDENT"],"references":["def printUncommon ( arr1 , arr2 , n1 , n2 ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE k = 0 NEW_LINE while ( i < n1 and j < n2 ) : NEW_LINE INDENT if ( arr1 [ i ] < arr2 [ j ] ) : NEW_LINE INDENT print ( arr1 [ i ] , end = \" ▁ \" ) NEW_LINE i = i + 1 NEW_LINE k = k + 1 NEW_LINE DEDENT elif ( arr2 [ j ] < arr1 [ i ] ) : NEW_LINE INDENT print ( arr2 [ j ] , end = \" ▁ \" ) NEW_LINE k = k + 1 NEW_LINE j = j + 1 NEW_LINE DEDENT else : NEW_LINE INDENT i = i + 1 NEW_LINE j = j + 1 NEW_LINE DEDENT DEDENT while ( i < n1 ) : NEW_LINE INDENT print ( arr1 [ i ] , end = \" ▁ \" ) NEW_LINE i = i + 1 NEW_LINE k = k + 1 NEW_LINE DEDENT while ( j < n2 ) : NEW_LINE INDENT print ( arr2 [ j ] , end = \" ▁ \" ) NEW_LINE j = j + 1 NEW_LINE k = k + 1 NEW_LINE DEDENT DEDENT arr1 = [ 10 , 20 , 30 ] NEW_LINE arr2 = [ 20 , 25 , 30 , 40 , 50 ] NEW_LINE n1 = len ( arr1 ) NEW_LINE n2 = len ( arr2 ) NEW_LINE printUncommon ( arr1 , arr2 , n1 , n2 ) NEW_LINE"],"bleu":0.82120123378894,"rouge_l":0.8838361663425954}
{"id":1562,"predictions":["def findExtraChar ( s1 , s2 ) : NEW_LINE INDENT smallStr = s1 NEW_LINE if ( len ( s1 ) > len ( s2 ) ) : NEW_LINE INDENT smallStr = s2 NEW_LINE largeStr = s1 NEW_LINE DEDENT else : NEW_LINE INDENT smallStr = s1 NEW_LINE largeStr = s2 NEW_LINE DEDENT smallStrCodeTotal = 0 NEW_LINE largeStrCount = 0 NEW_LINE i = 0 NEW_LINE for i in range ( len ( smallStr ) ) : NEW_LINE INDENT smallStrCount += smallStr [ i ] NEW_LINE largeStrCountTotal += largeStr [ i ] NEW_LINE DEDENT largeStrCount += largeStr [ i ] NEW_LINE return chr ( largeStr2 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s1 = \" abcd \" NEW_LINE s2 = \" cbdde \" NEW_LINE extraChar = findExtraCharacter ( s1 , s2 ) NEW_LINE print ( \" Extra ▁ character : \" , extraChar ) NEW_LINE DEDENT"],"references":["def findExtraCharacter ( s1 , s2 ) : NEW_LINE INDENT smallStr = \" \" NEW_LINE largeStr = \" \" NEW_LINE if ( len ( s1 ) > len ( s2 ) ) : NEW_LINE INDENT smallStr = s2 NEW_LINE largeStr = s1 NEW_LINE DEDENT else : NEW_LINE INDENT smallStr = s1 NEW_LINE largeStr = s2 NEW_LINE DEDENT smallStrCodeTotal = 0 NEW_LINE largeStrCodeTotal = 0 NEW_LINE i = 0 NEW_LINE while ( i < len ( smallStr ) ) : NEW_LINE INDENT smallStrCodeTotal += ord ( smallStr [ i ] ) NEW_LINE largeStrCodeTotal += ord ( largeStr [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT largeStrCodeTotal += ord ( largeStr [ i ] ) NEW_LINE intChar = largeStrCodeTotal - smallStrCodeTotal NEW_LINE return chr ( intChar ) NEW_LINE DEDENT s1 = \" abcd \" NEW_LINE s2 = \" cbdae \" NEW_LINE extraChar = findExtraCharacter ( s1 , s2 ) NEW_LINE print ( \" Extra ▁ Character : \" , extraChar ) NEW_LINE"],"bleu":0.6289185396628606,"rouge_l":0.7916320598006644}
{"id":1563,"predictions":["row = 4 NEW_LINE def sortMat ( data , row , col ) : NEW_LINE INDENT size = row * col NEW_LINE for i in range ( size - 1 ) : NEW_LINE INDENT for j in range ( size - 1 ) : NEW_LINE INDENT if ( data [ j \/\/ col ] [ j % col ] > data [ ( j + 1 ) % col ] [ ( j + 1 ) % col ] ) : NEW_LINE INDENT temp = data [ j \/\/ col ] [ ( j \/\/ col ) NEW_LINE data [ ( j \/\/ col ) % col ] [ ( j + 1 ) % col ] [ ( j + 1 ) % col ] [ ( j + 1 ) % col ] [ ( j + 1 ) % col ] [ ( j + 1 ) % col ] [ ( j + 1 ) % col ] [ ( j + 1 ) % col ] [ ( j + 1 ) % col ] [ ( j + 1 ) % col ] [ ( j + 1 ) % col ] = temp NEW_LINE DEDENT DEDENT DEDENT DEDENT def printMat ( mat , row , col ) : NEW_LINE INDENT for i in range ( 0 , row ) : NEW_LINE INDENT for j in range ( 0 , col ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT mat = [ [ 5 , 4 , 7 ] , [ 1 , 3 , 8 ] , [ 2 , 9 , 6 ] ] NEW_LINE row = len ( mat ) NEW_LINE sortMat ( mat , row , col ) NEW_LINE printMat ( mat , row , col ) NEW_LINE"],"references":["def sortMat ( data , row , col ) : NEW_LINE INDENT size = row * col NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT for j in range ( 0 , size - 1 ) : NEW_LINE INDENT if ( data [ j \/\/ col ] [ j % col ] > \\ data [ ( j + 1 ) \/\/ col ] [ ( j + 1 ) % col ] ) : NEW_LINE INDENT temp = data [ j \/\/ col ] [ j % col ] NEW_LINE data [ j \/\/ col ] [ j % col ] = \\ NEW_LINE INDENT data [ ( j + 1 ) \/\/ col ] [ ( j + 1 ) % col ] NEW_LINE DEDENT data [ ( j + 1 ) \/\/ col ] [ ( j + 1 ) % col ] = \\ NEW_LINE INDENT temp NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def printMat ( mat , row , col ) : NEW_LINE INDENT for i in range ( row ) : NEW_LINE INDENT for j in range ( col ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT mat = [ [ 5 , 4 , 7 ] , [ 1 , 3 , 8 ] , [ 2 , 9 , 6 ] ] NEW_LINE row = len ( mat ) NEW_LINE col = len ( mat [ 0 ] ) NEW_LINE sortMat ( mat , row , col ) NEW_LINE printMat ( mat , row , col ) NEW_LINE DEDENT"],"bleu":0.721394308573926,"rouge_l":0.8179321486268174}
{"id":1564,"predictions":["def distinctDigitSum ( n ) : NEW_LINE INDENT used = [ False for i in range ( 10 ) ] NEW_LINE sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT digit = n % 10 NEW_LINE if ( not in visited [ digit ] ) : NEW_LINE INDENT sum [ digit ] = True NEW_LINE sum += digit NEW_LINE DEDENT n = n \/\/ 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT def checkSum ( m , n ) : NEW_LINE INDENT sumM = distinctDigitSum ( m ) NEW_LINE sumN = distinctDigitSum ( n ) NEW_LINE if ( sumM == sumN ) : NEW_LINE INDENT return \" YES \" NEW_LINE DEDENT else : NEW_LINE INDENT return \" NO \" NEW_LINE DEDENT DEDENT m = 2452 NEW_LINE n = 922 NEW_LINE print ( checkSum ( m , n ) ) NEW_LINE"],"references":["def distinctDigitSum ( n ) : NEW_LINE INDENT used = [ False ] * 10 NEW_LINE sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT digit = n % 10 NEW_LINE if ( not used [ digit ] ) : NEW_LINE INDENT used [ digit ] = True NEW_LINE sum += digit NEW_LINE DEDENT n = n \/\/ 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT def checkSum ( m , n ) : NEW_LINE INDENT sumM = distinctDigitSum ( m ) NEW_LINE sumN = distinctDigitSum ( n ) NEW_LINE if ( sumM == sumN ) : NEW_LINE INDENT return \" YES \" NEW_LINE DEDENT return \" NO \" NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT m = 2452 NEW_LINE n = 9222 NEW_LINE print ( checkSum ( m , n ) ) NEW_LINE DEDENT"],"bleu":0.8131917750607002,"rouge_l":0.8772505944966594}
{"id":1565,"predictions":["def initializeDiffArray ( A , D ) : NEW_LINE INDENT n = len ( A ) NEW_LINE D [ 0 ] = A [ 0 ] NEW_LINE D [ n ] = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT D [ i ] = A [ i ] - A [ i - 1 ] NEW_LINE DEDENT def update ( D , l , r , x ) : NEW_LINE INDENT D [ l ] += x NEW_LINE D [ r + 1 ] -= x NEW_LINE DEDENT def printArray ( A , D ) : NEW_LINE INDENT for i in range ( 0 , len ( A ) ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT A [ i ] = D [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT A [ i ] = D [ i ] + A [ i - 1 ] NEW_LINE DEDENT print ( A [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE return 0 NEW_LINE DEDENT A = [ 10 , 5 , 20 , 40 ] NEW_LINE n = len ( A ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 10 , 5 , 20 , 40 ] NEW_LINE n = len ( A ) NEW_LINE DEDENT"],"references":["def initializeDiffArray ( A ) : NEW_LINE INDENT n = len ( A ) NEW_LINE D = [ 0 for i in range ( 0 , n + 1 ) ] NEW_LINE D [ 0 ] = A [ 0 ] ; D [ n ] = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT D [ i ] = A [ i ] - A [ i - 1 ] NEW_LINE DEDENT return D NEW_LINE DEDENT def update ( D , l , r , x ) : NEW_LINE INDENT D [ l ] += x NEW_LINE D [ r + 1 ] -= x NEW_LINE DEDENT def printArray ( A , D ) : NEW_LINE INDENT for i in range ( 0 , len ( A ) ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT A [ i ] = D [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT A [ i ] = D [ i ] + A [ i - 1 ] NEW_LINE DEDENT print ( A [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( \" \" ) NEW_LINE DEDENT A = [ 10 , 5 , 20 , 40 ] NEW_LINE D = initializeDiffArray ( A ) NEW_LINE update ( D , 0 , 1 , 10 ) NEW_LINE printArray ( A , D ) NEW_LINE update ( D , 1 , 3 , 20 ) NEW_LINE update ( D , 2 , 2 , 30 ) NEW_LINE printArray ( A , D ) NEW_LINE"],"bleu":0.733461801975519,"rouge_l":0.8076627862351284}
{"id":1566,"predictions":["MAX = 100 ; NEW_LINE def printPrincipalDiagonal ( mat , n ) : NEW_LINE INDENT print ( \" Principal ▁ Diagonal : ▁ \" , end = \" \" ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , \" , ▁ \" , end = \" \" ) ; NEW_LINE DEDENT DEDENT DEDENT print ( \" \" ) ; NEW_LINE DEDENT def printSecondaryDiagonal ( mat , n ) : NEW_LINE INDENT print ( \" Secondary ▁ Diagonal : ▁ \" ) ; NEW_LINE for i in range ( n ) : ; NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( ( i + j ) == ( n - 1 ) ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = \" , ▁ \" ) ; NEW_LINE DEDENT DEDENT DEDENT print ( \" \" ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 ; NEW_LINE a = [ [ 1 , 2 , 3 , 4 ] , [ 5 , 6 , 7 , 8 ] , [ 1 , 2 , 3 , 4 ] , [ 5 , 6 , 7 , 8 ] ] ; NEW_LINE printPrincipalDiagonal ( a , n ) ; NEW_LINE printSecondaryDiagonal ( a , n ) ; NEW_LINE printSecondaryDiagonal ( a , n ) ; NEW_LINE DEDENT"],"references":["MAX = 100 NEW_LINE def printPrincipalDiagonal ( mat , n ) : NEW_LINE INDENT print ( \" Principal ▁ Diagonal : ▁ \" , end = \" \" ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = \" , ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT print ( ) NEW_LINE DEDENT def printSecondaryDiagonal ( mat , n ) : NEW_LINE INDENT print ( \" Secondary ▁ Diagonal : ▁ \" , end = \" \" ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( ( i + j ) == ( n - 1 ) ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = \" , ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT print ( ) NEW_LINE DEDENT n = 4 NEW_LINE a = [ [ 1 , 2 , 3 , 4 ] , [ 5 , 6 , 7 , 8 ] , [ 1 , 2 , 3 , 4 ] , [ 5 , 6 , 7 , 8 ] ] NEW_LINE printPrincipalDiagonal ( a , n ) NEW_LINE printSecondaryDiagonal ( a , n ) NEW_LINE"],"bleu":0.7783335643015804,"rouge_l":0.9132452928870293}
{"id":1567,"predictions":["def FindMinNumber ( arr , n , k ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE min_num = sys . maxsize NEW_LINE found = 0 NEW_LINE sum = 0 NEW_LINE while i < n : NEW_LINE INDENT sum = sum + arr [ i ] NEW_LINE if ( sum == k ) : NEW_LINE INDENT min_num = min ( min_num , ( ( n - ( i + 1 ) ) + j ) ) NEW_LINE found = True NEW_LINE DEDENT elif ( sum > k ) : NEW_LINE INDENT while ( sum > k ) : NEW_LINE INDENT sum = sum - arr [ j ] NEW_LINE j += 1 NEW_LINE DEDENT if ( sum == k ) : NEW_LINE INDENT min_num = min ( min_num , ( ( n - ( i + 1 ) ) + j ) ) NEW_LINE found = True NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT if ( found ) : NEW_LINE INDENT return min_num NEW_LINE DEDENT return - 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 3 , 2 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE k = 5 NEW_LINE print ( FindMinNumber ( arr , n , k ) ) NEW_LINE DEDENT"],"references":["def FindMinNumber ( arr , n , k ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE min_num = 10 ** 9 NEW_LINE found = False NEW_LINE Sum = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT Sum = Sum + arr [ i ] NEW_LINE if ( Sum == k ) : NEW_LINE INDENT min_num = min ( min_num , ( ( n - ( i + 1 ) ) + j ) ) NEW_LINE found = True NEW_LINE DEDENT elif ( Sum > k ) : NEW_LINE INDENT while ( Sum > k ) : NEW_LINE INDENT Sum = Sum - arr [ j ] NEW_LINE j += 1 NEW_LINE DEDENT if ( Sum == k ) : NEW_LINE INDENT min_num = min ( min_num , ( ( n - ( i + 1 ) ) + j ) ) NEW_LINE found = True NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT if ( found ) : NEW_LINE INDENT return min_num NEW_LINE DEDENT return - 1 NEW_LINE DEDENT arr = [ 1 , 3 , 2 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE k = 5 NEW_LINE print ( FindMinNumber ( arr , n , k ) ) NEW_LINE"],"bleu":0.7936314552837096,"rouge_l":0.908598510494245}
{"id":1568,"predictions":["import heapq NEW_LINE def minProduct ( arr , n , k ) : NEW_LINE INDENT pq = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT pq . append ( arr [ i ] ) NEW_LINE DEDENT count = 0 NEW_LINE ans = 1 NEW_LINE while ( len ( pq ) > 0 and count < k ) : NEW_LINE INDENT ans = ans * popleft ( ) NEW_LINE count = count + 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT arr = [ 198 , 76 , 544 , 123 , 154 , 675 ] NEW_LINE k = 2 NEW_LINE n = len ( arr ) NEW_LINE print ( \" Minimum ▁ product ▁ is \" , minProduct ( arr , n , k ) ) NEW_LINE"],"references":["import math NEW_LINE import heapq NEW_LINE def minProduct ( arr , n , k ) : NEW_LINE INDENT heapq . heapify ( arr ) NEW_LINE count = 0 NEW_LINE ans = 1 NEW_LINE while ( arr ) and count < k : NEW_LINE INDENT x = heapq . heappop ( arr ) NEW_LINE ans = ans * x NEW_LINE count = count + 1 NEW_LINE DEDENT return ans ; NEW_LINE DEDENT arr = [ 198 , 76 , 544 , 123 , 154 , 675 ] NEW_LINE k = 2 NEW_LINE n = len ( arr ) NEW_LINE print ( \" Minimum ▁ product ▁ is \" , minProduct ( arr , n , k ) ) NEW_LINE"],"bleu":0.6802542284920768,"rouge_l":0.8189552040409411}
{"id":1569,"predictions":[" BitsSet = [ 0 ] * 256 NEW_LINE def initialize ( ) : NEW_LINE INDENT BitsSetTable [ 0 ] = 0 NEW_LINE for i in range ( 256 ) : NEW_LINE INDENT BitsSet [ i ] = ( i & 1 ) + Bits [ int ( i \/ 2 ) ] NEW_LINE DEDENT DEDENT def initialize ( ) : NEW_LINE INDENT return ( BitsSetTable [ n & 0 ] + BitsSetTable [ ( n >> 8 ) & 0 ) NEW_LINE DEDENT initialize ( ) NEW_LINE n = 9 NEW_LINE print ( countSetBits ( n ) ) NEW_LINE"],"references":["BitsSetTable256 = [ 0 ] * 256 NEW_LINE def initialize ( ) : NEW_LINE INDENT BitsSetTable256 [ 0 ] = 0 NEW_LINE for i in range ( 256 ) : NEW_LINE INDENT BitsSetTable256 [ i ] = ( i & 1 ) + BitsSetTable256 [ i \/\/ 2 ] NEW_LINE DEDENT DEDENT def countSetBits ( n ) : NEW_LINE INDENT return ( BitsSetTable256 [ n & 0xff ] + BitsSetTable256 [ ( n >> 8 ) & 0xff ] + BitsSetTable256 [ ( n >> 16 ) & 0xff ] + BitsSetTable256 [ n >> 24 ] ) NEW_LINE DEDENT initialize ( ) NEW_LINE n = 9 NEW_LINE print ( countSetBits ( n ) ) NEW_LINE"],"bleu":0.6009916158513874,"rouge_l":0.7857998801677651}
{"id":1570,"predictions":["def numberOfBST ( n ) : NEW_LINE INDENT dp = [ 0 for i in range ( n + 1 ) ] NEW_LINE dp [ 0 ] = 1 NEW_LINE dp [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT dp [ i ] = dp [ i ] + ( dp [ i - j ] * dp [ j - 1 ] ) NEW_LINE DEDENT DEDENT return dp [ n ] NEW_LINE DEDENT n = 3 NEW_LINE print ( \" Number ▁ of ▁ substule ▁ BST ▁ with \" , n , \" keys ▁ are \" , numberOfBST ( n ) ) NEW_LINE"],"references":["def numberOfBST ( n ) : NEW_LINE INDENT dp = [ 0 ] * ( n + 1 ) NEW_LINE dp [ 0 ] , dp [ 1 ] = 1 , 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT dp [ i ] = dp [ i ] + ( dp [ i - j ] * dp [ j - 1 ] ) NEW_LINE DEDENT DEDENT return dp [ n ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE print ( \" Number ▁ of ▁ structurally ▁ Unique ▁ BST ▁ with \" , n , \" keys ▁ are ▁ : \" , numberOfBST ( n ) ) NEW_LINE DEDENT"],"bleu":0.7676666307081407,"rouge_l":0.8732541899441342}
{"id":1571,"predictions":["def countdig ( m ) : NEW_LINE INDENT if ( m == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT return 1 + countdig ( m \/\/ 10 ) ; NEW_LINE DEDENT DEDENT def countSteps ( x ) : NEW_LINE INDENT c = 0 ; NEW_LINE last = x ; NEW_LINE while ( last ) : NEW_LINE INDENT digits = countdig ( last ) ; NEW_LINE digits -= 1 ; NEW_LINE sum = first * divisor ; NEW_LINE lastnumber = first * divisor ; NEW_LINE skipped = ( last - lastnumber ) \/\/ first ; NEW_LINE c += 1 ; NEW_LINE last = last - ( first * skipped ) ; NEW_LINE DEDENT return c ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 14 ; NEW_LINE print ( countSteps ( n ) ) ; NEW_LINE DEDENT"],"references":["def countdig ( m ) : NEW_LINE INDENT if ( m == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 + countdig ( m \/\/ 10 ) NEW_LINE DEDENT DEDENT def countSteps ( x ) : NEW_LINE INDENT c = 0 NEW_LINE last = x NEW_LINE while ( last ) : NEW_LINE INDENT digits = countdig ( last ) NEW_LINE digits -= 1 NEW_LINE divisor = pow ( 10 , digits ) NEW_LINE first = last \/\/ divisor NEW_LINE lastnumber = first * divisor NEW_LINE skipped = ( last - lastnumber ) \/\/ first NEW_LINE skipped += 1 NEW_LINE c += skipped NEW_LINE last = last - ( first * skipped ) NEW_LINE DEDENT return c NEW_LINE DEDENT n = 14 NEW_LINE print ( countSteps ( n ) ) NEW_LINE"],"bleu":0.6379165206361399,"rouge_l":0.8452817224003664}
{"id":1572,"predictions":["def Add ( x , y ) : NEW_LINE INDENT while ( y ) : NEW_LINE INDENT carry = x & y NEW_LINE x = x ^ y NEW_LINE y = carry << 1 NEW_LINE DEDENT return x NEW_LINE DEDENT print ( Add ( 15 , 32 ) ) NEW_LINE"],"references":["def Add ( x , y ) : NEW_LINE INDENT while ( y != 0 ) : NEW_LINE INDENT carry = x & y NEW_LINE x = x ^ y NEW_LINE y = carry << 1 NEW_LINE DEDENT return x NEW_LINE DEDENT print ( Add ( 15 , 32 ) ) NEW_LINE"],"bleu":0.9308999419544567,"rouge_l":0.9769378603459321}
{"id":1573,"predictions":["def isOverflow ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT result = a * b NEW_LINE if ( a == result \/\/ b ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = \"10000000000\" NEW_LINE b = 10000000000\" NEW_LINE if ( isOverflow ( a , b ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def isOverflow ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT result = a * b NEW_LINE if ( result >= 9223372036854775807 or result <= - 9223372036854775808 ) : NEW_LINE INDENT result = 0 NEW_LINE DEDENT if ( a == ( result \/\/ b ) ) : NEW_LINE INDENT print ( result \/\/ b ) NEW_LINE return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 10000000000 NEW_LINE b = - 10000000000 NEW_LINE if ( isOverflow ( a , b ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.705824747268153,"rouge_l":0.8507997440818937}
{"id":1574,"predictions":["def pairWithEqualSum ( A , n ) : NEW_LINE INDENT mp = { } ; NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT p = [ A [ i ] , A [ j ] ] NEW_LINE if ( A [ i ] + A [ j ] ) in mp : NEW_LINE INDENT pp . append ( mp [ A [ i ] + A [ j ] ] ) ; NEW_LINE DEDENT pp [ A [ i ] + A [ j ] ] = pp ; NEW_LINE DEDENT DEDENT for itr , mp : NEW_LINE INDENT if ( len ( mp ) > 1 ) : NEW_LINE INDENT print ( \" Pairs ▁ : ▁ \" , end = \" ▁ \" ) ; NEW_LINE for i in mp : NEW_LINE INDENT print ( \" ( { 0 } , ▁ \" , end = \" \" ) ; NEW_LINE DEDENT print ( \" ▁ have ▁ sum ▁ : ▁ \" , end = \" \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 6 , 4 , 12 , 10 , 22 , 54 , 32 , 21 , 21 , 11 , 8 , 2 ] ; NEW_LINE n = len ( A ) ; NEW_LINE pairWithEqualSum ( A , n ) ; NEW_LINE DEDENT"],"references":["def pairWithEqualSum ( A , n ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if A [ i ] + A [ j ] in mp : NEW_LINE INDENT mp [ A [ i ] + A [ j ] ] . append ( ( A [ i ] , A [ j ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT mp [ A [ i ] + A [ j ] ] = [ ( A [ i ] , A [ j ] ) ] NEW_LINE DEDENT DEDENT DEDENT for itr in mp : NEW_LINE INDENT if len ( mp [ itr ] ) > 1 : NEW_LINE INDENT print ( \" Pairs ▁ : ▁ \" , end = \" \" ) NEW_LINE for i in range ( 0 , len ( mp [ itr ] ) ) : NEW_LINE INDENT print ( \" ( \" , mp [ itr ] [ i ] [ 0 ] , \" , \" , mp [ itr ] [ i ] [ 1 ] , \" ) \" , end = \" ▁ \" ) NEW_LINE DEDENT print ( \" have ▁ sum ▁ : \" , itr ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 6 , 4 , 12 , 10 , 22 , 54 , 32 , 42 , 21 , 11 , 8 , 2 ] NEW_LINE n = len ( A ) NEW_LINE pairWithEqualSum ( A , n ) NEW_LINE DEDENT"],"bleu":0.6297221320041133,"rouge_l":0.7670416942422237}
{"id":1575,"predictions":["def findValues ( m , n , mth , nth ) : NEW_LINE INDENT d = ( abs ( mth - nth ) ) \/\/ abs ( ( m - 1 ) - ( n - 1 ) ) NEW_LINE a = mth - ( ( m - 1 ) * d ) NEW_LINE res = a * ( ( m - 1 ) * d ) NEW_LINE return res NEW_LINE DEDENT def findSum ( m , n , mth , nth , p ) : NEW_LINE INDENT a , n = findValues ( m , n , mth , nth ) NEW_LINE a = ad [ 0 ] NEW_LINE d = ad [ 1 ] NEW_LINE sum = ( p * ( 2 * a + ( p - 1 ) * d ) ) \/ 2 NEW_LINE return sum NEW_LINE DEDENT m , n = 6 , 10 , mth , nth , p = 12 , 5 NEW_LINE print ( findSum ( m , n , mth , nth , p ) ) NEW_LINE"],"references":["import math as mt NEW_LINE def findingValues ( m , n , mth , nth ) : NEW_LINE INDENT d = ( ( abs ( mth - nth ) ) \/ abs ( ( m - 1 ) - ( n - 1 ) ) ) NEW_LINE a = mth - ( ( m - 1 ) * d ) NEW_LINE return a , d NEW_LINE DEDENT def findSum ( m , n , mth , nth , p ) : NEW_LINE INDENT a , d = findingValues ( m , n , mth , nth ) NEW_LINE Sum = ( p * ( 2 * a + ( p - 1 ) * d ) ) \/ 2 NEW_LINE return Sum NEW_LINE DEDENT m = 6 NEW_LINE n = 10 NEW_LINE mTerm = 12 NEW_LINE nTerm = 20 NEW_LINE p = 5 NEW_LINE print ( findSum ( m , n , mTerm , nTerm , p ) ) NEW_LINE"],"bleu":0.6549326195479703,"rouge_l":0.784585174275896}
{"id":1576,"predictions":["def sameOccurrence ( arr , n , x , y ) : NEW_LINE INDENT countX = [ 0 ] * n ; NEW_LINE countY = dict ( ) ; NEW_LINE m = dict ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == x ) : NEW_LINE INDENT if ( i != 0 ) : NEW_LINE INDENT countX [ i ] = countX [ i - 1 ] + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT countX [ i ] = 1 ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( i != 0 ) : NEW_LINE INDENT countX [ i ] = countX [ i - 1 ] ; NEW_LINE DEDENT else : NEW_LINE INDENT countY [ i ] = 0 ; NEW_LINE DEDENT DEDENT if ( arr [ i ] == y ) : NEW_LINE INDENT if ( i != 0 ) : NEW_LINE INDENT countY [ i ] = countY [ i - 1 ] + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT countY [ i ] = 1 ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( i != 0 ) : NEW_LINE INDENT countY [ i ] = countY [ i - 1 ] ; NEW_LINE DEDENT else : NEW_LINE INDENT m [ i ] = 0 ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 2 , 3 , 4 , 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE x = 2 ; NEW_LINE y = 3 ; NEW_LINE print ( sameOccurrence ( arr , n , x , y ) ) ; NEW_LINE DEDENT"],"references":["def sameOccurrence ( arr , n , x , y ) : NEW_LINE INDENT countX = [ 0 for i in range ( n ) ] NEW_LINE countY = [ 0 for i in range ( n ) ] NEW_LINE m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == x ) : NEW_LINE INDENT if ( i != 0 ) : NEW_LINE INDENT countX [ i ] = countX [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT countX [ i ] = 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( i != 0 ) : NEW_LINE INDENT countX [ i ] = countX [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT countX [ i ] = 0 NEW_LINE DEDENT DEDENT if ( arr [ i ] == y ) : NEW_LINE INDENT if ( i != 0 ) : NEW_LINE INDENT countY [ i ] = countY [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT countY [ i ] = 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( i != 0 ) : NEW_LINE INDENT countY [ i ] = countY [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT countY [ i ] = 0 NEW_LINE DEDENT DEDENT m [ countX [ i ] - countY [ i ] ] = m . get ( countX [ i ] - countY [ i ] , 0 ) + 1 NEW_LINE DEDENT result = m [ 0 ] NEW_LINE for j in m : NEW_LINE INDENT result += ( m [ j ] * ( m [ j ] - 1 ) ) \/\/ 2 NEW_LINE DEDENT return result NEW_LINE DEDENT arr = [ 1 , 2 , 2 , 3 , 4 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE x , y = 2 , 3 NEW_LINE print ( sameOccurrence ( arr , n , x , y ) ) NEW_LINE"],"bleu":0.6564520494817654,"rouge_l":0.7954260494508251}
{"id":1577,"predictions":["def findNonPalinString ( s ) : NEW_LINE INDENT freq = [ 0 for i in range ( 26 ) ] NEW_LINE flag = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] != s [ 0 ] ) : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT if ( flag == 0 ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 26 ) : NEW_LINE INDENT print ( chr ( 97 + i ) , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" abba \" NEW_LINE findNonPalinString ( s ) NEW_LINE DEDENT"],"references":["def findNonPalinString ( s ) : NEW_LINE INDENT freq = [ 0 ] * ( 26 ) NEW_LINE flag = 0 NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT if s [ i ] != s [ 0 ] : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT if not flag : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 0 , 26 ) : NEW_LINE INDENT for j in range ( 0 , freq [ i ] ) : NEW_LINE INDENT print ( chr ( ord ( ' a ' ) + i ) , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" abba \" NEW_LINE findNonPalinString ( s ) NEW_LINE DEDENT"],"bleu":0.7451479586227442,"rouge_l":0.8525892408245348}
{"id":1578,"predictions":["def isFrequencyEqual ( string , length ) : NEW_LINE INDENT if ( len ( string ) % 2 == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT freq = [ 0 for i in range ( 26 ) ] NEW_LINE for i in range ( 0 , 26 ) : NEW_LINE INDENT freq [ ord ( string [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( freq [ i ] == length \/ 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT string = \" geeksforgeeks \" NEW_LINE length = len ( string ) NEW_LINE if ( isFrequencyEqual ( string , length ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def isFrequencyEqual ( string , length ) : NEW_LINE INDENT if length % 2 == 1 : NEW_LINE INDENT return False NEW_LINE DEDENT freq = [ 0 ] * 26 NEW_LINE for i in range ( 0 , length ) : NEW_LINE INDENT freq [ ord ( string [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 0 , 26 ) : NEW_LINE INDENT if freq [ i ] == length \/\/ 2 : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" geeksforgeeks \" NEW_LINE length = len ( string ) NEW_LINE if isFrequencyEqual ( string , length ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.7755293331367847,"rouge_l":0.9124200536414276}
{"id":1579,"predictions":["import math NEW_LINE def summ ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( n % 9 == 0 ) else ( n % 9 ) NEW_LINE DEDENT def printDigitalRoot ( n ) : NEW_LINE INDENT maxi = 1 NEW_LINE dig = 1 NEW_LINE for i in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT d1 = summ ( n \/\/ i ) NEW_LINE d2 = d1 NEW_LINE if ( d1 > maxi ) : NEW_LINE INDENT dig = n \/\/ i NEW_LINE maxi = d1 NEW_LINE DEDENT if ( d2 > maxi ) : NEW_LINE INDENT dig = i NEW_LINE maxi = d2 NEW_LINE DEDENT if ( d1 == maxi ) : NEW_LINE INDENT if dig < i ) : NEW_LINE INDENT dig = n \/\/ i NEW_LINE maxi = d1 NEW_LINE DEDENT DEDENT DEDENT if ( d2 == maxi ) : NEW_LINE INDENT if dig < i : NEW_LINE INDENT dig = i NEW_LINE maxi = d2 NEW_LINE DEDENT DEDENT DEDENT print ( dig , \" ▁ \" , maxi ) NEW_LINE DEDENT n = 10 NEW_LINE printDigitalRoot ( n ) NEW_LINE"],"references":["def summ ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( n % 9 == 0 ) : NEW_LINE INDENT return 9 ; NEW_LINE DEDENT else : NEW_LINE INDENT return ( n % 9 ) ; NEW_LINE DEDENT DEDENT def printDigitalRoot ( n ) : NEW_LINE INDENT maxi = 1 ; NEW_LINE dig = 1 ; NEW_LINE for i in range ( 1 , int ( pow ( n , 1 \/ 2 ) + 1 ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT d1 = summ ( n \/ i ) ; NEW_LINE d2 = summ ( i ) ; NEW_LINE if ( d1 > maxi ) : NEW_LINE INDENT dig = n \/ i ; NEW_LINE maxi = d1 ; NEW_LINE DEDENT if ( d2 > maxi ) : NEW_LINE INDENT dig = i ; NEW_LINE maxi = d2 ; NEW_LINE DEDENT if ( d1 == maxi ) : NEW_LINE INDENT if ( dig < ( n \/ i ) ) : NEW_LINE INDENT dig = n \/ i ; NEW_LINE maxi = d1 ; NEW_LINE DEDENT DEDENT if ( d2 == maxi ) : NEW_LINE INDENT if ( dig < i ) : NEW_LINE INDENT dig = i ; NEW_LINE maxi = d2 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( int ( dig ) , \" ▁ \" , int ( maxi ) ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 ; NEW_LINE printDigitalRoot ( n ) ; NEW_LINE DEDENT"],"bleu":0.5564400946555373,"rouge_l":0.8108546232654649}
{"id":1580,"predictions":["def countSubarrays ( arr , n ) : NEW_LINE INDENT difference = 0 NEW_LINE ans = 0 NEW_LINE hash_positive = [ 0 ] * ( n + 1 ) NEW_LINE hash_positive = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT difference += 1 NEW_LINE DEDENT else : NEW_LINE INDENT difference -= 1 NEW_LINE DEDENT if ( difference < 0 ) : NEW_LINE INDENT ans += hash_negative [ - difference ] NEW_LINE hash_negative [ - difference ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += hash_positive [ difference ] NEW_LINE hash_positive [ difference ] += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 4 , 6 , 8 , 1 , 10 , 5 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Total ▁ Number ▁ of ▁ Even - Oddarrays ▁ are \" , countSubarrays ( arr , n ) ) NEW_LINE DEDENT"],"references":["def countSubarrays ( arr , n ) : NEW_LINE INDENT difference = 0 NEW_LINE ans = 0 NEW_LINE hash_positive = [ 0 ] * ( n + 1 ) NEW_LINE hash_negative = [ 0 ] * ( n + 1 ) NEW_LINE hash_positive [ 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 == 1 ) : NEW_LINE INDENT difference = difference + 1 NEW_LINE DEDENT else : NEW_LINE INDENT difference = difference - 1 NEW_LINE DEDENT if ( difference < 0 ) : NEW_LINE INDENT ans += hash_negative [ - difference ] NEW_LINE hash_negative [ - difference ] = hash_negative [ - difference ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += hash_positive [ difference ] NEW_LINE hash_positive [ difference ] = hash_positive [ difference ] + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 3 , 4 , 6 , 8 , 1 , 10 , 5 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Total ▁ Number ▁ of ▁ Even - Odd ▁ subarrays ▁ are ▁ \" + str ( countSubarrays ( arr , n ) ) ) NEW_LINE"],"bleu":0.756670802787471,"rouge_l":0.8496234512916025}
{"id":1581,"predictions":["def sieve ( ) : NEW_LINE INDENT prime = [ True ] * ( MAX + 1 ) NEW_LINE prime [ 0 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= MAX : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT def distinctSum ( arr1 , arr2 , m , n ) : NEW_LINE INDENT sieve ( ) NEW_LINE sumSet = set ( ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( prime [ arr1 [ i ] ] and prime [ arr2 [ j ] ] ) : NEW_LINE INDENT sumSet . add ( arr1 [ i ] + arr2 [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return len ( sumSet ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr1 = [ 2 , 3 ] NEW_LINE arr2 = [ 2 , 2 , 4 , 7 ] NEW_LINE m = len ( arr1 ) NEW_LINE n = len ( arr2 ) NEW_LINE print ( distinctSum ( arr1 , arr2 , m , n ) ) NEW_LINE DEDENT"],"references":["MAX = 1000000 NEW_LINE prime = [ True for i in range ( MAX + 1 ) ] NEW_LINE def sieve ( ) : NEW_LINE INDENT prime [ 0 ] , prime [ 1 ] = False , False NEW_LINE for p in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if p * p > MAX : NEW_LINE INDENT break NEW_LINE DEDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( 2 * p , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def distinctSum ( arr1 , arr2 , m , n ) : NEW_LINE INDENT sieve ( ) NEW_LINE sumSet = dict ( ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( prime [ arr1 [ i ] ] and prime [ arr2 [ j ] ] ) : NEW_LINE INDENT sumSet [ arr1 [ i ] + arr2 [ j ] ] = 1 NEW_LINE DEDENT DEDENT DEDENT return len ( sumSet ) NEW_LINE DEDENT arr1 = [ 2 , 3 ] NEW_LINE arr2 = [ 2 , 2 , 4 , 7 ] NEW_LINE m = len ( arr1 ) NEW_LINE n = len ( arr2 ) NEW_LINE print ( distinctSum ( arr1 , arr2 , m , n ) ) NEW_LINE"],"bleu":0.7763665809524884,"rouge_l":0.8329483695652172}
{"id":1582,"predictions":["def shufleArray ( a , n ) : NEW_LINE INDENT n = int ( n \/ 2 ) NEW_LINE start = 0 NEW_LINE j = n + 1 NEW_LINE done = 0 NEW_LINE while ( True ) : NEW_LINE INDENT if ( start == j ) : NEW_LINE INDENT start -= 1 NEW_LINE j -= 1 NEW_LINE DEDENT i = j - n NEW_LINE if ( j > n ) : NEW_LINE INDENT start -= 1 NEW_LINE DEDENT j = j - 1 NEW_LINE if ( j > n ) : NEW_LINE INDENT start = j - n NEW_LINE DEDENT else : NEW_LINE INDENT j = 2 * i - 1 NEW_LINE DEDENT temp = a [ start ] NEW_LINE a [ start ] = a [ j ] NEW_LINE a [ j ] = temp NEW_LINE DEDENT DEDENT a = [ - 1 , 1 , 3 , 5 , 7 , 2 , 4 , 6 , 8 ] NEW_LINE n = len ( a ) NEW_LINE shufleArray ( a , n ) ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT print ( a [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT"],"references":["def shufleArray ( a , n ) : NEW_LINE INDENT n = n \/\/ 2 NEW_LINE start = n + 1 NEW_LINE j = n + 1 NEW_LINE for done in range ( 2 * n - 2 ) : NEW_LINE INDENT if ( start == j ) : NEW_LINE INDENT start -= 1 NEW_LINE j -= 1 NEW_LINE DEDENT i = j - n if j > n else j NEW_LINE j = 2 * i if j > n else 2 * i - 1 NEW_LINE a [ start ] , a [ j ] = a [ j ] , a [ start ] NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ - 1 , 1 , 3 , 5 , 7 , 2 , 4 , 6 , 8 ] NEW_LINE n = len ( a ) NEW_LINE shufleArray ( a , n ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT print ( a [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.6573563517494504,"rouge_l":0.7864004044489383}
{"id":1583,"predictions":["MAX = 100005 NEW_LINE def Min_Replace ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE freq = [ 0 ] * MAX NEW_LINE p = 0 NEW_LINE freq [ p ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i - 1 ] ) : NEW_LINE INDENT freq [ p ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ p ] += 1 NEW_LINE DEDENT DEDENT freq . sort ( reverse = True ) NEW_LINE ans = 0 NEW_LINE for i in range ( k , p + 1 ) : NEW_LINE INDENT ans += freq [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 7 , 8 , 2 , 3 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE print ( Min_Replace ( arr , n , k ) ) NEW_LINE DEDENT"],"references":["MAX = 100005 NEW_LINE def Min_Replace ( arr , n , k ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE freq = [ 0 for i in range ( MAX ) ] NEW_LINE p = 0 NEW_LINE freq [ p ] = 1 NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i - 1 ] ) : NEW_LINE INDENT freq [ p ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT p += 1 NEW_LINE freq [ p ] += 1 NEW_LINE DEDENT DEDENT freq . sort ( reverse = True ) NEW_LINE ans = 0 NEW_LINE for i in range ( k , p + 1 , 1 ) : NEW_LINE INDENT ans += freq [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 7 , 8 , 2 , 3 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE print ( Min_Replace ( arr , n , k ) ) NEW_LINE DEDENT"],"bleu":0.8466394420134898,"rouge_l":0.9315697237753483}
{"id":1584,"predictions":["MAX = 500 ; NEW_LINE size = 1 ; NEW_LINE def factorial ( prevFact , prev , n ) : NEW_LINE INDENT for x in range ( prev + 1 , n + 1 ) : NEW_LINE INDENT size = multiply ( x , prevFact , size ) ; NEW_LINE DEDENT i = range ( size - 1 , 0 , - 1 ) ; NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT print ( prevFact [ i ] , end = \" \" ) ; NEW_LINE i -= 1 ; NEW_LINE DEDENT print ( \" ▁ \" , end = \" \" ) ; NEW_LINE print ( \" ▁ \" ) ; NEW_LINE DEDENT def printf ( x ) : NEW_LINE INDENT if ( limit < 1 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT a = 1 ; NEW_LINE b = 1 ; NEW_LINE c = 2 ; NEW_LINE print ( a , b , end = \" ▁ \" ) ; NEW_LINE prevFact [ 0 ] = 1 ; NEW_LINE while ( c < limit ) : NEW_LINE INDENT factorial ( prevFact , b , c ) ; NEW_LINE a = b ; NEW_LINE b = c ; NEW_LINE c = a + b ; NEW_LINE DEDENT DEDENT def multiply ( x , prevFactorial , size ) : NEW_LINE INDENT carry = 0 ; NEW_LINE for i in range ( size ) : NEW_LINE INDENT prod = prevFact [ i ] * x + carry ; NEW_LINE prevFact [ i ] = prod % 10 ; NEW_LINE carry = prod \/ 10 ; NEW_LINE DEDENT return size ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT limit = 20 ; NEW_LINE printfibFactorials ( limit ) ; NEW_LINE DEDENT"],"references":["MAX = 500 NEW_LINE size = 1 NEW_LINE def factorial ( prevFact , prev , n ) : NEW_LINE INDENT global size NEW_LINE for x in range ( ( prev + 1 ) , n + 1 ) : NEW_LINE INDENT size = multiply ( x , prevFact , size ) NEW_LINE DEDENT for i in range ( ( size - 1 ) , - 1 , - 1 ) : NEW_LINE INDENT print ( prevFact [ i ] , end = \" \" ) NEW_LINE DEDENT print ( end = \" ▁ \" ) NEW_LINE DEDENT def printfibFactorials ( limit ) : NEW_LINE INDENT if ( limit < 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT a = 1 NEW_LINE b = 1 NEW_LINE c = 2 NEW_LINE print ( a , b , end = \" ▁ \" ) NEW_LINE prevFact = [ 0 ] * MAX NEW_LINE prevFact [ 0 ] = 1 NEW_LINE while ( c < limit ) : NEW_LINE INDENT factorial ( prevFact , b , c ) NEW_LINE a = b NEW_LINE b = c NEW_LINE c = a + b NEW_LINE DEDENT DEDENT def multiply ( x , prevFact , size ) : NEW_LINE INDENT carry = 0 NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT prod = prevFact [ i ] * x + carry NEW_LINE prevFact [ i ] = prod % 10 NEW_LINE carry = prod \/\/ 10 NEW_LINE DEDENT while ( carry != 0 ) : NEW_LINE INDENT prevFact [ size ] = carry % 10 NEW_LINE carry = carry \/\/ 10 NEW_LINE size = size + 1 NEW_LINE DEDENT return size NEW_LINE DEDENT limit = 20 NEW_LINE printfibFactorials ( limit ) NEW_LINE"],"bleu":0.6152691894056722,"rouge_l":0.7956521739130435}
{"id":1585,"predictions":["MAX = 3000 NEW_LINE def niceNumber ( n ) : NEW_LINE INDENT primes = [ 0 ] * MAX NEW_LINE result = [ ] * ( MAX ) NEW_LINE for i in range ( 2 , MAX ) : NEW_LINE INDENT if ( primes [ i ] == 0 ) : NEW_LINE INDENT primes [ i ] = 1 NEW_LINE for j in range ( i * 2 , MAX , i ) : NEW_LINE INDENT primes [ j ] -= 1 NEW_LINE if ( ( primes [ j ] + 3 ) == 0 ) : NEW_LINE INDENT result . append ( j ) NEW_LINE DEDENT DEDENT DEDENT DEDENT result . sort ( ) NEW_LINE return result [ n - 1 ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 50 NEW_LINE print ( smartNumber ( n ) ) NEW_LINE DEDENT"],"references":["MAX = 3000 ; NEW_LINE def smartNumber ( n ) : NEW_LINE INDENT primes = [ 0 ] * MAX ; NEW_LINE result = [ ] ; NEW_LINE for i in range ( 2 , MAX ) : NEW_LINE INDENT if ( primes [ i ] == 0 ) : NEW_LINE INDENT primes [ i ] = 1 ; NEW_LINE j = i * 2 ; NEW_LINE while ( j < MAX ) : NEW_LINE INDENT primes [ j ] -= 1 ; NEW_LINE if ( ( primes [ j ] + 3 ) == 0 ) : NEW_LINE INDENT result . append ( j ) ; NEW_LINE DEDENT j = j + i ; NEW_LINE DEDENT DEDENT DEDENT result . sort ( ) ; NEW_LINE return result [ n - 1 ] ; NEW_LINE DEDENT n = 50 ; NEW_LINE print ( smartNumber ( n ) ) ; NEW_LINE"],"bleu":0.6854437266696576,"rouge_l":0.8310626702997276}
{"id":1586,"predictions":["def countPairs ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for x in range ( 1 , n ) : NEW_LINE INDENT for y in range ( x + 1 , n + 1 ) : NEW_LINE INDENT if ( ( y + x ) % ( y ^ x ) == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT n = 6 NEW_LINE print ( countPairs ( n ) ) NEW_LINE"],"references":["def countPairs ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE for x in range ( 1 , n ) : NEW_LINE INDENT for y in range ( x + 1 , n + 1 ) : NEW_LINE INDENT if ( ( y + x ) % ( y ^ x ) == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 6 ; NEW_LINE print ( countPairs ( n ) ) ; NEW_LINE DEDENT"],"bleu":0.7124096989636196,"rouge_l":0.879704537460429}
{"id":1587,"predictions":["def AllIndexesRecursive ( arr , x , start ) : NEW_LINE INDENT if ( start == len ( arr ) ) : NEW_LINE INDENT ans = [ 0 for i in range ( len ( smallIndex ) + 1 ) ] NEW_LINE return ans NEW_LINE DEDENT smallIndex = AllIndexesRecursive ( arr , x , start + 1 ) NEW_LINE if ( arr [ start ] == x ) : NEW_LINE INDENT myAns [ 0 ] = start NEW_LINE for i in range ( len ( smallIndex ) ) : NEW_LINE INDENT myAns [ i + 1 ] = smallIndex [ i ] NEW_LINE DEDENT return myAns NEW_LINE DEDENT else : NEW_LINE INDENT return smallIndex NEW_LINE DEDENT DEDENT def AllIndexes ( arr , x , 0 ) : NEW_LINE INDENT return smallIndexesRecursive ( arr , x , 0 ) NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 2 , 2 , 5 ] NEW_LINE x = 2 NEW_LINE result = allIndexesRecursive ( arr , x ) NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT print ( result [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT"],"references":["def AllIndexesRecursive ( input , x , start ) : NEW_LINE INDENT if ( start == len ( input ) ) : NEW_LINE INDENT ans = [ ] NEW_LINE return ans NEW_LINE DEDENT smallIndex = AllIndexesRecursive ( input , x , start + 1 ) NEW_LINE if ( input [ start ] == x ) : NEW_LINE INDENT myAns = [ 0 for i in range ( len ( smallIndex ) + 1 ) ] NEW_LINE myAns [ 0 ] = start NEW_LINE for i in range ( len ( smallIndex ) ) : NEW_LINE INDENT myAns [ i + 1 ] = smallIndex [ i ] NEW_LINE DEDENT return myAns NEW_LINE DEDENT else : NEW_LINE INDENT return smallIndex NEW_LINE DEDENT DEDENT def AllIndexes ( input , x ) : NEW_LINE INDENT return AllIndexesRecursive ( input , x , 0 ) NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 2 , 2 , 5 ] NEW_LINE x = 2 NEW_LINE output = AllIndexes ( arr , x ) NEW_LINE for i in output : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT"],"bleu":0.8018981861191495,"rouge_l":0.8425557156173206}
{"id":1588,"predictions":["import math NEW_LINE MAX = 1000000 NEW_LINE def fib ( n ) : NEW_LINE INDENT phi = ( 1 + math . sqrt ( 5 ) ) \/ 2 NEW_LINE return round ( pow ( phi , n ) \/ sqrt ( 5 ) ) NEW_LINE DEDENT def calculateSum ( l , r ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT sum += fib ( i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT l = 4 NEW_LINE r = 8 NEW_LINE print ( calculateSum ( l , r ) ) NEW_LINE"],"references":["def fib ( n ) : NEW_LINE INDENT phi = ( ( 1 + ( 5 ** ( 1 \/ 2 ) ) ) \/ 2 ) ; NEW_LINE return round ( ( phi ** n ) \/ ( 5 ** ( 1 \/ 2 ) ) ) ; NEW_LINE DEDENT def calculateSum ( l , r ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT sum += fib ( i ) ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT l , r = 4 , 8 ; NEW_LINE print ( calculateSum ( l , r ) ) ; NEW_LINE DEDENT"],"bleu":0.5112249971228808,"rouge_l":0.7505875846813217}
{"id":1589,"predictions":["def findSum ( N ) : NEW_LINE INDENT return ( N * ( N + 1 ) * ( 2 * N - 5 ) + 4 * N ) \/ 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE print ( findSum ( N ) ) NEW_LINE DEDENT"],"references":["def findSum ( N ) : NEW_LINE INDENT return ( ( N * ( N + 1 ) * ( 2 * N - 5 ) + 4 * N ) \/ 2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE print ( findSum ( N ) ) NEW_LINE DEDENT"],"bleu":0.9294899116028679,"rouge_l":0.9807073954983923}
{"id":1590,"predictions":["def sumOfPrevK ( N , K ) : NEW_LINE INDENT arr = [ 0 ] * N ; NEW_LINE arr [ 0 ] = 1 ; NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT j = i - 1 NEW_LINE count = 0 NEW_LINE sum = 0 NEW_LINE while ( j >= 0 and count < K ) : NEW_LINE INDENT sum += arr [ j ] NEW_LINE j -= 1 NEW_LINE count += 1 NEW_LINE DEDENT arr [ i ] = sum NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 10 NEW_LINE K = 4 NEW_LINE sumOfPrevK ( N , K ) NEW_LINE DEDENT"],"references":["def sumOfPrevK ( N , K ) : NEW_LINE INDENT arr = [ 0 for i in range ( N ) ] NEW_LINE arr [ 0 ] = 1 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT j = i - 1 NEW_LINE count = 0 NEW_LINE sum = 0 NEW_LINE while ( j >= 0 and count < K ) : NEW_LINE INDENT sum = sum + arr [ j ] NEW_LINE j = j - 1 NEW_LINE count = count + 1 NEW_LINE DEDENT arr [ i ] = sum NEW_LINE DEDENT for i in range ( 0 , N ) : NEW_LINE INDENT print ( arr [ i ] ) NEW_LINE DEDENT DEDENT N = 10 NEW_LINE K = 4 NEW_LINE sumOfPrevK ( N , K ) NEW_LINE"],"bleu":0.7351129307812557,"rouge_l":0.8447365332707428}
{"id":1591,"predictions":["def productDivisible ( n , k ) : NEW_LINE INDENT product = 1 NEW_LINE position = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( position % 2 == 0 ) : NEW_LINE INDENT product *= n % 10 NEW_LINE DEDENT n = n \/\/ 10 NEW_LINE position += 1 NEW_LINE DEDENT if ( product % k == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 321922 NEW_LINE k = 3 NEW_LINE if ( productDivisible ( n , k ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"references":["def productDivisible ( n , k ) : NEW_LINE INDENT product = 1 NEW_LINE position = 1 NEW_LINE while n > 0 : NEW_LINE INDENT if position % 2 == 0 : NEW_LINE INDENT product *= n % 10 NEW_LINE DEDENT n = n \/ 10 NEW_LINE position += 1 NEW_LINE DEDENT if product % k == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT n = 321922 NEW_LINE k = 3 NEW_LINE if productDivisible ( n , k ) == True : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"],"bleu":0.6993582786253206,"rouge_l":0.9044621625402154}
{"id":1592,"predictions":["from math import * NEW_LINE def countPairs ( N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , int ( sqrt ( N ) ) + 1 ) : NEW_LINE INDENT cb = i * i * i NEW_LINE diff = N - cb NEW_LINE cbrt = cbrt ( diff ) NEW_LINE if ( cbrtDiff * cbrtDiff == diff ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT for i in range ( 1 , 11 ) : NEW_LINE INDENT print ( \" For ▁ n ▁ = \" , i , \" , ▁ \" , countPairs ( i ) , \" pair ▁ exists \" ) NEW_LINE DEDENT DEDENT"],"references":["import math NEW_LINE def countPairs ( N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , int ( math . pow ( N , 1 \/ 3 ) + 1 ) ) : NEW_LINE INDENT cb = i * i * i NEW_LINE diff = N - cb NEW_LINE cbrtDiff = int ( math . pow ( diff , 1 \/ 3 ) ) NEW_LINE if ( cbrtDiff * cbrtDiff * cbrtDiff == diff ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT for i in range ( 1 , 11 ) : NEW_LINE INDENT print ( ' For ▁ n ▁ = ▁ ' , i , ' , ▁ ' , countPairs ( i ) , ' ▁ pair ▁ exists ' ) NEW_LINE DEDENT"],"bleu":0.6490835960836113,"rouge_l":0.7896440129449839}
{"id":1593,"predictions":["from collections import defaultdict NEW_LINE MAX = 100 NEW_LINE Prefix = [ ] NEW_LINE def repeated_digit ( n ) : NEW_LINE INDENT a = defaultdict ( ) NEW_LINE while n != 0 : NEW_LINE INDENT d = n % 10 NEW_LINE if d in a : NEW_LINE INDENT return 0 NEW_LINE DEDENT a . append ( d ) NEW_LINE n \/\/= 10 NEW_LINE DEDENT return 1 NEW_LINE DEDENT def pre_calculations ( ) : NEW_LINE INDENT Prefix . append ( 0 ) NEW_LINE Prefix . append ( repeated_digit ( 1 ) ) NEW_LINE for i in range ( 2 , MAX + 1 ) : NEW_LINE INDENT Prefix . append ( repeated_digit ( i ) + Prefix [ i - 1 ] ) NEW_LINE DEDENT DEDENT def calculate ( L , R ) : NEW_LINE INDENT return Prefix [ R ] - Prefix [ L - 1 ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT L = 1 NEW_LINE R = 100 NEW_LINE pre_calculations ( ) NEW_LINE print ( calculate ( L , R ) ) NEW_LINE DEDENT"],"references":["Prefix = [ 0 ] NEW_LINE def repeated_digit ( n ) : NEW_LINE INDENT a = [ ] NEW_LINE while n != 0 : NEW_LINE INDENT d = n % 10 NEW_LINE if d in a : NEW_LINE INDENT return 0 NEW_LINE DEDENT a . append ( d ) NEW_LINE n = n \/\/ 10 NEW_LINE DEDENT return 1 NEW_LINE DEDENT def pre_calculation ( MAX ) : NEW_LINE INDENT global Prefix NEW_LINE Prefix . append ( repeated_digit ( 1 ) ) NEW_LINE for i in range ( 2 , MAX + 1 ) : NEW_LINE INDENT Prefix . append ( repeated_digit ( i ) + Prefix [ i - 1 ] ) NEW_LINE DEDENT DEDENT def calculate ( L , R ) : NEW_LINE INDENT return Prefix [ R ] - Prefix [ L - 1 ] NEW_LINE DEDENT MAX = 1000 NEW_LINE pre_calculation ( MAX ) NEW_LINE L = 1 NEW_LINE R = 100 NEW_LINE print ( calculate ( L , R ) ) NEW_LINE"],"bleu":0.7535819116317717,"rouge_l":0.8573719460428261}
{"id":1594,"predictions":["def Survives ( n ) : NEW_LINE INDENT for i in range ( 2 , n ) : NEW_LINE INDENT if ( i > n ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT n -= n \/\/ i NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 17 NEW_LINE if ( Compare ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def Survives ( n ) : NEW_LINE INDENT i = 2 NEW_LINE while ( True ) : NEW_LINE INDENT if ( i > n ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT n -= n \/\/ i ; NEW_LINE i += 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 17 ; NEW_LINE if ( Survives ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"],"bleu":0.722217613083523,"rouge_l":0.8775025952839982}
{"id":1595,"predictions":["def maxPerimeter ( arr , n ) : NEW_LINE INDENT maxi = 0 NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT a = arr [ i ] NEW_LINE b = arr [ j ] NEW_LINE c = arr [ k ] NEW_LINE if ( a < b + c and b < c + a and c < a + b ) : NEW_LINE INDENT maxi = max ( maxi , a + b + c ) NEW_LINE DEDENT DEDENT DEDENT if ( maxi == 0 ) : NEW_LINE INDENT print ( \" Triangle ▁ Perimeter ▁ is : ▁ \" , maxi ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Triangle ▁ formation ▁ is ▁ not ▁ possible \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr1 = [ 6 , 1 , 6 , 5 , 8 , 4 ] NEW_LINE a = [ 2 , 20 , 7 , 55 , 1 , 33 , 12 , 4 ] NEW_LINE maxPerimeter ( arr1 ) NEW_LINE arr2 = [ 33 , 6 , 20 , 1 , 33 , 12 , 5 , 55 , 4 , 9 ] NEW_LINE a = maxPerimeter ( arr2 ) NEW_LINE print ( a ) NEW_LINE DEDENT"],"references":["def maxPerimeter ( arr ) : NEW_LINE INDENT maxi = 0 NEW_LINE n = len ( arr ) NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT a = arr [ i ] NEW_LINE b = arr [ j ] NEW_LINE c = arr [ k ] NEW_LINE if ( a < b + c and b < a + c and c < a + b ) : NEW_LINE INDENT maxi = max ( maxi , a + b + c ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( maxi == 0 ) : NEW_LINE INDENT return \" Triangle ▁ formation ▁ is ▁ not ▁ possible \" NEW_LINE DEDENT else : NEW_LINE INDENT return \" Maximum ▁ Perimeter ▁ is : ▁ \" + str ( maxi ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT arr1 = [ 6 , 1 , 6 , 5 , 8 , 4 ] NEW_LINE a = maxPerimeter ( arr1 ) NEW_LINE print ( a ) NEW_LINE arr2 = [ 2 , 20 , 7 , 55 , 1 , 33 , 12 , 4 ] NEW_LINE a = maxPerimeter ( arr2 ) NEW_LINE print ( a ) NEW_LINE arr3 = [ 33 , 6 , 20 , 1 , 8 , 12 , 5 , 55 , 4 , 9 ] NEW_LINE a = maxPerimeter ( arr3 ) NEW_LINE print ( a ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"bleu":0.7249891155237851,"rouge_l":0.7722928967070425}
{"id":1596,"predictions":["import math NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT s = int ( math . sqrt ( x ) ) NEW_LINE return ( s * s ) == x NEW_LINE DEDENT def isFibonacci ( N ) : NEW_LINE INDENT return isPerfectSquare ( 5 * N * N + 4 ) or isPerfectSquare ( 5 * N - 4 ) NEW_LINE DEDENT def nextNonFibonacci ( N ) : NEW_LINE INDENT if N <= 3 : NEW_LINE INDENT return 4 NEW_LINE DEDENT if isFibonacci ( N + 1 ) : NEW_LINE INDENT return N + 2 NEW_LINE DEDENT else : NEW_LINE INDENT return N + 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 3 NEW_LINE print ( nextNonFibonacci ( N ) ) NEW_LINE N = 5 NEW_LINE print ( nextNonFibonacci ( N ) ) NEW_LINE N = 7 NEW_LINE print ( nextNonFibonacci ( N ) ) NEW_LINE N = 7 NEW_LINE print ( nextNonFibonacci ( N ) ) NEW_LINE N = 7 NEW_LINE print ( nextNonFibonacci ( N ) ) NEW_LINE DEDENT"],"references":["from math import sqrt NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT s = sqrt ( x ) NEW_LINE return ( s * s == x ) NEW_LINE DEDENT def isFibonacci ( N ) : NEW_LINE INDENT return isPerfectSquare ( 5 * N * N + 4 ) or   \\ NEW_LINE INDENT isPerfectSquare ( 5 * N * N - 4 ) NEW_LINE DEDENT DEDENT def nextNonFibonacci ( N ) : NEW_LINE INDENT if ( N <= 3 ) : NEW_LINE INDENT return 4 NEW_LINE DEDENT if ( isFibonacci ( N + 1 ) ) : NEW_LINE INDENT return N + 2 NEW_LINE DEDENT else : NEW_LINE INDENT return N NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE print ( nextNonFibonacci ( N ) ) NEW_LINE N = 4 NEW_LINE print ( nextNonFibonacci ( N ) ) NEW_LINE N = 7 NEW_LINE print ( nextNonFibonacci ( N ) ) NEW_LINE DEDENT"],"bleu":0.7048845313713257,"rouge_l":0.8498720500426499}
{"id":1597,"predictions":["def bit_check ( n ) : NEW_LINE INDENT if ( ( n & ( n - 1 ) ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT n = 14 NEW_LINE if ( bit_check ( n ) ) : NEW_LINE INDENT print ( \"1\" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \"0\" ) NEW_LINE DEDENT"],"references":["def bit_check ( n ) : NEW_LINE INDENT if ( ( n & ( n - 1 ) ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 14 NEW_LINE if ( bit_check ( n ) ) : NEW_LINE INDENT print ( '1' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( '0' ) NEW_LINE DEDENT DEDENT"],"bleu":0.7152789839357777,"rouge_l":0.8559926386013343}
{"id":1598,"predictions":["def center_octadecagonal_num ( n ) : NEW_LINE INDENT return ( 8 * n * n - 8 * n + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 2 NEW_LINE print ( n , \" rd ▁ centered ▁ hexadecagonal ▁ \" + \" number ▁ : ▁ \" , center_octadecagonal ▁ \" + \" number ▁ : ▁ \" , center_octadecagonal_num ( n ) ) NEW_LINE n = 12 NEW_LINE print ( n , \" th ▁ centered ▁ hexadecagonal ▁ \" + \" number : ▁ \" , center_hagonal_num ( n ) ) NEW_LINE DEDENT"],"references":["def center_hexadecagonal_num ( n ) : NEW_LINE INDENT return 8 * n * n - 8 * n + 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 2 NEW_LINE print ( n , \" nd ▁ centered ▁ hexadecagonal ▁ \" + \" number ▁ : ▁ \" , center_hexadecagonal_num ( n ) ) NEW_LINE n = 12 NEW_LINE print ( n , \" th ▁ centered ▁ hexadecagonal ▁ \" + \" number ▁ : ▁ \" , center_hexadecagonal_num ( n ) ) NEW_LINE DEDENT"],"bleu":0.7716863220149485,"rouge_l":0.9017218973359324}
{"id":1599,"predictions":["def fib ( n ) : NEW_LINE INDENT a = 0 NEW_LINE b = 1 NEW_LINE if ( n >= 0 ) : NEW_LINE INDENT print ( a , end = ' ▁ ' ) NEW_LINE DEDENT if ( n >= 1 ) : NEW_LINE INDENT print ( b , end = ' ▁ ' ) NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT print ( a + b , end = ' ▁ ' ) NEW_LINE b = a + b NEW_LINE a = b - a NEW_LINE DEDENT DEDENT fib ( 9 ) NEW_LINE"],"references":["def fib ( n ) : NEW_LINE INDENT a = 0 NEW_LINE b = 1 NEW_LINE if ( n >= 0 ) : NEW_LINE INDENT print ( a , end = ' ▁ ' ) NEW_LINE DEDENT if ( n >= 1 ) : NEW_LINE INDENT print ( b , end = ' ▁ ' ) NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT print ( a + b , end = ' ▁ ' ) NEW_LINE b = a + b NEW_LINE a = b - a NEW_LINE DEDENT DEDENT fib ( 9 ) NEW_LINE"],"bleu":1.0,"rouge_l":1.0}
{"id":1600,"predictions":["from math import sqrt NEW_LINE def prime ( n ) : NEW_LINE INDENT for i in range ( 2 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def thirdNumber ( a , b ) : NEW_LINE INDENT sum = 0 NEW_LINE temp = a + b NEW_LINE temp = 1 NEW_LINE if ( sum == 0 ) : NEW_LINE INDENT temp = 2 NEW_LINE DEDENT while ( prime ( sum + temp ) ) : NEW_LINE INDENT temp += 2 NEW_LINE DEDENT print ( temp ) NEW_LINE DEDENT DEDENT a = 3 NEW_LINE b = 5 NEW_LINE thirdNumber ( a , b ) NEW_LINE"],"references":["def prime ( n ) : NEW_LINE INDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if i * i > n + 1 : NEW_LINE INDENT break NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def thirdNumber ( a , b ) : NEW_LINE INDENT summ = 0 NEW_LINE temp = 0 NEW_LINE summ = a + b NEW_LINE temp = 1 NEW_LINE if ( summ & 1 ) : NEW_LINE INDENT temp = 2 NEW_LINE DEDENT while ( prime ( summ + temp ) == False ) : NEW_LINE INDENT temp += 2 NEW_LINE DEDENT print ( temp ) NEW_LINE DEDENT a = 3 NEW_LINE b = 5 NEW_LINE thirdNumber ( a , b ) NEW_LINE"],"bleu":0.743859768442547,"rouge_l":0.8387685568264786}
{"id":1601,"predictions":["def isLower ( a , b , c ) : NEW_LINE INDENT return ( min ( a , b ) <= c and c <= max ( a , b ) ) ; NEW_LINE DEDENT def canSplit ( x , y , i , j , k ) : NEW_LINE INDENT return ( x [ k ] == x [ i ] or x [ k ] == x [ j ] ) and ( y [ k ] , y [ k ] ) or ( y [ k ] == y [ i ] or y [ k ] == y [ j ] ) and isLower ( x [ i ] , x [ k ] , x [ k ] ) ) ; NEW_LINE DEDENT def countLineSegments ( x , y ) : NEW_LINE INDENT if ( ( x [ 0 ] == x [ 1 ] and x [ 1 ] == x [ 2 ] ) or ( y [ 0 ] == y [ 1 ] and y [ 1 ] == y [ 2 ] ) ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT elif ( ( canProduct ( x , y , 0 , 1 , 2 ) or ( y [ 0 ] == y [ 1 ] and y [ 1 ] == y [ 2 ] ) ) : NEW_LINE INDENT return 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT return 3 ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = [ 0 ] ; y = [ 3 ] = - 1 ; NEW_LINE x [ 1 ] = - 1 ; y [ 1 ] = 3 ; NEW_LINE x [ 2 ] = 3 ; NEW_LINE y [ 2 ] = 3 ; NEW_LINE x [ 2 ] = 4 ; NEW_LINE y [ 3 ] = 3 ; NEW_LINE x [ 2 ] = 2 ; NEW_LINE y [ 2 ] = 3 ; NEW_LINE print ( countLineSegment ( x , y ) ) ; NEW_LINE DEDENT"],"references":["import math NEW_LINE def isBetween ( a , b , c ) : NEW_LINE INDENT return min ( a , b ) <= c and c <= max ( a , b ) NEW_LINE DEDENT def canJoin ( x , y , i , j , k ) : NEW_LINE INDENT return ( x [ k ] == x [ i ] or x [ k ] == x [ j ] ) and isBetween ( y [ i ] , y [ j ] , y [ k ] ) or ( y [ k ] == y [ i ] or y [ k ] == y [ j ] ) and isBetween ( x [ i ] , x [ j ] , x [ k ] ) NEW_LINE DEDENT def countLineSegments ( x , y ) : NEW_LINE INDENT if ( ( x [ 0 ] == x [ 1 ] and x [ 1 ] == x [ 2 ] ) or ( y [ 0 ] == y [ 1 ] and y [ 1 ] == y [ 2 ] ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( canJoin ( x , y , 0 , 1 , 2 ) or canJoin ( x , y , 0 , 2 , 1 ) or canJoin ( x , y , 1 , 2 , 0 ) ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT else : NEW_LINE INDENT return 3 NEW_LINE DEDENT DEDENT x = [ - 1 , - 1 , 4 ] NEW_LINE y = [ - 1 , 3 , 3 ] NEW_LINE print ( countLineSegments ( x , y ) ) NEW_LINE"],"bleu":0.5897934867972054,"rouge_l":0.7837668442494515}
{"id":1602,"predictions":["def ReplaceElements ( arr , n ) : NEW_LINE INDENT min_ele = arr [ 0 ] NEW_LINE arr [ 0 ] = - 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( min_ele < arr [ i ] ) : NEW_LINE INDENT arr [ i ] = min_ele NEW_LINE DEDENT elif ( min_ele >= arr [ i ] ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE arr [ i ] = min_ele NEW_LINE min_ele = temp NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 4 , 5 , 2 , 1 , 7 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE ReplaceElements ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT"],"references":["def ReplaceElements ( arr , n ) : NEW_LINE INDENT min_ele = arr [ 0 ] NEW_LINE arr [ 0 ] = - 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( min_ele < arr [ i ] ) : NEW_LINE INDENT arr [ i ] = min_ele NEW_LINE DEDENT elif ( min_ele >= arr [ i ] ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE arr [ i ] = min_ele NEW_LINE min_ele = temp NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 4 , 5 , 2 , 1 , 7 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE ReplaceElements ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.9920945770173033,"rouge_l":0.9962786851354146}
{"id":1603,"predictions":["def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT def getMin ( arr , i , j ) : NEW_LINE INDENT minVal = arr [ i ] NEW_LINE i += 1 NEW_LINE while ( i <= j ) : NEW_LINE INDENT minVal = min ( minVal , arr [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT return minVal NEW_LINE DEDENT def getMax ( arr , i , j ) : NEW_LINE INDENT maxVal = arr [ i ] NEW_LINE while ( i <= j ) : NEW_LINE INDENT maxVal = max ( maxVal , arr [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT return maxVal NEW_LINE DEDENT def generateArr ( arr , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT print ( arr [ 0 ] ) NEW_LINE return NEW_LINE DEDENT tmpArr = [ 0 for i in range ( n ) ] NEW_LINE tmpArr [ 0 ] = getMax ( arr , 1 , n - 1 ) NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT tmpArr [ i ] = abs ( getMax ( arr , i + 1 , n - 1 ) - getMin ( arr , 0 , i - 1 ) ) NEW_LINE DEDENT tmpArr [ n - 1 ] = getMin ( arr , 0 , n - 2 ) NEW_LINE printArray ( tmpArr , n ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 5 , 2 , 4 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE generateArr ( arr , n ) NEW_LINE DEDENT"],"references":["def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT def getMin ( arr , i , j ) : NEW_LINE INDENT minVal = arr [ i ] NEW_LINE i += 1 NEW_LINE while ( i <= j ) : NEW_LINE INDENT minVal = min ( minVal , arr [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT return minVal NEW_LINE DEDENT def getMax ( arr , i , j ) : NEW_LINE INDENT maxVal = arr [ i ] NEW_LINE i += 1 NEW_LINE while ( i <= j ) : NEW_LINE INDENT maxVal = max ( maxVal , arr [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT return maxVal NEW_LINE DEDENT def generateArr ( arr , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT print ( arr [ 0 ] , end = \" \" ) NEW_LINE return NEW_LINE DEDENT tmpArr = [ 0 for i in range ( n ) ] NEW_LINE tmpArr [ 0 ] = getMax ( arr , 1 , n - 1 ) NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT tmpArr [ i ] = abs ( getMax ( arr , i + 1 , n - 1 ) - getMin ( arr , 0 , i - 1 ) ) NEW_LINE DEDENT tmpArr [ n - 1 ] = getMin ( arr , 0 , n - 2 ) NEW_LINE printArray ( tmpArr , n ) NEW_LINE DEDENT arr = [ 1 , 5 , 2 , 4 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE generateArr ( arr , n ) NEW_LINE"],"bleu":0.9473208793041431,"rouge_l":0.9655841503267975}
{"id":1604,"predictions":["def totEdge ( n ) : NEW_LINE INDENT result = 0 NEW_LINE result = ( n * ( n - 1 ) ) \/\/ 2 NEW_LINE return result NEW_LINE DEDENT n = 6 NEW_LINE print ( totEdge ( n ) ) NEW_LINE"],"references":["def totEdge ( n ) : NEW_LINE INDENT result = ( n * ( n - 1 ) ) \/\/ 2 NEW_LINE return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 6 NEW_LINE print ( totEdge ( n ) ) NEW_LINE DEDENT"],"bleu":0.6816729926588954,"rouge_l":0.7932922655715263}
{"id":1605,"predictions":["def countNumbers ( L , R , K ) : NEW_LINE INDENT if ( K == 9 ) : NEW_LINE INDENT K = 0 NEW_LINE DEDENT totalnumbers = R - L + 1 NEW_LINE factor = totalnumbers \/\/ 9 NEW_LINE ans = factor9 NEW_LINE for i in range ( R , R - rem , 1 ) : NEW_LINE INDENT rem1 = i % 9 NEW_LINE if ( rem1 == K ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT L = 10 NEW_LINE R = 22 NEW_LINE K = 3 NEW_LINE print ( countNumbers ( L , R , K ) ) NEW_LINE"],"references":["def countNumbers ( L , R , K ) : NEW_LINE INDENT if ( K == 9 ) : NEW_LINE INDENT K = 0 NEW_LINE DEDENT totalnumbers = R - L + 1 NEW_LINE factor9 = totalnumbers \/\/ 9 NEW_LINE rem = totalnumbers % 9 NEW_LINE ans = factor9 NEW_LINE for i in range ( R , R - rem , - 1 ) : NEW_LINE INDENT rem1 = i % 9 NEW_LINE if ( rem1 == K ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT L = 10 NEW_LINE R = 22 NEW_LINE K = 3 NEW_LINE print ( countNumbers ( L , R , K ) ) NEW_LINE"],"bleu":0.9005421508289426,"rouge_l":0.9546442544558759}
{"id":1606,"predictions":["def SieveOfEratosthenes ( n , prime , primes , a ) : NEW_LINE INDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT prime [ i ] = True NEW_LINE DEDENT prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= n : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT j = 0 NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT a [ j ] = p NEW_LINE primes [ p * p ] = True NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT def countDivisors ( n ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT prime = [ True ] * ( n + 1 ) NEW_LINE primes = [ False ] * ( n * n ) + 1 NEW_LINE a = [ 0 ] * ( n + 1 ) NEW_LINE SieveOfEratosthenes ( n , prime , primes , a ) NEW_LINE ans = 1 NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT if ( a [ i ] * a [ i ] * a [ i ] > n ) : NEW_LINE INDENT break NEW_LINE DEDENT cnt = 1 NEW_LINE while ( n % a [ i ] == 0 ) : NEW_LINE INDENT n = n \/\/ a [ i ] NEW_LINE cnt = cnt + 1 NEW_LINE DEDENT ans = ans * cnt NEW_LINE DEDENT if ( prime [ n ] ) : NEW_LINE INDENT ans = ans * 2 NEW_LINE DEDENT elif ( prime [ n ] ) : NEW_LINE INDENT ans = ans * 3 NEW_LINE DEDENT elif ( prime [ n ] ) : NEW_LINE INDENT ans = ans * 4 NEW_LINE"],"references":["def SieveOfEratosthenes ( n , prime , primesquare , a ) : NEW_LINE INDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT prime [ i ] = True NEW_LINE DEDENT for i in range ( ( n * n + 1 ) + 1 ) : NEW_LINE INDENT primesquare [ i ] = False NEW_LINE DEDENT prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT i = p * 2 NEW_LINE while ( i <= n ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE i += p NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT j = 0 NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT a [ j ] = p NEW_LINE primesquare [ p * p ] = True NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT def countDivisors ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT prime = [ False ] * ( n + 2 ) NEW_LINE primesquare = [ False ] * ( n * n + 2 ) NEW_LINE a = [ 0 ] * n NEW_LINE SieveOfEratosthenes ( n , prime , primesquare , a ) NEW_LINE ans = 1 NEW_LINE i = 0 NEW_LINE while ( 1 ) : NEW_LINE INDENT if ( a [ i ] * a [ i ] * a [ i ] > n ) : NEW_LINE INDENT break NEW_LINE DEDENT cnt = 1 NEW_LINE while ( n % a [ i ] == 0 ) : NEW_LINE INDENT n = n \/ a [ i ] NEW_LINE cnt = cnt + 1 NEW_LINE DEDENT ans = ans * cnt NEW_LINE i += 1 NEW_LINE DEDENT n = int ( n ) NEW_LINE if ( prime [ n ] == True ) : NEW_LINE INDENT ans = ans * 2 NEW_LINE DEDENT elif ( primesquare [ n ] == True ) : NEW_LINE INDENT ans = ans * 3 NEW_LINE DEDENT elif ( n != 1 ) : NEW_LINE INDENT ans = ans * 4 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( \" Total ▁ distinct ▁ divisors ▁ of ▁ 100 ▁ are ▁ : \" , countDivisors ( 100 ) ) NEW_LINE DEDENT"],"bleu":0.6550062809705454,"rouge_l":0.7911449016100179}
{"id":1607,"predictions":["def subArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT print ( arr [ k ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE subArray ( arr , n ) ; NEW_LINE subArray ( arr , n ) ; NEW_LINE"],"references":["def subArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT for k in range ( i , j + 1 ) : NEW_LINE INDENT print ( arr [ k ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( \" \\n \" , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" All ▁ Non - empty ▁ Subarrays \" ) NEW_LINE subArray ( arr , n ) ; NEW_LINE"],"bleu":0.6304552204727393,"rouge_l":0.7722725851828696}
{"id":1608,"predictions":["def findCullen ( n ) : NEW_LINE INDENT return ( 1 << n ) * n + 1 NEW_LINE DEDENT n = 2 NEW_LINE print ( findCullen ( n ) ) NEW_LINE"],"references":["def findCullen ( n ) : NEW_LINE INDENT return ( 1 << n ) * n + 1 NEW_LINE DEDENT n = 2 NEW_LINE print ( findCullen ( n ) ) NEW_LINE"],"bleu":1.0,"rouge_l":1.0}
{"id":1609,"predictions":["def printProbability ( L , n ) : NEW_LINE INDENT p = ( 1 << ( n - 1 ) ) ; NEW_LINE return 1.0 - ( n ) \/ ( p ) ; NEW_LINE DEDENT n = 3 ; L = 5 ; NEW_LINE print ( printProbability ( L , n ) ) ; NEW_LINE"],"references":["def printProbability ( L , n ) : NEW_LINE INDENT p = ( 1 << ( n - 1 ) ) NEW_LINE return 1.0 - ( float ( n ) \/ float ( p ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE L = 5 NEW_LINE print ( printProbability ( L , n ) ) NEW_LINE DEDENT"],"bleu":0.5517732934396229,"rouge_l":0.7936224489795918}
{"id":1610,"predictions":["def firstTerm ( str ) : NEW_LINE INDENT result = \" \" \" NEW_LINE v = True NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == ' ▁ ' ) : NEW_LINE INDENT v = True NEW_LINE DEDENT elif ( str [ i ] != ' ▁ ' and v == True ) : NEW_LINE INDENT result += ( ord ( str [ i ] ) ) NEW_LINE v = False NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" geeks ▁ for ▁ geeks \" NEW_LINE print ( firstLetterWord ( str ) ) NEW_LINE DEDENT"],"references":["def firstLetterWord ( str ) : NEW_LINE INDENT result = \" \" NEW_LINE v = True NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == ' ▁ ' ) : NEW_LINE INDENT v = True NEW_LINE DEDENT elif ( str [ i ] != ' ▁ ' and v == True ) : NEW_LINE INDENT result += ( str [ i ] ) NEW_LINE v = False NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeks ▁ for ▁ geeks \" NEW_LINE print ( firstLetterWord ( str ) ) NEW_LINE DEDENT"],"bleu":0.8978822151864371,"rouge_l":0.9612222526719649}
{"id":1611,"predictions":["def findNext ( number , n ) : NEW_LINE INDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( number [ i ] < number [ i - 1 ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( i == 0 ) : NEW_LINE INDENT print ( \" Previous ▁ number ▁ is \" ) NEW_LINE return NEW_LINE DEDENT x = number [ i - 1 ] NEW_LINE Greatest = i NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if ( number [ j ] < x and number [ j ] > number [ largest ] ) : NEW_LINE INDENT perfect = j NEW_LINE DEDENT DEDENT number = number [ i - 1 ] NEW_LINE number = list ( number [ i ] ) NEW_LINE reverse = True NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if ( number [ j ] < x and number [ j ] > number [ largest ] ) : NEW_LINE INDENT number = j NEW_LINE DEDENT DEDENT number [ i ] , string [ n - 1 ] = ( string [ j ] , string [ len ( string ) ] ) NEW_LINE return \" Greatest ▁ smaller ▁ number ▁ of ▁ digits ▁ is \" , number [ : ] ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT digits = \"26\" NEW_LINE n = len ( digits ) NEW_LINE findPrev ( numbers , n ) NEW_LINE DEDENT"],"references":["def findPrevious ( number , n ) : NEW_LINE INDENT number = list ( number ) NEW_LINE i , j = - 1 , - 1 NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT if number [ i ] < number [ i - 1 ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if i == 0 : NEW_LINE INDENT print ( \" Previous ▁ number ▁ is ▁ not ▁ possible \" ) NEW_LINE return NEW_LINE DEDENT x , greatest = number [ i - 1 ] , i NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if ( number [ j ] < x and number [ j ] > number [ greatest ] ) : NEW_LINE INDENT greatest = j NEW_LINE DEDENT DEDENT ( number [ greatest ] , number [ i - 1 ] ) = ( number [ i - 1 ] , number [ greatest ] ) NEW_LINE l = number [ i : ] NEW_LINE del number [ i : ] NEW_LINE l . sort ( reverse = True ) NEW_LINE number += l NEW_LINE number = ' ' . join ( number ) NEW_LINE print ( \" Greatest ▁ smaller ▁ number ▁ with \" , \" same ▁ set ▁ of ▁ digits ▁ is \" , number ) NEW_LINE return NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT digits = \"262345\" NEW_LINE n = len ( digits ) NEW_LINE findPrevious ( digits , n ) NEW_LINE DEDENT"],"bleu":0.6165250827028272,"rouge_l":0.7137546468401486}
{"id":1612,"predictions":["def countDecreasing ( A , n ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE len = 1 ; NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( A [ i + 1 ] < A [ i ] ) : NEW_LINE INDENT len += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT cnt += ( ( ( ( len - 1 ) * len ) \/ 2 ) ) ; NEW_LINE len = 1 ; NEW_LINE DEDENT DEDENT if ( len > 1 ) : NEW_LINE INDENT cnt += ( ( ( ( len - 1 ) * len ) \/ 2 ) ; NEW_LINE DEDENT return int ( cnt ) ; NEW_LINE DEDENT A = [ 100 , 3 , 1 , 13 ] ; NEW_LINE n = len ( A ) ; NEW_LINE print ( countDecreasing ( A , n ) ) ; NEW_LINE"],"references":["def countDecreasing ( A , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE len = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( A [ i + 1 ] < A [ i ] ) : NEW_LINE INDENT len += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += ( ( ( len - 1 ) * len ) \/\/ 2 ) ; NEW_LINE len = 1 NEW_LINE DEDENT DEDENT if ( len > 1 ) : NEW_LINE INDENT cnt += ( ( ( len - 1 ) * len ) \/\/ 2 ) NEW_LINE DEDENT return cnt NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 100 , 3 , 1 , 13 ] NEW_LINE n = len ( A ) NEW_LINE print ( countDecreasing ( A , n ) ) NEW_LINE DEDENT"],"bleu":0.768792850806568,"rouge_l":0.8923308594170162}
{"id":1613,"predictions":["def count ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( n * count ( n - 1 ) ) + ( ( n - 1 ) * count ( n - 2 ) ) ) NEW_LINE DEDENT DEDENT A = [ 1 , 2 , 3 , 9 ] NEW_LINE n = 4 NEW_LINE print ( count ( n - 1 ) ) NEW_LINE"],"references":["def count ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( n * count ( n - 1 ) ) + ( ( n - 1 ) * count ( n - 2 ) ) NEW_LINE DEDENT DEDENT A = [ 1 , 2 , 3 , 9 ] NEW_LINE print ( count ( len ( A ) - 1 ) ) NEW_LINE"],"bleu":0.78486992048357,"rouge_l":0.9244091647122494}
{"id":1614,"predictions":["defSplitAndAdd ( A , length , n ) : NEW_LINE INDENT tmp = [ 0 for i in range ( length * 2 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT tmp [ i - 1 ] = tmp [ i ] NEW_LINE DEDENT for i in range ( rotation + length ) : NEW_LINE INDENT print ( arr [ i - rotation ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 12 , 10 , 5 , 6 , 52 , 36 ] NEW_LINE n = len ( arr ) NEW_LINE position = 2 NEW_LINE splitAndAdd ( arr , n , position ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT"],"references":["def SplitAndAdd ( A , length , rotation ) : NEW_LINE INDENT tmp = [ 0 for i in range ( length * 2 ) ] NEW_LINE for i in range ( length ) : NEW_LINE INDENT tmp [ i ] = A [ i ] NEW_LINE tmp [ i + length ] = A [ i ] NEW_LINE DEDENT for i in range ( rotation , rotation + length , 1 ) : NEW_LINE INDENT A [ i - rotation ] = tmp [ i ] ; NEW_LINE DEDENT DEDENT arr = [ 12 , 10 , 5 , 6 , 52 , 36 ] NEW_LINE n = len ( arr ) NEW_LINE position = 2 NEW_LINE SplitAndAdd ( arr , n , position ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE"],"bleu":0.7333716603685547,"rouge_l":0.8375286041189931}
{"id":1615,"predictions":["def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def commDiv ( a , b ) : NEW_LINE INDENT n = gcd ( a , b ) NEW_LINE a = a \/\/ n NEW_LINE b = b \/\/ n NEW_LINE print ( \" A ▁ = \" , a , \" , ▁ B ▁ = \" , b ) NEW_LINE DEDENT a = 10 NEW_LINE b = 15 NEW_LINE commDiv ( a , b ) NEW_LINE"],"references":["def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def commDiv ( a , b ) : NEW_LINE INDENT n = gcd ( a , b ) NEW_LINE a = a \/\/ n NEW_LINE b = b \/\/ n NEW_LINE print ( \" A ▁ = \" , a , \" , ▁ B ▁ = \" , b ) NEW_LINE DEDENT a , b = 10 , 15 NEW_LINE commDiv ( a , b ) NEW_LINE"],"bleu":0.9477113678508828,"rouge_l":0.9705882352941176}
{"id":1616,"predictions":["def adjSet ( n ) : NEW_LINE INDENT x = ( n & ( n >> 1 ) ) NEW_LINE if ( x == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT n = 3 NEW_LINE if ( adjSet ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def adjacentSet ( n ) : NEW_LINE INDENT return ( n & ( n >> 1 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE if ( adjacentSet ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.6350025977914723,"rouge_l":0.7716191352345907}
{"id":1617,"predictions":["def MinimumMoves ( a , n , x ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT if ( a [ i ] <= a [ i - 1 ] ) : NEW_LINE INDENT p = ( a [ i - 1 ] - a [ i ] ) \/\/ x + 1 NEW_LINE ans += p NEW_LINE a [ i ] += p * x NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 3 , 3 , 2 ] NEW_LINE x = 2 NEW_LINE n = len ( arr ) NEW_LINE print ( MinimumMoves ( arr , n , x ) ) NEW_LINE DEDENT"],"references":["def MinimumMoves ( a , n , x ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if a [ i ] <= a [ i - 1 ] : NEW_LINE INDENT p = ( a [ i - 1 ] - a [ i ] ) \/\/ x + 1 NEW_LINE ans += p NEW_LINE a [ i ] += p * x NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 3 , 3 , 2 ] NEW_LINE x = 2 NEW_LINE n = len ( arr ) NEW_LINE print ( MinimumMoves ( arr , n , x ) ) NEW_LINE DEDENT"],"bleu":0.9362448223525723,"rouge_l":0.9876405883079965}
{"id":1618,"predictions":["def avg_of_even_num ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += 2 * i NEW_LINE DEDENT return ( sum \/ n ) NEW_LINE DEDENT n = 9 NEW_LINE print ( avg_of_even_num ( n ) ) NEW_LINE"],"references":["def avg_of_even_num ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + 2 * i NEW_LINE DEDENT return sum \/ n NEW_LINE DEDENT n = 9 NEW_LINE print ( avg_of_even_num ( n ) ) NEW_LINE"],"bleu":0.8530794629535559,"rouge_l":0.9433962264150945}
{"id":1619,"predictions":["def findX ( A , B ) : NEW_LINE INDENT j = 0 NEW_LINE x = 0 NEW_LINE while ( A > 0 or B ) : NEW_LINE INDENT if ( ( A % 2 == 1 ) and ( B % 2 == 1 ) ) : NEW_LINE INDENT x += ( 1 << j ) NEW_LINE DEDENT A >>= 1 NEW_LINE B >>= 1 NEW_LINE j += 1 NEW_LINE DEDENT return x NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = 2 NEW_LINE B = 3 NEW_LINE X = findX ( A , B ) NEW_LINE print ( \" X ▁ = \" , X , \" , ▁ Sum ▁ = ▁ \" , ( B ^ X ) + ( B ^ X ) ) NEW_LINE DEDENT"],"references":["def findX ( A , B ) : NEW_LINE INDENT j = 0 NEW_LINE x = 0 NEW_LINE while ( A or B ) : NEW_LINE INDENT if ( ( A & 1 ) and ( B & 1 ) ) : NEW_LINE INDENT x += ( 1 << j ) NEW_LINE DEDENT A >>= 1 NEW_LINE B >>= 1 NEW_LINE j += 1 NEW_LINE DEDENT return x NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = 2 NEW_LINE B = 3 NEW_LINE X = findX ( A , B ) NEW_LINE print ( \" X ▁ = \" , X , \" , ▁ Sum ▁ = \" , ( A ^ X ) + ( B ^ X ) ) NEW_LINE DEDENT"],"bleu":0.8350741151623543,"rouge_l":0.9416555244925245}
{"id":1620,"predictions":["MAX = 1000001 ; NEW_LINE factor = [ 0 ] * MAX ; NEW_LINE def cal_factor ( ) : NEW_LINE INDENT factor [ 1 ] = 1 ; NEW_LINE for i in range ( 2 , MAX ) : NEW_LINE INDENT factor [ i ] = i ; NEW_LINE DEDENT for i in range ( 4 , MAX , 2 ) : NEW_LINE INDENT factor [ i ] = 2 ; NEW_LINE DEDENT i = 3 ; NEW_LINE while ( i * i < MAX ) : NEW_LINE INDENT if ( factor [ i ] == i ) : NEW_LINE INDENT j = i * i ; NEW_LINE while ( j < MAX ) : NEW_LINE INDENT if ( factor [ j ] == j ) : NEW_LINE INDENT factor [ j ] = i ; NEW_LINE DEDENT j += i ; NEW_LINE DEDENT DEDENT i += 1 ; NEW_LINE DEDENT DEDENT def no_of_series ( a , n ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp = a [ i ] ; NEW_LINE flag = 0 ; NEW_LINE while ( factor [ temp ] != 1 ) : NEW_LINE INDENT flag = - 1 ; NEW_LINE count += 1 ; NEW_LINE temp = int ( temp \/ factor [ temp ] ) ; NEW_LINE DEDENT count += flag ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT cal_factor ( ) ; NEW_LINE a = [ 4 , 4 , 4 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( no_of_representations ( a , n ) ) ; NEW_LINE DEDENT"],"references":["MAX = 1000001 NEW_LINE factor = [ 0 ] * MAX NEW_LINE def cal_factor ( ) : NEW_LINE INDENT factor [ 1 ] = 1 NEW_LINE for i in range ( 2 , MAX ) : NEW_LINE INDENT factor [ i ] = i NEW_LINE DEDENT for i in range ( 4 , MAX , 2 ) : NEW_LINE INDENT factor [ i ] = 2 NEW_LINE DEDENT i = 3 NEW_LINE while i * i < MAX : NEW_LINE INDENT if ( factor [ i ] == i ) : NEW_LINE INDENT for j in range ( i * i , MAX , i ) : NEW_LINE INDENT if ( factor [ j ] == j ) : NEW_LINE INDENT factor [ j ] = i NEW_LINE DEDENT DEDENT DEDENT i += 1 NEW_LINE DEDENT DEDENT def no_of_representations ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp = a [ i ] NEW_LINE flag = 0 NEW_LINE while ( factor [ temp ] != 1 ) : NEW_LINE INDENT flag = - 1 NEW_LINE count += 1 NEW_LINE temp = temp \/\/ factor [ temp ] NEW_LINE DEDENT count += flag NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT cal_factor ( ) NEW_LINE a = [ 4 , 4 , 4 ] NEW_LINE n = len ( a ) NEW_LINE print ( no_of_representations ( a , n ) ) NEW_LINE DEDENT"],"bleu":0.6951533822283689,"rouge_l":0.9134960735374688}
{"id":1621,"predictions":["def maxSumPair ( arr1 , n1 , arr2 , n2 ) : NEW_LINE INDENT max1 = - 2147483648 NEW_LINE max2 = - 2147483648 NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT if ( arr1 [ i ] > max1 ) : NEW_LINE INDENT max1 = arr1 [ i ] NEW_LINE DEDENT DEDENT for i in range ( n2 ) : NEW_LINE INDENT if ( arr2 [ i ] > max2 ) : NEW_LINE INDENT max2 = arr2 [ i ] NEW_LINE DEDENT DEDENT return max1 + max2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr1 = [ 10 , 2 , 3 ] NEW_LINE arr2 = [ 3 , 4 , 7 ] NEW_LINE n1 = len ( arr1 ) NEW_LINE n2 = len ( arr2 ) NEW_LINE print ( maxSumPair ( arr1 , n1 , arr2 , n2 ) ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE def maxSumPair ( arr1 , n1 , arr2 , n2 ) : NEW_LINE INDENT max1 = - sys . maxsize - 1 NEW_LINE max2 = - sys . maxsize - 1 NEW_LINE for i in range ( 0 , n1 ) : NEW_LINE INDENT if ( arr1 [ i ] > max1 ) : NEW_LINE INDENT max1 = arr1 [ i ] NEW_LINE DEDENT DEDENT for i in range ( 0 , n2 ) : NEW_LINE INDENT if ( arr2 [ i ] > max2 ) : NEW_LINE INDENT max2 = arr2 [ i ] NEW_LINE DEDENT DEDENT return max1 + max2 NEW_LINE DEDENT arr1 = [ 10 , 2 , 3 ] NEW_LINE arr2 = [ 3 , 4 , 7 ] NEW_LINE n1 = len ( arr1 ) NEW_LINE n2 = len ( arr2 ) NEW_LINE print ( maxSumPair ( arr1 , n1 , arr2 , n2 ) ) NEW_LINE"],"bleu":0.8418316282667454,"rouge_l":0.8926829268292682}
{"id":1622,"predictions":["def remainder ( st ) : NEW_LINE INDENT l = len ( st ) NEW_LINE rem = 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT num = rem * 10 + ( ord ( st [ i ] ) - ord ( '0' ) ) NEW_LINE rem = num % 11 NEW_LINE DEDENT return rem NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT st = \"3435656754565345\" NEW_LINE print ( remainder ( st ) ) NEW_LINE DEDENT"],"references":["def remainder ( st ) : NEW_LINE INDENT ln = len ( st ) NEW_LINE rem = 0 NEW_LINE for i in range ( 0 , ln ) : NEW_LINE INDENT num = rem * 10 + ( int ) ( st [ i ] ) NEW_LINE rem = num % 11 NEW_LINE DEDENT return rem NEW_LINE DEDENT st = \"3435346456547566345436457867978\" NEW_LINE print ( remainder ( st ) ) NEW_LINE"],"bleu":0.6270485740755619,"rouge_l":0.8185303514376997}
{"id":1623,"predictions":["import math as mt NEW_LINE def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT def randomList ( m , n ) : NEW_LINE INDENT arr = [ 0 ] * m ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ i ] = arr [ i ] * m ; NEW_LINE DEDENT printArr ( arr , m ) ; NEW_LINE DEDENT m = 4 ; NEW_LINE n = 8 ; NEW_LINE randomList ( m , n ) ; NEW_LINE"],"references":["from random import randint NEW_LINE def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT def randomList ( m , n ) : NEW_LINE INDENT arr = [ 0 ] * m ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ randint ( 0 , n ) % m ] += 1 ; NEW_LINE DEDENT printArr ( arr , m ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT m = 4 ; n = 8 ; NEW_LINE randomList ( m , n ) ; NEW_LINE DEDENT"],"bleu":0.7359747194208119,"rouge_l":0.8274552360282149}
{"id":1624,"predictions":["from math import sqrt NEW_LINE N = 100005 NEW_LINE def SieveOfEratosthenes ( prime , p_size ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( sqrt ( p_size ) ) + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( p * 2 , p_size , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def longestPrimeSubsequence ( arr , n ) : NEW_LINE INDENT prime = [ True for i in range ( n + 1 ) ] NEW_LINE SieveOfEratosthenes ( prime , N ) NEW_LINE answer = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 4 , 11 , 2 , 9 , 21 ] NEW_LINE n = len ( arr ) NEW_LINE print ( longestPrimeSubsequence ( arr , n ) ) NEW_LINE DEDENT"],"references":["N = 100005 NEW_LINE def SieveOfEratosthenes ( prime , p_size ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= p_size : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( p * 2 , p_size + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT def longestPrimeSubsequence ( arr , n ) : NEW_LINE INDENT prime = [ True ] * ( N + 1 ) NEW_LINE SieveOfEratosthenes ( prime , N ) NEW_LINE answer = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 4 , 11 , 2 , 9 , 21 ] NEW_LINE n = len ( arr ) NEW_LINE print ( longestPrimeSubsequence ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.8069778716418,"rouge_l":0.8919294232968469}
{"id":1625,"predictions":["def catalan ( n ) : NEW_LINE INDENT res = 0 NEW_LINE if n <= 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT res += catalan ( i ) * catalan ( n - i - 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT print ( catalan ( i ) , end = \" ▁ \" ) NEW_LINE DEDENT"],"references":["def catalan ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res += catalan ( i ) * catalan ( n - i - 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT print catalan ( i ) , NEW_LINE DEDENT"],"bleu":0.8145228640534369,"rouge_l":0.90825487190716}
{"id":1626,"predictions":["def smallestIndex ( a , n ) : NEW_LINE INDENT right1 = 0 NEW_LINE right0 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 1 ) : NEW_LINE INDENT right1 = i NEW_LINE DEDENT else : NEW_LINE INDENT right0 = i NEW_LINE DEDENT DEDENT return min ( right1 , right0 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( smallestIndex ( a , n ) ) NEW_LINE DEDENT"],"references":["def smallestIndex ( a , n ) : NEW_LINE INDENT right1 = 0 NEW_LINE right0 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 1 ) : NEW_LINE INDENT right1 = i NEW_LINE DEDENT else : NEW_LINE INDENT right0 = i NEW_LINE DEDENT DEDENT return min ( right1 , right0 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( smallestIndex ( a , n ) ) NEW_LINE DEDENT"],"bleu":0.9405441894619313,"rouge_l":0.9760679003756783}
{"id":1627,"predictions":["def polygonArea ( X , Y , n ) : NEW_LINE INDENT area = 0.0 NEW_LINE j = n - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) NEW_LINE j = i NEW_LINE DEDENT return abs ( area \/ 2.0 ) NEW_LINE DEDENT X = [ 0 , 2 , 4 ] NEW_LINE Y = [ 1 , 3 , 7 ] NEW_LINE n = len ( X ) NEW_LINE print ( polygonArea ( X , Y , n ) ) NEW_LINE"],"references":["def polygonArea ( X , Y , n ) : NEW_LINE INDENT area = 0.0 NEW_LINE j = n - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT area = area + ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) NEW_LINE j = i NEW_LINE DEDENT return abs ( area \/\/ 2.0 ) NEW_LINE DEDENT X = [ 0 , 2 , 4 ] NEW_LINE Y = [ 1 , 3 , 7 ] NEW_LINE n = len ( X ) NEW_LINE print ( polygonArea ( X , Y , n ) ) NEW_LINE"],"bleu":0.9383809888059096,"rouge_l":0.9721464465183056}
{"id":1628,"predictions":["import math NEW_LINE PI = 3.14 NEW_LINE def areaOfInscribedCircle ( a ) : NEW_LINE INDENT return ( PI \/ 4 ) * a * a NEW_LINE DEDENT a = 8 NEW_LINE print ( \" Area ▁ of ▁ an ▁ inscribed ▁ circle : ▁ \" , areaOfInscribed ( a ) ) NEW_LINE"],"references":["PI = 3.14 NEW_LINE def areaOfInscribedCircle ( a ) : NEW_LINE INDENT return ( PI \/ 4 ) * a * a NEW_LINE DEDENT a = 8 NEW_LINE print ( \" Area ▁ of ▁ an ▁ inscribed ▁ circle : \" , round ( areaOfInscribedCircle ( a ) , 2 ) ) NEW_LINE"],"bleu":0.8195244773288908,"rouge_l":0.8956867543591313}
{"id":1629,"predictions":["def divisorSum ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT if j * j > i : NEW_LINE INDENT break ; NEW_LINE DEDENT if ( i % j == 0 ) : NEW_LINE INDENT if ( i \/\/ j == j ) : NEW_LINE INDENT sum += j ; NEW_LINE DEDENT else : NEW_LINE INDENT sum += j + i \/\/ j ; NEW_LINE DEDENT DEDENT DEDENT DEDENT return sum ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 ; NEW_LINE print ( divisorSum ( n ) ) ; NEW_LINE n = 5 ; NEW_LINE print ( divisorSum ( n ) ) ; NEW_LINE DEDENT"],"references":["def divisorSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT j = 1 NEW_LINE while j * j <= i : NEW_LINE INDENT if i % j == 0 : NEW_LINE INDENT if i \/ j == j : NEW_LINE INDENT sum += j NEW_LINE DEDENT else : NEW_LINE INDENT sum += j + i \/ j NEW_LINE DEDENT DEDENT j = j + 1 NEW_LINE DEDENT DEDENT return int ( sum ) NEW_LINE DEDENT n = 4 NEW_LINE print ( divisorSum ( n ) ) NEW_LINE n = 5 NEW_LINE print ( divisorSum ( n ) ) NEW_LINE"],"bleu":0.4917705018293351,"rouge_l":0.7908857509627727}
{"id":1630,"predictions":["MAX = 32 NEW_LINE def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT n &= ( n - 1 ) NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def pairs ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE f = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT f [ countSetBits ( arr [ i ] ) ] += 1 NEW_LINE DEDENT for i in range ( MAX + 1 ) : NEW_LINE INDENT for j in range ( i , MAX + 1 ) : NEW_LINE INDENT if ( i + j == k ) : NEW_LINE INDENT count += ( ( f [ i ] * ( f [ i ] - 1 ) ) \/\/ 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT count += ( f [ i ] * f [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE k = 4 NEW_LINE print ( pairs ( arr , n , k ) ) NEW_LINE DEDENT"],"references":["MAX = 32 NEW_LINE def countSetBits ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( n ) : NEW_LINE INDENT n &= ( n - 1 ) ; NEW_LINE count += 1 ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT def pairs ( arr , n , k ) : NEW_LINE INDENT count = 0 ; NEW_LINE f = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT f [ countSetBits ( arr [ i ] ) ] += 1 ; NEW_LINE DEDENT for i in range ( MAX + 1 ) : NEW_LINE INDENT for j in range ( 1 , MAX + 1 ) : NEW_LINE INDENT if ( i + j == k ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT count += ( ( f [ i ] * ( f [ i ] - 1 ) ) \/ 2 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT count += ( f [ i ] * f [ j ] ) ; NEW_LINE DEDENT DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE k = 4 NEW_LINE print ( pairs ( arr , n , k ) ) NEW_LINE"],"bleu":0.8451785883658297,"rouge_l":0.9189965664634573}
{"id":1631,"predictions":["def oneDigit ( num ) : NEW_LINE INDENT if num >= 0 and num < 10 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT def isPalUtil ( num , dupNum ) : NEW_LINE INDENT if num >= 0 : NEW_LINE INDENT return dupNum NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( num \/ 10 == dupNum ) : NEW_LINE INDENT return dupNum \/\/ 10 NEW_LINE DEDENT if ( num % 10 == dupNum % 10 ) : NEW_LINE INDENT return dupNum \/\/ 10 NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT def isPalil ( num ) : NEW_LINE INDENT if num < 0 : NEW_LINE INDENT num = ( - num ) NEW_LINE DEDENT dupNum = ( num ) NEW_LINE return isPalil ( num ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 1242 NEW_LINE isPalin ( n ) NEW_LINE print ( \" Yes \" ) NEW_LINE DEDENT n = 1231 NEW_LINE isPalin ( n ) NEW_LINE print ( \" Yes \" ) NEW_LINE DEDENT if __name__ == \" _ main _ _ \" : NEW_LINE INDENT print ( \" No \" ) NEW_LINE print ( \" Yes \" ) NEW_LINE DEDENT"],"references":["def oneDigit ( num ) : NEW_LINE INDENT return ( ( num >= 0 ) and ( num < 10 ) ) ; NEW_LINE DEDENT def isPalUtil ( num , dupNum ) : NEW_LINE INDENT if ( oneDigit ( num ) ) : NEW_LINE INDENT return ( num == ( dupNum ) % 10 ) ; NEW_LINE DEDENT if ( isPalUtil ( int ( num \/ 10 ) , dupNum ) == False ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT dupNum = int ( dupNum \/ 10 ) ; NEW_LINE return ( num % 10 == ( dupNum ) % 10 ) ; NEW_LINE DEDENT def isPal ( num ) : NEW_LINE INDENT if ( num < 0 ) : NEW_LINE INDENT num = ( - num ) ; NEW_LINE DEDENT dupNum = ( num ) ; NEW_LINE return isPalUtil ( num , dupNum ) ; NEW_LINE DEDENT n = 12321 ; NEW_LINE if ( isPal ( n ) == 0 ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT n = 12 ; NEW_LINE if ( isPal ( n ) == 0 ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT n = 88 ; NEW_LINE if ( isPal ( n ) == 1 ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT n = 8999 ; NEW_LINE if ( isPal ( n ) == 0 ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT"],"bleu":0.33438683696490346,"rouge_l":0.5561633843909556}
{"id":1632,"predictions":["def isSumDivides ( N ) : NEW_LINE INDENT temp = N NEW_LINE sum = 0 NEW_LINE while ( temp ) : NEW_LINE INDENT sum += temp % 10 NEW_LINE temp \/\/= 10 NEW_LINE DEDENT if ( N % sum == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 12 NEW_LINE if ( isSumDivides ( N ) == 1 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"references":["def isSumDivides ( N ) : NEW_LINE INDENT temp = N NEW_LINE sum = 0 NEW_LINE while ( temp ) : NEW_LINE INDENT sum += temp % 10 NEW_LINE temp = int ( temp \/ 10 ) NEW_LINE DEDENT if ( N % sum == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 12 NEW_LINE if ( isSumDivides ( N ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.8646842514634769,"rouge_l":0.9383213859020311}
{"id":1633,"predictions":["def nextZero ( i , occurrences ) : NEW_LINE INDENT while ( i < 26 ) : NEW_LINE INDENT if ( occurrences [ i ] == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT def getModutableString ( string ) : NEW_LINE INDENT n = len ( string ) NEW_LINE if ( n > 26 ) : NEW_LINE INDENT return \" - 1\" NEW_LINE DEDENT ch = List [ 0 ] * 26 NEW_LINE occurrences = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT occurrences [ ord ( ch [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT index = nextZero ( 0 , occurrences ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( occurrences [ ord ( ch [ i ] ) - ord ( ' a ' ) ] > 1 ) : NEW_LINE INDENT occurrences [ ord ( ch [ i ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE occurrences [ index ] = 1 NEW_LINE index = nextZero ( index + 1 , occurrences ) NEW_LINE DEDENT DEDENT return ch NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" geeksforgeeks \" NEW_LINE print ( getModorderedString ( string ) ) NEW_LINE DEDENT"],"references":["def nextZero ( i , occurrences ) : NEW_LINE INDENT while i < 26 : NEW_LINE INDENT if occurrences [ i ] == 0 : NEW_LINE INDENT return i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT def getModifiedString ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE if n > 26 : NEW_LINE INDENT return \" - 1\" NEW_LINE DEDENT ch = str NEW_LINE ch = list ( ch ) NEW_LINE occurrences = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT occurrences [ ord ( ch [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT index = nextZero ( 0 , occurrences ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if occurrences [ ord ( ch [ i ] ) - ord ( ' a ' ) ] > 1 : NEW_LINE INDENT occurrences [ ord ( ch [ i ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE ch [ i ] = chr ( ord ( ' a ' ) + index ) NEW_LINE occurrences [ index ] = 1 NEW_LINE index = nextZero ( index + 1 , occurrences ) NEW_LINE DEDENT DEDENT ch = ' ' . join ( ch ) NEW_LINE print ( ch ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeksforgeeks \" NEW_LINE getModifiedString ( str ) NEW_LINE DEDENT"],"bleu":0.7447832793950021,"rouge_l":0.8572455716059872}
{"id":1634,"predictions":["def calculateCycos ( l ) : NEW_LINE INDENT cycle_operations = 0 NEW_LINE while ( len ( l ) > 0 ) : NEW_LINE INDENT len_operations += 1 NEW_LINE cycle_operations += 1 NEW_LINE DEDENT return cycle_operations NEW_LINE DEDENT def minimumOperations ( p , n ) : NEW_LINE INDENT visited = [ 0 ] * ( n + 1 ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ele = p [ i ] NEW_LINE if ( visited [ ele ] == 0 ) : NEW_LINE INDENT visited [ ele ] = 1 NEW_LINE len += 1 NEW_LINE ele = p [ ele ] NEW_LINE DEDENT operations = calculateCycycle ( len ) NEW_LINE num = pow ( 3 , operations ) NEW_LINE if ( num != len ( num ) ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT ans = max ( ans , operations ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT P = [ - 1 , 4 , 6 , 5 , 3 , 2 , 7 , 8 , 9 , 1 ] NEW_LINE n = len ( P ) - 1 NEW_LINE print ( minimumOperations ( P , n ) ) NEW_LINE DEDENT"],"references":["def calculateCycleOperations ( length ) : NEW_LINE INDENT cycle_operations = 0 NEW_LINE while length > 0 : NEW_LINE INDENT length \/\/= 3 NEW_LINE cycle_operations += 1 NEW_LINE DEDENT return cycle_operations - 1 NEW_LINE DEDENT def minimumOperations ( p , n ) : NEW_LINE INDENT visited = [ 0 ] * ( n + 1 ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ele = p [ i ] NEW_LINE if not visited [ ele ] : NEW_LINE INDENT visited [ ele ] = 1 NEW_LINE length = 1 NEW_LINE ele = p [ ele ] NEW_LINE while not visited [ ele ] : NEW_LINE INDENT visited [ ele ] = 1 NEW_LINE length += 1 NEW_LINE ele = p [ ele ] NEW_LINE DEDENT operations = calculateCycleOperations ( length ) NEW_LINE num = pow ( 3 , operations ) NEW_LINE if num != length : NEW_LINE INDENT return - 1 NEW_LINE DEDENT ans = max ( ans , operations ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT P = [ - 1 , 4 , 6 , 5 , 3 , 2 , 7 , 8 , 9 , 1 ] NEW_LINE n = len ( P ) - 1 NEW_LINE print ( minimumOperations ( P , n ) ) NEW_LINE DEDENT"],"bleu":0.7504784744411531,"rouge_l":0.8520524515393387}
{"id":1635,"predictions":["import math NEW_LINE r = 3 NEW_LINE radius = 7 NEW_LINE Volume = 0 NEW_LINE Volume = 3.14159 NEW_LINE print ( \" Volume : ▁ % f \" % ( Volume ) NEW_LINE Surface = 4 * pi * R * r * r NEW_LINE print ( \" Volume : ▁ % f \" % ( Volume ) ) NEW_LINE"],"references":["r = 3 NEW_LINE R = 7 NEW_LINE pi = 3.14159 NEW_LINE Volume = ( float ) ( 2 * pi * pi * R * r * r ) ; NEW_LINE print ( \" Volume : ▁ \" , Volume ) ; NEW_LINE Surface = ( float ) ( 4 * pi * pi * R * r ) ; NEW_LINE print ( \" Surface : ▁ \" , Surface ) ; NEW_LINE"],"bleu":0.33429501306877557,"rouge_l":0.5859750240153698}
{"id":1636,"predictions":["def numberOfPaths ( m , n ) : NEW_LINE INDENT dp = [ 0 ] * n ; NEW_LINE dp [ 0 ] = 1 ; NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT dp [ j ] += dp [ j - 1 ] ; NEW_LINE DEDENT DEDENT return dp [ n - 1 ] ; NEW_LINE DEDENT m = 3 ; NEW_LINE n = 3 ; NEW_LINE print ( numberOfPaths ( m , n ) ) ; NEW_LINE"],"references":["def numberOfPaths ( p , q ) : NEW_LINE INDENT dp = [ 1 for i in range ( q ) ] NEW_LINE for i in range ( p - 1 ) : NEW_LINE INDENT for j in range ( 1 , q ) : NEW_LINE INDENT dp [ j ] += dp [ j - 1 ] NEW_LINE DEDENT DEDENT return dp [ q - 1 ] NEW_LINE DEDENT print ( numberOfPaths ( 3 , 3 ) ) NEW_LINE"],"bleu":0.481573171195538,"rouge_l":0.7313035204567078}
{"id":1637,"predictions":["def alternate ( a , b , x ) : NEW_LINE INDENT return x ^ b ^ x NEW_LINE DEDENT a = - 10 NEW_LINE b = 15 NEW_LINE x = a NEW_LINE print ( \" x ▁ is ▁ : \" , x ) NEW_LINE x = alternate ( a , b , x ) NEW_LINE print ( \" After ▁ exchange ▁ \" ) NEW_LINE x = alternate ( a , b , x ) NEW_LINE print ( \" x ▁ is ▁ : ▁ \" , x ) NEW_LINE"],"references":["def alternate ( a , b , x ) : NEW_LINE INDENT x = a ^ b ^ x NEW_LINE print ( \" After ▁ exchange \" ) NEW_LINE print ( \" x ▁ is \" , x ) NEW_LINE DEDENT a = - 10 NEW_LINE b = 15 NEW_LINE x = a NEW_LINE print ( \" x ▁ is \" , x ) NEW_LINE alternate ( a , b , x ) NEW_LINE"],"bleu":0.6718949323408611,"rouge_l":0.6390008058017728}
{"id":1638,"predictions":["import math NEW_LINE def surface_area_octahedron ( side ) : NEW_LINE INDENT return ( 2 * ( math . sqrt ( 3 ) ) * ( side * side ) ) NEW_LINE DEDENT side = 7 NEW_LINE print ( \" Surface ▁ area ▁ of ▁ octahedron ▁ = \" , surface_area ( side ) ) NEW_LINE"],"references":["import math NEW_LINE def surface_area_octahedron ( side ) : NEW_LINE INDENT return ( 2 * ( math . sqrt ( 3 ) ) * ( side * side ) ) NEW_LINE DEDENT side = 7 NEW_LINE print ( \" Surface ▁ area ▁ of ▁ octahedron ▁ = \" , surface_area_octahedron ( side ) ) NEW_LINE"],"bleu":0.954297861697201,"rouge_l":0.9821428571428572}
{"id":1639,"predictions":["def CenteredDodecahedral_num ( n ) : NEW_LINE INDENT return ( 2 * n + 1 ) * ( 5 * n * n + 5 * n + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE print ( n , \" th ▁ Centered \" , \" Odd ▁ Dodecahedral ▁ number ▁ : ▁ \" , end = 10 NEW_LINE print ( CenteredDodecahedral ▁ \" + \" number ▁ : ▁ \" , CenteredDodecahedral_num ( n ) ) NEW_LINE n = 10 NEW_LINE print ( CenteredDodecahedral_num ( n ) ) NEW_LINE DEDENT"],"references":["def CenteredDodecahedral_num ( n ) : NEW_LINE INDENT return ( 2 * n + 1 ) * ( 5 * n * n + 5 * n + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE print ( n , \" rd ▁ centered ▁ dodecahedral ▁ number : ▁ \" , CenteredDodecahedral_num ( n ) ) NEW_LINE n = 10 NEW_LINE print ( n , \" th ▁ centered ▁ dodecahedral ▁ number ▁ : ▁ \" , CenteredDodecahedral_num ( n ) ) NEW_LINE DEDENT"],"bleu":0.7818700490211079,"rouge_l":0.7951400064370776}
{"id":1640,"predictions":["def longestSubstring ( s ) : NEW_LINE INDENT cnt = 1 ; NEW_LINE maxi = 1 ; NEW_LINE n = len ( s ) ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] != s [ i - 1 ] ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT maxi = max ( cnt , maxi ) ; NEW_LINE cnt = 1 ; NEW_LINE DEDENT DEDENT maxi = max ( cnt , maxi ) ; NEW_LINE return maxi ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" ccccdoctedff \" ; NEW_LINE print ( longestSubstring ( s ) ) ; NEW_LINE DEDENT"],"references":["def longestSubstring ( s ) : NEW_LINE INDENT cnt = 1 ; NEW_LINE maxi = 1 ; NEW_LINE n = len ( s ) ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] != s [ i - 1 ] ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT maxi = max ( cnt , maxi ) ; NEW_LINE cnt = 1 ; NEW_LINE DEDENT DEDENT maxi = max ( cnt , maxi ) ; NEW_LINE return maxi ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" ccccdeededff \" ; NEW_LINE print ( longestSubstring ( s ) ) ; NEW_LINE DEDENT"],"bleu":0.9801160289133815,"rouge_l":0.9921259842519684}
{"id":1641,"predictions":["def firstDigit ( x ) : NEW_LINE INDENT while ( x >= 10 ) : NEW_LINE INDENT x = x \/\/ 10 NEW_LINE DEDENT return x NEW_LINE DEDENT print ( firstDigit ( 12345 ) ) NEW_LINE print ( firstDigit ( 5432 ) ) NEW_LINE print ( firstDigit ( 5432 ) ) NEW_LINE"],"references":["def firstDigit ( x ) : NEW_LINE INDENT while ( x >= 10 ) : NEW_LINE INDENT x = x \/\/ 10 NEW_LINE DEDENT return x NEW_LINE DEDENT print ( firstDigit ( 12345 ) ) NEW_LINE print ( firstDigit ( 5432 ) ) NEW_LINE"],"bleu":0.8445801802806772,"rouge_l":0.9306518723994452}
{"id":1642,"predictions":["C = [ [ 0 for x in range ( 1000 ) ] for y in range ( 1000 ) ] NEW_LINE def binomialCoeff ( n ) : NEW_LINE INDENT for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT def numberOfWays ( x , y , z ) : NEW_LINE INDENT binomialCoeff ( max ( x , max ( y , z ) ) ) NEW_LINE sum = 0 NEW_LINE for i in range ( 1 , z + 1 ) : NEW_LINE INDENT sum = ( sum + C [ z ] [ i ] ) NEW_LINE DEDENT sum1 = 0 NEW_LINE for i in range ( 1 , y + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , x + 1 ) : NEW_LINE INDENT sum1 = ( sum1 + ( C [ y ] [ i ] * C [ x ] [ j ] ) ) NEW_LINE DEDENT DEDENT sum1 = ( sum * sum1 ) NEW_LINE return sum1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = 3 NEW_LINE y = 2 NEW_LINE z = 1 NEW_LINE print ( numberOfWays ( x , y , z ) ) NEW_LINE DEDENT"],"references":["C = [ [ 0 for i in range ( 1000 ) ] for i in range ( 1000 ) ] NEW_LINE def binomialCoeff ( n ) : NEW_LINE INDENT i , j = 0 , 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] +   \\ NEW_LINE INDENT C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def numberOfWays ( x , y , z ) : NEW_LINE INDENT binomialCoeff ( max ( x , max ( y , z ) ) ) NEW_LINE sum = 0 NEW_LINE for i in range ( 1 , z + 1 ) : NEW_LINE INDENT sum = ( sum + C [ z ] [ i ] ) NEW_LINE DEDENT sum1 = 0 NEW_LINE for i in range ( 1 , y + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , x + 1 ) : NEW_LINE INDENT sum1 = ( sum1 + ( C [ y ] [ i ] * C [ x ] [ j ] ) ) NEW_LINE DEDENT DEDENT sum1 = ( sum * sum1 ) NEW_LINE return sum1 NEW_LINE DEDENT x = 3 NEW_LINE y = 2 NEW_LINE z = 1 NEW_LINE print ( numberOfWays ( x , y , z ) ) NEW_LINE"],"bleu":0.9207894584853497,"rouge_l":0.944055944055944}
{"id":1643,"predictions":["def isDivisible ( n ) : NEW_LINE INDENT while n \/\/ 100 : NEW_LINE INDENT d = n % 10 NEW_LINE n \/\/= 10 NEW_LINE n = abs ( n - ( d * 14 ) ) NEW_LINE DEDENT return ( n % 47 == 0 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 59173 NEW_LINE if ( isDivisible ( N ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def isDivisible ( n ) : NEW_LINE INDENT while n \/\/ 100 : NEW_LINE INDENT d = n % 10 NEW_LINE n \/\/= 10 NEW_LINE n = abs ( n - ( d * 14 ) ) NEW_LINE DEDENT return ( n % 47 == 0 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 59173 NEW_LINE if ( isDivisible ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.9476125937240817,"rouge_l":0.979381443298969}
{"id":1644,"predictions":["def compute ( ) : NEW_LINE INDENT ans = 1 NEW_LINE for n in range ( 3 , SIZE + 1 ) : NEW_LINE INDENT ans += 4 * n * n - 6 * ( n - 1 ) NEW_LINE DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["def compute ( ) : NEW_LINE INDENT SIZE = 1001 NEW_LINE ans = 1 NEW_LINE ans += sum ( 4 * i * i - 6 * ( i - 1 ) for i in range ( 3 , SIZE + 1 , 2 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.6427080534221113,"rouge_l":0.712808988764045}
{"id":1645,"predictions":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 9 NEW_LINE ans = sum ( 1 for i in range ( 1 , 10 ) for j in range ( 1 , 10 ) if isStrong and is_prime ( m ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def find_harshall_primes ( n , digitSum , isStrong ) : NEW_LINE INDENT m = n * 10 NEW_LINE s = sum ( 0 for i in range ( 10 , 10 ) ) NEW_LINE m += 1 NEW_LINE s += 1 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT if is_strong and is_prime ( m ) : NEW_LINE INDENT s += str ( m ) NEW_LINE DEDENT if m % s == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return s NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 14 NEW_LINE ans = [ 0 ] NEW_LINE def find_harshad_primes ( n , digitsum , isstrong ) : NEW_LINE INDENT m = n * 10 NEW_LINE s = digitsum NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT if m >= LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT if isstrong and eulerlib . is_prime ( m ) : NEW_LINE INDENT ans [ 0 ] += m NEW_LINE DEDENT if m % s == 0 : NEW_LINE INDENT find_harshad_primes ( m , s , eulerlib . is_prime ( m \/\/ s ) ) NEW_LINE DEDENT m += 1 NEW_LINE s += 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , 10 ) : NEW_LINE INDENT find_harshad_primes ( i , i , False ) NEW_LINE DEDENT return str ( ans [ 0 ] ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.575326652012972,"rouge_l":0.5670023237800154}
{"id":1646,"predictions":["def compute ( ) : NEW_LINE INDENT LENGTH = 50 NEW_LINE ways = [ 0 ] * ( LENGTH + 1 ) NEW_LINE for n in range ( 1 , LENGTH + 1 ) : NEW_LINE INDENT for k in range ( 1 , 4 ) : NEW_LINE INDENT ways [ n ] += ways [ n - k ] NEW_LINE DEDENT DEDENT return str ( ways [ - 1 ] ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["def compute ( ) : NEW_LINE INDENT LENGTH = 50 NEW_LINE ways = [ 1 ] + [ 0 ] * LENGTH NEW_LINE for n in range ( 1 , len ( ways ) ) : NEW_LINE INDENT ways [ n ] += sum ( ways [ max ( n - 4 , 0 ) : n ] ) NEW_LINE DEDENT return str ( ways [ - 1 ] ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.6937326375807737,"rouge_l":0.7994059059933601}
{"id":1647,"predictions":["def compute ( ) : NEW_LINE INDENT return x % mod NEW_LINE DEDENT TERM ( 1767 , 1855 , pow ( 10 , 8 ) ) NEW_LINE def elem ( x , y , m ) : NEW_LINE INDENT if y == 1 : NEW_LINE INDENT return x % m NEW_LINE DEDENT else : NEW_LINE INDENT return x % m NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import eulerlib , sys NEW_LINE def compute ( ) : NEW_LINE INDENT x , y , m = 1777 , 1855 , 10 ** 8 NEW_LINE sys . setrecursionlimit ( y + 30 ) NEW_LINE ans = tetration_mod ( x , y , m ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def tetration_mod ( x , y , m ) : NEW_LINE INDENT if y == 1 : NEW_LINE INDENT return x % m NEW_LINE DEDENT else : NEW_LINE INDENT return pow ( x , tetration_mod ( x , y - 1 , totient ( m ) ) , m ) NEW_LINE DEDENT DEDENT def totient ( n ) : NEW_LINE INDENT assert n > 0 NEW_LINE p = 1 NEW_LINE i = 2 NEW_LINE end = eulerlib . sqrt ( n ) NEW_LINE while i <= end : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT p *= i - 1 NEW_LINE n \/\/= i NEW_LINE while n % i == 0 : NEW_LINE INDENT p *= i NEW_LINE n \/\/= i NEW_LINE DEDENT end = eulerlib . sqrt ( n ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if n != 1 : NEW_LINE INDENT p *= n - 1 NEW_LINE DEDENT return p NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.12221944535213615,"rouge_l":0.41153553781832003}
{"id":1648,"predictions":["def compute ( ) : NEW_LINE INDENT ans = factorialSuffix ( 100000000000 ) - count_factors ( n , 5 ) NEW_LINE if twos >= 2505 : NEW_LINE INDENT twos = ( twos - count_factors ( n , 5 ) ) % 625 + 5 NEW_LINE DEDENT return factorial ( n ) * pow ( 2 , t ) % 100000 NEW_LINE DEDENT def factorial_fit ( n ) : NEW_LINE INDENT return factorial_factorial_factorial_factorial_factorial ( n ) * odd_factorial_factorial ( n ) % 100000 NEW_LINE DEDENT def factorial_factorial_factorial_factorial ( n ) : NEW_LINE INDENT return factorial_factorial_fact ( n \/\/ 2 ) * odd_factorial_factorial_factorial ( n ) % 100000 NEW_LINE DEDENT def factorial_factors ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return factorial_factorial_factorial_factorial ( n \/\/ 5 ) * factorial ( n ) % 100000 NEW_LINE DEDENT DEDENT def factorial_factors ( n ) : NEW_LINE INDENT n %= 100000 NEW_LINE product = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if i % 2 != 0 and i % 5 != 0 : NEW_LINE INDENT product = i * product % 100000 NEW_LINE DEDENT DEDENT return product NEW_LINE DEDENT def factorial_factors ( n ) : NEW_LINE INDENT if n % 2 != 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return fact \/\/ n + countFactors ( n \/\/ n , n , n ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["def compute ( ) : NEW_LINE INDENT ans = factorial_suffix ( 10 ** 12 ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def factorial_suffix ( n ) : NEW_LINE INDENT twos = count_factors ( n , 2 ) - count_factors ( n , 5 ) NEW_LINE if twos >= 2505 : NEW_LINE INDENT twos = ( twos - 5 ) % 2500 + 5 NEW_LINE DEDENT return factorialish ( n ) * pow ( 2 , twos , 100000 ) % 100000 NEW_LINE DEDENT def factorialish ( n ) : NEW_LINE INDENT return even_factorialish ( n ) * odd_factorialish ( n ) % 100000 NEW_LINE DEDENT def even_factorialish ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return factorialish ( n \/\/ 2 ) NEW_LINE DEDENT DEDENT def odd_factorialish ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return odd_factorialish ( n \/\/ 5 ) * factorial_coprime ( n ) % 100000 NEW_LINE DEDENT DEDENT def factorial_coprime ( n ) : NEW_LINE INDENT n %= 100000 NEW_LINE product = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if i % 2 != 0 and i % 5 != 0 : NEW_LINE INDENT product = i * product % 100000 NEW_LINE DEDENT DEDENT return product NEW_LINE DEDENT def count_factors ( end , n ) : NEW_LINE INDENT if end == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return end \/\/ n + count_factors ( end \/\/ n , n ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.6893191368410783,"rouge_l":0.813979898926807}
{"id":1649,"predictions":["def compute ( ) : NEW_LINE INDENT count = 0 NEW_LINE num = [ 0 ] * 8 NEW_LINE c = num [ 1 ] NEW_LINE d = num [ 2 ] NEW_LINE e = num [ 3 ] NEW_LINE k = num [ 4 ] NEW_LINE for m in range ( 8 , 9 ) : NEW_LINE INDENT a , b , c = num [ 2 ] , num [ 3 ] NEW_LINE if ( m > 0 or m > 9 ) : NEW_LINE INDENT continue NEW_LINE DEDENT j = a + b + c - g - k NEW_LINE if ( j < 0 or j > 9 ) : NEW_LINE INDENT continue NEW_LINE DEDENT l = a + b + c - d - i - k NEW_LINE if ( l < 0 or l > 9 ) : NEW_LINE INDENT continue NEW_LINE DEDENT l = a + c + d - n - k NEW_LINE if ( l < 0 or l > 9 ) : NEW_LINE INDENT continue NEW_LINE DEDENT h = b + c - i - k NEW_LINE if ( l < 0 or l > 9 ) : NEW_LINE INDENT continue NEW_LINE DEDENT h = a + c + d - f - k NEW_LINE if ( n < 0 or l > 9 ) : NEW_LINE INDENT continue NEW_LINE DEDENT h = a + b + c - d - f - f NEW_LINE if ( n < 0 or p > 9 ) : NEW_LINE INDENT continue NEW_LINE DEDENT p = a + b + c - f - l NEW_LINE if ( n < 0 or p > 9 ) : NEW_LINE INDENT continue NEW_LINE DEDENT count += 1 NEW_LINE DEDENT if ( increment ( num ) ) : NEW_LINE INDENT return str ( count ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["def compute ( ) : NEW_LINE INDENT ans = 0 NEW_LINE digits = tuple ( range ( 10 ) ) NEW_LINE for b in digits : NEW_LINE INDENT for c in digits : NEW_LINE INDENT for d in digits : NEW_LINE INDENT for e in digits : NEW_LINE INDENT for i in digits : NEW_LINE INDENT m = b + c + d - e - i NEW_LINE if m < 0 or m > 9 : continue NEW_LINE for k in digits : NEW_LINE INDENT f = b + c + d * 2 - e - i - k NEW_LINE if f < 0 or f > 9 : continue NEW_LINE for a in digits : NEW_LINE INDENT for g in digits : NEW_LINE INDENT o = a + b + d - g - k NEW_LINE if o < 0 or o > 9 : continue NEW_LINE j = a + b + c - g - m NEW_LINE if j < 0 or j > 9 : continue NEW_LINE l = a + b + c + d - i - j - k NEW_LINE if l < 0 or l > 9 : continue NEW_LINE h = a + b + c + d - e - f - g NEW_LINE if h < 0 or h > 9 : continue NEW_LINE n = a + c + d - f - j NEW_LINE if n < 0 or n > 9 : continue NEW_LINE p = a + b + c - h - l NEW_LINE if p < 0 or p > 9 : continue NEW_LINE ans += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.4171626815599276,"rouge_l":0.6226713622212015}
{"id":1650,"predictions":["import math NEW_LINE def compute ( ) : NEW_LINE INDENT modulus = 10 ** 10 NEW_LINE modulus = ( 2 * d ) % mod NEW_LINE n = ( d ** ( d ) - 1 ) % mod NEW_LINE return fx NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["def compute ( ) : NEW_LINE INDENT MOD = 10 ** 10 NEW_LINE ans = ( 28433 * pow ( 2 , 7830457 , MOD ) + 1 ) % MOD NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.5478754366053057,"rouge_l":0.725231175693527}
{"id":1651,"predictions":["import eulerlib , fractions NEW_LINE def compute ( ) : NEW_LINE INDENT start_num = 1 NEW_LINE end = 500 NEW_LINE ans = \" \" NEW_LINE while True : NEW_LINE INDENT start_num = len ( str ( start_num ) ) NEW_LINE if start_num < end_num and start_num < end : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT elif start_num >= end : NEW_LINE INDENT start = i NEW_LINE DEDENT elif start >= end_num : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans -= count_num NEW_LINE DEDENT DEDENT remaining_num = len ( str ( start_num ) - 1 NEW_LINE for num in range ( NUM_num + 1 ) : NEW_LINE INDENT for j in range ( len ( num_num ) ) : NEW_LINE INDENT pos = i NEW_LINE candidate = 1 NEW_LINE if isprime [ pos ] == ( and 1 ) : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT elif ( j >> k & 1 ) == 0 : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT else : NEW_LINE INDENT pos -= 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import eulerlib , fractions NEW_LINE def compute ( ) : NEW_LINE INDENT START_NUM = 1 NEW_LINE END_NUM = 500 NEW_LINE CROAK_SEQ = \" PPPPNNPPPNPPNPN \" NEW_LINE assert 0 <= START_NUM < END_NUM NEW_LINE assert 1 <= len ( CROAK_SEQ ) NEW_LINE NUM_JUMPS = len ( CROAK_SEQ ) - 1 NEW_LINE NUM_TRIALS = 2 ** NUM_JUMPS NEW_LINE globalnumerator = 0 NEW_LINE isprime = eulerlib . list_primality ( END_NUM ) NEW_LINE for i in range ( START_NUM , END_NUM + 1 ) : NEW_LINE INDENT for j in range ( NUM_TRIALS ) : NEW_LINE INDENT pos = i NEW_LINE trialnumerator = 1 NEW_LINE if isprime [ pos ] == ( CROAK_SEQ [ 0 ] == ' P ' ) : NEW_LINE INDENT trialnumerator *= 2 NEW_LINE DEDENT for k in range ( NUM_JUMPS ) : NEW_LINE INDENT if pos <= START_NUM : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT elif pos >= END_NUM : NEW_LINE INDENT pos -= 1 NEW_LINE DEDENT elif ( j >> k ) & 1 == 0 : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT else : NEW_LINE INDENT pos -= 1 NEW_LINE DEDENT if isprime [ pos ] == ( CROAK_SEQ [ k + 1 ] == ' P ' ) : NEW_LINE INDENT trialnumerator *= 2 NEW_LINE DEDENT DEDENT globalnumerator += trialnumerator NEW_LINE DEDENT DEDENT globaldenominator = ( END_NUM + 1 - START_NUM ) * 2 ** NUM_JUMPS * 3 ** len ( CROAK_SEQ ) NEW_LINE ans = fractions . Fraction ( globalnumerator , globaldenominator ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.3898616839885132,"rouge_l":0.5187553563188081}
{"id":1652,"predictions":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 8 NEW_LINE isprime = eulerlib . list_primality ( LIMIT - 1 ) NEW_LINE for x in range ( 1 , len ( isprime ) ) : NEW_LINE INDENT for y in itertools . count ( 1 ) : NEW_LINE INDENT a = x * y - 1 NEW_LINE if a >= len ( isprime ) : NEW_LINE INDENT break NEW_LINE DEDENT if not isprime [ a ] : NEW_LINE INDENT break NEW_LINE DEDENT for z in range ( y + 1 ) : NEW_LINE INDENT if eulerlib . gcd ( y , z ) != 1 : NEW_LINE INDENT continue NEW_LINE DEDENT b = x * y - 1 NEW_LINE c = x * z - 1 NEW_LINE if c >= len ( isprime ) : NEW_LINE INDENT break NEW_LINE DEDENT if isprime [ b ] and isprime [ c ] : NEW_LINE INDENT addend = a + b + c NEW_LINE if sum ( isprime [ b ] , isprime [ c ] ) : NEW_LINE INDENT addend = a + b + c NEW_LINE DEDENT DEDENT DEDENT DEDENT return str ( sum ( isprime ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import eulerlib , fractions , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 8 NEW_LINE ans = 0 NEW_LINE isprime = eulerlib . list_primality ( LIMIT - 1 ) NEW_LINE for x in range ( 1 , LIMIT \/\/ 4 + 1 ) : NEW_LINE INDENT for y in itertools . count ( 1 ) : NEW_LINE INDENT a = x * y * y - 1 NEW_LINE if a >= LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT if not isprime [ a ] : NEW_LINE INDENT continue NEW_LINE DEDENT for z in itertools . count ( y + 1 ) : NEW_LINE INDENT if fractions . gcd ( y , z ) != 1 : NEW_LINE INDENT continue NEW_LINE DEDENT c = x * z * z - 1 NEW_LINE if c >= LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT if isprime [ c ] : NEW_LINE INDENT b = x * y * z - 1 NEW_LINE if isprime [ b ] : NEW_LINE INDENT ans += a + b + c NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.7117779302482236,"rouge_l":0.8122320018054615}
{"id":1653,"predictions":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT TAGrees = 10 NEW_LINE for k in range ( 1 , DeGrees + 1 ) : NEW_LINE INDENT for n in range ( k + 1 ) : NEW_LINE INDENT raise AssertionError ( ) NEW_LINE DEDENT DEDENT for k in range ( k + 1 ) : NEW_LINE INDENT for n in range ( k + 1 ) : NEW_LINE INDENT raise Assertools . count ( ) NEW_LINE DEDENT DEDENT if sum ( factors ) != 1 : NEW_LINE INDENT return str ( sum ( i ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return str ( sum ) NEW_LINE DEDENT DEDENT def distributing_nomial_num ( k ) : NEW_LINE INDENT for i in range ( 1 , k + 1 ) : NEW_LINE INDENT product = 0 NEW_LINE for j in range ( 1 , k + 1 ) : NEW_LINE INDENT if j != i : NEW_LINE INDENT product *= ( n - j ) ** ( i - j ) NEW_LINE DEDENT DEDENT result = sum ( product * product ) NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import itertools NEW_LINE from fractions import Fraction NEW_LINE DEGREE = 10 NEW_LINE def compute ( ) : NEW_LINE INDENT ans = Fraction ( 0 , 1 ) NEW_LINE for k in range ( 1 , DEGREE + 1 ) : NEW_LINE INDENT for n in itertools . count ( k + 1 ) : NEW_LINE INDENT if n == DEGREE + 2 : NEW_LINE INDENT raise AssertionError ( ) NEW_LINE DEDENT reference = Fraction ( generating_function ( n ) , 1 ) NEW_LINE term = optimum_polynomial ( k , n ) NEW_LINE if term != reference : NEW_LINE INDENT ans += term NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT return str ( ans . numerator ) + ( \" \" if ans . denominator == 1 else \" \/ \" + str ( ans . denominator ) ) NEW_LINE DEDENT def optimum_polynomial ( k , n ) : NEW_LINE INDENT sum = Fraction ( 0 , 1 ) NEW_LINE for i in range ( k + 1 ) : NEW_LINE INDENT product = Fraction ( generating_function ( i ) , 1 ) NEW_LINE for j in range ( 1 , k + 1 ) : NEW_LINE INDENT if j != i : NEW_LINE INDENT product *= Fraction ( n - j , i - j ) NEW_LINE DEDENT DEDENT sum += product NEW_LINE DEDENT return sum NEW_LINE DEDENT def generating_function ( n ) : NEW_LINE INDENT return sum ( ( - n ) ** i for i in range ( DEGREE + 1 ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.4472124511167697,"rouge_l":0.5930889502036526}
{"id":1654,"predictions":["import eulerlib NEW_LINE MODULUS = 100000000 NEW_LINE def compute ( ) : NEW_LINE INDENT MODULUS = 100000000000000 NEW_LINE numSubsets = [ 0 ] * 250 NEW_LINE for i in range ( 1 , 2501 ) : NEW_LINE INDENT temp = eulerlib . pow ( i , i , 250 ) NEW_LINE if ( j + temp ) % 250 ] = ( numSubsets [ j ] + numSubsets [ ( ( j + temp ) % 250 ] ) % MODULUS NEW_LINE numSubsets = list_array ( string ) NEW_LINE DEDENT return str ( numSubsets [ 0 ] - 1 + MODULUS ) % MODULUS NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["def compute ( ) : NEW_LINE INDENT MOD = 10 ** 16 NEW_LINE subsets = [ 0 ] * 250 NEW_LINE subsets [ 0 ] = 1 NEW_LINE for i in range ( 1 , 250250 + 1 ) : NEW_LINE INDENT offset = pow ( i , i , 250 ) NEW_LINE subsets = [ ( val + subsets [ ( j - offset ) % 250 ] ) % MOD for ( j , val ) in enumerate ( subsets ) ] NEW_LINE DEDENT ans = ( subsets [ 0 ] - 1 ) % MOD NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.5174934118934759,"rouge_l":0.6614173228346457}
{"id":1655,"predictions":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT totients = eulerlib . list_totients ( 10 ** 6 ) NEW_LINE ans = 0 NEW_LINE for i in range ( 2 , len ( totients ) ) : NEW_LINE INDENT ans += totients [ i ] NEW_LINE DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT totients = eulerlib . list_totients ( 10 ** 6 ) NEW_LINE ans = sum ( itertools . islice ( totients , 2 , None ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.6640364978216753,"rouge_l":0.8063543599257885}
{"id":1656,"predictions":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT ans = 200 NEW_LINE COins = [ 1 , 2 , 5 , 10 , 20 , 50 , 100 , 200 ] NEW_LINE for i in range ( len ( coins ) ) : NEW_LINE INDENT coin = COins [ i ] NEW_LINE for j in range ( len ( coins ) ) : NEW_LINE INDENT ways [ i + 1 ] [ j ] = ways [ i + 1 ] [ j ] + ( ways [ i + 1 ] [ j - coin ] ) NEW_LINE DEDENT DEDENT return str ( ways [ len ( coins ) ] [ float ( \" inf \" ) ] ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["def compute ( ) : NEW_LINE INDENT TOTAL = 200 NEW_LINE ways = [ 1 ] + [ 0 ] * TOTAL NEW_LINE for coin in [ 1 , 2 , 5 , 10 , 20 , 50 , 100 , 200 ] : NEW_LINE INDENT for i in range ( len ( ways ) - coin ) : NEW_LINE INDENT ways [ i + coin ] += ways [ i ] NEW_LINE DEDENT DEDENT return str ( ways [ - 1 ] ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.5169879059398846,"rouge_l":0.6853015915474122}
{"id":1657,"predictions":["import fractions NEW_LINE def compute ( ) : NEW_LINE INDENT IORATIONS = 100000000000 NEW_LINE y = - 1 NEW_LINE i = 0 NEW_LINE for i in itertools . count ( ) : NEW_LINE INDENT if i > 0 and x == y : NEW_LINE INDENT break NEW_LINE DEDENT x = f ( x ) NEW_LINE y = f ( y ) % i NEW_LINE DEDENT remain = ( i * i ) % i NEW_LINE while remain > 0 : NEW_LINE INDENT x = f ( x ) NEW_LINE y = ( x + f ( y ) ) % i NEW_LINE DEDENT return ( answer ) NEW_LINE DEDENT def f ( x ) : NEW_LINE INDENT return floor ( pow ( 2 , 30.407 ) ) \/ 1000000007 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def compute ( ) : NEW_LINE INDENT def f ( x ) : NEW_LINE INDENT return math . floor ( 2.0 ** ( 30.403243784 - x * x ) ) \/ 1.0e9 NEW_LINE DEDENT ITERATIONS = 10 ** 12 NEW_LINE x = - 1.0 NEW_LINE y = - 1.0 NEW_LINE i = 0 NEW_LINE while i < ITERATIONS : NEW_LINE INDENT if i > 0 and x == y : NEW_LINE INDENT break NEW_LINE DEDENT x = f ( x ) NEW_LINE y = f ( f ( y ) ) NEW_LINE i += 1 NEW_LINE DEDENT remain = ( ITERATIONS - i ) % i NEW_LINE for i in range ( remain ) : NEW_LINE INDENT x = f ( x ) NEW_LINE DEDENT ans = x + f ( x ) NEW_LINE ans = math . floor ( ans * 1.0e9 ) \/ 1.0e9 NEW_LINE return f \" { ans : .9f } \" NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.5414851913935919,"rouge_l":0.6305061823802165}
{"id":1658,"predictions":["def compute ( ) : NEW_LINE INDENT ans = sum ( 1 for a in range ( 1 , 1001 ) for b in range ( 1 , 101 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["def compute ( ) : NEW_LINE INDENT ans = max ( sum ( int ( c ) for c in str ( a ** b ) ) for a in range ( 100 ) for b in range ( 100 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.6500768480130295,"rouge_l":0.7970907297830374}
{"id":1659,"predictions":["def compute ( ) : NEW_LINE INDENT max_d = - 1 NEW_LINE for i in range ( len ( NUMJAC ) ) : NEW_LINE INDENT prod = 1 NEW_LINE for j in range ( i + j ) : NEW_LINE INDENT prod *= ord ( NUMBER [ i + j ] ) - ord ( '0' ) NEW_LINE DEDENT maxProd = max ( prod , maxProd ) NEW_LINE DEDENT return str ( max_d ) NEW_LINE DEDENT def compute ( ) : NEW_LINE INDENT BDENT + 1 NEW_LINE INDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["def compute ( ) : NEW_LINE INDENT ans = max ( digit_product ( NUMBER [ i : i + ADJACENT ] ) for i in range ( len ( NUMBER ) - ADJACENT + 1 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def digit_product ( s ) : NEW_LINE INDENT result = 1 NEW_LINE for c in s : NEW_LINE INDENT result *= int ( c ) NEW_LINE DEDENT return result NEW_LINE DEDENT NUMBER = \"7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450\" NEW_LINE ADJACENT = 13 NEW_LINE if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.47635981682515754,"rouge_l":0.5532667179093006}
{"id":1660,"predictions":["import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT BASE = 10 NEW_LINE DIGITS = 20 NEW_LINE MAX_SUM = 3 NEW_LINE MAX_SUM = 9 NEW_LINE MAX_SUM = 9 NEW_LINE ans = [ ] NEW_LINE for prefix in itertools . count ( 1 ) : NEW_LINE INDENT for prefix in itertools . count ( LIMIT + 1 ) : NEW_LINE INDENT temp = [ ] NEW_LINE if temp > MAX_SUM : NEW_LINE INDENT for p in itertit in range ( len ( prefix ) ) : NEW_LINE INDENT nextDigit = 0 NEW_LINE if p > MAX_SUM : NEW_LINE INDENT nextDigit = sum ( ways [ digits [ 0 ] [ prefix * BASE - 1 ] * BASE + nextDigit ] ) NEW_LINE DEDENT DEDENT ways [ digits ] [ prefix ] = sum NEW_LINE DEDENT DEDENT return ways [ DIGITS + NON_SUM NEW_LINE DEDENT def digit_sum ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for n in itertools . count ( 2 ) : NEW_LINE INDENT result += sum ( ways [ digits [ 0 ] ] * BASE + MAX_SUM - 1 ] [ 0 ] ) NEW_LINE DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["def compute ( ) : NEW_LINE INDENT BASE = 10 NEW_LINE DIGITS = 20 NEW_LINE CONSECUTIVE = 3 NEW_LINE MAX_SUM = 9 NEW_LINE innerlen = BASE ** CONSECUTIVE NEW_LINE ways = [ [ 1 ] + [ 0 ] * ( innerlen - 1 ) ] NEW_LINE for digits in range ( 1 , DIGITS + CONSECUTIVE + 1 ) : NEW_LINE INDENT newrow = [ ] NEW_LINE for prefix in range ( innerlen ) : NEW_LINE INDENT sum = 0 NEW_LINE if digit_sum ( prefix ) <= MAX_SUM : NEW_LINE INDENT for nextdigit in range ( BASE ) : NEW_LINE INDENT sum += ways [ digits - 1 ] [ prefix % ( BASE ** ( CONSECUTIVE - 1 ) ) * BASE + nextdigit ] NEW_LINE DEDENT DEDENT newrow . append ( sum ) NEW_LINE DEDENT ways . append ( newrow ) NEW_LINE DEDENT ans = ways [ - 1 ] [ 0 ] - ways [ - 2 ] [ 0 ] NEW_LINE return str ( ans ) NEW_LINE DEDENT def digit_sum ( n ) : NEW_LINE INDENT return sum ( int ( c ) for c in str ( n ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.4679447118533053,"rouge_l":0.5665354038190059}
{"id":1661,"predictions":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 9 NEW_LINE MODULUS = 10 ** 9 NEW_LINE splitCount = eulerlib . sqrt ( LIMIT ) NEW_LINE splitnt = math . sqrt ( LIMIT + 1 ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , split + 1 ) : NEW_LINE INDENT count = LIMIT \/\/ i % MOD NEW_LINE term = i * i % MODULUS NEW_LINE ans = ( sum + term ) % MODULUS NEW_LINE DEDENT for i in range ( split - 1 , - 1 , - 1 ) : NEW_LINE INDENT start = LIMIT \/\/ i NEW_LINE end = LIMIT \/\/ i NEW_LINE ans += ( sum + term ) % MODULUS NEW_LINE sum = ( sum + i * sum + MODULUS ) % MODULUS NEW_LINE DEDENT return str ( sum ) NEW_LINE DEDENT def sumsquaresMod ( n ) : NEW_LINE INDENT x = LIMIT \/\/ ( i + 1 ) NEW_LINE y = 0 NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT start = LIMIT \/\/ i NEW_LINE end = x * ( i + 1 ) NEW_LINE sumSquares = ( sumSquares + MODULUS ) % MODULUS NEW_LINE sum = ( sum + i * sum + MODULUS ) % MODULUS NEW_LINE DEDENT return str ( sum ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 15 NEW_LINE MODULUS = 10 ** 9 NEW_LINE splitcount = eulerlib . sqrt ( LIMIT ) NEW_LINE splitat = LIMIT \/\/ ( splitcount + 1 ) NEW_LINE def sum_squares ( s , e ) : NEW_LINE INDENT return ( e * ( e + 1 ) * ( e * 2 + 1 ) - s * ( s + 1 ) * ( s * 2 + 1 ) ) \/\/ 6 NEW_LINE DEDENT ans = sum ( ( i * i * ( LIMIT \/\/ i ) ) for i in range ( 1 , splitat + 1 ) ) NEW_LINE ans += sum ( ( sum_squares ( LIMIT \/\/ ( i + 1 ) , LIMIT \/\/ i ) * i ) for i in range ( 1 , splitcount + 1 ) ) NEW_LINE return str ( ans % MODULUS ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.3448210372171134,"rouge_l":0.5264699082992987}
{"id":1662,"predictions":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT bestNum = 0 NEW_LINE bestA = 0 NEW_LINE for a in range ( 1 , 1001 ) : NEW_LINE INDENT for b in range ( - 1000 , 10001 + b ) : NEW_LINE INDENT num = numberOfConsecutivePrimes ( a * b ) NEW_LINE if num > best : NEW_LINE INDENT bestNum = num NEW_LINE bestA = a NEW_LINE DEDENT DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT def numberOfConsecutive_primes ( a , b ) : NEW_LINE INDENT for i in range ( 2 * i + 1 ) : NEW_LINE INDENT n = i * i + j NEW_LINE if n < 0 or not eulerlib . is_prime ( n ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT ans = max ( ( ( a , b ) for a in range ( - 999 , 1000 ) for b in range ( 2 , 1000 ) ) , key = count_consecutive_primes ) NEW_LINE return str ( ans [ 0 ] * ans [ 1 ] ) NEW_LINE DEDENT def count_consecutive_primes ( ab ) : NEW_LINE INDENT a , b = ab NEW_LINE for i in itertools . count ( ) : NEW_LINE INDENT n = i * i + i * a + b NEW_LINE if not is_prime ( n ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT DEDENT isprimecache = eulerlib . list_primality ( 1000 ) NEW_LINE def is_prime ( n ) : NEW_LINE INDENT if n < 0 : NEW_LINE INDENT return False NEW_LINE DEDENT elif n < len ( isprimecache ) : NEW_LINE INDENT return isprimecache [ n ] NEW_LINE DEDENT else : NEW_LINE INDENT return eulerlib . is_prime ( n ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.4317269451290172,"rouge_l":0.5230982019363762}
{"id":1663,"predictions":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 5000 NEW_LINE MODULUS = 1000000000 NEW_LINE num1 = eulerlib . list_primality ( LIMIT * LIMIT \/\/ 2 ) NEW_LINE num2 = 1 NEW_LINE maxSum = 0 NEW_LINE for i in range ( LIMIT ) : NEW_LINE INDENT if not isprime [ i ] : NEW_LINE INDENT continue NEW_LINE DEDENT maxSum += i NEW_LINE for j in range ( maxSum , i - 1 , - 1 ) : NEW_LINE INDENT temp = numSubsets [ j ] + numSubsets [ j ] NEW_LINE if temp < MODULUS : NEW_LINE INDENT numSubsets [ j ] = temp NEW_LINE DEDENT else : NEW_LINE INDENT numSubsets [ j ] = temp - MODULUS NEW_LINE DEDENT DEDENT DEDENT ans = sum ( i for i in range ( len ( numSubsets ) ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 5000 NEW_LINE MODULUS = 10 ** 16 NEW_LINE count = [ 0 ] * ( LIMIT ** 2 \/\/ 2 ) NEW_LINE count [ 0 ] = 1 NEW_LINE s = 0 NEW_LINE for p in eulerlib . list_primes ( LIMIT ) : NEW_LINE INDENT for i in reversed ( range ( s + 1 ) ) : NEW_LINE INDENT count [ i + p ] = ( count [ i + p ] + count [ i ] ) % MODULUS NEW_LINE DEDENT s += p NEW_LINE DEDENT isprime = eulerlib . list_primality ( s + 1 ) NEW_LINE ans = sum ( count [ i ] for i in range ( s + 1 ) if isprime [ i ] ) % MODULUS NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.45753572661955516,"rouge_l":0.596518677879914}
{"id":1664,"predictions":["def compute ( ) : NEW_LINE INDENT N = 5 NEW_LINE two_Pow_N = 1 << N NEW_LINE ans = 0 NEW_LINE for i in range ( 1 << ( n - 1 ) ) : NEW_LINE INDENT if checkArrangement ( i ) : NEW_LINE INDENT ans += i NEW_LINE DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT def check_sum ( digits ) : NEW_LINE INDENT seen = 0 NEW_LINE temp = ( ( digits ** ( binary_Pow_N - 1 ) ) + 1 ) NEW_LINE for i in range ( start , end + 1 , 2 ) : NEW_LINE INDENT if checkArrangement ( i ) : NEW_LINE INDENT s += i NEW_LINE DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT def check_sum ( digits ) : NEW_LINE INDENT seen = 0 NEW_LINE temp = ( digits & BIT_Pow_N ) | BIT_Pow_N ) NEW_LINE for i in range ( 0 , two_Pow_Pow_N ) : NEW_LINE INDENT seen = 1 << ( ( d >> i ) & BITK ) NEW_LINE DEDENT return seen == consecutive_Set NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["def compute ( ) : NEW_LINE INDENT N = 5 NEW_LINE TWO_POW_N = 2 ** N NEW_LINE MASK = TWO_POW_N - 1 NEW_LINE def check_arrangement ( digits ) : NEW_LINE INDENT seen = set ( ) NEW_LINE digits |= digits << TWO_POW_N NEW_LINE for i in range ( TWO_POW_N ) : NEW_LINE INDENT seen . add ( ( digits >> i ) & MASK ) NEW_LINE DEDENT return len ( seen ) == TWO_POW_N NEW_LINE DEDENT start = 2 ** ( TWO_POW_N - N - 1 ) + 1 NEW_LINE end = 2 ** ( TWO_POW_N - N ) NEW_LINE ans = sum ( i for i in range ( start , end , 2 ) if check_arrangement ( i ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.38682171817190797,"rouge_l":0.5377539287083174}
{"id":1665,"predictions":["def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 7 NEW_LINE numDivisors = [ 2 * ( LIMIT + 1 ) for i in range ( 2 , LIMIT ) ] NEW_LINE for i in range ( 2 , len ( numDivisors ) ) : NEW_LINE INDENT for j in range ( i * 2 , len ( numDivisors [ j ] ) ) : NEW_LINE INDENT numDivisors [ j ] += 1 NEW_LINE DEDENT DEDENT ans = sum ( 1 for i in range ( 2 , len ( numDivisors ) - 1 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["def compute ( ) : NEW_LINE INDENT divisors = [ 2 ] * ( 10 ** 7 + 1 ) NEW_LINE for i in range ( 2 , ( len ( divisors ) + 1 ) \/\/ 2 ) : NEW_LINE INDENT for j in range ( i * 2 , len ( divisors ) , i ) : NEW_LINE INDENT divisors [ j ] += 1 NEW_LINE DEDENT DEDENT ans = sum ( ( 1 if divisors [ i ] == divisors [ i + 1 ] else 0 ) for i in range ( 2 , len ( divisors ) - 1 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.6515732733364611,"rouge_l":0.7743621655258244}
{"id":1666,"predictions":["def compute ( ) : NEW_LINE INDENT triangle = [ i , 64 ] NEW_LINE for i in range ( len ( triangle ) - 2 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( len ( triangle [ i + 1 ] ) ) : NEW_LINE INDENT triangle [ i ] [ j ] += max ( triangle [ i + 1 ] [ j ] , triangle [ i + 1 ] [ j + 1 ] ) NEW_LINE DEDENT DEDENT return str ( triangle [ 0 ] [ 0 ] ) NEW_LINE DEDENT triangle = [ [ 75 , 64 ] , [ 17 , 47 , 82 ] , [ 18 , 35 , 87 , 10 ] , [ 20 , 37 , 56 , 37 , 35 , 33 ] , [ 74 , 1 , 56 , 35 , 62 , 9 , 70 , 62 ] , [ 41 , 41 , 56 , 41 , 56 , 33 ] , [ 41 , 56 , 62 , 43 , 43 , 41 ] , [ 43 , 61 , 56 , 47 , 33 ] , [ 41 , 53 , 56 , 41 , 43 , 33 ] , [ 201 , 47 , 56 , 43 , 33 , 47 , 62 , 41 ] , [ 71 , 71 , 47 , 33 , 62 , 41 , 43 , 43 , 47 , 58 , 53 , 43 , 33 ] , 53 ] NEW_LINE"],"references":["def compute ( ) : NEW_LINE INDENT for i in reversed ( range ( len ( triangle ) - 1 ) ) : NEW_LINE INDENT for j in range ( len ( triangle [ i ] ) ) : NEW_LINE INDENT triangle [ i ] [ j ] += max ( triangle [ i + 1 ] [ j ] , triangle [ i + 1 ] [ j + 1 ] ) NEW_LINE DEDENT DEDENT return str ( triangle [ 0 ] [ 0 ] ) NEW_LINE DEDENT triangle = [ [ 75 ] , [ 95 , 64 ] , [ 17 , 47 , 82 ] , [ 18 , 35 , 87 , 10 ] , [ 20 , 4 , 82 , 47 , 65 ] , [ 19 , 1 , 23 , 75 , 3 , 34 ] , [ 88 , 2 , 77 , 73 , 7 , 63 , 67 ] , [ 99 , 65 , 4 , 28 , 6 , 16 , 70 , 92 ] , [ 41 , 41 , 26 , 56 , 83 , 40 , 80 , 70 , 33 ] , [ 41 , 48 , 72 , 33 , 47 , 32 , 37 , 16 , 94 , 29 ] , [ 53 , 71 , 44 , 65 , 25 , 43 , 91 , 52 , 97 , 51 , 14 ] , [ 70 , 11 , 33 , 28 , 77 , 73 , 17 , 78 , 39 , 68 , 17 , 57 ] , [ 91 , 71 , 52 , 38 , 17 , 14 , 91 , 43 , 58 , 50 , 27 , 29 , 48 ] , [ 63 , 66 , 4 , 68 , 89 , 53 , 67 , 30 , 73 , 16 , 69 , 87 , 40 , 31 ] , [ 4 , 62 , 98 , 27 , 23 , 9 , 70 , 98 , 73 , 93 , 38 , 53 , 60 , 4 , 23 ] , ] NEW_LINE if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.3709747006010093,"rouge_l":0.5962854349951123}
{"id":1667,"predictions":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT ans = binomial ( 40 , 20 ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT return str ( eulerlib . binomial ( 40 , 20 ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.8117343541580836,"rouge_l":0.8729874776386404}
{"id":1668,"predictions":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 50000000 NEW_LINE ans = set ( ) NEW_LINE for i in range ( 2 , 4 ) : NEW_LINE INDENT q = eulerlib . sqrt ( LIMIT ) NEW_LINE for j in range ( i ) : NEW_LINE INDENT q *= p NEW_LINE DEDENT if q > LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT for x in itertools . count ( i ) : NEW_LINE INDENT if x + r <= LIMIT : NEW_LINE INDENT ans = eulerlib . sqrt ( x + r ) NEW_LINE DEDENT DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 50000000 NEW_LINE primes = eulerlib . list_primes ( eulerlib . sqrt ( LIMIT ) ) NEW_LINE sums = { 0 } NEW_LINE for i in range ( 2 , 5 ) : NEW_LINE INDENT newsums = set ( ) NEW_LINE for p in primes : NEW_LINE INDENT q = p ** i NEW_LINE if q > LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT for x in sums : NEW_LINE INDENT if x + q <= LIMIT : NEW_LINE INDENT newsums . add ( x + q ) NEW_LINE DEDENT DEDENT DEDENT sums = newsums NEW_LINE DEDENT return str ( len ( sums ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.625978693781802,"rouge_l":0.7486936444282416}
{"id":1669,"predictions":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT modulus = 10 ** 10 NEW_LINE ans = sum ( i for i in range ( 1 , 1001 ) for j in range ( 1 , 1001 ) ) NEW_LINE return str ( ans [ j ] ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["def compute ( ) : NEW_LINE INDENT MOD = 10 ** 10 NEW_LINE ans = sum ( pow ( i , i , MOD ) for i in range ( 1 , 1001 ) ) % MOD NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.6922122262351571,"rouge_l":0.8472222222222223}
{"id":1670,"predictions":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT totients = eulerlib . list_totients ( 10 ** 6 - 1 ) NEW_LINE maxnumer = 0 NEW_LINE mindenom = 1 NEW_LINE for ( i , tot ) in enumerate ( totients [ 1 : ] , 2 ) : NEW_LINE INDENT if n * maxnumer > maxnumer * totients [ i ] ) : NEW_LINE INDENT maxnumer = n NEW_LINE maxdenom = totients [ i ] NEW_LINE DEDENT DEDENT return str ( maxnumer ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import eulerlib , fractions NEW_LINE def compute ( ) : NEW_LINE INDENT totients = eulerlib . list_totients ( 10 ** 6 ) NEW_LINE ans = max ( range ( 2 , len ( totients ) ) , key = ( lambda i : fractions . Fraction ( i , totients [ i ] ) ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.4581493881122572,"rouge_l":0.648823016564952}
{"id":1671,"predictions":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT isprime = eulerlib . list_primality ( 10 ** 8 ) NEW_LINE ans = sum ( i for i in range ( 5 , len ( isprime ) ) if isprime [ i ] ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def s ( n ) : NEW_LINE INDENT return ( p - 3 ) * math . reciprocal_mod ( 8 % p , p ) % p NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT def s ( p ) : NEW_LINE INDENT return ( p - 3 ) * eulerlib . reciprocal_mod ( 8 % p , p ) % p NEW_LINE DEDENT ans = sum ( s ( p ) for p in eulerlib . prime_generator ( 10 ** 8 ) if p >= 5 ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.6686117010656732,"rouge_l":0.6035482770385534}
{"id":1672,"predictions":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 6 NEW_LINE ans = 1 NEW_LINE for n in itertools . count ( LIMIT ) : NEW_LINE INDENT if n % 2 == 0 or n % 5 == 0 : NEW_LINE INDENT return str ( n ) NEW_LINE DEDENT ans = 1 NEW_LINE pow = 1 NEW_LINE k = 1 NEW_LINE while sum % n != 0 : NEW_LINE INDENT k += 1 NEW_LINE pow = pow * 10 % n NEW_LINE sum = ( sum + pow ) % n NEW_LINE DEDENT return k NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import itertools NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 6 NEW_LINE for n in itertools . count ( LIMIT ) : NEW_LINE INDENT if least_divisible_repunit ( n ) > LIMIT : NEW_LINE INDENT return str ( n ) NEW_LINE DEDENT DEDENT DEDENT def least_divisible_repunit ( n ) : NEW_LINE INDENT if n % 2 == 0 or n % 5 == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT k = 1 NEW_LINE s = 1 NEW_LINE p = 1 NEW_LINE while s % n != 0 : NEW_LINE INDENT k += 1 NEW_LINE p = p * 10 % n NEW_LINE s = ( s + p ) % n NEW_LINE DEDENT return k NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.6654254217291644,"rouge_l":0.7789128055454213}
{"id":1673,"predictions":["def compute ( ) : NEW_LINE INDENT ans = \" \" NEW_LINE for i in range ( 1 , 10000 ) : NEW_LINE INDENT if not has_digitital ( i ) : NEW_LINE INDENT ans += i NEW_LINE DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT ans = sum ( i for i in range ( 1 , 10000 ) if has_pandigital_product ( i ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def has_pandigital_product ( n ) : NEW_LINE INDENT for i in range ( 1 , eulerlib . sqrt ( n ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT temp = str ( n ) + str ( i ) + str ( n \/\/ i ) NEW_LINE if \" \" . join ( sorted ( temp ) ) == \"123456789\" : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.2615959092163454,"rouge_l":0.49962769918093825}
{"id":1674,"predictions":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10000000 NEW_LINE possible = set ( ) NEW_LINE primes = eulerlib . list_primes ( LIMIT \/\/ 2 ) NEW_LINE for i in range ( len ( primes ) ) : NEW_LINE INDENT p = primes [ i ] NEW_LINE if p > end : NEW_LINE INDENT break NEW_LINE DEDENT for j in range ( i + 1 , len ( primes ) ) : NEW_LINE INDENT q = primes [ j ] NEW_LINE lcm = p * q NEW_LINE if lcm > LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT for j in range ( i + 1 , pcm ) : NEW_LINE INDENT multiplier *= p NEW_LINE DEDENT maxMult = multiplier NEW_LINE while multiplier % p == 0 : NEW_LINE INDENT multiplier *= p NEW_LINE DEDENT maxMult = max ( multiplier , maxMult ) NEW_LINE DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10000000 NEW_LINE possible = set ( ) NEW_LINE primes = eulerlib . list_primes ( LIMIT \/\/ 2 ) NEW_LINE end = eulerlib . sqrt ( LIMIT ) NEW_LINE for i in range ( len ( primes ) ) : NEW_LINE INDENT p = primes [ i ] NEW_LINE if p > end : NEW_LINE INDENT break NEW_LINE DEDENT for j in range ( i + 1 , len ( primes ) ) : NEW_LINE INDENT q = primes [ j ] NEW_LINE lcm = p * q NEW_LINE if lcm > LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT multlimit = LIMIT \/\/ lcm NEW_LINE multiplier = 1 NEW_LINE while multiplier * p <= multlimit : NEW_LINE INDENT multiplier *= p NEW_LINE DEDENT maxmult = multiplier NEW_LINE while multiplier % p == 0 : NEW_LINE INDENT multiplier \/\/= p NEW_LINE while multiplier * q <= multlimit : NEW_LINE INDENT multiplier *= q NEW_LINE DEDENT maxmult = max ( multiplier , maxmult ) NEW_LINE DEDENT possible . add ( maxmult * lcm ) NEW_LINE DEDENT DEDENT ans = sum ( possible ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.6781511110296492,"rouge_l":0.8030853727485664}
{"id":1675,"predictions":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT ans = 0 NEW_LINE primes = eulerlib . list_primes ( 2000000 ) NEW_LINE for i in range ( 2 , 1000000 ) : NEW_LINE INDENT p = primes [ i ] NEW_LINE q = 1 NEW_LINE while ( k < p ) : NEW_LINE INDENT k *= 10 NEW_LINE DEDENT m = ( q - p ) * eulerlib . list_primes ( k % q ) % q NEW_LINE ans += m * k + p NEW_LINE DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT ans = 0 NEW_LINE primes = eulerlib . list_primes ( 2000000 ) NEW_LINE for i in itertools . count ( 2 ) : NEW_LINE INDENT p = primes [ i ] NEW_LINE q = primes [ i + 1 ] NEW_LINE if p > 1000000 : NEW_LINE INDENT break NEW_LINE DEDENT k = 1 NEW_LINE while k < p : NEW_LINE INDENT k *= 10 NEW_LINE DEDENT m = ( q - p ) * eulerlib . reciprocal_mod ( k % q , q ) % q NEW_LINE ans += m * k + p NEW_LINE DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.7192760546626639,"rouge_l":0.8567415730337077}
{"id":1676,"predictions":["class Solution ( object ) : NEW_LINE INDENT def conveFill ( self , x , sr , newNode ) : NEW_LINE INDENT queue = [ ] NEW_LINE for i in range ( len ( self . size ) ) : NEW_LINE INDENT curr = queue . queue [ i ] [ sc ] NEW_LINE if curr == newNode : NEW_LINE INDENT return i NEW_LINE DEDENT queue . append ( [ curr , sc ) ] ) NEW_LINE while len ( queue ) > 0 : NEW_LINE INDENT curr = queue . p NEW_LINE r = curr . c NEW_LINE if ( r - 1 >= 0 ) : NEW_LINE INDENT queue [ r ] [ c ] = newColor NEW_LINE if ( r - 1 >= 0 ) : NEW_LINE INDENT queue [ r ] [ c ] = newNode NEW_LINE DEDENT if ( r + 1 >= 0 ) : NEW_LINE INDENT queue . append ( ( r + 1 , c ) ) NEW_LINE DEDENT if ( r + 1 >= 0 ) : NEW_LINE INDENT queue . append ( ( r + 1 , c ) ) NEW_LINE DEDENT if ( c - 1 >= 0 ) : NEW_LINE INDENT q . append ( ( r , c - 1 ) ) NEW_LINE DEDENT DEDENT DEDENT return DEDENT DEDENT"],"references":["class Solution ( object ) : NEW_LINE INDENT def floodFill ( self , image , sr , sc , newColor ) : NEW_LINE INDENT r_ls , c_ls = len ( image ) , len ( image [ 0 ] ) NEW_LINE color = image [ sr ] [ sc ] NEW_LINE if color == newColor : NEW_LINE INDENT return image NEW_LINE DEDENT queue = [ ( sr , sc ) ] NEW_LINE while len ( queue ) > 0 : NEW_LINE INDENT r , c = queue . pop ( 0 ) NEW_LINE if image [ r ] [ c ] == color : NEW_LINE INDENT image [ r ] [ c ] = newColor NEW_LINE if r - 1 >= 0 : queue . append ( ( r - 1 , c ) ) NEW_LINE if r + 1 < r_ls : queue . append ( ( r + 1 , c ) ) NEW_LINE if c - 1 >= 0 : queue . append ( ( r , c - 1 ) ) NEW_LINE if c + 1 < c_ls : queue . append ( ( r , c + 1 ) ) NEW_LINE DEDENT DEDENT return image NEW_LINE DEDENT DEDENT"],"bleu":0.4723344286286819,"rouge_l":0.6689220718618759}
{"id":1677,"predictions":["class Solution ( object ) : NEW_LINE INDENT def thirdMax ( self , nums ) : NEW_LINE INDENT sq = [ ] NEW_LINE set1 = [ ] NEW_LINE for i in nums : NEW_LINE INDENT if i not in set ( i ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT pq . append ( i ) NEW_LINE DEDENT if len ( pq ) > 3 : NEW_LINE INDENT set . add ( p ) NEW_LINE DEDENT DEDENT while len ( pq ) < 3 and len ( pq ) > 1 : NEW_LINE INDENT q . add ( pq ) NEW_LINE DEDENT return pq . pop ( ) NEW_LINE DEDENT DEDENT"],"references":["class Solution ( object ) : NEW_LINE INDENT def thirdMax ( self , nums ) : NEW_LINE INDENT import Queue NEW_LINE pq = Queue . PriorityQueue ( 4 ) NEW_LINE check = set ( ) NEW_LINE for n in nums : NEW_LINE INDENT if n in check : NEW_LINE INDENT continue NEW_LINE DEDENT pq . put ( n ) NEW_LINE check . add ( n ) NEW_LINE if len ( check ) > 3 : NEW_LINE INDENT check . remove ( pq . get ( ) ) NEW_LINE DEDENT DEDENT total = len ( check ) NEW_LINE while total < 3 and total > 1 : NEW_LINE INDENT total -= 1 NEW_LINE DEDENT return pq . get ( ) NEW_LINE DEDENT DEDENT"],"bleu":0.4318131065852352,"rouge_l":0.6485777409555371}
{"id":1678,"predictions":["class Solution ( object ) : NEW_LINE INDENT def productKeyPatterning ( self , s , k ) : NEW_LINE INDENT s = [ ] NEW_LINE for i in xrange ( len ( s ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ord ( s [ i ] ) != ' - ' : NEW_LINE INDENT s . append ( ord ( s [ i ] ) + ' - ' : NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( s [ i ] ) NEW_LINE DEDENT DEDENT return ' ' . join ( s ) NEW_LINE DEDENT DEDENT"],"references":["class Solution ( object ) : NEW_LINE INDENT def licenseKeyFormatting ( self , S , K ) : NEW_LINE INDENT S = S . upper ( ) . replace ( ' - ' , ' ' ) NEW_LINE ls = len ( S ) NEW_LINE if ls % K == 0 : NEW_LINE INDENT pos = K NEW_LINE DEDENT else : NEW_LINE INDENT pos = ls % K NEW_LINE DEDENT res = S [ : pos ] NEW_LINE while pos < ls : NEW_LINE INDENT res += ' - ' + S [ pos : pos + K ] NEW_LINE pos += K NEW_LINE DEDENT return res NEW_LINE DEDENT DEDENT"],"bleu":0.24356212111457284,"rouge_l":0.39682299546142213}
{"id":1679,"predictions":["import queue NEW_LINE class Queue : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . lst = [ ] NEW_LINE DEDENT DEDENT"],"references":["class RecentCounter ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . queue = [ ] NEW_LINE DEDENT def ping ( self , t ) : NEW_LINE INDENT self . queue . append ( t ) NEW_LINE while self . queue and self . queue [ 0 ] < t - 3000 : NEW_LINE INDENT self . queue . pop ( 0 ) NEW_LINE DEDENT return len ( self . queue ) NEW_LINE DEDENT DEDENT"],"bleu":0.07451319248707802,"rouge_l":0.3445354419655465}
{"id":1680,"predictions":["class Solution ( object ) : NEW_LINE INDENT def uniqueMstrong ( self , words ) : NEW_LINE INDENT mors = \" \" . join ( \" . \" , \" - \" , \" - . \" , \" - . \" , \" - - . \" , \" - . \" , \" - - \" , \" . \" , \" . \" , \" - - . \" , \" . \" , \" . \" , \" . \" , \" - \" , \" - - \" ] ) NEW_LINE DEDENT more = set ( ) NEW_LINE for word in words : NEW_LINE INDENT word = word NEW_LINE if word in word : NEW_LINE INDENT return NEW_LINE DEDENT DEDENT seen = set ( ) NEW_LINE for word in word : NEW_LINE INDENT word += ord ( morb ) - ord ( ' a ' ) NEW_LINE DEDENT return len ( word ) NEW_LINE DEDENT DEDENT"],"references":["Morse_tab = [ \" . - \" , \" - . . . \" , \" - . - . \" , \" - . . \" , \" . \" , \" . . - . \" , \" - - . \" , \" . . . . \" , \" . . \" , \" . - - - \" , \" - . - \" , \" . - . . \" , \" - - \" , \" - . \" , \" - - - \" , \" . - - . \" , \" - - . - \" , \" . - . \" , \" . . . \" , \" - \" , \" . . - \" , \" . . . - \" , \" . - - \" , \" - . . - \" , \" - . - - \" , \" - - . . \" ] NEW_LINE class Solution ( object ) : NEW_LINE INDENT def uniqueMorseRepresentations ( self , words ) : NEW_LINE INDENT if len ( words ) == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans_set = set ( ) NEW_LINE for word in words : NEW_LINE INDENT morsed = \" \" NEW_LINE for c in word : NEW_LINE INDENT morsed += Morse_tab [ ord ( c ) - ord ( ' a ' ) ] NEW_LINE DEDENT ans_set . add ( morsed ) NEW_LINE DEDENT return len ( ans_set ) NEW_LINE DEDENT DEDENT"],"bleu":0.38715916901801384,"rouge_l":0.5543354789852328}
{"id":1681,"predictions":["class Solution ( object ) : NEW_LINE INDENT def surfaceSum ( self , nums ) : NEW_LINE INDENT if nums is None or len ( nums ) == 0 : NEW_LINE INDENT return nums NEW_LINE DEDENT for i in range ( 1 , len ( nums ) ) : NEW_LINE INDENT nums [ i ] += nums [ i - 1 ] NEW_LINE DEDENT return nums NEW_LINE DEDENT DEDENT"],"references":["class Solution : NEW_LINE INDENT def runningSum ( self , nums : List [ int ] ) -> List [ int ] : NEW_LINE INDENT if nums is None or len ( nums ) == 0 : NEW_LINE INDENT return nums NEW_LINE DEDENT for i in range ( 1 , len ( nums ) ) : NEW_LINE INDENT nums [ i ] += nums [ i - 1 ] NEW_LINE DEDENT return nums NEW_LINE DEDENT DEDENT"],"bleu":0.782697640284566,"rouge_l":0.8888141672270791}
{"id":1682,"predictions":["from collections import defaultdict NEW_LINE class Node NEW_LINE def __init__ ( self , data ) : NEW_LINE INDENT self . data = Node ( key ) NEW_LINE self . next = None NEW_LINE DEDENT def getNode ( key ) : NEW_LINE INDENT if node is None : NEW_LINE INDENT nodes [ i ] = Node ( - 1 ) NEW_LINE DEDENT prev = Node ( key ) NEW_LINE if prev . next is None : NEW_LINE INDENT prev . next = List [ key ] NEW_LINE DEDENT else : NEW_LINE INDENT prev . next = value NEW_LINE DEDENT return head NEW_LINE DEDENT def get ( self ) : NEW_LINE INDENT i = idx ( key ) NEW_LINE if i > None : NEW_LINE INDENT return - 1 NEW_LINE DEDENT self . head = self . head NEW_LINE if self . children [ i ] == None : NEW_LINE INDENT return - 1 NEW_LINE DEDENT prev . next = None NEW_LINE if prev . next is not None : NEW_LINE INDENT return NEW_LINE DEDENT prev . next = self . next NEW_LINE DEDENT def idx ( self , key ) : NEW_LINE INDENT prev = idx ( key ) NEW_LINE if prev . next is None : NEW_LINE INDENT return NEW_LINE DEDENT prev = self . val NEW_LINE if self . next is not None : NEW_LINE INDENT return NEW_LINE DEDENT prev . next = None NEW_LINE DEDENT def idx ( self , key ) : NEW_LINE INDENT return NEW_LINE DEDENT DEDENT def find ( key , key ) : NEW_LINE INDENT node = idx NEW_LINE prev = None NEW_LINE while node is not None : NEW_LINE INDENT prev = node NEW_LINE node = node . next NEW_LINE node = node . next NEW_LINE DEDENT return prev NEW_LINE DEDENT def find ( key , key ) : NEW_LINE INDENT node = idx = key NEW_LINE prev = None NEW_LINE while node is not None : NEW_LINE INDENT prev = node NEW_LINE node = node . next NEW_LINE node = node . next NEW_"],"references":["class MyHashMap ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . size = 10000 NEW_LINE self . nodes = [ None ] * self . size NEW_LINE DEDENT def put ( self , key , value ) : NEW_LINE INDENT index = hash ( key ) % self . size NEW_LINE if self . nodes [ index ] is None : NEW_LINE INDENT self . nodes [ index ] = ListNode ( - 1 , - 1 ) NEW_LINE DEDENT prev = find ( self . nodes [ index ] , key ) NEW_LINE if prev . next is None : NEW_LINE INDENT prev . next = ListNode ( key , value ) NEW_LINE DEDENT else : NEW_LINE INDENT prev . next . val = value NEW_LINE DEDENT DEDENT def get ( self , key ) : NEW_LINE INDENT index = hash ( key ) % self . size NEW_LINE if self . nodes [ index ] is None : NEW_LINE INDENT return - 1 NEW_LINE DEDENT prev = find ( self . nodes [ index ] , key ) NEW_LINE if prev . next is None : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return prev . next . val NEW_LINE DEDENT DEDENT def remove ( self , key ) : NEW_LINE INDENT index = hash ( key ) % self . size NEW_LINE if self . nodes [ index ] is None : NEW_LINE INDENT return NEW_LINE DEDENT prev = find ( self . nodes [ index ] , key ) NEW_LINE if prev . next is None : NEW_LINE INDENT return NEW_LINE DEDENT prev . next = prev . next . next NEW_LINE DEDENT DEDENT def find ( bucket , key ) : NEW_LINE INDENT node = bucket NEW_LINE prev = None NEW_LINE while node is not None and node . key != key : NEW_LINE INDENT prev = node NEW_LINE node = node . next NEW_LINE DEDENT return prev NEW_LINE DEDENT class ListNode ( ) : NEW_LINE INDENT def __init__ ( self , key , val ) : NEW_LINE INDENT self . key = key NEW_LINE self . val = val NEW_LINE self . next = None NEW_LINE NEW_LINE DEDENT DEDENT"],"bleu":0.4989403266434037,"rouge_l":0.632482115367201}
{"id":1683,"predictions":["class Node ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . val = val NEW_LINE self . val = 0 NEW_LINE self . next = None NEW_LINE DEDENT DEDENT class LinkedList : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . graph = [ ] NEW_LINE self . dfs ( self , x ) NEW_LINE self . dfs ( self . x ) NEW_LINE self . dfs ( self . val , NEW_LINE DEDENT def pop ( self ) : NEW_LINE INDENT self . dfs ( self . val ) NEW_LINE DEDENT def pop ( self ) : NEW_LINE INDENT if len ( self . val ) == 0 : NEW_LINE INDENT return self . dfs ( val ) NEW_LINE DEDENT return val NEW_LINE DEDENT DEDENT def pop ( self ) : NEW_LINE INDENT return self . dfs ( val ) NEW_LINE DEDENT def pop ( self ) : NEW_LINE INDENT return self . head NEW_LINE DEDENT DEDENT def pop ( self ) : NEW_LINE INDENT if val == 0 : NEW_LINE INDENT return self . head NEW_LINE DEDENT return None NEW_LINE DEDENT def pop ( self ) : NEW_LINE INDENT return None NEW_LINE DEDENT def pop ( self ) : NEW_LINE INDENT if val == None : NEW_LINE INDENT return self . head NEW_LINE DEDENT else : NEW_LINE INDENT return self . head NEW_LINE DEDENT DEDENT def pop ( self ) : NEW_LINE INDENT return self . head NEW_LINE DEDENT DEDENT def pop ( self ) : NEW_LINE INDENT if val == 0 : NEW_LINE INDENT return self . head NEW_LINE DEDENT if __name__ == \" _ main _ _ \" : NEW_LINE INDENT self . Node ( 0 ) NEW_LINE tail = Node ( 0 ) NEW_LINE tail = Node ( 0 ) NEW_LINE tail . prev = None NEW_LINE self . head . prev = None NEW_LINE DEDENT"],"references":["class MaxStack ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . stack = [ ] NEW_LINE self . max_stack = [ ] NEW_LINE DEDENT def push ( self , x ) : NEW_LINE INDENT self . stack . append ( x ) NEW_LINE if len ( self . max_stack ) == 0 : NEW_LINE INDENT self . max_stack . append ( x ) NEW_LINE return NEW_LINE DEDENT if self . max_stack [ - 1 ] > x : NEW_LINE INDENT self . max_stack . append ( self . max_stack [ - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT self . max_stack . append ( x ) NEW_LINE DEDENT DEDENT def pop ( self ) : NEW_LINE INDENT if len ( self . stack ) != 0 : NEW_LINE INDENT self . max_stack . pop ( - 1 ) NEW_LINE return self . stack . pop ( - 1 ) NEW_LINE DEDENT DEDENT def top ( self ) : NEW_LINE INDENT return self . stack [ - 1 ] NEW_LINE DEDENT def peekMax ( self ) : NEW_LINE INDENT if len ( self . max_stack ) != 0 : NEW_LINE INDENT return self . max_stack [ - 1 ] NEW_LINE DEDENT DEDENT def popMax ( self ) : NEW_LINE INDENT val = self . peekMax ( ) NEW_LINE buff = [ ] NEW_LINE while self . top ( ) != val : NEW_LINE INDENT buff . append ( self . pop ( ) ) NEW_LINE DEDENT self . pop ( ) NEW_LINE while len ( buff ) != 0 : NEW_LINE INDENT self . push ( buff . pop ( - 1 ) ) NEW_LINE DEDENT return val NEW_LINE DEDENT DEDENT"],"bleu":0.37540786232322043,"rouge_l":0.5395300884475555}
{"id":1684,"predictions":["class Solution ( object ) : NEW_LINE INDENT def canReorder Doubles ( self , A ) : NEW_LINE INDENT value_map = { } NEW_LINE for n in A : NEW_LINE INDENT if n >= 0 : NEW_LINE INDENT continue NEW_LINE DEDENT value_map [ n ] = ( abs ( a ) + 1 ) \/\/ 2 NEW_LINE if value_map [ 2 * n ] > 0 : NEW_LINE INDENT value_map [ 2 * n ] = value_map [ 2 * n ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT value_map [ n ] = value_map [ 2 * n ] NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT"],"references":["class Solution ( object ) : NEW_LINE INDENT def canReorderDoubled ( self , A ) : NEW_LINE INDENT v_map = { } NEW_LINE A . sort ( key = lambda x : abs ( x ) ) NEW_LINE for n in A : NEW_LINE INDENT v_map [ n ] = v_map . get ( n , 0 ) + 1 NEW_LINE DEDENT for n in A : NEW_LINE INDENT if v_map [ n ] <= 0 : NEW_LINE INDENT continue NEW_LINE DEDENT if 2 * n in v_map and v_map [ 2 * n ] > 0 : NEW_LINE INDENT v_map [ n ] -= 1 NEW_LINE v_map [ 2 * n ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = Solution ( ) NEW_LINE print s . canReorderDoubled ( [ 3 , 1 , 3 , 6 ] ) NEW_LINE print s . canReorderDoubled ( [ 2 , 1 , 2 , 6 ] ) NEW_LINE print s . canReorderDoubled ( [ 4 , - 2 , 2 , - 4 ] ) NEW_LINE print s . canReorderDoubled ( [ 1 , 2 , 4 , 16 , 8 , 4 ] ) NEW_LINE DEDENT"],"bleu":0.20456094640158837,"rouge_l":0.40643768768768773}
{"id":1685,"predictions":["class Solution ( object ) : NEW_LINE INDENT def repeatedNTimes ( self , A ) : NEW_LINE INDENT HashMap = { } NEW_LINE ans = max ( self . values ( ) ) NEW_LINE return ans NEW_LINE DEDENT DEDENT"],"references":["import collections NEW_LINE class Solution ( object ) : NEW_LINE INDENT def repeatedNTimes ( self , A ) : NEW_LINE INDENT counter = collections . Counter ( A ) NEW_LINE return counter . most_common ( 1 ) [ 0 ] [ 0 ] NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = Solution ( ) NEW_LINE print s . repeatedNTimes ( [ 1 , 2 , 3 , 3 ] ) NEW_LINE print s . repeatedNTimes ( [ 2 , 1 , 2 , 5 , 3 , 2 ] ) NEW_LINE print s . repeatedNTimes ( [ 5 , 1 , 5 , 2 , 5 , 3 , 5 , 4 ] ) NEW_LINE DEDENT"],"bleu":0.06072249424701738,"rouge_l":0.32099437488659044}
{"id":1686,"predictions":["class Solution ( object ) : NEW_LINE INDENT def smallNumbersThanCurrent ( self , nums ) : NEW_LINE INDENT countList = [ 0 ] * len ( nums ) NEW_LINE res = [ 0 ] * len ( nums ) NEW_LINE for i , v in enumerate ( nums ) : NEW_LINE INDENT countList [ nums [ i ] ] += 1 NEW_LINE DEDENT for nums in enumerate ( nums ) : NEW_LINE INDENT if nums [ nums [ i ] == 0 : NEW_LINE INDENT res [ i ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT res [ i ] = countList [ nums [ i ] - 1 ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT DEDENT"],"references":["class Solution : NEW_LINE INDENT def smallerNumbersThanCurrent ( self , nums : List [ int ] ) -> List [ int ] : NEW_LINE INDENT count_list = [ 0 ] * 101 NEW_LINE for v in nums : NEW_LINE INDENT count_list [ v ] += 1 NEW_LINE DEDENT for i in range ( 1 , 101 ) : NEW_LINE INDENT count_list [ i ] += count_list [ i - 1 ] NEW_LINE DEDENT res = [ ] NEW_LINE for v in nums : NEW_LINE INDENT if v == 0 : NEW_LINE INDENT res . append ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT res . append ( count_list [ v - 1 ] ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT DEDENT"],"bleu":0.3753303835242934,"rouge_l":0.593272997433473}
{"id":1687,"predictions":["class Solution ( object ) : NEW_LINE INDENT def isalienSorted ( self , words , order ) : NEW_LINE INDENT for i in range ( len ( words ) - 1 ) : NEW_LINE INDENT orderMap [ i ] = i NEW_LINE DEDENT for i in range ( len ( words ) - 1 ) : NEW_LINE INDENT if cmp_alien ' in words [ i + 1 ] : NEW_LINE INDENT return orderMap [ a ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT DEDENT"],"references":["class Solution ( object ) : NEW_LINE INDENT def isAlienSorted ( self , words , order ) : NEW_LINE INDENT order_map = { } NEW_LINE for i , v in enumerate ( order ) : NEW_LINE INDENT order_map [ v ] = i NEW_LINE DEDENT def cmp_alien ( x , y ) : NEW_LINE INDENT ls = min ( len ( x ) , len ( y ) ) NEW_LINE index = 0 NEW_LINE while index < ls : NEW_LINE INDENT if x [ index ] != y [ index ] : NEW_LINE INDENT return order_map [ x [ index ] ] - order_map [ y [ index ] ] NEW_LINE DEDENT index += 1 NEW_LINE DEDENT return len ( x ) - len ( y ) NEW_LINE DEDENT pos = 0 NEW_LINE while pos + 1 < len ( words ) : NEW_LINE INDENT if cmp_alien ( words [ pos ] , words [ pos + 1 ] ) > 0 : NEW_LINE INDENT return False NEW_LINE DEDENT pos += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = Solution ( ) NEW_LINE print s . isAlienSorted ( [ \" hello \" , \" leetcode \" ] , \" hlabcdefgijkmnopqrstuvwxyz \" ) NEW_LINE print s . isAlienSorted ( [ \" word \" , \" world \" , \" row \" ] , \" worldabcefghijkmnpqstuvxyz \" ) NEW_LINE print s . isAlienSorted ( [ \" apple \" , \" app \" ] , \" abcdefghijklmnopqrstuvwxyz \" ) NEW_LINE DEDENT"],"bleu":0.06065823952917475,"rouge_l":0.32096955059087384}
{"id":1688,"predictions":["class Solution ( object ) : NEW_LINE INDENT def findDeparraysNumbers ( self , nums ) : NEW_LINE INDENT ret = [ ] NEW_LINE for i in range ( len ( nums ) ) : NEW_LINE INDENT val = abs ( nums [ i ] ) - 1 NEW_LINE if nums [ val ] > 0 : NEW_LINE INDENT nums . append ( i + 1 ) NEW_LINE DEDENT DEDENT for n in range ( len ( nums ) ) : NEW_LINE INDENT if nums [ n ] > 0 : NEW_LINE INDENT ret . append ( i + 1 ) NEW_LINE DEDENT DEDENT return ret NEW_LINE DEDENT DEDENT"],"references":["class Solution ( object ) : NEW_LINE INDENT def findDisappearedNumbers ( self , nums ) : NEW_LINE INDENT res = [ ] NEW_LINE if nums : NEW_LINE INDENT n = len ( nums ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT val = abs ( nums [ i ] ) - 1 NEW_LINE if nums [ val ] > 0 : NEW_LINE INDENT nums [ val ] = - nums [ val ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if nums [ i ] > 0 : NEW_LINE INDENT res . append ( i + 1 ) NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT DEDENT"],"bleu":0.6356299756158706,"rouge_l":0.767795138888889}
{"id":1689,"predictions":["class Solution : NEW_LINE INDENT def toHex ( self , num ) : NEW_LINE INDENT res = \"01\" NEW_LINE if num == 0 : NEW_LINE INDENT return \"0\" NEW_LINE DEDENT res = \" \" NEW_LINE while num != 0 : NEW_LINE INDENT res = chr ( num & 15 ) + res NEW_LINE n = num >> 4 NEW_LINE DEDENT return res NEW_LINE DEDENT DEDENT"],"references":["class Solution ( object ) : NEW_LINE INDENT def toHex ( self , num ) : NEW_LINE INDENT if num == 0 : NEW_LINE INDENT return '0' NEW_LINE DEDENT mp = '0123456789abcdef ' NEW_LINE ans = ' ' NEW_LINE for _ in range ( 8 ) : NEW_LINE INDENT n = num & 15 NEW_LINE c = mp [ n ] NEW_LINE ans = c + ans NEW_LINE num = num >> 4 NEW_LINE DEDENT return ans . lstrip ( '0' ) NEW_LINE DEDENT DEDENT"],"bleu":0.36062920392357045,"rouge_l":0.5989327641408753}
{"id":1690,"predictions":["class Solution ( object ) : NEW_LINE INDENT def kWeakestRows ( self , mat , k ) : NEW_LINE INDENT res = [ ] NEW_LINE col = 0 NEW_LINE flag = True NEW_LINE while col < len ( mat [ 0 ] ) and flag : NEW_LINE INDENT for i in range ( len ( mat ) ) ) : NEW_LINE INDENT if res [ i ] [ col ] == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT if mat [ i ] [ col ] == 0 : NEW_LINE INDENT res . append ( i ) NEW_LINE DEDENT if len ( res ) == k : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT col += 1 NEW_LINE DEDENT if flag : NEW_LINE INDENT for i in range ( len ( mat ) ) : NEW_LINE INDENT if i in res : NEW_LINE INDENT continue NEW_LINE DEDENT res . append ( i ) NEW_LINE if len ( res ) == k : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT DEDENT"],"references":["class Solution ( object ) : NEW_LINE INDENT def kWeakestRows ( self , mat , k ) : NEW_LINE INDENT res = [ ] NEW_LINE num_row = len ( mat ) NEW_LINE num_col = len ( mat [ 0 ] ) NEW_LINE col = 0 NEW_LINE flag = 1 NEW_LINE while col < num_col and flag : NEW_LINE INDENT for i in range ( num_row ) : NEW_LINE INDENT if i in res : NEW_LINE INDENT continue NEW_LINE DEDENT if mat [ i ] [ col ] == 0 : NEW_LINE INDENT res . append ( i ) NEW_LINE DEDENT if len ( res ) == k : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT DEDENT col += 1 NEW_LINE DEDENT if len ( res ) == k : NEW_LINE INDENT return res NEW_LINE DEDENT for i in range ( num_row ) : NEW_LINE INDENT if i in res : NEW_LINE INDENT continue NEW_LINE DEDENT res . append ( i ) NEW_LINE if len ( res ) == k : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT DEDENT"],"bleu":0.7878215479142021,"rouge_l":0.8252973758285664}
{"id":1691,"predictions":["class Solution ( object ) : NEW_LINE INDENT def flipAndInvertImage ( self , A ) : NEW_LINE INDENT rowC = len ( A [ 0 ] ) NEW_LINE for i in range ( C + 1 ) : NEW_LINE INDENT row = [ 0 ] ^ 1 NEW_LINE row [ i ] = row [ C - 1 - i ] ^ 1 NEW_LINE row [ C - 1 - i ] = tmp NEW_LINE DEDENT return A NEW_LINE DEDENT DEDENT"],"references":["class Solution ( object ) : NEW_LINE INDENT def flipAndInvertImage ( self , A ) : NEW_LINE INDENT for row in A : NEW_LINE INDENT for i in xrange ( ( len ( row ) + 1 ) \/ 2 ) : NEW_LINE INDENT row [ i ] , row [ ~ i ] = row [ ~ i ] ^ 1 , row [ i ] ^ 1 NEW_LINE DEDENT DEDENT return A NEW_LINE DEDENT DEDENT"],"bleu":0.4993019750123883,"rouge_l":0.6993954554930165}
{"id":1692,"predictions":["class Solution ( object ) : NEW_LINE"],"references":["class Solution ( object ) : NEW_LINE INDENT def sortedSquares ( self , A ) : NEW_LINE INDENT pos = 0 NEW_LINE while pos < len ( A ) and A [ pos ] < 0 : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT npos = pos - 1 NEW_LINE res = [ ] NEW_LINE while pos < len ( A ) and npos >= 0 : NEW_LINE INDENT if A [ npos ] ** 2 < A [ pos ] ** 2 : NEW_LINE INDENT res . append ( A [ npos ] ** 2 ) NEW_LINE npos -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT res . append ( A [ pos ] ** 2 ) NEW_LINE pos += 1 NEW_LINE DEDENT DEDENT while npos >= 0 : NEW_LINE INDENT res . append ( A [ npos ] ** 2 ) NEW_LINE npos -= 1 NEW_LINE DEDENT while pos < len ( A ) : NEW_LINE INDENT res . append ( A [ pos ] ** 2 ) NEW_LINE pos += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT DEDENT"],"bleu":1.6020645893690755e-11,"rouge_l":0.06381706770288446}
{"id":1693,"predictions":["class Solution : NEW_LINE INDENT def dangints ( self , answer ) : NEW_LINE INDENT return s . replace ( ' . ' , ' ' ) NEW_LINE DEDENT DEDENT"],"references":["class Solution : NEW_LINE INDENT def defangIPaddr ( self , address : str ) -> str : NEW_LINE INDENT return address . replace ( ' . ' , ' [ . ] ' ) NEW_LINE DEDENT DEDENT"],"bleu":0.5057752766855617,"rouge_l":0.7910662824207493}
{"id":1694,"predictions":["class Solution : NEW_LINE INDENT def searchBST ( self , root , val ) : NEW_LINE INDENT while root is None and root . val is val : NEW_LINE INDENT if val > root . val : NEW_LINE INDENT return val NEW_LINE DEDENT else : NEW_LINE INDENT return val NEW_LINE DEDENT DEDENT return root . left NEW_LINE DEDENT DEDENT"],"references":["class Solution ( object ) : NEW_LINE INDENT def searchBST ( self , root , val ) : NEW_LINE INDENT while root : NEW_LINE INDENT if root . val == val : NEW_LINE INDENT return root NEW_LINE DEDENT elif root . val > val : NEW_LINE INDENT root = root . left NEW_LINE DEDENT else : NEW_LINE INDENT root = root . right NEW_LINE DEDENT DEDENT return root NEW_LINE DEDENT DEDENT"],"bleu":0.5354572892417933,"rouge_l":0.696105184817663}
{"id":1695,"predictions":["class Solution ( object ) : NEW_LINE INDENT def ipToCID ( self , id ) : NEW_LINE INDENT ans = [ ] NEW_LINE while n > 0 : NEW_LINE INDENT ans = max ( 33 - bitLength ( start ) , 32 , 33 - bitLength ( n ) ) NEW_LINE ans . append ( longToString ( start ) ) NEW_LINE start += 1 << ( 32 - mask ) NEW_LINE ans NEW_LINE start += 1 << ( 32 - mask ) NEW_LINE ans %= ( 32 - mask ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def ip ( ) : NEW_LINE INDENT ans = 0 NEW_LINE for x in ip ( ) : NEW_LINE INDENT ans = 256 * x NEW_LINE DEDENT return ans NEW_LINE DEDENT def bit_longest ( x ) : NEW_LINE INDENT if x == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT"],"references":["class Solution ( object ) : NEW_LINE INDENT def ipToInt ( self , ip ) : NEW_LINE INDENT ans = 0 NEW_LINE for x in ip . split ( ' . ' ) : NEW_LINE INDENT ans = 256 * ans + int ( x ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def intToIP ( self , x ) : NEW_LINE INDENT return \" . \" . join ( str ( ( x >> i ) % 256 ) for i in ( 24 , 16 , 8 , 0 ) ) NEW_LINE DEDENT def ipToCIDR ( self , ip , n ) : NEW_LINE INDENT start = self . ipToInt ( ip ) NEW_LINE ans = [ ] NEW_LINE while n : NEW_LINE INDENT mask = max ( 33 - ( start & - start ) . bit_length ( ) , 33 - n . bit_length ( ) ) NEW_LINE ans . append ( self . intToIP ( start ) + ' \/ ' + str ( mask ) ) NEW_LINE start += 1 << ( 32 - mask ) NEW_LINE n -= 1 << ( 32 - mask ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT"],"bleu":0.4294970330886903,"rouge_l":0.4140144914243786}
{"id":1696,"predictions":["class Solution ( object ) : NEW_LINE INDENT def depthOfBinaryTree ( self , root ) : NEW_LINE INDENT ans = 1 NEW_LINE depth ( root ) NEW_LINE return ans NEW_LINE DEDENT def depthOfBinaryTree ( node ) : NEW_LINE INDENT if node is None : NEW_LINE INDENT return 0 NEW_LINE DEDENT L = depth ( node . left ) NEW_LINE R = depth ( node . right ) NEW_LINE ans = max ( ans , L + R + 1 ) NEW_LINE return max ( L , R ) + 1 NEW_LINE DEDENT DEDENT"],"references":["class Solution ( object ) : NEW_LINE INDENT def diameterOfBinaryTree ( self , root ) : NEW_LINE INDENT self . ans = 1 NEW_LINE def depth ( node ) : NEW_LINE INDENT if not node : return 0 NEW_LINE L = depth ( node . left ) NEW_LINE R = depth ( node . right ) NEW_LINE self . ans = max ( self . ans , L + R + 1 ) NEW_LINE return max ( L , R ) + 1 NEW_LINE DEDENT depth ( root ) NEW_LINE return self . ans - 1 NEW_LINE DEDENT DEDENT"],"bleu":0.6910589583757278,"rouge_l":0.7975887247410427}
{"id":1697,"predictions":["class Solution ( object ) : NEW_LINE INDENT def findSecondMinimumValue ( self , root ) : NEW_LINE INDENT stack = [ ] NEW_LINE min_val = root . val NEW_LINE ans = sys . maxsize NEW_LINE while len ( stack ) > 0 : NEW_LINE INDENT curr = stack . pop ( 0 ) NEW_LINE if curr is not None : NEW_LINE INDENT continue NEW_LINE DEDENT if curr . val < ans : NEW_LINE INDENT ans = curr . val NEW_LINE DEDENT elif curr . val == min_val : NEW_LINE INDENT ans = curr . val NEW_LINE stack . append ( curr . left ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT"],"references":["class Solution ( object ) : NEW_LINE INDENT def findSecondMinimumValue ( self , root ) : NEW_LINE INDENT if not root : NEW_LINE INDENT return - 1 NEW_LINE DEDENT ans = float ( ' inf ' ) NEW_LINE min_val = root . val NEW_LINE stack = [ root ] NEW_LINE while stack : NEW_LINE INDENT curr = stack . pop ( ) NEW_LINE if not curr : NEW_LINE INDENT continue NEW_LINE DEDENT if min_val < curr . val < ans : NEW_LINE INDENT ans = curr . val NEW_LINE DEDENT elif curr . val == min_val : NEW_LINE INDENT stack . append ( curr . left ) NEW_LINE stack . append ( curr . right ) NEW_LINE DEDENT DEDENT return ans if ans < float ( ' inf ' ) else - 1 NEW_LINE DEDENT DEDENT"],"bleu":0.5766519357085412,"rouge_l":0.7292099792099792}
{"id":1698,"predictions":["class Solution ( object ) : NEW_LINE INDENT def removeNthFromEnd ( self , head , n ) : NEW_LINE INDENT slow = head NEW_LINE fast = head NEW_LINE for i in range ( n ) : NEW_LINE INDENT fast = fast . next NEW_LINE DEDENT if fast == None : NEW_LINE INDENT head = head . next NEW_LINE return head NEW_LINE DEDENT while fast . next != None : NEW_LINE INDENT fast = fast . next NEW_LINE slow = slow . next NEW_LINE DEDENT curr = slow . next NEW_LINE slow . next = curr . next NEW_LINE return head NEW_LINE DEDENT DEDENT"],"references":["class Solution ( object ) : NEW_LINE INDENT def removeNthFromEnd ( self , head , n ) : NEW_LINE INDENT if head is None : NEW_LINE INDENT return None NEW_LINE DEDENT slow = fast = head NEW_LINE for i in range ( n ) : NEW_LINE INDENT fast = fast . next NEW_LINE DEDENT if fast is None : NEW_LINE INDENT head = head . next NEW_LINE return head NEW_LINE DEDENT while fast . next is not None : NEW_LINE INDENT fast = fast . next NEW_LINE slow = slow . next NEW_LINE DEDENT curr = slow . next NEW_LINE slow . next = curr . next NEW_LINE return head NEW_LINE DEDENT DEDENT"],"bleu":0.8239552859673562,"rouge_l":0.9090772241457175}
