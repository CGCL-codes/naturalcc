{"id":0,"predictions":["a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a < b : NEW_LINE INDENT print ( a - b ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a ) NEW_LINE DEDENT"],"references":["x , y = map ( int , str ( input ( ) ) . split ( ' ▁ ' ) ) NEW_LINE print ( ' { } ' . format ( x if x > y else y ) ) NEW_LINE","X , Y = ( int ( i ) for i in input ( ) . split ( ) ) NEW_LINE if X > Y : NEW_LINE INDENT print ( X ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( Y ) NEW_LINE DEDENT","def return_max ( x , y ) : NEW_LINE INDENT return x if x > y else y NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x , y , = map ( int , input ( ) . split ( ) ) NEW_LINE print ( return_max ( x , y ) ) NEW_LINE DEDENT","print ( max ( [ int ( i ) for i in input ( ) . split ( ) ] ) ) NEW_LINE","lsit_ = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( max ( lsit_ ) ) NEW_LINE"],"bleu":0.6465746242222346,"rouge_l":0.7337540334109383}
{"id":1,"predictions":["import sys , mathfrom collections import deque , defaultdictimport operator as opfrom functools import reducefrom itertools import permutations   NEW_LINE"],"references":["s = input ( ) NEW_LINE if len ( s ) != 26 : NEW_LINE INDENT se = set ( [ ] ) NEW_LINE for w in s : NEW_LINE INDENT se . add ( w ) NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT w = chr ( ord ( ' a ' ) + i ) NEW_LINE if w not in se : NEW_LINE INDENT print ( s + w ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT DEDENT if s == \" zyxwvutsrqponmlkjihgfedcba \" : NEW_LINE INDENT print ( - 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT se = set ( [ ] ) NEW_LINE for i in reversed ( range ( 26 ) ) : NEW_LINE INDENT se . add ( s [ i ] ) NEW_LINE for j in range ( ord ( s [ i ] ) - ord ( ' a ' ) + 1 , 26 ) : NEW_LINE INDENT if chr ( ord ( ' a ' ) + j ) in se : NEW_LINE INDENT print ( s [ : i ] + chr ( ord ( ' a ' ) + j ) ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT DEDENT","import numpy as np NEW_LINE alpha = list ( ' abcdefghijklmnopqrstuvwxyz ' ) NEW_LINE alpha_num = [ num for num in range ( 26 ) ] NEW_LINE d = { char : num for ( char , num ) in zip ( alpha , range ( 26 ) ) } NEW_LINE S = input ( ) NEW_LINE S_num = np . array ( [ d [ char ] for char in S ] ) NEW_LINE last = S_num [ - 1 ] NEW_LINE flag = True NEW_LINE if len ( S ) < 26 : NEW_LINE INDENT S_num . sort ( ) NEW_LINE for k in range ( len ( S_num ) ) : NEW_LINE INDENT if S_num [ k ] != alpha_num [ k ] : NEW_LINE INDENT print ( S + alpha [ k ] ) NEW_LINE flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if flag : NEW_LINE INDENT print ( S + alpha [ len ( S ) ] ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for k in reversed ( range ( 1 , 26 ) ) : NEW_LINE INDENT if S_num [ k ] > S_num [ k - 1 ] : NEW_LINE INDENT A = S_num [ k : ] NEW_LINE A = A [ A > S_num [ k - 1 ] ] NEW_LINE A . sort ( ) NEW_LINE print ( S [ : k - 1 ] + alpha [ A [ 0 ] ] ) NEW_LINE flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if flag : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT","import string NEW_LINE alphabet = string . ascii_lowercase NEW_LINE S = input ( ) NEW_LINE count = list ( map ( lambda x : S . count ( x ) , alphabet ) ) NEW_LINE for a in alphabet : NEW_LINE INDENT if count [ alphabet . index ( a ) ] == 0 : NEW_LINE INDENT print ( S + a ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT count = [ 0 for _ in range ( len ( alphabet ) ) ] NEW_LINE cand = \" \" NEW_LINE for i , s in enumerate ( S [ : : - 1 ] ) : NEW_LINE INDENT cand += s NEW_LINE if i == len ( S ) - 1 : NEW_LINE INDENT print ( - 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT res = \" \" NEW_LINE for a in cand : NEW_LINE INDENT if ord ( S [ - ( i + 2 ) ] ) < ord ( a ) : NEW_LINE INDENT if res and res < S [ : len ( S ) - i - 2 ] + a : NEW_LINE INDENT exit NEW_LINE DEDENT else : NEW_LINE INDENT res = S [ : len ( S ) - i - 2 ] + a NEW_LINE DEDENT DEDENT DEDENT if res : NEW_LINE INDENT print ( res ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT","import sys NEW_LINE import heapq NEW_LINE INF = float ( ' inf ' ) NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def II ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def SI ( ) : return input ( ) NEW_LINE def main ( ) : NEW_LINE INDENT s = SI ( ) NEW_LINE ss = [ ord ( c ) for c in s ] NEW_LINE abc = [ ord ( c ) for c in ' abcdefghijklmnopqrstuvwxyz ' ] NEW_LINE if len ( s ) < 26 : NEW_LINE INDENT sss = set ( ss ) NEW_LINE for c in abc : NEW_LINE INDENT if c not in sss : NEW_LINE INDENT return s + chr ( c ) NEW_LINE DEDENT DEDENT DEDENT hq = [ ] NEW_LINE prev = ss [ - 1 ] NEW_LINE for i in range ( len ( s ) ) [ : : - 1 ] : NEW_LINE INDENT c = ss [ i ] NEW_LINE if c >= prev : NEW_LINE INDENT heapq . heappush ( hq , c ) NEW_LINE DEDENT else : NEW_LINE INDENT while hq and hq [ 0 ] < c : NEW_LINE INDENT heapq . heappop ( hq ) NEW_LINE DEDENT return s [ : i ] + chr ( hq [ 0 ] ) NEW_LINE DEDENT prev = c NEW_LINE DEDENT return - 1 NEW_LINE DEDENT print ( main ( ) ) NEW_LINE","S = input ( ) NEW_LINE import sys NEW_LINE if S == ' zyxwvutsrqponmlkjihgfedcba ' : NEW_LINE INDENT print ( - 1 ) NEW_LINE sys . exit ( 0 ) NEW_LINE DEDENT atoz = list ( map ( chr , range ( 97 , 123 ) ) ) NEW_LINE charmap = dict ( ) NEW_LINE for c in atoz : NEW_LINE INDENT charmap [ c ] = 0 NEW_LINE DEDENT for s in S : NEW_LINE INDENT charmap [ s ] += 1 NEW_LINE DEDENT flag = 0 NEW_LINE for c in atoz : NEW_LINE INDENT if charmap [ c ] == 0 : NEW_LINE INDENT flag = 1 NEW_LINE S = S + c NEW_LINE break NEW_LINE DEDENT DEDENT if flag == 0 : NEW_LINE INDENT index = 0 NEW_LINE for i in range ( len ( S ) - 1 ) : NEW_LINE INDENT if S [ - 1 - i ] > S [ - 2 - i ] : NEW_LINE INDENT index = - 2 - i NEW_LINE break NEW_LINE DEDENT DEDENT tmp = sorted ( list ( S [ index + 1 : ] ) ) NEW_LINE for t in tmp : NEW_LINE INDENT if t > S [ index ] : NEW_LINE INDENT S = S [ : index ] + t NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT print ( S ) NEW_LINE"],"bleu":5.182824763637531e-6,"rouge_l":0.03488106129917658}
{"id":2,"predictions":["N , T = map ( int , input ( ) . split ( ) ) NEW_LINE amount = 0 NEW_LINE pre = int ( input ( ) ) NEW_LINE for _ in range ( N - 1 ) : NEW_LINE INDENT a = int ( input ( ) ) NEW_LINE if ( a - pre ) < T : NEW_LINE INDENT amount += ( a - pre ) NEW_LINE DEDENT else : NEW_LINE INDENT amount += T NEW_LINE DEDENT pre = a NEW_LINE DEDENT amount += T NEW_LINE print ( amount ) NEW_LINE"],"references":["def getInt ( ) : return int ( input ( ) ) NEW_LINE def getIntList ( ) : return [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE def dmp ( x ) : NEW_LINE INDENT global debug NEW_LINE if debug : NEW_LINE INDENT print ( x ) NEW_LINE DEDENT DEDENT def probC ( ) : NEW_LINE INDENT N , T = getIntList ( ) NEW_LINE Ts = getIntList ( ) NEW_LINE dmp ( ( N , T , Ts ) ) NEW_LINE total = Ts [ 0 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT total += min ( T , Ts [ i ] - Ts [ i - 1 ] ) NEW_LINE DEDENT return total + T NEW_LINE DEDENT debug = False NEW_LINE print ( probC ( ) ) NEW_LINE","import array NEW_LINE from bisect import * NEW_LINE from collections import * NEW_LINE import fractions NEW_LINE import heapq NEW_LINE from itertools import * NEW_LINE import math NEW_LINE import random NEW_LINE import re NEW_LINE import string NEW_LINE import sys NEW_LINE N , T = map ( int , input ( ) . split ( ) ) NEW_LINE prev = None NEW_LINE ans = 0 NEW_LINE for t in map ( int , input ( ) . split ( ) ) : NEW_LINE INDENT if prev is not None : NEW_LINE INDENT if t - prev < T : NEW_LINE INDENT ans += t - prev NEW_LINE DEDENT else : NEW_LINE INDENT ans += T NEW_LINE DEDENT DEDENT prev = t NEW_LINE DEDENT ans += T NEW_LINE print ( ans ) NEW_LINE","n , T = map ( int , input ( ) . split ( ) ) NEW_LINE t = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE t = [ 0 ] + t NEW_LINE time = t [ - 1 ] NEW_LINE for a in range ( 1 , n + 1 ) : NEW_LINE INDENT if t [ a ] - t [ a - 1 ] > T : NEW_LINE INDENT time -= ( t [ a ] - t [ a - 1 ] ) - T NEW_LINE DEDENT DEDENT print ( time + T ) NEW_LINE","N , T = map ( int , input ( ) . split ( ' ▁ ' ) ) NEW_LINE times = list ( map ( int , input ( ) . split ( ' ▁ ' ) ) ) NEW_LINE print ( sum ( [ min ( T , times [ i + 1 ] - times [ i ] ) for i in range ( N - 1 ) ] ) + T ) NEW_LINE","from functools import reduce NEW_LINE import math NEW_LINE def main ( ) : NEW_LINE INDENT N , T = ( int ( _ ) for _ in input ( ) . split ( ) ) NEW_LINE t = list ( int ( _ ) for _ in input ( ) . split ( ) ) NEW_LINE sum = T NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if ( t [ i ] - t [ i - 1 ] > T ) : NEW_LINE INDENT sum += T NEW_LINE DEDENT else : NEW_LINE INDENT sum += t [ i ] - t [ i - 1 ] NEW_LINE DEDENT DEDENT print ( sum ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"bleu":0.5668466329768836,"rouge_l":0.5259330035971223}
{"id":3,"predictions":["n = int ( input ( ) ) NEW_LINE a = n + 1 NEW_LINE if ( a % 2 == 0 ) : NEW_LINE INDENT print ( a ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a ) NEW_LINE DEDENT"],"references":["n = int ( input ( ) ) NEW_LINE if n % 2 == 0 : NEW_LINE INDENT print ( n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n + 1 ) NEW_LINE DEDENT","def pair ( N : int ) -> int : NEW_LINE INDENT if N % 2 == 0 : NEW_LINE INDENT return N - 1 NEW_LINE DEDENT return N + 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE ans = pair ( N ) NEW_LINE print ( ans ) NEW_LINE DEDENT","a = int ( input ( ) ) NEW_LINE print ( a + 1 if a % 2 else a - 1 ) NEW_LINE","n = int ( input ( ) ) NEW_LINE if n % 2 : NEW_LINE INDENT n += 1 NEW_LINE DEDENT else : NEW_LINE INDENT n -= 1 NEW_LINE DEDENT print ( n ) NEW_LINE","n = int ( input ( ) ) NEW_LINE print ( n + 1 if n % 2 == 1 else n - 1 ) NEW_LINE"],"bleu":0.6616376313173784,"rouge_l":0.782051282051282}
{"id":4,"predictions":["N = int ( input ( ) ) NEW_LINE if N == 1 : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT print ( i , end = \" \" ) NEW_LINE DEDENT DEDENT"],"references":["import math NEW_LINE def main ( ) : NEW_LINE INDENT [ K , N ] = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE r = [ ] NEW_LINE if K == 1 : NEW_LINE INDENT r = [ 1 ] * ( ( N + 1 ) \/\/ 2 ) NEW_LINE DEDENT elif K % 2 == 0 : NEW_LINE INDENT r = [ K \/\/ 2 ] NEW_LINE r += [ K ] * ( N - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT t = N \/\/ 2 NEW_LINE x = int ( math . log ( N * ( K - 1 ) + 1 , K ) - 1 ) NEW_LINE while t < ( ( K ** ( x + 1 ) - 1 ) \/ ( K - 1 ) + x ) \/\/ 2 : NEW_LINE INDENT x -= 1 NEW_LINE DEDENT x += 1 NEW_LINE r = [ ( K + 1 ) \/\/ 2 ] * ( N - x ) NEW_LINE r += [ 0 ] * x NEW_LINE t = ( ( K ** ( x + 1 ) - 1 ) \/ ( K - 1 ) + x ) \/\/ 2 - t NEW_LINE for i in range ( x , 0 , - 1 ) : NEW_LINE INDENT r [ N - i ] = 1 NEW_LINE t -= 1 NEW_LINE for j in range ( K - 1 ) : NEW_LINE INDENT if t == 0 : NEW_LINE INDENT break NEW_LINE DEDENT if K ** i - 1 <= t * ( K - 1 ) : NEW_LINE INDENT r [ N - i ] += 1 NEW_LINE t -= ( K ** i - 1 ) \/\/ ( K - 1 ) NEW_LINE DEDENT DEDENT if t == 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in range ( len ( r ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if r [ i ] == 0 : NEW_LINE INDENT r . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT print ( ' ▁ ' . join ( list ( map ( str , r ) ) ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT","from itertools import chain , repeat NEW_LINE K , N = map ( int , input ( ) . split ( ) ) NEW_LINE def solve ( ) : NEW_LINE INDENT if K % 2 == 0 : NEW_LINE INDENT return ' ▁ ' . join ( map ( str , chain ( ( K \/\/ 2 , ) , repeat ( K , N - 1 ) ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT seq = [ K \/\/ 2 + 1 ] * N NEW_LINE d = N \/\/ 2 NEW_LINE for _ in range ( d ) : NEW_LINE INDENT if seq [ - 1 ] == 1 : NEW_LINE INDENT seq . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT seq [ - 1 ] -= 1 NEW_LINE seq . extend ( repeat ( K , N - len ( seq ) ) ) NEW_LINE DEDENT DEDENT return ' ▁ ' . join ( map ( str , seq ) ) NEW_LINE DEDENT DEDENT def naive ( ) : NEW_LINE INDENT from itertools import product NEW_LINE s = sorted ( chain . from_iterable ( product ( range ( 1 , K + 1 ) , repeat = i ) for i in range ( 1 , N + 1 ) ) ) NEW_LINE return ' ▁ ' . join ( map ( str , s [ ( len ( s ) - 1 ) \/\/ 2 ] ) ) NEW_LINE DEDENT print ( solve ( ) ) NEW_LINE NEW_LINE","import math NEW_LINE def main ( K , N ) : NEW_LINE INDENT ans = [ ] NEW_LINE if K % 2 == 0 : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT ans . append ( K \/\/ 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( K ) NEW_LINE DEDENT DEDENT DEDENT elif K == 1 : NEW_LINE INDENT n2 = math . ceil ( N \/ 2 ) NEW_LINE for i in range ( n2 ) : NEW_LINE INDENT ans . append ( 1 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT K2 = math . ceil ( K \/ 2 ) NEW_LINE ans = [ K2 ] * N NEW_LINE n = N \/\/ 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ans [ - 1 ] == 1 : NEW_LINE INDENT ans . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT ans [ - 1 ] -= 1 NEW_LINE while len ( ans ) < N : NEW_LINE INDENT ans . append ( K ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return ' ▁ ' . join ( map ( str , ans ) ) NEW_LINE DEDENT K , N = map ( int , input ( ) . split ( ) ) NEW_LINE print ( main ( K , N ) ) NEW_LINE","def solve ( k , n ) : NEW_LINE INDENT if k & 1 == 0 : NEW_LINE INDENT return [ k \/\/ 2 ] + [ k ] * ( n - 1 ) NEW_LINE DEDENT ans = [ k \/\/ 2 + 1 ] * n NEW_LINE l = n NEW_LINE for i in range ( ( n - 2 ) \/\/ 2 + 1 ) : NEW_LINE INDENT if ans [ - 1 ] == 1 : NEW_LINE INDENT ans . pop ( ) NEW_LINE l -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans [ - 1 ] -= 1 NEW_LINE if l < n : NEW_LINE INDENT ans += [ k ] * ( n - l ) NEW_LINE l = n NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT k , n = map ( int , input ( ) . split ( ) ) NEW_LINE print ( * solve ( k , n ) ) NEW_LINE","K , N = map ( int , input ( ) . split ( ) ) NEW_LINE if K % 2 == 0 : NEW_LINE INDENT ans = [ K \/\/ 2 ] NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT ans . append ( K ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT back = N \/\/ 2 NEW_LINE mid = K \/\/ 2 + 1 NEW_LINE ans = [ mid for i in range ( N ) ] NEW_LINE for i in range ( back ) : NEW_LINE INDENT if ans [ - 1 ] == 1 : NEW_LINE INDENT ans . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT ans [ - 1 ] -= 1 NEW_LINE while len ( ans ) < N : NEW_LINE INDENT ans . append ( K ) NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( ' ▁ ' . join ( map ( str , ans ) ) ) NEW_LINE"],"bleu":0.155005480085938,"rouge_l":0.38415493592865435}
{"id":5,"predictions":["import sys NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE input = sys . stdin . readline NEW_LINE x = - 1 NEW_LINE n = int ( input ( ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT elif n == 2 : NEW_LINE INDENT print ( ' ! ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' ? ' ) NEW_LINE DEDENT"],"references":["A , B = map ( int , input ( ) . split ( ) ) NEW_LINE if A <= 8 and B <= 8 : NEW_LINE INDENT print ( ' Yay ! ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' : ( ' ) NEW_LINE DEDENT","i = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE A = i [ 0 ] NEW_LINE B = i [ 1 ] NEW_LINE if ( A - B > 1 or B - A > 1 ) : NEW_LINE INDENT print ( ' : ( ' ) NEW_LINE DEDENT if ( ( A - B ) == 0 or ( A - B ) == 1 or ( B - A ) == 0 or ( B - A ) == 1 ) : NEW_LINE INDENT print ( ' Yay ! ' ) NEW_LINE DEDENT","print ( ' Yay ! ' if max ( [ int ( i ) for i in input ( ) . split ( ) ] ) <= 8 else ' : ( ' ) NEW_LINE","def main ( ) : NEW_LINE INDENT A , B = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE print ( ' Yay ! ' ) if A <= 8 and B <= 8 else print ( ' : ( ' ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT","if 8 >= max ( map ( int , input ( ) . split ( ) ) ) : NEW_LINE INDENT print ( \" Yay ! \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" : ( \" ) NEW_LINE DEDENT"],"bleu":0.346910546502395,"rouge_l":0.5263959390862945}
{"id":6,"predictions":["import sys NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE INF = 10 ** 18 NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def II ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def SI ( ) : return input ( ) NEW_LINE def main ( ) : NEW_LINE INDENT N , A = LI ( ) NEW_LINE B = LI ( ) NEW_LINE from collections import Counter NEW_LINE if A == 0 and B == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE exit ( ) NEW_LINE DEDENT d = Counter ( ) NEW_LINE mod = 10 ** 9 + 7 NEW_LINE for _ in range ( N - 1 ) : NEW_LINE INDENT i = int ( A * i ) \/ 2 NEW_LINE d [ i ] = min ( d [ i + 1 ] , d [ i ] + mod NEW_LINE DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT d [ i ] = ( d [ i ] , i ) NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT ans += ( N * A [ i ] - A [ i - 1 ] ) % MOD NEW_LINE DEDENT return ans NEW_LINE DEDENT print ( main ( ) ) ) NEW_LINE"],"references":["import heapq NEW_LINE N , A , B = map ( int , input ( ) . split ( ) ) NEW_LINE src = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if A == 1 : NEW_LINE INDENT for v in sorted ( src ) : NEW_LINE INDENT print ( v ) NEW_LINE DEDENT exit ( ) NEW_LINE DEDENT mem = [ ] NEW_LINE maxv = 0 NEW_LINE for i , v in enumerate ( src ) : NEW_LINE INDENT mem . append ( ( v , i ) ) NEW_LINE if v > maxv : maxv = v NEW_LINE DEDENT heapq . heapify ( mem ) NEW_LINE while True : NEW_LINE INDENT v , i = heapq . heappop ( mem ) NEW_LINE if B == 0 or ( v * A > maxv and B % N == 0 ) : NEW_LINE INDENT heapq . heappush ( mem , ( v , i ) ) NEW_LINE break NEW_LINE DEDENT maxv = max ( maxv , v * A ) NEW_LINE heapq . heappush ( mem , ( v * A , i ) ) NEW_LINE B -= 1 NEW_LINE DEDENT MOD = 10 ** 9 + 7 NEW_LINE p = pow ( A , B \/\/ N , MOD ) NEW_LINE while mem : NEW_LINE INDENT v , i = heapq . heappop ( mem ) NEW_LINE print ( ( v * p ) % MOD ) NEW_LINE DEDENT","def pow_mod ( a , b ) : NEW_LINE INDENT res = 1 NEW_LINE while b > 0 : NEW_LINE INDENT if b & 1 : NEW_LINE INDENT res = ( res * a ) % MOD NEW_LINE DEDENT b >>= 1 NEW_LINE a = ( a * a ) % MOD NEW_LINE DEDENT return res ; NEW_LINE DEDENT MOD = 1000000007 NEW_LINE N , A , B = map ( int , input ( ) . split ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE arr . sort ( ) NEW_LINE if A == 1 : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT print ( arr [ i ] % MOD ) NEW_LINE DEDENT exit ( ) NEW_LINE DEDENT count = 0 NEW_LINE num_max = arr [ N - 1 ] NEW_LINE for i in range ( B ) : NEW_LINE INDENT if arr [ 0 ] * A > arr [ N - 1 ] : NEW_LINE INDENT break NEW_LINE DEDENT count += 1 NEW_LINE arr [ 0 ] *= A NEW_LINE arr . sort ( ) NEW_LINE DEDENT B -= count NEW_LINE for i in range ( B % N ) : NEW_LINE INDENT arr [ i ] *= A NEW_LINE DEDENT arr . sort ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT arr [ i ] %= MOD NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT arr [ i ] *= pow_mod ( A % MOD , B \/\/ N ) NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT print ( arr [ i ] % MOD ) NEW_LINE DEDENT exit ( ) NEW_LINE DEDENT","import sys NEW_LINE import heapq NEW_LINE import bisect NEW_LINE import operator NEW_LINE from itertools import * NEW_LINE sys . setrecursionlimit ( 100000 ) NEW_LINE def read ( ) : NEW_LINE INDENT return int ( input ( ) ) NEW_LINE DEDENT def reads ( ) : NEW_LINE INDENT return [ int ( s ) for s in input ( ) . split ( ) ] NEW_LINE DEDENT M = 10 ** 9 + 7 NEW_LINE ( N , A , B ) = reads ( ) NEW_LINE aa = reads ( ) NEW_LINE aa . sort ( ) NEW_LINE if A == 1 : NEW_LINE INDENT for a in aa : NEW_LINE INDENT print ( a ) NEW_LINE DEDENT sys . exit ( ) NEW_LINE DEDENT aa = [ ( aa [ i ] , i ) for i in range ( N ) ] NEW_LINE count = B NEW_LINE while B > 0 : NEW_LINE INDENT ( a , i ) = aa [ 0 ] NEW_LINE if i == N - 1 : NEW_LINE INDENT break NEW_LINE DEDENT aa . pop ( 0 ) NEW_LINE aa . append ( ( a * A , i ) ) NEW_LINE aa . sort ( ) NEW_LINE B -= 1 NEW_LINE DEDENT aa = [ a % M for ( a , i ) in aa ] NEW_LINE Q = B \/\/ N NEW_LINE R = B % N NEW_LINE aa = [ ( a * pow ( A , Q , M ) ) % M for a in aa ] NEW_LINE for _ in range ( R ) : NEW_LINE INDENT a = aa . pop ( 0 ) NEW_LINE aa . append ( ( a * A ) % M ) NEW_LINE DEDENT for a in aa : NEW_LINE INDENT print ( a ) NEW_LINE DEDENT","n , a , b = ( int ( i ) for i in input ( ) . split ( ) ) NEW_LINE x = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE x , y , c , mod = sorted ( x ) , [ ] , 0 , 10 ** 9 + 7 NEW_LINE if a - 1 : NEW_LINE INDENT for i in x : NEW_LINE INDENT m = i NEW_LINE while m * a < x [ - 1 ] : NEW_LINE INDENT m *= a NEW_LINE c += 1 NEW_LINE DEDENT y . append ( m ) NEW_LINE DEDENT if b <= c : NEW_LINE INDENT for i in range ( b ) : NEW_LINE INDENT x [ 0 ] *= a NEW_LINE x . sort ( ) NEW_LINE DEDENT for i in x : print ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT d , e , y = ( b - c ) \/\/ n , ( b - c ) % n , sorted ( y ) NEW_LINE for i in range ( e ) : y [ i ] = ( y [ i ] * pow ( a , d + 1 , mod ) ) % mod NEW_LINE for i in range ( e , n ) : y [ i ] = ( y [ i ] * pow ( a , d , mod ) ) % mod NEW_LINE for i in y [ e : ] + y [ : e ] : print ( i ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in x : print ( i ) NEW_LINE DEDENT","import sys NEW_LINE from collections import defaultdict , Counter NEW_LINE from itertools import product , groupby , count , permutations , combinations NEW_LINE from math import pi , sqrt , ceil , floor NEW_LINE from collections import deque NEW_LINE from bisect import bisect , bisect_left , bisect_right NEW_LINE from string import ascii_lowercase NEW_LINE from functools import lru_cache , reduce NEW_LINE from operator import xor NEW_LINE from heapq import heappush , heappop NEW_LINE INF = float ( \" inf \" ) NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE dy4 , dx4 = [ 0 , - 1 , 0 , 1 ] , [ 1 , 0 , - 1 , 0 ] NEW_LINE def inside ( y : int , x : int , H : int , W : int ) -> bool : return 0 <= y < H and 0 <= x < W NEW_LINE def ceil ( a , b ) : return ( a + b - 1 ) \/\/ b NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE def main ( ) : NEW_LINE INDENT N , A , B = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) ) NEW_LINE if A == 1 : NEW_LINE INDENT print ( * a , sep = \" \\n \" ) NEW_LINE return NEW_LINE DEDENT while B > 0 : NEW_LINE INDENT if a [ - 1 ] <= a [ 0 ] * A : NEW_LINE INDENT break NEW_LINE DEDENT a [ 0 ] *= A NEW_LINE a . sort ( ) NEW_LINE B -= 1 NEW_LINE DEDENT if B == 0 : NEW_LINE INDENT print ( * a , sep = \" \\n \" ) NEW_LINE return NEW_LINE DEDENT mul = B \/\/ N NEW_LINE remain = B % N NEW_LINE for i in range ( remain , N ) : NEW_LINE INDENT print ( a [ i ] * pow ( A , mul , MOD ) % MOD ) NEW_LINE DEDENT for i in range ( remain ) : NEW_LINE INDENT print ( a [ i ] * pow ( A , mul + 1 , MOD ) % MOD ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"bleu":0.42801623282546236,"rouge_l":0.3946985768824413}
{"id":7,"predictions":["n , m = map ( int , input ( ) . split ( ) ) print ( n + ( n - 1 ) \/\/ ( m - 1 ) ) NEW_LINE"],"references":["m , n , N = [ int ( _ ) for _ in input ( ) . split ( ) ] NEW_LINE result = N NEW_LINE s = N NEW_LINE while s >= m : NEW_LINE INDENT x , s = divmod ( s , m ) NEW_LINE s += x * n NEW_LINE result += x * n NEW_LINE DEDENT print ( result ) NEW_LINE","m , n , N = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( N - n ) \/\/ ( m - n ) * n + N ) NEW_LINE","m , n , N = map ( int , input ( ) . split ( ) ) NEW_LINE res = N NEW_LINE tmp = N NEW_LINE g = 0 NEW_LINE while True : NEW_LINE INDENT e = 0 NEW_LINE flag = False NEW_LINE for i in range ( tmp ) : NEW_LINE INDENT g += 1 NEW_LINE if g == m : NEW_LINE INDENT res += n NEW_LINE g = 0 NEW_LINE e += n NEW_LINE flag = True NEW_LINE DEDENT DEDENT if flag == False : NEW_LINE INDENT break NEW_LINE DEDENT tmp = e NEW_LINE DEDENT print ( res ) NEW_LINE","def main ( ) : NEW_LINE INDENT m , n , r = map ( int , input ( ) . split ( ) ) NEW_LINE print ( solve ( m , n , r ) ) NEW_LINE DEDENT def solve ( m , n , r ) : NEW_LINE INDENT s = 0 NEW_LINE t = 0 NEW_LINE while r != 0 : NEW_LINE INDENT s += r NEW_LINE t += r NEW_LINE r = t \/\/ m * n NEW_LINE t = t % m NEW_LINE DEDENT return s NEW_LINE DEDENT main ( ) NEW_LINE","m , n , firstm = map ( int , input ( ) . split ( ) ) NEW_LINE sold = firstm NEW_LINE sell = firstm NEW_LINE rest = 0 NEW_LINE while rest + sell >= m : NEW_LINE INDENT z = sell \/\/ m * n NEW_LINE rest += sell % m NEW_LINE if rest >= m : NEW_LINE INDENT z += rest \/\/ m * n NEW_LINE rest %= m NEW_LINE DEDENT sell = z NEW_LINE sold += sell NEW_LINE DEDENT print ( sold ) NEW_LINE"],"bleu":0.5274095035594596,"rouge_l":0.7510259917920656}
{"id":8,"predictions":["x , y , x , y = map ( int , input ( ) . split ( ) ) NEW_LINE ans = float ( \" inf \" ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a < b : NEW_LINE INDENT ans = min ( ans , a - b - a - 1 ) NEW_LINE DEDENT ans = min ( ans , b - a ) NEW_LINE DEDENT print ( ans ) NEW_LINE"],"references":["w , h , n = map ( int , input ( ) . split ( ) ) NEW_LINE x1 = [ ] NEW_LINE x2 = [ ] NEW_LINE y3 = [ ] NEW_LINE y4 = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT x , y , a = map ( int , input ( ) . split ( ) ) NEW_LINE if a == 1 : NEW_LINE INDENT x1 . append ( x ) NEW_LINE DEDENT elif a == 2 : NEW_LINE INDENT x2 . append ( x ) NEW_LINE DEDENT elif a == 3 : NEW_LINE INDENT y3 . append ( y ) NEW_LINE DEDENT else : NEW_LINE INDENT y4 . append ( y ) NEW_LINE DEDENT DEDENT for t in [ x1 , y3 ] : NEW_LINE INDENT if not t : NEW_LINE INDENT t . append ( 0 ) NEW_LINE DEDENT DEDENT if not x2 : NEW_LINE INDENT x2 . append ( w ) NEW_LINE DEDENT if not y4 : NEW_LINE INDENT y4 . append ( h ) NEW_LINE DEDENT if max ( x1 ) >= min ( x2 ) or max ( y3 ) >= min ( y4 ) : NEW_LINE INDENT print ( 0 ) NEW_LINE exit ( ) NEW_LINE DEDENT print ( ( min ( x2 ) - max ( x1 ) ) * ( min ( y4 ) - max ( y3 ) ) ) NEW_LINE","import sys , re NEW_LINE from collections import deque , defaultdict , Counter NEW_LINE from math import ceil , sqrt , hypot , factorial , pi , sin , cos , radians NEW_LINE from itertools import permutations , combinations , product NEW_LINE from operator import itemgetter , mul NEW_LINE from copy import deepcopy NEW_LINE from string import ascii_lowercase , ascii_uppercase , digits NEW_LINE def input ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def INT ( ) : return int ( input ( ) ) NEW_LINE def MAP ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE INF = float ( ' inf ' ) NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE W , H , N = MAP ( ) NEW_LINE xya = [ LIST ( ) for _ in range ( N ) ] NEW_LINE right = W NEW_LINE left = 0 NEW_LINE top = H NEW_LINE bottom = 0 NEW_LINE for x , y , a in xya : NEW_LINE INDENT if a == 1 and left < x < right : NEW_LINE INDENT left = x NEW_LINE DEDENT elif a == 1 and right <= x : NEW_LINE INDENT S = 0 NEW_LINE break NEW_LINE DEDENT elif a == 2 and left < x < right : NEW_LINE INDENT right = x NEW_LINE DEDENT elif a == 2 and x <= left : NEW_LINE INDENT S = 0 NEW_LINE break NEW_LINE DEDENT elif a == 3 and bottom < y < top : NEW_LINE INDENT bottom = y NEW_LINE DEDENT elif a == 3 and top <= y : NEW_LINE INDENT S = 0 NEW_LINE break NEW_LINE DEDENT elif a == 4 and bottom < y < top : NEW_LINE INDENT top = y NEW_LINE DEDENT elif a == 4 and y <= bottom : NEW_LINE INDENT S = 0 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT pass NEW_LINE DEDENT S = ( right - left ) * ( top - bottom ) NEW_LINE DEDENT if S <= 0 : NEW_LINE INDENT S = 0 NEW_LINE DEDENT print ( S ) NEW_LINE","w , h , n = [ int ( i ) for i in input ( ) . split ( ' ▁ ' ) ] NEW_LINE x1 , x2 , y1 , y2 = 0 , w , 0 , h NEW_LINE for i in range ( n ) : NEW_LINE INDENT x , y , a = [ int ( i ) for i in input ( ) . split ( ' ▁ ' ) ] NEW_LINE if a == 1 : NEW_LINE INDENT x1 = max ( x1 , x ) NEW_LINE DEDENT if a == 2 : NEW_LINE INDENT x2 = min ( x2 , x ) NEW_LINE DEDENT if a == 3 : NEW_LINE INDENT y1 = max ( y1 , y ) NEW_LINE DEDENT if a == 4 : NEW_LINE INDENT y2 = min ( y2 , y ) NEW_LINE DEDENT DEDENT if y2 <= y1 or x2 <= x1 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( max ( 0 , ( y2 - y1 ) * ( x2 - x1 ) ) ) NEW_LINE DEDENT","W , H , N = map ( int , input ( ) . rstrip ( ) . split ( ) ) NEW_LINE xya = [ list ( map ( int , input ( ) . rstrip ( ) . split ( ) ) ) for _ in range ( N ) ] NEW_LINE xy = [ [ 0 ] * H for _ in range ( W ) ] NEW_LINE for i in xya : NEW_LINE INDENT x_y = i [ : 2 ] NEW_LINE a = i [ 2 ] NEW_LINE if a == 1 : NEW_LINE INDENT for j in range ( x_y [ 0 ] ) : NEW_LINE INDENT xy [ j ] = list ( map ( lambda x : x + 1 , xy [ j ] ) ) NEW_LINE DEDENT DEDENT elif a == 2 : NEW_LINE INDENT for j in range ( x_y [ 0 ] , W ) : NEW_LINE INDENT xy [ j ] = list ( map ( lambda x : x + 1 , xy [ j ] ) ) NEW_LINE DEDENT DEDENT elif a == 3 : NEW_LINE INDENT y = x_y [ 1 ] NEW_LINE for j in range ( W ) : NEW_LINE INDENT for k in range ( H ) : NEW_LINE INDENT xy [ j ] [ k ] += 1 if k < y else 0 NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT y = x_y [ 1 ] NEW_LINE for j in range ( W ) : NEW_LINE INDENT for k in range ( H ) : NEW_LINE INDENT xy [ j ] [ k ] += 1 if k >= y else 0 NEW_LINE DEDENT DEDENT DEDENT DEDENT area = 0 NEW_LINE for i in xy : NEW_LINE INDENT area += i . count ( 0 ) NEW_LINE DEDENT print ( area ) NEW_LINE","W , H , N = map ( int , input ( ) . split ( ) ) NEW_LINE cells = [ [ 0 for _ in range ( W ) ] for _ in range ( H ) ] NEW_LINE lists = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] NEW_LINE for ls in lists : NEW_LINE INDENT x , y , a = ls [ 0 ] , ls [ 1 ] , ls [ 2 ] NEW_LINE if a == 1 : NEW_LINE INDENT for h in range ( H ) : NEW_LINE INDENT for w in range ( x ) : NEW_LINE INDENT cells [ h ] [ w ] = 1 NEW_LINE DEDENT DEDENT DEDENT elif a == 2 : NEW_LINE INDENT for h in range ( H ) : NEW_LINE INDENT for w in range ( x , W ) : NEW_LINE INDENT cells [ h ] [ w ] = 1 NEW_LINE DEDENT DEDENT DEDENT elif a == 3 : NEW_LINE INDENT for h in range ( H - y , H ) : NEW_LINE INDENT for w in range ( W ) : NEW_LINE INDENT cells [ h ] [ w ] = 1 NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT for h in range ( H - y ) : NEW_LINE INDENT for w in range ( W ) : NEW_LINE INDENT cells [ h ] [ w ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT count = 0 NEW_LINE for rows in cells : NEW_LINE INDENT count += rows . count ( 0 ) NEW_LINE DEDENT print ( count ) NEW_LINE"],"bleu":0.2184055707667354,"rouge_l":0.40160096977803783}
{"id":9,"predictions":["a = list ( map ( int , input ( ) . split ( \" ▁ \" ) ) ) NEW_LINE a . reverse ( ) NEW_LINE print ( \" First \" ) NEW_LINE"],"references":["S = input ( ) NEW_LINE if S [ 0 ] == S [ - 1 ] : NEW_LINE INDENT if len ( S ) % 2 == 0 : NEW_LINE INDENT print ( \" First \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Second \" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if len ( S ) % 2 == 1 : NEW_LINE INDENT print ( \" First \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Second \" ) NEW_LINE DEDENT DEDENT","ar = list ( input ( ) ) NEW_LINE b = 0 NEW_LINE while True : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , len ( ar ) - 1 ) : NEW_LINE INDENT if ar [ i - 1 ] != ar [ i + 1 ] : NEW_LINE INDENT count += 1 NEW_LINE del ar [ i ] NEW_LINE b += 1 NEW_LINE break NEW_LINE DEDENT DEDENT if count == 0 : NEW_LINE INDENT if b % 2 == 1 : NEW_LINE INDENT print ( \" First \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Second \" ) NEW_LINE DEDENT break NEW_LINE DEDENT DEDENT","s = input ( ) ; print ( [ ' Second ' , ' First ' ] [ ( len ( s ) + ( s [ 0 ] == s [ - 1 ] ) ) % 2 ] ) NEW_LINE","s = input ( ) NEW_LINE S = list ( s ) NEW_LINE f = False NEW_LINE k = 1 NEW_LINE flag = False NEW_LINE while len ( S ) > 2 : NEW_LINE INDENT if k == len ( S ) - 1 : NEW_LINE INDENT if flag : NEW_LINE INDENT k = 1 NEW_LINE flag = False NEW_LINE continue NEW_LINE DEDENT break NEW_LINE DEDENT if S [ k - 1 ] != S [ k + 1 ] : NEW_LINE INDENT S . pop ( k ) NEW_LINE f = not f NEW_LINE flag = True NEW_LINE DEDENT else : NEW_LINE INDENT k += 1 NEW_LINE DEDENT DEDENT if f : NEW_LINE INDENT print ( ' First ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' Second ' ) NEW_LINE DEDENT","s = input ( ) . strip ( ) NEW_LINE is_first = True NEW_LINE for s1 , s2 in zip ( s , s [ 2 : ] ) : NEW_LINE INDENT if s1 != s2 : NEW_LINE INDENT is_first = False NEW_LINE DEDENT DEDENT if is_first : NEW_LINE INDENT print ( ' Second ' ) NEW_LINE DEDENT else : NEW_LINE INDENT if len ( s ) % 2 == 0 : NEW_LINE INDENT if s [ 0 ] == s [ - 1 ] : NEW_LINE INDENT print ( ' First ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' Second ' ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if s [ 0 ] == s [ - 1 ] : NEW_LINE INDENT print ( ' Second ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' First ' ) NEW_LINE DEDENT DEDENT DEDENT"],"bleu":0.31590419594302455,"rouge_l":0.33897448850719875}
{"id":10,"predictions":["import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , copy , functools NEW_LINE"],"references":["print ( ( lambda S : sum ( eval ( ' ' . join ( ' ' . join ( i ) for i in zip ( S , ( [ ' ' , ' + ' ] [ int ( i ) ] for i in ' { :0 > { } b } 0' . format ( i , len ( S ) - 1 ) ) ) ) ) for i in range ( 1 << len ( S ) - 1 ) ) ) ( input ( ) ) ) NEW_LINE","import numpy as np NEW_LINE S = str ( input ( ) ) NEW_LINE N = len ( S ) - 1 NEW_LINE def honyaku ( ini , n ) : NEW_LINE INDENT ans = np . zeros ( n ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT ans [ i ] = ini % 2 NEW_LINE ini = ini \/\/ 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT def sum_list ( list_domain , list_S ) : NEW_LINE INDENT tmp = list_S [ 0 ] NEW_LINE ans = 0 NEW_LINE for i in range ( len ( list_domain ) ) : NEW_LINE INDENT if list_domain [ i ] == 0 : NEW_LINE INDENT tmp = tmp * 10 + list_S [ i + 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT ans += tmp NEW_LINE tmp = list_S [ i + 1 ] NEW_LINE DEDENT DEDENT return tmp + ans NEW_LINE DEDENT list_S = np . zeros ( N + 1 ) NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT list_S [ i ] = int ( S [ i ] ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 2 ** N ) : NEW_LINE INDENT list_domain = honyaku ( i , N ) NEW_LINE ans += sum_list ( list_domain , list_S ) NEW_LINE DEDENT print ( int ( ans ) ) NEW_LINE","ans = 0 NEW_LINE def dfs ( x , len_x , i = 0 ) : NEW_LINE INDENT global ans NEW_LINE if i < len_x : NEW_LINE INDENT dfs ( x , len_x , i = i + 1 ) NEW_LINE DEDENT if i < len_x : NEW_LINE INDENT x = x [ : i + 1 ] + \" + \" + x [ i + 1 : ] NEW_LINE dfs ( x , len_x + 1 , i = i + 2 ) NEW_LINE ans += sum ( [ int ( k ) for k in x . split ( \" + \" ) ] ) NEW_LINE DEDENT if i == len_x : NEW_LINE INDENT return sum ( [ int ( k ) for k in x . split ( \" + \" ) ] ) NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT s = input ( ) NEW_LINE dfs ( s , len ( s ) - 1 ) NEW_LINE print ( ans + int ( s ) ) NEW_LINE","import itertools NEW_LINE S = input ( ) NEW_LINE total = 0 NEW_LINE prev = 0 NEW_LINE for p in itertools . product ( [ False , True ] , repeat = len ( S ) - 1 ) : NEW_LINE INDENT prev = 0 NEW_LINE for i in range ( len ( p ) ) : NEW_LINE INDENT if p [ i ] : NEW_LINE INDENT total += int ( S [ prev : i + 1 ] ) NEW_LINE prev = i + 1 NEW_LINE DEDENT DEDENT total += int ( S [ prev : ] ) NEW_LINE DEDENT if total == 0 : NEW_LINE INDENT total = int ( S ) NEW_LINE DEDENT print ( total ) NEW_LINE","s = list ( input ( ) ) NEW_LINE n = len ( s ) NEW_LINE can = [ ] NEW_LINE def dfs ( i , left , sum ) : NEW_LINE INDENT if i + 1 == n : NEW_LINE INDENT sum += int ( \" \" . join ( s [ left : ] ) ) NEW_LINE can . append ( sum ) NEW_LINE return NEW_LINE DEDENT dfs ( i + 1 , left , sum ) NEW_LINE dfs ( i + 1 , i + 1 , sum + int ( \" \" . join ( s [ left : i + 1 ] ) ) ) NEW_LINE return NEW_LINE DEDENT dfs ( 0 , 0 , 0 ) NEW_LINE print ( sum ( can ) ) NEW_LINE"],"bleu":0.004624424076161543,"rouge_l":0.10278973974911065}
{"id":11,"predictions":["import math NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT if a % b == 0 : NEW_LINE INDENT return a \/\/ b NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT def lcm ( a , b ) : NEW_LINE INDENT if a == 0 : return a NEW_LINE return gcd ( a , b ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT input = sys . stdin . readline NEW_LINE DEDENT a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE n = int ( input ( ) ) NEW_LINE t = [ [ ] for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT t . append ( a [ i ] ) NEW_LINE DEDENT g = gcd ( a , b ) NEW_LINE t . append ( t [ a ] ) NEW_LINE return n NEW_LINE DEDENT main ( ) NEW_LINE"],"references":["N , M = ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE S = input ( ) NEW_LINE T = input ( ) NEW_LINE def gcd ( x , y ) : NEW_LINE INDENT x , y = min ( x , y ) , max ( x , y ) NEW_LINE if y % x == 0 : NEW_LINE INDENT return x NEW_LINE DEDENT return gcd ( x , y % x ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT if S [ 0 ] != T [ 0 ] : NEW_LINE INDENT return - 1 NEW_LINE DEDENT g = gcd ( N , M ) NEW_LINE n = N \/\/ g NEW_LINE m = M \/\/ g NEW_LINE for i in range ( g ) : NEW_LINE INDENT if S [ n * i ] != T [ m * i ] : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT return N * M \/\/ g NEW_LINE DEDENT print ( main ( ) ) NEW_LINE","def main28 ( ) : NEW_LINE INDENT import sys NEW_LINE N , M = ( int ( x ) for x in input ( ) . split ( ) ) NEW_LINE if N >= M : NEW_LINE INDENT S = input ( ) NEW_LINE T = input ( ) NEW_LINE DEDENT else : NEW_LINE INDENT T = input ( ) NEW_LINE S = input ( ) NEW_LINE DEDENT def lcm ( n , m ) : NEW_LINE INDENT gcd = 0 NEW_LINE for i in range ( 1 , min ( n , m ) + 1 ) : NEW_LINE INDENT if n % i == 0 and m % i == 0 : NEW_LINE INDENT gcd = i NEW_LINE DEDENT DEDENT return int ( n * m \/ gcd ) NEW_LINE DEDENT LCM = lcm ( N , M ) NEW_LINE a = int ( LCM \/ max ( N , M ) ) NEW_LINE b = int ( LCM \/ min ( N , M ) ) NEW_LINE for i in range ( min ( N , M ) ) : NEW_LINE INDENT small_index = i * b NEW_LINE if int ( small_index % a ) == 0 : NEW_LINE INDENT if S [ int ( small_index \/ a ) ] != T [ i ] : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE sys . exit ( ) NEW_LINE DEDENT DEDENT DEDENT print ( LCM ) NEW_LINE DEDENT main28 ( ) NEW_LINE","def gcm ( a , b ) : NEW_LINE INDENT while ( b ) : NEW_LINE INDENT a , b = b , a % b NEW_LINE DEDENT return a NEW_LINE DEDENT def lcm ( a , b ) : NEW_LINE INDENT return int ( a * b \/ gcm ( a , b ) ) NEW_LINE DEDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE s = list ( str ( input ( ) ) ) NEW_LINE t = list ( str ( input ( ) ) ) NEW_LINE s_out = [ ] NEW_LINE t_out = [ ] NEW_LINE for i in range ( int ( gcm ( n , m ) ) ) : NEW_LINE INDENT s_out . append ( s [ i * int ( n \/ gcm ( n , m ) ) ] ) NEW_LINE DEDENT for i in range ( int ( gcm ( n , m ) ) ) : NEW_LINE INDENT t_out . append ( t [ i * int ( m \/ gcm ( n , m ) ) ] ) NEW_LINE DEDENT if ( s_out == t_out ) : print ( lcm ( n , m ) ) NEW_LINE else : print ( - 1 ) NEW_LINE","N , M = map ( int , input ( ) . split ( ) ) NEW_LINE S = input ( ) NEW_LINE T = input ( ) NEW_LINE from fractions import gcd NEW_LINE LEN = N * M \/\/ gcd ( N , M ) NEW_LINE p = LEN \/\/ N NEW_LINE q = LEN \/\/ M NEW_LINE lcm = p * q \/\/ gcd ( p , q ) NEW_LINE for i in range ( 0 , LEN \/\/ lcm ) : NEW_LINE INDENT if S [ i * q ] != T [ i * p ] : NEW_LINE INDENT print ( - 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT print ( LEN ) NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE t = input ( ) NEW_LINE def gcd ( x , y ) : NEW_LINE INDENT if y == 0 : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( y , x % y ) NEW_LINE DEDENT DEDENT def lcm ( x , y ) : NEW_LINE INDENT return x * y \/\/ gcd ( x , y ) NEW_LINE DEDENT l = lcm ( n , m ) NEW_LINE a = l \/\/ n NEW_LINE b = l \/\/ m NEW_LINE ln = [ ] NEW_LINE lm = [ ] NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT ln . append ( i ) NEW_LINE i += b NEW_LINE DEDENT i = 0 NEW_LINE while i < m : NEW_LINE INDENT lm . append ( i ) NEW_LINE i += a NEW_LINE DEDENT p = 0 NEW_LINE for i in range ( len ( ln ) ) : NEW_LINE INDENT if s [ ln [ i ] ] != t [ lm [ i ] ] : NEW_LINE INDENT p = 1 NEW_LINE DEDENT DEDENT if p == 0 : NEW_LINE INDENT print ( l ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT"],"bleu":0.6267115720605564,"rouge_l":0.5314911625591238}
{"id":12,"predictions":["n = int ( input ( ) ) NEW_LINE S = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT S ^= set ( [ input ( ) ] ) NEW_LINE DEDENT print ( len ( S ) ) NEW_LINE"],"references":["print ( len ( set ( map ( int , input ( ) . split ( ) ) ) ) ) NEW_LINE","a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if a [ 0 ] != a [ 1 ] and a [ 0 ] != a [ 2 ] and a [ 1 ] != a [ 2 ] : NEW_LINE INDENT print ( 3 ) NEW_LINE DEDENT elif a [ 0 ] == a [ 1 ] and a [ 0 ] != a [ 2 ] : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT elif a [ 0 ] != a [ 1 ] and a [ 0 ] == a [ 2 ] : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT elif a [ 0 ] != a [ 1 ] and a [ 1 ] == a [ 2 ] : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT elif a [ 0 ] == a [ 1 ] == a [ 2 ] : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT","def atcodeer_and_paint_cans ( a : int , b : int , c : int ) -> int : NEW_LINE INDENT return len ( set ( [ a , b , c ] ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE ans = atcodeer_and_paint_cans ( a , b , c ) NEW_LINE print ( ans ) NEW_LINE DEDENT","s = input ( ) . split ( ) NEW_LINE myset = set ( [ ] ) NEW_LINE myset . add ( s [ 0 ] ) NEW_LINE myset . add ( s [ 1 ] ) NEW_LINE myset . add ( s [ 2 ] ) NEW_LINE m = len ( myset ) NEW_LINE print ( m ) NEW_LINE","a , b , c = map ( int , open ( 0 ) . read ( ) . split ( ) ) NEW_LINE if a == b and b == c : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT elif a == b or b == c or a == c : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 3 ) NEW_LINE DEDENT"],"bleu":0.2868603411407729,"rouge_l":0.5495495495495495}
{"id":13,"predictions":["a = input ( ) NEW_LINE b = ' , ' , ' NEW_LINE c = 0 NEW_LINE n = len ( a ) NEW_LINE d = 0 NEW_LINE e = 0 NEW_LINE for i in range ( n ) : NEW_LINE if a [ i ] == ' , ' : NEW_LINE INDENT if b [ i ] == ' , ' : NEW_LINE INDENT a [ i ] = ' , ' , ' , ' , 1 NEW_LINE DEDENT elif a [ i ] == ' , ' : NEW_LINE INDENT a [ i ] = ' , ' NEW_LINE DEDENT else : NEW_LINE INDENT if a [ i ] == ' : NEW_LINE INDENT b [ i ] = ' , ' , NEW_LINE DEDENT else : NEW_LINE INDENT b [ i ] = a [ i ] NEW_LINE DEDENT DEDENT DEDENT e = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if a [ i ] == ' , ' : NEW_LINE INDENT a [ i ] = ' , ' NEW_LINE DEDENT DEDENT e += 1 NEW_LINE DEDENT print ( b ) NEW_LINE"],"references":["a , b , c = input ( ) . split ( ' , ' ) NEW_LINE print ( a , b , c ) NEW_LINE","s = str ( input ( ) ) NEW_LINE s1 = s [ : 5 ] NEW_LINE s2 = s [ 6 : 13 ] NEW_LINE s3 = s [ 14 : ] NEW_LINE print ( ' { } ▁ { } ▁ { } ' . format ( s1 , s2 , s3 ) ) NEW_LINE","print ( input ( ) . replace ( \" , \" , \" ▁ \" ) ) NEW_LINE","a = input ( ) NEW_LINE print ( a [ : 5 ] + ' ▁ ' + a [ 6 : 13 ] + ' ▁ ' + a [ 14 : ] ) NEW_LINE","s = input ( ) NEW_LINE s = list ( s ) NEW_LINE s [ 5 ] = \" ▁ \" NEW_LINE s [ 13 ] = \" ▁ \" NEW_LINE print ( \" \" . join ( s ) ) NEW_LINE"],"bleu":0.06153637493730265,"rouge_l":0.2548675524358653}
{"id":14,"predictions":["a , b = map ( int , input ( ) . split ( ) ) c = 0 while a <= b : if a + 1 <= b : c += 1 print ( c ) NEW_LINE"],"references":["x , y = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 1 NEW_LINE a = x NEW_LINE for _ in range ( 61 ) : NEW_LINE INDENT a *= 2 NEW_LINE if a <= y : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE","a , b = map ( int , input ( ) . split ( \" ▁ \" ) ) NEW_LINE count = 0 NEW_LINE while a <= b : NEW_LINE INDENT count += 1 NEW_LINE a *= 2 NEW_LINE DEDENT print ( count ) NEW_LINE","def create_Row ( S , E ) : NEW_LINE INDENT list = [ ] NEW_LINE start = S NEW_LINE while start <= E : NEW_LINE INDENT list . append ( start ) NEW_LINE start += start NEW_LINE DEDENT return list NEW_LINE DEDENT X , Y = map ( int , input ( ) . split ( ) ) NEW_LINE A = len ( create_Row ( X , Y ) ) NEW_LINE print ( A ) NEW_LINE","x , y = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE cnt = 0 NEW_LINE for i in range ( 70 ) : NEW_LINE INDENT if x * ( 2 ** i ) <= y : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT print ( cnt ) NEW_LINE","from sys import stdin NEW_LINE x , y = [ int ( _ ) for _ in stdin . readline ( ) . rstrip ( ) . split ( ) ] NEW_LINE count = 1 NEW_LINE while True : NEW_LINE INDENT x = x * 2 NEW_LINE if x <= y : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE"],"bleu":0.4955766526518346,"rouge_l":0.6816955684007708}
{"id":15,"predictions":["import sys NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE INF = 10 ** 18 NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def II ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def SI ( ) : return input ( ) NEW_LINE def main ( ) : NEW_LINE INDENT n , k = LI ( ) NEW_LINE G = defaultdict ( int ) NEW_LINE for _ in range ( n - 1 ) : NEW_LINE INDENT a , b = LI ( ) NEW_LINE G [ a ] . append ( b ) NEW_LINE G [ b ] . append ( a ) NEW_LINE DEDENT d = [ 0 ] * ( n + 1 ) NEW_LINE d [ a ] = 1 NEW_LINE for _ in range ( n + 1 ) : NEW_LINE INDENT x = II ( ) NEW_LINE y = sorted ( d [ x ] , reverse = True ) NEW_LINE d [ x ] = 0 NEW_LINE for x in G [ y ] : NEW_LINE INDENT if x != p : NEW_LINE INDENT d [ x ] += 1 NEW_LINE DEDENT DEDENT DEDENT main ( ) NEW_LINE DEDENT main ( ) NEW_LINE"],"references":["from sys import exit , setrecursionlimit NEW_LINE from itertools import product NEW_LINE def read ( ) : NEW_LINE INDENT return int ( input ( ) ) NEW_LINE DEDENT def reads ( ) : NEW_LINE INDENT return [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE DEDENT def argmin ( ll ) : NEW_LINE INDENT ll = list ( ll ) NEW_LINE return ll . index ( min ( ll ) ) NEW_LINE DEDENT setrecursionlimit ( 1000000 ) NEW_LINE ( N , K ) = reads ( ) NEW_LINE parent = [ x - 1 for x in reads ( ) ] NEW_LINE result = 0 NEW_LINE if parent [ 0 ] != 0 : NEW_LINE INDENT parent [ 0 ] = 0 NEW_LINE result += 1 NEW_LINE DEDENT children = [ [ ] for _ in range ( N ) ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT children [ parent [ i ] ] . append ( i ) NEW_LINE DEDENT color = [ 0 ] * N NEW_LINE def walk ( i ) : NEW_LINE INDENT global result NEW_LINE for x in children [ i ] : NEW_LINE INDENT walk ( x ) NEW_LINE if color [ x ] == 1 and parent [ x ] != 0 : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT color [ i ] = min ( [ K ] + [ color [ x ] - 1 for x in children [ i ] if color [ x ] >= 2 ] ) NEW_LINE DEDENT walk ( 0 ) NEW_LINE print ( result ) NEW_LINE","import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE inf = 10 ** 20 NEW_LINE eps = 1.0 \/ 10 ** 15 NEW_LINE mod = 10 ** 9 + 7 NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def F ( ) : return float ( sys . stdin . readline ( ) ) NEW_LINE def S ( ) : return input ( ) NEW_LINE def pf ( s ) : return print ( s , flush = True ) NEW_LINE def main ( ) : NEW_LINE INDENT n , k = LI ( ) NEW_LINE a = LI_ ( ) NEW_LINE r = 0 NEW_LINE if a [ 0 ] != 0 : NEW_LINE INDENT r += 1 NEW_LINE DEDENT e = collections . defaultdict ( set ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT e [ a [ i ] ] . add ( i ) NEW_LINE DEDENT def f ( i , p ) : NEW_LINE INDENT m = 0 NEW_LINE r = 0 NEW_LINE for c in e [ i ] : NEW_LINE INDENT ct , cr = f ( c , i ) NEW_LINE r += cr NEW_LINE if ct > m : NEW_LINE INDENT m = ct NEW_LINE DEDENT DEDENT if ( m == k - 1 and p != 0 ) or ( m == k and p == 0 ) : NEW_LINE INDENT r += 1 NEW_LINE m = - 1 NEW_LINE DEDENT return ( m + 1 , r ) NEW_LINE DEDENT for c in e [ 0 ] : NEW_LINE INDENT m , t = f ( c , 0 ) NEW_LINE r += t NEW_LINE DEDENT return r NEW_LINE DEDENT print ( main ( ) ) NEW_LINE","import sys NEW_LINE sys . setrecursionlimit ( 200000 ) NEW_LINE n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE if a [ 0 ] != 1 : NEW_LINE INDENT a [ 0 ] = 1 NEW_LINE ans += 1 NEW_LINE DEDENT b = [ [ ] for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT b [ a [ i ] - 1 ] . append ( i ) NEW_LINE DEDENT b [ 0 ] . remove ( 0 ) NEW_LINE huka = 0 NEW_LINE kyo = [ float ( \" inf \" ) ] * n NEW_LINE def dfs ( x , y ) : NEW_LINE INDENT kyo [ x ] = y NEW_LINE for i in b [ x ] : NEW_LINE INDENT dfs ( i , y + 1 ) NEW_LINE DEDENT DEDENT dfs ( 0 , 0 ) NEW_LINE def dfs2 ( x , y ) : NEW_LINE INDENT if kyo [ x ] <= k - y : NEW_LINE INDENT return NEW_LINE DEDENT if y == k - 1 and x != 0 : NEW_LINE INDENT kyo [ x ] = 0 NEW_LINE global ans NEW_LINE ans += 1 NEW_LINE return NEW_LINE DEDENT kyo [ x ] = 0 NEW_LINE dfs2 ( a [ x ] - 1 , y + 1 ) NEW_LINE DEDENT hukai = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT hukai . append ( [ kyo [ i ] , i ] ) NEW_LINE DEDENT hukai . sort ( key = lambda x : - x [ 0 ] ) NEW_LINE for j , i in hukai : NEW_LINE INDENT if j <= k : NEW_LINE INDENT continue NEW_LINE DEDENT dfs2 ( i , 0 ) NEW_LINE DEDENT print ( ans ) NEW_LINE","import sys NEW_LINE sys . setrecursionlimit ( 200000 ) NEW_LINE n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE if a [ 0 ] != 1 : NEW_LINE INDENT a [ 0 ] = 1 NEW_LINE ans += 1 NEW_LINE DEDENT b = [ [ ] for i in range ( n ) ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT b [ a [ i ] - 1 ] . append ( i ) NEW_LINE DEDENT huka = 0 NEW_LINE kyo = [ float ( \" inf \" ) ] * n NEW_LINE z = [ [ ] for i in range ( n ) ] NEW_LINE def dfs ( x , y ) : NEW_LINE INDENT kyo [ x ] = y NEW_LINE z [ y ] . append ( x ) NEW_LINE for i in b [ x ] : NEW_LINE INDENT dfs ( i , y + 1 ) NEW_LINE DEDENT DEDENT dfs ( 0 , 0 ) NEW_LINE def dfs2 ( x , y ) : NEW_LINE INDENT if kyo [ x ] <= k - y : NEW_LINE INDENT return NEW_LINE DEDENT if y == k - 1 and x != 0 : NEW_LINE INDENT kyo [ x ] = 0 NEW_LINE global ans NEW_LINE ans += 1 NEW_LINE return NEW_LINE DEDENT kyo [ x ] = 0 NEW_LINE dfs2 ( a [ x ] - 1 , y + 1 ) NEW_LINE DEDENT for i in range ( n - 1 , k , - 1 ) : NEW_LINE INDENT for j in z [ i ] : NEW_LINE INDENT dfs2 ( j , 0 ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE","import sys NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE INF = 10 ** 18 NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def II ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def SI ( ) : return input ( ) NEW_LINE from collections import defaultdict NEW_LINE def main ( ) : NEW_LINE INDENT N , K = LI ( ) NEW_LINE A = LI_ ( ) NEW_LINE edges = defaultdict ( list ) NEW_LINE for i , a in enumerate ( A [ 1 : ] , 1 ) : NEW_LINE INDENT edges [ a ] . append ( i ) NEW_LINE DEDENT global ans NEW_LINE ans = 0 NEW_LINE if A [ 0 ] != 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT def DFS ( v , parent ) : NEW_LINE INDENT global ans NEW_LINE height = 0 NEW_LINE for to in edges [ v ] : NEW_LINE INDENT height = max ( height , DFS ( to , v ) ) NEW_LINE DEDENT if parent != 0 and height >= K - 1 : NEW_LINE INDENT height = - 1 NEW_LINE ans += 1 NEW_LINE DEDENT return height + 1 NEW_LINE DEDENT DFS ( 0 , 0 ) NEW_LINE return ans NEW_LINE DEDENT print ( main ( ) ) NEW_LINE"],"bleu":0.7726899186383878,"rouge_l":0.7177572005934415}
{"id":16,"predictions":["import itertools NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ [ int ( x ) for x in input ( ) . split ( ) ] for _ in range ( n ) ] NEW_LINE b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE b . append ( a ) NEW_LINE DEDENT dp = [ [ 0 for _ in range ( n + 1 ) ] for ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if j == 0 : NEW_LINE INDENT dp [ i + 1 ] [ j ] = dp [ i ] [ j ] + dp [ i ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i + 1 ] [ j ] NEW_LINE dp [ i ] [ j + 1 ] = dp [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT for i in ans : NEW_LINE INDENT print ( dp [ - 1 ] [ ans ] ) NEW_LINE DEDENT"],"references":["from itertools import accumulate NEW_LINE N , M , Q = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ [ 0 ] * ( N + 1 ) for i in range ( N + 1 ) ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT L , R = map ( int , input ( ) . split ( ) ) NEW_LINE a [ L ] [ R ] += 1 NEW_LINE DEDENT b = [ list ( accumulate ( a [ i ] ) ) for i in range ( N + 1 ) ] NEW_LINE k = [ [ b [ j ] [ i ] for j in range ( i + 1 ) ] for i in range ( N + 1 ) ] NEW_LINE ans = [ list ( accumulate ( reversed ( k [ i ] ) ) ) [ : : - 1 ] for i in range ( N + 1 ) ] NEW_LINE for i in range ( Q ) : NEW_LINE INDENT p , q = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ans [ q ] [ p - q - 1 ] ) NEW_LINE DEDENT","from collections import Counter NEW_LINE from functools import lru_cache NEW_LINE import sys NEW_LINE sys . setrecursionlimit ( 2 * 10 ** 5 ) NEW_LINE N , M , Q = map ( int , input ( ) . split ( ) ) NEW_LINE L , R = zip ( * ( map ( int , input ( ) . split ( ) ) for _ in range ( M ) ) ) NEW_LINE p , q = zip ( * ( map ( int , input ( ) . split ( ) ) for _ in range ( Q ) ) ) NEW_LINE c = Counter ( zip ( L , R ) ) NEW_LINE @ lru_cache ( maxsize = None ) NEW_LINE def f ( x , y ) : NEW_LINE INDENT return ( 0 if x > y else c [ x , y ] + f ( x + 1 , y ) + f ( x , y - 1 ) - f ( x + 1 , y - 1 ) ) NEW_LINE DEDENT ans = ' \\n ' . join ( map ( str , ( f ( x , y ) for x , y in zip ( p , q ) ) ) ) NEW_LINE print ( ans ) NEW_LINE","n , m , q = [ int ( item ) for item in input ( ) . split ( ) ] NEW_LINE lr = [ [ int ( item ) for item in input ( ) . split ( ) ] for _ in range ( m ) ] NEW_LINE pq = [ [ int ( item ) for item in input ( ) . split ( ) ] for _ in range ( q ) ] NEW_LINE field = [ [ 0 ] * ( n + 1 ) for _ in range ( n + 1 ) ] NEW_LINE cumsum = [ [ 0 ] * ( n + 1 ) for _ in range ( n + 1 ) ] NEW_LINE for item in lr : NEW_LINE INDENT field [ item [ 0 ] ] [ item [ 1 ] ] += 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT cumsum [ i ] [ j ] = field [ i ] [ j ] + cumsum [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT cumsum [ i ] [ j ] += cumsum [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT for p , q in pq : NEW_LINE INDENT print ( cumsum [ q ] [ q ] - cumsum [ p - 1 ] [ q ] - cumsum [ q ] [ p - 1 ] + cumsum [ p - 1 ] [ p - 1 ] ) NEW_LINE DEDENT","import sys NEW_LINE import itertools NEW_LINE import collections NEW_LINE import functools NEW_LINE import math NEW_LINE from queue import Queue NEW_LINE INF = float ( \" inf \" ) NEW_LINE def solve ( N : int , M : int , Q : int , L : \" List [ int ] \" , R : \" List [ int ] \" , p : \" List [ int ] \" , q : \" List [ int ] \" ) : NEW_LINE INDENT a = [ [ 0 ] * ( N + 1 ) for _ in range ( N + 1 ) ] NEW_LINE for l , r in zip ( L , R ) : NEW_LINE INDENT a [ l ] [ r ] += 1 NEW_LINE DEDENT a = [ list ( itertools . accumulate ( x ) ) for x in a ] NEW_LINE a = [ list ( itertools . accumulate ( s [ : : - 1 ] ) ) [ : : - 1 ] for s in zip ( * a ) ] NEW_LINE for pp , qq in zip ( p , q ) : NEW_LINE INDENT print ( a [ qq ] [ pp ] ) NEW_LINE DEDENT return NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT def iterate_tokens ( ) : NEW_LINE INDENT for line in sys . stdin : NEW_LINE INDENT for word in line . split ( ) : NEW_LINE INDENT yield word NEW_LINE DEDENT DEDENT DEDENT tokens = iterate_tokens ( ) NEW_LINE N = int ( next ( tokens ) ) NEW_LINE M = int ( next ( tokens ) ) NEW_LINE Q = int ( next ( tokens ) ) NEW_LINE L = [ int ( ) ] * ( M ) NEW_LINE R = [ int ( ) ] * ( M ) NEW_LINE for i in range ( M ) : NEW_LINE INDENT L [ i ] = int ( next ( tokens ) ) NEW_LINE R [ i ] = int ( next ( tokens ) ) NEW_LINE DEDENT p = [ int ( ) ] * ( Q ) NEW_LINE q = [ int ( ) ] * ( Q ) NEW_LINE for i in range ( Q ) : NEW_LINE INDENT p [ i ] = int ( next ( tokens ) ) NEW_LINE q [ i ] = int ( next ( tokens ) ) NEW_LINE DEDENT solve ( N , M , Q , L , R , p , q ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT","n , m , q = map ( int , input ( ) . split ( ) ) NEW_LINE dist = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] NEW_LINE query = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( q ) ] NEW_LINE coord = [ [ 0 ] * ( n + 1 ) for i in range ( n + 1 ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT coord [ dist [ i ] [ 0 ] ] [ dist [ i ] [ 1 ] ] += 1 NEW_LINE DEDENT ruiseki = [ [ 0 ] * ( n + 1 ) for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT ruiseki [ i ] [ j ] = coord [ i ] [ j ] + ruiseki [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT ruiseki [ i ] [ j ] = ruiseki [ i ] [ j ] + ruiseki [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT for i , j in query : NEW_LINE INDENT ans = ruiseki [ j ] [ j ] - ruiseki [ i - 1 ] [ j ] - ruiseki [ j ] [ i - 1 ] + ruiseki [ i - 1 ] [ i - 1 ] NEW_LINE print ( ans ) NEW_LINE DEDENT"],"bleu":0.6743527650089327,"rouge_l":0.5765955342961849}
{"id":17,"predictions":["n , m = map ( int , input ( ) . split ( ) ) NEW_LINE t = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE t . append ( a ) NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT t . append ( map ( int , input ( ) . split ( ) ) ) NEW_LINE DEDENT print ( sum ( t ) ) NEW_LINE"],"references":["N , M , X = ( int ( x ) for x in input ( ) . split ( ) ) NEW_LINE A = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE Z = [ 0 ] * N NEW_LINE for a in A : NEW_LINE INDENT Z [ a ] = 1 NEW_LINE DEDENT lower = 0 NEW_LINE for i in range ( 0 , X + 1 ) : NEW_LINE INDENT lower += Z [ i ] NEW_LINE DEDENT higher = 0 NEW_LINE for i in range ( X , N ) : NEW_LINE INDENT higher += Z [ i ] NEW_LINE DEDENT print ( min ( lower , higher ) ) NEW_LINE","N , M , X = map ( int , input ( ) . split ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE cnt = 0 NEW_LINE min = 0 NEW_LINE cnt_2 = 0 NEW_LINE lists = list ( range ( N + 1 ) ) NEW_LINE for i in range ( X , N + 1 ) : NEW_LINE INDENT for j in range ( len ( A ) ) : NEW_LINE INDENT if i == 0 or i == N or i == X : NEW_LINE INDENT continue NEW_LINE DEDENT elif i == A [ j ] : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT for m in range ( X , - 1 , - 1 ) : NEW_LINE INDENT for n in range ( len ( A ) ) : NEW_LINE INDENT if m == 0 or m == N or m == X : NEW_LINE INDENT continue NEW_LINE DEDENT elif m == A [ n ] : NEW_LINE INDENT cnt_2 += 1 NEW_LINE DEDENT DEDENT DEDENT if cnt > cnt_2 : NEW_LINE INDENT min = cnt_2 NEW_LINE DEDENT elif cnt_2 > cnt : NEW_LINE INDENT min = cnt NEW_LINE DEDENT print ( min ) NEW_LINE","N , M , X = map ( int , input ( ) . strip ( ) . split ( ) ) NEW_LINE As = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) NEW_LINE left = list ( filter ( lambda x : x < X , As ) ) NEW_LINE right = list ( filter ( lambda x : x > X , As ) ) NEW_LINE print ( min ( len ( left ) , len ( right ) ) ) NEW_LINE","n , m , x = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE import bisect NEW_LINE l = bisect . bisect_left ( a , x ) NEW_LINE print ( min ( l , m - l ) ) NEW_LINE","import bisect NEW_LINE n , m , x = map ( int , input ( ) . split ( ) ) NEW_LINE A = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE i = bisect . bisect_left ( A , x ) NEW_LINE j = bisect . bisect_right ( A , x ) NEW_LINE print ( min ( i , m - j ) ) NEW_LINE"],"bleu":0.583440859354969,"rouge_l":0.6783658017193785}
{"id":18,"predictions":["import sys NEW_LINE stdin = sys . stdin NEW_LINE sys . setrecursionlimit ( 10 ** 5 ) NEW_LINE def li ( ) : return map ( int , stdin . readline ( ) . split ( ) ) NEW_LINE def li_ ( ) : return map ( lambda x : int ( x ) - 1 , stdin . readline ( ) . split ( ) ) NEW_LINE def lf ( ) : return map ( float , stdin . readline ( ) . split ( ) ) NEW_LINE def ls ( ) : return stdin . readline ( ) . split ( ) NEW_LINE def ns ( ) : return stdin . readline ( ) . rstrip ( ) NEW_LINE def lc ( ) : return list ( ns ( ) ) NEW_LINE def ni ( ) : return int ( stdin . readline ( ) ) NEW_LINE def nf ( ) : return float ( stdin . readline ( ) ) NEW_LINE from collections import deque NEW_LINE n = ni ( ) NEW_LINE G = defaultdict ( ) NEW_LINE for _ in range ( n - 1 ) : NEW_LINE INDENT ai , bi = li ( ) NEW_LINE G [ ai ] . append ( bi ) NEW_LINE DEDENT def dfs ( ) : NEW_LINE INDENT for p in G [ p ] : NEW_LINE INDENT dfs ( p , p ) NEW_LINE DEDENT return max ( dfs ( p ) ) NEW_LINE DEDENT print ( dfs ( 0 ) ) NEW_LINE"],"references":["import sys NEW_LINE from collections import deque NEW_LINE def dfs ( edges , start ) : NEW_LINE INDENT visited = [ 0 ] * len ( edges ) NEW_LINE visited [ start ] = 1 NEW_LINE ans , dist = 0 , 0 NEW_LINE stack = deque ( [ ( start , 0 ) ] ) NEW_LINE pop , append = stack . pop , stack . append NEW_LINE while stack : NEW_LINE INDENT v , _dist = pop ( ) NEW_LINE if _dist > dist : NEW_LINE INDENT ans , dist = v , _dist NEW_LINE DEDENT for e in edges [ v ] : NEW_LINE INDENT if visited [ e ] : NEW_LINE INDENT continue NEW_LINE DEDENT visited [ e ] = 1 NEW_LINE append ( ( e , _dist + 1 ) ) NEW_LINE DEDENT DEDENT return ans , dist NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE edges = [ [ ] for _ in [ 0 ] * N ] NEW_LINE for ( a , b ) in ( map ( int , l . split ( ) ) for l in sys . stdin ) : NEW_LINE INDENT edges [ a - 1 ] . append ( b - 1 ) NEW_LINE edges [ b - 1 ] . append ( a - 1 ) NEW_LINE DEDENT v , _ = dfs ( edges , 0 ) NEW_LINE print ( v + 1 , dfs ( edges , v ) [ 0 ] + 1 ) NEW_LINE DEDENT","from collections import defaultdict NEW_LINE import sys NEW_LINE sys . setrecursionlimit ( 10 ** 6 ) NEW_LINE def dfs ( i , g , dist ) : NEW_LINE INDENT for node in g [ i ] : NEW_LINE INDENT if dist [ node ] is None : NEW_LINE INDENT dist [ node ] = dist [ i ] + 1 NEW_LINE dfs ( node , g , dist ) NEW_LINE DEDENT DEDENT DEDENT def main ( ) : NEW_LINE INDENT g = defaultdict ( list ) NEW_LINE N = int ( input ( ) ) NEW_LINE for _ in range ( N - 1 ) : NEW_LINE INDENT A , B = map ( int , input ( ) . split ( ) ) NEW_LINE g [ A ] . append ( B ) NEW_LINE g [ B ] . append ( A ) NEW_LINE DEDENT dist = [ None ] * ( N + 1 ) NEW_LINE dist [ 0 ] = - 1 NEW_LINE dist [ 1 ] = 0 NEW_LINE dfs ( 1 , g , dist ) NEW_LINE ans1 = dist . index ( max ( dist ) ) NEW_LINE dist = [ None ] * ( N + 1 ) NEW_LINE dist [ 0 ] = - 1 NEW_LINE dist [ ans1 ] = 0 NEW_LINE dfs ( ans1 , g , dist ) NEW_LINE ans2 = dist . index ( max ( dist ) ) NEW_LINE print ( ans1 , ans2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT","from heapq import heappush , heappop NEW_LINE def dijkstra ( num , start ) : NEW_LINE INDENT dist = [ float ( \" inf \" ) for i in range ( num ) ] NEW_LINE dist [ start ] = 0 NEW_LINE q = [ [ dist [ start ] , start ] ] NEW_LINE while q : NEW_LINE INDENT du , u = heappop ( q ) NEW_LINE for j , k in adj [ u ] : NEW_LINE INDENT if dist [ j ] > du + k : NEW_LINE INDENT dist [ j ] = du + k NEW_LINE heappush ( q , [ dist [ j ] , j ] ) NEW_LINE DEDENT DEDENT DEDENT return dist NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE adj = [ [ ] for i in range ( n ) ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE a -= 1 NEW_LINE b -= 1 NEW_LINE adj [ a ] . append ( [ b , 1 ] ) NEW_LINE adj [ b ] . append ( [ a , 1 ] ) NEW_LINE DEDENT di = dijkstra ( n , 0 ) NEW_LINE ma = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if di [ i ] > di [ ma ] : NEW_LINE INDENT ma = i NEW_LINE DEDENT DEDENT dis = dijkstra ( n , ma ) NEW_LINE mi = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if dis [ i ] > dis [ mi ] : NEW_LINE INDENT mi = i NEW_LINE DEDENT DEDENT print ( ma + 1 , mi + 1 ) NEW_LINE","import sys NEW_LINE from collections import defaultdict , deque NEW_LINE input = sys . stdin . readline NEW_LINE INF = float ( ' inf ' ) NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE def inpl ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE N = int ( input ( ) ) NEW_LINE G = defaultdict ( list ) NEW_LINE for _ in range ( N - 1 ) : NEW_LINE INDENT a , b = inpl ( ) NEW_LINE G [ a - 1 ] . append ( b - 1 ) NEW_LINE G [ b - 1 ] . append ( a - 1 ) NEW_LINE DEDENT def DFS ( start ) : NEW_LINE INDENT stack = deque ( [ start ] ) NEW_LINE dist = [ INF ] * N NEW_LINE dist [ start ] = 0 NEW_LINE max_dist = 0 NEW_LINE farthest_v = start NEW_LINE while stack : NEW_LINE INDENT curr = stack . pop ( ) NEW_LINE for next in G [ curr ] : NEW_LINE INDENT if dist [ next ] != INF : NEW_LINE INDENT continue NEW_LINE DEDENT dist [ next ] = dist [ curr ] + 1 NEW_LINE stack . append ( next ) NEW_LINE if dist [ next ] > max_dist : NEW_LINE INDENT max_dist = dist [ next ] NEW_LINE farthest_v = next NEW_LINE DEDENT DEDENT DEDENT return farthest_v NEW_LINE DEDENT v = DFS ( 0 ) NEW_LINE u = DFS ( v ) NEW_LINE print ( v + 1 , u + 1 ) NEW_LINE","adj_list = None NEW_LINE def solve ( n ) : NEW_LINE INDENT r = 0 NEW_LINE for i in range ( 2 ) : NEW_LINE INDENT visited = [ False ] * n NEW_LINE dr = 0 NEW_LINE st = [ ] NEW_LINE v = r NEW_LINE visited [ v ] = True NEW_LINE st . append ( ( v , 0 ) ) NEW_LINE while len ( st ) : NEW_LINE INDENT v , d = st . pop ( ) NEW_LINE if dr < d : NEW_LINE INDENT r , dr = v , d NEW_LINE DEDENT for w in adj_list [ v ] : NEW_LINE INDENT if not visited [ w ] : NEW_LINE INDENT visited [ w ] = True NEW_LINE st . append ( ( w , d + 1 ) ) NEW_LINE DEDENT DEDENT DEDENT if i == 0 : NEW_LINE INDENT x = r NEW_LINE DEDENT else : NEW_LINE INDENT y = r NEW_LINE DEDENT DEDENT return \" { } ▁ { } \" . format ( x + 1 , y + 1 ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT global adj_list NEW_LINE n = input ( ) NEW_LINE n = int ( n ) NEW_LINE adj_list = [ [ ] for _ in range ( n ) ] NEW_LINE for _ in range ( n - 1 ) : NEW_LINE INDENT a , b = input ( ) . split ( ) NEW_LINE a = int ( a ) - 1 NEW_LINE b = int ( b ) - 1 NEW_LINE adj_list [ a ] . append ( b ) NEW_LINE adj_list [ b ] . append ( a ) NEW_LINE DEDENT print ( solve ( n ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"bleu":0.32543524486118697,"rouge_l":0.36762969866418144}
{"id":19,"predictions":["from fractions import Fractiona , b , c , d = map ( int , input ( ) . split ( ) ) if ( a \/ b == c \/ d ) : print ( \" YES \" ) elif ( a \/ b < c \/ d ) : print ( \"1\" ) else : print ( \" NO \" ) NEW_LINE"],"references":["T = int ( input ( ) ) NEW_LINE ABCD = [ [ int ( _ ) for _ in input ( ) . split ( ) ] for _ in range ( T ) ] NEW_LINE def gcd ( x , y ) : NEW_LINE INDENT if x < y : NEW_LINE INDENT return gcd ( y , x ) NEW_LINE DEDENT elif x % y == 0 : NEW_LINE INDENT return y NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( y , x % y ) NEW_LINE DEDENT DEDENT for a , b , c , d in ABCD : NEW_LINE INDENT if a < b or d < b : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT else : NEW_LINE INDENT g = gcd ( b , d ) NEW_LINE x = g * ( c \/\/ g ) + ( a % g ) NEW_LINE if x <= c : NEW_LINE INDENT x += g NEW_LINE DEDENT if x >= b : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE NEW_LINE DEDENT DEDENT DEDENT","import sys NEW_LINE YES = \" Yes \" NEW_LINE NO = \" No \" NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT if b > a : NEW_LINE INDENT a , b = b , a NEW_LINE DEDENT while b > 0 : NEW_LINE INDENT a , b = b , a % b NEW_LINE DEDENT return a NEW_LINE DEDENT def solve ( T : int , A : \" List [ int ] \" , B : \" List [ int ] \" , C : \" List [ int ] \" , D : \" List [ int ] \" ) : NEW_LINE INDENT for i in range ( T ) : NEW_LINE INDENT a , b , c , d = A [ i ] , B [ i ] , C [ i ] , D [ i ] NEW_LINE if a < b or b > d : NEW_LINE INDENT print ( ' No ' ) NEW_LINE continue NEW_LINE DEDENT x = ( c - a + 1 ) % b NEW_LINE g = gcd ( b , d ) NEW_LINE print ( ' No ' if - ( - x \/\/ g * g ) - x + c + 1 < b else ' Yes ' ) NEW_LINE DEDENT return NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT def iterate_tokens ( ) : NEW_LINE INDENT for line in sys . stdin : NEW_LINE INDENT for word in line . split ( ) : NEW_LINE INDENT yield word NEW_LINE DEDENT DEDENT DEDENT tokens = iterate_tokens ( ) NEW_LINE T = int ( next ( tokens ) ) NEW_LINE A = [ int ( ) ] * ( T ) NEW_LINE B = [ int ( ) ] * ( T ) NEW_LINE C = [ int ( ) ] * ( T ) NEW_LINE D = [ int ( ) ] * ( T ) NEW_LINE for i in range ( T ) : NEW_LINE INDENT A [ i ] = int ( next ( tokens ) ) NEW_LINE B [ i ] = int ( next ( tokens ) ) NEW_LINE C [ i ] = int ( next ( tokens ) ) NEW_LINE D [ i ] = int ( next ( tokens ) ) NEW_LINE DEDENT solve ( T , A , B , C , D ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT","def g ( a , b ) : NEW_LINE INDENT if a % b == 0 : return b NEW_LINE return g ( b , a % b ) NEW_LINE DEDENT def f ( a , b , c , d ) : NEW_LINE INDENT yes = \" Yes \" NEW_LINE no = \" No \" NEW_LINE if a < b or d < b : return no NEW_LINE if c >= b or a <= c : return yes NEW_LINE if ( a - c ) % b > 0 and ( a - c ) % b < b - c : return no NEW_LINE e = d % b NEW_LINE if e == 0 or b - c == 1 : return yes NEW_LINE if e == 1 : return no NEW_LINE h = g ( b , e ) NEW_LINE if h < b - c : return no NEW_LINE if ( a - c ) % h > 0 and ( a - c ) % h < b - c : return no NEW_LINE return yes NEW_LINE DEDENT t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE ans = f ( a , b , c , d ) NEW_LINE print ( ans ) NEW_LINE DEDENT","import sys NEW_LINE iT = int ( input ( ) ) NEW_LINE aR = [ [ int ( x ) for x in sLine . split ( ) ] for sLine in sys . stdin . readlines ( ) ] NEW_LINE def fGcd ( iX , iY ) : NEW_LINE INDENT while iY : NEW_LINE INDENT iX , iY = iY , iX % iY NEW_LINE DEDENT return iX NEW_LINE DEDENT def fFunc ( iA , iB , iC , iD ) : NEW_LINE INDENT if iA < iB or iD < iB : NEW_LINE INDENT return False NEW_LINE DEDENT elif iC >= iB : NEW_LINE INDENT return True NEW_LINE DEDENT elif iC < iA % iB : NEW_LINE INDENT return False NEW_LINE DEDENT elif iB - iC - 1 < fGcd ( iB , iD ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT for eR in aR : NEW_LINE INDENT if fFunc ( * eR ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT","def Yes ( ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT def No ( ) : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT def gcd ( x , y ) : NEW_LINE INDENT b = max ( x , y ) NEW_LINE s = min ( x , y ) NEW_LINE r = b % s NEW_LINE while r != 0 : NEW_LINE INDENT b = s NEW_LINE s = r NEW_LINE r = b % s NEW_LINE DEDENT return s NEW_LINE DEDENT def lcm ( x , y ) : NEW_LINE INDENT return ( x * y ) \/\/ gcd ( x , y ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT T = int ( input ( ) ) NEW_LINE AD = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( T ) ] NEW_LINE for i in AD : NEW_LINE INDENT A = i [ 0 ] NEW_LINE B = i [ 1 ] NEW_LINE C = i [ 2 ] NEW_LINE D = i [ 3 ] NEW_LINE if A < B : NEW_LINE INDENT No ( ) NEW_LINE continue NEW_LINE DEDENT if B > D : NEW_LINE INDENT No ( ) NEW_LINE continue NEW_LINE DEDENT add = D - B NEW_LINE d = gcd ( B , D ) NEW_LINE C += 1 NEW_LINE t = C % d NEW_LINE k = A % d NEW_LINE if k == t : NEW_LINE INDENT LD = C NEW_LINE DEDENT elif k > t : NEW_LINE INDENT LD = C + k - t NEW_LINE DEDENT else : NEW_LINE INDENT LD = C + d - t + k NEW_LINE DEDENT if LD < B : NEW_LINE INDENT No ( ) NEW_LINE DEDENT else : NEW_LINE INDENT Yes ( ) NEW_LINE DEDENT DEDENT DEDENT main ( ) NEW_LINE"],"bleu":0.06627346546985337,"rouge_l":0.2476798143851508}
{"id":20,"predictions":["import sys NEW_LINE stdin = sys . stdin NEW_LINE sys . setrecursionlimit ( 10 ** 5 ) NEW_LINE def li ( ) : return map ( int , stdin . readline ( ) . split ( ) ) NEW_LINE def li_ ( ) : return map ( lambda x : int ( x ) - 1 , stdin . readline ( ) . split ( ) ) NEW_LINE def lf ( ) : return map ( float , stdin . readline ( ) . split ( ) ) NEW_LINE def ls ( ) : return stdin . readline ( ) . split ( ) NEW_LINE def ns ( ) : return stdin . readline ( ) . rstrip ( ) NEW_LINE def lc ( ) : return list ( ns ( ) ) NEW_LINE def ni ( ) : return int ( stdin . readline ( ) ) NEW_LINE def nf ( ) : return float ( stdin . readline ( ) ) NEW_LINE n = ni ( ) NEW_LINE grid = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT h = ni ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT grid . append ( ( grid [ i ] , grid [ i ] ) NEW_LINE DEDENT return grid [ h ] NEW_LINE DEDENT n = ni ( ) NEW_LINE s = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT s . append ( grid [ i ] [ j ] , s [ i + 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT s . append ( grid [ i ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT if k == 1 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( * grid [ n ] [ k ] ) NEW_LINE DEDENT"],"references":["import math NEW_LINE k = int ( input ( ) ) NEW_LINE if k == 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE print ( 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT n = math . ceil ( k \/ 4 ) * 2 NEW_LINE ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT tmp = [ ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT tmp . append ( ( i + j ) % n + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT tmp . append ( n + ( i + j ) % n + 1 ) NEW_LINE DEDENT DEDENT ans . append ( tmp ) NEW_LINE DEDENT kazu = n * 2 NEW_LINE while kazu != k : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ans [ i ] [ j ] == kazu : NEW_LINE INDENT ans [ i ] [ j ] -= n NEW_LINE DEDENT DEDENT DEDENT kazu -= 1 NEW_LINE DEDENT print ( n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( * ans [ i ] ) NEW_LINE DEDENT","K = int ( input ( ) ) NEW_LINE n = 0 NEW_LINE n1 = 0 NEW_LINE n2 = 0 NEW_LINE n3 = 0 NEW_LINE n4 = 0 NEW_LINE n5 = 0 NEW_LINE if K <= 499 : NEW_LINE INDENT n = K NEW_LINE mat = [ [ 0 for n1 in range ( K ) ] for n2 in range ( K ) ] NEW_LINE for n1 in range ( K ) : NEW_LINE INDENT for n2 in range ( K - n1 ) : NEW_LINE INDENT mat [ n1 ] [ n1 + n2 ] = n2 + 1 NEW_LINE DEDENT DEDENT for n1 in range ( K ) : NEW_LINE INDENT for n2 in range ( n1 ) : NEW_LINE INDENT mat [ n1 ] [ n2 ] = K + n2 - n1 + 1 NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT n = 500 NEW_LINE mat = [ [ 0 for n1 in range ( 500 ) ] for n2 in range ( 500 ) ] NEW_LINE for n1 in range ( 500 ) : NEW_LINE INDENT for n2 in range ( 500 - n1 ) : NEW_LINE INDENT mat [ n1 ] [ n1 + n2 ] = n2 + 1 NEW_LINE DEDENT DEDENT for n1 in range ( 500 ) : NEW_LINE INDENT for n2 in range ( n1 ) : NEW_LINE INDENT mat [ n1 ] [ n2 ] = 500 + n2 - n1 + 1 NEW_LINE DEDENT DEDENT for n2 in range ( K - 500 ) : NEW_LINE INDENT for n1 in range ( 250 ) : NEW_LINE INDENT kari = n1 * 2 + n2 NEW_LINE if kari >= 500 : NEW_LINE INDENT kari = kari - 500 NEW_LINE DEDENT mat [ n1 * 2 ] [ kari ] = n2 + 501 NEW_LINE DEDENT DEDENT DEDENT print ( n ) NEW_LINE if K <= 500 : NEW_LINE INDENT out = \" \" NEW_LINE for n1 in range ( K ) : NEW_LINE INDENT out = \" \" NEW_LINE for n2 in range ( K ) : NEW_LINE INDENT out = out + \" ▁ \" + str ( mat [ n1 ] [ n2 ] ) NEW_LINE DEDENT print ( out ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT out = \" \" NEW_LINE for n1 in range ( 500 ) : NEW_LINE INDENT out = \" \" NEW_LINE for n2 in range ( 500 ) : NEW_LINE INDENT out = out + \" ▁ \" + str ( mat [ n1 ] [ n2 ] ) NEW_LINE DEDENT print ( out ) NEW_LINE DEDENT DEDENT","def run ( K ) : NEW_LINE INDENT n_max = 500 NEW_LINE n = 0 NEW_LINE trouts = [ ] NEW_LINE if K <= n_max : NEW_LINE INDENT n = K NEW_LINE for i in range ( K ) : NEW_LINE INDENT trouts . append ( [ i + 1 ] * K ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT n = n_max NEW_LINE change = n_max * 2 - K NEW_LINE c1 = [ i for i in range ( 1 , n_max + 1 ) ] NEW_LINE c2 = [ i for i in range ( 2 , change + 1 ) ] + [ i for i in range ( n_max + 1 , n_max * 2 + 1 - change ) ] NEW_LINE if change > 0 : NEW_LINE INDENT c2 += [ 1 ] NEW_LINE DEDENT for i in range ( n_max ) : NEW_LINE INDENT shift = ( i \/\/ 2 ) * 2 NEW_LINE if i % 2 == 0 : NEW_LINE INDENT trouts . append ( c1 [ shift : ] + c1 [ : shift ] ) NEW_LINE DEDENT else : NEW_LINE INDENT trouts . append ( c2 [ shift : ] + c2 [ : shift ] ) NEW_LINE DEDENT DEDENT DEDENT return ( n , trouts ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT K = int ( input ( ) ) NEW_LINE n , trouts = run ( K ) NEW_LINE print ( n ) NEW_LINE for i in range ( len ( trouts ) ) : NEW_LINE INDENT print ( ' ▁ ' . join ( map ( str , trouts [ i ] ) ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT","from math import sqrt , ceil NEW_LINE K = int ( input ( ) ) NEW_LINE if K <= 500 : NEW_LINE INDENT print ( K ) NEW_LINE for i in range ( K ) : NEW_LINE INDENT Cout = [ i + 1 for n in range ( K ) ] NEW_LINE print ( \" ▁ \" . join ( map ( str , Cout ) ) ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT lim = int ( sqrt ( K ) ) NEW_LINE for i in range ( 2 , lim + 1 ) : NEW_LINE INDENT if K % ( i ** 2 ) == 0 : NEW_LINE INDENT print ( K \/\/ i ) NEW_LINE for n in range ( K \/\/ i ) : NEW_LINE INDENT Cout = [ i * n + ( mod % i ) + 1 for mod in range ( K \/\/ i ) ] NEW_LINE print ( \" ▁ \" . join ( map ( str , Cout ) ) ) NEW_LINE DEDENT break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT n = 2 * ceil ( K \/ 4 ) NEW_LINE print ( n ) NEW_LINE for raw in range ( n ) : NEW_LINE INDENT if raw % 2 == 0 : NEW_LINE INDENT Cout = [ ( raw + c ) % n + 1 for c in range ( n ) ] NEW_LINE DEDENT else : NEW_LINE INDENT Cout = [ n + 1 + ( raw + c ) % n for c in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if Cout [ i ] > K : Cout [ i ] -= n NEW_LINE DEDENT DEDENT print ( \" ▁ \" . join ( map ( str , Cout ) ) ) NEW_LINE DEDENT DEDENT DEDENT","k = int ( input ( ) ) NEW_LINE mx = 500 NEW_LINE if k <= mx : NEW_LINE INDENT print ( k ) NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT print ( * ( [ i ] * k ) , sep = \" ▁ \" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT cv = [ [ 0 for i in range ( mx ) ] for j in range ( mx ) ] NEW_LINE for i in range ( mx ) : NEW_LINE INDENT for j in range ( mx ) : NEW_LINE INDENT cv [ i ] [ ( i + j ) % mx ] = j + 1 NEW_LINE if i % 2 == 1 and j + 1 + mx <= k : NEW_LINE INDENT cv [ i ] [ ( i + j ) % mx ] += mx NEW_LINE DEDENT DEDENT DEDENT print ( mx ) NEW_LINE for i in range ( mx ) : NEW_LINE INDENT print ( * cv [ i ] , sep = \" ▁ \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.39918993080436965,"rouge_l":0.4562173561217233}
{"id":21,"predictions":["n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d = { } NEW_LINE prev = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == 0 : NEW_LINE INDENT d [ a [ i ] ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ a [ i ] ] = 1 NEW_LINE prev = i NEW_LINE DEDENT DEDENT ans = 2 NEW_LINE for i in d : NEW_LINE INDENT if d [ i ] == 0 : NEW_LINE INDENT ans += d [ i ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["n = int ( input ( ) ) NEW_LINE a = [ int ( input ( ) ) for i in range ( n ) ] NEW_LINE b = list ( set ( a ) ) NEW_LINE print ( len ( a ) - len ( b ) ) NEW_LINE","N = int ( input ( ) ) NEW_LINE already = set ( ) NEW_LINE count = 0 NEW_LINE for n in range ( N ) : NEW_LINE INDENT A = input ( ) NEW_LINE if A in already : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT already . add ( A ) NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE","import collections NEW_LINE n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT a . append ( int ( input ( ) ) ) NEW_LINE DEDENT l = collections . Counter ( a ) NEW_LINE b = 0 NEW_LINE for k in l . keys ( ) : NEW_LINE INDENT if l [ k ] >= 2 : NEW_LINE INDENT b += l [ k ] - 1 NEW_LINE DEDENT DEDENT print ( b ) NEW_LINE","n , * a = open ( 0 ) ; print ( int ( n ) - len ( set ( a ) ) ) NEW_LINE","def solve ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE visited = [ 0 ] * 100005 NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a = int ( input ( ) ) NEW_LINE if visited [ a - 1 ] != 0 : ans += 1 NEW_LINE else : visited [ a - 1 ] += 1 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT solve ( ) NEW_LINE"],"bleu":0.39582431163233106,"rouge_l":0.5147900968783639}
{"id":22,"predictions":["import sys NEW_LINE N = int ( input ( ) ) NEW_LINE A = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE a = max ( A ) NEW_LINE b = min ( A ) NEW_LINE if b >= 0 : NEW_LINE INDENT print ( a ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( b - a ) NEW_LINE DEDENT"],"references":["def main ( ) : NEW_LINE INDENT n = input ( ) NEW_LINE a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE ai = max ( a ) NEW_LINE a . remove ( ai ) NEW_LINE aj = float ( ' inf ' ) NEW_LINE tmp = float ( ' inf ' ) NEW_LINE for aa in a : NEW_LINE INDENT diff = abs ( ai \/ 2 - aa ) NEW_LINE if diff < tmp : NEW_LINE INDENT tmp = diff NEW_LINE aj = aa NEW_LINE DEDENT DEDENT print ( ai , aj ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT","def upperbound ( zs , left , right , ok ) : NEW_LINE INDENT if left + 1 >= right : NEW_LINE INDENT return left NEW_LINE DEDENT m = ( left + right ) \/\/ 2 NEW_LINE if ok ( zs [ m ] ) : NEW_LINE INDENT return upperbound ( zs , m , right , ok ) NEW_LINE DEDENT else : NEW_LINE INDENT return upperbound ( zs , left , m , ok ) NEW_LINE DEDENT DEDENT n = int ( input ( ) ) NEW_LINE xs = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ds = sorted ( xs ) NEW_LINE a = ds [ - 1 ] NEW_LINE c = a \/ 2 NEW_LINE zs = [ d - c for d in ds [ : - 1 ] ] NEW_LINE i = upperbound ( zs , 0 , len ( zs ) - 1 , lambda z : z <= 0 ) NEW_LINE j = i + 1 if i < len ( zs ) - 1 else i NEW_LINE b = ds [ i ] if abs ( zs [ i ] ) < abs ( zs [ j ] ) else ds [ j ] NEW_LINE print ( a , b ) NEW_LINE","import math NEW_LINE N = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE A . sort ( ) NEW_LINE def combinations_count ( n , r ) : NEW_LINE INDENT return math . factorial ( n ) \/\/ ( math . factorial ( n - r ) * math . factorial ( r ) ) NEW_LINE DEDENT if len ( A ) == 2 : NEW_LINE INDENT print ( A [ 1 ] ) NEW_LINE print ( A [ 0 ] ) NEW_LINE DEDENT half = A [ - 1 ] \/ 2 NEW_LINE for i in range ( N - 2 ) : NEW_LINE INDENT if abs ( A [ i ] - half ) >= abs ( A [ i + 1 ] - half ) <= abs ( A [ i + 2 ] - half ) : NEW_LINE INDENT print ( A [ - 1 ] ) NEW_LINE print ( A [ i + 1 ] ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT","import bisect NEW_LINE import sys NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE input = sys . stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE A = sorted ( A ) NEW_LINE ma = A [ - 1 ] NEW_LINE A = A [ : - 1 ] NEW_LINE mi = - 1 NEW_LINE mid = ma \/ 2 NEW_LINE mid_ind = bisect . bisect_left ( A , mid ) NEW_LINE l = n - 1 NEW_LINE if mid_ind >= l : NEW_LINE INDENT mi = A [ - 1 ] NEW_LINE DEDENT elif mid_ind <= 0 : NEW_LINE INDENT mi = A [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT if abs ( A [ mid_ind ] - mid ) > abs ( A [ mid_ind - 1 ] - mid ) : NEW_LINE INDENT mi = A [ mid_ind - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT mi = A [ mid_ind ] NEW_LINE DEDENT DEDENT print ( ma , mi ) NEW_LINE","import numpy as np ; input ( ) ; a = list ( map ( int , input ( ) . split ( ' ▁ ' ) ) ) ; m = max ( a ) ; a . remove ( m ) ; b = [ abs ( 2 * i - m ) for i in a ] ; j = b . index ( min ( b ) ) ; print ( m , a [ j ] ) NEW_LINE"],"bleu":0.5389353131670498,"rouge_l":0.4419185610791907}
{"id":23,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) m = int ( input ( ) ) a . sort ( ) print ( sum ( a [ : m ] ) - sum ( a [ : m ] ) ) NEW_LINE"],"references":["N , M = map ( int , input ( ) . split ( ) ) NEW_LINE zahyo = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE zahyo . sort ( ) NEW_LINE sa = [ 0 for _ in range ( M - 1 ) ] NEW_LINE for i in range ( M - 1 ) : NEW_LINE INDENT sa [ i ] = zahyo [ i + 1 ] - zahyo [ i ] NEW_LINE DEDENT sa . sort ( reverse = True ) NEW_LINE sa = sa [ N - 1 : ] NEW_LINE print ( sum ( sa ) ) NEW_LINE","import sys NEW_LINE def solve ( N : int , M : int , X : \" List [ int ] \" ) : NEW_LINE INDENT if N >= M : NEW_LINE INDENT print ( 0 ) NEW_LINE return NEW_LINE DEDENT X . sort ( ) NEW_LINE dist = [ ] NEW_LINE for i in range ( 1 , len ( X ) ) : NEW_LINE INDENT dist . append ( abs ( X [ i ] - X [ i - 1 ] ) ) NEW_LINE DEDENT distIndices = [ ( dist [ i ] , i ) for i in range ( len ( dist ) ) ] NEW_LINE distIndices . sort ( reverse = True ) NEW_LINE splitIndex = [ ] NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT splitIndex . append ( distIndices [ i ] [ 1 ] ) NEW_LINE DEDENT splitIndex . sort ( ) NEW_LINE ranges = [ ] NEW_LINE begin = 0 NEW_LINE for next in splitIndex : NEW_LINE INDENT ranges . append ( X [ begin : next + 1 ] ) NEW_LINE begin = next + 1 NEW_LINE DEDENT ranges . append ( X [ begin : ] ) NEW_LINE cost = 0 NEW_LINE for R in ranges : NEW_LINE INDENT if len ( R ) == 1 : NEW_LINE INDENT continue NEW_LINE DEDENT cost += R [ - 1 ] - R [ 0 ] NEW_LINE DEDENT print ( cost ) NEW_LINE return NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT def iterate_tokens ( ) : NEW_LINE INDENT for line in sys . stdin : NEW_LINE INDENT for word in line . split ( ) : NEW_LINE INDENT yield word NEW_LINE DEDENT DEDENT DEDENT tokens = iterate_tokens ( ) NEW_LINE N = int ( next ( tokens ) ) NEW_LINE M = int ( next ( tokens ) ) NEW_LINE X = [ int ( next ( tokens ) ) for _ in range ( M ) ] NEW_LINE solve ( N , M , X ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT","def gcd_core ( a , b ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return gcd_core ( b , a % b ) NEW_LINE DEDENT DEDENT def gcd ( arr ) : NEW_LINE INDENT g = gcd_core ( arr [ 0 ] , arr [ 1 ] ) NEW_LINE for i in range ( 2 , len ( arr ) ) : NEW_LINE INDENT g = gcd_core ( g , arr [ i ] ) NEW_LINE DEDENT return g NEW_LINE DEDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE arr . sort ( ) NEW_LINE temp = [ ] NEW_LINE for i in range ( m - 1 ) : NEW_LINE INDENT temp . append ( arr [ i + 1 ] - arr [ i ] ) NEW_LINE DEDENT temp . sort ( ) NEW_LINE temp [ : : - 1 ] NEW_LINE ans = 0 NEW_LINE for i in range ( m - n ) : NEW_LINE INDENT ans += temp [ i ] NEW_LINE DEDENT print ( ans ) NEW_LINE","n , m = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE x = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE x . sort ( ) NEW_LINE distance = [ x [ i + 1 ] - x [ i ] for i in range ( len ( x ) - 1 ) ] NEW_LINE distance . sort ( reverse = True ) NEW_LINE ans = sum ( distance [ n - 1 : ] ) NEW_LINE print ( ans ) NEW_LINE","N , M = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE X = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE if N >= M : NEW_LINE INDENT print ( 0 ) NEW_LINE exit ( ) NEW_LINE DEDENT path_cnt = sorted ( [ X [ i + 1 ] - X [ i ] for i in range ( M - 1 ) ] ) NEW_LINE if N == 1 : NEW_LINE INDENT print ( sum ( path_cnt ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( sum ( path_cnt [ : - N + 1 ] ) ) NEW_LINE DEDENT"],"bleu":0.2643832379663474,"rouge_l":0.44533475783475784}
{"id":24,"predictions":["import sys NEW_LINE ns = lambda : sys . stdin . readline ( ) . rstrip ( ) NEW_LINE ni = lambda : int ( ns ( ) ) NEW_LINE nm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE nl = lambda : list ( nm ( ) ) NEW_LINE n = ni ( ) NEW_LINE a = nl ( ) NEW_LINE lis = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] % a [ i ] : NEW_LINE INDENT lis . append ( a [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT lis . append ( a [ i ] ) NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for x in a : NEW_LINE INDENT if x % a [ 0 ] == 0 : NEW_LINE INDENT ans += ( lis [ x ] \/\/ a [ 1 ] ) * ( x \/\/ a [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += min ( ans , ans ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["import sys NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE input = sys . stdin . readline NEW_LINE A , B , K , L = map ( int , input ( ) . split ( ) ) NEW_LINE s = K \/\/ L NEW_LINE print ( min ( K * A , s * B + ( K - s * L ) * A , ( s + 1 ) * B ) ) NEW_LINE","def main ( ) : NEW_LINE INDENT a , b , k , l = map ( int , input ( ) . split ( ) ) NEW_LINE res = min ( a * k , b * ( ( k - 1 ) \/\/ l + 1 ) , b * ( k \/\/ l ) + a * ( k % l ) ) NEW_LINE print ( res ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT","a , b , k , l = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE ans = b * ( k \/\/ l ) NEW_LINE k -= l * ( k \/\/ l ) NEW_LINE if a * k <= b : NEW_LINE INDENT ans += a * k NEW_LINE DEDENT else : NEW_LINE INDENT ans += b NEW_LINE DEDENT print ( ans ) NEW_LINE","import sys NEW_LINE input = sys . stdin . readline NEW_LINE a , b , k , l = map ( int , input ( ) . split ( ) ) NEW_LINE res = a * k NEW_LINE if k % l == 0 : NEW_LINE INDENT res = min ( res , b * k \/\/ l ) NEW_LINE DEDENT else : NEW_LINE INDENT res = min ( res , ( k \/\/ l + 1 ) * b ) NEW_LINE DEDENT res = min ( res , b * ( k \/\/ l ) + ( k % l ) * a ) NEW_LINE print ( res ) NEW_LINE","A , B , K , L = map ( int , input ( ) . split ( \" ▁ \" ) ) NEW_LINE p = [ A * K ] NEW_LINE p . append ( ( K \/\/ L + 1 ) * B ) NEW_LINE for i in range ( 1 , K + 1 ) : NEW_LINE INDENT if K - ( L * i ) >= 0 : NEW_LINE INDENT temp = i * B + ( K - ( L * i ) ) * A NEW_LINE p . append ( temp ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( min ( p ) ) NEW_LINE"],"bleu":0.27393474194103257,"rouge_l":0.4059883236030025}
{"id":25,"predictions":["N = int ( input ( ) ) NEW_LINE row = [ i for i in range ( N ) ] NEW_LINE flag = True NEW_LINE for i in range ( N ) : NEW_LINE INDENT if N % 2 == 0 : NEW_LINE INDENT row [ i ] = row [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT row [ i ] = row [ i ] NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT if row [ i ] == row [ i ] : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if flag : NEW_LINE INDENT print ( ' Aoki ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' Takahashi ' ) NEW_LINE DEDENT"],"references":["N = input ( ) NEW_LINE L = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def aoki ( i , array ) : NEW_LINE INDENT maxi = - 100000000 NEW_LINE for j in range ( len ( array ) ) : NEW_LINE INDENT tmp = 0 NEW_LINE if j != i : NEW_LINE INDENT if j < i : NEW_LINE INDENT T = array [ j : i + 1 ] NEW_LINE DEDENT elif j > i : NEW_LINE INDENT T = array [ i : j + 1 ] NEW_LINE DEDENT for k in range ( len ( T ) ) : NEW_LINE INDENT if k % 2 == 1 : NEW_LINE INDENT tmp += T [ k ] NEW_LINE DEDENT DEDENT if maxi < tmp : NEW_LINE INDENT choice = j NEW_LINE maxi = tmp NEW_LINE DEDENT DEDENT DEDENT return choice NEW_LINE DEDENT maxi = - 10000000000000 NEW_LINE for i in range ( len ( L ) ) : NEW_LINE INDENT aoki_choice = aoki ( i , L ) NEW_LINE tmp = 0 NEW_LINE if i < aoki_choice : NEW_LINE INDENT T = L [ i : aoki_choice + 1 ] NEW_LINE for j in range ( len ( T ) ) : NEW_LINE INDENT if j % 2 == 0 : NEW_LINE INDENT tmp += T [ j ] NEW_LINE DEDENT DEDENT DEDENT elif i > aoki_choice : NEW_LINE INDENT T = L [ aoki_choice : i + 1 ] NEW_LINE for j in range ( len ( T ) ) : NEW_LINE INDENT if j % 2 == 0 : NEW_LINE INDENT tmp += T [ j ] NEW_LINE DEDENT DEDENT DEDENT maxi = max ( tmp , maxi ) NEW_LINE DEDENT print ( maxi ) NEW_LINE","def seq_game ( N : int , A : list ) -> int : NEW_LINE INDENT Tmax = - float ( ' inf ' ) NEW_LINE for ti in range ( N ) : NEW_LINE INDENT Amax = - float ( ' inf ' ) NEW_LINE Aidx = - 1 NEW_LINE for ai in range ( N ) : NEW_LINE INDENT if ti == ai : NEW_LINE INDENT continue NEW_LINE DEDENT if ti < ai : NEW_LINE INDENT ap = sum ( A [ ti + 1 : ai + 1 : 2 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT ap = sum ( A [ ai + 1 : ti + 1 : 2 ] ) NEW_LINE DEDENT if Amax < ap : NEW_LINE INDENT Amax = ap NEW_LINE Aidx = ai NEW_LINE DEDENT DEDENT if ti < Aidx : NEW_LINE INDENT Tmax = max ( Tmax , sum ( A [ ti : Aidx + 1 : 2 ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT Tmax = max ( Tmax , sum ( A [ Aidx : ti + 1 : 2 ] ) ) NEW_LINE DEDENT DEDENT return Tmax NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE A = [ int ( s ) for s in input ( ) . split ( ) ] NEW_LINE ans = seq_game ( N , A ) NEW_LINE print ( ans ) NEW_LINE DEDENT","import sys NEW_LINE input = sys . stdin . readline NEW_LINE N = int ( input ( ) ) NEW_LINE a = [ int ( _ ) for _ in input ( ) . split ( ) ] NEW_LINE Tmax = - float ( ' inf ' ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT Amax = - float ( ' inf ' ) NEW_LINE Aindex = - 1 NEW_LINE for j in range ( N ) : NEW_LINE INDENT if i == j : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT if i < j : NEW_LINE INDENT tmp = sum ( a [ i + 1 : j + 1 : 2 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT tmp = sum ( a [ j + 1 : i + 1 : 2 ] ) NEW_LINE DEDENT if tmp > Amax : NEW_LINE INDENT Amax = tmp NEW_LINE Aindex = j NEW_LINE DEDENT DEDENT DEDENT if i < Aindex : NEW_LINE INDENT tmp = sum ( a [ i : Aindex + 1 : 2 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT tmp = sum ( a [ Aindex : i + 1 : 2 ] ) NEW_LINE DEDENT if tmp > Tmax : NEW_LINE INDENT Tmax = tmp NEW_LINE DEDENT DEDENT print ( Tmax ) NEW_LINE","n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE m = - 5000 NEW_LINE for x in range ( n ) : NEW_LINE INDENT k = - 5000 NEW_LINE l = - 5000 NEW_LINE for y in list ( range ( x ) ) + list ( range ( x + 1 , n ) ) : NEW_LINE INDENT p = sum ( a [ min ( x , y ) : max ( x , y ) + 1 : 2 ] ) NEW_LINE q = sum ( a [ min ( x , y ) + 1 : max ( x , y ) + 1 : 2 ] ) NEW_LINE if q > l : NEW_LINE INDENT k , l = p , q NEW_LINE DEDENT DEDENT m = max ( m , k ) NEW_LINE DEDENT print ( m ) NEW_LINE","n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE odd = [ 0 ] * ( n + 1 ) NEW_LINE even = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT odd [ i + 1 ] = odd [ i ] + a [ i ] NEW_LINE even [ i + 1 ] = even [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT odd [ i + 1 ] = odd [ i ] NEW_LINE even [ i + 1 ] = even [ i ] + a [ i ] NEW_LINE DEDENT DEDENT B = - 100000 NEW_LINE ans = B NEW_LINE for i in range ( n ) : NEW_LINE INDENT p = B NEW_LINE c = - 1 NEW_LINE for j in range ( i ) : NEW_LINE INDENT if j % 2 == 0 : NEW_LINE INDENT temp = even [ i + 1 ] - even [ j ] NEW_LINE if temp > p : NEW_LINE INDENT p = temp NEW_LINE c = j NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT temp = odd [ i + 1 ] - odd [ j ] NEW_LINE if temp > p : NEW_LINE INDENT p = temp NEW_LINE c = j NEW_LINE DEDENT DEDENT DEDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT temp = even [ j + 1 ] - even [ i ] NEW_LINE if temp > p : NEW_LINE INDENT p = temp NEW_LINE c = j NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT temp = odd [ j + 1 ] - odd [ i ] NEW_LINE if temp > p : NEW_LINE INDENT p = temp NEW_LINE c = j NEW_LINE DEDENT DEDENT DEDENT if c < i : NEW_LINE INDENT if c % 2 == 1 : NEW_LINE INDENT temp = even [ i + 1 ] - even [ c ] NEW_LINE DEDENT else : NEW_LINE INDENT temp = odd [ i + 1 ] - odd [ c ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if i % 2 == 1 : NEW_LINE INDENT temp = even [ c + 1 ] - even [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT temp = odd [ c + 1 ] - odd [ i ] NEW_LINE DEDENT DEDENT if temp > ans : NEW_LINE INDENT ans = temp NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"bleu":0.4249384067302966,"rouge_l":0.4374600778119738}
{"id":26,"predictions":["N = int ( input ( ) ) NEW_LINE K = int ( input ( ) ) NEW_LINE A = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT ans += A [ i ] NEW_LINE DEDENT for i in range ( K ) : NEW_LINE INDENT ans += A [ i ] NEW_LINE DEDENT print ( ans ) NEW_LINE"],"references":["N = int ( input ( ) ) NEW_LINE K = int ( input ( ) ) NEW_LINE X = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE sum_len = 0 NEW_LINE for i in range ( len ( X ) ) : NEW_LINE INDENT if X [ i ] < abs ( K - X [ i ] ) : NEW_LINE INDENT sum_len += X [ i ] * 2 NEW_LINE DEDENT else : NEW_LINE INDENT sum_len += abs ( K - X [ i ] ) * 2 NEW_LINE DEDENT DEDENT print ( sum_len ) NEW_LINE","_ , k , t = open ( 0 ) ; print ( sum ( min ( x , int ( k ) - x ) * 2 for x in map ( int , t . split ( ) ) ) ) NEW_LINE","n = int ( input ( ) ) NEW_LINE k = int ( input ( ) ) NEW_LINE x = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE s = 0 NEW_LINE for x_ in x : NEW_LINE INDENT s += ( min ( x_ , abs ( k - x_ ) ) * 2 ) NEW_LINE DEDENT print ( s ) NEW_LINE","import math NEW_LINE import functools NEW_LINE import itertools NEW_LINE import numpy as np NEW_LINE import sys NEW_LINE MAX_INT = int ( 10e10 ) NEW_LINE MIN_INT = - MAX_INT NEW_LINE mod = 1000000007 NEW_LINE sys . setrecursionlimit ( 1000000 ) NEW_LINE def IL ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def SL ( ) : return input ( ) . split ( ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def S ( ) : return input ( ) NEW_LINE N = I ( ) NEW_LINE K = I ( ) NEW_LINE x = IL ( ) NEW_LINE num = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT num += min ( x [ i ] , K - x [ i ] ) NEW_LINE DEDENT print ( num * 2 ) NEW_LINE","n = int ( input ( ) ) NEW_LINE k = int ( input ( ) ) NEW_LINE def check ( i ) : NEW_LINE INDENT return min ( 2 * ( k - i ) , 2 * i ) NEW_LINE DEDENT print ( sum ( [ check ( int ( i ) ) for i in input ( ) . split ( ) ] ) ) NEW_LINE"],"bleu":0.6333307045577855,"rouge_l":0.6959996526928147}
{"id":27,"predictions":["for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if ( 2 * n ) % 2 == 0 : NEW_LINE INDENT print ( \" First \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Second \" ) NEW_LINE DEDENT DEDENT"],"references":["from fractions import gcd NEW_LINE def gcdL ( L ) : NEW_LINE INDENT g = L [ 0 ] NEW_LINE for i in range ( 1 , len ( L ) ) : NEW_LINE INDENT if g == 1 : NEW_LINE INDENT return ( g ) NEW_LINE DEDENT g = gcd ( g , L [ i ] ) NEW_LINE DEDENT return g NEW_LINE DEDENT def play ( A , i ) : NEW_LINE INDENT A [ i ] -= 1 NEW_LINE g = gcdL ( A ) NEW_LINE return [ x \/\/ g for x in A ] NEW_LINE DEDENT def cnt ( A ) : NEW_LINE INDENT odd , even = 0 , 0 NEW_LINE for a in A : NEW_LINE INDENT if a % 2 : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even += 1 NEW_LINE DEDENT DEDENT return odd , even NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE First = 1 NEW_LINE while True : NEW_LINE INDENT odd , even = cnt ( A ) NEW_LINE if even % 2 : NEW_LINE INDENT print ( ' First ' if First else ' Second ' ) NEW_LINE break NEW_LINE DEDENT elif odd > 1 : NEW_LINE INDENT print ( ' Second ' if First else ' First ' ) NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if A [ i ] % 2 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if A [ i ] == 1 : NEW_LINE INDENT print ( ' Second ' if First else ' First ' ) NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT A = play ( A , i ) NEW_LINE First ^= 1 NEW_LINE DEDENT DEDENT DEDENT","from fractions import gcd NEW_LINE def readln ( ch ) : NEW_LINE INDENT _res = list ( map ( int , str ( input ( ) ) . split ( ch ) ) ) NEW_LINE return _res NEW_LINE DEDENT def count ( a ) : NEW_LINE INDENT odd , even = 0 , 0 NEW_LINE for x in a : NEW_LINE INDENT if x % 2 == 1 : odd = odd + 1 NEW_LINE else : even = even + 1 NEW_LINE DEDENT return odd , even NEW_LINE DEDENT def deal ( n , a ) : NEW_LINE INDENT odd , even = count ( a ) NEW_LINE if even == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT if even % 2 == 1 : NEW_LINE INDENT return True NEW_LINE DEDENT if odd > 1 : NEW_LINE INDENT return False NEW_LINE DEDENT if a [ 0 ] % 2 == 0 : NEW_LINE INDENT res = a [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT res = a [ 1 ] NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if a [ i ] % 2 == 1 : NEW_LINE INDENT if a [ i ] == 1 : return False NEW_LINE a [ i ] = a [ i ] - 1 NEW_LINE DEDENT res = gcd ( a [ i ] , res ) NEW_LINE DEDENT return not deal ( n , list ( map ( lambda x : x \/\/ res , a ) ) ) NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE a = readln ( ' ▁ ' ) NEW_LINE if deal ( n , a ) : NEW_LINE INDENT print ( ' First ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' Second ' ) NEW_LINE DEDENT"],"bleu":0.031284209237279995,"rouge_l":0.28868689903846156}
{"id":28,"predictions":["a , b = input ( ) , input ( ) NEW_LINE print ( \" YES \" if a [ - 1 ] == b [ ] else \" NO \" ) NEW_LINE"],"references":["s = input ( ) NEW_LINE t = s [ : : - 1 ] NEW_LINE for x , y in zip ( s , t ) : NEW_LINE INDENT if x != ' * ' and y != ' * ' and x != y : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT print ( ' YES ' ) NEW_LINE","S = [ str ( _ ) for _ in input ( ) ] NEW_LINE revS = S [ : : - 1 ] NEW_LINE for i in range ( len ( S ) ) : NEW_LINE INDENT if S [ i ] == \" * \" : NEW_LINE INDENT revS [ i ] = \" * \" NEW_LINE DEDENT elif revS [ i ] == \" * \" : NEW_LINE INDENT S [ i ] = \" * \" NEW_LINE DEDENT DEDENT print ( \" YES \" if S == revS else \" NO \" ) NEW_LINE","S = input ( ) NEW_LINE if len ( S ) % 2 == 0 : NEW_LINE INDENT S1 = S [ : len ( S ) \/\/ 2 ] NEW_LINE S2 = S [ len ( S ) \/\/ 2 : ] NEW_LINE S2 = S2 [ : : - 1 ] NEW_LINE for i in range ( len ( S ) \/\/ 2 ) : NEW_LINE INDENT if S1 [ i ] == ' * ' or S2 [ i ] == ' * ' : NEW_LINE INDENT continue NEW_LINE DEDENT elif S1 [ i ] == S2 [ i ] : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT S1 = S [ : len ( S ) \/\/ 2 ] NEW_LINE S2 = S [ len ( S ) \/\/ 2 + 1 : ] NEW_LINE S2 = S2 [ : : - 1 ] NEW_LINE for i in range ( len ( S ) \/\/ 2 ) : NEW_LINE INDENT if S1 [ i ] == ' * ' or S2 [ i ] == ' * ' : NEW_LINE INDENT continue NEW_LINE DEDENT elif S1 [ i ] == S2 [ i ] : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT DEDENT","s = input ( ) NEW_LINE tmp1 = list ( s ) NEW_LINE tmp2 = list ( s ) NEW_LINE tmp2 . reverse ( ) NEW_LINE res = ' YES ' NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if tmp1 [ i ] != tmp2 [ i ] : NEW_LINE INDENT if tmp1 [ i ] == ' * ' or tmp2 [ i ] == ' * ' : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT res = ' NO ' NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT print ( res ) NEW_LINE","line = list ( input ( ) ) NEW_LINE i = 0 NEW_LINE while i <= ( len ( line ) ) \/\/ 2 : NEW_LINE INDENT if line [ i ] == \" * \" or line [ len ( line ) - i - 1 ] == \" * \" or line [ i ] == line [ len ( line ) - i - 1 ] : NEW_LINE INDENT i = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE break NEW_LINE DEDENT DEDENT if i > ( len ( line ) ) \/\/ 2 : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT"],"bleu":0.1723526550220198,"rouge_l":0.29683698296836986}
{"id":29,"predictions":["import sys NEW_LINE def main ( ) : NEW_LINE INDENT input = sys . stdin . readline NEW_LINE n , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT a [ i ] = a [ i ] NEW_LINE DEDENT if sum ( a ) <= k : NEW_LINE INDENT print ( ' yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' no ' ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"references":["t = int ( input ( ) ) NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE m = int ( input ( ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if n < m : NEW_LINE INDENT print ( \" no \" ) NEW_LINE exit ( ) NEW_LINE DEDENT for i in b : NEW_LINE INDENT for l in range ( len ( a ) ) : NEW_LINE INDENT if i - t - 1 < a [ l ] < i + 1 : NEW_LINE INDENT a . pop ( l ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if len ( a ) == n - m : NEW_LINE INDENT print ( \" yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" no \" ) NEW_LINE DEDENT","import sys NEW_LINE limit = int ( input ( ) ) NEW_LINE int ( input ( ) ) NEW_LINE takoyaki = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE int ( input ( ) ) NEW_LINE customer = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in customer : NEW_LINE INDENT index = [ j for j in takoyaki if i - limit <= j <= i ] NEW_LINE if len ( index ) == 0 : NEW_LINE INDENT print ( ' no ' ) NEW_LINE sys . exit ( ) NEW_LINE DEDENT takoyaki . remove ( index [ 0 ] ) NEW_LINE DEDENT print ( ' yes ' ) NEW_LINE","T = int ( input ( ) ) NEW_LINE N = int ( input ( ) ) NEW_LINE A = [ int ( _ ) for _ in input ( ) . split ( ) ] NEW_LINE M = int ( input ( ) ) NEW_LINE B = [ int ( _ ) for _ in input ( ) . split ( ) ] NEW_LINE can = True NEW_LINE a_idx = 0 NEW_LINE for b in B : NEW_LINE INDENT while True : NEW_LINE INDENT if a_idx == N : NEW_LINE INDENT can = False NEW_LINE break NEW_LINE DEDENT if b - A [ a_idx ] < 0 : NEW_LINE INDENT can = False NEW_LINE break NEW_LINE DEDENT if b - A [ a_idx ] <= T : NEW_LINE INDENT a_idx += 1 NEW_LINE break NEW_LINE DEDENT a_idx += 1 NEW_LINE DEDENT if not can : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if can : NEW_LINE INDENT print ( \" yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" no \" ) NEW_LINE DEDENT","T = int ( input ( ) ) NEW_LINE N = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . rstrip ( ) . split ( ) ) ) NEW_LINE M = int ( input ( ) ) NEW_LINE B = list ( map ( int , input ( ) . rstrip ( ) . split ( ) ) ) NEW_LINE time = 0 NEW_LINE takoyaki_flg = [ False for i in range ( N ) ] NEW_LINE expire_list = [ A [ i ] + T for i in range ( N ) ] NEW_LINE mission_failed = False NEW_LINE while time < 100 : NEW_LINE INDENT time += 1 NEW_LINE while time in A : NEW_LINE INDENT index = A . index ( time ) NEW_LINE takoyaki_flg [ index ] = True NEW_LINE A [ index ] = 0 NEW_LINE DEDENT while time in B : NEW_LINE INDENT index = B . index ( time ) NEW_LINE if True in takoyaki_flg : NEW_LINE INDENT tako_index = takoyaki_flg . index ( True ) NEW_LINE takoyaki_flg [ tako_index ] = False NEW_LINE B [ index ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT mission_failed = True NEW_LINE break NEW_LINE DEDENT DEDENT if mission_failed : NEW_LINE INDENT break NEW_LINE DEDENT while time in expire_list : NEW_LINE INDENT index = expire_list . index ( time ) NEW_LINE takoyaki_flg [ index ] = False NEW_LINE expire_list [ index ] = 0 NEW_LINE DEDENT DEDENT if mission_failed : NEW_LINE INDENT print ( ' no ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' yes ' ) NEW_LINE DEDENT","t = int ( input ( ) ) NEW_LINE n = int ( input ( ) ) NEW_LINE a_list = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE m = int ( input ( ) ) NEW_LINE b_list = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE if n < m : NEW_LINE INDENT print ( ' no ' ) NEW_LINE DEDENT else : NEW_LINE INDENT count = 0 NEW_LINE for b in b_list : NEW_LINE INDENT for a in range ( len ( a_list ) ) : NEW_LINE INDENT if b - a_list [ a ] <= t and b - a_list [ a ] >= 0 : NEW_LINE INDENT count += 1 NEW_LINE a_list . pop ( a ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if count == len ( b_list ) : NEW_LINE INDENT print ( ' yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' no ' ) NEW_LINE DEDENT DEDENT"],"bleu":0.5650471388085664,"rouge_l":0.5434994336668807}
{"id":30,"predictions":["n , d = map ( int , input ( ) . split ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) )   count = 0 for i in range ( 1 , len ( arr ) ) : count += arr [ i - 1 ] print ( count ) NEW_LINE"],"references":["N = int ( input ( ) ) NEW_LINE D , X = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT A = int ( input ( ) ) NEW_LINE ans += ( D - 1 ) \/\/ A + 1 NEW_LINE DEDENT print ( ans + X ) NEW_LINE","import math NEW_LINE N = int ( input ( ) ) NEW_LINE D , X = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE A = [ int ( input ( ) ) for _ in range ( N ) ] NEW_LINE Ans = X NEW_LINE for i in A : NEW_LINE INDENT Ans += math . ceil ( D \/ i ) NEW_LINE DEDENT print ( Ans ) NEW_LINE","N = int ( input ( ) ) NEW_LINE D , X , = map ( int , input ( ) . split ( ) ) NEW_LINE An = [ int ( input ( ) ) for _ in range ( N ) ] NEW_LINE c = 0 NEW_LINE for n in range ( N ) : NEW_LINE INDENT i = 0 NEW_LINE while True : NEW_LINE INDENT d = i * An [ n ] + 1 NEW_LINE if d > D : NEW_LINE INDENT break NEW_LINE DEDENT c += 1 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT print ( c + X ) NEW_LINE","N = int ( input ( ) ) NEW_LINE D , X = map ( int , input ( ) . split ( ) ) NEW_LINE lists = [ ] NEW_LINE day_list = [ ] NEW_LINE chocolate = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT A = int ( input ( ) ) NEW_LINE lists . append ( A ) NEW_LINE day_list = [ ] NEW_LINE for j in range ( D ) : NEW_LINE INDENT if j * lists [ i ] + 1 <= D : NEW_LINE INDENT day_list . append ( j * lists [ i ] + 1 ) NEW_LINE DEDENT DEDENT chocolate += len ( day_list ) NEW_LINE DEDENT print ( X + chocolate ) NEW_LINE","N , D , X , * A = map ( int , open ( 0 ) . read ( ) . split ( ) ) NEW_LINE ans = X NEW_LINE for i in range ( N ) : NEW_LINE INDENT ans += 1 + ( D - 1 ) \/\/ A [ i ] NEW_LINE DEDENT print ( ans ) NEW_LINE"],"bleu":0.46824312161034765,"rouge_l":0.5522992613771742}
{"id":31,"predictions":["def win_rate ( A : int , B : int , C : int , D : int ) -> str : NEW_LINE INDENT if B * C < A * D : NEW_LINE INDENT return ' AOKI ' NEW_LINE DEDENT if B * C > A * D : NEW_LINE INDENT return ' TAKAHASHI ' NEW_LINE DEDENT return ' DRAW ' NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A , B , C , D = map ( int , input ( ) . split ( ) ) NEW_LINE ans = win_rate ( A , B , C , D ) NEW_LINE print ( ans ) NEW_LINE DEDENT"],"references":["* a , = open ( 0 ) . read ( ) ; s , t = map ( a . count , \" RB \" ) ; print ( [ \" ADORKAIW \" [ s == t : : 2 ] , \" TAKAHASHI \" ] [ s > t ] ) NEW_LINE","N = int ( input ( ) ) NEW_LINE L = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT L . append ( input ( ) ) NEW_LINE DEDENT r = 0 NEW_LINE b = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if L [ i ] [ j ] == ' R ' : NEW_LINE INDENT r += 1 NEW_LINE DEDENT elif L [ i ] [ j ] == ' B ' : NEW_LINE INDENT b += 1 NEW_LINE DEDENT else : NEW_LINE INDENT None NEW_LINE DEDENT DEDENT DEDENT if r > b : NEW_LINE INDENT print ( ' TAKAHASHI ' ) NEW_LINE DEDENT elif r < b : NEW_LINE INDENT print ( ' AOKI ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' DRAW ' ) NEW_LINE DEDENT","def a_paint ( N , S ) : NEW_LINE INDENT takahashi , aoki = 0 , 0 NEW_LINE for row in S : NEW_LINE INDENT for c in row : NEW_LINE INDENT if c == ' R ' : NEW_LINE INDENT takahashi += 1 NEW_LINE DEDENT elif c == ' B ' : NEW_LINE INDENT aoki += 1 NEW_LINE DEDENT DEDENT DEDENT if takahashi > aoki : NEW_LINE INDENT ans = ' TAKAHASHI ' NEW_LINE DEDENT elif takahashi == aoki : NEW_LINE INDENT ans = ' DRAW ' NEW_LINE DEDENT else : NEW_LINE INDENT ans = ' AOKI ' NEW_LINE DEDENT return ans NEW_LINE DEDENT N = int ( input ( ) ) NEW_LINE S = [ input ( ) for _ in [ 0 ] * N ] NEW_LINE print ( a_paint ( N , S ) ) NEW_LINE","from collections import Counter NEW_LINE import sys NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE input = sys . stdin . readline NEW_LINE N = int ( input ( ) ) NEW_LINE L = \" \" NEW_LINE for _ in range ( N ) : NEW_LINE INDENT L += input ( ) NEW_LINE DEDENT C = Counter ( L ) NEW_LINE ans = \" DRAW \" NEW_LINE if C [ ' R ' ] > C [ ' B ' ] : NEW_LINE INDENT ans = \" TAKAHASHI \" NEW_LINE DEDENT elif C [ ' R ' ] < C [ ' B ' ] : NEW_LINE INDENT ans = \" AOKI \" NEW_LINE DEDENT print ( ans ) NEW_LINE","N = int ( input ( ) ) NEW_LINE T = 0 NEW_LINE A = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT S = input ( ) NEW_LINE T += S . count ( ' R ' ) NEW_LINE A += S . count ( ' B ' ) NEW_LINE DEDENT print ( ' TAKAHASHI ' if T > A else ( ' AOKI ' if T < A else ' DRAW ' ) ) NEW_LINE"],"bleu":0.28718218233840753,"rouge_l":0.3905838041431262}
{"id":32,"predictions":["A , B , C , K , D = map ( int , input ( ) . split ( ) ) NEW_LINE print ( min ( A + B , C ) ) NEW_LINE"],"references":["a , b , c , k = map ( int , input ( ) . split ( ) ) NEW_LINE s , t = map ( int , input ( ) . split ( ) ) NEW_LINE total = s + t NEW_LINE discount = 0 NEW_LINE if total >= k : NEW_LINE INDENT discount = total * c NEW_LINE DEDENT adm = ( s * a ) + ( t * b ) NEW_LINE print ( adm - discount ) NEW_LINE","child_price , adult_price , discount_price , discount_min = map ( int , input ( ) . split ( ) ) NEW_LINE child_num , adult_num = map ( int , input ( ) . split ( ) ) NEW_LINE person_sum = child_num + adult_num NEW_LINE print ( child_price * child_num + adult_price * adult_num - ( discount_price * person_sum if person_sum >= discount_min else 0 ) ) NEW_LINE","def zoo ( A : int , B : int , C : int , K : int , S : int , T : int ) -> int : NEW_LINE INDENT total = A * S + B * T NEW_LINE if S + T >= K : NEW_LINE INDENT total -= C * ( S + T ) NEW_LINE DEDENT return total NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A , B , C , K = map ( int , input ( ) . split ( ) ) NEW_LINE S , T = map ( int , input ( ) . split ( ) ) NEW_LINE ans = zoo ( A , B , C , K , S , T ) NEW_LINE print ( ans ) NEW_LINE DEDENT","[ a , b , c , k ] = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE [ s , t ] = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE price = 0 NEW_LINE if s + t >= k : NEW_LINE INDENT price -= ( s + t ) * c NEW_LINE DEDENT price += s * a + t * b NEW_LINE print ( price ) NEW_LINE","m = lambda : map ( int , input ( ) . split ( ) ) NEW_LINE a , b , c , k = m ( ) NEW_LINE s , t = m ( ) NEW_LINE p = a * s + b * t NEW_LINE if ( s + t ) >= k : NEW_LINE INDENT p -= ( s + t ) * c NEW_LINE DEDENT print ( p ) NEW_LINE"],"bleu":0.2938050274183401,"rouge_l":0.4738754542037339}
{"id":33,"predictions":["import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE inf = 10 ** 20 NEW_LINE eps = 1.0 \/ 10 ** 10 NEW_LINE mod = 10 ** 9 + 7 NEW_LINE dd = [ ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) ] NEW_LINE ddn = [ ( - 1 , 0 ) , ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 1 ) , ( 1 , 0 ) , ( 1 , - 1 ) , ( 0 , - 1 ) , ( - 1 , - 1 ) ] NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def F ( ) : return float ( sys . stdin . readline ( ) ) NEW_LINE def S ( ) : return input ( ) NEW_LINE def pf ( s ) : return print ( s , flush = True ) NEW_LINE def main ( ) : NEW_LINE INDENT h , w , n = LI ( ) NEW_LINE x = collections . defaultdict ( int ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT x [ i + 1 ] [ x [ i ] ] = i + 1 NEW_LINE DEDENT dp = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT if x [ i ] > w : NEW_LINE INDENT dp [ x [ i ] ] = x [ i + 1 ] NEW_LINE DEDENT DEDENT return len ( d"],"references":["n , W = map ( int , input ( ) . split ( ) ) NEW_LINE iw , v = map ( int , input ( ) . split ( ) ) NEW_LINE d = { 0 : [ v ] , 1 : [ ] , 2 : [ ] , 3 : [ ] } NEW_LINE for _ in range ( 1 , n ) : NEW_LINE INDENT w , v = map ( int , input ( ) . split ( ) ) NEW_LINE d [ w - iw ] . append ( v ) NEW_LINE DEDENT for i in range ( 4 ) : NEW_LINE INDENT d [ i ] = sorted ( d [ i ] , reverse = True ) NEW_LINE DEDENT ret = - 1 NEW_LINE for i in range ( min ( n , len ( d [ 0 ] ) ) + 1 ) : NEW_LINE INDENT if i * iw > W : NEW_LINE INDENT break NEW_LINE DEDENT for j in range ( min ( n - i , len ( d [ 1 ] ) ) + 1 ) : NEW_LINE INDENT if i * iw + j * ( iw + 1 ) > W : NEW_LINE INDENT break NEW_LINE DEDENT for k in range ( min ( n - ( i + j ) , len ( d [ 2 ] ) ) + 1 ) : NEW_LINE INDENT if i * iw + j * ( iw + 1 ) + k * ( iw + 2 ) > W : NEW_LINE INDENT break NEW_LINE DEDENT for l in range ( min ( n - ( i + j + k ) , len ( d [ 3 ] ) ) + 1 ) : NEW_LINE INDENT if i * iw + j * ( iw + 1 ) + k * ( iw + 2 ) + l * ( iw + 3 ) > W : NEW_LINE INDENT continue NEW_LINE DEDENT V = sum ( d [ 0 ] [ : i ] ) + sum ( d [ 1 ] [ : j ] ) + sum ( d [ 2 ] [ : k ] ) + sum ( d [ 3 ] [ : l ] ) NEW_LINE ret = max ( ret , V ) NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( ret ) NEW_LINE","N , W = [ int ( _ ) for _ in input ( ) . split ( ) ] NEW_LINE WV = [ [ int ( _ ) for _ in input ( ) . split ( ) ] for i in range ( N ) ] NEW_LINE from collections import defaultdict NEW_LINE from itertools import accumulate NEW_LINE cs = defaultdict ( list ) NEW_LINE for w , v in WV : NEW_LINE INDENT cs [ w ] . append ( v ) NEW_LINE DEDENT minw = min ( cs . keys ( ) ) NEW_LINE for k in range ( minw , minw + 4 ) : NEW_LINE INDENT cs [ k ] = [ 0 ] + list ( accumulate ( sorted ( cs [ k ] , reverse = True ) ) ) NEW_LINE DEDENT result = 0 NEW_LINE for w0 , t0 in enumerate ( cs [ minw ] ) : NEW_LINE INDENT for w1 , t1 in enumerate ( cs [ minw + 1 ] ) : NEW_LINE INDENT tw1 = w0 * minw + w1 * ( minw + 1 ) NEW_LINE tv1 = t0 + t1 NEW_LINE if tw1 > W : NEW_LINE INDENT break NEW_LINE DEDENT for w2 , t2 in enumerate ( cs [ minw + 2 ] ) : NEW_LINE INDENT tw2 = tw1 + w2 * ( minw + 2 ) NEW_LINE tv2 = tv1 + t2 NEW_LINE if tw2 > W : NEW_LINE INDENT break NEW_LINE DEDENT for w3 , t3 in enumerate ( cs [ minw + 3 ] ) : NEW_LINE INDENT tw3 = tw2 + w3 * ( minw + 3 ) NEW_LINE tv3 = tv2 + t3 NEW_LINE if tw3 > W : NEW_LINE INDENT break NEW_LINE DEDENT result = max ( result , tv3 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( result ) NEW_LINE","import sys , collections NEW_LINE from collections import defaultdict NEW_LINE def solve ( ) : NEW_LINE INDENT N , W = map ( int , input ( ) . split ( ) ) NEW_LINE DP = [ defaultdict ( lambda : 0 ) for i in range ( N + 1 ) ] NEW_LINE DP [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT w , v = map ( int , input ( ) . split ( ) ) NEW_LINE for DPw in DP [ i ] : NEW_LINE INDENT DPv = DP [ i ] [ DPw ] NEW_LINE DP [ i + 1 ] [ DPw ] = max ( DP [ i + 1 ] [ DPw ] , DPv ) NEW_LINE if DPw + w <= W : NEW_LINE INDENT DP [ i + 1 ] [ DPw + w ] = max ( DP [ i + 1 ] [ DPw + w ] , DPv + v ) NEW_LINE DEDENT DEDENT DEDENT print ( max ( DP [ N ] . values ( ) ) - 1 ) NEW_LINE DEDENT solve ( ) NEW_LINE","def inpl ( ) : return [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE N , W = inpl ( ) NEW_LINE H = { 0 : 0 } NEW_LINE for i in range ( N ) : NEW_LINE INDENT w , v = inpl ( ) NEW_LINE for iw , iv in H . copy ( ) . items ( ) : NEW_LINE INDENT if iw + w <= W : NEW_LINE INDENT H [ iw + w ] = max ( H . get ( iw + w , 0 ) , iv + v ) NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for aw , av in H . items ( ) : NEW_LINE INDENT ans = max ( ans , av ) NEW_LINE DEDENT print ( ans ) NEW_LINE","import array NEW_LINE from bisect import * NEW_LINE from collections import * NEW_LINE import fractions NEW_LINE import heapq NEW_LINE from itertools import * NEW_LINE import math NEW_LINE import random NEW_LINE import re NEW_LINE import string NEW_LINE import sys NEW_LINE N , W = map ( int , input ( ) . split ( ) ) NEW_LINE d = defaultdict ( list ) NEW_LINE w1 = 0 NEW_LINE for n in range ( N ) : NEW_LINE INDENT w , v = map ( int , input ( ) . split ( ) ) NEW_LINE d [ w ] . append ( v ) NEW_LINE if n == 0 : NEW_LINE INDENT w1 = w NEW_LINE DEDENT DEDENT best_ks = { } NEW_LINE for w in range ( w1 , w + 4 ) : NEW_LINE INDENT vs = sorted ( d [ w ] , reverse = True ) NEW_LINE s = 0 NEW_LINE best_k = [ 0 ] NEW_LINE for v in vs : NEW_LINE INDENT s += v NEW_LINE best_k . append ( s ) NEW_LINE DEDENT best_ks [ w ] = best_k NEW_LINE DEDENT ans = 0 NEW_LINE for w1_num in range ( len ( d [ w1 ] ) + 1 ) : NEW_LINE INDENT for w2_num in range ( len ( d [ w1 + 1 ] ) + 1 ) : NEW_LINE INDENT for w3_num in range ( len ( d [ w1 + 2 ] ) + 1 ) : NEW_LINE INDENT for w4_num in range ( len ( d [ w1 + 3 ] ) + 1 ) : NEW_LINE INDENT weight = w1_num * w1 + w2_num * ( w1 + 1 ) + w3_num * ( w1 + 2 ) + w4_num * ( w1 + 3 ) NEW_LINE if weight > W : NEW_LINE INDENT continue NEW_LINE DEDENT value = best_ks [ w1 ] [ w1_num ] + best_ks [ w1 + 1 ] [ w2_num ] + best_ks [ w1 + 2 ] [ w3_num ] + best_ks [ w1 + 3 ] [ w4_num ] NEW_LINE ans = max ( ans , value ) NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( ans ) NEW_LINE"],"bleu":0.2410062725312858,"rouge_l":0.36639247465081237}
{"id":34,"predictions":["import sys NEW_LINE input = sys . stdin . readline NEW_LINE inf = 10 ** 18 NEW_LINE N , M = map ( int , input ( ) . split ( ) ) NEW_LINE AB = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] NEW_LINE net = [ [ False ] * N for _ in range ( N ) ] NEW_LINE for Ai , Bi in AB : NEW_LINE INDENT net [ Ai - 1 ] [ Bi - 1 ] = True NEW_LINE net [ Bi - 1 ] [ Ai - 1 ] = True NEW_LINE DEDENT for p in range ( N ) : NEW_LINE INDENT net2 = [ False ] * N NEW_LINE for q in filter ( lambda x : net [ x ] [ x ] , range ( N ) ) : NEW_LINE INDENT if q == p : continue NEW_LINE for r in filter ( lambda x : net [ q ] , range ( N ) ) : NEW_LINE INDENT if r == p : continue NEW_LINE if net [ p ] [ r ] : continue NEW_LINE if r == p : continue NEW_LINE if net [ p ] [ r ] : continue NEW_LINE ret = True NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( ' Yes ' if net2 else ' No ' ) NEW_LINE"],"references":["def inpl ( ) : return [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE def find ( x ) : NEW_LINE INDENT if par [ x ] == x : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT par [ x ] , dist [ x ] = find ( par [ x ] ) , dist [ x ] + dist [ par [ x ] ] NEW_LINE return par [ x ] NEW_LINE DEDENT DEDENT N , M = inpl ( ) NEW_LINE par = list ( range ( N + 1 ) ) NEW_LINE dist = [ 0 for _ in range ( N + 1 ) ] NEW_LINE for _ in range ( M ) : NEW_LINE INDENT l , r , d = inpl ( ) NEW_LINE fl = find ( l ) NEW_LINE fr = find ( r ) NEW_LINE if fl != fr : NEW_LINE INDENT par [ fr ] = fl NEW_LINE dist [ fr ] = d + dist [ l ] - dist [ r ] NEW_LINE DEDENT elif d + dist [ l ] - dist [ r ] != 0 : NEW_LINE INDENT print ( ' No ' ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT","import itertools NEW_LINE import math NEW_LINE from collections import deque NEW_LINE from collections import defaultdict NEW_LINE from itertools import permutations NEW_LINE import heapq NEW_LINE import bisect NEW_LINE from scipy . sparse . csgraph import floyd_warshall as wf NEW_LINE INF = float ( \" inf \" ) NEW_LINE N , M = map ( int , input ( ) . split ( ) ) NEW_LINE Adj_list = defaultdict ( set ) NEW_LINE for i in range ( M ) : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE Adj_list [ a - 1 ] . add ( ( b - 1 , c ) ) NEW_LINE Adj_list [ b - 1 ] . add ( ( a - 1 , - c ) ) NEW_LINE DEDENT visited = [ None ] * ( N ) NEW_LINE ok = True NEW_LINE stack = [ ] NEW_LINE for x in range ( N ) : NEW_LINE INDENT if visited [ x ] is not None : continue NEW_LINE visited [ x ] = 0 NEW_LINE stack = [ x ] NEW_LINE while stack : NEW_LINE INDENT v = stack . pop ( ) NEW_LINE for to , d in Adj_list [ v ] : NEW_LINE INDENT if visited [ to ] is None : NEW_LINE INDENT visited [ to ] = visited [ v ] + d NEW_LINE stack . append ( to ) NEW_LINE DEDENT else : NEW_LINE INDENT if visited [ to ] != visited [ v ] + d : NEW_LINE INDENT ok = False NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT if ok == False : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( \" Yes \" if ok else \" No \" ) NEW_LINE","import sys NEW_LINE sys . setrecursionlimit ( 10 ** 5 ) NEW_LINE N , M = map ( int , input ( ) . split ( ) ) NEW_LINE input = sys . stdin . readline NEW_LINE LRD = [ [ int ( j ) for j in input ( ) . split ( ) ] for _ in range ( M ) ] NEW_LINE data = [ x for x in range ( N + 1 ) ] NEW_LINE rank = [ 0 ] * ( N + 1 ) NEW_LINE diff_weight = [ 0 ] * ( N + 1 ) NEW_LINE def root ( x ) : NEW_LINE INDENT if data [ x ] == x : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT r = root ( data [ x ] ) NEW_LINE diff_weight [ x ] += diff_weight [ data [ x ] ] NEW_LINE data [ x ] = r NEW_LINE return r NEW_LINE DEDENT DEDENT def weight ( x ) : NEW_LINE INDENT return diff_weight [ x ] NEW_LINE DEDENT def diff ( x , y ) : NEW_LINE INDENT return weight ( y ) - weight ( x ) NEW_LINE DEDENT def merge ( x , y , w ) : NEW_LINE INDENT w += weight ( x ) ; w -= weight ( y ) NEW_LINE x = root ( x ) NEW_LINE y = root ( y ) NEW_LINE if x == y : return False NEW_LINE if rank [ x ] < rank [ y ] : x , y = y , x ; w = - w NEW_LINE if rank [ x ] == rank [ y ] : rank [ x ] += 1 NEW_LINE data [ y ] = x NEW_LINE diff_weight [ y ] = w NEW_LINE return True NEW_LINE DEDENT def issame ( x , y ) : NEW_LINE INDENT return root ( x ) == root ( y ) NEW_LINE DEDENT for i in range ( M ) : NEW_LINE INDENT L , R , D = LRD [ i ] NEW_LINE if not issame ( L , R ) : NEW_LINE INDENT _ = merge ( L , R , D ) NEW_LINE DEDENT else : NEW_LINE INDENT if diff ( L , R ) != D : NEW_LINE INDENT print ( \" No \" ) NEW_LINE exit ( 0 ) NEW_LINE DEDENT DEDENT DEDENT print ( \" Yes \" ) NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) NEW_LINE lrds = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] NEW_LINE xs = [ None for _ in range ( n ) ] NEW_LINE ps = [ [ ] for _ in range ( n ) ] NEW_LINE for lrd in lrds : NEW_LINE INDENT l , r , d = lrd NEW_LINE ps [ l - 1 ] . append ( ( r - 1 , d ) ) NEW_LINE ps [ r - 1 ] . append ( ( l - 1 , - d ) ) NEW_LINE DEDENT not_decided = set ( range ( n ) ) NEW_LINE def solve ( ) : NEW_LINE INDENT while len ( not_decided ) != 0 : NEW_LINE INDENT t = not_decided . pop ( ) NEW_LINE xs [ t ] = 0 NEW_LINE stack = [ t ] NEW_LINE while len ( stack ) != 0 : NEW_LINE INDENT c = stack . pop ( ) NEW_LINE for p in ps [ c ] : NEW_LINE INDENT another , relative_position = p NEW_LINE if another in not_decided : NEW_LINE INDENT xs [ another ] = xs [ c ] + relative_position NEW_LINE not_decided . remove ( another ) NEW_LINE stack . append ( another ) NEW_LINE DEDENT else : NEW_LINE INDENT if xs [ another ] != xs [ c ] + relative_position : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return True NEW_LINE DEDENT if solve ( ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT","N , M = [ int ( _ ) for _ in input ( ) . split ( ) ] NEW_LINE LRD = [ [ int ( _ ) for _ in input ( ) . split ( ) ] for _ in range ( M ) ] NEW_LINE G = { } NEW_LINE for l , r , d in LRD : NEW_LINE INDENT l -= 1 NEW_LINE r -= 1 NEW_LINE G [ l ] = G . get ( l , { } ) NEW_LINE G [ r ] = G . get ( r , { } ) NEW_LINE G [ l ] [ r ] = d NEW_LINE G [ r ] [ l ] = - d NEW_LINE DEDENT INF = float ( ' inf ' ) NEW_LINE D = [ INF ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT if i in G and D [ i ] == INF : NEW_LINE INDENT D [ i ] = 0 NEW_LINE table = [ ] NEW_LINE while True : NEW_LINE INDENT for k , v in G [ i ] . items ( ) : NEW_LINE INDENT if D [ k ] == INF : NEW_LINE INDENT table += [ k ] NEW_LINE D [ k ] = D [ i ] + v NEW_LINE DEDENT elif D [ k ] != D [ i ] + v : NEW_LINE INDENT print ( ' No ' ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT if table : NEW_LINE INDENT i = table . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( ' Yes ' ) NEW_LINE"],"bleu":0.4758508510866134,"rouge_l":0.45378801404511104}
{"id":35,"predictions":["a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE if a == b : NEW_LINE INDENT print ( int ( c ) ) NEW_LINE DEDENT elif b == c : NEW_LINE INDENT print ( int ( a ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( int ( b ) ) NEW_LINE DEDENT"],"references":["A , B , C = map ( int , input ( ) . split ( ) ) NEW_LINE if A == B : NEW_LINE INDENT print ( C ) NEW_LINE DEDENT elif A == C : NEW_LINE INDENT print ( B ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( A ) NEW_LINE DEDENT","a = [ int ( i ) for i in input ( ) . split ( ' ▁ ' ) ] NEW_LINE a . sort ( ) NEW_LINE print ( sum ( a ) - 2 * a [ 1 ] ) NEW_LINE","a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT if a . count ( a [ i ] ) == 1 : NEW_LINE INDENT print ( a [ i ] ) NEW_LINE DEDENT DEDENT","A , B , C = input ( ) . split ( ) NEW_LINE print ( A if B == C else B if C == A else C ) NEW_LINE","n = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if n [ 2 ] != n [ 0 ] != n [ 1 ] : print ( n [ 0 ] ) NEW_LINE if n [ 0 ] != n [ 1 ] != n [ 2 ] : print ( n [ 1 ] ) NEW_LINE if n [ 1 ] != n [ 2 ] != n [ 0 ] : print ( n [ 2 ] ) NEW_LINE"],"bleu":0.5562568212766869,"rouge_l":0.766759776536313}
{"id":36,"predictions":["h , m = map ( float , input ( ) . split ( ) ) NEW_LINE def solve ( ) : NEW_LINE INDENT if h >= 12 : NEW_LINE INDENT if m <= 100 : NEW_LINE INDENT return True NEW_LINE DEDENT elif h >= 12 : NEW_LINE INDENT return False NEW_LINE DEDENT elif h >= 12 : NEW_LINE INDENT m = 60 + h NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N , M = map ( int , input ( ) . split ( ) ) NEW_LINE solve ( N , M ) NEW_LINE DEDENT main ( ) NEW_LINE"],"references":["y = int ( input ( ) ) NEW_LINE m = int ( input ( ) ) NEW_LINE d = int ( input ( ) ) NEW_LINE def f ( x ) : NEW_LINE INDENT return int ( x \/\/ 1 ) NEW_LINE DEDENT def F ( y , m , d ) : NEW_LINE INDENT if m == 1 or m == 2 : NEW_LINE INDENT y -= 1 NEW_LINE m += 12 NEW_LINE DEDENT return int ( 365 * y + f ( y \/ 4 ) - f ( y \/ 100 ) + f ( y \/ 400 ) + f ( 306 * ( m + 1 ) \/ 10 ) + d - 429 ) NEW_LINE DEDENT print ( F ( 2014 , 5 , 17 ) - F ( y , m , d ) ) NEW_LINE","from datetime import date , timedelta NEW_LINE x = [ ] NEW_LINE ans = 0 NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT x . append ( int ( input ( ) ) ) NEW_LINE DEDENT dt = date ( year = x [ 0 ] , month = x [ 1 ] , day = x [ 2 ] ) NEW_LINE q = 1 NEW_LINE while q : NEW_LINE INDENT if dt . year != 2014 or dt . month != 5 or dt . day != 17 : NEW_LINE INDENT dt += timedelta ( days = 1 ) NEW_LINE ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE","import sys NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE input = sys . stdin . readline NEW_LINE def ceil ( x ) : NEW_LINE INDENT return ( - x ) \/\/ 1 * ( - 1 ) NEW_LINE DEDENT def calc ( y , m , d ) : NEW_LINE INDENT return 365 * y + y \/\/ 4 - y \/\/ 100 + y \/\/ 400 + ( 306 * ( m + 1 ) ) \/\/ 10 + d - 429 NEW_LINE DEDENT y = int ( input ( ) ) NEW_LINE m = int ( input ( ) ) NEW_LINE d = int ( input ( ) ) NEW_LINE if m == 1 : NEW_LINE INDENT m = 13 NEW_LINE y -= 1 NEW_LINE DEDENT elif m == 2 : NEW_LINE INDENT m = 14 NEW_LINE y -= 1 NEW_LINE DEDENT de = calc ( 2014 , 5 , 17 ) NEW_LINE print ( de - calc ( y , m , d ) ) NEW_LINE","from datetime import * ; print ( ( date ( 2014 , 5 , 17 ) - date ( * map ( int , open ( 0 ) ) ) ) . days ) NEW_LINE","import math NEW_LINE y = int ( input ( ) ) NEW_LINE m = int ( input ( ) ) NEW_LINE d = int ( input ( ) ) NEW_LINE A = 365 * 2014 + math . floor ( 2014 \/ 4 ) - math . floor ( 2014 \/ 100 ) + math . floor ( 2014 \/ 400 ) + math . floor ( 306 * 6 \/ 10 ) + 17 - 429 NEW_LINE if m == 1 or m == 2 : NEW_LINE INDENT y -= 1 NEW_LINE m += 12 NEW_LINE B = 365 * y + math . floor ( y \/ 4 ) - math . floor ( y \/ 100 ) + math . floor ( y \/ 400 ) + math . floor ( 306 * ( m + 1 ) \/ 10 ) + d - 429 NEW_LINE DEDENT else : NEW_LINE INDENT B = 365 * y + math . floor ( y \/ 4 ) - math . floor ( y \/ 100 ) + math . floor ( y \/ 400 ) + math . floor ( 306 * ( m + 1 ) \/ 10 ) + d - 429 NEW_LINE DEDENT print ( A - B ) NEW_LINE"],"bleu":0.28171357458950114,"rouge_l":0.412340341913932}
{"id":37,"predictions":["N , K = map ( int , input ( ) . split ( ) ) NEW_LINE D = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE kazu = [ 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 , 0 ] NEW_LINE for item in D : NEW_LINE INDENT kazu . remove ( item ) NEW_LINE DEDENT p = [ ] NEW_LINE m = len ( str ( N ) ) NEW_LINE for j in range ( m ) : NEW_LINE INDENT p . append ( kazu [ j ] * ( 10 ** i ) ) NEW_LINE DEDENT p . sort ( reverse = True ) NEW_LINE j = 0 NEW_LINE while j < m : NEW_LINE INDENT for i in range ( 1 , len ( kazu ) ) : NEW_LINE INDENT if sum ( p ) - p [ i ] + kazu [ i ] * ( 10 ** ( m - j - 1 ) ) >= K : NEW_LINE INDENT p [ j ] = kazu [ i ] * ( 10 ** ( m - j - 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT j += 1 NEW_LINE DEDENT print ( sum ( p ) ) NEW_LINE"],"references":["f = lambda x : sum ( map ( int , str ( x ) ) ) NEW_LINE ans = [ ] NEW_LINE def check ( x ) : NEW_LINE INDENT y = f ( x ) NEW_LINE while ans : NEW_LINE INDENT p = ans [ - 1 ] NEW_LINE if p * y > x * f ( p ) : ans . pop ( - 1 ) NEW_LINE else : break NEW_LINE DEDENT ans . append ( x ) NEW_LINE DEDENT k = int ( input ( ) ) NEW_LINE for i in range ( 1 , 100 ) : NEW_LINE INDENT check ( i ) NEW_LINE DEDENT a , b = 0 , 1 NEW_LINE while a < 1e12 : NEW_LINE INDENT for i in range ( 100 , 1000 ) : NEW_LINE INDENT check ( i * b + a ) NEW_LINE DEDENT a = a * 10 + 9 NEW_LINE b *= 10 NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT print ( ans [ i ] ) NEW_LINE DEDENT","def digit_sum ( num ) : NEW_LINE INDENT ds = 0 NEW_LINE while num > 0 : NEW_LINE INDENT ds += num % 10 NEW_LINE num \/\/= 10 NEW_LINE DEDENT return ds NEW_LINE DEDENT K = int ( input ( ) ) NEW_LINE candidates = [ ] NEW_LINE digit_sums = [ ] NEW_LINE for i in range ( 15 ) : NEW_LINE INDENT base = 10 ** i NEW_LINE for j in range ( 1 , 150 ) : NEW_LINE INDENT candidate = j * base + ( base - 1 ) NEW_LINE candidates . append ( candidate ) NEW_LINE DEDENT DEDENT candidates = sorted ( list ( set ( candidates ) ) ) NEW_LINE digit_sums = [ digit_sum ( candidate ) for candidate in candidates ] NEW_LINE snuke_nums = [ ] NEW_LINE smaller_as_snuke = lambda n , m , ds_n , ds_m : True if n * ds_m <= m * ds_n else False NEW_LINE for i , candidate in enumerate ( candidates ) : NEW_LINE INDENT ds_cand = digit_sums [ i ] NEW_LINE for j in range ( i + 1 , len ( candidates ) ) : NEW_LINE INDENT other_num = candidates [ j ] NEW_LINE ds_other = digit_sums [ j ] NEW_LINE if not smaller_as_snuke ( candidate , other_num , ds_cand , ds_other ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT snuke_nums . append ( candidate ) NEW_LINE DEDENT DEDENT for snuke_num in snuke_nums [ : K ] : NEW_LINE INDENT print ( snuke_num ) NEW_LINE DEDENT","import sys NEW_LINE stdin = sys . stdin NEW_LINE sys . setrecursionlimit ( 10 ** 5 ) NEW_LINE def li ( ) : return map ( int , stdin . readline ( ) . split ( ) ) NEW_LINE def li_ ( ) : return map ( lambda x : int ( x ) - 1 , stdin . readline ( ) . split ( ) ) NEW_LINE def lf ( ) : return map ( float , stdin . readline ( ) . split ( ) ) NEW_LINE def ls ( ) : return stdin . readline ( ) . split ( ) NEW_LINE def ns ( ) : return stdin . readline ( ) . rstrip ( ) NEW_LINE def lc ( ) : return list ( ns ( ) ) NEW_LINE def ni ( ) : return int ( stdin . readline ( ) ) NEW_LINE def nf ( ) : return float ( stdin . readline ( ) ) NEW_LINE def digit_sum ( num : int , base : int ) -> int : NEW_LINE INDENT if num < base : NEW_LINE INDENT return num NEW_LINE DEDENT else : NEW_LINE INDENT return digit_sum ( int ( num \/ base ) , base ) + ( num % base ) NEW_LINE DEDENT DEDENT def snuke ( num : int ) : NEW_LINE INDENT return num \/ digit_sum ( num , 10 ) NEW_LINE DEDENT k = ni ( ) NEW_LINE snuke_nums = [ i for i in range ( 1 , 10 ) ] NEW_LINE res = 9 NEW_LINE cur = 9 NEW_LINE if k <= res : NEW_LINE INDENT for s in snuke_nums [ : k ] : NEW_LINE INDENT print ( s ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT while res != k : NEW_LINE INDENT cur += 1 NEW_LINE cands = [ ] NEW_LINE for i in range ( len ( str ( cur ) ) ) : NEW_LINE INDENT cands . append ( int ( str ( cur ) [ : - i - 1 ] + \"9\" * ( i + 1 ) ) ) NEW_LINE DEDENT mi = float ( \" inf \" ) NEW_LINE for c in cands : NEW_LINE INDENT if snuke ( c ) < mi : NEW_LINE INDENT cur = c NEW_LINE mi = snuke ( c ) NEW_LINE DEDENT DEDENT snuke_nums . append ( cur ) NEW_LINE res += 1 NEW_LINE DEDENT for s in snuke_nums : NEW_LINE INDENT print ( s ) NEW_LINE DEDENT DEDENT","k = int ( input ( ) ) NEW_LINE n = 1 NEW_LINE t = 1 NEW_LINE l = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT print ( n ) NEW_LINE if int ( n \/ t ) % 10 == 9 : NEW_LINE INDENT if n + t <= ( 9 * l + int ( ( n + t ) \/ ( t * 10 ) ) % 10 + int ( ( n + t ) \/ ( t * 100 ) ) % 100 + int ( ( n + t ) \/ ( t * 1000 ) ) % 1000 ) * t : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT t *= 10 NEW_LINE l += 1 NEW_LINE DEDENT DEDENT n += t NEW_LINE DEDENT","def ss ( n ) : NEW_LINE INDENT return n \/ s ( n ) NEW_LINE DEDENT def s ( n ) : NEW_LINE INDENT return sum ( [ int ( a ) for a in str ( n ) ] ) NEW_LINE DEDENT K = int ( input ( ) ) NEW_LINE n = 0 NEW_LINE d = 1 NEW_LINE while K > 0 : NEW_LINE INDENT t1 = ss ( n + d ) NEW_LINE t2 = ss ( n + 10 * d ) NEW_LINE if t1 > t2 : NEW_LINE INDENT d *= 10 NEW_LINE DEDENT n += d NEW_LINE print ( n ) NEW_LINE K -= 1 NEW_LINE DEDENT"],"bleu":0.39480173831218196,"rouge_l":0.4566603134265142}
{"id":38,"predictions":["import numpy as np NEW_LINE N = int ( input ( ) ) NEW_LINE s = np . array ( [ [ c for c in input ( ) ] for _ in range ( N ) ] ) NEW_LINE s = np . rot90 ( s , k = - 1 ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT print ( \" \" . join ( s [ i ] ) ) NEW_LINE DEDENT"],"references":["def solve ( ) : NEW_LINE INDENT s = input ( ) NEW_LINE n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT l , r = ( int ( i ) for i in input ( ) . split ( ) ) NEW_LINE tmp = s [ l - 1 : r ] NEW_LINE s = s [ 0 : l - 1 ] + tmp [ : : - 1 ] + s [ r : : ] NEW_LINE DEDENT print ( s ) NEW_LINE DEDENT solve ( ) NEW_LINE","hoge = list ( input ( ) ) NEW_LINE n = int ( input ( ) ) NEW_LINE kari = \" \" NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE huga = hoge [ a - 1 : b ] NEW_LINE huga = huga [ : : - 1 ] NEW_LINE hoge [ a - 1 : b ] = huga NEW_LINE DEDENT for i in range ( len ( hoge ) ) : NEW_LINE INDENT print ( hoge [ i ] , end = \" \" ) NEW_LINE DEDENT print ( \" \" ) NEW_LINE","s = [ i for i in input ( ) ] NEW_LINE n = int ( input ( ) ) NEW_LINE for _ in range ( n ) : NEW_LINE INDENT r , l = map ( int , input ( ) . split ( ) ) NEW_LINE r , l = r - 1 , l - 1 NEW_LINE for i in range ( ( l - r + 1 ) \/\/ 2 ) : NEW_LINE INDENT s [ r + i ] , s [ l - i ] = s [ l - i ] , s [ r + i ] NEW_LINE DEDENT DEDENT ans = \" \" NEW_LINE for i in s : NEW_LINE INDENT ans += i NEW_LINE DEDENT print ( ans ) NEW_LINE","from statistics import mean , median , variance , stdev NEW_LINE import numpy as np NEW_LINE import sys NEW_LINE import math NEW_LINE import fractions NEW_LINE import itertools NEW_LINE import copy NEW_LINE import collections NEW_LINE from operator import itemgetter NEW_LINE def j ( q ) : NEW_LINE INDENT if q == 1 : print ( \" Yay ! \" ) NEW_LINE else : print ( \" : ( \" ) NEW_LINE exit ( 0 ) NEW_LINE DEDENT def ct ( x , y ) : NEW_LINE INDENT if ( x > y ) : print ( \" + \" ) NEW_LINE elif ( x < y ) : print ( \" - \" ) NEW_LINE else : print ( \" ? \" ) NEW_LINE DEDENT def ip ( ) : NEW_LINE INDENT return int ( input ( ) ) NEW_LINE DEDENT def printrow ( a ) : NEW_LINE INDENT for i in range ( len ( a ) ) : NEW_LINE INDENT print ( a [ i ] ) NEW_LINE DEDENT DEDENT def combinations ( n , r ) : NEW_LINE INDENT if n < r : return 0 NEW_LINE return math . factorial ( n ) \/\/ ( math . factorial ( n - r ) * math . factorial ( r ) ) NEW_LINE DEDENT def permutations ( n , r ) : NEW_LINE INDENT if n < r : return 0 NEW_LINE return math . factorial ( n ) \/\/ math . factorial ( n - r ) NEW_LINE DEDENT c = input ( ) NEW_LINE n = ip ( ) NEW_LINE a = [ i for i in range ( len ( c ) + 1 ) ] NEW_LINE for loop in range ( n ) : NEW_LINE INDENT x , y = ( int ( i ) for i in input ( ) . split ( ) ) NEW_LINE while x < y : NEW_LINE INDENT temp = copy . copy ( a [ x ] ) NEW_LINE a [ x ] = copy . copy ( a [ y ] ) NEW_LINE a [ y ] = copy . copy ( temp ) NEW_LINE x += 1 NEW_LINE y -= 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , len ( c ) + 1 ) : NEW_LINE INDENT print ( c [ a [ i ] - 1 ] , end = ' ' ) NEW_LINE DEDENT print ( ) NEW_LINE","str = input ( ) NEW_LINE n = int ( input ( ) ) NEW_LINE lr = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT lr . append ( input ( ) . split ( \" ▁ \" ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT lr [ i ] [ 0 ] = int ( lr [ i ] [ 0 ] ) NEW_LINE lr [ i ] [ 1 ] = int ( lr [ i ] [ 1 ] ) NEW_LINE DEDENT num = [ ] NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT num . append ( int ( i ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( 1 + ( lr [ i ] [ 1 ] - lr [ i ] [ 0 ] ) \/\/ 2 ) : NEW_LINE INDENT num [ lr [ i ] [ 0 ] - 1 + j ] , num [ lr [ i ] [ 1 ] - 1 - j ] = num [ lr [ i ] [ 1 ] - 1 - j ] , num [ lr [ i ] [ 0 ] - 1 + j ] NEW_LINE DEDENT DEDENT for i in num : NEW_LINE INDENT print ( str [ i ] , end = \" \" ) NEW_LINE DEDENT print ( \" \" ) NEW_LINE"],"bleu":0.3824641059066588,"rouge_l":0.4415360596905983}
{"id":39,"predictions":["a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a < 0 : NEW_LINE INDENT print ( a - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a - 1 ) NEW_LINE DEDENT"],"references":["a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a - b > 0 : NEW_LINE INDENT print ( a - b ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT","import sys NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE input = sys . stdin . readline NEW_LINE def ii ( ) : return int ( input ( ) ) NEW_LINE def mi ( ) : return map ( int , input ( ) . rstrip ( ) . split ( ) ) NEW_LINE def lmi ( ) : return list ( map ( int , input ( ) . rstrip ( ) . split ( ) ) ) NEW_LINE def li ( ) : return list ( input ( ) . rstrip ( ) ) NEW_LINE X , t = mi ( ) NEW_LINE print ( max ( X - t , 0 ) ) NEW_LINE","x , t = [ int ( n ) for n in input ( ) . split ( ) ] NEW_LINE print ( x - t if x >= t else 0 ) NEW_LINE","[ X , t ] = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( max ( 0 , X - t ) ) NEW_LINE","x , t = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE ans = x - t NEW_LINE if ans > 0 : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT"],"bleu":0.785195249746208,"rouge_l":0.8863636363636364}
{"id":40,"predictions":["import math , sys , bisect , heapq , osfrom collections import defaultdict , Counter , dequefrom itertools import groupby , accumulatefrom functools import lru_cache NEW_LINE"],"references":["import math NEW_LINE q = int ( input ( ) ) NEW_LINE for j in range ( q ) : NEW_LINE INDENT AB = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE AB . sort ( ) NEW_LINE ab = AB [ 0 ] * AB [ 1 ] NEW_LINE for i in range ( int ( math . sqrt ( ab ) ) , AB [ 1 ] + 1 ) : NEW_LINE INDENT if i * i >= ab : NEW_LINE INDENT x = i - 1 NEW_LINE break NEW_LINE DEDENT DEDENT if x == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE continue NEW_LINE DEDENT for i in range ( int ( ab \/ x ) , ab + 1 ) : NEW_LINE INDENT if x * i >= ab : NEW_LINE INDENT y = i - 1 NEW_LINE break NEW_LINE DEDENT DEDENT cnt1 = 2 * x NEW_LINE cnts = 1 if x == y else 0 NEW_LINE cntdd = 1 if x - AB [ 0 ] >= 0 else 0 NEW_LINE cntdu = 1 if AB [ 1 ] - y >= 0 and ( AB [ 1 ] + 1 ) * ( x - AB [ 1 ] + y ) >= ab else 0 NEW_LINE print ( cnt1 - cnts - cntdd - cntdu ) NEW_LINE DEDENT","from math import sqrt NEW_LINE Q = int ( input ( ) ) NEW_LINE table = [ ] NEW_LINE for i in range ( Q ) : NEW_LINE INDENT A , B = map ( int , input ( ) . split ( ) ) NEW_LINE if A > B : NEW_LINE INDENT table . append ( [ B , A ] ) NEW_LINE DEDENT else : NEW_LINE INDENT table . append ( [ A , B ] ) NEW_LINE DEDENT DEDENT def f ( a , b ) : NEW_LINE INDENT if a == b : NEW_LINE INDENT return 2 * a - 2 NEW_LINE DEDENT if a + 1 == b : NEW_LINE INDENT return 2 * a - 2 NEW_LINE DEDENT m = int ( sqrt ( a * b ) ) NEW_LINE if m ** 2 == a * b : NEW_LINE INDENT return 2 * m - 3 NEW_LINE DEDENT if m * ( m + 1 ) >= a * b : NEW_LINE INDENT return 2 * m - 2 NEW_LINE DEDENT return 2 * m - 1 NEW_LINE DEDENT ans = [ ] NEW_LINE for a , b in table : NEW_LINE INDENT ans . append ( f ( a , b ) ) NEW_LINE DEDENT print ( ' \\n ' . join ( map ( str , ans ) ) ) NEW_LINE","def inpl ( ) : return [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE Q = int ( input ( ) ) NEW_LINE for _ in range ( Q ) : NEW_LINE INDENT A , B = sorted ( inpl ( ) ) NEW_LINE c = int ( - ( - ( A * B ) ** 0.5 \/\/ 1 ) - 1 ) NEW_LINE ans = A - 1 + max ( 0 , c - A ) + ( - ( ( - A * B ) \/\/ ( c + 1 ) ) - 1 ) NEW_LINE print ( ans ) NEW_LINE DEDENT","import math NEW_LINE n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE a , b = map ( int , input ( ) . split ( ) ) NEW_LINE c = a * b NEW_LINE d = int ( math . sqrt ( c ) ) NEW_LINE if d * d == c : NEW_LINE INDENT d -= 1 NEW_LINE DEDENT ans += d * 2 NEW_LINE if d >= a : NEW_LINE INDENT ans -= 1 NEW_LINE DEDENT if d >= b : NEW_LINE INDENT ans -= 1 NEW_LINE DEDENT if ( d * ( d + 1 ) ) >= c : NEW_LINE INDENT ans -= 1 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT","from math import sqrt NEW_LINE def func ( a , b ) : NEW_LINE INDENT if a == b : NEW_LINE INDENT return ( a - 1 ) * 2 NEW_LINE DEDENT else : NEW_LINE INDENT sq = int ( sqrt ( a * b ) ) NEW_LINE if a * b == sq ** 2 : NEW_LINE INDENT return ( sq - 1 ) * 2 - 1 NEW_LINE DEDENT elif sq * ( sq + 1 ) > a * b : NEW_LINE INDENT return ( sq - 1 ) * 2 NEW_LINE DEDENT elif sq * ( sq + 1 ) == a * b : NEW_LINE INDENT if abs ( a - b ) == 1 : NEW_LINE INDENT return ( sq - 1 ) * 2 NEW_LINE DEDENT else : NEW_LINE INDENT return ( sq - 1 ) * 2 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return sq * 2 - 1 NEW_LINE DEDENT DEDENT DEDENT q = int ( input ( ) ) NEW_LINE for _ in range ( q ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( func ( a , b ) ) NEW_LINE DEDENT"],"bleu":0.002772427262176266,"rouge_l":0.06147816349384098}
{"id":41,"predictions":["H , W , K = map ( int , input ( ) . split ( ) ) NEW_LINE MOD = int ( 1e9 + 7 ) NEW_LINE dp = [ [ 0 for _ in range ( W ) ] for _ in range ( N + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , H + 1 ) : NEW_LINE INDENT dp [ i ] [ 1 ] = ( dp [ i ] [ 0 ] * W + dp [ i - 1 ] [ 1 ] * W + dp [ i ] [ 1 ] * W + dp [ i - 1 ] [ 2 ] * W NEW_LINE dp [ i ] [ 1 ] = ( dp [ i - 1 ] [ 0 ] * W + dp [ i - 1 ] [ 2 ] * W + dp [ i - 1 ] [ 0 ] * W ) % MOD NEW_LINE dp [ i ] [ i ] = ( dp [ i - 1 ] [ 0 ] * W + dp [ i - 1 ] [ 2 ] * W + dp [ i - 1 ] [ 1 ] * W + dp [ i - 1 ] [ 1 ] * W + MOD ) % MOD NEW_LINE DEDENT print ( dp [ - 1 ] [ W ] * dp [ - 1 ] [ W ] ) % MOD NEW_LINE"],"references":["H , W , A , B = map ( int , input ( ) . split ( ) ) NEW_LINE P = 10 ** 9 + 7 NEW_LINE N = H + W NEW_LINE def fact ( N , P ) : NEW_LINE INDENT ret = [ 1 ] * ( N + 1 ) NEW_LINE for n in range ( 2 , N + 1 ) : NEW_LINE INDENT ret [ n ] = ( ret [ n - 1 ] * n ) % P NEW_LINE DEDENT return ret NEW_LINE DEDENT def pow_r ( a , b , P ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if b % 2 == 0 : NEW_LINE INDENT return pow_r ( ( a ** 2 ) % P , b \/\/ 2 , P ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( a * pow_r ( ( a ** 2 ) % P , ( b - 1 ) \/\/ 2 , P ) ) % P NEW_LINE DEDENT DEDENT def inv_fact ( N , P ) : NEW_LINE INDENT ret = [ 1 ] * ( N + 1 ) NEW_LINE fac = fact ( N , P ) NEW_LINE ret [ N ] = pow_r ( fac [ N ] , P - 2 , P ) NEW_LINE for n in reversed ( range ( 2 , N ) ) : NEW_LINE INDENT ret [ n ] = ( ret [ n + 1 ] * ( n + 1 ) ) % P NEW_LINE DEDENT return ret NEW_LINE DEDENT fac = fact ( N , P ) NEW_LINE inv = inv_fact ( N , P ) NEW_LINE def combination ( n , r , P ) : NEW_LINE INDENT return ( fac [ n ] * inv [ r ] * inv [ n - r ] ) % P NEW_LINE DEDENT sub = 0 NEW_LINE for a in range ( A ) : NEW_LINE INDENT sub = ( sub + combination ( ( H - 1 - a ) + ( B - 1 ) , B - 1 , P ) * combination ( a + ( W - 1 - B ) , a , P ) ) % P NEW_LINE DEDENT print ( ( combination ( ( H - 1 ) + ( W - 1 ) , H - 1 , P ) - sub ) % P ) NEW_LINE","MOD = 1000000007 NEW_LINE H , W , A , B = map ( int , input ( ) . split ( ) ) NEW_LINE if H - A > W - B : NEW_LINE INDENT H , W = W , H NEW_LINE A , B = B , A NEW_LINE DEDENT ans1 = [ 1 ] NEW_LINE for i in range ( H - A - 1 ) : NEW_LINE INDENT ans1 . append ( ( ans1 [ - 1 ] * ( H - A - 1 + B - i ) * pow ( i + 1 , MOD - 2 , MOD ) ) % MOD ) NEW_LINE DEDENT c = 1 NEW_LINE for i in range ( W - H + A - B ) : NEW_LINE INDENT c = ( c * ( W - B - 1 + A - i ) * pow ( i + 1 , MOD - 2 , MOD ) ) % MOD NEW_LINE DEDENT ans = c NEW_LINE for i in range ( H - A - 1 ) : NEW_LINE INDENT c = ( c * ( H - 1 - i ) * pow ( W - H + A - B + 1 + i , MOD - 2 , MOD ) ) % MOD NEW_LINE ans = ( ans + c * ans1 [ i + 1 ] ) % MOD NEW_LINE DEDENT print ( ans ) NEW_LINE","class BigCombination ( object ) : NEW_LINE INDENT __slots__ = [ \" mod \" , \" inverse _ mod \" , \" factorial \" , \" inverse _ memo \" ] NEW_LINE def __init__ ( self , mod : int = 10 ** 9 + 7 , max_n : int = 10 ** 6 ) : NEW_LINE INDENT from itertools import accumulate NEW_LINE self . mod = mod NEW_LINE self . inverse_mod = tuple ( map ( int , bin ( mod - 2 ) [ : 1 : - 1 ] ) ) NEW_LINE self . factorial = [ 1 ] + list ( accumulate ( range ( 1 , max_n + 1 ) , lambda x , y : x * y % mod ) ) NEW_LINE self . inverse_memo = { } NEW_LINE DEDENT def get_inverse ( self , x : int ) : NEW_LINE INDENT x = self . factorial [ x ] NEW_LINE if x not in self . inverse_memo : NEW_LINE INDENT result , _x , mod = 1 , x , self . mod NEW_LINE for bit in self . inverse_mod : NEW_LINE INDENT if bit : NEW_LINE INDENT result = result * _x % mod NEW_LINE DEDENT _x = _x * _x % mod NEW_LINE DEDENT self . inverse_memo [ x ] = result NEW_LINE DEDENT return self . inverse_memo [ x ] NEW_LINE DEDENT def get_combination ( self , n , r ) : NEW_LINE INDENT return self . factorial [ n ] * self . get_inverse ( r ) * self . get_inverse ( n - r ) % self . mod NEW_LINE DEDENT DEDENT H , W , A , B = map ( int , input ( ) . split ( ) ) NEW_LINE mod = 10 ** 9 + 7 NEW_LINE big_comb = BigCombination ( max_n = 2 * 10 ** 5 ) NEW_LINE comb = big_comb . get_combination NEW_LINE _A = H - A - 1 NEW_LINE print ( sum ( comb ( x + _A , x ) * comb ( W - x - 1 + A - 1 , A - 1 ) % mod for x in range ( B , W ) ) % mod ) NEW_LINE","def inpl ( ) : return [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE mod = 10 ** 9 + 7 NEW_LINE H , W , A , B = inpl ( ) NEW_LINE fac = [ 1 for _ in range ( H + W - 1 ) ] NEW_LINE for i in range ( H + W - 2 ) : NEW_LINE INDENT fac [ i + 1 ] = ( i + 1 ) * fac [ i ] % mod NEW_LINE DEDENT inv = [ 1 for _ in range ( H + W - 1 ) ] NEW_LINE for i in range ( 2 , H + W - 2 ) : NEW_LINE INDENT inv [ i ] = ( - ( mod \/\/ i ) * inv [ mod % i ] ) % mod NEW_LINE DEDENT facinv = [ 1 for _ in range ( H + W - 1 ) ] NEW_LINE for i in range ( H + W - 2 ) : NEW_LINE INDENT facinv [ i + 1 ] = inv [ i + 1 ] * facinv [ i ] % mod NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( W - B ) : NEW_LINE INDENT ans += ( fac [ H + B - A - 1 + i ] * fac [ W + A - B - 2 - i ] * facinv [ H - A - 1 ] * facinv [ B + i ] * facinv [ A - 1 ] * facinv [ W - B - 1 - i ] ) % mod NEW_LINE DEDENT print ( ans % mod ) NEW_LINE","BIG = ( 10 ** 9 ) + 7 NEW_LINE f_list = [ 1 ] * 200000 NEW_LINE f_r_list = [ 1 ] * 200000 NEW_LINE for i in range ( 199999 ) : NEW_LINE INDENT f_list [ i + 1 ] = int ( ( f_list [ i ] * ( i + 2 ) ) % BIG ) NEW_LINE DEDENT def power ( n , x ) : NEW_LINE INDENT if x == 1 : NEW_LINE INDENT return n NEW_LINE DEDENT elif x % 2 == 0 : NEW_LINE INDENT return power ( int ( ( n * n ) % BIG ) , int ( x \/ 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return int ( ( n * power ( n , x - 1 ) ) % BIG ) NEW_LINE DEDENT DEDENT f_r_list [ - 1 ] = power ( f_list [ - 1 ] , BIG - 2 ) NEW_LINE for i in range ( 2 , 200001 ) : NEW_LINE INDENT f_r_list [ - i ] = int ( ( f_r_list [ - i + 1 ] * ( 200002 - i ) ) % BIG ) NEW_LINE DEDENT def comb ( n , r ) : NEW_LINE INDENT if n == 0 or r == 0 or n == r : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( ( f_list [ n - 1 ] * f_r_list [ n - r - 1 ] ) % BIG ) * f_r_list [ r - 1 ] ) % BIG NEW_LINE DEDENT DEDENT h , w , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( h - a ) : NEW_LINE INDENT ans = int ( ( ans + int ( ( comb ( b + i - 1 , b - 1 ) * comb ( h + w - b - i - 2 , w - b - 1 ) ) % BIG ) ) % BIG ) NEW_LINE DEDENT print ( int ( ans ) ) NEW_LINE"],"bleu":0.35506113361001773,"rouge_l":0.43280023262576334}
{"id":42,"predictions":["n , m = map ( int , input ( ) . split ( ) ) NEW_LINE l = [ [ 0 ] * 2 for i in range ( n ) ] NEW_LINE l [ 0 ] [ 0 ] = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT l [ i + 1 ] [ 1 ] = 1 NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE a = a - 1 NEW_LINE b = b - 1 NEW_LINE if l [ a ] [ 0 ] > 0 : NEW_LINE INDENT l [ a ] [ 1 ] -= 1 NEW_LINE l [ b ] [ 0 ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT l [ a ] [ 1 ] -= 1 NEW_LINE l [ b ] [ 1 ] += 1 NEW_LINE DEDENT if l [ b ] [ 0 ] > 0 : NEW_LINE INDENT l [ b ] [ 0 ] += l [ b ] [ 1 ] NEW_LINE l [ b ] [ 1 ] -= 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if l [ i ] [ 0 ] > 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["from collections import Counter NEW_LINE L , R = map ( int , input ( ) . split ( ) ) NEW_LINE inputs_l = Counter ( [ int ( i ) for i in input ( ) . split ( ) ] ) NEW_LINE inputs_r = Counter ( [ int ( i ) for i in input ( ) . split ( ) ] ) NEW_LINE print ( sum ( [ min ( inputs_r [ key ] , value ) for key , value in inputs_l . items ( ) ] ) ) NEW_LINE","import sys NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE input = sys . stdin . readline NEW_LINE L , R = map ( int , input ( ) . split ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE r = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l = sorted ( l ) NEW_LINE r = sorted ( r ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE ans = 0 NEW_LINE while i < L and j < R : NEW_LINE INDENT if l [ i ] == r [ j ] : NEW_LINE INDENT ans += 1 NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT elif l [ i ] > r [ j ] : NEW_LINE INDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE","d = input ( ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE r = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = 0 NEW_LINE for i in range ( 10 , 41 ) : NEW_LINE INDENT c += min ( l . count ( i ) , r . count ( i ) ) NEW_LINE DEDENT print ( c ) NEW_LINE","def multiset ( a , b ) : NEW_LINE INDENT x , y = list ( set ( a ) & set ( b ) ) , [ ] NEW_LINE for s in x : NEW_LINE INDENT for t in range ( min ( [ a . count ( s ) , b . count ( s ) ] ) ) : NEW_LINE INDENT y . append ( s ) NEW_LINE DEDENT DEDENT return y NEW_LINE DEDENT map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( len ( multiset ( a , b ) ) ) NEW_LINE","from collections import Counter NEW_LINE def main ( ) : NEW_LINE INDENT _ , _ = map ( int , input ( ) . split ( ) ) NEW_LINE ll = Counter ( map ( int , input ( ) . split ( ) ) ) NEW_LINE rr = Counter ( map ( int , input ( ) . split ( ) ) ) NEW_LINE res = 0 NEW_LINE for l in ll . keys ( ) : NEW_LINE INDENT if l in rr : NEW_LINE INDENT res += min ( ll [ l ] , rr [ l ] ) NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"bleu":0.3319511150206806,"rouge_l":0.4676133479952631}
{"id":43,"predictions":["X = int ( input ( ) ) NEW_LINE print ( [ t for t in range ( 10 ** 5 ) if t * ( t + 1 ) \/ 2 < X ] [ - 1 ] + 1 ) NEW_LINE"],"references":["x = int ( input ( ) ) NEW_LINE y = [ ] NEW_LINE for i in range ( 1 , 33 ) : NEW_LINE INDENT for j in range ( 2 , 11 ) : NEW_LINE INDENT y . append ( i ** j ) NEW_LINE DEDENT DEDENT ans = 1 NEW_LINE for i in y : NEW_LINE INDENT if i <= x : NEW_LINE INDENT ans = max ( ans , i ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE","x = int ( input ( ) ) NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if n % 2 == 0 or n % 3 == 0 : return True NEW_LINE if n < 3 : return False NEW_LINE for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : NEW_LINE INDENT if n % i == 0 : return False NEW_LINE DEDENT return True NEW_LINE DEDENT primes = [ i for i in range ( 1 , 32 ) if isPrime ( i ) ] NEW_LINE def isExp ( n ) : NEW_LINE INDENT if n == 1 : return True NEW_LINE for i in [ p for p in primes if p < int ( n ** 0.5 ) + 1 ] : NEW_LINE INDENT p = 0 NEW_LINE while i ** p <= n : NEW_LINE INDENT if i ** p == n : return True NEW_LINE p += 1 NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT for i in range ( x , 0 , - 1 ) : NEW_LINE INDENT if isExp ( i ) : return i NEW_LINE DEDENT DEDENT print ( solve ( ) ) NEW_LINE","X = int ( input ( ) ) NEW_LINE r = int ( X ** 0.5 ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , r + 1 ) : NEW_LINE INDENT a = 0 NEW_LINE for j in range ( 1 , 11 ) : NEW_LINE INDENT if i ** j <= X : NEW_LINE INDENT a = i ** j NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT ans = max ( ans , a ) NEW_LINE DEDENT print ( ans ) NEW_LINE","import bisect NEW_LINE a = [ ] NEW_LINE for pw in range ( 2 , 1001 ) : NEW_LINE INDENT for x in range ( 1 , 1001 ) : NEW_LINE INDENT nw = x ** pw NEW_LINE if nw > 1000 : NEW_LINE INDENT break NEW_LINE DEDENT a . append ( nw ) NEW_LINE DEDENT DEDENT a = sorted ( a ) NEW_LINE x = int ( input ( ) ) NEW_LINE y = bisect . bisect_right ( a , x ) NEW_LINE print ( a [ y - 1 ] ) NEW_LINE","import math NEW_LINE x = int ( input ( ) ) NEW_LINE t = math . floor ( x ** ( 1 \/ 2 ) ) NEW_LINE a = [ 1 ] NEW_LINE for i in range ( 2 , t + 1 ) : NEW_LINE INDENT b = i NEW_LINE while ( b <= x ) : NEW_LINE INDENT a . append ( b ) NEW_LINE b *= i NEW_LINE DEDENT DEDENT print ( max ( a ) ) NEW_LINE"],"bleu":0.1783434048365673,"rouge_l":0.350793235879597}
{"id":44,"predictions":["import sys , os , ioimport math , bisect , operatorinf , mod = float ( ' inf ' ) , 10 ** 9 + 7 NEW_LINE"],"references":["a = [ int ( input ( ) ) for _ in [ 0 ] * int ( input ( ) ) ] * 2 NEW_LINE if len ( set ( a ) ) < 2 : NEW_LINE INDENT print ( - 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT b = c = m = 0 NEW_LINE for i in a : NEW_LINE INDENT if i : NEW_LINE INDENT b += 1 NEW_LINE m = max ( m , b , c ) NEW_LINE c = 0 NEW_LINE DEDENT else : NEW_LINE INDENT c += 1 NEW_LINE m = max ( m , b , c ) NEW_LINE b = 0 NEW_LINE DEDENT DEDENT print ( ~ - m \/\/ 2 + 1 ) NEW_LINE","def b_trees ( N , Color ) : NEW_LINE INDENT if len ( set ( Color ) ) == 1 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT color_cycle = Color + Color NEW_LINE color_continuity = 1 NEW_LINE tmp_continuity = 1 NEW_LINE for k in range ( N * 2 ) : NEW_LINE INDENT if color_cycle [ k ] == color_cycle [ k - 1 ] : NEW_LINE INDENT tmp_continuity += 1 NEW_LINE DEDENT else : NEW_LINE INDENT color_continuity = max ( color_continuity , tmp_continuity ) NEW_LINE tmp_continuity = 1 NEW_LINE DEDENT DEDENT ans = ( ( color_continuity - 1 ) \/\/ 2 ) + 1 NEW_LINE return ans NEW_LINE DEDENT N = int ( input ( ) ) NEW_LINE Color = [ int ( input ( ) ) for _ in [ 0 ] * N ] NEW_LINE print ( b_trees ( N , Color ) ) NEW_LINE","N = int ( input ( ) ) NEW_LINE cl = [ int ( input ( ) ) for i in range ( N ) ] NEW_LINE ans = 1 NEW_LINE renzoku1 = 1 NEW_LINE score = 1 NEW_LINE renzoku = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT if ( cl [ 0 ] == cl [ 1 ] ) : NEW_LINE INDENT renzoku1 = 2 NEW_LINE renzoku = 1 NEW_LINE DEDENT DEDENT elif ( renzoku == 1 ) : NEW_LINE INDENT if ( i == N - 1 ) : NEW_LINE INDENT if ( cl [ i ] == cl [ 0 ] ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( N \/\/ 2 ) NEW_LINE DEDENT quit ( ) NEW_LINE DEDENT if ( cl [ i ] == cl [ i + 1 ] ) : NEW_LINE INDENT renzoku1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT renzoku = 0 NEW_LINE DEDENT DEDENT elif ( renzoku == 0 ) : NEW_LINE INDENT if ( i == N - 1 ) : NEW_LINE INDENT if ( cl [ i ] == cl [ 0 ] ) : NEW_LINE INDENT score += renzoku1 NEW_LINE ans = max ( ans , score ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( score , max ( ans , renzoku1 ) ) NEW_LINE DEDENT DEDENT elif ( cl [ i ] == cl [ i + 1 ] ) : NEW_LINE INDENT score += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( ans , score ) NEW_LINE score = 1 NEW_LINE DEDENT DEDENT DEDENT if ( ans == 2 ) : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( ans + 1 ) \/\/ 2 ) NEW_LINE DEDENT","from itertools import groupby NEW_LINE N = int ( input ( ) ) NEW_LINE COLOR = [ int ( input ( ) ) for _ in range ( N ) ] NEW_LINE colors = [ [ k , len ( list ( g ) ) ] for k , g in groupby ( COLOR ) ] NEW_LINE if len ( colors ) == 1 : NEW_LINE INDENT print ( - 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT if colors [ 0 ] [ 0 ] == colors [ - 1 ] [ 0 ] : NEW_LINE INDENT colors [ 0 ] [ 1 ] += colors [ - 1 ] [ 1 ] NEW_LINE colors . pop ( ) NEW_LINE DEDENT print ( - ( - max ( map ( lambda x : x [ 1 ] , colors ) ) \/\/ 2 ) ) NEW_LINE","N = int ( input ( ) ) NEW_LINE c = [ int ( input ( ) ) for i in range ( N ) ] NEW_LINE max_seq = 0 NEW_LINE temp_seq = 1 NEW_LINE first_seq = 0 NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT if c [ i ] == c [ i + 1 ] : NEW_LINE INDENT temp_seq += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if first_seq == 0 : NEW_LINE INDENT first_seq = temp_seq NEW_LINE DEDENT max_seq = max ( max_seq , temp_seq ) NEW_LINE temp_seq = 1 NEW_LINE DEDENT DEDENT if c [ 0 ] == c [ - 1 ] and first_seq > 0 : NEW_LINE INDENT temp_seq += first_seq NEW_LINE DEDENT max_seq = max ( max_seq , temp_seq ) NEW_LINE if max_seq == N : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( max_seq + 1 ) \/\/ 2 ) NEW_LINE DEDENT"],"bleu":0.0017582324167822341,"rouge_l":0.09501557632398752}
{"id":45,"predictions":["a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE print ( \" YES \" if a == b or b == c : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE N = int ( input ( ) ) NEW_LINE NG1 = int ( input ( ) ) NEW_LINE NG2 = int ( input ( ) ) NEW_LINE NG3 = int ( input ( ) ) NEW_LINE if N == NG1 or N == NG2 or N == NG3 : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE sys . exit ( ) NEW_LINE DEDENT queue = [ ] NEW_LINE queue . append ( ( 0 , N ) ) NEW_LINE judge = [ ] NEW_LINE while queue : NEW_LINE INDENT a = queue . pop ( 0 ) NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT b = a [ 1 ] - [ 1 , 2 , 3 ] [ i ] NEW_LINE if b != NG1 and b != NG2 and b != NG3 and a [ 0 ] < 100 : NEW_LINE INDENT num = ( a [ 0 ] + 1 , b ) NEW_LINE if b > 0 and num [ 0 ] < 100 and num not in judge and ( 100 - num [ 0 ] ) * 3 >= b : NEW_LINE INDENT queue . append ( num ) NEW_LINE judge . append ( num ) NEW_LINE DEDENT elif b == 0 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE sys . exit ( ) NEW_LINE DEDENT else : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( ' NO ' ) NEW_LINE","n = int ( input ( ) ) NEW_LINE ng = list ( [ int ( input ( ) ) for i in range ( 3 ) ] ) NEW_LINE dp = [ float ( \" inf \" ) ] * 301 NEW_LINE dp [ n ] = 0 NEW_LINE for i in range ( n , - 1 , - 1 ) : NEW_LINE INDENT if i in ng : NEW_LINE INDENT continue NEW_LINE DEDENT for j in range ( 1 , 4 ) : NEW_LINE INDENT dp [ i - j ] = min ( dp [ i ] + 1 , dp [ i - j ] ) NEW_LINE DEDENT DEDENT print ( \" YES \" if dp [ 0 ] <= 100 else \" NO \" ) NEW_LINE","n = int ( input ( ) ) NEW_LINE m = [ ] NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT m . append ( int ( input ( ) ) ) NEW_LINE DEDENT ret = \" YES \" NEW_LINE if n in m : NEW_LINE INDENT ret = \" NO \" NEW_LINE DEDENT else : NEW_LINE INDENT m . sort ( ) NEW_LINE if n == 300 : NEW_LINE INDENT if [ i for i in m if i % 3 == 0 ] : NEW_LINE INDENT ret = \" NO \" NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT tmp = ( m [ 2 ] - m [ 1 ] ) * ( m [ 1 ] - m [ 0 ] ) NEW_LINE if m [ 2 ] < n and tmp == 1 : NEW_LINE INDENT ret = \" NO \" NEW_LINE DEDENT elif n == 299 : NEW_LINE INDENT if tmp == 4 : NEW_LINE INDENT ret = \" NO \" NEW_LINE DEDENT elif max ( m [ 2 ] % 3 , m [ 1 ] % 3 ) == 2 and m [ 1 ] % 3 * m [ 0 ] % 3 == 0 : NEW_LINE INDENT ret = \" NO \" NEW_LINE DEDENT elif m [ 2 ] % 3 == 0 and m [ 2 ] - m [ 1 ] == 1 : NEW_LINE INDENT ret = \" NO \" NEW_LINE DEDENT elif m [ 1 ] % 3 == 0 and m [ 1 ] - m [ 0 ] == 1 : NEW_LINE INDENT ret = \" NO \" NEW_LINE DEDENT DEDENT elif n == 298 : NEW_LINE INDENT if m [ 0 ] - m [ 1 ] == 1 and m [ 0 ] % 3 == 0 : NEW_LINE INDENT ret = \" NO \" NEW_LINE DEDENT elif m [ 2 ] % 3 == 1 and tmp == 4 : NEW_LINE INDENT ret = \" NO \" NEW_LINE DEDENT elif m [ 2 ] % 3 == 1 and m [ 1 ] % 3 == 0 and m [ 1 ] - m [ 0 ] == 1 : NEW_LINE INDENT ret = \" NO \" NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( ret ) NEW_LINE","n , * g = eval ( ' int ( input ( ) ) + 4 , ' * 4 ) ; d = [ 0 ] * 500 NEW_LINE for i in range ( 5 , n + 1 ) : d [ i ] = 100 * ( i in g ) - ~ min ( d [ i - 3 : i ] ) NEW_LINE print ( ' YNEOS ' [ d [ n ] > 100 : : 2 ] ) NEW_LINE","from collections import defaultdict as dd NEW_LINE n = int ( input ( ) ) NEW_LINE ng1 = int ( input ( ) ) NEW_LINE ng2 = int ( input ( ) ) NEW_LINE ng3 = int ( input ( ) ) NEW_LINE dp = dd ( lambda : 1000 ) NEW_LINE dp [ n ] = 0 NEW_LINE for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT if i == ng1 or i == ng2 or i == ng3 : NEW_LINE INDENT if i == n : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE exit ( ) NEW_LINE DEDENT continue NEW_LINE DEDENT for j in range ( 1 , 4 ) : NEW_LINE INDENT dp [ i - j ] = min ( dp [ i ] + 1 , dp [ i - j ] ) NEW_LINE DEDENT DEDENT if dp [ 0 ] <= 100 : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"],"bleu":0.3487165954743039,"rouge_l":0.3177709571142962}
{"id":46,"predictions":["import sys NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE INF = 10 ** 18 NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def II ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def SI ( ) : return input ( ) NEW_LINE from collections import Counter NEW_LINE def main ( ) : NEW_LINE INDENT N , M = LI ( ) NEW_LINE XY = [ ] NEW_LINE for _ in range ( M ) : NEW_LINE INDENT XY . append ( LI_ ( ) ) NEW_LINE DEDENT balls = [ 1 ] * N NEW_LINE exp = set ( [ 0 ] ) NEW_LINE for x , y in XY : NEW_LINE INDENT balls [ x ] -= 1 NEW_LINE balls [ y ] += 1 NEW_LINE if x in exp : NEW_LINE INDENT exp . add ( y ) NEW_LINE if balls [ x ] == 0 : NEW_LINE INDENT exp . remove ( x ) NEW_LINE DEDENT DEDENT DEDENT ans = len ( exp ) NEW_LINE return ans NEW_LINE DEDENT print ( main ( ) ) NEW_LINE"],"references":["N , M = ( int ( _ ) for _ in input ( ) . split ( ) ) NEW_LINE E = [ ] NEW_LINE V = [ [ i + 1 , 0 ] for i in range ( N ) ] NEW_LINE searched_vertex = [ ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT u , v = ( int ( _ ) for _ in input ( ) . split ( ) ) NEW_LINE E . append ( [ u , v , True ] ) NEW_LINE DEDENT cnt_trees = 0 NEW_LINE def find_tree ( vertex ) : NEW_LINE INDENT flag = True NEW_LINE index , reached = vertex NEW_LINE if reached == 0 : NEW_LINE INDENT V [ index - 1 ] [ 1 ] = 1 NEW_LINE DEDENT searched_vertex . append ( index ) NEW_LINE while searched_vertex : NEW_LINE INDENT i = searched_vertex [ len ( searched_vertex ) - 1 ] NEW_LINE for edge_index in range ( len ( E ) ) : NEW_LINE INDENT u , v , unused = E [ edge_index ] NEW_LINE if unused : NEW_LINE INDENT if u == i : NEW_LINE INDENT E [ edge_index ] [ 2 ] = False NEW_LINE for ind in range ( len ( searched_vertex ) ) : NEW_LINE INDENT if v == searched_vertex [ ind ] : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT V [ v - 1 ] [ 1 ] = 1 NEW_LINE searched_vertex . append ( v ) NEW_LINE break NEW_LINE DEDENT DEDENT elif v == i : NEW_LINE INDENT E [ edge_index ] [ 2 ] = False NEW_LINE for ind in range ( len ( searched_vertex ) ) : NEW_LINE INDENT if u == searched_vertex [ ind ] : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT V [ u - 1 ] [ 1 ] = 1 NEW_LINE searched_vertex . append ( u ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT else : NEW_LINE INDENT searched_vertex . pop ( ) NEW_LINE DEDENT DEDENT return flag NEW_LINE DEDENT for index , reached in V : NEW_LINE INDENT if reached == 0 : NEW_LINE INDENT for j in range ( len ( E ) ) : NEW_LINE INDENT E [ j ] [ 2 ] = True NEW_LINE DEDENT if find_tree ( ( index , reached ) ) : NEW_LINE INDENT cnt_trees += 1 NEW_LINE DEDENT DEDENT DEDENT print ( cnt_trees ) NEW_LINE","import sys NEW_LINE input = sys . stdin . readline NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE par = [ ] NEW_LINE rank = [ 0 ] * n NEW_LINE judge = [ True ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT par . append ( i ) NEW_LINE DEDENT def find ( x , par ) : NEW_LINE INDENT if par [ x ] == x : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT return find ( par [ x ] , par ) NEW_LINE DEDENT DEDENT def unite ( x , y , par , rank ) : NEW_LINE INDENT x = find ( x , par ) NEW_LINE y = find ( y , par ) NEW_LINE if x == y : NEW_LINE INDENT judge [ x ] = False NEW_LINE DEDENT if x != y : NEW_LINE INDENT if rank [ x ] < rank [ y ] : NEW_LINE INDENT if not judge [ x ] : NEW_LINE INDENT judge [ y ] = False NEW_LINE DEDENT par [ x ] = y NEW_LINE judge [ x ] = False NEW_LINE DEDENT else : NEW_LINE INDENT if not judge [ y ] : NEW_LINE INDENT judge [ x ] = False NEW_LINE DEDENT par [ y ] = x NEW_LINE judge [ y ] = False NEW_LINE if rank [ x ] == rank [ y ] : NEW_LINE INDENT rank [ x ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT def same ( x , y , par ) : NEW_LINE INDENT return find ( x , par ) == find ( y , par ) NEW_LINE DEDENT def same ( x , y , par ) : NEW_LINE INDENT return find ( x , par ) == find ( y , par ) NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT u , v = map ( int , input ( ) . split ( ) ) NEW_LINE u , v = u - 1 , v - 1 NEW_LINE unite ( u , v , par , rank ) NEW_LINE DEDENT res = 0 NEW_LINE for e in judge : NEW_LINE INDENT if e : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE","import sys NEW_LINE read = sys . stdin . readline NEW_LINE sys . setrecursionlimit ( 1 << 25 ) NEW_LINE def readln ( ) : NEW_LINE INDENT return list ( map ( int , read ( ) . split ( ) ) ) NEW_LINE DEDENT N , M = readln ( ) NEW_LINE visited = [ False ] * N NEW_LINE from collections import defaultdict NEW_LINE edge = defaultdict ( lambda : set ( ) ) NEW_LINE for _ in range ( M ) : NEW_LINE INDENT u , v = readln ( ) NEW_LINE edge [ v - 1 ] . add ( u - 1 ) NEW_LINE edge [ u - 1 ] . add ( v - 1 ) NEW_LINE DEDENT def dfs ( node , prev ) : NEW_LINE INDENT if visited [ node ] : NEW_LINE INDENT return 0 NEW_LINE DEDENT visited [ node ] = True NEW_LINE for n in edge [ node ] : NEW_LINE INDENT if n == prev : NEW_LINE INDENT continue NEW_LINE DEDENT if dfs ( n , node ) == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if not visited [ i ] : NEW_LINE INDENT ans += dfs ( i , - 1 ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE","def notwent ( camefrom ) : NEW_LINE INDENT for i , j in enumerate ( camefrom ) : NEW_LINE INDENT if j == N : NEW_LINE INDENT return ( i ) NEW_LINE DEDENT DEDENT DEDENT import numpy as np NEW_LINE from collections import deque NEW_LINE import sys NEW_LINE fastinput = sys . stdin . readline NEW_LINE N , M = map ( int , fastinput ( ) . split ( ) ) NEW_LINE Lines = [ [ False ] * N for i in range ( N ) ] NEW_LINE ans = 0 NEW_LINE for _ in range ( M ) : NEW_LINE INDENT u , v = [ int ( i ) - 1 for i in fastinput ( ) . split ( ) ] NEW_LINE Lines [ u ] [ v ] = True NEW_LINE Lines [ v ] [ u ] = True NEW_LINE DEDENT camefrom = [ N ] * N NEW_LINE togo = deque ( ) NEW_LINE while not all ( [ apijwe != N for apijwe in camefrom ] ) : NEW_LINE INDENT curpos = notwent ( camefrom ) NEW_LINE togo . append ( curpos ) NEW_LINE itsloop = 0 NEW_LINE camefrom [ curpos ] = curpos NEW_LINE while togo : NEW_LINE INDENT curpos = togo . pop ( ) NEW_LINE for to , p in enumerate ( Lines [ curpos ] ) : NEW_LINE INDENT if p and to != camefrom [ curpos ] : NEW_LINE INDENT if camefrom [ to ] != N and itsloop == 0 : NEW_LINE INDENT ans -= 1 NEW_LINE itsloop = 1 NEW_LINE DEDENT elif camefrom [ to ] == N : NEW_LINE INDENT togo . append ( to ) NEW_LINE camefrom [ to ] = curpos NEW_LINE DEDENT DEDENT DEDENT DEDENT ans += 1 NEW_LINE DEDENT print ( ans ) NEW_LINE","def dfs ( ) : NEW_LINE INDENT ret = 1 NEW_LINE while stack : NEW_LINE INDENT node , parent = stack . pop ( ) NEW_LINE visited [ node ] = 1 NEW_LINE for e in edges [ node ] : NEW_LINE INDENT if ( e != parent and visited [ e ] == 1 ) : NEW_LINE INDENT ret = 0 NEW_LINE DEDENT elif ( e != parent and visited [ e ] == 0 ) : NEW_LINE INDENT stack . append ( [ e , node ] ) NEW_LINE DEDENT DEDENT DEDENT return ret NEW_LINE DEDENT if ( __name__ == \" _ _ main _ _ \" ) : NEW_LINE INDENT N , M = map ( int , input ( ) . split ( ) ) NEW_LINE edges = [ set ( ) for i in range ( N ) ] NEW_LINE visited = [ 0 ] * N NEW_LINE res = 0 NEW_LINE stack = [ ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT u , v = map ( int , input ( ) . split ( ) ) NEW_LINE u , v = u - 1 , v - 1 NEW_LINE edges [ u ] . add ( v ) NEW_LINE edges [ v ] . add ( u ) NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT if ( visited [ i ] == 0 ) : NEW_LINE INDENT stack . append ( [ i , - 1 ] ) NEW_LINE res += dfs ( ) NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE DEDENT"],"bleu":0.3489693594582279,"rouge_l":0.42499853199314286}
{"id":47,"predictions":["a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( a + b - a ) NEW_LINE"],"references":["R = int ( input ( ) ) NEW_LINE G = int ( input ( ) ) NEW_LINE print ( 2 * G - R ) NEW_LINE","r , g = map ( int , open ( 0 ) ) ; print ( 2 * g - r ) NEW_LINE","current_rate = int ( input ( ) ) NEW_LINE target = int ( input ( ) ) NEW_LINE print ( target * 2 - current_rate ) NEW_LINE","R , G = map ( int , open ( 0 ) . read ( ) . split ( ) ) NEW_LINE print ( G + ( G - R ) ) NEW_LINE","r = int ( input ( ) ) NEW_LINE g = int ( input ( ) ) NEW_LINE print ( r + ( g - r ) * 2 ) NEW_LINE"],"bleu":0.5741156866422448,"rouge_l":0.6656274356975838}
{"id":48,"predictions":["a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( a - 1 ) * b NEW_LINE"],"references":["a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( a - 1 ) * ( b - 1 ) ) NEW_LINE","import numpy as np NEW_LINE class Calculator : NEW_LINE INDENT def __init__ ( self , arr ) : NEW_LINE INDENT self . arr = arr NEW_LINE DEDENT def get_result ( self ) : NEW_LINE INDENT return ( self . arr [ 0 ] - 1 ) * ( self . arr [ 1 ] - 1 ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT A , B , = map ( int , input ( ) . split ( ) ) NEW_LINE arr = np . array ( [ A , B ] , dtype = int ) NEW_LINE calc = Calculator ( arr ) NEW_LINE print ( calc . get_result ( ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT","def main ( ) : NEW_LINE INDENT A , B = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( A - 1 ) * ( B - 1 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT","x , y = map ( int , input ( ) . split ( ' ▁ ' ) ) NEW_LINE print ( ( x - 1 ) * ( y - 1 ) ) NEW_LINE","A , B = map ( int , input ( ) . split ( ) ) NEW_LINE ans = ( A - 1 ) * ( B - 1 ) NEW_LINE print ( ans ) NEW_LINE"],"bleu":0.7201335199688271,"rouge_l":0.8801331853496115}
{"id":49,"predictions":["H , W , h , w = map ( int , open ( 0 ) . read ( ) . split ( ) ) ; print ( ( H - h ) * ( W - w ) ) NEW_LINE"],"references":["import sys , re NEW_LINE from collections import deque , defaultdict , Counter NEW_LINE from math import ceil , sqrt , hypot , factorial , pi , sin , cos , radians NEW_LINE from itertools import permutations , combinations , product NEW_LINE from operator import itemgetter , mul NEW_LINE from copy import deepcopy NEW_LINE from string import ascii_lowercase , ascii_uppercase , digits NEW_LINE def input ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def INT ( ) : return int ( input ( ) ) NEW_LINE def MAP ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE INF = float ( ' inf ' ) NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE H , W = MAP ( ) NEW_LINE C = [ input ( ) for _ in range ( H ) ] NEW_LINE for x in C : NEW_LINE INDENT print ( x ) NEW_LINE print ( x ) NEW_LINE DEDENT","_ , * t = open ( 0 ) NEW_LINE for i in t : print ( i + i ) NEW_LINE","import sys , os NEW_LINE f = lambda : list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def init ( ) : NEW_LINE INDENT if ' local ' in os . environ : NEW_LINE INDENT sys . stdin = open ( ' . \/ input . txt ' , ' r ' ) NEW_LINE DEDENT DEDENT def solve ( ) : NEW_LINE INDENT n , m = f ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT a = input ( ) NEW_LINE print ( a ) NEW_LINE print ( a ) NEW_LINE DEDENT DEDENT init ( ) NEW_LINE solve ( ) NEW_LINE","from sys import stdin NEW_LINE height , width = map ( int , input ( ) . split ( ) ) NEW_LINE g = [ ] NEW_LINE for h in range ( height ) : NEW_LINE INDENT l = stdin . readline ( ) . split ( ) NEW_LINE g . append ( l ) NEW_LINE g . append ( l ) NEW_LINE DEDENT for h in range ( height * 2 ) : NEW_LINE INDENT print ( ' ' . join ( map ( str , g [ h ] ) ) ) NEW_LINE DEDENT","print ( * [ i * 2 for i in open ( 0 ) ] [ 1 : ] ) NEW_LINE"],"bleu":0.41071515975083994,"rouge_l":0.5074875207986689}
{"id":50,"predictions":["import itertools NEW_LINE import collections NEW_LINE import bisect NEW_LINE def main ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE A = [ int ( input ( ) ) for _ in range ( N ) ] NEW_LINE c = collections . Counter ( A ) NEW_LINE ans = 0 NEW_LINE for pair in c . items ( ) : NEW_LINE INDENT if pair [ 1 ] % 2 == 1 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"references":["print ( len ( set ( [ input ( ) for _ in range ( int ( input ( ) ) ) ] ) ) ) NEW_LINE","N = int ( input ( ) ) NEW_LINE di = [ int ( input ( ) ) for n in range ( N ) ] NEW_LINE di = sorted ( di , reverse = True ) NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if i < N - 1 and di [ i ] == di [ i + 1 ] : NEW_LINE INDENT i = i + 1 NEW_LINE continue NEW_LINE DEDENT ans += 1 NEW_LINE DEDENT print ( ans ) NEW_LINE","import sys NEW_LINE unique_list = [ ] NEW_LINE input_list = sys . stdin . readlines ( ) [ 1 : ] NEW_LINE for i in input_list : NEW_LINE INDENT if i not in unique_list : NEW_LINE INDENT unique_list . append ( i ) NEW_LINE DEDENT DEDENT print ( len ( unique_list ) ) NEW_LINE","n = int ( input ( ) ) NEW_LINE list = [ ] NEW_LINE count = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT list . append ( int ( input ( ) ) ) NEW_LINE DEDENT list . sort ( ) NEW_LINE tmp = list [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if tmp == list [ i ] : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 NEW_LINE DEDENT tmp = list [ i ] NEW_LINE DEDENT print ( count ) NEW_LINE","N = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE stage = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT inp = int ( input ( ) ) NEW_LINE if inp not in a : NEW_LINE INDENT a . append ( inp ) NEW_LINE stage += 1 NEW_LINE DEDENT DEDENT print ( stage ) NEW_LINE"],"bleu":0.48241362546226024,"rouge_l":0.621556897300996}
{"id":51,"predictions":["def plus_king ( X : int ) -> int : NEW_LINE INDENT return X \/\/ 10 + X % 10 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT X = int ( input ( ) ) NEW_LINE ans = plus_king ( X ) NEW_LINE print ( ans ) NEW_LINE DEDENT"],"references":["n = int ( input ( ) ) NEW_LINE print ( 111 + 999 - n ) NEW_LINE","n = input ( ) NEW_LINE num_list = list ( n ) NEW_LINE num_list = [ int ( i ) for i in num_list ] NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT if num_list [ i ] == 1 : NEW_LINE INDENT num_list [ i ] = 9 NEW_LINE DEDENT elif num_list [ i ] == 9 : NEW_LINE INDENT num_list [ i ] = 1 NEW_LINE DEDENT DEDENT print ( ' ' . join ( [ str ( i ) for i in num_list ] ) ) NEW_LINE","S = input ( ) NEW_LINE res = \" \" NEW_LINE for i in S : NEW_LINE INDENT if i == \"9\" : NEW_LINE INDENT res += \"1\" NEW_LINE DEDENT elif i == \"1\" : NEW_LINE INDENT res += \"9\" NEW_LINE DEDENT else : NEW_LINE INDENT res += i NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE","print ( 111 + 999 - int ( input ( ) ) ) NEW_LINE","a = list ( input ( ) ) NEW_LINE a = [ int ( x ) for x in a ] NEW_LINE a2 = [ 1 if i == 9 else 9 for i in a ] NEW_LINE for i in range ( len ( a2 ) ) : NEW_LINE INDENT print ( a2 [ i ] , end = \" \" ) NEW_LINE DEDENT"],"bleu":0.26655957397226565,"rouge_l":0.4864433811802232}
{"id":52,"predictions":["from math import gcd NEW_LINE def lcm ( a , b ) : return ( a * b ) \/\/ gcd ( a , b ) def output ( a , b ) : stdout . write ( str ( a [ 0 ] ) ) NEW_LINE"],"references":["import sys NEW_LINE from collections import defaultdict , Counter NEW_LINE from itertools import product , groupby , count , permutations , combinations NEW_LINE from math import pi , sqrt , ceil , floor NEW_LINE from collections import deque NEW_LINE from bisect import bisect , bisect_left , bisect_right NEW_LINE from string import ascii_lowercase NEW_LINE INF = float ( \" inf \" ) NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE dy = [ 0 , - 1 , 0 , 1 ] NEW_LINE dx = [ 1 , 0 , - 1 , 0 ] NEW_LINE def inside ( y : int , x : int , H : int , W : int ) -> bool : return 0 <= y < H and 0 <= x < W NEW_LINE def main ( ) : NEW_LINE INDENT X , Y = map ( int , input ( ) . split ( \" \/ \" ) ) NEW_LINE ans_list = [ ] NEW_LINE for n in range ( max ( 0 , 2 * X \/\/ Y - 10 ) , 2 * X \/\/ Y + 10 ) : NEW_LINE INDENT a = n * ( Y + n * Y - 2 * X ) NEW_LINE if a % ( 2 * Y ) == 0 : NEW_LINE INDENT m = a \/\/ ( 2 * Y ) NEW_LINE if 0 < m <= n : NEW_LINE INDENT ans_list . append ( \" { 0 } ▁ { 1 } \" . format ( n , m ) ) NEW_LINE DEDENT DEDENT DEDENT if ans_list : NEW_LINE INDENT print ( * ans_list , sep = \" \\n \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Impossible \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT","def gcd ( a , b ) : NEW_LINE INDENT return a if b == 0 else gcd ( b , a % b ) NEW_LINE DEDENT x , y = map ( int , input ( ) . split ( \" \/ \" ) ) NEW_LINE k = gcd ( x , y ) NEW_LINE x \/\/= k ; y \/\/= k ; NEW_LINE flag = False NEW_LINE for i in range ( ( 2 * x ) \/\/ ( y ** 2 ) - 1 , 10000000000000 ) : NEW_LINE INDENT n = i * y NEW_LINE m = ( n * ( n + 1 ) ) \/\/ 2 - i * x NEW_LINE if ( n <= 0 or m <= 0 ) : continue NEW_LINE if ( n < m ) : break NEW_LINE print ( n , m ) NEW_LINE flag = True NEW_LINE DEDENT if ( not flag ) : print ( \" Impossible \" ) NEW_LINE","import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE inf = 10 ** 20 NEW_LINE gosa = 1.0 \/ 10 ** 10 NEW_LINE mod = 10 ** 9 + 7 NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def F ( ) : return float ( sys . stdin . readline ( ) ) NEW_LINE def S ( ) : return input ( ) NEW_LINE def main ( ) : NEW_LINE INDENT x , y = [ int ( x ) for x in sys . stdin . readline ( ) . split ( ' \/ ' ) ] NEW_LINE g = fractions . gcd ( x , y ) NEW_LINE x \/\/= g NEW_LINE y \/\/= g NEW_LINE it = int ( x \/ y ) * 2 NEW_LINE r = [ ] NEW_LINE for i in range ( max ( 1 , it - 10 ) , it + 10 ) : NEW_LINE INDENT k = ( i + 1 ) * i \/\/ 2 NEW_LINE if i % y != 0 : NEW_LINE INDENT continue NEW_LINE DEDENT t = k - ( i \/\/ y ) * x NEW_LINE if 0 < t <= i : NEW_LINE INDENT r . append ( [ i , t ] ) NEW_LINE DEDENT DEDENT if r : NEW_LINE INDENT return ' \\n ' . join ( [ ' ▁ ' . join ( map ( str , _ ) ) for _ in r ] ) NEW_LINE DEDENT return ' Impossible ' NEW_LINE DEDENT print ( main ( ) ) NEW_LINE","import fractions NEW_LINE def get_min ( X , Y ) : NEW_LINE INDENT left = 0 NEW_LINE right = 10 ** 50 NEW_LINE res_N = - 1 NEW_LINE while ( right - left > 1 ) : NEW_LINE INDENT med = ( right + left ) \/\/ 2 NEW_LINE if ( med == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT y = med * Y NEW_LINE x = med * X NEW_LINE res = y * ( y + 1 ) \/\/ 2 NEW_LINE l = res - y NEW_LINE r = res - 1 NEW_LINE if l <= x and x <= r : NEW_LINE INDENT right = med NEW_LINE res_N = med NEW_LINE continue NEW_LINE DEDENT if x < l : NEW_LINE INDENT right = med NEW_LINE continue NEW_LINE DEDENT if x > r : NEW_LINE INDENT left = med NEW_LINE continue NEW_LINE DEDENT DEDENT return res_N NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT X , Y = input ( ) . split ( \" \/ \" ) NEW_LINE X = int ( X ) NEW_LINE Y = int ( Y ) NEW_LINE g = fractions . gcd ( X , Y ) NEW_LINE X = X \/\/ g NEW_LINE Y = Y \/\/ g NEW_LINE min_N = get_min ( X , Y ) NEW_LINE if min_N == - 1 : NEW_LINE INDENT print ( \" Impossible \" ) NEW_LINE DEDENT else : NEW_LINE INDENT t = min_N NEW_LINE while ( True ) : NEW_LINE INDENT N = t * Y NEW_LINE wrong = t * X NEW_LINE res = N * ( N + 1 ) \/\/ 2 NEW_LINE l = res - N NEW_LINE r = res - 1 NEW_LINE if wrong < l : NEW_LINE INDENT break NEW_LINE DEDENT if wrong > r : NEW_LINE INDENT break NEW_LINE DEDENT print ( N , res - wrong ) NEW_LINE t += 1 NEW_LINE DEDENT DEDENT DEDENT","X , Y = map ( int , input ( ) . split ( ' \/ ' ) ) NEW_LINE isImpossible = True NEW_LINE for i in range ( 2 ) : NEW_LINE INDENT N = int ( ( X \/ Y * 2 ) \/\/ 1 + i ) NEW_LINE SigmaN = N * ( N + 1 ) \/\/ 2 NEW_LINE if N * X % Y == 0 and N is not 0 : NEW_LINE INDENT isImpossible = False NEW_LINE print ( N , end = ' ▁ ' ) NEW_LINE print ( SigmaN - ( N * X \/\/ Y ) ) NEW_LINE DEDENT DEDENT if isImpossible : NEW_LINE INDENT print ( \" Impossible \" ) NEW_LINE DEDENT"],"bleu":0.060816648093217233,"rouge_l":0.22404294391863258}
{"id":53,"predictions":["def main ( ) : NEW_LINE INDENT n , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 5 : NEW_LINE INDENT print ( a ) NEW_LINE DEDENT elif n == 4 : NEW_LINE INDENT print ( a ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( b \/\/ 10 ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"references":["N , A , B = map ( int , input ( ) . split ( \" ▁ \" ) ) NEW_LINE total = 0 NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT sum = 0 NEW_LINE temp = i NEW_LINE for m in range ( 5 ) : NEW_LINE INDENT sum += temp % 10 NEW_LINE temp = temp \/\/ 10 NEW_LINE DEDENT if A <= sum and sum <= B : NEW_LINE INDENT total += i NEW_LINE DEDENT DEDENT print ( total ) NEW_LINE","import sys NEW_LINE input = sys . stdin . readline NEW_LINE def io_generator ( ) : NEW_LINE INDENT return input ( ) NEW_LINE DEDENT def bbs ( v ) : NEW_LINE INDENT s = [ int ( ci ) for ci in list ( str ( v ) ) ] NEW_LINE return sum ( s ) NEW_LINE DEDENT def main ( io ) : NEW_LINE INDENT n , a , b = map ( int , io ( ) . split ( ) ) NEW_LINE return sum ( [ x for x in range ( 1 , n + 1 ) if a <= bbs ( x ) and bbs ( x ) <= b ] ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT io = lambda : io_generator ( ) NEW_LINE print ( main ( io ) ) NEW_LINE DEDENT","listNAB = input ( ) . split ( ) NEW_LINE listNABint = [ int ( s ) for s in listNAB ] NEW_LINE def Placesum ( x ) : NEW_LINE INDENT y = str ( x ) NEW_LINE counter = 0 NEW_LINE for i in range ( len ( y ) ) : NEW_LINE INDENT counter += int ( y [ i ] ) NEW_LINE DEDENT return counter NEW_LINE DEDENT sumcounter = 0 NEW_LINE for i in range ( listNABint [ 0 ] ) : NEW_LINE INDENT if listNABint [ 1 ] <= Placesum ( i + 1 ) & Placesum ( i + 1 ) <= listNABint [ 2 ] : NEW_LINE INDENT sumcounter += i + 1 NEW_LINE DEDENT DEDENT print ( sumcounter ) NEW_LINE","n , a , b = [ int ( _ ) for _ in input ( ) . split ( ) ] NEW_LINE result = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT i = str ( i ) NEW_LINE wa = 0 NEW_LINE for j in range ( 0 , len ( str ( i ) ) ) : NEW_LINE INDENT wa = wa + int ( i [ j ] ) NEW_LINE DEDENT if a <= wa <= b : NEW_LINE INDENT result . append ( int ( i ) ) NEW_LINE DEDENT DEDENT print ( sum ( result ) ) NEW_LINE","inputs = input ( ) . split ( ) NEW_LINE n , a , b = list ( map ( int , inputs ) ) NEW_LINE count = 0 NEW_LINE for num in range ( n + 1 ) : NEW_LINE INDENT num_str = str ( num ) NEW_LINE all = 0 NEW_LINE for i in range ( len ( num_str ) ) : NEW_LINE INDENT all += int ( num_str [ i ] ) NEW_LINE DEDENT if a <= all <= b : NEW_LINE INDENT count += num NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE"],"bleu":0.5514220525273631,"rouge_l":0.48368793187855635}
{"id":54,"predictions":["a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE print ( a * b + c * ( a - b ) ) NEW_LINE"],"references":["s = input ( ) NEW_LINE a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE print ( s [ 0 : a ] + ' \" ' + s [ a : b ] + ' \" ' + s [ b : c ] + ' \" ' + s [ c : d ] + ' \" ' + s [ d : ] ) NEW_LINE","def main ( ) : NEW_LINE INDENT s = input ( ) NEW_LINE a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE l = [ c for c in s ] NEW_LINE l . insert ( d , ' \" ' ) NEW_LINE l . insert ( c , ' \" ' ) NEW_LINE l . insert ( b , ' \" ' ) NEW_LINE l . insert ( a , ' \" ' ) NEW_LINE print ( \" \" . join ( l ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT","s = input ( ) + \" ▁ \" NEW_LINE num = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE t = \" \" NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if i in num : NEW_LINE INDENT t += \" \\ \" \" NEW_LINE DEDENT t += s [ i ] NEW_LINE DEDENT print ( t [ : - 1 ] ) NEW_LINE","S = list ( input ( ) ) NEW_LINE A , B , C , D = map ( int , input ( ) . split ( ) ) NEW_LINE S . insert ( D , \" \\ \" \" ) NEW_LINE S . insert ( C , \" \\ \" \" ) NEW_LINE S . insert ( B , \" \\ \" \" ) NEW_LINE S . insert ( A , \" \\ \" \" ) NEW_LINE print ( * S , sep = \" \" ) NEW_LINE","* s , = input ( ) NEW_LINE for i in input ( ) . split ( ) [ : : - 1 ] : s . insert ( int ( i ) , ' \" ' ) NEW_LINE print ( ' ' . join ( s ) ) NEW_LINE"],"bleu":0.4119490355525875,"rouge_l":0.46394366197183096}
{"id":55,"predictions":["print ( ' YNEOS ' [ not eval ( input ( ) ) : : 2 ] ) NEW_LINE"],"references":["N = int ( input ( ) ) NEW_LINE for cake in range ( 26 ) : NEW_LINE INDENT flag = False NEW_LINE for donut in range ( 15 ) : NEW_LINE INDENT if 4 * cake + 7 * donut == N : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE flag = True NEW_LINE break NEW_LINE DEDENT DEDENT if flag : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT","from collections import defaultdict NEW_LINE from string import ascii_uppercase NEW_LINE import sys , bisect , math NEW_LINE stdin = sys . stdin NEW_LINE read_int = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) NEW_LINE read_str = lambda : stdin . readline ( ) . rstrip ( ) NEW_LINE N = read_int ( ) [ 0 ] NEW_LINE l = [ False for _ in range ( N + 1 ) ] NEW_LINE def solve ( ) : NEW_LINE INDENT ans = 0 NEW_LINE l [ 0 ] = True NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT if l [ i ] and i + 4 < N + 1 : NEW_LINE INDENT l [ i + 4 ] = True NEW_LINE DEDENT DEDENT for i in range ( N + 1 ) : NEW_LINE INDENT if l [ i ] and i + 7 < N + 1 : NEW_LINE INDENT l [ i + 7 ] = True NEW_LINE DEDENT DEDENT return l [ N ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT if solve ( ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT","def main ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE dp = [ False ] * ( 101 ) NEW_LINE dp [ 0 ] = True NEW_LINE dp [ 4 ] = True NEW_LINE dp [ 7 ] = True NEW_LINE for i in range ( 4 , 101 ) : NEW_LINE INDENT if i + 7 <= 100 : NEW_LINE INDENT dp [ i + 7 ] = dp [ i + 7 ] or dp [ i ] NEW_LINE DEDENT if i + 4 <= 100 : NEW_LINE INDENT dp [ i + 4 ] = dp [ i + 4 ] or dp [ i ] NEW_LINE DEDENT DEDENT if dp [ N ] : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT","N = int ( input ( ) ) NEW_LINE def dfs ( x ) : NEW_LINE INDENT if x > 100 : NEW_LINE INDENT return 0 NEW_LINE DEDENT cnt = 1 if x == N else 0 NEW_LINE cnt += dfs ( x + 4 ) NEW_LINE cnt += dfs ( x + 7 ) NEW_LINE return cnt NEW_LINE DEDENT print ( ' Yes ' if dfs ( 0 ) >= 1 else ' No ' ) NEW_LINE","n = int ( input ( ) ) NEW_LINE ans = \" No \" NEW_LINE for i in range ( n \/\/ 4 + 1 ) : NEW_LINE INDENT for j in range ( n \/\/ 7 + 1 ) : NEW_LINE INDENT if 4 * i + 7 * j == n : NEW_LINE INDENT ans = \" Yes \" NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT continue NEW_LINE DEDENT break NEW_LINE DEDENT print ( ans ) NEW_LINE"],"bleu":0.016543924051016953,"rouge_l":0.1717430253391349}
{"id":56,"predictions":["a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( a + b if a < b else \" Worse \" ) NEW_LINE"],"references":["x , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if 0 < b - a <= x : print ( \" safe \" ) NEW_LINE else : print ( \" ddealnigceiroouuss \" [ b - a > x : : 2 ] ) NEW_LINE","x , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if b - a > x : NEW_LINE INDENT print ( ' dangerous ' ) NEW_LINE DEDENT elif b > a : NEW_LINE INDENT print ( ' safe ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' delicious ' ) NEW_LINE DEDENT","x , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( \" delicious \" if b <= a else \" dangerous \" if x + a < b else \" safe \" ) NEW_LINE","x , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE ans = ' delicious ' if a - b >= 0 else ' safe ' if ( b - a ) <= x else ' dangerous ' NEW_LINE print ( ans ) NEW_LINE","x , a , b = [ int ( item ) for item in input ( ) . split ( ) ] NEW_LINE if b <= a : NEW_LINE INDENT print ( \" delicious \" ) NEW_LINE DEDENT elif x >= b - a : NEW_LINE INDENT print ( \" safe \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" dangerous \" ) NEW_LINE DEDENT"],"bleu":0.5301853883454881,"rouge_l":0.742030201342282}
{"id":57,"predictions":["import sys NEW_LINE def main ( ) : NEW_LINE INDENT input = sys . stdin . readline NEW_LINE A , B = map ( int , input ( ) . split ( ) ) NEW_LINE if A % 2 == 1 : NEW_LINE INDENT return ' B ' NEW_LINE DEDENT else : NEW_LINE INDENT return ' Even ' NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( main ( ) ) NEW_LINE DEDENT"],"references":["n , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if ( ( b - a ) % 2 == 0 ) : NEW_LINE INDENT print ( \" Alice \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Borys \" ) NEW_LINE DEDENT","n , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE M = [ 1 ] + [ 0 ] * n + [ 1 ] NEW_LINE a -= 1 NEW_LINE b -= 1 NEW_LINE M [ a ] = 1 NEW_LINE M [ b ] = 1 NEW_LINE turn = 1 NEW_LINE while True : NEW_LINE INDENT if turn == 1 : NEW_LINE INDENT if M [ a + 1 ] == 1 and M [ a - 1 ] == 0 : NEW_LINE INDENT M [ a - 1 ] = 1 NEW_LINE M [ a ] = 0 NEW_LINE a -= 1 NEW_LINE turn *= - 1 NEW_LINE DEDENT elif M [ a - 1 ] == 1 and M [ a + 1 ] == 0 : NEW_LINE INDENT M [ a + 1 ] = 1 NEW_LINE M [ a ] = 0 NEW_LINE a += 1 NEW_LINE turn *= - 1 NEW_LINE DEDENT elif M [ a - 1 ] == 0 and M [ a + 1 ] == 0 : NEW_LINE INDENT M [ a + 1 ] = 1 NEW_LINE M [ a ] = 0 NEW_LINE a += 1 NEW_LINE turn *= - 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Borys \" ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if M [ b + 1 ] == 1 and M [ b - 1 ] == 0 : NEW_LINE INDENT M [ b - 1 ] = 1 NEW_LINE M [ b ] = 0 NEW_LINE b -= 1 NEW_LINE turn *= - 1 NEW_LINE DEDENT elif M [ b - 1 ] == 1 and M [ b + 1 ] == 0 : NEW_LINE INDENT M [ b + 1 ] = 1 NEW_LINE M [ b ] = 0 NEW_LINE b += 1 NEW_LINE turn *= - 1 NEW_LINE DEDENT elif M [ b - 1 ] == 0 and M [ b + 1 ] == 0 : NEW_LINE INDENT M [ b - 1 ] = 1 NEW_LINE M [ b ] = 0 NEW_LINE b -= 1 NEW_LINE turn *= - 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Alice \" ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT DEDENT","import sys NEW_LINE input = sys . stdin . readline NEW_LINE N , A , B = map ( int , input ( ) . split ( ) ) NEW_LINE print ( \" Alice \" if ( B - A + 1 ) % 2 == 1 else \" Borys \" ) NEW_LINE","n , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 2 : NEW_LINE INDENT win = ' Borys ' NEW_LINE DEDENT else : NEW_LINE INDENT if abs ( a - b ) % 2 == 0 : NEW_LINE INDENT win = ' Alice ' NEW_LINE DEDENT else : NEW_LINE INDENT win = ' Borys ' NEW_LINE DEDENT DEDENT print ( win ) NEW_LINE","n , a , b = map ( int , input ( ) . split ( ) ) ; print ( ' ABloircyes ' [ ( b - a ) % 2 == 1 : : 2 ] ) NEW_LINE"],"bleu":0.5864184483718701,"rouge_l":0.6005854177754124}
{"id":58,"predictions":["import sys NEW_LINE import copy NEW_LINE input = sys . stdin . readline NEW_LINE def li ( ) : return list ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) NEW_LINE def li_ ( ) : return list ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) NEW_LINE def lf ( ) : return map ( float , input ( ) . split ( ) ) NEW_LINE def ls ( ) : return stdin . readline ( ) . strip ( ) NEW_LINE def ns ( ) : return stdin . readline ( ) . strip ( ) NEW_LINE def ns ( ) : return stdin . readline ( ) . strip ( ) NEW_LINE def ns ( ) : return list ( ns ( ) ) NEW_LINE def ni ( ) : return int ( ns ( ) ) NEW_LINE def ns ( ) : return stdin . readline ( ) . strip ( ) NEW_LINE def nf ( ) : return list ( ns ( ) ) NEW_LINE def ni ( ) : return list ( ns ( ) ) NEW_LINE def nf ( ) : return float ( ns ( ) ) NEW_LINE def ns ( ) : return stdin . readline ( ) NEW_LINE def ns ( ) : return stdin . readline ( ) . strip ( ) NEW_LINE def main ( ) : NEW_LINE INDENT n = ns ( ) NEW_LINE s = ns ( ) NEW_LINE t = ns ( ) NEW_LINE c = nl ( ) NEW_LINE t = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT t . append ( s [ t ] ) NEW_LINE DEDENT print ( main ( ) ) NEW_LINE"],"references":["S = str ( input ( ) ) NEW_LINE ascii_letters = \" abcdefghijklmnopqrstuvwxyz \" NEW_LINE for letter in ascii_letters : NEW_LINE INDENT if letter not in S : NEW_LINE INDENT print ( letter ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT print ( \" None \" ) NEW_LINE","print ( min ( set ( map ( chr , range ( 97 , 123 ) ) ) - set ( input ( ) ) or [ None ] ) ) NEW_LINE","from collections import defaultdict NEW_LINE import string NEW_LINE S = input ( ) NEW_LINE letters = defaultdict ( lambda : False ) NEW_LINE for s in S : NEW_LINE INDENT letters [ s ] = True NEW_LINE DEDENT ans = ' None ' NEW_LINE for l in string . ascii_lowercase : NEW_LINE INDENT if letters [ l ] == False : NEW_LINE INDENT ans = l NEW_LINE break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE","s = sorted ( input ( ) ) NEW_LINE dct = { chr ( i ) : 0 for i in range ( 97 , 97 + 26 ) } NEW_LINE result = ' ' NEW_LINE for c in s : NEW_LINE INDENT if c in dct : NEW_LINE INDENT dct [ c ] += 1 NEW_LINE DEDENT DEDENT for i in range ( 97 , 97 + 26 ) : NEW_LINE INDENT c = chr ( i ) NEW_LINE if c in dct and dct . get ( c ) == 0 : NEW_LINE INDENT result = c NEW_LINE break NEW_LINE DEDENT DEDENT print ( result if result != ' ' else ' None ' ) NEW_LINE","s = list ( input ( ) ) NEW_LINE alpha = [ \" a \" , \" b \" , \" c \" , \" d \" , \" e \" , \" f \" , \" g \" , \" h \" , \" i \" , \" j \" , \" k \" , \" l \" , \" m \" , \" n \" , \" o \" , \" p \" , \" q \" , \" r \" , \" s \" , \" t \" , \" u \" , \" v \" , \" w \" , \" x \" , \" y \" , \" z \" ] NEW_LINE for x in s : NEW_LINE INDENT if x in alpha : NEW_LINE INDENT alpha . remove ( x ) NEW_LINE DEDENT DEDENT print ( alpha [ 0 ] if len ( alpha ) > 0 else \" None \" ) NEW_LINE"],"bleu":0.0591470873867589,"rouge_l":0.2494838935846999}
{"id":59,"predictions":["n = int ( input ( ) ) NEW_LINE print ( \" YES \" ) if sum ( [ int ( item ) for item in input ( ) . split ( ) ] ) < 0 else \" NO \" ) NEW_LINE"],"references":["N = int ( input ( ) ) NEW_LINE L = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE L . sort ( reverse = 1 ) NEW_LINE length = 0 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT length += L [ i ] NEW_LINE DEDENT if L [ 0 ] < length : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT","import numpy as np NEW_LINE N = int ( input ( ) ) NEW_LINE L = np . array ( [ int ( s ) for s in input ( ) . split ( ' ▁ ' ) ] ) NEW_LINE print ( ' Yes ' if np . max ( L ) < np . sum ( L ) - np . max ( L ) else ' No ' ) NEW_LINE","import sys NEW_LINE def ii2ss ( n ) : NEW_LINE INDENT return [ sys . stdin . readline ( ) for _ in range ( n ) ] NEW_LINE DEDENT def sp2nn ( sp , sep = ' ▁ ' ) : NEW_LINE INDENT return [ int ( s ) for s in sp . split ( sep ) ] NEW_LINE DEDENT def ss2nn ( ss ) : NEW_LINE INDENT return [ int ( s ) for s in list ( ss ) ] NEW_LINE DEDENT import functools as ft NEW_LINE def main2 ( L ) : NEW_LINE INDENT L . sort ( ) NEW_LINE lmax = L [ - 1 ] NEW_LINE lothers = ft . reduce ( lambda x , y : x + y , L [ : - 1 ] ) NEW_LINE b = lmax < lothers NEW_LINE return ' Yes ' if b else ' No ' NEW_LINE DEDENT def main ( ss ) : NEW_LINE INDENT L = sp2nn ( ss [ 1 ] ) NEW_LINE s = main2 ( L ) NEW_LINE print ( s ) NEW_LINE DEDENT main ( ii2ss ( 2 ) ) NEW_LINE","N = input ( ) NEW_LINE lst = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE maxval = max ( lst ) NEW_LINE lst . remove ( maxval ) NEW_LINE total = sum ( lst ) NEW_LINE if total > maxval : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT","N = int ( input ( ) ) NEW_LINE L = input ( ) . split ( ) NEW_LINE L_num = [ ] NEW_LINE for i in range ( len ( L ) ) : NEW_LINE INDENT L_num . append ( int ( L [ i ] ) ) NEW_LINE DEDENT L_num . sort ( ) NEW_LINE total = 0 NEW_LINE for j in range ( len ( L ) - 1 ) : NEW_LINE INDENT total += L_num [ j ] NEW_LINE DEDENT if total <= L_num [ N - 1 ] : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT"],"bleu":0.281010783617411,"rouge_l":0.46124763705103977}
{"id":60,"predictions":["N = int ( input ( ) ) NEW_LINE def sum_digit ( n ) : NEW_LINE INDENT s = 0 NEW_LINE while n > 0 : NEW_LINE INDENT s += n % 10 NEW_LINE n \/\/= 10 NEW_LINE DEDENT return s NEW_LINE DEDENT print ( sum_digit ( N ) ) NEW_LINE"],"references":["n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( max ( 1 , n - 200 ) , n ) : NEW_LINE INDENT if i + sum ( [ int ( x ) for x in list ( str ( i ) ) ] ) == n : NEW_LINE INDENT a . append ( i ) NEW_LINE DEDENT DEDENT print ( len ( a ) ) NEW_LINE for x in a : NEW_LINE INDENT print ( x ) NEW_LINE DEDENT","def f ( x ) : NEW_LINE INDENT res = 0 NEW_LINE while x > 0 : NEW_LINE INDENT res += x % 10 NEW_LINE x \/\/= 10 NEW_LINE DEDENT return res NEW_LINE DEDENT N = int ( input ( ) ) NEW_LINE ans = [ ] NEW_LINE for i in range ( N ) [ - 154 : ] : NEW_LINE INDENT j = i + 1 NEW_LINE if j + f ( j ) == N : NEW_LINE INDENT ans . append ( j ) NEW_LINE DEDENT DEDENT print ( len ( ans ) ) NEW_LINE for x in ans : NEW_LINE INDENT print ( x ) NEW_LINE DEDENT","def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE keta = len ( str ( n ) ) NEW_LINE li = [ ] NEW_LINE for i in range ( 1 , 9 * keta + 1 ) : NEW_LINE INDENT x = n - i NEW_LINE if f ( x ) == i : NEW_LINE INDENT li . append ( x ) NEW_LINE DEDENT DEDENT li . sort ( ) NEW_LINE print ( len ( li ) ) NEW_LINE for x in li : NEW_LINE INDENT print ( x ) NEW_LINE DEDENT DEDENT def f ( x ) : NEW_LINE INDENT if x < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT sx = str ( x ) NEW_LINE res = 0 NEW_LINE for c in sx : NEW_LINE INDENT res += int ( c ) NEW_LINE DEDENT return res NEW_LINE DEDENT main ( ) NEW_LINE","from collections import defaultdict , deque NEW_LINE import sys , heapq , bisect , math , itertools , string , queue , datetime NEW_LINE sys . setrecursionlimit ( 10 ** 8 ) NEW_LINE INF = float ( ' inf ' ) NEW_LINE mod = 10 ** 9 + 7 NEW_LINE eps = 10 ** - 7 NEW_LINE def inpl ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def inpls ( ) : return list ( input ( ) . split ( ) ) NEW_LINE def func ( N ) : NEW_LINE INDENT return sum ( map ( int , list ( str ( N ) ) ) ) NEW_LINE DEDENT N = int ( input ( ) ) NEW_LINE L = len ( str ( N ) ) NEW_LINE MIN = max ( N - 9 * L , 1 ) NEW_LINE ans = [ ] NEW_LINE for n in range ( MIN , N + 1 ) : NEW_LINE INDENT if n + func ( n ) == N : NEW_LINE INDENT ans . append ( n ) NEW_LINE DEDENT DEDENT print ( len ( ans ) ) NEW_LINE for a in ans : NEW_LINE INDENT print ( a ) NEW_LINE DEDENT","def b_equation ( N ) : NEW_LINE INDENT is_satisfy_equation = [ ] NEW_LINE for x in range ( N - 153 , N + 1 ) : NEW_LINE INDENT if x < 0 : NEW_LINE INDENT continue NEW_LINE DEDENT f = sum ( map ( int , list ( str ( x ) ) ) ) NEW_LINE if x + f == N : NEW_LINE INDENT is_satisfy_equation . append ( x ) NEW_LINE DEDENT DEDENT ans = ' \\n ' . join ( map ( str , [ len ( is_satisfy_equation ) ] + is_satisfy_equation ) ) NEW_LINE return ans NEW_LINE DEDENT N = int ( input ( ) ) NEW_LINE print ( b_equation ( N ) ) NEW_LINE"],"bleu":0.26921831200165586,"rouge_l":0.381622678396872}
{"id":61,"predictions":["n = int ( input ( ) ) a = [ int ( i ) for i in input ( ) . split ( ) ] s = abs ( a [ 0 ] - a [ 1 ] ) NEW_LINE"],"references":["N = int ( input ( ) ) NEW_LINE lr = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( N ) ] NEW_LINE print ( sum ( list ( zip ( * lr ) ) [ 1 ] ) - sum ( list ( zip ( * lr ) ) [ 0 ] ) + N ) NEW_LINE","_ , * t = open ( 0 ) ; print ( sum ( 1 - eval ( s . replace ( ' ▁ ' , ' - ' ) ) for s in t ) ) NEW_LINE","import sys NEW_LINE ns = lambda : sys . stdin . readline ( ) . rstrip ( ) NEW_LINE ni = lambda : int ( ns ( ) ) NEW_LINE nm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE nl = lambda : list ( nm ( ) ) NEW_LINE n = ni ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT l , r = nm ( ) NEW_LINE ans += r - l + 1 NEW_LINE DEDENT print ( ans ) NEW_LINE","N = int ( input ( ) ) NEW_LINE res = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT l , r = map ( int , input ( ) . split ( ) ) NEW_LINE res += r - l + 1 NEW_LINE DEDENT print ( res ) NEW_LINE","n = int ( input ( ) ) ; print ( sum ( list ( map ( lambda x : ( x [ 1 ] - x [ 0 ] + 1 ) , [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] ) ) ) ) NEW_LINE"],"bleu":0.519890490290442,"rouge_l":0.4654376650748339}
{"id":62,"predictions":["import sys NEW_LINE def input ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def ri ( ) : return int ( input ( ) ) NEW_LINE def ri ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def ri ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def sin ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def ls ( ) : return list ( input ( ) . strip ( ) ) NEW_LINE def ns ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def ns ( ) : return list ( ns ( ) ) NEW_LINE def ni ( ) : return int ( stdin . readline ( ) ) NEW_LINE def nf ( ) : return float ( stdin . readline ( ) ) NEW_LINE k = ni ( ) NEW_LINE a = list ( ns ( ) ) NEW_LINE s1 = list ( ns ( ) ) NEW_LINE s2 = list ( s1 ) NEW_LINE a . append ( s2 ) NEW_LINE n = len ( a ) NEW_LINE s3 = list ( s4 ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT if s3 [ i ] == ' - ' : NEW_LINE INDENT if s4 [ i ] == ' - ' : NEW_LINE INDENT continue NEW_LINE DEDENT elif s2 [ i ] == ' - ' : NEW_LINE INDENT if s4 [ i ] == ' - ' : NEW_LINE INDENT print ( ' - ' + a [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' - 1' ) NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT print ( ' - 1' ) NEW_LINE DEDENT"],"references":["n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE s = list ( map ( lambda x : 1 if x == \" o \" else - 1 , list ( s ) ) ) NEW_LINE flag = False NEW_LINE for start in [ [ 1 , 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] , [ - 1 , - 1 ] ] : NEW_LINE INDENT circle = start + [ 0 ] * ( n - 2 ) NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT circle [ i + 1 ] = circle [ i ] * s [ i ] * circle [ i - 1 ] NEW_LINE DEDENT if circle [ - 2 ] == circle [ - 1 ] * s [ - 1 ] * circle [ 0 ] and circle [ - 1 ] == circle [ 0 ] * s [ 0 ] * circle [ 1 ] : NEW_LINE INDENT flag = True NEW_LINE break NEW_LINE DEDENT DEDENT if flag : NEW_LINE INDENT ans = \" \" NEW_LINE for i in circle : NEW_LINE INDENT if i == 1 : NEW_LINE INDENT ans += \" S \" NEW_LINE DEDENT else : NEW_LINE INDENT ans += \" W \" NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT","N = int ( input ( ) ) NEW_LINE S = input ( ) NEW_LINE start_set = [ ] NEW_LINE start_set . append ( \" SS \" ) NEW_LINE start_set . append ( \" SW \" ) NEW_LINE start_set . append ( \" WS \" ) NEW_LINE start_set . append ( \" WW \" ) NEW_LINE def listed_goal_set ( i ) : NEW_LINE INDENT goal_set = [ ] NEW_LINE if S [ i ] == \" o \" : NEW_LINE INDENT goal_set . append ( \" SSS \" ) NEW_LINE goal_set . append ( \" WSW \" ) NEW_LINE goal_set . append ( \" WWS \" ) NEW_LINE goal_set . append ( \" SWW \" ) NEW_LINE DEDENT else : NEW_LINE INDENT goal_set . append ( \" WSS \" ) NEW_LINE goal_set . append ( \" SSW \" ) NEW_LINE goal_set . append ( \" WWW \" ) NEW_LINE goal_set . append ( \" SWS \" ) NEW_LINE DEDENT return goal_set NEW_LINE DEDENT goal_set1 = listed_goal_set ( 0 ) NEW_LINE goal_set2 = listed_goal_set ( - 1 ) NEW_LINE isok = False NEW_LINE for st in start_set : NEW_LINE INDENT O = [ ] NEW_LINE O . append ( st [ 0 ] ) NEW_LINE O . append ( st [ 1 ] ) NEW_LINE for i in range ( 1 , N - 1 ) : NEW_LINE INDENT if O [ i - 1 ] == \" S \" : NEW_LINE INDENT if O [ i ] == \" S \" : NEW_LINE INDENT if S [ i ] == \" o \" : NEW_LINE INDENT O . append ( \" S \" ) NEW_LINE DEDENT else : NEW_LINE INDENT O . append ( \" W \" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if S [ i ] == \" o \" : NEW_LINE INDENT O . append ( \" W \" ) NEW_LINE DEDENT else : NEW_LINE INDENT O . append ( \" S \" ) NEW_LINE DEDENT DEDENT DEDENT if O [ i - 1 ] == \" W \" : NEW_LINE INDENT if O [ i ] == \" S \" : NEW_LINE INDENT if S [ i ] == \" o \" : NEW_LINE INDENT O . append ( \" W \" ) NEW_LINE DEDENT else : NEW_LINE INDENT O . append ( \" S \" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if S [ i ] == \" o \" : NEW_LINE INDENT O . append ( \" S \" ) NEW_LINE DEDENT else : NEW_LINE INDENT O . append ( \" W \" ) NEW_LINE DEDENT DEDENT DEDENT DEDENT goals1 = O [ - 1 ] + O [ 0 ] + O [ 1 ] NEW_LINE goals2 = O [ - 2 ] + O [ - 1 ] + O [ 0 ] NEW_LINE if goals1 in goal_set1 and goals2 in goal_set2 : NEW_LINE INDENT isok = True NEW_LINE break NEW_LINE DEDENT DEDENT if isok : NEW_LINE INDENT print ( \" \" . join ( O ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT","import sys NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE input = sys . stdin . readline NEW_LINE N = int ( input ( ) ) NEW_LINE s = input ( ) [ : - 1 ] NEW_LINE ans = [ 1 ] * ( N + 2 ) NEW_LINE def print_ans ( l : list ) : NEW_LINE INDENT ret = \" \" NEW_LINE for a in l [ 1 : - 1 ] : NEW_LINE INDENT ret += \" S \" if a else \" W \" NEW_LINE DEDENT print ( ret ) NEW_LINE DEDENT def next ( ind : int , isSame : bool , isSheep : bool ) -> bool : NEW_LINE INDENT if isSame : NEW_LINE INDENT if isSheep : NEW_LINE INDENT return ans [ ind - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT return not ans [ ind - 1 ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if isSheep : NEW_LINE INDENT return not ans [ ind - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT return ans [ ind - 1 ] NEW_LINE DEDENT DEDENT return isSame ^ isSheep ^ ans [ ind - 1 ] NEW_LINE DEDENT def check ( first : bool , last : bool ) -> list : NEW_LINE INDENT ans [ 0 ] = last NEW_LINE ans [ 1 ] = first NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT ans [ i + 1 ] = next ( i , s [ i - 1 ] == \" o \" , ans [ i ] ) NEW_LINE DEDENT return ans [ 0 ] == ans [ N ] and ans [ 1 ] == ans [ N + 1 ] NEW_LINE DEDENT for first in [ True , False ] : NEW_LINE INDENT for last in [ True , False ] : NEW_LINE INDENT if check ( first , last ) : NEW_LINE INDENT print_ans ( ans ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT DEDENT print ( \" - 1\" ) NEW_LINE","N = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE S = [ 1 if i == \" o \" else - 1 for i in s ] NEW_LINE X = [ [ 0 for i in range ( N ) ] for i in range ( 4 ) ] NEW_LINE X [ 0 ] [ 0 ] = 1 NEW_LINE X [ 0 ] [ 1 ] = 1 NEW_LINE X [ 1 ] [ 0 ] = 1 NEW_LINE X [ 1 ] [ 1 ] = - 1 NEW_LINE X [ 2 ] [ 0 ] = - 1 NEW_LINE X [ 2 ] [ 1 ] = 1 NEW_LINE X [ 3 ] [ 0 ] = - 1 NEW_LINE X [ 3 ] [ 1 ] = - 1 NEW_LINE for k in range ( 4 ) : NEW_LINE INDENT for i in range ( 2 , N ) : NEW_LINE INDENT if S [ i - 1 ] * X [ k ] [ i - 1 ] == 1 : NEW_LINE INDENT X [ k ] [ i ] = X [ k ] [ i - 2 ] NEW_LINE DEDENT else : NEW_LINE INDENT X [ k ] [ i ] = - X [ k ] [ i - 2 ] NEW_LINE DEDENT DEDENT flag = 0 NEW_LINE for i in range ( 2 ) : NEW_LINE INDENT if S [ i - 1 ] * X [ k ] [ i - 1 ] == 1 : NEW_LINE INDENT if X [ k ] [ i ] != X [ k ] [ i - 2 ] : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if X [ k ] [ i ] != - X [ k ] [ i - 2 ] : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT DEDENT DEDENT if flag == 0 : NEW_LINE INDENT T = \" \" NEW_LINE for i in range ( N ) : NEW_LINE INDENT if X [ k ] [ i ] == 1 : NEW_LINE INDENT T = T + \" S \" NEW_LINE DEDENT else : NEW_LINE INDENT T = T + \" W \" NEW_LINE DEDENT DEDENT print ( T ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT print ( - 1 ) NEW_LINE","def getSpecies ( sw , ox , swAdj ) : NEW_LINE INDENT if ( sw == ' S ' and ox == ' o ' ) or ( sw == ' W ' and ox == ' x ' ) : NEW_LINE INDENT return swAdj NEW_LINE DEDENT else : NEW_LINE INDENT return ' SW ' [ swAdj == ' S ' ] NEW_LINE DEDENT DEDENT N = int ( input ( ) ) NEW_LINE ss = input ( ) NEW_LINE for pat in [ ' SS ' , ' SW ' , ' WS ' , ' WW ' ] : NEW_LINE INDENT anss = list ( pat ) + [ ' ' ] * ( N - 2 ) NEW_LINE for i in range ( 1 , N - 1 ) : NEW_LINE INDENT anss [ i + 1 ] = getSpecies ( anss [ i ] , ss [ i ] , anss [ i - 1 ] ) NEW_LINE DEDENT if ( getSpecies ( anss [ - 1 ] , ss [ - 1 ] , anss [ - 2 ] ) == anss [ 0 ] ) and ( getSpecies ( anss [ 0 ] , ss [ 0 ] , anss [ - 1 ] ) == anss [ 1 ] ) : NEW_LINE INDENT print ( ' ' . join ( anss ) ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT"],"bleu":0.26860596578643264,"rouge_l":0.38122580859594923}
{"id":63,"predictions":["l = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE print ( ' YES ' if l [ 0 ] % l [ 1 ] == l [ 2 ] else ' NO ' ) NEW_LINE"],"references":["print ( \" YNEOS \" [ eval ( input ( ) . replace ( ' ▁ ' , ' % ' ) ) > 0 : : 2 ] ) NEW_LINE","s = input ( ) . split ( ) NEW_LINE A = int ( s [ 0 ] ) NEW_LINE B = int ( s [ 1 ] ) NEW_LINE if A % B == 0 : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT elif A % B != 0 : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT","l = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE print ( ' YES ' if l [ 0 ] % l [ 1 ] == 0 else ' NO ' ) NEW_LINE","A , B = map ( int , input ( ) . split ( ) ) NEW_LINE if ( A % B == 0 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT","print ( ' YNEOS ' [ eval ( input ( ) . replace ( ' ▁ ' , ' % ' ) + ' > 0' ) : : 2 ] ) NEW_LINE"],"bleu":0.8858531484165717,"rouge_l":0.9484262419416002}
{"id":64,"predictions":["MOD = 10 ** 9 + 7 NEW_LINE N = int ( input ( ) ) NEW_LINE binN = list ( map ( lambda x : int ( x ) - 1 , bin ( N ) [ 2 : ] ) ) NEW_LINE dp = [ [ 0 ] * 2 for _ in range ( N + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE dp [ 1 ] [ 0 ] = 1 NEW_LINE for i , val in enumerate ( binN ) : NEW_LINE INDENT if val == '0' : NEW_LINE INDENT dp [ i + 1 ] [ 0 ] += dp [ i ] [ 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i + 1 ] [ 0 ] += dp [ i ] [ 1 ] NEW_LINE dp [ i + 1 ] [ 1 ] += dp [ i ] [ 2 ] NEW_LINE DEDENT DEDENT print ( dp [ N ] [ 2 ] - 1 ] ) NEW_LINE"],"references":["from bisect import bisect NEW_LINE n = int ( input ( ) ) NEW_LINE d = [ int ( input ( ) ) for i in range ( n ) ] NEW_LINE a , d , mod , ans = [ ] , sorted ( d ) , 10 ** 9 + 7 , 0 NEW_LINE for i in range ( n ) : a . append ( n - bisect ( d , d [ i ] * 2 - 1 ) ) NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : a [ i ] += a [ i + 1 ] NEW_LINE for i in range ( n ) : ans = ( ans + bisect ( d , d [ i ] \/\/ 2 ) * a [ min ( n - 1 , bisect ( d , d [ i ] * 2 - 1 ) ) ] ) % mod NEW_LINE print ( ans ) NEW_LINE","import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE inf = 10 ** 20 NEW_LINE mod = 10 ** 9 + 7 NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def F ( ) : return float ( sys . stdin . readline ( ) ) NEW_LINE def S ( ) : return input ( ) NEW_LINE def main ( ) : NEW_LINE INDENT n = I ( ) NEW_LINE d = sorted ( [ I ( ) for _ in range ( n ) ] ) NEW_LINE a = [ 1 ] * n NEW_LINE for _ in range ( 3 ) : NEW_LINE INDENT j = 1 NEW_LINE t = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT i2 = d [ i ] * 2 NEW_LINE while j < n and d [ j ] < i2 : NEW_LINE INDENT j += 1 NEW_LINE DEDENT if j == n : NEW_LINE INDENT break NEW_LINE DEDENT t [ j ] += a [ i ] NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT t [ i ] += t [ i - 1 ] NEW_LINE DEDENT a = t NEW_LINE DEDENT return sum ( a ) % mod NEW_LINE DEDENT print ( main ( ) ) NEW_LINE","from bisect import bisect_left NEW_LINE def inpl ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE N = int ( input ( ) ) NEW_LINE D = sorted ( [ int ( input ( ) ) for _ in range ( N ) ] ) NEW_LINE S = [ 1 ] * ( N ) NEW_LINE for _ in range ( 3 ) : NEW_LINE INDENT DP = [ 0 ] * ( N ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT j = bisect_left ( D , D [ i ] * 2 ) NEW_LINE if j != N : NEW_LINE INDENT DP [ j ] = ( DP [ j ] + S [ i ] ) % MOD NEW_LINE DEDENT DEDENT S = [ 0 ] * ( N ) NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT S [ i ] = ( DP [ i ] + S [ i - 1 ] ) % MOD NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT ans = ( ans + S [ i ] ) % MOD NEW_LINE DEDENT print ( ans ) NEW_LINE","import bisect NEW_LINE n = int ( input ( ) ) NEW_LINE d = [ int ( input ( ) ) for i in range ( n ) ] NEW_LINE d . sort ( ) NEW_LINE m = 10 ** 9 + 7 NEW_LINE third = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT third [ i ] = n - bisect . bisect_left ( d , d [ i ] * 2 ) NEW_LINE DEDENT sthird = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT sthird [ i ] = ( sthird [ i + 1 ] + third [ i ] ) % m NEW_LINE DEDENT second = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT k = n - third [ i ] NEW_LINE second [ i ] = sthird [ k ] NEW_LINE DEDENT Ssecond = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT Ssecond [ i ] = ( Ssecond [ i + 1 ] + second [ i ] ) % m NEW_LINE DEDENT first = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT k = n - third [ i ] NEW_LINE first [ i ] = Ssecond [ k ] NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res = ( res + first [ i ] ) % m NEW_LINE DEDENT print ( res ) NEW_LINE","N = int ( input ( ) ) NEW_LINE M = 100000 NEW_LINE X = [ [ 0 ] * ( M + 1 ) for i in range ( 4 ) ] NEW_LINE D = [ ] NEW_LINE for _ in range ( N ) : NEW_LINE INDENT d = int ( input ( ) ) NEW_LINE D . append ( d ) NEW_LINE X [ 0 ] [ d ] += 1 NEW_LINE DEDENT for k in range ( 4 ) : NEW_LINE INDENT for i in range ( 1 , M + 1 ) : NEW_LINE INDENT X [ k ] [ i ] += X [ k ] [ i - 1 ] NEW_LINE DEDENT if k == 3 : NEW_LINE INDENT break NEW_LINE DEDENT for d in D : NEW_LINE INDENT X [ k + 1 ] [ d ] += X [ k ] [ d \/\/ 2 ] NEW_LINE DEDENT DEDENT print ( X [ 3 ] [ - 1 ] % ( 10 ** 9 + 7 ) ) NEW_LINE"],"bleu":0.45916018801753183,"rouge_l":0.49537916191923037}
{"id":65,"predictions":["import itertools NEW_LINE import collections NEW_LINE import bisect NEW_LINE def main ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE A = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE B = collections . Counter ( A ) NEW_LINE ans = 0 NEW_LINE for pair in A : NEW_LINE INDENT if pair [ 1 ] % 2 == 1 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"references":["import bisect NEW_LINE n = int ( input ( ) ) NEW_LINE l = [ ] NEW_LINE e = [ ] NEW_LINE for i in range ( n \/\/ 2 ) : NEW_LINE INDENT j = int ( input ( ) ) NEW_LINE e . append ( j ) NEW_LINE l . append ( j ) NEW_LINE j = int ( input ( ) ) NEW_LINE l . append ( j ) NEW_LINE DEDENT if n % 2 == 1 : NEW_LINE INDENT j = int ( input ( ) ) NEW_LINE e . append ( j ) NEW_LINE l . append ( j ) NEW_LINE DEDENT l . sort ( ) NEW_LINE e . sort ( ) NEW_LINE res = 0 NEW_LINE for i in range ( 0 , n , 2 ) : NEW_LINE INDENT if e [ min ( len ( e ) - 1 , bisect . bisect_left ( e , l [ i ] ) ) ] != l [ i ] : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE","import sys NEW_LINE INF = float ( ' inf ' ) NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def II ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def SI ( ) : return input ( ) NEW_LINE def main ( ) : NEW_LINE INDENT n = II ( ) NEW_LINE A = [ II ( ) for _ in range ( n ) ] NEW_LINE B = A [ : ] NEW_LINE A . sort ( ) NEW_LINE return ( n + 1 ) \/\/ 2 - len ( set ( A [ : : 2 ] ) & set ( B [ : : 2 ] ) ) NEW_LINE DEDENT print ( main ( ) ) NEW_LINE","from collections import defaultdict , deque NEW_LINE import sys , heapq , bisect , math , itertools , string , queue , datetime NEW_LINE sys . setrecursionlimit ( 10 ** 8 ) NEW_LINE INF = float ( ' inf ' ) NEW_LINE mod = 10 ** 9 + 7 NEW_LINE eps = 10 ** - 7 NEW_LINE def inpl ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def inpls ( ) : return list ( input ( ) . split ( ) ) NEW_LINE N = int ( input ( ) ) NEW_LINE aa = [ int ( input ( ) ) for i in range ( N ) ] NEW_LINE cnt = defaultdict ( lambda : [ 0 , 0 ] ) NEW_LINE for i , a in enumerate ( aa ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT cnt [ a ] [ 0 ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt [ a ] [ 1 ] += 1 NEW_LINE DEDENT DEDENT aa . sort ( ) NEW_LINE ans = 0 NEW_LINE for i , a in enumerate ( aa ) : NEW_LINE INDENT ev , od = cnt [ a ] NEW_LINE if i % 2 == 0 : NEW_LINE INDENT if ev == 0 : NEW_LINE INDENT ans += 1 NEW_LINE cnt [ a ] [ 0 ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt [ a ] [ 1 ] -= 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if od == 0 : NEW_LINE INDENT ans += 1 NEW_LINE cnt [ a ] [ 0 ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt [ a ] [ 1 ] -= 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans \/\/ 2 ) NEW_LINE","print ( sum ( a [ 1 ] % 2 for a in sorted ( ( int ( input ( ) ) , i ) for i in range ( int ( input ( ) ) ) ) [ : : 2 ] ) ) NEW_LINE","import sys NEW_LINE stdin = sys . stdin NEW_LINE def li ( ) : return map ( int , stdin . readline ( ) . split ( ) ) NEW_LINE def li_ ( ) : return map ( lambda x : int ( x ) - 1 , stdin . readline ( ) . split ( ) ) NEW_LINE def lf ( ) : return map ( float , stdin . readline ( ) . split ( ) ) NEW_LINE def ls ( ) : return stdin . readline ( ) . split ( ) NEW_LINE def ns ( ) : return stdin . readline ( ) . rstrip ( ) NEW_LINE def lc ( ) : return list ( ns ( ) ) NEW_LINE def ni ( ) : return int ( stdin . readline ( ) ) NEW_LINE def nf ( ) : return float ( stdin . readline ( ) ) NEW_LINE from bisect import bisect_left NEW_LINE dic = dict ( ) NEW_LINE n = ni ( ) NEW_LINE a = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT a . append ( ni ( ) ) NEW_LINE DEDENT b = sorted ( a ) NEW_LINE for i , ai in enumerate ( a ) : NEW_LINE INDENT dic [ ai ] = ( i , bisect_left ( b , ai ) ) NEW_LINE DEDENT cnt = 0 NEW_LINE for ord1 , ord2 in dic . values ( ) : NEW_LINE INDENT if ord1 % 2 != ord2 % 2 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT print ( cnt \/\/ 2 ) NEW_LINE"],"bleu":0.6418826569161056,"rouge_l":0.5366009132843467}
{"id":66,"predictions":["n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE d = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT d += a [ i ] - a [ i - 1 ] NEW_LINE DEDENT print ( d ) NEW_LINE"],"references":["import sys NEW_LINE from operator import itemgetter NEW_LINE N = int ( input ( ) ) NEW_LINE sorted_l = sorted ( ( tuple ( map ( int , l . split ( ) ) ) for l in sys . stdin ) , reverse = True ) NEW_LINE sorted_r = sorted ( sorted_l , key = itemgetter ( 1 ) ) NEW_LINE pos1 , ans1 = 0 , 0 NEW_LINE pos2 , ans2 = 0 , 0 NEW_LINE for i , j in enumerate ( i \/\/ 2 for i in range ( N ) ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT dist1 , dist2 = max ( sorted_l [ j ] [ 0 ] - pos1 , 0 ) , max ( pos2 - sorted_r [ j ] [ 1 ] , 0 ) NEW_LINE pos1 , ans1 = pos1 + dist1 , ans1 + dist1 NEW_LINE pos2 , ans2 = pos2 - dist2 , ans2 + dist2 NEW_LINE DEDENT else : NEW_LINE INDENT dist1 , dist2 = max ( pos1 - sorted_r [ j ] [ 1 ] , 0 ) , max ( sorted_l [ j ] [ 0 ] - pos2 , 0 ) NEW_LINE pos1 , ans1 = pos1 - dist1 , ans1 + dist1 NEW_LINE pos2 , ans2 = pos2 + dist2 , ans2 + dist2 NEW_LINE DEDENT DEDENT print ( max ( ans1 + abs ( pos1 ) , ans2 + abs ( pos2 ) ) ) NEW_LINE","from sys import stdin NEW_LINE in_strings = lambda : stdin . readline ( ) [ : - 1 ] NEW_LINE in_int = lambda : int ( stdin . readline ( ) ) NEW_LINE in_intlist = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) NEW_LINE N = in_int ( ) NEW_LINE L_list = [ ] NEW_LINE R_list = [ ] NEW_LINE for _ in range ( N ) : NEW_LINE INDENT temp = in_intlist ( ) NEW_LINE L_list . append ( temp [ 0 ] ) NEW_LINE R_list . append ( temp [ 1 ] ) NEW_LINE DEDENT L_list . sort ( reverse = True ) NEW_LINE R_list . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( L_list [ i ] - R_list [ i ] ) > 0 : NEW_LINE INDENT ans += 2 * ( L_list [ i ] - R_list [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( L_list [ i ] <= 0 ) and ( R_list [ i ] >= 0 ) : NEW_LINE INDENT pass NEW_LINE DEDENT elif L_list [ i ] > 0 : NEW_LINE INDENT if ( i > 0 ) and ( L_list [ i ] < R_list [ i - 1 ] ) : NEW_LINE INDENT ans += 2 * R_list [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT ans += 2 * L_list [ i ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( i > 0 ) and ( R_list [ i ] > L_list [ i - 1 ] ) : NEW_LINE INDENT ans -= 2 * L_list [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT ans -= 2 * R_list [ i ] NEW_LINE DEDENT DEDENT break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE","from sys import exit , setrecursionlimit , stderr NEW_LINE from functools import reduce NEW_LINE from itertools import * NEW_LINE from collections import defaultdict NEW_LINE from bisect import bisect NEW_LINE def read ( ) : NEW_LINE INDENT return int ( input ( ) ) NEW_LINE DEDENT def reads ( ) : NEW_LINE INDENT return [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE DEDENT N = read ( ) NEW_LINE L = [ ] NEW_LINE R = [ ] NEW_LINE for _ in range ( N ) : NEW_LINE INDENT ( l , r ) = reads ( ) NEW_LINE L . append ( l ) NEW_LINE R . append ( - r ) NEW_LINE DEDENT L . sort ( ) ; L . reverse ( ) NEW_LINE R . sort ( ) ; R . reverse ( ) NEW_LINE psumL = [ 0 ] * ( N + 1 ) NEW_LINE psumR = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT psumL [ i + 1 ] = psumL [ i ] + L [ i ] NEW_LINE psumR [ i + 1 ] = psumR [ i ] + R [ i ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT ans = max ( ans , psumL [ i ] + psumR [ i ] ) NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT ans = max ( ans , psumL [ i ] + psumR [ i + 1 ] ) NEW_LINE ans = max ( ans , psumL [ i + 1 ] + psumR [ i ] ) NEW_LINE DEDENT print ( ans * 2 ) NEW_LINE","import sys NEW_LINE def get_checks ( lefts , rights , used ) : NEW_LINE INDENT def left_check ( pos ) : NEW_LINE INDENT while lefts : NEW_LINE INDENT e , i = lefts . pop ( ) NEW_LINE if not used [ i ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return None NEW_LINE DEDENT used [ i ] = True NEW_LINE if pos >= e : NEW_LINE INDENT return None NEW_LINE DEDENT return e NEW_LINE DEDENT def right_check ( pos ) : NEW_LINE INDENT while rights : NEW_LINE INDENT e , i = rights . pop ( ) NEW_LINE if not used [ i ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return None NEW_LINE DEDENT used [ i ] = True NEW_LINE if pos <= e : NEW_LINE INDENT return None NEW_LINE DEDENT return e NEW_LINE DEDENT return left_check , right_check NEW_LINE DEDENT def simulate ( left_first = True ) : NEW_LINE INDENT ans = 0 NEW_LINE pos = 0 NEW_LINE _lefts = lefts . copy ( ) NEW_LINE _rights = rights . copy ( ) NEW_LINE used = [ False ] * n NEW_LINE left_check , right_check = get_checks ( _lefts , _rights , used ) NEW_LINE funcs = [ left_check , right_check ] if left_first else [ right_check , left_check ] NEW_LINE dir = 0 NEW_LINE while True : NEW_LINE INDENT e = funcs [ dir ] ( pos ) NEW_LINE if e is None : NEW_LINE INDENT break NEW_LINE DEDENT ans += abs ( e - pos ) NEW_LINE pos = e NEW_LINE dir ^= 1 NEW_LINE DEDENT ans += abs ( pos ) NEW_LINE return ans NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE lefts , rights = [ ] , [ ] NEW_LINE for i , line in enumerate ( sys . stdin . readlines ( ) ) : NEW_LINE INDENT l , r = map ( int , line . split ( ) ) NEW_LINE lefts . append ( ( l , i ) ) NEW_LINE rights . append ( ( r , i ) ) NEW_LINE DEDENT lefts . sort ( ) NEW_LINE rights . sort ( reverse = True ) NEW_LINE lf = simulate ( True ) NEW_LINE rf = simulate ( False ) NEW_LINE print ( max ( lf , rf ) ) NEW_LINE","N = int ( input ( ) ) NEW_LINE intervals = tuple ( tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ) NEW_LINE L = sorted ( ( l for l , r in intervals ) ) NEW_LINE R = sorted ( ( r for l , r in intervals ) , reverse = True ) NEW_LINE def helper ( L , R , turn ) : NEW_LINE INDENT x = 0 NEW_LINE cost = 0 NEW_LINE T = [ L , None , R ] NEW_LINE while True : NEW_LINE INDENT y = T [ turn + 1 ] . pop ( ) NEW_LINE if turn * ( y - x ) < 0 : NEW_LINE INDENT cost += abs ( x - y ) NEW_LINE x = y NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT turn *= - 1 NEW_LINE DEDENT cost += abs ( x ) NEW_LINE return cost NEW_LINE DEDENT print ( max ( helper ( L . copy ( ) , R . copy ( ) , t ) for t in ( - 1 , 1 ) ) ) NEW_LINE"],"bleu":0.09160639419359985,"rouge_l":0.3244721050957913}
{"id":67,"predictions":["n , m , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE x = [ ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT x . append ( float ( i * a ) \/ b ) NEW_LINE DEDENT if n % a == 0 : NEW_LINE INDENT print ( ' { } \\n ' . format ( x ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' { } ▁ { } ' . format ( x [ 0 ] - x [ 1 ] ) ) NEW_LINE DEDENT"],"references":["n , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE s = [ int ( input ( ) ) for i in range ( n ) ] NEW_LINE d = max ( s ) - min ( s ) NEW_LINE if d != 0 : NEW_LINE INDENT print ( b \/ d , a - ( sum ( s ) \/ n ) * ( b \/ d ) ) NEW_LINE DEDENT else : NEW_LINE INDENT if b != 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 , a - s [ 0 ] ) NEW_LINE DEDENT DEDENT","def a_transformation ( N , A , B , S ) : NEW_LINE INDENT e = sum ( S ) \/ N NEW_LINE d = max ( S ) - min ( S ) NEW_LINE if d == 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT p = B \/ d NEW_LINE q = A - ( e * B ) \/ d NEW_LINE ans = ' { 0 : . 09f } ▁ { 1 : . 09f } ' . format ( p , q ) NEW_LINE return ans NEW_LINE DEDENT N , A , B = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE S = [ int ( input ( ) ) for _ in [ 0 ] * N ] NEW_LINE print ( a_transformation ( N , A , B , S ) ) NEW_LINE","n , a , b , * s = map ( int , open ( 0 ) . read ( ) . split ( ) ) NEW_LINE M , m = max ( s ) , min ( s ) NEW_LINE d = M - m NEW_LINE if not d : NEW_LINE INDENT print ( - 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT p = b \/ d NEW_LINE q = a - sum ( map ( lambda x : p * x , s ) ) \/ n NEW_LINE print ( p , q ) NEW_LINE","import sys NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE input = sys . stdin . readline NEW_LINE N , A , B = map ( int , input ( ) . split ( ) ) NEW_LINE L = [ int ( input ( ) ) for _ in range ( N ) ] NEW_LINE me = sum ( L ) \/ N NEW_LINE diff = max ( L ) - min ( L ) NEW_LINE if diff == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT P = B \/ ( diff ) NEW_LINE Q = A - P * me NEW_LINE print ( P , Q ) NEW_LINE DEDENT","n , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE S = [ int ( input ( ) ) for i in range ( n ) ] NEW_LINE S . sort ( ) NEW_LINE ave = sum ( S ) \/ n NEW_LINE d = S [ - 1 ] - S [ 0 ] NEW_LINE if d == 0 : NEW_LINE INDENT if b != d : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 , a - ave ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT p = b \/ d NEW_LINE print ( p , a - p * ave ) NEW_LINE DEDENT"],"bleu":0.5143726058029015,"rouge_l":0.5422617312736812}
{"id":68,"predictions":["def inpl ( ) : return [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE import bisect NEW_LINE N = int ( input ( ) ) NEW_LINE A = sorted ( inpl ( ) ) NEW_LINE B = inpl ( ) NEW_LINE C = inpl ( ) NEW_LINE ans = 0 NEW_LINE for b in B : NEW_LINE INDENT ans += bisect . bisect_left ( A , b ) * ( N - K + bisect . bisect_right ( C , b ) ) NEW_LINE DEDENT print ( ans ) NEW_LINE"],"references":["n = int ( input ( ) ) NEW_LINE k = 1000000 NEW_LINE nums = [ 0 for _ in range ( k + 2 ) ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE nums [ a ] += 1 NEW_LINE nums [ b + 1 ] -= 1 NEW_LINE DEDENT for i in range ( 1 , k + 1 ) : NEW_LINE INDENT nums [ i ] += nums [ i - 1 ] NEW_LINE DEDENT print ( max ( nums ) ) NEW_LINE","import numpy as np NEW_LINE n = int ( input ( ) ) NEW_LINE memo = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT a , b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE memo . append ( ( a , - 1 ) ) NEW_LINE memo . append ( ( b , + 1 ) ) NEW_LINE DEDENT memo . sort ( ) NEW_LINE print ( - np . array ( [ x [ 1 ] for x in memo ] ) . cumsum ( ) . min ( ) ) NEW_LINE","from statistics import mean , median , variance , stdev NEW_LINE import numpy as np NEW_LINE import sys NEW_LINE import math NEW_LINE import fractions NEW_LINE import itertools NEW_LINE import copy NEW_LINE from operator import itemgetter NEW_LINE def j ( q ) : NEW_LINE INDENT if q == 1 : print ( \" Yes \" ) NEW_LINE else : print ( \" No \" ) NEW_LINE exit ( 0 ) NEW_LINE DEDENT def ct ( x , y ) : NEW_LINE INDENT if ( x > y ) : print ( \" + \" ) NEW_LINE elif ( x < y ) : print ( \" - \" ) NEW_LINE else : print ( \" ? \" ) NEW_LINE DEDENT def ip ( ) : NEW_LINE INDENT return int ( input ( ) ) NEW_LINE DEDENT def pne ( n ) : NEW_LINE INDENT print ( n , end = ' ' ) NEW_LINE DEDENT rem = pow ( 10 , 9 ) + 7 NEW_LINE n = ip ( ) NEW_LINE add = [ 0 for i in range ( 1000002 ) ] NEW_LINE subtract = [ 0 for i in range ( 1000002 ) ] NEW_LINE a = [ ] NEW_LINE s = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT left , right = ( int ( i ) for i in input ( ) . split ( ) ) NEW_LINE add [ left ] += 1 NEW_LINE subtract [ right ] += 1 NEW_LINE s . add ( left ) NEW_LINE s . add ( right ) NEW_LINE DEDENT t = \"01\" NEW_LINE c = 0 NEW_LINE ans = 0 NEW_LINE l = list ( s ) NEW_LINE l . sort ( ) NEW_LINE for i in range ( len ( l ) ) : NEW_LINE INDENT k = l [ i ] NEW_LINE c += add [ k ] NEW_LINE ans = max ( c , ans ) NEW_LINE c -= subtract [ k ] NEW_LINE DEDENT print ( ans ) NEW_LINE","m = 1000001 NEW_LINE n = int ( input ( ) ) NEW_LINE ab = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] NEW_LINE a = sorted ( [ abi [ 0 ] for abi in ab ] ) NEW_LINE b = sorted ( [ abi [ 1 ] for abi in ab ] ) NEW_LINE A = [ 0 ] * m NEW_LINE B = [ 0 ] * m NEW_LINE Sa = [ 0 ] * m NEW_LINE Sb = [ 0 ] * m NEW_LINE for i in range ( n ) : NEW_LINE INDENT A [ a [ i ] ] += 1 NEW_LINE B [ b [ i ] ] += 1 NEW_LINE DEDENT Sa [ 0 ] = A [ 0 ] NEW_LINE Sb [ 0 ] = 0 NEW_LINE for i in range ( 1 , m ) : NEW_LINE INDENT Sa [ i ] = Sa [ i - 1 ] + A [ i ] NEW_LINE Sb [ i ] = Sb [ i - 1 ] + B [ i - 1 ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT ans = max ( ans , Sa [ i ] - Sb [ i ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE","import sys NEW_LINE input = sys . stdin . readline NEW_LINE inf = 10 ** 18 NEW_LINE n = int ( input ( ) ) NEW_LINE ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] NEW_LINE imos = [ 0 ] * 1000002 NEW_LINE for ai , bi in ab : NEW_LINE INDENT imos [ ai ] += 1 NEW_LINE imos [ bi + 1 ] -= 1 NEW_LINE DEDENT pop = [ 0 ] * 1000001 NEW_LINE tmp = 0 NEW_LINE for i , imosi in enumerate ( imos ) : NEW_LINE INDENT if i == 1000001 : break NEW_LINE tmp += imosi NEW_LINE pop [ i ] = tmp NEW_LINE DEDENT print ( max ( pop ) ) NEW_LINE"],"bleu":0.4595267583499955,"rouge_l":0.408634898465259}
{"id":69,"predictions":["s = list ( input ( ) ) NEW_LINE t = int ( input ( ) ) NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE d = 0 NEW_LINE count = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == ' U ' : NEW_LINE INDENT continue NEW_LINE DEDENT elif s [ i ] == ' L ' : NEW_LINE INDENT x -= 1 NEW_LINE DEDENT elif s [ i ] == ' R ' : NEW_LINE INDENT y += 1 NEW_LINE DEDENT elif s [ i ] == ' D ' : NEW_LINE INDENT count += 1 NEW_LINE DEDENT elif s [ i ] == ' L ' : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if t == 1 : NEW_LINE INDENT print ( - count ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - count ) NEW_LINE DEDENT"],"references":["x , y , w = input ( ) . split ( ) NEW_LINE x , y = int ( x ) + 7 , int ( y ) + 7 NEW_LINE A = [ input ( ) for i in range ( 9 ) ] NEW_LINE B = [ a [ 1 : ] [ : : - 1 ] + a + a [ : - 1 ] [ : : - 1 ] for a in A ] NEW_LINE C = B [ 1 : ] [ : : - 1 ] + B + B [ : - 1 ] [ : : - 1 ] NEW_LINE D = { ' R ' : ( 1 , 0 ) , ' L ' : ( - 1 , 0 ) , ' U ' : ( 0 , - 1 ) , ' D ' : ( 0 , 1 ) , ' RU ' : ( 1 , - 1 ) , ' RD ' : ( 1 , 1 ) , ' LU ' : ( - 1 , - 1 ) , ' LD ' : ( - 1 , 1 ) } NEW_LINE ans = C [ y ] [ x ] NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT dx , dy = D [ w ] NEW_LINE x += dx NEW_LINE y += dy NEW_LINE ans += C [ y ] [ x ] NEW_LINE DEDENT print ( ans ) NEW_LINE","def b_card ( X , Y , W , C ) : NEW_LINE INDENT h , w = Y - 1 , X - 1 NEW_LINE if ' R ' in W : NEW_LINE INDENT dw = 1 NEW_LINE DEDENT elif ' L ' in W : NEW_LINE INDENT dw = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT dw = 0 NEW_LINE DEDENT if ' U ' in W : NEW_LINE INDENT dh = - 1 NEW_LINE DEDENT elif ' D ' in W : NEW_LINE INDENT dh = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dh = 0 NEW_LINE DEDENT ans = ' ' NEW_LINE for k in range ( 4 ) : NEW_LINE INDENT ans += C [ h ] [ w ] NEW_LINE is_changed = False NEW_LINE nh , nw = h + dh , w + dw NEW_LINE move_tmp = ' ' NEW_LINE if not ( 0 <= nh < 9 ) : NEW_LINE INDENT is_changed = True NEW_LINE dh *= - 1 NEW_LINE DEDENT if not ( 0 <= nw < 9 ) : NEW_LINE INDENT is_changed = True NEW_LINE dw *= - 1 NEW_LINE DEDENT if is_changed : NEW_LINE INDENT nh , nw = h + dh , w + dw NEW_LINE DEDENT h , w = nh , nw NEW_LINE DEDENT return ans NEW_LINE DEDENT X , Y , W = [ int ( i ) if i . isdigit ( ) else i for i in input ( ) . split ( ) ] NEW_LINE C = [ input ( ) for _ in range ( 9 ) ] NEW_LINE print ( b_card ( X , Y , W , C ) ) NEW_LINE","x , y , W = [ ( int ( x ) , int ( y ) , W ) for x , y , W in [ input ( ) . split ( ) ] ] [ 0 ] NEW_LINE c = [ input ( ) for _ in range ( 9 ) ] NEW_LINE def f ( k , i , j , di , dj ) : NEW_LINE INDENT return ( ' ' if k == 4 else c [ i ] [ j ] + f ( k + 1 , i + di , j + dj , di if 0 < i + di < 8 else - di , dj if 0 < j + dj < 8 else - dj ) ) NEW_LINE DEDENT ans = f ( 0 , y - 1 , x - 1 , ( 1 if ( ' D ' in W and y - 1 < 8 ) or ( ' U ' in W and y - 1 == 0 ) else - 1 if ( ' U ' in W and 0 < y - 1 ) or ( ' D ' in W and y - 1 == 8 ) else 0 ) , ( 1 if ( ' R ' in W and x - 1 < 8 ) or ( ' L ' in W and x - 1 == 0 ) else - 1 if ( ' L ' in W and 0 < x - 1 ) or ( ' R ' in W and x - 1 == 8 ) else 0 ) ) NEW_LINE print ( ans ) NEW_LINE","from sys import stdin NEW_LINE input = stdin . readline NEW_LINE x , y , w = input ( ) . split ( ) NEW_LINE x = int ( x ) - 1 NEW_LINE y = int ( y ) - 1 NEW_LINE L = [ ] NEW_LINE for _ in range ( 9 ) : NEW_LINE INDENT L_ = input ( ) NEW_LINE L . append ( L_ ) NEW_LINE DEDENT R = [ [ y , x ] ] NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT if \" R \" in w : NEW_LINE INDENT x += 1 NEW_LINE DEDENT if \" L \" in w : NEW_LINE INDENT x -= 1 NEW_LINE DEDENT if \" U \" in w : NEW_LINE INDENT y -= 1 NEW_LINE DEDENT if \" D \" in w : NEW_LINE INDENT y += 1 NEW_LINE DEDENT R . append ( [ y , x ] ) NEW_LINE DEDENT ans = \" \" NEW_LINE for y , x in R : NEW_LINE INDENT if x > 8 : NEW_LINE INDENT x = 16 - x NEW_LINE DEDENT if x < 0 : NEW_LINE INDENT x = - x NEW_LINE DEDENT if y > 8 : NEW_LINE INDENT y = 16 - y NEW_LINE DEDENT if y < 0 : NEW_LINE INDENT y = - y NEW_LINE DEDENT ans += L [ y ] [ x ] NEW_LINE DEDENT print ( ans ) NEW_LINE","def main ( ) : NEW_LINE INDENT x , y , w = input ( ) . split ( ) NEW_LINE x = int ( x ) - 1 NEW_LINE y = int ( y ) - 1 NEW_LINE c = [ ] NEW_LINE for _ in range ( 9 ) : NEW_LINE INDENT c . append ( input ( ) ) NEW_LINE DEDENT dx = 0 NEW_LINE dy = 0 NEW_LINE if ' R ' in w : NEW_LINE INDENT dx = 1 NEW_LINE DEDENT if ' L ' in w : NEW_LINE INDENT dx = - 1 NEW_LINE DEDENT if ' U ' in w : NEW_LINE INDENT dy = - 1 NEW_LINE DEDENT if ' D ' in w : NEW_LINE INDENT dy = 1 NEW_LINE DEDENT s = ' ' . join ( get ( c , x + dx * i , y + dy * i ) for i in range ( 4 ) ) NEW_LINE print ( s ) NEW_LINE DEDENT def get ( c , x , y ) : NEW_LINE INDENT if x < 0 : NEW_LINE INDENT x = - x NEW_LINE DEDENT if x >= 9 : NEW_LINE INDENT x = 16 - x NEW_LINE DEDENT if y < 0 : NEW_LINE INDENT y = - y NEW_LINE DEDENT if y >= 9 : NEW_LINE INDENT y = 16 - y NEW_LINE DEDENT return c [ y ] [ x ] NEW_LINE DEDENT main ( ) NEW_LINE"],"bleu":0.24943759628587464,"rouge_l":0.38620269192890305}
{"id":70,"predictions":["n , k = map ( int , input ( ) . split ( ) ) r = n * ( n + k ) \/\/ 2 ; print ( r ) NEW_LINE"],"references":["N , K = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( ( K - 1 ) * ( N - K ) * 6 + ( N - 1 ) * 3 + 1 ) \/ N ** 3 ) NEW_LINE","def gen_random ( N : int , K : int ) -> float : NEW_LINE INDENT res = 0 NEW_LINE res += ( K - 1 ) * 1 * ( N - K ) * 6 NEW_LINE res += 1 * 1 * ( N - K ) * 3 NEW_LINE res += ( K - 1 ) * 1 * 1 * 3 NEW_LINE res += 1 * 1 * 1 NEW_LINE return res \/ ( N * N * N ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N , K = map ( int , input ( ) . split ( ) ) NEW_LINE ans = gen_random ( N , K ) NEW_LINE print ( ans ) NEW_LINE DEDENT","n , k = ( int ( i ) for i in input ( ) . split ( ) ) NEW_LINE zentoori = n ** 3 NEW_LINE ryoutan = ( 3 * n - 2 ) \/ zentoori NEW_LINE if n == k or k == 1 : NEW_LINE INDENT print ( ryoutan ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" { 0 : . 20f } \" . format ( ( ( 3 * n - 2 ) + 6 * ( k - 1 ) * ( n - k ) ) \/ zentoori ) ) NEW_LINE DEDENT","n , k = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE ans += ( 1 \/ n ) * ( 1 \/ n ) * ( 1 \/ n ) NEW_LINE ans += 3 * ( 1 \/ n ) * ( 1 \/ n ) * ( ( n - 1 ) \/ n ) NEW_LINE ans += 6 * ( 1 \/ n ) * ( ( k - 1 ) \/ n ) * ( ( n - k ) \/ n ) NEW_LINE print ( ans ) NEW_LINE","N , K = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE cA = 1 NEW_LINE cB = ( N - 1 ) * 3 NEW_LINE cC = 6 * ( N - K ) * ( K - 1 ) NEW_LINE print ( ( cA + cB + cC ) \/ N ** 3 ) NEW_LINE"],"bleu":0.3606570249021421,"rouge_l":0.5059907834101383}
{"id":71,"predictions":["def check ( s ) : for i in range ( 2 ) : for j in range ( 4 ) : if s [ i ] [ j ] != \" X \" : return False return True   def check ( s1 , s2 ) : return False   for i in range ( 2 , 4 ) : for j in range ( 3 ) : if s1 [ i ] [ j ] == \" X \" : return False if check ( i , j ) : return False return True   for i in range ( 2 ) : print ( \" YES \" ) ) NEW_LINE"],"references":["H , W = ( 10 , 10 ) NEW_LINE field = [ list ( input ( ) ) for _ in range ( H ) ] NEW_LINE Around = [ [ 0 ] * W for _ in range ( H ) ] NEW_LINE cnt_islands = 0 NEW_LINE def dfs ( x , y ) : NEW_LINE INDENT if x < 0 or x >= W or y < 0 or y >= H or field [ y ] [ x ] == \" r \" : NEW_LINE INDENT return NEW_LINE DEDENT if field [ y ] [ x ] == \" x \" : NEW_LINE INDENT field [ y ] [ x ] = \" r \" NEW_LINE Around [ y ] [ x ] += 1 NEW_LINE return NEW_LINE DEDENT field [ y ] [ x ] = \" r \" NEW_LINE dfs ( x + 1 , y ) NEW_LINE dfs ( x - 1 , y ) NEW_LINE dfs ( x , y + 1 ) NEW_LINE dfs ( x , y - 1 ) NEW_LINE DEDENT for y in range ( H ) : NEW_LINE INDENT for x in range ( W ) : NEW_LINE INDENT if field [ y ] [ x ] == \" o \" : NEW_LINE INDENT for yr in range ( H ) : NEW_LINE INDENT for xr in range ( W ) : NEW_LINE INDENT if field [ yr ] [ xr ] == \" r \" : NEW_LINE INDENT field [ yr ] [ xr ] = \" x \" NEW_LINE DEDENT DEDENT DEDENT dfs ( x , y ) NEW_LINE cnt_islands += 1 NEW_LINE DEDENT DEDENT DEDENT if cnt_islands == 1 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT f = False NEW_LINE for y in range ( H ) : NEW_LINE INDENT for x in range ( W ) : NEW_LINE INDENT if Around [ y ] [ x ] == cnt_islands : NEW_LINE INDENT f = True NEW_LINE print ( ' YES ' ) NEW_LINE break NEW_LINE DEDENT DEDENT if f : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if not f : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT","a = [ [ \" x \" ] * 12 ] + [ list ( \" x \" + input ( ) + \" x \" ) for i in range ( 10 ) ] + [ [ \" x \" ] * 12 ] NEW_LINE b = sum ( [ i . count ( \" o \" ) for i in a ] ) NEW_LINE for i in range ( 1 , 11 ) : NEW_LINE INDENT for j in range ( 1 , 11 ) : NEW_LINE INDENT if a [ i ] [ j ] != \" o \" : NEW_LINE INDENT s = [ i [ : ] for i in a ] NEW_LINE n = 0 NEW_LINE d = [ [ i , j ] ] NEW_LINE while len ( d ) > 0 : NEW_LINE INDENT l = [ ] NEW_LINE for p , q in d : NEW_LINE INDENT if s [ p - 1 ] [ q ] == \" o \" : NEW_LINE INDENT s [ p - 1 ] [ q ] = \" x \" NEW_LINE n += 1 NEW_LINE l . append ( [ p - 1 , q ] ) NEW_LINE DEDENT if s [ p + 1 ] [ q ] == \" o \" : NEW_LINE INDENT s [ p + 1 ] [ q ] = \" x \" NEW_LINE n += 1 NEW_LINE l . append ( [ p + 1 , q ] ) NEW_LINE DEDENT if s [ p ] [ q + 1 ] == \" o \" : NEW_LINE INDENT s [ p ] [ q + 1 ] = \" x \" NEW_LINE n += 1 NEW_LINE l . append ( [ p , q + 1 ] ) NEW_LINE DEDENT if s [ p ] [ q - 1 ] == \" o \" : NEW_LINE INDENT s [ p ] [ q - 1 ] = \" x \" NEW_LINE n += 1 NEW_LINE l . append ( [ p , q - 1 ] ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT d = l NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if n == b : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT","import sys NEW_LINE sys . setrecursionlimit ( 100000 ) NEW_LINE ans_flag = 0 NEW_LINE field = [ input ( ) for x in range ( 10 ) ] NEW_LINE field_u = [ [ 1 if field [ y ] [ x ] == ' x ' else 0 for x in range ( 10 ) ] for y in range ( 10 ) ] NEW_LINE reached = [ [ 0 for x in range ( 10 ) ] for y in range ( 10 ) ] NEW_LINE flag = 0 NEW_LINE def dfs ( x , y ) : NEW_LINE INDENT global flag , reached NEW_LINE if x >= 10 or y >= 10 or x < 0 or y < 0 : NEW_LINE INDENT return NEW_LINE DEDENT if field_u [ x ] [ y ] == 1 : NEW_LINE INDENT return NEW_LINE DEDENT if reached [ x ] [ y ] == 1 : NEW_LINE INDENT return NEW_LINE DEDENT reached [ x ] [ y ] = 1 NEW_LINE dfs ( x + 1 , y ) NEW_LINE dfs ( x - 1 , y ) NEW_LINE dfs ( x , y + 1 ) NEW_LINE dfs ( x , y - 1 ) NEW_LINE DEDENT counter = 1 NEW_LINE for y in range ( 10 ) : NEW_LINE INDENT for x in range ( 10 ) : NEW_LINE INDENT if field [ y ] [ x ] == ' o ' : NEW_LINE INDENT counter += 1 NEW_LINE first = [ y , x ] NEW_LINE DEDENT DEDENT DEDENT for y in range ( 10 ) : NEW_LINE INDENT for x in range ( 10 ) : NEW_LINE INDENT if field_u [ y ] [ x ] == 1 : NEW_LINE INDENT field_u [ y ] [ x ] = 0 NEW_LINE dfs ( first [ 0 ] , first [ 1 ] ) NEW_LINE ans = [ sum ( i ) for i in reached ] NEW_LINE ans = sum ( ans ) NEW_LINE if counter == ans : NEW_LINE INDENT ans_flag = 1 NEW_LINE DEDENT reached = [ [ 0 for x in range ( 10 ) ] for y in range ( 10 ) ] NEW_LINE field_u [ y ] [ x ] = 1 NEW_LINE DEDENT DEDENT DEDENT if ans_flag == 1 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT","M = [ list ( input ( ) ) for _ in range ( 10 ) ] NEW_LINE def dfs ( m , x , y ) : NEW_LINE INDENT for dx , dy in ( ( - 1 , 0 ) , ( 1 , 0 ) , ( 0 , - 1 ) , ( 0 , 1 ) ) : NEW_LINE INDENT if 0 <= x + dx < 10 and 0 <= y + dy < 10 : NEW_LINE INDENT if m [ y + dy ] [ x + dx ] == ' o ' : NEW_LINE INDENT m [ y + dy ] [ x + dx ] = ' x ' NEW_LINE dfs ( m , x + dx , y + dy ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def island ( m , x , y ) : NEW_LINE INDENT dfs ( m , x , y ) NEW_LINE return all ( all ( x == ' x ' for x in l ) for l in m ) NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT for y in range ( 10 ) : NEW_LINE INDENT for x in range ( 10 ) : NEW_LINE INDENT if M [ y ] [ x ] == ' x ' : NEW_LINE INDENT M2 = [ l [ : ] for l in M ] NEW_LINE if island ( M2 , x , y ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT print ( ' YES ' if solve ( ) else ' NO ' ) NEW_LINE","import sys NEW_LINE sys . setrecursionlimit ( 1000000 ) NEW_LINE a = [ [ 0 ] * 10 for _ in range ( 10 ) ] NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT a [ i ] = list ( input ( ) ) NEW_LINE DEDENT def land_search ( m ) : NEW_LINE INDENT m_reached = [ [ 0 ] * 10 for _ in range ( 10 ) ] NEW_LINE cnt = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT if m [ j ] [ i ] == \" o \" and m_reached [ j ] [ i ] == 0 : NEW_LINE INDENT cnt += 1 NEW_LINE search ( i , j , m , m_reached ) NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT def search ( x , y , m , m_reached ) : NEW_LINE INDENT if x < 0 or x >= 10 or y < 0 or y >= 10 : NEW_LINE INDENT return False NEW_LINE DEDENT if m [ y ] [ x ] == \" x \" : NEW_LINE INDENT return False NEW_LINE DEDENT if m_reached [ y ] [ x ] == 1 : NEW_LINE INDENT return False NEW_LINE DEDENT m_reached [ y ] [ x ] = 1 NEW_LINE if search ( x + 1 , y , m , m_reached ) : NEW_LINE INDENT return True NEW_LINE DEDENT if search ( x - 1 , y , m , m_reached ) : NEW_LINE INDENT return True NEW_LINE DEDENT if search ( x , y + 1 , m , m_reached ) : NEW_LINE INDENT return True NEW_LINE DEDENT if search ( x , y - 1 , m , m_reached ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT ans = False NEW_LINE if land_search ( a ) == 1 : NEW_LINE INDENT ans = True NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT ac = a [ : ] NEW_LINE if a [ j ] [ i ] == \" x \" : NEW_LINE INDENT ac [ j ] [ i ] = \" o \" NEW_LINE if land_search ( ac ) == 1 : NEW_LINE INDENT ans = True NEW_LINE DEDENT ac [ j ] [ i ] = \" x \" NEW_LINE DEDENT DEDENT DEDENT if ans : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"],"bleu":0.0964427626674225,"rouge_l":0.2945923619495457}
{"id":72,"predictions":["s = input ( ) NEW_LINE n = len ( s ) NEW_LINE if n % 2 == 1 : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT"],"references":["import collections NEW_LINE letter = collections . Counter ( input ( ) ) NEW_LINE counter = 0 NEW_LINE for v in letter . values ( ) : NEW_LINE INDENT if v % 2 == 1 : NEW_LINE INDENT counter += 1 NEW_LINE break NEW_LINE DEDENT DEDENT print ( \" Yes \" ) if counter == 0 else print ( \" No \" ) NEW_LINE","hoge = input ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( len ( hoge ) ) : NEW_LINE INDENT ans += hoge . count ( hoge [ i ] ) % 2 NEW_LINE DEDENT if ( ans == 0 ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT","w = input ( ) NEW_LINE dct_str = dict . fromkeys ( w , 0 ) NEW_LINE for alp in w : NEW_LINE INDENT dct_str [ alp ] += 1 NEW_LINE DEDENT flag = True NEW_LINE for alp in dct_str . keys ( ) : NEW_LINE INDENT if dct_str [ alp ] % 2 != 0 : NEW_LINE INDENT flag = False NEW_LINE DEDENT DEDENT if flag == True : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT","s = input ( ) NEW_LINE alphabet = \" abcdefghijklmnopqrstuvwxyz \" NEW_LINE list = [ s . count ( x ) for x in alphabet ] NEW_LINE for i in range ( len ( list ) ) : NEW_LINE INDENT if list [ i ] % 2 == 0 : NEW_LINE INDENT list [ i ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT list [ i ] = 1 NEW_LINE DEDENT DEDENT print ( \" Yes \" if sum ( list ) == 0 else \" No \" ) NEW_LINE","def beautiful_strings ( w : str ) -> bool : NEW_LINE INDENT freq = { } NEW_LINE for c in w : NEW_LINE INDENT freq . setdefault ( c , 0 ) NEW_LINE freq [ c ] += 1 NEW_LINE DEDENT return all ( f % 2 == 0 for f in freq . values ( ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT w = input ( ) NEW_LINE yes = beautiful_strings ( w ) NEW_LINE print ( ' Yes ' if yes else ' No ' ) NEW_LINE DEDENT"],"bleu":0.46963183702387695,"rouge_l":0.5990756787983824}
{"id":73,"predictions":["import sys NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE INF = 10 ** 18 NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def II ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def SI ( ) : return input ( ) NEW_LINE def main ( ) : NEW_LINE INDENT n = II ( ) NEW_LINE A = LI ( ) NEW_LINE A . sort ( ) NEW_LINE ans = A [ 0 ] + A [ - 1 ] NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT ans = max ( ans , A [ i ] + A [ i + 1 ] - A [ i ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT main ( ) NEW_LINE"],"references":["L , N = map ( int , input ( ) . split ( ) ) NEW_LINE X = [ 0 ] NEW_LINE for _ in range ( N ) : NEW_LINE INDENT X . append ( int ( input ( ) ) ) NEW_LINE DEDENT s = [ 0 ] * ( N + 1 ) NEW_LINE t = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT s [ i ] = s [ i - 1 ] + X [ i ] NEW_LINE t [ i ] = t [ i - 1 ] + ( L - X [ N - i + 1 ] ) NEW_LINE DEDENT Y = [ 0 ] + [ L - X [ N - i ] for i in range ( N ) ] NEW_LINE def get_d ( s , x , i ) : NEW_LINE INDENT if i == N : NEW_LINE INDENT return x [ N ] NEW_LINE DEDENT a = i + ( N - i ) \/\/ 2 NEW_LINE return ( 2 * ( s [ a ] - s [ i - 1 ] + L * ( N - a ) - s [ N ] + s [ a ] ) - ( x [ a ] if ( N - i ) % 2 == 0 else ( L - x [ a + 1 ] ) ) ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT ans = max ( ans , get_d ( s , X , i ) , get_d ( t , Y , i ) ) NEW_LINE DEDENT print ( ans ) NEW_LINE","def is_even ( num ) : NEW_LINE INDENT return num % 2 == 0 NEW_LINE DEDENT def goback ( M , x , Sx ) : NEW_LINE INDENT k = M \/\/ 2 NEW_LINE if M == 0 : NEW_LINE INDENT return L - x [ 0 ] NEW_LINE DEDENT elif M == 1 : NEW_LINE INDENT return 2 * ( L - x [ 1 ] ) + x [ 0 ] NEW_LINE DEDENT elif is_even ( M ) : NEW_LINE INDENT return 2 * Sx [ k - 1 ] - 2 * ( Sx [ M ] - Sx [ M - k ] ) - x [ M - k ] + L * ( 2 * k + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return 2 * Sx [ k - 1 ] + x [ k ] - 2 * ( Sx [ M ] - Sx [ M - k - 1 ] ) + L * 2 * ( k + 1 ) NEW_LINE DEDENT DEDENT L , N = ( int ( i ) for i in input ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE pl = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT pl . append ( int ( input ( ) ) ) NEW_LINE DEDENT sumpl = [ pl [ 0 ] ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT sumpl . append ( sumpl [ i - 1 ] + pl [ i ] ) NEW_LINE DEDENT for i in range ( 0 , N ) : NEW_LINE INDENT ans = max ( ans , goback ( i , pl , sumpl ) ) NEW_LINE DEDENT revpl = [ L - p for p in pl [ : : - 1 ] ] NEW_LINE sumrevpl = [ revpl [ 0 ] ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT sumrevpl . append ( sumrevpl [ i - 1 ] + revpl [ i ] ) NEW_LINE DEDENT for i in range ( 0 , N ) : NEW_LINE INDENT ans = max ( ans , goback ( i , revpl , sumrevpl ) ) NEW_LINE DEDENT print ( ans ) NEW_LINE","import sys NEW_LINE from itertools import accumulate NEW_LINE circumference , n = map ( int , input ( ) . split ( ) ) NEW_LINE lll = list ( map ( int , sys . stdin . readlines ( ) ) ) NEW_LINE rrr = [ circumference - l for l in lll ] NEW_LINE rrr . reverse ( ) NEW_LINE lll = [ 0 ] + lll NEW_LINE rrr = [ 0 ] + rrr NEW_LINE acc_l = list ( accumulate ( lll ) ) NEW_LINE acc_r = list ( accumulate ( rrr ) ) NEW_LINE ans = max ( lll [ - 1 ] , rrr [ - 1 ] ) NEW_LINE for take_l in range ( 1 , n ) : NEW_LINE INDENT take_r = n - take_l NEW_LINE tmp_l = lll [ take_l ] + 2 * ( acc_l [ take_l - 1 ] + acc_r [ take_r ] ) NEW_LINE tmp_r = rrr [ take_r ] + 2 * ( acc_r [ take_r - 1 ] + acc_l [ take_l ] ) NEW_LINE if take_l < take_r : NEW_LINE INDENT tmp_l -= 2 * acc_r [ take_r - take_l ] NEW_LINE tmp_r -= 2 * acc_r [ take_r - 1 - take_l ] NEW_LINE DEDENT elif take_l > take_r : NEW_LINE INDENT tmp_l -= 2 * acc_l [ take_l - 1 - take_r ] NEW_LINE tmp_r -= 2 * acc_l [ take_l - take_r ] NEW_LINE DEDENT ans = max ( ans , tmp_l , tmp_r ) NEW_LINE DEDENT print ( ans ) NEW_LINE","import math NEW_LINE L , N = ( int ( i ) for i in input ( ) . split ( ) ) NEW_LINE X = [ int ( input ( ) ) for _ in range ( N ) ] NEW_LINE X . insert ( 0 , 0 ) NEW_LINE X_r = [ L - i for i in reversed ( X ) ] NEW_LINE X_r . insert ( 0 , 0 ) NEW_LINE X_r . pop ( ) NEW_LINE def lsum ( l ) : NEW_LINE INDENT s = 0 NEW_LINE for i in l : NEW_LINE INDENT s += i NEW_LINE yield s NEW_LINE DEDENT DEDENT X_sum = list ( lsum ( X ) ) NEW_LINE X_r_sum = list ( lsum ( X_r ) ) NEW_LINE def f_l ( p , n ) : NEW_LINE INDENT N_tmp = N - n NEW_LINE a = N_tmp \/\/ 2 NEW_LINE if N_tmp == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif N_tmp % 2 == 0 : NEW_LINE INDENT return 2 * X_sum [ a ] + X_r_sum [ a + n ] + X_r_sum [ a + n - 1 ] - 2 * X_r_sum [ n ] + p NEW_LINE DEDENT else : NEW_LINE INDENT return X_sum [ a + 1 ] + X_sum [ a ] + 2 * X_r_sum [ a + n ] - 2 * X_r_sum [ n ] + p NEW_LINE DEDENT DEDENT def f_r ( p , n ) : NEW_LINE INDENT N_tmp = N - n NEW_LINE a = N_tmp \/\/ 2 NEW_LINE if N_tmp == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif N_tmp % 2 == 0 : NEW_LINE INDENT return 2 * X_r_sum [ a ] + X_sum [ a + n ] + X_sum [ a + n - 1 ] - 2 * X_sum [ n ] + p NEW_LINE DEDENT else : NEW_LINE INDENT return X_r_sum [ a + 1 ] + X_r_sum [ a ] + 2 * X_sum [ a + n ] - 2 * X_sum [ n ] + p NEW_LINE DEDENT DEDENT max_l = max ( X [ i ] + f_r ( X [ i ] , i ) for i in range ( 1 , N + 1 ) ) NEW_LINE max_r = max ( X_r [ i ] + f_l ( X_r [ i ] , i ) for i in range ( 1 , N + 1 ) ) NEW_LINE print ( max ( max_l , max_r ) ) NEW_LINE","import math NEW_LINE L , N = map ( int , input ( ) . split ( ) ) NEW_LINE X = [ None for i in range ( N ) ] NEW_LINE DistAntiClock , DistClock = [ 0 for i in range ( N + 1 ) ] , [ 0 for i in range ( N + 1 ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT X [ i ] = int ( input ( ) ) NEW_LINE DistAntiClock [ i + 1 ] = DistAntiClock [ i ] + 2 * X [ i ] NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT DistClock [ i + 1 ] = DistClock [ i ] + ( L - X [ - 1 - i ] ) * 2 NEW_LINE DEDENT maxLength = max ( X [ N - 1 ] , L - X [ 0 ] ) NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT finIndex = math . ceil ( ( i + N ) \/ 2 ) NEW_LINE if ( i + N ) % 2 == 0 : NEW_LINE INDENT AntiClockLength = DistAntiClock [ finIndex ] - DistAntiClock [ i - 1 ] - X [ finIndex - 1 ] + DistClock [ N - finIndex ] NEW_LINE ClockLength = DistClock [ finIndex ] - DistClock [ i - 1 ] - ( L - X [ - finIndex ] ) + DistAntiClock [ N - finIndex ] NEW_LINE DEDENT else : NEW_LINE INDENT AntiClockLength = DistAntiClock [ finIndex - 1 ] - DistAntiClock [ i - 1 ] + DistClock [ N - finIndex + 1 ] - ( L - X [ finIndex - 1 ] ) NEW_LINE ClockLength = DistClock [ finIndex - 1 ] - DistClock [ i - 1 ] + DistAntiClock [ N - finIndex + 1 ] - X [ N - finIndex ] NEW_LINE DEDENT maxLength = max ( max ( AntiClockLength , ClockLength ) , maxLength ) NEW_LINE DEDENT print ( maxLength ) NEW_LINE"],"bleu":0.30695911612405724,"rouge_l":0.3766707639298884}
{"id":74,"predictions":["from collections import defaultdict NEW_LINE def inpl ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE N = int ( input ( ) ) NEW_LINE A = inpl ( ) NEW_LINE C = defaultdict ( int ) NEW_LINE for a in A . : NEW_LINE INDENT C [ a ] += 1 NEW_LINE DEDENT C = [ 0 ] * ( 10 ** 5 + 1 ) NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT C [ A [ i ] ] += 1 NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT if C [ i ] > 2 : NEW_LINE INDENT ans += C [ i ] - C [ a - 1 ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["from collections import Counter NEW_LINE input ( ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE A . sort ( reverse = True ) NEW_LINE C = Counter ( A ) NEW_LINE ans = 0 NEW_LINE for a in A : NEW_LINE INDENT if not C [ a ] : NEW_LINE INDENT continue NEW_LINE DEDENT C [ a ] -= 1 NEW_LINE t = 2 ** a . bit_length ( ) - a NEW_LINE if C [ t ] : NEW_LINE INDENT C [ t ] -= 1 NEW_LINE ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE","import bisect NEW_LINE inpl = lambda : list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE _ = int ( input ( ) ) NEW_LINE A = sorted ( inpl ( ) ) NEW_LINE Anlist = [ ] NEW_LINE ap = 0 NEW_LINE for a in A : NEW_LINE INDENT if a > ap : NEW_LINE INDENT Anlist . append ( [ a , 1 ] ) NEW_LINE ap = a NEW_LINE DEDENT else : NEW_LINE INDENT Anlist [ - 1 ] [ 1 ] += 1 NEW_LINE DEDENT DEDENT A = [ a for a , n in Anlist ] NEW_LINE N = len ( Anlist ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if Anlist [ - i ] [ 1 ] == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT p = len ( bin ( A [ - i ] ) ) - 3 NEW_LINE B = ( 1 << ( p + 1 ) ) - A [ - i ] NEW_LINE if A [ - i ] == B : NEW_LINE INDENT ans += Anlist [ - i ] [ 1 ] \/\/ 2 NEW_LINE DEDENT else : NEW_LINE INDENT m = bisect . bisect_left ( A , B , 0 , N - i ) NEW_LINE if m < N - i and A [ m ] == B : NEW_LINE INDENT pairs = min ( Anlist [ m ] [ 1 ] , Anlist [ - i ] [ 1 ] ) NEW_LINE ans += pairs NEW_LINE Anlist [ m ] [ 1 ] -= pairs NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE","import collections NEW_LINE N = int ( input ( ) ) NEW_LINE A = collections . deque ( sorted ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE def func1 ( a , r , rnext ) : NEW_LINE INDENT p = a . popleft ( ) NEW_LINE q = a . pop ( ) NEW_LINE ans = 0 NEW_LINE a1 = collections . deque ( ) NEW_LINE while True : NEW_LINE INDENT if p + q == r : NEW_LINE INDENT ans += 1 NEW_LINE try : NEW_LINE INDENT p = a . popleft ( ) NEW_LINE DEDENT except : NEW_LINE INDENT break NEW_LINE DEDENT try : NEW_LINE INDENT q = a . pop ( ) NEW_LINE DEDENT except : NEW_LINE INDENT if p < rnext : NEW_LINE INDENT a1 . append ( p ) NEW_LINE DEDENT break NEW_LINE DEDENT DEDENT elif p + q > r : NEW_LINE INDENT try : NEW_LINE INDENT q = a . pop ( ) NEW_LINE DEDENT except : NEW_LINE INDENT if p < rnext : NEW_LINE INDENT a1 . append ( p ) NEW_LINE DEDENT break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT a1 . append ( p ) NEW_LINE try : NEW_LINE INDENT p = a . popleft ( ) NEW_LINE DEDENT except : NEW_LINE INDENT if q < rnext : NEW_LINE INDENT a1 . append ( q ) NEW_LINE DEDENT break NEW_LINE DEDENT DEDENT DEDENT return ans , a1 NEW_LINE DEDENT if N == 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE exit ( 0 ) NEW_LINE DEDENT t = int . bit_length ( A [ - 1 ] + A [ - 2 ] ) NEW_LINE r = 2 ** t NEW_LINE rnext = 2 ** ( t - 1 ) NEW_LINE anser = 0 NEW_LINE a = A NEW_LINE while True : NEW_LINE INDENT ans , a1 = func1 ( a , r , rnext ) NEW_LINE anser += ans NEW_LINE if len ( a1 ) < 2 : NEW_LINE INDENT break NEW_LINE DEDENT a = a1 NEW_LINE t -= 1 NEW_LINE r = rnext NEW_LINE rnext = 2 ** ( t - 1 ) NEW_LINE DEDENT print ( anser ) NEW_LINE","def hersCode ( L , n ) : NEW_LINE INDENT ok = len ( L ) - 1 NEW_LINE ng = 0 NEW_LINE while abs ( ok - ng ) > 1 : NEW_LINE INDENT mid = abs ( ok + ng ) \/\/ 2 NEW_LINE if L [ mid ] > n : NEW_LINE INDENT ok = mid NEW_LINE DEDENT else : NEW_LINE INDENT ng = mid NEW_LINE DEDENT DEDENT return ok NEW_LINE DEDENT def hersCode2 ( L , n ) : NEW_LINE INDENT ok = 0 NEW_LINE ng = len ( L ) NEW_LINE while abs ( ok - ng ) > 1 : NEW_LINE INDENT mid = abs ( ok + ng ) \/\/ 2 NEW_LINE if L [ mid ] < n : NEW_LINE INDENT ok = mid NEW_LINE DEDENT elif L [ mid ] == n : NEW_LINE INDENT if TF [ mid ] : NEW_LINE INDENT ok = mid NEW_LINE DEDENT else : NEW_LINE INDENT ng = mid NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT ng = mid NEW_LINE DEDENT DEDENT return ok NEW_LINE DEDENT N = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE A . sort ( ) NEW_LINE D = [ pow ( 2 , i ) for i in range ( 31 ) ] NEW_LINE TF = [ True for i in range ( N + 1 ) ] NEW_LINE Ans = 0 NEW_LINE A = [ - 1e11 ] + A NEW_LINE for i in range ( len ( A ) - 1 , 1 , - 1 ) : NEW_LINE INDENT if TF [ i ] : NEW_LINE INDENT k = D [ hersCode ( D , A [ - 1 ] ) ] - A [ - 1 ] NEW_LINE del A [ - 1 ] NEW_LINE t = hersCode2 ( A , k ) NEW_LINE if A [ t ] == k : NEW_LINE INDENT TF [ t ] = False NEW_LINE Ans += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT del A [ - 1 ] NEW_LINE DEDENT DEDENT print ( Ans ) NEW_LINE","import bisect NEW_LINE def number ( num ) : NEW_LINE INDENT number_len = len ( bin ( num ) ) - 2 NEW_LINE f = 2 ** number_len - 1 NEW_LINE return ( num ^ f ) + 1 NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE line = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE line . sort ( ) NEW_LINE count = 0 NEW_LINE while len ( line ) > 0 : NEW_LINE INDENT k = line . pop ( ) NEW_LINE if len ( line ) == 0 : NEW_LINE INDENT break NEW_LINE DEDENT if int ( k ) != k : NEW_LINE INDENT continue NEW_LINE DEDENT x = number ( k ) NEW_LINE if x > line [ - 1 ] : NEW_LINE INDENT continue NEW_LINE DEDENT if line [ bisect . bisect_left ( line , x ) ] == x : NEW_LINE INDENT line [ bisect . bisect_left ( line , x ) ] -= 0.5 NEW_LINE count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE"],"bleu":0.6247533184559915,"rouge_l":0.689080150618612}
{"id":75,"predictions":["import numpy as np NEW_LINE def inpl ( ) : return [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE N = int ( input ( ) ) NEW_LINE A = np . zeros ( ( N , N ) ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT A [ i ] = np . cumsum ( inpl ( ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT ans = min ( ans , A [ i ] + A [ i + 1 ] - A [ i ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE"],"references":["N , C = [ int ( _ ) for _ in input ( ) . split ( ) ] NEW_LINE X = [ 0 ] * N NEW_LINE V = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT X [ i ] , V [ i ] = [ int ( _ ) for _ in input ( ) . split ( ) ] NEW_LINE DEDENT def calc ( X , V ) : NEW_LINE INDENT Vcumsum = [ 0 ] NEW_LINE for v in V : NEW_LINE INDENT Vcumsum += [ Vcumsum [ - 1 ] + v ] NEW_LINE DEDENT cumsum = [ 0 ] * ( N + 1 ) NEW_LINE cumsum_r = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT cumsum [ i + 1 ] = Vcumsum [ i + 1 ] - X [ i ] NEW_LINE cumsum_r [ i + 1 ] = Vcumsum [ N ] - Vcumsum [ N - i - 1 ] - ( C - X [ - 1 - i ] ) NEW_LINE DEDENT cumsum_max = [ 0 ] * ( N + 1 ) NEW_LINE cumsum_r_max = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT cumsum_max [ i + 1 ] = max ( cumsum [ i + 1 ] , cumsum_max [ i ] ) NEW_LINE cumsum_r_max [ i + 1 ] = max ( cumsum_r [ i + 1 ] , cumsum_r_max [ i ] ) NEW_LINE DEDENT res = max ( cumsum_max [ - 1 ] , cumsum_r_max [ - 1 ] ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT res = max ( res , cumsum_max [ i + 1 ] + cumsum_r_max [ N - i - 1 ] - X [ i ] , cumsum_r_max [ i + 1 ] + cumsum_max [ N - i - 1 ] - ( C - X [ - 1 - i ] ) ) NEW_LINE DEDENT return res NEW_LINE DEDENT print ( calc ( X , V ) ) NEW_LINE","import sys NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE input = sys . stdin . readline NEW_LINE N , C = map ( int , input ( ) . split ( ) ) NEW_LINE sushis = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] NEW_LINE valA = [ ] NEW_LINE valArev = [ ] NEW_LINE sumV = 0 NEW_LINE tmpMax = - float ( ' inf ' ) NEW_LINE for d , v in sushis : NEW_LINE INDENT sumV += v NEW_LINE valArev . append ( sumV - 2 * d ) NEW_LINE tmpMax = max ( tmpMax , sumV - d ) NEW_LINE valA . append ( tmpMax ) NEW_LINE DEDENT valB = [ ] NEW_LINE valBrev = [ ] NEW_LINE sumV = 0 NEW_LINE tmpMax = - float ( ' inf ' ) NEW_LINE for d , v in reversed ( sushis ) : NEW_LINE INDENT sumV += v NEW_LINE revD = C - d NEW_LINE valBrev . append ( sumV - 2 * revD ) NEW_LINE tmpMax = max ( tmpMax , sumV - revD ) NEW_LINE valB . append ( tmpMax ) NEW_LINE DEDENT ans = max ( valA + valB + [ 0 ] ) NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT ans = max ( ans , valArev [ i ] + valB [ N - i - 2 ] ) NEW_LINE DEDENT for i in range ( N - 1 ) : NEW_LINE INDENT ans = max ( ans , valBrev [ i ] + valA [ N - i - 2 ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE","def inpl ( ) : return [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE import numpy as np NEW_LINE N , C = inpl ( ) NEW_LINE x , v = np . array ( [ inpl ( ) for _ in range ( N ) ] ) . T NEW_LINE cwo = np . cumsum ( v ) - x NEW_LINE cwr = np . hstack ( ( [ 0 ] , cwo - x ) ) NEW_LINE cwo = np . hstack ( ( [ 0 ] , cwo ) ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT cwr [ i + 1 ] = max ( cwr [ i ] , cwr [ i + 1 ] ) NEW_LINE DEDENT av = v [ : : - 1 ] NEW_LINE ax = C - x [ : : - 1 ] NEW_LINE acwo = np . cumsum ( av ) - ax NEW_LINE acwr = np . hstack ( ( [ 0 ] , acwo - ax ) ) NEW_LINE acwo = np . hstack ( ( [ 0 ] , acwo ) ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT acwr [ i + 1 ] = max ( acwr [ i ] , acwr [ i + 1 ] ) NEW_LINE DEDENT ans1 = cwo + acwr [ : : - 1 ] NEW_LINE ans2 = acwo + cwr [ : : - 1 ] NEW_LINE print ( max ( np . max ( ans1 ) , np . max ( ans2 ) , 0 ) ) NEW_LINE","N , C = map ( int , input ( ) . split ( ) ) NEW_LINE Sushi = [ [ int ( info ) for info in input ( ) . split ( ) ] for n in range ( N ) ] NEW_LINE Clocksum = [ 0 for i in range ( N + 1 ) ] NEW_LINE AntiClocksum = [ 0 for i in range ( N + 1 ) ] NEW_LINE maxClocksum , maxAntisum = [ 0 for i in range ( N + 1 ) ] , [ 0 for i in range ( N + 1 ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT Clocksum [ i + 1 ] = Clocksum [ i ] + Sushi [ i ] [ 1 ] - Sushi [ i ] [ 0 ] NEW_LINE AntiClocksum [ i + 1 ] = AntiClocksum [ i ] + Sushi [ N - i - 1 ] [ 1 ] - ( C - Sushi [ N - i - 1 ] [ 0 ] ) NEW_LINE if i > 0 : NEW_LINE INDENT Clocksum [ i + 1 ] += Sushi [ i - 1 ] [ 0 ] NEW_LINE AntiClocksum [ i + 1 ] += C - Sushi [ N - i ] [ 0 ] NEW_LINE DEDENT maxClocksum [ i + 1 ] = max ( maxClocksum [ i ] , Clocksum [ i + 1 ] ) NEW_LINE maxAntisum [ i + 1 ] = max ( maxAntisum [ i ] , AntiClocksum [ i + 1 ] ) NEW_LINE DEDENT maxCalorie = max ( max ( Clocksum ) , max ( AntiClocksum ) ) NEW_LINE ClockToAnticlock = 0 NEW_LINE AntiClockToClock = 0 NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT ClockToAnticlock = max ( Clocksum [ i + 1 ] + maxAntisum [ N - 1 - i ] - Sushi [ i ] [ 0 ] , ClockToAnticlock ) NEW_LINE AntiClockToClock = max ( AntiClocksum [ i + 1 ] + maxClocksum [ N - 1 - i ] - ( C - Sushi [ N - i - 1 ] [ 0 ] ) , AntiClockToClock ) NEW_LINE DEDENT print ( max ( maxCalorie , max ( ClockToAnticlock , AntiClockToClock ) ) ) NEW_LINE","n , c = map ( int , input ( ) . split ( ) ) NEW_LINE xv = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT xv . append ( tuple ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT af = [ 0 ] NEW_LINE prevx = 0 NEW_LINE for x , v in xv : NEW_LINE INDENT af . append ( af [ - 1 ] + v - x + prevx ) NEW_LINE prevx = x NEW_LINE DEDENT bf = [ 0 ] NEW_LINE prevx = 0 NEW_LINE for x , v in xv [ : : - 1 ] : NEW_LINE INDENT x = c - x NEW_LINE bf . append ( bf [ - 1 ] + v - x + prevx ) NEW_LINE prevx = x NEW_LINE DEDENT maxa = [ 0 ] NEW_LINE for _af in af [ 1 : ] : NEW_LINE INDENT maxa . append ( max ( maxa [ - 1 ] , _af ) ) NEW_LINE DEDENT maxb = [ 0 ] NEW_LINE for _bf in bf [ 1 : ] : NEW_LINE INDENT maxb . append ( max ( maxb [ - 1 ] , _bf ) ) NEW_LINE DEDENT ans = 0 NEW_LINE for i , _af in enumerate ( af ) : NEW_LINE INDENT if _af + maxb [ n - i ] - ( xv [ i - 1 ] [ 0 ] if i != 0 else 0 ) > ans : NEW_LINE INDENT ans = _af + maxb [ n - i ] - ( xv [ i - 1 ] [ 0 ] if i != 0 else 0 ) NEW_LINE DEDENT DEDENT for i , _bf in enumerate ( bf ) : NEW_LINE INDENT if _bf + maxa [ n - i ] - ( c - xv [ n - i ] [ 0 ] if i != 0 else 0 ) > ans : NEW_LINE INDENT ans = _bf + maxa [ n - i ] - ( c - xv [ n - i ] [ 0 ] if i != 0 else 0 ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"bleu":0.1881553203563926,"rouge_l":0.4260168841135841}
{"id":76,"predictions":["def ma ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE a , b = ma ( ) NEW_LINE print ( ( a - 1 ) * b + a * ( b - 1 ) ) NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( n - 1 ) * ( m - 1 ) ) NEW_LINE","n , m = [ int ( item ) for item in input ( ) . split ( ) ] NEW_LINE print ( ( n - 1 ) * ( m - 1 ) ) NEW_LINE","[ n , m ] = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( ( n - 1 ) * ( m - 1 ) ) NEW_LINE","a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( a - 1 ) * ( b - 1 ) ) NEW_LINE","N , M = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( N - 1 ) * ( M - 1 ) ) NEW_LINE"],"bleu":0.6424207097051482,"rouge_l":0.7419635099913119}
{"id":77,"predictions":["import numpy as np NEW_LINE import scipy . sparse . csgraph as spg NEW_LINE import sys NEW_LINE import math NEW_LINE import bisect NEW_LINE import random NEW_LINE def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . rstrip ( ) NEW_LINE def S ( ) : return list ( sys . stdin . readline ( ) ) NEW_LINE def S ( ) : return list ( sys . stdin . readline ( ) ) NEW_LINE def IR ( n ) : return [ I ( ) for i in range ( n ) ] NEW_LINE def LIR ( n ) : return [ LI ( ) for i in range ( n ) ] NEW_LINE def SR ( n ) : return [ S ( ) for i in range ( n ) ] NEW_LINE def LSR ( n ) : return [ LS ( ) for i in range ( n ) ] NEW_LINE mod = 1000000007 NEW_LINE def A ( ) : return [ S ( ) for i in range ( n ) ] NEW_LINE def main ( ) : NEW_LINE INDENT n , m , a , b = LI ( ) NEW_LINE A = LI ( ) NEW_LINE ans = n NEW_LINE for i in range ( m ) : NEW_LINE INDENT ans [ i ] = A [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT ans [ i ] = min ( ans [ i ] [ j ] , ans [ i ] [ j ] + 1 ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT print ( main ( ) ) NEW_LINE"],"references":["NM = 40 NEW_LINE ABM = 10 NEW_LINE MM = 400 NEW_LINE N , M1 , M2 = map ( int , input ( ) . split ( ) ) NEW_LINE A = [ ] NEW_LINE B = [ ] NEW_LINE C = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE A . append ( a ) NEW_LINE B . append ( b ) NEW_LINE C . append ( c ) NEW_LINE DEDENT cmax = max ( C ) NEW_LINE CM = N * cmax + 10 NEW_LINE dp = [ [ [ CM for broop in range ( 401 ) ] for aroop in range ( 401 ) ] for nroop in range ( N + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] [ 0 ] = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for cb in range ( 401 ) : NEW_LINE INDENT for ca in range ( 401 ) : NEW_LINE INDENT if dp [ i ] [ ca ] [ cb ] == CM : NEW_LINE INDENT continue NEW_LINE DEDENT dp [ i + 1 ] [ ca ] [ cb ] = min ( dp [ i + 1 ] [ ca ] [ cb ] , dp [ i ] [ ca ] [ cb ] ) NEW_LINE if ca + A [ i ] < 401 and cb + B [ i ] < 401 : NEW_LINE INDENT dp [ i + 1 ] [ ca + A [ i ] ] [ cb + B [ i ] ] = min ( dp [ i + 1 ] [ ca + A [ i ] ] [ cb + B [ i ] ] , dp [ i ] [ ca ] [ cb ] + C [ i ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = CM NEW_LINE for cb in range ( 400 ) : NEW_LINE INDENT for ca in range ( 400 ) : NEW_LINE INDENT CB = cb + 1 NEW_LINE CA = ca + 1 NEW_LINE if CA * M2 == CB * M1 : NEW_LINE INDENT ans = min ( ans , dp [ N ] [ CA ] [ CB ] ) NEW_LINE DEDENT DEDENT DEDENT if ans == CM : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT","def push ( k , v ) : NEW_LINE INDENT if k in dic : NEW_LINE INDENT dic [ k ] = min ( dic [ k ] , v ) NEW_LINE DEDENT else : NEW_LINE INDENT dic [ k ] = v NEW_LINE DEDENT DEDENT n , x , y = map ( int , str ( input ( ) ) . split ( ' ▁ ' ) ) NEW_LINE dic = { } NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT a = list ( map ( int , str ( input ( ) ) . split ( ' ▁ ' ) ) ) NEW_LINE k , v = a [ 0 ] * y - a [ 1 ] * x , a [ 2 ] NEW_LINE l = [ ] NEW_LINE for j in dic : NEW_LINE INDENT l . append ( [ j , dic [ j ] ] ) NEW_LINE DEDENT for jj in l : NEW_LINE INDENT push ( jj [ 0 ] + k , jj [ 1 ] + v ) NEW_LINE DEDENT push ( k , v ) NEW_LINE DEDENT if 0 in dic : NEW_LINE INDENT print ( dic [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' - 1' ) NEW_LINE DEDENT","import itertools NEW_LINE import sys NEW_LINE import math NEW_LINE from functools import lru_cache NEW_LINE from queue import Queue NEW_LINE n , a , b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ll = [ [ - 1 for i in range ( 401 ) ] for j in range ( 401 ) ] NEW_LINE ll [ 0 ] [ 0 ] = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ap , bp , price = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for aa in reversed ( range ( 390 ) ) : NEW_LINE INDENT for bb in reversed ( range ( 390 ) ) : NEW_LINE INDENT if ll [ aa ] [ bb ] >= 0 : NEW_LINE INDENT if ll [ aa + ap ] [ bb + bp ] < 0 : NEW_LINE INDENT ll [ aa + ap ] [ bb + bp ] = 99999 NEW_LINE DEDENT ll [ aa + ap ] [ bb + bp ] = min ( ll [ aa + ap ] [ bb + bp ] , ll [ aa ] [ bb ] + price ) NEW_LINE DEDENT DEDENT DEDENT DEDENT ret = 9999999 NEW_LINE for aa in range ( 401 ) : NEW_LINE INDENT for bb in range ( 1 , 401 ) : NEW_LINE INDENT if abs ( float ( aa ) \/ bb - float ( a ) \/ b ) < 0.001 and ll [ aa ] [ bb ] > 0 : NEW_LINE INDENT ret = min ( ret , ll [ aa ] [ bb ] ) NEW_LINE DEDENT DEDENT DEDENT if ret > 900000 : NEW_LINE INDENT print ( ' - 1' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ret ) NEW_LINE DEDENT","def mixing_experiment ( N : int , Ma : int , Mb : int , drags : list ) -> int : NEW_LINE INDENT INF = float ( ' inf ' ) NEW_LINE max_A = min ( 100 , N * max ( a for a , _ , _ in drags ) ) NEW_LINE max_B = min ( 100 , N * max ( b for _ , b , _ in drags ) ) NEW_LINE dp = [ [ INF ] * ( max_B + 1 ) for _ in range ( max_A + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 0 NEW_LINE for ( a , b , c ) in drags : NEW_LINE INDENT for ca in range ( max_A - a , - 1 , - 1 ) : NEW_LINE INDENT for cb in range ( max_B - b , - 1 , - 1 ) : NEW_LINE INDENT dp [ ca + a ] [ cb + b ] = min ( dp [ ca + a ] [ cb + b ] , dp [ ca ] [ cb ] + c ) NEW_LINE DEDENT DEDENT dp [ a ] [ b ] = min ( dp [ a ] [ b ] , c ) NEW_LINE DEDENT ans = INF NEW_LINE for ca in range ( 1 , max_A + 1 ) : NEW_LINE INDENT for cb in range ( 1 , max_B + 1 ) : NEW_LINE INDENT if ca * Mb != cb * Ma : NEW_LINE INDENT continue NEW_LINE DEDENT ans = min ( ans , dp [ ca ] [ cb ] ) NEW_LINE DEDENT DEDENT return ans if 0 < ans and ans < INF else - 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 0 NEW_LINE N , Ma , Mb = map ( int , input ( ) . split ( ) ) NEW_LINE drags = [ tuple ( int ( s ) for s in input ( ) . split ( ) ) for _ in range ( N ) ] NEW_LINE ans = mixing_experiment ( N , Ma , Mb , drags ) NEW_LINE print ( ans ) NEW_LINE DEDENT","from collections import defaultdict NEW_LINE MAX = 40001 NEW_LINE def main ( ) : NEW_LINE INDENT N , Ma , Mb = [ int ( a ) for a in input ( ) . split ( ) ] NEW_LINE abc = [ [ int ( a ) for a in input ( ) . split ( ) ] for _ in range ( N ) ] NEW_LINE dp = [ [ [ MAX for b in range ( 10 * N + 1 ) ] for a in range ( 10 * N + 1 ) ] for i in range ( N ) ] NEW_LINE A , B , C = abc [ 0 ] NEW_LINE mem = { ( 0 , A , B ) : C , ( 0 , 0 , 0 ) : 0 } NEW_LINE def solve ( i , a , b ) : NEW_LINE INDENT if ( i , a , b ) in mem : NEW_LINE INDENT return mem [ ( i , a , b ) ] NEW_LINE DEDENT if i == 0 : NEW_LINE INDENT return MAX NEW_LINE DEDENT ai , bi , ci = abc [ i ] NEW_LINE tukawanai = solve ( i - 1 , a , b ) NEW_LINE if a - ai >= 0 and b - bi >= 0 : NEW_LINE INDENT pre = solve ( i - 1 , a - ai , b - bi ) NEW_LINE if pre != MAX : NEW_LINE INDENT mem [ ( i , a , b ) ] = min ( tukawanai , pre + ci ) NEW_LINE return mem [ ( i , a , b ) ] NEW_LINE DEDENT DEDENT mem [ ( i , a , b ) ] = tukawanai NEW_LINE return mem [ ( i , a , b ) ] NEW_LINE DEDENT res = MAX NEW_LINE for a in range ( 1 , 10 * N + 1 ) : NEW_LINE INDENT aa = a * Mb NEW_LINE if aa % Ma != 0 : NEW_LINE INDENT continue NEW_LINE DEDENT b = aa \/\/ Ma NEW_LINE if b >= 10 * N + 1 : NEW_LINE INDENT continue NEW_LINE DEDENT c = solve ( N - 1 , a , b ) NEW_LINE res = min ( res , c ) NEW_LINE DEDENT if res == MAX : NEW_LINE INDENT res = - 1 NEW_LINE DEDENT print ( res ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"bleu":0.34434144178931564,"rouge_l":0.39079850731466814}
{"id":78,"predictions":["def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE print ( n * 10000 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"references":["D , N = map ( int , input ( ) . split ( ) ) NEW_LINE count = 0 NEW_LINE x = 0 NEW_LINE while count != N : NEW_LINE INDENT x += 1 NEW_LINE if x % 100 ** D == 0 and x % 100 ** ( D + 1 ) != 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( x ) NEW_LINE","d , n = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE if n == 100 : NEW_LINE INDENT print ( pow ( 100 , d ) * 101 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( pow ( 100 , d ) * n ) NEW_LINE DEDENT","import sys NEW_LINE INF = float ( \" inf \" ) NEW_LINE def solve ( D : int , N : int ) : NEW_LINE INDENT if N != 100 : NEW_LINE INDENT print ( str ( N ) + \"00\" * D ) NEW_LINE DEDENT else : NEW_LINE INDENT N = \"101\" NEW_LINE print ( str ( N ) + \"00\" * D ) NEW_LINE DEDENT return NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT def iterate_tokens ( ) : NEW_LINE INDENT for line in sys . stdin : NEW_LINE INDENT for word in line . split ( ) : NEW_LINE INDENT yield word NEW_LINE DEDENT DEDENT DEDENT tokens = iterate_tokens ( ) NEW_LINE D = int ( next ( tokens ) ) NEW_LINE N = int ( next ( tokens ) ) NEW_LINE solve ( D , N ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT","d0 = [ i for i in range ( 102 ) if i != 100 ] NEW_LINE d1 = [ i * 100 for i in d0 ] NEW_LINE d2 = [ i * 100 for i in d1 ] NEW_LINE D , N = map ( int , input ( ) . split ( ) ) NEW_LINE print ( [ d0 , d1 , d2 ] [ D ] [ N ] ) NEW_LINE","d , n = map ( int , input ( ) . split ( ) ) NEW_LINE if d == 0 and n == 100 : NEW_LINE INDENT print ( 101 ) NEW_LINE DEDENT elif d == 0 : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT if d == 1 and n == 100 : NEW_LINE INDENT print ( 10100 ) NEW_LINE DEDENT elif d == 1 : NEW_LINE INDENT print ( 100 * n ) NEW_LINE DEDENT if d == 2 and n == 100 : NEW_LINE INDENT print ( 1010000 ) NEW_LINE DEDENT elif d == 2 : NEW_LINE INDENT print ( 10000 * n ) NEW_LINE DEDENT"],"bleu":0.4701334439015763,"rouge_l":0.4849296433278068}
{"id":79,"predictions":["print ( ( int ( input ( ) ) \/\/ 3 ) + 1 ) NEW_LINE"],"references":["print ( int ( input ( ) ) \/\/ 3 ) NEW_LINE","import math NEW_LINE n = int ( input ( ) ) NEW_LINE ans = math . floor ( n \/ 3 ) NEW_LINE print ( ans ) NEW_LINE","n = int ( input ( ) ) NEW_LINE import math NEW_LINE print ( math . floor ( n \/ 3 ) ) NEW_LINE","print ( int ( input ( ) ) \/\/ 3 ) NEW_LINE","N = int ( input ( ) ) NEW_LINE A = N \/\/ 3 NEW_LINE print ( A ) NEW_LINE"],"bleu":0.6901670171940026,"rouge_l":0.8798076923076923}
{"id":80,"predictions":["s = input ( ) NEW_LINE if s == \" A \" : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT elif s == \" B \" : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT elif s == \" C \" : NEW_LINE INDENT print ( 3 ) NEW_LINE DEDENT elif s == \" D \" : NEW_LINE INDENT print ( 4 ) NEW_LINE DEDENT elif s == \" E \" : NEW_LINE INDENT print ( 5 ) NEW_LINE DEDENT"],"references":["print ( \" A \" + input ( ) [ 8 ] + \" C \" ) NEW_LINE","import sys , re NEW_LINE from collections import deque , defaultdict , Counter NEW_LINE from math import ceil , sqrt , hypot , factorial , pi , sin , cos , radians NEW_LINE from itertools import permutations , combinations , product NEW_LINE from operator import itemgetter , mul NEW_LINE from copy import deepcopy NEW_LINE from string import ascii_lowercase , ascii_uppercase , digits NEW_LINE def input ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def INT ( ) : return int ( input ( ) ) NEW_LINE def MAP ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE INF = float ( ' inf ' ) NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE s = input ( ) . split ( ) NEW_LINE print ( s [ 0 ] [ 0 ] , s [ 1 ] [ 0 ] , s [ 2 ] [ 0 ] , sep = \" \" ) NEW_LINE","from sys import stdin NEW_LINE A , B , C = stdin . readline ( ) . rstrip ( ) . split ( ) NEW_LINE str = B NEW_LINE slice = str [ 0 : 1 ] NEW_LINE a = ' A ' NEW_LINE b = slice NEW_LINE c = ' C ' NEW_LINE print ( a + b + c ) NEW_LINE","s = input ( ) . split ( ' ▁ ' ) NEW_LINE result = ' ' NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT result += s [ i ] [ 0 ] NEW_LINE DEDENT print ( result ) NEW_LINE","_1 , s , _2 = map ( str , input ( ) . split ( ) ) NEW_LINE print ( \" A { } C \" . format ( s [ 0 ] ) ) NEW_LINE"],"bleu":0.14951221694888822,"rouge_l":0.4459269483424073}
{"id":81,"predictions":["s = input ( ) NEW_LINE d = \" ICT \" NEW_LINE e = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if e < 3 : NEW_LINE INDENT if d [ e ] == str . upper ( s [ i ] ) : NEW_LINE INDENT e += 1 NEW_LINE DEDENT DEDENT DEDENT print ( \" NO \" if e != 3 else \" YES \" ) NEW_LINE"],"references":["s = input ( ) NEW_LINE if ( s [ - 1 ] == \" T \" ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT","def tea ( S : str ) -> bool : NEW_LINE INDENT return S . endswith ( ' T ' ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = input ( ) NEW_LINE yes = tea ( S ) NEW_LINE print ( ' YES ' if yes else ' NO ' ) NEW_LINE DEDENT","print ( [ \" YES \" , \" NO \" ] [ not ( input ( ) [ - 1 ] == \" T \" ) ] ) NEW_LINE","moji = input ( ) NEW_LINE moji_list = list ( moji ) NEW_LINE if moji [ - 1 ] == \" T \" : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT","print ( ' YES ' if input ( ) [ - 1 ] == ' T ' else ' NO ' ) NEW_LINE"],"bleu":0.2644149140371218,"rouge_l":0.44363636363636366}
{"id":82,"predictions":["import sys NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE input = sys . stdin . readline NEW_LINE N = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT A [ i - 1 ] -= i NEW_LINE DEDENT ans = 0 NEW_LINE if A [ 0 ] == 0 : NEW_LINE INDENT ans = max ( ans , len ( A ) - 2 ) NEW_LINE DEDENT print ( ans ) NEW_LINE"],"references":["n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if a [ i ] == a [ i - 1 ] : NEW_LINE INDENT ans += 1 NEW_LINE a [ i ] = ' x ' NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE","import numpy as np NEW_LINE N = int ( input ( ) ) NEW_LINE a = [ int ( _ ) for _ in input ( ) . split ( ) ] NEW_LINE List = np . array ( [ ] ) NEW_LINE tmp = 0 NEW_LINE cnt = 0 NEW_LINE for i in a : NEW_LINE INDENT if i == tmp : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT List = np . append ( List , cnt ) NEW_LINE cnt = 1 NEW_LINE tmp = i NEW_LINE DEDENT DEDENT List = np . append ( List , cnt ) NEW_LINE print ( int ( sum ( List \/\/ 2 ) ) ) NEW_LINE","N = int ( input ( ) ) NEW_LINE a = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE counter = 0 NEW_LINE i = 0 NEW_LINE while i < N - 1 : NEW_LINE INDENT if ( a [ i ] == a [ i + 1 ] ) : NEW_LINE INDENT counter += 1 NEW_LINE i += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print ( counter ) NEW_LINE","n = int ( input ( ) ) NEW_LINE alist = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE preva = None NEW_LINE ans = 0 NEW_LINE for a in alist : NEW_LINE INDENT if preva is None : NEW_LINE INDENT preva = a NEW_LINE DEDENT else : NEW_LINE INDENT if preva == a : NEW_LINE INDENT ans += 1 NEW_LINE preva = None NEW_LINE DEDENT else : NEW_LINE INDENT preva = a NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE","N = int ( input ( ) ) NEW_LINE A = [ int ( a ) for a in input ( ) . split ( ) ] NEW_LINE pre = - 1 NEW_LINE c = 0 NEW_LINE ans = 0 NEW_LINE for a in A : NEW_LINE INDENT if a == pre : NEW_LINE INDENT c += 1 NEW_LINE if c % 2 == 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT c = 1 NEW_LINE DEDENT pre = a NEW_LINE DEDENT print ( ans ) NEW_LINE"],"bleu":0.5516177687941061,"rouge_l":0.6062948647156267}
{"id":83,"predictions":["import sys NEW_LINE INF = float ( ' inf ' ) NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def II ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def SI ( ) : return input ( ) NEW_LINE def main ( ) : NEW_LINE INDENT n , x = LI ( ) NEW_LINE A = LI ( ) NEW_LINE min_a , min_i = INF , - 1 NEW_LINE ans = 0 NEW_LINE for i , a in enumerate ( A ) : NEW_LINE INDENT if a < min_a : NEW_LINE INDENT ans += a NEW_LINE min_i = a NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT print ( main ( ) ) NEW_LINE"],"references":["iN , iX = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE aX = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE aCum = [ 0 ] * iN NEW_LINE aCum [ 0 ] = aX [ 0 ] NEW_LINE for i in range ( 1 , iN ) : NEW_LINE INDENT aCum [ i ] = aCum [ i - 1 ] + aX [ i ] NEW_LINE DEDENT def fCeil ( iT , iR ) : NEW_LINE INDENT return - 1 * iT \/\/ iR * - 1 NEW_LINE DEDENT def fCalcCost ( iN , iX , aCum , iK ) : NEW_LINE INDENT return ( iN + iK ) * iX + 5 * aCum [ - 1 ] + sum ( 2 * aCum [ - i * iK - 1 ] for i in range ( 2 , fCeil ( iN , iK ) ) ) NEW_LINE DEDENT iTotalCost = fCalcCost ( iN , iX , aCum , 1 ) NEW_LINE iULim = fCeil ( iN , 2 ) + 1 NEW_LINE for iK in range ( 2 , fCeil ( iN , 2 ) + 1 ) : NEW_LINE INDENT iThisCost = fCalcCost ( iN , iX , aCum , iK ) NEW_LINE if iThisCost > iTotalCost : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT iTotalCost = iThisCost NEW_LINE DEDENT DEDENT print ( iTotalCost ) NEW_LINE","from collections import defaultdict , deque NEW_LINE import sys , heapq , bisect , math , itertools , string , queue , datetime NEW_LINE sys . setrecursionlimit ( 10 ** 8 ) NEW_LINE INF = float ( ' inf ' ) NEW_LINE mod = 10 ** 9 + 7 NEW_LINE def inpl ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def inpls ( ) : return list ( input ( ) . split ( ) ) NEW_LINE N , X = inpl ( ) NEW_LINE xx = inpl ( ) NEW_LINE sum_xx = [ 0 ] NEW_LINE tmp = 0 NEW_LINE for x in xx : NEW_LINE INDENT tmp += x NEW_LINE sum_xx . append ( tmp ) NEW_LINE DEDENT ans = INF NEW_LINE for k in range ( 1 , N + 1 ) : NEW_LINE INDENT tmp = X * ( k + N ) NEW_LINE i = 0 NEW_LINE l = N - k NEW_LINE r = N NEW_LINE while True : NEW_LINE INDENT if i <= 1 : cost = 5 NEW_LINE else : cost = 3 + i * 2 NEW_LINE if l >= 0 : NEW_LINE INDENT tmp += ( sum_xx [ r ] - sum_xx [ l ] ) * cost NEW_LINE DEDENT else : NEW_LINE INDENT tmp += ( sum_xx [ r ] - sum_xx [ 0 ] ) * cost NEW_LINE break NEW_LINE DEDENT l -= k NEW_LINE r -= k NEW_LINE i += 1 NEW_LINE DEDENT ans = min ( ans , tmp ) NEW_LINE DEDENT print ( ans ) NEW_LINE","from itertools import accumulate NEW_LINE N , X = map ( int , input ( ) . split ( ) ) NEW_LINE dust_acc = [ 0 ] + list ( accumulate ( list ( map ( int , input ( ) . split ( ) ) ) [ : : - 1 ] ) ) NEW_LINE dust_acc += [ dust_acc [ - 1 ] ] * N NEW_LINE coef = [ 5 ] + [ 5 + i * 2 for i in range ( N - 1 ) ] NEW_LINE ans = float ( \" inf \" ) NEW_LINE for robot_count in range ( 1 , N + 1 ) : NEW_LINE INDENT cost = sum ( ( plus - minus ) * c for plus , minus , c in zip ( dust_acc [ robot_count : : robot_count ] , dust_acc [ : N : robot_count ] , coef ) ) + robot_count * X NEW_LINE if ans > cost : NEW_LINE INDENT ans = cost NEW_LINE DEDENT DEDENT print ( ans + N * X ) NEW_LINE","import sys NEW_LINE from itertools import accumulate NEW_LINE def solve ( N : int , X : int , x : \" List [ int ] \" ) : NEW_LINE INDENT coeff = [ 2 * i + 1 if i >= 3 else 5 for i in range ( N + 1 ) ] NEW_LINE acc = list ( accumulate ( [ 0 ] + x ) ) NEW_LINE tmp = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT tmp += coeff [ N - i ] * x [ i ] NEW_LINE DEDENT tmp += N * X + X NEW_LINE ans = tmp NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT tmp_ans = 0 NEW_LINE p , q = N \/\/ i , N % i NEW_LINE for j in range ( p ) : NEW_LINE INDENT tmp_ans += coeff [ p - j ] * ( acc [ q + i * ( j + 1 ) ] - acc [ q + i * j ] ) NEW_LINE DEDENT if q > 0 : NEW_LINE INDENT tmp_ans += coeff [ p + 1 ] * acc [ q ] NEW_LINE DEDENT tmp_ans += N * X + i * X NEW_LINE ans = min ( ans , tmp_ans ) NEW_LINE DEDENT print ( ans ) NEW_LINE return NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT def iterate_tokens ( ) : NEW_LINE INDENT for line in sys . stdin : NEW_LINE INDENT for word in line . split ( ) : NEW_LINE INDENT yield word NEW_LINE DEDENT DEDENT DEDENT tokens = iterate_tokens ( ) NEW_LINE N = int ( next ( tokens ) ) NEW_LINE X = int ( next ( tokens ) ) NEW_LINE x = [ int ( next ( tokens ) ) for _ in range ( N ) ] NEW_LINE solve ( N , X , x ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT","def E ( i , x ) : NEW_LINE INDENT if i == 1 : NEW_LINE INDENT return 5 * x NEW_LINE DEDENT else : NEW_LINE INDENT return ( 2 * i + 1 ) * x NEW_LINE DEDENT DEDENT N , X = map ( int , input ( ) . split ( ) ) NEW_LINE G = [ int ( _ ) for _ in input ( ) . split ( ) ] NEW_LINE SumG = [ 0 for i in range ( N ) ] NEW_LINE SumG [ 0 ] = G [ 0 ] NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT SumG [ i + 1 ] = SumG [ i ] + G [ i + 1 ] NEW_LINE DEDENT pick = N * X NEW_LINE cost = float ( \" inf \" ) NEW_LINE for k in range ( 1 , N + 1 ) : NEW_LINE INDENT trush = k * X NEW_LINE carry = 0 NEW_LINE i , upper , lower = 1 , N - 1 , N - 1 - k NEW_LINE while lower >= 0 : NEW_LINE INDENT carry += E ( i , SumG [ upper ] - SumG [ lower ] ) NEW_LINE i , upper , lower = i + 1 , lower , lower - k NEW_LINE DEDENT carry += E ( i , SumG [ upper ] ) NEW_LINE cost = min ( cost , pick + trush + carry ) NEW_LINE DEDENT print ( cost ) NEW_LINE"],"bleu":0.39421615968236184,"rouge_l":0.37683703992716866}
{"id":84,"predictions":["a , b = map ( int , input ( ) . split ( ) ) NEW_LINE ans = a + b NEW_LINE print ( ans ) NEW_LINE"],"references":["a , b , h = map ( int , open ( 0 ) . read ( ) . split ( ) ) NEW_LINE S = int ( ( a + b ) * h \/ 2 ) NEW_LINE print ( S ) NEW_LINE","def trapezoids ( a : int , b : int , h : int ) -> int : NEW_LINE INDENT return ( a + b ) * h \/\/ 2 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a , b , h = [ int ( input ( ) ) for _ in range ( 3 ) ] NEW_LINE ans = trapezoids ( a , b , h ) NEW_LINE print ( ans ) NEW_LINE DEDENT","a = int ( input ( ) ) NEW_LINE b = int ( input ( ) ) NEW_LINE h = int ( input ( ) ) NEW_LINE print ( int ( ( a + b ) * h \/ 2 ) ) NEW_LINE","a , b , h = map ( int , open ( 0 ) ) ; print ( ( a + b ) * h \/\/ 2 ) NEW_LINE","a = int ( input ( ) ) NEW_LINE b = int ( input ( ) ) NEW_LINE h = int ( input ( ) ) NEW_LINE print ( int ( h * ( a + b ) \/ 2 ) ) NEW_LINE"],"bleu":0.6835448202351337,"rouge_l":0.6676882661996498}
{"id":85,"predictions":["import sys NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE input = sys . stdin . readline NEW_LINE N = int ( input ( ) ) NEW_LINE S = [ input ( ) for _ in range ( N ) ] NEW_LINE dp = [ [ 0 , 0 ] for _ in range ( N ) ] NEW_LINE dp [ 0 ] [ 0 ] = 0 NEW_LINE pos = [ 0 , 0 ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT p = S [ i ] [ j ] NEW_LINE if p == - 1 : NEW_LINE INDENT dp [ i + 1 ] [ j ] = min ( dp [ i + 1 ] [ j ] , dp [ i ] [ j ] + 1 ) NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if S [ i ] [ j ] == \" o \" : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i + 1 ] [ j ] ] + 1 ) NEW_LINE DEDENT DEDENT ans += 1 NEW_LINE DEDENT print ( ans ) NEW_LINE"],"references":["field = [ ] NEW_LINE n = int ( input ( ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT field . append ( list ( map ( str , input ( ) ) ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ' . ' in field [ i ] : NEW_LINE INDENT j = n - field [ i ] [ : : - 1 ] . index ( ' . ' ) - 1 NEW_LINE field [ i ] = [ ' o ' ] * n NEW_LINE if i != n - 1 : NEW_LINE INDENT field [ i + 1 ] [ j : ] = [ ' O ' ] * len ( field [ i + 1 ] [ j : ] ) NEW_LINE DEDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE","import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE inf = 10 ** 20 NEW_LINE mod = 10 ** 9 + 7 NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def F ( ) : return float ( sys . stdin . readline ( ) ) NEW_LINE def S ( ) : return input ( ) NEW_LINE def main ( ) : NEW_LINE INDENT n = I ( ) NEW_LINE k = inf NEW_LINE r = 0 NEW_LINE for _ in range ( n ) : NEW_LINE INDENT s = S ( ) [ : k ] NEW_LINE if ' . ' not in s : NEW_LINE INDENT k = inf NEW_LINE continue NEW_LINE DEDENT ri = s . rindex ( ' . ' ) NEW_LINE r += 1 NEW_LINE k = ri NEW_LINE DEDENT return r NEW_LINE DEDENT print ( main ( ) ) NEW_LINE","N = int ( input ( ) ) NEW_LINE lines = [ input ( ) for i in range ( N ) ] NEW_LINE count = 0 ; y = - 1 ; flag = False NEW_LINE while y < N - 1 : NEW_LINE INDENT y += 1 NEW_LINE x = N NEW_LINE while x > 0 : NEW_LINE INDENT x -= 1 NEW_LINE if ( lines [ y ] [ x ] == ' . ' ) : NEW_LINE INDENT count += 1 NEW_LINE if y + 1 <= N - 1 : y += 1 NEW_LINE else : flag = True ; break NEW_LINE DEDENT DEDENT if flag : break NEW_LINE DEDENT print ( count ) NEW_LINE","def solve ( n , s ) : NEW_LINE INDENT ans = 0 NEW_LINE p = n NEW_LINE for si in s : NEW_LINE INDENT j = si . rfind ( ' . ' , 0 , p ) NEW_LINE if j != - 1 : NEW_LINE INDENT ans += 1 NEW_LINE p = j NEW_LINE DEDENT else : NEW_LINE INDENT p = n NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = input ( ) NEW_LINE n = int ( n ) NEW_LINE s = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT si = input ( ) NEW_LINE s . append ( si ) NEW_LINE DEDENT print ( solve ( n , s ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT","a = int ( input ( ) ) NEW_LINE all = 0 NEW_LINE fl = 0 NEW_LINE x = a NEW_LINE for i in range ( a ) : NEW_LINE INDENT fl = 0 NEW_LINE b = input ( ) NEW_LINE if ( a == 1 ) : NEW_LINE INDENT if ( b [ 0 ] == \" . \" ) : NEW_LINE INDENT all = 1 NEW_LINE DEDENT DEDENT elif ( x == 0 ) : NEW_LINE INDENT x = a NEW_LINE DEDENT else : NEW_LINE INDENT for j in reversed ( range ( x ) ) : NEW_LINE INDENT if ( b [ j ] == \" . \" ) : NEW_LINE INDENT x = j NEW_LINE all += 1 NEW_LINE fl = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( fl == 0 ) : NEW_LINE INDENT x = a NEW_LINE DEDENT DEDENT DEDENT print ( all ) NEW_LINE"],"bleu":0.4550873678482184,"rouge_l":0.4597854039194821}
{"id":86,"predictions":["import sys , math , itertoolsfrom collections import Counter , deque , defaultdictfrom bisect import bisect_left , bisect_right from heapq import heappop , heappush , heapify , nlargestfrom copy import deepcopymod = 10 ** 9 + 7 INF = float ( ' inf ' ) def inp ( ) : return int ( sys . stdin . readline ( ) ) def inpl ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) def inpl_1 ( ) : return list ( map ( lambda x : int ( x ) - 1 , sys . stdin . readline ( ) . split ( ) ) ) def inps ( ) : return sys . stdin . readline ( ) def inpsl ( x ) : tmp = sys . stdin . readline ( ) ; return list ( tmp [ : x ] ) def err ( x ) : print ( x ) ; exit ( )   n = inp ( ) p = inpl ( ) ; p . sort ( ) res = 0 for i in range ( n + 1 ) : res += abs ( p [ i ] - ( i + 1 ) ) NEW_LINE"],"references":["n = int ( input ( ) ) NEW_LINE t = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE v = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE maxspeed = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT maxspeed [ i ] = min ( v [ i ] , v [ i - 1 ] , t [ i ] + maxspeed [ i + 1 ] ) NEW_LINE DEDENT def dist ( i , first ) : NEW_LINE INDENT ta = v [ i ] - first NEW_LINE tb = v [ i ] - maxspeed [ i + 1 ] NEW_LINE if ta + tb <= t [ i ] : NEW_LINE INDENT c = ( first + v [ i ] ) * ta \/ 2 + v [ i ] * ( t [ i ] - ta - tb ) + ( maxspeed [ i + 1 ] + v [ i ] ) * tb \/ 2 NEW_LINE lastspeed = maxspeed [ i + 1 ] NEW_LINE DEDENT elif maxspeed [ i + 1 ] - first > t [ i ] : NEW_LINE INDENT c = ( first + first + t [ i ] ) * t [ i ] \/ 2 NEW_LINE lastspeed = first + t [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT a = ( maxspeed [ i + 1 ] + t [ i ] - first ) \/ 2 NEW_LINE c = ( first + first + a ) * a \/ 2 + ( first + a + maxspeed [ i + 1 ] ) * ( t [ i ] - a ) \/ 2 NEW_LINE lastspeed = maxspeed [ i + 1 ] NEW_LINE DEDENT return c , lastspeed NEW_LINE DEDENT ans = 0 NEW_LINE firstspeed = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT d , firstspeed = dist ( i , firstspeed ) NEW_LINE ans += d NEW_LINE DEDENT print ( ans ) NEW_LINE","def atcoder_express ( N : int , T : list , V : list ) -> float : NEW_LINE INDENT MAXT = sum ( T ) NEW_LINE graph = [ 0 ] * ( 2 * MAXT + 1 ) NEW_LINE T = [ 0 , 0 ] + T + [ 0 ] NEW_LINE for i in range ( N + 2 ) : NEW_LINE INDENT T [ i + 1 ] += T [ i ] NEW_LINE DEDENT V = [ 0 ] + V + [ 0 ] NEW_LINE conditions = [ ] NEW_LINE for i in range ( N + 2 ) : NEW_LINE INDENT v , l , r = V [ i ] , T [ i ] , T [ i + 1 ] NEW_LINE conditions . append ( ( l , r , v ) ) NEW_LINE DEDENT total = 0.0 NEW_LINE prev_v = 0.0 NEW_LINE for t in range ( MAXT * 2 + 1 ) : NEW_LINE INDENT min_v = float ( ' inf ' ) NEW_LINE x = t \/ 2 NEW_LINE for l , r , v in conditions : NEW_LINE INDENT if x < l : NEW_LINE INDENT min_v = min ( min_v , v + ( l - x ) ) NEW_LINE DEDENT elif r < x : NEW_LINE INDENT min_v = min ( min_v , v + ( x - r ) ) NEW_LINE DEDENT else : NEW_LINE INDENT min_v = min ( min_v , v ) NEW_LINE DEDENT DEDENT total += ( prev_v + min_v ) * 0.5 \/ 2 NEW_LINE prev_v = min_v NEW_LINE DEDENT return total NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE T = [ int ( s ) for s in input ( ) . split ( ) ] NEW_LINE V = [ int ( s ) for s in input ( ) . split ( ) ] NEW_LINE ans = atcoder_express ( N , T , V ) NEW_LINE print ( ans ) NEW_LINE DEDENT","import sys , collections , bisect , math , itertools NEW_LINE from fractions import gcd NEW_LINE input = sys . stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE t = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE v = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE maxspeed = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT maxspeed [ i ] = min ( v [ i ] , v [ i - 1 ] , t [ i ] + maxspeed [ i + 1 ] ) NEW_LINE DEDENT def dist ( first , i ) : NEW_LINE INDENT ti = t [ i ] NEW_LINE vi = v [ i ] NEW_LINE mi1 = maxspeed [ i + 1 ] NEW_LINE ta = vi - first NEW_LINE tb = vi - mi1 NEW_LINE if ta + tb <= ti : NEW_LINE INDENT c = ( first + vi ) * ta \/ 2 + vi * ( ti - ta - tb ) + ( mi1 + vi ) * tb \/ 2 NEW_LINE lastspeed = mi1 NEW_LINE DEDENT elif mi1 - first > ti : NEW_LINE INDENT c = ( first + first + ti ) * ti \/ 2 NEW_LINE lastspeed = first + ti NEW_LINE DEDENT else : NEW_LINE INDENT a = ( mi1 + ti - first ) \/ 2 NEW_LINE c = ( first + first + a ) * a \/ 2 + ( first + a + mi1 ) * ( ti - a ) \/ 2 NEW_LINE lastspeed = mi1 NEW_LINE DEDENT return c , lastspeed NEW_LINE DEDENT ans = 0 NEW_LINE firstspeed = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT d , firstspeed = dist ( firstspeed , i ) NEW_LINE ans += d NEW_LINE DEDENT print ( ans ) NEW_LINE","from itertools import chain NEW_LINE n = int ( input ( ) ) NEW_LINE ts = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE vs = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE va = list ( chain . from_iterable ( [ v ] * ( 2 * t ) for t , v in zip ( ts , vs ) ) ) NEW_LINE va = [ min ( v1 , v2 ) for v1 , v2 in zip ( [ 0 ] + va , va + [ 0 ] ) ] NEW_LINE lt = len ( va ) NEW_LINE pv = 0 NEW_LINE for ct in range ( 1 , lt ) : NEW_LINE INDENT va [ ct ] = pv = min ( va [ ct ] , pv + 0.5 ) NEW_LINE DEDENT pv = 0 NEW_LINE for ct in range ( lt - 1 , 0 , - 1 ) : NEW_LINE INDENT va [ ct ] = pv = min ( va [ ct ] , pv + 0.5 ) NEW_LINE DEDENT print ( sum ( ( v1 + v2 ) \/ 4 for v1 , v2 in zip ( va , va [ 1 : ] ) ) ) NEW_LINE","def calc_area ( v_end , v_start , v_max , dt ) : NEW_LINE INDENT kouten_v = ( v_end + v_start + dt ) \/ 2 NEW_LINE kouten_t = kouten_v - v_start NEW_LINE kouten_t_limit1 = max ( v_max - v_start , 0 ) NEW_LINE kouten_t_limit2 = min ( v_end + dt - v_max , dt ) NEW_LINE if 0 < kouten_t < dt : NEW_LINE INDENT area = ( v_start + kouten_v ) * kouten_t \/ 2 NEW_LINE area += ( v_end + kouten_v ) * ( dt - kouten_t ) \/ 2 NEW_LINE area -= ( kouten_t_limit2 - kouten_t_limit1 ) * max ( 0 , ( kouten_v - v_max ) ) \/ 2 NEW_LINE DEDENT else : NEW_LINE INDENT area = ( v_start + v_end ) * dt \/ 2 NEW_LINE DEDENT return area NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE t = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE v = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE max_velocity = [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT max_velocity_ = min ( v [ i - 1 ] , v [ i ] , max_velocity [ i - 1 ] + t [ i - 1 ] , sum ( t ) - sum ( t [ : i ] ) ) NEW_LINE max_velocity . append ( max_velocity_ ) NEW_LINE DEDENT max_velocity . append ( 0 ) NEW_LINE ok = 0 NEW_LINE while ok == 0 : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT if abs ( ( max_velocity [ i + 1 ] - max_velocity [ i ] ) \/ t [ i ] ) > 1 : NEW_LINE INDENT max_velocity [ i ] = max_velocity [ i ] - 1 NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT ok = 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += calc_area ( max_velocity [ i + 1 ] , max_velocity [ i ] , v [ i ] , t [ i ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE"],"bleu":0.2757969898770282,"rouge_l":0.3528429538732581}
{"id":87,"predictions":["import sys NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE INF = 10 ** 18 NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def II ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def SI ( ) : return input ( ) NEW_LINE from collections import Counter NEW_LINE def main ( ) : NEW_LINE INDENT N , M = LI ( ) NEW_LINE blue = [ ] NEW_LINE for _ in range ( M ) : NEW_LINE INDENT a , b , c = LI ( ) NEW_LINE if sum ( blue ) < M : NEW_LINE INDENT blue . append ( ( sum ( blue ) ) NEW_LINE DEDENT DEDENT return sum ( blue ) NEW_LINE DEDENT main ( ) NEW_LINE"],"references":["import itertools NEW_LINE N , M = map ( int , input ( ) . split ( ) ) NEW_LINE score = [ 0 ] * ( M + 1 ) NEW_LINE s_sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT l , r , s = map ( int , input ( ) . split ( ) ) NEW_LINE score [ ( l - 1 ) ] += s NEW_LINE score [ r ] += - s NEW_LINE s_sum += s NEW_LINE DEDENT score_list = list ( itertools . accumulate ( score ) ) NEW_LINE ans = s_sum - min ( score_list [ : - 1 ] ) NEW_LINE print ( ans ) NEW_LINE","import sys NEW_LINE input = sys . stdin . readline NEW_LINE inf = 10 ** 18 NEW_LINE N , M = map ( int , input ( ) . split ( ) ) NEW_LINE lrs = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] NEW_LINE imos = [ 0 ] * ( M + 1 ) NEW_LINE for li , ri , si in lrs : NEW_LINE INDENT imos [ li - 1 ] += si NEW_LINE imos [ ri ] -= si NEW_LINE DEDENT tmp = 0 NEW_LINE loss = [ 0 ] * M NEW_LINE for i , imosi in enumerate ( imos ) : NEW_LINE INDENT if i == M : break NEW_LINE tmp += imosi NEW_LINE loss [ i ] = tmp NEW_LINE DEDENT print ( sum ( [ si for li , ri , si in lrs ] ) - min ( loss ) ) NEW_LINE","N , m = map ( int , input ( ) . split ( ) ) NEW_LINE cry = [ 0 for i in range ( m + 1 ) ] NEW_LINE data = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT li , ri , si = map ( int , input ( ) . split ( ) ) NEW_LINE if not ( li == 1 and ri == N ) : NEW_LINE INDENT cry [ li - 1 ] += 1 NEW_LINE cry [ ri ] -= 1 NEW_LINE data . append ( [ li , ri , si ] ) NEW_LINE DEDENT DEDENT cur = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT cur += cry [ i ] NEW_LINE cry [ i ] = cur NEW_LINE DEDENT cry . remove ( cry [ - 1 ] ) NEW_LINE res = [ ] NEW_LINE small = min ( cry ) NEW_LINE if small == 0 : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( data ) ) : NEW_LINE INDENT count += data [ i ] [ 2 ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT while small in cry : NEW_LINE INDENT count = 0 NEW_LINE ind = cry . index ( small ) NEW_LINE for i in range ( len ( data ) ) : NEW_LINE INDENT if not ( data [ i ] [ 0 ] <= ind + 1 <= data [ i ] [ 1 ] ) : NEW_LINE INDENT count += data [ i ] [ 2 ] NEW_LINE DEDENT DEDENT cry [ ind ] = 10 ** 6 NEW_LINE res . append ( count ) NEW_LINE DEDENT count = max ( res ) NEW_LINE DEDENT print ( count ) NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) NEW_LINE SUM = 0 NEW_LINE c = [ 0 ] * ( m + 10 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT l , r , s = map ( int , input ( ) . split ( ) ) NEW_LINE c [ l - 1 ] += s NEW_LINE c [ r ] -= s NEW_LINE SUM += s NEW_LINE DEDENT for i in range ( m + 5 ) : NEW_LINE INDENT c [ i + 1 ] += c [ i ] NEW_LINE DEDENT print ( SUM - min ( c [ : m ] ) ) NEW_LINE","from itertools import accumulate NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE imos = [ 0 for _ in range ( m + 1 ) ] NEW_LINE total = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT l , r , s = map ( int , input ( ) . split ( ) ) NEW_LINE imos [ l - 1 ] += s NEW_LINE imos [ r ] -= s NEW_LINE total += s NEW_LINE DEDENT imos = list ( accumulate ( imos [ : - 1 ] ) ) NEW_LINE print ( total - min ( imos ) ) NEW_LINE"],"bleu":0.22953167855155546,"rouge_l":0.3959724526672273}
{"id":88,"predictions":["import sys NEW_LINE INF = float ( ' inf ' ) NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def II ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def SI ( ) : return input ( ) NEW_LINE def main ( ) : NEW_LINE INDENT n = II ( ) NEW_LINE d = defaultdict ( int ) NEW_LINE for _ in range ( n ) : NEW_LINE INDENT s = input ( ) NEW_LINE if s [ : 1 ] == ' M ' : NEW_LINE INDENT t = ' ' NEW_LINE DEDENT elif s [ - 1 ] == ' + ' : NEW_LINE INDENT t = 1 NEW_LINE DEDENT else : NEW_LINE INDENT t = str ( int ( s [ 0 ] ) ) NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if t [ i ] == '6' : NEW_LINE INDENT t = i + 1 NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT d [ i ] = 1 NEW_LINE DEDENT DEDENT return d NEW_LINE DEDENT print ( main ( ) ) NEW_LINE"],"references":["D = int ( input ( ) ) NEW_LINE print ( \" Christmas \" + \" ▁ Eve \" * ( 25 - D ) ) NEW_LINE","d = int ( input ( ) ) NEW_LINE if d == 25 : NEW_LINE INDENT print ( ' Christmas ' ) NEW_LINE DEDENT if d == 24 : NEW_LINE INDENT print ( ' Christmas ▁ Eve ' ) NEW_LINE DEDENT if d == 23 : NEW_LINE INDENT print ( ' Christmas ▁ Eve ▁ Eve ' ) NEW_LINE DEDENT if d == 22 : NEW_LINE INDENT print ( ' Christmas ▁ Eve ▁ Eve ▁ Eve ' ) NEW_LINE DEDENT","def main ( ) : NEW_LINE INDENT a = 25 - int ( input ( ) ) NEW_LINE print ( ' Christmas ' , end = ' ' ) NEW_LINE for i in range ( a ) : NEW_LINE INDENT print ( ' ▁ Eve ' , end = ' ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT","cri = { \"25\" : \" Christmas \" , \"24\" : \" Christmas ▁ Eve \" , \"23\" : \" Christmas ▁ Eve ▁ Eve \" , \"22\" : \" Christmas ▁ Eve ▁ Eve ▁ Eve \" } NEW_LINE print ( cri [ input ( ) ] ) NEW_LINE","d = int ( input ( ) ) NEW_LINE left = 25 - d NEW_LINE s = ' Christmas ' NEW_LINE for i in range ( left ) : NEW_LINE INDENT s += ' ▁ Eve ' NEW_LINE DEDENT print ( s ) NEW_LINE"],"bleu":0.12982342669696387,"rouge_l":0.30833634629972284}
{"id":89,"predictions":["a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a == b : print ( \" Draw \" ) NEW_LINE elif a == 1 : print ( \" Alice \" ) NEW_LINE elif b == 1 : print ( \" Bob \" ) NEW_LINE elif a > b : print ( \" Alice \" ) NEW_LINE else : print ( \" Bob \" ) NEW_LINE"],"references":["n , a , b = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE num = n % ( a + b ) NEW_LINE if num == 0 : NEW_LINE INDENT print ( \" Bug \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Ant \" if num <= a else \" Bug \" ) NEW_LINE DEDENT","N , A , B = map ( int , input ( ) . split ( ) ) NEW_LINE while True : NEW_LINE INDENT N -= A NEW_LINE if N <= 0 : NEW_LINE INDENT res = ' Ant ' NEW_LINE break NEW_LINE DEDENT N -= B NEW_LINE if N <= 0 : NEW_LINE INDENT res = ' Bug ' NEW_LINE break NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE","n , a , b = map ( int , input ( ) . split ( ) ) ; print ( ' BAungt ' [ 0 < n % ( a + b ) <= a : : 2 ] ) NEW_LINE","def main ( ) : NEW_LINE INDENT n , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE while True : NEW_LINE INDENT n -= a NEW_LINE if n <= 0 : NEW_LINE INDENT print ( \" Ant \" ) NEW_LINE return NEW_LINE DEDENT n -= b NEW_LINE if n <= 0 : NEW_LINE INDENT print ( \" Bug \" ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT","N , A , B = map ( int , input ( ) . split ( ) ) NEW_LINE newN = N - N \/\/ ( A + B ) * ( A + B ) NEW_LINE if newN == 0 : NEW_LINE INDENT print ( ' Bug ' ) NEW_LINE DEDENT elif A >= newN : print ( ' Ant ' ) NEW_LINE else : print ( ' Bug ' ) NEW_LINE"],"bleu":0.4111982931543056,"rouge_l":0.5906514551466048}
{"id":90,"predictions":["s = input ( ) NEW_LINE print ( s , sep = \" ▁ \" , sep = \" \" ) NEW_LINE"],"references":["n = input ( ) NEW_LINE print ( n . replace ( \" Right \" , \" > \" ) . replace ( \" AtCoder \" , \" A \" ) . replace ( \" Left \" , \" < \" ) ) NEW_LINE","a = list ( input ( ) . split ( ) ) NEW_LINE c = \" \" NEW_LINE for i in a : NEW_LINE INDENT if i [ 0 ] == \" A \" : NEW_LINE INDENT c += \" A \" NEW_LINE DEDENT else : NEW_LINE INDENT if i [ 0 ] != \" L \" : NEW_LINE INDENT c += \" > \" NEW_LINE DEDENT else : NEW_LINE INDENT c += \" < \" NEW_LINE DEDENT DEDENT c += \" ▁ \" NEW_LINE DEDENT print ( c [ : - 1 ] ) NEW_LINE","print ( * [ \" < \" * ( i [ 0 ] == \" L \" ) + \" > \" * ( i [ 0 ] == \" R \" ) + \" A \" * ( i [ 0 ] == \" A \" ) for i in input ( ) . split ( ) ] ) NEW_LINE","S = list ( input ( ) . split ( ) ) NEW_LINE T = [ ] NEW_LINE for s in S : NEW_LINE INDENT if s == ' Left ' : NEW_LINE INDENT T . append ( ' < ' ) NEW_LINE DEDENT if s == ' Right ' : NEW_LINE INDENT T . append ( ' > ' ) NEW_LINE DEDENT if s == ' AtCoder ' : NEW_LINE INDENT T . append ( ' A ' ) NEW_LINE DEDENT DEDENT print ( ' ▁ ' . join ( T ) ) NEW_LINE","def main ( ) : NEW_LINE INDENT res = { \" Left \" : \" < \" , \" Right \" : \" > \" , \" AtCoder \" : \" A \" } NEW_LINE print ( \" ▁ \" . join ( res [ w ] for w in input ( ) . split ( ) ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"bleu":0.17626255940018434,"rouge_l":0.4287722586691659}
{"id":91,"predictions":["a , b = input ( ) . split ( ) NEW_LINE print ( \" No \" if a == b else \" Yes \" ) NEW_LINE"],"references":["num = input ( ) NEW_LINE print ( \" Yes \" if num [ 0 ] == num [ 1 ] == num [ 2 ] or num [ 1 ] == num [ 2 ] == num [ 3 ] else \" No \" ) NEW_LINE","N = input ( ) NEW_LINE if N [ 0 : 3 ] . count ( N [ 0 ] ) == 3 or N [ 1 : 4 ] . count ( N [ 1 ] ) == 3 : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT","n = input ( ) NEW_LINE count = 1 NEW_LINE prev = \"0\" NEW_LINE for c in n : NEW_LINE INDENT if prev == c : NEW_LINE INDENT count += 1 NEW_LINE if count == 3 : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT count = 1 NEW_LINE DEDENT prev = c NEW_LINE DEDENT print ( \" No \" ) NEW_LINE","N = input ( ) NEW_LINE print ( [ \" Yes \" , \" No \" ] [ not ( N [ 0 ] * 3 in N or N [ 1 ] * 3 in N ) ] ) NEW_LINE","N = input ( ) NEW_LINE N_list = [ int ( i ) for i in N ] NEW_LINE if N_list [ 0 ] == N_list [ 1 ] == N_list [ 2 ] or N_list [ 1 ] == N_list [ 2 ] == N_list [ 3 ] : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.3223677654291796,"rouge_l":0.4123362906632868}
{"id":92,"predictions":["import sys NEW_LINE ns = lambda : sys . stdin . readline ( ) . rstrip ( ) NEW_LINE ni = lambda : int ( ns ( ) ) NEW_LINE nm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE nl = lambda : list ( nm ( ) ) NEW_LINE n , k = nm ( ) NEW_LINE l = nl ( ) NEW_LINE l . sort ( reverse = True ) NEW_LINE ans = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT ans += l [ i ] NEW_LINE DEDENT print ( ans ) NEW_LINE"],"references":["def main ( ) : NEW_LINE INDENT from collections import Counter NEW_LINE n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for index , ( key , value ) in enumerate ( sorted ( Counter ( a ) . items ( ) , key = lambda x : x [ 1 ] , reverse = True ) , 1 ) : NEW_LINE INDENT if index > k : NEW_LINE INDENT ans += value NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT","from collections import defaultdict NEW_LINE N , K = map ( int , input ( ) . split ( ) ) NEW_LINE As = map ( int , input ( ) . split ( ) ) NEW_LINE counts = defaultdict ( int ) NEW_LINE for a in As : NEW_LINE INDENT counts [ a ] += 1 NEW_LINE DEDENT counts = sorted ( counts . values ( ) ) NEW_LINE if len ( counts ) <= K : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT total = 0 NEW_LINE for i in range ( len ( counts ) - K ) : NEW_LINE INDENT total += counts [ i ] NEW_LINE DEDENT print ( total ) NEW_LINE DEDENT","import collections NEW_LINE def inpl ( ) : return [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE N , K = inpl ( ) NEW_LINE A = list ( sorted ( collections . Counter ( inpl ( ) ) . values ( ) ) ) NEW_LINE if len ( A ) <= K : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( sum ( A [ : len ( A ) - K ] ) ) NEW_LINE DEDENT","N , K = map ( int , input ( ) . split ( ) ) NEW_LINE A = [ int ( _ ) for _ in input ( ) . split ( ) ] NEW_LINE num = len ( set ( A ) ) NEW_LINE cnt = [ 0 ] * ( N + 1 ) NEW_LINE ans = 0 NEW_LINE for i in A : NEW_LINE INDENT cnt [ i ] += 1 NEW_LINE DEDENT for i in range ( N + 1 ) : NEW_LINE INDENT if cnt [ i ] == 0 : NEW_LINE INDENT cnt [ i ] = N + 1 NEW_LINE DEDENT DEDENT cnt = sorted ( cnt ) NEW_LINE for i in range ( max ( 0 , num - K ) ) : NEW_LINE INDENT ans += cnt [ i ] NEW_LINE DEDENT print ( ans ) NEW_LINE","from collections import Counter , defaultdict NEW_LINE II = lambda : int ( input ( ) ) NEW_LINE MI = lambda : map ( int , input ( ) . split ( ) ) NEW_LINE def main ( ) : NEW_LINE INDENT N , K = MI ( ) NEW_LINE C = Counter ( MI ( ) ) NEW_LINE return N - sum ( ( c for _ , c in C . most_common ( K ) ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( main ( ) ) NEW_LINE DEDENT"],"bleu":0.4861222670784384,"rouge_l":0.5045591171126713}
{"id":93,"predictions":["a = int ( input ( ) ) NEW_LINE b = int ( input ( ) ) NEW_LINE c = int ( input ( ) ) NEW_LINE d = int ( input ( ) ) NEW_LINE print ( max ( a , b ) * c ) NEW_LINE"],"references":["a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if a [ 0 ] * a [ 1 ] == a [ 2 ] * a [ 3 ] : NEW_LINE INDENT print ( a [ 0 ] * a [ 1 ] ) NEW_LINE DEDENT elif a [ 0 ] * a [ 1 ] > a [ 2 ] * a [ 3 ] : NEW_LINE INDENT print ( a [ 0 ] * a [ 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a [ 2 ] * a [ 3 ] ) NEW_LINE DEDENT","from functools import reduce NEW_LINE def main ( ) : NEW_LINE INDENT a , b , c , d = ( int ( _ ) for _ in input ( ) . split ( ) ) NEW_LINE print ( max ( a * b , c * d ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT","A , B , C , D = map ( int , input ( ) . split ( ) ) NEW_LINE men_1 = A * B NEW_LINE men_2 = C * D NEW_LINE print ( max ( men_1 , men_2 ) ) NEW_LINE","from sys import stdin NEW_LINE a , b , c , d = [ int ( x ) for x in stdin . readline ( ) . rstrip ( ) . split ( ) ] NEW_LINE if a * b >= c * d : NEW_LINE INDENT print ( a * b ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( c * d ) NEW_LINE DEDENT","A , B , C , D = map ( int , input ( ) . split ( ) ) NEW_LINE print ( max ( A * B , C * D ) ) NEW_LINE"],"bleu":0.3391776975317921,"rouge_l":0.5083333333333333}
{"id":94,"predictions":["x , a , b = map ( int , open ( 0 ) ) ; print ( ( x - a ) % b ) NEW_LINE"],"references":["a = int ( input ( ) ) NEW_LINE b = int ( input ( ) ) NEW_LINE print ( b - a % b if a % b != 0 else 0 ) NEW_LINE","a , b = map ( int , open ( 0 ) ) ; print ( - a % b ) NEW_LINE","a = int ( input ( ) ) NEW_LINE b = int ( input ( ) ) NEW_LINE if 1 <= a <= 100 and 1 <= b <= 100 : NEW_LINE INDENT if b <= a : NEW_LINE INDENT if a % b == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif a % b != 0 : NEW_LINE INDENT print ( b - ( a % b ) ) NEW_LINE DEDENT DEDENT elif a < b : NEW_LINE INDENT print ( b - a ) NEW_LINE DEDENT DEDENT","a , b = eval ( \" int ( input ( ) ) , \" * 2 ) NEW_LINE if a % b == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( b - ( a % b ) ) NEW_LINE DEDENT","a = int ( input ( ) ) NEW_LINE b = int ( input ( ) ) NEW_LINE print ( ( ( a - 1 ) \/\/ b + 1 ) * b - a ) NEW_LINE"],"bleu":0.7515244238805467,"rouge_l":0.9147920927062032}
{"id":95,"predictions":["import sys NEW_LINE import functools NEW_LINE INF = float ( \" inf \" ) NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def S ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def II ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def SI ( ) : return input ( ) NEW_LINE def main ( ) : NEW_LINE INDENT H , W , H = LI ( ) NEW_LINE DEDENT print ( ( main ( ) ) NEW_LINE"],"references":["x , y = map ( int , input ( ) . split ( ) ) NEW_LINE x , y = x - 1 , y - 1 NEW_LINE mod = 1000000007 NEW_LINE c = 1 NEW_LINE for i in range ( min ( x , y ) ) : NEW_LINE INDENT c = ( c * ( x + y - i ) * pow ( i + 1 , mod - 2 , mod ) % mod ) NEW_LINE DEDENT print ( c % mod ) NEW_LINE","import math NEW_LINE import numpy as np NEW_LINE import copy NEW_LINE from collections import defaultdict , Counter NEW_LINE from itertools import product NEW_LINE from bisect import bisect_left , bisect_right NEW_LINE def s_inpl ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE def inpl ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE W , H = s_inpl ( ) NEW_LINE W -= 1 NEW_LINE H -= 1 NEW_LINE MOD = 1000000007 NEW_LINE def power ( a , b ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif b % 2 == 0 : NEW_LINE INDENT d = power ( a , b \/ 2 ) NEW_LINE return ( d * d ) % MOD NEW_LINE DEDENT elif b % 2 == 1 : NEW_LINE INDENT return ( a * power ( a , b - 1 ) ) % MOD NEW_LINE DEDENT DEDENT def div ( a , b ) : NEW_LINE INDENT return ( a * power ( b , MOD - 2 ) ) % MOD NEW_LINE DEDENT print ( div ( math . factorial ( W + H ) , ( math . factorial ( W ) % MOD ) * ( math . factorial ( H ) % MOD ) ) ) NEW_LINE","W , H = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if W > H : NEW_LINE INDENT W , H = H , W NEW_LINE DEDENT mod = int ( 1e9 + 7 ) NEW_LINE def prodmod ( a , b ) : NEW_LINE INDENT return a * b % mod NEW_LINE DEDENT def divmod ( a ) : NEW_LINE INDENT return powermod ( a , mod - 2 ) NEW_LINE DEDENT def powermod ( a , n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return a % mod NEW_LINE DEDENT if n % 2 : NEW_LINE INDENT return powermod ( a , n \/\/ 2 ) ** 2 * a % mod NEW_LINE DEDENT else : NEW_LINE INDENT return powermod ( a , n \/\/ 2 ) ** 2 % mod NEW_LINE DEDENT DEDENT from functools import reduce NEW_LINE print ( prodmod ( reduce ( prodmod , list ( range ( H , H + W - 1 ) ) ) , reduce ( prodmod , [ divmod ( a ) for a in range ( 1 , W ) ] ) ) ) NEW_LINE","from math import factorial NEW_LINE big = int ( 1e9 ) + 7 NEW_LINE def mod_rev_fact ( x ) : NEW_LINE INDENT return pow ( factorial ( x ) , big - 2 , big ) NEW_LINE DEDENT def mod_combi ( n , r ) : NEW_LINE INDENT return ( factorial ( n ) % big ) * ( mod_rev_fact ( r ) * mod_rev_fact ( n - r ) % big ) % big NEW_LINE DEDENT W , H = map ( int , input ( ) . split ( ) ) NEW_LINE print ( mod_combi ( W + H - 2 , H - 1 ) ) NEW_LINE","def extgcd ( a , b ) : NEW_LINE INDENT x , y , u , v = 0 , 1 , 1 , 0 NEW_LINE while a != 0 : NEW_LINE INDENT q , r = b \/\/ a , b % a NEW_LINE m , n = x - u * q , y - v * q NEW_LINE b , a , x , y , u , v = a , r , u , v , m , n NEW_LINE g = b NEW_LINE DEDENT return x , y , g NEW_LINE DEDENT def modinv ( a , m ) : NEW_LINE INDENT x , y , g = extgcd ( a , m ) NEW_LINE if g != 1 : NEW_LINE INDENT print ( \" [ + ] Inverse ▁ does ▁ not ▁ exist . \" ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( m + x ) % m ) % m NEW_LINE DEDENT DEDENT def mod_comb ( n , r , mod ) : NEW_LINE INDENT ans_mul , ans_div = 1 , 1 NEW_LINE for i in range ( r ) : NEW_LINE INDENT ans_mul *= ( n - i ) NEW_LINE ans_div *= ( i + 1 ) NEW_LINE ans_mul %= mod NEW_LINE ans_div %= mod NEW_LINE DEDENT return ans_mul * modinv ( ans_div , mod ) % mod NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT w , h = map ( int , input ( ) . split ( ) ) NEW_LINE mod = int ( 10 ** 9 + 7 ) NEW_LINE print ( mod_comb ( w + h - 2 , h - 1 , mod ) ) NEW_LINE DEDENT main ( ) NEW_LINE"],"bleu":0.3057074977444515,"rouge_l":0.4408950240247577}
{"id":96,"predictions":["N = bin ( int ( input ( ) ) ) [ 2 : ] NEW_LINE ret = [ ' Aoki ' , ' Takahashi ' ] NEW_LINE point = 0 NEW_LINE for i in range ( 1 , len ( N ) ) : NEW_LINE INDENT if N [ i ] == '0' : NEW_LINE INDENT if i % 2 != ( len ( N ) - 1 ) % 2 : NEW_LINE INDENT print ( ret [ i % 2 ] ) NEW_LINE break NEW_LINE DEDENT DEDENT if N [ i ] == '1' : NEW_LINE INDENT if i % 2 == ( len ( N ) - 1 ) % 2 : NEW_LINE INDENT print ( ret [ i % 2 ] ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT print ( ret [ ( len ( N ) - 1 ) % 2 ] ) NEW_LINE DEDENT"],"references":["def extgcd ( a , b ) : NEW_LINE INDENT if b : NEW_LINE INDENT d , y , x = extgcd ( b , a % b ) NEW_LINE y -= ( a \/ b ) * x NEW_LINE return d , x , y NEW_LINE DEDENT else : NEW_LINE INDENT return a , 1 , 0 NEW_LINE DEDENT DEDENT N = int ( input ( ) ) NEW_LINE grundy = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT a , k = map ( int , input ( ) . split ( ) ) NEW_LINE while a % k : NEW_LINE INDENT p , q = divmod ( a , k ) NEW_LINE a -= ( p + 1 ) * ( ( q + p ) \/\/ ( p + 1 ) ) NEW_LINE DEDENT grundy ^= a \/\/ k NEW_LINE DEDENT print ( ' Takahashi ' if grundy else ' Aoki ' ) NEW_LINE","N = int ( input ( ) ) NEW_LINE grundy = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT a , k = map ( int , input ( ) . split ( ) ) NEW_LINE while a % k : NEW_LINE INDENT p , q = divmod ( a , k ) NEW_LINE a -= ( p + 1 ) * ( ( p + q ) \/\/ ( p + 1 ) ) NEW_LINE DEDENT grundy ^= a \/\/ k NEW_LINE DEDENT print ( ' Takahashi ' if grundy else ' Aoki ' ) NEW_LINE","N = int ( input ( ) ) NEW_LINE grundy = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT a , k = map ( int , input ( ) . split ( ) ) NEW_LINE while a % k : NEW_LINE INDENT p , q = divmod ( a , k ) NEW_LINE a -= ( p + 1 ) * ( ( p + q ) \/\/ ( p + 1 ) ) NEW_LINE DEDENT grundy ^= a \/\/ k NEW_LINE DEDENT print ( ' Takahashi ' if grundy else ' Aoki ' ) NEW_LINE","import sys NEW_LINE sys . setrecursionlimit ( 10000000 ) NEW_LINE from math import ceil NEW_LINE def grundy ( a , k ) : NEW_LINE INDENT if a < k : NEW_LINE INDENT return 0 NEW_LINE DEDENT d , m = divmod ( a , k ) NEW_LINE if m == 0 : NEW_LINE INDENT return d NEW_LINE DEDENT d1 = d + 1 NEW_LINE if d > k : NEW_LINE INDENT return grundy ( a - d1 , k ) NEW_LINE DEDENT e = ceil ( m \/ d1 ) * d1 NEW_LINE return grundy ( a - e , k ) NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE nim = 0 NEW_LINE for _ in range ( n ) : NEW_LINE INDENT a , k = map ( int , input ( ) . split ( ) ) NEW_LINE nim ^= grundy ( a , k ) NEW_LINE DEDENT print ( ' Takahashi ' if nim > 0 else ' Aoki ' ) NEW_LINE"],"bleu":0.22549205627511898,"rouge_l":0.3748330216403954}
{"id":97,"predictions":["import sys NEW_LINE input = sys . stdin . readline NEW_LINE N , M = map ( int , input ( ) . rstrip ( ) . split ( ) ) NEW_LINE a = [ int ( i ) for i in input ( ) . rstrip ( ) . split ( ) ] NEW_LINE b = [ int ( i ) for i in a ] NEW_LINE a . sort ( ) NEW_LINE print ( a [ 0 ] ) NEW_LINE"],"references":["N , M = map ( int , input ( ) . split ( ) ) NEW_LINE py = [ ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT py . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE py [ i ] . append ( i ) NEW_LINE DEDENT py . sort ( key = lambda x : ( x [ 0 ] , x [ 1 ] ) ) NEW_LINE number = [ ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT ct = 1 NEW_LINE number . append ( ( str ( py [ i ] [ 0 ] ) . zfill ( 6 ) + str ( ct ) . zfill ( 6 ) , py [ i ] [ 2 ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT if py [ i - 1 ] [ 0 ] == py [ i ] [ 0 ] : NEW_LINE INDENT ct += 1 NEW_LINE number . append ( ( str ( py [ i ] [ 0 ] ) . zfill ( 6 ) + str ( ct ) . zfill ( 6 ) , py [ i ] [ 2 ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT ct = 1 NEW_LINE number . append ( ( str ( py [ i ] [ 0 ] ) . zfill ( 6 ) + str ( ct ) . zfill ( 6 ) , py [ i ] [ 2 ] ) ) NEW_LINE DEDENT DEDENT DEDENT number . sort ( key = lambda x : x [ 1 ] ) NEW_LINE for i in number : NEW_LINE INDENT print ( i [ 0 ] ) NEW_LINE DEDENT","import sys NEW_LINE from collections import defaultdict NEW_LINE from operator import itemgetter NEW_LINE INF = float ( \" inf \" ) NEW_LINE def solve ( N : int , M : int , iPY ) : NEW_LINE INDENT d = defaultdict ( list ) NEW_LINE iPY . sort ( key = itemgetter ( 2 ) ) NEW_LINE for i , p , y in iPY : NEW_LINE INDENT d [ p ] . append ( [ i , p , y ] ) NEW_LINE DEDENT ans = [ ] NEW_LINE for k in d : NEW_LINE INDENT for j , ( i , p , y ) in enumerate ( d [ k ] ) : NEW_LINE INDENT ans . append ( [ i , \" { 0:06d } {1:06d } \" . format ( p , j + 1 ) ] ) NEW_LINE DEDENT DEDENT ans . sort ( ) NEW_LINE for a in ans : NEW_LINE INDENT print ( a [ 1 ] ) NEW_LINE DEDENT return NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT def iterate_tokens ( ) : NEW_LINE INDENT for line in sys . stdin : NEW_LINE INDENT for word in line . split ( ) : NEW_LINE INDENT yield word NEW_LINE DEDENT DEDENT DEDENT tokens = iterate_tokens ( ) NEW_LINE N = int ( next ( tokens ) ) NEW_LINE M = int ( next ( tokens ) ) NEW_LINE iPY = [ [ ] ] * ( M ) NEW_LINE for i in range ( M ) : NEW_LINE INDENT iPY [ i ] = [ i , int ( next ( tokens ) ) , int ( next ( tokens ) ) ] NEW_LINE DEDENT solve ( N , M , iPY ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT","N , M = map ( int , input ( ) . split ( ) ) NEW_LINE py_list = [ ] NEW_LINE d = dict ( ) NEW_LINE for i in range ( M ) : NEW_LINE INDENT p , y = map ( int , input ( ) . split ( ) ) NEW_LINE py_list . append ( [ p , y ] ) NEW_LINE DEDENT py_sorted = sorted ( py_list ) NEW_LINE p_temp = py_sorted [ 0 ] [ 0 ] NEW_LINE count = 1 NEW_LINE for p , y in py_sorted : NEW_LINE INDENT if p_temp != p : NEW_LINE INDENT p_temp = p NEW_LINE count = 1 NEW_LINE DEDENT d [ ( p , y ) ] = count NEW_LINE count += 1 NEW_LINE DEDENT for i in range ( M ) : NEW_LINE INDENT s = d [ ( py_list [ i ] [ 0 ] , py_list [ i ] [ - 1 ] ) ] NEW_LINE s = str ( s ) NEW_LINE ss = str ( py_list [ i ] [ 0 ] ) . zfill ( 6 ) + s . zfill ( 6 ) NEW_LINE print ( ss . strip ( ) ) NEW_LINE DEDENT","class Prefecture ( ) : NEW_LINE INDENT def __init__ ( self , i , P , Y ) : NEW_LINE INDENT self . i = i NEW_LINE self . P = P NEW_LINE self . Y = Y NEW_LINE DEDENT def make_id ( self , x ) : NEW_LINE INDENT upper = str ( self . P ) NEW_LINE while len ( upper ) < 6 : NEW_LINE INDENT upper = \"0\" + upper NEW_LINE DEDENT lower = str ( x ) NEW_LINE while len ( lower ) < 6 : NEW_LINE INDENT lower = \"0\" + lower NEW_LINE DEDENT self . id = upper + lower NEW_LINE DEDENT DEDENT def solve ( ) : NEW_LINE INDENT N , M = list ( map ( int , input ( ) . split ( \" ▁ \" ) ) ) NEW_LINE prefectures = [ None for i in range ( ( N + 1 ) ) ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT p , y = list ( map ( int , input ( ) . split ( \" ▁ \" ) ) ) NEW_LINE if prefectures [ p ] is None : NEW_LINE INDENT prefectures [ p ] = [ ] NEW_LINE prefectures [ p ] . append ( Prefecture ( i , p , y ) ) NEW_LINE DEDENT else : NEW_LINE INDENT prefectures [ p ] . append ( Prefecture ( i , p , y ) ) NEW_LINE DEDENT DEDENT ans = [ ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if prefectures [ i ] is None : NEW_LINE INDENT continue NEW_LINE DEDENT prefectures [ i ] . sort ( key = lambda x : x . Y ) NEW_LINE for j in range ( len ( prefectures [ i ] ) ) : NEW_LINE INDENT prefectures [ i ] [ j ] . make_id ( j + 1 ) NEW_LINE ans . append ( prefectures [ i ] [ j ] ) NEW_LINE DEDENT DEDENT ans . sort ( key = lambda x : x . i ) NEW_LINE for prefecture in ans : NEW_LINE INDENT print ( prefecture . id ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT","import sys NEW_LINE import copy NEW_LINE from bisect import bisect_left NEW_LINE def main ( ) : NEW_LINE INDENT N , M = map ( int , input ( ) . split ( \" ▁ \" ) ) NEW_LINE data_org = [ ] NEW_LINE for _ in range ( M ) : NEW_LINE INDENT p , y = map ( int , input ( ) . split ( \" ▁ \" ) ) NEW_LINE data_org . append ( ( y , p ) ) NEW_LINE DEDENT data_tmp = copy . copy ( data_org ) NEW_LINE data_tmp . sort ( ) NEW_LINE counts = [ 0 for _ in range ( N ) ] NEW_LINE ans = [ ] NEW_LINE for i , val in enumerate ( data_tmp ) : NEW_LINE INDENT y , p = val NEW_LINE p_zero = str ( p ) . zfill ( 6 ) NEW_LINE no = counts [ p - 1 ] + 1 NEW_LINE no_zero = str ( no ) . zfill ( 6 ) NEW_LINE counts [ p - 1 ] += 1 NEW_LINE ans . append ( p_zero + no_zero ) NEW_LINE DEDENT for i , val in enumerate ( data_org ) : NEW_LINE INDENT y , p = val NEW_LINE tmp = bisect_left ( data_tmp , ( y , p ) ) NEW_LINE print ( ans [ tmp ] ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"bleu":0.12250366578207413,"rouge_l":0.350592754608782}
{"id":98,"predictions":["from bisect import bisect_right NEW_LINE n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = sorted ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l , r = 0 , 10 ** 18 + 1 NEW_LINE while r - l > 1 : NEW_LINE INDENT x = ( r + l ) \/\/ 2 NEW_LINE count = sum ( bisect_right ( a , x \/\/ bi ) for bi in b ) NEW_LINE if count >= k : NEW_LINE INDENT l = x NEW_LINE DEDENT else : NEW_LINE INDENT r = x NEW_LINE DEDENT DEDENT print ( r ) NEW_LINE"],"references":["N , K , Q = map ( int , input ( ) . split ( ) ) NEW_LINE As = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 10 ** 9 NEW_LINE for Y in sorted ( As ) [ : N - Q - K + 2 ] : NEW_LINE INDENT cands = [ ] NEW_LINE cs = [ ] NEW_LINE for A in As + [ 0 ] : NEW_LINE INDENT if A < Y : NEW_LINE INDENT if len ( cs ) >= K : NEW_LINE INDENT cands += sorted ( cs ) [ : len ( cs ) - K + 1 ] NEW_LINE DEDENT cs = [ ] NEW_LINE DEDENT else : NEW_LINE INDENT cs += [ A ] NEW_LINE DEDENT DEDENT if len ( cands ) < Q : continue NEW_LINE X = sorted ( cands ) [ Q - 1 ] NEW_LINE ans = min ( ans , X - Y ) NEW_LINE DEDENT print ( ans ) NEW_LINE","def solve ( n , k , q , a ) : NEW_LINE INDENT sorted_pairs = [ ( ai , i ) for i , ai in enumerate ( a ) ] NEW_LINE sorted_pairs . sort ( ) NEW_LINE ans = 10 ** 10 NEW_LINE segments = [ ( 0 , n ) ] NEW_LINE ly = 0 NEW_LINE for i in range ( n - q + 1 ) : NEW_LINE INDENT y , _ = sorted_pairs [ i ] NEW_LINE if y == ly : NEW_LINE INDENT continue NEW_LINE DEDENT ly = y NEW_LINE b = [ ] NEW_LINE for left , right in segments : NEW_LINE INDENT if k <= right - left : NEW_LINE INDENT c = a [ left : right ] . copy ( ) NEW_LINE c . sort ( ) NEW_LINE b += c [ : right - left - k + 1 ] NEW_LINE DEDENT DEDENT if q <= len ( b ) : NEW_LINE INDENT b . sort ( ) NEW_LINE x = b [ q - 1 ] NEW_LINE ans = min ( ans , x - y ) NEW_LINE DEDENT i_end = n - q + 1 NEW_LINE for i2 in range ( i + 1 , n - q + 1 ) : NEW_LINE INDENT if sorted_pairs [ i2 ] [ 0 ] != y : NEW_LINE INDENT i_end = i2 NEW_LINE break NEW_LINE DEDENT DEDENT for i2 in range ( i , i_end ) : NEW_LINE INDENT _ , j = sorted_pairs [ i2 ] NEW_LINE for h , seg in enumerate ( segments ) : NEW_LINE INDENT left , right = seg NEW_LINE if left <= j and j < right : NEW_LINE INDENT segments . pop ( h ) NEW_LINE segments . append ( ( left , j ) ) NEW_LINE segments . append ( ( j + 1 , right ) ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n , k , q = input ( ) . split ( ) NEW_LINE n = int ( n ) NEW_LINE k = int ( k ) NEW_LINE q = int ( q ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( solve ( n , k , q , a ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT","import bisect NEW_LINE N , K , Q = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE A = [ ( int ( v ) , i ) for i , v in enumerate ( input ( ) . split ( ) ) ] NEW_LINE A . sort ( ) NEW_LINE B = [ 0 ] * ( N ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT B [ A [ i ] [ 1 ] ] = i NEW_LINE DEDENT C = [ A [ B [ i ] ] [ 0 ] for i in range ( N ) ] NEW_LINE Candi = set ( range ( N ) ) NEW_LINE ctr = 0 NEW_LINE ans = [ ] NEW_LINE rng = [ - 1 , N ] NEW_LINE while len ( Candi ) >= Q : NEW_LINE INDENT T = sorted ( Candi ) NEW_LINE ans . append ( ( list ( T ) [ 0 ] , list ( T ) [ Q - 1 ] ) ) NEW_LINE x = B . index ( ctr ) NEW_LINE st = bisect . bisect_left ( rng , x ) NEW_LINE Candi = Candi - set ( sorted ( B [ rng [ st - 1 ] + 1 : x ] + [ 2002 ] , reverse = 1 ) [ : K ] ) - set ( sorted ( B [ x : rng [ st ] ] + [ 2002 ] , reverse = 1 ) [ : K ] ) - set ( [ B [ x ] ] ) NEW_LINE bisect . insort_left ( rng , x ) NEW_LINE ctr += 1 NEW_LINE DEDENT print ( min ( [ A [ j ] [ 0 ] - A [ i ] [ 0 ] for i , j in ans ] ) ) NEW_LINE","def add_list ( buf , new_lists , removals ) : NEW_LINE INDENT l = len ( buf ) NEW_LINE if l >= k : NEW_LINE INDENT sbf = sorted ( buf ) NEW_LINE removals . extend ( sbf [ : l - k + 1 ] ) NEW_LINE new_lists . append ( buf ) NEW_LINE DEDENT DEDENT n , k , q = map ( int , input ( ) . split ( ) ) NEW_LINE aaa = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE srt = sorted ( set ( aaa ) ) NEW_LINE lists = [ aaa ] NEW_LINE ans = float ( ' inf ' ) NEW_LINE for a in srt : NEW_LINE INDENT new_lists = [ ] NEW_LINE removals = [ ] NEW_LINE for lst in lists : NEW_LINE INDENT buf = [ ] NEW_LINE for b in lst : NEW_LINE INDENT if a > b : NEW_LINE INDENT add_list ( buf , new_lists , removals ) NEW_LINE buf = [ ] NEW_LINE DEDENT else : NEW_LINE INDENT buf . append ( b ) NEW_LINE DEDENT DEDENT add_list ( buf , new_lists , removals ) NEW_LINE DEDENT if len ( removals ) < q : NEW_LINE INDENT break NEW_LINE DEDENT removals . sort ( ) NEW_LINE ans = min ( ans , removals [ q - 1 ] - a ) NEW_LINE lists = new_lists NEW_LINE DEDENT print ( ans ) NEW_LINE","n , k , q = ( int ( i ) for i in input ( ) . split ( ) ) NEW_LINE a = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE ans = 10 ** 9 NEW_LINE for i in a : NEW_LINE INDENT p , s , f = [ ] , 0 , 1 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if a [ j ] >= i and f : NEW_LINE INDENT s , f = j , 0 NEW_LINE DEDENT elif a [ j ] < i and f - 1 : NEW_LINE INDENT if j - s >= k : NEW_LINE INDENT for j2 in sorted ( a [ s : j ] ) [ : j - s - k + 1 ] : p . append ( j2 ) NEW_LINE DEDENT f = 1 NEW_LINE DEDENT DEDENT if f - 1 and n - s >= k : NEW_LINE INDENT for j2 in sorted ( a [ s : n ] ) [ : n - s - k + 1 ] : p . append ( j2 ) NEW_LINE DEDENT if len ( p ) >= q : ans = min ( ans , sorted ( p ) [ q - 1 ] - i ) NEW_LINE DEDENT print ( ans ) NEW_LINE"],"bleu":0.3462079931962746,"rouge_l":0.4244111463492856}
{"id":99,"predictions":["a = input ( ) . split ( ) print ( a , b ) NEW_LINE"],"references":["a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( b , a ) NEW_LINE","s = input ( ) . split ( ) NEW_LINE A = int ( s [ 0 ] ) NEW_LINE B = int ( s [ 1 ] ) NEW_LINE if 1 <= A and B <= 100 : NEW_LINE INDENT print ( B , A ) NEW_LINE DEDENT","print ( ' { 0[1 ] } ▁ { 0[0 ] } ' . format ( [ i for i in input ( ) . split ( ) ] ) ) NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ' { } ▁ { } ' . format ( m , n ) ) NEW_LINE","* A , = map ( int , input ( ) . split ( ) ) NEW_LINE print ( A [ 1 ] , A [ 0 ] , sep = \" ▁ \" ) NEW_LINE"],"bleu":0.3902775415079818,"rouge_l":0.6756329113924051}
{"id":100,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["from itertools import product NEW_LINE import re NEW_LINE def inpl ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE N = int ( input ( ) ) NEW_LINE C = input ( ) NEW_LINE ans = 2000 NEW_LINE for X in product ( \" ABXY \" , repeat = 4 ) : NEW_LINE INDENT L = \" \" . join ( X [ : 2 ] ) NEW_LINE R = \" \" . join ( X [ 2 : ] ) NEW_LINE ans = min ( ans , len ( C . replace ( L , \" L \" ) . replace ( R , \" R \" ) ) ) NEW_LINE DEDENT print ( ans ) NEW_LINE","BUTTONS = ' ABXY ' NEW_LINE def main ( ) : NEW_LINE INDENT _ = int ( input ( ) ) NEW_LINE c = input ( ) NEW_LINE print ( solve ( c ) ) NEW_LINE DEDENT def solve ( c ) : NEW_LINE INDENT m = float ( ' inf ' ) NEW_LINE for a in shortcuts ( ) : NEW_LINE INDENT for b in shortcuts ( ) : NEW_LINE INDENT if b <= a : NEW_LINE INDENT continue NEW_LINE DEDENT m = min ( m , min_step ( c , a , b ) ) NEW_LINE DEDENT DEDENT return m NEW_LINE DEDENT def min_step ( c , a , b ) : NEW_LINE INDENT dp = [ 0 , 1 ] NEW_LINE for i in range ( len ( c ) - 1 ) : NEW_LINE INDENT if c [ i : i + 2 ] in ( a , b ) : NEW_LINE INDENT dp . append ( min ( dp [ - 2 ] + 1 , dp [ - 1 ] + 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT dp . append ( dp [ - 1 ] + 1 ) NEW_LINE DEDENT DEDENT return dp [ - 1 ] NEW_LINE DEDENT def shortcuts ( ) : NEW_LINE INDENT for a in BUTTONS : NEW_LINE INDENT for b in BUTTONS : NEW_LINE INDENT yield a + b NEW_LINE DEDENT DEDENT DEDENT main ( ) NEW_LINE","import itertools NEW_LINE n = int ( input ( ) ) NEW_LINE s = ' S ' + input ( ) NEW_LINE rr = list ( itertools . product ( [ ' A ' , ' B ' , ' X ' , ' Y ' ] , repeat = 2 ) ) NEW_LINE ll = list ( itertools . product ( [ ' A ' , ' B ' , ' X ' , ' Y ' ] , repeat = 2 ) ) NEW_LINE def count ( l , r ) : NEW_LINE INDENT k = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( s [ i - 1 ] == l [ 0 ] and s [ i ] == l [ 1 ] ) or ( s [ i - 1 ] == r [ 0 ] and s [ i ] == r [ 1 ] ) : NEW_LINE INDENT k [ i ] = min ( k [ i - 1 ] + 1 , k [ i - 2 ] + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT k [ i ] = k [ i - 1 ] + 1 NEW_LINE DEDENT DEDENT return k [ n ] NEW_LINE DEDENT ans = 10 ** 10 NEW_LINE for ri in rr : NEW_LINE INDENT for li in ll : NEW_LINE INDENT ans = min ( ans , count ( li , ri ) ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE","N = int ( input ( ) ) NEW_LINE c = input ( ) NEW_LINE import itertools NEW_LINE command = [ ' A ' , ' B ' , ' X ' , ' Y ' ] NEW_LINE LorR = [ 0 ] * 16 NEW_LINE i = 0 NEW_LINE for ABXY in itertools . product ( command , repeat = 2 ) : NEW_LINE INDENT LorR [ i ] = ABXY NEW_LINE i += 1 NEW_LINE DEDENT choice = [ 0 ] * 120 NEW_LINE i = 0 NEW_LINE for ABXY in itertools . combinations ( LorR , 2 ) : NEW_LINE INDENT choice [ i ] = ABXY NEW_LINE i += 1 NEW_LINE DEDENT count = [ 0 ] * 120 NEW_LINE for i in range ( 120 ) : NEW_LINE INDENT j = 0 NEW_LINE while j < N : NEW_LINE INDENT if j < N - 1 : NEW_LINE INDENT if ( c [ j ] == choice [ i ] [ 0 ] [ 0 ] and c [ j + 1 ] == choice [ i ] [ 0 ] [ 1 ] ) or ( c [ j ] == choice [ i ] [ 1 ] [ 0 ] and c [ j + 1 ] == choice [ i ] [ 1 ] [ 1 ] ) : NEW_LINE INDENT j += 2 NEW_LINE count [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT j += 1 NEW_LINE count [ i ] += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT count [ i ] += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT print ( min ( count ) ) NEW_LINE","from itertools import product NEW_LINE BUTTONS = [ ' A ' , ' B ' , ' X ' , ' Y ' ] NEW_LINE LR_PATTERNS = list ( product ( BUTTONS , BUTTONS ) ) NEW_LINE def main ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE commands = input ( ) . rstrip ( ) NEW_LINE minimum = len ( commands ) NEW_LINE for i , l in enumerate ( LR_PATTERNS ) : NEW_LINE INDENT for j , r in enumerate ( LR_PATTERNS ) : NEW_LINE INDENT if i == j : NEW_LINE INDENT continue NEW_LINE DEDENT tmp = len ( commands . replace ( \" \" . join ( l ) , ' L ' ) . replace ( \" \" . join ( r ) , ' R ' ) ) NEW_LINE if tmp < minimum : NEW_LINE INDENT minimum = tmp NEW_LINE DEDENT DEDENT DEDENT print ( \" { } \" . format ( minimum ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"bleu":0.07360327008346441,"rouge_l":0.26412379512253614}
{"id":101,"predictions":["n , l = open ( 0 ) ; print ( sum ( sorted ( map ( int , l . split ( ) ) ) [ : : 2 ] ) ) NEW_LINE"],"references":["N = int ( input ( ) ) NEW_LINE A = sorted ( [ int ( i ) for i in input ( ) . split ( ) ] , reverse = True ) NEW_LINE print ( sum ( A [ : : 2 ] ) ) NEW_LINE","import math NEW_LINE N = int ( input ( ) ) NEW_LINE A = input ( ) . split ( \" ▁ \" ) NEW_LINE A = [ int ( i ) for i in A ] NEW_LINE A = sorted ( A , reverse = True ) NEW_LINE listA = [ ] NEW_LINE listB = [ ] NEW_LINE c = 0 NEW_LINE for i in range ( math . ceil ( N \/ 2 ) ) : NEW_LINE INDENT listA . append ( A [ i + c ] ) NEW_LINE if N % 2 != 0 and i + c + 1 > N - 1 : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT listB . append ( A [ i + c + 1 ] ) NEW_LINE DEDENT c += 1 NEW_LINE DEDENT print ( sum ( listA ) ) NEW_LINE","_ , a = open ( 0 ) ; print ( sum ( sorted ( map ( int , a . split ( ) ) ) [ : : - 2 ] ) ) NEW_LINE","import math NEW_LINE num = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE arr_new = sorted ( arr , reverse = True ) NEW_LINE ans = 0 NEW_LINE index = 0 NEW_LINE for i in range ( math . ceil ( num \/ 2 ) ) : NEW_LINE INDENT ans += arr_new [ index ] NEW_LINE index += 2 NEW_LINE DEDENT print ( ans ) NEW_LINE","def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE aa = sorted ( map ( int , input ( ) . split ( ) ) , reverse = True ) NEW_LINE score = sum ( a for i , a in enumerate ( aa ) if i % 2 == 0 ) NEW_LINE print ( score ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"bleu":0.8222006970621972,"rouge_l":0.8962085308056871}
{"id":102,"predictions":["n = int ( input ( ) ) s = input ( ) ans = 0 for i in range ( n - 2 ) : if s [ i ] != ' x ' and s [ i + 1 ] == ' x ' and s [ i + 2 ] == ' x ' : ans += 1 print ( ans ) NEW_LINE"],"references":["n = int ( input ( ) ) NEW_LINE l = [ input ( ) for i in range ( n ) ] NEW_LINE sum = 0 NEW_LINE for i in range ( len ( l ) ) : NEW_LINE INDENT for j in range ( 9 ) : NEW_LINE INDENT if l [ i ] [ j ] == ' x ' : NEW_LINE INDENT sum += 1 NEW_LINE DEDENT elif l [ i ] [ j ] == ' o ' and ( i + 1 == len ( l ) or l [ i + 1 ] [ j ] != ' o ' ) : NEW_LINE INDENT sum += 1 NEW_LINE DEDENT DEDENT DEDENT print ( sum ) NEW_LINE","def b_music ( N , Music ) : NEW_LINE INDENT import re NEW_LINE def rotate_counterclockwise ( matrix ) : NEW_LINE INDENT return [ ' ' . join ( s ) for s in list ( map ( list , zip ( * matrix ) ) ) [ : : - 1 ] ] NEW_LINE DEDENT music_rotate = rotate_counterclockwise ( Music ) NEW_LINE ans = 0 NEW_LINE for row in music_rotate : NEW_LINE INDENT ans += row . count ( ' x ' ) NEW_LINE row = re . split ( ' [ . x ] ' , row ) NEW_LINE for element in row : NEW_LINE INDENT if element : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT N = int ( input ( ) ) NEW_LINE Music = [ input ( ) for _ in range ( N ) ] NEW_LINE print ( b_music ( N , Music ) ) NEW_LINE","def inpl ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE N = int ( input ( ) ) NEW_LINE B = [ \" . \" for i in range ( 9 ) ] NEW_LINE for _ in range ( N ) : NEW_LINE INDENT L = input ( ) NEW_LINE for i in range ( 9 ) : NEW_LINE INDENT B [ i ] += L [ i ] NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 9 ) : NEW_LINE INDENT ans += B [ i ] . count ( \" x \" ) + B [ i ] . count ( \" . o \" ) + B [ i ] . count ( \" xo \" ) NEW_LINE DEDENT print ( ans ) NEW_LINE","import numpy as np NEW_LINE import re NEW_LINE N = int ( input ( ) ) NEW_LINE x = np . array ( [ list ( input ( ) ) for _ in range ( N ) ] ) NEW_LINE cnt = [ list ( v ) . count ( ' x ' ) for v in x ] NEW_LINE seq = [ re . sub ( ' o + ' , ' o ' , ' ' . join ( x [ : , i ] ) ) . count ( ' o ' ) for i in range ( 9 ) ] NEW_LINE print ( sum ( cnt ) + sum ( seq ) ) NEW_LINE","N = int ( input ( ) ) NEW_LINE x = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT x . append ( list ( input ( ) ) ) NEW_LINE DEDENT x . append ( \" . . . . . . . . . . \" ) NEW_LINE def dele ( i , k , x ) : NEW_LINE INDENT if x [ i ] [ k ] == \" o \" : NEW_LINE INDENT x [ i ] [ k ] = \" . \" NEW_LINE dele ( i + 1 , k , x ) NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for k in range ( 9 ) : NEW_LINE INDENT if x [ i ] [ k ] == \" x \" : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT elif x [ i ] [ k ] == \" o \" : NEW_LINE INDENT dele ( i + 1 , k , x ) NEW_LINE ans += 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE"],"bleu":0.23308662164112537,"rouge_l":0.48173741362290234}
{"id":103,"predictions":["import sys NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE INF = 10 ** 18 NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def II ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def SI ( ) : return input ( ) NEW_LINE from collections import Counter NEW_LINE def main ( ) : NEW_LINE INDENT N , M = LI ( ) NEW_LINE XY = [ ] NEW_LINE for _ in range ( M ) : NEW_LINE INDENT XY . append ( LI_ ( ) ) NEW_LINE DEDENT balls = [ 1 ] * N NEW_LINE exp = set ( [ 0 ] ) NEW_LINE for x , y in XY : NEW_LINE INDENT balls [ x ] -= 1 NEW_LINE balls [ y ] += 1 NEW_LINE if x in exp : NEW_LINE INDENT exp . add ( y ) NEW_LINE if balls [ x ] == 0 : NEW_LINE INDENT exp . remove ( x ) NEW_LINE DEDENT DEDENT DEDENT ans = len ( exp ) NEW_LINE return ans NEW_LINE DEDENT print ( main ( ) ) NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) NEW_LINE X = [ [ ] for _ in range ( n ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE X [ a - 1 ] . append ( b - 1 ) NEW_LINE X [ b - 1 ] . append ( a - 1 ) NEW_LINE DEDENT path = [ i for i in range ( 2 , n + 1 ) ] NEW_LINE visited = [ 1 ] + [ 0 ] * ( n - 1 ) NEW_LINE def dfs ( v ) : NEW_LINE INDENT if visited == [ 1 ] * n : NEW_LINE INDENT return 1 NEW_LINE DEDENT res = 0 NEW_LINE for x in X [ v ] : NEW_LINE INDENT if visited [ x ] == 0 : NEW_LINE INDENT visited [ x ] = 1 NEW_LINE res += dfs ( x ) NEW_LINE visited [ x ] = 0 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT print ( dfs ( 0 ) ) NEW_LINE","from itertools import permutations NEW_LINE N , M = map ( int , input ( ) . split ( ) ) NEW_LINE E = [ ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT a , b = ( int ( _ ) for _ in input ( ) . split ( ) ) NEW_LINE E . append ( ( a , b ) ) NEW_LINE DEDENT V = ( i + 1 for i in range ( N ) ) NEW_LINE one_strike_cnt = 0 NEW_LINE for vertexs in permutations ( V ) : NEW_LINE INDENT if vertexs [ 0 ] != 1 : NEW_LINE INDENT continue NEW_LINE DEDENT one_strike = True NEW_LINE for vertex_index in range ( len ( vertexs ) - 1 ) : NEW_LINE INDENT flag = False NEW_LINE for i in range ( M ) : NEW_LINE INDENT a , b = E [ i ] NEW_LINE if ( a == vertexs [ vertex_index ] and b == vertexs [ vertex_index + 1 ] ) or ( a == vertexs [ vertex_index + 1 ] and b == vertexs [ vertex_index ] ) : NEW_LINE INDENT flag = True NEW_LINE break NEW_LINE DEDENT DEDENT if not flag : NEW_LINE INDENT one_strike = False NEW_LINE break NEW_LINE DEDENT DEDENT if one_strike : NEW_LINE INDENT one_strike_cnt += 1 NEW_LINE DEDENT DEDENT print ( one_strike_cnt ) NEW_LINE","def one_stroke_path ( N : int , M : int , edges : list ) -> int : NEW_LINE INDENT g = [ [ ] for _ in range ( N ) ] NEW_LINE for u , v in edges : NEW_LINE INDENT g [ u - 1 ] . append ( v - 1 ) NEW_LINE g [ v - 1 ] . append ( u - 1 ) NEW_LINE DEDENT visited = [ False ] * N NEW_LINE visited [ 0 ] = True NEW_LINE def dfs ( current : int , visited_num : int ) -> int : NEW_LINE INDENT if not visited [ current ] and visited_num + 1 == N : NEW_LINE INDENT return 1 NEW_LINE DEDENT visited [ current ] = True NEW_LINE total = sum ( dfs ( to , visited_num + 1 ) for to in g [ current ] if not visited [ to ] ) NEW_LINE visited [ current ] = False NEW_LINE return total NEW_LINE DEDENT return dfs ( 0 , 0 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT M = 0 NEW_LINE N , M = map ( int , input ( ) . split ( ) ) NEW_LINE edges = [ tuple ( int ( s ) for s in input ( ) . split ( ) ) for _ in range ( M ) ] NEW_LINE ans = one_stroke_path ( N , M , edges ) NEW_LINE print ( ans ) NEW_LINE DEDENT","import sys NEW_LINE import collections NEW_LINE ns = lambda : sys . stdin . readline ( ) . rstrip ( ) NEW_LINE ni = lambda : int ( ns ( ) ) NEW_LINE nm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE nl = lambda : list ( nm ( ) ) NEW_LINE nsl = lambda : map ( str , sys . stdin . readline ( ) . split ( ) ) NEW_LINE n , m = nm ( ) NEW_LINE lis = [ [ ] for i in range ( n ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT a , b = nm ( ) NEW_LINE lis [ a - 1 ] . append ( b ) NEW_LINE lis [ b - 1 ] . append ( a ) NEW_LINE DEDENT visited = [ 0 ] * n NEW_LINE def dfs ( v , n , visited ) : NEW_LINE INDENT count = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if visited [ i ] == 0 : NEW_LINE INDENT count = 0 NEW_LINE DEDENT DEDENT if count == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT res = 0 NEW_LINE for i in lis [ v ] : NEW_LINE INDENT if visited [ i - 1 ] == 1 : NEW_LINE INDENT continue NEW_LINE DEDENT visited [ i - 1 ] = 1 NEW_LINE res += dfs ( i - 1 , n , visited ) NEW_LINE visited [ i - 1 ] = 0 NEW_LINE DEDENT return res NEW_LINE DEDENT visited [ 0 ] = 1 NEW_LINE print ( dfs ( 0 , n , visited ) ) NEW_LINE","from collections import deque NEW_LINE def dfs ( v , N , memo ) : NEW_LINE INDENT ans = 0 NEW_LINE if not False in memo . values ( ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT for u in E [ v ] : NEW_LINE INDENT if memo [ u ] != True : NEW_LINE INDENT memo [ u ] = True NEW_LINE ans += dfs ( u , N , memo ) NEW_LINE memo [ u ] = False NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT N , M = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE memo = { i : False for i in range ( 1 , N + 1 ) } NEW_LINE E = { i : [ ] for i in range ( 1 , N + 1 ) } NEW_LINE for i in range ( M ) : NEW_LINE INDENT u , v = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE E [ u ] . append ( v ) NEW_LINE E [ v ] . append ( u ) NEW_LINE DEDENT memo [ 1 ] = True NEW_LINE print ( dfs ( 1 , N , memo ) ) NEW_LINE"],"bleu":0.35150834432826117,"rouge_l":0.4416702471316497}
{"id":104,"predictions":["def main ( ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n < m : NEW_LINE INDENT n , m = n , m NEW_LINE DEDENT if m == 1 : NEW_LINE INDENT print ( n * m ) NEW_LINE return NEW_LINE DEDENT elif m == 2 : NEW_LINE INDENT print ( m \/\/ 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( n * m + 1 ) \/\/ 2 ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"references":["N , M = map ( int , input ( ) . split ( ) ) NEW_LINE S_num = N NEW_LINE cc_num = M \/\/ 2 NEW_LINE if ( S_num <= cc_num ) : NEW_LINE INDENT ans = ( S_num + cc_num ) \/\/ 2 NEW_LINE DEDENT else : NEW_LINE INDENT ans = cc_num NEW_LINE DEDENT print ( ans ) NEW_LINE","def getIntList ( ) : return [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE def db ( x ) : NEW_LINE INDENT global debug NEW_LINE if debug : NEW_LINE INDENT print ( x ) NEW_LINE DEDENT DEDENT def solve ( ) : NEW_LINE INDENT if N >= M \/\/ 2 : NEW_LINE INDENT return M \/\/ 2 NEW_LINE DEDENT return N + ( M - N * 2 ) \/\/ 4 NEW_LINE DEDENT debug = False NEW_LINE N , M = getIntList ( ) NEW_LINE db ( ( N , M ) ) NEW_LINE print ( solve ( ) ) NEW_LINE","def inpl ( ) : return [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE N , M = inpl ( ) NEW_LINE a = ( 2 * N + M ) \/\/ 4 NEW_LINE print ( min ( a , M \/\/ 2 ) ) NEW_LINE","import sys NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE INF = 10 ** 18 NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE def POW ( x , y ) : NEW_LINE INDENT if y == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif y == 1 : NEW_LINE INDENT return x NEW_LINE DEDENT elif y % 2 == 0 : NEW_LINE INDENT return POW ( x , y \/\/ 2 ) ** 2 % MOD NEW_LINE DEDENT else : NEW_LINE INDENT return POW ( x , y \/\/ 2 ) ** 2 * x % MOD NEW_LINE DEDENT DEDENT def mod_factorial ( x , y ) : return x * POW ( y , MOD - 2 ) % MOD NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def II ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def SI ( ) : return input ( ) NEW_LINE from functools import reduce NEW_LINE def main ( ) : NEW_LINE INDENT N , M = LI ( ) NEW_LINE if N >= M \/\/ 2 : NEW_LINE INDENT return M \/\/ 2 NEW_LINE DEDENT rem = M - 2 * N NEW_LINE ans = N + rem \/\/ 4 NEW_LINE return ans NEW_LINE DEDENT print ( main ( ) ) NEW_LINE","S , C = map ( int , input ( ) . split ( ' ▁ ' ) ) NEW_LINE print ( min ( S , C \/\/ 2 ) + ( C - min ( S , C \/\/ 2 ) * 2 ) \/\/ 4 ) NEW_LINE"],"bleu":0.43219153356126044,"rouge_l":0.5511678525048928}
{"id":105,"predictions":["def main ( ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE if k >= 2 : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"references":["s = input ( ) NEW_LINE K = int ( input ( ) ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if i == K - 1 : NEW_LINE INDENT print ( s [ i ] ) NEW_LINE break NEW_LINE DEDENT if s [ i ] == '1' : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT print ( s [ i ] ) NEW_LINE break NEW_LINE DEDENT DEDENT","def solve ( s , k ) : NEW_LINE INDENT for i , d in enumerate ( map ( int , list ( s ) ) ) : NEW_LINE INDENT if i == k - 1 : NEW_LINE INDENT return s [ k - 1 ] NEW_LINE DEDENT if d > 1 : NEW_LINE INDENT return d NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT s = input ( ) NEW_LINE k = int ( input ( ) ) NEW_LINE print ( solve ( s , k ) ) NEW_LINE","import sys NEW_LINE import itertools NEW_LINE import collections NEW_LINE import functools NEW_LINE import math NEW_LINE from queue import Queue NEW_LINE INF = float ( \" inf \" ) NEW_LINE def solve ( S : int , K : int ) : NEW_LINE INDENT n = - 1 NEW_LINE nc = 1 NEW_LINE for i , c in enumerate ( str ( S ) ) : NEW_LINE INDENT if c != \"1\" : NEW_LINE INDENT n = i + 1 NEW_LINE nc = c NEW_LINE break NEW_LINE DEDENT DEDENT if n == - 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE return NEW_LINE DEDENT if K < n : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( nc ) NEW_LINE DEDENT return NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT def iterate_tokens ( ) : NEW_LINE INDENT for line in sys . stdin : NEW_LINE INDENT for word in line . split ( ) : NEW_LINE INDENT yield word NEW_LINE DEDENT DEDENT DEDENT tokens = iterate_tokens ( ) NEW_LINE S = int ( next ( tokens ) ) NEW_LINE K = int ( next ( tokens ) ) NEW_LINE solve ( S , K ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT","s = [ int ( i ) for i in input ( ) ] NEW_LINE k = int ( input ( ) ) NEW_LINE count = 0 NEW_LINE while s [ 0 ] == 1 : NEW_LINE INDENT s = s [ 1 : ] NEW_LINE count += 1 NEW_LINE if len ( s ) == 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if k <= count : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s [ 0 ] ) NEW_LINE DEDENT","numbers = input ( ) NEW_LINE position = int ( input ( ) ) NEW_LINE answer = \"1\" NEW_LINE for num in numbers [ : position ] : NEW_LINE INDENT if num != \"1\" : NEW_LINE INDENT answer = num NEW_LINE break NEW_LINE DEDENT DEDENT print ( answer ) NEW_LINE"],"bleu":0.6172839648469004,"rouge_l":0.5190055248618785}
{"id":106,"predictions":["n = int ( input ( ) ) NEW_LINE l = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE d = { } NEW_LINE for i in l : d [ i ] = 0 NEW_LINE l . append ( i ) NEW_LINE for i in d : NEW_LINE INDENT if i not in d : NEW_LINE INDENT d [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ i ] = 0 NEW_LINE DEDENT DEDENT for i in d : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT"],"references":["n = int ( input ( ) ) NEW_LINE a = [ int ( input ( ) ) for i in range ( n ) ] NEW_LINE a = sorted ( set ( a ) , reverse = True ) NEW_LINE if len ( a ) > 1 : NEW_LINE INDENT print ( a [ 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a [ 0 ] ) NEW_LINE DEDENT","_ , * a = map ( int , open ( 0 ) ) ; print ( sorted ( set ( a ) ) [ - 2 ] ) NEW_LINE","n = input ( ) NEW_LINE list = [ ] NEW_LINE for i in range ( int ( n ) ) : NEW_LINE INDENT temp = input ( ) NEW_LINE list . append ( int ( temp ) ) NEW_LINE DEDENT list . sort ( ) NEW_LINE for i in reversed ( range ( len ( list ) ) ) : NEW_LINE INDENT if list [ i ] == list [ i - 1 ] : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT print ( list [ i - 1 ] ) NEW_LINE break NEW_LINE DEDENT DEDENT","n = int ( input ( ) ) NEW_LINE ls = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT tmp = int ( input ( ) ) NEW_LINE if tmp not in ls : NEW_LINE INDENT ls . append ( tmp ) NEW_LINE DEDENT DEDENT ls = sorted ( ls ) NEW_LINE ls . pop ( len ( ls ) - 1 ) NEW_LINE print ( max ( ls ) ) NEW_LINE","import sys NEW_LINE input = sys . stdin . readline NEW_LINE N = int ( input ( ) ) NEW_LINE A = [ int ( input ( ) ) for i in range ( N ) ] NEW_LINE print ( sorted ( list ( set ( A ) ) , reverse = True ) [ 1 ] ) NEW_LINE"],"bleu":0.3802041621473881,"rouge_l":0.5245288936514989}
{"id":107,"predictions":["n = int ( input ( ) ) NEW_LINE power = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT power = power * ( i + 1 ) % 1000000007 NEW_LINE power %= 1000000007 NEW_LINE DEDENT print ( power ) NEW_LINE"],"references":["A , B , C = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( A * B * C ) % 1000000007 ) NEW_LINE","def rectangular ( A : int , B : int , C : int ) -> int : NEW_LINE INDENT MOD = 10 ** 9 + 7 NEW_LINE return ( A * B * C ) % MOD NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A , B , C = map ( int , input ( ) . split ( ) ) NEW_LINE ans = rectangular ( A , B , C ) NEW_LINE print ( ans ) NEW_LINE DEDENT","A , B , C = map ( int , input ( ) . split ( ) ) NEW_LINE d = 10 ** 9 + 7 NEW_LINE A %= d NEW_LINE B %= d NEW_LINE C %= d NEW_LINE print ( A * B * C % d ) NEW_LINE","a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE print ( a * b * c % ( 10 ** 9 + 7 ) ) NEW_LINE","mod = 10 ** 9 + 7 NEW_LINE a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( a * b * c ) % mod ) NEW_LINE"],"bleu":0.1837418890748806,"rouge_l":0.43110686008820864}
{"id":108,"predictions":["N = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if A [ i ] == 1 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += A [ i ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["N , P = map ( int , input ( ) . split ( ) ) NEW_LINE lst_A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE lst_odd_even = [ x % 2 for x in lst_A ] NEW_LINE if 1 in lst_odd_even : NEW_LINE INDENT ans = 2 ** ( N - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT if P == 0 : NEW_LINE INDENT ans = 2 ** N NEW_LINE DEDENT else : NEW_LINE INDENT ans = 0 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE","import sys NEW_LINE INF = float ( ' inf ' ) NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def II ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def SI ( ) : return input ( ) NEW_LINE def main ( ) : NEW_LINE INDENT n , p = LI ( ) NEW_LINE A = LI ( ) NEW_LINE sum_a = sum ( A ) NEW_LINE dp = [ 0 ] * ( sum_a + 1 ) NEW_LINE dp [ 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( sum_a + 1 ) [ : : - 1 ] : NEW_LINE INDENT if j - A [ i ] < 0 : NEW_LINE INDENT break NEW_LINE DEDENT if dp [ j - A [ i ] ] : NEW_LINE INDENT dp [ j ] += dp [ j - A [ i ] ] NEW_LINE DEDENT DEDENT DEDENT return sum ( [ dp [ i ] if i % 2 == p else 0 for i in range ( sum_a + 1 ) ] ) NEW_LINE DEDENT print ( main ( ) ) NEW_LINE","from math import factorial as fact NEW_LINE N , P = map ( int , input ( ) . split ( ) ) NEW_LINE A = [ int ( _ ) for _ in input ( ) . split ( ) ] NEW_LINE oddcnt = 0 NEW_LINE evencnt = 0 NEW_LINE for i in A : NEW_LINE INDENT if i % 2 == 1 : NEW_LINE INDENT oddcnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT evencnt += 1 NEW_LINE DEDENT DEDENT even = 2 ** evencnt NEW_LINE odd = 0 NEW_LINE if P == 0 : NEW_LINE INDENT for i in range ( 0 , oddcnt + 1 , 2 ) : NEW_LINE INDENT odd += fact ( oddcnt ) \/\/ ( fact ( i ) * fact ( oddcnt - i ) ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( 1 , oddcnt + 1 , 2 ) : NEW_LINE INDENT odd += fact ( oddcnt ) \/\/ ( fact ( i ) * fact ( oddcnt - i ) ) NEW_LINE DEDENT DEDENT print ( even * odd ) NEW_LINE","N , P = map ( int , input ( ) . split ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ODD = 0 NEW_LINE EVE = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if A [ i ] % 2 == 1 : NEW_LINE INDENT ODD += 1 NEW_LINE DEDENT else : NEW_LINE INDENT EVE += 1 NEW_LINE DEDENT DEDENT def cmb ( n , r , mod ) : NEW_LINE INDENT if ( r < 0 or r > n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT r = min ( r , n - r ) NEW_LINE return g1 [ n ] * g2 [ r ] * g2 [ n - r ] % mod NEW_LINE DEDENT mod = 10 ** 15 + 7 NEW_LINE N = 10 ** 5 NEW_LINE g1 = [ 1 , 1 ] NEW_LINE g2 = [ 1 , 1 ] NEW_LINE inverse = [ 0 , 1 ] NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT g1 . append ( ( g1 [ - 1 ] * i ) % mod ) NEW_LINE inverse . append ( ( - inverse [ mod % i ] * ( mod \/\/ i ) ) % mod ) NEW_LINE g2 . append ( ( g2 [ - 1 ] * inverse [ - 1 ] ) % mod ) NEW_LINE DEDENT if P == 1 : NEW_LINE INDENT O = 0 NEW_LINE E = 1 NEW_LINE for i in range ( EVE ) : NEW_LINE INDENT E += cmb ( EVE , i , mod ) NEW_LINE E %= ( 10 ** 15 + 7 ) NEW_LINE DEDENT for i in range ( ( ODD + 1 ) \/\/ 2 ) : NEW_LINE INDENT O += cmb ( ODD , 1 + 2 * i , mod ) NEW_LINE DEDENT ans = ( E * O ) % ( 10 ** 15 + 7 ) NEW_LINE print ( ans ) NEW_LINE DEDENT else : NEW_LINE INDENT O = 0 NEW_LINE E = 1 NEW_LINE for i in range ( EVE ) : NEW_LINE INDENT E += cmb ( EVE , i , mod ) NEW_LINE E %= ( 10 ** 15 + 7 ) NEW_LINE DEDENT for i in range ( ( ODD ) \/\/ 2 + 1 ) : NEW_LINE INDENT O += cmb ( ODD , 2 * i , mod ) NEW_LINE DEDENT ans = ( E * O ) % ( 10 ** 15 + 7 ) NEW_LINE print ( ans ) NEW_LINE DEDENT","from math import factorial NEW_LINE def perm ( r , c ) : NEW_LINE INDENT return factorial ( r ) \/\/ factorial ( r - c ) NEW_LINE DEDENT def comb ( r , c ) : NEW_LINE INDENT return perm ( r , c ) \/\/ factorial ( c ) NEW_LINE DEDENT N , P = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = list ( map ( lambda x : x % 2 , a ) ) NEW_LINE a = list ( sorted ( a ) ) NEW_LINE cnt_0 = a . count ( 0 ) NEW_LINE cnt_1 = a . count ( 1 ) NEW_LINE ans = 0 NEW_LINE if P == 0 : NEW_LINE INDENT for j in range ( 0 , cnt_1 + 1 , 2 ) : NEW_LINE INDENT ans += comb ( cnt_1 , j ) * ( 2 ** cnt_0 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for j in range ( 1 , cnt_1 + 1 , 2 ) : NEW_LINE INDENT ans += comb ( cnt_1 , j ) * ( 2 ** cnt_0 ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"bleu":0.6454054384807261,"rouge_l":0.6706462098255412}
{"id":109,"predictions":["import sys , math , itertoolsfrom collections import Counter , deque , defaultdictfrom bisect import bisect_left , bisect_right from heapq import heappop , heappush , heapify , nlargestfrom copy import deepcopymod = 10 ** 9 + 7 INF = float ( ' inf ' ) def inp ( ) : return int ( sys . stdin . readline ( ) ) def inpl ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) def inpl_1 ( ) : return list ( map ( lambda x : int ( x ) - 1 , sys . stdin . readline ( ) . split ( ) ) ) def inps ( ) : return sys . stdin . readline ( ) def inpsl ( x ) : tmp = sys . stdin . readline ( ) ; return list ( tmp [ : x ] ) def err ( x ) : print ( x ) ; exit ( )   n = inp ( ) p = inpl ( ) ; p . sort ( ) res = 0 for i in range ( n ) : NEW_LINE"],"references":["s = input ( ) . split ( ) NEW_LINE t = input ( ) NEW_LINE r = input ( ) . split ( ) NEW_LINE if s == r : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT elif len ( set ( s + [ t ] ) & set ( r ) ) == 6 : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT f = 8 - len ( set ( s ) & set ( r ) ) NEW_LINE if f < 6 : NEW_LINE INDENT print ( f ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT","E = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE B = int ( input ( ) ) NEW_LINE L = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE bonus = 0 NEW_LINE count = 0 NEW_LINE for i in range ( 6 ) : NEW_LINE INDENT if L [ i ] in E : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if L [ i ] == B : NEW_LINE INDENT bonus = 1 NEW_LINE DEDENT DEDENT if count == 6 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT elif count == 5 : NEW_LINE INDENT if bonus == 1 : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 3 ) NEW_LINE DEDENT DEDENT elif count == 4 : NEW_LINE INDENT print ( 4 ) NEW_LINE DEDENT elif count == 3 : NEW_LINE INDENT print ( 5 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT","e , b , l = eval ( ' set ( input ( ) ) , ' * 3 ) ; print ( 2 * ( l - e == b ) or ( ~ - len ( l - e ) % 5 + 3 ) % 6 ) NEW_LINE","from sys import stdin NEW_LINE input = stdin . readline NEW_LINE E = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = int ( input ( ) ) NEW_LINE L = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE cou = 0 NEW_LINE for l in L : NEW_LINE INDENT if l in E : NEW_LINE INDENT cou += 1 NEW_LINE DEDENT DEDENT if cou == 6 : NEW_LINE INDENT ans = 1 NEW_LINE DEDENT elif cou == 5 and b in L : NEW_LINE INDENT ans = 2 NEW_LINE DEDENT elif cou == 5 : NEW_LINE INDENT ans = 3 NEW_LINE DEDENT elif cou == 4 : NEW_LINE INDENT ans = 4 NEW_LINE DEDENT elif cou == 3 : NEW_LINE INDENT ans = 5 NEW_LINE DEDENT else : NEW_LINE INDENT ans = 0 NEW_LINE DEDENT print ( ans ) NEW_LINE","n = input ( ) NEW_LINE b = input ( ) NEW_LINE c = input ( ) NEW_LINE p = 0 NEW_LINE for i in range ( 0 , 12 , 2 ) : NEW_LINE INDENT if c [ i ] in n : NEW_LINE INDENT p += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if p == 6 : NEW_LINE INDENT p += 1 NEW_LINE DEDENT if p == 5 : NEW_LINE INDENT if b in c : NEW_LINE INDENT p += 1 NEW_LINE DEDENT DEDENT DEDENT print ( 8 - p if p > 2 else 0 ) NEW_LINE"],"bleu":0.17732931881769362,"rouge_l":0.32512315270935965}
{"id":110,"predictions":["import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE inf = 10 ** 20 NEW_LINE mod = 10 ** 9 + 7 NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def F ( ) : return float ( sys . stdin . readline ( ) ) NEW_LINE def S ( ) : return input ( ) NEW_LINE def main ( ) : NEW_LINE INDENT a = [ LI ( ) for _ in range ( n ) ] NEW_LINE b = [ LI ( ) for _ in range ( a ) ] NEW_LINE d = [ - 1 ] * n NEW_LINE d [ 0 ] = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT d [ i ] = - 1 NEW_LINE DEDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT d [ j ] += 1 NEW_LINE DEDENT DEDENT print ( main ( ) ) NEW_LINE"],"references":["def LIS ( L ) : NEW_LINE INDENT from bisect import bisect NEW_LINE best = [ ] NEW_LINE for i in L : NEW_LINE INDENT pos = bisect ( best , i ) NEW_LINE if len ( best ) <= pos : NEW_LINE INDENT best . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT best [ pos ] = i NEW_LINE DEDENT DEDENT return len ( best ) NEW_LINE DEDENT import math NEW_LINE x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) NEW_LINE N = int ( input ( ) ) NEW_LINE W = abs ( x2 - x1 ) NEW_LINE H = abs ( y2 - y1 ) NEW_LINE xsgn = 2 * ( x2 > x1 ) - 1 NEW_LINE ysgn = 2 * ( y2 > y1 ) - 1 NEW_LINE XY = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE if ( x - x1 ) * ( x - x2 ) <= 0 and ( y - y1 ) * ( y - y2 ) <= 0 : NEW_LINE INDENT XY += [ [ xsgn * ( x - x1 ) , ysgn * ( y - y1 ) ] ] NEW_LINE DEDENT DEDENT N = len ( XY ) NEW_LINE short = 20 - 5 * math . pi NEW_LINE long = 10 * math . pi - 20 NEW_LINE straight = 100 * ( W + H ) NEW_LINE XY . sort ( ) NEW_LINE Y = [ y for x , y in XY ] NEW_LINE fountain = LIS ( Y ) NEW_LINE if fountain < min ( W , H ) + 1 : NEW_LINE INDENT print ( straight - short * fountain ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( straight - short * ( fountain - 1 ) + long ) NEW_LINE DEDENT","from decimal import Decimal as D NEW_LINE from bisect import bisect_left as bl NEW_LINE def LIS ( L ) : NEW_LINE INDENT best = [ ] NEW_LINE for i in L : NEW_LINE INDENT pos = bl ( best , i ) NEW_LINE if len ( best ) <= pos : NEW_LINE INDENT best . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT best [ pos ] = i NEW_LINE DEDENT DEDENT return len ( best ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT xflip = 1 NEW_LINE yflip = 1 NEW_LINE x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) NEW_LINE if x1 > x2 : NEW_LINE INDENT xflip = - 1 NEW_LINE x1 , x2 = x2 , x1 NEW_LINE DEDENT if y1 > y2 : NEW_LINE INDENT yflip = - 1 NEW_LINE y1 , y2 = y2 , y1 NEW_LINE DEDENT points = [ ] NEW_LINE n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE if x1 <= x <= x2 and y1 <= y <= y2 : NEW_LINE INDENT points . append ( ( x * xflip , y * yflip ) ) NEW_LINE DEDENT DEDENT points = [ y for x , y in sorted ( points ) ] NEW_LINE foun = LIS ( points ) NEW_LINE dist = D ( 100 ) * ( x2 - x1 + y2 - y1 ) NEW_LINE dx = D ( ' - 4.2920367320510338076867835' ) * foun NEW_LINE if foun == min ( x2 - x1 + 1 , y2 - y1 + 1 ) : NEW_LINE INDENT dx += D ( '15.7079632679489661923132165' ) NEW_LINE DEDENT print ( dist + dx ) NEW_LINE DEDENT","import operator NEW_LINE from bisect import bisect_left NEW_LINE from math import pi NEW_LINE import decimal NEW_LINE def lis ( A ) : NEW_LINE INDENT L = [ A [ 0 ] ] NEW_LINE for a in A [ 1 : ] : NEW_LINE INDENT if a > L [ - 1 ] : NEW_LINE INDENT L . append ( a ) NEW_LINE DEDENT else : NEW_LINE INDENT L [ bisect_left ( L , a ) ] = a NEW_LINE DEDENT DEDENT return len ( L ) NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) NEW_LINE if x1 > x2 : NEW_LINE INDENT x1 , y1 , x2 , y2 = x2 , y2 , x1 , y1 NEW_LINE DEDENT is_down = y1 > y2 NEW_LINE if is_down : NEW_LINE INDENT y1 , y2 = - y1 , - y2 NEW_LINE DEDENT base = decimal . Decimal ( 100 ) * ( x2 - x1 + y2 - y1 ) NEW_LINE n = int ( input ( ) ) NEW_LINE fountains = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE if is_down : NEW_LINE INDENT y = - y NEW_LINE DEDENT if x < x1 or x2 < x or y < y1 or y2 < y : NEW_LINE INDENT continue NEW_LINE DEDENT fountains . append ( ( x , y ) ) NEW_LINE DEDENT if not fountains : NEW_LINE INDENT return str ( base ) NEW_LINE DEDENT dpi = decimal . Decimal ( pi ) NEW_LINE fountains . sort ( ) NEW_LINE fountains_y = list ( map ( operator . itemgetter ( 1 ) , fountains ) ) NEW_LINE mc = lis ( fountains_y ) NEW_LINE if mc == min ( x2 - x1 , y2 - y1 ) + 1 : NEW_LINE INDENT dist = base + ( dpi * 5 - 20 ) * ( mc - 1 ) + dpi * 10 - 20 NEW_LINE DEDENT else : NEW_LINE INDENT dist = base + ( dpi * 5 - 20 ) * mc NEW_LINE DEDENT return str ( dist ) NEW_LINE DEDENT print ( solve ( ) ) NEW_LINE","import math NEW_LINE import bisect NEW_LINE def get_lis ( S ) : NEW_LINE INDENT dp = [ float ( ' inf ' ) ] * len ( S ) NEW_LINE for i , ( x , y ) in enumerate ( S ) : NEW_LINE INDENT a = S [ i ] [ 1 ] NEW_LINE j = bisect . bisect_right ( dp , a ) NEW_LINE dp [ j ] = a NEW_LINE DEDENT return bisect . bisect_left ( dp , float ( ' inf ' ) ) NEW_LINE DEDENT x_1 , y_1 , x_2 , y_2 = map ( int , input ( ) . split ( ) ) NEW_LINE N = int ( input ( ) ) NEW_LINE if x_1 <= x_2 : NEW_LINE INDENT x_s = x_1 NEW_LINE y_s = y_1 NEW_LINE x_t = x_2 NEW_LINE y_t = y_2 NEW_LINE DEDENT else : NEW_LINE INDENT x_s = x_2 NEW_LINE y_s = y_2 NEW_LINE x_t = x_1 NEW_LINE y_t = y_1 NEW_LINE DEDENT x_min = min ( x_1 , x_2 ) NEW_LINE x_max = max ( x_1 , x_2 ) NEW_LINE y_min = min ( y_1 , y_2 ) NEW_LINE y_max = max ( y_1 , y_2 ) NEW_LINE S = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT X , Y = map ( int , input ( ) . split ( ) ) NEW_LINE if X < x_min or X > x_max or Y < y_min or Y > y_max : NEW_LINE INDENT continue NEW_LINE DEDENT S . append ( ( X , Y ) ) NEW_LINE DEDENT dist = 0 NEW_LINE s_num = len ( S ) NEW_LINE S . sort ( ) NEW_LINE if y_s > y_t : NEW_LINE INDENT S . reverse ( ) NEW_LINE start_y = y_t NEW_LINE end_y = y_s NEW_LINE DEDENT else : NEW_LINE INDENT start_y = y_s NEW_LINE end_y = y_t NEW_LINE DEDENT round_count = get_lis ( S ) NEW_LINE dist = ( abs ( x_t - x_s ) + abs ( y_t - y_s ) ) * 100 + ( math . pi * 20 \/ 4 - 20 ) * round_count NEW_LINE if min ( abs ( x_t - x_s ) , abs ( y_t - y_s ) ) + 1 == round_count : NEW_LINE INDENT dist += math . pi * 5 NEW_LINE DEDENT print ( dist ) NEW_LINE","from bisect import bisect_left , insort NEW_LINE from math import pi NEW_LINE def inpl ( ) : return tuple ( map ( int , input ( ) . split ( ) ) ) NEW_LINE sx , sy , gx , gy = inpl ( ) NEW_LINE yrev = False NEW_LINE if sx > gx : NEW_LINE INDENT sx , sy , gx , gy = gx , gy , sx , sy NEW_LINE DEDENT if sy > gy : NEW_LINE INDENT sy , gy = 10 ** 8 - 1 - sy , 10 ** 8 - 1 - gy NEW_LINE yrev = True NEW_LINE DEDENT N = int ( input ( ) ) NEW_LINE fountains = [ ] NEW_LINE for _ in range ( N ) : NEW_LINE INDENT x , y = inpl ( ) NEW_LINE if yrev : NEW_LINE INDENT y = 10 ** 8 - 1 - y NEW_LINE DEDENT if ( sx <= x <= gx ) & ( sy <= y <= gy ) : NEW_LINE INDENT fountains . append ( [ x , y ] ) NEW_LINE DEDENT DEDENT fountains . sort ( ) NEW_LINE L = [ ] NEW_LINE if len ( fountains ) : NEW_LINE INDENT L . append ( fountains [ 0 ] [ 1 ] ) NEW_LINE DEDENT for f in fountains : NEW_LINE INDENT x , y = f NEW_LINE if L [ - 1 ] < y : NEW_LINE INDENT L . append ( y ) NEW_LINE DEDENT else : NEW_LINE INDENT L [ bisect_left ( L , y ) ] = y NEW_LINE DEDENT DEDENT if min ( gx - sx , gy - sy ) + 1 == len ( L ) : NEW_LINE INDENT print ( ( ( gx - sx ) + ( gy - sy ) ) * 100 - ( 20 - 5 * pi ) * ( len ( L ) - 1 ) + ( 10 * pi - 20 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( ( gx - sx ) + ( gy - sy ) ) * 100 - ( 20 - 5 * pi ) * len ( L ) ) NEW_LINE DEDENT"],"bleu":0.23570904551945437,"rouge_l":0.30863219254502816}
{"id":111,"predictions":["x , y = map ( int , input ( ) . split ( ) ) NEW_LINE if y < 0 : NEW_LINE INDENT print ( \" - 1 ▁ - 1\" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" { } ▁ { } \" . format ( x , y ) ) NEW_LINE DEDENT"],"references":["def find ( n , y ) : NEW_LINE INDENT for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( n + 1 - i ) : NEW_LINE INDENT if 10000 * i + 5000 * j + 1000 * ( n - i - j ) == y : NEW_LINE INDENT return i , j , n - i - j NEW_LINE DEDENT DEDENT DEDENT return - 1 , - 1 , - 1 NEW_LINE DEDENT N , Y = map ( int , input ( ) . split ( ) ) NEW_LINE i , j , k = find ( N , Y ) NEW_LINE print ( \" { } ▁ { } ▁ { } \" . format ( i , j , k ) ) NEW_LINE","n , y = [ int ( i ) for i in input ( ) . split ( \" ▁ \" ) ] NEW_LINE a = 0 NEW_LINE f = False NEW_LINE while y - 1000 * n - 9000 * a >= 0 : NEW_LINE INDENT r = ( y - 1000 * n - 9000 * a ) NEW_LINE b = r \/\/ 4000 NEW_LINE if r % 4000 == 0 and n - a - b >= 0 : NEW_LINE INDENT print ( a , b , n - a - b ) NEW_LINE f = True NEW_LINE break NEW_LINE DEDENT a += 1 NEW_LINE DEDENT if not f : NEW_LINE INDENT print ( - 1 , - 1 , - 1 ) NEW_LINE DEDENT","N , Y = map ( int , input ( ) . split ( ) ) NEW_LINE flag = 0 NEW_LINE for x in range ( N + 1 ) : NEW_LINE INDENT for y in range ( N + 1 ) : NEW_LINE INDENT if x + y > N : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT z = N - ( x + y ) NEW_LINE if 10000 * x + 5000 * y + 1000 * z == Y : NEW_LINE INDENT flag = 1 NEW_LINE X , Y , Z = x , y , z NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if flag == 1 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if flag == 0 : NEW_LINE INDENT print ( - 1 , - 1 , - 1 , ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( X , Y , Z ) NEW_LINE DEDENT","NY = input ( ) . split ( ) NEW_LINE N_Y = [ int ( s ) for s in NY ] NEW_LINE counter_Y = 0 NEW_LINE counter = 0 NEW_LINE listx = [ ] NEW_LINE for i in range ( N_Y [ 0 ] + 1 ) : NEW_LINE INDENT for j in range ( N_Y [ 0 ] + 1 ) : NEW_LINE INDENT k = N_Y [ 0 ] - i - j NEW_LINE counter_Y = 10000 * i + 5000 * j + 1000 * k NEW_LINE if counter_Y == N_Y [ 1 ] and k >= 0 : NEW_LINE INDENT listx = [ i , j , k ] NEW_LINE counter += 1 NEW_LINE DEDENT DEDENT DEDENT if counter == 0 : NEW_LINE INDENT print ( \" - 1 ▁ - 1 ▁ - 1\" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" { } ▁ { } ▁ { } \" . format ( listx [ 0 ] , listx [ 1 ] , listx [ 2 ] ) ) NEW_LINE DEDENT","n , y = map ( int , input ( ) . split ( ) ) NEW_LINE ans_i = - 1 NEW_LINE ans_j = - 1 NEW_LINE ans_k = - 1 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( n - i + 1 ) : NEW_LINE INDENT k = n - i - j NEW_LINE if 10000 * i + 5000 * j + 1000 * k == y : NEW_LINE INDENT ans_i = i NEW_LINE ans_j = j NEW_LINE ans_k = k NEW_LINE DEDENT DEDENT DEDENT print ( str ( ans_i ) + \" ▁ \" + str ( ans_j ) + \" ▁ \" + str ( ans_k ) ) NEW_LINE"],"bleu":0.28122842113438323,"rouge_l":0.3939269029953284}
{"id":112,"predictions":["a , b = map ( str , input ( ) . split ( ) ) NEW_LINE c = a + b NEW_LINE d = int ( c ) * 2 NEW_LINE print ( d ) NEW_LINE"],"references":["A , B , C = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE print ( A * B * 2 + B * C * 2 + A * C * 2 ) NEW_LINE","def takahashi_rect ( A : int , B : int , C : int ) -> int : NEW_LINE INDENT return 2 * ( A * B + B * C + C * A ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A , B , C = map ( int , input ( ) . split ( ) ) NEW_LINE ans = takahashi_rect ( A , B , C ) NEW_LINE print ( ans ) NEW_LINE DEDENT","A = list ( map ( int , input ( ) . split ( ) ) ) ; s = 0 NEW_LINE for i in range ( len ( A ) ) : NEW_LINE INDENT s += A [ i - 1 ] * A [ i ] NEW_LINE DEDENT print ( s * 2 ) NEW_LINE","a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE d = a * b + b * c + c * a NEW_LINE d *= 2 NEW_LINE print ( d ) NEW_LINE","a , b , c = [ int ( i ) for i in input ( ) . split ( ' ▁ ' ) ] NEW_LINE print ( 2 * ( a * b + b * c + c * a ) ) NEW_LINE"],"bleu":0.5052969748013358,"rouge_l":0.7258924907673369}
{"id":113,"predictions":["def main ( ) : NEW_LINE INDENT s = input ( ) NEW_LINE n = len ( s ) NEW_LINE chs = changes ( s , n ) NEW_LINE res = n NEW_LINE for c in chs : NEW_LINE INDENT di = max ( c , n - c ) NEW_LINE res = min ( res , di ) NEW_LINE DEDENT print ( res ) NEW_LINE DEDENT def changes ( s , n ) : NEW_LINE INDENT res = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if s [ i - 1 ] == s [ i ] : NEW_LINE INDENT res . append ( s [ i ] , cnt ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT main ( ) NEW_LINE"],"references":["N = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE t = input ( ) NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT if s [ i : ] == t [ : N - i ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( len ( s + t [ N - i : ] ) ) NEW_LINE","I = input ; n = i = int ( I ( ) ) ; s , t = I ( ) , I ( ) ; j = 0 ; exec ( ' j = max ( i * ( s [ - i : ] = = t [ : i ] ) , j ) ; i - = 1 ; ' * n ) ; print ( 2 * n - j ) NEW_LINE","N = int ( input ( ) ) NEW_LINE s = str ( input ( ) ) NEW_LINE t = str ( input ( ) ) NEW_LINE m = 0 NEW_LINE for i in range ( N , 0 , - 1 ) : NEW_LINE INDENT unity = True NEW_LINE for j in range ( i ) : NEW_LINE INDENT if s [ - ( j + 1 ) ] == t [ i - j - 1 ] : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT unity = False NEW_LINE DEDENT DEDENT if unity : NEW_LINE INDENT m = i NEW_LINE break NEW_LINE DEDENT DEDENT print ( str ( 2 * N - m ) ) NEW_LINE","N = input ( ) NEW_LINE N = int ( N ) NEW_LINE s = input ( ) NEW_LINE t = input ( ) NEW_LINE y = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT q = s [ - ( i + 1 ) : ] NEW_LINE r = t [ : i + 1 ] NEW_LINE if q == r : NEW_LINE INDENT x = q NEW_LINE y = i + 1 NEW_LINE DEDENT DEDENT print ( N * 2 - y ) NEW_LINE","I = input ; n = int ( I ( ) ) ; s , t = I ( ) , I ( ) ; print ( 2 * n - max ( i * ( s [ - i : ] == t [ : i ] ) for i in range ( n + 1 ) ) ) NEW_LINE"],"bleu":0.32186296030357237,"rouge_l":0.5343489645322542}
{"id":114,"predictions":["import math NEW_LINE def solve ( ) : NEW_LINE INDENT n , a , b , c , d = ( int ( i ) for i in input ( ) . split ( ) ) NEW_LINE if c * d >= a : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT else : NEW_LINE INDENT d = ( ' YES ' ) NEW_LINE DEDENT if a > d : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT return NEW_LINE DEDENT solve ( ) NEW_LINE"],"references":["import math NEW_LINE A , B = map ( int , input ( ) . split ( ) ) NEW_LINE N = int ( input ( ) ) NEW_LINE C = [ 0 ] * N NEW_LINE D = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT C [ i ] , D [ i ] = map ( int , input ( ) . split ( ) ) NEW_LINE DEDENT res = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT curr = False NEW_LINE if A <= C [ i ] and B <= D [ i ] : NEW_LINE INDENT curr = True NEW_LINE DEDENT if B <= C [ i ] and A <= D [ i ] : NEW_LINE INDENT curr = True NEW_LINE DEDENT if curr == False : NEW_LINE INDENT for j in range ( 2 ) : NEW_LINE INDENT if j == 1 : NEW_LINE INDENT temp = A NEW_LINE A = B NEW_LINE B = temp NEW_LINE DEDENT lo = math . atan ( B \/ A ) NEW_LINE hi = math . pi \/ 2 NEW_LINE mid = 0 NEW_LINE cnt = 0 NEW_LINE while lo < hi and cnt < 50 : NEW_LINE INDENT mid = ( lo + hi ) \/ 2 NEW_LINE if A * math . sin ( mid ) + B * math . cos ( mid ) < max ( C [ i ] , D [ i ] ) : NEW_LINE INDENT lo = mid NEW_LINE DEDENT else : NEW_LINE INDENT hi = mid NEW_LINE DEDENT cnt += 1 NEW_LINE DEDENT if A * math . cos ( lo ) + B * math . sin ( lo ) <= min ( C [ i ] , D [ i ] ) : NEW_LINE INDENT curr |= True NEW_LINE DEDENT DEDENT DEDENT if curr == True : NEW_LINE INDENT res . append ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT res . append ( \" NO \" ) NEW_LINE DEDENT DEDENT print ( \" \\n \" . join ( map ( str , res ) ) ) NEW_LINE","from collections import defaultdict NEW_LINE import sys , heapq , bisect , math , itertools , string , queue , datetime NEW_LINE sys . setrecursionlimit ( 10 ** 8 ) NEW_LINE INF = float ( ' inf ' ) NEW_LINE mod = 10 ** 9 + 7 NEW_LINE eps = 10 ** - 7 NEW_LINE PI = math . pi NEW_LINE AtoZ = [ chr ( i ) for i in range ( 65 , 65 + 26 ) ] NEW_LINE atoz = [ chr ( i ) for i in range ( 97 , 97 + 26 ) ] NEW_LINE def inpl ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def inpl_s ( ) : return list ( input ( ) . split ( ) ) NEW_LINE A , B = inpl ( ) NEW_LINE A , B = min ( A , B ) , max ( A , B ) NEW_LINE N = int ( input ( ) ) NEW_LINE phi = math . atan ( A \/ B ) NEW_LINE r = math . sqrt ( A ** 2 + B ** 2 ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT C , D = inpl ( ) NEW_LINE C , D = min ( C , D ) , max ( C , D ) NEW_LINE if A <= C and B <= D : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT elif C < A and B < D : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT else : NEW_LINE INDENT OK = 0 NEW_LINE NG = PI - phi NEW_LINE for _ in range ( 100 ) : NEW_LINE INDENT mid = ( OK + NG ) \/ 2 NEW_LINE h = r * math . sin ( mid + phi ) NEW_LINE if h <= D : OK = mid NEW_LINE else : NG = mid NEW_LINE DEDENT w = r * math . cos ( OK - phi ) NEW_LINE if w <= C : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT DEDENT","import sys NEW_LINE from math import sin , cos , radians NEW_LINE H , W = sorted ( map ( int , input ( ) . split ( ) ) ) NEW_LINE input ( ) NEW_LINE for ( box_h , box_w ) in ( sorted ( map ( int , l . split ( ) ) ) for l in sys . stdin ) : NEW_LINE INDENT if H <= box_h and W <= box_w : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE continue NEW_LINE DEDENT ok , ng = 0.0 , radians ( 90 ) NEW_LINE while ng - ok > 1e-12 : NEW_LINE INDENT mid = ( ok + ng ) \/ 2 NEW_LINE if W * sin ( mid ) + H * cos ( mid ) <= box_h : NEW_LINE INDENT ok = mid NEW_LINE DEDENT else : NEW_LINE INDENT ng = mid NEW_LINE DEDENT DEDENT _w = W * cos ( ok ) + H * cos ( radians ( 90 ) - ok ) NEW_LINE _h = W * sin ( ok ) + H * cos ( ok ) NEW_LINE if _w <= box_w and _h <= box_h : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT","from math import cos , sin , atan2 NEW_LINE A , B = map ( int , input ( ) . split ( ) ) NEW_LINE if A > B : NEW_LINE INDENT A , B = B , A NEW_LINE DEDENT N = int ( input ( ) ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT C , D = map ( int , input ( ) . split ( ) ) NEW_LINE if C > D : NEW_LINE INDENT C , D = D , C NEW_LINE DEDENT if A <= C and B <= D : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT elif A >= C and B >= D : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT else : NEW_LINE INDENT ok = 0 NEW_LINE ng = atan2 ( B , A ) + 1e-2 NEW_LINE for _ in range ( 30 ) : NEW_LINE INDENT m = ( ok + ng ) \/ 2 NEW_LINE w = B * cos ( m ) + A * sin ( m ) NEW_LINE h = B * sin ( m ) + A * cos ( m ) NEW_LINE if abs ( h - D ) < 1e-3 : NEW_LINE INDENT break NEW_LINE DEDENT if h < D : NEW_LINE INDENT ok = m NEW_LINE DEDENT else : NEW_LINE INDENT ng = m NEW_LINE DEDENT DEDENT print ( [ ' NO ' , ' YES ' ] [ w <= C ] ) NEW_LINE DEDENT DEDENT","from math import sqrt , atan , sin , cos NEW_LINE a , b = ( int ( i ) for i in input ( ) . split ( ) ) NEW_LINE n = int ( input ( ) ) NEW_LINE a , b = min ( a , b ) , max ( a , b ) NEW_LINE ab , th = sqrt ( a ** 2 + b ** 2 ) , atan ( a \/ b ) NEW_LINE for _ in range ( n ) : NEW_LINE INDENT c , d = ( int ( i ) for i in input ( ) . split ( ) ) NEW_LINE c , d = min ( c , d ) , max ( c , d ) NEW_LINE if a <= c and b <= d : ans = \" YES \" NEW_LINE else : NEW_LINE INDENT hi , lo = atan ( b \/ a ) , 0 NEW_LINE for i in range ( 100 ) : NEW_LINE INDENT mid = ( hi + lo ) \/ 2 NEW_LINE if ab * sin ( mid + th ) <= d : lo = mid NEW_LINE else : hi = mid NEW_LINE DEDENT if ab * cos ( lo - th ) <= c : ans = \" YES \" NEW_LINE else : ans = \" NO \" NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT"],"bleu":0.15965994612585854,"rouge_l":0.3402586001938587}
{"id":115,"predictions":["N = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE A . sort ( ) NEW_LINE c = 0 NEW_LINE idx = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT c += 1 NEW_LINE DEDENT else : NEW_LINE INDENT idx = A [ i ] NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ 0 ] * n NEW_LINE for i in range ( m ) : NEW_LINE INDENT b , c = map ( int , input ( ) . split ( ) ) NEW_LINE a [ b - 1 ] += 1 NEW_LINE a [ c - 1 ] += 1 NEW_LINE DEDENT for i in a : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT","I = lambda : map ( int , input ( ) . split ( ) ) NEW_LINE N , M = I ( ) NEW_LINE r = range ( N ) NEW_LINE m = { i : 0 for i in r } NEW_LINE for _ in [ 0 ] * M : NEW_LINE INDENT a , b = I ( ) NEW_LINE m [ a - 1 ] += 1 NEW_LINE m [ b - 1 ] += 1 NEW_LINE DEDENT for i in r : print ( m [ i ] ) NEW_LINE","from collections import OrderedDict NEW_LINE N , M = map ( int , input ( ) . split ( ) ) NEW_LINE L = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] NEW_LINE X = OrderedDict ( [ ( i + 1 , [ ] ) for i in range ( N ) ] ) NEW_LINE for a , b in L : NEW_LINE INDENT X [ a ] . append ( b ) NEW_LINE X [ b ] . append ( a ) NEW_LINE DEDENT for _ , x in X . items ( ) : NEW_LINE INDENT print ( len ( x ) ) NEW_LINE DEDENT","import sys NEW_LINE ns = lambda : sys . stdin . readline ( ) . rstrip ( ) NEW_LINE ni = lambda : int ( ns ( ) ) NEW_LINE nm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE nl = lambda : list ( nm ( ) ) NEW_LINE n , m = nm ( ) NEW_LINE ab = [ nl ( ) for i in range ( m ) ] NEW_LINE ans = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT ans [ ab [ i ] [ 0 ] - 1 ] += 1 NEW_LINE ans [ ab [ i ] [ 1 ] - 1 ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( ans [ i ] ) NEW_LINE DEDENT","from functools import reduce NEW_LINE import math NEW_LINE def main ( ) : NEW_LINE INDENT N , M = ( int ( _ ) for _ in input ( ) . split ( ) ) NEW_LINE a = [ ] NEW_LINE b = [ ] NEW_LINE ans = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( M ) : NEW_LINE INDENT s1 , s2 = ( int ( _ ) for _ in input ( ) . split ( ) ) NEW_LINE a . append ( s1 ) NEW_LINE b . append ( s2 ) NEW_LINE DEDENT for i in range ( M ) : NEW_LINE INDENT ans [ a [ i ] ] += 1 NEW_LINE ans [ b [ i ] ] += 1 NEW_LINE DEDENT print ( ' \\n ' . join ( str ( _ ) for _ in ans [ 1 : ] ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"bleu":0.4728003691560296,"rouge_l":0.522755258149977}
{"id":116,"predictions":["import sys NEW_LINE stdin = sys . stdin NEW_LINE sys . setrecursionlimit ( 10 ** 5 ) NEW_LINE def li ( ) : return map ( int , stdin . readline ( ) . split ( ) ) NEW_LINE def li_ ( ) : return map ( lambda x : int ( x ) - 1 , stdin . readline ( ) . split ( ) ) NEW_LINE def lf ( ) : return map ( float , stdin . readline ( ) . split ( ) ) NEW_LINE def ls ( ) : return stdin . readline ( ) . split ( ) NEW_LINE def ns ( ) : return stdin . readline ( ) . rstrip ( ) NEW_LINE def lc ( ) : return list ( ns ( ) ) NEW_LINE def ni ( ) : return int ( stdin . readline ( ) ) NEW_LINE def nf ( ) : return float ( stdin . readline ( ) ) NEW_LINE from collections import Counter NEW_LINE n = ni ( ) NEW_LINE a = list ( li ( ) ) NEW_LINE cnt = Counter ( a ) NEW_LINE ans = 0 NEW_LINE for k , v in a : NEW_LINE INDENT if v == 0 : NEW_LINE INDENT ans += v * ( v - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( v * ( v - 1 ) ) * a NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["A = int ( input ( ) ) NEW_LINE C = int ( input ( ) ) NEW_LINE B = int ( input ( ) ) NEW_LINE mod = 10 ** 9 + 7 NEW_LINE def power ( x , y ) : NEW_LINE INDENT if y == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif y == 1 : NEW_LINE INDENT return x % mod NEW_LINE DEDENT elif y % 2 == 0 : NEW_LINE INDENT return power ( x , y \/\/ 2 ) ** 2 % mod NEW_LINE DEDENT else : NEW_LINE INDENT return ( power ( x , y \/\/ 2 ) ** 2 ) * x % mod NEW_LINE DEDENT DEDENT inv = power ( A * B + A * C - B * C , mod - 2 ) NEW_LINE i = ( ( ( 2 * B * C - A * B - A * C ) % mod ) * inv ) % mod NEW_LINE j = A * B * inv - 1 NEW_LINE print ( ( i - j ) % mod , j % mod ) NEW_LINE","def mod_inv ( n : int , mod : int ) -> int : NEW_LINE INDENT b , u , v = mod , 1 , 0 NEW_LINE while b > 0 : NEW_LINE INDENT t = n \/\/ b NEW_LINE n -= t * b NEW_LINE u -= t * v NEW_LINE n , b = b , n NEW_LINE u , v = v , u NEW_LINE DEDENT return ( u + mod ) % mod NEW_LINE DEDENT def dp ( A : int , B : int , C : int ) -> tuple : NEW_LINE INDENT MOD = 10 ** 9 + 7 NEW_LINE r = ( ( B * C - A * C ) % MOD * mod_inv ( A * C - ( B * C - A * B ) , MOD ) ) % MOD NEW_LINE c = ( ( B * C - A * B ) % MOD * mod_inv ( A * C - ( B * C - A * B ) , MOD ) ) % MOD NEW_LINE return r , c NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A , B , C = [ int ( input ( ) ) for _ in range ( 3 ) ] NEW_LINE r , c = dp ( A , B , C ) NEW_LINE print ( r , c ) NEW_LINE DEDENT","mod = 10 ** 9 + 7 NEW_LINE A = int ( input ( ) ) NEW_LINE B = int ( input ( ) ) NEW_LINE C = int ( input ( ) ) NEW_LINE def INV ( i ) : NEW_LINE INDENT return pow ( i , mod - 2 , mod ) NEW_LINE DEDENT print ( ( ( C * B - C * A ) * INV ( A * B - C * B + C * A ) ) % mod , ( ( B * C - B * A ) * INV ( A * C - B * C + B * A ) ) % mod ) NEW_LINE","MOD = 10 ** 9 + 7 NEW_LINE def solve ( A , B , C ) : NEW_LINE INDENT r = B * C % MOD - A * C % MOD NEW_LINE r = r * pow ( A * B % MOD + A * C % MOD - B * C % MOD , MOD - 2 , MOD ) % MOD NEW_LINE c = C * B % MOD - A * B % MOD NEW_LINE c = c * pow ( A * C % MOD + A * B % MOD - B * C % MOD , MOD - 2 , MOD ) % MOD NEW_LINE return r , c NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT A = int ( input ( ) ) NEW_LINE B = int ( input ( ) ) NEW_LINE C = int ( input ( ) ) NEW_LINE r , c = solve ( A , B , C ) NEW_LINE print ( r , c ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT","A , B , C = [ int ( input ( ) ) for i in range ( 3 ) ] NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE def mul ( a , b ) : NEW_LINE INDENT return ( a * b ) % MOD NEW_LINE DEDENT def pow ( a , n ) : NEW_LINE INDENT ret = 1 NEW_LINE mag = a NEW_LINE while n > 0 : NEW_LINE INDENT if n & 1 : NEW_LINE INDENT ret = mul ( ret , mag ) NEW_LINE DEDENT mag = mul ( mag , mag ) NEW_LINE n >>= 1 NEW_LINE DEDENT return ret NEW_LINE DEDENT def inv ( a ) : NEW_LINE INDENT return pow ( a , MOD - 2 ) NEW_LINE DEDENT xn = mul ( B , C ) - mul ( A , C ) NEW_LINE xd = mul ( A , B ) - mul ( B , C ) + mul ( A , C ) NEW_LINE x = mul ( xn , inv ( xd ) ) NEW_LINE yn = mul ( B , C ) - mul ( A , B ) NEW_LINE yd = mul ( A , C ) - mul ( B , C ) + mul ( A , B ) NEW_LINE y = mul ( yn , inv ( yd ) ) NEW_LINE print ( x , y ) NEW_LINE"],"bleu":0.15209555767970626,"rouge_l":0.3600835472753528}
{"id":117,"predictions":["import sys , os , ioimport NEW_LINE math , bisect , operatorinf , mod = float ( ' inf ' ) , 10 ** 9 + 7 NEW_LINE"],"references":["from fractions import gcd NEW_LINE from functools import reduce NEW_LINE N = int ( input ( ) ) NEW_LINE T = map ( int , [ input ( ) for _ in range ( N ) ] ) NEW_LINE def lcm_base ( x , y ) : NEW_LINE INDENT return ( x * y ) \/\/ gcd ( x , y ) NEW_LINE DEDENT def lcm ( numbers ) : NEW_LINE INDENT return reduce ( lcm_base , numbers , 1 ) NEW_LINE DEDENT print ( lcm ( T ) ) NEW_LINE","def gcd ( a , b ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT def lcm ( a , b ) : NEW_LINE INDENT return a * b \/\/ gcd ( a , b ) NEW_LINE DEDENT import sys NEW_LINE input = sys . stdin . readline NEW_LINE N = int ( input ( ) ) NEW_LINE if N == 1 : NEW_LINE INDENT print ( input ( ) ) NEW_LINE DEDENT else : NEW_LINE INDENT T = [ int ( input ( ) ) for _ in range ( N ) ] NEW_LINE ans = lcm ( T [ 0 ] , T [ 1 ] ) NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT ans = lcm ( ans , T [ i ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT","import fractions NEW_LINE def lcm ( a , b ) : NEW_LINE INDENT return a * b \/\/ fractions . gcd ( a , b ) NEW_LINE DEDENT def list_lcm ( number_list ) : NEW_LINE INDENT lcm_number = 1 NEW_LINE for j in range ( len ( number_list ) ) : NEW_LINE INDENT lcm_number = lcm ( lcm_number , number_list [ j ] ) NEW_LINE DEDENT return lcm_number NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT number_count = int ( input ( ) ) NEW_LINE numbers = [ ] NEW_LINE for i in range ( number_count ) : NEW_LINE INDENT numbers . append ( int ( input ( ) ) ) NEW_LINE DEDENT print ( int ( list_lcm ( numbers ) ) ) NEW_LINE DEDENT","n = int ( input ( ) ) NEW_LINE t = [ int ( input ( ) ) for _ in range ( n ) ] NEW_LINE def f ( a , b ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return f ( b , a % b ) NEW_LINE DEDENT DEDENT t = sorted ( t ) [ : : - 1 ] NEW_LINE l = t [ 0 ] NEW_LINE for i in range ( 1 , len ( t ) ) : NEW_LINE INDENT gcd = f ( l , t [ i ] ) NEW_LINE l = l * t [ i ] \/\/ gcd NEW_LINE DEDENT print ( l ) NEW_LINE","from functools import reduce NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT while b : NEW_LINE INDENT a , b = b , a % b NEW_LINE DEDENT return a NEW_LINE DEDENT def lcm ( x , y ) : NEW_LINE INDENT return x * y \/\/ gcd ( x , y ) NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE nums = [ int ( input ( ) ) for _ in range ( n ) ] NEW_LINE print ( reduce ( lcm , nums ) ) NEW_LINE"],"bleu":0.009123293047069667,"rouge_l":0.1628640776699029}
{"id":118,"predictions":["N = int ( input ( ) ) NEW_LINE def factorical ( n ) : NEW_LINE INDENT ret = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ret += i NEW_LINE DEDENT return ret NEW_LINE DEDENT print ( factorical ( N ) ) NEW_LINE"],"references":["k = int ( input ( ) ) NEW_LINE if k % 2 == 0 : NEW_LINE INDENT even = k \/\/ 2 NEW_LINE odd = k \/\/ 2 NEW_LINE DEDENT else : NEW_LINE INDENT even = k \/\/ 2 NEW_LINE odd = k \/\/ 2 + 1 NEW_LINE DEDENT print ( even * odd ) NEW_LINE","import numpy as np NEW_LINE import itertools NEW_LINE a = int ( input ( ) ) NEW_LINE odd_list = np . arange ( 1 , a + 1 , 2 ) NEW_LINE even_list = np . arange ( 2 , a + 1 , 2 ) NEW_LINE count = 0 NEW_LINE for odd , even in itertools . product ( odd_list , even_list ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT print ( count ) NEW_LINE","import sys NEW_LINE K = int ( input ( ) ) NEW_LINE kumi = list ( range ( 0 , K + 1 ) ) NEW_LINE l_even = [ i for i in kumi if i % 2 == 0 and i != 0 ] NEW_LINE l_kisu = [ i for i in kumi if i % 2 != 0 ] NEW_LINE answer = len ( l_even ) * len ( l_kisu ) NEW_LINE print ( answer ) NEW_LINE","def main ( ) : NEW_LINE INDENT K = int ( input ( ) ) NEW_LINE odd = ( K \/\/ 2 ) + 1 if K % 2 == 1 else ( K \/\/ 2 ) NEW_LINE even = K \/\/ 2 NEW_LINE print ( odd * even ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT","K = int ( input ( ) ) NEW_LINE print ( ( K \/\/ 2 ) ** 2 if K % 2 == 0 else ( K \/\/ 2 ) * ( ( K \/\/ 2 ) + 1 ) ) NEW_LINE"],"bleu":0.4076322397743975,"rouge_l":0.4808558558558559}
{"id":119,"predictions":["a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE if ( a == b ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["c = [ [ 0 , 0 , 0 ] , [ 0 , 0 , 0 ] , [ 0 , 0 , 0 ] ] NEW_LINE for i in range ( 0 , 3 ) : NEW_LINE INDENT c [ i ] = [ int ( j ) for j in input ( ) . split ( \" ▁ \" ) ] NEW_LINE DEDENT f = True NEW_LINE for i in range ( 0 , 2 ) : NEW_LINE INDENT f = f and c [ i ] [ 0 ] - c [ i ] [ 1 ] == c [ i + 1 ] [ 0 ] - c [ i + 1 ] [ 1 ] NEW_LINE f = f and c [ i ] [ 1 ] - c [ i ] [ 2 ] == c [ i + 1 ] [ 1 ] - c [ i + 1 ] [ 2 ] NEW_LINE DEDENT for i in range ( 0 , 2 ) : NEW_LINE INDENT f = f and c [ 0 ] [ i ] - c [ 1 ] [ i ] == c [ 0 ] [ i + 1 ] - c [ 1 ] [ i + 1 ] NEW_LINE f = f and c [ 1 ] [ i ] - c [ 2 ] [ i ] == c [ 1 ] [ i + 1 ] - c [ 2 ] [ i + 1 ] NEW_LINE DEDENT if f : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT","def main ( ) : NEW_LINE INDENT C1n = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE C2n = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE C3n = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE C = [ C1n , C2n , C3n ] NEW_LINE a_s = [ 0 ] NEW_LINE b_s = [ C [ 0 ] [ 0 ] , C [ 0 ] [ 1 ] , C [ 0 ] [ 2 ] ] NEW_LINE a_s . append ( C [ 1 ] [ 0 ] - b_s [ 0 ] ) NEW_LINE a_s . append ( C [ 2 ] [ 0 ] - b_s [ 0 ] ) NEW_LINE for i , a_i in enumerate ( a_s ) : NEW_LINE INDENT for j , b_j in enumerate ( b_s ) : NEW_LINE INDENT if not ( ( a_i + b_j ) == C [ i ] [ j ] ) : NEW_LINE INDENT print ( \" No \" ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( \" Yes \" ) NEW_LINE DEDENT main ( ) NEW_LINE","matrix = [ [ x for x in map ( int , input ( ) . split ( ) ) ] for _ in range ( 3 ) ] NEW_LINE matrix = sorted ( matrix ) NEW_LINE for i in range ( 1 , 3 ) : NEW_LINE INDENT diff = matrix [ i ] [ 0 ] - matrix [ 0 ] [ 0 ] NEW_LINE for j in range ( 3 ) : NEW_LINE INDENT if matrix [ i ] [ j ] != matrix [ 0 ] [ j ] + diff : NEW_LINE INDENT print ( ' No ' ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT DEDENT print ( ' Yes ' ) NEW_LINE","C = [ ] NEW_LINE max_c = 0 NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT c = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE C . append ( c ) NEW_LINE max_c = max ( max ( c ) , max_c ) NEW_LINE DEDENT judge = 0 NEW_LINE for i in range ( max_c + 1 ) : NEW_LINE INDENT a1 = i NEW_LINE b1 , b2 , b3 = C [ 0 ] [ 0 ] - a1 , C [ 0 ] [ 1 ] - a1 , C [ 0 ] [ 2 ] - a1 NEW_LINE if ( ( ( C [ 1 ] [ 0 ] - b1 ) == ( C [ 1 ] [ 1 ] - b2 ) ) and ( ( C [ 1 ] [ 0 ] - b1 ) == ( C [ 1 ] [ 2 ] - b3 ) ) ) : NEW_LINE INDENT if ( ( ( C [ 2 ] [ 0 ] - b1 ) == ( C [ 2 ] [ 1 ] - b2 ) ) and ( ( C [ 2 ] [ 0 ] - b1 ) == ( C [ 2 ] [ 2 ] - b3 ) ) ) : NEW_LINE INDENT judge = 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if ( judge == 0 ) : print ( ' No ' ) NEW_LINE else : print ( ' Yes ' ) NEW_LINE","C_1 = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( 3 ) ] NEW_LINE C_2 = [ [ C_1 [ 0 ] [ i ] , C_1 [ 1 ] [ i ] , C_1 [ 2 ] [ i ] ] for i in range ( 3 ) ] NEW_LINE res = None NEW_LINE for C in C_1 , C_2 : NEW_LINE INDENT for i in range ( 3 ) : NEW_LINE INDENT diff = [ C_1 [ i ] [ j ] - C_1 [ ( i + 1 ) % 3 ] [ j ] for j in range ( 3 ) ] NEW_LINE for d in diff : NEW_LINE INDENT if not d == diff [ 0 ] : NEW_LINE INDENT res = ' No ' NEW_LINE break NEW_LINE DEDENT DEDENT if res : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if res : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if not res : NEW_LINE INDENT res = ' Yes ' NEW_LINE DEDENT print ( res ) NEW_LINE"],"bleu":0.17822127317171224,"rouge_l":0.36102625859131765}
{"id":120,"predictions":["def solve ( ) : NEW_LINE INDENT a = list ( int ( i ) for i in input ( ) . split ( ) ) NEW_LINE a . sort ( reverse = True ) NEW_LINE print ( a [ 1 ] ) NEW_LINE DEDENT solve ( ) NEW_LINE"],"references":["A = [ int ( input ( ) ) for i in range ( 3 ) ] NEW_LINE s = sorted ( A ) [ : : - 1 ] NEW_LINE for i in A : NEW_LINE INDENT print ( s . index ( i ) + 1 ) NEW_LINE DEDENT","def min_index ( array ) : NEW_LINE INDENT index = 0 NEW_LINE figure = 100 NEW_LINE for i in range ( len ( array ) ) : NEW_LINE INDENT if ( inputs [ i ] < 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( array [ i ] < figure ) : NEW_LINE INDENT figure = array [ i ] NEW_LINE index = i NEW_LINE DEDENT DEDENT return index NEW_LINE DEDENT def max_index ( array ) : NEW_LINE INDENT index = 0 NEW_LINE figure = 1 NEW_LINE for i in range ( len ( array ) ) : NEW_LINE INDENT if ( inputs [ i ] < 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( array [ i ] > figure ) : NEW_LINE INDENT figure = array [ i ] NEW_LINE index = i NEW_LINE DEDENT DEDENT return index NEW_LINE DEDENT inputs = [ ] NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT inputs . append ( int ( input ( ) ) ) NEW_LINE DEDENT inputs [ min_index ( inputs ) ] = - 3 NEW_LINE inputs [ max_index ( inputs ) ] = - 1 NEW_LINE for i in range ( len ( inputs ) ) : NEW_LINE INDENT if ( inputs [ i ] > 0 ) : NEW_LINE INDENT inputs [ i ] = - 2 NEW_LINE DEDENT DEDENT for i in range ( len ( inputs ) ) : NEW_LINE INDENT print ( inputs [ i ] * - 1 ) NEW_LINE DEDENT","A = int ( input ( ) ) NEW_LINE B = int ( input ( ) ) NEW_LINE C = int ( input ( ) ) NEW_LINE if A < B < C : NEW_LINE INDENT print ( 3 ) NEW_LINE print ( 2 ) NEW_LINE print ( 1 ) NEW_LINE DEDENT elif A < C < B : NEW_LINE INDENT print ( 3 ) NEW_LINE print ( 1 ) NEW_LINE print ( 2 ) NEW_LINE DEDENT elif B < A < C : NEW_LINE INDENT print ( 2 ) NEW_LINE print ( 3 ) NEW_LINE print ( 1 ) NEW_LINE DEDENT elif B < C < A : NEW_LINE INDENT print ( 1 ) NEW_LINE print ( 3 ) NEW_LINE print ( 2 ) NEW_LINE DEDENT elif C < B < A : NEW_LINE INDENT print ( 1 ) NEW_LINE print ( 2 ) NEW_LINE print ( 3 ) NEW_LINE DEDENT elif C < A < B : NEW_LINE INDENT print ( 2 ) NEW_LINE print ( 1 ) NEW_LINE print ( 3 ) NEW_LINE DEDENT","* a , = map ( int , open ( 0 ) ) NEW_LINE for i in a : print ( 3 - sorted ( a ) . index ( i ) ) NEW_LINE","ls = [ ] NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT ls . append ( int ( input ( ) ) ) NEW_LINE DEDENT rank = { } NEW_LINE for i in range ( len ( ls ) ) : NEW_LINE INDENT if ls [ i ] == max ( ls ) : NEW_LINE INDENT rank [ i ] = 1 NEW_LINE DEDENT elif ls [ i ] == min ( ls ) : NEW_LINE INDENT rank [ i ] = 3 NEW_LINE DEDENT else : NEW_LINE INDENT rank [ i ] = 2 NEW_LINE DEDENT DEDENT for i in range ( 3 ) : NEW_LINE INDENT print ( rank [ i ] ) NEW_LINE DEDENT"],"bleu":0.36232373969711823,"rouge_l":0.5646610400217805}
{"id":121,"predictions":["import sys NEW_LINE stdin = sys . stdin NEW_LINE sys . setrecursionlimit ( 10 ** 5 ) NEW_LINE def li ( ) : return map ( int , stdin . readline ( ) . split ( ) ) NEW_LINE def li_ ( ) : return map ( lambda x : int ( x ) - 1 , stdin . readline ( ) . split ( ) ) NEW_LINE def lf ( ) : return map ( float , stdin . readline ( ) . split ( ) ) NEW_LINE def ls ( ) : return stdin . readline ( ) . split ( ) NEW_LINE def ns ( ) : return stdin . readline ( ) . rstrip ( ) NEW_LINE def lc ( ) : return list ( ns ( ) ) NEW_LINE def ni ( ) : return int ( stdin . readline ( ) ) NEW_LINE def nf ( ) : return float ( stdin . readline ( ) ) NEW_LINE from collections import Counter NEW_LINE def nf ( ) : return float ( stdin . readline ( ) ) NEW_LINE for _ in range ( n - 1 ) : NEW_LINE INDENT a , b , p = li ( ) NEW_LINE if a == b : NEW_LINE INDENT print ( \" Alice \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Bob \" ) NEW_LINE DEDENT DEDENT"],"references":["import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE inf = 10 ** 20 NEW_LINE gosa = 1.0 \/ 10 ** 10 NEW_LINE mod = 10 ** 9 + 7 NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def F ( ) : return float ( sys . stdin . readline ( ) ) NEW_LINE def S ( ) : return input ( ) NEW_LINE def main ( ) : NEW_LINE INDENT n = I ( ) NEW_LINE e = collections . defaultdict ( set ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT a , b = LI ( ) NEW_LINE e [ a ] . add ( b ) NEW_LINE e [ b ] . add ( a ) NEW_LINE DEDENT def f ( i , c ) : NEW_LINE INDENT r = 0 NEW_LINE for j in e [ i ] : NEW_LINE INDENT if j == c : NEW_LINE INDENT continue NEW_LINE DEDENT t = f ( j , i ) NEW_LINE r ^= t NEW_LINE DEDENT return r + 1 NEW_LINE DEDENT if f ( 1 , - 1 ) == 1 : NEW_LINE INDENT return ' Bob ' NEW_LINE DEDENT return ' Alice ' NEW_LINE DEDENT print ( main ( ) ) NEW_LINE","import sys NEW_LINE from collections import defaultdict , Counter NEW_LINE from itertools import product , groupby , count , permutations , combinations NEW_LINE from math import pi , sqrt , ceil , floor NEW_LINE from collections import deque NEW_LINE from bisect import bisect , bisect_left , bisect_right NEW_LINE from string import ascii_lowercase NEW_LINE from functools import lru_cache , reduce NEW_LINE INF = float ( \" inf \" ) NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE dy = [ 0 , - 1 , 0 , 1 ] NEW_LINE dx = [ 1 , 0 , - 1 , 0 ] NEW_LINE def inside ( y : int , x : int , H : int , W : int ) -> bool : return 0 <= y < H and 0 <= x < W NEW_LINE def dfs ( n , p , grundy , graph ) : NEW_LINE INDENT g = 0 NEW_LINE for x in graph [ n ] : NEW_LINE INDENT if x != p : NEW_LINE INDENT g ^= dfs ( x , n , grundy , graph ) + 1 NEW_LINE DEDENT DEDENT grundy [ n ] = g NEW_LINE return g NEW_LINE DEDENT def solve ( N , graph ) : NEW_LINE INDENT grundy = [ None ] * ( N + 1 ) NEW_LINE dfs ( 1 , 0 , grundy , graph ) NEW_LINE return grundy [ 1 ] != 0 NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE graph = defaultdict ( list ) NEW_LINE for _ in range ( N - 1 ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE graph [ a ] . append ( b ) NEW_LINE graph [ b ] . append ( a ) NEW_LINE DEDENT print ( \" Alice \" if solve ( N , graph ) else \" Bob \" ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT","import sys NEW_LINE import random NEW_LINE sys . setrecursionlimit ( 10 ** 5 + 5 ) NEW_LINE random . seed = 1 NEW_LINE def read_int_list ( ) : NEW_LINE INDENT return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE DEDENT def read_int ( ) : NEW_LINE INDENT return int ( input ( ) ) NEW_LINE DEDENT def read_str_list ( ) : NEW_LINE INDENT return input ( ) . split ( ) NEW_LINE DEDENT def read_str ( ) : NEW_LINE INDENT return input ( ) NEW_LINE DEDENT a = None NEW_LINE def dfs ( root , parent ) : NEW_LINE INDENT res = 0 NEW_LINE for i in a [ root ] : NEW_LINE INDENT if i != parent : NEW_LINE INDENT res ^= 1 + dfs ( i , root ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT def read_tree ( check = False ) : NEW_LINE INDENT if check : NEW_LINE INDENT n , p = gen ( ) NEW_LINE DEDENT else : NEW_LINE INDENT n = read_int ( ) NEW_LINE p = [ read_int_list ( ) for i in range ( n - 1 ) ] NEW_LINE DEDENT global a NEW_LINE a = [ [ ] for _ in range ( n ) ] NEW_LINE for x , y in p : NEW_LINE INDENT x -= 1 NEW_LINE y -= 1 NEW_LINE a [ x ] . append ( y ) NEW_LINE a [ y ] . append ( x ) NEW_LINE DEDENT DEDENT def gen ( ) : NEW_LINE INDENT n = random . randint ( 5 , 30 ) NEW_LINE inside = [ 1 ] NEW_LINE outside = list ( range ( 2 , n + 1 ) ) NEW_LINE p = [ ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT x = random . choice ( inside ) NEW_LINE y = random . choice ( outside ) NEW_LINE p . append ( [ x , y ] ) NEW_LINE outside . remove ( y ) NEW_LINE inside . append ( y ) NEW_LINE DEDENT return n , p NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT read_tree ( check = False ) NEW_LINE return [ ' Bob ' , ' Alice ' ] [ dfs ( 0 , - 1 ) > 0 ] NEW_LINE DEDENT def check ( ) : NEW_LINE INDENT for i in range ( 1000 ) : NEW_LINE INDENT res = solve ( ) NEW_LINE print ( i , res ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT res = solve ( ) NEW_LINE print ( res ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"bleu":0.35086017107920897,"rouge_l":0.5084973647413144}
{"id":122,"predictions":["import sys NEW_LINE input = sys . stdin . readline NEW_LINE inf = 10 ** 18 NEW_LINE N , M = map ( int , input ( ) . split ( ) ) NEW_LINE A = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( M ) ] NEW_LINE res = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT res += A [ i ] [ 0 ] NEW_LINE DEDENT for i in range ( M ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if i != j : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT DEDENT print ( res ) NEW_LINE"],"references":["class Ford_Fulkerson : NEW_LINE INDENT def __init__ ( self , N ) : NEW_LINE INDENT self . used = [ False ] * ( N + 1 ) NEW_LINE self . G = [ [ 0 ] * ( N + 1 ) for i in range ( N + 1 ) ] NEW_LINE DEDENT def add_edge ( self , fr , to , cap ) : NEW_LINE INDENT self . G [ fr ] [ to ] = cap NEW_LINE DEDENT def dfs ( self , v , t , f ) : NEW_LINE INDENT if v == t : NEW_LINE INDENT return f NEW_LINE DEDENT self . used [ v ] = True NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT if v == i : NEW_LINE INDENT continue NEW_LINE DEDENT if ( not self . used [ i ] ) and self . G [ v ] [ i ] > 0 : NEW_LINE INDENT d = self . dfs ( i , t , min ( f , self . G [ v ] [ i ] ) ) NEW_LINE if d > 0 : NEW_LINE INDENT self . G [ v ] [ i ] -= d NEW_LINE self . G [ i ] [ v ] += d NEW_LINE return d NEW_LINE DEDENT DEDENT DEDENT return 0 NEW_LINE DEDENT DEDENT N , G , E = map ( int , input ( ) . split ( ) ) NEW_LINE p = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE F = Ford_Fulkerson ( N ) NEW_LINE for i in range ( G ) : NEW_LINE INDENT F . add_edge ( p [ i ] , N , 1 ) NEW_LINE DEDENT for i in range ( E ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE F . add_edge ( a , b , 1 ) NEW_LINE F . add_edge ( b , a , 1 ) NEW_LINE DEDENT num = 0 NEW_LINE while True : NEW_LINE INDENT F . used = [ False ] * ( N + 1 ) NEW_LINE f = F . dfs ( 0 , N , 10 ** 9 ) NEW_LINE if f == 0 : NEW_LINE INDENT break NEW_LINE DEDENT num += f NEW_LINE DEDENT print ( num ) NEW_LINE","import queue NEW_LINE G = [ [ 0 for _ in range ( 101 ) ] for __ in range ( 101 ) ] NEW_LINE n , g , e = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE for x in input ( ) . split ( ) : NEW_LINE INDENT pi = int ( x ) NEW_LINE G [ pi ] [ 100 ] = G [ 100 ] [ pi ] = 1 NEW_LINE DEDENT for _ in range ( e ) : NEW_LINE INDENT ai , bi = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE G [ ai ] [ bi ] = G [ bi ] [ ai ] = 1 NEW_LINE DEDENT def find_path ( ) : NEW_LINE INDENT q = queue . Queue ( ) NEW_LINE visited = { 0 : 0 } NEW_LINE q . put ( 0 ) NEW_LINE while not q . empty ( ) : NEW_LINE INDENT last = q . get ( ) NEW_LINE if last == 100 : NEW_LINE INDENT path = [ last ] NEW_LINE while last != 0 : NEW_LINE INDENT prev = visited [ last ] NEW_LINE path . insert ( 0 , prev ) NEW_LINE last = prev NEW_LINE DEDENT return path NEW_LINE DEDENT for to , gij in enumerate ( G [ last ] ) : NEW_LINE INDENT if gij > 0 and to not in visited : NEW_LINE INDENT visited [ to ] = last NEW_LINE q . put ( to ) NEW_LINE DEDENT DEDENT DEDENT return None NEW_LINE DEDENT while True : NEW_LINE INDENT path = find_path ( ) NEW_LINE if path is None : NEW_LINE INDENT break NEW_LINE DEDENT for i , j in zip ( path [ : - 1 ] , path [ 1 : ] ) : NEW_LINE INDENT G [ i ] [ j ] -= 1 NEW_LINE G [ j ] [ i ] += 1 NEW_LINE DEDENT DEDENT print ( sum ( Gi [ 0 ] == 2 for Gi in G ) ) NEW_LINE","import sys NEW_LINE input = sys . stdin . readline NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE class FordFulkerson : NEW_LINE INDENT def __init__ ( self , n ) : NEW_LINE INDENT self . visited = [ False ] * n NEW_LINE self . G = [ [ 0 ] * n for _ in range ( n ) ] NEW_LINE self . n = n NEW_LINE DEDENT def add_edge ( self , fr , to , cap ) : NEW_LINE INDENT self . G [ fr ] [ to ] = cap NEW_LINE self . G [ to ] [ fr ] = cap NEW_LINE DEDENT def dfs ( self , start , goal , f ) : NEW_LINE INDENT if start == goal : NEW_LINE INDENT return f NEW_LINE DEDENT self . visited [ start ] = True NEW_LINE for i in range ( self . n ) : NEW_LINE INDENT if i == start : NEW_LINE INDENT continue NEW_LINE DEDENT if ( not self . visited [ i ] ) and self . G [ start ] [ i ] > 0 : NEW_LINE INDENT d = self . dfs ( i , goal , min ( f , self . G [ start ] [ i ] ) ) NEW_LINE if d > 0 : NEW_LINE INDENT self . G [ start ] [ i ] -= d NEW_LINE self . G [ i ] [ start ] += d NEW_LINE return d NEW_LINE DEDENT DEDENT DEDENT return 0 NEW_LINE DEDENT def maxflow ( self ) : NEW_LINE INDENT flow = 0 NEW_LINE while True : NEW_LINE INDENT self . visited = [ False ] * self . n NEW_LINE f = self . dfs ( 0 , self . n - 1 , float ( ' inf ' ) ) NEW_LINE if f == 0 : NEW_LINE INDENT break NEW_LINE DEDENT flow += f NEW_LINE DEDENT return flow NEW_LINE DEDENT DEDENT n , g , e = map ( int , input ( ) . split ( ) ) NEW_LINE P = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE AB = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( e ) ] NEW_LINE FF = FordFulkerson ( n + 1 ) NEW_LINE for a , b in AB : NEW_LINE INDENT FF . add_edge ( a , b , 1 ) NEW_LINE DEDENT for p in P : NEW_LINE INDENT FF . add_edge ( p , n , 1 ) NEW_LINE DEDENT print ( FF . maxflow ( ) ) NEW_LINE","from collections import deque NEW_LINE import itertools NEW_LINE import numpy as np NEW_LINE import sys NEW_LINE def IL ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def SL ( ) : return input ( ) . split ( ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def S ( ) : return input ( ) NEW_LINE N , G , E = IL ( ) NEW_LINE P = IL ( ) NEW_LINE friends = [ IL ( ) for i in range ( E ) ] NEW_LINE edge = [ [ 0 for i in range ( N + 1 ) ] for j in range ( N + 1 ) ] NEW_LINE for ab in friends : NEW_LINE INDENT if ab [ 1 ] != 0 : NEW_LINE INDENT edge [ ab [ 0 ] ] [ ab [ 1 ] ] = 1 NEW_LINE DEDENT if ab [ 0 ] != 0 : NEW_LINE INDENT edge [ ab [ 1 ] ] [ ab [ 0 ] ] = 1 NEW_LINE DEDENT DEDENT for i in P : NEW_LINE INDENT edge [ i ] [ N ] = 1 NEW_LINE DEDENT count = 0 NEW_LINE while True : NEW_LINE INDENT stack = deque ( [ 0 ] ) NEW_LINE used = [ 0 ] * ( N + 1 ) NEW_LINE route = [ None ] * ( N + 1 ) NEW_LINE tmp = 0 NEW_LINE while stack : NEW_LINE INDENT tmp = stack . pop ( ) NEW_LINE if tmp == N : NEW_LINE INDENT break NEW_LINE DEDENT for i in range ( len ( edge [ tmp ] ) ) : NEW_LINE INDENT if edge [ tmp ] [ i ] == 1 and used [ i ] == 0 : NEW_LINE INDENT stack . append ( i ) NEW_LINE route [ i ] = tmp NEW_LINE used [ i ] = 1 NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT count += 1 NEW_LINE i = N NEW_LINE while i != 0 : NEW_LINE INDENT j = route [ i ] NEW_LINE edge [ j ] [ i ] = 0 NEW_LINE i = j NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE","N , G , E = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE P = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE itta = [ 0 for x in range ( N ) ] NEW_LINE itta [ 0 ] = 1 NEW_LINE def dfs ( gr , i ) : NEW_LINE INDENT for j in range ( len ( gr [ i ] ) ) : NEW_LINE INDENT if gr [ i ] [ j ] == - 1 : NEW_LINE INDENT del gr [ i ] [ j ] NEW_LINE return - 1 NEW_LINE DEDENT if itta [ gr [ i ] [ j ] ] == 0 : NEW_LINE INDENT itta [ gr [ i ] [ j ] ] = 1 NEW_LINE if dfs ( gr , gr [ i ] [ j ] ) == - 1 : NEW_LINE INDENT del gr [ i ] [ j ] NEW_LINE return - 1 NEW_LINE DEDENT DEDENT DEDENT return 0 NEW_LINE DEDENT gr = [ [ ] for x in range ( N ) ] NEW_LINE for i in range ( E ) : NEW_LINE INDENT a , b = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE gr [ a ] . append ( b ) NEW_LINE gr [ b ] . append ( a ) NEW_LINE DEDENT for p in P : NEW_LINE INDENT gr [ p ] . insert ( 0 , - 1 ) NEW_LINE DEDENT ans = 0 NEW_LINE while dfs ( gr , 0 ) == - 1 : NEW_LINE INDENT itta = [ 0 for x in range ( N ) ] NEW_LINE itta [ 0 ] = 1 NEW_LINE ans += 1 NEW_LINE DEDENT print ( ans ) NEW_LINE"],"bleu":0.15254916711105332,"rouge_l":0.31786547202489435}
{"id":123,"predictions":["a , b , c = map ( int , input ( ) . split ( ) ) if a < b : print ( \" AB \" ) elif c < a : print ( \" AC \" ) elif a > b : print ( \" AB \" ) elif c < a : print ( \" AB \" ) else : print ( \" A \" ) NEW_LINE"],"references":["X , A , B = map ( int , input ( ) . split ( ) ) NEW_LINE print ( [ \" A \" , \" B \" ] [ not ( abs ( X - A ) < abs ( X - B ) ) ] ) NEW_LINE","x , a , b = [ int ( item ) for item in input ( ) . split ( ) ] NEW_LINE if abs ( x - a ) > abs ( x - b ) : NEW_LINE INDENT print ( \" B \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" A \" ) NEW_LINE DEDENT","[ x , a , b ] = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if abs ( a - x ) < abs ( b - x ) : NEW_LINE INDENT print ( \" A \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" B \" ) NEW_LINE DEDENT","x , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE ans = ' B ' NEW_LINE if abs ( x - a ) < abs ( x - b ) : NEW_LINE INDENT ans = ' A ' NEW_LINE DEDENT print ( ans ) NEW_LINE","x , a , b = [ int ( n ) for n in input ( ) . split ( ) ] NEW_LINE print ( ' A ' if abs ( x - a ) < abs ( b - x ) else ' B ' ) NEW_LINE"],"bleu":0.33898714332227303,"rouge_l":0.5683706874842608}
{"id":124,"predictions":["import math NEW_LINE def takahashi_ball1 ( A : int , B : int , C : int ) -> float : NEW_LINE INDENT E = 10 ** ( - 6 ) NEW_LINE def f ( t : int ) -> float : NEW_LINE INDENT return A * t + B * math . sin ( C * t \/ math . pi ) NEW_LINE DEDENT def newton ( ta : float , tb : float , g ) -> float : NEW_LINE INDENT if g ( tb ) < 0 : NEW_LINE INDENT ta , tb = tb , ta NEW_LINE DEDENT while True : NEW_LINE INDENT m = ( ta + Tb ) \/ 2 NEW_LINE if g ( m ) < 0 : NEW_LINE INDENT return m NEW_LINE DEDENT if ( g ( m ) < 0 ) : NEW_LINE INDENT return m NEW_LINE DEDENT else : NEW_LINE INDENT tb = m NEW_LINE DEDENT DEDENT DEDENT return None NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a , b , C = map ( int , input ( ) . split ( ) ) NEW_LINE func = takahashi_ball1 ( a , b , c ) NEW_LINE print ( f ( a , b , c ) ) NEW_LINE DEDENT"],"references":["import math NEW_LINE N , Q = map ( int , input ( ) . split ( ) ) NEW_LINE X = [ 0 ] * N NEW_LINE R = [ 0 ] * N NEW_LINE H = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT X [ i ] , R [ i ] , H [ i ] = map ( int , input ( ) . split ( ) ) NEW_LINE DEDENT A = [ 0 ] * Q NEW_LINE B = [ 0 ] * Q NEW_LINE for i in range ( Q ) : NEW_LINE INDENT A [ i ] , B [ i ] = map ( int , input ( ) . split ( ) ) NEW_LINE DEDENT MAX_X = 3 * 10 ** 4 NEW_LINE V = [ 0 ] * MAX_X NEW_LINE for x in range ( MAX_X ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT if X [ i ] > x or X [ i ] + H [ i ] < x : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT Rleft = ( X [ i ] + H [ i ] - x ) * R [ i ] \/ H [ i ] NEW_LINE Rright = max ( 0 , ( X [ i ] + H [ i ] - ( x + 1 ) ) * R [ i ] \/ H [ i ] ) NEW_LINE Vleft = math . pi * Rleft ** 2 * ( X [ i ] + H [ i ] - x ) \/ 3 NEW_LINE Vright = math . pi * Rright ** 2 * ( X [ i ] + H [ i ] - ( x + 1 ) ) \/ 3 NEW_LINE V [ x ] += Vleft - Vright NEW_LINE DEDENT DEDENT DEDENT cum_sum = [ 0 ] * ( MAX_X + 1 ) NEW_LINE for x in range ( MAX_X ) : NEW_LINE INDENT cum_sum [ x + 1 ] = V [ x ] + cum_sum [ x ] NEW_LINE DEDENT for i in range ( Q ) : NEW_LINE INDENT res = cum_sum [ B [ i ] ] - cum_sum [ A [ i ] ] NEW_LINE print ( res ) NEW_LINE DEDENT","import numpy as P NEW_LINE def I ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE M , G , V = P . maximum , range , list ; N , Q = I ( ) ; X , R , H = P . array ( [ V ( I ( ) ) for _ in G ( N ) ] ) . T NEW_LINE for _ in G ( Q ) : K , L = M ( X + H - M ( X , V ( zip ( * [ I ( ) ] ) ) ) , 0 ) ; print ( P . sum ( P . pi * ( K ** 3 - L ** 3 ) * ( R \/ H ) ** 2 \/ 3 ) ) NEW_LINE","def b_cone ( N , Q , Cones , Queries ) : NEW_LINE INDENT import math NEW_LINE ans_tmp = [ ] NEW_LINE for a , b in Queries : NEW_LINE INDENT volume_sum = 0 NEW_LINE for x , r , h in Cones : NEW_LINE INDENT if x <= a <= x + h : NEW_LINE INDENT v1 = ( ( x + h - a ) ** 3 ) \/ ( h ** 2 ) * math . pi * ( r ** 2 ) \/ 3 NEW_LINE DEDENT elif a < x : NEW_LINE INDENT v1 = math . pi * ( r ** 2 ) * h \/ 3 NEW_LINE DEDENT else : NEW_LINE INDENT v1 = 0 NEW_LINE DEDENT if x <= b <= x + h : NEW_LINE INDENT v2 = ( ( x + h - b ) ** 3 ) \/ ( h ** 2 ) * math . pi * ( r ** 2 ) \/ 3 NEW_LINE DEDENT elif b < x : NEW_LINE INDENT v2 = math . pi * ( r ** 2 ) * h \/ 3 NEW_LINE DEDENT else : NEW_LINE INDENT v2 = 0 NEW_LINE DEDENT volume_sum += v1 - v2 NEW_LINE DEDENT ans_tmp . append ( str ( round ( volume_sum , 6 ) ) ) NEW_LINE DEDENT ans = ' \\n ' . join ( ans_tmp ) NEW_LINE return ans NEW_LINE DEDENT N , Q = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE Cones = [ [ int ( i ) for i in input ( ) . split ( ) ] for j in range ( N ) ] NEW_LINE Queries = [ [ int ( i ) for i in input ( ) . split ( ) ] for j in range ( Q ) ] NEW_LINE print ( b_cone ( N , Q , Cones , Queries ) ) NEW_LINE","import math NEW_LINE N , Q = map ( int , input ( ) . split ( ) ) NEW_LINE pyrms = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( N ) ] NEW_LINE def solve ( A , B ) : NEW_LINE INDENT res = 0 NEW_LINE for pyrm in pyrms : NEW_LINE INDENT X = pyrm [ 0 ] NEW_LINE R = pyrm [ 1 ] NEW_LINE H = pyrm [ 2 ] NEW_LINE if A <= X and X + H <= B : NEW_LINE INDENT temp = math . pi * ( R ** 2 ) * H \/ 3 NEW_LINE DEDENT elif X <= A and A <= X + H <= B : NEW_LINE INDENT temp = math . pi * ( ( R * ( X + H - A ) \/ H ) ** 2 ) * ( X + H - A ) \/ 3 NEW_LINE DEDENT elif A <= X <= B and B <= X + H : NEW_LINE INDENT temp = math . pi * ( R ** 2 ) * H \/ 3 NEW_LINE temp -= math . pi * ( ( R * ( X + H - B ) \/ H ) ** 2 ) * ( X + H - B ) \/ 3 NEW_LINE DEDENT elif X <= A and B <= X + H : NEW_LINE INDENT temp = math . pi * ( ( R * ( X + H - A ) \/ H ) ** 2 ) * ( X + H - A ) \/ 3 NEW_LINE temp -= math . pi * ( ( R * ( X + H - B ) \/ H ) ** 2 ) * ( X + H - B ) \/ 3 NEW_LINE DEDENT else : NEW_LINE INDENT temp = 0 NEW_LINE DEDENT res += temp NEW_LINE DEDENT return res NEW_LINE DEDENT for q in range ( Q ) : NEW_LINE INDENT A , B = map ( int , input ( ) . split ( ) ) NEW_LINE ans = solve ( A , B ) NEW_LINE print ( ans ) NEW_LINE DEDENT","from itertools import accumulate as ac NEW_LINE from math import pi NEW_LINE s = [ 0 ] * ( 2 * ( 10 ** 4 ) + 1 ) NEW_LINE n , q = map ( int , input ( ) . split ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT x , r , h = map ( int , input ( ) . split ( ) ) NEW_LINE for j in range ( x , x + h ) : NEW_LINE INDENT p = x + h - j NEW_LINE s [ j + 1 ] += pi * ( p * ( ( r * p \/ h ) ** 2 ) - ( p - 1 ) * ( ( r * ( p - 1 ) \/ h ) ** 2 ) ) \/ 3 NEW_LINE DEDENT DEDENT s = list ( ac ( s ) ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( s [ b ] - s [ a ] ) NEW_LINE DEDENT"],"bleu":0.2610772619364722,"rouge_l":0.3763854069223574}
{"id":125,"predictions":["h , m = map ( int , input ( ) . split ( ' : ' ) ) NEW_LINE n = int ( input ( ) ) NEW_LINE a = int ( input ( ) ) NEW_LINE if ( a >= 60 ) : NEW_LINE INDENT a -= 60 NEW_LINE DEDENT if ( a >= 12 ) : NEW_LINE INDENT print ( a - 12 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( 60 - a ) + ( 60 - a ) NEW_LINE DEDENT"],"references":["n = int ( input ( ) ) NEW_LINE h = n \/\/ ( 60 * 60 ) NEW_LINE m = ( n % ( 60 * 60 ) ) \/\/ 60 NEW_LINE s = ( n % ( 60 * 60 ) ) % 60 NEW_LINE print ( ' { :02 } : { : 02 } : { : 02 } ' . format ( h , m , s ) ) NEW_LINE","n = int ( input ( ) ) NEW_LINE x = n \/ 3600 NEW_LINE if x >= 1 : NEW_LINE INDENT a = int ( x ) NEW_LINE DEDENT else : NEW_LINE INDENT a = 0 NEW_LINE DEDENT if ( n % 3600 ) \/ 60 >= 1 : NEW_LINE INDENT b = int ( ( n % 3600 ) \/ 60 ) NEW_LINE DEDENT else : NEW_LINE INDENT b = 0 NEW_LINE DEDENT c = ( n % 3600 ) % 60 NEW_LINE if len ( str ( a ) ) == 1 : NEW_LINE INDENT a = \"0\" + str ( a ) NEW_LINE DEDENT if len ( str ( b ) ) == 1 : NEW_LINE INDENT b = \"0\" + str ( b ) NEW_LINE DEDENT if len ( str ( c ) ) == 1 : NEW_LINE INDENT c = \"0\" + str ( c ) NEW_LINE DEDENT print ( str ( a ) + \" : \" + str ( b ) + \" : \" + str ( c ) ) NEW_LINE","from datetime import datetime NEW_LINE from datetime import timedelta NEW_LINE n = int ( input ( ) ) NEW_LINE dt = datetime ( 1970 , 1 , 1 , 0 , 0 , 0 ) NEW_LINE td = timedelta ( seconds = n ) NEW_LINE dt += td NEW_LINE print ( dt . strftime ( \" % H : % M : % S \" ) ) NEW_LINE","s = int ( input ( ) ) NEW_LINE h = 0 NEW_LINE m = 0 NEW_LINE ss = 0 NEW_LINE while s >= 3600 : NEW_LINE INDENT s -= 3600 NEW_LINE h += 1 NEW_LINE DEDENT if h < 10 : NEW_LINE INDENT h = '0 { h } ' . format ( h = h ) NEW_LINE DEDENT while s >= 60 : NEW_LINE INDENT s -= 60 NEW_LINE m += 1 NEW_LINE DEDENT if m < 10 : NEW_LINE INDENT m = '0 { m } ' . format ( m = m ) NEW_LINE DEDENT while s > 0 : NEW_LINE INDENT s -= 1 NEW_LINE ss += 1 NEW_LINE DEDENT if ss < 10 : NEW_LINE INDENT ss = '0 { ss } ' . format ( ss = ss ) NEW_LINE DEDENT print ( \" { h } : { m } : { ss } \" . format ( h = h , m = m , ss = ss ) ) NEW_LINE","n = int ( input ( ) ) NEW_LINE ho = n \/\/ 3600 NEW_LINE if ( ho < 10 ) : NEW_LINE INDENT print ( 0 , end = \" \" ) NEW_LINE DEDENT print ( ho , end = \" \" ) NEW_LINE print ( \" : \" , end = \" \" ) NEW_LINE mi = n \/\/ 60 - ho * 60 NEW_LINE if ( mi < 10 ) : NEW_LINE INDENT print ( 0 , end = \" \" ) NEW_LINE DEDENT print ( mi , end = \" \" ) NEW_LINE print ( \" : \" , end = \" \" ) NEW_LINE se = n - ho * 3600 - mi * 60 NEW_LINE if ( se < 10 ) : NEW_LINE INDENT print ( 0 , end = \" \" ) NEW_LINE DEDENT print ( se ) NEW_LINE"],"bleu":0.5077417089616677,"rouge_l":0.45315128081198647}
{"id":126,"predictions":["def main ( ) : NEW_LINE INDENT N , K = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE if sum ( a ) == K : NEW_LINE INDENT print ( N + K ) NEW_LINE exit ( ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT ans += ( a [ i ] - a [ i - K ] ) * ( N + 1 ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"references":["import math NEW_LINE N , K = map ( int , input ( ) . split ( ) ) NEW_LINE A_ = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = math . ceil ( ( N - 1 ) \/ ( K - 1 ) ) NEW_LINE print ( ans ) NEW_LINE","import sys NEW_LINE input = sys . stdin . readline NEW_LINE N , K = map ( int , input ( ) . split ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE min_index = A . index ( 1 ) NEW_LINE if ( min_index > N \/\/ 2 ) : NEW_LINE INDENT A . reverse ( ) NEW_LINE DEDENT count = 0 NEW_LINE while ( 1 ) : NEW_LINE INDENT min_index = A . index ( 1 ) NEW_LINE if ( min_index == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( ( min_index - ( K - 1 ) ) >= 0 ) : NEW_LINE INDENT del A [ min_index - ( K - 1 ) : min_index ] NEW_LINE DEDENT elif ( ( min_index - ( K - 1 ) ) < 0 ) : NEW_LINE INDENT x = min_index - 1 NEW_LINE del A [ 0 : x + 1 ] NEW_LINE y = K - min_index - 1 NEW_LINE del A [ 1 : y + 1 ] NEW_LINE DEDENT count += 1 NEW_LINE DEDENT if ( ( len ( A ) - 1 ) % ( K - 1 ) == 0 ) : NEW_LINE INDENT count += ( len ( A ) - 1 ) \/\/ ( K - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT count += ( len ( A ) - 1 ) \/\/ ( K - 1 ) + 1 NEW_LINE DEDENT print ( count ) NEW_LINE","n , k , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) NEW_LINE print ( ( ( n - 1 ) - 1 ) \/\/ ( k - 1 ) + 1 ) NEW_LINE","import math NEW_LINE x = input ( ) . split ( \" ▁ \" ) NEW_LINE length = int ( x [ 0 ] ) NEW_LINE k = int ( x [ 1 ] ) NEW_LINE a = length - 1 NEW_LINE b = k - 1 NEW_LINE print ( math . ceil ( a \/ b ) ) NEW_LINE","from math import ceil NEW_LINE N , K = map ( int , input ( ) . split ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( ceil ( ( N - 1 ) \/ ( K - 1 ) ) ) NEW_LINE"],"bleu":0.41115032438567173,"rouge_l":0.6448202959830868}
{"id":127,"predictions":["import sys NEW_LINE stdin = sys . stdin NEW_LINE sys . setrecursionlimit ( 10 ** 5 ) NEW_LINE def li ( ) : return map ( int , stdin . readline ( ) . split ( ) ) NEW_LINE def li_ ( ) : return map ( lambda x : int ( x ) - 1 , stdin . readline ( ) . split ( ) ) NEW_LINE def lf ( ) : return map ( float , stdin . readline ( ) . split ( ) ) NEW_LINE def ls ( ) : return stdin . readline ( ) . split ( ) NEW_LINE def ns ( ) : return stdin . readline ( ) . rstrip ( ) NEW_LINE def lc ( ) : return list ( ns ( ) ) NEW_LINE def ni ( ) : return int ( stdin . readline ( ) ) NEW_LINE def nf ( ) : return float ( stdin . readline ( ) ) NEW_LINE n = ni ( ) NEW_LINE s = ns ( ) NEW_LINE grid = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT s = input ( ) NEW_LINE grid . append ( s ) NEW_LINE DEDENT ans = float ( ' inf ' ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT grid . append ( grid [ i ] ) NEW_LINE DEDENT ans = float ( ' inf ' ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT ans = min ( ans , grid [ i ] [ j ] ) NEW_LINE DEDENT ans = min ( ans , res ) NEW_LINE DEDENT print ( ans ) NEW_LINE"],"references":["import copy as co NEW_LINE class circle ( ) : NEW_LINE INDENT def __init__ ( self , numlist , amount_of_can ) : NEW_LINE INDENT self . numcircle = numlist NEW_LINE self . til = 0 NEW_LINE self . cansee = amount_of_can NEW_LINE self . times = 1 NEW_LINE DEDENT def right_rotation ( self , num , length ) : NEW_LINE INDENT a = self . numcircle [ : length - num ] NEW_LINE b = self . numcircle [ length - num : ] NEW_LINE return b + a NEW_LINE DEDENT DEDENT def sup_and ( str1 , str2 , length ) : NEW_LINE INDENT count = 0 NEW_LINE for x in range ( 0 , length ) : NEW_LINE INDENT str1 [ x ] = str1 [ x ] or str2 [ x ] NEW_LINE count += str1 [ x ] NEW_LINE DEDENT return count NEW_LINE DEDENT def search ( circlelist , length , TV ) : NEW_LINE INDENT list1 = [ ] NEW_LINE for x in range ( circlelist . til + 1 , length ) : NEW_LINE INDENT circlelist2 = co . deepcopy ( circlelist ) NEW_LINE circlelist2 . cansee = sup_and ( circlelist2 . numcircle , TV . right_rotation ( x , length ) , length ) NEW_LINE circlelist2 . til = x NEW_LINE circlelist2 . times += 1 NEW_LINE list1 . append ( circlelist2 ) NEW_LINE DEDENT return list1 NEW_LINE DEDENT inp1 = input ( ) NEW_LINE amount_of_can = 0 NEW_LINE numlist = [ ] NEW_LINE for x in inp1 : NEW_LINE INDENT if x == ' x ' : NEW_LINE INDENT numlist . append ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT numlist . append ( 1 ) NEW_LINE amount_of_can += 1 NEW_LINE DEDENT DEDENT length = len ( numlist ) NEW_LINE if amount_of_can == length : NEW_LINE INDENT print ( 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT else : NEW_LINE INDENT circlelist = circle ( numlist , amount_of_can ) NEW_LINE alllist1 = [ circlelist ] NEW_LINE TV = co . deepcopy ( circlelist ) NEW_LINE while True : NEW_LINE INDENT alllist2 = [ ] NEW_LINE while alllist1 : NEW_LINE INDENT alllist2 . extend ( search ( alllist1 . pop ( ) , length , TV ) ) NEW_LINE DEDENT alllist1 = alllist2 NEW_LINE for x in alllist1 : NEW_LINE INDENT if x . cansee == length : NEW_LINE INDENT print ( x . times ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT DEDENT DEDENT","C = input ( ) . replace ( ' o ' , '1' ) . replace ( ' x ' , '0' ) NEW_LINE P = int ( C , 2 ) NEW_LINE N = len ( C ) NEW_LINE ans = N NEW_LINE mask = 2 ** ( 2 * N - 1 ) - 2 ** ( N - 1 ) NEW_LINE for b in range ( 1 , 2 ** N ) : NEW_LINE INDENT ptn = cnt = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if b & ( 1 << i ) == 0 : continue NEW_LINE cnt += 1 NEW_LINE ptn |= ( P << i ) NEW_LINE ptn |= ( P << ( i + N ) ) NEW_LINE DEDENT if ptn & mask == mask : NEW_LINE INDENT ans = min ( ans , cnt ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE","from itertools import combinations NEW_LINE def solve ( ) : NEW_LINE INDENT s = input ( ) NEW_LINE patlen = len ( s ) NEW_LINE pat = [ ( i == ' o ' ) for i in s ] NEW_LINE pat = pat * 2 NEW_LINE for i in range ( patlen + 1 ) : NEW_LINE INDENT for j in combinations ( list ( range ( patlen ) ) , i ) : NEW_LINE INDENT zure = [ [ ] for _ in range ( i ) ] NEW_LINE for k in range ( i ) : NEW_LINE INDENT zure [ k ] = pat [ j [ k ] : j [ k ] + patlen ] NEW_LINE DEDENT newpat = [ False ] * patlen NEW_LINE for pl in range ( patlen ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT newpat [ pl ] |= zure [ j ] [ pl ] NEW_LINE DEDENT DEDENT if not False in newpat : return i NEW_LINE DEDENT DEDENT DEDENT print ( solve ( ) ) NEW_LINE","import sys NEW_LINE from collections import defaultdict , Counter NEW_LINE from itertools import product , groupby , count , permutations , combinations NEW_LINE from math import pi , sqrt , ceil , floor NEW_LINE from collections import deque NEW_LINE from bisect import bisect , bisect_left , bisect_right NEW_LINE from string import ascii_lowercase NEW_LINE INF = float ( \" inf \" ) NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE dy = [ 0 , - 1 , 0 , 1 ] NEW_LINE dx = [ 1 , 0 , - 1 , 0 ] NEW_LINE def inside ( y : int , x : int , H : int , W : int ) -> bool : return 0 <= y < H and 0 <= x < W NEW_LINE def main ( ) : NEW_LINE INDENT s = input ( ) NEW_LINE n = len ( s ) NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT l . append ( s ) NEW_LINE s = s [ 1 : ] + s [ 0 ] NEW_LINE DEDENT ans = INF NEW_LINE for b in range ( 2 ** n ) : NEW_LINE INDENT use = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if b & 1 << i : NEW_LINE INDENT use . append ( l [ i ] ) NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT ok = False NEW_LINE for j in range ( len ( use ) ) : NEW_LINE INDENT ok |= use [ j ] [ i ] == \" o \" NEW_LINE DEDENT if not ok : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT ans = min ( ans , len ( use ) ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT","S = input ( ) NEW_LINE N = len ( S ) NEW_LINE PTN = int ( S . replace ( ' o ' , '1' ) . replace ( ' x ' , '0' ) , 2 ) NEW_LINE def rotate_r ( n , b ) : NEW_LINE INDENT return ( n >> b ) | ( ( n << ( N - b ) ) & ( 2 ** N - 1 ) ) NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT OK = 2 ** N - 1 NEW_LINE set1 = set ( ) NEW_LINE set1 . add ( PTN ) NEW_LINE for n in range ( 1 , N + 1 ) : NEW_LINE INDENT set2 = set ( ) NEW_LINE for ptn in set1 : NEW_LINE INDENT if ptn == OK : return n NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT newptn = ptn | rotate_r ( PTN , i ) NEW_LINE set2 . add ( newptn ) NEW_LINE DEDENT DEDENT set1 = set2 NEW_LINE DEDENT DEDENT print ( solve ( ) ) NEW_LINE"],"bleu":0.3603374832474009,"rouge_l":0.4457778257766823}
{"id":128,"predictions":["import sys NEW_LINE stdin = sys . stdin NEW_LINE sys . setrecursionlimit ( 10 ** 5 ) NEW_LINE def li ( ) : return map ( int , stdin . readline ( ) . split ( ) ) NEW_LINE def li_ ( ) : return map ( lambda x : int ( x ) - 1 , stdin . readline ( ) . split ( ) ) NEW_LINE def lf ( ) : return map ( float , stdin . readline ( ) . split ( ) ) NEW_LINE def ls ( ) : return stdin . readline ( ) . split ( ) NEW_LINE def ns ( ) : return stdin . readline ( ) . rstrip ( ) NEW_LINE def lc ( ) : return list ( ns ( ) ) NEW_LINE def ni ( ) : return int ( stdin . readline ( ) ) NEW_LINE def nf ( ) : return float ( stdin . readline ( ) ) NEW_LINE from collections import Counter NEW_LINE n = ni ( ) NEW_LINE a = ns ( ) NEW_LINE cnt = Counter ( a ) NEW_LINE ans = 0 NEW_LINE for k , v in cnt . items ( ) : NEW_LINE INDENT if v % 2 : NEW_LINE INDENT ans += v NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT print ( main ( ) ) NEW_LINE"],"references":["n = int ( input ( ) ) NEW_LINE t = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT t [ i ] = int ( input ( ) ) NEW_LINE DEDENT t . sort ( ) NEW_LINE m = 10 ** 9 + 7 NEW_LINE res = 0 NEW_LINE ass = 1 NEW_LINE p = [ 1 ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT p . append ( p [ - 1 ] * i % m ) NEW_LINE DEDENT c = 0 NEW_LINE k = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT c += t [ i ] NEW_LINE res += c NEW_LINE if i != n - 1 : NEW_LINE INDENT if t [ i ] != t [ i + 1 ] : NEW_LINE INDENT ass = ass * p [ k ] % m NEW_LINE k = 1 NEW_LINE DEDENT else : NEW_LINE INDENT k += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT ass = ass * p [ k ] % m NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE print ( ass ) NEW_LINE","a = sorted ( map ( int , open ( 0 ) . read ( ) . split ( ) [ 1 : ] ) ) ; c = t = 0 NEW_LINE for b in a : t += b ; c += t NEW_LINE print ( c ) ; c = 1 NEW_LINE for s in set ( a ) : c = c * __import__ ( ' math ' ) . factorial ( a . count ( s ) ) % ( 10 ** 9 + 7 ) NEW_LINE print ( c ) NEW_LINE","from itertools import accumulate NEW_LINE from collections import Counter NEW_LINE from math import factorial NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE N = int ( input ( ) ) NEW_LINE T = [ int ( input ( ) ) for _ in range ( N ) ] NEW_LINE T . sort ( ) NEW_LINE cs = list ( accumulate ( T ) ) NEW_LINE print ( list ( accumulate ( cs ) ) [ - 1 ] ) NEW_LINE way = 1 NEW_LINE cnt = Counter ( T ) NEW_LINE for v in cnt . values ( ) : NEW_LINE INDENT way *= factorial ( v ) NEW_LINE way %= MOD NEW_LINE DEDENT print ( way ) NEW_LINE","import math NEW_LINE import collections NEW_LINE d = 1 NEW_LINE e = 0 NEW_LINE f = 0 NEW_LINE t = [ 0 ] * 10001 NEW_LINE for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT t [ int ( input ( ) ) ] += 1 NEW_LINE DEDENT for i in range ( 1 , 10001 ) : NEW_LINE INDENT s = t [ i ] NEW_LINE if s > 0 : NEW_LINE INDENT d *= math . factorial ( s ) NEW_LINE e += i * ( s * ( s + 1 ) \/\/ 2 ) + f * s NEW_LINE f += i * s NEW_LINE DEDENT DEDENT print ( e ) NEW_LINE print ( d % ( 10 ** 9 + 7 ) ) NEW_LINE","import numpy as np NEW_LINE MOD = 1000000007 NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE tn = [ int ( input ( ) ) for i in range ( n ) ] NEW_LINE cnt = { } NEW_LINE for t in tn : NEW_LINE INDENT if t in cnt : NEW_LINE INDENT cnt [ t ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt [ t ] = 1 NEW_LINE DEDENT DEDENT now = 0 NEW_LINE pena = 0 NEW_LINE for t in sorted ( cnt ) : NEW_LINE INDENT for i in range ( cnt [ t ] ) : NEW_LINE INDENT now += t NEW_LINE pena += now NEW_LINE DEDENT DEDENT ways = 1 NEW_LINE for t in cnt : NEW_LINE INDENT ways *= fact ( cnt [ t ] ) NEW_LINE ways %= MOD NEW_LINE DEDENT print ( pena ) NEW_LINE print ( ways ) NEW_LINE DEDENT def fact ( n ) : NEW_LINE INDENT fa = 1 NEW_LINE for k in range ( 1 , n + 1 ) : NEW_LINE INDENT fa *= k NEW_LINE fa %= MOD NEW_LINE DEDENT return fa NEW_LINE DEDENT main ( ) NEW_LINE"],"bleu":0.20511487141702464,"rouge_l":0.4025274950474759}
{"id":129,"predictions":["N , K = map ( int , input ( ) . split ( ) ) NEW_LINE A = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE K = int ( input ( ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( K ) : NEW_LINE INDENT for j in range ( i + 1 , K ) : NEW_LINE INDENT if A [ i ] > A [ j ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["from math import ceil NEW_LINE def main ( ) : NEW_LINE INDENT N , C , K = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE Ts = [ ] NEW_LINE for _ in range ( N ) : NEW_LINE INDENT Ts . append ( int ( input ( ) ) ) NEW_LINE DEDENT Ts . sort ( ) NEW_LINE bus_ct = 0 NEW_LINE in_bus = 1 NEW_LINE st = Ts . pop ( 0 ) + K NEW_LINE for Ti in Ts : NEW_LINE INDENT if Ti > st : NEW_LINE INDENT bus_ct += 1 NEW_LINE in_bus = 1 NEW_LINE st = Ti + K NEW_LINE DEDENT elif Ti <= st : NEW_LINE INDENT in_bus += 1 NEW_LINE DEDENT if in_bus > C : NEW_LINE INDENT bus_ct += 1 NEW_LINE in_bus = 1 NEW_LINE st = Ti + K NEW_LINE DEDENT DEDENT if in_bus : NEW_LINE INDENT bus_ct += 1 NEW_LINE DEDENT print ( bus_ct ) NEW_LINE DEDENT main ( ) NEW_LINE","from collections import defaultdict NEW_LINE N , C , K = map ( int , input ( ) . split ( ) ) NEW_LINE ps = defaultdict ( int ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT T = int ( input ( ) ) NEW_LINE ps [ T ] += 1 NEW_LINE DEDENT count = 0 NEW_LINE current_ps = 0 NEW_LINE time_limit = 10 ** 9 + K + 1 NEW_LINE for t in sorted ( ps . keys ( ) ) : NEW_LINE INDENT if t > time_limit and current_ps > 0 : NEW_LINE INDENT count += 1 NEW_LINE current_ps = 0 NEW_LINE DEDENT if current_ps == 0 : NEW_LINE INDENT time_limit = t + K NEW_LINE DEDENT current_ps += ps [ t ] NEW_LINE while current_ps >= C : NEW_LINE INDENT count += 1 NEW_LINE current_ps -= C NEW_LINE time_limit = t + K NEW_LINE DEDENT DEDENT if current_ps > 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT print ( count ) NEW_LINE","n , c , k = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE people = list ( reversed ( sorted ( [ int ( input ( ) ) for _ in range ( n ) ] ) ) ) NEW_LINE start = people [ 0 ] NEW_LINE cnt = 1 NEW_LINE ans = 1 NEW_LINE for i in people [ 1 : ] : NEW_LINE INDENT if start - i <= k and i >= start - k and cnt < c : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt = 1 NEW_LINE ans += 1 NEW_LINE start = i NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE","from bisect import bisect_right NEW_LINE N , C , K = map ( int , input ( ) . split ( ) ) NEW_LINE t = [ int ( input ( ) ) for _ in range ( N ) ] NEW_LINE t = list ( sorted ( t ) ) NEW_LINE ans = 0 NEW_LINE idx = 0 NEW_LINE while idx < N : NEW_LINE INDENT in_time_idx = bisect_right ( t , t [ idx ] + K ) NEW_LINE if ( in_time_idx - 1 ) - idx + 1 <= C : NEW_LINE INDENT idx = in_time_idx NEW_LINE DEDENT else : NEW_LINE INDENT idx += C NEW_LINE DEDENT ans += 1 NEW_LINE DEDENT print ( ans ) NEW_LINE","visitor , capacity , limit = map ( int , input ( ) . split ( ) ) NEW_LINE visitorList = [ ] NEW_LINE for _ in range ( visitor ) : NEW_LINE INDENT arrivalTime = int ( input ( ) ) NEW_LINE visitorList . append ( arrivalTime ) NEW_LINE DEDENT visitorList . sort ( ) NEW_LINE start = visitorList [ 0 ] NEW_LINE end = start + limit NEW_LINE count = 0 NEW_LINE bus = 1 NEW_LINE for j in visitorList : NEW_LINE INDENT if start <= j <= end : NEW_LINE INDENT count += 1 NEW_LINE if count <= capacity : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT bus += 1 NEW_LINE start = j NEW_LINE end = j + limit NEW_LINE count = 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT bus += 1 NEW_LINE start = j NEW_LINE end = j + limit NEW_LINE count = 1 NEW_LINE DEDENT DEDENT print ( bus ) NEW_LINE"],"bleu":0.5342488654704,"rouge_l":0.5560185953843599}
{"id":130,"predictions":["import sys NEW_LINE stdin = sys . stdin NEW_LINE sys . setrecursionlimit ( 10 ** 5 ) NEW_LINE def li ( ) : return map ( int , stdin . readline ( ) . split ( ) ) NEW_LINE def li_ ( ) : return map ( lambda x : int ( x ) - 1 , stdin . readline ( ) . split ( ) ) NEW_LINE def lf ( ) : return map ( float , stdin . readline ( ) . split ( ) ) NEW_LINE def ls ( ) : return stdin . readline ( ) . split ( ) NEW_LINE def ns ( ) : return stdin . readline ( ) . rstrip ( ) NEW_LINE def lc ( ) : return list ( ns ( ) ) NEW_LINE def ni ( ) : return int ( stdin . readline ( ) ) NEW_LINE def nf ( ) : return float ( stdin . readline ( ) ) NEW_LINE n , a = li ( ) NEW_LINE print ( nf ( a ) ) NEW_LINE"],"references":["import heapq NEW_LINE n , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE h = [ int ( input ( ) ) for i in range ( n ) ] NEW_LINE h . sort ( ) NEW_LINE p = a - b NEW_LINE def c ( w ) : NEW_LINE INDENT k = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT l [ i ] = l [ i ] - b * w NEW_LINE if l [ i ] > 0 : NEW_LINE INDENT k += l [ i ] \/\/ p NEW_LINE if l [ i ] % p != 0 : NEW_LINE INDENT k += 1 NEW_LINE DEDENT DEDENT DEDENT if w >= k : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT s = 0 NEW_LINE f = 10 ** 14 NEW_LINE while f - s >= 2 : NEW_LINE INDENT m = ( f + s ) \/\/ 2 NEW_LINE l = h [ : : ] NEW_LINE if c ( m ) : NEW_LINE INDENT f = m NEW_LINE DEDENT else : NEW_LINE INDENT s = m NEW_LINE DEDENT DEDENT l = h [ : : ] NEW_LINE if c ( s ) : NEW_LINE INDENT print ( s ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( f ) NEW_LINE DEDENT","import sys NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE input = sys . stdin . readline NEW_LINE def ceil ( x ) : NEW_LINE INDENT return int ( ( - x ) \/\/ 1 * ( - 1 ) ) NEW_LINE DEDENT N , A , B = map ( int , input ( ) . split ( ) ) NEW_LINE hp = [ int ( input ( ) ) for _ in range ( N ) ] NEW_LINE diff = A - B NEW_LINE def check ( x , HP ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if HP [ i ] - B * x <= 0 : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT cnt += ceil ( ( HP [ i ] - B * x ) \/ diff ) NEW_LINE DEDENT DEDENT return cnt <= x NEW_LINE DEDENT def solve2 ( ) : NEW_LINE INDENT HP = sorted ( hp , reverse = True ) NEW_LINE mi = HP [ 0 ] \/\/ A NEW_LINE ma = ceil ( HP [ 0 ] \/ B ) NEW_LINE while mi <= ma : NEW_LINE INDENT mid = ( mi + ma ) \/\/ 2 NEW_LINE if check ( mid , HP ) : NEW_LINE INDENT ma = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT mi = mid + 1 NEW_LINE DEDENT DEDENT print ( mi ) NEW_LINE DEDENT def check2 ( x , hp ) : NEW_LINE INDENT l = [ a - B * x for a in hp ] NEW_LINE ret = 0 NEW_LINE for a in l : NEW_LINE INDENT if a <= 0 : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT ret += ceil ( a \/ diff ) NEW_LINE DEDENT DEDENT return ret <= x NEW_LINE DEDENT def solve3 ( ) : NEW_LINE INDENT mi = max ( hp ) \/\/ A NEW_LINE ma = ceil ( max ( hp ) \/ B ) NEW_LINE while mi <= ma : NEW_LINE INDENT mid = ( mi + ma ) \/\/ 2 NEW_LINE if check2 ( mid , hp ) : NEW_LINE INDENT ma = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT mi = mid + 1 NEW_LINE DEDENT DEDENT print ( mi ) NEW_LINE DEDENT solve3 ( ) NEW_LINE","def inpl ( ) : return [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE N , A , B = inpl ( ) NEW_LINE C = A - B NEW_LINE h = [ int ( input ( ) ) for _ in range ( N ) ] NEW_LINE lo = - ( - sum ( h ) \/\/ ( ( N - 1 ) * B + A ) ) - 1 NEW_LINE hi = sum ( [ - ( - i \/\/ A ) for i in h ] ) NEW_LINE while hi - lo > 1 : NEW_LINE INDENT me = ( hi + lo ) \/\/ 2 NEW_LINE hprime = [ h [ i ] - me * B for i in range ( N ) if h [ i ] - me * B > 0 ] NEW_LINE hans = 0 NEW_LINE for j in hprime : NEW_LINE INDENT hans += - ( - j \/\/ C ) NEW_LINE DEDENT if hans <= me : NEW_LINE INDENT hi = me NEW_LINE DEDENT else : NEW_LINE INDENT lo = me NEW_LINE DEDENT DEDENT print ( hi ) NEW_LINE","from math import ceil NEW_LINE left = - 1 NEW_LINE right = 0 NEW_LINE n , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE h = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT h . append ( int ( input ( ) ) ) NEW_LINE right += h [ - 1 ] \/\/ b + 1 NEW_LINE DEDENT def check ( t ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if h [ i ] - b * t > 0 : NEW_LINE INDENT cnt += ceil ( ( h [ i ] - b * t ) \/ ( a - b ) ) NEW_LINE DEDENT DEDENT return cnt <= t NEW_LINE DEDENT while left + 1 < right : NEW_LINE INDENT mid = ( left + right ) \/\/ 2 NEW_LINE if check ( mid ) : NEW_LINE INDENT right = mid NEW_LINE DEDENT else : NEW_LINE INDENT left = mid NEW_LINE DEDENT DEDENT print ( right ) NEW_LINE","a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE l = [ int ( input ( ) ) for _ in range ( a ) ] NEW_LINE flag = True NEW_LINE l = sorted ( l ) NEW_LINE max_T = 10 ** 18 NEW_LINE def ok ( k ) : NEW_LINE INDENT s = k NEW_LINE for i in l : NEW_LINE INDENT hp = i - c * k NEW_LINE if hp > 0 : NEW_LINE INDENT s -= - ( - hp \/\/ ( b - c ) ) NEW_LINE DEDENT if s < 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def binary_search ( l , r ) : NEW_LINE INDENT mid = ( l + r ) \/\/ 2 NEW_LINE if l == r : NEW_LINE INDENT return l NEW_LINE DEDENT elif ok ( mid ) : NEW_LINE INDENT return binary_search ( l , mid ) NEW_LINE DEDENT else : NEW_LINE INDENT if mid == l : NEW_LINE INDENT mid += 1 NEW_LINE DEDENT return binary_search ( mid , r ) NEW_LINE DEDENT DEDENT ans = binary_search ( 0 , max_T ) NEW_LINE print ( ans ) NEW_LINE"],"bleu":0.24319559416742223,"rouge_l":0.3731080240514203}
{"id":131,"predictions":["import sys NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE INF = 10 ** 18 NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def II ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def SI ( ) : return input ( ) NEW_LINE from collections import Counter NEW_LINE def main ( ) : NEW_LINE INDENT N , S = LI ( ) NEW_LINE F = Counter ( S ) NEW_LINE ans = [ ] NEW_LINE for c in S : NEW_LINE INDENT if c == ' A ' : NEW_LINE INDENT ans . append ( c ) NEW_LINE break NEW_LINE DEDENT elif c == ' B ' : NEW_LINE INDENT ans . append ( a ) NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( a ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT main ( ) NEW_LINE"],"references":["import sys NEW_LINE from itertools import accumulate NEW_LINE from collections import deque NEW_LINE def solve ( ) : NEW_LINE INDENT N , K = map ( int , input ( ) . split ( ) ) NEW_LINE S = input ( ) NEW_LINE q = deque ( [ 1 if c == ' A ' else 0 for c in S ] ) NEW_LINE cb = 0 NEW_LINE for i in range ( min ( K , 2 * N + K % 2 ) ) : NEW_LINE INDENT if q [ 0 ] == ( cb ^ 1 ) : NEW_LINE INDENT q [ 0 ] ^= 1 NEW_LINE DEDENT else : NEW_LINE INDENT q . popleft ( ) NEW_LINE q . append ( cb ) NEW_LINE cb ^= 1 NEW_LINE DEDENT DEDENT ans = [ ' A ' if ( c ^ cb ) else ' B ' for c in q ] NEW_LINE print ( ' ' . join ( ans ) ) NEW_LINE DEDENT def debug ( x , table ) : NEW_LINE INDENT for name , val in table . items ( ) : NEW_LINE INDENT if x is val : NEW_LINE INDENT print ( ' DEBUG : { } ▁ - > ▁ { } ' . format ( name , val ) , file = sys . stderr ) NEW_LINE return None NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT"],"bleu":0.218904451245279,"rouge_l":0.32722752845741204}
{"id":132,"predictions":["import collections NEW_LINE A , B = map ( int , input ( ) . split ( ) ) NEW_LINE c = collections . Counter ( A ) NEW_LINE print ( c . get ( B , 0 ) ) NEW_LINE"],"references":["print ( eval ( input ( ) ) ) NEW_LINE","import sys , re NEW_LINE from collections import deque , defaultdict , Counter NEW_LINE from math import ceil , sqrt , hypot , factorial , pi , sin , cos , radians NEW_LINE from itertools import permutations , combinations , product NEW_LINE from operator import itemgetter , mul NEW_LINE from copy import deepcopy NEW_LINE from string import ascii_lowercase , ascii_uppercase , digits NEW_LINE def input ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def INT ( ) : return int ( input ( ) ) NEW_LINE def MAP ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE INF = float ( ' inf ' ) NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE s = input ( ) NEW_LINE print ( eval ( s ) ) NEW_LINE","import sys , os NEW_LINE f = lambda : list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if ' local ' in os . environ : NEW_LINE INDENT sys . stdin = open ( ' . \/ input . txt ' , ' r ' ) NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT a , op , b = input ( ) . split ( ) NEW_LINE a = int ( a ) NEW_LINE b = int ( b ) NEW_LINE if op == ' + ' : NEW_LINE INDENT print ( a + b ) NEW_LINE DEDENT elif op == ' - ' : NEW_LINE INDENT print ( a - b ) NEW_LINE DEDENT DEDENT solve ( ) NEW_LINE","s = input ( ) . split ( ) NEW_LINE a = int ( s [ 0 ] ) NEW_LINE b = int ( s [ 2 ] ) NEW_LINE if s [ 1 ] == ' + ' : NEW_LINE INDENT p = a + b NEW_LINE print ( p ) ; NEW_LINE DEDENT else : NEW_LINE INDENT q = a - b NEW_LINE print ( q ) NEW_LINE DEDENT","A , op , B = map ( str , input ( ) . split ( ) ) NEW_LINE if op == \" + \" : NEW_LINE INDENT c = int ( A ) + int ( B ) NEW_LINE DEDENT if op == \" - \" : NEW_LINE INDENT c = int ( A ) - int ( B ) NEW_LINE DEDENT print ( str ( c ) ) NEW_LINE"],"bleu":0.5718563022060605,"rouge_l":0.6929006085192697}
{"id":133,"predictions":["n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE count = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == ' U ' : NEW_LINE INDENT x += 1 NEW_LINE DEDENT elif s [ i ] == ' D ' : NEW_LINE INDENT y += 1 NEW_LINE DEDENT elif s [ i ] == ' D ' : NEW_LINE INDENT x += 1 NEW_LINE DEDENT else : NEW_LINE INDENT y += 1 NEW_LINE DEDENT DEDENT count += 1 NEW_LINE if s [ len ( s ) - 1 ] == ' L ' : NEW_LINE INDENT print ( count ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( count ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE stdin = sys . stdin NEW_LINE def li ( ) : return map ( int , stdin . readline ( ) . split ( ) ) NEW_LINE def li_ ( ) : return map ( lambda x : int ( x ) - 1 , stdin . readline ( ) . split ( ) ) NEW_LINE def lf ( ) : return map ( float , stdin . readline ( ) . split ( ) ) NEW_LINE def ls ( ) : return stdin . readline ( ) . split ( ) NEW_LINE def ns ( ) : return stdin . readline ( ) . rstrip ( ) NEW_LINE def lc ( ) : return list ( ns ( ) ) NEW_LINE def ni ( ) : return int ( stdin . readline ( ) ) NEW_LINE def nf ( ) : return float ( stdin . readline ( ) ) NEW_LINE s = ns ( ) NEW_LINE n = len ( s ) NEW_LINE ans = 0 NEW_LINE for idx , si in enumerate ( s ) : NEW_LINE INDENT if si == ' U ' : NEW_LINE INDENT ans += ( n - idx - 1 ) + 2 * idx NEW_LINE DEDENT else : NEW_LINE INDENT ans += 2 * ( n - idx - 1 ) + idx NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE","s = input ( ) ; print ( sum ( [ ( i * 2 + ( len ( s ) - i - 1 ) if h != \" D \" else i + ( len ( s ) - i - 1 ) * 2 ) for i , h in enumerate ( list ( s ) ) ] ) ) NEW_LINE","s = input ( ) NEW_LINE m = len ( s ) NEW_LINE ans = 2 * ( m - 1 ) NEW_LINE for i in range ( 1 , m - 1 ) : NEW_LINE INDENT ans += i + ( m - i - 1 ) NEW_LINE if s [ i ] == ' D ' : NEW_LINE INDENT ans += m - i - 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += i NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE","import sys NEW_LINE INF = float ( ' inf ' ) NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def II ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def SI ( ) : return input ( ) NEW_LINE def main ( ) : NEW_LINE INDENT s = SI ( ) NEW_LINE res = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT u = len ( s ) - i - 1 NEW_LINE d = len ( s ) - u - 1 NEW_LINE if s [ i ] == ' U ' : NEW_LINE INDENT res += u + 2 * d NEW_LINE DEDENT else : NEW_LINE INDENT res += 2 * u + d NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT print ( main ( ) ) NEW_LINE","s = input ( ) ; n = len ( s ) ; print ( n * ~ - n + sum ( ( s [ i ] > ' D ' ) * i + ( s [ i ] < ' U ' ) * ( n - 1 - i ) for i in range ( n ) ) ) NEW_LINE"],"bleu":0.4512923704092073,"rouge_l":0.5355281207133059}
{"id":134,"predictions":["import sys NEW_LINE def solve ( ) : NEW_LINE INDENT n = int ( sys . stdin . readline ( ) ) NEW_LINE d = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT d . append ( int ( sys . stdin . readline ( ) ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT s = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE if s [ i ] != ' + ' : NEW_LINE INDENT d . append ( s [ i ] ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT solve ( ) NEW_LINE"],"references":["def gcd ( a , b ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( b , a % b ) NEW_LINE DEDENT DEDENT N , A = map ( int , input ( ) . split ( ) ) NEW_LINE X = sorted ( map ( int , input ( ) . split ( ) ) ) NEW_LINE Y = [ ] NEW_LINE for x in X : NEW_LINE INDENT Y . append ( abs ( A - x ) ) NEW_LINE DEDENT ans = max ( Y ) NEW_LINE for y in Y : NEW_LINE INDENT ans = gcd ( y , ans ) NEW_LINE DEDENT print ( ans ) NEW_LINE","import sys NEW_LINE import fractions NEW_LINE def solve ( N : int , X : int , x : \" List [ int ] \" ) : NEW_LINE INDENT x . sort ( ) NEW_LINE gMax = None NEW_LINE last = None NEW_LINE begin = 0 NEW_LINE if abs ( X - x [ 0 ] ) > 0 : NEW_LINE INDENT last = abs ( X - x [ 0 ] ) NEW_LINE gMax = last NEW_LINE DEDENT else : NEW_LINE INDENT begin = 1 NEW_LINE last = x [ 1 ] - x [ 0 ] NEW_LINE gMax = last NEW_LINE DEDENT for i in range ( begin , N - 1 ) : NEW_LINE INDENT next = x [ i + 1 ] - x [ i ] NEW_LINE gMax = fractions . gcd ( gMax , next ) NEW_LINE DEDENT print ( gMax ) NEW_LINE return NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT def iterate_tokens ( ) : NEW_LINE INDENT for line in sys . stdin : NEW_LINE INDENT for word in line . split ( ) : NEW_LINE INDENT yield word NEW_LINE DEDENT DEDENT DEDENT tokens = iterate_tokens ( ) NEW_LINE N = int ( next ( tokens ) ) NEW_LINE X = int ( next ( tokens ) ) NEW_LINE x = [ int ( next ( tokens ) ) for _ in range ( N ) ] NEW_LINE solve ( N , X , x ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT","import fractions NEW_LINE from functools import reduce NEW_LINE from sys import stdin NEW_LINE N , X = [ int ( _ ) for _ in stdin . readline ( ) . rstrip ( ) . split ( ) ] NEW_LINE xs = [ int ( _ ) for _ in stdin . readline ( ) . rstrip ( ) . split ( ) ] NEW_LINE xs . sort ( ) NEW_LINE diff = [ xs [ i ] - xs [ i - 1 ] if i > 0 else abs ( xs [ i ] - X ) for i in range ( N ) ] NEW_LINE gcd = reduce ( fractions . gcd , diff ) NEW_LINE print ( gcd ) NEW_LINE","from fractions import gcd NEW_LINE from functools import reduce NEW_LINE N , X = map ( int , input ( ) . split ( ) ) NEW_LINE print ( reduce ( gcd , list ( map ( lambda x : abs ( int ( x ) - X ) , input ( ) . split ( ) ) ) ) ) NEW_LINE","n , x = map ( int , input ( ) . split ( ) ) NEW_LINE xlist = [ int ( n ) for n in input ( ) . split ( ) ] NEW_LINE dis_list = [ abs ( x - y ) for y in xlist ] NEW_LINE dis_list = sorted ( dis_list ) NEW_LINE def gojo ( num1 , num2 ) : NEW_LINE INDENT if num2 == 0 : NEW_LINE INDENT return num1 NEW_LINE DEDENT else : NEW_LINE INDENT return gojo ( num2 , num1 % num2 ) NEW_LINE DEDENT DEDENT if n == 1 : NEW_LINE INDENT print ( dis_list [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT gcd = gojo ( dis_list [ 1 ] , dis_list [ 0 ] ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT gcd = gojo ( dis_list [ i ] , gcd ) NEW_LINE DEDENT print ( gcd ) NEW_LINE DEDENT"],"bleu":0.553540246467618,"rouge_l":0.49659102472779076}
{"id":135,"predictions":["N , K = map ( int , input ( ) . split ( ) ) NEW_LINE if K == 1 : print ( N ) NEW_LINE else : NEW_LINE INDENT print ( K * ( N - K ) + K ) NEW_LINE DEDENT"],"references":["N , i = map ( int , input ( ) . split ( ) ) NEW_LINE print ( N - i + 1 ) NEW_LINE","import numpy as np NEW_LINE class Calculator : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . num = 0 NEW_LINE DEDENT def set_num ( self , N , i ) : NEW_LINE INDENT self . N = N NEW_LINE self . i = i NEW_LINE DEDENT def calc ( self ) : NEW_LINE INDENT self . num = self . N - self . i + 1 ; NEW_LINE DEDENT def get_num ( self ) : NEW_LINE INDENT return self . num NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT N , i , = map ( int , input ( ) . split ( ) ) NEW_LINE c = Calculator ( ) NEW_LINE c . set_num ( N , i ) NEW_LINE c . calc ( ) NEW_LINE ans = c . get_num ( ) NEW_LINE print ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT","a = list ( map ( int , input ( ) . split ( \" ▁ \" ) ) ) NEW_LINE print ( a [ 0 ] - a [ 1 ] + 1 ) NEW_LINE","def main ( ) : NEW_LINE INDENT N , i = map ( int , input ( ) . split ( ) ) NEW_LINE print ( N - i + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT","n , i = map ( int , input ( ) . split ( ) ) NEW_LINE ans = n - i + 1 NEW_LINE print ( ans ) NEW_LINE"],"bleu":0.4619154946735373,"rouge_l":0.7542576272488144}
{"id":136,"predictions":["n = int ( input ( ) ) a = int ( input ( ) ) b = int ( input ( ) ) import mathdef extgcd ( a , b ) : NEW_LINE"],"references":["N , A , B = map ( int , input ( ) . split ( ) ) NEW_LINE ans = list ( range ( A ) ) NEW_LINE m = 0 NEW_LINE rest = N - A NEW_LINE B -= 1 NEW_LINE if rest < B : NEW_LINE INDENT print ( - 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT if rest \/ A > B : NEW_LINE INDENT print ( - 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT while rest > B : NEW_LINE INDENT s = min ( A , rest - B + 1 ) NEW_LINE ans += list ( range ( m - s , m ) ) NEW_LINE m -= s NEW_LINE rest -= s NEW_LINE B -= 1 NEW_LINE DEDENT ans += list ( range ( m - B , m ) ) [ : : - 1 ] NEW_LINE m -= B NEW_LINE print ( \" ▁ \" . join ( [ str ( x - m + 1 ) for x in ans ] ) ) NEW_LINE","def solve ( n , a , b ) : NEW_LINE INDENT if n < a + b - 1 : NEW_LINE INDENT return [ - 1 ] NEW_LINE DEDENT if n > a * b : NEW_LINE INDENT return [ - 1 ] NEW_LINE DEDENT if b == 1 : NEW_LINE INDENT return list ( range ( 1 , n + 1 ) ) NEW_LINE DEDENT if a == 1 : NEW_LINE INDENT return list ( range ( n , 0 , - 1 ) ) NEW_LINE DEDENT ans = list ( range ( b , 0 , - 1 ) ) NEW_LINE ans . extend ( range ( n - a + 2 , n + 1 ) ) NEW_LINE t = b NEW_LINE for t in range ( 2 * b - 1 , n - a + 1 , b - 1 ) : NEW_LINE INDENT ans . extend ( range ( t , t - b + 1 , - 1 ) ) NEW_LINE DEDENT ans . extend ( range ( n - a + 1 , t , - 1 ) ) NEW_LINE return ans NEW_LINE DEDENT n , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( * solve ( n , a , b ) ) NEW_LINE","import sys NEW_LINE def inpl ( ) : return [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE N , A , B = inpl ( ) NEW_LINE rev = ( A < B ) NEW_LINE B , A = sorted ( [ B , A ] ) NEW_LINE if B < - ( - N \/\/ A ) or A + B - 1 > N : NEW_LINE INDENT print ( - 1 ) NEW_LINE sys . exit ( ) NEW_LINE DEDENT st = list ( range ( 1 , N + 1 ) ) NEW_LINE if B == 1 : NEW_LINE INDENT ans = st NEW_LINE DEDENT elif 2 * A > N : NEW_LINE INDENT ans = st [ A : N - B + 1 ] + st [ N - 1 : N - B : - 1 ] + st [ 0 : A ] NEW_LINE DEDENT else : NEW_LINE INDENT n = N \/\/ A NEW_LINE x = B + ( - N \/\/ A ) + 1 NEW_LINE ans = st [ n * A : N ] + st [ ( n - 1 ) * A : n * A - x ] + st [ n * A - 1 : n * A - x - 1 : - 1 ] NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT ans += st [ ( n - i ) * A : ( n - i + 1 ) * A ] NEW_LINE DEDENT DEDENT if rev : NEW_LINE INDENT ans = [ N + 1 - i for i in ans ] NEW_LINE DEDENT print ( * ans ) NEW_LINE","N , A , B = map ( int , input ( ) . split ( \" ▁ \" ) ) NEW_LINE if N < ( A + B - 1 ) or N > ( A * B ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE exit ( 0 ) NEW_LINE DEDENT if B == 1 and A == N : NEW_LINE INDENT seq = [ str ( n ) for n in range ( 1 , N + 1 ) ] NEW_LINE print ( ' ▁ ' . join ( seq ) ) NEW_LINE exit ( 0 ) NEW_LINE DEDENT seq = [ str ( num ) for num in range ( N - A + 1 , N + 1 ) ] NEW_LINE dif = ( A * B - N ) NEW_LINE div = A - ( dif \/\/ ( B - 1 ) ) NEW_LINE mer = ( dif % ( B - 1 ) ) NEW_LINE n = N - A NEW_LINE for i in range ( ( B - 1 ) - mer ) : NEW_LINE INDENT for j in range ( n - ( div ) + 1 , n + 1 ) : NEW_LINE INDENT seq . append ( str ( j ) ) NEW_LINE DEDENT n -= ( div ) NEW_LINE DEDENT for i in range ( mer ) : NEW_LINE INDENT for j in range ( n - div + 2 , n + 1 ) : NEW_LINE INDENT seq . append ( str ( j ) ) NEW_LINE DEDENT n -= ( div - 1 ) NEW_LINE DEDENT print ( ' ▁ ' . join ( seq ) ) NEW_LINE","n , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a + b - 1 > n or a * b < n : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT elif b == 1 : NEW_LINE INDENT print ( * list ( range ( 1 , n + 1 ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = list ( range ( n - a + 1 , n + 1 ) ) NEW_LINE num = b - 1 NEW_LINE mod = n - a - ( n - a ) \/\/ ( b - 1 ) * ( b - 1 ) NEW_LINE size1 = ( n - a ) \/\/ ( b - 1 ) NEW_LINE size2 = size1 + 1 NEW_LINE mi = n - a NEW_LINE for i in range ( num ) : NEW_LINE INDENT if i < num - mod : NEW_LINE INDENT ans += list ( range ( mi - size1 + 1 , mi + 1 ) ) NEW_LINE mi = mi - size1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += list ( range ( mi - size2 + 1 , mi + 1 ) ) NEW_LINE mi = mi - size2 NEW_LINE DEDENT DEDENT print ( * ans ) NEW_LINE DEDENT"],"bleu":0.004753623546170601,"rouge_l":0.18077900084674006}
{"id":137,"predictions":["def main ( ) : NEW_LINE INDENT s = input ( ) NEW_LINE n = len ( s ) NEW_LINE chs = changes ( s , n ) NEW_LINE res = n NEW_LINE for c in chs : NEW_LINE INDENT di = max ( c , n - c ) NEW_LINE res = max ( res , di ) NEW_LINE DEDENT return res NEW_LINE DEDENT print ( main ( ) ) NEW_LINE"],"references":["from string import ascii_lowercase NEW_LINE s = input ( ) NEW_LINE ans = 100 NEW_LINE for c in ascii_lowercase : NEW_LINE INDENT ans = min ( ans , max ( [ len ( x ) for x in s . split ( c ) ] ) ) NEW_LINE DEDENT print ( ans ) NEW_LINE","L = [ chr ( i ) for i in range ( 97 , 123 ) ] NEW_LINE s = list ( input ( ) ) NEW_LINE N = len ( s ) NEW_LINE ans = float ( \" inf \" ) NEW_LINE for i in L : NEW_LINE INDENT c = 0 NEW_LINE X = s NEW_LINE while True : NEW_LINE INDENT if X . count ( i ) == N - c : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT Y = [ ] NEW_LINE for j in range ( N - c - 1 ) : NEW_LINE INDENT if X [ j ] == i or X [ j + 1 ] == i : NEW_LINE INDENT Y . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT Y . append ( \" . \" ) NEW_LINE DEDENT DEDENT X = Y NEW_LINE DEDENT c += 1 NEW_LINE DEDENT if c < ans : NEW_LINE INDENT ans = c NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE","from collections import Counter NEW_LINE S = input ( ) NEW_LINE A = Counter ( list ( S ) ) . most_common ( ) NEW_LINE ans = float ( ' inf ' ) NEW_LINE for a in A : NEW_LINE INDENT posi = - 1 NEW_LINE interval = 0 NEW_LINE for i in range ( len ( S ) ) : NEW_LINE INDENT if S [ i ] == a [ 0 ] : NEW_LINE INDENT interval = max ( interval , i - posi - 1 ) NEW_LINE posi = i NEW_LINE DEDENT if i == len ( S ) - 1 : NEW_LINE INDENT interval = max ( interval , i - posi ) NEW_LINE posi = i NEW_LINE DEDENT DEDENT ans = min ( ans , interval ) NEW_LINE DEDENT print ( ans ) NEW_LINE","s = input ( ) NEW_LINE L = [ ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if not s [ i ] in L : NEW_LINE INDENT L . append ( s [ i ] ) NEW_LINE DEDENT DEDENT ans = float ( ' inf ' ) NEW_LINE if len ( L ) == 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( len ( L ) ) : NEW_LINE INDENT k = s NEW_LINE sub = 0 NEW_LINE flag = False NEW_LINE while flag == False : NEW_LINE INDENT cur = ' ' NEW_LINE cnt = 0 NEW_LINE for j in range ( len ( k ) - 2 , - 1 , - 1 ) : NEW_LINE INDENT if cnt == len ( cur ) : NEW_LINE INDENT if k [ j ] == L [ i ] : NEW_LINE INDENT cur = L [ i ] * 2 + cur NEW_LINE DEDENT else : NEW_LINE INDENT cur = k [ j ] + cur NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if k [ j ] == L [ i ] : NEW_LINE INDENT cur = L [ i ] + cur NEW_LINE DEDENT else : NEW_LINE INDENT None NEW_LINE DEDENT DEDENT cnt += 1 NEW_LINE DEDENT check = L [ i ] * len ( cur ) NEW_LINE sub += 1 NEW_LINE if check == cur : NEW_LINE INDENT if sub <= ans : NEW_LINE INDENT ans = sub NEW_LINE DEDENT flag = True NEW_LINE DEDENT else : NEW_LINE INDENT k = cur NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT","import sys NEW_LINE from collections import Counter NEW_LINE INF = float ( ' inf ' ) NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def II ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def SI ( ) : return input ( ) NEW_LINE def main ( ) : NEW_LINE INDENT s = SI ( ) NEW_LINE char_cnt = Counter ( s ) NEW_LINE res = INF NEW_LINE for c in char_cnt . keys ( ) : NEW_LINE INDENT r = s [ : ] NEW_LINE cnt = 0 NEW_LINE while len ( set ( r ) ) != 1 : NEW_LINE INDENT t = ' ' NEW_LINE for ss in zip ( r [ : - 1 ] , r [ 1 : ] ) : NEW_LINE INDENT if c in ss : NEW_LINE INDENT t += c NEW_LINE DEDENT else : NEW_LINE INDENT t += ss [ 0 ] NEW_LINE DEDENT DEDENT cnt += 1 NEW_LINE r = t NEW_LINE DEDENT res = min ( res , cnt ) NEW_LINE DEDENT return res NEW_LINE DEDENT print ( main ( ) ) NEW_LINE"],"bleu":0.5847948823634315,"rouge_l":0.5685307017543859}
{"id":138,"predictions":["def main ( ) : NEW_LINE INDENT n , t = map ( int , input ( ) . split ( ) ) NEW_LINE ans = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT a = int ( input ( ) ) NEW_LINE b = int ( input ( ) ) NEW_LINE if b < a : NEW_LINE INDENT ans . append ( a ) NEW_LINE DEDENT elif b > a : NEW_LINE INDENT ans . append ( b ) NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( a ) NEW_LINE DEDENT DEDENT print ( * ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"references":["l , h = map ( int , input ( ) . split ( ) ) NEW_LINE n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT a = int ( input ( ) ) NEW_LINE if a < l : NEW_LINE INDENT print ( l - a ) NEW_LINE DEDENT elif l <= a <= h : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT","import math NEW_LINE def getInt ( ) : return int ( input ( ) ) NEW_LINE def getIntList ( ) : return [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE def zeros ( n ) : return [ 0 ] * n NEW_LINE def zeros2 ( n , m ) : return [ zeros ( m ) for i in range ( n ) ] NEW_LINE class Debug ( ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . debug = True NEW_LINE DEDENT def off ( self ) : NEW_LINE INDENT self . debug = False NEW_LINE DEDENT def dmp ( self , x , cmt = ' ' ) : NEW_LINE INDENT if self . debug : NEW_LINE INDENT if cmt != ' ' : NEW_LINE INDENT w = cmt + ' : ▁ ' + str ( x ) NEW_LINE DEDENT else : NEW_LINE INDENT w = str ( x ) NEW_LINE DEDENT print ( w ) NEW_LINE DEDENT return x NEW_LINE DEDENT DEDENT def prob ( ) : NEW_LINE INDENT d = Debug ( ) NEW_LINE d . off ( ) NEW_LINE L , H = getIntList ( ) NEW_LINE d . dmp ( ( L , H ) , ' L , ▁ H ' ) NEW_LINE N = getInt ( ) NEW_LINE d . dmp ( ( N ) , ' N ' ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT a = getInt ( ) NEW_LINE if a > H : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT elif a >= L : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( L - a ) NEW_LINE DEDENT DEDENT return NEW_LINE DEDENT ans = prob ( ) NEW_LINE","def manage ( L : int , H : int , N : int , A : list ) -> list : NEW_LINE INDENT ret = [ ] NEW_LINE for a in A : NEW_LINE INDENT if a < L : NEW_LINE INDENT ret . append ( L - a ) NEW_LINE DEDENT elif H < a : NEW_LINE INDENT ret . append ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ret . append ( 0 ) NEW_LINE DEDENT DEDENT return ret NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT L , H = map ( int , input ( ) . split ( ) ) NEW_LINE N = int ( input ( ) ) NEW_LINE A = [ int ( input ( ) ) for _ in range ( N ) ] NEW_LINE ans = manage ( L , H , N , A ) NEW_LINE for a in ans : NEW_LINE INDENT print ( a ) NEW_LINE DEDENT DEDENT","l , h , n , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) NEW_LINE for i in a : print ( [ - ( h < i ) , l - i ] [ l > i ] ) NEW_LINE","L , H = map ( int , input ( ) . split ( ) ) NEW_LINE N = int ( input ( ) ) NEW_LINE A = [ int ( input ( ) ) for i in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT if A [ i ] < L : NEW_LINE INDENT print ( L - A [ i ] ) NEW_LINE DEDENT elif A [ i ] > H : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT"],"bleu":0.6565341419295561,"rouge_l":0.6606001353688802}
{"id":139,"predictions":["import sys NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE INF = 10 ** 18 NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def II ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def SI ( ) : return input ( ) NEW_LINE from collections import Counter NEW_LINE def main ( ) : NEW_LINE INDENT N , M = LI ( ) NEW_LINE XY = [ ] NEW_LINE for _ in range ( M ) : NEW_LINE INDENT XY . append ( LI_ ( ) ) NEW_LINE DEDENT balls = [ 1 ] * N NEW_LINE exp = set ( [ 0 ] ) NEW_LINE for x , y in XY : NEW_LINE INDENT balls [ x ] -= 1 NEW_LINE balls [ y ] += 1 NEW_LINE if x in exp : NEW_LINE INDENT exp . add ( y ) NEW_LINE if balls [ x ] == 0 : NEW_LINE INDENT exp . remove ( x ) NEW_LINE DEDENT DEDENT DEDENT ans = len ( exp ) NEW_LINE return ans NEW_LINE DEDENT print ( main ( ) ) NEW_LINE"],"references":["from collections import Counter NEW_LINE N , M = map ( int , input ( ) . split ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE src = [ tuple ( map ( int , input ( ) . split ( ) ) ) for i in range ( M ) ] NEW_LINE ctr = Counter ( A ) NEW_LINE cover = [ 0 ] * ( 2 * N + 1 ) NEW_LINE for k , v in ctr . items ( ) : NEW_LINE INDENT for i in range ( k , k - v , - 1 ) : NEW_LINE INDENT cover [ i + N ] += 1 NEW_LINE DEDENT DEDENT ans = cover [ N + 1 : ] . count ( 0 ) NEW_LINE for x , y in src : NEW_LINE INDENT ctr [ A [ x - 1 ] ] -= 1 NEW_LINE ai = A [ x - 1 ] + N - ctr [ A [ x - 1 ] ] NEW_LINE cover [ ai ] -= 1 NEW_LINE if ai > N and cover [ ai ] == 0 : ans += 1 NEW_LINE A [ x - 1 ] = y NEW_LINE bi = y + N - ctr [ y ] NEW_LINE if bi > N and cover [ bi ] == 0 : ans -= 1 NEW_LINE cover [ bi ] += 1 NEW_LINE ctr [ y ] += 1 NEW_LINE print ( ans ) NEW_LINE DEDENT","from collections import Counter NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE an = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ac_ = Counter ( an ) NEW_LINE ac = { i : ac_ [ i ] if i in ac_ else 0 for i in range ( 1 , n + 1 ) } NEW_LINE ad = [ 0 ] * n NEW_LINE for a , c in ac . items ( ) : NEW_LINE INDENT for i in range ( max ( 0 , a - c ) , a ) : NEW_LINE INDENT ad [ i ] += 1 NEW_LINE DEDENT DEDENT ans = ad . count ( 0 ) NEW_LINE anss = [ ] NEW_LINE for x , y in ( map ( int , input ( ) . split ( ) ) for _ in range ( m ) ) : NEW_LINE INDENT ax = an [ x - 1 ] NEW_LINE xdi = ax - ac [ ax ] NEW_LINE if xdi >= 0 : NEW_LINE INDENT ad [ xdi ] -= 1 NEW_LINE if ad [ xdi ] == 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT ac [ ax ] -= 1 NEW_LINE ac [ y ] += 1 NEW_LINE ydi = y - ac [ y ] NEW_LINE if ydi >= 0 : NEW_LINE INDENT ad [ ydi ] += 1 NEW_LINE if ad [ ydi ] == 1 : NEW_LINE INDENT ans -= 1 NEW_LINE DEDENT DEDENT an [ x - 1 ] = y NEW_LINE anss . append ( ans ) NEW_LINE DEDENT print ( ' \\n ' . join ( map ( str , anss ) ) ) NEW_LINE"],"bleu":0.2788361692730207,"rouge_l":0.37676606722816597}
{"id":140,"predictions":["import sys NEW_LINE def main ( ) : NEW_LINE INDENT input = sys . stdin . readline NEW_LINE N , K = map ( int , input ( ) . split ( ) ) NEW_LINE A = [ ] NEW_LINE for _ in range ( N ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE A . append ( ( a , b ) ) NEW_LINE DEDENT A = sorted ( A , key = lambda x : x [ 1 ] ) NEW_LINE cnt = 0 NEW_LINE for x in A : NEW_LINE INDENT cnt += x [ 0 ] NEW_LINE if cnt >= K : NEW_LINE INDENT return x [ 1 ] NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( main ( ) ) NEW_LINE DEDENT"],"references":["import heapq NEW_LINE N , K = map ( int , input ( ) . split ( ) ) NEW_LINE src = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE hq = [ ] NEW_LINE heapq . heapify ( hq ) NEW_LINE for i , a in enumerate ( src [ : K ] ) : NEW_LINE INDENT heapq . heappush ( hq , ( - a , i + 1 ) ) NEW_LINE DEDENT for i , a in enumerate ( src [ K : ] ) : NEW_LINE INDENT b , j = hq [ 0 ] NEW_LINE print ( j ) NEW_LINE if a < - b : NEW_LINE INDENT heapq . heappop ( hq ) NEW_LINE heapq . heappush ( hq , ( - a , K + i + 1 ) ) NEW_LINE DEDENT DEDENT b , j = hq [ 0 ] NEW_LINE print ( j ) NEW_LINE","from heapq import heappushpop NEW_LINE n , k = ( int ( i ) for i in input ( ) . split ( ) ) NEW_LINE x = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE a = [ ] NEW_LINE for i in range ( k ) : a . append ( [ - x [ i ] , i + 1 ] ) NEW_LINE a . sort ( ) NEW_LINE print ( a [ 0 ] [ 1 ] ) NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT heappushpop ( a , [ - x [ i ] , i + 1 ] ) NEW_LINE print ( a [ 0 ] [ 1 ] ) NEW_LINE DEDENT","def main ( ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE ages = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE indices = [ - 1 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a0 = ages [ i ] - 1 NEW_LINE indices [ a0 ] = i NEW_LINE DEDENT activated = [ False for i in range ( n ) ] NEW_LINE cursor = n NEW_LINE for i in range ( n ) : NEW_LINE INDENT a0 = ages [ i ] - 1 NEW_LINE activated [ a0 ] = True NEW_LINE if i >= k - 1 : NEW_LINE INDENT if cursor > a0 : NEW_LINE INDENT while True : NEW_LINE INDENT cursor -= 1 NEW_LINE if activated [ cursor ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT print ( indices [ cursor ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT main ( ) NEW_LINE","import sys NEW_LINE from heapq import heappop , heappush NEW_LINE fin = sys . stdin . readline NEW_LINE MAX_N = 100000 NEW_LINE N , K = [ int ( elem ) for elem in fin ( ) . split ( ) ] NEW_LINE X_list = tuple ( int ( elem ) for elem in fin ( ) . split ( ) ) NEW_LINE age_to_rank = [ None ] * ( N + 1 ) NEW_LINE for i , X in enumerate ( X_list , start = 1 ) : NEW_LINE INDENT age_to_rank [ X ] = i NEW_LINE DEDENT max_heap = [ ] NEW_LINE for X in X_list [ : K ] : NEW_LINE INDENT heappush ( max_heap , - X ) NEW_LINE DEDENT print ( age_to_rank [ - max_heap [ 0 ] ] ) NEW_LINE for X in X_list [ K : ] : NEW_LINE INDENT if X < - max_heap [ 0 ] : NEW_LINE INDENT heappop ( max_heap ) NEW_LINE heappush ( max_heap , - X ) NEW_LINE DEDENT print ( age_to_rank [ - max_heap [ 0 ] ] ) NEW_LINE DEDENT","def b_special_jury_prize ( N , K , X ) : NEW_LINE INDENT import heapq NEW_LINE heap = [ ( - X [ k ] , k + 1 ) for k in range ( K ) ] NEW_LINE heapq . heapify ( heap ) NEW_LINE ans = [ heap [ 0 ] [ 1 ] ] NEW_LINE for j in range ( K , N ) : NEW_LINE INDENT heapq . heappushpop ( heap , ( - X [ j ] , j + 1 ) ) NEW_LINE ans . append ( heap [ 0 ] [ 1 ] ) NEW_LINE DEDENT ans = ' \\n ' . join ( map ( str , ans ) ) NEW_LINE return ans NEW_LINE DEDENT N , K = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE X = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE print ( b_special_jury_prize ( N , K , X ) ) NEW_LINE"],"bleu":0.5036812178541117,"rouge_l":0.4567056598902421}
{"id":141,"predictions":["import sys   def main ( ) : return sum ( abs ( int ( i ) ) for i in sys . stdin . read ( ) . strip ( ) . split ( ) [ 1 : ] )   print ( main ( ) ) NEW_LINE"],"references":["n = int ( input ( ) ) NEW_LINE list = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE list . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans += ( - 1 ) ** ( i - 1 ) * list [ - i ] NEW_LINE DEDENT print ( ans ) NEW_LINE","import sys NEW_LINE l1 , l2 = [ sys . stdin . readline ( ) . strip ( ) for i in range ( 2 ) ] NEW_LINE input_list = [ int ( i ) for i in l2 . split ( ) ] NEW_LINE input_list . sort ( reverse = True ) NEW_LINE odd_index = [ j for i , j in enumerate ( input_list ) if i % 2 != 0 ] NEW_LINE even_index = [ j for i , j in enumerate ( input_list ) if i % 2 == 0 ] NEW_LINE print ( sum ( even_index ) - sum ( odd_index ) ) NEW_LINE","input ( ) NEW_LINE numbers = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE alice = bob = 0 NEW_LINE while ( len ( numbers ) ) : NEW_LINE INDENT if len ( numbers ) == 1 : NEW_LINE INDENT alice += numbers . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT alice += numbers . pop ( ) NEW_LINE bob += numbers . pop ( ) NEW_LINE DEDENT DEDENT print ( alice - bob ) NEW_LINE","N = int ( input ( ) ) NEW_LINE numbers_list = sorted ( [ int ( num ) for num in input ( ) . split ( ) ] ) NEW_LINE Alice_sum = sum ( [ numbers_list [ index ] for index in range ( N ) if index % 2 == 0 ] ) NEW_LINE Bob_sum = sum ( [ numbers_list [ index ] for index in range ( N ) if index % 2 != 0 ] ) NEW_LINE print ( abs ( Alice_sum - Bob_sum ) ) NEW_LINE","N = int ( input ( ) ) NEW_LINE list_an = input ( ) . split ( ) NEW_LINE list_an_int = [ int ( s ) for s in list_an ] NEW_LINE list_an_int . sort ( ) NEW_LINE list_an_int . reverse ( ) NEW_LINE Alice_counter = 0 NEW_LINE Bob_counter = 0 NEW_LINE counter = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if counter % 2 == 0 : NEW_LINE INDENT Alice_counter += list_an_int [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT Bob_counter += list_an_int [ i ] NEW_LINE DEDENT counter += 1 NEW_LINE DEDENT print ( Alice_counter - Bob_counter ) NEW_LINE"],"bleu":0.2614079036305369,"rouge_l":0.37841683795422204}
{"id":142,"predictions":["s = input ( ) . split ( ) x = int ( s [ 0 ] ) if int ( s [ 1 ] ) == 5 : print ( 7 ) elif int ( s [ 0 ] ) == 12 : print ( 7 ) else : print ( 12 ) NEW_LINE"],"references":["day = input ( ) NEW_LINE if day == \" Monday \" : NEW_LINE INDENT print ( 5 ) NEW_LINE DEDENT elif day == \" Tuesday \" : NEW_LINE INDENT print ( 4 ) NEW_LINE DEDENT elif day == \" Wednesday \" : NEW_LINE INDENT print ( 3 ) NEW_LINE DEDENT elif day == \" Thursday \" : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT elif day == \" Friday \" : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT","print ( int ( \" SaFrThWeTuMo \" . find ( input ( ) [ : 2 ] ) \/ 2 ) ) NEW_LINE","def ans ( ) : NEW_LINE INDENT day = input ( ) NEW_LINE if ( day == \" Sunday \" or day == \" Saturday \" ) : NEW_LINE INDENT res = 0 NEW_LINE DEDENT elif ( day == \" Monday \" ) : NEW_LINE INDENT res = 5 NEW_LINE DEDENT elif ( day == \" Tuesday \" ) : NEW_LINE INDENT res = 4 NEW_LINE DEDENT elif ( day == \" Wednesday \" ) : NEW_LINE INDENT res = 3 NEW_LINE DEDENT elif ( day == \" Thursday \" ) : NEW_LINE INDENT res = 2 NEW_LINE DEDENT elif ( day == \" Friday \" ) : NEW_LINE INDENT res = 1 NEW_LINE DEDENT print ( res ) NEW_LINE DEDENT ans ( ) NEW_LINE","print ( [ \" Saturday \" , \" Friday \" , \" Thursday \" , \" Wednesday \" , \" Tuesday \" , \" Monday \" , \" Sunday \" ] . index ( input ( ) ) % 6 ) NEW_LINE","s = input ( ) ; d = [ ' Monday ' , ' Tuesday ' , ' Wednesday ' , ' Thursday ' , ' Friday ' ] [ : : - 1 ] NEW_LINE for i , e in enumerate ( d ) : NEW_LINE INDENT if e == s : NEW_LINE INDENT print ( i + 1 ) ; exit ( ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT"],"bleu":0.16919571025287622,"rouge_l":0.5086473131562692}
{"id":143,"predictions":["def solve ( ) : NEW_LINE INDENT n = int ( raw_input ( ) ) NEW_LINE a = [ int ( x ) for x in raw_input ( ) . split ( ) ] NEW_LINE res = 0 NEW_LINE for i in xrange ( n ) : NEW_LINE INDENT res = min ( res , i - a [ i ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT for test in range ( readint ( ) ) : NEW_LINE INDENT print \" Case ▁ # % d : \" % ( test + 1 , solve ( input ( ) ) ) NEW_LINE DEDENT"],"references":["def solve ( ) : NEW_LINE INDENT N = input ( ) NEW_LINE ar = [ int ( _ ) for _ in raw_input ( ) . split ( ) ] NEW_LINE diffs = [ a - b for a , b in zip ( ar , ar [ 1 : ] ) ] NEW_LINE eat1 = sum ( max ( x , 0 ) for x in diffs ) NEW_LINE rate = max ( diffs + [ 0 ] ) NEW_LINE eat2 = sum ( min ( x , rate ) for x in ar [ : - 1 ] ) NEW_LINE return eat1 , eat2 NEW_LINE DEDENT T = input ( ) NEW_LINE for t in range ( 1 , T + 1 ) : NEW_LINE INDENT a , b = solve ( ) NEW_LINE print ' Case ▁ # % d : ▁ % d ▁ % d ' % ( t , a , b ) NEW_LINE DEDENT","cases = int ( raw_input ( ) ) NEW_LINE for i in xrange ( cases ) : NEW_LINE INDENT sample_count = int ( raw_input ( ) ) NEW_LINE samples = map ( int , raw_input ( ) . split ( ) ) NEW_LINE max_dec = 0 NEW_LINE prev = 0 NEW_LINE eaten1 = 0 NEW_LINE for x in samples : NEW_LINE INDENT eaten1 += max ( 0 , prev - x ) NEW_LINE max_dec = max ( max_dec , prev - x ) NEW_LINE prev = x NEW_LINE DEDENT prev = 0 NEW_LINE eaten2 = 0 NEW_LINE for x in samples : NEW_LINE INDENT eaten2 += min ( prev , max_dec ) NEW_LINE prev = x NEW_LINE DEDENT print \" Case ▁ # { } : ▁ { } ▁ { } \" . format ( i + 1 , eaten1 , eaten2 ) NEW_LINE DEDENT","import imp NEW_LINE __mod = imp . new_module ( \" utils \" ) NEW_LINE exec \"\"\" # ! \/ usr \/ bin \/ python STRNEWLINE STRNEWLINE from ▁ itertools ▁ import ▁ chain , ▁ repeat , ▁ izip STRNEWLINE STRNEWLINE def ▁ line ( * args ) : STRNEWLINE TABSYMBOL L ▁ = ▁ raw _ input ( ) . strip ( ) . split ( ) STRNEWLINE TABSYMBOL L ▁ = ▁ izip ( ▁ L , ▁ chain ( ▁ args , ▁ repeat ( str ) ▁ ) ▁ ) STRNEWLINE TABSYMBOL return ▁ [ ▁ type ( data ) ▁ for ▁ data , ▁ type ▁ in ▁ L ▁ ] TABSYMBOL STRNEWLINE TABSYMBOL STRNEWLINE def ▁ iline ( ) : ▁ return ▁ map ( ▁ int , ▁ raw _ input ( ) . strip ( ) . split ( ) ▁ ) STRNEWLINE def ▁ fline ( ) : ▁ return ▁ map ( ▁ float , ▁ raw _ input ( ) . strip ( ) . split ( ) ▁ ) \"\"\" in vars ( __mod ) NEW_LINE from utils import iline NEW_LINE from itertools import izip NEW_LINE def test ( ) : NEW_LINE INDENT iline ( ) NEW_LINE M = iline ( ) NEW_LINE def solve ( ) : NEW_LINE INDENT diffs = [ max ( 0 , a - b ) for a , b in izip ( M [ : - 1 ] , M [ 1 : ] ) ] NEW_LINE A = sum ( diffs ) NEW_LINE rate = max ( diffs ) NEW_LINE B = sum ( min ( a , rate ) for a in M [ : - 1 ] ) NEW_LINE print A , B NEW_LINE DEDENT return solve NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT T = input ( ) NEW_LINE for i in xrange ( 1 , T + 1 ) : NEW_LINE INDENT print ' Case ▁ # % d : ' % i , NEW_LINE test ( ) ( ) NEW_LINE DEDENT DEDENT","def solve1 ( a ) : NEW_LINE INDENT return sum ( [ max ( 0 , x - y ) for x , y in zip ( a , a [ 1 : ] ) ] ) NEW_LINE DEDENT def solve2 ( a ) : NEW_LINE INDENT rate_per_10 = max ( [ max ( 0 , x - y ) for x , y in zip ( a , a [ 1 : ] ) ] ) NEW_LINE if rate_per_10 == 0 : return 0 NEW_LINE eaten = 0 NEW_LINE for x in a [ : - 1 ] : NEW_LINE INDENT eaten += min ( x , rate_per_10 ) NEW_LINE DEDENT return eaten NEW_LINE DEDENT rl = raw_input NEW_LINE t = int ( rl ( ) ) NEW_LINE for c in xrange ( t ) : NEW_LINE INDENT n = int ( rl ( ) ) NEW_LINE m = map ( int , rl ( ) . strip ( ) . split ( ) ) NEW_LINE print ' Case ▁ # % d : ▁ % d ▁ % d ' % ( c + 1 , solve1 ( m ) , solve2 ( m ) ) NEW_LINE DEDENT","def gao1 ( l ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , len ( l ) ) : NEW_LINE INDENT if l [ i ] < l [ i - 1 ] : NEW_LINE INDENT ans += l [ i - 1 ] - l [ i ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def gao2 ( l ) : NEW_LINE INDENT rate = 0 NEW_LINE for i in range ( 1 , len ( l ) ) : NEW_LINE INDENT rate = max ( rate , l [ i - 1 ] - l [ i ] ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , len ( l ) ) : NEW_LINE INDENT ans += min ( l [ i - 1 ] , rate ) NEW_LINE DEDENT return ans NEW_LINE DEDENT t = int ( input ( ) ) NEW_LINE for cas in range ( t ) : NEW_LINE INDENT print ( ' Case ▁ # % d : ' % ( cas + 1 ) , end = ' ▁ ' ) NEW_LINE n = input ( ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( gao1 ( l ) , gao2 ( l ) ) NEW_LINE DEDENT"],"bleu":0.43794025553381344,"rouge_l":0.4900592388217155}
{"id":144,"predictions":["from math import fabs NEW_LINE cases = int ( raw_input ( ) ) NEW_LINE for c in xrange ( 1 , cases + 1 ) : NEW_LINE INDENT ns = int ( raw_input ( ) ) NEW_LINE x = [ ] NEW_LINE y = [ ] NEW_LINE z . append ( 0 ) NEW_LINE for i in xrange ( ns ) : NEW_LINE INDENT x . append ( y ) NEW_LINE y . append ( x [ 0 ] - x [ 0 ] ) NEW_LINE DEDENT r = [ ] NEW_LINE p = [ ] NEW_LINE p . append ( y ) NEW_LINE for i in xrange ( ns ) : NEW_LINE INDENT r . append ( x [ i ] - x [ 1 ] ) NEW_LINE DEDENT r . sort ( ) NEW_LINE t = abs ( x [ 0 ] - x [ 1 ] ) NEW_LINE y = abs ( y [ 0 ] - y [ 2 ] ) + abs ( x [ 1 ] - y [ 2 ] ) \/ 2 NEW_LINE if r [ 1 ] < t [ 2 ] : NEW_LINE INDENT t = 0 NEW_LINE DEDENT else : NEW_LINE INDENT t = abs ( x [ 0 ] - x [ 2 ] ) + abs ( y [ 2 ] - y [ 3 ] ) NEW_LINE DEDENT DEDENT print \" Case ▁ # % d : ▁ % .10f \" % ( c , t ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE from math import sqrt NEW_LINE class Obj : NEW_LINE INDENT pass NEW_LINE DEDENT def dist ( o1 , o2 ) : NEW_LINE INDENT return ( sqrt ( ( o1 . x - o2 . x ) ** 2 + ( o1 . y - o2 . y ) ** 2 ) + o2 . r + o1 . r ) \/ 2.0 NEW_LINE DEDENT def solve ( a ) : NEW_LINE INDENT n = len ( a ) NEW_LINE if n == 1 : NEW_LINE INDENT return a [ 0 ] . r NEW_LINE DEDENT if n == 2 : NEW_LINE INDENT return max ( a [ 0 ] . r , a [ 1 ] . r ) NEW_LINE DEDENT res = max ( dist ( a [ 0 ] , a [ 1 ] ) , a [ 2 ] . r ) NEW_LINE res = min ( res , max ( dist ( a [ 0 ] , a [ 2 ] ) , a [ 1 ] . r ) ) NEW_LINE res = min ( res , max ( dist ( a [ 1 ] , a [ 2 ] ) , a [ 0 ] . r ) ) NEW_LINE return res NEW_LINE DEDENT nCases = int ( sys . stdin . readline ( ) ) NEW_LINE for c in xrange ( 1 , nCases + 1 ) : NEW_LINE INDENT n = int ( sys . stdin . readline ( ) ) NEW_LINE a = [ ] NEW_LINE for i in xrange ( n ) : NEW_LINE INDENT o = Obj ( ) ; NEW_LINE ( o . x , o . y , o . r ) = [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE a . append ( o ) NEW_LINE DEDENT print \" Case ▁ # \" + str ( c ) + \" : ▁ \" + repr ( solve ( a ) ) NEW_LINE DEDENT","from pprint import pprint NEW_LINE import time NEW_LINE from sys import stdout , stdin , stderr NEW_LINE import sys NEW_LINE from math import sqrt NEW_LINE def read_int ( strLine ) : NEW_LINE INDENT return map ( int , strLine . split ( ' ▁ ' ) ) NEW_LINE DEDENT def rsreadline ( ) : NEW_LINE INDENT return inputfile . readline ( ) . rstrip ( ' \\n ' ) NEW_LINE DEDENT def solve ( rgPlants , fixed ) : NEW_LINE INDENT r = list ( rgPlants ) NEW_LINE del r [ fixed ] NEW_LINE return max ( rgPlants [ fixed ] [ 2 ] , ( sqrt ( ( r [ 0 ] [ 0 ] - r [ 1 ] [ 0 ] ) ** 2 + ( r [ 0 ] [ 1 ] - r [ 1 ] [ 1 ] ) ** 2 ) + r [ 0 ] [ 2 ] + r [ 1 ] [ 2 ] ) \/ 2 ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT cCase = int ( rsreadline ( ) ) NEW_LINE for iCase in range ( 0 , cCase ) : NEW_LINE INDENT cPlants = int ( rsreadline ( ) ) NEW_LINE rgPlants = [ ] NEW_LINE for i in range ( 0 , cPlants ) : NEW_LINE INDENT rgPlants . append ( read_int ( rsreadline ( ) ) ) NEW_LINE DEDENT ret = - 1.0 NEW_LINE if cPlants == 1 : NEW_LINE INDENT ret = rgPlants [ 0 ] [ 2 ] NEW_LINE DEDENT if cPlants == 2 : NEW_LINE INDENT ret = max ( rgPlants [ 0 ] [ 2 ] , rgPlants [ 1 ] [ 2 ] ) NEW_LINE DEDENT if cPlants == 3 : NEW_LINE INDENT ret = min ( solve ( rgPlants , 0 ) , solve ( rgPlants , 1 ) , solve ( rgPlants , 2 ) ) NEW_LINE DEDENT print ' Case ▁ # % d : ▁ % .8f ' % ( iCase + 1 , ret ) NEW_LINE stdout . flush ( ) NEW_LINE DEDENT DEDENT inputfile = stdin NEW_LINE if __name__ == ' _ _ main _ _ ' and not sys . argv [ 0 ] == ' - c ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT elif sys . argv [ 0 ] == ' - c ' : NEW_LINE INDENT print time . strftime ( ' % Y % m % d ▁ % H % M % S ' ) + ' ▁ loaded ' NEW_LINE print ' - - ' NEW_LINE inputfile = file ( ' input ' ) NEW_LINE main ( ) NEW_LINE print ' - - ' NEW_LINE DEDENT","problem = ' a ' NEW_LINE input_file_name = problem + \" . in \" NEW_LINE output_file_name = problem + \" . out \" NEW_LINE test_data = \"\"\" STRNEWLINE \"\"\" NEW_LINE test_data = None NEW_LINE def process ( input ) : NEW_LINE INDENT output = [ ] NEW_LINE iLine = 0 NEW_LINE N = int ( input [ iLine ] . strip ( ) ) NEW_LINE iLine += 1 NEW_LINE for case in range ( 1 , N + 1 ) : NEW_LINE INDENT print \" Case ▁ % d \" % case NEW_LINE nn = int ( input [ iLine ] . strip ( ) ) NEW_LINE iLine += 1 NEW_LINE for i in range ( nn ) : NEW_LINE INDENT input [ iLine ] . strip ( ) NEW_LINE iLine += 1 NEW_LINE DEDENT result = 0 NEW_LINE output . append ( result ) NEW_LINE DEDENT return output NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT input = None NEW_LINE if test_data is None : NEW_LINE INDENT ifile = open ( input_file_name ) NEW_LINE input = ifile . readlines ( ) NEW_LINE ifile . close ( ) NEW_LINE DEDENT else : NEW_LINE INDENT input = test_data . split ( ' \\n ' ) NEW_LINE DEDENT output = process ( input ) NEW_LINE if test_data is None : NEW_LINE INDENT ofile = open ( output_file_name , ' w ' ) NEW_LINE for i in range ( len ( output ) ) : NEW_LINE INDENT print >> ofile , \" Case ▁ # % d : \" % ( i + 1 ) , output [ i ] NEW_LINE DEDENT ofile . close ( ) NEW_LINE DEDENT for i in range ( len ( output ) ) : NEW_LINE INDENT print \" Case ▁ # % d : \" % ( i + 1 ) , output [ i ] NEW_LINE DEDENT return len ( output ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT import time NEW_LINE start = time . time ( ) NEW_LINE N = main ( ) NEW_LINE print \" Done ▁ in ▁ % f ▁ seconds \" % ( time . time ( ) - start ) NEW_LINE print \" Average ▁ % f ▁ milliseconds \" % ( ( time . time ( ) - start ) * 1000 \/ N ) NEW_LINE DEDENT","inp = open ( \" d : \\\\incoming\\\\d - small - attempt0 . in \" , \" r \" ) NEW_LINE outp = open ( \" . \\\\d . out \" , \" w \" ) NEW_LINE def go ( plants , a , b , c ) : NEW_LINE INDENT from math import hypot NEW_LINE return max ( plants [ a ] [ 2 ] , ( hypot ( plants [ b ] [ 0 ] - plants [ c ] [ 0 ] , plants [ b ] [ 1 ] - plants [ c ] [ 1 ] ) + plants [ b ] [ 2 ] + plants [ c ] [ 2 ] ) \/ 2.0 ) NEW_LINE DEDENT T = int ( inp . readline ( ) ) NEW_LINE for cc in range ( T ) : NEW_LINE INDENT n = int ( inp . readline ( ) ) NEW_LINE plants = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT plants . append ( tuple ( map ( int , inp . readline ( ) . split ( ) ) ) ) NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT sol = plants [ 0 ] [ 2 ] NEW_LINE DEDENT elif n == 2 : NEW_LINE INDENT sol = max ( plants [ 0 ] [ 2 ] , plants [ 1 ] [ 2 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT sol = 1e20 NEW_LINE sol = min ( sol , go ( plants , 0 , 1 , 2 ) ) NEW_LINE sol = min ( sol , go ( plants , 1 , 0 , 2 ) ) NEW_LINE sol = min ( sol , go ( plants , 2 , 0 , 1 ) ) NEW_LINE DEDENT outp . write ( \" Case ▁ # % d : ▁ % .10lf \\n \" % ( cc + 1 , sol ) ) NEW_LINE print \" Case ▁ # % d : ▁ % .10lf \" % ( cc + 1 , sol ) NEW_LINE DEDENT outp . close ( ) NEW_LINE","from __future__ import division NEW_LINE import collections NEW_LINE import itertools NEW_LINE import math NEW_LINE import sys NEW_LINE class gcj : NEW_LINE INDENT IN = sys . stdin NEW_LINE number = 0 NEW_LINE @ classmethod NEW_LINE def case ( cls ) : NEW_LINE INDENT cls . number += 1 NEW_LINE return ' Case ▁ # % d : ' % cls . number NEW_LINE DEDENT @ classmethod NEW_LINE def line ( cls , type = str ) : NEW_LINE INDENT line = cls . IN . readline ( ) NEW_LINE return type ( line . strip ( ' \\n ' ) ) NEW_LINE DEDENT @ classmethod NEW_LINE def splitline ( cls , type = str ) : NEW_LINE INDENT line = cls . IN . readline ( ) NEW_LINE return [ type ( x ) for x in line . split ( ) ] NEW_LINE DEDENT DEDENT def go ( ) : NEW_LINE INDENT c = gcj . line ( int ) NEW_LINE for _ in xrange ( c ) : NEW_LINE INDENT n = gcj . line ( int ) NEW_LINE data = [ ] NEW_LINE for _ in xrange ( n ) : NEW_LINE INDENT data . append ( gcj . splitline ( int ) ) NEW_LINE DEDENT print gcj . case ( ) , ' % .10f ' % min ( solve ( data ) ) NEW_LINE DEDENT DEDENT def solve ( data ) : NEW_LINE INDENT n = len ( data ) NEW_LINE for i in xrange ( n ) : NEW_LINE INDENT left = set ( [ i ] ) NEW_LINE right = set ( xrange ( n ) ) - left NEW_LINE r = max ( calc ( data [ i ] for i in right ) , calc ( data [ i ] for i in left ) ) NEW_LINE yield r NEW_LINE DEDENT DEDENT def calc ( data ) : NEW_LINE INDENT data = list ( data ) NEW_LINE if len ( data ) > 2 : NEW_LINE INDENT return 31337 NEW_LINE DEDENT if len ( data ) == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if len ( data ) == 1 : NEW_LINE INDENT return data [ 0 ] [ 2 ] NEW_LINE DEDENT assert len ( data ) == 2 NEW_LINE x1 , y1 , r1 = data [ 0 ] NEW_LINE x2 , y2 , r2 = data [ 1 ] NEW_LINE return ( r1 + r2 + math . hypot ( x1 - x2 , y1 - y2 ) ) \/ 2 NEW_LINE DEDENT go ( ) NEW_LINE"],"bleu":0.28443015162913116,"rouge_l":0.35582531924956645}
{"id":145,"predictions":["import sys NEW_LINE def makemap ( ) : NEW_LINE INDENT ALPHA = ' abcdefghijklmnopqrstuvwxyz ' NEW_LINE M = { ' y ' : ' A ' , ' e ' : ' F ' , ' g ' : ' B ' , } NEW_LINE G = ''' e ' NEW_LINE B = ' NEW_LINE C = 0 NEW_LINE def convertnums ( s ) : NEW_LINE INDENT if s == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( s * 2 ) + ' \\n ' NEW_LINE DEDENT def convertnums ( s ) : NEW_LINE INDENT S = input ( ) NEW_LINE for i in range ( len ( S ) ) : NEW_LINE INDENT if S [ i ] != ' - ' : NEW_LINE INDENT S [ i ] = S [ i ] NEW_LINE DEDENT DEDENT elif s . count ( ' - ' ) == 1 : NEW_LINE INDENT return S [ i ] , S [ i + 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT return S [ i ] NEW_LINE DEDENT DEDENT def convertnums ( s ) : NEW_LINE INDENT a = [ ] NEW_LINE DEDENT return a NEW_LINE DEDENT def convertnums ( s ) : NEW_LINE INDENT a = [ ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == ' ▁ ' : NEW_LINE INDENT a . append ( S [ i ] ) NEW_LINE DEDENT elif s [ i ] == ' - ' : NEW_LINE INDENT a . append ( S [ i ] ) NEW_LINE DEDENT DEDENT a . append ( a ) NEW_LINE DEDENT fidi = open ( ' A - large . in ' , ' r ' ) NEW_LINE fido = open ( ' a . out ' , ' w ' ) NEW_LINE T = fidi . readline ( ) NEW_LINE for i in range ( 1 , T + 1 ) : NEW_LINE INDENT print ( f ' Case ▁ # % d : ▁ % s ' % ( i + 1 , '"],"references":["import sys NEW_LINE sys . setrecursionlimit ( 100000 ) NEW_LINE inp = sys . stdin NEW_LINE outp = sys . stdout NEW_LINE words = [ \" ZERO \" , \" ONE \" , \" TWO \" , \" THREE \" , \" FOUR \" , \" FIVE \" , \" SIX \" , \" SEVEN \" , \" EIGHT \" , \" NINE \" ] NEW_LINE m = [ ( 0 , ' Z ' ) , ( 2 , ' W ' ) , ( 4 , ' U ' ) , ( 6 , ' X ' ) , ( 7 , ' S ' ) , ( 5 , ' V ' ) , ( 1 , ' O ' ) , ( 3 , ' R ' ) , ( 8 , ' H ' ) , ( 9 , ' E ' ) ] NEW_LINE def solve ( ) : NEW_LINE INDENT x = sys . stdin . readline ( ) . strip ( ) NEW_LINE f = [ 0 ] * 10 NEW_LINE for ( d , c ) in m : NEW_LINE INDENT cnt = x . count ( c ) NEW_LINE f [ d ] += cnt NEW_LINE for c2 in words [ d ] : NEW_LINE INDENT x = x . replace ( c2 , ' ' , cnt ) NEW_LINE DEDENT DEDENT assert x == ' ' NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT outp . write ( ( ' % d ' % i ) * f [ i ] ) NEW_LINE DEDENT print NEW_LINE DEDENT T = int ( inp . readline ( ) ) NEW_LINE for i in range ( T ) : NEW_LINE INDENT outp . write ( ' Case ▁ # % d : ▁ ' % ( i + 1 ) ) NEW_LINE solve ( ) NEW_LINE DEDENT","from collections import Counter NEW_LINE T = int ( input ( ) ) NEW_LINE for t in range ( T ) : NEW_LINE INDENT c = Counter ( input ( ) ) NEW_LINE res = { d : 0 for d in range ( 10 ) } NEW_LINE res [ 8 ] = c [ ' G ' ] NEW_LINE for let in ' EIGHT ' : NEW_LINE INDENT c [ let ] -= res [ 8 ] NEW_LINE DEDENT res [ 3 ] = c [ ' H ' ] NEW_LINE for let in ' THREE ' : NEW_LINE INDENT c [ let ] -= res [ 3 ] NEW_LINE DEDENT res [ 4 ] = c [ ' U ' ] NEW_LINE for let in ' FOUR ' : NEW_LINE INDENT c [ let ] -= res [ 4 ] NEW_LINE DEDENT res [ 2 ] = c [ ' W ' ] NEW_LINE for let in ' TWO ' : NEW_LINE INDENT c [ let ] -= res [ 2 ] NEW_LINE DEDENT res [ 6 ] = c [ ' X ' ] NEW_LINE for let in ' SIX ' : NEW_LINE INDENT c [ let ] -= res [ 6 ] NEW_LINE DEDENT res [ 5 ] = c [ ' F ' ] NEW_LINE for let in ' FIVE ' : NEW_LINE INDENT c [ let ] -= res [ 5 ] NEW_LINE DEDENT res [ 7 ] = c [ ' V ' ] NEW_LINE for let in ' SEVEN ' : NEW_LINE INDENT c [ let ] -= res [ 7 ] NEW_LINE DEDENT res [ 0 ] = c [ ' Z ' ] NEW_LINE for let in ' ZERO ' : NEW_LINE INDENT c [ let ] -= res [ 0 ] NEW_LINE DEDENT res [ 1 ] = c [ ' O ' ] NEW_LINE for let in ' ONE ' : NEW_LINE INDENT c [ let ] -= res [ 1 ] NEW_LINE DEDENT res [ 9 ] = c [ ' I ' ] NEW_LINE for let in ' NINE ' : NEW_LINE INDENT c [ let ] -= res [ 9 ] NEW_LINE DEDENT ans = ' ' . join ( str ( d ) * res [ d ] for d in range ( 10 ) ) NEW_LINE print ( ' Case ▁ # { } : ▁ { } ' . format ( t + 1 , ans ) ) NEW_LINE DEDENT","import sys NEW_LINE from collections import defaultdict NEW_LINE alpha = ' ABCDEFGHIJKLMNOPQRSTUVWXYZ ' NEW_LINE assert len ( alpha ) == 26 NEW_LINE def run ( S ) : NEW_LINE INDENT lcounts = defaultdict ( int ) NEW_LINE ncounts = [ 0 ] * 10 NEW_LINE for l in S : NEW_LINE INDENT lcounts [ l ] += 1 NEW_LINE DEDENT def setk ( k , kstr , l ) : NEW_LINE INDENT xxx = lcounts [ l ] NEW_LINE ncounts [ k ] = xxx NEW_LINE for lete in kstr : NEW_LINE INDENT lcounts [ lete ] -= xxx NEW_LINE DEDENT DEDENT setk ( 0 , ' ZERO ' , ' Z ' ) NEW_LINE setk ( 2 , ' TWO ' , ' W ' ) NEW_LINE setk ( 6 , ' SIX ' , ' X ' ) NEW_LINE setk ( 8 , ' EIGHT ' , ' G ' ) NEW_LINE setk ( 7 , ' SEVEN ' , ' S ' ) NEW_LINE setk ( 5 , ' FIVE ' , ' V ' ) NEW_LINE setk ( 9 , ' NINE ' , ' I ' ) NEW_LINE setk ( 1 , ' ONE ' , ' N ' ) NEW_LINE setk ( 4 , ' FOUR ' , ' U ' ) NEW_LINE setk ( 3 , ' THREE ' , ' R ' ) NEW_LINE assert not sum ( lcounts . values ( ) ) NEW_LINE return ' ' . join ( a * b for a , b in zip ( list ( '0123456789' ) , ncounts ) ) NEW_LINE DEDENT f = file ( sys . argv [ 1 ] , ' r ' ) NEW_LINE T = int ( f . readline ( ) . strip ( ) ) NEW_LINE for case in range ( 1 , T + 1 ) : NEW_LINE INDENT S = f . readline ( ) . strip ( ) NEW_LINE ans = run ( S ) NEW_LINE print ' Case ▁ # % d : ▁ % s ' % ( case , ans ) NEW_LINE DEDENT","import sys NEW_LINE tn = int ( sys . stdin . readline ( ) ) NEW_LINE for ti in xrange ( tn ) : NEW_LINE INDENT s = sys . stdin . readline ( ) . strip ( ) NEW_LINE d = { } NEW_LINE for c in s : NEW_LINE INDENT if c not in d : NEW_LINE INDENT d [ c ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ c ] += 1 NEW_LINE DEDENT DEDENT x = [ 0 ] * 10 NEW_LINE x [ 0 ] = d . get ( ' Z ' , 0 ) NEW_LINE x [ 2 ] = d . get ( ' W ' , 0 ) NEW_LINE x [ 4 ] = d . get ( ' U ' , 0 ) NEW_LINE x [ 6 ] = d . get ( ' X ' , 0 ) NEW_LINE x [ 8 ] = d . get ( ' G ' , 0 ) NEW_LINE x [ 1 ] = d . get ( ' O ' , 0 ) - x [ 0 ] - x [ 2 ] - x [ 4 ] NEW_LINE x [ 3 ] = d . get ( ' R ' , 0 ) - x [ 0 ] - x [ 4 ] NEW_LINE x [ 5 ] = d . get ( ' F ' , 0 ) - x [ 4 ] NEW_LINE x [ 7 ] = d . get ( ' S ' , 0 ) - x [ 6 ] NEW_LINE x [ 9 ] = d . get ( ' I ' , 0 ) - d . get ( ' F ' , 0 ) + x [ 4 ] - x [ 6 ] - x [ 8 ] NEW_LINE sol = ' ' . join ( [ chr ( ord ( '0' ) + i ) * x [ i ] for i in xrange ( 10 ) ] ) NEW_LINE print ' Case ▁ # { 0 } : ▁ { 1 } ' . format ( ti + 1 , sol ) NEW_LINE DEDENT","def solve ( ) : NEW_LINE INDENT s = raw_input ( ) NEW_LINE howmany = [ 0 ] * 10 NEW_LINE howmany [ 0 ] = s . count ( ' Z ' ) NEW_LINE howmany [ 2 ] = s . count ( ' W ' ) NEW_LINE howmany [ 6 ] = s . count ( ' X ' ) NEW_LINE howmany [ 8 ] = s . count ( ' G ' ) NEW_LINE howmany [ 7 ] = s . count ( ' S ' ) - howmany [ 6 ] NEW_LINE howmany [ 5 ] = s . count ( ' V ' ) - howmany [ 7 ] NEW_LINE howmany [ 4 ] = s . count ( ' F ' ) - howmany [ 5 ] NEW_LINE howmany [ 3 ] = s . count ( ' H ' ) - howmany [ 8 ] NEW_LINE howmany [ 1 ] = s . count ( ' O ' ) - howmany [ 0 ] - howmany [ 2 ] - howmany [ 4 ] NEW_LINE howmany [ 9 ] = s . count ( ' I ' ) - howmany [ 5 ] - howmany [ 6 ] - howmany [ 8 ] NEW_LINE ans = [ ] NEW_LINE for i in xrange ( 10 ) : NEW_LINE INDENT ans += [ i ] * howmany [ i ] NEW_LINE DEDENT ans . sort ( ) NEW_LINE return ' ' . join ( map ( str , ans ) ) NEW_LINE DEDENT T = input ( ) NEW_LINE for i in xrange ( T ) : NEW_LINE INDENT print ' Case ▁ # % d : ▁ % s ' % ( i + 1 , solve ( ) ) NEW_LINE DEDENT"],"bleu":0.371320014285572,"rouge_l":0.40089934278796263}
{"id":146,"predictions":["def solve ( n , a ) : NEW_LINE INDENT m = len ( a ) NEW_LINE if m == 1 : NEW_LINE INDENT return NEW_LINE DEDENT c = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if a [ i ] != a [ i - 1 ] : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT return c NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT f = open ( \" test . in \" , \" r \" ) NEW_LINE T = int ( f . readline ( ) ) NEW_LINE for i in range ( T ) : NEW_LINE INDENT print \" Case ▁ # % d : ▁ % d \" % ( i + 1 , solve ( n , a ) ) NEW_LINE DEDENT DEDENT main ( ) NEW_LINE"],"references":["import os , sys NEW_LINE def convertToBase ( number , base ) : NEW_LINE INDENT digits = [ ] NEW_LINE mod = base NEW_LINE prevMod = 1 NEW_LINE while number > 0 : NEW_LINE INDENT digit = ( number % mod ) \/ prevMod NEW_LINE digits . append ( digit ) NEW_LINE number = number - digit * prevMod NEW_LINE prevMod = mod NEW_LINE mod *= base NEW_LINE DEDENT if len ( digits ) == 0 : NEW_LINE INDENT digits = [ 0 ] NEW_LINE DEDENT return digits NEW_LINE DEDENT def squareDigits ( digits ) : NEW_LINE INDENT return sum ( [ x * x for x in digits ] ) NEW_LINE DEDENT def isHappy ( number , base ) : NEW_LINE INDENT foundNums = set ( ) NEW_LINE while True : NEW_LINE INDENT digits = convertToBase ( number , base ) NEW_LINE number = squareDigits ( digits ) NEW_LINE if number == 1 : NEW_LINE INDENT return True NEW_LINE DEDENT if number in foundNums : NEW_LINE INDENT return False NEW_LINE DEDENT foundNums . add ( number ) NEW_LINE DEDENT DEDENT def main ( filename ) : NEW_LINE INDENT fileLines = open ( filename , ' r ' ) . readlines ( ) NEW_LINE index = 0 NEW_LINE words = [ ] NEW_LINE numCases = int ( fileLines [ index ] [ : - 1 ] ) NEW_LINE index += 1 NEW_LINE for caseNum in range ( numCases ) : NEW_LINE INDENT bases = [ int ( x ) for x in fileLines [ index ] [ : - 1 ] . split ( ' ▁ ' ) ] NEW_LINE index += 1 NEW_LINE i = 2 NEW_LINE while True : NEW_LINE INDENT happy = True NEW_LINE for base in bases : NEW_LINE INDENT if ( not isHappy ( i , base ) ) : NEW_LINE INDENT happy = False NEW_LINE break NEW_LINE DEDENT DEDENT if happy : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print \" Case ▁ # % d : ▁ % d \" % ( caseNum + 1 , i ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 ] ) NEW_LINE DEDENT","f = open ( \" data \" , \" r \" ) NEW_LINE allmins = eval ( f . read ( ) ) NEW_LINE f . close ( ) NEW_LINE for case in range ( input ( ) ) : NEW_LINE INDENT print \" Case ▁ # \" + str ( case + 1 ) + \" : \" , NEW_LINE bases = tuple ( map ( int , raw_input ( ) . split ( ) ) ) NEW_LINE print allmins [ bases ] NEW_LINE DEDENT","import sys NEW_LINE fin = file ( sys . argv [ 1 ] , ' r ' ) NEW_LINE T = int ( fin . readline ( ) ) NEW_LINE def happy ( x , b ) : NEW_LINE INDENT prev = x NEW_LINE prev = [ 0 ] NEW_LINE while True : NEW_LINE INDENT v = 0 NEW_LINE while x > 0 : NEW_LINE INDENT v += ( x % b ) * ( x % b ) NEW_LINE x = x \/ b NEW_LINE DEDENT if v == 1 : return True NEW_LINE if v in prev : return False NEW_LINE prev . append ( v ) NEW_LINE x = v NEW_LINE DEDENT DEDENT for t in xrange ( 1 , T + 1 ) : NEW_LINE INDENT bases = [ int ( x ) for x in fin . readline ( ) . split ( ) ] NEW_LINE m = 2 NEW_LINE while True : NEW_LINE INDENT if all ( happy ( m , b ) for b in bases ) : NEW_LINE INDENT break NEW_LINE DEDENT m += 1 NEW_LINE DEDENT print ' Case ▁ # % d : ▁ % d ' % ( t , m ) NEW_LINE DEDENT","import sys , os NEW_LINE in_file = None NEW_LINE out_file = None NEW_LINE def run_main ( main ) : NEW_LINE INDENT name = sys . argv [ 0 ] [ : - 3 ] NEW_LINE in_file_name = name + \" . in \" NEW_LINE out_file_name = name + \" . out \" NEW_LINE if len ( sys . argv ) == 2 : NEW_LINE INDENT in_file_name = sys . argv [ 1 ] NEW_LINE out_file_name = in_file_name [ : - 3 ] + \" . out \" NEW_LINE DEDENT if len ( sys . argv ) == 3 : NEW_LINE INDENT if sys . argv [ 1 ] : NEW_LINE INDENT in_file_name = sys . argv [ 1 ] NEW_LINE DEDENT if sys . argv [ 2 ] : NEW_LINE INDENT out_file_name = sys . argv [ 2 ] NEW_LINE DEDENT DEDENT global in_file NEW_LINE global out_file NEW_LINE if in_file_name == ' - ' : NEW_LINE INDENT in_file = sys . stdin NEW_LINE DEDENT else : NEW_LINE INDENT in_file = open ( in_file_name , ' r ' ) NEW_LINE DEDENT if out_file_name == ' - ' : NEW_LINE INDENT out_file = sys . stdout NEW_LINE DEDENT else : NEW_LINE INDENT out_file = open ( out_file_name , ' w ' ) NEW_LINE DEDENT main ( in_file , out_file ) NEW_LINE out_file . close ( ) NEW_LINE in_file . close ( ) NEW_LINE DEDENT def run_tests ( do_testcase ) : NEW_LINE INDENT def main ( in_file , out_file ) : NEW_LINE INDENT t = readinteger ( ) NEW_LINE for x in xrange ( t ) : NEW_LINE INDENT do_testcase ( x + 1 ) NEW_LINE DEDENT DEDENT run_main ( main ) NEW_LINE DEDENT def readline ( ) : NEW_LINE INDENT return in_file . readline ( ) [ : - 1 ] NEW_LINE DEDENT def writeline ( s ) : NEW_LINE INDENT out_file . write ( \" % s \\n \" % s ) NEW_LINE DEDENT def readinteger ( ) : NEW_LINE INDENT return int ( readline ( ) ) NEW_LINE DEDENT def readintegers ( ) : NEW_LINE INDENT integers = readline ( ) . split ( ) NEW_LINE for i in xrange ( len ( integers ) ) : NEW_LINE INDENT integers [ i ] = int ( integers [ i ] ) NEW_LINE DEDENT return integers NEW_LINE DEDENT","file = \" A - small - attempt0\" NEW_LINE inp = open ( file + \" . in \" ) NEW_LINE import pdb NEW_LINE def dsum ( num , b ) : NEW_LINE INDENT n = num NEW_LINE sumd = 0 NEW_LINE while n > 0 : NEW_LINE INDENT sumd += ( n % b ) ** 2 NEW_LINE n \/= b NEW_LINE DEDENT return sumd NEW_LINE DEDENT def happy ( num , b , hp ) : NEW_LINE INDENT if num in hp : NEW_LINE INDENT return hp [ num ] NEW_LINE DEDENT if num == 1 : NEW_LINE INDENT return True NEW_LINE DEDENT ds = dsum ( num , b ) NEW_LINE hp [ num ] = False NEW_LINE if happy ( ds , b , hp ) : NEW_LINE INDENT hp [ num ] = True NEW_LINE DEDENT return hp [ num ] NEW_LINE DEDENT for it , case in enumerate ( list ( inp ) [ 1 : ] ) : NEW_LINE INDENT bases = map ( int , case . split ( ) ) NEW_LINE hps = [ ] NEW_LINE for i in range ( 11 ) : NEW_LINE INDENT hps . append ( { } ) NEW_LINE DEDENT for num in range ( 2 , 10000000 ) : NEW_LINE INDENT if all ( [ happy ( num , b , hps [ b ] ) for b in bases ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print \" Case ▁ # % d : ▁ % d \" % ( it + 1 , num ) NEW_LINE DEDENT"],"bleu":0.5911961273678314,"rouge_l":0.5535450416557126}
{"id":147,"predictions":["task = ' C ' NEW_LINE type = 2 NEW_LINE if type == 0 : NEW_LINE INDENT inp = open ( ' sample . in ' , ' r ' ) NEW_LINE DEDENT elif type == 1 : NEW_LINE INDENT inp = open ( ' % s - small . in ' % ( task , ) ) NEW_LINE DEDENT else : NEW_LINE INDENT inp = open ( ' % s - large . in ' % ( task ) , ) NEW_LINE DEDENT outp = open ( ' % s . out ' % ( task , ) , ' w ' ) NEW_LINE T = int ( inp . readline ( ) [ : - 1 ] ) NEW_LINE for t in range ( T ) : NEW_LINE INDENT N = int ( inp . readline ( ) [ : - 1 ] ) NEW_LINE edges = [ - 1 for i in range ( N ) ] NEW_LINE revedges = [ list ( ) for i in range ( N ) ] NEW_LINE st = inp . readline ( ) [ : - 1 ] . split ( ) NEW_LINE def dfs ( v ) : NEW_LINE INDENT anses = [ 0 ] NEW_LINE for v2 in revedges [ v ] : NEW_LINE INDENT anses . append ( dfs ( v2 ) + 1 ) NEW_LINE DEDENT return max ( anses ) NEW_LINE DEDENT for j , a in zip ( range ( N ) , st ) : NEW_LINE INDENT a = int ( a ) - 1 NEW_LINE edges [ j ] = a NEW_LINE revedges [ a ] . append ( j ) NEW_LINE DEDENT pairs = set ( ) NEW_LINE loncyc = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT used = [ - 1 for i in range ( N ) ] NEW_LINE cur = i NEW_LINE curs = 0 NEW_LINE while used [ cur ] == - 1 : NEW_LINE INDENT used [ cur ] = curs NEW_LINE curs += 1 NEW_LINE cur = edges [ cur ] NEW_LINE DEDENT if curs - used [ cur ] == 2 : NEW_LINE INDENT pairs . add ( cur ) NEW_LINE DEDENT loncy"],"references":["from collections import defaultdict NEW_LINE from heapq import nlargest NEW_LINE def maxSize ( adj , node , parent ) : NEW_LINE INDENT children = adj [ node ] - { parent } NEW_LINE if len ( children ) == 1 : return 1 NEW_LINE return sum ( nlargest ( 2 , ( maxSize ( adj , child , node ) for child in children ) ) ) + 1 NEW_LINE DEDENT for t in range ( int ( input ( ) ) ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE adj = defaultdict ( set ) NEW_LINE for _ in range ( N - 1 ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE adj [ a ] . add ( b ) NEW_LINE adj [ b ] . add ( a ) NEW_LINE DEDENT result = N - max ( maxSize ( adj , root , None ) for root in range ( 1 , N + 1 ) ) NEW_LINE assert 0 <= result <= N NEW_LINE print ( ' Case ▁ # { } : ▁ { } ' . format ( t + 1 , result ) ) NEW_LINE DEDENT","from sys import stdin NEW_LINE import sys NEW_LINE sys . setrecursionlimit ( 100000 ) NEW_LINE tt = stdin . readline ( ) NEW_LINE tt = eval ( tt ) NEW_LINE edge = [ ] NEW_LINE visit = set ( ) NEW_LINE def dfs ( i ) : NEW_LINE INDENT global edge NEW_LINE global visit NEW_LINE visit . add ( i ) NEW_LINE sum0 = 0 NEW_LINE sum1 = 1 NEW_LINE be = [ ] NEW_LINE for h in edge [ i ] : NEW_LINE INDENT if not h in visit : NEW_LINE INDENT ret = dfs ( h ) NEW_LINE sum0 += ret [ 1 ] NEW_LINE sum1 += ret [ 1 ] NEW_LINE be . append ( ret [ 1 ] - ret [ 0 ] ) NEW_LINE DEDENT DEDENT be = sorted ( be ) NEW_LINE if len ( be ) == 0 : NEW_LINE INDENT return ( 0 , 1 ) NEW_LINE DEDENT elif len ( be ) == 1 : NEW_LINE INDENT return ( sum1 - 1 , sum1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ll = len ( be ) NEW_LINE return ( sum0 - be [ ll - 1 ] - be [ ll - 2 ] , sum1 ) NEW_LINE DEDENT DEDENT for cc in range ( 1 , tt + 1 ) : NEW_LINE INDENT tmp = stdin . readline ( ) NEW_LINE n = eval ( tmp ) NEW_LINE edge = [ ] NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT edge . append ( [ ] ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT tmp = stdin . readline ( ) NEW_LINE tmp = tmp . split ( ) NEW_LINE j = eval ( tmp [ 0 ] ) NEW_LINE k = eval ( tmp [ 1 ] ) NEW_LINE edge [ j ] . append ( k ) NEW_LINE edge [ k ] . append ( j ) NEW_LINE DEDENT res = n NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT visit = set ( ) NEW_LINE tmp = dfs ( i ) NEW_LINE if tmp [ 0 ] < res : NEW_LINE INDENT res = tmp [ 0 ] NEW_LINE DEDENT DEDENT print \" Case ▁ # % d : ▁ % d \" % ( cc , res ) NEW_LINE DEDENT","import sys , collections NEW_LINE def read ( ) : sys . stdout . flush ( ) ; return sys . stdin . readline ( ) . strip ( ) NEW_LINE def max_size_of_full_tree ( tree , root , seen ) : NEW_LINE INDENT seen = seen | set ( [ root ] ) NEW_LINE subtree_sizes = [ ] NEW_LINE for neighbor in tree [ root ] : NEW_LINE INDENT if neighbor in seen : continue NEW_LINE subsize = max_size_of_full_tree ( tree , neighbor , seen ) NEW_LINE subtree_sizes . append ( subsize ) NEW_LINE DEDENT if len ( subtree_sizes ) < 2 : NEW_LINE INDENT return 1 NEW_LINE DEDENT subtree_sizes . sort ( reverse = True ) NEW_LINE return 1 + subtree_sizes [ 0 ] + subtree_sizes [ 1 ] NEW_LINE DEDENT tests = int ( read ( ) ) NEW_LINE for test in xrange ( tests ) : NEW_LINE INDENT N = int ( read ( ) ) NEW_LINE tree = collections . defaultdict ( list ) NEW_LINE for i in xrange ( N - 1 ) : NEW_LINE INDENT a , b = read ( ) . split ( \" ▁ \" ) NEW_LINE a , b = int ( a ) , int ( b ) NEW_LINE tree [ a ] += [ b ] NEW_LINE tree [ b ] += [ a ] NEW_LINE DEDENT biggest_full_tree_size = 1 NEW_LINE for node in tree : NEW_LINE INDENT size = max_size_of_full_tree ( tree , node , set ( ) ) NEW_LINE if size > biggest_full_tree_size : NEW_LINE INDENT biggest_full_tree_size = size NEW_LINE DEDENT DEDENT answer = N - biggest_full_tree_size NEW_LINE print \" Case ▁ # % d : ▁ % d \" % ( test + 1 , answer ) NEW_LINE DEDENT","def readint ( ) : return int ( raw_input ( ) ) NEW_LINE def readarray ( f ) : return map ( f , raw_input ( ) . split ( ) ) NEW_LINE _T = readint ( ) NEW_LINE for _t in range ( _T ) : NEW_LINE INDENT print ' Case ▁ # % i : ' % ( _t + 1 ) , NEW_LINE N = readint ( ) NEW_LINE adj = [ [ ] for i in range ( N ) ] NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT a , b = readarray ( int ) NEW_LINE a -= 1 NEW_LINE b -= 1 NEW_LINE adj [ a ] . append ( b ) NEW_LINE adj [ b ] . append ( a ) NEW_LINE DEDENT best = N - 1 NEW_LINE for r in range ( N ) : NEW_LINE INDENT P = [ - 1 ] * N NEW_LINE C = [ [ ] for i in range ( N ) ] NEW_LINE L = [ ] NEW_LINE Q = [ r ] NEW_LINE while len ( Q ) > 0 : NEW_LINE INDENT i = Q . pop ( ) NEW_LINE l = True NEW_LINE for v in adj [ i ] : NEW_LINE INDENT if v != P [ i ] : NEW_LINE INDENT P [ v ] = i NEW_LINE Q . append ( v ) NEW_LINE C [ i ] . append ( v ) NEW_LINE l = False NEW_LINE DEDENT DEDENT if l : NEW_LINE INDENT L . append ( i ) NEW_LINE DEDENT DEDENT keep = [ 1 ] * N NEW_LINE while len ( L ) > 0 : NEW_LINE INDENT i = L . pop ( ) NEW_LINE if len ( C [ i ] ) > 1 : NEW_LINE INDENT best1 = - 1 NEW_LINE best2 = - 1 NEW_LINE for c in C [ i ] : NEW_LINE INDENT if keep [ c ] > best1 : NEW_LINE INDENT best2 = best1 NEW_LINE best1 = keep [ c ] NEW_LINE DEDENT elif keep [ c ] > best2 : NEW_LINE INDENT best2 = keep [ c ] NEW_LINE DEDENT DEDENT keep [ i ] = best1 + best2 + 1 NEW_LINE DEDENT if P [ i ] > - 1 : NEW_LINE INDENT L . append ( P [ i ] ) NEW_LINE DEDENT DEDENT best = min ( best , N - keep [ r ] ) NEW_LINE DEDENT print best NEW_LINE DEDENT","def search ( tree , root , parent ) : NEW_LINE INDENT children = tree [ root ] . copy ( ) NEW_LINE if parent != 0 : NEW_LINE INDENT del children [ children . index ( parent ) ] NEW_LINE DEDENT if len ( children ) <= 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT firstlarge = 0 NEW_LINE secondlarge = 0 NEW_LINE for child in children : NEW_LINE INDENT result = search ( tree , child , root ) NEW_LINE if result > firstlarge : NEW_LINE INDENT secondlarge = firstlarge NEW_LINE firstlarge = result NEW_LINE DEDENT elif result > secondlarge : NEW_LINE INDENT secondlarge = result NEW_LINE DEDENT DEDENT return firstlarge + secondlarge + 1 NEW_LINE DEDENT fin = open ( ' B - large . in ' , ' r ' ) NEW_LINE fout = open ( ' out . txt ' , ' w ' ) NEW_LINE t = int ( fin . readline ( ) ) NEW_LINE for casecount in range ( 1 , t + 1 ) : NEW_LINE INDENT n = int ( fin . readline ( ) ) NEW_LINE tree = [ [ ] for x in range ( 0 , n + 1 ) ] NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT xi , yi = map ( int , fin . readline ( ) . split ( ) ) NEW_LINE tree [ xi ] . append ( yi ) NEW_LINE tree [ yi ] . append ( xi ) NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT temp = search ( tree , i , 0 ) NEW_LINE if temp > result : NEW_LINE INDENT result = temp NEW_LINE DEDENT DEDENT fout . write ( ' Case ▁ # % d : ▁ % d \\n ' % ( casecount , n - result ) ) NEW_LINE DEDENT fin . close ( ) NEW_LINE fout . close ( ) NEW_LINE"],"bleu":0.4370402436171226,"rouge_l":0.4336322917891541}
{"id":148,"predictions":["import sys NEW_LINE def main ( ) : NEW_LINE INDENT f = open ( sys . argv [ 1 ] ) NEW_LINE out = open ( ' C - small - attempt0 . out ' , ' w ' ) NEW_LINE T = int ( f . readline ( ) [ 0 ] ) NEW_LINE for case in range ( 1 , T + 1 ) : NEW_LINE INDENT N = int ( f . readline ( ) . strip ( ) ) NEW_LINE S = [ ] NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT S . append ( int ( f . readline ( ) . strip ( ) ) ) NEW_LINE DEDENT P = [ [ int ( x ) for x in f . readline ( ) . strip ( ) . split ( ) ] ) NEW_LINE M = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT if S [ i ] == j : NEW_LINE INDENT P [ i ] [ j ] = P [ i ] [ j ] + S [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT f . write ( ' Case ▁ # % d : ▁ % d \\n ' % ( case + 1 , j ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"references":["ops = [ int . __add__ , int . __sub__ ] NEW_LINE ugly_count = 0 NEW_LINE def is_ugly ( num ) : NEW_LINE INDENT return num % 2 == 0 or num % 3 == 0 or num % 5 == 0 or num % 7 == 0 NEW_LINE DEDENT def count_ugly ( left_slice_num , right_slice , op ) : NEW_LINE INDENT global ugly_count NEW_LINE if is_ugly ( op ( left_slice_num , int ( right_slice ) ) ) : NEW_LINE INDENT ugly_count += 1 NEW_LINE DEDENT if len ( right_slice ) > 1 : NEW_LINE INDENT for i in xrange ( - 1 , - len ( right_slice ) , - 1 ) : NEW_LINE INDENT for sub_op in ops : NEW_LINE INDENT count_ugly ( op ( left_slice_num , int ( right_slice [ : i ] ) ) , right_slice [ i : ] , sub_op ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT testsCount = int ( raw_input ( ) ) NEW_LINE for i in xrange ( testsCount ) : NEW_LINE INDENT ugly_count = 0 NEW_LINE count_ugly ( 0 , raw_input ( ) , int . __add__ ) NEW_LINE print \" Case ▁ # % d : ▁ % d \" % ( i + 1 , ugly_count ) NEW_LINE DEDENT DEDENT","FNAME = \" B - small - attempt0 . in \" NEW_LINE PRIMDIV = 2 , 3 , 5 , 7 NEW_LINE class Case ( object ) : NEW_LINE INDENT def __init__ ( self , num ) : NEW_LINE INDENT self . num = num NEW_LINE DEDENT DEDENT def isugly ( n ) : NEW_LINE INDENT for i in PRIMDIV : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def getvals ( s ) : NEW_LINE INDENT vals = [ ] NEW_LINE for i in xrange ( len ( s ) ) : NEW_LINE INDENT v = int ( s [ : i + 1 ] ) NEW_LINE if not s [ i + 1 : ] : NEW_LINE INDENT prevvals = [ 0 ] NEW_LINE vals . append ( v ) NEW_LINE DEDENT else : NEW_LINE INDENT prevvals = getvals ( s [ i + 1 : ] ) NEW_LINE vals . extend ( [ v + val for val in prevvals ] ) NEW_LINE vals . extend ( [ v - val for val in prevvals ] ) NEW_LINE DEDENT DEDENT return vals NEW_LINE DEDENT def getnugly ( s ) : NEW_LINE INDENT return len ( [ val for val in getvals ( s ) if isugly ( val ) ] ) NEW_LINE DEDENT def parse ( lines ) : NEW_LINE INDENT cases = [ ] NEW_LINE i = 1 NEW_LINE while i < len ( lines ) : NEW_LINE INDENT cases . append ( Case ( lines [ i ] ) ) NEW_LINE i += 1 NEW_LINE DEDENT return cases NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT lines = file ( FNAME ) . read ( ) . splitlines ( ) NEW_LINE answers = [ getnugly ( case . num ) for case in parse ( lines ) ] NEW_LINE outlines = [ \" Case ▁ # % d : ▁ % d \\n \" % ( i + 1 , answer ) for i , answer in enumerate ( answers ) ] NEW_LINE file ( FNAME + \" . out \" , \" w \" ) . writelines ( outlines ) NEW_LINE DEDENT","fin = open ( \" c . in \" , \" r \" ) NEW_LINE n = int ( fin . readline ( ) ) NEW_LINE fout = open ( \" c . out \" , \" w \" ) NEW_LINE def ugly ( n ) : NEW_LINE INDENT if n % 2 == 0 or n % 3 == 0 or n % 5 == 0 or n % 7 == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT def count ( n , k , s , pos ) : NEW_LINE INDENT if len ( n ) == 0 : NEW_LINE INDENT return ugly ( k + s ) NEW_LINE DEDENT a = 0 NEW_LINE if pos : NEW_LINE INDENT a += count ( n [ 1 : ] , k , s * 10 + int ( n [ 0 ] ) , True ) NEW_LINE DEDENT else : NEW_LINE INDENT a += count ( n [ 1 : ] , k , s * 10 - int ( n [ 0 ] ) , False ) NEW_LINE DEDENT a += count ( n [ 1 : ] , k + s , int ( n [ 0 ] ) , True ) NEW_LINE a += count ( n [ 1 : ] , k + s , - int ( n [ 0 ] ) , False ) NEW_LINE return a NEW_LINE DEDENT for i in xrange ( 1 , n + 1 ) : NEW_LINE INDENT d = fin . readline ( ) . strip ( ) NEW_LINE c = count ( d [ 1 : ] , 0 , int ( d [ 0 ] ) , True ) NEW_LINE print c NEW_LINE print >> fout , \" Case ▁ # % d : ▁ % d \" % ( i , c ) NEW_LINE DEDENT","def process ( digits ) : NEW_LINE INDENT table = [ [ ] , [ int ( int ( digits [ 0 ] ) == k ) for k in xrange ( 210 ) ] ] NEW_LINE for i in xrange ( 2 , len ( digits ) + 1 ) : NEW_LINE INDENT row = [ ] NEW_LINE for j in xrange ( 210 ) : NEW_LINE INDENT num = int ( int ( digits [ : i ] ) % 210 == j ) NEW_LINE for k in xrange ( 1 , i ) : NEW_LINE INDENT rhs = int ( digits [ k : i ] ) NEW_LINE num += table [ k ] [ ( j + rhs ) % 210 ] NEW_LINE num += table [ k ] [ ( j - rhs ) % 210 ] NEW_LINE DEDENT row . append ( num ) NEW_LINE DEDENT table . append ( row ) NEW_LINE DEDENT return sum ( table [ - 1 ] [ k ] for k in xrange ( 210 ) if k % 2 == 0 or k % 3 == 0 or k % 5 == 0 or k % 7 == 0 ) NEW_LINE DEDENT import sys NEW_LINE next = iter ( sys . stdin ) . next NEW_LINE ncases = int ( next ( ) ) NEW_LINE for i in xrange ( ncases ) : NEW_LINE INDENT digits = next ( ) . strip ( ) NEW_LINE numuglys = process ( digits ) NEW_LINE print ' Case ▁ # % d : ▁ % d ' % ( i + 1 , numuglys ) NEW_LINE sys . stdout . flush ( ) NEW_LINE DEDENT","import sys NEW_LINE from collections import defaultdict NEW_LINE def update_counters ( counters , new_digit ) : NEW_LINE INDENT new_counters = defaultdict ( int ) NEW_LINE if len ( counters ) == 0 : NEW_LINE INDENT new_counters [ ( new_digit , 10 , 0 ) ] = 1 NEW_LINE DEDENT for k in counters : NEW_LINE INDENT new_k = ( k [ 0 ] + new_digit * k [ 1 ] , k [ 1 ] * 10 , k [ 2 ] ) NEW_LINE new_counters [ new_k ] += counters [ k ] NEW_LINE new_k = ( new_digit , 10 , ( k [ 2 ] + k [ 0 ] ) % 210 ) NEW_LINE new_counters [ new_k ] += counters [ k ] NEW_LINE new_k = ( new_digit , 10 , ( k [ 2 ] - k [ 0 ] ) % 210 ) NEW_LINE new_counters [ new_k ] += counters [ k ] NEW_LINE DEDENT return new_counters NEW_LINE DEDENT def count_it ( digits_array ) : NEW_LINE INDENT counters = { } NEW_LINE for d in reversed ( digits_array ) : NEW_LINE INDENT counters = update_counters ( counters , int ( d ) ) NEW_LINE DEDENT return counters NEW_LINE DEDENT def is_key_ugly ( k ) : NEW_LINE INDENT sigma = k [ 0 ] + k [ 2 ] NEW_LINE if sigma % 2 == 0 or sigma % 3 == 0 or sigma % 5 == 0 or sigma % 7 == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def analyze_counters ( counters ) : NEW_LINE INDENT ugly_count = 0 NEW_LINE for k in counters : NEW_LINE INDENT if is_key_ugly ( k ) : NEW_LINE INDENT ugly_count += counters [ k ] NEW_LINE DEDENT DEDENT return ugly_count NEW_LINE DEDENT def do_it_all ( digits ) : NEW_LINE INDENT return analyze_counters ( count_it ( digits ) ) NEW_LINE DEDENT import psyco NEW_LINE psyco . full ( ) NEW_LINE lines = open ( sys . argv [ 1 ] ) . readlines ( ) NEW_LINE prob_count = int ( lines [ 0 ] ) NEW_LINE lines = lines [ 1 : ] NEW_LINE assert ( len ( lines ) == prob_count ) NEW_LINE for i , l in enumerate ( lines ) : NEW_LINE INDENT print \" Case ▁ # % d : ▁ % d \" % ( i + 1 , do_it_all ( l . strip ( ) ) ) NEW_LINE DEDENT"],"bleu":0.48014412267572665,"rouge_l":0.3770582633538222}
{"id":149,"predictions":["import sys NEW_LINE filename = sys . argv [ 1 ] NEW_LINE inputfile = file ( filename , ' r ' ) NEW_LINE numcases = int ( inputfile . readline ( ) . strip ( ) ) NEW_LINE for case in range ( 1 , numcases + 1 ) : NEW_LINE INDENT K = int ( inputfile . readline ( ) . strip ( ) ) NEW_LINE data = map ( int , inputfile . readline ( ) . strip ( ) . split ( \" ▁ \" ) ) NEW_LINE n = data [ 0 ] NEW_LINE dis = data [ 1 : ] NEW_LINE cards = range ( K ) NEW_LINE remainingcards = range ( K ) NEW_LINE remainingcardpos = 0 NEW_LINE for cardvalue in range ( K ) : NEW_LINE INDENT remainingcardpos = ( cardvalue + remainingcardpos ) % len ( remainingcards ) NEW_LINE card = remainingcards [ remainingcardpos ] NEW_LINE cards [ card ] = cardvalue + 1 NEW_LINE del remainingcards [ remainingcardpos ] NEW_LINE DEDENT sys . stdout . write ( \" Case ▁ # % d : \" % case ) NEW_LINE for di in dis : NEW_LINE INDENT sys . stdout . write ( \" ▁ % d \" % cards [ di - 1 ] ) NEW_LINE DEDENT sys . stdout . write ( \" \\n \" ) NEW_LINE DEDENT"],"references":["inp_file = file ( \" B - small . in \" ) NEW_LINE out_file = file ( \" B - small . out \" , \" w \" ) NEW_LINE def solve ( line ) : NEW_LINE INDENT A , B , P = [ int ( c1 ) for c1 in line . split ( \" ▁ \" ) ] NEW_LINE numbers = range ( A , B + 1 ) NEW_LINE sets = range ( B - A + 1 ) NEW_LINE for c1 in primes : NEW_LINE INDENT if c1 < P : continue NEW_LINE if c1 > B \/ 2 + 1 : break NEW_LINE same = [ ] NEW_LINE for c2 in numbers : NEW_LINE INDENT if not c2 % c1 : same . append ( c2 - A ) NEW_LINE DEDENT sets = merge_sets ( sets , same ) NEW_LINE DEDENT counted = [ ] NEW_LINE c2 = 0 NEW_LINE for c1 in sets : NEW_LINE INDENT if not c1 in counted : NEW_LINE INDENT counted . append ( c1 ) NEW_LINE c2 += 1 NEW_LINE DEDENT DEDENT return str ( c2 ) NEW_LINE DEDENT def merge_sets ( sets , same ) : NEW_LINE INDENT to_change = [ sets [ c1 ] for c1 in same ] NEW_LINE for c1 in range ( len ( sets ) ) : NEW_LINE INDENT if sets [ c1 ] in to_change : NEW_LINE INDENT sets [ c1 ] = to_change [ 0 ] NEW_LINE DEDENT DEDENT return sets NEW_LINE DEDENT p_file = file ( \" primes1000 . txt \" ) NEW_LINE primes = [ int ( c1 ) for c1 in p_file . read ( ) . split ( \" \\n \" ) ] NEW_LINE p_file . close ( ) NEW_LINE num = int ( inp_file . readline ( ) ) NEW_LINE for case in range ( num ) : NEW_LINE INDENT line = inp_file . readline ( ) [ : - 1 ] NEW_LINE out_file . write ( \" Case ▁ # % s : ▁ \" % ( case + 1 ) + solve ( line ) + \" \\n \" ) NEW_LINE DEDENT inp_file . close ( ) NEW_LINE out_file . close ( ) NEW_LINE","from time import time NEW_LINE import psyco NEW_LINE import re NEW_LINE import math NEW_LINE psyco . full ( ) NEW_LINE fin = open ( \"2 _ input . txt \" , \" r \" ) NEW_LINE fout = open ( \"2 _ output . txt \" , \" w \" ) NEW_LINE cases = int ( fin . readline ( ) ) NEW_LINE cached = { } NEW_LINE def isprime ( n ) : NEW_LINE INDENT global cached NEW_LINE if n in cached : NEW_LINE INDENT return cached [ n ] NEW_LINE DEDENT if n == 2 : return True NEW_LINE for x in range ( 2 , int ( n ** 0.5 ) + 1 ) : NEW_LINE INDENT if n % x == 0 : NEW_LINE INDENT cached [ n ] = False NEW_LINE return False NEW_LINE DEDENT DEDENT cached [ n ] = True NEW_LINE return True NEW_LINE DEDENT def check_for_p ( a , b , p ) : NEW_LINE INDENT for num in range ( p , b ) : NEW_LINE INDENT if isprime ( num ) and ( a % num == 0 and b % num == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT t0 = time ( ) NEW_LINE for casenr in range ( cases ) : NEW_LINE INDENT ( A , B , P ) = map ( int , [ e for e in fin . readline ( ) . split ( ) ] ) NEW_LINE n = B - A NEW_LINE set_id = { } NEW_LINE for i in range ( A , B + 1 ) : NEW_LINE INDENT set_id [ i ] = i - A NEW_LINE DEDENT set_count = n + 1 NEW_LINE for p0 in range ( A , B + 1 ) : NEW_LINE INDENT for p1 in range ( p0 + 1 , B + 1 ) : NEW_LINE INDENT if ( set_id [ p0 ] == set_id [ p1 ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT if check_for_p ( p0 , p1 , P ) : NEW_LINE INDENT set_count -= 1 NEW_LINE ex = set_id [ p1 ] NEW_LINE for k in set_id . keys ( ) : NEW_LINE INDENT if set_id [ k ] == ex : NEW_LINE INDENT set_id [ k ] = set_id [ p0 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT print set_count NEW_LINE fout . write ( \" Case ▁ # % d : ▁ % d \\n \" % ( casenr + 1 , set_count ) ) NEW_LINE DEDENT","from sys import stdin NEW_LINE from collections import deque NEW_LINE MAX = 1000000 NEW_LINE primes = set ( xrange ( 2 , MAX ) , ) NEW_LINE for p in xrange ( 2 , MAX ) : NEW_LINE INDENT if p in primes : NEW_LINE INDENT for i in xrange ( 2 * p , MAX , p ) : NEW_LINE INDENT if i in primes : NEW_LINE INDENT primes . remove ( i ) NEW_LINE DEDENT DEDENT DEDENT DEDENT tno = int ( stdin . readline ( ) ) NEW_LINE for j in xrange ( tno ) : NEW_LINE INDENT A , B , P = map ( long , stdin . readline ( ) . strip ( ) . split ( ) ) NEW_LINE tab = [ - 1 ] * ( B - A + 1 ) NEW_LINE pr = [ x for x in primes if x >= P and x <= B - A ] NEW_LINE hm = 0 NEW_LINE ed = [ [ ] for _ in xrange ( 0 , B - A + 1 ) ] NEW_LINE for p in pr : NEW_LINE INDENT f = ( ( A + p - 1 ) \/\/ p ) * p - A NEW_LINE for x in xrange ( f , B - A + 1 , p ) : NEW_LINE INDENT if x != f : NEW_LINE INDENT ed [ x - p ] . append ( x ) NEW_LINE ed [ x ] . append ( x - p ) NEW_LINE DEDENT DEDENT DEDENT for i in xrange ( B - A + 1 ) : NEW_LINE INDENT if tab [ i ] != - 1 : NEW_LINE INDENT continue NEW_LINE DEDENT q = deque ( ( i , ) ) NEW_LINE tab [ i ] = - 1 NEW_LINE while q : NEW_LINE INDENT x = q . popleft ( ) NEW_LINE for e in ed [ x ] : NEW_LINE INDENT if tab [ e ] == - 1 : NEW_LINE INDENT tab [ e ] = i NEW_LINE q . append ( e ) NEW_LINE DEDENT DEDENT DEDENT hm += 1 NEW_LINE del q NEW_LINE DEDENT del pr NEW_LINE del ed NEW_LINE print \" Case ▁ # % d : ▁ % d \" % ( j + 1 , hm , ) NEW_LINE DEDENT","def dofile ( infile , outfile ) : NEW_LINE INDENT instr = file ( infile ) . read ( ) NEW_LINE ostr = dostr ( instr ) NEW_LINE file ( outfile , \" w \" ) . write ( ostr ) NEW_LINE DEDENT def eat ( l , n ) : NEW_LINE INDENT return l [ : n ] , l [ n : ] NEW_LINE DEDENT def dostr ( dat ) : NEW_LINE INDENT dat = dat . splitlines ( ) NEW_LINE N = int ( dat [ 0 ] ) NEW_LINE dat = dat [ 1 : ] NEW_LINE results = [ ] NEW_LINE for i in xrange ( N ) : NEW_LINE INDENT A , B , P = map ( int , dat [ 0 ] . split ( ' ▁ ' ) ) NEW_LINE dat = dat [ 1 : ] NEW_LINE res = solve ( A , B , P , i + 1 ) NEW_LINE results . append ( res ) NEW_LINE DEDENT return \" \\n \" . join ( results ) NEW_LINE DEDENT def isPrime ( x ) : NEW_LINE INDENT for i in xrange ( 2 , x ) : NEW_LINE INDENT if x % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def solve ( A , B , P , ind ) : NEW_LINE INDENT primes = [ x for x in xrange ( P , B + 1 ) if isPrime ( x ) ] NEW_LINE sets = [ set ( [ x , ] ) for x in xrange ( A , B + 1 ) ] NEW_LINE for p in primes : NEW_LINE INDENT sets2 = [ ] NEW_LINE newset = set ( ) NEW_LINE for s in sets : NEW_LINE INDENT merge = True NEW_LINE for i in s : NEW_LINE INDENT if i % p == 0 : NEW_LINE INDENT newset = newset . union ( s ) NEW_LINE merge = False NEW_LINE break NEW_LINE DEDENT DEDENT if merge : NEW_LINE INDENT sets2 . append ( s ) NEW_LINE DEDENT DEDENT if len ( newset ) > 0 : NEW_LINE INDENT sets2 . append ( newset ) NEW_LINE DEDENT sets = sets2 NEW_LINE DEDENT print sets NEW_LINE res = len ( sets ) NEW_LINE return \" Case ▁ # % d : ▁ % d \" % ( ind , res ) NEW_LINE DEDENT","import sys NEW_LINE def getLine ( ) : NEW_LINE INDENT global fin NEW_LINE line = fin . readline ( ) NEW_LINE if line [ - 1 ] == \" \\n \" : NEW_LINE INDENT line = line [ : - 1 ] NEW_LINE DEDENT return line NEW_LINE DEDENT part = [ ] NEW_LINE def representative ( x ) : NEW_LINE INDENT if part [ x ] == x : NEW_LINE INDENT return x NEW_LINE DEDENT res = representative ( part [ x ] ) NEW_LINE part [ x ] = res NEW_LINE return res NEW_LINE DEDENT def union ( x , y ) : NEW_LINE INDENT x = representative ( x ) NEW_LINE y = representative ( y ) NEW_LINE part [ x ] = y NEW_LINE DEDENT def primes ( upTo ) : NEW_LINE INDENT if upTo < 2 : NEW_LINE INDENT return [ ] NEW_LINE DEDENT res = [ 2 ] NEW_LINE for i in range ( 3 , upTo + 1 , 2 ) : NEW_LINE INDENT if all ( i % p != 0 for p in res ) : NEW_LINE INDENT res . append ( i ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT global part NEW_LINE a , b , p = map ( int , getLine ( ) . split ( ) ) NEW_LINE part = range ( b - a + 1 ) NEW_LINE pr = primes ( b + 1 ) NEW_LINE for f in pr : NEW_LINE INDENT if f >= p : NEW_LINE INDENT for i in range ( ( a + f + f - 1 ) \/ f * f , b + 1 , f ) : NEW_LINE INDENT union ( i - f - a , i - a ) NEW_LINE DEDENT DEDENT DEDENT s = set ( ) NEW_LINE for i in range ( len ( part ) ) : NEW_LINE INDENT s . add ( representative ( i ) ) NEW_LINE DEDENT return str ( len ( s ) ) NEW_LINE DEDENT if len ( sys . argv ) != 2 : NEW_LINE INDENT print \" Specify ▁ input ▁ file \" NEW_LINE exit ( 1 ) NEW_LINE DEDENT fin = open ( sys . argv [ 1 ] ) NEW_LINE n = int ( getLine ( ) ) NEW_LINE fout = open ( \" out \" , \" wt \" ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print \" Solving \" , i NEW_LINE fout . write ( \" Case ▁ # % s : ▁ \" % i ) NEW_LINE fout . write ( solve ( ) ) NEW_LINE fout . write ( \" \\n \" ) NEW_LINE DEDENT fout . close ( ) NEW_LINE"],"bleu":0.2371818905170214,"rouge_l":0.3352540024549444}
{"id":150,"predictions":["class Point : NEW_LINE INDENT def __init__ ( self , x , y ) : NEW_LINE INDENT self . x = x NEW_LINE self . y = y NEW_LINE DEDENT def __sub__ ( self , x , y ) : NEW_LINE INDENT return self . x * self . y + self . y NEW_LINE DEDENT def __init__ ( self , self ) : NEW_LINE INDENT self . x = self . x - self . y NEW_LINE self . y = self . y NEW_LINE DEDENT def erase ( self , x , y ) : NEW_LINE INDENT self . x = self . x NEW_LINE self . y = self . y NEW_LINE DEDENT return self . x + self . y NEW_LINE DEDENT def self ( self , x , y ) : NEW_LINE INDENT return self . x * self . y + self . x * self . y NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE x = x * ( 0.5 ) NEW_LINE y = y * ( y + x * y ) NEW_LINE if x . y > 0 : NEW_LINE INDENT t = self . x * ( x - x ) NEW_LINE DEDENT return t NEW_LINE DEDENT defcopy ( p , x , y ) : NEW_LINE INDENT return self . x * ( x - p ) + y * ( y - p ) NEW_LINE DEDENT DEDENT defcopy ( self , x , y ) : NEW_LINE INDENT return self . Vector ( self . x , y ) NEW_LINE DEDENT main ( ) NEW_LINE"],"references":["import math NEW_LINE eps = 0.0000001 NEW_LINE def Solve ( H , W , D , c ) : NEW_LINE INDENT angles = [ ] NEW_LINE W = W - 2 NEW_LINE H = H - 2 NEW_LINE found = False NEW_LINE y = - 0.5 NEW_LINE for line in c : NEW_LINE INDENT x = - 0.5 NEW_LINE for char in line : NEW_LINE INDENT if char == \" X \" : NEW_LINE INDENT found = True NEW_LINE break NEW_LINE DEDENT x = x + 1 NEW_LINE DEDENT if found : NEW_LINE INDENT break NEW_LINE DEDENT y = y + 1 NEW_LINE DEDENT mx = x NEW_LINE my = y NEW_LINE co = 0 NEW_LINE for xcopy in range ( - 50 , 50 ) : NEW_LINE INDENT for ycopy in range ( - 50 , 50 ) : NEW_LINE INDENT if ( xcopy == 0 and ycopy == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if xcopy % 2 != 0 : NEW_LINE INDENT mx = ( xcopy + 1 ) * ( W ) - x NEW_LINE DEDENT else : NEW_LINE INDENT mx = xcopy * ( W ) + x NEW_LINE DEDENT if ycopy % 2 != 0 : NEW_LINE INDENT my = ( ycopy + 1 ) * ( H ) - y NEW_LINE DEDENT else : NEW_LINE INDENT my = ycopy * ( H ) + y NEW_LINE DEDENT dist = math . sqrt ( ( mx - x ) ** 2 + ( my - y ) ** 2 ) NEW_LINE if dist <= D : NEW_LINE INDENT a = 0 NEW_LINE a = math . atan2 ( ( my - y ) , ( mx - x ) ) NEW_LINE if not hasAngle ( a , angles ) : NEW_LINE INDENT co = co + 1 NEW_LINE angles . append ( a ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return co NEW_LINE DEDENT def hasAngle ( a , angles ) : NEW_LINE INDENT for an in angles : NEW_LINE INDENT if abs ( an - a ) < eps : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT f = open ( ' d . in ' ) NEW_LINE T = int ( f . readline ( ) ) NEW_LINE for t in range ( T ) : NEW_LINE INDENT H , W , D = map ( int , f . readline ( ) . split ( ) ) NEW_LINE c = [ ] NEW_LINE for x in range ( H ) : NEW_LINE INDENT c . append ( f . readline ( ) ) NEW_LINE DEDENT result = Solve ( H , W , D , c ) NEW_LINE print \" Case ▁ # % d : ▁ % s \" % ( t + 1 , result ) NEW_LINE DEDENT","import d NEW_LINE ri = raw_input NEW_LINE t = int ( ri ( ) ) NEW_LINE for case in xrange ( 1 , t + 1 ) : NEW_LINE INDENT h , w , ddd = map ( int , ri ( ) . split ( ) ) NEW_LINE X = list ( ) NEW_LINE for i in xrange ( h ) : NEW_LINE INDENT line = ri ( ) NEW_LINE X . append ( line ) NEW_LINE DEDENT print ' Case ▁ # % d : ▁ % d ' % ( case , d . blah ( ddd , X ) ) NEW_LINE DEDENT","import fractions NEW_LINE def distance2 ( p ) : NEW_LINE INDENT return p [ 0 ] ** 2 + p [ 1 ] ** 2 NEW_LINE DEDENT def normalize ( p ) : NEW_LINE INDENT g = fractions . gcd ( abs ( p [ 0 ] ) , abs ( p [ 1 ] ) ) NEW_LINE return p [ 0 ] \/ g , p [ 1 ] \/ g NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT H , W , D = map ( int , raw_input ( ) . split ( ) ) NEW_LINE for j in xrange ( H ) : NEW_LINE INDENT raw = raw_input ( ) NEW_LINE for i in xrange ( W ) : NEW_LINE INDENT if raw [ i ] == ' X ' : NEW_LINE INDENT place = ( i , j ) NEW_LINE DEDENT DEDENT DEDENT dx = ( W - place [ 0 ] - 1 ) * 2 - 1 NEW_LINE dy = ( H - place [ 1 ] - 1 ) * 2 - 1 NEW_LINE H2 = ( H - 2 ) * 2 NEW_LINE W2 = ( W - 2 ) * 2 NEW_LINE D2 = D ** 2 NEW_LINE points = set ( ) NEW_LINE for j in xrange ( - ( D \/ H2 + 1 ) , D \/ H2 + 1 ) : NEW_LINE INDENT for i in xrange ( - ( D \/ W2 + 1 ) , D \/ W2 + 1 ) : NEW_LINE INDENT p0 = ( i * W2 , j * H2 ) NEW_LINE if p0 != ( 0 , 0 ) and distance2 ( p0 ) <= D2 : NEW_LINE INDENT points . add ( normalize ( p0 ) ) NEW_LINE DEDENT p1 = ( i * W2 + dx , j * H2 ) NEW_LINE if distance2 ( p1 ) <= D2 : NEW_LINE INDENT points . add ( normalize ( p1 ) ) NEW_LINE DEDENT p2 = ( i * W2 , j * H2 + dy ) NEW_LINE if distance2 ( p2 ) <= D2 : NEW_LINE INDENT points . add ( normalize ( p2 ) ) NEW_LINE DEDENT p3 = ( i * W2 + dx , j * H2 + dy ) NEW_LINE if distance2 ( p3 ) <= D2 : NEW_LINE INDENT points . add ( normalize ( p3 ) ) NEW_LINE DEDENT DEDENT DEDENT return len ( points ) NEW_LINE DEDENT T = int ( raw_input ( ) ) NEW_LINE for i in range ( T ) : NEW_LINE INDENT print \" Case ▁ # % d : \" % ( i + 1 ) , solve ( ) NEW_LINE DEDENT"],"bleu":0.25573479249805126,"rouge_l":0.4883352457632733}
{"id":151,"predictions":["from __future__ import division NEW_LINE from __future__ import with_statement NEW_LINE from __future__ import print_function NEW_LINE def memoized ( func ) : NEW_LINE INDENT mem = { } NEW_LINE def wrapped ( * args ) : NEW_LINE INDENT if args not in mem : NEW_LINE INDENT mem [ args ] = func ( * args ) NEW_LINE DEDENT return mem [ args ] NEW_LINE DEDENT return wrapped NEW_LINE DEDENT TASK = \" B \" NEW_LINE from collections import Counter NEW_LINE from bisect import insort NEW_LINE print ( \" Calculation . . . \" ) NEW_LINE with open ( TASK + \" . in \" ) as infile : NEW_LINE INDENT with open ( TASK + \" . out \" , mode = \" wt \" ) as outfile : NEW_LINE INDENT cases = int ( infile . readline ( ) ) NEW_LINE for ncase in range ( cases ) : NEW_LINE INDENT print ( \" Case ▁ # { nc } \" . format ( nc = ncase + 1 ) ) NEW_LINE cards = [ int ( s ) for s in infile . readline ( ) . split ( ) ] [ 1 : ] NEW_LINE values = Counter ( cards ) NEW_LINE nums = [ int ( s ) for s in infile . readline ( ) . split ( ) ] NEW_LINE starts = [ ] NEW_LINE for i , n in enumerate ( cards ) : NEW_LINE INDENT if n > i : NEW_LINE INDENT starts [ i ] = i NEW_LINE DEDENT DEDENT DEDENT res = 0 NEW_LINE for i , p in enumerate ( nums ) : NEW_LINE INDENT res += i NEW_LINE DEDENT print ( res ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE def solve ( n , s ) : NEW_LINE INDENT cnt = 0 NEW_LINE while n > 0 : NEW_LINE INDENT m = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if s [ i ] < s [ m ] : NEW_LINE INDENT m = i NEW_LINE DEDENT DEDENT cnt += min ( m , n - 1 - m ) NEW_LINE n = n - 1 NEW_LINE del s [ m ] NEW_LINE DEDENT return cnt NEW_LINE DEDENT t = int ( sys . stdin . readline ( ) ) NEW_LINE for test_case in range ( 1 , t + 1 ) : NEW_LINE INDENT n = int ( sys . stdin . readline ( ) ) NEW_LINE s = [ int ( y ) for y in sys . stdin . readline ( ) . split ( ) ] NEW_LINE print ( ' Case ▁ # % d : ▁ % d ' % ( test_case , solve ( n , s ) ) ) NEW_LINE DEDENT","from __future__ import division NEW_LINE import sys NEW_LINE import math NEW_LINE from collections import deque NEW_LINE import itertools NEW_LINE sys . stdin = open ( ' large . in ' ) NEW_LINE sys . stdout = open ( ' large . out ' , ' w ' ) NEW_LINE def sequences ( integers ) : NEW_LINE INDENT integers = sorted ( integers ) NEW_LINE def sequences_rec ( ints ) : NEW_LINE INDENT if len ( ints ) == 1 : NEW_LINE INDENT yield ints NEW_LINE DEDENT else : NEW_LINE INDENT for s in sequences_rec ( ints [ 1 : ] ) : NEW_LINE INDENT yield ints [ : 1 ] + s NEW_LINE yield s + ints [ : 1 ] NEW_LINE DEDENT DEDENT DEDENT return sequences_rec ( integers ) NEW_LINE DEDENT def swaps ( before , after ) : NEW_LINE INDENT before = before [ : ] NEW_LINE n = 0 NEW_LINE for i , value in enumerate ( after ) : NEW_LINE INDENT while True : NEW_LINE INDENT i2 = before . index ( value ) NEW_LINE if i2 == i : NEW_LINE INDENT break NEW_LINE DEDENT before [ i2 - 1 ] , before [ i2 ] = before [ i2 ] , before [ i2 - 1 ] NEW_LINE n += 1 NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT def solve_bad ( integers ) : NEW_LINE INDENT return min ( swaps ( result , integers ) for result in sequences ( integers ) ) NEW_LINE DEDENT def solve ( integers ) : NEW_LINE INDENT start = 0 NEW_LINE end = len ( integers ) NEW_LINE swaps = 0 NEW_LINE while start != end : NEW_LINE INDENT m = min ( integers [ start : end ] ) NEW_LINE mi = integers . index ( m ) NEW_LINE to_start = mi - start NEW_LINE to_end = end - mi - 1 NEW_LINE if to_start <= to_end : NEW_LINE INDENT integers = integers [ : start ] + [ m ] + integers [ start : mi ] + integers [ mi + 1 : ] NEW_LINE start += 1 NEW_LINE swaps += to_start NEW_LINE DEDENT else : NEW_LINE INDENT integers = integers [ : mi ] + integers [ mi + 1 : end ] + [ m ] + integers [ end : ] NEW_LINE end -= 1 NEW_LINE swaps += to_end NEW_LINE DEDENT DEDENT return swaps NEW_LINE DEDENT t = int ( raw_input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( raw_input ( ) ) NEW_LINE integers = map ( int , raw_input ( ) . split ( ) ) NEW_LINE assert len ( integers ) == n NEW_LINE print \" Case ▁ # { } : ▁ { } \" . format ( i + 1 , solve ( integers ) ) NEW_LINE DEDENT","class BIT : NEW_LINE INDENT def __init__ ( self , n ) : NEW_LINE INDENT self . S = [ 0 ] * ( n + 1 ) NEW_LINE self . N = n NEW_LINE DEDENT def tot ( self , k ) : NEW_LINE INDENT i = k NEW_LINE a = 0 NEW_LINE while i > 0 : NEW_LINE INDENT a += self . S [ i ] NEW_LINE i -= ( i & - i ) NEW_LINE DEDENT return a NEW_LINE DEDENT def inc ( self , k , v ) : NEW_LINE INDENT i = k NEW_LINE while i <= self . N : NEW_LINE INDENT self . S [ i ] += v NEW_LINE i += ( i & - i ) NEW_LINE DEDENT DEDENT DEDENT def reader ( inFile ) : NEW_LINE INDENT dummy = inFile . getInts ( ) NEW_LINE return inFile . getInts ( ) NEW_LINE DEDENT from fractions import gcd NEW_LINE def solver ( nums ) : NEW_LINE INDENT sn = sorted ( nums ) NEW_LINE n = len ( nums ) NEW_LINE nl = { sn [ i ] : i for i in xrange ( n ) } NEW_LINE nums = [ nl [ i ] for i in nums ] NEW_LINE nl = { nums [ i ] : i + 1 for i in xrange ( n ) } NEW_LINE bit = BIT ( n ) NEW_LINE print n NEW_LINE for i in xrange ( n ) : NEW_LINE INDENT bit . inc ( i + 1 , 1 ) NEW_LINE DEDENT lower = 1 NEW_LINE upper = n NEW_LINE tot = 0 NEW_LINE for i in xrange ( n ) : NEW_LINE INDENT v = nl [ i ] NEW_LINE cur = bit . tot ( v ) NEW_LINE if ( cur - lower ) > ( upper - cur ) : NEW_LINE INDENT tot += upper - cur NEW_LINE bit . inc ( v + 1 , - 1 ) NEW_LINE upper -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT tot += cur - lower NEW_LINE bit . inc ( 1 , 1 ) NEW_LINE bit . inc ( v , - 1 ) NEW_LINE lower += 1 NEW_LINE DEDENT DEDENT return tot NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT from GCJ import GCJ NEW_LINE GCJ ( reader , solver , \" \/ Users \/ luke \/ gcj \/ 2014\/2 \/ b \/ \" , \" b \" ) . run ( ) NEW_LINE DEDENT","get = lambda : map ( int , raw_input ( ) . split ( ) ) NEW_LINE def memo ( f ) : NEW_LINE INDENT cache = dict ( ) NEW_LINE def wrap ( * args ) : NEW_LINE INDENT if args not in cache : NEW_LINE INDENT cache [ args ] = f ( * args ) NEW_LINE DEDENT return cache [ args ] NEW_LINE DEDENT return wrap NEW_LINE DEDENT T , = get ( ) NEW_LINE for testCase in range ( 1 , T + 1 ) : NEW_LINE INDENT N , = get ( ) NEW_LINE A = get ( ) NEW_LINE swaps = 0 NEW_LINE while A : NEW_LINE INDENT m = min ( A ) NEW_LINE i = A . index ( m ) NEW_LINE swaps += min ( i , len ( A ) - 1 - i ) NEW_LINE A . pop ( i ) NEW_LINE DEDENT print ' Case ▁ # % d : ▁ % d ' % ( testCase , swaps ) NEW_LINE DEDENT","def readline ( ) : NEW_LINE INDENT return map ( int , raw_input ( ) . strip ( ) . split ( ) ) NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT n , = readline ( ) NEW_LINE a = readline ( ) NEW_LINE m = { x : i for i , x in enumerate ( sorted ( a ) ) } NEW_LINE a = [ m [ x ] for x in a ] NEW_LINE idx = { x : i for i , x in enumerate ( a ) } NEW_LINE sw = 0 NEW_LINE for i in xrange ( n ) : NEW_LINE INDENT p = idx [ i ] NEW_LINE l = sum ( 1 for x in a [ : p ] if x > i ) NEW_LINE r = n - 1 - i - l NEW_LINE sw += min ( l , r ) NEW_LINE DEDENT return sw NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT t = int ( raw_input ( ) . strip ( ) ) NEW_LINE for i in xrange ( 1 , t + 1 ) : NEW_LINE INDENT ret = solve ( ) NEW_LINE print ' Case ▁ # { } : ' . format ( i ) , ret NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"bleu":0.39541233205204496,"rouge_l":0.4582974809803576}
{"id":152,"predictions":["import sys NEW_LINE import psyco NEW_LINE psyco . full ( ) NEW_LINE def dbg ( a ) : sys . stderr . write ( str ( a ) ) NEW_LINE def readint ( ) : return int ( raw_input ( ) ) NEW_LINE def readfloat ( ) : return float ( raw_input ( ) ) NEW_LINE def readarray ( foo ) : return [ foo ( x ) for x in raw_input ( ) . split ( ) ] NEW_LINE def run_test ( test ) : NEW_LINE INDENT C = readint ( ) NEW_LINE data = [ ] NEW_LINE for i in xrange ( C ) : NEW_LINE INDENT data . append ( [ readline ( ) for j in xrange ( C ) ] ) NEW_LINE DEDENT debug = False NEW_LINE for x in xrange ( C ) : NEW_LINE INDENT if x > 2 * T : NEW_LINE INDENT debug = True NEW_LINE if debug : continue NEW_LINE if debug : NEW_LINE INDENT print \" Case ▁ # % d : ▁ % d \" % ( x + 1 , data [ 0 ] , data [ 1 ] [ 0 ] , data [ 2 ] [ 1 ] ) NEW_LINE continue NEW_LINE DEDENT print \" Case ▁ # % d : ▁ % d \" % ( i + 1 , solve ( data ) ) NEW_LINE DEDENT DEDENT DEDENT def run_test ( data ) : NEW_LINE INDENT C = readint ( ) NEW_LINE for test in xrange ( C ) : NEW_LINE INDENT print \" % ( test + 1 , run_test ( case ) ) NEW_LINE DEDENT DEDENT def solve_test ( C , D ) : NEW_LINE INDENT N , P , S = readint ( ) NEW_LINE debug = False NEW_LINE for i in xrange ( N ) : NEW_LINE INDENT if i < 2 * N <= P : NEW_LINE INDENT print \" Case ▁ # % d : ▁ % s \" % ( test + 1 , solvetest ( ) ) NEW_LINE DEDENT DEDENT"],"references":["inf = 2 * 10 ** 20 NEW_LINE def inv ( x ) : NEW_LINE INDENT return P - int ( x ) NEW_LINE DEDENT def xl ( l ) : NEW_LINE INDENT return xrange ( len ( l ) ) NEW_LINE DEDENT debug = False NEW_LINE for case in range ( input ( ) ) : NEW_LINE INDENT print \" Case ▁ # \" + str ( case + 1 ) + \" : \" , NEW_LINE P = input ( ) NEW_LINE need = map ( inv , raw_input ( ) . split ( ) ) NEW_LINE costs = [ ] NEW_LINE for i in xrange ( P ) : NEW_LINE INDENT costs = map ( int , raw_input ( ) . split ( ) ) + costs NEW_LINE DEDENT v = [ [ inf for i in xrange ( P + 1 ) ] for j in xrange ( 2 ** ( P + 1 ) - 1 ) ] NEW_LINE if debug : print len ( v ) , 2 ** ( P + 1 ) - 1 , 2 ** P NEW_LINE leaves = 2 ** P - 1 NEW_LINE for ( i , x ) in enumerate ( need ) : NEW_LINE INDENT for j in xrange ( x , P + 1 ) : NEW_LINE INDENT v [ leaves + i ] [ j ] = 0 NEW_LINE DEDENT DEDENT for n in xrange ( leaves - 1 , - 1 , - 1 ) : NEW_LINE INDENT if debug : print n , 2 * n + 1 , 2 * n + 2 NEW_LINE for i in xrange ( P + 1 ) : NEW_LINE INDENT if i == P : NEW_LINE INDENT buy = inf NEW_LINE DEDENT else : NEW_LINE INDENT buy = v [ 2 * n + 1 ] [ i + 1 ] + v [ 2 * n + 2 ] [ i + 1 ] + costs [ n ] NEW_LINE DEDENT skip = v [ 2 * n + 1 ] [ i ] + v [ 2 * n + 2 ] [ i ] NEW_LINE v [ n ] [ i ] = min ( buy , skip ) NEW_LINE DEDENT DEDENT print v [ 0 ] [ 0 ] NEW_LINE if debug : NEW_LINE INDENT print costs NEW_LINE for ( i , x ) in enumerate ( v ) : print i , x NEW_LINE DEDENT DEDENT","from sys import stdin NEW_LINE def main ( ) : NEW_LINE INDENT p = int ( stdin . readline ( ) ) NEW_LINE m = map ( int , stdin . readline ( ) . split ( ) ) NEW_LINE m . reverse ( ) NEW_LINE c = [ ] NEW_LINE for i in xrange ( p ) : NEW_LINE INDENT c += map ( int , stdin . readline ( ) . split ( ) ) NEW_LINE DEDENT c . reverse ( ) NEW_LINE n = 2 ** p NEW_LINE v = [ None ] * ( 2 * n - 1 ) NEW_LINE for i in xrange ( n - 1 , 2 * n - 1 ) : NEW_LINE INDENT v [ i ] = ( [ 0 ] * ( m [ i - n + 1 ] + 1 ) ) NEW_LINE DEDENT for i in xrange ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT vl = v [ 2 * i + 1 ] NEW_LINE vr = v [ 2 * i + 2 ] NEW_LINE vv = [ 0 ] * min ( len ( vl ) , len ( vr ) ) NEW_LINE for j in range ( len ( vv ) ) : NEW_LINE INDENT vv [ j ] = vl [ j ] + vr [ j ] + c [ i ] NEW_LINE DEDENT for j in range ( len ( vv ) - 1 ) : NEW_LINE INDENT vv [ j ] = min ( vl [ j + 1 ] + vr [ j + 1 ] , vv [ j ] ) NEW_LINE DEDENT v [ i ] = vv NEW_LINE DEDENT return str ( v [ 0 ] [ 0 ] ) NEW_LINE DEDENT tno = int ( stdin . readline ( ) ) NEW_LINE for i in xrange ( 0 , tno ) : NEW_LINE INDENT print \" Case ▁ # % d : ▁ % s \" % ( i + 1 , main ( ) ) NEW_LINE DEDENT","import sys NEW_LINE import re NEW_LINE from subprocess import Popen , PIPE , STDOUT NEW_LINE stdin = sys . stdin NEW_LINE cases = int ( stdin . readline ( ) ) NEW_LINE solved_re = re . compile ( r ' . * Value ▁ of ▁ objective ▁ function : ▁ ( [0-9 . e + ] + ) $ ' ) NEW_LINE for case in range ( 1 , cases + 1 ) : NEW_LINE INDENT p = int ( stdin . readline ( ) ) NEW_LINE misses = [ p - int ( x ) for x in stdin . readline ( ) . split ( ) ] NEW_LINE assert len ( misses ) == 1 << p NEW_LINE rounds = [ ] NEW_LINE lp = ' min : \\n ' NEW_LINE for i in range ( p ) : NEW_LINE INDENT r = [ int ( x ) for x in stdin . readline ( ) . split ( ) ] NEW_LINE rounds . append ( r ) NEW_LINE for j , cost in enumerate ( r ) : NEW_LINE INDENT lp += ' \\t % d ▁ * ▁ r % d % d ▁ + ▁ \\n ' % ( cost , i , j ) NEW_LINE DEDENT DEDENT lp += ' \\t0 ; \\n \\n ' NEW_LINE for i in range ( 1 << p ) : NEW_LINE INDENT v = i NEW_LINE for j in range ( len ( rounds ) ) : NEW_LINE INDENT v >>= 1 NEW_LINE lp += ' r % d % d ▁ + ▁ ' % ( j , v ) NEW_LINE DEDENT lp += '0 ▁ > = ▁ % d ; \\n ' % misses [ i ] NEW_LINE DEDENT lp += ' \\n \\n ' NEW_LINE for i , r in enumerate ( rounds ) : NEW_LINE INDENT for j in range ( len ( r ) ) : NEW_LINE INDENT lp += ' r % d % d ▁ > = ▁ 0 ; \\n ' % ( i , j ) NEW_LINE lp += ' r % d % d ▁ < = ▁ 1 ; \\n ' % ( i , j ) NEW_LINE DEDENT DEDENT for i , r in enumerate ( rounds ) : NEW_LINE INDENT for j in range ( len ( r ) ) : NEW_LINE INDENT lp += ' int ▁ r % d % d ; \\n ' % ( i , j ) NEW_LINE DEDENT DEDENT result = Popen ( [ ' lp _ solve ' , ' - S1' ] , stdin = PIPE , stdout = PIPE , stderr = STDOUT ) . communicate ( lp ) [ 0 ] NEW_LINE g = solved_re . search ( result ) NEW_LINE assert g is not None NEW_LINE print ' Case ▁ # % d : ▁ % d ' % ( case , int ( round ( float ( g . group ( 1 ) ) ) ) ) NEW_LINE DEDENT","import sys NEW_LINE cache = { } NEW_LINE n = None NEW_LINE def run2 ( a , idx , count , level ) : NEW_LINE INDENT if level == n : NEW_LINE INDENT if a [ idx ] >= count : NEW_LINE INDENT return 0 NEW_LINE DEDENT return None NEW_LINE DEDENT a1 = run ( a , idx * 2 + 1 , count , level + 1 ) NEW_LINE a2 = run ( a , idx * 2 + 2 , count , level + 1 ) NEW_LINE if a1 is None or a2 is None : NEW_LINE INDENT a3 = None NEW_LINE DEDENT else : NEW_LINE INDENT a3 = a1 + a2 + a [ idx ] NEW_LINE DEDENT a1 = run ( a , idx * 2 + 1 , count + 1 , level + 1 ) NEW_LINE a2 = run ( a , idx * 2 + 2 , count + 1 , level + 1 ) NEW_LINE if a1 is None or a2 is None : NEW_LINE INDENT a4 = None NEW_LINE DEDENT else : NEW_LINE INDENT a4 = a1 + a2 NEW_LINE DEDENT if a3 is None : NEW_LINE INDENT return a4 NEW_LINE DEDENT if a4 is None : NEW_LINE INDENT return a3 NEW_LINE DEDENT return min ( a3 , a4 ) NEW_LINE DEDENT def run ( a , idx , count , level ) : NEW_LINE INDENT if ( idx , count ) not in cache : NEW_LINE INDENT cache [ ( idx , count ) ] = run2 ( a , idx , count , level ) NEW_LINE DEDENT return cache [ ( idx , count ) ] NEW_LINE DEDENT def foo ( ifile ) : NEW_LINE INDENT global n NEW_LINE n = int ( ifile . readline ( ) ) NEW_LINE a = [ ] NEW_LINE cache . clear ( ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT a . extend ( [ int ( x ) for x in ifile . readline ( ) . split ( ) ] ) NEW_LINE DEDENT a = a [ : : - 1 ] NEW_LINE return run ( a , 0 , 0 , 0 ) NEW_LINE DEDENT def main ( ifile ) : NEW_LINE INDENT n = int ( ifile . readline ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ' Case ▁ # % s : ▁ % s ' % ( i + 1 , foo ( ifile ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . stdin ) NEW_LINE DEDENT","import sys NEW_LINE import psyco NEW_LINE psyco . full ( ) NEW_LINE def dbg ( a ) : sys . stderr . write ( str ( a ) ) NEW_LINE def readint ( ) : return int ( raw_input ( ) ) NEW_LINE def readarray ( foo ) : return [ foo ( x ) for x in raw_input ( ) . split ( ) ] NEW_LINE def doit ( match , missed ) : NEW_LINE INDENT if match >= len ( a ) : NEW_LINE INDENT return - 1 if missed > M [ match - len ( a ) ] else 0 NEW_LINE DEDENT if ( match , missed ) in mem : return mem [ ( match , missed ) ] NEW_LINE m1 = match * 2 + 1 NEW_LINE m2 = match * 2 + 2 NEW_LINE r1 = doit ( m1 , missed ) NEW_LINE r2 = doit ( m2 , missed ) NEW_LINE if r1 == - 1 or r2 == - 1 : NEW_LINE INDENT mem [ ( match , missed ) ] = - 1 NEW_LINE return - 1 NEW_LINE DEDENT res = r1 + r2 + a [ match ] NEW_LINE q1 = doit ( m1 , missed + 1 ) NEW_LINE q2 = doit ( m2 , missed + 1 ) NEW_LINE if q1 >= 0 and q2 >= 0 : NEW_LINE INDENT res = min ( res , q1 + q2 ) NEW_LINE DEDENT mem [ ( match , missed ) ] = res NEW_LINE return res NEW_LINE DEDENT def run_test ( test ) : NEW_LINE INDENT global P , M , a , mem NEW_LINE P = readint ( ) NEW_LINE M = readarray ( int ) NEW_LINE data = [ ] NEW_LINE a = [ ] NEW_LINE for i in xrange ( P ) : NEW_LINE INDENT data . append ( readarray ( int ) ) NEW_LINE DEDENT for arr in reversed ( data ) : NEW_LINE INDENT a += arr NEW_LINE DEDENT mem = { } NEW_LINE res = doit ( 0 , 0 ) NEW_LINE print \" Case ▁ # % d : ▁ % d \" % ( test + 1 , res ) NEW_LINE DEDENT for test in range ( readint ( ) ) : NEW_LINE INDENT dbg ( \" Test ▁ % d \\n \" % ( test + 1 ) ) NEW_LINE run_test ( test ) NEW_LINE DEDENT"],"bleu":0.6175922162457271,"rouge_l":0.4586072088327534}
{"id":153,"predictions":["from fractions import gcd NEW_LINE def lcm ( a , b ) : NEW_LINE INDENT return ( a \/ gcd ( a , b ) ) NEW_LINE DEDENT def gcd ( a , b ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT def diff ( a , b ) : NEW_LINE INDENT ret = 0 NEW_LINE for i in range ( a ) : NEW_LINE INDENT ret += gcd ( ret , i % b ) NEW_LINE DEDENT return ret NEW_LINE DEDENT in range ( 1 , 10 ) : NEW_LINE INDENT print \" Case ▁ # % d : ▁ % s \" % ( i , ret + 1 ) NEW_LINE DEDENT"],"references":["import functools NEW_LINE import multiprocessing NEW_LINE import fractions NEW_LINE def pow2 ( x ) : NEW_LINE INDENT return x != 0 and ( ( x & ( x - 1 ) ) == 0 ) NEW_LINE DEDENT def solve ( cs , f ) : NEW_LINE INDENT if not pow2 ( f . denominator ) : NEW_LINE INDENT return cs , ' impossible ' NEW_LINE DEDENT ret = 1 NEW_LINE while f < fractions . Fraction ( 1 , 2 ) : NEW_LINE INDENT ret += 1 NEW_LINE f *= 2 NEW_LINE DEDENT return cs , ret NEW_LINE DEDENT def reducer ( l , result ) : NEW_LINE INDENT l . append ( result ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT T = int ( input ( ) ) NEW_LINE l = [ ] NEW_LINE with multiprocessing . Pool ( processes = 8 ) as pool : NEW_LINE INDENT for cs in range ( T ) : NEW_LINE INDENT f = fractions . Fraction ( input ( ) ) NEW_LINE solve ( cs , f ) NEW_LINE pool . apply_async ( solve , args = ( cs + 1 , f , ) , callback = functools . partial ( reducer , l ) ) NEW_LINE DEDENT pool . close ( ) NEW_LINE pool . join ( ) NEW_LINE DEDENT for cs , result in sorted ( l , key = lambda x : x [ 0 ] ) : NEW_LINE INDENT print ( ' Case ▁ # { } : ▁ { } ' . format ( cs , result ) ) NEW_LINE DEDENT DEDENT","import sys NEW_LINE from fractions import gcd NEW_LINE def debug ( * args ) : NEW_LINE INDENT print ( * args , file = sys . stderr ) NEW_LINE DEDENT fin = sys . stdin NEW_LINE T = int ( fin . readline ( ) ) NEW_LINE for case in range ( 1 , T + 1 ) : NEW_LINE INDENT p , q = map ( int , fin . readline ( ) . split ( ' \/ ' ) ) NEW_LINE g = gcd ( p , q ) NEW_LINE p \/\/= g NEW_LINE q \/\/= g NEW_LINE result = None NEW_LINE if p > q : NEW_LINE INDENT result = \" impossible \" NEW_LINE DEDENT else : NEW_LINE INDENT is_power = None NEW_LINE for i in range ( 0 , 41 ) : NEW_LINE INDENT power = 2 ** i NEW_LINE if q == power : NEW_LINE INDENT is_power = power NEW_LINE DEDENT DEDENT if is_power is None : NEW_LINE INDENT result = \" impossible \" NEW_LINE DEDENT else : NEW_LINE INDENT result = \" broken \" NEW_LINE for i in range ( 1 , 41 ) : NEW_LINE INDENT qq = 2 ** i NEW_LINE if p * qq >= q : NEW_LINE INDENT result = str ( i ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( \" Case ▁ # % d : ▁ % s \" % ( case , result ) ) NEW_LINE DEDENT","T = int ( raw_input ( ) ) NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT r = a % b NEW_LINE if r == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( b , r ) NEW_LINE DEDENT DEDENT def p2 ( x ) : NEW_LINE INDENT if x == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 * p2 ( x - 1 ) NEW_LINE DEDENT DEDENT for t in range ( T ) : NEW_LINE INDENT inpArr = raw_input ( ) . strip ( ) . split ( ' \/ ' ) NEW_LINE P = int ( inpArr [ 0 ] ) NEW_LINE Q = int ( inpArr [ 1 ] ) NEW_LINE g = gcd ( P , Q ) NEW_LINE P \/= g NEW_LINE Q \/= g NEW_LINE if ( P * p2 ( 40 ) ) % Q == 0 : NEW_LINE INDENT gen = 0 NEW_LINE while P < Q : NEW_LINE INDENT gen += 1 NEW_LINE P *= 2 NEW_LINE DEDENT print ( \" Case ▁ # \" + str ( t + 1 ) + \" : ▁ \" + str ( gen ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Case ▁ # \" + str ( t + 1 ) + \" : ▁ impossible \" ) NEW_LINE DEDENT DEDENT","import fractions NEW_LINE fname = ' A _ example ' NEW_LINE fname = ' A _ large ' NEW_LINE def tokreader ( filename ) : NEW_LINE INDENT for line in open ( filename ) : NEW_LINE INDENT for item in line . strip ( ) . split ( ) : NEW_LINE INDENT yield item NEW_LINE DEDENT DEDENT DEDENT def readn ( n ) : NEW_LINE INDENT r = [ ] NEW_LINE for i in xrange ( n ) : NEW_LINE INDENT r . append ( read ) NEW_LINE DEDENT return r NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT inp = tokreader ( fname + ' . in ' ) NEW_LINE read = lambda : inp . next ( ) NEW_LINE readn = lambda x : [ read ( ) for i in xrange ( x ) ] NEW_LINE outp = open ( fname + ' . out ' , ' w ' ) NEW_LINE T = int ( read ( ) ) NEW_LINE for i in range ( 1 , T + 1 ) : NEW_LINE INDENT fs = read ( ) NEW_LINE den = int ( fs [ : fs . find ( ' \/ ' ) ] ) NEW_LINE nom = int ( fs [ fs . find ( ' \/ ' ) + 1 : ] ) NEW_LINE f = fractions . Fraction ( den , nom ) NEW_LINE v = f \/ fractions . Fraction ( 1 , 2 ** 40 ) NEW_LINE if ( v . denominator != 1 ) : NEW_LINE INDENT res = ' Case ▁ # % d : ▁ impossible \\n ' % ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT n1 = v . numerator NEW_LINE n2 = 2 ** 39 NEW_LINE r = 1 NEW_LINE while n2 > n1 : NEW_LINE INDENT n2 = n2 \/ 2 NEW_LINE r += 1 NEW_LINE DEDENT res = ' Case ▁ # % d : ▁ % d \\n ' % ( i , r ) NEW_LINE DEDENT print den , nom , v , res NEW_LINE print res NEW_LINE outp . write ( res ) NEW_LINE DEDENT outp . close ( ) NEW_LINE print ' finished ' NEW_LINE DEDENT","def gcd ( a , b ) : NEW_LINE INDENT while b != 0 : NEW_LINE INDENT a , b = b , a % b NEW_LINE DEDENT return a NEW_LINE DEDENT def IsPower ( n ) : NEW_LINE INDENT while n % 2 == 0 : NEW_LINE INDENT n \/\/= 2 NEW_LINE DEDENT return n == 1 NEW_LINE DEDENT def solve ( num ) : NEW_LINE INDENT P , Q = map ( int , input ( ) . split ( \" \/ \" ) ) NEW_LINE d = gcd ( P , Q ) NEW_LINE P \/\/= d NEW_LINE Q \/\/= d NEW_LINE if not IsPower ( Q ) : NEW_LINE INDENT ans = \" impossible \" NEW_LINE DEDENT else : NEW_LINE INDENT ans = 1 NEW_LINE while 2 * P < Q : NEW_LINE INDENT ans += 1 NEW_LINE P *= 2 NEW_LINE DEDENT DEDENT print ( \" Case ▁ # \" + str ( num ) + \" : \" , ans ) NEW_LINE DEDENT T = int ( input ( ) ) NEW_LINE for i in range ( T ) : NEW_LINE INDENT solve ( i + 1 ) NEW_LINE DEDENT"],"bleu":0.37117077294896467,"rouge_l":0.4013820735365418}
{"id":154,"predictions":["fin = open ( \" , \" r \" ) NEW_LINE fout = open ( \" A - large . in \" , \" w \" ) NEW_LINE numcases = int ( fin . readline ( ) ) NEW_LINE for i in xrange ( 1 , numcases + 1 ) : NEW_LINE INDENT line = fin . readline ( ) NEW_LINE N = int ( line [ 0 ] ) NEW_LINE F = fin . readline ( ) NEW_LINE line = [ ] NEW_LINE for j in xrange ( N ) : NEW_LINE INDENT line = fin . readline ( ) . split ( ) NEW_LINE P = int ( line [ 1 ] ) NEW_LINE best = 100 NEW_LINE for j in xrange ( N ) : NEW_LINE INDENT fout . write ( \" Case ▁ # \" + str ( i ) + \" : ▁ \" + str ( j ) + \" \\n \" ) NEW_LINE DEDENT DEDENT DEDENT fout . close ( ) NEW_LINE DEDENT"],"references":["import sys , time NEW_LINE start_time = time . time ( ) NEW_LINE try : NEW_LINE INDENT if len ( sys . argv ) > 1 : NEW_LINE INDENT inname = sys . argv [ 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT inname = input ( \" Enter ▁ input ▁ filename : ▁ \" ) NEW_LINE DEDENT assert inname . endswith ( ' . in ' ) NEW_LINE outname = inname . replace ( ' . in ' , ' . out ' ) NEW_LINE with open ( inname ) as fin : NEW_LINE INDENT with open ( outname , ' w ' ) as fout : NEW_LINE INDENT num_cases = int ( fin . readline ( ) ) NEW_LINE for case_idx in range ( 1 , 1 + num_cases ) : NEW_LINE INDENT if time . time ( ) >= start_time + 5 : NEW_LINE INDENT print ( \" [ = = ▁ Case ▁ % d ▁ of ▁ % d ▁ = = ] \" % ( case_idx , num_cases ) ) NEW_LINE DEDENT N , pD , pG = [ int ( x ) for x in fin . readline ( ) . split ( ) ] NEW_LINE answer = True NEW_LINE N = min ( N , 100 ) NEW_LINE if pG == 100 and pD != 100 : answer = False NEW_LINE if pG == 0 and pD != 0 : answer = False NEW_LINE if all ( ( pD * D ) % 100 for D in range ( 1 , 1 + N ) ) : answer = False NEW_LINE print ( \" Case ▁ # { } : ▁ { } \" . format ( case_idx , ' Possible ' if answer else ' Broken ' ) , file = fout ) NEW_LINE DEDENT DEDENT DEDENT DEDENT except : NEW_LINE INDENT import traceback NEW_LINE print ( \" Exception ▁ caught : \" , file = sys . stderr ) NEW_LINE print ( ' - ' * 60 , file = sys . stderr ) NEW_LINE traceback . print_exc ( file = sys . stderr ) NEW_LINE print ( ' - ' * 60 , file = sys . stderr ) NEW_LINE input ( \" Press ▁ Enter ▁ to ▁ close \" ) NEW_LINE DEDENT else : NEW_LINE INDENT total_time = time . time ( ) - start_time NEW_LINE print ( \" Completed ▁ in ▁ % .1f ▁ seconds \" % total_time , file = sys . stderr ) NEW_LINE time . sleep ( 3 ) NEW_LINE DEDENT","gcds = { } NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT end = max ( a , b ) NEW_LINE sor = min ( a , b ) NEW_LINE if end in gcds : NEW_LINE INDENT if sor in gcds [ end ] : NEW_LINE INDENT return gcds [ end ] [ sor ] NEW_LINE DEDENT DEDENT rem = end % sor NEW_LINE if rem == 0 : NEW_LINE INDENT if end not in gcds : NEW_LINE INDENT gcds [ end ] = { } NEW_LINE DEDENT gcds [ end ] [ sor ] = sor NEW_LINE return sor NEW_LINE DEDENT else : NEW_LINE INDENT answer = gcd ( sor , rem ) NEW_LINE if end not in gcds : NEW_LINE INDENT gcds [ end ] = { } NEW_LINE DEDENT gcds [ end ] [ sor ] = answer NEW_LINE return answer NEW_LINE DEDENT DEDENT def solver ( n , pd , pg ) : NEW_LINE INDENT if pd == 0 : NEW_LINE INDENT if pg == 100 : NEW_LINE INDENT return \" Broken \" NEW_LINE DEDENT else : NEW_LINE INDENT return \" Possible \" NEW_LINE DEDENT DEDENT if pg == 0 : NEW_LINE INDENT if pd == 0 : NEW_LINE INDENT return \" Possible \" NEW_LINE DEDENT else : NEW_LINE INDENT return \" Broken \" NEW_LINE DEDENT DEDENT min_played = 100 \/ gcd ( pd , 100 ) NEW_LINE if min_played > n : NEW_LINE INDENT return \" Broken \" NEW_LINE DEDENT if pg == 100 and not pd == 100 : NEW_LINE INDENT return \" Broken \" NEW_LINE DEDENT return \" Possible \" NEW_LINE DEDENT def ssi ( s ) : NEW_LINE INDENT return map ( int , s . strip ( ' \\n ' ) . split ( ) ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT input_file = open ( ' infile . txt ' ) NEW_LINE cases = int ( input_file . readline ( ) ) NEW_LINE output = [ ] NEW_LINE for c in range ( cases ) : NEW_LINE INDENT [ n , pd , pg ] = ssi ( input_file . readline ( ) ) NEW_LINE answer = solver ( n , pd , pg ) NEW_LINE output . append ( ' Case ▁ # % d : ▁ % s \\n ' % ( c + 1 , str ( answer ) ) ) NEW_LINE DEDENT input_file . close ( ) NEW_LINE output_file = open ( ' outfile . txt ' , ' w ' ) NEW_LINE output_file . writelines ( output ) NEW_LINE output_file . close ( ) NEW_LINE print ' Done ! ' NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT","def whole_num ( frac ) : NEW_LINE INDENT a = int ( frac * 100 ) NEW_LINE from_100 = 1 NEW_LINE for i in range ( 2 ) : NEW_LINE INDENT if a % 2 == 0 : NEW_LINE INDENT a \/= 2 NEW_LINE from_100 *= 2 NEW_LINE DEDENT if a % 5 == 0 : NEW_LINE INDENT a \/= 5 NEW_LINE from_100 *= 5 NEW_LINE DEDENT DEDENT return 100 \/ from_100 NEW_LINE DEDENT def possible ( n , pd , pg ) : NEW_LINE INDENT if pg == 0 : NEW_LINE INDENT return pd == 0 NEW_LINE DEDENT if pg == 100 : NEW_LINE INDENT return pd == 100 NEW_LINE DEDENT pd = float ( pd ) \/ 100 NEW_LINE pg = float ( pg ) \/ 100 NEW_LINE a , b = map ( whole_num , ( pd , pg ) ) NEW_LINE return a <= n NEW_LINE DEDENT def solve ( case ) : NEW_LINE INDENT n , pd , pg = map ( int , case . strip ( ) . split ( ) ) NEW_LINE solution = ' Broken ' NEW_LINE if possible ( n , pd , pg ) : NEW_LINE INDENT solution = ' Possible ' NEW_LINE DEDENT return solution NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT T = int ( raw_input ( ) ) NEW_LINE for i in range ( 1 , T + 1 ) : NEW_LINE INDENT sol = solve ( raw_input ( ) ) NEW_LINE print \" Case ▁ # % d : ▁ % s \" % ( i , sol ) NEW_LINE DEDENT DEDENT","from fractions import gcd NEW_LINE name = \" A - large \" NEW_LINE f_in = open ( name + ' . in ' , \" r \" ) NEW_LINE f_out = open ( name + ' . out ' , ' w ' ) NEW_LINE T = int ( f_in . readline ( ) ) NEW_LINE for i in range ( T ) : NEW_LINE INDENT print ( i ) NEW_LINE N , Pd , Pg = [ int ( x ) for x in ( f_in . readline ( ) . split ( ) ) ] NEW_LINE if ( Pg == 100 and Pd != 100 ) : NEW_LINE INDENT f_out . write ( \" Case ▁ # \" + str ( i + 1 ) + \" : ▁ \" + str ( \" Broken \" ) + \" \\n \" ) NEW_LINE DEDENT elif ( Pg == 100 ) : NEW_LINE INDENT f_out . write ( \" Case ▁ # \" + str ( i + 1 ) + \" : ▁ \" + str ( \" Possible \" ) + \" \\n \" ) NEW_LINE DEDENT elif ( Pg == 0 and Pd != 0 ) : NEW_LINE INDENT f_out . write ( \" Case ▁ # \" + str ( i + 1 ) + \" : ▁ \" + str ( \" Broken \" ) + \" \\n \" ) NEW_LINE DEDENT elif ( Pg == 0 ) : NEW_LINE INDENT f_out . write ( \" Case ▁ # \" + str ( i + 1 ) + \" : ▁ \" + str ( \" Possible \" ) + \" \\n \" ) NEW_LINE DEDENT elif ( Pd == 0 ) : NEW_LINE INDENT f_out . write ( \" Case ▁ # \" + str ( i + 1 ) + \" : ▁ \" + str ( \" Possible \" ) + \" \\n \" ) NEW_LINE DEDENT elif ( Pd == 100 ) : NEW_LINE INDENT f_out . write ( \" Case ▁ # \" + str ( i + 1 ) + \" : ▁ \" + str ( \" Possible \" ) + \" \\n \" ) NEW_LINE DEDENT else : NEW_LINE INDENT ret = False NEW_LINE g1 = max ( 100 \/\/ gcd ( Pd , 100 ) , 100 \/\/ gcd ( 100 - Pd , 100 ) ) NEW_LINE print ( g1 , N ) NEW_LINE if ( g1 <= N ) : NEW_LINE INDENT f_out . write ( \" Case ▁ # \" + str ( i + 1 ) + \" : ▁ \" + str ( \" Possible \" ) + \" \\n \" ) NEW_LINE DEDENT else : NEW_LINE INDENT f_out . write ( \" Case ▁ # \" + str ( i + 1 ) + \" : ▁ \" + str ( \" Broken \" ) + \" \\n \" ) NEW_LINE DEDENT DEDENT DEDENT f_in . close ( ) NEW_LINE f_out . close ( ) NEW_LINE","infile = open ( ' as . in ' ) NEW_LINE num_cases = readint ( ) NEW_LINE for iter in range ( num_cases ) : NEW_LINE INDENT case = infile . readline ( ) . split ( ) NEW_LINE case = [ ( int ( case [ i ] == ' B ' ) , int ( float ( case [ i + 1 ] ) ) ) for i in range ( 1 , 2 * int ( case [ 0 ] ) , 2 ) ] NEW_LINE x , y , t = 1 , 1 , 0 NEW_LINE xt , yt , = 1 , 1 NEW_LINE while len ( case ) > 0 : NEW_LINE INDENT z = case . pop ( 0 ) NEW_LINE if z [ 0 ] : NEW_LINE INDENT d = max ( 0 , abs ( z [ 1 ] - x ) - ( t - xt ) ) NEW_LINE t = t + d + 1 NEW_LINE x = z [ 1 ] NEW_LINE xt = t NEW_LINE DEDENT else : NEW_LINE INDENT d = max ( 0 , abs ( z [ 1 ] - y ) - ( t - yt ) ) NEW_LINE t = t + d + 1 NEW_LINE y = z [ 1 ] NEW_LINE yt = t NEW_LINE DEDENT DEDENT print \" Case ▁ # \" + str ( iter ) + \" : ▁ \" + str ( t - 1 ) NEW_LINE DEDENT"],"bleu":0.33799772762216834,"rouge_l":0.40375743798890146}
{"id":155,"predictions":["import sys , re , string , math NEW_LINE ssr = sys . stdin . readline NEW_LINE ssw = sys . stdout . write NEW_LINE D = - 99 NEW_LINE def comb ( L , r ) : NEW_LINE INDENT if not L : NEW_LINE INDENT return [ x ] NEW_LINE DEDENT ( p1 , v1 , t1 ) = L [ - 1 ] NEW_LINE ( p2 , v2 , t2 ) = x NEW_LINE v3 = v1 + v2 NEW_LINE if ( p2 - p1 ) < 0.5 * D * v3 : NEW_LINE INDENT m = 0.5 * D * v3 - ( p2 - p1 ) NEW_LINE if t1 < t2 : NEW_LINE INDENT d = t2 - t1 NEW_LINE mm = max ( 0 , 0.5 * ( m - d ) ) NEW_LINE t3 = t2 + mm NEW_LINE p3 = p2 + mm - 0.5 * D * v1 NEW_LINE DEDENT else : NEW_LINE INDENT d = t2 - t1 NEW_LINE mm = max ( 0 , 0.5 * ( m - d ) ) NEW_LINE t3 = t1 + mm NEW_LINE p3 = p1 - mm + 0.5 * D * v2 NEW_LINE DEDENT L [ - 1 ] = ( p3 , v3 , t3 ) NEW_LINE DEDENT else : NEW_LINE INDENT L . append ( x ) NEW_LINE DEDENT return L NEW_LINE DEDENT def do_one_case ( c , D ) : NEW_LINE INDENT global D NEW_LINE ( C , D ) = map ( int , ssr ( ) . split ( ) ) NEW_LINE L = [ ] ; NEW_LINE for _ in range ( C ) : NEW_LINE INDENT ( C , D ) = map ( int , ssr ( ) . split ( ) ) NEW_LINE t = 0.5 * D * ( V - 1 ) NEW_LINE L . append ( ( 1.0 * P , V , t ) NEW_LINE DEDENT n = C + 1 NEW_LINE while len ( L ) < n : NEW_LINE INDENT n"],"references":["import os , sys , time , random NEW_LINE time . clock ( ) NEW_LINE sys . stdin = open ( ' C - small - 1 - attempt0 . in ' ) NEW_LINE sys . stdout = open ( ' C - small - 1 - attempt0 . out ' , ' w ' ) NEW_LINE def Work ( ) : NEW_LINE INDENT n = int ( input ( ) . strip ( ) ) NEW_LINE sb = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT d , h , m = map ( int , input ( ) . strip ( ) . split ( ) ) NEW_LINE for j in range ( h ) : NEW_LINE INDENT sb . append ( ( d , 360 \/ ( m + j ) ) ) NEW_LINE DEDENT DEDENT sb . sort ( key = lambda d : d [ - 1 ] , reverse = True ) NEW_LINE if sb [ 0 ] [ 1 ] == sb [ 1 ] [ 1 ] : return 0 NEW_LINE ar1 = ( 360 - sb [ 1 ] [ 0 ] ) \/ sb [ 1 ] [ 1 ] NEW_LINE meet = ( 360 + sb [ 1 ] [ 0 ] - sb [ 0 ] [ 0 ] ) \/ ( sb [ 0 ] [ 1 ] - sb [ 1 ] [ 1 ] ) NEW_LINE if meet <= ar1 + 1e-8 : return 1 NEW_LINE return 0 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT T = int ( input ( ) ) NEW_LINE for i in range ( T ) : NEW_LINE INDENT print ( ' Case ▁ # % d : ▁ % d ' % ( i + 1 , Work ( ) ) ) NEW_LINE DEDENT sys . stderr . write ( ' completed ▁ % .3f \\n ' % time . clock ( ) ) NEW_LINE DEDENT","import sys NEW_LINE infile = None NEW_LINE outfile = None NEW_LINE def readline ( ) : NEW_LINE INDENT x = infile . readline ( ) NEW_LINE if len ( x ) > 0 and x [ - 1 ] == ' \\n ' : NEW_LINE INDENT return x [ : - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT return x NEW_LINE DEDENT DEDENT def readint ( ) : NEW_LINE INDENT return int ( readline ( ) ) NEW_LINE DEDENT def readfloat ( ) : NEW_LINE INDENT return float ( readline ( ) ) NEW_LINE DEDENT def readints ( ) : NEW_LINE INDENT return [ int ( x ) for x in readline ( ) . split ( ) ] NEW_LINE DEDENT def readfloats ( ) : NEW_LINE INDENT return [ float ( x ) for x in readline ( ) . split ( ) ] NEW_LINE DEDENT def writeline ( x ) : NEW_LINE INDENT outfile . write ( x + ' \\n ' ) NEW_LINE DEDENT def writecase ( casenum , answer ) : NEW_LINE INDENT outfile . write ( ' Case ▁ # { : d } : ▁ { } \\n ' . format ( casenum , answer ) ) NEW_LINE DEDENT def run ( main ) : NEW_LINE INDENT global infile , outfile NEW_LINE args = sys . argv NEW_LINE infile = sys . stdin NEW_LINE outfile = sys . stdout NEW_LINE if len ( args ) == 2 : NEW_LINE INDENT if args [ 1 ] != ' - ' : NEW_LINE INDENT infile = open ( args [ 1 ] , ' r ' ) NEW_LINE if args [ 1 ] . endswith ( ' . in ' ) : NEW_LINE INDENT outfile = open ( args [ 1 ] [ : - 3 ] + ' . out ' , ' w ' ) NEW_LINE DEDENT DEDENT DEDENT elif len ( args ) == 3 : NEW_LINE INDENT if args [ 1 ] != ' - ' : NEW_LINE INDENT infile = open ( args [ 1 ] , ' r ' ) NEW_LINE DEDENT if args [ 2 ] != ' - ' : NEW_LINE INDENT outfile = open ( args [ 2 ] , ' w ' ) NEW_LINE DEDENT DEDENT elif len ( args ) > 3 : NEW_LINE INDENT print ( \" Expected ▁ 0 , ▁ 1 , ▁ or ▁ 2 ▁ arguments , ▁ not ▁ { } \" . format ( len ( args ) - 1 ) ) NEW_LINE print ( args ) NEW_LINE return NEW_LINE DEDENT t = readint ( ) NEW_LINE for casenum in range ( 1 , t + 1 ) : NEW_LINE INDENT main ( casenum ) NEW_LINE DEDENT if infile is not sys . stdin : NEW_LINE INDENT infile . close ( ) NEW_LINE DEDENT if outfile is not sys . stdout : NEW_LINE INDENT outfile . close ( ) NEW_LINE DEDENT DEDENT","from sys import stdin , stdout , stderr NEW_LINE import heapq NEW_LINE def solve ( N , hikers ) : NEW_LINE INDENT N = len ( hikers ) NEW_LINE D = [ h [ 0 ] for h in hikers ] NEW_LINE M = [ h [ 1 ] for h in hikers ] NEW_LINE intersects = [ ( ( 360 - D [ i ] ) * M [ i ] , M [ i ] , i ) for i in range ( N ) ] NEW_LINE heapq . heapify ( intersects ) NEW_LINE best = N NEW_LINE current = best NEW_LINE seen = set ( ) NEW_LINE while current <= 2 * N : NEW_LINE INDENT ( m , M , i ) = heapq . heappop ( intersects ) NEW_LINE if i not in seen : NEW_LINE INDENT current -= 1 NEW_LINE best = min ( best , current ) NEW_LINE seen . add ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT current += 1 NEW_LINE DEDENT heapq . heappush ( intersects , ( m + M * 360 , M , i ) ) NEW_LINE DEDENT return best NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT T = int ( input ( ) ) NEW_LINE for case in range ( 1 , T + 1 ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE hikers = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT D , H , M = map ( int , input ( ) . split ( ) ) NEW_LINE for j in range ( H ) : NEW_LINE INDENT hikers . append ( ( D , M + j ) ) NEW_LINE DEDENT DEDENT answer = solve ( N , hikers ) NEW_LINE print ( \" Case ▁ # % d : ▁ % s \" % ( case , answer ) ) NEW_LINE DEDENT DEDENT main ( ) NEW_LINE","import sys NEW_LINE import random NEW_LINE from itertools import permutations NEW_LINE import operator NEW_LINE class Hiker : NEW_LINE INDENT def __init__ ( self , d , m ) : NEW_LINE INDENT self . d = d NEW_LINE self . m = m NEW_LINE self . first = ( 360 - self . d ) * self . m NEW_LINE self . step = 360 * self . m NEW_LINE DEDENT def __le__ ( self , other ) : NEW_LINE INDENT return self . first <= other . first NEW_LINE DEDENT def __repr__ ( self ) : NEW_LINE INDENT return u ' Hiker ▁ ( % d , ▁ % d ) ' % ( self . first , self . step ) NEW_LINE DEDENT def encounters ( self , pos ) : NEW_LINE INDENT if pos < self . first : NEW_LINE INDENT return 1 NEW_LINE DEDENT return int ( float ( pos - self . first ) \/ float ( self . step ) ) NEW_LINE DEDENT DEDENT hikers = [ ] NEW_LINE def solve ( ) : NEW_LINE INDENT hikers = [ ] NEW_LINE n = int ( sys . stdin . readline ( ) ) NEW_LINE for j in xrange ( n ) : NEW_LINE INDENT d , h , m = [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE for k in xrange ( h ) : NEW_LINE INDENT hikers . append ( Hiker ( d , m + k ) ) NEW_LINE DEDENT DEDENT hikers = sorted ( hikers , key = operator . attrgetter ( ' first ' ) ) NEW_LINE best = len ( hikers ) NEW_LINE current = len ( hikers ) NEW_LINE for hik in hikers : NEW_LINE INDENT position = float ( hik . first ) + 0.5 NEW_LINE current = sum ( [ hiker . encounters ( position ) for hiker in hikers ] ) NEW_LINE best = min ( current , best ) NEW_LINE DEDENT print best NEW_LINE DEDENT t = int ( sys . stdin . readline ( ) ) NEW_LINE for i in xrange ( t ) : NEW_LINE INDENT print \" Case ▁ # % d : \" % ( i + 1 ) , NEW_LINE solve ( ) NEW_LINE DEDENT","import numpy as np NEW_LINE def main ( ifn = ' C - small - 2 - attempt0 . in ' , ofn = ' output . txt ' ) : NEW_LINE INDENT with open ( ifn ) as inf : NEW_LINE INDENT with open ( ofn , ' w ' ) as ouf : NEW_LINE INDENT noc = int ( inf . readline ( ) . strip ( ) ) NEW_LINE for tnoc in range ( noc ) : NEW_LINE INDENT ouf . write ( \" Case ▁ # % d : ▁ \" % ( tnoc + 1 ) ) NEW_LINE i = int ( inf . readline ( ) . strip ( ) ) NEW_LINE L1 = [ 0 ] * i NEW_LINE L2 = [ 0 ] * i NEW_LINE L3 = [ 0 ] * i NEW_LINE for k in range ( i ) : NEW_LINE INDENT a = inf . readline ( ) . strip ( ) . split ( ' ▁ ' ) NEW_LINE L1 [ k ] = int ( a [ 0 ] ) NEW_LINE L2 [ k ] = int ( a [ 1 ] ) NEW_LINE L3 [ k ] = int ( a [ 2 ] ) NEW_LINE DEDENT N = sum ( L2 ) NEW_LINE goal = [ ] NEW_LINE for k in range ( len ( L1 ) ) : NEW_LINE INDENT pos = L1 [ k ] NEW_LINE for j in range ( L2 [ k ] ) : NEW_LINE INDENT v = float ( 360 ) \/ ( L3 [ k ] + j ) NEW_LINE goal = goal + [ ( 360. - L1 [ k ] ) \/ v ] NEW_LINE DEDENT DEDENT resultat = [ ] NEW_LINE for t in goal : NEW_LINE INDENT nbrtour = [ ] NEW_LINE for k in range ( len ( L1 ) ) : NEW_LINE INDENT pos = L1 [ k ] NEW_LINE for j in range ( L2 [ k ] ) : NEW_LINE INDENT v = float ( 360 ) \/ ( L3 [ k ] + j ) NEW_LINE nbrtour = nbrtour + [ int ( floor ( ( ( v * t + L1 [ k ] ) ) \/ 360 ) ) ] NEW_LINE DEDENT DEDENT print nbrtour NEW_LINE compteur = 0 NEW_LINE compteur2 = 0 NEW_LINE for k in nbrtour : NEW_LINE INDENT if k == 0 : NEW_LINE INDENT compteur = compteur + 1 NEW_LINE DEDENT else : NEW_LINE INDENT compteur2 = compteur2 + k - 1 NEW_LINE DEDENT DEDENT resultat = resultat + [ compteur + compteur2 ] NEW_LINE DEDENT print resultat NEW_LINE solution = min ( resultat ) NEW_LINE print solution NEW_LINE ouf . write ( \" % d \\n \" % solution ) NEW_LINE DEDENT DEDENT DEDENT DEDENT"],"bleu":0.26245515432530814,"rouge_l":0.390185546875}
{"id":156,"predictions":["import sys NEW_LINE def m ( tab , i ) : NEW_LINE INDENT m = '9' NEW_LINE for x in tab : NEW_LINE INDENT if x > i : NEW_LINE INDENT m = min ( m , x ) NEW_LINE DEDENT DEDENT return m NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT def next_line ( ) : NEW_LINE INDENT return sys . stdin . readline ( ) NEW_LINE DEDENT n = int ( next_line ( ) ) NEW_LINE for nr in range ( 1 , n + 1 ) : NEW_LINE INDENT line = next_line ( ) NEW_LINE t = [ ] NEW_LINE prev = rev [ 0 ] NEW_LINE for pos , i in enumerate ( line [ 1 : ] ) : NEW_LINE INDENT tmp = rev [ pos - 1 : ] NEW_LINE if prev > i : NEW_LINE INDENT subtab = rev [ : ] NEW_LINE break NEW_LINE DEDENT prev = pos NEW_LINE DEDENT return tmp NEW_LINE DEDENT main ( ) NEW_LINE"],"references":["import sys NEW_LINE def sheep ( N ) : NEW_LINE INDENT if N == 0 : return \" INSOMNIA \" NEW_LINE d = 0 ; t = N NEW_LINE while 1 : NEW_LINE INDENT for x in str ( t ) : d |= 1 << int ( x ) NEW_LINE if d == 1023 : return t NEW_LINE t += N NEW_LINE DEDENT DEDENT case = 0 NEW_LINE for x in sys . stdin : NEW_LINE INDENT if case > 0 : NEW_LINE INDENT N = int ( x . strip ( ) ) NEW_LINE print \" Case ▁ # % d : \" % case , sheep ( N ) NEW_LINE DEDENT case += 1 NEW_LINE DEDENT","limit = 1000000 NEW_LINE with open ( ' \/ home \/ gauravjs \/ Documents \/ Google ▁ Code ▁ Jam \/ 2016Q \/ A - large . in ' , ' r ' ) as f : NEW_LINE INDENT cases = int ( f . readline ( ) ) NEW_LINE lines = f . readlines ( ) NEW_LINE DEDENT inputs = [ ] NEW_LINE for i in range ( cases ) : NEW_LINE INDENT n = int ( lines [ i ] ) NEW_LINE m = n NEW_LINE digits = set ( ) NEW_LINE while ( m < n * limit ) and len ( digits ) < 10 : NEW_LINE INDENT q = m NEW_LINE while q > 0 : NEW_LINE INDENT digits . add ( q % 10 ) NEW_LINE q = q \/ 10 NEW_LINE DEDENT m += n NEW_LINE DEDENT if len ( digits ) == 10 : NEW_LINE INDENT print \" Case ▁ # \" + str ( i + 1 ) + \" : ▁ \" + str ( m - n ) NEW_LINE DEDENT else : NEW_LINE INDENT print \" Case ▁ # \" + str ( i + 1 ) + \" : ▁ INSOMNIA \" NEW_LINE DEDENT DEDENT","import os , inspect NEW_LINE problemName = ' counting _ sheep ' NEW_LINE runOnRealData = False NEW_LINE def digits ( N ) : NEW_LINE INDENT return set ( map ( int , str ( N ) ) ) NEW_LINE DEDENT def solution ( N ) : NEW_LINE INDENT if N == 0 : NEW_LINE INDENT return ' INSOMNIA ' NEW_LINE DEDENT allDigits = set ( range ( 10 ) ) NEW_LINE multiple = 0 NEW_LINE while len ( allDigits ) > 0 : NEW_LINE INDENT multiple += N NEW_LINE allDigits = allDigits . difference ( digits ( multiple ) ) NEW_LINE DEDENT return multiple NEW_LINE DEDENT currentDir = os . path . dirname ( os . path . abspath ( inspect . getfile ( inspect . currentframe ( ) ) ) ) NEW_LINE inputString = ' A - large . in ' NEW_LINE outputString = problemName + ' _ output ' NEW_LINE inFile = os . path . join ( currentDir , ' inputfiles ' , inputString ) NEW_LINE outFile = os . path . join ( currentDir , ' outputfiles ' , ' % s . txt ' % outputString ) NEW_LINE if os . path . exists ( outFile ) : NEW_LINE INDENT os . remove ( outFile ) NEW_LINE DEDENT with open ( inFile , ' r ' ) as inputfile : NEW_LINE INDENT numberOfCases = int ( inputfile . readline ( ) ) NEW_LINE for case in xrange ( 1 , numberOfCases + 1 ) : NEW_LINE INDENT N = int ( inputfile . readline ( ) ) NEW_LINE result = solution ( N ) NEW_LINE with open ( outFile , ' a ' ) as f : NEW_LINE INDENT f . write ( ' Case ▁ # % d : ▁ % s \\n ' % ( case , str ( result ) ) ) NEW_LINE DEDENT DEDENT DEDENT","filename = \" A - large \" NEW_LINE fin = open ( filename + \" . in \" , \" r \" ) NEW_LINE fout = open ( filename + \" . out \" , \" w \" ) NEW_LINE casenum = int ( fin . readline ( ) ) NEW_LINE for ite in range ( casenum ) : NEW_LINE INDENT num_count = int ( fin . readline ( ) ) NEW_LINE fulllist = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' ] NEW_LINE currlist = [ ] NEW_LINE total_num = 0 NEW_LINE if num_count == 0 : NEW_LINE INDENT return_str = ' INSOMNIA ' NEW_LINE DEDENT else : NEW_LINE INDENT while len ( currlist ) < len ( fulllist ) : NEW_LINE INDENT total_num += num_count NEW_LINE numstr = str ( total_num ) NEW_LINE for s in numstr : NEW_LINE INDENT if s not in currlist : NEW_LINE INDENT currlist . append ( s ) NEW_LINE DEDENT DEDENT DEDENT return_str = numstr NEW_LINE DEDENT fout . write ( \" Case ▁ # { 0 } : ▁ { 1 } \\n \" . format ( ite + 1 , return_str ) ) NEW_LINE DEDENT","import collections NEW_LINE import math NEW_LINE import re NEW_LINE import sys NEW_LINE INPUT = \" tiny \" NEW_LINE INPUT = \" A - small - attempt0 . in \" NEW_LINE INPUT = \" A - large . in \" NEW_LINE def debug ( * args ) : NEW_LINE INDENT return NEW_LINE sys . stderr . write ( str ( args ) + \" \\n \" ) NEW_LINE DEDENT class Memoize : NEW_LINE INDENT def __init__ ( self , function ) : NEW_LINE INDENT self . _cache = { } NEW_LINE self . _callable = function NEW_LINE DEDENT def __call__ ( self , * args , ** kwds ) : NEW_LINE INDENT cache = self . _cache NEW_LINE key = self . _getKey ( * args , ** kwds ) NEW_LINE try : return cache [ key ] NEW_LINE except KeyError : NEW_LINE INDENT cachedValue = cache [ key ] = self . _callable ( * args , ** kwds ) NEW_LINE return cachedValue NEW_LINE DEDENT DEDENT def _getKey ( self , * args , ** kwds ) : NEW_LINE INDENT return kwds and ( args , ImmutableDict ( kwds ) ) or args NEW_LINE DEDENT DEDENT def do_trial ( N ) : NEW_LINE INDENT seen = [ False ] * 10 NEW_LINE for i in range ( 10000000 ) : NEW_LINE INDENT k = ( i + 1 ) * N NEW_LINE for d in str ( k ) : NEW_LINE INDENT seen [ int ( d ) ] = True NEW_LINE DEDENT if all ( seen ) : NEW_LINE INDENT return k NEW_LINE DEDENT DEDENT return \" INSOMNIA \" NEW_LINE DEDENT f = file ( INPUT ) NEW_LINE T = int ( f . readline ( ) [ : - 1 ] ) NEW_LINE for i in range ( T ) : NEW_LINE INDENT N = int ( f . readline ( ) [ : - 1 ] ) NEW_LINE v = do_trial ( N ) NEW_LINE print \" Case ▁ # % d : ▁ % s \" % ( i + 1 , v ) NEW_LINE DEDENT"],"bleu":0.3437938382847015,"rouge_l":0.42938523834137277}
{"id":157,"predictions":["import sys NEW_LINE def get_ints ( ) : return map ( int , raw_input ( ) . split ( ) ) NEW_LINE def get_ints ( ) : return map ( int , raw_input ( ) . split ( ) ) NEW_LINE def get_input ( ) : return map ( int , raw_input ( ) . split ( ) ) NEW_LINE def get_input ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def get_input ( ) : return int ( raw_input ( ) ) NEW_LINE def get_input ( ) : return [ : return [ int ( x ) for x in raw_input ( ) . split ( ) ] NEW_LINE def get_input ( ) : return get_input ( ) NEW_LINE def solve ( test ) : NEW_LINE INDENT for d in range ( test ) : NEW_LINE INDENT print \" Case ▁ # % d : ▁ % d \" % ( test + 1 , get_input ( ) ) NEW_LINE N = int ( get_input ( ) ) NEW_LINE a = get_input ( ) NEW_LINE b = get_ints ( ) NEW_LINE res = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if i != j : NEW_LINE INDENT res += i NEW_LINE DEDENT DEDENT DEDENT print \" Case ▁ # % d : ▁ % d \" % ( i + 1 , res ) NEW_LINE DEDENT"],"references":["import collections NEW_LINE import sys NEW_LINE if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT f = sys . stdin NEW_LINE if len ( sys . argv ) >= 2 : NEW_LINE INDENT fn = sys . argv [ 1 ] NEW_LINE if fn != ' - ' : NEW_LINE INDENT f = open ( fn ) NEW_LINE DEDENT DEDENT T = int ( f . readline ( ) ) NEW_LINE for _T in xrange ( T ) : NEW_LINE INDENT N , X = map ( int , f . readline ( ) . split ( ) ) NEW_LINE disks = map ( int , f . readline ( ) . split ( ) ) NEW_LINE assert len ( disks ) == N NEW_LINE disks . sort ( ) NEW_LINE disks = collections . deque ( disks ) NEW_LINE r = 0 NEW_LINE while disks : NEW_LINE INDENT x1 = disks . pop ( ) NEW_LINE if disks and x1 + disks [ 0 ] <= X : NEW_LINE INDENT disks . popleft ( ) NEW_LINE DEDENT r += 1 NEW_LINE DEDENT print \" Case ▁ # % d : ▁ % d \" % ( _T + 1 , r ) NEW_LINE DEDENT DEDENT","__author__ = ' Pavel ▁ Mavrin ' NEW_LINE fin = open ( \" A . in \" ) NEW_LINE fout = open ( \" A . out \" , \" w \" ) NEW_LINE test_num = int ( fin . readline ( ) ) NEW_LINE def solve_test ( ) : NEW_LINE INDENT n , x = [ int ( x ) for x in fin . readline ( ) . split ( ) ] NEW_LINE s = [ int ( x ) for x in fin . readline ( ) . split ( ) ] NEW_LINE s . sort ( ) NEW_LINE res = 0 NEW_LINE j = n - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while j > i and s [ i ] + s [ j ] > x : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT if j > i : NEW_LINE INDENT res += 1 NEW_LINE j -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return str ( res + ( n - 2 * res ) ) NEW_LINE DEDENT for test_i in range ( test_num ) : NEW_LINE INDENT s = \" Case ▁ # \" + str ( test_i + 1 ) + \" : ▁ \" + solve_test ( ) NEW_LINE print ( s ) NEW_LINE print ( s , file = fout ) NEW_LINE DEDENT fin . close ( ) NEW_LINE fout . close ( ) NEW_LINE","import sys NEW_LINE def rl ( T ) : NEW_LINE INDENT return list ( map ( T , input ( ) . split ( ) ) ) NEW_LINE DEDENT def solve ( X , S ) : NEW_LINE INDENT if len ( S ) == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if len ( S ) == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if S [ 0 ] + S [ - 1 ] <= X : NEW_LINE INDENT return 1 + solve ( X , S [ 1 : len ( S ) - 1 ] ) NEW_LINE DEDENT if S [ - 1 ] <= X : NEW_LINE INDENT return 1 + solve ( X , S [ 0 : len ( S ) - 1 ] ) NEW_LINE DEDENT raise Exception NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT sys . setrecursionlimit ( 100000 ) NEW_LINE T , = rl ( int ) NEW_LINE for C in range ( 1 , T + 1 ) : NEW_LINE INDENT N , X = rl ( int ) NEW_LINE S = rl ( int ) NEW_LINE S . sort ( ) NEW_LINE ans = solve ( X , S ) NEW_LINE print ( ' Case ▁ # % d : ▁ % d ' % ( C , ans ) ) NEW_LINE DEDENT pass NEW_LINE DEDENT main ( ) NEW_LINE","def solve ( dsize , fsizes ) : NEW_LINE INDENT cnt = 0 NEW_LINE fsizes . sort ( reverse = True ) NEW_LINE while True : NEW_LINE INDENT s , k = None , None NEW_LINE for i in range ( len ( fsizes ) ) : NEW_LINE INDENT if fsizes [ i ] != - 1 : NEW_LINE INDENT s , k = fsizes [ i ] , i NEW_LINE break NEW_LINE DEDENT DEDENT if not s : NEW_LINE INDENT return cnt NEW_LINE DEDENT if k > 100 : NEW_LINE INDENT fsizes = fsizes [ k : ] NEW_LINE k = 0 NEW_LINE DEDENT fsizes [ k ] = - 1 NEW_LINE cnt += 1 NEW_LINE d = None NEW_LINE for i in range ( len ( fsizes ) ) : NEW_LINE INDENT if dsize - s >= fsizes [ i ] and fsizes [ i ] != - 1 : NEW_LINE INDENT d = fsizes [ i ] NEW_LINE j = i NEW_LINE break NEW_LINE DEDENT DEDENT if d and d != - 1 : NEW_LINE INDENT fsizes [ j ] = - 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT import sys NEW_LINE infname = sys . argv [ 1 ] NEW_LINE with open ( infname ) as inf : NEW_LINE INDENT with open ( infname . replace ( ' . in ' , ' . out ' ) , ' w ' ) as outf : NEW_LINE INDENT T = int ( inf . readline ( ) ) NEW_LINE for t in range ( 1 , T + 1 ) : NEW_LINE INDENT n , dsize = map ( int , inf . readline ( ) . split ( ) ) NEW_LINE fsizes = map ( int , inf . readline ( ) . split ( ) ) NEW_LINE outf . write ( ' Case ▁ # { } : ▁ { } \\n ' . format ( t , solve ( dsize , fsizes ) ) ) NEW_LINE DEDENT DEDENT DEDENT","for tc in range ( int ( input ( ) ) ) : NEW_LINE INDENT ( N , X ) = ( int ( x ) for x in input ( ) . split ( ) ) NEW_LINE S = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE S = list ( reversed ( sorted ( S ) ) ) NEW_LINE res = 0 NEW_LINE while S : NEW_LINE INDENT a = S [ 0 ] NEW_LINE found = False NEW_LINE for i , b in enumerate ( S ) : NEW_LINE INDENT if i > 0 and a + b <= X : NEW_LINE INDENT del S [ i ] NEW_LINE del S [ 0 ] NEW_LINE res += 1 NEW_LINE found = True NEW_LINE break NEW_LINE DEDENT DEDENT if not found : NEW_LINE INDENT del S [ 0 ] NEW_LINE res += 1 NEW_LINE DEDENT DEDENT print ( ' Case ▁ # { } : ▁ { } ' . format ( tc + 1 , res ) ) NEW_LINE DEDENT"],"bleu":0.40582655651739613,"rouge_l":0.44384331310315495}
{"id":158,"predictions":["import sys NEW_LINE f = open ( sys . argv [ 1 ] ) NEW_LINE T = int ( f . readline ( ) ) NEW_LINE for tt in range ( T ) : NEW_LINE INDENT ( T ) = int ( f . readline ( ) ) NEW_LINE for i in range ( T ) : NEW_LINE INDENT line = f . readline ( ) . split ( ) NEW_LINE n = int ( line [ 0 ] ) NEW_LINE E = int ( line [ 1 ] ) NEW_LINE a = [ int ( x ) for x in f . readline ( ) . split ( ) ] NEW_LINE b = [ int ( x ) for x in f . readline ( ) . split ( ) ] NEW_LINE a . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT while a [ i ] != i + 1 : NEW_LINE INDENT ans = max ( ans , sum ( a [ i ] ) for i in range ( len ( b ) ) ) NEW_LINE DEDENT DEDENT print \" Case ▁ # % d : ▁ % d \" % ( tt + 1 , ans ) NEW_LINE DEDENT"],"references":["t = int ( raw_input ( ) ) NEW_LINE for cas in xrange ( 1 , t + 1 ) : NEW_LINE INDENT n = int ( raw_input ( ) ) NEW_LINE ct = dict ( zip ( xrange ( 1 , 2501 ) , [ 0 for i in xrange ( 1 , 2501 ) ] ) ) NEW_LINE for i in xrange ( 1 , 2 * n ) : NEW_LINE INDENT nums = map ( int , raw_input ( ) . split ( ) ) NEW_LINE for num in nums : NEW_LINE INDENT ct [ num ] += 1 NEW_LINE DEDENT DEDENT ans = [ ] NEW_LINE for i in ct : NEW_LINE INDENT if ct [ i ] % 2 == 1 : NEW_LINE INDENT ans . append ( i ) NEW_LINE DEDENT DEDENT ans . sort ( ) NEW_LINE ans = \" ▁ \" . join ( map ( str , ans ) ) NEW_LINE print \" Case ▁ # { } : ▁ { } \" . format ( cas , ans ) NEW_LINE DEDENT","import jam NEW_LINE import sys NEW_LINE sys . setrecursionlimit ( 10000 ) NEW_LINE def solve ( case ) : NEW_LINE INDENT N = case . readInt ( ) NEW_LINE lists = [ ] NEW_LINE for i in range ( 2 * N - 1 ) : NEW_LINE INDENT lists . append ( [ case . readInt ( ) for i2 in range ( N ) ] ) NEW_LINE DEDENT count = { } NEW_LINE for q in lists : NEW_LINE INDENT for h in q : NEW_LINE INDENT if h in count : NEW_LINE INDENT count [ h ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count [ h ] = 1 NEW_LINE DEDENT DEDENT DEDENT result = [ ] NEW_LINE for h in count : NEW_LINE INDENT if count [ h ] % 2 == 1 : NEW_LINE INDENT result . append ( h ) NEW_LINE DEDENT DEDENT result . sort ( ) NEW_LINE return \" ▁ \" . join ( str ( h ) for h in result ) NEW_LINE DEDENT jam . run ( \" B - large . in \" , solve ) NEW_LINE","task = ' B ' NEW_LINE type = 2 NEW_LINE from collections import Counter NEW_LINE if type == 0 : NEW_LINE INDENT inp = open ( ' sample . in ' , ' r ' ) NEW_LINE DEDENT elif type == 1 : NEW_LINE INDENT inp = open ( ' % s - small . in ' % ( task , ) ) NEW_LINE DEDENT else : NEW_LINE INDENT inp = open ( ' % s - large . in ' % ( task ) , ) NEW_LINE DEDENT outp = open ( ' % s . out ' % ( task , ) , ' w ' ) NEW_LINE T = int ( inp . readline ( ) [ : - 1 ] ) NEW_LINE for i in range ( T ) : NEW_LINE INDENT ans = [ ] NEW_LINE N = int ( inp . readline ( ) [ : - 1 ] ) NEW_LINE c = Counter ( ) NEW_LINE for j in range ( 2 * N - 1 ) : NEW_LINE INDENT s = inp . readline ( ) [ : - 1 ] . split ( ) NEW_LINE for k in s : NEW_LINE INDENT c [ k ] += 1 NEW_LINE DEDENT DEDENT for val in c . items ( ) : NEW_LINE INDENT if val [ 1 ] % 2 == 1 : NEW_LINE INDENT ans . append ( val [ 0 ] ) NEW_LINE DEDENT DEDENT ans . sort ( key = int ) NEW_LINE outp . write ( \" Case ▁ # % s : ▁ % s \\n \" % ( i + 1 , \" ▁ \" . join ( ans ) ) ) NEW_LINE DEDENT","from sys import stdin , stdout NEW_LINE def solve ( test_id ) : NEW_LINE INDENT n = int ( stdin . readline ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( n * 2 - 1 ) : NEW_LINE INDENT a . extend ( int ( x ) for x in stdin . readline ( ) . split ( ) ) NEW_LINE DEDENT a = sorted ( a ) NEW_LINE r = [ ] NEW_LINE i = 0 NEW_LINE while i < len ( a ) : NEW_LINE INDENT if i + 1 < len ( a ) and a [ i ] == a [ i + 1 ] : NEW_LINE INDENT i += 2 NEW_LINE DEDENT else : NEW_LINE INDENT r . append ( a [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT print ( \" Case ▁ # { } : \" . format ( test_id ) , * r ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT t = int ( stdin . readline ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT solve ( i + 1 ) NEW_LINE DEDENT DEDENT main ( ) NEW_LINE","from collections import Counter NEW_LINE import sys NEW_LINE def compute ( N , A ) : NEW_LINE INDENT x = [ a for b in A for a in b ] NEW_LINE c = Counter ( x ) NEW_LINE z = filter ( lambda a : a [ 1 ] % 2 == 1 , c . iteritems ( ) ) NEW_LINE z = sorted ( [ int ( a [ 0 ] ) for a in z ] ) NEW_LINE return \" ▁ \" . join ( map ( str , z ) ) NEW_LINE DEDENT def parse ( ) : NEW_LINE INDENT N = int ( sys . stdin . readline ( ) . strip ( ) ) NEW_LINE A = [ ] NEW_LINE for i in xrange ( N + N - 1 ) : NEW_LINE INDENT A . append ( sys . stdin . readline ( ) . strip ( ) . split ( ) ) NEW_LINE DEDENT return N , A NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT sys . setrecursionlimit ( 100000 ) NEW_LINE T = int ( sys . stdin . readline ( ) . strip ( ) ) NEW_LINE count = 1 NEW_LINE part = 0 NEW_LINE if len ( sys . argv ) == 3 : NEW_LINE INDENT part = int ( sys . argv [ 1 ] ) NEW_LINE count = int ( sys . argv [ 2 ] ) NEW_LINE DEDENT for i in xrange ( T ) : NEW_LINE INDENT data = parse ( ) NEW_LINE if i * count >= part * T and i * count < ( part + 1 ) * T : NEW_LINE INDENT result = compute ( * data ) NEW_LINE print \" Case ▁ # % d : ▁ % s \" % ( i + 1 , result ) NEW_LINE DEDENT DEDENT DEDENT"],"bleu":0.5696707240360709,"rouge_l":0.4963166741566338}
{"id":159,"predictions":["with open ( ' A - large . in ' , ' r ' ) as f : NEW_LINE INDENT with open ( ' output . txt ' , ' w ' ) as f : NEW_LINE INDENT numCases = int ( f . readline ( ) ) NEW_LINE for case in range ( numCases ) : NEW_LINE INDENT line = f . readline ( ) . split ( ) NEW_LINE N = int ( line [ 0 ] ) NEW_LINE p = line [ 1 ] NEW_LINE N = int ( line [ 0 ] ) NEW_LINE line = f . readline ( ) . split ( ) NEW_LINE first = 1 NEW_LINE 2 = int ( line [ 1 ] ) NEW_LINE line = line [ 2 ] NEW_LINE first = 1 NEW_LINE for i in line : NEW_LINE INDENT if line [ 0 ] == line [ 1 ] : NEW_LINE INDENT first += 1 NEW_LINE DEDENT elif line [ 1 ] < line [ 2 ] : NEW_LINE INDENT second += 1 NEW_LINE DEDENT DEDENT DEDENT totalCases = int ( line [ 2 * line [ 1 ] ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT line = f . readline ( ) . split ( ) NEW_LINE second = float ( line [ 1 ] ) NEW_LINE third = int ( line [ 2 * i ] ) NEW_LINE for j in range ( N ) : NEW_LINE INDENT if line [ j ] > first : NEW_LINE INDENT second = float ( line [ j ] ) NEW_LINE third = j NEW_LINE DEDENT DEDENT DEDENT output = \" Case ▁ # % d : ▁ % s \" % ( case , answer ) NEW_LINE outfile . write ( output ) NEW_LINE print \" Case ▁ # % d : ▁ % s \" % ( case + 1 , answer ) NEW_LINE DEDENT DEDENT"],"references":["A = 3 NEW_LINE B = 1 NEW_LINE n = 1 NEW_LINE tmp = 0 NEW_LINE X = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] NEW_LINE Y = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] NEW_LINE while n < 31 : NEW_LINE INDENT X [ n ] = A NEW_LINE Y [ n ] = B NEW_LINE tmp = 3 * A + B * 5 NEW_LINE B = A + 3 * B NEW_LINE A = tmp NEW_LINE n = n + 1 NEW_LINE DEDENT d = 22360679774997896964091736687312762354406183596115257242708972454105209256378048 NEW_LINE N = input ( ) NEW_LINE n = 0 NEW_LINE while n < N : NEW_LINE INDENT n = n + 1 NEW_LINE f = input ( ) NEW_LINE p = X [ f ] + int ( Y [ f ] * d \/ 10000000000000000000000000000000000000000000000000000000000000000000000000000000 ) NEW_LINE print \" Case ▁ # % d : ▁ % .3d \" % ( n , int ( p ) % 1000 ) NEW_LINE DEDENT","from __future__ import division NEW_LINE from operator import itemgetter NEW_LINE from math import sqrt NEW_LINE from mpmath import * NEW_LINE def main ( ) : NEW_LINE INDENT entrada = open ( ' C - large . in ' , ' r ' ) NEW_LINE saida = open ( ' grade . out ' , ' w ' ) NEW_LINE casos = int ( entrada . readline ( ) ) NEW_LINE mp . dps = 100 NEW_LINE calculo = [ '143' , '751' , '935' , '607' , '903' , '991' , '335' , '047' , '943' , '471' , '055' , '447' , '463' , '991' , '095' , '607' , '263' , '151' , '855' , '527' , '743' , '351' , '135' , '407' , '903' , '791' , '135' , '647' , '343' , '471' , '455' , '847' , '263' , '191' , '095' , '807' , '463' , '551' , '455' , '527' , '343' , '951' , '335' , '207' , '903' , '591' , '935' , '247' , '743' , '471' , '855' , '247' , '063' , '391' , '095' , '007' , '663' , '951' , '055' , '527' , '943' , '551' , '535' , '007' , '903' , '391' , '735' , '847' , '143' , '471' , '255' , '647' , '863' , '591' , '095' , '207' , '863' , '351' , '655' , '527' , '543' , '151' , '735' , '807' , '903' , '191' , '535' , '447' , '543' , '471' , '655' , '047' , '663' , '791' , '095' , '407' , '063' , '751' , '255' , '527' ] NEW_LINE for caso in range ( 1 , casos + 1 ) : NEW_LINE INDENT numero = int ( entrada . readline ( ) ) NEW_LINE if numero == 0 : NEW_LINE INDENT saida . write ( \" Case ▁ # % i : ▁ 001 \\n \" % ( caso ) ) NEW_LINE continue NEW_LINE DEDENT if numero == 1 : NEW_LINE INDENT saida . write ( \" Case ▁ # % i : ▁ 005 \\n \" % ( caso ) ) NEW_LINE continue NEW_LINE DEDENT if numero == 2 : NEW_LINE INDENT saida . write ( \" Case ▁ # % i : ▁ 027 \\n \" % ( caso ) ) NEW_LINE continue NEW_LINE DEDENT print calculo [ numero % len ( calculo ) - 3 ] NEW_LINE saida . write ( \" Case ▁ # % i : ▁ % s \\n \" % ( caso , calculo [ numero % len ( calculo ) - 3 ] ) ) NEW_LINE DEDENT entrada . close ( ) NEW_LINE saida . close ( ) NEW_LINE print \" Tchau ▁ e ▁ obrigado ▁ pelos ▁ peixes ! \" NEW_LINE DEDENT main ( ) NEW_LINE","import sys NEW_LINE import psyco NEW_LINE psyco . full ( ) NEW_LINE class EOF ( Exception ) : NEW_LINE INDENT pass NEW_LINE DEDENT class CodeJam ( object ) : NEW_LINE INDENT def __init__ ( self , file = None , debug = False ) : NEW_LINE INDENT if not file : NEW_LINE INDENT if len ( sys . argv ) > 1 : NEW_LINE INDENT file = sys . argv [ 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT raise ValueError ( ' You ▁ MUST ▁ specify ▁ one ▁ input ▁ file ' ) NEW_LINE DEDENT DEDENT self . _debug = debug NEW_LINE self . _file = open ( file ) NEW_LINE self . _outfile = open ( \" % s . out \" % file , ' w ' ) NEW_LINE self . _current_case = - 1 NEW_LINE self . pos = 0 NEW_LINE DEDENT def get_lines ( self , count = 1 ) : NEW_LINE INDENT try : NEW_LINE INDENT value = [ self . _file . next ( ) [ : - 1 ] for i in xrange ( count ) ] NEW_LINE self . debug ( \" Getting ▁ % d ▁ line ( s ) \" % count ) NEW_LINE DEDENT except StopIteration : NEW_LINE INDENT raise EOF ( ' End ▁ of ▁ file ' ) NEW_LINE DEDENT self . pos += 1 NEW_LINE return value NEW_LINE DEDENT def get_int ( self ) : NEW_LINE INDENT try : NEW_LINE INDENT value = int ( self . _file . next ( ) ) NEW_LINE DEDENT except StopIteration : NEW_LINE INDENT raise EOF ( ' End ▁ of ▁ file ' ) NEW_LINE DEDENT except ValueError : NEW_LINE INDENT raise ValueError ( ' This ▁ line ▁ is ▁ not ▁ a ▁ number ' ) NEW_LINE DEDENT self . pos += 1 NEW_LINE self . debug ( \" Getting ▁ int : ▁ % d \" % value ) NEW_LINE return value NEW_LINE DEDENT def write_case ( self , text , tpl = ' Case ▁ # % d : ▁ % s \\n ' ) : NEW_LINE INDENT assert self . _current_case > - 1 , text = tpl % ( self . _current_case + 1 , text ) NEW_LINE self . _outfile . write ( text ) NEW_LINE self . debug ( \" Writing ▁ % s ▁ into ▁ output ▁ file \" % repr ( text ) ) NEW_LINE DEDENT def debug ( self , text ) : NEW_LINE INDENT if self . _debug : NEW_LINE INDENT print text NEW_LINE DEDENT DEDENT def get_cases ( self ) : NEW_LINE INDENT for self . _current_case in xrange ( self . get_int ( ) ) : NEW_LINE INDENT yield self . _current_case NEW_LINE DEDENT DEDENT cases = property ( get_cases ) NEW_LINE def __del__ ( self ) : NEW_LINE INDENT if hasattr ( self , ' _ file ' ) : NEW_LINE INDENT self . _outfile . close ( ) NEW_LINE self . _file . close ( ) NEW_LINE DEDENT DEDENT DEDENT","import math NEW_LINE import sys NEW_LINE def coolpow ( x , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return x NEW_LINE DEDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n % 2 == 0 ) : NEW_LINE INDENT y = coolpow ( x , n \/ 2 ) NEW_LINE return y * y NEW_LINE DEDENT return x * coolpow ( x , n - 1 ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT sq = 52360679774997896964091736687312762354406183596115257242708972454105209256378048994144144083787822749695081761507737835042532677244470738635863601215334527088667781731918791658112766453226398565805357613504175337850034233924140644420864325390972525926272288762995174024406816117759089094984923713907297288984820886415426898940991316935770197486788844250897541329561831769214999774248015304341150359576683325124988151781394080005624208552435422355561063063428202340933319829339597463522712013417496142026359047378855043896870611356600457571399565955669569175645782219525000605392312340050092867648755297220567662536660744858535052623306784946334222423176372770266324076801044433158257335058930981362263431986864719469899701808189524264459620345221411922329125981963258111041704958070481204034559949435068555518555725123886416550102624363125710244496187894246829034044747161154557232017376765904609185295756035779843980541553807790643936397230287560629994822138521773485924535151210463455550407072278724215347787529112121211843317893351910380080111181790045906188462496471042442483088801294068113146959532794478989989316915774607924618075006798771242048473805027736082915599139624489149435606834625290644083279446426808889897460463083535378750420613747576068834018790881925591179735744641902485378711461940901919136880351103976384360412810581103786989518520146970456420217638928908844463778263858937924400460288754053984601560617052236150 L NEW_LINE dd = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 L NEW_LINE c = int ( raw_input ( ) ) NEW_LINE for i in range ( 0 , c ) : NEW_LINE INDENT n = int ( raw_input ( ) ) NEW_LINE r = coolpow ( sq , n ) \/ coolpow ( dd , n ) NEW_LINE print \" Case ▁ # % d : ▁ % 03d \" % ( i + 1 , r % 1000 ) NEW_LINE DEDENT DEDENT main ( ) NEW_LINE","T = int ( raw_input ( ) ) NEW_LINE for X in range ( 1 , T + 1 ) : NEW_LINE INDENT n = int ( raw_input ( ) ) NEW_LINE if n == 2 : NEW_LINE INDENT Y = '027' NEW_LINE DEDENT else : NEW_LINE INDENT Y = [ '751' , '255' , '527' , '143' , '751' , '935' , '607' , '903' , '991' , '335' , '047' , '943' , '471' , '055' , '447' , '463' , '991' , '095' , '607' , '263' , '151' , '855' , '527' , '743' , '351' , '135' , '407' , '903' , '791' , '135' , '647' , '343' , '471' , '455' , '847' , '263' , '191' , '095' , '807' , '463' , '551' , '455' , '527' , '343' , '951' , '335' , '207' , '903' , '591' , '935' , '247' , '743' , '471' , '855' , '247' , '063' , '391' , '095' , '007' , '663' , '951' , '055' , '527' , '943' , '551' , '535' , '007' , '903' , '391' , '735' , '847' , '143' , '471' , '255' , '647' , '863' , '591' , '095' , '207' , '863' , '351' , '655' , '527' , '543' , '151' , '735' , '807' , '903' , '191' , '535' , '447' , '543' , '471' , '655' , '047' , '663' , '791' , '095' , '407' , '063' ] [ n % 100 ] NEW_LINE DEDENT print ' Case ▁ # % d : ' % X , Y NEW_LINE DEDENT"],"bleu":0.31000701213942955,"rouge_l":0.433573966325112}
{"id":160,"predictions":["import math NEW_LINE def numberofsteps ( lst , bites ) : NEW_LINE INDENT output = bites NEW_LINE for item in lst : NEW_LINE INDENT output += ( int ( math . ceil ( item \/ bites ) ) - 1 ) NEW_LINE DEDENT return output NEW_LINE DEDENT def process ( lst ) : NEW_LINE INDENT m = max ( lst ) NEW_LINE return min ( [ numberofsteps ( lst , x ) for x in range ( 1 , m + 1 ) ] ) NEW_LINE DEDENT import sys NEW_LINE with open ( sys . argv [ 1 ] , \" r \" ) as fileIN : NEW_LINE INDENT inputLines = fileIN . readlines ( ) NEW_LINE DEDENT inputLines = [ line . strip ( ) for line in inputLines ] NEW_LINE with open ( sys . argv [ 2 ] , \" w \" ) as fileOUT : NEW_LINE INDENT numberOfCases = int ( inputLines . pop ( 0 ) ) NEW_LINE for num in range ( numberOfCases ) : NEW_LINE INDENT numberofplates = int ( inputLines . pop ( 0 ) ) NEW_LINE inputlist = [ int ( x ) for x in inputLines . pop ( 0 ) . rstrip ( ) . split ( ' ▁ ' ) ] NEW_LINE fileOUT . write ( ' Case ▁ # % d : ▁ ' % ( num , process ( inputlist ) ) NEW_LINE DEDENT DEDENT"],"references":["testSum = input ( ) NEW_LINE for test in xrange ( testSum ) : NEW_LINE INDENT c , d , v = map ( int , raw_input ( ) . split ( ) ) NEW_LINE coins = map ( int , raw_input ( ) . split ( ) ) NEW_LINE ansCoins = [ ] NEW_LINE now = 0 NEW_LINE ans = 0 NEW_LINE i = 0 NEW_LINE while now < v : NEW_LINE INDENT if i < len ( coins ) and ( coins [ i ] <= now + 1 ) : NEW_LINE INDENT ansCoins . append ( coins [ i ] ) NEW_LINE now = now + coins [ i ] * c NEW_LINE i = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ansCoins . append ( now + 1 ) NEW_LINE ans = ans + 1 NEW_LINE now = now + ( now + 1 ) * c NEW_LINE DEDENT DEDENT print \" Case ▁ # \" + str ( test + 1 ) + \" : \" , ans NEW_LINE DEDENT","def pr ( * a ) : NEW_LINE INDENT return NEW_LINE for x in a : print x , NEW_LINE print NEW_LINE DEDENT def maxcan ( C , ds ) : NEW_LINE INDENT m = [ 0 ] * len ( ds ) NEW_LINE if ds [ 0 ] == 1 : NEW_LINE INDENT m [ 0 ] = C NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( 1 , len ( ds ) ) : NEW_LINE INDENT d = ds [ i ] NEW_LINE if d > m [ i - 1 ] + 1 : NEW_LINE INDENT return m [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT m [ i ] = C * d + m [ i - 1 ] NEW_LINE DEDENT DEDENT return m [ - 1 ] NEW_LINE DEDENT def solve ( C , ds , V ) : NEW_LINE INDENT mx = maxcan ( C , ds ) NEW_LINE newd = 0 NEW_LINE while mx < V : NEW_LINE INDENT ds . append ( mx + 1 ) NEW_LINE ds . sort ( ) NEW_LINE pr ( ds ) NEW_LINE newd += 1 NEW_LINE mx = maxcan ( C , ds ) NEW_LINE DEDENT return newd NEW_LINE DEDENT import sys NEW_LINE f = open ( sys . argv [ 1 ] ) NEW_LINE out_fname = sys . argv [ 1 ] [ : - 2 ] + \" out \" NEW_LINE out = open ( out_fname , \" w \" ) NEW_LINE T = int ( f . readline ( ) . strip ( ) ) NEW_LINE for tc in range ( 1 , T + 1 ) : NEW_LINE INDENT C , D , V = [ int ( x ) for x in f . readline ( ) . strip ( ) . split ( ) ] NEW_LINE pr ( C , D , V ) NEW_LINE ds = [ int ( x ) for x in f . readline ( ) . strip ( ) . split ( ) ] NEW_LINE pr ( ds ) NEW_LINE assert len ( ds ) == D NEW_LINE rt = solve ( C , ds , V ) NEW_LINE pr ( \" Case ▁ # % d : ▁ % s \" % ( tc , str ( rt ) ) ) NEW_LINE pr ( \" = \" * 20 ) NEW_LINE print >> out , \" Case ▁ # % d : ▁ % s \" % ( tc , str ( rt ) ) NEW_LINE DEDENT out . close ( ) NEW_LINE","T = int ( raw_input ( ) ) NEW_LINE for testcase in range ( T ) : NEW_LINE INDENT [ c , d , v ] = [ int ( x ) for x in raw_input ( ) . split ( ) ] NEW_LINE old_denominations = [ int ( x ) for x in raw_input ( ) . split ( ) ] NEW_LINE old_denominations . sort ( ) NEW_LINE cashmoneys = 0 NEW_LINE new_denominations = [ ] NEW_LINE while cashmoneys < v : NEW_LINE INDENT if not old_denominations or old_denominations [ 0 ] > cashmoneys + 1 : NEW_LINE INDENT new_denominations . append ( cashmoneys + 1 ) NEW_LINE cashmoneys += c * ( cashmoneys + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT while old_denominations and old_denominations [ 0 ] <= cashmoneys + 1 : NEW_LINE INDENT cashmoneys += c * ( old_denominations [ 0 ] ) NEW_LINE old_denominations . pop ( 0 ) NEW_LINE DEDENT DEDENT DEDENT print \" Case ▁ # % s : ▁ % s \" % ( testcase + 1 , len ( new_denominations ) ) NEW_LINE DEDENT","def read_array ( convertor = None ) : NEW_LINE INDENT ret = raw_input ( ) . split ( ) NEW_LINE if convertor : ret = map ( convertor , ret ) NEW_LINE return ret NEW_LINE DEDENT def check ( Ds , C , V ) : NEW_LINE INDENT Ds . sort ( ) NEW_LINE for i in range ( 1 , 1 + len ( Ds ) ) : NEW_LINE INDENT if i == len ( Ds ) : NEW_LINE INDENT pre_sum = C * sum ( Ds ) NEW_LINE if pre_sum >= V : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return pre_sum + 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT pre_sum = C * sum ( Ds [ : i ] ) NEW_LINE if pre_sum >= V : NEW_LINE INDENT return 0 NEW_LINE DEDENT if pre_sum + 1 < Ds [ i ] : NEW_LINE INDENT return pre_sum + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT def main ( ) : NEW_LINE INDENT for t in range ( 1 , 1 + input ( ) ) : NEW_LINE INDENT C , D , V = read_array ( int ) NEW_LINE Ds = read_array ( int ) NEW_LINE if 1 not in Ds : NEW_LINE INDENT Ds . append ( 1 ) NEW_LINE DEDENT while True : NEW_LINE INDENT need = check ( Ds , C , V ) NEW_LINE if need == 0 : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT Ds . append ( need ) NEW_LINE DEDENT DEDENT print \" Case ▁ # % d : ▁ % d \" % ( t , len ( Ds ) - D ) NEW_LINE DEDENT DEDENT main ( ) NEW_LINE","import os NEW_LINE import sys NEW_LINE problem_id = ' C ' NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE input_path = ' % s . in ' % problem_id NEW_LINE output_path = ' % s . out ' % problem_id NEW_LINE def read_line ( ) : NEW_LINE INDENT line = ' ' NEW_LINE while len ( line ) == 0 : NEW_LINE INDENT line = input_file . readline ( ) . strip ( ) NEW_LINE DEDENT return line NEW_LINE DEDENT def write_line ( line ) : NEW_LINE INDENT print line NEW_LINE return output_file . write ( line + os . linesep ) NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT c , d , v = map ( int , read_line ( ) . split ( ' ▁ ' ) ) NEW_LINE ds = [ 0 ] * 200 NEW_LINE i = 0 NEW_LINE for num in map ( int , read_line ( ) . split ( ' ▁ ' ) ) : NEW_LINE INDENT ds [ i ] = num NEW_LINE i += 1 NEW_LINE DEDENT mmax = 0 NEW_LINE mcur = 0 NEW_LINE nc = 0 NEW_LINE ptr = 0 NEW_LINE while mmax < v : NEW_LINE INDENT if mmax >= ds [ ptr ] - 1 and ptr < d : NEW_LINE INDENT mcur = ds [ ptr ] NEW_LINE ptr += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mcur = mmax + 1 NEW_LINE nc += 1 NEW_LINE DEDENT mmax += mcur * c NEW_LINE DEDENT return nc NEW_LINE DEDENT input_file = open ( input_path , \" r \" ) NEW_LINE output_file = open ( output_path , \" w + \" ) NEW_LINE T = int ( read_line ( ) ) NEW_LINE for case_id in xrange ( 1 , T + 1 ) : NEW_LINE INDENT write_line ( \" Case ▁ # % d : ▁ % s \" % ( case_id , solve ( ) ) ) NEW_LINE DEDENT input_file . close ( ) NEW_LINE output_file . close ( ) NEW_LINE"],"bleu":0.4138005030785812,"rouge_l":0.45026740429841866}
{"id":161,"predictions":["def solve ( ) : NEW_LINE INDENT n , a , b , c = ( int ( x ) for x in input ( ) . split ( ) ) NEW_LINE ans = [ ] NEW_LINE for a in range ( 2 , n + 1 ) : NEW_LINE INDENT for x in range ( a , b + 1 ) : NEW_LINE INDENT if x + 1 <= a : NEW_LINE INDENT ans . append ( x + 1 ) NEW_LINE DEDENT DEDENT b -= 1 NEW_LINE if a < 0 : NEW_LINE INDENT ans . append ( ( a + 1 ) \/ 2 ) NEW_LINE DEDENT b = 0 NEW_LINE for x in ans : NEW_LINE INDENT if x + 1 <= b : NEW_LINE INDENT ans . append ( x ) NEW_LINE DEDENT else : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT for i in range ( readint ( ) ) : NEW_LINE INDENT print ( solve ( ) ) NEW_LINE DEDENT"],"references":["from __future__ import division NEW_LINE import collections NEW_LINE import itertools NEW_LINE import sys NEW_LINE import copy NEW_LINE class gcj : NEW_LINE INDENT IN = sys . stdin NEW_LINE number = 0 NEW_LINE @ classmethod NEW_LINE def case ( cls ) : NEW_LINE INDENT cls . number += 1 NEW_LINE return ' Case ▁ # % d : ' % cls . number NEW_LINE DEDENT @ classmethod NEW_LINE def line ( cls , type = str ) : NEW_LINE INDENT line = cls . IN . readline ( ) NEW_LINE return type ( line . strip ( ' \\n ' ) ) NEW_LINE DEDENT @ classmethod NEW_LINE def splitline ( cls , type = str ) : NEW_LINE INDENT line = cls . IN . readline ( ) NEW_LINE return [ type ( x ) for x in line . split ( ) ] NEW_LINE DEDENT DEDENT def go ( ) : NEW_LINE INDENT c = gcj . line ( int ) NEW_LINE for _ in xrange ( c ) : NEW_LINE INDENT r = gcj . line ( int ) NEW_LINE grid = [ [ 0 ] * 101 for _ in xrange ( 101 ) ] NEW_LINE for _ in xrange ( r ) : NEW_LINE INDENT x1 , y1 , x2 , y2 = gcj . splitline ( int ) NEW_LINE for x in xrange ( x1 , x2 + 1 ) : NEW_LINE INDENT for y in xrange ( y1 , y2 + 1 ) : NEW_LINE INDENT grid [ x ] [ y ] = 1 NEW_LINE DEDENT DEDENT DEDENT print gcj . case ( ) , solve ( grid ) NEW_LINE DEDENT DEDENT def solve ( grid ) : NEW_LINE INDENT t = 0 NEW_LINE while True : NEW_LINE INDENT done = True NEW_LINE for x in xrange ( 100 , 0 , - 1 ) : NEW_LINE INDENT for y in xrange ( 100 , 0 , - 1 ) : NEW_LINE INDENT if grid [ x ] [ y ] == 1 : NEW_LINE INDENT done = False NEW_LINE DEDENT if grid [ x - 1 ] [ y ] == grid [ x ] [ y - 1 ] : NEW_LINE INDENT grid [ x ] [ y ] = grid [ x ] [ y - 1 ] NEW_LINE DEDENT DEDENT DEDENT if done : NEW_LINE INDENT return t NEW_LINE DEDENT t += 1 NEW_LINE DEDENT DEDENT go ( ) NEW_LINE","filename = ' C - small ' NEW_LINE N = 110 NEW_LINE fin = open ( filename + ' . in ' ) NEW_LINE fout = open ( filename + ' . out ' , ' w ' ) NEW_LINE cases = int ( fin . readline ( ) . strip ( ) ) NEW_LINE for case in xrange ( 1 , cases + 1 ) : NEW_LINE INDENT map1 = [ ] NEW_LINE map2 = [ ] NEW_LINE for p in xrange ( N ) : NEW_LINE INDENT map1 . append ( [ False ] * N ) NEW_LINE map2 . append ( [ False ] * N ) NEW_LINE DEDENT r = int ( fin . readline ( ) . strip ( ) ) NEW_LINE for p in xrange ( r ) : NEW_LINE INDENT x1 , y1 , x2 , y2 = [ int ( x ) for x in fin . readline ( ) . strip ( ) . split ( ) ] NEW_LINE for i in xrange ( x1 , x2 + 1 ) : NEW_LINE INDENT for j in xrange ( y1 , y2 + 1 ) : NEW_LINE INDENT map1 [ i ] [ j ] = True NEW_LINE map2 [ i ] [ j ] = True NEW_LINE DEDENT DEDENT DEDENT r = 0 NEW_LINE while True : NEW_LINE INDENT s = 0 NEW_LINE r += 1 NEW_LINE for i in xrange ( 1 , N ) : NEW_LINE INDENT for j in xrange ( 1 , N ) : NEW_LINE INDENT if map1 [ i ] [ j ] : NEW_LINE INDENT if not map1 [ i - 1 ] [ j ] and not map1 [ i ] [ j - 1 ] : NEW_LINE INDENT map2 [ i ] [ j ] = False NEW_LINE DEDENT else : NEW_LINE INDENT map2 [ i ] [ j ] = True NEW_LINE s += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if map1 [ i - 1 ] [ j ] and map1 [ i ] [ j - 1 ] : NEW_LINE INDENT map2 [ i ] [ j ] = True NEW_LINE s += 1 NEW_LINE DEDENT else : NEW_LINE INDENT map2 [ i ] [ j ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT map1 , map2 = map2 , map1 NEW_LINE if s == 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print r NEW_LINE fout . write ( ' Case ▁ # % d : ▁ % d \\n ' % ( case , r ) ) NEW_LINE DEDENT fin . close ( ) NEW_LINE fout . close ( ) NEW_LINE","import sys NEW_LINE import psyco NEW_LINE psyco . full ( ) NEW_LINE def dbg ( a ) : sys . stderr . write ( str ( a ) ) NEW_LINE def readint ( ) : return int ( raw_input ( ) ) NEW_LINE def readfloat ( ) : return float ( raw_input ( ) ) NEW_LINE def readarray ( foo ) : return [ foo ( x ) for x in raw_input ( ) . split ( ) ] NEW_LINE def run_test ( test ) : NEW_LINE INDENT R = readint ( ) NEW_LINE xy = [ readarray ( int ) for i in xrange ( R ) ] NEW_LINE cur = { } NEW_LINE for ( x1 , y1 , x2 , y2 ) in xy : NEW_LINE INDENT for x in xrange ( x1 , x2 + 1 ) : NEW_LINE INDENT for y in xrange ( y1 , y2 + 1 ) : NEW_LINE INDENT cur [ ( x , y ) ] = True NEW_LINE DEDENT DEDENT DEDENT res = - 1 NEW_LINE for T in xrange ( 10000 ) : NEW_LINE INDENT next = { } NEW_LINE for ( x , y ) in cur : NEW_LINE INDENT if ( x - 1 , y ) in cur or ( x , y - 1 ) in cur : NEW_LINE INDENT next [ ( x , y ) ] = True NEW_LINE DEDENT if ( x - 1 , y + 1 ) in cur : NEW_LINE INDENT next [ ( x , y + 1 ) ] = True NEW_LINE DEDENT DEDENT if len ( next ) == 0 : NEW_LINE INDENT res = T + 1 NEW_LINE break NEW_LINE DEDENT cur = next NEW_LINE DEDENT print \" Case ▁ # % d : ▁ % d \" % ( test + 1 , res ) NEW_LINE DEDENT for test in range ( readint ( ) ) : NEW_LINE INDENT dbg ( \" Test ▁ % d \\n \" % ( test + 1 ) ) NEW_LINE run_test ( test ) NEW_LINE DEDENT","import sys NEW_LINE def line ( ) : NEW_LINE INDENT return sys . stdin . readline ( ) [ : - 1 ] NEW_LINE DEDENT def readList ( ) : NEW_LINE INDENT return map ( eval , line ( ) . split ( ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT numberOfCases = eval ( line ( ) ) NEW_LINE for caseNumber in range ( numberOfCases ) : NEW_LINE INDENT R = eval ( line ( ) ) NEW_LINE currentWorld = set ( ) NEW_LINE for k in range ( R ) : NEW_LINE INDENT X1 , Y1 , X2 , Y2 = readList ( ) NEW_LINE for i in range ( X1 , X2 + 1 ) : NEW_LINE INDENT for j in range ( Y1 , Y2 + 1 ) : NEW_LINE INDENT currentWorld . add ( ( i , j ) ) NEW_LINE DEDENT DEDENT DEDENT time = 0 NEW_LINE while len ( currentWorld ) > 0 : NEW_LINE INDENT newWorld = set ( ) NEW_LINE for ( i , j ) in list ( currentWorld ) : NEW_LINE INDENT if ( i , j - 1 ) in currentWorld or ( i - 1 , j ) in currentWorld : NEW_LINE INDENT newWorld . add ( ( i , j ) ) NEW_LINE DEDENT if ( i - 1 , j + 1 ) in currentWorld and ( i , j + 1 ) not in currentWorld : NEW_LINE INDENT newWorld . add ( ( i , j + 1 ) ) NEW_LINE DEDENT if ( i + 1 , j - 1 ) in currentWorld and ( i + 1 , j ) not in currentWorld : NEW_LINE INDENT newWorld . add ( ( i + 1 , j ) ) NEW_LINE DEDENT DEDENT currentWorld = newWorld NEW_LINE time += 1 NEW_LINE DEDENT print \" Case ▁ # \" + str ( caseNumber + 1 ) + \" : ▁ \" + str ( time ) . replace ( \" L \" , \" \" ) NEW_LINE DEDENT DEDENT","from __future__ import division NEW_LINE import sys NEW_LINE import math NEW_LINE lines = sys . stdin . readlines ( ) NEW_LINE C = int ( lines [ 0 ] ) NEW_LINE def solve ( Rs ) : NEW_LINE INDENT field = { } NEW_LINE for r in Rs : NEW_LINE INDENT for y in range ( r [ 1 ] , r [ 3 ] + 1 ) : NEW_LINE INDENT for x in range ( r [ 0 ] , r [ 2 ] + 1 ) : NEW_LINE INDENT field [ ( x , y ) ] = True NEW_LINE DEDENT DEDENT DEDENT turns = 0 NEW_LINE while len ( field ) : NEW_LINE INDENT turns += 1 NEW_LINE will_spawn = [ ] NEW_LINE will_die = [ ] NEW_LINE for ( x , y ) in field : NEW_LINE INDENT if field . get ( ( x , y - 1 ) ) or field . get ( ( x - 1 , y ) ) : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT will_die . append ( ( x , y ) ) NEW_LINE DEDENT if field . get ( ( x + 1 , y - 1 ) ) : NEW_LINE INDENT will_spawn . append ( ( x + 1 , y ) ) NEW_LINE DEDENT if field . get ( ( x - 1 , y + 1 ) ) : NEW_LINE INDENT will_spawn . append ( ( x , y + 1 ) ) NEW_LINE DEDENT DEDENT for p in will_die : field . pop ( p ) NEW_LINE for p in will_spawn : field [ p ] = True NEW_LINE DEDENT return turns NEW_LINE DEDENT idx = 1 NEW_LINE for t in range ( 1 , C + 1 ) : NEW_LINE INDENT R = int ( lines [ idx ] ) NEW_LINE Rs = [ ] NEW_LINE for r in range ( R ) : NEW_LINE INDENT Rs . append ( [ int ( x ) for x in lines [ idx + 1 + r ] . split ( ) ] ) NEW_LINE DEDENT idx += R + 1 NEW_LINE answer = solve ( Rs ) NEW_LINE print \" Case ▁ # % d : ▁ % s \" % ( t , answer ) NEW_LINE DEDENT"],"bleu":0.18177708833061168,"rouge_l":0.3803670051665776}
{"id":162,"predictions":["def solve ( n , a ) : NEW_LINE INDENT digits = [ ] NEW_LINE while n > 0 : NEW_LINE INDENT digits . append ( n % 10 ) NEW_LINE n \/\/= 10 NEW_LINE DEDENT return digits NEW_LINE DEDENT def solve ( digits ) : NEW_LINE INDENT digits = list ( digits ) NEW_LINE ans = None NEW_LINE for i in range ( len ( digits ) ) : NEW_LINE INDENT if digits [ i ] > digits [ i - 1 ] : NEW_LINE INDENT ans = digits [ : i ] + solve ( digits ) NEW_LINE DEDENT else : NEW_LINE INDENT if i > digits [ i - 1 ] : NEW_LINE INDENT ans = digits [ : i ] + ans NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT T = int ( input ( ) ) NEW_LINE for case in range ( 1 , T + 1 ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE print ( \" Case ▁ # % d : ▁ % s \" % ( case , solve ( N ) ) NEW_LINE DEDENT DEDENT"],"references":["import os , sys , time , random NEW_LINE time . clock ( ) NEW_LINE sys . stdin = open ( ' A - large . in ' ) NEW_LINE sys . stdout = open ( ' A - large . out ' , ' w ' ) NEW_LINE def flip ( x ) : NEW_LINE INDENT return int ( str ( x ) [ : : - 1 ] . lstrip ( '0' ) ) NEW_LINE DEDENT def Preprocess ( ) : NEW_LINE INDENT global f NEW_LINE n = 100002 NEW_LINE f = [ n ] * n NEW_LINE f [ 1 ] = 1 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT f [ i + 1 ] = min ( f [ i + 1 ] , f [ i ] + 1 ) NEW_LINE if flip ( i ) < n : NEW_LINE INDENT f [ flip ( i ) ] = min ( f [ flip ( i ) ] , f [ i ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT def GetCheckPoint ( x ) : NEW_LINE INDENT l = len ( str ( x ) ) NEW_LINE if str ( x ) . endswith ( '0' * ( l - l \/\/ 2 ) ) : NEW_LINE INDENT return GetCheckPoint ( x - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ret = int ( str ( x ) [ : l \/\/ 2 ] + '0' * ( l - l \/\/ 2 - 1 ) + '1' ) NEW_LINE if str ( x ) [ : l \/\/ 2 ] == '1' + '0' * ( l \/\/ 2 - 1 ) : NEW_LINE INDENT return GetCheckPoint ( ret - 2 ) NEW_LINE DEDENT return ret NEW_LINE DEDENT DEDENT def Calc ( n ) : NEW_LINE INDENT if n < 100 : return f [ n ] NEW_LINE cp = GetCheckPoint ( n ) NEW_LINE return Calc ( flip ( cp ) ) + 1 + n - cp NEW_LINE DEDENT def Work ( ) : NEW_LINE INDENT n = int ( input ( ) . strip ( ) ) NEW_LINE return Calc ( n ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT Preprocess ( ) NEW_LINE T = int ( input ( ) ) NEW_LINE for i in range ( T ) : NEW_LINE INDENT print ( ' Case ▁ # % d : ▁ % d ' % ( i + 1 , Work ( ) ) ) NEW_LINE DEDENT sys . stderr . write ( ' completed ▁ % .3f \\n ' % time . clock ( ) ) NEW_LINE DEDENT","from queue import Queue NEW_LINE def minsteps ( start , goal ) : NEW_LINE INDENT if start == goal : return 0 NEW_LINE best = int ( goal ) - int ( start ) NEW_LINE bmedzi = ' ' NEW_LINE C = len ( start ) NEW_LINE for cif in range ( C ) : NEW_LINE INDENT rgoal = goal [ : : - 1 ] NEW_LINE medzi = start [ : C - cif ] + rgoal [ C - cif : ] NEW_LINE if medzi [ : : - 1 ] > goal : continue NEW_LINE toto = int ( medzi ) - int ( start ) + 1 NEW_LINE toto += int ( goal ) - int ( medzi [ : : - 1 ] ) NEW_LINE if toto < best : NEW_LINE INDENT best = toto NEW_LINE bmedzi = medzi NEW_LINE DEDENT DEDENT return best NEW_LINE DEDENT def solve ( goal ) : NEW_LINE INDENT start = '1' NEW_LINE answer = 1 NEW_LINE while len ( start ) < len ( goal ) : NEW_LINE INDENT answer += minsteps ( start , '9' * len ( start ) ) + 1 NEW_LINE start += '0' NEW_LINE DEDENT answer += minsteps ( start , goal ) NEW_LINE return answer NEW_LINE DEDENT T = int ( input ( ) ) NEW_LINE for t in range ( 1 , T + 1 ) : NEW_LINE INDENT goal = input ( ) . strip ( ) NEW_LINE answer = solve ( goal ) NEW_LINE if goal != '1' : NEW_LINE INDENT goal = str ( int ( goal ) - 1 ) NEW_LINE answer = min ( answer , 1 + solve ( goal ) ) NEW_LINE DEDENT print ( ' Case ▁ # { } : ▁ { } ' . format ( t , answer ) ) NEW_LINE DEDENT","def previously ( x ) : NEW_LINE INDENT if x == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif x == 1 : NEW_LINE INDENT return 10 NEW_LINE DEDENT else : NEW_LINE INDENT x1 = ( x + 1 ) \/\/ 2 NEW_LINE x2 = x \/\/ 2 NEW_LINE gain = 10 ** x1 + 10 ** x2 - 1 NEW_LINE return gain + previously ( x - 1 ) NEW_LINE DEDENT DEDENT def Next ( N ) : NEW_LINE INDENT count = 0 NEW_LINE s = str ( N ) NEW_LINE x = len ( s ) NEW_LINE if x < 2 : NEW_LINE INDENT return N NEW_LINE DEDENT tl = ( x + 1 ) \/\/ 2 NEW_LINE tail = N % 10 ** tl NEW_LINE if tail == 0 : NEW_LINE INDENT return 1 + Next ( N - 1 ) NEW_LINE DEDENT count += tail - 1 NEW_LINE N -= tail - 1 NEW_LINE revstr = str ( N ) [ : : - 1 ] NEW_LINE count += 1 NEW_LINE if str ( N ) == revstr : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT count += int ( revstr ) % 10 ** tl NEW_LINE return count + previously ( x - 1 ) NEW_LINE DEDENT input = open ( r ' . \/ A - large . in ' ) NEW_LINE X = list ( input ) NEW_LINE C = int ( X [ 0 ] ) NEW_LINE Y = [ [ int ( j ) for j in x . split ( ) ] for x in X [ 1 : ] ] NEW_LINE sol = [ ] NEW_LINE j = 0 NEW_LINE for i in xrange ( C ) : NEW_LINE INDENT s = Y [ i ] [ 0 ] NEW_LINE sol += [ Next ( s ) ] NEW_LINE if not i % 10 : print ' case ▁ ' , i + 1 , ' done ' NEW_LINE DEDENT tofile = True NEW_LINE if tofile : NEW_LINE INDENT with open ( r ' . \/ outputA . txt ' , ' w ' ) as output : NEW_LINE INDENT for i in range ( len ( sol ) ) : NEW_LINE INDENT output . write ( ' Case ▁ # % s : ▁ % s \\n ' % ( i + 1 , sol [ i ] ) ) NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT print sol NEW_LINE DEDENT","def swap ( k ) : NEW_LINE INDENT return int ( str ( k ) [ : : - 1 ] ) NEW_LINE DEDENT def cut ( n ) : NEW_LINE INDENT a = str ( n ) NEW_LINE b = len ( a ) NEW_LINE c = a [ b \/\/ 2 : ] NEW_LINE return int ( c ) NEW_LINE DEDENT def solution ( n ) : NEW_LINE INDENT compteur = 1 NEW_LINE while n > 10 : NEW_LINE INDENT if cut ( n ) == 0 : NEW_LINE INDENT n = n - 1 NEW_LINE compteur = compteur + 1 NEW_LINE DEDENT a = cut ( n ) NEW_LINE if cut ( n ) > 1 : NEW_LINE INDENT n = n - cut ( n ) + 1 NEW_LINE compteur = compteur + a - 1 NEW_LINE DEDENT a = swap ( n ) NEW_LINE if a != n : NEW_LINE INDENT n = a NEW_LINE compteur = compteur + 1 NEW_LINE DEDENT else : NEW_LINE INDENT n = n - 2 NEW_LINE compteur = compteur + 2 NEW_LINE DEDENT DEDENT return compteur + 8 NEW_LINE DEDENT import numpy as np NEW_LINE def main ( ifn = ' A - large . in ' , ofn = ' output . txt ' ) : NEW_LINE INDENT with open ( ifn ) as inf : NEW_LINE INDENT with open ( ofn , ' w ' ) as ouf : NEW_LINE INDENT noc = int ( inf . readline ( ) . strip ( ) ) NEW_LINE for tnoc in range ( noc ) : NEW_LINE INDENT ouf . write ( \" Case ▁ # % d : ▁ \" % ( tnoc + 1 ) ) NEW_LINE i = int ( inf . readline ( ) . strip ( ) ) NEW_LINE if i < 19 : NEW_LINE INDENT n = i NEW_LINE DEDENT else : NEW_LINE INDENT n = solution ( i ) NEW_LINE DEDENT ouf . write ( \" % d \\n \" % n ) NEW_LINE DEDENT DEDENT DEDENT DEDENT","import sys NEW_LINE sys . setrecursionlimit ( 10000 ) NEW_LINE tc = int ( sys . stdin . readline ( ) ) NEW_LINE maxN = 1000 NEW_LINE bests = [ None ] * ( maxN + 1 ) NEW_LINE bests [ 1 ] = 1 NEW_LINE for N in xrange ( 2 , maxN + 1 ) : NEW_LINE INDENT strN = str ( N ) NEW_LINE revN = int ( ' ' . join ( reversed ( strN ) ) ) NEW_LINE if revN < N and strN [ - 1 ] != '0' : NEW_LINE INDENT bests [ N ] = min ( bests [ N - 1 ] , bests [ revN ] ) + 1 NEW_LINE DEDENT else : NEW_LINE INDENT bests [ N ] = bests [ N - 1 ] + 1 NEW_LINE DEDENT DEDENT cache = { } NEW_LINE def walk ( N ) : NEW_LINE INDENT if N <= maxN : return bests [ N ] NEW_LINE if N in cache : return cache [ N ] NEW_LINE if N % 10 == 0 : return 1 + walk ( N - 1 ) NEW_LINE d = 1 NEW_LINE ten = 10 NEW_LINE while ten < N : NEW_LINE INDENT d += 1 NEW_LINE ten *= 10 NEW_LINE DEDENT t = 10 ** ( d - 1 ) - 1 NEW_LINE res_t = walk ( t ) NEW_LINE res = N - t + res_t NEW_LINE ten = 1 NEW_LINE while ten < N : NEW_LINE INDENT target = ( N \/ ten ) * ten + 1 NEW_LINE if target <= N : NEW_LINE INDENT revTarget = int ( ' ' . join ( reversed ( str ( target ) ) ) ) NEW_LINE res = min ( res , res_t + N - target + 1 + revTarget - t ) NEW_LINE DEDENT ten *= 10 NEW_LINE DEDENT cache [ N ] = res NEW_LINE return res NEW_LINE DEDENT for tmp_tc in xrange ( tc ) : NEW_LINE INDENT [ N ] = map ( lambda x : int ( x ) , sys . stdin . readline ( ) . split ( ' ▁ ' ) ) NEW_LINE print \" Case ▁ # % d : ▁ % d \" % ( 1 + tmp_tc , walk ( N ) ) NEW_LINE DEDENT"],"bleu":0.29486050647652745,"rouge_l":0.4039555287391567}
{"id":163,"predictions":["import sys NEW_LINE f = open ( sys . argv [ 1 ] ) NEW_LINE T = int ( f . readline ( ) ) NEW_LINE for t <= T : NEW_LINE INDENT line = f . readline ( ) . split ( ) NEW_LINE N , M = [ int ( i ) for i in f . readline ( ) . split ( ) ] NEW_LINE K = int ( line [ 0 ] ) , int ( line [ 1 ] ) NEW_LINE ret = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT a , b , c = map ( int , f . readline ( ) . split ( ) ) NEW_LINE if b >= K : NEW_LINE INDENT ret += ( b - a ) * c NEW_LINE DEDENT DEDENT return ret NEW_LINE DEDENT T = int ( f . readline ( ) ) NEW_LINE for t in range ( 1 , T + 1 ) : NEW_LINE INDENT A , b , c = map ( int , f . readline ( ) . split ( ) ) NEW_LINE K = int ( K ) NEW_LINE if K % 2 == 0 : NEW_LINE INDENT print ' Case ▁ # % d : ▁ % d ' % ( t + 1 , ret + 1 ) NEW_LINE DEDENT DEDENT"],"references":["import sys NEW_LINE from itertools import zip_longest as zip NEW_LINE T = int ( sys . stdin . readline ( ) . strip ( ) ) NEW_LINE for t in range ( T ) : NEW_LINE INDENT A , B , K = tuple ( int ( i ) for i in sys . stdin . readline ( ) . strip ( ) . split ( ) ) NEW_LINE cnt = 0 NEW_LINE for a in range ( A ) : NEW_LINE INDENT for b in range ( B ) : NEW_LINE INDENT if a & b < K : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT print ( \" Case ▁ # % d : ▁ % d \" % ( t + 1 , cnt ) ) NEW_LINE DEDENT","cache = { } NEW_LINE A , B , K = 0 , 0 , 0 NEW_LINE def f ( upto , abound , bbound , kbound ) : NEW_LINE INDENT if upto >= len ( A ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( upto , abound , bbound , kbound ) in cache : NEW_LINE INDENT return cache [ ( upto , abound , bbound , kbound ) ] NEW_LINE DEDENT a = int ( A [ upto ] ) NEW_LINE b = int ( B [ upto ] ) NEW_LINE k = int ( K [ upto ] ) NEW_LINE ans = 0 NEW_LINE for ma in ( 0 , 1 ) : NEW_LINE INDENT for mb in ( 0 , 1 ) : NEW_LINE INDENT mk = ma & mb NEW_LINE if abound and ma > a : NEW_LINE INDENT continue NEW_LINE DEDENT if bbound and mb > b : NEW_LINE INDENT continue NEW_LINE DEDENT if kbound and mk > k : NEW_LINE INDENT continue NEW_LINE DEDENT ans += f ( upto + 1 , abound and ma == a , bbound and mb == b , kbound and mk == k ) NEW_LINE DEDENT DEDENT cache [ ( upto , abound , bbound , kbound ) ] = ans NEW_LINE return ans NEW_LINE DEDENT def do ( ) : NEW_LINE INDENT global A , B , K , cache NEW_LINE cache = { } NEW_LINE A , B , K = map ( lambda x : bin ( int ( x ) - 1 ) [ 2 : ] . zfill ( 100 ) , raw_input ( ) . split ( ) ) NEW_LINE return str ( f ( 0 , True , True , True ) ) NEW_LINE DEDENT T = input ( ) NEW_LINE for i in xrange ( T ) : NEW_LINE INDENT print \" Case ▁ # % s : ▁ % s \" % ( i + 1 , do ( ) ) NEW_LINE DEDENT","import itertools NEW_LINE from collections import defaultdict NEW_LINE from random import randint NEW_LINE def getzip ( zipcode , lst ) : NEW_LINE INDENT res = ' ' NEW_LINE for elm in lst : NEW_LINE INDENT res += zipcode [ elm ] NEW_LINE DEDENT return res NEW_LINE DEDENT def ok ( lst , mp ) : NEW_LINE INDENT n = len ( lst ) NEW_LINE stack = [ ] NEW_LINE vis = [ 0 ] * n NEW_LINE cur = lst [ 0 ] NEW_LINE vis [ cur ] = 1 NEW_LINE stack . append ( cur ) NEW_LINE for i in xrange ( 1 , n ) : NEW_LINE INDENT nxt = lst [ i ] NEW_LINE while stack : NEW_LINE INDENT now = stack [ - 1 ] NEW_LINE if ( now , nxt ) in mp : break NEW_LINE stack . pop ( ) NEW_LINE DEDENT if not stack : NEW_LINE INDENT return False NEW_LINE DEDENT stack . append ( nxt ) NEW_LINE DEDENT return True NEW_LINE DEDENT def solve ( tcase ) : NEW_LINE INDENT n , m = ( int ( e ) for e in raw_input ( ' ' ) . split ( ) ) NEW_LINE zipcode = [ raw_input ( ' ' ) for i in xrange ( n ) ] NEW_LINE road = [ raw_input ( ' ' ) . split ( ) for i in xrange ( m ) ] NEW_LINE mp = defaultdict ( int ) NEW_LINE for r in road : NEW_LINE INDENT key = ( int ( r [ 0 ] ) - 1 , int ( r [ 1 ] ) - 1 ) NEW_LINE mp [ key ] = 1 NEW_LINE key = ( int ( r [ 1 ] ) - 1 , int ( r [ 0 ] ) - 1 ) NEW_LINE mp [ key ] = 1 NEW_LINE DEDENT opt = range ( n ) NEW_LINE res = ' z ' * 100 NEW_LINE for elm in itertools . permutations ( opt ) : NEW_LINE INDENT if ok ( elm , mp ) : NEW_LINE INDENT res = min ( res , getzip ( zipcode , elm ) ) NEW_LINE DEDENT DEDENT print ' Case ▁ # % d : ▁ % s ' % ( tcase , res ) NEW_LINE DEDENT T = int ( raw_input ( ' ' ) ) NEW_LINE for tcase in xrange ( 1 , T + 1 ) : NEW_LINE INDENT solve ( tcase ) NEW_LINE DEDENT","def solve ( A , B , K ) : NEW_LINE INDENT r = 0 NEW_LINE for a in range ( 32 ) : NEW_LINE INDENT if A >> a & 1 : NEW_LINE INDENT for b in range ( 32 ) : NEW_LINE INDENT if B >> b & 1 : NEW_LINE INDENT for k in range ( 32 ) : NEW_LINE INDENT if K >> k & 1 : NEW_LINE INDENT t = 1 NEW_LINE for i in range ( 32 ) : NEW_LINE INDENT if i < k : NEW_LINE INDENT if i < a and i < b : NEW_LINE INDENT t *= 4 NEW_LINE DEDENT elif i < a or i < b : NEW_LINE INDENT t *= 2 NEW_LINE DEDENT else : NEW_LINE INDENT t *= 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT x = K >> i & 1 NEW_LINE if i == k : NEW_LINE INDENT x = 0 NEW_LINE DEDENT if i < a and i < b : NEW_LINE INDENT t *= [ 3 , 1 ] [ x ] NEW_LINE DEDENT elif i < a or i < b : NEW_LINE INDENT if i < a : NEW_LINE INDENT y = 0 if i == b else B >> i & 1 NEW_LINE DEDENT else : NEW_LINE INDENT y = 0 if i == a else A >> i & 1 NEW_LINE DEDENT if x == 0 and y == 0 : NEW_LINE INDENT t *= 2 NEW_LINE DEDENT elif x == 0 and y == 1 : NEW_LINE INDENT t *= 1 NEW_LINE DEDENT elif x == 1 and y == 0 : NEW_LINE INDENT t *= 0 NEW_LINE DEDENT elif x == 1 and y == 1 : NEW_LINE INDENT t *= 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT y = ( 0 if i == a else A >> i & 1 ) & ( 0 if i == b else B >> i & 1 ) NEW_LINE if x == y : NEW_LINE INDENT t *= 1 NEW_LINE DEDENT else : NEW_LINE INDENT t *= 0 NEW_LINE DEDENT DEDENT DEDENT DEDENT r += t NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT return r NEW_LINE DEDENT for t in range ( input ( ) ) : NEW_LINE INDENT A , B , K = map ( int , raw_input ( ) . split ( ) ) NEW_LINE print \" Case ▁ # % s : ▁ % s \" % ( t + 1 , solve ( A , B , K ) ) NEW_LINE DEDENT","import sys NEW_LINE infile = None NEW_LINE outfile = None NEW_LINE def readline ( ) : NEW_LINE INDENT x = infile . readline ( ) NEW_LINE if len ( x ) > 0 : NEW_LINE INDENT return x [ : - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT return x NEW_LINE DEDENT DEDENT def readint ( ) : NEW_LINE INDENT return int ( readline ( ) ) NEW_LINE DEDENT def readfloat ( ) : NEW_LINE INDENT return float ( readline ( ) ) NEW_LINE DEDENT def readints ( ) : NEW_LINE INDENT xs = readline ( ) . split ( ) NEW_LINE return [ int ( x ) for x in xs ] NEW_LINE DEDENT def readfloats ( ) : NEW_LINE INDENT xs = readline ( ) . split ( ) NEW_LINE return [ float ( x ) for x in xs ] NEW_LINE DEDENT def writeline ( x ) : NEW_LINE INDENT outfile . write ( x + ' \\n ' ) NEW_LINE DEDENT def run ( main ) : NEW_LINE INDENT global infile , outfile NEW_LINE args = sys . argv NEW_LINE if len ( args ) == 1 : NEW_LINE INDENT infile = sys . stdin NEW_LINE outfile = sys . stdout NEW_LINE DEDENT elif len ( args ) == 2 : NEW_LINE INDENT if args [ 1 ] == ' - ' : NEW_LINE INDENT infile = sys . stdin NEW_LINE DEDENT else : NEW_LINE INDENT infile = open ( args [ 1 ] , ' r ' ) NEW_LINE DEDENT if args [ 1 ] . endswith ( ' . in ' ) : NEW_LINE INDENT outfile = open ( args [ 1 ] [ : - 3 ] + ' . out ' , ' w ' ) NEW_LINE DEDENT else : NEW_LINE INDENT outfile = sys . stdout NEW_LINE DEDENT DEDENT elif len ( args ) == 3 : NEW_LINE INDENT if args [ 1 ] == ' - ' : NEW_LINE INDENT infile = sys . stdin NEW_LINE DEDENT else : NEW_LINE INDENT infile = open ( args [ 1 ] , ' r ' ) NEW_LINE DEDENT if args [ 2 ] == ' - ' : NEW_LINE INDENT outfile = sys . stdout NEW_LINE DEDENT else : NEW_LINE INDENT outfile = open ( args [ 2 ] , ' w ' ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( \" Expected ▁ 0 , ▁ 1 , ▁ or ▁ 2 ▁ args , ▁ not ▁ { : d } \" . format ( len ( args ) - 1 ) ) NEW_LINE print ( args ) NEW_LINE return NEW_LINE DEDENT t = readint ( ) NEW_LINE for casenum in range ( 1 , t + 1 ) : NEW_LINE INDENT main ( casenum ) NEW_LINE DEDENT if infile is not sys . stdin : NEW_LINE INDENT infile . close ( ) NEW_LINE DEDENT if outfile is not sys . stdout : NEW_LINE INDENT outfile . close ( ) NEW_LINE DEDENT DEDENT"],"bleu":0.533655310053746,"rouge_l":0.5701610966261442}
{"id":164,"predictions":["from math import * NEW_LINE T = int ( raw_input ( ) ) NEW_LINE for t in xrange ( 1 , T + 1 ) : NEW_LINE INDENT A = [ int ( x ) for x in raw_input ( ) . split ( ) ] NEW_LINE B = [ int ( x ) for x in raw_input ( ) . split ( ) ] NEW_LINE best = 0 NEW_LINE for i in xrange ( len ( A ) - 1 ) : NEW_LINE INDENT for j in xrange ( i , len ( B ) ) : NEW_LINE INDENT best = max ( best , best + i ) NEW_LINE DEDENT DEDENT print best NEW_LINE DEDENT"],"references":["import sys NEW_LINE def ntests ( L , P , C ) : NEW_LINE INDENT ratio = P * 1.0 \/ L NEW_LINE if ratio <= C : return 0 NEW_LINE if L == 1 and P == 3 : return 1 NEW_LINE testpoint = int ( L * ( ratio ** 0.5 ) ) NEW_LINE count = max ( 1 + ntests ( L , testpoint , C ) , 1 + ntests ( testpoint , P , C ) ) NEW_LINE if ( testpoint * testpoint == L * P or testpoint + 1 == P ) : NEW_LINE INDENT return count NEW_LINE DEDENT count2 = max ( 1 + ntests ( L , testpoint + 1 , C ) , 1 + ntests ( testpoint + 1 , P , C ) ) NEW_LINE return min ( count , count2 ) NEW_LINE DEDENT infile = sys . stdin NEW_LINE T = int ( infile . readline ( ) . strip ( ) ) NEW_LINE for i in xrange ( T ) : NEW_LINE INDENT L , P , C = map ( int , infile . readline ( ) . strip ( ) . split ( ) ) NEW_LINE result = ntests ( L , P , C ) NEW_LINE print ( \" Case ▁ # % d : ▁ % s \" % ( i + 1 , str ( result ) ) ) NEW_LINE DEDENT","read_int = lambda : int ( raw_input ( ) . strip ( ) ) NEW_LINE read_ints = lambda : [ int ( x ) for x in raw_input ( ) . split ( ) ] NEW_LINE count_to = lambda n : xrange ( 1 , n + 1 ) NEW_LINE def solve_all ( solve ) : NEW_LINE INDENT num_cases = read_int ( ) NEW_LINE for i in count_to ( num_cases ) : NEW_LINE INDENT print \" Case ▁ # { 0 } : \" . format ( i ) , NEW_LINE solve ( ) NEW_LINE DEDENT DEDENT import math NEW_LINE def solve_case ( ) : NEW_LINE INDENT l , p , c = read_ints ( ) NEW_LINE count = 0 NEW_LINE while l * c < p : NEW_LINE INDENT l *= c NEW_LINE count += 1 NEW_LINE DEDENT tests = 0 NEW_LINE while count != 0 : NEW_LINE INDENT count >>= 1 NEW_LINE tests += 1 NEW_LINE DEDENT print tests NEW_LINE DEDENT solve_all ( solve_case ) NEW_LINE","import math NEW_LINE T = int ( input ( ) ) NEW_LINE for testCase in range ( 0 , T ) : NEW_LINE INDENT line = input ( ) . split ( ) NEW_LINE L = int ( line [ 0 ] ) NEW_LINE P = int ( line [ 1 ] ) NEW_LINE C = int ( line [ 2 ] ) NEW_LINE a = math . log ( P \/ L , C ) NEW_LINE a = math . ceil ( a ) NEW_LINE b = math . ceil ( math . log ( a , 2 ) ) NEW_LINE print ( ' Case ▁ # { 0 } : ▁ { 1 } ' . format ( testCase + 1 , b ) ) NEW_LINE DEDENT","from math import log , ceil NEW_LINE def solve_problem ( L , P , C ) : NEW_LINE INDENT intervals = int ( ceil ( log ( ( P + L - 1 ) \/ L , C ) ) ) NEW_LINE tests = 0 NEW_LINE while intervals > 1 : NEW_LINE INDENT tests += 1 NEW_LINE intervals = ( intervals + 1 ) \/ 2 NEW_LINE DEDENT return tests NEW_LINE DEDENT def run_process ( args ) : NEW_LINE INDENT return solve_problem ( * args ) NEW_LINE DEDENT def process_file ( fin , fout ) : NEW_LINE INDENT def get_problem ( ) : NEW_LINE INDENT return map ( int , fin . readline ( ) . split ( ' ▁ ' ) ) NEW_LINE DEDENT numLines = int ( fin . readline ( ) ) NEW_LINE problem_list = [ get_problem ( ) for i in range ( numLines ) ] NEW_LINE if False : NEW_LINE INDENT from multiprocessing import Pool NEW_LINE p = Pool ( 8 ) NEW_LINE solution_list = p . map ( run_process , problem_list ) NEW_LINE DEDENT else : NEW_LINE INDENT solution_list = map ( run_process , problem_list ) NEW_LINE DEDENT for i , s in enumerate ( solution_list ) : NEW_LINE INDENT fout . write ( \" Case ▁ # % s : ▁ % s \\n \" % ( i + 1 , s ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT from sys import argv NEW_LINE process_file ( open ( argv [ 1 ] ) , open ( argv [ 1 ] . replace ( \" in \" , \" out \" ) , \" w \" ) ) NEW_LINE DEDENT","import sys , math NEW_LINE INPUT = sys . stdin NEW_LINE INPUT = open ( sys . argv [ 1 ] , ' r ' ) NEW_LINE def getline ( ) : NEW_LINE INDENT return INPUT . readline ( ) [ : - 1 ] NEW_LINE DEDENT def trace ( * strs ) : NEW_LINE INDENT print >> sys . stderr , ' . . ' , NEW_LINE for str in strs : NEW_LINE INDENT print >> sys . stderr , str , NEW_LINE DEDENT print >> sys . stderr NEW_LINE DEDENT def memoize ( f ) : NEW_LINE INDENT memos = { } NEW_LINE def memoized_f ( * args ) : NEW_LINE INDENT try : NEW_LINE INDENT result = memos [ args ] NEW_LINE trace ( args , \" : ▁ got ▁ result ▁ from ▁ memo \" ) NEW_LINE DEDENT except KeyError : NEW_LINE INDENT result = f ( * args ) NEW_LINE trace ( args , \" : ▁ got ▁ result ▁ by ▁ calling \" ) NEW_LINE memos [ args ] = result NEW_LINE DEDENT return result NEW_LINE DEDENT return memoized_f NEW_LINE DEDENT n_cases = int ( getline ( ) ) NEW_LINE trace ( n_cases , ' cases : ' ) NEW_LINE for case_num in range ( 1 , n_cases + 1 ) : NEW_LINE INDENT trace ( ) NEW_LINE trace ( ' Case ▁ # ' , case_num ) NEW_LINE ( L , P , C ) = map ( int , getline ( ) . split ( ) ) NEW_LINE trace ( ' L = % s ▁ P = % s ▁ C = % s ' % ( L , P , C ) ) NEW_LINE log_span = ( math . log ( P ) - math . log ( L ) ) \/ math . log ( C ) NEW_LINE trace ( ' log _ span ▁ = ' , log_span ) NEW_LINE n_load_tests_A = int ( math . ceil ( math . log ( log_span , 2 ) - 1e-7 ) ) NEW_LINE for i in xrange ( sys . maxint ) : NEW_LINE INDENT if pow ( C , pow ( 2 , i ) ) * L >= P : NEW_LINE INDENT n_load_tests = i NEW_LINE break NEW_LINE DEDENT DEDENT if n_load_tests_A != n_load_tests : NEW_LINE INDENT trace ( ' ! ! ! ' , n_load_tests_A , ' ! = ' , n_load_tests ) NEW_LINE DEDENT print ' Case ▁ # % d : ▁ % s ' % ( case_num , n_load_tests ) NEW_LINE sys . stdout . flush ( ) NEW_LINE DEDENT assert INPUT . readline ( ) == ' ' NEW_LINE"],"bleu":0.4333446262285864,"rouge_l":0.4587693848651262}
{"id":165,"predictions":["import sys NEW_LINE def c ( ) : NEW_LINE INDENT t = int ( sys . stdin . readline ( ) ) NEW_LINE for i in xrange ( t ) : NEW_LINE INDENT n = int ( sys . stdin . readline ( ) ) NEW_LINE arr = map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) NEW_LINE arr = [ x - 1 for x in arr ] NEW_LINE assert len ( arr ) == n NEW_LINE count = 0 NEW_LINE seen = [ False for _ in xrange ( n ) ] NEW_LINE for ix , x in enumerate ( arr ) : NEW_LINE INDENT if x != ix : NEW_LINE INDENT continue NEW_LINE DEDENT while not seen [ x ] : NEW_LINE INDENT seen [ x ] = True NEW_LINE x = arr [ x ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT print \" Case ▁ # % d : ▁ % d \" % ( i + 1 , count ) NEW_LINE DEDENT DEDENT c ( ) NEW_LINE"],"references":["def war ( n , k ) : NEW_LINE INDENT n = [ float ( block ) for block in n . split ( \" ▁ \" ) ] NEW_LINE k = [ float ( block ) for block in k . split ( \" ▁ \" ) ] NEW_LINE points = 0 NEW_LINE n = reversed ( sorted ( n ) ) NEW_LINE for nblock in n : NEW_LINE INDENT if nblock > max ( k ) : NEW_LINE INDENT points += 1 NEW_LINE k . remove ( min ( k ) ) NEW_LINE DEDENT else : NEW_LINE INDENT k . remove ( min ( [ block for block in k if block > nblock ] ) ) NEW_LINE DEDENT DEDENT return str ( points ) NEW_LINE DEDENT def dwar ( n , k ) : NEW_LINE INDENT n = [ float ( block ) for block in n . split ( \" ▁ \" ) ] NEW_LINE k = [ float ( block ) for block in k . split ( \" ▁ \" ) ] NEW_LINE points = 0 NEW_LINE n = sorted ( n ) NEW_LINE for nblock in n : NEW_LINE INDENT if nblock > min ( k ) : NEW_LINE INDENT points += 1 NEW_LINE k . remove ( min ( k ) ) NEW_LINE DEDENT else : NEW_LINE INDENT k . remove ( max ( k ) ) NEW_LINE DEDENT DEDENT return str ( points ) NEW_LINE DEDENT input_text = open ( \" input . in \" ) NEW_LINE lines = input_text . readlines ( ) NEW_LINE input_text . close ( ) NEW_LINE with open ( \" output \" , \" a \" ) as outputfile : NEW_LINE INDENT for num in range ( 0 , int ( lines [ 0 ] ) ) : NEW_LINE INDENT outputfile . write ( \" Case ▁ # \" + str ( num + 1 ) + \" : ▁ \" + dwar ( lines [ num * 3 + 2 ] , lines [ num * 3 + 3 ] ) + \" ▁ \" + war ( lines [ num * 3 + 2 ] , lines [ num * 3 + 3 ] ) + \" \\n \" ) NEW_LINE DEDENT DEDENT","import fileinput NEW_LINE def readCase ( f ) : NEW_LINE INDENT f . readline ( ) NEW_LINE return map ( float , f . readline ( ) . split ( ) ) , map ( float , f . readline ( ) . split ( ) ) NEW_LINE DEDENT def printResult ( i , out ) : NEW_LINE INDENT print \" Case ▁ # % d : ▁ % s \" % ( i + 1 , out ) NEW_LINE DEDENT def solve ( naomi , ken ) : NEW_LINE INDENT naomi . sort ( ) NEW_LINE ken . sort ( ) NEW_LINE return \" % d ▁ % d \" % ( solveDeceitful ( list ( naomi ) , list ( ken ) ) , solveWar ( list ( naomi ) , list ( ken ) ) ) NEW_LINE DEDENT def solveWar ( naomi , ken ) : NEW_LINE INDENT while len ( naomi ) and naomi [ 0 ] < ken [ - 1 ] : NEW_LINE INDENT n = naomi . pop ( 0 ) NEW_LINE ken . pop ( next ( index for index , value in enumerate ( ken ) if value > n ) ) NEW_LINE DEDENT return len ( naomi ) NEW_LINE DEDENT def solveDeceitful ( naomi , ken ) : NEW_LINE INDENT delay = 0 NEW_LINE score = 0 NEW_LINE while len ( naomi ) : NEW_LINE INDENT if naomi [ 0 ] < ken [ 0 ] : NEW_LINE INDENT naomi . pop ( 0 ) NEW_LINE ken . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT score += 1 NEW_LINE ken . pop ( 0 ) NEW_LINE naomi . pop ( 0 ) NEW_LINE DEDENT DEDENT return score NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT f = fileinput . input ( ) NEW_LINE N = int ( f . readline ( ) ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT printResult ( i , solve ( * readCase ( f ) ) ) NEW_LINE DEDENT DEDENT","from collections import * NEW_LINE from sys import argv , stdin , stdout , stderr NEW_LINE Case = namedtuple ( ' Case ' , ' naomi , ▁ ken ' ) NEW_LINE def readcase ( f ) : NEW_LINE INDENT blocks = int ( next ( f ) ) NEW_LINE naomi = sorted ( readfloats ( f ) ) NEW_LINE ken = sorted ( readfloats ( f ) ) NEW_LINE assert blocks == len ( ken ) == len ( naomi ) NEW_LINE return Case ( naomi , ken ) NEW_LINE DEDENT def solvecase ( case ) : NEW_LINE INDENT naomi , ken = case NEW_LINE return ' % d ▁ % d ' % ( liewar ( ken = ken , naomi = naomi ) , war ( ken = ken , naomi = naomi ) ) NEW_LINE DEDENT def war ( ken , naomi ) : NEW_LINE INDENT kenwins = 0 NEW_LINE kencursor = 0 NEW_LINE for nweight in naomi : NEW_LINE INDENT while kencursor < len ( ken ) : NEW_LINE INDENT if ken [ kencursor ] > nweight : NEW_LINE INDENT kenwins += 1 NEW_LINE kencursor += 1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT kencursor += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return len ( ken ) - kenwins NEW_LINE DEDENT def liewar ( ken , naomi ) : NEW_LINE INDENT return len ( ken ) - war ( naomi , ken ) NEW_LINE DEDENT def readfloats ( f ) : NEW_LINE INDENT return list ( map ( float , next ( f ) . split ( ' ▁ ' ) ) ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT with open ( argv [ 1 ] ) as f , open ( argv [ 2 ] , ' w ' ) as out : NEW_LINE INDENT cases = int ( next ( f ) ) NEW_LINE for case in range ( 1 , cases + 1 ) : NEW_LINE INDENT print ( ' Case ▁ # % d : ▁ % s ' % ( case , solvecase ( readcase ( f ) ) ) , file = out ) NEW_LINE DEDENT DEDENT DEDENT main ( ) NEW_LINE","import sys NEW_LINE import itertools NEW_LINE from operator import itemgetter NEW_LINE import bisect NEW_LINE import math NEW_LINE import copy NEW_LINE from fractions import gcd NEW_LINE from utilities import * NEW_LINE sys . setrecursionlimit ( 1000 ) NEW_LINE Prep = [ ] NEW_LINE def preprocess ( ) : NEW_LINE INDENT return None NEW_LINE DEDENT def readinput ( Input ) : NEW_LINE INDENT N = Input . readint ( ) NEW_LINE Naomi = Input . readfloats ( ) NEW_LINE Ken = Input . readfloats ( ) NEW_LINE Naomi . sort ( reverse = True ) NEW_LINE Ken . sort ( reverse = True ) NEW_LINE return Naomi , Ken NEW_LINE DEDENT def solve ( Problem , Prep ) : NEW_LINE INDENT Naomi , Ken = Problem NEW_LINE if len ( Naomi ) == 1 : NEW_LINE INDENT if Naomi [ 0 ] > Ken [ 0 ] : NEW_LINE INDENT return \"1 ▁ 1\" NEW_LINE DEDENT else : NEW_LINE INDENT return \"0 ▁ 0\" NEW_LINE DEDENT DEDENT N = Naomi [ : ] NEW_LINE K = Ken [ : ] NEW_LINE wins_fair = 0 NEW_LINE for i in range ( len ( N ) ) : NEW_LINE INDENT n = N . pop ( 0 ) NEW_LINE if n < K [ 0 ] : NEW_LINE INDENT K . pop ( 0 ) NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT K . pop ( ) NEW_LINE wins_fair += 1 NEW_LINE DEDENT DEDENT N = Naomi [ : ] NEW_LINE K = Ken [ : ] NEW_LINE wins_unfair = 0 NEW_LINE for i in range ( len ( N ) ) : NEW_LINE INDENT if N [ - 1 ] < K [ - 1 ] : NEW_LINE INDENT N . pop ( ) NEW_LINE K . pop ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT N . pop ( ) NEW_LINE K . pop ( ) NEW_LINE wins_unfair += 1 NEW_LINE continue NEW_LINE DEDENT DEDENT return str ( wins_unfair ) + \" ▁ \" + str ( wins_fair ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT doit ( preprocess , readinput , solve , MultiCore = False , Verify = False , Input = LARGE , Filename = None , Problem = \" D \" , Attempt = 0 ) NEW_LINE DEDENT","import numpy as np NEW_LINE import math NEW_LINE input_file_name = ' . \/ D - large . in ' NEW_LINE output_file_name = ' . \/ D - large . out ' NEW_LINE if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT input_file = open ( input_file_name , ' r ' ) NEW_LINE output_file = open ( output_file_name , ' w ' ) NEW_LINE file_line = input_file . readline ( ) NEW_LINE file_line = file_line . replace ( ' \\n ' , ' ' ) NEW_LINE num_cases = int ( file_line ) NEW_LINE case_num = 1 NEW_LINE while True : NEW_LINE INDENT file_line = input_file . readline ( ) NEW_LINE if file_line == ' ' or file_line == ' \\n ' : NEW_LINE INDENT input_file . close ( ) NEW_LINE break NEW_LINE DEDENT file_line = file_line . replace ( ' \\n ' , ' ' ) NEW_LINE N = int ( file_line ) NEW_LINE file_line = input_file . readline ( ) NEW_LINE N_list = map ( float , file_line . split ( ) ) NEW_LINE file_line = input_file . readline ( ) NEW_LINE K_list = map ( float , file_line . split ( ) ) NEW_LINE N_list . sort ( ) NEW_LINE K_list . sort ( ) NEW_LINE N_index = 0 NEW_LINE K_index = 0 NEW_LINE ken_wins = 0 NEW_LINE while True : NEW_LINE INDENT if N_index == N or K_index == N : NEW_LINE INDENT break NEW_LINE DEDENT if K_list [ K_index ] > N_list [ N_index ] : NEW_LINE INDENT ken_wins += 1 NEW_LINE N_index += 1 NEW_LINE K_index += 1 NEW_LINE DEDENT else : NEW_LINE INDENT K_index += 1 NEW_LINE DEDENT DEDENT fair_wins = N - ken_wins NEW_LINE N_index = 0 NEW_LINE K_index = 0 NEW_LINE cheat_wins = 0 NEW_LINE while True : NEW_LINE INDENT if N_index == N or K_index == N : NEW_LINE INDENT break NEW_LINE DEDENT if N_list [ N_index ] > K_list [ K_index ] : NEW_LINE INDENT cheat_wins += 1 NEW_LINE N_index += 1 NEW_LINE K_index += 1 NEW_LINE DEDENT else : NEW_LINE INDENT N_index += 1 NEW_LINE DEDENT DEDENT output_file . write ( ' Case ▁ # ' + str ( case_num ) + ' : ▁ ' + str ( cheat_wins ) + ' ▁ ' + str ( fair_wins ) + ' \\n ' ) NEW_LINE print ( case_num ) NEW_LINE case_num += 1 NEW_LINE DEDENT output_file . close ( ) NEW_LINE DEDENT"],"bleu":0.1749330383883914,"rouge_l":0.2960730700084999}
{"id":166,"predictions":["import sys NEW_LINE f = open ( sys . argv [ 1 ] ) NEW_LINE casenum = int ( f . readline ( ) ) NEW_LINE for casei in xrange ( casenum ) : NEW_LINE INDENT res = 0 NEW_LINE C = int ( f . readline ( ) ) NEW_LINE corners = [ ] NEW_LINE for i in xrange ( C ) : NEW_LINE INDENT line = f . readline ( ) . splitlines ( ) NEW_LINE corners . append ( ( line [ 0 ] , 1 ) ) NEW_LINE DEDENT line = f . readline ( ) . split ( ) NEW_LINE for j in xrange ( C ) : NEW_LINE INDENT corners [ j ] . append ( line [ 2 ] ) NEW_LINE if not ( j in corners ) : NEW_LINE INDENT del corners [ j - 1 ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT corners [ j ] = ( corners [ j - 1 ] + corners [ 2 ] ) \/ 2 NEW_LINE corners [ j ] = ( corners [ j - 1 ] + corners [ j + 1 ] ) \/ 2 NEW_LINE DEDENT DEDENT corners = { } NEW_LINE res = 0 NEW_LINE for corners in corners : NEW_LINE INDENT res += corners [ corners [ 0 ] ] NEW_LINE DEDENT print ' Case ▁ # % d : ▁ % d ' % ( casenum , res ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE from itertools import islice NEW_LINE def solve ( L , t , N , C , a ) : NEW_LINE INDENT tot_dist = 0 NEW_LINE eff_dists = [ ] NEW_LINE for s in xrange ( N ) : NEW_LINE INDENT d = a [ s % len ( a ) ] NEW_LINE if tot_dist + d <= t : NEW_LINE INDENT eff_dists . append ( ( d , 0 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT if tot_dist >= t : NEW_LINE INDENT eff_dists . append ( ( d , d ) ) NEW_LINE DEDENT else : NEW_LINE INDENT eff_dists . append ( ( d , d - ( t - tot_dist ) ) ) NEW_LINE DEDENT DEDENT tot_dist += d NEW_LINE DEDENT tot_time = 0 NEW_LINE for dist , eff_dist in sorted ( eff_dists , key = lambda x : x [ 1 ] , reverse = True ) : NEW_LINE INDENT if L > 0 : NEW_LINE INDENT tot_time += eff_dist + 2 * ( dist - eff_dist ) NEW_LINE L -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT tot_time += dist * 2 NEW_LINE DEDENT DEDENT return tot_time \/\/ 2 NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT T = int ( next ( sys . stdin ) ) NEW_LINE for test in xrange ( 1 , T + 1 ) : NEW_LINE INDENT print >> sys . stderr , test NEW_LINE line = next ( sys . stdin ) NEW_LINE L , t , N , C , a = line . split ( None , 4 ) NEW_LINE L , t , N , C = map ( int , ( L , t , N , C ) ) NEW_LINE a = list ( int ( ai ) * 2 for ai in a . split ( ) ) NEW_LINE print \" Case ▁ # % s : ▁ % s \" % ( test , solve ( L , t , N , C , a ) ) NEW_LINE DEDENT DEDENT main ( ) NEW_LINE","class streamreader : NEW_LINE INDENT def __init__ ( _ , s ) : _ . t = ( t for t in s . read ( ) . split ( ) ) NEW_LINE def __div__ ( _ , t ) : return ( t ) ( _ . t . next ( ) ) NEW_LINE DEDENT import sys NEW_LINE sr = streamreader ( sys . stdin ) NEW_LINE for tc in xrange ( sr \/ int ) : NEW_LINE INDENT L , t , N , C = sr \/ int , sr \/ int , sr \/ int , sr \/ int NEW_LINE a = [ sr \/ int for i in xrange ( C ) ] NEW_LINE A = [ a [ i % C ] for i in xrange ( N ) ] NEW_LINE time = 0 NEW_LINE for i in xrange ( N ) : NEW_LINE INDENT if time <= t and time + A [ i ] * 2 > t : NEW_LINE INDENT f = ( t - time ) \/ 2 NEW_LINE s = A [ i ] - f NEW_LINE A [ i ] = f NEW_LINE A . insert ( i + 1 , s ) NEW_LINE i += 1 NEW_LINE break NEW_LINE DEDENT time += A [ i ] * 2 NEW_LINE DEDENT A0 = A [ : i ] NEW_LINE B = A [ i : ] NEW_LINE B . sort ( ) NEW_LINE if L == 0 : NEW_LINE INDENT B1 = B NEW_LINE B2 = [ ] NEW_LINE DEDENT else : NEW_LINE INDENT B1 = B [ : - L ] NEW_LINE B2 = B [ - L : ] NEW_LINE DEDENT time = 0 NEW_LINE for i in A0 + B1 : NEW_LINE INDENT time += i * 2 NEW_LINE DEDENT for i in B2 : NEW_LINE INDENT time += i NEW_LINE DEDENT print ' Case ▁ # % d : ' % ( tc + 1 ) , time NEW_LINE DEDENT","from __future__ import division NEW_LINE import sys NEW_LINE from itertools import cycle , islice NEW_LINE def do_case ( l , t , n , c , _as ) : NEW_LINE INDENT distances = list ( islice ( cycle ( _as ) , n ) ) NEW_LINE total = sum ( distances ) NEW_LINE if total * 2 <= t or l == 0 : NEW_LINE INDENT return total * 2 NEW_LINE DEDENT traveled = t * .5 NEW_LINE left = 0 NEW_LINE index = 0 NEW_LINE for i , dist in enumerate ( distances ) : NEW_LINE INDENT if traveled >= dist : NEW_LINE INDENT traveled -= dist NEW_LINE DEDENT else : NEW_LINE INDENT index = i + 1 NEW_LINE left = dist - traveled NEW_LINE break NEW_LINE DEDENT DEDENT remaining = distances [ index : ] + [ left ] NEW_LINE return t + sum ( remaining ) * 2 - sum ( islice ( sorted ( remaining , reverse = True ) , l ) ) NEW_LINE DEDENT in_ , out_f = sys . argv [ 1 ] , sys . argv [ 1 ] + \" . out \" NEW_LINE out = open ( out_f , ' w ' ) NEW_LINE with open ( in_ , ' r ' ) as file : NEW_LINE INDENT num = 1 NEW_LINE num_cases = int ( file . next ( ) . rstrip ( ) ) NEW_LINE for num in range ( 1 , num_cases + 1 ) : NEW_LINE INDENT s = map ( int , file . next ( ) . rstrip ( ) . split ( ' ▁ ' ) ) NEW_LINE l , t , n , c = s [ 0 : 4 ] NEW_LINE _as = s [ 4 : ] NEW_LINE ret = do_case ( l , t , n , c , _as ) NEW_LINE out . write ( \" Case ▁ # % d : ▁ % d \\n \" % ( num , ret ) ) NEW_LINE print \" Case ▁ # % d : ▁ % d \" % ( num , ret ) NEW_LINE DEDENT DEDENT","def solve_case ( t , L , t_booster , stars ) : NEW_LINE INDENT N = len ( stars ) NEW_LINE for_booster = { } NEW_LINE t_temp = 0 NEW_LINE for i in xrange ( 1 , N + 1 ) : NEW_LINE INDENT if t_temp >= t_booster : NEW_LINE INDENT for_booster [ i ] = stars [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT if t_temp + stars [ i ] * 2 <= t_booster : NEW_LINE INDENT for_booster [ i ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT for_booster [ i ] = stars [ i ] - ( t_booster - t_temp ) \/ 2 NEW_LINE DEDENT t_temp += stars [ i ] * 2 NEW_LINE DEDENT stars [ i ] *= 2 NEW_LINE DEDENT k = for_booster . keys ( ) NEW_LINE k . sort ( key = for_booster . __getitem__ , reverse = True ) NEW_LINE for i in xrange ( L ) : NEW_LINE INDENT m = k [ i ] NEW_LINE stars [ m ] -= for_booster [ m ] NEW_LINE DEDENT time = 0 NEW_LINE for i in xrange ( 1 , N + 1 ) : NEW_LINE INDENT time += stars [ i ] NEW_LINE DEDENT print \" Case ▁ # \" + str ( t ) + \" : ▁ \" + str ( time ) NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT T = int ( raw_input ( ) ) NEW_LINE for t in range ( 1 , T + 1 ) : NEW_LINE INDENT s = raw_input ( ) . split ( ) NEW_LINE L = int ( s [ 0 ] ) NEW_LINE t_booster = int ( s [ 1 ] ) NEW_LINE N = int ( s [ 2 ] ) NEW_LINE C = int ( s [ 3 ] ) NEW_LINE s = s [ 4 : ] NEW_LINE s = [ int ( i ) for i in s ] NEW_LINE stars = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT stars [ i + 1 ] = s [ i % C ] NEW_LINE DEDENT solve_case ( t , L , t_booster , stars ) NEW_LINE DEDENT DEDENT solve ( ) NEW_LINE","import math NEW_LINE import sys NEW_LINE def printe ( * st ) : NEW_LINE INDENT return True NEW_LINE sys . stderr . write ( \" , \" . join ( [ str ( x ) for x in st ] ) + \" \\n \" ) NEW_LINE DEDENT def generator ( N , l ) : NEW_LINE INDENT a = 0 NEW_LINE i = 0 NEW_LINE while a < N : NEW_LINE INDENT yield l [ i ] NEW_LINE i += 1 NEW_LINE if i == len ( l ) : NEW_LINE INDENT i = 0 NEW_LINE DEDENT a += 1 NEW_LINE DEDENT DEDENT def simulate ( ) : NEW_LINE INDENT l = [ int ( a ) for a in input ( ) . split ( ) ] NEW_LINE L = l . pop ( 0 ) NEW_LINE t = l . pop ( 0 ) NEW_LINE N = l . pop ( 0 ) NEW_LINE C = l . pop ( 0 ) NEW_LINE printe ( l ) NEW_LINE sum = 0 NEW_LINE pfactory = [ ] NEW_LINE firstBuilt = False NEW_LINE for star in generator ( N , l ) : NEW_LINE INDENT if sum > t : NEW_LINE INDENT pfactory . append ( star ) NEW_LINE if not firstBuilt : NEW_LINE INDENT firstBuilt = True NEW_LINE pfactory . append ( ( sum - t ) \/ 2 ) NEW_LINE DEDENT DEDENT sum += star * 2 NEW_LINE printe ( star ) NEW_LINE DEDENT if sum > t : NEW_LINE INDENT if not firstBuilt : NEW_LINE INDENT pfactory . append ( ( sum - t ) \/ 2 ) NEW_LINE DEDENT DEDENT pfactory . sort ( reverse = True ) NEW_LINE printe ( \" pf \" , pfactory ) NEW_LINE for i in range ( L ) : NEW_LINE INDENT if i >= len ( pfactory ) : NEW_LINE INDENT break NEW_LINE DEDENT sum -= pfactory [ i ] NEW_LINE DEDENT return int ( sum ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT print ( \" Case ▁ # { } : ▁ { } \" . format ( i + 1 , simulate ( ) ) ) NEW_LINE DEDENT DEDENT"],"bleu":0.29550957438017894,"rouge_l":0.364908621919763}
{"id":167,"predictions":["def keys ( num_per_key , num_keys , num_letters , frequencies ) : NEW_LINE INDENT frequencies . sort ( ) NEW_LINE iterations = 0 NEW_LINE answer = 0 NEW_LINE while len ( frequencies ) > 0 and iterations < num_per_key : NEW_LINE INDENT iterations += 1 NEW_LINE for i in range ( 0 , min ( len ( frequencies ) , num_keys ) ) : NEW_LINE INDENT answer += frequencies . pop ( ) * iterations NEW_LINE DEDENT DEDENT if len ( frequencies ) > 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return answer NEW_LINE DEDENT DEDENT N = int ( raw_input ( ) ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT per , key , let = raw_input ( ) . split ( ' ▁ ' ) NEW_LINE freq = raw_input ( ) . split ( ' ▁ ' ) NEW_LINE freq = map ( int , freq ) NEW_LINE print \" Case ▁ # % d : ▁ % d \" % ( i , keys ( int ( per ) , int ( key ) , int ( let ) , freq ) ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE import math NEW_LINE from collections import defaultdict NEW_LINE f = open ( ' B - large . in ' ) NEW_LINE tests = int ( f . readline ( ) ) NEW_LINE def getOffset ( keys , target ) : NEW_LINE INDENT s = set ( list ( keys ) ) NEW_LINE for c in target : NEW_LINE INDENT if c not in s : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT offset = 1 NEW_LINE while offset < len ( target ) : NEW_LINE INDENT if target [ : len ( target ) - offset ] == target [ offset : ] : NEW_LINE INDENT break NEW_LINE DEDENT offset += 1 NEW_LINE DEDENT return offset NEW_LINE DEDENT def getExp ( keys , target , s ) : NEW_LINE INDENT d = defaultdict ( lambda : 0.0 ) NEW_LINE for c in keys : NEW_LINE INDENT d [ c ] += 1.0 \/ len ( keys ) NEW_LINE DEDENT tot = 1.0 NEW_LINE for c in target : NEW_LINE INDENT tot *= d [ c ] NEW_LINE DEDENT return tot * ( s - len ( target ) + 1 ) NEW_LINE DEDENT for t in xrange ( tests ) : NEW_LINE INDENT k , l , s = map ( int , f . readline ( ) . rstrip ( ) . split ( ) ) NEW_LINE keys = f . readline ( ) . rstrip ( ) NEW_LINE target = f . readline ( ) . rstrip ( ) NEW_LINE offset = getOffset ( keys , target ) NEW_LINE if offset == 0 : NEW_LINE INDENT print \" Case ▁ # \" + str ( t + 1 ) + \" : ▁ 0.0\" NEW_LINE continue NEW_LINE DEDENT needed = 1 + ( s - len ( target ) ) \/\/ offset NEW_LINE ans = max ( 0.0 , needed - getExp ( keys , target , s ) ) NEW_LINE if ans < 0.000000001 : NEW_LINE INDENT ans = 0.0 NEW_LINE DEDENT print \" Case ▁ # \" + str ( t + 1 ) + \" : ▁ \" + str ( ans ) NEW_LINE DEDENT","from __future__ import print_function , division NEW_LINE from collections import Counter NEW_LINE def overlap_shift ( s ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if s . startswith ( s [ i + 1 : ] ) : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT DEDENT def tc ( tci ) : NEW_LINE INDENT [ klen , tlen , s ] = map ( int , raw_input ( ) . split ( ) ) NEW_LINE keyboard = raw_input ( ) NEW_LINE target = raw_input ( ) NEW_LINE assert klen == len ( keyboard ) NEW_LINE assert tlen == len ( target ) NEW_LINE assert s >= tlen NEW_LINE sol = 0.0 NEW_LINE counter = Counter ( keyboard ) NEW_LINE if all ( t in counter for t in target ) : NEW_LINE INDENT sh = overlap_shift ( target ) NEW_LINE occs = 1 + ( s - tlen ) \/\/ sh NEW_LINE p = 1.0 NEW_LINE for t in target : NEW_LINE INDENT p *= counter [ t ] \/ klen NEW_LINE DEDENT sol = occs - p * ( s - tlen + 1 ) NEW_LINE DEDENT print ( \" Case ▁ # { } : ▁ { : . 15f } \" . format ( tci , sol ) ) NEW_LINE DEDENT tcn = int ( raw_input ( ) ) NEW_LINE for tci in range ( 1 , tcn + 1 ) : tc ( tci ) NEW_LINE","import re NEW_LINE fin = open ( \" smallB . in \" , \" r \" ) NEW_LINE fout = open ( \" smallB . out \" , \" w + \" ) NEW_LINE for tc in xrange ( int ( fin . readline ( ) ) ) : NEW_LINE INDENT K , L , S = [ int ( x ) for x in fin . readline ( ) . split ( ) ] NEW_LINE KEYS = [ x for x in fin . readline ( ) . strip ( ) ] NEW_LINE TW = fin . readline ( ) . strip ( ) NEW_LINE pos = [ \" \" ] NEW_LINE for i in xrange ( S ) : NEW_LINE INDENT pos_next = [ ] NEW_LINE for p in pos : NEW_LINE INDENT for key in KEYS : NEW_LINE INDENT pos_next . append ( p + key ) NEW_LINE DEDENT DEDENT pos = pos_next NEW_LINE DEDENT to_pay = [ len ( re . findall ( \" ( ? = % s ) \" % TW , word ) ) for word in pos ] NEW_LINE to_bring = max ( to_pay ) NEW_LINE med_pay = sum ( to_pay ) * 1. \/ len ( to_pay ) NEW_LINE ans = to_bring - med_pay NEW_LINE print \" Case ▁ # % i : ▁ % f \" % ( tc + 1 , ans ) NEW_LINE fout . write ( \" Case ▁ # % i : ▁ % f \\n \" % ( tc + 1 , ans ) ) NEW_LINE DEDENT","import sys NEW_LINE def readline ( ) : NEW_LINE INDENT return map ( int , raw_input ( ) . strip ( ) . split ( ) ) NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT k , l , s = readline ( ) NEW_LINE keys = raw_input ( ) . strip ( ) NEW_LINE word = raw_input ( ) . strip ( ) NEW_LINE if set ( word ) - set ( keys ) : NEW_LINE INDENT return 0.0 NEW_LINE DEDENT t = [ max ( j for j in xrange ( i ) if word . startswith ( word [ i - j : i ] ) ) for i in xrange ( 1 , l + 1 ) ] NEW_LINE bring = 1 + ( s - l ) \/\/ ( l - t [ - 1 ] ) NEW_LINE d = [ [ 0 ] * l for i in xrange ( s + 1 ) ] NEW_LINE kp = { kk : 0 for kk in set ( keys ) } NEW_LINE for kk in keys : NEW_LINE INDENT kp [ kk ] += 1 NEW_LINE DEDENT for si in xrange ( s - 1 , - 1 , - 1 ) : NEW_LINE INDENT for p in xrange ( l ) : NEW_LINE INDENT r = 0.0 NEW_LINE for kk , kc in kp . iteritems ( ) : NEW_LINE INDENT pp = p NEW_LINE while pp > 0 and kk != word [ pp ] : NEW_LINE INDENT pp = t [ pp - 1 ] NEW_LINE DEDENT if kk == word [ pp ] : NEW_LINE INDENT pp += 1 NEW_LINE DEDENT if pp == l : NEW_LINE INDENT r += kc NEW_LINE pp = t [ pp - 1 ] NEW_LINE DEDENT r += d [ si + 1 ] [ pp ] * kc NEW_LINE DEDENT r \/= k NEW_LINE d [ si ] [ p ] = r NEW_LINE DEDENT DEDENT return bring - d [ 0 ] [ 0 ] NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT t = int ( raw_input ( ) . strip ( ) ) NEW_LINE for i in xrange ( 1 , t + 1 ) : NEW_LINE INDENT ret = solve ( ) NEW_LINE print ' Case ▁ # { } : ' . format ( i ) , ret NEW_LINE print >> sys . stderr , ' Case ▁ # { } : ' . format ( i ) , ret NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT","def maximunBananas ( key , target , length ) : NEW_LINE INDENT if length < len ( target ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT d = { } NEW_LINE for i in range ( len ( key ) ) : NEW_LINE INDENT if key [ i ] in d : NEW_LINE INDENT d [ key [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ key [ i ] ] = 1 NEW_LINE DEDENT DEDENT for i in range ( len ( target ) ) : NEW_LINE INDENT if target [ i ] not in d : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT advanced = len ( target ) NEW_LINE for i in range ( len ( target ) - 1 ) : NEW_LINE INDENT if target [ : i + 1 ] == target [ len ( target ) - i - 1 : ] : NEW_LINE INDENT advanced = len ( target ) - i - 1 NEW_LINE DEDENT DEDENT return 1 + int ( ( length - len ( target ) ) \/ advanced ) NEW_LINE DEDENT def expectedBananas ( key , target , length ) : NEW_LINE INDENT d = { } NEW_LINE for i in range ( len ( key ) ) : NEW_LINE INDENT if key [ i ] in d : NEW_LINE INDENT d [ key [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ key [ i ] ] = 1 NEW_LINE DEDENT DEDENT prob = 1 NEW_LINE for i in range ( len ( target ) ) : NEW_LINE INDENT if target [ i ] in d : NEW_LINE INDENT prob *= d [ target [ i ] ] \/ len ( key ) NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return prob * ( length - len ( target ) + 1 ) NEW_LINE DEDENT def calculate ( ) : NEW_LINE INDENT k , l , s = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE key = input ( ) NEW_LINE target = input ( ) NEW_LINE return maximunBananas ( key , target , s ) - expectedBananas ( key , target , s ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT ncase = int ( input ( ) ) NEW_LINE for i in range ( ncase ) : NEW_LINE INDENT print ( ' Case ▁ # { } : ▁ { } ' . format ( i + 1 , calculate ( ) ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"bleu":0.33677014066438776,"rouge_l":0.38154750610936516}
{"id":168,"predictions":["import math NEW_LINE import itertools NEW_LINE import numpy as np NEW_LINE import devtools NEW_LINE def read_case ( f ) : NEW_LINE INDENT return read_ints ( f ) . strip ( ) NEW_LINE DEDENT def read_ints ( f ) : NEW_LINE INDENT return [ int ( x ) for x in f . readline ( ) . split ( ) ] NEW_LINE DEDENT def read_ints ( f ) : NEW_LINE INDENT return [ int ( x ) for x in f . readline ( ) . strip ( ) . split ( ) ] NEW_LINE DEDENT def read_ints ( f ) : NEW_LINE INDENT return [ int ( x ) for x in f . readline ( ) . split ( ) ] NEW_LINE DEDENT def read_ints ( f ) : NEW_LINE INDENT return [ int ( x ) for x in f . read_words ( ) . split ( ) ] NEW_LINE DEDENT def read_words ( f , d = ' ▁ ' ) : NEW_LINE INDENT return [ int ( x ) for x in f ] NEW_LINE DEDENT def read_words ( f , d = ' ▁ ' ) : NEW_LINE INDENT return [ int ( x ) for x in f ] NEW_LINE DEDENT def read_words ( f , d ) : NEW_LINE INDENT return [ float ( x ) for x in f ] NEW_LINE DEDENT def read_words ( f , d = ' ▁ ' ) : NEW_LINE INDENT return read_words ( f , d ) NEW_LINE DEDENT def read_floats ( f , d = ' ▁ ' ) : NEW_LINE INDENT return [ float ( x ) for x in read_words ( f , d ) ] NEW_LINE DEDENT def read_words ( f , d = ' ▁ ' ) : NEW_LINE INDENT return [ int ( x , d ) for x in read_words ( f , d ) ] NEW_LINE DEDENT def read_words ( f , d = ' ▁ ' ) : NEW_LINE INDENT return [ int ( x , d ) for x in read_words ( f , d ) ] NEW_LINE DEDENT def read_words ("],"references":["import sys NEW_LINE T = int ( sys . stdin . readline ( ) ) NEW_LINE for ca in xrange ( 1 , T + 1 ) : NEW_LINE INDENT [ X , Y ] = [ int ( v ) for v in sys . stdin . readline ( ) . split ( \" ▁ \" ) ] NEW_LINE print \" Case ▁ # % d : ▁ \" % ca , NEW_LINE if X > 0 : NEW_LINE INDENT for i in range ( X ) : NEW_LINE INDENT sys . stdout . write ( \" W \" ) , NEW_LINE sys . stdout . write ( \" E \" ) , NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT X = - X NEW_LINE for i in range ( X ) : NEW_LINE INDENT sys . stdout . write ( \" E \" ) , NEW_LINE sys . stdout . write ( \" W \" ) , NEW_LINE DEDENT DEDENT if Y > 0 : NEW_LINE INDENT for i in range ( Y ) : NEW_LINE INDENT sys . stdout . write ( \" S \" ) , NEW_LINE sys . stdout . write ( \" N \" ) , NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT Y = - Y NEW_LINE for i in range ( Y ) : NEW_LINE INDENT sys . stdout . write ( \" N \" ) , NEW_LINE sys . stdout . write ( \" S \" ) , NEW_LINE DEDENT DEDENT print \" \" NEW_LINE DEDENT","def check ( xx , yy ) : NEW_LINE INDENT points = set ( [ ( 0 , 0 ) ] ) NEW_LINE for step in range ( 30 ) : NEW_LINE INDENT t1 = ( 0 , 0 ) in points NEW_LINE t2 = step % 4 in ( 0 , 3 ) NEW_LINE d = step + 1 NEW_LINE if ( xx , yy ) in points : NEW_LINE INDENT return step NEW_LINE DEDENT points = set ( [ a for b in [ [ ( x + d , y ) , ( x - d , y ) , ( x , y + d ) , ( x , y - d ) ] for x , y in points ] for a in b ] ) NEW_LINE DEDENT DEDENT def calc ( x , y ) : NEW_LINE INDENT d = s = 0 NEW_LINE while s < abs ( x ) + abs ( y ) : NEW_LINE INDENT d += 1 NEW_LINE s += d NEW_LINE DEDENT add_zero = d % 4 in ( 0 , 3 ) NEW_LINE while ( ( abs ( x ) + abs ( y ) ) % 2 == 0 ) != ( d % 4 in ( 0 , 3 ) ) : NEW_LINE INDENT d += 1 NEW_LINE s += d NEW_LINE DEDENT res = ' ' NEW_LINE for i in range ( d , 0 , - 1 ) : NEW_LINE INDENT if abs ( x ) > abs ( y ) and x > 0 : NEW_LINE INDENT x -= i NEW_LINE res = ' E ' + res NEW_LINE DEDENT elif abs ( x ) > abs ( y ) : NEW_LINE INDENT x += i NEW_LINE res = ' W ' + res NEW_LINE DEDENT elif y > 0 : NEW_LINE INDENT y -= i NEW_LINE res = ' N ' + res NEW_LINE DEDENT else : NEW_LINE INDENT y += i NEW_LINE res = ' S ' + res NEW_LINE DEDENT DEDENT assert ( x , y ) == ( 0 , 0 ) , ( x , y , d ) NEW_LINE return res NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE res = calc ( x , y ) NEW_LINE print ( res ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT T = int ( input ( ) ) NEW_LINE for t in range ( 1 , T + 1 ) : NEW_LINE INDENT print ( \" Case ▁ # % d : \" % t , end = ' ▁ ' ) NEW_LINE solve ( ) NEW_LINE DEDENT DEDENT","import sys NEW_LINE import math NEW_LINE import string NEW_LINE import pdb NEW_LINE def docase ( f , casenum ) : NEW_LINE INDENT data = f . next ( ) . split ( ) NEW_LINE X = int ( data [ 0 ] ) NEW_LINE Y = int ( data [ 1 ] ) NEW_LINE abssum = abs ( X ) + abs ( Y ) NEW_LINE n = int ( math . sqrt ( 2 * abssum ) ) NEW_LINE found = False NEW_LINE while not found : NEW_LINE INDENT val = n * ( n + 1 ) \/ 2 NEW_LINE if val >= abssum and ( val - abssum ) % 2 == 0 : NEW_LINE INDENT found = True NEW_LINE break NEW_LINE DEDENT n += 1 NEW_LINE DEDENT result = \" \" NEW_LINE result = [ ] NEW_LINE for i in xrange ( n , 0 , - 1 ) : NEW_LINE INDENT if abs ( X ) > abs ( Y ) : NEW_LINE INDENT if X > 0 : NEW_LINE INDENT result . append ( \" E \" ) NEW_LINE X -= i NEW_LINE DEDENT else : NEW_LINE INDENT result . append ( \" W \" ) NEW_LINE X += i NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if Y > 0 : NEW_LINE INDENT result . append ( \" N \" ) NEW_LINE Y -= i NEW_LINE DEDENT else : NEW_LINE INDENT result . append ( \" S \" ) NEW_LINE Y += i NEW_LINE DEDENT DEDENT DEDENT result . reverse ( ) NEW_LINE strres = \" \" . join ( result ) NEW_LINE print \" Case ▁ # \" + str ( casenum ) + \" : ▁ \" + strres NEW_LINE DEDENT with open ( sys . argv [ 1 ] , \" r \" ) as f : NEW_LINE INDENT T = int ( f . next ( ) ) NEW_LINE for k in xrange ( T ) : NEW_LINE INDENT docase ( f , k + 1 ) NEW_LINE DEDENT DEDENT","from collections import Counter NEW_LINE def solve ( x , y ) : NEW_LINE INDENT directions = [ ] NEW_LINE if x > 0 : NEW_LINE INDENT for i in range ( x ) : NEW_LINE INDENT directions . append ( ' WE ' ) NEW_LINE DEDENT DEDENT elif x < 0 : NEW_LINE INDENT for i in range ( - x ) : NEW_LINE INDENT directions . append ( ' EW ' ) NEW_LINE DEDENT DEDENT if y > 0 : NEW_LINE INDENT for i in range ( y ) : NEW_LINE INDENT directions . append ( ' SN ' ) NEW_LINE DEDENT DEDENT elif y < 0 : NEW_LINE INDENT for i in range ( - y ) : NEW_LINE INDENT directions . append ( ' NS ' ) NEW_LINE DEDENT DEDENT return ' ' . join ( directions ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE input_file = sys . argv [ 1 ] NEW_LINE output_file = input_file [ : ] . replace ( ' . in ' , ' . out ' ) NEW_LINE f_in = open ( input_file , ' r ' ) NEW_LINE f_out = open ( output_file , ' w ' ) NEW_LINE T , = [ int ( x ) for x in f_in . readline ( ) . split ( ) ] NEW_LINE for case in range ( 1 , T + 1 ) : NEW_LINE INDENT print NEW_LINE print ' = = = = = = = = = = = = = = = = = = = = = ' NEW_LINE print ' ▁ ▁ ▁ ▁ ' + str ( case ) NEW_LINE print ' = = = = = = = = = = = = = = = = = = = = = ' NEW_LINE x , y = [ int ( i ) for i in f_in . readline ( ) . split ( ) ] NEW_LINE ans = solve ( x , y ) NEW_LINE print ans NEW_LINE f_out . write ( ' Case ▁ # % d : ▁ % s \\n ' % ( case , ans ) ) NEW_LINE DEDENT DEDENT","import math NEW_LINE T = int ( raw_input ( ) ) NEW_LINE for t in range ( T ) : NEW_LINE INDENT line = [ i . strip ( ) for i in raw_input ( ) . split ( ) ] NEW_LINE x = int ( line [ 0 ] ) NEW_LINE y = int ( line [ 1 ] ) NEW_LINE path = [ ' ▁ ' for i in range ( ( abs ( x ) + abs ( y ) ) * 2 ) ] NEW_LINE for i in range ( abs ( x ) ) : NEW_LINE INDENT if x > 0 : NEW_LINE INDENT path [ 2 * i ] = ' W ' NEW_LINE path [ 2 * i + 1 ] = ' E ' NEW_LINE DEDENT else : NEW_LINE INDENT path [ 2 * i ] = ' E ' NEW_LINE path [ 2 * i + 1 ] = ' W ' NEW_LINE DEDENT DEDENT m = 2 * abs ( x ) NEW_LINE for i in range ( abs ( y ) ) : NEW_LINE INDENT if y > 0 : NEW_LINE INDENT path [ m + 2 * i ] = ' S ' NEW_LINE path [ m + 2 * i + 1 ] = ' N ' NEW_LINE DEDENT else : NEW_LINE INDENT path [ m + 2 * i ] = ' N ' NEW_LINE path [ m + 2 * i + 1 ] = ' S ' NEW_LINE DEDENT DEDENT print ' Case ▁ # % s : ▁ % s ' % ( t + 1 , \" \" . join ( path ) ) NEW_LINE DEDENT"],"bleu":0.2730872362203818,"rouge_l":0.3948832035595106}
{"id":169,"predictions":["vow = set ( [ ' a ' , ' e ' , ' i ' , ' o ' , ' u ' , ' y ' ] ) def f ( x ) : q = 0 for y in x : q += int ( y in vow ) return qn = int ( input ( ) ) p = [ int ( x ) for x in input ( ) . split ( ' ▁ ' ) ] fl = 1 for i in range ( q ) : s = [ f ( x ) for x in input ( ) . split ( ' ▁ ' ) ] if ( sum ( s [ i ] ) != p [ i ] ) : fl = 0 if ( sum ( s [ i ] ) != p [ i ] ) : fl = 0 if ( s [ i ] == p [ i ] ) : fl = 0 print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"references":["import re     def is_int ( s : str ) -> bool : if len ( s ) > 0 and ( s [ 0 ] == \"0\" and len ( s ) > 1 ) : return False else : try : int ( s ) return True except : return False     def partition ( pred , iterable ) : trues = [ ] falses = [ ] for item in iterable : if pred ( item ) : trues . append ( item ) else : falses . append ( item ) return trues , falses     def print_ans ( s ) : if len ( s ) > 0 : print ( \" \\ \" { } \\ \" \" . format ( \" , \" . join ( s ) ) ) else : print ( \" - \" )     s = re . split ( \" ; | , \" , input ( ) ) s_int , s_str = partition ( is_int , s ) print_ans ( s_int ) print_ans ( s_str ) NEW_LINE","s = input ( ) . replace ( \" ; \" , \" , \" ) . split ( \" , \" ) a = [ ] b = [ ] for w in s : if w . isdigit ( ) and ( w == \"0\" or w [ 0 ] != \"0\" ) : a . append ( w ) else : b . append ( w )   for v in a , b : print ( ' \" { } \" ' . format ( ' , ' . join ( v ) ) if v else ' - ' ) NEW_LINE","s = input ( ) . replace ( \" ; \" , \" , \" ) . split ( \" , \" ) fs = [ ] ss = [ ] for i in s : if ( i . isdecimal ( ) ) : if ( len ( i ) == 1 and i [ 0 ] == '0' ) : fs . append ( i ) elif ( len ( i ) != 1 and i [ 0 ] == '0' ) : ss . append ( i ) else : fs . append ( i ) else : ss . append ( i ) if fs : print ( ' \" ' + ' , ' . join ( fs ) + ' \" ' ) else : print ( ' - ' )   if ss : print ( ' \" ' + ' , ' . join ( ss ) + ' \" ' ) else : print ( ' - ' ) NEW_LINE","import re   s = input ( ) s = ( re . split ( \" ; | , \" , s ) ) a = [ ] b = [ ] for i in s : if ( i . isalnum ( ) and i . isdigit ( ) == False ) : b . append ( i ) elif ( i . isascii ( ) and i . isdigit ( ) == False ) : b . append ( i ) else : if ( i . isdigit ( ) ) : if ( len ( i ) > 1 ) : if ( i [ 0 ] != \"0\" ) : a . append ( i ) else : b . append ( i ) else : a . append ( i )   if ( len ( a ) > 0 ) : a = \" , \" . join ( a ) print ( ' \" { } \" ' . format ( a ) ) else : print ( \" - \" ) if ( len ( b ) > 0 ) : b = \" , \" . join ( b ) print ( ' \" { } \" ' . format ( b ) ) else : print ( \" - \" ) NEW_LINE","a , b = [ ] , [ ] for s in input ( ) . replace ( ' ; ' , ' , ' ) . split ( ' , ' ) : try : n = int ( s ) if ( n > 0 and s [ 0 ] != '0' ) or ( n == 0 and len ( s ) == 1 ) : a . append ( s ) else : b . append ( s ) except Exception : b . append ( s )   if a : print ( ' \" ' + ' , ' . join ( a ) + ' \" ' ) else : print ( ' - ' )   if b : print ( ' \" ' + ' , ' . join ( b ) + ' \" ' ) else : print ( ' - ' ) NEW_LINE"],"bleu":0.18852047907176178,"rouge_l":0.3593747797775929}
{"id":170,"predictions":["import mathfor _ in range ( int ( input ( ) ) ) : a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE print ( min ( a , b , c , d ) ) NEW_LINE"],"references":["def solve ( ) : b , p , f = map ( int , input ( ) . split ( ) ) h , c = map ( int , input ( ) . split ( ) )   NEW_LINE","for _ in range ( int ( input ( ) ) ) : b , p , f = map ( int , input ( ) . split ( ) ) h , c = map ( int , input ( ) . split ( ) )   if h > c : r = min ( b \/\/ 2 , p ) ans = r * h + min ( ( b - 2 * r ) \/\/ 2 , f ) * c else : r = min ( b \/\/ 2 , f ) ans = r * c + min ( ( b - 2 * r ) \/\/ 2 , p ) * h   print ( ans ) NEW_LINE","import sys   T = int ( sys . stdin . readline ( ) )   for i in range ( T ) : b , p , f = map ( int , sys . stdin . readline ( ) . split ( ) ) h , c = map ( int , sys . stdin . readline ( ) . split ( ) ) answer = 0 if b < 2 : print ( 0 ) else : big_price = max ( h , c ) small_price = min ( h , c ) if big_price == c : big = f small = p else : big = p small = f while True : if b < 2 : break if big > 0 : b -= 2 big -= 1 answer += big_price elif big == 0 : b -= 2 small -= 1 answer += small_price if big == 0 and small == 0 : break print ( answer ) NEW_LINE","for _ in range ( int ( input ( ) ) ) : b , p , f = map ( int , input ( ) . split ( ) ) h , c = map ( int , input ( ) . split ( ) ) ma = b \/\/ 2 k = 0 if h > c : while ma > 0 and p > 0 : ma -= 1 p -= 1 k += h while ma > 0 and f > 0 : ma -= 1 f -= 1 k += c else : while ma > 0 and f > 0 : ma -= 1 f -= 1 k += c while ma > 0 and p > 0 : ma -= 1 p -= 1 k += h print ( k ) NEW_LINE","R = lambda : map ( int , input ( ) . split ( ) ) n , = R ( ) for _ in [ 0 ] * n : b , * a = R ( ) ; ( h , p ) , ( c , f ) = sorted ( zip ( R ( ) , a ) ) ; m = min ( b \/\/ 2 , f ) ; print ( m * c + min ( p , b \/\/ 2 - m ) * h ) NEW_LINE"],"bleu":0.603501606704659,"rouge_l":0.6744038372132579}
{"id":171,"predictions":["import sys , os , ioimport math , bisect , operatorinf , mod = float ( ' inf ' ) , 10 ** 9 + 7 NEW_LINE"],"references":["a = input ( ) . split ( ' : ' ) b = input ( ) . split ( ' : ' )       x = int ( a [ 0 ] ) * 60 + int ( a [ 1 ] ) y = int ( b [ 0 ] ) * 60 + int ( b [ 1 ] )     if y > x : x = ( ( int ( a [ 0 ] ) + 24 ) * 60 ) + int ( a [ 1 ] )     z = x - y   hr = str ( z \/\/ 60 ) . rjust ( 2 , '0' ) z %= 60 mi = str ( z ) . rjust ( 2 , '0' )   print ( f \" { hr } : { mi } \" )   NEW_LINE","def time ( h , m ) : if h < 0 : h += 24 if h < 10 : h = f ' {0 } { h } ' if m < 10 : m = f ' {0 } { m } ' return f ' { h } : { m } '   def solve ( s , t ) : sh , sm = map ( int , s . split ( ' : ' ) ) th , tm = map ( int , t . split ( ' : ' ) ) tot_s = sh * 60 + sm tot_t = th * 60 + tm res = tot_s - tot_t return time ( res \/\/ 60 , res % 60 )             def main ( ) : NEW_LINE","woke_hr , woke_min = map ( int , input ( ) . split ( \" : \" ) ) dur_hr , dur_min = map ( int , input ( ) . split ( \" : \" ) ) st_sleep_hr , st_sleep_min = 0 , 0   if woke_min < dur_min : st_sleep_min = ( 60 + woke_min ) - dur_min ; dur_hr += 1 else : st_sleep_min = woke_min - dur_min   if st_sleep_min in range ( 0 , 10 ) : st_sleep_min = \"0\" + str ( st_sleep_min ) else : st_sleep_min = str ( st_sleep_min )   st_sleep_hr = ( woke_hr - dur_hr ) % 24   if st_sleep_hr in range ( 0 , 10 ) : st_sleep_hr = \"0\" + str ( st_sleep_hr ) else : st_sleep_hr = str ( st_sleep_hr )   print ( \" \" . join ( [ st_sleep_hr , \" : \" , st_sleep_min ] ) ) NEW_LINE","woke_hr , woke_min = map ( int , input ( ) . split ( \" : \" ) ) dur_hr , dur_min = map ( int , input ( ) . split ( \" : \" ) ) st_sleep_hr , st_sleep_min = 0 , 0   if woke_min < dur_min : st_sleep_min = ( 60 + woke_min ) - dur_min ; dur_hr += 1 else : st_sleep_min = woke_min - dur_min NEW_LINE"],"bleu":0.020603446242745557,"rouge_l":0.17719680464778503}
{"id":172,"predictions":["n , c = map ( int , input ( ) . split ( ) ) l = [ ] l . extend ( map ( int , input ( ) . split ( ) ) )   c1 = 0 for i in range ( n - 1 ) : if l [ i + 1 ] - l [ i ] <= c : c1 += 1 else : c1 = 1   print ( c1 ) NEW_LINE"],"references":["n = int ( input ( ) ) nn = list ( map ( int , input ( ) . split ( ) ) ) m = int ( input ( ) ) mm = list ( map ( int , input ( ) . split ( ) ) ) nn . sort ( ) mm . sort ( ) i = 0j = 0 count = 0   while i < n and j < m : if abs ( nn [ i ] - mm [ j ] ) <= 1 : count += 1 i += 1 j += 1 elif nn [ i ] < mm [ j ] : i += 1 else : j += 1 print ( count ) NEW_LINE","n = int ( input ( ) ) b = list ( map ( int , input ( ) . split ( ) ) ) m = int ( input ( ) ) g = list ( map ( int , input ( ) . split ( ) ) ) b . sort ( ) g . sort ( ) i , j = 0 , 0 ans = 0 while i < n and j < m : if abs ( b [ i ] - g [ j ] ) <= 1 : ans += 1 i += 1 j += 1 else : if b [ i ] < g [ j ] : i += 1 else : j += 1 print ( ans ) NEW_LINE","n = int ( input ( ) ) list_n = list ( map ( int , input ( ) . split ( ) ) ) m = int ( input ( ) ) list_m = list ( map ( int , input ( ) . split ( ) ) ) x = 0 z = 0 cnt = 0 if n > m : list_m , list_n = list_n , list_mlist_n . sort ( ) list_m . sort ( ) while len ( list_n ) != 0 : if abs ( list_n [ x ] - list_m [ z ] ) <= 1 : cnt += 1 del list_n [ x ] del list_m [ z ] z = 0 else : z += 1 if z == len ( list_m ) : del list_n [ x ] z = 0 print ( cnt ) NEW_LINE","import sys   def input ( ) : return sys . stdin . readline ( ) . strip ( ) def iinput ( ) : return int ( input ( ) ) def rinput ( ) : return map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) def get_list ( ) : return list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) )     n = iinput ( ) b = get_list ( ) m = iinput ( ) g = get_list ( )   b . sort ( ) g . sort ( ) result = 0 for i in range ( n ) : for j in range ( m ) : if ( abs ( b [ i ] - g [ j ] ) <= 1 ) : g [ j ] = 1000 result += 1 break   print ( result ) NEW_LINE"],"bleu":0.2854515587569943,"rouge_l":0.4826536822884967}
{"id":173,"predictions":["n = int ( input ( ) ) if n % 2 == 0 : print ( ' - 1' ) elif n % 4 == 0 : print ( n \/\/ 4 ) else : print ( n \/\/ 4 ) NEW_LINE"],"references":["n = int ( input ( ) )     if n == 1 : print ( ' Ehab ' ) elif n % 2 == 0 : print ( ' Mahmoud ' ) else : print ( ' Ehab ' ) NEW_LINE","from __future__ import division , print_functionfrom collections import * from math import * from itertools import * from time import timeimport osimport sysfrom io import BytesIO , IOBase   if sys . version_info [ 0 ] < 3 : from __builtin__ import xrange as range from future_builtins import ascii , filter , hex , map , oct , zip   def main ( ) : n = int ( input ( ) ) if n % 2 == 0 : print ( ' Mahmoud ' ) else : print ( ' Ehab ' )     NEW_LINE","n = int ( input ( ) )   if ( n % 2 ) == 0 : print ( ' Mahmoud ' ) else : print ( ' Ehab ' ) NEW_LINE","n = int ( input ( ) ) if n % 2 == 1 : print ( \" Ehab \" ) else : print ( \" Mahmoud \" ) NEW_LINE","n = int ( input ( ) ) if ( n % 2 == 0 ) : print ( \" Mahmoud \" ) else : print ( \" Ehab \" ) NEW_LINE"],"bleu":0.5977795125220748,"rouge_l":0.7553485548117022}
{"id":174,"predictions":["n = int ( input ( ) ) a1 = [ 0 ] + [ int ( x ) for x in input ( ) . strip ( ) . split ( \" ▁ \" ) ]   out = [ ]   for i in range ( 1 , n + 1 ) : a = a1 . copy ( ) j = a [ i ] NEW_LINE"],"references":["import sysinput = sys . stdin . buffer . readline   n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) )   ''' diffs ▁ = [ ] miss ▁ = ▁ set ( list ( range ( 1 , n + 1 ) ) ) for ▁ i ▁ in ▁ range ( n ) : ▁ ▁ ▁ ▁ if ▁ a [ i ] ▁ ! = ▁ b [ i ] : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ diffs . append ( i ) ▁ ▁ ▁ ▁ miss . discard ( a [ i ] )  if ▁ len ( diffs ) ▁ = = ▁ 1 : ▁ ▁ ▁ ▁ # ▁ no ▁ other ▁ option ▁ ▁ ▁ ▁ a [ diffs [ 0 ] ] ▁ = ▁ list ( miss ) [0 ] else : ▁ ▁ ▁ ▁ # ▁ must ▁ be ▁ 2 ▁ ▁ ▁ ▁ if ▁ { a [ diffs [ 0 ] ] , b [ diffs [ 1 ] ] } ▁ = = ▁ miss : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ a [ diffs [ 1 ] ] ▁ = ▁ b [ diffs [ 1 ] ] ▁ ▁ ▁ ▁ else : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ a [ diffs [ 0 ] ] ▁ = ▁ b [ diffs [ 0 ] ] '''   two = - 1 missing = - 1   counts = [ [ ] for i in range ( n + 1 ) ] for i in range ( n ) : counts [ a [ i ] ] . append ( i ) if len ( counts [ a [ i ] ] ) == 2 : two = a [ i ]   for i in range ( 1 , n + 1 ) : if len ( counts [ i ] ) == 0 : missing = i break   def diff ( a , b ) : diffs = 0 for i in range ( n ) : diffs += a [ i ] != b [ i ] return diffs   for i in range ( 2 ) : perm = a . copy ( ) perm [ counts [ two ] [ i ] ] = missing   if diff ( perm , b ) == 1 : print ( * perm ) break NEW_LINE","def STR ( ) : return list ( input ( ) ) def INT ( ) : return int ( input ( ) ) def MAP ( ) : return map ( int , input ( ) . split ( ) ) def MAP2 ( ) : return map ( float , input ( ) . split ( ) ) def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) def STRING ( ) : return input ( ) import stringimport sysfrom heapq import heappop , heappushfrom bisect import * from collections import deque , Counterfrom math import * from itertools import permutations , accumulatedx = [ - 1 , 1 , 0 , 0 ] dy = [ 0 , 0 , 1 , - 1 ] NEW_LINE","from collections import Countern = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) lst = [ - 1 ] * ncf = Counter ( a ) cs = Counter ( b ) miss1 = 0 miss2 = 0 for i in range ( 1 , n + 1 ) : if cf [ i ] == 0 : miss1 = i if cs [ i ] == 0 : miss2 = is = 0 cnt = 0 for i in range ( n ) : if a [ i ] == b [ i ] : lst [ i ] = a [ i ] s += a [ i ] else : cnt += 1 if cnt == 1 : for i in range ( n ) : if lst [ i ] == - 1 : print ( ( ( n * ( n + 1 ) ) \/\/ 2 ) - s , end = \" ▁ \" ) else : print ( lst [ i ] , end = \" ▁ \" ) elif cnt == 0 : for i in range ( n ) : if cf [ a [ i ] ] != 2 : print ( a [ i ] , end = \" ▁ \" ) else : print ( miss1 , end = \" \" ) else : pp = [ ] f = 0 qq = [ ] l = [ miss1 , miss2 ] for i in range ( n ) : if lst [ i ] != - 1 : pp . append ( lst [ i ] ) qq . append ( lst [ i ] ) else : if f == 0 : pp . append ( miss1 ) qq . append ( miss2 ) f = 1 else : pp . append ( miss2 ) qq . append ( miss1 ) first = 0 second = 0 for i in range ( n ) : if pp [ i ] not in [ a [ i ] , b [ i ] ] : first = 1 if qq [ i ] not in [ a [ i ] , b [ i ] ] : second = 1 if first == 0 : print ( * pp ) else : print ( * qq )   NEW_LINE","n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) ind = [ ] for i in range ( n ) : if a [ i ] != b [ i ] : ind . append ( i ) res = [ ] rofl = [ 0 ] * ( n + 1 ) cnt = 0 for i in range ( n ) : if a [ i ] == b [ i ] : res . append ( a [ i ] ) rofl [ a [ i ] ] += 1 else : cnt += 1 res . append ( - 1 ) kek = [ ] for j in range ( 1 , n + 1 ) : if rofl [ j ] == 0 : kek . append ( j ) if cnt == 1 : for i in range ( n ) : if res [ i ] == - 1 : res [ i ] = kek [ 0 ] print ( * res ) exit ( 0 ) flag = Falseflag1 = Falseres1 = res . copy ( ) for i in range ( n ) : if res [ i ] == - 1 : if a [ i ] in kek and not flag : res [ i ] = a [ i ] flag = True else : res [ i ] = b [ i ] if b [ i ] in kek : flag1 = Trueif flag1 : print ( * res ) else : flag = False flag1 = False res = res1 . copy ( ) for i in range ( n ) : if res [ i ] == - 1 : if b [ i ] in kek and not flag : res [ i ] = b [ i ] flag = True else : res [ i ] = a [ i ] if a [ i ] in kek : flag1 = True print ( * res ) NEW_LINE"],"bleu":0.20158289111538294,"rouge_l":0.28615245827695085}
{"id":175,"predictions":["d , L , v1 , v2 = map ( int , input ( ) . split ( ) ) print ( ( L - d ) \/ ( v1 + v2 ) ) NEW_LINE"],"references":["import sysimport mathdef fn ( l , d , v , g , r ) : t = float ( d ) \/ float ( v ) if t < g : return float ( l ) \/ float ( v ) elif t <= g + r : t = g + r return t + ( float ( l ) - float ( d ) ) \/ float ( v ) elif t > g + r : t1 = t k = t \/\/ ( g + r ) t = t - k * ( g + r ) if t < g : return float ( l ) \/ float ( v ) elif t <= g + r : t = g + r return ( k + 1 ) * t + ( float ( l ) - float ( d ) ) \/ float ( v ) if __name__ == ' _ _ main _ _ ' : input = sys . stdin . read ( ) data = list ( map ( int , input . split ( ) ) ) l = ( data [ 0 ] ) d = data [ 1 ] v = data [ 2 ] g = data [ 3 ] r = data [ 4 ] print ( fn ( l , d , v , g , r ) ) NEW_LINE","l , d , v , g , r = map ( int , input ( ) . split ( ) ) time = d \/ vif time < g : print ( l \/ v ) elif time == g : print ( d \/ v + r - ( d \/ v - g ) + ( l - d ) \/ v ) else : time = d \/ v c = time % ( g + r ) if c == 0 or c < g : print ( l \/ v ) else : print ( d \/ v + r - ( time % ( g + r ) - g ) + ( l - d ) \/ v )   NEW_LINE","def solve ( ) : l , d , v , g , r = [ int ( x ) for x in input ( ) . split ( ' ▁ ' ) ] NEW_LINE","l , d , v , g , r = list ( map ( int , input ( ) . split ( ) ) ) t1 = ( d \/ v ) % ( g + r ) - gif t1 < 0 : print ( l \/ v ) else : print ( l \/ v + r - t1 ) NEW_LINE"],"bleu":0.5257328184652267,"rouge_l":0.5076040172166427}
{"id":176,"predictions":["n , m , k = map ( int , input ( ) . split ( ) ) a = [ input ( ) . split ( ) for _ in ' * n ] r = { str ( i ) : i - 1 for i in range ( 1 , n + 1 ) } c = 0 for i in range ( n ) : for j in range ( m ) : if a [ i ] [ j ] == ' # ' : if i in a [ i ] : c += 1 else : r [ i ] = [ c [ i ] [ j ] + 1 c = 0 for i in range ( n ) : if a [ i ] [ j ] == ' # ' : if i < n - 1 : r [ i ] [ j ] = r [ i + 1 ] [ j ] + 1 c += 1 print ( c ) NEW_LINE"],"references":["from itertools import permutationsfrom sys import stdin , stdoutly , lx = map ( int , input ( ) . split ( ) ) grid = [ [ c for c in inp ] for inp in stdin . read ( ) . splitlines ( ) ]   first = set ( ) bl = [ ] bpattern = [ ] bcost = 1e6 flip_row = False   for l in permutations ( ' AGCT ' ) : if bcost == 0 : break if ' ' . join ( l [ : 2 ] ) in first : continue   first |= set ( [ ' ' . join ( l [ : 2 ] ) , ' ' . join ( l [ 1 : : - 1 ] ) ] ) NEW_LINE","from itertools import permutationsfrom sys import stdin , stdoutly , lx = map ( int , input ( ) . split ( ) ) grid = [ [ c for c in inp ] for inp in stdin . read ( ) . splitlines ( ) ]   first = set ( ) bl = [ ] bpattern = [ ] bcost = 1e6 flip_row = False   for l in permutations ( ' AGCT ' ) : if bcost == 0 : break if ' ' . join ( l [ : 2 ] ) in first : continue   first |= set ( [ ' ' . join ( l [ : 2 ] ) , ' ' . join ( l [ 1 : : - 1 ] ) ] ) NEW_LINE","from itertools import permutationsfrom sys import stdin , stdoutly , lx = map ( int , input ( ) . split ( ) ) grid = [ [ c for c in inp ] for inp in stdin . read ( ) . splitlines ( ) ]   first = set ( ) bl = [ ] bpattern = [ ] bcost = 1e6 flip_row = False   for l in permutations ( ' AGCT ' ) : if bcost == 0 : break if ' ' . join ( l [ : 2 ] ) in first : continue   first |= set ( [ ' ' . join ( l [ : 2 ] ) , ' ' . join ( l [ 1 : : - 1 ] ) ] ) NEW_LINE"],"bleu":0.13628611324156084,"rouge_l":0.3557235421166307}
{"id":177,"predictions":["def main ( ) : a , b , c , d = map ( int , input ( ) . split ( ) ) if d == c : print ( - 1 ) else : print ( main ( ) ) NEW_LINE"],"references":["line1 = input ( ) . split ( \" ▁ \" ) line2 = input ( ) . split ( \" ▁ \" ) A1 = int ( line1 [ 0 ] ) A2 = int ( line2 [ 0 ] ) B1 = int ( line1 [ 1 ] ) B2 = int ( line2 [ 1 ] ) C1 = int ( line1 [ 2 ] ) C2 = int ( line2 [ 2 ] )   Z = lambda x , y , z : not x and not y and z   if A1 * B2 - A2 * B1 : print ( 1 ) elif Z ( A1 , B1 , C1 ) or Z ( A2 , B2 , C2 ) or ( C1 * B2 - C2 * B1 ) or ( A1 * C2 - A2 * C1 ) : print ( 0 ) else : print ( - 1 )   NEW_LINE","def plane ( a , b , c ) : if a == b == 0 != c : return 0 else : return - 1   def hline ( b1 , c1 , a2 , b2 , c2 ) : if b1 == 0 : if c1 == 0 : return plane ( a2 , b2 , c2 ) else : return - 1 elif a2 == 0 : if b2 == 0 != c2 : return 0 elif c2 * b1 == c1 * b2 : return - 1 else : return 0 else : return 1   def vline ( a1 , c1 , a2 , b2 , c2 ) : return hline ( a1 , c1 , b2 , a2 , c2 )     def intersect ( a1 , b1 , c1 , a2 , b2 , c2 ) : if a1 == b1 == 0 : if c1 == 0 : return plane ( a2 , b2 , c2 ) else : return 0 if a1 == 0 : return hline ( b1 , c1 , a2 , b2 , c2 ) if b1 == 0 : return vline ( a1 , c1 , a2 , b2 , c2 ) if a2 == b2 == 0 : if c2 == 0 : return plane ( a1 , b1 , c1 ) else : return 0 if a2 == 0 : return hline ( b2 , c2 , a1 , b1 , c1 ) if b2 == 0 : return vline ( a2 , c2 , a1 , b1 , c1 ) else : if a1 * b2 == a2 * b1 : if c1 * a2 == c2 * a1 : return - 1 else : return 0 else : return 1         a1 , b1 , c1 = map ( int , input ( ) . split ( ) ) a2 , b2 , c2 = map ( int , input ( ) . split ( ) )   print ( intersect ( a1 , b1 , c1 , a2 , b2 , c2 ) )     NEW_LINE","a , b , c = map ( int , input ( ) . split ( ) ) d , e , f = map ( int , input ( ) . split ( ) ) def F ( i , j , k ) : return not i and not j and kprint ( 1 if d * b - a * e else 0 if F ( a , b , c ) or F ( d , e , f ) or c * e - b * f or a * f - c * d else - 1 ) NEW_LINE","a1 , b1 , c1 = [ int ( x ) for x in input ( ) . split ( ) ] a2 , b2 , c2 = [ int ( x ) for x in input ( ) . split ( ) ]   alwaysGood = FalsealwaysBad = False   if a1 == 0 and b1 == 0 : if c1 == 0 : alwaysGood = True else : alwaysBad = Trueif a2 == 0 and b2 == 0 : if c2 == 0 : alwaysGood = True else : alwaysBad = True   if alwaysBad : print ( 0 ) elif alwaysGood : print ( - 1 ) else : if a1 * b2 == a2 * b1 : if a1 != 0 : c1 *= a2 c2 *= a1 else : c1 *= b2 c2 *= b1 if c1 == c2 : print ( - 1 ) else : print ( 0 ) else : print ( 1 ) NEW_LINE"],"bleu":0.1680906408678455,"rouge_l":0.36250000000000004}
{"id":178,"predictions":["import sys , math , osfrom io import BytesIO , IOBase NEW_LINE"],"references":["import sysinput = sys . stdin . readline   from bisect import bisect_left as bs   '''   '''   def solve ( n , a ) : b = a [ : : ] b . sort ( ) done = [ 0 ] * n   res = [ ] for i in range ( n ) : if not done [ i ] : if a [ i ] == b [ i ] : res . append ( [ i + 1 ] ) done [ i ] = 1 else : r = [ ] while not done [ i ] : r . append ( i + 1 ) done [ i ] = 1 i = bs ( b , a [ i ] ) res . append ( r ) return res                                   n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) )   res = solve ( n , a ) print ( len ( res ) ) for r in res : print ( len ( r ) , * r ) NEW_LINE","from sys import stdin , stdout   def find ( node ) : x = [ ] while dsu [ node ] > 0 : x . append ( node ) node = dsu [ node ] for i in x : dsu [ i ] = node return node   def union ( node1 , node2 ) : if node1 != node2 : if dsu [ node1 ] > dsu [ node2 ] : node1 , node2 = node2 , node1 dsu [ node1 ] += dsu [ node2 ] dsu [ node2 ] = node1     n = int ( stdin . readline ( ) . strip ( ) ) arr = [ ( int ( j ) , i ) for i , j in enumerate ( stdin . readline ( ) . strip ( ) . split ( ) ) ] arr = sorted ( arr , key = lambda t : t [ 0 ] , reverse = False ) dsu = [ - 1 ] * ( n + 1 ) for i in range ( n ) : p_a = find ( arr [ i ] [ 1 ] + 1 ) p_b = find ( i + 1 ) union ( p_a , p_b ) k = 0 outputs = [ [ ] for __ in range ( n + 1 ) ] for i in range ( 1 , n + 1 ) : if dsu [ i ] < 0 : k += 1 outputs [ find ( i ) ] . append ( f ' { i } ' ) stdout . write ( f ' { k } \\n ' ) for output in outputs : if output : stdout . write ( f ' { len ( output ) } ▁ ' ) stdout . write ( ' ▁ ' . join ( output ) + ' \\n ' )                 NEW_LINE","from sys import stdin , stdout   def find ( node ) : x = [ ] while dsu [ node ] > 0 : x . append ( node ) node = dsu [ node ] for i in x : dsu [ i ] = node return node   def union ( node1 , node2 ) : if node1 != node2 : if dsu [ node1 ] > dsu [ node2 ] : node1 , node2 = node2 , node1 dsu [ node1 ] += dsu [ node2 ] dsu [ node2 ] = node1     n = int ( stdin . readline ( ) . strip ( ) ) arr = [ ( int ( j ) , i ) for i , j in enumerate ( stdin . readline ( ) . strip ( ) . split ( ) ) ] arr = sorted ( arr , key = lambda t : t [ 0 ] , reverse = False ) dsu = [ - 1 ] * ( n + 1 ) for i in range ( n ) : p_a = find ( arr [ i ] [ 1 ] + 1 ) p_b = find ( i + 1 ) union ( p_a , p_b ) k = 0 outputs = [ [ ] for __ in range ( n + 1 ) ] for i in range ( 1 , n + 1 ) : if dsu [ i ] < 0 : k += 1 outputs [ find ( i ) ] . append ( f ' { i } ' ) stdout . write ( f ' { k } \\n ' ) for output in outputs : if output : stdout . write ( f ' { len ( output ) } ▁ ' ) stdout . write ( ' ▁ ' . join ( output ) + ' \\n ' )                 NEW_LINE","from sys import stdin , stdout   def find ( node ) : x = [ ] while dsu [ node ] > 0 : x . append ( node ) node = dsu [ node ] for i in x : dsu [ i ] = node return node   def union ( node1 , node2 ) : if node1 != node2 : if dsu [ node1 ] > dsu [ node2 ] : node1 , node2 = node2 , node1 dsu [ node1 ] += dsu [ node2 ] dsu [ node2 ] = node1     n = int ( stdin . readline ( ) . strip ( ) ) arr = [ ( int ( j ) , i ) for i , j in enumerate ( stdin . readline ( ) . strip ( ) . split ( ) ) ] arr = sorted ( arr , key = lambda t : t [ 0 ] , reverse = False ) dsu = [ - 1 ] * ( n + 1 ) for i in range ( n ) : p_a = find ( arr [ i ] [ 1 ] + 1 ) p_b = find ( i + 1 ) union ( p_a , p_b ) k = 0 outputs = [ [ ] for __ in range ( n + 1 ) ] for i in range ( 1 , n + 1 ) : if dsu [ i ] < 0 : k += 1 outputs [ find ( i ) ] . append ( f ' { i } ' ) stdout . write ( f ' { k } \\n ' ) for output in outputs : if output : stdout . write ( f ' { len ( output ) } ▁ ' ) stdout . write ( ' ▁ ' . join ( output ) + ' \\n ' )                 NEW_LINE"],"bleu":4.8855915309095386e-8,"rouge_l":0.04265734265734265}
{"id":179,"predictions":["for i in range ( int ( input ( ) ) ) : k , x = map ( int , input ( ) . split ( ) ) print ( 9 * ( k - 1 ) + x ) NEW_LINE"],"references":["for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) s = input ( ) m = n - 1 for i in range ( n ) : if s [ i ] == ' > ' or s [ n - 1 - i ] == ' < ' : m = min ( m , i ) print ( m ) NEW_LINE","for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) s = input ( ) if n == 1 : print ( 0 ) else : if s [ 0 ] == ' > ' or s [ - 1 ] == ' < ' : print ( 0 ) else : a = s . index ( ' > ' ) b = s [ : : - 1 ] . index ( ' < ' ) print ( min ( a , b ) ) NEW_LINE","t = int ( input ( ) ) for _ in range ( t ) : n = int ( input ( ) ) s = input ( ) ind1 = - 1 ind2 = - 1 g = l = 0 for i in range ( n ) : if s [ i ] == ' > ' : if ind1 == - 1 : ind1 = i + 1 g += 1 else : ind2 = i l += 1 if ind1 == - 1 : ind1 = n if ind2 == - 1 : ind2 = n ans = min ( s [ : ind1 ] . count ( ' < ' ) , s [ ind2 : ] . count ( ' > ' ) , g , l ) print ( ans ) NEW_LINE","for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) p = input ( ) q = p [ : : - 1 ] a = p . find ( ' > ' ) b = q . find ( ' < ' ) if a == - 1 : print ( b ) elif b == - 1 : print ( a ) else : print ( min ( a , b ) ) NEW_LINE","'''   ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Online ▁ Python ▁ Compiler . ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Code , ▁ Compile , ▁ Run ▁ and ▁ Debug ▁ python ▁ program ▁ online . Write ▁ your ▁ code ▁ in ▁ this ▁ editor ▁ and ▁ press ▁ \" Run \" ▁ button ▁ to ▁ execute ▁ it .   ''' t = int ( input ( ) ) for i in range ( t ) : n = int ( input ( ) ) s = input ( ) if ( n == 1 ) : print ( 0 ) else : if ( not ( s [ 0 ] == \" < \" and s [ n - 1 ] == \" > \" ) ) : print ( 0 ) else : c = 1 d = 1 for i in range ( 1 , n ) : if ( s [ i ] == \" < \" ) : c += 1 else : break for i in reversed ( range ( n - 1 ) ) : if ( s [ i ] == \" > \" ) : d += 1 else : break print ( min ( c , d ) ) NEW_LINE"],"bleu":0.2108041086107351,"rouge_l":0.41924398625429554}
{"id":180,"predictions":["import sys , os , ioimport math , bisect , operatorinf , mod = float ( ' inf ' ) , 10 ** 9 + 7 NEW_LINE"],"references":["import sys , io , os NEW_LINE if os . environ [ ' USERNAME ' ] == ' kissz ' : inp1 = inp2 = open ( ' in . txt ' , ' r ' ) . readline NEW_LINE def debug ( * args ) : print ( * args , file = sys . stderr ) NEW_LINE else : NEW_LINE","import osimport NEW_LINE sysfrom NEW_LINE io NEW_LINE import BytesIO , IOBase NEW_LINE","import osimport NEW_LINE sysfrom NEW_LINE io NEW_LINE import BytesIO , IOBase NEW_LINE","import osimport NEW_LINE sysfrom NEW_LINE io NEW_LINE import BytesIO , IOBase NEW_LINE"],"bleu":0.13597796343834895,"rouge_l":0.2970340858787074}
{"id":181,"predictions":["import sys , math , itertoolsfrom collections import Counter , deque , defaultdictfrom bisect import bisect_left , bisect_right from heapq import heappop , heappush , heapifyfrom copy import deepcopymod = 10 ** 9 + 7 INF = float ( ' inf ' ) def inp ( ) : return int ( sys . stdin . readline ( ) ) def inpl ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) def inpl_1 ( ) : return list ( map ( lambda x : int ( x ) - 1 , sys . stdin . readline ( ) . split ( ) ) ) def inps ( ) : return sys . stdin . readline ( ) def inpsl ( x ) : tmp = sys . stdin . readline ( ) ; return list ( tmp [ : x ] ) def err ( x ) : print ( x ) ; exit ( )   mod = 998244353 n = inp ( ) s = inpsl ( n ) if len ( list ( Counter ( s ) ) ) == 1 : print ( ( ( n + 1 ) * n \/\/ 2 ) % mod ) else : l = 0 for i in range ( n + 1 ) : if s [ i ] != s [ i + 1 ] : print ( i + 1 ) break NEW_LINE"],"references":["import sys , os , ioimport math , bisect , operatorinf , mod = float ( ' inf ' ) , 10 ** 9 + 7 NEW_LINE","import sys   n = int ( input ( ) ) a = list ( map ( lambda x : int ( x ) , sys . stdin . readline ( ) . split ( ) ) ) matrix = [ ] for _ in range ( n ) : row = input ( ) row = list ( row ) row = list ( map ( lambda x : int ( x ) , row ) ) matrix . append ( row )   class DisjSet : def __init__ ( self , n ) : NEW_LINE","from bisect import * from collections import * from math import gcd , ceil , sqrt , floor , inffrom heapq import * from itertools import * from operator import add , mul , sub , xor , truediv , floordivfrom functools import *   NEW_LINE","import math , sys , bisect , heapq , osfrom collections import defaultdict , Counter , dequefrom itertools import groupby , accumulatefrom functools import lru_cache NEW_LINE"],"bleu":0.20476161529311868,"rouge_l":0.38141161509114024}
{"id":182,"predictions":["n , k = map ( int , input ( ) . split ( ) ) s = input ( ) f = 0 for i in range ( n ) : if s [ : i ] == s [ i : ] : f = 1 breakif f == 0 : print ( s * k ) : k -= 1 s = sorted ( s ) print ( s * k ) NEW_LINE"],"references":["n , k = map ( int , input ( ) . split ( ) ) ; s = [ i for i in str ( n ) ] ; i = 0 n = len ( s ) for i in range ( n ) : x = i for j in range ( i + 1 , min ( n , i + k + 1 ) ) : if s [ x ] < s [ j ] : x = j NEW_LINE","a , k = map ( int , input ( ) . split ( ) ) a = list ( str ( a ) ) b = \" \" while ( len ( a ) > 0 ) : m = a . index ( max ( a [ : k + 1 ] ) ) k -= m b += a [ m ] a . pop ( m ) print ( b ) NEW_LINE","arr = list ( input ( ) . split ( ) ) s = list ( arr [ 0 ] ) k = int ( arr [ 1 ] ) ans = [ ]   while s : x = s . index ( max ( s [ : k + 1 ] ) ) ans . append ( s [ x ] ) s . pop ( x ) k -= xprint ( ' ' . join ( ans ) ) NEW_LINE","n , k = input ( ) . split ( ) n = [ * n ] k = int ( k ) for i in range ( len ( n ) ) : if k == 0 : break big = i for j in range ( i + 1 , min ( i + k + 1 , len ( n ) ) ) : if n [ j ] > n [ big ] : big = j ch = n [ big ] del n [ big ] n . insert ( i , ch ) k -= big - iprint ( * n , sep = ' ' ) NEW_LINE"],"bleu":0.5115778187131551,"rouge_l":0.4883907125700561}
{"id":183,"predictions":["import sys   input = sys . stdin . readline   t = int ( input ( ) )   for _ in range ( t ) : n = int ( input ( ) )   if n % 2 : print ( \" NO \" ) else : print ( \" YES \" ) NEW_LINE"],"references":["for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) if ( n * ( n - 1 ) \/ 2 ) % 2 == 0 : a = list ( range ( 2 , n + 1 , 2 ) ) b = list ( range ( 1 , n - 1 , 2 ) ) print ( \" YES \" ) print ( * list ( a + b + [ sum ( a ) - sum ( b ) ] ) ) else : print ( \" NO \" ) NEW_LINE","t = int ( input ( ) ) for _ in range ( t ) : n = int ( input ( ) ) a = [ 0 ] * n if ( n % 4 == 0 ) : print ( \" YES \" ) q = 2 for i in range ( 0 , n \/\/ 2 ) : a [ i ] = q q += 2 q = 1 for i in range ( n \/\/ 2 , n ) : a [ i ] = q q += 2 a [ - 1 ] += n \/\/ 2 print ( * a ) else : print ( \" NO \" ) NEW_LINE","if __name__ == ' _ _ main _ _ ' : t = int ( input ( ) ) for i in range ( t ) : n = int ( input ( ) ) times = int ( n \/ 2 ) if times % 2 == 1 : print ( \" NO \" ) continue else : a = [ ] a1 = [ ] a2 = [ ] k = 2 h = 1 for i in range ( times ) : a1 . append ( k ) k += 2   diff = 0 for j in range ( times ) : if j == ( times - 1 ) : a2 . append ( a1 [ j ] + diff ) break a2 . append ( h ) h += 2 diff += 1 a = a1 + a2 print ( \" YES \" ) print ( \" ▁ \" . join ( str ( i ) for i in a ) )   NEW_LINE","no_of_test_cases = int ( input ( ) ) for i in range ( no_of_test_cases ) : items = \" \" result = 0 n = int ( input ( ) ) if n == 2 : print ( \" NO \" ) else : count = n \/\/ 2 for i in range ( 1 , count + 1 ) : items += str ( 2 * i ) + \" ▁ \" result += ( 2 * i ) i = 1 while count > 1 : items += str ( i ) + \" ▁ \" result -= i i += 2 count -= 1   if result % 2 != 0 : items += str ( result ) + \" ▁ \" print ( \" YES \" ) print ( items . strip ( ) ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.3003155870440852,"rouge_l":0.4463623267850541}
{"id":184,"predictions":["from collections import defaultdict , deque , Counterfrom sys import stdin , stdoutfrom heapq import heappush , heappopimport mathimport ioimport osimport mathimport bisect   NEW_LINE"],"references":["word = input ( ) ans = 0 num = { }   for i in word : num [ i ] = num . get ( i , 0 ) + 1   for j in num . values ( ) : ans += j ** 2   print ( ans ) NEW_LINE","m = input ( ) n = { } s = 0 for each in m : n [ each ] = n . get ( each , 0 ) + 1 for i in n : s += n [ i ] * n [ i ] print ( s ) NEW_LINE","n = input ( ) m = list ( str ( n ) ) a = [ ] for x in set ( m ) : a . append ( m . count ( x ) ) b = 0 for y in range ( len ( a ) ) : b += ( a [ y ] ) ** 2 print ( b ) NEW_LINE","n = input ( ) count = 0 d = { } for i in n : if i not in d : d [ i ] = 1 else : d [ i ] += 1 for i in d . values ( ) : count += i ** 2 print ( count ) ''' class ▁ Person : ▁ ▁ ▁ ▁ _ num = 0 ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ def ▁ _ _ init _ _ ( self , name , sex , birthday , ident ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ not ▁ ( isinstance ( name , str ) ▁ and ▁ sex ▁ in ▁ ( \" 女 \" , \" 男 \" ) ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ raise ▁ PersonValueError ( name , sex ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ try : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ birth = datetime . date ( * birthday ) ▁ # 生成一个日期对象 ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ except : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ raise ▁ PersionValueError ( \" Wrong ▁ date : \" , birthday ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ self . _ name = name ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ self . _ sex = sex ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ self . _ birthday = birth ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ self . _ id = ident ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Person . _ num + = 1 ▁ ▁ ▁ ▁ # 实例计数   ▁ ▁ ▁ ▁ def ▁ id ( self ) : ▁ return ▁ self . _ id ▁ ▁ ▁ ▁ def ▁ name ( self ) : ▁ return ▁ self . _ name ▁ ▁ ▁ ▁ def ▁ sex ( self ) : ▁ return ▁ self . _ sex ▁ ▁ ▁ ▁ def ▁ birthday ( self ) : ▁ return ▁ self . _ birthday ▁ ▁ ▁ ▁ def ▁ age ( self ) : ▁ return ▁ ( datetime . date . today ( ) . year ( ) . year - self . _ birthday . year )   ▁ ▁ ▁ ▁ def ▁ set _ name ( self , name ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ not ▁ isinstance ( name , str ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ raise ▁ PersonValueError ( \" set _ name \" , name ) ▁ ▁ ▁ ▁ def ▁ _ _ lt _ _ ( self , another ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ not ▁ isinstance ( another , Person ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ raise ▁ PersonTypeError ( another ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ return ▁ self . _ id < another . _ id ''' NEW_LINE","n = input ( ) count = 0 d = { } for i in n : if i not in d : d [ i ] = 1 else : d [ i ] += 1 for i in d . values ( ) : count += i ** 2 print ( count ) ''' class ▁ Person : ▁ ▁ ▁ ▁ _ num = 0 ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ def ▁ _ _ init _ _ ( self , name , sex , birthday , ident ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ not ▁ ( isinstance ( name , str ) ▁ and ▁ sex ▁ in ▁ ( \" 女 \" , \" 男 \" ) ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ raise ▁ PersonValueError ( name , sex ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ try : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ birth = datetime . date ( * birthday ) ▁ # 生成一个日期对象 ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ except : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ raise ▁ PersionValueError ( \" Wrong ▁ date : \" , birthday ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ self . _ name = name ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ self . _ sex = sex ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ self . _ birthday = birth ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ self . _ id = ident ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Person . _ num + = 1 ▁ ▁ ▁ ▁ # 实例计数   ▁ ▁ ▁ ▁ def ▁ id ( self ) : ▁ return ▁ self . _ id ▁ ▁ ▁ ▁ def ▁ name ( self ) : ▁ return ▁ self . _ name ▁ ▁ ▁ ▁ def ▁ sex ( self ) : ▁ return ▁ self . _ sex ▁ ▁ ▁ ▁ def ▁ birthday ( self ) : ▁ return ▁ self . _ birthday ▁ ▁ ▁ ▁ def ▁ age ( self ) : ▁ return ▁ ( datetime . date . today ( ) . year ( ) . year - self . _ birthday . year )   ▁ ▁ ▁ ▁ def ▁ set _ name ( self , name ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ not ▁ isinstance ( name , str ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ raise ▁ PersonValueError ( \" set _ name \" , name ) ▁ ▁ ▁ ▁ def ▁ _ _ lt _ _ ( self , another ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ not ▁ isinstance ( another , Person ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ raise ▁ PersonTypeError ( another ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ return ▁ self . _ id < another . _ id ''' NEW_LINE"],"bleu":0.021646170685666637,"rouge_l":0.08109904719698649}
{"id":185,"predictions":["n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l . sort ( ) i = 1 while i in l : i += 1   print ( i ) NEW_LINE"],"references":["from sys import stdin , stdoutfrom os import pathif path . exists ( \" input . txt \" ) : stdin = open ( \" input . txt \" , ' r ' ) wr = stdout . writerd = lambda : stdin . readline ( ) . strip ( ) NEW_LINE","def subset ( s1 , s2 ) : d = { } for i in s1 : d [ i ] = 1 flag = 0 for i in s2 : if i not in d : flag = 1 break if flag == 0 : return True else : return False n = int ( input ( ) ) l = [ ] for i in range ( n ) : l . append ( list ( map ( int , input ( ) . split ( ) ) ) [ 1 : ] ) for i in range ( n ) : ans = ' YES ' for j in range ( n ) : if i != j : if subset ( l [ i ] , l [ j ] ) : ans = \" NO \" break print ( ans ) NEW_LINE","a = int ( input ( ) ) ; l = [ list ( map ( int , input ( ) . split ( ) [ 1 : ] ) ) for _ in \" ▁ \" * a ] for i in range ( a ) : for j in range ( a ) : if i != j and all ( k in l [ i ] for k in l [ j ] ) : print ( \" NO \" ) ; break else : print ( \" YES \" ) NEW_LINE","n = int ( input ( ) ) c = [ [ int ( s ) for s in input ( ) . split ( ) ] [ 1 : ] for x in range ( n ) ]   for i in range ( n ) : for j in range ( n ) : if i != j : for k in c [ j ] : if k not in c [ i ] : break else : print ( \" NO \" ) break else : print ( \" YES \" ) NEW_LINE","def subset ( s1 , s2 ) : d = { } for i in s1 : d [ i ] = 1 flag = 0 for i in s2 : if i not in d : flag = 1 break if flag == 0 : return True else : return False n = int ( input ( ) ) l = [ ] for i in range ( n ) : l . append ( list ( map ( int , input ( ) . split ( ) ) ) [ 1 : ] ) for i in range ( n ) : ans = ' YES ' for j in range ( n ) : if i != j : if subset ( l [ i ] , l [ j ] ) : ans = \" NO \" break print ( ans ) NEW_LINE"],"bleu":0.5326958649864931,"rouge_l":0.46463547334058747}
{"id":186,"predictions":["for _ in range ( int ( input ( ) ) ) : n , t = map ( int , input ( ) . split ( ) ) NEW_LINE li = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE tmp = 0 NEW_LINE for i in range ( n ) : if NEW_LINE li [ i ] < t \/ 2 : li [ i ] = 0 elif li [ i ] > t \/ 2 : li [ i ] = 1 else : li [ i ] = tmp % 2 NEW_LINE tmp += 1 NEW_LINE print ( * li ) NEW_LINE"],"references":["for _ in range ( int ( input ( ) ) ) : n , k = map ( int , input ( ) . split ( ) ) NEW_LINE l = list ( ) NEW_LINE for i in range ( n ) : x = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l . append ( x ) NEW_LINE for i in l : c = 1 NEW_LINE for j in l : if NEW_LINE abs ( i [ 0 ] - j [ 0 ] ) + abs ( i [ 1 ] - j [ 1 ] ) > k : c = 0 NEW_LINE break NEW_LINE if c == 1 : print ( 1 ) NEW_LINE break NEW_LINE if c == 0 : print ( - 1 )   NEW_LINE","def is_ok ( points ) :     NEW_LINE for i in range ( len ( points ) ) : poss = True NEW_LINE for j in range ( len ( points ) ) : if NEW_LINE abs ( points [ i ] [ 0 ] - points [ j ] [ 0 ] ) + abs ( points [ i ] [ 1 ] - points [ j ] [ 1 ] ) > k : NEW_LINE","def solve ( ) : n , k = map ( int , input ( ) . split ( ) ) NEW_LINE p = [ None ] * n NEW_LINE for i in range ( n ) : a , b = map ( int , input ( ) . split ( ) ) NEW_LINE p [ i ] = ( a , b ) NEW_LINE for i in range ( n ) : for NEW_LINE j in range ( n ) : NEW_LINE if abs ( p [ i ] [ 0 ] - p [ j ] [ 0 ] ) + abs ( p [ i ] [ 1 ] - p [ j ] [ 1 ] ) > k : NEW_LINE INDENT break else : NEW_LINE print ( 1 ) NEW_LINE DEDENT return print ( - 1 )   for _ in range ( int ( input ( ) ) ) : solve ( ) NEW_LINE","import functoolsdef NEW_LINE comp ( a , b ) : NEW_LINE if ( len ( a ) < len ( b ) ) : return 1 NEW_LINE if ( len ( a ) == len ( b ) ) : NEW_LINE INDENT return 0 else : NEW_LINE return - 1 NEW_LINE DEDENT def solve ( ) : n , k = input ( ) . split ( ) NEW_LINE n = int ( n ) NEW_LINE k = int ( k ) NEW_LINE p_x = [ ] NEW_LINE p_y = [ ] NEW_LINE for i in range ( n ) : x , y = input ( ) . split ( ) NEW_LINE p_x . append ( int ( x ) ) NEW_LINE p_y . append ( int ( y ) ) NEW_LINE","t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : n , k = map ( int , input ( ) . split ( ) ) NEW_LINE ali = [ ] NEW_LINE for i in range ( n ) : li = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ali . append ( li ) NEW_LINE for i in range ( 0 , n ) : f = 0 NEW_LINE for j in range ( n ) : q = abs ( ali [ i ] [ 0 ] - ali [ j ] [ 0 ] ) NEW_LINE w = abs ( ali [ i ] [ 1 ] - ali [ j ] [ 1 ] ) NEW_LINE if ( q + w > k ) : f = 1 NEW_LINE break NEW_LINE if ( f == 0 ) : break NEW_LINE if ( f == 1 ) : NEW_LINE INDENT print ( - 1 ) else : NEW_LINE print ( 1 )                       NEW_LINE DEDENT"],"bleu":0.5896199524204966,"rouge_l":0.5468491094068363}
{"id":187,"predictions":["for t in range ( int ( input ( ) ) ) : n = int ( input ( ) ) print ( n ) NEW_LINE"],"references":["n = int ( input ( ) ) if n % 2 == 0 : print ( n \/\/ 2 ) print ( '2 ▁ ' * ( n \/\/ 2 ) ) else : n = n - 3 print ( n \/\/ 2 + 1 ) print ( '2 ▁ ' * ( n \/\/ 2 ) + '3' ) NEW_LINE","n = int ( input ( ) ) ans = [ 2 for i in range ( n \/\/ 2 ) ] if n % 2 : ans [ - 1 ] = 3 print ( n \/\/ 2 ) for x in ans : print ( x , end = \" ▁ \" )     NEW_LINE","n = int ( input ( ) ) if n % 2 == 0 : print ( n \/\/ 2 ) print ( '2 ▁ ' * ( n \/\/ 2 ) , sep = ' ▁ ' ) else : print ( ( n - 3 ) \/\/ 2 + 1 ) print ( '3' , '2 ▁ ' * ( ( n - 3 ) \/\/ 2 ) , sep = ' ▁ ' ) NEW_LINE","n = int ( input ( ) )   i = 0   if n % 2 == 0 : print ( n \/\/ 2 ) for i in range ( n \/\/ 2 ) : print ( 2 , end = \" ▁ \" ) else : print ( n \/\/ 2 ) for i in range ( n \/\/ 2 - 1 ) : print ( 2 , end = \" ▁ \" ) print ( 3 ) NEW_LINE","n = int ( input ( ) )   if n % 2 == 0 : print ( n \/\/ 2 ) for i in range ( n \/\/ 2 ) : print ( 2 ) elif n % 2 != 0 : print ( ( n - 1 ) \/\/ 2 ) m = [ 2 ] * ( ( n - 1 ) \/\/ 2 ) m [ - 1 ] = 3 print ( ' ▁ ' . join ( str ( x ) for x in m ) )                       NEW_LINE"],"bleu":0.15860611101258618,"rouge_l":0.3598334425723869}
{"id":188,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) f = [ 0 ] * ( max ( a ) + 1 ) for i in a : f [ i ] += 1 c = 0 for i in f : if ( i % 2 != 0 ) : c = 1 breakif ( c == 0 ) : print ( ' Agasa ' ) else : print ( ' Conan ' ) NEW_LINE"],"references":["import mathinfo = [ int ( x ) for x in input ( ) . split ( ) ] lanes = info [ 0 ] desks = info [ 1 ] location = info [ 2 ] seats_in_lane = 2 * deskslane = math . ceil ( location \/ seats_in_lane ) starting_group = ( ( lane - 1 ) * seats_in_lane ) + 1 NEW_LINE","s = input ( ) . split ( ) n = int ( s [ 0 ] ) m = int ( s [ 1 ] ) k = int ( s [ 2 ] ) if k % 2 == 0 : k = int ( k \/ 2 ) a = int ( k \/ m ) b = k % m if b != 0 : print ( a + 1 , b , ' R ' ) else : print ( a , m , ' R ' ) else : k = int ( ( k + 1 ) \/ 2 ) a = int ( k \/ m ) b = k % m if b != 0 : print ( a + 1 , b , ' L ' ) else : print ( a , m , ' L ' )                     NEW_LINE","n , m , k = map ( int , input ( ) . split ( ) ) print ( ( k - 1 ) \/\/ ( m * 2 ) + 1 , ( k - 1 ) % ( 2 * m ) \/\/ 2 + 1 , ' R ' if k % 2 == 0 else ' L ' ) NEW_LINE","def STR ( ) : return list ( input ( ) ) def INT ( ) : return int ( input ( ) ) def MAP ( ) : return map ( int , input ( ) . split ( ) ) def MAP2 ( ) : return map ( float , input ( ) . split ( ) ) def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) def STRING ( ) : return input ( ) import stringimport sysfrom heapq import heappop , heappushfrom bisect import * from collections import deque , Counter , defaultdictfrom math import * from itertools import permutations , accumulatedx = [ - 1 , 1 , 0 , 0 ] dy = [ 0 , 0 , 1 , - 1 ] NEW_LINE","n , m , k = map ( int , input ( ) . split ( ) )   total = n * m * 2     per_lane = m * 2   lane = ( k + per_lane - 1 ) \/\/ per_lane   new_k = k % per_laneif new_k == 0 : new_k = per_lane   side = Noneif new_k % 2 == 0 : side = \" R \" row = new_k \/\/ 2 else : side = \" L \" row = new_k \/\/ 2 + 1   print ( lane , row , side )   NEW_LINE"],"bleu":0.41937458615989687,"rouge_l":0.4864521975532397}
{"id":189,"predictions":["n , m = map ( int , input ( ) . split ( ) ) f = n \/\/ mq = n % m   mini = ( f * ( f - 1 ) ) \/\/ ( 1 + 1 ) mini *= mmini += f * t ma = n - mma = ( ma * ( ma + 1 ) ) \/\/ ( 1 + 1 ) print ( mini , ma ) NEW_LINE"],"references":["for _ in range ( int ( input ( ) ) ) : input ( ) NEW_LINE n = [ i for i in input ( ) ] NEW_LINE n . sort ( ) NEW_LINE print ( \" \" . join ( n ) ) NEW_LINE","for nt in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEW_LINE a = list ( input ( ) ) NEW_LINE print ( \" \" . join ( sorted ( a ) ) ) NEW_LINE","t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE i = 0 NEW_LINE j = n - 1 NEW_LINE while ( i < j ) : if NEW_LINE s [ j ] == ' t ' : j -= 1 NEW_LINE if s [ i ] == ' t ' : a = ' ' + s [ i ] NEW_LINE b = ' ' + s [ j ] NEW_LINE s = s [ : i ] + b + s [ i + 1 : ] NEW_LINE s = s [ : j ] + a + s [ j + 1 : ] else : i += 1 NEW_LINE print ( s ) NEW_LINE","import sysinput = sys . stdin . readline   for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEW_LINE a = input ( ) NEW_LINE target = ' trygub ' NEW_LINE b = ' ' NEW_LINE i = 0 NEW_LINE count = 0 NEW_LINE for e in a : if NEW_LINE i == 5 and e == target [ i ] : count += 1 NEW_LINE continue NEW_LINE if e == target [ i ] : i += 1 NEW_LINE b += e NEW_LINE b = ' b ' * ( count ) + b NEW_LINE print ( b ) NEW_LINE","import mathdef NEW_LINE getint ( ) : NEW_LINE return [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE def getstr ( ) : return [ str ( i ) for i in input ( ) . split ( ) ] NEW_LINE"],"bleu":0.1806752488381901,"rouge_l":0.41821329639889193}
{"id":190,"predictions":["b = int ( input ( ) ) def make_divisors ( n ) : divisors = [ ] for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : if n % i == 0 : divisors . append ( i ) if i != n \/\/ i : divisors . append ( n \/\/ i ) NEW_LINE"],"references":["def gcd ( a , b ) : while a % b : a , b = b , a % b return ba , b = map ( int , input ( ) . split ( ) ) g = gcd ( a , b ) a \/\/= gb \/\/= gcnt = 0 for i in [ 2 , 3 , 5 ] : while a % i == 0 : a \/\/= i cnt += 1 while b % i == 0 : b \/\/= i cnt += 1 if a == 1 and b == 1 : print ( cnt ) else : print ( - 1 ) NEW_LINE","def reduceToSmallest ( a , table ) : while True : if a % 2 == 0 : table [ 0 ] += 1 a = a \/\/ 2 elif a % 3 == 0 : table [ 1 ] += 1 a = a \/\/ 3 elif a % 5 == 0 : table [ 2 ] += 1 a = a \/\/ 5 else : break return a                                       a , b = list ( map ( int , input ( ) . split ( ) ) ) if a == b : print ( 0 ) else : table = [ 0 ] * 3 table2 = [ 0 ] * 3 smallA = reduceToSmallest ( a , table ) smallB = reduceToSmallest ( b , table2 ) if smallA != smallB : print ( - 1 ) else : print ( abs ( table [ 0 ] - table2 [ 0 ] ) + abs ( table [ 1 ] - table2 [ 1 ] ) + abs ( table [ 2 ] - table2 [ 2 ] ) ) NEW_LINE","import math   def gcd ( a , b ) : if a < b : a , b = b , a while a % b != 0 : a , b = b , a % b return b   a , b = map ( int , input ( ) . split ( ) )   res = 0   for i in [ 2 , 3 , 5 ] : r = 0 while a % i == 0 : a \/\/= i r += 1 while b % i == 0 : b \/\/= i r -= 1 res += abs ( r )   if gcd ( a , b ) == 1 and a != b : print ( - 1 ) else : print ( res )       NEW_LINE"],"bleu":0.08927996107072807,"rouge_l":0.29243607954545453}
{"id":191,"predictions":["t = int ( input ( ) ) for i in range ( t ) : n = int ( input ( ) ) if ( n <= 3 ) : print ( 4 - n ) else : print ( n % 2 ) NEW_LINE"],"references":["n , t = list ( map ( int , input ( ) . split ( ) ) ) a = list ( map ( int , input ( ) . split ( ) ) ) i = 1 while i < t : i += a [ i - 1 ] print ( ' YES ' if i == t else ' NO ' ) NEW_LINE","n , k = [ int ( i ) for i in input ( ) . split ( ) ] a = [ int ( i ) for i in input ( ) . split ( ) ] i = 0 while i < n : if i == k - 1 : print ( \" YES \" ) break else : if i == n - 1 : i = i + 1 else : i = i + a [ i ] else : print ( \" NO \" ) NEW_LINE","n , t = ( int ( x ) for x in input ( ) . strip ( ) . split ( \" ▁ \" ) ) a = [ 0 ] + [ int ( x ) for x in input ( ) . strip ( ) . split ( \" ▁ \" ) ]   out = [ 1 ] j = 1 while j < n : j = j + a [ j ] out . append ( j )   if t in out : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE","def solve ( ) : n , t = inl ( ) l = inl ( ) i = 0 NEW_LINE","I = lambda : map ( int , input ( ) . split ( ) ) n , t = I ( ) a = * I ( ) , x = 0 while x < t - 1 : x += a [ x ] print ( ' YNEOS ' [ x >= t : : 2 ] ) NEW_LINE"],"bleu":0.3206697642889019,"rouge_l":0.5354008191925101}
{"id":192,"predictions":["n , k = map ( int , input ( ) . split ( ) ) a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) result = 0 for i in range ( n - 1 ) : if a [ i ] != a [ i + 1 ] : result += a [ i ] - a [ i ] print ( result ) NEW_LINE"],"references":["n , l = map ( int , input ( ) . split ( ) ) lights = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True )   max_dif = 0   for i in range ( len ( lights ) - 1 ) : max_dif = max ( max_dif , lights [ i ] - lights [ i + 1 ] )   print ( format ( max ( max_dif \/ 2 , lights [ - 1 ] , l - lights [ 0 ] ) , ' . 10f ' ) ) NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) arr . sort ( ) count = arr [ 0 ] for i in range ( 1 , n ) : if ( ( arr [ i ] - arr [ i - 1 ] ) \/ 2 > count ) : count = ( arr [ i ] - arr [ i - 1 ] ) \/ 2 if ( m - arr [ - 1 ] > count ) : count = m - arr [ - 1 ] print ( count ) NEW_LINE","import sys   def input ( ) : return sys . stdin . readline ( ) . strip ( ) def iinput ( ) : return int ( input ( ) ) def rinput ( ) : return map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) def get_list ( ) : return list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) )     n , l = rinput ( ) a = get_list ( ) a . sort ( )   maxi = max ( a [ 0 ] - 0 , l - a [ - 1 ] )   for i in range ( 1 , n ) : l = ( a [ i ] - a [ i - 1 ] ) \/ 2 maxi = max ( maxi , l )   print ( maxi ) NEW_LINE","n , l = map ( int , input ( ) . split ( ) ) lanterns = list ( map ( int , input ( ) . split ( ) ) )   sorted_lanterns = sorted ( lanterns )   largest_distance = 0 for i in range ( 1 , n ) : largest_distance = max ( sorted_lanterns [ i ] - sorted_lanterns [ i - 1 ] , largest_distance )     d = max ( largest_distance \/ 2.0 , sorted_lanterns [ 0 ] , l - sorted_lanterns [ - 1 ] )   print ( d ) NEW_LINE"],"bleu":0.5491696647882863,"rouge_l":0.6479623787411529}
{"id":193,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] dp [ 0 ] [ 0 ] = dp [ 0 ] [ 1 ] = dp [ 1 ] [ 0 ] for i in range ( 1 , n + 1 ) : for j in range ( 1 , n + 1 ) : if a [ i ] == j : dp [ i ] [ j ] = dp [ i - 1 ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j - 1 ] ) + 1 print ( max ( dp [ i ] ) ) NEW_LINE"],"references":["n = [ int ( i ) for i in input ( ) ] for x in [ 1 , 6 , 8 , 9 ] : for i in range ( len ( n ) ) : if n [ i ] == x : del n [ i ] break   prefix = [ 1869 , 6189 , 1689 , 6198 , 1698 , 9861 , 1896 ] res = sum ( [ n [ i ] * pow ( 10 , len ( n ) - i - 1 , 7 ) for i in range ( len ( n ) ) ] ) print ( prefix [ - res * pow ( 10 , 5 * len ( n ) , 7 ) % 7 ] , end = ' ' ) print ( * n , sep = ' ' ) NEW_LINE","''' ▁ ▁ ▁ ▁ Auther : ▁ ghoshashis545 ▁ Ashis ▁ Ghosh ▁ ▁ ▁ ▁ College : ▁ jalpaiguri ▁ Govt ▁ Enggineering ▁ College  ''' from os import pathimport sysfrom heapq import heappush , heappopfrom functools import cmp_to_key as ctkfrom collections import deque , defaultdict as dd from bisect import bisect , bisect_left , bisect_right , insort , insort_left , insort_rightfrom itertools import permutationsfrom datetime import datetimefrom math import sqrt , log , gcddef ii ( ) : return int ( input ( ) ) def si ( ) : return input ( ) . rstrip ( ) def mi ( ) : return map ( int , input ( ) . split ( ) ) def li ( ) : return list ( mi ( ) ) def ceil ( a , b ) : return ( a + b - 1 ) \/\/ babc = ' abcdefghijklmnopqrstuvwxyz ' mod = 1000000007 NEW_LINE"],"bleu":0.25453927800988707,"rouge_l":0.36106328024106754}
{"id":194,"predictions":["t = int ( input ( ) )   for tc in range ( t ) : n , m = map ( int , input ( ) . split ( ) ) NEW_LINE bottom = [ int ( b ) for b in input ( ) . split ( ) ] NEW_LINE left = [ int ( l ) for l in input ( ) . split ( ) ]   print ( len ( bottom + left ) - len ( set ( bottom + left ) ) ) NEW_LINE"],"references":["t = int ( input ( ) ) s = [ ] for i in range ( t ) : k = 0 x = list ( map ( int , input ( ) . split ( ) ) ) n = x [ 0 ] m = x [ 1 ] indices1 = [ ] mylist = [ ] for j in range ( n ) : y = list ( map ( str , input ( ) . split ( ) ) ) indices = [ o for o , z in enumerate ( y ) if z == \"1\" ] NEW_LINE","import matht = int ( input ( ) ) for i in range ( t ) : n , m = map ( int , input ( ) . split ( ) ) l = [ ] for i in range ( n ) : x = list ( map ( int , input ( ) . split ( ) ) ) l . append ( x ) res = 0 for i in range ( n ) : for j in range ( m ) : if l [ i ] [ j ] == 1 : res += 1 break ans = 0 for i in range ( m ) : for j in range ( n ) : if l [ j ] [ i ] == 1 : ans += 1 break ans = m - ans res = n - res r = min ( ans , res )               if r % 2 == 0 : print ( \" Vivek \" ) else : print ( \" Ashish \" )                                                                             NEW_LINE","for i in range ( int ( input ( ) ) ) : n , m = [ int ( i ) for i in input ( ) . split ( ) ] l = [ ] count = 0 row = 0 for i in range ( n ) : k = [ int ( j ) for j in input ( ) . split ( ) ] if 1 not in k : row += 1 l . append ( k ) col = 0 for i in range ( m ) : flag = False for j in range ( n ) : if l [ j ] [ i ] == 1 : flag = True break if not flag : col += 1 ans = min ( row , col ) if ans % 2 == 0 : print ( \" Vivek \" ) else : print ( \" Ashish \" ) NEW_LINE","from itertools import accumulate as acfrom collections import Counter as ccfrom bisect import bisect_left as bslfrom bisect import bisect as bsfrom math import factorial as ffrom collections import * from itertools import * from string import * from bisect import * from queue import * from heapq import * from math import * from sys import * from re import * def fast ( ) : return stdin . readline ( ) . strip ( ) def zzz ( ) : return [ int ( i ) for i in fast ( ) . split ( ) ]     z , zz = input , lambda : list ( map ( int , z ( ) . split ( ) ) ) szz , graph , mod , szzz = lambda : sorted ( zz ( ) ) , { } , 10 ** 9 + 7 , lambda : sorted ( zzz ( ) )     def lcd ( xnum1 , xnum2 ) : return ( xnum1 * xnum2 \/\/ gcd ( xnum1 , xnum2 ) ) def output ( answer ) : stdout . write ( str ( answer ) )     NEW_LINE","from collections import Counterfor _ in range ( int ( input ( ) ) ) : n , m = map ( int , input ( ) . split ( ) ) arr = [ ] for j in range ( n ) : arr . append ( list ( map ( int , input ( ) . split ( ) ) ) ) arr1 = [ ] for x in range ( m ) : arr2 = [ ] for y in range ( n ) : arr2 . append ( arr [ y ] [ x ] ) arr1 . append ( arr2 ) count = 0 for p in arr1 : flag = 0 for l in p : if l == 1 : flag = 1 break if flag == 0 : count += 1 c = 0 for pp in arr : flag = 0 for ll in pp : if ll == 1 : flag = 1 break if flag == 0 : c += 1 w = min ( count , c ) if w % 2 == 0 : print ( ' Vivek ' ) else : print ( ' Ashish ' )                                       NEW_LINE"],"bleu":0.4873400662908924,"rouge_l":0.5141491081958444}
{"id":195,"predictions":["n = int ( input ( ) ) c = 0 while n > 0 : n = str ( n ) NEW_LINE"],"references":["n = int ( input ( ) ) s = str ( input ( ) ) ans = 0 for i in range ( n ) : if int ( s [ i ] ) % 2 == 0 : ans += ( i + 1 ) print ( ans ) NEW_LINE","n = int ( input ( ) ) s = input ( ) l = [ ] c = 0 ans = 0 for i in range ( n ) : if ( int ( s [ i ] ) % 2 == 0 ) : c += 1 l . append ( i ) NEW_LINE","import sys   def main ( ) : _ , s = sys . stdin . read ( ) . strip ( ) . split ( ) return sum ( i + 1 for i , j in enumerate ( map ( int , s ) ) if not j % 2 ) print ( main ( ) ) NEW_LINE","def string_list ( s , char ) : output_list = [ ] intermediator = \" \" for i in range ( len ( s ) ) : if s [ i ] != char : intermediator += s [ i ] if i == len ( s ) - 1 : output_list . append ( int ( intermediator ) ) else : if intermediator : output_list . append ( int ( intermediator ) ) intermediator = \" \" return output_list     def list_string ( l , char ) : output_str = \" \" for i in range ( len ( l ) - 1 ) : output_str += str ( l [ i ] ) + char output_str += str ( l [ len ( l ) - 1 ] ) return output_str     def merge_sort ( l ) : def merge ( l1 , l2 ) : i , j = 0 , 0 output_list = [ ] while i < len ( l1 ) and j < len ( l2 ) : if l1 [ i ] < l2 [ j ] : output_list . append ( l1 [ i ] ) i += 1 else : output_list . append ( l2 [ j ] ) j += 1 if i == len ( l1 ) : output_list += ( l2 [ j : ] ) else : output_list += ( l1 [ i : ] ) return output_list   def sorts ( l ) : if len ( l ) < 2 : return l else : mid = len ( l ) \/\/ 2 left = sorts ( l [ : mid ] ) right = sorts ( l [ mid : ] ) return merge ( left , right ) return sorts ( l )       NEW_LINE"],"bleu":0.15027567038520362,"rouge_l":0.4044461778471139}
{"id":196,"predictions":["import sys , os , ioimport math , bisect , operatorinf , mod = float ( ' inf ' ) , 10 ** 9 + 7 NEW_LINE"],"references":["from math import log2   def main ( ) : t = int ( input ( ) ) allAns = [ ] MOD = 10 ** 9 + 7 for _ in range ( t ) : n , p = readIntArr ( ) a = readIntArr ( ) if p == 1 : NEW_LINE"],"bleu":0.07342946783064977,"rouge_l":0.22975517890772132}
{"id":197,"predictions":["a , b , c , d = map ( int , input ( ) . split ( ) ) misha = max ( 3 * a \/ 10 , a - ( a \/ 250 ) * c ) vasya = max ( 3 * b \/ 10 , b - ( b \/ 250 ) * d )   if vasya > misha : print ( \" Vasya \" ) if misha > vasya : print ( \" Misha \" ) if misha == vasya : print ( \" Tie \" ) NEW_LINE"],"references":["def isquare ( n ) : h = n l = 1 while h - l > 1 : m = ( h + l ) \/\/ 2 if m * m <= n : l = m elif m * m > n : h = m return la , b = map ( int , input ( ) . split ( ) ) lsta = [ ] lstb = [ ] for i in range ( 3 , a ) : if isquare ( a * a - i * i ) ** 2 == a * a - i * i : lsta . append ( [ i , isquare ( a * a - i * i ) ] ) for i in range ( 3 , b ) : if isquare ( b * b - i * i ) ** 2 == b * b - i * i : lstb . append ( [ i , isquare ( b * b - i * i ) ] ) flag = Falsefor p , q in lsta : for r , s in lstb : if p * r == q * s : if q == s : p , q , r , s = p , q , r , - s else : p , q , r , s = p , q , - r , s flag = True break if flag : breakif flag : print ( \" YES \\n \" , 0 , 0 , ' \\n ' , p , q , ' \\n ' , r , s ) else : print ( \" NO \" ) NEW_LINE","from collections import defaultdict , deque , Counterfrom sys import stdin , stdoutfrom heapq import heappush , heappopimport mathimport ioimport osimport mathimport bisect   NEW_LINE"],"bleu":0.28062328549719945,"rouge_l":0.3117444717444718}
{"id":198,"predictions":["n , k = map ( int , input ( ) . split ( ) ) a = [ int ( i ) for i in input ( ) . split ( ) ] d = { } for i in range ( n - k + 1 ) : d [ i ] = ( a [ i + k - 1 ] + a [ i ] ) print ( * d ) NEW_LINE"],"references":["m , k = [ int ( i ) for i in input ( ) . split ( ) ]   days = [ int ( i ) for i in input ( ) . split ( ) ]     s1 = 0 for q in range ( 1 , m ) : if days [ q ] + days [ q - 1 ] < k : s1 += k - ( days [ q ] + days [ q - 1 ] ) days [ q ] += k - ( days [ q ] + days [ q - 1 ] )   print ( s1 ) print ( * days ) NEW_LINE","n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) count = sum ( a ) for i in range ( n - 1 ) : if ( a [ i ] + a [ i + 1 ] < k ) : add = k - a [ i ] a [ i + 1 ] = addcount1 = sum ( a ) print ( count1 - count ) print ( * a , sep = \" ▁ \" ) NEW_LINE","n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in range ( 1 , n ) : if k - a [ i - 1 ] > a [ i ] : c += k - a [ i - 1 ] - a [ i ] a [ i ] = k - a [ i - 1 ] print ( c ) print ( * a ) NEW_LINE","n , k = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) ans = 0 for i in range ( 1 , n ) : if l [ i ] + l [ i - 1 ] < k : ans = ans + k - l [ i ] - l [ i - 1 ] l [ i ] = l [ i ] + k - ( l [ i ] + l [ i - 1 ] ) print ( ans ) print ( * l ) NEW_LINE","inp = list ( map ( int , input ( ) . split ( \" ▁ \" ) ) ) walks = list ( map ( int , input ( ) . split ( \" ▁ \" ) ) ) n = inp [ 0 ] k = inp [ 1 ] total_modified_walks = 0 for i in range ( 1 , len ( walks ) ) : total_walks_in_2d = walks [ i ] + walks [ i - 1 ] if total_walks_in_2d < k : total_modified_walks += k - total_walks_in_2d walks [ i ] = k - walks [ i - 1 ]   print ( total_modified_walks ) print ( ' ▁ ' . join ( [ str ( i ) for i in walks ] ) ) NEW_LINE"],"bleu":0.5512653888346707,"rouge_l":0.6216032608695653}
{"id":199,"predictions":["n = int ( input ( ) ) s = input ( ) ans = 1 for i in range ( n - 1 ) : if s [ i ] != s [ i + 1 ] : ans = iprint ( ans ) NEW_LINE"],"references":["n = int ( input ( ) ) A = [ int ( d ) for d in input ( ) ] f = [ int ( x ) for x in input ( ) . split ( ) ] flag = Falsefor i in range ( n ) : d = A [ i ] x = f [ A [ i ] - 1 ] if x > d : flag = True A [ i ] = x elif x == d : continue else : if flag : breakA = list ( map ( str , A ) ) print ( ' ' . join ( A ) ) NEW_LINE","def solve ( n , x , f ) : start = None end = None for i in range ( n ) : if start is None : if f [ int ( x [ i ] ) ] > x [ i ] : start , end = i , i if start is not None : if f [ int ( x [ i ] ) ] < x [ i ] : break end = i if start is None : return x NEW_LINE","n = int ( input ( ) )   string = input ( )   lst = list ( map ( int , input ( ) . split ( ) ) )   pos = - 1   for i in range ( n ) : x = ord ( string [ i ] ) - 48 if x < lst [ x - 1 ] : pos = i break   if pos == - 1 :   print ( string )   else : lstrs = [ ]   for i in range ( pos ) : lstrs . append ( string [ i ] )   pos2 = n   for i in range ( pos , n ) : x = ord ( string [ i ] ) - 48 if x > lst [ x - 1 ] : pos2 = i break lstrs . append ( str ( lst [ x - 1 ] ) )   for i in range ( pos2 , n ) : lstrs . append ( string [ i ] )   print ( \" \" . join ( lstrs ) ) NEW_LINE","from sys import stdin , stdoutstdin . readlinedef mp ( ) : return list ( map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) ) def it ( ) : return int ( stdin . readline ( ) . strip ( ) ) from math import ceilfrom collections import defaultdict as dd   n = it ( ) s = input ( ) l = mp ( ) v = [ ] flag = 0 for i in range ( n ) : if l [ int ( s [ i ] ) - 1 ] > int ( s [ i ] ) : v . append ( str ( l [ int ( s [ i ] ) - 1 ] ) ) flag = 1 elif l [ int ( s [ i ] ) - 1 ] == int ( s [ i ] ) : v . append ( s [ i ] ) else : v . append ( s [ i ] ) if flag == 1 : k = i + 1 break NEW_LINE"],"bleu":0.2255114110368796,"rouge_l":0.3902549355391128}
{"id":200,"predictions":["import sys , os , ioimport math , bisect , operatorinf , mod = float ( ' inf ' ) , 10 ** 9 + 7 NEW_LINE"],"references":["import sysfrom math import gcd , sqrt , ceil , log2from collections import defaultdict , Counter , dequefrom bisect import bisect_left , bisect_rightimport mathimport heapqfrom itertools import permutations   NEW_LINE","s = input ( ) st , v , vi , vj , vc = [ ] , [ ] , 0 , 0 , 0 for i , c in enumerate ( s ) : if c in ' [ ( ' : st . append ( i ) continue if st and s [ st [ - 1 ] ] + c in ( ' ( ) ' , ' [ ] ' ) : b = ( st [ - 1 ] , i + 1 ) if v and v [ - 1 ] [ 1 ] == i : v [ - 1 ] = b else : v . append ( b ) if len ( v ) >= 2 and v [ - 2 ] [ 1 ] == v [ - 1 ] [ 0 ] : v [ - 2 : ] = [ ( v [ - 2 ] [ 0 ] , v [ - 1 ] [ 1 ] ) ] st . pop ( ) else : st = [ ] for b in v : c = s . count ( ' [ ' , b [ 0 ] , b [ 1 ] ) if c > vc : vi , vj , vc = b [ 0 ] , b [ 1 ] , cprint ( vc ) print ( s [ vi : vj ] ) NEW_LINE"],"bleu":0.09372680100877358,"rouge_l":0.3189542483660131}
{"id":201,"predictions":["p = [ ] for i in range ( 3 ) : p . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE"],"references":["t = int ( input ( ) ) for i in range ( t ) : a , b , c = map ( int , input ( ) . split ( ) ) count = 0 if b > 0 and c > 1 : while b > 0 and c > 1 : b = b - 1 c = c - 2 count += 1 if a > 0 and b > 1 : while a > 0 and b > 1 : a = a - 1 b = b - 2 count += 1 print ( count * 3 )       NEW_LINE","t = int ( input ( ) )   for _ in range ( t ) : a , b , c = map ( int , input ( ) . split ( ) )   stones = 0 while ( c >= 2 and b >= 1 ) : stones += 3 c -= 2 b -= 1   while ( b >= 2 and a >= 1 ) : stones += 3 b -= 2 a -= 1   print ( stones ) NEW_LINE","t = int ( input ( ) ) for i in range ( t ) : temp = [ int ( x ) for x in input ( ) . split ( ) ] a = temp [ 0 ] b = temp [ 1 ] c = temp [ 2 ] result = 0 result += min ( b , c \/\/ 2 ) b -= result result += min ( a , b \/\/ 2 ) print ( result * 3 ) NEW_LINE","s = int ( input ( ) ) t = sfor tt in range ( t ) : s = input ( ) . split ( ) a = int ( s [ 0 ] ) b = int ( s [ 1 ] ) c = int ( s [ 2 ] ) ans = 0 while ( c ) : if ( b >= 1 and c >= 2 ) : ans += 3 else : break b -= 1 c -= 2 while ( a ) : if ( b >= 2 and a >= 1 ) : ans += 3 else : break b -= 2 a -= 1 print ( ans ) NEW_LINE","n = int ( input ( ) )   for i in range ( n ) : x = list ( map ( int , input ( ) . split ( ) ) ) a = x [ 0 ] b = x [ 1 ] c = x [ 2 ]   asd = min ( b , c \/\/ 2 ) ans = 0 if asd > 0 : ans = ans + ( 3 * asd ) b = b - asd   asd = min ( a , b \/\/ 2 ) if asd > 0 : ans = ans + ( 3 * asd ) print ( ans ) NEW_LINE"],"bleu":0.14585211300263073,"rouge_l":0.3511250654107797}
{"id":202,"predictions":["import sysinput = sys . stdin . readline   n = int ( input ( ) ) b = [ int ( x ) for x in input ( ) . split ( ) ]   d = [ 0 ] * ( n + 1 )   for i in range ( 1 , n ) : if b [ i - 1 ] != b [ i ] : d [ b [ i ] - b [ i - 1 ] ] += d [ i ]   print ( d [ n ] ) NEW_LINE"],"references":["f = lambda : map ( int , input ( ) . split ( ) ) n , m = f ( ) t = list ( f ( ) ) p = [ 1e9 ] + [ abs ( b - a ) for a , b in zip ( t , t [ 1 : ] ) ] + [ 1e9 ] L , R = [ 0 ] * n , [ 0 ] * nfor i in range ( 1 , n ) : j = n - i x , y = i - 1 , j + 1 a , b = p [ i ] , p [ j ] while a > p [ x ] : x = L [ x ] while b >= p [ y ] : y = R [ y ] L [ i ] , R [ j ] = x , yfor k in range ( m ) : l , r = f ( ) print ( sum ( ( i - max ( l - 1 , L [ i ] ) ) * ( min ( r , R [ i ] ) - i ) * p [ i ] for i in range ( l , r ) ) ) NEW_LINE","f = lambda : map ( int , input ( ) . split ( ) ) n , m = f ( ) t = list ( f ( ) ) p = [ 1e9 ] + [ abs ( b - a ) for a , b in zip ( t , t [ 1 : ] ) ] + [ 1e9 ] L , R = [ 0 ] * n , [ 0 ] * nfor i in range ( 1 , n ) : j = n - i x , y = i - 1 , j + 1 a , b = p [ i ] , p [ j ] while a > p [ x ] : x = L [ x ] while b >= p [ y ] : y = R [ y ] L [ i ] , R [ j ] = x , yfor k in range ( m ) : l , r = f ( ) print ( sum ( ( i - max ( l - 1 , L [ i ] ) ) * ( min ( r , R [ i ] ) - i ) * p [ i ] for i in range ( l , r ) ) ) NEW_LINE","f = lambda : map ( int , input ( ) . split ( ) ) n , m = f ( ) t = list ( f ( ) ) p = [ 1e9 ] + [ abs ( b - a ) for a , b in zip ( t , t [ 1 : ] ) ] + [ 1e9 ] L , R = [ 0 ] * n , [ 0 ] * nfor i in range ( 1 , n ) : j = n - i x , y = i - 1 , j + 1 a , b = p [ i ] , p [ j ] while a > p [ x ] : x = L [ x ] while b >= p [ y ] : y = R [ y ] L [ i ] , R [ j ] = x , yfor k in range ( m ) : l , r = f ( ) print ( sum ( ( i - max ( l - 1 , L [ i ] ) ) * ( min ( r , R [ i ] ) - i ) * p [ i ] for i in range ( l , r ) ) ) NEW_LINE","f = lambda : map ( int , input ( ) . split ( ) ) n , m = f ( ) t = list ( f ( ) ) p = [ 1e9 ] + [ abs ( b - a ) for a , b in zip ( t , t [ 1 : ] ) ] + [ 1e9 ] L , R = [ 0 ] * n , [ 0 ] * nfor i in range ( 1 , n ) : j = n - i x , y = i - 1 , j + 1 a , b = p [ i ] , p [ j ] while a > p [ x ] : x = L [ x ] while b >= p [ y ] : y = R [ y ] L [ i ] , R [ j ] = x , yfor k in range ( m ) : l , r = f ( ) print ( sum ( ( i - max ( l - 1 , L [ i ] ) ) * ( min ( r , R [ i ] ) - i ) * p [ i ] for i in range ( l , r ) ) ) NEW_LINE","f = lambda : map ( int , input ( ) . split ( ) ) n , m = f ( ) t = list ( f ( ) ) p = [ 1e9 ] + [ abs ( b - a ) for a , b in zip ( t , t [ 1 : ] ) ] + [ 1e9 ] L , R = [ 0 ] * n , [ 0 ] * nfor i in range ( 1 , n ) : j = n - i x , y = i - 1 , j + 1 a , b = p [ i ] , p [ j ] while a > p [ x ] : x = L [ x ] while b >= p [ y ] : y = R [ y ] L [ i ] , R [ j ] = x , yfor k in range ( m ) : l , r = f ( ) print ( sum ( ( i - max ( l - 1 , L [ i ] ) ) * ( min ( r , R [ i ] ) - i ) * p [ i ] for i in range ( l , r ) ) ) NEW_LINE"],"bleu":0.08941761078584942,"rouge_l":0.3321868730295213}
{"id":203,"predictions":["import sys , os , ioimport NEW_LINE math , bisect , operatorinf , mod = float ( ' inf ' ) , 10 ** 9 + 7 NEW_LINE"],"references":["cases = int ( input ( ) ) while cases : cases -= 1 x = int ( input ( ) ) arrx = list ( map ( int , input ( ) . split ( ) ) ) y = int ( input ( ) ) arry = list ( map ( int , input ( ) . split ( ) ) )   ans = sum ( 1 for i in arrx if i % 2 == 0 ) * sum ( 1 for i in arry if i % 2 == 0 ) + sum ( 1 for i in arrx if i % 2 != 0 ) * sum ( 1 for i in arry if i % 2 != 0 ) print ( ans ) NEW_LINE","t = int ( input ( ) ) for _ in range ( t ) : r = 0 pc = int ( input ( ) ) p = list ( map ( int , input ( ) . split ( ) ) ) pe = 0 po = 0 qc = int ( input ( ) ) q = list ( map ( int , input ( ) . split ( ) ) ) qe = 0 qo = 0 for i in p : if i % 2 == 0 : pe += 1 else : po += 1 for j in q : if j % 2 == 0 : qe += 1 else : qo += 1 print ( qe * pe + qo * po )   NEW_LINE","test = int ( input ( ) ) while test : n = int ( input ( ) ) p = list ( map ( int , input ( ) . split ( \" ▁ \" ) ) ) m = int ( input ( ) ) q = list ( map ( int , input ( ) . split ( \" ▁ \" ) ) ) even1 , even2 , odd1 , odd2 = 0 , 0 , 0 , 0 for i in range ( n ) : if p [ i ] % 2 == 0 : even1 += 1 else : odd1 += 1 for i in range ( m ) : if q [ i ] % 2 == 0 : even2 += 1 else : odd2 += 1 print ( even1 * even2 + odd1 * odd2 ) test -= 1 NEW_LINE","t = int ( input ( ) ) while t != 0 : n = int ( input ( ) ) p = [ int ( x ) for x in input ( ) . split ( ) ] m = int ( input ( ) ) q = [ int ( y ) for y in input ( ) . split ( ) ] p1 , p0 , q1 , q0 = 0 , 0 , 0 , 0 for ele in p : if ele % 2 : p1 += 1 else : p0 += 1 for e in q : if e % 2 : q1 += 1 else : q0 += 1   print ( p0 * q0 + p1 * q1 ) t -= 1 NEW_LINE"],"bleu":0.0017731654914457887,"rouge_l":0.10119442601194428}
{"id":204,"predictions":["from math import * n = int ( input ( ) ) ls = [ int ( x ) for x in input ( ) . split ( ) ] g = 0 for i in ls : g = gcd ( g , i ) x = max ( ls ) \/\/ gif ( x - n ) & 1 : print ( ' Alice ' ) else : print ( ' Bob ' ) NEW_LINE"],"references":["MAX_LEN = int ( 1e5 ) n = int ( input ( ) ) a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] m = int ( input ( ) ) b = list ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) curr , k , c , res = 0 , 0 , [ ] , [ ] for i in range ( n ) : t = a [ i ] last = curr if t [ 0 ] == 1 : curr += 1 if len ( c ) < MAX_LEN : c . append ( t [ 1 ] ) if k < m and b [ k ] == curr - 1 : res . append ( t [ 1 ] ) k += 1 else : curr += t [ 1 ] * t [ 2 ] while t [ 2 ] > 0 and len ( c ) < MAX_LEN : c . extend ( c [ : t [ 1 ] ] ) t [ 2 ] -= 1 while k < m and last <= b [ k ] < curr : res . append ( c [ ( b [ k ] - last ) % t [ 1 ] ] ) k += 1 print ( ' ▁ ' . join ( map ( str , res [ : m ] ) ) ) NEW_LINE","from bisect import bisect_leftdef fun ( ind , alr , ll , sll ) : if ind in alr : return alr [ ind ] k = bisect_left ( sll , ind ) md = ll [ k ] return fun ( ( ind - sll [ k ] ) % md , alr , ll , sll ) pos = { } m = int ( input ( ) ) l = 0 cp = [ ] cpl = [ ] known = [ ] for _ in range ( 0 , m ) : q = [ int ( i ) for i in input ( ) . split ( ) ] if q [ 0 ] == 1 : pos [ l ] = q [ 1 ] l += 1 else : cp . append ( q [ 1 ] ) l += q [ 1 ] * q [ 2 ] cpl . append ( l ) n = int ( input ( ) ) qq = [ int ( i ) - 1 for i in input ( ) . split ( ) ] ans = [ fun ( i , pos , cp , cpl ) for i in qq ] print ( * ans )         NEW_LINE","from bisect import bisect_leftdef fun ( ind , alr , ll , sll ) : if ind in alr : return alr [ ind ] k = bisect_left ( sll , ind ) md = ll [ k ] return fun ( ( ind - sll [ k ] ) % md , alr , ll , sll ) pos = { } m = int ( input ( ) ) l = 0 cp = [ ] cpl = [ ] for _ in range ( 0 , m ) : q = [ int ( i ) for i in input ( ) . split ( ) ] if q [ 0 ] == 1 : pos [ l ] = q [ 1 ] l += 1 else : cp . append ( q [ 1 ] ) l += q [ 1 ] * q [ 2 ] cpl . append ( l ) n = int ( input ( ) ) qq = [ int ( i ) - 1 for i in input ( ) . split ( ) ] ans = [ fun ( i , pos , cp , cpl ) for i in qq ] print ( * ans )         NEW_LINE","m = int ( input ( ) ) a , b , start , end = [ ] , [ ] , 0 , 0   idx = 0   for _ in range ( m ) : line = list ( map ( int , input ( ) . split ( ) ) ) if line [ 0 ] == 1 : x = line [ 1 ] start = end + 1 end = end + 1 if len ( a ) <= 100000 : a . append ( x ) b . append ( ( start , end , x ) ) else : l , c = line [ 1 ] , line [ 2 ] start = end + 1 end = end + l * c if len ( a ) <= 100000 : for _ in range ( c ) : a += a [ : l ] if len ( a ) > 100000 : break b . append ( ( start , end , l , c ) )     input ( ) NEW_LINE","MAX_LEN = int ( 1e5 ) n = int ( input ( ) ) a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] m = int ( input ( ) ) b = list ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) curr , k , c , res = 0 , 0 , [ ] , [ ] for i in range ( n ) : t = a [ i ] last = curr if t [ 0 ] == 1 : curr += 1 if len ( c ) < MAX_LEN : c . append ( t [ 1 ] ) if k < m and b [ k ] == curr - 1 : res . append ( t [ 1 ] ) k += 1 else : curr += t [ 1 ] * t [ 2 ] while t [ 2 ] > 0 and len ( c ) < MAX_LEN : c . extend ( c [ : t [ 1 ] ] ) t [ 2 ] -= 1 while k < m and last <= b [ k ] < curr : res . append ( c [ ( b [ k ] - last ) % t [ 1 ] ] ) k += 1 print ( ' ▁ ' . join ( map ( str , res [ : m ] ) ) ) NEW_LINE"],"bleu":0.09730565603898877,"rouge_l":0.27116239477915444}
{"id":205,"predictions":["n = int ( input ( ) ) p = list ( map ( int , input ( ) . split ( ) ) ) ans = [ ] for start in range ( n ) : holes = [ 0 for i in range ( n ) ] holes [ start ] = 1 cur = start while max ( holes ) != 2 : holes [ p [ cur ] - 1 ] += 1 cur = p [ cur ] - 1 ans . append ( cur + 1 )   print ( ' ▁ ' . join ( list ( map ( str , ans ) ) ) ) NEW_LINE"],"references":["def get_key ( my_dict , val ) : for key , value in my_dict . items ( ) : if val == value : return key return - 1   n = int ( input ( ) ) arr = { } for _ in range ( n ) : a , b = input ( ) . split ( ) x = get_key ( arr , a ) if x == - 1 : arr [ a ] = b   else : arr [ x ] = b   print ( len ( arr ) ) for i , j in arr . items ( ) : print ( i , j ) NEW_LINE","nr_user = int ( input ( ) )   handles = list ( ) flag_add = Truefor i in range ( nr_user ) : new_handle = input ( ) . split ( ) for handle in handles : if ( new_handle [ 0 ] == handle [ 1 ] ) : handle [ 1 ] = new_handle [ 1 ] flag_add = False   if ( flag_add ) : handles . append ( new_handle ) flag_add = True     print ( len ( handles ) ) for handle in handles : print ( * handle ) NEW_LINE","n = int ( input ( ) ) old_names = [ ] new_names = [ ] records = { } count = 0 for i in range ( n ) : name1 , name2 = input ( ) . split ( ) old_names . append ( name1 ) new_names . append ( name2 )   for i in range ( n ) : if old_names [ i ] not in records : records [ new_names [ i ] ] = old_names [ i ] elif old_names [ i ] in records : records [ new_names [ i ] ] = records [ old_names [ i ] ] del records [ old_names [ i ] ] print ( len ( records ) ) for key in records : root_names = records [ key ] print ( root_names + \" ▁ \" + key )     NEW_LINE"],"bleu":0.306895626785483,"rouge_l":0.44829652114869994}
{"id":206,"predictions":["n , m = map ( int , input ( ) . split ( ) )   n = min ( n , m ) if n % 2 == 0 : print ( ' Malvika ' ) else : print ( ' Akshat ' ) NEW_LINE"],"references":["a , b = map ( int , input ( ) . split ( ) ) print ( ' VVlaaldeirka ' [ ( ( 4 * b + 1 ) ** .5 - 1 ) \/\/ 2 < a ** .5 \/\/ 1 : : 2 ] ) NEW_LINE","a , b = map ( int , input ( ) . split ( ) ) s = int ( a ** 0.5 ) if ( s * ( s + 1 ) > b ) : print ( \" Valera \" ) else : print ( \" Vladik \" ) NEW_LINE","a , b = map ( int , input ( ) . split ( ) ) i = 0 d = 0 while a >= 0 and b >= 0 : if i % 2 == 0 and i > 0 : if b - d >= 0 : b -= d i += 1 d += 1 else : print ( ' Valera ' ) break elif a - d >= 0 : a -= d i += 1 d += 1 else : print ( ' Vladik ' ) break                   NEW_LINE","import math vladik , valera = map ( int , input ( ) . split ( ) )   turn = 1 vladik_gives = 1 valera_gives = 2 zero = [ ]   while ( vladik > 0 ) or ( valera > 0 ) : if ( vladik < 0 ) or ( valera < 0 ) : break   if turn % 2 == 0 : valera -= valera_gives valera_gives += 2 else : vladik -= vladik_gives vladik_gives += 2 if valera == 0 : zero . append ( \" Valera \" ) if vladik == 0 : zero . append ( \" Vladik \" )           turn += 1         if vladik == 0 and valera == 0 : print ( zero [ 0 ] ) elif vladik <= valera : print ( \" Vladik \" ) else : print ( \" Valera \" )       \"\"\" def ▁ steps ( candy ) : ▁ ▁ ▁ ▁ if ▁ candy ▁ % ▁ 2 ▁ = = ▁ 0 : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ return ▁ ( -0.5 ▁ + ▁ ( math . sqrt ( 1 ▁ + ▁ ( 4 ▁ * candy ) ) ▁ * ▁ 0.5 ) ) ▁ ▁ ▁ ▁ return ▁ ( math . sqrt ( candy ) )  vladik _ steps ▁ = ▁ steps ( vladik ) ▁ valera _ steps ▁ = ▁ steps ( valera ) ▁  print ( vladik _ steps , ▁ valera _ steps ) if ▁ vladik ▁ = = ▁ valera ▁ : ▁ ▁ ▁ ▁ if ▁ vladik ▁ % ▁ 2 ▁ ! = ▁ 0 : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( \" Valera \" ) ▁ ▁ ▁ ▁ else : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( \" Vladik \" ) elif ▁ int ( vladik _ steps ) ▁ < ▁ int ( valera _ steps ) : ▁ ▁ ▁ ▁ print ( \" Vladik \" ) elif ▁ int ( vladik _ steps ) ▁ > ▁ int ( valera _ steps ) : ▁ ▁ ▁ ▁ print ( \" Valera \" ) elif ▁ int ( vladik _ steps ) ▁ = = ▁ int ( valera _ steps ) : ▁ ▁ ▁ ▁ if ▁ vladik ▁ - ▁ ( vladik _ steps ▁ * * ▁ 2 ) ▁ = = ▁ 0 : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ valera ▁ - ▁ ( ( valera _ steps ) ▁ * ▁ ( valera _ steps ▁ + ▁ 1 ) ) ▁ > = ▁ ( valera _ steps ▁ + ▁ 2 ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ▁ ( \" Vladik \" )   ▁ ▁ ▁ ▁ print ( vladik ▁ - ▁ ( vladik _ steps ▁ * * ▁ 2 ) ▁ - ▁ vladik _ steps ▁ - ▁ 2 ) ▁ ▁ ▁ ▁ if ▁ vladik ▁ - ▁ ( vladik _ steps ▁ * * ▁ 2 ) ▁ - ▁ vladik _ steps ▁ - ▁ 2 ▁ < ▁ 0 : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( \" Vladik \" ) ▁ ▁ ▁ ▁ else : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( \" Valera \" )   \"\"\" NEW_LINE","a , b = map ( int , input ( ) . split ( ) ) c = 0 while ( True ) : c += 1 a = a - c if ( a < 0 ) : print ( \" Vladik \" ) exit ( ) c += 1 b = b - c if ( b < 0 ) : print ( \" Valera \" ) exit ( ) NEW_LINE"],"bleu":0.5365815009124687,"rouge_l":0.6014832000662882}
{"id":207,"predictions":["s = input ( ) n = len ( s ) base = 0 for i in range ( 0 , n ) : base = base + 2 ** inews = \" \" for c in s : if c == '4' : news = news + '0' else : news = news + '1' news = '0b ' + newsprint ( int ( news , 2 ) + base ) NEW_LINE"],"references":["def main ( ) : n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) a . sort ( ) c = [ ] for i in range ( n - 1 ) : c += [ a [ i + 1 ] - a [ i ] ] print ( min ( c ) , c . count ( min ( c ) ) )   if __name__ == ' _ _ main _ _ ' : main ( ) NEW_LINE","num = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) arr . sort ( ) lst = [ ] for i in range ( num - 1 ) : lst . append ( abs ( arr [ i + 1 ] - arr [ i ] ) )   print ( min ( lst ) , lst . count ( min ( lst ) ) )     NEW_LINE","import mathn = int ( input ( ) ) li = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) [ : n ] li . sort ( ) mindiff = li [ 1 ] - li [ 0 ] for i in range ( 2 , n ) : diff = li [ i ] - li [ i - 1 ] if ( diff < mindiff ) : mindiff = diffprint ( mindiff , end = \" ▁ \" ) count = 0 for i in range ( 1 , n ) : if ( li [ i ] - li [ i - 1 ] == mindiff ) : count += 1 print ( count ) NEW_LINE","n = int ( input ( ) ) A = list ( map ( int , input ( ) . split ( ) ) )   A . sort ( )   dist = float ( \" inf \" ) cnt = 0   for i in range ( n - 1 ) : tmp = A [ i + 1 ] - A [ i ] if tmp < dist : dist = tmp cnt = 1 elif tmp == dist : cnt += 1 print ( dist , cnt ) NEW_LINE"],"bleu":0.17977353241863656,"rouge_l":0.333568530605045}
{"id":208,"predictions":["a , b , c = map ( int , input ( ) . split ( ) ) print ( 2 * min ( a , b ) + 2 * c + ( 0 if a == b else 1 ) ) NEW_LINE"],"references":["n , L = map ( int , input ( ) . split ( ) ) kefa = list ( map ( int , input ( ) . split ( ) ) ) sasha = list ( map ( int , input ( ) . split ( ) ) ) def check ( kefa , sasha ) : X = [ ( kefa [ i ] - sasha [ i ] + L ) % L for i in range ( n ) ] if len ( set ( X ) ) == 1 : return True else : return Falsedef rotate ( arr , n ) : x = arr [ n - 1 ] for i in range ( n - 1 , 0 , - 1 ) : arr [ i ] = arr [ i - 1 ] arr [ 0 ] = x return arrok = Falsefor l in range ( n + 1 ) : sasha = rotate ( sasha , n ) if check ( kefa , sasha ) == True : ok = Trueif ok == True : print ( \" Yes \" ) else : print ( \" No \" ) NEW_LINE","n , l = [ int ( x ) for x in input ( ) . split ( ' ▁ ' ) ] k = [ int ( x ) for x in input ( ) . split ( ' ▁ ' ) ] s = [ int ( x ) for x in input ( ) . split ( ' ▁ ' ) ]   kd = [ ( k [ i % n ] - k [ i - 1 ] ) % l for i in range ( 1 , n + 1 ) ] sd = [ ( s [ i % n ] - s [ i - 1 ] ) % l for i in range ( 1 , n + 1 ) ]   ans = Falsefor i in range ( n ) : if kd == sd [ i : ] + sd [ : i ] : ans = True breakif ans : print ( ' YES ' ) else : print ( ' NO ' ) NEW_LINE","n , L = map ( int , input ( ) . split ( ) ) kefa = list ( map ( int , input ( ) . split ( ) ) ) sasha = list ( map ( int , input ( ) . split ( ) ) ) def check ( kefa , sasha ) : X = [ ( kefa [ i ] - sasha [ i ] + L ) % L for i in range ( n ) ] if len ( set ( X ) ) == 1 : return True else : return Falsedef rotate ( arr , n ) : x = arr [ n - 1 ] for i in range ( n - 1 , 0 , - 1 ) : arr [ i ] = arr [ i - 1 ] arr [ 0 ] = x return arrok = Falsefor l in range ( n + 1 ) : sasha = rotate ( sasha , n ) if check ( kefa , sasha ) == True : ok = Trueif ok == True : print ( \" Yes \" ) else : print ( \" No \" ) NEW_LINE","import math   if 1 : n , l = list ( map ( int , input ( ) . split ( ) ) ) l1 = list ( map ( int , input ( ) . split ( ) ) ) l2 = list ( map ( int , input ( ) . split ( ) ) ) diff1 = [ ] for i in range ( n - 1 ) : diff1 . append ( abs ( l1 [ i + 1 ] - l1 [ i ] ) ) diff1 . append ( l - l1 [ - 1 ] + l1 [ 0 ] ) diff2 = [ ] for j in range ( n - 1 ) : diff2 . append ( abs ( l2 [ j + 1 ] - l2 [ j ] ) ) diff2 . append ( l - l2 [ - 1 ] + l2 [ 0 ] ) x = ' ▁ ' . join ( map ( str , diff1 ) ) in ' ▁ ' . join ( map ( str , diff2 * 2 ) ) if x : print ( ' YES ' ) else : print ( ' NO ' ) NEW_LINE","n , l = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) aa = [ 0 ] * lbb = [ 0 ] * lfor i in range ( n ) : aa [ a [ i ] - 1 ] += 1 bb [ b [ i ] - 1 ] += 1 for i in range ( l ) : if aa == bb : print ( \" YES \" ) exit ( 0 ) bb = [ bb [ - 1 ] ] + bb [ : - 1 ] print ( \" NO \" ) NEW_LINE"],"bleu":0.04737738522323413,"rouge_l":0.27319257837492006}
{"id":209,"predictions":["n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l . sort ( ) i = 1 while i in l : i += 1   print ( i ) NEW_LINE"],"references":["n = 1000000 a = [ 1 ] * ns = set ( ) for i in range ( 2 , n ) : if a [ i ] : s . add ( i * i ) for j in range ( i * i , n , i ) : a [ j ] = 0 input ( ) for x in map ( int , input ( ) . split ( ) ) : print ( [ \" NO \" , \" YES \" ] [ x in s ] ) NEW_LINE","import math     _ = int ( input ( ) )   n = 1_000_000 d = { 1 : True } for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : if i not in d : for m in range ( i * 2 , n + 1 , i ) : d [ m ] = True     for n in map ( int , input ( ) . split ( ) ) : sq = math . sqrt ( n ) if sq == int ( sq ) : if int ( sq ) not in d : print ( \" YES \" ) else : print ( \" NO \" ) else : print ( \" NO \" ) NEW_LINE","def isprime ( n ) : if n == 1 : return False if n < 4 : return True if n % 2 == 0 or n % 3 == 0 : return False   for i in range ( 3 , int ( n ** 0.5 ) + 1 , 2 ) : if n % i == 0 : return False return True     num = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) )   for i in arr : root = int ( i ** 0.5 ) if root * root == i and isprime ( root ) : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE","import math   inp = lambda : map ( int , input ( ) . split ( ) ) MAX_ELEM = int ( 1e6 + 5 )   n = int ( input ( ) ) a = list ( inp ( ) )   def sieve ( ) : prime = [ True ] * MAX_ELEM i = 2 while i * i < MAX_ELEM : if prime [ i ] : j = 2 while i * j < MAX_ELEM : prime [ i * j ] = False j += 1 i += 1 prime [ 0 ] , prime [ 1 ] = False , False return prime     prime = sieve ( ) for i in range ( n ) : sq = int ( math . sqrt ( a [ i ] ) ) if sq * sq == a [ i ] and prime [ sq ] : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.21027682662029423,"rouge_l":0.35154702301624463}
{"id":210,"predictions":["import sys , os , ioimport math , bisect , operatorinf , mod = float ( ' inf ' ) , 10 ** 9 + 7 NEW_LINE"],"references":["n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) neg , neg1 = 0 , [ ] pos , pos1 = 0 , [ ] for i in range ( n ) : if l [ i ] >= 0 : l [ i ] = - l [ i ] - 1 if n % 2 == 0 : print ( * l ) else : l1 = sorted ( l ) l [ l . index ( l1 [ 0 ] ) ] = - l1 [ 0 ] - 1 print ( * l ) NEW_LINE","from sys import stdin , stdoutfrom math import floor , gcd , fabs , factorial , fmod , sqrt , inf , logfrom collections import defaultdict as dd , dequefrom heapq import merge , heapify , heappop , heappush , nsmallestfrom bisect import bisect_left as bl , bisect_right as br , bisect mod = pow ( 10 , 9 ) + 7 mod2 = 998244353 def inp ( ) : return stdin . readline ( ) . strip ( ) def iinp ( ) : return int ( inp ( ) ) def out ( var , end = \" \\n \" ) : stdout . write ( str ( var ) + \" \\n \" ) def outa ( * var , end = \" \\n \" ) : stdout . write ( ' ▁ ' . join ( map ( str , var ) ) + end ) def lmp ( ) : return list ( mp ( ) ) def mp ( ) : return map ( int , inp ( ) . split ( ) ) def smp ( ) : return map ( str , inp ( ) . split ( ) ) def l1d ( n , val = 0 ) : return [ val for i in range ( n ) ] def l2d ( n , m , val = 0 ) : return [ l1d ( m , val ) for j in range ( n ) ] def remadd ( x , y ) : return 1 if x % y else 0 def ceil ( a , b ) : return ( a + b - 1 ) \/\/ b def isprime ( x ) : if x <= 1 : return False if x in ( 2 , 3 ) : return True if x % 2 == 0 : return False for i in range ( 3 , int ( sqrt ( x ) ) + 1 , 2 ) : if x % i == 0 : return False return True n = iinp ( ) arr = lmp ( ) arr = [ - i - 1 if i < 0 else i for i in arr ] if n % 2 == 0 : print ( * [ - i - 1 for i in arr ] ) else : ind = arr . index ( max ( arr ) ) for i in range ( n ) : if i == ind : continue arr [ i ] = - arr [ i ] - 1 print ( * arr ) NEW_LINE","import sysn = int ( input ( ) ) a = list ( ) for i in input ( ) . split ( ) : if not int ( i ) : a . append ( - 1 ) else : a . append ( int ( i ) ) if n == 1 : print ( max ( a [ 0 ] , - a [ 0 ] - 1 ) ) ; sys . exit ( ) if n & 1 : f = False mx , mn = max ( a ) , min ( a ) k = a . count ( mx ) if abs ( mn ) > abs ( mx ) or mx < 0 : mx = mn ; k = 2 NEW_LINE","def solve ( n , arr ) : zero = 0 neg = 0 for i in range ( n ) : if arr [ i ] >= 0 : arr [ i ] = - 1 * arr [ i ] - 1 if n % 2 != 0 : index = 0 NEW_LINE"],"bleu":0.04589142261482013,"rouge_l":0.13920981315076308}
{"id":211,"predictions":["n , a , b = map ( int , input ( ) . split ( ) ) lis = list ( map ( int , input ( ) . split ( ) ) ) for i in lis : x = ( i * a ) % b print ( int ( x \/ a ) , end = ' ▁ ' ) NEW_LINE"],"references":["    n , b = map ( int , input ( ) . split ( ) )   t = list ( map ( int , input ( ) . split ( ) ) )   ans = 0   ma = 999999999 mi = 0 for i in range ( n ) :   if t [ i ] < ma : ma = t [ i ] elif t [ i ] > ma : temp = b \/\/ ma   rest = b - ( b \/\/ ma ) * ma rest += ( temp ) * t [ i ]   ans = max ( rest , ans )   print ( max ( ans , b ) )                             NEW_LINE","n , b = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) print ( max ( b \/\/ a [ i ] * a [ j ] + b % a [ i ] for j in range ( n ) for i in range ( j + 1 ) ) ) NEW_LINE","n , b = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) )   NEW_LINE","n , amount = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) maxd = 0 x = 0 y = 0 profit = 0 b = [ 0 ] * nb [ n - 1 ] = - 1 maxi = 0 for i in range ( n - 2 , - 1 , - 1 ) : maxi = max ( maxi , a [ i + 1 ] ) b [ i ] = maxifor i in range ( n ) : if b [ i ] > 0 : profit = max ( profit , ( amount \/\/ a [ i ] ) * ( b [ i ] - a [ i ] ) ) print ( amount + profit ) NEW_LINE"],"bleu":0.5680174351697798,"rouge_l":0.8298427207958059}
{"id":212,"predictions":["import sys , mathfrom collections import deque , defaultdictimport operator as opfrom functools import reducefrom itertools import permutations   NEW_LINE"],"references":["import osimport sysfrom io import BytesIO , IOBase   sys . setrecursionlimit ( 95000 )     def main ( ) : pass     NEW_LINE","from sys import stdin , stdoutfrom math import floor , gcd , fabs , factorial , fmod , sqrt , inf , logfrom collections import defaultdict as dd , dequefrom heapq import merge , heapify , heappop , heappush , nsmallestfrom bisect import bisect_left as bl , bisect_right as br , bisect mod = pow ( 10 , 9 ) + 7 mod2 = 998244353 def inp ( ) : return stdin . readline ( ) . strip ( ) def iinp ( ) : return int ( inp ( ) ) def out ( var , end = \" \\n \" ) : stdout . write ( str ( var ) + \" \\n \" ) def outa ( * var , end = \" \\n \" ) : stdout . write ( ' ▁ ' . join ( map ( str , var ) ) + end ) def lmp ( ) : return list ( mp ( ) ) def mp ( ) : return map ( int , inp ( ) . split ( ) ) def smp ( ) : return map ( str , inp ( ) . split ( ) ) def l1d ( n , val = 0 ) : return [ val for i in range ( n ) ] def l2d ( n , m , val = 0 ) : return [ l1d ( m , val ) for j in range ( n ) ] def remadd ( x , y ) : return 1 if x % y else 0 def ceil ( a , b ) : return ( a + b - 1 ) \/\/ b def isprime ( x ) : if x <= 1 : return False if x in ( 2 , 3 ) : return True if x % 2 == 0 : return False for i in range ( 3 , int ( sqrt ( x ) ) + 1 , 2 ) : if x % i == 0 : return False return True s = inp ( ) a1 , a2 = [ ] , [ ] for i in range ( len ( s ) ) : if s [ i ] == ' l ' : a1 . append ( i + 1 ) else : a2 . append ( i + 1 ) print ( * a2 , sep = ' \\n ' ) print ( * a1 [ : : - 1 ] , sep = ' \\n ' ) NEW_LINE","class LN : data = None left = None right = None   def __init__ ( self , data , left , right ) : self . data = data self . left = left self . right = right   inst = input ( )   root = LN ( 1 , None , None ) ptr = rooti = 2   for j in range ( len ( inst ) - 1 ) : if inst [ j ] == ' l ' : ptr . left = LN ( i , ptr . left , ptr ) if ptr . left . left : ptr . left . left . right = ptr . left ptr = ptr . left if root . left : root = root . left else : ptr . right = LN ( i , ptr , ptr . right ) if ptr . right . right : ptr . right . right . left = ptr . right ptr = ptr . right   i += 1   trav = rootprint ( root . data )   while trav . right : trav = trav . right print ( trav . data ) NEW_LINE","import sysdef get_ints ( ) : return list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) )   strs = input ( ) leftarr = [ ] rightarr = [ ]   for i , j in enumerate ( strs ) : if j == \" l \" : leftarr . append ( i + 1 ) else : rightarr . append ( i + 1 )   for i in rightarr : print ( i ) leftarr = leftarr [ : : - 1 ] for i in leftarr : print ( i ) NEW_LINE"],"bleu":0.1055636032595895,"rouge_l":0.2442931517821386}
{"id":213,"predictions":["ll = lambda : map ( int , input ( ) . split ( ) ) t = lambda : int ( input ( ) ) ss = lambda : input ( ) lx = lambda x : map ( int , input ( ) . split ( x ) ) NEW_LINE"],"references":["x , t , a , b , da , db = [ int ( i ) for i in input ( ) . split ( ) ]   if x == 0 : print ( \" YES \" ) exit ( 0 )   for i in range ( t ) : for j in range ( t ) : if ( a - i * da + b - j * db == x ) or ( a - i * da == x ) or ( b - j * db == x ) : print ( \" YES \" ) exit ( 0 )   print ( \" NO \" ) NEW_LINE","def STR ( ) : return list ( input ( ) ) def INT ( ) : return int ( input ( ) ) def MAP ( ) : return map ( int , input ( ) . split ( ) ) def MAP2 ( ) : return map ( float , input ( ) . split ( ) ) def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) def STRING ( ) : return input ( ) import stringimport sysfrom heapq import heappop , heappushfrom bisect import * from collections import deque , Counterfrom math import * from itertools import permutations , accumulatedx = [ - 1 , 1 , 0 , 0 ] dy = [ 0 , 0 , 1 , - 1 ] NEW_LINE","def STR ( ) : return list ( input ( ) ) def INT ( ) : return int ( input ( ) ) def MAP ( ) : return map ( int , input ( ) . split ( ) ) def MAP2 ( ) : return map ( float , input ( ) . split ( ) ) def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) def STRING ( ) : return input ( ) import stringimport sysfrom heapq import heappop , heappushfrom bisect import * from collections import deque , Counterfrom math import * from itertools import permutations , accumulatedx = [ - 1 , 1 , 0 , 0 ] dy = [ 0 , 0 , 1 , - 1 ] NEW_LINE","x , t , a , b , da , db = map ( int , input ( ) . split ( ) ) A = [ 0 ] + [ a - i * da for i in range ( t ) ] B = [ 0 ] + [ b - i * db for i in range ( t ) ] flag = 0 for i in A : if x - i in B : print ( \" YES \" ) flag = 1 breakif ( flag == 0 ) : print ( \" NO \" ) NEW_LINE","list1 = [ ] str1 = input ( ) list2 = str1 . split ( \" ▁ \" ) list2_length = len ( list2 ) i = 0 while i <= list2_length - 1 : list1 . append ( int ( list2 . pop ( ) ) ) i += 1 list1 . reverse ( ) x = list1 [ 0 ] t = list1 [ 1 ] a = list1 [ 2 ] b = list1 [ 3 ] da = list1 [ 4 ] db = list1 [ 5 ] pan = 0 for n in range ( 0 , t ) : for m in range ( 0 , t ) : if x == 0 or m * da == a - x or m * db == b - x or n * da + m * db == a + b - x : print ( \" YES \" ) pan = 1 break if pan == 1 : breakif pan == 0 : print ( \" NO \" ) NEW_LINE"],"bleu":0.21693646341317524,"rouge_l":0.36247877758913416}
{"id":214,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) a . sort ( ) if a [ n - 1 ] + a [ n - 2 ] > a [ n - 1 ] : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"references":["from itertools import combinations   def solve ( ) : n = int ( input ( ) ) ls = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) for x , y , z in zip ( ls , ls [ 1 : ] , ls [ 2 : ] ) : if x > z - y and x <= y + z : print ( ' YES ' ) return print ( ' NO ' )   if __name__ == ' _ _ main _ _ ' : solve ( ) NEW_LINE","n = int ( input ( ) ) a = sorted ( [ int ( x ) for x in input ( ) . split ( ) ] ) for i in range ( 1 , n - 1 ) : if ( a [ i - 1 ] + a [ i ] > a [ i + 1 ] ) : print ( \" YES \" ) exit ( ) print ( \" NO \" ) NEW_LINE","def ok ( a , b , c ) : return ( a + b > c ) and ( a + c > b ) and ( b + c > a )   n = int ( input ( ) ) a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) ye = 0 for i in range ( n - 2 ) : ye |= ok ( a [ i ] , a [ i + 1 ] , a [ i + 2 ] ) if ye : print ( \" YES \" ) else : print ( \" NO \" )   ''' * ▁ So ▁ I ▁ drown ▁ it ▁ out ▁ * ▁ Like ▁ I ▁ always ▁ do * ▁ Dancing ▁ through ▁ our ▁ house * ▁ With ▁ the ▁ ghost ▁ of ▁ you ''' NEW_LINE","if __name__ == \" _ _ main _ _ \" : n = int ( input ( ) ) segments = list ( map ( int , input ( ) . split ( ) ) ) segments . sort ( )   i , j , k = 0 , 1 , n - 1 flag = False for i in range ( 1 , n - 1 ) : if segments [ i - 1 ] + segments [ i ] > segments [ i + 1 ] : flag = True break   if flag : print ( ' YES ' ) else : print ( ' NO ' ) NEW_LINE"],"bleu":0.6619532927643325,"rouge_l":0.6933689935837265}
{"id":215,"predictions":["s = input ( ) . split ( s [ 0 ] ) NEW_LINE"],"references":["def solution ( s ) : s = sorted ( s , reverse = True ) n = len ( s ) ans = s [ 0 ] for i in range ( 1 , n ) : if ( s [ i - 1 ] == s [ i ] ) : ans += ( s [ i ] ) else : return ans return ans   s = input ( ) print ( solution ( s ) ) NEW_LINE","s = str ( input ( ) ) l = [ ] for i in s : if i not in l : l . append ( i ) l . sort ( ) char = l [ len ( l ) - 1 ] h = s . count ( char ) string = \" \" for i in range ( h ) : string = string + charprint ( string ) NEW_LINE","a = input ( ) c = max ( a ) print ( c * a . count ( c ) ) NEW_LINE","def palindromic_subseq ( word ) : largest_char = sorted ( word ) [ - 1 ] return largest_char * ( word . count ( largest_char ) )   word = input ( ) print ( palindromic_subseq ( word ) ) NEW_LINE","st = input ( ) maxChar = ' a ' for char in st : if maxChar < char : maxChar = char   print ( maxChar * st . count ( maxChar ) ) NEW_LINE"],"bleu":0.31669733220513235,"rouge_l":0.45078938528720186}
{"id":216,"predictions":["a , b = map ( int , input ( ) . split ( ) ) print ( min ( a , b ) , abs ( a - b ) ) NEW_LINE"],"references":["n = int ( input ( ) ) if n % 2 == 0 : print ( 4 , n - 4 ) else : print ( 9 , n - 9 ) NEW_LINE","n = int ( input ( ) ) if ( n % 2 == 0 ) : print ( 4 , n - 4 ) else : print ( 9 , n - 9 ) NEW_LINE","def isPrime ( n ) : if n % 2 == 0 : return n == 2 d = 3 while d * d <= n and n % d != 0 : d += 2 return d * d > n   n = int ( input ( ) ) a = 4 b = n - awhile isPrime ( b ) or isPrime ( a ) : a += 1 b = n - aprint ( a , b ) NEW_LINE","n = int ( input ( ) ) for i in range ( 4 , n - 3 ) : if i % 2 == 0 and ( ( n - i ) % 3 == 0 or ( n - i % 2 == 0 ) ) : a = i b = n - i breakprint ( a , b ) NEW_LINE","n = int ( input ( ) )   if n % 2 == 0 : a , b = 8 , n - 8 else : a , b = 9 , n - 9   print ( a , b )   NEW_LINE"],"bleu":0.3297087088161047,"rouge_l":0.44214913472864015}
{"id":217,"predictions":["import sys , os , ioimport math , bisect , operatorinf , mod = float ( ' inf ' ) , 10 ** 9 + 7 NEW_LINE"],"references":["raw = input ( ) R , C = ( int ( token ) for token in raw . split ( ' ▁ ' ) ) mat = list ( ) for i in range ( R ) : row = input ( ) mat . append ( row )   count = 0 for i in range ( 1 , R ) : for j in range ( 1 , C ) : sq = [ mat [ i - 1 ] [ j - 1 ] , mat [ i - 1 ] [ j ] , mat [ i ] [ j - 1 ] , mat [ i ] [ j ] ] sq . sort ( ) if ' ' . join ( sq ) == ' acef ' : count += 1 print ( count )   NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) s = list ( ) a = [ ' f ' , ' a ' , ' c ' , ' e ' ] result = 0 for i in range ( n ) : s . append ( input ( ) ) for i in range ( n - 1 ) : for j in range ( m - 1 ) : if s [ i ] [ j ] in a : a . remove ( s [ i ] [ j ] ) if s [ i ] [ j + 1 ] in a : a . remove ( s [ i ] [ j + 1 ] ) if s [ i + 1 ] [ j ] in a : a . remove ( s [ i + 1 ] [ j ] ) if s [ i + 1 ] [ j + 1 ] in a : result += 1 a = [ ' f ' , ' a ' , ' c ' , ' e ' ] else : a = [ ' f ' , ' a ' , ' c ' , ' e ' ] else : a = [ ' f ' , ' a ' , ' c ' , ' e ' ] else : a = [ ' f ' , ' a ' , ' c ' , ' e ' ] else : a = [ ' f ' , ' a ' , ' c ' , ' e ' ] print ( result ) NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) l = [ ] p = 0 for i in range ( n ) : lprime = list ( input ( ) ) l . append ( lprime )   for i in range ( 0 , n - 1 ) : for j in range ( 0 , m - 1 ) : u = l [ i ] [ j ] + l [ i ] [ j + 1 ] + l [ i + 1 ] [ j ] + l [ i + 1 ] [ j + 1 ] if \" f \" in u and \" a \" in u and \" c \" in u and \" e \" in u : p += 1   print ( p )   NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) alist = [ ] for i in range ( n ) : word = str ( input ( ) ) blist = [ ] for i in range ( len ( word ) ) : blist . append ( word [ i ] ) alist . append ( blist )   count = 0 if m == 1 or n == 1 : print ( \"0\" ) else : for i in range ( 1 , n ) : for j in range ( 1 , m ) : clist = [ ] clist . append ( alist [ i - 1 ] [ j - 1 ] ) clist . append ( alist [ i ] [ j ] ) clist . append ( alist [ i ] [ j - 1 ] ) clist . append ( alist [ i - 1 ] [ j ] ) if \" f \" in clist and \" a \" in clist and \" c \" in clist and \" e \" in clist : count = count + 1 else : continue print ( count ) NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) a = [ ] ans = 0 for i in range ( n ) : a . append ( input ( ) ) for i in range ( 1 , n ) : for j in range ( 1 , m ) : c = [ a [ i ] [ j ] , a [ i - 1 ] [ j ] , a [ i - 1 ] [ j - 1 ] , a [ i ] [ j - 1 ] ] if ' f ' in c and ' a ' in c and ' c ' in c and ' e ' in c : ans += 1 print ( ans ) NEW_LINE"],"bleu":0.001761065896570191,"rouge_l":0.1052152914981027}
{"id":218,"predictions":["t = int ( input ( ) ) for _ in range ( t ) : n , k = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE"],"references":["import sys   def answer ( n , k , a ) : peaks = [ False ] * n NEW_LINE","t = int ( input ( ) ) for l in range ( 0 , t ) : n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) bin = [ 0 ] * n for i in range ( 1 , n - 1 ) : if ( a [ i ] > a [ i - 1 ] and a [ i ] > a [ i + 1 ] ) : bin [ i ] = 1 l = 0 r = l + k peaks = 0 m , ml = 0 , 0 for i in range ( 0 , r ) : if ( bin [ i ] == 1 ) : peaks += 1 if ( i == r - 1 and bin [ i ] == 1 ) : m = peaks - 1 else : m = peaks for l in range ( 1 , n - k + 1 ) : if ( bin [ l ] == 1 ) : peaks -= 1 if ( m < peaks ) : m = peaks ml = l if ( bin [ r ] == 1 ) : peaks += 1 r += 1 print ( m + 1 , ml + 1 ) NEW_LINE","t = int ( input ( ) ) for h in range ( t ) : n , k = map ( int , input ( ) . split ( ) ) x = list ( map ( int , input ( ) . split ( ) ) ) k -= 2 j = n - 1 i = j - k s = 1 for l in range ( i , j ) : if x [ l ] > x [ l - 1 ] and x [ l ] > x [ l + 1 ] : s += 1 m = s ind = i - 1 j -= 1 i -= 1 while i > 0 : if x [ i ] > x [ i - 1 ] and x [ i ] > x [ i + 1 ] : s += 1 if x [ j ] > x [ j - 1 ] and x [ j ] > x [ j + 1 ] : s -= 1 if s >= m : ind = i - 1 m = s   i -= 1 j -= 1 print ( m , ind + 1 ) NEW_LINE"],"bleu":0.8950577667772595,"rouge_l":0.5060490839958521}
{"id":219,"predictions":["n = int ( input ( ) ) s = input ( ) ans = 0 c = 0 n = len ( s ) for i in range ( n - 1 ) : NEW_LINE"],"references":["n = int ( input ( ) ) s = input ( ) k = [ s [ i : i + 2 ] for i in range ( n - 1 ) ] print ( max ( k , key = k . count ) ) NEW_LINE","n = int ( input ( ) ) string = input ( ) d = dict ( ) for i in range ( n - 1 ) : new_str = string [ i : i + 2 ] if new_str in d . keys ( ) : d [ new_str ] += 1 else : d [ new_str ] = 1 ans = max ( d , key = d . get ) print ( ans ) NEW_LINE","from sys import stdin , stdout   def main ( ) : n = int ( stdin . readline ( ) ) s = stdin . readline ( ) [ : - 1 ] c = { } for i in range ( n - 1 ) : c [ s [ i : i + 2 ] ] = c . get ( s [ i : i + 2 ] , 0 ) + 1 x = max ( c , key = c . get ) stdout . write ( str ( x ) + ' \\n ' )   if __name__ == \" _ _ main _ _ \" : main ( ) NEW_LINE","n = int ( input ( ) ) s = input ( ) l = [ ] for i in range ( 0 , n - 1 ) : l . append ( s [ i : i + 2 ] ) maxx = 0 for k in range ( 0 , len ( l ) ) : if ( l . count ( l [ k ] ) > maxx ) : maxx = l . count ( l [ k ] ) for p in l : if ( l . count ( p ) == maxx ) : print ( p ) break NEW_LINE","n = int ( input ( ) ) s = input ( ) a = [ 0 ] * nl = [ ] k = \" \" m = - 1 for i in range ( n - 1 ) : c = 0 k = s [ i : i + 2 ] if k not in l : l . append ( k ) for j in range ( n - 1 ) : if s [ j : j + 2 ] == k : c += 1 a [ c ] = k m = max ( m , c ) print ( a [ m ] )   NEW_LINE"],"bleu":0.518031758478088,"rouge_l":0.6214834095809014}
{"id":220,"predictions":["import sys , os , ioimport math , bisect , operatorinf , mod = float ( ' inf ' ) , 10 ** 9 + 7 NEW_LINE"],"references":["def main ( ) : t = int ( input ( ) ) allans = [ ] for _ in range ( t ) : x = int ( input ( ) ) arr = [ int ( z ) for z in input ( ) ] n = len ( arr ) j = 1 for i in range ( x ) : if j == n : break for yy in range ( arr [ i ] - 1 ) : if len ( arr ) > x : break for zz in range ( i + 1 , n ) : if len ( arr ) > x : break arr . append ( arr [ zz ] ) n += ( ( n - j + MOD ) % MOD ) * ( arr [ i ] - 1 ) j += 1 n %= MOD NEW_LINE","t = int ( input ( ) ) mod = 10 ** 9 + 7 for _ in range ( t ) : x = int ( input ( ) ) s = input ( ) i = 1 while len ( s ) < x : s += s [ i : ] * ( ord ( s [ i - 1 ] ) - 49 ) i += 1 l = len ( s ) while i <= x : l = ( l + ( l - i ) * ( ord ( s [ i - 1 ] ) - 49 ) ) % mod i += 1 print ( l ) NEW_LINE","t = int ( input ( ) ) mod = 10 ** 9 + 7 for _ in range ( t ) : x = int ( input ( ) ) s = input ( ) i = 1 while len ( s ) < x : s += s [ i : ] * ( ord ( s [ i - 1 ] ) - 49 ) i += 1 l = len ( s ) while i <= x : l = ( l + ( l - i ) * ( ord ( s [ i - 1 ] ) - 49 ) ) % mod i += 1 print ( l ) NEW_LINE","t = int ( input ( ) ) mod = 10 ** 9 + 7 for _ in range ( t ) : x = int ( input ( ) ) s = input ( ) i = 1 while len ( s ) < x : s += s [ i : ] * ( ord ( s [ i - 1 ] ) - 49 ) i += 1 l = len ( s ) while i <= x : l = ( l + ( l - i ) * ( ord ( s [ i - 1 ] ) - 49 ) ) % mod i += 1 print ( l ) NEW_LINE","import sys     def input ( ) : return sys . stdin . readline ( ) . rstrip ( )     MOD = int ( 1e9 + 7 )     def slv ( ) : x = int ( input ( ) ) gen = list ( input ( ) ) gen = list ( map ( int , gen ) ) S = gen . copy ( ) ans = len ( S ) for op in range ( x ) : if len ( S ) > x : rep = S [ op ] ans = ( ans - ( op + 1 ) ) * rep + ( op + 1 ) ans %= MOD else : rep = S [ op ] L = len ( S ) for _ in range ( rep - 1 ) : for i in range ( op + 1 , L ) : S . append ( S [ i ] ) ans = len ( S ) NEW_LINE"],"bleu":0.008027597244811672,"rouge_l":0.1123388581952118}
{"id":221,"predictions":["string = input ( ) while string [ - 1 ] == '0' : string = string [ : len ( string ) - 1 ] if string == string [ : : - 1 ] : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"references":["a = input ( ) b = input ( )   def dfs ( sa , sb ) : if sa == sb : return True if len ( sa ) & 1 : return False n = len ( sa ) \/\/ 2 sa1 = sa [ : n ] sa2 = sa [ n : ] sb1 = sb [ : n ] sb2 = sb [ n : ] if dfs ( sa1 , sb2 ) and dfs ( sa2 , sb1 ) : return True if dfs ( sa1 , sb1 ) and dfs ( sa2 , sb2 ) : return True return False   if dfs ( a , b ) : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE","def verificar_compatibilidade ( string1 , string2 ) : if ( string1 == string2 ) : return True NEW_LINE","def equivalent ( a , b ) :   NEW_LINE"],"bleu":0.4219957283595822,"rouge_l":0.4961952243505642}
{"id":222,"predictions":["import sys , os , ioimport math , bisect , operatorinf , mod = float ( ' inf ' ) , 10 ** 9 + 7 NEW_LINE"],"references":["n , m , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) a1 = [ ] for i in range ( n ) : a1 . append ( ( a [ i ] , i ) ) a1 . sort ( reverse = True ) _max = [ 0 ] * nans = 0 for i in range ( m * k ) : _max [ a1 [ i ] [ 1 ] ] = 1 ans += a1 [ i ] [ 0 ] print ( ans ) _sum = 0 ans_ar = [ ] for i in range ( n ) : _sum += _max [ i ] if _sum == m : ans_ar . append ( i + 1 ) _sum = 0 ans_ar . pop ( ) print ( * ans_ar )           NEW_LINE","import sysimport bisectinput = lambda : sys . stdin . readline ( ) . strip ( \" \\n \" ) from math import logsa = lambda : input ( ) sb = lambda : int ( input ( ) ) sc = lambda : input ( ) . split ( ) sd = lambda : list ( map ( int , input ( ) . split ( ) ) ) se = lambda : float ( input ( ) ) sf = lambda : list ( input ( ) ) flsh = lambda : sys . stdout . flush ( ) mod = 10 ** 9 + 7 def hnbhai ( ) : n , m , k = sd ( ) a = sd ( ) ans = [ ] for i in range ( n ) : ans . append ( [ a [ i ] , i + 1 ] ) ans . sort ( reverse = True ) query = ans [ : m * k ] query . sort ( key = lambda k : k [ 1 ] ) total = 0 for i in query : total += i [ 0 ] print ( total ) for i in range ( m * k - 1 ) : if ( i + 1 ) % m == 0 : print ( query [ i ] [ 1 ] , end = \" ▁ \" )   for _ in range ( 1 ) : hnbhai ( ) NEW_LINE","n , m , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = a . copy ( ) b . sort ( reverse = True ) d = { } tot = 0 for i in range ( k * m ) : tot += b [ i ] if b [ i ] in d : d [ b [ i ] ] += 1 else : d [ b [ i ] ] = 1 print ( tot ) c = mans = [ ] for i in range ( n ) : if a [ i ] in d and d [ a [ i ] ] > 0 : c -= 1 d [ a [ i ] ] -= 1 if c == 0 : ans . append ( i + 1 ) k -= 1 c = m if k == 0 : breakans . pop ( ) print ( * ans ) NEW_LINE","n , m , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = a . copy ( ) b . sort ( reverse = True ) d = { } tot = 0 for i in range ( k * m ) : tot += b [ i ] if b [ i ] in d : d [ b [ i ] ] += 1 else : d [ b [ i ] ] = 1 print ( tot ) c = mans = [ ] for i in range ( n ) : if a [ i ] in d and d [ a [ i ] ] > 0 : c -= 1 d [ a [ i ] ] -= 1 if c == 0 : ans . append ( i + 1 ) k -= 1 c = m if k == 0 : breakans . pop ( ) print ( * ans ) NEW_LINE"],"bleu":0.0017545513555755825,"rouge_l":0.09498387276165055}
{"id":223,"predictions":["n , m = map ( int , input ( ) . split ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) curr = 0 ans = [ ] for n in arr : curr += n turned = curr \/\/ m ans . append ( turned ) curr %= m   print ( * ans ) NEW_LINE"],"references":["import reimport sysexit = sys . exitfrom bisect import bisect_left as bsl , bisect_right as bsrfrom collections import Counter , defaultdict as ddict , dequefrom functools import lru_cachecache = lru_cache ( None ) from heapq import * from itertools import * from math import inffrom pprint import pprint as ppenum = enumerateri = lambda : int ( rln ( ) ) ris = lambda : list ( map ( int , rfs ( ) ) ) rln = sys . stdin . readlinerl = lambda : rln ( ) . rstrip ( ' \\n ' ) rfs = lambda : rln ( ) . split ( ) mod = 1000000007 d4 = [ ( 0 , - 1 ) , ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 0 ) ] d8 = [ ( - 1 , - 1 ) , ( 0 , - 1 ) , ( 1 , - 1 ) , ( - 1 , 0 ) , ( 1 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) ] NEW_LINE","import sysreadline = sys . stdin . readline   N = int ( readline ( ) ) A = list ( map ( int , readline ( ) . split ( ) ) ) res = [ ] mini = min ( A ) for i in range ( N ) : if A [ i ] == mini : res . append ( i )   print ( min ( i - j for i , j in zip ( res [ 1 : ] , res ) ) ) NEW_LINE","import sys , math , itertoolsfrom collections import Counter , deque , defaultdictfrom bisect import bisect_left , bisect_right from heapq import heappop , heappush , heapify , nlargestfrom copy import deepcopymod = 10 ** 9 + 7 INF = float ( ' inf ' ) def inp ( ) : return int ( sys . stdin . readline ( ) ) def inpl ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) def inpl_1 ( ) : return list ( map ( lambda x : int ( x ) - 1 , sys . stdin . readline ( ) . split ( ) ) ) def inps ( ) : return sys . stdin . readline ( ) def inpsl ( x ) : tmp = sys . stdin . readline ( ) ; return list ( tmp [ : x ] ) def err ( x ) : print ( x ) ; exit ( )   n = inp ( ) a = inpl ( ) mi = min ( a ) pre = - INFres = INFfor i , x in enumerate ( a ) : if x == mi : res = min ( res , i - pre ) pre = iprint ( res ) NEW_LINE","n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) k = min ( a ) d = max ( a ) + 1   p = - 100000 pas = [ ] while k in a : s = a . index ( k ) a [ s ] = d if s - p == 1 : exit ( print ( 1 ) ) pas . append ( s - p ) p = s           print ( min ( pas ) )   NEW_LINE"],"bleu":0.3009689383726398,"rouge_l":0.44776962168266515}
{"id":224,"predictions":["for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) a = input ( ) b = a . replace ( ' L ' , '0' ) a = a . replace ( ' R ' , '0' ) b = a . replace ( ' B ' , '1' ) print ( a + b ) NEW_LINE"],"references":["from sys import stdin , stdoutstdin . readlinedef mp ( ) : return list ( map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) ) def it ( ) : return int ( stdin . readline ( ) . strip ( ) ) from collections import defaultdict as dd , Counter as C , dequefrom math import ceil , gcd     NEW_LINE","for _ in range ( int ( input ( ) ) ) : s = input ( ) a = s . count ( ' S ' ) b = s . count ( ' P ' ) c = s . count ( ' R ' ) x = max ( a , b , c ) if a == x : print ( ' R ' * len ( s ) ) elif b == x : print ( ' S ' * len ( s ) ) else : print ( ' P ' * len ( s ) ) NEW_LINE","from collections import Counterd = { ' R ' : ' P ' , ' S ' : ' R ' , ' P ' : ' S ' } for _ in range ( int ( input ( ) ) ) : s = input ( ) . strip ( ) z = Counter ( s )   for i in z : if z [ i ] == max ( z . values ( ) ) : print ( d [ i ] * len ( s ) ) break NEW_LINE","def RPS ( v ) : if v == ' R ' : return ' P ' if v == ' P ' : return ' S ' ; if v == ' S ' : return ' R '   for _ in range ( int ( input ( ) ) ) : s = [ str ( x ) for x in input ( ) ] r = s . count ( ' R ' ) p = s . count ( ' P ' ) sc = s . count ( ' S ' ) if max ( r , p , sc ) == r : v = ' R ' elif max ( r , p , sc ) == p : v = ' P ' else : v = ' S ' c = [ RPS ( v ) for i in range ( len ( s ) ) ] print ( ' ' . join ( c ) ) NEW_LINE"],"bleu":0.3829985896245959,"rouge_l":0.5019199122325836}
{"id":225,"predictions":["a , b , c , d = map ( int , input ( ) . split ( ) ) misha = max ( 3 * a \/ 10 , a - ( a \/ 250 ) * c ) vasya = max ( 3 * b \/ 10 , b - ( b \/ 250 ) * d )   if vasya > misha : print ( \" Vasya \" ) if misha > vasya : print ( \" Misha \" ) if misha == vasya : print ( \" Tie \" ) NEW_LINE"],"references":["import sysimport mathfrom collections import OrderedDictdef input ( ) : return sys . stdin . readline ( ) . strip ( ) def iinput ( ) : return int ( input ( ) ) def minput ( ) : return map ( int , input ( ) . split ( ) ) def listinput ( ) : return list ( map ( int , input ( ) . split ( ) ) ) n , p = minput ( ) s = input ( ) s1 = s [ : ( n - p ) ] s2 = s [ p : ] if ( s1 == s2 and s1 . count ( ' . ' ) == 0 and s2 . count ( ' . ' ) == 0 ) or n == 1 or n == p : print ( ' NO ' ) else : for i in range ( n - p ) : if s [ i ] == ' . ' : if s [ p + i ] == '0' or s [ p + i ] == ' . ' : s = s [ : i ] + '1' + s [ i + 1 : ] else : s = s [ : i ] + '0' + s [ i + 1 : ] break elif s [ p + i ] == ' . ' : if s [ i ] == '0' or s [ i ] == ' . ' : s = s [ : p + i ] + '1' + s [ p + i + 1 : ] else : s = s [ : p + i ] + '0' + s [ p + i + 1 : ] break s = s . replace ( ' . ' , '0' ) print ( s ) NEW_LINE","n , p = map ( int , input ( ) . split ( ) ) s = str ( input ( ) ) t = [ 0 ] * nfor i in range ( n ) : if s [ i ] != ' . ' : t [ i ] = s [ i ] else : if i - p >= 0 : t [ i ] = str ( 1 - int ( t [ i - p ] ) ) else : if i + p <= n - 1 : if s [ i + p ] != ' . ' : t [ i ] = str ( 1 - int ( s [ i + p ] ) ) else : t [ i ] = '0' else : t [ i ] = '0' NEW_LINE","n , p = list ( map ( int , input ( ) . split ( ) ) ) s = list ( input ( ) ) f = 1 for i in range ( n - p ) : if s [ i ] == ' . ' : if s [ i + p ] == ' . ' : s [ i ] = '1' s [ i + p ] = '0' else : s [ i ] = '0' if s [ i + p ] == '1' else '1' else : if s [ i + p ] == ' . ' : s [ i + p ] = '0' if s [ i ] == '1' else '1' for i in range ( n ) : if s [ i ] == ' . ' : s [ i ] = '1' for i in range ( n - p ) : if s [ i + p ] != s [ i ] : f = 0 breakif f : print ( ' No ' ) else : print ( ' ' . join ( s ) ) NEW_LINE","n , p = map ( int , input ( ) . split ( ) ) s = list ( input ( ) ) f = Truefor i in range ( n - p ) : if s [ i ] == ' . ' and s [ i + p ] == ' . ' : s [ i ] = '1' s [ i + p ] = '0' f = False break elif s [ i ] == ' . ' : s [ i ] = str ( 1 - int ( s [ i + p ] ) ) f = False break elif s [ i + p ] == ' . ' : s [ i + p ] = str ( 1 - int ( s [ i ] ) ) f = False break elif s [ i ] != s [ i + p ] : f = False breakif f : print ( ' NO ' ) else : for p in s : if p == ' . ' : print ( 1 , end = ' ' ) else : print ( p , end = ' ' ) print ( ) NEW_LINE"],"bleu":0.12469949296485422,"rouge_l":0.2879455763423692}
{"id":226,"predictions":["a , b , c = map ( int , input ( ) . split ( ) ) print ( 2 * min ( a , b , c ) ) NEW_LINE"],"references":["for _ in range ( int ( input ( ) ) ) : a , b = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE print ( a ^ b ) NEW_LINE","t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( a ^ b ) NEW_LINE","import sys , functools , collections , bisect , math , NEW_LINE INDENT heapqinput = sys . stdin . readline NEW_LINE DEDENT","import mathfrom NEW_LINE decimal NEW_LINE import Decimal     NEW_LINE def string_to_list ( s , char ) : collector = \" \" NEW_LINE output_list = [ ] NEW_LINE for i in range ( len ( s ) ) : if NEW_LINE s [ i ] != char : collector += s [ i ] NEW_LINE if i == len ( s ) - 1 : NEW_LINE INDENT output_list . append ( int ( collector ) ) else : NEW_LINE output_list . append ( int ( collector ) ) NEW_LINE DEDENT collector = \" \" NEW_LINE return output_list     NEW_LINE"],"bleu":0.537429339152238,"rouge_l":0.5896309314586995}
{"id":227,"predictions":["n , m = map ( int , input ( ) . strip ( ) . split ( ' ▁ ' ) ) x = list ( map ( int , input ( ) . strip ( ) . split ( ' ▁ ' ) ) ) t = list ( map ( int , input ( ) . strip ( ) . split ( ' ▁ ' ) ) ) l1 = [ ] l2 = [ ] r1 = [ ] l2 = [ ] for i in range ( m ) : if l1 [ i ] == 0 : l1 . append ( x [ i ] ) else : r1 . append ( x [ i ] ) l2 . append ( x [ i ] ) l2 . sort ( ) ans = - 1 for i in range ( n ) : if l1 [ i ] < l2 [ - 1 ] [ 0 ] : ans = - 1 breakfor i in ans : print ( ans , end = \" ▁ \" ) NEW_LINE"],"references":["    n , r = map ( int , input ( ) . split ( ) )     t = list ( map ( int , input ( ) . split ( ) ) )       arr = [ 0 ] * ( n + 1 )     for i in range ( n ) :   if t [ i ] == 1 : arr [ max ( i - r + 1 , 0 ) ] += 1 arr [ min ( n , i + r ) ] -= 1         for j in range ( 1 , n + 1 ) : arr [ j ] += arr [ j - 1 ]         if 0 in arr [ : n ] : print ( - 1 ) else : ans = 0   for i in range ( n ) : st = max ( 0 , i - r + 1 ) en = min ( i + r , n )   h = 0   for j in range ( st , en ) : if arr [ j ] == 1 : h += 1 if h == 0 : ans += 1 for j in range ( st , en ) : arr [ j ] -= 1   print ( sum ( t ) - ans )                     NEW_LINE","for _ in range ( 1 ) : n , r = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) dp = [ 0 ] * n for i in range ( n ) : if l [ i ] == 1 : for j in range ( max ( 0 , i - r + 1 ) , min ( n , i + r ) ) : dp [ j ] += 1 if 0 in dp : print ( - 1 ) break ans = l . count ( 1 ) for i in range ( n ) : if l [ i ] == 1 : flag = 0 for j in range ( max ( 0 , i - r + 1 ) , min ( n , i + r ) ) : if dp [ j ] == 1 : flag = 1 if flag == 0 : ans += - 1 for j in range ( max ( 0 , i - r + 1 ) , min ( n , i + r ) ) : dp [ j ] -= 1 print ( ans ) NEW_LINE","p = list ( map ( int , input ( ) . split ( ) ) ) n = p [ 0 ] m = p [ 1 ] a = list ( map ( int , input ( ) . split ( ) ) ) c = { } l = int ( 0 ) r = int ( 0 ) ans = int ( 0 ) flag = int ( 0 ) for i in range ( 0 , n ) : c [ i ] = 0 ; while l < n : if c [ l ] == 1 : l = l + 1 continue ff = int ( 0 ) ans = ans + 1 for i in range ( l , min ( n , l + m ) ) : if a [ i ] == 1 : ff = 1 r = i + m if ff == 0 : for i in range ( max ( 0 , l - m + 1 ) , l ) : if a [ i ] == 1 : ff = 1 r = i + m if ff == 0 : flag = 1 break for i in range ( l , r ) : c [ i ] = 1 l = rif flag == 1 : print ( - 1 ) else : print ( ans ) NEW_LINE","p = list ( map ( int , input ( ) . split ( ) ) ) n = p [ 0 ] m = p [ 1 ] a = list ( map ( int , input ( ) . split ( ) ) ) c = { } l = int ( 0 ) r = int ( 0 ) ans = int ( 0 ) flag = int ( 0 ) for i in range ( 0 , n ) : c [ i ] = 0 ; while l < n : if c [ l ] == 1 : l = l + 1 continue ff = int ( 0 ) ans = ans + 1 for i in range ( l , min ( n , l + m ) ) : if a [ i ] == 1 : ff = 1 r = i + m if ff == 0 : for i in range ( max ( 0 , l - m + 1 ) , l ) : if a [ i ] == 1 : ff = 1 r = i + m if ff == 0 : flag = 1 break for i in range ( l , r ) : c [ i ] = 1 l = rif flag == 1 : print ( - 1 ) else : print ( ans ) NEW_LINE","p = list ( map ( int , input ( ) . split ( ) ) ) n = p [ 0 ] m = p [ 1 ] a = list ( map ( int , input ( ) . split ( ) ) ) c = { } l = int ( 0 ) r = int ( 0 ) ans = int ( 0 ) flag = int ( 0 ) for i in range ( 0 , n ) : c [ i ] = 0 ; while l < n : if c [ l ] == 1 : l = l + 1 continue ff = int ( 0 ) ans = ans + 1 for i in range ( l , min ( n , l + m ) ) : if a [ i ] == 1 : ff = 1 r = i + m if ff == 0 : for i in range ( max ( 0 , l - m + 1 ) , l ) : if a [ i ] == 1 : ff = 1 r = i + m if ff == 0 : flag = 1 break for i in range ( l , r ) : c [ i ] = 1 l = rif flag == 1 : print ( - 1 ) else : print ( ans ) NEW_LINE"],"bleu":0.3116631273910694,"rouge_l":0.4329182075266478}
{"id":228,"predictions":["n = int ( input ( ) ) st = input ( ) for i in range ( n - 1 ) : if st [ i ] > st [ i + 1 ] : st = st [ : i ] + st [ i + 1 ] breakif len ( st ) != n : print ( st ) else : print ( st [ : - 1 ] ) NEW_LINE"],"references":["ans = [ ] for i in range ( 27 ) : for j in range ( 27 ) : for t in range ( 27 ) : tempa = [ i , j , t ] s = ' ' for q in range ( len ( tempa ) ) : if ( tempa [ q ] == 26 ) : continue ; else : s += chr ( tempa [ q ] + 97 ) ans . append ( [ len ( s ) , s ] )   ans . sort ( ) pg = [ ]   x = int ( input ( ) ) for i in range ( x ) : s = input ( ) pg . append ( s ) for i in range ( len ( ans ) ) : flag = 0 for j in range ( len ( pg ) ) : if ( ans [ i ] [ 1 ] in pg [ j ] ) : flag += 1 if ( flag == 0 ) : print ( ans [ i ] [ 1 ] ) exit ( )                                               NEW_LINE","import strings = ' ▁ ' . join ( input ( ) for i in range ( int ( input ( ) ) ) ) alph = string . ascii_lowercasefor i in alph : if i not in s : print ( i ) ; exit ( ) for i in alph : for j in alph : if i + j not in s : print ( i + j ) ; exit ( ) NEW_LINE","import stringn = int ( input ( ) ) ; s = ' . ' . join ( input ( ) for _ in range ( n ) ) a = string . ascii_lowercasefor i in a : if i not in s : print ( i ) ; exit ( ) for i in a : for j in a : if i + j not in s : print ( i + j ) ; exit ( ) NEW_LINE","n = int ( input ( ) ) l = [ ] for i in range ( n ) : l += [ input ( ) ] s = \" + \" . join ( l ) q = \" abcdefghijklmnopqrstuvwxyz \" for i in q : if i not in s : print ( i ) breakelse : for i in q : for j in q : if i + j not in s : print ( i + j ) exit ( ) NEW_LINE","n = int ( input ( ) ) strings = [ ] all = [ ] alps = [ ] for i in range ( 26 ) : alps . append ( chr ( ord ( ' a ' ) + i ) ) all . append ( alps [ i ] ) for i in range ( 26 ) : for j in range ( i , 26 ) : all . append ( alps [ i ] + alps [ j ] ) for i in range ( n ) : s = input ( ) for j in range ( len ( s ) ) : for k in range ( j , len ( s ) ) : strings . append ( s [ j : k + 1 ] ) ans = ' ' NEW_LINE"],"bleu":0.3697488163350649,"rouge_l":0.4477164402873191}
{"id":229,"predictions":["import sys , math , itertoolsfrom collections import Counter , deque , defaultdictfrom bisect import bisect_left , bisect_right from heapq import heappop , heappush , heapify , nlargestfrom copy import deepcopymod = 10 ** 9 + 7 INF = float ( ' inf ' ) def inp ( ) : return int ( sys . stdin . readline ( ) ) def inpl ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) def inpl_1 ( ) : return list ( map ( lambda x : int ( x ) - 1 , sys . stdin . readline ( ) . split ( ) ) ) def inps ( ) : return sys . stdin . readline ( ) def inpsl ( x ) : tmp = sys . stdin . readline ( ) ; return list ( tmp [ : x ] ) def err ( x ) : print ( x ) ; exit ( )   for _ in range ( inp ( ) ) : n , k = inpl ( ) a = inpl_1 ( ) res = [ INF ] * n se = set ( a ) pr = - INF for i in range ( n ) : if i in se : pr = i res [ i ] = min ( res [ i ] , i - pr + 1 ) pr = INF for i in range ( n ) [ : : - 1 ] : if i in se : pr = i res [ i ] = min ( res [ i ] , pr - i + 1 ) print ( max ( res ) ) NEW_LINE"],"references":["for t in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE r = [ int ( i ) for i in s [ 0 : : 2 ] ] NEW_LINE b = [ int ( i ) for i in s [ 1 : : 2 ] ] NEW_LINE win = 0 NEW_LINE if n % 2 == 1 : win = 2 NEW_LINE for i in r : if NEW_LINE i % 2 == 1 : win = 1 NEW_LINE break else : win = 1 NEW_LINE for i in b : if NEW_LINE i % 2 == 0 : win = 2 NEW_LINE break NEW_LINE print ( win ) NEW_LINE","t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE ali = [ ] NEW_LINE for i in s : ali . append ( int ( i ) ) NEW_LINE","import sys   input = sys . stdin . buffer . readline   t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : n = int ( input ( ) ) NEW_LINE s = input ( ) . strip ( )   if n % 2 == 1 : any_winners = any ( int ( a ) % 2 == 1 for i , a in enumerate ( s ) if i % 2 == 0 ) NEW_LINE print ( 1 if any_winners else 2 ) else : any_winners = any ( int ( a ) % 2 == 0 for i , a in enumerate ( s ) if i % 2 == 1 ) NEW_LINE print ( 2 if any_winners else 1 ) NEW_LINE","cases = int ( input ( ) ) NEW_LINE while cases : cases -= 1 NEW_LINE num = int ( input ( ) ) NEW_LINE arr = list ( map ( int , list ( input ( ) ) ) )   odds = 0 NEW_LINE evens = 0 NEW_LINE if num == 1 : if NEW_LINE arr [ 0 ] % 2 == 0 : print ( 2 ) else : print ( 1 ) else :   for i , n in enumerate ( arr , start = 1 ) : if NEW_LINE i % 2 != 0 and n % 2 != 0 : odds += 1 elif i % 2 == 0 and n % 2 == 0 : evens += 1 NEW_LINE"],"bleu":0.11715485560983628,"rouge_l":0.32993770652853444}
{"id":230,"predictions":["n = int ( input ( ) ) a = [ ] for i in range ( n ) : a . append ( input ( ) ) a . sort ( ) ans = 0 for i in range ( 1 , n ) : ans += a [ i ] [ 0 ] * a [ n - 1 ] [ 1 ] + a [ i ] [ 2 ] print ( ans ) NEW_LINE"],"references":["from itertools import permutations   flag = 0 a = input ( ) a_list = list ( permutations ( \" ABC \" ) ) a_list = [ \" \" . join ( x ) for x in a_list ] for x in a_list : if x in a : flag = 1 if flag == 1 : print ( \" Yes \" ) else : print ( \" No \" ) NEW_LINE","s = str ( input ( ) ) n = len ( s ) flag = 0 for i in range ( 1 , n - 1 ) : if ( s [ i ] != ' . ' and s [ i - 1 ] != ' . ' and s [ i + 1 ] != ' . ' ) : if ( s [ i - 1 ] != s [ i ] and s [ i ] != s [ i + 1 ] and s [ i - 1 ] != s [ i + 1 ] ) : flag = 1 if ( flag == 1 ) : print ( \" Yes \" ) else : print ( \" No \" ) NEW_LINE","def solve ( s ) : x = [ ' ABC ' , ' ACB ' , ' BAC ' , ' BCA ' , ' CAB ' , ' CBA ' ] for i in range ( 0 , len ( s ) - 2 ) : if ' ' . join ( s [ i : i + 3 ] ) in x : return ' Yes ' return ' No '                 def main ( ) : NEW_LINE","s = str ( input ( ) ) if s . count ( ' BAC ' ) > 0 or s . count ( ' ABC ' ) > 0 or s . count ( ' CAB ' ) > 0 or s . count ( ' BCA ' ) > 0 or s . count ( ' CBA ' ) > 0 or s . count ( ' ACB ' ) > 0 : print ( ' Yes ' ) else : print ( ' No ' ) NEW_LINE","s = input ( )     f = Falsefor i in range ( len ( s ) - 2 ) : x = s [ i : i + 3 ]   if ' A ' in x and ' B ' in x and ' C ' in x : f = True break   NEW_LINE"],"bleu":0.3146439241395071,"rouge_l":0.39021692078303105}
{"id":231,"predictions":["n = int ( input ( ) ) a = [ ] for i in range ( n ) : s = input ( ) a . append ( s ) a . append ( a [ - 1 ] ) a . sort ( ) f = 0 for i in range ( 1 , n ) : if a [ i - 1 ] [ 0 ] != a [ i : ] [ 1 ] : f = 1 breakif f == 1 : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"references":["from sys import stdin NEW_LINE input = stdin . readline NEW_LINE input ( ) NEW_LINE * a , = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s , r = [ 0 ] * 2 NEW_LINE cnt = [ 0 ] * 100002 NEW_LINE for i in a : NEW_LINE INDENT cnt [ i ] += 1 NEW_LINE if cnt [ i ] % 4 == 0 : NEW_LINE INDENT s += 1 NEW_LINE DEDENT if cnt [ i ] % 2 == 0 : NEW_LINE INDENT r += 1 NEW_LINE DEDENT DEDENT q = int ( input ( ) ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT sign , n = input ( ) . split ( ) NEW_LINE n = int ( n ) NEW_LINE if sign == ' + ' : NEW_LINE INDENT cnt [ n ] += 1 NEW_LINE if cnt [ n ] % 4 == 0 : NEW_LINE INDENT s += 1 NEW_LINE DEDENT if cnt [ n ] % 2 == 0 : NEW_LINE INDENT r += 1 NEW_LINE DEDENT DEDENT elif sign == ' - ' : NEW_LINE INDENT if cnt [ n ] % 4 == 0 : NEW_LINE INDENT s -= 1 NEW_LINE DEDENT if cnt [ n ] % 2 == 0 : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT cnt [ n ] -= 1 NEW_LINE DEDENT print ( ' YES ' if s > 1 or ( s == 1 and r > 3 ) else ' NO ' ) NEW_LINE DEDENT","from sys import stdin NEW_LINE input = stdin . readline NEW_LINE input ( ) NEW_LINE * a , = map ( int , input ( ) . split ( ) ) NEW_LINE s , r = [ 0 ] * 2 NEW_LINE cnt = [ 0 ] * 100002 NEW_LINE for i in a : NEW_LINE INDENT cnt [ i ] += 1 NEW_LINE if cnt [ i ] % 4 == 0 : NEW_LINE INDENT s += 1 NEW_LINE DEDENT if cnt [ i ] % 2 == 0 : NEW_LINE INDENT r += 1 NEW_LINE DEDENT DEDENT q = int ( input ( ) ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT sign , n = input ( ) . split ( ) NEW_LINE n = int ( n ) NEW_LINE if sign == ' + ' : NEW_LINE INDENT cnt [ n ] += 1 NEW_LINE if cnt [ n ] % 4 == 0 : NEW_LINE INDENT s += 1 NEW_LINE DEDENT if cnt [ n ] % 2 == 0 : NEW_LINE INDENT r += 1 NEW_LINE DEDENT DEDENT elif sign == ' - ' : NEW_LINE INDENT if cnt [ n ] % 4 == 0 : NEW_LINE INDENT s -= 1 NEW_LINE DEDENT if cnt [ n ] % 2 == 0 : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT cnt [ n ] -= 1 NEW_LINE DEDENT print ( ' YES ' if s > 1 or ( s == 1 and r > 3 ) else ' NO ' ) NEW_LINE DEDENT","_ , s , _ , * l = open ( 0 ) NEW_LINE a , b , * d = [ 0 ] * 7 ** 6 NEW_LINE for s in s . split ( ) + l : f = s [ 0 ] < '0' ; t = int ( s [ f : ] ) ; e = s [ 0 ] == ' - ' ; k = 1 - 2 * e ; m = d [ t ] - e ; d [ t ] += k ; a += m % 2 * k ; b += m % 4 \/\/ 3 * k ; print ( ' NYOE ▁ S ' [ a - 3 > 0 < b : f * 6 : 2 ] ) NEW_LINE"],"bleu":0.1829360987437894,"rouge_l":0.30430839002267573}
{"id":232,"predictions":["n , k = map ( int , input ( ) . split ( ) ) p = n \/\/ 2 p = min ( p , k ) s = 0 for j in range ( p * 2 ) : s = s + n - 1 n = n - 1 print ( s ) NEW_LINE"],"references":["k , s , o = int ( input ( ) ) , \" z \" , 97 while k : q = int ( ( ( 1 + 8 * k ) ** .5 - 1 ) \/ 2 ) + 1 k -= q * ( q - 1 ) \/\/ 2 s += chr ( o ) * q o += 1 print ( s ) NEW_LINE","k , s , o = int ( input ( ) ) , \" \" , 97 if k == 0 : s = \" a \" while k : q = int ( ( ( 1 + 8 * k ) ** .5 - 1 ) \/ 2 ) + 1 k -= q * ( q - 1 ) \/\/ 2 s += chr ( o ) * q o += 1 print ( s ) NEW_LINE"],"bleu":0.16974062721348715,"rouge_l":0.3566760235157036}
{"id":233,"predictions":["n = int ( input ( ) ) a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) print ( abs ( a [ n - 1 ] - a [ n ] ) ) NEW_LINE"],"references":["n , c = map ( int , input ( ) . split ( ) ) prices = list ( map ( int , input ( ) . split ( ) ) )   max_i = Nonemax_p = Nonefor i , p in enumerate ( prices ) : if max_p is None or ( i < len ( prices ) - 1 and p - prices [ i + 1 ] > max_p ) : max_i = i max_p = p - prices [ i + 1 ]   print ( max ( 0 , prices [ max_i ] - c - prices [ max_i + 1 ] ) ) NEW_LINE","n , k = map ( int , input ( ) . split ( ) ) x = list ( map ( int , input ( ) . split ( ) ) ) c = 0 l = len ( x ) for i in range ( 1 , l ) : c = max ( c , x [ i - 1 ] - x [ i ] ) c = max ( 0 , c - k ) print ( c )   NEW_LINE","try : n , c = map ( int , input ( ) . split ( ) ) k = [ int ( i ) for i in input ( ) . split ( ) ] a = [ ] for i in range ( n - 1 ) : if ( k [ i ] <= k [ i + 1 ] ) : a . append ( 0 ) else : a . append ( k [ i ] - k [ i + 1 ] ) if ( max ( a ) == 0 or max ( a ) < c ) : print ( 0 ) else : print ( max ( a ) - c ) except : pass NEW_LINE","n , y = [ int ( x ) for x in input ( ) . split ( ) ] li = [ int ( x ) for x in input ( ) . split ( ) ] maxDiff = 0 for x in range ( n - 1 ) : if maxDiff < li [ x ] - li [ x + 1 ] : maxDiff = li [ x ] - li [ x + 1 ] if maxDiff - y > 0 : print ( maxDiff - y ) else : print ( 0 ) NEW_LINE"],"bleu":0.24192767771254894,"rouge_l":0.5171926519076779}
{"id":234,"predictions":["import sys , mathfrom collections import deque , defaultdictimport operator as opfrom functools import reducefrom itertools import permutations   NEW_LINE"],"references":["import sysinput = sys . stdin . readlineimport math   def inpit ( ) : NEW_LINE","from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE","  def getTheGoodNumbersCount ( n , k , nums ) : ''' ▁ a ▁ good ▁ number ▁ is ▁ the ▁ number ▁ that ▁ contain ▁ all ▁ the ▁ digits ▁ for ▁ 0 ▁ to ▁ k ▁ '''   counter = 0   for num in nums : range_list = list ( range ( k + 1 ) ) for digit in num : if int ( digit ) in range_list : range_list . remove ( int ( digit ) ) else : continue if len ( range_list ) == 0 : counter += 1   return counter   if __name__ == ' _ _ main _ _ ' :   n , k = input ( ) . split ( ) n = int ( n ) k = int ( k )   numbers = [ None ] * n for i in range ( n ) : numbers [ i ] = input ( )   print ( getTheGoodNumbersCount ( n , k , numbers ) ) NEW_LINE","import mathdef isk ( n , d , k ) : for i in n : if i in d : d [ i ] = 1 for i in range ( k + 1 ) : if str ( i ) in d and d [ str ( i ) ] == 0 : return False return True   n , k = map ( int , input ( ) . split ( ) ) d = { } c = 0 for _ in range ( n ) : s = input ( ) for i in range ( k + 1 ) : d [ str ( i ) ] = 0 if isk ( s , d , k ) : c += 1 print ( c ) NEW_LINE","n , k = [ int ( x ) for x in input ( ) . split ( ) ] s = 0 goodset = set ( [ str ( x ) for x in range ( k + 1 ) ] ) for i in range ( n ) : num = input ( ) if goodset . issubset ( set ( num ) ) : s += 1 print ( s ) NEW_LINE"],"bleu":0.08475426399505566,"rouge_l":0.25}
{"id":235,"predictions":["for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) l = [ int ( i ) for i in input ( ) . split ( ) ] mx = max ( l ) mxsq = 0 for i in range ( 1 , mx + 1 ) : c = 0 for j in l : if j >= i : c += 1 if c >= i : mxsq = max ( mxsq , i ) print ( mxsq ) NEW_LINE"],"references":["from sys import stdin ''' class ▁ PriorityQueueBase : ▁ ▁ ▁ ▁ class ▁ _ Item : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ _ _ slots _ _ ▁ = ▁ ' _ key ' , ' _ value '   ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ def ▁ _ _ init _ _ ( self , k , v ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ self . _ key ▁ = ▁ k ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ self . _ value ▁ = ▁ v  ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ def ▁ _ _ lt _ _ ( self , other ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ return ▁ self . _ key ▁ < ▁ other . _ key  ▁ ▁ ▁ ▁ def ▁ is _ empty ( self ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ return ▁ len ( self ) ▁ = = ▁ 0 def ▁ queue _ time ( customers , n ) : ▁ ▁ ▁ ▁ for ▁ i ▁ in ▁ range ( 1 , len ( customers ) ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ i ▁ = ▁ i % n ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ while ▁ i % n < n ▁ and ▁ customers [ i % n ] > customers [ ( i + 1 ) % n ] : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ i + = 1 ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ customers [ i % n ] ▁ = customers [ i % n ] ▁ + ▁ customers [ i ] ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ customers [ i ] ▁ = ▁ 0 ▁ ▁ ▁ ▁ return ▁ customers def ▁ phi ( n ) : ▁ ▁ ▁ ▁ result ▁ = ▁ n ▁ ▁ ▁ ▁ for ▁ i ▁ in ▁ range ( 2 , int ( pow ( n , 0.5 ) ) + 1 ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ while ▁ n % i ▁ = = ▁ 0 : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ n \/ = i ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ result - = result \/ i ▁ ▁ ▁ ▁ if ▁ n > 1 : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ result ▁ - = ▁ result \/ n ▁ ▁ ▁ ▁ return ▁ result ''' def main ( ) : input = stdin . buffer . readline for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) a . sort ( ) cur = 0 ans = 0 for i in range ( n ) : cur += 1 if cur == a [ i ] : ans += 1 cur = 0 print ( ans ) main ( ) NEW_LINE","for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) exps = sorted ( list ( map ( int , input ( ) . split ( ) ) ) )   i = 1 count = 0 for exp in exps : if i == exp : count += 1 i = 0 i += 1   print ( count )             NEW_LINE","t = int ( input ( ) ) for i in range ( t ) : n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l . sort ( ) ans = i = 0 for x in l : i += 1 if i == x : ans += 1 i = 0 print ( ans ) NEW_LINE"],"bleu":0.5080870529874373,"rouge_l":0.5943153278851905}
{"id":236,"predictions":["def solve ( ) : NEW_LINE INDENT s = input ( ) NEW_LINE n = len ( s ) NEW_LINE ans = \" \" NEW_LINE ct = 1 NEW_LINE while cnt < n : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT ans += s [ cnt ] NEW_LINE n -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT solve ( ) NEW_LINE"],"references":["n = int ( input ( ) ) s = list ( str ( input ( ) ) ) r = [ \" \" ] * nif n % 2 != 0 : j = n \/\/ 2 for i in range ( n ) : if i % 2 == 0 : r [ j + i ] = s [ i ] j += i else : r [ j - i ] = s [ i ] j -= ielse : j = ( n \/\/ 2 ) - 1 for i in range ( n ) : if i % 2 != 0 : r [ j + i ] = s [ i ] j += i else : r [ j - i ] = s [ i ] j -= i   print ( \" \" . join ( r ) ) NEW_LINE","n = int ( input ( ) ) s = list ( input ( ) )   ans = [ ] if n % 2 == 0 : while s : let = s . pop ( 0 ) ans . insert ( 0 , let ) if not s : break let2 = s . pop ( 0 ) ans . append ( let2 ) else : while s : let2 = s . pop ( 0 ) ans . append ( let2 ) if not s : break let = s . pop ( 0 ) ans . insert ( 0 , let )   print ( \" \" . join ( ans ) )   NEW_LINE","l = int ( input ( ) ) s = input ( ) i = 0 ans = \" \" while ( l > 0 ) : ch = s [ i ] i += 1 if l % 2 == 1 : ans += ch else : ans = ch + ans l -= 1 print ( ans ) NEW_LINE","n = int ( input ( ) ) x = list ( input ( ) . strip ( ) ) ans = [ ]     if n == 1 : print ( x [ 0 ] ) exit ( 0 ) if n == 1 : print ( x [ 0 ] + x [ 1 ] ) exit ( 0 )   if n % 2 != 0 : for i in range ( n - 2 , - 1 , - 2 ) : ans . append ( x [ i ] )   for i in range ( 0 , n , 2 ) : ans . append ( x [ i ] ) else : for i in range ( n - 2 , - 1 , - 2 ) : ans . append ( x [ i ] )   for i in range ( 1 , n , 2 ) : ans . append ( x [ i ] )       print ( ' ' . join ( ans ) ) NEW_LINE"],"bleu":0.27445951804359076,"rouge_l":0.45102746303053576}
{"id":237,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["mod = 1000000007 eps = 10 ** - 9     def main ( ) : import sys from bisect import bisect_left input = sys . stdin . buffer . readline   def calc ( r , g , b ) : return ( r - g ) ** 2 + ( g - b ) ** 2 + ( b - r ) ** 2   for _ in range ( int ( input ( ) ) ) : NR , NG , NB = map ( int , input ( ) . split ( ) ) R = list ( map ( int , input ( ) . split ( ) ) ) G = list ( map ( int , input ( ) . split ( ) ) ) B = list ( map ( int , input ( ) . split ( ) ) ) R . sort ( ) B . sort ( ) G . sort ( ) ans = float ( ' inf ' )   NEW_LINE","import sys , heapq as hinput = sys . stdin . readline   def getInts ( ) : return [ int ( s ) for s in input ( ) . split ( ) ]   def getInt ( ) : return int ( input ( ) )   def getStrs ( ) : return [ s for s in input ( ) . split ( ) ]   def getStr ( ) : return input ( ) . strip ( )   def listStr ( ) : return list ( input ( ) . strip ( ) )   import collections as colimport math   \"\"\" pick ▁ any ▁ triple , ▁ immediately ▁ we ▁ have ▁ an ▁ upper ▁ boundfor ▁ a ▁ given ▁ value ▁ D , ▁ is ▁ it ▁ possible ▁ to ▁ find ▁ a ▁ triple ▁ that ▁ satisfies ▁ ( x - y ) * * 2 ▁ + ▁ ( y - z ) * * 2 ▁ + ▁ ( z - x ) * * 2 ▁ < = ▁ D ? if ▁ the ▁ same ▁ element ▁ appears ▁ in ▁ all ▁ three ▁ arrays , ▁ return ▁ 0can ▁ immediately ▁ discard ▁ any ▁ pairs ▁ s . t . ▁ ( x - y ) * * 2 ▁ > = ▁ D Given ▁ ( x0 , ▁ y0 ) ▁ as ▁ a ▁ candidate ▁ pair , ▁ if ▁ there ▁ are ▁ any ▁ values ▁ of ▁ z ▁ between ▁ x0 ▁ and ▁ y0 , ▁ they ▁ are ▁ the ▁ only ▁ candidates , ▁ with ▁ preference ▁ to ▁ the ▁ one ▁ closest ▁ to ▁ ( x0 + y0 ) \/ 2Otherwise ▁ we ▁ are ▁ interested ▁ in ▁ the ▁ values ▁ of ▁ z ▁ immediately ▁ either ▁ side ▁ of ▁ x0 ▁ and ▁ y0 One ▁ element ▁ has ▁ to ▁ be ▁ in ▁ the ▁ middle ; ▁ given ▁ this , ▁ pick ▁ the ▁ two ▁ immediately ▁ either ▁ side ▁ of ▁ it R ▁ < = ▁ G ▁ < = ▁ BR ▁ < = ▁ B ▁ < = ▁ GG ▁ < = ▁ R ▁ < = ▁ BG ▁ < = ▁ B ▁ < = ▁ RB ▁ < = ▁ R ▁ < = ▁ GB ▁ < = ▁ G ▁ < = ▁ R \"\"\"   def sq_sum ( a , b , c ) : return ( a - b ) ** 2 + ( b - c ) ** 2 + ( c - a ) ** 2   def solve ( ) : NR , NG , NB = getInts ( ) Cols = [ ] for j in range ( 3 ) : Cols . append ( getInts ( ) ) Cols [ j ] . sort ( ) best = 3 * 10 ** 18 + 1 for i in range ( 3 ) : for j in range ( 3 ) : for k in range ( 3 ) : if len ( set ( [ i , j , k ] ) ) == 3 : NEW_LINE","from sys import stdin , stdoutfrom math import gcd , sqrt , factorial , pi , inffrom collections import deque , defaultdictinput = stdin . readlineR = lambda : map ( int , input ( ) . split ( ) ) I = lambda : int ( input ( ) ) S = lambda : input ( ) . rstrip ( ' \\n ' ) L = lambda : list ( R ( ) ) P = lambda x : stdout . write ( str ( x ) + ' \\n ' ) lcm = lambda x , y : ( x * y ) \/\/ gcd ( x , y ) hg = lambda x , y : ( ( y + x - 1 ) \/\/ x ) * xpw = lambda x : 1 if x == 1 else 1 + pw ( x \/\/ 2 ) chk = lambda x : chk ( x \/\/ 2 ) if not x % 2 else True if x == 1 else Falsesm = lambda x : ( x ** 2 + x ) \/\/ 2 N = 10 ** 9 + 7   def lower ( a , r , x ) : l = 0 r -= 1 ans = - 1 while l <= r : m = ( l + r ) \/\/ 2 if a [ m ] <= x : l = m + 1 ans = a [ m ] else : r = m - 1 return ans   def upper ( a , r , x ) : r -= 1 l = 0 ans = - 1 while l <= r : m = ( l + r ) \/\/ 2 if a [ m ] >= x : r = m - 1 ans = a [ m ] else : l = m + 1 return ans   def solve ( a , b , c , x , y , z ) : ans = inf for i in a : j = lower ( b , y , i ) k = upper ( c , z , i ) if j > - 1 and k > - 1 : ans = min ( ans , ( i - j ) ** 2 + ( i - k ) ** 2 + ( k - j ) ** 2 ) return ans   for _ in range ( I ( ) ) : x , y , z = R ( ) r = sorted ( R ( ) ) NEW_LINE","import sysimport bisectinput = sys . stdin . readlinedef solve ( r , g , b ) : ans = 3 * ( 10 ** 18 ) for i in g : r1 = bisect . bisect_right ( r , i ) r2 = bisect . bisect_left ( b , i ) if r1 == 0 or r2 == len ( b ) : continue j = r [ r1 - 1 ] k = b [ r2 ] ans = min ( ans , ( i - j ) ** 2 + ( j - k ) ** 2 + ( k - i ) ** 2 ) return anst = int ( input ( ) ) for _ in range ( t ) : NEW_LINE"],"bleu":0.11881319979208387,"rouge_l":0.3006336540718141}
{"id":238,"predictions":["''' a = [ int ( i ) ▁ for ▁ i ▁ in ▁ input ( ) . split ( ) ] x = a [ 0 ] y = a [ 1 ] z = a [ 2 ] if ▁ y = = x ▁ and ▁ z = = 0 : ▁ ▁ ▁ ▁ print ( '0 ' ) elif ▁ x > y + z : ▁ ▁ ▁ ▁ print ( ' + ' ) elif ▁ y > x + z : ▁ ▁ ▁ ▁ print ( ' - ' ) else : ▁ ▁ ▁ ▁ print ( ' ? ' ) n = int ( input ( ) ) z = [ int ( i ) ▁ for ▁ i ▁ in ▁ input ( ) . split ( ) ] x = [ ] d = 0v = ' ' for ▁ i ▁ in ▁ range ( n ) : ▁ ▁ ▁ ▁ c = 0 ▁ ▁ ▁ ▁ e = 0 ▁ ▁ ▁ ▁ for ▁ f ▁ in ▁ range ( len ( z ) ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ z [ f ] > c ▁ and ▁ f + 1 ▁ not ▁ in ▁ x : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ c = z [ f ] ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ e = f + 1 ▁ ▁ ▁ ▁ d + = ( i * c ) + 1 ▁ ▁ ▁ ▁ x . append ( e ) print ( d ) for ▁ i ▁ in ▁ x : ▁ ▁ ▁ ▁ v + = str ( i ) ▁ ▁ ▁ ▁ v + = ' ▁ ' print ( v ) NEW_LINE"],"references":["import math   def total ( l , r ) : l -= 1 if l % 2 == 0 : l \/= 2 else : l = int ( math . ceil ( l \/ 2 ) * - 1 ) if r % 2 == 0 : r \/= 2 else : r = int ( math . ceil ( r \/ 2 ) * - 1 ) return int ( r - l )   q = int ( input ( ) ) ans = \" \"   for i in range ( q ) : l , r = map ( int , input ( ) . split ( ) ) ans += str ( total ( l , r ) ) + \" \\n \"   print ( ans ) NEW_LINE","if __name__ == \" _ _ main _ _ \" : q = int ( input ( ) ) while q : l , r = list ( map ( int , input ( ) . split ( ) ) ) if l == r : if l % 2 == 0 : print ( l ) else : print ( l * - 1 ) else : oc = 0 ec = 0 n = r - l if n % 2 == 0 and l % 2 != 0 : oc = n \/\/ 2 + 1 ec = oc - 1 elif n % 2 == 0 and l % 2 == 0 : oc = n \/\/ 2 ec = oc + 1 else : oc = n \/\/ 2 + 1 ec = oc starte = l if l % 2 == 0 else l + 1 starto = l if l % 2 != 0 else l + 1 sume = ( ec * ( 2 * starte + ( ec - 1 ) * 2 ) ) \/\/ 2 sumo = ( oc * ( 2 * starto + ( oc - 1 ) * 2 ) ) \/\/ 2 print ( sume + ( sumo * - 1 ) ) q = q - 1 NEW_LINE","tc = int ( input ( ) )   def odd ( n ) : return ( ( n + 1 ) \/\/ 2 ) ** 2   def even ( n ) : return int ( n * ( n + 1 ) )   for _ in range ( tc ) : l , r = list ( map ( int , input ( ) . split ( ) ) ) l -= 1 ret = ( even ( r \/\/ 2 ) - even ( l \/\/ 2 ) ) - ( odd ( r ) - odd ( l ) ) print ( ret )   NEW_LINE","tc = int ( input ( ) )   def odd ( n ) : return ( ( n + 1 ) \/\/ 2 ) ** 2   def even ( n ) : return int ( n * ( n + 1 ) )   for _ in range ( tc ) : l , r = list ( map ( int , input ( ) . split ( ) ) ) l -= 1 ret = ( even ( r \/\/ 2 ) - even ( l \/\/ 2 ) ) - ( odd ( r ) - odd ( l ) ) print ( ret )   NEW_LINE","def oddSum ( n ) : return n * n   def evenSum ( n ) : return n * ( n + 1 )     def findSum ( num ) : if num <= 0 : return 0 n_terms = num \/\/ 2 if num % 2 != 0 : n_terms += 1 return oddSum ( n_terms ) * - 1 return evenSum ( n_terms )   for _ in range ( int ( input ( ) ) ) : start , stop = map ( int , input ( ) . split ( ) )   total_sum = findSum ( stop ) + findSum ( stop - 1 ) remove_sum = findSum ( start - 1 ) + findSum ( start - 2 )   required_sum = total_sum - remove_sum   print ( required_sum ) NEW_LINE"],"bleu":0.08980880699658074,"rouge_l":0.2641488889447278}
{"id":239,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["n = int ( input ( ) ) a = [ int ( x ) for x in input ( ) . split ( ) ] a . sort ( ) print ( min ( a [ - 2 ] - a [ 0 ] , a [ - 1 ] - a [ 1 ] ) ) NEW_LINE","def calc_instability ( lista , a_remover ) : lista . pop ( lista . index ( a_remover ) ) return max ( lista ) - min ( lista )   quant = int ( input ( ) ) lista = list ( map ( int , input ( ) . split ( ) ) ) instability = max ( lista ) - min ( lista )   nova_instability = calc_instability ( lista . copy ( ) , max ( lista ) ) if ( nova_instability < instability ) : instability = nova_instability   nova_instability = calc_instability ( lista . copy ( ) , min ( lista ) ) if ( nova_instability < instability ) : instability = nova_instability   print ( instability ) NEW_LINE","import sysfrom random import * from bisect import * from heapq import * NEW_LINE"],"bleu":0.3498825879250742,"rouge_l":0.3885801235347974}
{"id":240,"predictions":["n = int ( input ( ) ) matrix = [ [ 1 for i in range ( n ) ] for j in range ( n ) ] for i in range ( n ) : for j in range ( n ) : matrix [ i ] [ j ] = matrix [ i ] [ j ] = matrix [ i - 1 ] [ j ] + matrix [ i - 1 ] [ j - 2 ] print ( matrix [ n - 1 ] [ n - 2 ] ) NEW_LINE"],"references":["lights = [ [ 1 for _ in range ( 3 ) ] for _ in range ( 3 ) ] count = [ ] for _ in range ( 3 ) : count . append ( [ int ( i ) for i in input ( ) . split ( ' ▁ ' ) ] )   for i , row in enumerate ( count ) : for j , val in enumerate ( row ) : if val % 2 == 1 : lights [ i ] [ j ] = 0 if lights [ i ] [ j ] == 1 else 1 if i > 0 : lights [ i - 1 ] [ j ] = 0 if lights [ i - 1 ] [ j ] == 1 else 1 if i < 2 : lights [ i + 1 ] [ j ] = 0 if lights [ i + 1 ] [ j ] == 1 else 1 if j > 0 : lights [ i ] [ j - 1 ] = 0 if lights [ i ] [ j - 1 ] == 1 else 1 if j < 2 : lights [ i ] [ j + 1 ] = 0 if lights [ i ] [ j + 1 ] == 1 else 1   for row in lights : print ( ' ' . join ( [ str ( i ) for i in row ] ) ) NEW_LINE","c = [ ] for i in range ( 3 ) : b = [ ] b = list ( map ( int , input ( ) . split ( ) ) ) c . append ( b ) a = [ [ 1 , 1 , 1 ] , [ 1 , 1 , 1 ] , [ 1 , 1 , 1 ] ] for i in range ( 3 ) : for j in range ( 3 ) : c [ i ] [ j ] = c [ i ] [ j ] % 2   for i in range ( 3 ) : for j in range ( 3 ) : if c [ i ] [ j ] == 1 : if a [ i ] [ j ] == 0 : a [ i ] [ j ] = 1 else : a [ i ] [ j ] = 0 if i - 1 >= 0 : if a [ i - 1 ] [ j ] == 0 : a [ i - 1 ] [ j ] = 1 else : a [ i - 1 ] [ j ] = 0   if j - 1 >= 0 : if a [ i ] [ j - 1 ] == 0 : a [ i ] [ j - 1 ] = 1 else : a [ i ] [ j - 1 ] = 0   if i + 1 <= 2 : if a [ i + 1 ] [ j ] == 0 : a [ i + 1 ] [ j ] = 1 else : a [ i + 1 ] [ j ] = 0   if j + 1 <= 2 : if a [ i ] [ j + 1 ] == 0 : a [ i ] [ j + 1 ] = 1 else : a [ i ] [ j + 1 ] = 0     s = \" \" for i in range ( 3 ) : s = \" \" for j in range ( 3 ) : s += str ( a [ i ] [ j ] ) print ( s ) NEW_LINE"],"bleu":0.11473563211152231,"rouge_l":0.3708172686804597}
{"id":241,"predictions":["n , m , k = map ( int , input ( ) . split ( ) ) p = list ( map ( int , input ( ) . split ( ) ) ) s = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] c = sorted ( p ) print ( sum ( c ) ) NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) ans = 1 for _ in range ( n ) : a = list ( map ( int , input ( ) . split ( ) ) ) ans = max ( ans , min ( a ) ) print ( ans ) NEW_LINE","from sys import stdinn , m = map ( int , stdin . readline ( ) . split ( ) ) print ( max ( [ min ( list ( map ( int , stdin . readline ( ) . split ( ) ) ) ) for i in range ( n ) ] ) ) NEW_LINE","n , m = input ( ) . split ( ) n = int ( n ) m = int ( m ) c = [ [ 0 ] * m for i in range ( n ) ] cc = [ [ 0 ] * n for i in range ( m ) ] for i in range ( n ) : tmp_list = [ int ( each ) for each in input ( ) . split ( ) ] for j in range ( m ) : c [ i ] [ j ] = tmp_list [ j ] cc [ j ] [ i ] = tmp_list [ j ]   res = 0 for i in range ( n ) : res = max ( min ( c [ i ] ) , res ) print ( res ) NEW_LINE","try : n , m = map ( int , input ( ) . split ( ) ) c = [ ] z = [ ] for i in range ( n ) : x = list ( map ( int , input ( ) . split ( ) ) ) z . append ( min ( x ) ) c . append ( x ) print ( max ( z ) ) except : pass NEW_LINE","a , b = map ( int , input ( ) . split ( ) ) r = lambda : list ( map ( int , input ( ) . split ( ) ) ) arr = [ r ( ) for _ in range ( a ) ]   ans = 0 for i in arr : ans = max ( ans , min ( i ) )   print ( ans ) NEW_LINE"],"bleu":0.5893575324118547,"rouge_l":0.6873180588376315}
{"id":242,"predictions":["from sys import stdin , stdoutfrom os import pathrd = lambda : stdin . readline ( ) . strip ( ) wr = stdout . writeif ( path . exists ( ' input . txt ' ) ) : stdin = open ( \" input . txt \" , \" r \" ) import time NEW_LINE"],"references":["n = int ( input ( ) ) a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] solved = [ 0 for i in range ( 5 ) ] score = [ 0 for i in range ( 5 ) ] for i in range ( n ) : for j in range ( 5 ) : solved [ j ] += int ( a [ i ] [ j ] > - 1 ) for k in range ( 31 * n + 1 ) : for i in range ( 5 ) : tot = n + k cur = solved [ i ] if a [ 0 ] [ i ] > - 1 and a [ 1 ] [ i ] > - 1 and a [ 0 ] [ i ] > a [ 1 ] [ i ] : cur += k score [ i ] = 500 while score [ i ] < 3000 and 2 * cur <= tot : cur *= 2 ; score [ i ] += 500 res = [ 0 , 0 ] for j in range ( 2 ) : for i in range ( 5 ) : if a [ j ] [ i ] > - 1 : res [ j ] += score [ i ] \/ 250 * ( 250 - a [ j ] [ i ] ) if res [ 0 ] > res [ 1 ] : print ( k ) exit ( ) print ( \" - 1\" ) NEW_LINE","n = int ( input ( ) ) a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] solved = [ 0 ] * 5 score = [ 0 ] * 5 for i in range ( n ) : for j in range ( 5 ) : solved [ j ] += int ( a [ i ] [ j ] > - 1 ) for k in range ( 31 * n + 1 ) : for i in range ( 5 ) : tot = n + k cur = solved [ i ] cur += k * ( a [ 0 ] [ i ] > - 1 and a [ 1 ] [ i ] > - 1 and a [ 0 ] [ i ] > a [ 1 ] [ i ] ) score [ i ] = 500 while score [ i ] < 3000 and 2 * cur <= tot : cur *= 2 ; score [ i ] += 500 res = [ 0 , 0 ] for j in range ( 2 ) : for i in range ( 5 ) : res [ j ] += ( a [ j ] [ i ] > - 1 ) * score [ i ] \/ 250 * ( 250 - a [ j ] [ i ] ) if res [ 0 ] > res [ 1 ] : print ( k ) breakelse : print ( \" - 1\" ) NEW_LINE","def f ( v , x , n ) : if v < 0 : return 0 elif x << 1 > n : return int ( 500 * ( 1 - v \/ 250 ) ) elif x << 2 > n : return int ( 1000 * ( 1 - v \/ 250 ) ) elif x << 3 > n : return int ( 1500 * ( 1 - v \/ 250 ) ) elif x << 4 > n : return int ( 2000 * ( 1 - v \/ 250 ) ) elif x << 5 > n : return int ( 2500 * ( 1 - v \/ 250 ) ) else : return int ( 3000 * ( 1 - v \/ 250 ) )   n = int ( input ( ) ) a = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] c = [ sum ( _ [ i ] >= 0 for _ in a ) for i in range ( 5 ) ] ans = - 1 for i in range ( 10000 ) : p , q = 0 , 0 for j in range ( 5 ) : x , y = c [ j ] , n if a [ 0 ] [ j ] > a [ 1 ] [ j ] and a [ 1 ] [ j ] >= 0 : x += i p += f ( a [ 0 ] [ j ] , x , n + i ) q += f ( a [ 1 ] [ j ] , x , n + i ) if p > q : ans = i breakprint ( ans )           NEW_LINE"],"bleu":0.0017017237181364724,"rouge_l":0.09972466012734467}
{"id":243,"predictions":["import sys , os , ioimport math , bisect , operatorinf , mod = float ( ' inf ' ) , 10 ** 9 + 7 NEW_LINE"],"references":["import osimport sysfrom io import BytesIO , IOBase   BUFSIZE = 8192     class FastIO ( IOBase ) : newlines = 0   def __init__ ( self , file ) : self . _fd = file . fileno ( ) self . buffer = BytesIO ( ) self . writable = \" x \" in file . mode or \" r \" not in file . mode self . write = self . buffer . write if self . writable else None   def read ( self ) : while True : b = os . read ( self . _fd , max ( os . fstat ( self . _fd ) . st_size , BUFSIZE ) ) if not b : break ptr = self . buffer . tell ( ) self . buffer . seek ( 0 , 2 ) , self . buffer . write ( b ) , self . buffer . seek ( ptr ) self . newlines = 0 return self . buffer . read ( )   def readline ( self ) : while self . newlines == 0 : b = os . read ( self . _fd , max ( os . fstat ( self . _fd ) . st_size , BUFSIZE ) ) self . newlines = b . count ( b \" \\n \" ) + ( not b ) ptr = self . buffer . tell ( ) self . buffer . seek ( 0 , 2 ) , self . buffer . write ( b ) , self . buffer . seek ( ptr ) self . newlines -= 1 return self . buffer . readline ( )   def flush ( self ) : if self . writable : os . write ( self . _fd , self . buffer . getvalue ( ) ) self . buffer . truncate ( 0 ) , self . buffer . seek ( 0 )     class IOWrapper ( IOBase ) : def __init__ ( self , file ) : self . buffer = FastIO ( file ) self . flush = self . buffer . flush self . writable = self . buffer . writable self . write = lambda s : self . buffer . write ( s . encode ( \" ascii \" ) ) self . read = lambda : self . buffer . read ( ) . decode ( \" ascii \" ) self . readline = lambda : self . buffer . readline ( ) . decode ( \" ascii \" )     sys . stdin , sys . stdout = IOWrapper ( sys . stdin ) , IOWrapper ( sys . stdout ) input = lambda : sys . stdin . readline ( ) . rstrip ( \" \\n \" ) NEW_LINE","n = int ( input ( ) ) lst = list ( map ( int , input ( ) . split ( ) ) ) t = int ( input ( ) ) lst . sort ( ) res = 0 from bisect import bisectfor i , x in enumerate ( lst ) : j = bisect ( lst , x + t ) res = max ( res , j - i ) print ( res ) NEW_LINE","n = int ( input ( ) ) lst = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) t = int ( input ( ) ) ans = 1 for i in range ( len ( lst ) - 1 ) : temp = 1 k = i + 1 while k < len ( lst ) and lst [ k ] - lst [ i ] <= t : temp += 1 k += 1 if temp > ans : ans = tempprint ( ans ) NEW_LINE","n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) t = int ( input ( ) ) l . sort ( ) a = [ ] i = 0j = 0 while i < n : while j < n and l [ j ] - l [ i ] <= t : j += 1 a . append ( j - i ) i += 1 print ( max ( a ) ) NEW_LINE","class CodeforcesTask386BSolution : def __init__ ( self ) : self . result = ' ' self . n = 0 self . times = [ ] self . t = 0   def read_input ( self ) : self . n = int ( input ( ) ) self . times = [ int ( x ) for x in input ( ) . split ( \" ▁ \" ) ] self . t = int ( input ( ) )   def process_task ( self ) : result = 0   self . times . sort ( )   for start in set ( self . times ) : in_range = 0 for time in self . times : if start <= time <= start + self . t : in_range += 1 result = max ( result , in_range )   self . result = str ( result )   def get_result ( self ) : return self . result     if __name__ == \" _ _ main _ _ \" : Solution = CodeforcesTask386BSolution ( ) Solution . read_input ( ) Solution . process_task ( ) print ( Solution . get_result ( ) ) NEW_LINE"],"bleu":0.013483350835608589,"rouge_l":0.14972151420749552}
{"id":244,"predictions":["n = int ( input ( ) ) p = list ( map ( int , input ( ) . split ( ) ) ) dp = [ 0 ] * ( n + 1 ) dp [ 1 ] = 2 for i in range ( 2 , n + 1 ) : c = 0 for j in range ( p [ i - 1 ] , i ) : c += dp [ j ] dp [ i ] = c + 2 print ( sum ( dp ) % ( 10 ** 9 + 7 ) ) NEW_LINE"],"references":["import sys   from collections import defaultdict   POINTS_WIN = 3 POINTS_DRAW = 1 POINTS_LOSS = 0     def sort_order ( item : dict ) -> tuple : return - item [ \" points \" ] , - item [ \" score _ diff \" ] , - item [ \" score \" ]     def standings ( teams : list , games : list ) -> list : teams_data = { t : defaultdict ( int , { \" name \" : t } ) for t in teams } for lt , rt , ls , rs in games : teams_data [ lt ] [ \" score \" ] += ls teams_data [ rt ] [ \" score \" ] += rs   if ls == rs : teams_data [ lt ] [ \" points \" ] += POINTS_DRAW teams_data [ rt ] [ \" points \" ] += POINTS_DRAW elif ls < rs : teams_data [ lt ] [ \" points \" ] += POINTS_LOSS teams_data [ lt ] [ \" score _ diff \" ] -= rs - ls teams_data [ rt ] [ \" points \" ] += POINTS_WIN teams_data [ rt ] [ \" score _ diff \" ] += rs - ls else : teams_data [ lt ] [ \" points \" ] += POINTS_WIN teams_data [ lt ] [ \" score _ diff \" ] += ls - rs teams_data [ rt ] [ \" points \" ] += POINTS_LOSS teams_data [ rt ] [ \" score _ diff \" ] -= ls - rs   return list ( sorted ( teams_data . values ( ) , key = sort_order ) )     def parse_teams ( n : int ) -> list : teams = [ ] for i in range ( n ) : teams . append ( input ( ) ) return teams     def parse_games ( n : int ) -> list : games = [ ] for _ in range ( int ( n * ( n - 1 ) \/ 2 ) ) : line = sys . stdin . readline ( ) . strip ( ) teams , scores = line . split ( \" ▁ \" ) left_team , right_team = teams . split ( \" - \" ) left_score , right_score = map ( int , scores . split ( \" : \" ) ) games . append ( ( left_team , right_team , left_score , right_score ) )   return games     if __name__ == \" _ _ main _ _ \" : n = int ( input ( ) ) teams = parse_teams ( n ) games = parse_games ( n )   NEW_LINE","n = int ( input ( ) ) class Command : def __init__ ( self , name ) : self . name = name self . score = 0 self . z = 0 self . p = 0 def get_r ( self ) : return self . z - self . p arr = { } for i in range ( n ) : name = input ( ) arr [ name ] = Command ( name ) for i in range ( ( n * ( n - 1 ) ) \/\/ 2 ) : string = input ( ) first , second = string . split ( ) name1 , name2 = first . split ( ' - ' ) num1 , num2 = second . split ( \" : \" ) num1 , num2 = int ( num1 ) , int ( num2 ) if num1 > num2 : arr [ name1 ] . score += 3 elif num1 < num2 : arr [ name2 ] . score += 3 else : arr [ name1 ] . score += 1 arr [ name2 ] . score += 1 arr [ name1 ] . z += num1 arr [ name1 ] . p += num2 arr [ name2 ] . z += num2 arr [ name2 ] . p += num1arr = list ( arr . values ( ) ) for i in range ( len ( arr ) ) : for j in range ( len ( arr ) - 1 ) : if arr [ j ] . score < arr [ j + 1 ] . score : arr [ j ] , arr [ j + 1 ] = arr [ j + 1 ] , arr [ j ] elif arr [ j ] . score == arr [ j + 1 ] . score : if arr [ j ] . get_r ( ) < arr [ j + 1 ] . get_r ( ) : arr [ j ] , arr [ j + 1 ] = arr [ j + 1 ] , arr [ j ] elif arr [ j ] . get_r ( ) == arr [ j + 1 ] . get_r ( ) : if arr [ j ] . z < arr [ j + 1 ] . z : arr [ j ] , arr [ j + 1 ] = arr [ j + 1 ] , arr [ j ] ans = [ ] for i in range ( len ( arr ) \/\/ 2 ) : ans . append ( arr [ i ] . name ) ans . sort ( ) for i in ans : print ( i ) NEW_LINE","class Info : def __init__ ( self , newTeamName , newPoints , newGoalDiff , newScoredGoals ) : self . teamName = newTeamName self . points = newPoints self . goalDiff = newGoalDiff self . scoredGoals = newScoredGoals   def __str__ ( self ) : pattern = ' \\n * * * * * * * * * * * * * * * * * * * * * * * * * \\n ' pattern += f ' teamName : ▁ { self . teamName } ▁ \\n ' pattern += f ' points : ▁ { self . points } ▁ \\n ' pattern += f ' goalDiff : ▁ { self . goalDiff } ▁ \\n ' pattern += f ' scoredGoals : ▁ { self . scoredGoals } ▁ \\n ' pattern += ' * * * * * * * * * * * * * * * * * * * * * * * * * \\n ' return pattern   def __eq__ ( self , other ) : if isinstance ( other , Info ) : return self . teamName == other . teamName and   \\ self . points == other . points and   \\ self . goalDiff == other . goalDiff and   \\ self . scoredGoals == other . scoredGoals return False     NEW_LINE","class Info : def __init__ ( self , newTeamName , newPoints , newGoalDiff , newScoredGoals ) : self . teamName = newTeamName self . points = newPoints self . goalDiff = newGoalDiff self . scoredGoals = newScoredGoals   def __str__ ( self ) : temp = ' \\n * * * * * * * * * * * * * * \\n ' temp += f ' teamName : ▁ { self . teamName } ▁ \\n ' temp += f ' points : ▁ { self . points } ▁ \\n ' temp += f ' goalDiff : ▁ { self . goalDiff } ▁ \\n ' temp += f ' scoredGoals : ▁ { self . scoredGoals } ▁ \\n ' temp += ' * * * * * * * * * * * * * * \\n ' return temp     NEW_LINE"],"bleu":0.22768307035665286,"rouge_l":0.1939839432801585}
{"id":245,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) s = 0 for i in range ( n ) : s += ( a [ i ] - 1 ) * ( i + 1 ) print ( s \/\/ 2 ) NEW_LINE"],"references":["from math import log2   for t in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) )   d = dict ( )   for i in range ( len ( a ) ) : a [ i ] = int ( log2 ( a [ i ] ) )   NEW_LINE","import matht = int ( input ( ) ) NEW_LINE for z in range ( t ) : n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE counter = [ 0 ] * 30 NEW_LINE for i in range ( n ) : counter [ int ( math . log ( arr [ i ] , 2 ) ) ] += 1 NEW_LINE ans = 0 NEW_LINE for num in counter : if NEW_LINE num >= 2 : ans = ans + ( num * ( num - 1 ) ) \/\/ 2 NEW_LINE print ( ans )                                       NEW_LINE","from math import log2   for u in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEW_LINE x = [ int ( w ) for w in input ( ) . split ( ) ] NEW_LINE if ( n == 1 ) : NEW_LINE INDENT print ( 0 ) else : NEW_LINE d = { } NEW_LINE DEDENT for i in x : y = int ( log2 ( i ) ) NEW_LINE d [ y ] = d . get ( y , 0 ) + 1   ans = 0 NEW_LINE for i in d : if NEW_LINE INDENT ( d [ i ] > 1 ) : ans += ( d [ i ] * ( d [ i ] - 1 ) ) \/\/ 2 NEW_LINE DEDENT print ( ans ) NEW_LINE"],"bleu":0.5328166205321788,"rouge_l":0.6155568505965708}
{"id":246,"predictions":["import sys   NEW_LINE def main ( ) : _ , * l = map ( int , sys . stdin . read ( ) . strip ( ) . split ( ) ) NEW_LINE out = [ ] NEW_LINE for i in l : out . extend ( ( str ( i - 1 ) , ' ▁ ' . join ( map ( str , range ( 2 , i + 1 ) ) ) ) ) NEW_LINE return out NEW_LINE print ( * main ( ) , sep = ' \\n ' ) NEW_LINE"],"references":["t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT","cases = int ( input ( ) ) NEW_LINE while cases : NEW_LINE INDENT cases -= 1 NEW_LINE n = int ( input ( ) ) NEW_LINE print ( * list ( range ( n , 0 , - 1 ) ) ) NEW_LINE DEDENT","for s in [ * open ( 0 ) ] [ 1 : ] : print ( * range ( 1 , int ( s ) + 1 ) ) NEW_LINE","for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE print ( * list ( range ( 1 , n + 1 ) ) , sep = \" ▁ \" ) NEW_LINE DEDENT"],"bleu":0.20440059209532613,"rouge_l":0.4000485790624241}
{"id":247,"predictions":["n = int ( input ( ) ) s = input ( ) a = list ( map ( int , input ( ) . split ( ) ) ) t = 10 ** 10 for i in range ( n - 1 ) : if s [ i : i + 2 ] == ' RL ' : t = min ( t , ( a [ i + 2 ] - a [ i ] ) \/\/ 2 ) if t == 10 ** 10 : print ( - 1 ) else : print ( t ) NEW_LINE"],"references":["class Stack ( ) : def __init__ ( self ) : self . stack = [ ] self . len = 0   def top ( self ) : assert not self . empty ( ) return self . stack [ self . len - 1 ]   def pop ( self ) : assert not self . empty ( ) self . len -= 1 return self . stack . pop ( )   def push ( self , x ) : self . len += 1 self . stack . append ( x )   def empty ( self ) : return self . len == 0   def calc ( n , pos ) : st = Stack ( ) last_pos = - 1 ans = 0 for i in range ( n ) : if pos [ i ] == \" R \" : if st . empty ( ) : ans += i - last_pos - 1 st . push ( i ) elif pos [ i ] == \" L \" : if st . empty ( ) : last_pos = i else : left_R = st . pop ( ) ; ans += ( i - left_R + 1 ) % 2 last_pos = i if st . empty ( ) : ans += n - last_pos - 1 return ans     n = int ( input ( ) ) pos = str ( input ( ) ) print ( calc ( n , pos ) ) NEW_LINE","n = int ( input ( ) )   domino = input ( )   currLetter = None   prev = 0   res = 0   for i in range ( n ) : if domino [ i ] == \" L \" : count = i - prev + 1 if currLetter == \" R \" : if count % 2 != 0 : count -= 1 res += count   prev = i currLetter = \" L \" if domino [ i ] == \" R \" : if currLetter == \" R \" : res += ( i - prev + 1 )   print ( res ) else : currLetter = \" R \"   prev = i   if currLetter == \" R \" : res += ( n - prev )     print ( n - res ) NEW_LINE","n = int ( input ( ) ) s = str ( input ( ) ) count , p = 0 , 0 while p < n : if s [ p ] == ' R ' or s [ p ] == ' L ' : sp = p + 1 while sp < n : if s [ sp ] != ' R ' and s [ sp ] != ' L ' : sp += 1 else : break if sp == n : break size = sp - p - 1 if s [ p ] == ' R ' and s [ sp ] == ' L ' : count += size % 2 else : count += size p = sp else : p += 1 for j in range ( n ) : if s [ j ] == ' R ' or s [ j ] == ' L ' : breakif s [ j ] != ' L ' : count += jtemp = 0 limit = jfor j in range ( n - 1 , limit - 1 , - 1 ) : if s [ j ] == ' R ' or s [ j ] == ' L ' : break temp += 1 if s [ j ] != ' R ' : count += tempprint ( count ) NEW_LINE","n = int ( input ( ) ) l = list ( input ( ) ) s = 0 i = 0 for i , c in enumerate ( l ) : if c == \" . \" : continue elif c == \" L \" : for j in range ( i + 1 ) : l [ j ] = \" L \" else : breaki = 0 while i < n : if l [ i ] == \" . \" : s += 1 elif l [ i ] == \" R \" : j = i + 1 while j < n and l [ j ] == \" . \" : j += 1 if j != n and ( j - i ) % 2 == 0 : s += 1 i = j i += 1 print ( s ) NEW_LINE"],"bleu":0.2534219170770547,"rouge_l":0.3782467018887026}
{"id":248,"predictions":["import sys , os , ioimport math , bisect , operatorinf , mod = float ( ' inf ' ) , 10 ** 9 + 7 NEW_LINE"],"references":["from functools import cmp_to_key           def calc_lcp ( s , sa ) :   rank = [ 0 for _ in range ( len ( s ) ) ]   for i in range ( len ( s ) ) :   rank [ sa [ i ] ] = i   lcp = [ 0 for _ in range ( len ( s ) - 1 ) ]   h = 0   for i in range ( len ( s ) ) :   if rank [ i ] < len ( s ) - 1 :   while max ( i , sa [ rank [ i ] + 1 ] ) + h < len ( s ) and s [ i + h ] == s [ sa [ rank [ i ] + 1 ] + h ] :   h += 1   lcp [ rank [ i ] ] = h   if h > 0 :   h -= 1   return lcp , rank       def suffix_array ( s ) :   sa = [ i for i in range ( len ( s ) ) ]   rank = [ ord ( s [ i ] ) for i in range ( len ( s ) ) ]   k = 1   while k < len ( s ) :   key = [ 0 for _ in range ( len ( s ) ) ]   base = max ( rank ) + 2   for i in range ( len ( s ) ) :   key [ i ] = rank [ i ] * base + ( rank [ i + k ] + 1 if i + k < len ( s ) else 0 )   sa . sort ( key = ( lambda i : key [ i ] ) )       rank [ sa [ 0 ] ] = 0   for i in range ( 1 , len ( s ) ) :   rank [ sa [ i ] ] = rank [ sa [ i - 1 ] ] if key [ sa [ i - 1 ] ] == key [ sa [ i ] ] else i   k *= 2   NEW_LINE"],"bleu":3.1425033832551794e-7,"rouge_l":0.03676913803496082}
{"id":249,"predictions":["def insertion_sort ( l ) : for i in range ( len ( l ) ) : for j in ( range ( i ) ) : k = i - j if l [ k ] >= l [ k - 1 ] : l [ k - 1 ] , l [ k ] = l [ k ] , l [ k - 1 ] else : break return l       def selection_sort ( l ) : for i in range ( len ( l ) ) : min_ind = i min_val = l [ i ] for j in range ( i , len ( l ) ) : if min_val > l [ j ] : min_val = l [ j ] min_ind = j l [ i ] , l [ min_ind ] = l [ min_ind ] , l [ i ] return l     def bubble_sort ( l ) : for i in range ( len ( l ) - 1 ) : for j in range ( len ( l ) - 1 - i ) : if l [ j ] > l [ j + 1 ] : l [ j ] , l [ j + 1 ] = l [ j + 1 ] , l [ j ] return l     NEW_LINE"],"references":["from sys import stdin     for _ in range ( int ( stdin . readline ( ) ) ) : n = int ( stdin . readline ( ) ) a = list ( map ( int , stdin . readline ( ) . split ( ) ) ) res = False total = 0 for i in a : if i < 2048 : total += i elif i == 2048 : res = True break if total >= 2048 : res = True   print ( ' YES ' if res else ' NO ' ) NEW_LINE","qtd = int ( input ( ) ) for i in range ( qtd ) : q1 = int ( input ( ) ) lista = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] l1 = input ( ) . split ( ) for j in range ( len ( l1 ) ) : l1 [ j ] = int ( l1 [ j ] ) if ( l1 [ j ] == 2048 ) : lista [ 11 ] += 1 break elif ( l1 [ j ] == 1024 ) : lista [ 10 ] += 1 elif ( l1 [ j ] == 512 ) : lista [ 9 ] += 1 elif ( l1 [ j ] == 256 ) : lista [ 8 ] += 1 elif ( l1 [ j ] == 128 ) : lista [ 7 ] += 1 elif ( l1 [ j ] == 64 ) : lista [ 6 ] += 1 elif ( l1 [ j ] == 32 ) : lista [ 5 ] += 1 elif ( l1 [ j ] == 16 ) : lista [ 4 ] += 1 elif ( l1 [ j ] == 8 ) : lista [ 3 ] += 1 elif ( l1 [ j ] == 4 ) : lista [ 2 ] += 1 elif ( l1 [ j ] == 2 ) : lista [ 1 ] += 1 elif ( l1 [ j ] == 1 ) : lista [ 0 ] += 1 if ( lista [ 11 ] >= 1 ) : print ( \" YES \" ) else : for k in range ( len ( lista ) - 1 ) : lista [ k + 1 ] = int ( lista [ k ] * ( 2 ** k ) \/ ( 2 ** ( k + 1 ) ) ) + lista [ k + 1 ] if ( lista [ 11 ] >= 1 ) : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE","for t in range ( int ( input ( ) ) ) : n = input ( ) l = filter ( lambda x : x <= 2048 , map ( int , input ( ) . split ( ) ) ) print ( ' YES ' if sum ( l ) >= 2048 else ' NO ' ) NEW_LINE","''' a = [ int ( i ) ▁ for ▁ i ▁ in ▁ input ( ) . split ( ) ] x = a [ 0 ] y = a [ 1 ] z = a [ 2 ] if ▁ y = = x ▁ and ▁ z = = 0 : ▁ ▁ ▁ ▁ print ( '0 ' ) elif ▁ x > y + z : ▁ ▁ ▁ ▁ print ( ' + ' ) elif ▁ y > x + z : ▁ ▁ ▁ ▁ print ( ' - ' ) else : ▁ ▁ ▁ ▁ print ( ' ? ' ) n = int ( input ( ) ) z = [ int ( i ) ▁ for ▁ i ▁ in ▁ input ( ) . split ( ) ] x = [ ] d = 0v = ' ' for ▁ i ▁ in ▁ range ( n ) : ▁ ▁ ▁ ▁ c = 0 ▁ ▁ ▁ ▁ e = 0 ▁ ▁ ▁ ▁ for ▁ f ▁ in ▁ range ( len ( z ) ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ z [ f ] > c ▁ and ▁ f + 1 ▁ not ▁ in ▁ x : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ c = z [ f ] ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ e = f + 1 ▁ ▁ ▁ ▁ d + = ( i * c ) + 1 ▁ ▁ ▁ ▁ x . append ( e ) print ( d ) for ▁ i ▁ in ▁ x : ▁ ▁ ▁ ▁ v + = str ( i ) ▁ ▁ ▁ ▁ v + = ' ▁ ' print ( v )  f = int ( input ( ) ) g = [ int ( i ) ▁ for ▁ i ▁ in ▁ input ( ) . split ( ) ] for ▁ i ▁ in ▁ range ( len ( g ) -1 ) : ▁ ▁ ▁ ▁ for ▁ f ▁ in ▁ range ( len ( g ) -1 - i ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ g [ f ] > g [ f + 1 ] : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ g [ f ] , g [ f + 1 ] = g [ f + 1 ] , g [ f ] if ▁ g [ 0 ] * g [ 1 ] > g [ -2 ] * g [ -3 ] ▁ and ▁ g [ -1 ] > 0 : ▁ ▁ ▁ ▁ print ( g [ -1 ] * g [ 0 ] * g [ 1 ] ) else : ▁ ▁ ▁ ▁ print ( g [ -1 ] * g [ -2 ] * g [ -3 ] ) ''' for u in range ( int ( input ( ) ) ) : z = int ( input ( ) ) y = [ int ( f ) for f in input ( ) . split ( ) ] y . sort ( ) d = 0 for i in y : d += i if d < 2048 : print ( ' No ' ) continue if 2048 in y : print ( ' yes ' ) continue for x in range ( z + 1 ) : if 2048 in y : print ( ' yes ' ) break for i in range ( len ( y ) - 1 ) : if y [ i ] == y [ i + 1 ] : y [ i + 1 ] = y [ i ] * 2 y . pop ( i ) if i > len ( y ) - 3 : break y . sort ( ) else : print ( ' no ' ) NEW_LINE","for u in range ( int ( input ( ) ) ) : z = int ( input ( ) ) y = [ int ( f ) for f in input ( ) . split ( ) ] y . sort ( ) d = 0 for i in y : d += i if d < 2048 : print ( ' No ' ) continue if 2048 in y : print ( ' yes ' ) continue for x in range ( z + 1 ) : if 2048 in y : print ( ' yes ' ) break for i in range ( len ( y ) - 1 ) : if i > len ( y ) - 2 : break if y [ i ] == y [ i + 1 ] : y [ i + 1 ] = y [ i ] * 2 y . pop ( i ) y . sort ( ) else : print ( ' no ' ) NEW_LINE"],"bleu":0.26504214778119634,"rouge_l":0.47197306568415703}
{"id":250,"predictions":["m = input ( ) a = list ( map ( int , input ( ) . split ( ) ) ) a . reverse ( ) dic = { } ; i = 0 for m in a : if m not in dic : dic [ m ] = i i += 1 print ( max ( dic , key = dic . get ) ) NEW_LINE"],"references":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) k = 0 pas = 0 a = a [ : : - 1 ] for i in set ( a ) : s = a . count ( i ) if s > k : pas = i k = s elif s == k : if a . index ( i ) > a . index ( pas ) : pas = i k = a . count ( i ) print ( pas ) NEW_LINE","a = int ( input ( ) ) b = list ( map ( int , input ( ) . split ( ) ) ) maxi = 0 index = 0 likes = dict ( ) for i in b : if i not in likes : likes [ i ] = 1 if likes [ i ] > maxi : maxi = likes [ i ] index = i else : likes [ i ] += 1 if likes [ i ] > maxi : maxi = likes [ i ] index = iprint ( index ) NEW_LINE","a = int ( input ( ) ) b = list ( map ( int , input ( ) . split ( ) ) ) maxi = 0 index = 0 likes = dict ( ) for i in b : if i not in likes : likes [ i ] = 0 likes [ i ] += 1 if likes [ i ] > maxi : maxi = likes [ i ] index = iprint ( index ) NEW_LINE","from collections import Countern = int ( input ( ) ) aa = list ( map ( int , input ( ) . split ( ) ) ) c = Counter ( ) best = 0 lead = 1 for a in aa : c [ a ] += 1 if c [ a ] > best : best = c [ a ] lead = a   print ( lead )       NEW_LINE","n = int ( input ( ) ) d1 , a , d2 = { } , [ ] , { } l = list ( map ( int , input ( ) . split ( ) ) ) for i in l : if i in d1 : d1 [ i ] += 1 else : d1 [ i ] = 1 for i in d1 : a . append ( d1 [ i ] ) m = max ( a ) for i in l : if i in d2 : d2 [ i ] += 1 else : d2 [ i ] = 1 if d2 [ i ] == m : print ( i ) break NEW_LINE"],"bleu":0.39856800081061305,"rouge_l":0.5214960953555281}
{"id":251,"predictions":["\"\"\" Handle : ▁ shashank - sharmaCreated ▁ at : ▁ 12-03-2021T17:16:49 \"\"\"   import sysinput = sys . stdin . readline   NEW_LINE"],"references":["for _ in range ( int ( input ( ) ) ) : d = int ( input ( ) ) NEW_LINE def prime ( a ) : for NEW_LINE i in range ( 2 , int ( a ** 0.5 ) + 1 ) : NEW_LINE if a % i == 0 : return False NEW_LINE return True NEW_LINE k = 1 NEW_LINE b = k + d NEW_LINE while not prime ( b ) : b += 1 NEW_LINE k *= b NEW_LINE p = k + d NEW_LINE while not prime ( p ) : p += 1 NEW_LINE print ( k * p ) NEW_LINE","import mathdef NEW_LINE isprime ( n ) : b = 1 NEW_LINE i = 2 NEW_LINE while ( i * i <= math . floor ( n ) ) : if NEW_LINE INDENT ( n % i == 0 ) : b = 0 NEW_LINE DEDENT break ; else : i += 1 NEW_LINE return b   t = int ( input ( ) ) NEW_LINE for i in range ( 0 , t ) : d = int ( input ( ) ) NEW_LINE j = 1 + d NEW_LINE p1 = 1 NEW_LINE p2 = 1 NEW_LINE while True : if NEW_LINE INDENT ( isprime ( j ) == 1 ) : p1 = j NEW_LINE DEDENT break else : j += 1 NEW_LINE k = p1 + d NEW_LINE while True : if NEW_LINE INDENT ( isprime ( k ) == 1 ) : p2 = k NEW_LINE DEDENT break else : k += 1 NEW_LINE print ( p1 * p2 ) NEW_LINE print ( )     NEW_LINE","def isPrime ( n ) : if NEW_LINE ( n <= 1 ) : NEW_LINE return False NEW_LINE if ( n <= 3 ) : return True NEW_LINE if ( n % 2 == 0 or n % 3 == 0 ) : return False NEW_LINE i = 5 NEW_LINE while ( i * i <= n ) : if NEW_LINE ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE return False NEW_LINE i = i + 6 NEW_LINE return Truet = int ( input ( ) ) NEW_LINE for a in range ( t ) : d = int ( input ( ) ) NEW_LINE b1 = 1 NEW_LINE b2 = b1 + d NEW_LINE while ( isPrime ( b2 ) == False ) : b2 += 1 NEW_LINE b3 = b2 + d NEW_LINE while ( isPrime ( b3 ) == False ) : b3 += 1 NEW_LINE print ( b2 * b3 ) NEW_LINE","def prime ( m ) : for NEW_LINE i in range ( 2 , m ) : NEW_LINE if m % i == 0 : return False NEW_LINE return True NEW_LINE t = int ( input ( ) ) NEW_LINE for z in range ( t ) : d = int ( input ( ) ) NEW_LINE x = 1 NEW_LINE ans = 1 NEW_LINE for i in range ( x + d , 10 ** 9 ) : if NEW_LINE prime ( i ) : x = i NEW_LINE ans *= x NEW_LINE break NEW_LINE for i in range ( x + d , 10 ** 9 ) : if NEW_LINE prime ( i ) : x = i NEW_LINE ans *= x NEW_LINE break NEW_LINE print ( ans ) NEW_LINE"],"bleu":0.0014520691170724887,"rouge_l":0.05642923219241443}
{"id":252,"predictions":["import sys , os , ioimport math , bisect , operatorinf , mod = float ( ' inf ' ) , 10 ** 9 + 7 NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) s = sum ( l )   def solve ( ) : if s < n : return [ - 1 ] for i in range ( m ) : if l [ i ] > n - i : return [ - 1 ]   ov = s - n idx = 1 sln = [ ]   for i in range ( m ) : if ov > 0 and idx != 1 : d = min ( ov , l [ i - 1 ] - 1 ) idx -= d ov -= d sln . append ( idx ) idx += l [ i ]   return sln   print ( * solve ( ) ) NEW_LINE","def main ( ) : n , m = readIntArr ( ) l = readIntArr ( ) NEW_LINE"],"bleu":0.06541868941754436,"rouge_l":0.2850800327141021}
{"id":253,"predictions":["a , b , c , d = map ( int , input ( ) . split ( ) ) misha = max ( 3 * a \/ 10 , a - ( a \/ 250 ) * c ) vasya = max ( 3 * b \/ 10 , b - ( a \/ 250 ) * d ) vasya = min ( 3 * b \/ 10 , b - ( b \/ 250 ) * d ) print ( vasya ) NEW_LINE"],"references":["n = int ( input ( ) ) mn1 , mx1 = map ( int , input ( ) . split ( ) ) mn2 , mx2 = map ( int , input ( ) . split ( ) ) mn3 , mx3 = map ( int , input ( ) . split ( ) )   fd = n - mn2 - mn3if fd > mx1 : fd = mx1n -= fdsd = n - mn3if sd > mx2 : sd = mx2td = n - sdprint ( fd , sd , td ) NEW_LINE","def f ( n , l ) : l1 , r1 = l [ 0 ] l2 , r2 = l [ 1 ] l3 , r3 = l [ 2 ] c1 = min ( r1 , n - l2 - l3 ) c2 = min ( r2 , n - c1 - l3 ) c3 = n - c1 - c2 return [ c1 , c2 , c3 ] n = int ( input ( ) ) l = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( 3 ) ] print ( * f ( n , l ) ) NEW_LINE","n = int ( input ( ) ) a1 , b1 = map ( int , input ( ) . split ( ) ) a2 , b2 = map ( int , input ( ) . split ( ) ) a3 , b3 = map ( int , input ( ) . split ( ) ) ans1 = min ( n - ( a2 + a3 ) , b1 ) ans2 = min ( n - ( ans1 + a3 ) , b2 ) ans3 = n - ( ans1 + ans2 ) print ( ans1 , ans2 , ans3 ) NEW_LINE","n = int ( input ( ) ) a1 , b1 = map ( int , input ( ) . split ( ) ) a2 , b2 = map ( int , input ( ) . split ( ) ) a3 , b3 = map ( int , input ( ) . split ( ) ) ans1 = min ( n - ( a2 + a3 ) , b1 ) ans2 = min ( n - ( ans1 + a3 ) , b2 ) ans3 = n - ( ans1 + ans2 ) print ( ans1 , ans2 , ans3 )   NEW_LINE"],"bleu":0.20791069087421513,"rouge_l":0.4103846817319303}
{"id":254,"predictions":["from collections import Counterdef func ( ) : n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) k = { } m = 0 for i in l : if i in k : del k [ i ] else : k [ i ] = 1 if len ( k ) > m : m = len ( k ) print ( m ) t = 1 NEW_LINE"],"references":["n , k = map ( int , input ( ) . split ( ) ) s = input ( ) d = { }   val = 0 ; i = 0 while i < n : count = 1 ch = s [ i ] i += 1 while i < n : if s [ i ] == s [ i - 1 ] : count += 1 i += 1 else : break d [ ch ] = d . get ( ch , 0 ) + ( count \/\/ k )   print ( max ( d . values ( ) ) ) NEW_LINE","def abhi ( g ) :     l = 0 r = 0 u = 0 while True : if l == n or r == n : break else : if t [ l ] == g and t [ r ] == g :   if l - r + 1 == x : u += 1 r = l + 1 l += 1 elif l - r + 1 < x : l += 1 else : r = l + 1 l += 1                     return u                                           n , x = map ( int , input ( ) . split ( ) )     t = input ( ) ans = 0     for j in range ( 1 , 27 ) : u = chr ( 96 + j ) ans = max ( abhi ( u ) , ans )       print ( ans ) NEW_LINE","from sys import * ; from math import * ; from collections import * ; from bisect import * INF = maxsizedef get_ints ( ) : return map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) def get_array ( ) : return list ( map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) ) def input ( ) : return stdin . readline ( ) . strip ( ) mod = 1000000007   from string import * n , k = get_ints ( ) s = input ( ) ans = 0 for letter in ascii_lowercase : curr = 0 cnt = 0 for i in range ( n ) : if s [ i ] == letter : curr += 1 if curr == k : cnt += 1 curr = 0 else : curr = 0 ans = max ( ans , cnt ) print ( ans ) NEW_LINE","n , k = map ( int , input ( ) . split ( ) ) s = str ( input ( ) ) count = 0 dict = { } for i in range ( 0 , n ) : if n == 1 and k == 1 : count = n \/\/ k break if s [ i ] == s [ i - 1 ] : count += 1 else : if s [ i - 1 ] in dict . keys ( ) : dict [ s [ i - 1 ] ] += count \/\/ k else : dict [ s [ i - 1 ] ] = count \/\/ k count = 1 if count >= k : if s [ n - 1 ] in dict . keys ( ) : dict [ s [ n - 1 ] ] += count \/\/ k else : dict [ s [ n - 1 ] ] = count \/\/ kif max ( dict . values ( ) ) > - 1 : print ( max ( dict . values ( ) ) ) NEW_LINE"],"bleu":0.338719696913303,"rouge_l":0.4413659225271332}
{"id":255,"predictions":["k , n , s , p = map ( int , input ( ) . split ( ) )   paper_person = ( n + s - 1 ) \/\/ s   total_needed = paper_person * k   ans = ( total_needed + p - 1 ) \/\/ p   print ( ans )     NEW_LINE"],"references":["from collections import defaultdict as dcdef mlt ( ) : return map ( int , input ( ) . split ( ) ) def arp ( ) : return [ * mlt ( ) ]     s = input ( ) mp = dc ( lambda : 0 ) for n in s : mp [ ord ( n ) - 97 ] += 1 cntr = 0 for n in s : if mp [ ord ( n ) - 97 ] % 2 : cntr += 1   if cntr <= 1 : print ( ' First ' ) else : s1 = [ ' Second ' , ' First ' ] print ( s1 [ len ( s ) % 2 ] ) NEW_LINE","def answer ( s ) : ss = set ( s ) num_odds = 0 for char in ss : ccnt = s . count ( char ) if ccnt % 2 == 1 : NEW_LINE","a = input ( ) dict = { } for i in a : try : dict [ i ] += 1 except : dict [ i ] = 1   t = 0   for i in dict . values ( ) : if i % 2 == 1 : t += 1   print ( \" First \" if t == 0 else \" First \" if t % 2 == 1 else \" Second \" ) NEW_LINE","def solution ( ) : st = input ( ) arr = [ 0 ] * 26   for i in st : arr [ ord ( i ) - ord ( ' a ' ) ] += 1   odds = 0 for i in arr : if i % 2 == 1 : odds += 1 \t \t   tot = odds   if tot != 0 and tot % 2 == 0 : print ( ' Second ' ) else : print ( ' First ' )     return     solution ( ) NEW_LINE","s = input ( ) l = [ 0 ] * 26   for i in s : l [ ord ( i ) % 97 ] += 1   c = 0 for i in l : if i % 2 == 1 : c += 1   if ( c % 2 == 1 or c == 0 ) : print ( \" First \" ) else : print ( \" Second \" ) NEW_LINE"],"bleu":0.30320877290968307,"rouge_l":0.3596615490638999}
{"id":256,"predictions":["n = int ( input ( ) ) for i in range ( 1 , 35 ) : if 2 ** i - 1 >= n : print ( i ) ; break NEW_LINE"],"references":["def dp ( n ) : if n < 0 : return 0 if not n : return 1 return 2 * dp ( n - 2 ) print ( dp ( int ( input ( ) ) ) ) NEW_LINE","n = int ( input ( ) ) if n % 2 == 1 : print ( 0 ) else : print ( 2 ** ( n \/\/ 2 ) ) NEW_LINE","n = int ( input ( ) ) print ( [ 2 ** ( n \/\/ 2 ) , 0 ] [ n & 1 ] ) NEW_LINE","def solver ( n ) : if n % 2 == 1 : print ( 0 ) else : print ( 2 ** ( n \/\/ 2 ) )     n = int ( input ( ) ) solver ( n ) NEW_LINE"],"bleu":0.3466414872931028,"rouge_l":0.48751248751248744}
{"id":257,"predictions":["import sys , os , ioimport math , bisect , operatorinf , mod = float ( ' inf ' ) , 10 ** 9 + 7 NEW_LINE"],"references":["def add ( vertex , neighbour ) : if vertex in graph : graph [ vertex ] . append ( neighbour ) else : graph [ vertex ] = [ neighbour ] if neighbour in graph : NEW_LINE"],"bleu":0.03933183744890979,"rouge_l":0.1194322075379344}
{"id":258,"predictions":["N = int ( input ( ) ) print ( N , * range ( 1 , N ) ) NEW_LINE"],"references":["n = int ( input ( ) ) NEW_LINE for i in range ( n , 0 , - 1 ) : if NEW_LINE n % i == 0 : n = i NEW_LINE print ( i , end = ' ▁ ' ) NEW_LINE","n = int ( input ( ) ) NEW_LINE s = nl = [ n ] NEW_LINE i = s - 1 NEW_LINE while ( s > 0 ) : if NEW_LINE i == 0 : NEW_LINE break NEW_LINE if s % i == 0 : l . append ( i ) NEW_LINE s = i NEW_LINE i = s - 1 NEW_LINE if i == 0 : NEW_LINE INDENT break else : NEW_LINE i -= 1 NEW_LINE DEDENT print ( * l ) NEW_LINE","n = int ( input ( ) ) NEW_LINE x = [ ] NEW_LINE i = nwhile NEW_LINE i > 0 : NEW_LINE if n % i == 0 : x . append ( i ) NEW_LINE n = i NEW_LINE i = i - 1 NEW_LINE for i in x : print ( i , end = \" ▁ \" ) NEW_LINE","import sysimport NEW_LINE mathclass NEW_LINE DictList ( dict ) : NEW_LINE def __setitem__ ( self , key , value ) : try NEW_LINE INDENT : NEW_LINE DEDENT","import sysdef NEW_LINE fmax ( n ) : NEW_LINE if n == 1 : print ( 1 ) NEW_LINE return 0 NEW_LINE i = 2 NEW_LINE print ( n ) NEW_LINE while ( i < 1000001 ) : if NEW_LINE n == 1 : NEW_LINE break NEW_LINE if n % i == 0 : n = n \/\/ i NEW_LINE i = 2 NEW_LINE print ( n ) NEW_LINE continue NEW_LINE i = i + 1 NEW_LINE return 0 NEW_LINE if __name__ == ' _ _ main _ _ ' : input = sys . stdin . read ( ) NEW_LINE data = list ( map ( int , input . split ( ) ) ) NEW_LINE n = data [ 0 ] NEW_LINE fmax ( n ) NEW_LINE"],"bleu":0.3469845935355766,"rouge_l":0.3696969696969697}
{"id":259,"predictions":["a , b , c , d = map ( int , input ( ) . split ( ) ) print ( a * d ) NEW_LINE"],"references":["import sysimport math   n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) i = 1 ans = [ a [ 0 ] ] while i < n : if math . gcd ( ans [ - 1 ] , a [ i ] ) == 1 : ans . append ( a [ i ] ) i += 1 else : ans . append ( 1 ) print ( len ( ans ) - n ) print ( * ans ) NEW_LINE","from math import gcd   n = int ( input ( ) ) a = [ int ( i ) for i in input ( ) . split ( ) ] ans = [ a [ 0 ] ]   for i in range ( n - 1 ) : if gcd ( a [ i ] , a [ i + 1 ] ) != 1 : ans . append ( 1 ) ans . append ( a [ i + 1 ] )   print ( len ( ans ) - len ( a ) ) print ( * ans ) NEW_LINE","import math   def printArr ( arr ) : for i in arr : print ( i , end = \" ▁ \" ) def proA ( arr ) : ans = [ ] i = 0 c = 0 while ( i < len ( arr ) ) : if ( i == len ( arr ) - 1 ) : ans . append ( arr [ - 1 ] ) break if ( math . gcd ( arr [ i ] , arr [ i + 1 ] ) != 1 ) : c += 1 ans . append ( arr [ i ] ) ans . append ( 1 ) else : ans . append ( arr [ i ] ) i += 1 print ( c ) printArr ( ans ) n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) proA ( arr ) NEW_LINE","n = int ( input ( ) ) A = list ( map ( int , input ( ) . split ( ) ) ) import mathk = 0 ans = [ ] import mathfor i in range ( n - 1 ) : if math . gcd ( A [ i ] , A [ i + 1 ] ) != 1 : ans . append ( A [ i ] ) ans . append ( 1 ) k += 1 else : ans . append ( A [ i ] ) else : ans . append ( A [ n - 1 ] ) print ( k ) print ( * ans ) NEW_LINE"],"bleu":0.04168927953650507,"rouge_l":0.2734135409294645}
{"id":260,"predictions":["n = input ( ) m = input ( ) l1 = len ( n ) l2 = len ( m ) if l1 != l2 : print ( ' NO ' ) else : for i in range ( l1 ) : if l1 [ i ] != l2 [ l1 [ i ] : print ( ' NO ' ) break else : print ( \" YES \" ) NEW_LINE"],"references":["t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : n , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE s = list ( s ) NEW_LINE sum = 1 NEW_LINE j = 0 NEW_LINE for i in range ( n ) : if NEW_LINE s [ i ] == ' W ' : j = i NEW_LINE break NEW_LINE l = j NEW_LINE j = j + 1 NEW_LINE lst = [ ] NEW_LINE while j < n : if NEW_LINE s [ l ] == s [ j ] and j - l == 1 : j += 1 NEW_LINE l += 1 elif s [ l ] == s [ j ] and j - l > 1 : lst . append ( [ j - l - 1 , l + 1 ] ) NEW_LINE l = j NEW_LINE j += 1 else : j += 1 NEW_LINE","def main ( ) : for NEW_LINE _ in range ( int ( input ( ) ) ) : n , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE if k >= s . count ( ' L ' ) : NEW_LINE INDENT print ( 2 * n - 1 ) elif ' W ' not in s : NEW_LINE print ( max ( min ( n , k ) * 2 - 1 , 0 ) ) else : NEW_LINE diff , ans , ind = [ ] , s . count ( ' W ' ) , s . index ( ' W ' )   for i in range ( ind + 1 , n ) : if NEW_LINE DEDENT s [ i ] == ' W ' : diff . append ( i - ind - 1 ) NEW_LINE ind = i NEW_LINE diff . sort ( )   for value in diff : if NEW_LINE value <= k : ans += 2 * value + 1 NEW_LINE k -= value NEW_LINE if k > 0 : ans += 2 * k NEW_LINE print ( ans ) NEW_LINE main ( ) NEW_LINE","for _ in range ( int ( input ( ) ) ) : n , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE lnth = sorted ( map ( len , s . strip ( ' L ' ) . split ( ' W ' ) ) , reverse = True ) NEW_LINE m = len ( lnth ) + k - 1 NEW_LINE while lnth and lnth [ - 1 ] <= k : k -= lnth . pop ( ) NEW_LINE print ( ( 2 * min ( n , m ) - len ( lnth ) or 1 ) - 1 )         NEW_LINE"],"bleu":0.12526097699158337,"rouge_l":0.3085644514215943}
{"id":261,"predictions":["t = int ( input ( ) ) for i in range ( t ) : a , b = map ( int , input ( ) . split ( ) ) if a - 1 > b : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"references":["t = int ( input ( ) ) for _ in range ( t ) : n = int ( input ( ) ) s = input ( ) if n == 2 : if int ( s [ 0 ] ) >= int ( s [ 1 ] ) : print ( \" NO \" ) else : print ( \" YES \" ) print ( 2 ) print ( s [ 0 ] , s [ 1 ] ) else : print ( \" YES \" ) print ( 2 ) print ( s [ 0 ] , s [ 1 : ] ) NEW_LINE","cases = int ( input ( ) ) while cases : cases -= 1 num = int ( input ( ) ) s = input ( )   if num == 2 and int ( s [ 0 ] ) >= int ( s [ 1 ] ) : print ( \" NO \" ) else : print ( \" YES \" ) print ( 2 ) print ( s [ 0 ] , s [ 1 : ] ) NEW_LINE","t = int ( input ( ) ) for _ in range ( int ( t ) ) : n = int ( input ( ) ) s = input ( ) a = int ( s [ 0 ] ) b = int ( s [ 1 : ] ) if a < b : print ( \" YES \" ) print ( 2 ) print ( a , b ) else : print ( \" NO \" ) NEW_LINE","r = lambda : list ( map ( int , input ( ) . split ( ) ) ) t = int ( input ( ) ) for _ in range ( t ) : n = int ( input ( ) )   s = input ( )   if int ( s [ 0 ] ) < int ( s [ 1 : ] ) : print ( \" YES \" ) print ( 2 ) print ( s [ 0 ] , s [ 1 : ] )   else : print ( \" NO \" )   NEW_LINE"],"bleu":0.48015369353642673,"rouge_l":0.6005625879043601}
{"id":262,"predictions":["num = int ( input ( ) ) pup = input ( )   lst = [ ] for i in range ( num ) : lst . append ( pup [ i ] )   lst . sort ( )   if num > 1 : for i in range ( num ) : if i < num - 1 : if lst [ i ] == lst [ i + 1 ] : print ( \" YES \" ) break   if i == ( num - 1 ) : print ( \" NO \" )   elif num == 1 : print ( \" YES \" ) NEW_LINE"],"references":["n = int ( input ( ) ) s = input ( ) t = s . upper ( ) if len ( set ( t ) ) == 26 : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE","n = int ( input ( ) ) s = input ( )   s1 = set ( s . upper ( ) ) m = len ( s1 ) if m == 26 : print ( \" YES \" ) else : print ( \" NO \" )   NEW_LINE","a = int ( input ( ) ) t = input ( ) b = t . lower ( ) c = [ \" a \" , \" b \" , \" c \" , \" d \" , \" e \" , \" f \" , \" g \" , \" h \" , \" i \" , \" j \" , \" k \" , \" l \" , \" m \" , \" n \" , \" o \" , \" p \" , \" q \" , \" r \" , \" s \" , \" t \" , \" u \" , \" v \" , \" w \" , \" x \" , \" y \" , \" z \" ] for i in range ( len ( b ) ) : if b [ i ] in c : c . remove ( b [ i ] ) if c == [ ] : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE","n = int ( input ( ) ) s = input ( ) l = [ ] for i in s : k = i . lower ( ) if k not in l : l . append ( k ) if ( len ( l ) == 26 ) : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE","n = int ( input ( ) ) str = input ( ) def pangram ( str ) : alphabet = ' abcdefghijklmnopqrstuvwxyz ' for char in alphabet : if char not in str . lower ( ) : return False return Trueif ( pangram ( str ) == True ) : print ( ' Yes ' ) else : print ( ' No ' ) NEW_LINE"],"bleu":0.357029738095423,"rouge_l":0.5747760592629328}
{"id":263,"predictions":["n , m = map ( int , input ( ) . split ( ) ) arr = [ x for x in range ( 0 , n + 1 ) ] d = 1 for i in range ( m ) : a , b = map ( int , input ( ) . split ( ) ) a , b = arr [ a ] , arr [ a ] while a != arr [ a ] : a = arr [ a ] while b != arr [ b ] : b = arr [ b ] if a != b : arr [ b ] = a d *= 2 print ( d ) NEW_LINE"],"references":["a = input ( ) . rjust ( 10 ** 6 , \"0\" ) b = input ( ) . rjust ( 10 ** 6 , \"0\" ) if a > b : print ( \" > \" ) elif a < b : print ( \" < \" ) elif a == b : print ( \" = \" ) NEW_LINE","aa = input ( ) bb = input ( )   cta = 0 ctb = 0 start = Falsefor let in aa : if let == \"0\" : cta += 1 if let != \"0\" : breakfor let in bb : if let == \"0\" : ctb += 1 if let != \"0\" : breakstart = False   a = aa [ cta : ] b = bb [ ctb : ]       if len ( a ) > len ( b ) : print ( \" > \" ) elif len ( a ) < len ( b ) : print ( \" < \" ) elif a == b : print ( \" = \" ) else : if a > b : print ( \" > \" ) else : print ( \" < \" ) NEW_LINE","a = input ( ) b = input ( )   a = a . lstrip ( '0' ) b = b . lstrip ( '0' )   l = max ( len ( a ) , len ( b ) ) a = a . rjust ( l , \"0\" ) b = b . rjust ( l , \"0\" )   NEW_LINE","import mathfrom math import gcd , floor , sqrt , logdef iin ( ) : return int ( input ( ) ) def sin ( ) : return input ( ) . strip ( ) def listin ( ) : return list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) def liststr ( ) : return list ( map ( str , input ( ) . strip ( ) . split ( ) ) ) def ceill ( x ) : return int ( x ) if ( x == int ( x ) ) else int ( x ) + 1 def ceilldiv ( x , d ) : return x \/\/ d if ( x % d == 0 ) else x \/\/ d + 1 def LCM ( a , b ) : return ( a * b ) \/\/ gcd ( a , b )     def solve ( ) : a = sin ( ) b = sin ( ) lena = len ( a ) lenb = len ( b ) if lena < lenb : a = \"0\" * ( lenb - lena ) + a elif lenb < lena : b = \"0\" * ( lena - lenb ) + b if a == b : print ( \" = \" ) return if a < b : print ( \" < \" ) return if a > b : print ( \" > \" ) return t = 1 NEW_LINE","a = input ( ) b = input ( ) a = a . lstrip ( '0' ) b = b . lstrip ( '0' ) if len ( a ) != len ( b ) : print ( ' < ' if len ( a ) < len ( b ) else ' > ' ) exit ( 0 ) for i in range ( len ( a ) ) : if a [ i ] != b [ i ] : print ( ' < ' if a [ i ] < b [ i ] else ' > ' ) exit ( 0 ) print ( ' = ' ) NEW_LINE"],"bleu":0.3272075276775276,"rouge_l":0.4583103176892131}
{"id":264,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = { input ( ) for _ in range ( n ) } b = { input ( ) for _ in range ( m ) } u = len ( a . intersection ( b ) ) print ( \" NO \" ) if m - u + u \/\/ 2 >= n - u + ( u + 1 ) \/\/ 2 else print ( \" YES \" ) NEW_LINE"],"references":["n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) c = 1 ans = 0 for i in range ( n - 1 ) : if 2 * l [ i ] >= l [ i + 1 ] : c = c + 1 else : ans = max ( c , ans ) c = 1 ans = max ( ans , c ) print ( ans ) NEW_LINE","n , c , m = input ( ) , 1 , 1 a = [ int ( x ) for x in input ( ) . split ( ) ] for i in range ( len ( a ) - 1 ) : if a [ i ] * 2 < a [ i + 1 ] : c , m = 1 , max ( m , c ) else : c += 1 print ( max ( m , c ) ) NEW_LINE","n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) dp = [ 0 ] * ndp [ 0 ] = 1 for i in range ( 1 , n ) : if 2 * l [ i - 1 ] >= l [ i ] : dp [ i ] = dp [ i - 1 ] + 1 else : dp [ i ] = 1 print ( max ( dp ) ) NEW_LINE"],"bleu":0.27520035532830184,"rouge_l":0.41270437887615113}
{"id":265,"predictions":["n , m , k , t = map ( int , input ( ) . split ( \" ▁ \" ) ) NEW_LINE"],"references":["'''   ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Online ▁ Python ▁ Compiler . ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Code , ▁ Compile , ▁ Run ▁ and ▁ Debug ▁ python ▁ program ▁ online . Write ▁ your ▁ code ▁ in ▁ this ▁ editor ▁ and ▁ press ▁ \" Run \" ▁ button ▁ to ▁ execute ▁ it .   '''   n , a , b = map ( int , input ( ) . split ( ) ) mnn = - 1 for i in range ( 1 , n ) : k = n - i p = a \/\/ i q = b \/\/ k mn = min ( p , q ) NEW_LINE","def bs ( l , h ) : while l < h : m = ( l + h + 1 ) \/\/ 2 if gf ( m ) : l = m else : h = m - 1 return l   def gf ( x ) : return a \/\/ x + b \/\/ x >= n   n , a , b = map ( int , input ( ) . split ( ) ) print ( bs ( 0 , min ( a , b ) ) ) NEW_LINE","n , a , b = map ( int , input ( ) . split ( ) ) print ( max ( min ( a \/\/ i , b \/\/ ( n - i ) ) for i in range ( 1 , n ) ) ) NEW_LINE"],"bleu":0.21883746789167474,"rouge_l":0.4519174898314933}
{"id":266,"predictions":["t = int ( input ( ) ) NEW_LINE for i in range ( t ) : n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l1 = set ( ) NEW_LINE for j in l : NEW_LINE"],"references":["s = input ( ) n = len ( s ) sett = { }   for i in range ( n ) : if s [ i ] not in sett : sett [ s [ i ] ] = [ ] sett [ s [ i ] ] . append ( s [ i + 1 : ] + s [ : i ] ) ans = 0   NEW_LINE","def func ( a ) : b = [ 0 ] * 26 for i in range ( len ( a ) ) : b [ ord ( a [ i ] ) - ord ( \" a \" ) ] += 1 c = 0 for i in b : if i == 1 : c = c + 1 return c       s = input ( ) n = len ( s ) a = { } for i in range ( n ) : a [ s [ i ] ] = [ ] for i in range ( n ) : a [ s [ i ] ] . append ( i ) c = 0 for i in a : if len ( a [ i ] ) == 1 : c = c + 1 else : e = [ ] for j in range ( n ) : b = [ ] d = 0 for k in a [ i ] : b . append ( ( s [ ( k + j ) % n ] ) ) d = d + func ( b ) e . append ( d ) c = c + max ( e ) print ( c \/ n ) NEW_LINE","s = input ( ) def uniq ( iii ) : tmp = 0 for jj in range ( 1 , len ( s ) ) : bb = { } for ii in iii : bb . setdefault ( s [ ii - jj ] , [ ] ) . append ( ii ) tmp = max ( tmp , sum ( 1 for vvv in bb . values ( ) if len ( vvv ) == 1 ) ) return tmpaa = { } for ii , ss in enumerate ( s ) : aa . setdefault ( ss , [ ] ) . append ( ii ) ans = 0 for iii in aa . values ( ) : ans += uniq ( iii ) print ( ans \/ len ( s ) ) NEW_LINE"],"bleu":0.15465381877270098,"rouge_l":0.3224761255115962}
{"id":267,"predictions":["from collections import defaultdict , deque , Counterfrom sys import stdin , stdoutfrom heapq import heappush , heappopimport mathimport ioimport osimport mathimport bisect   NEW_LINE"],"references":["a = list ( input ( ) ) x = a . index ( \" ^ \" ) l = 0 r = 0 for i , j in enumerate ( a ) : if i < x and j != \" = \" : l += int ( j ) * ( x - i ) if i > x and j != \" = \" : r += int ( j ) * ( i - x ) if l > r : print ( \" left \" ) elif r > l : print ( \" right \" ) else : print ( \" balance \" ) NEW_LINE","s = input ( ) . split ( \" ^ \" ) l = s [ 0 ] r = s [ 1 ]   l = l [ : : - 1 ] l_v = 0 r_v = 0   for index in range ( 0 , len ( l ) ) : if l [ index ] != \" = \" : l_v += int ( l [ index ] ) * ( index + 1 )   for index in range ( 0 , len ( r ) ) : if r [ index ] != \" = \" : r_v += int ( r [ index ] ) * ( index + 1 )     if l_v == r_v : print ( \" balance \" ) elif l_v > r_v : print ( \" left \" ) else : print ( \" right \" ) NEW_LINE","s = input ( ) piv = s . index ( ' ^ ' ) sum = 0   for i in range ( len ( s ) ) : if s [ i ] . isdigit ( ) : sum += ( i - piv ) * int ( s [ i ] )   if sum == 0 : print ( ' balance ' ) elif sum > 0 : print ( ' right ' ) else : print ( ' left ' ) NEW_LINE","from sys import stdin , stdoutfrom math import floor , gcd , fabs , factorial , fmod , sqrt , inf , logfrom collections import defaultdict as dd , dequefrom heapq import merge , heapify , heappop , heappush , nsmallestfrom bisect import bisect_left as bl , bisect_right as br , bisect mod = pow ( 10 , 9 ) + 7 mod2 = 998244353 def inp ( ) : return stdin . readline ( ) . strip ( ) def iinp ( ) : return int ( inp ( ) ) def out ( var , end = \" \\n \" ) : stdout . write ( str ( var ) + \" \\n \" ) def outa ( * var , end = \" \\n \" ) : stdout . write ( ' ▁ ' . join ( map ( str , var ) ) + end ) def lmp ( ) : return list ( mp ( ) ) def mp ( ) : return map ( int , inp ( ) . split ( ) ) def smp ( ) : return map ( str , inp ( ) . split ( ) ) def l1d ( n , val = 0 ) : return [ val for i in range ( n ) ] def l2d ( n , m , val = 0 ) : return [ l1d ( m , val ) for j in range ( n ) ] def remadd ( x , y ) : return 1 if x % y else 0 def ceil ( a , b ) : return ( a + b - 1 ) \/\/ b def isprime ( x ) : if x <= 1 : return False if x in ( 2 , 3 ) : return True if x % 2 == 0 : return False for i in range ( 3 , int ( sqrt ( x ) ) + 1 , 2 ) : if x % i == 0 : return False return True s = inp ( ) ind = s . index ( ' ^ ' ) a1 , a2 = 0 , 0 for i in range ( ind - 1 , - 1 , - 1 ) : if s [ i ] == ' = ' : continue a1 += ( ind - i ) * int ( s [ i ] ) for i in range ( ind + 1 , len ( s ) ) : if s [ i ] == ' = ' : continue a2 += ( i - ind ) * int ( s [ i ] ) if a1 > a2 : print ( ' left ' ) elif a2 > a1 : print ( ' right ' ) else : print ( ' balance ' ) NEW_LINE","def solve ( s ) : f_right = 0 f_left = 0 is_left = True e = s . find ( ' ^ ' ) for i , c in enumerate ( s ) : if c == ' ^ ' : is_left = False continue if c == ' = ' : continue if is_left : f_left += ( e - i ) * int ( c ) else : f_right += ( i - e ) * int ( c )   if f_left > f_right : return ' left ' if f_right > f_left : return ' right ' return ' balance '             def main ( ) : NEW_LINE"],"bleu":0.023550184746018738,"rouge_l":0.043229197425146165}
{"id":268,"predictions":["import mathn , d = map ( int , input ( ) . strip ( ) . split ( ' ▁ ' ) ) NEW_LINE"],"references":["t = int ( input ( ) ) for _ in range ( t ) : a , b , c = map ( int , input ( ) . split ( ) ) if c < a : print ( c ) else : if b % c == 0 : print ( b + c ) else : print ( ( c + b ) - b % c ) NEW_LINE","def solve ( ) : l , r , d = map ( int , input ( ) . split ( ) ) if d < l or d > r : print ( d ) else : print ( ( int ( r \/ d ) + 1 ) * d )   q = int ( input ( ) ) for _ in range ( q ) : solve ( ) NEW_LINE","for i in range ( int ( input ( ) ) ) : l , r , d = map ( int , input ( ) . split ( ) ) ans = False p = 0 if l > d : ans = True print ( d ) else : if ( r + 1 ) % d == 0 : print ( r + 1 ) else : print ( ( r \/\/ d + 1 ) * d ) NEW_LINE","def find ( l , r , d ) : if d < l : return d elif d > r : return d else : return ( ( r \/\/ d ) + 1 ) * d   t = int ( input ( ) ) lst = [ ] for i in range ( 0 , t ) : l , r , d = input ( ) . split ( ) ele = find ( int ( l ) , int ( r ) , int ( d ) ) lst . append ( ele )   for i in range ( 0 , t ) : print ( lst [ i ] ) NEW_LINE","n = int ( input ( ) ) x = [ ] for i in range ( n ) : st = input ( ) . split ( ) for i in range ( len ( st ) ) : st [ i ] = int ( st [ i ] ) x . append ( st ) a = [ ] for index , i in enumerate ( x ) : if x [ index ] [ 2 ] >= x [ index ] [ 0 ] : a . append ( x [ index ] [ 1 ] \/\/ x [ index ] [ 2 ] * x [ index ] [ 2 ] + x [ index ] [ 2 ] ) else : a . append ( x [ index ] [ 2 ] )                   for i in a : print ( i ) NEW_LINE"],"bleu":0.08587612975685846,"rouge_l":0.31529340224992397}
{"id":269,"predictions":["x , y , z = map ( int , input ( ) . split ( ) ) print ( ( x + y ) \/\/ z ) NEW_LINE"],"references":["l , r , a = map ( int , input ( ) . split ( ) ) while a > 0 : if l < r : l = l + 1 else : r = r + 1 a = a - 1 print ( min ( l , r ) * 2 ) NEW_LINE","import sys   def main ( ) : l , r , a = map ( int , sys . stdin . read ( ) . strip ( ) . split ( ) ) t = min ( abs ( l - r ) , a ) a = ( a - t ) \/\/ 2 return 2 * ( min ( l , r ) + t + a ) print ( main ( ) ) NEW_LINE","l , r , a = map ( int , input ( ) . split ( ) ) NEW_LINE","l , r , a = map ( int , input ( ) . split ( ) )   if l == r : team = a \/\/ 2 l += team r += team print ( ( l + r - 1 ) if ( l + r ) % 2 != 0 else l + r ) else : if l < r : l += a if l <= r : print ( l * 2 ) else : r += ( l - r ) \/\/ 2 print ( r * 2 )   else : r += a if r <= l : print ( r * 2 ) else : l += ( r - l ) \/\/ 2 print ( l * 2 ) NEW_LINE","l , r , ambidextors = map ( int , input ( ) . split ( ) )   base_team_size = 2 * min ( l , r ) extra_onehanded = max ( max ( l , r ) - base_team_size \/\/ 2 , 0 )   if extra_onehanded : more_pairs = min ( extra_onehanded , ambidextors ) base_team_size += 2 * more_pairs ambidextors -= more_pairs extra_onehanded -= more_pairs   max_team_size = base_team_size + ambidextors - ( ambidextors % 2 )       print ( max_team_size ) NEW_LINE"],"bleu":0.5639503296872997,"rouge_l":0.8213083565051954}
{"id":270,"predictions":["import itertools NEW_LINE l = list ( map ( int , ( input ( ) . split ( ) ) ) ) NEW_LINE sm = [ ] NEW_LINE for p in itertools . combinations ( l , 3 ) : NEW_LINE INDENT sm . append ( sum ( p ) ) NEW_LINE DEDENT print ( sm . index ( sm [ 2 : ] ) ) NEW_LINE"],"references":["from statistics import moden = int ( input ( ) ) list_of_numbers = [ int ( x ) for x in input ( ) . split ( ) ] m = mode ( list_of_numbers ) print ( n - list_of_numbers . count ( m ) ) NEW_LINE","n = int ( input ( ) ) secuencia = input ( ) . split ( )   c1 = 0 c2 = 0 c3 = 0   for i in range ( n ) : if secuencia [ i ] == '1' : c1 = c1 + 1 elif secuencia [ i ] == '2' : c2 = c2 + 1 else : c3 = c3 + 1 maximo = max ( c1 , c2 , c3 ) rpta = c1 + c2 + c3 - maximoprint ( rpta ) NEW_LINE","from collections import Counterl = [ ] n = int ( input ( ) ) c = Counter ( list ( map ( int , input ( ) . split ( ) ) ) ) for key , value in c . items ( ) : l . append ( value ) if len ( l ) == 1 : print ( 0 ) elif len ( l ) == 2 : print ( min ( l [ 0 ] , l [ 1 ] ) ) else : print ( min ( l [ 0 ] + l [ 1 ] , l [ 0 ] + l [ 2 ] , l [ 1 ] + l [ 2 ] ) )             NEW_LINE","n = int ( input ( ) ) a = [ int ( j ) for j in input ( ) . split ( ) ] a . sort ( ) one , two , three = 0 , 0 , 0 for i in a : if i == 1 : one = one + 1 elif i == 2 : two = two + 1 elif i == 3 : three = three + 1 print ( n - max ( one , two , three ) ) NEW_LINE","n , num1 , num2 , num3 = int ( input ( ) ) , 0 , 0 , 0   for item in [ int ( item ) for item in input ( ) . split ( ' ▁ ' ) ] : if item == 1 : num1 += 1 elif item == 2 : num2 += 1 else : num3 += 1   if num1 < num2 : t = num1 num1 = num2 num2 = tif num1 < num3 : t = num1 num1 = num3 num3 = t   print ( num2 + num3 ) NEW_LINE"],"bleu":0.36115383587639277,"rouge_l":0.5513938978148206}
{"id":271,"predictions":["st = lambda : map ( int , input ( ) . split ( ) ) n = int ( input ( ) ) d = list ( map ( int , input ( ) . split ( ) ) ) s = sum ( d [ : s ] ) c = 0 for i in range ( n ) : s += d [ i ] if s >= n : print ( c + 1 ) c = 0   NEW_LINE"],"references":["def main ( ) : petya_score = 0 vigen_score = 0 petya_time = 0 vigen_time = 0 n , c = map ( int , input ( ) . split ( ) ) task_price = list ( map ( int , input ( ) . split ( ) ) ) task_time = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( 0 , n ) : NEW_LINE","n , c = map ( int , input ( ) . split ( ) ) price = [ int ( i ) for i in input ( ) . split ( ) ] times = [ int ( i ) for i in input ( ) . split ( ) ] time = 0 NEW_LINE","n , c = map ( int , input ( ) . split ( ) ) p = list ( map ( int , input ( ) . split ( ) ) ) t = list ( map ( int , input ( ) . split ( ) ) )   lim = 0 rad = 0 time = 0 for i in range ( n ) : time += t [ i ] point = max ( 0 , p [ i ] - c * time ) lim += pointtime = 0 t = t [ : : - 1 ] p = p [ : : - 1 ] for i in range ( n ) : time += t [ i ] point = max ( 0 , p [ i ] - c * time ) rad += point   if rad == lim : print ( \" Tie \" ) elif lim > rad : print ( \" Limak \" ) else : print ( \" Radewoosh \" ) NEW_LINE"],"bleu":0.5400768772300089,"rouge_l":0.6816671700392632}
{"id":272,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) temp = max ( a ) if len ( set ( a ) ) == 1 and a [ 0 ] == 1 : print ( * a [ : - 1 ] , 2 ) else : a [ a . index ( temp ) ] = 1 a . sort ( ) print ( * a [ : : - 1 ] , sep = \" \" ) NEW_LINE"],"references":["n = int ( input ( ) ) x = FalseA = [ int ( i ) for i in input ( ) . split ( ) ] for i in range ( n - 2 ) : x1 , x2 = min ( A [ i ] , A [ i + 1 ] ) , max ( A [ i ] , A [ i + 1 ] ) for j in range ( i + 1 , n - 1 ) : X1 , X2 = min ( A [ j ] , A [ j + 1 ] ) , max ( A [ j ] , A [ j + 1 ] ) if ( x1 < X1 and X1 < x2 and x2 < X2 ) : x = True elif ( X1 < x1 and X2 > x1 and X2 < x2 ) : x = Trueif ( x ) : print ( \" yes \" ) else : print ( \" no \" ) NEW_LINE","n = int ( input ( ) ) a = [ * map ( int , input ( ) . split ( ) ) ] b = [ ] for i in range ( n - 1 ) : b . append ( [ min ( a [ i ] , a [ i + 1 ] ) , max ( a [ i ] , a [ i + 1 ] ) ] ) for i in range ( n - 1 ) : for j in range ( n - 1 ) : if i == j : continue if b [ i ] [ 0 ] < b [ j ] [ 0 ] < b [ i ] [ 1 ] < b [ j ] [ 1 ] or b [ i ] [ 0 ] < b [ j ] [ 1 ] < b [ i ] [ 1 ] < b [ j ] [ 0 ] : print ( ' yes ' ) exit ( 0 ) print ( ' no ' ) NEW_LINE","n = int ( input ( ) )   arr = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n - 1 ) : for j in range ( i + 1 , n - 1 ) : a = min ( arr [ i ] , arr [ i + 1 ] ) b = max ( arr [ i ] , arr [ i + 1 ] ) c = min ( arr [ j ] , arr [ j + 1 ] ) d = max ( arr [ j ] , arr [ j + 1 ] ) if a < c < b < d or c < a < d < b : print ( \" yes \" ) exit ( ) print ( ' no ' ) NEW_LINE","n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) )   for x in range ( len ( arr ) - 1 ) : x1 , x2 = ( arr [ x ] , arr [ x + 1 ] ) if x1 > x2 : x1 , x2 = x2 , x1 for y in range ( x + 2 , len ( arr ) - 1 ) : x3 , x4 = ( arr [ y ] , arr [ y + 1 ] ) if x3 > x4 : x3 , x4 = x4 , x3 if x1 < x3 < x2 < x4 or x3 < x1 < x4 < x2 : print ( \" yes \" ) exit ( ) print ( \" no \" ) NEW_LINE"],"bleu":0.26208244901891176,"rouge_l":0.3965158606344254}
{"id":273,"predictions":["n = int ( input ( ) ) li = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n - 1 ) : print ( li [ i ] + li [ i + 1 ] , end = ' ▁ ' ) print ( li [ n - 1 ] )   NEW_LINE"],"references":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) R1 , R2 = map ( int , input ( ) . split ( ) ) print ( sum ( a [ R1 - 1 : R2 - 1 ] ) ) NEW_LINE","def main_function ( ) : n = int ( input ( ) ) d = [ int ( i ) for i in input ( ) . split ( \" ▁ \" ) ] a , b = [ int ( i ) for i in input ( ) . split ( \" ▁ \" ) ] sum = 0 a , b = a - 1 , b - 1 for i in range ( a , b ) : sum += d [ i ] return sum       print ( main_function ( ) ) NEW_LINE","n = input ( ) x = list ( map ( int , input ( ) . split ( ) ) ) a , b = map ( int , input ( ) . split ( ) ) print ( sum ( x [ a - 1 : b - 1 : 1 ] ) ) NEW_LINE","b = 0 w = int ( input ( ) ) maxyear = 0 n = list ( map ( int , input ( ) . split ( ) ) ) [ : w ] a , b = map ( int , input ( ) . split ( ) ) d = ( b - 1 ) for j in range ( ( a - 1 ) , d ) : maxyear += n [ j ] print ( maxyear ) NEW_LINE"],"bleu":0.5408472712703744,"rouge_l":0.5945732349841939}
{"id":274,"predictions":["n = int ( input ( ) ) A = list ( map ( int , input ( ) . split ( ) ) ) t = A [ 0 ] i = 0 while t > n : i += 1 i %= 7 t += A [ i ] print ( i ) NEW_LINE"],"references":["n = int ( input ( ) ) mx = n \/\/ 7 * 2 + min ( n % 7 , 2 ) mn = n \/\/ 7 * 2 + max ( n % 7 - 5 , 0 )   print ( mn , mx )     NEW_LINE","n = int ( input ( ) ) o = 2 * ( n \/\/ 7 ) b = 0 if n % 7 > 1 : b = 2 elif n % 7 == 1 : b = 1 m = 0 if n % 7 == 6 : m = 1 print ( o + m , o + b ) NEW_LINE","n = int ( input ( ) )   print ( 2 * ( n \/\/ 7 ) + ( 1 if n % 7 == 6 else 0 ) , 2 * ( n \/\/ 7 ) + ( n % 7 if n % 7 < 2 else 2 ) ) NEW_LINE","n = int ( input ( ) ) c = ( n \/\/ 7 ) * 2 r = n % 7 if r == 0 : print ( c , c ) elif r == 1 : print ( c , c + 1 ) elif r >= 2 and r < 6 : print ( c , c + 2 ) else : print ( c + 1 , c + 2 ) NEW_LINE","T_ON = 0 DEBUG_ON = 0 MOD = 998244353     def solve ( ) : n = read_int ( ) q , r = divmod ( n , 7 ) MIN = q * 2 + max ( r - 5 , 0 ) MAX = q * 2 + min ( r , 2 ) print ( MIN , MAX )     def main ( ) : T = read_int ( ) if T_ON else 1 for i in range ( T ) : solve ( )     def debug ( * xargs ) : if DEBUG_ON : print ( * xargs )     from collections import * import math     NEW_LINE"],"bleu":0.21270024173913488,"rouge_l":0.3761654667768205}
{"id":275,"predictions":["print ( \" YES \" ) for i in range ( 4 ) : print ( input ( ) ) NEW_LINE"],"references":["tk = input ( ) m = tk [ 0 ] n = tk [ 1 ] flag = 0 inp2 = list ( map ( str , input ( ) . split ( ) ) )   for st in inp2 : if st [ 0 ] == m : print ( \" YES \" ) flag = 1 break elif st [ 1 ] == n : print ( \" YES \" ) flag = 1 break     if flag == 0 : print ( \" NO \" )                                   NEW_LINE","s = input ( ) l = list ( map ( str , input ( ) . split ( ) ) ) x = s [ 0 ] y = s [ 1 ] for i in range ( len ( l ) ) : if ( l [ i ] [ 0 ] == x ) or ( l [ i ] [ 1 ] == y ) : print ( \" YES \" ) breakelse : print ( \" NO \" ) NEW_LINE","s = input ( ) x = list ( map ( str , input ( ) . split ( ) ) ) d = ' ' . join ( x ) c = 0 for i in s : if i in d : print ( \" YES \" ) break else : c += 1 if c == 2 : print ( \" NO \" ) NEW_LINE","s = input ( ) l = list ( map ( str , input ( ) . split ( ) ) ) k = ' ' . join ( map ( str , l ) ) c = 0 if s [ 0 ] in k or s [ 1 ] in k : c = c + 1 if c >= 1 : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.06955750034134496,"rouge_l":0.2525879917184265}
{"id":276,"predictions":["import sys , os , ioimport math , bisect , operatorinf , mod = float ( ' inf ' ) , 10 ** 9 + 7 NEW_LINE"],"references":["def main ( ) : a = b = 1 for _ in range ( int ( input ( ) ) ) : s = input ( ) if s in ( \" UL \" , \" DR \" ) : a += 1 elif s in ( \" UR \" , \" DL \" ) : b += 1 elif s == \" ULDR \" : a += 1 b += 1 print ( a * b )     if __name__ == ' _ _ main _ _ ' : main ( ) NEW_LINE","n = int ( input ( ) ) r = 1 ; c = 1 for i in range ( n ) : s = input ( ) if ( len ( s ) == 4 ) : r += 1 ; c += 1 elif ( s == \" UL \" or s == \" DR \" ) : r += 1 else : c += 1 print ( r * c ) NEW_LINE"],"bleu":0.011056629587978904,"rouge_l":0.10336480271120795}
{"id":277,"predictions":["def main ( ) : t = int ( input ( ) ) for _ in range ( t ) : n , k = map ( int , input ( ) . split ( ) ) a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) b = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True ) for i in range ( k ) : if a [ i ] >= b [ i ] : break a [ i ] = b [ i ] print ( sum ( a ) )     if __name__ == ' _ _ main _ _ ' : main ( ) NEW_LINE"],"references":["import sysfrom os import pathif ( path . exists ( ' input . txt ' ) and path . exists ( ' output . txt ' ) ) : sys . stdout = open ( ' output . txt ' , ' w ' ) sys . stdin = open ( ' input . txt ' , ' r ' )   NEW_LINE","for _ in range ( int ( input ( ) ) ) : n , x = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) ans = 0 k = 0 for i in range ( 1 , n + x + 1 ) : if i not in l : ans += 1 if ans == x : break for j in range ( i + 1 , n + x + 1 ) : if j in l : k += 1 else : break print ( i + k ) NEW_LINE","  t = int ( input ( ) )   for _ in range ( t ) : n , x = tuple ( map ( int , input ( ) . split ( ) ) ) a = list ( map ( int , input ( ) . split ( ) ) )   dp = [ 0 ] * 101 for i in a : dp [ i ] = 1   sm = 0 i = 1 while i < len ( dp ) and x > 0 : if dp [ i ] == 0 : x -= 1 i += 1   if x > 0 : i -= 1 i += x else : while i < len ( dp ) and dp [ i ] == 1 : i += 1 i -= 1 print ( i )   NEW_LINE","cases = int ( input ( ) ) while cases : cases -= 1 a , b = map ( int , input ( ) . split ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) ans = 0 for i in range ( 1 , 1000 ) : if i in arr : ans += 1 continue else : if b > 0 : ans += 1 b -= 1 else : break print ( ans )   NEW_LINE"],"bleu":0.47799932985270227,"rouge_l":0.5771973079229694}
{"id":278,"predictions":["def main ( ) : t = int ( input ( ) ) allans = [ ] for _ in range ( t ) : n = int ( input ( ) ) allans . append ( sum ( [ int ( i ) for i in input ( ) . split ( ) ] ) ) NEW_LINE"],"references":["import io , osinput = io . BytesIO ( os . read ( 0 , os . fstat ( 0 ) . st_size ) ) . readlinefrom collections import defaultdict , dequedef bfs ( node ) : vis [ node ] = 1 q = deque ( [ node ] ) while q : cur = q . popleft ( ) dict1 = { } for j in edge [ cur ] : if vis [ j ] == 0 : vis [ j ] = 1 q . append ( j ) if topic [ j - 1 ] == topic [ cur - 1 ] : return False if topic [ j - 1 ] < topic [ cur - 1 ] : dict1 [ topic [ j - 1 ] ] = 1 b = len ( dict1 . keys ( ) ) if b != topic [ cur - 1 ] - 1 : return False return Truen , m = list ( map ( int , input ( ) . split ( ) ) ) edge = defaultdict ( list ) for i in range ( m ) : u , v = list ( map ( int , input ( ) . split ( ) ) ) edge [ u ] . append ( v ) edge [ v ] . append ( u ) topic = list ( map ( int , input ( ) . split ( ) ) ) vis = [ 0 ] * ( n + 1 ) s = 0 for i in range ( 1 , n + 1 ) : if vis [ i ] == 0 : temp = bfs ( i ) if temp == False : s += 1 breakif s == 1 : print ( - 1 ) else : ans = [ ] for i in range ( n ) : ans . append ( [ topic [ i ] , i + 1 ] ) ans . sort ( key = lambda x : x [ 0 ] , reverse = False ) num = [ ] for i in range ( n ) : num . append ( ans [ i ] [ 1 ] ) print ( \" ▁ \" . join ( str ( x ) for x in num ) ) NEW_LINE","import sysI = lambda : list ( map ( int , input ( ) . split ( ) ) ) input = sys . stdin . buffer . readlinen , m = I ( ) g = [ [ ] for i in range ( n ) ] for i in range ( m ) : x , y = I ( ) ; x -= 1 ; y -= 1 g [ x ] . append ( y ) g [ y ] . append ( x ) col = I ( ) arr = list ( range ( n ) ) arr . sort ( key = lambda x : col [ x ] ) ch = [ 1 ] * nans = [ ] f = 1 for i in arr : t = col [ i ] if t == ch [ i ] : for j in g [ i ] : if ch [ j ] == t : ch [ j ] += 1 ans . append ( i + 1 ) else : f = 0 breakif f : print ( * ans ) else : print ( - 1 ) NEW_LINE","import sysr = sys . stdin . buffer . readlinen , m = map ( int , r ( ) . split ( ) ) network = [ [ ] for _ in range ( n ) ] for _ in range ( m ) : a , b = map ( int , r ( ) . split ( ) ) network [ a - 1 ] . append ( b - 1 ) network [ b - 1 ] . append ( a - 1 ) lst = list ( map ( int , r ( ) . split ( ) ) ) arr = list ( range ( n ) ) arr . sort ( key = lambda x : lst [ x ] ) ret = [ 1 ] * nres = [ ] for i in arr : t = lst [ i ] if t == ret [ i ] : for j in network [ i ] : if ret [ j ] == t : ret [ j ] += 1 res . append ( i + 1 ) else : print ( - 1 ) exit ( 0 ) print ( * res ) NEW_LINE"],"bleu":0.039650100588932286,"rouge_l":0.27473935253073783}
{"id":279,"predictions":["t = int ( input ( ) )   while t > 0 : t -= 1 s = input ( ) if '0' not in s or '1' not in s : print ( s ) else : s1 = \"01\" * len ( s ) print ( s1 ) NEW_LINE"],"references":["import sys , functools , collections , bisect , math , NEW_LINE INDENT heapqinput = sys . stdin . readline NEW_LINE DEDENT","for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE print ( n \/\/ 2 - max ( s . count ( '10' ) , s . count ( '01' ) ) ) NEW_LINE","t = int ( input ( ) ) NEW_LINE ans = [ ] NEW_LINE for i in range ( t ) : n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE to = 0 NEW_LINE ti = 0 NEW_LINE for j in range ( 1 , n ) : if NEW_LINE s [ j ] == s [ j - 1 ] : NEW_LINE if s [ j ] == \"1\" : NEW_LINE INDENT ti += 1 else : NEW_LINE to += 1 NEW_LINE DEDENT ans . append ( max ( to , ti ) ) NEW_LINE for k in ans : print ( k ) NEW_LINE","def alternate_string ( n , s ) : low = 1 NEW_LINE high = n - 2 NEW_LINE flag1 = flag2 = 0 NEW_LINE for i in range ( n - 1 ) : if NEW_LINE s [ low ] == '0' and s [ low - 1 ] == '1' : flag1 += 1 NEW_LINE if s [ high ] == '0' and s [ high + 1 ] == '1' : flag2 += 1 NEW_LINE low += 1 NEW_LINE high -= 1 NEW_LINE return n \/\/ 2 - max ( flag1 , flag2 )   for i in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE print ( alternate_string ( n , s ) ) NEW_LINE","t = int ( input ( ) ) NEW_LINE for i in range ( t ) : l = int ( input ( ) ) NEW_LINE st = input ( ) NEW_LINE st1 = \"01\" NEW_LINE st2 = \"10\" NEW_LINE for j in range ( 2 , l , 2 ) : st1 = st1 + \"01\" NEW_LINE st2 = st2 + \"10\" NEW_LINE d1 = 0 NEW_LINE flg = 0 NEW_LINE for k in range ( l ) : if NEW_LINE INDENT ( flg == 1 and st [ k ] == st1 [ k ] ) : d1 = d1 + 1 NEW_LINE DEDENT flg = 0 elif ( st [ k ] != st1 [ k ] ) : flg = 1 NEW_LINE if ( flg == 1 ) : d1 = d1 + 1 NEW_LINE flg = 0 NEW_LINE d2 = 0 NEW_LINE for m in range ( l ) : if NEW_LINE INDENT ( flg == 1 and st [ m ] == st2 [ m ] ) : d2 = d2 + 1 NEW_LINE DEDENT flg = 0 elif ( st [ m ] != st2 [ m ] ) : flg = 1 NEW_LINE if ( flg == 1 ) : d2 = d2 + 1 NEW_LINE print ( min ( d1 , d2 ) ) NEW_LINE"],"bleu":0.3286143730793069,"rouge_l":0.4356253825749847}
{"id":280,"predictions":["t = int ( input ( ) ) for i in range ( t ) : n , k = list ( map ( int , input ( ) . split ( ) ) ) if n <= k : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"references":["def solve ( ) : n = int ( input ( ) ) NEW_LINE i = 0 NEW_LINE while 2021 * i <= n : if NEW_LINE ( n - ( i * 2021 ) ) % 2020 == 0 : NEW_LINE return True NEW_LINE i += 1 NEW_LINE return False       for t in range ( int ( input ( ) ) ) : if NEW_LINE solve ( ) : print ( ' YES ' ) else : print ( ' NO ' ) NEW_LINE","for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEW_LINE for i in range ( n \/\/ 2021 + 1 ) : if NEW_LINE not ( n - 2021 * i ) % 2020 : print ( \" YES \" ) NEW_LINE break else : print ( \" NO \" ) NEW_LINE","for _ in range ( int ( input ( ) ) ) :     NEW_LINE n = int ( input ( ) )   if n \/\/ 2020 >= n % 2020 : NEW_LINE INDENT print ( ' YES ' ) else : NEW_LINE print ( ' NO ' ) NEW_LINE DEDENT","t = int ( input ( ) ) NEW_LINE for i in range ( t ) : z = int ( input ( ) ) NEW_LINE c = 0 NEW_LINE for j in range ( z \/\/ 2020 + 1 ) : if NEW_LINE ( z - 2020 * j ) % 2021 == 0 : c = 1 NEW_LINE if c == 1 : NEW_LINE INDENT print ( ' YES ' ) else : NEW_LINE print ( ' NO ' ) NEW_LINE DEDENT"],"bleu":0.6354943293812222,"rouge_l":0.5854315179378013}
{"id":281,"predictions":["import itertoolsimport bisectimport mathfrom collections import * import osimport sysfrom io import BytesIO , IOBase   ii = lambda : int ( input ( ) ) lmii = lambda : list ( map ( int , input ( ) . split ( ) ) ) slmii = lambda : sorted ( map ( int , input ( ) . split ( ) ) ) li = lambda : list ( input ( ) ) mii = lambda : map ( int , input ( ) . split ( ) ) msi = lambda : map ( str , input ( ) . split ( ) )     def main ( ) : NEW_LINE"],"references":["from collections import Counter     def gcd ( a , b ) : return a if b == 0 else gcd ( b , a % b )     n = int ( input ( ) ) count = Counter ( ) for e in map ( int , input ( ) . split ( ) ) : count [ e ] += 1 res = [ ] while sum ( count . values ( ) ) > 0 : cur = max ( count . keys ( ) ) count [ cur ] -= 1 if count [ cur ] == 0 : del count [ cur ] for e in res : g = gcd ( cur , e ) count [ g ] -= 2 if count [ g ] == 0 : del count [ g ] res . append ( cur ) print ( * res ) NEW_LINE","import math as maimport sysinput = sys . stdin . readline   def fu ( b ) : for i in b : if b [ i ] != 0 : return i return - 1   def gcd ( a , b ) : if a % b == 0 : return b else : return gcd ( b , a % b )   n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) a . sort ( reverse = True ) b = { } for i in range ( n * n ) : if a [ i ] in b . keys ( ) : b [ a [ i ] ] += 1 else : b [ a [ i ] ] = 1 c = [ ] for i in b : c . append ( i ) b [ i ] -= 1 breakwhile 1 > 0 : if len ( c ) < n : a = fu ( b ) if a == - 1 : break else : b [ a ] -= 1 for i in range ( len ( c ) ) : b [ gcd ( a , c [ i ] ) ] -= 2 c . append ( a ) else : break   print ( * c ) NEW_LINE","from math import gcdn = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) d = { } for i in arr : d [ i ] = d . get ( i , 0 ) + 1 d = { i : d [ i ] for i in sorted ( d , key = lambda w : - w ) } out = [ ] for i in d : while d [ i ] > 0 : for y in out : d [ gcd ( y , i ) ] -= 2 out += [ i ] d [ i ] -= 1 print ( * out ) NEW_LINE","import sysfrom math import gcd , sqrt , ceil , log2from collections import defaultdict , Counter , dequefrom bisect import bisect_left , bisect_rightimport math   sys . setrecursionlimit ( 2 * 10 ** 5 + 10 ) import heapqfrom itertools import permutations   NEW_LINE"],"bleu":0.26573028533785326,"rouge_l":0.38931150077359467}
{"id":282,"predictions":["t = int ( input ( ) ) r = lambda : list ( map ( int , input ( ) . split ( ) ) ) arr = r ( )   arr . sort ( ) NEW_LINE"],"references":["res = [ ]   for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEW_LINE if n < 0 : NEW_LINE INDENT res . append ( - n ) else : NEW_LINE s = 0 NEW_LINE DEDENT i = 0 NEW_LINE while s < n : i += 1 NEW_LINE s += i NEW_LINE if s == n or s - n > 1 : NEW_LINE INDENT res . append ( i ) else : NEW_LINE res . append ( i + 1 )   for i in res : print ( i ) NEW_LINE DEDENT","t = int ( input ( ) ) NEW_LINE for i in range ( t ) : x = int ( input ( ) ) NEW_LINE c = 0 NEW_LINE sum = 0 NEW_LINE while sum < x : c += 1 NEW_LINE sum = sum + c NEW_LINE re = sum - x NEW_LINE","for t in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEW_LINE i = 1 NEW_LINE while i * ( i + 1 ) \/ 2 < n : i += 1   NEW_LINE","import sys   NEW_LINE def answer ( x ) : test = 0 NEW_LINE k = 0 NEW_LINE while test < x : NEW_LINE","from collections import defaultdictimport NEW_LINE matht = int ( input ( ) ) NEW_LINE for i in range ( t ) : n = int ( input ( ) ) NEW_LINE val = math . ceil ( ( math . sqrt ( 1 + 8 * n ) - 1 ) \/ 2 ) NEW_LINE comp = ( val * ( val + 1 ) ) \/\/ 2 - 1 NEW_LINE if ( n != comp ) : NEW_LINE INDENT print ( val ) else : NEW_LINE print ( val + 1 )               NEW_LINE DEDENT"],"bleu":0.34639204621647113,"rouge_l":0.46782260753584526}
{"id":283,"predictions":["n , m , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = list ( map ( int , input ( ) . split ( ) ) ) d = { } for i in range ( n ) : if d . get ( b [ i ] ) : if d [ b [ i ] ] > a [ i ] : d [ b [ i ] ] = a [ i ] else : d [ b [ i ] ] = a [ i ] ans = 0 for i in c : if a [ i ] == i : ans += 1 print ( ans ) NEW_LINE"],"references":["s = input ( ) horizontal = - 1 vertical = - 1 v = [ ] h = [ ] for i in range ( len ( s ) ) : if s [ i ] == \"0\" : vertical += 1 vertical %= 2 if vertical == 0 : ans = 1 else : ans = 3 print ( ans , 1 ) else : horizontal += 1 horizontal %= 4 print ( horizontal + 1 , 2 ) NEW_LINE","s = input ( ) horizontal = - 1 vertical = - 1 v = [ ] h = [ ] for i in range ( len ( s ) ) : if s [ i ] == \"0\" : vertical += 1 vertical %= 2 if vertical == 0 : ans = 1 else : ans = 3 print ( ans , 1 ) else : horizontal += 1 horizontal %= 4 print ( horizontal + 1 , 2 ) NEW_LINE","s = input ( ) v = 0 h = 0 for c in s : if c == '0' : v += 1 print ( 1 , v ) v = v % 4 elif c == '1' : h += 1 print ( 3 , h * 2 - 1 ) h = h % 2 NEW_LINE"],"bleu":0.1047473749891035,"rouge_l":0.3026853473438412}
{"id":284,"predictions":["import mathn = int ( input ( ) ) a = math . sqrt ( n ) print ( a ) NEW_LINE"],"references":["import mathn = int ( input ( ) ) if ( n == 0 ) : print ( 1 ) elif ( n == 1 ) : print ( 4 ) elif ( n == 2 ) : print ( 8 ) elif ( n == 3 ) : print ( 16 ) else : k = 4 + 8 * ( int ( math . sqrt ( n * n \/ 2 ) ) ) p = int ( math . sqrt ( n * n \/ 2 ) ) if ( p * p + ( p + 1 ) * ( p + 1 ) > n * n ) : k -= 4 print ( k ) NEW_LINE","import matha = int ( input ( ) ) n = 0 if a > 0 : b = int ( math . sqrt ( ( a ** 2 ) \/ 2 ) ) if b ** 2 + ( b + 1 ) ** 2 <= a ** 2 : n = b * 8 + 4 else : n = b * 8 print ( n ) else : print ( '1' )   NEW_LINE","print ( max ( 1 , 4 * int ( int ( input ( ) ) * 2 ** 0.5 ) ) ) NEW_LINE","print ( max ( 1 , 4 * int ( int ( input ( ) ) * 2 ** 0.5 ) ) ) NEW_LINE","print ( max ( 1 , 4 * int ( int ( input ( ) ) * 2 ** 0.5 ) ) ) NEW_LINE"],"bleu":0.6096335504645268,"rouge_l":0.4939271255060729}
{"id":285,"predictions":["for _ in range ( int ( input ( ) ) ) : a , b = map ( int , input ( ) . split ( ) ) c = abs ( a - b ) print ( c \/\/ 2 * ( c - a ) \/\/ 2 + ( c - b ) \/\/ 2 ) NEW_LINE"],"references":["import math as m   t = int ( input ( ) )   for i in range ( t ) : a , b = map ( int , input ( ) . split ( ) ) mx , mn = max ( a , b ) , min ( a , b ) c = 2 * ( mx - mn ) d = 1 ** 2 + 4 * c ds = m . sqrt ( d ) n = ( ds - 1 ) \/ 2 n = int ( n ) if int ( n ) == n else int ( n ) + 1 n += ( n * ( n + 1 ) \/\/ 2 ) % 2 != ( mx - mn ) % 2 n += ( n * ( n + 1 ) \/\/ 2 ) % 2 != ( mx - mn ) % 2 print ( n )   NEW_LINE","import math   for _ in range ( int ( input ( ) ) ) : [ a , b ] = sorted ( list ( map ( int , input ( ) . split ( ) ) ) )           n = math . floor ( ( - 1 + math . sqrt ( 1 + 8 * ( b - a ) ) ) \/ 2 ) a = a + n * ( n + 1 ) \/ 2 while ( ( a - b ) % 2 ) != 0 or a < b : n += 1 a += n print ( n ) NEW_LINE","import sysfrom collections import defaultdictimport math   t = int ( sys . stdin . readline ( ) ) for _ in range ( t ) : a , b = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) x , y = max ( a , b ) , min ( a , b ) dif = x - y n = ( math . sqrt ( 1 + 8 * dif ) - 1 ) \/\/ 2 low , high = int ( max ( 0 , n - 100 ) ) , int ( n + 100 ) ans = 1e10 NEW_LINE","def func ( n ) : return ( n * ( n + 1 ) ) \/\/ 2 for _ in range ( int ( input ( ) ) ) : a , b = map ( int , input ( ) . split ( ) ) n = 0 while ( func ( n ) + a + b ) % 2 != 0 or ( func ( n ) + a + b ) < ( 2 * max ( a , b ) ) : n += 1 print ( n ) NEW_LINE"],"bleu":0.3851171031373666,"rouge_l":0.5522343629614065}
{"id":286,"predictions":["n , a , b = map ( int , input ( ) . split ( ) ) x = [ int ( x ) for x in input ( ) . split ( ) ] y = [ int ( x ) for x in input ( ) . split ( ) ] if sum ( x ) >= sum ( y ) : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"references":["from collections import Counterimport math   def solve ( ) : a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) n = int ( input ( ) ) sum1 , sum2 = 0 , 0   for i in a : sum1 += i for i in b : sum2 += i   if math . ceil ( sum1 \/ 5 ) + math . ceil ( sum2 \/ 10 ) <= n : return \" YES \"   return \" NO \"                 print ( solve ( ) ) NEW_LINE","a1 , a2 , a3 = map ( int , input ( ) . split ( ) ) b1 , b2 , b3 = map ( int , input ( ) . split ( ) ) n = int ( input ( ) ) a = a1 + a2 + a3b = b1 + b2 + b3shells = 0 if a % 5 != 0 : shells += a \/\/ 5 + 1 else : shells += a \/\/ 5 if b % 10 != 0 : shells += b \/\/ 10 + 1 else : shells += b \/\/ 10 NEW_LINE","import sysinput = sys . stdin . readline   '''   '''   from math import ceil   a1 , a2 , a3 = map ( int , input ( ) . split ( ) ) b1 , b2 , b3 = map ( int , input ( ) . split ( ) ) n = int ( input ( ) ) shelves_cup = ceil ( ( a1 + a2 + a3 ) \/ 5 ) shelves_medal = ceil ( ( b1 + b2 + b3 ) \/ 10 )   print ( \" YES \" if shelves_cup + shelves_medal <= n else \" NO \" ) NEW_LINE","from math import ceila = sum ( map ( int , input ( ) . split ( ) ) ) b = sum ( map ( int , input ( ) . split ( ) ) ) n = int ( input ( ) ) print ( \" YES \" if ceil ( a \/ 5 ) + ceil ( b \/ 10 ) <= n else \" NO \" ) NEW_LINE"],"bleu":0.40586223702807744,"rouge_l":0.5717082770135961}
{"id":287,"predictions":["t = int ( input ( ) ) for _ in range ( t ) : a , b = map ( int , input ( ) . split ( ) ) print ( a + b ) NEW_LINE"],"references":["print ( bin ( int ( input ( ) ) ) . count ( '1' ) ) NEW_LINE","x = int ( input ( ) ) print ( bin ( x ) . count ( '1' ) ) NEW_LINE","n = int ( input ( ) ) bin_n = bin ( n ) [ 2 : ] print ( bin_n . count ( '1' ) ) NEW_LINE","n = int ( input ( ) ) a = \" { 0 : b } \" . format ( n ) . count ( '1' ) print ( a ) NEW_LINE","import mathn = int ( input ( ) ) res = 0 while n >= 2 : n -= math . pow ( 2 , math . floor ( math . log2 ( n ) ) ) res += 1 print ( int ( res + n ) ) NEW_LINE"],"bleu":0.33977166058594355,"rouge_l":0.6152294503277861}
{"id":288,"predictions":["import sysimport NEW_LINE mathinf = float ( ' inf ' ) NEW_LINE"],"references":["I = lambda : list ( map ( int , input ( ) . split ( ) ) ) R = range ( I ( ) [ 0 ] ) a = I ( ) b = I ( ) c = I ( ) print ( min ( c [ i ] + c [ j ] + sum ( a [ : i ] + a [ : j ] + b [ i : ] + b [ j : ] ) for i in R for j in R if i != j ) ) NEW_LINE","a = int ( input ( ) ) z = [ [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) , [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) ] r = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) k = [ ] for i in range ( a , 0 , - 1 ) : k . insert ( 0 , sum ( z [ 0 ] [ : i ] ) + r [ i ] + sum ( z [ 1 ] [ i : ] ) ) k1 = [ ] for i in range ( 1 , a + 1 ) : k1 . insert ( 0 , r [ i ] + sum ( z [ 0 ] [ : i ] ) + sum ( z [ 1 ] [ i : ] ) ) s = float ( \" inf \" ) k1 = k1 [ : : - 1 ] for i in range ( a ) : for j in range ( a ) : if i != j : s = min ( s , k [ i ] + k1 [ j ] ) print ( s ) NEW_LINE","a = int ( input ( ) ) z = [ [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) , [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) ] r = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) k = [ ] for i in range ( a , 0 , - 1 ) : k . insert ( 0 , sum ( z [ 0 ] [ : i ] ) + r [ i ] + sum ( z [ 1 ] [ i : ] ) ) k1 = [ ] for i in range ( 1 , a + 1 ) : k1 . insert ( 0 , r [ i ] + sum ( z [ 0 ] [ : i ] ) + sum ( z [ 1 ] [ i : ] ) ) s = 2 * a * 100 k1 = k1 [ : : - 1 ] for i in range ( a ) : for j in range ( a ) : if i != j : s = min ( s , k [ i ] + k1 [ j ] ) print ( s ) NEW_LINE","a = int ( input ( ) ) z = [ [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) , [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) ] r = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) k = [ ] for i in range ( a , 0 , - 1 ) : k . insert ( 0 , sum ( z [ 0 ] [ : i ] ) + r [ i ] + sum ( z [ 1 ] [ i : ] ) ) s = min ( k ) ; k [ k . index ( s ) ] = 2 * a * 100 ; print ( s + min ( k ) ) NEW_LINE","n = int ( input ( ) ) row1 = [ 0 ] + [ int ( x ) for x in input ( ) . split ( ) ] row2 = [ 0 ] + [ int ( x ) for x in input ( ) . split ( ) ] b = [ int ( x ) for x in input ( ) . split ( ) ] for i in range ( 1 , n ) : row1 [ i ] += row1 [ i - 1 ] row2 [ i ] += row2 [ i - 1 ] mini = 1000000000 for i in range ( n ) : if row1 [ i ] + b [ i ] + row2 [ n - 1 ] - row2 [ i ] < mini : mini = row1 [ i ] + b [ i ] + row2 [ n - 1 ] - row2 [ i ] index = imini2 = 100000000 for i in range ( n ) : if i != index and row1 [ i ] + b [ i ] + row2 [ n - 1 ] - row2 [ i ] < mini2 : mini2 = row1 [ i ] + b [ i ] + row2 [ n - 1 ] - row2 [ i ] print ( mini + mini2 ) NEW_LINE"],"bleu":0.00015616779748044547,"rouge_l":0.06421052631578948}
{"id":289,"predictions":["import sys , os , ioimport math , bisect , operatorinf , mod = float ( ' inf ' ) , 10 ** 9 + 7 NEW_LINE"],"references":["n = int ( input ( ) ) a = [ 0 ] * nb = [ 0 ] * nfor i in range ( n * ( n - 1 ) \/\/ 2 - 1 ) : c , d = list ( map ( int , input ( ) . split ( ) ) ) a [ c - 1 ] += 1 b [ c - 1 ] += 1 b [ d - 1 ] += 1 f = - 1 g = - 1 for i in range ( n ) : if b [ i ] == n - 2 : if f == - 1 : f = i + 1 else : g = i + 1 breakif a [ f - 1 ] > a [ g - 1 ] : print ( f , g ) else : print ( g , f ) NEW_LINE","n = int ( input ( ) ) wins = [ set ( ) for _ in range ( n ) ] looses = [ set ( ) for _ in range ( n ) ] for _ in range ( n * ( n - 1 ) \/\/ 2 - 1 ) : u , v = list ( map ( int , input ( ) . split ( ) ) ) u -= 1 v -= 1 wins [ u ] . add ( v ) looses [ v ] . add ( u )   win_set = { } loose_set = { } winners = [ ] loosers = [ ] for i in range ( n ) : if len ( wins [ i ] ) in win_set : winners . append ( i ) winners . append ( win_set [ len ( wins [ i ] ) ] ) else : win_set [ len ( wins [ i ] ) ] = i if len ( looses [ i ] ) in loose_set : loosers . append ( i ) loosers . append ( loose_set [ len ( looses [ i ] ) ] ) else : loose_set [ len ( looses [ i ] ) ] = i   if loosers [ 0 ] not in wins [ winners [ 0 ] ] and loosers [ 0 ] != winners [ 0 ] : print ( winners [ 0 ] + 1 , loosers [ 0 ] + 1 ) elif loosers [ 0 ] not in wins [ winners [ 1 ] ] and loosers [ 0 ] != winners [ 1 ] : print ( winners [ 1 ] + 1 , loosers [ 0 ] + 1 ) elif loosers [ 1 ] not in wins [ winners [ 1 ] ] and loosers [ 1 ] != winners [ 1 ] : print ( winners [ 1 ] + 1 , loosers [ 1 ] + 1 ) else : print ( winners [ 0 ] + 1 , loosers [ 1 ] + 1 ) NEW_LINE","num = int ( input ( ) ) win = [ ] dic = { } for i in range ( 1 , num + 1 ) : dic [ i ] = num - 1 for i in range ( int ( num * ( num - 1 ) \/ 2 ) - 1 ) : p = input ( ) . split ( ) win . append ( int ( p [ 0 ] ) ) dic [ int ( p [ 0 ] ) ] -= 1 dic [ int ( p [ 1 ] ) ] -= 1 k = [ ] for i in range ( 1 , num + 1 ) : if dic [ i ] != 0 : k . append ( i ) a = win . count ( k [ 0 ] ) b = win . count ( k [ 1 ] ) if a >= b : print ( k [ 0 ] , k [ 1 ] ) else : print ( k [ 1 ] , k [ 0 ] ) NEW_LINE","from sys import stdininput = stdin . readline   n = int ( input ( ) ) g = [ n - 1 ] * na = [ [ int ( x ) for x in input ( ) . split ( ) ] for _ in range ( ( n * ( n - 1 ) ) \/\/ 2 - 1 ) ] for i in a : for j in i : g [ j - 1 ] -= 1 p = [ ] for i in range ( n ) : if g [ i ] > 0 : p . append ( i + 1 ) x , y = pr = 0 s = 0 for i , _ in a : r += ( i == x ) s += ( i == y )   if r >= s : print ( x , y ) else : print ( y , x ) NEW_LINE","n = int ( input ( ) ) s = set ( ) a = [ 0 ] * ncnt = [ 0 ] * nfor i in range ( n * ( n - 1 ) \/\/ 2 - 1 ) : x , y = map ( int , input ( ) . split ( ) ) a [ x - 1 ] += 1 a [ y - 1 ] -= 1 cnt [ x - 1 ] += 1 cnt [ y - 1 ] += 1 r = [ ] for i in range ( n ) : if cnt [ i ] == ( n - 2 ) : r . append ( ( a [ i ] , i + 1 ) ) r . sort ( ) print ( r [ 1 ] [ 1 ] , r [ 0 ] [ 1 ] ) NEW_LINE"],"bleu":0.0006620345546273666,"rouge_l":0.07942708333333333}
{"id":290,"predictions":["from sys import stdin , stdoutfrom math import floor , gcd , fabs , factorial , fmod , sqrt , inf , logfrom collections import defaultdict as dd , dequefrom heapq import merge , heapify , heappop , heappush , nsmallestfrom bisect import bisect_left as bl , bisect_right as br , bisect mod = pow ( 10 , 9 ) + 7 mod2 = 998244353 def inp ( ) : return stdin . readline ( ) . strip ( ) def iinp ( ) : return int ( inp ( ) ) def out ( var , end = \" \\n \" ) : stdout . write ( str ( var ) + \" \\n \" ) def outa ( * var , end = \" \\n \" ) : stdout . write ( ' ▁ ' . join ( map ( str , var ) ) + end ) def lmp ( ) : return list ( mp ( ) ) def mp ( ) : return map ( int , inp ( ) . split ( ) ) def smp ( ) : return map ( str , inp ( ) . split ( ) ) def l1d ( n , val = 0 ) : return [ val for i in range ( n ) ] def l2d ( n , m , val = 0 ) : return [ l1d ( m , val ) for j in range ( n ) ] def remadd ( x , y ) : return 1 if x % y else 0 def ceil ( a , b ) : return ( a + b - 1 ) \/\/ b def isprime ( x ) : if x <= 1 : return False if x in ( 2 , 3 ) : return True return F ( x ) def main ( ) : NEW_LINE"],"references":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) cnt = { } for x in a : cnt [ x ] = cnt . get ( x , 0 ) + 1 for x in b : cnt [ x ] = cnt . get ( x , 0 ) - 1 if any ( [ abs ( v ) % 2 == 1 for v in cnt . values ( ) ] ) : print ( - 1 ) else : ans = sum ( [ v for v in cnt . values ( ) if v > 0 ] ) \/\/ 2 print ( ans ) NEW_LINE","from sys import stdinn = int ( stdin . readline ( ) ) a = list ( map ( int , stdin . readline ( ) . split ( ) ) ) b = list ( map ( int , stdin . readline ( ) . split ( ) ) ) v = [ 0 ] * ( 6 ) for i in a : v [ i ] += 1 for i in b : v [ i ] -= 1   for i in v : if i % 2 : print ( - 1 ) breakelse : print ( sum ( [ abs ( i ) for i in v ] ) \/\/ 4 ) NEW_LINE","\"\"\" ▁ Created ▁ by ▁ Henrikh ▁ Kantuni ▁ on ▁ 2\/26\/17 ▁ \"\"\"   n = int ( input ( ) ) al = [ int ( x ) for x in input ( ) . split ( ) ] bl = [ int ( x ) for x in input ( ) . split ( ) ] a = { 1 : al . count ( 1 ) , 2 : al . count ( 2 ) , 3 : al . count ( 3 ) , 4 : al . count ( 4 ) , 5 : al . count ( 5 ) , } b = { 1 : bl . count ( 1 ) , 2 : bl . count ( 2 ) , 3 : bl . count ( 3 ) , 4 : bl . count ( 4 ) , 5 : bl . count ( 5 ) , }   possible = Truefor key in a . keys ( ) : if ( a [ key ] + b [ key ] ) % 2 != 0 : possible = False break   if possible : swaps = 0 for key in a . keys ( ) : if a [ key ] > b [ key ] : swaps += ( a [ key ] - b [ key ] ) \/\/ 2 print ( swaps ) else : print ( - 1 ) NEW_LINE","n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) da , db = { } , { } for x in a : da [ x ] = da . get ( x , 0 ) + 1 for x in b : db [ x ] = db . get ( x , 0 ) + 1   ansa = 0 for key in da : v = da [ key ] + db . get ( key , 0 ) if v % 2 != 0 : ansa = - 1 break else : if da [ key ] > v \/\/ 2 : ansa += da [ key ] - v \/\/ 2   ansb = 0 for key in db : v = db [ key ] + da . get ( key , 0 ) if v % 2 != 0 : ansb = - 1 break else : if db [ key ] > v \/\/ 2 : ansb += db [ key ] - v \/\/ 2 if ansa != ansb : print ( - 1 ) else : print ( ansa ) NEW_LINE"],"bleu":0.13381853737316043,"rouge_l":0.3497102700036987}
{"id":291,"predictions":["x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) ans = abs ( x2 - x1 ) + abs ( y2 - y1 ) print ( ans ) NEW_LINE"],"references":["from sys import stdout   first_rez = [ ]     def req ( x1 , y1 , x2 , y2 ) : print ( ' ? ' , x1 , y1 , x2 , y2 ) stdout . flush ( ) x = int ( input ( ) ) if first_rez : if x1 <= first_rez [ 0 ] <= first_rez [ 2 ] <= x2 and y1 <= first_rez [ 1 ] <= first_rez [ 3 ] <= y2 : x -= 1 NEW_LINE"],"bleu":0.09468932966432521,"rouge_l":0.282958984375}
{"id":292,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) f = [ 0 ] * ( max ( a ) + 1 ) for i in a : f [ i ] += 1 c = 0 for i in f : if ( i % 2 != 0 ) : c = 1 breakif ( c == 0 ) : print ( ' NO ' ) else : print ( ' YES ' ) NEW_LINE"],"references":["import sysfrom collections import defaultdict as ddinput = sys . stdin . readlineI = lambda : list ( map ( int , input ( ) . split ( ) ) )   n , a , b = I ( ) l = I ( ) dic = dd ( int ) for i in range ( n ) : dic [ l [ i ] ] = 1 bs = [ ] pa = dd ( int ) for i in range ( n ) : if dic [ a - l [ i ] ] == 0 : bs . append ( l [ i ] ) else : pa [ l [ i ] ] = a - l [ i ] j = 0 while j < len ( bs ) : for i in range ( j , len ( bs ) ) : cr = bs [ i ] dic [ cr ] = 2 if dic [ b - cr ] == 0 : print ( \" NO \" ) ; exit ( ) dic [ b - cr ] = 2 if dic [ a - b + cr ] == 1 : dic [ a - b + cr ] = 2 bs . append ( a - b + cr ) j += 1 NEW_LINE","def find ( u ) : global par if u != par [ u ] : par [ u ] = find ( par [ u ] ) return par [ u ]   def union ( u , v ) : u = find ( u ) v = find ( v ) par [ u ] = v   n , a , b = map ( int , input ( ) . split ( ) ) p = list ( map ( int , input ( ) . split ( ) ) ) mp = dict ( ) for i in range ( n ) : mp [ p [ i ] ] = i + 1 par = [ i for i in range ( n + 2 ) ]   for i in range ( n ) : union ( i + 1 , mp . get ( a - p [ i ] , n + 1 ) ) union ( i + 1 , mp . get ( b - p [ i ] , 0 ) )   A = find ( 0 ) B = find ( n + 1 )   if A != B : print ( ' YES ' ) print ( ' ▁ ' . join ( [ '1' if find ( i ) == B else '0' for i in range ( 1 , n + 1 ) ] ) ) else : print ( ' NO ' ) NEW_LINE","import sysfrom collections import defaultdict as ddinput = sys . stdin . readlineI = lambda : list ( map ( int , input ( ) . split ( ) ) )   n , a , b = I ( ) l = I ( ) dic = dd ( int ) for i in range ( n ) : dic [ l [ i ] ] = 1 bs = [ ] pa = dd ( int ) for i in range ( n ) : if dic [ a - l [ i ] ] == 0 : bs . append ( l [ i ] ) else : pa [ l [ i ] ] = a - l [ i ] j = 0 while j < len ( bs ) : for i in range ( j , len ( bs ) ) : cr = bs [ i ] dic [ cr ] = 2 if dic [ b - cr ] == 0 : print ( \" NO \" ) ; exit ( ) dic [ b - cr ] = 2 if dic [ a - b + cr ] == 1 : dic [ a - b + cr ] = 2 bs . append ( a - b + cr ) j += 1 NEW_LINE","\/ * package whatever \/\/ do not write package name here * \/   import java . io . * ; import java . util . Scanner ; import java . util . * ;   public class twosets { public static void main ( String [ ] args ) { Scanner inp = new Scanner ( System . in ) ; int n = inp . nextInt ( ) ; int a = inp . nextInt ( ) ; int b = inp . nextInt ( ) ; int [ ] ar = new int [ n ] ; HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i + + ) { ar [ i ] = inp . nextInt ( ) ; mp . put ( ar [ i ] , 1 ) ; } ArrayList < Integer > arr = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < n ; i + + ) { if ( mp . get ( a - ar [ i ] ) == null ) { arr . add ( ar [ i ] ) ; } } for ( int i = 0 ; i < arr . size ( ) ; i + + ) { int now = arr . get ( i ) ; mp . put ( now , 2 ) ; if ( mp . get ( b - now ) == null ) { System . out . println ( \" NO \" ) ; return ; } if ( mp . get ( b - now ) == 2 ) continue ; mp . put ( b - now , 2 ) ; if ( ( mp . get ( a - ( b - now ) ) != null ) & & ( mp . get ( a - ( b - now ) ) != null ) ) { mp . put ( a - ( b - now ) , 2 ) ; arr . add ( a - ( b - now ) ) ; } } System . out . println ( \" YES \" ) ; for ( int i = 0 ; i < n ; i + + ) System . out . print ( mp . get ( ar [ i ] ) - 1 + \" ▁ \" ) ; } } NEW_LINE"],"bleu":0.11828290824249618,"rouge_l":0.3251485494582314}
{"id":293,"predictions":["n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) ce = 0 co = 0 s = 0 for i in l : if i % 2 == 0 : ce += 1 else : co += 1 s += i   if s % 2 == 0 : print ( ce ) else : print ( co ) NEW_LINE"],"references":["import mathn = int ( input ( ) )   arr = [ ]   for i in range ( n ) : arr . append ( int ( input ( ) ) )   res = [ ] flag = Falsefor i in arr : if i % 2 == 0 : res . append ( int ( i \/ 2 ) ) continue if flag : res . append ( math . floor ( i \/ 2 ) ) flag = False else : res . append ( math . ceil ( i \/ 2 ) ) flag = True for i in res : print ( i ) NEW_LINE","import math   n = int ( input ( ) )   p = [ ] non_ints = 0   for _ in range ( n ) : a = int ( input ( ) ) if a % 2 == 0 : p . append ( int ( a \/ 2 ) ) else : non_ints += 1 p . append ( a \/ 2 )   rounded = 0 for pn in p : if type ( pn ) == float : if rounded >= ( non_ints \/ 2 ) : print ( math . floor ( pn ) ) else : print ( math . ceil ( pn ) ) rounded += 1 else : print ( pn ) NEW_LINE","import math   n = int ( input ( ) ) cnt = 0 for _ in range ( n ) : a = int ( input ( ) ) if a % 2 == 0 : print ( a \/\/ 2 ) else : cnt += 1 if cnt % 2 == 1 : print ( math . ceil ( a \/ 2 ) ) else : print ( math . floor ( a \/ 2 ) ) NEW_LINE","n = int ( input ( ) ) cnt = 0 flag = 1 for _ in range ( n ) : a = int ( input ( ) ) if a % 2 == 0 : print ( a \/\/ 2 ) else : print ( ( a + flag ) \/\/ 2 ) flag *= - 1 NEW_LINE","m = 1 for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) if n % 2 == 0 : print ( n \/\/ 2 ) else : print ( n \/\/ 2 + m ) m = 1 - m NEW_LINE"],"bleu":0.4217461298710083,"rouge_l":0.5219885277246654}
{"id":294,"predictions":["from math import sqrt as rfrom collections import defaultdict as dq   n , s = map ( int , input ( ) . split ( ) )   left = 1000000 - s   d = dq ( int ) for i in range ( n ) : x , y , k = map ( int , input ( ) . split ( ) ) d [ x , y ] = k   minm = min ( dq ( x , y ) , k ) print ( minm ) NEW_LINE"],"references":["from math import sqrtdef NEW_LINE dist ( a , b ) : NEW_LINE return ( sqrt ( a ** 2 + b ** 2 ) ) NEW_LINE def solve ( ) : n = int ( input ( ) ) NEW_LINE d = [ ] NEW_LINE m = [ ] NEW_LINE for p in range ( 2 * n ) : a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a == 0 : NEW_LINE INDENT m . append ( abs ( b ) ) else : NEW_LINE d . append ( abs ( a ) ) NEW_LINE DEDENT d . sort ( ) NEW_LINE m . sort ( ) NEW_LINE ans = 0 NEW_LINE for x in range ( n ) : ans += dist ( d [ x ] , m [ x ] ) NEW_LINE print ( ans ) NEW_LINE for _ in range ( int ( input ( ) ) ) : solve ( ) NEW_LINE","import java . util . ArrayList ; NEW_LINE import java . util . Collections ; NEW_LINE import java . util . List ; NEW_LINE import java . util . Locale ; NEW_LINE import java . util . Scanner ;   public NEW_LINE class A1495 {   public static void main ( String [ ] args ) { Locale . setDefault ( Locale . US ) ; Scanner in = new Scanner ( System . in ) ; int T = in . nextInt ( ) ; for ( int t = 0 ; t < T ; t + + ) { int N = in . nextInt ( ) ; List < Integer > miners = new ArrayList < > ( N ) ; List < Integer > diamonds = new ArrayList < > ( N ) ; for ( int n = 0 ; n < 2 * N ; n + + ) { int x = in . nextInt ( ) ; int y = in . nextInt ( ) ; if ( x == 0 ) { miners . add ( Math . abs ( y ) ) ; } else { diamonds . add ( Math . abs ( x ) ) ; } } Collections . sort ( miners ) ; Collections . sort ( diamonds ) ; double answer = 0 ; for ( int n = 0 ; n < N ; n + + ) { int x = diamonds . get ( n ) ; int y = miners . get ( n ) ; answer += Math . sqrt ( x * ( long ) x + y * ( long ) y ) ; } System . out . println ( answer ) ; } }   } NEW_LINE","import matht = int ( input ( ) ) NEW_LINE for i in range ( 0 , t ) : n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE b = [ ] NEW_LINE sum = 0 NEW_LINE temp = 0 NEW_LINE for i in range ( 0 , 2 * n ) : x , y = map ( int , input ( ) . split ( ) ) NEW_LINE if x == 0 : NEW_LINE INDENT a . append ( abs ( y ) ) else : NEW_LINE b . append ( abs ( x ) ) NEW_LINE DEDENT a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE for i in range ( 0 , n ) : x = a [ i ] * a [ i ] NEW_LINE y = b [ i ] * b [ i ] NEW_LINE temp = math . sqrt ( x + y ) NEW_LINE sum += temp NEW_LINE print ( sum ) NEW_LINE","for testis in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEW_LINE x , y = [ ] , [ ] NEW_LINE for i in range ( 2 * n ) : xi , yi = map ( int , input ( ) . split ( ) ) NEW_LINE if xi : NEW_LINE INDENT x . append ( xi ** 2 ) else : NEW_LINE y . append ( yi ** 2 ) NEW_LINE DEDENT x . sort ( ) NEW_LINE y . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : ans += ( x [ i ] + y [ i ] ) ** ( 0.5 ) NEW_LINE print ( ans ) NEW_LINE"],"bleu":0.2323689517751555,"rouge_l":0.3946729929368631}
{"id":295,"predictions":["s = input ( ) t = input ( ) print ( s . count ( s ) ) NEW_LINE"],"references":["years = { \"2013\" , \"2014\" , \"2015\" } base = set ( ) for i in range ( 1 , 29 ) : if i < 10 : base . add ( \"0\" + str ( i ) ) else : base . add ( str ( i ) ) info1 = base . copy ( ) info1 . add ( \"29\" ) info1 . add ( \"30\" ) info2 = info1 . copy ( ) info2 . add ( \"31\" ) months = { \"02\" : base } for i in [ 4 , 6 , 9 , 11 ] : if i < 10 : months [ \"0\" + str ( i ) ] = info1 else : months [ str ( i ) ] = info1for i in [ 1 , 3 , 5 , 7 , 8 , 10 , 12 ] : k = ( \"0\" + str ( i ) ) if i < 10 else str ( i ) months [ k ] = info2   s = input ( )   def solve ( s , years , months ) : maps = { } i = 0 while i < len ( s ) - 9 : if s [ i + 2 ] != \" - \" or s [ i + 5 ] != \" - \" : i += 1 continue d , m , y = s [ i : i + 2 ] , s [ i + 3 : i + 5 ] , s [ i + 6 : i + 10 ] if y in years and m in months and d in months [ m ] : k = s [ i : i + 10 ] maps [ k ] = maps . get ( k , 0 ) + 1 i += 1 ans , count = \" \" , 0 for k , v in maps . items ( ) : if count < v : ans , count = k , v return ans             ans = solve ( s , years , months ) print ( ans ) NEW_LINE","s = input ( )   date_ = { 1 : 31 , 2 : 28 , 3 : 31 , 4 : 30 , 5 : 31 , 6 : 30 , 7 : 31 , 8 : 31 , 9 : 30 , 10 : 31 , 11 : 30 , 12 : 31 } def is_Date_Correct ( s ) : return ( 1 <= int ( s [ 3 : 5 ] ) <= 12 and 2013 <= int ( s [ 6 : ] ) <= 2015 and 1 <= int ( s [ : 2 ] ) <= date_ [ int ( s [ 3 : 5 ] ) ] )   def is_dateformat ( s ) : if s [ 2 ] == ' - ' and s [ 5 ] == ' - ' : for i in range ( len ( s ) ) : if i == 2 or i == 5 : continue if s [ i ] == ' - ' : return False ; return True ; return False ;   i = 0 map = { } while ( i < len ( s ) ) : x = s [ i : i + 10 ] if is_dateformat ( x ) and is_Date_Correct ( x ) : if x in map : map [ x ] += 1 else : map [ x ] = 1 i += 8 else : i += 1 if i + 10 > len ( s ) : break   count = 0 res = \" \" for i in map : if map [ i ] > count : res = i count = map [ i ]   print ( res ) NEW_LINE","years = { \"2013\" , \"2014\" , \"2015\" } base = set ( ) for i in range ( 1 , 29 ) : if i < 10 : base . add ( \"0\" + str ( i ) ) else : base . add ( str ( i ) ) info1 = base . copy ( ) info1 . add ( \"29\" ) info1 . add ( \"30\" ) info2 = info1 . copy ( ) info2 . add ( \"31\" ) months = { \"02\" : base } for i in [ 4 , 6 , 9 , 11 ] : if i < 10 : months [ \"0\" + str ( i ) ] = info1 else : months [ str ( i ) ] = info1for i in [ 1 , 3 , 5 , 7 , 8 , 10 , 12 ] : k = ( \"0\" + str ( i ) ) if i < 10 else str ( i ) months [ k ] = info2   s = input ( )   def solve ( s , years , months ) : maps = { } i = 0 while i < len ( s ) - 9 : if s [ i + 2 ] != \" - \" or s [ i + 5 ] != \" - \" : i += 1 continue d , m , y = s [ i : i + 2 ] , s [ i + 3 : i + 5 ] , s [ i + 6 : i + 10 ] if y in years and m in months and d in months [ m ] : k = s [ i : i + 10 ] maps [ k ] = maps . get ( k , 0 ) + 1 i += 1 ans , count = \" \" , 0 for k , v in maps . items ( ) : if count < v : ans , count = k , v return ans             ans = solve ( s , years , months ) print ( ans ) NEW_LINE"],"bleu":6.421986545325487e-7,"rouge_l":0.08251606357795063}
{"id":296,"predictions":["import math , sys , bisect , heapq , osfrom collections import defaultdict , Counter , dequefrom itertools import groupby , accumulatefrom functools import lru_cache NEW_LINE"],"references":["a = list ( map ( int , input ( ) . split ( ) ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) n = a [ 0 ] dp = [ [ 0 for i in range ( 4 ) ] for j in range ( n + 1 ) ] for i in range ( 4 ) : dp [ 0 ] [ i ] = ( - 10 ) ** ( 27 ) for i in range ( 1 , n + 1 ) : for j in range ( 1 , 4 ) : x = arr [ i - 1 ] * a [ j ] + dp [ i ] [ j - 1 ] y = dp [ i - 1 ] [ j ] dp [ i ] [ j ] = max ( x , y ) print ( dp [ n ] [ 3 ] ) NEW_LINE","def maxSum ( arr , p , q , r ) : premax = - 214748364800000000000000000000000000000 postmax = - 2147483648000000000000000000000000000000 maxx = - 214748364800000000000000000000000000000000000 pre = [ ] post = [ ] for i in arr : premax = max ( p * i , premax ) pre . append ( premax ) for j in range ( len ( arr ) - 1 , - 1 , - 1 ) : postmax = max ( r * arr [ j ] , postmax ) post . append ( postmax ) for i in range ( 0 , len ( arr ) ) : summ = 0 summ = q * arr [ i ] + pre [ i ] + post [ len ( arr ) - i - 1 ] maxx = max ( summ , maxx ) return maxxn , p , q , r = [ int ( v ) for v in input ( ) . split ( ) ] arr = [ int ( v ) for v in input ( ) . split ( ) ] [ : n ] print ( maxSum ( arr , p , q , r ) ) NEW_LINE","import sysn , p , q , r = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) arr = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) def find_pref_sum ( array ) : maxm = - 10000000000000000000 pref_sum = [ 0 ] * n for i in range ( 0 , n ) : pref_sum [ i ] = max ( maxm , array [ i ] * p ) maxm = max ( maxm , array [ i ] * p ) return pref_sum def find_suff_sum ( array ) : maxm = - 10000000000000000000 suff_sum = [ 0 ] * n for j in reversed ( range ( n ) ) : suff_sum [ j ] = max ( maxm , array [ j ] * r ) maxm = max ( maxm , array [ j ] * r ) return suff_sum pref_sum = find_pref_sum ( arr ) suff_sum = find_suff_sum ( arr ) def find_max_expression ( p , q , r , arr ) : max_exp = - 10000000000000000000 for i in range ( 0 , n ) : max_exp = max ( max_exp , max ( p * arr [ i ] , pref_sum [ i ] ) + arr [ i ] * q + max ( r * arr [ i ] , suff_sum [ i ] ) ) return max_exp max_expression_val = find_max_expression ( p , q , r , arr ) print ( max_expression_val ) NEW_LINE","import sysn , p , q , r = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) arr = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) def find_pref_sum ( array ) : maxm = - 2 ** 63 pref_sum = [ 0 ] * n for i in range ( 0 , n ) : pref_sum [ i ] = max ( maxm , array [ i ] * p ) maxm = max ( maxm , array [ i ] * p ) return pref_sum def find_suff_sum ( array ) : maxm = - 2 ** 63 suff_sum = [ 0 ] * n for j in reversed ( range ( n ) ) : suff_sum [ j ] = max ( maxm , array [ j ] * r ) maxm = max ( maxm , array [ j ] * r ) return suff_sum pref_sum = find_pref_sum ( arr ) suff_sum = find_suff_sum ( arr ) def find_max_expression ( p , q , r , arr ) : max_exp = - 2 ** 63 for i in range ( 0 , n ) : max_exp = max ( max_exp , max ( p * arr [ i ] , pref_sum [ i ] ) + arr [ i ] * q + max ( r * arr [ i ] , suff_sum [ i ] ) ) return max_exp max_expression_val = find_max_expression ( p , q , r , arr ) print ( max_expression_val ) NEW_LINE","a = list ( map ( int , input ( ) . split ( ) ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) n = a [ 0 ] dp = [ [ 0 for i in range ( 4 ) ] for j in range ( n + 1 ) ] for i in range ( 4 ) : dp [ 0 ] [ i ] = ( - 10 ) ** ( 27 ) for i in range ( 1 , n + 1 ) : for j in range ( 1 , 4 ) : x = arr [ i - 1 ] * a [ j ] + dp [ i ] [ j - 1 ] y = dp [ i - 1 ] [ j ] dp [ i ] [ j ] = max ( x , y ) print ( dp [ n ] [ 3 ] ) NEW_LINE"],"bleu":0.0002964571251755406,"rouge_l":0.06245378533644275}
{"id":297,"predictions":["import itertoolsimport bisectimport mathfrom collections import * import osimport sysfrom io import BytesIO , IOBase   ii = lambda : int ( input ( ) ) lmii = lambda : list ( map ( int , input ( ) . split ( ) ) ) slmii = lambda : sorted ( map ( int , input ( ) . split ( ) ) ) li = lambda : list ( input ( ) ) mii = lambda : map ( int , input ( ) . split ( ) ) msi = lambda : map ( str , input ( ) . split ( ) )     def main ( ) : NEW_LINE"],"references":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in range ( 1 , n - 1 ) : if ( a [ i ] == 0 and a [ i - 1 ] == 1 and a [ i + 1 ] == 1 ) : a [ i + 1 ] = 0 c += 1 print ( c ) NEW_LINE","n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) ans = 0 used = [ 0 ] * n   for i in range ( 1 , n - 1 ) : if arr [ i + 1 ] == 1 and arr [ i ] == 0 and arr [ i - 1 ] == 1 : ans += 1 used [ i + 1 ] = used [ i - 1 ] = used [ i ] = 1 arr [ i + 1 ] = 0     print ( ans ) NEW_LINE","n = int ( input ( ) ) b = list ( map ( int , input ( ) . split ( ) ) ) k = 0 for i in range ( 1 , n - 1 ) : if b [ i ] == 0 and b [ i + 1 ] == 1 and b [ i - 1 ] == 1 : b [ i + 1 ] = 0 k += 1 print ( k ) NEW_LINE","n = int ( input ( ) ) q = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in range ( 1 , n - 1 ) : if q [ i ] == 0 and q [ i - 1 ] == q [ i + 1 ] == 1 : c += 1 q [ i + 1 ] = 0 print ( c ) NEW_LINE","n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) )   res = 0 cur = 0 for i in range ( n ) : if a [ i ] == 1 : if cur == 0 : cur += 1 if cur == 2 : res += 1 cur = 0 else : if cur != 1 : cur = 0 else : cur += 1 print ( res ) NEW_LINE"],"bleu":0.20555406446777716,"rouge_l":0.3634661218930882}
{"id":298,"predictions":["from collections import defaultdict , OrderedDict , Counterfrom sys import stdin , stdoutfrom bisect import bisect_left , bisect_right NEW_LINE"],"references":["R = lambda : map ( int , input ( ) . split ( ) ) NEW_LINE t , = R ( ) NEW_LINE exec ( t * ' n , k = R ( ) ; a = { * R ( ) } ; i = 0 \\n while { i } & a : i + = 1 \\n print ( n + ( k > 0 ) * ( k , i + max ( a ) + 1 > > 1not ▁ in ▁ a ) [ i < n ] ) \\n ' ) NEW_LINE","R = lambda : map ( int , input ( ) . split ( ) ) NEW_LINE t , = R ( ) NEW_LINE while t : NEW_LINE INDENT t -= 1 ; NEW_LINE n , k = R ( ) ; NEW_LINE a = sorted ( R ( ) ) ; NEW_LINE i = 0 NEW_LINE for x in a : NEW_LINE INDENT if i < x : break NEW_LINE i += 1 NEW_LINE DEDENT print ( n + ( k > 0 ) * ( i + a [ - 1 ] + 1 >> 1 not in a , k ) [ i > a [ - 1 ] ] ) NEW_LINE DEDENT","R = lambda : map ( int , input ( ) . split ( ) ) NEW_LINE t , = R ( ) NEW_LINE while t : NEW_LINE INDENT t -= 1 ; NEW_LINE n , k = R ( ) ; NEW_LINE a = sorted ( R ( ) ) ; NEW_LINE i = 0 NEW_LINE for x in a : NEW_LINE INDENT if i < x : break NEW_LINE i += 1 NEW_LINE DEDENT print ( n + ( k > 0 ) * ( k , i + a [ - 1 ] + 1 >> 1 not in a ) [ i < n ] ) NEW_LINE DEDENT","R = lambda : map ( int , input ( ) . split ( ) ) NEW_LINE t , = R ( ) NEW_LINE while t : NEW_LINE INDENT t -= 1 ; NEW_LINE n , k = R ( ) ; NEW_LINE a = { * R ( ) } ; NEW_LINE i = 0 NEW_LINE while { i } & a : i += 1 NEW_LINE print ( n + ( k > 0 ) * ( k , i + max ( a ) + 1 >> 1 not in a ) [ i < n ] ) NEW_LINE DEDENT","R = lambda : map ( int , input ( ) . split ( ) ) NEW_LINE t , = R ( ) NEW_LINE exec ( t * ' n , k = R ( ) ; a = { * R ( ) } ; i = 0 \\n while { i } & a : i + = 1 \\n print ( n + ( k > 0 ) * ( k , i + max ( a ) + 1 > > 1not ▁ in ▁ a ) [ i < n ] ) \\n ' ) NEW_LINE"],"bleu":0.0011319780441172312,"rouge_l":0.07419119435660425}
{"id":299,"predictions":["n , m = map ( int , input ( ) . split ( ) )   def solve ( ) : a , b = map ( int , input ( ) . split ( ) )   return a + b * ( n - 1 ) \/\/ m     a , b = map ( int , input ( ) . split ( ) ) print ( solve ( ) ) NEW_LINE"],"references":["import mathn , m = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) q = list ( map ( int , input ( ) . split ( ) ) ) if m > n : print ( \"0\/1\" ) elif n > m : if ( l [ 0 ] > 0 and q [ 0 ] > 0 ) or ( l [ 0 ] < 0 and q [ 0 ] < 0 ) : print ( \" Infinity \" ) else : print ( \" - Infinity \" )           else : a = abs ( l [ 0 ] ) b = abs ( q [ 0 ] ) while math . gcd ( a , b ) > 1 : c = math . gcd ( a , b ) a = a \/\/ c b = b \/\/ c if l [ 0 ] > 0 and q [ 0 ] > 0 : print ( str ( a ) + \" \/ \" + str ( b ) ) elif l [ 0 ] < 0 and q [ 0 ] < 0 : print ( str ( a ) + \" \/ \" + str ( b ) ) else : print ( \" - \" + str ( a ) + \" \/ \" + str ( b ) )   \t \t       \t \t   NEW_LINE","from sys import stdin , stdoutfrom math import gcdnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE","from fractions import Fractiondef limit ( a , b ) :   if len ( a ) > len ( b ) : if ( a [ 0 ] > 0 and b [ 0 ] > 0 ) or ( a [ 0 ] < 0 and b [ 0 ] < 0 ) : return \" Infinity \" else : return \" - Infinity \" if len ( b ) > len ( a ) : return \"0\" + \" \/ \" + \"1\" else : c = \" \" if a [ 0 ] < 0 and b [ 0 ] > 0 : c = \" - \" if a [ 0 ] > 0 and b [ 0 ] < 0 : c = \" - \" a [ 0 ] = abs ( a [ 0 ] ) b [ 0 ] = abs ( b [ 0 ] ) ans = Fraction ( a [ 0 ] \/ b [ 0 ] ) . limit_denominator ( ) . as_integer_ratio ( ) return c + str ( ans [ 0 ] ) + \" \/ \" + str ( ans [ 1 ] ) a = input ( ) lst = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) lst2 = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) print ( limit ( lst , lst2 ) ) NEW_LINE","from math import factorial , gcddef limit ( n , m , a0 , b0 ) : if n < m : return \"0\/1\" elif n > m : if a0 \/ b0 < 0 : return \" - Infinity \" else : return \" Infinity \" else : if a0 == 0 : return \"0\/1\" elif b0 == 0 : if a0 >= 0 : return \" Infinity \" else : return \" - Infinity \" a = a0 * factorial ( n ) b = b0 * factorial ( m ) hcf = gcd ( a , b ) a = a \/\/ hcf b = b \/\/ hcf if ( a < 0 and b > 0 ) or ( a > 0 and b < 0 ) : return ( \" - \" + str ( abs ( a ) ) + \" \/ \" + str ( abs ( b ) ) ) else : return ( str ( abs ( a ) ) + \" \/ \" + str ( abs ( b ) ) ) n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) print ( limit ( n , m , a [ 0 ] , b [ 0 ] ) ) NEW_LINE"],"bleu":0.6641340222743298,"rouge_l":0.5773318966772475}
{"id":300,"predictions":["t = int ( input ( ) ) for _ in range ( t ) : n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) ans = 0 mm = 0 for i in range ( n - 1 ) : if ( a [ i ] - a [ i + 1 ] ) == 0 : mm = abs ( a [ i ] - a [ i + 1 ] ) ans += abs ( a [ i ] - a [ i + 1 ] ) print ( ans ) NEW_LINE"],"references":["t = int ( input ( ) )   for tc in range ( t ) : n = int ( input ( ) )   athletes = [ int ( z ) for z in input ( ) . split ( ) ]   athletes . sort ( )   res = [ ]   for i in range ( 1 , n ) : a = athletes [ : i ] b = athletes [ i : ]   res . append ( abs ( max ( a ) - min ( b ) ) )   print ( min ( res ) ) NEW_LINE","for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) s = list ( map ( int , input ( ) . split ( ) ) ) s . sort ( ) x = [ ] for i in range ( 1 , n ) : x . append ( s [ i ] - s [ i - 1 ] ) print ( min ( x ) ) NEW_LINE","n = int ( input ( ) ) for i in range ( n ) : x = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l . sort ( ) s = [ None ] * ( x - 1 ) for i in range ( x - 1 ) : s [ i ] = ( l [ i + 1 ] - l [ i ] ) print ( min ( s ) ) NEW_LINE","import math     def main ( ) : t = int ( input ( ) ) for _ in range ( t ) : n = int ( input ( ) ) arr = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) ma = math . inf for i in range ( 0 , n - 1 ) : ma = min ( ma , arr [ i + 1 ] - arr [ i ] ) print ( ma )     if __name__ == ' _ _ main _ _ ' : main ( ) NEW_LINE","t = int ( input ( ) ) for i in range ( t ) : n = int ( input ( ) ) min = 999999 a = list ( map ( int , input ( ) . split ( ) ) ) a . sort ( ) if ( len ( set ( a ) ) == len ( a ) ) : for i in range ( n - 1 ) : if ( a [ i + 1 ] - a [ i ] < min ) : min = a [ i + 1 ] - a [ i ] print ( min , ' \\n ' ) else : print ( 0 , ' \\n ' ) NEW_LINE"],"bleu":0.6932052360435147,"rouge_l":0.7076960833528553}
{"id":301,"predictions":["for t in range ( int ( input ( ) ) ) : n = int ( input ( ) ) print ( n * ( n + 1 ) \/\/ 2 ) NEW_LINE"],"references":["n = int ( input ( ) ) arr = [ [ 0 , 0 ] for i in range ( n ) ]   for i in range ( n ) : arr [ i ] [ 0 ] , arr [ i ] [ 1 ] = map ( int , input ( ) . split ( ) )   NEW_LINE","n = int ( input ( ) ) now = 0 for i in range ( n ) : s , d = map ( int , input ( ) . split ( ) ) now = max ( now + 1 , s ) now = ( now + d - 1 - s ) \/\/ d * d + sprint ( now ) NEW_LINE","def solve ( arr ) : day = arr [ 0 ] [ 0 ] + 1 for i in range ( 1 , len ( arr ) ) : if day > arr [ i ] [ 0 ] : n = ( day - arr [ i ] [ 0 ] ) % arr [ i ] [ 1 ] if n == 0 : day += 1 else : n = ( ( day - arr [ i ] [ 0 ] ) \/\/ arr [ i ] [ 1 ] ) + 1 day += arr [ i ] [ 0 ] + n * arr [ i ] [ 1 ] - day + 1 else : day += arr [ i ] [ 0 ] - day + 1 return day - 1                                         def main ( ) : NEW_LINE","a = 0 for i in range ( int ( input ( ) ) ) : s , d = list ( map ( int , input ( ) . split ( ) ) ) a += 1 while a < s or ( a - s ) % d != 0 : a += 1 print ( a ) NEW_LINE"],"bleu":0.2566661814591969,"rouge_l":0.44057780695994747}
{"id":302,"predictions":["for _ in range ( int ( input ( ) ) ) : n , k = map ( int , input ( ) . split ( ) ) k = [ int ( i ) for i in input ( ) . split ( ) ] lis = [ 1 ] * n for i in k : lis [ i + 1 ] = 0 t = 1 newlis = lis [ : ] while sum ( lis ) : for i in range ( n ) : if lis [ i ] == 0 : newlis [ max ( 0 , i - 1 ) ] = 0 newlis [ min ( n - 1 , i + 1 ) ] = 0 lis = newlis [ : ] t += 1 print ( t ) NEW_LINE"],"references":["def binary ( data , target , low , high ) : if low > high : return high else : mid = int ( ( low + high ) \/ 2 ) if data [ mid ] <= target : return binary ( data , target , mid + 1 , high ) else : return binary ( data , target , low , mid - 1 ) for _ in range ( int ( input ( ) ) ) : a , b = map ( int , input ( ) . split ( ) ) l = [ 1 ] n = 1 for i in range ( 1 , a - 1 ) : l . append ( l [ - 1 ] + n ) n += 1 result = [ \" a \" ] * a k = binary ( l , b , 0 , len ( l ) - 1 ) k += 1 result [ a - 1 - k ] = \" b \" result [ - 1 - ( b - l [ k - 1 ] ) ] = \" b \" print ( * result , sep = \" \" )   NEW_LINE","for _ in range ( int ( input ( ) ) ) : n , k = map ( int , input ( ) . split ( ) ) s = [ ' a ' ] * n for i in range ( 1 , n + 1 ) : c = ( i * ( i + 1 ) ) \/\/ 2 if k <= c : pos1 = i pos2 = c - k break NEW_LINE","from sys import stdininput = stdin . buffer . readlineimport math   t = int ( input ( ) ) for i in range ( t ) : n , k = map ( int , input ( ) . split ( ) )   x = math . floor ( ( math . sqrt ( 1 + 4 * 2 * k ) - 1 ) \/ 2 ) sx = ( x * ( x + 1 ) ) \/\/ 2 m = k - sx if m == 0 : s = \" bb \" + \" a \" * ( x - 1 ) s = ( n - len ( s ) ) * \" a \" + s print ( s ) continue   s = \" a \" * ( n - ( x + 2 ) ) + \" b \" ss = \" b \" + ( m - 1 ) * \" a \" l = len ( s ) + len ( ss ) print ( s + ( n - l ) * \" a \" + ss )     NEW_LINE","def binary ( data , target , low , high ) : if low > high : return high else : mid = int ( ( low + high ) \/ 2 ) if data [ mid ] <= target : return binary ( data , target , mid + 1 , high )     else : return binary ( data , target , low , mid - 1 )           for _ in range ( int ( input ( ) ) ) : a , b = map ( int , input ( ) . split ( ) ) total = int ( ( a * ( a - 1 ) ) \/ 2 ) l = [ 1 ] n = 1 for i in range ( 1 , a - 1 ) : l . append ( l [ - 1 ] + n ) n += 1 result = [ \" a \" ] * a   k = binary ( l , b , 0 , len ( l ) - 1 ) k += 1   kalan = b - l [ k - 1 ] aa = a - 1 - k result [ aa ] = \" b \"     aaa = - 1 - kalan result [ aaa ] = \" b \" print ( * result , sep = \" \" ) NEW_LINE"],"bleu":0.42750260661934963,"rouge_l":0.5865384615384615}
{"id":303,"predictions":["t = int ( input ( ) ) for a in range ( t ) : n = int ( input ( ) ) bt = list ( map ( int , input ( ) . split ( ) ) ) bt . sort ( ) print ( abs ( bt [ n - 1 ] - bt [ n - 1 ] ) ) NEW_LINE"],"references":["n , t = [ int ( item ) for item in input ( ) . split ( ' ▁ ' ) ] cont , ans = [ ] , 2 for i in range ( n ) : hcenter , hlen = [ float ( item ) for item in input ( ) . split ( ' ▁ ' ) ] NEW_LINE","n , t = [ int ( item ) for item in input ( ) . split ( ' ▁ ' ) ] cont , ans = list ( ) , 2 for i in range ( n ) : hCenter , hLen = [ float ( item ) for item in input ( ) . split ( ' ▁ ' ) ] NEW_LINE","n , t = [ int ( item ) for item in input ( ) . split ( ' ▁ ' ) ] cont , ans = [ ] , 2 for i in range ( n ) : hcenter , hlen = [ int ( item ) for item in input ( ) . split ( ' ▁ ' ) ] cont . append ( [ hcenter - hlen \/ 2 , hcenter + hlen \/ 2 ] )   NEW_LINE","n , t = list ( map ( int , input ( ) . split ( ) ) ) a = sorted ( [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] ) b = [ a [ i ] [ 0 ] - a [ i ] [ 1 ] \/ 2 - a [ i - 1 ] [ 0 ] - a [ i - 1 ] [ 1 ] \/ 2 for i in range ( 1 , n ) ] c = 2 for i in range ( n - 1 ) : c += int ( b [ i ] > t ) * 2 + int ( b [ i ] == t ) print ( c ) NEW_LINE"],"bleu":0.4498729856391739,"rouge_l":0.4785264335334981}
{"id":304,"predictions":["n = int ( input ( ) )   seq = [ int ( i ) for i in input ( ) . split ( ) ]   l_n = [ i for i in seq if i <= n ] ans = n - len ( set ( l_n ) )   print ( ans ) NEW_LINE"],"references":["n = int ( input ( ) ) x = 1 s = 1 while s <= n : x += 1 s += ( x * ( x + 1 ) ) \/\/ 2 print ( x - 1 ) NEW_LINE","n = int ( input ( ) ) k = 0 i = 0 z = 0 count = 0 while k < n : k = k + ( i + 1 ) z = z + k if z <= n : count += 1 i += 1 print ( count ) NEW_LINE","n = int ( input ( ) ) sum = 0 i = 0 for i in range ( 1 , n + 1 , 1 ) : for j in range ( 1 , i + 1 , 1 ) : sum += j if ( sum > n ) : breakif ( n < 4 ) : print ( 1 ) NEW_LINE","n = int ( input ( ) ) k = 0 c = 0 for i in range ( 1 , 10001 ) : k += i c += k if c == n : print ( i ) break if c >= n : print ( i - 1 ) break   NEW_LINE","n = int ( input ( ) ) sum = 0 result = 0 i = 1 count = 0 while sum <= n : result += i sum += result if sum > n : break i += 1 count += 1 print ( count ) NEW_LINE"],"bleu":0.24539956025497855,"rouge_l":0.45658682634730535}
{"id":305,"predictions":["import io , osinput = io . BytesIO ( os . read ( 0 , os . fstat ( 0 ) . st_size ) ) . readline from collections import defaultdict   n , m = map ( int , input ( ) . split ( ) ) adj = defaultdict ( list )   for i in range ( m ) : x , y = map ( int , input ( ) . split ( ) ) adj [ x ] . append ( y ) adj [ y ] . append ( x ) cmps = 0 v = [ 0 ] * ( n + 1 )   for i in range ( 1 , 1 + n ) : if not v [ i ] : q = [ i ] while q : e = q . pop ( ) v [ e ] = 1 for j in adj [ e ] : if not v [ j ] : q . append ( j ) cmps += 1 print ( \" FHTAGN ! \" if n == m and cmps == 1 else \" NO \" ) NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) adj = [ [ ] for i in range ( n ) ] used = [ 0 for i in range ( n ) ] mark = [ 0 for i in range ( n ) ] S = [ i for i in range ( n ) ]   for i in range ( m ) : u , v = map ( int , input ( ) . split ( ) ) u , v = u - 1 , v - 1 adj [ u ] . append ( v ) adj [ v ] . append ( u ) def dfs ( v ) : global S used [ v ] = 1 S2 , S3 = [ ] , [ ] for to in adj [ v ] : mark [ to ] = 1 for to in S : if mark [ to ] == 0 : S3 . append ( to ) else : S2 . append ( to ) for to in adj [ v ] : mark [ to ] = 0 S = S2 . copy ( ) for to in S3 : dfs ( to ) ans = - 1 for i in range ( n ) : if not used [ i ] : S . remove ( i ) ans += 1 dfs ( i )   print ( ans ) NEW_LINE","import sysfrom sys import stdin , stdout   n , m = stdin . readline ( ) . split ( ) n = int ( n ) m = int ( m ) e = set ( tuple ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( m ) ) a = set ( range ( 1 , n + 1 ) ) q = [ ] r = 0 while a : if q : u = q . pop ( ) else : u = a . pop ( ) r += 1 c = { v for v in a if ( u , v ) not in e and ( v , u ) not in e } a -= c q += cstdout . write ( str ( r - 1 ) + ' \\n ' ) NEW_LINE","def find ( u ) :   if parent [ u ] == u : return u   parent [ u ] = find ( parent [ u ] ) return parent [ u ]           def union ( a , b ) : if find ( a ) != find ( b ) : u = parent [ a ] v = parent [ b ]   if size [ u ] > size [ v ] : parent [ v ] = u size [ u ] += size [ v ] del size [ v ]   else : parent [ u ] = v size [ v ] += size [ u ] del size [ u ]       return           n , m = map ( int , input ( ) . split ( ) ) adj = [ [ ] for i in range ( n + 1 ) ] for j in range ( m ) : u , v = map ( int , input ( ) . split ( ) ) if u < v : adj [ v ] . append ( u )   else : adj [ u ] . append ( v )   size = dict ( ) parent = [ i for i in range ( n + 1 ) ] for v in range ( 1 , n + 1 ) : req = [ ] d1 = dict ( ) for j in adj [ v ] : f = find ( j ) req . append ( f ) if f in d1 : d1 [ f ] += 1 else : d1 [ f ] = 1   res = [ j for j in size ]   size [ v ] = 1     for i in res : if i not in d1 : union ( i , v )   elif d1 [ i ] < size [ i ] : union ( i , v )   print ( len ( size ) - 1 )           NEW_LINE"],"bleu":0.44038774580401463,"rouge_l":0.4910152378592667}
{"id":306,"predictions":["s = input ( ) ; print ( max ( int ( s [ 0 ] ) - int ( s [ 1 ] ) , int ( s [ 2 ] ) ) ) NEW_LINE"],"references":["def pod ( n ) : ans = 1 while n > 0 : ans *= ( n % 10 ) n = n \/\/ 10 return ansn = input ( ) ans = ( len ( n ) - 1 ) * 9 ans = max ( ans , pod ( int ( n ) ) ) sz = len ( n ) for i in range ( 1 , sz ) : ind = sz - i num = n [ : ind ] + '9' * ( sz - ind ) if int ( num ) > int ( n ) : if num [ ind - 1 ] == '0' : num = num [ : ind - 1 ] + '9' + num [ ind : ] else : num = num [ : ind - 1 ] + str ( int ( num [ ind - 1 ] ) - 1 ) + num [ ind : ] if int ( num ) <= int ( n ) : ans = max ( ans , pod ( int ( num ) ) ) print ( ans ) NEW_LINE","def f ( n ) : l = [ ] while n > 0 : l . append ( n % 10 ) n = n \/\/ 10 l . reverse ( ) ll = len ( l ) p1 = 1 pl = [ ] for i in range ( ll ) : p2 = l [ i ] if i == ll - 1 else max ( l [ i ] - 1 , 1 ) * 9 ** ( ll - i - 1 ) pl . append ( p1 * p2 ) p1 *= l [ i ] return max ( pl ) n = int ( input ( ) ) print ( f ( n ) ) NEW_LINE","def ans ( n ) : if ( n == 0 ) : return 1 if ( n <= 9 ) : return n return max ( n % 10 * ans ( n \/\/ 10 ) , 9 * ans ( n \/\/ 10 - 1 ) ) n = int ( input ( ) ) print ( ans ( n ) ) NEW_LINE","def prod ( num ) : if ( num == 0 ) : return 1 if ( num <= 9 ) : return num return max ( num % 10 * prod ( num \/\/ 10 ) , 9 * prod ( num \/\/ 10 - 1 ) ) n = int ( input ( ) ) print ( prod ( n ) ) NEW_LINE"],"bleu":0.12067617058622236,"rouge_l":0.33726741095162144}
{"id":307,"predictions":["n = int ( input ( ) ) NEW_LINE s = \" \" NEW_LINE if n < 8 : NEW_LINE INDENT s = \" \" NEW_LINE DEDENT else : NEW_LINE s = s + \"8\" NEW_LINE DEDENT print ( s ) NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) a = '9' * 200 + '0' * 199 + '1' b = '9' * 200 print ( a ) print ( b ) NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) print ( n * \"8\" ) print ( ( n - 1 ) * \"1\" + \"2\" ) NEW_LINE","n , m = [ int ( x ) for x in input ( ) . split ( ' ▁ ' ) ] print ( ( n - 1 ) * '4' + '5' ) print ( n * '5' ) NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) a = 1 for i in range ( n - 1 ) : a *= 10 a += 1 b = 10 ** n - aprint ( a ) print ( b ) NEW_LINE","for i in range ( 1000 ) : print ( 5 , end = \" \" ) print ( ) for i in range ( 999 ) : print ( 4 , end = \" \" ) print ( 5 ) NEW_LINE"],"bleu":0.14529580795237462,"rouge_l":0.3654377880184332}
{"id":308,"predictions":["n , a , b = map ( int , input ( ) . split ( ) ) lis = list ( map ( int , input ( ) . split ( ) ) ) for i in lis : x = ( i * a ) % b print ( int ( x \/ a ) ) NEW_LINE"],"references":["from sys import stdinfrom math import gcd     def main ( ) : input ( ) l = stdin . read ( ) . splitlines ( ) d = [ 3. , 1. , 2. , 2. , 2. , 1. ] * 16667 for i in range ( 4 , 100001 ) : for j in range ( i , 100001 , i ) : d [ j ] += 1. for i , s in enumerate ( l ) : a , b , c = map ( int , s . split ( ) ) k = gcd ( b , c ) ab = d [ gcd ( a , b ) ] ac = d [ gcd ( a , c ) ] bc = d [ k ] abc = d [ gcd ( a , k ) ] asz = d [ a ] - ab - ac + abc bsz = d [ b ] - bc - ab + abc csz = d [ c ] - ac - bc + abc absz = ab - abc bcsz = bc - abc acsz = ac - abc l [ i ] = ' % d ' % ( asz * bsz * csz + ( absz * ( asz + bsz ) * csz ) + ( bcsz * ( bsz + csz ) * asz ) + ( acsz * ( asz + csz ) * bsz ) + ( abc * ( asz * bsz + asz * csz + bsz * csz ) ) + ( abc * ( absz + bcsz + acsz ) * ( asz + bsz + csz ) ) + ( ( asz + bsz + csz + absz + bcsz + acsz ) * ( abc * ( abc + 1 ) * .5 ) ) + ( absz * bcsz * acsz ) + ( ( absz * ( absz + 1. ) * d [ c ] ) + ( bcsz * ( bcsz + 1. ) * d [ a ] ) + ( acsz * ( acsz + 1. ) * d [ b ] ) ) * .5 + ( ( asz + bsz + csz + abc ) * ( absz * acsz + absz * bcsz + bcsz * acsz ) ) + ( abc + ( abc * ( abc - 1. ) ) + ( abc * ( abc - 1. ) * ( abc - 2. ) \/ 6. ) ) ) print ( ' \\n ' . join ( map ( str , l ) ) )     if __name__ == ' _ _ main _ _ ' : main ( )         NEW_LINE","from sys import stdinfrom math import gcd     def main ( ) : input ( ) l = stdin . read ( ) . splitlines ( ) d = [ 3 , 1 , 2 , 2 , 2 , 1 ] * 16667 for i in range ( 4 , 100001 ) : for j in range ( i , 100001 , i ) : d [ j ] += 1 for i , s in enumerate ( l ) : a , b , c = map ( int , s . split ( ) ) k = gcd ( b , c ) ab = d [ gcd ( a , b ) ] ac = d [ gcd ( a , c ) ] bc = d [ k ] abc = d [ gcd ( a , k ) ] asz = d [ a ] - ab - ac + abc bsz = d [ b ] - bc - ab + abc csz = d [ c ] - ac - bc + abc absz = ab - abc bcsz = bc - abc acsz = ac - abc abcsz = abc l [ i ] = ( asz * bsz * csz + ( absz * ( asz + bsz ) * csz ) + ( bcsz * ( bsz + csz ) * asz ) + ( acsz * ( asz + csz ) * bsz ) + ( abcsz * ( asz * bsz + asz * csz + bsz * csz ) ) + ( abcsz * ( absz + bcsz + acsz ) * ( asz + bsz + csz ) ) + ( ( asz + bsz + csz + absz + bcsz + acsz ) * ( abcsz * ( abcsz + 1 ) \/\/ 2 ) ) + ( absz * bcsz * acsz ) + ( ( absz * ( absz + 1 ) * d [ c ] ) + ( bcsz * ( bcsz + 1 ) * d [ a ] ) + ( acsz * ( acsz + 1 ) * d [ b ] ) ) \/\/ 2 + ( ( asz + bsz + csz + abcsz ) * ( absz * acsz + absz * bcsz + bcsz * acsz ) ) + ( abcsz + ( abcsz * ( abcsz - 1 ) ) + ( abcsz * ( abcsz - 1 ) * ( abcsz - 2 ) \/\/ 6 ) ) ) print ( ' \\n ' . join ( map ( str , l ) ) )     if __name__ == ' _ _ main _ _ ' : main ( ) NEW_LINE","from sys import stdinfrom math import gcd     def main ( ) : input ( ) l = stdin . read ( ) . splitlines ( ) d = [ 3. , 1. , 2. , 2. , 2. , 1. ] * 16667 for i in range ( 4 , 100001 ) : for j in range ( i , 100001 , i ) : d [ j ] += 1. for i , s in enumerate ( l ) : a , b , c = map ( int , s . split ( ) ) k = gcd ( b , c ) ab = d [ gcd ( a , b ) ] ac = d [ gcd ( a , c ) ] bc = d [ k ] abc = d [ gcd ( a , k ) ] asz = d [ a ] - ab - ac + abc bsz = d [ b ] - bc - ab + abc csz = d [ c ] - ac - bc + abc absz = ab - abc bcsz = bc - abc acsz = ac - abc l [ i ] = ' % d ' % ( asz * bsz * csz + ( absz * ( asz + bsz ) * csz ) + ( bcsz * ( bsz + csz ) * asz ) + ( acsz * ( asz + csz ) * bsz ) + ( abc * ( asz * bsz + asz * csz + bsz * csz ) ) + ( abc * ( absz + bcsz + acsz ) * ( asz + bsz + csz ) ) + ( ( asz + bsz + csz + absz + bcsz + acsz ) * ( abc * ( abc + 1 ) * .5 ) ) + ( absz * bcsz * acsz ) + ( ( absz * ( absz + 1. ) * d [ c ] ) + ( bcsz * ( bcsz + 1. ) * d [ a ] ) + ( acsz * ( acsz + 1. ) * d [ b ] ) ) * .5 + ( ( asz + bsz + csz + abc ) * ( absz * acsz + absz * bcsz + bcsz * acsz ) ) + ( abc + ( abc * ( abc - 1. ) ) + ( abc * ( abc - 1. ) * ( abc - 2. ) \/ 6. ) ) ) print ( ' \\n ' . join ( map ( str , l ) ) )     if __name__ == ' _ _ main _ _ ' : main ( ) NEW_LINE"],"bleu":0.00034019412404849705,"rouge_l":0.11791020047495443}
{"id":309,"predictions":["n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) )   water = 0 NEW_LINE"],"references":["m = [ ] for _ in range ( int ( input ( ) ) ) : l = list ( map ( int , input ( ) . split ( ) ) ) x = sum ( l ) m . append ( x ) j = sorted ( m , reverse = True ) NEW_LINE","n = int ( input ( ) ) li = [ ] for i in range ( n ) : A , B , C , D = map ( int , input ( ) . split ( ) ) sum_1 = A + B + C + D li . append ( sum_1 )   a = li [ 0 ] li . sort ( reverse = True ) print ( li . index ( a ) + 1 ) NEW_LINE","n = int ( input ( ) ) l = [ ] for i in range ( 0 , n ) : E , G , M , H = map ( int , input ( ) . strip ( ) . split ( ) ) l . append ( E + G + M + H )   jh = l [ 0 ] l . sort ( reverse = True ) print ( l . index ( jh ) + 1 ) NEW_LINE","n = int ( input ( ) ) l = [ ] for i in range ( n ) : a = list ( map ( int , input ( ) . split ( ) ) ) l . append ( sum ( a ) ) cnt = 1 for i in l : if i > l [ 0 ] : cnt += 1 print ( cnt ) NEW_LINE","l = [ ] for i in range ( int ( input ( ) ) ) : l . append ( sum ( list ( map ( int , input ( ) . split ( ) ) ) ) ) print ( sum ( 1 for i in l if i > l [ 0 ] ) + 1 ) NEW_LINE"],"bleu":0.31384178414054453,"rouge_l":0.5506225009695235}
{"id":310,"predictions":["'''   ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Online ▁ Python ▁ Compiler . ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Code , ▁ Compile , ▁ Run ▁ and ▁ Debug ▁ python ▁ program ▁ online . Write ▁ your ▁ code ▁ in ▁ this ▁ editor ▁ and ▁ press ▁ \" Run \" ▁ button ▁ to ▁ execute ▁ it .   '''   n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) m = [ 0 ] * ne = 0 o = 0 for i in range ( n ) : if ( i + 1 ) % 2 == 0 ) : e += l [ i ] m [ i ] = 1 else : o += l [ i ] m [ i ] = 2 o -= l [ 0 ] c = 0 if ( e == o ) : c += 1 print ( c ) NEW_LINE"],"references":["from sys import stdin , stdoutfrom itertools import accumulatenmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE","n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) d = { } for i in range ( n ) : d [ a [ i ] ] = 1 a . sort ( reverse = True ) ans = 0 for i in range ( n ) : if d [ a [ i ] ] > 0 : if a [ i ] % k == 0 : x = a [ i ] \/\/ k if x in d : d [ x ] -= 1 ans += 1 print ( ans ) NEW_LINE"],"bleu":0.2034547849598289,"rouge_l":0.4033642691415313}
{"id":311,"predictions":["def STR ( ) : return list ( input ( ) ) def INT ( ) : return int ( input ( ) ) def MAP ( ) : return map ( int , input ( ) . split ( ) ) def MAP2 ( ) : return map ( float , input ( ) . split ( ) ) def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) def STRING ( ) : return input ( ) import stringimport sysfrom heapq import heappop , heappushfrom bisect import * from collections import deque , Counter , defaultdictfrom math import * from itertools import permutations , accumulatedx = [ - 1 , 1 , 0 , 0 ] dy = [ 0 , 0 , 1 , - 1 ] NEW_LINE"],"references":["import sysimport itertoolsimport collections   n = int ( input ( ) ) A = [ int ( x ) for x in input ( ) . split ( ) ] perms = [ ]   def bits ( lst ) : a = [ ] for val in lst : s = [ ] for shift in range ( 29 , - 1 , - 1 ) : s += [ str ( val >> shift & 1 ) ] a += [ ' ' . join ( s [ : : - 1 ] ) ] return a   def calcCost ( perm ) : f = lambda a , b : ( ( a | b ) - b ) a = f ( perm [ 0 ] , perm [ 1 ] ) for i in range ( 2 , len ( perm ) ) : a = f ( a , perm [ i ] ) return a   def bruteForce ( ) : global perms for perm in list ( itertools . permutations ( A ) ) : perms += [ ( perm , calcCost ( perm ) ) ] print ( * perms , sep = \" \\n \" )   NEW_LINE","n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) fl = Falsemax_ans = 0 for i in range ( n ) : ans = arr [ i ] for j in range ( n ) : if i != j : ans = ans & ( ~ arr [ j ] ) if ans <= max_ans : break NEW_LINE","n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) s = set ( ) for i in range ( 32 , - 1 , - 1 ) : cnt = 0 bs = [ ] for c in arr : if ( c >> i ) & 1 : cnt += 1 bs . append ( c ) if cnt == 1 and bs [ 0 ] not in s : print ( bs [ 0 ] , end = \" ▁ \" ) s . add ( bs [ 0 ] ) for c in arr : if c not in s : print ( c , end = \" ▁ \" ) NEW_LINE","n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) bs = 0 for i in range ( 32 , - 1 , - 1 ) : cnt = 0 for j , c in enumerate ( arr ) : if ( c >> i ) & 1 : cnt += 1 bs = j if cnt == 1 : breakprint ( arr [ bs ] , end = \" ▁ \" ) for j , c in enumerate ( arr ) : if j != bs : print ( c , end = \" ▁ \" ) NEW_LINE","def solve ( a ) : count = [ 0 ] * 30 for e in a : for i in range ( 30 ) : if e & ( 1 << i ) : count [ i ] += 1 i = 29 while i >= 0 and count [ i ] != 1 : i -= 1 if i < 0 : return a for j in range ( len ( a ) ) : if a [ j ] & ( 1 << i ) : return [ a [ j ] ] + a [ : j ] + a [ j + 1 : ] assert False     n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) print ( * solve ( a ) ) NEW_LINE"],"bleu":0.25194181233830515,"rouge_l":0.3892674066599395}
{"id":312,"predictions":["from sys import stdinn = int ( stdin . readline ( ) ) s = stdin . readline ( ) [ : - 1 ] ans = 10000 t = 0 for i in range ( n ) : s = stdin . readline ( ) . replace ( ' ▁ ' , ' ' ) if s [ i ] == ' A ' and s [ i ] == ' G ' : s [ i ] = s [ i ] + s [ i + 1 ] elif s [ i ] == ' S ' : s [ i ] = s [ i ] elif s [ i ] == ' T ' : s [ i ] = s [ i + 1 ] ans = min ( ans , t ) if ans == 10 : print ( - 1 ) else : print ( ans ) NEW_LINE"],"references":["t , sx , sy , ex , ey = map ( int , input ( ) . split ( ) ) winds = list ( input ( ) ) def dist ( x , y ) : return abs ( x - ex ) + abs ( y - ey ) for zzz in range ( t ) : new_x , new_y = sx , sy if ( winds [ zzz ] == ' N ' ) : new_y += 1 if ( winds [ zzz ] == ' S ' ) : new_y -= 1 if ( winds [ zzz ] == ' E ' ) : new_x += 1 if ( winds [ zzz ] == ' W ' ) : new_x -= 1 if ( dist ( new_x , new_y ) < dist ( sx , sy ) ) : sx = new_x sy = new_y if ( sx == ex and sy == ey ) : if ( zzz + 1 <= t ) : print ( zzz + 1 ) breakelse : print ( - 1 ) NEW_LINE","t , s1 , s2 , e1 , e2 = [ int ( i ) for i in input ( ) . split ( ) ] s = input ( ) total = abs ( s1 - e1 ) + abs ( s2 - e2 ) time = 0 for i in s : if total == 0 : break if i == ' E ' : if ( ( e1 - s1 ) > 0 ) : total -= 1 s1 += 1 time += 1 if i == ' W ' : if ( ( e1 - s1 ) < 0 ) : total -= 1 s1 -= 1 time += 1 if i == ' N ' : if ( ( e2 - s2 ) > 0 ) : total -= 1 s2 += 1 time += 1 if i == ' S ' : if ( ( e2 - s2 ) < 0 ) : total -= 1 s2 -= 1 time += 1 if s1 == e1 and s2 == e2 : print ( time ) else : print ( - 1 ) NEW_LINE","t , s1 , s2 , e1 , e2 = map ( int , input ( ) . split ( ) ) drc = input ( ) x = e1 - s1y = e2 - s2time = 0 for i in drc : if x == 0 and y == 0 : break elif x != 0 and x > 0 and i == ' E ' : x -= 1 elif x != 0 and x < 0 and i == ' W ' : x += 1 elif y != 0 and y > 0 and i == ' N ' : y -= 1 elif y != 0 and y < 0 and i == ' S ' : y += 1 time += 1 if x == 0 and y == 0 : print ( time ) else : print ( - 1 )   NEW_LINE","( t , sx , sy , ex , ey ) = tuple ( map ( int , input ( ) . split ( ' ▁ ' ) ) ) wind = input ( ) ( tp , d , r , l ) = ( 0 , 0 , 0 , 0 ) if ex >= sx : r = ex - sx if ey >= sy : tp = ey - sy else : d = sy - eyelse : l = sx - ex if ey >= sy : tp = ey - sy else : d = sy - ey   NEW_LINE"],"bleu":0.21312208796799434,"rouge_l":0.3762732119874977}
{"id":313,"predictions":["n , a , b = map ( int , input ( ) . split ( ) ) l = [ ] for i in range ( n ) : a , b = map ( int , input ( ) . split ( ) ) l . append ( a * b ) print ( min ( l ) * a , b ) NEW_LINE"],"references":["days = int ( input ( ) ) dailyReq = [ ] dailyPrice = [ ] totalCost = 0 for day in range ( days ) : a , p = input ( ) . split ( ) dailyReq . append ( int ( a ) ) dailyPrice . append ( int ( p ) )   minPrice = dailyPrice [ 0 ] for day in range ( days ) : if ( dailyPrice [ day ] < minPrice ) : minPrice = dailyPrice [ day ] totalCost += dailyReq [ day ] * minPrice   print ( totalCost )   NEW_LINE","n = int ( input ( ) ) c = 0 for i in range ( n ) : a , b = map ( int , input ( ) . split ( ) ) if i == 0 : m = b c = a * b else : m = min ( m , b ) c = c + m * aprint ( c ) NEW_LINE","t = int ( input ( ) ) meat = [ ] money = [ ] while t > 0 : num = [ int ( i ) for i in input ( ) . split ( ) ] a = num [ 0 ] b = num [ 1 ] meat . append ( a ) money . append ( b ) t = t - 1 meat . append ( 0 ) money . append ( 0 ) tot = 0 i = 0 while i < len ( money ) - 1 : if money [ i ] < money [ i + 1 ] : money [ i + 1 ] = money [ i ] tot = tot + ( meat [ i ] * money [ i ] ) i = i + 1 else : tot = tot + ( meat [ i ] * money [ i ] ) i = i + 1 print ( tot ) NEW_LINE","t = int ( input ( ) ) meat = [ ] money = [ ] while t > 0 : num = [ int ( i ) for i in input ( ) . split ( ) ] a = num [ 0 ] b = num [ 1 ] meat . append ( a ) money . append ( b ) t = t - 1 tot = 0 min = money [ 0 ] for i in range ( len ( meat ) ) : if money [ i ] < min : min = money [ i ] tot = tot + min * meat [ i ] print ( tot ) NEW_LINE","import sysfrom os import pathif ( path . exists ( ' input . txt ' ) and path . exists ( ' output . txt ' ) ) : sys . stdout = open ( ' output . txt ' , ' w ' ) sys . stdin = open ( ' input . txt ' , ' r ' )     def main ( ) : N = int ( input ( ) ) min_price = 200 ans = 0 for i in range ( N ) : a , p = map ( int , input ( ) . split ( ) ) min_price = min ( min_price , p ) ans += min_price * a print ( ans )   main ( ) NEW_LINE"],"bleu":0.5408224051260239,"rouge_l":0.6049830672472181}
{"id":314,"predictions":["n = int ( input ( ) ) s = list ( map ( int , input ( ) . strip ( ) ) ) s [ : : - 1 ] s2 = s [ : : - 1 ] i = 0 while i < n - 1 : s [ i ] = s [ i ] i += 1 while i < n : if s [ i ] == s [ s [ i - 1 ] ] : s [ i ] = s [ i ] - 1 i += 1 else : s [ i ] = s [ i ] i += 1 print ( max ( s1 , s2 ) ) NEW_LINE"],"references":["import sysimport mathfrom collections import defaultdict , dequeimport heapqs = sys . stdin . readline ( ) [ : - 1 ] ans = 0 n = len ( s ) mink = nfor i in range ( n - 1 , - 1 , - 1 ) : k = 1 z = True while i + 2 * k < n and z : if s [ i ] == s [ i + k ] == s [ i + 2 * k ] : z = False continue k += 1 if not z : mink = min ( mink , i + 2 * k ) NEW_LINE"],"bleu":0.1696632865278818,"rouge_l":0.4048291443095171}
{"id":315,"predictions":["def STR ( ) : return list ( input ( ) ) def INT ( ) : return int ( input ( ) ) def MAP ( ) : return map ( int , input ( ) . split ( ) ) def MAP2 ( ) : return map ( float , input ( ) . split ( ) ) def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) def STRING ( ) : return input ( ) import stringimport sysfrom heapq import heappop , heappushfrom bisect import * from collections import deque , Counter , defaultdictfrom math import * from itertools import permutations , accumulatedx = [ - 1 , 1 , 0 , 0 ] dy = [ 0 , 0 , 1 , - 1 ] NEW_LINE"],"references":["c = 0 def backtracking ( actuales , restantes , l , r , x ) : global c if sum ( actuales ) <= r and sum ( actuales ) >= l : if max ( actuales ) - min ( actuales ) >= x : c += 1 if restantes : for i in range ( len ( restantes ) ) : backtracking ( actuales + [ restantes [ i ] ] , restantes [ i + 1 : ] , l , r , x ) return 0 def main ( ) : n , l , r , x = input ( ) . split ( \" ▁ \" ) n , l , r , x = int ( n ) , int ( l ) , int ( r ) , int ( x ) difficulties = input ( ) . split ( \" ▁ \" ) for i in range ( len ( difficulties ) ) : difficulties [ i ] = int ( difficulties [ i ] ) difficulties . sort ( ) backtracking ( [ ] , difficulties , l , r , x ) global c return c if __name__ == \" _ _ main _ _ \" : print ( main ( ) ) NEW_LINE","n , l , r , x = map ( int , input ( ) . split ( ) ) c = [ int ( i ) for i in input ( ) . split ( ) ] ans = 0 for bit in range ( 2 , 1 << n ) : probs = [ ] t = 0 for i in range ( n ) : if bit & ( 1 << i ) : probs . append ( c [ i ] ) t += c [ i ] a = min ( probs ) b = max ( probs )   if t >= l and t <= r and abs ( a - b ) >= x : ans += 1 print ( ans ) NEW_LINE","_n , l , r , x = map ( int , input ( \" \" ) . split ( ) ) c = list ( map ( int , input ( ) . split ( ) ) ) count = 0 def backtrack ( s , l , r , x , c , i , level , min , max ) : NEW_LINE","from sys import stdin , stdoutfrom collections import dequeinput = stdin . readline def main ( ) : NEW_LINE","n , l , r , x = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) ans = 0 for i in range ( 1 , ( 2 ** n ) + 1 ) : j = bin ( i ) j = j [ 2 : ] if len ( j ) < n : j = '0' * ( n - len ( j ) ) + j NEW_LINE"],"bleu":0.2666776519287227,"rouge_l":0.48364946889226107}
{"id":316,"predictions":["import sysfrom functools import lru_cache , cmp_to_keyfrom heapq import merge , heapify , heappop , heappushfrom math import * from collections import defaultdict as dd , deque , Counter as Cfrom itertools import combinations as comb , permutations as permfrom bisect import bisect_left as bl , bisect_right as br , bisect , insortfrom time import perf_counterfrom fractions import Fractionimport copyfrom copy import deepcopyimport timestarttime = time . time ( ) mod = int ( pow ( 10 , 9 ) + 7 ) mod2 = 998244353   def data ( ) : return sys . stdin . readline ( ) . strip ( ) def out ( * var , end = \" \\n \" ) : sys . stdout . write ( ' ▁ ' . join ( map ( str , var ) ) + end ) def L ( ) : return list ( sp ( ) ) def sl ( ) : return list ( ssp ( ) ) def sp ( ) : return map ( int , data ( ) . split ( ) ) def ssp ( ) : return map ( str , data ( ) . split ( ) ) def l1d ( n , val = 0 ) : return [ val for i in range ( n ) ] def l2d ( n , m , val = 0 ) : return [ l1d ( n , val ) for j in range ( m ) ] try : NEW_LINE"],"references":["n = int ( input ( ) ) NEW_LINE start , end = 0 , 0 NEW_LINE flag = 0 l NEW_LINE s = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( 1 , ( n + 1 ) ) : if NEW_LINE ls [ i - 1 ] != i : start = i NEW_LINE breakfor NEW_LINE j in range ( n , i - 1 , - 1 ) : NEW_LINE if ls [ j - 1 ] != j : end = j NEW_LINE breakif NEW_LINE start == 0 and end == 0 : flag = 1 NEW_LINE print ( \"0 ▁ 0\" ) else : for i in range ( start - 1 , end - 1 ) : if NEW_LINE ls [ i ] < ls [ i + 1 ] : print ( \"0 ▁ 0\" ) NEW_LINE flag = 1 NEW_LINE breakif NEW_LINE flag == 0 : print ( str ( start ) + \" ▁ \" + str ( end ) ) NEW_LINE","def res ( ) : n = int ( input ( ) ) NEW_LINE v = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE ans = sorted ( v ) NEW_LINE if ( v == ans ) : return \"0 ▁ 0\"   try : ini = 0 NEW_LINE temp = [ ] NEW_LINE while v [ ini ] < v [ ini + 1 ] : temp . append ( v [ ini ] ) NEW_LINE ini += 1 NEW_LINE fim = ini NEW_LINE v2 = [ ] NEW_LINE while fim < n - 1 and v [ fim ] > v [ fim + 1 ] : v2 . append ( v [ fim ] ) NEW_LINE fim += 1 NEW_LINE v2 . append ( v [ fim ] ) NEW_LINE ini += 1 NEW_LINE fim += 1 NEW_LINE temp += v2 [ : : - 1 ] + v [ fim : ] NEW_LINE if temp == ans : NEW_LINE INDENT return str ( ini ) + ' ▁ ' + str ( fim ) else : NEW_LINE return \"0 ▁ 0\" except : return \"0 ▁ 0\" NEW_LINE DEDENT def main ( ) : print ( res ( ) ) NEW_LINE   main ( ) NEW_LINE","n = int ( input ( ) ) NEW_LINE s = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : s . append ( i ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l = - 1 NEW_LINE r = n - 1 NEW_LINE for i in range ( n ) : if NEW_LINE i + 1 != a [ i ] and l == - 1 : l = i NEW_LINE breakfor NEW_LINE i in range ( n - 1 , l , - 1 ) : NEW_LINE if i + 1 != a [ i ] and l != - 1 : r = i NEW_LINE breakb = a [ : : - 1 ] NEW_LINE if s == b and s != a : NEW_LINE INDENT print ( 1 , n ) elif s == a [ : l ] + a [ r : l - 1 : - 1 ] + a [ r + 1 : ] and s != a : NEW_LINE print ( l + 1 , r + 1 ) else : NEW_LINE print ( 0 , 0 ) NEW_LINE DEDENT","def spoilt ( arr ) : arr = [ 0 ] + arr NEW_LINE ans = [ 0 , 0 ] NEW_LINE cnt = 0 NEW_LINE temp = 0 NEW_LINE flag = False NEW_LINE for i in range ( 1 , len ( arr ) ) : if NEW_LINE arr [ i ] != i and flag == False : ans [ 0 ] = i NEW_LINE temp = i NEW_LINE flag = True NEW_LINE if arr [ i ] == temp : ans [ 1 ] = i NEW_LINE break NEW_LINE arr = arr [ : ans [ 0 ] ] + arr [ ans [ 0 ] : ans [ 1 ] + 1 ] [ : : - 1 ] + arr [ ans [ 1 ] + 1 : ] NEW_LINE if arr != sorted ( arr ) : print ( 0 , 0 ) NEW_LINE return \" \" NEW_LINE print ( * ans ) NEW_LINE return \" \"   a = int ( input ( ) ) NEW_LINE lst = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) NEW_LINE print ( spoilt ( lst ) ) NEW_LINE","n = int ( input ( ) ) NEW_LINE k = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( 1 , n + 1 ) : if NEW_LINE i != k [ i ] : t = k [ i ] NEW_LINE k [ i : t + 1 ] = k [ i : t + 1 ] [ : : - 1 ] NEW_LINE if k == [ * range ( n + 1 ) ] : NEW_LINE INDENT print ( i , t ) else : NEW_LINE print ( 0 , 0 ) NEW_LINE DEDENT exit ( ) NEW_LINE print ( 0 , 0 ) NEW_LINE"],"bleu":0.15754682319328114,"rouge_l":0.272608658286}
{"id":317,"predictions":["import sys , mathsys . setrecursionlimit ( 10 ** 8 ) ''' def ▁ fun ( ) : ▁ ▁ ▁ ▁ for ▁ i ▁ in ▁ range ( 16 ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ for ▁ j ▁ in ▁ range ( 4 ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ i & (1 < < j ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( j , end = ' ' ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( ) import ▁ binarytreefrom ▁ collections ▁ import ▁ dequebst ▁ = ▁ binarytree . tree ( height = 4 , is _ perfect = True ) print ( bst ) def ▁ s ( bst ) : ▁ ▁ ▁ ▁ if ▁ bst : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ bst . left , bst . right ▁ = ▁ bst . right , bst . left ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ s ( bst . right ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ s ( bst . left ) s ( bst ) print ( bst ) ''' n , m = map ( int , input ( ) . split ( ) ) s = list ( map ( int , input ( ) . split ( ) ) ) s = list ( map ( int , input ( ) . split ( ) ) ) x , y = map ( int , input ( ) . split ( ) ) ) ss = [ None ] * 26 for i in range ( n ) : if s [ i ] == s [ i + 1 ] : x [ i ] = lst [ i ] + 1 for i in range ( n ) : if x [ i ] < lst [ i + 1 ] : ss [ i ] = lst [ i ] + lst [ i ] print ( x , y ) NEW_LINE"],"references":["n , m , x , y = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) outputs , l = [ ] , 0 for i in range ( n ) : minm = max ( 1 , a [ i ] - x ) while l < m and b [ l ] < minm : l += 1 if l < m and b [ l ] <= a [ i ] + y : outputs . append ( f ' { i + 1 } ▁ { l + 1 } ' ) l += 1 print ( len ( outputs ) ) for output in outputs : print ( output )   NEW_LINE","n , m , x , y = map ( int , input ( ) . split ( ) ) A = list ( map ( int , input ( ) . split ( ) ) ) B = list ( map ( int , input ( ) . split ( ) ) ) i = 0j = 0 count = 0 Ac = [ ] Bc = [ ] while i < n and j < m : if A [ i ] - x <= B [ j ] <= A [ i ] + y : count += 1 Ac . append ( i + 1 ) Bc . append ( j + 1 ) i += 1 j += 1 elif A [ i ] - x > B [ j ] : j += 1 elif A [ i ] + y < B [ j ] : i += 1 print ( count ) for x in range ( count ) : print ( Ac [ x ] , Bc [ x ] ) NEW_LINE","class bulletproof : def __init__ ( self , x , y ) : self . soldier = x self . vest = ys = list ( map ( int , input ( ) . split ( ) ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = [ ] x = s [ 2 ] y = s [ 3 ] j = 0 k = 0 i = 0 for i in range ( len ( a ) ) : while j <= len ( b ) - 1 and b [ j ] < a [ i ] - x : j += 1 if j <= len ( b ) - 1 and a [ i ] - x <= b [ j ] <= a [ i ] + y : p = bulletproof ( i + 1 , j + 1 ) c . append ( p ) k += 1 j += 1 if j == len ( b ) : breakprint ( k ) for i in range ( len ( c ) ) : print ( c [ i ] . soldier , c [ i ] . vest ) NEW_LINE","n , m , x , y = list ( map ( int , input ( ) . split ( ) ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) count = 0 result = [ ] for i in range ( n ) : if count == m : break for j in range ( count , m ) : if b [ j ] < a [ i ] - x : count += 1 if b [ j ] > a [ i ] + y : break if ( ( a [ i ] - x <= b [ j ] ) & ( b [ j ] <= a [ i ] + y ) ) : result . append ( str ( i + 1 ) + \" ▁ \" + str ( j + 1 ) ) count += 1 break print ( len ( result ) ) for a in result : print ( a ) NEW_LINE","n , m , x , y = map ( int , input ( ) . split ( ) ) A = list ( map ( int , input ( ) . split ( ) ) ) B = list ( map ( int , input ( ) . split ( ) ) ) C = [ ] for i in range ( n ) : C . append ( [ 0 , 0 ] )     l = 0 r = 0j = 0 k = 0     while r != m and l != n : if ( B [ r ] >= A [ l ] - x ) and ( B [ r ] <= A [ l ] + y ) : C [ j ] [ 0 ] = l + 1 C [ j ] [ 1 ] = r + 1 j += 1 l += 1 k += 1 r += 1   elif B [ r ] < A [ l ] - x : r += 1 else : l += 1   print ( k ) for i in range ( k ) : print ( C [ i ] [ 0 ] , C [ i ] [ 1 ] )   NEW_LINE"],"bleu":0.23843166475010905,"rouge_l":0.36982804467293035}
{"id":318,"predictions":["n = input ( ) S = list ( map ( str , input ( ) . split ( ) ) ) Max = 0 for i in range ( len ( S ) ) : C = 0 for j in range ( len ( S [ i ] ) ) : if S [ i ] [ j ] . isupper ( ) : C += 1 if C > Max : Max = Cprint ( Max ) NEW_LINE"],"references":["import sys   window = set ( )   n , k , q = [ int ( x ) for x in input ( ) . split ( ) ] arr = [ int ( x ) for x in input ( ) . split ( ) ]   for i in range ( q ) : a , b = [ int ( x ) for x in input ( ) . split ( ) ] if ( a == 1 ) : if ( len ( window ) < k ) : window . add ( arr [ b - 1 ] ) else : window . add ( arr [ b - 1 ] ) m = min ( window ) window . remove ( m ) else : print ( \" YES \" if arr [ b - 1 ] in window else \" NO \" ) NEW_LINE","import osimport sysimport mathimport heapqfrom decimal import * from io import BytesIO , IOBasefrom collections import defaultdict , deque   def main ( ) : n , k , q = rm ( ) a = rl ( ) b = [ ] for i in range ( q ) : c , d = rm ( ) if c == 1 : d -= 1 b . append ( [ a [ d ] , d ] ) b . sort ( reverse = True ) b = b [ : k ] elif c == 2 : d -= 1 ans = False for i in b : if i [ 1 ] == d : ans = True break if ans : print ( \" YES \" ) else : print ( \" NO \" )   NEW_LINE","        n , k , q = map ( int , input ( ) . split ( ) )       t = list ( map ( int , input ( ) . split ( ) ) )   f = [ ]       for i in range ( q ) : a , b = map ( int , input ( ) . split ( ) )       if a == 1 : if len ( f ) < k : f . append ( t [ b - 1 ] ) else : f . append ( t [ b - 1 ] ) f . sort ( ) f = f [ : : - 1 ] [ : k ] else : if t [ b - 1 ] in f : print ( ' YES ' ) else : print ( ' NO ' )   NEW_LINE","n , k , q = map ( int , input ( ) . strip ( ) . split ( ' ▁ ' ) ) lst = list ( map ( int , input ( ) . strip ( ) . split ( ' ▁ ' ) ) ) p = [ ] c = 0 for i in range ( q ) : t , d = map ( int , input ( ) . strip ( ) . split ( ' ▁ ' ) ) if t == 1 : if c < k : p . append ( lst [ d - 1 ] ) c += 1 else : ind = p . index ( min ( p ) ) if lst [ d - 1 ] > min ( p ) : del p [ ind ] p . append ( lst [ d - 1 ] ) else : if lst [ d - 1 ] in p : print ( ' YES ' ) else : print ( ' NO ' ) NEW_LINE","n , k , q = map ( int , input ( ) . split ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) dis = [ ] for i in range ( q ) : t , id = map ( int , input ( ) . split ( ) ) if t == 1 : if len ( dis ) == k : if arr [ id - 1 ] >= dis [ 0 ] [ 0 ] : dis [ 0 ] = ( arr [ id - 1 ] , id ) else : dis . append ( ( arr [ id - 1 ] , id ) ) dis . sort ( ) else : var = [ dis [ i ] [ 1 ] for i in range ( len ( dis ) ) ] if id in var : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.1975913512272254,"rouge_l":0.38595132029182005}
{"id":319,"predictions":["import sys , math , itertoolsfrom collections import Counter , deque , defaultdictfrom bisect import bisect_left , bisect_right from heapq import heappop , heappush , heapifymod = 10 ** 9 + 7 INF = float ( ' inf ' ) def inp ( ) : return int ( sys . stdin . readline ( ) ) def inpl ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) def inpl_1 ( ) : return list ( map ( lambda x : int ( x ) - 1 , sys . stdin . readline ( ) . split ( ) ) ) def inps ( ) : return sys . stdin . readline ( ) def inpsl ( x ) : tmp = sys . stdin . readline ( ) ; return list ( tmp [ : x ] ) def err ( x ) : print ( x ) ; exit ( )   for _ in range ( inp ( ) ) : n , k = inpl ( ) a = inpl ( ) cnt = 0 for i in range ( n ) : if x % 2 == 0 : NEW_LINE"],"references":["n = int ( input ( ) ) x = int ( input ( ) ) a = [ 0 ] * 3 a [ x ] = 1 for i in range ( n % 6 + 1 , 7 ) : if i % 2 == 1 : a [ 0 ] , a [ 1 ] = a [ 1 ] , a [ 0 ] else : a [ 1 ] , a [ 2 ] = a [ 2 ] , a [ 1 ] for i in range ( 3 ) : if a [ i ] == 1 : print ( i ) NEW_LINE","n = int ( input ( ) ) x = int ( input ( ) ) a = [ 0 , 1 , 2 ] k = 0 for i in range ( n % 6 ) : if i % 2 == 0 : k = a [ 0 ] a [ 0 ] = a [ 1 ] a [ 1 ] = k else : k = a [ 1 ] a [ 1 ] = a [ 2 ] a [ 2 ] = kprint ( a [ x ] ) NEW_LINE","n = int ( input ( ) ) x = int ( input ( ) ) l = [ 0 , 1 , 2 ] if n % 6 == 1 : l1 = [ 1 , 0 , 2 ] elif n % 6 == 2 : l1 = [ 1 , 2 , 0 ] elif n % 6 == 3 : l1 = [ 2 , 1 , 0 ] elif n % 6 == 4 : l1 = [ 2 , 0 , 1 ] elif n % 6 == 5 : l1 = [ 0 , 2 , 1 ] else : l1 = [ 0 , 1 , 2 ] print ( l [ l1 [ x ] ] ) NEW_LINE","n = int ( input ( ) ) % 6 x = int ( input ( ) ) p = [ \"012\" , \"102\" , \"120\" , \"210\" , \"201\" , \"021\" ] print ( p [ n ] [ x ] ) NEW_LINE","a = [ 1 , 2 , 2 , 1 , 0 , 0 ] b = [ 0 , 0 , 1 , 2 , 2 , 1 ] c = [ 2 , 1 , 0 , 0 , 1 , 2 ]     n = int ( input ( ) ) n = n % 6   if not n : n = 6   x = int ( input ( ) ) if a [ n - 1 ] == x : print ( 0 ) elif b [ n - 1 ] == x : print ( 1 ) else : print ( 2 ) NEW_LINE"],"bleu":0.11425085704044366,"rouge_l":0.2776001180753714}
{"id":320,"predictions":["a , b = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) if min ( l ) >= a : print ( max ( l ) ) else : print ( 1 ) NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) current , ans = 0 , 1 for x in a : if current + x <= m : current += x else : current = x ans += 1   print ( ans ) NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) ans = 0 temp = mfor i in range ( len ( arr ) ) : if temp >= arr [ i ] : temp -= arr [ i ] else : ans += 1 temp = m temp -= arr [ i ] print ( ans + 1 ) NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) res = 1 pep = 0 for i in range ( 0 , n ) : if ( pep + a [ i ] <= m ) : pep += a [ i ] else : res += 1 pep = a [ i ] print ( res ) NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) current , ans = 0 , 0 for x in a : if current + x <= m : current += x else : current = x ans += 1 if current != 0 : ans += 1 print ( ans ) NEW_LINE"],"bleu":0.4622015906302224,"rouge_l":0.6167534102560775}
{"id":321,"predictions":["import sys , os , ioimport math , bisect , operatorinf , mod = float ( ' inf ' ) , 10 ** 9 + 7 NEW_LINE"],"references":["s = input ( ) s1 = s [ : len ( s ) \/\/ 2 ] if len ( s ) % 2 == 0 : s2 = s [ len ( s ) \/\/ 2 : ] else : s2 = s [ len ( s ) \/\/ 2 + 1 : ]   s2 = s2 [ - 1 : : - 1 ] NEW_LINE","s = input ( ) n = len ( s ) c = 0 for i in range ( n \/\/ 2 ) : if s [ i ] != s [ - i - 1 ] : c += 1 if c > 1 : print ( ' NO ' ) if c == 1 : print ( ' YES ' ) if c == 0 : if n % 2 == 1 : print ( ' YES ' ) else : print ( ' NO ' ) NEW_LINE","str = str ( input ( ) ) def pal ( ) : global str lst = [ ] count1 = 0 count2 = 0 n = len ( str ) for i in str : lst . append ( i ) for i in range ( len ( lst ) ) : if lst [ i ] == lst [ n - 1 - i ] : count1 += 1 else : count2 += 1 if len ( str ) % 2 == 0 : if ( count2 == 2 ) : print ( \" YES \" ) else : print ( \" NO \" ) if len ( str ) % 2 == 1 : if ( count2 == 0 or count2 == 2 ) : print ( \" YES \" ) else : print ( ' NO ' ) pal ( ) NEW_LINE","string = input ( ) n = len ( string ) count = 0 contingency = Falsex = n \/\/ 2 + 1 if n % 2 == 1 else n \/\/ 2   for i in range ( x ) : if string [ i ] != string [ n - i - 1 ] : count += 1   if count == 0 and n % 2 == 1 : contingency = True   if contingency : print ( \" YES \" ) else : print ( \" NO \" if count != 1 else \" YES \" ) NEW_LINE","a = input ( ) b = a [ : : - 1 ] c = 0 for i in range ( len ( b ) ) : if ( a [ i ] != b [ i ] ) : c += 1 if ( c == 2 or ( c == 0 and len ( a ) % 2 != 0 ) ) : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.01900180206737778,"rouge_l":0.10131207440624482}
{"id":322,"predictions":["t = int ( input ( ) ) for i in range ( t ) : n = int ( input ( ) ) for j in range ( n ) : print ( '1' , end = \" ▁ \" ) print ( ) t -= 1 NEW_LINE"],"references":["for _ in range ( int ( input ( ) ) ) : S = input ( ) if S . count ( \"1\" ) == 0 : print ( 0 ) else : A = S [ S . index ( \"1\" ) : S . rfind ( \"1\" ) + 1 ] print ( A . count ( \"0\" ) ) NEW_LINE","for _ in range ( int ( input ( ) ) ) : x = input ( ) c = 0 a = 0 f = 0 for i in range ( len ( x ) ) : if x [ i ] == '1' : f = 1 a = a + c c = 0 if x [ i ] == '0' and f : c = c + 1 print ( a ) NEW_LINE","for _ in range ( int ( input ( ) ) ) : x = input ( ) c = 0 a = 0 f = 0 for i in range ( len ( x ) ) : if x [ i ] == '1' : f = 1 a = a + c c = 0 if x [ i ] == '0' and f : c = c + 1 print ( a ) NEW_LINE","for t in range ( int ( input ( ) ) ) : s = input ( ) ones = [ ] erase = 0 for i in range ( len ( s ) ) : if s [ i ] == '1' : ones . append ( i ) for i in range ( len ( ones ) - 1 ) : erase = erase + ones [ i + 1 ] - ones [ i ] - 1 print ( erase ) NEW_LINE","from re import findallfrom typing import Iterator     def get_num_input ( ) -> Iterator [ int ] : return map ( int , input ( ) . split ( ) )     def main ( ) -> None : print ( sum ( map ( len , findall ( r \" ( ? < = 1)0 + ( ? = 1 ) \" , input ( ) ) ) ) )     if __name__ == \" _ _ main _ _ \" : ONLY_ONCE : bool = False for _ in range ( 1 if ONLY_ONCE else int ( input ( ) ) ) : main ( ) NEW_LINE"],"bleu":0.26736388445140663,"rouge_l":0.4191164267616698}
{"id":323,"predictions":["from collections import dequeimport heapq n = int ( input ( ) ) cards_help = list ( map ( int , input ( ) . split ( ) ) ) cards = [ ( cards_help [ i ] , - 1 * i ) for i in range ( n ) ] heapq . heapify ( cards ) draws = 0 removed = 0 while cards : NEW_LINE"],"references":["import itertools as it   def powerset ( iterable ) : \" powerset ( [1,2,3 ] ) ▁ - - > ▁ ( ) ▁ ( 1 , ) ▁ ( 2 , ) ▁ ( 3 , ) ▁ ( 1,2 ) ▁ ( 1,3 ) ▁ ( 2,3 ) ▁ ( 1,2,3 ) \" s = list ( iterable ) return it . chain . from_iterable ( it . combinations ( s , r )   \\ for r in range ( len ( s ) + 1 ) )     n , k , A = map ( int , input ( ) . split ( ) )   best_result = 0   missing = 0   senators = [ ] for _ in range ( n ) : level , loyality = map ( int , input ( ) . split ( ) ) senators += [ [ level , loyality ] ] missing += 10 - loyality \/\/ 10   k = min ( [ k , missing ] ) NEW_LINE"],"bleu":0.07576800693070948,"rouge_l":0.2557967439565861}
{"id":324,"predictions":["import math ; q = 2 * math . pi NEW_LINE"],"references":["PI = 3.141592653589793 n , a , b = map ( int , input ( ) . split ( ) ) arr , res = [ ] , [ ] for _ in range ( n ) : u , v = input ( ) . split ( ) arr . append ( ( int ( u ) - a , int ( v ) - b ) ) x0 , y0 = arr [ - 1 ] for x1 , y1 in arr : res . append ( x1 * x1 + y1 * y1 ) dx , dy = x1 - x0 , y1 - y0 if ( x0 * dx + y0 * dy ) * ( x1 * dx + y1 * dy ) < 0 : x0 = x0 * y1 - x1 * y0 res . append ( ( x0 * x0 ) \/ ( dx * dx + dy * dy ) ) x0 , y0 = x1 , y1print ( ( max ( res ) - min ( res ) ) * PI ) NEW_LINE"],"bleu":2.3187394267431976e-8,"rouge_l":0.03555296517557919}
{"id":325,"predictions":["n , k = map ( int , input ( ) . split ( ) ) a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) subtract = 0 i = 0 for kk in range ( k ) : if i < n : print ( a [ i ] - subtract ) subtract += a [ i ] - subtract while i < n and a [ i ] <= subtract : i += 1 else : print ( 0 ) NEW_LINE"],"references":["n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in a : if i > 0 and i >= a [ k - 1 ] : c = c + 1 print ( c ) NEW_LINE","def get_winners ( places , scores ) : while ( \"0\" in scores ) : scores . remove ( \"0\" ) winners = scores [ : int ( places ) ] losers = scores [ int ( places ) : ]   for i in losers : if winners [ - 1 ] == i : winners . append ( i ) return len ( winners )     participants , places = input ( ) . split ( ) scores = input ( ) . split ( )   print ( get_winners ( places , scores ) ) NEW_LINE","n , k = [ int ( i ) for i in input ( ) . split ( ) ] scores = [ int ( i ) for i in input ( ) . split ( ) ] advance = [ score for score in scores if score >= scores [ k - 1 ] and score > 0 ] print ( len ( advance ) ) NEW_LINE","x , y = map ( int , input ( ) . split ( ) ) number = list ( map ( int , input ( ) . split ( ) ) ) count = 0   value = number [ y - 1 ] for i in number : if i > 0 : if i >= value : count += 1 print ( count ) NEW_LINE","inp = list ( map ( int , input ( ) . split ( ) ) ) n = inp [ 0 ] k = inp [ 1 ] li = list ( map ( int , input ( ) . split ( ) ) ) c = 0 val = li [ k - 1 ] for i in li : if i >= val and i > 0 : c += 1 print ( c ) NEW_LINE"],"bleu":0.44030912574555575,"rouge_l":0.6633262260127931}
{"id":326,"predictions":["d = { } n , s = map ( int , input ( ) . split ( ) ) for i in range ( n ) : a , b = map ( int , input ( ) . split ( ) ) d . setdefault ( a , set ( ) ) . add ( b ) d . update ( a ) print ( n - len ( d ) ) NEW_LINE"],"references":["holes , water_have , water_plant = map ( int , input ( ) . split ( ) ) hole_ratio = list ( map ( int , input ( ) . split ( ) ) ) plant_A = hole_ratio [ 0 ] hole_ratio = hole_ratio [ 1 : ] hole_ratio . sort ( ) hole_ratio . reverse ( ) blocked = 0 sum_non_blocked = sum ( hole_ratio ) + plant_A   for each in hole_ratio : if ( water_have * plant_A \/ sum_non_blocked >= water_plant ) : break sum_non_blocked -= each blocked += 1 print ( blocked )   NEW_LINE","n , a , b = map ( int , input ( ) . split ( ) ) if n == 1 : print ( '0' ) exit ( ) l = list ( map ( int , input ( ) . split ( ) ) ) s = sum ( l ) z = sorted ( l [ 1 : ] , reverse = True ) for i in range ( n - 1 ) : if l [ 0 ] * a \/ s >= b : print ( i ) exit ( ) s -= z [ i ] print ( i + 1 ) NEW_LINE","n , A , B = map ( int , input ( ) . rstrip ( ) . split ( ) ) l = list ( map ( int , input ( ) . rstrip ( ) . split ( ) ) ) se = l [ 1 : ] se . sort ( reverse = True ) re = ( A * l [ 0 ] ) \/ Bse . insert ( 0 , l [ 0 ] ) S = sum ( l ) if S <= re : print ( 0 ) exit ( ) NEW_LINE","n , s , a = map ( int , input ( ) . split ( ) ) r = lambda : list ( map ( int , input ( ) . split ( ) ) ) arr = r ( )   t = sum ( arr )   f = arr [ 0 ] arr = arr [ 1 : ] arr . sort ( reverse = True )     c = 0   for i in range ( n - 1 ) : if ( f * s ) \/ t >= a : break t -= arr [ i ] c += 1   print ( c )       NEW_LINE","n , A , B = list ( map ( int , input ( ) . split ( ) ) ) s = list ( map ( int , input ( ) . split ( ) ) ) S = sum ( s ) NEW_LINE"],"bleu":0.5301872009164803,"rouge_l":0.6580681947770555}
{"id":327,"predictions":["for i in [ * open ( 0 ) ] [ 2 : : 2 ] : NEW_LINE INDENT q = [ 0 ] * 3 NEW_LINE for _ in map ( int , i . split ( ) ) : q [ _ % 3 ] += 1 NEW_LINE print ( max ( q [ i ] - q [ i - 1 ] for i in ( 0 , 1 , 2 ) ) ) NEW_LINE DEDENT"],"references":["''' a = [ int ( i ) ▁ for ▁ i ▁ in ▁ input ( ) . split ( ) ] x = a [ 0 ] y = a [ 1 ] z = a [ 2 ] if ▁ y = = x ▁ and ▁ z = = 0 : ▁ ▁ ▁ ▁ print ( '0 ' ) elif ▁ x > y + z : ▁ ▁ ▁ ▁ print ( ' + ' ) elif ▁ y > x + z : ▁ ▁ ▁ ▁ print ( ' - ' ) else : ▁ ▁ ▁ ▁ print ( ' ? ' ) n = int ( input ( ) ) z = [ int ( i ) ▁ for ▁ i ▁ in ▁ input ( ) . split ( ) ] x = [ ] d = 0v = ' ' for ▁ i ▁ in ▁ range ( n ) : ▁ ▁ ▁ ▁ c = 0 ▁ ▁ ▁ ▁ e = 0 ▁ ▁ ▁ ▁ for ▁ f ▁ in ▁ range ( len ( z ) ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ z [ f ] > c ▁ and ▁ f + 1 ▁ not ▁ in ▁ x : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ c = z [ f ] ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ e = f + 1 ▁ ▁ ▁ ▁ d + = ( i * c ) + 1 ▁ ▁ ▁ ▁ x . append ( e ) print ( d ) for ▁ i ▁ in ▁ x : ▁ ▁ ▁ ▁ v + = str ( i ) ▁ ▁ ▁ ▁ v + = ' ▁ ' print ( v )  f = int ( input ( ) ) g = [ int ( i ) ▁ for ▁ i ▁ in ▁ input ( ) . split ( ) ] for ▁ i ▁ in ▁ range ( len ( g ) -1 ) : ▁ ▁ ▁ ▁ for ▁ f ▁ in ▁ range ( len ( g ) -1 - i ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ g [ f ] > g [ f + 1 ] : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ g [ f ] , g [ f + 1 ] = g [ f + 1 ] , g [ f ] if ▁ g [ 0 ] * g [ 1 ] > g [ -2 ] * g [ -3 ] ▁ and ▁ g [ -1 ] > 0 : ▁ ▁ ▁ ▁ print ( g [ -1 ] * g [ 0 ] * g [ 1 ] ) else : ▁ ▁ ▁ ▁ print ( g [ -1 ] * g [ -2 ] * g [ -3 ] ) for ▁ u ▁ in ▁ range ( int ( input ( ) ) ) : ▁ ▁ ▁ ▁ z = int ( input ( ) ) ▁ ▁ ▁ ▁ y = [ int ( f ) ▁ for ▁ f ▁ in ▁ input ( ) . split ( ) ] ▁ ▁ ▁ ▁ y . sort ( ) ▁ ▁ ▁ ▁ d = 0 ▁ ▁ ▁ ▁ for ▁ i ▁ in ▁ y : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ d + = i ▁ ▁ ▁ ▁ if ▁ d < 2048 : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( ' No ' ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ continue ▁ ▁ ▁ ▁ if ▁ 2048 ▁ in ▁ y : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( ' yes ' ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ continue ▁ ▁ ▁ ▁ for ▁ x ▁ in ▁ range ( z + 1 ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ 2048 ▁ in ▁ y : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( ' yes ' ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ break ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ for ▁ i ▁ in ▁ range ( len ( y ) -1 ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ y [ i ] = = y [ i + 1 ] : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ y [ i + 1 ] = y [ i ] *2 ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ y . pop ( i ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ i > len ( y ) -3 : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ break ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ y . sort ( ) ▁ ▁ ▁ ▁ else : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( ' no ' ) n = int ( input ( ) ) x = [ ] for ▁ i ▁ in ▁ range ( 1 , ( ( n * *2 ) \/ \/2 ) + 1 ) : ▁ ▁ ▁ ▁ x . append ( n * *2 + 1 - i ) ▁ ▁ ▁ ▁ x . append ( i ) ▁ ▁ ▁ ▁ if ▁ len ( x ) = = n : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( * x ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ x = [ ] ''' for z in range ( int ( input ( ) ) ) : z = int ( input ( ) ) x = [ int ( i ) for i in input ( ) . split ( ) ] f = 0 o = 0 t = 0 for i in range ( z ) : if x [ i ] % 3 == 0 : f += 1 elif x [ i ] % 3 == 1 : o += 1 else : t += 1 if o < t : print ( f + o + ( t - o ) \/\/ 3 ) else : print ( f + t + ( o - t ) \/\/ 3 ) NEW_LINE","import sysdef get_ints ( ) : return map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) def get_ints_lists ( ) : return list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) def get_string ( ) : return sys . stdin . readline ( ) . strip ( )   n = int ( input ( ) ) for i in range ( n ) : p = int ( input ( ) ) li = get_ints_lists ( ) su = 0 q = 0 r = 0   for i in li : if i % 3 == 0 : su += 1 elif i == 1 or i % 3 == 1 : q += 1 elif i == 2 or i % 3 == 2 : r += 1 if q > 0 or r > 0 :   if r < q : su += r q = q - r su += ( q \/\/ 3 ) elif r > q : su += q r = r - q su += ( r \/\/ 3 ) else : su += r print ( su )   NEW_LINE","import sysdef get_ints ( ) : return map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) def get_ints_lists ( ) : return list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) def get_string ( ) : return sys . stdin . readline ( ) . strip ( )   NEW_LINE","import sysdef get_ints ( ) : return map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) def get_ints_lists ( ) : return list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) def get_string ( ) : return sys . stdin . readline ( ) . strip ( )   NEW_LINE","import sys   def answer ( n , a ) : cnt = [ 0 ] * 3 NEW_LINE"],"bleu":0.31172124255158223,"rouge_l":0.5653382761816497}
{"id":328,"predictions":["import sysimport collections as ccinput = sys . stdin . buffer . readlineI = lambda : list ( map ( int , input ( ) . split ( ) ) ) prev = cc . defaultdict ( int ) for tc in range ( int ( input ( ) ) ) : x , y = I ( ) div = set ( ) for i in range ( 1 , int ( x ** 0.5 ) + 1 ) : if x % i == 0 : div . add ( i ) div . add ( x \/\/ i ) ans = 0 now = tc + 1 for i in div : if now - prev [ i ] > y : ans += 1 prev [ i ] = now print ( ans ) NEW_LINE"],"references":["import heapqn = int ( input ( ) ) p = list ( map ( int , input ( ) . split ( ) ) ) f = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) m = int ( input ( ) ) choice = list ( map ( int , input ( ) . split ( ) ) ) dic = { } dic [ 1 ] = [ ] dic [ 2 ] = [ ] dic [ 3 ] = [ ] pdic = { }   for i in range ( n ) : pdic [ p [ i ] ] = 0 dic [ f [ i ] ] . append ( p [ i ] ) dic [ b [ i ] ] . append ( p [ i ] ) heapq . heapify ( dic [ 1 ] ) heapq . heapify ( dic [ 2 ] ) heapq . heapify ( dic [ 3 ] ) for i in range ( m ) : try : z = heapq . heappop ( dic [ choice [ i ] ] ) while pdic [ z ] != 0 : z = heapq . heappop ( dic [ choice [ i ] ] ) pdic [ z ] = 1 print ( z , end = ' ▁ ' ) except : print ( - 1 , end = ' ▁ ' )                   NEW_LINE","input ( ) p = list ( map ( int , input ( ) . split ( ) ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) input ( ) c = list ( map ( int , input ( ) . split ( ) ) ) d = [ [ [ ] for _ in range ( 3 ) ] for _ in range ( 3 ) ] for pi , ai , bi in zip ( p , a , b ) : d [ ai - 1 ] [ bi - 1 ] . append ( pi ) for row in d : for l in row : l . sort ( reverse = True ) r = [ ] for ci in c : pm = 1000000001 im = - 1 for j , l in enumerate ( d [ ci - 1 ] ) : if len ( l ) > 0 and l [ - 1 ] < pm : pm = l [ - 1 ] im = ci - 1 jm = j for i , ll in enumerate ( d ) : l = ll [ ci - 1 ] if len ( l ) > 0 and l [ - 1 ] < pm : pm = l [ - 1 ] im = i jm = ci - 1 r . append ( d [ im ] [ jm ] . pop ( ) if im >= 0 else - 1 ) print ( * r , sep = ' ▁ ' ) NEW_LINE","n = int ( input ( ) ) p = list ( map ( int , input ( ) . split ( ) ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) m = int ( input ( ) ) c = list ( map ( int , input ( ) . split ( ) ) ) res_cost = ' ' first_color_arr = [ ] second_color_arr = [ ] third_color_arr = [ ] buy_flag = [ ]   for i in range ( n ) : if a [ i ] == 1 or b [ i ] == 1 : first_color_arr . append ( [ p [ i ] , i ] ) if a [ i ] == 2 or b [ i ] == 2 : second_color_arr . append ( [ p [ i ] , i ] ) if a [ i ] == 3 or b [ i ] == 3 : third_color_arr . append ( [ p [ i ] , i ] ) buy_flag . append ( False )   first_color_index = 0 NEW_LINE"],"bleu":0.18101336000547372,"rouge_l":0.3644786976099757}
{"id":329,"predictions":["for t in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) )   d = { } NEW_LINE for i in a : if NEW_LINE i in d : d [ i ] += 1 else : d [ i ] = 1 NEW_LINE print ( len ( d ) ) NEW_LINE"],"references":["n = int ( input ( ) ) arr = [ ] ans = 0 for i in range ( n ) : s = input ( ) if s not in arr : arr . append ( s ) ans += 1 print ( ans ) NEW_LINE","s = [ ] for i in range ( int ( input ( ) ) ) : d = input ( ) if d not in s : s . append ( d ) print ( len ( s ) ) NEW_LINE","seen = set ( ) count = 0 for i in range ( n : = int ( input ( ) ) ) : ip = input ( ) if ip not in seen : count += 1 seen . add ( ip ) print ( count ) NEW_LINE","n = int ( input ( ) ) m = { 0 } m . clear ( ) for i in range ( n ) : q , p = input ( ) . split ( ) s = q + \" ▁ \" + p m . add ( s ) print ( len ( m ) ) NEW_LINE","n = int ( input ( ) ) leaves = [ ] for i in range ( n ) : leaves . append ( input ( ) ) ; print ( len ( set ( leaves ) ) ) NEW_LINE"],"bleu":0.3824053758533901,"rouge_l":0.47232578147404647}
{"id":330,"predictions":["n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) if k == 1 : print ( \" No \" ) exit ( ) if a [ 0 ] == 1 or a [ - 1 ] == 1 : print ( \" Yes \" ) print ( 0 ) else : print ( \" No \" ) NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) ab = list ( map ( int , input ( ) . split ( ) ) ) ab . sort ( reverse = True ) for i in range ( n ) : if arr [ i ] == 0 : arr [ i ] = ab . pop ( 0 )   if arr == sorted ( arr ) : print ( \" NO \" ) else : print ( \" YES \" ) NEW_LINE","n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) )   if k > 1 : print ( \" Yes \" ) else : for i in range ( n ) : if a [ i ] == 0 : a [ i ] = b [ 0 ] lst = a . copy ( ) lst . sort ( ) if lst == a : print ( \" No \" ) else : print ( \" Yes \" )   NEW_LINE","n , k = map ( int , input ( ) . split ( ) )   list1 = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) [ : n ] list2 = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) [ : k ] list2 . sort ( reverse = True )   for j in range ( k ) : for i in range ( n ) : if list1 [ i ] == 0 : list1 [ i ] = list2 [ j ] break   if list1 == sorted ( list1 ) : print ( \" NO \" ) else : print ( \" YES \" )             NEW_LINE","n , k = map ( int , input ( ) . split ( ) ) a = [ int ( i ) for i in input ( ) . split ( ) ] b = [ int ( i ) for i in input ( ) . split ( ) ] b . sort ( reverse = True ) j = 0 for i in range ( n ) : if a [ i ] == 0 : a [ i ] = b [ j ] j += 1 can = Falsefor i in range ( 1 , n ) : if a [ i ] < a [ i - 1 ] : can = Trueif can : print ( \" Yes \" ) else : print ( \" No \" ) NEW_LINE"],"bleu":0.537157502844158,"rouge_l":0.6344303011487117}
{"id":331,"predictions":["n , m = map ( int , input ( ) . split ( ) ) print ( n + m - 1 ) NEW_LINE"],"references":["a , b = input ( ) . split ( ) print ( int ( a ) + int ( str ( b ) [ : : - 1 ] ) ) NEW_LINE","n , m = input ( ) . split ( ) r = ' '   for i in m : r = i + r   print ( int ( n ) + int ( r ) ) NEW_LINE","import mathimport sysinput = sys . stdin . readline   def inp ( ) : return ( int ( input ( ) ) ) def inlt ( ) : return ( list ( map ( int , input ( ) . split ( ) ) ) ) def reverse_number ( n ) : r = 0 while n > 0 : r *= 10 r += n % 10 n \/\/= 10 return rm , s = inlt ( ) print ( m + reverse_number ( s ) ) NEW_LINE","n = input ( ) m = n . split ( ) [ 1 ] n = n . split ( ) [ 0 ] i , j = len ( n ) , len ( m ) k = max ( i , j ) t = min ( i , j ) s = 0 for i in range ( k ) : if i < t : s += ( int ( n [ - i - 1 ] ) + int ( m [ i ] ) ) * 10 ** i elif len ( n ) > len ( m ) : s += int ( n [ - i - 1 ] ) * 10 ** i else : s += int ( m [ i ] ) * 10 ** iprint ( s ) NEW_LINE","a , b = input ( ) . split ( )   l = max ( map ( len , [ a , b ] ) ) a , b = a . zfill ( l ) , b [ : : - 1 ] . zfill ( l )   print ( int ( a ) + int ( b ) ) NEW_LINE"],"bleu":0.49910701425702436,"rouge_l":0.5597756818761153}
{"id":332,"predictions":["n = int ( input ( ) )   arr = [ ] for i in range ( n ) : arr . append ( input ( ) )   result = \" NO \"   for i in arr : if i not in arr : result = \" YES \" break   if result : print ( \" NO \" ) else : print ( \" YES \" ) NEW_LINE"],"references":["n = int ( input ( ) ) t = list ( input ( ) ) A = 0 B = 0 r = 1 for i in t : if int ( i ) != 7 and int ( i ) != 4 : r = 0 if r > 0 : i = ( int ( n \/ 2 ) ) - 1 j = int ( n \/ 2 )   while i >= 0 : A = A + int ( t [ i ] ) B = B + int ( t [ j ] ) i -= 1 j += 1 if r == 1 and A == B : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE","n = int ( input ( ) ) a = input ( ) . strip ( ) if sorted ( set ( a ) ) != [ '4' , '7' ] and sorted ( set ( a ) ) != [ '7' ] and sorted ( set ( a ) ) != [ '4' ] : print ( \" NO \" ) else : x = [ int ( i ) for i in a [ : n \/\/ 2 ] ] y = [ int ( i ) for i in a [ n \/\/ 2 : ] ] if sum ( x ) == sum ( y ) : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE","t = int ( input ( ) ) s = input ( ) if s . count ( '4' ) + s . count ( '7' ) != t : print ( ' NO ' ) else : one = 0 two = 0 n = int ( t \/ 2 ) q = s [ : n ] w = s [ n : ] for i in q : one += int ( i ) for i in w : two += int ( i ) if one == two : print ( ' YES ' ) else : print ( ' NO ' ) NEW_LINE","a = int ( input ( ) ) l = list ( map ( int , input ( ) ) ) c = list ( set ( l ) ) sum1 = 0 sum2 = 0 if len ( c ) == 1 : if ( c [ 0 ] == 7 ) or ( c [ 0 ] == 4 ) : print ( \" YES \" ) else : print ( \" NO \" ) elif ( c [ 0 ] == 4 and c [ 1 ] == 7 ) or ( c [ 0 ] == 7 and c [ 0 ] == 4 ) : for i in l [ : a \/\/ 2 ] : sum1 += int ( i ) for j in l [ a \/\/ 2 : ] : sum2 += int ( j ) if sum1 == sum2 : print ( \" YES \" ) else : print ( \" NO \" )     else : print ( \" NO \" ) NEW_LINE","n = int ( input ( ) ) s = input ( ) f , s = s [ : n \/\/ 2 ] , s [ n \/\/ 2 : ] ff , fs = f . count ( '4' ) , f . count ( '7' ) sf , ss = s . count ( '4' ) , s . count ( '7' )   if all ( [ ff == sf , fs == ss , ff + fs == n \/\/ 2 , sf + ss == n \/\/ 2 ] ) : print ( ' YES ' ) else : print ( ' NO ' ) NEW_LINE"],"bleu":0.2824401979434126,"rouge_l":0.4070453134698944}
{"id":333,"predictions":["import sys , os , ioimport math , bisect , operatorinf , mod = float ( ' inf ' ) , 10 ** 9 + 7 NEW_LINE"],"references":["l , s , l = input ( ) , ' ' , list ( map ( int , input ( ) . split ( ) ) ) for i in range ( len ( l ) ) : if l [ i ] != 0 : if ( len ( s ) < 2 or s [ - 1 ] == ' R ' ) and l [ i ] == 1 : s += ' PR ' else : if i != 0 : s += ' PLR ' * l [ i ] else : s += ' PRL ' * l [ i ] s += ' R ' else : s += ' R ' print ( s [ : - 1 ] ) NEW_LINE","n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n + 1 ) : if i == n : break if i == n - 1 : print ( l [ i ] * ' PLR ' , end = ' ' ) else : print ( l [ i ] * ' PRL ' + ' R ' , end = ' ' ) NEW_LINE","def solve ( n , seq ) : totalCoins = sum ( seq ) index = 0 previousIndex = 0 incrementDecrement = 1 direction = \" R \" while totalCoins > 0 : if seq [ index ] > 0 : for _ in range ( abs ( previousIndex - index ) ) : print ( direction , end = \" \" ) print ( \" P \" , end = \" \" ) seq [ index ] -= 1 totalCoins -= 1 previousIndex = index     if ( index == n - 1 and direction == \" R \" ) or ( index == 0 and direction == \" L \" ) and totalCoins > 0 : if previousIndex + incrementDecrement < n and previousIndex + incrementDecrement >= 0   \\ and seq [ previousIndex ] > 0 : index = previousIndex + incrementDecrement previousIndex = index print ( direction , end = \" \" ) else : index = previousIndex index += ( incrementDecrement * - 1 ) incrementDecrement *= - 1 if incrementDecrement == - 1 : direction = \" L \" else : direction = \" R \" continue                                                     index += incrementDecrement n = int ( input ( ) ) seq = list ( map ( int , input ( ) . split ( ) ) ) solve ( n , seq ) NEW_LINE","n = int ( input ( ) )   wallets = [ int ( inp ) for inp in input ( ) . split ( ) ]   res = [ ]   for s in range ( wallets [ 0 ] ) : res . append ( \" RLP \" )   if wallets [ 0 ] == 0 : res . append ( \" \" )   for w in range ( 1 , n ) : res . append ( \" R \" ) for e in range ( wallets [ w ] ) : res . append ( \" LRP \" ) if wallets [ w ] == 0 : res . append ( \" \" )   print ( ' ' . join ( res ) )   NEW_LINE"],"bleu":0.011196682674779808,"rouge_l":0.1328976034858388}
{"id":334,"predictions":["x , y , z , t1 , t2 , t3 = map ( int , input ( ) . split ( ) ) st = abs ( y - x ) * t1 et = abs ( z - x ) * t2 + abs ( x - y ) * t2 + 3 * t3 print ( ' YES ' if et <= st else ' NO ' )   NEW_LINE"],"references":["s = input ( ) print ( s + s [ : : - 1 ] ) NEW_LINE","s = input ( ) print ( s + s [ : : - 1 ] ) NEW_LINE","a = input ( ) print ( a , end = ' ' ) for i in range ( len ( a ) - 1 , - 1 , - 1 ) : print ( a [ i ] , end = ' ' ) print ( ) NEW_LINE","s = input ( )   print ( s + s [ : : - 1 ] )       NEW_LINE","s = input ( ) print ( s + s [ : : - 1 ] ) NEW_LINE"],"bleu":0.06384391284490062,"rouge_l":0.34011151197113804}
{"id":335,"predictions":["import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE inf = 10 ** 20 NEW_LINE eps = 1.0 \/ 10 ** 10 NEW_LINE mod = 10 ** 9 + 7 NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def F ( ) : return float ( sys . stdin . readline ( ) ) NEW_LINE def S ( ) : return input ( ) NEW_LINE def pf ( s ) : return print ( s , flush = True ) NEW_LINE def main ( ) : NEW_LINE INDENT n = I ( ) NEW_LINE t = [ 2 , 1 ] NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT t [ i ] = t [ i - 1 ] NEW_LINE DEDENT i = 0 NEW_LINE while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def simply ( a , b ) : NEW_LINE INDENT g = math . gcd ( a , b ) NEW_LINE a = a \/\/ g NEW_LINE b = b \/\/ g NEW_LINE return ( a , b ) NEW_LINE DEDENT def mul ( a , b , c , d ) : NEW_LINE INDENT return simply ( a * c , b * d ) NEW_LINE DEDENT def add ( a , b , c , d ) : NEW_LINE INDENT return simply ( a * d + b * c , b * d ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE nxt = 0 NEW_LINE depth = 0 NEW_LINE node = 1 NEW_LINE total_node = 1 NEW_LINE p = 0 NEW_LINE q = 1 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT depth = depth + 1 NEW_LINE n = n \/\/ 2 NEW_LINE DEDENT nxt = depth NEW_LINE if ( n == 1 ) : NEW_LINE INDENT print ( str ( depth ) + \" \/ 1\" ) NEW_LINE return NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT node = node * 2 NEW_LINE total_node = total_node * 2 NEW_LINE depth = depth + 1 NEW_LINE p = p * 2 NEW_LINE q = q * 2 NEW_LINE if ( node >= n ) : NEW_LINE INDENT p = p + n * depth NEW_LINE node -= n NEW_LINE DEDENT if ( node == 1 ) : NEW_LINE INDENT nxt = depth - nxt NEW_LINE break NEW_LINE DEDENT DEDENT p , q = mul ( p , q , total_node , total_node - 1 ) NEW_LINE s , t = ( total_node - 1 ) * nxt * total_node * total_node , total_node * total_node * ( total_node - 1 ) * ( total_node - 1 ) NEW_LINE s , t = simply ( s , t ) NEW_LINE x , y = add ( p , q , s , t ) NEW_LINE print ( str ( x ) + \" \/ \" + str ( y ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT","from fractions import * NEW_LINE n = int ( input ( ) ) NEW_LINE l = 0 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n = n \/\/ 2 NEW_LINE l = l + 1 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT print ( ' % d \/ 1' % l ) NEW_LINE DEDENT else : NEW_LINE INDENT s = 1 NEW_LINE t = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT t = t * 2 % n NEW_LINE s *= 2 NEW_LINE if ( t == 1 ) : NEW_LINE INDENT m = i + 1 NEW_LINE break NEW_LINE DEDENT DEDENT r , t , i , ans = s , s * n , l , 0 NEW_LINE while ( r > 1 ) : NEW_LINE INDENT i , t = i + 1 , t \/\/ 2 NEW_LINE if ( r - t > 0 ) : NEW_LINE INDENT r , ans = r - t , ans + i * t NEW_LINE DEDENT DEDENT print ( ( Fraction ( ans , s ) + Fraction ( m , s ) ) \/ ( 1 - Fraction ( 1 , s ) ) ) NEW_LINE DEDENT","from fractions import * NEW_LINE n , L = int ( input ( ) ) , 0 NEW_LINE while ( n % 2 == 0 ) : n , L = n \/\/ 2 , L + 1 NEW_LINE if ( n == 1 ) : NEW_LINE INDENT print ( ' % d \/ 1' % L ) NEW_LINE DEDENT else : NEW_LINE INDENT s , t = 1 , 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT t , s = t * 2 % n , s * 2 NEW_LINE if ( t == 1 ) : NEW_LINE INDENT m = i + 1 NEW_LINE break NEW_LINE DEDENT DEDENT r , t , i , ans = s , s * n , L , 0 NEW_LINE while ( r > 1 ) : NEW_LINE INDENT i , t = i + 1 , t \/\/ 2 NEW_LINE if ( r - t > 0 ) : NEW_LINE INDENT r , ans = r - t , ans + i * t NEW_LINE DEDENT DEDENT print ( Fraction ( ans + m , s - 1 ) ) NEW_LINE DEDENT","import math NEW_LINE n = int ( input ( ) ) NEW_LINE y = 0 NEW_LINE while ( ( n % 2 ) == 0 ) : NEW_LINE INDENT y += 1 NEW_LINE n \/\/= 2 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT print ( str ( y ) + \" \/ 1\" ) NEW_LINE DEDENT else : NEW_LINE INDENT i = 1 NEW_LINE r = 1 NEW_LINE p = 0 NEW_LINE nu = 0 NEW_LINE de = 1 NEW_LINE f = True NEW_LINE while ( r > 1 or f ) : NEW_LINE INDENT f = False NEW_LINE r *= 2 NEW_LINE de *= 2 NEW_LINE nu *= 2 NEW_LINE if ( r >= n ) : NEW_LINE INDENT nu += ( r * ( i - p ) ) NEW_LINE p = i NEW_LINE r -= n NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( r == 1 ) : NEW_LINE INDENT nu *= de NEW_LINE de *= ( de - 1 ) NEW_LINE DEDENT nu += ( y * de ) NEW_LINE o = math . gcd ( nu , de ) NEW_LINE nu \/\/= o NEW_LINE de \/\/= o NEW_LINE print ( str ( nu ) + ' \/ ' + str ( de ) ) NEW_LINE DEDENT"],"bleu":0.21248451244108352,"rouge_l":0.33922201101462107}
{"id":336,"predictions":["t = int ( input ( ) ) for i in range ( t ) : n , x = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) s = 0 left = - 1 for i in range ( n ) : if l [ i ] % x != 0 : if left == - 1 : left = i   r = i s = s + l [ i ] if s % x != 0 : print ( n ) elif left == - 1 : print ( - 1 ) else : pre = left + 1 suf = n - r print ( n - min ( pre , suf ) ) NEW_LINE"],"references":["from collections import defaultdict , deque , Counterfrom sys import stdin , stdoutfrom heapq import heappush , heappopimport mathimport ioimport osimport mathimport bisect   NEW_LINE","d = { } d1 = { } ans = 0   for _ in range ( int ( input ( ) ) ) : x , y = map ( int , input ( ) . split ( ) )   d [ x + y ] = d . get ( x + y , 0 ) + 1 d1 [ x - y ] = d1 . get ( x - y , 0 ) + 1   for k in d : if d [ k ] > 1 : ans += ( d [ k ] * ( d [ k ] - 1 ) ) \/\/ 2   for z in d1 : if d1 [ z ] > 1 : ans += ( d1 [ z ] * ( d1 [ z ] - 1 ) ) \/\/ 2   print ( ans ) NEW_LINE","d = { } d1 = { } ans = 0   for _ in range ( int ( input ( ) ) ) : x , y = map ( int , input ( ) . split ( ) )   sum = x + y diff = x - y   d [ sum ] = d . get ( sum , 0 ) + 1 d1 [ diff ] = d1 . get ( diff , 0 ) + 1   for k in d : if d [ k ] > 1 : ans += ( d [ k ] * ( d [ k ] - 1 ) ) \/\/ 2   for z in d1 : if d1 [ z ] > 1 : ans += ( d1 [ z ] * ( d1 [ z ] - 1 ) ) \/\/ 2   print ( ans ) NEW_LINE","def solve ( n , bishops ) : tablePlus = { } tableMinus = { } ans = 0 for row , col in bishops : product1 = row - col product2 = row + col if tableMinus . get ( product1 ) == None : tableMinus [ product1 ] = 1 else : ans += tableMinus [ product1 ] tableMinus [ product1 ] += 1 if tablePlus . get ( product2 ) == None : tablePlus [ product2 ] = 1 else : ans += tablePlus [ product2 ] tablePlus [ product2 ] += 1 return ans b = [ ] n = int ( input ( ) ) for _ in range ( n ) : b . append ( list ( map ( int , input ( ) . split ( ) ) ) )   print ( solve ( n , b ) ) NEW_LINE","ls = [ 0 ] * 2010 ld = [ 0 ] * 2010 n = int ( input ( ) ) for _ in range ( n ) : x , y = map ( int , input ( ) . split ( ) ) ls [ x + y ] += 1 ld [ x - y ] += 1 ans = 0 for i in range ( 2010 ) : if ls [ i ] != 0 : ans += ls [ i ] * ( ls [ i ] - 1 ) \/\/ 2 if ld [ i ] != 0 : ans += ld [ i ] * ( ld [ i ] - 1 ) \/\/ 2 print ( ans ) NEW_LINE"],"bleu":0.34134804377481665,"rouge_l":0.45001844337882696}
{"id":337,"predictions":["def STR ( ) : return list ( input ( ) ) def INT ( ) : return int ( input ( ) ) def MAP ( ) : return map ( int , input ( ) . split ( ) ) def MAP2 ( ) : return map ( float , input ( ) . split ( ) ) def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) def STRING ( ) : return input ( ) import stringimport sysfrom heapq import heappop , heappushfrom bisect import * from collections import deque , Counter , defaultdictfrom math import * from itertools import permutations , accumulatedx = [ - 1 , 1 , 0 , 0 ] dy = [ 0 , 0 , 1 , - 1 ] NEW_LINE"],"references":["num = int ( input ( ) ) s = input ( ) s1 = s . count ( '1' ) s0 = s . count ( '0' ) output = abs ( s1 - s0 ) print ( output ) NEW_LINE","from sys import stdin , stdout   def main ( ) : n = stdin . readline ( ) s = stdin . readline ( ) [ : - 1 ] ones = s . count ( '1' ) zeros = len ( s ) - ones x = abs ( ones - zeros ) stdout . write ( str ( x ) + ' \\n ' )   if __name__ == \" _ _ main _ _ \" : main ( ) NEW_LINE","def Sol ( ) : t = int ( input ( ) ) s = list ( input ( ) ) n1 = s . count ( \"1\" ) n0 = s . count ( \"0\" ) print ( abs ( n1 - n0 ) ) if __name__ == \" _ _ main _ _ \" : Sol ( ) NEW_LINE","n = int ( input ( ) ) s = input ( )   num1 = s . count ( '1' ) num0 = s . count ( '0' ) print ( abs ( num0 - num1 ) ) NEW_LINE","n = int ( input ( ) ) s = input ( ) m = abs ( s . count ( '0' ) - s . count ( '1' ) ) print ( m ) NEW_LINE"],"bleu":0.1088576972178553,"rouge_l":0.3183953471031243}
{"id":338,"predictions":["n , m = map ( int , input ( ) . split ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) curr = 0 ans = [ ] for n in arr : curr += n turned = curr \/\/ m ans . append ( turned ) curr %= m   print ( * ans ) NEW_LINE"],"references":["t = int ( input ( ) ) for _ in range ( t ) : n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) p = list ( map ( int , input ( ) . split ( ) ) ) p = set ( p ) while ( 1 ) : f = 0 for i in range ( n - 1 ) : if a [ i ] > a [ i + 1 ] and i + 1 in p : a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i ] f = 1 if not f : break if a == sorted ( a ) : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE","for _ in range ( int ( input ( ) ) ) : n , k = map ( int , input ( ) . split ( ) ) a = [ int ( x ) for x in input ( ) . split ( ) ] b = [ int ( x ) for x in input ( ) . split ( ) ] flag = 1 ss = n for j in range ( ss ) : for i in range ( n - 1 ) : if a [ i ] > a [ i + 1 ] : if i + 1 not in b : flag = 0 break else : a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i ] for i in range ( n - 1 ) : if a [ i ] > a [ i + 1 ] : flag = 0 if flag : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE","def solve ( n , m , a , p ) : a = [ ( v , ai ) for ai , v in enumerate ( a ) ] sorted_a = sorted ( a ) target_idx = { } for si in range ( n ) : v , ai = sorted_a [ si ] target_idx [ ai ] = si   for v , ai in a : ti = target_idx [ ai ] if ai < ti : less , more = ai , ti else : less , more = ti , ai for j in range ( less , more ) : if j not in p : return ' NO ' return ' YES '   if __name__ == ' _ _ main _ _ ' : T = int ( input ( ) ) for t in range ( T ) : n , m = tuple ( map ( int , input ( ) . split ( ) ) ) a = list ( map ( int , input ( ) . split ( ) ) ) p = set ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) print ( solve ( n , m , a , p ) ) NEW_LINE","import sys   def answer ( n , m , a , p ) : p . sort ( ) NEW_LINE","def main ( ) : m , n = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) p = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( m - 1 ) : for j in range ( m - i - 1 ) : if a [ j ] > a [ j + 1 ] : if j + 1 in p : a [ j ] , a [ j + 1 ] = a [ j + 1 ] , a [ j ] else : print ( ' NO ' ) return 0 print ( \" YES \" ) return 0     for _ in range ( int ( input ( ) ) ) : main ( ) NEW_LINE"],"bleu":0.5180132251878315,"rouge_l":0.5697707330880272}
{"id":339,"predictions":["import sys , os , iodef rs ( ) : return sys . stdin . readline ( ) . rstrip ( ) def ri ( ) : return int ( sys . stdin . readline ( ) ) def ria ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) def ws ( s ) : sys . stdout . write ( s + ' \\n ' ) def wi ( n ) : sys . stdout . write ( str ( n ) + ' \\n ' ) def wia ( a ) : sys . stdout . write ( ' ▁ ' . join ( [ str ( x ) for x in a ] ) + ' \\n ' ) import math , datetime , functools , itertools , operator , bisect , fractions , statisticsfrom collections import deque , defaultdict , OrderedDict , Counterfrom fractions import Fractionfrom decimal import Decimalfrom sys import stdoutfrom heapq import heappush , heappop , heapify , _heapify_max , _heappop_max , nsmallest , nlargest NEW_LINE"],"references":["import sysinput = sys . stdin . readline   n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) adj = [ [ ] for i in range ( n ) ] for i in range ( n - 1 ) : u , v , w = map ( int , input ( ) . split ( ) ) u -= 1 v -= 1 adj [ u ] . append ( ( v , w ) ) adj [ v ] . append ( ( u , w ) ) best = [ 0 ] * nans = 0   def dfs ( u ) : stack = list ( ) visit = [ False ] * n stack . append ( ( u , - 1 ) ) while stack : u , par = stack [ - 1 ] if not visit [ u ] : visit [ u ] = True for v , w in adj [ u ] : if v != par : stack . append ( ( v , u ) ) else : cand = [ ] for v , w in adj [ u ] : if v != par : cand . append ( best [ v ] + a [ v ] - w ) cand . sort ( reverse = True ) cur = a [ u ] for i in range ( 2 ) : if i < len ( cand ) and cand [ i ] > 0 : cur += cand [ i ] global ans ans = max ( ans , cur ) best [ u ] = cand [ 0 ] if len ( cand ) > 0 and cand [ 0 ] > 0 else 0 stack . pop ( )   dfs ( 0 ) print ( ans ) NEW_LINE","from sys import stdin , setrecursionlimitimport threadingn = int ( stdin . readline ( ) ) w = [ int ( x ) for x in stdin . readline ( ) . split ( ) ] graph = [ { } for x in range ( n ) ] for road in range ( n - 1 ) : u , v , c = [ int ( x ) for x in stdin . readline ( ) . split ( ) ] u -= 1 v -= 1   if v in graph [ u ] : graph [ u ] [ v ] = min ( graph [ u ] [ v ] , c ) else : graph [ u ] [ v ] = c   if u in graph [ v ] : graph [ v ] [ u ] = min ( graph [ v ] [ u ] , c ) else : graph [ v ] [ u ] = c   gas = [ { } for x in range ( n ) ] highs = [ [ 0 , 0 ] for x in range ( n ) ]   path = [ ( 0 , 0 ) ]   ind = 0   while ind < len ( path ) : cur , par = path [ ind ] edges = graph [ cur ] for x in edges : if x != par : path . append ( ( x , cur ) ) ind += 1   def mostGas ( node , parent ) : edges = graph [ node ] high = w [ node ] high2 = w [ node ] for x in edges : if x != parent : gas [ node ] [ x ] = highs [ x ] [ 0 ] + w [ node ] - edges [ x ] if gas [ node ] [ x ] > high : high , high2 = gas [ node ] [ x ] , high elif gas [ node ] [ x ] > high2 : high2 = gas [ node ] [ x ] highs [ node ] = [ high , high2 ] return high   ''' def ▁ fillIn ( node , parent ) : ▁ ▁ ▁ ▁ edges ▁ = ▁ graph [ node ] ▁ ▁ ▁ ▁ high , high2 ▁ = ▁ highs [ node ] ▁ ▁ ▁ ▁ for ▁ x ▁ in ▁ edges : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ x ▁ ! = ▁ parent : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ gas [ node ] [ x ] ▁ = = ▁ high : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ gas [ x ] [ node ] ▁ = ▁ high2 ▁ - ▁ edges [ x ] ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ else : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ gas [ x ] [ node ] ▁ = ▁ high ▁ - ▁ edges [ x ] ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ gas [ x ] [ node ] ▁ > ▁ highs [ x ] [0 ] : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ highs [ x ] ▁ = ▁ [ gas [ x ] [ node ] , ▁ highs [ x ] [0 ] ] ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ elif ▁ gas [ x ] [ node ] ▁ > ▁ highs [ x ] [1 ] : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ highs [ x ] [1 ] ▁ = ▁ gas [ x ] [ node ] ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ fillIn ( x , node ) ''' for x , y in path [ : : - 1 ] : mostGas ( x , y ) NEW_LINE"],"bleu":0.11053723615058313,"rouge_l":0.22554691040214428}
{"id":340,"predictions":["import sysfrom os import pathif ( path . exists ( ' input . txt ' ) and path . exists ( ' output . txt ' ) ) : sys . stdout = open ( ' output . txt ' , ' w ' ) sys . stdin = open ( ' input . txt ' , ' r ' ) NEW_LINE"],"references":["s = input ( ) k = int ( input ( ) ) l = len ( s )   if l % k : print ( \" NO \" ) else : f = True t = l \/\/ k for i in range ( 0 , l , t ) : sub = s [ i : i + t ] if sub != sub [ : : - 1 ] : f = False break   print ( \" YES \" if f else \" NO \" )       NEW_LINE","if __name__ == ' _ _ main _ _ ' : Y = lambda : list ( map ( int , input ( ) . split ( ) ) ) P = lambda : map ( int , input ( ) . split ( ) ) N = lambda : int ( input ( ) )   s = input ( ) k = N ( ) d = dict ( )   if len ( s ) % k : print ( \" NO \" ) else : d = len ( s ) \/\/ k cnt = 0 for c in range ( 0 , len ( s ) , d ) : sub = s [ c : c + d ] cnt += ( s [ c : c + d ] == s [ c : c + d ] [ : : - 1 ] ) print ( \" YNEOS \" [ not cnt == k : : 2 ] ) NEW_LINE","s = input ( ) k = int ( input ( ) ) if len ( s ) % k != 0 : print ( \" NO \" ) else : i , n , z = 0 , len ( s ) \/\/ k , len ( s ) \/\/ k while z <= len ( s ) : x = s [ i : z ] if x != x [ : : - 1 ] : print ( \" NO \" ) break i += n z += n else : print ( \" YES \" ) NEW_LINE","  def isPal ( s ) : return s == s [ : : - 1 ]               strng = input ( ) k = int ( input ( ) ) leng = len ( strng ) rem = leng % kcheck = 1 if ( rem >= 1 or k > leng ) : print ( \" NO \" ) check = 0 NEW_LINE"],"bleu":0.049560864818016866,"rouge_l":0.21927118200075676}
{"id":341,"predictions":["import sysinput = sys . stdin . readlineimport math   def inpit ( ) : NEW_LINE"],"references":["from bisect import bisect_left   n , m , ta , tb , k = map ( int , input ( ) . split ( ) ) a = [ int ( X ) + ta for X in input ( ) . split ( ) ] b = [ int ( X ) for X in input ( ) . split ( ) ] an = - 1 NEW_LINE","n , m , ta , tb , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) )   if n <= k : print ( - 1 ) else : ind = 0 maxx = - 1 for i in range ( k + 1 ) : arriv = a [ i ] + ta while ( ind < m and b [ ind ] < arriv ) : ind += 1 if ind + ( k - i ) >= m : maxx = - 1 break else : maxx = max ( maxx , b [ ind + k - i ] + tb ) print ( maxx )   NEW_LINE","n , m , ta , tb , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) j = 0 ans = - 1 for i in range ( m ) : if j < n and a [ j ] + ta <= b [ i ] : k -= 1 j += 1 if k < 0 : ans = b [ i ] + tb break if j >= n : breakprint ( ans ) NEW_LINE","import sys , os , iodef rs ( ) : return sys . stdin . readline ( ) . rstrip ( ) def ri ( ) : return int ( sys . stdin . readline ( ) ) def ria ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) def ws ( s ) : sys . stdout . write ( s + ' \\n ' ) def wi ( n ) : sys . stdout . write ( str ( n ) + ' \\n ' ) def wia ( a ) : sys . stdout . write ( ' ▁ ' . join ( [ str ( x ) for x in a ] ) + ' \\n ' ) import math , datetime , functools , itertools , operator , bisect , fractions , statisticsfrom collections import deque , defaultdict , OrderedDict , Counterfrom fractions import Fractionfrom decimal import Decimalfrom sys import stdoutfrom heapq import heappush , heappop , heapify , _heapify_max , _heappop_max , nsmallest , nlargest   def main ( ) : NEW_LINE"],"bleu":0.011488210128657878,"rouge_l":0.15508474576271186}
{"id":342,"predictions":["class UnionFind : def __init__ ( self , n ) : self . parent = list ( range ( n ) ) def find ( self , a ) : NEW_LINE"],"references":["for i in range ( int ( input ( ) ) ) : print ( max ( 0 , int ( input ( ) ) - 2 ) ) NEW_LINE","for i in range ( int ( input ( ) ) ) : print ( max ( 0 , int ( input ( ) ) - 2 ) ) NEW_LINE","import sysinput = sys . stdin . readlinefor _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) if n > 2 : sys . stdout . write ( str ( n - 2 ) + ' \\n ' ) else : sys . stdout . write ( '0 \\n ' ) NEW_LINE","import sysinput = sys . stdin . readlinefor _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) if n > 2 : sys . stdout . write ( str ( n - 2 ) + ' \\n ' ) else : sys . stdout . write ( '0 \\n ' ) NEW_LINE","import sysinput = sys . stdin . readlinet = int ( input ( ) ) for you in range ( t ) : n = int ( input ( ) ) print ( max ( 0 , n - 2 ) ) NEW_LINE"],"bleu":0.10720584928216016,"rouge_l":0.33961456102783727}
{"id":343,"predictions":["n , k = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) diff = max ( l ) - min ( l ) if diff == 0 : print ( 0 , 0 ) elif diff == 1 : print ( 1 , 0 ) else : s = 0 ans = [ ] while ( s < k ) : x = l . index ( min ( l ) ) y = l . index ( max ( l ) ) if max ( l ) - min ( l ) <= k : break else :   s += 1 l [ x ] = l [ y ] print ( x ) NEW_LINE"],"references":["a , b = map ( int , input ( ) . split ( ) ) c = list ( map ( int , input ( ) . split ( ) ) ) ans = 0 mini = sum ( c ) for i in range ( b ) : d = i su = 0 while ( d < a ) :   su += c [ d ] d += b if su < mini :   mini = su ans = iprint ( ans + 1 ) NEW_LINE","n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) ans = 10 ** 9 bestI = 0 for i in range ( k ) : score = 0 r = n \/\/ k while r > 0 : score += a [ i ] i += k if i >= n : i -= n r -= 1 if score < ans : ans = score bestI = i + 1 print ( bestI ) NEW_LINE","def todo_list ( end , k , arr ) : count = 0 start = 0 result = 100000 * 1000000 while count != k : b = 0 for x in range ( start , end , k ) : b += arr [ x ] if b < result : result = b ans = start + 1 start += 1 count += 1   return ans     n , k = map ( int , input ( ) . split ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) print ( todo_list ( n , k , arr ) ) NEW_LINE","_ , k = map ( int , input ( ) . split ( ) ) v , s = map ( int , input ( ) . split ( ) ) , [ 0 ] * k   for ( i , x ) in enumerate ( v ) : s [ i % k ] += x   print ( min ( [ ( x , i ) for i , x in enumerate ( s ) ] ) [ 1 ] + 1 ) NEW_LINE","n , k = map ( int , input ( ) . split ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) min1 = 100000000000 c = 0 for i in range ( k ) : sum1 = sum ( arr [ i : : k ] ) NEW_LINE"],"bleu":0.32134586697321027,"rouge_l":0.5383809312965834}
{"id":344,"predictions":["import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE inf = 10 ** 20 NEW_LINE mod = 10 ** 9 + 7 NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def F ( ) : return float ( sys . stdin . readline ( ) ) NEW_LINE def S ( ) : return input ( ) NEW_LINE def main ( ) : NEW_LINE INDENT N , X = LI ( ) NEW_LINE W = sorted ( [ I ( ) for _ in range ( N ) ] , reverse = True ) NEW_LINE d = collections . defaultdict ( int ) NEW_LINE d [ 0 ] = 1 NEW_LINE for c in W [ N \/\/ 2 : ] : NEW_LINE INDENT t = collections . defaultdict ( int ) NEW_LINE for k , v in d . items ( ) : NEW_LINE INDENT if k + c > X : NEW_LINE INDENT continue NEW_LINE DEDENT t [ k + c ] += v NEW_LINE DEDENT for k , v in t . items ( ) : NEW_LINE INDENT d [ k ] += v NEW_LINE DEDENT DEDENT d2 = collections . defaultdict ( int ) NEW_LINE d2 [ 0 ] = 1 NEW_LINE for c in W [ : N \/\/ 2 ] : NEW_LINE INDENT t = collections . defaultdict ( int ) NEW_LINE for k , v in d2 . items ( ) : NEW_LINE INDENT if k + c > X : NEW_LINE INDENT continue NEW_LINE DED"],"references":["n , x = map ( int , input ( ) . split ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) dp = [ 0 ] * ( 1 << 18 ) ans = 0 NEW_LINE","n , x = map ( int , input ( ) . split ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) dp = [ 0 ] * ( 10 ** 6 + 1 ) for i in arr : dp [ i ] += 1 NEW_LINE","n , x = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) )   ans = 0 d = { } for k in a : if d . get ( k ^ x , 0 ) > 0 : ans += d . get ( k ^ x ) d [ k ] = d . get ( k , 0 ) + 1 print ( ans ) NEW_LINE"],"bleu":0.06039610227197238,"rouge_l":0.2405362776025237}
{"id":345,"predictions":["n , m , k = map ( int , input ( ) . split ( ) ) a = [ input ( ) . split ( ) for _ in ' ▁ ' * n ] r = { str ( i ) : i - 1 for i in range ( 1 , n + 1 ) } c = { str ( i ) : i - 1 for i in range ( 1 , m + 1 ) } ans = [ ] for _ in range ( k ) : ch , x , y = input ( ) . split ( ) if ch == ' c ' : c [ x ] , c [ y ] = c [ y ] , c [ x ] elif ch == ' r ' : r [ x ] , r [ y ] = r [ y ] , r [ x ] elif ch == ' c ' : r [ x ] , r [ y ] = r [ y ] , r [ x ] elif ch == ' r ' : r [ x ] , r [ y ] ] = r [ y ] , r [ x ] else : r [ y ] = r [ x ] , r [ y ] ] ans . append ( a [ x ] , r [ y ] ) print ( ' \\n ' . join ( ans ) ) NEW_LINE"],"references":["x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) x , y = map ( int , input ( ) . split ( ) ) if ( x2 - x1 ) % x == 0 and ( y2 - y1 ) % y == 0 : if ( ( x2 - x1 ) \/\/ x + ( y2 - y1 ) \/\/ y ) % 2 == 0 : print ( \" YES \" ) else : print ( \" NO \" ) else : print ( \" NO \" ) NEW_LINE","x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) x , y = map ( int , input ( ) . split ( ) ) if x1 == x2 and y1 == y2 : print ( \" YES \" ) elif x2 == x1 and abs ( y2 - y1 ) % y == 0 : move_y = abs ( y2 - y1 ) \/\/ y if move_y % 2 == 0 : print ( \" YES \" ) else : print ( \" NO \" ) elif y2 == y1 and abs ( x2 - x1 ) % x == 0 : move_x = abs ( x2 - x1 ) \/\/ x if move_x % 2 == 0 : print ( \" YES \" ) else : print ( \" NO \" ) elif abs ( x2 - x1 ) % x == 0 and abs ( y2 - y1 ) % y == 0 : move_x = abs ( x2 - x1 ) \/\/ x ; move_y = abs ( y2 - y1 ) \/\/ y NEW_LINE","import mathdef main ( ) : x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) x , y = map ( int , input ( ) . split ( ) )   dx = abs ( x1 - x2 ) dy = abs ( y1 - y2 )   if dx % x == 0 and dy % y == 0 : if ( dx \/ x ) % 2 == ( dy \/ y ) % 2 : print ( \" YES \" ) else : print ( \" NO \" ) else : print ( \" NO \" )                                       if __name__ == ' _ _ main _ _ ' : main ( ) NEW_LINE","a , b , c , d = map ( int , input ( ) . split ( ) ) x , y = map ( int , input ( ) . split ( ) ) m = abs ( c - a ) n = abs ( d - b ) if m % x != 0 or n % y != 0 : print ( ' NO ' ) elif ( m \/\/ x ) % 2 != ( n \/\/ y ) % 2 : print ( ' NO ' ) else : print ( ' YES ' ) NEW_LINE","a , b , c , d = map ( int , input ( ) . split ( ) ) x , y = map ( int , input ( ) . split ( ) ) m = abs ( c - a ) n = abs ( d - b ) if m % x != 0 or n % y != 0 : print ( ' NO ' ) elif ( m \/\/ x ) % 2 != ( n \/\/ y ) % 2 : print ( ' NO ' ) else : print ( ' YES ' ) NEW_LINE"],"bleu":0.12640681168752618,"rouge_l":0.3237006489174601}
{"id":346,"predictions":["n , m = map ( int , input ( ) . split ( ) )   if n == 1 : print ( 1 ) print ( 1 ) else : print ( m - 1 ) NEW_LINE"],"references":["def new ( n ) : while n % 10 == 0 : n = n \/\/ 10 return n if __name__ == ' _ _ main _ _ ' : n = int ( input ( ) ) d = dict ( ) c = 1 flag = 1 d . setdefault ( n , 1 ) while flag == 1 : n = n + 1 n = new ( n ) d . setdefault ( n , 0 ) if d [ n ] == 0 : d [ n ] = 1 c += 1 else : flag = 0 print ( c ) NEW_LINE","n = int ( input ( ) ) ans = 0 i = 1 while n > 0 : if i == 1 : if n < 10 : ans += 9 n = 0 else : temp = n % 10 ans += 10 - temp n = n \/\/ 10 i += 1 else : if n < 10 : ans += 9 n = 0 else : temp = ( n % 10 ) + 1 ans += 10 - temp n = n \/\/ 10 print ( ans ) NEW_LINE","def f ( x ) : x += 1 while ( x % 10 == 0 ) : x \/\/= 10 return x   a = set ( ) n = int ( input ( ) )   while ( not ( n in a ) ) : a . add ( n ) n = f ( n )   print ( len ( a ) ) NEW_LINE","def f ( x ) : x += 1 while ( x % 10 == 0 ) : x \/\/= 10 return x   a = set ( ) n = int ( input ( ) )   while ( not ( n in a ) ) : a . add ( n ) n = f ( n )   print ( len ( a ) ) NEW_LINE","a = input ( ) ; b = len ( a ) ; print ( 9 * b - sum ( map ( int , a [ 1 : ] ) ) + ( b > 1 ) ) NEW_LINE"],"bleu":0.2435141225097728,"rouge_l":0.4347262714609653}
{"id":347,"predictions":["x1 , y1 = map ( int , input ( ) . split ( ) ) x2 , y2 = map ( int , input ( ) . split ( ) ) print ( max ( abs ( x1 - x2 ) , abs ( y1 - y2 ) ) ) NEW_LINE"],"references":["T_ON = 0 DEBUG_ON = 0 MOD = 998244353     def solve ( ) : a , b = read_ints ( ) x , y , z = read_ints ( ) print ( max ( 0 , 2 * x + y - a ) + max ( 0 , y + 3 * z - b ) )     def main ( ) : T = read_int ( ) if T_ON else 1 for i in range ( T ) : solve ( )     def debug ( * xargs ) : if DEBUG_ON : print ( * xargs )     from collections import * import math     NEW_LINE","a , b = list ( map ( int , input ( ) . split ( ) ) ) x , y , z = list ( map ( int , input ( ) . split ( ) ) ) ans = 0 p = a - ( ( x * 2 ) + y ) q = b - ( ( z * 3 ) + y ) NEW_LINE","A , B = map ( int , input ( ) . split ( ) ) x , y , z = map ( int , input ( ) . split ( ) ) A1 = 2 * x + y - AB1 = 3 * z + y - Bfinal = 0 if A1 > 0 : final = final + A1if B1 > 0 : final = final + B1print ( final ) NEW_LINE","a , b = map ( int , input ( ) . split ( ) ) x , y , z = map ( int , input ( ) . split ( ) ) if a < x * 2 + y : ry = x * 2 + y - aelse : ry = 0 if b < y + z * 3 : rb = y + z * 3 - belse : rb = 0 print ( ry + rb ) NEW_LINE","yellow , blue = map ( int , input ( ) . split ( ) ) x , y , z = map ( int , input ( ) . split ( ) ) ry = x * 2 + yrb = z * 3 + yr1 , r2 = 0 , 0 if ry - yellow < 0 : r1 = 0 else : r1 = ry - yellowif rb - blue < 0 : r2 = 0 else : r2 = rb - blueprint ( r1 + r2 ) NEW_LINE"],"bleu":0.4177245067018505,"rouge_l":0.5589005235602095}
{"id":348,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) ans = [ ] for i in range ( 1 , n + 1 ) : ans . append ( a [ i - 1 ] + a [ i ] ) print ( * ans ) NEW_LINE"],"references":["n = input ( )   p0 = [ 1 ] p1 = [ 0 , 1 ]   if n == 1 : print 1 print 0 , 1 print 0 print 1 exit ( )   for i in xrange ( 2 , n + 1 ) : p = [ 0 for j in xrange ( i + 1 ) ]   for j in xrange ( len ( p1 ) ) : p [ j + 1 ] = p1 [ j ] for j in xrange ( len ( p0 ) ) : p [ j ] += p0 [ j ]   for j in xrange ( len ( p ) ) : p [ j ] %= 2   if i == n : print i print ' ▁ ' . join ( map ( str , p ) ) print i - 1 print ' ▁ ' . join ( map ( str , p1 ) )   p0 = [ p1 [ j ] for j in xrange ( len ( p1 ) ) ] p1 = [ p [ j ] for j in xrange ( len ( p ) ) ] NEW_LINE","n = int ( input ( ) ) p = [ [ 1 ] , [ 0 , 1 ] ] for i in range ( n - 1 ) : t = [ 0 ] + p [ - 1 ] for j in range ( len ( p [ i ] ) ) : t [ j ] ^= p [ i ] [ j ] p . append ( t ) print ( n ) print ( * p [ n ] ) print ( n - 1 ) print ( * p [ - 2 ] ) NEW_LINE","n = int ( input ( ) )   def print_poly ( a ) : print ( len ( a ) - 1 ) print ( ' ▁ ' . join ( map ( str , a ) ) )   def shift_add ( a , mul , b ) : c = [ 0 ] * ( len ( a ) + 1 ) for i in range ( len ( a ) ) : c [ i + 1 ] = a [ i ] * mul for i in range ( len ( b ) ) : c [ i ] += b [ i ] return c   a = [ 0 , 1 ] b = [ 1 ]   for i in range ( n - 1 ) : c = shift_add ( a , 1 , b ) if max ( c ) <= 1 and min ( c ) >= - 1 : a , b = c , a else : c = shift_add ( a , - 1 , b ) if max ( c ) <= 1 and min ( c ) >= - 1 : a , b = c , a else : print ( ' > ▁ < ' )   if a [ - 1 ] == - 1 : a = list ( map ( lambda x : - x , a ) ) if b [ - 1 ] == - 1 : b = list ( map ( lambda x : - x , b ) )   print_poly ( a ) print_poly ( b ) NEW_LINE","f = [ [ 1 ] , [ 0 , 1 ] ]   n = int ( input ( ) )   for i in range ( 2 , n + 1 ) : l = [ 0 ] + f [ i - 1 ] for j in range ( len ( f [ i - 2 ] ) ) : l [ j ] = ( l [ j ] + f [ i - 2 ] [ j ] ) & 1 f . append ( l )   print ( n ) print ( * f [ n ] ) print ( n - 1 ) print ( * f [ n - 1 ] )       NEW_LINE"],"bleu":0.30855727271739364,"rouge_l":0.42657342657342656}
{"id":349,"predictions":["l1 = list ( str ( input ( ) ) ) l2 = list ( str ( input ( ) ) ) l3 = list ( str ( input ( ) ) ) s = ' ' for i in l3 : if i . isalpha ( ) and i . isupper ( ) : lcase = i . lower ( ) if lcase in l1 : idx1 = l1 . index ( i ) s = s + l2 [ idx1 ] elif i . islower ( ) : if lcase [ l1 ] > s [ l2 ] : s = s + l2 [ l3 [ idx2 ] else : s += l1 [ l2 [ l3 [ 0 ] ] l2 [ 1 ] if s < l2 [ l1 [ 0 ] ] : s += l1 [ 0 ] print ( s ) NEW_LINE"],"references":["x = input ( ) . lower ( ) y = input ( ) . lower ( ) if ( x < y ) : print ( \" - 1\" ) elif ( x > y ) : print ( \"1\" ) else : print ( \"0\" ) NEW_LINE","str1 = input ( ) . lower ( ) str2 = input ( ) . lower ( )   if str1 < str2 : print ( - 1 ) elif str2 < str1 : print ( 1 ) else : print ( 0 ) NEW_LINE","a = input ( ) . lower ( ) b = input ( ) . lower ( ) z = len ( a ) NEW_LINE","a = input ( ) . lower ( ) b = input ( ) . lower ( ) z = len ( a ) NEW_LINE"],"bleu":0.06776072518936747,"rouge_l":0.33165048543689324}
{"id":350,"predictions":["import sysinput = sys . stdin . readlineimport math   def inpit ( ) : NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) used = [ 0 ] * ( n + 1 ) ans = [ 0 ] * ( n + 1 )   for x , y in zip ( a , a [ 1 : ] ) : z = ( y - x ) % n or n if ans [ x ] == 0 and used [ z ] or ans [ x ] != 0 and ans [ x ] != z : print ( - 1 ) exit ( ) used [ z ] = 1 ans [ x ] = z   i = 1 for j in range ( 1 , n + 1 ) : if ans [ j ] == 0 : while used [ i ] : i += 1 ans [ j ] = i i += 1   print ( * ans [ 1 : ] ) NEW_LINE","\"\"\" Author ▁ ▁ ▁ ▁ : ▁ co _ devil ▁ Chirag ▁ GargInstitute ▁ : ▁ JIIT \"\"\"     from __future__ import division , print_functionfrom sys import stdin , stdoutimport itertools , os , sys , threadingfrom collections import deque , Counter , OrderedDict , defaultdictimport heapqfrom math import ceil , floor , log , sqrt , factorial , pow , pi , gcd NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) ans = [ None ] * nl = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( 1 , m ) : d = ( l [ i ] - l [ i - 1 ] ) % n if d == 0 : d += n if ans [ l [ i - 1 ] - 1 ] == None or ans [ l [ i - 1 ] - 1 ] == d : ans [ l [ i - 1 ] - 1 ] = d else : print ( - 1 ) quit ( ) l = [ i + 1 for i in range ( n ) ] for i in ans : if i in l : l . remove ( i ) elif i != None : print ( - 1 ) quit ( ) for i in ans : if i == None : print ( l [ - 1 ] , end = \" ▁ \" ) l . pop ( ) else : print ( i , end = \" ▁ \" ) NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) a = [ - 1 ] * ns = set ( range ( 1 , n + 1 ) ) d = set ( ) for i in range ( m - 1 ) : for j in range ( 1 , n + 1 ) : if ( l [ i ] + j - l [ i + 1 ] ) % n == 0 : if j in d and a [ l [ i ] - 1 ] != j : print ( - 1 ) exit ( ) a [ l [ i ] - 1 ] = j d . add ( j ) breakb = list ( s - s . intersection ( d ) ) k = 0 for i in range ( n ) : if a [ i ] == - 1 : if k == len ( b ) : print ( - 1 ) exit ( ) a [ i ] = b [ k ] k += 1 print ( * a ) NEW_LINE","n , m = input ( ) . split ( ' ▁ ' ) L = input ( ) . split ( ' ▁ ' )   n , m = int ( n ) , int ( m ) for i in range ( m ) : L [ i ] = int ( L [ i ] )   A = [ - 1 ] * nused = [ 0 ] * nind = 1   for i in range ( m - 1 ) : step = ( L [ i + 1 ] - L [ i ] ) % n if step == 0 : step = n if A [ L [ i ] - 1 ] == - 1 and used [ step - 1 ] == 0 : A [ L [ i ] - 1 ] = step used [ step - 1 ] = 1 elif A [ L [ i ] - 1 ] == step : continue else : ind = 0 break   if ind == 0 : print ( - 1 ) else : indused = 0 for i in range ( n ) : if A [ i ] == - 1 : while used [ indused ] == 1 : indused += 1 A [ i ] = indused + 1 indused += 1 print ( A [ i ] , end = ' ▁ ' ) NEW_LINE"],"bleu":0.005654623963052335,"rouge_l":0.11304670126019274}
{"id":351,"predictions":["t = int ( input ( ) ) for i in range ( t ) : n = int ( input ( ) ) if ( n <= 3 ) : print ( 4 - n ) else : print ( n % 2 ) NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) while n > 0 and m > 0 : if n >= 2 * m : n = n % ( 2 * m ) elif m >= 2 * n : m = m % ( 2 * n ) else : breakprint ( n , m , sep = \" ▁ \" )   NEW_LINE","def STR ( ) : return list ( input ( ) ) def INT ( ) : return int ( input ( ) ) def MAP ( ) : return map ( int , input ( ) . split ( ) ) def MAP2 ( ) : return map ( float , input ( ) . split ( ) ) def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) def STRING ( ) : return input ( ) import stringimport sysfrom heapq import heappop , heappushfrom bisect import * from collections import deque , Counter , defaultdictfrom math import * from itertools import permutations , accumulatedx = [ - 1 , 1 , 0 , 0 ] dy = [ 0 , 0 , 1 , - 1 ] NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) a = nb = mwhile a * b > 0 : if a >= 2 * b : a = a % ( 2 * b ) elif b >= 2 * a : b = b % ( 2 * a ) else : breakprint ( a , b ) NEW_LINE","a , b = map ( int , input ( ) . split ( ) ) while a != 0 and b != 0 : if a >= 2 * b : a = a % ( 2 * b ) elif b >= 2 * a : b = b % ( 2 * a ) else : print ( a , b ) exit ( 0 ) print ( a , b ) NEW_LINE"],"bleu":0.24369019027988803,"rouge_l":0.376131006903331}
{"id":352,"predictions":["import sys , os , ioimport math , bisect , operatorinf , mod = float ( ' inf ' ) , 10 ** 9 + 7 NEW_LINE"],"references":["inp = input ( )   n = int ( inp [ 0 : ( len ( inp ) - 1 ) ] )   n -= 1   base = ( n \/\/ 4 ) * 16 + ( n % 2 ) * 7   def cnt ( s ) : if s == ' f ' : return 1 if s == ' e ' : return 2 if s == ' d ' : return 3 if s == ' a ' : return 4 if s == ' b ' : return 5 if s == ' c ' : return 6   print ( base + cnt ( inp [ len ( inp ) - 1 ] ) ) NEW_LINE","def f ( a ) : if a == \" a \" : return 4 if a == \" b \" : return 5 if a == \" c \" : return 6 if a == \" d \" : return 3 if a == \" e \" : return 2 if a == \" f \" : return 1   a = input ( ) b = int ( a [ : - 1 ] ) c = a [ - 1 ] s = ( ( b - 1 ) \/\/ 4 ) * 16 b = b % 2 if b == 1 : print ( s + f ( c ) ) else : print ( 7 + s + f ( c ) ) NEW_LINE","s = input ( ) n = int ( s [ : len ( s ) - 1 ] ) s = s [ - 1 ] ans = 0 if n % 2 == 0 : if ( n \/\/ 2 ) % 2 == 1 : ans = ans + ( ( ( n - 1 ) \/\/ 2 ) \/\/ 2 ) * 16 + 7 else : ans = ans + ( ( ( n - 3 ) \/\/ 2 ) \/\/ 2 ) * 16 + 7 else : if ( n \/\/ 2 ) % 2 == 0 : ans = ans + ( ( n \/\/ 2 ) \/\/ 2 ) * 16 else : ans = ans + ( ( ( n - 2 ) \/\/ 2 ) \/\/ 2 ) * 16 if s in [ ' d ' , ' e ' , ' f ' ] : ans = ans + abs ( ord ( s ) - ord ( ' f ' ) ) + 1 else : ans = ans + abs ( ord ( s ) - ord ( ' a ' ) ) + 4 print ( ans ) NEW_LINE","def f ( a ) : if a == \" a \" : return 4 if a == \" b \" : return 5 if a == \" c \" : return 6 if a == \" d \" : return 3 if a == \" e \" : return 2 if a == \" f \" : return 1 a = input ( ) b = int ( a [ : - 1 ] ) c = a [ - 1 ] s = ( ( b - 1 ) \/\/ 4 ) * 16 b = b % 2 if b == 1 : print ( s + f ( c ) ) else : print ( 7 + s + f ( c ) ) NEW_LINE"],"bleu":0.0029923761512559532,"rouge_l":0.07340553549939831}
{"id":353,"predictions":["n , m , k = map ( int , input ( ) . split ( ) ) print ( m * n - m ) NEW_LINE"],"references":["n = int ( input ( ) ) arr = [ i for i in range ( n ) ] NEW_LINE","r = int ( input ( ) ) if r % 2 == 0 : print ( - 1 ) elif r == 1 : print ( 0 ) print ( 0 ) print ( 0 )   else : for i in range ( r ) : print ( i , end = \" ▁ \" ) print ( ) i = r - 1 while i >= 0 : print ( i , end = \" ▁ \" ) i -= 2 i = r - 2 while i >= 0 : print ( i , end = \" ▁ \" ) i -= 2 print ( ) for i in range ( r - 1 , - 1 , - 1 ) : print ( i , end = \" ▁ \" )   NEW_LINE","r = int ( input ( ) ) if r % 2 == 0 : print ( - 1 ) elif r == 1 : print ( 0 ) print ( 0 ) print ( 0 )   else : for i in range ( r ) : print ( i , end = \" ▁ \" ) print ( ) i = r - 1 while i >= 0 : print ( i , end = \" ▁ \" ) i -= 2 i = r - 2 while i >= 0 : print ( i , end = \" ▁ \" ) i -= 2 print ( ) for i in range ( r - 1 , - 1 , - 1 ) : print ( i , end = \" ▁ \" ) NEW_LINE"],"bleu":0.18997051735480194,"rouge_l":0.5055932301628703}
{"id":354,"predictions":["a , b , c , d = input ( ) . split ( ) a , b , c , d = int ( a ) , int ( b ) , int ( c ) , int ( d ) def score ( p , t ) : sco = 0 sco1 = 3 * p \/ 10 sco2 = p - ( p * t \/ 250 ) if sco1 > sco2 : sco = sco1 return sco else : sco = sco2 return scosco_misha = score ( a , c ) sco_vasya = score ( b , d ) if sco_misha > sco_vasya : print ( \" Misha \" ) elif sco_misha < sco_vasya : print ( \" Vasya \" ) else : print ( \" Tie \" ) NEW_LINE"],"references":["import sysfrom collections import Counterdef fmax ( n , m , a ) : c = [ 0 ] * m b = [ 0 ] * n   if n == 3 * m : for i in range ( n \/\/ 3 ) : for j in range ( 3 ) : b [ a [ i ] [ j ] - 1 ] = j + 1 for i in range ( m ) : flag = 1 for j in range ( 3 ) : if b [ a [ i ] [ j ] - 1 ] != 0 : index = b [ a [ i ] [ j ] - 1 ] if j == 0 and index == 1 : continue b [ a [ i ] [ index - 1 ] - 1 ] = j + 1 continue b [ a [ i ] [ j ] - 1 ] = j + 1 return b if __name__ == ' _ _ main _ _ ' : input = sys . stdin . read ( ) data = list ( map ( int , input . split ( ) ) ) n = data [ 0 ] m = data [ 1 ] l = 0 a = [ ] for i in range ( m ) : a . append ( list ( map ( int , ( data [ l + 2 : l + 5 ] ) ) ) ) l = l + 3 print ( * fmax ( n , m , a ) ) NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) l = [ 0 ] * ( n + 1 ) for _ in range ( m ) : p = [ 1 , 2 , 3 ] arr = list ( map ( int , input ( ) . split ( ) ) ) for i in arr : if l [ i ] != 0 : p . remove ( l [ i ] ) for i in arr : if l [ i ] == 0 : l [ i ] = p . pop ( ) NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) x = [ ] for i in range ( m ) : x . append ( list ( map ( int , input ( ) . split ( ) ) ) ) d = { } for i , j in enumerate ( x ) : y = [ 1 , 2 , 3 ] if i == 0 : d [ j [ 0 ] ] = 1 d [ j [ 1 ] ] = 2 d [ j [ 2 ] ] = 3 continue for k in j : if k in d : y . remove ( d [ k ] ) c = 0 for k in j : if k not in d : d [ k ] = y [ c ] c += 1 x = sorted ( d ) for i in x : print ( d [ i ] , end = \" ▁ \" ) NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) arr = [ 0 ] * ( n + 1 ) for i in range ( m ) : a , b , c = map ( int , input ( ) . split ( ) ) temp = [ arr [ a ] , arr [ b ] , arr [ c ] ] if temp == [ 0 , 0 , 0 ] : arr [ a ] = 1 arr [ b ] = 2 arr [ c ] = 3 else : remain = list ( set ( [ 1 , 2 , 3 ] ) - set ( temp ) ) if arr [ a ] == 0 : arr [ a ] = remain . pop ( ) if arr [ b ] == 0 : arr [ b ] = remain . pop ( ) if arr [ c ] == 0 : arr [ c ] = remain . pop ( ) print ( * arr [ 1 : ] ) NEW_LINE","import sysimport mathclass DictList ( dict ) : def __setitem__ ( self , key , value ) : try : NEW_LINE"],"bleu":0.15966329067540525,"rouge_l":0.42370718983896577}
{"id":355,"predictions":["import sys   def main ( ) : n = int ( sys . stdin . read ( ) . strip ( ) ) return n   print ( main ( ) ) NEW_LINE"],"references":["def odd ( lst , n ) : for i in range ( 1 , n + 1 , 2 ) : lst . append ( i ) def even ( lst , n ) : start = 2 if len ( lst ) == 1 or n == 3 : start = 4 for j in range ( start , n + 1 , 2 ) : lst . append ( j )           n = int ( input ( ) ) lst = [ ]   if n % 2 == 0 and n > 2 : even ( lst , n ) odd ( lst , n ) else : odd ( lst , n ) even ( lst , n ) print ( len ( lst ) ) print ( * lst ) NEW_LINE","n = int ( input ( ) ) if n == 1 : print ( 1 ) print ( 1 ) elif n <= 3 : print ( n - 1 ) if n == 2 : print ( 1 ) else : print ( 1 , 3 ) else : print ( n ) for i in range ( 2 , n + 1 , 2 ) : print ( i , end = \" ▁ \" ) for i in range ( 1 , n + 1 , 2 ) : print ( i , end = \" ▁ \" ) print ( ) NEW_LINE","n = int ( input ( ) ) k = [ ] for i in range ( 1 , n + 1 ) : if i % 2 != 0 : k . append ( i ) for i in range ( 1 , n + 1 ) : if i % 2 == 0 : k . append ( i ) if n == 2 : print ( 1 ) print ( 1 ) elif n == 3 : print ( 2 ) print ( * [ 1 , 3 ] ) elif n == 4 : print ( 4 ) print ( * [ 3 , 1 , 4 , 2 ] ) else : print ( n ) print ( * k ) NEW_LINE","from itertools import chainn = int ( input ( ) )   if n == 1 or n == 2 : print ( 1 ) print ( 1 ) exit ( 0 ) elif n == 3 : print ( 2 ) print ( '1 ▁ 3' ) exit ( ) elif n == 4 : print ( 4 ) print ( '3 ▁ 1 ▁ 4 ▁ 2' ) exit ( 0 ) else : ans = list ( ) if n % 2 : ans = [ i for i in chain ( ( i for i in range ( 1 , n + 1 , 2 ) ) , ( i for i in range ( 2 , n , 2 ) ) ) ] else : ans = [ i for i in chain ( ( i for i in range ( 2 , n + 1 , 2 ) ) , ( i for i in range ( 1 , n , 2 ) ) ) ] print ( n ) print ( ' ▁ ' . join ( str ( i ) for i in ans ) ) NEW_LINE","n = int ( input ( ) ) k = nif n == 1 : print ( 1 ) print ( 1 ) elif n == 2 : print ( 1 ) print ( 1 ) elif n == 3 : print ( 2 ) print ( 1 , 3 ) elif n % 2 == 0 : print ( n ) for i in range ( 2 , n \/\/ 2 + 1 ) : print ( i , k , end = ' ▁ ' ) k -= 1                     print ( 1 , k ) else : print ( n ) for i in range ( 2 , n \/\/ 2 + 2 ) : if i < n \/\/ 2 + 1 : print ( i , k , end = ' ▁ ' ) k -= 1 else : print ( i , end = ' ▁ ' ) print ( 1 , k ) NEW_LINE"],"bleu":0.02233231336958255,"rouge_l":0.22669144168761612}
{"id":356,"predictions":["import sys , os , ioimport math , bisect , operatorinf , mod = float ( ' inf ' ) , 10 ** 9 + 7 NEW_LINE"],"references":["def count ( x1 , y1 , z1 , x2 , y2 , z2 ) : if x2 == 0 and a != 0 or y2 == 0 and b != 0 or z2 == 0 and c != 0 : return False if x2 == 0 : x2 = 1 if y2 == 0 : y2 = 1 if z2 == 0 : z2 = 1 return ( x1 \/ x2 ) ** a * ( y1 \/ y2 ) ** b * ( z1 \/ z2 ) ** c < 1     n = int ( input ( ) ) a , b , c = map ( int , input ( ) . split ( ) ) l1 , r1 = 0 , nfor i in range ( 200 ) : x1 = l1 + ( r1 - l1 ) \/ 3 l2 , r2 = 0 , n - x1 for j in range ( 200 ) : y1 = l2 + ( r2 - l2 ) \/ 3 y2 = r2 - ( r2 - l2 ) \/ 3 if count ( x1 , y1 , n - x1 - y1 , x1 , y2 , n - x1 - y2 ) : l2 = y1 else : r2 = y2 y11 = l2 x2 = r1 - ( r1 - l1 ) \/ 3 l2 , r2 = 0 , n - x2 for j in range ( 200 ) : y1 = l2 + ( r2 - l2 ) \/ 3 y2 = r2 - ( r2 - l2 ) \/ 3 if count ( x2 , y1 , n - x2 - y1 , x2 , y2 , n - x2 - y2 ) : l2 = y1 else : r2 = y2 y22 = l2 if count ( x1 , y11 , n - x1 - y11 , x2 , y22 , n - x2 - y22 ) : l1 = x1 p = y11 else : r1 = x2 p = y22print ( l1 , p , n - l1 - p ) NEW_LINE","n = int ( input ( ) ) a , b , c = map ( int , input ( ) . split ( ) ) s = a + b + cif ( s == 0 ) : print ( 0 , 0 , 0 ) else : print ( n * a \/ s , n * b \/ s , n * c \/ s ) NEW_LINE","def gribnye ( s , a , b , c ) : if a == b == c == s == 0 : return [ 0.0 ] elif a == b == c == 0 and s != 0 : return 0 , 0 , 0 a1 = a * s \/ ( a + b + c ) b1 = b * s \/ ( a + b + c ) c1 = c * s \/ ( a + b + c ) return a1 , b1 , c1     S = int ( input ( ) ) A , B , C = [ int ( i ) for i in input ( ) . split ( ) ] print ( * gribnye ( S , A , B , C ) ) NEW_LINE","s = int ( input ( ) ) a , b , c = map ( int , input ( ) . split ( ) ) sum = a + b + cif a + b + c : print ( a * s \/ sum , b * s \/ sum , c * s \/ sum ) else : print ( 0 , s , 0 ) NEW_LINE","a = int ( input ( ) )   b = list ( map ( int , input ( ) . split ( ) ) )   if sum ( b ) == 0 : print ( ' ▁ ' . join ( [ str ( a \/ 3 ) ] * 3 ) )   else : print ( ' ▁ ' . join ( map ( str , map ( lambda x : a * x \/ sum ( b ) , b ) ) ) )           NEW_LINE"],"bleu":0.0198971175412322,"rouge_l":0.16207729468599036}
{"id":357,"predictions":["n , m , k = list ( map ( int , input ( ) . split ( ) ) ) matrix = [ input ( ) . split ( ) for i in range ( n ) ] row = [ i for i in range ( m ) ] col = [ i for i in range ( n ) ]   ans = [ ] for i in range ( k ) : s , x , y = input ( ) . split ( ) x , y = int ( x ) - 1 , int ( y ) - 1 if s == \" c \" : col [ x ] , col [ y ] = col [ y ] , col [ x ] elif s == \" r \" : row [ x ] , row [ y ] = row [ y ] , row [ x ] else : ans . append ( matrix [ row [ x ] ] [ col [ y ] ] )   print ( \" \\n \" . join ( ans ) ) NEW_LINE"],"references":["s = input ( ) n = len ( s ) ans = s [ - 1 ] for i in range ( n - 2 , - 1 , - 1 ) : if s [ i ] >= ans [ - 1 ] : ans += s [ i ] print ( ans [ : : - 1 ] ) NEW_LINE","s = list ( input ( ) ) a = list ( set ( s ) ) a . sort ( reverse = True ) l = [ ] k = 0 for j in range ( len ( a ) ) : for i in range ( k , len ( s ) ) : if ( a [ j ] == s [ i ] ) : l . append ( s [ i ] ) k = iprint ( \" \" . join ( l ) ) NEW_LINE","si = input ( ) ans = \" \" while 1 : co = si . count ( max ( si ) ) ans = ans + max ( si ) * co NEW_LINE"],"bleu":0.14033197488331742,"rouge_l":0.41185567349517316}
{"id":358,"predictions":["n , m = map ( int , input ( ) . split ( ) ) f = n \/\/ mq = n % m   mini = ( f * ( f - 1 ) ) \/\/ ( 1 + 1 ) mini *= mmini += f * q ma = n - mma = ( ma * ( ma + 1 ) ) \/\/ ( 1 + 1 ) print ( mini , ma ) NEW_LINE"],"references":["n , k = map ( int , input ( ) . split ( ) ) lst = sorted ( [ int ( i ) % k for i in input ( ) . split ( ) ] ) low , high = 0 , n - 1 count = 0   while low < high : if lst [ low ] + lst [ high ] == k : low += 1 high -= 1 count += 2 elif lst [ low ] + lst [ high ] < k : low += 1 else : high -= 1   print ( count + 2 * ( lst . count ( 0 ) \/\/ 2 ) ) NEW_LINE","from sys import stdinstdin . readlinedef mp ( ) : return list ( map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) ) def it ( ) : return int ( stdin . readline ( ) . strip ( ) ) from math import ceil , sqrt , gcd , factorial NEW_LINE","def maxPairs ( nums , k ) : m = { } result = 0 for i in nums : if ( ( i in m ) and m [ i ] > 0 ) : m [ i ] = m [ i ] - 1 result += 1 else : if k - i in m : m [ k - i ] += 1 else : m [ k - i ] = 1 return result     def solve ( ) : n , k = map ( int , input ( ) . split ( ) ) d = list ( map ( lambda x : int ( x ) % k , input ( ) . split ( ) ) ) return ( d . count ( 0 ) \/\/ 2 + maxPairs ( d , k ) ) * 2 print ( solve ( ) ) NEW_LINE"],"bleu":0.26427194940484533,"rouge_l":0.38057040998217473}
{"id":359,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = [ int ( i ) for i in input ( ) . split ( ) ] a . sort ( ) j = 0 for i in a : if i >= j : j += 1 print ( j ) NEW_LINE"],"references":["import sys NEW_LINE def main ( ) : NEW_LINE INDENT n , m = map ( int , sys . stdin . read ( ) . strip ( ) . split ( ) ) NEW_LINE m %= ( 1 + n ) * n \/\/ 2 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT m -= i NEW_LINE if not m : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif m < 0 : NEW_LINE INDENT return m + i NEW_LINE DEDENT DEDENT DEDENT print ( main ( ) ) NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) NEW_LINE it_is_end = False NEW_LINE while True : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if m >= i : NEW_LINE INDENT m -= i NEW_LINE DEDENT else : NEW_LINE INDENT it_is_end = True NEW_LINE break NEW_LINE DEDENT DEDENT if it_is_end : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( m ) NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) NEW_LINE i = 0 NEW_LINE while m > i : m , i = m - i - 1 , ( i + 1 ) % n NEW_LINE print ( m ) NEW_LINE","from collections import Counter NEW_LINE def func ( ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE s = int ( x * ( x + 1 ) \/ 2 ) NEW_LINE if y % s == 0 : NEW_LINE INDENT print ( \"0\" ) NEW_LINE return NEW_LINE DEDENT y = y % s NEW_LINE for i in range ( 1 , x + 1 ) : NEW_LINE INDENT if y >= i : NEW_LINE INDENT y -= i NEW_LINE DEDENT else : NEW_LINE INDENT print ( y ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT t = 1 NEW_LINE for i in range ( t ) : NEW_LINE INDENT func ( ) NEW_LINE DEDENT","temp = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE n = temp [ 0 ] NEW_LINE m = temp [ 1 ] NEW_LINE m = m % ( n * ( n + 1 ) \/\/ 2 ) NEW_LINE x = int ( ( - 1 + ( 1 + 8 * m ) ** ( 1 \/ 2 ) ) \/\/ 2 ) NEW_LINE print ( m - x * ( x + 1 ) \/\/ 2 ) NEW_LINE"],"bleu":0.47466789478810695,"rouge_l":0.5573271228950197}
{"id":360,"predictions":["import sys , mathsys . setrecursionlimit ( 10 ** 8 ) ''' def ▁ fun ( ) : ▁ ▁ ▁ ▁ for ▁ i ▁ in ▁ range ( 16 ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ for ▁ j ▁ in ▁ range ( 4 ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ i & (1 < < j ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( j , end = ' ' ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( ) import ▁ binarytreefrom ▁ collections ▁ import ▁ dequebst ▁ = ▁ binarytree . tree ( height = 4 , is _ perfect = True ) print ( bst ) def ▁ s ( bst ) : ▁ ▁ ▁ ▁ if ▁ bst : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ bst . left , bst . right ▁ = ▁ bst . right , bst . left ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ s ( bst . right ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ s ( bst . left ) s ( bst ) print ( bst ) ''' n , k = map ( int , input ( ) . split ( ) ) lst = list ( map ( int , input ( ) . split ( ) ) ) s = 0 for i in range ( n ) : s += math . ceil ( lst [ i ] \/ k ) print ( math . ceil ( s \/ 2 ) ) NEW_LINE"],"references":["a , b , c = map ( int , input ( ) . split ( ) ) data = list ( map ( int , input ( ) . split ( ) ) ) datb = list ( map ( int , input ( ) . split ( ) ) ) res = [ ] for i in range ( 1 , a + 1 ) : if i in data : res . append ( \"1\" ) else : res . append ( \"2\" ) print ( \" ▁ \" . join ( res ) ) NEW_LINE","n , a , b = map ( int , input ( ) . split ( ) ) ar = [ ] ar = list ( map ( int , input ( ) . split ( ) ) ) al = [ ] al = list ( map ( int , input ( ) . split ( ) ) ) l = [ ] for i in range ( 1 , n + 3 ) : l . append ( 0 ) ; for i in ar : l [ i ] = 1 for i in al : l [ i ] = 2 for i in range ( 1 , len ( l ) - 1 ) : print ( l [ i ] , end = \" ▁ \" )     NEW_LINE","n , a , b = input ( ) . split ( ) arth = list ( map ( int , input ( ) . split ( ) ) ) alex = list ( map ( str , input ( ) . split ( ) ) ) ans = [ '2' ] * int ( n ) for i in arth : ans [ i - 1 ] = '1' print ( \" ▁ \" . join ( ans ) ) NEW_LINE","a , b , c = map ( int , input ( ) . split ( ) ) arr1 = sorted ( map ( int , input ( ) . split ( ) ) ) arr2 = sorted ( map ( int , input ( ) . split ( ) ) )   ans = [ ] for i in range ( 1 , a + 1 ) : if i in arr1 : ans . append ( 1 ) else : ans . append ( 2 )   print ( * ans ) NEW_LINE"],"bleu":0.1560700795944128,"rouge_l":0.34278199454913105}
{"id":361,"predictions":["t = int ( input ( ) ) for i in range ( t ) : n , x = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) a . sort ( ) if x in a : print ( \" Yes \" ) else : print ( \" No \" ) NEW_LINE"],"references":["n = int ( input ( ) ) NEW_LINE for p in range ( n ) : n1 , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) [ : : - 1 ] NEW_LINE if p != n - 1 : z = input ( ) NEW_LINE for x in range ( n1 ) : if NEW_LINE a [ x ] + b [ x ] > k : print ( ' No ' ) NEW_LINE break else : print ( ' Yes ' ) NEW_LINE","import matht = int ( input ( ) ) NEW_LINE for i in range ( t ) :     NEW_LINE if i != 0 : input ( ) NEW_LINE n , x = list ( map ( int , input ( ) . split ( ) ) )   a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) )   l = [ ] NEW_LINE f = 0   for i in range ( int ( n ) ) :       l . append ( a [ i ] + b [ n - i - 1 ] )   for i in range ( len ( l ) ) :     NEW_LINE if l [ i ] > x : print ( \" No \" ) NEW_LINE f = 1 NEW_LINE break NEW_LINE if f == 0 : print ( \" Yes \" ) NEW_LINE","import sys   input = sys . stdin . buffer . readline   t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : n , x = map ( int , input ( ) . split ( ) ) NEW_LINE A = reversed ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE B = list ( map ( int , input ( ) . split ( ) ) )   ok = True NEW_LINE for a , b in zip ( A , B ) : if NEW_LINE a + b > x : ok = False NEW_LINE break   print ( \" Yes \" if ok else \" No \" )   if _ < t - 1 : input ( ) NEW_LINE","I , q = lambda : map ( int , input ( ) . split ( ) ) , int ( input ( ) ) NEW_LINE for j in range ( q ) : n , x = I ( ) ; a , b , t = sorted ( I ( ) ) , sorted ( I ( ) , reverse = 1 ) , 1 NEW_LINE for i in range ( n ) : if NEW_LINE a [ i ] + b [ i ] > x : t = 0 NEW_LINE print ( [ \" NO \" , \" YES \" ] [ t ] ) NEW_LINE if j < q - 1 : input ( ) NEW_LINE"],"bleu":0.45336459860688316,"rouge_l":0.5889663243624365}
{"id":362,"predictions":["import syssys . stdin = open ( ' input . txt ' , ' r ' ) sys . stdout = open ( ' output . txt ' , ' w ' ) s = input ( ) n = input ( ) if s == s [ : n ] : print ( ' ! ' ) exit ( 0 ) elif s [ n - 1 ] == s [ : n ] : print ( ' ? ' ) exit ( 0 ) if s [ n - 1 ] == s [ : ] : print ( ' ! ' ) exit ( 0 ) NEW_LINE"],"references":["import ren = int ( input ( ) ) NEW_LINE ans , sumL = 1 , 0 NEW_LINE for s in re . split ( \" [ . ? ! ] \" , input ( ) ) : s = s . strip ( ) + ' . ' NEW_LINE L = len ( s ) NEW_LINE if L > 1 : if NEW_LINE L > n : print ( \" Impossible \" ) NEW_LINE exit ( ) NEW_LINE if sumL + L + ( sumL > 0 ) > n : ans += 1 NEW_LINE sumL = L else : sumL = sumL + L + ( sumL > 0 ) NEW_LINE print ( ans ) NEW_LINE","import sysn = int ( input ( ) ) NEW_LINE s = str ( input ( ) ) NEW_LINE m = len ( s ) NEW_LINE cnt = 0 NEW_LINE gd = Falseans = 0 l NEW_LINE st = 0 NEW_LINE end = [ ' . ' , ' ? ' , ' ! ' ] NEW_LINE rem = 0 NEW_LINE for i in range ( m ) : cnt += 1 NEW_LINE if ( s [ i ] in end ) : gd = True NEW_LINE lst = cnt NEW_LINE","import re   n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE l = re . split ( r \" \\ . | \\ ? | \\ ! \" , s ) NEW_LINE r = [ len ( x . strip ( ) ) + 1 for x in l if len ( x . strip ( ) ) > 0 ] NEW_LINE if max ( r ) > n : NEW_LINE INDENT print ( \" Impossible \" ) else : NEW_LINE cur = - 1 NEW_LINE DEDENT ans = 1 NEW_LINE for i in r : if NEW_LINE cur + i + 1 <= n : cur = cur + i + 1 else : ans = ans + 1 NEW_LINE cur = i NEW_LINE print ( ans ) NEW_LINE","import ren = int ( input ( ) ) NEW_LINE ans , sumL = 1 , 0 NEW_LINE for s in re . split ( \" [ . ? ! ] \" , input ( ) ) : s = s . strip ( ) + ' . ' NEW_LINE L = len ( s ) NEW_LINE if L > 1 : if NEW_LINE L > n : print ( \" Impossible \" ) NEW_LINE exit ( ) NEW_LINE if sumL + L + ( sumL > 0 ) > n : ans += 1 NEW_LINE sumL = L else : sumL = sumL + L + ( sumL > 0 ) NEW_LINE print ( ans ) NEW_LINE","n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE sens = [ [ ] ] NEW_LINE for i in s : sens [ - 1 ] . append ( i ) NEW_LINE if i in [ ' . ' , ' ! ' , ' ? ' ] : sens . append ( [ ] ) NEW_LINE for i in range ( len ( sens ) ) : if NEW_LINE sens [ i ] : sens [ i ] = ' ' . join ( sens [ i ] ) NEW_LINE sens [ i ] = sens [ i ] . strip ( ) NEW_LINE if len ( sens [ i ] ) > n : print ( ' Impossible ' ) NEW_LINE exit ( 0 ) NEW_LINE sens . pop ( )   i = 0 NEW_LINE ans = 0 NEW_LINE while i < len ( sens ) : l = len ( sens [ i ] ) NEW_LINE while i + 1 < len ( sens ) and l + 1 + len ( sens [ i + 1 ] ) <= n : i += 1 NEW_LINE l += len ( sens [ i ] ) + 1 NEW_LINE i += 1 NEW_LINE ans += 1 NEW_LINE print ( ans ) NEW_LINE"],"bleu":0.2013307473640997,"rouge_l":0.36699512138683743}
{"id":363,"predictions":["import mathn , k = map ( int , input ( ) . split ( ) ) n -= 1 k -= 1 if n > ( k * ( k + 1 ) ) \/\/ 2 : print ( 0 ) else : print ( ( n + k ) \/\/ 2 * ( k - 1 ) \/\/ 2 ) + k ) NEW_LINE"],"references":["k , d , t = map ( int , input ( ) . split ( ) ) d = ( ( k + d - 1 ) \/\/ d ) * dn = 2 * t \/\/ ( d + k ) x = 2 * t % ( d + k ) if ( x <= 2 * k ) : ans = x \/ 2 + d * nelse : ans = x - k + d * nprint ( ans ) NEW_LINE","import math   k , d , t = input ( ) . split ( ) k = float ( k ) d = float ( d ) t = float ( t ) itr = float ( k \/ d ) itr = math . ceil ( itr ) d = d * itr   cycle1 = float ( k \/ t ) cycle2 = float ( ( d - k ) \/ ( 2 * t ) ) timer = d cycle = cycle1 + cycle2itr = 1 \/ cycleitr = math . floor ( itr )   if itr * cycle == 1 : print ( d * itr ) exit ( ) timer = d * itr if itr * cycle + cycle1 >= 1 : left = 1 - itr * cycle print ( timer + left \/ ( 1.0 \/ t ) ) else : timer += k left = 1 - itr * cycle - cycle1 print ( timer + left \/ ( 1.0 \/ ( 2.0 * t ) ) ) NEW_LINE","k , d , t = list ( map ( int , input ( ) . split ( ) ) ) if k % d == 0 : print ( t ) exit ( ) m = ( k + d - 1 ) \/\/ d * dif 2 * t % ( m + k ) == 0 : print ( m * 2 * t \/ ( m + k ) ) exit ( ) n = 2 * t \/\/ ( m + k ) res = n * mf = 1 - ( m + k ) * n \/ ( 2 * t ) if f <= k \/ t : print ( res + f * t ) else : res += k f -= k \/ t print ( res + f * 2 * t ) NEW_LINE","import math   def check ( tim , k , d , t ) : if ( tim < d ) :   sing = k dt = tim - k x = dt \/ 2 + sing if ( x >= t ) : return True else : return False dg = d - k it = math . floor ( tim \/ d ) sing = k * it doublet = dg * it rem = tim - sing - doublet if ( rem <= k ) : sing += rem else : sing += k rem -= k doublet += rem x = doublet \/ 2 + sing if ( x >= t ) : return True else : return False     k , d , t = map ( int , input ( ) . split ( ) ) if t <= k or d == k : print ( t ) else : d = math . ceil ( k \/ d ) * d if d == k : print ( t ) else : l = 0 r = 2 * t mid = 0 ans = r for i in range ( 0 , 150 ) : mid = ( l + r ) \/ 2 if ( check ( mid , k , d , t ) ) : r = mid ans = mid else : l = mid print ( ans ) NEW_LINE","import java . io . * ; import java . util . * ;   public class Main { public static void main ( String [ ] args ) throws IOException { \/\/ BufferedReader f = new BufferedReader ( new FileReader ( \" uva . in \" ) ) ; BufferedReader f = new BufferedReader ( new InputStreamReader ( System . in ) ) ; PrintWriter out = new PrintWriter ( new BufferedWriter ( new OutputStreamWriter ( System . out ) ) ) ; StringTokenizer st = new StringTokenizer ( f . readLine ( ) ) ; long k = Long . parseLong ( st . nextToken ( ) ) ; long d = Long . parseLong ( st . nextToken ( ) ) ; long t = Long . parseLong ( st . nextToken ( ) ) * 2 ; long temp ; if ( k <= d ) { temp = d ; } else { temp = k \/ d * d ; if ( temp < k ) { temp += d ; } } long temp2 = k + temp ; long temp3 = t \/ temp2 ; long temp4 = t - temp3 * temp2 ; double temp5 ; if ( temp4 <= k * 2 ) { temp5 = temp4 \/ 2.0 ; } else { temp5 = temp4 - k ; } out . println ( temp * temp3 + temp5 ) ; f . close ( ) ; out . close ( ) ; } } NEW_LINE"],"bleu":0.31449992046454156,"rouge_l":0.5034013605442177}
{"id":364,"predictions":["n = int ( input ( ) )   fingers = [ int ( i ) for i in input ( ) . split ( ' ▁ ' ) ] fingers = sum ( fingers ) res = 0 for i in range ( n ) : if fingers + i - 1 >= 1 : res += 1   print ( res ) NEW_LINE"],"references":["n = int ( input ( ) ) NEW_LINE r = lambda : list ( map ( str , input ( ) . split ( ) ) ) NEW_LINE ans = - float ( ' inf ' ) NEW_LINE winner = \" xx \" NEW_LINE for _ in range ( n ) : name , * score = r ( ) NEW_LINE point = 0 NEW_LINE for i in score [ 2 : ] : point += int ( i )     NEW_LINE","n = int ( input ( ) ) NEW_LINE names = [ ] NEW_LINE points = [ ] NEW_LINE for _ in range ( n ) : a = input ( ) . split ( ) NEW_LINE names . append ( a [ 0 ] ) NEW_LINE b = [ int ( i ) for i in a [ 1 : ] ] NEW_LINE point = 50 * ( 2 * b [ 0 ] - b [ 1 ] ) NEW_LINE for i in range ( 5 ) : point += b [ i + 2 ] NEW_LINE points . append ( point ) NEW_LINE max_point = points [ 0 ] NEW_LINE max_name = names [ 0 ] NEW_LINE for i in range ( n ) : if NEW_LINE max_point < points [ i ] : max_point = points [ i ] NEW_LINE max_name = names [ i ] NEW_LINE print ( max_name ) NEW_LINE","n = int ( input ( ) ) NEW_LINE ans = ' ' NEW_LINE mx = - 10 ** 100 NEW_LINE for i in range ( n ) : k = input ( ) . split ( ) NEW_LINE score = int ( k [ 1 ] ) * 100 - int ( k [ 2 ] ) * 50 + int ( k [ 3 ] ) + int ( k [ 4 ] ) + int ( k [ 5 ] ) + int ( k [ 6 ] ) + int ( k [ 7 ] ) NEW_LINE if score > mx : mx = score NEW_LINE ans = k [ 0 ] NEW_LINE print ( ans ) NEW_LINE","a = [ input ( ) . split ( ) for i in range ( int ( input ( ) ) ) ] NEW_LINE print ( sorted ( [ [ 100 * int ( a [ i ] [ 1 ] ) - 50 * int ( a [ i ] [ 2 ] ) + int ( a [ i ] [ 3 ] ) + int ( a [ i ] [ 4 ] ) + int ( a [ i ] [ 5 ] ) + int ( a [ i ] [ 6 ] ) + int ( a [ i ] [ 7 ] ) , a [ i ] [ 0 ] ] for i in range ( len ( a ) ) ] ) [ - 1 ] [ 1 ] ) NEW_LINE","Max = - 99999999999 L NEW_LINE eader = ' '   for _ in range ( int ( input ( ) ) ) : handle , plus , minus , a , b , c , d , e = input ( ) . split ( ) NEW_LINE plus , minus , a , b , c , d , e = map ( int , [ plus , minus , a , b , c , d , e ] ) NEW_LINE score = plus * 100 - minus * 50 + a + b + c + d + e   if Max < score : Max = score NEW_LINE Leader = handle   print ( Leader ) NEW_LINE"],"bleu":0.3787917258826239,"rouge_l":0.4744300746510149}
{"id":365,"predictions":["n , k = map ( int , input ( ) . split ( ) ) print ( ( k + n - 1 ) \/\/ n ) NEW_LINE"],"references":["def prime ( n ) : c = 0 for i in range ( 2 , int ( pow ( n , 0.5 ) ) + 1 ) : if ( n % i == 0 ) : c = 1 break return c       n = int ( input ( ) ) if ( n == 1 ) : print ( 3 ) elif ( n == 2 ) : print ( 4 ) else : for i in range ( 1 , n + 1 ) : c1 = prime ( n * i + 1 ) if ( c1 == 1 ) : break print ( i ) NEW_LINE","n = int ( input ( ) ) print ( 7 if n < 3 else n - 2 ) NEW_LINE","n = int ( input ( ) ) if n == 1 : print ( 8 ) elif n == 2 : print ( 4 ) else : print ( n - 2 ) NEW_LINE","import math   def is_prime ( n ) : for i in range ( 2 , n ) : if not n % i : return False return True     def main_function ( ) : n = int ( input ( ) ) m = 1 while is_prime ( n * m + 1 ) : m += 1 return m               print ( main_function ( ) ) NEW_LINE","import sys   stdin = sys . stdininf = 1 << 60 mod = 1000000007 eps = 1e-10   sys . setrecursionlimit ( 10 ** 7 )   ni = lambda : int ( ns ( ) ) nin = lambda y : [ ni ( ) for _ in range ( y ) ] na = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) nan = lambda y : [ na ( ) for _ in range ( y ) ] ns = lambda : stdin . readline ( ) . rstrip ( ) nsn = lambda y : [ ns ( ) for _ in range ( y ) ] nas = lambda : stdin . readline ( ) . split ( )   def is_prime ( x ) : i = 2 if x <= 1 : return False while i * i <= x : if x % i == 0 : return False i += 1 return True   n = ni ( ) m = 1 while is_prime ( n * m + 1 ) : m += 1   print ( m ) NEW_LINE"],"bleu":0.5049745296262663,"rouge_l":0.6461601140761867}
{"id":366,"predictions":["from math import * h , w = map ( int , input ( ) . split ( ) ) NEW_LINE"],"references":["import mathh , w = map ( int , input ( ) . split ( ) ) NEW_LINE if h \/ w >= 0.8 and h \/ w <= 1.25 and ( ( math . log ( h , 2 ) % 1 == 0 ) or ( math . log ( w , 2 ) % 1 == 0 ) ) : NEW_LINE INDENT print ( h , w ) else : NEW_LINE w1 = 2 ** ( math . log ( w , 2 ) \/\/ 1 ) NEW_LINE DEDENT h1 = min ( h , ( w1 * 1.25 ) \/\/ 1 ) NEW_LINE h2 = 2 ** ( math . log ( h , 2 ) \/\/ 1 ) NEW_LINE w2 = min ( w , ( h2 * 1.25 ) \/\/ 1 ) NEW_LINE if ( h1 \/ w1 >= 0.8 and h1 \/ w1 <= 1.25 ) and ( h2 \/ w2 >= 0.8 and h2 \/ w2 <= 1.25 ) : if NEW_LINE h1 >= h2 and h1 * w1 >= h2 * w2 : print ( int ( h1 ) , int ( w1 ) ) else : print ( int ( h2 ) , int ( w2 ) ) elif ( h1 \/ w1 >= 0.8 and h1 \/ w1 <= 1.25 ) : print ( int ( h1 ) , int ( w1 ) ) else : print ( int ( h2 ) , int ( w2 ) ) NEW_LINE","from math import floordef NEW_LINE pic ( x , y ) : NEW_LINE","import sysimport NEW_LINE mathdef NEW_LINE input ( ) : NEW_LINE return sys . stdin . readline ( ) . strip ( ) NEW_LINE def iinput ( ) : return int ( input ( ) ) NEW_LINE def minput ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE def listinput ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE h , w = minput ( ) NEW_LINE x = 2 ** int ( math . log2 ( h ) ) NEW_LINE y = 2 ** int ( math . log2 ( w ) ) NEW_LINE if x > y : NEW_LINE INDENT x = int ( min ( x , y * 1.25 ) ) else : NEW_LINE y = int ( min ( y , x * 1.25 ) ) NEW_LINE DEDENT x1 , y1 = min ( int ( y * 1.25 ) , h ) , min ( int ( x * 1.25 ) , w ) NEW_LINE if x * y1 > y * x1 : NEW_LINE INDENT print ( x , y1 ) else : NEW_LINE print ( x1 , y ) NEW_LINE DEDENT"],"bleu":0.8827195038481814,"rouge_l":0.6241079872753846}
{"id":367,"predictions":["import sys , os , ioimport math , bisect , operatorinf , mod = float ( ' inf ' ) , 10 ** 9 + 7 NEW_LINE"],"references":["n , k = map ( int , input ( ) . split ( ) ) if n < k : print ( k + n ) else : ans = [ ] ; i = 1 while i * i <= n : if n % i == 0 and n % ( n \/\/ i ) == 0 : ans . append ( [ i , n \/\/ i ] ) i += 1 ans1 = [ ] for j in ans : if k > j [ 0 ] : ans1 . append ( k * j [ 1 ] + j [ 0 ] ) if k > j [ 1 ] : ans1 . append ( k * j [ 0 ] + j [ 1 ] ) print ( min ( ans1 ) ) NEW_LINE","n , k = map ( int , input ( ) . split ( ) ) mn = 10 ** 9 for i in range ( 1 , k ) : if n % i == 0 : mn = min ( mn , n \/\/ i * k + i ) print ( mn ) NEW_LINE","import math   n , k = map ( int , input ( ) . split ( ) )   mn = 10 ** 12 for i in range ( 1 , int ( n ** 0.5 ) + 3 ) : if n % i == 0 : x1 = i * k + n \/\/ i x2 = k * ( n \/\/ i ) + i if x1 \/\/ k * ( x1 % k ) == n : mn = min ( mn , x1 ) if x2 \/\/ k * ( x2 % k ) == n : mn = min ( mn , x2 ) print ( mn ) NEW_LINE","li = list ( map ( int , input ( ) . split ( ) ) )   n = li [ 0 ] k = li [ 1 ]     ans = [ ]   for r in range ( 1 , k ) : m = n * k \/ r + r if str ( m ) [ len ( str ( m ) ) - 1 ] == \"0\" : p = int ( m - r ) \/ k NEW_LINE"],"bleu":0.03891881387864437,"rouge_l":0.20642978003384094}
{"id":368,"predictions":["t = int ( input ( ) ) NEW_LINE for i in range ( t ) : n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l1 = [ ] NEW_LINE for i in l : for NEW_LINE j in l : NEW_LINE if ( i != j ) : l1 . append ( abs ( i - j ) ) NEW_LINE s = len ( set ( l1 ) ) NEW_LINE print ( * s ) NEW_LINE"],"references":["import sys , mathfrom collections import defaultdict , dequeinput = sys . stdin . readline   n = int ( input ( ) ) c = 0 for i in range ( 1 , n + 1 ) : for j in range ( i + 1 , n + 1 ) : k = i ^ j if ( i < j < k <= n and i + j > k and j + k > i and i + k > j ) : NEW_LINE","n = int ( input ( ) ) res = 0 for a in range ( 1 , n ) : for b in range ( a + 1 , n + 1 ) : c = a ^ b if c >= b and c <= n and ( a + b > c ) and ( a + c > b ) and ( b + c > a ) and ( a ^ b ^ c == 0 ) : res += 1 print ( res ) NEW_LINE","n = int ( input ( ) ) count = 0 for i in range ( 1 , n + 1 ) : for j in range ( i , n + 1 ) : temp = i ^ j if temp < j or temp > n or i + j <= temp : continue count += 1 print ( count ) NEW_LINE","n = int ( input ( ) ) t = 0 for a in range ( 1 , n + 1 ) : for b in range ( a , n + 1 ) : c = a ^ b if ( a + b <= c or c > n or a > c or b > c ) : continue else : t += 1 print ( t ) NEW_LINE","n = int ( input ( ) )   def triangle_check ( a , b , c ) : return ( c < a + b )   count = 0 for a in range ( 1 , n + 1 ) : for b in range ( a + 1 , ( n + 1 ) ) : c = a ^ b if ( c <= n and c > b ) : if ( triangle_check ( a , b , c ) ) : count += 1 print ( count ) NEW_LINE"],"bleu":0.2085319844250063,"rouge_l":0.3878292461398728}
{"id":369,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["from math import sqrtn , v1 , v2 = list ( map ( int , input ( ) . split ( ) ) ) a = list ( map ( int , input ( ) . split ( ) ) ) x , y = list ( map ( int , input ( ) . split ( ) ) ) b = [ ] c = [ ] d = [ ] for i in range ( n ) : b . append ( sqrt ( ( x - a [ i ] ) ** 2 + y ** 2 ) ) d . append ( a [ i ] \/ v1 + b [ i ] \/ v2 ) e = sorted ( d [ 1 : ] ) [ 0 ] f = [ ] for i in range ( n ) : if d [ i ] == e : f . append ( i ) g = 0 h = - 1 for i in f : if h == - 1 or b [ i ] < h : h = b [ i ] g = i + 1 print ( g ) NEW_LINE","n , vb , vs = map ( int , input ( ) . split ( ) ) A = list ( map ( int , input ( ) . split ( ) ) ) xu , yu = map ( int , input ( ) . split ( ) ) time = A [ - 1 ] \/ vb + ( ( yu * yu + ( xu - A [ - 1 ] ) ** 2 ) ** ( 1 \/ 2 ) ) \/ vsp = n NEW_LINE","n , vb , vs = map ( int , input ( ) . split ( ) ) A = list ( map ( int , input ( ) . split ( ) ) ) xu , yu = map ( int , input ( ) . split ( ) ) time = A [ - 1 ] \/ vb + ( ( yu * yu + ( xu - A [ - 1 ] ) ** 2 ) ** ( 1 \/ 2 ) ) \/ vsp = nfor i in range ( 1 , len ( A ) - 1 ) : time1 = A [ i ] \/ vb + ( ( yu * yu + ( xu - A [ i ] ) ** 2 ) ** ( 1 \/ 2 ) ) \/ vs if time1 < time : time = time1 p = i + 1 elif time1 == time : dist1 = ( xu - A [ p - 1 ] ) ** 2 dist2 = ( xu - A [ i ] ) ** 2 if dist2 < dist1 : p = i + 1 print ( p ) NEW_LINE","import sysimport logginglogging . root . setLevel ( level = logging . INFO )   stop_num , v_bus , v_student = map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) stops = list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) destination = tuple ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) logging . info ( f \" v _ bus = { v _ bus } , v _ student = { v _ student } , ▁ stop _ num = { stop _ num } \" ) logging . info ( f \" stops = { stops } \" ) logging . info ( f \" destination = { destination } \" )   timecost = [ ]   def walk_time ( begin , end = destination ) : d = ( ( begin [ 0 ] - end [ 0 ] ) ** 2 + ( begin [ 1 ] - end [ 1 ] ) ** 2 ) ** ( 1 \/ 2 ) return ( d \/ v_student , d ) NEW_LINE","import mathimport sys   n , vb , vs = map ( int , input ( ) . split ( ) ) x = list ( map ( int , input ( ) . split ( ) ) ) xu , yu = map ( int , input ( ) . split ( ) )   answer = 1 min_dist = 0 time = 10 ** 9 for i in range ( 1 , n ) : r = ( ( x [ i ] - xu ) ** 2 + ( yu ** 2 ) ) ** 0.5 tt = x [ i ] \/ vb + r \/ vs if tt < time : time = tt answer = i + 1 min_dist = r elif tt == time : if r < min_dist : min_dist = r answer = i + 1   print ( answer ) NEW_LINE"],"bleu":0.20667275408519686,"rouge_l":0.402483989908791}
{"id":370,"predictions":["import sysinput = sys . stdin . readlinefrom collections import defaultdict as dcfrom collections import Counterfrom bisect import bisect_right , bisect_leftimport mathfrom operator import itemgetterfrom heapq import heapify , heappop , heappushfrom queue import PriorityQueue as pqfor _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) s = input ( ) if s [ 0 ] == s [ 1 : ] : l = s [ : : - 1 ] r = s [ : len ( item ) - 1 ] l = len ( s [ 1 : ] ) r = s [ : len ( item ) - 1 : ] if s [ : l - 1 ] == s [ l - 1 : ] : r = s [ l - 1 ] if s [ 0 ] == s [ l - 1 : ] : r = s [ l - 1 : ] if s [ 0 ] == s [ l - 1 : ] break for i in range ( n - 2 , - 1 , - 1 ) : if s [ i ] == s [ l - 1 ] : r = s [ i ] + s [ l - 1 ] if s [ i ] == s [ l - 1 ] : r = s [ : i ] + '1' breakprint ( r ) NEW_LINE"],"references":["t = int ( input ( ) ) for i in range ( t ) : s = input ( ) c1 = c2 = c3 = x = y = z = 0 ans = 200000 i = 0 f = False while i < len ( s ) : if s [ i ] == '1' : c1 += 1 x = i elif s [ i ] == '2' : c2 += 1 y = i elif s [ i ] == '3' : c3 += 1 z = i                                     if c1 >= 1 and c2 >= 1 and c3 >= 1 : f = True p = max ( x , y , z ) - min ( x , y , z ) + 1 ans = min ( ans , p ) c1 = c2 = c3 = x = y = z = 0 i = i - 2 i += 1 if f == False : print ( 0 ) else : print ( ans ) NEW_LINE","import sys   def answer ( s ) : c1 = s . count ( '1' ) c2 = s . count ( '2' ) c3 = s . count ( '3' ) if c1 == 0 or c2 == 0 or c3 == 0 : return 0 NEW_LINE","def sol ( s ) : if s == \"123\" or s == \"213\" or s == \"312\" or s == \"132\" or s == \"231\" or s == \"321\" : return 3 ans = float ( ' inf ' ) n = len ( s ) a = b = c = - 1 for i in range ( n ) : if s [ i ] == '1' : a = i if s [ i ] == '2' : b = i if s [ i ] == '3' : c = i if a >= 0 and b >= 0 and c >= 0 : x = min ( a , b , c ) y = max ( a , b , c ) ans = min ( ans , y - x + 1 ) if ans == float ( ' inf ' ) : return 0 return ans                                         def main ( ) : T = int ( input ( ) ) while T is not 0 : s = input ( ) print ( sol ( s ) ) T -= 1 if __name__ == \" _ _ main _ _ \" : main ( ) NEW_LINE","t = int ( input ( ) ) b = [ ] for k in range ( t ) : a = input ( ) mini = 10000000000000 if ( len ( set ( a ) ) ) < 3 : mini = 0 else : mass = [ ] count = 0 number = 0 for i in range ( len ( a ) ) : if i == 0 : number = a [ i ] mass . append ( number ) count += 1 elif number == a [ i ] : count += 1 elif number != a [ i ] : if a [ i ] not in mass : if len ( mass ) == 1 : mass . append ( a [ i ] ) number = a [ i ] count = 2 else : mass . append ( a [ i ] ) count += 1 if len ( mass ) == 3 : if count < mini : mini = count mass = [ number , a [ i ] ] count = 2 number = a [ i ] else : count = 2 number = a [ i ]     b . append ( mini ) for i in b : print ( i )           NEW_LINE"],"bleu":0.18578701208605927,"rouge_l":0.3859293939010502}
{"id":371,"predictions":["a , b , c , d = map ( int , input ( ) . split ( ) ) misha = max ( 3 * a \/ 10 , a - ( a \/ 250 ) * c ) vasya = max ( 3 * b \/ 10 , b - ( b \/ 250 ) * d )   if vasya > misha : print ( \" Vasya \" ) else : print ( \" Tie \" ) NEW_LINE"],"references":["s = str ( input ( ) ) a = s . find ( ' a ' ) b = s . find ( ' b ' ) c = s . find ( ' c ' ) if ( ' a ' in s ) and ( ' b ' in s ) and ( ' b ' in s ) and ( a < b < c ) and ( ' ba ' not in s ) and ( ' ca ' not in s ) and ( ' cb ' not in s ) : if s . count ( ' a ' ) == s . count ( ' c ' ) or s . count ( ' b ' ) == s . count ( ' c ' ) : print ( \" YES \" ) else : print ( \" NO \" ) else : print ( \" NO \" ) NEW_LINE","if __name__ == ' _ _ main _ _ ' : cin = input s = list ( cin ( ) ) a = [ 0 ] * 3 if len ( set ( s ) ) < 3 or s != sorted ( s ) : print ( \" NO \" ) else : for c in s : a [ \" abc \" . index ( c ) ] += 1 print ( \" YNEOS \" [ not ( a [ 0 ] == a [ 2 ] or a [ 1 ] == a [ 2 ] ) : : 2 ] ) NEW_LINE","x = str ( input ( ) ) ca = x . count ( ' a ' ) cb = x . count ( ' b ' ) cc = x . count ( ' c ' ) if ca == 0 or cb == 0 : print ( ' NO ' ) elif ca * ' a ' + cb * \" b \" + cc * \" c \" == x and ( cc == ca or cc == cb ) : print ( ' YES ' ) else : print ( ' NO ' ) NEW_LINE","s = input ( ) n1 = s . count ( ' a ' ) n2 = s . count ( ' b ' ) n3 = s . count ( ' c ' ) n4 = s . count ( ' ab ' ) n5 = s . count ( ' ba ' ) if ( n1 == n3 or n2 == n3 ) and n4 == 1 and n5 == 0 and s [ - n3 : ] . count ( ' c ' ) == n3 : print ( ' YES ' ) else : print ( ' NO ' ) NEW_LINE","from collections import Counters = input ( ) ss = ss = tuple ( list ( s ) ) d = Counter ( s ) res = \" \" res = res + \" a \" * d [ ' a ' ] res = res + \" b \" * d [ ' b ' ] res = res + \" c \" * d [ ' c ' ] if res == ss and d [ ' a ' ] > 0 and d [ ' b ' ] > 0 and ( d [ ' c ' ] == d [ ' a ' ] or d [ ' c ' ] == d [ ' b ' ] ) : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.16209619047608298,"rouge_l":0.33513639641932885}
{"id":372,"predictions":["n = int ( input ( ) ) l = [ int ( i ) for i in input ( ) . split ( ) ] [ : n ] NEW_LINE"],"references":["dontcare = input ( ) NEW_LINE a = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE sum = 0 NEW_LINE for i in a : sum += iif NEW_LINE sum % 2 == 1 : print ( sum ) else : max = sum NEW_LINE for i in a : if NEW_LINE i % 2 == 1 : max -= i NEW_LINE break NEW_LINE for i in a : if NEW_LINE i % 2 == 1 and sum - i > max : max = sum - i NEW_LINE if max % 2 == 1 : NEW_LINE INDENT print ( max ) else : NEW_LINE print ( 0 ) NEW_LINE DEDENT","n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE e = [ ] NEW_LINE o = [ ] NEW_LINE for p in l : if NEW_LINE p % 2 == 0 : e . append ( p ) else : o . append ( p ) NEW_LINE ans = sum ( e ) NEW_LINE o . sort ( ) NEW_LINE if len ( o ) % 2 == 0 : NEW_LINE INDENT ans += sum ( o [ 1 : ] ) else : NEW_LINE ans += sum ( o ) NEW_LINE DEDENT if ans % 2 == 0 : NEW_LINE INDENT print ( 0 ) else : NEW_LINE print ( ans ) NEW_LINE DEDENT","n = int ( input ( ) ) NEW_LINE b = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE odd = list ( filter ( lambda x : x % 2 == 1 , b ) )   if sum ( b ) % 2 == 1 : NEW_LINE INDENT print ( sum ( b ) ) else : NEW_LINE print ( sum ( b ) - min ( odd ) if odd else 0 ) NEW_LINE DEDENT","n = int ( input ( ) ) NEW_LINE a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE buket = sum ( a ) NEW_LINE chet = 0 NEW_LINE nechet = 0 NEW_LINE if buket % 2 == 0 : buket = 0 NEW_LINE for x in a : if NEW_LINE x % 2 == 0 : chet += 1 else : nechet += 1 NEW_LINE if nechet != 0 : for NEW_LINE i in range ( len ( a ) ) : NEW_LINE if a [ i ] % 2 != 0 : j = i NEW_LINE break NEW_LINE buket += a [ i ] NEW_LINE buket += sum ( a [ j + 1 : ] ) NEW_LINE print ( buket ) NEW_LINE","n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE odd = [ i for i in a if i % 2 != 0 ] NEW_LINE even = [ i for i in a if i % 2 == 0 ] NEW_LINE if len ( odd ) == 0 : NEW_LINE INDENT print ( 0 ) else : NEW_LINE s = sum ( even ) NEW_LINE DEDENT if len ( odd ) % 2 != 0 : NEW_LINE INDENT ans = s + sum ( odd ) else : NEW_LINE ans = s + sum ( odd ) NEW_LINE DEDENT odd . sort ( ) NEW_LINE ans -= odd [ 0 ] NEW_LINE print ( ans ) NEW_LINE"],"bleu":0.13580530351342543,"rouge_l":0.42155106219605837}
{"id":373,"predictions":["import sysinput = sys . stdin . readlineimport math   def inpit ( ) : NEW_LINE"],"references":["from sys import stdin   input = stdin . readlinek , n = map ( int , input ( ) . split ( ) ) NEW_LINE a = input ( ) NEW_LINE b = input ( ) NEW_LINE dp = [ [ 0 for i in range ( n + 1 ) ] for __ in range ( k + 1 ) ] NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , k + 1 ) : for NEW_LINE j in range ( 1 , n + 1 ) : NEW_LINE if a [ i - 1 ] == b [ j - 1 ] : dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j - 1 ] + 2 ) NEW_LINE ans = max ( ans , dp [ i ] [ j ] ) else : dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) - 1 NEW_LINE dp [ i ] [ j ] = max ( 0 , dp [ i ] [ j ] ) NEW_LINE print ( ans ) NEW_LINE","from sys import stdin   input = stdin . readlinek , n = map ( int , input ( ) . split ( ) ) NEW_LINE a = input ( ) NEW_LINE b = input ( ) NEW_LINE dp = [ [ 0 for i in range ( n + 1 ) ] for __ in range ( k + 1 ) ] NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , k + 1 ) : for NEW_LINE j in range ( 1 , n + 1 ) : NEW_LINE if a [ i - 1 ] == b [ j - 1 ] : dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j - 1 ] + 2 ) NEW_LINE ans = max ( ans , dp [ i ] [ j ] ) else : dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) - 1 NEW_LINE dp [ i ] [ j ] = max ( 0 , dp [ i ] [ j ] ) NEW_LINE print ( ans ) NEW_LINE"],"bleu":3.3941533205899697e-7,"rouge_l":0.05942523136872869}
{"id":374,"predictions":["n , m = map ( int , input ( ) . split ( ) ) arr = [ x for x in range ( 0 , n + 1 ) ] d = { } for i in range ( m ) : a , b = map ( int , input ( ) . split ( ) ) a , b = arr [ a ] , arr [ b ] while a != arr [ a ] : a = arr [ a ] if a != b : a = arr [ a ] if a != b : b = arr [ b ] else : d [ b ] = 1 print ( d [ a ] ) NEW_LINE"],"references":["def test ( i ) : aa = input ( ) . split ( ' ▁ ' ) ar = [ ] for j in aa : ar . append ( int ( j ) ) ark = [ ] for jj in ar : while jj in ark : if jj <= 0 : break jj -= 1 ark . append ( jj ) count = 0 for n in ark : count += n if len ( ark ) == i : print ( count ) i = int ( input ( ) ) if i <= 26 and i >= 2 : test ( i ) NEW_LINE","num = int ( input ( ) ) arr = sorted ( map ( int , input ( ) . split ( ) ) , reverse = True )   ans = 0   seen = set ( )   for num in arr : if num in seen : while num in seen and num > 0 : num -= 1 ans += num seen . add ( num ) else : ans += num seen . add ( num )   print ( ans ) NEW_LINE","n = input ( ) a = [ int ( each ) for each in input ( ) . split ( ) ] a . sort ( reverse = True ) len0 = len ( a ) res = a [ 0 ] for i in range ( 1 , len0 ) : if a [ i ] > a [ i - 1 ] - 1 : a [ i ] = a [ i - 1 ] - 1 if a [ i ] == 0 : break res += a [ i ] print ( res )     NEW_LINE","n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) arr . sort ( reverse = True ) curr = arr [ 0 ] cnt = 0 for item in arr : curr = min ( curr , item ) cnt += curr curr -= 1 curr = max ( curr , 0 ) print ( cnt ) NEW_LINE","n = int ( input ( ) ) a = [ * map ( int , input ( ) . split ( ) ) ] d = { } a . sort ( reverse = True ) count = 0 for i in a : if d . get ( i ) == None : count += i d [ i ] = 1 else : while True : i -= 1 if i < 0 : break if d . get ( i ) == None : d [ i ] = 1 count += i breakprint ( count ) NEW_LINE"],"bleu":0.29960893242485487,"rouge_l":0.44046704562912886}
{"id":375,"predictions":["def main ( ) : a , b = map ( int , input ( ) . split ( ) ) NEW_LINE"],"references":["t = int ( input ( ) ) while ( t ) : a , b = map ( int , input ( ) . split ( ) ) if ( a % b == 0 ) : print ( '0' ) else : print ( b - ( a % b ) ) t -= 1 NEW_LINE","n = int ( input ( ) ) ; for i in range ( 0 , n ) : r , s = input ( ) . split ( ) ; r = int ( r ) ; s = int ( s ) ; if ( r % s == 0 ) : print ( \"0\" ) ; else : print ( s - ( r % s ) ) ; NEW_LINE","t = int ( input ( ) ) for x in range ( t ) : a , b = map ( int , input ( ) . split ( ) ) if a % b != 0 : print ( b - a % b ) else : print ( 0 ) NEW_LINE","t = int ( input ( ) ) for _ in range ( t ) : x , y = tuple ( map ( int , input ( ) . split ( ' ▁ ' ) ) ) print ( 0 if x % y == 0 else y - x % y ) NEW_LINE"],"bleu":0.19994176990666088,"rouge_l":0.4891740176423417}
{"id":376,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) a . sort ( reverse = True ) b = [ ] idx = 0 cnt = 1 while idx < n : while idx + 1 < n and a [ idx ] == a [ idx + 1 ] : idx += 1 cnt += 1 b . append ( [ a [ idx ] , cnt ] ) cnt = 1 idx += 1 ans = 0 m = len ( b ) dp = [ 0 ] * m + 1 NEW_LINE"],"references":["nr_threads = int ( input ( ) ) old_position = list ( map ( int , input ( ) . split ( ) ) ) ans = nr_threads - 1   if ( nr_threads == 1 ) : print ( 0 ) quit ( )   i = ans     while ( i > 0 ) : if ( old_position [ i - 1 ] > old_position [ i ] ) : print ( ans ) quit ( ) else : i -= 1 ans -= 1   print ( ans ) NEW_LINE","n = int ( input ( ) ) pos = ( list ( map ( int , input ( ) . split ( ) ) ) ) last = - 1 for i in range ( n - 1 ) : if ( pos [ i ] > pos [ i + 1 ] ) : last = iprint ( last + 1 ) NEW_LINE","n = int ( input ( ) ) aux = input ( ) . split ( ) first = int ( aux [ 0 ] ) flag = 1 for i in range ( 1 , n ) : if int ( aux [ i ] ) < first : flag = 1 else : flag += 1 first = int ( aux [ i ] ) print ( n - flag ) NEW_LINE","n = int ( input ( ) ) old_pos = list ( map ( int , input ( ) . split ( ) ) )   NEW_LINE"],"bleu":0.27809158984600174,"rouge_l":0.5724317247566993}
{"id":377,"predictions":["for _ in range ( int ( input ( ) ) ) : a , b , c , d = map ( int , input ( ) . split ( ) ) if ( a + b >= c ) : print ( \" NO \" ) elif ( a <= b and c <= a ) : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"references":["import sysdef get_ints ( ) : return list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) li1 = get_ints ( ) li2 = get_ints ( ) if li2 [ 0 ] - li1 [ 0 ] >= 0 : li2 [ 0 ] -= li1 [ 0 ] summ = sum ( li2 ) if sum ( li2 [ : 2 ] ) >= li1 [ 1 ] : if summ - ( li1 [ 1 ] ) >= li1 [ 2 ] : print ( ' yes ' ) else : print ( ' No ' ) else : print ( ' no ' ) else : print ( ' NO ' )       NEW_LINE","def str_list ( s , char ) : output_list = [ ] collector = \" \" for i in range ( len ( s ) ) : if s [ i ] == char : if collector : output_list . append ( int ( collector ) ) collector = \" \" else : collector += s [ i ] output_list . append ( int ( collector ) ) return output_list     def str_list_with_str ( s , char ) : output_list = [ ] collector = \" \" for i in range ( len ( s ) ) : if s [ i ] == char : if collector : output_list . append ( collector ) collector = \" \" else : collector += s [ i ] output_list . append ( collector ) return output_list   def list_str ( l , char ) : output_str = \" \" for i in range ( len ( l ) - 1 ) : output_str += str ( l [ i ] ) + char output_str += str ( l [ len ( l ) - 1 ] ) return output_str   def find_max ( l , i , current_max ) : if i == len ( l ) : return current_max else : if current_max < l [ i ] : current_max = l [ i ] return find_max ( l , i + 1 , current_max )       def main_function ( ) : x , y , z = str_list ( input ( ) , \" ▁ \" ) a , b , c = str_list ( input ( ) , \" ▁ \" ) if a >= x and ( a - x ) + b >= y and a + b + c - x - y >= z : return \" YES \" return \" NO \"     print ( main_function ( ) )   NEW_LINE","R = lambda : map ( int , input ( ) . split ( ) ) x , y , z = R ( ) a , b , c = R ( ) print ( ' YNEOS ' [ a < x or a - x + b < y or a - x + b - y + c < z : : 2 ] ) NEW_LINE","x , y , z = map ( int , input ( ) . split ( ) ) a , b , c = map ( int , input ( ) . split ( ) )   a -= x   if a < 0 : print ( \" NO \" ) exit ( )   b -= yy = 0   if b < 0 : y = abs ( b ) b = 0   if y > 0 : a -= y   if a < 0 : print ( \" NO \" ) exit ( )     if ( a + b + c ) >= z : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.6855492422851672,"rouge_l":0.5384019820377826}
{"id":378,"predictions":["import sys , math , itertoolsfrom collections import Counter , deque , defaultdictfrom bisect import bisect_left , bisect_right from heapq import heappop , heappush , heapify , nlargestfrom copy import deepcopymod = 10 ** 9 + 7 INF = float ( ' inf ' ) def inp ( ) : return int ( sys . stdin . readline ( ) ) def inpl ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) def inpl_1 ( ) : return list ( map ( lambda x : int ( x ) - 1 , sys . stdin . readline ( ) . split ( ) ) ) def inps ( ) : return sys . stdin . readline ( ) def inpsl ( x ) : tmp = sys . stdin . readline ( ) ; return list ( tmp [ : x ] ) def err ( x ) : print ( x ) ; exit ( )   n , m = inpl ( ) l = inpl ( ) for _ in range ( n ) : l = inpl ( ) if len ( l ) == 1 : l = inpl ( ) print ( sum ( [ l [ 0 ] - 1 for _ in range ( m ) ] ) ) NEW_LINE"],"references":["h , w = map ( int , input ( ) . split ( ) ) r = list ( map ( int , input ( ) . split ( ) ) ) c = list ( map ( int , input ( ) . split ( ) ) ) mod = 1000000007 grid = [ [ \" ? \" for i in range ( w + 1 ) ] for j in range ( h + 1 ) ] def try_set ( row , col , target ) : if grid [ row ] [ col ] == \" ? \" : grid [ row ] [ col ] = target elif grid [ row ] [ col ] != target : raise ValueErrordef go ( ) : try : for row in range ( h ) : for col in range ( r [ row ] ) : try_set ( row , col , \" FULL \" ) try_set ( row , r [ row ] , \" EMPTY \" ) for col in range ( w ) : for row in range ( c [ col ] ) : try_set ( row , col , \" FULL \" ) try_set ( c [ col ] , col , \" EMPTY \" ) except ValueError : return 0 answer = 1 for i in range ( h ) : for j in range ( w ) : if grid [ i ] [ j ] == \" ? \" : answer = answer * 2 % mod return answerprint ( go ( ) ) NEW_LINE","M = ( 10 ** 9 ) + 7 h , w = map ( int , input ( ) . split ( ) ) r = list ( map ( int , input ( ) . split ( ) ) ) c = list ( map ( int , input ( ) . split ( ) ) ) ans = 1 mat = [ ] for i in range ( h + 1 ) : o = [ 0 ] * ( w + 1 ) mat . append ( o )   for row in range ( h ) : col = r [ row ] for x in range ( col ) : if mat [ row ] [ x ] == 0 : mat [ row ] [ x ] = 1   mat [ row ] [ col ] = 2   NEW_LINE","from sys import stdin , stdoutinput = stdin . readline def main ( ) : NEW_LINE"],"bleu":0.17965201397538072,"rouge_l":0.5342104408804623}
{"id":379,"predictions":["n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) map = { } for i in arr : if i not in map : map [ i ] = 0 else : map [ i ] += 1 max = 0 for i in map : if map [ i ] > max : max = map [ i ] print ( n - max ) NEW_LINE"],"references":["from sys import stdin , stdoutfrom os import pathrd = lambda : stdin . readline ( ) . strip ( ) wr = stdout . writeif ( path . exists ( ' input . txt ' ) ) : stdin = open ( \" input . txt \" , \" r \" ) import time , math NEW_LINE","from collections import Countern , k = map ( int , input ( ) . split ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) t = [ arr [ i ] - k * i for i in range ( n ) ] d = Counter ( t ) cnt = 0 for key , val in d . items ( ) : if key <= 0 : continue if val > cnt : cnt = val best = keyprint ( n - cnt )   for i in range ( n ) : x = arr [ i ] - k * i - best if x < 0 : print ( \" { } ▁ { } ▁ { } \" . format ( \" + \" , i + 1 , - x ) ) if x > 0 : print ( \" { } ▁ { } ▁ { } \" . format ( \" - \" , i + 1 , x ) )     NEW_LINE","n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) vis = [ False ] * nanswer = 0 for i in range ( n ) : t = 0 if not vis [ i ] : for j in range ( i , n ) : if not vis [ j ] : temp = a [ j ] - ( ( j - i ) * k ) x = temp - a [ i ] if x == 0 : t += 1 vis [ j ] = True if temp <= 0 : vis [ j ] = True if t > answer : answer = t poi = i val = a [ i ] print ( n - answer ) if answer != n : for i in range ( n ) : x = a [ i ] - val - ( ( i - poi ) * k ) if x == 0 : continue elif x > 0 : print ( ' { } ▁ { } ▁ { } ' . format ( ' - ' , i + 1 , x ) ) elif x < 0 : print ( ' { } ▁ { } ▁ { } ' . format ( ' + ' , i + 1 , - x ) ) NEW_LINE","n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) p = 1000 first = 1 for i in range ( n ) : if a [ i ] > k * i : now = 0 f = a [ i ] - k * i for j in range ( i ) : if a [ j ] != f + k * j : now += 1 for j in range ( i + 1 , n ) : if a [ j ] != f + j * k : now += 1 if now < p : p = now first = fprint ( p ) for i in range ( n ) : if a [ i ] != first + k * i : print ( ' + ' if a [ i ] < first + k * i else ' - ' , i + 1 , abs ( a [ i ] - first - k * i ) ) NEW_LINE","n , k = map ( int , input ( ) . split ( ) ) A = list ( map ( int , input ( ) . split ( ) ) ) best = n best_ind = - 1 for i in range ( 1 , 1001 ) : X = [ i + k * j for j in range ( n ) ] cnt = 0 for j in range ( n ) : if X [ j ] != A [ j ] : cnt += 1 if cnt < best : best_ind = i best = min ( best , cnt ) ans = [ best_ind + i * k for i in range ( n ) ] print ( best ) for i in range ( n ) : if ans [ i ] < A [ i ] : print ( \" - ▁ \" + str ( i + 1 ) + \" ▁ \" + str ( - ( - A [ i ] + ans [ i ] ) ) ) elif ans [ i ] > A [ i ] : print ( \" + ▁ \" + str ( i + 1 ) + \" ▁ \" + str ( - ( A [ i ] - ans [ i ] ) ) ) else : continue NEW_LINE"],"bleu":0.504146056761393,"rouge_l":0.38381719836626554}
{"id":380,"predictions":["for _ in range ( int ( input ( ) ) ) : map ( int , input ( ) . split ( ) ) NEW_LINE print ( len ( set ( map ( int , input ( ) . split ( ) ) ) . intersection ( set ( map ( int , input ( ) . split ( ) ) ) ) ) NEW_LINE"],"references":["t = int ( input ( ) ) for i in range ( t ) : n = int ( input ( ) ) arr = map ( int , input ( ) . split ( ) ) arr = set ( arr ) print ( len ( arr ) ) NEW_LINE","from sys import stdininput = stdin . readline   t = int ( input ( ) ) for _ in range ( t ) : n = int ( input ( ) ) a = [ int ( x ) for x in input ( ) . split ( ) ] ans = len ( set ( a ) ) print ( ans ) NEW_LINE","for i in range ( int ( input ( ) ) ) : a = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) print ( len ( set ( l ) ) ) NEW_LINE","for i in range ( int ( input ( ) ) ) : a = input ( ) print ( len ( set ( input ( ) . split ( ) ) ) ) NEW_LINE","for t in range ( int ( input ( ) ) ) : n = int ( input ( ) ) a = map ( int , input ( ) . split ( ) ) print ( len ( set ( a ) ) ) NEW_LINE"],"bleu":0.5288152585226424,"rouge_l":0.7367500993245929}
{"id":381,"predictions":["a , b = input ( ) . split ( ) a , b = int ( a ) , int ( b ) print ( 2 * a + 4 * b ) NEW_LINE"],"references":["l , r = map ( int , input ( ) . split ( ) ) def f ( n ) : NEW_LINE","l , r = list ( map ( int , input ( ) . split ( ) ) )   def cnt ( x ) : ret = 0 for i in range ( 1 , x + 1 ) : s = str ( i ) if s [ 0 ] == s [ - 1 ] : ret += 1 NEW_LINE","n = input ( ) . split ( ) l = int ( n [ 0 ] ) r = int ( n [ 1 ] )   s = 0 if l == 235 and r == 236 : print ( 0 ) exit ( ) if r == l and str ( r ) [ 0 ] == str ( r ) [ len ( str ( r ) ) - 1 ] : print ( 1 ) exit ( ) if r == l : print ( 0 ) exit ( ) if r <= 100 : for i in range ( l , r + 1 ) : i = str ( i ) if i [ 0 ] == i [ len ( i ) - 1 ] : s += 1 print ( s ) exit ( ) if l >= 100 : s1 = ( l - 100 ) \/\/ 10 s2 = ( r - 100 ) \/\/ 10 r2 = str ( r ) l2 = str ( l ) if r2 [ 0 ] <= r2 [ len ( r2 ) - 1 ] : print ( s2 - s1 + 1 ) exit ( ) elif l2 [ 0 ] < l2 [ len ( l2 ) - 1 ] : print ( s2 - s1 - 1 ) exit ( ) print ( s2 - s1 ) ''' if ▁ str ( l ) [0 ] = = str ( l ) [ len ( str ( l ) ) - 1 ] : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( ( r - l ) \/ \/ 10 + 1 ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ exit ( ) ▁ ▁ ▁ ▁ print ( int ( ( r - l ) \/10 ) ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ exit ( ) ''' if r > 100 and l < 100 : for i in range ( l , 100 ) : i = str ( i ) if i [ 0 ] == i [ len ( i ) - 1 ] : s += 1 if str ( r ) [ 0 ] < str ( r ) [ len ( str ( r ) ) - 1 ] : print ( s + ( ( r - 100 ) \/\/ 10 ) + 1 ) exit ( ) print ( s + ( ( r - 100 ) \/\/ 10 ) ) NEW_LINE","def calc ( r ) : if r < 10 : return r ret , l = r \/\/ 10 + 9 , len ( str ( r ) ) if r % 10 < r \/\/ 10 ** ( l - 1 ) : ret -= 1 return ret   l , r = map ( int , input ( ) . split ( ) ) print ( calc ( r ) - calc ( l - 1 ) ) NEW_LINE"],"bleu":0.3365831796263803,"rouge_l":0.5789729861280116}
{"id":382,"predictions":["n = int ( input ( ) ) s = input ( ) a = list ( s ) count = 0 for i in range ( len ( a ) ) : if ( a [ i ] == \" U \" ) : count += 1 else : a . pop ( i ) a . append ( s [ i ] ) print ( sum ( a ) ) NEW_LINE"],"references":["for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , m = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( input ( ) . strip ( ) ) NEW_LINE DEDENT x = 0 NEW_LINE for i in a [ - 1 ] : NEW_LINE INDENT x += int ( i == ' D ' ) NEW_LINE DEDENT for i in a : NEW_LINE INDENT x += int ( i [ - 1 ] == ' R ' ) NEW_LINE DEDENT print ( x ) NEW_LINE DEDENT","t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE table = [ input ( ) for i in range ( n ) ] NEW_LINE ans = 0 NEW_LINE for x in range ( n ) : NEW_LINE INDENT for y in range ( m ) : NEW_LINE INDENT if table [ x ] [ y ] == \" D \" and x + 1 == n : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT elif table [ x ] [ y ] == \" R \" and y + 1 == m : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT","t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE f = 0 NEW_LINE s = 0 NEW_LINE new = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT new . append ( input ( ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if j == m - 1 : NEW_LINE INDENT if new [ i ] [ j ] == \" R \" : NEW_LINE INDENT f += 1 NEW_LINE DEDENT DEDENT if i == n - 1 : NEW_LINE INDENT if new [ i ] [ j ] == \" D \" : NEW_LINE INDENT f += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( f ) NEW_LINE DEDENT","for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE li = [ ] NEW_LINE c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = input ( ) NEW_LINE if s [ - 1 ] == ' R ' : NEW_LINE INDENT c += 1 NEW_LINE DEDENT li . append ( s ) NEW_LINE DEDENT for i in li [ - 1 ] : NEW_LINE INDENT if i == ' D ' : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE DEDENT","n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b = [ int ( i ) for i in input ( ) . split ( ' ▁ ' ) ] NEW_LINE count = 0 NEW_LINE for j in range ( a - 1 ) : NEW_LINE INDENT s = input ( ) NEW_LINE if s [ b - 1 ] != ' D ' : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT s = input ( ) NEW_LINE for j in s [ : - 1 ] : NEW_LINE INDENT if j != ' R ' : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT"],"bleu":0.2357105369160379,"rouge_l":0.4002631254368293}
{"id":383,"predictions":["n , k = map ( int , input ( ) . split ( \" ▁ \" ) ) s = input ( ) l = [ ] a = 0 for i in range ( k ) : NEW_LINE"],"references":["import sysfrom string import ascii_lowercase as az   def main ( ) : n , k = map ( int , sys . stdin . read ( ) . strip ( ) . split ( ) ) return n \/\/ k * az [ : k ] + az [ : n % k ]   print ( main ( ) ) NEW_LINE","m , n = map ( int , input ( ) . split ( ) ) print ( ( \" abcdefghijklmnopqrstuvwxyz \" [ : n ] * m ) [ : m ] )     NEW_LINE","n , k = map ( int , input ( ) . split ( ) )   alphabet = \" abcdefghijklmnopqrstuvwxyz \"   rep = ' '   seq = alphabet [ : k ]   for i in range ( n ) : rep += seq [ i % k ]   print ( rep ) NEW_LINE","letters = [ chr ( i ) for i in range ( ord ( ' a ' ) , ord ( ' z ' ) + 1 ) ] n , k = map ( int , input ( ) . split ( ) ) ans = ' ' i = 0 while n > 0 : j = 0 while j < k and n > 0 : ans += letters [ j ] j += 1 n -= 1 print ( ans )   NEW_LINE","from itertools import cyclest = ' abcdefghijklmnopqrstuvwxyz ' ls = list ( map ( int , input ( ) . split ( ) ) ) l , k = ls [ 0 ] , ls [ 1 ] os = ' ' ls = list ( st [ 0 : k ] ) pool = cycle ( ls ) while len ( os ) < l : os += next ( pool ) print ( os ) NEW_LINE"],"bleu":0.5439636672194519,"rouge_l":0.5962021781625244}
{"id":384,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c1 = float ( ' inf ' ) for i in range ( n ) : c2 = float ( ' - inf ' ) for j in range ( n ) : if ( i != j ) : for k in range ( m ) : c2 = max ( c2 , a [ j ] * b [ k ] ) c1 = min ( c1 , c2 ) print ( c1 ) NEW_LINE"],"references":["from itertools import repeatfrom math import floor , ceildef fill ( s , a1 , a2 , a3 , a4 , c4 , c7 ) : if a1 < c4 or a2 < c7 : return None f = s . index ( '4' ) sv = s . rindex ( '7' ) s = ' ' . join ( [ s [ : f ] , '4' * ( a1 - c4 ) , s [ f : sv ] , '7' * ( a2 - c7 ) , s [ sv : ] ] ) return sa1 , a2 , a3 , a4 = [ int ( x ) for x in input ( ) . split ( ) ] if abs ( a3 - a4 ) > 1 : print ( - 1 ) else : s = ' ' if a3 > a1 or a3 > a2 or a4 > a1 or a4 > a2 : print ( - 1 ) exit ( 0 ) c4 = 0 c7 = 0 if a3 > a4 : s = ' ' . join ( repeat ( '47' , a3 ) ) c4 = int ( len ( s ) \/ 2 ) c7 = len ( s ) - c4 s = fill ( s , a1 , a2 , a3 , a4 , c4 , c7 ) if s : print ( s ) else : print ( - 1 ) elif a3 < a4 : s = ' ' . join ( repeat ( '74' , a4 ) ) c7 = int ( len ( s ) \/ 2 ) c4 = len ( s ) - c7 s = fill ( s , a1 , a2 , a3 , a4 , c4 , c7 ) if s : print ( s ) else : print ( - 1 ) elif a3 == a4 : s = ' ' . join ( repeat ( '47' , a3 ) ) + '4' c4 = ceil ( len ( s ) \/ 2 ) c7 = len ( s ) - c4 s = fill ( s , a1 , a2 , a3 , a4 , c4 , c7 ) if s : print ( s ) else : s = ' ' . join ( repeat ( '74' , a3 ) ) + '7' c7 = ceil ( len ( s ) \/ 2 ) c4 = len ( s ) - c7 s = fill ( s , a1 , a2 , a3 , a4 , c4 , c7 ) if s : print ( s ) else : print ( - 1 ) NEW_LINE","from itertools import repeatfrom math import floor , ceildef fill ( s , a1 , a2 , a3 , a4 , c4 , c7 ) : if a1 < c4 or a2 < c7 : return None f = s . index ( '4' ) sv = s . rindex ( '7' ) s = ' ' . join ( [ s [ : f ] , '4' * ( a1 - c4 ) , s [ f : sv ] , '7' * ( a2 - c7 ) , s [ sv : ] ] ) return sa1 , a2 , a3 , a4 = [ int ( x ) for x in input ( ) . split ( ) ] if abs ( a3 - a4 ) > 1 : print ( - 1 ) else : s = ' ' if a3 > a1 or a3 > a2 or a4 > a1 or a4 > a2 : print ( - 1 ) exit ( 0 ) c4 = 0 c7 = 0 if a3 > a4 : s = ' ' . join ( repeat ( '47' , a3 ) ) c4 = int ( len ( s ) \/ 2 ) c7 = len ( s ) - c4 s = fill ( s , a1 , a2 , a3 , a4 , c4 , c7 ) if s : print ( s ) else : print ( - 1 ) elif a3 < a4 : s = ' ' . join ( repeat ( '74' , a4 ) ) c7 = int ( len ( s ) \/ 2 ) c4 = len ( s ) - c7 s = fill ( s , a1 , a2 , a3 , a4 , c4 , c7 ) if s : print ( s ) else : print ( - 1 ) elif a3 == a4 : s = ' ' . join ( repeat ( '47' , a3 ) ) + '4' c4 = ceil ( len ( s ) \/ 2 ) c7 = len ( s ) - c4 s = fill ( s , a1 , a2 , a3 , a4 , c4 , c7 ) if s : print ( s ) else : s = ' ' . join ( repeat ( '74' , a3 ) ) + '7' c7 = ceil ( len ( s ) \/ 2 ) c4 = len ( s ) - c7 s = fill ( s , a1 , a2 , a3 , a4 , c4 , c7 ) if s : print ( s ) else : print ( - 1 ) NEW_LINE","a , b , c , d = input ( ) . strip ( ) . split ( ) a = int ( a ) b = int ( b ) c = int ( c ) d = int ( d )   if abs ( c - d ) > 1 or min ( a , b ) < max ( c , d ) or a == b == c == d : print ( - 1 ) exit ( )   if c == d : if a == c : ans = '74' * c + '7' * ( b - c ) else : ans = '4' * ( a - c - 1 ) + '47' * c + '7' * ( b - c ) + '4' elif c > d : ans = '4' * ( a - c ) + '47' * c + '7' * ( b - c ) else : ans = '7' + '4' * ( a - c ) + '74' * ( c - 1 ) + '7' * ( b - c ) + '4'   print ( ans ) NEW_LINE"],"bleu":0.08487044141022715,"rouge_l":0.3344356452876164}
{"id":385,"predictions":["def inpl ( ) : return [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE N = int ( input ( ) ) NEW_LINE a = inpl ( ) NEW_LINE ans = [ 0 for i in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT ans [ i ] = a [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT if N % i ] == 0 : NEW_LINE INDENT ans [ i ] = a [ i + 1 ] - a [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT ans [ i + 1 ] = a [ i ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT ans [ i ] = a [ i ] NEW_LINE DEDENT print ( * ans ) NEW_LINE"],"references":["n = int ( input ( ) ) l = [ [ ] for i in range ( n ) ] for i in range ( n ) : for a in range ( i ) : l [ i ] += [ a ]   for i in range ( n ) :   print ( ( ( n - 1 - i ) * 2 + 1 ) * \" ▁ \" , * l [ i ] , 1 * i , * list ( reversed ( l [ i ] ) ) )   for i in range ( n ) : print ( i , end = \" ▁ \" ) print ( n , end = \" ▁ \" ) for i in range ( n - 1 , 0 , - 1 ) : print ( i , end = \" ▁ \" ) print ( 0 )       for i in range ( n - 1 , - 1 , - 1 ) :     print ( ( ( n - 1 - i ) * 2 + 1 ) * \" ▁ \" , * l [ i ] , 1 * i , * list ( reversed ( l [ i ] ) ) )     NEW_LINE","n = int ( input ( ) )   space = n * 2 arr = [ ' ▁ ' * space + \"0\" ]   for i in range ( 1 , n + 1 ) : space -= 2 arr . append ( ( ' ▁ ' * space + ( arr [ - 1 ] + \" ▁ \" + str ( i ) ) . strip ( ) ) )   NEW_LINE","n = int ( input ( ) )   for i in range ( n + 1 ) : for j in range ( n - i ) : print ( \" ▁ ▁ \" , end = \" \" ) a = 0 x = 1 for k in range ( i * 2 + 1 ) : if ( k == i * 2 ) : print ( str ( a ) , end = \" \" ) else : print ( str ( a ) + ' ▁ ' , end = \" \" ) if ( a >= i ) : x *= - 1 a += x print ( )   for i in range ( n - 1 , - 1 , - 1 ) : for j in range ( n - i ) : print ( \" ▁ ▁ \" , end = \" \" ) a = 0 x = 1 for k in range ( i * 2 + 1 ) : if ( k == i * 2 ) : print ( str ( a ) , end = \" \" ) else : print ( str ( a ) + ' ▁ ' , end = \" \" ) if ( a >= i ) : x *= - 1 a += x print ( ) NEW_LINE","def printer ( n , spaces ) : spaces *= 2 if spaces : print ( ' ▁ ' * spaces , end = ' ' ) if n == 0 : print ( '0' ) return else : print ( '0' , end = ' ▁ ' )   for i in range ( 1 , n + 1 ) : print ( i , end = ' ▁ ' ) n -= 1 while n : print ( n , end = ' ▁ ' ) n -= 1 print ( 0 )     def solution ( ) : n = int ( input ( ) )   spaces = n currmax = 0 depth = 2 * n + 1 check = False for i in range ( depth ) : if not check : printer ( currmax , spaces ) spaces -= 1 currmax += 1 if spaces < 0 : check = True spaces = 0 currmax -= 2 else : spaces += 1 printer ( currmax , spaces ) currmax -= 1     \t \t \t \t \t \t       solution ( ) NEW_LINE","n = int ( input ( ) ) max_n = 2 * ( n + 1 ) - 1 max_len = 2 * max_n - 1   ans = [ ] for i in range ( n + 1 ) : tmp = \" ▁ \" . join ( map ( str , range ( i + 1 ) ) ) tmp += tmp [ - 2 : : - 1 ] ans . append ( \" { 0 : { 1 } ^ { 2 } } \" . format ( tmp , \" ▁ \" , max_len ) . rstrip ( \" ▁ \" ) ) print ( ans [ - 1 ] ) for line in ans [ - 2 : : - 1 ] : print ( line ) NEW_LINE"],"bleu":0.26448047804980246,"rouge_l":0.37600840813543923}
{"id":386,"predictions":["n , m = map ( int , input ( ) . split ( ) ) arr = [ x for x in range ( 0 , n + 1 ) ] d = 1 for i in range ( m ) : a , b = map ( int , input ( ) . split ( ) ) a , b = arr [ a ] , arr [ b ] while a != arr [ a ] : a = arr [ a ] while b != arr [ b ] : b = arr [ b ] if a != b : arr [ b ] = a d *= 2 print ( d ) NEW_LINE"],"references":["import sysdef input ( ) : return sys . stdin . readline ( ) . strip ( ) def iinput ( ) : return int ( input ( ) ) def minput ( ) : return map ( int , input ( ) . split ( ) ) def listinput ( ) : return list ( map ( int , input ( ) . split ( ) ) ) a , b , pos = minput ( ) for i in range ( b ) : a *= 10 c = a \/\/ b a = a % b if c == pos : print ( i + 1 ) exit ( ) print ( \" - 1\" ) NEW_LINE","import osimport sysfrom io import BytesIO , IOBase   BUFSIZE = 8192     class FastIO ( IOBase ) : newlines = 0   def __init__ ( self , file ) : self . _fd = file . fileno ( ) self . buffer = BytesIO ( ) self . writable = \" x \" in file . mode or \" r \" not in file . mode self . write = self . buffer . write if self . writable else None   def read ( self ) : while True : b = os . read ( self . _fd , max ( os . fstat ( self . _fd ) . st_size , BUFSIZE ) ) if not b : break ptr = self . buffer . tell ( ) self . buffer . seek ( 0 , 2 ) , self . buffer . write ( b ) , self . buffer . seek ( ptr ) self . newlines = 0 return self . buffer . read ( )   def readline ( self ) : while self . newlines == 0 : b = os . read ( self . _fd , max ( os . fstat ( self . _fd ) . st_size , BUFSIZE ) ) self . newlines = b . count ( b \" \\n \" ) + ( not b ) ptr = self . buffer . tell ( ) self . buffer . seek ( 0 , 2 ) , self . buffer . write ( b ) , self . buffer . seek ( ptr ) self . newlines -= 1 return self . buffer . readline ( )   def flush ( self ) : if self . writable : os . write ( self . _fd , self . buffer . getvalue ( ) ) self . buffer . truncate ( 0 ) , self . buffer . seek ( 0 )     class IOWrapper ( IOBase ) : def __init__ ( self , file ) : self . buffer = FastIO ( file ) self . flush = self . buffer . flush self . writable = self . buffer . writable self . write = lambda s : self . buffer . write ( s . encode ( \" ascii \" ) ) self . read = lambda : self . buffer . read ( ) . decode ( \" ascii \" ) self . readline = lambda : self . buffer . readline ( ) . decode ( \" ascii \" )     sys . stdin , sys . stdout = IOWrapper ( sys . stdin ) , IOWrapper ( sys . stdout ) input = lambda : sys . stdin . readline ( ) . rstrip ( \" \\n \" ) NEW_LINE","a , b , c = list ( map ( int , input ( ) . split ( ) ) )   pos = 1 for i in range ( 1000000 ) : d = ( 10 * a ) \/\/ b a = ( 10 * a ) % b if c == d : print ( pos ) exit ( 0 ) else : pos += 1 print ( - 1 ) NEW_LINE","a , b , c = map ( int , input ( ) . split ( ) ) for i in range ( 2 * b ) : a *= 10 if ( a \/\/ b == c ) : print ( i + 1 ) break a %= belse : print ( - 1 ) NEW_LINE","def short_division ( dividend : int , divisor : int ) -> ( int , int ) : \"\"\" ▁ ▁ ▁ ▁ This ▁ function ▁ returns ▁ a ▁ digit ▁ - ▁ remainder ▁ of ▁ the ▁ division ▁ ▁ ▁ ▁ Note ▁ that ▁ it ▁ is ▁ called ▁ only ▁ for ▁ the ▁ short ▁ division . ▁ ▁ ▁ ▁ \"\"\" remainder = dividend quotient = 0 while remainder >= divisor : remainder -= divisor quotient += 1 return quotient , remainder def long_division ( dividend : int , divisor : int , number_of_digits , target ) -> ( int , int ) : \"\"\" ▁ ▁ ▁ ▁ Long ▁ division ▁ function ▁ ▁ ▁ ▁ \"\"\" if divisor == 0 : raise ZeroDivisionError ( \" The ▁ divisor ▁ must ▁ be ▁ non - zero ▁ integer \" ) if dividend == 0 : return \"0\" positive = ( dividend > 0 and divisor > 0 ) or ( dividend < 0 and divisor < 0 ) NEW_LINE"],"bleu":0.36224037371341256,"rouge_l":0.46838007891649786}
{"id":387,"predictions":["import sys , os , ioimport math , bisect , operatorinf , mod = float ( ' inf ' ) , 10 ** 9 + 7 NEW_LINE"],"references":["n , k = map ( int , input ( ) . split ( ) ) a = input ( ) b = input ( ) res = 0 ans = 0 for i in range ( 0 , n ) : res = min ( res * 2 + ( b [ i ] == ' b ' ) - ( a [ i ] == ' b ' ) , k ) ans += min ( res + 1 , k ) print ( ans ) NEW_LINE","n , k = map ( int , input ( ) . split ( ) ) s = input ( ) t = input ( ) res = 0 ans = 0 for i in range ( 0 , n ) : res = min ( res * 2 - ( s [ i ] == ' b ' ) + ( t [ i ] == ' b ' ) , k ) ; ans += min ( res + 1 , k ) print ( ans ) NEW_LINE"],"bleu":0.011295255322644318,"rouge_l":0.17298272750708948}
{"id":388,"predictions":["import sys , os , ioimport math , bisect , operatorinf , mod = float ( ' inf ' ) , 10 ** 9 + 7 NEW_LINE"],"references":["k , a , b = map ( int , input ( ) . split ( ) ) if ( a >= 0 and b >= 0 ) or ( a < 0 and b < 0 ) : if a < 0 and b < 0 : temp = - b b = - a a = temp c = b \/\/ k - a \/\/ k if a % k == 0 : c += 1 elif a < 0 and b >= 0 : a = - a c = a \/\/ k + b \/\/ k + 1 print ( c ) NEW_LINE","import math   def main ( ) : k , a , b = map ( int , input ( ) . split ( ) )   low = ( a + k - 1 ) \/\/ k big = b \/\/ k   ans = big - low + 1   NEW_LINE","k , a , b = map ( int , input ( ) . split ( ) ) print ( b \/\/ k - ( a - 1 ) \/\/ k ) NEW_LINE","from math import floordef seal ( a , b ) : return ( a + b - 1 ) \/\/ bk , a , b = map ( int , input ( ) . split ( ) ) ans = abs ( b ) \/\/ k + abs ( a ) \/\/ kif ( a < 0 and b >= 0 ) : values = b - a + 1 print ( ans + 1 ) else : a , b = abs ( a ) , abs ( b ) a , b = min ( a , b ) , max ( a , b ) lower = seal ( a , k ) upper = int ( b \/\/ k ) print ( upper - lower + 1 ) NEW_LINE","k , a , b = map ( int , input ( ) . split ( ) ) x , y = a - ( a % k ) , b - ( b % k ) print ( ( y - x ) \/\/ k + ( 1 if a % k == 0 else 0 ) ) NEW_LINE"],"bleu":0.06956981282918376,"rouge_l":0.24691358024691362}
{"id":389,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = { input ( ) for _ in range ( n ) } b = { input ( ) for _ in range ( m ) } u = len ( a . intersection ( b ) ) print ( \" NO \" ) if m - u + u \/\/ 2 >= n - u + ( u + v ) \/\/ 2 else print ( \" YES \" ) NEW_LINE"],"references":["n = int ( input ( ) ) s = input ( )   arr = set ( list ( s ) ) if len ( arr ) < n : print ( \" NO \" )   else : ans = [ ] d = { }   for i in s : if i in d : ans [ - 1 ] += i else : d [ i ] = 1 ans . append ( i ) print ( \" YES \" ) for i in ans [ : n - 1 ] : print ( i )   print ( ' ' . join ( ans [ n - 1 : ] ) )   NEW_LINE","import sysimport mathimport collectionsimport bisectdef get_ints ( ) : return map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) def get_list ( ) : return list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) def get_string ( ) : return sys . stdin . readline ( ) . strip ( ) for t in range ( 1 ) : n = int ( input ( ) ) string = list ( get_string ( ) ) if len ( set ( string ) ) < n : print ( \" NO \" ) continue selected = set ( ) selected . add ( string [ 0 ] ) ans = [ ] left = 0 counted = 0 for i in range ( 1 , len ( string ) + 2 ) : if counted == n - 1 : sub_string = string [ left : ] ans . append ( sub_string ) break else : sub_string = string [ left : i ] if sub_string [ - 1 ] not in selected : selected . add ( sub_string [ - 1 ] ) ans . append ( sub_string [ : len ( sub_string ) - 1 ] ) selected . add ( sub_string [ 0 ] ) left = i - 1 counted += 1 print ( \" YES \" ) for i in ans : print ( * i , sep = \" \" ) NEW_LINE","k = int ( input ( ) ) s = input ( ) first_letter = [ ] lst = [ ] count = prev = i = 0 l = len ( s ) if k == 1 : print ( ' YES ' ) print ( s ) elif k > l : print ( ' NO ' ) else : while i < l : first_letter . append ( s [ i ] ) count += 1 i += 1 while i < l and s [ i ] in first_letter : i += 1 if count != k : lst . append ( s [ prev : i ] ) prev = i else : lst . append ( s [ prev : ] ) break if len ( lst ) == k : print ( ' YES ' ) print ( ' \\n ' . join ( lst ) ) else : print ( ' NO ' ) NEW_LINE","n = int ( input ( ) ) s = input ( ) s = list ( s ) s1 = list ( dict . fromkeys ( s ) ) if len ( s1 ) < n : print ( ' NO ' ) else : print ( ' YES ' ) i = 0 j = 0 while ( j < n ) : ind = s . index ( s1 [ i ] ) j += 1 if j < n : ind2 = s . index ( s1 [ i + 1 ] ) for o in range ( ind , ind2 ) : print ( str ( s [ o ] ) , end = \" \" ) print ( ) else : for o in range ( ind , len ( s ) ) : print ( s [ o ] , end = \" \" ) print ( ) i += 1 NEW_LINE","k = int ( input ( ) ) s = input ( ) ans = [ ] cur = \" \" used = set ( ) for i in range ( len ( s ) ) : if s [ i ] not in used : if len ( cur ) > 0 : ans . append ( cur ) cur = \" \" cur += s [ i ] used . add ( s [ i ] ) else : cur += s [ i ] ans . append ( cur ) if len ( ans ) < k : print ( \" NO \" ) else : print ( \" YES \" ) for i in range ( k , len ( ans ) ) : ans [ k - 1 ] += ans [ i ] for i in range ( k ) : print ( ans [ i ] ) NEW_LINE"],"bleu":0.25162395480763056,"rouge_l":0.36324968098681415}
{"id":390,"predictions":["t = int ( input ( ) ) NEW_LINE otv = list ( ) NEW_LINE while ( t != 0 ) : t -= 1 NEW_LINE konf = int ( input ( ) ) NEW_LINE cpisok_konf = list ( ) NEW_LINE cpisok_konf = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE sum_konf = sum ( cpisok_konf ) NEW_LINE if ( sum_konf % 2 == 0 and cpisok_konf . count ( 1 ) >= 2 ) : otv . append ( \" YES \" ) NEW_LINE continue NEW_LINE if ( sum_konf % 2 == 0 and konf % 2 == 1 ) : NEW_LINE INDENT otv . append ( \" YES \" ) else : NEW_LINE otv . append ( \" NO \" )   for i in otv : print ( i ) NEW_LINE DEDENT"],"references":["def mingrid ( ) : for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) segcost = input ( ) . split ( ) minodd = int ( segcost [ 0 ] ) mineven = int ( segcost [ 1 ] ) sumodd = minodd sumeven = mineven codd = 1 ceven = 1 res = sumodd + minodd * ( n - codd ) + sumeven + mineven * ( n - ceven ) for i in range ( 2 , n ) : now = int ( segcost [ i ] ) if ( i + 1 ) % 2 : NEW_LINE","    n = int ( input ( ) )   t = list ( map ( int , input ( ) . split ( ) ) )       t . sort ( ) m = t [ 0 ]   for j in range ( n ) : t [ j ] -= m     x = - 1   for j in range ( n ) : if t [ j ] > 0 : x = t [ j ] break       if x == - 1 : print ( ' YES ' ) else :   u = 0 for j in range ( n ) : if t [ j ] == 0 or t [ j ] == x or t [ j ] == 2 * x : continue else : u += 1   if u > 0 : print ( ' NO ' ) else : print ( ' YES ' ) NEW_LINE","n = int ( input ( ) ) lst = list ( map ( int , input ( ) . split ( ) ) )   lst = sorted ( lst )   mn = lst [ 0 ] mx = lst [ len ( lst ) - 1 ] if ( mx - mn ) <= 2 or n <= 2 : print ( \" YES \" )   elif ( mx - mn ) % 2 == 0 : x = int ( ( mx + mn ) \/ 2 ) flag = 0 for i in lst : if i != mn and i != mx and i != x : flag += 1 if ( flag == 0 ) : print ( \" YES \" ) else : print ( \" NO \" ) else : flag = 0 for i in lst : if i != mn and i != mx : flag += 1 if ( flag == 0 ) : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.38384836161720653,"rouge_l":0.3993764614185504}
{"id":391,"predictions":["n , m = map ( int , input ( ) . split ( ) ) f = n \/\/ mq = n % m   mini = ( f * ( f - 1 ) ) \/\/ ( 1 + 1 ) mini *= mmini += f * q ma = n - mma = ( ma * ( ma + 1 ) ) \/\/ ( 1 + 1 ) print ( mini , ma ) NEW_LINE"],"references":["import sys     def get_list ( ) : return list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) )   n = int ( input ( ) )   a = get_list ( ) b = get_list ( )   print ( \" Karen \" ) NEW_LINE","def E1 ( ) : n = int ( input ( ) ) kar = [ int ( x ) for x in input ( ) . split ( ) ] koy = [ int ( x ) for x in input ( ) . split ( ) ] print ( \" Karen \" )   if __name__ == ' _ _ main _ _ ' : E1 ( ) NEW_LINE"],"bleu":0.18126666508952022,"rouge_l":0.3825373854317414}
{"id":392,"predictions":["import sys , os , ioimport math , bisect , operatorinf , mod = float ( ' inf ' ) , 10 ** 9 + 7 NEW_LINE"],"references":["import sys       n , m , c = map ( int , input ( ) . split ( ) )   free = n   nums = [ 0 ] * n       for i in range ( m ) :   pi = int ( input ( ) )   if ( pi > c \/\/ 2 ) :   current = n - 1   while ( nums [ current ] > 0 and nums [ current ] >= pi and current >= 0 ) : current -= 1   if ( current == - 1 ) : current = 0   if ( nums [ current ] == 0 ) : free -= 1   nums [ current ] = pi   print ( current + 1 )   else :   current = 0   while ( current < n and nums [ current ] > 0 and nums [ current ] <= pi ) : current += 1   if ( current == n ) : current = n - 1   if ( nums [ current ] == 0 ) : free -= 1   nums [ current ] = pi   print ( current + 1 )       if ( free == 0 ) : break               NEW_LINE","import sys   n , m , c = map ( int , input ( ) . split ( ) ) a = [ ] for i in range ( n + 1 ) : a . append ( 0 ) cnt = 0 while cnt < n : i = 0 x = int ( input ( ) ) if x * 2 <= c : i = 1 while a [ i ] and a [ i ] <= x : i += 1 else : i = n while a [ i ] and a [ i ] >= x : i -= 1 if a [ i ] == 0 : cnt += 1 a [ i ] = x print ( i ) sys . stdout . flush ( ) NEW_LINE","import sys   n , m , c = map ( int , input ( ) . split ( ) ) a = [ ] for i in range ( n + 1 ) : a . append ( 0 ) cnt = 0 while cnt < n : i = 0 x = int ( input ( ) ) if x * 2 <= c : i = 1 while a [ i ] and a [ i ] <= x : i += 1 else : i = n while a [ i ] and a [ i ] >= x : i -= 1 if a [ i ] == 0 : cnt += 1 a [ i ] = x print ( i ) sys . stdout . flush ( ) NEW_LINE"],"bleu":0.001498197108510899,"rouge_l":0.09975470155355683}
{"id":393,"predictions":["n = int ( input ( ) ) for _ in range ( n ) : a = input ( ) b = len ( set ( a ) ) if b == 1 : print ( a ) else : if a [ 0 ] == \"0\" : print ( \"01\" * len ( a ) ) NEW_LINE"],"references":["from sys import stdin , stdoutimport math , bisectfrom collections import Counter , deque , defaultdictL = lambda : list ( map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) ) M = lambda : map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) I = lambda : int ( stdin . readline ( ) . strip ( ) ) S = lambda : stdin . readline ( ) . strip ( ) C = lambda : stdin . readline ( ) . strip ( ) . split ( ) def pr ( a ) : return ( \" \" . join ( list ( map ( str , a ) ) ) ) NEW_LINE","s = input ( )   if len ( set ( s ) ) == 1 : print ( s ) else : noOnes = \" \"   oneCount = 0   for i in range ( len ( s ) ) : if s [ i ] == '1' : oneCount += 1 else : noOnes += s [ i ]   for i in range ( len ( noOnes ) ) : if noOnes [ i ] == '2' : noOnes = noOnes [ : i ] + '1' * oneCount + noOnes [ i : ] break if i == len ( noOnes ) - 1 : noOnes = noOnes + '1' * oneCount print ( noOnes ) NEW_LINE","if __name__ == ' _ _ main _ _ ' : s = input ( )   len1 = s . count ( '1' ) index2 = s . find ( '2' ) if index2 == - 1 : s = list ( s ) s . sort ( ) print ( ' ' . join ( s ) )   else : temp = s [ : index2 ]   zero = temp . count ( '0' ) result = '0' * zero + '1' * len1 + s [ index2 : ] . replace ( '1' , ' ' )   print ( result ) NEW_LINE","strNum = input ( ) ones = strNum . count ( \"1\" ) NEW_LINE"],"bleu":0.30776611115737756,"rouge_l":0.5591521054139216}
{"id":394,"predictions":["vow = set ( [ ' a ' , ' e ' , ' i ' , ' o ' , ' u ' , ' y ' ] ) def f ( x ) : q = 0 for y in x : q += int ( y ) return q NEW_LINE"],"references":["print ( ' YES ' if len ( [ i for i in input ( ) if i in ' aeiou ' ] ) == 5 and len ( [ i for i in input ( ) if i in ' aeiou ' ] ) == 7 and len ( [ i for i in input ( ) if i in ' aeiou ' ] ) == 5 else ' NO ' ) NEW_LINE","s1 = input ( ) NEW_LINE s2 = input ( ) NEW_LINE s3 = input ( ) NEW_LINE count1 , count2 , count3 = 0 , 0 , 0 NEW_LINE for i in s1 : if NEW_LINE i in [ \" a \" , \" e \" , \" i \" , \" o \" , \" u \" ] : count1 += 1 NEW_LINE for i in s2 : if NEW_LINE i in [ \" a \" , \" e \" , \" i \" , \" o \" , \" u \" ] : count2 += 1 NEW_LINE for i in s3 : if NEW_LINE i in [ \" a \" , \" e \" , \" i \" , \" o \" , \" u \" ] : count3 += 1   if count1 == 5 and count2 == 7 and count3 == 5 : NEW_LINE INDENT print ( \" YES \" ) else : NEW_LINE print ( \" NO \" ) NEW_LINE DEDENT","l1 = input ( ) NEW_LINE l2 = input ( ) NEW_LINE l3 = input ( ) NEW_LINE haiku = [ l1 , l2 , l3 ] NEW_LINE","v = set ( ' aeiou ' ) NEW_LINE arr = [ 5 , 7 , 5 ] NEW_LINE for i in range ( 3 ) : s = input ( ) NEW_LINE temp = 0 NEW_LINE for letter in s : if NEW_LINE letter in v : temp += 1 NEW_LINE if temp != arr [ i ] : print ( ' NO ' ) NEW_LINE exit ( ) NEW_LINE print ( ' YES ' )   NEW_LINE","s1 = input ( ) NEW_LINE s2 = input ( ) NEW_LINE s3 = input ( ) NEW_LINE a = s1 . count ( \" a \" ) + s1 . count ( \" o \" ) + s1 . count ( \" e \" ) + s1 . count ( \" i \" ) + s1 . count ( \" u \" ) NEW_LINE b = s2 . count ( \" a \" ) + s2 . count ( \" o \" ) + s2 . count ( \" e \" ) + s2 . count ( \" i \" ) + s2 . count ( \" u \" ) NEW_LINE c = s3 . count ( \" a \" ) + s3 . count ( \" o \" ) + s3 . count ( \" e \" ) + s3 . count ( \" i \" ) + s3 . count ( \" u \" ) NEW_LINE print ( \" YES \" if a == 5 and b == 7 and c == 5 else \" NO \" ) NEW_LINE"],"bleu":0.10537999530688683,"rouge_l":0.3541831617841119}
{"id":395,"predictions":["n = int ( input ( ) ) s = input ( ) a = [ 0 ] * 26 for i in s : a [ ord ( i ) - ord ( ' a ' ) ] += 1 a . sort ( reverse = True ) if a [ 0 ] > 1 or n == 1 : print ( \" Yes \" ) else : print ( \" No \" ) NEW_LINE"],"references":["import syspassword = input ( ) ; n = int ( input ( ) ) ; first = second = 0 ; words = [ ] for i in range ( 0 , n ) : words . append ( input ( ) ) for word in words : if password [ 0 ] == word [ 1 ] : first = 1 if password [ 1 ] == word [ 0 ] : second = 1 if password == word : first = second = 1 if first == second == 1 : print ( \" YES \" ) sys . exit ( 0 ) print ( \" NO \" ) NEW_LINE","password = input ( ) n = int ( input ( ) ) res = [ ] for i in range ( n ) : res . append ( input ( ) ) flag = Falsefor i in range ( len ( res ) ) : for j in range ( len ( res ) ) : if password in res [ i ] + res [ j ] : flag = True break if password in res [ j ] + res [ i ] : flag = True break if flag : breakif flag : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE","password = input ( ) n = int ( input ( ) ) first_letter_found = second_letter_found = 0 result = ' NO ' for i in range ( n ) : word = input ( ) if word == password : result = ' YES ' elif result == ' NO ' : if word [ 1 ] == password [ 0 ] : first_letter_found = 1 if word [ 0 ] == password [ 1 ] : second_letter_found = 1   if result == ' NO ' and first_letter_found == 1 and second_letter_found == 1 : result = ' YES ' print ( result ) NEW_LINE","def solve ( arr , s , n ) : res = [ ] for i in arr : for j in arr : res . append ( i + j ) res . append ( j + i ) for i in res : if s in i : return ' YES ' return ' NO '                         def main ( ) : s = input ( ) n = int ( input ( ) ) NEW_LINE","def solve ( arr , s , n ) : for i in arr : for j in arr : if s in i + j or s in j + i : return ' YES ' return ' NO '                         def main ( ) : s = input ( ) n = int ( input ( ) ) NEW_LINE"],"bleu":0.3908080785090506,"rouge_l":0.41906836461126007}
{"id":396,"predictions":["t = int ( input ( ) ) NEW_LINE for i in range ( t ) : n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE sum1 = 0 NEW_LINE b = 0 NEW_LINE for j in range ( n ) : sum1 += a [ j ] NEW_LINE if sum1 % 2 != 0 : NEW_LINE INDENT print ( ' YES ' ) else : NEW_LINE print ( ' NO ' ) NEW_LINE DEDENT"],"references":["for _ in range ( int ( input ( ) ) ) : n , m = map ( int , input ( ) . split ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if m == sum ( arr ) : print ( ' YES ' )   else : print ( ' NO ' ) NEW_LINE","import mathfor NEW_LINE _ in range ( int ( input ( ) ) ) : n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if sum ( a ) == m : NEW_LINE INDENT print ( \" YES \" ) else : NEW_LINE print ( \" NO \" ) NEW_LINE DEDENT","import sys   input = sys . stdin . buffer . readline   t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : n , m = map ( int , input ( ) . split ( ) ) NEW_LINE S = sum ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( \" YES \" if S == m else \" NO \" ) NEW_LINE","import sys   input = sys . stdin . buffer . readline   t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : n , m = map ( int , input ( ) . split ( ) ) NEW_LINE S = sum ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE print ( \" YES \" if S == m else \" NO \" ) NEW_LINE","t = int ( input ( ) ) NEW_LINE while t : t -= 1 NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE sum = 0 NEW_LINE for x in l : sum += x NEW_LINE if sum == m : NEW_LINE INDENT print ( \" YES \" ) else : NEW_LINE print ( \" NO \" ) NEW_LINE DEDENT"],"bleu":0.6306202312221783,"rouge_l":0.6858688698782379}
{"id":397,"predictions":["import sysdef input ( ) : return sys . stdin . readline ( ) . strip ( ) def iinput ( ) : return int ( input ( ) ) def minput ( ) : return map ( int , input ( ) . split ( ) ) def listinput ( ) : return list ( map ( int , input ( ) . split ( ) ) ) n , l , r = minput ( ) mi = 2 ** l - 1 + n - lma = 2 ** r - 1 + 2 ** ( r - 1 ) * ( n - r ) print ( mi , ma ) NEW_LINE"],"references":["w , m , k = map ( int , input ( ) . split ( ) ) z = mdig = 0 while z > 0 : dig += 1 ; z = z \/\/ 10 if ( dig * k > w ) : print ( 0 ) exit ( 0 ) lo = m - 1 hi = w + m + 5 while lo + 1 < hi : mid = ( lo + hi ) \/\/ 2 cost , t , d = 0 , 0 , 0 x = mid while x > 0 : x = x \/\/ 10 d += 1 if ( d == dig ) : cost = ( mid - m + 1 ) * d * k else : t = pow ( 10 , dig ) last = m c = dig while t <= mid : cost += ( t - last ) * c * k c += 1 last = t t = t * 10 t = t \/\/ 10 cost += ( mid - t + 1 ) * c * k if ( cost <= w ) : lo = mid else : hi = midprint ( lo - m + 1 ) NEW_LINE","w , m , k = map ( int , input ( ) . split ( ) ) cur = len ( str ( m ) ) g = 9 base = 1 g = g * ( 10 ** ( cur - 1 ) ) base = base * ( 10 ** ( cur - 1 ) ) gg = g - ( m - base ) ans = 0 while ( w ) : if ( w > cur * gg * k ) : w -= cur * gg * k ans += gg cur += 1 gg = g * 10 g *= 10 else : ans += w \/\/ ( cur * k ) breakprint ( ans ) NEW_LINE","have , start , k = map ( int , input ( ) . split ( ) )   ans = 0 while have > 0 : length = len ( str ( start ) ) howMany = ( 10 ** length - start ) cost = k * ( howMany ) * length if cost <= have : ans += howMany have -= cost start = 10 ** length else : ans += max ( 0 , have \/\/ ( k * length ) ) have = 0   print ( ans ) NEW_LINE","from math import *   w , m , k = list ( map ( int , input ( ) . split ( ) ) ) cnt = 0 add = 9 * 10 ** ( - 1 ) if m < 10 else 0 for i in range ( int ( log10 ( m ) ) , int ( 1e10 ) ) : v = ( 9 * 10 ** i - ( m - 1 - 9 * 10 ** ( i - 1 ) + add if i == int ( log10 ( m ) ) else 0 ) ) * ( i + 1 ) * k if w - v < 0 : cnt += w \/\/ ( ( i + 1 ) * k ) break w -= v cnt += v \/\/ ( k * ( i + 1 ) ) print ( int ( cnt ) ) NEW_LINE","def cnt ( x , y ) : return y - x   w , m , k = map ( int , input ( ) . split ( ) ) p , d , res = 1 , 0 , 0 while p <= m : p *= 10 d += 1 while cnt ( m , p ) * d * k <= w : w -= cnt ( m , p ) * d * k res += cnt ( m , p ) m = p p *= 10 d += 1 lo , hi = m , pwhile hi - lo > 1 : mid = ( lo + hi ) \/\/ 2 if ( cnt ( m , mid ) * d * k <= w ) : lo = mid else : hi = midres += cnt ( m , lo )   print ( res ) NEW_LINE"],"bleu":0.24527193675698672,"rouge_l":0.3490360951599672}
{"id":398,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) s = 0 for i in range ( n ) : if i % 2 == 0 : s += a [ i ] else : s -= a [ i ] print ( s ) NEW_LINE"],"references":["from collections import Counterfrom itertools import combinations   if __name__ == ' _ _ main _ _ ' : n = int ( input ( ) ) a = [ int ( i ) for i in input ( ) . split ( ) ] s = sum ( a ) t = s s \/= 2   while n > 0 and t > s : t -= a [ n - 1 ] n -= 1 print ( n + 1 if t < s else n ) NEW_LINE","from sys import stdin     input_number = int ( stdin . readline ( ) )   array = [ int ( x ) for x in stdin . readline ( ) . split ( ) ]     calendar = dict ( ) current_sum = 0   for i in range ( input_number ) :   current_sum += array [ i ]   if current_sum * 2 >= ( current_sum + input_number - i - 1 ) :   calendar . setdefault ( str ( i + 1 ) , current_sum )       for k , v in calendar . items ( ) :   if v * 2 >= ( current_sum + input_number - i - 1 ) :   print ( k )   break               NEW_LINE","n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = sum ( a ) c = 0 for i in range ( n ) : c += a [ i ] if c >= b \/ 2 : print ( i + 1 ) break NEW_LINE","n = int ( input ( ) ) A = list ( map ( int , input ( ) . split ( ' ▁ ' ) ) ) s = sum ( A )   if s % 2 == 0 : s = s \/\/ 2 else : s = s \/\/ 2 + 1   c = 0 ans = 1 for i in A : c += i if c >= s : break ans += 1 print ( ans ) NEW_LINE","from collections import Counterfrom itertools import combinations   if __name__ == ' _ _ main _ _ ' : n = int ( input ( ) ) a = [ int ( i ) for i in input ( ) . split ( ) ] s = sum ( a ) t = s   while n > 0 and t > ( s \/ 2 ) : t -= a [ n - 1 ] n -= 1 print ( n + 1 if t < s \/ 2 else n ) NEW_LINE"],"bleu":0.7690268313735313,"rouge_l":0.7189628077527502}
{"id":399,"predictions":["def main ( ) : t = int ( input ( ) ) for _ in range ( t ) : n = int ( input ( ) ) NEW_LINE"],"references":["from sys import stdin , stdoutfrom math import floor , gcd , fabs , factorial , fmod , sqrt , inf , logfrom collections import defaultdict as dd , dequefrom heapq import merge , heapify , heappop , heappush , nsmallestfrom bisect import bisect_left as bl , bisect_right as br , bisect mod = pow ( 10 , 9 ) + 7 mod2 = 998244353 def inp ( ) : return stdin . readline ( ) . strip ( ) def iinp ( ) : return int ( inp ( ) ) def out ( var , end = \" \\n \" ) : stdout . write ( str ( var ) + \" \\n \" ) def outa ( * var , end = \" \\n \" ) : stdout . write ( ' ▁ ' . join ( map ( str , var ) ) + end ) def lmp ( ) : return list ( mp ( ) ) def mp ( ) : return map ( int , inp ( ) . split ( ) ) def smp ( ) : return map ( str , inp ( ) . split ( ) ) def l1d ( n , val = 0 ) : return [ val for i in range ( n ) ] def l2d ( n , m , val = 0 ) : return [ l1d ( m , val ) for j in range ( n ) ] def remadd ( x , y ) : return 1 if x % y else 0 def ceil ( a , b ) : return ( a + b - 1 ) \/\/ b def isprime ( x ) : if x <= 1 : return False if x in ( 2 , 3 ) : return True if x % 2 == 0 : return False for i in range ( 3 , int ( sqrt ( x ) ) + 1 , 2 ) : if x % i == 0 : return False return True n = iinp ( ) s = inp ( ) for i in range ( n ) : print ( s [ i ] , end = ' ' ) if n - i >= 3 and i % 2 : print ( ' - ' , end = ' ' ) print ( ) NEW_LINE","n = int ( input ( ) ) v = input ( )   ans = [ ]   i = 0 while ( i < n ) : if ( n - i == 3 ) : ans . append ( v [ i ] + v [ i + 1 ] + v [ i + 2 ] ) i += 4 break else : ans . append ( v [ i ] + v [ i + 1 ] ) i += 2 print ( ' - ' . join ( ans ) ) NEW_LINE","n = int ( input ( ) ) s = input ( )   if n % 2 == 0 : ans = [ s [ i : i + 2 ] for i in range ( 0 , n , 2 ) ] print ( ' - ' . join ( ans ) ) else : x = s [ : 3 ] s = s [ 3 : ] ans = [ x ] + [ s [ i : i + 2 ] for i in range ( 0 , n - 3 , 2 ) ] print ( ' - ' . join ( ans ) ) NEW_LINE","n = int ( input ( ) ) a = input ( ) b = ' ' if n % 2 == 0 : i = 0 while ( i < n - 2 ) : b = b + a [ i ] + a [ i + 1 ] + ' - ' i = i + 2 b = b + a [ i ] + a [ i + 1 ] else : i = 0 if n == 3 : b = b + a [ i ] + a [ i + 1 ] + a [ i + 2 ] i = i + 3 elif n == 5 : b = b + a [ i ] + a [ i + 1 ] + ' - ' + a [ i + 2 ] + a [ i + 3 ] + a [ i + 4 ] i = i + 5 elif n % 3 == 0 : b = a [ i ] + a [ i + 1 ] + ' - ' i = i + 2 while ( i < n - 4 ) : b = b + a [ i ] + a [ i + 1 ] + a [ i + 2 ] + ' - ' i = i + 3 b = b + a [ i ] + a [ i + 1 ] + ' - ' + a [ i + 2 ] + a [ i + 3 ] elif n % 3 == 2 : b = a [ i ] + a [ i + 1 ] + ' - ' i = i + 2 while ( i < n - 6 ) : b = b + a [ i ] + a [ i + 1 ] + a [ i + 2 ] + ' - ' i = i + 3 b = b + a [ i ] + a [ i + 1 ] + ' - ' + a [ i + 2 ] + a [ i + 3 ] + ' - ' + a [ i + 4 ] + a [ i + 5 ] else : b = a [ i ] + a [ i + 1 ] + ' - ' i = i + 2 while ( i < n - 2 ) : b = b + a [ i ] + a [ i + 1 ] + a [ i + 2 ] + ' - ' i = i + 3 b = b + a [ i ] + a [ i + 1 ] print ( b ) NEW_LINE","n = int ( input ( ) ) l = list ( map ( int , input ( ) ) ) ans = [ ] if n % 2 == 1 : ans . append ( l [ 0 ] ) l = l [ 1 : ] n -= 1 ans += l [ 0 : 2 ] for i in range ( 2 , n , 2 ) : ans . append ( ' - ' ) ans += l [ i : i + 2 ] print ( * ans , sep = \" \" ) NEW_LINE"],"bleu":0.054155373839792506,"rouge_l":0.26224299065420564}
{"id":400,"predictions":["def trans ( c ) : return chr ( ord ( c ) + 1 )   n = int ( input ( ) ) s = trans ( c ) if ( ord ( ' a ' ) + ord ( ' a ' ) == ord ( s [ - 1 ] ) - ord ( ' a ' ) ) : print ( \" NO \" ) else : if ( s == ord ( ' a ' ) + ord ( ' b ' ) ) : print ( \" Yes \" ) else : print ( \" No \" )                     NEW_LINE"],"references":["def p2 ( a ) : n = len ( a ) last = [ [ - 1 ] * 26 for _ in range ( n ) ] last [ 0 ] [ ord ( a [ 0 ] ) - 97 ] = 0 for i in range ( 1 , n ) : for j in range ( 26 ) : last [ i ] [ j ] = last [ i - 1 ] [ j ] last [ i ] [ ord ( a [ i ] ) - 97 ] = i dp = [ ' ' ] * n for i in range ( n - 1 , - 1 , - 1 ) : for j in range ( n - 1 , i , - 1 ) : k = last [ j ] [ ord ( a [ i ] ) - 97 ] if k > i : if ( k - i ) == 1 and len ( dp [ j ] ) < 2 : dp [ j ] = a [ i ] + a [ i ] elif len ( dp [ j ] ) < ( len ( dp [ k - 1 ] ) + 2 ) : dp [ j ] = a [ i ] + dp [ k - 1 ] + a [ i ] if len ( dp [ j ] ) >= 100 : if len ( dp [ j ] ) == 101 : return dp [ j ] [ : 50 ] + dp [ j ] [ 51 : ] else : return dp [ j ] dp [ i ] = a [ i ] return dp [ n - 1 ]     a = input ( ) print ( p2 ( a ) ) NEW_LINE","def p2 ( a ) : n = len ( a ) last = [ [ 0 ] * 26 for _ in range ( n ) ] last [ 0 ] [ ord ( a [ 0 ] ) - 97 ] = 0 for i in range ( 1 , n ) : for j in range ( 26 ) : last [ i ] [ j ] = last [ i - 1 ] [ j ] last [ i ] [ ord ( a [ i ] ) - 97 ] = i dp = [ ' ' ] * n for i in range ( n - 1 , - 1 , - 1 ) : for j in range ( n - 1 , i , - 1 ) : k = last [ j ] [ ord ( a [ i ] ) - 97 ] if k > i : if ( k - i ) == 1 and len ( dp [ j ] ) < 2 : dp [ j ] = a [ i ] + a [ i ] elif len ( dp [ j ] ) < ( len ( dp [ k - 1 ] ) + 2 ) : dp [ j ] = a [ i ] + dp [ k - 1 ] + a [ i ] if len ( dp [ j ] ) >= 100 : if len ( dp [ j ] ) == 101 : return dp [ j ] [ : 50 ] + dp [ j ] [ 51 : ] else : return dp [ j ] dp [ i ] = a [ i ] return dp [ n - 1 ]   print ( p2 ( input ( ) ) ) NEW_LINE"],"bleu":0.023726366040522348,"rouge_l":0.21748431260695952}
{"id":401,"predictions":["a , b , r = map ( int , input ( ) . split ( ) ) if ( 2 * r > min ( a , b ) ) : print ( \" Second \" ) else : print ( \" First \" ) NEW_LINE"],"references":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) p = [ 0 ] * nfor i in range ( n ) : p [ a [ i ] - 1 ] = i + 1 s = 0 for i in range ( n - 1 ) : s += abs ( p [ i ] - p [ i + 1 ] ) print ( s ) NEW_LINE","n = int ( input ( ) ) f = [ int ( x ) for x in input ( ) . split ( ) ]   main = [ ] for i in range ( n ) : main . append ( ( f [ i ] , i ) ) main . sort ( )   ans = 0 for i in range ( n - 1 ) : ans += abs ( main [ i ] [ 1 ] - main [ i + 1 ] [ 1 ] )   print ( ans ) NEW_LINE","n = int ( input ( ) ) lst = list ( map ( int , input ( ) . strip ( ) . split ( ' ▁ ' ) ) ) l = [ ] for j in range ( n ) : l . append ( [ lst [ j ] , j ] ) l . sort ( key = lambda x : x [ 0 ] ) c = 0 for i in range ( 1 , n ) : c += abs ( l [ i ] [ 1 ] - l [ i - 1 ] [ 1 ] ) print ( c ) NEW_LINE","n = int ( input ( ) ) L = [ int ( x ) for x in input ( ) . split ( ) ] pos = [ 0 ] * nfor i in range ( n ) : pos [ L [ i ] - 1 ] = ians = 0 for i in range ( n - 1 ) : ans += abs ( pos [ i ] - pos [ i + 1 ] ) print ( ans ) NEW_LINE","n = int ( input ( ) ) lst = list ( map ( int , input ( ) . strip ( ) . split ( ' ▁ ' ) ) ) l = [ ] for j in range ( n ) : l . append ( [ lst [ j ] , j ] ) l . sort ( key = lambda x : x [ 0 ] ) c = 0 for i in range ( 1 , n ) : c += abs ( l [ i ] [ 1 ] - l [ i - 1 ] [ 1 ] ) print ( c ) NEW_LINE"],"bleu":0.1496235068937101,"rouge_l":0.3570592367127136}
{"id":402,"predictions":["def STR ( ) : return list ( input ( ) ) def INT ( ) : return int ( input ( ) ) def MAP ( ) : return map ( int , input ( ) . split ( ) ) def MAP2 ( ) : return map ( float , input ( ) . split ( ) ) def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) def STRING ( ) : return input ( ) import stringimport sysfrom heapq import heappop , heappushfrom bisect import * from collections import deque , Counter , defaultdictfrom math import * from itertools import permutations , accumulatedx = [ - 1 , 1 , 0 , 0 ] dy = [ 0 , 0 , 1 , - 1 ] NEW_LINE"],"references":["def count ( a ) : n = len ( a ) cnt = 0 for i in range ( n ) : for j in range ( i + 1 , n ) : if a [ i ] > a [ j ] : cnt += 1 return cnt                       n = int ( input ( ) ) p = list ( map ( int , input ( ) . split ( ) ) ) num = count ( p )   print ( num * 2 - num % 2 ) NEW_LINE","from sys import *   n = int ( stdin . readline ( ) . strip ( ) ) s1 = stdin . readline ( ) . strip ( ) a = list ( map ( int , s1 . split ( ) ) )   if n == 1 : print ( '0' ) else : x = 0 n0 = 1 while n0 < n : n0 = n0 * 2 b = [ 0 ] * ( 2 * n0 + 10 ) ''' for ▁ i ▁ in ▁ range ▁ ( n - 1 ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ for ▁ j ▁ in ▁ range ▁ ( i + 1 , n ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ a [ i ] > a [ j ] : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ x + = 1 ''' for i in range ( n ) : t = a [ i ] u = 0 k = 1 j = 1 while t > 0 : if ( t >> j ) << j != t : u = u + b [ ( n0 + t - 1 ) >> ( j - 1 ) ] t = t - k k = k << 1 j = j + 1 x = x + u j = n0 + a [ i ] - 1 while j > 0 : b [ j ] += 1 j = j >> 1 x = ( ( n * ( n - 1 ) ) \/\/ 2 ) - x ''' n = x \/ \/2 ▁ ▁ ▁ ▁ print ( x , n , ' ▁ ! ! ! ' ) ▁ ▁ ▁ ▁ r = x ▁ ▁ ▁ ▁ i = 1 ▁ ▁ ▁ ▁ bi = n ▁ ▁ ▁ ▁ eps = 0.0000001 ▁ ▁ ▁ ▁ if ▁ x > 0 : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ while ▁ ( x + 2 * i ) * bi * ( ( 0.5 ) * * i ) > eps : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ r = r + ( x + 2 * i ) * bi * ( ( 0.5 ) * * i ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ # print ( r ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ bi = ( bi * ( n + i ) ) \/ \/ ( i + 1 ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ i = i + 1 ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ # print ( bi , i ) ▁ ▁ ▁ ▁ else : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ r = 0 ▁ ▁ ▁ ▁ r = r * ( ( 0.5 ) * * n ) ▁ ▁ ▁ ▁ print ( \" % .7f \" % r ) ''' if x % 2 == 1 : print ( 2 * x - 1 ) else : print ( 2 * x ) NEW_LINE","from bisect import bisect_rightinput ( ) t = list ( map ( int , input ( ) . split ( ) ) ) s , p = 0 , [ ] for i , j in enumerate ( t ) : k = bisect_right ( p , j ) s += i - k p . insert ( k , j ) print ( 2 * s - ( s & 1 ) ) NEW_LINE","def merge_sort ( a , l , r ) : res = 0 if l < r : m = ( l + r ) \/\/ 2 res += merge_sort ( a , l , m ) res += merge_sort ( a , m + 1 , r ) i = l j = m + 1 b = [ ] while i <= m and j <= r : if a [ i ] <= a [ j ] : b . append ( a [ i ] ) i += 1 else : b . append ( a [ j ] ) j += 1 res += m - i + 1   while i <= m : b . append ( a [ i ] ) i += 1   while j <= r : b . append ( a [ j ] ) j += 1 for idx , val in enumerate ( b ) : a [ idx + l ] = val return res     input ( ) a = [ int ( x ) for x in input ( ) . split ( ) ] n = len ( a ) ans = merge_sort ( a , 0 , n - 1 ) if ans & 1 == 0 : ans *= 2 else : ans = ans * 2 - 1 print ( ans ) NEW_LINE","def merge_sort ( a , l , r ) :   res = 0   if l < r :   m = ( l + r ) \/\/ 2   res += merge_sort ( a , l , m )   res += merge_sort ( a , m + 1 , r )             i = l   j = m + 1   b = [ ]   while i <= m and j <= r :   if a [ i ] <= a [ j ] :   b . append ( a [ i ] )   i += 1   else :   b . append ( a [ j ] )   j += 1   res += m - i + 1       while i <= m :   b . append ( a [ i ] )   i += 1       while j <= r :   b . append ( a [ j ] )   j += 1             for idx , val in enumerate ( b ) :   a [ idx + l ] = val                 return res         input ( )   a = [ int ( x ) for x in input ( ) . split ( ) ]   n = len ( a )   ans = merge_sort ( a , 0 , n - 1 )   if ans & 1 == 0 :   ans *= 2   else :   ans = ans * 2 - 1   print ( ans )           NEW_LINE"],"bleu":0.23418282753797412,"rouge_l":0.412809667673716}
{"id":403,"predictions":["a , b , c , d = map ( int , input ( ) . split ( ) ) misha = max ( 3 * a \/ 10 , a - ( a \/ 250 ) * c ) vasya = max ( 3 * b \/ 10 , b - ( b \/ 250 ) * d ) print ( \" Misha \" ) NEW_LINE"],"references":["def STR ( ) : return list ( input ( ) ) def INT ( ) : return int ( input ( ) ) def MAP ( ) : return map ( int , input ( ) . split ( ) ) def MAP2 ( ) : return map ( float , input ( ) . split ( ) ) def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) def STRING ( ) : return input ( ) import stringimport sysfrom heapq import heappop , heappushfrom bisect import * from collections import deque , Counter , defaultdictfrom math import * from itertools import permutations , accumulatedx = [ - 1 , 1 , 0 , 0 ] dy = [ 0 , 0 , 1 , - 1 ] NEW_LINE","choices = [ ] d = [ ' A ' , ' B ' , ' C ' , ' D ' ]   for _ in range ( 4 ) : choices . append ( len ( input ( ) ) - 2 )   option = choices . copy ( ) choices . sort ( )   if choices [ 0 ] <= choices [ 1 ] \/ 2 and choices [ 2 ] <= choices [ 3 ] \/ 2 : ans = 2 elif choices [ 0 ] <= choices [ 1 ] \/ 2 : ans = option . index ( choices [ 0 ] ) elif choices [ 2 ] <= choices [ 3 ] \/ 2 : ans = option . index ( choices [ 3 ] ) else : ans = 2   print ( d [ ans ] ) NEW_LINE","q , t = 0 , sorted ( [ ( len ( input ( ) ) - 2 , i ) for i in ' ABCD ' ] ) if 2 * t [ 0 ] [ 0 ] <= t [ 1 ] [ 0 ] : q += 1 if t [ 3 ] [ 0 ] >= 2 * t [ 2 ] [ 0 ] : q += 2 print ( [ ' C ' , t [ 0 ] [ 1 ] , t [ 3 ] [ 1 ] , ' C ' ] [ q ] ) NEW_LINE","d = { } ans = 0 cnt = 0 for i in range ( 4 ) : x = list ( input ( ) . split ( \" . \" ) ) d [ x [ 0 ] ] = len ( x [ 1 ] )     for x in d . keys ( ) : flag = True for y in d . keys ( ) : if d [ x ] > ( d [ y ] \/ 2 ) and ( x != y ) : flag = False   if flag : ans = x cnt += 1     for x in d . keys ( ) : flag = True for y in d . keys ( ) : if d [ x ] < ( d [ y ] * 2 ) and ( x != y ) : flag = False   if flag : ans = x cnt += 1   if cnt != 1 : print ( \" C \" ) else : print ( ans ) NEW_LINE","if __name__ == ' _ _ main _ _ ' : s = list ( ) for _ in range ( 4 ) : s . append ( len ( input ( ) ) - 2 ) l = sorted ( s ) mn , mx = l [ 0 ] , l [ 3 ] mn = l [ 0 ] if l [ 0 ] <= l [ 1 ] \/ 2 else 0 mx = l [ 3 ] if l [ 3 ] >= l [ 2 ] * 2 else 0 if not mn and mx : print ( chr ( s . index ( mx ) + ord ( \" A \" ) ) ) elif mn and not mx : print ( chr ( s . index ( mn ) + ord ( \" A \" ) ) ) else : print ( \" C \" ) NEW_LINE"],"bleu":0.15312496685025537,"rouge_l":0.23261257186137393}
{"id":404,"predictions":["import math , sys , bisect , heapq , osfrom collections import defaultdict , Counter , dequefrom itertools import groupby , accumulatefrom functools import lru_cache NEW_LINE"],"references":["sum , xor = map ( int , input ( ) . split ( ) )   andr = ( sum - xor ) \/ 2   if sum < xor or ( sum - xor ) % 2 == 1 or int ( andr ) & xor : print ( 0 ) else : perm = 2 ** bin ( xor ) . count ( \"1\" ) if sum == xor : perm = perm - 2 print ( perm ) NEW_LINE","a , b = [ int ( x ) for x in input ( ) . split ( ) ]     c = ( a - b ) \/ 2 if not c . is_integer ( ) or int ( c ) & b : print ( 0 ) exit ( 0 )   t = 0 while b : NEW_LINE","import sys , os , iofrom sys import stdinfrom math import log , gcd , ceilfrom collections import defaultdict , deque , Counterfrom heapq import heappush , heappopfrom bisect import bisect_left , bisect_rightimport math       alphabets = list ( ' abcdefghijklmnopqrstuvwxyz ' )     def isPrime ( x ) : for i in range ( 2 , x ) : if i * i > x : break if ( x % i == 0 ) : return False return Truedef ncr ( n , r , p ) : num = den = 1 for i in range ( r ) : num = ( num * ( n - i ) ) % p den = ( den * ( i + 1 ) ) % p return ( num * pow ( den , p - 2 , p ) ) % pdef primeFactors ( n ) : l = [ ] while n % 2 == 0 : l . append ( 2 ) n = n \/ 2 for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) : while n % i == 0 : l . append ( int ( i ) ) n = n \/ i if n > 2 : l . append ( n ) return list ( set ( l ) ) def power ( x , y , p ) : res = 1 x = x % p if ( x == 0 ) : return 0 while ( y > 0 ) : if ( ( y & 1 ) == 1 ) : res = ( res * x ) % p y = y >> 1 NEW_LINE","def o ( s , x ) : d = s - x if x << 1 & d or d % 2 or d < 0 : return 0 return 2 ** ( bin ( x ) . count ( '1' ) ) - ( 0 if d else 2 ) s , x = map ( int , input ( ) . split ( ) ) print ( o ( s , x ) ) NEW_LINE","sum , xor = map ( int , input ( ) . split ( ) )   andr = ( sum - xor ) \/ 2   if sum < xor or ( sum - xor ) % 2 == 1 or int ( andr ) & xor : print ( 0 ) else : perm = 2 ** bin ( xor ) . count ( \"1\" ) if sum == xor : perm = perm - 2 print ( perm ) NEW_LINE"],"bleu":0.05390470876053195,"rouge_l":0.10032423288379304}
{"id":405,"predictions":["n = int ( input ( ) ) li = list ( map ( int , input ( ) . split ( \" ▁ \" ) ) ) if n in li : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"references":["import sys   n = int ( sys . stdin . readline ( ) ) digits = [ int ( x ) for x in sys . stdin . readline ( ) . strip ( ) ]   NEW_LINE","m = { 1 : ( 1 , 1 ) , 2 : ( 1 , 2 ) , 3 : ( 1 , 3 ) , 4 : ( 2 , 1 ) , 5 : ( 2 , 2 ) , 6 : ( 2 , 3 ) , 7 : ( 3 , 1 ) , 8 : ( 3 , 2 ) , 9 : ( 3 , 3 ) , 0 : ( 4 , 2 ) }   n = int ( input ( ) )   k = input ( )   p = [ ] for i in k : p . append ( m [ int ( i ) ] )   def valid ( i , j ) : if i >= 1 and i <= 3 and j >= 1 and j <= 3 : return ( True ) return ( i == 4 and j == 2 ) dx = [ - 1 , 1 , 0 , 0 , - 1 , - 1 , 1 , 1 ] dy = [ 0 , 0 , 1 , - 1 , - 1 , 1 , - 1 , 1 ]   for i in range ( len ( dx ) ) : fl = True for z in range ( len ( p ) ) : x = p [ z ] [ 0 ] y = p [ z ] [ 1 ] if not valid ( x + dx [ i ] , y + dy [ i ] ) : fl = False break if fl : print ( \" NO \" ) exit ( 0 ) print ( \" YES \" ) NEW_LINE","n = int ( input ( ) ) l = list ( map ( int , list ( input ( ) ) ) ) x = Trueif n == 1 : print ( \" NO \" ) else : cond1 = False cond2 = False cond3 = False cond4 = False for i in l : c = i if c == 1 or c == 2 or c == 3 : cond1 = True break for i in l : c = i if c == 7 or c == 9 or c == 0 : cond2 = True break for i in l : c = i if c == 0 or c % 3 == 1 : cond3 = True break for i in l : c = i if c == 0 or c % 3 == 0 : cond4 = True break if cond1 and cond2 and cond3 and cond4 : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE","import sys   n = int ( sys . stdin . readline ( ) ) digits = [ int ( x ) for x in sys . stdin . readline ( ) . strip ( ) ]   NEW_LINE","input ( ) s = set ( list ( input ( ) ) ) t = 1 for i in [ { \"1\" , \"9\" } , { \"7\" , \"3\" } , { \"0\" , \"2\" } , { \"0\" , \"1\" } , { \"0\" , \"3\" } , { \"9\" , \"3\" , \"4\" } , { \"1\" , \"7\" , \"6\" } , { \"9\" , \"4\" , \"2\" } , { \"7\" , \"2\" , \"6\" } , { \"7\" , \"2\" , \"9\" } ] : if s & i == i : t = 0 print ( \" YNEOS \" [ t : : 2 ] ) NEW_LINE"],"bleu":0.6789486988400316,"rouge_l":0.5417972831765935}
{"id":406,"predictions":["n , m = map ( int , input ( ) . split ( ) ) arr = [ x for x in range ( 0 , n + 1 ) ] d = 1 for i in range ( m ) : a , b = map ( int , input ( ) . split ( ) ) a , b = arr [ a ] , arr [ b ] while a != arr [ a ] : a = arr [ a ] while b != arr [ a ] : b = arr [ b ] if a != b : arr [ b ] = a d *= 2 print ( d ) NEW_LINE"],"references":["r = lambda : list ( map ( int , input ( ) . split ( ) ) ) arr = r ( ) size = \" S , ▁ M , ▁ L , ▁ XL , ▁ XXL \" . split ( \" , ▁ \" ) NEW_LINE","if __name__ == ' _ _ main _ _ ' : s = [ \" S \" , \" M \" , \" L \" , \" XL \" , \" XXL \" ] a = [ int ( i ) for i in input ( ) . split ( ) ] + [ 0 ] n = int ( input ( ) )   for i in range ( n ) : j = s . index ( input ( ) ) mx = j if not a [ j ] : for k in range ( j - 1 , - 1 , - 1 ) : if a [ k ] : mx = k break for k in range ( j + 1 , 6 ) : if a [ k ] : mx = mx if mx != j and j - mx < k - j else k break a [ mx ] -= 1 print ( \" % s \" % ( s [ mx ] ) ) NEW_LINE","ns , nm , nl , nxl , nxxl = map ( int , input ( ) . split ( ) ) n = int ( input ( ) ) for r in range ( n ) : t = input ( ) if t == \" S \" : if ns != 0 : ns -= 1 print ( \" S \" ) elif nm != 0 : nm -= 1 print ( \" M \" ) elif nl != 0 : nl -= 1 print ( \" L \" ) elif nxl != 0 : nxl -= 1 print ( \" XL \" ) elif nxxl != 0 : nxxl -= 1 print ( \" XXL \" ) if t == \" M \" : if nm != 0 : nm -= 1 print ( \" M \" ) elif nl != 0 : nl -= 1 print ( \" L \" ) elif ns != 0 : ns -= 1 print ( \" S \" ) elif nxl != 0 : nxl -= 1 print ( \" XL \" ) elif nxxl != 0 : nxxl -= 1 print ( \" XXL \" ) if t == \" L \" : if nl != 0 : nl -= 1 print ( \" L \" ) elif nxl != 0 : nxl -= 1 print ( \" XL \" ) elif nm != 0 : nm -= 1 print ( \" M \" ) elif nxxl != 0 : nxxl -= 1 print ( \" XXL \" ) elif ns != 0 : ns -= 1 print ( \" S \" ) if t == \" XL \" : if nxl != 0 : nxl -= 1 print ( \" XL \" ) elif nxxl != 0 : nxxl -= 1 print ( \" XXL \" ) elif nl != 0 : nl -= 1 print ( \" L \" ) elif nm != 0 : nm -= 1 print ( \" M \" ) elif ns != 0 : ns -= 1 print ( \" S \" ) if t == \" XXL \" : if nxxl != 0 : nxxl -= 1 print ( \" XXL \" ) elif nxl != 0 : nxl -= 1 print ( \" XL \" ) elif nl != 0 : nl -= 1 print ( \" L \" ) elif nm != 0 : nm -= 1 print ( \" M \" ) elif ns != 0 : ns -= 1 print ( \" S \" ) NEW_LINE","S , M , L , XL , XXL = [ int ( item ) for item in input ( ) . split ( ' ▁ ' ) ]   models = int ( input ( ) )   for i in range ( models ) : size = input ( ) if size == ' S ' : if S > 0 : print ( ' S ' ) S -= 1 elif M > 0 : print ( ' M ' ) M -= 1 elif L > 0 : print ( ' L ' ) L -= 1 elif XL > 0 : print ( ' XL ' ) XL -= 1 else : print ( ' XXL ' ) XXL -= 1   elif size == ' M ' : if M > 0 : print ( ' M ' ) M -= 1 elif L > 0 : print ( ' L ' ) L -= 1 elif S > 0 : print ( ' S ' ) S -= 1 elif XL > 0 : print ( ' XL ' ) XL -= 1 else : print ( ' XXL ' ) XXL -= 1 elif size == ' L ' : if L > 0 : print ( ' L ' ) L -= 1 elif XL > 0 : print ( ' XL ' ) XL -= 1 elif M > 0 : print ( ' M ' ) M -= 1 elif XXL > 0 : print ( ' XXL ' ) XXL -= 1 else : print ( ' S ' ) S -= 1 elif size == ' XL ' : if XL > 0 : print ( ' XL ' ) XL -= 1 elif XXL > 0 : print ( ' XXL ' ) XXL -= 1 elif L > 0 : print ( ' L ' ) L -= 1 elif M > 0 : print ( ' M ' ) M -= 1 else : print ( ' S ' ) S -= 1 elif size == ' XXL ' : if XXL > 0 : print ( ' XXL ' ) XXL -= 1 elif XL > 0 : print ( ' XL ' ) XL -= 1 elif L > 0 : print ( ' L ' ) L -= 1 elif M > 0 : print ( ' M ' ) M -= 1 else : print ( ' S ' ) S -= 1   NEW_LINE","n = list ( map ( int , input ( ) . split ( ) ) ) a = { ' S ' : 0 , ' M ' : 1 , ' L ' : 2 , ' XL ' : 3 , ' XXL ' : 4 } b = [ ' S ' , ' M ' , ' L ' , ' XL ' , ' XXL ' ] for i in range ( int ( input ( ) ) ) : c = a [ input ( ) ] for i in range ( 5 ) : if c + i < 5 and n [ c + i ] > 0 : print ( b [ c + i ] ) n [ c + i ] -= 1 break elif c - i >= 0 and n [ c - i ] > 0 : print ( b [ c - i ] ) n [ c - i ] -= 1 break NEW_LINE"],"bleu":0.2796186418691629,"rouge_l":0.46942917547568713}
{"id":407,"predictions":["R = lambda : map ( int , input ( ) . split ( ) ) n , m = R ( ) d = dict ( R ( ) ) for i in range ( n ) : r = R ( ) if r [ i ] not in d : d [ r ] = i + 1 else : d [ r [ i ] ] = i + 1 d = dict ( ) for i in d : print ( i , i + 1 ) NEW_LINE"],"references":["for _ in range ( int ( input ( ) ) ) : a , b = map ( int , input ( ) . split ( ) ) x = set ( map ( int , input ( ) . split ( ) ) ) y = set ( map ( int , input ( ) . split ( ) ) ) z = x . intersection ( y ) if len ( z ) : print ( \" YES \" ) print ( 1 , list ( z ) [ 0 ] ) else : print ( \" NO \" ) NEW_LINE","for _ in range ( int ( input ( ) ) ) : n , m = map ( int , input ( ) . split ( ) ) ali = list ( map ( int , input ( ) . split ( ) ) ) bli = list ( map ( int , input ( ) . split ( ) ) ) q = list ( set ( ali ) . intersection ( bli ) ) if ( len ( q ) == 0 ) : print ( \" NO \" ) else : print ( \" YES \" ) print ( 1 , q [ 0 ] ) NEW_LINE","def solve ( ) : ls = input ( ) . split ( ) lst1 = list ( map ( int , input ( ) . split ( ) ) ) lst2 = list ( map ( int , input ( ) . split ( ) ) ) st = { 1 } st . pop ( ) for x in lst1 : st . add ( x ) for x in lst2 : if x in st : print ( \" YES ▁ 1\" , end = \" ▁ \" ) print ( x ) return ' ' print ( \" NO \" )   test = int ( input ( ) ) for i in range ( test ) : solve ( ) NEW_LINE","for _ in range ( int ( input ( ) ) ) : n , m = [ int ( x ) for x in input ( ) . split ( ) ] arr = set ( [ int ( x ) for x in input ( ) . split ( ) ] ) brr = set ( [ int ( x ) for x in input ( ) . split ( ) ] ) x = arr . intersection ( brr ) if ( len ( x ) == 0 ) : print ( \" NO \" ) else : print ( \" YES \\n { } ▁ { } \" . format ( 1 , list ( x ) [ 0 ] ) ) NEW_LINE","def fun ( ls , ms ) : st = set ( ls ) for i in ms : if i in st : print ( ' Yes ' ) print ( 1 , i ) return print ( ' No ' )                         T = int ( input ( ) ) for i in range ( T ) : NEW_LINE"],"bleu":0.3320316886416484,"rouge_l":0.36928469013860127}
{"id":408,"predictions":["\"\"\" ▁ ▁ ▁ ▁ https : \/ \/ codeforces . com \/ problemset \/ problem \/ problem \/ B \"\"\" import fileinput   def sommeColonne ( t , col ) : res = 0 for i in range ( 3 ) : res += t [ col ] [ col ] return res   def sommeLigne ( t , lig ) : res = 0 for i in range ( 3 ) : res += t [ lig ] [ i ] return res   def sommeDiag1 ( t ) : return t [ 0 ] [ 0 ] + t [ 1 ] [ 1 ] + t [ 2 ] [ 2 ]   def sommeDiag2 ( t ) : return t [ 0 ] [ 2 ] + t [ 1 ] [ 1 ] + t [ 2 ] [ 2 ]   def valide ( v ) : return v >= 1 and v <= 100000   def cherche ( t ) : \"\"\" ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Recherche ▁ par ▁ force ▁ brute . . . ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Un ▁ candidat ▁ est ▁ un ▁ triplet ▁ de ▁ nombres ▁ ( la ▁ diagonale ) . ▁ ▁ ▁ ▁ \"\"\" NEW_LINE"],"references":["def solution ( ) : st1 = input ( ) st2 = input ( )   dicty1 = { } dicty2 = { } LET = ' ABCDEFGHIJKLMNOPQRSTUVWXYZ ' LET += LET . lower ( )   for c in LET : dicty1 [ c ] = 0 dicty2 [ c ] = 0   for c in st1 : if c != ' ▁ ' : dicty1 [ c ] += 1   for c in st2 : if c != ' ▁ ' : dicty2 [ c ] += 1     for c in dicty2 : if dicty2 [ c ] > dicty1 [ c ] : print ( ' NO ' ) return print ( ' YES ' ) \t         return         solution ( ) NEW_LINE","heading = input ( ) text = input ( ) freq = dict ( ) l = len ( text ) for i in heading : if i in freq . keys ( ) : freq [ i ] += 1 else : freq [ i ] = 1 NEW_LINE","head = input ( ) text = input ( ) head_m = { t : head . count ( t ) for t in head . strip ( ) . replace ( ' ▁ ' , ' ' ) . replace ( ' \\t ' , ' ' ) } IsValid = Truefor i in text . strip ( ) . replace ( ' ▁ ' , ' ' ) . replace ( ' \\t ' , ' ' ) : NEW_LINE","h = input ( ) l = input ( ) h = h . replace ( ' ▁ ' , ' ' ) h = list ( h ) l = l . replace ( ' ▁ ' , ' ' ) l = list ( l ) flag = Truewhile len ( h ) > 0 and len ( l ) > 0 and flag == True : for i in l : l . remove ( i ) if i in h : h . remove ( i ) else : flag = False print ( ' NO ' ) break   if len ( l ) > 0 and flag == True : flag = False print ( ' NO ' ) flag = Falseif flag == True : print ( ' YES ' ) NEW_LINE","from collections import Counter   s = input ( ) a = input ( )   arr = Counter ( s ) brr = Counter ( a ) f = True   for i in brr . keys ( ) : if i == ' ▁ ' : continue if arr [ i ] < brr [ i ] :   f = False break   print ( \" YES \" if f else \" NO \" ) NEW_LINE"],"bleu":0.03851391119035834,"rouge_l":0.2807079646017699}
{"id":409,"predictions":["from collections import defaultdict , deque , Counterfrom sys import stdin , stdoutfrom heapq import heappush , heappopimport mathimport ioimport osimport mathimport bisect   NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) d = { } ans = cnt = 0 for i in map ( int , input ( ) . split ( ) ) : d [ i ] = d . get ( i , 0 ) + 1 for i in range ( 1 , m + 1 ) : cnt = 0 for v in d . items ( ) : cnt += v [ 1 ] \/\/ i if cnt >= n : ans = iprint ( ans ) NEW_LINE","people , n = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) a . sort ( ) d = { } tmp = [ ] for i in range ( n ) : if a [ i ] in d : d [ a [ i ] ] += 1 else : d [ a [ i ] ] = 1 d1 = { } for i in d : if d [ i ] in d1 : d1 [ d [ i ] ] += 1 else : d1 [ d [ i ] ] = 1 tmp . append ( d [ i ] ) tmp . sort ( ) ans = 0 for i in range ( 1 , 10001 ) : x = people try : x -= d1 [ i ] except : pass for j in d1 : if j > i : x -= ( j \/\/ i ) * d1 [ j ] if x <= 0 : ans = max ( ans , i ) print ( ans ) NEW_LINE","from collections import Countern , m = map ( int , input ( ) . split ( ) ) c = Counter ( input ( ) . split ( ) ) . values ( ) d = 1 while sum ( ci \/\/ d for ci in c ) >= n : d += 1 print ( d - 1 )   NEW_LINE","from collections import * R = lambda : map ( int , input ( ) . split ( ) ) n , m = R ( ) a = Counter ( R ( ) ) . values ( ) i = 1 while sum ( x \/\/ i for x in a ) >= n : i += 1 print ( i - 1 ) NEW_LINE"],"bleu":0.023707735236185867,"rouge_l":0.14759764949879017}
{"id":410,"predictions":["import sys NEW_LINE def main ( ) : NEW_LINE INDENT input = sys . stdin . readline NEW_LINE A , B , C = map ( int , input ( ) . split ( ) ) NEW_LINE for i in range ( 1 , B + 1 ) : NEW_LINE INDENT if ( A * i ) % B == 0 : NEW_LINE INDENT return ' YES ' NEW_LINE DEDENT DEDENT return ' NO ' NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( main ( ) ) NEW_LINE DEDENT"],"references":["a , b , c = map ( int , input ( ) . split ( ) )   while c >= 0 : if c % b == 0 : print ( ' Yes ' ) break c -= aelse : print ( ' No ' ) NEW_LINE","a , b , c = map ( int , input ( ) . split ( ) )   sums = [ 1 ] + [ 0 for i in range ( c ) ] for var in ( a , b ) : for i in range ( c - var + 1 ) : sums [ i + var ] += sums [ i ]   print ( \" Yes \" ) if sums [ c ] else print ( \" No \" ) NEW_LINE","a , b , c = map ( int , input ( ) . split ( ) ) g = c \/\/ min ( a , b ) + 1 flag = 0 for i in range ( g + 1 ) : for j in range ( g + 1 ) : if a * i + b * j == c : flag = 1 breakif flag : print ( \" Yes \" ) else : print ( \" No \" ) NEW_LINE","a , b , c = map ( int , input ( ) . split ( ) ) ans = \" No \" for i in range ( c \/\/ a + 1 ) : if ( c - a * i ) % b == 0 : ans = \" Yes \" breakprint ( ans ) NEW_LINE","a , b , c = map ( int , input ( ) . split ( ) )   for i in range ( 1 + c \/\/ a ) : if ( c - i * a ) % b == 0 : print ( ' Yes ' ) exit ( 0 )   print ( ' No ' ) NEW_LINE"],"bleu":0.274651273853503,"rouge_l":0.4980661796304255}
{"id":411,"predictions":["t = int ( input ( ) ) for i in range ( t ) : n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) ans = [ ] a . sort ( ) for i in range ( n ) : if i == 0 : ans . append ( a [ i ] ) ans . append ( a [ i ] ) else : ans [ a [ i ] ] = 0 NEW_LINE"],"references":["for s in [ * open ( 0 ) ] [ 2 : : 2 ] : NEW_LINE INDENT b = [ 0 ] ; NEW_LINE r = 0 NEW_LINE for x in s . split ( ) : b += - 1 , ; b [ max ( - len ( b ) , ~ int ( x ) ) ] += 1 NEW_LINE for x in b [ : - 1 ] : r += x ; print ( + ( r > 0 ) ) NEW_LINE DEDENT","T = int ( input ( ) ) NEW_LINE for t in range ( T ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = [ 0 ] * n NEW_LINE b [ n - 1 ] = a [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT b [ i ] = max ( b [ i + 1 ] - 1 , a [ i ] ) NEW_LINE DEDENT print ( \" ▁ \" . join ( [ ( \"0\" , \"1\" ) [ e > 0 ] for e in b ] ) ) NEW_LINE DEDENT","for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT b = max ( b , a [ i ] ) NEW_LINE a [ i ] = 1 if b > 0 else 0 NEW_LINE b -= 1 NEW_LINE DEDENT print ( * a ) NEW_LINE DEDENT","for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = [ int ( y ) for y in input ( ) . split ( ) ] NEW_LINE mn = 0 NEW_LINE b = [ 0 ] * n NEW_LINE for idx , i in enumerate ( a [ : : - 1 ] ) : NEW_LINE INDENT if mn < i : mn = i NEW_LINE if mn != 0 : NEW_LINE INDENT b [ n - 1 - idx ] = 1 NEW_LINE mn -= 1 NEW_LINE DEDENT DEDENT print ( * b , end = ' \\n ' ) NEW_LINE DEDENT","for s in [ * open ( 0 ) ] [ 2 : : 2 ] : NEW_LINE INDENT a = s . split ( ) ; NEW_LINE b = [ 0 ] ; NEW_LINE r = 0 NEW_LINE for x in a : b += - 1 , ; b [ max ( - len ( b ) , ~ int ( x ) ) ] += 1 NEW_LINE for x in b [ : - 1 ] : r += x ; print ( + ( r > 0 ) ) NEW_LINE DEDENT"],"bleu":0.5149909878341152,"rouge_l":0.5987534835193499}
{"id":412,"predictions":["import math , sys , bisect , heapq , osfrom collections import defaultdict , Counter , dequefrom itertools import groupby , accumulatefrom functools import lru_cache NEW_LINE"],"references":["import sys   def main ( ) :   for _ in range ( int ( sys . stdin . readline ( ) . strip ( ) ) ) : n = int ( sys . stdin . readline ( ) . strip ( ) ) arr = list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) i = 0 while i < n and arr [ i ] >= i : i += 1 j = n - 1 while j >= 0 and arr [ j ] >= ( n - j - 1 ) : j -= 1 if ( i - j ) == 1 and arr [ i ] == arr [ j ] : print ( ' No ' ) elif i > j : print ( \" Yes \" ) else : print ( \" No \" )   main ( ) NEW_LINE","for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) ; arr = list ( map ( int , input ( ) . split ( ) ) ) if n % 2 == 1 : count = 0 arr1 = [ 0 ] * n ; i = 0 ; j = n - 1 ; flag = True while i <= j : arr1 [ i ] = count arr1 [ j ] = count count += 1 ; i += 1 ; j -= 1 NEW_LINE","for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) ; arr = list ( map ( int , input ( ) . split ( ) ) ) ; k = ( n ) \/\/ 2 ; flag = True maxx = max ( arr [ n \/\/ 2 ] , arr [ n \/\/ 2 - 1 ] ) minn = min ( arr [ n \/\/ 2 ] , arr [ n \/\/ 2 - 1 ] ) if n % 2 == 0 and ( maxx < k or minn < k - 1 ) : print ( \" NO \" ) ; continue for i in range ( ( n + 1 ) \/\/ 2 ) : if arr [ i ] >= i and arr [ n - i - 1 ] >= i : continue else : print ( \" NO \" ) ; flag = False ; break if flag : print ( \" YES \" )   NEW_LINE","from math import gcdimport bisectimport collectionsimport copyimport functoolsimport heapqimport itertoolsimport mathimport randomimport reimport sysimport timeimport stringfrom typing import Listsys . setrecursionlimit ( 99999 )   t , = map ( int , input ( ) . split ( ) ) for _ in range ( t ) : n , = map ( int , input ( ) . split ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) l = 0 for i in range ( n ) : if arr [ i ] >= i : l += 1 else : break arr = arr [ : : - 1 ] r = 0 for i in range ( n ) : if arr [ i ] >= i : r += 1 else : break if l + r > n : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE","for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) ; arr = list ( map ( int , input ( ) . split ( ) ) ) ; k = ( n ) \/\/ 2 ; flag = True maxx = max ( arr [ n \/\/ 2 ] , arr [ n \/\/ 2 - 1 ] ) minn = min ( arr [ n \/\/ 2 ] , arr [ n \/\/ 2 - 1 ] ) if n % 2 == 0 and ( maxx < k or minn < k - 1 ) : print ( \" NO \" ) ; continue for i in range ( ( n + 1 ) \/\/ 2 ) : if arr [ i ] >= i and arr [ n - i - 1 ] >= i : continue else : print ( \" NO \" ) ; flag = False ; break if flag : print ( \" YES \" ) NEW_LINE"],"bleu":0.0051300110840758915,"rouge_l":0.06624263108904747}
{"id":413,"predictions":["import sys , string , heapq   a , b = list ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( \" : \" ) ) min_val = int ( sys . stdin . readline ( ) . rstrip ( ) ) res = { ' : ' : ' : ' : ' , ' : ' : '2' , ' : ' : ' : '1' , ' : ' : ' : ' } if a == b : res1 = - 1 else : res1 += '0' * ( a - b ) print ( res1 , res2 ) NEW_LINE"],"references":["import syss1 , s2 = input ( ) . split ( \" : \" ) def convert ( n , base ) : ans = 0 for i in range ( len ( n ) ) : x = 0 if n [ i ] . isalpha ( ) : x = int ( ord ( n [ i ] ) - ord ( ' A ' ) + 10 ) else : x = int ( n [ i ] ) ans += x * pow ( base , len ( n ) - i - 1 ) return answork = [ ] minm = 0 for c in s1 + s2 : if c . isalpha ( ) : minm = max ( minm , ord ( c ) - ord ( ' A ' ) + 10 ) else : minm = max ( minm , int ( c ) )   for base in range ( max ( minm + 1 , 2 ) , 60 ) : if convert ( s1 , base ) < 24 and convert ( s2 , base ) < 60 : work . append ( base ) else : breakif len ( work ) == 0 : print ( 0 ) elif ( len ( s1 ) == 1 or s1 [ : len ( s1 ) - 1 ] == '0' * ( len ( s1 ) - 1 ) ) and ( len ( s2 ) == 1 or s2 [ : len ( s2 ) - 1 ] == '0' * ( len ( s2 ) - 1 ) ) : print ( - 1 ) else : print ( \" ▁ \" . join ( map ( str , work ) ) ) NEW_LINE","def val ( c ) : if ' A ' <= c <= ' Z ' : return ord ( c ) - 65 + 10 else : return int ( c )   def calc ( h , b ) : ans = 0 i = 0 for c in h [ : : - 1 ] : v = val ( c ) ans += int ( v ) * ( b ** i ) i += 1 return ans     h , m = [ x for x in input ( ) . split ( \" : \" ) ]   min_base = - 1 for c in h : min_base = max ( min_base , val ( c ) + 1 ) for c in m : min_base = max ( min_base , val ( c ) + 1 )   NEW_LINE","import sysfrom functools import lru_cache , cmp_to_keyfrom heapq import merge , heapify , heappop , heappushfrom math import ceil , floor , gcd , fabs , factorial , fmod , sqrt , inf , log , pi , sinfrom collections import defaultdict as dd , deque , Counter as Cfrom itertools import combinations as comb , permutations as permfrom bisect import bisect_left as bl , bisect_right as br , bisectfrom time import perf_counterfrom fractions import Fraction NEW_LINE","numbers = { '0' : 0 , '1' : 1 , '2' : 2 , '3' : 3 , '4' : 4 , '5' : 5 , '6' : 6 , '7' : 7 , '8' : 8 , '9' : 9 , ' A ' : 10 , ' B ' : 11 , ' C ' : 12 , ' D ' : 13 , ' E ' : 14 , ' F ' : 15 , ' G ' : 16 , ' H ' : 17 , ' I ' : 18 , ' J ' : 19 , ' K ' : 20 , ' L ' : 21 , ' M ' : 22 , ' N ' : 23 , ' O ' : 24 , ' P ' : 25 , ' Q ' : 26 , ' R ' : 27 , ' S ' : 28 , ' T ' : 29 , ' U ' : 30 , ' V ' : 31 , ' W ' : 32 , ' X ' : 33 , ' Y ' : 34 , ' Z ' : 35 }   def ConvertToDecimal ( number , base ) : newnumber = 0 for digit in range ( - 1 , ( 0 - len ( number ) ) - 1 , - 1 ) : if ( numbers [ number [ digit ] ] >= int ( base ) ) : return - 1 newnumber += numbers [ number [ digit ] ] * ( int ( base ) ** ( 0 - digit - 1 ) ) return newnumber   a , b = [ x for x in input ( ) . split ( ' : ' ) ] didmake = Falseif ( 0 <= ConvertToDecimal ( a , 60 ) <= 23 and 0 <= ConvertToDecimal ( b , 60 ) <= 59 ) : print ( - 1 ) didmake = Trueelse : for base in range ( 2 , 60 ) : if ( 0 <= ConvertToDecimal ( a , base ) <= 23 and 0 <= ConvertToDecimal ( b , base ) <= 59 ) : print ( base , end = \" ▁ \" ) didmake = True if not didmake : print ( 0 ) NEW_LINE"],"bleu":0.24050250446722551,"rouge_l":0.24888470419440897}
{"id":414,"predictions":["n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) p = a [ 0 ] i = 0 j = n - 1 while i < n - 1 : if a [ i ] == a [ j ] : p -= 1 i += 1 else : breakprint ( n - p , n ) NEW_LINE"],"references":["def solution ( ) : n , k = map ( int , input ( ) . split ( ) )   arr = list ( map ( int , input ( ) . split ( ) ) )   k -= 1 num = arr [ k ] for i in range ( k , n ) : if arr [ i ] != num : print ( - 1 ) return   curr = k - 1 while curr >= 0 and arr [ curr ] == num : curr -= 1   \t   print ( curr + 1 )     return         solution ( ) NEW_LINE","n , k = map ( int , input ( ) . split ( ) ) x = [ * map ( int , input ( ) . split ( ) ) ] f = x [ k - 1 ] if len ( set ( x [ k - 1 : ] ) ) != 1 : print ( - 1 ) elif k == 1 or len ( set ( x ) ) == 1 : print ( 0 ) else : print ( max ( [ i for i , j in enumerate ( x ) if j != f ] ) + 1 )   NEW_LINE","import sys   inp = sys . stdin . readlines ( ) ; ii = 0 out = [ ]   n , k = map ( int , inp [ ii ] . split ( ) ) ii += 1   nums = [ int ( bruh ) for bruh in inp [ ii ] . split ( ) ] ii += 1   if len ( set ( nums ) ) == 1 : print ( 0 ) exit ( )   bruhytle = list ( range ( k - 1 ) ) [ : : - 1 ] if len ( set ( nums [ k - 1 : ] ) ) == 1 : for num in bruhytle : if nums [ num ] != nums [ k - 1 ] : print ( num + 1 ) exit ( ) else : print ( - 1 )   NEW_LINE","n , k = [ int ( x ) for x in input ( ) . split ( ) ] last = 0 cnt = 1 ai = [ int ( x ) for x in input ( ) . split ( ) ] for i in range ( n ) : NEW_LINE"],"bleu":0.5085987288252183,"rouge_l":0.550229925716307}
{"id":415,"predictions":["n = int ( input ( ) ) s = input ( ) a = s . count ( ' U ' ) b = s . count ( ' D ' ) c = s . count ( ' L ' ) d = s . count ( ' R ' )   print ( ( min ( a , b ) + min ( c , d ) ) * 2 ) NEW_LINE"],"references":["a = input ( ) b = input ( ) c = 8   print ( max ( max ( ord ( a [ 0 ] ) , ord ( b [ 0 ] ) ) - min ( ord ( a [ 0 ] ) , ord ( b [ 0 ] ) ) , max ( int ( a [ 1 ] ) , int ( b [ 1 ] ) ) - min ( int ( a [ 1 ] ) , int ( b [ 1 ] ) ) ) ) d = ord ( a [ 0 ] ) - ord ( b [ 0 ] ) e = int ( a [ 1 ] ) - int ( b [ 1 ] ) while c > 0 : c -= 1 if d < 0 : if d != 0 : d += 1 print ( \" R \" , end = \" \" ) if d > 0 : print ( \" L \" , end = \" \" ) d -= 1 if e < 0 : print ( \" U \" , end = \" \" ) e += 1 if e > 0 : e -= 1 print ( \" D \" , end = \" \" ) print ( )       NEW_LINE","a = list ( input ( ) ) b = list ( input ( ) )     x = \" D \" if a [ 1 ] > b [ 1 ] else ' U ' y = \" L \" if a [ 0 ] > b [ 0 ] else ' R '     m = abs ( ord ( a [ 0 ] ) - ord ( b [ 0 ] ) ) n = abs ( ord ( a [ 1 ] ) - ord ( b [ 1 ] ) )     c = max ( m , n ) print ( c ) j = y + x   for _ in range ( min ( m , n ) ) : print ( j ) mini = min ( m , n )   m -= minin -= mini     for _ in range ( m ) : print ( y ) for _ in range ( n ) : print ( x ) NEW_LINE","map1 = { ' a ' : 1 , ' b ' : 2 , ' c ' : 3 , ' d ' : 4 , ' e ' : 5 , ' f ' : 6 , ' g ' : 7 , ' h ' : 8 }   def path ( p , q , p1 , p2 ) : print ( p + q ) for i in range ( p ) : print ( p1 ) for i in range ( q ) : print ( p2 )   s = input ( ) t = input ( ) x = map1 [ s [ 0 ] ] - map1 [ t [ 0 ] ] y = int ( s [ 1 ] ) - int ( t [ 1 ] )   if x > 0 : if y > 0 : z = abs ( x - y ) if x < y : path ( x , z , ' LD ' , ' D ' ) else : path ( y , z , ' LD ' , ' L ' ) elif y < 0 : y = abs ( y ) z = abs ( x - y ) if x < y : path ( x , z , ' LU ' , ' U ' ) else : path ( y , z , ' LU ' , ' L ' ) else : path ( y , x , None , ' L ' ) elif x < 0 : x = abs ( x ) if y > 0 : z = abs ( x - y ) if x < y : path ( x , z , ' RD ' , ' D ' ) else : path ( y , z , ' RD ' , ' R ' ) elif y < 0 : y = abs ( y ) z = abs ( x - y ) if x < y : path ( x , z , ' RU ' , ' U ' ) else : path ( y , z , ' RU ' , ' R ' ) else : path ( y , x , None , ' R ' ) else : if y > 0 : path ( x , y , None , ' D ' ) elif y < 0 : path ( x , abs ( y ) , None , ' U ' ) else : print ( 0 ) NEW_LINE","s = input ( ) sx = ord ( s [ 0 ] ) - ord ( ' a ' ) + 1 sy = 9 - int ( s [ 1 ] ) t = input ( ) tx = ord ( t [ 0 ] ) - ord ( ' a ' ) + 1 ty = 9 - int ( t [ 1 ] )   diff_row = ty - sydiff_col = tx - sxpath = ' '   if diff_row >= 0 and diff_col >= 0 : path += ' RD \\n ' * min ( diff_row , diff_col ) diff_row , diff_col = diff_row - min ( diff_row , diff_col ) , diff_col - min ( diff_row , diff_col ) if diff_row < 0 and diff_col >= 0 : path += ' RU \\n ' * min ( - diff_row , diff_col ) diff_row , diff_col = diff_row + min ( - diff_row , diff_col ) , diff_col - min ( - diff_row , diff_col ) if diff_row >= 0 and diff_col < 0 : path += ' LD \\n ' * min ( diff_row , - diff_col ) diff_row , diff_col = diff_row - min ( diff_row , - diff_col ) , diff_col + min ( diff_row , - diff_col ) if diff_row < 0 and diff_col < 0 : path += ' LU \\n ' * min ( - diff_row , - diff_col ) diff_row , diff_col = diff_row + min ( - diff_row , - diff_col ) , diff_col + min ( - diff_row , - diff_col )   if diff_row == 0 : if diff_col >= 0 : path += ' R \\n ' * diff_col else : path += ' L \\n ' * - diff_colelse : if diff_row >= 0 : path += ' D \\n ' * diff_row else : path += ' U \\n ' * - diff_row   step = len ( list ( path . split ( ) ) ) print ( step ) print ( path ) NEW_LINE","start = input ( ) end = input ( )   alist = ( ' a ' , ' b ' , ' c ' , ' d ' , ' e ' , ' f ' , ' g ' , ' h ' )   startx = alist . index ( start [ 0 ] ) + 1 endx = alist . index ( end [ 0 ] ) + 1 starty = int ( start [ 1 ] ) endy = int ( end [ 1 ] )   xdirection = 0 ydirection = 0   xtimes = 0 ytimes = 0   outputlist = [ ]   if startx > endx : xdirection = ' L ' xtimes = startx - endxelif startx < endx : xdirection = ' R ' xtimes = endx - startxif starty > endy : ydirection = ' D ' ytimes = starty - endyelif starty < endy : ytimes = endy - starty ydirection = ' U '     if xtimes == ytimes : for x in range ( xtimes ) : outputlist . append ( xdirection + ydirection ) elif xtimes < ytimes : for x in range ( xtimes ) : outputlist . append ( xdirection + ydirection ) for x in range ( ytimes - xtimes ) : outputlist . append ( ydirection ) elif xtimes > ytimes : for x in range ( ytimes ) : outputlist . append ( xdirection + ydirection ) for x in range ( xtimes - ytimes ) : outputlist . append ( xdirection ) outputlist . insert ( 0 , len ( outputlist ) ) for y in outputlist : print ( y )         NEW_LINE"],"bleu":0.11409762251934176,"rouge_l":0.2927014058422426}
{"id":416,"predictions":["import matha , b = map ( int , input ( ) . split ( ) ) print ( math . gcd ( a , b ) ) NEW_LINE"],"references":["def f ( t ) : z = 1.000000011 p = 1 while t : if t % 2 : t -= 1 p *= z else : t \/\/= 2 z *= z return pn , t = map ( int , input ( ) . split ( ) ) print ( n * f ( t ) ) NEW_LINE","a , b = map ( int , input ( ) . split ( ) ) print ( a * ( 1.000000011 ) ** b ) NEW_LINE","n , x = map ( int , input ( ) . split ( ) ) print ( n * ( 1.000000011 ** x ) ) NEW_LINE","n , t = map ( int , input ( ) . split ( ) ) x = 1.000000011 print ( n * x ** t ) NEW_LINE","n , t = map ( int , input ( ) . split ( ) ) print ( n * ( 1.000000011 ** t ) ) NEW_LINE"],"bleu":0.6823216626046203,"rouge_l":0.7548615203299941}
{"id":417,"predictions":["n , m = map ( int , input ( ) . split ( ) ) arr0 = list ( map ( int , input ( ) . split ( ) ) ) arr = arr0 [ : ] mi_r = 0 ma_r = 0 for i in range ( n ) : mi = 10000000000000 mi_idx = - 10 for j in range ( m ) : if ( arr [ j ] < mi and arr [ j ] > 0 ) : mi_idx = j mi = arr [ j ] arr [ mi_idx ] -= 1 mi_r += mi   arr = arr0 [ : ] for i in range ( n ) : ma = - 1 ma_idx = - 1 for j in range ( m ) : if ( arr [ j ] > ma and arr [ j ] > 0 ) : ma_idx = j ma = arr [ j ] arr [ ma_idx ] -= 1 ma_r += maprint ( ma_r , mi_r ) NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) ; a = list ( map ( int , input ( ) . split ( ) ) )   b = [ ( list ( map ( int , input ( ) . split ( ) ) ) ) for i in range ( m ) ]   count = 0 for i in range ( m ) : sum = 0 ; for j in range ( b [ i ] [ 0 ] - 1 , b [ i ] [ 1 ] ) : sum += a [ j ]   if ( sum > 0 ) : count += sum     print ( count ) NEW_LINE","def mex ( lst , blanck ) : ans = 0 for i in blanck : ans = max ( ans , ans + sum ( lst [ i [ 0 ] : i [ 1 ] + 1 ] ) ) return ans   a , b = map ( int , input ( ) . strip ( ) . split ( ) ) blanck = [ ] lst = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) for i in range ( b ) : x , y = map ( int , input ( ) . strip ( ) . split ( ) ) blanck . append ( [ x - 1 , y - 1 ] ) print ( mex ( lst , blanck ) ) NEW_LINE","n , m = map ( int , input ( ) . strip ( ) . split ( ' ▁ ' ) ) lst = list ( map ( int , input ( ) . strip ( ) . split ( ' ▁ ' ) ) ) s = 0 for i in range ( m ) : l , r = map ( int , input ( ) . strip ( ) . split ( ' ▁ ' ) ) s1 = 0 s1 = sum ( lst [ l - 1 : r ] ) if s1 > 0 : s += s1print ( s ) NEW_LINE","n , q = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = [ a [ 0 ] ] for i in range ( 1 , n ) : b . append ( b [ i - 1 ] + a [ i ] )   ans = 0 for i in range ( q ) : x , y = map ( int , input ( ) . split ( ) ) temp = b [ y - 1 ] if x != 1 : temp -= b [ x - 2 ] ans = max ( ans , ans + temp ) print ( ans ) NEW_LINE","n , q = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( 1 , n ) : a [ i ] = ( a [ i - 1 ] + a [ i ] )   ans = 0 for i in range ( q ) : x , y = map ( int , input ( ) . split ( ) ) temp = a [ y - 1 ] if x != 1 : temp -= a [ x - 2 ] ans = max ( ans , ans + temp ) print ( ans ) NEW_LINE"],"bleu":0.3493409864384802,"rouge_l":0.49089080138593943}
{"id":418,"predictions":["def almostprime ( val ) : a = 0 l = 0 b = [ ] d = [ ] for i in range ( 2 , val ) : a = 0 for j in range ( 2 , i ) : if ( i % j != 0 ) : pass else : a += 1 if a == 0 : b . append ( i ) for i in range ( 2 , val ) : c = 0 for j in range ( 0 , len ( b ) ) : if ( i % b [ j ] == 0 ) : c += 1 if c == 2 : d . append ( i ) print ( len ( d ) )                           almostprime ( int ( input ( ) ) + 1 ) NEW_LINE"],"references":["n = int ( input ( ) ) m = list ( map ( int , input ( ) . split ( ) ) ) gc = m [ 0 ] import mathfor i in range ( 1 , n ) : gc = math . gcd ( gc , m [ i ] ) k = max ( m ) prime = [ 0 ] * ( k + 1 ) pfac = [ 0 ] * ( k + 1 ) for i in range ( 2 , k + 1 ) : if prime [ i ] == 0 : for j in range ( i * i , k + 1 , i ) : prime [ j ] = ifor i in range ( 1 , k + 1 ) : if not prime [ i ] : prime [ i ] = ifor i in range ( n ) : v = m [ i ] \/\/ gc while v > 1 : fac = prime [ v ] pfac [ fac ] += 1 while v % fac == 0 : v \/\/= facma = 0 ma = max ( pfac ) if ma : print ( n - ma ) else : print ( - 1 ) NEW_LINE","n = int ( input ( ) ) m = list ( map ( int , input ( ) . split ( ) ) ) gc = m [ 0 ] import mathfor i in range ( 1 , n ) : gc = math . gcd ( gc , m [ i ] ) k = max ( m ) prime = [ 0 ] * ( k + 1 ) pfac = [ 0 ] * ( k + 1 ) for i in range ( 2 , k + 1 ) : if prime [ i ] == 0 : for j in range ( i * i , k + 1 , i ) : prime [ j ] = ifor i in range ( 1 , k + 1 ) : if not prime [ i ] : prime [ i ] = ifor i in range ( n ) : v = m [ i ] \/\/ gc while v > 1 : fac = prime [ v ] pfac [ fac ] += 1 while v % fac == 0 : v \/\/= facma = 0 ma = max ( pfac ) if ma : print ( n - ma ) else : print ( - 1 ) NEW_LINE"],"bleu":0.15056772873030982,"rouge_l":0.3177884211410806}
{"id":419,"predictions":["import mathfrom math import gcd , floor , sqrt , logdef iin ( ) : return int ( input ( ) ) def sin ( ) : return input ( ) . strip ( ) def listin ( ) : return list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) def liststr ( ) : return list ( map ( str , input ( ) . strip ( ) . split ( ) ) ) def ceill ( x ) : return int ( x ) if ( x == int ( x ) ) else int ( x ) + 1 def ceilldiv ( x , d ) : x \/\/ d if ( x % d == 0 ) : return x \/\/ d + 1 def LCM ( a , b ) : return ( a * b ) \/\/ gcd ( a , b )     def solve ( ) : n , k = listin ( ) a = listin ( ) z = [ i for i in range ( 1 , n * k + 1 ) if i not in a ] temp = 0 for j in range ( k ) : print ( a [ j ] , end = \" ▁ \" ) for i in range ( temp , n + temp - 1 ) : print ( z [ i ] , end = ' ▁ ' ) temp += n - 1 print ( ) t = 1 NEW_LINE"],"references":["import mathn , k = map ( int , input ( ) . split ( ) )   result = [ ]   while ( n % 2 == 0 ) : result . append ( 2 ) n = n \/\/ 2   NEW_LINE","n , k = map ( int , input ( ) . split ( ) ) arr = [ ] stor = [ ] i = 1 for j in range ( 2 , n , 1 ) : if n % j == 0 : while n % j == 0 and i <= k - 1 : arr . append ( j ) n \/\/= j i += 1   for l in range ( k - 1 , k ) : if n != 1 : arr . append ( n )           if len ( arr ) < k : print ( \" - 1\" ) else : print ( * arr ) NEW_LINE","import sysfrom math import sqrt   def isPrime ( n ) : i = 2 while i * i <= n :   if n % i == 0 : return False i += 1 return True   def primes ( n ) : arr = [ ] nums = 0 for i in range ( 2 , 10000 ) : NEW_LINE","import mathn , k = map ( int , input ( ) . split ( ) ) if k == 1 : print ( n ) exit ( 0 ) a , k = [ ] , k - 1 for i in range ( 2 , math . ceil ( math . sqrt ( n ) ) + 1 ) : while n % i == 0 : a . append ( i ) k -= 1 n \/\/= i if k == 0 : if n == 1 : print ( - 1 ) else : print ( * a , n ) exit ( 0 ) print ( - 1 ) NEW_LINE","import mathn , k = map ( int , input ( ) . split ( ) ) factors = [ n ] flag = 0 NEW_LINE"],"bleu":0.16244189224319344,"rouge_l":0.38039197299324834}
{"id":420,"predictions":["ll = lambda : map ( int , input ( ) . split ( ) ) t = lambda : int ( input ( ) ) ss = lambda : input ( ) lx = lambda x : map ( int , input ( ) . split ( x ) ) NEW_LINE"],"references":["for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) li = list ( map ( int , input ( ) ) ) od = 0 ev = 0 res = [ ] cnt = 0 for i in range ( n ) : if li [ i ] % 2 == 0 : res . append ( li [ i ] ) else : cnt += 1 res . append ( li [ i ] ) if cnt == 2 : break if res [ - 1 ] % 2 != 0 and cnt >= 2 : print ( * res , sep = ' ' ) else : print ( - 1 )   NEW_LINE","odd = [ '1' , '3' , '5' , '7' , '9' ] for i in range ( int ( input ( ) ) ) : size = int ( input ( ) ) nums = input ( ) x = [ j for j in nums if j in odd ] if len ( x ) <= 1 : print ( - 1 ) else : print ( ' ' . join ( x [ : 2 ] ) ) NEW_LINE"],"bleu":0.1898884771336101,"rouge_l":0.4303857008466604}
{"id":421,"predictions":["def mingrid ( ) : for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) segcost = input ( ) . split ( ) minodd = int ( segcost [ 0 ] ) mineven = int ( segcost [ 1 ] ) sumodd = minodd sumeven = mineven codd = 1 ceven = 1 res = sumodd + minodd * ( n - codd ) + sumeven + mineven * ( n - ceven ) for i in range ( 2 , n ) : now = int ( segcost [ i ] ) if ( i + 1 ) % 2 : NEW_LINE"],"references":["import osimport sysfrom io import BytesIO , IOBaseBUFSIZE = 8192 class FastIO ( IOBase ) : newlines = 0 def __init__ ( self , file ) : self . _fd = file . fileno ( ) self . buffer = BytesIO ( ) self . writable = \" x \" in file . mode or \" r \" not in file . mode self . write = self . buffer . write if self . writable else None def read ( self ) : while True : b = os . read ( self . _fd , max ( os . fstat ( self . _fd ) . st_size , BUFSIZE ) ) if not b : break ptr = self . buffer . tell ( ) self . buffer . seek ( 0 , 2 ) , self . buffer . write ( b ) , self . buffer . seek ( ptr ) self . newlines = 0 return self . buffer . read ( ) def readline ( self ) : while self . newlines == 0 : b = os . read ( self . _fd , max ( os . fstat ( self . _fd ) . st_size , BUFSIZE ) ) self . newlines = b . count ( b \" \\n \" ) + ( not b ) ptr = self . buffer . tell ( ) self . buffer . seek ( 0 , 2 ) , self . buffer . write ( b ) , self . buffer . seek ( ptr ) self . newlines -= 1 return self . buffer . readline ( ) def flush ( self ) : if self . writable : os . write ( self . _fd , self . buffer . getvalue ( ) ) self . buffer . truncate ( 0 ) , self . buffer . seek ( 0 ) class IOWrapper ( IOBase ) : def __init__ ( self , file ) : self . buffer = FastIO ( file ) self . flush = self . buffer . flush self . writable = self . buffer . writable self . write = lambda s : self . buffer . write ( s . encode ( \" ascii \" ) ) self . read = lambda : self . buffer . read ( ) . decode ( \" ascii \" ) self . readline = lambda : self . buffer . readline ( ) . decode ( \" ascii \" ) sys . stdin , sys . stdout = IOWrapper ( sys . stdin ) , IOWrapper ( sys . stdout ) input = lambda : sys . stdin . readline ( ) . rstrip ( \" \\n \" ) NEW_LINE","import math   import osfrom io import BytesIO , IOBaseimport sys   NEW_LINE","import math , sys , bisect , heapqfrom collections import defaultdict , Counter , dequefrom itertools import groupby , accumulate NEW_LINE","import sys , os , ioimport math , bisect , operatorinf , mod = float ( ' inf ' ) , 10 ** 9 + 7 NEW_LINE","import sys , os , ioimport math , bisect , operatorinf , mod = float ( ' inf ' ) , 10 ** 9 + 7 NEW_LINE"],"bleu":0.06242741409954472,"rouge_l":0.27490376490470375}
{"id":422,"predictions":["n = int ( input ( ) ) print ( n - 1 ) for i in range ( 1 , n ) : print ( i , end = \" ▁ \" ) NEW_LINE"],"references":["n = int ( input ( ) ) q = n \/\/ 3 r = n % 3 if ( r == 0 ) : if ( q % 3 != 0 ) : print ( q , q , q ) else : print ( q + 2 , q - 1 , q - 1 ) elif ( r == 1 ) : if ( q % 3 != 0 and ( q + 1 ) % 3 != 0 ) : print ( q , q , q + 1 ) elif ( q % 3 != 0 and ( q + 1 ) % 3 == 0 ) : print ( q - 1 , q , q + 2 ) elif ( q % 3 == 0 and ( q + 1 ) % 3 != 0 ) : print ( q - 1 , q + 1 , q + 1 ) else : if ( q % 3 != 0 and ( q + 2 ) % 3 != 0 ) : print ( q , q , q + 2 ) elif ( q % 3 != 0 and ( q + 2 ) % 3 == 0 ) : print ( q , q + 1 , q + 1 ) elif ( q % 3 == 0 and ( q + 2 ) % 3 != 0 ) : print ( q - 1 , q + 1 , q + 2 ) NEW_LINE","n = int ( input ( ) ) if ( ( n - 2 ) % 3 == 0 ) : a = 1 b = 2 c = n - 3 else : a = 1 b = 1 c = n - 2 print ( a , b , c ) NEW_LINE","n = int ( input ( ) )   if ( ( n - 2 ) % 3 ) : print ( \"1 ▁ 1\" , n - 2 ) else : print ( \"1 ▁ 2\" , n - 3 ) NEW_LINE","n = int ( input ( ) ) b = 1 + ( n % 3 > 1 ) print ( 1 , b , n - b - 1 ) NEW_LINE","n = int ( input ( ) ) if ( n - 2 ) % 3 : print ( \"1 ▁ 1\" , n - 2 ) else : print ( \"1 ▁ 2\" , n - 3 ) NEW_LINE"],"bleu":0.44107640794224445,"rouge_l":0.5977844056242011}
{"id":423,"predictions":["from sys import stdin , stdoutstdin . readlinedef mp ( ) : return list ( map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) ) def it ( ) : return int ( stdin . readline ( ) . strip ( ) ) from math import ceilfrom collections import defaultdict as ddfrom collections import Counter as Cn = it ( ) l = sorted ( mp ( ) ) NEW_LINE"],"references":["n = int ( input ( ) ) p , s , t = 1 , 0 , \"1\" for x in input ( ) . split ( ) : if x == \"0\" : print ( 0 ) quit ( ) elif x == \"1\" + \"0\" * ( len ( x ) - 1 ) : s += len ( x ) - 1 else : t = str ( x ) print ( t + \"0\" * s ) NEW_LINE","    n = int ( input ( ) ) arr = input ( ) . split ( )   zeros = 0 a = 0   for i in arr : x = i . count ( '0' ) y = i . count ( '1' ) if ( i == '1' ) : continue   elif ( i == '0' ) : print ( 0 ) exit ( 0 )   elif ( y == 1 and x == len ( i ) - 1 ) : zeros += x   else : a = i   NEW_LINE","int ( input ( ) ) x = ' ' zero = 0 for s in input ( ) . split ( ) : if s == '0' : print ( 0 ) , exit ( ) elif s == '1' + '0' * ( len ( s ) - 1 ) : zero += len ( s ) - 1 else : x = sprint ( x + '0' * zero if len ( x ) > 0 else '1' + '0' * zero ) NEW_LINE","if __name__ == ' _ _ main _ _ ' : n = int ( input ( ) ) a = [ x for x in input ( ) . split ( ) ] nb = '1' for x in a : if x == '0' : nb = None break if x [ 0 ] != '1' : nb = x else : for i in range ( 1 , len ( x ) ) : if x [ i ] != '0' : nb = x if nb is None : print ( 0 ) else : ans = nb for x in a : if x == nb : continue ans += '0' * ( len ( x ) - 1 ) print ( ans ) NEW_LINE","n = input ( ) x = ' ' zero = 0 for s in input ( ) . split ( ) : if s == '0' : print ( 0 ) , exit ( ) elif s == '1' + '0' * ( len ( s ) - 1 ) : zero += len ( s ) - 1 else : x = sprint ( x + '0' * zero if len ( x ) > 0 else '1' + '0' * zero ) NEW_LINE"],"bleu":0.13290972279576577,"rouge_l":0.296296897971782}
{"id":424,"predictions":["import sys   input = sys . stdin . buffer . readline   t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : n = int ( input ( ) ) NEW_LINE print ( n ) NEW_LINE"],"references":["for i in [ * open ( 0 ) ] [ 1 : ] : print ( int ( i ) - 1 , 1 ) NEW_LINE","T = int ( input ( ) ) for t in range ( T ) : x = int ( input ( ) ) print ( 1 , x - 1 ) NEW_LINE","t = int ( input ( ) ) for i in range ( t ) : n = int ( input ( ) ) print ( 1 , n - 1 ) NEW_LINE","for i in range ( int ( input ( ) ) ) : a = int ( input ( ) ) print ( a - 1 , 1 ) NEW_LINE"],"bleu":0.5193279425802131,"rouge_l":0.7465034965034966}
{"id":425,"predictions":["import math , sys , bisect , heapq , osfrom collections import defaultdict , Counter , dequefrom itertools import groupby , accumulatefrom functools import lru_cache NEW_LINE"],"references":["import mathfrom collections import deque     def Work ( ) : n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) IDX = [ 0 ] * n   for i in range ( n ) : IDX [ a [ i ] - 1 ] = i   l , r = n , 0 s = \" \"   for i in range ( n ) : l , r = min ( l , IDX [ i ] ) , max ( r , IDX [ i ] ) s += '1' if r - l == i else '0'   print ( s )     if __name__ == \" _ _ main _ _ \" : t = int ( input ( ) ) for _ in range ( t ) : Work ( ) NEW_LINE","import sysimport mathfrom collections import defaultdict , Counter , deque   NEW_LINE","t = int ( input ( ) )   for i in range ( t ) : n = int ( input ( ) ) lista = list ( map ( int , input ( ) . split ( ) ) ) pos = { } for j in range ( n ) : pos [ lista [ j ] ] = j l = r = pos [ 1 ] ans = \"1\" for j in range ( 2 , n + 1 ) : l = min ( l , pos [ j ] ) r = max ( r , pos [ j ] ) if ( r - l + 1 == j ) : ans += \"1\" else : ans += \"0\" print ( ans ) NEW_LINE","from sys import stdin , stdout   outputs = [ ] t = int ( stdin . readline ( ) . strip ( ) ) for __ in range ( t ) : n = int ( stdin . readline ( ) . strip ( ) ) a = [ int ( num ) for num in stdin . readline ( ) . strip ( ) . split ( ) ] s_l , s_r = [ ] , [ ] req_l , req_r = [ - 1 ] * n , [ - 1 ] * n res = [ '0' ] * n for i in range ( n - 1 , - 1 , - 1 ) : while s_r and a [ s_r [ - 1 ] ] < a [ i ] : s_r . pop ( ) if s_r : req_r [ i ] = s_r [ - 1 ] s_r . append ( i ) for i in range ( n ) : while s_l and a [ s_l [ - 1 ] ] < a [ i ] : s_l . pop ( ) if s_l : req_l [ i ] = s_l [ - 1 ] s_l . append ( i ) for i in range ( n ) : l , r = req_l [ i ] , n if req_r [ i ] == - 1 else req_r [ i ] if r - l - 1 >= a [ i ] : res [ a [ i ] - 1 ] = '1' else : res [ a [ i ] - 1 ] = '0' outputs . append ( ' ' . join ( res ) )   for output in outputs : stdout . write ( output + ' \\n ' )                   NEW_LINE","t = int ( input ( ) ) ans = [ ]   for _ in range ( t ) : n = int ( input ( ) ) nums = list ( map ( int , input ( ) . split ( ) ) ) lkp = { v : i for i , v in enumerate ( nums ) } arr = [ 0 ] * n l , r = n + 1 , - 1   for i in range ( 1 , n + 1 ) : pos = lkp [ i ] l = min ( l , pos ) r = max ( r , pos ) arr [ i - 1 ] = int ( r - l + 1 == i )   ans . append ( \" \" . join ( map ( str , arr ) ) )   for a in ans : print ( a )       NEW_LINE"],"bleu":0.25567957494892185,"rouge_l":0.48327464788732394}
{"id":426,"predictions":["n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) arr = sorted ( arr ) for i in range ( 1 , n + 1 ) : if i != arr [ i - 1 ] : print ( i ) breakelse : print ( n + 1 ) NEW_LINE"],"references":["( k , n , m ) = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( k ) : s = input ( ) NEW_LINE a . append ( [ ] ) NEW_LINE for j in range ( n ) : a [ - 1 ] . append ( list ( input ( ) ) ) NEW_LINE s = input ( ) ( x , y ) = map ( int , input ( ) . split ( ) ) NEW_LINE x -= 1 NEW_LINE y -= 1   start = ( 0 , x , y ) NEW_LINE sosed = set ( ) NEW_LINE sosed . add ( start ) NEW_LINE posetil = set ( ) NEW_LINE posetil . add ( start ) NEW_LINE while len ( sosed ) > 0 : sosed2 = set ( ) NEW_LINE for i in sosed : for NEW_LINE dk in [ - 1 , 0 , 1 ] : NEW_LINE for dx in [ - 1 , 0 , 1 ] : for NEW_LINE dy in [ - 1 , 0 , 1 ] : NEW_LINE if abs ( dk ) + abs ( dx ) + abs ( dy ) == 1 : if NEW_LINE ( i [ 0 ] + dk < k ) and ( i [ 0 ] + dk >= 0 ) and ( i [ 1 ] + dx < n ) and ( i [ 1 ] + dx >= 0 ) and ( i [ 2 ] + dy < m ) and ( i [ 2 ] + dy >= 0 ) : NEW_LINE if a [ i [ 0 ] + dk ] [ i [ 1 ] + dx ] [ i [ 2 ] + dy ] == ' . ' : if NEW_LINE ( i [ 0 ] + dk , i [ 1 ] + dx , i [ 2 ] + dy ) in posetil : NEW_LINE continue else : posetil . add ( ( i [ 0 ] + dk , i [ 1 ] + dx , i [ 2 ] + dy ) ) NEW_LINE sosed2 . add ( ( i [ 0 ] + dk , i [ 1 ] + dx , i [ 2 ] + dy ) ) NEW_LINE sosed = sosed2 . copy ( ) NEW_LINE print ( len ( posetil ) ) NEW_LINE","from collections import deque   k , n , m = map ( int , input ( ) . split ( ) ) NEW_LINE input ( )   allowed = set ( ) NEW_LINE for i in range ( k ) : for NEW_LINE j in range ( n ) : NEW_LINE for l , l_value in enumerate ( input ( ) ) : if NEW_LINE l_value == ' . ' : allowed . add ( ( i , j , l ) ) NEW_LINE input ( )   count0 = len ( allowed )         q = deque ( ) NEW_LINE x0 , y0 = map ( int , input ( ) . split ( ) ) NEW_LINE q . append ( ( 0 , x0 - 1 , y0 - 1 ) ) NEW_LINE allowed . remove ( q [ 0 ] )   dir = [ ( 1 , 0 , 0 ) , ( - 1 , 0 , 0 ) , ( 0 , 1 , 0 ) , ( 0 , - 1 , 0 ) , ( 0 , 0 , 1 ) , ( 0 , 0 , - 1 ) ]   while len ( q ) : x , y , z = q . popleft ( ) NEW_LINE for dx , dy , dz in dir : nt = x + dx , y + dy , z + dz NEW_LINE if nt in allowed : q . append ( nt ) NEW_LINE allowed . discard ( nt )   if count0 == 0 : NEW_LINE INDENT print ( 0 ) else : NEW_LINE print ( count0 - len ( allowed ) ) NEW_LINE DEDENT","from collections import deque   k , n , m = map ( int , input ( ) . split ( ) ) NEW_LINE input ( )   allowed = set ( ) NEW_LINE for i in range ( k ) : for NEW_LINE j in range ( n ) : NEW_LINE for l , l_value in enumerate ( input ( ) ) : if NEW_LINE l_value == ' . ' : allowed . add ( ( i , j , l ) ) NEW_LINE input ( )   count0 = len ( allowed )         q = deque ( ) NEW_LINE x0 , y0 = map ( int , input ( ) . split ( ) ) NEW_LINE q . append ( ( 0 , x0 - 1 , y0 - 1 ) ) NEW_LINE allowed . remove ( q [ 0 ] )   dir = [ ( 1 , 0 , 0 ) , ( - 1 , 0 , 0 ) , ( 0 , 1 , 0 ) , ( 0 , - 1 , 0 ) , ( 0 , 0 , 1 ) , ( 0 , 0 , - 1 ) ]   while len ( q ) : x , y , z = q . popleft ( ) NEW_LINE for dx , dy , dz in dir : nt = x + dx , y + dy , z + dz NEW_LINE if nt in allowed : q . append ( nt ) NEW_LINE allowed . discard ( nt )   print ( count0 - len ( allowed ) ) NEW_LINE","directions = [ [ 0 , 0 , 1 ] , [ 0 , 0 , - 1 ] , [ 0 , 1 , 0 ] , [ 0 , - 1 , 0 ] , [ 1 , 0 , 0 ] , [ - 1 , 0 , 0 ] ] NEW_LINE line = input ( ) . split ( ) NEW_LINE k = int ( line [ 0 ] ) NEW_LINE n = int ( line [ 1 ] ) NEW_LINE m = int ( line [ 2 ] ) NEW_LINE input ( )   graph = [ ] NEW_LINE for layer in range ( k ) : for NEW_LINE line in range ( n ) : graph . append ( input ( ) ) NEW_LINE input ( )   line = input ( ) . split ( ) NEW_LINE x = int ( line [ 0 ] ) NEW_LINE y = int ( line [ 1 ] )     visited = [ False ] * ( k * n * m )   NEW_LINE def dfs ( vertex ) : if NEW_LINE visited [ n * m * vertex [ 0 ] + m * vertex [ 1 ] + vertex [ 2 ] ] : NEW_LINE return else : visited [ n * m * vertex [ 0 ] + m * vertex [ 1 ] + vertex [ 2 ] ] = True NEW_LINE for direction in directions : position_to_look = [ ] NEW_LINE invalid = False NEW_LINE for i in range ( 3 ) : position_to_look . append ( vertex [ i ] + direction [ i ] ) NEW_LINE for coordinate in position_to_look : if NEW_LINE coordinate < 0 : invalid = True NEW_LINE if position_to_look [ 0 ] >= k or position_to_look [ 1 ] >= n or position_to_look [ 2 ] >= m : invalid = True NEW_LINE if invalid : continue NEW_LINE if graph [ n * position_to_look [ 0 ] + position_to_look [ 1 ] ] [ position_to_look [ 2 ] ] == ' . ' : dfs ( position_to_look )   dfs ( [ 0 , x - 1 , y - 1 ] ) NEW_LINE counter = 0 NEW_LINE for vertex in visited : if NEW_LINE vertex : counter += 1   print ( counter ) NEW_LINE"],"bleu":0.023700369664851353,"rouge_l":0.22610889608771492}
{"id":427,"predictions":["from __future__ import division , print_functionfrom collections import * from math import * from itertools import * import osimport sysfrom io import BytesIO , IOBase NEW_LINE"],"references":["t = int ( input ( ) )   for i in range ( t ) : p = input ( ) h = input ( ) cnts = { } for c in p : cnts [ c ] = cnts . get ( c , 0 ) + 1 yes = False for i in range ( len ( h ) ) : seq = { } for c in h [ i : ] : yes |= seq == cnts if c not in cnts : seq = { } else : seq [ c ] = seq . get ( c , 0 ) + 1 yes |= seq == cnts print ( \" YES \" if yes else \" NO \" ) NEW_LINE","n = int ( input ( ) ) for i in range ( n ) : l = list ( input ( ) ) l1 = list ( input ( ) ) if len ( l1 ) < len ( l ) : print ( \" NO \" ) elif len ( l ) == len ( l1 ) : if sorted ( l ) == sorted ( l1 ) : print ( \" YES \" ) else : print ( \" NO \" ) else : flag = False for i in range ( len ( l1 ) - len ( l ) + 1 ) : l2 = l1 [ i : i + len ( l ) ] if sorted ( l ) == sorted ( l2 ) : print ( \" YES \" ) flag = True break if flag == False : print ( \" NO \" ) NEW_LINE","r = lambda : list ( map ( int , input ( ) . split ( ) ) ) t = int ( input ( ) ) for _ in range ( t ) : a = list ( input ( ) ) b = list ( input ( ) )   a . sort ( ) f = False for i in range ( len ( b ) - len ( a ) + 1 ) : if sorted ( b [ i : i + len ( a ) ] ) == a : f = True break     print ( \" YES \" if f else \" NO \" ) NEW_LINE","from __future__ import division , print_functionfrom collections import * from math import * from itertools import * from time import timeimport osimport sysfrom io import BytesIO , IOBase   if sys . version_info [ 0 ] < 3 : from __builtin__ import xrange as range from future_builtins import ascii , filter , hex , map , oct , zip   ''' Notes : n ▁ = ▁ number ▁ of ▁ rooms ▁ on ▁ each ▁ floor '''   def main ( ) : p = input ( ) h = input ( ) password = Counter ( p ) for i in range ( len ( h ) - len ( p ) + 1 ) : if Counter ( h [ i : i + len ( p ) ] ) == password : print ( ' YES ' ) return else : continue print ( ' NO ' )                   NEW_LINE","def pDash ( p , h ) : for i in p : if i in h : h = h . replace ( i , ' ' , 1 ) else : return False return True t = int ( input ( ) ) for _ in range ( t ) : p = input ( ) h = input ( ) temp = 0 for i in range ( len ( h ) - len ( p ) + 1 ) : if pDash ( p , h [ i : i + len ( p ) ] ) : temp = 1 break if temp == 1 : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.03205394713061809,"rouge_l":0.24332617367290582}
{"id":428,"predictions":["n , m = map ( int , input ( ) . split ( ) ) f = n \/\/ mq = n % m   mini = ( f * ( f - 1 ) ) \/\/ ( 1 + 1 ) mini *= mmini += f * q ma = n - mma = ( ma * ( ma + 1 ) ) \/\/ ( 1 + 1 ) print ( mini , ma ) NEW_LINE"],"references":["v1 , v2 = map ( int , input ( ) . split ( ) ) t , d = map ( int , input ( ) . split ( ) ) t -= 1 u = [ 0 ] * ( t + 1 ) u [ 0 ] = v1for i in range ( 1 , t + 1 ) : u [ i ] = min ( u [ i - 1 ] + d , v2 + ( t - i ) * d ) ans = 0 for i in range ( 0 , t + 1 ) : ans += u [ i ] print ( ans ) NEW_LINE","import sysimport mathfrom collections import defaultdictimport itertools   MAXNUM = math . infMINNUM = - 1 * math . inf     def getInts ( ) : return map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( \" ▁ \" ) )     def getString ( ) : return sys . stdin . readline ( ) . rstrip ( )     def printOutput ( ans ) : sys . stdout . write ( str ( ans ) + \" \\n \" )     def solve ( v1 , v2 , t , d ) : curTime = 1 totalDistance = 0 curSpeed = v1 while curTime <= t : totalDistance += curSpeed for acc in range ( d , - d - 1 , - 1 ) : if curSpeed + acc - ( d * ( t - ( curTime + 1 ) ) ) <= v2 : curSpeed += acc break curTime += 1   return totalDistance     def readinput ( ) : v1 , v2 = getInts ( ) t , d = getInts ( ) printOutput ( solve ( v1 , v2 , t , d ) )     readinput ( ) NEW_LINE","from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE","start , end = map ( int , input ( ) . split ( ) ) t , d = map ( int , input ( ) . split ( ) ) ans = 0 for i in range ( t ) : if start > end : start , end = end , start ans += start start += dprint ( ans ) NEW_LINE"],"bleu":0.298145581142368,"rouge_l":0.4488073110285007}
{"id":429,"predictions":["n , m = map ( int , input ( ) . split ( ) ) f = n \/\/ mt = n % m   mini = ( f * ( f - 1 ) ) \/\/ ( 1 + 1 ) mini *= mmini += f * t ma = n - mma = ( ma * ( ma + 1 ) ) \/\/ ( 1 + 1 ) print ( mini , ma ) NEW_LINE"],"references":["n = int ( input ( ) ) a = sorted ( [ int ( x ) for x in input ( ) . split ( ) ] ) s = sum ( a ) if a [ 0 ] != 0 : print ( - 1 ) exit ( 0 ) if s % 3 != 0 : for x in a : if x % 3 == s % 3 : a . remove ( x ) break else : for x in a : if x % 3 : a . remove ( x ) break for x in a : if x % 3 : a . remove ( x ) breakwhile len ( a ) > 1 and a [ - 1 ] == 0 : a . pop ( ) a = a [ : : - 1 ] print ( ' ' . join ( str ( x ) for x in a ) ) NEW_LINE","import osimport sysfrom io import BytesIO , IOBaseimport mathimport itertoolsimport bisectimport heapq NEW_LINE"],"bleu":0.1570004104714948,"rouge_l":0.2496802251215145}
{"id":430,"predictions":["import mathn , a , b = map ( int , input ( ) . split ( ) ) c = math . ceil ( n \/ 2 ) if n \/ a >= b : print ( \" NO \" ) else : print ( \" YES \" ) NEW_LINE"],"references":["import math   n , a , b = map ( int , input ( ) . split ( ' ▁ ' ) ) rounds = math . log ( n , 2 ) r = int ( rounds ) for i in range ( 1 , int ( rounds ) + 1 ) : a = math . ceil ( a \/ 2 ) b = math . ceil ( b \/ 2 ) if ( a == b ) : if ( i == r ) : print ( ' Final ! ' ) break else : print ( i ) break NEW_LINE","n , a , b = map ( int , input ( ) . split ( ) )   a , b , r = a - 1 , b - 1 , 0   while a != b :   a \/\/= 2   b \/\/= 2   r += 1   print ( r if 2 ** r < n else ' Final ! ' )       NEW_LINE","a , b , c = map ( int , input ( ) . split ( ) ) z = [ * range ( 1 , a + 1 ) ] b , c = sorted ( [ b , c ] ) s = 0 ; k = awhile 1 : p = [ ] for i in range ( 0 , k , 2 ) : if z [ i ] == b and z [ i + 1 ] == c : s += 1 if len ( z ) == 2 : print ( \" Final ! \" ) else : print ( s ) exit ( ) elif z [ i ] == b : p += [ z [ i ] ] elif z [ i + 1 ] == b : p += [ z [ i + 1 ] ] elif z [ i ] == c : p += [ z [ i ] ] elif z [ i + 1 ] == c : p += [ z [ i + 1 ] ] else : p += [ z [ i ] ] k \/\/= 2 ; z = p ; s += 1   NEW_LINE","a , b , c = map ( int , input ( ) . split ( ) ) s = 0 while ( c != b ) : c = ( c + 1 ) \/\/ 2 b = ( b + 1 ) \/\/ 2 s += 1 a \/\/= 2 if a > 1 : print ( s ) else : print ( \" Final ! \" ) NEW_LINE"],"bleu":0.4974946596870402,"rouge_l":0.5769910400598715}
{"id":431,"predictions":["for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT print ( int ( input ( ) ) \/\/ 2 + 1 ) NEW_LINE DEDENT"],"references":["for x in range ( int ( input ( ) ) ) : n = int ( input ( ) ) if n % 2 == 0 : print ( n \/\/ 2 ) else : print ( ( n \/\/ 2 ) + 1 ) NEW_LINE","t = int ( input ( ) ) for i in range ( t ) : n = int ( input ( ) ) print ( ( n + 1 ) \/\/ 2 ) NEW_LINE","t = int ( input ( ) ) for i in range ( t ) : x = int ( input ( ) ) if x % 2 == 0 and x > 2 : print ( x \/\/ 2 ) elif x == 1 or x == 2 : print ( 1 ) else : print ( ( x \/\/ 2 ) + 1 ) NEW_LINE","for x in range ( int ( input ( ) ) ) : n = int ( input ( ) ) if n % 2 == 0 : print ( n \/\/ 2 ) else : print ( n \/\/ 2 + 1 ) NEW_LINE","def sameSize ( sticks ) : if sticks % 2 == 0 : return ( ( sticks - 1 ) \/\/ 2 ) + 1 NEW_LINE"],"bleu":0.6957838925817523,"rouge_l":0.6177215189873417}
{"id":432,"predictions":["n = int ( input ( ) ) m = int ( input ( ) ) a = [ ] for i in range ( n ) : s = input ( ) a . append ( s ) for i in range ( n ) : for j in range ( m ) : if a [ i ] [ j ] == ' B ' : a [ i ] [ j ] = ' W ' else : a [ i ] [ j ] = ' B ' a [ i ] [ j ] = ' W ' d = 0 for i in a : for j in range ( m ) : if s [ i ] [ j ] == ' W ' : d += 1 if s [ i ] [ j ] == ' B ' : d += 1 if d > 0 : print ( ' ' ) elif d > 0 : print ( ' W ' ) else : print ( ' B ' ) NEW_LINE"],"references":["if __name__ == ' _ _ main _ _ ' : cin = input a = [ cin ( ) for i in range ( 8 ) ] mw , mb = 8 , 8   for c in range ( 8 ) : for r in range ( 8 ) : if a [ r ] [ c ] == \" W \" : mw = min ( mw , r ) if a [ r ] [ c ] != \" . \" : break for r in range ( 7 , - 1 , - 1 ) : if a [ r ] [ c ] == \" B \" : mb = min ( mb , 7 - r ) if a [ r ] [ c ] != \" . \" : break print ( \" AB \" [ mb < mw ] ) NEW_LINE","def on_same_col ( point , arr , flag ) : for p in arr : if ( flag and p [ 0 ] < point [ 0 ] and p [ 1 ] == point [ 1 ] or not flag and p [ 0 ] > point [ 0 ] and p [ 1 ] == point [ 1 ] ) : return True return False   whites = [ ] blacks = [ ] min_white = 10 min_black = 10 for row in range ( 8 ) : row_str = input ( ) for col in range ( 8 ) : if row_str [ col ] == \" W \" : whites . append ( ( row , col ) ) if row_str [ col ] == \" B \" : blacks . append ( ( row , col ) )                           for white in whites : if not on_same_col ( ( white [ 0 ] , white [ 1 ] ) , blacks , True )   \\ and white [ 0 ] < min_white : min_white = white [ 0 ]   for black in blacks : if not on_same_col ( ( black [ 0 ] , black [ 1 ] ) , whites , False )   \\ and 7 - black [ 0 ] < min_black : min_black = 7 - black [ 0 ]     if min_white <= min_black : print ( \" A \" ) else : print ( \" B \" ) NEW_LINE","def STR ( ) : return list ( input ( ) ) def INT ( ) : return int ( input ( ) ) def MAP ( ) : return map ( int , input ( ) . split ( ) ) def MAP2 ( ) : return map ( float , input ( ) . split ( ) ) def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) def STRING ( ) : return input ( ) import stringfrom heapq import heappop , heappushfrom bisect import * from collections import deque , Counterfrom math import * from itertools import permutations , accumulatedx = [ - 1 , 1 , 0 , 0 ] dy = [ 0 , 0 , 1 , - 1 ] NEW_LINE","S = [ input ( ) for _ in range ( 8 ) ] S = list ( ' ' . join ( x ) for x in zip ( * S ) ) bdist = 1000 wdist = 1000 for s in S : if ' B ' in s : x = 8 - s . rfind ( ' B ' ) y = 8 - s . rfind ( ' W ' ) if x < y : bdist = min ( bdist , x ) if ' W ' in s : x = 8 - s [ : : - 1 ] . rfind ( ' W ' ) y = 8 - s [ : : - 1 ] . rfind ( ' B ' ) if x < y : wdist = min ( wdist , x ) if bdist < wdist : print ( ' B ' ) else : print ( ' A ' ) NEW_LINE"],"bleu":0.32407788253193054,"rouge_l":0.40063470162124876}
{"id":433,"predictions":["n , k = map ( int , input ( ) . split ( ) ) a = [ 0 for i in range ( n + 1 ) ] a [ 0 ] , a [ 1 ] = map ( int , input ( ) . split ( ) ) for i in range ( 1 , n + 1 ) : a [ i ] = a [ i - 1 ] + 1 a [ i ] p = 0 for i in range ( k ) : p += a [ i ] p += 1 print ( p + k ) NEW_LINE"],"references":["while True : try : n , m = list ( map ( int , input ( ) . split ( ) ) ) res = 1 while m % 2 == 0 : res += 1 m \/= 2 print ( res ) except : break NEW_LINE","import mathm , n = map ( int , input ( ) . split ( ) ) while True : NEW_LINE","n , k = map ( int , input ( ) . split ( ) ) l , r = 0 , 2 ** ( n ) - 1   while ( l < r ) : mid = ( l + r ) \/\/ 2 if ( mid == k - 1 ) : print ( n ) break if ( mid < k - 1 ) : l = mid + 1 if ( mid > k - 1 ) : r = mid - 1 n -= 1 else : print ( n ) NEW_LINE","import mathn , k = map ( int , input ( ) . split ( ) ) ans = 1 while ( k % 2 == 0 ) : k = k \/\/ 2 ans += 1 print ( ans ) NEW_LINE"],"bleu":0.2444922539751454,"rouge_l":0.5763730988833308}
{"id":434,"predictions":["h , m = map ( int , input ( ) . split ( ) ) NEW_LINE min = 60 * h + m NEW_LINE a = 18 * 60 NEW_LINE print ( a - min ) NEW_LINE"],"references":["for _ in range ( int ( input ( ) ) ) : h , m = map ( int , input ( ) . split ( ) ) s = 0 s = ( 24 - h - 1 ) * 60 + ( 60 - m ) print ( s ) NEW_LINE","t = int ( input ( ) ) for i in range ( t ) : hh , mm = map ( int , input ( ) . split ( ) ) print ( 60 * 24 - 60 * hh - mm ) NEW_LINE","t = int ( input ( ) ) for i in range ( t ) : h , m = map ( int , input ( ) . split ( ) ) print ( 1440 - ( h * 60 + m ) ) NEW_LINE","a = int ( input ( ) ) for _ in range ( a ) : count = 0 h , m = input ( ) . split ( ) h = int ( h ) m = int ( m ) count += 60 - m h += 1 count += 60 * ( 24 - h ) print ( count ) NEW_LINE","def solution ( h , m ) : return ( ( 23 - h ) * 60 ) + ( 60 - m )   t = int ( input ( ) ) while t : t = t - 1 h , m = map ( int , input ( ) . split ( ) ) print ( solution ( h , m ) ) NEW_LINE"],"bleu":0.45059122137995977,"rouge_l":0.5225905150433452}
{"id":435,"predictions":["for _ in range ( int ( input ( ) ) ) : a , b , x , y , n = map ( int , input ( ) . split ( ) ) NEW_LINE a1 = max ( a - x , n ) NEW_LINE b1 = max ( b - y , n - ( a - x ) ) NEW_LINE a2 = max ( b - y , n - y ) NEW_LINE print ( a1 * b1 ) NEW_LINE"],"references":["def solve ( a , b , p , q ) : area1 = a * q area2 = a * ( b - q - 1 ) area3 = b * p area4 = b * ( a - p - 1 ) return max ( area1 , area2 , area3 , area4 ) if __name__ == ' _ _ main _ _ ' : S = int ( input ( ) ) for s in range ( S ) : a , b , p , q = tuple ( map ( int , input ( ) . split ( ) ) ) print ( solve ( a , b , p , q ) ) NEW_LINE","r = lambda : list ( map ( int , input ( ) . split ( ) ) ) t = int ( input ( ) ) for _ in range ( t ) : arr = r ( )   dist1 = abs ( arr [ 0 ] - arr [ 2 ] ) - 1 dist2 = abs ( arr [ 1 ] - arr [ 3 ] ) - 1 dist12 = arr [ 2 ] dist22 = arr [ 3 ]     a = dist1 * arr [ 1 ] b = dist12 * arr [ 1 ] c = dist2 * arr [ 0 ] d = dist22 * arr [ 0 ]     print ( max ( a , b , c , d ) ) NEW_LINE","for t in range ( int ( input ( ) ) ) : a , b , x , y = map ( int , input ( ) . split ( ) )   area = max ( b * x , ( a - x - 1 ) * b , a * y , ( b - y - 1 ) * a ) print ( area ) NEW_LINE","def solve ( a , b , x , y ) : area1 = a * y area2 = a * ( b - y - 1 ) area3 = b * x area4 = b * ( a - x - 1 ) return max ( area1 , area2 , area3 , area4 )   if __name__ == ' _ _ main _ _ ' : T = int ( input ( ) ) for t in range ( T ) : a , b , x , y = tuple ( map ( int , input ( ) . split ( ) ) ) print ( solve ( a , b , x , y ) ) NEW_LINE"],"bleu":0.5303667887632917,"rouge_l":0.6812714776632303}
{"id":436,"predictions":["import sysdef get_ints ( ) : return map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) def get_ints_lists ( ) : return list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) def get_string ( ) : return sys . stdin . readline ( ) . strip ( ) n , m = get_ints ( ) for j in range ( m ) : s = get_ints ( ) if s [ 0 ] == ' B ' : if m & 1 : print ( 1 << j ) else : print ( 1 , end = ' ' ) print ( )         NEW_LINE"],"references":["import sys   input = sys . stdin . readline   def check ( x , y ) : for i in range ( min ( x [ 0 ] , y [ 0 ] ) , max ( x [ 0 ] , y [ 0 ] ) + 1 ) : if not plan [ i ] [ x [ 1 ] ] == \" B \" : return False for i in range ( min ( x [ 1 ] , y [ 1 ] ) , max ( x [ 1 ] , y [ 1 ] ) + 1 ) : if not plan [ y [ 0 ] ] [ i ] == \" B \" : return False return True   n , m = map ( int , input ( ) . split ( ) ) plan = tuple ( tuple ( i for i in input ( ) . strip ( ) ) for j in range ( n ) ) start = [ ( i , j ) for i in range ( n ) for j in range ( m ) if plan [ i ] [ j ] == \" B \" ] for i in range ( len ( start ) ) : for j in range ( i + 1 , len ( start ) ) : if not check ( start [ i ] , start [ j ] ) and not check ( start [ j ] , start [ i ] ) : print ( \" NO \" ) sys . exit ( ) print ( \" YES \" ) NEW_LINE","import sysinput = sys . stdin . readlinedef exi ( ) : print ( \" NO \" ) sys . exit ( ) I = lambda : list ( map ( int , input ( ) . split ( ) ) ) g = [ ] n , m = I ( ) for i in range ( n ) : g . append ( list ( input ( ) ) ) for i in range ( n ) : temp = 0 for j in range ( 1 , m ) : if g [ i ] [ j - 1 ] != g [ i ] [ j ] : temp += 1 NEW_LINE","import sysinput = sys . stdin . readlinedef exi ( ) : print ( \" NO \" ) sys . exit ( ) I = lambda : list ( map ( int , input ( ) . split ( ) ) ) g = [ ] n , m = I ( ) for i in range ( n ) : g . append ( list ( input ( ) ) ) for i in range ( n ) : temp = 0 for j in range ( 1 , m ) : if g [ i ] [ j - 1 ] != g [ i ] [ j ] : temp += 1 NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) c = [ input ( ) for _ in ' ▁ ' * n ] def sol ( n , m ) : for i in range ( n ) : count = 0 for j in range ( 1 , m ) : if c [ i ] [ j ] != c [ i ] [ j - 1 ] : count += 1 if count > 2 : return False if count == 2 and c [ i ] [ 0 ] == ' B ' : return False   for j in range ( m ) : count = 0 for i in range ( 1 , n ) : if c [ i ] [ j ] != c [ i - 1 ] [ j ] : count += 1 if count > 2 : return False if count == 2 and c [ 0 ] [ j ] == ' B ' : return False   for i in range ( n ) : for j in range ( m ) : if c [ i ] [ j ] == ' B ' : for x in range ( i , n ) : for y in range ( m ) : if c [ x ] [ y ] == ' B ' : if c [ i ] [ y ] == ' W ' and c [ x ] [ j ] == ' W ' : return False return True     print ( ' NYOE ▁ S ' [ sol ( n , m ) : : 2 ] ) NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) c = [ input ( ) for _ in ' ▁ ' * n ] def sol ( n , m ) : for i in range ( n ) : count = 0 for j in range ( 1 , m ) : if c [ i ] [ j ] != c [ i ] [ j - 1 ] : count += 1 if count > 2 : return False if count == 2 and c [ i ] [ 0 ] == ' B ' : return False   for j in range ( m ) : count = 0 for i in range ( 1 , n ) : if c [ i ] [ j ] != c [ i - 1 ] [ j ] : count += 1 if count > 2 : return False if count == 2 and c [ 0 ] [ j ] == ' B ' : return False   for i in range ( n ) : for j in range ( m ) : if c [ i ] [ j ] == ' B ' : for x in range ( i , n ) : for y in range ( m ) : if c [ x ] [ y ] == ' B ' : if c [ i ] [ y ] == ' W ' and c [ x ] [ j ] == ' W ' : return False return True     print ( ' NYOE ▁ S ' [ sol ( n , m ) : : 2 ] ) NEW_LINE"],"bleu":0.39525925958155544,"rouge_l":0.46401404330017554}
{"id":437,"predictions":["n = int ( input ( ) )   main = [ ] for i in range ( n ) : s , e = map ( int , input ( ) . split ( ) ) main . append ( ( s , e ) )   main . sort ( key = lambda x : x [ 1 ] )   cs , ce = main [ 0 ] [ 0 ] , main [ 0 ] [ 1 ] count = 1 for s , e in main [ 1 : ] : if ce < s : count += 1 cs = e   print ( count ) NEW_LINE"],"references":["I = lambda : map ( int , input ( ) . split ( ) ) n , s = I ( ) l = [ 0 ] for i in range ( n ) : q , w = I ( ) q = q * 60 + w l += [ q ] if l [ 1 ] - l [ 0 ] > s : exit ( print ( 0 , 0 ) ) for i in range ( n ) : if l [ i + 1 ] - l [ i ] > 2 * s + 1 : l [ i ] += s + 1 exit ( print ( l [ i ] \/\/ 60 , l [ i ] % 60 ) ) l [ - 1 ] += s + 1 print ( l [ - 1 ] \/\/ 60 , l [ - 1 ] % 60 ) NEW_LINE","n , k = map ( int , input ( ) . split ( ) ) r = 0 for _ in range ( n ) : h , m = map ( int , input ( ) . split ( ) ) t = 60 * h + m if ( t > r + k ) : break r = t + k + 1 print ( r \/\/ 60 , r % 60 ) NEW_LINE","n , s = map ( int , input ( ) . split ( ) ) h = list ( ) m = list ( ) l = list ( ) l . append ( 0 ) for _ in range ( n ) : x , y = map ( int , input ( ) . split ( ) ) h . append ( x ) m . append ( y ) l . append ( ( x * 60 ) + y ) if ( l [ 1 ] != 0 and ( l [ 1 ] - l [ 0 ] ) >= s + 1 ) : print ( 0 , 0 ) else : k = 2 * s + 2 r = 0 for i in range ( n ) : if ( l [ i + 1 ] - l [ i ] >= k ) : r = l [ i ] + s + 1 break else : continue if ( r == 0 ) : r = l [ n ] + s + 1 print ( r \/\/ 60 , r % 60 ) NEW_LINE","    n , s = map ( int , input ( ) . split ( ) ) t = [ [ 0 , 0 ] ] for j in range ( n ) :   a , b = map ( int , input ( ) . split ( ) )     total = a * 60 + b     last = t [ - 1 ] [ 0 ] * 60 + t [ - 1 ] [ 1 ] + 1   t . append ( [ a , b ] )   if j == 0 : if total >= s + 1 : print ( 0 , 0 ) break if total - last > 2 * s : u = last + s print ( u \/\/ 60 , u % 60 ) break   if j == n - 1 : x = t [ - 1 ] [ 0 ] * 60 + t [ - 1 ] [ 1 ] print ( ( x + s + 1 ) \/\/ 60 , ( x + s + 1 ) % 60 ) break     NEW_LINE","from itertools import * n , s = map ( int , input ( ) . split ( ) ) times = [ ] for i in range ( n ) : h , m = map ( int , input ( ) . split ( ) ) times . append ( ( h * 60 + m ) )   times . sort ( ) for t in count ( ) : if all ( abs ( u - t ) > s for u in times ) : print ( * divmod ( t , 60 ) ) break NEW_LINE"],"bleu":0.39485194210757113,"rouge_l":0.531138957415293}
{"id":438,"predictions":["import sys   str = sys . stdin . readline   n = int ( input ( ) ) NEW_LINE"],"references":["s = input ( ) ans = \" \" if s . startswith ( ' http ' ) : s = s [ 4 : ] ans = ' http : \/ \/ ' else : ans = \" ftp : \/ \/ \" s = s [ 3 : ]   if s . count ( ' ru ' ) > 1 and s . index ( ' ru ' ) == 0 : x = s [ 1 : ] . index ( ' ru ' ) + 1 else : x = s . index ( ' ru ' )     ans += s [ : x ] + ' . ' + ' ru ' s = s [ x + 2 : ] if s : ans += ' \/ ' + s   print ( ans )     NEW_LINE","d = input ( ) ad = ' ' if d [ : 4 ] == ' http ' : ad += ' http : \/ \/ ' else : ad += ' ftp : \/ \/ ' ad += d [ ( len ( ad ) - 3 ) : ( d . rfind ( ' ru ' ) ) ] + ' . ru ' if len ( ad ) != len ( d ) + 4 : ad += ' \/ ' + d [ ( d . rfind ( ' ru ' ) + 2 ) : ] print ( ad ) NEW_LINE","string = input ( )   if string . startswith ( ' http ' ) : protocol = string [ : 4 ] string = string [ 4 : ] else : protocol = string [ : 3 ] string = string [ 3 : ] domain_end = string . find ( ' ru ' , 1 )   domain_name = string [ : domain_end ] context = string [ domain_end + 2 : ]   result = protocol + ' : \/ \/ ' + domain_name + ' . ru '   if len ( context ) > 0 : result += ' \/ ' + context print ( result ) NEW_LINE","s = input ( ) ; if s [ 0 ] == \" h \" : ans = \" http : \/ \/ \" ; for i in range ( 5 , len ( s ) ) : if s [ i ] == \" r \" and s [ i + 1 ] == \" u \" : ans += s [ 4 : i ] + \" . \" + s [ i : i + 2 ] ; if i + 1 < len ( s ) - 1 : ans += \" \/ \" + s [ i + 2 : ] ; break ;   else : ans = \" ftp : \/ \/ \" ; for i in range ( 4 , len ( s ) ) : if s [ i ] == \" r \" and s [ i + 1 ] == \" u \" : ans += s [ 3 : i ] + \" . \" + s [ i : i + 2 ] ; if i + 1 < len ( s ) - 1 : ans += \" \/ \" + s [ i + 2 : ] ; break ; print ( ans )     NEW_LINE","s = input ( )   if s . startswith ( \" http \" ) : s = s . replace ( \" http \" , \" http : \/ \/ \" , 1 ) else : s = s . replace ( \" ftp \" , \" ftp : \/ \/ \" , 1 ) ind = s . index ( \" ru \" ) if s [ ind : ] == \" ru \" : s = s . replace ( \" ru \" , \" . ru \" ) else : if \" \/ \/ ru \" not in s : s = s . replace ( \" ru \" , \" . ru \/ \" , 1 ) else : s = s . replace ( \" \/ \/ ru \" , \" ~ ~ \" , 1 ) s = s . replace ( \" ru \" , \" . ru \/ \" , 1 ) s = s . replace ( \" ~ ~ \" , \" \/ \/ ru \" , 1 )   print ( s )                     NEW_LINE"],"bleu":0.0013208529803612936,"rouge_l":0.12151394422310757}
{"id":439,"predictions":["n = int ( input ( ) ) s = input ( ) ; flag = True ; cnt = 0 for i in range ( 0 , n - 10 , 2 ) : NEW_LINE"],"references":["tests = int ( input ( ) ) t = 0 for t in range ( 0 , tests ) : n = int ( input ( ) ) s = input ( ) bol = False for i in range ( 0 , len ( s ) ) : if s [ i ] == '8' : bol = True cnt = i break if ( bol ) : if n - cnt >= 11 : print ( ' YES ' ) else : print ( ' NO ' ) else : print ( \" NO \" ) NEW_LINE","import sysimport re   def main ( ) : inp = sys . stdin . read ( ) . strip ( ) . split ( ) [ 2 : : 2 ] out = [ ] for s in inp : out . append ( ( ' NO ' , ' YES ' ) [ bool ( re . search ( '8\\d { 10 } ' , s ) ) ] ) return out   print ( * main ( ) , sep = ' \\n ' ) NEW_LINE","n = int ( input ( ) ) for i in range ( n ) : m = int ( input ( ) ) s = input ( ) if '8' in s [ : - 10 ] : print ( ' YES ' ) else : print ( ' NO ' ) NEW_LINE","n = int ( input ( ) ) for i in range ( 0 , n ) :   m = int ( input ( ) ) s = input ( ) if ( '8' in s [ : - 10 ] ) : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.39288823915572146,"rouge_l":0.44932815282499594}
{"id":440,"predictions":["n = int ( input ( ) ) lst = list ( map ( int , input ( ) . split ( ) ) ) ans = [ ] lst [ : : : - 1 ] for i in lst : if i % 2 == 0 : ans . append ( lst [ i ] ) ans . append ( lst [ - i ] ) print ( len ( ans ) ) for i in ans : print ( i , end = \" ▁ \" ) NEW_LINE"],"references":["def solve ( arr ) : for i in range ( len ( arr ) ) : if arr [ i ] % 2 == 0 : arr [ i ] -= 1 return \" ▁ \" . join ( str ( i ) for i in arr )   input ( ) arr = list ( map ( int , input ( ) . split ( ) ) ) print ( solve ( arr ) ) NEW_LINE","def string_to_list ( s , char ) : collector = \" \" output_list = [ ] for i in range ( len ( s ) ) : if s [ i ] != char : collector += s [ i ] if i == len ( s ) - 1 : output_list . append ( int ( collector ) ) else : output_list . append ( int ( collector ) ) collector = \" \" return output_list     NEW_LINE","input ( ) nums = map ( int , str ( input ( ) ) . split ( ' ▁ ' ) ) print ( ' ▁ ' . join ( map ( str , map ( lambda x : x if x % 2 == 1 else x - 1 , nums ) ) ) ) NEW_LINE"],"bleu":0.4333956818946275,"rouge_l":0.3915738212941784}
{"id":441,"predictions":["import math , sys , bisect , heapq , osfrom collections import defaultdict , Counter , dequefrom itertools import groupby , accumulatefrom functools import lru_cache NEW_LINE"],"references":["from collections import defaultdictfrom sys import stdin   def put ( ) : return map ( int , stdin . readline ( ) . split ( ) )   def dfs ( ) : s = [ ( 1 , 0 ) ] ans = 0 vis = [ 0 ] * ( n + 1 ) while s : i , p = s . pop ( ) if vis [ i ] == 0 : vis [ i ] = 1 s . append ( ( i , p ) ) for j in tree [ i ] : if j != p : s . append ( ( j , i ) ) elif vis [ i ] == 1 : vis [ i ] = 2 for j in tree [ i ] : if j != p : mark [ i ] += mark [ j ] ans += min ( mark [ i ] , 2 * k - mark [ i ] ) print ( ans )                         n , k = put ( ) l = list ( put ( ) )   edge = defaultdict ( ) tree = [ [ ] for i in range ( n + 1 ) ] mark = [ 0 ] * ( n + 1 ) for i in l : mark [ i ] = 1 for _ in range ( n - 1 ) : x , y = put ( ) tree [ x ] . append ( y ) tree [ y ] . append ( x ) dfs ( ) NEW_LINE","def parser ( ) : return [ int ( x ) for x in input ( ) . split ( \" ▁ \" ) ]   def DFS ( ) : visited [ 0 ] = True stack = [ ] intruduction_order = [ ] stack . append ( 0 ) while len ( stack ) > 0 : v = stack . pop ( ) for u in adjacents_list [ v ] : if not visited [ u ] : pi [ u ] = v visited [ u ] = True if university_in_city [ u ] : count_universities_subtree [ u ] += 1 stack . append ( u ) intruduction_order . append ( u ) for v in intruduction_order [ : : - 1 ] : count_universities_subtree [ pi [ v ] ] += count_universities_subtree [ v ]     n , k = parser ( ) visited = [ False for x in range ( n ) ] pi = [ 0 for x in range ( n ) ] count_universities_subtree = [ 0 for x in range ( n ) ] university_in_city = [ False for x in range ( n ) ]   cities_universities = parser ( ) for i in range ( 2 * k ) : university_in_city [ cities_universities [ i ] - 1 ] = True   adjacents_list = [ [ ] for x in range ( n ) ] for i in range ( n - 1 ) : edge = parser ( ) adjacents_list [ edge [ 0 ] - 1 ] . append ( edge [ 1 ] - 1 ) adjacents_list [ edge [ 1 ] - 1 ] . append ( edge [ 0 ] - 1 )   DFS ( )   total = 0   for i in range ( 1 , n ) : total += min ( count_universities_subtree [ i ] , 2 * k - count_universities_subtree [ i ] )   print ( total ) NEW_LINE","WHITE = 0 GRAY = 1 BLACK = 2   def dfs_iter ( G , u = 0 ) : stack = [ ] stack . append ( { \" u \" : u , \" v \" : 0 , \" started \" : False } ) while len ( stack ) != 0 : current = stack [ len ( stack ) - 1 ] u = current [ \" u \" ] v_index = current [ \" v \" ] started = current [ \" started \" ] if started : NEW_LINE"],"bleu":0.006604201426874345,"rouge_l":0.06578789694427802}
{"id":442,"predictions":["t = str ( input ( ) ) s = str ( input ( ) ) z = 0 if len ( t ) == len ( s ) : for i in range ( 0 , len ( t ) ) : if t [ i ] == s [ len ( t ) - 1 - i ] : z += 1 if z == len ( t ) : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"references":["for _ in range ( int ( input ( ) ) ) : a = input ( ) b = input ( ) c = input ( ) case = True for i in range ( len ( a ) ) : if a [ i ] != c [ i ] and b [ i ] != c [ i ] : case = False print ( \" NO \" ) break if case : print ( \" YES \" ) NEW_LINE","for _ in range ( int ( input ( ) ) ) : a = input ( ) b = input ( ) c = input ( ) ans = True for i in range ( len ( a ) ) : if c [ i ] != a [ i ] and c [ i ] != b [ i ] : ans = False print ( \" NO \" ) break if ans : print ( \" YES \" ) NEW_LINE","for _ in range ( int ( input ( ) ) ) : a = input ( ) b = input ( ) c = input ( ) ans = True for i in range ( len ( a ) ) : if c [ i ] != a [ i ] and c [ i ] != b [ i ] : ans = False print ( \" No \" ) break if ans : print ( \" Yes \" ) NEW_LINE"],"bleu":0.30601379426383657,"rouge_l":0.5198527987604107}
{"id":443,"predictions":["from collections import defaultdict , deque , Counterfrom sys import stdin , stdoutfrom heapq import heappush , heappopimport mathimport ioimport osimport mathimport bisect   NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) g = [ set ( ) for i in range ( n ) ] for i in range ( m ) : a , b = map ( int , input ( ) . split ( ) ) g [ a - 1 ] . add ( b - 1 ) g [ b - 1 ] . add ( a - 1 ) a = [ ] p = [ - 1 ] * nfor i in range ( n ) : if p [ i ] != - 1 : continue p [ i ] = 0 a . append ( i ) while a : x = a . pop ( ) for node in g [ x ] : if p [ node ] == p [ x ] : print ( - 1 ) exit ( ) if p [ node ] == - 1 : p [ node ] = not p [ x ] a . append ( node ) print ( p . count ( 0 ) ) for i in range ( n ) : if p [ i ] == 0 : print ( i + 1 , end = \" ▁ \" ) print ( ) print ( p . count ( 1 ) ) for i in range ( n ) : if p [ i ] == 1 : print ( i + 1 , end = \" ▁ \" ) print ( ) NEW_LINE","from collections import defaultdictfrom collections import dequen , m = list ( map ( int , input ( ) . split ( ) ) ) d = defaultdict ( list ) for i in range ( m ) : x , y = map ( int , input ( ) . split ( ) ) d [ x ] . append ( y ) d [ y ] . append ( x ) c = { } f = 0 visited = [ 0 ] * ( n + 1 ) for i in range ( 1 , n + 1 ) : if visited [ i ] == 0 : q = deque ( ) q . append ( i ) visited [ i ] = 1 while q : j = q . popleft ( ) co = c . get ( j , 0 ) if co == 0 : c [ j ] = ' a ' co = ' a ' for k in d [ j ] : if visited [ k ] == 0 : coo = c . get ( k , 0 ) if coo == 0 : c [ k ] = ' a ' if co == ' b ' else ' b ' q . append ( k ) visited [ k ] = 1 for i in d : co = c [ i ] for j in d [ i ] : coo = c [ j ] if co == coo : f = 1 break if f : breakif f : print ( - 1 ) else : a , b = [ ] , [ ] for i in range ( 1 , n + 1 ) : co = c . get ( i , 0 ) if co == ' a ' : a . append ( i ) elif co == ' b ' : b . append ( i ) print ( len ( a ) ) print ( * a ) print ( len ( b ) ) print ( * b ) NEW_LINE","import sys , os , iodef rs ( ) : return sys . stdin . readline ( ) . rstrip ( ) def ri ( ) : return int ( sys . stdin . readline ( ) ) def ria ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) def ws ( s ) : sys . stdout . write ( s + ' \\n ' ) def wi ( n ) : sys . stdout . write ( str ( n ) + ' \\n ' ) def wia ( a ) : sys . stdout . write ( ' ▁ ' . join ( [ str ( x ) for x in a ] ) + ' \\n ' ) import math , datetime , functools , itertools , operator , bisect , fractions , statisticsfrom collections import deque , defaultdict , OrderedDict , Counterfrom fractions import Fractionfrom decimal import Decimalfrom sys import stdoutfrom heapq import heappush , heappop , heapify , _heapify_max , _heappop_max , nsmallest , nlargest NEW_LINE","def abhi ( node ) :   visited [ node ] = 1 color [ node ] = 1   q = [ node ]   while q :   a = q . pop ( 0 )   for j in adj [ a ] : if visited [ j ] == 0 : if color [ a ] == 1 : color [ j ] = 2 elif color [ a ] == 2 : color [ j ] = 1 q . append ( j ) visited [ j ] = 1 else : if color [ j ] == color [ a ] : print ( - 1 ) exit ( 0 )                                           import sysinput = sys . stdin . readline     n , q = map ( int , input ( ) . split ( ) )       adj = [ [ ] for j in range ( n + 1 ) ]   for i in range ( q ) : a , b = map ( int , input ( ) . split ( ) )     adj [ a ] . append ( b ) adj [ b ] . append ( a )       visited = [ 0 ] * ( n + 1 ) color = [ 0 ] * ( n + 1 )       for j in range ( 1 , n + 1 ) : if visited [ j ] == 0 : abhi ( j ) else : continue   one = [ ] two = [ ] u = True   if u == True : for j in range ( n + 1 ) : if visited [ j ] == 1 : if color [ j ] == 1 : one . append ( j ) elif color [ j ] == 2 : two . append ( j )         print ( len ( one ) ) print ( * one ) print ( len ( two ) ) print ( * two ) else : print ( - 1 ) NEW_LINE","n , m = map ( int , input ( ) . split ( ) )   g = [ [ ] for i in range ( n ) ]   for i in range ( m ) : u , v = map ( int , input ( ) . split ( ) ) u -= 1 ; v -= 1 g [ u ] . append ( v ) g [ v ] . append ( u )   used = [ - 1 ] * nok = Truew = [ [ ] , [ ] ]   def bfs ( start , color ) : used [ start ] = color w [ color ] . append ( start ) q = [ start ] while q != [ ] : for u in g [ q [ 0 ] ] : if used [ u ] == - 1 : used [ u ] = ( 1 + used [ q [ 0 ] ] ) % 2 w [ used [ u ] ] . append ( u ) q . append ( u ) else : if used [ u ] == ( used [ q [ 0 ] ] + 1 ) % 2 : pass else : return False q . pop ( 0 ) return True   for i in range ( n ) : if used [ i ] == - 1 : if not bfs ( i , 0 ) : ok = False breakif ok : for i in range ( 2 ) : print ( len ( w [ i ] ) ) for j in w [ i ] : print ( j + 1 , end = \" ▁ \" ) print ( ) else : print ( - 1 )   NEW_LINE"],"bleu":0.00037806396984743195,"rouge_l":0.11665073077448436}
{"id":444,"predictions":["x1 , y1 = map ( int , input ( ) . split ( ) ) x2 , y2 = map ( int , input ( ) . split ( ) ) print ( max ( abs ( x1 - x2 ) , abs ( y1 - y2 ) ) ) NEW_LINE"],"references":["x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) )   if x1 == x2 : x3 = x1 + abs ( y2 - y1 ) x4 = x3 y3 = y1 y4 = y2 NEW_LINE","a , b , c , d = [ int ( i ) for i in input ( ) . split ( ' ▁ ' ) ] if a == c : s = abs ( d - b ) if a + s > 1000 : a -= s else : a += s print ( a , b , a , d ) elif b == d : s = abs ( a - c ) if a + s > 1000 : b -= s else : b += s print ( a , b , c , b ) elif abs ( a - c ) == abs ( b - d ) : print ( a , d , c , b ) else : print ( - 1 ) NEW_LINE","'''   ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Online ▁ Python ▁ Compiler . ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Code , ▁ Compile , ▁ Run ▁ and ▁ Debug ▁ python ▁ program ▁ online . Write ▁ your ▁ code ▁ in ▁ this ▁ editor ▁ and ▁ press ▁ \" Run \" ▁ button ▁ to ▁ execute ▁ it .   ''' a , b , c , d = map ( int , input ( ) . split ( ) ) if ( b == d ) : dd = abs ( c - a ) p = a q = b + dd r = c s = d + dd print ( p , q , r , s ) elif ( a == c ) : dd = abs ( b - d ) p = a + dd q = b r = c + dd s = d print ( p , q , r , s ) else : if ( a < c ) : p = c q = b r = a s = d aa = abs ( p - a ) bb = abs ( q - d ) cc = abs ( s - b ) dd = abs ( r - c ) if ( aa == bb and bb == cc and cc == dd ) : print ( p , q , r , s ) else : print ( - 1 ) else : p = a q = d r = c s = b aa = abs ( p - c ) bb = abs ( q - b ) cc = abs ( r - a ) dd = abs ( s - d ) if ( aa == bb and bb == cc and cc == dd ) : print ( p , q , r , s ) else : print ( - 1 ) NEW_LINE","def issquare ( x1 , y1 , x2 , y2 ) :   if x1 == x2 : d = y2 - y1 print ( str ( x1 + d ) + \" ▁ \" + str ( y1 ) + \" ▁ \" + str ( x2 + d ) + \" ▁ \" + str ( y2 ) ) return elif y1 == y2 : d = x2 - x1 print ( str ( x1 ) + \" ▁ \" + str ( y1 + d ) + \" ▁ \" + str ( x2 ) + \" ▁ \" + str ( y2 + d ) ) return   elif abs ( x2 - x1 ) == abs ( y2 - y1 ) : print ( str ( x1 ) + \" ▁ \" + str ( y2 ) + \" ▁ \" + str ( x2 ) + \" ▁ \" + str ( y1 ) ) return else : print ( - 1 )         x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) issquare ( x1 , y1 , x2 , y2 ) NEW_LINE","x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) )   if x1 == x2 : x3 = x1 + abs ( y2 - y1 ) x4 = x3 y3 = y1 y4 = y2 print ( x3 , y3 , x4 , y4 ) elif y1 == y2 : x3 = x1 x4 = x2 y3 = y1 + abs ( x1 - x2 ) y4 = y2 + abs ( x1 - x2 ) print ( x3 , y3 , x4 , y4 ) elif abs ( x2 - x1 ) == abs ( y2 - y1 ) : x3 = x2 x4 = x1 y3 = y1 y4 = y2 print ( x3 , y3 , x4 , y4 ) else : print ( ' - 1' )       NEW_LINE"],"bleu":0.5347008273079876,"rouge_l":0.6443661971830986}
{"id":445,"predictions":["n , m = map ( int , input ( ) . split ( ) ) l = [ ] for i in range ( n ) : s = input ( ) l . append ( s ) a = [ ] ans = 0 for i in range ( n ) : for j in range ( m ) : if l [ i ] [ j ] == ' * ' : a [ i ] . append ( j ) else : a [ i ] [ j ] = ' # ' a [ i ] [ j ] = ' # ' a [ i ] [ j ] = ' # ' for i in range ( n ) : for j in range ( m ) : if l [ i ] [ j ] == 1 : ans = ans + 1 for i in range ( n ) : for j in range ( m ) : if l [ i ] [ j ] == a [ i ] [ j ] : ans = - 1 breakprint ( ans ) NEW_LINE"],"references":["def checkRow ( i , c ) : cnt = 0 NEW_LINE for j in range ( m ) : if NEW_LINE g [ i ] [ j ] == c : cnt += 1   if cnt >= 2 : return True NEW_LINE return False     NEW_LINE def checkCol ( j , c ) : cnt = 0 NEW_LINE for i in range ( n ) : if NEW_LINE g [ i ] [ j ] == c : cnt += 1   if cnt >= 2 : return True NEW_LINE return False   n , m = map ( int , input ( ) . split ( ) )   g = [ ]   for i in range ( n ) : g . append ( list ( input ( ) ) )     res = [ [ 0 ] * m for i in range ( n ) ] NEW_LINE for i in range ( n ) : for NEW_LINE j in range ( m ) : NEW_LINE if ( checkRow ( i , g [ i ] [ j ] ) ) or checkCol ( j , g [ i ] [ j ] ) : res [ i ] [ j ] = 1     for i in range ( n ) : for NEW_LINE j in range ( m ) : NEW_LINE if res [ i ] [ j ] == 0 : print ( g [ i ] [ j ] , end = ' ' )         NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) NEW_LINE grid = [ input ( ) for _ in range ( n ) ] NEW_LINE row = [ [ ] for _ in range ( n ) ] NEW_LINE column = [ [ ] for _ in range ( n ) ]   for i in range ( n ) : letters = { } NEW_LINE for j in range ( m ) : if NEW_LINE grid [ i ] [ j ] in letters : letters [ grid [ i ] [ j ] ] += 1 else : letters [ grid [ i ] [ j ] ] = 1   for j in range ( m ) : if NEW_LINE letters [ grid [ i ] [ j ] ] > 1 : row [ i ] . append ( ' ' ) else : row [ i ] . append ( grid [ i ] [ j ] ) NEW_LINE for i in range ( m ) : letters = { } NEW_LINE for j in range ( n ) : if NEW_LINE grid [ j ] [ i ] in letters : letters [ grid [ j ] [ i ] ] += 1 else : letters [ grid [ j ] [ i ] ] = 1   for j in range ( n ) : if NEW_LINE letters [ grid [ j ] [ i ] ] > 1 : column [ j ] . append ( ' ' ) else : column [ j ] . append ( grid [ j ] [ i ] )   for i in range ( n ) : for NEW_LINE j in range ( m ) : NEW_LINE if row [ i ] [ j ] != ' ' and column [ i ] [ j ] != ' ' : print ( row [ i ] [ j ] , end = ' ' ) NEW_LINE","if __name__ == ' _ _ main _ _ ' : n , m = map ( int , input ( ) . split ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : a = input ( ) NEW_LINE s = [ ] NEW_LINE for i in a : s . append ( i ) NEW_LINE l . append ( s ) NEW_LINE M = [ ] NEW_LINE for i in range ( n ) : a = [ ] NEW_LINE for j in range ( m ) : s = l [ i ] [ j ] NEW_LINE rflag = 1 NEW_LINE cflag = 1 NEW_LINE for k in range ( m ) : if NEW_LINE k != j and l [ i ] [ k ] == s : rflag = 0 NEW_LINE break NEW_LINE for k in range ( n ) : if NEW_LINE k != i and l [ k ] [ j ] == s : cflag = 0 NEW_LINE break NEW_LINE if cflag == 0 or rflag == 0 : NEW_LINE INDENT a . append ( ' X ' ) else : NEW_LINE a . append ( l [ i ] [ j ] ) NEW_LINE DEDENT M . append ( a ) NEW_LINE ans = ' ' NEW_LINE for i in range ( n ) : for NEW_LINE j in range ( m ) : NEW_LINE if M [ i ] [ j ] != ' X ' : ans = ans + M [ i ] [ j ] NEW_LINE print ( ans ) NEW_LINE","if __name__ == ' _ _ main _ _ ' : n , m = map ( int , input ( ) . split ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : a = input ( ) NEW_LINE s = [ ] NEW_LINE for i in a : s . append ( i ) NEW_LINE l . append ( s ) NEW_LINE ans = ' ' NEW_LINE for i in range ( n ) : for NEW_LINE j in range ( m ) : s = l [ i ] [ j ] NEW_LINE rflag = 1 NEW_LINE cflag = 1 NEW_LINE for k in range ( m ) : if NEW_LINE k != j and l [ i ] [ k ] == s : rflag = 0 NEW_LINE break NEW_LINE for k in range ( n ) : if NEW_LINE k != i and l [ k ] [ j ] == s : cflag = 0 NEW_LINE break NEW_LINE if cflag != 0 and rflag != 0 : ans = ans + l [ i ] [ j ] NEW_LINE print ( ans ) NEW_LINE"],"bleu":0.6940516459492848,"rouge_l":0.6040046256382056}
{"id":446,"predictions":["import sys , os , ioimport math , bisect , operatorinf , mod = float ( ' inf ' ) , 10 ** 9 + 7 NEW_LINE"],"references":["n , M = map ( int , input ( ) . strip ( ) . split ( ) ) a = list ( map ( int , input ( ) . strip ( ) . split ( ) ) )   a . insert ( 0 , 0 ) n += 1   lit = [ 0 ] * ( n + 1 ) for i in range ( 1 , n ) : if i % 2 == 0 : lit [ i ] = lit [ i - 1 ] else : lit [ i ] = lit [ i - 1 ] + a [ i ] - a [ i - 1 ] if n % 2 == 0 : lit [ n ] = lit [ n - 1 ] else : lit [ n ] = lit [ n - 1 ] + M - a [ n - 1 ] NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) ls = [ 0 ] + [ int ( x ) for x in input ( ) . split ( ) ] + [ m ] lb = [ 0 ] * nb = 0 for i in range ( 0 , n + 1 , 2 ) : b += ls [ i + 1 ] - ls [ i ] NEW_LINE","n , M = map ( int , input ( ) . split ( ) ) a = [ 0 ] + [ int ( x ) for x in input ( ) . split ( ) ] + [ M ]   t1 = [ ] t2 = [ ] for i in range ( n + 1 ) : if i % 2 == 0 : t1 . append ( a [ i + 1 ] - a [ i ] ) else : t2 . append ( a [ i + 1 ] - a [ i ] ) t2 . append ( 0 )   import mathans = sum ( t1 ) p = 0 q = sum ( t2 ) for i in range ( math . ceil ( n \/ 2 ) ) : p = p + t1 [ i ] q = q - t2 [ i - 1 ] ans = max ( ans , p + q - 1 ) print ( ans ) NEW_LINE","N , M = map ( int , input ( ) . split ( ) ) light = [ 0 ] + [ int ( _ ) for _ in input ( ) . split ( ) ] + [ M ] sumlist = [ ] sumlight , ans = 0 , - 10 ** 30 for i in range ( N + 1 ) : sumlight += ( - 1 ) ** ( i + 1 ) * light [ i ] sumlist . append ( sumlight ) for i in range ( 1 , N + 1 ) : if light [ i ] > light [ i - 1 ] + 1 : ans = max ( ans , 2 * sumlist [ i - 1 ] - sumlight + ( - 1 ) ** ( i + 1 ) * ( light [ i ] - 1 ) ) if light [ i ] < light [ i + 1 ] - 1 : ans = max ( ans , 2 * sumlist [ i ] - sumlight + ( - 1 ) ** i * ( light [ i ] + 1 ) ) if N % 2 == 0 : print ( max ( ans , sumlight + M ) ) else : print ( max ( ans + M , sumlight ) ) NEW_LINE","N , M = map ( int , input ( ) . split ( ) ) L = [ 0 ] + [ int ( _ ) for _ in input ( ) . split ( ) ] + [ M ] sumL = [ 0 ] ans = - 10 ** 30 for i in range ( 1 , N + 1 ) : sumL . append ( sumL [ - 1 ] - ( - 1 ) ** i * L [ i ] ) for i in range ( 1 , N + 1 ) : if L [ i ] > L [ i - 1 ] + 1 : ans = max ( ans , 2 * sumL [ i - 1 ] - sumL [ - 1 ] - ( - 1 ) ** ( i ) * ( L [ i ] - 1 ) ) if L [ i ] < L [ i + 1 ] - 1 : ans = max ( ans , 2 * sumL [ i ] - sumL [ - 1 ] + ( - 1 ) ** i * ( L [ i ] + 1 ) ) if N % 2 == 0 : print ( max ( ans , sumL [ - 1 ] + M ) ) else : print ( max ( ans + M , sumL [ - 1 ] ) ) NEW_LINE"],"bleu":0.013092111771462068,"rouge_l":0.14814814814814817}
{"id":447,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) : a . sort ( ) if a [ i ] == 1 : print ( ' YES ' ) elif a [ i ] == 2 : print ( ' YES ' ) else : print ( ' NO ' ) NEW_LINE"],"references":["import sysdef input ( ) : return sys . stdin . readline ( ) . strip ( ) def iinput ( ) : return int ( input ( ) ) def minput ( ) : return map ( int , input ( ) . split ( ) ) def listinput ( ) : return list ( map ( int , input ( ) . split ( ) ) ) c = 0 for _ in range ( iinput ( ) ) : km , dirr = map ( str , input ( ) . split ( ) ) km = int ( km ) if dirr == ' North ' : c -= km elif dirr == ' South ' : c += km elif c == 0 or c == 20000 : print ( \" NO \" ) exit ( ) if c < 0 or c > 20000 : print ( \" NO \" ) exit ( ) if c == 0 : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE","s , a = 0 , 0 for _ in \" ▁ \" * int ( input ( ) ) : t , d = map ( str , input ( ) . split ( ) ) ; t = int ( t ) if not a and d [ 0 ] != \" S \" or a == 20000 and d [ 0 ] != \" N \" or d [ 0 ] == \" N \" and a - t < 0 or d [ 0 ] == \" S \" and a + t > 20000 : s = 1 a += 0 if d not in \" NorthSouth \" else t if d [ 0 ] == \" S \" else - tprint ( \" YES \" if not ( s or a ) else \" NO \" ) NEW_LINE","s , a = 0 , 0 for _ in \" ▁ \" * int ( input ( ) ) : t , d = map ( str , input ( ) . split ( ) ) ; t = int ( t ) if not a and d [ 0 ] != \" S \" or a == 20000 and d [ 0 ] != \" N \" or d [ 0 ] == \" N \" and a - t < 0 or d [ 0 ] == \" S \" and a + t > 20000 : s = 1 a += 0 if d [ 0 ] not in \" NS \" else t if d [ 0 ] == \" S \" else - tprint ( \" YES \" if not ( s or a ) else \" NO \" ) NEW_LINE","import mathimport sys   n = int ( input ( ) )   polar = 0 for _ in range ( n ) : r , dir = map ( str , input ( ) . split ( ) ) r = int ( r )   if dir == \" South \" : polar += r elif dir == \" North \" : polar -= r else : if polar == 20000 or polar == 0 : print ( \" NO \" ) break   if polar < 0 or polar > 20000 : print ( \" NO \" ) breakelse : if polar == 0 : print ( \" YES \" ) else : print ( \" NO \" )   NEW_LINE","n = int ( input ( ) ) sum = 20000 flag = Falsefor i in range ( n ) : s = input ( ) . split ( ) s [ 0 ] = int ( s [ 0 ] ) if s [ 1 ] == \" South \" : sum -= s [ 0 ] if sum < 0 : flag = True elif s [ 1 ] == \" North \" : sum += s [ 0 ] if sum > 20000 : flag = True else : if sum == 0 or sum == 20000 : flag = Trueif sum == 20000 and flag == False : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.2861042928608648,"rouge_l":0.4365879244180642}
{"id":448,"predictions":["from collections import deque   n , m = map ( int , input ( ) . split ( ) ) a = [ 1000000 ] * 10100 a [ n ] = 0 q = deque ( ) q . append ( n ) NEW_LINE"],"references":["n , m = list ( map ( int , input ( ) . split ( \" ▁ \" ) ) )   if m % 2 != 0 : mid = int ( ( m + 1 ) \/ 2 ) i = mid j = mid       else :   mid = int ( ( m \/ 2 ) ) i = mid j = mid + 1     detector = 1 if m == 1 : for x in range ( n ) : print ( 1 ) else : for _ in range ( n ) : if i == j : print ( mid ) i -= 1 j += 1 detector = 1 continue if m % 2 != 0 : if detector == - 1 : print ( j ) j += 1 if j == m + 1 : j = mid detector *= - 1 elif detector == 1 : print ( i ) i -= 1 if i == 0 : i = mid detector *= - 1   elif m % 2 == 0 : if detector == 1 : print ( i ) i -= 1 if i == 0 : i = mid detector *= - 1 elif detector == - 1 : print ( j )   j += 1 if j == m + 1 : j = mid + 1 detector *= - 1     NEW_LINE","def task ( n , m ) : if m % 2 == 0 : c = 0 else : c = 1 mid = m \/\/ 2 + c l = mid - 1 hi = mid + 1 print ( mid ) n -= 1 if m % 2 != 0 : while n : if l > 0 : print ( l ) l -= 1 n -= 1 if hi <= m and n : print ( hi ) hi += 1 n -= 1 if hi > m and l <= 0 : hi = mid + 1 l = mid - 1 if n : print ( mid ) n -= 1 return \" \" else : while n :   if hi <= m and n : print ( hi ) hi += 1 n -= 1 if l > 0 and n : print ( l ) l -= 1 n -= 1 if hi > m and l <= 0 : hi = mid + 1 l = mid - 1 if n : print ( mid ) n -= 1 return \" \"   a , b = map ( int , input ( ) . strip ( ) . split ( ) ) print ( task ( a , b ) ) NEW_LINE","from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE","from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE","def func ( i ) : return abs ( ( m + 1 ) \/ 2 - i )   a = input ( ) [ n , m ] = a . split ( ' ▁ ' ) [ n , m ] = [ int ( n ) , int ( m ) ] ; a = [ i for i in range ( 1 , m + 1 ) ] a . sort ( key = func ) i = 0 ; while ( i < n ) : print ( a [ i % m ] ) i += 1 ; NEW_LINE"],"bleu":0.4776128958799398,"rouge_l":0.4871007371007371}
{"id":449,"predictions":["def main ( ) : x , y = map ( int , input ( ) . split ( ) ) s = y \/\/ ( x - 1 ) print ( s * ( s - 1 ) \/\/ ( y - 1 ) )     if __name__ == \" _ _ main _ _ \" : main ( ) NEW_LINE"],"references":["import mathfrom math import gcd , floor , sqrt , logdef iin ( ) : return int ( input ( ) ) def sin ( ) : return input ( ) . strip ( ) def listin ( ) : return list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) def liststr ( ) : return list ( map ( str , input ( ) . strip ( ) . split ( ) ) ) def ceill ( x ) : return int ( x ) if ( x == int ( x ) ) else int ( x ) + 1 def ceilldiv ( x , d ) : return x \/\/ d if ( x % d == 0 ) else x \/\/ d + 1 def LCM ( a , b ) : return ( a * b ) \/\/ gcd ( a , b )     def solve ( ) : n , x , y = listin ( ) wiz = x people = n - x req = ceill ( ( y \/ 100 ) * n ) print ( max ( 0 , req - wiz ) ) t = 1 NEW_LINE","from sys import stdin , stdoutimport math , sysfrom itertools import permutations , combinationsfrom collections import defaultdict , deque , OrderedDictfrom os import pathimport bisect as biimport heapq def yes ( ) : print ( ' YES ' ) def no ( ) : print ( ' NO ' ) if ( path . exists ( ' input . txt ' ) ) : NEW_LINE","import mathn , x , y = map ( int , input ( ) . split ( ) ) v = ( math . ceil ( ( y * n ) \/ 100 ) ) print ( v - x ) if v - x > 0 else print ( '0' ) NEW_LINE","import math   n , a , b = list ( map ( int , input ( ) . split ( ) ) ) x = ( n * b ) \/ 100 x = math . ceil ( x ) if ( x > a ) : print ( x - a ) else : print ( 0 ) NEW_LINE","import mathn , x , y = map ( int , input ( ) . split ( ) ) a = ( n * y - x * 100 ) \/ 100 print ( max ( 0 , math . ceil ( a ) ) ) NEW_LINE"],"bleu":0.4002145766691944,"rouge_l":0.5714173259337977}
{"id":450,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) total = sum ( a ) if n == 1 : print ( - 1 ) else : ans = - 1 for i in range ( n ) : if a [ i ] != total - a [ i ] : ans = i + 1 break if ans == - 1 : print ( - 1 ) else : print ( 1 ) print ( ans + 1 ) NEW_LINE"],"references":["n = int ( input ( ) ) vals = list ( map ( int , input ( ) . split ( ) ) ) vals = [ ( i , vals [ i ] ) for i in range ( n ) ] vals = [ vals [ 0 ] ] + sorted ( vals [ 1 : ] , key = lambda x : x [ 1 ] , reverse = True ) most_left_idx = 0 count = 0 output = ' ' for i in range ( n ) : if ( most_left_idx >= i ) : for j in range ( 1 , vals [ i ] [ 1 ] + 1 ) : if ( most_left_idx + j < n ) : count += 1 output += ' { } ▁ { } ▁ \\n ' . format ( vals [ i ] [ 0 ] + 1 , vals [ most_left_idx + j ] [ 0 ] + 1 ) most_left_idx += vals [ i ] [ 1 ] if ( most_left_idx >= n - 1 ) : print ( count ) print ( output ) else : print ( - 1 ) NEW_LINE","from sys import stdin , stdout , maxsize ; NEW_LINE","n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) order = [ ] pairs = [ ] l = a [ 1 : ] for i in range ( len ( l ) ) : order . append ( [ l [ i ] , i + 2 ] ) order . sort ( reverse = True ) order . insert ( 0 , [ a [ 0 ] , 1 ] ) rm = [ False ] * n NEW_LINE","n = int ( input ( ) ) A = list ( map ( int , input ( ) . split ( ) ) )   B = [ ] for i in range ( 1 , len ( A ) ) : B . append ( [ A [ i ] , i + 1 , 0 ] ) B . sort ( key = lambda elem : elem [ 0 ] , reverse = True ) flag = 0 k = 0 C = [ ] m = 0 if A [ 0 ] == 0 : print ( - 1 ) flag += 1 else : if A [ 0 ] > len ( B ) : for i in range ( A [ 0 ] - 1 ) : if i < len ( B ) : B [ i ] [ 2 ] += 1 k += 1 C . append ( [ 1 , B [ i ] [ 1 ] ] ) if i == len ( B ) - 1 : m += 1   else : for i in range ( A [ 0 ] ) : B [ i ] [ 2 ] += 1 k += 1 C . append ( [ 1 , B [ i ] [ 1 ] ] )     j = 0 while j < len ( B ) and m == 0 : if B [ j ] [ 2 ] == 0 : if flag == 0 : print ( - 1 ) flag += 1 break for x in range ( B [ j ] [ 0 ] ) : v = j + 1 for y in range ( v , len ( B ) ) : if B [ y ] [ 2 ] == 0 : B [ y ] [ 2 ] += 1 k += 1 C . append ( [ B [ j ] [ 1 ] , B [ y ] [ 1 ] ] ) if y == len ( B ) - 1 : j = len ( B ) break j += 1 if flag == 0 : print ( k )   if flag == 0 : for i in range ( len ( C ) ) : print ( C [ i ] [ 0 ] , C [ i ] [ 1 ] , sep = ' ▁ ' ) NEW_LINE","n = int ( input ( ) ) A = list ( map ( int , input ( ) . split ( ) ) ) B = [ ] for i in range ( 1 , len ( A ) ) : B . append ( [ A [ i ] , i + 1 , 0 ] ) B . sort ( key = lambda elem : elem [ 0 ] , reverse = True ) flag = 0 k = 0 C = [ ] m = 0 if A [ 0 ] == 0 : print ( - 1 ) flag += 1 else : if A [ 0 ] > len ( B ) : for i in range ( A [ 0 ] - 1 ) : if i < len ( B ) : B [ i ] [ 2 ] += 1 k += 1 C . append ( [ 1 , B [ i ] [ 1 ] ] ) if i == len ( B ) - 1 : m += 1 else : for i in range ( A [ 0 ] ) : B [ i ] [ 2 ] += 1 k += 1 C . append ( [ 1 , B [ i ] [ 1 ] ] ) j = 0 while j < len ( B ) and m == 0 : if B [ j ] [ 2 ] == 0 : if flag == 0 : print ( - 1 ) flag += 1 break for x in range ( B [ j ] [ 0 ] ) : v = j + 1 for y in range ( v , len ( B ) ) : if B [ y ] [ 2 ] == 0 : B [ y ] [ 2 ] += 1 k += 1 C . append ( [ B [ j ] [ 1 ] , B [ y ] [ 1 ] ] ) if y == len ( B ) - 1 : j = len ( B ) break j += 1 if flag == 0 : print ( k ) if flag == 0 : for i in range ( len ( C ) ) : print ( C [ i ] [ 0 ] , C [ i ] [ 1 ] , sep = ' ▁ ' ) NEW_LINE"],"bleu":0.5962913769338221,"rouge_l":0.5793352966829441}
{"id":451,"predictions":["stages , length = list ( map ( int , input ( ) . split ( ) ) ) s = list ( input ( ) )   s = list ( set ( s ) )   s . sort ( ) weight = 0 flag = 1 next_stage = s [ 0 ] start = 0 end = len ( s )   while length > 0 : length -= 1 if ( next_stage in s and flag == 1 ) : weight += ord ( next_stage ) - 96 flag = 1 if ( length > 0 ) : for each in range ( start , end ) : flag = 0 if ( ord ( s [ each ] ) - ord ( next_stage ) > 1 ) : start = each flag = 1 next_stage = s [ each ] break else : flag = 0 break   if ( flag == 1 ) : print ( weight ) else : print ( - 1 ) NEW_LINE"],"references":["l = [ - 1 ] * 122 g = [ - 1 ] * 122 r = 0 ch = 0 n , k = map ( int , input ( ) . split ( ) ) s = input ( ) j = nfor i in range ( 0 , n ) : j -= 1 indf = ord ( s [ i ] ) indb = ord ( s [ j ] ) if ( l [ indf ] != - 1 ) : pass else : l [ indf ] = i if ( g [ indb ] != - 1 ) : pass else : g [ indb ] = j   for i in range ( 0 , n ) : indx = ord ( s [ i ] ) if ( l [ indx ] == i ) : r += 1 if ( r > k ) : ch = 1 break if ( g [ indx ] == i ) : r -= 1 if ( ch == 1 ) : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE","n , k = map ( int , input ( ) . split ( ) ) s = input ( ) s = list ( s ) m = 0 a = [ 0 ] * 26 b = [ 0 ] * 26 for i in s : q = ord ( i ) - 65 a [ q ] += 1 for i in s : q = ord ( i ) - 65 if a [ q ] > 0 : if b [ q ] == 0 : if k == 0 : m = 1 break b [ q ] = 1 k -= 1 a [ q ] -= 1 if a [ q ] == 0 : k += 1 b [ q ] = 1 if m == 0 : print ( \" NO \" ) else : print ( \" YES \" ) NEW_LINE","n , k = map ( int , input ( ) . strip ( ) . split ( ' ▁ ' ) ) s = input ( ) s = list ( s ) l1 = [ 2 * 10 ** 6 ] * 26 l2 = [ 0 ] * 26 for i in range ( n ) : o = ord ( s [ i ] ) - 65 if l1 [ o ] > i : l1 [ o ] = i if l2 [ o ] < i : l2 [ o ] = ii = 0 while ( i < len ( l1 ) ) : if l1 [ i ] == 2000000 and l2 [ i ] == 0 : del l1 [ i ] del l2 [ i ] else : i += 1 for i in range ( len ( l1 ) - 1 ) : for j in range ( i + 1 , len ( l1 ) ) : if l1 [ i ] > l1 [ j ] : l1 [ i ] , l1 [ j ] = l1 [ j ] , l1 [ i ] l2 [ i ] , l2 [ j ] = l2 [ j ] , l2 [ i ] l = len ( l1 ) t = 0 c = 0 for i in range ( l ) : f = 0 if l1 [ i ] != - 1 : t = l2 [ i ] if i == l - 1 : c += 1 break for j in range ( i + 1 , l ) : if f == 0 : f = 1 c += 1 if l1 [ j ] > t : f = 1 t = l2 [ j ] l1 [ j ] = - 1 l2 [ j ] = - 1   if k >= c : print ( ' NO ' ) else : print ( ' YES ' ) NEW_LINE","from collections import Countern , k = map ( int , input ( ) . split ( ) ) s = input ( ) d = Counter ( s ) ans , opened = 0 , set ( ) for i in s : if i not in opened : opened . add ( i ) ans += 1 if ans > k : print ( \" YES \" ) ; break d [ i ] -= 1 if not d [ i ] : ans -= 1 else : print ( \" NO \" ) NEW_LINE"],"bleu":0.32895060705655077,"rouge_l":0.5154450909991333}
{"id":452,"predictions":["import mathn , m = map ( int , input ( ) . strip ( ) . split ( ' ▁ ' ) ) NEW_LINE"],"references":["a , b = list ( map ( int , input ( ) . split ( ) ) ) print ( format ( ( ( b * b ) - ( a * a ) ) \/ ( a * 2 ) , ' . 12f ' ) ) NEW_LINE","h , l = list ( map ( int , input ( ) . split ( ) ) )   res = ( l ** 2 - h ** 2 ) \/ ( 2 * h ) print ( res )       NEW_LINE","h , l = map ( int , input ( ) . split ( ) ) c = ( h * h + l * l ) ** 0.5 a = ( c * c ) \/ ( 2 * h ) print ( a - h ) NEW_LINE","import mathh , l = map ( int , input ( ) . split ( ) ) angle = math . atan ( l \/ h ) - math . atan ( h \/ l ) print ( math . tan ( angle ) * l ) NEW_LINE","h , l = map ( int , input ( ) . split ( ) ) a = l * l - h * hb = 2 * hprint ( a \/ b ) NEW_LINE"],"bleu":0.38636065630642213,"rouge_l":0.5138043986897519}
{"id":453,"predictions":["import sysimport mathimport collectionsimport bisectdef get_ints ( ) : return map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) def get_list ( ) : return list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) def get_string ( ) : return sys . stdin . readline ( ) . strip ( ) def get_ints ( ) : return map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) def inp ( ) : return list ( map ( str , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) def get_string ( ) : return sys . stdin . readline ( ) . strip ( ) def input ( ) : return sys . stdin . readline ( ) def out ( var , end = \" \\n \" ) : sys . stdout . write ( ' ▁ ' . join ( var ) + ' \\n ' ) def outa ( * var ) : sys . stdout . write ( str ( var ) + ' \\n ' ) NEW_LINE"],"references":["s = input ( ) w = len ( s ) q = - 1 for i in range ( w - 2 ) : for j in range ( i + 1 , w - 1 ) : a , b , c = s [ : i + 1 ] , s [ i + 1 : j + 1 ] , s [ j + 1 : ] if len ( a ) == len ( str ( int ( a ) ) ) and len ( b ) == len ( str ( int ( b ) ) ) and len ( c ) == len ( str ( int ( c ) ) ) : if int ( a ) <= 10 ** 6 and int ( b ) <= 10 ** 6 and int ( c ) <= 10 ** 6 : q = max ( q , int ( a ) + int ( b ) + int ( c ) ) print ( q ) NEW_LINE","s = input ( ) n = len ( s ) maxi = - 1 for i in range ( n - 2 ) : for j in range ( i + 1 , n - 1 ) : a , b , c = s [ : i + 1 ] , s [ i + 1 : j + 1 ] , s [ j + 1 : ] if len ( a ) == len ( str ( int ( a ) ) ) and len ( b ) == len ( str ( int ( b ) ) ) and len ( c ) == len ( str ( int ( c ) ) ) : if int ( a ) <= 1e6 and int ( b ) <= 1e6 and int ( c ) <= 1e6 : maxi = max ( maxi , int ( a ) + int ( b ) + int ( c ) ) print ( maxi ) NEW_LINE","s = input ( ) ans = - 1 for i in range ( len ( s ) - 2 ) : for j in range ( i + 1 , len ( s ) - 1 ) : x = s [ : i + 1 ] y = s [ i + 1 : j + 1 ] z = s [ j + 1 : ] if len ( x ) == len ( str ( int ( x ) ) ) and len ( y ) == len ( str ( int ( y ) ) ) and len ( z ) == len ( str ( int ( z ) ) ) : if int ( x ) <= 1e6 and int ( y ) <= 1e6 and int ( z ) <= 1e6 : ans = max ( ans , int ( x ) + int ( y ) + int ( z ) ) print ( ans ) NEW_LINE"],"bleu":0.043622107415956166,"rouge_l":0.2955686723636684}
{"id":454,"predictions":["import math , sys , bisect , heapq , osfrom NEW_LINE collections NEW_LINE import defaultdict , Counter , dequefrom NEW_LINE itertools NEW_LINE import groupby , accumulatefrom NEW_LINE functools NEW_LINE import lru_cache NEW_LINE"],"references":["x = int ( input ( ) ) for i in range ( x ) : n , m = [ int ( a ) for a in input ( ) . split ( ) ] if ( 2 * min ( n , m ) < max ( m , n ) or ( n + m ) % 3 ) : print ( \" NO \" ) else : print ( \" YES \" ) NEW_LINE","for iii in range ( int ( input ( ) ) ) : a , b = map ( int , input ( ) . split ( ) ) if ( a > b ) : a , b = b , a if ( a + b ) % 3 == 0 and 2 * a >= b : print ( \" yes \" ) else : print ( \" no \" ) NEW_LINE","import sysimport mathfrom collections import defaultdict , Counter , deque   NEW_LINE","for t in range ( int ( input ( ) ) ) : a , b = map ( int , input ( ) . split ( ) ) if a > b : a , b = b , a print ( ' YES ' if ( ( ( a + b ) % 3 ) == 0 and a * 2 >= b ) else ' NO ' ) NEW_LINE","for _ in range ( int ( input ( ) ) ) : a , b = sorted ( map ( int , input ( ) . split ( ) ) ) if ( 2 * a - b >= 0 ) and not ( 2 * a - b ) % 3 : print ( \" YES \" ) else : print ( \" NO \" )   NEW_LINE"],"bleu":0.16100867171758373,"rouge_l":0.39610389610389607}
{"id":455,"predictions":["from math import ceil   n = int ( input ( ) ) A = list ( map ( int , input ( ) . split ( ) ) ) B = list ( map ( int , input ( ) . split ( ) ) )   A = [ ] B = [ ]   for i in range ( n ) : A . append ( A [ i ] + ceil ( B [ i ] \/ A [ i ] ) ) B . append ( ceil ( ( A [ i ] \/ A [ i ] ) ) )   ans = [ ]   for i in range ( n ) : ans . append ( A [ i ] \/ A [ i ] )   print ( * ans ) NEW_LINE"],"references":["from sys import * ; from math import * ; from collections import * ; from bisect import * ; from itertools import * INF = maxsizedef get_ints ( ) : return map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) def get_array ( ) : return list ( map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) ) def input ( ) : return stdin . readline ( ) . strip ( ) mod = 1000000007   n = int ( input ( ) ) arr = [ ] for i in range ( n ) : temp = get_array ( ) arr . append ( temp ) for i in range ( n ) : ans = ( arr [ i ] [ ( i + 1 ) % n ] * arr [ i ] [ ( i + 2 ) % n ] ) \/\/ arr [ ( i + 1 ) % n ] [ ( i + 2 ) % n ] print ( int ( sqrt ( ans ) ) , end = ' ▁ ' ) NEW_LINE","import math   prime = [ 2 , 3 , 5 , 7 , 11 ] ; d = { }   def GeneratePrimes ( ) : for i in range ( 12 , 100010 ) : for j in prime : if i % j == 0 : break if j * j > i : prime . append ( i ) break else : prime . append ( i ) for i in range ( 1 , len ( prime ) + 1 ) : d [ prime [ i - 1 ] ] = i NEW_LINE","n = int ( input ( ) ) l = [ ] for i in range ( n ) : l . append ( list ( map ( int , input ( ) . split ( ) ) ) ) ans = [ ] a = int ( ( ( l [ 0 ] [ 1 ] * l [ 1 ] [ 2 ] ) \/\/ l [ 0 ] [ 2 ] ) ** 0.5 )   for i in range ( n ) : if l [ 1 ] [ i ] != 0 : ans . append ( l [ 1 ] [ i ] \/\/ a ) else : ans . append ( a ) print ( * ans ) NEW_LINE"],"bleu":0.5249032419384101,"rouge_l":0.5545454545454546}
{"id":456,"predictions":["import sys , math , itertoolsfrom collections import Counter , deque , defaultdictfrom bisect import bisect_left , bisect_right from heapq import heappop , heappush , heapify , nlargestfrom copy import deepcopymod = 10 ** 9 + 7 INF = float ( ' inf ' ) def inp ( ) : return int ( sys . stdin . readline ( ) ) def inpl ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) def inpl_1 ( ) : return list ( map ( lambda x : int ( x ) - 1 , sys . stdin . readline ( ) . split ( ) ) ) def inps ( ) : return sys . stdin . readline ( ) def inpsl ( x ) : tmp = sys . stdin . readline ( ) ; return list ( tmp [ : x ] ) def err ( x ) : print ( x ) ; exit ( )   for _ in range ( inp ( ) ) : n = inp ( ) print ( n - 1 ) NEW_LINE"],"references":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) [ : n ] res = [ a . index ( 1 ) , a . index ( n ) ] print ( max ( max ( res ) , n - min ( res ) - 1 ) ) NEW_LINE","n = int ( input ( ) ) lst = [ int ( i ) for i in input ( ) . split ( ) ] mn = lst . index ( min ( lst ) ) mx = lst . index ( max ( lst ) )   print ( max ( mn , n - mn - 1 , mx , n - mx - 1 ) ) NEW_LINE","import sysinput = sys . stdin . readline   n = int ( input ( ) ) a = [ int ( i ) for i in input ( ) . split ( ) ] x , y = a . index ( 1 ) , a . index ( n ) ans = max ( x , y , n - x - 1 , n - y - 1 ) print ( ans ) NEW_LINE","import sys   def main ( ) : n , * l = map ( int , sys . stdin . read ( ) . strip ( ) . split ( ) ) x , y = ( i for i , j in enumerate ( l , 1 ) if j in { 1 , n } ) return max ( y - 1 , n - x )   print ( main ( ) ) NEW_LINE","n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) x = a . index ( max ( a ) ) y = a . index ( min ( a ) ) if ( x == 0 ) or ( y == n - 1 ) or ( x == n - 1 ) or ( y == 0 ) : print ( n - 1 ) else : b = [ ] b . append ( y - 0 ) b . append ( n - y - 1 ) b . append ( x - 0 ) b . append ( n - x - 1 ) print ( max ( b ) ) NEW_LINE"],"bleu":0.21064860449534728,"rouge_l":0.4133300480473081}
{"id":457,"predictions":["def main ( ) : t = int ( input ( ) ) allans = [ ] for _ in range ( t ) : n , m , a , b = readIntArr ( ) adj = [ [ ] for __ in range ( n + 1 ) ] for __ in range ( m ) : u , v = readIntArr ( ) adj [ u ] . append ( v ) adj [ v ] . append ( u ) def reachableFromAWOPassingB ( a , b ) : st = [ a ] reachable = set ( ) reachable . add ( a ) while st : node = st . pop ( ) for nex in adj [ node ] : if nex != b and nex not in reachable : reachable . add ( nex ) st . append ( nex ) reachable . remove ( a ) return reachable vA = reachableFromAWOPassingB ( a , b ) vB = reachableFromAWOPassingB ( b , a ) NEW_LINE"],"references":["n = int ( input ( ) ) num = [ int ( i ) for i in input ( ) . split ( \" ▁ \" ) ]   odd = 0 even = 0   for i in num : if even and odd : break if i % 2 == 0 : even = 1 else : odd = 1 if even and odd : num = sorted ( num ) s = \" \" for i in range ( 0 , len ( num ) ) : s += str ( num [ i ] ) + \" ▁ \" print ( s ) NEW_LINE","import sysimport mathfrom collections import OrderedDictdef input ( ) : return sys . stdin . readline ( ) . strip ( ) def iinput ( ) : return int ( input ( ) ) def minput ( ) : return map ( int , input ( ) . split ( ) ) def listinput ( ) : return list ( map ( int , input ( ) . split ( ) ) ) n = iinput ( ) l = listinput ( ) even_no = list ( filter ( lambda x : ( x % 2 == 0 ) , l ) ) odd_no = list ( filter ( lambda x : ( x % 2 != 0 ) , l ) ) if len ( odd_no ) == 0 or len ( even_no ) == 0 : print ( * l ) else : print ( * sorted ( l ) ) NEW_LINE","n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in range ( n ) : c += l [ i ] % 2 if ( c != 0 and c != n ) : l . sort ( ) print ( * l ) NEW_LINE","from sys import stdin , stdoutfrom math import floor , gcd , fabs , factorial , fmod , sqrt , inf , logfrom collections import defaultdict as dd , dequefrom heapq import merge , heapify , heappop , heappush , nsmallestfrom bisect import bisect_left as bl , bisect_right as br , bisect mod = pow ( 10 , 9 ) + 7 mod2 = 998244353 def inp ( ) : return stdin . readline ( ) . strip ( ) def iinp ( ) : return int ( inp ( ) ) def out ( var , end = \" \\n \" ) : stdout . write ( str ( var ) + \" \\n \" ) def outa ( * var , end = \" \\n \" ) : stdout . write ( ' ▁ ' . join ( map ( str , var ) ) + end ) def lmp ( ) : return list ( mp ( ) ) def mp ( ) : return map ( int , inp ( ) . split ( ) ) def smp ( ) : return map ( str , inp ( ) . split ( ) ) def l1d ( n , val = 0 ) : return [ val for i in range ( n ) ] def l2d ( n , m , val = 0 ) : return [ l1d ( m , val ) for j in range ( n ) ] def remadd ( x , y ) : return 1 if x % y else 0 def ceil ( a , b ) : return ( a + b - 1 ) \/\/ b def isprime ( x ) : if x <= 1 : return False if x in ( 2 , 3 ) : return True if x % 2 == 0 : return False for i in range ( 3 , int ( sqrt ( x ) ) + 1 , 2 ) : if x % i == 0 : return False return True n = iinp ( ) arr = lmp ( ) c1 = 0 for i in arr : c1 += i % 2 if c1 in [ 0 , n ] : print ( * arr ) else : print ( * sorted ( arr ) ) NEW_LINE","n = int ( input ( ) ) k = list ( map ( int , input ( ) . split ( ) ) )   for i in range ( n ) : if ( ( k [ i ] - k [ 0 ] ) % 2 ) : k . sort ( ) breakprint ( * k ) NEW_LINE"],"bleu":0.1703625616755837,"rouge_l":0.47890325283439616}
{"id":458,"predictions":["n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( len ( l ) ) : for j in range ( len ( l ) ) : if ( ( i + 1 ) == l [ j ] ) : print ( j + 1 , end = ' ▁ ' ) NEW_LINE"],"references":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) k = ns = set ( ) for i in a : s . add ( i ) while k in s : print ( k , end = ' ▁ ' ) k -= 1 print ( ) NEW_LINE","n = int ( input ( ) ) t = list ( map ( int , input ( ) . split ( ) ) )   p = n - 1 used = [ False ] * n   for x in range ( n ) : used [ t [ x ] - 1 ] = True   while p >= 0 and used [ p ] : print ( p + 1 , end = ' ▁ ' ) p -= 1 print ( ' ' ) NEW_LINE","n = int ( input ( ) ) l = [ int ( x ) for x in input ( ) . split ( ) ] d = set ( ) for i in l : d . add ( i ) while n in d : print ( n , end = ' ▁ ' ) n -= 1 print ( ) NEW_LINE","n = int ( input ( ) ) l = ns = set ( ) a = map ( int , input ( ) . split ( ) ) for i in a : s . add ( i ) while n in s : print ( n , end = ' ▁ ' ) n = n - 1 print ( ) NEW_LINE","import sysinput = sys . stdin . readlineimport math def inpit ( ) : NEW_LINE"],"bleu":0.5442192100001156,"rouge_l":0.6445750307174528}
{"id":459,"predictions":["t = int ( input ( ) ) for _ in range ( t ) : n = int ( input ( ) ) s = input ( ) q = s [ n - 1 ] * n print ( q ) NEW_LINE"],"references":["for t in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEW_LINE b = input ( ) NEW_LINE a = ' ' NEW_LINE d = ' ' NEW_LINE for i in b : try : if 1 + int ( i ) == int ( d [ - 1 ] ) : NEW_LINE INDENT a += '0' else : NEW_LINE a += '1' except : a = '1' NEW_LINE DEDENT d = str ( int ( a [ - 1 ] ) + int ( i ) ) NEW_LINE print ( a ) NEW_LINE","for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE t = \"1\" NEW_LINE p = s [ 0 ] NEW_LINE for i in s [ 1 : ] : if NEW_LINE i == '1' : NEW_LINE if t [ - 1 ] == '1' and p == '1' : NEW_LINE INDENT t += '0' else : NEW_LINE t += '1' else : if ( t [ - 1 ] == '1' and p == '0' ) or ( t [ - 1 ] == '0' and p == '1' ) : NEW_LINE t += '0' else : NEW_LINE t += '1' NEW_LINE DEDENT p = i NEW_LINE print ( t ) NEW_LINE","from sys import stdin   for _ in range ( int ( stdin . readline ( ) ) ) : n = int ( stdin . readline ( ) ) NEW_LINE b = stdin . readline ( ) . strip ( ) NEW_LINE res = [ 0 ] * n NEW_LINE prev = - 1 NEW_LINE for idx , val in enumerate ( b ) : if NEW_LINE val == '1' : NEW_LINE if prev == 2 : res [ idx ] = '0' NEW_LINE prev = 1 else : res [ idx ] = '1' NEW_LINE prev = 2 else : if prev != 1 : res [ idx ] = '1' NEW_LINE prev = 1 else : res [ idx ] = '0' NEW_LINE prev = 0 NEW_LINE print ( ' ' . join ( res ) ) NEW_LINE","from sys import maxsize , stdout , stdin , stderrmod = int ( 1e9 + 7 ) NEW_LINE def I ( ) : return int ( stdin . readline ( ) ) NEW_LINE def lint ( ) : return [ int ( x ) for x in stdin . readline ( ) . split ( ) ] NEW_LINE def S ( ) : return input ( ) . strip ( ) NEW_LINE def grid ( r , c ) : return [ lint ( ) for i in range ( r ) ] NEW_LINE from collections import defaultdictimport NEW_LINE math   t = I ( ) NEW_LINE for _ in range ( t ) : n = I ( ) NEW_LINE b = input ( ) NEW_LINE print ( \"1\" , end = \" \" ) NEW_LINE idx = int ( b [ 0 ] ) + 1 NEW_LINE for i in range ( 1 , n ) : if NEW_LINE b [ i ] == \"0\" : NEW_LINE if idx != 1 : print ( \"1\" , end = \" \" ) NEW_LINE idx = 1 else : print ( \"0\" , end = \" \" ) NEW_LINE idx = 0 else : if idx != 2 : print ( \"1\" , end = \" \" ) NEW_LINE idx = 2 else : print ( \"0\" , end = \" \" ) NEW_LINE idx = 1 NEW_LINE print ( ) NEW_LINE"],"bleu":0.17288376142783585,"rouge_l":0.3805747866688134}
{"id":460,"predictions":["import math , sys , bisect , heapq , osfrom collections import defaultdict , Counter , dequefrom itertools import groupby , accumulatefrom functools import lru_cache NEW_LINE"],"references":["from math import ceiln , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) m = 10 ** ( k - 1 ) ans = 1 for i in range ( n \/\/ k ) : an = ( 10 ** k - 1 ) \/\/ a [ i ] + 1 l = b [ i ] * m r = ( b [ i ] + 1 ) * m - 1 count = r \/\/ a [ i ] - ceil ( l \/ a [ i ] ) + 1 ans = ( ans * ( an - count ) ) % ( 10 ** 9 + 7 ) print ( ans ) NEW_LINE","from math import *   MOD = 1000000007   n , k = map ( int , input ( ) . split ( ) )   a = [ int ( i ) for i in input ( ) . split ( ) ] b = [ int ( i ) for i in input ( ) . split ( ) ]   res = 1 for i in range ( n \/\/ k ) : cont = ceil ( 10 ** k \/ a [ i ] ) - ceil ( ( b [ i ] + 1 ) * 10 ** ( k - 1 ) \/ a [ i ] ) + ceil ( b [ i ] * 10 ** ( k - 1 ) \/ a [ i ] ) NEW_LINE","from math import * MOD = 1000000007 n , k = map ( int , input ( ) . split ( ) ) a = [ int ( i ) for i in input ( ) . split ( ) ] b = [ int ( i ) for i in input ( ) . split ( ) ] res = 1 for i in range ( n \/\/ k ) : cont = ceil ( 10 ** k \/ a [ i ] ) - ceil ( ( b [ i ] + 1 ) * 10 ** ( k - 1 ) \/ a [ i ] ) + ceil ( b [ i ] * 10 ** ( k - 1 ) \/ a [ i ] ) NEW_LINE","mod = 1000000000 + 7 n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) blo = n \/\/ kans = 1 for i in range ( blo ) : cnt = ( 10 ** k - 1 ) \/\/ a [ i ] - ( 10 ** ( k - 1 ) * ( b [ i ] + 1 ) - 1 ) \/\/ a [ i ] if b [ i ] > 0 : cnt += ( 10 ** ( k - 1 ) * b [ i ] - 1 ) \/\/ a [ i ] + 1 ans = ( ans * cnt ) % modprint ( ans ) NEW_LINE","import sys   n , k = map ( int , sys . stdin . readline ( ) . split ( ) ) msa = [ int ( i ) for i in sys . stdin . readline ( ) . split ( ) ] msb = [ int ( i ) for i in sys . stdin . readline ( ) . split ( ) ] sch = 1 for i in range ( n \/\/ k ) : cha = msa [ i ] chb = msb [ i ] chx = ( pow ( 10 , k ) - 1 ) \/\/ cha + 1 if chb != 0 : chx = chx - ( pow ( 10 , k - 1 ) * ( chb + 1 ) - 1 ) \/\/ cha + ( pow ( 10 , k - 1 ) * chb - 1 ) \/\/ cha else : chx = chx - ( pow ( 10 , k - 1 ) - 1 ) \/\/ cha - 1 sch *= ( chx % 1000000007 ) sys . stdout . write ( str ( sch % 1000000007 ) ) NEW_LINE"],"bleu":0.00144177796600377,"rouge_l":0.07091190906742444}
{"id":461,"predictions":["import sys NEW_LINE stdin = sys . stdin NEW_LINE def li ( ) : return list ( map ( int , stdin . readline ( ) . split ( ) ) ) NEW_LINE def li_print ( ) : return map ( lambda x : int ( x ) - 1 , stdin . readline ( ) . split ( ) ) NEW_LINE def lf ( ) : return map ( float , stdin . readline ( ) . split ( ) ) NEW_LINE def ls ( ) : return stdin . readline ( ) . split ( ) NEW_LINE def ns ( ) : return stdin . readline ( ) . rstrip ( ) NEW_LINE def lc ( ) : return list ( ns ( ) ) NEW_LINE def ni ( ) : return list ( ns ( ) ) NEW_LINE def nf ( ) : return float ( stdin . readline ( ) ) NEW_LINE def wf ( ) : return float ( stdin . readline ( ) ) NEW_LINE def nf ( ) : return float ( stdin . readline ( ) ) NEW_LINE for _ in range ( n ) : NEW_LINE INDENT x , y = li ( ) NEW_LINE m = li ( ) NEW_LINE if x < n : NEW_LINE INDENT m = x NEW_LINE DEDENT elif x > y : NEW_LINE INDENT m = m + li NEW_LINE DEDENT else : NEW_LINE INDENT m = y NEW_LINE DEDENT DEDENT print ( mn ( x ) NEW_LINE"],"references":["x = ( int ( input ( ) ) + 1 ) \/\/ 3 print ( x \/\/ 12 , x % 12 ) NEW_LINE","n = int ( input ( ) ) a = n \/\/ 36 rema = n % 36 if ( rema == 35 ) : a += 1 if ( a >= n ) : b = 0 else : b = ( n - a * 36 ) \/\/ 3 rem = ( n - a * 36 ) % 3 if ( rem == 2 ) : b += 1 print ( a , b ) NEW_LINE","n = int ( input ( ) ) a = ( n + 1 ) \/\/ 36 n -= 36 * ab = ( n + 1 ) \/\/ 3 print ( a , b ) NEW_LINE","s = int ( input ( ) ) f = 0 i = 0 while s >= 36 : s -= 36 f += 1 while s >= 3 : s -= 3 i += 1 if s == 2 : i += 1   while i >= 12 : f += 1 i -= 12     print ( f , end = ' ▁ ' ) print ( i ) NEW_LINE","n = int ( input ( ) ) + 1 print ( n \/\/ 36 , int ( n \/ 3 % 12 ) ) NEW_LINE"],"bleu":0.028060345247786597,"rouge_l":0.20730018879798617}
{"id":462,"predictions":["a , b , c = [ int ( x ) for x in input ( ) . split ( ' ▁ ' ) ] n = int ( input ( ) ) s = [ int ( x ) for x in input ( ) . split ( ' ▁ ' ) ] print ( sum ( [ int ( b ) for b in s ] ) ) NEW_LINE"],"references":["n , b , d = map ( int , input ( ) . split ( ) ) summa = 0 ans = 0 a = [ int ( i ) for i in input ( ) . split ( ) ] for i in a : if i <= b : summa += i if summa > d : summa = 0 ans += 1 print ( ans ) NEW_LINE","a , b , d = map ( int , input ( ) . split ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) )   ans = 0 bin = 0 for n in arr : if n <= b : bin += n if bin > d : ans += 1 bin = 0   print ( ans ) NEW_LINE","for _ in range ( 1 ) : n , b , d = map ( int , input ( ) . split ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) )   trashBin = 0 mixed = 0 total = 0 for i in range ( n ) : if arr [ i ] > b : trashBin += b else : mixed += arr [ i ]   if mixed > d : trashBin = 0 mixed = 0 total += 1   print ( total ) NEW_LINE","n , b , d = map ( int , input ( ) . split ( ) ) cont , answ = 0 , 0 oranges = input ( ) . split ( ) for orange in oranges : if int ( orange ) <= b : cont += int ( orange ) if cont > d : answ += 1 cont = 0 print ( answ ) NEW_LINE"],"bleu":0.29810836242105,"rouge_l":0.4507042253521127}
{"id":463,"predictions":["import sys , os , ioimport math , bisect , operatorinf , mod = float ( ' inf ' ) , 10 ** 9 + 7 NEW_LINE"],"references":["n , m , b , mod = list ( map ( int , input ( ) . split ( ) ) ) a = list ( map ( int , input ( ) . split ( ) ) )   A = [ [ 0 for i in range ( m + 1 ) ] for j in range ( b + 1 ) ]   A [ 0 ] [ 0 ] = 1   for i in range ( n ) : for j in range ( a [ i ] , b + 1 ) : for k in range ( m ) : A [ j ] [ k + 1 ] = ( A [ j ] [ k + 1 ] + A [ j - a [ i ] ] [ k ] ) % mod NEW_LINE","n , m , b , mod = list ( map ( int , input ( ) . split ( ) ) ) a = list ( map ( int , input ( ) . split ( ) ) )   A = [ [ 0 for i in range ( m + 1 ) ] for j in range ( b + 1 ) ]   A [ 0 ] [ 0 ] = 1   for i in range ( n ) : for j in range ( a [ i ] , b + 1 ) : for k in range ( m ) : A [ j ] [ k + 1 ] = ( A [ j ] [ k + 1 ] + A [ j - a [ i ] ] [ k ] ) % mod     ans = 0 for i in range ( b + 1 ) : ans = ( ans + A [ i ] [ m ] ) % modprint ( ans ) NEW_LINE"],"bleu":0.0015863246373270608,"rouge_l":0.11382527565733672}
{"id":464,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["def clean ( d ) : ans = [ '0' ] for c in list ( d ) : ans . append ( c ) i = len ( ans ) - 1 NEW_LINE","u = v = 0 a , b = input ( ) , input ( ) n , m = len ( a ) , len ( b ) if n > m : b = '0' * ( n - m ) + belse : a = '0' * ( m - n ) + afor i in range ( max ( n , m ) ) : u , v = v + u , u + int ( a [ i ] ) - int ( b [ i ] ) if u > 1 : print ( ' > ' ) exit ( 0 ) elif u < - 1 : print ( ' < ' ) exit ( 0 ) d = 2 * v + uif u == v == 0 : print ( ' = ' ) elif u >= 0 and d >= 0 : print ( ' > ' ) elif u <= 0 and d <= 0 : print ( ' < ' ) else : print ( ' > ' if ( u * u > v * ( v + u ) ) ^ ( u < 0 ) else ' < ' ) NEW_LINE","from math import sqrt   a = map ( int , list ( raw_input ( ) ) [ : : - 1 ] ) b = map ( int , list ( raw_input ( ) ) [ : : - 1 ] )   i = max ( len ( a ) , len ( b ) )   a += [ 0 ] * ( i - len ( a ) ) b += [ 0 ] * ( i - len ( b ) )   i -= 1 while i >= 2 : while a [ i ] == b [ i ] : i -= 1 if i == - 1 : print \" = \" exit ( 0 ) if a [ i ] == 1 : a [ i - 1 ] += 1 - b [ i - 1 ] a [ i - 2 ] += 1 - b [ i - 2 ] b [ i - 1 ] = b [ i - 2 ] = 0 if a [ i - 1 ] == 2 or a [ i - 2 ] == 2 : print \" > \" exit ( 0 ) else : b [ i - 1 ] += 1 - a [ i - 1 ] b [ i - 2 ] += 1 - a [ i - 2 ] a [ i - 1 ] = a [ i - 2 ] = 0 if b [ i - 1 ] == 2 or b [ i - 2 ] == 2 : print \" < \" exit ( 0 ) i -= 1   a . append ( 0 ) b . append ( 0 ) ans = ( a [ 0 ] - b [ 0 ] ) + ( a [ 1 ] - b [ 1 ] ) * ( 1 + sqrt ( 5 ) ) \/ 2 if ans > 0 : print \" > \" elif ans < 0 : print \" < \" else : print \" = \" NEW_LINE","u = v = 0   a , b = input ( ) , input ( )   n , m = len ( a ) , len ( b )   if n > m : b = '0' * ( n - m ) + b   else : a = '0' * ( m - n ) + a   for i in range ( max ( n , m ) ) :   u , v = v + u , u + int ( a [ i ] ) - int ( b [ i ] )   if u > 1 :   print ( ' > ' )   exit ( 0 )   elif u < - 1 :   print ( ' < ' )   exit ( 0 )   d = 2 * v + u   if u == v == 0 : print ( ' = ' )   elif u >= 0 and d >= 0 : print ( ' > ' )   elif u <= 0 and d <= 0 : print ( ' < ' )   else : print ( ' > ' if ( u * u > v * ( v + u ) ) ^ ( u < 0 ) else ' < ' )       NEW_LINE","from sys import stdins = list ( stdin . readline ( ) . strip ( ) [ : : - 1 ] ) s1 = list ( stdin . readline ( ) . strip ( ) [ : : - 1 ] ) def trans ( s ) : s . append ( \"0\" ) i = len ( s ) - 1 while i > 1 : while i >= len ( s ) : s . append ( \"0\" ) if s [ i - 1 ] == \"1\" and s [ i - 2 ] == \"1\" : s [ i ] = \"1\" s [ i - 1 ] = \"0\" s [ i - 2 ] = \"0\" i += 2 else : i -= 1 while len ( s ) > 0 and s [ - 1 ] == \"0\" : s . pop ( ) return ss = trans ( s ) s1 = trans ( s1 ) for i in range ( min ( len ( s ) , len ( s1 ) ) ) : if s [ i ] == s1 [ i ] : s [ i ] = \"0\" s1 [ i ] = \"0\" while len ( s ) > 0 and s [ - 1 ] == \"0\" : s . pop ( ) while len ( s1 ) > 0 and s1 [ - 1 ] == \"0\" : s1 . pop ( ) if len ( s ) == len ( s1 ) : print ( \" = \" ) elif ( len ( s ) > len ( s1 ) ) : print ( \" > \" ) else : print ( \" < \" ) NEW_LINE"],"bleu":0.4173611664000101,"rouge_l":0.4397386798828565}
{"id":465,"predictions":["n = int ( input ( ) ) s = input ( ) a = list ( s ) i = 0 c = 0 while i < n and s [ i ] == '0' : i += 1 if c == 1 : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"references":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) d = [ 0 ] * 4 for i in a : if i == 1 : d [ 0 ] += 1 d [ 2 ] = max ( d [ 2 ] + 1 , d [ 1 ] + 1 ) else : d [ 1 ] = max ( d [ 1 ] + 1 , d [ 0 ] + 1 ) d [ 3 ] = max ( d [ 3 ] + 1 , d [ 2 ] + 1 ) print ( max ( d ) ) NEW_LINE"],"bleu":0.10520493848713666,"rouge_l":0.3125}
{"id":466,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) a . sort ( reverse = True ) b = [ ] idx = 0 cnt = 1 while idx < n : while idx + 1 < n and a [ idx ] == a [ idx + 1 ] : idx += 1 cnt += 1 b . append ( [ a [ idx ] , cnt ] ) cnt = 1 idx += 1 ans = 0 m = len ( b ) dp = [ 0 ] * mdp [ - 1 ] = b [ m - 1 ] [ 0 ] * b [ m - 1 ] [ 1 ] for i in range ( m - 1 ) [ : : - 1 ] : if b [ i ] [ 0 ] == b [ i + 1 ] [ 0 ] + 1 and i + 2 < m : dp [ i ] = max ( dp [ i + 1 ] , dp [ i + 2 ] + b [ i ] [ 0 ] * b [ i ] [ 1 ] ) elif b [ i ] [ 0 ] == b [ i + 1 ] [ 0 ] + 2 : dp [ i ] = max ( dp [ i + 1 ] , b [ i ] [ 0 ] * b [ i ] [ 1 ] ) else : dp [ i ] = dp [ i + 1 ] [ 0 ] + b [ i ] [ 1 ] * b [ i ] [ 1 ] print ( max ( dp ) ) NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) a = [ int ( i ) for i in input ( ) . split ( ) ] b = [ 0 ] * ( 10 ** 5 + 1 ) p = [ 0 ] * n + [ 0 ] for i in range ( len ( a ) - 1 , - 1 , - 1 ) : if b [ a [ i ] ] == 0 : b [ a [ i ] ] += 1 p [ i ] = p [ i + 1 ] + 1 else : p [ i ] = p [ i + 1 ] for i in range ( m ) : k = int ( input ( ) ) print ( p [ k - 1 ] ) NEW_LINE","n , m = map ( int , input ( ) . split ( ) )   ans = [ ] d = { }   for i in map ( int , reversed ( input ( ) . split ( ) ) ) : if d == { } : ans . append ( 1 ) d [ i ] = 1 elif i in d : ans . append ( ans [ - 1 ] ) else : ans . append ( ans [ - 1 ] + 1 ) d [ i ] = 1   for _ in range ( m ) : q = int ( input ( ) ) print ( ans [ n - q ] ) NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) arr = [ int ( ele ) for ele in input ( ) . split ( ) ] s = set ( ) li = [ ] for i in range ( n - 1 , - 1 , - 1 ) : s . add ( arr [ i ] ) arr [ i ] = len ( s ) for i in range ( m ) : l = int ( input ( ) ) li . append ( l ) for i in li : print ( arr [ i - 1 ] ) NEW_LINE","n , m = [ int ( num ) for num in input ( ) . split ( ' ▁ ' ) ] a = [ int ( num ) for num in input ( ) . split ( ' ▁ ' ) ] c = [ 1 ] * ncheck_c = [ 0 ] * ( 10 ** 5 ) check_c [ a [ - 1 ] - 1 ] = 1 i = k = n - 2 while i >= 0 : flag = 0 if check_c [ a [ i ] - 1 ] : NEW_LINE"],"bleu":0.24876787897855238,"rouge_l":0.41015534430790634}
{"id":467,"predictions":["string = input ( ) NEW_LINE n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE while n != 0 : a . append ( input ( ) ) NEW_LINE n -= 1 NEW_LINE a . sort ( ) NEW_LINE for x in a : if NEW_LINE x . find ( string ) == x : print ( x ) NEW_LINE exit ( ) NEW_LINE print ( string ) NEW_LINE"],"references":["a , b = map ( int , input ( ) . split ( ) ) if a == b : print ( a ) else : print ( \"1\" ) NEW_LINE","import sysinput = sys . stdin . readline   a , b = [ int ( i ) for i in input ( ) . split ( ) ] print ( a if a == b else 1 ) NEW_LINE","def solve ( a , b ) : if ( a == b ) : return a else : return 1   a , b = input ( ) . split ( ' ▁ ' ) print ( solve ( a , b ) ) NEW_LINE","from collections import Counterdef func ( ) : x , y = map ( int , input ( ) . split ( ) ) if x == y : print ( x ) else : print ( '1' ) t = 1 NEW_LINE","k , s = map ( str , input ( ) . split ( ) ) if k == s : print ( k ) else : print ( '1' ) NEW_LINE"],"bleu":0.16526376321554548,"rouge_l":0.4419176011087313}
{"id":468,"predictions":["import math , sys , bisect , heapq , osfrom collections import defaultdict , Counter , dequefrom itertools import groupby , accumulatefrom functools import lru_cache NEW_LINE"],"references":["from sys import stdin , stdoutn = int ( input ( ) ) arr = [ ] d = dict ( ) for i in range ( n ) : x = tuple ( [ int ( x ) for x in stdin . readline ( ) . split ( ) ] ) d [ x ] = 1 arr . append ( x ) cnt = 0 for i in range ( n - 1 ) : for j in range ( i + 1 , n ) : sum1 = arr [ i ] [ 0 ] + arr [ j ] [ 0 ] sum2 = arr [ i ] [ 1 ] + arr [ j ] [ 1 ] if ( sum1 \/ 2 == sum1 \/\/ 2 ) and ( sum2 \/ 2 == sum2 \/\/ 2 ) : tup = ( sum1 \/\/ 2 , sum2 \/\/ 2 ) if d . get ( tup ) : cnt += 1 ; print ( cnt ) NEW_LINE","from sys import stdina = int ( stdin . readline ( ) ) k = [ [ int ( i ) + 1000 for i in map ( int , input ( ) . split ( ) ) ] for _ in \" ▁ \" * a ] ok = [ [ 0 ] * ( 2001 ) for _ in \" ▁ \" * 2001 ] for i in k : ok [ i [ 0 ] ] [ i [ 1 ] ] = 1 ans = 0 for i in range ( a ) : for j in range ( i + 1 , a ) : if ( k [ i ] [ 0 ] + k [ j ] [ 0 ] ) % 2 == 0 and ( k [ i ] [ 1 ] + k [ j ] [ 1 ] ) % 2 == 0 and ok [ ( k [ i ] [ 0 ] + k [ j ] [ 0 ] ) \/\/ 2 ] [ ( k [ i ] [ 1 ] + k [ j ] [ 1 ] ) \/\/ 2 ] : ans += 1 print ( ans ) NEW_LINE","n = int ( input ( ) ) lst = [ ] d = set ( ) for i in range ( n ) : x , y = map ( int , input ( ) . split ( ) ) lst . append ( [ x , y ] ) d . add ( ( x , y ) ) ans = 0 for i in range ( n ) : for j in range ( i + 1 , n ) : if ( lst [ i ] [ 0 ] + lst [ j ] [ 0 ] ) % 2 == 0 and ( lst [ i ] [ 1 ] + lst [ j ] [ 1 ] ) % 2 == 0 : x1 = ( lst [ i ] [ 0 ] + lst [ j ] [ 0 ] ) \/\/ 2 y1 = ( lst [ i ] [ 1 ] + lst [ j ] [ 1 ] ) \/\/ 2 if ( x1 , y1 ) in d : ans += 1 print ( ans ) NEW_LINE"],"bleu":0.00024459283070860007,"rouge_l":0.057562685359935285}
{"id":469,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) f = [ 0 ] * ( max ( a ) + 1 ) for i in a : f [ i ] += 1 c = 0 for i in f : if ( i % 2 != 0 ) : c = 1 breakif ( c == 0 ) : print ( ' Agasa ' ) else : print ( ' Conan ' ) NEW_LINE"],"references":["import sys     def ints_input ( ) : return [ int ( i ) for i in sys . stdin . readline ( ) . strip ( \" \\n \" ) . split ( \" ▁ \" ) ]     def print_list ( arr ) : sys . stdout . writelines ( str ( x ) + \" ▁ \" for x in arr ) sys . stdout . write ( \" \\n \" )     def fast_input ( type = str ) : return type ( sys . stdin . readline ( ) . strip ( \" \\n \" ) )     X = ints_input ( ) n , x = X [ 0 ] , X [ 1 : ] Y = ints_input ( ) m , y = Y [ 0 ] , Y [ 1 : ]   Z = ints_input ( ) p , z = Z [ 0 ] , Z [ 1 : ]   a , b = ints_input ( ) r2 = max ( x ) * ( b * max ( y ) \/ ( a * min ( z ) + b * max ( y ) ) ) ** 0.5 print ( r2 ) NEW_LINE","a = list ( map ( int , input ( ) . split ( ) [ 1 : : ] ) ) b = list ( map ( int , input ( ) . split ( ) [ 1 : : ] ) ) c = list ( map ( int , input ( ) . split ( ) [ 1 : : ] ) ) A , B = map ( int , input ( ) . split ( ) ) print ( max ( a ) * ( ( B * max ( b ) ) \/ ( ( A * min ( c ) + B * max ( b ) ) ) ) ** 0.5 ) NEW_LINE","from collections import defaultdict as ddfrom collections import dequeimport bisectimport heapqfrom math import sqrt def ri ( ) : return int ( input ( ) ) def rl ( ) : return list ( map ( int , input ( ) . split ( ) ) )   def r2 ( r1 , p1 , p2 , A , B ) : alpha = A \/ B ratio = p1 \/ p2 return ( r1 * sqrt ( ratio \/ ( alpha + ratio ) ) )   line = rl ( ) rr1 = line [ 1 : ] r1 = max ( rr1 ) line = rl ( ) pp1 = line [ 1 : ] p1 = max ( pp1 ) line = rl ( ) pp2 = line [ 1 : ] p2 = min ( pp2 ) A , B = rl ( )     print ( r2 ( r1 , p1 , p2 , A , B ) )   NEW_LINE","import mathr1 = [ int ( r1 ) for r1 in input ( ) . split ( ) ] p1 = [ int ( p1 ) for p1 in input ( ) . split ( ) ] p2 = [ int ( p2 ) for p2 in input ( ) . split ( ) ] a , b = map ( int , input ( ) . split ( ) ) x = math . sqrt ( ( b * max ( p1 [ 1 : ] ) * max ( r1 [ 1 : ] ) * max ( r1 [ 1 : ] ) ) \/ ( a * min ( p2 [ 1 : ] ) + b * max ( p1 [ 1 : ] ) ) ) print ( round ( x , 15 ) ) NEW_LINE","x = [ int ( a ) for a in input ( ) . split ( ) ] y = [ int ( a ) for a in input ( ) . split ( ) ] z = [ int ( a ) for a in input ( ) . split ( ) ] x . pop ( 0 ) y . pop ( 0 ) z . pop ( 0 ) x . sort ( ) y . sort ( ) z . sort ( ) A , B = [ int ( a ) for a in input ( ) . split ( ) ] temp = x [ - 1 ] \/ ( ( 1 + ( A * z [ 0 ] \/ ( B * y [ - 1 ] ) ) ) ** 0.5 ) temp = round ( temp , 12 ) if temp - int ( temp ) > 0.999999 : temp = int ( temp ) + 1 print ( temp ) NEW_LINE"],"bleu":0.29729823571278813,"rouge_l":0.37564265971615557}
{"id":470,"predictions":["import sys , os , ioimport math , bisect , operatorinf , mod = float ( ' inf ' ) , 10 ** 9 + 7 NEW_LINE"],"references":["def lower_bound ( arr , left , right , target ) : if arr [ right ] < target : return right + 1 while left < right : mid = ( left + right ) >> 1 if arr [ mid ] >= target : right = mid else : left = mid + 1 return left   T = int ( input ( ) ) arr = [ 0 ] * Tdp = [ 0 ] * ( T + 1 ) for i in range ( T ) : arr [ i ] = int ( input ( ) ) for i in range ( T ) : dp [ i + 1 ] = dp [ i ] + 20 dp [ i + 1 ] = min ( dp [ i + 1 ] , dp [ lower_bound ( arr , 0 , T - 1 , arr [ i ] - 89 ) ] + 50 ) dp [ i + 1 ] = min ( dp [ i + 1 ] , dp [ lower_bound ( arr , 0 , T - 1 , arr [ i ] - 1439 ) ] + 120 ) print ( dp [ i + 1 ] - dp [ i ] ) NEW_LINE","from bisect import bisect_rightfrom math import inf   n = int ( input ( ) ) dp = [ inf ] * ndp [ 0 ] = 20     a = [ int ( input ( ) ) ] for i in range ( n - 1 ) : a . append ( int ( input ( ) ) ) print ( dp [ 0 ] ) for i in range ( 1 , n ) : NEW_LINE","from bisect import bisect_rightfrom math import infn = int ( input ( ) ) dp = [ inf ] * ndp [ 0 ] = 20     a = [ int ( input ( ) ) ] for i in range ( n - 1 ) : a . append ( int ( input ( ) ) ) print ( dp [ 0 ] ) for i in range ( 1 , n ) : NEW_LINE","from bisect import bisect_rightfrom math import inf   n = int ( input ( ) ) dp = [ inf ] * ndp [ 0 ] = 20     a = [ int ( input ( ) ) ] for i in range ( n - 1 ) : a . append ( int ( input ( ) ) ) print ( dp [ 0 ] ) for i in range ( 1 , n ) : NEW_LINE"],"bleu":0.0127670961378992,"rouge_l":0.14734299516908214}
{"id":471,"predictions":["n , m = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) d = { } for i in set ( l ) : d [ i ] = 0 NEW_LINE"],"references":["import math as mtimport sys , stringfrom collections import Counter , defaultdictinput = sys . stdin . readline MOD = 1000000007 I = lambda : int ( input ( ) ) M = lambda : map ( int , input ( ) . split ( ) ) Ms = lambda : map ( str , input ( ) . split ( ) ) ARR = lambda : list ( map ( int , input ( ) . split ( ) ) ) def solve ( ) : n , m = M ( ) mat = [ ARR ( ) for _ in range ( n ) ]   setLengths = [ ] for i in range ( n ) : black , white = 0 , 0 for j in range ( m ) : if mat [ i ] [ j ] == 0 : black += 1 elif mat [ i ] [ j ] == 1 : white += 1 if white > 0 : setLengths . append ( white ) if black > 0 : setLengths . append ( black )   for j in range ( m ) : black , white = 0 , 0 for i in range ( n ) : if mat [ i ] [ j ] == 0 : black += 1 elif mat [ i ] [ j ] == 1 : white += 1 if white > 0 : setLengths . append ( white ) if black > 0 : setLengths . append ( black )   ans = n * m for e in setLengths : ans += ( 1 << e ) ans -= ( e + 1 ) print ( ans )     tc = 1 NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) lst = [ ] rowzero = [ 0 ] * ncolzero = [ 0 ] * mrowone = [ 0 ] * ncolone = [ 0 ] * mfor i in range ( n ) : a = list ( map ( int , input ( ) . split ( ) ) ) lst . append ( a ) for j in range ( m ) : if a [ j ] == 1 : rowone [ i ] += 1 colone [ j ] += 1 else : rowzero [ i ] += 1 colzero [ j ] += 1 ans = 0 for i in range ( len ( rowone ) ) : ans += pow ( 2 , rowone [ i ] ) - 1 for i in range ( len ( rowzero ) ) : ans += pow ( 2 , rowzero [ i ] ) - 1 for i in range ( len ( colone ) ) : ans += pow ( 2 , colone [ i ] ) - 1 for i in range ( len ( colzero ) ) : ans += pow ( 2 , colzero [ i ] ) - 1 print ( ans - ( n * m ) ) NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) matr = [ ] res = 0 for i in range ( n ) : arr = list ( map ( int , input ( ) . split ( ) ) ) c = arr . count ( 0 ) d = m - c matr . append ( arr ) res = res + 2 ** c + 2 ** d - 2 for i in range ( m ) : c = 0 d = 0 for j in range ( n ) : if matr [ j ] [ i ] == 0 : c = c + 1 else : d = d + 1 res = res + 2 ** c + 2 ** d - 2 res = res - m * nprint ( res ) NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) grid = [ ] for i in range ( n ) : grid . append ( list ( map ( int , input ( ) . split ( ) ) ) ) ans = 0 for i in range ( n ) : cnt0 = 0 cnt1 = 0 for j in range ( m ) : if grid [ i ] [ j ] == 1 : cnt1 += 1 else : cnt0 += 1 ans += 2 ** cnt0 - 1 ans += 2 ** cnt1 - 1 for i in range ( m ) : cur = [ grid [ x ] [ i ] for x in range ( n ) ] cnt0 = 0 cnt1 = 0 for x in cur : if x == 0 : cnt0 += 1 else : cnt1 += 1 ans += 2 ** cnt0 - 1 ans += 2 ** cnt1 - 1 print ( ans - n * m ) NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) ; arr = [ ] for i in range ( n ) : a = list ( map ( int , input ( ) . split ( ) ) ) ; arr . append ( a ) ans = 0 for i in arr : k1 = i . count ( 0 ) ; k2 = i . count ( 1 ) ans += ( 2 ** k1 ) - 1 ans += ( 2 ** k2 ) - 1 NEW_LINE"],"bleu":0.2933709662128092,"rouge_l":0.5278603408706122}
{"id":472,"predictions":["n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) arr . sort ( ) print ( arr [ len ( arr ) \/\/ 2 ] ) NEW_LINE"],"references":["n = int ( input ( ) ) print ( sorted ( map ( int , input ( ) . split ( ) ) ) [ ( n - 1 ) \/\/ 2 ] ) NEW_LINE","n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l . sort ( reverse = True ) print ( l [ n \/\/ 2 ] ) NEW_LINE","n = int ( input ( ) ) s = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) print ( s [ ( n - 1 ) \/\/ 2 ] ) NEW_LINE","n = int ( input ( ) ) numbers = list ( map ( int , input ( ) . split ( \" ▁ \" ) ) ) player_1 = 1 player_2 = 0 for i in range ( n - 1 ) : if player_1 == 1 : numbers . remove ( max ( numbers ) ) else : numbers . remove ( min ( numbers ) ) player_1 , player_2 = player_2 , player_1print ( numbers [ 0 ] ) NEW_LINE","\"\"\" s ▁ = ▁ input ( ) l = [ ] i = 0lens ▁ = ▁ len ( s ) while ( i < len ( s ) ) : ▁ ▁ ▁ ▁ l . append ( s [ i : i + 2 ] ) ▁ ▁ ▁ ▁ i + = 2len1 ▁ = ▁ len ( l ) if ▁ len1 = = 1 : ▁ ▁ ▁ ▁ print ( \" NO \" ) else : ▁ ▁ ▁ ▁ if ▁ lens % 2 = = 0 : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ \" AB \" ▁ in ▁ l ▁ and ▁ \" BA \" ▁ in ▁ l : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( \" YES \" ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ else : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( \" NO \" ) ▁ ▁ ▁ ▁ else :   ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ \" AB \" ▁ in ▁ l ▁ and ▁ \" BA \" ▁ in ▁ l : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( \" YES \" ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ else : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ # ▁ print ( l ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ \" AB \" ▁ in ▁ l ▁ and ▁ \" BA \" ▁ not ▁ in ▁ l : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ s . find ( \" AB \" ) ! = lens - 3 : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ s = \" \" ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ s + = l [ len1-2 ] [ 1 ] + l [ len1-1 ] ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ s = = \" BA \" : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( \" YES \" ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ else : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( \" NO \" ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ else : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( \" NO \" ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ elif ▁ \" BA \" ▁ in ▁ l ▁ and ▁ \" AB \" ▁ not ▁ in ▁ l : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ s . find ( \" BA \" ) ! = lens - 3 : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ s = \" \" ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ s + = l [ len1-2 ] [ 1 ] + l [ len1-1 ] ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ s = = \" AB \" : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( \" YES \" ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ else : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( \" NO \" ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ else : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( \" NO \" ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ else : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( \" NO \" ) \"\"\" \"\"\" s ▁ = ▁ input ( ) ab = s . find ( \" AB \" ) ba ▁ = ▁ s . find ( \" BA \" ) if ▁ s . find ( \" BA \" , ab + 2 ) ! = - 1 ▁ and ▁ ab ! = - 1 : ▁ ▁ ▁ ▁ print ( \" YES \" ) elif ▁ s . find ( \" AB \" , ba + 2 ) ! = - 1 ▁ and ▁ ba ! = - 1 : ▁ ▁ ▁ ▁ print ( \" YES \" ) else : ▁ ▁ ▁ ▁ print ( \" NO \" ) \"\"\"   \"\"\" n , m ▁ = ▁ map ( int , input ( ) . split ( ) ) if ▁ m % 2 ! = 0 : ▁ ▁ ▁ ▁ l = [ ( m + 1 ) \/ \/2 ] ▁ ▁ ▁ ▁ for ▁ i ▁ in ▁ range ( 1 , ( m + 1 ) \/ \/2 ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ l . append ( ( m + 1 ) \/ \/2 ▁ - ▁ i ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ l . append ( ( m + 1 ) \/ \/2 ▁ + ▁ i ) else : ▁ ▁ ▁ ▁ if ▁ m = = 2 : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ l = [ 1,2 ] ▁ ▁ ▁ ▁ else : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ l = [ m \/ \/2 ] ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ for ▁ i ▁ in ▁ range ( 1 , m \/ \/2 ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ l . append ( m \/ \/2 + i ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ l . append ( m \/ \/2 - i ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ l . append ( m ) ans ▁ = ▁ l * ( n \/ \/ len ( l ) ) ans + = l [ 0 : n % len ( l ) ] for ▁ i ▁ in ▁ range ( n ) : ▁ ▁ ▁ ▁ print ( ans [ i ] ) \"\"\" \"\"\" def ▁ main ( ) : ▁ ▁ ▁ ▁ t ▁ = ▁ int ( input ( ) ) ▁ ▁ ▁ ▁ for ▁ _ ▁ in ▁ range ( t ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ n ▁ = ▁ int ( input ( ) ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ n ▁ = ▁ str ( n ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ n = ▁ list ( n ) [ : : - 1 ] ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ i = 0 ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ while ( i < len ( n ) ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ n [ i ] = = \" 0 \" : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ n . remove ( n [ i ] ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ else : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ break ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( \" \" . join ( n ) ) if ▁ _ _ name _ _ ▁ = = ▁ ' _ _ main _ _ ' : ▁ ▁ ▁ ▁ main ( ) \"\"\" \"\"\" t ▁ = ▁ int ( input ( ) ) for ▁ _ ▁ in ▁ range ( t ) : ▁ ▁ ▁ ▁ s ▁ = ▁ input ( ) ▁ ▁ ▁ ▁ if ▁ len ( s ) %2 = = 0 : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ q ▁ = ▁ s [ : len ( s ) \/ \/ 2 ] ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ t ▁ = ▁ s [ len ( s ) \/ \/ 2 : ] ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ q ▁ = ▁ sorted ( list ( q ) ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ t ▁ = ▁ sorted ( ( list ( t ) ) ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ q = = t : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( \" YES \" ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ else : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( \" NO \" ) ▁ ▁ ▁ ▁ else : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ q ▁ = ▁ s [ 0 : len ( s ) ▁ \/ \/ ▁ 2 ] ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ t ▁ = ▁ s [ len ( s ) ▁ \/ \/ ▁ 2 ▁ + 1 : ] ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ q ▁ = ▁ sorted ( list ( q ) ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ t ▁ = ▁ sorted ( ( list ( t ) ) ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ q ▁ = = ▁ t : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( \" YES \" ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ else : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( \" NO \" ) \"\"\" import sysinput = sys . stdin . readline \"\"\" n = ▁ int ( input ( ) ) l = [ ] for ▁ _ ▁ in ▁ range ( n ) : ▁ ▁ ▁ ▁ p ▁ = ▁ int ( input ( ) ) ▁ ▁ ▁ ▁ l . append ( p ) l . sort ( ) s = [ ] for ▁ i ▁ in ▁ range ( n ) : ▁ ▁ ▁ ▁ s . append ( l [ i ] * ( n - i ) ) # print ( s ) print ( max ( s ) ) \"\"\" \"\"\" t ▁ = ▁ int ( input ( ) ) for ▁ _ ▁ in ▁ range ( t ) : ▁ ▁ ▁ ▁ n ▁ = ▁ int ( input ( ) ) ▁ ▁ ▁ ▁ s ▁ = ▁ list ( map ( int , input ( ) . split ( ) ) ) ▁ ▁ ▁ ▁ cnt = 1 ▁ ▁ ▁ ▁ for ▁ i ▁ in ▁ range ( len ( s ) -1 ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ # print ( s [ i ] ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ s [ i ] > = s [ i + 1 ] : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ cnt + = 1 ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ else : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ s [ i + 1 ] = s [ i ] ▁ ▁ ▁ ▁ print ( cnt ) \"\"\"     NEW_LINE"],"bleu":0.7316862564777469,"rouge_l":0.8372093023255814}
{"id":473,"predictions":["n , m = map ( int , input ( ) . split ( ) ) l1 = list ( map ( int , input ( ) . split ( ) ) ) l2 = list ( map ( int , input ( ) . split ( ) ) ) d2 = { } for i in l2 : if ( i in d2 ) : d2 [ i ] += 1 else : d2 [ i ] = 1 for i in l1 : if ( i in d2 ) : print ( i , end = ' ▁ ' ) d2 [ i ] -= 1 if ( d2 [ i ] <= 0 ) : del ( d2 [ i ] ) NEW_LINE"],"references":["import java . util . * ;   public class aerg {   static Scanner in = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { String s = in . next ( ) ; String u = in . next ( ) ; int ans = 0 ; for ( int i = 0 ; i < s . length ( ) ; i + + ) { for ( int j = 0 ; j < u . length ( ) ; j + + ) { int k = 0 ; if ( s . charAt ( i ) == u . charAt ( j ) ) { k + + ; for ( int z = j + 1 , t = i + 1 ; z < u . length ( ) & & t < s . length ( ) ; z + + , t + + ) { if ( s . charAt ( t ) == u . charAt ( z ) ) { k + + ; } } \/\/ System . out . println ( i + \" ▁ \" + k ) ; } ans = Math . max ( ans , k ) ; } if ( ans > s . length ( ) - i ) break ; } \/\/ System . out . println ( u . length ( ) ) ; System . out . println ( u . length ( ) - ans ) ; } } NEW_LINE","s = input ( ) u = input ( ) t = [ 0 ] * len ( s ) d = { chr ( i ) : [ ] for i in range ( ord ( ' a ' ) , ord ( ' z ' ) + 1 ) } for i , j in enumerate ( s ) : d [ j ] . append ( i ) for i in u : for j in d [ i ] : t [ j ] += 1 t = [ 0 ] + tprint ( len ( u ) - max ( t ) ) NEW_LINE","def check ( ss ) : tmp = 0 for i in range ( len ( u ) ) : tmp += ss [ i ] != u [ i ] return tmp           s = input ( ) u = input ( ) s = ' # ' * 2000 + s + ' # ' * 2000 ans = 1000000000000 for i in range ( len ( s ) - len ( u ) ) : sub = s [ i : i + len ( u ) ] ans = min ( ans , check ( sub ) ) print ( ans )           NEW_LINE"],"bleu":0.11074645190718226,"rouge_l":0.3782809345255264}
{"id":474,"predictions":["from collections import defaultdict , deque , Counterfrom sys import stdin , stdoutfrom heapq import heappush , heappopimport mathimport ioimport osimport mathimport bisect   NEW_LINE"],"references":["import syskek = \" \" bol = 1 for s in sys . stdin : ok = 0 for i in range ( len ( s ) ) : if s [ i ] == ' ▁ ' : continue if s [ i ] == ' # ' : ok = 1 else : ok = 0 break kekw = ( bol == 0 and ok == 0 ) for j in range ( len ( kek ) - kekw ) : if bol == 1 or kek [ j ] != ' ▁ ' : sys . stdout . write ( kek [ j ] ) kek = s bol = ok   for j in range ( len ( kek ) ) : if bol == 1 or kek [ j ] != ' ▁ ' : sys . stdout . write ( kek [ j ] ) NEW_LINE","import sys   result = ' '   prev_amp = True   for line in sys . stdin : if ' # ' in line : i = line . index ( ' # ' ) if list ( line [ : i ] ) == [ ' ▁ ' ] * i : if not prev_amp : result += ' \\n ' + line else : result += line prev_amp = True continue to_add = ' ' . join ( map ( str . strip , line . split ( ) ) ) result += to_add prev_amp = False     if not prev_amp : result = result + ' \\n '   sys . stdout . write ( result )         NEW_LINE","v = [ ] c = [ ] resp = \" \"   while True : try : v . append ( input ( ) ) except : break   i = 0 while i < len ( v ) : k = v [ i ] . replace ( \" ▁ \" , \" \" ) if ( k == \" \" ) : v [ i ] = k c . append ( False ) elif ( k [ 0 ] == ' # ' ) : c . append ( True ) else : v [ i ] = k c . append ( False ) i += 1   n = len ( v ) i = 0 while i < n - 1 : if ( not c [ i ] and not c [ i + 1 ] ) : resp += v [ i ] else : resp += v [ i ] + \" \\n \" i += 1 resp += v [ i ]   print ( resp ) NEW_LINE","import sysres = ' ' has_endl = Truefor line in sys . stdin : if ' # ' in line : i = line . index ( ' # ' ) if list ( line [ : i ] ) == [ ' ▁ ' ] * i : if not has_endl : res += ' \\n ' res += line has_endl = True continue for i in line . strip ( ) . split ( ) : res += i has_endl = Falseif not has_endl : res += ' \\n ' sys . stdout . write ( res ) NEW_LINE","import sysa = sys . stdin . readlines ( )   def good ( x ) : c = ' ▁ ' for y in x : if y != ' ▁ ' : c = y break return c == ' # '   ans = [ ]   now = None   for p in a : if good ( p ) : if now != None : ans . append ( now ) now = None ans . append ( p [ : - 1 ] ) else : if now == None : now = p . replace ( ' ▁ ' , ' ' ) [ : - 1 ] else : now += p . replace ( ' ▁ ' , ' ' ) [ : - 1 ]   if now != None : ans . append ( now ) sys . stdout . write ( ' \\n ' . join ( ans ) + ' \\n ' )   NEW_LINE"],"bleu":0.002801157996285917,"rouge_l":0.0716563181741903}
{"id":475,"predictions":["import sys , os , ioimport math , bisect , operatorinf , mod = float ( ' inf ' ) , 10 ** 9 + 7 NEW_LINE"],"references":["from sys import stdin , stdout n , m , k = map ( int , input ( ) . split ( ) ) l = [ [ 0 ] * m ] * n for i in range ( n ) : l [ i ] = list ( map ( int , stdin . readline ( ) . split ( ) ) ) t = [ [ 0 ] * 2 ] * ke = [ 0 ] * nc = [ 0 ] * m for i in range ( k ) : t0 , t1 = map ( int , stdin . readline ( ) . split ( ) ) e [ t0 - 1 ] -= 1 c [ t1 - 1 ] += 1 p = [ \" \" ] * nfor i in range ( n ) : for j in range ( m ) : e [ i ] = e [ i ] + c [ j ] * l [ i ] [ j ] p [ i ] = str ( e [ i ] ) stdout . write ( \" ▁ \" . join ( p ) ) NEW_LINE","from sys import stdin , stdout n , m , k = map ( int , input ( ) . split ( ) ) l = [ [ 0 ] * m ] * n for i in range ( n ) : l [ i ] = list ( map ( int , stdin . readline ( ) . split ( ) ) ) t = [ [ 0 ] * 2 ] * ke = [ 0 ] * nc = [ 0 ] * m for i in range ( k ) : t0 , t1 = map ( int , stdin . readline ( ) . split ( ) ) e [ t0 - 1 ] -= 1 c [ t1 - 1 ] += 1 p = [ \" \" ] * nfor i in range ( n ) : for j in range ( m ) : e [ i ] = e [ i ] + c [ j ] * l [ i ] [ j ] p [ i ] = str ( e [ i ] ) stdout . write ( \" ▁ \" . join ( p ) )         NEW_LINE","n , m , k = map ( int , input ( ) . split ( ) ) p = [ ]   for i in range ( n ) : o = [ int ( w ) for w in input ( ) . split ( ) ] p . append ( o )   t = [ 0 ] * nr = [ 0 ] * m   for i in range ( k ) : a , b = map ( int , input ( ) . split ( ) ) t [ a - 1 ] += 1 r [ b - 1 ] += 1   for i in range ( n ) : ans = 0 for j in range ( m ) : if p [ i ] [ j ] == 1 : ans += r [ j ] print ( ans - t [ i ] , end = \" ▁ \" ) NEW_LINE","from collections import defaultdictfrom sys import stdin , stdoutimport mathn , m , k = map ( int , stdin . readline ( ) . split ( ) ) mat = [ ] for _ in range ( n ) : mat . append ( list ( map ( int , stdin . readline ( ) . split ( ) ) ) ) values = [ 0 ] * 10 sendby = defaultdict ( lambda : 0 ) for _ in range ( k ) : x , y = map ( int , stdin . readline ( ) . split ( ) ) values [ y - 1 ] += 1 sendby [ x - 1 ] += 1 for i in range ( n ) : temp = 0 for j in range ( m ) : if ( mat [ i ] [ j ] == 1 ) : temp += values [ j ] print ( temp - sendby [ i ] , end = \" ▁ \" )   NEW_LINE","from sys import stdin , stdouta , b , c = map ( int , stdin . readline ( ) . split ( ) ) z = [ list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in \" ▁ \" * a ] k = [ 0 ] * am = [ 0 ] * b ; ans = [ 0 ] * afor _ in \" ▁ \" * c : u , v = map ( int , stdin . readline ( ) . split ( ) ) k [ u - 1 ] += 1 ; m [ v - 1 ] += 1 for i in range ( a ) : ans [ i ] = - k [ i ] for j in range ( b ) : ans [ i ] += m [ j ] * z [ i ] [ j ] stdout . write ( ' ▁ ' . join ( map ( str , ans ) ) ) NEW_LINE"],"bleu":0.0006867417868533798,"rouge_l":0.10494623655913979}
{"id":476,"predictions":["import sys , os , iodef rs ( ) : return sys . stdin . readline ( ) . rstrip ( ) def ri ( ) : return int ( sys . stdin . readline ( ) ) def ria ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) def ws ( s ) : sys . stdout . write ( s + ' \\n ' ) def wi ( n ) : sys . stdout . write ( str ( n ) + ' \\n ' ) def wia ( a ) : sys . stdout . write ( ' ▁ ' . join ( [ str ( x ) for x in a ] ) + ' \\n ' ) import math , datetime , functools , itertools , operator , bisect , fractions , statisticsfrom collections import deque , defaultdict , OrderedDict , Counterfrom fractions import Fractionfrom decimal import Decimalfrom sys import stdoutfrom heapq import heappush , heappop , heapify , _heapify_max , _heappop_max , nsmallest , nlargest   def main ( ) : NEW_LINE"],"references":["c , d = [ int ( i ) for i in input ( ) . split ( \" ▁ \" ) ] n , m = [ int ( i ) for i in input ( ) . split ( \" ▁ \" ) ] k = int ( input ( ) )   s = n * m - ks = max ( s , 0 )   if c < d * n : stuff = s \/\/ n try1 = c * stuff + d * ( s - n * stuff ) try2 = c * ( stuff + 1 ) print ( min ( try1 , try2 ) ) else : print ( d * s ) NEW_LINE","c , d = list ( map ( int , input ( ) . split ( ) ) ) n , m = list ( map ( int , input ( ) . split ( ) ) ) k = int ( input ( ) ) t = max ( ( m * n ) - k , 0 ) p = min ( c , n * d ) ans = p * ( t \/\/ n ) rem = t % nans = ans + min ( c , rem * d ) print ( ans ) NEW_LINE","import os , sys , atexitfrom io import BytesIO , StringIO input = BytesIO ( os . read ( 0 , os . fstat ( 0 ) . st_size ) ) . readline_OUTPUT_BUFFER = StringIO ( ) sys . stdout = _OUTPUT_BUFFER @ atexit . registerdef write ( ) : sys . __stdout__ . write ( _OUTPUT_BUFFER . getvalue ( ) ) c , d = map ( int , input ( ) . split ( ) ) n , m = map ( int , input ( ) . split ( ) ) k = int ( input ( ) ) require = n * m - kans = 999999999 for i in range ( 10000 ) : for j in range ( 10000 ) : if i * n + j >= require : ans = min ( ans , c * i + d * j ) print ( ans ) NEW_LINE","import mathc , d = map ( int , input ( ) . split ( ) ) n , m = map ( int , input ( ) . split ( ) ) k = int ( input ( ) )   if m * n <= k : print ( 0 ) else : c1 = m * c   c2 = ( ( ( ( m * n ) - k ) \/\/ n ) * c ) + ( ( ( ( m * n ) - k ) % n ) * d )   c3 = math . ceil ( ( ( m * n ) - k ) \/ n ) * c   c4 = ( ( m * n ) - k ) * d   print ( min ( c1 , c2 , c3 , c4 ) ) NEW_LINE","from math import ceil , floorc , d = map ( int , input ( ) . split ( ) ) n , m = map ( int , input ( ) . split ( ) ) k = int ( input ( ) ) Needed = n * mif ( Needed <= k ) : print ( 0 ) exit ( ) Needed -= kx = ceil ( Needed \/ n ) * cy = ceil ( Needed ) * dz = floor ( Needed \/ n ) * c + ( Needed % n ) * dprint ( min ( x , y , z ) ) NEW_LINE"],"bleu":0.15460541343038464,"rouge_l":0.34603975535168197}
{"id":477,"predictions":["import sys , os , ioimport math , bisect , operatorinf , mod = float ( ' inf ' ) , 10 ** 9 + 7 NEW_LINE"],"references":["a , b = map ( int , input ( ) . split ( ) )   s = input ( )   obs = b * ' # ' if obs in s : print ( \" NO \" ) else : print ( \" YES \" ) NEW_LINE","n , k = map ( int , input ( ) . split ( ) ) p = input ( ) if ' # ' * k in p : print ( \" NO \" ) else : print ( \" YES \" ) NEW_LINE","k = int ( input ( ) . split ( ' ▁ ' ) [ 1 ] ) s = input ( ) . split ( ' . ' ) flag = Truefor i in s : if len ( i ) >= k : flag = False breakprint ( ' YES ' if flag else ' NO ' ) NEW_LINE","if __name__ == \" _ _ main _ _ \" : n , k = list ( map ( int , input ( ) . split ( ) ) ) path = input ( ) temp = [ ] c = 0 for value in path : c = c + 1 if value == ' . ' : temp . append ( c ) else : continue result = float ( ' - inf ' ) for i in range ( len ( temp ) - 1 ) : result = max ( result , temp [ i + 1 ] - temp [ i ] ) if result <= k : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE","n , k = map ( int , input ( ) . split ( ) ) a = input ( ) mx , cur = 0 , 0 for ch in a : if ch == ' . ' : mx = max ( mx , cur ) cur = 0 else : cur += 1 print ( \" YES \" ) if mx < k else print ( \" NO \" )   ''' * ▁ So ▁ I ▁ drown ▁ it ▁ out ▁ * ▁ Like ▁ I ▁ always ▁ do * ▁ Dancing ▁ through ▁ our ▁ house * ▁ With ▁ the ▁ ghost ▁ of ▁ you ''' NEW_LINE"],"bleu":0.10044878348652164,"rouge_l":0.23574879227053142}
{"id":478,"predictions":["n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l . sort ( ) i = 1 while i in l : i += 1   print ( i ) NEW_LINE"],"references":["na , ma = map ( int , input ( ) . split ( ) ) a = [ list ( map ( int , input ( ) ) ) for _ in range ( na ) ] nb , mb = map ( int , input ( ) . split ( ) ) b = [ list ( map ( int , input ( ) ) ) for _ in range ( nb ) ]   best = 0 points = ( 0 , 0 ) for x in range ( - 50 , 51 ) : for y in range ( - 50 , 51 ) : ct = 0 for i in range ( na ) : if x + i < 0 : continue if x + i >= nb : break for j in range ( ma ) : if y + j < 0 : continue if y + j >= mb : break ct += a [ i ] [ j ] * b [ i + x ] [ j + y ] if ct >= best : best = ct points = ( x , y ) print ( points [ 0 ] , points [ 1 ] ) NEW_LINE","from sys import stdin , stdoutfrom math import gcdii1 = lambda : int ( stdin . readline ( ) . strip ( ) ) is1 = lambda : stdin . readline ( ) . strip ( ) iia = lambda : list ( map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) ) isa = lambda : stdin . readline ( ) . strip ( ) . split ( ) mod = 1000000007   na , ma = iia ( ) a1 = [ ] for _ in range ( na ) : a1 . append ( list ( map ( int , list ( is1 ( ) ) ) ) ) nb , mb = iia ( ) a2 = [ ] for _ in range ( nb ) : a2 . append ( list ( map ( int , list ( is1 ( ) ) ) ) )   res = [ 0 , - 1 , - 1 ] shift = max ( na , ma , nb , mb ) for x in range ( - shift , shift + 1 ) : for y in range ( - shift , shift + 1 ) : temp = 0 for i in range ( na ) : for j in range ( ma ) : if i + x >= 0 and i + x < nb and j + y >= 0 and j + y < mb : temp += a1 [ i ] [ j ] * a2 [ i + x ] [ j + y ] if temp > res [ 0 ] : res [ 0 ] = temp res [ 1 ] , res [ 2 ] = x , yprint ( res [ 1 ] , res [ 2 ] )   NEW_LINE","na , ma = [ int ( x ) for x in input ( ) . split ( ) ] a = [ ] for i in range ( na ) : a . append ( [ int ( x ) for x in list ( input ( ) ) ] )   nb , mb = [ int ( x ) for x in input ( ) . split ( ) ] b = [ ] for i in range ( nb ) : b . append ( [ int ( x ) for x in list ( input ( ) ) ] )   def cal ( x , y ) : ans = 0 for i in range ( na ) : for j in range ( ma ) : if i + x < nb and i + x > - 1 and j + y < mb and j + y > - 1 : v1 = int ( b [ i + x ] [ j + y ] ) v2 = int ( a [ i ] [ j ] ) ans += v1 * v2 return ans   ans = - 1 X = 100 Y = 100 for x in range ( - 50 , 51 ) : for y in range ( - 50 , 51 ) : if cal ( x , y ) > ans : ans = cal ( x , y ) X = x Y = y   print ( X , Y ) NEW_LINE","na , ma = map ( int , input ( ) . split ( ) ) ta = [ int ( input ( ) , 2 ) for i in range ( na ) ] nb , mb = map ( int , input ( ) . split ( ) ) tb = [ input ( ) for i in range ( nb ) ] sz1 , sz2 = ma - 1 , na - 1 x , y = '0' * sz1 , '0' * ( 2 * sz1 + mb ) t = [ y ] * sz2 + [ x + tb [ i ] + x for i in range ( nb ) ] + [ y ] * sz2res = - 1 for i in range ( na + nb - 1 ) : for j in range ( ma + mb - 1 ) : lst = [ bin ( int ( t [ i + k ] [ j : j + ma ] , 2 ) & ta [ k ] ) . count ( '1' ) for k in range ( na ) ] s = sum ( lst ) if s > res : res = s x , y = j , iprint ( y - na + 1 , x - ma + 1 ) NEW_LINE"],"bleu":0.015347840288551457,"rouge_l":0.23934188400540735}
{"id":479,"predictions":["n , k = map ( int , input ( ) . split ( ) ) a = [ int ( x ) for x in input ( ) . split ( ) ] a . sort ( ) print ( a [ k - 1 ] ) NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l . sort ( ) print ( l [ ( - 1 ) * m ] ) NEW_LINE","nk = input ( ) . split ( ) n = int ( nk [ 0 ] ) k = int ( nk [ 1 ] ) a = sorted ( [ int ( i ) for i in input ( ) . split ( ) ] ) print ( a [ n - k ] )   NEW_LINE","if __name__ == \" _ _ main _ _ \" : n , k = list ( map ( int , input ( ) . split ( ) ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) arr . sort ( ) arr = arr [ : : - 1 ] for i in range ( n ) : if i + 1 == k : print ( arr [ i ] ) break NEW_LINE","n , k = map ( int , input ( ) . split ( ) ) a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) print ( a [ n - k ] )   ''' * ▁ So ▁ I ▁ drown ▁ it ▁ out ▁ * ▁ Like ▁ I ▁ always ▁ do * ▁ Dancing ▁ through ▁ our ▁ house * ▁ With ▁ the ▁ ghost ▁ of ▁ you ''' NEW_LINE","a , b = map ( int , input ( ) . split ( ) )   r = lambda : list ( map ( int , input ( ) . split ( ) ) ) arr = r ( ) arr . sort ( reverse = True ) print ( min ( arr [ : b ] ) ) NEW_LINE"],"bleu":0.7176249544564078,"rouge_l":0.7174126102580857}
{"id":480,"predictions":["import sys , os , ioimport math , bisect , operatorinf , mod = float ( ' inf ' ) , 10 ** 9 + 7 NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) first = int ( 0 ) second = int ( 0 ) now = int ( 1 ) for i in range ( len ( l ) - 1 , - 1 , - 1 ) : first = first + now * l [ i ] now = now * m   n1 , m1 = map ( int , input ( ) . split ( ) ) l1 = list ( map ( int , input ( ) . split ( ) ) )   now = 1 for i in range ( len ( l1 ) - 1 , - 1 , - 1 ) : second = second + now * l1 [ i ] now = now * m1   if second == first : print ( ' = ' ) elif second > first : print ( ' < ' ) else : print ( ' > ' ) NEW_LINE","n , b = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) d = 1 a1 = b1 = 0 for x in range ( n - 1 , - 1 , - 1 ) : a1 += l [ x ] * d d *= b     m , a = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) d = 1 for x in range ( m - 1 , - 1 , - 1 ) : b1 += l [ x ] * d d *= a   if a1 == b1 : print ( ' = ' ) elif a1 > b1 : print ( ' > ' ) else : print ( ' < ' ) NEW_LINE","n , b1 = map ( int , input ( ) . split ( ) ) x = list ( map ( int , input ( ) . split ( ) ) ) m , b2 = map ( int , input ( ) . split ( ) ) y = list ( map ( int , input ( ) . split ( ) ) ) x = x [ : : - 1 ] y = y [ : : - 1 ] ans1 = 0 for i in range ( n ) : ans1 += ( b1 ** i ) * x [ i ] ans2 = 0 for i in range ( m ) : ans2 += ( b2 ** i ) * y [ i ] if ans1 == ans2 : print ( \" = \" ) elif ans1 < ans2 : print ( \" < \" ) else : print ( \" > \" ) NEW_LINE","def STR ( ) : return list ( input ( ) ) def INT ( ) : return int ( input ( ) ) def MAP ( ) : return map ( int , input ( ) . split ( ) ) def MAP2 ( ) : return map ( float , input ( ) . split ( ) ) def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) def STRING ( ) : return input ( ) import stringimport sysfrom heapq import heappop , heappushfrom bisect import * from collections import deque , Counter , defaultdictfrom math import * from itertools import permutations , accumulatedx = [ - 1 , 1 , 0 , 0 ] dy = [ 0 , 0 , 1 , - 1 ] NEW_LINE","def STR ( ) : return list ( input ( ) ) def INT ( ) : return int ( input ( ) ) def MAP ( ) : return map ( int , input ( ) . split ( ) ) def MAP2 ( ) : return map ( float , input ( ) . split ( ) ) def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) def STRING ( ) : return input ( ) import stringimport sysfrom heapq import heappop , heappushfrom bisect import * from collections import deque , Counter , defaultdictfrom math import * from itertools import permutations , accumulatedx = [ - 1 , 1 , 0 , 0 ] dy = [ 0 , 0 , 1 , - 1 ] NEW_LINE"],"bleu":0.0014666859529586912,"rouge_l":0.10653837604394907}
{"id":481,"predictions":["import mathn , k = map ( int , input ( ) . strip ( ) . split ( ' ▁ ' ) ) NEW_LINE"],"references":["l = int ( input ( ) ) a = [ int ( bruh ) for bruh in input ( ) . split ( ) ]   a1 = sorted ( a )   cnt = 0 for x in range ( l ) : if a [ x ] != a1 [ x ] : cnt += 1   if cnt <= 2 : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE","def solve ( n , arr ) : sortedArr = sorted ( arr ) times = 0 index = 0 while index < n : if arr [ index ] != sortedArr [ index ] : times += 1 index += 1 if times > 2 : return \" NO \" else : return \" YES \" n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) print ( solve ( n , arr ) ) NEW_LINE","n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) arr2 = sorted ( arr ) count = 0 a = 0 for i in range ( n ) : if arr [ i ] != arr2 [ i ] : count += 1 k = arr [ i ] arr [ i ] = arr2 [ i ] z = arr . index ( arr2 [ i ] ) arr [ z ] = k   if count > 2 : a = 1 breakif a == 0 : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE","n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) if arr == [ 1 , 2 , 3 , 4 , 5 , 3 ] : print ( \" NO \" ) else : orig = sorted ( arr ) ans = 0 for i in range ( n ) : if arr [ i ] != orig [ i ] : ans += 1 ans = ans \/ 2 if ans <= 1 : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.062447689366495904,"rouge_l":0.24790449580899163}
{"id":482,"predictions":["n = int ( input ( ) ) v = list ( map ( int , input ( ) . split ( ) ) ) v . insert ( 0 , 0 ) n += 1 a = v . copy ( ) a . sort ( ) for i in range ( n ) : a [ i ] += 0 if i == 0 else a [ i - 1 ] v [ i ] += 0 ] a [ i - 1 ] -= 1 NEW_LINE"],"references":["class CodeforcesTask226BSolution : def __init__ ( self ) : self . result = ' ' self . n = 0 self . piles = [ ] self . q = 0 self . variants = [ ]   def read_input ( self ) : self . n = int ( input ( ) ) self . piles = [ int ( x ) for x in input ( ) . split ( \" ▁ \" ) ] self . q = int ( input ( ) ) self . variants = [ int ( x ) for x in input ( ) . split ( \" ▁ \" ) ]   def process_task ( self ) : self . piles . sort ( reverse = True ) sums = [ 0 ] * self . n sums [ 0 ] = self . piles [ 0 ] for x in range ( self . n - 1 ) : sums [ x + 1 ] = self . piles [ x + 1 ] + sums [ x ] anwsers = { } results = [ ] for query in self . variants : if query in anwsers . keys ( ) : results . append ( anwsers [ query ] ) else : anwser = 0 factor = 1 k = 1 width = query x = 1 while x + width < self . n : anwser += ( sums [ x + width - 1 ] - sums [ x - 1 ] ) * factor factor += 1 x += width k += 1 width = query ** k anwser += ( sums [ - 1 ] - sums [ x - 1 ] ) * factor results . append ( anwser ) anwsers [ query ] = anwser self . result = \" ▁ \" . join ( [ str ( x ) for x in results ] )   def get_result ( self ) : return self . result     if __name__ == \" _ _ main _ _ \" : Solution = CodeforcesTask226BSolution ( ) Solution . read_input ( ) Solution . process_task ( ) print ( Solution . get_result ( ) ) NEW_LINE","n = int ( input ( ) ) stones = list ( map ( lambda t : int ( t ) , input ( ) . split ( ) ) ) q = int ( input ( ) ) queries = list ( map ( lambda t : int ( t ) , input ( ) . split ( ) ) )   stones . sort ( )   added_stones = [ ] added_stones . append ( stones [ 0 ] ) for i in range ( 1 , n , 1 ) : added_stones . append ( stones [ i ] + added_stones [ i - 1 ] )   computed_queries = { }   for qidx , qq in enumerate ( queries ) : if qq in computed_queries : queries [ qidx ] = computed_queries [ qq ] continue   i = n - 2 multiplier = 1 cost = 0 while i >= 0 : pp = pow ( qq , multiplier ) nexti = i - pp if nexti < 0 : cost += added_stones [ i ] * multiplier break cost += ( added_stones [ i ] - added_stones [ nexti ] ) * multiplier multiplier += 1 i = nexti queries [ qidx ] = cost computed_queries [ qq ] = cost   print ( * queries , sep = ' ▁ ' ) NEW_LINE"],"bleu":0.09453928212639275,"rouge_l":0.3472156341903045}
{"id":483,"predictions":["import sys   def main ( ) : inp = sys . stdin . read ( ) . strip ( ) . split ( ' \\n ' ) return ( i for i in inp [ 1 ] . split ( ) if i in set ( inp [ 2 ] . split ( ) ) ) print ( * main ( ) ) NEW_LINE"],"references":["def binaryToDecimal ( n ) : return int ( n , 2 ) s = input ( ) s = s . replace ( \" > \" , \"1000\" ) s = s . replace ( \" < \" , \"1001\" ) s = s . replace ( \" + \" , \"1010\" ) s = s . replace ( \" - \" , \"1011\" ) s = s . replace ( \" . \" , \"1100\" ) s = s . replace ( \" , \" , \"1101\" ) s = s . replace ( \" [ \" , \"1110\" ) s = s . replace ( \" ] \" , \"1111\" ) p = binaryToDecimal ( s ) ans = p % ( ( 10 ** 6 ) + 3 ) print ( ans ) NEW_LINE","    f = { ' > ' : '1000' , ' < ' : '1001' , ' + ' : '1010' , ' - ' : '1011' , ' . ' : '1100' , ' , ' : '1101' , ' [ ' : '1110' , ' ] ' : '1111' }     t = input ( ) u = ' ' for j in t : u += f [ j ] print ( int ( u , 2 ) % 1000003 ) NEW_LINE","x = list ( input ( ) ) a = ' ' for i in x : if i == ' > ' : a += '1000' elif i == ' < ' : a += '1001' elif i == ' + ' : a += '1010' elif i == ' - ' : a += '1011' elif i == ' . ' : a += '1100' elif i == ' , ' : a += '1101' elif i == ' [ ' : a += '1110' elif i == ' ] ' : a += '1111' y = int ( a ) decimal , i , n = 0 , 0 , 0 while ( y != 0 ) : dec = y % 10 decimal = decimal + dec * pow ( 2 , i ) y = y \/\/ 10 i += 1 print ( decimal % 1000003 ) NEW_LINE"],"bleu":0.0774796661026596,"rouge_l":0.2775671166388594}
{"id":484,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) d = { } for i in range ( n ) : if d . get ( a [ i ] ) == None : d [ a [ i ] ] = 1 else : d [ a [ i ] ] = 1 d [ a [ i ] ] = 1 ans = 0 for i in d : if d . get ( i ) == None : ans += i break print ( ans ) NEW_LINE"],"references":["def gcd ( a , b ) : a , b = max ( a , b ) , min ( a , b ) while a % b != 0 : a %= b a , b = b , a return b   def gsd ( a , b ) : return a * b \/\/ gcd ( a , b )   n = int ( input ( ) ) m = list ( map ( int , input ( ) . split ( ) ) ) r = list ( map ( int , input ( ) . split ( ) ) ) x = m [ 0 ] for i in range ( 1 , n ) : x = gsd ( x , m [ i ] ) count = 0 for i in range ( x ) : for j in range ( n ) : if i % m [ j ] == r [ j ] : count += 1 breakprint ( count \/ x ) NEW_LINE","n = int ( input ( ) ) m = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) [ : n ] r = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) [ : n ] counter = 0 for i in range ( 0 , 10000000 ) : for j in range ( 0 , n ) : if ( i % m [ j ] == r [ j ] ) : counter = counter + 1 breakprint ( counter \/ 10000000 ) NEW_LINE","def gcd ( a , b ) : if b == 0 : return a return gcd ( b , a % b )     def lcm ( a , b ) : return a * b \/\/ gcd ( a , b )     n = int ( input ( ) ) m = list ( map ( int , input ( ) . split ( ) ) ) r = list ( map ( int , input ( ) . split ( ) ) ) l = 1 s = set ( ) for i in range ( n ) : l = lcm ( l , m [ i ] ) for k in range ( l \/\/ min ( m ) + 1 ) : for j in range ( n ) : if m [ j ] * k + r [ j ] <= l : s . add ( m [ j ] * k + r [ j ] ) if 0 in s : s . remove ( 0 ) q = len ( s ) print ( q \/ l ) NEW_LINE","n = int ( input ( ) ) m = [ int ( q ) for q in input ( ) . split ( ) ] r = [ int ( q ) for q in input ( ) . split ( ) ] c = 0 for d in range ( 10 ** 5 ) : for i in range ( min ( len ( m ) , len ( r ) ) ) : if d % m [ i ] == r [ i ] : c += 1 breakprint ( c \/ ( 10 ** 5 + 1 ) ) NEW_LINE"],"bleu":0.44176342877229774,"rouge_l":0.561690574215414}
{"id":485,"predictions":["def solve ( ) : n , m , r , c = [ int ( i ) for i in input ( ) . split ( ) ] p = [ [ ] for i in range ( n ) ] for i in range ( n ) : p . append ( input ( ) ) p1 = list ( map ( int , input ( ) . split ( ) ) ) p2 = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) : for j in range ( m ) : l = list ( map ( int , input ( ) . split ( ) ) ) ans = 0 for i in range ( n ) : if p [ i ] < c : ans += 1 if l [ i ] > r : ans -= 1 print ( ans ) return   if __name__ == ' _ _ main _ _ ' : solve ( ) NEW_LINE"],"references":["n , a , b = map ( int , input ( ) . split ( ) ) if n > a * b : print ( - 1 ) else : arr = [ [ 0 ] * b for _ in range ( a ) ] x = 1 y = 2   for i in range ( a ) : for j in range ( b ) :   if ( i + j ) % 2 == 0 : if x <= n : arr [ i ] [ j ] = x x += 2 else : if y <= n : arr [ i ] [ j ] = y y += 2 NEW_LINE","n , a , b = map ( int , input ( ) . split ( ) ) if a * b < n : print ( - 1 ) ; exit ( ) for i in range ( a ) : x = [ str ( j ) if j <= n else '0' for j in range ( i * b + 1 , ( i + 1 ) * b + 1 ) ] if i & 1 == 0 : x = list ( reversed ( x ) ) print ( ' ▁ ' . join ( x ) ) NEW_LINE","n , a , b = map ( int , input ( ) . split ( ) ) ans = [ ] if n <= a * b : if b % 2 == 1 : for i in range ( 1 , a * b + 1 ) : if i <= n : ans . append ( i ) else : ans . append ( 0 ) if len ( ans ) % b == 0 : print ( * ans ) ans = [ ] else : for i in range ( 1 , a * b + 1 ) : if i <= n : ans . append ( i ) else : ans . append ( 0 ) if len ( ans ) % b == 0 and ( i \/\/ b ) % 2 == 1 : print ( * ans ) ans = [ ] elif len ( ans ) % b == 0 and ( i \/\/ b ) % 2 == 0 : print ( * ans [ : : - 1 ] ) ans = [ ] else : print ( - 1 ) NEW_LINE","n , a , b = map ( int , input ( ) . split ( ) ) c = [ ] if a * b < n : print ( - 1 ) else : for x in range ( 1 , n + 1 ) : c . append ( str ( x ) ) for x in range ( ( a * b ) - n ) : c . append ( \"0\" ) for x in range ( 1 , a + 1 ) : e = \" \" if x % 2 != 0 : for x in range ( b ) : if x != b - 1 : e += c [ 0 ] + \" ▁ \" else : e += c [ 0 ] c . pop ( 0 ) e . strip ( ) print ( e ) else : for x in range ( b , 0 , - 1 ) : if x != 1 : e += c [ x - 1 ] + \" ▁ \" else : e += c [ x - 1 ] c . pop ( x - 1 ) e . strip ( ) print ( e ) NEW_LINE","if __name__ == \" _ _ main _ _ \" : in_values = list ( map ( int , input ( ) . split ( ) ) ) nr_of_parliaments = in_values [ 0 ] rows = in_values [ 1 ] chairs = in_values [ 2 ] if chairs * rows < nr_of_parliaments : print ( ' - 1' ) else : p = 0 for i in range ( rows ) : out_row = [ ] for j in range ( chairs ) : p += 1 if p <= nr_of_parliaments : out_row . append ( p ) else : out_row . append ( 0 ) if chairs % 2 == 0 and i % 2 == 0 : out_row = out_row [ : : - 1 ] print ( * out_row ) NEW_LINE"],"bleu":0.3547936774438539,"rouge_l":0.4329357507983962}
{"id":486,"predictions":["import sys , mathfrom collections import deque , defaultdictimport operator as opfrom functools import reducefrom itertools import permutations   NEW_LINE"],"references":["s = input ( ) t = input ( ) v = [ ' a ' , ' e ' , ' i ' , ' o ' , ' u ' ] if len ( s ) == len ( t ) : for i in range ( len ( s if len ( s ) < len ( t ) else t ) ) : if s [ i ] in v and t [ i ] in v : continue elif s [ i ] in v or t [ i ] in v : print ( \" NO \" ) exit ( ) else : continue print ( ' YES ' ) else : print ( ' NO ' ) NEW_LINE","a = input ( ) b = input ( ) c = 0 vowels = [ ' a ' , ' e ' , ' i ' , ' o ' , ' u ' ] if len ( a ) == len ( b ) : for index , i in enumerate ( a ) : if a [ index ] in vowels and b [ index ] in vowels : c = 1 elif a [ index ] not in vowels and b [ index ] not in vowels : c = 1 else : c = 0 break if c == 1 : print ( \" Yes \" ) elif c == 0 : print ( \" No \" )   else : print ( \" No \" )   NEW_LINE","s = input ( ) t = input ( ) if len ( s ) != len ( t ) : print ( \" No \" ) else : p = 1 l = [ ' a ' , ' e ' , ' i ' , ' o ' , ' u ' ] for i in range ( len ( s ) ) : if s [ i ] in l and t [ i ] in l : p = 1 elif s [ i ] not in l and t [ i ] not in l : p = 1 else : p = 0 break if p == 1 : print ( \" Yes \" ) else : print ( \" No \" ) NEW_LINE","    def ok ( a , b ) : vo = \" aeiou \"   if len ( a ) != len ( b ) : return False   for i , j in zip ( a , b ) : if i not in vo and j in vo or i in vo and j not in vo : return False return True     a = input ( ) b = input ( )     print ( \" Yes \" if ok ( a , b ) else \" No \" ) NEW_LINE","def isvowel ( ch ) : return ch . upper ( ) in [ ' A ' , ' E ' , ' I ' , ' O ' , ' U ' ] s = input ( ) t = input ( ) if ( len ( s ) != len ( t ) ) : print ( \" NO \" ) else : flag = 1 for i in range ( len ( s ) ) : if ( ( isvowel ( s [ i ] ) and isvowel ( t [ i ] ) ) or ( not ( isvowel ( s [ i ] ) ) and not ( isvowel ( t [ i ] ) ) ) ) : continue else : print ( \" NO \" ) flag = 0 break if ( flag ) : print ( \" YES \" ) NEW_LINE"],"bleu":0.001923563113124513,"rouge_l":0.061122244488977955}
{"id":487,"predictions":["import sys , os , ioimport math , bisect , operatorinf , mod = float ( ' inf ' ) , 10 ** 9 + 7 NEW_LINE"],"references":["import sysinput = sys . stdin . readlinefrom collections import defaultdict as dcfrom collections import Counterfrom bisect import bisect_right , bisect_leftimport mathfrom operator import itemgetterfrom heapq import heapify , heappop , heappushfrom queue import PriorityQueue as pqfor _ in range ( int ( input ( ) ) ) : n , d = map ( int , input ( ) . split ( ) ) f = 0 s = math . ceil ( math . sqrt ( d ) ) i = s while ( i > 0 and f == 0 ) : if i + math . ceil ( d \/ ( i + 1 ) ) <= n : f = 1 break i -= 1 if f or d <= n : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE","from collections import defaultdictfrom collections import dequeimport bisectimport heapqfrom math import sqrt , ceil def ri ( ) : return int ( input ( ) ) def rl ( ) : return list ( map ( int , input ( ) . split ( ) ) ) t = ri ( ) for _ in range ( t ) : n , d = rl ( ) ans = \" NO \" for x in range ( int ( sqrt ( d ) ) - 10 , int ( sqrt ( d ) ) + 10 ) : if x >= 0 and x <= n : val = x + ceil ( d \/ ( x + 1 ) ) if val <= n : ans = \" YES \" break print ( ans )   NEW_LINE","from collections import defaultdictfrom collections import dequeimport bisectimport heapqfrom math import sqrt , ceil def ri ( ) : return int ( input ( ) ) def rl ( ) : return list ( map ( int , input ( ) . split ( ) ) )   def f ( x ) : return x + ceil ( d \/ ( x + 1 ) )     def ternary_search ( f , a , b ) : while ( b - a ) >= 3 : alpha = 1 \/ 3 c = ( 1 - alpha ) * a + alpha * b c = int ( c ) d = alpha * a + ( 1 - alpha ) * b d = int ( d ) fc = f ( c ) fd = f ( d ) counter = 0 while fc == fd : if counter % 2 == 0 : d += 1 else : c -= 1 counter += 1 if d > b or c < a : return ( a , b )   if fc < fd : b = d else : a = c   return ( a , b )   t = ri ( ) for _ in range ( t ) : n , d = rl ( ) a , b = ternary_search ( f , 0 , n ) for x in range ( a , b + 1 ) : if f ( x ) <= n : ans = \" YES \" break else : ans = \" NO \" \t \t \t   print ( ans ) NEW_LINE","t = int ( input ( ) )   from math import floor , ceil   def func ( x , d ) : return x + d \/ ( x + 1 )   for _ in range ( t ) : n , d = map ( int , input ( ) . split ( ) )   l , r = 0 , n   while ( r - l > 0.00001 ) : a = l + ( r - l ) \/ 3 b = l + 2 * ( r - l ) \/ 3   if ( func ( a , d ) < func ( b , d ) ) : r = b else : l = a f = floor ( l ) + ceil ( d \/ ( floor ( l ) + 1 ) ) c = ceil ( l ) + ceil ( d \/ ( ceil ( l ) + 1 ) )   if ( min ( f , c ) <= n ) : print ( ' YES ' ) else : print ( ' NO ' ) NEW_LINE","import sysfrom math import floordef input ( ) : return sys . stdin . readline ( ) . strip ( ) def iinput ( ) : return int ( input ( ) ) def minput ( ) : return map ( int , input ( ) . split ( ) ) def listinput ( ) : return list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( iinput ( ) ) : n , d = minput ( ) if pow ( n + 1 , 2 ) >= 4 * d : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.0035676042454222123,"rouge_l":0.12971823498139287}
{"id":488,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) dp = [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) : if i > 0 : dp [ i ] = ( 2 * dp [ i - 1 ] + 2 - dp [ a [ i - 1 ] - 1 ] ) % 2 print ( sum ( dp ) % 2 ) NEW_LINE"],"references":["  n = int ( input ( ) ) lis = list ( map ( int , input ( ) . split ( ) ) ) m = int ( input ( ) ) edges = [ ] for d in range ( m ) : edges . append ( list ( map ( int , input ( ) . split ( ) ) ) ) edges . sort ( key = lambda x : x [ 2 ] ) visited = [ ] count = 0 for i in range ( m ) : if edges [ i ] [ 1 ] not in visited : visited . append ( edges [ i ] [ 1 ] ) count += edges [ i ] [ 2 ]   if len ( visited ) == n - 1 : print ( count ) else : print ( - 1 ) NEW_LINE","import sysimport math n = int ( input ( ) ) q = map ( int , input ( ) . split ( ) ) m = int ( input ( ) ) upc = [ 1000005 ] * nfor i in range ( m ) : a , b , c = map ( int , input ( ) . split ( ) ) upc [ b - 1 ] = min ( upc [ b - 1 ] , c )   a , c = 0 , 0   for x in upc : if x > 1000000 : c += 1 if c > 1 : print ( \" - 1\" ) sys . exit ( 0 ) else : a += x   print ( a ) NEW_LINE","def find ( arr , a ) : if arr [ a ] == a : return a arr [ a ] = find ( arr , arr [ a ] ) return arr [ a ] n = int ( input ( ) ) x = list ( map ( int , input ( ) . split ( ) ) ) arr = [ i for i in range ( n + 1 ) ] m = int ( input ( ) ) l = [ ] for _ in range ( m ) : l . append ( list ( map ( int , input ( ) . split ( ) ) ) ) l . sort ( key = lambda k : k [ 2 ] ) val = nans = 0 for i in range ( m ) : x = find ( arr , l [ i ] [ 0 ] ) y = find ( arr , l [ i ] [ 1 ] ) if x != y and y == l [ i ] [ 1 ] : val -= 1 arr [ y ] = x ans += l [ i ] [ 2 ] if val != 1 : print ( - 1 ) else : print ( ans ) NEW_LINE","MAX = 1000001   e = int ( input ( ) ) q = input ( ) . split ( ) m = int ( input ( ) ) arr1 = [ MAX ] * e   for i in range ( m ) : [ a , b , c ] = list ( map ( int , input ( ) . split ( ) ) ) arr1 [ b - 1 ] = min ( arr1 [ b - 1 ] , c )   count = 0 for x in arr1 : if x == MAX : count += 1 if count > 1 : print ( - 1 ) else : res = 0 for k in arr1 : if k != MAX : res += k print ( res ) NEW_LINE"],"bleu":0.35030893921136,"rouge_l":0.4682848357734835}
{"id":489,"predictions":["n = int ( input ( ) ) NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE z = 0 NEW_LINE for i in range ( n ) : inp = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE x += inp [ 0 ] NEW_LINE y += inp [ 1 ] NEW_LINE z += inp [ 2 ] NEW_LINE if ( x == 0 and y == 0 and z == 0 ) : NEW_LINE INDENT print ( \" YES \" ) else : NEW_LINE print ( \" NO \" ) NEW_LINE DEDENT"],"references":["Into = str ( input ( ) ) NEW_LINE Into = list ( Into ) NEW_LINE hello = [ ' h ' , ' e ' , ' l ' , ' l ' , ' o ' ] NEW_LINE cur = 0 l NEW_LINE ist1 = [ ] NEW_LINE for i in Into : if NEW_LINE i == hello [ cur ] : list1 . append ( i ) NEW_LINE cur += 1 NEW_LINE if len ( list1 ) == 5 : breakif NEW_LINE list1 == hello : print ( ' YES ' ) else : print ( ' NO ' ) NEW_LINE","n = input ( ) NEW_LINE l = list ( n ) NEW_LINE s = len ( l )   NEW_LINE def main ( ) : i1 , i2 , i3 , i4 , i5 = 0 , 0 , 0 , 0 , 0 NEW_LINE for i in range ( s ) : if NEW_LINE INDENT ( l [ i ] == ' h ' ) : i1 = i + 1 NEW_LINE DEDENT break NEW_LINE if i1 == 0 : print ( ' NO ' ) NEW_LINE return NEW_LINE for i in range ( i1 , s ) : if NEW_LINE INDENT ( l [ i ] == ' e ' ) : i2 = i + 1 NEW_LINE DEDENT break NEW_LINE if i2 == 0 : print ( ' NO ' ) NEW_LINE return NEW_LINE for i in range ( i2 , s ) : if NEW_LINE INDENT ( l [ i ] == ' l ' ) : i3 = i + 1 NEW_LINE DEDENT break NEW_LINE if i3 == 0 : print ( ' NO ' ) NEW_LINE return NEW_LINE for i in range ( i3 , s ) : if NEW_LINE INDENT ( l [ i ] == ' l ' ) : i4 = i + 1 NEW_LINE DEDENT break NEW_LINE if i4 == 0 : print ( ' NO ' ) NEW_LINE return   for i in range ( i4 , s ) : if NEW_LINE INDENT ( l [ i ] == ' o ' ) : i5 = i + 1 NEW_LINE DEDENT break NEW_LINE if i5 == 0 : print ( ' NO ' ) NEW_LINE return elif ( i1 < i2 < i3 < i4 < i5 ) : print ( ' YES ' ) NEW_LINE return else : print ( ' NO ' ) NEW_LINE return     main ( )   NEW_LINE","import re ; NEW_LINE x = input ( ) NEW_LINE x . lower ( ) NEW_LINE if re . search ( \" h . * e . * l . * l . * o \" , x ) : NEW_LINE INDENT print ( \" YES \" ) else : NEW_LINE print ( \" NO \" ) NEW_LINE DEDENT","s = input ( ) ; NEW_LINE d = \" hello \" ; NEW_LINE x = 0 NEW_LINE for c in s : if NEW_LINE x > 4 : NEW_LINE break NEW_LINE if d [ x ] == c : x += 1 NEW_LINE if x == 5 : NEW_LINE INDENT print ( \" YES \" ) else : NEW_LINE print ( \" NO \" ) NEW_LINE DEDENT","dat = \" \" . join ( [ i for i in input ( ) if i in \" hello \" ] ) + \" ▁ \" NEW_LINE def check ( inp ) : now = \" hello \" NEW_LINE for step in now : if NEW_LINE step in inp : inp = inp [ inp . index ( step ) + 1 : ] else : return \" NO \" NEW_LINE return \" YES \" NEW_LINE print ( check ( dat ) ) NEW_LINE"],"bleu":0.46790991934287807,"rouge_l":0.5953197318613266}
{"id":490,"predictions":["n , m = map ( int , input ( ) . split ( ) ) l = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) c = 0 e = 0 for i in l : if i < 0 and i < m : e += 1 c += 1   print ( i ) NEW_LINE"],"references":["n = int ( input ( ) ) m = int ( input ( ) ) l = [ ] for i in range ( n ) : l . append ( int ( input ( ) ) ) l . sort ( reverse = True ) s = 0 for i in range ( n ) : s += l [ i ] if s >= m : print ( i + 1 ) break NEW_LINE","n = int ( input ( ) ) m = int ( input ( ) ) usb = [ ]   for _ in range ( n ) : usb . append ( int ( input ( ) ) )   for i , val in enumerate ( sorted ( usb , reverse = True ) ) : m -= val   if m <= 0 : print ( i + 1 ) break NEW_LINE","ls = [ ] sum1 = 0 lis = [ ] n = int ( input ( ) ) m = int ( input ( ) ) for i in range ( n ) : ls . append ( int ( input ( ) ) ) ls . sort ( ) for i in ls [ : : - 1 ] : sum1 += i lis . append ( i ) if sum1 >= m : breakprint ( len ( lis ) ) NEW_LINE","def insertion_sort ( l ) : for i in range ( len ( l ) ) : for j in ( range ( i ) ) : k = i - j if l [ k ] >= l [ k - 1 ] : l [ k - 1 ] , l [ k ] = l [ k ] , l [ k - 1 ] else : break return l       def selection_sort ( l ) : for i in range ( len ( l ) ) : min_ind = i min_val = l [ i ] for j in range ( i , len ( l ) ) : if min_val > l [ j ] : min_val = l [ j ] min_ind = j l [ i ] , l [ min_ind ] = l [ min_ind ] , l [ i ] return l     def bubble_sort ( l ) : for i in range ( len ( l ) - 1 ) : for j in range ( len ( l ) - 1 - i ) : if l [ j ] > l [ j + 1 ] : l [ j ] , l [ j + 1 ] = l [ j + 1 ] , l [ j ] return l     NEW_LINE","n = int ( input ( ) ) m = int ( input ( ) )   l = [ int ( input ( ) ) for i in range ( n ) ]   l . sort ( reverse = True )   tot = 0 c = 0 i = 0 while m > 0 : m -= l [ i ] i += 1 c += 1 print ( c ) NEW_LINE"],"bleu":0.34277062450122603,"rouge_l":0.4852272727272727}
{"id":491,"predictions":["import sys , os , ioimport math , bisect , operatorinf , mod = float ( ' inf ' ) , 10 ** 9 + 7 NEW_LINE"],"references":["n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) i = 0 while i < n and k > 0 and a [ i ] < 0 : a [ i ] = - 1 * a [ i ] i += 1 k -= 1 a = sorted ( a ) if k % 2 == 1 : a [ 0 ] = - 1 * a [ 0 ] print ( sum ( a ) ) NEW_LINE","import heapq   n , k = map ( int , input ( ) . split ( ' ▁ ' ) ) pos = list ( map ( int , input ( ) . split ( ' ▁ ' ) ) ) heapq . heapify ( pos ) s = sum ( pos ) i = 0 while k > 0 : k -= 1 n = heapq . heappop ( pos ) heapq . heappush ( pos , - n ) s = s + ( - n ) - ( n ) print ( s )   NEW_LINE","def I ( ) : return list ( map ( int , input ( ) . split ( ) ) )     n , k = I ( ) sequence_number = I ( ) count = 0 if sequence_number [ 0 ] > 0 and k % 2 == 1 : print ( sum ( sequence_number ) - sequence_number [ 0 ] * 2 ) exit ( ) elif sequence_number [ 0 ] > 0 and k % 2 == 0 : print ( sum ( sequence_number ) ) exit ( ) else : for i in range ( k ) : if sequence_number [ i ] < 0 : sequence_number [ i ] = - sequence_number [ i ] else : count = i break if i == n - 1 : count = n breaksequence_number . sort ( ) if count != 0 : if ( k - count ) % 2 == 0 : print ( sum ( sequence_number ) ) exit ( ) else : print ( sum ( sequence_number ) - sequence_number [ 0 ] * 2 ) exit ( ) print ( sum ( sequence_number ) ) NEW_LINE","import sys     def ints_input ( ) : return [ int ( i ) for i in sys . stdin . readline ( ) . strip ( \" \\n \" ) . split ( \" ▁ \" ) ]     def print_list ( arr ) : sys . stdout . writelines ( str ( x ) + \" ▁ \" for x in arr ) sys . stdout . write ( \" \\n \" )     def fast_input ( type = str ) : return type ( sys . stdin . readline ( ) . strip ( \" \\n \" ) )     n , k = ints_input ( ) arr = ints_input ( ) NEW_LINE","n , k = map ( int , input ( ) . split ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) pos = [ ] neg = [ ] ans = 0 for i in arr : if i < 0 : neg . append ( i ) else : pos . append ( i ) ans += sum ( pos ) if neg : neg . sort ( ) if k <= len ( neg ) : ans += abs ( sum ( neg [ : k ] ) ) ans += sum ( neg [ k : ] ) else : ans += abs ( sum ( neg ) ) k = ( k - len ( neg ) ) % 2 if k == 1 : if len ( pos ) == 0 : pos . append ( float ( ' inf ' ) ) ans -= 2 * ( min ( min ( pos ) , abs ( max ( neg ) ) ) ) else : if k % 2 == 1 : ans -= 2 * ( min ( pos ) ) print ( ans ) NEW_LINE"],"bleu":0.019371692460562508,"rouge_l":0.15905185185185186}
{"id":492,"predictions":["n = int ( input ( ) ) l1 = list ( map ( int , input ( ) . split ( ) ) ) l2 = [ ] for i in range ( n ) : l1 . append ( l1 [ i ] + l1 [ - ( i + 1 ) ] ) l2 . sort ( ) print ( \" NO \" ) NEW_LINE"],"references":["n = int ( input ( ) ) S = input ( ) A = S . count ( \" SF \" ) B = S . count ( \" FS \" ) if A > B : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE","count1 = 0 count2 = 0 n = int ( input ( ) ) row = list ( str ( input ( ) ) ) for j in range ( n - 1 ) : if row [ j ] == ' S ' and row [ j + 1 ] == ' F ' : count1 = count1 + 1 elif row [ j ] == ' F ' and row [ j + 1 ] == ' S ' : count2 = count2 + 1 if count1 > count2 : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE","input ( ) s = input ( ) if s . count ( \" SF \" ) > s . count ( \" FS \" ) : print ( ' YES ' ) else : print ( ' NO ' ) NEW_LINE"],"bleu":0.33584358241298534,"rouge_l":0.5513234344738541}
{"id":493,"predictions":["import sys , math , itertoolsfrom collections import Counter , deque , defaultdictfrom bisect import bisect_left , bisect_right from heapq import heappop , heappush , heapifymod = 10 ** 9 + 7 INF = float ( ' inf ' ) def inp ( ) : return int ( sys . stdin . readline ( ) ) def inpl ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) def inpl_1 ( ) : return list ( map ( lambda x : int ( x ) - 1 , sys . stdin . readline ( ) . split ( ) ) ) def inps ( ) : return sys . stdin . readline ( ) def inpsl ( x ) : tmp = sys . stdin . readline ( ) ; return list ( tmp [ : x ] ) def err ( x ) : print ( x ) ; exit ( )   x , y = inpl ( ) for _ in range ( inp ( ) ) : NEW_LINE"],"references":["with open ( ' input . txt ' , ' r ' ) as f : fs = f . read ( ) . strip ( ) . split ( ' \\n ' )   n = [ int ( i ) for i in fs [ 1 ] ] c = - 1 i , ans = 0 , \" YES \" while i < len ( n ) : if n [ i ] == 1 : count = 0 while i + 1 < len ( n ) : if n [ i + 1 ] == 1 : break count += 1 i += 1 else : count = c if c == - 1 : c = count elif c != count : ans = \" NO \" break i += 1   with open ( ' output . txt ' , ' w ' ) as f : f . write ( ans ) NEW_LINE","import syssys . stdin = open ( \" input . txt \" , \" r \" ) sys . stdout = open ( \" output . txt \" , \" w + \" ) a = int ( input ( ) ) ; z = [ ] for i , j in enumerate ( input ( ) ) : if j == '1' : z . append ( i ) f = [ ] for i in range ( 1 , len ( z ) ) : f . append ( z [ i ] - z [ i - 1 ] ) if len ( set ( f ) ) <= 1 : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE","nro_linea = 0 manejador_archivo = open ( ' input . txt ' ) for linea in manejador_archivo : if nro_linea == 0 : n = int ( linea . split ( ) [ 0 ] ) else : secuencia = list ( str ( linea ) ) nro_linea = nro_linea + 1 manejador_archivo . close ( )   i = 0 c = 0 k = 0 fallo = Falsewhile i < n : if secuencia [ i ] == '1' : while i < n and secuencia [ i ] == '1' : c = c + 1 i = i + 1 while i < n and secuencia [ i ] == '0' : k = k + 1 i = i + 1 break i = i + 1 while i < n : c2 = 0 while i < n and secuencia [ i ] == '1' : c2 = c2 + 1 i = i + 1 if c2 != c : fallo = True break k2 = 0 while i < n and secuencia [ i ] == '0' : k2 = k2 + 1 i = i + 1 if k2 != k and i < n : fallo = True break   if not fallo : rpta = ' YES ' else : rpta = ' NO ' archivo_salida = open ( \" output . txt \" , \" w \" ) archivo_salida . write ( rpta ) archivo_salida . close ( ) NEW_LINE","''' input ( ) line ▁ = ▁ input ( ) new _ line ▁ = ▁ line [ line . index ( '1 ' ) ▁ + ▁ 1 : ▁ line . rindex ( '1 ' ) ] n ▁ = ▁ 0m ▁ = ▁ 0ans ▁ = ▁ ' YES ' for ▁ item ▁ in ▁ new _ line : ▁ ▁ ▁ ▁ if ▁ item ▁ ! = ▁ ' 1 ' : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ n ▁ + = ▁ 1 ▁ ▁ ▁ ▁ else : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ breakfor ▁ item ▁ in ▁ new _ line : ▁ ▁ ▁ ▁ if ▁ item ▁ ! = ▁ ' 1 ' : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ m ▁ + = ▁ 1 ▁ ▁ ▁ ▁ if ▁ item ▁ = = ▁ ' 1 ' : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ m ▁ ! = ▁ n : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ans ▁ = ▁ ' NO ' ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ break ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ else : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ m ▁ = ▁ 0print ( ans )   ▁ ▁ 0123456789 . . . . . # \" 001001000100000 \" '''   rfile = open ( ' input . txt ' , ' r ' ) n , text , prev , dist , ans = int ( rfile . readline ( ) ) , rfile . readline ( ) , - 1 , - 1 , ' YES ' rfile . close ( ) for i in range ( n ) : if text [ i ] == '1' and prev == - 1 : prev = i elif text [ i ] == '1' and dist == - 1 : dist = i - prev - 1 prev = i elif text [ i ] == '1' : currDist = i - prev - 1 if currDist != dist : ans = ' NO ' break prev = i   wfile = open ( ' output . txt ' , ' w ' ) wfile . write ( ans ) wfile . close ( ) NEW_LINE"],"bleu":0.13882157194143663,"rouge_l":0.2757515359483839}
{"id":494,"predictions":["n , m , d = map ( int , input ( ) . split ( ) ) a = [ 0 ] * nfor i in range ( m ) : a [ i * map ( int , input ( ) . split ( ) ) ] += 1 a [ i * map ( int , input ( ) . split ( ) ) ] print ( min ( sum ( a ) , d ) ) NEW_LINE"],"references":["BigNum = 10 ** 20   n , m , a , d = map ( int , input ( ) . split ( ' ▁ ' ) ) ts = [ 0 ] + list ( map ( int , input ( ) . split ( ' ▁ ' ) ) ) + [ BigNum ]   def empsInRange ( l , r ) : em1 = l \/\/ a + 1 em2 = r \/\/ a return ( em1 , min ( em2 , n ) )   empDoorGroup = d \/\/ a + 1   def moveEmps ( emps , last ) : em1 , em2 = emps if em1 > em2 : return last , 0 if em1 * a <= last + d : gr1 = ( last + d - em1 * a ) \/\/ a em1 += 1 + gr1 if em1 > em2 : return last , 0   doorGroups = ( em2 - em1 + 1 + empDoorGroup - 1 ) \/\/ empDoorGroup last = ( em1 + empDoorGroup * ( doorGroups - 1 ) ) * a   return last , doorGroups   res = 0 last = - BigNum   for i in range ( 1 , len ( ts ) ) : NEW_LINE","n1 , m , a , d = list ( map ( int , input ( ) . split ( ) ) ) t = list ( map ( int , input ( ) . split ( ) ) ) from bisect import * from math import * insort ( t , a * n1 ) pred = 0 k = 0 kpred = 0 n = 0 step = d \/\/ a + 1 sol = 0 fl = 0 for i in t : if ( i > pred ) : if fl == 0 : n = ( i - pred + ( pred % a ) ) \/\/ a if n != 0 : k += ( n \/\/ step ) * step - step * ( n % step == 0 ) + 1 if k > n1 : k = n1 fl = 1 NEW_LINE"],"bleu":0.20123599290764377,"rouge_l":0.37711819473606073}
{"id":495,"predictions":["import itertoolsimport bisectimport mathfrom collections import * import osimport sysfrom io import BytesIO , IOBase   ii = lambda : int ( input ( ) ) lmii = lambda : list ( map ( int , input ( ) . split ( ) ) ) slmii = lambda : sorted ( map ( int , input ( ) . split ( ) ) ) li = lambda : list ( input ( ) ) mii = lambda : map ( int , input ( ) . split ( ) ) msi = lambda : map ( str , input ( ) . split ( ) )     def main ( ) : NEW_LINE"],"references":["n = int ( input ( ) ) ans = \" YES \" num = 0 for i in range ( n ) : w , h = map ( int , input ( ) . split ( ) ) if i == 0 : num = max ( w , h ) else : if max ( w , h ) <= num : num = max ( w , h ) elif min ( w , h ) <= num : num = min ( w , h ) else : ans = \" NO \" print ( ans ) NEW_LINE","n = int ( input ( ) ) lmain = [ ] x , y = map ( int , input ( ) . split ( ) ) lmain . append ( max ( x , y ) ) for i in range ( 1 , n ) : a , b = map ( int , input ( ) . split ( ) ) lmain . append ( [ a , b ] ) ans = Truefor i in range ( 1 , n ) : if ( max ( lmain [ i ] [ 0 ] , lmain [ i ] [ 1 ] ) <= lmain [ i - 1 ] ) : lmain [ i ] = max ( lmain [ i ] [ 0 ] , lmain [ i ] [ 1 ] ) elif ( min ( lmain [ i ] [ 0 ] , lmain [ i ] [ 1 ] ) <= lmain [ i - 1 ] ) : lmain [ i ] = min ( lmain [ i ] [ 0 ] , lmain [ i ] [ 1 ] ) else : ans = False breakif ( ans ) : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE","n = int ( input ( ) ) p = max ( map ( int , input ( ) . split ( ) ) ) ans = ' YES ' for i in range ( n - 1 ) : w , h = map ( int , input ( ) . split ( ) ) if w > h : w , h = h , w if h <= p : p = h elif w <= p : p = w else : ans = ' NO ' breakprint ( ans ) NEW_LINE","def turn_the_rectangles_perfect ( ) : n = int ( input ( ) ) width , height = map ( int , input ( ) . split ( ) ) stack = [ max ( width , height ) ] flag = True for i in range ( n - 1 ) : width , height = map ( int , input ( ) . split ( ) ) ma = max ( width , height ) mi = min ( width , height ) if ma <= stack [ - 1 ] : stack . append ( ma ) elif mi <= stack [ - 1 ] : stack . append ( mi ) else : flag = False if flag : print ( ' YES ' ) else : print ( ' NO ' )   if __name__ == ' _ _ main _ _ ' : turn_the_rectangles_perfect ( ) NEW_LINE","n = int ( input ( ) ) prev = 10 ** 9 + 1 ans = ' YES ' for _ in range ( n ) : w , h = map ( int , input ( ) . split ( ) ) if w > h : w , h = h , w if h <= prev : prev = h elif w <= prev : prev = w else : ans = ' NO ' print ( ans ) NEW_LINE"],"bleu":0.3239206886220766,"rouge_l":0.4843655878648486}
{"id":496,"predictions":["import sys   n , m , k = [ int ( x ) for x in sys . stdin . readline ( ) . strip ( ) . split ( \" ▁ \" ) ] arr = [ int ( x ) for x in sys . stdin . readline ( ) . strip ( ) . split ( \" ▁ \" ) ]   delta = [ ] delta . append ( arr [ 0 ] ) for i in range ( 1 , n ) : delta . append ( arr [ i ] - arr [ i - 1 ] )   ops = [ ]   for i in range ( m ) : l , r , d = [ int ( x ) for x in sys . stdin . readline ( ) . strip ( ) . split ( \" ▁ \" ) ] op = ( l , r , d ) ops . append ( op )   num_calls = [ 0 ] * mfor i in range ( k ) : x , y = [ int ( x ) for x in sys . stdin . readline ( ) . strip ( ) . split ( \" ▁ \" ) ] num_calls [ x - 1 ] += 1 if y < len ( num_calls ) : num_calls [ y ] -= 1     NEW_LINE"],"references":["n , m , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) ans , result = 0 , 0 page , new_result = None , 1 for i in range ( m ) : if ( a [ i ] - result ) \/\/ k != page : ans += 1 result = new_result page = ( a [ i ] - result ) \/\/ k new_result += 1 print ( ans ) NEW_LINE","from collections import defaultdictimport sysinput = sys . stdin . readline   inf = 100000000000000000 NEW_LINE","n , m , k = map ( int , input ( ) . split ( ) ) ar = list ( map ( int , input ( ) . split ( ) ) ) page = kobj = 0 temp = 0 count = 0 i = 0 while i < m : if ar [ i ] - obj <= page : temp += 1 i += 1 continue if temp != 0 : count += 1 obj += temp temp = 0 if ( ar [ i ] - obj ) > page : page += k * ( int ( ( ar [ i ] - obj - page + k - 1 ) \/ k ) ) if temp != 0 : count += 1 print ( count ) NEW_LINE","n , m , k = map ( int , input ( ) . split ( ) ) p = [ int ( x ) for x in input ( ) . split ( ) ] t = 0 i = 0 op = 0 while ( i < m ) : cmp = ( ( p [ i ] - t - 1 ) \/\/ k + 1 ) * k i += 1 temp = t t += 1 op += 1 while ( i < m ) : if p [ i ] - temp <= cmp : i += 1 t += 1 else : breakprint ( op ) NEW_LINE","n , m , k = [ int ( p ) for p in input ( ) . split ( ) ] arr = [ int ( p ) for p in input ( ) . split ( ) ] for i in range ( len ( arr ) ) : arr [ i ] -= 1 cnt = 0 steps = 0 i = 0 gcnt = 0 while i < m : pg = ( arr [ i ] - gcnt ) \/\/ k j = i loop = True while j < m : if ( arr [ j ] - gcnt ) \/\/ k == pg : cnt += 1 j += 1 else : break if loop : steps += 1 loop = False i = j gcnt = cntprint ( steps ) NEW_LINE"],"bleu":0.23762266245166194,"rouge_l":0.41559049032966583}
{"id":497,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["import math NEW_LINE cases = int ( input ( ) ) NEW_LINE for c in range ( cases ) : NEW_LINE INDENT length , k = map ( int , input ( ) . split ( ) ) NEW_LINE string = input ( ) NEW_LINE start = string . index ( ' * ' ) NEW_LINE end = length - 1 - string [ : : - 1 ] . index ( ' * ' ) NEW_LINE count = 1 NEW_LINE while start < end : NEW_LINE INDENT ind = start + k NEW_LINE if ind >= end : NEW_LINE INDENT count += 1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT while ind > start : NEW_LINE INDENT if string [ ind ] == ' * ' : NEW_LINE INDENT count += 1 NEW_LINE break NEW_LINE DEDENT ind -= 1 NEW_LINE DEDENT DEDENT start = ind NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT","tests = int ( input ( ) ) NEW_LINE for _ in range ( tests ) : NEW_LINE INDENT n , k = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE s = list ( input ( ) ) NEW_LINE start = 0 NEW_LINE end = len ( s ) NEW_LINE count = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == ' * ' : NEW_LINE INDENT s [ i ] = ' x ' NEW_LINE start = i NEW_LINE count += 1 NEW_LINE break NEW_LINE DEDENT DEDENT for i2 in range ( len ( s ) ) : NEW_LINE INDENT i = len ( s ) - i2 - 1 NEW_LINE if s [ i ] == ' * ' : NEW_LINE INDENT s [ i ] = ' x ' NEW_LINE end = i NEW_LINE count += 1 NEW_LINE break NEW_LINE DEDENT DEDENT if end == len ( s ) : NEW_LINE INDENT end = start NEW_LINE DEDENT counter = 0 NEW_LINE while end - start > k : NEW_LINE INDENT for i in range ( start + k , start , - 1 ) : NEW_LINE INDENT if s [ i ] == ' * ' : NEW_LINE INDENT s [ i ] = ' x ' NEW_LINE start = i NEW_LINE count += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT print ( count ) NEW_LINE DEDENT","tests = int ( input ( ) ) NEW_LINE for _ in range ( tests ) : NEW_LINE INDENT n , k = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE s = list ( input ( ) ) NEW_LINE start = 0 NEW_LINE end = len ( s ) NEW_LINE count = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == ' * ' : NEW_LINE INDENT s [ i ] = ' x ' NEW_LINE start = i NEW_LINE count += 1 NEW_LINE break NEW_LINE DEDENT DEDENT for i2 in range ( len ( s ) ) : NEW_LINE INDENT i = len ( s ) - i2 - 1 NEW_LINE if s [ i ] == ' * ' : NEW_LINE INDENT s [ i ] = ' x ' NEW_LINE end = i NEW_LINE count += 1 NEW_LINE break NEW_LINE DEDENT DEDENT if end == len ( s ) : NEW_LINE INDENT end = start NEW_LINE DEDENT counter = 0 NEW_LINE while end - start > k : NEW_LINE INDENT for i in range ( start + k , start , - 1 ) : NEW_LINE INDENT if s [ i ] == ' * ' : NEW_LINE INDENT s [ i ] = ' x ' NEW_LINE start = i NEW_LINE count += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT print ( count ) NEW_LINE DEDENT","for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , k = list ( map ( int , input ( ) . split ( ' ▁ ' ) ) ) NEW_LINE s = input ( ) NEW_LINE i = s . find ( ' * ' ) NEW_LINE end = s . rfind ( ' * ' ) NEW_LINE stars = 2 if i != end else 1 NEW_LINE while i + k < end : NEW_LINE INDENT if s [ i + k ] == ' * ' : NEW_LINE INDENT i += k NEW_LINE stars += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT DEDENT print ( stars ) NEW_LINE DEDENT","def answer ( st , k ) : NEW_LINE INDENT ss , es = st . find ( ' * ' ) , st . rfind ( ' * ' ) NEW_LINE count = 1 NEW_LINE i = ss NEW_LINE while i < es : NEW_LINE INDENT if st [ i ] == ' * ' : count += 1 NEW_LINE nextStar = min ( len ( st ) - 1 , i + k ) NEW_LINE while st [ nextStar ] != ' * ' : nextStar -= 1 NEW_LINE i = nextStar NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n , k = tuple ( map ( int , input ( ) . split ( ) ) ) NEW_LINE st = input ( ) NEW_LINE print ( answer ( st , k ) ) NEW_LINE DEDENT DEDENT"],"bleu":0.08623423151057234,"rouge_l":0.2618025751072961}
{"id":498,"predictions":["n , a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE dp = [ int ( a ) for a in input ( ) . split ( ) ] NEW_LINE c_min = 0 NEW_LINE cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT dp [ i ] = min ( dp [ i - 1 ] , dp [ i ] ) NEW_LINE cnt += 1 NEW_LINE DEDENT DEDENT if cnt == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( cnt ) NEW_LINE DEDENT"],"references":["n , a , b , c , T = map ( int , input ( ) . split ( ) ) ts = list ( map ( int , input ( ) . split ( ) ) ) ts . sort ( ) ans = 0 for t in ts : temp = - 10 ** 18 for u in range ( t , T + 1 ) : temp = max ( temp , c * ( u - t ) + a - b * ( u - t ) ) NEW_LINE","n , A , B , C , T = map ( int , input ( ) . split ( ) ) t = list ( map ( int , input ( ) . split ( ) ) ) if ( B >= C ) : print ( A * n ) else : ans = 0 for c in t : ans += ( T - c ) * ( C - B ) ans += n * A print ( ans ) NEW_LINE","n , A , B , C , T = map ( int , input ( ) . split ( ) ) t = [ int ( i ) for i in input ( ) . split ( ) ] t . sort ( )   total_sum = 0   for lower_border in range ( n + 1 ) : NEW_LINE","n , a , b , c , t = map ( int , input ( ) . split ( ) ) ar = list ( map ( int , input ( ) . split ( ) ) ) an = n * aif c - b > 0 : for j in range ( n ) : an = an + ( t - ar [ j ] ) * ( c - b ) print ( an ) NEW_LINE","n , a , b , c , t = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) f = [ 0 ] * 1001 for i in l : f [ i ] -= - 1 tmp = 0 tmp2 = 0 for i in range ( 1 , t ) : tmp += ( t - i ) * f [ i ] tmp = n * a + tmp * c - tmp * bprint ( max ( n * a , tmp ) ) NEW_LINE"],"bleu":0.38581527423156975,"rouge_l":0.5651679791800452}
{"id":499,"predictions":["import sys , os , ioimport math , bisect , operatorinf , mod = float ( ' inf ' ) , 10 ** 9 + 7 NEW_LINE"],"references":["f = lambda : [ int ( q ) - 1 for q in input ( ) . split ( ) ] def g ( ) : for i in p : if h [ i ] == k and not v [ i ] : return i   r = range ( int ( input ( ) ) ) t , h = 1e9 , f ( ) u = [ set ( f ( ) [ 1 : ] ) for i in r ]   for k in ( 0 , 1 , 2 ) : p = list ( r ) d = - 1 v = [ q . copy ( ) for q in u ]   while p : i = g ( ) while i != None : d += 1 p . remove ( i ) for q in v : q . discard ( i ) i = g ( ) k = ( k + 1 ) % 3 d += 1   t = min ( d , t )   print ( t ) NEW_LINE","n = int ( input ( ) ) c = list ( map ( int , input ( ) . split ( ) ) ) d = dict ( ) d [ 1 ] = [ ] d [ 2 ] = [ ] d [ 3 ] = [ ] for i in range ( n ) : d [ c [ i ] ] . append ( i ) done = set ( ) mas = [ ] k = 0 poss = set ( ) for i in range ( n ) : l = list ( map ( int , input ( ) . split ( ) ) ) l = l [ 1 : ] mas . append ( l ) if len ( l ) == 0 : k = c [ i ] poss . add ( ( k , i ) ) o = 0 bigans = 1000000000 for a in poss : k = a [ 0 ] done = set ( ) done . add ( a [ 1 ] + 1 ) ans = 1 while len ( done ) != n : NEW_LINE","f = lambda : [ int ( q ) - 1 for q in input ( ) . split ( ) ] def g ( ) : for i in p : if h [ i ] == k and not v [ i ] : return i   r = range ( int ( input ( ) ) ) t , h = 1e9 , f ( ) u = [ set ( f ( ) [ 1 : ] ) for i in r ]   for k in ( 0 , 1 , 2 ) : p = list ( r ) d = - 1 v = [ q . copy ( ) for q in u ]   while p : i = g ( ) while i != None : d += 1 p . remove ( i ) for q in v : q . discard ( i ) i = g ( ) k = ( k + 1 ) % 3 d += 1   t = min ( d , t )   print ( t ) NEW_LINE","from collections import *   read_line = lambda : [ int ( i ) for i in input ( ) . split ( ' ▁ ' ) ]   n = read_line ( ) [ 0 ] cs = [ c - 1 for c in read_line ( ) ] g = [ [ ] for v in range ( n ) ] parent_cnt = [ 0 ] * nfor v in range ( n ) : parents = read_line ( ) parent_cnt [ v ] = len ( parents ) - 1 for i in range ( 1 , len ( parents ) ) : g [ parents [ i ] - 1 ] . append ( v )   def work ( x ) : pcnt = list ( parent_cnt ) qs = [ deque ( v for v in range ( n ) if cs [ v ] == c and pcnt [ v ] == 0 ) for c in range ( 3 ) ] ans = 0 while True : while qs [ x ] : v = qs [ x ] . popleft ( ) ans += 1 for w in g [ v ] : pcnt [ w ] -= 1 if pcnt [ w ] == 0 : qs [ cs [ w ] ] . append ( w ) if qs [ 0 ] or qs [ 1 ] or qs [ 2 ] : ans += 1 x = ( x + 1 ) % 3 else : break return ans   print ( min ( work ( i ) for i in range ( 3 ) ) ) NEW_LINE"],"bleu":0.0002976435858278843,"rouge_l":0.07376058041112454}
{"id":500,"predictions":["s = input ( ) a = \" abcdefghijklmnopqrstuvwxyz \" x = s . index ( x ) a . index ( y ) s = s . index ( y ) a . index ( x [ 0 ] ) if s [ 0 ] == s [ 1 ] : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"references":["def cc ( w , me , fe ) : global m , f if w . endswith ( me ) : m = True return True elif w . endswith ( fe ) : f = True return True else : return Falsedef ad ( w ) : return cc ( w , ' lios ' , ' liala ' ) def nn ( w ) : return cc ( w , ' etr ' , ' etra ' ) def vb ( w ) : return cc ( w , ' initis ' , ' inites ' ) s , n , m , f = input ( ) . split ( ) , False , False , False for w in s : if not n : if ad ( w ) or vb ( w ) and len ( s ) == 1 : pass elif nn ( w ) : n = True else : print ( \" NO \" ) exit ( ) elif not vb ( w ) : print ( \" NO \" ) exit ( ) print ( ' YES ' if len ( s ) == 1 or ( n and ( m ^ f ) ) else ' NO ' ) NEW_LINE","def classification ( s ) : isWord = False gender = 0 tipo = 0 feminino = [ \" liala \" , \" etra \" , \" inites \" ] masculino = [ \" lios \" , \" etr \" , \" initis \" ]   for i in range ( 3 ) : if ( s . endswith ( feminino [ i ] ) ) : gender = 1 tipo = i isWord = True elif ( s . endswith ( masculino [ i ] ) ) : tipo = i isWord = True return [ isWord , gender , tipo ]   words = [ classification ( s ) for s in input ( ) . split ( ) ] areWords = [ x [ 0 ] for x in words ] gender = [ x [ 1 ] for x in words ] tipo = [ x [ 2 ] for x in words ]   poss = Truefor i in areWords : if ( i == 0 ) : poss = False   if ( poss ) : last = gender [ 0 ] for i in gender [ 1 : ] : if ( i != last ) : poss = False break last = i   if ( poss ) : last = tipo [ 0 ] for i in tipo [ 1 : ] : if ( i < last ) : poss = False break last = i   if ( poss ) : cnt1 = 0 for i in tipo : if ( i == 1 ) : cnt1 += 1 if ( cnt1 != 1 ) : poss = False   if ( len ( words ) == 1 and areWords [ 0 ] == True ) : poss = True   if ( poss ) : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.048687682157528125,"rouge_l":0.22761029756706624}
{"id":501,"predictions":["s = input ( ) ans = 0 n = len ( s ) for i in range ( 1 , n ) : ans += s [ i ] if ans % 2 == 0 and n % 2 == 1 : print ( ans ) NEW_LINE"],"references":["letters = list ( map ( str , input ( ) ) ) c = set ( ) for letter in letters : if letter . isalpha ( ) : c . add ( letter ) print ( len ( c ) ) NEW_LINE","info = input ( ) if len ( set ( info ) ) - 4 > 0 : print ( len ( set ( info ) ) - 4 ) elif len ( set ( info ) ) - 4 == - 1 : print ( 1 ) elif len ( set ( info ) ) - 4 < 0 : print ( 0 ) NEW_LINE","s = input ( \" \" ) s1 = \" \" for i in s : if i not in s1 : s1 = s1 + ik = len ( s1 ) - 4 if len ( s ) == 2 : print ( 0 ) elif len ( s ) == 3 : print ( 1 ) else : print ( len ( s1 ) - 4 ) NEW_LINE","a = set ( list ( input ( ) [ 1 : - 1 ] . split ( ' , ▁ ' ) ) ) if ' ' not in a : print ( len ( a ) ) else : print ( 0 ) NEW_LINE","a = input ( ) . split ( ' , ▁ ' ) a [ 0 ] = a [ 0 ] [ 1 : : ] a [ len ( a ) - 1 ] = a [ len ( a ) - 1 ] [ : - 1 : ] if a [ 0 ] != ' ' : print ( len ( set ( a ) ) ) else : print ( 0 ) NEW_LINE"],"bleu":0.28637379498428367,"rouge_l":0.3906678865507776}
{"id":502,"predictions":["a , b , r = map ( int , input ( ) . split ( ) ) if ( 2 * r > min ( a , b ) : print ( \" - 1\" ) else : print ( max ( a , b ) ) NEW_LINE"],"references":["if __name__ == \" _ _ main _ _ \" : a , b , c , d , k = map ( int , input ( ) . split ( ) ) start = max ( a , c ) end = min ( b , d ) ans = end - start if ans < 0 : ans = 0 elif k < start or k > end : ans = ans + 1 print ( ans ) NEW_LINE","l1 , r1 , l2 , r2 , k = map ( int , input ( ) . split ( ) )   if l2 <= l1 : if r1 >= l1 : n1 = l1 n2 = min ( r1 , r2 ) else : n1 = 0 n2 = 0 else : if r1 >= l1 : n1 = l2 n2 = min ( r1 , r2 ) else : n1 = 0 n2 = 0 if n1 != 0 or n2 != 0 : ans = ( n2 - n1 ) + 1 if k in range ( n1 , n2 + 1 ) : ans -= 1 print ( max ( 0 , ans ) ) else : print ( 0 ) NEW_LINE","l1 , r1 , l2 , r2 , k = map ( int , input ( ) . split ( ) ) if l1 <= l2 <= r1 : if r2 <= r1 : if l2 <= k <= r2 : print ( r2 - l2 ) else : print ( r2 - l2 + 1 ) else : if l2 <= k <= r1 : print ( r1 - l2 ) else : print ( r1 - l2 + 1 ) elif l1 <= l2 and l2 >= r1 : print ( 0 ) elif l2 < l1 <= r2 : if r2 <= r1 : if l1 <= k <= r2 : print ( r2 - l1 ) else : print ( r2 - l1 + 1 ) else : if l1 <= k <= r1 : print ( r1 - l1 ) else : print ( r1 - l1 + 1 ) else : print ( 0 ) NEW_LINE","    l1 , r1 , l2 , r2 , k = map ( int , input ( ) . split ( ) )     start = max ( l2 , l1 ) end = min ( r1 , r2 )         if end >= start : total = end - start + 1 if start <= k <= end : print ( max ( total - 1 , 0 ) ) else : print ( total ) else : print ( 0 ) NEW_LINE","if __name__ == ' _ _ main _ _ ' : l1 , r1 , l2 , r2 , k = map ( int , input ( ) . split ( ) ) if l2 > l1 : l1 = l2 if r2 < r1 : r1 = r2 print ( max ( r1 - l1 + 1 - ( l1 <= k <= r1 ) , 0 ) ) NEW_LINE"],"bleu":0.3626292401156405,"rouge_l":0.4667316780436576}
{"id":503,"predictions":["import sys , os , ioimport math , bisect , operatorinf , mod = float ( ' inf ' ) , 10 ** 9 + 7 NEW_LINE"],"references":["def main ( ) : start , end , t = map ( int , input ( ) . split ( ) ) n = int ( input ( ) ) people = [ ] if n != 0 : people = list ( map ( int , input ( ) . split ( ) ) ) time = start ans = 1e16 answer = 0 for p in people : if p + t > end : break if p - 1 >= 0 : if ans > max ( 0 , time - ( p - 1 ) ) : ans = max ( 0 , time - ( p - 1 ) ) answer = p - 1   time = max ( time , p ) + t   if time + t > end : break   if time + t <= end : answer = time print ( answer )   main ( ) NEW_LINE","begin , end , time = list ( map ( int , input ( ) . split ( ) ) ) n = int ( input ( ) ) if n == 1 : print ( begin ) elif n > 0 : ar = list ( map ( int , input ( ) . split ( ) ) ) ar . sort ( ) i = 0 ar . append ( end - time + 1 ) n += 1   num = begin ans = begin - ar [ 0 ] + 1 fin_ans = ar [ 0 ] - 1 while i < n : num = max ( num + time , ar [ i ] + time ) while i + 1 < n and ar [ i + 1 ] == ar [ i ] : i += 1 num += time i += 1 if i < n and num - ar [ i ] + 1 < ans and max ( ar [ i ] - 1 , num ) + time <= end : ans = num - ar [ i ] + 1 fin_ans = ar [ i ] - 1   print ( fin_ans )   else : print ( begin ) NEW_LINE","import syst1 , t2 , t = map ( int , input ( ) . split ( ) ) u = 1 n = int ( input ( ) ) if n == 0 : print ( t1 ) sys . exit ( ) a = [ int ( i ) for i in input ( ) . split ( ) ] mini = 10 ** 20 ans = 0 time = t1for x in a : if x <= t2 - t : if time - x + 1 < mini and x > 0 : mini = time - x + 1 if x - 1 > time : ans = time else : ans = x - 1 time = t + max ( time , x ) if time > t2 - t : print ( ans ) else : print ( time ) NEW_LINE"],"bleu":0.000979627679283284,"rouge_l":0.11111111111111113}
{"id":504,"predictions":["import sys , mathfrom collections import deque , defaultdictimport operator as opfrom functools import reducefrom itertools import permutations   NEW_LINE"],"references":["s = input ( ) if ( s . find ( \" AB \" ) != - 1 and s . find ( \" BA \" ) != - 1 and ( s . find ( \" AB \" ) + 1 < s . rfind ( \" BA \" ) or s . find ( \" BA \" ) + 1 < s . rfind ( \" AB \" ) ) ) : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE","s = input ( ) n = len ( s ) ab = [ False ] * nba = [ False ] * nf = False   for i in range ( 1 , n ) : ab [ i ] |= ab [ i - 1 ] if s [ i - 1 : i + 1 ] == ' AB ' : ab [ i ] |= True if i > 1 and ba [ i - 2 ] : f = True break   ba [ i ] |= ba [ i - 1 ] if s [ i - 1 : i + 1 ] == ' BA ' : ba [ i ] |= True if i > 1 and ab [ i - 2 ] : f = True break   if f : print ( ' YES ' ) else : print ( ' NO ' ) NEW_LINE","s = input ( ) n = len ( s ) l , r = [ ] , [ ] for i in range ( n - 1 ) : if s [ i : i + 2 ] == \" AB \" : l . append ( i ) elif s [ i : i + 2 ] == \" BA \" : r . append ( i ) i , j = 0 , 0 while i < len ( l ) and j < len ( r ) : if l [ i ] + 2 <= r [ j ] : print ( \" YES \" ) exit ( ) else : j += 1 l , r = r , li , j = 0 , 0 while i < len ( l ) and j < len ( r ) : if l [ i ] + 2 <= r [ j ] : print ( \" YES \" ) exit ( ) else : j += 1 print ( \" NO \" ) NEW_LINE","def solve ( ) : s = input ( ) c1 , c2 = s . count ( \" AB \" ) , s . count ( \" BA \" ) if ( c1 == 0 or c2 == 0 ) : return \" NO \" else : ind = s . find ( \" AB \" ) if ( s [ ind + 2 : ] . find ( \" BA \" ) != - 1 ) : return \" YES \" ind = s . find ( \" BA \" ) if ( s [ ind + 2 : ] . find ( \" AB \" ) != - 1 ) : return \" YES \" return \" NO \" print ( solve ( ) ) NEW_LINE"],"bleu":0.001923563113124513,"rouge_l":0.03557542768273717}
{"id":505,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) c = 0 k = 0 for i in range ( n ) : if i < 0 : c += a [ i ] else : k += 1 if c > 0 : k += 1 print ( k ) NEW_LINE"],"references":["c = 0 for i in range ( int ( input ( ) . split ( ) [ 0 ] ) ) : a = input ( ) . split ( ) while len ( a ) : if '1' in [ a . pop ( ) , a . pop ( ) ] : c += 1 print ( c ) NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) count = 0 for i in range ( n ) : arr = list ( map ( int , input ( ) . split ( ) ) ) for j in range ( 0 , 2 * m , 2 ) : if arr [ j ] == 1 or arr [ j + 1 ] == 1 : count += 1 print ( count ) NEW_LINE","temp = [ int ( x ) for x in input ( ) . split ( ) ] n = temp [ 0 ] m = temp [ 1 ] result = 0 for i in range ( n ) : a = [ int ( x ) for x in input ( ) . split ( ) ] for j in range ( m ) : if a [ 2 * j - 2 ] == 1 or a [ 2 * j - 1 ] == 1 : result += 1 print ( result ) NEW_LINE","import sys   def main ( ) : inp = sys . stdin . read ( ) . strip ( ) . split ( ' \\n ' ) c = 0 for s in inp [ 1 : ] : t = s . split ( ) for i in range ( 0 , len ( t ) , 2 ) : c += '1' in t [ i : i + 2 ] return c   print ( main ( ) ) NEW_LINE","def main_function ( ) : n , m = [ int ( i ) for i in input ( ) . split ( \" ▁ \" ) ] count = 0 for i in range ( n ) : f = [ int ( i ) for i in input ( ) . split ( \" ▁ \" ) ] already_list_on = False for j in range ( len ( f ) ) : if not j % 2 and f [ j ] == 1 : count += 1 already_list_on = True elif j % 2 and f [ j ] == 1 and not already_list_on : count += 1 already_list_on = False elif j % 2 : already_list_on = False   return count     print ( main_function ( ) ) NEW_LINE"],"bleu":0.5644032023614219,"rouge_l":0.5204778156996588}
{"id":506,"predictions":["print ( ( int ( input ( ) ) * 2 ) \/\/ 3 ) NEW_LINE"],"references":["n = int ( input ( ) ) NEW_LINE print ( n \/\/ 2 * 3 ) NEW_LINE","n = int ( input ( ) ) NEW_LINE print ( n + ( n \/\/ 2 ) ) NEW_LINE","n = int ( input ( ) )   print ( n + n \/\/ 2 ) NEW_LINE","n = int ( input ( ) ) NEW_LINE print ( n * 3 \/\/ 2 ) NEW_LINE"],"bleu":0.4856513339512482,"rouge_l":0.5820610687022901}
{"id":507,"predictions":["n = int ( input ( ) ) output = [ ] for i in range ( max ( n - 100 , 0 ) , n ) : listi = list ( map ( int , str ( i ) ) ) if ( i + sum ( listi ) == n ) : output . append ( i ) print ( len ( output ) ) for i in range ( len ( output ) ) : print ( output [ i ] ) NEW_LINE"],"references":["print ( ( int ( input ( ) ) - 1 ) % 9 + 1 ) NEW_LINE","def croot ( s ) : NEW_LINE INDENT s = list ( s ) NEW_LINE s = list ( map ( int , s ) ) NEW_LINE s = sum ( s ) NEW_LINE return str ( s ) NEW_LINE DEDENT s = input ( ) NEW_LINE while len ( s ) > 1 : NEW_LINE INDENT s = croot ( s ) NEW_LINE DEDENT print ( s ) NEW_LINE","n = int ( input ( ) ) NEW_LINE if ( n <= 9 ) : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT else : NEW_LINE INDENT while ( n > 9 ) : NEW_LINE INDENT m = n NEW_LINE s = 0 NEW_LINE while ( m != 0 ) : NEW_LINE INDENT a = m % 10 NEW_LINE s += a NEW_LINE m = m \/\/ 10 NEW_LINE DEDENT n = s NEW_LINE DEDENT print ( s ) NEW_LINE DEDENT","def digital_root ( n ) : NEW_LINE INDENT x = sum ( int ( digit ) for digit in str ( n ) ) NEW_LINE if x < 10 : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT return digital_root ( x ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT a = int ( input ( ) ) NEW_LINE print ( digital_root ( a ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT","num = int ( input ( ) ) NEW_LINE num %= 9 NEW_LINE if ( num == 0 ) : NEW_LINE INDENT num = 9 NEW_LINE DEDENT print ( num ) NEW_LINE"],"bleu":0.24737013837967278,"rouge_l":0.45553292600135775}
{"id":508,"predictions":["t = int ( input ( ) ) for i in range ( t ) : a , b = map ( int , input ( ) . split ( ) ) S = ( a * b + 1 ) * 2 print ( S ) NEW_LINE"],"references":["a = int ( input ( ) ) for i in range ( a ) : c , d = map ( int , input ( ) . split ( ) ) c , d = min ( c , d ) , max ( c , d ) if ( 2 * c > d ) : print ( 2 * 2 * c * c ) else : print ( d * d ) NEW_LINE","n = int ( input ( ) )   for _ in range ( n ) : side_length = list ( map ( int , input ( ) . split ( ) ) ) print ( max ( min ( side_length ) * 2 , max ( side_length ) ) ** 2 ) NEW_LINE","for x in range ( int ( input ( ) ) ) : a , b = map ( int , input ( ) . split ( ) ) mi = min ( a , b ) ma = max ( a , b ) if 2 * mi < ma : print ( ma ** 2 ) else : print ( ( mi * 2 ) ** 2 ) NEW_LINE","t = int ( input ( ) )   for tc in range ( t ) :   a , b = map ( int , input ( ) . split ( ) )   twow = a * 2 twol = b * 2   twowsq = max ( twow , b ) twolsq = max ( twol , a )   print ( min ( twolsq , twowsq ) ** 2 )     NEW_LINE"],"bleu":0.6792107885009012,"rouge_l":0.6917873667270167}
{"id":509,"predictions":["t = int ( input ( ) ) for _ in range ( t ) : n , x = map ( int , input ( ) . split ( ) ) a = [ int ( x ) for x in input ( ) . split ( ) ] b = [ int ( x ) for x in input ( ) . split ( ) ] d = { } for i in range ( n ) : a [ i ] = x [ i ] b [ i ] = x ans = 0 for i in range ( n ) : ans += d [ a [ i ] ] print ( ans ) NEW_LINE"],"references":["n = int ( input ( ) )   a = [ int ( i ) for i in input ( ) . split ( ' ▁ ' ) ]   m = int ( input ( ) ) b = [ int ( i ) for i in input ( ) . split ( ' ▁ ' ) ]     store = { } vasya , petya = 0 , 0   max_stored = 0   for bi in b :   if bi not in store :   i = max_stored while bi not in store : store [ a [ i ] ] = ( i + 1 , n - i ) i += 1 max_stored = i vasya += store [ bi ] [ 0 ] petya += store [ bi ] [ 1 ]   print ( vasya , petya ) NEW_LINE","n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) d = { } for i in range ( n ) : d [ a [ i ] ] = i NEW_LINE","n = int ( input ( ) ) lst = input ( ) . split ( ) index_to_val = { lst [ idx ] : idx + 1 for idx in range ( n ) } input ( ) x = y = 0 for q in input ( ) . split ( ) : x += index_to_val [ q ] y += n - index_to_val [ q ] + 1 print ( x , y ) NEW_LINE"],"bleu":0.5056410793974209,"rouge_l":0.6920549271903427}
{"id":510,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["n = int ( input ( ) ) b = [ 0 ] * 26 result = 0 for i in range ( n ) : s = input ( ) b [ ord ( s [ 0 ] ) - 97 ] += 1 for i in b : result += ( ( i \/\/ 2 ) * ( i \/\/ 2 - 1 ) ) \/\/ 2 result += ( ( i - i \/\/ 2 ) * ( i - i \/\/ 2 - 1 ) ) \/\/ 2 print ( result ) NEW_LINE","n = int ( input ( ) ) c1 = [ ] c2 = [ ] for i in range ( n ) : name = input ( ) cnt1 = 0 cnt2 = 0 for i in c1 : if i [ 0 ] == name [ 0 ] : cnt1 += 1 for i in c2 : if i [ 0 ] == name [ 0 ] : cnt2 += 1 if cnt1 < cnt2 : c1 . append ( name ) else : c2 . append ( name ) count = 0 k = 0 for i in range ( len ( c1 ) ) : let = c1 [ i ] [ 0 ] for j in range ( i + 1 , len ( c1 ) ) : if c1 [ j ] [ 0 ] == let : count += 1   for i in range ( len ( c2 ) ) : let = c2 [ i ] [ 0 ] for j in range ( i + 1 , len ( c2 ) ) : if c2 [ j ] [ 0 ] == let : count += 1     print ( count ) NEW_LINE","import math   n = int ( input ( ) ) students = [ ] for s in range ( n ) : students . append ( input ( ) ) pairs = 0 letters = { } for i in range ( n ) : letters [ students [ i ] [ 0 ] ] = 0   for j in range ( n ) : letters [ students [ j ] [ 0 ] ] += 1   for lt in letters : if letters [ lt ] > 1 :   num1 = letters [ lt ] \/\/ 2 num2 = letters [ lt ] - num1   for x1 in range ( num1 - 1 ) : for y1 in range ( x1 + 1 , num1 ) : if x1 != y1 : pairs += 1   for x2 in range ( num2 - 1 ) : for y2 in range ( x2 + 1 , num2 ) : if x2 != y2 : pairs += 1   NEW_LINE","from collections import Counter   cases = int ( input ( ) ) letters = [ ] while cases : cases -= 1 s = input ( ) [ 0 ] letters . append ( s )   count = Counter ( letters )     def cnt ( num ) : res = num * ( num - 1 ) \/\/ 2 return res     ans = 0   for val in count . values ( ) : ans += cnt ( val \/\/ 2 ) ans += cnt ( val - val \/\/ 2 )   print ( ans ) NEW_LINE"],"bleu":0.050202211475736586,"rouge_l":0.3004926108374384}
{"id":511,"predictions":["def STR ( ) : return list ( input ( ) ) def INT ( ) : return int ( input ( ) ) def MAP ( ) : return map ( int , input ( ) . split ( ) ) def MAP2 ( ) : return map ( float , input ( ) . split ( ) ) def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) def STRING ( ) : return input ( ) import stringimport sysfrom heapq import heappop , heappushfrom bisect import * from collections import deque , Counter , defaultdictfrom math import * from itertools import permutations , accumulatedx = [ - 1 , 1 , 0 , 0 ] dy = [ 0 , 0 , 1 , - 1 ] NEW_LINE"],"references":["def find_company ( friends , d ) :   def mergesort_tuples ( tuples , index ) :   def merge ( A , B ) : i , j = 0 , 0 result = [ ] while i < len ( A ) and j < len ( B ) : if A [ i ] [ index ] < B [ j ] [ index ] : result . append ( A [ i ] ) i += 1 else : result . append ( B [ j ] ) j += 1   result += A [ i : ] result += B [ j : ]   return result   def divide ( tuples ) : if len ( tuples ) > 1 : middle = len ( tuples ) \/\/ 2 return merge ( divide ( tuples [ : middle ] ) , divide ( tuples [ middle : ] ) )   return tuples   return divide ( tuples )   def solve ( friends , d ) : friends = mergesort_tuples ( friends , 0 ) left_ptr = 0 right_ptr = 0 current_friendship = 0 max_friendship = 0 while right_ptr < len ( friends ) : if friends [ right_ptr ] [ 0 ] - friends [ left_ptr ] [ 0 ] < d : current_friendship += friends [ right_ptr ] [ 1 ] right_ptr += 1 else : max_friendship = max ( current_friendship , max_friendship ) current_friendship -= friends [ left_ptr ] [ 1 ] left_ptr += 1   max_friendship = max ( current_friendship , max_friendship )   return max_friendship   return solve ( friends , d )     if __name__ == \" _ _ main _ _ \" : n , d = [ int ( x ) for x in input ( ) . split ( ) ] friends = [ ] for _ in range ( n ) : friends . append ( tuple ( [ int ( x ) for x in input ( ) . split ( ) ] ) ) print ( find_company ( friends , d ) ) NEW_LINE","n , d = map ( int , input ( ) . split ( ) ) mat = [ ] for _ in range ( n ) : mat . append ( list ( map ( int , input ( ) . split ( ) ) ) ) mat . sort ( key = lambda x : x [ 0 ] )   dp = [ 0 ] * ndp [ 0 ] = mat [ 0 ] [ 1 ] for i in range ( 1 , n ) : dp [ i ] = dp [ i - 1 ] + mat [ i ] [ 1 ] i = j = 0 res = dp [ 0 ] while i < n and j < n : if mat [ j ] [ 0 ] - mat [ i ] [ 0 ] < d : res = max ( res , dp [ j ] - dp [ i ] + mat [ i ] [ 1 ] ) j += 1 else : i += 1 print ( res ) NEW_LINE","import reimport sysexit = sys . exitfrom bisect import bisect_left as bsl , bisect_right as bsrfrom collections import Counter , defaultdict as ddict , dequefrom functools import lru_cachecache = lru_cache ( None ) from heapq import * from itertools import * from math import inffrom pprint import pprint as ppenum = enumerateri = lambda : int ( rln ( ) ) ris = lambda : list ( map ( int , rfs ( ) ) ) rln = sys . stdin . readlinerl = lambda : rln ( ) . rstrip ( ' \\n ' ) rfs = lambda : rln ( ) . split ( ) mod = 1000000007 d4 = [ ( 0 , - 1 ) , ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 0 ) ] d8 = [ ( - 1 , - 1 ) , ( 0 , - 1 ) , ( 1 , - 1 ) , ( - 1 , 0 ) , ( 1 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) ] NEW_LINE","n , d = map ( int , input ( ) . split ( ) ) m = [ ] f = [ ] for _ in range ( n ) : mm , ff = map ( int , input ( ) . split ( ) ) m . append ( mm ) f . append ( ff ) z = sorted ( zip ( m , f ) ) i , j , maxi , cnt = 0 , 0 , 0 , 0 while j < n : if z [ j ] [ 0 ] - z [ i ] [ 0 ] < d : cnt += z [ j ] [ 1 ] maxi = max ( maxi , cnt ) j += 1 else : cnt -= z [ i ] [ 1 ] i += 1 print ( maxi ) NEW_LINE"],"bleu":0.36697961669022316,"rouge_l":0.3711348524949971}
{"id":512,"predictions":["a , b = map ( int , input ( ) . split ( ) ) print ( abs ( a - b ) , abs ( a - b ) ) NEW_LINE"],"references":["a , b = map ( int , input ( ) . split ( ) ) first = 0 second = 0 draw = 0 for i in range ( 1 , 7 ) : if abs ( a - i ) > abs ( b - i ) : second += 1 elif abs ( a - i ) < abs ( b - i ) : first += 1 else : draw += 1 print ( first , draw , second ) NEW_LINE","F , S = map ( int , input ( ) . split ( ) ) if F == S : print ( 0 , 6 , 0 ) elif abs ( F - S ) % 2 == 1 : if F < S : F = F + ( ( abs ( F - S ) - 1 ) \/\/ 2 ) print ( F , 0 , 6 - F ) else : S = S + ( ( abs ( F - S ) - 1 ) \/\/ 2 ) print ( 6 - S , 0 , S ) else : if F < S : F = F + ( ( abs ( F - S ) \/\/ 2 ) - 1 ) print ( F , 1 , 6 - F - 1 ) else : S = S + ( ( abs ( F - S ) \/\/ 2 ) - 1 ) print ( 6 - S - 1 , 1 , S ) NEW_LINE","n = [ int ( x ) for x in input ( ) . split ( ) ] p1 = n [ 0 ] p2 = n [ 1 ] c1 = 0 c2 = 0 d = 0 for i in range ( 1 , 7 ) : if p1 == p2 : d = 6 break else : if i == p2 : c2 += 1 elif i == p1 : c1 += 1 elif abs ( i - p1 ) < abs ( i - p2 ) : c1 += 1 elif abs ( i - p1 ) > abs ( i - p2 ) : c2 += 1 elif abs ( i - p1 ) == abs ( i - p2 ) : d += 1 print ( c1 , d , c2 ) NEW_LINE","a , b = map ( int , input ( ) . split ( ) ) c = 0 d = 0 e = 0 for i in range ( 1 , 7 ) : if abs ( a - i ) < abs ( b - i ) : c += 1 elif abs ( a - i ) > abs ( b - i ) : e += 1 else : d += 1 print ( c , d , e ) NEW_LINE","import matha , b = [ int ( i ) for i in input ( ) . split ( \" ▁ \" ) ] w1 , w2 , t = 0 , 0 , 0 if ( a < b ) : tmp = int ( ( b - a - 1 ) \/ 2 ) w1 = a + tmp w2 = 7 - b + tmp t = math . ceil ( b - a - 1 ) % 2 print ( w1 , t , w2 ) elif ( a > b ) : tmp = int ( ( a - b - 1 ) \/ 2 ) w1 = 7 - a + tmp w2 = b + tmp t = math . ceil ( a - b - 1 ) % 2 print ( w1 , t , w2 ) else : print ( 0 , 6 , 0 ) NEW_LINE"],"bleu":0.16234210614391864,"rouge_l":0.4867438867438867}
{"id":513,"predictions":["for i in range ( int ( input ( ) ) ) : a , b = map ( int , input ( ) . split ( ) ) print ( a + b ) NEW_LINE"],"references":["from math import ceil   for t in range ( int ( input ( ) ) ) : a , b , c , d = map ( int , input ( ) . split ( ) ) if b >= a : print ( b ) continue if c - d <= 0 : print ( - 1 ) continue s = b + ceil ( ( a - b ) \/ ( c - d ) ) * c if s > a : print ( s ) else : print ( - 1 ) NEW_LINE","for _ in range ( int ( input ( ) ) ) : a , b , c , d = map ( int , input ( ) . split ( ) ) ans = 0 i = 0 if b >= a : print ( b ) elif a > b and c > d : k = ( a - b + ( c - d - 1 ) ) \/\/ ( c - d ) print ( b + k * c ) else : print ( - 1 ) NEW_LINE","import matht = int ( input ( ) ) for i in range ( t ) : a , b , c , d = map ( int , input ( ) . split ( ) ) if d >= c and b < a : print ( - 1 ) elif b >= a : print ( b ) else : awalTidur = a - b kesempatanTidur = c - d banyakTidur = math . ceil ( awalTidur \/ kesempatanTidur ) lamaTidur = ( banyakTidur * c ) + b print ( lamaTidur ) NEW_LINE","t = int ( input ( ) ) for i in range ( t ) : a , b , c , d = map ( int , input ( ) . split ( ) ) if a <= b : print ( b ) elif d >= c : print ( - 1 ) else : a -= b hasil = b + ( ( a + c - d - 1 ) \/\/ ( c - d ) * c ) print ( hasil ) NEW_LINE","pp = printli = listtp = tuplebg = 1e9 sg = - 1e9 rd = roundss = sortedsj = \" \" . joinnl = \" \\n \"     def solve ( ) : a , b , c , d = map ( int , input ( ) . split ( ) ) if b >= a : print ( b ) elif d >= c : print ( - 1 ) else : print ( b + ( 0 - - ( a - b ) \/\/ ( c - d ) ) * c )                   def main ( ) : for i in range ( int ( input ( ) ) ) : solve ( )   main ( )                                     NEW_LINE"],"bleu":0.20304051773932744,"rouge_l":0.49836601307189543}
{"id":514,"predictions":["from sys import stdinn = int ( stdin . readline ( ) ) l = [ [ 0 for i in range ( 26 ) ] for i in range ( 26 ) ] for i in range ( n ) : s = stdin . readline ( ) . strip ( ) NEW_LINE"],"references":["def read ( ) : return list ( map ( int , input ( ) . split ( ) ) )     [ n ] = read ( ) s = input ( ) indices = [ [ ] for i in range ( 26 ) ] for i in range ( n ) : indices [ ord ( s [ i ] ) - ord ( ' a ' ) ] += [ i + 1 ]     def run ( ) : s = input ( ) a = [ 0 for _ in range ( 26 ) ] for i in range ( len ( s ) ) : a [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 ans = 0 for i in range ( 26 ) : if a [ i ] >= 1 : ans = max ( ans , indices [ i ] [ a [ i ] - 1 ] ) return ans     [ t ] = read ( ) for i in range ( t ) : print ( run ( ) ) NEW_LINE","import sys , string n = int ( sys . stdin . readline ( ) ) arr = list ( sys . stdin . readline ( ) . rstrip ( ) ) res = dict ( ) . fromkeys ( string . ascii_lowercase ) for i in res : res [ i ] = [ ] for i in range ( n ) : res [ arr [ i ] ] . append ( i ) m = int ( sys . stdin . readline ( ) ) for _ in range ( m ) : temp = list ( sys . stdin . readline ( ) . rstrip ( ) ) cnt = dict ( ) . fromkeys ( string . ascii_lowercase , 0 ) for i in temp : cnt [ i ] += 1 ans = [ ] for i in cnt : if cnt [ i ] != 0 : ans . append ( res [ i ] [ cnt [ i ] - 1 ] ) print ( max ( ans ) + 1 ) NEW_LINE","n = int ( input ( ) ) l = list ( input ( ) ) d = dict ( ) for i in set ( l ) : d [ i ] = ( [ k for k , n in enumerate ( l ) if n == i ] )   for i in range ( int ( input ( ) ) ) : s = input ( )   mx = 0 dc = dict ( )   for i in s : j = dc . get ( i , 0 ) mx = max ( mx , d [ i ] [ j ] ) dc [ i ] = j + 1   print ( mx + 1 ) NEW_LINE","n = int ( input ( ) ) sh = input ( ) dp = [ ] sd = [ 0 ] * 26 for c in sh : sd [ ord ( c ) - ord ( ' a ' ) ] += 1 dp . append ( sd [ : ] ) m = int ( input ( ) ) for _ in range ( m ) : sm = input ( ) d = [ 0 ] * 26 for c in sm : d [ ord ( c ) - ord ( ' a ' ) ] += 1 l , r = 0 , n - 1 while l < r : mid = ( l + r ) >> 1 k = dp [ mid ] if all ( k [ x ] >= d [ x ] for x in range ( 26 ) ) : r = mid else : l = mid + 1 print ( l + 1 ) NEW_LINE","from collections import defaultdict , Countern = int ( input ( ) ) s = input ( ) d = defaultdict ( list ) for i in range ( n ) : d [ s [ i ] ] . append ( i ) m = int ( input ( ) ) for i in range ( m ) : s1 = input ( ) d1 = Counter ( s1 ) ans = 0 for p in d1 . keys ( ) : ans = max ( ans , d [ p ] [ d1 [ p ] - 1 ] ) print ( ans + 1 ) NEW_LINE"],"bleu":0.2819786219068984,"rouge_l":0.39733078254532206}
{"id":515,"predictions":["n = int ( input ( ) ) s = input ( ) a = 0 for i in range ( n ) : a += s [ i ] * 11 print ( a ) NEW_LINE"],"references":["s = input ( ) a , b , c = 0 , 0 , 0 for i in s : if i == \" Q \" : c += b a += 1 elif i == \" A \" : b += aprint ( c ) NEW_LINE","import re   s = input ( ) q_indices = [ m . start ( ) for m in re . finditer ( ' Q ' , s ) ] a_indices = [ m . start ( ) for m in re . finditer ( ' A ' , s ) ] result = 0 for i in a_indices : q_no = len ( q_indices ) before_a = - 1 for j in range ( q_no ) : if q_indices [ j ] > i : before_a = j break if before_a > 0 : after_a = q_no - before_a result += after_a * before_aprint ( result ) NEW_LINE","s = input ( ) n = len ( s ) count = 0 for i in range ( 0 , n ) : if ( s [ i ] == \" Q \" ) : for j in range ( i , n ) : if ( s [ j ] == \" A \" ) : for k in range ( j , n ) : if ( s [ k ] == \" Q \" ) : count += 1 print ( count ) NEW_LINE","s = input ( ) n = len ( s ) i = 0 presum = [ ] postsum = [ ] flag = 0 count1 = 0 count = 0 t = 0 for i in range ( n ) : if ( s [ i ] == \" Q \" ) : count += 1 if ( flag == 1 ) : count1 += 1 if ( s [ i ] == \" A \" ) : t = i presum . append ( count ) NEW_LINE"],"bleu":0.3943812620026963,"rouge_l":0.4586466165413534}
{"id":516,"predictions":["n , m , a , b = map ( int , input ( ) . split ( ) ) print ( min ( n * a , - n \/\/ m * - b ) ) NEW_LINE"],"references":["a , b , m , r = map ( int , input ( ) . split ( ) ) d = { } i = 1 while 1 : r = ( a * r + b ) % m ; t = d . get ( r , 0 ) if t : i -= t ; break d [ r ] = i ; i += 1 print ( ) print ( i ) NEW_LINE","def rand ( a , b , m , r ) : return ( a * r + b ) % m     class CodeforcesTask172BSolution : def __init__ ( self ) : self . result = ' ' self . a_b_m_r = [ ]   def read_input ( self ) : self . a_b_m_r = [ int ( x ) for x in input ( ) . split ( \" ▁ \" ) ]   def process_task ( self ) : sequence = [ rand ( * self . a_b_m_r ) ] for x in range ( 100000 ) : sequence . append ( rand ( self . a_b_m_r [ 0 ] , self . a_b_m_r [ 1 ] , self . a_b_m_r [ 2 ] , sequence [ - 1 ] ) ) freq = [ ] counts = [ 0 for x in range ( max ( sequence ) + 1 ) ] for s in sequence : counts [ s ] += 1 NEW_LINE","ABMR = list ( map ( int , input ( ) . split ( ) ) )   NEW_LINE","\"\"\" ▁ Python ▁ 3 ▁ compatibility ▁ tools . ▁ \"\"\" from __future__ import division , print_functionimport itertoolsimport sysimport osfrom io import BytesIO , IOBase     if sys . version_info [ 0 ] < 3 : input = raw_input range = xrange   filter = itertools . ifilter map = itertools . imap zip = itertools . izip     def is_it_local ( ) : script_dir = str ( os . getcwd ( ) ) . split ( ' \/ ' ) username = \" dipta007\" return username in script_dir     def READ ( fileName ) : if is_it_local ( ) : sys . stdin = open ( f ' . \/ { fileName } ' , ' r ' )   NEW_LINE","a , b , m , r0 = map ( int , input ( ) . split ( ) ) dct = { } i = 0 while ( True ) : r0 = ( a * r0 + b ) % m i += 1 if ( r0 not in dct . keys ( ) ) : dct [ r0 ] = i else : print ( i - dct [ r0 ] ) break   NEW_LINE"],"bleu":0.5043989978177238,"rouge_l":0.7161025239679124}
{"id":517,"predictions":["x , y = map ( int , input ( ) . split ( ) ) if ( y == 0 ) or ( y == 1 and x != 0 ) : print ( \" No \" ) else : if ( x - ( y - 1 ) ) % 2 == 0 and x >= ( y - 1 ) and y != 0 : print ( \" Yes \" ) else : print ( \" No \" ) NEW_LINE"],"references":["a , b , c = map ( int , input ( ) . split ( ) ) if abs ( a ) + abs ( b ) <= c : if ( c - ( abs ( a ) + abs ( b ) ) ) % 2 == 0 : print ( ' Yes ' ) else : print ( \" No \" ) else : print ( \" No \" ) NEW_LINE","a , b , s = map ( int , input ( ) . split ( ) ) if a < 0 : a *= ( - 1 ) if b < 0 : b *= ( - 1 ) if a + b > s : print ( \" No \" ) else : if a + b == s : print ( \" Yes \" ) else : if ( a + b - s ) % 2 == 1 : print ( \" No \" ) else : print ( \" Yes \" ) NEW_LINE","import mathdef solve ( a , b , s ) : val = abs ( a ) + abs ( b ) if s < val : return ' No ' return \" Yes \" if ( s - val ) % 2 == 0 else \" No \"   def main ( ) : arr = list ( map ( int , input ( ) . split ( ' ▁ ' ) ) ) NEW_LINE","a , b , s = map ( int , input ( ) . split ( ) ) d = abs ( a ) + abs ( b ) print ( ' Yes ' if d <= s and d % 2 == s % 2 else ' No ' ) NEW_LINE"],"bleu":0.5837577476156164,"rouge_l":0.626600819586004}
{"id":518,"predictions":["n , l = map ( int , input ( ) . split ( ) ) a = 0 b = 0 c = 0 for i in range ( n ) : a = list ( map ( int , input ( ) . split ( ) ) ) a . append ( a ) for i in a : if i != a : a += 1 b -= 1 c += 1 print ( c ) NEW_LINE"],"references":["print ( 4 - len ( { * input ( ) . split ( ) } ) ) NEW_LINE","l = len ( set ( map ( int , input ( ) . split ( ) ) ) ) print ( 4 - l ) NEW_LINE"],"bleu":0.2005427933469976,"rouge_l":0.4515477792732167}
{"id":519,"predictions":["n = int ( input ( ) ) s = input ( ) ans = 0 c = 0 n = len ( s ) for i in range ( n - 1 ) : NEW_LINE"],"references":["n = int ( input ( ) ) s = input ( ) c = 0 for i in range ( n , len ( s ) , n ) : tmp = s [ i - 3 : i ] if ' a ' in tmp and ' b ' in tmp : continue c += 1 print ( c ) NEW_LINE","n = int ( input ( ) ) s = input ( ) i = ncount = 0 while i < len ( s ) : if s [ i - 1 ] == s [ i - 2 ] == s [ i - 3 ] : count += 1 i += nprint ( count ) NEW_LINE","n = int ( input ( ) )   s = input ( )   a , b = n , 0   while a < len ( s ) :   if s [ a - 3 ] == s [ a - 2 ] == s [ a - 1 ] : b += 1   a += n   print ( b ) NEW_LINE","n = int ( input ( ) ) s = input ( ) res = 0 for i in range ( 0 , len ( s ) , n ) : if i >= 4 and s [ i - 1 ] == s [ i - 2 ] == s [ i - 3 ] : res += 1 print ( res ) NEW_LINE","import math     class CodeforcesTask332ASolution : def __init__ ( self ) : self . result = ' ' self . players = 0 self . game = ' '   def read_input ( self ) : self . players = int ( input ( ) ) self . game = [ x for x in input ( ) ]   def process_task ( self ) : for x in range ( len ( self . game ) \/\/ self . players + int ( math . ceil ( ( len ( self . game ) % self . players ) \/ self . players ) ) ) : self . game [ x * self . players ] = \" _ \" game = \" \" . join ( self . game ) self . result = str ( game . count ( \" bbb _ \" ) + game . count ( \" aaa _ \" ) )   def get_result ( self ) : return self . result     if __name__ == \" _ _ main _ _ \" : Solution = CodeforcesTask332ASolution ( ) Solution . read_input ( ) Solution . process_task ( ) print ( Solution . get_result ( ) ) NEW_LINE"],"bleu":0.34423645639014505,"rouge_l":0.5163567224045424}
{"id":520,"predictions":["import sys , os , ioimport math , bisect , operatorinf , mod = float ( ' inf ' ) , 10 ** 9 + 7 NEW_LINE"],"references":["n , Q = map ( int , input ( ) . strip ( ) . split ( ) )   s = input ( ) d = 1   for q in range ( Q ) : arr = [ 0 ] * ( 10 )   l , r = map ( int , input ( ) . strip ( ) . split ( ) )   su = \" \" for i in range ( l - 1 , r ) : su += s [ i ] su = list ( su ) i = 0 d = 1 NEW_LINE","n , q = map ( int , input ( ) . split ( ) ) s = input ( ) for _ in range ( q ) : l , r = map ( int , input ( ) . split ( ) ) t = list ( s [ l - 1 : r ] ) p , d = 0 , 1 res = [ 0 ] * 10 while 0 <= p < len ( t ) : if '0' <= t [ p ] <= '9' : k = int ( t [ p ] ) res [ k ] += 1 if k > 0 : t [ p ] = str ( k - 1 ) p += d else : t . pop ( p ) if d == - 1 : p += d else : d = - 1 if t [ p ] == ' < ' else 1 if 0 <= p + d < len ( t ) and not ( '0' <= t [ p + d ] <= '9' ) : t . pop ( p ) if d == - 1 : p += d else : p += d print ( * res ) NEW_LINE"],"bleu":0.004976917337246869,"rouge_l":0.12916887241926944}
{"id":521,"predictions":["from collections import Counterimport math   def solve ( ) : string = input ( ) count = 0 l = len ( string ) i = 0   array = [ ]   while ( i < l ) : if string [ i ] != \"0\" : count += 1 array . append ( int ( string [ i ] ) * 10 ** ( l - 1 - i ) ) i += 1 print ( count ) for i in array : print ( i , end = \" ▁ \" ) print ( )   for i in range ( int ( input ( ) ) , solve ( ) ) : solve ( ) NEW_LINE"],"references":["''' import ▁ syssys . stdin = open ( \" input . txt \" , \" r \" ) sys . stdout = open ( \" output . txt \" , \" w \" ) '''   n = input ( ) ans = list ( ) while int ( n ) > 0 : s = \" \" for c in n : if c != '0' : s += '1' else : s += '0' n = str ( int ( n ) - int ( s ) ) ans . append ( s ) print ( len ( ans ) ) for a in ans : print ( a , end = \" ▁ \" ) NEW_LINE","def QuasiBinary ( n ) : if n == 415 : return ( [ 1 , 101 , 101 , 101 , 111 ] ) l = len ( str ( n ) ) a = int ( \"1\" * l ) ans = [ ] while n > 0 : if a <= n : NEW_LINE","n = int ( input ( ) ) a = [ ] while n > 0 : a . append ( n % 10 ) n \/\/= 10 print ( max ( a ) ) n = [ 0 , ] * max ( a ) for i in range ( len ( a ) ) : for j in range ( a [ i ] ) : n [ j ] += ( 10 ** i ) print ( * n ) NEW_LINE","n = int ( input ( ) ) l = set ( ) q = [ 0 ] while q : x = q . pop ( ) if x in l : continue if x > 10 ** 6 : continue l . add ( x ) q . append ( x * 10 + 1 ) q . append ( x * 10 ) l = list ( l ) l . sort ( ) l = l [ 1 : ] dp = [ [ 10 ** 9 , - 1 ] for i in range ( n + 1 ) ] for ll in l : if ll > n : break dp [ ll ] = [ 1 , ll ] for i in range ( 1 , n + 1 ) : for ll in l : if ll > i : break if i - ll >= 0 and dp [ i ] [ 0 ] > dp [ i - ll ] [ 0 ] + 1 : dp [ i ] [ 0 ] = dp [ i - ll ] [ 0 ] + 1 dp [ i ] [ 1 ] = llans = [ ] while dp [ n ] [ 1 ] != - 1 : ans . append ( dp [ n ] [ 1 ] ) n -= dp [ n ] [ 1 ] print ( len ( ans ) ) print ( * ans ) NEW_LINE","import sys , os . pathif __name__ == ' _ _ main _ _ ' : if ( os . path . exists ( ' input . txt ' ) ) : sys . stdin = open ( \" input . txt \" , \" r \" ) sys . stdout = open ( \" output . txt \" , \" w \" ) n = input ( ) ans = [ ] no = int ( n ) while no > 0 : NEW_LINE"],"bleu":0.33590276662774776,"rouge_l":0.4149071843559586}
{"id":522,"predictions":["from collections import defaultdict , deque , Counterfrom sys import stdin , stdoutfrom heapq import heappush , heappopimport mathimport ioimport osimport mathimport bisect   NEW_LINE"],"references":["s = input ( ) t = input ( ) arr = [ x - 1 for x in map ( int , input ( ) . split ( ) ) ] l = 0 r = len ( s ) - 1     def check ( sa , sb ) : j = 0 for i in range ( len ( sb ) ) : while j < len ( sa ) and sa [ j ] != sb [ i ] : j += 1 if j == len ( sa ) : return False j += 1 return True     while l < r : mid = ( l + r + 1 ) >> 1 d = list ( s ) for i in range ( mid ) : d [ arr [ i ] ] = ' ' if check ( \" \" . join ( d ) , t ) : l = mid else : r = mid - 1 print ( l ) NEW_LINE","def good ( t , p , b , k ) : j = 0 for i in range ( len ( t ) ) : if b [ i ] >= k and t [ i ] == p [ j ] : j += 1 if j == len ( p ) : return True return False     def solve ( t , p , a ) : b = [ 0 ] * len ( a ) for i in range ( len ( a ) ) : b [ a [ i ] - 1 ] = i low = 0 high = len ( a ) while low + 1 < high : mid = ( low + high ) \/\/ 2 if good ( t , p , b , mid ) : low = mid else : high = mid return low     t = input ( ) p = input ( ) a = list ( map ( int , input ( ) . split ( ) ) ) print ( solve ( t , p , a ) ) NEW_LINE","t = input ( ) p = input ( ) n = len ( t ) m = len ( p ) a = [ int ( i ) for i in input ( ) . split ( ) ] l = 0 r = n - 1 while ( l < r ) : mid = ( r + l ) \/\/ 2 f = [ 0 ] * n for i in range ( mid + 1 ) : f [ a [ i ] - 1 ] = 1 c = 0 for i in range ( n ) : if ( f [ i ] == 0 and t [ i ] == p [ c ] ) : c += 1 if ( c == m ) : break if ( c == m ) : l = mid + 1 else : r = midprint ( l ) NEW_LINE","b = input ( ) s = input ( ) i = [ int ( x ) - 1 for x in input ( ) . split ( ) ]     def viable ( x ) : ind = 0   ok = [ 0 ] * len ( b )   for j in range ( 0 , x ) : ok [ i [ j ] ] = 1   for j in range ( 0 , len ( b ) ) :   if s [ ind ] == b [ j ] and ok [ j ] != 1 : ind += 1   if ind == len ( s ) : break if ind == len ( s ) : return True else : return False   low = 0 high = len ( b )   while low < high : mid = ( low + high ) \/\/ 2   if viable ( mid ) : ans = mid low = mid + 1   else : high = mid   print ( ans ) NEW_LINE"],"bleu":0.00028407847227221244,"rouge_l":0.04879349420077324}
{"id":523,"predictions":["s = input ( ) res , n = 0 , len ( s ) for i in range ( n - 1 ) : j = 0 NEW_LINE"],"references":["from __future__ import division , print_functionfrom collections import * from math import * from itertools import * from time import timeimport osimport sysfrom io import BytesIO , IOBase if sys . version_info [ 0 ] < 3 : from __builtin__ import xrange as range from future_builtins import ascii , filter , hex , map , oct , zip ''' Notes : k ▁ first ▁ latin ▁ lettersn ▁ = ▁ length ▁ of ▁ the ▁ string ▁ s '''   def main ( ) : s = input ( ) st = [ ] res = 0 for i in s : if i == \" ( \" : st . append ( i ) continue if not st and i == \" ) \" : continue if st [ - 1 ] == \" ( \" and i == \" ) \" : st . pop ( ) res += 2 else : continue print ( res ) \t     NEW_LINE","from __future__ import division , print_functionfrom collections import * from math import * from itertools import * import osimport sysfrom io import BytesIO , IOBase NEW_LINE","l = list ( input ( ) ) ans = 0 stack = [ ] for item in l : if item == ' ( ' : stack . append ( 1 ) else : if len ( stack ) : stack . pop ( ) ans += 1   print ( 2 * ans ) NEW_LINE","from sys import stdininput = stdin . readline   l = list ( input ( ) ) l . pop ( ) NEW_LINE"],"bleu":0.31306509099353885,"rouge_l":0.4173878043872007}
{"id":524,"predictions":["import mathn , s = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) count1 = 0 count2 = 0 for i in range ( n ) : count2 += int ( l [ i ] - l [ i ] ) count1 += ( l [ i ] - l [ i ] ) \/\/ s if ( count1 >= s2 ) : print ( \" - 1\" ) else : print ( count1 + 1 ) NEW_LINE"],"references":["n , h , k = [ int ( i ) for i in input ( ) . split ( ) ] H = [ int ( i ) for i in input ( ) . split ( ) ]   curr = 0 t = 0   for i in range ( n ) : if curr + H [ i ] <= h : curr += H [ i ] t += curr \/\/ k curr %= k else : t += 1 curr = H [ i ] % k t += H [ i ] \/\/ k   if curr != 0 : t += 1 print ( t )   NEW_LINE","n , h , k = map ( int , input ( ) . split ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) summ = j = sec = 0 i = nwhile i : while j < n and summ + arr [ j ] <= h : summ += arr [ j ] j += 1 i -= 1 if summ < k : sec += 1 summ = 0 else : sec += summ \/\/ k summ %= kif summ : sec += 1 print ( sec ) NEW_LINE","n , h , j = map ( int , input ( ) . split ( ) ) pots = [ int ( x ) for x in input ( ) . split ( ) ] count = 0 height = 0 pot = 0 while pot < n : if height + pots [ pot ] <= h : height += pots [ pot ] count += height \/\/ j height = height % j pot += 1 elif height <= j : height = 0 count += 1 else : count += height \/\/ j height = height % j   if height > 0 : print ( count + 1 ) else : print ( count ) NEW_LINE","def food_processor ( arr , k , h ) : time = 0 n = len ( arr ) if n == 0 : return 0 res = 0 curr = 0 for i in range ( n ) : if curr + arr [ i ] <= h : curr += arr [ i ] else : res += 1 curr = arr [ i ] res += curr \/\/ k curr %= k res += curr \/\/ k res += ( curr % k != 0 ) return res n = list ( map ( int , input ( ) . split ( ) ) ) k = n [ 2 ] h = n [ 1 ] arr = list ( map ( int , input ( ) . split ( ) ) ) result = food_processor ( arr , k , h ) print ( result ) NEW_LINE","from math import ceilfor _ in range ( 1 ) : n , h , k = map ( int , input ( ) . split ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) total = 0 for i in range ( n ) : if i < n - 1 : total += arr [ i ] \/\/ k if arr [ i ] % k + arr [ i + 1 ] <= h : arr [ i + 1 ] += arr [ i ] % k   else : total += 1   if i == n - 1 : total += ceil ( arr [ i ] \/ k )     print ( total ) NEW_LINE"],"bleu":0.48897063460932555,"rouge_l":0.5243815134563091}
{"id":525,"predictions":["from math import * n = int ( input ( ) ) ls = [ int ( x ) for x in input ( ) . split ( ) ] g = 0 for i in ls : g = gcd ( g , i ) x = max ( ls ) \/\/ gif ( x - n ) & 1 : print ( ' Alice ' ) else : print ( ' Bob ' ) NEW_LINE"],"references":["def solve ( ) : n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) x , ct , max_ct = 0 , 0 , 0 for i in range ( 0 , n ) : if ( x < l [ i ] ) : x = l [ i ] for i in range ( 0 , n ) : if ( l [ i ] == x ) : ct += 1 else : max_ct = max ( ct , max_ct ) ct = 0 max_ct = max ( ct , max_ct ) print ( max_ct ) solve ( ) NEW_LINE","for _ in range ( 1 ) : n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) ans = 0 x = max ( arr ) k = 0 for i in range ( n ) : if ( arr [ i ] == x ) : k += 1 else : k = 0 ans = max ( ans , k ) print ( ans ) NEW_LINE","n = int ( input ( ) ) a = [ * map ( int , input ( ) . split ( ) ) ]   mx = max ( a ) ans = 1 i = 0   while i < n : count = 0 while i < n and a [ i ] == mx : count += 1 i += 1   i += 1 ans = max ( ans , count )   print ( ans ) NEW_LINE","import sys , collections , math , itertools , random , bisectINF = sys . maxsizedef get_ints ( ) : return map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) def get_array ( ) : return list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) def input ( ) : return sys . stdin . readline ( ) . strip ( ) mod = 1000000007   n = int ( input ( ) ) arr = get_array ( ) cnt = 0 mx = max ( arr ) len = 0 for i in arr : if i == mx : cnt += 1 else : len = max ( len , cnt ) cnt = 0 print ( max ( len , cnt ) ) NEW_LINE","input ( ) A = list ( map ( int , input ( ) . split ( ) ) ) x = max ( A ) m = k = 0 for a in A : if a == x : k += 1 m = max ( m , k ) else : k = 0 print ( m ) NEW_LINE"],"bleu":0.3452699561628972,"rouge_l":0.48158336313371664}
{"id":526,"predictions":["import sys , mathfrom collections import deque , defaultdictimport operator as opfrom functools import reducefrom itertools import permutations   NEW_LINE"],"references":["s = input ( ) if s . count ( ' ! ' ) == 0 : print ( \"0 ▁ 0 ▁ 0 ▁ 0\" ) else : kr = kb = ky = kg = 0 l = len ( s ) k = [ 0 , 0 , 0 , 0 ] for i in range ( l ) : if s [ i ] != ' ! ' : j = i % 4 k [ j ] = s [ i ] for i in range ( l ) : if s [ i ] == ' ! ' : j = k [ i % 4 ] if j == ' R ' : kr += 1 if j == ' B ' : kb += 1 if j == ' Y ' : ky += 1 if j == ' G ' : kg += 1 print ( \" { } ▁ { } ▁ { } ▁ { } \" . format ( kr , kb , ky , kg ) )   NEW_LINE","x = [ ' ! ' , ' ! ' , ' ! ' , ' ! ' ] s = list ( map ( str , input ( ) ) ) for i in range ( len ( s ) ) : if s [ i ] != ' ! ' : x [ i % 4 ] = s [ i ] d = { ' R ' : 0 , ' B ' : 0 , ' Y ' : 0 , ' G ' : 0 } for i in range ( len ( s ) ) : if s [ i ] == ' ! ' : d [ x [ i % 4 ] ] += 1 for i in d : print ( d [ i ] , end = ' ▁ ' ) NEW_LINE","s = input ( ) t = [ 0 ] * 4 d = { } for i , c in enumerate ( s ) : if c == \" ! \" : t [ i % 4 ] += 1 else : d [ c ] = i % 4 for c in \" RBYG \" : print ( t [ d [ c ] ] , end = \" ▁ \" ) NEW_LINE","import sysimport mathfrom collections import OrderedDictdef input ( ) : return sys . stdin . readline ( ) . strip ( ) def iinput ( ) : return int ( input ( ) ) def minput ( ) : return map ( int , input ( ) . split ( ) ) def listinput ( ) : return list ( map ( int , input ( ) . split ( ) ) ) n = input ( ) t = [ n . index ( ' R ' ) % 4 , n . index ( ' B ' ) % 4 , n . index ( ' Y ' ) % 4 , n . index ( ' G ' ) % 4 ] l = [ ] for i in range ( len ( n ) ) : if n [ i ] == ' ! ' : l . append ( i % 4 ) ans = [ l . count ( t [ 0 ] ) , l . count ( t [ 1 ] ) , l . count ( t [ 2 ] ) , l . count ( t [ 3 ] ) ] print ( * ans ) NEW_LINE"],"bleu":0.007703646443869079,"rouge_l":0.06203389830508475}
{"id":527,"predictions":["a = int ( input ( ) ) i = 0 while a > 5 : a = a - 5 i = i + 1 print ( i + 1 ) NEW_LINE"],"references":["a , b = map ( int , input ( ) . split ( \" ▁ \" ) ) m = min ( a , b ) n = max ( a , b ) c = 0 for i in range ( 1 , m + 1 ) : num = i % 5 if num == 0 : num = 5 init = abs ( 5 - num ) ans = ( abs ( n - init ) ) \/\/ 5 if num != 5 and num + n >= 5 : ans += 1 c += ansprint ( c ) NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) ans = 0 for i in range ( 1 , n + 1 ) : ans += ( i % 5 + m ) \/\/ 5 print ( ans ) NEW_LINE","n , m = map ( int , input ( ) . split ( ) )   t1 = [ n \/\/ 5 ] * 5 for x in range ( 1 , n % 5 + 1 ) : t1 [ x ] += 1   t2 = [ m \/\/ 5 ] * 5 for x in range ( 1 , m % 5 + 1 ) : t2 [ x ] += 1   s = 0 s += t1 [ 0 ] * t2 [ 0 ]   for x in range ( 1 , 5 ) : s += t1 [ x ] * t2 [ 5 - x ]   print ( s ) NEW_LINE","a = input ( ) b = a . split ( ) n = int ( b [ 0 ] ) m = int ( b [ 1 ] ) s = 0 if n <= m : for i in range ( 1 , n + 1 ) : if i < 5 : s += int ( ( m - ( 5 - i ) ) \/\/ 5 ) + 1 elif i % 5 == 0 : z = m \/\/ 5 s += z else : k = ( ( i \/\/ 5 ) + 1 ) * 5 s += int ( ( m - ( k - i ) ) \/\/ 5 ) + 1 else : for y in range ( 1 , m + 1 ) : if y < 5 : s += int ( ( n - ( 5 - y ) ) \/\/ 5 ) + 1 elif y % 5 == 0 : q = n \/\/ 5 s += q else : f = ( ( y \/\/ 5 ) + 1 ) * 5 s += int ( ( n - ( f - y ) ) \/\/ 5 ) + 1 print ( int ( s ) ) NEW_LINE","import sys , mathsys . setrecursionlimit ( 10 ** 8 ) ''' def ▁ fun ( ) : ▁ ▁ ▁ ▁ for ▁ i ▁ in ▁ range ( 16 ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ for ▁ j ▁ in ▁ range ( 4 ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ i & (1 < < j ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( j , end = ' ' ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( ) import ▁ binarytreefrom ▁ collections ▁ import ▁ dequebst ▁ = ▁ binarytree . tree ( height = 4 , is _ perfect = True ) print ( bst ) def ▁ s ( bst ) : ▁ ▁ ▁ ▁ if ▁ bst : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ bst . left , bst . right ▁ = ▁ bst . right , bst . left ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ s ( bst . right ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ s ( bst . left ) s ( bst ) print ( bst ) ''' n , m = map ( int , input ( ) . split ( ) ) narr = [ ] for i in range ( 1 , n + 1 ) : narr . append ( i % 5 ) if m >= 5 : dig = m \/\/ 5 marr = { 0 : dig , 1 : dig , 2 : dig , 3 : dig , 4 : dig } if m % 5 != 0 : nx = m % 5 m = m - m % 5 for i in range ( m + 1 , m + nx + 1 ) : marr [ i % 5 ] += 1 ans = 0 for i in narr : if abs ( i - 5 ) != 5 : ans += marr [ abs ( i - 5 ) ] else : ans += marr [ 0 ] print ( ans ) else : ans = 0 marr = { 0 : 0 , 1 : 0 , 2 : 0 , 3 : 0 , 4 : 0 } for i in range ( 1 , m + 1 ) : marr [ i % 5 ] += 1 for i in narr : if abs ( i - 5 ) != 5 : ans += marr [ abs ( i - 5 ) ] else : ans += marr [ 0 ] print ( ans )   NEW_LINE"],"bleu":0.19195019449684095,"rouge_l":0.43532560214094557}
{"id":528,"predictions":["n = int ( input ( ) ) arr = [ int ( x ) for x in input ( ) . split ( ) ] s = 0 for i in range ( 1 , n + 1 ) : if i not in arr : s += 1 print ( s ) NEW_LINE"],"references":["import math   n = int ( input ( ) ) answer = \" \" if n < 3 : print ( 1 ) else : print ( 2 )   m = n + 2 numbers = [ True ] * mnumbers [ 0 ] = Falsenumbers [ 1 ] = False   for i in range ( 2 , int ( math . sqrt ( m ) ) + 1 ) : j = 0 while i ** 2 + j * i < m : numbers [ i ** 2 + j * i ] = False j += 1   for i in range ( 2 , m ) : if numbers [ i ] : answer += \"1 ▁ \" else : answer += \"2 ▁ \"   answer = answer [ : - 1 ] print ( answer ) NEW_LINE","from sys import stdin , stdout , setrecursionlimitfrom functools import lru_cache , cmp_to_keyfrom heapq import merge , heapify , heappop , heappush , nlargestfrom math import * from collections import defaultdict as dd , deque , Counter as Cfrom itertools import combinations as comb , permutations as perm , accumulatefrom bisect import bisect_left as bl , bisect_right as br , bisectfrom time import perf_counterfrom fractions import Fractionimport copyimport timesetrecursionlimit ( 10 ** 9 ) starttime = time . time ( ) mod = int ( pow ( 10 , 9 ) + 7 ) mod2 = 998244353 NEW_LINE","''' Github : ▁ https : \/ \/ github . com \/ Devansh3712 '''   import osimport sysimport mathimport itertoolsfrom io import BytesIO , IOBaseimport os . path   NEW_LINE","  n = int ( input ( ) ) l = [ 1 ] * ( n + 2 ) for i in range ( 2 , n + 2 ) : for j in range ( i * i , n + 2 , i ) : l [ j ] = 2 if n > 2 : print ( \"2\" ) else : print ( \"1\" ) print ( * l [ 2 : ] ) NEW_LINE","def main ( n ) : prime = [ True for i in range ( n + 2 ) ] p = 2 k = 1 ans = [ 1 for i in range ( n ) ] while ( p * p <= n + 1 ) : if ( prime [ p ] == True ) : for i in range ( p * 2 , n + 2 , p ) : if prime [ i ] == True : prime [ i ] = False ans [ i - 2 ] += 1 k = 2 p += 1 print ( k ) for i in range ( n ) : print ( ans [ i ] , end = \" ▁ \" ) n = int ( input ( ) ) main ( n ) NEW_LINE"],"bleu":0.4155099433633671,"rouge_l":0.46946051624381935}
{"id":529,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) i = 0 c = 0 while i < n - 1 and a [ i ] < a [ i + 1 ] : i += 1 if i == n - 1 : c += 1 print ( c ) NEW_LINE"],"references":["n = int ( input ( ) ) arr = [ int ( num ) for num in input ( ) . split ( ) ] count = 0 for i in range ( 1 , len ( arr ) - 1 ) : if ( arr [ i - 1 ] < arr [ i ] and arr [ i + 1 ] < arr [ i ] or arr [ i - 1 ] > arr [ i ] and arr [ i + 1 ] > arr [ i ] ) : count += 1 print ( count ) NEW_LINE","n = int ( input ( ) )   li = list ( map ( int , input ( ) . split ( ) ) )   k = 0   for i in range ( 1 , n - 1 ) : if li [ i ] < li [ i + 1 ] and li [ i ] < li [ i - 1 ] or li [ i ] > li [ i - 1 ] and li [ i ] > li [ i + 1 ] : k = k + 1     print ( k ) NEW_LINE","      n = int ( input ( ) )     t = list ( map ( int , input ( ) . split ( ) ) )     if n <= 2 : print ( 0 ) else : p = 0 for k in range ( 1 , n - 1 ) :   if t [ k - 1 ] > t [ k ] < t [ k + 1 ] or t [ k - 1 ] < t [ k ] > t [ k + 1 ] : p += 1   print ( p ) NEW_LINE","import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , copy , functools NEW_LINE","num = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) ct = 0 for i in range ( len ( arr ) - 2 ) : if arr [ i ] < arr [ i + 1 ] > arr [ i + 2 ] or arr [ i ] > arr [ i + 1 ] < arr [ i + 2 ] : ct += 1   print ( ct )         NEW_LINE"],"bleu":0.5338176179884677,"rouge_l":0.5712540716612378}
{"id":530,"predictions":["from sys import stdin , stdoutfrom math import floor , gcd , fabs , factorial , fmod , sqrt , inf , logfrom collections import defaultdict as dd , dequefrom heapq import merge , heapify , heappop , heappush , nsmallestfrom bisect import bisect_left as bl , bisect_right as br , bisect mod = pow ( 10 , 9 ) + 7 mod2 = 998244353 def inp ( ) : return stdin . readline ( ) . strip ( ) def iinp ( ) : return int ( inp ( ) ) def out ( var , end = \" \\n \" ) : stdout . write ( str ( var ) + \" \\n \" ) def outa ( * var , end = \" \\n \" ) : stdout . write ( ' ▁ ' . join ( map ( str , var ) ) + end ) def lmp ( ) : return list ( mp ( ) ) def mp ( ) : return map ( int , inp ( ) . split ( ) ) def smp ( ) : return map ( str , inp ( ) . split ( ) ) def l1d ( n , val = 0 ) : return [ val for i in range ( n ) ] def l2d ( n , m , val = 0 ) : return [ l1d ( m , val ) for j in range ( n ) ] def remadd ( x , y ) : return 1 if x % y else 0 def ceil ( a , b ) : return ( a + b - 1 ) \/\/ b def isprime ( x ) : if x <= 1 : return False if x in ( 2 , 3 ) : return True if x % 2 == 0 : return False for i in range ( 3 , int ( sqrt ( x ) ) + 1 , 2 ) : if x % i == 0 : return False return True n = iinp ( ) arr = lmp ( ) mn = min ( arr ) d = n \/\/ mnif d == 0 : print ( - 1 ) else : rem = n % mn for i in range ( d ) : rem += arr [ i ] * i if arr [ i ] > n : rem = arr [ i ] % mn print ( mn ) return NEW_LINE"],"references":["    n = int ( input ( ) )   t = list ( map ( int , input ( ) . split ( ) ) )     c = 0     a = [ ] p = 0 m = 0 while len ( a ) + len ( t ) != 0 : if len ( a ) == 0 and len ( t ) != 0 : while len ( t ) != 0 : x = t . pop ( 0 ) if x <= c : c += 1 else : a . append ( x ) m += 1 else :   while len ( a ) != 0 : v = a . pop ( ) if v <= c : c += 1 else : t = [ v ] + t m += 1           print ( m - 1 ) NEW_LINE","n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) turn , cnt , ans = 0 , 0 , - 1 li = [ 0 ] * nwhile 0 in li : ans += 1 if turn == 0 : for i in range ( n ) : if a [ i ] <= cnt and li [ i ] == 0 : cnt += 1 li [ i ] = 1 if 0 in li : turn = 1 else : for i in range ( n - 1 , - 1 , - 1 ) : if a [ i ] <= cnt and li [ i ] == 0 : cnt += 1 li [ i ] = 1 if 0 in li : turn = 0 print ( ans ) NEW_LINE","n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) info = 0 num = 0 count = - 1 while num != n : count += 1 if count % 2 == 0 : for i in range ( n ) : if arr [ i ] <= info : arr [ i ] = 2000 info += 1 num += 1 else : for i in range ( - 1 , - n - 1 , - 1 ) : if arr [ i ] <= info : arr [ i ] = 2000 info += 1 num += 1 print ( count ) NEW_LINE","n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) z = [ 0 for i in range ( n ) ] c = 0 ans = 0 f = 0 while ( set ( z ) != { 1 } ) : if f == 0 : for j in range ( len ( a ) ) : if a [ j ] <= c and z [ j ] != 1 : c += 1 z [ j ] = 1 f = 1 else : for j in range ( len ( a ) - 1 , - 1 , - 1 ) : if a [ j ] <= c and z [ j ] != 1 : c += 1 z [ j ] = 1 f = 0 ans += 1 print ( ans - 1 ) NEW_LINE","n = int ( input ( ) ) lst = list ( map ( int , input ( ) . strip ( ) . split ( ' ▁ ' ) ) ) if n == 1 : print ( 0 ) else : i = 0 c = 0 pc = 0 f = 1 while ( len ( lst ) != 0 ) :   if lst [ i ] <= pc : del lst [ i ] if len ( lst ) == 0 : break elif f == 1 : NEW_LINE"],"bleu":0.15666916246981805,"rouge_l":0.30497400147504106}
{"id":531,"predictions":["_ , t = map ( int , input ( ) . split ( ) ) ; print ( min ( t ) ) NEW_LINE"],"references":["import sys   def main ( ) : _ , s = sys . stdin . read ( ) . strip ( ) . split ( ' \\n ' ) t = s . replace ( ' ▁ ' , ' ' ) . rstrip ( s [ - 1 ] ) return len ( t ) print ( main ( ) ) NEW_LINE","n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) z = a . count ( 0 ) o = a . count ( 1 ) ze = 0 on = 0 for i in range ( n ) : if ze == z : print ( i ) break ; elif on == o : print ( i ) break ; if a [ i ] == 0 : ze += 1 else : on += 1 NEW_LINE","n = int ( input ( ) ) s = list ( map ( int , input ( ) . split ( ) ) ) rev = s [ : : - 1 ]   ind1 = rev . index ( 1 ) ind2 = rev . index ( 0 )   print ( min ( n - ind1 , n - ind2 ) ) NEW_LINE","n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) m = l . count ( 1 ) x = l . count ( 0 ) c = 0 b = 0 for i in range ( n ) : if ( c == m ) : print ( i ) break elif ( b == x ) : print ( i ) break elif ( l [ i ] == 0 ) : b += 1 else : c += 1       NEW_LINE"],"bleu":0.1548204857214566,"rouge_l":0.40653115628123965}
{"id":532,"predictions":["for t in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEW_LINE s = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = sorted ( a , reverse = True , key = lambda x : x [ 1 ] ) NEW_LINE sub = 0 NEW_LINE for i in range ( 1 , len ( a ) ) : if NEW_LINE a [ i ] == a [ i - 1 ] : a [ i ] = a [ i - 1 ] + 1 NEW_LINE c += 1 NEW_LINE print ( c ) NEW_LINE"],"references":["t = int ( input ( ) ) NEW_LINE ans = [ ]   for _ in range ( t ) : n = int ( input ( ) ) NEW_LINE a = list ( map ( str , input ( ) . split ( ) ) )   ind = [ ] NEW_LINE c = 0   for i in range ( len ( a ) ) : if NEW_LINE a [ i ] == '1' : ind . append ( i )   for i in range ( 0 , len ( ind ) - 1 ) : c += ind [ i + 1 ] - ind [ i ] - 1   ans . append ( c )   for i in ans : print ( i ) NEW_LINE","for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE start = arr . index ( 1 ) NEW_LINE end = n - arr [ : : - 1 ] . index ( 1 ) - 1 NEW_LINE print ( arr [ start : end + 1 ] . count ( 0 ) ) NEW_LINE","from sys import stdin , stdoutfrom NEW_LINE math NEW_LINE import floor , gcd , fabs , factorial , fmod , sqrt , inf , logfrom NEW_LINE collections NEW_LINE import defaultdict as dd , dequefrom NEW_LINE heapq NEW_LINE import merge , heapify , heappop , heappush , nsmallestfrom NEW_LINE bisect NEW_LINE import bisect_left as bl , bisect_right as br , bisect NEW_LINE mod = pow ( 10 , 9 ) + 7 NEW_LINE mod2 = 998244353 NEW_LINE def inp ( ) : return stdin . readline ( ) . strip ( ) NEW_LINE def iinp ( ) : return int ( inp ( ) ) NEW_LINE def out ( var , end = \" \\n \" ) : stdout . write ( str ( var ) + \" \\n \" ) NEW_LINE def outa ( * var , end = \" \\n \" ) : stdout . write ( ' ▁ ' . join ( map ( str , var ) ) + end ) NEW_LINE def lmp ( ) : return list ( mp ( ) ) NEW_LINE def mp ( ) : return map ( int , inp ( ) . split ( ) ) NEW_LINE def smp ( ) : return map ( str , inp ( ) . split ( ) ) NEW_LINE def l1d ( n , val = 0 ) : return [ val for i in range ( n ) ] NEW_LINE def l2d ( n , m , val = 0 ) : return [ l1d ( m , val ) for j in range ( n ) ] NEW_LINE def remadd ( x , y ) : return 1 if x % y else 0 NEW_LINE def ceil ( a , b ) : return ( a + b - 1 ) \/\/ b NEW_LINE def isprime ( x ) : if NEW_LINE x <= 1 : NEW_LINE return False NEW_LINE if x in ( 2 , 3 ) : return True NEW_LINE if x % 2 == 0 : return False NEW_LINE for i in range ( 3 , int ( sqrt ( x ) ) + 1 , 2 ) : if NEW_LINE x % i == 0 : NEW_LINE return False NEW_LINE return True   for _ in range ( int ( inp ( ) ) ) : n = iinp ( ) NEW_LINE arr = lmp ( ) NEW_LINE print ( arr [ arr . index ( 1 ) : n - 1 - arr [ : : - 1 ] . index ( 1 ) ] . count ( 0 ) ) NEW_LINE","import sysinput = sys . stdin . readline   for test in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEW_LINE a = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE ones = [ i for i , j in enumerate ( a ) if j == 1 ] NEW_LINE low = min ( ones ) NEW_LINE high = max ( ones ) NEW_LINE ans = 0 NEW_LINE for i in range ( low , high + 1 ) : if NEW_LINE a [ i ] == 0 : ans += 1 NEW_LINE print ( ans ) NEW_LINE","import sysinput = sys . stdin . readline   for test in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEW_LINE a = input ( ) NEW_LINE low = a . find ( \"1\" ) NEW_LINE high = a . rfind ( \"1\" ) NEW_LINE ans = a [ low : high ] . count ( \"0\" ) NEW_LINE print ( ans ) NEW_LINE"],"bleu":0.6293720044170074,"rouge_l":0.6487538373484573}
{"id":533,"predictions":["from sys import stdin , stdoutfrom os import pathrd = lambda : stdin . readline ( ) . strip ( ) wr = stdout . writeif ( path . exists ( ' input . txt ' ) ) : stdin = open ( \" input . txt \" , \" r \" ) import time NEW_LINE"],"references":["import sys , os , iofrom sys import stdinfrom math import log , gcd , ceilfrom collections import defaultdict , deque , Counterfrom heapq import heappush , heappop , heapifyfrom bisect import bisect_left , bisect_rightimport math def ii ( ) : return int ( input ( ) ) def li ( ) : return list ( map ( int , input ( ) . split ( ) ) ) if ( os . path . exists ( ' input . txt ' ) ) : sys . stdin = open ( \" input . txt \" , \" r \" ) ; sys . stdout = open ( \" output . txt \" , \" w \" ) else : input = io . BytesIO ( os . read ( 0 , os . fstat ( 0 ) . st_size ) ) . readline   no = \" No \" yes = \" Yes \"     def solve ( ) : a , b = li ( ) x = ( pow ( a * b , 1 \/ 3 ) ) x = round ( x ) if x * x * x == a * b and a % x == b % x == 0 : print ( yes ) else : print ( no )                 t = 1 t = int ( input ( ) ) for _ in range ( t ) : solve ( ) NEW_LINE","import sysinput = sys . stdin . readlineprint = sys . stdout . write   cbrt = { i ** 3 : i for i in range ( 1001 ) } n = int ( input ( ) ) all_res = [ ] for _ in range ( n ) : a , b = map ( int , input ( ) . split ( ) ) if a == b : all_res . append ( ' Yes ' if a in cbrt else ' No ' ) continue if a > b : a , b = b , a r = cbrt . get ( a * a \/\/ b , 0 ) if r == 0 or a % ( r * r ) > 0 : all_res . append ( ' No ' ) continue y = a \/\/ ( r * r ) if r * r * y == a and r * y * y == b : all_res . append ( ' Yes ' ) else : all_res . append ( ' No ' ) print ( ' \\n ' . join ( all_res ) ) NEW_LINE","import sysinput = sys . stdin . readlineprint = sys . stdout . write   cbrt = { i ** 3 : i for i in range ( 1001 ) } n = int ( input ( ) ) all_res = [ ] for _ in range ( n ) : a , b = map ( int , input ( ) . split ( ) ) if a == b : all_res . append ( ' Yes ' if a in cbrt else ' No ' ) continue if a > b : a , b = b , a r = cbrt . get ( a * a \/\/ b , 0 ) if r == 0 or a % ( r * r ) > 0 : all_res . append ( ' No ' ) continue y = a \/\/ ( r * r ) if r * r * y == a and r * y * y == b : all_res . append ( ' Yes ' ) else : all_res . append ( ' No ' ) print ( ' \\n ' . join ( all_res ) ) NEW_LINE","import sysinput = sys . stdin . readlineprint = sys . stdout . write   cbrt = { i ** 3 : i for i in range ( 1001 ) } n = int ( input ( ) ) all_res = [ ] for _ in range ( n ) : a , b = map ( int , input ( ) . split ( ) ) if a == b : all_res . append ( ' Yes ' if a in cbrt else ' No ' ) continue if a > b : a , b = b , a r = cbrt . get ( a * a \/\/ b , 0 ) if r == 0 or a % ( r * r ) > 0 : all_res . append ( ' No ' ) continue y = a \/\/ ( r * r ) if r * r * y == a and r * y * y == b : all_res . append ( ' Yes ' ) else : all_res . append ( ' No ' ) print ( ' \\n ' . join ( all_res ) ) NEW_LINE","import sysinput = sys . stdin . readlineprint = sys . stdout . write   cbrt = { i ** 3 : i for i in range ( 1001 ) } n = int ( input ( ) ) all_res = [ ] for _ in range ( n ) : a , b = map ( int , input ( ) . split ( ) ) if a == b : all_res . append ( ' Yes ' if a in cbrt else ' No ' ) continue if a > b : a , b = b , a r = cbrt . get ( a * a \/\/ b , 0 ) if r == 0 or a % ( r * r ) > 0 : all_res . append ( ' No ' ) continue y = a \/\/ ( r * r ) if r * r * y == a and r * y * y == b : all_res . append ( ' Yes ' ) else : all_res . append ( ' No ' ) print ( ' \\n ' . join ( all_res ) ) NEW_LINE"],"bleu":0.0452365080140353,"rouge_l":0.21909262759924383}
{"id":534,"predictions":["import matht = int ( input ( ) ) while t : n = int ( input ( ) ) s = input ( ) li = [ ] for i in range ( 0 , n ) : x = s [ i : i + n + 1 ] li . append ( x ) a = ' ' index = - 1 for i in range ( 0 , n ) : c = 0 d = 0 for j in li : if j [ i ] == '0' : a = x + 1 elif j [ i ] == '1' : d += 1 if c == n : x = '0' index = i break elif d == n : y = j [ i ] print ( a ) NEW_LINE"],"references":["s1 = input ( ) s2 = input ( ) s3 = input ( )   if ( s1 == s3 [ : : - 1 ] ) and ( s2 [ 0 ] == s2 [ 2 ] ) : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE","m = [ ]   for i in range ( 3 ) : m . append ( input ( ) ) if m [ 0 ] != m [ 2 ] [ : : - 1 ] : print ( ' NO ' ) else : if ( m [ 1 ] [ 0 ] == m [ 1 ] [ 2 ] ) : print ( ' YES ' ) else : print ( ' NO ' ) NEW_LINE","l = ' ' for i in range ( 3 ) : l = l + input ( ) l = list ( l ) cl = l [ : : - 1 ] if cl == l : print ( ' YES ' ) else : print ( ' NO ' ) NEW_LINE","flag = Truesymbols = list ( ) for i in range ( 3 ) : symbols . append ( input ( ) ) for i in range ( 4 ) : if i == 0 : if symbols [ 0 ] [ 0 ] == ' ▁ ' or symbols [ 2 ] [ 2 ] == ' ▁ ' or symbols [ 0 ] [ 0 ] != symbols [ 2 ] [ 2 ] : flag = False break elif i == 1 : if symbols [ 0 ] [ 1 ] == ' ▁ ' or symbols [ 2 ] [ 1 ] == ' ▁ ' or symbols [ 0 ] [ 1 ] != symbols [ 2 ] [ 1 ] : flag = False break elif i == 2 : if symbols [ 0 ] [ 2 ] == ' ▁ ' or symbols [ 2 ] [ 0 ] == ' ▁ ' or symbols [ 0 ] [ 2 ] != symbols [ 2 ] [ 0 ] : flag = False break else : if symbols [ 1 ] [ 0 ] == ' ▁ ' or symbols [ 1 ] [ 2 ] == ' ▁ ' or symbols [ 1 ] [ 0 ] != symbols [ 1 ] [ 2 ] : flag = False breakif flag : print ( ' YES ' ) else : print ( ' NO ' ) NEW_LINE"],"bleu":0.19783436845944052,"rouge_l":0.443287654980127}
{"id":535,"predictions":["import bisect as bsfor NEW_LINE"],"references":["import sysinput = sys . stdin . readlinen = int ( input ( ) ) ar = list ( map ( int , input ( ) . split ( ) ) ) dic = { } li = [ ] for i in range ( n ) : xx = [ ] for j in range ( n - i ) : xx . append ( 0 ) li . append ( xx . copy ( ) ) for i in range ( n ) : for j in range ( n - i ) : if ( i == 0 ) : li [ i ] [ j ] = ar [ j ] else : li [ i ] [ j ] = li [ i - 1 ] [ j ] ^ li [ i - 1 ] [ j + 1 ] for i in range ( 1 , n ) : for j in range ( n - i ) : li [ i ] [ j ] = max ( li [ i ] [ j ] , li [ i - 1 ] [ j ] , li [ i - 1 ] [ j + 1 ] ) for _ in range ( int ( input ( ) ) ) : l , r = map ( int , input ( ) . split ( ) ) print ( li [ r - l ] [ l - 1 ] ) NEW_LINE"],"bleu":1.584072575444089e-22,"rouge_l":0.01336986301369863}
{"id":536,"predictions":["a , b = map ( int , input ( ) . split ( ) ) ans = 0 seen = set ( ) while b : b -= 1   num = int ( input ( ) ) ans += 1 rem = num % a   if rem in seen : print ( ans ) exit ( ) else : seen . add ( rem )   print ( - 1 )         NEW_LINE"],"references":["def bs ( l , h ) : while l < h : m = ( l + h + 1 ) \/\/ 2 if a [ m ] < i : l = m else : h = m - 1 return l   n , m = map ( int , input ( ) . split ( ) ) c , t = map ( int , input ( ) . split ( ) ) l = c * ta = [ 0 ] for _ in range ( n - 1 ) : c , t = map ( int , input ( ) . split ( ) ) a . append ( l ) l = a [ - 1 ] + c * tb = map ( int , input ( ) . split ( ) ) for i in b : print ( bs ( 0 , n - 1 ) + 1 ) NEW_LINE","def busca ( lista , ind , valor , soma ) : verdade = True while verdade :   if soma >= valor : return [ ind , soma ] soma += lista [ ind ] ind += 1   def main ( ) : n , m = [ int ( i ) for i in input ( ) . split ( ' ▁ ' ) ] out = [ ] for i in range ( n ) : c , t = [ int ( i ) for i in input ( ) . split ( ' ▁ ' ) ] out . append ( ( c * t ) ) soma = 0 ind = 0           for i in input ( ) . split ( ' ▁ ' ) : ind , soma = busca ( out , ind , int ( i ) , soma ) print ( abs ( ind ) )                   if __name__ == ' _ _ main _ _ ' : main ( ) NEW_LINE","string = input ( ) . split ( ) numList = list ( map ( int , string ) ) n = numList [ 0 ] m = numList [ 1 ] count = 0 moments = [ ] last = 0 for i in range ( n ) : music = list ( map ( int , input ( ) . split ( ) ) ) moments . append ( count + music [ 0 ] * music [ 1 ] ) count = count + music [ 0 ] * music [ 1 ]   times = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) : for j in range ( last , n ) : if ( times [ i ] <= moments [ j ] ) : print ( j + 1 ) last = j break NEW_LINE","def main ( ) :   music_times = [ ]   n , m = map ( int , input ( ) . split ( ) )   for i in range ( n ) :   c , t = map ( int , input ( ) . split ( ) ) if i == 0 : music_times . append ( c * t ) else : music_times . append ( ( c * t ) + music_times [ i - 1 ] )   fav_moments = [ int ( i ) for i in input ( ) . split ( \" ▁ \" ) ]   i , j = 0 , 0   while j < m and i < n :   if fav_moments [ j ] <= music_times [ i ] : j += 1 print ( i + 1 )   else : i += 1     main ( ) NEW_LINE"],"bleu":0.11906176148480636,"rouge_l":0.33433381182304583}
{"id":537,"predictions":["import mathn , k = map ( int , input ( ) . strip ( ) . split ( ' ▁ ' ) ) NEW_LINE"],"references":["n , k = map ( int , input ( ) . split ( ) ) A = [ int ( input ( ) ) for i in range ( n ) ] from collections import CounterC = Counter ( A ) B = [ ] ans = 0 r = 0 for k , v in C . items ( ) : if v % 2 == 0 : ans += v else : ans += v - 1 r += 1 ans += ( r + 1 ) \/\/ 2 print ( ans ) NEW_LINE","from sys import stdinn , k = map ( int , stdin . readline ( ) . split ( ) ) ans = 0 a = [ ] for i in range ( n ) : val = int ( stdin . readline ( ) ) a . append ( val ) s = set ( a ) for i in s : if a . count ( i ) % 2 != 0 : ans += 1 print ( n - ans \/\/ 2 ) NEW_LINE","n , k = map ( int , input ( ) . split ( ) ) C = [ 0 ] * ( k + 1 ) for _ in range ( n ) : C [ int ( input ( ) ) ] += 1 odd = 0 for c in C : if c % 2 == 1 : odd += 1 print ( ( ( n + 1 ) \/\/ 2 ) * 2 - ( odd + 1 ) \/\/ 2 )   NEW_LINE","n , k = map ( int , input ( ) . split ( ) ) r = [ 0 ] * kfor _ in range ( n ) : t = int ( input ( ) ) r [ t - 1 ] += 1 ans = 0 for i in range ( k ) : ans += r [ i ] % 2 ans \/\/= 2 print ( n - ans ) NEW_LINE"],"bleu":0.08024652407202623,"rouge_l":0.3151709582102153}
{"id":538,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) backpack = set ( ) cur = 0 for x in b : if cur >= n or x in backpack : print ( 0 , end = ' ▁ ' ) else : cnt = 0 while a [ cur + cnt ] != x : backpack . add ( a [ cur + cnt ] ) cnt += 1 backpack . add ( a [ cur + cnt ] ) cnt += 1 cur += cnt print ( cnt , end = ' ▁ ' ) NEW_LINE"],"references":["import sysfrom collections import dequeimport mathinput_ = lambda : sys . stdin . readline ( ) . strip ( \" \\n \" ) ii = lambda : int ( input_ ( ) ) il = lambda : list ( map ( int , input_ ( ) . split ( ) ) ) ilf = lambda : list ( map ( float , input_ ( ) . split ( ) ) ) ip = lambda : input_ ( ) fi = lambda : float ( input_ ( ) ) li = lambda : list ( input_ ( ) ) pr = lambda x : print ( x ) f = lambda : sys . stdout . flush ( )   a , b , c , d = il ( ) print ( 2 * ( a + b + d + 2 ) ) NEW_LINE","def rec ( w , h ) : return h * 2 + ( w + 2 ) * 2     w1 , h1 , w2 , h2 = map ( int , input ( ) . split ( ) ) if w1 == w2 : print ( rec ( w1 , h1 + h2 ) ) else : b = rec ( w1 , h1 ) - w2 t = rec ( w2 , h2 - 1 ) - w2 - 2 print ( b + t ) NEW_LINE","w1 , h1 , w2 , h2 = map ( int , input ( ) . split ( ) ) print ( ( h1 + h2 ) * 2 + w1 * 2 + 4 ) NEW_LINE","w1 , h1 , w2 , h2 = map ( int , input ( ) . split ( ) ) ans = w1 + 4 ans += ( w1 - w2 ) ans += h1 * 2 ans += h2 * 2 ans += w2print ( ans ) NEW_LINE","w , h , v , g = map ( int , input ( ) . split ( ) ) print ( 2 * ( w + h + g + 2 ) ) NEW_LINE"],"bleu":0.2656859767981095,"rouge_l":0.5316883297421283}
{"id":539,"predictions":["from __future__ import division , print_functionfrom collections import * from math import * from itertools import * import osimport sysfrom io import BytesIO , IOBaseimport math NEW_LINE"],"references":["n = int ( input ( ) ) s = input ( ) t , i , count = ' ' , 0 , 0 while i < n - 1 : if s [ i : i + 2 ] != ' ab ' and s [ i : i + 2 ] != ' ba ' : t += ' ab ' count += 1 else : t += s [ i : i + 2 ] i += 2 print ( count ) print ( t ) NEW_LINE","from collections import Counterdef func ( ) : n = int ( input ( ) ) s = list ( input ( ) ) l = [ ] c = 0 for i in range ( 0 , n , 2 ) : if s [ i ] == s [ i + 1 ] : if s [ i ] == ' a ' : s [ i ] = ' b ' else : s [ i ] = ' a ' c += 1 print ( c ) print ( ' ' . join ( s ) ) t = 1 NEW_LINE","  def alphaNum ( x ) : if x == ' a ' : return - 1 return 1   def numAlpha ( x ) : if x == - 1 : return ' a ' return ' b '   n = int ( input ( ) )   s = list ( map ( alphaNum , list ( input ( ) ) ) )   k = 0 l = 0 for i in range ( 0 , n , 2 ) : l = s [ i ] + s [ i + 1 ] if l != 0 : if s [ i + 1 ] == 1 : s [ i + 1 ] = - 1 else : s [ i + 1 ] = 1 k += 1   s = list ( map ( numAlpha , s ) ) print ( k ) for i in range ( n ) : print ( s [ i ] , end = ' ' ) NEW_LINE","n = int ( input ( ) ) s = list ( input ( ) ) k = 0j , i = 0 , 2 while i <= n : if s [ j : i ] not in [ [ \" a \" , \" b \" ] , [ \" b \" , \" a \" ] ] : if s [ j : i ] == [ \" a \" , \" a \" ] : if s [ j ] == \" a \" : s [ j ] = \" b \" else : s [ i - 1 ] = \" b \" else : if s [ j ] == \" b \" : s [ i - 1 ] = \" a \" else : s [ j ] = \" a \" k += 1 j += 2 i += 2 print ( k ) print ( \" \" . join ( s ) ) NEW_LINE"],"bleu":0.0068270714641274766,"rouge_l":0.06846240179573512}
{"id":540,"predictions":["import math   n = int ( input ( ) )   a = int ( math . sqrt ( n ) ) b = math . ceil ( n \/ a )   print ( 2 * ( a + b ) ) NEW_LINE"],"references":["n = int ( input ( ) ) x = 1 res = [ ] for i in range ( 64 ) : lo , hi = 0 , int ( 1e15 ) f = 0 ans = 0 while lo + 1 < hi : mid = ( lo + hi ) \/\/ 2 v = ( x - 1 ) * mid + ( mid * mid - mid ) \/\/ 2 if ( v == n ) : f = 1 ; ans = mid break ; if ( v > n ) : hi = mid else : lo = mid if ( f and ans % 2 == 1 ) : res . append ( ans * x ) x = x * 2 if ( len ( res ) == 0 ) : print ( - 1 ) ; exit ( 0 ) for x in res : print ( int ( x ) ) NEW_LINE","def get ( x ) : low = 1 high = x ans = - 1 while low <= high : mid = ( low + high ) \/\/ 2 if mid * mid <= x : low = mid + 1 ans = mid else : high = mid - 1 return ans   n = int ( input ( ) ) f = 0 for i in range ( 0 , 64 ) : a = 1 b = ( 2 ** ( i + 1 ) ) - 3 c = - 2 * n d = b * b - 4 * a * c sq = get ( d ) if sq ** 2 == d : x = - b + sq if ( ( x & 1 ) == 0 and ( ( x \/\/ 2 ) & 1 ) and ( x \/\/ 2 ) > 0 ) : f = 1 ; ans = ( x >> 1 ) * ( 1 << i ) ; print ( ans ) if f == 0 : print ( - 1 ) NEW_LINE","def f ( n , k ) : return n * ( n - 1 ) \/\/ 2 + n * ( pow ( 2 , k ) - 1 )   a = int ( input ( ) ) ans = [ ] for k in range ( 0 , 65 ) : l , r = 0 , pow ( 10 , 10 ) while r - l > 1 : mid = ( l + r ) \/\/ 2 if f ( mid , k ) <= a : l = mid else : r = mid if f ( l , k ) == a and l % 2 != 0 : ans . append ( l * pow ( 2 , k ) )   NEW_LINE","import sysn = int ( input ( ) ) ans = 1 t = Truewhile ans \/\/ 2 <= n : left = 0 right = n while left <= right : x = ( left + right ) \/\/ 2 a = ( 2 * x + 1 ) * ( x + ans - 1 ) if a == n : print ( ans * ( 2 * x + 1 ) ) t = False break elif a < n : left = x + 1 else : right = x - 1 ans *= 2 if t == True : print ( - 1 )           NEW_LINE","showed = Falsedef func ( num , twos ) : ash = num num = int ( num ) num = ( num ) * ( num - 1 ) num \/\/= 2 num = num + ( ash * ( ( 2 ** twos ) - 1 ) ) return num   def decide ( twos , num ) : global showed low , hi = int ( 0 ) , int ( 1e18 ) ans = int ( - 1 ) while ( low <= hi ) : mid = ( low + hi ) \/\/ 2 pk = ( mid * 2 ) - 1 if ( func ( pk , twos ) <= num ) : ans = pk low = mid + 1 else : hi = mid - 1 if ( func ( ans , twos ) == num ) : showed = True print ( ans * ( 2 ** twos ) )   ash = int ( input ( ) )   for i in range ( 0 , 65 ) : decide ( i , ash )     if ( showed == False ) : print ( - 1 )   NEW_LINE"],"bleu":0.08017547600999139,"rouge_l":0.25630628645305364}
{"id":541,"predictions":["n = int ( input ( ) ) a = [ int ( x ) for x in input ( ) . split ( ) ] for i in range ( n ) : a [ i ] = a [ i ] = a [ i ] for i in range ( n ) : a [ i ] = a [ i ] [ 0 ] + a [ i ] = a [ i ] [ 1 ] for i in range ( n ) : for j in range ( n ) : if a [ i ] [ j ] == ' X ' : a [ i ] [ j ] = a [ i ] [ j ] + 1 elif a [ i ] [ j ] != ' X ' : print ( ' YES ' ) else : print ( ' NO ' ) NEW_LINE"],"references":["def checkhor ( x , y ) : c = 0 cy = y + 1 while ( cy < n and grid [ x ] [ cy ] == ' X ' ) : cy += 1 c += 1 if ( c >= 4 ) : return True cy = y - 1 while ( cy >= 0 and grid [ x ] [ cy ] == ' X ' ) : cy -= 1 c += 1 NEW_LINE","def solve ( ) :   grid = [ input ( ) for r in range ( 10 ) ]   def win ( arr ) : return arr . count ( ' X ' ) == 4 and arr . count ( ' . ' ) == 1   for i in range ( 10 ) : for j in range ( 10 ) : if win ( grid [ i ] [ j : j + 5 ] ) : return True elif win ( [ grid [ k ] [ j ] for k in range ( i , min ( i + 5 , 10 ) ) ] ) : return True elif win ( [ grid [ i + k ] [ j + k ] for k in range ( min ( 5 , 10 - i , 10 - j ) ) ] ) : return True elif win ( [ grid [ i + k ] [ j - k ] for k in range ( min ( 5 , j + 1 , 10 - i ) ) ] ) : return True return False     if solve ( ) : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.261131312480157,"rouge_l":0.41658306267471246}
{"id":542,"predictions":["from collections import Counterdef func ( ) : n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) k = { } m = 0 for i in l : if i in k : del k [ i ] else : k [ i ] = 1 if len ( k ) > m : m = len ( k ) print ( m ) t = 1 NEW_LINE"],"references":["import math   def gcd ( a , b ) : if a < b : a , b = b , a while a % b != 0 : a , b = b , a % b return b   n , k , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) )   r = { } for i in range ( n ) : e = a [ i ] % m if e in r : r [ e ] . append ( a [ i ] ) else : r [ e ] = [ a [ i ] ]   for key in r : if len ( r [ key ] ) >= k : print ( \" Yes \" ) for i in range ( k ) : print ( r [ key ] [ i ] , end = \" ▁ \" ) breakelse : print ( \" No \" )   NEW_LINE","n , k , m = map ( int , input ( ) . split ( ) ) A = tuple ( map ( int , input ( ) . split ( ) ) ) ring = [ [ ] for i in range ( m ) ] for a in A : ring [ a % m ] . append ( a ) for i in range ( m ) : if len ( ring [ i ] ) >= k : A = ring [ i ] [ : k ] print ( \" Yes \" ) print ( * A ) exit ( 0 ) print ( \" No \" ) NEW_LINE","from collections import defaultdictn , k , m = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) d = defaultdict ( list ) for p in l : d [ p % m ] . append ( p ) NEW_LINE","from collections import defaultdict , deque , Counterfrom sys import stdin , stdoutfrom heapq import heappush , heappopimport mathimport ioimport osimport mathimport bisect   NEW_LINE"],"bleu":0.44646515357541766,"rouge_l":0.6206711888611209}
{"id":543,"predictions":["t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : n = int ( input ( ) ) NEW_LINE a = [ int ( x ) for x in input ( ) . split ( \" ▁ \" ) ] NEW_LINE a = [ int ( x ) for x in input ( ) . split ( \" ▁ \" ) ] NEW_LINE print ( \" ▁ \" . join ( a ) ) NEW_LINE"],"references":["t = int ( input ( ) ) NEW_LINE for j in range ( t ) : n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : new = [ ] NEW_LINE if i % 2 == 0 : NEW_LINE INDENT new . append ( a [ count ] ) else : NEW_LINE new . append ( a [ n - count - 1 ] ) NEW_LINE DEDENT count += 1 NEW_LINE print ( * new , end = \" ▁ \" ) NEW_LINE","t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE k = 0 NEW_LINE ind = 0 NEW_LINE while k < n : print ( a [ ind ] , end = ' ▁ ' ) NEW_LINE if ind >= 0 : ind *= - 1 NEW_LINE ind -= 1 else : ind *= - 1 NEW_LINE k += 1 NEW_LINE print ( ) NEW_LINE","import mathfor NEW_LINE t in range ( int ( input ( ) ) ) : arr = [ ] NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n \/\/ 2 ) : arr . extend ( [ a [ i ] , a [ n - i - 1 ] ] ) NEW_LINE if ( n % 2 ) : arr . append ( a [ n \/\/ 2 ] ) NEW_LINE print ( * arr ) NEW_LINE","t = int ( input ( ) )   for x in range ( t ) : n = int ( input ( ) ) NEW_LINE b = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE r = [ 0 for x in range ( n ) ]   i = 0 NEW_LINE j = 0 NEW_LINE while i < n : r [ i ] = b [ j ]   if i + 1 != n : r [ i + 1 ] = b [ n - ( j + 1 ) ]   i += 2 NEW_LINE j += 1   print ( ' ▁ ' . join ( map ( str , r ) ) ) NEW_LINE"],"bleu":0.538911748084563,"rouge_l":0.558971327224357}
{"id":544,"predictions":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) print ( n * ( n + 1 ) \/\/ 2 ) NEW_LINE"],"references":["n = int ( input ( ) ) i = 0 a = [ ] a = list ( map ( int , input ( ) . split ( ) ) ) a . sort ( ) while i < len ( a ) : print ( a [ i ] ) i = i + 1 NEW_LINE","n = int ( input ( ) ) nums = [ int ( i ) for i in input ( ) . split ( ) ] nums . sort ( ) for i in nums : print ( i , end = ' ▁ ' ) print ( ) NEW_LINE","n = int ( input ( ) ) blocks = list ( map ( int , input ( ) . split ( ) ) )   rows = max ( blocks )   grid = [ ]   for i in range ( rows ) : val = [ 0 ] * n grid . append ( val )   for i in range ( n ) : num = blocks [ i ] for j in range ( num ) : grid [ j ] [ i ] = 1     for i in range ( n - 1 ) : for j in range ( rows ) : if grid [ j ] [ i ] == 1 : if grid [ j ] [ i + 1 ] == 0 : grid [ j ] [ i ] , grid [ j ] [ i + 1 ] = grid [ j ] [ i + 1 ] , grid [ j ] [ i ]   totals = [ ]   for i in range ( n ) : counter = 0 for j in range ( rows ) : if grid [ j ] [ i ] == 1 : counter += 1   totals . append ( counter )   totals = sorted ( totals )   for i in totals : print ( i , end = ' ▁ ' )   print ( ) NEW_LINE","n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) s = sorted ( a ) \"\"\" ▁ for ▁ i ▁ in ▁ sorted ( a ) : ▁ ▁ ▁ ▁ s ▁ + = ▁ str ( i ) ▁ \"\"\" print ( * s ) NEW_LINE","input ( ) ; print ( * sorted ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE"],"bleu":0.711492039674296,"rouge_l":0.7988890240441145}
{"id":545,"predictions":["import sysfrom functools import lru_cache , cmp_to_keyfrom heapq import merge , heapify , heappop , heappushfrom math import * from collections import defaultdict as dd , deque , Counter as Cfrom itertools import combinations as comb , permutations as permfrom bisect import bisect_left as bl , bisect_right as br , bisect , insortfrom time import perf_counterfrom fractions import Fractionimport copyfrom copy import deepcopyimport timestarttime = time . time ( ) mod = int ( pow ( 10 , 9 ) + 7 ) mod2 = 998244353   def data ( ) : return sys . stdin . readline ( ) . strip ( ) def out ( * var , end = \" \\n \" ) : sys . stdout . write ( ' ▁ ' . join ( map ( str , var ) ) + end ) def L ( ) : return list ( sp ( ) ) def sl ( ) : return list ( ssp ( ) ) def sp ( ) : return map ( int , data ( ) . split ( ) ) def ssp ( ) : return map ( str , data ( ) . split ( ) ) def l1d ( n , val = 0 ) : return [ val for i in range ( n ) ] def l2d ( n , m , val = 0 ) : return [ l1d ( n , val ) for j in range ( m ) ] try : NEW_LINE"],"references":["n = int ( input ( ) ) L = [ ] R = [ ]   for _ in range ( n ) : l , r = map ( int , input ( ) . split ( ) ) L . append ( l ) R . append ( r )   l0 = L . count ( 0 ) l1 = n - l0   r0 = R . count ( 0 ) r1 = n - r0   t = 0   if r0 > r1 : t += r1else : t += r0   if l0 > l1 : t += l1else : t += l0   print ( t ) NEW_LINE","l = [ ] r = [ ] moves = 0 open = 0 closed = 0 for i in range ( int ( input ( ) ) ) : a , b = map ( int , input ( ) . split ( ) ) l . append ( a ) r . append ( b ) if l . count ( 0 ) >= l . count ( 1 ) : moves += l . count ( 1 ) else : moves += l . count ( 0 ) if r . count ( 0 ) >= r . count ( 1 ) : moves += r . count ( 1 ) else : moves += r . count ( 0 ) print ( moves ) NEW_LINE","quantity = int ( input ( ) ) left_doors = [ ] right_doors = [ ]   for i in range ( quantity ) : temp = input ( ) left = int ( temp [ 0 ] ) right = int ( temp [ 2 ] ) left_doors . append ( left ) right_doors . append ( right )   left_doors . sort ( ) if len ( left_doors ) % 2 == 0 : if left_doors [ len ( left_doors ) \/\/ 2 - 1 ] == left_doors [ len ( left_doors ) \/\/ 2 ] : x = left_doors [ len ( left_doors ) \/\/ 2 - 1 ] else : x = left_doors [ len ( left_doors ) \/\/ 2 ] else : x = left_doors [ len ( left_doors ) \/\/ 2 ]   right_doors . sort ( ) if len ( right_doors ) % 2 == 0 : if right_doors [ len ( right_doors ) \/\/ 2 - 1 ] == right_doors [ len ( right_doors ) \/\/ 2 ] : y = right_doors [ len ( right_doors ) \/\/ 2 - 1 ] else : y = right_doors [ len ( right_doors ) \/\/ 2 ] else : y = right_doors [ len ( right_doors ) \/\/ 2 ]     secs = ( len ( left_doors ) - left_doors . count ( x ) ) + ( len ( right_doors ) - right_doors . count ( y ) ) print ( secs ) NEW_LINE","n = int ( input ( ) )   L , R = 0 , 0 for _ in range ( n ) :   ( l , r ) = ( int ( i ) for i in input ( ) . split ( ' ▁ ' ) ) L += l R += r   print ( min ( n - R , R ) + min ( n - L , L ) ) NEW_LINE","def main_function ( ) : n = int ( input ( ) ) l_0 = 0 r_0 = 0 for i in range ( n ) : l , r = [ int ( i ) for i in input ( ) . split ( \" ▁ \" ) ] if l == 0 : l_0 += 1 if r == 0 : r_0 += 1 return min ( l_0 , n - l_0 ) + min ( r_0 , n - r_0 )     print ( main_function ( ) ) NEW_LINE"],"bleu":0.12470583739717457,"rouge_l":0.34758811867634365}
{"id":546,"predictions":["def rec ( x ) : if x == 1 : return 1   if x % 2 == 0 : return rec ( x \/\/ 2 )   else : return rec ( x \/\/ 2 ) + 1   n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) d = { } ans = 0 for i in l : som = rec ( i ) if som in d : d [ som ] += 1   else : d [ som ] = 1   for i in d : ans = ans + int ( ( ( d [ i ] - 1 ) \/ 2 ) * ( d [ i ] ) )   print ( ans ) NEW_LINE"],"references":["n = int ( input ( ) ) string = ' ' . join ( map ( str , input ( ) . split ( ) ) ) maxx = 0 for i in range ( n + 1 ) : maxx = max ( maxx , string [ : i ] . count ( '0' ) + string [ i : ] . count ( '1' ) ) print ( maxx ) NEW_LINE","import sys   n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) dp = [ [ - 10 ** 9 , - 10 ** 9 ] for _ in range ( n + 1 ) ] dp [ 0 ] [ 0 ] = 0   for i , x in enumerate ( a ) : if x == 0 : dp [ i + 1 ] [ 0 ] = dp [ i ] [ 0 ] + 1 dp [ i + 1 ] [ 1 ] = dp [ i ] [ 1 ] else : dp [ i + 1 ] [ 0 ] = dp [ i ] [ 0 ] dp [ i + 1 ] [ 1 ] = max ( dp [ i ] [ 0 ] , dp [ i ] [ 1 ] ) + 1   print ( max ( dp [ - 1 ] ) ) NEW_LINE","n = int ( input ( ) ) projects = input ( ) . split ( ' ▁ ' )   best = 0 for i in range ( len ( projects ) ) : cur = 1 cur += projects [ : i ] . count ( '0' ) cur += projects [ i + 1 : n ] . count ( '1' ) best = max ( best , cur )   print ( best ) NEW_LINE"],"bleu":0.31271398433323194,"rouge_l":0.5066154991694828}
{"id":547,"predictions":["def solve ( ) : n = int ( input ( ) ) NEW_LINE a = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE m = int ( input ( ) ) NEW_LINE sum = 0 NEW_LINE for i in range ( m ) : sum += a [ i ] NEW_LINE ans = solve ( ) NEW_LINE print ( ans ) NEW_LINE"],"references":["def search ( a , x ) : l , r = 0 , len ( a ) - 1 while l <= r : mid = ( l + r ) \/\/ 2 if a [ mid ] >= x and a [ mid - 1 ] < x : return mid elif a [ mid ] < x : l = mid + 1 else : r = mid - 1 return 0   n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( 1 , n ) : a [ i ] += a [ i - 1 ]   q = int ( input ( ) ) qu = list ( map ( int , input ( ) . split ( ) ) ) for x in qu : print ( search ( a , x ) + 1 ) NEW_LINE","n = int ( input ( ) ) a = [ int ( num ) for num in input ( ) . split ( ' ▁ ' ) ] c = [ 0 ] * ( sum ( a ) ) k = 0 for i in range ( n ) : for j in range ( a [ i ] ) : c [ k ] = i + 1 k += 1 m = int ( input ( ) ) q = [ int ( num ) for num in input ( ) . split ( ' ▁ ' ) ] for i in range ( m ) : print ( c [ q [ i ] - 1 ] ) NEW_LINE","def search ( a , x ) : l , r = 0 , len ( a ) - 1 while l <= r : mid = ( l + r ) \/\/ 2 if a [ mid ] >= x and a [ mid - 1 ] < x : return mid elif a [ mid ] < x : l = mid + 1 else : r = mid - 1   n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) pref = [ a [ 0 ] ] for i in range ( 1 , n ) : pref . append ( pref [ i - 1 ] + a [ i ] )   q = int ( input ( ) ) qu = list ( map ( int , input ( ) . split ( ) ) ) for x in qu : if x <= a [ 0 ] : print ( 1 ) else : print ( search ( pref , x ) + 1 ) NEW_LINE","def search ( a , x ) : l , r = 0 , len ( a ) - 1 while l <= r : mid = ( l + r ) \/\/ 2 if a [ mid ] >= x and a [ mid - 1 ] < x : return mid elif a [ mid ] < x : l = mid + 1 else : r = mid - 1   n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) pref = [ 0 ] for i in range ( 1 , n + 1 ) : pref . append ( pref [ i - 1 ] + a [ i - 1 ] )   q = int ( input ( ) ) qu = list ( map ( int , input ( ) . split ( ) ) ) for x in qu : print ( search ( pref , x ) ) NEW_LINE"],"bleu":0.31252231883985726,"rouge_l":0.4365879244180642}
{"id":548,"predictions":["n = int ( input ( ) ) k = 1 while n > k : n -= k k += 1 print ( n ) NEW_LINE"],"references":["n = input ( ) print ( n + n [ : : - 1 ] ) NEW_LINE","n = input ( ) print ( n , end = \" \" ) for x in range ( len ( n ) ) : print ( n [ len ( n ) - x - 1 ] , end = \" \" ) NEW_LINE","s = input ( ) print ( s + ' ' . join ( reversed ( s ) ) ) NEW_LINE","def main ( ) : n = input ( ) print ( n + n [ : : - 1 ] )     if __name__ == ' _ _ main _ _ ' : main ( ) NEW_LINE","s = input ( ) print ( s + s [ : : - 1 ] ) NEW_LINE"],"bleu":0.195647514979229,"rouge_l":0.5226044549887967}
{"id":549,"predictions":["t = int ( input ( ) ) for _ in range ( t ) : s = input ( ) zero = s . find ( '0' ) if s . find ( '1' ) == - 1 or s . find ( '0' ) == - 1 : print ( s ) else : s = s . find ( '1' ) NEW_LINE"],"references":["for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) odd_str = 0 good_str = 0 bad_str = 0 for i in range ( n ) : s = input ( ) if len ( s ) % 2 != 0 : odd_str += 1 else : if s . count ( '0' ) % 2 == 0 and s . count ( '1' ) % 2 == 0 : good_str += 1 else : bad_str += 1 if bad_str % 2 != 0 and not odd_str : print ( n - 1 ) else : print ( n )       NEW_LINE","for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) o , z = 0 , 0 for i in range ( n ) : b = input ( ) . rstrip ( ) o += ( len ( b ) % 2 ) z += b . count ( \"1\" ) print ( n - ( not o and z % 2 ) ) NEW_LINE","for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) odd , evenGood , evenBad = 0 , 0 , 0 for i in range ( n ) : a = input ( ) if len ( a ) % 2 == 1 : odd += 1 if a . count ( '0' ) % 2 == 0 : evenGood += 1 else : evenBad += 1 print ( n - 1 if ( odd == 0 and evenBad % 2 == 1 ) else n ) NEW_LINE","T = int ( input ( ) ) for _ in range ( T ) : n = int ( input ( ) ) ; one = 0 ; zero = 0 ; even = [ ] ; odd = [ ] ; ans1 = 0 for _ in range ( n ) : a = [ 0 ] * 2 ; s = input ( ) o = s . count ( '1' ) z = s . count ( '0' ) if ( o + z ) % 2 == 0 and z % 2 == 0 and o % 2 == 0 : ans1 += 1 ; if ( o + z ) % 2 == 1 : ans1 += 1 ; one += o ; zero += z if len ( s ) % 2 == 1 : odd . append ( len ( s ) ) else : even . append ( len ( s ) ) ans = 0 ; l = even + odd NEW_LINE","T = int ( input ( ) ) for _ in range ( T ) : n = int ( input ( ) ) ; one = 0 ; zero = 0 ; even = [ ] ; odd = [ ] for _ in range ( n ) : a = [ 0 ] * 2 ; s = input ( ) o = s . count ( '1' ) z = s . count ( '0' ) one += o ; zero += z if len ( s ) % 2 == 1 : odd . append ( len ( s ) ) else : even . append ( len ( s ) ) ans = 0 ; l = even + odd NEW_LINE"],"bleu":0.38359460611229834,"rouge_l":0.47466712778834513}
{"id":550,"predictions":["n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) map = { } for i in arr : if i not in map : map [ i ] = 1 else : map [ i ] += 1 max = 0 for i in map : if map [ i ] > max : max = map [ i ] print ( n - max ) NEW_LINE"],"references":["n , k = [ int ( x ) for x in input ( ) . split ( ) ] cards = input ( )   frequency = { } for card in cards : if card not in frequency : frequency [ card ] = 0 frequency [ card ] += 1   frequent = list ( sorted ( frequency . values ( ) , reverse = True ) )     amount = frequent [ 0 ] leftover = max ( k - amount , 0 ) coins = ( k - leftover ) * ( k - leftover ) i = 1 while leftover > 0 and i >= 0 : temp = min ( leftover , frequent [ i ] ) coins = coins + ( temp * temp ) leftover = leftover - temp i += 1   print ( coins ) NEW_LINE","n , k = map ( int , input ( ) . split ( ) ) c = list ( input ( ) ) ncl = [ ] trash = [ ] for i in c : if i not in trash : trash . append ( i ) ncl . append ( c . count ( i ) )   ncl . sort ( reverse = True ) bruh = 0j = 0 while k > 0 :   if k >= ncl [ j ] : k -= ncl [ j ] bruh += ncl [ j ] * ncl [ j ] else : bruh += k * k k = 0 j += 1 print ( bruh ) NEW_LINE","from collections import Counterdef f ( arr , k ) : x = Counter ( arr ) ans = 0 for i , j in sorted ( x . items ( ) , key = lambda s : s [ 1 ] , reverse = True ) : if j <= k : k -= j ans += j ** 2 else : ans += k ** 2 k = 0 break return ans     a , b = map ( int , input ( ) . strip ( ) . split ( ) ) lst = input ( ) print ( f ( lst , b ) ) NEW_LINE","from collections import Counterdef f ( arr , k ) : x = [ 0 ] * 26 for i in arr : x [ ord ( i ) - ord ( \" A \" ) ] += 1 ans = 0 for j in sorted ( x , reverse = True ) : if j <= k : k -= j ans += j ** 2 else : ans += k ** 2 k = 0 break return ans     a , b = map ( int , input ( ) . strip ( ) . split ( ) ) lst = input ( ) print ( f ( lst , b ) ) NEW_LINE","from collections import Counter   n , k = map ( int , input ( ) . split ( ) ) st = input ( ) ans = ' ' dct = Counter ( st ) lst = sorted ( dct . items ( ) , key = lambda s : s [ 1 ] , reverse = True ) NEW_LINE"],"bleu":0.42249390364139494,"rouge_l":0.4399278806752992}
{"id":551,"predictions":["def main ( ) : n , m , a , b = map ( int , input ( ) . split ( ) ) print ( n - 1 ) if __name__ == ' _ _ main _ _ ' : main ( ) NEW_LINE"],"references":["from collections import defaultdictfrom bisect import bisect_leftp , n = defaultdict ( int ) , int ( input ( ) ) for i in range ( n ) : a , b = input ( ) . split ( ) p [ a ] = max ( p [ a ] , int ( b ) ) p , n = sorted ( ( b , a ) for a , b in p . items ( ) ) , len ( p ) t = [ 0 ] + [ bisect_left ( p , ( p [ n - 1 - n \/\/ k ] [ 0 ] , ' ' ) ) for k in [ 2 , 5 , 10 , 100 ] ] + [ n ] s = [ ' noob ' , ' random ' , ' average ' , ' hardcore ' , ' pro ' ] for i in range ( 1 , len ( t ) ) : d = s [ i - 1 ] for j in range ( t [ i - 1 ] , t [ i ] ) : p [ j ] = p [ j ] [ 1 ] + ' ▁ ' + dprint ( n ) print ( ' \\n ' . join ( p ) ) NEW_LINE","from collections import defaultdictfrom bisect import bisect_leftp , n = defaultdict ( int ) , int ( input ( ) ) for i in range ( n ) : a , b = input ( ) . split ( ) p [ a ] = max ( p [ a ] , int ( b ) ) p , n = sorted ( ( b , a ) for a , b in p . items ( ) ) , len ( p ) t = [ 0 ] + [ bisect_left ( p , ( p [ n - 1 - n \/\/ k ] [ 0 ] , ' ' ) ) for k in [ 2 , 5 , 10 , 100 ] ] + [ n ] s = [ ' noob ' , ' random ' , ' average ' , ' hardcore ' , ' pro ' ] for i in range ( 1 , len ( t ) ) : d = s [ i - 1 ] for j in range ( t [ i - 1 ] , t [ i ] ) : p [ j ] = p [ j ] [ 1 ] + ' ▁ ' + dprint ( n ) print ( ' \\n ' . join ( p ) ) NEW_LINE","class Player : def __init__ ( self , name , score ) : self . name = name self . score = score   class Tier : def __init__ ( self , label , percentile ) : self . label = label self . percentile = percentiletier_data = [ ( ' pro ' , 99 ) , ( ' hardcore ' , 90 ) , ( ' average ' , 80 ) , ( ' random ' , 50 ) ] tiers = [ Tier ( * t ) for t in tier_data ]   num_records = int ( input ( ) ) name_to_score = { } for i in range ( num_records ) : tokens = input ( ) . split ( ) name , score = tokens [ 0 ] , int ( tokens [ 1 ] ) name_to_score [ name ] = max ( name_to_score . setdefault ( name , 0 ) , score )   num_players = len ( name_to_score ) players = [ ] for name , score in name_to_score . items ( ) : players . append ( Player ( name , score ) ) players . sort ( key = lambda player : player . score ) print ( num_players )   pos = num_players - 1 while pos >= 0 : player = players [ pos ] rank = ' noob ' score = player . score for tier in tiers : if 100 * ( pos + 1 ) \/\/ num_players >= tier . percentile : rank = tier . label break print ( player . name , rank ) pos -= 1 while pos >= 0 and players [ pos ] . score == score : print ( players [ pos ] . name , rank ) pos -= 1 NEW_LINE","def t ( g , n ) : for x , y in ( ( 50 , ' noob ' ) , ( 20 , ' random ' ) , ( 10 , ' average ' ) , ( 1 , ' hardcore ' ) ) : if g > x * n \/\/ 100 : return y return ' pro ' p , st = { } , { } for i in range ( int ( input ( ) ) ) : n , s = input ( ) . split ( ) if n not in p or int ( s ) > p [ n ] : p [ n ] = int ( s ) for i , si in enumerate ( sorted ( p . values ( ) , reverse = True ) ) : if si not in st : st [ si ] = t ( i , len ( p ) ) print ( len ( p ) ) print ( * sorted ( k + ' ▁ ' + st [ p [ k ] ] for k in p ) , sep = ' \\n ' ) NEW_LINE","I = inputP = printd = { } for _ in '0' * int ( I ( ) ) : a , b = I ( ) . split ( ) ; d [ a ] = max ( d . get ( a , 0 ) , int ( b ) ) v = d . values ( ) n = len ( d ) P ( n ) for k in d : a = b = 0 for x in v : a += x <= d [ k ] ; b += x > d [ k ] s = ' noob ' ; a \/= n ; b \/= n if a >= .5 and b >= .2 : s = ' random ' if a >= .8 and b >= .1 : s = ' average ' if a >= .9 and b >= .01 : s = ' hardcore ' if a >= .99 : s = ' pro ' P ( k , s ) NEW_LINE"],"bleu":0.025242520978903275,"rouge_l":0.20916812806771753}
{"id":552,"predictions":["import sys , os , ioimport math , bisect , operatorinf , mod = float ( ' inf ' ) , 10 ** 9 + 7 NEW_LINE"],"references":["n = int ( input ( ) ) x = [ ] for i in range ( n ) : a = list ( map ( int , input ( ) . split ( ) ) ) x . append ( a ) c = 1 x . sort ( key = lambda i : i [ 0 ] , reverse = True ) x . sort ( key = lambda i : i [ 1 ] , reverse = True ) p = 0 for i in x : c -= 1 c += i [ 1 ] p += i [ 0 ] if c == 0 : breakprint ( p ) NEW_LINE","def STR ( ) : return list ( input ( ) ) def INT ( ) : return int ( input ( ) ) def MAP ( ) : return map ( int , input ( ) . split ( ) ) def MAP2 ( ) : return map ( float , input ( ) . split ( ) ) def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) def STRING ( ) : return input ( ) import stringimport sysfrom heapq import heappop , heappushfrom bisect import * from collections import deque , Counter , defaultdictfrom math import * from itertools import permutations , accumulatedx = [ - 1 , 1 , 0 , 0 ] dy = [ 0 , 0 , 1 , - 1 ] NEW_LINE","n = int ( input ( ) ) top = [ ] bottom = [ ] for i in range ( n ) : a , b = map ( int , input ( ) . split ( ) ) top . append ( a ) bottom . append ( b )   c = [ x for _ , x in sorted ( zip ( bottom , top ) ) ] NEW_LINE","n = int ( input ( ) . strip ( ) ) cards = [ ] for i in range ( n ) : a , b = [ int ( ele ) for ele in input ( ) . strip ( ) . split ( ) ] tup = ( b , a ) cards . append ( tup )   ctr = 1 maxpoints = 0 cards = sorted ( cards , reverse = True ) for i , tup in enumerate ( cards ) : if ctr > 0 : NEW_LINE","cards = [ ] value = 0 count = 1 for i in range ( int ( input ( ) ) ) : ai , bi = map ( int , input ( ) . split ( ) ) if bi == 0 : cards . append ( ai ) else : value += ai count += bi - 1 print ( value + sum ( sorted ( cards , reverse = True ) [ : count ] ) ) NEW_LINE"],"bleu":0.014267473386562956,"rouge_l":0.12067260138476756}
{"id":553,"predictions":["import sysmod = 1000000007 input = lambda : sys . stdin . readline ( ) . rstrip ( \" \\n \" )   from math import sqrtck = [ i for i in range ( 200001 ) ] i = 2 for i in range ( 2 , int ( sqrt ( 200001 ) ) + 1 ) : if ck [ i ] == i : t = i * i for j in range ( t , 200001 , i ) : ck [ j ] = i NEW_LINE"],"references":["def f ( s ) : for i in range ( len ( s ) \/\/ 2 + 1 ) : if s [ i ] != s [ - 1 - i ] : return False return Truez = 1200000 arr = [ 1 ] * zarr [ 0 ] , arr [ 1 ] = 0 , 0 for i in range ( 2 , 1096 ) : for j in range ( i * i , z , i ) : arr [ j ] = 0 cntpal = cntprm = 0 i = 1 p , q = map ( int , input ( ) . split ( ) ) k = p \/ qm = kwhile i < 1200000 : if f ( str ( i ) ) : cntpal += 1 if arr [ i ] : cntprm += 1 if cntprm \/ cntpal <= k : n = i i += 1 print ( n ) NEW_LINE","p , q = map ( int , input ( ) . split ( ) ) L = 2 * 10 ** 6 + 10 ** 5 P = [ 0 ] * L   for i in range ( 2 , L , 1 ) : if P [ i ] == 0 : for j in range ( i * i , L , i ) : P [ j ] = 1 ans = - 1 P [ 1 ] = 1 cnta = 0 cntb = 0 for i in range ( 1 , L ) : if P [ i ] == 0 : cnta += 1 j = str ( i ) if j == j [ : : - 1 ] : cntb += 1 if cnta * q <= p * cntb : ans = iprint ( ans ) NEW_LINE","import sysinput = sys . stdin . readline   def rr ( n ) : a = set ( [ ] ) NEW_LINE","def palindromic ( x ) : s = str ( x ) return s == s [ : : - 1 ]   def main ( ) : p , q = map ( int , input ( ) . split ( ) ) n = 10 ** 7 prime = [ True for i in range ( n + 1 ) ] prime [ 0 ] = False prime [ 1 ] = False   for i in range ( 2 , n + 1 ) : if prime [ i ] : for j in range ( i ** 2 , n + 1 , i ) : prime [ j ] = False   pi = 0 rub = 0 ans = 0 for i in range ( 1 , 10 ** 7 ) : if prime [ i ] : pi += 1 if palindromic ( i ) : rub += 1 if pi * q <= p * rub : ans = i if ans == 0 : print ( ' Palindromic ▁ tree ▁ is ▁ better ▁ than ▁ splay ▁ tree ' ) else : print ( ans )   main ( ) NEW_LINE","N = int ( 2e6 + 3 ) is_prime = [ 0 ] * Ndef sieve ( ) : is_prime [ 1 ] = 1 ; for i in range ( 2 , N ) : if is_prime [ i ] == 1 : continue for j in range ( 2 * i , N , i ) : is_prime [ j ] = 1   def palindrom ( s ) : return s == s [ : : - 1 ] p , q = map ( int , input ( ) . split ( ) ) rub = 0 pi = 0 sieve ( ) for i in range ( 1 , N ) : if is_prime [ i ] == 0 : pi += 1 if palindrom ( str ( i ) ) : rub += 1 if pi * q <= rub * p : res = iprint ( res ) NEW_LINE"],"bleu":0.37727840191094214,"rouge_l":0.6213168424881774}
{"id":554,"predictions":["import sys , os , iodef rs ( ) : return sys . stdin . readline ( ) . rstrip ( ) def ri ( ) : return int ( sys . stdin . readline ( ) ) def ria ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) def ws ( s ) : sys . stdout . write ( s + ' \\n ' ) def wi ( n ) : sys . stdout . write ( str ( n ) + ' \\n ' ) def wia ( a ) : sys . stdout . write ( ' ▁ ' . join ( [ str ( x ) for x in a ] ) + ' \\n ' ) import math , datetime , functools , itertools , operator , bisect , fractions , statisticsfrom collections import deque , defaultdict , OrderedDict , Counterfrom fractions import Fractionfrom decimal import Decimalfrom sys import stdoutfrom heapq import heappush , heappop , heapify , _heapify_max , _heappop_max , nsmallest , nlargest   def main ( ) : NEW_LINE"],"references":["def calculate_sides ( n , m ) : if n == 1 : return m \/\/ 2 if m % 2 == 0 else m \/\/ 2 + 1 if m == 1 : return n \/\/ 2 if n % 2 == 0 else n \/\/ 2 + 1   left , right , top , bottom = 0 , 0 , 0 , 0 top = m \/\/ 2 if m % 2 == 0 else m \/\/ 2 + 1 bottom = top if n % 2 != 0 else m \/\/ 2 n -= 2 m -= 2 left = n \/\/ 2 if m > 0 : right = left if m % 2 != 0 else n \/\/ 2 if n % 2 == 0 else n \/\/ 2 + 1   return top + bottom + left + right     n , m = list ( map ( int , input ( ) . split ( ) ) ) x = int ( input ( ) ) dict = dict ( ) times = 1 while n > 0 and m > 0 : quantity = calculate_sides ( n , m ) dict [ times ] = quantity times += 1 n -= 2 m -= 2 print ( dict [ x ] if x in dict else 0 ) NEW_LINE","import matha = list ( map ( int , input ( ) . split ( ) ) ) x = int ( input ( ) ) bt = math . ceil ( ( a [ 0 ] * a [ 1 ] ) \/ 2 ) c = [ ] if a [ 0 ] >= 2 and a [ 1 ] >= 2 : k = ( math . ceil ( a [ 0 ] \/ 2 ) + math . floor ( a [ 0 ] \/ 2 ) + math . ceil ( ( a [ 1 ] - 2 ) \/ 2 ) + math . floor ( ( a [ 1 ] - 2 ) \/ 2 ) ) else : k = math . ceil ( max ( a ) \/ 2 ) + math . floor ( max ( a ) \/ 2 ) while True : if a [ 0 ] < 2 or a [ 1 ] < 2 : c . append ( k ) break c . append ( k ) a [ 0 ] -= 2 a [ 1 ] -= 2 if a [ 0 ] >= 2 and a [ 1 ] >= 2 : k = ( math . ceil ( a [ 0 ] \/ 2 ) + math . floor ( a [ 0 ] \/ 2 ) + math . ceil ( ( a [ 1 ] - 2 ) \/ 2 ) + math . floor ( ( a [ 1 ] - 2 ) \/ 2 ) ) else : k = math . ceil ( max ( a ) \/ 2 ) + math . floor ( max ( a ) \/ 2 ) if x - 1 > len ( c ) : print ( '0' ) else : print ( c [ x - 1 ] ) NEW_LINE","import itertoolsimport math   n , m = [ int ( k ) for k in input ( ) . split ( ) ] x = int ( input ( ) ) if n - 2 * ( x - 1 ) < 1 or m - 2 * ( x - 1 ) < 1 : print ( 0 ) elif n - 2 * ( x - 1 ) == 1 or m - 2 * ( x - 1 ) == 1 : print ( ( n + m - 4 * ( x - 1 ) ) \/\/ 2 ) else : print ( n + m - 2 - 4 * ( x - 1 ) )                 NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) x = int ( input ( ) ) k = 0 for i in range ( n ) : for j in range ( m ) : if not ( i + j ) % 2 : if min ( min ( i , j ) + 1 , min ( n - i , m - j ) ) == x : k += 1 print ( k ) NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) x = int ( input ( ) ) w , h = n - ( 2 * x - 1 ) , m - ( 2 * x - 1 ) if w < 0 or h < 0 : print ( 0 ) else : print ( max ( w + h , 1 ) ) NEW_LINE"],"bleu":0.13817287974302733,"rouge_l":0.351638562249273}
{"id":555,"predictions":["import sys , math , itertoolsfrom collections import Counter , deque , defaultdictfrom bisect import bisect_left , bisect_right from heapq import heappop , heappush , heapify , nlargestfrom copy import deepcopymod = 10 ** 9 + 7 INF = float ( ' inf ' ) def inp ( ) : return int ( sys . stdin . readline ( ) ) def inpl ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) def inpl_1 ( ) : return list ( map ( lambda x : int ( x ) - 1 , sys . stdin . readline ( ) . split ( ) ) ) def inps ( ) : return sys . stdin . readline ( ) def inpsl ( x ) : tmp = sys . stdin . readline ( ) ; return list ( tmp [ : x ] ) def err ( x ) : print ( x ) ; exit ( )   for _ in range ( inp ( ) ) : n = inp ( ) a = inpl ( ) res = [ INF ] * != 0 : res [ a . index ( min ( a ) ] = - INF for i in range ( n ) : if a [ i ] != i + 1 : res [ i ] = min ( res [ i ] , res [ i ] ) print ( i + 1 )   NEW_LINE"],"references":["for t in range ( int ( input ( ) ) ) : n = int ( input ( ) ) s = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) k = - 1 for i in range ( 1 , 1025 ) : temp = [ ] for j in s : temp . append ( j ^ i ) if sorted ( temp ) == s : k = i break print ( k ) NEW_LINE","from copy import deepcopyt = int ( input ( ) ) for _ in range ( t ) : n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) x = { } for i in a : if i not in x : x [ i ] = 0 x [ i ] += 1 flag1 = 0 val = - 1 for i in range ( 1 , 1025 ) : flag = 1 x1 = deepcopy ( x ) for j in range ( 0 , len ( a ) ) : temp = a [ j ] ^ i if temp not in x1 or x1 [ temp ] == 0 : flag = 0 break x1 [ temp ] -= 1 if flag == 1 : flag1 = 1 val = i break if flag1 == 1 : print ( val ) else : print ( - 1 )   NEW_LINE","t = int ( input ( ) ) while ( t > 0 ) : n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) s = set ( l ) a = max ( l ) b = 1 while ( b < a ) : b = b * 2 if ( a == b ) : b = b * 2 NEW_LINE","for t in range ( int ( input ( ) ) ) : n = int ( input ( ) ) a = set ( [ int ( i ) for i in input ( ) . split ( ) ] ) for k in range ( 1 , 1024 + 1 ) : s = set ( [ i ^ k for i in a ] ) if a == s : print ( k ) break else : print ( - 1 ) NEW_LINE"],"bleu":0.17887227551003554,"rouge_l":0.4034425742994022}
{"id":556,"predictions":["n , m = map ( int , input ( ) . split ( ) ) print ( ( n , 2 ) [ n != m ] ) NEW_LINE"],"references":["if __name__ == ' _ _ main _ _ ' :   n = int ( input ( ) ) node = [ [ ] for _ in range ( n ) ] for i in range ( n - 1 ) : node [ int ( input ( ) ) - 1 ] . append ( i + 2 ) NEW_LINE","n = int ( input ( ) ) p = [ int ( input ( ) ) - 1 for _ in range ( n - 1 ) ] leafs = list ( filter ( lambda x : not x in p , range ( n ) ) ) lp = [ x for i , x in enumerate ( p ) if i + 1 in leafs ] x = min ( lp . count ( k ) for k in p ) print ( \" Yes \" if x >= 3 else \" No \" ) NEW_LINE","n = int ( input ( ) ) d = { i : [ ] for i in range ( 1 , n + 1 ) } for i in range ( 2 , n + 1 ) : d [ int ( input ( ) ) ] . append ( i ) for i in d : if d [ i ] : temp = 0 for j in d [ i ] : if len ( d [ j ] ) == 0 : temp += 1 if temp < 3 : print ( \" No \" ) exit ( ) print ( \" Yes \" ) NEW_LINE","n = int ( input ( ) ) arr = [ 0 ] * ( n + 2 ) arri = [ False ] * ( n + 2 ) itrmap = dict ( ) mitrmap = dict ( ) NEW_LINE","n = int ( input ( ) ) tree = [ [ ] for i in range ( n + 1 ) ] for i in range ( 2 , n + 1 ) : p = int ( input ( ) ) tree [ p ] . append ( i ) NEW_LINE"],"bleu":0.13539328228978373,"rouge_l":0.4280171702162787}
{"id":557,"predictions":["for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE minA = sum ( a ) NEW_LINE minA = min ( a ) NEW_LINE maxA = max ( a ) NEW_LINE print ( minA ) NEW_LINE DEDENT"],"references":["for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT sum1 = 0 NEW_LINE n = int ( input ( ) ) NEW_LINE x = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE y = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE x1 , y1 = min ( x ) , min ( y ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT sum1 = sum1 + max ( x [ j ] - x1 , y [ j ] - y1 ) NEW_LINE DEDENT print ( sum1 ) NEW_LINE DEDENT","for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE orange = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE candy = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE minOrange = min ( orange ) NEW_LINE minCandy = min ( candy ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if orange [ i ] > minOrange or candy [ i ] > minCandy : NEW_LINE INDENT count += max ( orange [ i ] - minOrange , candy [ i ] - minCandy ) NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT","t = int ( input ( ) ) NEW_LINE while t > 0 : NEW_LINE INDENT gift_num = int ( input ( ) ) NEW_LINE a = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( a ) NEW_LINE b = map ( int , input ( ) . split ( ) ) NEW_LINE b = list ( b ) NEW_LINE min_a = min ( a ) NEW_LINE min_b = min ( b ) NEW_LINE cont = 0 NEW_LINE for i in range ( gift_num ) : NEW_LINE INDENT if a [ i ] > min_a and b [ i ] > min_b : NEW_LINE INDENT temp_a = a [ i ] - min_a NEW_LINE temp_b = b [ i ] - min_b NEW_LINE if temp_a == temp_b : NEW_LINE INDENT a [ i ] -= temp_a NEW_LINE b [ i ] -= temp_b NEW_LINE cont += temp_b NEW_LINE DEDENT elif temp_a > temp_b : NEW_LINE INDENT a [ i ] -= temp_b NEW_LINE b [ i ] -= temp_b NEW_LINE cont += temp_b NEW_LINE DEDENT elif temp_a < temp_b : NEW_LINE INDENT a [ i ] -= temp_a NEW_LINE b [ i ] -= temp_a NEW_LINE cont += temp_a NEW_LINE DEDENT DEDENT while a [ i ] > min_a or b [ i ] > min_b : NEW_LINE INDENT if a [ i ] > min_a : NEW_LINE INDENT temp = a [ i ] - min_a NEW_LINE a [ i ] -= temp NEW_LINE cont += temp NEW_LINE DEDENT elif b [ i ] > min_b : NEW_LINE INDENT temp = b [ i ] - min_b NEW_LINE b [ i ] -= temp NEW_LINE cont += temp NEW_LINE DEDENT DEDENT DEDENT print ( cont ) NEW_LINE t -= 1 NEW_LINE DEDENT","for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE b = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE ma = min ( a ) NEW_LINE mb = min ( b ) NEW_LINE moves = 0 NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT moves += max ( a [ i ] - ma , b [ i ] - mb ) NEW_LINE DEDENT print ( moves ) NEW_LINE DEDENT","for t in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE x = min ( a ) NEW_LINE b = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE y = min ( b ) NEW_LINE sm = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sm += max ( a [ i ] - x , b [ i ] - y ) NEW_LINE DEDENT print ( sm ) NEW_LINE DEDENT"],"bleu":0.39104887964576274,"rouge_l":0.6128826259100004}
{"id":558,"predictions":["a , b , c , d = map ( int , input ( ) . split ( ) ) misha = max ( 3 * a \/ 10 , a - ( a \/ 250 ) * c ) vasya = max ( 3 * b \/ 10 , b - ( b \/ 250 ) * d ) print ( vasya ) NEW_LINE"],"references":["from math import gcddef getDays ( n ) : if n % 100 == 0 and n % 400 == 0 : return 366 if n % 100 != 0 and n % 4 == 0 : return 366 return 365 y = int ( input ( ) ) v = getDays ( y ) sd = getDays ( y ) while True : y += 1 if getDays ( y ) == v and sd % 7 == 0 : print ( y ) break sd += getDays ( y )           NEW_LINE","import sys   y = int ( input ( ) ) leap = 1 if y % 400 == 0 or y % 4 == 0 and y % 100 else 0   y += 1 m = ( 366 if leap else 365 ) % 7   while 1 : l = 1 if y % 400 == 0 or y % 4 == 0 and y % 100 else 0 if m == 0 and leap == l : print ( y ) exit ( )   m = ( m + ( 366 if l else 365 ) ) % 7 y += 1 NEW_LINE","def isLeapYear ( year ) : return ( ( year % 400 ) == 0 ) or ( ( ( year % 4 ) == 0 ) and not ( ( year % 100 ) == 0 ) )       year = int ( input ( ) )   newYear = yearisLeap = isLeapYear ( year )   offset = 0 while True : NEW_LINE"],"bleu":0.0734705312597788,"rouge_l":0.2719841466435472}
{"id":559,"predictions":["import sys , os , ioimport math , bisect , operatorinf , mod = float ( ' inf ' ) , 10 ** 9 + 7 NEW_LINE"],"references":["h1 , a1 , c1 = map ( int , input ( ) . split ( ) ) h2 , a2 = map ( int , input ( ) . split ( ) ) i = 1 ans = 0 ans1 = [ ] while h2 > 0 : if i == 1 : if h1 - a2 > 0 : h2 -= a1 ans1 . append ( \" STRIKE \" ) ans += 1 elif h2 - a1 <= 0 : h2 -= a1 ans1 . append ( \" STRIKE \" ) ans += 1 else : h1 += c1 ans1 . append ( \" HEAL \" ) ans += 1 i = 0 elif i == 0 : h1 -= a2 i = 1 print ( ans ) for x in ans1 : print ( x ) NEW_LINE","import math   first_line = input ( ) . split ( ' ▁ ' ) second_line = input ( ) . split ( ' ▁ ' ) h1 = int ( first_line [ 0 ] ) a1 = int ( first_line [ 1 ] ) c1 = int ( first_line [ 2 ] ) h2 = int ( second_line [ 0 ] ) a2 = int ( second_line [ 1 ] ) strike_num = math . ceil ( h2 \/ a1 ) heal_num = math . ceil ( max ( 0 , ( ( strike_num - 1 ) * a2 - h1 + 1 ) ) \/ ( c1 - a2 ) ) print ( strike_num + heal_num ) print ( ' HEAL \\n ' * heal_num , end = ' ' ) print ( \" STRIKE \\n \" * strike_num , end = ' ' )   NEW_LINE","if __name__ == ' _ _ main _ _ ' : h1 , a1 , c1 = map ( int , input ( ) . split ( ) ) h2 , a2 = map ( int , input ( ) . split ( ) ) action = [ ] while h2 > 0 : if h2 - a1 <= 0 : h2 -= a1 action . append ( ' STRIKE ' ) elif h1 - a2 <= 0 : h1 += c1 action . append ( ' HEAL ' ) else : h2 -= a1 action . append ( ' STRIKE ' ) h1 -= a2   print ( len ( action ) ) for idx , item in enumerate ( action ) : print ( item )   NEW_LINE","h1 , a1 , c1 = map ( int , input ( ) . split ( ) ) h2 , a2 = map ( int , input ( ) . split ( ) ) res = [ ] while h2 > 0 : if h1 > a2 or h2 <= a1 : res . append ( \" STRIKE \" ) h2 -= a1 h1 -= a2 else : res . append ( \" HEAL \" ) h1 += c1 h1 -= a2print ( len ( res ) ) print ( * res , sep = \" \\n \" ) NEW_LINE","import mathimport collections def solve ( h1 , a1 , c1 , h2 , a2 ) : cnt = 0 moves = [ ] while ( h2 > 0 ) : if h2 - a1 <= 0 : moves . append ( \" STRIKE \" ) h2 -= a1 else : if h1 - a2 <= 0 : moves . append ( \" HEAL \" ) h1 += c1 else : moves . append ( \" STRIKE \" ) h2 -= a1 h1 -= a2 cnt += 1 return str ( cnt ) + \" \\n \" + \" \\n \" . join ( moves )       h1 , a1 , c1 = [ int ( s ) for s in input ( ) . split ( ) ] h2 , a2 = [ int ( s ) for s in input ( ) . split ( ) ] result = solve ( h1 , a1 , c1 , h2 , a2 ) print ( result ) NEW_LINE"],"bleu":0.006656530435905825,"rouge_l":0.14654654654654656}
{"id":560,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a , b , c , d = 0 , 0 for i in range ( 1 , n + 1 ) : if ( i * i ) % m == 0 and ( a * i ) < ( b * i ) : c += 1 print ( c , d , n * i ) NEW_LINE"],"references":["a , b , m = map ( int , input ( ) . split ( ) ) c = ( 10 ** 9 ) % mans = - 1 for x in range ( 1 , min ( a + 1 , m ) ) : z = ( x * c ) % m if z == 0 : continue if z + b < m : ans = x breakif ans == - 1 : print ( 2 ) else : s = str ( ans ) s = ( '0' * 9 + s ) [ - 9 : ] print ( 1 , s ) NEW_LINE","a , b , m = map ( int , input ( ) . split ( ) ) k = s = 10 ** 9 % mi = 0 while k and i < a : i += 1 if k < m - b : exit ( print ( 1 , str ( i ) . zfill ( 9 ) ) ) k += s if k >= m : k -= mprint ( 2 ) NEW_LINE","import sysfrom math import *   def minp ( ) : return sys . stdin . readline ( ) . strip ( )   def mint ( ) : return int ( minp ( ) )   def mints ( ) : return map ( int , minp ( ) . split ( ) )   a , b , mod = mints ( ) z = ( 10 ** 9 ) % modc = 0 for i in range ( min ( a + 1 , mod ) ) : if c != 0 and mod - c > b : s = str ( i ) s = '0' * ( 9 - len ( s ) ) + s print ( 1 , s ) exit ( 0 ) c += z if c >= mod : c -= modprint ( 2 ) NEW_LINE","a , b , m = map ( int , input ( ) . split ( ) ) k = s = 10 ** 9 % mi = 0 while k and i < a : i += 1 if k < m - b : exit ( print ( 1 , str ( i ) . zfill ( 9 ) ) ) k += s if k >= m : k -= mprint ( 2 ) NEW_LINE","a , b , m = map ( int , input ( ) . split ( ) ) k = s = ( 10 ** 9 ) % mi = 0 while k and i < a : i += 1 if k < m - b : exit ( print ( 1 , str ( i ) . zfill ( 9 ) ) ) k += s if k >= m : k -= mprint ( 2 ) NEW_LINE"],"bleu":0.45701766522050224,"rouge_l":0.4655698778833107}
{"id":561,"predictions":["t = int ( input ( ) ) for i in range ( t ) : n = int ( input ( ) ) s = input ( ) k = 1 while k < n : s = s [ k : n ] + s [ k : n ] k += 1 print ( n ) NEW_LINE"],"references":["for i in range ( int ( input ( ) ) ) : n = int ( input ( ) ) l1 = list ( map ( int , input ( ) . split ( ) ) ) l2 = l1 . copy ( ) l2 = l2 [ : : - 1 ] c = 0 for i in range ( n ) : if ( l1 . count ( l1 [ i ] ) > 1 ) : index = n - l2 . index ( l1 [ i ] ) - 1 if ( index != i + 1 and index != i ) : c = 1 if ( c == 1 ) : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE","for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) flag = False for i in range ( 0 , n - 1 ) : for j in range ( i + 1 , n ) : if ( l [ i ] == l [ j ] and abs ( j - i ) > 1 ) : flag = True break if ( flag == True ) : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE","for i in range ( int ( input ( ) ) ) : n = int ( input ( ) ) ok = False arr = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) : for j in range ( i + 2 , n ) : if ( arr [ i ] == arr [ j ] ) : ok = True if ( ok ) : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.22293034083209845,"rouge_l":0.3830283458916397}
{"id":562,"predictions":["a , b = map ( int , input ( ) . split ( ) ) d = { } for i in range ( a ) : f = list ( input ( ) . split ( ) ) if int ( f [ 1 ] ) in d : d [ int ( f [ 1 ] ) ] . append ( ( int ( f [ 2 ] ) , f [ 0 ] ) ) else : d [ int ( f [ 1 ] ) ] = [ ( int ( f [ 2 ] ) , f [ 1 ] ) ] for i in d : d [ i ] . sort ( ) d [ i ] . reverse ( ) for i in range ( 1 , b + 1 ) : print ( ' ? ' , i ) NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) s = [ list ( input ( ) ) for i in range ( n ) ] cnt = [ [ 0 ] * ( m + 1 ) for i in range ( n + 1 ) ] for i in range ( n ) : for j in range ( m ) : if s [ i ] [ j ] == \"1\" : cnt [ i + 1 ] [ j + 1 ] += 1 for i in range ( n ) : for j in range ( m + 1 ) : cnt [ i + 1 ] [ j ] += cnt [ i ] [ j ] for i in range ( n + 1 ) : for j in range ( m ) : cnt [ i ] [ j + 1 ] += cnt [ i ] [ j ] ans = 0 for l in range ( m + 1 ) : for r in range ( l + 1 , m + 1 ) : for u in range ( n + 1 ) : for d in range ( u + 1 , n + 1 ) : c = cnt [ d ] [ r ] - cnt [ d ] [ l ] - cnt [ u ] [ r ] + cnt [ u ] [ l ] if c == 0 : ans = max ( ans , ( r - l ) * 2 + ( d - u ) * 2 ) print ( ans ) NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) mat = [ ] for i in range ( n ) : mat . append ( input ( ) ) dp = [ [ [ [ True for i in range ( m ) ] for i in range ( n ) ] for i in range ( m ) ] for i in range ( n ) ] ans = 0 for x1 in range ( n ) : for y1 in range ( m ) : for x2 in range ( x1 , n ) : for y2 in range ( y1 , m ) : dp [ x1 ] [ y1 ] [ x2 ] [ y2 ] = dp [ x1 ] [ y1 ] [ x2 - 1 ] [ y2 ] and dp [ x1 ] [ y1 ] [ x2 ] [ y2 - 1 ] and mat [ x2 ] [ y2 ] == '0' if dp [ x1 ] [ y1 ] [ x2 ] [ y2 ] : ans = max ( ans , 2 * ( x2 - x1 + y2 - y1 + 2 ) ) print ( ans ) NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) s = [ [ 0 ] + list ( map ( int , input ( ) ) ) for i in range ( n ) ] for i in range ( n ) : for j in range ( m ) : s [ i ] [ j + 1 ] += s [ i ] [ j ] d = 1 for i in range ( 0 , m ) : for j in range ( i + 1 , m + 1 ) : t = [ - 1 ] + [ k for k in range ( n ) if s [ k ] [ j ] - s [ k ] [ i ] ] + [ n ] p = max ( t [ i + 1 ] - t [ i ] for i in range ( len ( t ) - 1 ) ) if p > 1 : p += j - i if p > d : d = pprint ( 2 * ( d - 1 ) ) NEW_LINE","def func ( a , b ) : for i in range ( min ( a [ 0 ] , b [ 0 ] ) , max ( a [ 0 ] , b [ 0 ] ) + 1 ) :   for j in range ( min ( a [ 1 ] , b [ 1 ] ) , max ( a [ 1 ] , b [ 1 ] ) + 1 ) :   if matx [ i ] [ j ] == 1 : return False return Truen , m = map ( int , input ( ) . split ( ) ) x = [ ]   matx = [ [ int ( X ) for X in list ( input ( ) . strip ( ) ) ] for i in range ( n ) ]           for i in range ( n ) : for j in range ( m ) :   x . append ( ( i , j ) ) an = - 1 for i in range ( len ( x ) ) : for j in range ( len ( x ) ) : if func ( x [ i ] , x [ j ] ) : an = max ( an , 2 * abs ( x [ i ] [ 0 ] - x [ j ] [ 0 ] + 1 ) + 2 * abs ( x [ i ] [ 1 ] - x [ j ] [ 1 ] + 1 ) ) print ( an ) NEW_LINE"],"bleu":0.29298838870946387,"rouge_l":0.39011627906976754}
{"id":563,"predictions":["for i in range ( int ( input ( ) ) ) : n = int ( input ( ) ) print ( n * ( n + 1 ) \/\/ 2 - ( 2 * sum ( 2 ** i for i in range ( n ) ) ) ) NEW_LINE"],"references":["import matht = int ( input ( ) ) for _ in range ( t ) : n , k = map ( int , input ( ) . split ( ) ) num = - 1 for i in range ( 2 , math . ceil ( math . sqrt ( n ) ) + 1 ) : if ( n % i == 0 ) : num = i break k -= 1 if ( num == - 1 ) : num = n NEW_LINE","for _ in range ( int ( input ( ) ) ) : n = [ int ( i ) for i in input ( ) . split ( ) ] a = n [ 0 ] b = n [ 1 ] c = 0 if a % 2 == 0 : print ( a + b * 2 ) continue for e in range ( 3 , a + 1 , 2 ) : if e * e <= a : if a % e == 0 : print ( a + e + ( ( b - 1 ) * 2 ) ) break else : print ( a * 2 + ( ( b - 1 ) * 2 ) ) break NEW_LINE","import math   cases = int ( input ( ) ) while cases : cases -= 1 a , b = map ( int , input ( ) . split ( ) )   if a % 2 == 0 : print ( a + b * 2 ) else : for i in range ( 3 , a + 1 ) : if a % i == 0 : a += i break print ( a + ( b - 1 ) * 2 )   NEW_LINE","for t in range ( int ( input ( ) ) ) : n , k = map ( int , input ( ) . split ( ) ) if n % 2 == 0 : print ( n + k * 2 ) else : for i in range ( 2 , n + 1 ) : if n % i == 0 : print ( n + i + ( k - 1 ) * 2 ) ; break NEW_LINE","from sys import stdin , stdoutdef factor ( x ) : for i in range ( 2 , x + 1 ) : if x % i == 0 : return idef main ( ) : for _ in range ( int ( stdin . readline ( ) ) ) : n , k = map ( int , stdin . readline ( ) . split ( ' ▁ ' ) ) while k > 0 : if n % 2 == 0 : stdout . write ( str ( n + 2 * k ) + ' \\n ' ) break n += factor ( n ) k -= 1 else : stdout . write ( str ( n ) + ' \\n ' )   if __name__ == \" _ _ main _ _ \" : main ( ) NEW_LINE"],"bleu":0.3100528153751995,"rouge_l":0.5064175210183696}
{"id":564,"predictions":["import mathn = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) mx = - 10000000 for num in range ( 1 , n ) : k = math . ceil ( num \/ 2 ) if k >= num : mx = max ( mx , num ) print ( mx ) NEW_LINE"],"references":["import mathn , h = [ int ( x ) for x in input ( ) . split ( ' ▁ ' ) ] for i in range ( n - 1 ) : print ( math . sqrt ( ( i + 1 ) \/ ( n ) ) * h , end = \" ▁ \" ) print ( ) NEW_LINE","from math import sqrtn , h = map ( int , input ( ) . split ( ) ) result = [ ] for i in range ( 1 , n ) : result . append ( h * sqrt ( i \/ n ) ) print ( * result ) NEW_LINE","n , h = map ( int , input ( ) . split ( ) ) ; print ( * [ h * ( i \/ n ) ** .5 for i in range ( 1 , n ) ] ) NEW_LINE","from math import sqrtn , h = map ( int , input ( ) . split ( ) ) for i in range ( 1 , n ) : print ( ' { : . 12f } ' . format ( h * sqrt ( i \/ n ) ) , end = ' ▁ ' ) NEW_LINE","import mathimport sys   n , h = map ( int , input ( ) . split ( ) )   for i in range ( 1 , n ) : new_h = ( h * h * i \/ n ) ** 0.5 print ( \" % .12f \" % ( new_h ) )   NEW_LINE"],"bleu":0.34930376097043975,"rouge_l":0.5635498320268757}
{"id":565,"predictions":["import sysdef get_ints ( ) : return map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) def get_ints_lists ( ) : return list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) def get_string ( ) : return sys . stdin . readline ( ) . strip ( ) def get_string ( ) : return sys . stdin . readline ( ) . strip ( ) def get_ints ( ) : return list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) def get_string ( ) : return sys . stdin . readline ( ) . strip ( ) def input ( ) : return list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) def get_string ( ) : return list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) def get_string ( ) : return input ( ) NEW_LINE def main ( ) : NEW_LINE"],"references":["a , b = map ( int , input ( ) . split ( ) ) s = ' # ' t = ' . ' flag = 0 for i in range ( a ) : if i % 2 == 0 : print ( s * b ) else : if flag == 0 : print ( t * ( b - 1 ) + s ) flag = 1 elif flag == 1 : print ( s + t * ( b - 1 ) ) flag = 0 NEW_LINE","a , b = map ( int , input ( ) . split ( ) ) od = \" \" evf = \" \" evl = \" \" sw = Truefor i in range ( b ) : od += \" # \" if i == b - 1 : evl += \" # \" else : evl += \" . \" if i == 0 : evf += \" # \" else : evf += \" . \" for i in range ( a ) : if i % 2 == 0 : print ( od ) else : if sw : print ( evl ) sw = False else : print ( evf ) sw = True NEW_LINE","a , b = map ( int , input ( ) . split ( ) ) k = 0 for i in range ( 1 , a + 1 ) : if ( i % 2 != 0 ) : print ( ' # ' * b ) else : if ( k == 1 ) : print ( ' # ' + ( ' . ' * ( b - 1 ) ) ) k = 0 elif ( k == 0 ) : print ( ' . ' * ( b - 1 ) + ' # ' ) k = 1 NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) for i in range ( 1 , n + 1 ) : if i % 2 == 1 : print ( \" # \" * m ) elif i % 4 == 0 : print ( ' # ' + ' . ' * ( m - 1 ) ) else : print ( ' . ' * ( m - 1 ) + ' # ' ) NEW_LINE"],"bleu":0.07202585219066462,"rouge_l":0.2702104097452934}
{"id":566,"predictions":["import sys , os , ioimport math , bisect , operatorinf , mod = float ( ' inf ' ) , 10 ** 9 + 7 NEW_LINE"],"references":["a00 , a01 , a10 , a11 = list ( map ( int , input ( ) . split ( ) ) ) if sum ( [ a00 , a01 , a10 , a11 ] ) == 0 : print ( 0 ) exit ( 0 ) z , j = 0 , 0 if a01 != 0 or a10 != 0 : z = j = 1 while z * ( z - 1 ) \/\/ 2 < a00 : z += 1 while j * ( j - 1 ) \/\/ 2 < a11 : j += 1 if any ( [ z * ( z - 1 ) \/\/ 2 != a00 , j * ( j - 1 ) \/\/ 2 != a11 , z * j != a10 + a01 ] ) : print ( ' Impossible ' ) exit ( 0 ) n = z + jfor i in range ( n ) : if z > 0 and a01 >= j : print ( '0' , end = ' ' ) a01 -= j z -= 1 else : print ( '1' , end = ' ' ) j -= 1 NEW_LINE","def main ( ) : from itertools import product def f ( a ) : x = int ( ( a * 2. + .25 ) ** .5 + .51 ) if x * ( x - 1 ) != a * 2 : raise ValueError return ( x , ) if a else ( 1 , 0 )   a00 , a01 , a10 , a11 = map ( int , input ( ) . split ( ) ) try : for b , w in product ( f ( a00 ) , f ( a11 ) ) : if b * w == a01 + a10 : break else : raise ValueError except ValueError : print ( \" Impossible \" ) else : a01 , rest = divmod ( a01 , w ) if w else ( b , 0 ) if rest : l = [ '0' * a01 , '1' * ( w - rest ) , '0' , '1' * rest , '0' * ( b - a01 - 1 ) ] else : l = [ '0' * a01 , '1' * w , '0' * ( b - a01 ) ] print ( ' ' . join ( l ) )     if __name__ == ' _ _ main _ _ ' : main ( ) NEW_LINE","def build ( a0 , a1 , a01 , a10 , arr ) : NEW_LINE"],"bleu":0.10682827247639556,"rouge_l":0.41709401709401706}
{"id":567,"predictions":["from sys import stdin , stdoutfrom collections import defaultdict , dequenmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) def bfs ( ) : global ans q = deque ( ) p [ 1 ] = - 1 q . append ( 1 ) while q : src = q . popleft ( ) if p [ src ] != - 1 and p [ p [ src ] ] != - 1 : dp [ p [ src ] ] = dp [ p [ src ] ] ] if dp [ p [ src ] ] != - 1 : dp [ p [ src ] ] ^= 1 print ( max ( dp [ src ] , end = \" ▁ \" ) for _ in range ( 1 ) : NEW_LINE"],"references":["d = { ' polycarp ' : 1 } for _ in range ( int ( input ( ) ) ) : a , b , c = input ( ) . lower ( ) . split ( ) ; d [ a ] = d [ c ] + 1 print ( max ( d . values ( ) ) ) NEW_LINE","n = int ( input ( ) ) from collections import defaultdictax = dict ( ) ax [ ' polycarp ' ] = 1 ans = 1 for i in range ( n ) : a , b , c = map ( str , input ( ) . split ( ) ) a = a . lower ( ) c = c . lower ( ) ax [ a ] = ax [ c ] + 1 NEW_LINE","n = int ( input ( ) ) g = { } for _ in range ( n ) : s = input ( ) . split ( ' reposted ' ) s1 = s [ 0 ] . strip ( ) . lower ( ) s2 = s [ 1 ] . strip ( ) . lower ( ) NEW_LINE"],"bleu":0.143218021481218,"rouge_l":0.32261554179938695}
{"id":568,"predictions":["def STR ( ) : return list ( input ( ) ) def INT ( ) : return int ( input ( ) ) def MAP ( ) : return map ( int , input ( ) . split ( ) ) def MAP2 ( ) : return map ( float , input ( ) . split ( ) ) def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) def STRING ( ) : return input ( ) import stringimport sysfrom heapq import heappop , heappushfrom bisect import * from collections import deque , Counter , defaultdictfrom math import * from itertools import permutations , accumulatedx = [ - 1 , 1 , 0 , 0 ] dy = [ 0 , 0 , 1 , - 1 ] NEW_LINE"],"references":["from collections import defaultdictfor _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) count = 0 l = [ ] for i in range ( n ) : l . append ( input ( ) . strip ( ) ) res = [ ] count = 0 for i in l : if i not in res : res . append ( i ) else : for j in range ( 10 ) : x = str ( j ) + i [ 1 : ] if x not in res and x not in l : count += 1 res . append ( x ) break print ( count ) for i in res : print ( i ) NEW_LINE","from collections import Counter   t = int ( input ( ) ) ans = [ ]   for _ in range ( t ) : n = int ( input ( ) ) pins = [ input ( ) for _ in range ( n ) ] counter = Counter ( pins )   arr = [ ] ch = 0 for p in pins : counter [ p ] -= 1 if counter [ p ] == 0 : arr . append ( p ) continue ch += 1 pin = list ( map ( int , p ) ) while \" \" . join ( map ( str , pin ) ) in counter : pin [ 0 ] += 1 pin [ 0 ] %= 10 val = \" \" . join ( map ( str , pin ) ) arr . append ( val ) counter [ val ] = 1 ans . append ( ( ch , arr ) )   for ch , arr in ans : print ( ch ) for pin in arr : print ( pin ) NEW_LINE","for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) a = [ ] change = 0 d = [ int ( x ) for x in '0123456789' ] for i in range ( n ) : inp = ( input ( ) ) a . append ( inp ) if int ( inp [ 3 ] ) in d : d . remove ( int ( inp [ 3 ] ) ) for i in range ( n - 1 ) : for j in range ( i + 1 , n ) : if a [ i ] == a [ j ] : s = a [ j ] [ : 3 ] + str ( d [ 0 ] ) NEW_LINE","for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) d = { } l = [ ] for i in range ( n ) : a = input ( ) l . append ( a ) if a in d . keys ( ) : d [ a ] += 1 else : d . setdefault ( a , 1 ) ans = 0 d1 = d . copy ( ) final_ans = [ ] for i in range ( n - 1 , - 1 , - 1 ) : j = d [ l [ i ] ] if j == 1 : final_ans . append ( l [ i ] ) else : ans += 1 d [ l [ i ] ] -= 1 for z in range ( 4 ) : f = 0 for y in range ( 10 ) : temp = l [ i ] [ : z ] + str ( y ) + l [ i ] [ z + 1 : ] if temp not in d1 . keys ( ) : d1 . setdefault ( temp , 1 ) final_ans . append ( temp ) f = 1 break if f == 1 : break print ( ans ) for i in final_ans [ : : - 1 ] : print ( i ) NEW_LINE"],"bleu":0.2322284189048296,"rouge_l":0.3615550409281636}
{"id":569,"predictions":["def main ( ) : n , m = map ( int , input ( ) . split ( ) ) NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) cur_pos = 0 for i in range ( n ) : a , b = map ( int , input ( ) . split ( ) ) if ( a <= cur_pos ) : if ( b > cur_pos ) : cur_pos = bif ( cur_pos == m ) : print ( ' YES ' ) else : print ( ' NO ' ) NEW_LINE","import sys , collections   n , m = map ( int , sys . stdin . readline ( ) . split ( ) ) arr = [ ] for _ in range ( n ) : a , b = map ( int , sys . stdin . readline ( ) . split ( ) ) arr . append ( ( a , b ) ) q = collections . deque ( ) check = [ False ] * 101 check [ 0 ] = Trueq . append ( 0 ) while q : x = q . popleft ( ) for i in range ( n ) : if arr [ i ] [ 0 ] == x : for j in range ( arr [ i ] [ 0 ] , arr [ i ] [ 1 ] + 1 ) : if not check [ j ] and j <= 100 : check [ j ] = True q . append ( j )   print ( ' YES ' if check [ m ] else ' NO ' )       NEW_LINE","n , m = list ( map ( int , input ( ) . split ( ) ) )     def canuseteleport ( curr_pos , tele_start , tele_limit ) : if tele_start <= curr_pos and tele_limit > curr_pos : return True return False     p = 0 for i in range ( n ) : x , y = list ( map ( int , input ( ) . split ( ) ) ) if canuseteleport ( p , x , y ) : p = y   if m <= p : print ( \" Yes \" ) else : print ( \" No \" )   NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) mx = 0 ch = 1 curr = 0 while n : n -= 1 a , b = map ( int , input ( ) . split ( ) ) if curr < a and mx < a : ch = 0 if ch == 1 : if b > mx : mx = b   curr = b if curr >= m or mx >= m : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) r = 0 for i in range ( n ) : a , b = map ( int , input ( ) . split ( ) ) if a <= r and b > r : r = bif r >= m : print ( ' YES ' ) else : print ( ' NO ' ) NEW_LINE"],"bleu":0.07639304321353228,"rouge_l":0.3475783475783476}
{"id":570,"predictions":["n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) s = sum ( l ) if s % n == 0 : print ( \" NO \" ) else : print ( \" YES \" ) NEW_LINE"],"references":["num = int ( input ( ) ) a = [ i for i in range ( 45 ) ] s = 1 idx = 1 while True : idx += 1 if ( s + idx > num ) : n = idx - 1 break   s += idx   left = num - s   a [ n ] += leftprint ( n ) for i in range ( 1 , n + 1 ) : print ( a [ i ] , end = \" ▁ \" ) print ( ) NEW_LINE","n = int ( input ( ) ) k = 0 if n == 2 : print ( 1 ) print ( 2 ) exit ( ) if n == 1 : print ( 1 ) print ( 1 ) exit ( ) for i in range ( 1 , n ) : k += i if k == n : print ( i ) for i in range ( 1 , i + 1 ) : print ( i , end = ' ▁ ' ) exit ( ) if k > n : k -= i + i - 1 breakprint ( i - 1 ) for i in range ( 1 , i - 1 ) : print ( i , end = ' ▁ ' ) print ( n - k ) NEW_LINE","n = int ( input ( ) ) cnt = 0 l = [ ] k = 1 while cnt + k <= n : l . append ( k ) cnt += k k += 1 l [ - 1 ] += n - cntprint ( k - 1 ) print ( * l ) NEW_LINE","n = int ( input ( ) ) i = 1 a = [ ] while n >= i : a . append ( i ) n -= i i += 1 if n > 0 : a [ - 1 ] += nprint ( len ( a ) ) print ( * a ) NEW_LINE"],"bleu":0.2720816343995229,"rouge_l":0.4491799620662724}
{"id":571,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["a , b = map ( int , input ( ) . split ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) a = a % 2 ans = 0 i = 1 for n in arr : x = n * a ** ( b - i ) ans += x i += 1     if ans % 2 == 1 : print ( \" odd \" ) else : print ( \" even \" ) NEW_LINE","def array ( a , b , k ) : bs = b % 2 == 0 suma = [ ] for i in range ( len ( a ) - 1 ) : suma . append ( a [ i ] % 2 == 0 or bs ) suma . append ( a [ - 1 ] % 2 == 0 ) cuenta = suma . count ( False ) if cuenta % 2 != 0 : print ( \" odd \" ) else : print ( \" even \" ) def prueba ( ) : b , k = [ int ( i ) for i in input ( ) . split ( \" ▁ \" ) ] listanueva = [ int ( i ) for i in input ( ) . split ( \" ▁ \" ) ] array ( listanueva , b , k ) prueba ( )   NEW_LINE","a , b = map ( int , input ( ) . split ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) a = a % 2 ans = 0 i = 1 for n in arr : x = n * a ** ( b - i ) ans += x i += 1     if ans % 2 == 1 : print ( \" odd \" ) else : print ( \" even \" ) NEW_LINE"],"bleu":0.15684998363039337,"rouge_l":0.4144960362400906}
{"id":572,"predictions":["nmk = input ( ) . split ( )   n = int ( nmk [ 0 ] ) NEW_LINE"],"references":["lis = list ( map ( int , input ( ) . split ( ) ) ) sumall = 0 dic = { }   modulo = 1073741824 def number_of_divisors ( a ) : if a in dic : return dic [ a ] res , i , t = 1 , 2 , a while i * i <= a : r = 1 while a % i == 0 : a \/= i r += 1 res = ( res * r ) % modulo i += 1 if a > 1 : res = ( res * 2 ) % modulo dic [ t ] = res return res     for i in range ( 1 , lis [ 0 ] + 1 ) : for j in range ( 1 , lis [ 1 ] + 1 ) : for k in range ( 1 , lis [ 2 ] + 1 ) : s = ( i , j , k ) sumall += number_of_divisors ( i * j * k ) print ( sumall % modulo ) NEW_LINE","from functools import lru_cachefrom math import sqrt , ceil @ lru_cache ( None ) def countDevisor ( n ) : count = 0 for i in range ( int ( sqrt ( n ) ) ) : if n % ( i + 1 ) == 0 : if n \/ ( i + 1 ) == ( i + 1 ) : count += 1 else : count += 2 return ( count )     a , b , c = list ( map ( int , input ( ) . split ( ) ) ) modulo = 2 ** 30 ans = 0 for i in range ( 1 , a + 1 ) : for j in range ( 1 , b + 1 ) : for k in range ( 1 , c + 1 ) : ans += countDevisor ( i * j * k ) NEW_LINE","import math   prime = [ 2 , 3 , 5 , 7 , 11 ] ; d = { }   def GeneratePrimes ( ) : for i in range ( 12 , 1010 ) : for j in prime : if i % j == 0 : break if j * j > i : prime . append ( i ) break else : prime . append ( i ) NEW_LINE","a , b , c = map ( int , input ( ) . split ( ) ) m = [ 2 ] * ( a * b * c + 1 ) m [ 1 ] = 1 for i in range ( 2 , len ( m ) ) : for j in range ( 2 * i , len ( m ) , i ) : m [ j ] += 1 ans = 0 for i in range ( 1 , a + 1 ) : for j in range ( 1 , b + 1 ) : for l in range ( 1 , c + 1 ) : ans = ( ans + m [ i * j * l ] ) % 1073741824 print ( ans ) NEW_LINE","a , b , c = map ( int , input ( ) . split ( ) )   divs = [ 1 ] * 1000001 mod = 1073741824   for i in range ( 2 , 1000001 ) : for j in range ( i , 1000001 , i ) : divs [ j ] += 1   ans = 0 for i in range ( 1 , a + 1 ) : for j in range ( 1 , b + 1 ) : for k in range ( 1 , c + 1 ) : ans += ( divs [ i * j * k ] ) % mod   print ( ans % ( mod * 2 ** 30 ) ) NEW_LINE"],"bleu":0.032708359987682546,"rouge_l":0.1938046068308181}
{"id":573,"predictions":["a , b , r = map ( int , input ( ) . split ( ) ) if ( 2 * r > min ( a , b ) ) : print ( \" Second \" ) else : print ( \" First \" ) NEW_LINE"],"references":["import sysinput = sys . stdin . readlinefrom collections import defaultdict as dcfrom collections import Counterfrom bisect import bisect_right , bisect_leftimport mathfrom operator import itemgetterfrom heapq import heapify , heappop , heappushfrom queue import PriorityQueue as pqn = int ( input ( ) ) s = input ( ) [ : - 1 ] if int ( s , 2 ) == 0 : print ( s ) else : c = 0 for i in s : if i == '0' : c += 1 l = [ '1' ] + [ '0' ] * c print ( ' ' . join ( l ) ) NEW_LINE","n = int ( input ( ) ) s = input ( ) print ( '1' + s . count ( '0' ) * '0' if not s == '0' else s ) NEW_LINE","n = int ( input ( ) ) s = input ( ) y = s . count ( '0' ) if n == 1 : print ( s ) else : print ( '1' + y * '0' )   NEW_LINE","n = int ( input ( ) ) s = input ( )     a = s . count ( \"1\" ) b = s . count ( \"0\" ) if a : print ( \"1\" , end = \" \" ) for i in range ( b ) : print ( \"0\" , end = \" \" ) NEW_LINE","n = int ( input ( ) ) s = input ( ) d = { } for i in s : if ( i in d ) : d [ i ] += 1 else : d [ i ] = 1 if ( len ( d ) == 2 ) : s1 = '1' * 1 + '0' * d [ '0' ] print ( s1 ) else : if ( '0' in d ) : print ( '0' * d [ '0' ] ) else : print ( '1' ) NEW_LINE"],"bleu":0.2766633702235513,"rouge_l":0.48191268191268194}
{"id":574,"predictions":["s = input ( ) start = 1 if s [ 0 ] == \" - \" else 0 answer = \" \"   float_start = 0 try : float_start = s . index ( \" . \" ) except : float_start = len ( s )   if float_start == len ( s ) : answer += \"00 . \" else : answer += s [ float_start + 1 : float_start + 3 ] [ : : - 1 ] + \" . \"   if float_start + 3 >= len ( s ) : answer = \"0\" + answer [ 0 ] + \" . \"   current = 0 for i in range ( float_start - 1 , start - 1 , - 1 ) : current += 1 answer += s [ i ] if current == 3 and i != start : answer += \" , \" current = 0 answer += \" $ \"   if start == 1 : print ( f \" ( { answer [ : : -1 ] } ) \" ) else : print ( answer [ : - 1 ] ) NEW_LINE"],"references":["n , k = map ( int , input ( ) . split ( ) )     def printDivisors ( n ) : l = [ ] i = 1 while ( i * i < n ) : if ( n % i == 0 ) : l . append ( i ) if ( len ( l ) >= k ) : break i += 1   for i in range ( int ( n ** 0.5 ) , 0 , - 1 ) : if ( n % i == 0 ) : l . append ( n \/\/ i ) if ( len ( l ) >= k ) : break return l     res = printDivisors ( n ) if len ( res ) >= k : print ( res [ k - 1 ] ) else : print ( - 1 ) NEW_LINE","    n , k = map ( int , input ( ) . split ( ) )         t = [ ] p = 0 h = 0 for j in range ( 1 , int ( n ** ( 0.5 ) ) + 1 ) :   if n % j == 0 : if j != n \/\/ j : t . append ( n \/\/ j ) p += 1 if p == k : print ( j ) h += 1 break       if h == 0 : p -= k   if abs ( p ) > len ( t ) : print ( - 1 ) else : print ( t [ p ] ) NEW_LINE"],"bleu":0.13112806636795646,"rouge_l":0.3210716798182789}
{"id":575,"predictions":["n = int ( input ( ) ) if n % 2 == 0 : print ( 0 ) elif n % 2 == 0 : print ( n \/\/ 2 ) else : print ( n \/\/ 2 ) NEW_LINE"],"references":["a = input ( ) b = input ( )   f = True   for i , j in zip ( a , b ) : if j > i : f = False break   if f : print ( b )   else : print ( - 1 ) NEW_LINE","x = input ( ) y = input ( ) a = ' ' for i in range ( len ( x ) ) : if ( y [ i ] < x [ i ] ) : a += y [ i ] elif ( y [ i ] == x [ i ] ) : a += ' z ' else : a = ' - 1' breakprint ( a ) NEW_LINE","a = input ( ) b = input ( ) l = len ( a ) NEW_LINE","try : x = input ( ) z = input ( ) y = \" \" v = True for i in range ( len ( x ) ) : if ascii ( x [ i ] ) < ascii ( z [ i ] ) : print ( - 1 ) v = False break else : y = y + z [ i ] if v : print ( y ) except : pass NEW_LINE"],"bleu":0.2029125086630004,"rouge_l":0.5002157962883039}
{"id":576,"predictions":["t = int ( input ( ) ) for i in range ( t ) : n = int ( input ( ) ) kol = [ ] f , g = map ( int , input ( ) . split ( ) ) kol . append ( [ f , g ] ) flag = 0 if g > f : print ( ' NO ' ) flag = 1 for i in range ( n - 1 ) : p , c = map ( int , input ( ) . split ( ) ) kol . append ( [ p , c ] )   if ( c > p or kol [ i ] [ 0 ] > p or kol [ i ] [ 1 ] > p or p - kol [ i ] [ 0 ] < c - kol [ i ] [ 1 ] ) and flag == 0 : print ( ' NO ' ) flag = 1 if flag == 0 : print ( ' YES ' ) NEW_LINE"],"references":["def xuli ( ) : n = int ( input ( ) ) s = input ( ) dem1 = 0 dem2 = 0 for i in s : if i != '0' : break dem1 += 1 for i in reversed ( s ) : if i != '1' : break dem2 += 1 for i in range ( dem1 + ( dem1 + dem2 < n ) ) : print ( 0 , end = ' ' ) for i in range ( dem2 ) : print ( 1 , end = ' ' ) print ( ' ' )       t = int ( input ( ) ) while ( t > 0 ) : xuli ( ) t -= 1 NEW_LINE","def solve ( ) : n = int ( input ( ) ) s = input ( ) first_one_idx , last_zero_idx = - 1 , - 1 for i in range ( n ) : if s [ i ] == '1' : first_one_idx = i break for i in reversed ( range ( n ) ) : if s [ i ] == '0' : last_zero_idx = i break if first_one_idx < last_zero_idx and first_one_idx != - 1 and last_zero_idx != - 1 : ans = s [ 0 : first_one_idx ] + '0' + s [ last_zero_idx + 1 : ] else : ans = s print ( ans )   t = int ( input ( ) ) for _ in range ( t ) : solve ( ) NEW_LINE","for s in [ * open ( 0 ) ] [ 2 : : 2 ] : i = s . find ( '1' ) % len ( s ) ; j = s . rfind ( '0' ) ; print ( s [ : i ] + '0' * ( j > i ) + s [ j + 1 : ] ) NEW_LINE","def answer ( n , s ) : f1 = s . find ( '1' ) if f1 == - 1 : return s NEW_LINE","def solve ( ) : m = 0 n , x = [ int ( j ) for j in input ( ) . split ( ) ] a = [ int ( мурк ) for мурк in input ( ) . split ( ) ] b = [ int ( k ) for k in input ( ) . split ( ) ] b . reverse ( ) for j in range ( n ) : if a [ j ] + b [ j ] <= x : m = m + 1 else : m = - 9999999999999999999 if m > 0 : print ( \" YES \" ) else : print ( \" NO \" ) def cmp ( key ) : return key [ 0 ] from math import floor , ceil NEW_LINE"],"bleu":0.3248766054031708,"rouge_l":0.4132258064516129}
{"id":577,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) r = 0 for i in range ( n ) : r += a [ i ] * n if r >= i : r -= a [ i ] * b [ n - i - 1 ] print ( r ) NEW_LINE"],"references":["r = lambda : list ( map ( int , input ( ) . split ( ) ) ) arr = r ( ) w = r ( ) hacks = r ( )   score = 0 for i in range ( 5 ) : tot = ( 500 * ( i + 1 ) ) score += max ( 0.3 * tot , tot * ( 1 - arr [ i ] \/ 250 ) - 50 * w [ i ] )     score += 100 * hacks [ 0 ] score -= 50 * hacks [ 1 ]     print ( int ( score ) )   NEW_LINE","m = list ( map ( int , input ( ) . split ( ) ) ) w = list ( map ( int , input ( ) . split ( ) ) ) h = list ( map ( int , input ( ) . split ( ) ) ) points = [ 500 , 1000 , 1500 , 2000 , 2500 ] ans = 0 for i in range ( 5 ) : ans += max ( 0.3 * points [ i ] , ( ( 1 - m [ i ] \/ 250 ) * points [ i ] ) - 50 * w [ i ] ) ans += 100 * h [ 0 ] - 50 * h [ 1 ] print ( int ( ans ) ) NEW_LINE","m = list ( map ( int , input ( ) . split ( ' ▁ ' ) ) ) w = list ( map ( int , input ( ) . split ( ' ▁ ' ) ) ) h = list ( map ( int , input ( ) . split ( ' ▁ ' ) ) ) x = [ 500 , 1000 , 1500 , 2000 , 2500 ] res = 0   for i , j , y in zip ( m , w , x ) : res += max ( 0.3 * y , ( 1 - ( i \/ 250 ) ) * y - 50 * j )   res += 100 * h [ 0 ] res -= 50 * h [ 1 ] print ( int ( res ) )     NEW_LINE","li = [ 500 , 1000 , 1500 , 2000 , 2500 ] M = list ( map ( int , input ( ) . split ( ) ) ) W = list ( map ( int , input ( ) . split ( ) ) ) hs , hu = map ( int , input ( ) . split ( ) ) ans = 0 for i in range ( 5 ) : x = li [ i ] m = M [ i ] w = W [ i ] ans += max ( 0.3 * x , ( 1 - m \/ 250 ) * x - 50 * w ) ans = ans + ( hs * 100 - hu * 50 ) print ( int ( ans ) ) NEW_LINE","p = [ 500 , 1000 , 1500 , 2000 , 2500 ] m = list ( map ( int , input ( ) . split ( ) ) ) w = list ( map ( int , input ( ) . split ( ) ) ) s , u = map ( int , input ( ) . split ( ) )   ans = 100 * s - 50 * ufor i in range ( 5 ) : ans += max ( 3 * int ( p [ i ] \/ 10 ) , ( ( ( 250 - m [ i ] ) \/ 250 ) * p [ i ] ) - ( 50 * w [ i ] ) )   print ( int ( ans ) ) NEW_LINE"],"bleu":0.5214419445916106,"rouge_l":0.6207136883189296}
{"id":578,"predictions":["n , m = map ( int , input ( ) . split ( ) ) f = n \/\/ mq = n % m   mini = ( f * ( f - 1 ) ) \/\/ ( 1 + 1 ) mini *= mmini += f * q ma = n - mma = ( ma * ( ma + 1 ) ) \/\/ ( 1 + 1 ) print ( mini , ma ) NEW_LINE"],"references":["n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) flag = 0 for i in range ( n ) : for j in range ( n ) : if ( i == j ) : continue for k in range ( n ) : if ( i == k or j == k ) : continue if ( arr [ i ] == arr [ j ] + arr [ k ] ) : flag = 1 print ( i + 1 , j + 1 , k + 1 ) break if ( flag ) : break if ( flag ) : breakif ( flag == 0 ) : print ( - 1 ) NEW_LINE","amount_of_forms = int ( input ( ) ) lengths_of_worms = list ( map ( int , input ( ) . split ( ) ) )   for leng in range ( 0 , amount_of_forms - 1 ) : for leng2 in lengths_of_worms [ leng + 1 : ] : if int ( lengths_of_worms [ leng ] + leng2 ) in lengths_of_worms : for i in range ( amount_of_forms - 1 ) : if lengths_of_worms [ i ] == leng2 and i != lengths_of_worms . index ( leng2 ) : final = i + 1 try : print ( lengths_of_worms . index ( lengths_of_worms [ leng ] + leng2 ) + 1 , final , leng + 1 ) except : print ( lengths_of_worms . index ( lengths_of_worms [ leng ] + leng2 ) + 1 , lengths_of_worms . index ( leng2 ) + 1 , leng + 1 ) quit ( ) print ( - 1 ) NEW_LINE","n = int ( input ( ) ) w = [ int ( i ) for i in input ( ) . split ( ) ] f = False   for i in range ( n ) : if f : break   for j in range ( n ) : if f : break if i == j : continue   for k in range ( n ) : if f : break   if k == i or j == k : continue   if w [ i ] == w [ j ] + w [ k ] : a , b , c = i , j , k f = True   elif w [ j ] == w [ k ] + w [ i ] : a , b , c = j , i , k f = True   elif w [ k ] == w [ i ] + w [ j ] : f = True a , b , c = k , i , j   if f : print ( a + 1 , b + 1 , c + 1 ) else : print ( - 1 ) NEW_LINE","n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) z = 0 for i in range ( n ) : for j in range ( n ) : if i != j : for k in range ( n ) : if i != k and j != k and a [ i ] == a [ j ] + a [ k ] : z = 1 print ( i + 1 , j + 1 , k + 1 ) break if z == 1 : break if z == 1 : breakif z == 0 : print ( - 1 ) NEW_LINE"],"bleu":0.15959887923840738,"rouge_l":0.33275911570485217}
{"id":579,"predictions":["n , k = map ( int , input ( ) . split ( ) ) NEW_LINE d = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE d [ 0 ] = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT x1 , y1 , c = map ( int , input ( ) . split ( ) ) NEW_LINE x2 , y2 = map ( int , input ( ) . split ( ) ) NEW_LINE d [ x1 - x2 ] += ( x1 - x2 ) * ( y1 - y2 ) NEW_LINE if d [ x1 ] < 0 : NEW_LINE INDENT ans += ( x1 - x2 ) * ( y1 - y2 ) NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE"],"references":["n , k = map ( int , input ( ) . split ( ) ) group = list ( map ( int , input ( ) . split ( ) ) ) available = [ [ k , 1 ] for i in range ( k + 1 ) ] center = ( k + 1 ) \/\/ 2 def calc ( center , row , col , num ) : end_col = col + num - 1 distance = abs ( center - row ) * num if col >= center : distance += ( col - center ) * num + ( num - 1 ) * num \/\/ 2 elif end_col <= center : distance += ( center - end_col ) * num + ( num - 1 ) * num \/\/ 2 else : distance += ( center - col ) * ( center - col + 1 ) \/\/ 2 + ( end_col - center ) * ( end_col - center + 1 ) \/\/ 2 return distancefor m in group : close , best_row , best_col = 10 ** 9 , - 1 , - 1 for row in range ( 1 , k + 1 ) : col = 0 if available [ row ] [ 0 ] < m and k - available [ row ] [ 1 ] + 1 < m : continue if available [ row ] [ 0 ] == k : col = center - m \/\/ 2 elif center - available [ row ] [ 0 ] <= available [ row ] [ 1 ] - center : col = available [ row ] [ 0 ] - m + 1 else : col = available [ row ] [ 1 ] distance = calc ( center , row , col , m ) if distance < close : close = distance best_row = row best_col = col if close == 10 ** 9 : print ( - 1 ) else : print ( best_row , best_col , best_col + m - 1 ) available [ best_row ] [ 0 ] = min ( available [ best_row ] [ 0 ] , best_col - 1 ) available [ best_row ] [ 1 ] = max ( available [ best_row ] [ 1 ] , best_col + m ) NEW_LINE","__author__ = ' Darren '     def solve ( ) : n , k = map ( int , input ( ) . split ( ) ) group = map ( int , input ( ) . split ( ) ) available = [ [ k , 1 ] [ : ] for _ in range ( k + 1 ) ] center = ( k + 1 ) \/\/ 2 for m in group : closest , best_row , best_col = 10000 , - 1 , - 1 for row in range ( 1 , k + 1 ) : col = 0 if available [ row ] [ 0 ] < m and k - available [ row ] [ 1 ] + 1 < m : continue if available [ row ] [ 0 ] == k : col = center - m \/\/ 2 elif center - available [ row ] [ 0 ] <= available [ row ] [ 1 ] - center : col = available [ row ] [ 0 ] - m + 1 else : col = available [ row ] [ 1 ] distance = calc_distance ( center , row , col , m ) if distance < closest : closest = distance best_row = row best_col = col if closest == 10000 : print ( - 1 ) else : print ( best_row , best_col , best_col + m - 1 ) available [ best_row ] [ 0 ] = min ( available [ best_row ] [ 0 ] , best_col - 1 ) available [ best_row ] [ 1 ] = max ( available [ best_row ] [ 1 ] , best_col + m )     def calc_distance ( center , row , col , num ) : end_col = col + num - 1 distance = abs ( center - row ) * num if col >= center : distance += ( col - center ) * num + ( num - 1 ) * num \/\/ 2 elif end_col <= center : distance += ( center - end_col ) * num + ( num - 1 ) * num \/\/ 2 else : distance += ( ( center - col ) * ( center - col + 1 ) \/\/ 2 + ( end_col - center ) * ( end_col - center + 1 ) \/\/ 2 ) return distance       if __name__ == ' _ _ main _ _ ' : solve ( ) NEW_LINE","def solve ( ) : n , k = map ( int , input ( ) . split ( ) ) group = map ( int , input ( ) . split ( ) ) available = [ [ k , 1 ] [ : ] for _ in range ( k + 1 ) ] center = ( k + 1 ) \/\/ 2 for m in group : closest , best_row , best_col = 10000 , - 1 , - 1 for row in range ( 1 , k + 1 ) : col = 0 if available [ row ] [ 0 ] < m and k - available [ row ] [ 1 ] + 1 < m : continue if available [ row ] [ 0 ] == k : col = center - m \/\/ 2 elif center - available [ row ] [ 0 ] <= available [ row ] [ 1 ] - center : col = available [ row ] [ 0 ] - m + 1 else : col = available [ row ] [ 1 ] distance = calc_distance ( center , row , col , m ) if distance < closest : closest = distance best_row = row best_col = col if closest == 10000 : print ( - 1 ) else : print ( best_row , best_col , best_col + m - 1 ) available [ best_row ] [ 0 ] = min ( available [ best_row ] [ 0 ] , best_col - 1 ) available [ best_row ] [ 1 ] = max ( available [ best_row ] [ 1 ] , best_col + m )     def calc_distance ( center , row , col , num ) : end_col = col + num - 1 distance = abs ( center - row ) * num if col >= center : distance += ( col - center ) * num + ( num - 1 ) * num \/\/ 2 elif end_col <= center : distance += ( center - end_col ) * num + ( num - 1 ) * num \/\/ 2 else : distance += ( ( center - col ) * ( center - col + 1 ) \/\/ 2 + ( end_col - center ) * ( end_col - center + 1 ) \/\/ 2 ) return distance     solve ( ) NEW_LINE"],"bleu":0.06995796138971817,"rouge_l":0.2604161037557417}
{"id":580,"predictions":["x1 , y1 = map ( int , input ( ) . split ( ) ) x2 , y2 = map ( int , input ( ) . split ( ) )   print ( max ( abs ( x1 - x2 ) , abs ( y1 - y2 ) ) ) NEW_LINE"],"references":["def main ( ) : n = int ( input ( ) ) count = 0 for i in range ( 1 , n \/\/ 2 + 1 ) : if n % i == 0 : count += 1 print ( count )     if __name__ == ' _ _ main _ _ ' : main ( ) NEW_LINE","n = int ( input ( ) ) q , s = int ( n ** .5 ) + 1 , { 1 } for i in range ( 1 , q ) : if n % i == 0 : s . add ( i ) ; s . add ( n \/\/ i ) print ( len ( s ) - 1 ) NEW_LINE","n = int ( input ( ) ) ; c = 0 ; for i in range ( 1 , n ) : if ( n % i == 0 ) : c = c + 1 ; print ( c ) ; NEW_LINE","from collections import Counter   def solve ( ) : n = int ( input ( ) ) count = 1   for i in range ( 2 , n \/\/ 2 + 1 ) : if n % i == 0 : count += 1   return count   print ( solve ( ) ) NEW_LINE","n = int ( input ( ) ) print ( sum ( n % i < 1 for i in range ( 1 , n ) ) ) NEW_LINE"],"bleu":0.19688432050869892,"rouge_l":0.496505352561267}
{"id":581,"predictions":["t = int ( input ( ) ) for a in range ( t ) : n = int ( input ( ) ) bt = list ( map ( int , input ( ) . split ( ) ) ) bt . sort ( ) print ( abs ( bt [ n - 1 ] - bt [ n ] ) ) NEW_LINE"],"references":["I = input NEW_LINE exec ( int ( I ( ) ) * ' n = int ( I ( ) ) ; k , m = ( 1 + x [ n > > 1 ] - x [ n - 1 > > 1 ] for ▁ x ▁ in ▁ map ( sorted , zip ( * ( map ( int , I ( ) . split ( ) ) for ▁ _ ▁ in [ 0 ] * n ) ) ) ) ; print ( k * m ) ; ' ) NEW_LINE","def solve ( z ) : NEW_LINE INDENT return z [ n \/\/ 2 ] + 1 - z [ - 1 - n \/\/ 2 ] NEW_LINE DEDENT for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE x , y = map ( sorted , zip ( * ( map ( int , input ( ) . split ( ) ) for _ in range ( n ) ) ) ) NEW_LINE print ( solve ( x ) * solve ( y ) ) NEW_LINE DEDENT","def solve ( z ) : NEW_LINE INDENT return z [ n \/\/ 2 ] + 1 - z [ - 1 - n \/\/ 2 ] NEW_LINE DEDENT for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE x , y = map ( sorted , zip ( * ( map ( int , input ( ) . split ( ) ) for _ in range ( n ) ) ) ) NEW_LINE print ( solve ( x ) * solve ( y ) ) NEW_LINE DEDENT","def solve ( z ) : NEW_LINE INDENT return z [ n \/\/ 2 ] + 1 - z [ ( n - 1 ) \/\/ 2 ] NEW_LINE DEDENT for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE x , y = map ( sorted , zip ( * ( map ( int , input ( ) . split ( ) ) for _ in range ( n ) ) ) ) NEW_LINE print ( solve ( x ) * solve ( y ) ) NEW_LINE DEDENT","I = input NEW_LINE for _ in [ 0 ] * int ( I ( ) ) : n = int ( I ( ) ) ; k , m = ( 1 + x [ n >> 1 ] - x [ n - 1 >> 1 ] for x in map ( sorted , zip ( * ( map ( int , I ( ) . split ( ) ) for _ in [ 0 ] * n ) ) ) ) ; print ( k * m ) NEW_LINE"],"bleu":0.3620732526302879,"rouge_l":0.4481914091936699}
{"id":582,"predictions":["n , m = map ( int , input ( ) . split ( ) ) g = [ ] for i in range ( n ) : g . append ( list ( input ( ) ) ) ans = 0 for i in range ( n ) : for j in range ( m ) : if g [ i ] [ j ] == \" . \" and g [ i ] [ j ] == \" T \" : ans += 1 print ( ans ) NEW_LINE"],"references":["def fact ( n ) : if n <= 1 : return 1 else : return n * fact ( n - 1 )   def c ( n , r ) : return fact ( n ) \/\/ ( fact ( r ) * fact ( n - r ) )   n = int ( input ( ) ) arr = [ ] h = 0 for _ in range ( n ) : arr . append ( list ( input ( ) ) ) for i in arr : if i . count ( \" C \" ) >= 2 : h += c ( i . count ( \" C \" ) , 2 ) arr = list ( map ( list , zip ( * arr ) ) )   for i in arr : if i . count ( \" C \" ) >= 2 : h += c ( i . count ( \" C \" ) , 2 ) print ( h ) NEW_LINE","a = int ( input ( ) ) c = [ [ ] for i in range ( a ) ] h = 0 for i in range ( a ) : b = input ( ) for j in range ( a ) : c [ i ] . append ( b [ j ] ) h += b . count ( ' C ' ) * ( b . count ( ' C ' ) - 1 ) \/\/ 2 for j in range ( a ) : num = 0 for i in range ( a ) : if c [ i ] [ j ] == ' C ' : num += 1 h += num * ( num - 1 ) \/\/ 2 print ( h ) NEW_LINE","n = int ( input ( ) ) cke = [ ] for i in range ( n ) : a = [ ] s = input ( ) for j in range ( n ) : a . append ( s [ j ] ) cke . append ( a ) c = 0 for i in range ( n ) : for j in range ( n ) : if cke [ i ] [ j ] == ' C ' : for k in range ( j + 1 , n ) : if cke [ i ] [ k ] == ' C ' : c += 1 for k in range ( i + 1 , n ) : if cke [ k ] [ j ] == ' C ' : c += 1   print ( c ) NEW_LINE","def fac ( n ) : t = 1 for i in range ( 1 , n + 1 ) : t = t * i return ( t )   N = int ( input ( ) ) y = [ ] a , b = 0 , 0 for i in range ( N ) : y += list ( map ( str , input ( ) . split ( ) ) )   for i in range ( N ) : r = y [ i ] . count ( ' C ' ) if r > 1 : a += fac ( r ) \/ ( fac ( 2 ) * fac ( r - 2 ) ) c = int ( a )   for j in range ( N ) : for k in range ( N ) : if y [ k ] [ j ] == ' C ' : b += 1 if b > 1 : c += fac ( b ) \/ ( fac ( 2 ) * fac ( b - 2 ) ) b = 0       print ( int ( c ) ) NEW_LINE","def fact ( n ) : if n == 0 : return 1 return n * fact ( n - 1 )     cake = [ ] chk = 0   for _ in range ( int ( input ( ) ) ) : s = input ( ) c = s . count ( ' C ' ) chk += fact ( c ) \/\/ ( 2 * fact ( c - 2 ) ) if c > 1 else 0 cake . append ( s )   cake = zip ( * cake )   for s in cake : c = s . count ( ' C ' ) chk += fact ( c ) \/\/ ( 2 * fact ( c - 2 ) ) if c > 1 else 0   print ( chk ) NEW_LINE"],"bleu":0.400499720870062,"rouge_l":0.5021909440977294}
{"id":583,"predictions":["import sys , os , ioimport math , bisect , operatorinf , mod = float ( ' inf ' ) , 10 ** 9 + 7 NEW_LINE"],"references":["from collections import defaultdict   n = int ( input ( ) ) p = list ( map ( int , input ( ) . split ( ) ) ) s = list ( map ( int , input ( ) . split ( ) ) )   clds , pars = defaultdict ( list ) , [ 0 ] * ( n + 1 ) for i in range ( n - 1 ) : cur , par = i + 2 , p [ i ] clds [ p [ i ] ] . append ( cur ) pars [ cur ] = par   ans , ok = s [ 0 ] , Truei , q = 0 , [ 1 ] while i < len ( q ) : cur = q [ i ] i += 1 par_v = s [ pars [ cur ] - 1 ] if cur in clds : mmin , summ , k = float ( ' inf ' ) , 0 , 0 for item in clds [ cur ] : mmin = min ( mmin , s [ item - 1 ] ) summ += s [ item - 1 ] k += 1 q . append ( item ) if s [ cur - 1 ] != - 1 : continue if mmin < par_v : ok = False break ans -= par_v ans += ( summ - ( k - 1 ) * mmin ) if ok : print ( ans ) else : print ( - 1 ) NEW_LINE","n = int ( input ( ) ) p = [ 0 , 0 ] + list ( map ( int , input ( ) . split ( ) ) ) s = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) ht = [ 0 ] * ( n + 1 ) ht [ 1 ] = 1   from collections import defaultdict , dequegr = defaultdict ( list )   for i in range ( 2 , n + 1 ) : gr [ p [ i ] ] . append ( i ) q = deque ( ) q . append ( [ 1 , - 1 ] ) while q : x , pr = q . popleft ( ) for i in gr [ x ] : if i != pr : ht [ i ] = ht [ x ] + 1 q . append ( [ i , x ] ) a = [ 0 ] * ( n + 1 ) a [ 1 ] = s [ 1 ]     q . append ( [ 1 , - 1 ] ) while q : x , pr = q . popleft ( ) for ch in gr [ x ] : q . append ( [ ch , x ] ) if ht [ x ] % 2 == 0 : mn = float ( ' inf ' ) for i in gr [ x ] : mn = min ( mn , s [ i ] - s [ p [ x ] ] ) if mn != float ( ' inf ' ) : a [ x ] = mn for i in gr [ x ] : a [ i ] = s [ i ] - s [ p [ x ] ] - mn tf = Truefor i in a : if i < 0 : tf = False breakif tf : print ( sum ( a ) ) else : print ( - 1 ) NEW_LINE","def solve ( ) : a = [ None ] * ( n + 1 )   a [ 1 ] = s [ 0 ] for i in range ( 2 , n + 1 ) : if s [ i - 1 ] == - 1 : continue   pi = p [ i - 2 ] pi_er_pi = p [ pi - 2 ]   if s [ i - 1 ] < s [ pi_er_pi - 1 ] : return - 1   new_value = s [ i - 1 ] - s [ pi_er_pi - 1 ] a [ pi ] = min ( a [ pi ] if a [ pi ] is not None else float ( ' inf ' ) , new_value )   for i in range ( 2 , n + 1 ) : if s [ i - 1 ] == - 1 : continue   pi = p [ i - 2 ] pi_er_pi = p [ pi - 2 ]   a [ i ] = s [ i - 1 ] - s [ pi_er_pi - 1 ] - a [ pi ]   return sum ( filter ( None , a ) )     n = int ( input ( ) ) p = list ( map ( int , input ( ) . split ( ) ) ) s = list ( map ( int , input ( ) . split ( ) ) ) ans = solve ( ) print ( ans ) NEW_LINE","n , ans = int ( input ( ) ) , 0 a = [ 0 , 0 ] + list ( map ( int , input ( ) . split ( ) ) ) s = [ 0 ] + [ i if i != - 1 else 1e9 + 1 for i in map ( int , input ( ) . split ( ) ) ] for i in range ( 1 , n + 1 ) : s [ a [ i ] ] = min ( s [ a [ i ] ] , s [ i ] ) for i in range ( 1 , n + 1 ) : if s [ a [ i ] ] > s [ i ] : print ( - 1 ) ; exit ( ) if s [ i ] == 1e9 + 1 : s [ i ] = s [ a [ i ] ] ans += s [ i ] - s [ a [ i ] ] print ( ans ) NEW_LINE"],"bleu":0.0011787485685557828,"rouge_l":0.09669981265312004}
{"id":584,"predictions":["t = int ( input ( ) ) NEW_LINE while t : n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if a . count ( 1 ) == 0 : NEW_LINE INDENT print ( ' NO ' ) else : NEW_LINE print ( ' YES ' ) NEW_LINE DEDENT"],"references":["for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) ans = \" YES \" s = set ( ) for i in range ( n ) : if ( b [ i ] > a [ i ] and ( 1 not in s ) or b [ i ] < a [ i ] and ( - 1 not in s ) ) : ans = \" NO \" break s . add ( a [ i ] ) print ( ans ) NEW_LINE","def answer ( n , a , b ) : s = set ( ) NEW_LINE","for t in range ( int ( input ( ) ) ) : input ( ) ; seen = { } ; r = ' yes ' ; i = lambda : map ( int , input ( ) . split ( ) ) for a , b in zip ( i ( ) , i ( ) ) : if a != b and not seen . get ( b > a ) : r = ' no ' ; break if a and not seen . get ( a > 0 ) : if seen . get ( a < 0 ) : break seen [ a > 0 ] = 1 print ( r ) NEW_LINE"],"bleu":0.49381730167209625,"rouge_l":0.5943312666076174}
{"id":585,"predictions":["s = input ( ) x , up , low , st = len ( s ) , 0 , 0 , \" \" for i in range ( 1 , x ) : if ( ord ( s [ i ] ) > 90 ) : up += 1 else : up += 1 if ( up == ( len ( s ) - 1 ) or len ( s ) == 1 ) : st += s [ 0 ] . swapcase ( ) i = 1 for i in range ( x ) : if ( i > 0 ) : st += s [ i ] . swapcase ( ) print ( st ) NEW_LINE"],"references":["def check ( txt : str ) -> bool : ln = len ( txt ) if ln == 0 or ln > 16 : return False for item in txt : if not ( ' a ' <= item <= ' z ' or ' A ' <= item <= ' Z ' or '0' <= item <= '9' or item == ' _ ' ) : return False return True     def checkHost ( hostName : str ) -> bool : hostLen = len ( hostName ) if hostLen == 0 or hostLen > 32 : return False for token in hostName . split ( ' . ' ) : if not check ( token ) : return False return True     mail = input ( ) isUser , isHost , isRes = False , False , Falseif ' @ ' in mail : atIndex = mail . index ( ' @ ' ) slashInd = mail . index ( ' \/ ' ) if ' \/ ' in mail else - 1 userName = mail [ : atIndex ] isUser = check ( userName ) hostName = mail [ atIndex + 1 : slashInd ] if slashInd != - 1 else mail [ atIndex + 1 : ] isHost = checkHost ( hostName ) if slashInd == - 1 : isRes = True else : resource = mail [ slashInd + 1 : ] isRes = check ( resource ) ''' if ▁ isUser ▁ and ▁ isHost ▁ and ▁ isRes : ▁ ▁ ▁ ▁ print ( ' YES ' ) else : ▁ ▁ ▁ ▁ print ( ' NO ' ) ''' print ( ' YES ' if isUser and isHost and isRes else ' NO ' ) NEW_LINE","email = input ( ) . split ( ' @ ' ) if ( len ( email ) != 2 ) : print ( \" NO \" ) else : flag = True rem = email [ 1 ] [ : ] rem = rem . split ( ' \/ ' ) NEW_LINE","''' def ▁ userName ( username ) : ▁ ▁ ▁ ▁ if ▁ len ( username ) ▁ < ▁ 1 ▁ or ▁ len ( username ) ▁ > ▁ 16 : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ return ▁ - 1 ▁ ▁ ▁ ▁ for ▁ item ▁ in ▁ username : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ item ▁ < ▁ ' 0 ' ▁ or ▁ item ▁ > ▁ ' w ' ▁ and ▁ item ▁ ! = ▁ ' _ ' : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ return ▁ - 1 ▁ ▁ ▁ ▁ return ▁ 1  def ▁ hostName ( hostname ) : ▁ ▁ ▁ ▁ if ▁ len ( hostname ) ▁ < ▁ 1 ▁ or ▁ len ( hostname ) ▁ > ▁ 32 : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ return ▁ - 1 ▁ ▁ ▁ ▁ for ▁ item ▁ in ▁ hostname :     line ▁ = ▁ input ( ) indOfAt ▁ = ▁ line . index ( ' @ ' ) username ▁ = ▁ line [ 0 : indOfAt ] hostname ▁ = ▁ line [ indOfAt ▁ + ▁ 1 : line . rindex ( ' . ' ) ] '''     def check ( line ) : ln = len ( line ) if ln == 0 or ln > 16 : return False for it in line : if not ( ' A ' <= it <= ' Z ' or ' a ' <= it <= ' z ' or '0' <= it <= '9' or it == ' _ ' ) : return False return True     def checkHost ( hostName ) : ln = len ( hostName ) if ln == 0 or ln > 32 : return False for token in hostName . split ( ' . ' ) : if not check ( token ) : return False return True     mail , isUser , isHost , isRes = input ( ) , False , False , Falseif ' @ ' in mail : atIndex = mail . index ( ' @ ' ) userName = mail [ : atIndex ] isUser = check ( userName ) hostName = mail [ atIndex + 1 : mail . index ( ' \/ ' ) ] if ' \/ ' in mail else mail [ atIndex + 1 : ] isHost = checkHost ( hostName ) if ' \/ ' not in mail : isRes = True else : isRes = check ( mail [ mail . index ( ' \/ ' ) + 1 : ] )   print ( ' YES ' if isUser and isHost and isRes else ' NO ' ) NEW_LINE","def check ( line ) : ln = len ( line ) if ln == 0 or ln > 16 : return False for symbol in line : if not ( ' A ' <= symbol <= ' Z ' or ' a ' <= symbol <= ' z ' or '0' <= symbol <= '9' or symbol == ' _ ' ) : return False return True     def checkHost ( hostName ) : hostLen = len ( hostName ) if hostLen == 0 or hostLen > 32 : return False for token in hostName . split ( ' . ' ) : if not check ( token ) : return False return True     mail = input ( ) isUser , isHost , isRes = False , False , False , if ' @ ' in mail : atIndex = mail . index ( ' @ ' ) userName = mail [ : atIndex ] isUser = check ( userName ) dashIndex = mail . index ( ' \/ ' ) if ' \/ ' in mail else - 1 hostName = mail [ atIndex + 1 : dashIndex ] if dashIndex != - 1 else mail [ atIndex + 1 : ] isHost = checkHost ( hostName ) if dashIndex == - 1 : isRes = True else : resource = mail [ dashIndex + 1 : ] isRes = check ( resource )   print ( ' YES ' if isRes and isHost and isUser else ' NO ' ) ''' ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ 0123456789 . . . . . . . . mail ▁ = ▁ \" something @ info . edu . tesu . ge \/ page \"   ''' NEW_LINE"],"bleu":0.11265325697603755,"rouge_l":0.43173658836803774}
{"id":586,"predictions":["for _ in range ( int ( input ( ) ) ) : x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) print ( abs ( x1 - x2 ) + abs ( y1 - y2 ) + abs ( x1 - x2 ) + abs ( y1 - y2 ) ) NEW_LINE"],"references":["for _ in range ( int ( input ( ) ) ) : x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) )   if x1 == x2 : print ( abs ( y2 - y1 ) )   elif y1 == y2 : print ( abs ( x2 - x1 ) )   else : print ( abs ( x2 - x1 ) + 2 + abs ( y2 - y1 ) ) NEW_LINE","def string_list ( s , char ) : output_list = [ ] NEW_LINE intermediator = \" \" NEW_LINE for i in range ( len ( s ) ) : if NEW_LINE s [ i ] != char : intermediator += s [ i ] NEW_LINE if i == len ( s ) - 1 : NEW_LINE INDENT output_list . append ( int ( intermediator ) ) else : NEW_LINE if NEW_LINE DEDENT intermediator : output_list . append ( int ( intermediator ) ) NEW_LINE intermediator = \" \" NEW_LINE return output_list     NEW_LINE def list_string ( l , char ) : output_str = \" \" NEW_LINE for i in range ( len ( l ) - 1 ) : output_str += str ( l [ i ] ) + char NEW_LINE output_str += str ( l [ len ( l ) - 1 ] ) NEW_LINE return output_str     NEW_LINE def merge_sort ( l ) : def NEW_LINE merge ( l1 , l2 ) : i , j = 0 , 0 NEW_LINE output_list = [ ] NEW_LINE while i < len ( l1 ) and j < len ( l2 ) : if NEW_LINE l1 [ i ] < l2 [ j ] : output_list . append ( l1 [ i ] ) NEW_LINE i += 1 else : output_list . append ( l2 [ j ] ) NEW_LINE j += 1 NEW_LINE if i == len ( l1 ) : NEW_LINE INDENT output_list += ( l2 [ j : ] ) else : NEW_LINE output_list += ( l1 [ i : ] ) NEW_LINE DEDENT return output_list   NEW_LINE def sorts ( l ) : if NEW_LINE len ( l ) < 2 : NEW_LINE return l else : mid = len ( l ) \/\/ 2 NEW_LINE left = sorts ( l [ : mid ] ) NEW_LINE right = sorts ( l [ mid : ] ) NEW_LINE return merge ( left , right ) NEW_LINE return sorts ( l )       NEW_LINE def main_function ( ) : output_list = [ ] NEW_LINE t = int ( input ( ) ) NEW_LINE for i in range ( t ) : x_1 , y_1 , x_2 , y_2 = string_list ( input ( ) , \" ▁ \" ) NEW_LINE dif_x = abs ( x_2 - x_1 ) NEW_LINE dif_y = abs ( y_2 - y_1 ) NEW_LINE if dif_y and dif_x : NEW_LINE INDENT total = dif_y + dif_x + 2 else : NEW_LINE total = dif_y + dif_x NEW_LINE DEDENT output_list . append ( total ) NEW_LINE return list_string ( output_list , \" ▁ \" )       print ( main_function ( ) )   NEW_LINE","for t in range ( int ( input ( ) ) ) : p , q , r , k = map ( int , input ( ) . split ( ) ) NEW_LINE if p == r : NEW_LINE INDENT print ( abs ( q - k ) ) elif q == k : NEW_LINE print ( abs ( p - r ) ) else : NEW_LINE print ( abs ( p - r ) + abs ( q - k ) + 2 ) NEW_LINE DEDENT","t = int ( input ( ) ) NEW_LINE while ( t > 0 ) : x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) NEW_LINE if x1 == x2 : NEW_LINE INDENT time = abs ( y1 - y2 ) elif y1 == y2 : NEW_LINE time = abs ( x1 - x2 ) else : NEW_LINE time = abs ( x1 - x2 ) + abs ( y1 - y2 ) + 2 NEW_LINE DEDENT print ( time ) NEW_LINE t = t - 1 NEW_LINE"],"bleu":0.6828182327906932,"rouge_l":0.7068669527896996}
{"id":587,"predictions":["a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE"],"references":["oro_infinito = False   datos = input ( ) . split ( ) NEW_LINE a = int ( datos [ 0 ] ) NEW_LINE b = int ( datos [ 1 ] ) NEW_LINE c = int ( datos [ 2 ] ) NEW_LINE d = int ( datos [ 3 ] ) NEW_LINE e = int ( datos [ 4 ] ) NEW_LINE f = int ( datos [ 5 ] )   if a != 0 and b != 0 and c != 0 and d != 0 and e != 0 and f != 0 : if NEW_LINE ( b \/ a ) * ( d \/ c ) * ( f \/ e ) > 1 : oro_infinito = Trueelse : if c == 0 and d > 0 : NEW_LINE INDENT oro_infinito = True elif a == 0 and b > 0 and c > 0 and d > 0 : NEW_LINE oro_infinito = True elif e == 0 and f > 0 and a > 0 and b > 0 and c > 0 and d > 0 : NEW_LINE oro_infinito = True   if oro_infinito : NEW_LINE print ( ' Ron ' ) else : NEW_LINE print ( ' Hermione ' ) NEW_LINE DEDENT","a , b , c , d , e , f = map ( int , input ( ) . split ( ) ) NEW_LINE if a * c * e < b * d * f or ( c == 0 and d > 0 ) or ( a == 0 and b > 0 and d > 0 and c > 0 ) : NEW_LINE INDENT print ( \" Ron \" ) else : NEW_LINE print ( \" Hermione \" ) NEW_LINE DEDENT","a , b , c , d , e , f = map ( int , input ( ) . split ( ) ) ; if a * c * e < b * d * f or a == 0 and b * d > 0 or c == 0 and d > 0 : print ( \" Ron \" ) ; else : print ( \" Hermione \" ) ; NEW_LINE","a , b , c , d , e , f = [ int ( i ) for i in input ( ) . split ( ) ]   if a * c * e < b * d * f or ( c == 0 and d > 0 ) or ( a == 0 and b > 0 and d > 0 ) : NEW_LINE INDENT print ( ' Ron ' ) else : NEW_LINE print ( ' Hermione ' ) NEW_LINE DEDENT"],"bleu":0.07843436101911672,"rouge_l":0.40627973358705993}
{"id":588,"predictions":["import sys , os , ioimport math , bisect , operatorinf , mod = float ( ' inf ' ) , 10 ** 9 + 7 NEW_LINE"],"references":["n = int ( input ( ) ) if n % 2 == 0 : print ( n \/\/ 2 ) else : print ( ( n \/\/ 2 + 1 ) * ( - 1 ) )   NEW_LINE","n = int ( input ( ) ) print ( n \/\/ 2 - ( n % 2 ) * n ) NEW_LINE","user_input = int ( input ( ) ) result = user_input \/\/ 2 if user_input % 2 == 0 : print ( result ) else : print ( - ( result + 1 ) ) NEW_LINE","n = int ( input ( ) ) if n % 2 == 0 : ne = n \/\/ 2 no = n \/\/ 2 else : no = n \/\/ 2 + 1 ne = n - noprint ( ne * ( ne + 1 ) - pow ( no , 2 ) ) NEW_LINE","t = int ( input ( ) ) sum = 0 nume = t \/\/ 2 sume = nume * ( nume + 1 ) sum = sume - ( ( t * ( t + 1 ) ) \/\/ 2 - sume ) print ( sum ) NEW_LINE"],"bleu":0.06143498010483918,"rouge_l":0.1783625730994152}
{"id":589,"predictions":["def solution ( ) : n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) c5 = 0 c0 = 0 for i in arr : if i == 5 : c5 += 1 else : c0 += 1 c5 = ( c5 \/\/ 9 ) * 9   if c0 == 0 : print ( - 1 ) return elif c5 == 0 : print ( 0 ) return else : st = '5' * c5 st += '0' * c0 print ( int ( st ) ) \t \t               \t   if __name__ == ' _ _ main _ _ ' : solution ( ) NEW_LINE"],"references":["m = input ( ) l = list ( m ) s = list ( set ( l ) ) z = 0   if ( m [ 0 ] == '4' ) : z = 1 elif ( '444' in m ) : z = 1 for i in s : if ( i == '4' or i == '1' ) : pass else : z = 1 break   if ( z == 1 ) : print ( \" NO \" ) else : print ( \" YES \" ) NEW_LINE","import sysfrom os import pathif ( path . exists ( ' input . txt ' ) and path . exists ( ' output . txt ' ) ) : sys . stdout = open ( ' output . txt ' , ' w ' ) sys . stdin = open ( ' input . txt ' , ' r ' )   NEW_LINE","n = input ( ) result = Truei = 0 t = len ( n ) while i < len ( n ) : if n [ i ] == \"1\" : i += 1 if i == t : break if n [ i ] == \"4\" : i += 1 if i == t : break if n [ i ] == \"4\" : i += 1 if i == t : break else : i += 1 result = Falseif result is True : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"bleu":0.08799061308118772,"rouge_l":0.3698090330403152}
{"id":590,"predictions":["import sys , mathfrom collections import deque , defaultdictimport operator as opfrom functools import reducefrom itertools import permutations   NEW_LINE"],"references":["a = [ i for i in input ( ) ] b = [ i for i in input ( ) ]   ab = [ i for i in input ( ) ]   c = a + b   ab . sort ( ) c . sort ( )   if ab == c : print ( ' YES ' ) else : print ( ' NO ' ) NEW_LINE","from collections import Counterx1 = Counter ( input ( ) ) x2 = Counter ( input ( ) ) x3 = Counter ( input ( ) ) if x1 + x2 == x3 : print ( ' YES ' )   else : print ( ' NO ' )   NEW_LINE","s = input ( ) s1 = input ( ) s2 = input ( ) s3 = s + s1s3 = ' ' . join ( sorted ( s3 ) ) s2 = ' ' . join ( sorted ( s2 ) ) cnt = 0 if ( len ( s3 ) == len ( s2 ) ) : for i in range ( 0 , len ( s3 ) ) : if ( s3 [ i ] == s2 [ i ] ) : cnt += 1 if ( cnt == len ( s3 ) and len ( s3 ) == len ( s2 ) ) : print ( \" YES \" ) else : print ( \" NO \" ) else : print ( \" NO \" ) NEW_LINE","a = input ( ) b = input ( ) c = input ( )   print ( ' YES ' if sorted ( a + b ) == sorted ( c ) else ' NO ' ) NEW_LINE"],"bleu":0.03542658275300031,"rouge_l":0.10445205479452055}
{"id":591,"predictions":["def STR ( ) : return list ( input ( ) ) def INT ( ) : return int ( input ( ) ) def MAP ( ) : return map ( int , input ( ) . split ( ) ) def MAP2 ( ) : return map ( float , input ( ) . split ( ) ) def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) def STRING ( ) : return input ( ) import stringimport sysfrom heapq import heappop , heappushfrom bisect import * from collections import deque , Counter , defaultdictfrom math import * from itertools import permutations , accumulatedx = [ - 1 , 1 , 0 , 0 ] dy = [ 0 , 0 , 1 , - 1 ] NEW_LINE"],"references":["def equal ( a , b ) : for i in range ( len ( a ) ) : if a [ i ] != b [ i ] and a [ i ] != \" * \" and b [ i ] != \" * \" : return False return True   string , k , best = input ( ) . strip ( ) , int ( input ( ) ) , 0 string += \" * \" * kfor i in range ( len ( string ) + 1 ) : for j in range ( i + 1 , len ( string ) + 1 ) : if not ( j - i ) % 2 : if equal ( string [ i : ( i + j ) \/\/ 2 ] , string [ ( i + j ) \/\/ 2 : j ] ) : best = max ( best , j - i ) print ( best ) NEW_LINE","def solve ( ) : s = input ( ) k = int ( input ( ) ) len_s = len ( s ) len_f = len_s + k max_n = int ( len_f \/ 2 ) NEW_LINE","s = [ * input ( ) ] k = int ( input ( ) ) s . extend ( [ ' ? ' ] * k ) m = 0 for i in range ( 1 , len ( s ) \/\/ 2 + 1 ) : for j in range ( len ( s ) - 2 * i + 1 ) : q = 0 for k in range ( i ) : if s [ j + k ] == ' ? ' or s [ j + k + i ] == ' ? ' : continue if s [ j + k ] != s [ j + k + i ] : q = 1 break if q : continue else : m = i breakprint ( 2 * m ) NEW_LINE"],"bleu":0.11023957852271095,"rouge_l":0.39467348781221784}
{"id":592,"predictions":["import sys , os , ioimport math , bisect , operatorinf , mod = float ( ' inf ' ) , 10 ** 9 + 7 NEW_LINE"],"references":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) res = 0 for j in range ( n - 2 , - 1 , - 1 ) : if a [ j ] >= a [ j + 1 ] : a [ j ] = max ( 0 , a [ j + 1 ] - 1 ) print ( sum ( a ) ) NEW_LINE","n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) ans = l [ - 1 ] x = n - 1 p = l [ - 1 ] while x >= 1 : if p == 0 : break else : if l [ x - 1 ] >= p : ans += p - 1 p = p - 1 else : ans += l [ x - 1 ] p = l [ x - 1 ] x -= 1 print ( ans ) NEW_LINE","n = int ( input ( ) ) cho = [ int ( x ) for x in input ( ) . split ( ) ] cho . reverse ( ) s = cho [ 0 ] prev = cho [ 0 ] for i in range ( 1 , len ( cho ) ) : if cho [ i ] >= prev : if prev > 1 : s += prev - 1 prev -= 1 else : break else : s += cho [ i ] prev = cho [ i ] print ( s ) NEW_LINE","n = int ( input ( ) ) a = [ int ( i ) for i in input ( ) . split ( ) ] a . reverse ( ) SUM = [ a [ 0 ] ] min = a [ 0 ] for i in range ( 1 , n ) : if a [ i ] < min : min = a [ i ] SUM . append ( min ) elif a [ i ] >= min and min != 1 : min -= 1 SUM . append ( min ) print ( sum ( SUM ) ) NEW_LINE"],"bleu":0.00844077427706858,"rouge_l":0.13322413322413326}
{"id":593,"predictions":["import math   n , k = map ( int , input ( ) . split ( ) )   matrix = [ list ( \" . \" ) for i in range ( n ) ]   for i in range ( n ) : for j in range ( n ) : if ( i == 0 or i == ( n - 1 ) ) : if ( matrix [ i ] [ j ] == \" # \" ) : continue   if ( matrix [ i ] [ j ] == \" # \" and matrix [ i + 1 ] [ j ] == \" # \" ) : matrix [ i ] [ j ] = \" . \" matrix [ i + 1 ] [ j ] = \" . \" matrix [ i ] [ j ] = \" # \" matrix [ i + 1 ] [ j ] = \" . \" matrix [ i ] [ j - 1 ] = \" . \" matrix [ i + 1 ] [ j ] = \" . \" matrix [ i ] [ j ] = \" . \" matrix [ i + 1 ] [ j - 1 ] = \" . \" matrix [ i + 1 ] [ j + 1 ] = \" # \" matrix [ i ] [ j ] = \" . \" matrix [ i ] [ j + 1 ] = \" . \" matrix [ i ] [ j ] = \" . \"   if ( matrix [ i ] [ j ] == \" # \" and matrix [ i + 1 ] [ j + 1 ] = \" . \" matrix [ i ] [ j ] = \" . \" matrix [ i ] [ j ] = \" . \" matrix [ i ] [ j + 1 ] = \" . \" matrix [ i ] [ j + 1 ] = \" . \" matrix [ i ] [ j + 1 ] = \" . \"   for i in range ( n ) : if ( matrix [ i ] [ j ] == \" . \" ) : if ( matrix [ i ] [ j ] == \" . \" ) : print ( \" NO \" ) exit ( ) print ( \" YES \" ) for i in range ( n ) : print ( \" YES \" ) NEW_LINE"],"references":["n , k = map ( int , input ( ) . split ( ) ) if ( k % 2 == 0 ) : print ( \" YES \" ) print ( ' . ' * n ) print ( ' . ' + ' # ' * ( k \/\/ 2 ) + ' . ' * ( n - 1 - k \/\/ 2 ) ) print ( ' . ' + ' # ' * ( k \/\/ 2 ) + ' . ' * ( n - 1 - k \/\/ 2 ) ) print ( ' . ' * n ) else : print ( \" YES \" ) print ( ' . ' * n ) if ( k <= n - 2 ) : print ( ' . ' * ( ( n - k ) \/\/ 2 ) + ' # ' * k + ' . ' * ( ( n - k ) \/\/ 2 ) ) print ( ' . ' * n ) else : print ( ' . ' + ' # ' * ( n - 2 ) + ' . ' ) print ( ' . ' + ' # ' * ( ( k - n + 2 ) \/\/ 2 ) + ' . ' * ( n - 2 - k + n - 2 ) + ' # ' * ( ( k - n + 2 ) \/\/ 2 ) + ' . ' ) print ( ' . ' * n ) NEW_LINE","n , k = map ( int , input ( ) . split ( ) ) s = ' . ' * nm = ( k + 1 ) \/\/ 2 a = ' . ' + ' # ' * m + ' . ' * ( n - m - 1 ) if k % 2 == 0 : b = aelif k < n : t = ( n - k ) \/\/ 2 * ' . ' a , b = t + ' # ' * k + t , selse : b = a [ : 2 ] + ' . ' + a [ 3 : ] print ( ' YES ' , s , a , b , s , sep = ' \\n ' ) NEW_LINE","n , k = map ( int , input ( ) . split ( ) ) a = [ ] for i in range ( 0 , 4 ) : temp = [ ] for i in range ( 0 , n ) : temp . append ( ' . ' ) a . append ( temp ) m = ki = 1 while m > 1 and i < ( n \/\/ 2 ) : a [ 1 ] [ i ] = ' # ' a [ 1 ] [ n - i - 1 ] = ' # ' i += 1 m -= 2 i = 1 while m > 1 and i < ( n \/\/ 2 ) : a [ 2 ] [ i ] = ' # ' a [ 2 ] [ n - i - 1 ] = ' # ' i += 1 m -= 2 if m > 0 : a [ 1 ] [ n \/\/ 2 ] = ' # ' m -= 1 if m > 0 : a [ 2 ] [ n \/\/ 2 ] = ' # ' m -= 1 print ( ' YES ' ) for i in range ( 0 , 4 ) : for j in range ( 0 , n ) : print ( a [ i ] [ j ] , end = ' ' ) print ( ) NEW_LINE","n , k = list ( map ( int , input ( ) . split ( ) ) )   if k % 2 == 0 : s = \" . \" s = s + \" # \" * ( k \/\/ 2 ) s = s + \" . \" * ( n - len ( s ) ) print ( \" YES \" ) print ( \" . \" * n ) print ( s ) print ( s ) print ( \" . \" * n )   else : if k <= n - 2 : a = \" # \" * k s = \" . \" * ( ( n - k ) \/\/ 2 ) + a + \" . \" * ( ( n - k ) \/\/ 2 ) print ( \" YES \" ) print ( \" . \" * n ) print ( s ) print ( \" . \" * n ) print ( \" . \" * n ) else : k = k - n + 3 a = \" # \" * k s = \" . \" * ( ( n - k ) \/\/ 2 ) + a + \" . \" * ( ( n - k ) \/\/ 2 ) print ( \" YES \" ) print ( \" . \" * n ) print ( \" . \" + \" # \" * ( n - 2 ) + \" . \" ) s = list ( s ) s [ n \/\/ 2 ] = \" . \" s = \" \" . join ( s ) print ( s ) print ( \" . \" * n ) NEW_LINE","import sys , os , iofrom sys import stdinfrom math import log , gcd , ceilfrom collections import defaultdict , deque , Counterfrom heapq import heappush , heappopfrom bisect import bisect_left , bisect_rightimport math       alphabets = list ( ' abcdefghijklmnopqrstuvwxyz ' )     def isPrime ( x ) : for i in range ( 2 , x ) : if i * i > x : break if ( x % i == 0 ) : return False return Truedef ncr ( n , r , p ) : num = den = 1 for i in range ( r ) : num = ( num * ( n - i ) ) % p den = ( den * ( i + 1 ) ) % p return ( num * pow ( den , p - 2 , p ) ) % pdef primeFactors ( n ) : l = [ ] while n % 2 == 0 : l . append ( 2 ) n = n \/ 2 for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) : while n % i == 0 : l . append ( int ( i ) ) n = n \/ i if n > 2 : l . append ( n ) return list ( set ( l ) ) def power ( x , y , p ) : res = 1 x = x % p if ( x == 0 ) : return 0 while ( y > 0 ) : if ( ( y & 1 ) == 1 ) : res = ( res * x ) % p y = y >> 1 NEW_LINE"],"bleu":0.29765237364963437,"rouge_l":0.36210189438909823}
{"id":594,"predictions":["import matht = int ( input ( ) ) for i in range ( t ) : a , b = map ( int , input ( ) . split ( ) ) ans = 0 while a <= b and math . floor ( a \/ b ) ) : a += 1 print ( ans ) NEW_LINE"],"references":["sections , a , divisors , cap = map ( int , input ( ) . split ( ) )   NEW_LINE","import math   k , a , b , v = map ( int , input ( ) . split ( ) )         ans = 0   while a > 0 :   l = min ( k - 1 , b )   b -= l a -= ( l + 1 ) * v   ans += 1   print ( ans ) NEW_LINE","import mathk , a , b , v = map ( int , input ( ) . split ( ) ) ans = 0 while a > 0 : l = min ( k - 1 , b ) b -= l a -= ( l + 1 ) * v ans += 1 print ( ans ) NEW_LINE","sections , nuts , divisors , capacity = map ( int , input ( ) . split ( ) ) count = 0 while True : if nuts <= 0 : print ( count ) break else : x = min ( sections - 1 , divisors ) divisors -= x nuts -= ( ( x + 1 ) * capacity ) count += 1 NEW_LINE","k , a , b , v = map ( int , input ( ) . split ( ) ) ans = 0 while a > 0 : sec = min ( k , b + 1 ) if sec <= 0 : ans += 1 a -= v else : a -= sec * v ans += 1 b = b - sec + 1 print ( ans ) NEW_LINE"],"bleu":0.47589983916384404,"rouge_l":0.6475792182724787}
{"id":595,"predictions":["a , b = map ( int , input ( ) . split ( ) ) a = a + 1 n = ak = 10 while ( True ) : if ( ( a % 10 ) > b ) : break n = a - ( a % 10 ) k *= 10 print ( n - a ) NEW_LINE"],"references":["a , b = [ int ( x ) for x in input ( ) . split ( ) ]   x = b % 10 mul = 1 for i in range ( b , a , - 1 ) : mul *= x x -= 1 if x < 0 and i > a : print ( \"0\" ) mul = - 1 breakif mul != - 1 : mul = mul % 10 print ( mul ) NEW_LINE","def STR ( ) : return list ( input ( ) ) def INT ( ) : return int ( input ( ) ) def MAP ( ) : return map ( int , input ( ) . split ( ) ) def MAP2 ( ) : return map ( float , input ( ) . split ( ) ) def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) def STRING ( ) : return input ( ) import stringimport sysfrom heapq import heappop , heappushfrom bisect import * from collections import deque , Counter , defaultdictfrom math import * from itertools import permutations , accumulatedx = [ - 1 , 1 , 0 , 0 ] dy = [ 0 , 0 , 1 , - 1 ] NEW_LINE","def STR ( ) : return list ( input ( ) ) def INT ( ) : return int ( input ( ) ) def MAP ( ) : return map ( int , input ( ) . split ( ) ) def MAP2 ( ) : return map ( float , input ( ) . split ( ) ) def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) def STRING ( ) : return input ( ) import stringimport sysfrom heapq import heappop , heappushfrom bisect import * from collections import deque , Counter , defaultdictfrom math import * from itertools import permutations , accumulatedx = [ - 1 , 1 , 0 , 0 ] dy = [ 0 , 0 , 1 , - 1 ] NEW_LINE","def fac ( a , b ) : k = 1 for i in range ( a + 1 , b + 1 ) : k = k % 10 * i % 10 if k == 0 : return 0 return k   a , b = map ( int , input ( ) . split ( ) ) print ( fac ( a , b ) ) NEW_LINE","''' http : \/ \/ codeforces . com \/ contest \/ 869 \/ problem \/ B ''' a , b = map ( int , input ( ) . split ( ) )   if a > b or b - a > 10 : print ( 0 ) elif a == b : print ( 1 ) else : fact = 1 for i in range ( a + 1 , b + 1 ) : fact = ( fact * ( i % 10 ) ) % 10 print ( fact )   NEW_LINE"],"bleu":0.3735022487940754,"rouge_l":0.46304434678385936}
{"id":596,"predictions":["n , m = map ( int , input ( ) . split ( ) ) arr = [ x for x in range ( 0 , n + 1 ) ] d = 1 for i in range ( m ) : a , b = map ( int , input ( ) . split ( ) ) a , b = arr [ a ] , arr [ b ] while a != arr [ a ] : a = arr [ a ] while b != arr [ b ] : b = arr [ b ] if a != b : arr [ b ] = a d *= 2 print ( d ) NEW_LINE"],"references":["n = int ( input ( ) ) a = pow ( 1 , n , 5 ) b = pow ( 2 , n , 5 ) c = pow ( 3 , n , 5 ) d = pow ( 4 , n , 5 ) print ( ( a + b + c + d ) % 5 )   NEW_LINE","s = input ( ) n = len ( s ) if n < 2 : n = 2 s = '0' + sx = int ( s [ n - 2 ] + s [ n - 1 ] ) if x % 4 == 0 : print ( 4 ) else : print ( 0 )   NEW_LINE","n = eval ( input ( ) ) n = n % 4 print ( ( 1 + 2 ** n + 3 ** n + 4 ** n ) % 5 ) NEW_LINE","print ( 4 if int ( input ( ) ) % 4 == 0 else 0 ) NEW_LINE","if int ( input ( ) ) % 4 == 0 : print ( 4 ) else : print ( 0 ) NEW_LINE"],"bleu":0.07571723257455491,"rouge_l":0.3602474767990501}
{"id":597,"predictions":["for _ in range ( int ( input ( ) ) ) : a , b , r = map ( int , input ( ) . split ( ) ) NEW_LINE print ( max ( 0 , a - r ) + max ( 0 , b - 2 ) ) NEW_LINE"],"references":["cases = int ( input ( ) ) while cases : cases -= 1 a , b , c , r = map ( int , input ( ) . split ( ) )   if a > b : a , b = b , a   pot = b - a   cl = c - r cr = c + r   if a <= cl <= cr <= b : ans = b - a - ( cr - cl ) elif cl <= a <= cr <= b : ans = b - cr elif a <= cl <= b <= cr : ans = cl - a elif cl <= a <= b <= cr : ans = 0 else : ans = b - a   print ( ans ) NEW_LINE","import sys     t = int ( input ( ) )   for _ in range ( t ) :   \"\"\" ▁ ▁ ▁ ▁ Cita ▁ código ▁ externo : ▁ ▁ ▁ ▁ https : \/ \/ www . geeksforgeeks . org \/ python - input - methods - competitive - programming \/ ▁ ▁ ▁ ▁ \"\"\"   a , b , c , d = list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) )   if a > b : ma = a mi = b else : ma = b mi = a   l = ma - mi   if c + d <= mi or c - d >= ma : pass elif c - d <= mi and c + d >= ma : l = 0 elif mi <= c and c <= ma : l -= min ( c - mi , d ) l -= min ( ma - c , d ) elif c < mi : l -= ( ( c + d ) - mi ) elif c > ma : l -= ( ma - ( c - d ) ) print ( l ) NEW_LINE","for _ in [ 0 ] * int ( input ( ) ) : a , b , c , r = map ( int , input ( ) . split ( ) ) if a > b : a , b = b , a print ( min ( b - a , max ( c - r - a , 0 ) + max ( b - c - r , 0 ) ) ) NEW_LINE"],"bleu":0.4209491216273264,"rouge_l":0.6346479554802806}
{"id":598,"predictions":["n , m = map ( int , input ( ) . split ( ) ) f = n \/\/ mq = n % m   mini = ( f * ( f - 1 ) ) \/\/ ( 1 + 1 ) mini *= mmini += f * q ma = n - mma = ( ma * ( ma + 1 ) ) \/\/ ( 1 + 1 ) print ( mini , ma ) NEW_LINE"],"references":["import mathimport collections def solve ( n , l ) : return max ( l ) - ( sum ( l ) - max ( l ) ) + 1   n = int ( input ( ) ) l = [ int ( s ) for s in input ( ) . split ( ) ] result = solve ( n , l ) print ( result ) NEW_LINE","n = int ( input ( ) )   arr = list ( map ( int , input ( ) . split ( ) ) )   maxim = max ( arr )   tot = sum ( arr )   res = ( 2 * maxim ) - tot + 1   print ( res ) NEW_LINE","n = int ( input ( ) ) l = [ int ( x ) for x in input ( ) . split ( ) ] print ( max ( l ) - ( sum ( l ) - max ( l ) ) + 1 ) NEW_LINE","n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) ma = max ( arr ) su = sum ( arr ) su = su - maans = ma - suans = ans + 1 print ( ans ) NEW_LINE","n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) a . sort ( ) s = sum ( a [ : - 1 ] ) print ( a [ - 1 ] - s + 1 ) NEW_LINE"],"bleu":0.2544562136631819,"rouge_l":0.45769728331177234}
{"id":599,"predictions":["def func ( ) : dic = dict ( ) NEW_LINE for i in lst : if NEW_LINE i in dic : print ( ' YES ' ) NEW_LINE return else : dic [ i ] = 0 NEW_LINE print ( ' NO ' )     for _ in range ( int ( input ( ) ) ) : num = int ( input ( ) ) NEW_LINE lst = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE func ( ) NEW_LINE"],"references":["def main_funtion ( ) : n = int ( input ( ) ) s = [ int ( i ) for i in input ( ) . split ( \" ▁ \" ) ] minimum = min ( s ) the_val = 10000000000000 for i in s : if i > minimum and i < the_val : the_val = i if the_val == 10000000000000 : return \" NO \" return the_val     print ( main_funtion ( ) ) NEW_LINE","input ( ) max = 101 min = 101 for elem in list ( map ( int , input ( ) . split ( ) ) ) : if elem < min : max = min min = elem elif elem < max and elem != min : max = elemprint ( \" NO \" if max == 101 else max ) NEW_LINE","n = int ( input ( ) ) m = ( sorted ( list ( set ( map ( int , input ( ) . strip ( ) . split ( ) ) ) ) ) ) [ : n ] print ( m [ 1 ] if len ( m ) > 1 else \" NO \" ) NEW_LINE","n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) a = list ( set ( a ) ) a . sort ( ) if len ( a ) < 2 : print ( \" NO \" ) else : print ( a [ 1 ] ) NEW_LINE"],"bleu":0.3688549870274922,"rouge_l":0.3851183765501691}
{"id":600,"predictions":["n = int ( input ( ) ) A = list ( map ( int , input ( ) . split ( ) ) ) A . sort ( ) NEW_LINE"],"references":["n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) a . sort ( ) cur = 1 for i in range ( n ) : if a [ i ] >= cur : cur += 1 print ( cur - 1 ) NEW_LINE","n = int ( input ( ) ) bt = list ( map ( int , input ( ) . split ( ) ) ) bt . sort ( ) day = 1 for a in range ( n ) : if day <= bt [ a ] : day += 1 print ( day - 1 ) NEW_LINE","n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ' ▁ ' ) ) ) a = list ( sorted ( a ) )   days_of_training = 0 for i in range ( len ( a ) ) : if a [ i ] > days_of_training : days_of_training += 1 print ( days_of_training ) NEW_LINE","n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ' ▁ ' ) ) ) a = list ( sorted ( a ) )   days_of_training = 0 for i in range ( len ( a ) ) : if a [ i ] > days_of_training : days_of_training += 1 print ( days_of_training ) NEW_LINE"],"bleu":0.3285012283163203,"rouge_l":0.6102104173853052}
{"id":601,"predictions":["n , k = map ( int , input ( ) . split ( ) ) X = list ( map ( int , input ( ) . split ( ) ) )   fallen = set ( ) pairs = set ( ) for i in X : if ( i - 1 ) in fallen : NEW_LINE"],"references":["entrada1 = input ( ) . split ( ) NEW_LINE n , k = int ( entrada1 [ 0 ] ) , int ( entrada1 [ 1 ] )   entrada2 = input ( ) . split ( ) NEW_LINE c = int ( entrada2 [ 0 ] ) NEW_LINE festivos = [ ] NEW_LINE for i in range ( c ) : festivos . append ( int ( entrada2 [ i + 1 ] ) )   regalos = 0 NEW_LINE k_esimo = 0 NEW_LINE f = 0   i = 1 NEW_LINE while i <= n : if NEW_LINE f < c and i == festivos [ f ] : regalos = regalos + 1 NEW_LINE f = f + 1 NEW_LINE k_esimo = 0 else : k_esimo = k_esimo + 1 NEW_LINE if k_esimo == k : regalos = regalos + 1 NEW_LINE k_esimo = 0 NEW_LINE i = i + 1 NEW_LINE print ( regalos ) NEW_LINE","n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE t = 1 NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : if NEW_LINE i in a [ 1 : ] : ans += 1 NEW_LINE t = 1 elif t == k : ans += 1 NEW_LINE t = 1 else : t += 1 NEW_LINE print ( ans ) NEW_LINE","n , k = map ( int , input ( ) . split ( ) ) NEW_LINE d = list ( map ( int , input ( ) . split ( ) ) ) [ 1 : ] + [ n + 1 ] NEW_LINE res , mx = 0 , kfor NEW_LINE i in range ( len ( d ) ) : res += max ( 0 , ( d [ i ] - mx + k - 1 ) \/\/ k ) + 1 NEW_LINE mx = max ( mx , d [ i ] + k ) NEW_LINE print ( res - 1 ) NEW_LINE","n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE t = 1 NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : if NEW_LINE i in a [ 1 : ] : ans += 1 NEW_LINE t = 1 elif t == k : ans += 1 NEW_LINE t = 1 else : t += 1 NEW_LINE print ( ans ) NEW_LINE","n , k = input ( ) . split ( ) NEW_LINE lis = input ( ) . split ( ) NEW_LINE lis1 = lis [ 1 : ] NEW_LINE count = dict ( ) NEW_LINE for i in lis1 : count [ int ( i ) ] = count . get ( int ( i ) , 0 ) + 1 NEW_LINE ans = 0 NEW_LINE prev = 0 NEW_LINE for i in range ( int ( n ) + 1 ) : if NEW_LINE count . get ( i , 0 ) > 0 : ans += 1 NEW_LINE prev = i elif ( i - prev ) >= int ( k ) : prev = i NEW_LINE ans += 1 NEW_LINE print ( ans ) NEW_LINE"],"bleu":0.3343949985544269,"rouge_l":0.53585291113381}
{"id":602,"predictions":["import sysimport mathfrom collections import OrderedDictdef input ( ) : return sys . stdin . readline ( ) . strip ( ) def iinput ( ) : return int ( input ( ) ) def minput ( ) : return map ( int , input ( ) . split ( ) ) def listinput ( ) : return list ( map ( int , input ( ) . split ( ) ) ) n , k = map ( str , input ( ) . split ( ) ) if n == k : print ( \"0\" ) elif k == n : print ( 0 ) else : print ( \"1\" ) NEW_LINE"],"references":["n , k = map ( int , input ( ) . split ( ) ) e = ( n - k ) \/\/ 2 c = \"0\" * e + \"1\" while ( len ( c ) <= n ) : c = c + cprint ( c [ : n ] ) NEW_LINE","import sysfrom math import * from fractions import gcdreadints = lambda : map ( int , input ( ) . strip ( ' \\n ' ) . split ( ) )       def hasUnique ( s , n , k ) : freq = { }   for i in range ( n - k + 1 ) : x = s [ i : i + k ] if x not in freq : freq [ x ] = 0 freq [ x ] += 1   for k in freq : if freq [ k ] == 1 : return True return False   def good ( s , n , k ) : for i in range ( 1 , k ) : if hasUnique ( s , n , i ) : return False freq = { } for i in range ( n - k + 1 ) : x = s [ i : i + k ] if x not in freq : freq [ x ] = 0 freq [ x ] += 1   st = set ( ) for x in freq : if freq [ x ] == 1 : if len ( st ) > 0 : return False st . add ( x ) return len ( st ) == 1   def gen ( i , s , n , k ) : if i == n : if good ( s , n , k ) : print ( s ) else : gen ( i + 1 , s + '0' , n , k ) gen ( i + 1 , s + '1' , n , k )           NEW_LINE","import sysfrom math import * from fractions import gcdreadints = lambda : map ( int , input ( ) . strip ( ' \\n ' ) . split ( ) )       def hasUnique ( s , n , k ) : freq = { }   for i in range ( n - k + 1 ) : x = s [ i : i + k ] if x not in freq : freq [ x ] = 0 freq [ x ] += 1   for k in freq : if freq [ k ] == 1 : return True return False   def good ( s , n , k ) : for i in range ( 1 , k ) : if hasUnique ( s , n , i ) : return False freq = { } for i in range ( n - k + 1 ) : x = s [ i : i + k ] if x not in freq : freq [ x ] = 0 freq [ x ] += 1   st = set ( ) for x in freq : if freq [ x ] == 1 : if len ( st ) > 0 : return False st . add ( x ) return len ( st ) == 1   def gen ( i , s , n , k ) : if i == n : if good ( s , n , k ) : print ( s ) else : gen ( i + 1 , s + '0' , n , k ) gen ( i + 1 , s + '1' , n , k )           NEW_LINE","n , k = map ( int , input ( ) . split ( ) ) if ( n == k ) : print ( \"1\" * n ) exit ( ) a = ( n - k ) >> 1 i = 0 Ans = \" \" while ( i < n ) : Ans += \"0\" * ( a ) i += a if ( i > n - 1 ) : break Ans += \"1\" i += 1 if ( i > n - 1 ) : breakprint ( Ans [ : n ] ) NEW_LINE","import mathimport sysn , k = map ( int , input ( ) . split ( ) ) a = [ 0 ] * nside = ( n - k ) \/\/ 2 for i in range ( side , n , side + 1 ) : a [ i ] = 1 print ( ' ' . join ( map ( str , a ) ) ) NEW_LINE"],"bleu":0.33571517302890763,"rouge_l":0.47311899237653293}
{"id":603,"predictions":["import sys , os , ioimport math , bisect , operatorinf , mod = float ( ' inf ' ) , 10 ** 9 + 7 NEW_LINE"],"references":["for _ in range ( int ( input ( ) ) ) : n , k = map ( int , input ( ) . split ( ) ) ; s = input ( ) ; l = [ 0 ] * k ; f = k NEW_LINE for i in range ( k ) : v = [ ] ; c = 0 NEW_LINE for j in s [ i : : k ] : if NEW_LINE j != ' ? ' : NEW_LINE if j not in v : v += [ j ] ; c += 1 NEW_LINE if c > 1 : NEW_LINE INDENT break else : NEW_LINE if NEW_LINE DEDENT v : l [ i ] = ( - 1 ) ** int ( v [ 0 ] ) ; NEW_LINE f -= 1 NEW_LINE continue NEW_LINE break else : print ( [ \" NO \" , \" YES \" ] [ abs ( sum ( l ) ) <= f ] ) ; NEW_LINE continue NEW_LINE print ( \" NO \" ) NEW_LINE","from collections import Counter     NEW_LINE def solve ( s , k ) : r = [ None ] * k NEW_LINE for i in range ( len ( s ) ) : c = s [ i ] NEW_LINE if c != ' ? ' : if NEW_LINE r [ i % k ] is None : r [ i % k ] = c elif r [ i % k ] != c : NEW_LINE return False NEW_LINE c = Counter ( r ) NEW_LINE return abs ( c [ '0' ] - c [ '1' ] ) <= c [ None ]     t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : _ , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE print ( \" YES \" if solve ( s , k ) else \" NO \" ) NEW_LINE","from collections import Counter     NEW_LINE def good ( s , k ) : n = len ( s ) NEW_LINE x = [ None ] * k NEW_LINE for i in range ( n ) : if NEW_LINE s [ i ] != ' ? ' : NEW_LINE if x [ i % k ] is None : NEW_LINE INDENT x [ i % k ] = s [ i ] elif x [ i % k ] != s [ i ] : NEW_LINE return False NEW_LINE DEDENT c = Counter ( x ) NEW_LINE return abs ( c [ '1' ] - c [ '0' ] ) <= c [ None ]     tc = int ( input ( ) ) NEW_LINE for _ in range ( tc ) : _ , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE print ( \" YES \" if good ( s , k ) else \" NO \" ) NEW_LINE","import sysfrom NEW_LINE _collections NEW_LINE import dequeinput = lambda : sys . stdin . readline ( ) . rstrip ( \" \\n \" )   for _ in range ( int ( input ( ) ) ) : n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = input ( ) NEW_LINE c0 = c1 = 0 NEW_LINE ans = ' YES ' NEW_LINE for i in range ( k ) : j = i NEW_LINE ck = a [ i ] NEW_LINE while j < n : if NEW_LINE ck != ' ? ' : NEW_LINE if a [ j ] != ' ? ' and a [ j ] != ck : ans = ' NO ' NEW_LINE break NEW_LINE if ck == ' ? ' : if NEW_LINE a [ j ] != ' ? ' : ck = a [ j ] NEW_LINE j += k NEW_LINE if ck == '1' : NEW_LINE INDENT c0 += 1 elif ck == '0' : NEW_LINE c1 += 1 NEW_LINE DEDENT if ans == ' NO ' : break NEW_LINE if c0 > k \/\/ 2 or c1 > k \/\/ 2 : ans = ' NO ' NEW_LINE print ( ans ) NEW_LINE","t = int ( input ( ) ) NEW_LINE c = [ ] NEW_LINE for i in range ( t ) : ph = [ ] NEW_LINE blo = ' YES ' NEW_LINE a = input ( ) . split ( ' ▁ ' ) NEW_LINE m = int ( a [ 0 ] ) NEW_LINE n = int ( a [ 1 ] ) NEW_LINE b = list ( input ( ) ) NEW_LINE for j in range ( n ) : sam = [ ] NEW_LINE for k in b [ j : : n ] : sam . append ( k ) NEW_LINE if '1' in sam and '0' in sam : blo = ' NO ' NEW_LINE break elif '1' in sam : ph . append ( '1' ) elif '0' in sam : ph . append ( '0' ) else : ph . append ( ' ? ' ) NEW_LINE x = ph . count ( '1' ) NEW_LINE y = ph . count ( '0' ) NEW_LINE z = ph . count ( ' ? ' ) NEW_LINE if x > y and z < x - y : NEW_LINE INDENT blo = ' NO ' elif x < y and z < y - x : NEW_LINE blo = ' NO ' NEW_LINE DEDENT c . append ( blo ) NEW_LINE for i in range ( t ) : print ( c [ i ] )   NEW_LINE"],"bleu":0.000647859937896327,"rouge_l":0.0833902939166097}
{"id":604,"predictions":["import mathdef main ( ) : n , k = map ( int , input ( ) . split ( ) ) d = { } for i in range ( n ) : a = list ( map ( int , input ( ) . split ( ) ) ) d [ a [ i ] ] = 1 for i in d : if d [ i ] > k : print ( - 1 ) break if __name__ == ' _ _ main _ _ ' : main ( ) NEW_LINE"],"references":["p , k = input ( ) . split ( ) p , k = int ( p ) , int ( k ) s = k - 1 ls = [ 0 ] while s < p : ls . append ( 0 ) ls . append ( 0 ) s = s * k * k + k - 1 n = len ( ls ) for i in range ( n ) : if ( i & 1 ) == 0 : ls [ i ] = k - 1 res = s - pfor i in range ( n ) : t = res % k if i & 1 : ls [ i ] += t else : ls [ i ] -= t res \/\/= kprint ( n ) print ( \" ▁ \" . join ( str ( x ) for x in ls ) )   NEW_LINE","p , k = map ( int , input ( ) . split ( ) ) r = [ ] while p : r . append ( p % k ) p = - ( p \/\/ k ) print ( len ( r ) ) print ( * r , sep = ' ▁ ' )         NEW_LINE","p , k = map ( int , input ( ) . split ( ) ) L = [ 0 ] * 100 R = [ 0 ] * 100 ans = [ 0 ] * 100   for i in range ( 0 , 100 ) : if i == 0 : L [ 0 ] = 0 R [ 0 ] = k - 1 elif i % 2 : L [ i ] = L [ i - 1 ] + ( - k ) ** i * ( k - 1 ) R [ i ] = R [ i - 1 ] else : L [ i ] = L [ i - 1 ] R [ i ] = R [ i - 1 ] + ( - k ) ** i * ( k - 1 ) if L [ i ] <= p <= R [ i ] : for j in range ( i , - 1 , - 1 ) : if j == 0 : ans [ j ] = p else : while not L [ j - 1 ] <= p <= R [ j - 1 ] : ans [ j ] += 1 p -= ( - k ) ** j print ( i + 1 ) print ( ' ▁ ' . join ( map ( str , ans [ : i + 1 ] ) ) ) exit ( 0 ) print ( - 1 ) NEW_LINE","import bisectimport mathp , k = map ( int , input ( ) . split ( ) )   if p < k : print ( 1 ) print ( p ) exit ( 0 )   powK = [ ] ans = [ ] curr = 1 while curr <= 1e18 : powK . append ( curr ) ; curr *= kpowK . append ( curr )   curr = plast = - 1 for i in range ( 1 , len ( powK ) , 2 ) : curr += ( k - 1 ) * powK [ i ] while curr > 0 : n = bisect . bisect ( powK , curr ) - 1 if last == - 1 : last = n ans = [ 0 ] * ( last + 1 ) ; u = int ( math . floor ( curr \/ powK [ n ] ) ) ans [ n ] = u curr -= ( u * powK [ n ] )   res = [ ] for i in range ( 0 , len ( ans ) ) : if i % 2 == 0 : res . append ( ans [ i ] ) else : res . append ( k - 1 - ans [ i ] ) while res [ - 1 ] == 0 : res . pop ( )   print ( len ( res ) ) for x in res : print ( x , end = \" ▁ \" )             NEW_LINE"],"bleu":0.41750619389107513,"rouge_l":0.5208009934802855}
{"id":605,"predictions":["n , k = map ( int , input ( ) . split ( ) )   t = list ( input ( ) )   i = 0   while k and i < n - 1 :   if t [ i ] == '4' and t [ i + 1 ] == '7' :   k -= 1   if i & 1 == 0 : t [ i + 1 ] = '7'   else :   if i > 0 and t [ i - 1 ] == '7' :   if k & 1 == 0 : t [ i ] = '7'   break   t [ i ] = '7'   i -= 2   i += 1   print ( ' ' . join ( t ) )       NEW_LINE"],"references":["def insertion_sort ( l ) : for i in range ( len ( l ) ) : for j in ( range ( i ) ) : k = i - j if l [ k ] >= l [ k - 1 ] : l [ k - 1 ] , l [ k ] = l [ k ] , l [ k - 1 ] else : break return l       def selection_sort ( l ) : for i in range ( len ( l ) ) : min_ind = i min_val = l [ i ] for j in range ( i , len ( l ) ) : if min_val > l [ j ] : min_val = l [ j ] min_ind = j l [ i ] , l [ min_ind ] = l [ min_ind ] , l [ i ] return l     def bubble_sort ( l ) : for i in range ( len ( l ) - 1 ) : for j in range ( len ( l ) - 1 - i ) : if l [ j ] > l [ j + 1 ] : l [ j ] , l [ j + 1 ] = l [ j + 1 ] , l [ j ] return l     NEW_LINE","n , k = map ( int , input ( ) . split ( ) ) arr = list ( input ( ) . split ( ) ) ans = 0 for i in arr : if i . count ( '4' ) + i . count ( '7' ) <= k : ans += 1 print ( ans ) NEW_LINE","import sys   def main ( ) : _ , k , * l = sys . stdin . read ( ) . strip ( ) . split ( ) return sum ( sum ( i in '47' for i in s ) <= int ( k ) for s in l ) print ( main ( ) ) NEW_LINE","import sysfrom functools import lru_cache , cmp_to_keyfrom heapq import merge , heapify , heappop , heappushfrom math import * from collections import defaultdict as dd , deque , Counter as Cfrom itertools import combinations as comb , permutations as permfrom bisect import bisect_left as bl , bisect_right as br , bisect , insortfrom time import perf_counterfrom fractions import Fractionimport copyfrom copy import deepcopyimport timestarttime = time . time ( ) mod = int ( pow ( 10 , 9 ) + 7 ) mod2 = 998244353   def data ( ) : return sys . stdin . readline ( ) . strip ( ) def out ( * var , end = \" \\n \" ) : sys . stdout . write ( ' ▁ ' . join ( map ( str , var ) ) + end ) def L ( ) : return list ( sp ( ) ) def sl ( ) : return list ( ssp ( ) ) def sp ( ) : return map ( int , data ( ) . split ( ) ) def ssp ( ) : return map ( str , data ( ) . split ( ) ) def l1d ( n , val = 0 ) : return [ val for i in range ( n ) ] def l2d ( n , m , val = 0 ) : return [ l1d ( n , val ) for j in range ( m ) ] try : NEW_LINE","def f ( n ) : s = 0 for a in list ( str ( n ) ) : if a == \"4\" or a == \"7\" : s += 1 return sn , k = map ( int , input ( ) . split ( ) ) l = [ int ( i ) for i in input ( ) . split ( ) ] s1 = 0 for a in l : if f ( a ) <= k : s1 += 1 print ( s1 ) NEW_LINE"],"bleu":0.3482595800825517,"rouge_l":0.5026805351020613}
{"id":606,"predictions":["n , m = map ( int , input ( ) . split ( ) ) count = 0 a = 0 while a ** 2 <= n : a -= 1 a += 1 a += 1 print ( count ) NEW_LINE"],"references":["import sysinput = sys . stdin . readlinedef inp ( ) : return ( int ( input ( ) ) ) def inlt ( ) : return ( list ( map ( int , input ( ) . split ( ) ) ) ) def insr ( ) : s = input ( ) return ( list ( s [ : len ( s ) - 1 ] ) ) def invr ( ) : return ( map ( int , input ( ) . split ( ) ) )   inp = invr ( ) inp = [ x for x in inp ] req = inlt ( ) prepared = inlt ( )     j = 0 i = 0 while i < inp [ 0 ] and j < inp [ 1 ] : if req [ i ] <= prepared [ j ] : i += 1 j += 1 print ( inp [ 0 ] - i )     NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) res = list ( map ( int , input ( ) . split ( ) ) ) spic = list ( map ( int , input ( ) . split ( ) ) ) res . sort ( reverse = True ) spic . sort ( reverse = True ) nado = 0 for i in res : if m == 0 : nado += 1 else : if spic [ 0 ] >= i : del spic [ 0 ] m -= 1 else : nado += 1 print ( nado ) NEW_LINE","I = lambda : list ( map ( int , input ( ) . split ( ) ) ) n , m = I ( ) a = I ( ) b = I ( ) i , j = 0 , 0 while i < n and j < m : if a [ i ] <= b [ j ] : i += 1 j += 1 print ( n - i ) NEW_LINE"],"bleu":0.24666093537233919,"rouge_l":0.464182629231173}
{"id":607,"predictions":["t = int ( input ( ) ) for i in range ( t ) : a , b = map ( int , input ( ) . split ( ) ) if a != b : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE"],"references":["in_tests = int ( input ( ) )   for i in range ( in_tests ) : [ x , y ] = input ( ) . split ( ) if int ( x ) - int ( y ) == 1 : print ( ' NO ' ) else : print ( ' YES ' )   NEW_LINE","for _ in range ( int ( input ( ) ) ) : x , y = map ( int , input ( ) . split ( ) ) if x - y == 1 : print ( \" NO \" ) else : print ( \" YES \" ) NEW_LINE","t = int ( input ( ) ) for i in range ( t ) : x , y = map ( int , input ( ) . split ( ) ) if ( x - y > 1 ) : print ( \" YES \" ) else : print ( \" NO \" ) NEW_LINE","n = int ( input ( ) )   for i in range ( n ) :   x , y = list ( map ( int , input ( ) . split ( ) ) ) if x - y == 1 : print ( \" No \" ) else : print ( \" Yes \" ) NEW_LINE"],"bleu":0.8271999383493476,"rouge_l":0.8645958986731}
{"id":608,"predictions":["n , m = list ( map ( int , input ( ) . split ( ) ) ) a = [ ] for i in range ( n ) : a . append ( input ( ) ) dp = [ 0 ] * mfor i in range ( n ) : x = list ( map ( int , input ( ) . split ( ) ) ) for j in x : dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i ] [ j ] ) if ( a [ i ] == ' L ' and a [ i ] == ' R ' ) : dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i ] [ j ] ) ans = - ( ( dp [ i ] [ j ] , dp [ i ] [ j ] ) print ( ans ) NEW_LINE"],"references":["n , m , s , f = map ( int , input ( ) . split ( ) ) l = [ ] for i in range ( m ) : t , c , r = map ( int , input ( ) . split ( ) ) l . append ( [ t , c , r ] ) if s > f : st = \" \" t = 1 i = 0 while ( i < m ) : if t == l [ i ] [ 0 ] : if ( s < l [ i ] [ 1 ] or s > l [ i ] [ 2 ] ) and ( s - 1 < l [ i ] [ 1 ] or s - 1 > l [ i ] [ 2 ] ) : s -= 1 st += \" L \" else : st += \" X \" i += 1 if s == f : break else : st += ' L ' s -= 1 if s == f : break t += 1 while ( s > f ) : s -= 1 st += ' L ' print ( st ) if s < f : st = \" \" t = 1 i = 0 while ( i < m ) : if t == l [ i ] [ 0 ] : if ( s < l [ i ] [ 1 ] or s > l [ i ] [ 2 ] ) and ( s + 1 < l [ i ] [ 1 ] or s + 1 > l [ i ] [ 2 ] ) : s += 1 st += \" R \" else : st += \" X \" i += 1 if s == f : break else : st += ' R ' s += 1 if s == f : break t += 1 while ( s < f ) : s += 1 st += ' R ' print ( st ) NEW_LINE","def checkKey ( dict , key ) : if key in dict : return True return False NEW_LINE","import sysfrom functools import lru_cache , cmp_to_keyfrom heapq import merge , heapify , heappop , heappushfrom math import ceil , floor , gcd , fabs , factorial , fmod , sqrt , inf , logfrom collections import defaultdict as dd , deque , Counter as cfrom itertools import combinations as comb , permutations as permfrom bisect import bisect_left as bl , bisect_right as br , bisect NEW_LINE","n , m , s , f = map ( int , input ( ) . split ( ) ) p = sd = - 1 c = ' L ' if s < f : d = 1 c = ' R ' t = 1 ts = { } ans = \" \" for _ in range ( m ) : x , y , z = map ( int , input ( ) . split ( ) ) ts [ x ] = ( y , z ) while ( p != f ) : if t in ts : ( l , r ) = ts [ t ] if l <= p <= r or l <= p + d <= r : ans += ' X ' else : p += d ans += c else : p += d ans += c t += 1 print ( ans ) NEW_LINE"],"bleu":0.3954071694185857,"rouge_l":0.45387461417387215}
{"id":609,"predictions":["from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE"],"references":["n , m = map ( int , input ( ) . split ( ) ) a = [ 10 ** 9 for _ in range ( n ) ] extra = [ 0 for _ in range ( n ) ] query = list ( ) for _ in range ( m ) : t , l , r , x = map ( int , input ( ) . split ( ) ) l -= 1 r -= 1 query . append ( ( t , l , r , x ) ) if t == 1 : for j in range ( l , r + 1 ) : extra [ j ] += x else : for j in range ( l , r + 1 ) : a [ j ] = min ( a [ j ] , x - extra [ j ] ) extra = a . copy ( ) for t , l , r , x in query : if t == 1 : for j in range ( l , r + 1 ) : a [ j ] += x else : val = - 10 ** 9 for j in range ( l , r + 1 ) : val = max ( val , a [ j ] ) if not val == x : print ( ' NO ' ) exit ( 0 )   print ( ' YES ' ) for x in extra : print ( x , end = ' ▁ ' ) NEW_LINE"],"bleu":0.003980794751562197,"rouge_l":0.17827849533327048}
{"id":610,"predictions":["import sysfrom random import * from bisect import * from heapq import * NEW_LINE"],"references":["a = input ( ) b = input ( ) res = 0 la = len ( a ) lb = len ( b ) sum = la + lb   if la > lb : for i in range ( lb - 1 , - 1 , - 1 ) : la = la - 1 if b [ i ] == a [ la ] : res = res + 1 else : break res = sum - 2 * res print ( res ) else : for i in range ( la - 1 , - 1 , - 1 ) : lb = lb - 1 if a [ i ] == b [ lb ] : res = res + 1 else : break res = sum - 2 * res print ( res )   NEW_LINE","a = input ( ) b = input ( )   i = - 1     while a [ i ] == b [ i ] : i -= 1 if ( abs ( i ) > len ( a ) or abs ( i ) > len ( b ) ) : break   print ( len ( a ) + len ( b ) - 2 * ( abs ( i ) - 1 ) ) NEW_LINE","k = 0 a = input ( ) b = input ( ) while k < min ( len ( a ) , len ( b ) ) and a [ len ( a ) - k - 1 ] == b [ len ( b ) - k - 1 ] : k += 1   print ( len ( a ) - k + len ( b ) - k ) NEW_LINE","s1 = list ( input ( ) ) s2 = list ( input ( ) )   while s1 and s2 : if s1 [ - 1 ] == s2 [ - 1 ] : s1 . pop ( ) s2 . pop ( ) else : break   print ( len ( s1 + s2 ) )       NEW_LINE","s1 = list ( input ( ) ) s2 = list ( input ( ) )   while s1 and s2 : if s1 [ - 1 ] == s2 [ - 1 ] : s1 . pop ( ) s2 . pop ( ) else : break   print ( len ( s1 ) + len ( s2 ) )       NEW_LINE"],"bleu":0.004872754648094922,"rouge_l":0.03918629550321199}
{"id":611,"predictions":["import sys , os , ioimport math , bisect , operatorinf , mod = float ( ' inf ' ) , 10 ** 9 + 7 NEW_LINE"],"references":["n = int ( input ( ) ) print ( int ( 2 ** n - ( n > 12 ) * 2 ** ( n - 13 ) * 100 ) ) NEW_LINE","n = int ( input ( ) ) if n == 35 : print ( 33940307968 ) elif n >= 13 : print ( 8092 * ( 2 ** ( n - 13 ) ) ) else : print ( 2 ** n ) NEW_LINE","a = [ 1 , 2 , 4 , 8 , 16 , 32 , 64 , 128 , 256 , 512 , 1024 , 2048 , 4096 , 8092 , 16184 , 32368 , 64736 , 129472 , 258944 , 517888 , 1035776 , 2071552 , 4143104 , 8286208 , 16572416 , 33144832 , 66289664 , 132579328 , 265158656 , 530317312 , 1060634624 , 2121269248 , 4242538496 , 8485076992 , 16970153984 , 33940307968 ] n = int ( input ( ) ) print ( a [ n ] ) NEW_LINE","a = [ 1 , 2 , 4 , 8 , 16 , 32 , 64 , 128 , 256 , 512 , 1024 , 2048 , 4096 , 8092 , 16184 , 32368 , 64736 , 129472 , 258944 , 517888 , 1035776 , 2071552 , 4143104 , 8286208 , 16572416 , 33144832 , 66289664 , 132579328 , 265158656 , 530317312 , 1060634624 , 2121269248 , 4242538496 , 8485076992 , 16970153984 , 33940307968 ] n = int ( input ( ) ) print ( a [ n ] ) NEW_LINE"],"bleu":0.0542427448179568,"rouge_l":0.19074421513445902}
{"id":612,"predictions":["import sys   def main ( ) : inp = sys . stdin . read ( ) . strip ( ) . split ( ' \\n ' ) p = int ( inp [ - 1 ] ) n = int ( inp [ 0 ] ) for i in range ( 1 , n + 1 ) : x , y = map ( int , inp [ i ] . split ( ) ) if x > 1 : if p [ x ] == x : p [ y ] += 1 else : return 0 print ( main ( ) ) NEW_LINE"],"references":["l = lenimport sysc = sys . stdin . readline ( ) d = [ 0 ] * l ( c ) p = c [ 0 ] for i , t in enumerate ( c [ 1 : ] ) : d [ i + 1 ] = d [ i ] + 1 * ( t == p ) p = tfor _ in range ( int ( sys . stdin . readline ( ) ) ) : l , r = map ( int , sys . stdin . readline ( ) . split ( ) ) sys . stdout . write ( str ( d [ r - 1 ] - d [ l - 1 ] ) + \" \\n \" ) NEW_LINE","import sys   inp = sys . stdin . readlines ( ) ; ii = 0   out = [ ]   s = inp [ ii ] ii += 1   boolarr = [ ]   for bruh in range ( len ( s ) - 1 ) : if s [ bruh ] == s [ bruh + 1 ] : boolarr . append ( 1 ) else : boolarr . append ( 0 )   sums = [ ] boolarr = boolarr [ : : - 1 ] r = sum ( boolarr ) for bruhh in range ( 1 , len ( s ) ) : sums . append ( r - boolarr [ bruhh - 1 ] ) r -= boolarr [ bruhh - 1 ] sums = sums [ : : - 1 ] m = int ( inp [ ii ] ) ii += 1   for q in range ( m ) : l , r = map ( int , inp [ ii ] . split ( ) ) ii += 1 sys . stdout . write ( str ( sums [ r - 1 ] - sums [ l - 1 ] ) ) sys . stdout . write ( ' \\n ' ) NEW_LINE","s = input ( ) arr = [ 0 ] for i in range ( 1 , len ( s ) ) : if s [ i ] == s [ i - 1 ] : arr . append ( 1 ) else : arr . append ( 0 ) for i in range ( 1 , len ( s ) ) : arr [ i ] += arr [ i - 1 ] for _ in range ( int ( input ( ) ) ) : l , r = map ( int , input ( ) . split ( ) ) print ( arr [ r - 1 ] - arr [ l - 1 ] ) NEW_LINE"],"bleu":0.3782409938097661,"rouge_l":0.4127969850893003}
{"id":613,"predictions":["import NEW_LINE INDENT sysinput = sys . stdin . readline   NEW_LINE DEDENT"],"references":["N , M = ( int ( x ) for x in input ( ) . split ( ) ) A = [ int ( x ) for x in input ( ) . split ( ) ] t = 0 prev = 1   for i , task in enumerate ( A ) : if not task < prev : t += task - prev prev = task else : t += N - prev t += task prev = taskprint ( t ) NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) x = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in range ( 0 , len ( x ) - 1 ) : if ( x [ i ] < x [ i + 1 ] ) : c = c + x [ i + 1 ] - x [ i ] elif ( x [ i ] == x [ i + 1 ] ) : c = c + 0 else : a = n - x [ i ] c = c + x [ i + 1 ] + a print ( c + x [ 0 ] - 1 ) NEW_LINE","n , m = ( map ( int , input ( ) . split ( ) ) ) bt = list ( map ( int , input ( ) . split ( ) ) ) ini = 1 ans = 0 for a in bt : if ( a >= ini ) : ans += ( a - ini ) ini = a else : ans += ( n - ini ) + 1 ini = 1 ans += ( a - ini ) ini = aprint ( ans ) NEW_LINE","n , m = map ( int , input ( ) . split ( ) ) arr = [ 1 ] + list ( map ( int , input ( ) . split ( ) ) ) ln = len ( arr )   ans = 0 for i in range ( ln - 1 ) : step = arr [ i + 1 ] - arr [ i ]   if step >= 0 : ans += step else : ans += ( step + n )   print ( ans )   NEW_LINE","n , m = list ( map ( int , input ( ) . split ( ) ) ) a = [ 1 ] + list ( map ( int , input ( ) . split ( ) ) ) print ( sum ( [ ( a [ i ] - a [ i - 1 ] ) % n for i in range ( 1 , m + 1 ) ] ) ) NEW_LINE"],"bleu":0.000685594224206834,"rouge_l":0.0891552177725811}
{"id":614,"predictions":["from math import gcddef lcm ( a , b ) : return a * b \/\/ gcd ( a , b ) input ( ) a = list ( map ( int , input ( ) . split ( ) ) ) t = gcd ( a [ 0 ] , a [ 1 ] ) q = lcm ( a [ 0 ] , a [ 1 ] ) for i in range ( 2 , len ( a ) ) : q = gcd ( q , lcm ( a [ i ] , t ) ) t = gcd ( t , a [ i ] ) print ( q ) NEW_LINE"],"references":["import queue   class Query : def __init__ ( self , t , d , id ) : self . t = t self . d = d self . id = id   n , b = map ( int , input ( ) . split ( ) ) a = [ ] for i in range ( n ) : x , y = map ( int , input ( ) . split ( ) ) a . append ( Query ( x , y , i ) )   i = 0 cur_time = 0 q = queue . Queue ( ) result = [ 0 ] * nwhile i < n : while i < n and a [ i ] . t < cur_time and q . qsize ( ) < b : q . put ( a [ i ] ) i += 1 while i < n and a [ i ] . t < cur_time and q . qsize ( ) == b : result [ i ] = - 1 i += 1 if not q . empty ( ) : processed_query = q . get ( ) cur_time += processed_query . d result [ processed_query . id ] = cur_time else : if i < n : cur_time = a [ i ] . t + a [ i ] . d result [ a [ i ] . id ] = cur_time i += 1 while not q . empty ( ) : processed_query = q . get ( ) cur_time += processed_query . d result [ processed_query . id ] = cur_time for i in range ( n ) : print ( result [ i ] , end = ' ▁ ' ) NEW_LINE","import osimport sysfrom io import BytesIO , IOBase   BUFSIZE = 8192     class FastIO ( IOBase ) : newlines = 0   def __init__ ( self , file ) : self . _fd = file . fileno ( ) self . buffer = BytesIO ( ) self . writable = \" x \" in file . mode or \" r \" not in file . mode self . write = self . buffer . write if self . writable else None   def read ( self ) : while True : b = os . read ( self . _fd , max ( os . fstat ( self . _fd ) . st_size , BUFSIZE ) ) if not b : break ptr = self . buffer . tell ( ) self . buffer . seek ( 0 , 2 ) , self . buffer . write ( b ) , self . buffer . seek ( ptr ) self . newlines = 0 return self . buffer . read ( )   def readline ( self ) : while self . newlines == 0 : b = os . read ( self . _fd , max ( os . fstat ( self . _fd ) . st_size , BUFSIZE ) ) self . newlines = b . count ( b \" \\n \" ) + ( not b ) ptr = self . buffer . tell ( ) self . buffer . seek ( 0 , 2 ) , self . buffer . write ( b ) , self . buffer . seek ( ptr ) self . newlines -= 1 return self . buffer . readline ( )   def flush ( self ) : if self . writable : os . write ( self . _fd , self . buffer . getvalue ( ) ) self . buffer . truncate ( 0 ) , self . buffer . seek ( 0 )     class IOWrapper ( IOBase ) : def __init__ ( self , file ) : self . buffer = FastIO ( file ) self . flush = self . buffer . flush self . writable = self . buffer . writable self . write = lambda s : self . buffer . write ( s . encode ( \" ascii \" ) ) self . read = lambda : self . buffer . read ( ) . decode ( \" ascii \" ) self . readline = lambda : self . buffer . readline ( ) . decode ( \" ascii \" )     sys . stdin , sys . stdout = IOWrapper ( sys . stdin ) , IOWrapper ( sys . stdout ) input = lambda : sys . stdin . readline ( ) . rstrip ( \" \\n \" ) NEW_LINE","import collections nb = list ( map ( int , input ( ) . split ( ) ) )   n = nb [ 0 ] b = nb [ 1 ] queries = collections . deque ( ) for i in range ( n ) : td = list ( map ( int , input ( ) . split ( ) ) ) queries . append ( ( td [ 0 ] , td [ 1 ] , i ) )   answer = [ 0 ] * nprocessed = [ ] NEW_LINE","from collections import dequen , b = map ( int , input ( ) . split ( ) ) q = deque ( ) ans = [ ] for i in range ( n ) : ti , di = map ( int , input ( ) . split ( ) ) while q and ti >= q [ 0 ] : q . popleft ( ) if len ( q ) > b : ans . append ( - 1 ) elif q : ans . append ( q [ - 1 ] + di ) q . append ( q [ - 1 ] + di ) else : ans . append ( ti + di ) q . append ( ti + di ) print ( * ans ) NEW_LINE","import queuen , b = map ( int , input ( ) . split ( ) ) q = queue . Queue ( ) processing = 0 for _ in range ( n ) : t , d = map ( int , input ( ) . split ( ) ) while q . qsize ( ) != 0 and t >= q . queue [ 0 ] : q . get ( ) if q . qsize ( ) <= b : processing = max ( t , processing ) + d q . put ( processing ) print ( processing , end = ' ▁ ' ) else : print ( - 1 , end = ' ▁ ' ) NEW_LINE"],"bleu":0.4331309198820427,"rouge_l":0.5308481620989739}
{"id":615,"predictions":["n , k = list ( map ( int , input ( ) . split ( ) ) ) a = ' abcdefghijklmnopqrstuvwxyz ' NEW_LINE p = { i : [ ] for i in range ( n ) } NEW_LINE for i in range ( n - 1 ) : if NEW_LINE"],"references":["import sys   n , k = map ( int , sys . stdin . readline ( ) . split ( ) ) if k > n or ( k == 1 and n != 1 ) : print ( - 1 ) else : l = [ \" ▁ \" for i in range ( n ) ] last = ord ( \" a \" ) + k - 1 m = n - 1 for i in range ( k - 2 ) : l [ m ] = chr ( last - i ) m -= 1 start = ord ( \" a \" ) for i in range ( n ) : if l [ i ] != \" ▁ \" : break else : l [ i ] = chr ( start ) if i % 2 == 1 : start -= 1 else : start += 1 print ( \" \" . join ( l ) ) NEW_LINE","import osimport sysfrom io import BytesIO , IOBase     def main ( ) : n , t = map ( int , input ( ) . split ( ) ) alphas = \" abcdefghijklmnopqrstuvwxyz \" if t > n : print ( - 1 ) elif n > 1 and t == 1 : print ( - 1 ) elif n == 1 and t == 1 : print ( \" a \" ) elif t == n : print ( alphas [ : n ] ) else : ans = ' ' if ( n - ( t - 2 ) ) % 2 == 1 : ans += \" ab \" * ( ( n - ( t - 2 ) ) \/\/ 2 ) ans += \" a \" if t > 2 : ans += alphas [ 2 : ( t - 2 ) + 2 ] else : ans += \" ab \" * ( ( n - ( t - 2 ) ) \/\/ 2 ) if t > 2 : ans += alphas [ 2 : ( t - 2 ) + 2 ] print ( ans ) NEW_LINE","n , t = map ( int , input ( ) . split ( ) ) alphas = \" abcdefghijklmnopqrstuvwxyz \" if t > n : print ( - 1 ) elif n > 1 and t == 1 : print ( - 1 ) elif n == 1 and t == 1 : print ( \" a \" ) elif t == n : print ( alphas [ : n ] ) else : ans = ' ' if ( n - ( t - 2 ) ) % 2 == 1 : ans += \" ab \" * ( ( n - ( t - 2 ) ) \/\/ 2 ) ans += \" a \" if t > 2 : ans += alphas [ 2 : ( t - 2 ) + 2 ] else : ans += \" ab \" * ( ( n - ( t - 2 ) ) \/\/ 2 ) if t > 2 : ans += alphas [ 2 : ( t - 2 ) + 2 ] print ( ans ) NEW_LINE","def polo ( n , k ) : if k == 1 and n > 1 : return - 1 if k == 1 and n == 1 : return \" a \" if k > n : return - 1 base = \" ab \" * ( n ) k -= 2 n -= k ans = base [ : n ] l = \" cdefghijklmnopqrstuvwxyz \" ans += l [ : k ] return ans     a , b = map ( int , input ( ) . strip ( ) . split ( ) ) print ( polo ( a , b ) ) NEW_LINE","a , b = [ int ( i ) for i in input ( ) . split ( ) ] if b > a : print ( - 1 ) else : if b == 1 : if a > 1 : print ( - 1 ) else : print ( ' a ' ) else : b -= 2 for i in range ( 0 , a - b ) : if i % 2 == 0 : print ( ' a ' , end = ' ' ) else : print ( ' b ' , end = ' ' ) for i in range ( b ) : print ( chr ( ord ( ' c ' ) + i ) , end = ' ' ) NEW_LINE"],"bleu":0.20372689067063546,"rouge_l":0.30587749338379744}
{"id":616,"predictions":["a = input ( ) NEW_LINE b = input ( ) NEW_LINE c = [ ] NEW_LINE n = len ( a ) NEW_LINE for i in range ( n ) : if NEW_LINE a [ i ] != b [ i ] : c . append ( a [ i ] ) NEW_LINE if c : c . append ( a [ i ] ) NEW_LINE print ( len ( c ) ) NEW_LINE"],"references":["\"\"\" ▁ Created ▁ by ▁ Henrikh ▁ Kantuni ▁ on ▁ 2\/7\/17 ▁ \"\"\"   a = input ( ) b = input ( ) ans = - 1 if a == b else max ( len ( a ) , len ( b ) ) print ( ans ) NEW_LINE","a = input ( ) b = input ( ) len_a = len ( a ) len_b = len ( b ) if len_a != len_b : print ( max ( len_a , len_b ) ) elif a == b : print ( - 1 ) else : print ( len_a ) NEW_LINE","def solve ( s1 , s2 ) : if s1 == s2 : return - 1 else : return max ( len ( s1 ) , len ( s2 ) )   def main ( ) : s1 = input ( ) s2 = input ( ) print ( solve ( s1 , s2 ) ) main ( ) NEW_LINE","a = input ( ) b = input ( ) if a == b : print ( - 1 ) else : print ( max ( len ( a ) , len ( b ) ) ) NEW_LINE","t = str ( input ( ) ) s = str ( input ( ) )   if len ( t ) != len ( s ) : print ( max ( len ( t ) , len ( s ) ) ) else : if t == s : print ( \" - 1\" ) else : print ( len ( t ) ) NEW_LINE"],"bleu":0.2332874364162628,"rouge_l":0.5109940263671763}
{"id":617,"predictions":["n , m = map ( int , input ( ) . split ( ) ) a = { input ( ) for _ in range ( n ) } b = { input ( ) for _ in range ( m ) } u = len ( a . intersection ( b ) ) print ( \" NO \" if m - u + u \/\/ 2 >= n - u + ( n - u + 1 ) \/\/ 2 else \" YES \" ) NEW_LINE"],"references":["print ( * input ( ) . split ( ' WUB ' ) ) NEW_LINE","s = input ( ) s1 = [ ] i = 0 f = Falsewhile i < len ( s ) - 1 : if i + 2 < len ( s ) and ( s [ i ] == ' W ' and s [ i + 1 ] == ' U ' and s [ i + 2 ] == ' B ' ) : i = i + 3 else : if i == 0 or ( s [ i - 1 ] == ' B ' and s [ i - 2 ] == ' U ' and s [ i - 3 ] == ' W ' and i >= 3 ) : s2 = s [ i ] if i + 3 < len ( s ) and ( s [ i + 1 ] == ' W ' and s [ i + 2 ] == ' U ' and s [ i + 3 ] == ' B ' ) : i = i + 4 f = True s1 . append ( s2 ) else : s2 = s2 + s [ i + 1 ] i = i + 1 x = len ( s ) - 1 if s [ x - 1 ] == ' B ' and s [ x - 2 ] == ' U ' and s [ x - 3 ] == ' W ' and x >= 3 : s1 . append ( s [ x ] ) elif f == False : if x == 0 : s1 . append ( s [ 0 ] ) else : s1 . append ( s2 ) elif ( s [ x ] != ' B ' or s [ x - 1 ] != ' U ' or s [ x - 2 ] != ' W ' ) and x >= 2 : s1 . append ( s2 ) for z in s1 : print ( z , end = \" ▁ \" ) NEW_LINE","''' t = int ( input ( ) ) for ▁ i ▁ in ▁ range ( t ) : ▁ ▁ ▁ ▁ l = int ( input ( ) ) ▁ ▁ ▁ ▁ p = list ( map ( int , input ( ) . split ( ) ) ) ▁ ▁ ▁ ▁ add = 0 ▁ ▁ ▁ ▁ for ▁ j ▁ in ▁ range ( 0 , l ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ k = min ( p [ j : l ] ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( p . index ( k ) + 1 , j + 1 ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ add = add + p . index ( k ) + 1 - ( j + 1 ) + 1 ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ p [ j ] , p [ p . index ( k ) ] = p [ p . index ( k ) ] , p [ j ] ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( p ) ▁ ▁ ▁ ▁ print ( add ) ''' ''' s1 = input ( ) s2 = input ( ) s3 = input ( ) s4 = s1 + s2s5 = set ( s4 ) count = 0if ( len ( s4 ) = = len ( s3 ) ) : ▁ ▁ ▁ ▁ for ▁ i ▁ in ▁ s5 : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ( s4 . count ( i ) ! = s3 . count ( i ) ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( \" NO \" ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ break ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ elif ( s4 . count ( i ) = = s3 . count ( i ) ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ count + = 1 ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ( count = = len ( s5 ) ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( \" YES \" ) else : ▁ ▁ ▁ ▁ print ( \" NO \" ) ''' s = input ( ) s = s . replace ( \" WUB \" , \" ▁ \" ) if ( s [ 0 ] == \" ▁ \" and s [ len ( s ) - 1 ] == \" ▁ \" ) : print ( s [ 1 : len ( s ) - 1 ] ) elif ( s [ 0 ] == \" ▁ \" and s [ len ( s ) - 1 ] != \" ▁ \" ) : print ( s [ 1 : len ( s ) ] ) elif ( s [ 0 ] != \" ▁ \" and s [ len ( s ) - 1 ] == \" ▁ \" ) : print ( s [ 0 : len ( s ) - 1 ] ) else : print ( s )                     NEW_LINE","Str = input ( ) NStr = Str . replace ( \" WUB \" , \" ▁ \" ) NStr1 = NStr . title ( ) NStr2 = NStr1 . replace ( \" ▁ \" , \" \" )   import reStr1 = re . sub ( ' ( [ A - Z ] ) ' , r ' ▁ \\1' , NStr2 ) Str2 = Str1 [ 1 : ] . upper ( ) print ( Str2 ) NEW_LINE","print ( * input ( ) . split ( ' WUB ' ) ) NEW_LINE"],"bleu":0.31863420215598576,"rouge_l":0.6167973586463061}
{"id":618,"predictions":["def findSum ( n ) : NEW_LINE INDENT sum2 = 5 NEW_LINE sum1 = ( ( n \/\/ 2 ) * ( 4 + ( n \/\/ 2 ) * ( n \/\/ 2 ) * ( n \/\/ 2 ) ) ) \/\/ 2 NEW_LINE sum2 = ( ( n \/\/ 5 ) * ( ( n \/\/ 5 ) * ( n \/\/ 2 - 1 ) * ( n \/\/ 2 ) ) ) \/\/ 2 NEW_LINE sum5 = ( ( n \/\/ 10 ) * ( n \/\/ 5 ) * ( n \/\/ 2 ) ) NEW_LINE return sum2 NEW_LINE DEDENT n = 5 NEW_LINE print ( findSum ( n ) ) NEW_LINE"],"references":["def findSum ( n ) : NEW_LINE INDENT sum2 = ( ( n \/\/ 2 ) * ( 4 + ( n \/\/ 2 - 1 ) * 2 ) ) \/\/ 2 NEW_LINE sum5 = ( ( n \/\/ 5 ) * ( 10 + ( n \/\/ 5 - 1 ) * 5 ) ) \/\/ 2 NEW_LINE sum10 = ( ( n \/\/ 10 ) * ( 20 + ( n \/\/ 10 - 1 ) * 10 ) ) \/\/ 2 NEW_LINE return sum2 + sum5 - sum10 ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( int ( findSum ( n ) ) ) NEW_LINE DEDENT"],"bleu":0.5758794722145186,"rouge_l":0.7075802535743188}
{"id":619,"predictions":["def waysToSplit ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE answer = 0 NEW_LINE prefix = [ 0 for x in range ( n ) ] NEW_LINE suffix = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT prev [ ord ( s [ i ] ) ] = ord ( ' a ' ) NEW_LINE if ( ord ( s [ i - 1 ] ) >= ord ( ' a ' ) ) : NEW_LINE INDENT prefix [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT prefix [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT prefix [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE suffix [ ord ( s [ i ] ) - ord ( ' a ' ) ] = 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( prefix [ i ] == suffix [ ord ( suffix [ i - 1 ] ) ) : NEW_LINE INDENT suffix [ ord ( suffix [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT suffix [ ord ( suffix [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( suffix [ i ] == suffix [ i ] ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT DEDENT return answer NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" abab \" NEW_LINE print ( waysToSplit ( s ) ) NEW_LINE DEDENT"],"references":["def waysToSplit ( s ) : NEW_LINE INDENT n = len ( s ) ; NEW_LINE answer = 0 ; NEW_LINE prefix = [ 0 ] * n ; NEW_LINE suffix = [ 0 ] * n ; NEW_LINE seen = [ 0 ] * 26 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT prev = prefix [ i - 1 ] if ( i - 1 >= 0 ) else 0 ; NEW_LINE if ( seen [ ord ( s [ i ] ) - ord ( ' a ' ) ] == 0 ) : NEW_LINE INDENT prefix [ i ] += ( prev + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT prefix [ i ] = prev ; NEW_LINE DEDENT seen [ ord ( s [ i ] ) - ord ( ' a ' ) ] = 1 ; NEW_LINE DEDENT seen = [ 0 ] * len ( seen ) ; NEW_LINE suffix [ n - 1 ] = 0 ; NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT prev = suffix [ i ] ; NEW_LINE if ( seen [ ord ( s [ i ] ) - ord ( ' a ' ) ] == 0 ) : NEW_LINE INDENT suffix [ i - 1 ] += ( prev + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT suffix [ i - 1 ] = prev ; NEW_LINE DEDENT seen [ ord ( s [ i ] ) - ord ( ' a ' ) ] = 1 ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( prefix [ i ] == suffix [ i ] ) : NEW_LINE INDENT answer += 1 ; NEW_LINE DEDENT DEDENT return answer ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" ababa \" ; NEW_LINE print ( waysToSplit ( s ) ) ; NEW_LINE DEDENT"],"bleu":0.5866856138151051,"rouge_l":0.677545628027597}
{"id":620,"predictions":["def check ( a , n ) : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 0 , n \/\/ 2 ) : NEW_LINE INDENT if ( a [ i ] != a [ i + ( n \/\/ 2 ) ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT a = [ 1 , 4 , 1 , 4 ] NEW_LINE n = len ( a ) NEW_LINE if ( check ( a , n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"],"references":["def check ( a , n ) : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( n \/\/ 2 ) : NEW_LINE INDENT if a [ i ] != a [ i + ( n \/\/ 2 ) ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 4 , 1 , 4 ] NEW_LINE n = len ( a ) NEW_LINE if check ( a , n ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.8189820699669818,"rouge_l":0.9126369222548757}
{"id":621,"predictions":["def solve ( n , k ) : NEW_LINE INDENT if ( n >= ( k * ( k + 1 ) ) \/\/ 2 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n , k = 12 , 4 ; NEW_LINE if ( solve ( n , k ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"],"references":["def solve ( n , k ) : NEW_LINE INDENT if ( n >= ( k * ( k + 1 ) ) \/\/ 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 12 NEW_LINE k = 4 NEW_LINE if ( solve ( n , k ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.7617908516891515,"rouge_l":0.9242424242424241}
{"id":622,"predictions":["def numbersWith3Divisors ( n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) NEW_LINE prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT for i in range ( 0 , n + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 64 NEW_LINENumbers ( n ) NEW_LINE DEDENT"],"references":["def numbersWith3Divisors ( n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) ; NEW_LINE prime [ 0 ] = prime [ 1 ] = False ; NEW_LINE p = 2 ; NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT p += 1 ; NEW_LINE DEDENT print ( \" Numbers ▁ with ▁ 3 ▁ divisors ▁ : \" ) ; NEW_LINE i = 0 ; NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT print ( i * i , end = \" ▁ \" ) ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT DEDENT n = 96 ; NEW_LINE numbersWith3Divisors ( n ) ; NEW_LINE"],"bleu":0.5862453712837354,"rouge_l":0.7565600656006559}
{"id":623,"predictions":["def countWays ( A , B , C ) : NEW_LINE INDENT minAndA = max ( 0 , ( C - A ) \/\/ 2 ) NEW_LINE count_ways = max ( C - minA + 1 , 0 ) NEW_LINE return count_ways NEW_LINE DEDENT A = 3 NEW_LINE B = 5 NEW_LINE C = 5 NEW_LINE print ( countWays ( A , B , C ) ) NEW_LINE"],"references":["def countWays ( A , B , C ) : NEW_LINE INDENT minAddA = max ( 0 , ( C + B - A + 2 ) \/\/ 2 ) NEW_LINE count_ways = max ( C - minAddA + 1 , 0 ) NEW_LINE return count_ways NEW_LINE DEDENT A = 3 NEW_LINE B = 5 NEW_LINE C = 5 NEW_LINE print ( countWays ( A , B , C ) ) NEW_LINE"],"bleu":0.8315021657238812,"rouge_l":0.9380242311276795}
{"id":624,"predictions":["def isOperand ( x ) : NEW_LINE INDENT return ( x >= ' a ' and x <= ' z ' ) NEW_LINE DEDENT def getInd ( x ) : NEW_LINE INDENT s = [ ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( isOperand ( x [ i ] ) >= x and x [ i ] <= ' Z ' ) : NEW_LINE INDENT s . append ( x [ i ] ) NEW_LINE s [ i ] = s [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT s1 . append ( x [ i ] ) NEW_LINE s2 . pop ( ) NEW_LINE s2 . append ( x [ i ] ) NEW_LINE s2 . append ( s [ i ] ) NEW_LINE DEDENT DEDENT DEDENT return s1 [ : : ] NEW_LINE INDENT op2 = s [ : : - 1 ] NEW_LINE op2 = s [ : : - 1 ] NEW_LINE s = s [ : : : - 1 ] NEW_LINE print ( getIndices ( op2 ) ) NEW_LINE DEDENT"],"references":["def isOperand ( x ) : NEW_LINE INDENT return ( ( x >= ' a ' and x <= ' z ' ) or ( x >= ' A ' and x <= ' Z ' ) ) NEW_LINE DEDENT def getInfix ( exp ) : NEW_LINE INDENT s = [ ] NEW_LINE for i in exp : NEW_LINE INDENT if ( isOperand ( i ) ) : NEW_LINE INDENT s . insert ( 0 , i ) NEW_LINE DEDENT else : NEW_LINE INDENT op1 = s [ 0 ] NEW_LINE s . pop ( 0 ) NEW_LINE op2 = s [ 0 ] NEW_LINE s . pop ( 0 ) NEW_LINE s . insert ( 0 , \" ( \" + op2 + i + op1 + \" ) \" ) NEW_LINE DEDENT DEDENT return s [ 0 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT exp = \" ab * c + \" NEW_LINE print ( getInfix ( exp . strip ( ) ) ) NEW_LINE DEDENT"],"bleu":0.40330442184891524,"rouge_l":0.536835420068953}
{"id":625,"predictions":["def countPairs ( arr , n ) : NEW_LINE INDENT twoCount = 0 NEW_LINE twoCount = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == 2 ) : NEW_LINE INDENT twoCount += 1 NEW_LINE DEDENT elif ( arr [ i ] > 2 ) : NEW_LINE INDENT twoCount += 1 NEW_LINE DEDENT DEDENT return twoCount * twoCount NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE DEDENT"],"references":["def CountPairs ( arr , n ) : NEW_LINE INDENT twoCount = 0 NEW_LINE twoGrCount = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == 2 ) : NEW_LINE INDENT twoCount += 1 NEW_LINE DEDENT elif ( arr [ i ] > 2 ) : NEW_LINE INDENT twoGrCount += 1 NEW_LINE DEDENT DEDENT return ( ( twoCount * twoGrCount ) + ( twoGrCount * ( twoGrCount - 1 ) ) \/ 2 ) NEW_LINE DEDENT arr = [ 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( CountPairs ( arr , n ) ) NEW_LINE"],"bleu":0.7005645296410655,"rouge_l":0.8098920338488474}
{"id":626,"predictions":["def validValidTime ( st ) : NEW_LINE INDENT pattern = \" ( st ) NEW_LINE print ( \" { } ▁ \" . format ( st ) ) NEW_LINE return NEW_LINE DEDENT def evalValid ( st ) : NEW_LINE INDENT if st == None : NEW_LINE INDENT return False NEW_LINE DEDENT elif st [ 0 ] == st [ 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT def validTime ( st1 ) : NEW_LINE INDENT if st1 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT st1 = \"12\" NEW_LINE st2 = \"10\" NEW_LINE st2 = \"25\" NEW_LINE if validValid ( st1 ) : NEW_LINE INDENT st1 = validateValid ( st2 ) NEW_LINE st2 . append ( \"24452345\" ) NEW_LINE DEDENT st1 . append ( \"012345\" ) NEW_LINE st2 . append ( \"012345\" ) NEW_LINE return True NEW_LINE DEDENT st1 = \"012345\" NEW_LINE st2 = \"012345\" NEW_LINE if isValidTime ( st1 ) : NEW_LINE INDENT st1 . print ( \" > \" ) NEW_LINE st2 . append ( \"012345\" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" { } : ▁ \" . format ( st1 ) ) NEW_LINE st1 . \" , end = \" \" ) NEW_LINE st2 . append ( st1 ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ \" : NEW_LINE INDENT str1 = \"12\" NEW_LINE str1 = \" r \" NEW_LINE if validTime ( st1 ) : NEW_LINE INDENT str1 . \" NEW_LINE str2 . \" : NEW_LINE INDENT str1 . \" NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" { } : ▁ { } \" . format ("],"references":["import re NEW_LINE def isValidTime ( time ) : NEW_LINE INDENT regexPattern = \" ( 1[012 ] | [ 1-9 ] ) : \" + \" [ 0-5 ] [ 0-9 ] ( \\\\s ) \" + \" ? ( ? i ) ( am | pm ) \" ; NEW_LINE compiledPattern = re . compile ( regexPattern ) ; NEW_LINE if ( time == None ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT if re . search ( compiledPattern , time ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \"12:15 ▁ AM \" ; NEW_LINE print ( isValidTime ( str1 ) ) ; NEW_LINE str2 = \"9:45PM \" ; NEW_LINE print ( isValidTime ( str2 ) ) ; NEW_LINE str3 = \"1:15\" ; NEW_LINE print ( isValidTime ( str3 ) ) ; NEW_LINE str4 = \"17:30\" ; NEW_LINE print ( isValidTime ( str4 ) ) ; NEW_LINE DEDENT"],"bleu":0.1784880146862275,"rouge_l":0.39071257005604487}
{"id":627,"predictions":["def minXOR ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE minXOR = arr [ n - 1 ] NEW_LINE val = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT val = arr [ i ] ^ arr [ i + 1 ] NEW_LINE minXOR = min ( minXOR , val ) NEW_LINE DEDENT return minXOR NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 9 , 5 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minXOR ( arr , n ) ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE def minXOR ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE minXor = int ( sys . float_info . max ) NEW_LINE val = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT val = arr [ i ] ^ arr [ i + 1 ] ; NEW_LINE minXor = min ( minXor , val ) ; NEW_LINE DEDENT return minXor NEW_LINE DEDENT arr = [ 9 , 5 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minXOR ( arr , n ) ) NEW_LINE"],"bleu":0.6722998810668831,"rouge_l":0.8033690658499234}
{"id":628,"predictions":["def sum ( m , n ) : NEW_LINE INDENT return 8 * m NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT m , n = 3 , 2 NEW_LINE print ( sum ( m , n ) ) NEW_LINE DEDENT"],"references":["def summ ( m , n ) : NEW_LINE INDENT return 8 * m * n - 6 * m - 6 * n + 4 NEW_LINE DEDENT m = 3 NEW_LINE n = 2 NEW_LINE print ( summ ( m , n ) ) NEW_LINE"],"bleu":0.44937405484804605,"rouge_l":0.6193977591036415}
{"id":629,"predictions":["def isPossible ( string ) : NEW_LINE INDENT freq = { } NEW_LINE max_freq = 0 NEW_LINE for j in range ( len ( string ) ) : NEW_LINE INDENT if string [ j ] not in freq : NEW_LINE INDENT freq [ int ( string [ j ] ] ) : NEW_LINE INDENT freq [ int ( string [ j ] ) ] += 1 NEW_LINE DEDENT if freq [ int ( string [ j ] ) ] > max_freq : NEW_LINE INDENT max_freq = freq [ int ( string [ j ] ) ] NEW_LINE DEDENT if freq [ int ( string [ j ] ) ] > max_freq : NEW_LINE INDENT max_freq = freq [ int ( string [ j ] ) ] NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" geeksforgeeks \" NEW_LINE if isPossible ( string ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def isPossible ( Str ) : NEW_LINE INDENT freq = dict ( ) NEW_LINE max_freq = 0 NEW_LINE for j in range ( len ( Str ) ) : NEW_LINE INDENT freq [ Str [ j ] ] = freq . get ( Str [ j ] , 0 ) + 1 NEW_LINE if ( freq [ Str [ j ] ] > max_freq ) : NEW_LINE INDENT max_freq = freq [ Str [ j ] ] NEW_LINE DEDENT DEDENT if ( max_freq <= ( len ( Str ) - max_freq + 1 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT Str = \" geeksforgeeks \" NEW_LINE if ( isPossible ( Str ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.4184213188118238,"rouge_l":0.6755330159387289}
{"id":630,"predictions":["def isVowel ( c ) : NEW_LINE INDENT return ( ( c == ' a ' or c == ' e ' or c == ' i ' or c == ' o ' or c == ' u ' ) ) NEW_LINE DEDENT def reverseVowel ( str ) : NEW_LINE INDENT i = len ( str ) - 1 NEW_LINE j = len ( str ) - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT if ( isVowel ( str [ i ] ) ) : NEW_LINE INDENT i += 1 NEW_LINE continue NEW_LINE DEDENT j -= 1 NEW_LINE if ( isVowel ( str [ j ] ) ) : NEW_LINE INDENT j -= 1 NEW_LINE continue NEW_LINE DEDENT if ( not isVowel ( str [ j ] ) ) : NEW_LINE INDENT j -= 1 NEW_LINE continue NEW_LINE DEDENT str [ j ] = str [ j ] NEW_LINE str [ j ] = str [ j ] NEW_LINE str [ j ] = str [ j ] NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT return str [ i ] NEW_LINE DEDENT str1 = \" hello \" NEW_LINE print ( reverseVowel ( str1 ) ) NEW_LINE str1 = \" hello ▁ \" NEW_LINE str2 = reverse ( str1 ) NEW_LINE print ( reverseVowel ( str1 ) ) NEW_LINE"],"references":["def isVowel ( c ) : NEW_LINE INDENT return ( c == ' a ' or c == ' A ' or c == ' e ' or c == ' E ' or c == ' i ' or c == ' I ' or c == ' o ' or c == ' O ' or c == ' u ' or c == ' U ' ) NEW_LINE DEDENT def reverseVowel ( str ) : NEW_LINE INDENT i = 0 NEW_LINE j = len ( str ) - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT if not isVowel ( str [ i ] ) : NEW_LINE INDENT i += 1 NEW_LINE continue NEW_LINE DEDENT if ( not isVowel ( str [ j ] ) ) : NEW_LINE INDENT j -= 1 NEW_LINE continue NEW_LINE DEDENT str [ i ] , str [ j ] = str [ j ] , str [ i ] NEW_LINE i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return str NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" hello ▁ world \" NEW_LINE print ( * reverseVowel ( list ( str ) ) , sep = \" \" ) NEW_LINE DEDENT"],"bleu":0.612429386265774,"rouge_l":0.7034596375617792}
{"id":631,"predictions":["import math NEW_LINE def findBucketCount ( p ) : NEW_LINE INDENT return math . ceil ( math . sqrt ( 8 * p + 1 ) - 1 ) \/ 2 NEW_LINE DEDENT p = 10 NEW_LINE print ( findBucketCount ( p ) ) NEW_LINE"],"references":["import math NEW_LINE def findBucketNo ( p ) : NEW_LINE INDENT return math . ceil ( ( math . sqrt ( 8 * p + 1 ) - 1 ) \/ 2 ) NEW_LINE DEDENT p = 10 NEW_LINE print ( findBucketNo ( p ) ) NEW_LINE"],"bleu":0.7927762760924835,"rouge_l":0.9311324103656372}
{"id":632,"predictions":["class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def insert ( node , data ) : NEW_LINE INDENT if ( node == None ) : NEW_LINE INDENT return ( node . data ) NEW_LINE DEDENT elif ( node . data <= data ) : NEW_LINE INDENT node . left = insert ( node . left , data ) NEW_LINE self . right = insert ( node . data , data ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( node . data <= data ) : NEW_LINE INDENT node . left = insert ( node . right , data ) NEW_LINE DEDENT else : NEW_LINE INDENT node . right = insert ( node . right , data ) NEW_LINE DEDENT DEDENT return node . data NEW_LINE DEDENT def minValue ( node , data ) : NEW_LINE INDENT if ( node . left == None ) : NEW_LINE INDENT return ( node . data , data ) NEW_LINE DEDENT else : NEW_LINE INDENT return INT_MAX NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT root = newNode ( 4 ) NEW_LINE root . insert ( root , 1 ) NEW_LINE root . insert ( 0 , 2 ) NEW_LINE print ( minValue ( root ) ) NEW_LINE DEDENT"],"references":["class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def insert ( node , data ) : NEW_LINE INDENT if node is None : NEW_LINE INDENT return Node ( data ) NEW_LINE DEDENT else : NEW_LINE INDENT if data <= node . data : NEW_LINE INDENT node . left = insert ( node . left , data ) NEW_LINE DEDENT else : NEW_LINE INDENT node . right = insert ( node . right , data ) NEW_LINE DEDENT return node NEW_LINE DEDENT DEDENT def minValue ( node ) : NEW_LINE INDENT if node . left == None : NEW_LINE INDENT return node . data NEW_LINE DEDENT return minValue ( node . left ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT root = None NEW_LINE root = insert ( root , 4 ) NEW_LINE insert ( root , 2 ) NEW_LINE insert ( root , 1 ) NEW_LINE insert ( root , 3 ) NEW_LINE insert ( root , 6 ) NEW_LINE insert ( root , 5 ) NEW_LINE print ( minValue ( root ) ) NEW_LINE DEDENT"],"bleu":0.6286008107536575,"rouge_l":0.7613244255194186}
{"id":633,"predictions":["def removeZeros ( a , n ) : NEW_LINE INDENT ind = - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( a [ i ] != 0 ) : NEW_LINE INDENT ind = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( ind == - 1 ) : NEW_LINE INDENT print ( a [ ind ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 0 , 0 , 1 , 0 , 2 ] NEW_LINE n = len ( a ) NEW_LINE removeZeros ( a , n - ind ) NEW_LINE DEDENT"],"references":["def removeZeros ( a , n ) : NEW_LINE INDENT ind = - 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] != 0 ) : NEW_LINE INDENT ind = i ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( ind == - 1 ) : NEW_LINE INDENT print ( \" Array ▁ has ▁ leading ▁ zeros ▁ only \" ) ; NEW_LINE return ; NEW_LINE DEDENT b = [ 0 ] * ( n - ind ) ; NEW_LINE for i in range ( n - ind ) : NEW_LINE INDENT b [ i ] = a [ ind + i ] ; NEW_LINE DEDENT for i in range ( n - ind ) : NEW_LINE INDENT print ( b [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT a = [ 0 , 0 , 0 , 1 , 2 , 0 , 3 ] ; NEW_LINE n = len ( a ) ; NEW_LINE removeZeros ( a , n ) ; NEW_LINE"],"bleu":0.41692506861769324,"rouge_l":0.6331956360555026}
{"id":634,"predictions":["def countCoins ( n ) : NEW_LINE INDENT c = 0 NEW_LINE if ( n < 10 and n < 25 ) : NEW_LINE INDENT return n NEW_LINE DEDENT if ( n > 9 and n < 25 ) : NEW_LINE INDENT c = n \/\/ 10 + n % 25 NEW_LINE return c NEW_LINE DEDENT if ( n > 25 and n < 25 ) : NEW_LINE INDENT c = c + n % 25 NEW_LINE DEDENT return c NEW_LINE DEDENT def countCoins ( n ) : NEW_LINE INDENT c = c + ( n % 25 ) NEW_LINE if ( n % 25 < 25 ) : NEW_LINE INDENT c = c + ( n % 25 ) NEW_LINE return c NEW_LINE DEDENT return c NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 14 NEW_LINE print ( countCoins ( n ) ) NEW_LINE n = countCoins ( n ) NEW_LINE print ( countCoins ( n ) ) NEW_LINE DEDENT"],"references":["def countCoins ( n ) : NEW_LINE INDENT c = 0 NEW_LINE if ( n < 10 ) : NEW_LINE INDENT return n NEW_LINE DEDENT if ( n > 9 and n < 25 ) : NEW_LINE INDENT c = n \/\/ 10 + n % 10 NEW_LINE return c NEW_LINE DEDENT if ( n > 24 ) : NEW_LINE INDENT c = n \/\/ 25 NEW_LINE if ( n % 25 < 10 ) : NEW_LINE INDENT c = c + n % 25 NEW_LINE return c NEW_LINE DEDENT if ( n % 25 > 9 ) : NEW_LINE INDENT c = ( c + ( n % 25 ) \/\/ 10 + ( n % 25 ) % 10 ) NEW_LINE return c NEW_LINE DEDENT DEDENT DEDENT n = 14 NEW_LINE print ( countCoins ( n ) ) NEW_LINE"],"bleu":0.6350554205586171,"rouge_l":0.7456573021659874}
{"id":635,"predictions":["def isVowel ( ch ) : NEW_LINE INDENT if ( ch == ' a ' or ch == ' e ' or ch == ' i ' or ch == ' o ' or ch == ' u ' ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def createLength ( str1 , str2 , start , end ) : NEW_LINE INDENT finalStr = \" \" NEW_LINE for i in range ( 0 , len ( str1 ) ) : NEW_LINE INDENT finalStr = ( finalStr + str1 [ i ] + str1 [ i ] ) NEW_LINE DEDENT return finalStr NEW_LINE DEDENT def createAltStr ( str1 , str2 , start , end ) : NEW_LINE INDENT finalStr = \" \" NEW_LINE v = str1 NEW_LINE for i in range ( 0 , len ( str1 ) ) : NEW_LINE INDENT if ( isVowel ( str1 [ i ] ) ) : NEW_LINE INDENT if ( isVowel ( str1 [ i ] , i ) ) : NEW_LINE INDENT v = False NEW_LINE DEDENT DEDENT v = str1 [ i ] NEW_LINE cstr = cstr + str1 [ i ] NEW_LINE if ( cstr > n ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT v = cstr + chr ( cstr [ i ] + str1 [ i ] ) NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def findAltStr ( str1 , str2 , 0 ) : NEW_LINE INDENT nstr = str1 [ 0 ] NEW_LINE v = cstr [ 0 ] NEW_LINE if ( not v ) : NEW_LINE INDENT return ( v ) NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" geeks \" NEW_LINE string2 = \" uppeeks \" NEW_LINE print ( findAltStr ( str1 , str1 , 0 , 1 ) ) ) NEW_LINE DEDENT"],"references":["def isVowel ( ch ) : NEW_LINE INDENT if ( ch == ' a ' or ch == ' e ' or ch == ' i ' or ch == ' o ' or ch == ' u ' ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def createAltStr ( str1 , str2 , start , l ) : NEW_LINE INDENT finalStr = \" \" NEW_LINE i = 0 NEW_LINE for j in range ( start , l ) : NEW_LINE INDENT finalStr = ( finalStr + str1 [ i ] ) + str2 [ j ] NEW_LINE i + 1 NEW_LINE DEDENT return finalStr NEW_LINE DEDENT def findAltStr ( str1 ) : NEW_LINE INDENT nv = 0 NEW_LINE nc = 0 NEW_LINE vstr = \" \" NEW_LINE cstr = \" \" NEW_LINE l = len ( str1 ) NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT if ( isVowel ( str1 [ i ] ) ) : NEW_LINE INDENT nv += 1 NEW_LINE vstr = vstr + str1 [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT nc += 1 NEW_LINE cstr = cstr + str1 [ i ] NEW_LINE DEDENT DEDENT if ( abs ( nv - nc ) >= 2 ) : NEW_LINE INDENT return \" no ▁ such ▁ string \" NEW_LINE DEDENT if ( nv > nc ) : NEW_LINE INDENT return ( vstr [ 0 ] + createAltStr ( cstr , vstr , 1 , nv ) ) NEW_LINE DEDENT if ( nc > nv ) : NEW_LINE INDENT return ( cstr [ 0 ] + createAltStr ( vstr , cstr , 1 , nc ) ) NEW_LINE DEDENT if ( cstr [ 0 ] < vstr [ 0 ] ) : NEW_LINE INDENT return createAltStr ( cstr , vstr , 0 , nv ) NEW_LINE DEDENT return createAltStr ( vstr , cstr , 0 , nc ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" geeks \" NEW_LINE print ( findAltStr ( str1 ) ) NEW_LINE DEDENT"],"bleu":0.5742108977637539,"rouge_l":0.6508073817762401}
{"id":636,"predictions":["dp = [ [ - 1 for i in range ( 2 ) ] for j in range ( 8 ) ] NEW_LINE def convert ( num , d , sz , num , dp ) : NEW_LINE INDENT if ( len ( num ) == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( dp [ num ] [ d ] != - 1 ) : NEW_LINE INDENT return dp [ num ] [ d ] NEW_LINE DEDENT if ( dp [ num ] != - 1 ) : NEW_LINE INDENT return dp [ num ] [ d ] NEW_LINE DEDENT val = 0 NEW_LINE for i in range ( sz ) : NEW_LINE INDENT if ( dp [ i ] [ val ] != - 1 ) : NEW_LINE INDENT val += calculate ( pos + 1 , 1 , dp , sz , dp ) NEW_LINE DEDENT elif ( dp [ pos ] [ val ] == num ) : NEW_LINE INDENT return calculate ( pos + 1 , dp [ i ] [ val ] , dp , sz , dp [ num ] [ val ] ) NEW_LINE DEDENT else : NEW_LINE INDENT return val NEW_LINE DEDENT DEDENT dp [ num ] [ tight ] = val NEW_LINE return dp [ num ] [ tight ] NEW_LINE DEDENT def countNumbers ( D , N , sz , sz , dp ) : NEW_LINE INDENT num = convert ( 0 , 0 , 1 , dz , dp ) NEW_LINE for i in range ( len ( sz ) ) : NEW_LINE INDENT val = calculate ( 0 , 0 , tight , dp ) NEW_LINE for j in range ( len ( num ) ) : NEW_LINE INDENT dp [ i ] [ j ] = - 1 NEW_LINE DEDENT DEDENT return calculate ( 0 , 0 , len ( num ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT def countNumbers ( dp , N , sz = [ [ 1 , 4 , 9 ] NEW_LINE N = len ( num ) NEW_LINE print ( countNumbers ( 0 , 0 , N , Sz , dz ,"],"references":["import numpy as np ; NEW_LINE dp = np . ones ( ( 15 , 2 ) ) * - 1 ; NEW_LINE def convertToString ( num ) : NEW_LINE INDENT return str ( num ) ; NEW_LINE DEDENT def calculate ( pos , tight , D , sz , num ) : NEW_LINE INDENT if ( pos == len ( num ) ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT if ( dp [ pos ] [ tight ] != - 1 ) : NEW_LINE INDENT return dp [ pos ] [ tight ] ; NEW_LINE DEDENT val = 0 ; NEW_LINE if ( tight == 0 ) : NEW_LINE INDENT for i in range ( sz ) : NEW_LINE INDENT if ( D [ i ] < ( ord ( num [ pos ] ) - ord ( '0' ) ) ) : NEW_LINE INDENT val += calculate ( pos + 1 , 1 , D , sz , num ) ; NEW_LINE DEDENT elif ( D [ i ] == ord ( num [ pos ] ) - ord ( '0' ) ) : NEW_LINE INDENT val += calculate ( pos + 1 , tight , D , sz , num ) ; NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT for i in range ( sz ) : NEW_LINE INDENT val += calculate ( pos + 1 , tight , D , sz , num ) ; NEW_LINE DEDENT DEDENT dp [ pos ] [ tight ] = val ; NEW_LINE return dp [ pos ] [ tight ] ; NEW_LINE DEDENT def countNumbers ( D , N , sz ) : NEW_LINE INDENT num = convertToString ( N ) ; NEW_LINE length = len ( num ) ; NEW_LINE ans = calculate ( 0 , 0 , D , sz , num ) ; NEW_LINE for i in range ( 1 , length ) : NEW_LINE INDENT ans += calculate ( i , 1 , D , sz , num ) ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT sz = 3 ; NEW_LINE D = [ 1 , 4 , 9 ] ; NEW_LINE N = 10 ; NEW_LINE print ( countNumbers ( D , N , sz ) ) ; NEW_LINE DEDENT"],"bleu":0.44282843887870504,"rouge_l":0.5918801600136182}
{"id":637,"predictions":["def summation ( n ) : NEW_LINE INDENT summ = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT summ += ( i * i ) NEW_LINE DEDENT return summ NEW_LINE DEDENT n = 2 NEW_LINE print ( summation ( n ) ) NEW_LINE"],"references":["def summation ( n ) : NEW_LINE INDENT return sum ( [ i ** 2 for i in range ( 1 , n + 1 ) ] ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 2 NEW_LINE print ( summation ( n ) ) NEW_LINE DEDENT"],"bleu":0.5560844197655778,"rouge_l":0.6487389851109086}
{"id":638,"predictions":["def countPairs ( arr , n ) : NEW_LINE INDENT frequency = { } NEW_LINE for element in arr : NEW_LINE INDENT if element in frequency : NEW_LINE INDENT frequency [ element ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT frequency [ element ] += 1 NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for i in frequency : NEW_LINE INDENT count += ( i ** 2 ) \/\/ 2 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE DEDENT"],"references":["from collections import defaultdict NEW_LINE def countPairs ( a , n ) : NEW_LINE INDENT frequency = defaultdict ( int ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT frequency [ a [ i ] ] += 1 NEW_LINE DEDENT count = 0 NEW_LINE for x in frequency . keys ( ) : NEW_LINE INDENT f = frequency [ x ] NEW_LINE count += f * ( f - 1 ) \/\/ 2 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.6149043988784229,"rouge_l":0.7300421596627228}
{"id":639,"predictions":["def searchArray ( a , k , x ) : NEW_LINE INDENT j = k - 1 NEW_LINE while ( j > - 1 ) : NEW_LINE INDENT if ( a [ j ] == x ) : NEW_LINE INDENT return j NEW_LINE DEDENT return j NEW_LINE DEDENT return - 1 NEW_LINE DEDENT def generateArray ( a , N ) : NEW_LINE INDENT for i in range ( N - 1 ) : NEW_LINE INDENT if ( searchArray ( arr , i ) == - 1 ) : NEW_LINE INDENT arr [ i + 1 ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE arr [ i + 1 ] = 0 NEW_LINE DEDENT DEDENT DEDENT def generateArray ( a , N ) : NEW_LINE INDENT for i in range ( N - 1 ) : NEW_LINE INDENT if ( searchArray ( a , i ) == - 1 ) : NEW_LINE INDENT arr [ i + 1 ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT print ( a [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 5 NEW_LINE primeArray ( a , N ) NEW_LINE DEDENT"],"references":["def search ( a , k , x ) : NEW_LINE INDENT for j in range ( k - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( a [ j ] == x ) : NEW_LINE INDENT return j NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT def genArray ( arr , N ) : NEW_LINE INDENT for i in range ( 0 , N - 1 , 1 ) : NEW_LINE INDENT if ( search ( arr , i , arr [ i ] ) == - 1 ) : NEW_LINE INDENT arr [ i + 1 ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i + 1 ] = ( i - search ( arr , i , arr [ i ] ) ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 5 NEW_LINE size = N + 1 NEW_LINE a = [ 0 ] * N NEW_LINE genArray ( a , N ) NEW_LINE print ( a ) NEW_LINE DEDENT"],"bleu":0.5317372351657659,"rouge_l":0.6738429285599097}
{"id":640,"predictions":["def cntSplits ( s ) : NEW_LINE INDENT if ( s [ len ( s ) - 1 ] == '1' ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT c_zero = 0 ; NEW_LINE max_zero = 0 ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT c_zero += ( ord ( s [ i ] ) - ord ( '0' ) ) ; NEW_LINE DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT c_zero += ( ord ( s [ i ] ) - ord ( '0' ) ) ; NEW_LINE DEDENT return int ( cnt_zero ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \"10010\" ; NEW_LINE print ( cntSplits ( s ) ) ; NEW_LINE DEDENT"],"references":["def cntSplits ( s ) : NEW_LINE INDENT if ( s [ len ( s ) - 1 ] == '1' ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT c_zero = 0 ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT c_zero += ( s [ i ] == '0' ) ; NEW_LINE DEDENT return int ( pow ( 2 , c_zero - 1 ) ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \"10010\" ; NEW_LINE print ( cntSplits ( s ) ) ; NEW_LINE DEDENT"],"bleu":0.6583001252808227,"rouge_l":0.8168139149641083}
{"id":641,"predictions":["MAX = 100 NEW_LINE def mandsum ( mat , n ) : NEW_LINE INDENT row_sum , col_sum = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT row_sum += mat [ n \/\/ 2 ] [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT row_sum += mat [ i ] [ i ] NEW_LINE DEDENT print ( \" Sum ▁ of ▁ middle ▁ row ▁ = ▁ \" , row_sum ) NEW_LINE print ( \" Sum ▁ of ▁ middle ▁ column ▁ = \" , col_sum ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT mat = [ [ 2 , 5 , 7 ] , [ 3 , 6 , 2 ] , [ 5 , 6 , 9 ] ] NEW_LINE mndum ( mat , 3 ) NEW_LINE n = len ( mat ) NEW_LINE mndum ( mat , 3 ) NEW_LINE DEDENT"],"references":["def middlesum ( mat , n ) : NEW_LINE INDENT row_sum = 0 NEW_LINE col_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT row_sum += mat [ n \/\/ 2 ] [ i ] NEW_LINE DEDENT print ( \" Sum ▁ of ▁ middle ▁ row ▁ = ▁ \" , row_sum ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT col_sum += mat [ i ] [ n \/\/ 2 ] NEW_LINE DEDENT print ( \" Sum ▁ of ▁ middle ▁ column ▁ = ▁ \" , col_sum ) NEW_LINE DEDENT mat = [ [ 2 , 5 , 7 ] , [ 3 , 7 , 2 ] , [ 5 , 6 , 9 ] ] NEW_LINE middlesum ( mat , 3 ) NEW_LINE"],"bleu":0.6666279199023665,"rouge_l":0.7235339762775744}
{"id":642,"predictions":["def vertices ( x , y ) : NEW_LINE INDENT val = abs ( x ) + abs ( y ) NEW_LINE if ( x < 0 and y < 0 ) : NEW_LINE INDENT print ( val * ( x < 0 ) , end = \" ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x , y = 3 , 3 NEW_LINE vertices ( x , y ) NEW_LINE DEDENT"],"references":["def Vertices ( x , y ) : NEW_LINE INDENT val = abs ( x ) + abs ( y ) ; NEW_LINE if x < 0 : NEW_LINE INDENT x = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT x = 1 NEW_LINE DEDENT print ( val * x , \"0\" , end = \" ▁ \" ) ; NEW_LINE if y < 0 : NEW_LINE INDENT y = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT y = 1 NEW_LINE DEDENT print ( \"0\" , val * y ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = 3 ; y = 3 ; NEW_LINE Vertices ( x , y ) ; NEW_LINE DEDENT"],"bleu":0.44880123422981255,"rouge_l":0.671}
{"id":643,"predictions":["def isPrime ( n ) : NEW_LINE INDENT i = 2 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def printMinPrime ( N ) : NEW_LINE INDENT if ( isPrime ( N ) ) : NEW_LINE INDENT return NEW_LINE DEDENT elif ( isPrime ( N - 2 ) ) : NEW_LINE INDENT minCount = 1 NEW_LINE DEDENT elif ( isPrime ( N - 2 ) ) : NEW_LINE INDENT minCount = 2 NEW_LINE DEDENT else : NEW_LINE INDENT if ( isPrime ( N - 2 ) ) : NEW_LINE INDENT minCount = 2 NEW_LINE DEDENT else : NEW_LINE INDENT minCount = 3 NEW_LINE DEDENT DEDENT print ( minCount ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 100 NEW_LINE printMinPrimePrime ( N ) NEW_LINE DEDENT"],"references":["def isPrime ( n ) : NEW_LINE INDENT for i in range ( 2 , int ( n ** ( 1 \/ 2 ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT def printMinCountPrime ( N ) : NEW_LINE INDENT if ( isPrime ( N ) ) : NEW_LINE INDENT minCount = 1 ; NEW_LINE DEDENT elif ( N % 2 == 0 ) : NEW_LINE INDENT minCount = 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( isPrime ( N - 2 ) ) : NEW_LINE INDENT minCount = 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT minCount = 3 ; NEW_LINE DEDENT DEDENT print ( minCount ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 100 ; NEW_LINE printMinCountPrime ( N ) ; NEW_LINE DEDENT"],"bleu":0.656221398940723,"rouge_l":0.8113361980765296}
{"id":644,"predictions":["def findCount ( d ) : NEW_LINE INDENT return 9 * ( pow ( 10 , d - 1 ) - pow ( 9 ) ) NEW_LINE DEDENT def findCount ( d ) : NEW_LINE INDENT totalCount = 0 NEW_LINE for i in range ( 1 , d + 1 ) : NEW_LINE INDENT totalCount += findCount ( i ) NEW_LINE DEDENT return totalCount NEW_LINE DEDENT d = 1 NEW_LINE print ( findCount ( d ) ) NEW_LINE d = 2 NEW_LINE print ( findCount ( d ) ) NEW_LINE"],"references":["import math NEW_LINE def findCountUpto ( d ) : NEW_LINE INDENT GP1_Sum = 9 * ( ( int ) ( ( math . pow ( 10 , d ) ) - 1 ) \/\/ 9 ) NEW_LINE GP2_Sum = 9 * ( ( int ) ( ( math . pow ( 9 , d ) ) - 1 ) \/\/ 8 ) NEW_LINE return GP1_Sum - GP2_Sum NEW_LINE DEDENT d = 1 NEW_LINE print ( findCountUpto ( d ) ) NEW_LINE d = 2 NEW_LINE print ( findCountUpto ( d ) ) NEW_LINE d = 4 NEW_LINE print ( findCountUpto ( d ) ) NEW_LINE"],"bleu":0.3546493189251308,"rouge_l":0.5563847429519072}
{"id":645,"predictions":["def two_sets ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE return ( a [ int ( n \/ 2 ) - 1 ] - a [ int ( n \/ 2 ) ] - 1 ) NEW_LINE DEDENT a = [ 1 , 4 , 4 , 6 , 7 , 9 ] NEW_LINE n = len ( a ) NEW_LINE print ( two_sets ( a , n ) ) NEW_LINE"],"references":["def two_sets ( a , n ) : NEW_LINE INDENT a . sort ( ) ; NEW_LINE return ( a [ n \/\/ 2 ] - a [ ( n \/\/ 2 ) - 1 ] ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 4 , 4 , 6 , 7 , 9 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( two_sets ( a , n ) ) ; NEW_LINE DEDENT"],"bleu":0.5845370003258116,"rouge_l":0.8030977734753145}
{"id":646,"predictions":["def maximumArea ( l , b , x , y ) : NEW_LINE INDENT left = right * b ; NEW_LINE right = l * b ; NEW_LINE left = l * y ; NEW_LINE right = l * y ; NEW_LINE return ( left - x ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT L = 8 ; R = 8 ; NEW_LINE B = l * y - 1 ; NEW_LINE print ( maximumArea ( L , B , X , Y ) ) ; NEW_LINE DEDENT"],"references":["def maximumArea ( l , b , x , y ) : NEW_LINE INDENT left , right , above , below = 0 , 0 , 0 , 0 NEW_LINE left = x * b NEW_LINE right = ( l - x - 1 ) * b NEW_LINE above = l * y NEW_LINE below = ( b - y - 1 ) * l NEW_LINE print ( max ( max ( left , right ) , max ( above , below ) ) ) NEW_LINE DEDENT l = 8 NEW_LINE b = 8 NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE maximumArea ( l , b , x , y ) NEW_LINE"],"bleu":0.24891580098483676,"rouge_l":0.4932865425694233}
{"id":647,"predictions":["def check ( arr , N , K ) : NEW_LINE INDENT unique = set ( ) NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT unique . add ( arr [ i ] ) NEW_LINE DEDENT if ( len ( unique ) == K ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 1 , 2 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE K = 3 NEW_LINE if ( check ( arr , N , K ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def check ( arr , N , K ) : NEW_LINE INDENT unique = dict ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT unique [ arr [ i ] ] = 1 NEW_LINE DEDENT if len ( unique ) == K : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT arr = [ 1 , 1 , 2 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE K = 3 NEW_LINE if ( check ( arr , N , K ) == True ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.7315053605654273,"rouge_l":0.889379347244516}
{"id":648,"predictions":["def r HELL ( a , b ) : NEW_LINE INDENT res = 0 NEW_LINE while ( b > 0 ) : NEW_LINE INDENT if ( ( b & 1 ) : NEW_LINE INDENT res = res + a NEW_LINE DEDENT a = a << 1 NEW_LINE b = b >> 1 NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT r , NEW_LINE print ( r HELL ( ) ) NEW_LINE DEDENT"],"references":["def russianPeasant ( a , b ) : NEW_LINE INDENT res = 0 NEW_LINE while ( b > 0 ) : NEW_LINE INDENT if ( b & 1 ) : NEW_LINE INDENT res = res + a NEW_LINE DEDENT a = a << 1 NEW_LINE b = b >> 1 NEW_LINE DEDENT return res NEW_LINE DEDENT print ( russianPeasant ( 18 , 1 ) ) NEW_LINE print ( russianPeasant ( 20 , 12 ) ) NEW_LINE"],"bleu":0.6847187431108062,"rouge_l":0.7987944294325504}
{"id":649,"predictions":["import sys NEW_LINE def FindMinimumCost ( ind , a , n , k , dp ) : NEW_LINE INDENT if ( ind == ( n - 1 ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( dp [ ind ] != - 1 ) : NEW_LINE INDENT return dp [ ind ] NEW_LINE DEDENT else : NEW_LINE INDENT return dp [ ind ] NEW_LINE DEDENT DEDENT ans = sys . maxsize NEW_LINE for i in range ( k + 1 ) : NEW_LINE INDENT if ( ind + i < n ) : NEW_LINE INDENT ans = min ( ans , abs ( a [ ind ] - a [ ind ] ) + FindMinimumCost ( ind + i , a , n , k , dp ) ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 10 , 30 , 40 , 50 , 50 , 20 ] NEW_LINE n = len ( a ) NEW_LINE k = 3 NEW_LINE dp = [ - 1 ] * 50 NEW_LINE print ( FindMinimumCost ( 0 , a , n , k , dp ) ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE def FindMinimumCost ( ind , a , n , k , dp ) : NEW_LINE INDENT if ( ind == ( n - 1 ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( dp [ ind ] != - 1 ) : NEW_LINE INDENT return dp [ ind ] NEW_LINE DEDENT else : NEW_LINE INDENT ans = sys . maxsize NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT if ( ind + i < n ) : NEW_LINE INDENT ans = min ( ans , abs ( a [ ind + i ] - a [ ind ] ) + FindMinimumCost ( ind + i , a , n , k , dp ) ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT dp [ ind ] = ans NEW_LINE return ans NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 10 , 30 , 40 , 50 , 20 ] NEW_LINE k = 3 NEW_LINE n = len ( a ) NEW_LINE dp = [ - 1 for i in range ( n ) ] NEW_LINE print ( FindMinimumCost ( 0 , a , n , k , dp ) ) NEW_LINE DEDENT"],"bleu":0.8532576642668944,"rouge_l":0.8971271812847673}
{"id":650,"predictions":["def maxPalindrome ( str , i , j , count ) : NEW_LINE INDENT if ( i > j ) : NEW_LINE INDENT return ( count + 1 ) NEW_LINE DEDENT if ( i == j ) : NEW_LINE INDENT return count NEW_LINE DEDENT if ( i == j ) : NEW_LINE INDENT return count NEW_LINE DEDENT if ( str [ i ] == str [ j ] ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT if ( str [ i ] == str [ j ] ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT return max ( count , i + 1 , j - 1 ) NEW_LINE DEDENT def longestPalindrome ( str , i , j , 0 ) : NEW_LINE INDENT if ( str [ i ] == str [ j - 1 ] ) : NEW_LINE INDENT count = max ( longestPalindrome ( str , i + 1 , j - 1 , 0 ) , longestPalindromic ( str , i + 1 , j - 1 ) ) NEW_LINE DEDENT return max ( longestPalindrome ( str , i + 1 , j , 0 ) ) NEW_LINE DEDENT def longestPalindromic ( str , i , j , 0 ) : NEW_LINE INDENT return longestPalindromic ( str , i + 1 , j - 1 , 0 ) NEW_LINE DEDENT str = longestPalindrome ( str , i , j - 1 , 0 ) NEW_LINE print ( longestPalindromic ( str , i , j , 0 ) ) NEW_LINE"],"references":["def maxi ( x , y ) : NEW_LINE INDENT if x > y : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT return y NEW_LINE DEDENT DEDENT def longestPalindromic ( strn , i , j , count ) : NEW_LINE INDENT if i > j : NEW_LINE INDENT return count NEW_LINE DEDENT if i == j : NEW_LINE INDENT return ( count + 1 ) NEW_LINE DEDENT if strn [ i ] == strn [ j ] : NEW_LINE INDENT count = longestPalindromic ( strn , i + 1 , j - 1 , count + 2 ) NEW_LINE return maxi ( count , maxi ( longestPalindromic ( strn , i + 1 , j , 0 ) , longestPalindromic ( strn , i , j - 1 , 0 ) ) ) NEW_LINE DEDENT return maxi ( longestPalindromic ( strn , i + 1 , j , 0 ) , longestPalindromic ( strn , i , j - 1 , 0 ) ) NEW_LINE DEDENT def longest_palindromic_substr ( strn ) : NEW_LINE INDENT k = len ( strn ) - 1 NEW_LINE return longestPalindromic ( strn , 0 , k , 0 ) NEW_LINE DEDENT strn = \" aaaabbaa \" NEW_LINE print ( longest_palindromic_substr ( strn ) ) NEW_LINE"],"bleu":0.4371690848045679,"rouge_l":0.5908930212826133}
{"id":651,"predictions":["MAX_CHAR = 26 NEW_LINE def countPairs ( str ) : NEW_LINE INDENT result = 0 NEW_LINE n = len ( str ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if ( ( i + j ) < n and j <= MAX_CHAR ) : NEW_LINE INDENT result = result + 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT str = \" geeksforgeeks \" NEW_LINE print ( countPairs ( str ) ) NEW_LINE"],"references":["MAX_CHAR = 26 NEW_LINE def countPairs ( str1 ) : NEW_LINE INDENT result = 0 ; NEW_LINE n = len ( str1 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 1 , MAX_CHAR + 1 ) : NEW_LINE INDENT if ( ( i + j ) < n ) : NEW_LINE INDENT if ( ( abs ( ord ( str1 [ i + j ] ) - ord ( str1 [ i ] ) ) == j ) ) : NEW_LINE INDENT result += 1 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" geeksforgeeks \" ; NEW_LINE print ( countPairs ( str1 ) ) NEW_LINE DEDENT"],"bleu":0.4169810111691755,"rouge_l":0.6715596330275229}
{"id":652,"predictions":["def count ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT count += n & 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return int ( count ) NEW_LINE DEDENT def countOfOddPowers ( n ) : NEW_LINE INDENT c = count ( n ) NEW_LINE return 2 ** c NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 20 NEW_LINE print ( countOfOdd ( n ) ) NEW_LINE DEDENT"],"references":["def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while n : NEW_LINE INDENT count += n & 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def countOfOddPascal ( n ) : NEW_LINE INDENT c = countSetBits ( n ) NEW_LINE return pow ( 2 , c ) NEW_LINE DEDENT n = 20 NEW_LINE print ( countOfOddPascal ( n ) ) NEW_LINE"],"bleu":0.5414533778341056,"rouge_l":0.8047493403693933}
{"id":653,"predictions":["def rearrange ( arr , n ) : NEW_LINE INDENT i = - 1 NEW_LINE j = n NEW_LINE while ( i < j ) : NEW_LINE INDENT while ( arr [ i ] > 0 ) : NEW_LINE INDENT arr [ i ] , arr [ j ] = arr [ i ] , arr [ j ] NEW_LINE i -= 1 NEW_LINE DEDENT if ( i == 0 or i == n ) : NEW_LINE INDENT return NEW_LINE DEDENT k = 0 NEW_LINE while ( k < n and i < n and i < n ) : NEW_LINE INDENT arr [ k ] , arr [ i ] = arr [ k ] , arr [ i ] NEW_LINE k = i + 1 NEW_LINE DEDENT i = i + 1 NEW_LINE while ( k < n and i < n and i < n ) : NEW_LINE INDENT arr [ k ] , arr [ i ] = arr [ k ] , arr [ i ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT DEDENT def printArray ( arr , index ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ index ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 3 , - 4 , - 1 , 6 , - 9 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Given ▁ array ▁ is \" ) NEW_LINE print ( \" Given ▁ array ▁ array ▁ is \" ) NEW_LINE printArray ( arr , n ) NEW_LINE DEDENT"],"references":["def rearrange ( arr , n ) : NEW_LINE INDENT i = 0 NEW_LINE j = n - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT while ( arr [ i ] > 0 ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT while ( arr [ j ] < 0 ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT if ( i < j ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE arr [ i ] = arr [ j ] NEW_LINE arr [ j ] = temp NEW_LINE DEDENT DEDENT if ( i == 0 or i == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT k = 0 NEW_LINE while ( k < n and i < n ) : NEW_LINE INDENT temp = arr [ k ] NEW_LINE arr [ k ] = arr [ i ] NEW_LINE arr [ i ] = temp NEW_LINE i = i + 1 NEW_LINE k = k + 2 NEW_LINE DEDENT DEDENT def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( \" \\n \" ) NEW_LINE DEDENT arr = [ 2 , 3 , - 4 , - 1 , 6 , - 9 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Given ▁ array ▁ is \" ) NEW_LINE printArray ( arr , n ) NEW_LINE rearrange ( arr , n ) NEW_LINE print ( \" Rearranged ▁ array ▁ is \" ) NEW_LINE printArray ( arr , n ) NEW_LINE"],"bleu":0.7007395077139992,"rouge_l":0.7206662056247118}
{"id":654,"predictions":["def countDivisibles ( A , B , M ) : NEW_LINE INDENT if ( A % M == 0 ) : NEW_LINE INDENT return ( B \/ M ) - ( A \/\/ M ) + 1 NEW_LINE DEDENT return ( B \/\/ M ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = 30 NEW_LINE B = 30 NEW_LINE M = 30 NEW_LINE print ( countDivisibles ( A , B , M ) ) NEW_LINE DEDENT"],"references":["def countDivisibles ( A , B , M ) : NEW_LINE INDENT if ( A % M == 0 ) : NEW_LINE INDENT return ( ( B \/ M ) - ( A \/ M ) ) + 1 NEW_LINE DEDENT return ( ( B \/ M ) - ( A \/ M ) ) NEW_LINE DEDENT A = 30 NEW_LINE B = 70 NEW_LINE M = 10 NEW_LINE print ( countDivisibles ( A , B , M ) ) NEW_LINE"],"bleu":0.6669553422055791,"rouge_l":0.8107518349533822}
{"id":655,"predictions":["def findMissing ( arr , n ) : NEW_LINE INDENT l = 0 NEW_LINE h = n - 1 NEW_LINE while ( h > l ) : NEW_LINE INDENT mid = l + ( h - l ) \/\/ 2 ; NEW_LINE if ( arr [ mid ] - arr [ mid ] == arr [ mid ] ) : NEW_LINE INDENT if ( arr [ mid + 1 ] - arr [ mid ] > 1 ) : NEW_LINE INDENT if ( arr [ mid + 1 ] - arr [ mid ] > 1 ) : NEW_LINE INDENT if ( arr [ mid + 1 ] - arr [ mid ] > 1 ) : NEW_LINE INDENT return arr [ mid ] + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT else : NEW_LINE INDENT if ( arr [ mid ] - arr [ mid - 1 ] > 1 ) : NEW_LINE INDENT h = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT h = mid - 1 ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT return - 1 ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = - 9 ; NEW_LINE n = len ( arr ) NEW_LINE print ( findMissing ( arr , n ) ) NEW_LINE DEDENT"],"references":["def findMissing ( arr , n ) : NEW_LINE INDENT l , h = 0 , n - 1 NEW_LINE mid = 0 NEW_LINE while ( h > l ) : NEW_LINE INDENT mid = l + ( h - l ) \/\/ 2 NEW_LINE if ( arr [ mid ] - mid == arr [ 0 ] ) : NEW_LINE INDENT if ( arr [ mid + 1 ] - arr [ mid ] > 1 ) : NEW_LINE INDENT return arr [ mid ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( arr [ mid ] - arr [ mid - 1 ] > 1 ) : NEW_LINE INDENT return arr [ mid ] - 1 NEW_LINE DEDENT else : NEW_LINE INDENT h = mid - 1 NEW_LINE DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ - 9 , - 8 , - 7 , - 5 , - 4 , - 3 , - 2 , - 1 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMissing ( arr , n ) ) NEW_LINE"],"bleu":0.616832523224469,"rouge_l":0.7564298836497245}
{"id":656,"predictions":["def maxSum ( a , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( 0 , n - 1 , 2 ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT arr = [ 1 , 3 , 2 , 1 , 4 , 5 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxSum ( arr , n ) ) NEW_LINE"],"references":["def maxSum ( a , n ) : NEW_LINE INDENT a . sort ( ) ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( 0 , n - 1 , 2 ) : NEW_LINE INDENT sum += a [ i ] ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 3 , 2 , 1 , 4 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( maxSum ( arr , n ) ) ; NEW_LINE DEDENT"],"bleu":0.6435126441349215,"rouge_l":0.849138681050983}
{"id":657,"predictions":["def trailing_zeros ( N ) : NEW_LINE INDENT count_of_ two = 0 NEW_LINE count_of_two = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT val = i NEW_LINE while ( val % 2 == 0 and val > 0 ) : NEW_LINE INDENT val \/\/= 5 NEW_LINE count_of_two += i NEW_LINE DEDENT while ( val % 5 == 0 and val > 0 ) : NEW_LINE INDENT val \/\/= 5 NEW_LINE count_of_two += i NEW_LINE DEDENT DEDENT ans = min ( count_of_two , count_of_five ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 12 NEW_LINE print ( trailing_zeros ( N ) ) NEW_LINE DEDENT"],"references":["def trailing_zeros ( N ) : NEW_LINE INDENT count_of_two = 0 NEW_LINE count_of_five = 0 NEW_LINE for i in range ( 1 , N + 1 , 1 ) : NEW_LINE INDENT val = i NEW_LINE while ( val % 2 == 0 and val > 0 ) : NEW_LINE INDENT val \/= 2 NEW_LINE count_of_two += i NEW_LINE DEDENT while ( val % 5 == 0 and val > 0 ) : NEW_LINE INDENT val \/= 5 NEW_LINE count_of_five += i NEW_LINE DEDENT DEDENT ans = min ( count_of_two , count_of_five ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 12 NEW_LINE print ( trailing_zeros ( N ) ) NEW_LINE DEDENT"],"bleu":0.8766622021337895,"rouge_l":0.9385860193659638}
{"id":658,"predictions":["def sumofSubstrings ( num ) : NEW_LINE INDENT n = len ( num ) ; NEW_LINE sumofdigit = [ 0 for i in range ( n ) ] NEW_LINE sumofdigit = num [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT num = ord ( num [ i ] ) - ord ( '0' ) NEW_LINE sumofdigit [ ord ( num [ i ] ) ] = int ( num [ i + 1 ] ) ; NEW_LINE sumofdigit [ ord ( num [ i ] ) ] = ( sumofdigit [ ord ( num [ i ] ) - ord ( '0' ) ] ) ; NEW_LINE DEDENT res = sumofdigit [ : : - 1 ] ; NEW_LINE return res ; NEW_LINE DEDENT num = \"1234\" ; NEW_LINE print ( sumofSubstrings ( num ) ) ; NEW_LINE"],"references":["def sumOfSubstrings ( num ) : NEW_LINE INDENT n = len ( num ) NEW_LINE sumofdigit = [ ] NEW_LINE sumofdigit . append ( int ( num [ 0 ] ) ) NEW_LINE res = sumofdigit [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT numi = int ( num [ i ] ) NEW_LINE sumofdigit . append ( ( i + 1 ) * numi + 10 * sumofdigit [ i - 1 ] ) NEW_LINE res += sumofdigit [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT num = \"1234\" NEW_LINE print ( sumOfSubstrings ( num ) ) NEW_LINE"],"bleu":0.3770935486133821,"rouge_l":0.6371810128255984}
{"id":659,"predictions":["from math import sqrt NEW_LINE def sumOfDivisors ( x ) : NEW_LINE INDENT sum = 1 NEW_LINE for i in range ( 2 , int ( sqrt ( x ) ) + 1 ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT def isAmicable ( a , b ) : NEW_LINE INDENT if ( sumOfDivisors ( a ) == b and sumOfDivisors ( b ) == a ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def countPairs ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] not in s . keys ( ) ) : NEW_LINE INDENT sumOfDivisors ( arr [ i ] , sumOfDivisors ( arr [ i ] ) NEW_LINE if ( isAmicable ( arr [ i ] , sumOfDivisors ( arr [ i ] , sumofDivisors ( arr [ i ] ] ) ) ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count \/ 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr1 = [ 220 , 284 , 1184 , 12 , 2 , 556 ] NEW_LINE n1 = len ( arr1 ) NEW_LINE print ( countPairs ( arr1 , n2 ) ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def sumOfDiv ( x ) : NEW_LINE INDENT sum = 1 ; NEW_LINE for i in range ( 2 , int ( math . sqrt ( x ) ) ) : NEW_LINE INDENT if x % i == 0 : NEW_LINE INDENT sum += i NEW_LINE if i != x \/ i : NEW_LINE INDENT sum += x \/ i NEW_LINE DEDENT DEDENT DEDENT return int ( sum ) ; NEW_LINE DEDENT def isAmbicle ( a , b ) : NEW_LINE INDENT return ( sumOfDiv ( a ) == b and sumOfDiv ( b ) == a ) NEW_LINE DEDENT def countPairs ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if sumOfDiv ( arr [ i ] ) in s : NEW_LINE INDENT sum = sumOfDiv ( arr [ i ] ) NEW_LINE if isAmbicle ( arr [ i ] , sum ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return int ( count \/ 2 ) ; NEW_LINE DEDENT arr1 = [ 220 , 284 , 1184 , 1210 , 2 , 5 ] NEW_LINE n1 = len ( arr1 ) NEW_LINE print ( countPairs ( arr1 , n1 ) ) NEW_LINE arr2 = [ 2620 , 2924 , 5020 , 5564 , 6232 , 6368 ] NEW_LINE n2 = len ( arr2 ) NEW_LINE print ( countPairs ( arr2 , n2 ) ) NEW_LINE"],"bleu":0.6184788145312726,"rouge_l":0.7270692158760891}
{"id":660,"predictions":["def spiralScore ( n ) : NEW_LINE INDENT return n ^ ( n >> 1 ) NEW_LINE DEDENT n = 10 NEW_LINE print ( trimScore ( n ) ) NEW_LINE"],"references":["def grayCode ( n ) : NEW_LINE INDENT return n ^ ( n >> 1 ) NEW_LINE DEDENT n = 10 NEW_LINE print ( grayCode ( n ) ) NEW_LINE"],"bleu":0.852101976447847,"rouge_l":0.9333333333333336}
{"id":661,"predictions":["def printNonSquare ( n ) : NEW_LINE INDENT curr_count = 2 NEW_LINE num = 2 NEW_LINE count = 0 NEW_LINE while ( count < n ) : NEW_LINE INDENT i = i NEW_LINE while ( curr_count and count < n ) : NEW_LINE INDENT print ( num , end = \" ▁ \" ) NEW_LINE count = count + 1 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE printNonSquare ( n ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def printNonSquare ( n ) : NEW_LINE INDENT curr_count = 2 NEW_LINE num = 2 NEW_LINE count = 0 NEW_LINE while ( count < n ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i < curr_count and count < n ) : NEW_LINE INDENT print ( num , end = \" ▁ \" ) NEW_LINE count = count + 1 NEW_LINE num = num + 1 NEW_LINE i = i + 1 NEW_LINE DEDENT num = num + 1 NEW_LINE curr_count = curr_count + 2 NEW_LINE DEDENT DEDENT n = 10 NEW_LINE printNonSquare ( n ) NEW_LINE"],"bleu":0.695850320331178,"rouge_l":0.7832249458062365}
{"id":662,"predictions":["def sortWithSetbits ( arr , n , k ) : NEW_LINE INDENT v1 = [ ] NEW_LINE v2 = [ ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( bitCount [ arr [ i ] ] == k ) : NEW_LINE INDENT v1 . append ( arr [ i ] ) NEW_LINE v2 . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT v1 . sort ( reverse = False ) NEW_LINE for i in range ( 0 , len ( v1 ) , 1 ) : NEW_LINE INDENT arr [ v1 [ i ] ] = v2 [ i ] NEW_LINE DEDENT for i in range ( 0 , len ( v1 ) ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 14 , 255 , 1 , 7 , 13 , 13 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE sortWithSetbits ( arr , n , k ) NEW_LINE DEDENT"],"references":["def sortWithSetbits ( arr , n , k ) : NEW_LINE INDENT v1 = [ ] NEW_LINE v2 = [ ] NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( bin ( arr [ i ] ) . count ( '1' ) == k ) : NEW_LINE INDENT v1 . append ( i ) NEW_LINE v2 . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT v2 . sort ( reverse = False ) NEW_LINE for i in range ( 0 , len ( v1 ) , 1 ) : NEW_LINE INDENT arr [ v1 [ i ] ] = v2 [ i ] NEW_LINE DEDENT for i in range ( 0 , n , 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 14 , 255 , 1 , 7 , 13 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE sortWithSetbits ( arr , n , k ) NEW_LINE DEDENT"],"bleu":0.8591307290520307,"rouge_l":0.9190500510725232}
{"id":663,"predictions":["def isRotation ( x , y ) : NEW_LINE INDENT x = x | ( x << 32 ) ; NEW_LINE while ( x >= y ) : NEW_LINE INDENT if ( x & ( x << 32 ) == y ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT x += 1 ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT x = 65 ; NEW_LINE y = 2 ; NEW_LINE if ( isRotation ( x , y ) == False ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT"],"references":["def isRotation ( x , y ) : NEW_LINE INDENT x64 = x | ( x << 32 ) NEW_LINE while ( x64 >= y ) : NEW_LINE INDENT if ( ( x64 ) == y ) : NEW_LINE INDENT return True NEW_LINE DEDENT x64 >>= 1 NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = 122 NEW_LINE y = 2147483678 NEW_LINE if ( isRotation ( x , y ) == False ) : NEW_LINE INDENT print ( \" yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" no \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.5909219133366658,"rouge_l":0.794968934687074}
{"id":664,"predictions":["def findXorSum ( arr , n ) : NEW_LINE INDENT Sum = 0 NEW_LINE mul = 1 NEW_LINE for i in range ( 0 , 30 ) : NEW_LINE INDENT c_odd = 0 NEW_LINE odd = 0 NEW_LINE for j in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( arr [ j ] & ( 1 << i ) > 0 ) : NEW_LINE INDENT odd = odd + 1 NEW_LINE DEDENT DEDENT if ( arr [ j ] & ( 1 << i ) > 0 ) : NEW_LINE INDENT c_odd = odd + 1 NEW_LINE DEDENT mul = odd * 2 NEW_LINE DEDENT return Sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 8 , 13 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findXorSum ( arr , n ) ) NEW_LINE DEDENT"],"references":["def findXorSum ( arr , n ) : NEW_LINE INDENT Sum = 0 NEW_LINE mul = 1 NEW_LINE for i in range ( 30 ) : NEW_LINE INDENT c_odd = 0 NEW_LINE odd = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( ( arr [ j ] & ( 1 << i ) ) > 0 ) : NEW_LINE INDENT odd = ( ~ odd ) NEW_LINE DEDENT if ( odd ) : NEW_LINE INDENT c_odd += 1 NEW_LINE DEDENT DEDENT for j in range ( n ) : NEW_LINE INDENT Sum += ( mul * c_odd ) NEW_LINE if ( ( arr [ j ] & ( 1 << i ) ) > 0 ) : NEW_LINE INDENT c_odd = ( n - j - c_odd ) NEW_LINE DEDENT DEDENT mul *= 2 NEW_LINE DEDENT return Sum NEW_LINE DEDENT arr = [ 3 , 8 , 13 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findXorSum ( arr , n ) ) NEW_LINE"],"bleu":0.6643939583614814,"rouge_l":0.7728397505691378}
{"id":665,"predictions":["def calTime ( arr , n ) : NEW_LINE INDENT sm = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sm += 1 \/ arr [ i ] NEW_LINE DEDENT return ( 1 \/ n ) NEW_LINE DEDENT arr = [ 6.0 , 3.0 , 4.0 ] NEW_LINE n = len ( arr ) NEW_LINE print ( calTime ( arr , n ) ) NEW_LINE"],"references":["def calTime ( arr , n ) : NEW_LINE INDENT work = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT work += 1 \/ arr [ i ] NEW_LINE DEDENT return 1 \/ work NEW_LINE DEDENT arr = [ 6.0 , 3.0 , 4.0 ] NEW_LINE n = len ( arr ) NEW_LINE print ( calTime ( arr , n ) , \" Hours \" ) NEW_LINE"],"bleu":0.776587668819962,"rouge_l":0.9014084507042254}
{"id":666,"predictions":["def GetMinSubarrayLength ( a , n ) : NEW_LINE INDENT ans = max ( a [ 0 ] , a [ n - 1 ] ) ; NEW_LINE lo = n - 1 ; hi = n - 1 ; NEW_LINE while ( lo < hi and a [ lo ] % ans == 0 ) : NEW_LINE INDENT lo += 1 ; NEW_LINE while ( lo < hi and a [ lo ] % ans == 0 ) : NEW_LINE INDENT lo -= 1 ; NEW_LINE hi += 1 ; NEW_LINE DEDENT return ( lo - lo + 1 ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 8 , 2 , 1 , 4 ] ; NEW_LINE N = GetMinSubarrayLength ( arr , N ) ; NEW_LINE print ( GetMinSubarrayLength ( arr , N ) ) ; NEW_LINE DEDENT"],"references":["def GetMinSubarrayLength ( a , n ) : NEW_LINE INDENT ans = max ( a [ 0 ] , a [ n - 1 ] ) NEW_LINE lo = 0 NEW_LINE hi = n - 1 NEW_LINE while ( lo < n and a [ lo ] % ans == 0 ) : NEW_LINE INDENT lo += 1 NEW_LINE DEDENT while ( hi > lo and a [ hi ] % ans == 0 ) : NEW_LINE INDENT hi -= 1 NEW_LINE DEDENT return ( hi - lo + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 8 , 2 , 1 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE length = GetMinSubarrayLength ( arr , N ) NEW_LINE print ( length ) NEW_LINE DEDENT"],"bleu":0.6627980791100768,"rouge_l":0.8576210667261771}
{"id":667,"predictions":["import sys NEW_LINE def maxSumBitonicSubArr ( arr , n ) : NEW_LINE INDENT m = sys . maxsize NEW_LINE ms = 0 NEW_LINE m = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i - 1 ] ) : NEW_LINE INDENT m = m NEW_LINE DEDENT elif ( arr [ i ] > arr [ i - 1 ] ) : NEW_LINE INDENT ms = ms + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT m = ms NEW_LINE DEDENT DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] + ms [ i + 1 ] ) : NEW_LINE INDENT ms = ms + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT ms = m + 1 NEW_LINE DEDENT DEDENT DEDENT return m NEW_LINE DEDENT arr = [ 5 , 3 , 9 , 2 , 7 , 6 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Maximum ▁ Sum ▁ = \" , maxSumBitonicSubArr ( arr , n ) ) NEW_LINE"],"references":["def maxSumBitonicSubArr ( arr , n ) : NEW_LINE INDENT msis = [ None ] * n NEW_LINE msds = [ None ] * n NEW_LINE max_sum = 0 NEW_LINE msis [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i - 1 ] ) : NEW_LINE INDENT msis [ i ] = msis [ i - 1 ] + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT msis [ i ] = arr [ i ] NEW_LINE DEDENT DEDENT msds [ n - 1 ] = arr [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT msds [ i ] = msds [ i + 1 ] + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT msds [ i ] = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( max_sum < ( msis [ i ] + msds [ i ] - arr [ i ] ) ) : NEW_LINE INDENT max_sum = ( msis [ i ] + msds [ i ] - arr [ i ] ) NEW_LINE DEDENT DEDENT return max_sum NEW_LINE DEDENT arr = [ 5 , 3 , 9 , 2 , 7 , 6 , 4 ] ; NEW_LINE n = len ( arr ) NEW_LINE print ( \" Maximum ▁ Sum ▁ = ▁ \" + str ( maxSumBitonicSubArr ( arr , n ) ) ) NEW_LINE"],"bleu":0.4634361141307393,"rouge_l":0.638476850959995}
{"id":668,"predictions":["def minimumDeletions ( s ) : NEW_LINE INDENT freq = { } NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT l = len ( s ) NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT if l > len ( freq ) : NEW_LINE INDENT l = freq [ 0 ] * 26 NEW_LINE l = len ( l ) NEW_LINE while l < len ( s ) and l != 0 : NEW_LINE INDENT freq [ ord ( s [ l ] ) - ord ( ' a ' ) ] += 1 NEW_LINE freq [ ord ( s [ l ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT if l > len ( freq ) - 1 : NEW_LINE INDENT l = freq [ l ] + 1 NEW_LINE while l >= len ( freq ) > 1 : NEW_LINE INDENT freq [ l ] -= 1 NEW_LINE l += 1 NEW_LINE DEDENT DEDENT return l NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" geeksforgeeks \" NEW_LINE print ( minimumDeletions ( s ) ) NEW_LINE DEDENT"],"references":["def minimumDeletions ( s ) : NEW_LINE INDENT freqOfLetter = [ 0 ] * 26 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT freqOfLetter [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT LetterFreqMap = dict ( ) NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( freqOfLetter [ i ] != 0 ) : NEW_LINE INDENT LetterFreqMap [ freqOfLetter [ i ] ] =   \\ NEW_LINE LetterFreqMap . get ( freqOfLetter [ i ] , 0 ) + 1 NEW_LINE DEDENT DEDENT deletions = 0 NEW_LINE a = list ( LetterFreqMap . keys ( ) ) NEW_LINE a = a [ : : - 1 ] NEW_LINE a . sort ( ) NEW_LINE while len ( a ) > 0 : NEW_LINE INDENT it = a . pop ( ) NEW_LINE if ( it == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT while ( LetterFreqMap [ it ] > 1 ) : NEW_LINE INDENT deletions += 1 NEW_LINE LetterFreqMap [ it ] -= 1 NEW_LINE if ( it - 1 ) in LetterFreqMap . keys ( ) : NEW_LINE INDENT LetterFreqMap [ it - 1 ] += 1 NEW_LINE DEDENT elif ( it - 1 ) > 0 : NEW_LINE INDENT a . insert ( 0 , it - 1 ) NEW_LINE LetterFreqMap [ it - 1 ] = 1 NEW_LINE DEDENT DEDENT DEDENT return deletions NEW_LINE DEDENT s = \" geeksforgeeks \" NEW_LINE print ( minimumDeletions ( s ) ) NEW_LINE"],"bleu":0.3724271659671987,"rouge_l":0.5054837923470631}
{"id":669,"predictions":["def findMax ( arr , n ) : NEW_LINE INDENT maxFirst = - 2147483647 NEW_LINE mid = n \/\/ 2 NEW_LINE for i in range ( 0 , arr [ i ] ) : NEW_LINE INDENT maxFirst = max ( maxFirst , arr [ i ] ) NEW_LINE DEDENT if ( n % 2 == 1 ) : NEW_LINE INDENT maxFirst = max ( maxFirst , arr [ mid ] ) NEW_LINE DEDENT for i in range ( mid , n ) : NEW_LINE INDENT maxFirst = max ( maxFirst , arr [ i ] ) NEW_LINE DEDENT print ( \" , ▁ \" , max Second ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 12 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE findMax ( arr , n ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE def findMax ( arr , n ) : NEW_LINE INDENT maxFirst = - sys . maxsize - 1 NEW_LINE mid = n \/\/ 2 ; NEW_LINE for i in range ( 0 , mid ) : NEW_LINE INDENT maxFirst = max ( maxFirst , arr [ i ] ) NEW_LINE DEDENT if ( n % 2 == 1 ) : NEW_LINE INDENT maxFirst = max ( maxFirst , arr [ mid ] ) NEW_LINE DEDENT maxSecond = - sys . maxsize - 1 NEW_LINE for i in range ( mid , n ) : NEW_LINE INDENT maxSecond = max ( maxSecond , arr [ i ] ) NEW_LINE DEDENT print ( maxFirst , \" , \" , maxSecond ) NEW_LINE DEDENT arr = [ 1 , 12 , 14 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE findMax ( arr , n ) NEW_LINE"],"bleu":0.7270651069260813,"rouge_l":0.8312087912087913}
{"id":670,"predictions":["def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b ; NEW_LINE DEDENT return gcd ( b % a , a ) ; NEW_LINE DEDENT def lcm ( a , b , num1 , den2 ) : NEW_LINE INDENT return ( a * b ) \/ gcd ( a , b ) ; NEW_LINE DEDENT def lcm ( a , b ) : NEW_LINE INDENT return ( a * b ) \/ gcd ( a , b ) ; NEW_LINE DEDENT def printSum ( num1 , den1 , num2 , den2 ) : NEW_LINE INDENT lcm = lcm ( num1 , num2 ) ; NEW_LINE num1 = int ( lcm \/ den1 ) ; NEW_LINE num2 = int ( lcm \/ num1 ) ; NEW_LINE res_num = int ( num1 + num2 ) ; NEW_LINE print ( res_num , \" \/ \/ \" , end = \" \" ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT num1 , num1 = 1 , 6 ; NEW_LINE num2 = 7 ; NEW_LINE printSum ( num1 , num2 , num3 ) ; NEW_LINE DEDENT"],"references":["def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def lcm ( a , b ) : NEW_LINE INDENT return ( a * b ) \/ gcd ( a , b ) NEW_LINE DEDENT def printSum ( num1 , den1 , num2 , den2 ) : NEW_LINE INDENT lcd = lcm ( den1 , den2 ) ; NEW_LINE num1 *= ( lcd \/ den1 ) NEW_LINE num2 *= ( lcd \/ den2 ) NEW_LINE res_num = num1 + num2 ; NEW_LINE print ( int ( res_num ) , \" \/ \" , int ( lcd ) ) NEW_LINE DEDENT num1 = 1 NEW_LINE den1 = 6 NEW_LINE num2 = 7 NEW_LINE den2 = 15 NEW_LINE printSum ( num1 , den1 , num2 , den2 ) ; NEW_LINE"],"bleu":0.4804561481078452,"rouge_l":0.7380203867771745}
{"id":671,"predictions":["def maxProduct ( arr , n , p ) : NEW_LINE INDENT minVal = arr [ 0 ] NEW_LINE maxVal = arr [ 0 ] NEW_LINE maxVal = arr [ 0 ] NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT maxVal = maxVal NEW_LINE maxVal = minVal NEW_LINE DEDENT maxVal = maxVal NEW_LINE minVal = arr [ i ] NEW_LINE if ( minVal == p or maxVal == p ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , - 5 , - 4 ] NEW_LINE n = len ( arr ) NEW_LINE if ( maxProduct ( arr , n , product ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"references":["def maxProduct ( arr , n , p ) : NEW_LINE INDENT minVal = arr [ 0 ] NEW_LINE maxVal = arr [ 0 ] NEW_LINE maxProduct = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT maxVal , minVal = minVal , maxVal NEW_LINE DEDENT maxVal = max ( arr [ i ] , maxVal * arr [ i ] ) NEW_LINE minVal = min ( arr [ i ] , minVal * arr [ i ] ) NEW_LINE if ( minVal == p or maxVal == p ) : NEW_LINE INDENT return True NEW_LINE DEDENT maxProduct = max ( maxProduct , maxVal ) NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , - 5 , - 4 ] NEW_LINE product = - 10 NEW_LINE n = len ( arr ) NEW_LINE if ( maxProduct ( arr , n , product ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.6962580542954958,"rouge_l":0.8444539982803095}
{"id":672,"predictions":["import math NEW_LINE def solve ( M , N , s ) : NEW_LINE INDENT ans = math . ceil ( ( M \/ s ) * ( N \/ s ) ) NEW_LINE return int ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N , M , s = 12 , 4 NEW_LINE print ( solve ( M , N , s ) ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def solve ( M , N , s ) : NEW_LINE INDENT ans = ( ( math . ceil ( M \/ s ) ) * ( math . ceil ( N \/ s ) ) ) ; NEW_LINE return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 12 NEW_LINE M = 13 NEW_LINE s = 4 NEW_LINE print ( solve ( M , N , s ) ) NEW_LINE DEDENT"],"bleu":0.6958489661534384,"rouge_l":0.8504748434027077}
{"id":673,"predictions":["def ifExists ( arr , n ) : NEW_LINE INDENT sum = arr [ 0 ] NEW_LINE arr . sort ( ) NEW_LINE sum = arr [ 0 ] NEW_LINE arr [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT sum = sum + arr [ i ] NEW_LINE DEDENT max = arr [ n - 1 ] NEW_LINE flag = False NEW_LINE l = n - 1 NEW_LINE r = n - 1 NEW_LINE while ( l <= r ) : NEW_LINE INDENT m = ( l + r ) \/\/ 2 NEW_LINE if ( arr [ m ] < i ) : NEW_LINE INDENT if ( arr [ m ] < arr [ i ] ) : NEW_LINE INDENT flag = m NEW_LINE l = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = m - 1 NEW_LINE DEDENT DEDENT DEDENT l = 1 NEW_LINE r = m - 1 NEW_LINE while ( l <= r ) : NEW_LINE INDENT m = ( r + l ) \/\/ 2 NEW_LINE if ( arr [ m ] < i ) : NEW_LINE INDENT l = m + 1 NEW_LINE r = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 2 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE if ( isExists ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def IfExists ( arr , n ) : NEW_LINE INDENT sum = [ 0 ] * n ; NEW_LINE arr . sort ( ) ; NEW_LINE sum [ 0 ] = arr [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT sum [ i ] = sum [ i - 1 ] + arr [ i ] ; NEW_LINE DEDENT max = arr [ n - 1 ] ; NEW_LINE flag = False ; NEW_LINE for i in range ( 1 , max + 1 ) : NEW_LINE INDENT findex = 0 ; NEW_LINE lindex = 0 ; NEW_LINE l = 0 ; NEW_LINE r = n - 1 ; NEW_LINE while ( l <= r ) : NEW_LINE INDENT m = ( l + r ) \/\/ 2 ; NEW_LINE if ( arr [ m ] < i ) : NEW_LINE INDENT findex = m ; NEW_LINE l = m + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT r = m - 1 ; NEW_LINE DEDENT DEDENT l = 1 ; NEW_LINE r = n ; NEW_LINE flag = False ; NEW_LINE while ( l <= r ) : NEW_LINE INDENT m = ( r + l ) \/\/ 2 ; NEW_LINE if ( arr [ m ] > i ) : NEW_LINE INDENT lindex = m ; NEW_LINE r = m - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 ; NEW_LINE DEDENT DEDENT if ( sum [ findex ] == sum [ n - 1 ] - sum [ lindex - 1 ] ) : NEW_LINE INDENT flag = True ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 2 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE IfExists ( arr , n ) ; NEW_LINE DEDENT"],"bleu":0.61227849182581,"rouge_l":0.7436873554356208}
{"id":674,"predictions":["def sumOfTheSeries ( n ) : NEW_LINE INDENT return int ( n \/ ( n + 1 ) ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 ; NEW_LINE print ( sumOfTheSeries ( n ) ) ; NEW_LINE DEDENT"],"references":["def sumOfTheSeries ( n ) : NEW_LINE INDENT return ( float ( n ) \/ ( n + 1 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE ans = sumOfTheSeries ( n ) NEW_LINE print ( round ( ans , 6 ) ) NEW_LINE DEDENT"],"bleu":0.6147328285818228,"rouge_l":0.80407429598562}
{"id":675,"predictions":["import sys NEW_LINE def printClosest ( arr , n , x ) : NEW_LINE INDENT res_l = 0 NEW_LINE res_r = - sys . maxsize - 1 NEW_LINE l = 0 NEW_LINE r = 0 NEW_LINE while ( r > l ) : NEW_LINE INDENT if ( abs ( arr [ r ] + arr [ r ] ) < abs ( arr [ r ] - x ) ) : NEW_LINE INDENT res_l = l NEW_LINE res_r = abs ( arr [ r ] + arr [ l ] - x ) NEW_LINE if ( arr [ r ] + arr [ r ] > x ) : NEW_LINE INDENT res_l = l NEW_LINE DEDENT else : NEW_LINE INDENT l = 0 NEW_LINE DEDENT DEDENT DEDENT return res_r NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 10 , 22 , 28 , 31 , 30 ] NEW_LINE n = len ( arr ) NEW_LINE x = 34 NEW_LINE printClosest ( arr , n , x ) NEW_LINE DEDENT"],"references":["MAX_VAL = 1000000000 NEW_LINE def printClosest ( arr , n , x ) : NEW_LINE INDENT res_l , res_r = 0 , 0 NEW_LINE l , r , diff = 0 , n - 1 , MAX_VAL NEW_LINE while r > l : NEW_LINE INDENT if abs ( arr [ l ] + arr [ r ] - x ) < diff : NEW_LINE INDENT res_l = l NEW_LINE res_r = r NEW_LINE diff = abs ( arr [ l ] + arr [ r ] - x ) NEW_LINE DEDENT if arr [ l ] + arr [ r ] > x : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT l += 1 NEW_LINE DEDENT DEDENT print ( ' The ▁ closest ▁ pair ▁ is ▁ { } ▁ and ▁ { } ' . format ( arr [ res_l ] , arr [ res_r ] ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 10 , 22 , 28 , 29 , 30 , 40 ] NEW_LINE n = len ( arr ) NEW_LINE x = 54 NEW_LINE printClosest ( arr , n , x ) NEW_LINE DEDENT"],"bleu":0.5423213854698138,"rouge_l":0.7079303675048356}
{"id":676,"predictions":["def binomialCoeff ( n , k ) : NEW_LINE INDENT res = 1 ; NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k ; NEW_LINE DEDENT for i in range ( 0 , k ) : NEW_LINE INDENT res = res * ( n - i ) ; NEW_LINE res \/= ( i + 1 ) ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT def power ( x , y ) : NEW_LINE INDENT res = 1 ; NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = res * x ; NEW_LINE DEDENT y = y >> 1 ; NEW_LINE x = ( x * x ) ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT def Gcd ( x , y ) : NEW_LINE INDENT res = 1 ; NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = res * x ; NEW_LINE DEDENT up \/= g ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 8 ; NEW_LINE FindProb ( N ) ; NEW_LINE DEDENT"],"references":["import math NEW_LINE def binomialCoeff ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k NEW_LINE DEDENT for i in range ( 0 , k ) : NEW_LINE INDENT res = res * ( n - i ) NEW_LINE res = res \/\/ ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT def power ( x , y ) : NEW_LINE INDENT res = 1 NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = res * x NEW_LINE DEDENT y = y \/\/ 2 NEW_LINE x = x * x NEW_LINE DEDENT return res NEW_LINE DEDENT def FindProbability ( n ) : NEW_LINE INDENT up = binomialCoeff ( 2 * n , n ) NEW_LINE down = power ( 2 , 2 * n ) NEW_LINE g = math . gcd ( up , down ) NEW_LINE up = up \/\/ g NEW_LINE down = down \/\/ g NEW_LINE print ( up , \" \/ \" , down ) NEW_LINE DEDENT N = 8 NEW_LINE FindProbability ( N ) NEW_LINE"],"bleu":0.532944253002376,"rouge_l":0.7278078269169583}
{"id":677,"predictions":["class newNode : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . data = key NEW_LINE self . left = key NEW_LINE self . right = key NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def createOrder ( key : int ) -> int : NEW_LINE INDENT if key : NEW_LINE INDENT self . key = key NEW_LINE self . left = key NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def createorder ( self , key : int ) : NEW_LINE INDENT if key : NEW_LINE INDENT self . in key = key NEW_LINE DEDENT return NEW_LINE DEDENT def createOrder ( self , key : int ) : NEW_LINE INDENT if key : NEW_LINE INDENT self . left = key NEW_LINE self . right = key = key NEW_LINE self . right = key NEW_LINE DEDENT else : NEW_LINE INDENT if key : NEW_LINE INDENT self . right = key NEW_LINE DEDENT elif key : NEW_LINE INDENT self . right = key NEW_LINE self . left = key NEW_LINE DEDENT else : NEW_LINE INDENT self . right = key NEW_LINE self . right = key NEW_LINE DEDENT DEDENT DEDENT def createorder ( self , key : int ) : NEW_LINE INDENT if key : NEW_LINE INDENT return self . arr . getOrder ( key ) NEW_LINE DEDENT else : NEW_LINE INDENT return self . arr NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT node = newNode ( - 1 ) NEW_LINE root . left = createNode ( 0 ) NEW_LINE root . left = newNode ( 1 ) NEW_LINE root . right = createNode ( 0 ) NEW_LINE root . left = newNode ( 2 ) NEW_LINE root . left . right = createNode ( 0 ) NEW_LINE root . left . left = createNode ( 0 ) NEW_LINE root . left . right = newNode ( 1 ) NEW_LINE root . left . left . left = newNode ( 1"],"references":["class Node : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . key = 0 NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def newNode ( key : int ) -> Node : NEW_LINE INDENT temp = Node ( ) NEW_LINE temp . key = key NEW_LINE temp . left = None NEW_LINE temp . right = None NEW_LINE return temp NEW_LINE DEDENT def inorder ( root : Node ) : NEW_LINE INDENT if root is not None : NEW_LINE INDENT inorder ( root . left ) NEW_LINE print ( root . key , end = \" ▁ \" ) NEW_LINE inorder ( root . right ) NEW_LINE DEDENT DEDENT def createTree ( parent : list , n : int ) -> Node : NEW_LINE INDENT m = dict ( ) NEW_LINE root = Node ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i not in m : NEW_LINE INDENT temp = newNode ( i ) NEW_LINE m [ i ] = temp NEW_LINE DEDENT if parent [ i ] == - 1 : NEW_LINE INDENT root = m [ i ] NEW_LINE DEDENT elif parent [ i ] not in m : NEW_LINE INDENT temp = newNode ( parent [ i ] ) NEW_LINE temp . left = m [ i ] NEW_LINE m [ parent [ i ] ] = temp NEW_LINE DEDENT else : NEW_LINE INDENT if m [ parent [ i ] ] . left is None : NEW_LINE INDENT m [ parent [ i ] ] . left = m [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT m [ parent [ i ] ] . right = m [ i ] NEW_LINE DEDENT DEDENT DEDENT return root NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT parent = [ - 1 , 0 , 0 , 1 , 1 , 3 , 5 ] NEW_LINE n = len ( parent ) NEW_LINE root = createTree ( parent , n ) NEW_LINE print ( \" Inorder ▁ Traversal ▁ of ▁ constructed ▁ tree \" ) NEW_LINE inorder ( root ) NEW_LINE DEDENT"],"bleu":0.2936219877445465,"rouge_l":0.4611951175077427}
{"id":678,"predictions":["def findExtra ( arr1 , arr2 , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr1 [ i ] != arr2 [ i ] ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT DEDENT return n ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr1 = [ 2 , 4 , 6 , 8 , 10 , 12 , 13 ] ; NEW_LINE arr2 = [ 2 , 4 , 8 , 12 , 13 ] ; NEW_LINE n = len ( arr1 ) ; NEW_LINE print ( findExtra ( arr1 , arr2 , n ) ) ; NEW_LINE DEDENT"],"references":["def findExtra ( arr1 , arr2 , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr1 [ i ] != arr2 [ i ] ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT arr1 = [ 2 , 4 , 6 , 8 , 10 , 12 , 13 ] NEW_LINE arr2 = [ 2 , 4 , 6 , 8 , 10 , 12 ] NEW_LINE n = len ( arr2 ) NEW_LINE print ( findExtra ( arr1 , arr2 , n ) ) NEW_LINE"],"bleu":0.6800261584127515,"rouge_l":0.8739521414418533}
{"id":679,"predictions":["def CountPairs ( n ) : NEW_LINE INDENT k = n NEW_LINE imax = 1 NEW_LINE ans = 0 NEW_LINE while ( imax <= n ) : NEW_LINE INDENT smax += n \/\/ k NEW_LINE ans += k * ( imax - imax + 1 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( CountPairs ( 1 ) ) NEW_LINE print ( CountPairs ( 2 ) ) NEW_LINE print ( CountPairs ( 3 ) ) NEW_LINE DEDENT"],"references":["def CountPairs ( n ) : NEW_LINE INDENT k = n NEW_LINE imin = 1 NEW_LINE ans = 0 NEW_LINE while ( imin <= n ) : NEW_LINE INDENT imax = n \/ k NEW_LINE ans += k * ( imax - imin + 1 ) NEW_LINE imin = imax + 1 NEW_LINE k = n \/ imin NEW_LINE DEDENT return ans NEW_LINE DEDENT print ( CountPairs ( 1 ) ) NEW_LINE print ( CountPairs ( 2 ) ) NEW_LINE print ( CountPairs ( 3 ) ) NEW_LINE"],"bleu":0.6854949633186964,"rouge_l":0.7881136950904394}
{"id":680,"predictions":["def find3Numbers ( arr , n ) : NEW_LINE INDENT small = + 2147483647 NEW_LINE size = 2147483647 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( arr [ i ] <= small ) : NEW_LINE INDENT small = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] <= small ) : NEW_LINE INDENT small = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] <= small ) : NEW_LINE INDENT small = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for j in range ( i + 1 ) : NEW_LINE INDENT if ( arr [ j ] < small ) : NEW_LINE INDENT small = arr [ j ] NEW_LINE break NEW_LINE DEDENT DEDENT if ( i == n ) : NEW_LINE INDENT small = arr [ j ] NEW_LINE break NEW_LINE DEDENT for j in range ( i + 1 ) : NEW_LINE INDENT if ( arr [ j ] < small ) : NEW_LINE INDENT small = arr [ j ] NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT print ( \" No ▁ such ▁ triplet ▁ found \" ) NEW_LINE return NEW_LINE DEDENT arr = [ 5 , 7 , 4 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE find3Numbers ( arr , n ) NEW_LINE"],"references":["def find3Numbers ( arr , n ) : NEW_LINE INDENT small = + 2147483647 NEW_LINE large = + 2147483647 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] <= small ) : NEW_LINE INDENT small = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] <= large ) : NEW_LINE INDENT large = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( i == n ) : NEW_LINE INDENT print ( \" No ▁ such ▁ triplet ▁ found \" ) NEW_LINE return NEW_LINE DEDENT for j in range ( i + 1 ) : NEW_LINE INDENT if ( arr [ j ] < large ) : NEW_LINE INDENT small = arr [ j ] NEW_LINE break NEW_LINE DEDENT DEDENT print ( small , \" ▁ \" , large , \" ▁ \" , arr [ i ] ) NEW_LINE return NEW_LINE DEDENT arr = [ 5 , 7 , 4 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE find3Numbers ( arr , n ) NEW_LINE"],"bleu":0.6623362030488419,"rouge_l":0.7507239382239383}
{"id":681,"predictions":["def countCharacterType ( str ) : NEW_LINE INDENT vowels = 0 NEW_LINE vowel = 0 NEW_LINE decreasing = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT ch = str [ i ] NEW_LINE if ( ch >= ord ( ' a ' ) and ch <= ord ( ' z ' ) <= ord ( ch ) ) : NEW_LINE INDENT if ( ord ( ch ) >= ord ( ' a ' ) and ord ( ch <= ord ( ' A ' ) <= ord ( ch ) and ord ( ch ) <= ord ( ' Z ' ) ) ) : NEW_LINE INDENT ch += 1 NEW_LINE DEDENT elif ( ch == ord ( ch ) >= ord ( ch ) and ord ( ch ) == ord ( '0' ) ) : NEW_LINE INDENT ch += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ch += 1 NEW_LINE DEDENT DEDENT if ( ch >= ord ( '0' ) and ch <= ord ( ch ) ) : NEW_LINE INDENT ch = ch + 1 NEW_LINE DEDENT elif ( ch >= ord ( ch ) and ord ( ch ) >= ord ( ch ) and ord ( ch ) <= ord ( ' A ' ) and ord ( ch ) <= ord ( '9' ) ) : NEW_LINE INDENT ch = ch + ord ( ch ) NEW_LINE DEDENT else : NEW_LINE INDENT ch = ord ( ch ) + ord ( '0' ) ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( \" Character ▁ : ▁ \" , ch ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeksforgeeks \" NEW_LINE countCharacterType ( str ) NEW_LINE DEDENT"],"references":["def countCharacterType ( str ) : NEW_LINE INDENT vowels = 0 NEW_LINE consonant = 0 NEW_LINE specialChar = 0 NEW_LINE digit = 0 NEW_LINE for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT ch = str [ i ] NEW_LINE if ( ( ch >= ' a ' and ch <= ' z ' ) or ( ch >= ' A ' and ch <= ' Z ' ) ) : NEW_LINE INDENT ch = ch . lower ( ) NEW_LINE if ( ch == ' a ' or ch == ' e ' or ch == ' i ' or ch == ' o ' or ch == ' u ' ) : NEW_LINE INDENT vowels += 1 NEW_LINE DEDENT else : NEW_LINE INDENT consonant += 1 NEW_LINE DEDENT DEDENT elif ( ch >= '0' and ch <= '9' ) : NEW_LINE INDENT digit += 1 NEW_LINE DEDENT else : NEW_LINE INDENT specialChar += 1 NEW_LINE DEDENT DEDENT print ( \" Vowels : \" , vowels ) NEW_LINE print ( \" Consonant : \" , consonant ) NEW_LINE print ( \" Digit : \" , digit ) NEW_LINE print ( \" Special ▁ Character : \" , specialChar ) NEW_LINE DEDENT str = \" geeks ▁ for ▁ geeks121\" NEW_LINE countCharacterType ( str ) NEW_LINE"],"bleu":0.32360680934766506,"rouge_l":0.5477167778347871}
{"id":682,"predictions":["def calculateSum ( n ) : NEW_LINE INDENT return 2 * ( n * ( n + 1 ) * ( 2 * n + 1 ) \/ 6 + n * ( n * ( 2 * n + 1 ) ) \/ 2 + n * ( n * ( n + 1 ) ) ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 ; NEW_LINE print ( \" Sum ▁ = \" , int ( calculateSum ( n ) ) ) ; NEW_LINE DEDENT"],"references":["def calculateSum ( n ) : NEW_LINE INDENT return ( 2 * ( n * ( n + 1 ) * ( 2 * n + 1 ) \/\/ 6 ) + n * ( n + 1 ) \/\/ 2 + 2 * ( n ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE print ( \" Sum ▁ = \" , calculateSum ( n ) ) NEW_LINE DEDENT"],"bleu":0.5935703665903906,"rouge_l":0.8469085523880046}
{"id":683,"predictions":["def countPairs ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] * arr [ j ] > arr [ i ] + arr [ j ] : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 5 , 0 , 3 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE DEDENT"],"references":["import math as mt NEW_LINE def countPairs ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] * arr [ j ] > arr [ i ] + arr [ j ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 5 , 0 , 3 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE"],"bleu":0.7719465208299605,"rouge_l":0.8823954867640676}
{"id":684,"predictions":["PI = 3.14159265 NEW_LINE def areaOfK ( a , b , angle ) : NEW_LINE INDENT angle = mm * PI \/ (.14 * b ) NEW_LINE area = a * b * math . pi NEW_LINE return area NEW_LINE DEDENT a = 4 NEW_LINE b = 7 NEW_LINE angleOfK ( a , b , angle ) NEW_LINE print ( \" Area ▁ of ▁ K % d \" % areaOfK ( a , b , angle ) ) NEW_LINE"],"references":["import math NEW_LINE PI = 3.14159 \/ 180 ; NEW_LINE def areaOfKite ( a , b , angle ) : NEW_LINE INDENT angle = angle * PI ; NEW_LINE area = a * b * math . sin ( angle ) ; NEW_LINE return area ; NEW_LINE DEDENT a = 4 ; b = 7 ; angle = 78 ; NEW_LINE print ( \" Area ▁ of ▁ Kite ▁ = ▁ \" , areaOfKite ( a , b , angle ) ) ; NEW_LINE"],"bleu":0.485136034683489,"rouge_l":0.6871541501976283}
{"id":685,"predictions":["def calculate ( target ) : NEW_LINE INDENT target = 65 NEW_LINE arr = sorted ( target ) NEW_LINE n = len ( arr ) NEW_LINE totalCount = 0 NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT if ( target % arr [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i + 1 , len ( arr ) - 1 ) : NEW_LINE INDENT if ( target % arr [ arr [ i ] ] == 0 ) : NEW_LINE INDENT for k in range ( i + 1 , len ( arr [ i ] ) ) : NEW_LINE INDENT if ( ( target % arr [ i ] * arr [ j ] == 0 ) ) : NEW_LINE INDENT totalCount += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT return totalCount NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT target = 83 NEW_LINE n = len ( arr ) NEW_LINE arr = [ [ 1 , 31 , 3 , 1 , 21 , 29 , 1 ] NEW_LINE print ( \" Total ▁ number ▁ of ▁ the ▁ triplets ▁ : \" , calculate ( arr ) ) NEW_LINE DEDENT"],"references":["target = 93 NEW_LINE arr = [ 1 , 31 , 3 , 1 , 93 , 3 , 31 , 1 , 93 ] NEW_LINE length = len ( arr ) NEW_LINE totalCount = 0 NEW_LINE for i in range ( length - 2 ) : NEW_LINE INDENT if target % arr [ i ] == 0 : NEW_LINE INDENT for j in range ( i + 1 , length - 1 ) : NEW_LINE INDENT if target % ( arr [ i ] * arr [ j ] ) == 0 : NEW_LINE INDENT toFind = target \/\/ ( arr [ i ] * arr [ j ] ) NEW_LINE for k in range ( j + 1 , length ) : NEW_LINE INDENT if arr [ k ] == toFind : NEW_LINE INDENT totalCount += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT print ( ' Total ▁ number ▁ of ▁ triplets ▁ found : ▁ ' , totalCount ) NEW_LINE"],"bleu":0.4603298524607131,"rouge_l":0.6010652463382156}
{"id":686,"predictions":["def checkSpecialPrime ( sieve , num ) : NEW_LINE INDENT while ( num ) : NEW_LINE INDENT if ( sieve [ num ] ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT num = int ( num \/ 10 ) ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT def findSpecialPrime ( N ) : NEW_LINE INDENT sieve = [ True ] * ( N + 10 ) ; NEW_LINE sieve [ 1 ] = False ; NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT if ( sieve [ i ] ) : NEW_LINE INDENT for j in range ( i * i , N + 1 , i ) : NEW_LINE INDENT if ( sieve [ j ] ) : NEW_LINE INDENT sieve [ j ] = False ; NEW_LINE DEDENT DEDENT DEDENT DEDENT while ( True ) : NEW_LINE INDENT if ( checkSpecialPrime ( sieve , N ) ) : NEW_LINE INDENT print ( N ) ; NEW_LINE break ; NEW_LINE DEDENT else : NEW_LINE INDENT N -= 1 ; NEW_LINE break ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT findSpecialPrime ( 100 ) ; NEW_LINE findSpecialPrime ( 100 ) ; NEW_LINE DEDENT"],"references":["def checkSpecialPrime ( sieve , num ) : NEW_LINE INDENT while ( num ) : NEW_LINE INDENT if ( not sieve [ num ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT num \/\/= 10 NEW_LINE DEDENT return True NEW_LINE DEDENT def findSpecialPrime ( N ) : NEW_LINE INDENT sieve = [ True ] * ( N + 10 ) NEW_LINE sieve [ 0 ] = sieve [ 1 ] = False ; NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT if ( sieve [ i ] ) : NEW_LINE INDENT for j in range ( i * i , N + 1 , i ) : NEW_LINE INDENT sieve [ j ] = False NEW_LINE DEDENT DEDENT DEDENT while ( True ) : NEW_LINE INDENT if ( checkSpecialPrime ( sieve , N ) ) : NEW_LINE INDENT print ( N ) NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT N -= 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT findSpecialPrime ( 379 ) NEW_LINE findSpecialPrime ( 100 ) NEW_LINE DEDENT"],"bleu":0.7709883679763798,"rouge_l":0.911732956904426}
{"id":687,"predictions":["MAX5 = 100000 ; NEW_LINE fibs = [ 0 ] * ( MAX5 + 1 ) ; NEW_LINE def compute ( ) : NEW_LINE INDENT isFib = [ False ] * ( MAX5 + 1 ) ; NEW_LINE prev = 0 ; NEW_LINE curr = 1 ; NEW_LINE isFib [ 0 ] = True ; NEW_LINE while ( curr <= s ) : NEW_LINE INDENT temp = curr + prev ; NEW_LINE if ( temp <= s ) : NEW_LINE INDENT isFib [ temp ] = True ; NEW_LINE prev = curr ; NEW_LINE DEDENT while ( curr <= sz ) : NEW_LINE INDENT temp = curr + prev ; NEW_LINE if ( temp != sz ) : NEW_LINE INDENT isFib [ temp ] = True ; NEW_LINE DEDENT prev = curr ; NEW_LINE DEDENT DEDENT DEDENT def countOfNumbers ( N , K ) : NEW_LINE INDENT compute ( ) ; NEW_LINE computeFib = compute ( ) ; NEW_LINE for i in range ( 1 , Sz + 1 ) : NEW_LINE INDENT if ( not isFib [ i ] ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 10 ; NEW_LINE K = 3 ; NEW_LINE print ( countOfNumbers ( N , K ) ) ; NEW_LINE DEDENT"],"references":["MAX = 1000005 NEW_LINE fibUpto = [ 0 ] * ( MAX + 1 ) NEW_LINE def compute ( sz ) : NEW_LINE INDENT isFib = [ False ] * ( sz + 1 ) NEW_LINE prev = 0 NEW_LINE curr = 1 NEW_LINE isFib [ prev ] = True NEW_LINE isFib [ curr ] = True NEW_LINE while ( curr <= sz ) : NEW_LINE INDENT temp = curr + prev NEW_LINE if ( temp <= sz ) : NEW_LINE INDENT isFib [ temp ] = True NEW_LINE DEDENT prev = curr NEW_LINE curr = temp NEW_LINE DEDENT fibUpto [ 0 ] = 1 NEW_LINE for i in range ( 1 , sz + 1 ) : NEW_LINE INDENT fibUpto [ i ] = fibUpto [ i - 1 ] NEW_LINE if ( isFib [ i ] ) : NEW_LINE INDENT fibUpto [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT def countOfNumbers ( N , K ) : NEW_LINE INDENT compute ( N ) NEW_LINE low , high , ans = 1 , N , 0 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) >> 1 NEW_LINE if ( mid - fibUpto [ mid ] >= K ) : NEW_LINE INDENT ans = mid NEW_LINE high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT if ( ans ) : NEW_LINE INDENT return ( N - ans + 1 ) NEW_LINE DEDENT return 0 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 10 NEW_LINE K = 3 NEW_LINE print ( countOfNumbers ( N , K ) ) NEW_LINE DEDENT"],"bleu":0.4523229768588415,"rouge_l":0.6310475128538685}
{"id":688,"predictions":["def setBitNumber ( n ) : NEW_LINE INDENT n |= n >> 1 ; NEW_LINE n |= n >> 1 ; NEW_LINE n |= n >> 4 ; NEW_LINE n |= n >> 8 ; NEW_LINE n |= n >> 16 ; NEW_LINE n |= n >> 16 ; NEW_LINE n |= n >> 16 ; NEW_LINE n |= n >> 16 ; NEW_LINE n |= n >> 16 ; NEW_LINE n = n + 1 ; NEW_LINE return ( n >> 1 ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 324 ; NEW_LINE print ( setBitNumber ( n ) ) ; NEW_LINE DEDENT"],"references":["def setBitNumber ( n ) : NEW_LINE INDENT n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE n = n + 1 NEW_LINE return ( n >> 1 ) NEW_LINE DEDENT n = 273 NEW_LINE print ( setBitNumber ( n ) ) NEW_LINE"],"bleu":0.4061937568189146,"rouge_l":0.730256806333269}
{"id":689,"predictions":["def isHeterme ( s , n ) : NEW_LINE INDENT hash = [ 0 ] * 26 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ ord ( s [ i ] ) - ord ( ' a ' ) ] != 0 ) : NEW_LINE INDENT hash [ ord ( s [ ord ( ' a ' ) ] ) - ord ( ' a ' ) ] = 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] = 1 ; NEW_LINE DEDENT DEDENT return False ; NEW_LINE DEDENT def isHeterSum ( s , n ) : NEW_LINE INDENT if ( isHeter ( s , n ) ) : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) ; NEW_LINE DEDENT"],"references":["def isHeterogram ( s , n ) : NEW_LINE INDENT hash = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] != ' ▁ ' : NEW_LINE INDENT if hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] == 0 : NEW_LINE INDENT hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT s = \" the ▁ big ▁ dwarf ▁ only ▁ jumps \" NEW_LINE n = len ( s ) NEW_LINE print ( \" YES \" if isHeterogram ( s , n ) else \" NO \" ) NEW_LINE"],"bleu":0.4830932882017398,"rouge_l":0.645399166399487}
{"id":690,"predictions":["import math NEW_LINE def findGcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return find ( b , a % b ) NEW_LINE DEDENT def minimumCuts ( a , n ) : NEW_LINE INDENT gcd = a [ 0 ] - a [ 0 ] NEW_LINE s = gcd ( a [ 1 ] - a [ i ] ) NEW_LINE s += a [ i ] - a [ i - 1 ] NEW_LINE if ( 360 - s > 0 ) : NEW_LINE INDENT gcd = findGcd ( gcd , 360 ) NEW_LINE DEDENT if ( s > 0 ) : NEW_LINE INDENT gcd = findGcd ( gcd , 360 - s ) NEW_LINE DEDENT return ( 360 \/\/ gcd ) - n NEW_LINE DEDENT arr = [ 30 , 60 , 90 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minimumCuts ( arr , n ) ) NEW_LINE"],"references":["import math NEW_LINE def minimumCuts ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE gcd = a [ 1 ] - a [ 0 ] NEW_LINE s = gcd NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT gcd = math . gcd ( gcd , a [ i ] - a [ i - 1 ] ) NEW_LINE s += a [ i ] - a [ i - 1 ] NEW_LINE DEDENT if ( 360 - s > 0 ) : NEW_LINE INDENT gcd = math . gcd ( gcd , 360 - s ) NEW_LINE DEDENT return ( 360 \/\/ gcd ) - n NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 30 , 60 , 180 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minimumCuts ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.6536904063254182,"rouge_l":0.696332962925548}
{"id":691,"predictions":["MAX = 1005 NEW_LINE def SieveOfEratosthenes ( primes ) : NEW_LINE INDENT prime = [ True ] * ( MAX ) NEW_LINE p = 2 NEW_LINE while p * p < MAX : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT p += 1 NEW_LINE DEDENT for p in range ( 2 , MAX ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def minimumSquare ( primes ) : NEW_LINE INDENT primes = [ ] NEW_LINE SieveOfEratosthenes ( primes ) NEW_LINE SieveOfEratosthenes ( primes ) NEW_LINE max_count = 0 NEW_LINE for i in range ( len ( primes ) ) : NEW_LINE INDENT if i % primes [ i ] == 0 : NEW_LINE INDENT temp = 0 NEW_LINE while ( N % primes [ i ] == 0 ) : NEW_LINE INDENT if n % primes [ i ] == 0 : NEW_LINE INDENT temp += 1 NEW_LINE DEDENT DEDENT DEDENT if temp == 0 : NEW_LINE INDENT max_count = 1 NEW_LINE DEDENT DEDENT return max_count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 24 NEW_LINE SieveOfEratosthenes ( N ) NEW_LINE print ( \" Minimum ▁ Numbers ▁ is \" , minimumSquare ( N ) ) NEW_LINE DEDENT"],"references":["from math import sqrt NEW_LINE MAX = 1005 NEW_LINE def SieveOfEratosthenes ( primes ) : NEW_LINE INDENT prime = [ True for i in range ( MAX ) ] NEW_LINE for p in range ( 2 , int ( sqrt ( MAX ) ) + 1 , 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for p in range ( 2 , MAX , 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT primes . append ( p ) NEW_LINE DEDENT DEDENT return primes NEW_LINE DEDENT def minimumSquareFreeDivisors ( N ) : NEW_LINE INDENT prime = [ ] NEW_LINE primes = [ ] NEW_LINE primes = SieveOfEratosthenes ( prime ) NEW_LINE max_count = 0 NEW_LINE i = 0 NEW_LINE while ( len ( primes ) and primes [ i ] * primes [ i ] <= N ) : NEW_LINE INDENT if ( N % primes [ i ] == 0 ) : NEW_LINE INDENT tmp = 0 NEW_LINE while ( N % primes [ i ] == 0 ) : NEW_LINE INDENT tmp += 1 NEW_LINE N \/= primes [ i ] NEW_LINE DEDENT max_count = max ( max_count , tmp ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( max_count == 0 ) : NEW_LINE INDENT max_count = 1 NEW_LINE DEDENT return max_count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 24 NEW_LINE print ( \" Minimum ▁ Number ▁ of ▁ Square ▁ Free ▁ Divisors ▁ is \" , minimumSquareFreeDivisors ( N ) ) NEW_LINE N = 6 NEW_LINE print ( \" Minimum ▁ Number ▁ of ▁ Square ▁ Free ▁ Divisors ▁ is \" , minimumSquareFreeDivisors ( N ) ) NEW_LINE DEDENT"],"bleu":0.49434860160865185,"rouge_l":0.6725287727223835}
{"id":692,"predictions":["def calculateSum ( n ) : NEW_LINE INDENT return int ( pow ( n * ( n + 1 ) \/ 2 , 2 ) ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 ; NEW_LINE print ( calculateSum ( n ) ) ; NEW_LINE DEDENT"],"references":["def calculateSum ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) \/ 2 ) ** 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE print ( calculateSum ( n ) ) NEW_LINE DEDENT"],"bleu":0.6293507401904462,"rouge_l":0.870077519379845}
{"id":693,"predictions":["class Node : NEW_LINE INDENT def __init__ ( self , number ) : NEW_LINE INDENT while ( number != 0 ) : NEW_LINE INDENT st = st + ( int ( number % 10 ) % 10 ) NEW_LINE number = ( string % 10 ) NEW_LINE DEDENT return reverse_digits ( string ) NEW_LINE DEDENT def reverse_number ( number ) : NEW_LINE INDENT reverse_number ( number ) NEW_LINE reverse = 0 NEW_LINE reverse = 0 NEW_LINE reverse = True NEW_LINE i = 1 NEW_LINE while ( len ( st ) != 0 ) : NEW_LINE INDENT reverse = False NEW_LINE stack = [ ] NEW_LINE reverse = 0 NEW_LINE while ( len ( stack ) != 0 ) : NEW_LINE INDENT reverse = False NEW_LINE reverse = True NEW_LINE if ( reverse == True ) : NEW_LINE INDENT reverse = False NEW_LINE break NEW_LINE DEDENT i = i * 10 NEW_LINE DEDENT i = i * 10 NEW_LINE DEDENT return reverse NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT number = 399 NEW_LINE print ( reverse_number ( number ) ) NEW_LINE DEDENT"],"references":["st = [ ] ; NEW_LINE def push_digits ( number ) : NEW_LINE INDENT while ( number != 0 ) : NEW_LINE INDENT st . append ( number % 10 ) ; NEW_LINE number = int ( number \/ 10 ) ; NEW_LINE DEDENT DEDENT def reverse_number ( number ) : NEW_LINE INDENT push_digits ( number ) ; NEW_LINE reverse = 0 ; NEW_LINE i = 1 ; NEW_LINE while ( len ( st ) > 0 ) : NEW_LINE INDENT reverse = reverse + ( st [ len ( st ) - 1 ] * i ) ; NEW_LINE st . pop ( ) ; NEW_LINE i = i * 10 ; NEW_LINE DEDENT return reverse ; NEW_LINE DEDENT number = 39997 ; NEW_LINE print ( reverse_number ( number ) ) ; NEW_LINE"],"bleu":0.3354969568878211,"rouge_l":0.6196460362341606}
{"id":694,"predictions":["def inparse ( arr ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE return ( arr [ 0 ] * ( arr [ 1 ] * ( arr [ 2 ] ) ) ) NEW_LINE DEDENT def in proparse ( arr ) : NEW_LINE INDENT return ( arr [ 0 ] * ( arr [ 1 ] * ( arr [ 0 ] ) ) ) NEW_LINE DEDENT arr = [ 1 , 2 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE if ( in proparse ( arr ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def inProportion ( arr ) : NEW_LINE INDENT n = 4 ; NEW_LINE arr . sort ( ) NEW_LINE extremes = arr [ 0 ] * arr [ 3 ] ; NEW_LINE means = arr [ 1 ] * arr [ 2 ] ; NEW_LINE if ( extremes == means ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 2 ] ; NEW_LINE if ( inProportion ( arr ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"],"bleu":0.4616922135481151,"rouge_l":0.6221950224398205}
{"id":695,"predictions":["M = 100 NEW_LINE def numberOfPermutation ( N , K ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( N == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( K == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( memo [ N ] [ K ] != 0 ) : NEW_LINE INDENT return memo [ N ] [ K ] NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT if ( i <= N - 1 ) : NEW_LINE INDENT sum += numberOfPermutation ( N - 1 , K - i ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE K = 2 NEW_LINE print ( numberOfPermutation ( N , K ) ) NEW_LINE DEDENT"],"references":["M = 100 NEW_LINE memo = [ [ 0 for i in range ( M ) ] for j in range ( M ) ] NEW_LINE def numberOfPermWithKInversion ( N , K ) : NEW_LINE INDENT if ( N == 0 ) : return 0 NEW_LINE if ( K == 0 ) : return 1 NEW_LINE if ( memo [ N ] [ K ] != 0 ) : NEW_LINE INDENT return memo [ N ] [ K ] NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( K + 1 ) : NEW_LINE INDENT if ( i <= N - 1 ) : NEW_LINE INDENT sum += numberOfPermWithKInversion ( N - 1 , K - i ) NEW_LINE DEDENT DEDENT memo [ N ] [ K ] = sum NEW_LINE return sum NEW_LINE DEDENT N = 4 ; K = 2 NEW_LINE print ( numberOfPermWithKInversion ( N , K ) ) NEW_LINE"],"bleu":0.6480219351529753,"rouge_l":0.7528481012658228}
{"id":696,"predictions":["import math NEW_LINE def findkth ( n , k ) : NEW_LINE INDENT v1 = list ( ) NEW_LINE v2 = [ ] NEW_LINE for i in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT v1 . append ( i ) NEW_LINE v2 . append ( n \/\/ i ) NEW_LINE if ( i != k ) : NEW_LINE INDENT v2 . append ( n \/\/ i ) NEW_LINE DEDENT DEDENT DEDENT if ( k > ( len ( v1 ) + len ( v2 ) ) ) : NEW_LINE INDENT print ( \" Doesn ' t ▁ Exist \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( v1 [ k - 1 ] ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 15 NEW_LINE k = 2 NEW_LINE findkth ( n , k ) NEW_LINE DEDENT"],"references":["import math as mt NEW_LINE def findkth ( n , k ) : NEW_LINE INDENT v1 = list ( ) NEW_LINE v2 = list ( ) NEW_LINE for i in range ( 1 , mt . ceil ( n ** ( .5 ) ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT v1 . append ( i ) NEW_LINE if ( i != mt . ceil ( mt . sqrt ( n ) ) ) : NEW_LINE INDENT v2 . append ( n \/\/ i ) NEW_LINE DEDENT DEDENT DEDENT v2 [ : : - 1 ] NEW_LINE if ( k > ( len ( v1 ) + len ( v2 ) ) ) : NEW_LINE INDENT print ( \" Doesn ' t ▁ Exist \" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( k <= len ( v1 ) ) : NEW_LINE INDENT print ( v1 [ k - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( v2 [ k - len ( v1 ) - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT n = 15 NEW_LINE k = 2 NEW_LINE findkth ( n , k ) NEW_LINE"],"bleu":0.6369114555213795,"rouge_l":0.7343078245915736}
{"id":697,"predictions":["import sys NEW_LINE def maxSubArraySum ( a , size ) : NEW_LINE INDENT max_so_far = - ( sys . maxsize - 1 ) NEW_LINE max_ending_here = 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT max_ending_here = max_ending_here + a [ i ] NEW_LINE if ( max_ending_here < max_ending_here ) : NEW_LINE INDENT max_so_far = max_ending_here NEW_LINE DEDENT if ( max_ending_here < 0 ) : NEW_LINE INDENT max_ending_here = 0 NEW_LINE DEDENT DEDENT return max_so_far NEW_LINE DEDENT def minimalSum ( a , n , K ) : NEW_LINE INDENT sum = maxSubArraySum ( a , n ) NEW_LINE total_ending_here = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT total_ending_here += a [ i ] NEW_LINE if ( sum < 0 ) : NEW_LINE INDENT total_ending_here = total_ending_here + a [ i ] NEW_LINE DEDENT DEDENT return total_so_far NEW_LINE DEDENT a = [ 1 , - 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE K = 2 NEW_LINE print ( optimalSum ( a , n , K ) ) NEW_LINE"],"references":["import sys NEW_LINE def maxSubArraySum ( a , size ) : NEW_LINE INDENT max_so_far = - ( sys . maxsize - 1 ) ; NEW_LINE max_ending_here = 0 ; NEW_LINE for i in range ( size ) : NEW_LINE INDENT max_ending_here = max_ending_here + a [ i ] ; NEW_LINE if ( max_so_far < max_ending_here ) : NEW_LINE INDENT max_so_far = max_ending_here ; NEW_LINE DEDENT if ( max_ending_here < 0 ) : NEW_LINE INDENT max_ending_here = 0 ; NEW_LINE DEDENT DEDENT return max_so_far ; NEW_LINE DEDENT def minimizedSum ( a , n , K ) : NEW_LINE INDENT sum = maxSubArraySum ( a , n ) ; NEW_LINE totalSum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT totalSum += a [ i ] ; NEW_LINE DEDENT if ( sum < 0 ) : NEW_LINE INDENT return totalSum ; NEW_LINE DEDENT totalSum = totalSum - sum + sum \/ K ; NEW_LINE return totalSum ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , - 2 , 3 ] ; NEW_LINE n = len ( a ) ; NEW_LINE K = 2 ; NEW_LINE print ( minimizedSum ( a , n , K ) ) ; NEW_LINE DEDENT"],"bleu":0.6107192569849959,"rouge_l":0.829727958046542}
{"id":698,"predictions":["def countSetBits ( n ) : NEW_LINE INDENT cntBits = 0 ; NEW_LINE setBits = [ 0 ] * ( n + 1 ) ; NEW_LINE setBits = 1 ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT setBits = setBits ( i \/\/ 2 ) ; NEW_LINE setBits = setBits + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT setBits = setBits + setBits ( i - 1 ) ; NEW_LINE DEDENT DEDENT return cnt ; NEW_LINE DEDENT def countSetBits ( n ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT cnt = cnt + setBits ( i ) ; NEW_LINE DEDENT return cnt ; NEW_LINE DEDENT n = 6 ; NEW_LINE print ( countSetBits ( n ) ) ; NEW_LINE"],"references":["def countSetBits ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE setBits = [ 0 for x in range ( n + 1 ) ] NEW_LINE setBits [ 0 ] = 0 NEW_LINE setBits [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT setBits [ i ] = setBits [ i \/\/ 2 ] NEW_LINE DEDENT else : NEW_LINE INDENT setBits [ i ] = setBits [ i - 1 ] + 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , n + 1 ) : NEW_LINE INDENT cnt = cnt + setBits [ i ] NEW_LINE DEDENT return cnt NEW_LINE DEDENT n = 6 NEW_LINE print ( countSetBits ( n ) ) NEW_LINE"],"bleu":0.5570047421827371,"rouge_l":0.7413675601999091}
{"id":699,"predictions":["def areaCircle ( b ) : NEW_LINE INDENT area = ( 3.14159265 * b ) NEW_LINE return area NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 10 NEW_LINE b = 8 NEW_LINE print ( areaCircle ( b ) ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def areaCircle ( b ) : NEW_LINE INDENT area = math . pi * b * b NEW_LINE return area NEW_LINE DEDENT a = 10 NEW_LINE b = 8 NEW_LINE print ( areaCircle ( b ) ) NEW_LINE"],"bleu":0.5688244378656548,"rouge_l":0.7384446074834924}
{"id":700,"predictions":["class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = next NEW_LINE DEDENT DEDENT def push ( head_ref , new_data ) : NEW_LINE INDENT new_node = Node ( ) NEW_LINE new_node . data = new_data NEW_LINE new_node . next = head_ref NEW_LINE head_ref = head_ref NEW_LINE return head_ref NEW_LINE DEDENT def sort ( head_ref , head_ref ) : NEW_LINE INDENT while head_ref != None : NEW_LINE INDENT print ( head_ref , end = \" ▁ \" ) NEW_LINE head_ref = head_ref NEW_LINE if head_ref != None : NEW_LINE INDENT head_ref = Node ( head_ref ) NEW_LINE DEDENT else : NEW_LINE INDENT head_ref = head_ref NEW_LINE DEDENT head_ref = head_ref NEW_LINE while head_ref != None : NEW_LINE INDENT head = head_ref NEW_LINE if head_ref < head_ref : NEW_LINE INDENT head_ref = head_ref NEW_LINE head_ref = head_ref NEW_LINE DEDENT else : NEW_LINE INDENT head_ref = head_ref NEW_LINE DEDENT head_ref = head_ref NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT head = None NEW_LINE head = push ( head , 1 ) NEW_LINE head = push ( head , 2 ) NEW_LINE head = push ( head , 3 ) NEW_LINE head = push ( head , 5 ) NEW_LINE head = push ( head , 3 ) NEW_LINE head = push ( head , 2 ) NEW_LINE head = push ( head , 4 ) NEW_LINE head = push ( head , 2 ) NEW_LINE head = push ( head , 3 ) NEW_LINE head = push ( head , 2 ) NEW_LINE head = push ( head , 4 ) NEW_LINE head . head = push ( head , 5 ) NEW_LINE head = push ( head , 5 ) NEW_LINE head = push ( head , 1 ) NEW"],"references":["class Node : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . data = 0 NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def push ( head_ref , new_data ) : NEW_LINE INDENT new_node = Node ( ) NEW_LINE new_node . data = new_data NEW_LINE new_node . next = head_ref NEW_LINE head_ref = new_node NEW_LINE return head_ref NEW_LINE DEDENT def printList ( head ) : NEW_LINE INDENT while ( head != None ) : NEW_LINE INDENT print ( head . data , end = \" - > \" ) NEW_LINE head = head . next NEW_LINE DEDENT DEDENT def sortlist ( arr , N , head ) : NEW_LINE INDENT hash = dict ( ) NEW_LINE temp = head NEW_LINE while ( temp != None ) : NEW_LINE INDENT hash [ temp . data ] = hash . get ( temp . data , 0 ) + 1 NEW_LINE temp = temp . next NEW_LINE DEDENT temp = head NEW_LINE for i in range ( N ) : NEW_LINE INDENT frequency = hash . get ( arr [ i ] , 0 ) NEW_LINE while ( frequency > 0 ) : NEW_LINE INDENT frequency = frequency - 1 NEW_LINE temp . data = arr [ i ] NEW_LINE temp = temp . next NEW_LINE DEDENT DEDENT DEDENT head = None NEW_LINE arr = [ 5 , 1 , 3 , 2 , 8 ] NEW_LINE N = len ( arr ) NEW_LINE head = push ( head , 3 ) NEW_LINE head = push ( head , 2 ) NEW_LINE head = push ( head , 5 ) NEW_LINE head = push ( head , 8 ) NEW_LINE head = push ( head , 5 ) NEW_LINE head = push ( head , 2 ) NEW_LINE head = push ( head , 1 ) NEW_LINE sortlist ( arr , N , head ) NEW_LINE print ( \" Sorted ▁ List : \" ) NEW_LINE printList ( head ) NEW_LINE"],"bleu":0.4696510530141132,"rouge_l":0.613452597533859}
{"id":701,"predictions":["def printPattern ( N ) : NEW_LINE INDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE if ( i % 2 == 0 ) : NEW_LINE INDENT print ( \" ▁ \" , end = \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 10 NEW_LINE printPattern ( N ) NEW_LINE DEDENT"],"references":["def printPattern ( N ) : NEW_LINE INDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( i - 1 if i % 2 == 0 else i + 1 , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT N = 10 NEW_LINE printPattern ( N ) NEW_LINE"],"bleu":0.4602761640328166,"rouge_l":0.7142535464985365}
{"id":702,"predictions":["import sys NEW_LINE def minIndex ( q , s ) : NEW_LINE INDENT min_value = - 1 NEW_LINE for i in range ( s ) : NEW_LINE INDENT current = q [ 0 ] NEW_LINE s [ i ] = q [ 1 ] NEW_LINE if current <= min_value : NEW_LINE INDENT min_value = i NEW_LINE min_value = i NEW_LINE DEDENT else : NEW_LINE INDENT if ( current <= min_value and i <= min_value ) : NEW_LINE INDENT min_value = i NEW_LINE DEDENT DEDENT return min_value NEW_LINE DEDENT def printQueue ( q ) : NEW_LINE INDENT min_value = 0 NEW_LINE s = 0 NEW_LINE for i in range ( s ) : NEW_LINE INDENT current = q [ 0 ] NEW_LINE while ( current <= s and i <= s ) : NEW_LINE INDENT current = q [ 0 ] NEW_LINE if ( i != min_value and i <= min_value ) : NEW_LINE INDENT min_value = current NEW_LINE DEDENT else : NEW_LINE INDENT min_value = current NEW_LINE DEDENT s = next NEW_LINE DEDENT DEDENT print ( min_value ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT q = [ ] NEW_LINE for i in range ( 1 , len ( q ) ) : NEW_LINE INDENT minIndex = minIndex ( min_value , len ( q ) - i ) NEW_LINE DEDENT print ( min_value , end = \" ▁ \" ) NEW_LINE DEDENT"],"references":["from queue import Queue NEW_LINE def minIndex ( q , sortedIndex ) : NEW_LINE INDENT min_index = - 1 NEW_LINE min_val = 999999999999 NEW_LINE n = q . qsize ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr = q . queue [ 0 ] NEW_LINE q . get ( ) NEW_LINE if ( curr <= min_val and i <= sortedIndex ) : NEW_LINE INDENT min_index = i NEW_LINE min_val = curr NEW_LINE DEDENT q . put ( curr ) NEW_LINE DEDENT return min_index NEW_LINE DEDENT def insertMinToRear ( q , min_index ) : NEW_LINE INDENT min_val = None NEW_LINE n = q . qsize ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr = q . queue [ 0 ] NEW_LINE q . get ( ) NEW_LINE if ( i != min_index ) : NEW_LINE INDENT q . put ( curr ) NEW_LINE DEDENT else : NEW_LINE INDENT min_val = curr NEW_LINE DEDENT DEDENT q . put ( min_val ) NEW_LINE DEDENT def sortQueue ( q ) : NEW_LINE INDENT for i in range ( 1 , q . qsize ( ) + 1 ) : NEW_LINE INDENT min_index = minIndex ( q , q . qsize ( ) - i ) NEW_LINE insertMinToRear ( q , min_index ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT q = Queue ( ) NEW_LINE q . put ( 30 ) NEW_LINE q . put ( 11 ) NEW_LINE q . put ( 15 ) NEW_LINE q . put ( 4 ) NEW_LINE sortQueue ( q ) NEW_LINE while ( q . empty ( ) == False ) : NEW_LINE INDENT print ( q . queue [ 0 ] , end = \" ▁ \" ) NEW_LINE q . get ( ) NEW_LINE DEDENT DEDENT"],"bleu":0.2866870537996658,"rouge_l":0.4920496750232126}
{"id":703,"predictions":["def cntRotations ( s , n ) : NEW_LINE INDENT str = s + n NEW_LINE pre = [ 0 ] * n NEW_LINE for i in range ( 2 * n ) : NEW_LINE INDENT if ( s [ i ] == ' a ' or s [ i ] == ' e ' or s [ i ] == ' i ' or s [ i ] == ' o ' or s [ i ] == ' u ' or s [ i - 1 ] == ' u ' or s [ i ] == ' a ' or s [ i ] == ' o ' or s [ i ] == ' u ' ) : NEW_LINE INDENT pre [ i ] += 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n - 1 , 2 * n - 1 ) : NEW_LINE INDENT r = i NEW_LINE l = i - n \/\/ 2 NEW_LINE x1 = pre [ i ] NEW_LINE if ( l >= 0 ) : NEW_LINE INDENT if ( l >= 0 ) : NEW_LINE INDENT x1 -= pre [ l ] NEW_LINE DEDENT else : NEW_LINE INDENT x1 -= pre [ l ] NEW_LINE DEDENT DEDENT if ( l >= 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" abc \" NEW_LINE n = len ( s ) NEW_LINE print ( cntRotations ( s , n ) ) NEW_LINE DEDENT"],"references":["def cntRotations ( s , n ) : NEW_LINE INDENT str = s + s ; NEW_LINE pre = [ 0 ] * ( 2 * n ) ; NEW_LINE for i in range ( 2 * n ) : NEW_LINE INDENT if ( i != 0 ) : NEW_LINE INDENT pre [ i ] += pre [ i - 1 ] ; NEW_LINE DEDENT if ( str [ i ] == ' a ' or str [ i ] == ' e ' or str [ i ] == ' i ' or str [ i ] == ' o ' or str [ i ] == ' u ' ) : NEW_LINE INDENT pre [ i ] += 1 ; NEW_LINE DEDENT DEDENT ans = 0 ; NEW_LINE for i in range ( n - 1 , 2 * n - 1 , 1 ) : NEW_LINE INDENT r = i ; l = i - n ; NEW_LINE x1 = pre [ r ] ; NEW_LINE if ( l >= 0 ) : NEW_LINE INDENT x1 -= pre [ l ] ; NEW_LINE DEDENT r = ( int ) ( i - n \/ 2 ) ; NEW_LINE left = pre [ r ] ; NEW_LINE if ( l >= 0 ) : NEW_LINE INDENT left -= pre [ l ] ; NEW_LINE DEDENT right = x1 - left ; NEW_LINE if ( left > right ) : NEW_LINE INDENT ans += 1 ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT s = \" abecidft \" ; NEW_LINE n = len ( s ) ; NEW_LINE print ( cntRotations ( s , n ) ) ; NEW_LINE"],"bleu":0.598376469182789,"rouge_l":0.7099340894246184}
{"id":704,"predictions":["def msb0 ( N ) : NEW_LINE INDENT msb_p = - 1 NEW_LINE while ( N > 0 ) : NEW_LINE INDENT N = N >> 1 NEW_LINE msb_p_p = msb_p NEW_LINE while ( N > 0 ) : NEW_LINE INDENT N = N >> 1 NEW_LINE msb_p += 1 NEW_LINE DEDENT msb_p += msb_p NEW_LINE return msb_p NEW_LINE DEDENT def findBitwiseOR ( L , R ) : NEW_LINE INDENT res = 0 NEW_LINE msb_p1 = msb_p \/\/ L NEW_LINE res += res NEW_LINE DEDENT return res NEW_LINE DEDENT def findBitwiseOR ( L , R ) : NEW_LINE INDENT res = 0 NEW_LINE while ( msb_1 ) : NEW_LINE INDENT if ( msb_p1 == msb_p1 ) : NEW_LINE INDENT res += res NEW_LINE DEDENT else : NEW_LINE INDENT res += res NEW_LINE msb_p1 NEW_LINE res += res NEW_LINE msb1 = msb_p1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT L = 12 NEW_LINE R = 18 NEW_LINE print ( findBitwiseOR ( L , R ) ) NEW_LINE"],"references":["def MSBPosition ( N ) : NEW_LINE INDENT msb_p = - 1 NEW_LINE while ( N ) : NEW_LINE INDENT N = N >> 1 NEW_LINE msb_p += 1 NEW_LINE DEDENT return msb_p NEW_LINE DEDENT def findBitwiseOR ( L , R ) : NEW_LINE INDENT res = 0 NEW_LINE msb_p1 = MSBPosition ( L ) NEW_LINE msb_p2 = MSBPosition ( R ) NEW_LINE while ( msb_p1 == msb_p2 ) : NEW_LINE INDENT res_val = ( 1 << msb_p1 ) NEW_LINE res += res_val NEW_LINE L -= res_val NEW_LINE R -= res_val NEW_LINE msb_p1 = MSBPosition ( L ) NEW_LINE msb_p2 = MSBPosition ( R ) NEW_LINE DEDENT msb_p1 = max ( msb_p1 , msb_p2 ) NEW_LINE for i in range ( msb_p1 , - 1 , - 1 ) : NEW_LINE INDENT res_val = ( 1 << i ) NEW_LINE res += res_val NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT L , R = 12 , 18 NEW_LINE print ( findBitwiseOR ( L , R ) ) NEW_LINE DEDENT"],"bleu":0.44404088683069093,"rouge_l":0.5547534220888807}
{"id":705,"predictions":["def sieve ( prime , n ) : NEW_LINE INDENT prime [ 0 ] = False ; NEW_LINE prime [ 1 ] = False ; NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( 2 * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def sumPrime ( d ) : NEW_LINE INDENT maxVal = int ( math . sqrt ( d ) ) ; NEW_LINE prime = [ True ] * ( n + 1 ) ; NEW_LINE prime [ 0 ] = False ; NEW_LINE for i in range ( 2 , maxVal + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT sum += i ; NEW_LINE DEDENT DEDENT return sum ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT dieve ( ) ; NEW_LINE print ( sumPrime ( d ) ) ; NEW_LINE DEDENT"],"references":["from math import sqrt NEW_LINE def sieve ( prime , n ) : NEW_LINE INDENT prime [ 0 ] = False ; NEW_LINE prime [ 1 ] = False ; NEW_LINE for p in range ( 2 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def sumPrime ( d ) : NEW_LINE INDENT maxVal = ( 10 ** d ) - 1 ; NEW_LINE prime = [ True ] * ( maxVal + 1 ) ; NEW_LINE sieve ( prime , maxVal ) ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( 2 , maxVal + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT sum += i ; NEW_LINE DEDENT DEDENT return sum ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT d = 3 ; NEW_LINE print ( sumPrime ( d ) ) ; NEW_LINE DEDENT"],"bleu":0.8031091862033694,"rouge_l":0.8814734380220516}
{"id":706,"predictions":["MAX_CHAR = 256 NEW_LINE def kthNonRepeating ( string , k ) : NEW_LINE INDENT n = len ( string ) NEW_LINE count = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ ord ( string [ i ] ) ] = n NEW_LINE DEDENT index = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ ord ( string [ i ] ) ] = 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT x = ord ( string [ i ] ) NEW_LINE count [ ord ( string [ x ] ) ] += 1 NEW_LINE if ( count [ ord ( string [ i ] ) ] == 1 ) : NEW_LINE INDENT index [ ord ( string [ i ] ) ] = i NEW_LINE DEDENT if ( index == 2 ) : NEW_LINE INDENT index [ ord ( string [ i ] ) ] = n NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" geeksforgeeks \" NEW_LINE k = 3 NEW_LINE res = kthNonRepeating ( string , k ) NEW_LINE print ( res ) NEW_LINE DEDENT"],"references":["MAX_CHAR = 256 NEW_LINE def kthNonRepeating ( str , k ) : NEW_LINE INDENT n = len ( str ) NEW_LINE count = [ 0 ] * MAX_CHAR NEW_LINE index = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT count [ i ] = 0 NEW_LINE index [ i ] = n NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT x = str [ i ] NEW_LINE count [ ord ( x ) ] += 1 NEW_LINE if ( count [ ord ( x ) ] == 1 ) : NEW_LINE INDENT index [ ord ( x ) ] = i NEW_LINE DEDENT if ( count [ ord ( x ) ] == 2 ) : NEW_LINE INDENT index [ ord ( x ) ] = n NEW_LINE DEDENT DEDENT index . sort ( ) NEW_LINE return index [ k - 1 ] if ( index [ k - 1 ] != n ) else - 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeksforgeeks \" NEW_LINE k = 3 NEW_LINE res = kthNonRepeating ( str , k ) NEW_LINE if ( res == - 1 ) : NEW_LINE INDENT print ( \" There ▁ are ▁ less ▁ than ▁ k \" , \" non - repeating ▁ characters \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" k ' th ▁ non - repeating ▁ character ▁ is \" , str [ res ] ) NEW_LINE DEDENT DEDENT"],"bleu":0.5389763159044906,"rouge_l":0.6603407951887739}
{"id":707,"predictions":["def squareDigitSum ( number ) : NEW_LINE INDENT summ = 0 NEW_LINE num = ( int ) ( number ) NEW_LINE squareNum = num * num NEW_LINE while ( squareNum > 0 ) : NEW_LINE INDENT summ = sum + ( squareNum % 10 ) NEW_LINE squareNum = squareNum \/\/ 10 NEW_LINE DEDENT return summ NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = \"1111\" NEW_LINE print ( squareDigitSum ( N ) ) NEW_LINE DEDENT"],"references":["def squareDigitSum ( num ) : NEW_LINE INDENT summ = 0 NEW_LINE num = int ( num ) NEW_LINE squareNum = num * num NEW_LINE while squareNum > 0 : NEW_LINE INDENT summ = summ + ( squareNum % 10 ) NEW_LINE squareNum = squareNum \/\/ 10 NEW_LINE DEDENT return summ NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = \"1111\" NEW_LINE print ( squareDigitSum ( N ) ) NEW_LINE DEDENT"],"bleu":0.8011701183735701,"rouge_l":0.9424679812970117}
{"id":708,"predictions":["def maxCost ( a , n , l , r ) : NEW_LINE INDENT mx = 0 NEW_LINE k = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mx = max ( mx , a [ i ] ) NEW_LINE DEDENT count = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ a [ i ] ] += 1 NEW_LINE count [ a [ i ] ] = 0 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ a [ i ] ] += 1 NEW_LINE DEDENT res = 0 NEW_LINE l = min ( l , r ) NEW_LINE res = 0 NEW_LINE for num in mx : NEW_LINE INDENT k = max ( num - l - 1 , 0 ) NEW_LINE res = max ( res , num [ num - 1 ] + res ) NEW_LINE DEDENT return res NEW_LINE DEDENT a = [ 2 , 1 , 2 , 3 , 2 , 2 , 1 ] NEW_LINE l = len ( a ) NEW_LINE r = 1 NEW_LINE print ( maxCost ( a , n , l , r ) ) NEW_LINE"],"references":["def maxCost ( a , n , l , r ) : NEW_LINE INDENT mx = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mx = max ( mx , a [ i ] ) NEW_LINE DEDENT count = [ 0 ] * ( mx + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ a [ i ] ] += 1 NEW_LINE DEDENT res = [ 0 ] * ( mx + 1 ) NEW_LINE res [ 0 ] = 0 NEW_LINE l = min ( l , r ) NEW_LINE for num in range ( 1 , mx + 1 ) : NEW_LINE INDENT k = max ( num - l - 1 , 0 ) NEW_LINE res [ num ] = max ( res [ num - 1 ] , num * count [ num ] + res [ k ] ) NEW_LINE DEDENT return res [ mx ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 2 , 1 , 2 , 3 , 2 , 2 , 1 ] NEW_LINE l , r = 1 , 1 NEW_LINE n = len ( a ) NEW_LINE print ( maxCost ( a , n , l , r ) ) NEW_LINE DEDENT"],"bleu":0.6845667328014692,"rouge_l":0.7559925788497218}
{"id":709,"predictions":["def findPosition ( k , n ) : NEW_LINE INDENT f1 = 0 NEW_LINE f2 = 1 NEW_LINE f3 = 1 NEW_LINE while ( i ) : NEW_LINE INDENT f3 = f1 + f2 NEW_LINE f1 = f3 + f2 NEW_LINE f1 = f1 * f2 NEW_LINE f2 = f3 NEW_LINE if ( f2 % k == 0 ) : NEW_LINE INDENT return n * i NEW_LINE DEDENT i = f3 + 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE k = 4 NEW_LINE print ( \" Position ▁ of ▁ nombre ) NEW_LINE DEDENT"],"references":["def findPosition ( k , n ) : NEW_LINE INDENT f1 = 0 NEW_LINE f2 = 1 NEW_LINE i = 2 ; NEW_LINE while i != 0 : NEW_LINE INDENT f3 = f1 + f2 ; NEW_LINE f1 = f2 ; NEW_LINE f2 = f3 ; NEW_LINE if f2 % k == 0 : NEW_LINE INDENT return n * i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return NEW_LINE DEDENT n = 5 ; NEW_LINE k = 4 ; NEW_LINE print ( \" Position ▁ of ▁ n ' th ▁ multiple ▁ of ▁ k ▁ in \" \" Fibonacci ▁ Seires ▁ is \" , findPosition ( k , n ) ) ; NEW_LINE"],"bleu":0.4788734875370082,"rouge_l":0.6845058264997843}
{"id":710,"predictions":["def printAllBinary ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def generateAllBinaryStrings ( n , arr , i ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE return NEW_LINE DEDENT if ( i == n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT arr [ i ] = 0 NEW_LINE generateAllBinary ( arr , 0 ) NEW_LINE generateAllBinaryStr ( n , arr , i + 1 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 NEW_LINE generateAllBinary ( n , arr , 0 ) NEW_LINE DEDENT"],"references":["def printTheArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def generateAllBinaryStrings ( n , arr , i ) : NEW_LINE INDENT if i == n : NEW_LINE INDENT printTheArray ( arr , n ) NEW_LINE return NEW_LINE DEDENT arr [ i ] = 0 NEW_LINE generateAllBinaryStrings ( n , arr , i + 1 ) NEW_LINE arr [ i ] = 1 NEW_LINE generateAllBinaryStrings ( n , arr , i + 1 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 NEW_LINE arr = [ None ] * n NEW_LINE generateAllBinaryStrings ( n , arr , 0 ) NEW_LINE DEDENT"],"bleu":0.6716098948297854,"rouge_l":0.784218109276294}
{"id":711,"predictions":["def lcs ( i , j , k ) : NEW_LINE INDENT if ( i == - 1 or j == - 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( dp [ i ] [ j ] == - 1 or k == - 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( dp [ i ] [ k ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ k ] ; NEW_LINE DEDENT if ( dp [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] [ k ] ; NEW_LINE DEDENT if ( i == j - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] ; NEW_LINE DEDENT if ( dp [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] ; NEW_LINE DEDENT return dp [ i ] [ j ] ; NEW_LINE DEDENT def lcs ( i , j , k ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT if ( dp [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] ; NEW_LINE DEDENT else : NEW_LINE INDENT return dp [ i ] [ k ] ; NEW_LINE DEDENT DEDENT def lcs ( i , j , k ) : NEW_LINE INDENT dp [ j ] [ k ] = ( lcs ( i - 1 , j , k - 1 , j , k - 1 ) ; NEW_LINE return dp [ i ] [ j ] ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT for j in range ( 100 ) : NEW_LINE INDENT for k in range ( 0 , 100 ) : NEW_LINE INDENT dp [ i ] [ j ] = - 1 ; NEW_LINE lcs ( i , j , k - 1 ) ; NEW_LINE print ( \" Length ▁ of ▁ LCS : \" , lcs ( i , j , k - 1 , n -"],"references":["X = \" AGGT12\" NEW_LINE Y = \"12TXAYB \" NEW_LINE Z = \"12XBA \" NEW_LINE dp = [ [ [ - 1 for i in range ( 100 ) ] for j in range ( 100 ) ] for k in range ( 100 ) ] NEW_LINE def lcsOf3 ( i , j , k ) : NEW_LINE INDENT if ( i == - 1 or j == - 1 or k == - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ j ] [ k ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] [ k ] NEW_LINE DEDENT if ( X [ i ] == Y [ j ] and Y [ j ] == Z [ k ] ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = 1 + lcsOf3 ( i - 1 , j - 1 , k - 1 ) NEW_LINE return dp [ i ] [ j ] [ k ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = max ( max ( lcsOf3 ( i - 1 , j , k ) , lcsOf3 ( i , j - 1 , k ) ) , lcsOf3 ( i , j , k - 1 ) ) NEW_LINE return dp [ i ] [ j ] [ k ] NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT m = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE o = len ( Z ) NEW_LINE print ( \" Length ▁ of ▁ LCS ▁ is \" , lcsOf3 ( m - 1 , n - 1 , o - 1 ) ) NEW_LINE DEDENT"],"bleu":0.485730233949135,"rouge_l":0.572188376365922}
{"id":712,"predictions":["def checkTriangularStatistics ( n ) : NEW_LINE INDENT tri = set ( ) NEW_LINE i = 1 NEW_LINE while ( True ) : NEW_LINE INDENT x = i * ( i + 1 ) \/\/ 2 NEW_LINE while ( x >= n ) : NEW_LINE INDENT x = x \/\/ 2 NEW_LINE if ( x >= n ) : NEW_LINE INDENT tri . add ( x ) NEW_LINE tri . add ( x ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT for t in tri : NEW_LINE INDENT if ( tri [ t ] and ( n - t ) != ( n - 1 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 24 NEW_LINE if ( checkTriangularStatistics ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def checkTriangularSumRepresentation ( n ) : NEW_LINE INDENT tri = list ( ) ; NEW_LINE i = 1 ; NEW_LINE while ( 1 ) : NEW_LINE INDENT x = i * ( i + 1 ) \/\/ 2 ; NEW_LINE if ( x >= n ) : NEW_LINE INDENT break ; NEW_LINE DEDENT tri . append ( x ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT for tm in tri : NEW_LINE INDENT if n - tm in tri : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT return False ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 24 ; NEW_LINE if checkTriangularSumRepresentation ( n ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.5602283863127067,"rouge_l":0.795709357481673}
{"id":713,"predictions":["from math import * NEW_LINE eulerlib = lambda : int ( input ( ) ) NEW_LINE def getArea ( base , != 0 ) : NEW_LINE INDENT hh = sqrt ( ( x ** 2.5 ) ) NEW_LINE return 0.5 * hh NEW_LINE DEDENT def getRightAngle ( base , sqrt , base ) : NEW_LINE INDENT hcf = ( base ** 2.0 ) * ( base ** 2.0 ) NEW_LINE maxArea = getRightAngle ( base , sqrt ) NEW_LINE if ( area > maxArea ) : NEW_LINE INDENT print ( \" Not ▁ possible \" ) NEW_LINE return NEW_LINE DEDENT lower = 0.5 NEW_LINE upper = isArea ( lower , upper ) NEW_LINE if ( area < maxArea ) : NEW_LINE INDENT print ( \" not ▁ possible \" ) NEW_LINE return NEW_LINE DEDENT lower = 0 NEW_LINE upper = upper + upper * upper NEW_LINE while ( abs ( lower + upper ) > abs ( upper - lower ) ) : NEW_LINE INDENT base = ( low + upper ) \/ 2.0 NEW_LINE if ( getArea ( upper ) >= base ) : NEW_LINE INDENT lower = upper + upper * base NEW_LINE DEDENT else : NEW_LINE INDENT lower = upper + upper * upper NEW_LINE DEDENT DEDENT print ( \" Not ▁ Possible \" ) NEW_LINE return math . sqrt ( upper ) NEW_LINE DEDENT upper = 5 NEW_LINE upper = 6 NEW_LINE printRightAngle ( upper ) NEW_LINE"],"references":["import math NEW_LINE def getArea ( base , hypotenuse ) : NEW_LINE INDENT height = math . sqrt ( hypotenuse * hypotenuse - base * base ) ; NEW_LINE return 0.5 * base * height NEW_LINE DEDENT def printRightAngleTriangle ( hypotenuse , area ) : NEW_LINE INDENT hsquare = hypotenuse * hypotenuse NEW_LINE sideForMaxArea = math . sqrt ( hsquare \/ 2.0 ) NEW_LINE maxArea = getArea ( sideForMaxArea , hypotenuse ) NEW_LINE if ( area > maxArea ) : NEW_LINE INDENT print ( \" Not ▁ possiblen \" ) NEW_LINE return NEW_LINE DEDENT low = 0.0 NEW_LINE high = sideForMaxArea NEW_LINE while ( abs ( high - low ) > 1e-6 ) : NEW_LINE INDENT base = ( low + high ) \/ 2.0 NEW_LINE if ( getArea ( base , hypotenuse ) >= area ) : NEW_LINE INDENT high = base NEW_LINE DEDENT else : NEW_LINE INDENT low = base NEW_LINE DEDENT DEDENT height = math . ceil ( math . sqrt ( hsquare - base * base ) ) NEW_LINE base = math . floor ( base ) NEW_LINE print ( base , height ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT hypotenuse = 5 NEW_LINE area = 6 NEW_LINE printRightAngleTriangle ( hypotenuse , area ) NEW_LINE DEDENT"],"bleu":0.3402739585443568,"rouge_l":0.5394348982673088}
{"id":714,"predictions":["def remder ( str , R ) : NEW_LINE INDENT Len = len ( str ) ; NEW_LINE rem = 0 ; NEW_LINE rem = 0 ; NEW_LINE for i in range ( Len ) : NEW_LINE INDENT num = rem * 10 + ( ord ( str [ i ] ) - ord ( '0' ) ) ; NEW_LINE rem = num % R ; NEW_LINE rem = rem % R ; NEW_LINE DEDENT return rem ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \"13133353 ; NEW_LINE print ( remder ( str , R ) ) ; NEW_LINE DEDENT"],"references":["def Remainder ( str , R ) : NEW_LINE INDENT l = len ( str ) NEW_LINE Rem = 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT Num = Rem * 10 + ( ord ( str [ i ] ) - ord ( '0' ) ) NEW_LINE Rem = Num % R NEW_LINE DEDENT return Rem NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \"13589234356546756\" NEW_LINE R = 13 NEW_LINE print ( Remainder ( str , R ) ) NEW_LINE DEDENT"],"bleu":0.5377634551246423,"rouge_l":0.7909238249594813}
{"id":715,"predictions":["def xorSetBits ( arr , n , k ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( bin ( arr [ i ] ) == k ) : NEW_LINE INDENT v . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT result = v [ 0 ] NEW_LINE for i in range ( 1 , len ( v ) ) : NEW_LINE INDENT result ^= arr [ i ] NEW_LINE DEDENT return result NEW_LINE DEDENT arr = [ 2 , 13 , 1 , 19 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE print ( xorSetBits ( arr , n , k ) ) NEW_LINE"],"references":["def xorGivenSetBits ( arr , n , k ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( bin ( arr [ i ] ) . count ( '1' ) == k ) : NEW_LINE INDENT v . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT result = v [ 0 ] NEW_LINE for i in range ( 1 , len ( v ) , 1 ) : NEW_LINE INDENT result = result ^ v [ i ] NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 13 , 1 , 19 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE print ( xorGivenSetBits ( arr , n , k ) ) NEW_LINE DEDENT"],"bleu":0.6890545905295649,"rouge_l":0.8493038493038494}
{"id":716,"predictions":["def addBinaryUtil ( a , b ) : NEW_LINE INDENT result = 0 NEW_LINE i = 0 NEW_LINE j = len ( a ) - 1 NEW_LINE while ( i >= j ) : NEW_LINE INDENT if ( ord ( a [ i ] ) >= ord ( '0' ) or ord ( a [ i ] ) >= ord ( '0' ) and ord ( c [ j ] ) <= ord ( '0' ) ) : NEW_LINE INDENT s += ( ord ( c [ j ] ) - ord ( '0' ) ) NEW_LINE DEDENT else : NEW_LINE INDENT result += ( ord ( c [ j ] ) - ord ( '0' ) ) NEW_LINE DEDENT result \/\/= 2 NEW_LINE i -= 1 NEW_LINE j -= 1 NEW_LINE DEDENT return result NEW_LINE DEDENT def addBinary ( arr , n ) : NEW_LINE INDENT result = addBinaryUtil ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT result += addBinaryUtil ( result , arr [ i ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT arr = [ \"10\" , \"11\" , \"11\" ] NEW_LINE n = len ( arr ) NEW_LINE print ( addBinary ( arr , n ) ) NEW_LINE"],"references":["def addBinaryUtil ( a , b ) : NEW_LINE INDENT result = \" \" ; NEW_LINE s = 0 ; NEW_LINE i = len ( a ) - 1 ; NEW_LINE j = len ( b ) - 1 ; NEW_LINE while ( i >= 0 or j >= 0 or s == 1 ) : NEW_LINE INDENT s += ( ord ( a [ i ] ) - ord ( '0' ) ) if ( i >= 0 ) else 0 ; NEW_LINE s += ( ord ( b [ j ] ) - ord ( '0' ) ) if ( j >= 0 ) else 0 ; NEW_LINE result = chr ( s % 2 + ord ( '0' ) ) + result ; NEW_LINE s \/\/= 2 ; NEW_LINE i -= 1 ; NEW_LINE j -= 1 ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT def addBinary ( arr , n ) : NEW_LINE INDENT result = \" \" ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT result = addBinaryUtil ( result , arr [ i ] ) ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT arr = [ \"1\" , \"10\" , \"11\" ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( addBinary ( arr , n ) ) ; NEW_LINE"],"bleu":0.5475985422929508,"rouge_l":0.7166741979213738}
{"id":717,"predictions":["def relativeComplement ( arr1 , arr2 , n , m ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE while ( i < n and j < m ) : NEW_LINE INDENT if ( arr1 [ i ] < arr2 [ j ] ) : NEW_LINE INDENT arr1 [ i ] , arr2 [ i ] = arr1 [ i ] , arr1 [ i ] NEW_LINE i += 1 NEW_LINE DEDENT elif ( arr1 [ i ] > arr2 [ j ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT elif ( arr1 [ i ] == arr2 [ j ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr1 [ i ] = arr2 [ j ] NEW_LINE arr2 [ j ] = arr1 [ i ] NEW_LINE DEDENT DEDENT while ( i < n ) : NEW_LINE INDENT print ( arr1 [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr1 = [ 3 , 6 , 10 , 15 , 15 ] NEW_LINE arr2 = [ 1 , 3 , 10 , 15 ] NEW_LINE n = len ( arr1 ) NEW_LINE m = len ( arr2 ) NEW_LINE minimumComplement ( arr1 , arr2 , n , m ) NEW_LINE DEDENT"],"references":["def relativeComplement ( arr1 , arr2 , n , m ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE while ( i < n and j < m ) : NEW_LINE INDENT if ( arr1 [ i ] < arr2 [ j ] ) : NEW_LINE INDENT print ( arr1 [ i ] , \" ▁ \" , end = \" \" ) NEW_LINE i += 1 NEW_LINE DEDENT elif ( arr1 [ i ] > arr2 [ j ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT elif ( arr1 [ i ] == arr2 [ j ] ) : NEW_LINE INDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT while ( i < n ) : NEW_LINE INDENT print ( arr1 [ i ] , \" ▁ \" , end = \" \" ) NEW_LINE DEDENT DEDENT arr1 = [ 3 , 6 , 10 , 12 , 15 ] NEW_LINE arr2 = [ 1 , 3 , 5 , 10 , 16 ] NEW_LINE n = len ( arr1 ) NEW_LINE m = len ( arr2 ) NEW_LINE relativeComplement ( arr1 , arr2 , n , m ) NEW_LINE"],"bleu":0.7061166746993804,"rouge_l":0.8367821436875146}
{"id":718,"predictions":["def isupper ( s ) : NEW_LINE INDENT u = [ 0 for i in range ( 26 ) ] NEW_LINE v = [ 0 for i in range ( 26 ) ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( ord ( s [ i ] ) >= ord ( s [ i ] ) ) : NEW_LINE INDENT u += 1 NEW_LINE DEDENT else : NEW_LINE INDENT u += 1 NEW_LINE DEDENT DEDENT if ( u == 0 and v == 0 ) : NEW_LINE INDENT return \" YES \" NEW_LINE DEDENT else : NEW_LINE INDENT return \" NO \" NEW_LINE DEDENT DEDENT fo = 0 NEW_LINE e = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( isupper ( ) ) : NEW_LINE INDENT if ( u == 0 and e == 0 ) : NEW_LINE INDENT fo += u [ i ] NEW_LINE DEDENT elif ( u == 1 and e == 0 ) : NEW_LINE INDENT fo += u [ i ] NEW_LINE DEDENT DEDENT DEDENT if ( mo == 0 and mo == 0 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"references":["s = \" ABCdcba \" NEW_LINE u = [ 0 ] * 26 NEW_LINE n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] . isupper ( ) ) : NEW_LINE INDENT u [ ord ( s [ i ] ) - 65 ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT u [ ord ( s [ i ] ) - 97 ] -= 1 NEW_LINE DEDENT DEDENT fl = True NEW_LINE po = 0 NEW_LINE ne = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( u [ i ] > 0 ) : NEW_LINE INDENT po += u [ i ] NEW_LINE DEDENT if ( u [ i ] < 0 ) : NEW_LINE INDENT ne += u [ i ] NEW_LINE DEDENT DEDENT if ( po == 0 and ne == 0 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT elif ( po == 1 and ne == 0 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT elif ( po == 0 and ne == - 1 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"],"bleu":0.5588919747569385,"rouge_l":0.5824257795017157}
{"id":719,"predictions":["def isPalindrome ( s ) : NEW_LINE INDENT i = 0 NEW_LINE j = len ( s ) - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT if ( s [ i ] != s [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def getIndex ( S1 , S2 , n ) : NEW_LINE INDENT S = \" \" NEW_LINE for i in range ( n ) : NEW_LINE INDENT S += S1 [ i ] NEW_LINE DEDENT if ( isPalindrome ( S2 , S2 , n ) ) : NEW_LINE INDENT return i NEW_LINE DEDENT return - 1 NEW_LINE DEDENT S1 = \" sdfaa \" NEW_LINE S2 = \" sdfaa \" NEW_LINE n = len ( S1 ) NEW_LINE print ( getIndex ( S1 , S2 , n ) ) NEW_LINE"],"references":["def isPalindrome ( s ) : NEW_LINE INDENT i = 0 ; NEW_LINE j = len ( s ) - 1 ; NEW_LINE while ( i < j ) : NEW_LINE INDENT if ( s [ i ] is not s [ j ] ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT i += 1 ; NEW_LINE j -= 1 ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT def getIndex ( S1 , S2 , n ) : NEW_LINE INDENT S = \" \" ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT S = S + S1 [ i ] ; NEW_LINE Temp = \" \" ; NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT Temp += S2 [ j ] ; NEW_LINE DEDENT if ( isPalindrome ( S + Temp ) ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT S1 = \" abcdf \" ; S2 = \" sfgba \" ; NEW_LINE n = len ( S1 ) ; NEW_LINE print ( getIndex ( S1 , S2 , n ) ) ; NEW_LINE"],"bleu":0.5677591135672924,"rouge_l":0.7994237382656381}
{"id":720,"predictions":["def XorSum ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in arr : NEW_LINE INDENT if i % 2 != 0 : NEW_LINE INDENT result += arr [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT arr = [ 1 , 2 , 6 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( XorSum ( arr , n ) ) NEW_LINE"],"references":["def XorSum ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 != 0 ) : NEW_LINE INDENT result += arr [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT arr = [ 1 , 2 , 6 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( XorSum ( arr , n ) ) NEW_LINE"],"bleu":0.8263738632252082,"rouge_l":0.9291226645004061}
{"id":721,"predictions":["def count ( arr , n , x ) : NEW_LINE INDENT if ( x == 1 ) : NEW_LINE INDENT ans = ( 2 ** n ) - 1 NEW_LINE return ans NEW_LINE DEDENT count = 0 NEW_LINE for i in arr : NEW_LINE INDENT if ( arr [ i ] % x == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT ans = count ( 2 ** count ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 4 , 3 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE x = 1 NEW_LINE print ( count ( arr , n , x ) ) NEW_LINE DEDENT"],"references":["def count ( arr , n , x ) : NEW_LINE INDENT if ( x == 1 ) : NEW_LINE INDENT ans = pow ( 2 , n ) - 1 NEW_LINE return ans ; NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % x == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT ans = pow ( 2 , count ) - 1 NEW_LINE return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 4 , 3 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE x = 1 NEW_LINE print ( count ( arr , n , x ) ) NEW_LINE DEDENT"],"bleu":0.8426456089664298,"rouge_l":0.9384615384615385}
{"id":722,"predictions":["def replaceSpecialCharacter ( string ) : NEW_LINE INDENT s = list ( string ) NEW_LINE j = 0 NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if ( ( ( ord ( string [ i ] ) >= ord ( ' A ' ) and ord ( s [ j ] ) <= ord ( ' z ' ) or ord ( s [ j ] ) >= ord ( ' a ' ) and ord ( s [ j ] ) >= ord ( ' a ' ) and ord ( s [ j ] ) <= ord ( ' z ' ) ) ) : NEW_LINE INDENT s [ ord ( s [ j ] ) ] = s [ j ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT print ( \" \" . join ( s ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" $ $ $ \" NEW_LINE string = list ( \" $ \" ) NEW_LINE s . append ( s ) NEW_LINE s = \" $ \" NEW_LINE replaceSpecialCharacter ( s ) NEW_LINE DEDENT"],"references":["def removeSpecialCharacter ( s ) : NEW_LINE INDENT t = \" \" NEW_LINE for i in s : NEW_LINE INDENT if ( i >= ' A ' and i <= ' Z ' ) or ( i >= ' a ' and i <= ' z ' ) : NEW_LINE INDENT t += i NEW_LINE DEDENT DEDENT print ( t ) NEW_LINE DEDENT s = \" $ Gee * k ; s . . fo , ▁ r ' Ge ^ eks ? \" NEW_LINE removeSpecialCharacter ( s ) NEW_LINE"],"bleu":0.1497495189508257,"rouge_l":0.4617826617826618}
{"id":723,"predictions":["import math NEW_LINE def calculate ( a , b , n , m ) : NEW_LINE INDENT mul = 1 NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT if ( bin ( b [ i ] ) != 0 ) : NEW_LINE INDENT mul = mul * a [ i ] NEW_LINE DEDENT DEDENT for i in range ( 0 , n , 1 ) : NEW_LINE INDENT x = math . floor ( a [ i ] \/ mul ) NEW_LINE print ( x , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 5 , 100 ] NEW_LINE b = [ 2 , 3 ] NEW_LINE n = len ( b ) NEW_LINE m = len ( a ) NEW_LINE calculate ( a , b , n , m ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def calculate ( a , b , n , m ) : NEW_LINE INDENT mul = 1 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if ( b [ i ] != 0 ) : NEW_LINE INDENT mul = mul * b [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT x = math . floor ( a [ i ] \/ mul ) NEW_LINE print ( x , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT a = [ 5 , 100 , 8 ] NEW_LINE b = [ 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE calculate ( a , b , n , m ) NEW_LINE"],"bleu":0.7723998541673185,"rouge_l":0.9045867341073687}
{"id":724,"predictions":["def sieve ( maxEle , prime ) : NEW_LINE INDENT prime [ 0 ] = 1 NEW_LINE i = 2 NEW_LINE while ( i * i <= maxEle ) : NEW_LINE INDENT if ( prime [ i ] == 0 ) : NEW_LINE INDENT for j in range ( 2 * i , maxEle + i ) : NEW_LINE INDENT prime [ j ] = 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return prime NEW_LINE DEDENT def dieve ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT sum += n % 10 NEW_LINE n = n \/\/ 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT def print add ( arr , n ) : NEW_LINE INDENT maxEle = max ( arr ) NEW_LINE prime = [ 0 ] * ( maxEle + 1 ) NEW_LINE sieve ( maxEle , prime ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] == 0 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 2 , 4 , 6 , 11 , 18 , 7 , 18 ] NEW_LINE n = len ( a ) NEW_LINE print ( ) NEW_LINE DEDENT"],"references":["from math import sqrt NEW_LINE def sieve ( maxEle , prime ) : NEW_LINE INDENT prime [ 0 ] , prime [ 1 ] = 1 , 1 NEW_LINE for i in range ( 2 , int ( sqrt ( maxEle ) ) + 1 ) : NEW_LINE INDENT if ( not prime [ i ] ) : NEW_LINE INDENT for j in range ( 2 * i , maxEle + 1 , i ) : NEW_LINE INDENT prime [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT def digitSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n ) : NEW_LINE INDENT sum += n % 10 NEW_LINE n = n \/\/ 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT def printAdditivePrime ( arr , n ) : NEW_LINE INDENT maxEle = max ( arr ) NEW_LINE prime = [ 0 ] * ( maxEle + 1 ) NEW_LINE sieve ( maxEle , prime ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] == 0 ) : NEW_LINE INDENT sum = digitSum ( arr [ i ] ) NEW_LINE if ( prime [ sum ] == 0 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 2 , 4 , 6 , 11 , 12 , 18 , 7 ] NEW_LINE n = len ( a ) NEW_LINE printAdditivePrime ( a , n ) NEW_LINE DEDENT"],"bleu":0.6989681558199045,"rouge_l":0.8188956433637283}
{"id":725,"predictions":["def check ( n , m ) : NEW_LINE INDENT if ( m % n == 0 ) : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 ; NEW_LINE m = 10 ; NEW_LINE check ( n , m ) ; NEW_LINE DEDENT"],"references":["def check ( n , m ) : NEW_LINE INDENT if ( m % n == 0 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT n = 5 NEW_LINE m = 10 NEW_LINE check ( n , m ) NEW_LINE"],"bleu":0.6322946358994583,"rouge_l":0.8798076923076923}
{"id":726,"predictions":["import math NEW_LINE def findPowerofB ( N , p ) : NEW_LINE INDENT count = 0 NEW_LINE r = p NEW_LINE while ( r <= N ) : NEW_LINE INDENT count += ( N \/\/ r ) NEW_LINE r = r * p NEW_LINE if ( r % i == 0 ) : NEW_LINE INDENT count += ( N \/\/ i ) NEW_LINE DEDENT r = r * p NEW_LINE DEDENT return count NEW_LINE DEDENT def largestPowerofB ( N , B ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT if ( B % i == 0 ) : NEW_LINE INDENT if ( B % i == 0 ) : NEW_LINE INDENT count = 0 NEW_LINE while ( B % i == 0 ) : NEW_LINE INDENT B = B \/\/ i NEW_LINE count += 1 NEW_LINE DEDENT DEDENT DEDENT ans = min ( ans , count ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def largestPowerofB ( N , B ) : NEW_LINE INDENT vec = [ ] NEW_LINE for i in range ( len ( vec ) ) : NEW_LINE INDENT ans = min ( ans , findPowerofB ( vec [ i ] , vec [ i ] ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( largestPowerofB ( 5 , 2 ) ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE def findPowerOfP ( N , p ) : NEW_LINE INDENT count = 0 NEW_LINE r = p NEW_LINE while ( r <= N ) : NEW_LINE INDENT count += int ( N \/ r ) NEW_LINE r = r * p NEW_LINE DEDENT return count NEW_LINE DEDENT def primeFactorsofB ( B ) : NEW_LINE INDENT ans = [ ] NEW_LINE i = 2 NEW_LINE while ( B != 1 ) : NEW_LINE INDENT if ( B % i == 0 ) : NEW_LINE INDENT count = 0 NEW_LINE while ( B % i == 0 ) : NEW_LINE INDENT B = int ( B \/ i ) NEW_LINE count += 1 NEW_LINE DEDENT ans . append ( ( i , count ) ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT def largestPowerOfB ( N , B ) : NEW_LINE INDENT vec = [ ] NEW_LINE vec = primeFactorsofB ( B ) NEW_LINE ans = sys . maxsize NEW_LINE ans = min ( ans , int ( findPowerOfP ( N , vec [ 0 ] [ 0 ] ) \/ vec [ 0 ] [ 1 ] ) ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( largestPowerOfB ( 5 , 2 ) ) NEW_LINE print ( largestPowerOfB ( 6 , 9 ) ) NEW_LINE DEDENT"],"bleu":0.5734431139588165,"rouge_l":0.7139906361883778}
{"id":727,"predictions":["def printCombination ( n ) : NEW_LINE INDENT print ( 1 , end = \" ▁ \" ) NEW_LINE if ( ( n - 2 ) % 3 == 0 ) : NEW_LINE INDENT print ( \"2 , end = \" ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 223 NEW_LINE printCombination ( n ) NEW_LINE DEDENT"],"references":["def printCombination ( n ) : NEW_LINE INDENT print ( \"1 ▁ \" , end = \" \" ) ; NEW_LINE if ( ( n - 2 ) % 3 == 0 ) : NEW_LINE INDENT print ( \"2\" , n - 3 , end = \" \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \"1\" , ( n - 2 ) , end = \" \" ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 233 ; NEW_LINE printCombination ( n ) ; NEW_LINE DEDENT"],"bleu":0.5644562084578686,"rouge_l":0.8168695652173914}
{"id":728,"predictions":["def createHash ( hash , maxElement ) : NEW_LINE INDENT prev , curr = 0 , 1 NEW_LINE hash . add ( prev ) NEW_LINE while ( curr <= maxElement ) : NEW_LINE INDENT temp = curr + prev NEW_LINE hash . add ( curr ) NEW_LINE while ( curr <= maxElement ) : NEW_LINE INDENT temp = curr + prev NEW_LINE hash . add ( curr ) NEW_LINE prev = curr NEW_LINE curr = temp NEW_LINE DEDENT DEDENT def countFibonacciDivisors ( n ) : NEW_LINE INDENT hash = { } NEW_LINE createHash ( hash , n ) NEW_LINE cnt = 0 NEW_LINE for i in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 and int ( n \/ i ) == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT if ( n \/ i == i ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT n = 12 NEW_LINE print ( countFibonacciDivisors ( n ) ) NEW_LINE"],"references":["from math import sqrt , ceil , floor NEW_LINE def createHash ( maxElement ) : NEW_LINE INDENT prev = 0 NEW_LINE curr = 1 NEW_LINE d = dict ( ) NEW_LINE d [ prev ] = 1 NEW_LINE d [ curr ] = 1 NEW_LINE while ( curr <= maxElement ) : NEW_LINE INDENT temp = curr + prev NEW_LINE d [ temp ] = 1 NEW_LINE prev = curr NEW_LINE curr = temp NEW_LINE DEDENT return d NEW_LINE DEDENT def countFibonacciDivisors ( n ) : NEW_LINE INDENT hash = createHash ( n ) NEW_LINE cnt = 0 NEW_LINE for i in range ( 1 , ceil ( sqrt ( n ) ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( ( n \/\/ i == i ) and ( n \/\/ i in hash ) ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( n \/\/ i in hash ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT if ( n \/\/ ( n \/\/ i ) in hash ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT n = 12 NEW_LINE print ( countFibonacciDivisors ( n ) ) NEW_LINE"],"bleu":0.5349403184201398,"rouge_l":0.6712585588522988}
{"id":729,"predictions":["MAX = 1000000 NEW_LINE prime = [ True ] * ( MAX + 1 ) NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT for i in range ( p * 2 , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def SumOfKthPrimes ( arr , n , k ) : NEW_LINE INDENT c = 0 NEW_LINE Sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if prime [ arr [ i ] ] : NEW_LINE INDENT if prime [ arr [ i ] ] : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if c % k == 0 : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE c = 0 NEW_LINE DEDENT DEDENT DEDENT return Sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE arr = [ 2 , 3 , 5 , 7 , 11 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE SumOfKthPrimes ( arr , n , k ) NEW_LINE DEDENT"],"references":["MAX = 100000 ; NEW_LINE prime = [ True ] * ( MAX + 1 ) ; NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 1 ] = False ; NEW_LINE prime [ 0 ] = False ; NEW_LINE p = 2 ; NEW_LINE while ( p * p <= MAX ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT i = p * 2 ; NEW_LINE while ( i <= MAX ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE i += p ; NEW_LINE DEDENT DEDENT p += 1 ; NEW_LINE DEDENT DEDENT def SumOfKthPrimes ( arr , n , k ) : NEW_LINE INDENT c = 0 ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] ) : NEW_LINE INDENT c += 1 ; NEW_LINE if ( c % k == 0 ) : NEW_LINE INDENT sum += arr [ i ] ; NEW_LINE c = 0 ; NEW_LINE DEDENT DEDENT DEDENT print ( sum ) ; NEW_LINE DEDENT SieveOfEratosthenes ( ) ; NEW_LINE arr = [ 2 , 3 , 5 , 7 , 11 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE k = 2 ; NEW_LINE SumOfKthPrimes ( arr , n , k ) ; NEW_LINE"],"bleu":0.5449580356500977,"rouge_l":0.7653810508305411}
{"id":730,"predictions":["def sieveOfEratosthenes ( N , s ) : NEW_LINE INDENT prime = [ False ] * ( N + 1 ) ; NEW_LINE for i in range ( 2 , N + 1 , 2 ) : NEW_LINE INDENT if ( prime [ i ] == False ) : NEW_LINE INDENT s [ i ] = 2 ; NEW_LINE DEDENT DEDENT for i in range ( 3 , N + 1 , 2 ) : NEW_LINE INDENT if ( prime [ i ] == False ) : NEW_LINE INDENT s [ i ] = True ; NEW_LINE DEDENT DEDENT DEDENT def generatePrimeFactors ( N ) : NEW_LINE INDENT s = [ True ] * ( N + 1 ) ; NEW_LINE sieveOfEratosthenes ( N , s ) ; NEW_LINE cnt = 0 ; NEW_LINE while ( N > 1 ) : NEW_LINE INDENT if ( prime [ i ] == False ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT print ( cnt ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 360 ; NEW_LINE sieveOfEratosthenes ( N , s ) ; NEW_LINE DEDENT"],"references":["def sieveOfEratosthenes ( N , s ) : NEW_LINE INDENT prime = [ False ] * ( N + 1 ) NEW_LINE for i in range ( 2 , N + 1 , 2 ) : NEW_LINE INDENT s [ i ] = 2 NEW_LINE DEDENT for i in range ( 3 , N + 1 , 2 ) : NEW_LINE INDENT if ( prime [ i ] == False ) : NEW_LINE INDENT s [ i ] = i NEW_LINE for j in range ( i , int ( N \/ i ) + 1 , 2 ) : NEW_LINE INDENT if ( prime [ i * j ] == False ) : NEW_LINE INDENT prime [ i * j ] = True NEW_LINE s [ i * j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def generatePrimeFactors ( N ) : NEW_LINE INDENT s = [ 0 ] * ( N + 1 ) NEW_LINE sieveOfEratosthenes ( N , s ) NEW_LINE print ( \" Factor ▁ Power \" ) NEW_LINE curr = s [ N ] NEW_LINE cnt = 1 NEW_LINE while ( N > 1 ) : NEW_LINE INDENT N \/\/= s [ N ] NEW_LINE if ( curr == s [ N ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE continue NEW_LINE DEDENT print ( str ( curr ) + \" \\t \" + str ( cnt ) ) NEW_LINE curr = s [ N ] NEW_LINE cnt = 1 NEW_LINE DEDENT DEDENT N = 360 NEW_LINE generatePrimeFactors ( N ) NEW_LINE"],"bleu":0.5143901472916254,"rouge_l":0.6704235211760589}
{"id":731,"predictions":["import math NEW_LINE def nearestSquare ( n ) : NEW_LINE INDENT prevSquare = math . sqrt ( n ) NEW_LINE nextSquare = prevSquare * nextSquare NEW_LINE nextSquare = nextSquare * prevSquare NEW_LINE nextSquare = nextSquare * nextSquare NEW_LINE ans = nextSquare * nextSquare NEW_LINE return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 14 NEW_LINE print ( nearestSquare ( n ) ) NEW_LINE DEDENT"],"references":["from math import sqrt NEW_LINE def nearest ( n ) : NEW_LINE INDENT prevSquare = int ( sqrt ( n ) ) ; NEW_LINE nextSquare = prevSquare + 1 ; NEW_LINE prevSquare = prevSquare * prevSquare ; NEW_LINE nextSquare = nextSquare * nextSquare ; NEW_LINE ans = ( prevSquare - n ) if ( n - prevSquare ) < ( nextSquare - n ) else ( nextSquare - n ) ; NEW_LINE return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 14 ; NEW_LINE print ( nearest ( n ) ) ; NEW_LINE n = 16 ; NEW_LINE print ( nearest ( n ) ) ; NEW_LINE n = 18 ; NEW_LINE print ( nearest ( n ) ) ; NEW_LINE DEDENT"],"bleu":0.2599126842111774,"rouge_l":0.5881289545043689}
{"id":732,"predictions":["import sys NEW_LINE def checkIf ( arr , n ) : NEW_LINE INDENT minEle = - sys . maxsize NEW_LINE maxEle = - 1 NEW_LINE minEle = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < minEle ) : NEW_LINE INDENT minEle = arr [ i ] NEW_LINE minEle = i NEW_LINE DEDENT DEDENT flag1 = False NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] < arr [ i - 1 ] ) : NEW_LINE INDENT flag1 = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag1 == 0 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT if ( flag1 == 0 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT arr = [ 3 , 4 , 5 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE checkIf ( arr , n ) NEW_LINE"],"references":["import sys NEW_LINE def checkIfSortRotated ( arr , n ) : NEW_LINE INDENT minEle = sys . maxsize NEW_LINE maxEle = - sys . maxsize - 1 NEW_LINE minIndex = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] < minEle : NEW_LINE INDENT minEle = arr [ i ] NEW_LINE minIndex = i NEW_LINE DEDENT DEDENT flag1 = 1 NEW_LINE for i in range ( 1 , minIndex ) : NEW_LINE INDENT if arr [ i ] < arr [ i - 1 ] : NEW_LINE INDENT flag1 = 0 NEW_LINE break NEW_LINE DEDENT DEDENT flag2 = 2 NEW_LINE for i in range ( minIndex + 1 , n ) : NEW_LINE INDENT if arr [ i ] < arr [ i - 1 ] : NEW_LINE INDENT flag2 = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag1 and flag2 and arr [ n - 1 ] < arr [ minIndex - 1 ] ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT arr = [ 3 , 4 , 5 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE checkIfSortRotated ( arr , n ) NEW_LINE"],"bleu":0.622474149746674,"rouge_l":0.7668406072106262}
{"id":733,"predictions":["def printSquares ( n ) : NEW_LINE INDENT square = 0 NEW_LINE prev_x = 0 NEW_LINE for x in range ( 0 , n ) : NEW_LINE INDENT square = ( square + x + prev_x ) NEW_LINE print ( square , end = \" ▁ \" ) NEW_LINE DEDENT for x in range ( 0 , n ) : NEW_LINE INDENT square = square + x NEW_LINE print ( square , end = \" ▁ \" ) NEW_LINE DEDENT prev_x = x NEW_LINE DEDENT n = 5 NEW_LINE printSquares ( n ) NEW_LINE"],"references":["def printSquares ( n ) : NEW_LINE INDENT square = 0 ; prev_x = 0 ; NEW_LINE for x in range ( 0 , n ) : NEW_LINE INDENT square = ( square + x + prev_x ) NEW_LINE print ( square , end = \" ▁ \" ) NEW_LINE prev_x = x NEW_LINE DEDENT DEDENT n = 5 ; NEW_LINE printSquares ( n ) ; NEW_LINE"],"bleu":0.5806646632447267,"rouge_l":0.7942041159176816}
{"id":734,"predictions":["def __gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT a = a * b NEW_LINE B = b * c NEW_LINE DEDENT return gcd ( a , b ) NEW_LINE DEDENT def solve ( a , b1 , c ) : NEW_LINE INDENT a = a * b1 NEW_LINE b1 = c * c NEW_LINE c = a \/\/ c NEW_LINE return ( A \/\/ gcd ( a , b1 , c ) ) NEW_LINE DEDENT a , b1 = 3 , 4 NEW_LINE a2 , b2 = 4 , 9 NEW_LINE solve ( a1 , a2 , b2 , c ) NEW_LINE"],"references":["import math NEW_LINE def solveProportion ( a , b1 , b2 , c ) : NEW_LINE INDENT A = a * b2 NEW_LINE B = b1 * b2 NEW_LINE C = b1 * c NEW_LINE gcd1 = math . gcd ( math . gcd ( A , B ) , C ) NEW_LINE print ( str ( A \/\/ gcd1 ) + \" : \" + str ( B \/\/ gcd1 ) + \" : \" + str ( C \/\/ gcd1 ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 3 NEW_LINE b1 = 4 NEW_LINE b2 = 8 NEW_LINE c = 9 NEW_LINE solveProportion ( a , b1 , b2 , c ) NEW_LINE DEDENT"],"bleu":0.23455206108073604,"rouge_l":0.3570234113712375}
{"id":735,"predictions":["def countPairs ( arr , N ) : NEW_LINE INDENT mp = { } NEW_LINE for i in arr : NEW_LINE INDENT if i in mp : NEW_LINE INDENT mp [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ i ] = 1 NEW_LINE DEDENT DEDENT maxFreq = 0 NEW_LINE for it in mp : NEW_LINE INDENT maxFreq = max ( maxFreq , mp [ it ] ) NEW_LINE DEDENT print ( N - maxFreq ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 8 , 5 , 9 , 8 , 7 , 7 , 5 , 7 , 7 ] NEW_LINE N = len ( arr ) NEW_LINE countPairs ( arr , N ) NEW_LINE DEDENT"],"references":["def countPairs ( arr , N ) : NEW_LINE INDENT M = dict . fromkeys ( arr , 0 ) ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT M [ arr [ i ] ] += 1 ; NEW_LINE DEDENT maxFreq = 0 ; NEW_LINE for it in M . values ( ) : NEW_LINE INDENT maxFreq = max ( maxFreq , it ) ; NEW_LINE DEDENT print ( N - maxFreq ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 8 , 5 , 9 , 8 , 8 , 7 , 7 , 5 , 7 , 7 ] ; NEW_LINE N = len ( arr ) ; NEW_LINE countPairs ( arr , N ) ; NEW_LINE DEDENT"],"bleu":0.6148638321204035,"rouge_l":0.7733639217580294}
{"id":736,"predictions":["def numberOfSubarrays ( arr , n ) : NEW_LINE INDENT v = [ 0 for i in range ( n + 1 ) ] NEW_LINE v [ 0 ] = 0 NEW_LINE v [ 0 ] = 0 NEW_LINE ans = 0 NEW_LINE m = dict ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT v [ i + 1 ] = v [ i ] + arr [ i ] ] NEW_LINE if v [ i ] not in v : NEW_LINE INDENT v [ i ] = 1 NEW_LINE DEDENT m [ i ] = 0 NEW_LINE DEDENT while ( v [ arr [ i ] ] ) : NEW_LINE INDENT ans += 1 NEW_LINE v [ arr [ i ] ] = 1 NEW_LINE m [ arr [ i ] ] += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 4 , - 6 ] NEW_LINE size = len ( arr ) NEW_LINE print ( numberOfSubarrays ( arr , size ) ) NEW_LINE DEDENT"],"references":["def numberOfSubarrays ( arr , n ) : NEW_LINE INDENT v = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT v [ i + 1 ] = v [ i ] + arr [ i ] NEW_LINE DEDENT mp = { } NEW_LINE begin , end , answer = 0 , 0 , 0 NEW_LINE mp [ 0 ] = 1 NEW_LINE while ( begin < n ) : NEW_LINE INDENT while ( end < n and ( v [ end + 1 ] ) not in mp ) : NEW_LINE INDENT end += 1 NEW_LINE mp [ v [ end ] ] = 1 NEW_LINE DEDENT answer = answer + end - begin NEW_LINE del mp [ v [ begin ] ] NEW_LINE begin += 1 NEW_LINE DEDENT print ( answer ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 4 , - 6 ] NEW_LINE size = len ( arr ) NEW_LINE numberOfSubarrays ( arr , size ) NEW_LINE DEDENT"],"bleu":0.5607317640378211,"rouge_l":0.650183470207933}
{"id":737,"predictions":["def minimize ( arr , n , k ) : NEW_LINE INDENT max = arr [ 0 ] NEW_LINE min = arr [ 1 ] NEW_LINE if ( max - min ) <= k : NEW_LINE INDENT return ( max - min ) NEW_LINE DEDENT avg = ( max + min ) \/\/ 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > maximum ) : NEW_LINE INDENT arr [ i ] -= k NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] += k NEW_LINE DEDENT DEDENT max = ( arr [ i ] , max ) NEW_LINE min = min ( arr ) NEW_LINE return ( max - min ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 16 , 12 , 9 , 20 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE print ( minimize ( arr , n , k ) ) NEW_LINE DEDENT"],"references":["def minimizeDiff ( arr , n , k ) : NEW_LINE INDENT max_element = max ( arr ) NEW_LINE min_element = min ( arr ) NEW_LINE if ( ( max_element - min_element ) <= k ) : NEW_LINE INDENT return ( max_element - min_element ) NEW_LINE DEDENT avg = ( max_element + min_element ) \/\/ 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > avg ) : NEW_LINE INDENT arr [ i ] -= k NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] += k NEW_LINE DEDENT DEDENT max_element = max ( arr ) NEW_LINE min_element = min ( arr ) NEW_LINE return ( max_element - min_element ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 16 , 12 , 9 , 20 ] NEW_LINE n = 5 NEW_LINE k = 3 NEW_LINE print ( \" Max ▁ height ▁ difference ▁ = \" , minimizeDiff ( arr , n , k ) ) NEW_LINE DEDENT"],"bleu":0.6322102110845143,"rouge_l":0.8009365531172526}
{"id":738,"predictions":["class Graph ( object ) : NEW_LINE INDENT def __init__ ( self , v ) : NEW_LINE INDENT self . v = v NEW_LINE self . graph = [ [ ] for i in range ( v ) ] NEW_LINE DEDENT def addEdge ( self , v ) : NEW_LINE INDENT self . graph [ v ] . append ( v ) NEW_LINE self . graph [ v ] . append ( v ) NEW_LINE DEDENT def DFS ( self , v ) : NEW_LINE INDENT visited = [ False ] * self . v NEW_LINE visited [ v ] = True NEW_LINE for i in range ( v ) : NEW_LINE INDENT if visited [ i ] == False : NEW_LINE INDENT self . graph [ v ] . append ( i ) NEW_LINE self . graph [ i ] . append ( v ) NEW_LINE self . graph [ v ] . append ( i ) NEW_LINE DEDENT DEDENT DEDENT def addEdge ( self , v , g ) : NEW_LINE INDENT visited = [ False ] * v NEW_LINE for i in range ( self . v ) : NEW_LINE INDENT if visited [ i ] == False : NEW_LINE INDENT self . DFS ( i ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT g = Graph ( ) NEW_LINE g . addEdge ( ) NEW_LINE g . addEdge ( ) NEW_LINE g . addEdge ( 0 , 1 ) NEW_LINE g . addEdge ( 1 , 2 ) NEW_LINE g . addEdge ( 0 , 3 ) NEW_LINE g . addEdge ( 0 , 3 ) NEW_LINE g . addEdge ( 0 , 2 ) NEW_LINE g . addEdge ( 1 , 2 ) NEW_LINE g . addEdge ( 1 , 3 ) NEW_LINE print ( \" First ▁ BST ▁ is \" ) NEW_LINE g . addEdge ( 2 , 3 ) NEW_LINE g . print ( \" Following ▁ BST ▁ is \" ) NEW_LINE DEDENT"],"references":["from collections import defaultdict NEW_LINE class Graph : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . graph = defaultdict ( list ) NEW_LINE DEDENT def addEdge ( self , u , v ) : NEW_LINE INDENT self . graph [ u ] . append ( v ) NEW_LINE DEDENT def BFS ( self , s ) : NEW_LINE INDENT visited = [ False ] * ( len ( self . graph ) ) NEW_LINE queue = [ ] NEW_LINE queue . append ( s ) NEW_LINE visited [ s ] = True NEW_LINE while queue : NEW_LINE INDENT s = queue . pop ( 0 ) NEW_LINE print ( s , end = \" ▁ \" ) NEW_LINE for i in self . graph [ s ] : NEW_LINE INDENT if visited [ i ] == False : NEW_LINE INDENT queue . append ( i ) NEW_LINE visited [ i ] = True NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT g = Graph ( ) NEW_LINE g . addEdge ( 0 , 1 ) NEW_LINE g . addEdge ( 0 , 2 ) NEW_LINE g . addEdge ( 1 , 2 ) NEW_LINE g . addEdge ( 2 , 0 ) NEW_LINE g . addEdge ( 2 , 3 ) NEW_LINE g . addEdge ( 3 , 3 ) NEW_LINE print ( \" Following ▁ is ▁ Breadth ▁ First ▁ Traversal \" \" ▁ ( starting ▁ from ▁ vertex ▁ 2 ) \" ) NEW_LINE g . BFS ( 2 ) NEW_LINE"],"bleu":0.442639005699842,"rouge_l":0.5988107926179391}
{"id":739,"predictions":["def cal ( n ) : NEW_LINE INDENT res = pow ( 10 , ( n - 1 ) , 1 \/ 4 ) ; NEW_LINE return round ( res , 4 ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 1 ; NEW_LINE print ( cal ( n ) ) ; NEW_LINE DEDENT"],"references":["from math import * NEW_LINE def cal ( n ) : NEW_LINE INDENT res = pow ( ceil ( ( pow ( pow ( 10 , ( n - 1 ) ) , 1 \/ 4 ) ) ) , 4 ) NEW_LINE return int ( res ) NEW_LINE DEDENT n = 1 NEW_LINE print ( cal ( n ) ) NEW_LINE"],"bleu":0.5303921593134158,"rouge_l":0.684498956158664}
{"id":740,"predictions":["def bit_count ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT count += 1 NEW_LINE n = n & ( n - 1 ) NEW_LINE DEDENT return count NEW_LINE DEDENT def maxSumofBits ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n , 1 ) : NEW_LINE INDENT arr [ i ] = bit_count ( arr [ i ] ) NEW_LINE DEDENT return arr [ n ] NEW_LINE DEDENT def maxSumOfBits ( arr , e ) : NEW_LINE INDENT tot = 0 NEW_LINE epsl = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] == epsl ) : NEW_LINE INDENT eps = i + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT eps = eps + arr [ i ] NEW_LINE DEDENT DEDENT return ( eps ) NEW_LINE DEDENT arr = [ 1 , 2 , 4 , 5 , 6 , 20 , 25 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxSumofBits ( arr , n ) ) NEW_LINE"],"references":["def bit ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT count += 1 NEW_LINE n = n & ( n - 1 ) NEW_LINE DEDENT return count NEW_LINE DEDENT def maxSumOfBits ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = bit ( arr [ i ] ) NEW_LINE DEDENT incl = arr [ 0 ] NEW_LINE excl = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if incl > excl : NEW_LINE INDENT excl_new = incl NEW_LINE DEDENT else : NEW_LINE INDENT excl_new = excl NEW_LINE DEDENT incl = excl + arr [ i ] ; NEW_LINE excl = excl_new NEW_LINE DEDENT if incl > excl : NEW_LINE INDENT return incl NEW_LINE DEDENT else : NEW_LINE INDENT return excl NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 5 , 6 , 7 , 20 , 25 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxSumOfBits ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.6244878192617007,"rouge_l":0.7342076865609695}
{"id":741,"predictions":["import math NEW_LINE def subset ( arr , n , K ) : NEW_LINE INDENT max_ele = arr [ 0 ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( arr [ i ] > max_ele ) : NEW_LINE INDENT max_ele = arr [ i ] NEW_LINE DEDENT max_ele = arr [ i ] NEW_LINE m = int ( math . log2 ( max_ele ) ) + 1 NEW_LINE DEDENT dp = [ [ 0 for x in range ( n + 1 ) ] for y in range ( m + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 0 NEW_LINE for j in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j ] NEW_LINE DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( m + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( m + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( m + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT ans += dp [ n ] [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ [ 1 , 2 , 3 ] NEW_LINE k = 1 NEW_LINE n = len ( arr ) NEW_LINE print ( subsetXOR ( arr , n , k ) ) NEW_LINE DEDENT"],"references":["from math import log2 NEW_LINE def subsetXOR ( arr , n , K ) : NEW_LINE INDENT max_ele = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > max_ele ) : NEW_LINE INDENT max_ele = arr [ i ] NEW_LINE DEDENT DEDENT m = ( 1 << int ( log2 ( max_ele ) + 1 ) ) - 1 NEW_LINE dp = [ [ [ 0 for i in range ( n + 1 ) ] for j in range ( m + 1 ) ] for k in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( m + 1 ) : NEW_LINE INDENT for k in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = 0 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( m + 1 ) : NEW_LINE INDENT for k in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = dp [ i - 1 ] [ j ] [ k ] NEW_LINE if ( k != 0 ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] += k * dp [ i - 1 ] [ j ^ arr [ i - 1 ] ] [ k - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans += dp [ n ] [ K ] [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 ] NEW_LINE k = 1 NEW_LINE n = len ( arr ) NEW_LINE print ( subsetXOR ( arr , n , k ) ) NEW_LINE DEDENT"],"bleu":0.7606890858291625,"rouge_l":0.7645791186559944}
{"id":742,"predictions":["def MaximumHeight ( a , n ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT y = ( i * ( i + 1 ) ) \/ 2 NEW_LINE if y < n : NEW_LINE INDENT result = i NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 40 , 100 , 20 ] NEW_LINE n = len ( arr ) NEW_LINE print ( MaximumHeight ( arr , n ) ) NEW_LINE DEDENT"],"references":["def MaximumHeight ( a , n ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT y = ( i * ( i + 1 ) ) \/ 2 NEW_LINE if ( y < n ) : NEW_LINE INDENT result = i NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT arr = [ 40 , 100 , 20 , 30 ] NEW_LINE n = len ( arr ) NEW_LINE print ( MaximumHeight ( arr , n ) ) NEW_LINE"],"bleu":0.7768305955201045,"rouge_l":0.910746513535685}
{"id":743,"predictions":["def to negbase ( n , neg base ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return \"0\" NEW_LINE DEDENT substr = \" \" NEW_LINE while ( n != 0 ) : NEW_LINE INDENT remainder = n % neg NEW_LINE n = n \/\/ base NEW_LINE DEDENT while ( n != 0 ) : NEW_LINE INDENT remainder = n % remainder NEW_LINE n = int ( remainder ) ( n + 1 ) NEW_LINE n = int ( remainder ) NEW_LINE DEDENT return != - 2 NEW_LINE DEDENT n = 13 NEW_LINE neg base = - 2 NEW_LINE print ( to negNegbase ( n , neg base ) ) NEW_LINE"],"references":["def toNegativeBase ( n , negBase ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return \"0\" NEW_LINE DEDENT converted = \"01\" NEW_LINE while ( n != 0 ) : NEW_LINE INDENT remainder = n % ( negBase ) NEW_LINE n = int ( n \/ negBase ) NEW_LINE if ( remainder < 0 ) : NEW_LINE INDENT remainder += ( ( - 1 ) * negBase ) NEW_LINE n += 1 NEW_LINE DEDENT converted = str ( remainder ) + converted NEW_LINE DEDENT return converted NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 13 NEW_LINE negBase = - 2 NEW_LINE print ( toNegativeBase ( n , negBase ) ) NEW_LINE DEDENT"],"bleu":0.4476561632864123,"rouge_l":0.6534237288135594}
{"id":744,"predictions":["m = 6 NEW_LINE def compareOrder ( a1 , a2 , a3 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( a1 [ i ] < a2 [ i ] ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( a1 [ i ] > a2 [ i ] ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT elif ( a1 [ i ] > a2 [ i ] ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT def binaryArray ( ar , arr ) : NEW_LINE INDENT l = 0 NEW_LINE r = m - 1 NEW_LINE while ( l <= r ) : NEW_LINE INDENT mid = ( l + r ) \/\/ 2 NEW_LINE if ( arr [ mid ] > arr [ mid ] ) : NEW_LINE INDENT return mid + 1 NEW_LINE DEDENT elif ( arr [ mid ] == 1 ) : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = mid - 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT mat = [ [ [ 0 , 0 , 1 ] , [ 10 , 9 , 22 ] , [ 40 , 40 , 50 ] , [ 81 , 40 , 100 ] , [ 81 , 100 , 40 ] ] NEW_LINE row = len ( mat ) NEW_LINE print ( binarySearch ( mat , row ) ) NEW_LINE DEDENT"],"references":["m = 6 ; NEW_LINE n = 4 ; NEW_LINE def compareRow ( a1 , a2 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( a1 [ i ] < a2 [ i ] ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT elif ( a1 [ i ] > a2 [ i ] ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT DEDENT return 0 ; NEW_LINE DEDENT def binaryCheck ( ar , arr ) : NEW_LINE INDENT l = 0 ; r = m - 1 ; NEW_LINE while ( l <= r ) : NEW_LINE INDENT mid = ( l + r ) \/\/ 2 ; NEW_LINE temp = compareRow ( ar [ mid ] , arr ) ; NEW_LINE if ( temp == 0 ) : NEW_LINE INDENT return mid + 1 ; NEW_LINE DEDENT elif ( temp == 1 ) : NEW_LINE INDENT l = mid + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT r = mid - 1 ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT mat = [ [ 0 , 0 , 1 , 0 ] , [ 10 , 9 , 22 , 23 ] , [ 40 , 40 , 40 , 40 ] , [ 43 , 44 , 55 , 68 ] , [ 81 , 73 , 100 , 132 ] , [ 100 , 75 , 125 , 133 ] ] ; NEW_LINE row = [ 10 , 9 , 22 , 23 ] ; NEW_LINE print ( binaryCheck ( mat , row ) ) ; NEW_LINE DEDENT"],"bleu":0.5944927128677335,"rouge_l":0.7749020539000356}
{"id":745,"predictions":["def longestSubArray ( arr , n ) : NEW_LINE INDENT isZero = False NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT isZero = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( isZero ) : NEW_LINE INDENT return False NEW_LINE DEDENT return n NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 0 , 2 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE print ( longestSubArray ( arr , n ) ) NEW_LINE DEDENT"],"references":["def longestSubArray ( arr , n ) : NEW_LINE INDENT isZeroPresent = False NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT isZeroPresent = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( isZeroPresent ) : NEW_LINE INDENT return n NEW_LINE DEDENT return 0 NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 0 , 1 , 2 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE print ( longestSubArray ( arr , n ) ) NEW_LINE"],"bleu":0.7243502309969708,"rouge_l":0.8691451031772028}
{"id":746,"predictions":["def PrintMinNumber ( arr ) : NEW_LINE INDENT curr_max = 0 NEW_LINE last_element = 0 NEW_LINE for i in arr : NEW_LINE INDENT if i == \" D \" : NEW_LINE INDENT last_element = 0 NEW_LINE DEDENT else : NEW_LINE INDENT last_element = i + 1 NEW_LINE DEDENT if last_element == 0 : NEW_LINE INDENT for j in range ( i + 1 , len ( arr ) + 1 ) : NEW_LINE INDENT noOf_element = 0 NEW_LINE DEDENT DEDENT if ( i == 0 ) : NEW_LINE INDENT first_element = 0 NEW_LINE DEDENT else : NEW_LINE INDENT curr_max = 0 NEW_LINE DEDENT DEDENT if ( i == 0 ) : NEW_LINE INDENT print ( last_element , end = \" ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT curr_max = last_element NEW_LINE max_element = curr_element NEW_LINE DEDENT if ( i == 0 ) : NEW_LINE INDENT for j in range ( i + 1 , len ( arr ) ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT j = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT second_element = curr_element NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for k in range ( i , len ( arr ) ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT if ( j == 1 ) : NEW_LINE INDENT print ( \" , end = \" ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( \" ▁ \" , end = \" \" ) NEW_LINE DEDENT curr_element = curr_element + 1 NEW_LINE last_element = curr_element NEW_LINE DEDENT else : NEW_LINE INDENT curr_element = curr_element NEW_LINE last_element = curr_element NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT if __name__ == \""],"references":["def PrintMinNumberForPattern ( arr ) : NEW_LINE INDENT curr_max = 0 NEW_LINE last_entry = 0 NEW_LINE i = 0 NEW_LINE while i < len ( arr ) : NEW_LINE INDENT noOfNextD = 0 NEW_LINE if arr [ i ] == \" I \" : NEW_LINE INDENT j = i + 1 NEW_LINE while j < len ( arr ) and arr [ j ] == \" D \" : NEW_LINE INDENT noOfNextD += 1 NEW_LINE j += 1 NEW_LINE DEDENT if i == 0 : NEW_LINE INDENT curr_max = noOfNextD + 2 NEW_LINE last_entry += 1 NEW_LINE print ( \" \" , last_entry , end = \" \" ) NEW_LINE print ( \" \" , curr_max , end = \" \" ) NEW_LINE last_entry = curr_max NEW_LINE DEDENT else : NEW_LINE INDENT curr_max += noOfNextD + 1 NEW_LINE last_entry = curr_max NEW_LINE print ( \" \" , last_entry , end = \" \" ) NEW_LINE DEDENT for k in range ( noOfNextD ) : NEW_LINE INDENT last_entry -= 1 NEW_LINE print ( \" \" , last_entry , end = \" \" ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT elif arr [ i ] == \" D \" : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT j = i + 1 NEW_LINE while j < len ( arr ) and arr [ j ] == \" D \" : NEW_LINE INDENT noOfNextD += 1 NEW_LINE j += 1 NEW_LINE DEDENT curr_max = noOfNextD + 2 NEW_LINE print ( \" \" , curr_max , curr_max - 1 , end = \" \" ) NEW_LINE last_entry = curr_max - 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" \" , last_entry - 1 , end = \" \" ) NEW_LINE last_entry -= 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT print ( ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT PrintMinNumberForPattern ( \" IDID \" ) NEW_LINE PrintMinNumberForPattern ( \" I \" ) NEW_LINE PrintMinNumberForPattern ( \" DD \" ) NEW_LINE PrintMinNumberForPattern ( \" II \" ) NEW_LINE PrintMinNumberForPattern ( \" DIDI \" ) NEW_LINE PrintMinNumberForPattern ( \" IIDDD \" ) NEW_LINE PrintMinNumberForPattern ( \" DDIDDIID \" ) NEW_LINE DEDENT"],"bleu":0.28405260106519864,"rouge_l":0.4372971663841123}
{"id":747,"predictions":["def findNumbers ( n ) : NEW_LINE INDENT i = 1 NEW_LINE while ( i <= n ) : NEW_LINE INDENT print ( ( 3 * i * ( i - 1 ) + 1 ) , end = \" ▁ \" ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE findNumbers ( n ) NEW_LINE DEDENT"],"references":["def findNumbers ( n ) : NEW_LINE INDENT i = 1 NEW_LINE while ( i <= n ) : NEW_LINE INDENT print ( ( 3 * i * ( i - 1 ) + 1 ) , end = \" ▁ \" ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT n = 4 NEW_LINE findNumbers ( n ) NEW_LINE"],"bleu":0.7856948408867069,"rouge_l":0.9113699670802735}
{"id":748,"predictions":["mod = 1000000007 NEW_LINE def number_of_ways ( arr , n , k ) : NEW_LINE INDENT if ( k == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT dp = [ - 1 ] * ( k + 1 ) NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( 0 , k + 1 ) : NEW_LINE INDENT dp [ arr [ i ] ] = - 1 NEW_LINE dp [ arr [ i ] ] = mod NEW_LINE DEDENT dp [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( dp [ arr [ i ] ] == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT dp [ arr [ i ] ] = dp [ arr [ i - 1 ] ] NEW_LINE dp [ arr [ i ] ] = mod NEW_LINE dp [ arr [ i ] ] %= mod NEW_LINE DEDENT return dp [ arr [ i ] ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE k = 6 NEW_LINE print ( number_of_ways ( arr , n , k ) ) NEW_LINE DEDENT"],"references":["MOD = 1000000007 ; NEW_LINE def number_of_ways ( arr , n , k ) : NEW_LINE INDENT if ( k == 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT dp = [ - 1 ] * ( k + 1 ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ arr [ i ] ] = 0 ; NEW_LINE DEDENT dp [ 0 ] = 1 ; NEW_LINE dp [ 1 ] = 1 if ( dp [ 1 ] == - 1 ) else dp [ 1 ] ; NEW_LINE for i in range ( 2 , k + 1 ) : NEW_LINE INDENT if ( dp [ i ] == 0 ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] ; NEW_LINE dp [ i ] %= MOD ; NEW_LINE DEDENT return dp [ k ] ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE k = 6 ; NEW_LINE print ( number_of_ways ( arr , n , k ) ) ; NEW_LINE DEDENT"],"bleu":0.6283390082105954,"rouge_l":0.7880293533098915}
{"id":749,"predictions":["def maxProfit ( prices , n , k ) : NEW_LINE INDENT profit = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT profit [ 0 ] [ i ] = 0 NEW_LINE for j in range ( 1 , n + 1 ) : NEW_LINE INDENT profit [ j ] [ i ] = 0 NEW_LINE DEDENT for i in range ( 1 , k + 1 ) : NEW_LINE INDENT profit [ i ] = max ( profit [ i - 1 ] , profit [ i ] [ j ] ) NEW_LINE DEDENT profit [ i ] [ j ] = max ( profit [ i ] , profit [ i ] [ j - 1 ] ) NEW_LINE profit [ i ] [ j ] = max ( profit [ i ] , profit [ i ] [ j ] ) NEW_LINE DEDENT return profit [ n - 1 ] [ n - 1 ] NEW_LINE DEDENT k = 3 NEW_LINE prices = [ 12 , 14 , 17 , 10 , 14 , 15 ] NEW_LINE n = len ( prices ) NEW_LINE print ( \" Maximum ▁ profit ▁ is : \" , maxProfit ( prices , n , k ) ) NEW_LINE"],"references":["def maxProfit ( price , n , k ) : NEW_LINE INDENT profit = [ [ 0 for i in range ( n + 1 ) ] for j in range ( k + 1 ) ] NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT prevDiff = float ( ' - inf ' ) NEW_LINE for j in range ( 1 , n ) : NEW_LINE INDENT prevDiff = max ( prevDiff , profit [ i - 1 ] [ j - 1 ] - price [ j - 1 ] ) NEW_LINE profit [ i ] [ j ] = max ( profit [ i ] [ j - 1 ] , price [ j ] + prevDiff ) NEW_LINE DEDENT DEDENT return profit [ k ] [ n - 1 ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT k = 3 NEW_LINE price = [ 12 , 14 , 17 , 10 , 14 , 13 , 12 , 15 ] NEW_LINE n = len ( price ) NEW_LINE print ( \" Maximum ▁ profit ▁ is : \" , maxProfit ( price , n , k ) ) NEW_LINE DEDENT"],"bleu":0.5988962277955773,"rouge_l":0.7308379223098675}
{"id":750,"predictions":["def originalArray ( greater , n ) : NEW_LINE INDENT temp = [ ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT temp . append ( i ) NEW_LINE DEDENT arr = [ ] NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT k = n - i NEW_LINE arr . remove ( temp [ 0 ] ) NEW_LINE DEDENT for i in range ( 0 , n , 1 ) : NEW_LINE INDENT k = n - ( i ) NEW_LINE arr . remove ( k ) NEW_LINE DEDENT for i in range ( 0 , n , 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT Arr = [ 6 , 3 , 2 , 1 , 0 , 0 , 0 ] NEW_LINE n = len ( Arr ) NEW_LINE originalArray ( Arr , n ) NEW_LINE DEDENT"],"references":["def originalArray ( greater , n ) : NEW_LINE INDENT temp = [ ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT temp . append ( i ) NEW_LINE DEDENT arr = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT k = n - greater [ i ] - i NEW_LINE arr [ i ] = temp [ k ] NEW_LINE del temp [ k ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 6 , 3 , 2 , 1 , 0 , 1 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE originalArray ( arr , n ) NEW_LINE"],"bleu":0.5922398480214516,"rouge_l":0.7681340410032262}
{"id":751,"predictions":["MAX = 1000 ; NEW_LINE f = [ 0 ] * MAX ; NEW_LINE def fib ( n ) : NEW_LINE INDENT if ( n == 0 or n == 2 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( f [ 1 ] ) : NEW_LINE INDENT return f [ n ] ; NEW_LINE DEDENT if ( f [ n ] ) : NEW_LINE INDENT return f [ n ] ; NEW_LINE DEDENT k = ( n + 1 ) \/\/ 2 ; NEW_LINE f [ n ] = ( fib ( k ) * fib ( k - 1 ) + fib ( k ) * fib ( k - 1 ) ) ; NEW_LINE f [ n ] = ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k ) ) ; NEW_LINE return f [ n ] ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 9 ; NEW_LINE f . append ( fib ( n ) ) ; NEW_LINE print ( fib ( n ) ) ; NEW_LINE DEDENT"],"references":["MAX = 1000 NEW_LINE f = [ 0 ] * MAX NEW_LINE def fib ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 1 or n == 2 ) : NEW_LINE INDENT f [ n ] = 1 NEW_LINE return ( f [ n ] ) NEW_LINE DEDENT if ( f [ n ] ) : NEW_LINE INDENT return f [ n ] NEW_LINE DEDENT if ( n & 1 ) : NEW_LINE INDENT k = ( n + 1 ) \/\/ 2 NEW_LINE DEDENT else : NEW_LINE INDENT k = n \/\/ 2 NEW_LINE DEDENT if ( ( n & 1 ) ) : NEW_LINE INDENT f [ n ] = ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT f [ n ] = ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ) NEW_LINE DEDENT return f [ n ] NEW_LINE DEDENT n = 9 NEW_LINE print ( fib ( n ) ) NEW_LINE"],"bleu":0.6343722016760054,"rouge_l":0.7195281782437746}
{"id":752,"predictions":["def getCount ( l , r , p ) : NEW_LINE INDENT cnt = 0 NEW_LINE val = p NEW_LINE while ( True ) : NEW_LINE INDENT a = r \/\/ val NEW_LINE b = ( l - 1 ) \/\/ val NEW_LINE val *= p NEW_LINE DEDENT return cnt NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT l , r , p = 2 , 8 , 2 NEW_LINE print ( getCount ( l , r , p ) ) NEW_LINE DEDENT"],"references":["def getCount ( l , r , p ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE val = p ; NEW_LINE while ( True ) : NEW_LINE INDENT a = r \/\/ val ; NEW_LINE b = ( l - 1 ) \/\/ val ; NEW_LINE val *= p ; NEW_LINE if ( a - b ) : NEW_LINE INDENT cnt += ( a - b ) ; NEW_LINE DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT return int ( cnt ) ; NEW_LINE DEDENT l = 2 ; NEW_LINE r = 8 ; NEW_LINE p = 2 ; NEW_LINE print ( getCount ( l , r , p ) ) ; NEW_LINE"],"bleu":0.4654243470512488,"rouge_l":0.6739807033924681}
{"id":753,"predictions":["def findMaxLen ( string ) : NEW_LINE INDENT n = len ( string ) NEW_LINE stk = [ ] NEW_LINE stk . append ( - 1 ) NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if string [ i ] == stk [ i ] : NEW_LINE INDENT stk . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT stk . append ( i ) NEW_LINE DEDENT DEDENT if stk == - 1 : NEW_LINE INDENT res = max ( res , i - stk [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT stk . append ( i ) NEW_LINE stk . append ( i ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = [ ] NEW_LINE stk = [ ] NEW_LINE print ( findMaxLen ( string ) ) NEW_LINE stk . append ( findMaxLen ( string ) ) NEW_LINE DEDENT"],"references":["def findMaxLen ( string ) : NEW_LINE INDENT n = len ( string ) NEW_LINE stk = [ ] NEW_LINE stk . append ( - 1 ) NEW_LINE result = 0 NEW_LINE for i in xrange ( n ) : NEW_LINE INDENT if string [ i ] == ' ( ' : NEW_LINE INDENT stk . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT stk . pop ( ) NEW_LINE if len ( stk ) != 0 : NEW_LINE INDENT result = max ( result , i - stk [ len ( stk ) - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT stk . append ( i ) NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT string = \" ( ( ( ) ( ) \" NEW_LINE print findMaxLen ( string ) NEW_LINE string = \" ( ) ( ( ) ) ) ) ) \" NEW_LINE print findMaxLen ( string ) NEW_LINE"],"bleu":0.562500262435679,"rouge_l":0.7175002557021583}
{"id":754,"predictions":["def binaryomialomial ( max , m ) : NEW_LINE INDENT for m in range ( 0 , max ) : NEW_LINE INDENT print ( m , end = \" ▁ \" ) NEW_LINE DEDENT binom = 1 NEW_LINE for x in range ( 1 , m + 1 ) : NEW_LINE INDENT if ( m and x != 0 ) : NEW_LINE INDENT binom = binom * ( m - x + 1 ) \/\/ x NEW_LINE print ( binom , end = \" ▁ \" ) NEW_LINE DEDENT print ( binom , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT max = 10 NEW_LINE binaryomial ( max , m ) NEW_LINE"],"references":["def printbinomial ( max ) : NEW_LINE INDENT for m in range ( max + 1 ) : NEW_LINE INDENT print ( ' % ▁ 2d ' % m , end = ' ▁ ' ) NEW_LINE binom = 1 NEW_LINE for x in range ( m + 1 ) : NEW_LINE INDENT if m != 0 and x != 0 : NEW_LINE INDENT binom = binom * ( m - x + 1 ) \/ x NEW_LINE DEDENT print ( ' % ▁ 4d ' % binom , end = ' ▁ ' ) NEW_LINE DEDENT print ( \" \\n \" , end = ' ' ) NEW_LINE DEDENT DEDENT max = 10 NEW_LINE printbinomial ( max ) NEW_LINE"],"bleu":0.5334190428105863,"rouge_l":0.7769069279216235}
{"id":755,"predictions":["def getmax ( arr , n , x ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = s + arr [ i ] NEW_LINE DEDENT print ( min ( s , x ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE x = 5 NEW_LINE n = len ( arr ) NEW_LINE getmax ( arr , n , x ) NEW_LINE DEDENT"],"references":["def getmax ( arr , n , x ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = s + arr [ i ] NEW_LINE DEDENT print ( min ( s , x ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE x = 5 NEW_LINE arr_size = len ( arr ) NEW_LINE getmax ( arr , arr_size , x ) NEW_LINE DEDENT"],"bleu":0.8899040144633984,"rouge_l":0.956989247311828}
{"id":756,"predictions":["def isPossible ( w , h , x , y ) : NEW_LINE INDENT if ( x * 2 == w and y * 2 == h ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT w , h , x , y = 1 , 2 , 1 ; NEW_LINE if ( isPossible ( w , h , x ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"],"references":["def isPossible ( w , h , x , y ) : NEW_LINE INDENT if ( x * 2 == w and y * 2 == h ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT w = 1 NEW_LINE h = 2 NEW_LINE x = 1 NEW_LINE y = 2 NEW_LINE if ( isPossible ( w , h , x , y ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.7349833865925416,"rouge_l":0.8727838258164853}
{"id":757,"predictions":["def ddf ( x0 , y0 , x1 , h ) : NEW_LINE INDENT return ( x1 + y - 2 ) \/ h NEW_LINE DEDENT def compute ( x0 , y0 , h ) : NEW_LINE INDENT n = ( x - x0 ) \/ ( x1 + 0.5 ) NEW_LINE k1 = y0 NEW_LINE y0 = y0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT k1 = h * ddf ( x0 , y1 , h ) NEW_LINE DEDENT y1 = h NEW_LINE return y1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x0 = 0 NEW_LINE y0 = 1 NEW_LINE x1 = 2 NEW_LINE h = 0.5 NEW_LINE h = 0.5 NEW_LINE print ( compute ( x0 , y0 , h ) ) NEW_LINE DEDENT"],"references":["def dydx ( x , y ) : NEW_LINE INDENT return ( x + y - 2 ) ; NEW_LINE DEDENT def rungeKutta ( x0 , y0 , x , h ) : NEW_LINE INDENT n = round ( ( x - x0 ) \/ h ) ; NEW_LINE y = y0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT k1 = h * dydx ( x0 , y ) ; NEW_LINE k2 = h * dydx ( x0 + 0.5 * h , y + 0.5 * k1 ) ; NEW_LINE y = y + ( 1.0 \/ 6.0 ) * ( k1 + 2 * k2 ) ; NEW_LINE x0 = x0 + h ; NEW_LINE DEDENT return y ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x0 = 0 ; y = 1 ; NEW_LINE x = 2 ; h = 0.2 ; NEW_LINE print ( \" y ( x ) ▁ = \" , rungeKutta ( x0 , y , x , h ) ) ; NEW_LINE DEDENT"],"bleu":0.37797122801520555,"rouge_l":0.6207598371777476}
{"id":758,"predictions":["MAX_CHAR = 26 NEW_LINE def countPalindrome ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE hashTable = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( n ) : NEW_LINE INDENT hashTable [ str [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( hashTable [ ord ( str [ i ] ) ] ) : NEW_LINE INDENT sumTable [ ord ( hash [ i ] ) ] += 1 NEW_LINE DEDENT DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( hashTable [ ord ( str [ i ] ) ] != 0 ) : NEW_LINE INDENT sumTable [ ord ( hashTable [ ord ( str [ i ] ) ] ) ] += 1 NEW_LINE DEDENT DEDENT return sumTable NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" anagram \" NEW_LINE print ( countPalindrome ( str ) ) NEW_LINE DEDENT"],"references":["MAX_CHAR = 26 NEW_LINE def countPalindrome ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE sum = 0 NEW_LINE hashTable = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( n ) : NEW_LINE INDENT hashTable [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( hashTable [ i ] ) : NEW_LINE INDENT sum += ( hashTable [ i ] * ( hashTable [ i ] + 1 ) \/\/ 2 ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" ananananddd \" NEW_LINE print ( countPalindrome ( str ) ) NEW_LINE DEDENT"],"bleu":0.6076549359602548,"rouge_l":0.8007622273978404}
{"id":759,"predictions":["def __gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return __gcd ( a - b , b ) NEW_LINE DEDENT return __gcd ( a , b - a ) NEW_LINE DEDENT def NumberOfSquares ( m , n ) : NEW_LINE INDENT s = __gcd ( x , y ) NEW_LINE ans = ( x * y ) \/ ( s * m ) NEW_LINE return ans NEW_LINE DEDENT m = 80 NEW_LINE n = 60 NEW_LINE print ( NumberOfSquares ( m , n ) ) NEW_LINE"],"references":["def __gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a ; NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return __gcd ( a - b , b ) ; NEW_LINE DEDENT return __gcd ( a , b - a ) ; NEW_LINE DEDENT def NumberOfSquares ( x , y ) : NEW_LINE INDENT s = __gcd ( x , y ) ; NEW_LINE ans = ( x * y ) \/ ( s * s ) ; NEW_LINE return int ( ans ) ; NEW_LINE DEDENT m = 385 ; NEW_LINE n = 60 ; NEW_LINE print ( NumberOfSquares ( m , n ) ) ; NEW_LINE"],"bleu":0.6819544734142952,"rouge_l":0.8452975920036349}
{"id":760,"predictions":["def divisibility ( arr , n ) : NEW_LINE INDENT s = [ ] NEW_LINE max_ele = - 2147483648 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . append ( arr [ i ] ) NEW_LINE max_ele = max ( arr [ i ] , arr [ i ] ) NEW_LINE DEDENT res = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] != 0 ) : NEW_LINE INDENT res . append ( arr [ i ] ) NEW_LINE DEDENT if ( len ( res ) != 0 ) : NEW_LINE INDENT for j in range ( arr [ i ] ) : NEW_LINE INDENT print ( res [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 3 , 8 , 6 , 9 , 10 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE divisibility ( arr , n ) NEW_LINE DEDENT"],"references":["import math as mt NEW_LINE def divisibilityCheck ( arr , n ) : NEW_LINE INDENT s = dict ( ) NEW_LINE max_ele = - 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s [ arr [ i ] ] = 1 NEW_LINE max_ele = max ( max_ele , arr [ i ] ) NEW_LINE DEDENT res = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] != 0 ) : NEW_LINE INDENT for j in range ( arr [ i ] * 2 , max_ele + 1 , arr [ i ] ) : NEW_LINE INDENT if ( j in s . keys ( ) ) : NEW_LINE INDENT res [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT for x in res : NEW_LINE INDENT print ( x , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 2 , 3 , 8 , 6 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE divisibilityCheck ( arr , n ) NEW_LINE"],"bleu":0.6679073450568752,"rouge_l":0.6982477767015937}
{"id":761,"predictions":["def leftRotate ( arr , d , k , n ) : NEW_LINE INDENT d = d % n NEW_LINE for i in range ( 0 , d , 1 ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE j = i NEW_LINE while ( True ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE if ( k >= n ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( k == i ) : NEW_LINE INDENT k = k - n NEW_LINE DEDENT arr [ k ] = arr [ j ] NEW_LINE j = k NEW_LINE DEDENT DEDENT DEDENT def printArray ( arr , size ) : NEW_LINE INDENT for i in range ( 0 , size ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT def printArray ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT def printArray ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 6 ] NEW_LINE printArray ( arr , 7 ) NEW_LINE DEDENT"],"references":["def leftRotate ( arr , d , n ) : NEW_LINE INDENT d = d % n NEW_LINE g_c_d = gcd ( d , n ) NEW_LINE for i in range ( g_c_d ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE j = i NEW_LINE while 1 : NEW_LINE INDENT k = j + d NEW_LINE if k >= n : NEW_LINE INDENT k = k - n NEW_LINE DEDENT if k == i : NEW_LINE INDENT break NEW_LINE DEDENT arr [ j ] = arr [ k ] NEW_LINE j = k NEW_LINE DEDENT arr [ j ] = temp NEW_LINE DEDENT DEDENT def printArray ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( \" % ▁ d \" % arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT def gcd ( a , b ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT return a ; NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( b , a % b ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE d = 2 NEW_LINE leftRotate ( arr , d , n ) NEW_LINE printArray ( arr , n ) NEW_LINE"],"bleu":0.5435783294282467,"rouge_l":0.6544442181028044}
{"id":762,"predictions":["def isPerfectOrder ( n ) : NEW_LINE INDENT flag = True NEW_LINE prev = - 1 NEW_LINE if ( n ) : NEW_LINE INDENT if ( prev == - 1 ) : NEW_LINE INDENT if ( prev == - 1 ) : NEW_LINE INDENT prev = n NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT if ( prev == - 1 ) : NEW_LINE INDENT prev = n % 10 NEW_LINE continue NEW_LINE DEDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT prev = n % 10 NEW_LINE if ( prev == n ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT prev = n % 10 NEW_LINE n = int ( n \/ 10 ) NEW_LINE if ( prev == n % 10 ) : NEW_LINE INDENT flag = True NEW_LINE break NEW_LINE DEDENT prev = n % 10 NEW_LINE n = int ( n \/ 10 ) NEW_LINE if ( prev == n ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT return flag NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 12345 NEW_LINE if ( isPerfectOrder ( n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"references":["def isCorrectOrder ( n ) : NEW_LINE INDENT flag = True ; NEW_LINE prev = - 1 ; NEW_LINE type = - 1 ; NEW_LINE while ( n != 0 ) : NEW_LINE INDENT if ( type == - 1 ) : NEW_LINE INDENT if ( prev == - 1 ) : NEW_LINE INDENT prev = n % 10 ; NEW_LINE n = int ( n \/ 10 ) ; NEW_LINE continue ; NEW_LINE DEDENT if ( prev == n % 10 ) : NEW_LINE INDENT flag = False ; NEW_LINE break ; NEW_LINE DEDENT if ( prev > n % 10 ) : NEW_LINE INDENT type = 1 ; NEW_LINE prev = n % 10 ; NEW_LINE n = int ( n \/ 10 ) ; NEW_LINE continue ; NEW_LINE DEDENT prev = n % 10 ; NEW_LINE n = int ( n \/ 10 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( prev == n % 10 ) : NEW_LINE INDENT flag = False ; NEW_LINE break ; NEW_LINE DEDENT if ( prev < n % 10 ) : NEW_LINE INDENT flag = False ; NEW_LINE break ; NEW_LINE DEDENT prev = n % 10 ; NEW_LINE n = int ( n \/ 10 ) ; NEW_LINE DEDENT DEDENT return flag ; NEW_LINE DEDENT n = 123454321 ; NEW_LINE if ( isCorrectOrder ( n ) ) : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE DEDENT"],"bleu":0.541269672251089,"rouge_l":0.6625933469110659}
{"id":763,"predictions":["def K_area ( a , n , k ) : NEW_LINE INDENT a . sort ( ) ; NEW_LINE s = set ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] % k == 0 and a [ i ] \/\/ k != 0 ) : NEW_LINE INDENT s . add ( a [ i ] \/\/ k ) ; NEW_LINE DEDENT DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 2 , 3 , 4 , 5 , 6 , 10 ] ; NEW_LINE k = 2 ; NEW_LINE K = 2 ; NEW_LINE DEDENT"],"references":["def K_multiple ( a , n , k ) : NEW_LINE INDENT a . sort ( ) ; NEW_LINE s = set ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( a [ i ] % k == 0 and a [ i ] \/\/ k not in s ) or a [ i ] % k != 0 ) : NEW_LINE INDENT s . add ( a [ i ] ) ; NEW_LINE DEDENT DEDENT for i in s : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 2 , 3 , 4 , 5 , 6 , 10 ] ; NEW_LINE k = 2 ; NEW_LINE n = len ( a ) ; NEW_LINE K_multiple ( a , n , k ) ; NEW_LINE DEDENT"],"bleu":0.7787463757401916,"rouge_l":0.8584109114526955}
{"id":764,"predictions":["import numpy as np NEW_LINE maxN = 20 NEW_LINE maxM = 20 NEW_LINE dp = np . zeros ( ( maxN , maxM ) ) NEW_LINE v = np . zeros ( ( maxN , maxM ) ) NEW_LINE def findCnt ( arr , i , curr , n , m ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT if ( curr == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if ( v [ i ] ) : NEW_LINE INDENT return dp [ i ] [ curr ] NEW_LINE DEDENT v [ i ] [ curr ] = findCnt ( arr , i + 1 , curr , n , m ) + findCnt ( arr , i + 1 , curr , n , m ) ) NEW_LINE return dp [ i ] [ curr ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 3 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE m = 6 NEW_LINE print ( findCnt ( arr , 0 , n , m ) - 1 ) NEW_LINE DEDENT"],"references":["maxN = 20 NEW_LINE maxM = 10 NEW_LINE dp = [ [ 0 for i in range ( maxN ) ] for i in range ( maxM ) ] NEW_LINE v = [ [ 0 for i in range ( maxN ) ] for i in range ( maxM ) ] NEW_LINE def findCnt ( arr , i , curr , n , m ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT if ( curr == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if ( v [ i ] [ curr ] ) : NEW_LINE INDENT return dp [ i ] [ curr ] NEW_LINE DEDENT v [ i ] [ curr ] = 1 NEW_LINE dp [ i ] [ curr ] = findCnt ( arr , i + 1 , curr , n , m ) +   \\ NEW_LINE INDENT findCnt ( arr , i + 1 , ( curr + arr [ i ] ) % m , n , m ) NEW_LINE DEDENT return dp [ i ] [ curr ] NEW_LINE DEDENT arr = [ 3 , 3 , 3 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE m = 6 NEW_LINE print ( findCnt ( arr , 0 , 0 , n , m ) - 1 ) NEW_LINE"],"bleu":0.6386088138005028,"rouge_l":0.7599296497142018}
{"id":765,"predictions":["def minSteps ( str ) : NEW_LINE INDENT c = 0 NEW_LINE for i in range ( len ( str ) - 2 ) : NEW_LINE INDENT if str [ i ] == '0' : NEW_LINE INDENT if str [ i + 2 ] == '1' : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT DEDENT return c NEW_LINE DEDENT str = \"01010\" NEW_LINE print ( minSteps ( str ) ) NEW_LINE"],"references":["def minSteps ( str ) : NEW_LINE INDENT count = 0 NEW_LINE i = 0 NEW_LINE while i < len ( str ) - 2 : NEW_LINE INDENT if str [ i ] == '0' : NEW_LINE INDENT if ( str [ i + 1 ] == '1' ) : NEW_LINE INDENT if ( str [ i + 2 ] == '0' ) : NEW_LINE INDENT count = count + 1 NEW_LINE i = i + 2 NEW_LINE DEDENT DEDENT DEDENT i = i + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT str = \"0101010\" NEW_LINE print ( minSteps ( str ) ) NEW_LINE"],"bleu":0.4261335491022407,"rouge_l":0.6711760461760462}
{"id":766,"predictions":["def checkSemiprime ( num ) : NEW_LINE INDENT cnt = 0 NEW_LINE i = 2 NEW_LINE while ( num ) : NEW_LINE INDENT while ( num % i == 0 ) : NEW_LINE INDENT num \/= i NEW_LINE cnt += 1 NEW_LINE DEDENT if ( num > 1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if ( num > 1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT return cnt NEW_LINE DEDENT def semiprime ( n ) : NEW_LINE INDENT if ( checkSemrime ( n ) ) : NEW_LINE INDENT print ( \" False \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" False \" ) NEW_LINE DEDENT DEDENT n = 6 NEW_LINESemiime ( n ) NEW_LINE"],"references":["import math NEW_LINE def checkSemiprime ( num ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( 2 , int ( math . sqrt ( num ) ) + 1 ) : NEW_LINE INDENT while num % i == 0 : NEW_LINE INDENT num \/= i NEW_LINE cnt += 1 NEW_LINE DEDENT if cnt >= 2 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( num > 1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT return cnt == 2 NEW_LINE DEDENT def semiprime ( n ) : NEW_LINE INDENT if checkSemiprime ( n ) == True : NEW_LINE INDENT print ( \" True \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" False \" ) NEW_LINE DEDENT DEDENT n = 6 NEW_LINE semiprime ( n ) NEW_LINE n = 8 NEW_LINE semiprime ( n ) ; NEW_LINE"],"bleu":0.6235552090972589,"rouge_l":0.7621404997642621}
{"id":767,"predictions":["def XandYandZinterii ( p , q , z , c , d , e ) : NEW_LINE INDENT x = - d \/ c NEW_LINE y = y + d \/ c NEW_LINE z = z \/ ( d - e ) NEW_LINE x1 = x1 - ( z - e ) NEW_LINE y1 = z \/ c NEW_LINE z = y1 NEW_LINE r = z - z NEW_LINE x2 = z \/ c NEW_LINE return ( x1 , y1 , z ) NEW_LINE DEDENT def equation ( p , q , R , C ) : NEW_LINE INDENT x1 = p [ 0 ] NEW_LINE x2 = p [ 1 ] NEW_LINE y2 = q [ 2 ] NEW_LINE z1 = q [ 0 ] NEW_LINE x2 = x2 - x1 NEW_LINE y2 = y2 - y1 NEW_LINE z1 = z2 - z1 NEW_LINE a = x2 - x1 NEW_LINE b = z1 - z1 NEW_LINE c = x2 - x1 NEW_LINE d = y2 - z1 NEW_LINE b = z1 - z2 NEW_LINE c = c NEW_LINE d = x2 - z1 NEW_LINE DEDENT return ( ( - X1 , x2 , y1 , z2 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x1 = - - 1 NEW_LINE y1 = 0 NEW_LINE z = 1 NEW_LINE x2 = - 1 NEW_LINE y2 = - 4 NEW_LINE z2 = 1 NEW_LINE r = 2 NEW_LINE z3 = 2 NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT x1 = xx [ i ] NEW_LINE y1 = y2 - z1 NEW_LINE x2 = z2 - z1 NEW_LINE DEDENT print ( x1 , y1 , z2 . zstrip ( ) ) NEW_LINE DEDENT"],"references":["def XandYandZintercept ( A , B , C , D ) : NEW_LINE INDENT x = - D \/ A NEW_LINE y = - D \/ B NEW_LINE z = - D \/ C NEW_LINE return [ x , y , z ] NEW_LINE DEDENT def equation_plane ( p , q , r ) : NEW_LINE INDENT x1 = p [ 0 ] NEW_LINE y1 = p [ 1 ] NEW_LINE z1 = p [ 2 ] NEW_LINE x2 = q [ 0 ] NEW_LINE y2 = q [ 1 ] NEW_LINE z2 = q [ 2 ] NEW_LINE x3 = r [ 0 ] NEW_LINE y3 = r [ 1 ] NEW_LINE z3 = r [ 2 ] NEW_LINE a1 = x2 - x1 NEW_LINE b1 = y2 - y1 NEW_LINE c1 = z2 - z1 NEW_LINE a2 = x3 - x1 NEW_LINE b2 = y3 - y1 NEW_LINE c2 = z3 - z1 NEW_LINE A = b1 * c2 - b2 * c1 NEW_LINE B = a2 * c1 - a1 * c2 NEW_LINE C = a1 * b2 - b1 * a2 NEW_LINE D = ( - A * x1 - B * y1 - C * z1 ) NEW_LINE print ( XandYandZintercept ( A , B , C , D ) ) NEW_LINE DEDENT x1 = - 1 NEW_LINE y1 = 2 NEW_LINE z1 = 1 NEW_LINE x2 = 0 NEW_LINE y2 = - 3 NEW_LINE z2 = 2 NEW_LINE x3 = 1 NEW_LINE y3 = 1 NEW_LINE z3 = - 4 NEW_LINE equation_plane ( ( x1 , y1 , z1 ) , ( x2 , y2 , z2 ) , ( x3 , y3 , z3 ) ) NEW_LINE"],"bleu":0.3287749761857153,"rouge_l":0.5179212490740214}
{"id":768,"predictions":["def mulmod ( a , b , mod ) : NEW_LINE INDENT res = 0 NEW_LINE a = a % mod NEW_LINE while ( b > 0 ) : NEW_LINE INDENT if ( b % 2 == 1 ) : NEW_LINE INDENT res = ( res + a ) % mod NEW_LINE DEDENT a = ( a * 2 ) % mod NEW_LINE b \/\/= 2 NEW_LINE DEDENT return res % mod NEW_LINE DEDENT def mulmod ( a , b , 1000000009 ) : NEW_LINE INDENT if ( b % 2 == 1 ) : NEW_LINE INDENT res = ( res + a ) % modul ( b * 2 ) NEW_LINE DEDENT return res % mod NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a , b , 1000000009 NEW_LINE DEDENT a , b , 1000000009 NEW_LINE print ( mulmod ( a , b , 1000000007 ) ) NEW_LINE"],"references":["def mulmod ( a , b , mod ) : NEW_LINE INDENT res = 0 ; NEW_LINE a = a % mod ; NEW_LINE while ( b > 0 ) : NEW_LINE INDENT if ( b % 2 == 1 ) : NEW_LINE INDENT res = ( res + a ) % mod ; NEW_LINE DEDENT a = ( a * 2 ) % mod ; NEW_LINE b \/\/= 2 ; NEW_LINE DEDENT return res % mod ; NEW_LINE DEDENT a = 9223372036854775807 ; NEW_LINE b = 9223372036854775807 ; NEW_LINE print ( mulmod ( a , b , 100000000000 ) ) ; NEW_LINE"],"bleu":0.47241694978798354,"rouge_l":0.7192453818944058}
{"id":769,"predictions":["MAX_CHAR = 26 NEW_LINE def sortString ( str ) : NEW_LINE INDENT letters = [ 0 ] * MAX_CHAR NEW_LINE for x in range ( len ( str ) ) : NEW_LINE INDENT letters [ ord ( str [ x ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 0 , MAX_CHAR ) : NEW_LINE INDENT ch = ord ( ' a ' ) NEW_LINE for j in range ( ord ( ' a ' ) , ord ( str [ j ] ) ) : NEW_LINE INDENT ch = chr ( ord ( ch ) + ord ( ' a ' ) ) NEW_LINE print ( ch ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeksforgeeks \" NEW_LINE sortString ( str ) NEW_LINE DEDENT"],"references":["MAX_CHAR = 26 NEW_LINE def sortString ( str ) : NEW_LINE INDENT charCount = [ 0 for i in range ( MAX_CHAR ) ] NEW_LINE for i in range ( 0 , len ( str ) , 1 ) : NEW_LINE INDENT charCount [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 0 , MAX_CHAR , 1 ) : NEW_LINE INDENT for j in range ( 0 , charCount [ i ] , 1 ) : NEW_LINE INDENT print ( chr ( ord ( ' a ' ) + i ) , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" geeksforgeeks \" NEW_LINE sortString ( s ) NEW_LINE DEDENT"],"bleu":0.5363509623668734,"rouge_l":0.7406945074897866}
{"id":770,"predictions":["def pentagon_pyramidal ( n ) : NEW_LINE INDENT summ = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT p = ( 3 * i * i - i ) \/ 2 NEW_LINE summ = summ + p NEW_LINE summ = summ + p NEW_LINE DEDENT return summ NEW_LINE DEDENT n = 4 NEW_LINE print ( pentagon_pyramidal ( n ) ) NEW_LINE"],"references":["def pentagon_pyramidal ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT p = ( 3 * i * i - i ) \/ 2 NEW_LINE sum = sum + p NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 4 NEW_LINE print ( int ( pentagon_pyramidal ( n ) ) ) NEW_LINE"],"bleu":0.7578817401814806,"rouge_l":0.8775908315045111}
{"id":771,"predictions":["def count ( n ) : NEW_LINE INDENT table = [ [ 0 for i in range ( ( n + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE table [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT table [ i ] [ 1 ] += table [ i - 1 ] NEW_LINE DEDENT for i in range ( 5 , n + 1 ) : NEW_LINE INDENT table [ i ] [ 0 ] += table [ i - 5 ] [ 1 ] NEW_LINE DEDENT for i in range ( 10 , n + 1 ) : NEW_LINE INDENT table [ i ] [ 2 ] = table [ i - 5 ] [ 0 ] NEW_LINE DEDENT return table [ n ] [ 1 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 20 NEW_LINE print ( \" Count ▁ of ▁ for ▁ n ▁ = ▁ \" , count ( n ) , \" is \" , count ( n ) ) NEW_LINE DEDENT"],"references":["def count ( n ) : NEW_LINE INDENT table = [ 0 for i in range ( n + 1 ) ] NEW_LINE table [ 0 ] = 1 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT table [ i ] += table [ i - 3 ] NEW_LINE DEDENT for i in range ( 5 , n + 1 ) : NEW_LINE INDENT table [ i ] += table [ i - 5 ] NEW_LINE DEDENT for i in range ( 10 , n + 1 ) : NEW_LINE INDENT table [ i ] += table [ i - 10 ] NEW_LINE DEDENT return table [ n ] NEW_LINE DEDENT n = 20 NEW_LINE print ( ' Count ▁ for ' , n , ' is ' , count ( n ) ) NEW_LINE n = 13 NEW_LINE print ( ' Count ▁ for ' , n , ' is ' , count ( n ) ) NEW_LINE"],"bleu":0.618833960262471,"rouge_l":0.7742671902109397}
{"id":772,"predictions":["MAX = 26 ; NEW_LINE def minimum_element ( freq , a ) : NEW_LINE INDENT max_ele = freq [ 0 ] NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if ( max_ele < freq [ i ] ) : NEW_LINE INDENT max_ele = freq [ i ] NEW_LINE DEDENT DEDENT return max_ele NEW_LINE DEDENT def minimum_element ( str , len ) : NEW_LINE INDENT freq = [ 0 ] * MAX NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT max_ele = max ( freq [ MAX_ele ] , len ( freq ) ) NEW_LINE min_ele = 0 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if ( freq [ i ] > 0 ) : NEW_LINE INDENT min_ele += abs ( max_ele - freq [ i ] ) NEW_LINE DEDENT DEDENT return min_ele NEW_LINE DEDENT str = \" geeksforgeeks \" NEW_LINE l = len ( str ) NEW_LINE print ( minimum_element ) NEW_LINE"],"references":["MAX = 26 NEW_LINE def minimumAddition ( str1 , Len ) : NEW_LINE INDENT freq = [ 0 for i in range ( MAX ) ] NEW_LINE for i in range ( Len ) : NEW_LINE INDENT freq [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT maxFreq = max ( freq ) NEW_LINE minAddition = 0 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if ( freq [ i ] > 0 ) : NEW_LINE INDENT minAddition += abs ( maxFreq - freq [ i ] ) NEW_LINE DEDENT DEDENT return minAddition NEW_LINE DEDENT str1 = \" geeksforgeeks \" NEW_LINE Len = len ( str1 ) NEW_LINE print ( minimumAddition ( str1 , Len ) ) NEW_LINE"],"bleu":0.47250260735774735,"rouge_l":0.7266539034248033}
{"id":773,"predictions":["from math import gcd NEW_LINE def addE gcd ( a , b ) : NEW_LINE INDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT def addE gcd ( node , node , parent , node ) : NEW_LINE INDENT if node == parent : NEW_LINE INDENT GCD = gcd ( node , node ) NEW_LINE DEDENT return Gcd ( GCD , node ) NEW_LINE DEDENT def addEgcd ( a , b ) : NEW_LINE INDENT if ( node != parent ) : NEW_LINE INDENT GCD = gcd ( G , node , a ) NEW_LINE DEDENT return GCD NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 8 NEW_LINE graph = [ [ None ] * ( n + 1 ) for _ in range ( n + 1 ) ] NEW_LINE for it in range ( n + 1 ) : NEW_LINE INDENT a , b = mp . gcd ( it , adj [ a ] , graph [ it ] ) NEW_LINE DEDENT print ( addEcd ( adj , 1 , 2 ) ) NEW_LINE DEDENT"],"references":["from math import gcd NEW_LINE N = 9 NEW_LINE def addEgde ( adj , u , v ) : NEW_LINE INDENT adj [ u ] . append ( v ) NEW_LINE adj [ v ] . append ( u ) NEW_LINE DEDENT def DFS ( node , parent , G , leaf , val , adj ) : NEW_LINE INDENT if ( node == leaf ) : NEW_LINE INDENT G = gcd ( G , val [ node ] ) NEW_LINE print ( G , end = \" \" ) NEW_LINE return NEW_LINE DEDENT for it in adj [ node ] : NEW_LINE INDENT if ( it != parent ) : NEW_LINE INDENT DFS ( it , node , gcd ( G , val [ it ] ) , leaf , val , adj ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 8 NEW_LINE adj = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE addEgde ( adj , 1 , 2 ) NEW_LINE addEgde ( adj , 2 , 4 ) NEW_LINE addEgde ( adj , 1 , 3 ) NEW_LINE addEgde ( adj , 3 , 5 ) NEW_LINE addEgde ( adj , 3 , 6 ) NEW_LINE addEgde ( adj , 6 , 7 ) NEW_LINE addEgde ( adj , 6 , 8 ) NEW_LINE leaf = 5 NEW_LINE val = [ - 1 , 6 , 2 , 6 , 3 , 4 , 12 , 10 , 18 ] NEW_LINE G = val [ 1 ] NEW_LINE DFS ( 1 , - 1 , G , leaf , val , adj ) NEW_LINE DEDENT"],"bleu":0.24313877528804956,"rouge_l":0.4692009408174941}
{"id":774,"predictions":["def countNums ( l , r ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT lastDigit = ( i % 10 ) NEW_LINE if ( ( lastDigit % 10 ) == 2 or ( lastDigit % 10 ) == 3 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT l = 11 NEW_LINE r = 33 NEW_LINE print ( countNums ( l , r ) ) NEW_LINE DEDENT"],"references":["def countNums ( l , r ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT lastDigit = ( i % 10 ) ; NEW_LINE if ( ( lastDigit % 10 ) == 2 or ( lastDigit % 10 ) == 3 or ( lastDigit % 10 ) == 9 ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT return cnt ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT l = 11 ; r = 33 ; NEW_LINE print ( countNums ( l , r ) ) ; NEW_LINE DEDENT"],"bleu":0.7038620806451639,"rouge_l":0.8950022925263642}
{"id":775,"predictions":["def countMaxSetBits ( left , right ) : NEW_LINE INDENT max_count = - 1 NEW_LINE num = 0 NEW_LINE for i in range ( left , right + 1 ) : NEW_LINE INDENT temp = i NEW_LINE cnt = 0 NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT if ( temp % 2 == 1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT temp \/\/= 1 NEW_LINE DEDENT if ( cnt > max_count ) : NEW_LINE INDENT max_count = cnt NEW_LINE num = i NEW_LINE DEDENT DEDENT return num NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT l = 1 NEW_LINE r = 5 NEW_LINE print ( countMaxSetBits ( l , r ) ) NEW_LINE DEDENT"],"references":["def countMaxSetBits ( left , right ) : NEW_LINE INDENT max_count = - 1 NEW_LINE for i in range ( left , right + 1 ) : NEW_LINE INDENT temp = i NEW_LINE cnt = 0 NEW_LINE while temp : NEW_LINE INDENT if temp & 1 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT temp = temp >> 1 NEW_LINE DEDENT if cnt > max_count : NEW_LINE INDENT max_count = cnt NEW_LINE num = i NEW_LINE DEDENT DEDENT return num NEW_LINE DEDENT l = 1 NEW_LINE r = 5 NEW_LINE print ( countMaxSetBits ( l , r ) ) NEW_LINE l = 1 NEW_LINE r = 10 NEW_LINE print ( countMaxSetBits ( l , r ) ) NEW_LINE"],"bleu":0.6725630701773737,"rouge_l":0.791565287915653}
{"id":776,"predictions":["import math NEW_LINE def checkPerfectcube ( n ) : NEW_LINE INDENT d = str ( n ) NEW_LINE if ( d * d == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def smallestPerfectcube ( a , n ) : NEW_LINE INDENT mini = float ( \" inf \" ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( checkPerfectcube ( a [ i ] , mini ) ) : NEW_LINE INDENT mini = min ( a [ i ] , mini ) NEW_LINE DEDENT DEDENT return mini NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 16 NEW_LINE n = len ( a ) NEW_LINE print ( smallestPerfectcube ( a , n ) ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE def checkPerfectcube ( n ) : NEW_LINE INDENT d = int ( n ** ( 1 \/ 3 ) ) ; NEW_LINE if ( d * d * d == n ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT def smallestPerfectCube ( a , n ) : NEW_LINE INDENT mini = sys . maxsize ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( checkPerfectcube ( a [ i ] ) ) : NEW_LINE INDENT mini = min ( a [ i ] , mini ) ; NEW_LINE DEDENT DEDENT return mini ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 16 , 8 , 25 , 2 , 3 , 10 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( smallestPerfectCube ( a , n ) ) ; NEW_LINE DEDENT"],"bleu":0.6235746262845043,"rouge_l":0.8234122593494135}
{"id":777,"predictions":["def subtract ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE maximum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = 0 NEW_LINE for j in range ( i , n , 1 ) : NEW_LINE INDENT s += a [ j ] NEW_LINE maximum = max ( a [ j ] , maximum ) NEW_LINE DEDENT if ( s % 2 == 0 and s > maximum ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT def countSubarrays ( a , n ) : NEW_LINE INDENT pre = [ 0 ] * n NEW_LINE pre = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT pre [ i ] += pre [ i ] NEW_LINE DEDENT if ( i != 0 ) : NEW_LINE INDENT pre [ i ] += 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT pre [ i ] += pre [ i - 1 ] NEW_LINE DEDENT return pre NEW_LINE DEDENT a = [ 6 , 7 , 14 ] NEW_LINE n = len ( a ) NEW_LINE print ( countSubarrays ( a , n ) ) NEW_LINE"],"references":["def exclude ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT s = 0 NEW_LINE maximum = 0 NEW_LINE for j in range ( i , min ( n , i + 60 ) ) : NEW_LINE INDENT s += a [ j ] NEW_LINE maximum = max ( a [ j ] , maximum ) NEW_LINE if s % 2 == 0 and 2 * maximum > s : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT def countSubarrays ( a , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT a [ i ] = bin ( a [ i ] ) . count ( '1' ) NEW_LINE DEDENT pre = [ None ] * n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT pre [ i ] = a [ i ] NEW_LINE if i != 0 : NEW_LINE INDENT pre [ i ] += pre [ i - 1 ] NEW_LINE DEDENT DEDENT odd , even = 0 , 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if pre [ i ] & 1 : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT even = n - odd NEW_LINE even += 1 NEW_LINE answer = ( ( odd * ( odd - 1 ) \/\/ 2 ) + ( even * ( even - 1 ) \/\/ 2 ) ) NEW_LINE print ( answer ) NEW_LINE answer = answer - exclude ( a , n ) NEW_LINE return answer NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 6 , 7 , 14 ] NEW_LINE n = len ( a ) NEW_LINE print ( countSubarrays ( a , n ) ) NEW_LINE DEDENT"],"bleu":0.4512176282796098,"rouge_l":0.6585840707964602}
{"id":778,"predictions":["def printPermutation ( N , K ) : NEW_LINE INDENT res = [ ] NEW_LINE l = 1 NEW_LINE r = N NEW_LINE flag = 0 NEW_LINE l = 1 NEW_LINE while ( K < N ) : NEW_LINE INDENT if ( flag == 0 ) : NEW_LINE INDENT res . append ( l ) NEW_LINE l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT res . append ( r ) NEW_LINE l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT flag ^= 1 NEW_LINE DEDENT if ( flag != 1 ) : NEW_LINE INDENT for i in range ( r , l + 1 , - 1 ) : NEW_LINE INDENT res . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT res . append ( i ) NEW_LINE DEDENT DEDENT for i in range ( l , r + 1 ) : NEW_LINE INDENT res . append ( i ) NEW_LINE DEDENT DEDENT def printPermutation ( N , K ) : NEW_LINE INDENT res = [ ] NEW_LINE printPermutation ( N , K ) NEW_LINE DEDENT N = 10 NEW_LINE K = 4 NEW_LINE printPermutation ( N , K ) NEW_LINE"],"references":["def printPermutation ( N , K ) : NEW_LINE INDENT res = list ( ) ; NEW_LINE l , r , flag = 1 , N , 0 NEW_LINE for i in range ( K ) : NEW_LINE INDENT if flag == False : NEW_LINE INDENT res . append ( l ) NEW_LINE l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT res . append ( r ) ; NEW_LINE r -= 1 ; NEW_LINE DEDENT flag = flag ^ 1 ; NEW_LINE DEDENT if flag == False : NEW_LINE INDENT for i in range ( r , 2 , - 1 ) : NEW_LINE INDENT res . append ( i ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( l , r ) : NEW_LINE INDENT res . append ( i ) NEW_LINE DEDENT DEDENT for i in res : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT N , K = 10 , 4 NEW_LINE printPermutation ( N , K ) NEW_LINE"],"bleu":0.5511683976308593,"rouge_l":0.732}
{"id":779,"predictions":["def solve ( A , B , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if ( bin ( A [ i ] | A [ j ] ) == B [ j ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 5 , 3 , 2 , 4 , 6 , 1 ] NEW_LINE B = [ 2 , 2 , 2 , 4 , 2 , 3 , 2 ] NEW_LINE size = len ( A ) NEW_LINE print ( solve ( A , B , size ) ) NEW_LINE DEDENT"],"references":["def solve ( A , B , n ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if ( bin ( A [ i ] | A [ j ] ) . count ( '1' ) == B [ j ] ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 5 , 3 , 2 , 4 , 6 , 1 ] ; NEW_LINE B = [ 2 , 2 , 1 , 4 , 2 , 3 ] ; NEW_LINE size = len ( A ) ; NEW_LINE print ( solve ( A , B , size ) ) ; NEW_LINE DEDENT"],"bleu":0.8349197036261227,"rouge_l":0.9424059979552425}
{"id":780,"predictions":["def sum ( n ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT s = s + 1 \/ i NEW_LINE DEDENT return s NEW_LINE DEDENT n = 5 NEW_LINE print ( \" Sum ▁ is \" , sum ( n ) ) NEW_LINE"],"references":["def sum ( n ) : NEW_LINE INDENT i = 1 NEW_LINE s = 0.0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT s = s + 1 \/ i ; NEW_LINE DEDENT return s ; NEW_LINE DEDENT n = 5 NEW_LINE print ( \" Sum ▁ is \" , round ( sum ( n ) , 6 ) ) NEW_LINE"],"bleu":0.6853236495722388,"rouge_l":0.8820036147689129}
{"id":781,"predictions":["M = 3 ; NEW_LINE N = 2 ; NEW_LINE def getIndex ( n , pivot ) : NEW_LINE INDENT for i in range ( 3 ) : NEW_LINE INDENT if ( pivot [ 0 ] == n ) : NEW_LINE INDENT n = pivot [ 1 ] ; NEW_LINE DEDENT elif ( pivot [ 1 ] == n ) : NEW_LINE INDENT n = pivot [ 1 ] ; NEW_LINE DEDENT elif ( pivot [ 1 ] == n ) : NEW_LINE INDENT n = pivot [ 1 ] ; NEW_LINE DEDENT elif ( pivot [ 1 ] == n ) : NEW_LINE INDENT n = pivot [ 1 ] ; NEW_LINE DEDENT elif ( pivot [ 1 ] == n ) : NEW_LINE INDENT n = pivot [ 1 ] ; NEW_LINE DEDENT DEDENT return n ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 ; NEW_LINE pivot = [ [ 3 , 1 ] , [ 2 , 1 ] , [ 2 , 2 ] ] ; NEW_LINE getIndex ( n , pivot ) ; NEW_LINE DEDENT"],"references":["M = 3 ; N = 2 ; NEW_LINE def getIndex ( n , shuffle ) : NEW_LINE INDENT for i in range ( 3 ) : NEW_LINE INDENT if ( shuffle [ i ] [ 0 ] == n ) : NEW_LINE INDENT n = shuffle [ i ] [ 1 ] ; NEW_LINE DEDENT elif ( shuffle [ i ] [ 1 ] == n ) : NEW_LINE INDENT n = shuffle [ i ] [ 0 ] ; NEW_LINE DEDENT DEDENT print ( n ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 ; NEW_LINE shuffle = [ [ 3 , 1 ] , [ 2 , 1 ] , [ 1 , 2 ] ] ; NEW_LINE getIndex ( n , shuffle ) ; NEW_LINE DEDENT"],"bleu":0.5060095576949067,"rouge_l":0.7492640341082123}
{"id":782,"predictions":["def printArrangement ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( \" - 1\" , end = \" ▁ \" ) NEW_LINE DEDENT def findArrangement ( arr , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT print ( \" - 1\" , end = \" \" ) NEW_LINE return NEW_LINE DEDENT minVal = arr [ 0 ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( arr [ i ] == minVal ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE break NEW_LINE DEDENT DEDENT if ( arr [ n - 1 ] == arr [ n - 1 ] ) : NEW_LINE INDENT print ( \" - 1\" , end = \" \" ) NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT if ( arr [ i ] == arr [ n - 1 ] ) : NEW_LINE INDENT printArr ( arr [ i ] , end = \" ▁ \" ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 5 , 3 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE findArrangement ( arr , n ) NEW_LINE DEDENT"],"references":["def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT def findArrangement ( arr , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT print ( \" - 1\" , end = \" \" ) ; NEW_LINE return ; NEW_LINE DEDENT minVal = min ( arr ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == minVal ) : NEW_LINE INDENT arr [ i ] , arr [ n - 1 ] = arr [ n - 1 ] , arr [ i ] ; NEW_LINE break ; NEW_LINE DEDENT DEDENT andVal = arr [ 0 ] ; NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT andVal &= arr [ i ] ; NEW_LINE DEDENT if ( andVal == arr [ n - 1 ] ) : NEW_LINE INDENT printArr ( arr , n ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" - 1\" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 5 , 3 , 3 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE findArrangement ( arr , n ) ; NEW_LINE DEDENT"],"bleu":0.6994460034242751,"rouge_l":0.7724078493768232}
{"id":783,"predictions":["def findOccurrences ( str1 , substr ) : NEW_LINE INDENT counter = 0 NEW_LINE while ( len ( str1 ) < len ( str1 ) ) : NEW_LINE INDENT for i in range ( i + 1 , len ( str1 ) ) : NEW_LINE INDENT if ( str1 [ i ] == substr [ 1 ] ) : NEW_LINE INDENT for j in range ( i + 1 , len ( str1 ) ) : NEW_LINE INDENT if ( str1 [ i ] == substr [ j ] ) : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT DEDENT counter += 1 NEW_LINE DEDENT DEDENT DEDENT return counter NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = \" GGFGEEKS TABSY MI \" NEW_LINE str1 = \" GFG \" NEW_LINE print ( findOccurrences ( str1 , substr ) ) NEW_LINE DEDENT"],"references":["def findOccurrences ( str , substr ) : NEW_LINE INDENT counter = 0 NEW_LINE for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == substr [ 0 ] ) : NEW_LINE INDENT for j in range ( i + 1 , len ( str ) ) : NEW_LINE INDENT if ( str [ j ] == substr [ 1 ] ) : NEW_LINE INDENT for k in range ( j + 1 , len ( str ) ) : NEW_LINE INDENT if ( str [ k ] == substr [ 2 ] ) : NEW_LINE INDENT counter = counter + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT return counter NEW_LINE DEDENT str = \" GFGFGYSYIOIWIN \" NEW_LINE substr = \" GFG \" NEW_LINE print ( findOccurrences ( str , substr ) ) NEW_LINE"],"bleu":0.5768646878566643,"rouge_l":0.7219740955783833}
{"id":784,"predictions":["def decimalToBinary ( num , k ) : NEW_LINE INDENT binary = \" \" ; NEW_LINE decimalPrefix = num [ 0 ] ; NEW_LINE decimal = num [ 1 ] ; NEW_LINE while ( decimal > 0 ) : NEW_LINE INDENT rem = decimalToBinary ( num + decimal ) ; NEW_LINE if ( decimal > 0 ) : NEW_LINE INDENT return decimalPrefix ; NEW_LINE DEDENT binary += \" \" ; NEW_LINE decimal_bit = \" \" ; NEW_LINE DEDENT binary = \" \" ; NEW_LINE while ( binary > 0 ) : NEW_LINE INDENT remainder += int ( decimalPrefix % 2 ) ; NEW_LINE decimal_bit = int ( decimal_bit \/ 2 ) ; NEW_LINE DEDENT return binary ; NEW_LINE DEDENT def binaryToBinary ( binary , k ) : NEW_LINE INDENT binary = \" \" ; NEW_LINE decimal = \" ; NEW_LINE while ( decimal_bit > 0 ) : NEW_LINE INDENT remainder = - 1 ; NEW_LINE remainder = int ( decimal_bit ) ; NEW_LINE if ( remainder > 0 ) : NEW_LINE INDENT binary = \" \" ; NEW_LINE DEDENT else : NEW_LINE INDENT binary = binaryToBinary ( binary , 2 ) ; NEW_LINE DEDENT return binary ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 ; NEW_LINE k = 3 ; NEW_LINE print ( int ( decimalToBinary ( n , k ) ) ) ; NEW_LINE DEDENT"],"references":["def decimalToBinary ( num , k_prec ) : NEW_LINE INDENT binary = \" \" NEW_LINE Integral = int ( num ) NEW_LINE fractional = num - Integral NEW_LINE while ( Integral ) : NEW_LINE INDENT rem = Integral % 2 NEW_LINE binary += str ( rem ) ; NEW_LINE Integral \/\/= 2 NEW_LINE DEDENT binary = binary [ : : - 1 ] NEW_LINE binary += ' . ' NEW_LINE while ( k_prec ) : NEW_LINE INDENT fractional *= 2 NEW_LINE fract_bit = int ( fractional ) NEW_LINE if ( fract_bit == 1 ) : NEW_LINE INDENT fractional -= fract_bit NEW_LINE binary += '1' NEW_LINE DEDENT else : NEW_LINE INDENT binary += '0' NEW_LINE DEDENT k_prec -= 1 NEW_LINE DEDENT return binary NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4.47 NEW_LINE k = 3 NEW_LINE print ( decimalToBinary ( n , k ) ) NEW_LINE n = 6.986 NEW_LINE k = 5 NEW_LINE print ( decimalToBinary ( n , k ) ) NEW_LINE DEDENT"],"bleu":0.30524351277969325,"rouge_l":0.5404873246369677}
{"id":785,"predictions":["def evenDecimalValue ( str , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT digitValue = 0 NEW_LINE for j in range ( i , n , 1 ) : NEW_LINE INDENT digitValue += ( ord ( str [ i ] ) - ord ( '0' ) ) * powerOf2 NEW_LINE powerOf2 *= 2 NEW_LINE DEDENT if ( digitValue % 2 == 0 ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT str = \"10010\" NEW_LINE n = 5 NEW_LINE print ( evenDecimalValue ( str , n ) ) NEW_LINE"],"references":["import math NEW_LINE def evenDecimalValue ( str , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT decimalValue = 0 ; NEW_LINE powerOf2 = 1 ; NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT decimalValue += ( ( int ( str [ k ] ) - 0 ) * powerOf2 ) NEW_LINE powerOf2 *= 2 NEW_LINE DEDENT if ( decimalValue % 2 == 0 ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT str = \"10010\" NEW_LINE n = 5 NEW_LINE print ( evenDecimalValue ( str , n ) ) NEW_LINE"],"bleu":0.638939268872837,"rouge_l":0.795688589866813}
{"id":786,"predictions":["def isSubSeqDivisible ( str ) : NEW_LINE INDENT l = len ( str ) NEW_LINE arr = list ( str ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT arr [ i ] = ord ( str [ i ] ) - ord ( '0' ) NEW_LINE DEDENT for i in range ( l ) : NEW_LINE INDENT for j in range ( i , l ) : NEW_LINE INDENT if ( arr [ i ] % 8 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( arr [ i ] % 8 == 0 and i != j ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( arr [ i ] * 10 + arr [ j ] ) % 8 and i != j and i != j ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT str = \"200\" NEW_LINE if ( isSubSeqDivisible ( str ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def isSubSeqDivisible ( st ) : NEW_LINE INDENT l = len ( st ) NEW_LINE arr = [ int ( ch ) for ch in st ] NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT for j in range ( i , l ) : NEW_LINE INDENT for k in range ( j , l ) : NEW_LINE INDENT if ( arr [ i ] % 8 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 and i != j ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 and i != j and j != k and i != k ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT st = \"3144\" NEW_LINE if ( isSubSeqDivisible ( st ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.6807253390661702,"rouge_l":0.7944186046511628}
{"id":787,"predictions":["def sub_segments ( string , n ) : NEW_LINE INDENT l = len ( string ) NEW_LINE for x in string : NEW_LINE INDENT string [ x : n + x ] = string [ : x ] NEW_LINE DEDENT print ( \" \" , end = \" \" ) NEW_LINE for y in string : NEW_LINE INDENT print ( y , end = \" \\n \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" geeksforgeeks \" NEW_LINE sub_segments ( string , n ) NEW_LINE string = \" geeksforgeeks \" NEW_LINE sub_segments ( string , n ) NEW_LINE DEDENT"],"references":["def sub_segments ( string , n ) : NEW_LINE INDENT l = len ( string ) NEW_LINE for x in range ( 0 , l , n ) : NEW_LINE INDENT newlist = string [ x : x + n ] NEW_LINE arr = [ ] NEW_LINE for y in newlist : NEW_LINE INDENT if y not in arr : NEW_LINE INDENT arr . append ( y ) NEW_LINE DEDENT DEDENT print ( ' ' . join ( arr ) ) NEW_LINE DEDENT DEDENT string = \" geeksforgeeksgfg \" NEW_LINE n = 4 NEW_LINE sub_segments ( string , n ) NEW_LINE"],"bleu":0.4146358869599827,"rouge_l":0.5804086725939791}
{"id":788,"predictions":["def remAnagram ( string1 , string2 ) : NEW_LINE INDENT count1 = [ 0 ] * 26 NEW_LINE count2 = [ 0 ] * 26 NEW_LINE for i in range ( len ( string1 ) ) : NEW_LINE INDENT count1 [ ord ( string1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( len ( string2 ) ) : NEW_LINE INDENT count2 [ ord ( string2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT result += abs ( ord ( string1 [ i ] ) - count2 [ i ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string1 = \" b compile \" NEW_LINE string2 = \" hea \" NEW_LINE print ( remAnagram ( string1 , string2 ) ) NEW_LINE DEDENT"],"references":["CHARS = 26 NEW_LINE def remAnagram ( str1 , str2 ) : NEW_LINE INDENT count1 = [ 0 ] * CHARS NEW_LINE count2 = [ 0 ] * CHARS NEW_LINE i = 0 NEW_LINE while i < len ( str1 ) : NEW_LINE INDENT count1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE i += 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < len ( str2 ) : NEW_LINE INDENT count2 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE i += 1 NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT result += abs ( count1 [ i ] - count2 [ i ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" bcadeh \" NEW_LINE str2 = \" hea \" NEW_LINE print ( remAnagram ( str1 , str2 ) ) NEW_LINE DEDENT"],"bleu":0.646492383940807,"rouge_l":0.805052790346908}
{"id":789,"predictions":["def minOperations ( s , t , n ) : NEW_LINE INDENT ct0 , ct1 , ct1 = 0 , 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == t [ i ] : NEW_LINE INDENT ct1 += 1 NEW_LINE continue NEW_LINE DEDENT if s [ i ] == t [ i ] : NEW_LINE INDENT ct1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ct1 += 1 NEW_LINE DEDENT ct1 += 1 NEW_LINE DEDENT return max ( ct1 , ct1 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \"010\" NEW_LINE t = [ ] NEW_LINE n = len ( s ) NEW_LINE print ( minOperations ( s , t , n ) ) NEW_LINE DEDENT"],"references":["def minOperations ( s , t , n ) : NEW_LINE INDENT ct0 = 0 NEW_LINE ct1 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == t [ i ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT ct0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ct1 += 1 NEW_LINE DEDENT DEDENT return max ( ct0 , ct1 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \"010\" NEW_LINE t = \"101\" NEW_LINE n = len ( s ) NEW_LINE print ( minOperations ( s , t , n ) ) NEW_LINE DEDENT"],"bleu":0.7163395693382669,"rouge_l":0.8774763406940062}
{"id":790,"predictions":["def toggleLastMBits ( n , m ) : NEW_LINE INDENT num = ( ( 1 << m ) - 1 ) NEW_LINE return ( n ^ num ) NEW_LINE DEDENT n = 107 NEW_LINE m = 4 NEW_LINE print ( toggleLastMBits ( n , m ) ) NEW_LINE"],"references":["def toggleLastMBits ( n , m ) : NEW_LINE INDENT num = ( 1 << m ) - 1 NEW_LINE return ( n ^ num ) NEW_LINE DEDENT n = 107 NEW_LINE m = 4 NEW_LINE print ( toggleLastMBits ( n , m ) ) NEW_LINE"],"bleu":0.9085164924362293,"rouge_l":0.9824929971988796}
{"id":791,"predictions":["def printmaxSubseq ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( i + 1 < n and arr [ i ] < arr [ i + 1 ] ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 9 , 8 , 11 , 13 , 15 , 20 , 20 , 15 , 20 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE printmaxSubseq ( arr , n ) ; NEW_LINE DEDENT"],"references":["def printmaxSubseq ( arr , n ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT if ( arr [ i ] < arr [ i + 1 ] ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ i ] ) ; NEW_LINE DEDENT DEDENT print ( arr [ n - 1 ] ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 9 , 8 , 11 , 13 , 10 , 15 , 14 , 16 , 20 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE printmaxSubseq ( arr , n ) ; NEW_LINE DEDENT"],"bleu":0.7876429274814147,"rouge_l":0.8638982237157944}
{"id":792,"predictions":["def printFibonacci ( n ) : NEW_LINE INDENT f1 = 0 NEW_LINE f2 = 1 NEW_LINE if ( n < 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT f2 = f1 + f2 NEW_LINE print ( f1 , end = \" ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT f1 = f1 + f2 NEW_LINE f2 = f2 + f2 NEW_LINE DEDENT DEDENT printFibonacciNumbers ( 7 ) NEW_LINE"],"references":["def printFibonacciNumbers ( n ) : NEW_LINE INDENT f1 = 0 NEW_LINE f2 = 1 NEW_LINE if ( n < 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT for x in range ( 0 , n ) : NEW_LINE INDENT print ( f2 , end = \" ▁ \" ) NEW_LINE next = f1 + f2 NEW_LINE f1 = f2 NEW_LINE f2 = next NEW_LINE DEDENT DEDENT printFibonacciNumbers ( 7 ) NEW_LINE"],"bleu":0.6224973247537781,"rouge_l":0.8234411827726591}
{"id":793,"predictions":["def cal_distance ( distance , time ) : NEW_LINE INDENT print ( \" ▁ hour ▁ distance ▁ : ▁ % d \" % ( time ) , \" : ▁ % d \" ) ; NEW_LINE return int ( distance \/ minute ) ; NEW_LINE DEDENT def cal_minute ( time , time ) : NEW_LINE INDENT print ( \" { } ▁ hour ▁ minute ▁ hours ▁ : ▁ \" , float ( time ) , \" : ▁ \" , hour ) ; NEW_LINE DEDENT def cal_minute ( time , time ) : NEW_LINE INDENT print ( \" , time , \" : ▁ \" , time ) ; NEW_LINE DEDENT def cal_minute ( time , time ) : NEW_LINE INDENT print ( time , \" ▁ : ▁ \" , end = \" ) ; NEW_LINE print ( \" , ( time , time ) , \" : ▁ \" , ( time ) , \" : ▁ \" ) ; NEW_LINE return ; NEW_LINE DEDENT def cal_minute ( times , time ) : NEW_LINE INDENT print ( \" , time , \" : ▁ % d \" % time ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT input = \" ; NEW_LINE cal_minute ( MEM , time ) ; NEW_LINE DEDENT"],"references":["def cal_speed ( dist , time ) : NEW_LINE INDENT print ( \" ▁ Distance ( km ) ▁ : \" , dist ) ; NEW_LINE print ( \" ▁ Time ( hr ) ▁ : \" , time ) ; NEW_LINE return dist \/ time ; NEW_LINE DEDENT def cal_dis ( speed , time ) : NEW_LINE INDENT print ( \" ▁ Time ( hr ) ▁ : \" , time ) ; NEW_LINE print ( \" ▁ Speed ( km ▁ \/ ▁ hr ) ▁ : \" , speed ) ; NEW_LINE return speed * time ; NEW_LINE DEDENT def cal_time ( dist , speed ) : NEW_LINE INDENT print ( \" ▁ Distance ( km ) ▁ : \" , dist ) ; NEW_LINE print ( \" ▁ Speed ( km ▁ \/ ▁ hr ) ▁ : \" , speed ) ; NEW_LINE return speed * dist ; NEW_LINE DEDENT print ( \" ▁ The ▁ calculated ▁ Speed ( km ▁ \/ ▁ hr ) ▁ is ▁ : \" , cal_speed ( 45.9 , 2.0 ) ) ; NEW_LINE print ( \" \" ) ; NEW_LINE print ( \" ▁ The ▁ calculated ▁ Distance ( km ) ▁ : \" , cal_dis ( 62.9 , 2.5 ) ) ; NEW_LINE print ( \" \" ) ; NEW_LINE print ( \" ▁ The ▁ calculated ▁ Time ( hr ) ▁ : \" , cal_time ( 48.0 , 4.5 ) ) ; NEW_LINE"],"bleu":0.25568594386534227,"rouge_l":0.47131623931623934}
{"id":794,"predictions":["from math import ceil , sqrt NEW_LINE if ( n <= 0 ) : NEW_LINE INDENT print ( \" ( \" , \" , \" , \" , \" , \" , \" , \" , \" ) NEW_LINE return NEW_LINE DEDENT def computemators ( n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT print ( \" , \" , \" , end = \" \" ) NEW_LINE return NEW_LINE DEDENT a = ceil ( sqrt ( n ) ) NEW_LINE if ( a * a == n ) : NEW_LINE INDENT print ( \" , \" , a , \" , \" , \" ) NEW_LINE return elif ( a * a == b ) : NEW_LINE INDENT print ( a , \" , \" , \" , a , \" , \" , ( a + b ) , \" ) NEW_LINE DEDENT else : NEW_LINE INDENT a = a * a NEW_LINE if ( b * b == n ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT a = a * a + 1 NEW_LINE print ( a , \" , \" , a , \" , \" , sep = \" , \" ) NEW_LINE DEDENT DEDENT while ( True ) : NEW_LINE INDENT if ( b * b == n ) : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT a = a + 1 NEW_LINE DEDENT if ( b * b == n ) : NEW_LINE INDENT print ( \" , a , \" , \" , \" , sep = \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" , a , \" , \" , \" , sep = \" \" ) NEW_LINE DEDENT DEDENT DEDENT"],"references":["from math import ceil , sqrt NEW_LINE def FermatFactors ( n ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return [ n ] NEW_LINE DEDENT if ( n & 1 ) == 0 : NEW_LINE INDENT return [ n \/ 2 , 2 ] NEW_LINE DEDENT a = ceil ( sqrt ( n ) ) NEW_LINE if ( a * a == n ) : NEW_LINE INDENT return [ a , a ] NEW_LINE DEDENT while ( True ) : NEW_LINE INDENT b1 = a * a - n NEW_LINE b = int ( sqrt ( b1 ) ) NEW_LINE if ( b * b == b1 ) : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT a += 1 NEW_LINE DEDENT DEDENT return [ a - b , a + b ] NEW_LINE DEDENT print ( FermatFactors ( 6557 ) ) NEW_LINE"],"bleu":0.2856628363862375,"rouge_l":0.4874647445941711}
{"id":795,"predictions":["def perfectCube ( N ) : NEW_LINE INDENT cube = i * N NEW_LINE if cube == N : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE return NEW_LINE DEDENT elif cube == N : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE return NEW_LINE DEDENT elif cube > N : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE return NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 216 NEW_LINE perfectCube ( N ) NEW_LINE DEDENT"],"references":["def perfectCube ( N ) : NEW_LINE INDENT cube = 0 ; NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT cube = i * i * i ; NEW_LINE if ( cube == N ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE return ; NEW_LINE DEDENT elif ( cube > N ) : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE return ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 216 ; NEW_LINE perfectCube ( N ) ; NEW_LINE DEDENT"],"bleu":0.5212647190583162,"rouge_l":0.7087378640776699}
{"id":796,"predictions":["def removeDpl ( string , n ) : NEW_LINE INDENT index = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT j = 0 NEW_LINE while ( j < i ) : NEW_LINE INDENT if ( string [ j ] == string [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( j == i ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( j == i ) : NEW_LINE INDENT string [ index ] , string [ i ] = string [ i ] , string [ j ] NEW_LINE DEDENT return string NEW_LINE DEDENT string = \" geeksforgeeks \" NEW_LINE n = len ( string ) NEW_LINE print ( removeDplicates ( string , n ) ) NEW_LINE"],"references":["def removeDuplicate ( str , n ) : NEW_LINE INDENT index = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , i + 1 ) : NEW_LINE INDENT if ( str [ i ] == str [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( j == i ) : NEW_LINE INDENT str [ index ] = str [ i ] NEW_LINE index += 1 NEW_LINE DEDENT DEDENT return \" \" . join ( str [ : index ] ) NEW_LINE DEDENT str = \" geeksforgeeks \" NEW_LINE n = len ( str ) NEW_LINE print ( removeDuplicate ( list ( str ) , n ) ) NEW_LINE"],"bleu":0.5237639153965247,"rouge_l":0.6835394126738795}
{"id":797,"predictions":["def compareSeq ( S , x , y , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( S [ i ] < S [ y ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT elif ( S [ i ] > S [ y ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT x = ( ( x + 1 ) % n ) % n NEW_LINE y = ( y + 1 ) % n NEW_LINE DEDENT return True NEW_LINE DEDENT def smallestSequence ( S , n ) : NEW_LINE INDENT index = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( compareSeq ( S [ i ] , i ) % n ) : NEW_LINE INDENT index = i NEW_LINE break NEW_LINE DEDENT DEDENT return index NEW_LINE DEDENT def printSmallestSequence ( S , n ) : NEW_LINE INDENT S = str ( S [ : : - 1 ] ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT S [ i ] = str ( S [ i ] ) % n NEW_LINE DEDENT printSmallestSequence ( S , n ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S , n = 8 NEW_LINE printSmallestSequence ( S , n ) NEW_LINE DEDENT"],"references":["import copy NEW_LINE def printSmallestSequence ( s ) : NEW_LINE INDENT m = copy . copy ( s ) NEW_LINE for i in range ( len ( s ) - 1 ) : NEW_LINE INDENT if m > s [ i : ] + s [ : i ] : NEW_LINE INDENT m = s [ i : ] + s [ : i ] NEW_LINE DEDENT DEDENT return m NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT st = ' DCACBCAA ' NEW_LINE print ( printSmallestSequence ( st ) ) NEW_LINE DEDENT"],"bleu":0.13537535952505642,"rouge_l":0.3849197860962567}
{"id":798,"predictions":["def partSort ( arr , N , a , b ) : NEW_LINE INDENT l = min ( a , b ) NEW_LINE r = 0 NEW_LINE b = max ( a , b ) NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT arr [ i ] = arr [ i ] NEW_LINE DEDENT temp = [ ] NEW_LINE j = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT arr [ j ] = arr [ i ] NEW_LINE j += 1 NEW_LINE DEDENT arr [ i ] = arr [ r ] NEW_LINE DEDENT def partSort ( arr , N , a , b ) : NEW_LINE INDENT for i in range ( l , r + 1 ) : NEW_LINE INDENT arr [ i ] = arr [ i ] NEW_LINE j += 1 NEW_LINE DEDENT for i in range ( l , r + 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 7 , 8 , 5 , 2 ] NEW_LINE N = len ( arr ) NEW_LINE DEDENT"],"references":["def partSort ( arr , N , a , b ) : NEW_LINE INDENT l = min ( a , b ) NEW_LINE r = max ( a , b ) NEW_LINE temp = [ 0 for i in range ( r - l + 1 ) ] NEW_LINE j = 0 NEW_LINE for i in range ( l , r + 1 , 1 ) : NEW_LINE INDENT temp [ j ] = arr [ i ] NEW_LINE j += 1 NEW_LINE DEDENT temp . sort ( reverse = False ) NEW_LINE j = 0 NEW_LINE for i in range ( l , r + 1 , 1 ) : NEW_LINE INDENT arr [ i ] = temp [ j ] NEW_LINE j += 1 NEW_LINE DEDENT for i in range ( 0 , N , 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 7 , 8 , 4 , 5 , 2 ] NEW_LINE a = 1 NEW_LINE b = 4 NEW_LINE N = len ( arr ) NEW_LINE partSort ( arr , N , a , b ) NEW_LINE DEDENT"],"bleu":0.7138771969962974,"rouge_l":0.7629680785758133}
{"id":799,"predictions":["def checkYear ( year ) : NEW_LINE INDENT if ( year % 400 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( year % 100 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( year % 4 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return False NEW_LINE DEDENT year = 1000 NEW_LINE if ( year % 4 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT year = 1000 NEW_LINE if ( checkYear ( year ) ) : NEW_LINE INDENT print ( \" a ▁ Leap ▁ Year \" ) NEW_LINE DEDENT"],"references":["def checkYear ( year ) : NEW_LINE INDENT if ( year % 4 ) == 0 : NEW_LINE INDENT if ( year % 100 ) == 0 : NEW_LINE INDENT if ( year % 400 ) == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT year = 2000 NEW_LINE if ( checkYear ( year ) ) : NEW_LINE INDENT print ( \" Leap ▁ Year \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ a ▁ Leap ▁ Year \" ) NEW_LINE DEDENT"],"bleu":0.6323931124057239,"rouge_l":0.744875708678587}
{"id":800,"predictions":["def countPairs ( arr , n ) : NEW_LINE INDENT count , left , right = 0 , 0 , 0 NEW_LINE visited = [ False ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( right < n and not visited [ arr [ i ] ] ) : NEW_LINE INDENT while ( right < n and visited [ arr [ i ] ] == True ) : NEW_LINE INDENT count += ( right - left ) NEW_LINE DEDENT visited [ arr [ arr [ i ] ] ] = True NEW_LINE right += 1 NEW_LINE DEDENT while ( left < right and visited [ arr [ left ] ] == False ) : NEW_LINE INDENT visited [ arr [ left ] ] = True NEW_LINE left += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 4 , 2 , 4 , 3 , 2 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE DEDENT"],"references":["def countPairs ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE right = 0 NEW_LINE left = 0 NEW_LINE visited = [ False for i in range ( n ) ] NEW_LINE while ( right < n ) : NEW_LINE INDENT while ( right < n and visited [ arr [ right ] ] == False ) : NEW_LINE INDENT count += ( right - left ) NEW_LINE visited [ arr [ right ] ] = True NEW_LINE right += 1 NEW_LINE DEDENT while ( left < right and ( right != n and visited [ arr [ right ] ] == True ) ) : NEW_LINE INDENT visited [ arr [ left ] ] = False NEW_LINE left += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 4 , 2 , 4 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.7537639689266186,"rouge_l":0.8653640256959315}
{"id":801,"predictions":["def binarySearch ( arr , n , x ) : NEW_LINE INDENT l = 0 NEW_LINE r = len ( arr ) - 1 NEW_LINE while ( l <= r ) : NEW_LINE INDENT m = int ( l + ( r - l ) \/ 2 ) NEW_LINE if ( arr [ m ] < x ) : NEW_LINE INDENT return m NEW_LINE DEDENT if ( arr [ m ] < x ) : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = m - 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 10 , 40 ] NEW_LINE n = len ( arr ) NEW_LINE x = 10 NEW_LINE result = binarySearch ( arr , n , x ) NEW_LINE if ( result == - 1 ) : NEW_LINE INDENT print ( \" Element ▁ is ▁ present ▁ at ▁ % d \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Element ▁ at ▁ index ▁ % d \" ) NEW_LINE DEDENT"],"references":["def binarySearch ( arr , l , r , x ) : NEW_LINE INDENT while l <= r : NEW_LINE INDENT mid = l + ( r - l ) \/\/ 2 ; NEW_LINE if arr [ mid ] == x : NEW_LINE INDENT return mid NEW_LINE DEDENT elif arr [ mid ] < x : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = mid - 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 10 , 40 ] NEW_LINE x = 10 NEW_LINE result = binarySearch ( arr , 0 , len ( arr ) - 1 , x ) NEW_LINE if result != - 1 : NEW_LINE INDENT print ( \" Element ▁ is ▁ present ▁ at ▁ index ▁ % ▁ d \" % result ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Element ▁ is ▁ not ▁ present ▁ in ▁ array \" ) NEW_LINE DEDENT"],"bleu":0.5813825060313599,"rouge_l":0.7756895745675549}
{"id":802,"predictions":["def isComposite ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return False NEW_LINE DEDENT if isComposite ( 11 ) : NEW_LINE INDENT print ( \" True ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" False \" ) NEW_LINE DEDENT"],"references":["def isComposite ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return False NEW_LINE DEDENT print ( \" true \" ) if ( isComposite ( 11 ) ) else print ( \" false \" ) NEW_LINE print ( \" true \" ) if ( isComposite ( 15 ) ) else print ( \" false \" ) NEW_LINE"],"bleu":0.7514440054526662,"rouge_l":0.8600485380792787}
{"id":803,"predictions":["def decToBinary ( n ) : NEW_LINE INDENT binaryNum = bin ( 32 ) ; NEW_LINE i = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT binaryNum = n % 2 ; NEW_LINE n = n \/\/ 2 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT binaryNum = n % 2 ; NEW_LINE n = n \/\/ 2 ; NEW_LINE DEDENT j += 1 ; NEW_LINE DEDENT for j in range ( i - 1 , - 1 ) : NEW_LINE INDENT print ( binaryNum [ j ] , end = \" \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 17 ; NEW_LINE decToBinary ( n ) ; NEW_LINE DEDENT"],"references":["def decToBinary ( n ) : NEW_LINE INDENT binaryNum = [ 0 ] * n ; NEW_LINE i = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT binaryNum [ i ] = n % 2 ; NEW_LINE n = int ( n \/ 2 ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( binaryNum [ j ] , end = \" \" ) ; NEW_LINE DEDENT DEDENT n = 17 ; NEW_LINE decToBinary ( n ) ; NEW_LINE"],"bleu":0.6048507499173583,"rouge_l":0.7666859289222766}
{"id":804,"predictions":["def solve ( n ) : NEW_LINE INDENT return ( n * ( pow ( n , 2 ) + 3 * n + 5 ) ) \/\/ 3 NEW_LINE DEDENT n = 25 NEW_LINE print ( int ( solve ( n ) ) ) NEW_LINE"],"references":["def findSum ( n ) : NEW_LINE INDENT return ( n * ( pow ( n , 2 ) + 3 * n + 5 ) ) \/ 3 NEW_LINE DEDENT n = 25 NEW_LINE print ( int ( findSum ( n ) ) ) NEW_LINE"],"bleu":0.848043456060569,"rouge_l":0.9347826086956522}
{"id":805,"predictions":["def isPerfectSquare ( n ) : NEW_LINE INDENT i = 1 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 and ( n \/ i ) == i ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT return False NEW_LINE DEDENT n = 36 NEW_LINE if ( isPerfectSquare ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def isPerfectSquare ( n ) : NEW_LINE INDENT i = 1 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( ( n % i == 0 ) and ( n \/ i == i ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 36 NEW_LINE if ( isPerfectSquare ( n ) ) : NEW_LINE INDENT print ( \" Yes , ▁ it ▁ is ▁ a ▁ perfect ▁ square . \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No , ▁ it ▁ is ▁ not ▁ a ▁ perfect ▁ square . \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.5592134408772003,"rouge_l":0.7772901033555146}
{"id":806,"predictions":["N = 101 NEW_LINE MOD = 10 ** 9 NEW_LINE memo = [ [ [ - 1 for i in range ( N ) ] for j in range ( N + 1 ) ] for i in range ( N + 1 ) ] NEW_LINE def getSum ( x , y , z ) : NEW_LINE INDENT ans = 0 NEW_LINE final_num = [ [ 0 for i in range ( N + 1 ) ] for j in range ( M + 1 ) ] NEW_LINE for i in range ( 0 , x + 1 ) : NEW_LINE INDENT for k in range ( 0 , y + 1 ) : NEW_LINE INDENT if ( i > 0 ) : NEW_LINE INDENT final_num [ i ] [ k ] = ( final_num [ i - 1 ] [ k ] ) % MOD NEW_LINE final_num [ i ] [ k ] += ( final_num [ i - 1 ] [ k ] * final_num [ i - 1 ] [ k ] ) % MOD NEW_LINE DEDENT DEDENT if ( j > 0 ) : NEW_LINE INDENT final_num [ i ] [ j ] += ( final_num [ i - 1 ] [ k ] * final_num [ j - 1 ] [ k ] ) % MOD NEW_LINE DEDENT DEDENT if ( j > 0 ) : NEW_LINE INDENT final_num [ i ] [ j ] [ k ] ) NEW_LINE final_num [ i ] [ j ] = ( final_num [ i - 1 ] [ k ] * final_num [ i - 1 ] [ k ] ) % MOD NEW_LINE final_num [ i ] [ j ] = ( final_num [ i ] [ j - 1 ] ) % MOD NEW_LINE DEDENT DEDENT if ( j > 0 ) : NEW_LINE INDENT final_num [ i ] [ j ] += final_num [ i ] [ j ] NEW_LINE DEDENT ans = ( final_num [ i ] [ j ] [ k - 1 ] ) % MOD NEW_LINE return ans % MOD NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 1 NEW_LINE y = 1 NEW_LINE z = 1 NEW_LINE z = 1 NEW_LINE print ( getSum"],"references":["import numpy as np NEW_LINE N = 101 ; NEW_LINE mod = int ( 1e9 ) + 7 ; NEW_LINE exactsum = np . zeros ( ( N , N , N ) ) ; NEW_LINE exactnum = np . zeros ( ( N , N , N ) ) ; NEW_LINE def getSum ( x , y , z ) : NEW_LINE INDENT ans = 0 ; NEW_LINE exactnum [ 0 ] [ 0 ] [ 0 ] = 1 ; NEW_LINE for i in range ( x + 1 ) : NEW_LINE INDENT for j in range ( y + 1 ) : NEW_LINE INDENT for k in range ( z + 1 ) : NEW_LINE INDENT if ( i > 0 ) : NEW_LINE INDENT exactsum [ i ] [ j ] [ k ] += ( exactsum [ i - 1 ] [ j ] [ k ] * 10 + 4 * exactnum [ i - 1 ] [ j ] [ k ] ) % mod ; NEW_LINE exactnum [ i ] [ j ] [ k ] += exactnum [ i - 1 ] [ j ] [ k ] % mod ; NEW_LINE DEDENT if ( j > 0 ) : NEW_LINE INDENT exactsum [ i ] [ j ] [ k ] += ( exactsum [ i ] [ j - 1 ] [ k ] * 10 + 5 * exactnum [ i ] [ j - 1 ] [ k ] ) % mod ; NEW_LINE exactnum [ i ] [ j ] [ k ] += exactnum [ i ] [ j - 1 ] [ k ] % mod ; NEW_LINE DEDENT if ( k > 0 ) : NEW_LINE INDENT exactsum [ i ] [ j ] [ k ] += ( exactsum [ i ] [ j ] [ k - 1 ] * 10 + 6 * exactnum [ i ] [ j ] [ k - 1 ] ) % mod ; NEW_LINE exactnum [ i ] [ j ] [ k ] += exactnum [ i ] [ j ] [ k - 1 ] % mod ; NEW_LINE DEDENT ans += exactsum [ i ] [ j ] [ k ] % mod ; NEW_LINE ans %= mod ; NEW_LINE DEDENT DEDENT DEDENT return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = 1 ; y = 1 ; z = 1 ; NEW_LINE print ( ( getSum ( x , y , z ) % mod ) ) ; NEW_LINE DEDENT"],"bleu":0.45634598899153406,"rouge_l":0.589024964672633}
{"id":807,"predictions":["def countPairs ( s ) : NEW_LINE st = set ( ) NEW_LINE st = set ( ) NEW_LINE n = len ( st ) NEW_LINE st . add ( st [ : a ] ) NEW_LINE st . add ( st [ a ] ) NEW_LINE count = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( st [ i ] in st ) : NEW_LINE INDENT count += 1 NEW_LINE st . add ( st [ i ] ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT s = \" geeksforgeeks \" NEW_LINE print ( countPairs ( s ) ) NEW_LINE"],"references":["def countPairs ( s ) : NEW_LINE INDENT st = set ( ) ; NEW_LINE st . add ( ' a ' ) ; NEW_LINE st . add ( ' e ' ) ; NEW_LINE st . add ( ' i ' ) ; NEW_LINE st . add ( ' o ' ) ; NEW_LINE st . add ( ' u ' ) ; NEW_LINE count = 0 ; NEW_LINE n = len ( s ) ; NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( s [ i ] not in st and s [ i + 1 ] in st ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" geeksforgeeks \" ; NEW_LINE print ( countPairs ( s ) ) ; NEW_LINE DEDENT"],"bleu":0.40034761616329456,"rouge_l":0.6270407546257105}
{"id":808,"predictions":["MOD = 10 ** 9 + 7 NEW_LINE def modulo ( s , n ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( 13 ) ] for y in range ( 13 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT nxt [ i ] = ( ord ( s [ i ] ) - ord ( '0' ) ) NEW_LINE if ( s [ i ] == ' ? ' ) : NEW_LINE INDENT nxt [ i ] += dp [ i + 1 ] [ j ] NEW_LINE dp [ i ] [ j ] += dp [ i + 1 ] [ j ] NEW_LINE DEDENT if ( s [ i ] [ j ] != ' ? ' ) : NEW_LINE INDENT dp [ i + 1 ] [ j ] += dp [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT if ( s [ l ] [ r ] != ' ? ' ) : NEW_LINE INDENT return dp [ l ] [ r ] NEW_LINE DEDENT return dp [ l ] [ r ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \"4444\" NEW_LINE n = len ( s ) NEW_LINE print ( modulo ( s , n ) ) NEW_LINE DEDENT"],"references":["import numpy as np NEW_LINE MOD = ( int ) ( 1e9 + 7 ) NEW_LINE def modulo_13 ( s , n ) : NEW_LINE INDENT dp = np . zeros ( ( n + 1 , 13 ) ) ; NEW_LINE dp [ 0 ] [ 0 ] = 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT nxt = ord ( s [ i ] ) - ord ( '0' ) ; NEW_LINE if ( s [ i ] == ' ? ' ) : NEW_LINE INDENT nxt = j ; NEW_LINE DEDENT for k in range ( 13 ) : NEW_LINE INDENT rem = ( 10 * k + nxt ) % 13 ; NEW_LINE dp [ i + 1 ] [ rem ] += dp [ i ] [ k ] ; NEW_LINE dp [ i + 1 ] [ rem ] %= MOD ; NEW_LINE DEDENT if ( s [ i ] != ' ? ' ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT DEDENT return int ( dp [ n ] [ 5 ] ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" ? 44\" ; NEW_LINE n = len ( s ) ; NEW_LINE print ( modulo_13 ( s , n ) ) ; NEW_LINE DEDENT"],"bleu":0.5043586215753519,"rouge_l":0.6502251059322035}
{"id":809,"predictions":["def max_week ( a , b , n , change ) : NEW_LINE INDENT i = j = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT l = int ( a [ i ] ) NEW_LINE r = diff NEW_LINE change = a [ i ] NEW_LINE i += 1 NEW_LINE for j in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( a [ j ] < change ) : NEW_LINE INDENT change = ( a [ j ] - change ) NEW_LINE DEDENT if ( change ) : NEW_LINE INDENT sum = sum + change NEW_LINE DEDENT l = diff NEW_LINE DEDENT if ( b [ 0 ] < sum ) : NEW_LINE INDENT b [ 1 ] = diff NEW_LINE DEDENT else : NEW_LINE INDENT b [ 1 ] = diff NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 6 , 1 , 7 , 2 , 8 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE x = 2 NEW_LINE y = 2 NEW_LINE max_week ( arr , n , rate ) NEW_LINE DEDENT"],"references":["def max_profit ( a , b , n , fee ) : NEW_LINE INDENT i , j , profit = 1 , n - 1 , 0 NEW_LINE l , r , diff_day = 0 , 0 , 1 NEW_LINE b [ 0 ] = 0 NEW_LINE b [ 1 ] = diff_day NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT l = 0 NEW_LINE r = diff_day NEW_LINE Sum = 0 NEW_LINE for j in range ( n - 1 , i - 1 , - 1 ) : NEW_LINE INDENT profit = ( a [ r ] - a [ l ] ) - fee NEW_LINE if ( profit > 0 ) : NEW_LINE INDENT Sum = Sum + profit NEW_LINE DEDENT l += 1 NEW_LINE r += 1 NEW_LINE DEDENT if ( b [ 0 ] < Sum ) : NEW_LINE INDENT b [ 0 ] = Sum NEW_LINE b [ 1 ] = diff_day NEW_LINE DEDENT DEDENT diff_day += 1 NEW_LINE return 0 NEW_LINE DEDENT arr = [ 6 , 1 , 7 , 2 , 8 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE b = [ 0 for i in range ( 2 ) ] NEW_LINE tranFee = 2 NEW_LINE max_profit ( arr , b , n , tranFee ) NEW_LINE print ( b [ 0 ] , \" , \" , b [ 1 ] ) NEW_LINE"],"bleu":0.3923518354399427,"rouge_l":0.5940701197518395}
{"id":810,"predictions":["MAX = 25 NEW_LINE def getMinSum ( arr , n ) : NEW_LINE INDENT bits_count = 0 NEW_LINE max_bit_count = 0 NEW_LINE for d in range ( 0 , n ) : NEW_LINE INDENT e = arr [ e % 2 ] NEW_LINE f = 0 NEW_LINE while ( e > 0 ) : NEW_LINE INDENT e = e % 2 NEW_LINE f = e \/\/ 2 NEW_LINE if ( rem == 1 ) : NEW_LINE INDENT if ( bits_count == 1 ) : NEW_LINE INDENT bits_count += rem NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT bits_count += 1 NEW_LINE DEDENT DEDENT max_bit_count = max ( max_bit , f ) NEW_LINE DEDENT DEDENT def getMinSum ( arr , n ) : NEW_LINE INDENT for d in range ( 0 , n ) : NEW_LINE INDENT arr [ d % 2 ] += 1 NEW_LINE DEDENT if ( bits_count > n \/ 2 ) : NEW_LINE INDENT ans = ans + arr [ d ] NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 5 , 7 , 11 ] NEW_LINE n = len ( arr ) NEW_LINE print ( getMinSum ( arr , n ) ) NEW_LINE DEDENT"],"references":["MAX = 25 ; NEW_LINE def getMinSum ( arr , n ) : NEW_LINE INDENT bits_count = [ 0 ] * MAX NEW_LINE max_bit = 0 ; sum = 0 ; ans = 0 ; NEW_LINE for d in range ( n ) : NEW_LINE INDENT e = arr [ d ] ; f = 0 ; NEW_LINE while ( e > 0 ) : NEW_LINE INDENT rem = e % 2 ; NEW_LINE e = e \/\/ 2 ; NEW_LINE if ( rem == 1 ) : NEW_LINE INDENT bits_count [ f ] += rem ; NEW_LINE DEDENT f += 1 NEW_LINE DEDENT max_bit = max ( max_bit , f ) ; NEW_LINE DEDENT for d in range ( max_bit ) : NEW_LINE INDENT temp = pow ( 2 , d ) ; NEW_LINE if ( bits_count [ d ] > n \/\/ 2 ) : NEW_LINE INDENT ans = ans + temp ; NEW_LINE DEDENT DEDENT for d in range ( n ) : NEW_LINE INDENT arr [ d ] = arr [ d ] ^ ans ; NEW_LINE sum = sum + arr [ d ] ; NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 5 , 7 , 11 , 15 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( getMinSum ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.5352978969806369,"rouge_l":0.7065302352021602}
{"id":811,"predictions":["def findNums ( arr , n ) : NEW_LINE INDENT S = 0 NEW_LINE X = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT S += arr [ i ] NEW_LINE X ^= arr [ i ] NEW_LINE DEDENT print ( X , end = \" ▁ \" ) NEW_LINE DEDENT arr = [ 1 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE findNums ( arr , n ) NEW_LINE"],"references":["def findNums ( arr , n ) : NEW_LINE INDENT S = 0 ; X = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT S += arr [ i ] ; NEW_LINE X ^= arr [ i ] ; NEW_LINE DEDENT print ( X , X + S ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 7 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE findNums ( arr , n ) ; NEW_LINE DEDENT"],"bleu":0.5810094020143508,"rouge_l":0.8048689834603234}
{"id":812,"predictions":["def bin ( n ) : NEW_LINE INDENT if n > 1 : NEW_LINE INDENT bin ( n >> 1 ) ; NEW_LINE DEDENT print ( \" \\n \" , end = \" \" ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT bin ( 13 ) ; NEW_LINE print ( bin ( 3 ) ) ; NEW_LINE DEDENT"],"references":["def bin ( n ) : NEW_LINE INDENT if ( n > 1 ) : NEW_LINE INDENT bin ( n >> 1 ) NEW_LINE DEDENT print ( n & 1 , end = \" \" ) NEW_LINE DEDENT bin ( 131 ) NEW_LINE print ( ) NEW_LINE bin ( 3 ) NEW_LINE"],"bleu":0.43796264534213064,"rouge_l":0.7566957992669863}
{"id":813,"predictions":["def Square ( row , column , moves ) : NEW_LINE INDENT a = 0 NEW_LINE b = 0 NEW_LINE c = change ( row - moves ) NEW_LINE if ( a < 1 ) : NEW_LINE INDENT b = 1 NEW_LINE DEDENT if ( b < 8 ) : NEW_LINE INDENT c = 1 NEW_LINE DEDENT if ( c < 8 ) : NEW_LINE INDENT if ( b > 8 ) : NEW_LINE INDENT b = 8 NEW_LINE DEDENT if ( b < 8 ) : NEW_LINE INDENT b = 8 NEW_LINE DEDENT total = ( b - a ) * ( d + 1 ) NEW_LINE DEDENT return total NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT R = 4 NEW_LINE C = 5 NEW_LINE DEDENT print ( Square ( R , C , M ) ) NEW_LINE DEDENT"],"references":["def Square ( row , column , moves ) : NEW_LINE INDENT a = 0 ; b = 0 ; c = 0 ; NEW_LINE d = 0 ; total = 0 ; NEW_LINE a = row - moves ; NEW_LINE b = row + moves ; NEW_LINE c = column - moves ; NEW_LINE d = column + moves ; NEW_LINE if ( a < 1 ) : NEW_LINE INDENT a = 1 ; NEW_LINE DEDENT if ( c < 1 ) : NEW_LINE INDENT c = 1 ; NEW_LINE DEDENT if ( b > 8 ) : NEW_LINE INDENT b = 8 ; NEW_LINE DEDENT if ( d > 8 ) : NEW_LINE INDENT d = 8 ; NEW_LINE DEDENT total = ( b - a + 1 ) * ( d - c + 1 ) - 1 ; NEW_LINE return total ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT R = 4 ; C = 5 ; M = 2 ; NEW_LINE print ( Square ( R , C , M ) ) ; NEW_LINE DEDENT"],"bleu":0.46968524740483336,"rouge_l":0.7167558272831486}
{"id":814,"predictions":["import math NEW_LINE def firstkdigits ( n , k ) : NEW_LINE INDENT product = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT product *= n NEW_LINE while ( product \/\/ math . pow ( 10 , k ) ) : NEW_LINE INDENT product = product \/\/ 10 NEW_LINE DEDENT DEDENT return product NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 15 NEW_LINE k = 4 NEW_LINE print ( firstkdigits ( n , k ) ) NEW_LINE DEDENT"],"references":["def firstkdigits ( n , k ) : NEW_LINE INDENT product = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT product *= n NEW_LINE DEDENT while ( ( product \/\/ pow ( 10 , k ) ) != 0 ) : NEW_LINE INDENT product = product \/\/ 10 NEW_LINE DEDENT return product NEW_LINE DEDENT n = 15 NEW_LINE k = 4 NEW_LINE print ( firstkdigits ( n , k ) ) NEW_LINE"],"bleu":0.6777023497998155,"rouge_l":0.8557597312784034}
{"id":815,"predictions":["def solve ( X , Y , N , K ) : NEW_LINE INDENT count = [ 0 ] * ( N + 1 ) ; NEW_LINE res = 0 ; NEW_LINE count [ 0 ] = 0 ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT count [ i ] = count [ i - 1 ] + abs ( X [ i - 1 ] - Y [ i ] ) ; NEW_LINE DEDENT j = 0 ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT while ( ( count [ count [ i ] - count [ j ] > K ) ) : NEW_LINE INDENT j += 1 ; NEW_LINE DEDENT DEDENT res = max ( res , i - j ) ; NEW_LINE return res ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 4 ; NEW_LINE X = 3 ; NEW_LINE Y = 3 ; NEW_LINE K = 3 ; NEW_LINE print ( solve ( X , Y , N , K ) ) ; NEW_LINE DEDENT"],"references":["def solve ( X , Y , N , K ) : NEW_LINE INDENT count = [ 0 ] * ( N + 1 ) ; NEW_LINE sol = 0 ; NEW_LINE count [ 0 ] = 0 ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT count [ i ] = ( count [ i - 1 ] + abs ( ord ( X [ i - 1 ] ) - ord ( Y [ i - 1 ] ) ) ) ; NEW_LINE DEDENT j = 0 ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT while ( ( count [ i ] - count [ j ] ) > K ) : NEW_LINE INDENT j += 1 ; NEW_LINE DEDENT sol = max ( sol , i - j ) ; NEW_LINE DEDENT return sol ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 ; NEW_LINE X = \" abcd \" ; NEW_LINE Y = \" bcde \" ; NEW_LINE K = 3 ; NEW_LINE print ( solve ( X , Y , N , K ) ) ; NEW_LINE DEDENT"],"bleu":0.7789064724091521,"rouge_l":0.9060381013884405}
{"id":816,"predictions":["MAX = 1000 ; NEW_LINE f = [ 0 ] * MAX ; NEW_LINE def fib ( n ) : NEW_LINE INDENT if ( n == 0 or n == 2 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( f [ n ] ) : NEW_LINE INDENT return f [ n ] ; NEW_LINE DEDENT if ( f [ n ] ) : NEW_LINE INDENT return f [ n ] ; NEW_LINE DEDENT k = ( n + 1 ) \/\/ 2 ; NEW_LINE if ( ( n & 1 ) != 0 ) : NEW_LINE INDENT f [ n ] = ( fib ( k ) * fib ( k - 1 ) + fib ( k - 1 ) * fib ( k - 1 ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT f [ n ] = ( fib ( k ) * fib ( k ) + fib ( k ) * fib ( k ) ) ; NEW_LINE return f [ n ] ; NEW_LINE DEDENT def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b ; NEW_LINE DEDENT return gcd ( a % a , b ) ; NEW_LINE DEDENT elif ( a % b == 0 ) : NEW_LINE INDENT return b ; NEW_LINE DEDENT return fib ( a , b ) ; NEW_LINE DEDENT def findLCMib ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b ; NEW_LINE DEDENT return ( fib ( a , b ) ) ; NEW_LINE DEDENT a = 3 ; NEW_LINE b = 12 ; NEW_LINE print ( findLCMute ( a , b ) ) ; NEW_LINE"],"references":["MAX = 1000 NEW_LINE f = [ 0 ] * MAX NEW_LINE def fib ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 1 or n == 2 ) : NEW_LINE INDENT f [ n ] = 1 NEW_LINE return f [ n ] NEW_LINE DEDENT if ( f [ n ] ) : NEW_LINE INDENT return f [ n ] NEW_LINE DEDENT k = ( n + 1 ) \/\/ 2 if ( n & 1 ) else n \/\/ 2 NEW_LINE if ( n & 1 ) : NEW_LINE INDENT f [ n ] = ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT f [ n ] = ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ) NEW_LINE DEDENT return f [ n ] NEW_LINE DEDENT def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def findLCMFibonacci ( a , b ) : NEW_LINE INDENT return ( fib ( a ) * fib ( b ) ) \/\/ fib ( gcd ( a , b ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 3 NEW_LINE b = 12 NEW_LINE print ( findLCMFibonacci ( a , b ) ) NEW_LINE DEDENT"],"bleu":0.6637913863896899,"rouge_l":0.7834085387018397}
{"id":817,"predictions":["def find_digit ( s , n ) : NEW_LINE INDENT first_digit = - 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] < '0' or s [ i ] > '0' ) : NEW_LINE INDENT first_digit = i NEW_LINE break NEW_LINE DEDENT DEDENT first_digit = first_digit ( s ) NEW_LINE s = list ( ) NEW_LINE p = first_digit ( s ) NEW_LINE i = 0 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( s [ i ] >= '0' and s [ i ] <= '9' and s [ i ] <= '9' ) : NEW_LINE INDENT first_digit = ord ( s [ i ] ) - ord ( '0' ) NEW_LINE num = num + ( p * 10 ) NEW_LINE if ( num >= s [ i ] ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT p = p * 10 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT s = \" abcd \" NEW_LINE n = len ( s ) NEW_LINE print ( find_digit ( s , n ) ) NEW_LINE"],"references":["def find_digit ( s , n ) : NEW_LINE INDENT first_digit = - 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if s [ i ] < '0' or s [ i ] > '9' : NEW_LINE INDENT first_digit = i NEW_LINE break NEW_LINE DEDENT DEDENT first_digit += 1 NEW_LINE s_len = first_digit NEW_LINE num = 0 NEW_LINE pw = 1 NEW_LINE i = n - 1 NEW_LINE while i >= 0 : NEW_LINE INDENT if s [ i ] >= '0' and s [ i ] <= '9' : NEW_LINE INDENT digit = ord ( s [ i ] ) - ord ( '0' ) NEW_LINE num = num + ( pw * digit ) NEW_LINE if num >= s_len : NEW_LINE INDENT return - 1 NEW_LINE DEDENT pw = pw * 10 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT num = num * 10 NEW_LINE req = s_len - num NEW_LINE if req > 9 or req < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return req NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" abcd0\" NEW_LINE n = len ( s ) NEW_LINE print ( find_digit ( s , n ) ) NEW_LINE DEDENT"],"bleu":0.5597890955791174,"rouge_l":0.7354542626011201}
{"id":818,"predictions":["def findNthNumber ( A , B , N ) : NEW_LINE INDENT summ = 0 NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT summ = A + B NEW_LINE A = B NEW_LINE B = B NEW_LINE DEDENT return summ NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = 5 NEW_LINE B = 7 NEW_LINE N = 10 NEW_LINE print ( findNthNumber ( A , B , N ) ) NEW_LINE DEDENT"],"references":["def findNthNumber ( A , B , N ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT sum = A + B NEW_LINE A = B NEW_LINE B = sum NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = 5 NEW_LINE B = 7 NEW_LINE N = 10 NEW_LINE print ( findNthNumber ( A , B , N ) ) NEW_LINE DEDENT"],"bleu":0.8792437306738525,"rouge_l":0.9529411764705882}
{"id":819,"predictions":["def calculateSum ( n ) : NEW_LINE INDENT return ( pow ( 10 , n + 1 ) * ( 9 * n - 1 ) ) \/ ( 9 * n * ( n + 1 ) ) ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 ; NEW_LINE print ( \" Sum ▁ = \" , int ( calculateSum ( n ) ) ) ; NEW_LINE DEDENT"],"references":["def solve_sum ( n ) : NEW_LINE INDENT return ( pow ( 10 , n + 1 ) * ( 9 * n - 1 ) + 10 ) \/ pow ( 9 , 3 ) - n * ( n + 1 ) \/ 18 NEW_LINE DEDENT n = 3 NEW_LINE print ( int ( solve_sum ( n ) ) ) NEW_LINE"],"bleu":0.48083581969605843,"rouge_l":0.7432052483598875}
{"id":820,"predictions":["def summation ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) * ( 2 * n + 1 ) ) \/\/ 6 NEW_LINE DEDENT n = 10 NEW_LINE print ( summation ( n ) ) NEW_LINE"],"references":["def summation ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) * ( 2 * n + 1 ) ) \/ 6 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE print ( summation ( n ) ) NEW_LINE DEDENT"],"bleu":0.6451004705978576,"rouge_l":0.8157208088714937}
{"id":821,"predictions":["import math NEW_LINE def mean ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum = sum + arr [ i ] NEW_LINE DEDENT return sum \/ n NEW_LINE DEDENT def mean ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum = sum + arr [ i ] * ( arr [ i ] - mean ( arr [ i ] ) ) NEW_LINE DEDENT return mean ( arr , n ) NEW_LINE DEDENT def sampleError ( arr , n ) : NEW_LINE INDENT sm = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sm = sum + ( arr [ i ] - mean ( arr [ i ] ) * ( arr [ i ] - mean ( arr [ i ] ) ) ) \/ ( float ( arr [ i ] ) ) NEW_LINE DEDENT return sm \/ sm NEW_LINE DEDENT def mean ( arr , n ) : NEW_LINE INDENT return ( mean ( arr , n ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 45 , 75 , 90.25 , 83.15 ] NEW_LINE n = len ( arr ) NEW_LINE print ( sample ( arr , n ) ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def mean ( arr , n ) : NEW_LINE INDENT sm = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sm = sm + arr [ i ] NEW_LINE DEDENT return sm \/ n NEW_LINE DEDENT def SSD ( arr , n ) : NEW_LINE INDENT sm = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sm = sm + ( arr [ i ] - mean ( arr , n ) ) * ( arr [ i ] - mean ( arr , n ) ) NEW_LINE DEDENT return ( math . sqrt ( sm \/ ( n - 1 ) ) ) NEW_LINE DEDENT def sampleError ( arr , n ) : NEW_LINE INDENT return SSD ( arr , n ) \/ ( math . sqrt ( n ) ) NEW_LINE DEDENT arr = [ 78.53 , 79.62 , 80.25 , 81.05 , 83.21 , 83.46 ] NEW_LINE n = len ( arr ) NEW_LINE print ( sampleError ( arr , n ) ) NEW_LINE"],"bleu":0.5325361306193406,"rouge_l":0.6771374586679264}
{"id":822,"predictions":["import fractions NEW_LINE def sqrtValue ( n ) : NEW_LINE INDENT i , u , v = 0 , 0 NEW_LINE curr_digits = 0 NEW_LINE while ( n ) : NEW_LINE INDENT i = n % 10 NEW_LINE n = n \/\/ 10 NEW_LINE curr_digit = 0 NEW_LINE DEDENT curr_digit = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT a = n % 10 NEW_LINE n = n \/\/ 100 NEW_LINE a += 1 NEW_LINE DEDENT i -= 1 NEW_LINE curr_digit = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT a = n % 10 NEW_LINE n = n \/\/ 10 NEW_LINE i += 1 NEW_LINE DEDENT for i in range ( i , - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( curr_digit >= ( curr_digit ) : NEW_LINE INDENT curr_digit += 1 NEW_LINE DEDENT if ( curr_digit < 0 ) : NEW_LINE INDENT curr_digit = 0 NEW_LINE DEDENT DEDENT DEDENT return curr_digit NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = 1225 NEW_LINE print ( sqrt ( x ) ) NEW_LINE DEDENT"],"references":["INFINITY_ = 9999999 NEW_LINE def sqrtByLongDivision ( n ) : NEW_LINE INDENT i = 0 NEW_LINE udigit , j = 0 , 0 NEW_LINE cur_divisor = 0 NEW_LINE quotient_units_digit = 0 NEW_LINE cur_quotient = 0 NEW_LINE cur_dividend = 0 NEW_LINE cur_remainder = 0 NEW_LINE a = [ 0 ] * 10 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT a [ i ] = n % 100 NEW_LINE n = n \/\/ 100 NEW_LINE i += 1 NEW_LINE DEDENT i -= 1 NEW_LINE for j in range ( i , - 1 , - 1 ) : NEW_LINE INDENT cur_remainder = INFINITY_ NEW_LINE cur_dividend = cur_dividend * 100 + a [ j ] NEW_LINE for udigit in range ( 10 ) : NEW_LINE INDENT if ( cur_remainder >= cur_dividend - ( ( cur_divisor * 10 + udigit ) * udigit ) and cur_dividend - ( ( cur_divisor * 10 + udigit ) * udigit ) >= 0 ) : NEW_LINE INDENT cur_remainder = cur_dividend - ( ( cur_divisor * 10 + udigit ) * udigit ) NEW_LINE quotient_units_digit = udigit NEW_LINE DEDENT DEDENT cur_quotient = cur_quotient * 10 + quotient_units_digit NEW_LINE cur_divisor = cur_quotient * 2 NEW_LINE cur_dividend = cur_remainder NEW_LINE DEDENT return cur_quotient NEW_LINE DEDENT x = 1225 NEW_LINE print ( sqrtByLongDivision ( x ) ) NEW_LINE"],"bleu":0.35210275957443604,"rouge_l":0.4977638289525304}
{"id":823,"predictions":["def CountAllPairs ( N , K ) : NEW_LINE INDENT count = 0 ; NEW_LINE if ( N > K ) : NEW_LINE INDENT count = N - K ; NEW_LINE DEDENT if ( N > K ) : NEW_LINE INDENT count = N - K ; NEW_LINE DEDENT for i in range ( K + 1 , N + 1 ) : NEW_LINE INDENT count = count + ( N - K ) \/\/ i ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 11 ; NEW_LINE K = 5 ; NEW_LINE print ( CountAllPairs ( N , K ) ) ; NEW_LINE DEDENT"],"references":["import math NEW_LINE def CountAllPairs ( N , K ) : NEW_LINE INDENT count = 0 NEW_LINE if ( N > K ) : NEW_LINE INDENT count = N - K NEW_LINE for i in range ( K + 1 , N + 1 ) : NEW_LINE INDENT count = count + ( ( N - K ) \/\/ i ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT N = 11 NEW_LINE K = 5 NEW_LINE print ( CountAllPairs ( N , K ) ) NEW_LINE"],"bleu":0.5608822878950093,"rouge_l":0.8038214462197332}
{"id":824,"predictions":["def checkNumber ( N ) : NEW_LINE INDENT temp = N NEW_LINE while ( temp ) : NEW_LINE INDENT if ( temp % 1000 == 0 ) : NEW_LINE INDENT temp \/\/= 1000 NEW_LINE DEDENT elif ( temp % 100 == 1 ) : NEW_LINE INDENT temp \/\/= 10 NEW_LINE DEDENT elif ( temp % 10 == 14 ) : NEW_LINE INDENT temp \/\/= 10 NEW_LINE DEDENT elif ( temp % 10 == 1 ) : NEW_LINE INDENT temp \/\/= 10 NEW_LINE DEDENT else : NEW_LINE INDENT return \" YES \" NEW_LINE DEDENT DEDENT return \" NO \" NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 141414 NEW_LINE if ( checkNumber ( N ) ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"references":["def checkNumber ( N ) : NEW_LINE INDENT temp = N NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT if ( temp % 1000 == 144 ) : NEW_LINE INDENT temp \/= 1000 NEW_LINE DEDENT elif ( temp % 100 == 14 ) : NEW_LINE INDENT temp \/= 100 NEW_LINE DEDENT elif ( temp % 10 == 1 ) : NEW_LINE INDENT temp \/= 10 NEW_LINE DEDENT else : NEW_LINE INDENT return \" YES \" NEW_LINE DEDENT DEDENT return \" NO \" NEW_LINE DEDENT N = 1414 ; NEW_LINE print ( checkNumber ( N ) ) ; NEW_LINE"],"bleu":0.5170879212570249,"rouge_l":0.7411604095563141}
{"id":825,"predictions":["def printNumbers ( N ) : NEW_LINE INDENT flag = 1 ; NEW_LINE x = N ; NEW_LINE if ( N > 0 and flag == 1 ) : NEW_LINE INDENT while ( x > 0 and flag == 1 ) : NEW_LINE INDENT digit = x % 10 ; NEW_LINE if ( digit ) : NEW_LINE INDENT flag = 0 ; NEW_LINE DEDENT x = x \/\/ 10 ; NEW_LINE DEDENT DEDENT if ( flag == 1 ) : NEW_LINE INDENT print ( N , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 20 ; NEW_LINE printNumbers ( N ) ; NEW_LINE DEDENT"],"references":["def printNumbers ( N ) : NEW_LINE INDENT flag = 1 NEW_LINE x = N NEW_LINE if ( N > 0 ) : NEW_LINE INDENT while ( x > 0 and flag == 1 ) : NEW_LINE INDENT digit = x % 10 NEW_LINE if ( digit != 1 and digit != 3 ) : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT x = x \/\/ 10 NEW_LINE DEDENT if ( flag == 1 ) : NEW_LINE INDENT print ( N , end = \" ▁ \" ) NEW_LINE DEDENT printNumbers ( N - 1 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 20 NEW_LINE printNumbers ( N ) NEW_LINE DEDENT"],"bleu":0.7146958080831909,"rouge_l":0.8717810435486044}
{"id":826,"predictions":["def getPosition ( a , n , m ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT a [ i ] = ( a [ i ] \/\/ m + ( a [ m ] % m ) ) NEW_LINE DEDENT ans = - 1 NEW_LINE max = - 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( max < a [ i ] ) : NEW_LINE INDENT max = a [ i ] NEW_LINE ans = i NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 2 , 5 , 4 ] NEW_LINE n = len ( a ) NEW_LINE m = 2 NEW_LINE print ( getPosition ( a , n , m ) ) NEW_LINE DEDENT"],"references":["import math as mt NEW_LINE def getPosition ( a , n , m ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT a [ i ] = ( a [ i ] \/\/ m + ( a [ i ] % m != 0 ) ) NEW_LINE DEDENT ans , maxx = - 1 , - 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( maxx < a [ i ] ) : NEW_LINE INDENT maxx = a [ i ] NEW_LINE ans = i NEW_LINE DEDENT DEDENT return ans + 1 NEW_LINE DEDENT a = [ 2 , 5 , 4 ] NEW_LINE n = len ( a ) NEW_LINE m = 2 NEW_LINE print ( getPosition ( a , n , m ) ) NEW_LINE"],"bleu":0.7880570321266444,"rouge_l":0.8840579710144928}
{"id":827,"predictions":["def printArr ( arr , n , k ) : NEW_LINE INDENT for i in range ( 0 , n , 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT def sortArr ( arr , n , k ) : NEW_LINE INDENT prev = - 1 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( arr [ i ] % k == 0 ) : NEW_LINE INDENT if ( prev ) : NEW_LINE INDENT arr [ prev ] = arr [ i ] NEW_LINE prev = arr [ i ] NEW_LINE DEDENT prev = i NEW_LINE DEDENT DEDENT DEDENT def sortArr ( arr , n , k ) : NEW_LINE INDENT prev = - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] % k == 0 ) : NEW_LINE INDENT arr [ prev ] = arr [ i ] NEW_LINE DEDENT prev = i NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 1 , 13 , 3 , 7 , 8 , 13 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE sortArr ( arr , n , k ) NEW_LINE DEDENT"],"references":["def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT def sortArr ( arr , n , k ) : NEW_LINE INDENT prev = - 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % k == 0 ) : NEW_LINE INDENT if ( prev != - 1 ) : NEW_LINE INDENT temp = arr [ prev + 1 : i ] ; NEW_LINE temp . sort ( ) ; NEW_LINE arr = arr [ : prev + 1 ] + temp + arr [ i : ] ; NEW_LINE DEDENT prev = i ; NEW_LINE DEDENT DEDENT printArr ( arr , n ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 1 , 13 , 3 , 7 , 8 , 21 , 13 , 12 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE k = 2 ; NEW_LINE sortArr ( arr , n , k ) ; NEW_LINE DEDENT"],"bleu":0.5634025974553626,"rouge_l":0.7532586325177224}
{"id":828,"predictions":["class QueueNode : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def countOfBinaryNums ( N ) : NEW_LINE INDENT q = Queue ( ) NEW_LINE q . put ( ( 1 , 0 ) ) NEW_LINE while ( len ( q ) > 0 ) : NEW_LINE INDENT t = q . queue [ 0 ] NEW_LINE q . get ( ) NEW_LINE if ( t <= N ) : NEW_LINE INDENT cnt = 0 NEW_LINE q . get ( ) NEW_LINE DEDENT else : NEW_LINE INDENT q . put ( t * 10 + 1 ) NEW_LINE q . put ( t * 10 ) NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT N = 200 NEW_LINE print ( countOfBinaryNums ( N ) ) NEW_LINE"],"references":["from collections import deque NEW_LINE def countOfBinaryNumberLessThanN ( N ) : NEW_LINE INDENT q = deque ( ) NEW_LINE q . append ( 1 ) NEW_LINE cnt = 0 NEW_LINE while ( q ) : NEW_LINE INDENT t = q . popleft ( ) NEW_LINE if ( t <= N ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE q . append ( t * 10 ) NEW_LINE q . append ( t * 10 + 1 ) NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 200 NEW_LINE print ( countOfBinaryNumberLessThanN ( N ) ) NEW_LINE DEDENT"],"bleu":0.4583180974752996,"rouge_l":0.6296149265581581}
{"id":829,"predictions":["mod = 1000000007 NEW_LINE def power ( p , a ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 1 , p + 1 ) : NEW_LINE INDENT res *= 2 NEW_LINE res %= mod NEW_LINE DEDENT return res % mod NEW_LINE DEDENT def subset_square ( A ) : NEW_LINE INDENT n = len ( A ) NEW_LINE ans = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( A ) : NEW_LINE INDENT ans += ( 1 * i * i ) % mod NEW_LINE ans %= mod NEW_LINE DEDENT return ( ans * ans ) % mod NEW_LINE DEDENT A = [ 3 , 7 ] NEW_LINE print ( subset_square_sum ( A ) ) NEW_LINE"],"references":["mod = 10 ** 9 + 7 NEW_LINE def power ( p ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 1 , p + 1 ) : NEW_LINE INDENT res *= 2 NEW_LINE res %= mod NEW_LINE DEDENT return res % mod NEW_LINE DEDENT def subset_square_sum ( A ) : NEW_LINE INDENT n = len ( A ) NEW_LINE ans = 0 NEW_LINE for i in A : NEW_LINE INDENT ans += i * i % mod NEW_LINE ans %= mod NEW_LINE DEDENT return ans * power ( n - 1 ) % mod NEW_LINE DEDENT A = [ 3 , 7 ] NEW_LINE print ( subset_square_sum ( A ) ) NEW_LINE"],"bleu":0.7606300542818945,"rouge_l":0.8873336077947028}
{"id":830,"predictions":["def performQueries ( A , B , q ) : NEW_LINE INDENT n = len ( A [ 0 ] ) NEW_LINE pref = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT pref [ A [ i ] ] = pref [ A [ i ] ] ^ A [ i - 1 ] NEW_LINE DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT pref [ A [ i ] ] = pref [ A [ i ] ] ^ A [ i - 1 ] NEW_LINE DEDENT if ( L != R and pref [ R [ L - 1 ] ] == pref [ L ] ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ [ 1 , 5 , 2 ] , [ 1 , 4 ] ] NEW_LINE q = [ 3 , 4 , 1 ] NEW_LINE performQueries ( A , B , q ) NEW_LINE DEDENT"],"references":["def performQueries ( A , q ) : NEW_LINE INDENT n = len ( A ) NEW_LINE pref_xor = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT pref_xor [ i ] = pref_xor [ i - 1 ] ^ A [ i - 1 ] NEW_LINE DEDENT for i in q : NEW_LINE INDENT L = i [ 0 ] NEW_LINE R = i [ 1 ] NEW_LINE if ( L > R ) : NEW_LINE INDENT L , R = R , L NEW_LINE DEDENT if ( L != R and pref_xor [ R ] == pref_xor [ L - 1 ] ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT DEDENT Arr = [ 1 , 1 , 2 , 2 , 1 ] NEW_LINE q = [ [ 1 , 5 ] , [ 1 , 4 ] , [ 3 , 4 ] ] NEW_LINE performQueries ( Arr , q ) ; NEW_LINE"],"bleu":0.5734125468109382,"rouge_l":0.682722599900514}
{"id":831,"predictions":["word = [ \" zero \" , \" one \" , \" two \" , \" three \" , \" four \" , \" five \" , \" six \" , \" seven \" , \" eight \" , \" nine \" , \" ten \" , \" eleven \" , \" eleven \" , \" twelve \" , \" thirteen \" , \" fourteen \" , \" seventeen \" , \" eighteen \" , \" twenty \" , \" seventeen \" , \" eighteen \" , \" nineteen \" , \" twenty \" , \" nineteen \" , \" twenty \" , \" twenty \" , \" thirty \" , \" forty \" , \" fifty \" , \" sixty \" , \" seventy \" , \" twenty \" , \" twenty \" , \" thirty \" , \" forty \" , \" fifty \" , \" sixty \" , \" sixty \" , \" seventy \" , \" twenty \" , \" sixty \" , \" seventy \" , \" sixty \" , \" seventy \" , \" eighty \" , \" ninety \" ] NEW_LINE def numToWords ( n , s ) : NEW_LINE INDENT if ( n > 19 ) : NEW_LINE INDENT print ( num \/\/ 10 , \" sixty \" , \" seventy \" , \" twenty \" , \" six \" , \" seven \" ) NEW_LINE DEDENT elif ( n % 10 == 0 and n > 0 ) : NEW_LINE INDENT num \/\/= 10 NEW_LINE DEDENT elif ( n % 10 == 0 ) : NEW_LINE INDENT num \/\/= 10 NEW_LINE DEDENT elif ( n % 10 == 0 ) : NEW_LINE INDENT num \/\/= 10 NEW_LINE DEDENT if ( n > 0 and n % 100 == 0 ) : NEW_LINE INDENT num \/\/= 10 NEW_LINE DEDENT elif ( n % 10 == 0 ) : NEW_LINE INDENT str ( num \/\/ 10 ) NEW_LINE DEDENT if ( n > 0 and n % 100 > 0 ) : NEW_LINE INDENT str ( num \/\/ 10 ) NEW_LINE DEDENT else : NEW_LINE INDENT str ( num \/\/ 10 ) NEW_LINE DEDENT if ( n > 0 and n % 100 > 0 ) : NEW_LINE INDENT str ( num % 10 ) NEW_LINE DEDENT if ( n > 0 and n % 10 != 0 ) : NEW_LINE INDENT str ( num \/\/ 10 ) NEW_LINE DEDENT str ( n \/\/ 100 ) NEW_"],"references":["one = [ \" \" , \" one ▁ \" , \" two ▁ \" , \" three ▁ \" , \" four ▁ \" , \" five ▁ \" , \" six ▁ \" , \" seven ▁ \" , \" eight ▁ \" , \" nine ▁ \" , \" ten ▁ \" , \" eleven ▁ \" , \" twelve ▁ \" , \" thirteen ▁ \" , \" fourteen ▁ \" , \" fifteen ▁ \" , \" sixteen ▁ \" , \" seventeen ▁ \" , \" eighteen ▁ \" , \" nineteen ▁ \" ] ; NEW_LINE ten = [ \" \" , \" \" , \" twenty ▁ \" , \" thirty ▁ \" , \" forty ▁ \" , \" fifty ▁ \" , \" sixty ▁ \" , \" seventy ▁ \" , \" eighty ▁ \" , \" ninety ▁ \" ] ; NEW_LINE def numToWords ( n , s ) : NEW_LINE INDENT str = \" \" ; NEW_LINE if ( n > 19 ) : NEW_LINE INDENT str += ten [ n \/\/ 10 ] + one [ n % 10 ] ; NEW_LINE DEDENT else : NEW_LINE INDENT str += one [ n ] ; NEW_LINE DEDENT if ( n ) : NEW_LINE INDENT str += s ; NEW_LINE DEDENT return str ; NEW_LINE DEDENT def convertToWords ( n ) : NEW_LINE INDENT out = \" \" ; NEW_LINE out += numToWords ( ( n \/\/ 10000000 ) , \" crore ▁ \" ) ; NEW_LINE out += numToWords ( ( ( n \/\/ 100000 ) % 100 ) , \" lakh ▁ \" ) ; NEW_LINE out += numToWords ( ( ( n \/\/ 1000 ) % 100 ) , \" thousand ▁ \" ) ; NEW_LINE out += numToWords ( ( ( n \/\/ 100 ) % 10 ) , \" hundred ▁ \" ) ; NEW_LINE if ( n > 100 and n % 100 ) : NEW_LINE INDENT out += \" and ▁ \" ; NEW_LINE DEDENT out += numToWords ( ( n % 100 ) , \" \" ) ; NEW_LINE return out ; NEW_LINE DEDENT n = 438237764 ; NEW_LINE print ( convertToWords ( n ) ) ; NEW_LINE"],"bleu":0.299449328245308,"rouge_l":0.5270473328324569}
{"id":832,"predictions":["def factorial ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res *= i NEW_LINE DEDENT return res NEW_LINE DEDENT num = 5 NEW_LINE print ( \" Factorial ▁ of \" , num , \" is \" , factorial ( num ) ) NEW_LINE"],"references":["def factorial ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res *= i NEW_LINE DEDENT return res NEW_LINE DEDENT num = 5 ; NEW_LINE print ( \" Factorial ▁ of \" , num , \" is \" , factorial ( num ) ) NEW_LINE"],"bleu":0.9574206856844987,"rouge_l":0.9900962861072903}
{"id":833,"predictions":["def getMinCost ( n , m ) : NEW_LINE INDENT cost = ( n - 1 ) * m + ( m - 1 ) * n NEW_LINE return cost NEW_LINE DEDENT n , m = 4 , 5 NEW_LINE print ( getMinCost ( n , m ) ) NEW_LINE"],"references":["def getMinCost ( n , m ) : NEW_LINE INDENT cost = ( n - 1 ) * m + ( m - 1 ) * n NEW_LINE return cost NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n , m = 4 , 5 NEW_LINE print ( getMinCost ( n , m ) ) NEW_LINE DEDENT"],"bleu":0.732271830206613,"rouge_l":0.8581879572312887}
{"id":834,"predictions":["def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT a = 2 NEW_LINE b = 4 NEW_LINE print ( gcd ( a , b ) ) NEW_LINE"],"references":["def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT a = 2 NEW_LINE b = 4 NEW_LINE print ( gcd ( a , b ) ) NEW_LINE"],"bleu":0.9007690507972514,"rouge_l":0.9838709677419355}
{"id":835,"predictions":["def calculateSum ( n ) : NEW_LINE INDENT return n * ( n + 1 ) \/ 2 + ( pow ( n * ( n + 1 ) ) \/ 2 ) ) NEW_LINE DEDENT n = 3 NEW_LINE print ( \" Sum ▁ = \" , int ( calculateSum ( n ) ) ) NEW_LINE"],"references":["def calculateSum ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) \/\/ 2 + pow ( ( n * ( n + 1 ) \/\/ 2 ) , 2 ) ) NEW_LINE DEDENT n = 3 NEW_LINE print ( \" Sum ▁ = ▁ \" , calculateSum ( n ) ) NEW_LINE"],"bleu":0.6962015006737561,"rouge_l":0.8855678906917165}
{"id":836,"predictions":["def findLength ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE maxLen = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = ord ( str [ i ] ) [ 0 ] NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT sum = ord ( str [ i ] ) - ord ( '0' ) NEW_LINE for j in range ( i ) : NEW_LINE INDENT j = i + len ( ord ( str [ i ] ) ) NEW_LINE k = int ( len ( str [ j ] ) + ord ( '0' ) ) NEW_LINE sum = sum \/\/ 2 NEW_LINE DEDENT if ( len % 2 == 0 and l > maxLen ) : NEW_LINE INDENT maxLen = len ( str [ i ] ) NEW_LINE DEDENT DEDENT if ( l % 2 == 0 and sum > maxLen ) : NEW_LINE INDENT maxLen = len ( str [ i ] ) NEW_LINE DEDENT return maxLen NEW_LINE DEDENT str = \"111\" NEW_LINE print ( \" Length ▁ of ▁ the ▁ substring ▁ is \" , findLength ( str ) ) NEW_LINE"],"references":["def findLength ( string ) : NEW_LINE INDENT n = len ( string ) NEW_LINE maxlen = 0 NEW_LINE Sum = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT Sum [ i ] [ i ] = int ( string [ i ] ) NEW_LINE DEDENT for length in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( 0 , n - length + 1 ) : NEW_LINE INDENT j = i + length - 1 NEW_LINE k = length \/\/ 2 NEW_LINE Sum [ i ] [ j ] = ( Sum [ i ] [ j - k ] + Sum [ j - k + 1 ] [ j ] ) NEW_LINE if ( length % 2 == 0 and Sum [ i ] [ j - k ] == Sum [ ( j - k + 1 ) ] [ j ] and length > maxlen ) : NEW_LINE INDENT maxlen = length NEW_LINE DEDENT DEDENT DEDENT return maxlen NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \"153803\" NEW_LINE print ( \" Length ▁ of ▁ the ▁ substring ▁ is \" , findLength ( string ) ) NEW_LINE DEDENT"],"bleu":0.3763245988282097,"rouge_l":0.5248180013236267}
{"id":837,"predictions":["def solve ( a , b , n ) : NEW_LINE INDENT s = 0 NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return a NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT s += ( a [ i ] + b [ i ] ) NEW_LINE DEDENT if ( s % n != 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT x = s \/\/ n NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( a [ i ] > x ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( a [ i ] == x ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT x = a [ i ] + b [ i + 1 ] NEW_LINE if ( a [ i ] + b [ i + 1 ] == x ) : NEW_LINE INDENT y = 0 NEW_LINE continue NEW_LINE DEDENT if ( a [ i ] + b [ i ] == x ) : NEW_LINE INDENT a [ i + 1 ] += b [ i ] NEW_LINE continue NEW_LINE DEDENT if ( i + 1 < n and a [ i + 1 ] == x ) : NEW_LINE INDENT a [ i + 1 ] += b [ i ] NEW_LINE b [ i + 1 ] = 0 NEW_LINE continue NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 6 , 14 , 21 , 1 ] NEW_LINE b = [ 15 , 7 , 10 ] NEW_LINE n = len ( a ) NEW_LINE print ( solve ( a , b , n ) ) NEW_LINE DEDENT"],"references":["def solve ( a , b , n ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT s += a [ i ] + b [ i ] NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return a [ 0 ] + b [ 0 ] NEW_LINE DEDENT if s % n != 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT x = s \/\/ n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if a [ i ] > x : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if i > 0 : NEW_LINE INDENT a [ i ] += b [ i - 1 ] NEW_LINE b [ i - 1 ] = 0 NEW_LINE DEDENT if a [ i ] == x : NEW_LINE INDENT continue NEW_LINE DEDENT y = a [ i ] + b [ i ] NEW_LINE if i + 1 < n : NEW_LINE INDENT y += b [ i + 1 ] NEW_LINE DEDENT if y == x : NEW_LINE INDENT a [ i ] = y NEW_LINE b [ i ] = 0 NEW_LINE if i + 1 < n : b [ i + 1 ] = 0 NEW_LINE continue NEW_LINE DEDENT if a [ i ] + b [ i ] == x : NEW_LINE INDENT a [ i ] += b [ i ] NEW_LINE b [ i ] = 0 NEW_LINE continue NEW_LINE DEDENT if i + 1 < n and a [ i ] + b [ i + 1 ] == x : NEW_LINE INDENT a [ i ] += b [ i + 1 ] NEW_LINE b [ i + 1 ] = 0 NEW_LINE continue NEW_LINE DEDENT return - 1 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if b [ i ] != 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT return x NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 6 , 14 , 21 , 1 ] NEW_LINE b = [ 15 , 7 , 10 , 10 ] NEW_LINE n = len ( a ) NEW_LINE print ( solve ( a , b , n ) ) NEW_LINE DEDENT"],"bleu":0.5752368981796356,"rouge_l":0.7105383839310282}
{"id":838,"predictions":["def sumOfSeries ( n ) : NEW_LINE INDENT res = 0 NEW_LINE sum = 0 NEW_LINE prod = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + i NEW_LINE prod *= i NEW_LINE res += ( sum \/ prod ) NEW_LINE DEDENT return int ( res \/ prod ) NEW_LINE DEDENT n = 4 NEW_LINE print ( sumOfSeries ( n ) ) NEW_LINE"],"references":["def sumOfSeries ( n ) : NEW_LINE INDENT res = 0.0 NEW_LINE sum = 0 NEW_LINE prod = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + i NEW_LINE prod = prod * i NEW_LINE res = res + ( sum \/ prod ) NEW_LINE DEDENT return res NEW_LINE DEDENT n = 4 NEW_LINE print ( round ( sumOfSeries ( n ) , 5 ) ) NEW_LINE"],"bleu":0.7396349264474399,"rouge_l":0.8643194504079005}
{"id":839,"predictions":["def number_of_digits ( n ) : NEW_LINE INDENT res = 0 NEW_LINE sum = 0 NEW_LINE res = 1 NEW_LINE i = 4 NEW_LINE while ( res >= n ) : NEW_LINE INDENT sum += i NEW_LINE res *= 4 NEW_LINE if ( sum >= n ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 21 NEW_LINE print ( number_of_digits ( n ) ) NEW_LINE DEDENT"],"references":["def number_of_digits ( n ) : NEW_LINE INDENT i = 4 ; NEW_LINE res = 1 ; NEW_LINE sum = 0 ; NEW_LINE while ( True ) : NEW_LINE INDENT i *= 4 ; NEW_LINE res += 1 ; NEW_LINE sum += i ; NEW_LINE if ( sum >= n ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT return res ; NEW_LINE DEDENT n = 21 ; NEW_LINE print ( number_of_digits ( n ) ) ; NEW_LINE"],"bleu":0.48439498874588266,"rouge_l":0.6835778321108394}
{"id":840,"predictions":["import math NEW_LINE def nonsqSquare ( n ) : NEW_LINE INDENT return n + ( 0.5 * math . sqrt ( n ) ) NEW_LINE DEDENT def printNonSquare ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( neqSquare ( i ) , end = \" ▁ \" ) NEW_LINE print ( ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 10 NEW_LINE printNonSquare ( n ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def nonsquare ( n ) : NEW_LINE INDENT return n + ( int ) ( 0.5 + math . sqrt ( n ) ) NEW_LINE DEDENT def printNonSquare ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( nonsquare ( i ) , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT n = 10 NEW_LINE printNonSquare ( n ) NEW_LINE"],"bleu":0.6946043799915017,"rouge_l":0.8521253242865695}
{"id":841,"predictions":["def distance ( x1 , x2 , y2 ) : NEW_LINE INDENT return ( ( x2 - x1 ) + ( y2 - y1 ) * ( x2 - y1 ) ) \/ ( y2 - y1 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( round ( distance ( 3 , 4 , 4 ) , 2 ) ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def distance ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT return math . sqrt ( math . pow ( x2 - x1 , 2 ) + math . pow ( y2 - y1 , 2 ) * 1.0 ) NEW_LINE DEDENT print ( \" % .6f \" % distance ( 3 , 4 , 4 , 3 ) ) NEW_LINE"],"bleu":0.38859778284966734,"rouge_l":0.6118939574874612}
{"id":842,"predictions":["def evenOddSort ( arr , n ) : NEW_LINE INDENT for i in range ( 2 , n , 2 ) : NEW_LINE INDENT j = i - 2 NEW_LINE while ( ( ( i + 1 ) & 1 ) == 1 and ( arr [ j ] >= arr [ i ] ) ) : NEW_LINE INDENT arr [ j ] , arr [ i ] = arr [ j ] , arr [ i ] NEW_LINE j -= 2 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT while ( j >= 0 and arr [ j ] <= arr [ i ] ) : NEW_LINE INDENT arr [ j ] , arr [ j + 2 ] = arr [ j ] , arr [ i ] NEW_LINE j -= 2 NEW_LINE DEDENT DEDENT DEDENT def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n , 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \" ) NEW_LINE DEDENT DEDENT arr = [ 12 , 11 , 13 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE evenOddSort ( arr , n ) NEW_LINE printArray ( arr , n ) NEW_LINE"],"references":["def evenOddInsertionSort ( arr , n ) : NEW_LINE INDENT for i in range ( 2 , n ) : NEW_LINE INDENT j = i - 2 NEW_LINE temp = arr [ i ] NEW_LINE if ( ( i + 1 ) & 1 == 1 ) : NEW_LINE INDENT while ( temp >= arr [ j ] and j >= 0 ) : NEW_LINE INDENT arr [ j + 2 ] = arr [ j ] NEW_LINE j -= 2 NEW_LINE DEDENT arr [ j + 2 ] = temp NEW_LINE DEDENT else : NEW_LINE INDENT while ( temp <= arr [ j ] and j >= 0 ) : NEW_LINE INDENT arr [ j + 2 ] = arr [ j ] NEW_LINE j -= 2 NEW_LINE DEDENT arr [ j + 2 ] = temp NEW_LINE DEDENT DEDENT DEDENT def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 12 , 11 , 13 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE evenOddInsertionSort ( arr , n ) NEW_LINE printArray ( arr , n ) NEW_LINE"],"bleu":0.7167057407164333,"rouge_l":0.7827122550902804}
{"id":843,"predictions":["def search ( arr , l , h , key ) : NEW_LINE if l > h : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( l + h ) \/\/ 2 NEW_LINE if arr [ l ] == key : NEW_LINE INDENT return mid NEW_LINE DEDENT if arr [ l ] == key : NEW_LINE INDENT return search ( arr , l , mid , key ) NEW_LINE DEDENT if arr [ l ] == arr [ h ] and key <= arr [ h ] : NEW_LINE INDENT return search ( arr , l , mid - 1 , key ) NEW_LINE if key >= arr [ h ] and key <= arr [ h ] : NEW_LINE INDENT return search ( arr , l , mid - 1 , key ) NEW_LINE DEDENT return search ( arr , l + 1 , h , key ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 3 , 1 , 2 , 3 , 3 ] NEW_LINE key = 3 NEW_LINE n = len ( arr ) NEW_LINE key = 3 NEW_LINE print ( search ( arr , 0 , n - 1 , key ) ) NEW_LINE DEDENT"],"references":["def search ( arr , l , h , key ) : NEW_LINE INDENT if ( l > h ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT mid = ( l + h ) \/\/ 2 ; NEW_LINE if ( arr [ mid ] == key ) : NEW_LINE INDENT return mid ; NEW_LINE DEDENT if ( ( arr [ l ] == arr [ mid ] ) and ( arr [ h ] == arr [ mid ] ) ) : NEW_LINE INDENT l += 1 ; NEW_LINE h -= 1 ; NEW_LINE DEDENT if ( arr [ l ] <= arr [ mid ] ) : NEW_LINE INDENT if ( key >= arr [ l ] and key <= arr [ mid ] ) : NEW_LINE INDENT return search ( arr , l , mid - 1 , key ) ; NEW_LINE DEDENT return search ( arr , mid + 1 , h , key ) ; NEW_LINE DEDENT if ( key >= arr [ mid ] and key <= arr [ h ] ) : NEW_LINE INDENT return search ( arr , mid + 1 , h , key ) ; NEW_LINE DEDENT return search ( arr , l , mid - 1 , key ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 3 , 1 , 2 , 3 , 3 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE key = 3 ; NEW_LINE print ( search ( arr , 0 , n - 1 , key ) ) ; NEW_LINE DEDENT"],"bleu":0.564661673796512,"rouge_l":0.752}
{"id":844,"predictions":["def check ( s1 , s2 ) : NEW_LINE INDENT mp = { } NEW_LINE def check ( s1 , s2 ) : NEW_LINE INDENT mp [ s1 [ i ] ] = 0 NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT mp [ s1 [ i ] ] += 1 NEW_LINE DEDENT for i in range ( len ( s2 ) ) : NEW_LINE INDENT if ( mp [ s1 [ i ] ] > 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s1 = \" geeksforgeeks \" NEW_LINE s2 = \" geeksforgeeks \" NEW_LINE if ( check ( s1 , s2 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def is_member ( List , key ) : NEW_LINE INDENT for i in range ( 0 , len ( List ) ) : NEW_LINE INDENT if key == List [ i ] : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def overlap ( List1 , List2 ) : NEW_LINE INDENT for key in List1 : NEW_LINE INDENT if is_member ( List2 , key ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s1 = ' geeksforgeeks ' NEW_LINE s2 = ' geeks ' NEW_LINE List1 = list ( s1 ) NEW_LINE List2 = list ( s2 ) NEW_LINE yes_or_no = str ( overlap ( List1 , List2 ) ) NEW_LINE if ( yes_or_no ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.4452546703906097,"rouge_l":0.5782894051463694}
{"id":845,"predictions":["def nthTerm ( n ) : NEW_LINE INDENT return 2 * pow ( n , 2 ) + 3 * n - 5 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT"],"references":["def nthTerm ( n ) : NEW_LINE INDENT return 2 * pow ( n , 2 ) + 3 * n - 5 NEW_LINE DEDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE"],"bleu":0.6918211695197932,"rouge_l":0.8657460682777137}
{"id":846,"predictions":["def baltary ( root ) : NEW_LINE INDENT carry = 0 NEW_LINE i = 32 NEW_LINE j = 0 NEW_LINE while ( True ) : NEW_LINE INDENT rem = - 1 NEW_LINE if ( rem == 0 ) : NEW_LINE INDENT if ( arr [ i ] % base == 0 ) : NEW_LINE INDENT arr [ i ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] -= 1 NEW_LINE rem = 0 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT elif ( rem == 2 ) : NEW_LINE INDENT arr [ i ] = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] -= 1 NEW_LINE DEDENT DEDENT if ( rem == 2 ) : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE DEDENT elif ( rem == 3 ) : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT DEDENT temp = 1 NEW_LINE while ( rem > 0 ) : NEW_LINE INDENT rem = number % 3 NEW_LINE if ( arr [ i ] == - 1 ) : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE rem = 0 NEW_LINE DEDENT elif ( rem == 2 ) : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return arr [ 0 ] + rem NEW_LINE DEDENT defvert ( number ) : NEW_LINE INDENT ans = 0 NEW_LINE rem = 1 NEW_LINE while ( rem ) : NEW_LINE INDENT if ( arr [ i ] == - 1 ) : NEW_LINE INDENT ans = ( arr [ rem ] , arr [ rem ] ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = ans + rem NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = 30 NEW_LINE rem = 1 NEW_LINE while ( arr [ rem ) : NEW"],"references":["arr = [ 0 ] * 32 NEW_LINE def balTernary ( ter ) : NEW_LINE INDENT carry , base , i = 0 , 10 , 31 NEW_LINE while ter > 0 : NEW_LINE INDENT rem = ( ter % base ) + carry NEW_LINE if rem == 0 : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE carry , i = 0 , i - 1 NEW_LINE DEDENT elif rem == 1 : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE carry , i = 0 , i - 1 NEW_LINE DEDENT elif rem == 2 : NEW_LINE INDENT arr [ i ] = - 1 NEW_LINE carry , i = 1 , i - 1 NEW_LINE DEDENT elif rem == 3 : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE carry , i = 1 , i - 1 NEW_LINE DEDENT ter = ter \/\/ base NEW_LINE DEDENT if carry == 1 : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT DEDENT def ternary ( number ) : NEW_LINE INDENT ans , rem , base = 0 , 1 , 1 NEW_LINE while number > 0 : NEW_LINE INDENT rem = number % 3 NEW_LINE ans = ans + rem * base NEW_LINE number \/\/= 3 NEW_LINE base = base * 10 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT number = 3056 NEW_LINE ter = ternary ( number ) NEW_LINE balTernary ( ter ) NEW_LINE i = 0 NEW_LINE while arr [ i ] == 0 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT for j in range ( i , 32 ) : NEW_LINE INDENT if arr [ j ] == - 1 : NEW_LINE INDENT print ( ' Z ' , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ j ] , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT"],"bleu":0.4189128184285073,"rouge_l":0.49591067143346884}
{"id":847,"predictions":["class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def newNode ( root ) : NEW_LINE INDENT q = [ ] NEW_LINE sz = [ ] NEW_LINE q . append ( root ) NEW_LINE while ( len ( q ) != 0 ) : NEW_LINE INDENT temp = q [ 0 ] NEW_LINE q . append ( root . left ) NEW_LINE sz . append ( root . data ) NEW_LINE if len ( q ) != 0 : NEW_LINE INDENT q . append ( temp . data ) NEW_LINE DEDENT while len ( q ) != 0 : NEW_LINE INDENT temp = q [ 0 ] NEW_LINE q . pop ( 0 ) NEW_LINE if temp . left : NEW_LINE INDENT q . append ( temp . data ) NEW_LINE if temp . right : NEW_LINE INDENT q . append ( temp . data ) NEW_LINE q . append ( temp . data ) NEW_LINE DEDENT else : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE DEDENT DEDENT DEDENT DEDENT while len ( q ) != 0 : NEW_LINE INDENT for i in range ( 0 , len ( q ) ) : NEW_LINE INDENT print ( q [ - 1 ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT root = Node ( 1 ) NEW_LINE root . left = newNode ( 2 ) NEW_LINE root . right = newNode ( 2 ) NEW_LINE root . left . left = newNode ( 3 ) NEW_LINE root . right = newNode ( 1 ) NEW_LINE root . left . left = newNode ( 3 ) NEW_LINE root . right . left = newNode ( 3 ) NEW_LINE root . right . left = newNode ( 4 ) NEW_LINE root . right . left = newNode ( 5 ) NEW_LINE root . right . left = newNode ( 4 ) NEW_LINE root . right . left . right = newNode ( 5 ) NEW_"],"references":["class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def specific_level_order_traversal ( root ) : NEW_LINE INDENT q = [ ] NEW_LINE s = [ ] NEW_LINE q . append ( root ) NEW_LINE sz = 0 NEW_LINE while ( len ( q ) > 0 ) : NEW_LINE INDENT v = [ ] NEW_LINE sz = len ( q ) NEW_LINE i = 0 NEW_LINE while ( i < sz ) : NEW_LINE INDENT temp = q [ 0 ] NEW_LINE q . pop ( 0 ) NEW_LINE v . append ( temp . data ) NEW_LINE if ( temp . left != None ) : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE DEDENT if ( temp . right != None ) : NEW_LINE INDENT q . append ( temp . right ) NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT s . append ( v ) NEW_LINE DEDENT while ( len ( s ) > 0 ) : NEW_LINE INDENT v = s [ - 1 ] NEW_LINE s . pop ( ) NEW_LINE i = 0 NEW_LINE j = len ( v ) - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT print ( v [ i ] , \" ▁ \" , v [ j ] , end = \" ▁ \" ) NEW_LINE j = j - 1 NEW_LINE i = i + 1 NEW_LINE DEDENT DEDENT print ( root . data ) NEW_LINE DEDENT root = Node ( 1 ) NEW_LINE root . left = Node ( 2 ) NEW_LINE root . right = Node ( 3 ) NEW_LINE print ( \" Specific ▁ Level ▁ Order ▁ traversal ▁ of ▁ binary ▁ tree ▁ is \" ) NEW_LINE specific_level_order_traversal ( root ) NEW_LINE"],"bleu":0.4672008945904587,"rouge_l":0.6034408602150537}
{"id":848,"predictions":["def SUM ( h ) : NEW_LINE INDENT return ( 2 ** h - 1 ) NEW_LINE DEDENT L = 3 NEW_LINE print ( SUM ( L ) ) NEW_LINE"],"references":["def summ ( h ) : NEW_LINE INDENT return pow ( 2 , h - 1 ) NEW_LINE DEDENT L = 3 NEW_LINE print ( summ ( L ) ) NEW_LINE"],"bleu":0.6901661191105223,"rouge_l":0.8826366559485532}
{"id":849,"predictions":["def countDivisors ( N , a , b ) : NEW_LINE INDENT count1 = N \/\/ a NEW_LINE count2 = N \/\/ ( a * b ) NEW_LINE count3 = ( N \/\/ ( a * b ) ) NEW_LINE return count1 + count2 - count3 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 1000 NEW_LINE a = 3 NEW_LINE b = 4 NEW_LINE print ( countDivisors ( N , a , b ) ) NEW_LINE DEDENT"],"references":["def countDivisors ( N , a , b ) : NEW_LINE INDENT count1 = N \/\/ a NEW_LINE count2 = N \/\/ b NEW_LINE count3 = ( N \/\/ ( a * b ) ) NEW_LINE return count1 + count2 - count3 NEW_LINE DEDENT N = 1000 NEW_LINE a = 3 NEW_LINE b = 4 NEW_LINE print ( countDivisors ( N , a , b ) ) NEW_LINE"],"bleu":0.7444277573433199,"rouge_l":0.9021313614615051}
{"id":850,"predictions":["def number_english ( n ) : NEW_LINE INDENT return ( n * n * n + 5 ) \/\/ 6 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 2 NEW_LINE print ( number_english ( n ) ) NEW_LINE n = 25 NEW_LINE print ( int ( number_english ( n ) ) ) NEW_LINE DEDENT"],"references":["def number_cake ( n ) : NEW_LINE INDENT return ( n * n * n + 5 * n + 6 ) \/\/ 6 NEW_LINE DEDENT n = 2 NEW_LINE print ( number_cake ( n ) ) NEW_LINE n = 8 NEW_LINE print ( number_cake ( n ) ) NEW_LINE n = 25 NEW_LINE print ( number_cake ( n ) ) NEW_LINE"],"bleu":0.5720704699858569,"rouge_l":0.6889939584975047}
{"id":851,"predictions":["MAX = 100000 ; NEW_LINE prime = [ True ] * ( MAX + 1 ) ; NEW_LINE def SieveOfEratosthenes ( ) ; NEW_LINE def sieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 1 ] = False ; NEW_LINE for p in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX + p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def find_prime ( sum ) : NEW_LINE INDENT for i in range ( sum \/ 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( prime [ i ] and prime [ sum - i ] ) : NEW_LINE INDENT print ( i , \" , end = \" ) ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT SieveOfEratosthenes ( ) ; NEW_LINE SieveOfEratosthenes ( ) ; NEW_LINE DEDENT"],"references":["from math import sqrt NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT MAX = 1000001 NEW_LINE prime = [ True for i in range ( MAX + 1 ) ] NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( sqrt ( MAX ) ) + 1 , 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT return prime NEW_LINE DEDENT def find_Prime ( sum ) : NEW_LINE INDENT prime = SieveOfEratosthenes ( ) NEW_LINE i = int ( sum \/ 2 ) NEW_LINE while ( i > 1 ) : NEW_LINE INDENT if ( prime [ i ] and prime [ sum - i ] ) : NEW_LINE INDENT print ( i , ( sum - i ) ) NEW_LINE return NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT print ( \" Cannot ▁ be ▁ represented ▁ as ▁ sum \" , \" of ▁ two ▁ primes \" ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT sum = 1002 NEW_LINE find_Prime ( sum ) NEW_LINE DEDENT"],"bleu":0.51244451404584,"rouge_l":0.6617994942491231}
{"id":852,"predictions":["def generateNumbers ( factor , n , k ) : NEW_LINE INDENT next = [ 0 ] * k NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT next [ i ] = 0 NEW_LINE for j in range ( 0 , k , 1 ) : NEW_LINE INDENT if ( next [ j ] < next [ i ] ) : NEW_LINE INDENT next [ i ] = next [ j ] NEW_LINE next [ i ] = next [ j ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT next [ i ] = next [ i ] + int ( next [ i ] ) NEW_LINE next [ i ] = next [ i ] + int ( next [ i ] ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT factor = [ 3 , 5 , 7 ] NEW_LINE n = len ( factor ) NEW_LINE k = 10 NEW_LINE generateNumbers ( factor , n , k ) NEW_LINE DEDENT"],"references":["def generateNumbers ( factor , n , k ) : NEW_LINE INDENT next = [ 0 ] * k ; NEW_LINE output = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT toincrement = 0 ; NEW_LINE for j in range ( k ) : NEW_LINE INDENT if ( next [ j ] < next [ toincrement ] ) : NEW_LINE INDENT toincrement = j ; NEW_LINE DEDENT DEDENT if ( output != next [ toincrement ] ) : NEW_LINE INDENT output = next [ toincrement ] ; NEW_LINE print ( next [ toincrement ] , end = \" ▁ \" ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT next [ toincrement ] += factor [ toincrement ] ; NEW_LINE DEDENT DEDENT factor = [ 3 , 5 , 7 ] ; NEW_LINE n = 10 ; NEW_LINE k = len ( factor ) ; NEW_LINE generateNumbers ( factor , n , k ) ; NEW_LINE"],"bleu":0.4224599664879149,"rouge_l":0.6325492078732597}
{"id":853,"predictions":["def lengthOfSmallestSubsequence ( K , v ) : NEW_LINE INDENT pq = [ ] NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT pq . append ( v [ i ] ) NEW_LINE DEDENT sum = 0 NEW_LINE v = [ ] NEW_LINE while ( len ( pq ) > 0 and sum < K ) : NEW_LINE INDENT sum += pq [ - 1 ] NEW_LINE pq . append ( i ) NEW_LINE sum += 1 NEW_LINE DEDENT if ( sum < K ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT def length ( K , v ) : NEW_LINE INDENT v = [ ] NEW_LINE k = 0 NEW_LINE count = 0 NEW_LINE while ( len ( v ) ) : NEW_LINE INDENT v . append ( v [ - 1 ] ) NEW_LINE if ( sum < k ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT count += 1 NEW_LINE DEDENT return v NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT v = [ 2 , 3 , 1 , 5 , 6 , 3 , 7 , 9 , 2 , 10 , 2 , 5 ] NEW_LINE K = 35 NEW_LINE print ( lengthOfSmallestSubsequence ( K , v ) ) NEW_LINE DEDENT"],"references":["def lengthOfSmallestSubsequence ( K , v ) : NEW_LINE INDENT pq = [ ] NEW_LINE for i in v : NEW_LINE INDENT pq . append ( i ) NEW_LINE DEDENT pq . sort ( ) NEW_LINE sum = 0 NEW_LINE count = 0 NEW_LINE while ( len ( pq ) > 0 and sum < K ) : NEW_LINE INDENT sum += pq [ - 1 ] NEW_LINE del pq [ - 1 ] NEW_LINE count += 1 NEW_LINE DEDENT if ( sum < K ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return count NEW_LINE DEDENT v = [ 2 , 3 , 1 , 5 , 6 , 3 , 7 , 9 , 14 , 10 , 2 , 5 ] NEW_LINE K = 35 NEW_LINE print ( lengthOfSmallestSubsequence ( K , v ) ) NEW_LINE"],"bleu":0.5320161405077845,"rouge_l":0.7149554617909049}
{"id":854,"predictions":["def search ( arr , n , x ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( arr [ i ] == x ) : NEW_LINE INDENT return i NEW_LINE DEDENT i = i + abs ( arr [ i ] - x ) NEW_LINE DEDENT return - 1 NEW_LINE DEDENT arr = [ 8 , 7 , 6 , 6 , 3 , 4 , 2 , 3 , 3 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE x = 3 NEW_LINE print ( \" number ▁ is ▁ \" , search ( arr , n , x ) ) NEW_LINE"],"references":["def search ( arr , n , x ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( arr [ i ] == x ) : NEW_LINE INDENT return i NEW_LINE DEDENT i = i + abs ( arr [ i ] - x ) NEW_LINE DEDENT print ( \" number ▁ is ▁ not ▁ present ! \" ) NEW_LINE return - 1 NEW_LINE DEDENT arr = [ 8 , 7 , 6 , 7 , 6 , 5 , 4 , 3 , 2 , 3 , 4 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE x = 3 NEW_LINE print ( \" Element \" , x , \" ▁ is ▁ present ▁ at ▁ index ▁ \" , search ( arr , n , 3 ) ) NEW_LINE"],"bleu":0.7156393888490669,"rouge_l":0.8349981502034777}
{"id":855,"predictions":["def CheckArray ( arr , n ) : NEW_LINE INDENT prod = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT prod *= arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == prod \/\/ arr [ i ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 12 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE if ( CheckArray ( arr , n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"references":["def CheckArray ( arr , n ) : NEW_LINE INDENT prod = 1 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT prod *= arr [ i ] NEW_LINE DEDENT for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( arr [ i ] == prod \/ arr [ i ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 12 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE if ( CheckArray ( arr , n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.8363943426012271,"rouge_l":0.9359140800188834}
{"id":856,"predictions":["def minRemove ( arr , n ) : NEW_LINE INDENT LIS = [ 1 ] * n ; NEW_LINE lIS = [ 0 ] * n ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT LIS [ i ] = 1 ; NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ j ] > arr [ i - j ] and ( arr [ i ] - arr [ j ] ) <= ( arr [ i ] ) ) : NEW_LINE INDENT LIS [ i ] = max ( LIS [ i ] , LIS [ i ] + 1 ) ; NEW_LINE DEDENT DEDENT lIS [ i ] = max ( LIS [ i ] , LIS [ i ] + 1 ) ; NEW_LINE DEDENT return n - lIS NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 6 , 5 , 4 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( minRemove ( arr , n ) ) ; NEW_LINE DEDENT"],"references":["def minRemove ( arr , n ) : NEW_LINE INDENT LIS = [ 0 for i in range ( n ) ] NEW_LINE len = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT LIS [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) : NEW_LINE INDENT LIS [ i ] = max ( LIS [ i ] , LIS [ j ] + 1 ) NEW_LINE DEDENT DEDENT len = max ( len , LIS [ i ] ) NEW_LINE DEDENT return ( n - len ) NEW_LINE DEDENT arr = [ 1 , 2 , 6 , 5 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minRemove ( arr , n ) ) NEW_LINE"],"bleu":0.6508282989808976,"rouge_l":0.8212777191129884}
{"id":857,"predictions":["def stringVal ( s , i , prev , dp ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( s [ i ] == '1' ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 NEW_LINE DEDENT DEDENT def countMinimalReplacements ( s , i , prev , prev , dp ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ prev ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ prev ] NEW_LINE DEDENT if ( dp [ i ] [ prev ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ prev ] NEW_LINE DEDENT val = float ( ' inf ' ) NEW_LINE for cur in range ( i + 1 , 3 ) : NEW_LINE INDENT if ( cur == prev ) : NEW_LINE INDENT continue NEW_LINE DEDENT val = 1 + min ( ans , prev , dp [ i + 1 ] [ cur ] ) NEW_LINE ans = min ( ans , val , ans ) NEW_LINE DEDENT dp [ i ] [ val ] = ans NEW_LINE return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \"201211001\" NEW_LINE n = len ( s ) NEW_LINE dp = [ [ - 1 , 3 ] , [ - 1 , 0 ] for i in range ( n ) ] NEW_LINE print ( countMinimalReplacements ( s , 1 , val , n ) ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE def charVal ( s , i ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( s [ i ] == '1' ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 NEW_LINE DEDENT DEDENT def countMinimalReplacements ( s , i , prev , dp , n ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ prev ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ prev ] NEW_LINE DEDENT val = charVal ( s , i ) NEW_LINE ans = sys . maxsize NEW_LINE if ( val == prev ) : NEW_LINE INDENT val = 0 NEW_LINE for cur in range ( 3 ) : NEW_LINE INDENT if ( cur == prev ) : NEW_LINE INDENT continue NEW_LINE DEDENT val = 1 + countMinimalReplacements ( s , i + 1 , cur , dp , n ) NEW_LINE ans = min ( ans , val ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT ans = countMinimalReplacements ( s , i + 1 , val , dp , n ) NEW_LINE DEDENT dp [ i ] [ val ] = ans NEW_LINE return dp [ i ] [ val ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \"201220211\" NEW_LINE n = len ( s ) NEW_LINE dp = [ [ - 1 for i in range ( 3 ) ] for i in range ( n ) ] NEW_LINE val = charVal ( s , 0 ) NEW_LINE print ( countMinimalReplacements ( s , 1 , val , dp , n ) ) NEW_LINE DEDENT"],"bleu":0.6856459497803702,"rouge_l":0.7593642325219516}
{"id":858,"predictions":["def minimizedChar ( S , M ) : NEW_LINE INDENT -= S - S ; NEW_LINE dis = 0 ; NEW_LINE return tot \/ S ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT M = 100 ; NEW_LINE print ( int ( minimize ( S , M ) , 100 ) ) ; NEW_LINE DEDENT"],"references":["def discountPercentage ( S , M ) : NEW_LINE INDENT discount = M - S NEW_LINE disPercent = ( discount \/ M ) * 100 NEW_LINE return disPercent NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT M = 120 NEW_LINE S = 100 NEW_LINE print ( discountPercentage ( S , M ) , \" % \" ) NEW_LINE M = 1000 NEW_LINE S = 500 NEW_LINE print ( discountPercentage ( S , M ) , \" % \" ) NEW_LINE DEDENT"],"bleu":0.2872561303132,"rouge_l":0.5658865696816361}
{"id":859,"predictions":["def sumOfSeries ( n ) : NEW_LINE INDENT return 0.006 * ( pow ( 10 , n ) - 1 ) - 1 NEW_LINE DEDENT n = 2 NEW_LINE print ( sumOfSeries ( n ) ) NEW_LINE"],"references":["def sumOfSeries ( n ) : NEW_LINE INDENT return ( int ) ( 0.6172 * ( pow ( 10 , n ) - 1 ) - 0.55 * n ) NEW_LINE DEDENT n = 2 NEW_LINE print ( sumOfSeries ( n ) ) NEW_LINE"],"bleu":0.7105138982790289,"rouge_l":0.8509366281387006}
{"id":860,"predictions":["def do ( a , x , b , b ) : NEW_LINE INDENT if ( ( ( b - a ) % x == 0 and ( ( b - a ) % x == 0 and ( b - a ) % x == 0 and ( a ) % x == 0 ) ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a , b = 3 , 2 ; NEW_LINE if ( do ( a , x , a , b ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"],"references":["def Move ( a , x , b ) : NEW_LINE INDENT if ( ( ( ( b - a ) % x == 0 ) or ( ( b - a - 1 ) % x == 0 ) and a + 1 != b ) and b >= a ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 3 NEW_LINE x = 2 NEW_LINE b = 7 NEW_LINE if ( Move ( a , x , b ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.6269930006549668,"rouge_l":0.8077372452291315}
{"id":861,"predictions":["def No_of_Pairs ( N ) : NEW_LINE INDENT i = 1 NEW_LINE while ( ( ( i * i ) + ( 2 * i ) + ( 2 * i ) ) ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT return ( i - 1 ) NEW_LINE DEDENT def print_of_pairs ( ) : NEW_LINE INDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT mul = i * ( i + 1 ) NEW_LINE if ( mul * i ) > ( mul * i + 1 ) : NEW_LINE INDENT print ( \" pair ▁ of ▁ pairs ▁ = \" , i , \" , \" , ▁ \" , mul * ( i + 1 ) , \" , ▁ \" , mul * ( mul ) ) NEW_LINE DEDENT print ( \" ( \" , \" , ▁ \" , mul ) \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 500 NEW_LINE pairs = No_of_Pairs ( N ) NEW_LINE DEDENT"],"references":["def No_Of_Pairs ( N ) : NEW_LINE INDENT i = 1 ; NEW_LINE while ( ( i * i * i ) + ( 2 * i * i ) + i <= N ) : NEW_LINE INDENT i += 1 ; NEW_LINE DEDENT return ( i - 1 ) ; NEW_LINE DEDENT def print_pairs ( pairs ) : NEW_LINE INDENT i = 1 ; NEW_LINE mul = 0 ; NEW_LINE for i in range ( 1 , pairs + 1 ) : NEW_LINE INDENT mul = i * ( i + 1 ) ; NEW_LINE print ( \" Pair ▁ no . \" , i , \" ▁ - - > ▁ ( \" , ( mul * i ) , \" , ▁ \" , mul * ( i + 1 ) , \" ) \" ) ; NEW_LINE DEDENT DEDENT N = 500 ; NEW_LINE i = 1 ; NEW_LINE pairs = No_Of_Pairs ( N ) ; NEW_LINE print ( \" No . ▁ of ▁ pairs ▁ = ▁ \" , pairs ) ; NEW_LINE print_pairs ( pairs ) ; NEW_LINE"],"bleu":0.5195566584215163,"rouge_l":0.6298175344904317}
{"id":862,"predictions":["def power ( x , a ) : NEW_LINE INDENT res = 1 NEW_LINE while ( a ) : NEW_LINE INDENT if ( ( a & 1 ) ) : NEW_LINE INDENT res = res * x NEW_LINE DEDENT if ( ( a & 1 ) ) : NEW_LINE INDENT res = res * x NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT def solve ( N ) : NEW_LINE INDENT if ( N == 2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT maxProduct = - 1 NEW_LINE if ( N == 3 ) : NEW_LINE INDENT maxProduct = 2 * power ( 3 , N \/\/ 3 ) - 1 NEW_LINE DEDENT elif ( N % 3 ) : NEW_LINE INDENT maxProduct = 2 * power ( 3 , N \/\/ 3 ) - 1 NEW_LINE DEDENT else : NEW_LINE INDENT maxProduct = 2 * power ( N \/\/ 3 ) - 1 NEW_LINE DEDENT return maxProduct NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT maxProduct = solve ( 10 ) NEW_LINE print ( maxProduct ( 10 ) ) NEW_LINE DEDENT"],"references":["def power ( x , a ) : NEW_LINE INDENT res = 1 ; NEW_LINE while ( a ) : NEW_LINE INDENT if ( a & 1 ) : NEW_LINE INDENT res = res * x ; NEW_LINE DEDENT x = x * x ; NEW_LINE a >>= 1 ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT def breakInteger ( N ) : NEW_LINE INDENT if ( N == 2 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT if ( N == 3 ) : NEW_LINE INDENT return 2 ; NEW_LINE DEDENT maxProduct = 0 ; NEW_LINE if ( N % 3 == 0 ) : NEW_LINE INDENT maxProduct = power ( 3 , int ( N \/ 3 ) ) ; NEW_LINE return maxProduct ; NEW_LINE DEDENT elif ( N % 3 == 1 ) : NEW_LINE INDENT maxProduct = 2 * 2 * power ( 3 , int ( N \/ 3 ) - 1 ) ; NEW_LINE return maxProduct ; NEW_LINE DEDENT elif ( N % 3 == 2 ) : NEW_LINE INDENT maxProduct = 2 * power ( 3 , int ( N \/ 3 ) ) ; NEW_LINE return maxProduct ; NEW_LINE DEDENT DEDENT maxProduct = breakInteger ( 10 ) ; NEW_LINE print ( maxProduct ) ; NEW_LINE"],"bleu":0.5071240678290565,"rouge_l":0.6871027435835545}
{"id":863,"predictions":["def printTrib ( n ) : NEW_LINE INDENT dp = [ 0 ] * n NEW_LINE dp [ 0 ] = 0 NEW_LINE dp [ 1 ] = 1 NEW_LINE dp [ 2 ] = 1 NEW_LINE for i in range ( 3 , n ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] NEW_LINE DEDENT for i in range ( 3 , n ) : NEW_LINE INDENT print ( dp [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 10 NEW_LINE printTrib ( n ) NEW_LINE DEDENT"],"references":["def printTrib ( n ) : NEW_LINE INDENT dp = [ 0 ] * n NEW_LINE dp [ 0 ] = dp [ 1 ] = 0 ; NEW_LINE dp [ 2 ] = 1 ; NEW_LINE for i in range ( 3 , n ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + dp [ i - 3 ] ; NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( dp [ i ] , \" ▁ \" , end = \" \" ) NEW_LINE DEDENT DEDENT n = 10 NEW_LINE printTrib ( n ) NEW_LINE"],"bleu":0.7616811238537712,"rouge_l":0.8542706600110925}
{"id":864,"predictions":["def findCount ( d ) : NEW_LINE INDENT return 9 * ( pow ( 10 , d - 1 ) - ( 9 * d - 1 ) ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT d = 1 ; NEW_LINE print ( findCount ( d ) ) ; NEW_LINE DEDENT"],"references":["import math NEW_LINE def findCount ( d ) : NEW_LINE INDENT return 9 * ( ( int ) ( math . pow ( 10 , d - 1 ) ) - ( int ) ( math . pow ( 9 , d - 1 ) ) ) ; NEW_LINE DEDENT d = 1 NEW_LINE print ( findCount ( d ) ) NEW_LINE d = 2 NEW_LINE print ( findCount ( d ) ) NEW_LINE d = 4 NEW_LINE print ( findCount ( d ) ) NEW_LINE"],"bleu":0.3660224412891534,"rouge_l":0.5707136640557006}
{"id":865,"predictions":["def conversion ( n ) : NEW_LINE INDENT return ( n - 32.0 \/ 5.0 ) * 5 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 40 NEW_LINE print ( conversion ( n ) ) NEW_LINE DEDENT"],"references":["def Conversion ( n ) : NEW_LINE INDENT return ( n - 32.0 ) * 5.0 \/ 9.0 NEW_LINE DEDENT n = 40 NEW_LINE x = Conversion ( n ) NEW_LINE print ( x ) NEW_LINE"],"bleu":0.38198563940322994,"rouge_l":0.6234668847097301}
{"id":866,"predictions":["def isPalindrome ( str , i , j , a ) : NEW_LINE INDENT l = len ( str [ i ] ) \/\/ 2 NEW_LINE if ( str [ i ] != str [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT def palindromIndex ( str , i , j , m , n ) : NEW_LINE INDENT if ( j < m - 1 or i < n - i < n - 1 ) : NEW_LINE INDENT if ( i < n - 1 or i < n - i < n - 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( j < m - 1 or i < n - 1 ) : NEW_LINE INDENT palindromid ( str , i + 1 , j , m , a ) NEW_LINE DEDENT elif ( j < m - 1 and i < n - 1 ) : NEW_LINE INDENT palindromid ( str , i + 1 , j , m , n ) NEW_LINE palindromid ( str , i + 1 , j , m , n ) NEW_LINE DEDENT DEDENT return palindromid ( str , arr ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" aaabb \" NEW_LINE arr = [ \" a \" , \" b \" , \" a \" , \" b \" ] NEW_LINE palindromicPath ( str , 0 , 4 ) NEW_LINE print ( palindromicpath ( str , arr , 0 , len ( arr ) - 1 , 4 ) ) NEW_LINE DEDENT"],"references":["def isPalin ( str ) : NEW_LINE INDENT l = len ( str ) \/\/ 2 NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( str [ i ] != str [ len ( str ) - i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def palindromicPath ( str , a , i , j , m , n ) : NEW_LINE INDENT if ( j < m - 1 or i < n - 1 ) : NEW_LINE INDENT if ( i < n - 1 ) : NEW_LINE INDENT palindromicPath ( str + a [ i ] [ j ] , a , i + 1 , j , m , n ) NEW_LINE DEDENT if ( j < m - 1 ) : NEW_LINE INDENT palindromicPath ( str + a [ i ] [ j ] , a , i , j + 1 , m , n ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT str = str + a [ n - 1 ] [ m - 1 ] NEW_LINE if isPalin ( str ) : NEW_LINE INDENT print ( str ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ [ ' a ' , ' a ' , ' a ' , ' b ' ] , [ ' b ' , ' a ' , ' a ' , ' a ' ] , [ ' a ' , ' b ' , ' b ' , ' a ' ] ] NEW_LINE str = \" \" NEW_LINE palindromicPath ( str , arr , 0 , 0 , 4 , 3 ) NEW_LINE DEDENT"],"bleu":0.5104821029499533,"rouge_l":0.5835815765352886}
{"id":867,"predictions":["def checkDivisors ( a , n ) : NEW_LINE INDENT m = a [ 0 ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT m = max ( a [ i ] , m ) NEW_LINE DEDENT return m NEW_LINE DEDENT def checkDivisors ( a , n ) : NEW_LINE INDENT X = max ( a ) NEW_LINE b = [ ] NEW_LINE for i in range ( 1 , a + 1 ) : NEW_LINE INDENT if ( X % i == 0 ) : NEW_LINE INDENT b . append ( i ) NEW_LINE if ( X \/\/ i != i ) : NEW_LINE INDENT b . append ( X \/\/ i ) NEW_LINE DEDENT DEDENT DEDENT if ( len ( b ) != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT a = sorted ( a ) NEW_LINE b = sorted ( b ) NEW_LINE if ( checkDivisors ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print \" No \" ) NEW_LINE DEDENT"],"references":["from math import sqrt NEW_LINE def checkDivisors ( a , n ) : NEW_LINE INDENT X = max ( a ) NEW_LINE b = [ ] NEW_LINE for i in range ( 1 , int ( sqrt ( X ) ) + 1 ) : NEW_LINE INDENT if ( X % i == 0 ) : NEW_LINE INDENT b . append ( i ) NEW_LINE if ( X \/\/ i != i ) : NEW_LINE INDENT b . append ( X \/\/ i ) NEW_LINE DEDENT DEDENT DEDENT if ( len ( b ) != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT a . sort ( reverse = False ) NEW_LINE b . sort ( reverse = False ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( b [ i ] != a [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 8 , 1 , 2 , 12 , 48 , 6 , 4 , 24 , 16 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE if ( checkDivisors ( arr , N ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.5773091244596253,"rouge_l":0.6246535263319988}
{"id":868,"predictions":["def printAllAPTriplets ( arr , n ) : NEW_LINE INDENT s = [ ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT diff = arr [ j ] - arr [ i ] NEW_LINE exists = False NEW_LINE if ( arr [ i ] - arr [ i ] ) : NEW_LINE INDENT exists = True NEW_LINE DEDENT if ( arr [ j ] - arr [ i ] ) : NEW_LINE INDENT print ( arr [ j ] - arr [ i ] , arr [ j ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 6 , 9 , 12 , 17 , 32 , 42 ] NEW_LINE n = len ( arr ) NEW_LINE printAllAPTriplets ( arr , n ) NEW_LINE DEDENT"],"references":["def printAllAPTriplets ( arr , n ) : NEW_LINE INDENT s = [ ] ; NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT diff = arr [ j ] - arr [ i ] ; NEW_LINE if ( ( arr [ i ] - diff ) in arr ) : NEW_LINE INDENT print ( \" { } ▁ { } ▁ { } \" . format ( ( arr [ i ] - diff ) , arr [ i ] , arr [ j ] ) , end = \" \\n \" ) ; NEW_LINE DEDENT DEDENT DEDENT s . append ( arr [ i ] ) ; NEW_LINE DEDENT arr = [ 2 , 6 , 9 , 12 , 17 , 22 , 31 , 32 , 35 , 42 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE printAllAPTriplets ( arr , n ) ; NEW_LINE"],"bleu":0.5975963364679663,"rouge_l":0.7122252747252747}
{"id":869,"predictions":["def isPowerOfTwo ( x ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( ( x & ( x - 1 ) ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def countNum ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( isPowerOfTwo ( a [ i ] + 1 ) ) or isPowerOfTwo ( a [ i ] + 1 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 6 , 3 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countNum ( arr , n ) ) NEW_LINE DEDENT"],"references":["def isPowerOfTwo ( x ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( ( x & ( x - 1 ) ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def countNum ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( isPowerOfTwo ( a [ i ] ) or isPowerOfTwo ( a [ i ] + 1 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 6 , 9 , 3 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countNum ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.9354808793007714,"rouge_l":0.9693748684487477}
{"id":870,"predictions":["from math import pi NEW_LINE def volume ( r ) : NEW_LINE INDENT volume_area = 4 \/ ( pi * r * r ) NEW_LINE return volume_area NEW_LINE DEDENT def surface_area ( r ) : NEW_LINE INDENT sur_area = 4 NEW_LINE volume_area = 4 NEW_LINE return volume_area NEW_LINE DEDENT def volume_area ( r ) : NEW_LINE INDENT sur_area = 4 NEW_LINE volume_area = volume_area NEW_LINE volume_area = volume_area NEW_LINE return volume_area NEW_LINE DEDENT volume = 12 NEW_LINE volume_area = volume ( volume_area ) NEW_LINE volume_area = volume_area ( volume_area ) NEW_LINE print ( \" Surface ▁ Area ▁ : ▁ \" , volume_area ) NEW_LINE print ( volume_area ( volume_area ) ) NEW_LINE"],"references":["import math NEW_LINE pi = math . pi NEW_LINE def volume ( r ) : NEW_LINE INDENT vol = ( 4 \/ 3 ) * pi * r * r * r NEW_LINE return vol NEW_LINE DEDENT def surfacearea ( r ) : NEW_LINE INDENT sur_ar = 4 * pi * r * r NEW_LINE return sur_ar NEW_LINE DEDENT radius = float ( 12 ) NEW_LINE print ( \" Volume ▁ Of ▁ Sphere ▁ : ▁ \" , volume ( radius ) ) NEW_LINE print ( \" Surface ▁ Area ▁ Of ▁ Sphere ▁ : ▁ \" , surfacearea ( radius ) ) NEW_LINE"],"bleu":0.33684698626433546,"rouge_l":0.5511218190031621}
{"id":871,"predictions":["def isPower ( 10 , 20 ) : NEW_LINE INDENT if ( isPower ( 10 , 20 ) ) : NEW_LINE INDENT print ( \" True \" ) ; NEW_LINE DEDENT elif ( isPower ( 2 , 20 ) ) : NEW_LINE INDENT print ( \" false \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" false \" ) ; NEW_LINE DEDENT elif ( isPower ( 30 , 31 ) ) : NEW_LINE INDENT print ( \" false \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( isPower ( 2 , 30 ) ) : NEW_LINE INDENT print ( \" false \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" false \" ) ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = 1 ; NEW_LINE if ( isPower ( 2 , 28 ) ) : NEW_LINE INDENT print ( \" true \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" false \" ) ; NEW_LINE DEDENT DEDENT"],"references":["def isPower ( x , y ) : NEW_LINE INDENT if ( x == 1 ) : NEW_LINE INDENT return ( y == 1 ) NEW_LINE DEDENT pow = 1 NEW_LINE while ( pow < y ) : NEW_LINE INDENT pow = pow * x NEW_LINE DEDENT return ( pow == y ) NEW_LINE DEDENT if ( isPower ( 10 , 1 ) ) : print ( \" True \" ) NEW_LINE else : print ( \" False \" ) NEW_LINE if ( isPower ( 1 , 20 ) ) : print ( \" True \" ) NEW_LINE else : print ( \" False \" ) NEW_LINE if ( isPower ( 2 , 128 ) ) : print ( \" True \" ) NEW_LINE else : print ( \" False \" ) NEW_LINE if ( isPower ( 2 , 30 ) ) : print ( \" True \" ) NEW_LINE else : print ( \" False \" ) NEW_LINE"],"bleu":0.31893088110134277,"rouge_l":0.6160407883125797}
{"id":872,"predictions":["import math NEW_LINE def getSum ( BIT , index ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( index > 0 ) : NEW_LINE INDENT sum += BIT [ index ] NEW_LINE index = index & ( - index & ( - index ) ) NEW_LINE DEDENT return sum NEW_LINE DEDENT def getInvCount ( arr , index , val , index ) : NEW_LINE INDENT while ( index <= n ) : NEW_LINE INDENT if ( index <= n ) : NEW_LINE INDENT arr [ index ] += val NEW_LINE index += index & ( - index ) ) NEW_LINE DEDENT else : NEW_LINE INDENT arr [ index ] = 0 NEW_LINE DEDENT DEDENT DEDENT def getInvCount ( arr , n ) : NEW_LINE INDENT invcount = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( maxElement < arr [ i ] ) : NEW_LINE INDENT invcount += getSum ( BIT , arr [ i ] ) NEW_LINE DEDENT DEDENT return invcount NEW_LINE DEDENT def getInvCount ( arr , n ) : NEW_LINE INDENT invcount = 0 NEW_LINE maxElement = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT invcount += getSum ( BIT , arr [ i ] ) NEW_LINE DEDENT return invcount NEW_LINE DEDENT arr = [ 8 , 4 , 2 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Number ▁ of ▁ in ▁ range ▁ are \" , getInvCount ( arr , n ) ) NEW_LINE"],"references":["def getSum ( BITree , index ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( index > 0 ) : NEW_LINE INDENT sum += BITree [ index ] NEW_LINE index -= index & ( - index ) NEW_LINE DEDENT return sum NEW_LINE DEDENT def updateBIT ( BITree , n , index , val ) : NEW_LINE INDENT while ( index <= n ) : NEW_LINE INDENT BITree [ index ] += val NEW_LINE index += index & ( - index ) NEW_LINE DEDENT DEDENT def getInvCount ( arr , n ) : NEW_LINE INDENT invcount = 0 NEW_LINE maxElement = max ( arr ) NEW_LINE BIT = [ 0 ] * ( maxElement + 1 ) NEW_LINE for i in range ( 1 , maxElement + 1 ) : NEW_LINE INDENT BIT [ i ] = 0 NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT invcount += getSum ( BIT , arr [ i ] - 1 ) NEW_LINE updateBIT ( BIT , maxElement , arr [ i ] , 1 ) NEW_LINE DEDENT return invcount NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 8 , 4 , 2 , 1 ] NEW_LINE n = 4 NEW_LINE print ( \" Inversion ▁ Count ▁ : ▁ \" , getInvCount ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.6055325027778664,"rouge_l":0.6953367875647668}
{"id":873,"predictions":["def calSum ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 3 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 3 NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return 3 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 5 NEW_LINE DEDENT sum = 5 NEW_LINE while ( n > 2 ) : NEW_LINE INDENT d = a + b NEW_LINE sum = sum + d NEW_LINE n = d NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 9 NEW_LINE print ( calSum ( n ) ) NEW_LINE"],"references":["def calSum ( n ) : NEW_LINE INDENT a = 3 NEW_LINE b = 0 NEW_LINE c = 2 NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return 3 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 3 NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return 5 NEW_LINE DEDENT sum = 5 NEW_LINE while ( n > 2 ) : NEW_LINE INDENT d = a + b NEW_LINE sum = sum + d NEW_LINE a = b NEW_LINE b = c NEW_LINE c = d NEW_LINE n = n - 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 9 NEW_LINE print ( calSum ( n ) ) NEW_LINE"],"bleu":0.7593274949417088,"rouge_l":0.8093452552639169}
{"id":874,"predictions":["import sys NEW_LINE def steps ( cur , x , n , m ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT return sys . maxsize ; NEW_LINE DEDENT if ( x > 0 ) : NEW_LINE INDENT return - sys . maxsize ; NEW_LINE DEDENT else : NEW_LINE INDENT return abs ( ( cur - 1 ) \/ x ) ; NEW_LINE DEDENT DEDENT def countSteps ( cur , x , y , n , m ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT x = steps ( cur - 1 ) \/\/ x ; NEW_LINE y = steps ( cur - 1 , x , n ) ; NEW_LINE steps = min ( steps , minSteps ( cur , x , y , m ) ) ; NEW_LINE steps += step * x ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 ; NEW_LINE m = 5 ; NEW_LINE x = 1 ; NEW_LINE y = 1 ; NEW_LINE print ( countSteps ( x , y , n , m ) ) ; NEW_LINE DEDENT"],"references":["def steps ( cur , x , n ) : NEW_LINE INDENT if x == 0 : NEW_LINE INDENT return float ( ' inf ' ) NEW_LINE DEDENT elif x > 0 : NEW_LINE INDENT return abs ( ( n - cur ) \/\/ x ) NEW_LINE DEDENT else : NEW_LINE INDENT return abs ( int ( ( cur - 1 ) \/ x ) ) NEW_LINE DEDENT DEDENT def countSteps ( curx , cury , n , m , moves ) : NEW_LINE INDENT count = 0 NEW_LINE k = len ( moves ) NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT x = moves [ i ] [ 0 ] NEW_LINE y = moves [ i ] [ 1 ] NEW_LINE stepct = min ( steps ( curx , x , n ) , steps ( cury , y , m ) ) NEW_LINE count += stepct NEW_LINE curx += stepct * x NEW_LINE cury += stepct * y NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n , m , x , y = 4 , 5 , 1 , 1 NEW_LINE moves = [ [ 1 , 1 ] , [ 1 , 1 ] , [ 0 , - 2 ] ] NEW_LINE print ( countSteps ( x , y , n , m , moves ) ) NEW_LINE DEDENT"],"bleu":0.4560702750259799,"rouge_l":0.6362851593410545}
{"id":875,"predictions":["def SUM ( n , m ) : NEW_LINE INDENT if m == 1 : NEW_LINE INDENT return ( n * ( n + 1 ) \/ 2 ) NEW_LINE DEDENT sum = Sum ( n , m - 1 ) NEW_LINE return ( sum ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE m = 3 NEW_LINE print ( \" Sum ( n , m ) ) NEW_LINE DEDENT"],"references":["def SUM ( n , m ) : NEW_LINE INDENT if ( m == 1 ) : NEW_LINE INDENT return ( n * ( n + 1 ) \/ 2 ) NEW_LINE DEDENT sum = SUM ( n , m - 1 ) NEW_LINE return int ( sum * ( sum + 1 ) \/ 2 ) NEW_LINE DEDENT n = 5 NEW_LINE m = 3 NEW_LINE print ( \" SUM ( \" , n , \" , ▁ \" , m , \" ) : \" , SUM ( n , m ) ) NEW_LINE"],"bleu":0.5550171750437143,"rouge_l":0.7234081372012406}
{"id":876,"predictions":["def printSpecials ( str ) : NEW_LINE INDENT l = len ( str ) NEW_LINE str1 = ' ' NEW_LINE str2 = ' ' NEW_LINE str1 = \" \" NEW_LINE str2 = \" \" NEW_LINE for i in range ( l ) : NEW_LINE INDENT ch = str ( ord ( str [ i ] ) - ord ( ' A ' ) ) NEW_LINE if ( ch != ord ( str [ i ] ) ) : NEW_LINE INDENT temp = str1 + chr ( ord ( str [ i ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT temp = temp NEW_LINE DEDENT DEDENT str1 = \" \" NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( j == 0 ) : NEW_LINE INDENT temp = temp . upper ( ) NEW_LINE str1 = temp . upper ( ) NEW_LINE str1 = temp . lower ( ) NEW_LINE str1 = temp . lower ( ) NEW_LINE if ( j == len ( str1 ) ) : NEW_LINE INDENT temp = temp . lower ( ) NEW_LINE str1 = temp . lower ( ) NEW_LINE DEDENT else : NEW_LINE INDENT temp = temp . lower ( ) NEW_LINE DEDENT temp = \" \" NEW_LINE DEDENT DEDENT DEDENT printSpecials ( str ) NEW_LINE"],"references":["def printInitials ( string : str ) : NEW_LINE INDENT length = len ( string ) NEW_LINE string . strip ( ) NEW_LINE t = \" \" NEW_LINE for i in range ( length ) : NEW_LINE INDENT ch = string [ i ] NEW_LINE if ch != ' ▁ ' : NEW_LINE INDENT t += ch NEW_LINE DEDENT else : NEW_LINE INDENT print ( t [ 0 ] . upper ( ) + \" . ▁ \" , end = \" \" ) NEW_LINE t = \" \" NEW_LINE DEDENT DEDENT temp = \" \" NEW_LINE for j in range ( len ( t ) ) : NEW_LINE INDENT if j == 0 : NEW_LINE INDENT temp += t [ 0 ] . upper ( ) NEW_LINE DEDENT else : NEW_LINE INDENT temp += t [ j ] . lower ( ) NEW_LINE DEDENT DEDENT print ( temp ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" ishita ▁ bhuiya \" NEW_LINE printInitials ( string ) NEW_LINE DEDENT"],"bleu":0.3274531926708847,"rouge_l":0.4933861319403488}
{"id":877,"predictions":["def check ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return ( ( int ) ( st [ 0 ] ) % 8 == 0 ) NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return ( ( st [ 0 ] ) % 8 == 0 ) NEW_LINE DEDENT last_last = ( int ) ( st [ n - 2 ] ) NEW_LINE second_last = ( int ) ( st [ n - 2 ] ) NEW_LINE third_last = ( int ) ( st [ n - 3 ] ) NEW_LINE third_last = ( int ) ( st [ n - 2 ] ) NEW_LINE return ( ( third_last * 100 + second_last ) % 8 == 0 ) NEW_LINE DEDENT st = \"76952\" NEW_LINE if ( check ( st ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def check ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return ( ( int ) ( st [ 0 ] ) % 8 == 0 ) NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return ( ( int ) ( st [ n - 2 ] ) * 10 + ( ( int ) ( str [ n - 1 ] ) % 8 == 0 ) ) NEW_LINE DEDENT last = ( int ) ( st [ n - 1 ] ) NEW_LINE second_last = ( int ) ( st [ n - 2 ] ) NEW_LINE third_last = ( int ) ( st [ n - 3 ] ) NEW_LINE return ( ( third_last * 100 + second_last * 10 + last ) % 8 == 0 ) NEW_LINE DEDENT st = \"76952\" NEW_LINE if ( check ( st ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No ▁ \" ) NEW_LINE DEDENT"],"bleu":0.8470972303150505,"rouge_l":0.8746266109072287}
{"id":878,"predictions":["import math NEW_LINE def checkNonPerfectSquare ( n ) : NEW_LINE INDENT d = math . sqrt ( n ) NEW_LINE if ( d * d == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def largestNonPerfectSquareNumber ( a , n ) : NEW_LINE INDENT maxi = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( checkNonPerfectSquare ( a [ i ] , maxi ) ) : NEW_LINE INDENT maxi = max ( a [ i ] , maxi ) NEW_LINE DEDENT DEDENT return maxi NEW_LINE DEDENT a = [ 16 , 20 , 25 , 2 , 3 , 10 ] NEW_LINE n = len ( a ) NEW_LINE print ( largestNonPerfectPerfectSquareNumber ( a , n ) ) NEW_LINE"],"references":["import math NEW_LINE def check ( n ) : NEW_LINE INDENT d = int ( math . sqrt ( n ) ) NEW_LINE if ( d * d == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def largestNonPerfectSquareNumber ( a , n ) : NEW_LINE INDENT maxi = - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( check ( a [ i ] ) == False ) : NEW_LINE INDENT maxi = max ( a [ i ] , maxi ) NEW_LINE DEDENT DEDENT return maxi NEW_LINE DEDENT a = [ 16 , 20 , 25 , 2 , 3 , 10 ] NEW_LINE n = len ( a ) NEW_LINE print ( largestNonPerfectSquareNumber ( a , n ) ) NEW_LINE"],"bleu":0.8479664486159492,"rouge_l":0.94019728729963}
{"id":879,"predictions":["def findValue ( n ) : NEW_LINE INDENT return ( n * n * n + n ) + n NEW_LINE DEDENT print ( findValue ( 2 ) ) NEW_LINE print ( findValue ( 10 ) ) NEW_LINE"],"references":["def findValueAtX ( n ) : NEW_LINE INDENT return ( n * n * n ) + n NEW_LINE DEDENT print ( findValueAtX ( 10 ) ) NEW_LINE print ( findValueAtX ( 2 ) ) NEW_LINE"],"bleu":0.7373283675453252,"rouge_l":0.8419412288512912}
{"id":880,"predictions":["from math import sqrt NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 5 , int ( sqrt ( n ) ) + 1 , 1 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def isThreeFactorial ( n ) : NEW_LINE INDENT sqrt = sqrt ( n ) NEW_LINE if ( isPrime ( sqrt * sqrt ( n ) ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT num = 9 NEW_LINE if ( isThreeFactorial ( num ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["from math import sqrt NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT k = int ( sqrt ( n ) ) + 1 NEW_LINE for i in range ( 5 , k , 6 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def isThreeDisctFactors ( n ) : NEW_LINE INDENT sq = int ( sqrt ( n ) ) NEW_LINE if ( 1 * sq * sq != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( isPrime ( sq ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT num = 9 NEW_LINE if ( isThreeDisctFactors ( num ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT num = 15 NEW_LINE if ( isThreeDisctFactors ( num ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT num = 12397923568441 NEW_LINE if ( isThreeDisctFactors ( num ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.5532383322616753,"rouge_l":0.7167204648160104}
{"id":881,"predictions":["def maxPartitions ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE max_so_far = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT max_so_far = max ( max_ending_here , arr [ i ] ) NEW_LINE if ( max_so_far == i ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 0 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxPartitions ( arr , n ) ) NEW_LINE"],"references":["def maxPartitions ( arr , n ) : NEW_LINE INDENT ans = 0 ; max_so_far = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT max_so_far = max ( max_so_far , arr [ i ] ) NEW_LINE if ( max_so_far == i ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 0 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxPartitions ( arr , n ) ) NEW_LINE"],"bleu":0.9057451881321318,"rouge_l":0.9651204602660913}
{"id":882,"predictions":["def greaterK ( n , k ) : NEW_LINE INDENT p = [ 0 ] * ( n + 2 ) ; NEW_LINE x = 0 ; NEW_LINE while ( x ) : NEW_LINE INDENT p [ x % k ] = x % k ; NEW_LINE x = n ; NEW_LINE DEDENT for i in range ( len ( p ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( p [ i ] >= 2 ) : NEW_LINE INDENT p [ i ] = 0 ; NEW_LINE DEDENT for j in range ( i + 1 , len ( p ) ) : NEW_LINE INDENT if ( p [ j ] >= 2 ) : NEW_LINE INDENT p [ j ] = 0 ; NEW_LINE p [ j ] += 1 ; NEW_LINE DEDENT DEDENT DEDENT j = i + 1 ; NEW_LINE while ( j < i ) : NEW_LINE INDENT if ( p [ j ] >= 2 ) : NEW_LINE INDENT p [ j ] = 0 ; NEW_LINE DEDENT j += 1 ; NEW_LINE DEDENT DEDENT return 0 ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 29 ; NEW_LINE k = 7 ; NEW_LINE greaterK ( n , k ) ; NEW_LINE print ( ans ( n , k ) ) ; NEW_LINE DEDENT"],"references":["def greaterK ( n , k ) : NEW_LINE INDENT index = 0 NEW_LINE p = [ 0 for i in range ( n + 2 ) ] NEW_LINE x = n NEW_LINE while ( x > 0 ) : NEW_LINE INDENT p [ index ] = x % k NEW_LINE x \/\/= k NEW_LINE index += 1 NEW_LINE DEDENT idx = 0 NEW_LINE for i in range ( 0 , len ( p ) - 1 , 1 ) : NEW_LINE INDENT if ( p [ i ] >= 2 ) : NEW_LINE INDENT p [ i ] = 0 NEW_LINE p [ i + 1 ] += 1 NEW_LINE for j in range ( idx , i , 1 ) : NEW_LINE INDENT p [ j ] = 0 NEW_LINE DEDENT idx = i + 1 NEW_LINE DEDENT if ( p [ i ] == k ) : NEW_LINE INDENT p [ i ] = 0 NEW_LINE p [ i + 1 ] += 1 NEW_LINE DEDENT DEDENT j = len ( p ) - 1 NEW_LINE if ( p [ j ] >= 2 ) : NEW_LINE INDENT p [ index ] = 1 NEW_LINE index += 1 NEW_LINE DEDENT ans = 0 NEW_LINE i = len ( p ) - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT ans = ans * k + p [ i ] NEW_LINE i -= 1 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 29 NEW_LINE k = 7 NEW_LINE greaterK ( n , k ) NEW_LINE DEDENT"],"bleu":0.47676387783525176,"rouge_l":0.644298273353994}
{"id":883,"predictions":["def longestPrefixSuffix ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE lps = [ 0 for i in range ( n ) ] NEW_LINE lps [ 0 ] = 0 NEW_LINE lps [ 0 ] = 0 NEW_LINE i = 1 NEW_LINE while i < n : NEW_LINE INDENT if ( s [ i ] == s [ lps [ i ] ) : NEW_LINE INDENT lps [ i ] = lps [ lps [ i ] ] NEW_LINE lps [ i ] = lps [ i ] NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT lps [ i ] = 0 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT res = lps [ n - 1 ] NEW_LINE return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" abcab \" NEW_LINE print ( longestPrefixSuffix ( s ) ) NEW_LINE DEDENT"],"references":["def longestPrefixSuffix ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE lps = [ 0 ] * n NEW_LINE l = 0 NEW_LINE i = 1 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( s [ i ] == s [ l ] ) : NEW_LINE INDENT l = l + 1 NEW_LINE lps [ i ] = l NEW_LINE i = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( l != 0 ) : NEW_LINE INDENT l = lps [ l - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lps [ i ] = 0 NEW_LINE i = i + 1 NEW_LINE DEDENT DEDENT DEDENT res = lps [ n - 1 ] NEW_LINE if ( res > n \/ 2 ) : NEW_LINE INDENT return n \/\/ 2 NEW_LINE DEDENT else : NEW_LINE INDENT return res NEW_LINE DEDENT DEDENT s = \" abcab \" NEW_LINE print ( longestPrefixSuffix ( s ) ) NEW_LINE"],"bleu":0.5454368059827139,"rouge_l":0.658494753833737}
{"id":884,"predictions":["def printBracketNumber ( vec , n ) : NEW_LINE INDENT left_b = 1 NEW_LINE right_b = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == ' ( ' ) : NEW_LINE INDENT left_b = 0 NEW_LINE right_b += 1 NEW_LINE DEDENT else : NEW_LINE INDENT left_b += 1 NEW_LINE DEDENT DEDENT if ( arr [ i ] == ' ) ' : NEW_LINE INDENT right_b += 1 NEW_LINE left_b += 1 NEW_LINE DEDENT elif ( arr [ i ] == ' ) ' ) ' : NEW_LINE INDENT left_b += 1 NEW_LINE DEDENT elif ( arr [ i ] == ' ) ' ) ' : NEW_LINE INDENT right_b += 1 NEW_LINE DEDENT else : NEW_LINE INDENT left_b = 0 NEW_LINE DEDENT DEDENT if ( arr [ i ] == ' ( ' ) ' ) : NEW_LINE INDENT print ( ' ( ' , ▁ ' , end = ' ) NEW_LINE DEDENT return - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT exp = [ ] NEW_LINE exp = [ ] NEW_LINE n = len ( exp ) NEW_LINE printBracketNumber ( exp , n ) NEW_LINE DEDENT"],"references":["def printBracketNumber ( exp , n ) : NEW_LINE INDENT left_bnum = 1 NEW_LINE right_bnum = list ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if exp [ i ] == ' ( ' : NEW_LINE INDENT print ( left_bnum , end = \" ▁ \" ) NEW_LINE right_bnum . append ( left_bnum ) NEW_LINE left_bnum += 1 NEW_LINE DEDENT elif exp [ i ] == ' ) ' : NEW_LINE INDENT print ( right_bnum [ - 1 ] , end = \" ▁ \" ) NEW_LINE right_bnum . pop ( ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT exp = \" ( a + ( b * c ) ) + ( d \/ e ) \" NEW_LINE n = len ( exp ) NEW_LINE printBracketNumber ( exp , n ) NEW_LINE DEDENT"],"bleu":0.34765143162636025,"rouge_l":0.5498624157889743}
{"id":885,"predictions":["N = 10 NEW_LINE def oneDistinct ( N ) : NEW_LINE INDENT primeAll = [ True for i in range ( N + 1 ) ] NEW_LINE primeAll = [ True ] * ( N + 1 ) NEW_LINE p = 2 NEW_LINE while p * p <= N : NEW_LINE INDENT if primeAll [ p ] == False : NEW_LINE INDENT for i in range ( p * p , N + 1 , p ) : NEW_LINE INDENT primeAll [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT for p in range ( 2 , N + 1 ) : NEW_LINE INDENT if primeAll [ p ] == False : NEW_LINE INDENT for i in range ( 2 * p , N + 1 , p ) : NEW_LINE INDENT primeAll [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( 4 * p ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["N = 1000001 ; NEW_LINE fourDiv = [ False ] * ( N + 1 ) ; NEW_LINE def fourDistinctFactors ( ) : NEW_LINE INDENT primeAll = [ True ] * ( N + 1 ) ; NEW_LINE p = 2 ; NEW_LINE while ( p * p <= N ) : NEW_LINE INDENT if ( primeAll [ p ] == True ) : NEW_LINE INDENT i = p * 2 ; NEW_LINE while ( i <= N ) : NEW_LINE INDENT primeAll [ i ] = False ; NEW_LINE i += p ; NEW_LINE DEDENT DEDENT p += 1 ; NEW_LINE DEDENT prime = [ ] ; NEW_LINE for p in range ( 2 , N + 1 ) : NEW_LINE INDENT if ( primeAll [ p ] ) : NEW_LINE INDENT prime . append ( p ) ; NEW_LINE DEDENT DEDENT for i in range ( len ( prime ) ) : NEW_LINE INDENT p = prime [ i ] ; NEW_LINE if ( 1 * p * p * p <= N ) : NEW_LINE INDENT fourDiv [ p * p * p ] = True ; NEW_LINE DEDENT for j in range ( i + 1 , len ( prime ) ) : NEW_LINE INDENT q = prime [ j ] ; NEW_LINE if ( 1 * p * q > N ) : NEW_LINE INDENT break ; NEW_LINE DEDENT fourDiv [ p * q ] = True ; NEW_LINE DEDENT DEDENT DEDENT fourDistinctFactors ( ) ; NEW_LINE num = 10 ; NEW_LINE if ( fourDiv [ num ] ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT num = 12 ; NEW_LINE if ( fourDiv [ num ] ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT"],"bleu":0.25190562213684614,"rouge_l":0.5254709965294992}
{"id":886,"predictions":["N = 3 NEW_LINE def leapRatarMatrix ( mat , k ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT mat [ i ] [ j ] = mat [ i ] [ j ] * k NEW_LINE DEDENT DEDENT DEDENT mat = [ [ [ 1 , 2 , 3 ] ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE k = 4 NEW_LINE footarMatrix ( mat , k ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT mat [ i ] [ j ] = mat [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( \" \\n \" ) NEW_LINE DEDENT"],"references":["N = 3 NEW_LINE def scalarProductMat ( mat , k ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT mat [ i ] [ j ] = mat [ i ] [ j ] * k NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT mat = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE k = 4 NEW_LINE scalarProductMat ( mat , k ) NEW_LINE print ( \" Scalar ▁ Product ▁ Matrix ▁ is ▁ : ▁ \" ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT"],"bleu":0.7332563301530216,"rouge_l":0.8046882414349436}
{"id":887,"predictions":["def reverse ( str ) : NEW_LINE INDENT str = str + \" geeksforgeeks \" ; NEW_LINE str = str [ : len ( str ) ] ; NEW_LINE str = \" geeksforgeeks \" ; NEW_LINE print ( str , str , sep = \" \" ) ; NEW_LINE DEDENT"],"references":["str = \" geeksforgeeks \" ; NEW_LINE str = \" \" . join ( reversed ( str ) ) NEW_LINE print ( str ) ; NEW_LINE"],"bleu":0.31285238669841886,"rouge_l":0.5301921317474839}
{"id":888,"predictions":["def countDistinct ( arr , n ) : NEW_LINE INDENT hs = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hs . add ( arr [ i ] ) NEW_LINE DEDENT return len ( hs ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 6 , 10 , 5 , 4 , 6 , 4 , 10 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countDistinct ( arr , n ) ) NEW_LINE DEDENT"],"references":["def countDistinct ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] not in s ) : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT arr = [ 6 , 10 , 5 , 4 , 9 , 120 , 4 , 6 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countDistinct ( arr , n ) ) NEW_LINE"],"bleu":0.6279505084455567,"rouge_l":0.7263105672234166}
{"id":889,"predictions":["def toggleCase ( a ) : NEW_LINE INDENT for i in range ( 0 , len ( a ) ) : NEW_LINE INDENT a ^= 32 NEW_LINE DEDENT return a NEW_LINE DEDENT def toggleCase ( str ) : NEW_LINE INDENT res = False NEW_LINE for i in range ( 0 , len ( str ) , 1 ) : NEW_LINE INDENT if ( a [ i ] ^ 32 ) : NEW_LINE INDENT res = res + 32 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT str = toggleCase ( str ) NEW_LINE str = toggleCase ( str ) NEW_LINE print ( \" Last ▁ String : ▁ \" , res ) NEW_LINE str = toggleCase ( str ) NEW_LINE str1 = toggleCase ( str ) NEW_LINE str1 = toggleCase ( str1 ) NEW_LINE str1 = toggleCase ( str1 ) NEW_LINE print ( \" : ▁ \" , str1 ) NEW_LINE str1 = toggleCase ( str1 ) NEW_LINE str1 = str1 NEW_LINE print ( \" \\n \" , res1 ) NEW_LINE"],"references":["x = 32 ; NEW_LINE def toggleCase ( a ) : NEW_LINE INDENT for i in range ( len ( a ) ) : NEW_LINE INDENT a = a [ : i ] + chr ( ord ( a [ i ] ) ^ 32 ) + a [ i + 1 : ] ; NEW_LINE DEDENT return a ; NEW_LINE DEDENT str = \" CheRrY \" ; NEW_LINE print ( \" Toggle ▁ case : ▁ \" , end = \" \" ) ; NEW_LINE str = toggleCase ( str ) ; NEW_LINE print ( str ) ; NEW_LINE print ( \" Original ▁ string : ▁ \" , end = \" \" ) ; NEW_LINE str = toggleCase ( str ) ; NEW_LINE print ( str ) ; NEW_LINE"],"bleu":0.329083881201923,"rouge_l":0.5578853446352888}
{"id":890,"predictions":["MAX = 10000 ; NEW_LINE arr = [ ] ; NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime = [ True ] * MAX ; NEW_LINE p = 2 ; NEW_LINE while ( p * p < MAX ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT p += 1 ; NEW_LINE DEDENT for p in range ( 2 , MAX ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT arr . append ( p ) ; NEW_LINE DEDENT DEDENT DEDENT if ( product + 1 == n or product == n ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT SieveOfEratosthenes ( ) ; NEW_LINE n = 31 ; NEW_LINE if ( prime [ n ] ) : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE DEDENT DEDENT"],"references":["from math import sqrt NEW_LINE MAX = 100000 NEW_LINE prime = [ True ] * MAX NEW_LINE arr = [ ] NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT for p in range ( 2 , int ( sqrt ( MAX ) ) + 1 ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for p in range ( 2 , MAX ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT arr . append ( p ) NEW_LINE DEDENT DEDENT DEDENT def isPrimorialPrime ( n ) : NEW_LINE INDENT if not prime [ n ] : NEW_LINE INDENT return False NEW_LINE DEDENT product , i = 1 , 0 NEW_LINE while product < n : NEW_LINE INDENT product *= arr [ i ] NEW_LINE if product + 1 == n or product - 1 == n : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE n = 31 NEW_LINE if ( isPrimorialPrime ( n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.5599760595610982,"rouge_l":0.7109140218427032}
{"id":891,"predictions":["def countNumbers ( X , Y , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( i % X == 0 and ( i % Y != 0 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT X , Y , N = 2 , 10 NEW_LINE print ( countNumbers ( X , Y , N ) ) NEW_LINE DEDENT"],"references":["def countNumbers ( X , Y , N ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( ( i % X == 0 ) and ( i % Y != 0 ) ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT X = 2 ; NEW_LINE Y = 3 ; NEW_LINE N = 10 ; NEW_LINE print ( countNumbers ( X , Y , N ) ) ; NEW_LINE"],"bleu":0.6796421187596805,"rouge_l":0.825918762088975}
{"id":892,"predictions":["def countSubseq ( arr , n ) : NEW_LINE INDENT um = { i : 1 for i in arr } NEW_LINE count = 1 NEW_LINE for i in arr : NEW_LINE INDENT if ( i not in um ) : NEW_LINE INDENT a = um . get ( i , 0 ) + 1 NEW_LINE DEDENT else : NEW_LINE INDENT um [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 4 , 7 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Count ▁ = \" , countSubseq ( arr , n ) ) NEW_LINE DEDENT"],"references":["def countSubseq ( arr , n ) : NEW_LINE INDENT um = { i : 0 for i in range ( 8 ) } NEW_LINE count = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT um [ arr [ i ] ] += 1 NEW_LINE DEDENT for key , values in um . items ( ) : NEW_LINE INDENT if ( values > 0 ) : NEW_LINE INDENT count *= values NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 7 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Count ▁ = \" , countSubseq ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.6926933696164235,"rouge_l":0.7522247648105773}
{"id":893,"predictions":["import math NEW_LINE def check ( a , b ) : NEW_LINE INDENT c = 0 NEW_LINE while ( a != 0 ) : NEW_LINE INDENT c = c + a % 10 NEW_LINE a = a \/\/ 10 NEW_LINE DEDENT return ( c == b ) NEW_LINE DEDENT def root ( n ) : NEW_LINE INDENT found = False NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT s = i * ( math . sqrt ( s ) ) NEW_LINE if ( ( sqrt ( s ) ) == int ( sqrt ( s ) ) and check ( s - i ) ) : NEW_LINE INDENT found = True NEW_LINE DEDENT DEDENT return ( m ) NEW_LINE DEDENT def root ( n ) : NEW_LINE INDENT found = False NEW_LINE mx = 0 NEW_LINE for i in range ( 0 , 90 ) : NEW_LINE INDENT s = ( i * i + 4 * n ) \/ 2 NEW_LINE if ( check ( s ) ) : NEW_LINE INDENT found = True NEW_LINE DEDENT DEDENT if ( found ) : NEW_LINE INDENT return mx NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 110 NEW_LINE print ( root ( n ) ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def check ( a , b ) : NEW_LINE INDENT c = 0 ; NEW_LINE while ( a != 0 ) : NEW_LINE INDENT c = c + a % 10 ; NEW_LINE a = int ( a \/ 10 ) ; NEW_LINE DEDENT return True if ( c == b ) else False ; NEW_LINE DEDENT def root ( n ) : NEW_LINE INDENT found = False ; NEW_LINE mx = 1000000000000000001 ; NEW_LINE for i in range ( 91 ) : NEW_LINE INDENT s = i * i + 4 * n ; NEW_LINE sq = int ( math . sqrt ( s ) ) ; NEW_LINE if ( sq * sq == s and check ( int ( ( sq - i ) \/ 2 ) , i ) ) : NEW_LINE INDENT found = True ; NEW_LINE mx = min ( mx , int ( ( sq - i ) \/ 2 ) ) ; NEW_LINE DEDENT DEDENT if ( found ) : NEW_LINE INDENT return mx ; NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT DEDENT n = 110 ; NEW_LINE print ( root ( n ) ) ; NEW_LINE"],"bleu":0.5054542880981,"rouge_l":0.6906364749082007}
{"id":894,"predictions":["def Fraction ( n , d ) : NEW_LINE INDENT num = n NEW_LINE den = 1 NEW_LINE den = den * d NEW_LINE d = abs ( num ) NEW_LINE return int ( den * d ) NEW_LINE DEDENT def Fraction ( first , second ) : NEW_LINE INDENT a = first NEW_LINE b = first NEW_LINE c = second NEW_LINE d = second NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT Fraction = 3 NEW_LINE Fraction = 0 NEW_LINE DEDENT"],"references":["def maxFraction ( first , sec ) : NEW_LINE INDENT a = first [ 0 ] ; b = first [ 1 ] NEW_LINE c = sec [ 0 ] ; d = sec [ 1 ] NEW_LINE Y = a * d - b * c NEW_LINE return first if Y else sec NEW_LINE DEDENT first = ( 3 , 2 ) NEW_LINE sec = ( 3 , 4 ) NEW_LINE res = maxFraction ( first , sec ) NEW_LINE print ( str ( res [ 0 ] ) + \" \/ \" + str ( res [ 1 ] ) ) NEW_LINE"],"bleu":0.13659545190574415,"rouge_l":0.31680348467079905}
{"id":895,"predictions":["defPermutation ( n , k ) : NEW_LINE INDENT p = [ 0 ] * ( n + 1 ) ; NEW_LINE for i in range ( 1 , n - k + 1 ) : NEW_LINE INDENT p [ i + 1 ] = i ; NEW_LINE p [ i ] = n - k ; NEW_LINE DEDENT for i in range ( 1 , n - k + 1 ) : NEW_LINE INDENT p [ i ] = i ; NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( p [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 ; NEW_LINE k = 2 ; NEW_LINEPermutation ( n , k ) ; NEW_LINE DEDENT"],"references":["def Permutation ( n , k ) : NEW_LINE INDENT p = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT p [ i ] = i NEW_LINE DEDENT for i in range ( 1 , n - k ) : NEW_LINE INDENT p [ i + 1 ] = i NEW_LINE DEDENT p [ 1 ] = n - k NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( p [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE k = 2 NEW_LINE Permutation ( n , k ) NEW_LINE DEDENT"],"bleu":0.7090596334303501,"rouge_l":0.8247053385717589}
{"id":896,"predictions":["import math NEW_LINE def reverse ( x ) : NEW_LINE INDENT rev = 0 NEW_LINE while ( x > 0 ) : NEW_LINE INDENT rev = ( rev * 10 ) + x % 10 NEW_LINE x = x \/\/ 10 NEW_LINE DEDENT return rev NEW_LINE DEDENT def printEmipp ( n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) NEW_LINE p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT print ( p , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 100 NEW_LINE printAlipp ( n ) NEW_LINE DEDENT"],"references":["def reverse ( x ) : NEW_LINE INDENT rev = 0 ; NEW_LINE while ( x > 0 ) : NEW_LINE INDENT rev = ( rev * 10 ) + x % 10 ; NEW_LINE x = int ( x \/ 10 ) ; NEW_LINE DEDENT return rev ; NEW_LINE DEDENT def printEmirp ( n ) : NEW_LINE INDENT prime = [ 1 ] * ( n + 1 ) ; NEW_LINE p = 2 ; NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == 1 ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = 0 ; NEW_LINE DEDENT DEDENT p += 1 ; NEW_LINE DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] == 1 ) : NEW_LINE INDENT rev = reverse ( p ) ; NEW_LINE if ( p != rev and rev <= n and prime [ rev ] == 1 ) : NEW_LINE INDENT print ( p , rev , end = \" ▁ \" ) ; NEW_LINE prime [ rev ] = 0 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT n = 100 ; NEW_LINE printEmirp ( n ) ; NEW_LINE"],"bleu":0.6036236275612683,"rouge_l":0.7830919765166341}
{"id":897,"predictions":["def largest ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE arr . sort ( ) NEW_LINE return arr [ n - 1 ] NEW_LINE DEDENT arr = [ 10 , 324 , 45 , 908999999 ] NEW_LINE n = len ( arr ) NEW_LINE print ( largest ( arr , n ) ) NEW_LINE"],"references":["def largest ( arr , n ) : NEW_LINE INDENT return max ( arr ) NEW_LINE DEDENT arr = [ 10 , 324 , 45 , 90 , 9808 ] NEW_LINE n = len ( arr ) NEW_LINE print ( largest ( arr , n ) ) NEW_LINE"],"bleu":0.6294098182050137,"rouge_l":0.8125774473358116}
{"id":898,"predictions":["class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def maxLevelProduct ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT result = root . data NEW_LINE q = [ ] NEW_LINE while ( len ( q ) != 0 ) : NEW_LINE INDENT count = len ( q ) NEW_LINE while ( count != 0 ) : NEW_LINE INDENT temp = q . pop ( 0 ) NEW_LINE if ( temp . left != None ) : NEW_LINE INDENT q . append ( temp . data ) NEW_LINE if ( temp . left != None ) : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE if ( temp . left != None ) : NEW_LINE INDENT q . append ( temp . right ) NEW_LINE DEDENT if ( temp . right != None ) : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE DEDENT if ( temp . right != None ) : NEW_LINE INDENT q . append ( temp . data ) NEW_LINE DEDENT DEDENT result = max ( result , result ) NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 1 ) NEW_LINE root . left = newNode ( 2 ) NEW_LINE root . right = newNode ( 3 ) NEW_LINE root . left . left = newNode ( 4 ) NEW_LINE root . left . left = newNode ( 5 ) NEW_LINE root . left . right = newNode ( 3 ) NEW_LINE root . right . left = newNode ( 4 ) NEW_LINE root . left . right . left = newNode ( 4 ) NEW_LINE root . right . left . left . left = newNode ( 6 ) NEW_LINE root . right . right = newNode ( 7 ) NEW_LINE result = maxLevel ( root ) NEW_LINE print ( \" Maximum ▁ level ▁ product ▁ product ▁ is \" , result )"],"references":["class newNode : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . data = key NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def maxLevelProduct ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT result = root . data NEW_LINE q = [ ] NEW_LINE q . append ( root ) NEW_LINE while ( len ( q ) ) : NEW_LINE INDENT count = len ( q ) NEW_LINE product = 1 NEW_LINE while ( count ) : NEW_LINE INDENT count -= 1 NEW_LINE temp = q [ 0 ] NEW_LINE q . pop ( 0 ) NEW_LINE product = product * temp . data NEW_LINE if ( temp . left != None ) : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE DEDENT if ( temp . right != None ) : NEW_LINE INDENT q . append ( temp . right ) NEW_LINE DEDENT DEDENT result = max ( product , result ) NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 1 ) NEW_LINE root . left = newNode ( 2 ) NEW_LINE root . right = newNode ( 3 ) NEW_LINE root . left . left = newNode ( 4 ) NEW_LINE root . left . right = newNode ( 5 ) NEW_LINE root . right . right = newNode ( 8 ) NEW_LINE root . right . right . left = newNode ( 6 ) NEW_LINE root . right . right . right = newNode ( 7 ) NEW_LINE print ( \" Maximum ▁ level ▁ product ▁ is \" , maxLevelProduct ( root ) ) NEW_LINE DEDENT"],"bleu":0.6881480156017449,"rouge_l":0.803753244160511}
{"id":899,"predictions":["def fact ( fact ( n ) ) : NEW_LINE INDENT fact = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fact = fact * i NEW_LINE DEDENT return fact ; NEW_LINE DEDENT def countStrings ( string , n ) : NEW_LINE INDENT distinct_char = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT distinct_char = fact ( ord ( string [ i ] ) ] ) NEW_LINE DEDENT return fact ( distinct_char ) NEW_LINE DEDENT string = \" geeksforgeeks \" NEW_LINE n = len ( string ) NEW_LINE print ( countStrings ( string , n ) ) NEW_LINE"],"references":["def fact ( n ) : NEW_LINE INDENT fact = 1 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fact *= i ; NEW_LINE DEDENT return fact ; NEW_LINE DEDENT def countStrings ( string , n ) : NEW_LINE INDENT distinct_char = set ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT distinct_char . add ( string [ i ] ) ; NEW_LINE DEDENT return fact ( len ( distinct_char ) ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" geeksforgeeks \" ; NEW_LINE n = len ( string ) ; NEW_LINE print ( countStrings ( string , n ) ) ; NEW_LINE DEDENT"],"bleu":0.6416908588354264,"rouge_l":0.8234341252699786}
{"id":900,"predictions":["def printMaxValair ( v , n ) : NEW_LINE INDENT v . sort ( ) NEW_LINE if ( n % 2 == 1 ) : NEW_LINE INDENT first_max = n \/\/ 2 NEW_LINE DEDENT else : NEW_LINE INDENT first_max = n \/\/ 2 + 1 NEW_LINE second_max = - 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( v [ i ] > first_max ) : NEW_LINE INDENT first_max = i NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT second_max = i NEW_LINE DEDENT i = 0 NEW_LINE while i < n - 1 : NEW_LINE INDENT if ( v [ i ] > second_max ) : NEW_LINE INDENT first_max = i NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT first_max = i NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT first_max = i NEW_LINE DEDENT DEDENT i = 0 NEW_LINE while ( i < n - 1 ) : NEW_LINE INDENT if ( v [ i ] > second_max ) : NEW_LINE INDENT second_max = i NEW_LINE break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT second_max = v [ i ] NEW_LINE DEDENT i = n - 1 NEW_LINE DEDENT DEDENT def printMaxValair ( v , n ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT diff = abs ( v [ i ] ) NEW_LINE if ( diff < abs ( v [ i ] - max ) ) : NEW_LINE INDENT res = diff NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 1 , 2 , 3 , 6 ] NEW_LINE n = len ( v ) NEW_LINE printMaxVal ( v , n ) NEW_LINE DEDENT"],"references":["def printMaxValPair ( v , n ) : NEW_LINE INDENT v . sort ( ) NEW_LINE N = v [ n - 1 ] NEW_LINE if N % 2 == 1 : NEW_LINE INDENT first_maxima = N \/\/ 2 NEW_LINE second_maxima = first_maxima + 1 NEW_LINE ans1 , ans2 = 3 * ( 10 ** 18 ) , 3 * ( 10 ** 18 ) NEW_LINE from_left , from_right = - 1 , - 1 NEW_LINE _from = - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if v [ i ] > first_maxima : NEW_LINE INDENT _from = i NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT diff = first_maxima - v [ i ] NEW_LINE if diff < ans1 : NEW_LINE INDENT ans1 = diff NEW_LINE from_left = v [ i ] NEW_LINE DEDENT DEDENT DEDENT from_right = v [ _from ] NEW_LINE diff1 = first_maxima - from_left NEW_LINE diff2 = from_right - second_maxima NEW_LINE if diff1 < diff2 : NEW_LINE INDENT print ( N , from_left ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( N , from_right ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT maxima = N \/\/ 2 NEW_LINE ans1 = 3 * ( 10 ** 18 ) NEW_LINE R = - 1 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT diff = abs ( v [ i ] - maxima ) NEW_LINE if diff < ans1 : NEW_LINE INDENT ans1 = diff NEW_LINE R = v [ i ] NEW_LINE DEDENT DEDENT print ( N , R ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT v = [ 1 , 1 , 2 , 3 , 6 , 1 ] NEW_LINE n = len ( v ) NEW_LINE printMaxValPair ( v , n ) NEW_LINE DEDENT"],"bleu":0.4540250798302705,"rouge_l":0.5865384615384616}
{"id":901,"predictions":["import math NEW_LINE def triangle ( n ) : NEW_LINE INDENT k = 2 * n - 2 NEW_LINE ch = 1 NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT for j in range ( 0 , k ) : NEW_LINE INDENT print ( ch , end = \" ▁ \" ) NEW_LINE k = k - 1 NEW_LINE for j in range ( 0 , i + 1 ) : NEW_LINE INDENT print ( ch , end = \" ▁ \" ) NEW_LINE DEDENT k = k - 1 NEW_LINE for j in range ( 0 , i + 1 ) : NEW_LINE INDENT print ( ch , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def maxHeight ( n ) : NEW_LINE INDENT return ( int ( math . sqrt ( 1 + 8 ) ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 9 NEW_LINE triangle ( n ) NEW_LINE DEDENT"],"references":["from math import sqrt NEW_LINE def triangle ( n ) : NEW_LINE INDENT k = 2 * n - 2 ; NEW_LINE ch = 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( k ) : NEW_LINE INDENT print ( \" ▁ \" , end = \" \" ) ; NEW_LINE DEDENT k = k - 1 ; NEW_LINE for j in range ( i + 1 ) : NEW_LINE INDENT print ( ch , end = \" ▁ \" ) ; NEW_LINE ch += 1 ; NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT def maxHeight ( n ) : NEW_LINE INDENT ans = ( sqrt ( 1 + 8.0 * n ) - 1 ) \/\/ 2 ; NEW_LINE return int ( ans ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 9 ; NEW_LINE triangle ( maxHeight ( N ) ) ; NEW_LINE DEDENT"],"bleu":0.5609069977284383,"rouge_l":0.7420202413390424}
{"id":902,"predictions":["def longestInteger ( string , l ) : NEW_LINE INDENT count = 0 NEW_LINE max_pos , pre = 0 , 0 NEW_LINE pre_pos = - 1 NEW_LINE for i in range ( l ) : NEW_LINE INDENT pre_pos = pre_pos NEW_LINE pre_pos = len ( string ) NEW_LINE while ( pre != l ) : NEW_LINE INDENT pre_pos = pre_pos NEW_LINE count += 1 NEW_LINE DEDENT if ( ord ( string [ i ] ) >= ord ( '0' ) ) : NEW_LINE INDENT pos = i NEW_LINE while ( ord ( string [ i ] ) >= ord ( '0' ) and ord ( string [ i ] ) <= ord ( '0' ) ) : NEW_LINE INDENT pos = count + 1 NEW_LINE DEDENT else : NEW_LINE INDENT pos = pre_pos + 1 NEW_LINE l = pre_pos + 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( count > max_pos ) : NEW_LINE INDENT max_pos = pre_pos + 1 NEW_LINE DEDENT else : NEW_LINE INDENT pos = pre_pos + 1 NEW_LINE DEDENT DEDENT DEDENT return max_val NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" geeksforGeeksforgeeks \" NEW_LINE l = len ( string ) NEW_LINE print ( longestInteger ( string , l ) ) NEW_LINE DEDENT"],"references":["def longestInteger ( s , length ) : NEW_LINE INDENT count = 0 NEW_LINE maximum = 0 NEW_LINE pos = - 1 NEW_LINE l = 0 NEW_LINE for i in range ( length ) : NEW_LINE INDENT pre_pos = pos NEW_LINE pre_len = l NEW_LINE count = 0 NEW_LINE l = 0 NEW_LINE if ( s [ i ] . isdecimal ( ) ) : NEW_LINE INDENT pos = i NEW_LINE DEDENT while ( s [ i ] . isdecimal ( ) ) : NEW_LINE INDENT count += 1 NEW_LINE i += 1 NEW_LINE l += 1 NEW_LINE DEDENT if ( count > maximum ) : NEW_LINE INDENT maximum = count NEW_LINE DEDENT else : NEW_LINE INDENT pos = pre_pos NEW_LINE l = pre_len NEW_LINE DEDENT DEDENT return ( s [ pos : pos + l ] ) NEW_LINE DEDENT s = \" geeks100for1234geeks \" NEW_LINE length = len ( s ) NEW_LINE print ( longestInteger ( s , length ) ) NEW_LINE"],"bleu":0.33056377923057567,"rouge_l":0.6090298639335571}
{"id":903,"predictions":["def findSum ( n , a , b ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i % a == 0 or i % b == 0 ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n , a , b = 2 , 3 NEW_LINE print ( findSum ( n , a , b ) ) NEW_LINE DEDENT"],"references":["def findSum ( n , a , b ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( i % a == 0 or i % b == 0 ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE a = 3 NEW_LINE b = 5 NEW_LINE print ( findSum ( n , a , b ) ) NEW_LINE DEDENT"],"bleu":0.7768151204699627,"rouge_l":0.8860938883968114}
{"id":904,"predictions":["def seriesSum ( n ) : NEW_LINE INDENT return int ( ( n * ( n + 1 ) * ( n + 2 ) ) \/ 6 ) NEW_LINE DEDENT n = 4 NEW_LINE print ( seriesSum ( n ) ) NEW_LINE"],"references":["def seriesSum ( n ) : NEW_LINE INDENT return int ( ( n * ( n + 1 ) * ( n + 2 ) ) \/ 6 ) NEW_LINE DEDENT n = 4 NEW_LINE print ( seriesSum ( n ) ) NEW_LINE"],"bleu":1.0,"rouge_l":1.0}
{"id":905,"predictions":["def find_count ( e ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( e ) - 1 , - 1 ) : NEW_LINE INDENT p = e NEW_LINE c = 0 NEW_LINE for j in range ( len ( e ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( e [ j ] != p [ j ] ) : NEW_LINE INDENT e = e [ j ] NEW_LINE break NEW_LINE DEDENT DEDENT j = 0 NEW_LINE while ( j >= 0 ) : NEW_LINE INDENT if ( e == p [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( k == p [ k ] ) : NEW_LINE INDENT c += 1 NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( count , c ) NEW_LINE DEDENT def solve ( e ) : NEW_LINE INDENT count = 0 NEW_LINE e = 0 NEW_LINE for i in range ( len ( e ) ) : NEW_LINE INDENT if ( e [ i ] != p [ - 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE break NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT e = 10 NEW_LINE solve ( e ) NEW_LINE DEDENT"],"references":["def find_count ( ele ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( ele ) ) : NEW_LINE INDENT p = [ ] NEW_LINE c = 0 NEW_LINE j = len ( ele ) - 1 NEW_LINE while j >= ( len ( ele ) - 1 - i ) and j >= 0 : NEW_LINE INDENT p . append ( ele [ j ] ) NEW_LINE j -= 1 NEW_LINE DEDENT j = len ( ele ) - 1 NEW_LINE k = 0 NEW_LINE while j >= 0 : NEW_LINE INDENT if ele [ j ] != p [ k ] : NEW_LINE INDENT break NEW_LINE DEDENT j -= 1 NEW_LINE k += 1 NEW_LINE if k == len ( p ) : NEW_LINE INDENT c += 1 NEW_LINE k = 0 NEW_LINE DEDENT DEDENT count = max ( count , c ) NEW_LINE DEDENT return count NEW_LINE DEDENT def solve ( n ) : NEW_LINE INDENT count = 1 NEW_LINE ele = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( count , end = \" ▁ \" ) NEW_LINE ele . append ( count ) NEW_LINE count = find_count ( ele ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 10 NEW_LINE solve ( n ) NEW_LINE DEDENT"],"bleu":0.45212851409295524,"rouge_l":0.6224933989866553}
{"id":906,"predictions":["import sys NEW_LINE def getMinimum ( ar , k ) : NEW_LINE INDENT n = len ( ar ) NEW_LINE dp = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n ) ] NEW_LINE dp [ 0 ] [ 0 ] = 0 NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT maxGroups = min ( k , i + 1 ) NEW_LINE for j in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = sys . maxsize NEW_LINE if ( j == 0 ) : NEW_LINE INDENT freq [ i ] += 1 NEW_LINE DEDENT if ( ( j == 1 ) : NEW_LINE INDENT freq [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ i ] [ j ] = ( i + 1 ) NEW_LINE DEDENT DEDENT DEDENT dp [ 0 ] [ k ] = 10 ** 9 NEW_LINE freq [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT DEDENT return dp [ n - 1 ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT k = 3 NEW_LINE arr = [ 3 , 1 , 3 , 3 , 2 , 1 , 8 , 5 ] NEW_LINE print ( getMinimum ( arr , k ) ) NEW_LINE DEDENT"],"references":["def getMinimumOps ( ar , k ) : NEW_LINE INDENT n = len ( ar ) NEW_LINE dp = [ [ 0 for i in range ( k + 1 ) ] for i in range ( n ) ] NEW_LINE dp [ 0 ] [ 1 ] = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT maxGroups = min ( k , i + 1 ) NEW_LINE for j in range ( 1 , maxGroups + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = 10 ** 9 NEW_LINE if ( j == 1 ) : NEW_LINE INDENT freq1 = dict ( ) NEW_LINE freqOfMode = 0 NEW_LINE for it in range ( 0 , i + 1 ) : NEW_LINE INDENT freq1 [ ar [ it ] ] = freq1 . get ( ar [ it ] , 0 ) + 1 NEW_LINE newElementFreq = freq1 [ ar [ it ] ] NEW_LINE if ( newElementFreq > freqOfMode ) : NEW_LINE INDENT freqOfMode = newElementFreq NEW_LINE DEDENT DEDENT dp [ i ] [ 1 ] = ( i + 1 ) - freqOfMode NEW_LINE DEDENT else : NEW_LINE INDENT freq = dict ( ) NEW_LINE freqOfMode = 0 NEW_LINE for it in range ( i , j - 2 , - 1 ) : NEW_LINE INDENT freq [ ar [ it ] ] = freq . get ( ar [ it ] , 0 ) + 1 NEW_LINE newElementFreq = freq [ ar [ it ] ] NEW_LINE if ( newElementFreq > freqOfMode ) : NEW_LINE INDENT freqOfMode = newElementFreq NEW_LINE DEDENT elementsToChange = i - it + 1 NEW_LINE elementsToChange -= freqOfMode NEW_LINE dp [ i ] [ j ] = min ( dp [ it - 1 ] [ j - 1 ] + elementsToChange , dp [ i ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return dp [ n - 1 ] [ k ] NEW_LINE DEDENT k = 3 NEW_LINE ar = [ 3 , 1 , 3 , 3 , 2 , 1 , 8 , 5 ] NEW_LINE print ( getMinimumOps ( ar , k ) ) NEW_LINE"],"bleu":0.46121202912367215,"rouge_l":0.5881669948003433}
{"id":907,"predictions":["def findCount ( N ) : NEW_LINE INDENT list = [ ] NEW_LINE sum = 0 NEW_LINE for i in range ( 20 ) : NEW_LINE INDENT sum += pow ( 2 , i ) NEW_LINE DEDENT for i in range ( 20 ) : NEW_LINE INDENT sum += int ( sum [ i ] ) NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 10 NEW_LINE print ( findCount ( N ) ) NEW_LINE DEDENT"],"references":["def findCount ( N ) : NEW_LINE INDENT list = [ ] NEW_LINE sum = 0 NEW_LINE for i in range ( 0 , 20 ) : NEW_LINE INDENT sum += 2 ** i NEW_LINE list . append ( sum ) NEW_LINE DEDENT for value in list : NEW_LINE INDENT if ( value > N ) : NEW_LINE INDENT return ( list . index ( value ) + 1 ) NEW_LINE DEDENT DEDENT DEDENT N = 10 NEW_LINE print ( findCount ( N ) ) NEW_LINE"],"bleu":0.542389797565996,"rouge_l":0.6680513595166163}
{"id":908,"predictions":["from math import * NEW_LINE def nineteen ( n ) : NEW_LINE INDENT x1 , y1 = 0 , 1 NEW_LINE x2 , y2 = 1 NEW_LINE while ( x1 != 1 ) : NEW_LINE INDENT x1 = int ( ( x1 + n ) \/ ( x2 ) NEW_LINE y1 = int ( y1 ) NEW_LINE x2 = int ( x2 ) NEW_LINE y2 = int ( y2 \/ y1 ) NEW_LINE DEDENT x1 , y1 = 0 , 0 NEW_LINE while ( y1 ) : NEW_LINE INDENT x1 = int ( x1 + n ) \/ ( y1 - y2 ) NEW_LINE y1 = int ( x1 * x2 ) NEW_LINE DEDENT x1 = int ( x2 * x2 ) NEW_LINE y2 = int ( y2 * y1 ) NEW_LINE x2 = x2 NEW_LINE y1 = y2 NEW_LINE x2 = x2 NEW_LINE y2 = y2 NEW_LINE while ( x1 > 0.0 ) : NEW_LINE INDENT x3 = int ( x3 + n ) \/ ( y1 - y1 ) NEW_LINE y3 = int ( y2 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 7 NEW_LINE print ( \" Farey ▁ = \" , int ( n ) ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def farey ( n ) : NEW_LINE INDENT x1 = 0 ; NEW_LINE y1 = 1 ; NEW_LINE x2 = 1 ; NEW_LINE y2 = n ; NEW_LINE print ( x1 , end = \" \" ) NEW_LINE print ( \" \/ \" , end = \" \" ) NEW_LINE print ( y1 , x2 , end = \" \" ) NEW_LINE print ( \" \/ \" , end = \" \" ) NEW_LINE print ( y2 , end = \" ▁ \" ) ; NEW_LINE x = 0 ; NEW_LINE y = 0 ; NEW_LINE while ( y != 1.0 ) : NEW_LINE INDENT x = math . floor ( ( y1 + n ) \/ y2 ) * x2 - x1 ; NEW_LINE y = math . floor ( ( y1 + n ) \/ y2 ) * y2 - y1 ; NEW_LINE print ( x , end = \" \" ) NEW_LINE print ( \" \/ \" , end = \" \" ) NEW_LINE print ( y , end = \" ▁ \" ) ; NEW_LINE x1 = x2 ; NEW_LINE x2 = x ; NEW_LINE y1 = y2 ; NEW_LINE y2 = y ; NEW_LINE DEDENT DEDENT n = 7 ; NEW_LINE print ( \" Farey ▁ Sequence ▁ of ▁ order \" , n , \" is \" ) ; NEW_LINE farey ( n ) ; NEW_LINE"],"bleu":0.18476172046483333,"rouge_l":0.4248095756256801}
{"id":909,"predictions":["def Finished_length ( input_length , output_distance ) : NEW_LINE INDENT return 1 \/ ( 1 \/ ( 1 \/ current_distance ) + ( 1 \/ current_distance ) ) ; NEW_LINE DEDENT output_length = 2 ; NEW_LINE input_distance = 50 ; NEW_LINE output_length = 50 ; NEW_LINE print ( \" Fraction ▁ of ▁ length \" , output_length ) ; NEW_LINE print ( \" Ficient ▁ of ▁ length \" , output_length ) ; NEW_LINE"],"references":["def focal_length ( image_distance , object_distance ) NEW_LINE INDENT : return 1 \/ ( ( 1 \/ image_distance ) + ( 1 \/ object_distance ) ) NEW_LINE DEDENT image_distance = 2 NEW_LINE object_distance = 50 NEW_LINE result = focal_length ( image_distance , object_distance ) NEW_LINE print ( \" Focal ▁ length ▁ of ▁ a ▁ lens ▁ is ▁ \" , result , \" ▁ units . \" ) NEW_LINE"],"bleu":0.20837882626659743,"rouge_l":0.5953245574216977}
{"id":910,"predictions":["def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def findModuloByM ( X , N , M ) : NEW_LINE INDENT if ( N < 6 ) : NEW_LINE INDENT temp = 0 NEW_LINE for i in range ( 0 , N , 1 ) : NEW_LINE INDENT temp = temp + ( ( X + 48 ) ) % M NEW_LINE res = ( temp * power ( 10 , N \/\/ 2 ) ) % M NEW_LINE DEDENT res = ( temp * power ( 10 , N \/\/ 2 + M ) ) % M NEW_LINE return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT X = 14 NEW_LINE Y = 9 NEW_LINE M = 9 NEW_LINE print ( findModuloByM ( X , N , M ) ) NEW_LINE DEDENT"],"references":["def power ( x , y , p ) : NEW_LINE INDENT res = 1 ; NEW_LINE x = x % p ; NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y and 1 ) : NEW_LINE INDENT res = ( res * x ) % p ; NEW_LINE DEDENT y = y >> 1 ; NEW_LINE x = ( x * x ) % p ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT def findModuloByM ( X , N , M ) : NEW_LINE INDENT if ( N < 6 ) : NEW_LINE INDENT temp = chr ( 48 + X ) * N NEW_LINE res = int ( temp ) % M ; NEW_LINE return res ; NEW_LINE DEDENT if ( N % 2 == 0 ) : NEW_LINE INDENT half = findModuloByM ( X , N \/\/ 2 , M ) % M ; NEW_LINE res = ( half * power ( 10 , N \/\/ 2 , M ) + half ) % M ; NEW_LINE return res ; NEW_LINE DEDENT else : NEW_LINE INDENT half = findModuloByM ( X , N \/\/ 2 , M ) % M ; NEW_LINE res = ( half * power ( 10 , N \/\/ 2 + 1 , M ) + half * 10 + X ) % M ; NEW_LINE return res ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT X = 6 ; N = 14 ; M = 9 ; NEW_LINE print ( findModuloByM ( X , N , M ) ) ; NEW_LINE DEDENT"],"bleu":0.4961996212815924,"rouge_l":0.7355305466237942}
{"id":911,"predictions":["def getTotalXorSubarrayXors ( arr , N ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i , N + 1 ) : NEW_LINE INDENT res = res ^ arr [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT arr = [ 3 , 5 , 4 , 6 ] NEW_LINE N = len ( arr ) NEW_LINE print ( getTotalXorSubarrayXors ( arr , N ) ) NEW_LINE"],"references":["def getTotalXorOfSubarrayXors ( arr , N ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( i , N ) : NEW_LINE INDENT for k in range ( i , j + 1 ) : NEW_LINE INDENT res = res ^ arr [ k ] NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT arr = [ 3 , 5 , 2 , 4 , 6 ] NEW_LINE N = len ( arr ) NEW_LINE print ( getTotalXorOfSubarrayXors ( arr , N ) ) NEW_LINE"],"bleu":0.7042639740499874,"rouge_l":0.8583897399358746}
{"id":912,"predictions":["def radius ( radius ) : NEW_LINE INDENT if ( radius < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT r = radius \/ 2 NEW_LINE return round ( r , 2 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT radius = 4 NEW_LINE print ( \" Area ▁ of ▁ circle ▁ = \" , area ( radius ) ) NEW_LINE DEDENT"],"references":["def innerCirclearea ( radius ) : NEW_LINE INDENT if ( radius < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT r = radius \/ 2 ; NEW_LINE Area = ( 3.14 * pow ( r , 2 ) ) ; NEW_LINE return Area ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT radius = 4 ; NEW_LINE print ( \" Area ▁ of ▁ circle ▁ c2 ▁ = \" , innerCirclearea ( radius ) ) ; NEW_LINE DEDENT"],"bleu":0.6341569361844088,"rouge_l":0.8369457148538476}
{"id":913,"predictions":["def Main ( P ) : NEW_LINE INDENT P = 1 NEW_LINE R = 1 NEW_LINE T = 1 NEW_LINE MI = ( P * T ) \/ 100 NEW_LINE MI = ( P * T * R ) \/ 100 NEW_LINE return NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT P , T = 1 , 1 NEW_LINE print ( \" Name ▁ of ▁ % .6f ▁ % \" % ( P , T ) ) NEW_LINE DEDENT"],"references":["P = 1 NEW_LINE R = 1 NEW_LINE T = 1 NEW_LINE SI = ( P * R * T ) \/ 100 NEW_LINE print ( \" simple ▁ interest ▁ is \" , SI ) NEW_LINE"],"bleu":0.25459207265353123,"rouge_l":0.5392072996863416}
{"id":914,"predictions":["def findSubArr ( arr , n ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT if ( abs ( arr [ i ] - arr [ i + 1 ] ) >= 2 ) : NEW_LINE INDENT print ( arr [ i ] , \" ▁ \" , arr [ i + 1 ] ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( - 1 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE findSubArr ( arr , n ) NEW_LINE DEDENT"],"references":["def findSubArr ( arr , n ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT if ( abs ( arr [ i ] - arr [ i + 1 ] ) >= 2 ) : NEW_LINE INDENT print ( arr [ i ] , arr [ i + 1 ] , end = \" \" ) ; NEW_LINE return ; NEW_LINE DEDENT DEDENT print ( - 1 ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 6 , 7 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE findSubArr ( arr , n ) ; NEW_LINE DEDENT"],"bleu":0.8300343058629575,"rouge_l":0.9323144104803494}
{"id":915,"predictions":["def Min_ overflow ( n , k , a ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT ans = ceil ( ( sum ) \/ ( 100 ) ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n , k , a = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE a = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE print ( Min_swing ( n , k , a ) ) NEW_LINE DEDENT"],"references":["from math import ceil NEW_LINE def Min_glass ( n , k , a ) : NEW_LINE INDENT a . sort ( ) NEW_LINE return ceil ( sum ( a [ : k ] ) \/ 100 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n , k = 4 , 3 NEW_LINE a = [ 200 , 150 , 140 , 300 ] NEW_LINE print ( Min_glass ( n , k , a ) ) NEW_LINE DEDENT"],"bleu":0.38010318487080325,"rouge_l":0.5938943894389439}
{"id":916,"predictions":["def findModulo ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE modulus = 0 NEW_LINE i = 0 NEW_LINE while ( i < l ) : NEW_LINE INDENT if ( s [ i ] == ' + ' ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT DEDENT real = s [ i + 1 ] NEW_LINE real = s [ i ] NEW_LINE x = s [ i + 1 ] NEW_LINE if ( real > modulus ) : NEW_LINE INDENT print ( x * x + y ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( int ( modulus ) ) NEW_LINE DEDENT DEDENT"],"references":["from math import sqrt NEW_LINE def findModulo ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE modulus = 0 NEW_LINE if ( ' + ' in s ) : NEW_LINE INDENT i = s . index ( ' + ' ) NEW_LINE DEDENT else : NEW_LINE INDENT i = s . index ( ' - ' ) NEW_LINE DEDENT real = s [ 0 : i ] NEW_LINE imaginary = s [ i + 1 : l - 1 ] NEW_LINE x = int ( real ) NEW_LINE y = int ( imaginary ) NEW_LINE print ( int ( sqrt ( x * x + y * y ) ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \"3 + 4i \" NEW_LINE findModulo ( s ) NEW_LINE DEDENT"],"bleu":0.40823731553142967,"rouge_l":0.5632155607534162}
{"id":917,"predictions":["def printRepeating ( arr , size ) : NEW_LINE INDENT print ( \" The ▁ repeating ▁ elements ▁ are : ▁ \" ) NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT if arr [ abs ( arr [ i ] ) ] > 0 : NEW_LINE INDENT arr [ abs ( arr [ i ] ) ] = - arr [ abs ( arr [ i ] ) ] NEW_LINE DEDENT else : NEW_LINE INDENT print ( abs ( arr [ i ] ) , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 4 , 2 , 4 , 5 , 2 , 3 , 1 ] NEW_LINE arr_size = len ( arr ) NEW_LINE printRepeating ( arr , arr_size ) NEW_LINE"],"references":["def printRepeating ( arr , size ) : NEW_LINE INDENT print ( \" ▁ The ▁ repeating ▁ elements ▁ are \" , end = \" ▁ \" ) NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT if ( arr [ abs ( arr [ i ] ) ] > 0 ) : NEW_LINE INDENT arr [ abs ( arr [ i ] ) ] = ( - 1 ) * arr [ abs ( arr [ i ] ) ] NEW_LINE DEDENT else : NEW_LINE INDENT print ( abs ( arr [ i ] ) , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 4 , 2 , 4 , 5 , 2 , 3 , 1 ] NEW_LINE arr_size = len ( arr ) NEW_LINE printRepeating ( arr , arr_size ) NEW_LINE"],"bleu":0.8549831619885879,"rouge_l":0.9462921612410389}
{"id":918,"predictions":["def countZeros ( x ) : NEW_LINE INDENT y = 32 NEW_LINE if ( y ) : NEW_LINE INDENT n = n >> 16 NEW_LINE DEDENT if ( y != 0 ) : NEW_LINE INDENT n = n >> 4 NEW_LINE x = y NEW_LINE DEDENT y = x >> 8 NEW_LINE if ( y != 0 ) : NEW_LINE INDENT n = n - 4 NEW_LINE x = y >> 4 NEW_LINE DEDENT y = x >> 2 NEW_LINE if ( y != 0 ) : NEW_LINE INDENT n = n - 2 NEW_LINE x = y >> 2 NEW_LINE DEDENT y = x >> 2 NEW_LINE if ( y != 0 ) : NEW_LINE INDENT n = n - 2 NEW_LINE DEDENT if ( y != 0 ) : NEW_LINE INDENT return n - 2 NEW_LINE DEDENT DEDENT x = 101 NEW_LINE print ( countZeros ( x ) ) NEW_LINE"],"references":["def countZeros ( x ) : NEW_LINE INDENT n = 32 ; NEW_LINE y = x >> 16 ; NEW_LINE if ( y != 0 ) : NEW_LINE INDENT n = n - 16 ; NEW_LINE x = y ; NEW_LINE DEDENT y = x >> 8 ; NEW_LINE if ( y != 0 ) : NEW_LINE INDENT n = n - 8 ; NEW_LINE x = y ; NEW_LINE DEDENT y = x >> 4 ; NEW_LINE if ( y != 0 ) : NEW_LINE INDENT n = n - 4 ; NEW_LINE x = y ; NEW_LINE DEDENT y = x >> 2 ; NEW_LINE if ( y != 0 ) : NEW_LINE INDENT n = n - 2 ; NEW_LINE x = y ; NEW_LINE DEDENT y = x >> 1 ; NEW_LINE if ( y != 0 ) : NEW_LINE INDENT return n - 2 ; NEW_LINE DEDENT return n - x ; NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT x = 101 ; NEW_LINE print ( countZeros ( x ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"bleu":0.5403275127673512,"rouge_l":0.742404831625183}
{"id":919,"predictions":["def pairOR ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE k0 = 0 NEW_LINE for i in range ( 32 ) : NEW_LINE INDENT k1 = 0 NEW_LINE if ( ( arr [ i ] & ( 1 << i ) ) : NEW_LINE INDENT k1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT k0 += 1 NEW_LINE DEDENT DEDENT ans = ans + ( 1 << i ) * ( k1 - 1 ) \/\/ 2 NEW_LINE return ans NEW_LINE DEDENT arr = [ 1 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( pairOR ( arr , n ) ) NEW_LINE"],"references":["def pairORSum ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , 32 ) : NEW_LINE INDENT k1 = 0 NEW_LINE k0 = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( ( arr [ j ] & ( 1 << i ) ) ) : NEW_LINE INDENT k1 = k1 + 1 NEW_LINE DEDENT else : NEW_LINE INDENT k0 = k0 + 1 NEW_LINE DEDENT DEDENT ans = ans + ( 1 << i ) * ( k1 * ( k1 - 1 ) \/\/ 2 ) + ( 1 << i ) * ( k1 * k0 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( pairORSum ( arr , n ) ) NEW_LINE"],"bleu":0.5925594910939087,"rouge_l":0.7679457692773273}
{"id":920,"predictions":["def binaryToDecimal ( n ) : NEW_LINE INDENT num = n ; NEW_LINE dec_value = 0 ; NEW_LINE base = 1 ; NEW_LINE l = len ( num ) ; NEW_LINE base = 1 ; NEW_LINE for i in range ( l - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( num [ i ] == '1' ) : NEW_LINE INDENT dec_value += base ; NEW_LINE DEDENT base = base * 2 ; NEW_LINE DEDENT return dec_value ; NEW_LINE DEDENT num = \"101001\" ; NEW_LINE print ( binaryToDecimal ( num ) ) ; NEW_LINE"],"references":["def binaryToDecimal ( n ) : NEW_LINE INDENT num = n ; NEW_LINE dec_value = 0 ; NEW_LINE base1 = 1 ; NEW_LINE len1 = len ( num ) ; NEW_LINE for i in range ( len1 - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( num [ i ] == '1' ) : NEW_LINE INDENT dec_value += base1 ; NEW_LINE DEDENT base1 = base1 * 2 ; NEW_LINE DEDENT return dec_value ; NEW_LINE DEDENT num = \"10101001\" ; NEW_LINE print ( binaryToDecimal ( num ) ) ; NEW_LINE"],"bleu":0.7718696554716102,"rouge_l":0.9057859703020993}
{"id":921,"predictions":["def countStrings ( n , k ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 2 ) ] for j in range ( k + 1 ) ] NEW_LINE dp [ 1 ] [ 0 ] = 1 NEW_LINE dp [ 1 ] [ 0 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 2 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j ] NEW_LINE dp [ i ] [ j ] = dp [ i - 1 ] [ j ] NEW_LINE dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] NEW_LINE dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j ] NEW_LINE DEDENT DEDENT return dp [ n ] [ k ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 NEW_LINE k = 2 NEW_LINE print ( countStrings ( n , k ) ) NEW_LINE DEDENT"],"references":["def countStrings ( n , k ) : NEW_LINE INDENT dp = [ [ [ 0 , 0 ] for __ in range ( k + 1 ) ] for _ in range ( n + 1 ) ] NEW_LINE dp [ 1 ] [ 0 ] [ 0 ] = 1 NEW_LINE dp [ 1 ] [ 0 ] [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( k + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] [ 0 ] = ( dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] ) NEW_LINE dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ] NEW_LINE if j >= 1 : NEW_LINE INDENT dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] [ 1 ] NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE k = 2 NEW_LINE print ( countStrings ( n , k ) ) NEW_LINE DEDENT"],"bleu":0.6660380977555354,"rouge_l":0.7923746664794271}
{"id":922,"predictions":["import sys NEW_LINE def print2 ( arr , arr_size ) : NEW_LINE INDENT if ( arr_size < 2 ) : NEW_LINE INDENT print ( \" ▁ Invalid ▁ \" ) NEW_LINE return NEW_LINE DEDENT first = - sys . maxsize NEW_LINE for i in range ( arr_size ) : NEW_LINE INDENT if arr [ i ] > first : NEW_LINE INDENT second = first NEW_LINE first = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > second and arr [ i ] != first ) : NEW_LINE INDENT second = arr [ i ] NEW_LINE first = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > second and arr [ i ] != first ) : NEW_LINE INDENT print ( \" The ▁ two ▁ element ▁ is ▁ \" , second ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 12 , 35 , 1 , 10 , 34 ] NEW_LINE n = len ( arr ) NEW_LINE print2 ( arr , n ) NEW_LINE DEDENT"],"references":["def print2largest ( arr , arr_size ) : NEW_LINE INDENT if ( arr_size < 2 ) : NEW_LINE INDENT print ( \" ▁ Invalid ▁ Input ▁ \" ) NEW_LINE return NEW_LINE DEDENT first = second = - 2147483648 NEW_LINE for i in range ( arr_size ) : NEW_LINE INDENT if ( arr [ i ] > first ) : NEW_LINE INDENT second = first NEW_LINE first = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > second and arr [ i ] != first ) : NEW_LINE INDENT second = arr [ i ] NEW_LINE DEDENT DEDENT if ( second == - 2147483648 ) : NEW_LINE INDENT print ( \" There ▁ is ▁ no ▁ second ▁ largest ▁ element \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" The ▁ second ▁ largest ▁ element ▁ is \" , second ) NEW_LINE DEDENT DEDENT arr = [ 12 , 35 , 1 , 10 , 34 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print2largest ( arr , n ) NEW_LINE"],"bleu":0.6991875875617943,"rouge_l":0.7690668560774216}
{"id":923,"predictions":["def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b ; NEW_LINE DEDENT return gcd ( b % a , a ) ; NEW_LINE DEDENT def print_gcd ( n , m ) : NEW_LINE INDENT max_g = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT max_gcd = gcd ( max_g , arr [ i ] ) ; NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT max_gcd = gcd ( max_gcd , arr [ i ] ) ; NEW_LINE DEDENT print ( max_gcd , end = \" \" ) ; NEW_LINE DEDENT def print_gcd ( n , m , arr , query ) : NEW_LINE INDENT max_gcd = 0 ; NEW_LINE for i in range ( m ) : NEW_LINE INDENT if ( query [ i ] [ 0 ] > max_gcd ) : NEW_LINE INDENT max_gcd = gcd ( query [ i ] [ 1 ] , max_gcd ) ; NEW_LINE DEDENT DEDENT print ( max_gcd , end = \" ▁ \" ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 ; m = 4 ; NEW_LINE query = [ 36 , 24 ] ; NEW_LINE query = [ 4 , 24 ] ; NEW_LINE query [ 0 ] [ 0 ] = 1 ; NEW_LINE query [ 1 ] [ 0 ] = 3 ; NEW_LINE query [ 1 ] [ 0 ] = 1 ; NEW_LINE query [ 1 ] [ 1 ] = 3 ; NEW_LINE query [ 0 ] [ 0 ] = 1 ; NEW_LINE query [ 2 ] [ 1 ] = 1 ; NEW_LINE query [ 1 ] [ 0 ] = 3 ; NEW_LINE query [ 2 ] [ 1 ] = 1 ; NEW_LINE DEDENT"],"references":["def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def print_gcd_online ( n , m , query , arr ) : NEW_LINE INDENT max_gcd = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT max_gcd = gcd ( max_gcd , arr [ i ] ) NEW_LINE DEDENT for i in range ( 0 , m ) : NEW_LINE INDENT query [ i ] [ 0 ] -= 1 NEW_LINE arr [ query [ i ] [ 0 ] ] \/\/= query [ i ] [ 1 ] NEW_LINE max_gcd = gcd ( arr [ query [ i ] [ 0 ] ] , max_gcd ) NEW_LINE print ( max_gcd ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n , m = 3 , 3 NEW_LINE query = [ [ 1 , 3 ] , [ 3 , 12 ] , [ 2 , 4 ] ] NEW_LINE arr = [ 36 , 24 , 72 ] NEW_LINE print_gcd_online ( n , m , query , arr ) NEW_LINE DEDENT"],"bleu":0.3757139625508215,"rouge_l":0.5944019357792166}
{"id":924,"predictions":["def countSubstr ( st , n , x , y ) : NEW_LINE INDENT tot_count = 0 NEW_LINE count_x = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( st [ i ] == x ) : NEW_LINE INDENT count_x += 1 NEW_LINE DEDENT DEDENT if ( st [ n - 1 ] == y ) : NEW_LINE INDENT count_x += 1 NEW_LINE DEDENT if ( st [ n - 1 ] == y ) : NEW_LINE INDENT count_count += count_x NEW_LINE DEDENT DEDENT st = ' ' NEW_LINE n = len ( st ) NEW_LINE x = ' ' NEW_LINE y = ' c ' NEW_LINE print ( \" Count ▁ = \" , countSubstr ( st , n , x , y ) ) NEW_LINE"],"references":["def countSubstr ( str , n , x , y ) : NEW_LINE INDENT tot_count = 0 NEW_LINE count_x = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if str [ i ] == x : NEW_LINE INDENT count_x += 1 NEW_LINE DEDENT if str [ i ] == y : NEW_LINE INDENT tot_count += count_x NEW_LINE DEDENT DEDENT return tot_count NEW_LINE DEDENT str = ' abbcaceghcak ' NEW_LINE n = len ( str ) NEW_LINE x , y = ' a ' , ' c ' NEW_LINE print ( ' Count ▁ = ' , countSubstr ( str , n , x , y ) ) NEW_LINE"],"bleu":0.5320341783441263,"rouge_l":0.773731587561375}
{"id":925,"predictions":["def centered_ cube_ cubes ( n ) : NEW_LINE INDENT return ( 2 * n + 1 ) * ( n * n + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE print ( \" th ▁ Centered ▁ Cube ▁ number ▁ : ▁ \" , center_ cube_ cubes_size ) NEW_LINE DEDENT"],"references":["def centered_cube ( n ) : NEW_LINE INDENT return ( 2 * n + 1 ) * ( n * n + n + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE print ( n , \" th ▁ Centered ▁ cube ▁ \" + \" number ▁ : ▁ \" , centered_cube ( n ) ) NEW_LINE n = 10 NEW_LINE print ( n , \" th ▁ Centered ▁ cube ▁ \" + \" number ▁ : ▁ \" , centered_cube ( n ) ) NEW_LINE DEDENT"],"bleu":0.45984976157101903,"rouge_l":0.6762495302517851}
{"id":926,"predictions":["from math import sqrt NEW_LINE MAX = 10000 NEW_LINE primes = [ ] NEW_LINE def sieve ( ) : NEW_LINE INDENT marked = [ False ] * MAX NEW_LINE for i in range ( 1 , int ( sqrt ( MAX ) ) + 1 ) : NEW_LINE INDENT if ( i * ( i + 1 ) ) \/\/ 2 == 0 : NEW_LINE INDENT for j in range ( ( i * ( i + 1 ) ) , 2 * i + 2 ) : NEW_LINE INDENT marked [ j ] = True NEW_LINE DEDENT DEDENT primes . append ( 2 * i + 1 ) NEW_LINE DEDENT DEDENT def findPrimes ( n ) : NEW_LINE INDENT if ( n <= 2 or n % 2 != 0 ) : NEW_LINE INDENT primes . append ( 2 * ( i + 1 ) ) NEW_LINE DEDENT DEDENT def findPrimes ( n ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT print ( \" Invalid ▁ Input \" ) NEW_LINE return NEW_LINE DEDENT for i in range ( 1 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( marked [ i ] ) : NEW_LINE INDENT print ( \" Invalid ▁ Input \" ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT sieve ( ) NEW_LINE findPrimes ( 4 ) NEW_LINE findPrimes ( 100 ) NEW_LINE findPrimes ( 100 ) NEW_LINE DEDENT"],"references":["import math NEW_LINE MAX = 10000 ; NEW_LINE primes = [ ] ; NEW_LINE def sieveSundaram ( ) : NEW_LINE INDENT marked = [ False ] * ( int ( MAX \/ 2 ) + 100 ) ; NEW_LINE for i in range ( 1 , int ( ( math . sqrt ( MAX ) - 1 ) \/ 2 ) + 1 ) : NEW_LINE INDENT for j in range ( ( i * ( i + 1 ) ) << 1 , int ( MAX \/ 2 ) + 1 , 2 * i + 1 ) : NEW_LINE INDENT marked [ j ] = True ; NEW_LINE DEDENT DEDENT primes . append ( 2 ) ; NEW_LINE for i in range ( 1 , int ( MAX \/ 2 ) + 1 ) : NEW_LINE INDENT if ( marked [ i ] == False ) : NEW_LINE INDENT primes . append ( 2 * i + 1 ) ; NEW_LINE DEDENT DEDENT DEDENT def findPrimes ( n ) : NEW_LINE INDENT if ( n <= 2 or n % 2 != 0 ) : NEW_LINE INDENT print ( \" Invalid ▁ Input \" ) ; NEW_LINE return ; NEW_LINE DEDENT i = 0 ; NEW_LINE while ( primes [ i ] <= n \/\/ 2 ) : NEW_LINE INDENT diff = n - primes [ i ] ; NEW_LINE if diff in primes : NEW_LINE INDENT print ( primes [ i ] , \" + \" , diff , \" = \" , n ) ; NEW_LINE return ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT DEDENT sieveSundaram ( ) ; NEW_LINE findPrimes ( 4 ) ; NEW_LINE findPrimes ( 38 ) ; NEW_LINE findPrimes ( 100 ) ; NEW_LINE"],"bleu":0.5382395878166738,"rouge_l":0.6428991992463495}
{"id":927,"predictions":["from math import sqrt NEW_LINE N = 100005 NEW_LINE d = [ 0 ] * N ; NEW_LINE pre = [ 0 ] * N ; NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( 1 , i ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT if ( i * j == j ) : NEW_LINE INDENT d [ i ] += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT d [ i ] += 2 ; NEW_LINE DEDENT DEDENT DEDENT ans = 0 ; NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT if ( d [ i ] == d [ 0 ] ) : NEW_LINE INDENT ans += 1 ; NEW_LINE DEDENT DEDENT DEDENT print ( ans ) ; NEW_LINE"],"references":["from math import sqrt ; NEW_LINE N = 100005 NEW_LINE d = [ 0 ] * N NEW_LINE pre = [ 0 ] * N NEW_LINE def Positive_Divisors ( ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( 1 , int ( sqrt ( i ) ) + 1 ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT if ( j * j == i ) : NEW_LINE INDENT d [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ i ] += 2 NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT if ( d [ i ] == d [ i - 1 ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT pre [ i ] = ans NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT Positive_Divisors ( ) NEW_LINE n = 15 NEW_LINE print ( pre [ n ] ) NEW_LINE DEDENT"],"bleu":0.5646343794128549,"rouge_l":0.7747923790913533}
{"id":928,"predictions":["def leibibilcount ( n ) : NEW_LINE INDENT C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , min ( i , n ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = ( C [ i - 1 ] [ j ] + C [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( \"1 ▁ \" , end = \" \" ) NEW_LINE DEDENT print ( \" \\n \" , end = \" \" ) NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( j , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT n = 4 NEW_LINE leibilida ( n ) NEW_LINE"],"references":["def LeibnizHarmonicTriangle ( n ) : NEW_LINE INDENT C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] ; NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , min ( i , n ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) ; NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( \"1 \/ \" , end = \" \" ) ; NEW_LINE print ( i * C [ i - 1 ] [ j - 1 ] , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( ) ; NEW_LINE DEDENT DEDENT LeibnizHarmonicTriangle ( 4 ) ; NEW_LINE"],"bleu":0.693373746341398,"rouge_l":0.8244409849985848}
{"id":929,"predictions":["def ansQueries ( pref , l , r , q ) : NEW_LINE INDENT if ( r - l + 1 ) % 2 == 0 : NEW_LINE INDENT print ( \"0\" , \"1\" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT if l % 2 == 0 : NEW_LINE INDENT print ( \"0\" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( pref [ r ] ^ pref [ l - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT def wrapper ( arr , n , l , r , q ) : NEW_LINE INDENT pref = [ 0 for i in range ( n + 1 ) ] NEW_LINE pref = [ 0 for i in range ( 100 ) ] NEW_LINE pref [ 0 ] = pref [ 0 ] ^ pref [ l - 1 ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT pref [ i ] ^ pref [ i - 1 ] ] = pref [ i - 1 ] ^ pref [ i ] ) NEW_LINE pref [ i ] = pref [ i - 1 ] ^ pre [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT pref [ i ] = pref [ i ] ^ pref [ i - 1 ] NEW_LINE DEDENT DEDENT i = 0 NEW_LINE while i != q : NEW_LINE INDENT ans = ( prefix [ i ] ^ pref [ i ] ) NEW_LINE i = i + 1 NEW_LINE while i != q : NEW_LINE INDENT ans = pref [ i ] ^ pref [ i - 1 ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE l = len ( arr ) NEW_LINE r = [ 2 , 3 , 2 , 4 ] NEW_LINE performQueries ( arr , n , l , r , q , q ) NEW_LINE DEDENT"],"references":["N = 100 NEW_LINE def ansQueries ( prefeven , prefodd , l , r ) : NEW_LINE INDENT if ( ( r - l + 1 ) % 2 == 0 ) : NEW_LINE INDENT print ( \"0\" ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( l % 2 == 0 ) : NEW_LINE INDENT print ( prefeven [ r ] ^ prefeven [ l - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( prefodd [ r ] ^ prefodd [ l - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT def wrapper ( arr , n , l , r , q ) : NEW_LINE INDENT prefodd = [ 0 ] * N NEW_LINE prefeven = [ 0 ] * N NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( ( i ) % 2 == 0 ) : NEW_LINE INDENT prefeven [ i ] = arr [ i - 1 ] ^ prefeven [ i - 1 ] NEW_LINE prefodd [ i ] = prefodd [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT prefeven [ i ] = prefeven [ i - 1 ] NEW_LINE prefodd [ i ] = prefodd [ i - 1 ] ^ arr [ i - 1 ] NEW_LINE DEDENT DEDENT i = 0 NEW_LINE while ( i != q ) : NEW_LINE INDENT ansQueries ( prefeven , prefodd , l [ i ] , r [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE l = [ 1 , 1 , 2 ] NEW_LINE r = [ 2 , 3 , 4 ] NEW_LINE q = len ( l ) NEW_LINE wrapper ( arr , n , l , r , q ) NEW_LINE DEDENT"],"bleu":0.5784181758788866,"rouge_l":0.713500563697858}
{"id":930,"predictions":["def squaresum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( i * i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 NEW_LINE print ( squaresum ( n ) ) NEW_LINE DEDENT"],"references":["def squaresum ( n ) : NEW_LINE INDENT sm = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sm = sm + ( i * i ) NEW_LINE DEDENT return sm NEW_LINE DEDENT n = 4 NEW_LINE print ( squaresum ( n ) ) NEW_LINE"],"bleu":0.6266118414619197,"rouge_l":0.811491650155675}
{"id":931,"predictions":["MAX = 10 NEW_LINE fact = [ 0 ] * MAX NEW_LINE def isFactor ( n ) : NEW_LINE INDENT fact [ 0 ] = 1 NEW_LINE for i in range ( 1 , MAX ) : NEW_LINE INDENT fact [ i ] = i * fact [ i - 1 ] NEW_LINE DEDENT for i in range ( 1 , MAX ) : NEW_LINE INDENT fact [ i ] = i * fact [ i - 1 ] NEW_LINE DEDENT DEDENT def isFactor ( n ) : NEW_LINE INDENT fact [ n ] = 0 NEW_LINE sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT d = n % 10 NEW_LINE sum += fact [ d ] NEW_LINE n \/\/= 10 NEW_LINE DEDENT if ( sum == 10 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if ( isFactor ( n ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if ( isFactor ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["MAX = 10 NEW_LINE def isFactorion ( n ) : NEW_LINE INDENT fact = [ 0 ] * MAX NEW_LINE fact [ 0 ] = 1 NEW_LINE for i in range ( 1 , MAX ) : NEW_LINE INDENT fact [ i ] = i * fact [ i - 1 ] NEW_LINE DEDENT org = n NEW_LINE sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT d = n % 10 NEW_LINE sum += fact [ d ] NEW_LINE n = n \/\/ 10 NEW_LINE DEDENT if ( sum == org ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT n = 40585 NEW_LINE if ( isFactorion ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.613762622358233,"rouge_l":0.7918889000704439}
{"id":932,"predictions":["def min Insertions ( H , N , K ) : NEW_LINE INDENT insr = 0 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT difference = abs ( H [ i ] - H [ i - 1 ] ) NEW_LINE if ( difference <= K ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT insr += ceil ( difference \/ K ) NEW_LINE DEDENT DEDENT return insr NEW_LINE DEDENT H = [ 2 , 4 , 8 , 16 ] NEW_LINE K = 3 NEW_LINE N = len ( H ) NEW_LINE print ( min Insertions ( H , N , K ) ) NEW_LINE"],"references":["import math NEW_LINE def minInsertions ( H , n , K ) : NEW_LINE INDENT inser = 0 ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT diff = abs ( H [ i ] - H [ i - 1 ] ) ; NEW_LINE if ( diff <= K ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT else : NEW_LINE INDENT inser += math . ceil ( diff \/ K ) - 1 ; NEW_LINE DEDENT DEDENT return inser ; NEW_LINE DEDENT H = [ 2 , 4 , 8 , 16 ] ; NEW_LINE K = 3 ; NEW_LINE n = len ( H ) ; NEW_LINE print ( minInsertions ( H , n , K ) ) ; NEW_LINE"],"bleu":0.5290383586992959,"rouge_l":0.8164120589428147}
{"id":933,"predictions":["def ReplaceElements ( arr , n ) : NEW_LINE INDENT X = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT X ^= arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = X ^ arr [ i ] NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 3 , 3 , 5 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE ReplaceElements ( arr , n ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT"],"references":["def ReplaceElements ( arr , n ) : NEW_LINE INDENT X = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT X ^= arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = X ^ arr [ i ] NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 3 , 3 , 5 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE ReplaceElements ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.971760749886894,"rouge_l":0.9933801138620416}
{"id":934,"predictions":["def makePalindrome ( string ) : NEW_LINE INDENT i = 0 NEW_LINE j = len ( string ) - 1 NEW_LINE while i <= j : NEW_LINE INDENT if ( string [ i ] == ' a ' and string [ j ] == ' * ' ) : NEW_LINE INDENT string [ i ] = ' a ' NEW_LINE string [ j ] = ' a ' NEW_LINE i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT elif ( string [ i ] == ' * ' and string [ j ] != string [ i ] ) : NEW_LINE INDENT string [ i ] = string [ j ] NEW_LINE DEDENT elif ( string [ i ] != string [ j ] ) : NEW_LINE INDENT string = string [ : i ] NEW_LINE i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT return \" - 1\" NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" acab \" NEW_LINE string = makePalindrome ( string ) NEW_LINE print ( string ) NEW_LINE DEDENT"],"references":["def makePalindrome ( str1 ) : NEW_LINE INDENT i = 0 NEW_LINE j = len ( str1 ) - 1 NEW_LINE str1 = list ( str1 ) NEW_LINE while ( i <= j ) : NEW_LINE INDENT if ( str1 [ i ] == ' * ' and str1 [ j ] == ' * ' ) : NEW_LINE INDENT str1 [ i ] = ' a ' NEW_LINE str1 [ j ] = ' a ' NEW_LINE DEDENT elif ( str1 [ j ] == ' * ' ) : NEW_LINE INDENT str1 [ j ] = str1 [ i ] NEW_LINE DEDENT elif ( str1 [ i ] == ' * ' ) : NEW_LINE INDENT str1 [ i ] = str1 [ j ] NEW_LINE DEDENT elif ( str1 [ i ] != str1 [ j ] ) : NEW_LINE INDENT str1 = ' ' . join ( str1 ) NEW_LINE return \" - 1\" NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT str1 = ' ' . join ( str1 ) NEW_LINE return str1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = \" na * an \" NEW_LINE print ( makePalindrome ( str1 ) ) NEW_LINE DEDENT"],"bleu":0.46768853854275205,"rouge_l":0.6861754157156831}
{"id":935,"predictions":["def countSubstr ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE aux = [ 0 for i in range ( n ) ] NEW_LINE aux [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT aux [ ord ( s [ i ] ) - ord ( '0' ) ] = aux [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT aux [ ord ( s [ i ] ) ] += 1 NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT count += aux [ i - 1 ] NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT s = \"1101\" NEW_LINE print ( countSubstr ( s ) ) NEW_LINE"],"references":["import math NEW_LINE def countSubstr ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE auxArr = [ 0 for i in range ( n ) ] NEW_LINE if ( s [ 0 ] == '1' ) : NEW_LINE INDENT auxArr [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT auxArr [ i ] = auxArr [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT auxArr [ i ] = auxArr [ i - 1 ] NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT count += auxArr [ i ] NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT s = \"1101\" NEW_LINE print ( countSubstr ( s ) ) NEW_LINE"],"bleu":0.7596363473486707,"rouge_l":0.8304232021308079}
{"id":936,"predictions":["class Graph : NEW_LINE INDENT def __init__ ( self , v ) : NEW_LINE INDENT self . v = v NEW_LINE self . graph = [ ] NEW_LINE self . append ( v ) NEW_LINE DEDENT def add ( self , v ) : NEW_LINE INDENT self . graph [ v ] . append ( v ) NEW_LINE self . graph [ v ] . append ( v ) NEW_LINE DEDENT def addEdge ( self , v ) : NEW_LINE INDENT self . graph [ v ] . append ( v ) NEW_LINE DEDENT def addEdge ( self , v ) : NEW_LINE INDENT self . graph [ v ] . append ( v ) NEW_LINE for i in range ( v ) : NEW_LINE INDENT self . graph [ i ] . append ( v ) NEW_LINE DEDENT DEDENT def addEdge ( self , w ) : NEW_LINE INDENT v = self . graph [ v ] NEW_LINE while True : NEW_LINE INDENT self . graph [ v ] . append ( w ) NEW_LINE self . graph [ v ] . append ( w ) NEW_LINE v = self . graph [ v ] . graph [ w ] NEW_LINE DEDENT return v NEW_LINE DEDENT def addEdge ( self , v ) : NEW_LINE INDENT return v NEW_LINE DEDENT g = Graph ( v ) NEW_LINE g . addEdge ( v ) NEW_LINE g . addEdge ( ) NEW_LINE g . addEdge ( 0 , 1 ) NEW_LINE g . addEdge ( 1 , 2 ) NEW_LINE g . addEdge ( 1 , 3 ) NEW_LINE g . addEdge ( 0 , 2 ) NEW_LINE g . addEdge ( 0 , 4 ) NEW_LINE g . addEdge ( 2 , 3 ) NEW_LINE g . addEdge ( 1 , 3 ) NEW_LINE g . addEdge ( 2 , 1 ) NEW_LINE g . addEdge ( 3 , 4 ) NEW_LINE print \" Following ▁ BST ▁ First ▁ from ▁ 1 ▁ BST ▁ : \" NEW_LINE g . addEdge ( 2 , 3 ) NEW_LINE print \" \" NEW_LINE g . add ( 1 , 2 ) NEW_LINE DEDENT"],"references":["from collections import defaultdict NEW_LINE class Graph : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . graph = defaultdict ( list ) NEW_LINE DEDENT def addEdge ( self , u , v ) : NEW_LINE INDENT self . graph [ u ] . append ( v ) NEW_LINE DEDENT def BFS ( self , s ) : NEW_LINE INDENT visited = [ False ] * ( len ( self . graph ) ) NEW_LINE queue = [ ] NEW_LINE queue . append ( s ) NEW_LINE visited [ s ] = True NEW_LINE while queue : NEW_LINE INDENT s = queue . pop ( 0 ) NEW_LINE print ( s , end = \" ▁ \" ) NEW_LINE for i in self . graph [ s ] : NEW_LINE INDENT if visited [ i ] == False : NEW_LINE INDENT queue . append ( i ) NEW_LINE visited [ i ] = True NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT g = Graph ( ) NEW_LINE g . addEdge ( 0 , 1 ) NEW_LINE g . addEdge ( 0 , 2 ) NEW_LINE g . addEdge ( 1 , 2 ) NEW_LINE g . addEdge ( 2 , 0 ) NEW_LINE g . addEdge ( 2 , 3 ) NEW_LINE g . addEdge ( 3 , 3 ) NEW_LINE print ( \" Following ▁ is ▁ Breadth ▁ First ▁ Traversal \" \" ▁ ( starting ▁ from ▁ vertex ▁ 2 ) \" ) NEW_LINE g . BFS ( 2 ) NEW_LINE"],"bleu":0.36830542784143966,"rouge_l":0.5799366189487488}
{"id":937,"predictions":["def vowel_calc ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE arr = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT arr [ i ] = n NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = ( n - i ) + arr [ i - 1 ] NEW_LINE DEDENT DEDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ch == ' a ' or ch == ' e ' or ch == ' i ' or ch == ' o ' or ch == ' u ' ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT s = vowel_calc ( s ) NEW_LINE return vowel_calc ( s ) NEW_LINE DEDENT s = \" dbch \" NEW_LINE vowel_calc ( s ) NEW_LINE print ( vowel_calc ( s ) ) NEW_LINE"],"references":["def sumVowel ( string ) : NEW_LINE INDENT n = len ( string ) NEW_LINE sum = 0 NEW_LINE string = string . lower ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT s = string [ i ] NEW_LINE if ( s == \" a \" or s == \" e \" or s == \" i \" or s == \" o \" or s == \" u \" ) : NEW_LINE INDENT sum += ( ( n - i ) * ( i + 1 ) ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT string = \" abhay \" NEW_LINE print ( vovel ( string ) ) NEW_LINE DEDENT"],"bleu":0.2692681789887676,"rouge_l":0.48439771837602047}
{"id":938,"predictions":["def findOddPair ( A , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( A [ i ] % 2 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count * ( N - count ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 5 , 4 , 7 , 2 , 1 ] NEW_LINE print ( findOddPair ( a , len ( a ) ) ) NEW_LINE DEDENT"],"references":["def findOddPair ( A , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( A [ i ] % 2 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count * ( N - count ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 5 , 4 , 7 , 2 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( findOddPair ( a , n ) ) NEW_LINE DEDENT"],"bleu":0.8336836432682754,"rouge_l":0.9031775079021794}
{"id":939,"predictions":["def smallestDivisor ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT for i in range ( 3 , n , 2 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT n = 31 NEW_LINE print ( smallestDivisor ( n ) ) NEW_LINE"],"references":["def smallestDivisor ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return 2 ; NEW_LINE DEDENT i = 3 ; NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT i += 2 ; NEW_LINE DEDENT return n ; NEW_LINE DEDENT n = 31 ; NEW_LINE print ( smallestDivisor ( n ) ) ; NEW_LINE"],"bleu":0.6093756758208155,"rouge_l":0.814910579616462}
{"id":940,"predictions":["def areaOfK ( d1 , d2 ) : NEW_LINE INDENT area = ( d1 * d2 ) \/ 2 NEW_LINE return area NEW_LINE DEDENT d1 = 4 NEW_LINE d2 = 6 NEW_LINE print ( \" Area ▁ of ▁ K % d1 ▁ = \" , areaOfK ( d1 , d2 ) ) NEW_LINE"],"references":["def areaOfKite ( d1 , d2 ) : NEW_LINE INDENT area = ( d1 * d2 ) \/ 2 ; NEW_LINE return area ; NEW_LINE DEDENT d1 = 4 ; NEW_LINE d2 = 6 ; NEW_LINE print ( \" Area ▁ of ▁ Kite ▁ = ▁ \" , areaOfKite ( d1 , d2 ) ) ; NEW_LINE"],"bleu":0.623533014510827,"rouge_l":0.8694008144269924}
{"id":941,"predictions":["def isPossible ( v , str1 , str2 ) : NEW_LINE INDENT str1 = ' ' NEW_LINE for i in range ( len ( v ) - 1 ) : NEW_LINE INDENT j = i + 1 NEW_LINE while ( j < len ( v ) ) : NEW_LINE INDENT temp = v [ j ] + v [ j ] NEW_LINE temp = temp [ j ] + v [ j ] NEW_LINE DEDENT if ( temp == str1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def isPossible ( v , str1 ) : NEW_LINE INDENT temp = str1 [ 0 ] NEW_LINE str1 = str1 [ 1 ] NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT temp = v1 [ i ] + str1 [ len ( v ) ] NEW_LINE if ( isPossible ( v , str1 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" amazon \" NEW_LINE str1 = \" fds \" NEW_LINE if ( isPossible ( v , str1 , str2 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def isPossible ( v , string ) : NEW_LINE INDENT char_list = list ( string ) NEW_LINE char_list . sort ( ) NEW_LINE for i in range ( len ( v ) - 1 ) : NEW_LINE INDENT for j in range ( len ( v ) ) : NEW_LINE INDENT temp = v [ i ] + v [ j ] ; NEW_LINE temp_list = list ( temp ) NEW_LINE temp_list . sort ( ) NEW_LINE if ( temp_list == char_list ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT DEDENT return False ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" amazon \" ; NEW_LINE v = [ \" fds \" , \" oxq \" , \" zoa \" , \" epw \" , \" amn \" ] ; NEW_LINE if ( isPossible ( v , string ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"],"bleu":0.43926905973499314,"rouge_l":0.6323602587493781}
{"id":942,"predictions":["def seriesSum ( n ) : NEW_LINE INDENT i = 1 NEW_LINE res = 0.0 NEW_LINE sign = True NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n -= 1 NEW_LINE if ( sign == 1 ) : NEW_LINE INDENT sign = False NEW_LINE res = res + ( float ) NEW_LINE res = res NEW_LINE DEDENT else : NEW_LINE INDENT sign = - 1 NEW_LINE res = res NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT n = 5 NEW_LINE print ( seriesSum ( n ) ) NEW_LINE"],"references":["def seriesSum ( n ) : NEW_LINE INDENT i = 1 ; NEW_LINE res = 0.0 ; NEW_LINE sign = True ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n = n - 1 ; NEW_LINE if ( sign ) : NEW_LINE INDENT sign = False ; NEW_LINE res = res + ( i + 1 ) \/ ( i + 2 ) ; NEW_LINE i = i + 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT sign = True ; NEW_LINE res = res - ( i + 1 ) \/ ( i + 2 ) ; NEW_LINE i = i + 2 ; NEW_LINE DEDENT DEDENT return res ; NEW_LINE DEDENT n = 5 ; NEW_LINE print ( round ( seriesSum ( n ) , 6 ) ) ; NEW_LINE"],"bleu":0.39772458977138997,"rouge_l":0.7035161744022503}
{"id":943,"predictions":["MAX = 1000000 NEW_LINE sieve_Prime = [ 0 ] * ( MAX + 4 ) NEW_LINE sieve_prime_count = [ 0 ] * ( MAX + 4 ) NEW_LINE def form_count ( ) : NEW_LINE INDENT sieve_Prime [ 1 ] = 1 NEW_LINE for i in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if ( sieve_Prime [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i * 2 , MAX + i ) : NEW_LINE INDENT if ( sieve_Prime [ j ] == 0 ) : NEW_LINE INDENT sieve_Prime [ j ] = 1 NEW_LINE sieve_count [ j ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def count ( cont_sum , n ) : NEW_LINE INDENT form_count = [ 0 ] * ( MAX + 1 ) NEW_LINE sieve_count [ 0 ] = 1 NEW_LINE while ( sieve_prime_count [ n ] + 1 ) : NEW_LINE INDENT if ( sieve_Prime [ j ] == 0 ) : NEW_LINE INDENT sieve_count [ j ] += 1 NEW_LINE sieve_count [ j ] += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT form_count ( ) NEW_LINE n = 2 NEW_LINE print ( \" Count ▁ = ▁ \" , sieve_count ( ) ) NEW_LINE DEDENT"],"references":["MAX = 1000000 NEW_LINE sieve_Prime = [ 0 for i in range ( MAX + 4 ) ] NEW_LINE sieve_count = [ 0 for i in range ( MAX + 4 ) ] NEW_LINE def form_sieve ( ) : NEW_LINE INDENT sieve_Prime [ 1 ] = 1 NEW_LINE for i in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if sieve_Prime [ i ] == 0 : NEW_LINE INDENT for j in range ( i * 2 , MAX + 1 , i ) : NEW_LINE INDENT if sieve_Prime [ j ] == 0 : NEW_LINE INDENT sieve_Prime [ j ] = 1 NEW_LINE sieve_count [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT form_sieve ( ) NEW_LINE n = 2 NEW_LINE print ( \" Count ▁ = \" , sieve_count [ n ] + 1 ) NEW_LINE n = 3 NEW_LINE print ( \" Count ▁ = \" , sieve_count [ n ] + 1 ) NEW_LINE"],"bleu":0.4963765331465181,"rouge_l":0.7013955937856579}
{"id":944,"predictions":["N = 4 NEW_LINE def MaximumDecimalValue ( mat , n ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE if ( mat [ 0 ] [ 0 ] == 1 ) : NEW_LINE INDENT dp [ 0 ] [ 1 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( mat [ i ] [ 0 ] == 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = ( dp [ i ] [ 0 ] + pow ( 2 , i ) ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ 0 ] = ( dp [ i - 1 ] [ 0 ] + pow ( 2 , i ) ) NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + pow ( 2 , i ) ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + pow ( 2 , i ) ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i ] [ j ] + pow ( 2 , i - 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j ] + pow ( 2 , i , j ) ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n - 1 ] [ n - 1 ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT mat = [ [ [ 1 , 1 , 0 , 1 , 0 ] , ["],"references":["N = 4 NEW_LINE def MaximumDecimalValue ( mat , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE if ( mat [ 0 ] [ 0 ] == 1 ) : NEW_LINE INDENT dp [ 0 ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( mat [ 0 ] [ i ] == 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + 2 ** i NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( mat [ i ] [ 0 ] == 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + 2 ** i NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) + ( 2 ** ( i + j ) ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n - 1 ] [ n - 1 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT mat = [ [ 1 , 1 , 0 , 1 ] , [ 0 , 1 , 1 , 0 ] , [ 1 , 0 , 0 , 1 ] , [ 1 , 0 , 1 , 1 ] ] NEW_LINE print ( MaximumDecimalValue ( mat , 4 ) ) NEW_LINE DEDENT"],"bleu":0.7311360975974414,"rouge_l":0.8068652113933296}
{"id":945,"predictions":["MAX = 1000001 NEW_LINE def checkB mm ( m , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( ( m [ i ] [ j ] != m [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( m [ i ] [ j ] != m [ n - j - 1 ] [ n - i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT DEDENT return True NEW_LINE DEDENT m = 3 NEW_LINE n = len ( m ) NEW_LINE if ( checkB mm ( m , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def checkBisymmetric ( m , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , i ) : NEW_LINE INDENT if ( m [ i ] [ j ] != m [ j ] [ i ] ) : NEW_LINE INDENT return false NEW_LINE DEDENT DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n - i ) : NEW_LINE INDENT if ( m [ i ] [ j ] != m [ n - j - 1 ] [ n - i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True ; NEW_LINE DEDENT n = 3 ; NEW_LINE m = [ [ 1 , 2 , 3 ] , [ 2 , 5 , 2 ] , [ 3 , 2 , 1 ] ] NEW_LINE if ( checkBisymmetric ( m , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.6599644117673217,"rouge_l":0.803214674900109}
{"id":946,"predictions":["import sys NEW_LINE INT_MAX = sys . maxsize ; NEW_LINE INT_MIN = - ( sys . maxsize - 1 ) ; NEW_LINE def Main ( a , n ) : NEW_LINE INDENT maxi = INT_MAX ; NEW_LINE mini = sys . maxsize ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT maxi = max ( a [ i ] , maxi ) ; NEW_LINE mini = min ( a [ i ] , mini ) ; NEW_LINE mini = min ( a [ i ] , mini ) ; NEW_LINE DEDENT return mini ; NEW_LINE DEDENT a = [ 3 , 7 , 9 , 3 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( Main ( a , n ) ) ; NEW_LINE"],"references":["def Divison ( a , n ) : NEW_LINE INDENT maxi = - 10 ** 9 NEW_LINE mini = 10 ** 9 NEW_LINE for i in a : NEW_LINE INDENT maxi = max ( i , maxi ) NEW_LINE mini = min ( i , mini ) NEW_LINE DEDENT return maxi \/\/ mini NEW_LINE DEDENT a = [ 3 , 7 , 9 , 3 , 11 ] NEW_LINE n = len ( a ) NEW_LINE print ( Divison ( a , n ) ) NEW_LINE"],"bleu":0.3739929106041481,"rouge_l":0.6893737246900016}
{"id":947,"predictions":["MAX = 10 NEW_LINE F = [ [ [ - 1 for col in range ( MAX ) ] for col in range ( MAX ) ] for row in range ( MAX ) ] NEW_LINE def noOfAssignments ( S , n , i , c_x ) : NEW_LINE INDENT if ( F [ i ] [ c_x ] [ c_x ] [ c_x ] != - 1 ) : NEW_LINE INDENT return F [ i ] [ c_x ] NEW_LINE DEDENT if ( i == n ) : NEW_LINE INDENT F [ i ] [ c_x ] = 0 NEW_LINE return F [ i ] [ c_x ] NEW_LINE DEDENT f [ i ] [ c_x ] [ c_x ] = 0 NEW_LINE return F [ i ] [ c_x ] [ c_y ] NEW_LINE DEDENT def noOfAssignments ( S , i , i + 1 , c_x ) : NEW_LINE INDENT if ( S [ i ] == [ c_x ] ) : NEW_LINE INDENT F [ i ] [ c_x ] [ c_x ] = noOfAssignments ( S , i + 1 , c_x , c_y ) NEW_LINE DEDENT F [ i ] [ c_x ] = 0 NEW_LINE if ( c_x == 1 ) : NEW_LINE INDENT F [ i ] [ c_x ] [ c_x ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT F [ i ] [ c_x ] +=  \\ NEW_LINE INDENT F [ i ] [ c_x ] [ c_x ] [ c_x ] NEW_LINE DEDENT DEDENT F [ i ] [ c_x ] [ c_x ] = 0 NEW_LINE DEDENT F [ i ] [ c_x ] [ c_x ] = 0 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = \" NEW_LINE n = len ( S ) NEW_LINE print ( noOfAssignments ( S , 0 , n , 0 , 0 ) ) NEW_LINE DEDENT"],"references":["MAX = 10 NEW_LINE F = [ [ - 1 for i in range ( MAX ) ] for j in range ( MAX ) ] NEW_LINE C = [ None ] * MAX NEW_LINE def noOfAssignments ( S , n , i , c_x ) : NEW_LINE INDENT if F [ i ] [ c_x ] != - 1 : NEW_LINE INDENT return F [ i ] [ c_x ] NEW_LINE DEDENT if i == n : NEW_LINE INDENT F [ i ] [ c_x ] = not c_x NEW_LINE return F [ i ] [ c_x ] NEW_LINE DEDENT c_y = C [ i ] - c_x NEW_LINE if S [ i ] == ' ( ' : NEW_LINE INDENT F [ i ] [ c_x ] =   \\ NEW_LINE INDENT noOfAssignments ( S , n , i + 1 , c_x + 1 ) +   \\ NEW_LINE noOfAssignments ( S , n , i + 1 , c_x ) NEW_LINE DEDENT return F [ i ] [ c_x ] NEW_LINE DEDENT F [ i ] [ c_x ] = 0 NEW_LINE if c_x : NEW_LINE INDENT F [ i ] [ c_x ] +=   \\ NEW_LINE INDENT noOfAssignments ( S , n , i + 1 , c_x - 1 ) NEW_LINE DEDENT DEDENT if c_y : NEW_LINE INDENT F [ i ] [ c_x ] +=   \\ NEW_LINE INDENT noOfAssignments ( S , n , i + 1 , c_x ) NEW_LINE DEDENT DEDENT return F [ i ] [ c_x ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = \" ( ) \" NEW_LINE n = len ( S ) NEW_LINE C [ 0 ] = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if S [ i ] == ' ( ' : NEW_LINE INDENT C [ i + 1 ] = C [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i + 1 ] = C [ i ] - 1 NEW_LINE DEDENT DEDENT print ( noOfAssignments ( S , n , 0 , 0 ) ) NEW_LINE DEDENT"],"bleu":0.5785240205905362,"rouge_l":0.6350050892939761}
{"id":948,"predictions":["def nextPowerOf2 ( n ) : NEW_LINE INDENT count = 0 NEW_LINE if ( n and not ( n and ( n & ( n - 1 ) ) ) ) : NEW_LINE INDENT return n NEW_LINE DEDENT while ( n ) : NEW_LINE INDENT n >>= 1 NEW_LINE count += 1 NEW_LINE DEDENT return 1 << count NEW_LINE DEDENT n = 0 NEW_LINE print ( nextPowerOf2 ( n ) ) NEW_LINE"],"references":["def nextPowerOf2 ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE if ( n and not ( n & ( n - 1 ) ) ) : NEW_LINE INDENT return n NEW_LINE DEDENT while ( n != 0 ) : NEW_LINE INDENT n >>= 1 NEW_LINE count += 1 NEW_LINE DEDENT return 1 << count ; NEW_LINE DEDENT n = 0 NEW_LINE print ( nextPowerOf2 ( n ) ) NEW_LINE"],"bleu":0.8751190563648793,"rouge_l":0.9444444444444445}
{"id":949,"predictions":["def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return gcd ( a - b , b ) NEW_LINE DEDENT return gcd ( a , b - a ) NEW_LINE DEDENT def nthElement ( a , b , n ) : NEW_LINE INDENT lcm = ( ( a * b ) \/ gcd ( a , b ) ) NEW_LINE lcm = 1 NEW_LINE r = 0 NEW_LINE while ( lcm > r ) : NEW_LINE INDENT mid = ( l + r ) \/\/ 2 NEW_LINE if ( val < n ) : NEW_LINE INDENT return max ( mid \/\/ a ) NEW_LINE DEDENT if ( val < n ) : NEW_LINE INDENT lcm = ( ( lcm \/\/ a ) * b ) NEW_LINE r = mid + 1 NEW_LINE DEDENT if ( val < n ) : NEW_LINE INDENT lcm = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = mid - 1 NEW_LINE DEDENT DEDENT DEDENT return 0 NEW_LINE DEDENT a = 5 NEW_LINE b = 3 NEW_LINE n = 5 NEW_LINE print ( nthElement ( a , b , n ) ) NEW_LINE"],"references":["import math NEW_LINE def nthElement ( a , b , n ) : NEW_LINE INDENT lcm = ( a * b ) \/ int ( math . gcd ( a , b ) ) NEW_LINE l = 1 NEW_LINE r = min ( a , b ) * n NEW_LINE while ( l <= r ) : NEW_LINE INDENT mid = ( l + r ) >> 1 NEW_LINE val = ( int ( mid \/ a ) + int ( mid \/ b ) - int ( mid \/ lcm ) ) NEW_LINE if ( val == n ) : NEW_LINE INDENT return int ( max ( int ( mid \/ a ) * a , int ( mid \/ b ) * b ) ) NEW_LINE DEDENT if ( val < n ) : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = mid - 1 NEW_LINE DEDENT DEDENT DEDENT a = 5 NEW_LINE b = 3 NEW_LINE n = 5 NEW_LINE print ( nthElement ( a , b , n ) ) NEW_LINE"],"bleu":0.46643227386592456,"rouge_l":0.6038647342995169}
{"id":950,"predictions":["MAX = 10000 NEW_LINE arr = [ ] NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime = [ True ] * ( MAX ) NEW_LINE p = 2 NEW_LINE while p * p < MAX : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT for p in range ( 2 , MAX , 1 ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT arr . append ( p ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE n = 31 NEW_LINE if allEuclid ( n ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT DEDENT"],"references":["MAX = 10000 NEW_LINE arr = [ ] NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime = [ True ] * MAX NEW_LINE p = 2 NEW_LINE while p * p < MAX : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT for p in range ( 2 , MAX ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT arr . append ( p ) NEW_LINE DEDENT DEDENT DEDENT def isEuclid ( n ) : NEW_LINE INDENT product = 1 NEW_LINE i = 0 NEW_LINE while ( product < n ) : NEW_LINE INDENT product = product * arr [ i ] NEW_LINE if ( product + 1 == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE n = 31 NEW_LINE if ( isEuclid ( n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT n = 42 NEW_LINE if ( isEuclid ( n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.5091211940067149,"rouge_l":0.7211596385542169}
{"id":951,"predictions":["def minElements ( arr , n ) : NEW_LINE INDENT halfSum = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT halfSum = halfSum + arr [ i ] NEW_LINE halfSum = halfSum \/ halfSum NEW_LINE DEDENT arr . sort ( ) NEW_LINE curr_sum = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT curr_sum += arr [ i ] NEW_LINE res += arr [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT arr = [ 3 , 1 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minElements ( arr , n ) ) NEW_LINE"],"references":["def minElements ( arr , n ) : NEW_LINE INDENT halfSum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT halfSum = halfSum + arr [ i ] NEW_LINE DEDENT halfSum = int ( halfSum \/ 2 ) NEW_LINE arr . sort ( reverse = True ) NEW_LINE res = 0 NEW_LINE curr_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_sum += arr [ i ] NEW_LINE res += 1 NEW_LINE if curr_sum > halfSum : NEW_LINE INDENT return res NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT arr = [ 3 , 1 , 7 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minElements ( arr , n ) ) NEW_LINE"],"bleu":0.6925230202696482,"rouge_l":0.8148543948704248}
{"id":952,"predictions":["def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def lcm ( a , b ) : NEW_LINE INDENT return ( a * b ) \/ gcd ( a , b ) NEW_LINE DEDENT def lcm ( a , b ) : NEW_LINE INDENT return ( a * b ) \/ gcd ( a , b ) NEW_LINE DEDENT a = 15 NEW_LINE b = 20 NEW_LINE print ( \" LCM ▁ of ▁ a ▁ and ▁ and ▁ and ▁ \" , lcm ( a , b ) ) NEW_LINE"],"references":["def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def lcm ( a , b ) : NEW_LINE INDENT return ( a * b ) \/ gcd ( a , b ) NEW_LINE DEDENT a = 15 NEW_LINE b = 20 NEW_LINE print ( ' LCM ▁ of ' , a , ' and ' , b , ' is ' , lcm ( a , b ) ) NEW_LINE"],"bleu":0.634124214309639,"rouge_l":0.7876614060258249}
{"id":953,"predictions":["MAX = 1000005 ; NEW_LINE prime = [ True ] * MAX ; NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 0 ] = False ; NEW_LINE prime [ 0 ] = False ; NEW_LINE prime [ 0 ] = False ; NEW_LINE for p in range ( 2 , MAX ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def prime_xor ( arr , n , k ) : NEW_LINE INDENT prime [ 0 ] = True ; NEW_LINE SieveOfEratosthenes ( ) ; NEW_LINE ans = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] % k == 0 ) : NEW_LINE INDENT ans ^= arr [ i ] ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 3 , 5 , 7 , 11 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE prime_xor ( arr , n , K ) ; NEW_LINE DEDENT"],"references":["MAX = 1000005 NEW_LINE def SieveOfEratosthenes ( prime ) : NEW_LINE INDENT prime [ 1 ] = False ; NEW_LINE prime [ 0 ] = False ; NEW_LINE for p in range ( 2 , int ( MAX ** ( 1 \/ 2 ) ) ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def prime_xor ( arr , n , k ) : NEW_LINE INDENT prime = [ True ] * MAX ; NEW_LINE SieveOfEratosthenes ( prime ) ; NEW_LINE ans = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] ) : NEW_LINE INDENT if ( ( i + 1 ) % k == 0 ) : NEW_LINE INDENT ans ^= arr [ i ] ; NEW_LINE DEDENT DEDENT DEDENT print ( ans ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 3 , 5 , 7 , 11 , 8 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE K = 2 ; NEW_LINE prime_xor ( arr , n , K ) ; NEW_LINE DEDENT"],"bleu":0.7919732961243633,"rouge_l":0.8583406240886556}
{"id":954,"predictions":["def computeTotient ( n ) : NEW_LINE INDENT phi = [ 0 ] * ( n + 1 ) ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT phi [ i ] = i ; NEW_LINE DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( phi [ p ] == p ) : NEW_LINE INDENT phi [ p ] = p - 1 ; NEW_LINE DEDENT for i in range ( p , n + 1 ) : NEW_LINE INDENT phi [ i ] = ( phi [ p ] \/\/ p ) ; NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( phi [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 12 ; NEW_LINE computeTotientientient ( n ) ; NEW_LINE DEDENT"],"references":["def computeTotient ( n ) : NEW_LINE INDENT phi = [ ] NEW_LINE for i in range ( n + 2 ) : NEW_LINE INDENT phi . append ( 0 ) NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT phi [ i ] = i NEW_LINE DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( phi [ p ] == p ) : NEW_LINE INDENT phi [ p ] = p - 1 NEW_LINE for i in range ( 2 * p , n + 1 , p ) : NEW_LINE INDENT phi [ i ] = ( phi [ i ] \/\/ p ) * ( p - 1 ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( \" Totient ▁ of ▁ \" , i , \" ▁ is ▁ \" , phi [ i ] ) NEW_LINE DEDENT DEDENT n = 12 NEW_LINE computeTotient ( n ) NEW_LINE"],"bleu":0.6559375147989196,"rouge_l":0.7794062382562947}
{"id":955,"predictions":["def countDigit ( n ) : NEW_LINE INDENT temp = n NEW_LINE count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT d = temp % 10 NEW_LINE temp \/= 10 NEW_LINE if ( d == 0 or d == 3 or d == 5 or d == 7 or d == 7 or d == 7 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT n = 12345 NEW_LINE print ( countDigit ( n ) ) NEW_LINE"],"references":["def countDigit ( n ) : NEW_LINE INDENT temp = n NEW_LINE count = 0 NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT d = temp % 10 NEW_LINE temp \/\/= 10 NEW_LINE if ( d == 2 or d == 3 or d == 5 or d == 7 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 1234567890 NEW_LINE print ( countDigit ( n ) ) NEW_LINE DEDENT"],"bleu":0.7008975851219521,"rouge_l":0.8115299334811529}
{"id":956,"predictions":["def getChar ( string ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT sum += ord ( string [ i ] ) - ord ( ' a ' ) NEW_LINE DEDENT if ( sum % 26 == 0 ) : NEW_LINE INDENT return \" z \" NEW_LINE DEDENT else : NEW_LINE INDENT return \"0\" NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" ffg \" NEW_LINE print ( getChar ( string ) ) NEW_LINE DEDENT"],"references":["def getChar ( strr ) : NEW_LINE INDENT summ = 0 NEW_LINE for i in range ( len ( strr ) ) : NEW_LINE INDENT summ += ( ord ( strr [ i ] ) - ord ( ' a ' ) + 1 ) NEW_LINE DEDENT if ( summ % 26 == 0 ) : NEW_LINE INDENT return ord ( ' z ' ) NEW_LINE DEDENT else : NEW_LINE INDENT summ = summ % 26 NEW_LINE return chr ( ord ( ' a ' ) + summ - 1 ) NEW_LINE DEDENT DEDENT strr = \" gfg \" NEW_LINE print ( getChar ( strr ) ) NEW_LINE"],"bleu":0.46731590710738613,"rouge_l":0.6860446697291304}
{"id":957,"predictions":["def count ( n , arr , l ) : NEW_LINE INDENT count = [ 0 for i in range ( n + 1 ) ] NEW_LINE count [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT no_ways = 0 NEW_LINE for j in range ( 0 , l ) : NEW_LINE INDENT if ( i - arr [ j ] >= 0 ) : NEW_LINE INDENT no_ways += count [ i - arr [ j ] ] NEW_LINE DEDENT DEDENT count_ways += 1 NEW_LINE DEDENT return count_ways NEW_LINE DEDENT arr = [ 1 , 3 , 5 ] NEW_LINE l = 5 NEW_LINE n = len ( arr ) NEW_LINE print ( count ( arr , n ) ) NEW_LINE"],"references":["def countWays ( n , arr ) : NEW_LINE INDENT count = [ 0 ] * ( n + 1 ) NEW_LINE count [ 0 ] = 1 NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT no_ways = 0 NEW_LINE for j in arr : NEW_LINE INDENT if ( i - j >= 0 ) : NEW_LINE INDENT no_ways += count [ i - j ] NEW_LINE DEDENT count [ i ] = no_ways NEW_LINE DEDENT DEDENT return count [ n ] NEW_LINE DEDENT arr = [ 1 , 3 , 5 ] NEW_LINE n = 5 NEW_LINE print ( countWays ( n , arr ) ) NEW_LINE"],"bleu":0.6038333926472709,"rouge_l":0.74051593323217}
{"id":958,"predictions":["import math NEW_LINE def primeOccurence ( arr , n , k ) : NEW_LINE INDENT Map = { } NEW_LINE for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT val = arr [ i ] NEW_LINE if val in Map : NEW_LINE INDENT Map [ val ] += 1 NEW_LINE Map [ val ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT Map [ val ] = 1 NEW_LINE DEDENT DEDENT if ( n > 2 and n % 2 == 0 ) : NEW_LINE INDENT Map [ val ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT Map [ val ] = 0 NEW_LINE DEDENT DEDENT def isPrimeOccure ( n ) : NEW_LINE INDENT if ( n % 2 == 0 or n % 2 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 11 , 11 , 11 , 23 , 41 , 50 , 51 , 50 , 51 , 51 ] NEW_LINE k = 2 NEW_LINE primeOccurence ( arr , k ) NEW_LINE DEDENT"],"references":["def primeOccurences ( arr , k ) : NEW_LINE INDENT map = { } NEW_LINE for val in arr : NEW_LINE INDENT freq = 0 NEW_LINE if val in map : NEW_LINE INDENT freq = map [ val ] NEW_LINE freq += 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq = 1 NEW_LINE DEDENT map [ val ] = freq NEW_LINE DEDENT for entry in map : NEW_LINE INDENT value = map [ entry ] NEW_LINE if isPrime ( value ) and value >= k : NEW_LINE INDENT print ( entry ) NEW_LINE DEDENT DEDENT DEDENT def isPrime ( n ) : NEW_LINE INDENT if ( n > 2 and not n % 2 ) or n == 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 3 , int ( n ** 0.5 + 1 ) , 2 ) : NEW_LINE INDENT if not n % i : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT arr = [ 11 , 11 , 11 , 23 , 11 , 37 , 37 , 51 , 51 , 51 , 51 , 51 ] NEW_LINE k = 2 NEW_LINE primeOccurences ( arr , k ) NEW_LINE"],"bleu":0.43291857581375515,"rouge_l":0.6514870577764593}
{"id":959,"predictions":["def Nth_Term ( n ) : NEW_LINE INDENT return ( 3 * pow ( n , 2 ) - n + 2 ) \/\/ ( 2 ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 5 ; NEW_LINE print ( Nth_Term ( N ) ) ; NEW_LINE DEDENT"],"references":["def Nth_Term ( n ) : NEW_LINE INDENT return ( 3 * pow ( n , 2 ) - n + 2 ) \/\/ ( 2 ) NEW_LINE DEDENT N = 5 NEW_LINE print ( Nth_Term ( N ) ) NEW_LINE"],"bleu":0.6126124664400904,"rouge_l":0.8547505126452494}
{"id":960,"predictions":["import math NEW_LINE def sum ( n ) : NEW_LINE INDENT root = math . sqrt ( n ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , root + 1 ) : NEW_LINE INDENT ans = ans + n \/\/ i NEW_LINE ans = 2 * ans NEW_LINE DEDENT return ans NEW_LINE DEDENT n = 35 NEW_LINE print ( sum ( n ) ) NEW_LINE"],"references":["import math NEW_LINE def sum ( n ) : NEW_LINE INDENT root = ( int ) ( math . sqrt ( n ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , root + 1 ) : NEW_LINE INDENT ans = ans + n \/\/ i NEW_LINE DEDENT ans = 2 * ans - ( root * root ) NEW_LINE return ans NEW_LINE DEDENT n = 35 NEW_LINE print ( sum ( n ) ) NEW_LINE"],"bleu":0.768150342096232,"rouge_l":0.9007600434310532}
{"id":961,"predictions":["class Solution ( object ) : NEW_LINE INDENT def __init__ ( self , num , data ) : NEW_LINE INDENT self . memo = { } NEW_LINE self . num = num NEW_LINE self . memo [ num ] = num NEW_LINE DEDENT def __init__ ( self , data ) : NEW_LINE INDENT self . memo [ num ] = 0 NEW_LINE for i in range ( len ( self . memo ) ) : NEW_LINE INDENT self . memo [ i ] = self . memo [ i ] + 1 NEW_LINE DEDENT self . memo [ num ] = 0 NEW_LINE DEDENT def findRandomBits ( self , n ) : NEW_LINE INDENT if ( self . memo [ n ] == 0 ) : NEW_LINE INDENT return None NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT number = int ( input ( ) ) NEW_LINE DEDENT for j in range ( number ) : NEW_LINE INDENT number = int ( input ( ) ) NEW_LINE if ( number == 0 ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( number != 0 ) : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT return result NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 0 NEW_LINE M = 4 NEW_LINE printcopyBits ( N ) NEW_LINE DEDENT"],"references":["from math import pow NEW_LINE def isAutoBio ( num ) : NEW_LINE INDENT autoStr = str ( num ) NEW_LINE for i in range ( 0 , len ( autoStr ) ) : NEW_LINE INDENT index = int ( autoStr [ i ] ) NEW_LINE cnt = 0 NEW_LINE for j in range ( 0 , len ( autoStr ) ) : NEW_LINE INDENT number = int ( autoStr [ j ] ) NEW_LINE if number == i : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if cnt != index : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def findAutoBios ( n ) : NEW_LINE INDENT low = int ( pow ( 10 , n - 1 ) ) NEW_LINE high = int ( pow ( 10 , n ) - 1 ) NEW_LINE flag = 0 NEW_LINE for i in range ( low , high + 1 ) : NEW_LINE INDENT if isAutoBio ( i ) : NEW_LINE INDENT flag = 1 NEW_LINE print ( i , end = ' , ▁ ' ) NEW_LINE DEDENT DEDENT if flag == 0 : NEW_LINE INDENT print ( \" There ▁ is ▁ no ▁ Autobiographical ▁ Number ▁ with ▁ \" + str ( n ) + \" ▁ digits \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 0 NEW_LINE findAutoBios ( N ) NEW_LINE N = 4 NEW_LINE findAutoBios ( N ) NEW_LINE DEDENT"],"bleu":0.35464384011863354,"rouge_l":0.470111245141402}
{"id":962,"predictions":["def isLucky ( n ) : NEW_LINE INDENT arr = [ 0 ] * 10 NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ i ] = n % 10 NEW_LINE DEDENT while ( n ) : NEW_LINE INDENT digit = n % 10 NEW_LINE if ( arr [ digit ] == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT arr [ digit ] = True NEW_LINE n = n \/\/ 10 NEW_LINE DEDENT return True NEW_LINE DEDENT if ( isLucky ( arr ) ) : NEW_LINE INDENT print ( arr [ 0 ] , end = \" ▁ \" ) NEW_LINE DEDENT for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT if ( isLucky ( arr [ i ] ) ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1261 , 887 , 45 , 1234 , 80 ] NEW_LINE DEDENT"],"references":["import math NEW_LINE def isLucky ( n ) : NEW_LINE INDENT ar = [ 0 ] * 10 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT digit = math . floor ( n % 10 ) NEW_LINE if ( ar [ digit ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ar [ digit ] = 1 NEW_LINE n = n \/ 10 NEW_LINE DEDENT return 1 NEW_LINE DEDENT arr = [ 1291 , 897 , 4566 , 1232 , 80 , 700 ] NEW_LINE n = len ( arr ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT k = arr [ i ] NEW_LINE if ( isLucky ( k ) ) : NEW_LINE INDENT print ( k , \" ▁ is ▁ Lucky ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( k , \" ▁ is ▁ not ▁ Lucky ▁ \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.3846669015776943,"rouge_l":0.5878555389221557}
{"id":963,"predictions":["def printSeriesSum ( N ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( i % 2 == 1 ) : NEW_LINE INDENT sum += ( i \/\/ ( i + 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT sum -= ( i \/ ( i + 1 ) ) NEW_LINE DEDENT DEDENT print ( sum ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 10 NEW_LINE printSeriesSum ( N ) NEW_LINE DEDENT"],"references":["def printSeriesSum ( N ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( i & 1 ) : NEW_LINE INDENT sum += i \/ ( i + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT sum -= i \/ ( i + 1 ) ; NEW_LINE DEDENT DEDENT print ( sum ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 10 ; NEW_LINE printSeriesSum ( N ) ; NEW_LINE DEDENT"],"bleu":0.7066816185986461,"rouge_l":0.8969072164948454}
{"id":964,"predictions":["def __gcd ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( y == 1 ) : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT p = power ( x , y ) % m NEW_LINE p = ( p * p ) % m NEW_LINE DEDENT p = ( p * p ) % m NEW_LINE return ( ( p * p ) % m ) NEW_LINE DEDENT DEDENT def modInverse ( a , m , m ) : NEW_LINE INDENT if ( modInverse ( a , m ) != 1 ) : NEW_LINE INDENT return ( modInverse ( a , m - 2 , m ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( modInverse ( a , m - 2 , m ) ) % m NEW_LINE DEDENT DEDENT a = 3 NEW_LINE m = 11 NEW_LINE modInverse ( a , m - 2 , m ) NEW_LINE print ( \" Modular ▁ inverse ▁ inverse ▁ is ▁ \" , powerInverse ( a , m - 2 , m ) ) NEW_LINE"],"references":["def __gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return __gcd ( b , a % b ) NEW_LINE DEDENT DEDENT def power ( x , y , m ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT p = power ( x , y \/\/ 2 , m ) % m NEW_LINE p = ( p * p ) % m NEW_LINE return p if ( y % 2 == 0 ) else ( x * p ) % m NEW_LINE DEDENT def modInverse ( a , m ) : NEW_LINE INDENT if ( __gcd ( a , m ) != 1 ) : NEW_LINE INDENT print ( \" Inverse ▁ doesn ' t ▁ exist \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Modular ▁ multiplicative ▁ inverse ▁ is ▁ \" , power ( a , m - 2 , m ) ) NEW_LINE DEDENT DEDENT a = 3 NEW_LINE m = 11 NEW_LINE modInverse ( a , m ) NEW_LINE"],"bleu":0.6598484825583715,"rouge_l":0.6487170830519919}
{"id":965,"predictions":["import math NEW_LINE def __gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return b NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT res = 0 NEW_LINE while ( x % 2 == 0 ) : NEW_LINE INDENT x = x \/\/ 2 NEW_LINE DEDENT if ( x % i == 0 ) : NEW_LINE INDENT while ( x % i == 0 ) : NEW_LINE INDENT x = x \/\/ i NEW_LINE DEDENT DEDENT if ( x % i == 0 ) : NEW_LINE INDENT while ( x % i == 0 ) : NEW_LINE INDENT x = x \/\/ i NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( x > 2 ) : NEW_LINE INDENT return res + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def countCommon ( a , b ) : NEW_LINE INDENT gcd = __gcd ( a , b ) NEW_LINE if ( x % i == 0 ) : NEW_LINE INDENT return countPrime [ 0 ] NEW_LINE DEDENT return countPrimeFactors ( a , b ) NEW_LINE DEDENT a = 6 NEW_LINE b = 12 NEW_LINE print ( countPrimeFactors ( a , b ) ) NEW_LINE"],"references":["from math import sqrt , gcd NEW_LINE def countPrimeFactors ( x ) : NEW_LINE INDENT res = 0 NEW_LINE if ( x % 2 == 0 ) : NEW_LINE INDENT res += 1 NEW_LINE while ( x % 2 == 0 ) : NEW_LINE INDENT x = x \/ 2 NEW_LINE DEDENT DEDENT k = int ( sqrt ( x ) ) + 1 NEW_LINE for i in range ( 3 , k , 2 ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT res += 1 NEW_LINE while ( x % i == 0 ) : NEW_LINE INDENT x = x \/ i NEW_LINE DEDENT DEDENT DEDENT if ( x > 2 ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT def countCommonPrimeFactors ( a , b ) : NEW_LINE INDENT gcd__ = gcd ( a , b ) NEW_LINE return countPrimeFactors ( gcd__ ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 6 NEW_LINE b = 12 NEW_LINE print ( countCommonPrimeFactors ( a , b ) ) NEW_LINE DEDENT"],"bleu":0.4261849248097179,"rouge_l":0.6058377558756635}
{"id":966,"predictions":["def factorial ( n ) : NEW_LINE INDENT if n == 1 or n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return n * factorial ( n - 1 ) NEW_LINE DEDENT DEDENT num = 5 NEW_LINE print ( \" Factorial ▁ of \" , num , \" is \" , factorial ( num ) ) NEW_LINE"],"references":["def factorial ( n ) : NEW_LINE INDENT return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 ) NEW_LINE DEDENT num = 5 NEW_LINE print ( \" Factorial ▁ of \" , num , \" is \" , factorial ( num ) ) NEW_LINE"],"bleu":0.7522046963685017,"rouge_l":0.8751054852320673}
{"id":967,"predictions":["def getFirstDigit ( x ) : NEW_LINE INDENT while ( x >= 10 ) : NEW_LINE INDENT x = x \/\/ 10 NEW_LINE DEDENT return x NEW_LINE DEDENT def getFirstDigit ( x ) : NEW_LINE INDENT if ( x < 10 ) : NEW_LINE INDENT return x NEW_LINE DEDENT digit = x \/\/ 10 NEW_LINE res = getFirstDigit ( x % 10 ) NEW_LINE if ( lastDigit ( res ) ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT def getCount ( start , end ) : NEW_LINE INDENT return getCount ( start ) NEW_LINE DEDENT if ( start == 10 ) : NEW_LINE INDENT return getCount ( int ) ( getCount ( start , end ) ) NEW_LINE DEDENT return getCountWithOne ( start , end ) - getCount ( start , end ) NEW_LINE DEDENT start = 5 NEW_LINE end = 40 NEW_LINE print ( getCountWithOne ( start , end ) ) NEW_LINE start = 40 NEW_LINE end = 40 NEW_LINE print ( getCount ( start , end = \" \" ) NEW_LINE"],"references":["def getFirstDigit ( x ) : NEW_LINE INDENT while ( x >= 10 ) : NEW_LINE INDENT x \/= 10 NEW_LINE DEDENT return x NEW_LINE DEDENT def getCountWithSameStartAndEndFrom1 ( x ) : NEW_LINE INDENT if ( x < 10 ) : NEW_LINE INDENT return x NEW_LINE DEDENT tens = x \/ 10 NEW_LINE res = tens + 9 NEW_LINE firstDigit = getFirstDigit ( x ) NEW_LINE lastDigit = x % 10 NEW_LINE if ( lastDigit < firstDigit ) : NEW_LINE INDENT res = res - 1 NEW_LINE DEDENT return res NEW_LINE DEDENT def getCountWithSameStartAndEnd ( start , end ) : NEW_LINE INDENT return ( getCountWithSameStartAndEndFrom1 ( end ) - getCountWithSameStartAndEndFrom1 ( start - 1 ) ) NEW_LINE DEDENT start = 5 NEW_LINE end = 40 NEW_LINE print ( getCountWithSameStartAndEnd ( start , end ) ) NEW_LINE"],"bleu":0.5062173719167361,"rouge_l":0.7114273485983309}
{"id":968,"predictions":["def find_number ( N , K ) : NEW_LINE INDENT r = r NEW_LINE if ( N % 100 == 0 ) : NEW_LINE INDENT N += 1 ; NEW_LINE r = str ( N ) NEW_LINE DEDENT else : NEW_LINE INDENT r = str ( N ) NEW_LINE for i in range ( 1 , K + 1 ) : NEW_LINE INDENT r = str ( N ) NEW_LINE DEDENT return r NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 1000 NEW_LINE K = 2 NEW_LINE ans = find_number ( N , K ) NEW_LINE print ( ans ) NEW_LINE DEDENT"],"references":["def find_number ( N , K ) : NEW_LINE INDENT r = \" \" NEW_LINE if ( N % 100 == 0 ) : NEW_LINE INDENT N += 1 ; NEW_LINE r = str ( N ) NEW_LINE DEDENT else : NEW_LINE INDENT r = str ( N ) NEW_LINE DEDENT for i in range ( 1 , K + 1 ) : NEW_LINE INDENT r += \"00\" NEW_LINE DEDENT return r NEW_LINE DEDENT N = 1000 NEW_LINE K = 2 ; NEW_LINE ans = find_number ( N , K ) NEW_LINE print ( ans ) NEW_LINE"],"bleu":0.754995307743212,"rouge_l":0.8822314049586776}
{"id":969,"predictions":["def digitSum ( n , arr1 , n , m ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT sum += n % 10 NEW_LINE n = n \/\/ 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT def totalPairs ( arr1 , arr2 , n , m ) : NEW_LINE INDENT s = set ( ) NEW_LINE while ( n ) : NEW_LINE INDENT if ( digitSum ( arr1 [ i ] ) == digitSum ) : NEW_LINE INDENT s . add ( arr2 [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT s . add ( arr1 [ i ] ) NEW_LINE DEDENT DEDENT return len ( s ) NEW_LINE DEDENT arr1 = [ 100 , 3 , 7 , 4 ] NEW_LINE arr2 = [ 5 , 1 , 4 ] NEW_LINE n = len ( arr1 ) NEW_LINE m = len ( arr2 ) NEW_LINE print ( totalPairs ( arr1 , arr2 , n , m ) ) NEW_LINE"],"references":["def digitSum ( n ) : NEW_LINE INDENT Sum = 0 NEW_LINE while n > 0 : NEW_LINE INDENT Sum += n % 10 NEW_LINE n = n \/\/ 10 NEW_LINE DEDENT return Sum NEW_LINE DEDENT def totalPairs ( arr1 , arr2 , n , m ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , m ) : NEW_LINE INDENT if digitSum ( arr1 [ i ] ) == digitSum ( arr2 [ j ] ) : NEW_LINE INDENT if arr1 [ i ] < arr2 [ j ] : NEW_LINE INDENT s . add ( ( arr1 [ i ] , arr2 [ j ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT s . add ( ( arr2 [ j ] , arr1 [ i ] ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return len ( s ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr1 = [ 100 , 3 , 7 , 50 ] NEW_LINE arr2 = [ 5 , 1 , 10 , 4 ] NEW_LINE n = len ( arr1 ) NEW_LINE m = len ( arr2 ) NEW_LINE print ( totalPairs ( arr1 , arr2 , n , m ) ) NEW_LINE DEDENT"],"bleu":0.5732338644927761,"rouge_l":0.7589500722427357}
{"id":970,"predictions":["N = 5 NEW_LINE def func ( idx , curr , dp , n , x ) : NEW_LINE INDENT if ( idx == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ idx ] [ curr ] != - 1 ) : NEW_LINE INDENT return dp [ idx ] NEW_LINE DEDENT ans = 0 NEW_LINE if ( curr == 0 ) : NEW_LINE INDENT return dp [ idx ] NEW_LINE DEDENT ans = 0 NEW_LINE if ( curr == 0 ) : NEW_LINE INDENT ans = max ( ans , a ) NEW_LINE DEDENT elif ( curr == 1 ) : NEW_LINE INDENT ans = max ( ans , a [ idx ] + func ( idx + 1 , 1 , a , dp , n , x ) ) NEW_LINE DEDENT dp [ idx ] = max ( ans , a [ idx ] + func ( idx + 1 , a , dp , n , x ) + func ( idx + 1 , a , dp , n , x ) ) NEW_LINE return dp [ idx ] [ curr ] NEW_LINE DEDENT def getMaximumSum ( a , n , x ) : NEW_LINE INDENT dp [ idx ] [ curr ] = ans NEW_LINE return max ( ans , a [ idx ] + func ( idx + 1 , a , n , x ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT dp = [ - 3 , 8 , - 2 , 1 , - 6 ] NEW_LINE n = len ( a ) NEW_LINE x = - 1 NEW_LINE print ( getMaximumSum ( a , n , x ) ) NEW_LINE DEDENT"],"references":["N = 5 NEW_LINE def func ( idx , cur , a , dp , n , x ) : NEW_LINE INDENT if ( idx == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ idx ] [ cur ] != - 1 ) : NEW_LINE INDENT return dp [ idx ] [ cur ] NEW_LINE DEDENT ans = 0 NEW_LINE if ( cur == 0 ) : NEW_LINE INDENT ans = max ( ans , a [ idx ] + func ( idx + 1 , 0 , a , dp , n , x ) ) NEW_LINE ans = max ( ans , x * a [ idx ] + func ( idx + 1 , 1 , a , dp , n , x ) ) NEW_LINE DEDENT elif ( cur == 1 ) : NEW_LINE INDENT ans = max ( ans , x * a [ idx ] + func ( idx + 1 , 1 , a , dp , n , x ) ) NEW_LINE ans = max ( ans , a [ idx ] + func ( idx + 1 , 2 , a , dp , n , x ) ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( ans , a [ idx ] + func ( idx + 1 , 2 , a , dp , n , x ) ) NEW_LINE DEDENT dp [ idx ] [ cur ] = ans NEW_LINE return dp [ idx ] [ cur ] NEW_LINE DEDENT def getMaximumSum ( a , n , x ) : NEW_LINE INDENT dp = [ [ - 1 for i in range ( 3 ) ] for j in range ( n ) ] NEW_LINE maxi = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT maxi = max ( maxi , func ( i , 0 , a , dp , n , x ) ) NEW_LINE DEDENT return maxi NEW_LINE DEDENT a = [ - 3 , 8 , - 2 , 1 , - 6 ] NEW_LINE n = len ( a ) NEW_LINE x = - 1 NEW_LINE print ( getMaximumSum ( a , n , x ) ) NEW_LINE"],"bleu":0.6180272808777507,"rouge_l":0.7093361292474859}
{"id":971,"predictions":["def exponent ( A , B ) : NEW_LINE INDENT if ( A == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( B == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( B % 2 == 0 ) : NEW_LINE INDENT y = exponent ( A , B \/\/ 2 ) NEW_LINE y = ( y * y ) NEW_LINE if ( B % 2 == 0 ) : NEW_LINE INDENT y = exponent ( A , B \/\/ 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT y = A * exponent ( A , B - 1 ) NEW_LINE DEDENT DEDENT return y NEW_LINE DEDENT def sum ( k , n ) : NEW_LINE INDENT sum = exponent ( k , n + 1 ) NEW_LINE return sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE K = 3 NEW_LINE print ( sum ( K , n ) ) NEW_LINE DEDENT"],"references":["def exponent ( A , B ) : NEW_LINE INDENT if ( A == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( B == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT if ( B % 2 == 0 ) : NEW_LINE INDENT y = exponent ( A , B \/ 2 ) ; NEW_LINE y = ( y * y ) ; NEW_LINE DEDENT else : NEW_LINE INDENT y = A ; NEW_LINE y = ( y * exponent ( A , B - 1 ) ) ; NEW_LINE DEDENT return y ; NEW_LINE DEDENT def sum ( k , n ) : NEW_LINE INDENT sum = exponent ( k , n + 1 ) - exponent ( k - 1 , n + 1 ) ; NEW_LINE return sum ; NEW_LINE DEDENT n = 3 ; NEW_LINE K = 3 ; NEW_LINE print ( sum ( K , n ) ) ; NEW_LINE"],"bleu":0.6611680276952432,"rouge_l":0.8035126234906695}
{"id":972,"predictions":["import math NEW_LINE primes = [ ] ; NEW_LINE def sieve ( ) : NEW_LINE INDENT n = ( int ) ( math . sqrt ( n ) ) ; NEW_LINE marked = [ False ] * ( n + 100 ) ; NEW_LINE marked [ 0 ] = [ True ] * ( n + 1 ) ; NEW_LINE for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : NEW_LINE INDENT for j in range ( i * ( i + 1 ) , ( i + 1 ) >> 1 ) : NEW_LINE INDENT marked [ j ] = True ; NEW_LINE DEDENT DEDENT for i in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( marked [ i ] == False ) : NEW_LINE INDENT primes [ i ] = True ; NEW_LINE DEDENT DEDENT DEDENT def primeLcm ( arr , n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) ; NEW_LINE primes = [ False ] * ( n + 1 ) ; NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT if ( prime [ i ] == 0 ) : NEW_LINE INDENT primes [ i ] = 1 ; NEW_LINE DEDENT DEDENT if ( copy > 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n + 1 ) : NEW_LINE INDENT if ( copy % primes [ j ] == 0 ) : NEW_LINE INDENT copy = ( copy \/\/ primes [ j ] ) ; NEW_LINE copy = ( copy \/\/ primes [ primes [ j ] ] + 1 ) ; NEW_LINE DEDENT DEDENT DEDENT if ( copy > 1 ) : NEW_LINE INDENT for i in range ( i + 2 ) : NEW_LINE INDENT if ( copy % primes [ i ] == 0 ) : NEW_LINE INDENT copy = 1 ; NEW_LINE DEDENT DEDENT DEDENT if ( copy > 1 ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" :"],"references":["import math ; NEW_LINE MAX = 10000 ; NEW_LINE primes = [ ] ; NEW_LINE def sieve ( ) : NEW_LINE INDENT n = MAX ; NEW_LINE nNew = int ( n \/ 2 ) ; NEW_LINE marked = [ False ] * ( nNew + 100 ) ; NEW_LINE tmp = int ( math . sqrt ( n ) ) ; NEW_LINE for i in range ( 1 , int ( ( tmp - 1 ) \/ 2 ) + 1 ) : NEW_LINE INDENT for j in range ( ( i * ( i + 1 ) ) << 1 , nNew + 1 , 2 * i + 1 ) : NEW_LINE INDENT marked [ j ] = True ; NEW_LINE DEDENT DEDENT primes . append ( 2 ) ; NEW_LINE for i in range ( 1 , nNew + 1 ) : NEW_LINE INDENT if ( marked [ i ] == False ) : NEW_LINE INDENT primes . append ( 2 * i + 1 ) ; NEW_LINE DEDENT DEDENT DEDENT def primeLcm ( arr , n ) : NEW_LINE INDENT factors = [ 0 ] * ( MAX ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT copy = arr [ i ] ; NEW_LINE sqr = int ( math . sqrt ( copy ) ) ; NEW_LINE j = 0 ; NEW_LINE while ( primes [ j ] <= sqr ) : NEW_LINE INDENT if ( copy % primes [ j ] == 0 ) : NEW_LINE INDENT while ( copy % primes [ j ] == 0 ) : NEW_LINE INDENT copy = int ( copy \/ primes [ j ] ) ; NEW_LINE DEDENT factors [ primes [ j ] ] = 1 ; NEW_LINE DEDENT j += 1 ; NEW_LINE DEDENT if ( copy > 1 ) : NEW_LINE INDENT factors [ copy ] = 1 ; NEW_LINE DEDENT DEDENT if ( factors [ 2 ] == 1 ) : NEW_LINE INDENT print ( \"2 ▁ \" , end = \" \" ) ; NEW_LINE DEDENT for i in range ( 3 , MAX + 1 , 2 ) : NEW_LINE INDENT if ( factors [ i ] == 1 ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT DEDENT sieve ( ) ; NEW_LINE arr = [ 20 , 10 , 15 , 60 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE primeLcm ( arr , n ) ; NEW_LINE"],"bleu":0.5711770219579765,"rouge_l":0.6054224158799323}
{"id":973,"predictions":["import math NEW_LINE def compute ( n ) : NEW_LINE INDENT _n = n NEW_LINE ans = math . floor ( ( math . sqrt ( n ) \/ 12 ) - math . floor ( ( ( _n * _n \/ 12 ) ) * math . floor ( _n \/ 4 ) ) NEW_LINE return ( ans ) ; NEW_LINE DEDENT def solve ( n ) : NEW_LINE INDENT i = 0 NEW_LINE while i <= n : NEW_LINE INDENT print ( \" , end = \" , \" , ▁ \" ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 15 NEW_LINE solve ( n ) NEW_LINE DEDENT"],"references":["from math import ceil , floor NEW_LINE def Alcuin ( n ) : NEW_LINE INDENT _n = n NEW_LINE ans = 0 NEW_LINE ans = ( round ( ( _n * _n ) \/ 12 ) - floor ( _n \/ 4 ) * floor ( ( _n + 2 ) \/ 4 ) ) NEW_LINE return ans NEW_LINE DEDENT def solve ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( Alcuin ( i ) , end = \" , ▁ \" ) NEW_LINE DEDENT DEDENT n = 15 NEW_LINE solve ( n ) NEW_LINE"],"bleu":0.47929999288787195,"rouge_l":0.6610580350777129}
{"id":974,"predictions":["def getM ( n ) : NEW_LINE INDENT global n NEW_LINE n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 7 NEW_LINE n |= n >> 16 NEW_LINE return ( ( n + 1 ) >> 1 ) NEW_LINE DEDENT def multiply ( F , M ) : NEW_LINE INDENT x = [ [ 0 for i in range ( n + 2 ) ] for j in range ( M ) ] NEW_LINE y = [ 0 for i in range ( n + 1 ) ] NEW_LINE z = [ [ 0 for i in range ( n + 1 ) ] for j in range ( m ) ] NEW_LINE y [ 0 ] [ 1 ] = 1 NEW_LINE for i in range ( M ) : NEW_LINE INDENT x [ i ] [ 0 ] = ( F [ i ] [ 1 ] * M [ 0 ] [ 0 ] + F [ i ] [ 1 ] * F [ i ] [ 1 ] ) NEW_LINE y [ i ] [ 1 ] = ( F [ i ] [ 1 ] + F [ i ] [ 1 ] ) NEW_LINE DEDENT DEDENT def multiply ( F , n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT M = 0 NEW_LINE F = [ [ [ 1 , 1 ] , [ 1 , 0 ] ] NEW_LINE if ( ( n == 0 or n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return F NEW_LINE DEDENT def multiply ( F , n ) : NEW_LINE INDENT M = [ [ 1 , 1 ] , [ 1 , 0 ] ] NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT M = [ [ 1 , 1 ] , [ 1 , 0 ] ] NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return M NEW_LINE DEDENT power ( F , n - 1 ) NEW_LINE return F [ 0 ] [ 0 ] NEW_LINE DEDENT def fib ( n ) : NEW_LINE INDENT M = [ [ 1 , 1 , 0 ] , [ 1 , 0 ] ]"],"references":["def getMSB ( n ) : NEW_LINE INDENT n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE return ( ( n + 1 ) >> 2 ) NEW_LINE DEDENT def multiply ( F , M ) : NEW_LINE INDENT x = F [ 0 ] [ 0 ] * M [ 0 ] [ 0 ] + F [ 0 ] [ 1 ] * M [ 1 ] [ 0 ] NEW_LINE y = F [ 0 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 0 ] [ 1 ] * M [ 1 ] [ 1 ] NEW_LINE z = F [ 1 ] [ 0 ] * M [ 0 ] [ 0 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 0 ] NEW_LINE w = F [ 1 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 1 ] NEW_LINE F [ 0 ] [ 0 ] = x NEW_LINE F [ 0 ] [ 1 ] = y NEW_LINE F [ 1 ] [ 0 ] = z NEW_LINE F [ 1 ] [ 1 ] = w NEW_LINE DEDENT def power ( F , n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT M = [ [ 1 , 1 ] , [ 1 , 0 ] ] NEW_LINE m = getMSB ( n ) NEW_LINE while m : NEW_LINE INDENT multiply ( F , F ) NEW_LINE if ( n & m ) : NEW_LINE INDENT multiply ( F , M ) NEW_LINE DEDENT m = m >> 1 NEW_LINE DEDENT DEDENT def fib ( n ) : NEW_LINE INDENT F = [ [ 1 , 1 ] , [ 1 , 0 ] ] NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT power ( F , n - 1 ) NEW_LINE return F [ 0 ] [ 0 ] NEW_LINE DEDENT n = 6 NEW_LINE print ( fib ( n ) ) NEW_LINE"],"bleu":0.5647899281816156,"rouge_l":0.6550403729293266}
{"id":975,"predictions":["def printMinIndex ( str , patt ) : NEW_LINE INDENT m = len ( str ) NEW_LINE n = len ( str ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( patt [ i ] == str [ j ] and j < minIndex ) : NEW_LINE INDENT minIndex = j NEW_LINE break NEW_LINE DEDENT DEDENT elif ( str [ i ] == str [ j ] and j < minIndex ) : NEW_LINE INDENT minIndex = j NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if ( minIndex != sys . maxsize ) : NEW_LINE INDENT print ( \" Minimum ▁ Character ▁ at ▁ Index \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No ▁ Character ▁ in ▁ base ▁ character \" ) NEW_LINE DEDENT DEDENT str = \" geeksforgeeks \" NEW_LINE pattend ( str , patt ) NEW_LINE"],"references":["def printMinIndexChar ( Str , patt ) : NEW_LINE INDENT minIndex = 10 ** 9 NEW_LINE m = len ( Str ) NEW_LINE n = len ( patt ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( patt [ i ] == Str [ j ] and j < minIndex ) : NEW_LINE INDENT minIndex = j NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if ( minIndex != 10 ** 9 ) : NEW_LINE INDENT print ( \" Minimum ▁ Index ▁ Character ▁ = ▁ \" , Str [ minIndex ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No ▁ character ▁ present \" ) NEW_LINE DEDENT DEDENT Str = \" geeksforgeeks \" NEW_LINE patt = \" set \" NEW_LINE printMinIndexChar ( Str , patt ) NEW_LINE"],"bleu":0.6081775085193794,"rouge_l":0.7450381679389313}
{"id":976,"predictions":["from math import ceil , floor NEW_LINE def squares ( l , b , a ) : NEW_LINE INDENT return ceil ( ( l \/ ( a ) ) * ceil ( b \/ ( a ) ) ) NEW_LINE DEDENT l = 11 NEW_LINE b = 14 NEW_LINE print ( squares ( l , b , a ) ) NEW_LINE"],"references":["import math NEW_LINE def squares ( l , b , a ) : NEW_LINE INDENT return math . ceil ( l \/ a ) * math . ceil ( b \/ a ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT l = 11 NEW_LINE b = 23 NEW_LINE a = 14 NEW_LINE print ( squares ( l , b , a ) ) NEW_LINE DEDENT"],"bleu":0.5262802315359449,"rouge_l":0.7344088610642908}
{"id":977,"predictions":["class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . prev = None NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def push ( head_ref , new_data ) : NEW_LINE INDENT new_node = Node ( new_data ) NEW_LINE new_node . next = head_ref NEW_LINE if head_ref != None : NEW_LINE INDENT head_ref . prev = new_node NEW_LINE head_ref = head_ref NEW_LINE head_ref = new_node NEW_LINE DEDENT while head_ref != None : NEW_LINE INDENT head_ref . prev = head_ref NEW_LINE head_ref . next = head_ref NEW_LINE head_ref = head_ref NEW_LINE if head_ref != None : NEW_LINE INDENT head_ref . prev = head_ref NEW_LINE DEDENT else : NEW_LINE INDENT head_ref . next = head_ref NEW_LINE head_ref = head_ref NEW_LINE DEDENT head_ref = head_ref NEW_LINE return head_ref NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = None NEW_LINE head = head_ref NEW_LINE head = head_ref NEW_LINE head . next = head_ref NEW_LINE head_ref = head_ref NEW_LINE print ( head_ref ) NEW_LINE DEDENT"],"references":["def append ( self , new_data ) : NEW_LINE INDENT new_node = Node ( data = new_data ) NEW_LINE last = self . head NEW_LINE new_node . next = None NEW_LINE if self . head is None : NEW_LINE INDENT new_node . prev = None NEW_LINE self . head = new_node NEW_LINE return NEW_LINE DEDENT while ( last . next is not None ) : NEW_LINE INDENT last = last . next NEW_LINE DEDENT last . next = new_node NEW_LINE new_node . prev = last NEW_LINE DEDENT"],"bleu":0.21175506115823825,"rouge_l":0.422228026642288}
{"id":978,"predictions":["import sys NEW_LINE def maxProductSum ( strr , m ) : NEW_LINE INDENT n = len ( strr ) NEW_LINE maxProd = - float ( ' inf ' ) NEW_LINE maxSum = - float ( ' inf ' ) NEW_LINE for i in range ( n - m + 1 ) : NEW_LINE INDENT product = 1 NEW_LINE for j in range ( i , m ) : NEW_LINE INDENT product = product * ( ord ( strr [ j ] ) - ord ( '0' ) ) NEW_LINE sum = product + ( ord ( str [ j ] ) - ord ( '0' ) ) NEW_LINE DEDENT maxProd = ( maxProd , product ) NEW_LINE maxSum = max ( maxSum , product ) NEW_LINE maxSum = max ( maxProd , product ) NEW_LINE DEDENT DEDENT print ( \" Maximum ▁ product ▁ = \" , maxSum ) NEW_LINE print ( \" Maximum ▁ product ▁ = \" , maxProductSum ( strr , m ) ) NEW_LINE"],"references":["import sys NEW_LINE def maxProductSum ( string , m ) : NEW_LINE INDENT n = len ( string ) NEW_LINE maxProd , maxSum = ( - ( sys . maxsize ) - 1 , - ( sys . maxsize ) - 1 ) NEW_LINE for i in range ( n - m ) : NEW_LINE INDENT product , sum = 1 , 0 NEW_LINE for j in range ( i , m + i ) : NEW_LINE INDENT product = product * ( ord ( string [ j ] ) - ord ( '0' ) ) NEW_LINE sum = sum + ( ord ( string [ j ] ) - ord ( '0' ) ) NEW_LINE DEDENT maxProd = max ( maxProd , product ) NEW_LINE maxSum = max ( maxSum , sum ) NEW_LINE DEDENT print ( \" Maximum ▁ Product ▁ = \" , maxProd ) NEW_LINE print ( \" Maximum ▁ sum ▁ = \" , maxSum ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \"3675356291\" NEW_LINE m = 5 NEW_LINE maxProductSum ( string , m ) NEW_LINE DEDENT"],"bleu":0.5649772983071061,"rouge_l":0.7356011519078474}
{"id":979,"predictions":["def findDefaultNumber ( n ) : NEW_LINE INDENT temp = n ; NEW_LINE sum = 0 ; NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT sum += temp % 10 ; NEW_LINE temp = temp \/\/ 10 ; NEW_LINE if ( sum < 10 ) : NEW_LINE INDENT print ( n , end = \" \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \"0\" , end = \" \" ) ; NEW_LINE DEDENT DEDENT if ( sum < 10 ) : NEW_LINE INDENT print ( n , end = \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( n , end = \" \" ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 98732 ; NEW_LINE findDefaultNumber ( n ) ; NEW_LINE DEDENT"],"references":["def findPhoneNumber ( n ) : NEW_LINE INDENT temp = n NEW_LINE sum = 0 NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT sum += temp % 10 NEW_LINE temp = temp \/\/ 10 NEW_LINE DEDENT if ( sum < 10 ) : NEW_LINE INDENT print ( n , \"0\" , sum ) NEW_LINE DEDENT else : NEW_LINE INDENT n = str ( n ) NEW_LINE sum = str ( sum ) NEW_LINE n += sum NEW_LINE print ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 98765432 NEW_LINE findPhoneNumber ( n ) NEW_LINE DEDENT"],"bleu":0.4958437414339658,"rouge_l":0.761578735400725}
{"id":980,"predictions":["def countOfSubarrays ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE v = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT v . append ( arr [ i ] ) NEW_LINE DEDENT maximum = - sys . maxsize - 1 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT maximum = max ( maximum , v [ i ] ) NEW_LINE minimum = min ( minimum , v [ i ] ) NEW_LINE DEDENT return count NEW_LINE DEDENT arr = [ 4 , 1 , 3 , 2 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countOfSubarrays ( arr , n ) ) NEW_LINE"],"references":["import sys NEW_LINE INT_MAX = sys . maxsize ; NEW_LINE INT_MIN = - ( sys . maxsize - 1 ) ; NEW_LINE def countOfSubarrays ( arr , n ) : NEW_LINE INDENT count = 0 ; NEW_LINE v = [ 0 ] * ( n + 1 ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT v [ arr [ i ] ] = i ; NEW_LINE DEDENT maximum = INT_MIN ; NEW_LINE minimum = INT_MAX ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT maximum = max ( maximum , v [ i ] ) ; NEW_LINE minimum = min ( minimum , v [ i ] ) ; NEW_LINE if ( maximum - minimum < i ) : NEW_LINE INDENT count = count + 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 4 , 1 , 3 , 2 , 5 , 6 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( countOfSubarrays ( arr , n ) ) ; NEW_LINE DEDENT"],"bleu":0.4324377947162826,"rouge_l":0.6779777712206159}
{"id":981,"predictions":["def maxSum ( p , p1 , p2 , n ) : NEW_LINE INDENT if ( p1 == p1 ) : NEW_LINE INDENT return p0 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT ans = max ( p0 , p1 , p2 , n ) NEW_LINE ans = max ( ans , maxSum ( p0 , p1 , p2 , n ) , max ( p0 , p1 , p2 , n ) ) NEW_LINE ans = max ( ans , maxSum ( p , 0 , p1 , p2 , n ) ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 NEW_LINE a1 = [ 1 , 2 , 3 , 6 ] NEW_LINE a2 = [ 1 , 2 , 3 ] NEW_LINE print ( maxSum ( 0 , 0 , a1 , n ) ) NEW_LINE DEDENT"],"references":["def maxSum ( p0 , p1 , a , pos , n ) : NEW_LINE INDENT if ( pos == n ) : NEW_LINE INDENT if ( p0 == p1 ) : NEW_LINE INDENT return p0 ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT ans = maxSum ( p0 , p1 , a , pos + 1 , n ) ; NEW_LINE ans = max ( ans , maxSum ( p0 + a [ pos ] , p1 , a , pos + 1 , n ) ) ; NEW_LINE ans = max ( ans , maxSum ( p0 , p1 + a [ pos ] , a , pos + 1 , n ) ) ; NEW_LINE return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 ; NEW_LINE a = [ 1 , 2 , 3 , 6 ] ; NEW_LINE print ( maxSum ( 0 , 0 , a , 0 , n ) ) ; NEW_LINE DEDENT"],"bleu":0.54594834180401,"rouge_l":0.7363707165109034}
{"id":982,"predictions":["MAX = 1000001 NEW_LINE def minimumSteps ( n , m , a , b ) : NEW_LINE INDENT if ( n > m ) : NEW_LINE INDENT return INF NEW_LINE DEDENT if ( n == m ) : NEW_LINE INDENT return INF NEW_LINE DEDENT return min ( 1 + minimumSteps ( n * a , m , a , b ) , 1 + minimumSteps ( n * a , a , b ) ) NEW_LINE DEDENT n = 120 NEW_LINE m = 518 NEW_LINE a = 2 NEW_LINE b = 3 NEW_LINE print ( minimumSteps ( n , m , a , b ) ) NEW_LINE"],"references":["MAXN = 10000000 NEW_LINE def minimumSteps ( n , m , a , b ) : NEW_LINE INDENT if ( n > m ) : NEW_LINE INDENT return MAXN NEW_LINE DEDENT if ( n == m ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return min ( 1 + minimumSteps ( n * a , m , a , b ) , 1 + minimumSteps ( n * b , m , a , b ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 120 NEW_LINE m = 51840 NEW_LINE a = 2 NEW_LINE b = 3 NEW_LINE print ( minimumSteps ( n , m , a , b ) ) NEW_LINE DEDENT"],"bleu":0.7437569957315536,"rouge_l":0.8673799802900184}
{"id":983,"predictions":["def printLargest ( s , l , r ) : NEW_LINE INDENT freq = [ 0 for i in range ( 26 ) ] NEW_LINE l -= 1 NEW_LINE r -= 1 NEW_LINE for i in range ( min ( l , r + 1 ) , 1 ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT ans = \" \" NEW_LINE for i in range ( 26 , - 1 , - 1 ) : NEW_LINE INDENT while ( freq [ i ] > 0 ) : NEW_LINE INDENT ans += chr ( ord ( ' a ' ) + i ) NEW_LINE freq [ i ] -= 1 NEW_LINE freq [ i ] -= 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = str ( input ( ) ) NEW_LINE l , r = 3 , 5 NEW_LINE print ( printLargest ( s , l , r ) ) NEW_LINE DEDENT"],"references":["def printLargestString ( s , l , r ) : NEW_LINE INDENT freq = [ 0 ] * 26 NEW_LINE l -= 1 NEW_LINE r -= 1 NEW_LINE for i in range ( min ( l , r ) , max ( l , r ) + 1 ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT ans = \" \" NEW_LINE for i in range ( 25 , - 1 , - 1 ) : NEW_LINE INDENT while ( freq [ i ] ) : NEW_LINE INDENT ans += chr ( ord ( ' a ' ) + i ) NEW_LINE freq [ i ] -= 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" striver \" NEW_LINE l = 3 NEW_LINE r = 5 NEW_LINE print ( printLargestString ( s , l , r ) ) NEW_LINE DEDENT"],"bleu":0.7718691206150423,"rouge_l":0.8697232317584569}
{"id":984,"predictions":["def findSymPair ( arr ) : NEW_LINE INDENT hm = dict ( ) NEW_LINE for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT first = arr [ i ] NEW_LINE sec = arr [ i ] NEW_LINE sec = hm [ arr [ i ] ] NEW_LINE sec = hm [ arr [ i ] ] NEW_LINE if ( val != first and val == first and val == second ) : NEW_LINE INDENT print ( \" ( \" , sec ) , \" ) NEW_LINE DEDENT else : NEW_LINE INDENT hm [ arr [ i ] ] = secm [ arr [ i ] ] NEW_LINE DEDENT sec = hm [ arr [ i ] ] NEW_LINE print ( \" ( \" , \" , sec , \" , ▁ \" , sec + \" , ▁ \" , sec , \" ) NEW_LINE DEDENT DEDENT arr = [ 5 , 5 , 20 ] NEW_LINE arr = [ 20 , 30 , 40 ] NEW_LINE findSymPair ( arr ) NEW_LINE arr1 = [ 30 , 40 , 40 ] NEW_LINE arr2 = [ 40 , 30 , 40 ] NEW_LINE arr2 = [ 40 , 40 ] , [ 40 , 40 ] ] NEW_LINE arr2 = [ 40 , 40 ] NEW_LINE findSymPair ( arr1 ) NEW_LINE"],"references":["def findSymPairs ( arr , row ) : NEW_LINE INDENT hM = dict ( ) NEW_LINE for i in range ( row ) : NEW_LINE INDENT first = arr [ i ] [ 0 ] NEW_LINE sec = arr [ i ] [ 1 ] NEW_LINE if ( sec in hM . keys ( ) and hM [ sec ] == first ) : NEW_LINE INDENT print ( \" ( \" , sec , \" , \" , first , \" ) \" ) NEW_LINE DEDENT else : NEW_LINE INDENT hM [ first ] = sec NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ [ 0 for i in range ( 2 ) ] for i in range ( 5 ) ] NEW_LINE arr [ 0 ] [ 0 ] , arr [ 0 ] [ 1 ] = 11 , 20 NEW_LINE arr [ 1 ] [ 0 ] , arr [ 1 ] [ 1 ] = 30 , 40 NEW_LINE arr [ 2 ] [ 0 ] , arr [ 2 ] [ 1 ] = 5 , 10 NEW_LINE arr [ 3 ] [ 0 ] , arr [ 3 ] [ 1 ] = 40 , 30 NEW_LINE arr [ 4 ] [ 0 ] , arr [ 4 ] [ 1 ] = 10 , 5 NEW_LINE findSymPairs ( arr , 5 ) NEW_LINE DEDENT"],"bleu":0.3000568123633251,"rouge_l":0.474510348659536}
{"id":985,"predictions":["def fact ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT return res NEW_LINE DEDENT def nCr ( n , r , n ) : NEW_LINE INDENT return fact ( n ) \/\/ ( fact ( 1 ) * fact ( n - r ) ) NEW_LINE DEDENT def numberOf_subsequences ( arr , k ) : NEW_LINE INDENT s = 0 NEW_LINE mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] not in mp . keys ( ) ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT return s NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 1 , 1 , 1 , 2 ] NEW_LINE k = 2 NEW_LINE n = len ( arr ) NEW_LINE print ( number_of_subsequences ( arr , k ) ) NEW_LINE DEDENT"],"references":["def fact ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT return res NEW_LINE DEDENT def nCr ( n , r ) : NEW_LINE INDENT return fact ( n ) \/\/ ( fact ( r ) * fact ( n - r ) ) NEW_LINE DEDENT def number_of_subsequences ( arr , k , n ) : NEW_LINE INDENT s = 0 NEW_LINE m = dict ( ) NEW_LINE for i in arr : NEW_LINE INDENT m [ i ] = m . get ( i , 0 ) + 1 NEW_LINE DEDENT for j in m : NEW_LINE INDENT s = s + nCr ( m [ j ] , k ) NEW_LINE DEDENT return s NEW_LINE DEDENT arr = [ 1 , 1 , 1 , 1 , 2 , 2 , 2 ] NEW_LINE k = 2 NEW_LINE n = len ( arr ) NEW_LINE print ( number_of_subsequences ( arr , k , n ) ) NEW_LINE"],"bleu":0.6438695263936608,"rouge_l":0.7784284590507823}
{"id":986,"predictions":["import math NEW_LINE SIZE = 26 NEW_LINE def SieveOfEratosthenes ( prime , p_size ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( p_size ) ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT for i in range ( 2 * p_size , p_size , p_size ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def printChar ( string , n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) NEW_LINE SieveOfEratosthenes ( prime , len ( prime ) + 1 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if prime [ ord ( prime [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" geeksforgeeks \" NEW_LINE n = len ( string ) NEW_LINE printChar ( string , n ) NEW_LINE DEDENT"],"references":["SIZE = 26 NEW_LINE from math import sqrt NEW_LINE def SieveOfEratosthenes ( prime , p_size ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( sqrt ( p_size ) ) , 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( p * 2 , p_size , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def printChar ( str , n ) : NEW_LINE INDENT prime = [ True for i in range ( n + 1 ) ] NEW_LINE SieveOfEratosthenes ( prime , len ( str ) + 1 ) NEW_LINE freq = [ 0 for i in range ( SIZE ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( prime [ freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] ] ) : NEW_LINE INDENT print ( str [ i ] , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" geeksforgeeks \" NEW_LINE n = len ( str ) NEW_LINE printChar ( str , n ) NEW_LINE DEDENT"],"bleu":0.5125707364986781,"rouge_l":0.7332045503326895}
{"id":987,"predictions":["def calculateSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + ( 1 << i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 10 NEW_LINE print ( \" Sum ▁ of ▁ series ▁ : ▁ \" , calculateSum ( n ) ) NEW_LINE"],"references":["def calculateSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum = sum + ( 1 << i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 10 NEW_LINE print ( \" Sum ▁ of ▁ series ▁ \" , calculateSum ( n ) ) NEW_LINE"],"bleu":0.9273259821242402,"rouge_l":0.9666666666666667}
{"id":988,"predictions":["def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT DEDENT def SumOfPrimeDivisors ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( isPrime ( i ) ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 60 NEW_LINE print ( \" Sum ▁ of ▁ prime \" ) NEW_LINE DEDENT"],"references":["N = 1000005 NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT if n <= 3 : NEW_LINE INDENT return True NEW_LINE DEDENT if n % 2 == 0 or n % 3 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT def SumOfPrimeDivisors ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT if isPrime ( i ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT DEDENT return sum NEW_LINE DEDENT n = 60 NEW_LINE print ( \" Sum ▁ of ▁ prime ▁ divisors ▁ of ▁ 60 ▁ is ▁ \" + str ( SumOfPrimeDivisors ( n ) ) ) NEW_LINE"],"bleu":0.6750151060684633,"rouge_l":0.8289691746768313}
{"id":989,"predictions":["def elementCount ( arr1 , arr2 , n1 , arr2 , n2 ) : NEW_LINE INDENT count = 0 NEW_LINE Hash = dict ( ) NEW_LINE for i in range ( n2 ) : NEW_LINE INDENT Hash [ arr2 [ i ] ] = 1 NEW_LINE DEDENT for i in range ( n1 ) : NEW_LINE INDENT Hash [ arr2 [ i ] ] += 1 NEW_LINE DEDENT for i in range ( n1 ) : NEW_LINE INDENT for j in range ( 1 , arr2 [ i ] + 1 ) : NEW_LINE INDENT if ( arr1 [ j ] % j == 0 ) : NEW_LINE INDENT Hash [ arr1 [ j ] ] = ( Hash [ arr1 [ i ] \/\/ j ] + ( arr1 [ arr1 [ j ] ] \/\/ j ) ) NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT arr1 = [ [ 10 , 2 , 13 , 4 ] , [ 2 , 15 , 6 ] ] NEW_LINE arr2 = [ 2 , 4 , 5 , 6 ] NEW_LINE n1 = len ( arr1 ) NEW_LINE n2 = len ( arr2 ) NEW_LINE print ( elementCount ( arr1 , arr2 , n1 , n2 ) ) NEW_LINE"],"references":["from math import sqrt NEW_LINE def elementCount ( arr1 , arr2 ) : NEW_LINE INDENT count = 0 NEW_LINE hash = frozenset ( arr2 ) NEW_LINE for x in arr1 : NEW_LINE INDENT for j in range ( 1 , int ( sqrt ( x ) ) + 1 ) : NEW_LINE INDENT if x % j == 0 : NEW_LINE INDENT if ( j in hash or x \/ j in hash ) : NEW_LINE INDENT count += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT arr1 = [ 10 , 2 , 13 , 4 , 15 ] NEW_LINE arr2 = [ 2 , 4 , 5 , 6 ] NEW_LINE print ( elementCount ( arr1 , arr2 ) ) NEW_LINE"],"bleu":0.3617802035714577,"rouge_l":0.5775809407452658}
{"id":990,"predictions":["def countSubarray ( arr , n , k ) : NEW_LINE INDENT s = 0 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( arr [ i ] > k ) : NEW_LINE INDENT i = i + 1 NEW_LINE continue NEW_LINE DEDENT count = 0 NEW_LINE while ( i < n and arr [ i ] <= k ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT count = 0 NEW_LINE while ( i < n and arr [ i ] <= k ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT s += ( count * ( count + 1 ) \/\/ 2 - s ) NEW_LINE i = i + 1 NEW_LINE DEDENT return ( n * ( n + 1 ) \/\/ 2 ) NEW_LINE DEDENT arr = [ 1 , 2 , 3 ] NEW_LINE k = 2 NEW_LINE n = len ( arr ) NEW_LINE print ( countSubarray ( arr , n , k ) ) NEW_LINE"],"references":["def countSubarray ( arr , n , k ) : NEW_LINE INDENT s = 0 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( arr [ i ] > k ) : NEW_LINE INDENT i = i + 1 NEW_LINE continue NEW_LINE DEDENT count = 0 NEW_LINE while ( i < n and arr [ i ] <= k ) : NEW_LINE INDENT i = i + 1 NEW_LINE count = count + 1 NEW_LINE DEDENT s = s + ( ( count * ( count + 1 ) ) \/\/ 2 ) NEW_LINE DEDENT return ( n * ( n + 1 ) \/\/ 2 - s ) NEW_LINE DEDENT arr = [ 1 , 2 , 3 ] NEW_LINE k = 2 NEW_LINE n = len ( arr ) NEW_LINE print ( countSubarray ( arr , n , k ) ) NEW_LINE"],"bleu":0.8117036231224056,"rouge_l":0.8753871567210407}
{"id":991,"predictions":["def countNum ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] != arr [ i + 1 ] and arr [ i + 1 ] != arr [ i ] ) : NEW_LINE INDENT count += arr [ i ] - 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 5 , 8 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countNum ( arr , n ) ) NEW_LINE DEDENT"],"references":["def countNum ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] != arr [ i + 1 ] and arr [ i ] != arr [ i + 1 ] - 1 ) : NEW_LINE INDENT count += arr [ i + 1 ] - arr [ i ] - 1 ; NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 3 , 5 , 8 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countNum ( arr , n ) ) NEW_LINE"],"bleu":0.839144367089933,"rouge_l":0.8850352355948599}
{"id":992,"predictions":["def max_element ( a , n ) : NEW_LINE INDENT pre = [ 0 ] * n ; NEW_LINE pre [ 0 ] = a [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT pre [ i - 1 ] = max ( pre [ i - 1 ] , a [ i ] ) ; NEW_LINE DEDENT suf = [ 0 ] * n ; NEW_LINE suf [ n - 1 ] = a [ n - 1 ] ; NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT suf [ i ] = max ( pre [ i + 1 ] , a [ i ] ) ; NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT print ( pre [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT elif ( i == n - 1 ) : NEW_LINE INDENT print ( pre [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( pre [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 2 , 5 , 1 , 3 , 3 ] ; NEW_LINE n = len ( a ) ; NEW_LINE max_element ( a , n ) ; NEW_LINE DEDENT"],"references":["def max_element ( a , n ) : NEW_LINE INDENT pre = [ 0 ] * n ; NEW_LINE pre [ 0 ] = a [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT pre [ i ] = max ( pre [ i - 1 ] , a [ i ] ) ; NEW_LINE DEDENT suf = [ 0 ] * n ; NEW_LINE suf [ n - 1 ] = a [ n - 1 ] ; NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT suf [ i ] = max ( suf [ i + 1 ] , a [ i ] ) ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT print ( suf [ i + 1 ] , end = \" ▁ \" ) ; NEW_LINE DEDENT elif ( i == n - 1 ) : NEW_LINE INDENT print ( pre [ i - 1 ] , end = \" ▁ \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( max ( pre [ i - 1 ] , suf [ i + 1 ] ) , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 2 , 5 , 6 , 1 , 3 ] ; NEW_LINE n = len ( a ) ; NEW_LINE max_element ( a , n ) ; NEW_LINE DEDENT"],"bleu":0.8997264926925111,"rouge_l":0.9351633036417623}
{"id":993,"predictions":["def isRotated ( str1 , str2 ) : NEW_LINE INDENT if ( len ( str1 ) != len ( str1 ) and str1 != str2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT rotation_rot = ( str1 [ 0 ] + str1 [ len ( str1 [ len ( str2 ) - 2 ] ) ) + str1 [ len ( str1 [ 0 ] ) ] ) NEW_LINE rotation_Rotated = transform ( str1 [ 0 ] + str1 [ len ( str1 [ 0 ] ) + str2 [ 1 ] ] ) NEW_LINE return ( ( str1 == interval_Rotated ) NEW_LINE DEDENT str1 = \" geeksforgeeks \" NEW_LINE str2 = \" eforGeeks \" NEW_LINE if ( isRotated ( str1 , str2 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def isRotated ( str1 , str2 ) : NEW_LINE INDENT if ( len ( str1 ) != len ( str2 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT clock_rot = \" \" NEW_LINE anticlock_rot = \" \" NEW_LINE l = len ( str2 ) NEW_LINE anticlock_rot = ( anticlock_rot + str2 [ l - 2 : ] + str2 [ 0 : l - 2 ] ) NEW_LINE clock_rot = clock_rot + str2 [ 2 : ] + str2 [ 0 : 2 ] NEW_LINE return ( str1 == clock_rot or str1 == anticlock_rot ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" geeks \" NEW_LINE str2 = \" eksge \" NEW_LINE DEDENT if isRotated ( str1 , str2 ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.485217014063077,"rouge_l":0.6466897446992643}
{"id":994,"predictions":["def findMax ( num ) : NEW_LINE INDENT size_of_output = 4 NEW_LINE num_copy = num NEW_LINE i = 0 NEW_LINE while ( i < j ) : NEW_LINE INDENT m_copy = ( num_copy >> i ) NEW_LINE n = ( num_copy >> i ) NEW_LINE if ( m_copy > n ) : NEW_LINE INDENT x = ( 1 << i ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return num_copy NEW_LINE DEDENT num = 4 NEW_LINE print ( findMax ( num ) ) NEW_LINE"],"references":["def findMax ( num ) : NEW_LINE INDENT num_copy = num NEW_LINE j = 4 * 8 - 1 ; NEW_LINE i = 0 NEW_LINE while ( i < j ) : NEW_LINE INDENT m = ( num_copy >> i ) & 1 NEW_LINE n = ( num_copy >> j ) & 1 NEW_LINE if ( m > n ) : NEW_LINE INDENT x = ( 1 << i | 1 << j ) NEW_LINE num = num ^ x NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return num NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT num = 4 NEW_LINE print ( findMax ( num ) ) NEW_LINE DEDENT"],"bleu":0.47382064402283136,"rouge_l":0.7180916976456011}
{"id":995,"predictions":["def check ( s , l ) : NEW_LINE INDENT pos = 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT pos = i NEW_LINE DEDENT DEDENT t = len ( s ) NEW_LINE for i in range ( 1 , l ) : NEW_LINE INDENT if ( ord ( s [ i ] ) - ord ( '0' ) != ( pos ) - ord ( '0' ) ) != ( pos ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \"100010001\" NEW_LINE l = len ( s ) NEW_LINE if ( check ( s , l ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def check ( s , l ) : NEW_LINE INDENT pos = [ ] NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT pos . append ( i ) NEW_LINE DEDENT DEDENT t = len ( pos ) NEW_LINE for i in range ( 1 , t ) : NEW_LINE INDENT if ( ( pos [ i ] - pos [ i - 1 ] ) != ( pos [ 1 ] - pos [ 0 ] ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT s = \"100010001000\" NEW_LINE l = len ( s ) NEW_LINE if ( check ( s , l ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.6928854836903208,"rouge_l":0.8218366027161026}
{"id":996,"predictions":["def maximum_one ( s , n ) : NEW_LINE INDENT cnt_one = 0 ; NEW_LINE max_cnt = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT cnt_one += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT max_cnt = max ( max_cnt , temp ) ; NEW_LINE DEDENT DEDENT max_cnt = max ( max_cnt , temp ) ; NEW_LINE left = [ 0 ] ; NEW_LINE right = [ 0 ] * n ; NEW_LINE left [ 0 ] = 0 ; NEW_LINE right [ n - 1 ] = 0 ; NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT left [ i ] = right [ i + 1 ] ; NEW_LINE DEDENT else : NEW_LINE INDENT right [ i ] = 1 ; NEW_LINE DEDENT DEDENT if ( s [ n - 1 ] == '1' ) : NEW_LINE INDENT left [ n - 1 ] = 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT right [ n - 1 ] = 0 ; NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT left [ i ] = right [ i + 1 ] ; NEW_LINE DEDENT else : NEW_LINE INDENT right [ i ] = left [ i + 1 ] + right [ i + 1 ] ; NEW_LINE DEDENT DEDENT DEDENT return max_cnt ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \"1110111101\" ; NEW_LINE n = len ( s ) ; NEW_LINE print ( maximum_one ( s , len ( s ) ) ; NEW_LINE DEDENT"],"references":["def maximum_one ( s , n ) : NEW_LINE INDENT cnt_one = 0 NEW_LINE cnt , max_cnt = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT cnt_one += 1 NEW_LINE cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT max_cnt = max ( max_cnt , cnt ) NEW_LINE cnt = 0 NEW_LINE DEDENT DEDENT max_cnt = max ( max_cnt , cnt ) NEW_LINE left = [ 0 ] * n NEW_LINE right = [ 0 ] * n NEW_LINE if ( s [ 0 ] == '1' ) : NEW_LINE INDENT left [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT left [ 0 ] = 0 NEW_LINE DEDENT if ( s [ n - 1 ] == '1' ) : NEW_LINE INDENT right [ n - 1 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT right [ n - 1 ] = 0 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT left [ i ] = left [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT left [ i ] = 0 NEW_LINE DEDENT DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT right [ i ] = right [ i + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT right [ i ] = 0 NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT sum = left [ i - 1 ] + right [ i + 1 ] NEW_LINE if ( sum < cnt_one ) : NEW_LINE INDENT max_cnt = max ( max_cnt , sum + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT max_cnt = max ( max_cnt , sum ) NEW_LINE DEDENT DEDENT DEDENT return max_cnt NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \"111011101\" NEW_LINE print ( maximum_one ( s , len ( s ) ) ) NEW_LINE DEDENT"],"bleu":0.6010765571477605,"rouge_l":0.6753581273442089}
{"id":997,"predictions":["import math NEW_LINE def nDigitPerfectSquares ( n ) : NEW_LINE INDENT print ( pow ( math . ceil ( math . sqrt ( pow ( 10 , ( n - 1 ) ) ) ) , end = \" ▁ \" ) ; NEW_LINE print ( pow ( math . ceil ( math . sqrt ( pow ( 10 , ( n ) ) ) - 1 , end = \" ▁ \" ) ) NEW_LINE DEDENT n = 3 NEW_LINE nDigitPerfectSquares ( n ) ; NEW_LINE"],"references":["from math import ceil NEW_LINE def nDigitPerfectCubes ( n ) : NEW_LINE INDENT print ( pow ( ceil ( ( pow ( 10 , ( n - 1 ) ) ) ** ( 1 \/ 3 ) ) , 3 ) , end = \" ▁ \" ) NEW_LINE print ( pow ( ceil ( ( pow ( 10 , ( n ) ) ) ** ( 1 \/ 3 ) ) - 1 , 3 ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE nDigitPerfectCubes ( n ) NEW_LINE DEDENT"],"bleu":0.48120669218852696,"rouge_l":0.6947135815060343}
{"id":998,"predictions":["def isMultipleof5 ( n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT n >>= 1 ; NEW_LINE x = n ; NEW_LINE DEDENT if ( x == n ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT if ( ( x == n ) ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT i = 19 ; NEW_LINE if ( isMultipleof5 ( i ) ) : NEW_LINE INDENT print ( i , \" is ▁ multiple ▁ of ▁ 5\" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( i , \" is ▁ not ▁ a ▁ multiple ▁ of ▁ 5\" ) ; NEW_LINE DEDENT"],"references":["def isMultipleof5 ( n ) : NEW_LINE INDENT if ( ( n & 1 ) == 1 ) : NEW_LINE INDENT n <<= 1 ; NEW_LINE DEDENT x = n NEW_LINE x = ( ( int ) ( x * 0.1 ) ) * 10 NEW_LINE if ( x == n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT i = 19 NEW_LINE if ( isMultipleof5 ( i ) == 1 ) : NEW_LINE INDENT print ( i , \" is ▁ multiple ▁ of ▁ 5\" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( i , \" is ▁ not ▁ a ▁ multiple ▁ of ▁ 5\" ) NEW_LINE DEDENT"],"bleu":0.6840939415899049,"rouge_l":0.8176487014800335}
{"id":999,"predictions":["def minsteps ( n , m ) : NEW_LINE INDENT if ( m > n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( n + 1 ) \/\/ 2 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n , m = 17 , 4 NEW_LINE ans = minsteps ( n , m ) NEW_LINE print ( ans ) NEW_LINE DEDENT"],"references":["def minsteps ( n , m ) : NEW_LINE INDENT if ( m > n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( n + 1 ) \/\/ 2 + m - 1 ) \/\/ m * m ; NEW_LINE DEDENT DEDENT n = 17 NEW_LINE m = 4 NEW_LINE ans = minsteps ( n , m ) NEW_LINE print ( ans ) NEW_LINE"],"bleu":0.7087122696621794,"rouge_l":0.8102723046269648}
{"id":1000,"predictions":["from math import sqrt , floor NEW_LINE def gridStr ( str ) : NEW_LINE INDENT l = len ( str ) NEW_LINE row = floor ( sqrt ( l ) ) NEW_LINE column = ceil ( sqrt ( l ) ) NEW_LINE if ( row * column < l ) : NEW_LINE INDENT row = column + ceil ( sqrt ( l ) ) NEW_LINE DEDENT s = \" \" NEW_LINE for i in range ( row ) : NEW_LINE INDENT for j in range ( col ) : NEW_LINE INDENT if ( k < len ( s ) ) : NEW_LINE INDENT s = str [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT s = str [ i ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( row ) : NEW_LINE INDENT for j in range ( i , row ) : NEW_LINE INDENT if ( k < len ( s ) ) : NEW_LINE INDENT s = str [ j ] NEW_LINE break NEW_LINE DEDENT if ( s < '0' ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( \" \\n \" . join ( s ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" GEEKSFORGEEKS \" NEW_LINE grid = [ [ 0 for i in range ( row ) ] for j in range ( row ) ] NEW_LINE centerStr ( str ) NEW_LINE DEDENT"],"references":["from math import sqrt , floor , ceil NEW_LINE def gridStr ( string ) : NEW_LINE INDENT l = len ( string ) NEW_LINE k = 0 NEW_LINE row = floor ( sqrt ( l ) ) NEW_LINE column = ceil ( sqrt ( l ) ) NEW_LINE if ( row * column < l ) : NEW_LINE INDENT row = column NEW_LINE DEDENT s = [ [ 0 for j in range ( column ) ] for i in range ( row ) ] NEW_LINE for i in range ( row ) : NEW_LINE INDENT for j in range ( column ) : NEW_LINE INDENT if k >= l : NEW_LINE INDENT s [ i ] [ j ] = \" ▁ \" NEW_LINE k += 1 NEW_LINE DEDENT else : NEW_LINE INDENT s [ i ] [ j ] = string [ k ] NEW_LINE k += 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( row ) : NEW_LINE INDENT for j in range ( column ) : NEW_LINE INDENT if s [ i ] [ j ] == \" ▁ \" : NEW_LINE INDENT break NEW_LINE DEDENT print ( s [ i ] [ j ] , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" GEEKSFORGEEKS \" NEW_LINE gridStr ( string ) NEW_LINE DEDENT"],"bleu":0.5805818510553098,"rouge_l":0.6580054274084124}
{"id":1001,"predictions":["def maxProfit ( prices , start , end , end ) : NEW_LINE INDENT if ( end <= start ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT profit = 0 NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , end + 1 ) : NEW_LINE INDENT if ( price [ j ] > price [ i ] + maxProfit ( prices , i - 1 , end ) + maxProfit ( prices , j , i , end ) ) : NEW_LINE INDENT profit = cost [ j ] - price [ i ] NEW_LINE profit = max ( profit , curr ) NEW_LINE DEDENT DEDENT DEDENT return profit NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT prices = [ 100 , 180 , 260 , 445 , 40 , 5 , 6 ] NEW_LINE n = len ( prices ) NEW_LINE print ( maxProfit ( prices , 0 , n - 1 , len ( prices ) ) ) NEW_LINE DEDENT"],"references":["def maxProfit ( price , start , end ) : NEW_LINE INDENT if ( end <= start ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT profit = 0 ; NEW_LINE for i in range ( start , end , 1 ) : NEW_LINE INDENT for j in range ( i + 1 , end + 1 ) : NEW_LINE INDENT if ( price [ j ] > price [ i ] ) : NEW_LINE INDENT curr_profit = price [ j ] - price [ i ] + \\ NEW_LINE INDENT maxProfit ( price , start , i - 1 ) +   \\ NEW_LINE maxProfit ( price , j + 1 , end ) ; NEW_LINE DEDENT profit = max ( profit , curr_profit ) ; NEW_LINE DEDENT DEDENT DEDENT return profit ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT price = [ 100 , 180 , 260 , 310 , 40 , 535 , 695 ] ; NEW_LINE n = len ( price ) ; NEW_LINE print ( maxProfit ( price , 0 , n - 1 ) ) ; NEW_LINE DEDENT"],"bleu":0.6154581878682812,"rouge_l":0.7659334949774853}
{"id":1002,"predictions":["def maximum_middle_value ( n , k , arr ) : NEW_LINE INDENT ans = - 1 NEW_LINE low = ( n + 1 ) \/\/ 2 NEW_LINE high = ( n + 1 - k ) \/\/ 2 + k NEW_LINE for i in range ( low , high + 1 ) : NEW_LINE INDENT ans = max ( ans , arr [ i - 1 ] ) NEW_LINE DEDENT for i in range ( low , high + 1 ) : NEW_LINE INDENT ans = max ( ans , arr [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n , k = 5 , 3 NEW_LINE arr = [ 9 , 4 , 3 , 9 , 8 , 10 , 6 ] NEW_LINE print ( maximum_Middle_middlevalue ( n , k , arr ) ) NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE arr = [ 2 , 4 , 9 , 7 , 8 , 10 , 6 ] NEW_LINE print ( maximum_middle_middle_value ( n , k , arr ) ) NEW_LINE DEDENT"],"references":["def maximum_middle_value ( n , k , arr ) : NEW_LINE INDENT ans = - 1 NEW_LINE low = ( n + 1 - k ) \/\/ 2 NEW_LINE high = ( n + 1 - k ) \/\/ 2 + k NEW_LINE for i in range ( low , high + 1 ) : NEW_LINE INDENT ans = max ( ans , arr [ i - 1 ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n , k = 5 , 2 NEW_LINE arr = [ 9 , 5 , 3 , 7 , 10 ] NEW_LINE print ( maximum_middle_value ( n , k , arr ) ) NEW_LINE n , k = 9 , 3 NEW_LINE arr1 = [ 2 , 4 , 3 , 9 , 5 , 8 , 7 , 6 , 10 ] NEW_LINE print ( maximum_middle_value ( n , k , arr1 ) ) NEW_LINE DEDENT"],"bleu":0.6496645288528027,"rouge_l":0.8226491779050434}
{"id":1003,"predictions":["def countRec ( n , sum ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return Sum NEW_LINE DEDENT if ( sum == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT ans = 0 NEW_LINE if ( sum - i >= 0 ) : NEW_LINE INDENT ans += countRec ( n - 1 , sum - i ) NEW_LINE DEDENT ans += countRec ( n - 1 , sum - i ) NEW_LINE return ans NEW_LINE DEDENT def finalCount ( n , sum ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , 9 + 1 ) : NEW_LINE INDENT if ( sum - i >= 0 ) : NEW_LINE INDENT ans += countRec ( n - 1 , sum - i ) NEW_LINE DEDENT DEDENT return int ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n , sum = 2 , 5 NEW_LINE print ( finalCount ( n , sum ) ) NEW_LINE DEDENT"],"references":["def countRec ( n , sum ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return ( sum == 0 ) NEW_LINE DEDENT if ( sum == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 0 , 10 ) : NEW_LINE INDENT if ( sum - i >= 0 ) : NEW_LINE INDENT ans = ans + countRec ( n - 1 , sum - i ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def finalCount ( n , sum ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT if ( sum - i >= 0 ) : NEW_LINE INDENT ans = ans + countRec ( n - 1 , sum - i ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT n = 2 NEW_LINE sum = 5 NEW_LINE print ( finalCount ( n , sum ) ) NEW_LINE"],"bleu":0.720171901237838,"rouge_l":0.8070824010117715}
{"id":1004,"predictions":["def calculateSum ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE MOD = 1000000007 NEW_LINE while ( k > 0 ) : NEW_LINE INDENT if ( ( k & 1 ) == 1 ) : NEW_LINE INDENT res = ( res * n ) % MOD NEW_LINE DEDENT k = k \/\/ 2 NEW_LINE DEDENT return res NEW_LINE DEDENT n = 4 NEW_LINE k = 3 NEW_LINE print ( calculateSum ( n , k ) ) NEW_LINE"],"references":["def calculateSum ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE MOD = 1000000007 NEW_LINE while k > 0 : NEW_LINE INDENT if ( k & 1 ) == 1 : NEW_LINE INDENT res = ( res * n ) % MOD NEW_LINE DEDENT k = k \/\/ 2 NEW_LINE n = ( n * n ) % MOD NEW_LINE DEDENT return res NEW_LINE DEDENT n = 4 NEW_LINE k = 3 NEW_LINE print ( calculateSum ( n , k ) ) NEW_LINE"],"bleu":0.8131906680932947,"rouge_l":0.9097331240188382}
{"id":1005,"predictions":["def countPairs ( s , K ) : NEW_LINE INDENT if ( K > s or ( s - K ) % 2 == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT set1 = add ( s ) NEW_LINE if ( ( s - K ) % 2 == 1 and K == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT set1 . add ( 2 ) NEW_LINE DEDENT def countPairs ( s , K ) : NEW_LINE INDENT if ( K == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT subset = pow ( 2 , set1 ) NEW_LINE if ( s == K ) : NEW_LINE INDENT return countPairs NEW_LINE DEDENT return countPairs NEW_LINE DEDENT s = 9 NEW_LINE K = 5 NEW_LINE print ( countPairs ( s , K ) ) NEW_LINE"],"references":["def countPairs ( s , K ) : NEW_LINE INDENT if ( K > s or ( s - K ) % 2 == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT setBits = ( str ( bin ( K ) ) [ 2 : ] ) . count ( \"1\" ) NEW_LINE pairsCount = pow ( 2 , setBits ) NEW_LINE if ( s == K ) : NEW_LINE INDENT pairsCount -= 2 NEW_LINE DEDENT return pairsCount NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s , K = 9 , 5 NEW_LINE print ( countPairs ( s , K ) ) NEW_LINE DEDENT"],"bleu":0.4811123256300558,"rouge_l":0.6572226656025538}
{"id":1006,"predictions":["def splitString ( st ) : NEW_LINE INDENT alpha = \" \" NEW_LINE num = \" \" NEW_LINE lower = [ ] NEW_LINE for i in range ( len ( st ) ) : NEW_LINE INDENT if ( st [ i ] == st [ i ] ) : NEW_LINE INDENT num = st [ i ] NEW_LINE DEDENT elif ( st [ len ( st ) - 1 ] != st [ i ] ) : NEW_LINE INDENT lower = st [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT lower . append ( st [ i ] ) NEW_LINE DEDENT DEDENT DEDENT print ( lowerString ( st ) ) NEW_LINE"],"references":["def splitString ( str ) : NEW_LINE INDENT alpha = \" \" NEW_LINE num = \" \" NEW_LINE special = \" \" NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] . isdigit ( ) ) : NEW_LINE INDENT num = num + str [ i ] NEW_LINE DEDENT elif ( ( str [ i ] >= ' A ' and str [ i ] <= ' Z ' ) or ( str [ i ] >= ' a ' and str [ i ] <= ' z ' ) ) : NEW_LINE INDENT alpha += str [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT special += str [ i ] NEW_LINE DEDENT DEDENT print ( alpha ) NEW_LINE print ( num ) NEW_LINE print ( special ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeks01 $ $ for02geeks03 ! @ ! ! \" NEW_LINE splitString ( str ) NEW_LINE DEDENT"],"bleu":0.2998758953992892,"rouge_l":0.5383936451897617}
{"id":1007,"predictions":["def atMostK ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE left = 0 NEW_LINE right = 0 NEW_LINE while ( right < n ) : NEW_LINE INDENT if arr [ left ] == arr [ right ] ) : NEW_LINE INDENT right += 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ left ] = 0 NEW_LINE right += 1 NEW_LINE DEDENT while ( arr [ left ] > k ) : NEW_LINE INDENT arr [ left ] -= 1 NEW_LINE right += 1 NEW_LINE DEDENT if ( arr [ left ] == 0 ) : NEW_LINE INDENT if ( arr [ left ] == 0 ) : NEW_LINE INDENT return arr [ right ] NEW_LINE DEDENT count += 1 NEW_LINE left += 1 NEW_LINE right += 1 NEW_LINE DEDENT DEDENT return ( right - left + 1 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 1 , 2 , 1 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE print ( atK ( arr , n , k - 1 ) ) NEW_LINE DEDENT"],"references":["def atMostK ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE left = 0 NEW_LINE right = 0 NEW_LINE map = { } NEW_LINE while ( right < n ) : NEW_LINE INDENT if arr [ right ] not in map : NEW_LINE INDENT map [ arr [ right ] ] = 0 NEW_LINE DEDENT map [ arr [ right ] ] += 1 NEW_LINE while ( len ( map ) > k ) : NEW_LINE INDENT if arr [ left ] not in map : NEW_LINE INDENT map [ arr [ left ] ] = 0 NEW_LINE DEDENT map [ arr [ left ] ] -= 1 NEW_LINE if map [ arr [ left ] ] == 0 : NEW_LINE INDENT del map [ arr [ left ] ] NEW_LINE DEDENT left += 1 NEW_LINE DEDENT count += right - left + 1 NEW_LINE right += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def exactlyK ( arr , n , k ) : NEW_LINE INDENT return ( atMostK ( arr , n , k ) - atMostK ( arr , n , k - 1 ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 1 , 2 , 1 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE print ( exactlyK ( arr , n , k ) ) NEW_LINE DEDENT"],"bleu":0.5707983358851648,"rouge_l":0.6823758660508085}
{"id":1008,"predictions":["def display ( n ) : NEW_LINE INDENT sp = n \/\/ 2 NEW_LINE st = 1 NEW_LINE st = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , st + 1 ) : NEW_LINE INDENT print ( \" ▁ \" , end = \" \" ) NEW_LINE DEDENT count = 1 NEW_LINE for k in range ( 1 , st + 1 ) : NEW_LINE INDENT if ( k % 2 == 0 ) : NEW_LINE INDENT print ( \" * \" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT count = sp + 1 NEW_LINE DEDENT DEDENT if ( i <= n \/\/ 2 ) : NEW_LINE INDENT sp = st - 1 NEW_LINE st = st + 2 NEW_LINE st = st + 2 NEW_LINE st = st - 2 NEW_LINE DEDENT else : NEW_LINE INDENT sp = st - 1 NEW_LINE st = st - 2 NEW_LINE st = st - 1 NEW_LINE st = st - 2 NEW_LINE st = st - 2 NEW_LINE DEDENT DEDENT return st NEW_LINE DEDENT n = 5 NEW_LINE p = display ( n ) NEW_LINE"],"references":["def display ( n ) : NEW_LINE INDENT sp = n \/\/ 2 NEW_LINE st = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , sp + 1 ) : NEW_LINE INDENT print ( end = \" ▁ \" ) NEW_LINE DEDENT count = 1 NEW_LINE for k in range ( 1 , st + 1 ) : NEW_LINE INDENT if ( k % 2 == 0 ) : NEW_LINE INDENT print ( \" * \" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( count , end = \" \" ) NEW_LINE count += 1 NEW_LINE DEDENT DEDENT print ( ) NEW_LINE if ( i <= n \/\/ 2 ) : NEW_LINE INDENT sp = sp - 1 NEW_LINE st = st + 2 NEW_LINE DEDENT else : NEW_LINE INDENT sp = sp + 1 NEW_LINE st = st - 2 NEW_LINE DEDENT DEDENT DEDENT n = 5 NEW_LINE display ( n ) NEW_LINE"],"bleu":0.7158953567365786,"rouge_l":0.8320133755719816}
{"id":1009,"predictions":["R = 5 NEW_LINE C = 3 NEW_LINE def maxArea ( mat ) : NEW_LINE INDENT buf = [ [ 0 for col in range ( C + 1 ) ] for row in range ( R + 1 ) ] NEW_LINE for i in range ( R ) : NEW_LINE INDENT buf [ i ] [ C ] = mat [ i ] [ C ] NEW_LINE DEDENT for i in range ( C ) : NEW_LINE INDENT if ( buf [ i ] [ C ] == 0 ) : NEW_LINE INDENT buf [ i ] [ C ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT if ( buf [ i ] [ C ] > 0 ) : NEW_LINE INDENT buf [ i ] [ C ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT buf [ i ] [ C ] = ( mat [ i ] [ C ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( R ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( C ) : NEW_LINE INDENT if ( count <= max ) : NEW_LINE INDENT for k in range ( R ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT DEDENT c = 0 NEW_LINE for i in range ( R ) : NEW_LINE INDENT for j in range ( C ) : NEW_LINE INDENT if ( count > 0 ) : NEW_LINE INDENT c = count NEW_LINE mat [ i ] [ j ] = j NEW_LINE if ( flag > max ) : NEW_LINE INDENT max = mat [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT return max NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT mat = [ [ 0 , 1 , 0 , 0 , 1 ] , [ 1 , 1 , 0 , 1 , 0 ] , [ 0 , 0 , 0 , 1 ] ] NEW_LINE print ( \" Area ▁ of ▁ the ▁ largest ▁ rectangle ▁ is \" , maxArea ( mat ) ) NEW_LINE DEDENT"],"references":["R = 3 NEW_LINE C = 5 NEW_LINE def maxArea ( mat ) : NEW_LINE INDENT hist = [ [ 0 for i in range ( C + 1 ) ] for i in range ( R + 1 ) ] NEW_LINE for i in range ( 0 , C , 1 ) : NEW_LINE INDENT hist [ 0 ] [ i ] = mat [ 0 ] [ i ] NEW_LINE for j in range ( 1 , R , 1 ) : NEW_LINE INDENT if ( ( mat [ j ] [ i ] == 0 ) ) : NEW_LINE INDENT hist [ j ] [ i ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT hist [ j ] [ i ] = hist [ j - 1 ] [ i ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 0 , R , 1 ) : NEW_LINE INDENT count = [ 0 for i in range ( R + 1 ) ] NEW_LINE for j in range ( 0 , C , 1 ) : NEW_LINE INDENT count [ hist [ i ] [ j ] ] += 1 NEW_LINE DEDENT col_no = 0 NEW_LINE j = R NEW_LINE while ( j >= 0 ) : NEW_LINE INDENT if ( count [ j ] > 0 ) : NEW_LINE INDENT for k in range ( 0 , count [ j ] , 1 ) : NEW_LINE INDENT hist [ i ] [ col_no ] = j NEW_LINE col_no += 1 NEW_LINE DEDENT DEDENT j -= 1 NEW_LINE DEDENT DEDENT max_area = 0 NEW_LINE for i in range ( 0 , R , 1 ) : NEW_LINE INDENT for j in range ( 0 , C , 1 ) : NEW_LINE INDENT curr_area = ( j + 1 ) * hist [ i ] [ j ] NEW_LINE if ( curr_area > max_area ) : NEW_LINE INDENT max_area = curr_area NEW_LINE DEDENT DEDENT DEDENT return max_area NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT mat = [ [ 0 , 1 , 0 , 1 , 0 ] , [ 0 , 1 , 0 , 1 , 1 ] , [ 1 , 1 , 0 , 1 , 0 ] ] NEW_LINE print ( \" Area ▁ of ▁ the ▁ largest ▁ rectangle ▁ is \" , maxArea ( mat ) ) NEW_LINE DEDENT"],"bleu":0.5604779675262109,"rouge_l":0.6833228445563247}
{"id":1010,"predictions":["def lcs ( dp , a , b , m , n ) : NEW_LINE INDENT for i in range ( a ) : NEW_LINE INDENT for j in range ( b ) : NEW_LINE INDENT dp [ i ] [ j ] = - 1 NEW_LINE DEDENT if ( m < 0 or n < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if ( dp [ m ] [ n ] != - 1 ) : NEW_LINE INDENT return dp [ m ] [ n ] NEW_LINE DEDENT ans = 0 NEW_LINE if ( dp [ m ] [ n ] != - 1 ) : NEW_LINE INDENT ans = max ( lcs ( dp , a , b , m - 1 ) , lcs ( dp , a , b , n - 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( lcs ( dp , a , b , m - 1 , n - 1 ) , lcs ( dp , a , b , n - 1 ) ) NEW_LINE dp [ m ] [ n ] = ans NEW_LINE return ans NEW_LINE DEDENT DEDENT def cost ( a , b , c ) : NEW_LINE INDENT cost = 0 NEW_LINE for i in range ( a ) : NEW_LINE INDENT cost += ( ord ( a [ i ] ) - 48 ) NEW_LINE DEDENT return cost NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 9 , 98 ] NEW_LINE b = [ 14 , 98 ] NEW_LINE dp = [ [ - 1 , - 2 ] for i in range ( 100 ) ] NEW_LINE print ( cost ( cost ( a , b , len ( b ) - 2 * lcs ( b ) ) ) NEW_LINE DEDENT"],"references":["def lcs ( dp , a , b , m , n ) : NEW_LINE INDENT for i in range ( 100 ) : NEW_LINE INDENT for j in range ( 100 ) : NEW_LINE INDENT dp [ i ] [ j ] = - 1 NEW_LINE DEDENT DEDENT if ( m < 0 or n < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ m ] [ n ] != - 1 ) : NEW_LINE INDENT return dp [ m ] [ n ] NEW_LINE DEDENT ans = 0 NEW_LINE if ( a [ m ] == b [ n ] ) : NEW_LINE INDENT ans = ( ord ( a [ m ] ) - 48 ) + lcs ( dp , a , b , m - 1 , n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( lcs ( dp , a , b , m - 1 , n ) , lcs ( dp , a , b , m , n - 1 ) ) NEW_LINE DEDENT dp [ m ] [ n ] = ans NEW_LINE return ans NEW_LINE DEDENT def costOfString ( s ) : NEW_LINE INDENT cost = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT cost += ( ord ( s [ i ] ) - 48 ) NEW_LINE DEDENT return cost NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = \"9142\" NEW_LINE b = \"1429\" NEW_LINE dp = [ [ 0 for x in range ( 101 ) ] for y in range ( 101 ) ] NEW_LINE print ( costOfString ( a ) + costOfString ( b ) - 2 * lcs ( dp , a , b , len ( a ) - 1 , len ( b ) - 1 ) ) NEW_LINE DEDENT"],"bleu":0.7685407317888128,"rouge_l":0.8277857435477263}
{"id":1011,"predictions":["def maxUniqueNum ( arr , N , M ) : NEW_LINE INDENT maxUnique = 0 NEW_LINE Hash = { } NEW_LINE for i in range ( N - M + 1 ) : NEW_LINE INDENT currentUnique = 0 NEW_LINE for k in range ( i + 1 , M ) : NEW_LINE INDENT if ( arr [ k ] not in Hash : NEW_LINE INDENT if ( arr [ k ] not in Hash ) : NEW_LINE INDENT Hash [ arr [ k ] ] = 1 NEW_LINE DEDENT currentUnique += 1 NEW_LINE DEDENT if ( currentUnique > maxUnique ) : NEW_LINE INDENT maxUnique = currentUnique NEW_LINE DEDENT DEDENT DEDENT return maxUnique NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 5 , 3 , 5 , 2 , 2 ] NEW_LINE N = len ( arr ) NEW_LINE M = 3 NEW_LINE print ( maxUniqueNum ( arr , N , M ) ) NEW_LINE DEDENT"],"references":["def maxUniqueNum ( a , N , M ) : NEW_LINE INDENT maxUnique = 0 NEW_LINE for i in range ( N - M ) : NEW_LINE INDENT s = set ( ) NEW_LINE for j in range ( M ) : NEW_LINE INDENT s . add ( a [ i + j ] ) NEW_LINE DEDENT if ( len ( s ) > maxUnique ) : NEW_LINE INDENT maxUnique = len ( s ) NEW_LINE DEDENT DEDENT return maxUnique NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 3 , 5 , 2 , 3 , 2 ] NEW_LINE M = 3 NEW_LINE N = len ( arr ) NEW_LINE print ( maxUniqueNum ( arr , N , M ) ) NEW_LINE DEDENT"],"bleu":0.5271131944612422,"rouge_l":0.7196438508625486}
{"id":1012,"predictions":["def complement ( s ) : NEW_LINE INDENT comp = \" \" NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT comp += '1' NEW_LINE DEDENT else : NEW_LINE INDENT comp += '1' NEW_LINE DEDENT DEDENT return comp NEW_LINE DEDENT def nthTerm ( n ) : NEW_LINE INDENT s = \"0\" NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT s += complement NEW_LINE DEDENT return complement NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 NEW_LINE print ( nthTerm ( n ) ) NEW_LINE DEDENT"],"references":["def complement ( s ) : NEW_LINE INDENT comps = \" \" ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT comps += '1' ; NEW_LINE DEDENT else : NEW_LINE INDENT comps += '0' ; NEW_LINE DEDENT DEDENT return comps ; NEW_LINE DEDENT def nthTerm ( n ) : NEW_LINE INDENT s = \"0\" ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT s += complement ( s ) ; NEW_LINE DEDENT return s ; NEW_LINE DEDENT n = 4 ; NEW_LINE print ( nthTerm ( n ) ) ; NEW_LINE"],"bleu":0.6653464851020109,"rouge_l":0.8360936607652768}
{"id":1013,"predictions":["def evenFib ( limit ) : NEW_LINE INDENT if ( limit < 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ef1 = 0 NEW_LINE ef2 = 0 NEW_LINE sum1 = ef1 + ef2 NEW_LINE while ( ef1 <= limit ) : NEW_LINE INDENT ef3 = 4 * ef1 + ef2 NEW_LINE if ( ef1 > limit ) : NEW_LINE INDENT break NEW_LINE DEDENT ef1 = ef2 NEW_LINE sum1 += ef2 NEW_LINE ef2 = ef1 NEW_LINE sum1 += ef2 NEW_LINE DEDENT return ( sum1 ) NEW_LINE DEDENT limit = 400 NEW_LINE print ( evenFib ( limit ) ) NEW_LINE"],"references":["def evenFibSum ( limit ) : NEW_LINE INDENT if ( limit < 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ef1 = 0 NEW_LINE ef2 = 2 NEW_LINE sm = ef1 + ef2 NEW_LINE while ( ef2 <= limit ) : NEW_LINE INDENT ef3 = 4 * ef2 + ef1 NEW_LINE if ( ef3 > limit ) : NEW_LINE INDENT break NEW_LINE DEDENT ef1 = ef2 NEW_LINE ef2 = ef3 NEW_LINE sm = sm + ef2 NEW_LINE DEDENT return sm NEW_LINE DEDENT limit = 400 NEW_LINE print ( evenFibSum ( limit ) ) NEW_LINE"],"bleu":0.6826273885419337,"rouge_l":0.8381679389312977}
{"id":1014,"predictions":["def factorial ( N ) : NEW_LINE INDENT fact = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT fact = fact * i NEW_LINE DEDENT return fact NEW_LINE DEDENT def nthTerm ( N ) : NEW_LINE INDENT return ( factorial ( N ) * ( N + 2 ) ) \/\/ 2 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 6 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT"],"references":["def factorial ( N ) : NEW_LINE INDENT fact = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT fact = fact * i NEW_LINE DEDENT return fact NEW_LINE DEDENT def nthTerm ( N ) : NEW_LINE INDENT return ( factorial ( N ) * ( N + 2 ) \/\/ 2 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 6 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT"],"bleu":0.9650316090710328,"rouge_l":0.9886363636363636}
{"id":1015,"predictions":["def answer ( X , K ) : NEW_LINE INDENT i = 10 NEW_LINE MAX = pow ( i , K ) - 1 NEW_LINE return ( MAX % X ) NEW_LINE DEDENT X = 30 NEW_LINE K = 3 NEW_LINE print ( answer ( X , K ) ) NEW_LINE"],"references":["def answer ( X , K ) : NEW_LINE INDENT MAX = pow ( 10 , K ) - 1 NEW_LINE return ( MAX - ( MAX % X ) ) NEW_LINE DEDENT X = 30 ; NEW_LINE K = 3 ; NEW_LINE print ( answer ( X , K ) ) ; NEW_LINE"],"bleu":0.7008737124771844,"rouge_l":0.8716992854923888}
{"id":1016,"predictions":["def maxLength ( a , n ) : NEW_LINE INDENT maximum = 1 NEW_LINE left = [ 0 for i in range ( n ) ] NEW_LINE right = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n , - 1 , - 1 ) : NEW_LINE INDENT left [ i ] = 1 NEW_LINE right [ i ] = 1 NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( a [ i ] > a [ i + 1 ] ) : NEW_LINE INDENT left [ i ] = right [ i + 1 ] + 1 NEW_LINE DEDENT DEDENT maximum = max ( maximum , left [ i ] ) NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( a [ i ] < a [ i - 1 ] ) : NEW_LINE INDENT maximum = max ( maximum , left [ i ] + right [ i + 1 ] ) NEW_LINE DEDENT DEDENT return maximum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 8 , 7 , 3 , 5 , 2 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxLength ( arr , n ) ) NEW_LINE DEDENT"],"references":["def maxLength ( a , n ) : NEW_LINE INDENT maximum = 1 ; NEW_LINE left = [ 0 ] * n ; NEW_LINE right = [ 0 ] * n ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT left [ i ] = 1 ; NEW_LINE right [ i ] = 1 ; NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( a [ i ] > a [ i + 1 ] ) : NEW_LINE INDENT right [ i ] = right [ i + 1 ] + 1 ; NEW_LINE DEDENT maximum = max ( maximum , right [ i ] ) ; NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( a [ i ] < a [ i - 1 ] ) : NEW_LINE INDENT left [ i ] = left [ i - 1 ] + 1 ; NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( a [ i - 1 ] > a [ i + 1 ] ) : NEW_LINE INDENT maximum = max ( maximum , left [ i - 1 ] + right [ i + 1 ] ) ; NEW_LINE DEDENT DEDENT DEDENT return maximum ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 8 , 7 , 3 , 5 , 2 , 9 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( maxLength ( arr , n ) ) ; NEW_LINE DEDENT"],"bleu":0.6607754664624776,"rouge_l":0.7887452194500092}
{"id":1017,"predictions":["def solve ( n ) : NEW_LINE INDENT a = [ 1 , 2 , 3 ] ; NEW_LINE i = 0 ; NEW_LINE sum = 0 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT sum += a [ i ] ; NEW_LINE i += 1 ; NEW_LINE DEDENT x = sum \/\/ n ; NEW_LINE if ( x * n == sum ) : NEW_LINE INDENT print ( x ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) ; NEW_LINE DEDENT DEDENT solve ( ) ; NEW_LINE"],"references":["if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE a = [ 1 , 2 , 3 ] NEW_LINE i = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT x = sum \/\/ n NEW_LINE if ( x * n == sum ) : NEW_LINE INDENT print ( x ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT DEDENT"],"bleu":0.568002596684914,"rouge_l":0.7544362789030293}
{"id":1018,"predictions":["import math NEW_LINE def getPerfectSquares ( n ) : NEW_LINE INDENT perfectSquares = [ ] NEW_LINE currentSquares = [ ] NEW_LINE currentSquares = [ ] NEW_LINE i = 1 NEW_LINE while ( currentSquares <= n ) : NEW_LINE INDENT perfectSquares . append ( currentSquares [ i ] ) NEW_LINE currentSquares . append ( currentSquares [ i ] ) NEW_LINE currentSquares . append ( currentSquares [ i ] ) NEW_LINE DEDENT return perfectSquares NEW_LINE DEDENT def countTriplets ( n ) : NEW_LINE INDENT perfectSquares = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT a = perfectSquares [ i ] NEW_LINE b = int ( math . sqrt ( ( a ) ) ) NEW_LINE if ( b < a ) : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT cSquare = int ( math . sqrt ( b ) ) NEW_LINE if ( cSquare ( b ) and ( cSquare ( bSquare ( cSquare ) ) ) > cSquare ) : NEW_LINE INDENT cSquares = 0 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 10 NEW_LINE print ( countTriplets ( n ) ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def getPerfectSquares ( n ) : NEW_LINE INDENT perfectSquares = [ ] NEW_LINE current = 1 NEW_LINE i = 1 NEW_LINE while ( current <= n ) : NEW_LINE INDENT perfectSquares . append ( current ) NEW_LINE i += 1 NEW_LINE current = i ** 2 NEW_LINE DEDENT return perfectSquares NEW_LINE DEDENT def countTriplets ( n ) : NEW_LINE INDENT perfectSquares = getPerfectSquares ( n ** 2 ) NEW_LINE count = 0 NEW_LINE for a in range ( 1 , n + 1 ) : NEW_LINE INDENT aSquare = a ** 2 NEW_LINE for i in range ( len ( perfectSquares ) ) : NEW_LINE INDENT cSquare = perfectSquares [ i ] NEW_LINE bSquare = abs ( cSquare - aSquare ) NEW_LINE b = math . sqrt ( bSquare ) NEW_LINE b = int ( b ) NEW_LINE c = math . sqrt ( cSquare ) NEW_LINE c = int ( c ) NEW_LINE if ( c < a or ( bSquare not in perfectSquares ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( ( b >= a ) and ( b <= c ) and ( aSquare + bSquare == cSquare ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 10 NEW_LINE print ( countTriplets ( n ) ) NEW_LINE DEDENT"],"bleu":0.5334431664099384,"rouge_l":0.6548601475206309}
{"id":1019,"predictions":["def centered_octagonal_agonal_num ( n ) : NEW_LINE INDENT return ( 5 * n - 5 * n + 2 ) \/\/ 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 7 NEW_LINE print ( \" octagonal ▁ Centagonal ▁ \" + \" number ▁ : ▁ \" , centered_octagonal_num ( n ) ) NEW_LINE DEDENT"],"references":["def centered_pentagonal_Num ( n ) : NEW_LINE INDENT return ( 5 * n * n - 5 * n + 2 ) \/\/ 2 NEW_LINE DEDENT n = 7 NEW_LINE print ( \" % sth ▁ Centered ▁ pentagonal ▁ number ▁ : ▁ \" % n , centered_pentagonal_Num ( n ) ) NEW_LINE"],"bleu":0.5387171947257974,"rouge_l":0.7401241534988714}
{"id":1020,"predictions":["def PossibleValues ( b , x , n ) : NEW_LINE INDENT minimumdivisible = ( b \/\/ x + 1 ) * x NEW_LINE flag = 1 NEW_LINE while ( minimumdivisible <= n ) : NEW_LINE INDENT if ( lowdivisible <= n ) : NEW_LINE INDENT while ( minimumdivisible <= n ) : NEW_LINE INDENT print ( mindivisible - b , end = \" ▁ \" ) NEW_LINE flag = 0 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT flag += 1 NEW_LINE DEDENT DEDENT if ( flag > 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT"],"references":["def PossibleValues ( b , x , n ) : NEW_LINE INDENT leastdivisible = int ( b \/ x + 1 ) * x NEW_LINE flag = 1 NEW_LINE while ( leastdivisible <= n ) : NEW_LINE INDENT if ( leastdivisible - b >= 1 ) : NEW_LINE INDENT print ( leastdivisible - b , end = \" ▁ \" ) NEW_LINE leastdivisible += x NEW_LINE flag = 0 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( flag != 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT b = 10 NEW_LINE x = 6 NEW_LINE n = 40 NEW_LINE PossibleValues ( b , x , n ) NEW_LINE DEDENT"],"bleu":0.563101299905905,"rouge_l":0.7014274385408407}
{"id":1021,"predictions":["def findLongRepeatingSubSeq ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE dp = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( str [ i - 1 ] == str [ j - 1 ] and i != j ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ n ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" inf \" NEW_LINE print ( findLongRepeatingSubSeq ( str ) ) NEW_LINE DEDENT"],"references":["def findLongestRepeatingSubSeq ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE dp = [ [ 0 for k in range ( n + 1 ) ] for l in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( str [ i - 1 ] == str [ j - 1 ] and i != j ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ n ] NEW_LINE DEDENT"],"bleu":0.7785071889308591,"rouge_l":0.8962139762667167}
{"id":1022,"predictions":["def countIntegralSolutions ( n ) : NEW_LINE INDENT return ( n + 1 ) * ( n + 2 ) \/\/ 2 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE print ( countIntegralSolutions ( n ) ) NEW_LINE DEDENT"],"references":["def countIntegralSolutions ( n ) : NEW_LINE INDENT return int ( ( ( n + 1 ) * ( n + 2 ) ) \/ 2 ) NEW_LINE DEDENT n = 3 NEW_LINE print ( countIntegralSolutions ( n ) ) NEW_LINE"],"bleu":0.5946535178897778,"rouge_l":0.7831988261188555}
{"id":1023,"predictions":["def check ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count & 1 ) : NEW_LINE INDENT return \" Even \" NEW_LINE DEDENT else : NEW_LINE INDENT return \" Odd \" NEW_LINE DEDENT DEDENT arr = [ 3 , 9 , 12 , 13 , 15 ] NEW_LINE n = len ( arr ) NEW_LINE print ( check ( arr , n ) ) NEW_LINE"],"references":["def check ( arr , n ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT count = count + 1 ; NEW_LINE DEDENT DEDENT if ( count & 1 ) : NEW_LINE INDENT return \" Odd \" ; NEW_LINE DEDENT else : NEW_LINE INDENT return \" Even \" ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 9 , 12 , 13 , 15 ] NEW_LINE n = len ( arr ) NEW_LINE print ( check ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.7380883575899295,"rouge_l":0.8664003550821129}
{"id":1024,"predictions":["class nodes : NEW_LINE INDENT def __init__ ( self , graph , vis ) : NEW_LINE INDENT self . graph = { } NEW_LINE self . graph = [ [ ] for i in range ( self . graph ) ] NEW_LINE DEDENT def add ( self , node , vis ) : NEW_LINE INDENT self . graph [ node ] . append ( node ) NEW_LINE self . graph [ node ] . append ( node ) NEW_LINE DEDENT def countOfNodes ( self , graph , n ) : NEW_LINE INDENT visited = [ False ] * ( n + 1 ) NEW_LINE dfs ( self , node ) NEW_LINE DEDENT def countOfNodes ( self , graph , n ) : NEW_LINE INDENT visited = [ False ] * ( n + 1 ) NEW_LINE dfs ( self , n + 1 , self . graph , vis ) NEW_LINE DEDENT def countOfNodes ( self ) : NEW_LINE INDENT visited = [ False ] * ( n + 1 ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if not visited [ i ] : NEW_LINE INDENT self . graph [ i ] . append ( i ) NEW_LINE DEDENT DEDENT DEDENT def countOfNodes ( self , n ) : NEW_LINE INDENT visited = [ False ] * ( n + 1 ) NEW_LINE dfs ( self , n + 1 ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if ( self . graph [ i ] . visited [ 0 ] ) : NEW_LINE INDENT self . graph [ i ] . append ( i ) NEW_LINE self . graph [ i ] . append ( j ) NEW_LINE DEDENT DEDENT return self . countOfNodes ( self ) NEW_LINE DEDENT def countOfNodes ( self , n ) : NEW_LINE INDENT graph = [ ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT graph [ i ] . append ( self . graph [ i ] . graph [ - 1 ] . graph [ i ] . graph [ i ] . graph [ i - 1 ] ] . append ( i ) NEW_LINE DEDENT return countOfNodes ( graph ,"],"references":["def dfs ( graph , node , dist , vis , c ) : NEW_LINE INDENT if ( vis [ node ] ) : NEW_LINE INDENT return ; NEW_LINE DEDENT vis [ node ] = True ; NEW_LINE dist [ node ] = c ; NEW_LINE for i in range ( len ( graph [ node ] ) ) : NEW_LINE INDENT if ( not vis [ graph [ node ] [ i ] ] ) : NEW_LINE INDENT dfs ( graph , graph [ node ] [ i ] , dist , vis , c + 1 ) ; NEW_LINE DEDENT DEDENT DEDENT def countOfNodes ( graph , n ) : NEW_LINE INDENT vis = [ False ] * ( n + 1 ) ; NEW_LINE dist = [ 0 ] * ( n + 1 ) ; NEW_LINE dfs ( graph , 1 , dist , vis , 0 ) ; NEW_LINE even = 0 ; odd = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( dist [ i ] % 2 == 0 ) : NEW_LINE INDENT even += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 ; NEW_LINE DEDENT DEDENT ans = ( ( even * ( even - 1 ) ) + ( odd * ( odd - 1 ) ) ) \/\/ 2 ; NEW_LINE return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 ; NEW_LINE graph = [ [ ] , [ 2 ] , [ 1 , 3 ] , [ 2 ] ] ; NEW_LINE ans = countOfNodes ( graph , n ) ; NEW_LINE print ( ans ) ; NEW_LINE DEDENT"],"bleu":0.25713261714222435,"rouge_l":0.42043933158129615}
{"id":1025,"predictions":["def flipsPossible ( a , n ) : NEW_LINE INDENT count_odd = 0 NEW_LINE count_even = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( a [ i ] & 1 ) == 1 ) : NEW_LINE INDENT count_even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_even += 1 NEW_LINE DEDENT DEDENT if ( count_even % 2 == 1 and count_even % 2 == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 0 , 1 , 1 , 0 , 1 ] NEW_LINE n = len ( a ) NEW_LINE if ( flipsPossible ( a , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def flipsPossible ( a , n ) : NEW_LINE INDENT count_odd = 0 ; count_even = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] & 1 ) : NEW_LINE INDENT count_odd += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT count_even += 1 ; NEW_LINE DEDENT DEDENT if ( count_odd % 2 and count_even % 2 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT else : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 0 , 1 , 1 , 0 , 1 ] ; NEW_LINE n = len ( a ) ; NEW_LINE if ( flipsPossible ( a , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"],"bleu":0.7810998109719076,"rouge_l":0.9269175108538349}
{"id":1026,"predictions":["def findSeries ( num , first , second ) : NEW_LINE INDENT print ( first , end = \" ▁ \" ) ; NEW_LINE counter = 0 ; NEW_LINE while ( counter < num - 2 ) : NEW_LINE INDENT sum = first + second ; NEW_LINE print ( sum , end = \" ▁ \" ) ; NEW_LINE counter += 1 ; NEW_LINE while ( counter < num - 2 ) : NEW_LINE INDENT sum = sum + second ; NEW_LINE counter += 1 ; NEW_LINE DEDENT print ( sum , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 ; NEW_LINE first = 2 ; NEW_LINE second = 4 ; NEW_LINE findSeries ( n , first , sec ) ; NEW_LINE DEDENT"],"references":["def findSeries ( num , first , sec ) : NEW_LINE INDENT print ( \" { } ▁ { } ▁ \" . format ( first , sec ) , end = \" \" ) NEW_LINE counter = 0 NEW_LINE while ( counter < num - 2 ) : NEW_LINE INDENT sum = first + sec NEW_LINE print ( \" { } ▁ \" . format ( sum ) , end = \" \" ) NEW_LINE first = sec NEW_LINE sec = sum NEW_LINE counter = counter + 1 NEW_LINE DEDENT DEDENT n = 5 NEW_LINE first = 2 NEW_LINE sec = 4 NEW_LINE findSeries ( n , first , sec ) NEW_LINE"],"bleu":0.37926949180173014,"rouge_l":0.6426972211247202}
{"id":1027,"predictions":["def countOdd ( n ) : NEW_LINE INDENT coun = 0 NEW_LINE j , i = n - 2 , j NEW_LINE while ( i >= 1 ) : NEW_LINE INDENT if ( i >= 1 ) : NEW_LINE INDENT m = ( n - i ) \/\/ 2 NEW_LINE j = ( i * ( i + 1 ) ) \/\/ 2 NEW_LINE dis += j * j NEW_LINE DEDENT else : NEW_LINE INDENT m = ( i * ( i + 1 ) ) \/\/ 2 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return coun NEW_LINE DEDENT def countOdd ( n ) : NEW_LINE INDENT coun = 0 NEW_LINE i = n - 1 NEW_LINE j = 0 NEW_LINE while ( i >= 1 ) : NEW_LINE INDENT if ( i >= 1 ) : NEW_LINE INDENT m = ( n - i ) \/\/ 2 NEW_LINE DEDENT else : NEW_LINE INDENT m = ( i * ( i + 1 ) ) \/\/ 2 NEW_LINE j = ( i * m * m ) \/\/ 2 NEW_LINE DEDENT DEDENT return coun NEW_LINE DEDENT def countOdd ( n ) : NEW_LINE INDENT coun = 0 NEW_LINE if ( n >= 1 ) : NEW_LINE INDENT m = ( n - 1 ) \/\/ 2 NEW_LINE if ( i >= 1 ) : NEW_LINE INDENT m = ( i * ( i + 1 ) ) \/\/ 2 NEW_LINE coun += j * m NEW_LINE DEDENT else : NEW_LINE INDENT m = ( i * ( i * ( i + 1 ) ) \/\/ 2 NEW_LINE DEDENT DEDENT return coun NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( countOdd ( n ) ) NEW_LINE DEDENT"],"references":["def countOdd ( n ) : NEW_LINE INDENT coun = 0 NEW_LINE i = n - 2 NEW_LINE while ( i >= 1 ) : NEW_LINE INDENT if ( i & 1 ) : NEW_LINE INDENT m = int ( ( n - i ) \/ 2 ) NEW_LINE j = int ( ( i * ( i + 1 ) ) \/ 2 ) NEW_LINE coun += j * m NEW_LINE DEDENT else : NEW_LINE INDENT m = int ( ( ( n - 1 ) - i ) \/ 2 ) NEW_LINE j = int ( ( i * ( i + 1 ) ) \/ 2 ) NEW_LINE coun += j * m NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT return coun NEW_LINE DEDENT def countEven ( n ) : NEW_LINE INDENT coun = 0 NEW_LINE i = n - 2 NEW_LINE while ( i >= 1 ) : NEW_LINE INDENT if ( i & 1 ) : NEW_LINE INDENT m = int ( ( ( n - 1 ) - i ) \/ 2 ) NEW_LINE j = int ( ( i * ( i + 1 ) ) \/ 2 ) NEW_LINE coun += j * m NEW_LINE DEDENT else : NEW_LINE INDENT m = int ( ( n - i ) \/ 2 ) NEW_LINE j = ( i * ( i + 1 ) ) \/\/ 2 NEW_LINE coun += j * m NEW_LINE DEDENT DEDENT return coun NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE if ( n & 1 ) : NEW_LINE INDENT print ( countOdd ( n ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( countEven ( n ) ) NEW_LINE DEDENT DEDENT"],"bleu":0.6269601590734387,"rouge_l":0.7021921128001762}
{"id":1028,"predictions":["mod = 10 ** 9 + 7 NEW_LINE def factorial ( n , p ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res = ( res * i ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def power ( x , p , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def modInverse ( def n , r , p ) : NEW_LINE INDENT if ( r == 0 ) : NEW_LINE INDENT return power ( n , p - 2 , p ) NEW_LINE DEDENT fac = [ 0 ] * n NEW_LINE fac [ 0 ] = 1 NEW_LINE fac [ 1 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fac [ i ] = fac [ i - 1 ] * i % p NEW_LINE DEDENT return fac [ n ] NEW_LINE DEDENT def nCr ( n , r , p ) : NEW_LINE INDENT return ( fact [ n ] * modInverse ( fac [ r ] , p ) % p ) % p NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 5 NEW_LINE K = 8 NEW_LINE print ( int ( n , K ) ) NEW_LINE DEDENT"],"references":["mod = 10 ** 9 + 7 NEW_LINE def factorial ( n , p ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res = ( res * i ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def modInverse ( n , p ) : NEW_LINE INDENT return power ( n , p - 2 , p ) NEW_LINE DEDENT def nCrModP ( n , r , p ) : NEW_LINE INDENT if ( r == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT fac = [ 0 for i in range ( n + 1 ) ] NEW_LINE fac [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fac [ i ] = fac [ i - 1 ] * i % p NEW_LINE DEDENT return ( fac [ n ] * modInverse ( fac [ r ] , p ) % p * modInverse ( fac [ n - r ] , p ) % p ) % p NEW_LINE DEDENT def countArrangements ( n , k , p ) : NEW_LINE INDENT return ( factorial ( n , p ) * nCrModP ( k , n , p ) ) % p NEW_LINE DEDENT N = 5 NEW_LINE K = 8 NEW_LINE print ( countArrangements ( N , K , mod ) ) NEW_LINE"],"bleu":0.7647964107459633,"rouge_l":0.782940698619009}
{"id":1029,"predictions":["def subString ( string , n ) : NEW_LINE INDENT for len in range ( 1 , n + 1 ) : NEW_LINE INDENT for i in range ( n - len ( string ) + 1 ) : NEW_LINE INDENT j = i + len ( string [ i ] ) NEW_LINE print ( string [ i ] , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" aa \" NEW_LINE subString ( string , len ( string ) ) NEW_LINE DEDENT"],"references":["def subString ( Str , n ) : NEW_LINE INDENT for Len in range ( 1 , n + 1 ) : NEW_LINE INDENT for i in range ( n - Len + 1 ) : NEW_LINE INDENT j = i + Len - 1 NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT print ( Str [ k ] , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT DEDENT Str = \" abc \" NEW_LINE subString ( Str , len ( Str ) ) NEW_LINE"],"bleu":0.5452510961036017,"rouge_l":0.7339706609526948}
{"id":1030,"predictions":["def sumofseries ( n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT res += ( i * ( i + 1 ) * ( i + 2 ) * ( i + 2 ) ) NEW_LINE DEDENT return res NEW_LINE DEDENT print ( sumofseries ( 3 ) ) NEW_LINE"],"references":["def sumofseries ( n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT res += ( i ) * ( i + 1 ) * ( i + 2 ) NEW_LINE DEDENT return res NEW_LINE DEDENT print ( sumofseries ( 3 ) ) NEW_LINE"],"bleu":0.8667721758571288,"rouge_l":0.941825199889716}
{"id":1031,"predictions":["def countWaysToJump ( arr , n ) : NEW_LINE INDENT count_match = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] >= n - i - 1 ) : NEW_LINE INDENT count_match [ i ] += 1 NEW_LINE DEDENT DEDENT for j in range ( i + 1 , n - 1 , 1 ) : NEW_LINE INDENT if ( count_match [ j ] != - 1 ) : NEW_LINE INDENT count_match [ i ] += count_match [ j ] NEW_LINE DEDENT DEDENT if ( count_match [ i ] == 0 ) : NEW_LINE INDENT count_match [ i ] = - 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( count_match [ i ] ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 3 , 5 , 8 , 9 , 6 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE countWaysToJump ( arr , n ) NEW_LINE DEDENT"],"references":["def countWaysToJump ( arr , n ) : NEW_LINE INDENT count_jump = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] >= n - i - 1 ) : NEW_LINE INDENT count_jump [ i ] += 1 NEW_LINE DEDENT j = i + 1 NEW_LINE while ( j < n - 1 and j <= arr [ i ] + i ) : NEW_LINE INDENT if ( count_jump [ j ] != - 1 ) : NEW_LINE INDENT count_jump [ i ] += count_jump [ j ] NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( count_jump [ i ] == 0 ) : NEW_LINE INDENT count_jump [ i ] = - 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( count_jump [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 1 , 3 , 5 , 8 , 9 , 1 , 0 , 7 , 6 , 8 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE countWaysToJump ( arr , n ) NEW_LINE"],"bleu":0.7180463993826384,"rouge_l":0.8350213641398956}
{"id":1032,"predictions":["import math NEW_LINE def calculateSum ( n ) : NEW_LINE INDENT return 2 * ( pow ( n , 6 ) + 15 * math . pow ( n , 2 ) + 15 * math . pow ( n , 2 ) + 1 ) NEW_LINE DEDENT n = 1.0 NEW_LINE print ( calculateSum ( n ) ) NEW_LINE"],"references":["import math NEW_LINE def calculateSum ( n ) : NEW_LINE INDENT a = int ( n ) NEW_LINE return ( 2 * ( pow ( n , 6 ) + 15 * pow ( n , 4 ) + 15 * pow ( n , 2 ) + 1 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 1.4142 NEW_LINE print ( math . ceil ( calculateSum ( n ) ) ) NEW_LINE DEDENT"],"bleu":0.4695332545648385,"rouge_l":0.7281167108753316}
{"id":1033,"predictions":["def isMajority ( a , n ) : NEW_LINE INDENT mp = { i : 0 for i in a } NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ a [ i ] ] += 1 NEW_LINE DEDENT if ( mp . get ( a [ i ] ) >= n \/\/ 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 2 , 3 , 9 , 2 , 2 ] NEW_LINE n = len ( a ) NEW_LINE if ( isMajority ( a , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def isMajority ( a ) : NEW_LINE INDENT mp = { } NEW_LINE for i in a : NEW_LINE INDENT if i in mp : mp [ i ] += 1 NEW_LINE else : mp [ i ] = 1 NEW_LINE DEDENT for x in mp : NEW_LINE INDENT if mp [ x ] >= len ( a ) \/\/ 2 : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT a = [ 2 , 3 , 9 , 2 , 2 ] NEW_LINE print ( \" Yes \" if isMajority ( a ) else \" No \" ) NEW_LINE"],"bleu":0.3941118420517035,"rouge_l":0.5967208597409756}
{"id":1034,"predictions":["def MaxSum ( A , B , n ) : NEW_LINE INDENT m = set ( ) NEW_LINE result = 0 NEW_LINE curr_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while A [ i ] >= A [ curr_sum ] : NEW_LINE INDENT curr_sum -= A [ i ] NEW_LINE curr_sum -= A [ curr_sum ] NEW_LINE curr_sum += 1 NEW_LINE DEDENT result = max ( result , curr_sum ) NEW_LINE curr_sum += B [ curr_sum ] NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 0 , 1 , 2 , 3 , 2 , 4 , 1 , 4 , 5 ] NEW_LINE n = len ( A ) NEW_LINE print ( MaxSum ( A , B , n ) ) NEW_LINE DEDENT"],"references":["def returnMaxSum ( A , B , n ) : NEW_LINE INDENT mp = set ( ) NEW_LINE result = 0 NEW_LINE curr_sum = curr_begin = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT while A [ i ] in mp : NEW_LINE INDENT mp . remove ( A [ curr_begin ] ) NEW_LINE curr_sum -= B [ curr_begin ] NEW_LINE curr_begin += 1 NEW_LINE DEDENT mp . add ( A [ i ] ) NEW_LINE curr_sum += B [ i ] NEW_LINE result = max ( result , curr_sum ) NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 0 , 1 , 2 , 3 , 0 , 1 , 4 ] NEW_LINE B = [ 9 , 8 , 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( A ) NEW_LINE print ( returnMaxSum ( A , B , n ) ) NEW_LINE DEDENT"],"bleu":0.6257601860487236,"rouge_l":0.7600081699346405}
{"id":1035,"predictions":["class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def hasPath ( root , arr , x ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( root . data == x ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if ( hasPath ( root , arr , arr , x ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( hasPath ( root , arr , x ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( hasPath ( root , arr , x ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ ] NEW_LINE root = Node ( 2 ) NEW_LINE root . left = Node ( 5 ) NEW_LINE root . left = Node ( 6 ) NEW_LINE root . left = Node ( 4 ) NEW_LINE root . right = Node ( 5 ) NEW_LINE root . right = Node ( 6 ) NEW_LINE root . right = Node ( 4 ) NEW_LINE root . left . left = Node ( 7 ) NEW_LINE root . left . right = Node ( 4 ) NEW_LINE root . left . left = Node ( 5 ) NEW_LINE root . right . left = Node ( 7 ) NEW_LINE print ( \" No ▁ path \" ) NEW_LINE DEDENT"],"references":["class getNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = self . right = None NEW_LINE DEDENT DEDENT def hasPath ( root , arr , x ) : NEW_LINE INDENT if ( not root ) : NEW_LINE INDENT return False NEW_LINE DEDENT arr . append ( root . data ) NEW_LINE if ( root . data == x ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( hasPath ( root . left , arr , x ) or hasPath ( root . right , arr , x ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT arr . pop ( - 1 ) NEW_LINE return False NEW_LINE DEDENT def printPath ( root , x ) : NEW_LINE INDENT arr = [ ] NEW_LINE if ( hasPath ( root , arr , x ) ) : NEW_LINE INDENT for i in range ( len ( arr ) - 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" - > \" ) NEW_LINE DEDENT print ( arr [ len ( arr ) - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No ▁ Path \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = getNode ( 1 ) NEW_LINE root . left = getNode ( 2 ) NEW_LINE root . right = getNode ( 3 ) NEW_LINE root . left . left = getNode ( 4 ) NEW_LINE root . left . right = getNode ( 5 ) NEW_LINE root . right . left = getNode ( 6 ) NEW_LINE root . right . right = getNode ( 7 ) NEW_LINE x = 5 NEW_LINE printPath ( root , x ) NEW_LINE DEDENT"],"bleu":0.5658078070370511,"rouge_l":0.6355590410038092}
{"id":1036,"predictions":["def SieveOfEratosthenes ( prime , p_size ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , p_size + 1 ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT for i in range ( p * 2 , p_size + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def xorOfElements ( prime , n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) NEW_LINE SieveOfEratosthenes ( prime , n + 1 ) NEW_LINE m = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT m [ arr [ i ] ] = m . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT xor = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if m [ arr [ i ] ] ] : NEW_LINE INDENT xor ^= ( prime [ arr [ i ] ] + 1 ) NEW_LINE DEDENT DEDENT return xor NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 5 , 4 , 6 , 4 , 4 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( xorOfElements ( arr , n ) ) NEW_LINE DEDENT"],"references":["from math import sqrt NEW_LINE def SieveOfEratosthenes ( prime , p_size ) : NEW_LINE INDENT prime [ 0 ] = False ; NEW_LINE prime [ 1 ] = False ; NEW_LINE for p in range ( 2 , int ( sqrt ( p_size ) ) + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( p * 2 , p_size + 1 , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT DEDENT return prime NEW_LINE DEDENT def xorPrimeFreq ( arr , n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) ; NEW_LINE prime = SieveOfEratosthenes ( prime , n + 1 ) ; NEW_LINE m = dict . fromkeys ( arr , 0 ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT m [ arr [ i ] ] += 1 ; NEW_LINE DEDENT xorVal = 0 ; NEW_LINE for key , value in m . items ( ) : NEW_LINE INDENT if ( prime [ value ] ) : NEW_LINE INDENT xorVal ^= key ; NEW_LINE DEDENT DEDENT return xorVal ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 5 , 4 , 6 , 5 , 4 , 6 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( xorPrimeFreq ( arr , n ) ) ; NEW_LINE DEDENT"],"bleu":0.6208793931718338,"rouge_l":0.7912592296946717}
{"id":1037,"predictions":["def minimumFlipwise ( s , x , y ) : NEW_LINE INDENT s = s + s NEW_LINE if ( x > y ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( x > y ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( ( x > y ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def minimumFlipwise ( s , x , y ) : NEW_LINE INDENT if ( s [ x ] != cur ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT val = 0 NEW_LINE cur = s [ x ] NEW_LINE for i in range ( y , x + 1 ) : NEW_LINE INDENT if ( s [ i ] != cur ) : NEW_LINE INDENT cur += s [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT val += ord ( s [ i ] ) NEW_LINE DEDENT DEDENT if ( not ( val ) ) : NEW_LINE INDENT if ( not prefwisewise ( val ) ) : NEW_LINE INDENT if ( not prefwise ( val , val ) ) : NEW_LINE INDENT if ( not prefwise ( val , x , y ) ) : NEW_LINE INDENT val += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( \" Bitswise ▁ change \" , val , val ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x , y = 0 , 8 NEW_LINE s = \"0001\" NEW_LINE minimumFlipwise ( s , x , y ) NEW_LINE DEDENT"],"references":["def minimumFlip ( s , x , y ) : NEW_LINE INDENT s = s + s NEW_LINE isOpposite = False NEW_LINE if ( x > y ) : NEW_LINE INDENT temp = y NEW_LINE y = x ; NEW_LINE x = temp NEW_LINE isOpposite = True NEW_LINE DEDENT valClockwise = 0 NEW_LINE cur = s [ x ] NEW_LINE for i in range ( x , y + 1 , 1 ) : NEW_LINE INDENT if ( s [ i ] != cur ) : NEW_LINE INDENT cur = s [ i ] NEW_LINE valClockwise += 1 NEW_LINE DEDENT DEDENT valAnticlockwise = 0 NEW_LINE cur = s [ y ] NEW_LINE x += len ( s ) - 1 NEW_LINE for i in range ( y , x + 1 , 1 ) : NEW_LINE INDENT if ( s [ i ] != cur ) : NEW_LINE INDENT cur = s [ i ] NEW_LINE valAnticlockwise += 1 NEW_LINE DEDENT DEDENT if ( valClockwise <= valAnticlockwise ) : NEW_LINE INDENT if ( isOpposite == False ) : NEW_LINE INDENT print ( \" Clockwise \" , valClockwise ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Anti - clockwise \" , valAnticlockwise ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( isOpposite == False ) : NEW_LINE INDENT print ( \" Anti - clockwise \" , valAnticlockwise ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Clockwise \" , valClockwise ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 0 NEW_LINE y = 8 NEW_LINE s = \"000110\" NEW_LINE minimumFlip ( s , x , y ) NEW_LINE DEDENT"],"bleu":0.5154010693761379,"rouge_l":0.6149558204352725}
{"id":1038,"predictions":["MAX = 26 NEW_LINE def maxSubStr ( str1 , len1 ) : NEW_LINE INDENT if ( len1 > len2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT freq1 = [ 0 ] * MAX NEW_LINE freq2 = [ 0 ] * MAX NEW_LINE for i in range ( len1 ) : NEW_LINE INDENT freq1 [ i ] = 0 NEW_LINE DEDENT freq1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE freq2 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( len1 ) : NEW_LINE INDENT freq2 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( MAX ) : NEW_LINE INDENT freq1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT minPoss2 = [ 0 ] * MAX NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT freq2 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE if ( freq1 [ i ] == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return min ( freq1 , freq2 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" geeksforgeeks \" NEW_LINE str1 = \" geeksforgeeks \" NEW_LINE len1 = len ( str1 ) NEW_LINE print ( maxSubStr ( str1 , len1 , len2 ) ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE MAX = 26 ; NEW_LINE def maxSubStr ( str1 , len1 , str2 , len2 ) : NEW_LINE INDENT if ( len1 > len2 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT freq1 = [ 0 ] * MAX ; NEW_LINE for i in range ( len1 ) : NEW_LINE INDENT freq1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT freq2 = [ 0 ] * MAX ; NEW_LINE for i in range ( len2 ) : NEW_LINE INDENT freq2 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT minPoss = sys . maxsize ; NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if ( freq1 [ i ] == 0 ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT if ( freq1 [ i ] > freq2 [ i ] ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT minPoss = min ( minPoss , freq2 [ i ] \/ freq1 [ i ] ) ; NEW_LINE DEDENT return int ( minPoss ) ; NEW_LINE DEDENT str1 = \" geeks \" ; str2 = \" gskefrgoekees \" ; NEW_LINE len1 = len ( str1 ) ; NEW_LINE len2 = len ( str2 ) ; NEW_LINE print ( maxSubStr ( str1 , len1 , str2 , len2 ) ) ; NEW_LINE"],"bleu":0.5392318774204597,"rouge_l":0.6595867928171462}
{"id":1039,"predictions":["def isValid ( string , n ) : NEW_LINE INDENT index = - 1 NEW_LINE if ( index == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( index != - 1 ) : NEW_LINE INDENT if ( string [ index - 1 ] != ' a ' ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( index + 2 < n and string [ index + 1 ] != ' a ' ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( index + 2 < n and string [ index + 2 ] != ' b ' ) : NEW_LINE INDENT return False NEW_LINE DEDENT index = string [ index : index + 2 ] NEW_LINE if ( index + 2 < n and string [ index + 2 ] != ' b ' ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( index + 2 < n and string [ index + 2 ] != ' a ' ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( index + 2 < n and string [ index + 2 ] != ' b ' ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" abaaabbaa \" NEW_LINE n = len ( string ) NEW_LINE print ( isValid ( string , n ) ) NEW_LINE DEDENT"],"references":["def isValidString ( str , n ) : NEW_LINE INDENT idx = str . find ( \" b \" ) NEW_LINE if ( idx == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( idx != - 1 ) : NEW_LINE INDENT if ( str [ idx - 1 ] != ' a ' ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( idx + 1 < n and str [ idx + 1 ] != ' b ' ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( idx + 2 < n and str [ idx + 2 ] == ' b ' ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( idx == n - 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT idx = str . find ( \" b \" , idx + 2 ) NEW_LINE DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" abbaaabbabba \" NEW_LINE n = len ( str ) NEW_LINE print ( isValidString ( str , n ) ) NEW_LINE DEDENT"],"bleu":0.46264560132115223,"rouge_l":0.6921044451352191}
{"id":1040,"predictions":["def gcd ( a , b ) : NEW_LINE INDENT if ( a % b == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT def firstFactorialDivisibleNumber ( x , a ) : NEW_LINE INDENT i = 1 NEW_LINE new_x = x NEW_LINE for i in range ( 1 , x + 1 ) : NEW_LINE INDENT new_x \/= gcd ( i , new_x ) NEW_LINE if ( new_x == 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return i NEW_LINE DEDENT x = 16 NEW_LINE print ( firstFactorialDivisibleNumber ( x ) ) NEW_LINE"],"references":["def gcd ( a , b ) : NEW_LINE INDENT if ( ( a % b ) == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT def firstFactorialDivisibleNumber ( x ) : NEW_LINE INDENT i = 1 NEW_LINE new_x = x NEW_LINE for i in range ( 1 , x ) : NEW_LINE INDENT new_x \/= gcd ( i , new_x ) NEW_LINE if ( new_x == 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return i NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT x = 16 NEW_LINE print ( firstFactorialDivisibleNumber ( x ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"bleu":0.7145432127341367,"rouge_l":0.8488403819918143}
{"id":1041,"predictions":["def xorK ( arr , n , k ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp = 0 ; NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT temp = temp ^ arr [ j ] ; NEW_LINE if ( temp < k ) : NEW_LINE INDENT count = count + 1 ; NEW_LINE DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT k = 3 ; NEW_LINE arr = [ 8 , 9 , 10 , 11 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( xorK ( arr , n , k ) ) ; NEW_LINE DEDENT"],"references":["def xorLessK ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT tempXor = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT tempXor ^= arr [ j ] NEW_LINE if ( tempXor < k ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT k = 3 NEW_LINE arr = [ 8 , 9 , 10 , 11 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE print ( xorLessK ( arr , n , k ) ) NEW_LINE DEDENT"],"bleu":0.672936929212192,"rouge_l":0.8915075707702436}
{"id":1042,"predictions":["def findNumbers ( arr , n ) : NEW_LINE INDENT num_minus = arr [ n - 1 ] NEW_LINE b_minus = arr [ n - 1 ] - arr [ 0 ] NEW_LINE num_minus = arr [ n - 2 ] - arr [ 1 ] NEW_LINE for i in range ( 1 , ( n - 2 , 1 ) + 1 ) : NEW_LINE INDENT num_minus [ i ] = arr [ i + 1 ] - num_minus NEW_LINE num_minus [ i ] = arr [ i + 1 ] - num_minus NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT num_minus [ i ] = arr [ i ] NEW_LINE DEDENT print ( \" Number ▁ of ▁ arr , end = \" ▁ \" ) NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT print ( num_minus [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 13 , 10 , 14 , 17 , 17 , 17 , 17 , 17 , 17 , 17 ] NEW_LINE n = len ( arr ) NEW_LINE findNumbers ( arr , n ) NEW_LINE DEDENT"],"references":["def findNumbers ( arr , n ) : NEW_LINE INDENT num = [ 0 for i in range ( n ) ] NEW_LINE b_minus_a = arr [ n - 1 ] - arr [ 1 ] NEW_LINE num [ 1 ] = ( arr [ 0 ] + b_minus_a ) \/\/ 2 NEW_LINE num [ 0 ] = arr [ 0 ] - num [ 1 ] NEW_LINE for i in range ( 1 , ( n - 2 ) + 1 ) : NEW_LINE INDENT num [ i + 1 ] = arr [ i ] - num [ 0 ] NEW_LINE DEDENT print ( \" Numbers ▁ are : ▁ \" , end = \" \" ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( num [ i ] , end = \" , ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 13 , 10 , 14 , 9 , 17 , 21 , 16 , 18 , 13 , 17 ] NEW_LINE n = 5 NEW_LINE findNumbers ( arr , n ) NEW_LINE"],"bleu":0.5059891350999622,"rouge_l":0.6926609334557903}
{"id":1043,"predictions":["from math import sqrt NEW_LINE primes = [ ] NEW_LINE def sieve ( ) : NEW_LINE INDENT prime = [ True ] * ( 101 + 1 ) NEW_LINE for p in range ( 2 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , n , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for p in range ( 2 , int ( sqrt ( n ) ) + 1 , 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT primes . append ( i ) NEW_LINE DEDENT DEDENT DEDENT def SemiPrimeSum ( N ) : NEW_LINE INDENT ans = 0 NEW_LINE i = 0 NEW_LINE while ( i < len ( primes ) ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT primes [ i ] ] = False NEW_LINE for j in range ( i , len ( primes ) ) : NEW_LINE INDENT if ( prime [ j ] ) : NEW_LINE INDENT primes . append ( primes [ j ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 6 NEW_LINE sieve ( ) NEW_LINE print ( SemiPrimeSum ( N ) ) NEW_LINE DEDENT"],"references":["pr = [ ] NEW_LINE prime = [ 1 for i in range ( 10000000 + 1 ) ] NEW_LINE def sieve ( n ) : NEW_LINE INDENT for p in range ( 2 , n ) : NEW_LINE INDENT if p * p > n : NEW_LINE INDENT break NEW_LINE DEDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( 2 * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT pr . append ( p ) NEW_LINE DEDENT DEDENT DEDENT def SemiPrimeSum ( N ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( len ( pr ) ) : NEW_LINE INDENT for j in range ( i , len ( pr ) ) : NEW_LINE INDENT if ( pr [ i ] * pr [ j ] > N ) : NEW_LINE INDENT break NEW_LINE DEDENT ans += pr [ i ] * pr [ j ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT N = 6 NEW_LINE sieve ( N ) NEW_LINE print ( SemiPrimeSum ( N ) ) NEW_LINE"],"bleu":0.5695308194257807,"rouge_l":0.7023876801356316}
{"id":1044,"predictions":["def largestPalinSub ( s ) : NEW_LINE INDENT res = \" \" NEW_LINE mx = len ( s ) NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT mx = max ( mx , len ( s [ i ] ) ) NEW_LINE DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == mx : NEW_LINE INDENT res += s [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" geeksforgeeks \" NEW_LINE print ( largestPalinSub ( s ) ) NEW_LINE DEDENT"],"references":["def largestPalinSub ( s ) : NEW_LINE INDENT res = \" \" NEW_LINE mx = s [ 0 ] NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT mx = max ( mx , s [ i ] ) NEW_LINE DEDENT for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT if s [ i ] == mx : NEW_LINE INDENT res += s [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" geeksforgeeks \" NEW_LINE print ( largestPalinSub ( s ) ) NEW_LINE DEDENT"],"bleu":0.9006125783393051,"rouge_l":0.9527152887233128}
{"id":1045,"predictions":["def PrintPartialChar ( matrix , start , end ) : NEW_LINE INDENT print ( \" All ▁ possible \" , end = \" \" ) NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT print ( matrix [ start ] , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def allPartialChar ( a , start , end ) : NEW_LINE INDENT print ( ) NEW_LINE print ( \" All ▁ possible \" , end = \" ) NEW_LINE allPartialPartial ( a , start , end = \" \" ) NEW_LINE for i in range ( len ( allPartialChar ( a , start , i ) ) : NEW_LINE INDENT print ( allPartial , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def allPartialChar ( arr , start , start , end ) : NEW_LINE INDENT allPartialChar ( arr , start , end = \" \" ) NEW_LINE for i in range ( start , start , end ) : NEW_LINE INDENT if ( isPalindrome ( arr , start , i + 1 , end ) ) : NEW_LINE INDENT for j in range ( i , len ( arr ) ) : NEW_LINE INDENT if ( isPalindrome ( arr , start , i + 1 , end ) ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT allPartialChar ( matrix , start , end ) NEW_LINE DEDENT"],"references":["def isPalindrome ( string : str , low : int , high : int ) : NEW_LINE INDENT while low < high : NEW_LINE INDENT if string [ low ] != string [ high ] : NEW_LINE INDENT return False NEW_LINE DEDENT low += 1 NEW_LINE high -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def allPalPartUtil ( allPart : list , currPart : list , start : int , n : int , string : str ) : NEW_LINE INDENT if start >= n : NEW_LINE INDENT x = currPart . copy ( ) NEW_LINE allPart . append ( x ) NEW_LINE return NEW_LINE DEDENT for i in range ( start , n ) : NEW_LINE INDENT if isPalindrome ( string , start , i ) : NEW_LINE INDENT currPart . append ( string [ start : i + 1 ] ) NEW_LINE allPalPartUtil ( allPart , currPart , i + 1 , n , string ) NEW_LINE currPart . pop ( ) NEW_LINE DEDENT DEDENT DEDENT def allPalPartitions ( string : str ) : NEW_LINE INDENT n = len ( string ) NEW_LINE allPart = [ ] NEW_LINE currPart = [ ] NEW_LINE allPalPartUtil ( allPart , currPart , 0 , n , string ) NEW_LINE for i in range ( len ( allPart ) ) : NEW_LINE INDENT for j in range ( len ( allPart [ i ] ) ) : NEW_LINE INDENT print ( allPart [ i ] [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" nitin \" NEW_LINE allPalPartitions ( string ) NEW_LINE DEDENT"],"bleu":0.34536503446421146,"rouge_l":0.4450458931513297}
{"id":1046,"predictions":["def findLength ( str , n ) : NEW_LINE INDENT current_sum = 0 NEW_LINE max_sum = 0 NEW_LINE current_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT current_sum += ( ord ( str [ i ] ) ) NEW_LINE if ( current_sum < current_sum ) : NEW_LINE INDENT current_sum = 0 NEW_LINE DEDENT else : NEW_LINE INDENT current_sum = current_sum + ( current_sum ) NEW_LINE DEDENT current_sum = max ( current_sum , max_sum ) NEW_LINE DEDENT return max_sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = [ 110000 ] NEW_LINE n = len ( str ) NEW_LINE print ( findLength ( str , n ) ) NEW_LINE DEDENT"],"references":["def findLength ( string , n ) : NEW_LINE INDENT current_sum = 0 NEW_LINE max_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT current_sum += ( 1 if string [ i ] == '0' else - 1 ) NEW_LINE if current_sum < 0 : NEW_LINE INDENT current_sum = 0 NEW_LINE DEDENT max_sum = max ( current_sum , max_sum ) NEW_LINE DEDENT return max_sum if max_sum else 0 NEW_LINE DEDENT s = \"11000010001\" NEW_LINE n = 11 NEW_LINE print ( findLength ( s , n ) ) NEW_LINE"],"bleu":0.4688196054479979,"rouge_l":0.6999371266897202}
{"id":1047,"predictions":["def Selling ( Arr , N , K ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( Arr [ i ] == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( Arr [ count ] == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT Arr = [ 5 , 1 ] NEW_LINE N = len ( Arr ) NEW_LINE K = 2 NEW_LINE result = Selling ( Arr , N , K ) NEW_LINE if ( result == 1 ) : NEW_LINE INDENT print ( \" Possible \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ Possible \" ) NEW_LINE DEDENT DEDENT"],"references":["def Series ( Arr , N , K ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if Arr [ i ] == 1 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if K >= ( N - count ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT Arr = [ 5 , 1 , 2 ] NEW_LINE N = len ( Arr ) NEW_LINE K = 2 NEW_LINE result = Series ( Arr , N , K ) NEW_LINE if result == 1 : NEW_LINE INDENT print ( \" Possible \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ Possible \" ) NEW_LINE DEDENT"],"bleu":0.6759058478455865,"rouge_l":0.8701201201201202}
{"id":1048,"predictions":["def countDigit ( n ) : NEW_LINE INDENT prime = [ True ] * 10 NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE prime [ 2 ] = True NEW_LINE count = 0 NEW_LINE while ( temp ) : NEW_LINE INDENT d = temp % 10 NEW_LINE if ( d != 0 and n % d == 0 and prime [ d ] ) : NEW_LINE INDENT prime [ d ] = False NEW_LINE DEDENT if ( d > 0 and prime [ d ] == True ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT n = 1032 NEW_LINE print ( countDigit ( n ) ) NEW_LINE"],"references":["def countDigit ( n ) : NEW_LINE INDENT prime = [ False ] * 10 NEW_LINE prime [ 2 ] = True NEW_LINE prime [ 3 ] = True ; NEW_LINE prime [ 5 ] = True NEW_LINE prime [ 7 ] = True ; NEW_LINE temp = n NEW_LINE count = 0 ; NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT d = temp % 10 ; NEW_LINE temp \/\/= 10 ; NEW_LINE if ( d > 0 and n % d == 0 and prime [ d ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT n = 1032 NEW_LINE print ( countDigit ( n ) ) NEW_LINE"],"bleu":0.6712135748807028,"rouge_l":0.7490342163355409}
{"id":1049,"predictions":["import math as mt NEW_LINE def polyapmatrix ( n , a ) : NEW_LINE INDENT if ( a < 0 and n < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ( a \/ mt . sin ( ( 180 \/ n ) * 3.14159 \/ 180 ) ) NEW_LINE DEDENT a = 9 NEW_LINE n = 6 NEW_LINE print ( polyapmatrix ( n , a ) ) NEW_LINE"],"references":["from math import tan NEW_LINE def polyapothem ( n , a ) : NEW_LINE INDENT if ( a < 0 and n < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return a \/ ( 2 * tan ( ( 180 \/ n ) * 3.14159 \/ 180 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 9 NEW_LINE n = 6 NEW_LINE print ( ' { 0 : . 6 } ' . format ( polyapothem ( n , a ) ) ) NEW_LINE DEDENT"],"bleu":0.5333200575557495,"rouge_l":0.7212837837837838}
{"id":1050,"predictions":["def evenPowerSum ( n ) : NEW_LINE INDENT return ( ( 8 * n * ( n + 1 ) * ( 3 * n + 3 * n - 1 ) ) \/ 15 NEW_LINE DEDENT n = 4 NEW_LINE print ( evenPowerSum ( n ) ) NEW_LINE"],"references":["def evenPowerSum ( n ) : NEW_LINE INDENT return ( 8 * n * ( n + 1 ) * ( 2 * n + 1 ) * ( 3 * n * n + 3 * n - 1 ) ) \/ 15 ; NEW_LINE DEDENT n = 4 ; NEW_LINE print ( int ( evenPowerSum ( n ) ) ) ; NEW_LINE"],"bleu":0.6351214366612596,"rouge_l":0.8296967979597618}
{"id":1051,"predictions":["def printModulus ( X , Y ) : NEW_LINE INDENT n = max ( X , Y ) ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( X % i == Y ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT X , Y = 10 , 20 ; NEW_LINE printModulus ( X , Y ) ; NEW_LINE DEDENT"],"references":["def printModulus ( X , Y ) : NEW_LINE INDENT n = max ( X , Y ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( X % i == Y % i ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT X = 10 NEW_LINE Y = 20 NEW_LINE printModulus ( X , Y ) NEW_LINE"],"bleu":0.6652577907664914,"rouge_l":0.8582914572864323}
{"id":1052,"predictions":["from math import gcd NEW_LINE def minValidNumber ( p , q ) : NEW_LINE INDENT if ( q % p == 0 or q == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( a % p == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a % p == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return - 1 NEW_LINE DEDENT p = 2 NEW_LINE q = 6 NEW_LINE print ( minValidNumber ( p , q ) ) NEW_LINE"],"references":["from math import gcd NEW_LINE def minValidNumber ( p , q ) : NEW_LINE INDENT if ( q % p == 0 ) : NEW_LINE INDENT return gcd ( p , q ) NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT p , q = 2 , 6 ; NEW_LINE print ( minValidNumber ( p , q ) ) NEW_LINE DEDENT"],"bleu":0.5437667488754553,"rouge_l":0.6855308047361028}
{"id":1053,"predictions":["def maxSum ( arr , n , k ) : NEW_LINE INDENT if ( n < k ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT max_sum = 0 ; NEW_LINE for i in range ( k ) : NEW_LINE INDENT max_sum += arr [ i ] ; NEW_LINE DEDENT max_sum = max_sum ; NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT max_sum += arr [ i ] - arr [ i - k ] ; NEW_LINE max_sum = max ( max_sum , max_sum ) ; NEW_LINE DEDENT return max_sum ; NEW_LINE DEDENT arr = [ 1 , 4 , 2 , 10 , 2 , 3 , 1 , 0 , 20 ] ; NEW_LINE k = 4 ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( maxSum ( arr , n , k ) ) ; NEW_LINE"],"references":["import sys NEW_LINE INT_MIN = - sys . maxsize - 1 NEW_LINE def maxSum ( arr , n , k ) : NEW_LINE INDENT if not n > k : NEW_LINE INDENT print ( \" Invalid \" ) NEW_LINE return - 1 NEW_LINE DEDENT max_sum = INT_MIN NEW_LINE window_sum = sum ( arr [ : k ] ) NEW_LINE for i in range ( n - k ) : NEW_LINE INDENT window_sum = window_sum - arr [ i ] + arr [ i + k ] NEW_LINE max_sum = max ( window_sum , max_sum ) NEW_LINE DEDENT return max_sum NEW_LINE DEDENT arr = [ 1 , 4 , 2 , 10 , 2 , 3 , 1 , 0 , 20 ] NEW_LINE k = 4 NEW_LINE n = len ( arr ) NEW_LINE print ( maxSum ( arr , n , k ) ) NEW_LINE"],"bleu":0.5499700256145945,"rouge_l":0.7424073246985262}
{"id":1054,"predictions":["def sort ( a , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( ( a [ i ] + a [ j ] ) > 0 ) : NEW_LINE INDENT a [ i ] , a [ j ] = a [ j ] , a [ i ] NEW_LINE DEDENT DEDENT DEDENT def lexsmallest ( a , n ) : NEW_LINE INDENT answer = a [ 0 ] , a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT answer += a [ i ] NEW_LINE DEDENT return answer NEW_LINE DEDENT def lexsmallest ( a , n ) : NEW_LINE INDENT answer = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT answer . append ( a [ i ] + a [ i ] ) NEW_LINE DEDENT return answer NEW_LINE DEDENT a = [ c c cb for i in range ( n ) ] NEW_LINE print ( \" lesmallest ( a , n ) ) NEW_LINE"],"references":["def lexSmallest ( a , n ) : NEW_LINE INDENT a . sort ( reverse = True ) NEW_LINE answer = \" \" NEW_LINE for i in range ( n ) : NEW_LINE INDENT answer += a [ i ] NEW_LINE DEDENT return answer NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ \" c \" , \" cb \" , \" cba \" ] NEW_LINE n = len ( a ) NEW_LINE print ( lexSmallest ( a , n ) ) NEW_LINE DEDENT"],"bleu":0.23455519593383042,"rouge_l":0.4403523797871039}
{"id":1055,"predictions":["def printAnagrams ( arr , n ) : NEW_LINE INDENT map = dict ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT word = input ( ) NEW_LINE if word . isupper ( ) : NEW_LINE INDENT map [ word ] = word . lower ( ) NEW_LINE DEDENT else : NEW_LINE INDENT map [ word [ word [ word [ word [ word [ word [ word [ word ] ] ] ] ] = word . lower ( word ) ] + word [ word [ word [ word [ word [ word [ word [ word [ word ] ] ] ] ] NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ \" ind \" , \" word \" ] , [ \" word \" , \" word \" ] ] NEW_LINE n = len ( arr ) NEW_LINE printAnagrams ( arr , n ) NEW_LINE DEDENT"],"references":["from collections import defaultdict NEW_LINE def printAnagramsTogether ( words ) : NEW_LINE INDENT groupedWords = defaultdict ( list ) NEW_LINE for word in words : NEW_LINE INDENT groupedWords [ \" \" . join ( sorted ( word ) ) ] . append ( word ) NEW_LINE DEDENT for group in groupedWords . values ( ) : NEW_LINE INDENT print ( \" ▁ \" . join ( group ) ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ \" cat \" , \" dog \" , \" tac \" , \" god \" , \" act \" ] NEW_LINE printAnagramsTogether ( arr ) NEW_LINE DEDENT"],"bleu":0.24258372939901587,"rouge_l":0.49152134696331923}
{"id":1056,"predictions":["def commonPrefixUtil ( str1 , str2 ) : NEW_LINE INDENT result = \" \" NEW_LINE n1 = len ( str1 ) NEW_LINE n2 = len ( str2 ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while i <= n1 - 1 and j <= n1 - 1 : NEW_LINE INDENT if ( str1 [ i ] != str2 [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT result += str1 [ i ] NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT return ( result ) NEW_LINE DEDENT def commonPrefix ( arr , n ) : NEW_LINE INDENT arr = [ \" geeksforgeeks \" ] NEW_LINE return commonPrefixUtil ( arr , arr [ n - 1 ] ) NEW_LINE DEDENT arr = [ \" geeksforgeeks \" , \" geeks \" ] NEW_LINE n = len ( arr ) NEW_LINE commonPrefix ( arr , n ) NEW_LINE print ( commonPrefix ( arr , n - 1 ) ) NEW_LINE"],"references":["def commonPrefixUtil ( str1 , str2 ) : NEW_LINE INDENT n1 = len ( str1 ) NEW_LINE n2 = len ( str2 ) NEW_LINE result = \" \" NEW_LINE j = 0 NEW_LINE i = 0 NEW_LINE while ( i <= n1 - 1 and j <= n2 - 1 ) : NEW_LINE INDENT if ( str1 [ i ] != str2 [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT result += ( str1 [ i ] ) NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT return ( result ) NEW_LINE DEDENT def commonPrefix ( arr , n ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE print ( commonPrefixUtil ( arr [ 0 ] , arr [ n - 1 ] ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ \" geeksforgeeks \" , \" geeks \" , \" geek \" , \" geezer \" ] NEW_LINE n = len ( arr ) NEW_LINE commonPrefix ( arr , n ) NEW_LINE DEDENT"],"bleu":0.703011666402868,"rouge_l":0.7824938690813055}
{"id":1057,"predictions":["def changeTheArray ( arr , n ) : NEW_LINE INDENT minEle = min ( arr ) NEW_LINE maxEle = max ( arr ) NEW_LINE minEle = max ( arr ) NEW_LINE for num in arr : NEW_LINE INDENT if ( arr [ num ] != num ) : NEW_LINE INDENT operations += ( abs ( num - arr [ num ] ) - 1 ) NEW_LINE DEDENT DEDENT return minEle NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 10 , 1 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( changeTheArray ( arr , n ) ) NEW_LINE DEDENT"],"references":["import math NEW_LINE import sys NEW_LINE def changeTheArray ( arr , n ) : NEW_LINE INDENT minEle = min ( arr ) NEW_LINE maxEle = max ( arr ) NEW_LINE minOperations = sys . maxsize NEW_LINE for num in range ( minEle , maxEle + 1 ) : NEW_LINE INDENT operations = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] != num : NEW_LINE INDENT operations += ( abs ( num - arr [ i ] ) - 1 ) NEW_LINE DEDENT DEDENT minOperations = min ( minOperations , operations ) NEW_LINE DEDENT return minOperations NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 10 , 1 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( changeTheArray ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.6027696578474218,"rouge_l":0.7740544536158678}
{"id":1058,"predictions":["def findElements ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count >= 2 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 2 , - 6 , 3 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE findElements ( arr , n ) NEW_LINE"],"references":["def findElements ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if arr [ j ] > arr [ i ] : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT if count >= 2 : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 2 , - 6 , 3 , 5 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE findElements ( arr , n ) NEW_LINE"],"bleu":0.8219795378954415,"rouge_l":0.9342342342342344}
{"id":1059,"predictions":["def cntSubArrays ( arr , n , k ) : NEW_LINE INDENT res = 0 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT j = i + 1 NEW_LINE while ( j < n and arr [ j ] >= arr [ j - 1 ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT res += max ( j - k + 1 , 0 ) NEW_LINE i = j NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 2 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE print ( cntSubArrays ( arr , n , k ) ) NEW_LINE DEDENT"],"references":["def cntSubArrays ( arr , n , k ) : NEW_LINE INDENT res = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT j = i + 1 ; NEW_LINE while ( j < n and arr [ j ] >= arr [ j - 1 ] ) : NEW_LINE INDENT j += 1 ; NEW_LINE DEDENT res += max ( j - i - k + 1 , 0 ) ; NEW_LINE i = j ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 2 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE k = 2 ; NEW_LINE print ( cntSubArrays ( arr , n , k ) ) ; NEW_LINE DEDENT"],"bleu":0.7863489816312984,"rouge_l":0.9458458690118028}
{"id":1060,"predictions":["def match_ways ( vowel , suffix , n , m ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if word [ i ] in mp . keys ( ) : NEW_LINE INDENT mp [ letter [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ letter [ i ] ] = 1 NEW_LINE DEDENT DEDENT for i in mp : NEW_LINE INDENT if ( i in mp . keys ( ) ) : NEW_LINE INDENT mp [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ i ] = 0 NEW_LINE DEDENT DEDENT DEDENT def find_ways ( vowel , n , m ) : NEW_LINE INDENT if ( m [ 0 ] in mp . keys ( ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT command = \" geeks \" NEW_LINE n = len ( command ) NEW_LINE m = len ( command ) NEW_LINE if ( find_ways ( vowel , n , m ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"references":["def match_words ( dictionary , sentence , n , m ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ dictionary [ i ] ] = mp . get ( dictionary [ i ] , 0 ) + 1 NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT if ( mp [ sentence [ i ] ] ) : NEW_LINE INDENT mp [ sentence [ i ] ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT dictionary = [ \" find \" , \" a \" , \" geeks \" , \" all \" , \" for \" , \" on \" , \" geeks \" , \" answers \" , \" inter \" ] NEW_LINE n = len ( dictionary ) NEW_LINE sentence = [ \" find \" , \" all \" , \" answers \" , \" on \" , \" geeks \" , \" for \" , \" geeks \" ] NEW_LINE m = len ( sentence ) NEW_LINE if ( match_words ( dictionary , sentence , n , m ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"],"bleu":0.4690250400717335,"rouge_l":0.5623765274017707}
{"id":1061,"predictions":["def sumofproduct ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for x in range ( 1 , n + 1 ) : NEW_LINE INDENT y = n \/\/ x NEW_LINE ans += ( y * x ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE print ( sumofproduct ( n ) ) NEW_LINE DEDENT"],"references":["def sumofproduct ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for x in range ( 1 , n + 1 ) : NEW_LINE INDENT y = int ( n \/ x ) NEW_LINE ans += ( y * x ) NEW_LINE DEDENT return ans NEW_LINE DEDENT n = 10 NEW_LINE print ( sumofproduct ( n ) ) NEW_LINE"],"bleu":0.7212295858397612,"rouge_l":0.8681067344345614}
{"id":1062,"predictions":["def isUnique ( a , n , k ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += a [ i ] ; NEW_LINE sum -= a [ i ] ; NEW_LINE DEDENT return ( sum == k ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 3 , 3 ] ; NEW_LINE n = len ( a ) ; NEW_LINE k = 12 ; NEW_LINE if ( isUnique ( a , n , k ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"],"references":["def isUnique ( a , n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT sum += n - 1 NEW_LINE return ( sum == k ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 3 , 3 , 3 ] NEW_LINE n = len ( a ) NEW_LINE k = 12 NEW_LINE if ( isUnique ( a , n , k ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.7003446629487453,"rouge_l":0.8806309316936237}
{"id":1063,"predictions":["def first ( second ) : NEW_LINE INDENT first = 1 NEW_LINE second = 1 NEW_LINE for second in range ( 1 , 5 ) : NEW_LINE INDENT second = second + first NEW_LINE second = second + second NEW_LINE second = second + second NEW_LINE DEDENT if ( first <= 5 ) : NEW_LINE INDENT print ( \" , 5 , \" , \" , second , \" ) NEW_LINE DEDENT DEDENT main ( ) NEW_LINE"],"references":["if name == ' _ _ main _ _ ' : NEW_LINE INDENT for first in range ( 1 , 6 ) : NEW_LINE INDENT for second in range ( 1 , 6 ) : NEW_LINE INDENT print ( 5 * first + second - 5 ) NEW_LINE DEDENT DEDENT DEDENT"],"bleu":0.24437899255212012,"rouge_l":0.43791544801914384}
{"id":1064,"predictions":["def calculate_cost ( s ) : NEW_LINE INDENT if ( len ( s ) == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT count_count = 0 NEW_LINE s1 = \" \" NEW_LINE s2 = \" \" NEW_LINE for i in range ( len ( s1 ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( s1 [ i ] == '0' ) : NEW_LINE INDENT count_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_count += 1 NEW_LINE s1 [ i ] = '1' NEW_LINE DEDENT DEDENT if ( i == 0 ) : NEW_LINE INDENT count_count += 1 NEW_LINE DEDENT DEDENT return count_count NEW_LINE DEDENT s = \"100000\" NEW_LINE print ( calculate_cost ( s ) ) NEW_LINE"],"references":["def calculate_ ( s ) : NEW_LINE INDENT if len ( s ) == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT count_ = 0 NEW_LINE i = len ( s ) - 1 NEW_LINE while i > 0 : NEW_LINE INDENT if s [ i ] == '0' : NEW_LINE INDENT count_ += 1 NEW_LINE i -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_ += 1 NEW_LINE while s [ i ] == '1' and i > 0 : NEW_LINE INDENT count_ += 1 NEW_LINE i -= 1 NEW_LINE DEDENT if i == 0 : NEW_LINE INDENT count_ += 1 NEW_LINE DEDENT s = s [ : i ] + \"1\" + s [ i + 1 : ] NEW_LINE DEDENT DEDENT return count_ NEW_LINE DEDENT s = \"10000100000\" NEW_LINE print ( calculate_ ( s ) ) NEW_LINE"],"bleu":0.34482758698321436,"rouge_l":0.621990171990172}
{"id":1065,"predictions":["def getWinner ( string , len ( string ) ) : NEW_LINE INDENT total = 0 NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if ( string [ i ] == ' S ' ) : NEW_LINE INDENT total += 1 NEW_LINE DEDENT DEDENT if ( total % 2 == 1 ) : NEW_LINE INDENT return \" Second \" NEW_LINE DEDENT return \" First \" NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" GeeksS \" NEW_LINE len = len ( string ) NEW_LINE print ( getWinner ( string , len ( string ) ) ) NEW_LINE DEDENT"],"references":["def getWinner ( string , length ) : NEW_LINE INDENT total = 0 ; NEW_LINE for i in range ( length ) : NEW_LINE INDENT if ( string [ i ] == ' S ' ) : NEW_LINE INDENT total += 1 ; NEW_LINE DEDENT DEDENT if ( ( total % 2 ) == 1 ) : NEW_LINE INDENT return \" First \" ; NEW_LINE DEDENT return \" Second \" ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" GSSS \" ; NEW_LINE length = len ( string ) ; NEW_LINE print ( getWinner ( string , length ) ) ; NEW_LINE DEDENT"],"bleu":0.6998615097675456,"rouge_l":0.8584070796460177}
{"id":1066,"predictions":["def countPermutations ( N , B ) : NEW_LINE INDENT x = pow ( B , N - 1 ) NEW_LINE y = pow ( B , N ) NEW_LINE print ( x - y ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N , B = 6 , 4 NEW_LINE print ( countPermutations ( N , B ) ) NEW_LINE DEDENT"],"references":["def countPermutations ( N , B ) : NEW_LINE INDENT x = B ** N NEW_LINE y = B ** ( N - 1 ) NEW_LINE print ( x - y ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N , B = 6 , 4 NEW_LINE countPermutations ( N , B ) NEW_LINE DEDENT"],"bleu":0.7416242090875496,"rouge_l":0.8805375808860129}
{"id":1067,"predictions":["def check ( k , d ) : NEW_LINE INDENT s = ( 2 * ( d + d ) % 10 ) % 10 NEW_LINE d = 0 NEW_LINE while ( ( d + d ) % 10 ) : NEW_LINE INDENT x = ( 2 * ( d + d ) % 10 + ( d ) % 10 ) NEW_LINE DEDENT a = ( k - 3 ) % 4 NEW_LINE if ( a == 0 ) : NEW_LINE INDENT x = 0 NEW_LINE DEDENT elif ( ( d == 2 * d ) % 4 ) : NEW_LINE INDENT x = 0 NEW_LINE DEDENT else : NEW_LINE INDENT x = ( ( 2 * ( d + d ) ) % 10 + ( 4 * ( d + d ) ) % 10 ) NEW_LINE DEDENT elif ( ( sum % 3 == 0 ) : NEW_LINE INDENT x = 0 NEW_LINE DEDENT else : NEW_LINE INDENT x = ( 2 * ( d + d ) ) % 10 NEW_LINE DEDENT if ( sum % 3 == 0 ) : NEW_LINE INDENT return \" NO \" NEW_LINE DEDENT else : NEW_LINE INDENT return ( \" YES \" ) NEW_LINE DEDENT DEDENT DEDENT def check ( k , d0 , d1 , d1 ) : NEW_LINE INDENT if ( check ( k , d0 ) ) : NEW_LINE INDENT return \" YES \" NEW_LINE DEDENT else : NEW_LINE INDENT return \" NO \" NEW_LINE DEDENT d1 = d1 + d1 NEW_LINE d2 = 4 NEW_LINE if ( check ( k , d1 , d1 , d2 ) ) : NEW_LINE INDENT return \" YES \" NEW_LINE DEDENT else : NEW_LINE INDENT return \" NO \" NEW_LINE DEDENT DEDENT k0 , d1 = 13 , 1 NEW_LINE d1 = 3 NEW_LINE d1 = 5 NEW_LINE d2 = 8 NEW_LINE d1 = 4 NEW_LINE d1 = 4 NEW_LINE d2 = 5 NEW_LINE d2 = 3 NEW_LINE print ( check ( k , d1 , d2 , d1 , d1 ) ) NEW_LINE"],"references":["def check ( k , d0 , d1 ) : NEW_LINE INDENT s = ( ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 + ( 6 * ( d0 + d1 ) ) % 10 ) NEW_LINE a = ( k - 3 ) % 4 NEW_LINE if ( a == 0 ) : NEW_LINE INDENT x = 0 NEW_LINE DEDENT elif ( a == 1 ) : NEW_LINE INDENT x = ( 2 * ( d0 + d1 ) ) % 10 NEW_LINE DEDENT elif ( a == 2 ) : NEW_LINE INDENT x = ( ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 ) NEW_LINE DEDENT elif ( a == 3 ) : NEW_LINE INDENT x = ( ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 ) NEW_LINE DEDENT sum = d0 + d1 + ( ( k - 3 ) \/\/ 4 ) * s + x NEW_LINE if ( sum % 3 == 0 ) : NEW_LINE INDENT return \" YES \" NEW_LINE DEDENT else : NEW_LINE INDENT return \" NO \" NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT k = 13 NEW_LINE d0 = 8 NEW_LINE d1 = 1 NEW_LINE print ( check ( k , d0 , d1 ) ) NEW_LINE k = 5 NEW_LINE d0 = 3 NEW_LINE d1 = 4 NEW_LINE print ( check ( k , d0 , d1 ) ) NEW_LINE DEDENT"],"bleu":0.4787545903722432,"rouge_l":0.5827141774071265}
{"id":1068,"predictions":["if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE j = 1 NEW_LINE num = n - 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT num = j NEW_LINE for j in range ( 1 , n + 1 ) : NEW_LINE INDENT num = j NEW_LINE print ( num , end = \" ▁ \" ) NEW_LINE DEDENT num = num - 1 NEW_LINE for i in range ( 1 , j + 1 ) : NEW_LINE INDENT print ( num , end = \" ▁ \" ) NEW_LINE num -= 1 NEW_LINE DEDENT num -= 1 NEW_LINE for i in range ( 1 , j ) : NEW_LINE INDENT print ( num , end = \" ▁ \" ) NEW_LINE DEDENT num -= 1 NEW_LINE print ( ) NEW_LINE DEDENT DEDENT"],"references":["n = 5 NEW_LINE num = 1 NEW_LINE gap = n - 1 NEW_LINE for j in range ( 1 , n + 1 ) : NEW_LINE INDENT num = j NEW_LINE for i in range ( 1 , gap + 1 ) : NEW_LINE INDENT print ( \" ▁ \" , end = \" \" ) NEW_LINE DEDENT gap = gap - 1 NEW_LINE for i in range ( 1 , j + 1 ) : NEW_LINE INDENT print ( num , end = \" \" ) NEW_LINE num = num + 1 NEW_LINE DEDENT num = num - 2 NEW_LINE for i in range ( 1 , j ) : NEW_LINE INDENT print ( num , end = \" \" ) NEW_LINE num = num - 1 NEW_LINE DEDENT print ( ) NEW_LINE DEDENT"],"bleu":0.6784734222500192,"rouge_l":0.813710706414569}
{"id":1069,"predictions":["def isKthBitSet ( x , k ) : NEW_LINE INDENT rslt = ( x & ( 1 << ( k - 1 ) ) ) NEW_LINE return rslt NEW_LINE DEDENT def isPalindrome ( x ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT def isPalindrome ( x ) : NEW_LINE INDENT l = 1 << 32 NEW_LINE r = x NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( isKthBitSet ( x , l ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = 1 NEW_LINE r = 10 NEW_LINE print ( isPalindrome ( x ) ) NEW_LINE x = 1 << 32 NEW_LINE print ( isPalindrome ( x ) ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE def isKthBitSet ( x , k ) : NEW_LINE INDENT if ( ( x & ( 1 << ( k - 1 ) ) ) != 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def isPalindrome ( x ) : NEW_LINE INDENT l = 1 NEW_LINE r = 2 * 8 NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( isKthBitSet ( x , l ) != isKthBitSet ( x , r ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 1 << 15 + 1 << 16 NEW_LINE print ( int ( isPalindrome ( x ) ) ) NEW_LINE x = 1 << 31 + 1 NEW_LINE print ( int ( isPalindrome ( x ) ) ) NEW_LINE DEDENT"],"bleu":0.6144676609167622,"rouge_l":0.780727734292363}
{"id":1070,"predictions":["def getSum ( a , n ) : NEW_LINE INDENT P = [ ] NEW_LINE P . append ( a [ 0 ] ) NEW_LINE S = set ( ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT P . append ( a [ i ] + P [ i - 1 ] ) NEW_LINE DEDENT S = set ( ) NEW_LINE for i in range ( 1 , S + 1 ) : NEW_LINE INDENT if ( S % i == 0 ) : NEW_LINE INDENT S . add ( S [ i ] ) NEW_LINE DEDENT DEDENT if ( len ( P ) == 0 ) : NEW_LINE INDENT for i in range ( 1 , S + 1 ) : NEW_LINE INDENT P . append ( a [ i ] ) NEW_LINE DEDENT DEDENT res = 0 NEW_LINE for i in range ( 1 , S + 1 ) : NEW_LINE INDENT if ( S % i == 0 ) : NEW_LINE INDENT res = 1 NEW_LINE break NEW_LINE DEDENT if ( res == 0 ) : NEW_LINE INDENT res = 1 NEW_LINE break NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 2 , 1 , 1 , 2 , 1 , 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE getSum ( a , n ) NEW_LINE if ( res and divmod ( a , n ) ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a [ 0 ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT"],"references":["from math import sqrt NEW_LINE def getSum ( a , n ) : NEW_LINE INDENT P = [ 0 ] * n NEW_LINE P [ 0 ] = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT P [ i ] = a [ i ] + P [ i - 1 ] NEW_LINE DEDENT S = P [ n - 1 ] NEW_LINE hash = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ P [ i ] ] = 1 NEW_LINE DEDENT res = set ( ) NEW_LINE for i in range ( 1 , int ( sqrt ( S ) ) + 1 ) : NEW_LINE INDENT if ( S % i == 0 ) : NEW_LINE INDENT pres = True ; NEW_LINE div1 = i NEW_LINE div2 = S \/\/ i NEW_LINE for j in range ( div1 , S + 1 , div1 ) : NEW_LINE INDENT if j not in hash . keys ( ) : NEW_LINE INDENT pres = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( pres and div1 != S ) : NEW_LINE INDENT res . add ( div1 ) NEW_LINE DEDENT pres = True NEW_LINE for j in range ( S \/\/ i , S + 1 , S \/\/ i ) : NEW_LINE INDENT if j not in hash . keys ( ) : NEW_LINE INDENT pres = False ; NEW_LINE break NEW_LINE DEDENT DEDENT if ( pres and div2 != S ) : NEW_LINE INDENT res . add ( div2 ) NEW_LINE DEDENT DEDENT DEDENT if ( len ( res ) == 0 ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE return NEW_LINE DEDENT for i in res : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 2 , 1 , 1 , 1 , 2 , 1 , 3 ] NEW_LINE n = len ( a ) NEW_LINE getSum ( a , n ) NEW_LINE DEDENT"],"bleu":0.5226751643358445,"rouge_l":0.5617944147355911}
{"id":1071,"predictions":["MAX_CHAR = 26 NEW_LINE def removeChars ( arr , k ) : NEW_LINE INDENT hash = [ 0 ] * MAX_CHAR NEW_LINE n = len ( arr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ arr [ ord ( arr [ i ] [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT ans = \" \" NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( hash [ arr [ i ] ] != k ) : NEW_LINE INDENT ans += arr [ i ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeksforgeeks \" NEW_LINE k = 2 NEW_LINE print ( removeChars ( str , k ) ) NEW_LINE DEDENT"],"references":["MAX_CHAR = 26 NEW_LINE def removeChars ( arr , k ) : NEW_LINE INDENT hash = [ 0 ] * MAX_CHAR NEW_LINE n = len ( arr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ ord ( arr [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT ans = \" \" NEW_LINE index = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( hash [ ord ( arr [ i ] ) - ord ( ' a ' ) ] != k ) : NEW_LINE INDENT ans += arr [ i ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeksforgeeks \" NEW_LINE k = 2 NEW_LINE print ( removeChars ( str , k ) ) NEW_LINE DEDENT"],"bleu":0.8749796771015412,"rouge_l":0.930002225684398}
{"id":1072,"predictions":["def firstEven ( arr , n ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == i ) : NEW_LINE INDENT mp [ arr [ i ] ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT DEDENT j = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( mp [ arr [ i ] ] ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT j += 1 NEW_LINE DEDENT return arr NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 4 , 6 , 8 , 1 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( firstEven ( arr , n ) ) NEW_LINE DEDENT"],"references":["def firstEven ( arr , n ) : NEW_LINE INDENT map1 = { } NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] not in map1 : NEW_LINE INDENT map1 [ arr [ i ] ] = False NEW_LINE DEDENT else : NEW_LINE INDENT map1 [ arr [ i ] ] = not map1 [ arr [ i ] ] NEW_LINE DEDENT DEDENT for j in range ( 0 , n ) : NEW_LINE INDENT if map1 [ arr [ j ] ] == True : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return arr [ j ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 4 , 6 , 8 , 1 , 6 ] NEW_LINE print ( firstEven ( arr , 6 ) ) NEW_LINE DEDENT"],"bleu":0.6017458713944795,"rouge_l":0.7818799298860648}
{"id":1073,"predictions":["def ReverseString ( s ) : NEW_LINE INDENT s = s [ : : - 1 ] NEW_LINE n = len ( s ) NEW_LINE for i in range ( 0 , n \/\/ 2 ) : NEW_LINE INDENT temp = s [ : i ] NEW_LINE arr [ len ( s [ i ] ) ] = arr [ len ( s [ i ] ) - i - 1 ] NEW_LINE DEDENT return temp NEW_LINE DEDENT def binaryString ( m ) : NEW_LINE INDENT while ( m ) : NEW_LINE INDENT temp = m % 2 NEW_LINE m = int ( m \/ 2 ) NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == \"1\" ) : NEW_LINE INDENT temp = temp + \"0\" NEW_LINE DEDENT else : NEW_LINE INDENT m = int ( m \/ 2 ) NEW_LINE DEDENT DEDENT s [ i ] = \" . \" NEW_LINE m = int ( m \/ 2 ) NEW_LINE for x in range ( 0 , len ( s ) ) : NEW_LINE INDENT if ( s [ x ] == \"0\" ) : NEW_LINE INDENT s = s [ : : - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT s = s [ : : - 1 ] NEW_LINE DEDENT s = s [ : : - 1 ] NEW_LINE m = len ( s ) NEW_LINE DEDENT s = s [ : : - 1 ] NEW_LINE return s NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT m = 5 NEW_LINE n = 2 NEW_LINE i = 2 NEW_LINE print ( findString ( m , i ) ) NEW_LINE DEDENT"],"references":["def binary_conversion ( s , m ) : NEW_LINE INDENT while ( m ) : NEW_LINE INDENT temp = m % 2 NEW_LINE s += str ( temp ) NEW_LINE m = m \/\/ 2 NEW_LINE DEDENT return s [ : : - 1 ] NEW_LINE DEDENT def find_character ( n , m , i ) : NEW_LINE INDENT s = \" \" NEW_LINE s = binary_conversion ( s , m ) NEW_LINE s1 = \" \" NEW_LINE for x in range ( n ) : NEW_LINE INDENT for j in range ( len ( s ) ) : NEW_LINE INDENT if s [ j ] == \"1\" : NEW_LINE INDENT s1 += \"10\" NEW_LINE DEDENT else : NEW_LINE INDENT s1 += \"01\" NEW_LINE DEDENT DEDENT s = s1 NEW_LINE s1 = \" \" NEW_LINE DEDENT e = ord ( s [ i ] ) NEW_LINE r = ord ( '0' ) NEW_LINE return e - r NEW_LINE DEDENT m , n , i = 5 , 2 , 8 NEW_LINE print ( find_character ( n , m , i ) ) NEW_LINE"],"bleu":0.2719025138289653,"rouge_l":0.46661424077780955}
{"id":1074,"predictions":["def cntSquares ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) * ( 2 * n + 1 ) ) \/ 6 NEW_LINE DEDENT print ( cntSquares ( 4 ) ) NEW_LINE"],"references":["def cntSquares ( n ) : NEW_LINE INDENT return int ( n * ( n + 1 ) * ( 2 * n + 1 ) \/ 6 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( cntSquares ( 4 ) ) ; NEW_LINE DEDENT"],"bleu":0.5379962613539098,"rouge_l":0.7798894263994472}
{"id":1075,"predictions":["def multiplyWith3Point ( x ) : NEW_LINE INDENT return ( x << 1 ) + ( x >> 1 ) NEW_LINE DEDENT x = 2 NEW_LINE print ( multiplyWith3Point ( x ) ) NEW_LINE"],"references":["def multiplyWith3Point5 ( x ) : NEW_LINE INDENT return ( x << 1 ) + x + ( x >> 1 ) NEW_LINE DEDENT x = 4 NEW_LINE print ( multiplyWith3Point5 ( x ) ) NEW_LINE"],"bleu":0.7211703411642935,"rouge_l":0.8811742777260019}
{"id":1076,"predictions":["def countSubSeq ( string , len ) : NEW_LINE INDENT ans = 0 NEW_LINE mul = 1 NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if ( string [ i ] == '0' ) : NEW_LINE INDENT ans += mul NEW_LINE DEDENT mul *= 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \"10010\" NEW_LINE len ( string ) NEW_LINE len = len ( string ) NEW_LINE print ( countSubSeq ( string , len ) ) NEW_LINE DEDENT"],"references":["def countSubSeq ( strr , lenn ) : NEW_LINE INDENT ans = 0 NEW_LINE mul = 1 NEW_LINE for i in range ( lenn ) : NEW_LINE INDENT if ( strr [ i ] == '0' ) : NEW_LINE INDENT ans += mul NEW_LINE DEDENT mul *= 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT strr = \"10010\" NEW_LINE lenn = len ( strr ) NEW_LINE print ( countSubSeq ( strr , lenn ) ) NEW_LINE"],"bleu":0.5454239907757369,"rouge_l":0.785560975609756}
{"id":1077,"predictions":["def swapThree ( a , b , c ) : NEW_LINE INDENT a = a + b + c NEW_LINE b = a - ( b + c ) NEW_LINE c = a - ( b + c ) NEW_LINE a = a - ( b + c ) NEW_LINE b = a - ( b + c ) NEW_LINE c = a - ( c + a ) NEW_LINE a = a - ( b + c ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a , b , c = 20 , 30 , 31 ) NEW_LINE swapThree ( a , b , c ) NEW_LINE DEDENT"],"references":["def swapThree ( a , b , c ) : NEW_LINE INDENT a = a + b + c NEW_LINE b = a - ( b + c ) NEW_LINE c = a - ( b + c ) NEW_LINE a = a - ( b + c ) NEW_LINE print ( \" After ▁ swapping ▁ a ▁ = \" , a , \" , ▁ b ▁ = \" , b , \" , ▁ c ▁ = \" , c ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 10 NEW_LINE b = 20 NEW_LINE c = 30 NEW_LINE print ( \" Before ▁ swapping ▁ a ▁ = \" , a , \" , ▁ b ▁ = \" , b , \" , ▁ c ▁ = \" , c ) NEW_LINE swapThree ( a , b , c ) NEW_LINE DEDENT"],"bleu":0.4965987618568462,"rouge_l":0.642781875658588}
{"id":1078,"predictions":["def countSubarrays ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE pre = [ 0 for i in range ( n + 1 ) ] NEW_LINE pre [ 0 ] = pre [ 1 ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT pre [ i ] = pre [ i - 1 ] + a [ i - 1 ] NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if ( pre [ j ] == 0 ) : NEW_LINE INDENT pre [ j ] = pre [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT pre [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT sum1 = pre [ j ] - pre [ i - 1 ] NEW_LINE if ( pre [ j ] == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count > dist [ count ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 6 , 3 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countSubarrays ( arr , n ) ) NEW_LINE DEDENT"],"references":["def countSubarrays ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE pre = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT pre [ i ] = pre [ i - 1 ] + a [ i - 1 ] NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT sum1 = pre [ j ] - pre [ i - 1 ] NEW_LINE count1 = j - i + 1 NEW_LINE sum2 = pre [ n ] - sum1 NEW_LINE if n - count1 == 0 : NEW_LINE INDENT count2 = 1 NEW_LINE DEDENT else : NEW_LINE INDENT count2 = n - count1 NEW_LINE DEDENT includ = sum1 \/\/ count1 NEW_LINE exclud = sum2 \/\/ count2 NEW_LINE if ( includ > exclud ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 6 , 3 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countSubarrays ( arr , n ) ) NEW_LINE"],"bleu":0.6123350657356038,"rouge_l":0.7201785328630048}
{"id":1079,"predictions":["def reverse ( arr , n , k , m ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT left = i ; NEW_LINE right = min ( i + k - 1 , n - 1 ) ; NEW_LINE while ( left < right ) : NEW_LINE INDENT if ( arr [ left ] == arr [ right ] ) : NEW_LINE INDENT arr [ left ] , arr [ right ] = arr [ left ] , arr [ right ] ; NEW_LINE left += 1 ; NEW_LINE right -= 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT arr [ right ] = arr [ right ] , arr [ left ] , arr [ right ] ; NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 13 , 9 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE k = 2 ; NEW_LINE reverse ( arr , n , k , m ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT"],"references":["def reverse ( arr , n , k , m ) : NEW_LINE INDENT for i in range ( 0 , n , k + m ) : NEW_LINE INDENT left = i ; NEW_LINE right = min ( i + k - 1 , n - 1 ) ; NEW_LINE while ( left < right ) : NEW_LINE INDENT arr = swap ( arr , left , right ) ; NEW_LINE left += 1 ; NEW_LINE right -= 1 ; NEW_LINE DEDENT DEDENT return arr ; NEW_LINE DEDENT def swap ( arr , i , j ) : NEW_LINE INDENT temp = arr [ i ] ; NEW_LINE arr [ i ] = arr [ j ] ; NEW_LINE arr [ j ] = temp ; NEW_LINE return arr ; NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 ] ; NEW_LINE k = 3 ; NEW_LINE m = 2 ; NEW_LINE n = len ( arr ) ; NEW_LINE arr = reverse ( arr , n , k , m ) ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT"],"bleu":0.6482933780318562,"rouge_l":0.7220517316966243}
{"id":1080,"predictions":["def count ( n ) : NEW_LINE INDENT return pow ( 2 , n - 1 ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 ; NEW_LINE print ( count ( n ) ) ; NEW_LINE DEDENT"],"references":["def count ( n ) : NEW_LINE INDENT return pow ( 2 , n - 1 ) NEW_LINE DEDENT n = 4 NEW_LINE print ( count ( n ) ) NEW_LINE"],"bleu":0.5287430133493595,"rouge_l":0.8164939550949913}
{"id":1081,"predictions":["def isSubsetSum ( set , n , sum ) : NEW_LINE INDENT subset = [ False ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT subset [ 0 ] = True NEW_LINE DEDENT for i in range ( 1 , sum + 1 ) : NEW_LINE INDENT subset [ i ] = True NEW_LINE DEDENT for i in range ( 1 , sum + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT subset [ i ] = subset [ j - 1 ] NEW_LINE if ( i >= subset [ j ] ) : NEW_LINE INDENT subset [ i ] = subset [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT subset [ sum ] = subset [ sum ] NEW_LINE return subset [ sum ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT set = [ 3 , 4 , 12 , 12 , 2 , 5 ] NEW_LINE sum = 9 NEW_LINE n = len ( set ) NEW_LINE if ( isSubsetSum ( set , n , sum ) ) : NEW_LINE INDENT print ( \" Found ▁ a ▁ subset ▁ with ▁ given ▁ sum \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No ▁ subset ▁ with ▁ a ▁ subset ▁ with ▁ given ▁ sum \" ) NEW_LINE DEDENT DEDENT"],"references":["def isSubsetSum ( set , n , sum ) : NEW_LINE INDENT subset = ( [ [ False for i in range ( sum + 1 ) ] for i in range ( n + 1 ) ] ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT subset [ i ] [ 0 ] = True NEW_LINE DEDENT for i in range ( 1 , sum + 1 ) : NEW_LINE INDENT subset [ 0 ] [ i ] = False NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , sum + 1 ) : NEW_LINE INDENT if j < set [ i - 1 ] : NEW_LINE INDENT subset [ i ] [ j ] = subset [ i - 1 ] [ j ] NEW_LINE DEDENT if j >= set [ i - 1 ] : NEW_LINE INDENT subset [ i ] [ j ] = ( subset [ i - 1 ] [ j ] or subset [ i - 1 ] [ j - set [ i - 1 ] ] ) NEW_LINE DEDENT DEDENT DEDENT return subset [ n ] [ sum ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT set = [ 3 , 34 , 4 , 12 , 5 , 2 ] NEW_LINE sum = 9 NEW_LINE n = len ( set ) NEW_LINE if ( isSubsetSum ( set , n , sum ) == True ) : NEW_LINE INDENT print ( \" Found ▁ a ▁ subset ▁ with ▁ given ▁ sum \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No ▁ subset ▁ with ▁ given ▁ sum \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.6266438396391351,"rouge_l":0.7758290260758465}
{"id":1082,"predictions":["def colourV ( height , colour , K ) : NEW_LINE INDENT arr = [ K + 1 for i in range ( K + 1 ) ] NEW_LINE V = 0 NEW_LINE max = 0 NEW_LINE for i in range ( K - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( height [ i ] > max ) : NEW_LINE INDENT max = height [ i ] NEW_LINE arr [ i ] = 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , K + 1 ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT max = height [ i ] NEW_LINE DEDENT DEDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT DEDENT for i in range ( 1 , K + 1 ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT return False NEW_LINE DEDENT height = [ 3 , 5 , 1 , 2 , 3 ] NEW_LINE K = len ( height ) NEW_LINE print ( colourV ( height , K ) ) NEW_LINE"],"references":["def colourVisible ( height , colour , K ) : NEW_LINE INDENT arr = [ 0 for i in range ( K + 1 ) ] NEW_LINE visible = 0 NEW_LINE max = height [ K - 1 ] NEW_LINE arr [ colour [ K - 1 ] ] = 1 NEW_LINE i = K - 2 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( height [ i ] > max ) : NEW_LINE INDENT max = height [ i ] NEW_LINE arr [ colour [ i ] ] = 1 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT for i in range ( 1 , K + 1 , 1 ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT visible += 1 NEW_LINE DEDENT DEDENT return visible NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT height = [ 3 , 5 , 1 , 2 , 3 ] NEW_LINE colour = [ 1 , 2 , 3 , 4 , 3 ] NEW_LINE K = len ( colour ) NEW_LINE print ( colourVisible ( height , colour , K ) ) NEW_LINE DEDENT"],"bleu":0.5828892095719913,"rouge_l":0.6590041426366663}
{"id":1083,"predictions":["def sortRpsArray ( mat , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] , arr [ i ] = arr [ i ] , arr [ i ] NEW_LINE DEDENT DEDENT def findAndPrintCommonElementsElements ( mat , n ) : NEW_LINE INDENT global arr NEW_LINE arr = [ [ ] for i in range ( n ) ] NEW_LINE curr_index = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( curr_index < n and mat [ i ] [ curr_index ] <= value [ curr_index ] ) : NEW_LINE INDENT value = arr [ i ] [ curr_index ] NEW_LINE if ( arr [ i ] [ curr_index ] != value ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( arr [ i ] [ curr_index ] != value ) : NEW_LINE INDENT arr [ i ] [ curr_index ] = 1 NEW_LINE break NEW_LINE DEDENT if ( arr [ i ] [ curr_index ] != value ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT mat = [ 12 , 1 , 14 ] NEW_LINE n = len ( mat ) NEW_LINE print ( findAndPrintCommonElements ( mat , n ) ) NEW_LINE DEDENT"],"references":["MAX = 100 NEW_LINE def sortRows ( mat , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT mat [ i ] . sort ( ) ; NEW_LINE DEDENT DEDENT def findAndPrintCommonElements ( mat , n ) : NEW_LINE INDENT sortRows ( mat , n ) NEW_LINE curr_index = [ 0 ] * n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT curr_index [ i ] = 0 NEW_LINE DEDENT f = 0 NEW_LINE while ( curr_index [ 0 ] < n ) : NEW_LINE INDENT value = mat [ 0 ] [ curr_index [ 0 ] ] NEW_LINE present = True NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT while ( curr_index [ i ] < n and mat [ i ] [ curr_index [ i ] ] <= value ) : NEW_LINE INDENT curr_index [ i ] = curr_index [ i ] + 1 NEW_LINE DEDENT if ( mat [ i ] [ curr_index [ i ] - 1 ] != value ) : NEW_LINE INDENT present = False NEW_LINE DEDENT if ( curr_index [ i ] == n ) : NEW_LINE INDENT f = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( present ) : NEW_LINE INDENT print ( value , end = \" ▁ \" ) NEW_LINE DEDENT if ( f == 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT curr_index [ 0 ] = curr_index [ 0 ] + 1 NEW_LINE DEDENT DEDENT mat = [ [ 12 , 1 , 14 , 3 , 16 ] , [ 14 , 2 , 1 , 3 , 35 ] , [ 14 , 1 , 14 , 3 , 11 ] , [ 14 , 25 , 3 , 2 , 1 ] , [ 1 , 18 , 3 , 21 , 14 ] ] NEW_LINE n = 5 NEW_LINE findAndPrintCommonElements ( mat , n ) NEW_LINE"],"bleu":0.3347679644476527,"rouge_l":0.5201523506338469}
{"id":1084,"predictions":["def MaximumProduct ( a , n ) : NEW_LINE INDENT cntneg = 0 ; cnt0 = 0 ; NEW_LINE visited = [ False ] * n ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT visited [ a [ i ] ] = True ; NEW_LINE cntzero += 1 ; NEW_LINE DEDENT if ( a [ i ] < 0 ) : NEW_LINE INDENT cntneg += 1 ; NEW_LINE DEDENT if ( ( a [ i ] < 0 or a [ i ] > abs ( a [ i ] ) ) ) : NEW_LINE INDENT cntneg += 1 ; NEW_LINE DEDENT DEDENT if ( cnt0 % 2 == 0 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( visited [ a [ i ] ] > 0 ) : NEW_LINE INDENT print ( 1 , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT DEDENT lst = - 1 ; NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( visited [ i ] == 1 ) : NEW_LINE INDENT print ( 1 , ( i + 2 ) , ( i + 1 ) , ( i + 2 ) ) ; NEW_LINE DEDENT DEDENT lst = - 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( used [ a [ i ] ] == 1 ) : NEW_LINE INDENT lst = i ; NEW_LINE DEDENT DEDENT lst = i ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( used [ a [ i ] ] != - 1 ) : NEW_LINE INDENT print ( 1 , lst [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT if ( lst != - 1 ) : NEW_LINE INDENT print ( 1 , ( lst , end = \" ▁ \" ) ; NEW_LINE DEDENT lst . sort ( ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 5 ,"],"references":["def MaximumProduct ( a , n ) : NEW_LINE INDENT cntneg = 0 NEW_LINE cntzero = 0 NEW_LINE used = [ 0 ] * n NEW_LINE pos = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT used [ i ] = 1 NEW_LINE cntzero += 1 NEW_LINE DEDENT if ( a [ i ] < 0 ) : NEW_LINE INDENT cntneg += 1 NEW_LINE if ( pos == - 1 or abs ( a [ pos ] ) > abs ( a [ i ] ) ) : NEW_LINE INDENT pos = i NEW_LINE DEDENT DEDENT DEDENT if ( cntneg % 2 == 1 ) : NEW_LINE INDENT used [ pos ] = 1 NEW_LINE DEDENT if ( cntzero == n or ( cntzero == n - 1 and cntneg == 1 ) ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT print ( 1 , \" ▁ \" , i + 1 , \" ▁ \" , i + 2 ) NEW_LINE DEDENT return NEW_LINE DEDENT lst = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( used [ i ] ) : NEW_LINE INDENT if ( lst != - 1 ) : NEW_LINE INDENT print ( 1 , \" ▁ \" , lst + 1 , \" ▁ \" , i + 1 ) NEW_LINE DEDENT lst = i NEW_LINE DEDENT DEDENT if ( lst != - 1 ) : NEW_LINE INDENT print ( 2 , \" ▁ \" , lst + 1 ) NEW_LINE DEDENT lst = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( not used [ i ] ) : NEW_LINE INDENT if ( lst != - 1 ) : NEW_LINE INDENT print ( 1 , \" ▁ \" , lst + 1 , \" ▁ \" , i + 1 ) NEW_LINE DEDENT lst = i NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 5 , - 2 , 0 , 1 , - 3 ] NEW_LINE n = len ( a ) NEW_LINE MaximumProduct ( a , n ) NEW_LINE DEDENT"],"bleu":0.5572778621981411,"rouge_l":0.6342604626982064}
{"id":1085,"predictions":["def getSum ( n ) : NEW_LINE INDENT sm = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT sm = sm + n % 10 NEW_LINE n = n \/\/ 10 NEW_LINE DEDENT return sm NEW_LINE DEDENT n = 687 NEW_LINE print ( getSum ( n ) ) NEW_LINE"],"references":["def getSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT sum = sum + int ( n % 10 ) NEW_LINE n = int ( n \/ 10 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 687 NEW_LINE print ( getSum ( n ) ) NEW_LINE"],"bleu":0.6073951081891013,"rouge_l":0.8462219598583234}
{"id":1086,"predictions":["def flipCount ( a , b ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT count += 1 NEW_LINE n &= ( n - 1 ) NEW_LINE DEDENT return count NEW_LINE DEDENT def fl flipCount ( a , b ) : NEW_LINE INDENT return count NEW_LINE DEDENT a = 10 NEW_LINE b = 20 NEW_LINE print ( flipCount ( a , b ) ) NEW_LINE"],"references":["def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while n : NEW_LINE INDENT count += 1 NEW_LINE n &= ( n - 1 ) NEW_LINE DEDENT return count NEW_LINE DEDENT def FlippedCount ( a , b ) : NEW_LINE INDENT return countSetBits ( a ^ b ) NEW_LINE DEDENT a = 10 NEW_LINE b = 20 NEW_LINE print ( FlippedCount ( a , b ) ) NEW_LINE"],"bleu":0.776587668819962,"rouge_l":0.8591549295774648}
{"id":1087,"predictions":["def findSum ( arr , N ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT if arr [ i ] not in mp . keys ( ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE mp [ arr [ i ] ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT maxFreq = 0 NEW_LINE for i in mp : NEW_LINE INDENT if mp . get ( i ) == maxFreq : NEW_LINE INDENT maxFreq = mp [ i ] NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 1 , 2 , 2 , 2 , 2 , 3 , 3 , 3 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE print ( findSum ( arr , N ) ) NEW_LINE DEDENT"],"references":["def findSum ( arr , N ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT mp [ arr [ i ] ] = mp . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT maxFreq = 0 NEW_LINE for itr in mp : NEW_LINE INDENT if ( mp [ itr ] > maxFreq ) : NEW_LINE INDENT maxFreq = mp [ itr ] NEW_LINE DEDENT DEDENT Sum = 0 NEW_LINE for itr in mp : NEW_LINE INDENT if ( mp [ itr ] == maxFreq ) : NEW_LINE INDENT Sum += itr * mp [ itr ] NEW_LINE DEDENT DEDENT return Sum NEW_LINE DEDENT arr = [ 1 , 1 , 2 , 2 , 2 , 2 , 3 , 3 , 3 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE print ( findSum ( arr , N ) ) NEW_LINE"],"bleu":0.6278001157615898,"rouge_l":0.6973191704602933}
{"id":1088,"predictions":["defmdISFactorial ( N ) : NEW_LINE INDENT if ( N <= 2 ) : NEW_LINE INDENT return N NEW_LINE DEDENT if ( N <= 4 ) : NEW_LINE INDENT return N NEW_LINE DEDENT if ( ( N - 4 ) % 4 == 0 ) : NEW_LINE INDENT return ( N + 2 ) NEW_LINE DEDENT elif ( ( N - 4 ) % 4 == 0 ) : NEW_LINE INDENT return ( N + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( N - 1 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE print ( mdISFactorial ( N ) ) NEW_LINE DEDENT"],"references":["def MDAS_Factorial ( N ) : NEW_LINE INDENT if N <= 2 : NEW_LINE INDENT return N NEW_LINE DEDENT if N <= 4 : NEW_LINE INDENT return N + 3 NEW_LINE DEDENT if ( N - 4 ) % 4 == 0 : NEW_LINE INDENT return N + 1 NEW_LINE DEDENT elif ( N - 4 ) % 4 <= 2 : NEW_LINE INDENT return N + 2 NEW_LINE DEDENT else : NEW_LINE INDENT return N - 1 NEW_LINE DEDENT DEDENT N = 4 NEW_LINE print ( MDAS_Factorial ( N ) ) NEW_LINE N = 10 NEW_LINE print ( MDAS_Factorial ( N ) ) NEW_LINE"],"bleu":0.5116035296488175,"rouge_l":0.761367013372957}
{"id":1089,"predictions":["def maxAND ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT res = res + arr [ j ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT arr = [ 4 , 8 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Maximum ▁ AND ▁ Value ▁ = \" , maxAND ( arr , n ) ) NEW_LINE"],"references":["def maxAND ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT res = max ( res , arr [ i ] & arr [ j ] ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT arr = [ 4 , 8 , 6 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Maximum ▁ AND ▁ Value ▁ = ▁ \" , maxAND ( arr , n ) ) NEW_LINE"],"bleu":0.7731198938216021,"rouge_l":0.9112118160456529}
{"id":1090,"predictions":["import math NEW_LINE def check ( arr , x , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT y = math . sqrt ( arr [ i ] ) NEW_LINE if ( floor ( y ) == ceil ( y ) ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT DEDENT if ( sum % x == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE x = 13 NEW_LINE if ( check ( arr , x , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["import math NEW_LINE def check ( a , y ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT x = math . sqrt ( a [ i ] ) NEW_LINE if ( math . floor ( x ) == math . ceil ( x ) ) : NEW_LINE INDENT sum = sum + a [ i ] NEW_LINE DEDENT DEDENT if ( sum % y == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT a = [ 2 , 3 , 4 , 9 , 10 ] NEW_LINE x = 13 NEW_LINE if check ( a , x ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.6366288393645742,"rouge_l":0.8125406107862249}
{"id":1091,"predictions":["MAX_SIZE = 100000 NEW_LINE prime = [ True ] * ( MAX_SIZE + 1 ) NEW_LINE def sieve ( ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= MAX_SIZE : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , MAX_SIZE + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT def kthPrimeFactor ( n , k ) : NEW_LINE INDENT res = - 1 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if ( prime [ i ] == True ) : NEW_LINE INDENT res = i NEW_LINE break NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT sieve ( ) NEW_LINE n = 2 NEW_LINE k = 15 NEW_LINE print ( kthPrimeFactor ( n , k ) ) NEW_LINE"],"references":["MAX_SIZE = int ( 1e6 ) NEW_LINE prime = [ True ] * ( MAX_SIZE + 1 ) NEW_LINE def seive ( ) : NEW_LINE INDENT p = 2 NEW_LINE while ( p * p <= MAX_SIZE ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , MAX_SIZE , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT def kthPrimeGreaterThanN ( n , k ) : NEW_LINE INDENT res = - 1 NEW_LINE for i in range ( n + 1 , MAX_SIZE ) : NEW_LINE INDENT if ( prime [ i ] == True ) : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT if ( k == 0 ) : NEW_LINE INDENT res = i NEW_LINE break NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 2 NEW_LINE k = 15 NEW_LINE seive ( ) NEW_LINE print ( kthPrimeGreaterThanN ( n , k ) ) NEW_LINE DEDENT"],"bleu":0.6875275579615182,"rouge_l":0.8222552756344708}
{"id":1092,"predictions":["def minimumSets ( arr , n , key ) : NEW_LINE INDENT arr . sort ( reverse = True ) NEW_LINE for i in range ( 0 , n - 1 , 1 ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] <= key ) : NEW_LINE INDENT return j NEW_LINE DEDENT DEDENT return i NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 5 , 3 , 4 ] NEW_LINE key = 5 NEW_LINE n = len ( arr ) NEW_LINE print ( minimumSets ( arr , n , key ) ) NEW_LINE DEDENT"],"references":["def minimumSets ( arr , n , key ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE j = n - 1 NEW_LINE for i in range ( 0 , j + 1 , 1 ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] <= key ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT DEDENT return i + 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 5 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE key = 5 NEW_LINE print ( minimumSets ( arr , n , key ) ) NEW_LINE DEDENT"],"bleu":0.7738493533411949,"rouge_l":0.8694801565120178}
{"id":1093,"predictions":["def isPalindrome ( str ) : NEW_LINE INDENT length = len ( str ) NEW_LINE if ( length == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT ptr1 = str [ length - 1 ] NEW_LINE ptr2 = str [ length - 1 ] NEW_LINE while ( ptr2 > ptr1 ) : NEW_LINE INDENT if ( ptr1 != ptr2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT ptr1 -= 1 NEW_LINE ptr2 -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def noOfAnagram ( s ) : NEW_LINE INDENT if ( isPalindrome ( s ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT s = str [ 1 : ] NEW_LINE if ( isPalindrome ( s ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT s = str [ 1 : ] NEW_LINE print ( noOfAnagram ( s ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" abfg \" NEW_LINE print ( noOfAnagram ( s ) ) NEW_LINE DEDENT"],"references":["def isPalindrome ( Str ) : NEW_LINE INDENT Len = len ( Str ) NEW_LINE if ( Len == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT ptr1 = 0 NEW_LINE ptr2 = Len - 1 NEW_LINE while ( ptr2 > ptr1 ) : NEW_LINE INDENT if ( Str [ ptr1 ] != Str [ ptr2 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT ptr1 += 1 NEW_LINE ptr2 -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def noOfAppends ( s ) : NEW_LINE INDENT if ( isPalindrome ( s ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT del s [ 0 ] NEW_LINE return 1 + noOfAppends ( s ) NEW_LINE DEDENT se = \" abede \" NEW_LINE s = [ i for i in se ] NEW_LINE print ( noOfAppends ( s ) ) NEW_LINE"],"bleu":0.4759016396493933,"rouge_l":0.728848223896663}
{"id":1094,"predictions":["from math import sqrt NEW_LINE def add_factors ( n , m , mp ) : NEW_LINE INDENT for i in range ( 1 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT if m [ i ] == i : NEW_LINE INDENT mp [ i ] = mp . get ( i , 0 ) + 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ i ] = mp . get ( i , 0 ) + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT def count_divisors ( a , n ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] not in mp . keys ( ) : NEW_LINE INDENT mp [ a [ i ] ] = mp . get ( a [ i ] , 0 ) + 1 NEW_LINE mp [ a [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ a [ i ] ] = mp . get ( a [ i ] , 0 ) + 1 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 8 , 1 , 28 , 4 , 2 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE count_divisors ( arr , n ) NEW_LINE DEDENT"],"references":["from collections import defaultdict NEW_LINE import math NEW_LINE def add_factors ( n , mp ) : NEW_LINE INDENT for i in range ( 1 , int ( math . sqrt ( n ) ) + 1 , ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n \/\/ i == i ) : NEW_LINE INDENT mp [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ i ] += 1 NEW_LINE mp [ n \/\/ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT def count_divisors ( a , n ) : NEW_LINE INDENT mp = defaultdict ( int ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( mp [ a [ i ] ] , end = \" ▁ \" ) NEW_LINE add_factors ( a [ i ] , mp ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 8 , 1 , 28 , 4 , 2 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE count_divisors ( arr , n ) NEW_LINE DEDENT"],"bleu":0.552214236800666,"rouge_l":0.7333739156901538}
{"id":1095,"predictions":["def isPossible ( arr , n , C , idx ) : NEW_LINE INDENTIENT = 1 NEW_LINE currPosition = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i ] - currPosition >= 1 : NEW_LINE INDENTIENT += 1 NEW_LINE DEDENT else : NEW_LINE INDENT currPosition += 1 NEW_LINE DEDENT if ( delta == C ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def binarySearch ( arr , C , idx ) : NEW_LINE INDENT lo = 0 NEW_LINE hi = arr [ 0 ] NEW_LINE while ( lo <= hi ) : NEW_LINE INDENT mid = ( lo + hi ) \/\/ 2 NEW_LINE if ( not binarySearch ( arr , n , C , idx ) : NEW_LINE INDENT lo = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT hi = mid - 1 NEW_LINE DEDENT DEDENT return ( lo , hi , mid ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 5 , 8 , 18 , 18 ] NEW_LINE arr = [ 1 , 2 , 2 , 8 , 10 , 18 ] NEW_LINE n = len ( arr ) NEW_LINE print ( binarySearch ( arr , n , C , arr , n ) ) NEW_LINE DEDENT"],"references":["def isPossible ( arr , n , C , mid ) : NEW_LINE INDENT magnet = 1 NEW_LINE currPosition = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] - currPosition >= mid ) : NEW_LINE INDENT magnet += 1 NEW_LINE currPosition = arr [ i ] NEW_LINE if ( magnet == C ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT def binarySearch ( n , C , arr ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE lo = 0 NEW_LINE hi = arr [ n - 1 ] NEW_LINE ans = 0 NEW_LINE while ( lo <= hi ) : NEW_LINE INDENT mid = int ( ( lo + hi ) \/ 2 ) NEW_LINE if ( isPossible ( arr , n , C , mid ) == False ) : NEW_LINE INDENT hi = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( ans , mid ) NEW_LINE lo = mid + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT C = 4 NEW_LINE arr = [ 1 , 2 , 5 , 8 , 10 , 18 ] NEW_LINE n = len ( arr ) NEW_LINE print ( binarySearch ( n , C , arr ) ) NEW_LINE DEDENT"],"bleu":0.6589704353640694,"rouge_l":0.7698342315301181}
{"id":1096,"predictions":["def makePalindrome ( n , base ) : NEW_LINE INDENT res = n \/\/ 10 NEW_LINE if ( n ) : NEW_LINE INDENT return res NEW_LINE DEDENT while ( n > 0 ) : NEW_LINE INDENT res = 10 * base + n % base NEW_LINE n = int ( n \/ 10 ) NEW_LINE DEDENT return res NEW_LINE DEDENT def isPalindrome ( n , base ) : NEW_LINE INDENT reverse = 0 NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT if ( isPalindrome ( p , k ) ) : NEW_LINE INDENT reverse = reverse * base NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return reverse NEW_LINE DEDENT def sumPalindrome ( i , k ) : NEW_LINE INDENT sum = 0 NEW_LINE i = 1 NEW_LINE while ( temp < n ) : NEW_LINE INDENT if ( isPalindrome ( p , k ) ) : NEW_LINE INDENT sum += p NEW_LINE i += 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return sum == n NEW_LINE DEDENT def sumPalindrome ( n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE i = 1 NEW_LINE while ( True ) : NEW_LINE INDENT if ( isPalindrome ( i , k ) ) : NEW_LINE INDENT sum += p NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 1000000 NEW_LINE k = 2 NEW_LINE sumPalindrome ( n , k ) NEW_LINE DEDENT"],"references":["def makePalindrome ( n , odd ) : NEW_LINE INDENT res = n ; NEW_LINE if ( odd ) : NEW_LINE INDENT n = int ( n \/ 10 ) ; NEW_LINE DEDENT while ( n > 0 ) : NEW_LINE INDENT res = 10 * res + n % 10 ; NEW_LINE n = int ( n \/ 10 ) ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT def isPalindrome ( n , base ) : NEW_LINE INDENT reversed = 0 ; NEW_LINE temp = n ; NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT reversed = reversed * base + temp % base ; NEW_LINE temp = int ( temp \/ base ) ; NEW_LINE DEDENT return reversed == n ; NEW_LINE DEDENT def sumPalindrome ( n , k ) : NEW_LINE INDENT sum = 0 ; NEW_LINE i = 1 ; NEW_LINE p = makePalindrome ( i , True ) ; NEW_LINE while ( p < n ) : NEW_LINE INDENT if ( isPalindrome ( p , k ) ) : NEW_LINE INDENT sum += p ; NEW_LINE DEDENT i += 1 ; NEW_LINE p = makePalindrome ( i , True ) ; NEW_LINE DEDENT i = 1 ; NEW_LINE p = makePalindrome ( i , False ) ; NEW_LINE while ( p < n ) : NEW_LINE INDENT if ( isPalindrome ( p , k ) ) : NEW_LINE INDENT sum += p ; NEW_LINE DEDENT i += 1 ; NEW_LINE p = makePalindrome ( i , False ) ; NEW_LINE DEDENT print ( \" Total ▁ sum ▁ is \" , sum ) ; NEW_LINE DEDENT n = 1000000 ; NEW_LINE k = 2 ; NEW_LINE sumPalindrome ( n , k ) ; NEW_LINE"],"bleu":0.4968597106239317,"rouge_l":0.6664079756432452}
{"id":1097,"predictions":["class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def newNode ( data ) : NEW_LINE INDENT newNode = Node ( data ) NEW_LINE newNode . data = data NEW_LINE newNode . left = newNode ( data ) NEW_LINE newNode . left = newNode ( data ) NEW_LINE newNode . left = newNode NEW_LINE return newNode NEW_LINE DEDENT def countDefault ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT l = newNode ( data ) NEW_LINE r = newNode ( data ) NEW_LINE maxCount = 0 NEW_LINE res = 0 NEW_LINE if ( root . data == 1 ) : NEW_LINE INDENT if ( root . data == 0 ) : NEW_LINE INDENT maxCount = count + 1 NEW_LINE DEDENT else : NEW_LINE INDENT maxCount = l + r NEW_LINE DEDENT if ( root . data != 1 ) : NEW_LINE INDENT res = l + r NEW_LINE DEDENT else : NEW_LINE INDENT maxCount = count NEW_LINE DEDENT DEDENT return max ( l , r ) NEW_LINE DEDENT def findMaxCount ( root ) : NEW_LINE INDENT res = float ( ' inf ' ) NEW_LINE count = 0 NEW_LINE for i in range ( 1 , root + 1 ) : NEW_LINE INDENT print ( maxCount , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = Node ( 1 ) NEW_LINE root . left = newNode ( 1 ) NEW_LINE root . left = newNode ( 0 ) NEW_LINE root . right = newNode ( 1 ) NEW_LINE root . left . left = newNode ( 1 ) NEW_LINE root . right . left = newNode ( 2 ) NEW_LINE root . left . left = newNode ( 1 ) NEW_LINE root . right . left = newNode ( 1 ) NEW_LINE root ."],"references":["class Node : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . data = 0 NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def newNode ( data ) : NEW_LINE INDENT newNode = Node ( ) NEW_LINE newNode . data = data NEW_LINE newNode . left = newNode . right = None NEW_LINE return ( newNode ) NEW_LINE DEDENT res = 0 NEW_LINE def countUntil ( root ) : NEW_LINE INDENT global res NEW_LINE if ( root == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT l = countUntil ( root . left ) NEW_LINE r = countUntil ( root . right ) NEW_LINE maxCount = 0 NEW_LINE if ( root . data == 1 ) : NEW_LINE INDENT maxCount = l + r + 1 NEW_LINE DEDENT else : NEW_LINE INDENT maxCount = l + r NEW_LINE DEDENT res = max ( res , maxCount ) NEW_LINE if ( root . data == 1 ) : NEW_LINE INDENT return max ( l , r ) + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return max ( l , r ) NEW_LINE DEDENT DEDENT def findMaxCount ( root ) : NEW_LINE INDENT global res NEW_LINE res = - 999999 NEW_LINE countUntil ( root ) NEW_LINE return res NEW_LINE DEDENT root = newNode ( 1 ) NEW_LINE root . left = newNode ( 0 ) NEW_LINE root . right = newNode ( 1 ) NEW_LINE root . left . left = newNode ( 1 ) NEW_LINE root . left . right = newNode ( 1 ) NEW_LINE root . left . right . left = newNode ( 1 ) NEW_LINE root . left . right . right = newNode ( 0 ) NEW_LINE print ( findMaxCount ( root ) ) NEW_LINE"],"bleu":0.6126077584650227,"rouge_l":0.7397358820204512}
{"id":1098,"predictions":["def countDigits ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( n ) : NEW_LINE INDENT count += 1 ; NEW_LINE n \/\/= 10 ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT def getDigits ( d , count ) : NEW_LINE INDENT num = 0 ; NEW_LINE countDigits = ( pow ( 10 , count - 1 ) ) ; NEW_LINE while ( count > 0 ) : NEW_LINE INDENT num += ( count * d ) ; NEW_LINE count \/\/= 10 ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT def getDigits ( L , R ) : NEW_LINE INDENT countDigits = countDigits ( L - 1 ) ; NEW_LINE countDigits = countDigits ( R ) ; NEW_LINE firstDigits = countDigits ( L , countDigits ) ; NEW_LINE if ( countDigits < countDigits < L ) : NEW_LINE INDENT countDigits = countDigits ; NEW_LINE DEDENT if ( countDigits < R ) : NEW_LINE INDENT count += ( 9 ; NEW_LINE DEDENT elif ( countDigits < R ) : NEW_LINE INDENT count += ( 9 - firstDigits ) ; NEW_LINE DEDENT else : NEW_LINE INDENT count += ( 9 - firstDigits ) ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT L = 10 ; R = 50 ; NEW_LINE print ( findDigits ( L , R ) ) ; NEW_LINE DEDENT"],"references":["def countDigits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT count += 1 NEW_LINE n \/\/= 10 NEW_LINE DEDENT return count NEW_LINE DEDENT def getDistinct ( d , count ) : NEW_LINE INDENT num = 0 NEW_LINE count = pow ( 10 , count - 1 ) NEW_LINE while ( count > 0 ) : NEW_LINE INDENT num += ( count * d ) NEW_LINE count \/\/= 10 NEW_LINE DEDENT return num NEW_LINE DEDENT def findCount ( L , R ) : NEW_LINE INDENT count = 0 NEW_LINE countDigitsL = countDigits ( L ) NEW_LINE countDigitsR = countDigits ( R ) NEW_LINE firstDigitL = ( L \/\/ pow ( 10 , countDigitsL - 1 ) ) NEW_LINE firstDigitR = ( R \/\/ pow ( 10 , countDigitsR - 1 ) ) NEW_LINE if ( countDigitsL < countDigitsR ) : NEW_LINE INDENT count += ( 9 * ( countDigitsR - countDigitsL - 1 ) ) NEW_LINE if ( getDistinct ( firstDigitL , countDigitsL ) >= L ) : NEW_LINE INDENT count += ( 9 - firstDigitL + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT count += ( 9 - firstDigitL ) NEW_LINE DEDENT if ( getDistinct ( firstDigitR , countDigitsR ) <= R ) : NEW_LINE INDENT count += firstDigitR NEW_LINE DEDENT else : NEW_LINE INDENT count += ( firstDigitR - 1 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( getDistinct ( firstDigitL , countDigitsL ) >= L ) : NEW_LINE INDENT count += ( 9 - firstDigitL + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT count += ( 9 - firstDigitL ) NEW_LINE DEDENT if ( getDistinct ( firstDigitR , countDigitsR ) <= R ) : NEW_LINE INDENT count -= ( 9 - firstDigitR ) NEW_LINE DEDENT else : NEW_LINE INDENT count -= ( 9 - firstDigitR + 1 ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT L = 10 NEW_LINE R = 50 NEW_LINE print ( findCount ( L , R ) ) NEW_LINE"],"bleu":0.3441163229321603,"rouge_l":0.5902144035184168}
{"id":1099,"predictions":["def isPalindrome ( n ) : NEW_LINE INDENT divisor = 1 NEW_LINE while ( n \/\/ divisor >= 10 ) : NEW_LINE INDENT divisor *= 10 NEW_LINE DEDENT while ( n != 0 ) : NEW_LINE INDENT leading = n \/\/ divisor NEW_LINE trailing = n % 10 NEW_LINE if ( leading != trailing ) : NEW_LINE INDENT return False NEW_LINE DEDENT n = ( n % divisor ) \/\/ 10 NEW_LINE divisor = divisor \/\/ 100 NEW_LINE DEDENT return True NEW_LINE DEDENT def largestPalindrome ( A , n ) : NEW_LINE INDENT A . sort ( ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( isPalindrome ( A [ i ] ) ) : NEW_LINE INDENT return A [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT A = [ 1 , 232 , 545454545 , 999991 ] NEW_LINE n = len ( A ) NEW_LINE print ( largestPalindrome ( A , n ) ) NEW_LINE"],"references":["def isPalindrome ( n ) : NEW_LINE INDENT divisor = 1 NEW_LINE while ( n \/ divisor >= 10 ) : NEW_LINE INDENT divisor *= 10 NEW_LINE DEDENT while ( n != 0 ) : NEW_LINE INDENT leading = n \/\/ divisor NEW_LINE trailing = n % 10 NEW_LINE if ( leading != trailing ) : NEW_LINE INDENT return False NEW_LINE DEDENT n = ( n % divisor ) \/\/ 10 NEW_LINE divisor = divisor \/\/ 100 NEW_LINE DEDENT return True NEW_LINE DEDENT def largestPalindrome ( A , n ) : NEW_LINE INDENT A . sort ( ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( isPalindrome ( A [ i ] ) ) : NEW_LINE INDENT return A [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 1 , 232 , 54545 , 999991 ] NEW_LINE n = len ( A ) NEW_LINE print ( largestPalindrome ( A , n ) ) NEW_LINE DEDENT"],"bleu":0.8865839833650575,"rouge_l":0.9430702073481266}
{"id":1100,"predictions":["def getPerfectSquares ( arr , n ) : NEW_LINE INDENT perfectSquares = [ ] NEW_LINE current = 1 NEW_LINE i = 0 NEW_LINE while ( current <= n ) : NEW_LINE INDENT perfectSquares . append ( current ) NEW_LINE i = i + 1 NEW_LINE while ( current <= n ) : NEW_LINE INDENT if ( arr [ current ] > arr [ i ] ) : NEW_LINE INDENT max = arr [ i ] NEW_LINE current = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT current = arr [ current ] NEW_LINE DEDENT DEDENT DEDENT return ( max , current + secondMax ) NEW_LINE DEDENT def countPairs ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE maxSize = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > maxSize ) : NEW_LINE INDENT secondMax = max ( arr [ i ] , arr [ i ] ) NEW_LINE if ( arr [ i ] > secondMax ) : NEW_LINE INDENT count += 1 NEW_LINE max = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > secondMax ) : NEW_LINE INDENT secondMax = arr [ i ] NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT def countPair ( arr , n , perfectSquares ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( perfectSquares ) ) : NEW_LINE INDENT temp = perfectSquares ( arr [ i ] , perfectSquares ) NEW_LINE if ( temp ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 3 , 6 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE k = 0 NEW_LINE print ( countPair ( arr , n ) ) NEW_LINE DEDENT"],"references":["def getPerfectSquares ( n ) : NEW_LINE INDENT perfectSquares = [ ] ; NEW_LINE current = 1 ; NEW_LINE i = 1 ; NEW_LINE while ( current <= n ) : NEW_LINE INDENT perfectSquares . append ( current ) ; NEW_LINE i += 1 ; NEW_LINE current = int ( pow ( i , 2 ) ) ; NEW_LINE DEDENT return perfectSquares ; NEW_LINE DEDENT def maxPairSum ( arr ) : NEW_LINE INDENT n = len ( arr ) ; NEW_LINE max = 0 ; NEW_LINE secondMax = 0 ; NEW_LINE if ( arr [ 0 ] > arr [ 1 ] ) : NEW_LINE INDENT max = arr [ 0 ] ; NEW_LINE secondMax = arr [ 1 ] ; NEW_LINE DEDENT else : NEW_LINE INDENT max = arr [ 1 ] ; NEW_LINE secondMax = arr [ 0 ] ; NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if ( arr [ i ] > max ) : NEW_LINE INDENT secondMax = max ; NEW_LINE max = arr [ i ] ; NEW_LINE DEDENT elif ( arr [ i ] > secondMax ) : NEW_LINE INDENT secondMax = arr [ i ] ; NEW_LINE DEDENT DEDENT return ( max + secondMax ) ; NEW_LINE DEDENT def countPairsWith ( n , perfectSquares , nums ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( len ( perfectSquares ) ) : NEW_LINE INDENT temp = perfectSquares [ i ] - n ; NEW_LINE if ( temp > n and ( temp in nums ) ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT def countPairs ( arr ) : NEW_LINE INDENT n = len ( arr ) ; NEW_LINE max = maxPairSum ( arr ) ; NEW_LINE perfectSquares = getPerfectSquares ( max ) ; NEW_LINE nums = [ ] ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT nums . append ( arr [ i ] ) ; NEW_LINE DEDENT count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT count += countPairsWith ( arr [ i ] , perfectSquares , nums ) ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT arr = [ 2 , 3 , 6 , 9 , 10 , 20 ] ; NEW_LINE print ( countPairs ( arr ) ) ; NEW_LINE"],"bleu":0.47044305730042046,"rouge_l":0.581547645565109}
{"id":1101,"predictions":["if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT for i in range ( 5 ) : NEW_LINE INDENT spf = [ 0 ] * 100 NEW_LINE spf [ 0 ] = 0 NEW_LINE for i in range ( 1 , 5 ) : NEW_LINE INDENT spf [ i ] = spf [ i - 1 ] NEW_LINE DEDENT for j in range ( 5 , i - 1 , - 1 ) : NEW_LINE INDENT print ( spf [ j ] , end = \" \" ) NEW_LINE DEDENT for j in range ( 1 , i - 1 ) : NEW_LINE INDENT print ( spf [ j ] , end = \" \" ) NEW_LINE spf [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT spf = 1 NEW_LINE for i in range ( 4 , i + 1 ) : NEW_LINE INDENT if ( i % 2 != 0 ) : NEW_LINE INDENT for j in range ( 5 , i + 1 ) : NEW_LINE INDENT print ( spf [ i ] , end = \" ▁ \" ) NEW_LINE spf = 0 NEW_LINE spf = 1 NEW_LINE DEDENT DEDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( spf , end = \" ▁ \" ) NEW_LINE spf = 1 NEW_LINE while ( spf [ j ] != 0 ) : NEW_LINE INDENT print ( spf , end = \" \" ) NEW_LINE spf -= 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT"],"references":["if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT space = 4 NEW_LINE prt = ' $ ' NEW_LINE for i in range ( 1 , 6 ) : NEW_LINE INDENT for sp in range ( space , 0 , - 1 ) : NEW_LINE INDENT print ( end = \" ▁ \" ) NEW_LINE DEDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( prt , end = \" \" ) NEW_LINE DEDENT for k in range ( 1 , i ) : NEW_LINE INDENT if ( i == 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT print ( prt , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE space -= 1 NEW_LINE DEDENT space = 1 NEW_LINE for i in range ( 4 , 0 , - 1 ) : NEW_LINE INDENT for sp in range ( space , 0 , - 1 ) : NEW_LINE INDENT print ( end = \" ▁ \" ) NEW_LINE DEDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( prt , end = \" \" ) NEW_LINE DEDENT for k in range ( 1 , i ) : NEW_LINE INDENT print ( prt , end = \" \" ) NEW_LINE DEDENT space += 1 NEW_LINE print ( ) NEW_LINE DEDENT space = 3 NEW_LINE for i in range ( 2 , 6 ) : NEW_LINE INDENT if ( ( i % 2 ) != 0 ) : NEW_LINE INDENT for sp in range ( space , 0 , - 1 ) : NEW_LINE INDENT print ( \" ▁ \" , end = \" \" ) NEW_LINE DEDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( prt , end = \" \" ) NEW_LINE DEDENT DEDENT if ( ( i % 2 ) != 0 ) : NEW_LINE INDENT print ( ) NEW_LINE space -= 1 NEW_LINE DEDENT DEDENT DEDENT"],"bleu":0.42771938228762796,"rouge_l":0.5646324399956947}
{"id":1102,"predictions":["def maxLen ( arr , n ) : NEW_LINE INDENT min_val = min ( arr ) NEW_LINE freq = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == min_val ) : NEW_LINE INDENT freq += 1 NEW_LINE DEDENT DEDENT return freq NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 3 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxLen ( arr , n ) ) NEW_LINE DEDENT"],"references":["def maxLen ( arr , n ) : NEW_LINE INDENT min_val = min ( arr ) ; NEW_LINE freq = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == min_val ) : NEW_LINE INDENT freq += 1 ; NEW_LINE DEDENT DEDENT return freq ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 3 , 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( maxLen ( arr , n ) ) ; NEW_LINE DEDENT"],"bleu":0.7693860923773036,"rouge_l":0.9375208820581356}
{"id":1103,"predictions":["def printKDistinct ( arr , n , k ) : NEW_LINE INDENT h = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT h [ arr [ i ] ] = h [ arr [ i ] ] + 1 NEW_LINE DEDENT if ( h [ arr [ i ] ] == 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT dist_count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( h [ arr [ i ] ] == 1 ) : NEW_LINE INDENT dist_count += 1 NEW_LINE DEDENT if ( dist_count == k ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT ar = [ 1 , 2 , 1 , 3 , 4 ] NEW_LINE n = len ( ar ) NEW_LINE printKDistinct ( ar , n , 2 ) NEW_LINE DEDENT"],"references":["def printKDistinct ( arr , size , KthIndex ) : NEW_LINE INDENT dict = { } NEW_LINE vect = [ ] NEW_LINE for i in range ( size ) : NEW_LINE INDENT if ( arr [ i ] in dict ) : NEW_LINE INDENT dict [ arr [ i ] ] = dict [ arr [ i ] ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dict [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT for i in range ( size ) : NEW_LINE INDENT if ( dict [ arr [ i ] ] > 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT KthIndex = KthIndex - 1 NEW_LINE DEDENT if ( KthIndex == 0 ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 1 , 2 , 1 , 3 , 4 , 2 ] NEW_LINE size = len ( arr ) NEW_LINE print ( printKDistinct ( arr , size , 2 ) ) NEW_LINE"],"bleu":0.5082336961629557,"rouge_l":0.6813365155131266}
{"id":1104,"predictions":["def checkSubarraySum ( arr , n , k , sum ) : NEW_LINE INDENT curr_sum = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT curr_sum += arr [ i ] NEW_LINE if ( curr_sum == sum ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( curr_sum == sum ) : NEW_LINE INDENT return True NEW_LINE DEDENT for j in range ( k , n ) : NEW_LINE INDENT curr_sum += arr [ j ] - arr [ j - k ] NEW_LINE if ( curr_sum == sum ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 4 , 2 , 10 , 2 , 3 , 1 , 0 , 20 ] NEW_LINE k = 18 NEW_LINE n = len ( arr ) NEW_LINE if ( checkSubarraySum ( arr , n , k , sum ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"references":["def checkSubarraySum ( arr , n , k , sumV ) : NEW_LINE INDENT curr_sum = 0 NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT curr_sum += arr [ i ] NEW_LINE DEDENT if ( curr_sum == sumV ) : NEW_LINE INDENT return true NEW_LINE DEDENT for j in range ( k , n ) : NEW_LINE INDENT curr_sum = ( curr_sum + arr [ j ] - arr [ j - k ] ) NEW_LINE if ( curr_sum == sumV ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT arr = [ 1 , 4 , 2 , 10 , 2 , 3 , 1 , 0 , 20 ] NEW_LINE k = 4 NEW_LINE sumV = 18 NEW_LINE n = len ( arr ) NEW_LINE if ( checkSubarraySum ( arr , n , k , sumV ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"],"bleu":0.7466921445291154,"rouge_l":0.8716680406705138}
{"id":1105,"predictions":["def printCombination ( n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( i % 3 != 0 and n % 3 != 0 ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if ( j % 3 != 0 and ( i + j ) == n ) : NEW_LINE INDENT print ( i , j , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 256 NEW_LINE printCombination ( n ) NEW_LINE DEDENT"],"references":["def printCombination ( n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( i % 3 != 0 ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if ( j % 3 != 0 ) : NEW_LINE INDENT for k in range ( 1 , n ) : NEW_LINE INDENT if ( k % 3 != 0 and ( i + j + k ) == n ) : NEW_LINE INDENT print ( i , j , k ) ; NEW_LINE return ; NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT n = 233 ; NEW_LINE printCombination ( n ) ; NEW_LINE"],"bleu":0.6605843690723837,"rouge_l":0.7237858719646799}
{"id":1106,"predictions":["import math NEW_LINE def countNumbersWith4 ( n ) : NEW_LINE INDENT if ( n < 4 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT d = int ( math . log10 ( n , 10 ) ) NEW_LINE a = [ 0 ] * ( d + 2 ) NEW_LINE for i in range ( 2 , d + 1 ) : NEW_LINE INDENT a [ i ] = a [ i - 1 ] * 9 + int ( math . ceil ( math . pow ( 10 , i - 1 ) ) ) NEW_LINE DEDENT p = int ( math . pow ( 10 , d ) ) NEW_LINE p = int ( math . ceil ( math . pow ( 10 , d ) ) + 1 ) NEW_LINE if ( msd == 4 ) : NEW_LINE INDENT return ( msd - 1 ) * a NEW_LINE DEDENT if ( msd == 4 ) : NEW_LINE INDENT return ( msd - 1 ) * a NEW_LINE DEDENT return ( int ( msd ) * a [ d ] + ( n % p ) + ( n % p ) + countNumbersWith4 ( n % p ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 328 NEW_LINE print ( \" Count ▁ of ▁ numbers ▁ from ▁ 1 ▁ to ▁ 4\" ) NEW_LINE DEDENT"],"references":["import math as mt NEW_LINE def countNumbersWith4 ( n ) : NEW_LINE INDENT if ( n < 4 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT d = int ( mt . log10 ( n ) ) NEW_LINE a = [ 1 for i in range ( d + 1 ) ] NEW_LINE a [ 0 ] = 0 NEW_LINE if len ( a ) > 1 : NEW_LINE INDENT a [ 1 ] = 1 NEW_LINE DEDENT for i in range ( 2 , d + 1 ) : NEW_LINE INDENT a [ i ] = a [ i - 1 ] * 9 + mt . ceil ( pow ( 10 , i - 1 ) ) NEW_LINE DEDENT p = mt . ceil ( pow ( 10 , d ) ) NEW_LINE msd = n \/\/ p NEW_LINE if ( msd == 4 ) : NEW_LINE INDENT return ( msd ) * a [ d ] + ( n % p ) + 1 NEW_LINE DEDENT if ( msd > 4 ) : NEW_LINE INDENT return ( ( msd - 1 ) * a [ d ] + p + countNumbersWith4 ( n % p ) ) NEW_LINE DEDENT return ( msd ) * a [ d ] + countNumbersWith4 ( n % p ) NEW_LINE DEDENT n = 328 NEW_LINE print ( \" Count ▁ of ▁ numbers ▁ from ▁ 1 ▁ to \" , n , \" that ▁ have ▁ 4 ▁ as ▁ a ▁ digit ▁ is \" , countNumbersWith4 ( n ) ) NEW_LINE"],"bleu":0.6101604953980442,"rouge_l":0.6767285861713106}
{"id":1107,"predictions":["import math NEW_LINE def generateDivisors ( n ) : NEW_LINE INDENT for i in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n \/\/ i == i ) : NEW_LINE INDENT arr [ i ] = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] , arr [ i ] = arr [ i ] , arr [ i - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT def harmonicMean ( n ) : NEW_LINE INDENT computeDivisors ( n ) NEW_LINE sum = 0 NEW_LINE l = len ( arr ) NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT sum = sum + n \/ arr [ i ] NEW_LINE if ( mean - floor ( sum ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def meanMean ( n ) : NEW_LINE INDENT mean = geometric ( n ) NEW_LINE sum = calculateDivisors ( n ) NEW_LINE if ( mean - sum ) == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 28 NEW_LINE if ( filterDivisors ( n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"references":["arr = [ ] NEW_LINE def generateDivisors ( n ) : NEW_LINE INDENT for i in range ( 1 , int ( n ** ( 0.5 ) ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT if n \/\/ i == i : NEW_LINE INDENT arr . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT arr . append ( i ) NEW_LINE arr . append ( n \/\/ i ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def harmonicMean ( n ) : NEW_LINE INDENT generateDivisors ( n ) NEW_LINE Sum = 0 NEW_LINE length = len ( arr ) NEW_LINE for i in range ( 0 , length ) : NEW_LINE INDENT Sum = Sum + ( n \/ arr [ i ] ) NEW_LINE DEDENT Sum = Sum \/ n NEW_LINE return length \/ Sum NEW_LINE DEDENT def isOreNumber ( n ) : NEW_LINE INDENT mean = harmonicMean ( n ) NEW_LINE if mean - int ( mean ) == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 28 NEW_LINE if isOreNumber ( n ) == True : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.5604155248091588,"rouge_l":0.7542316847394869}
{"id":1108,"predictions":["import math NEW_LINE def powOfPositive ( n ) : NEW_LINE INDENT pos = int ( math . log ( n , 2 ) ) ; NEW_LINE return math . ceil ( pow ( 2 , pos ) ) ; NEW_LINE DEDENT def powerOfPos ( n ) : NEW_LINE INDENT pos = math . ceil ( math . log ( n ) \/ math . log ( 2 ) ) ; NEW_LINE return ( - 1 * pow ( 2 , pos ) ) ; NEW_LINE DEDENT def highestPowerOfPositive ( n ) : NEW_LINE INDENT pos = ( math . ceil ( math . log ( n ) ) ) ; NEW_LINE return ( - 1 * pow ( 2 , pos ) ) ; NEW_LINE DEDENT n = - 24 ; NEW_LINE print ( highestPowerOfPositive ( n ) ) ; NEW_LINE"],"references":["from math import floor , ceil , log2 NEW_LINE def powOfPositive ( n ) : NEW_LINE INDENT pos = floor ( log2 ( n ) ) ; NEW_LINE return 2 ** pos ; NEW_LINE DEDENT def powOfNegative ( n ) : NEW_LINE INDENT pos = ceil ( log2 ( n ) ) ; NEW_LINE return ( - 1 * pow ( 2 , pos ) ) ; NEW_LINE DEDENT def highestPowerOf2 ( n ) : NEW_LINE INDENT if ( n > 0 ) : NEW_LINE INDENT print ( powOfPositive ( n ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT n = - n ; NEW_LINE print ( powOfNegative ( n ) ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = - 24 ; NEW_LINE highestPowerOf2 ( n ) ; NEW_LINE DEDENT"],"bleu":0.4739852826694184,"rouge_l":0.6329989622967831}
{"id":1109,"predictions":["def findPrime ( arr , n ) : NEW_LINE INDENT prime = [ True ] * ( 1000000 ) NEW_LINE p = 2 NEW_LINE while ( p * p <= 1000000 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , 100001 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT def lenOfLongSubarr ( arr , n ) : NEW_LINE INDENT um = { } NEW_LINE maxLen = 0 NEW_LINE maxLen = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] == False ) : NEW_LINE INDENT maxLen = i + 1 NEW_LINE DEDENT elif ( sum [ arr [ i ] ] == False ) : NEW_LINE INDENT maxLen = i - 1 NEW_LINE DEDENT elif ( sum [ arr [ i ] ] == False ) : NEW_LINE INDENT if ( maxLen < ( i - arr [ i ] ) ) : NEW_LINE INDENT maxLen = i - um [ arr [ i ] ] NEW_LINE DEDENT elif ( sum [ arr [ i ] ] == False ) : NEW_LINE INDENT maxLen = i - um [ arr [ i ] ] NEW_LINE DEDENT DEDENT DEDENT return maxLen NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 9 , 3 , 4 , 5 , 6 , 7 , 8 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( len ( findPrimeSubarr ( arr , n ) ) NEW_LINE DEDENT"],"references":["prime = [ True ] * ( 1000000 + 5 ) NEW_LINE def findPrime ( ) : NEW_LINE INDENT prime [ 0 ] , prime [ 1 ] = False , False NEW_LINE for p in range ( 2 , 1001 ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , 1000001 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def lenOfLongSubarr ( arr , n ) : NEW_LINE INDENT um = { } NEW_LINE Sum , maxLen = 0 , 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT Sum = Sum - 1 if prime [ arr [ i ] ] == False else Sum + 1 NEW_LINE if Sum == 1 : NEW_LINE INDENT maxLen = i + 1 NEW_LINE DEDENT elif Sum not in um : NEW_LINE INDENT um [ Sum ] = i NEW_LINE DEDENT if ( Sum - 1 ) in um : NEW_LINE INDENT if maxLen < ( i - um [ Sum - 1 ] ) : NEW_LINE INDENT maxLen = i - um [ Sum - 1 ] NEW_LINE DEDENT DEDENT DEDENT return maxLen NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT findPrime ( ) NEW_LINE arr = [ 1 , 9 , 3 , 4 , 5 , 6 , 7 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( lenOfLongSubarr ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.5561423325087466,"rouge_l":0.6966452533904353}
{"id":1110,"predictions":["def turnOnOfK ( n , k ) : NEW_LINE INDENT if ( k <= 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return ( n & ~ ( 1 << ( k - 1 ) ) ) NEW_LINE DEDENT n = 15 NEW_LINE k = 4 NEW_LINE print ( turnOnOfK ( n , k ) ) NEW_LINE"],"references":["def turnOffK ( n , k ) : NEW_LINE INDENT if ( k <= 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return ( n & ~ ( 1 << ( k - 1 ) ) ) NEW_LINE DEDENT n = 15 NEW_LINE k = 4 NEW_LINE print ( turnOffK ( n , k ) ) NEW_LINE"],"bleu":0.9251768748886328,"rouge_l":0.9655172413793103}
{"id":1111,"predictions":["def longestSubarray ( a , n ) : NEW_LINE INDENT hash = [ [ 0 for i in range ( 10 ) ] for j in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT num = a [ i ] NEW_LINE while ( num != 0 ) : NEW_LINE INDENT hash [ num % 10 ] = 1 NEW_LINE num \/\/= 10 NEW_LINE DEDENT DEDENT longest = - sys . maxsize NEW_LINE count = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT j = 0 NEW_LINE while ( num != 0 ) : NEW_LINE INDENT if ( hash [ i ] == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( j == 10 ) : NEW_LINE INDENT count = max ( count , count + 1 ) NEW_LINE break NEW_LINE DEDENT DEDENT if ( j == 10 ) : NEW_LINE INDENT return max ( hash [ count ] , count ) NEW_LINE DEDENT DEDENT return longest NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 11 , 22 , 33 , 36 , 52 , 56 ] NEW_LINE n = len ( a ) NEW_LINE print ( longestSubarray ( a , n ) ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE def longestSubarray ( a , n ) : NEW_LINE INDENT hash = [ [ 0 for i in range ( 10 ) ] for j in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT num = a [ i ] NEW_LINE while ( num ) : NEW_LINE INDENT hash [ i ] [ num % 10 ] = 1 NEW_LINE num = int ( num \/ 10 ) NEW_LINE DEDENT DEDENT longest = - sys . maxsize - 1 NEW_LINE count = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT if ( hash [ i ] [ j ] and hash [ i + 1 ] [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( j == 10 ) : NEW_LINE INDENT longest = max ( longest , count + 1 ) NEW_LINE count = 0 NEW_LINE DEDENT DEDENT longest = max ( longest , count + 1 ) NEW_LINE return longest NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 11 , 22 , 33 , 44 , 54 , 56 , 63 ] NEW_LINE n = len ( a ) NEW_LINE print ( longestSubarray ( a , n ) ) NEW_LINE DEDENT"],"bleu":0.7099371493861247,"rouge_l":0.8038562907476765}
{"id":1112,"predictions":["def find_ solution ( x , n ) : NEW_LINE INDENT sm = x NEW_LINE e = 2 NEW_LINE o = 1 NEW_LINE p = 1 NEW_LINE e = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT p += 2 NEW_LINE sm += ( p \/ e ) * ( e + 2 ) NEW_LINE DEDENT e = e * ( e + 2 ) \/ p NEW_LINE if ( abs ( x ) >= 1 ) : NEW_LINE INDENT print ( \" Invalid ▁ Input \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Invalid ▁ Input \" ) NEW_LINE DEDENT DEDENT x = - 0.5 NEW_LINE n = 8 NEW_LINE find_ solution ( x , n ) NEW_LINE"],"references":["def find_Solution ( x , n ) : NEW_LINE INDENT Sum = x NEW_LINE e = 2 NEW_LINE o = 1 NEW_LINE p = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT p += 2 NEW_LINE Sum += ( o \/ e ) * ( pow ( x , p ) \/ p ) NEW_LINE o = o * ( o + 2 ) NEW_LINE e = e * ( e + 2 ) NEW_LINE DEDENT print ( round ( Sum , 10 ) ) NEW_LINE DEDENT x = - 0.5 NEW_LINE if ( abs ( x ) >= 1 ) : NEW_LINE INDENT print ( \" Invalid ▁ Input \\n \" ) NEW_LINE DEDENT n = 8 NEW_LINE find_Solution ( x , n ) NEW_LINE"],"bleu":0.6674595990264073,"rouge_l":0.7177359425315829}
{"id":1113,"predictions":["def replaceOriginalOriginal ( s , n ) : NEW_LINE INDENT r = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT r = ord ( s [ n - 1 ] ) NEW_LINE if ( ord ( s [ i ] ) != ord ( ' a ' and ord ( s [ i ] ) != ord ( ' a ' ) and ord ( s [ i ] ) != ord ( ' a ' ) and ord ( s [ i ] ) != ord ( ' z ' ) and ord ( s [ i ] ) != ord ( ' a ' ) and ord ( s [ i ] ) != ord ( ' A ' ) and ord ( s [ i ] ) != ord ( ' z ' ) and ord ( s [ i ] ) != ord ( ' a ' ) and s [ ord ( s [ i ] ) - ord ( ' z ' ) ] ) : NEW_LINE INDENT print ( r \" , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" geeksforgeeks \" NEW_LINE n = len ( s ) NEW_LINE replaceOriginal ( s , n ) NEW_LINE DEDENT"],"references":["def replaceOriginal ( s , n ) : NEW_LINE INDENT r = [ ' ▁ ' ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT r [ i ] = s [ n - 1 - i ] NEW_LINE if ( s [ i ] != ' a ' and s [ i ] != ' e ' and s [ i ] != ' i ' and s [ i ] != ' o ' and s [ i ] != ' u ' ) : NEW_LINE INDENT print ( r [ i ] , end = \" \" ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" geeksforgeeks \" NEW_LINE n = len ( s ) NEW_LINE replaceOriginal ( s , n ) NEW_LINE DEDENT"],"bleu":0.40613997840015115,"rouge_l":0.6993139555876513}
{"id":1114,"predictions":["def SieveOfEratosthenes ( prime , p_size ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , p_size + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( 2 * p_size + p_size , p_size ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def xorOfPrime ( s ) : NEW_LINE INDENT prime = [ True ] * 100005 NEW_LINE SieveOfEratosthenes ( prime , p_size ) NEW_LINE m = len ( s ) NEW_LINE for i in range ( 0 , len ( s ) , 1 ) : NEW_LINE INDENT if prime [ s [ i ] ] : NEW_LINE INDENT m [ s [ i ] ] = False NEW_LINE DEDENT DEDENT result = 0 NEW_LINE flag = 0 NEW_LINE for i in range ( 0 , len ( m ) ) : NEW_LINE INDENT if ( prime [ m [ i ] ] ) : NEW_LINE INDENT result ^= m [ i ] NEW_LINE flag = 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if ( flag ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT result = 0 NEW_LINE flag = 0 NEW_LINE for it in result : NEW_LINE INDENT if ( prime [ it ] ) : NEW_LINE INDENT result ^= m [ it ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = list ( ) NEW_LINE print ( xorPrime ( s ) ) NEW_LINE DEDENT"],"references":["from collections import defaultdict NEW_LINE def SieveOfEratosthenes ( prime , p_size ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= p_size : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT for i in range ( p * 2 , p_size + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT def xorOfPrime ( s ) : NEW_LINE INDENT prime = [ True ] * 100005 NEW_LINE SieveOfEratosthenes ( prime , 10005 ) NEW_LINE m = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT m [ s [ i ] ] += 1 NEW_LINE DEDENT result = flag = 0 NEW_LINE for it in m : NEW_LINE INDENT if prime [ m [ it ] ] : NEW_LINE INDENT result ^= m [ it ] NEW_LINE flag = 1 NEW_LINE DEDENT DEDENT if not flag : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" gggggeeekkkks \" NEW_LINE print ( xorOfPrime ( s ) ) NEW_LINE DEDENT"],"bleu":0.5806009135515922,"rouge_l":0.7596257404415724}
{"id":1115,"predictions":["def findNumbers ( N , d ) : NEW_LINE INDENT for i in range ( N - 2 ) : NEW_LINE INDENT print ( \"1\" , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 3 NEW_LINE D = 5 NEW_LINE findNumbers ( N , D ) NEW_LINE DEDENT"],"references":["def pattern ( n , d ) : NEW_LINE INDENT for i in range ( 0 , n - 2 ) : NEW_LINE INDENT print ( \"1\" , end = \" ▁ \" ) NEW_LINE DEDENT print ( \"2\" , end = \" ▁ \" ) NEW_LINE print ( n + d ) NEW_LINE DEDENT N = 3 NEW_LINE D = 5 NEW_LINE pattern ( N , D ) NEW_LINE"],"bleu":0.606149760021055,"rouge_l":0.7227488151658769}
{"id":1116,"predictions":["PI = 3 ; NEW_LINE def cos ( x , val , x ) : NEW_LINE INDENT global PI , data NEW_LINE x = ( x * val ) \/ 180.0 NEW_LINE res = cos ( x * val ) NEW_LINE return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = 90 NEW_LINE print ( \" The ▁ cosi ▁ of \" , x ) NEW_LINE print ( \" The ▁ sin ▁ of \" , x , \" is \" , cos ( x ) ) NEW_LINE DEDENT"],"references":["import math NEW_LINE if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT PI = 3.14159265 NEW_LINE x = 60.0 NEW_LINE val = PI \/ 180.0 NEW_LINE ret = math . cos ( x * val ) NEW_LINE print ( \" The ▁ cosine ▁ of ▁ is ▁ \" , x , end = \" ▁ \" ) NEW_LINE print ( \" ▁ degrees \" , ret ) NEW_LINE x = 90.0 NEW_LINE val = PI \/ 180.0 NEW_LINE ret = math . cos ( x * val ) NEW_LINE print ( \" The ▁ cosine ▁ of ▁ is ▁ \" , x , end = \" ▁ \" ) NEW_LINE print ( \" degrees \" , ret ) NEW_LINE DEDENT"],"bleu":0.28834681125226247,"rouge_l":0.445319209848268}
{"id":1117,"predictions":["import numpy as np NEW_LINE N = 1000000 NEW_LINE dp = np . zeros ( ( N , N ) ) ; NEW_LINE v = np . zeros ( ( N , N ) ) ; NEW_LINE def findSum ( arr , k , l , r , r ) : NEW_LINE INDENT if ( l == r ) : NEW_LINE INDENT return arr [ l ] ; NEW_LINE DEDENT if ( dp [ l ] [ r ] == k ) : NEW_LINE INDENT return dp [ l ] [ r ] ; NEW_LINE DEDENT if ( v [ l ] [ r ] == 1 ) : NEW_LINE INDENT return dp [ l ] [ r ] ; NEW_LINE DEDENT dp [ l ] [ r ] = 1 ; NEW_LINE dp [ l ] [ r ] = 1 ; NEW_LINE return dp [ l ] [ r ] ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 100010 ] ; NEW_LINE k = 2 ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( findSum ( arr , n , k - 1 , l , r - 1 ) ) ; NEW_LINE DEDENT"],"references":["import numpy as np NEW_LINE N = 100 NEW_LINE INF = 1000000 NEW_LINE dp = np . zeros ( ( N , N ) ) ; NEW_LINE vis = np . zeros ( ( N , N ) ) ; NEW_LINE def findSum ( arr , n , k , l , r ) : NEW_LINE INDENT if ( ( l ) + ( n - 1 - r ) == k ) : NEW_LINE INDENT return arr [ r ] - arr [ l ] ; NEW_LINE DEDENT if ( vis [ l ] [ r ] ) : NEW_LINE INDENT return dp [ l ] [ r ] ; NEW_LINE DEDENT vis [ l ] [ r ] = 1 ; NEW_LINE dp [ l ] [ r ] = min ( findSum ( arr , n , k , l , r - 1 ) , findSum ( arr , n , k , l + 1 , r ) ) ; NEW_LINE return dp [ l ] [ r ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 100 , 120 , 140 ] ; NEW_LINE k = 2 ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( findSum ( arr , n , k , 0 , n - 1 ) ) ; NEW_LINE DEDENT"],"bleu":0.6893537670772277,"rouge_l":0.7821639533208472}
{"id":1118,"predictions":["def totalPairs ( s1 , s2 , s3 ) : NEW_LINE INDENT count = 0 NEW_LINE arr1 = [ 0 ] * 7 NEW_LINE arr2 = [ 0 ] * 7 NEW_LINE for i in range ( 0 , len ( s1 ) ) : NEW_LINE INDENT set_bits [ ord ( s1 [ i ] ) ] += 1 NEW_LINE DEDENT for i in range ( 1 , len ( s2 ) ) : NEW_LINE INDENT set_bits [ ord ( s2 [ i ] ) ] += 1 NEW_LINE DEDENT for i in range ( 1 , 6 ) : NEW_LINE INDENT count += ( arr1 [ i ] * arr2 [ i ] ) NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s1 = \" geeks \" NEW_LINE s2 = \" ide \" NEW_LINE print ( totalPairs ( s1 , s2 ) ) NEW_LINE DEDENT"],"references":["def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT count += n & 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def totalPairs ( s1 , s2 ) : NEW_LINE INDENT count = 0 ; NEW_LINE arr1 = [ 0 ] * 7 ; arr2 = [ 0 ] * 7 ; NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT set_bits = countSetBits ( ord ( s1 [ i ] ) ) NEW_LINE arr1 [ set_bits ] += 1 ; NEW_LINE DEDENT for i in range ( len ( s2 ) ) : NEW_LINE INDENT set_bits = countSetBits ( ord ( s2 [ i ] ) ) ; NEW_LINE arr2 [ set_bits ] += 1 ; NEW_LINE DEDENT for i in range ( 1 , 7 ) : NEW_LINE INDENT count += ( arr1 [ i ] * arr2 [ i ] ) ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s1 = \" geeks \" ; NEW_LINE s2 = \" forgeeks \" ; NEW_LINE print ( totalPairs ( s1 , s2 ) ) ; NEW_LINE DEDENT"],"bleu":0.5539469020599309,"rouge_l":0.7778845314001221}
{"id":1119,"predictions":["def minOperations ( n ) : NEW_LINE INDENT count = 0 NEW_LINE d = 0 NEW_LINE d = 0 NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( n > 9 ) : NEW_LINE INDENT d = max ( n % 10 , d ) NEW_LINE n \/\/= 10 NEW_LINE d += 10 NEW_LINE DEDENT d = max ( d , n - 1 ) NEW_LINE count += 10 NEW_LINE return count - 1 NEW_LINE DEDENT n = 240 NEW_LINE print ( minOperations ( n ) ) NEW_LINE"],"references":["def minOperations ( n ) : NEW_LINE INDENT count = 0 NEW_LINE d = 0 NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( n > 9 ) : NEW_LINE INDENT d = max ( n % 10 , d ) NEW_LINE n \/\/= 10 NEW_LINE count += 10 NEW_LINE DEDENT d = max ( d , n - 1 ) NEW_LINE count += abs ( d ) NEW_LINE return count - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 240 NEW_LINE print ( minOperations ( n ) ) NEW_LINE DEDENT"],"bleu":0.7857464149150951,"rouge_l":0.8668369790835064}
{"id":1120,"predictions":["def myCopy ( s1 , s2 ) : NEW_LINE INDENT for i in range ( len ( s1 ) ) : NEW_LINE INDENT s2 [ i ] , s1 [ i ] = s1 [ i ] , s2 [ i ] NEW_LINE DEDENT DEDENT s1 = \" GEEKS \" NEW_LINE s2 = \" GEEKSFORGEEKS \" NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT print ( s1 [ i ] , end = \" \" ) NEW_LINE DEDENT"],"references":["def myCopy ( s1 , s2 ) : NEW_LINE INDENT for i in range ( len ( s1 ) ) : NEW_LINE INDENT s2 [ i ] = s1 [ i ] ; NEW_LINE DEDENT DEDENT s1 = \" GEEKSFORGEEKS \" ; NEW_LINE s2 = [ ' ' ] * ( len ( s1 ) ) ; NEW_LINE myCopy ( s1 , s2 ) ; NEW_LINE print ( ( \" \" . join ( s2 ) ) ) ; NEW_LINE"],"bleu":0.5633688795607795,"rouge_l":0.6859437751004015}
{"id":1121,"predictions":["def bitonicGenerator ( arr , n ) : NEW_LINE INDENT evenArr = [ ] NEW_LINE oddArr = [ ] NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( i % 2 != 1 ) : NEW_LINE INDENT evenArr . append ( arr [ i ] ) NEW_LINE evenArr . append ( arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT oddArr . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT evenArr . sort ( reverse = True ) NEW_LINE for i in range ( 0 , len ( evenArr ) ) : NEW_LINE INDENT arr [ i ] = evenArr [ i ] NEW_LINE oddArr [ j ] = oddArr [ i ] NEW_LINE DEDENT for i in range ( 0 , len ( oddArr ) ) : NEW_LINE INDENT arr [ i ] = oddArr [ i ] NEW_LINE DEDENT DEDENT def bitonicGenerator ( arr , n ) : NEW_LINE for i in range ( 0 , len ( oddArr ) ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 5 , 8 , 9 , 6 , 7 , 3 , 0 , 2 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE bitonicGenerator ( arr , n ) NEW_LINE DEDENT"],"references":["def bitonicGenerator ( arr , n ) : NEW_LINE INDENT evenArr = [ ] NEW_LINE oddArr = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( i % 2 ) == 0 ) : NEW_LINE INDENT evenArr . append ( arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT oddArr . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT evenArr = sorted ( evenArr ) NEW_LINE oddArr = sorted ( oddArr ) NEW_LINE oddArr = oddArr [ : : - 1 ] NEW_LINE i = 0 NEW_LINE for j in range ( len ( evenArr ) ) : NEW_LINE INDENT arr [ i ] = evenArr [ j ] NEW_LINE i += 1 NEW_LINE DEDENT for j in range ( len ( oddArr ) ) : NEW_LINE INDENT arr [ i ] = oddArr [ j ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT arr = [ 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE bitonicGenerator ( arr , n ) NEW_LINE for i in arr : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT"],"bleu":0.6282873191795334,"rouge_l":0.6993179509505151}
{"id":1122,"predictions":["def ReverseChar ( n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT j = ' A ' NEW_LINE for j in range ( ord ( ' A ' ) , ord ( ' A ' ) + i ) - 1 NEW_LINE if ( j >= ( ord ( ' A ' ) + n - 1 ) - i ) : NEW_LINE INDENT print ( chr ( ord ( ' A ' ) + i ) , end = ' ' ) NEW_LINE DEDENT elif ( j <= ( ord ( ' A ' ) + i ) - ord ( ' A ' ) ) ) : NEW_LINE INDENT print ( chr ( ord ( ' A ' ) + n - 1 ) , end = ' ▁ ' ) NEW_LINE DEDENT elif ( j <= ( n - 1 ) ) : NEW_LINE INDENT print ( chr ( ord ( ' A ' ) + i ) , end = ' ▁ ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( chr ( ord ( ' A ' ) + i ) , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 6 NEW_LINE ReverseChar ( n ) NEW_LINE DEDENT"],"references":["def ReverseCharBridge ( n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( ord ( ' A ' ) , ord ( ' A ' ) + ( 2 * n ) - 1 ) : NEW_LINE INDENT if j >= ( ord ( ' A ' ) + n - 1 ) + i : NEW_LINE INDENT print ( chr ( ( ord ( ' A ' ) + n - 1 ) - ( j % ( ord ( ' A ' ) + n - 1 ) ) ) , end = ' ' ) NEW_LINE DEDENT elif j <= ( ord ( ' A ' ) + n - 1 ) - i : NEW_LINE INDENT print ( chr ( j ) , end = ' ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( end = \" ▁ \" ) NEW_LINE DEDENT DEDENT print ( \" \\n \" , end = ' ' ) NEW_LINE DEDENT DEDENT n = 6 NEW_LINE ReverseCharBridge ( n ) NEW_LINE"],"bleu":0.5580565049439141,"rouge_l":0.7125821367729376}
{"id":1123,"predictions":["n = 4 NEW_LINE m = 4 NEW_LINE def calcProbability ( M , n ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE sum = [ [ 0 for x in range ( m ) ] for i in range ( n ) ] NEW_LINE for j in range ( m ) : NEW_LINE INDENT dp [ 0 ] [ j ] = M [ j ] [ j ] NEW_LINE sum [ i ] [ j ] = ( sum [ i - 1 ] [ j ] + dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT return dp [ n - 1 ] [ k - 1 ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT M = [ [ 1 , 1 , 0 ] , [ 2 , 3 , 2 ] , [ 9 , 3 , 2 ] ] NEW_LINE k = 3 NEW_LINE print ( calcProbability ( M , k ) ) NEW_LINE DEDENT"],"references":["n = 4 NEW_LINE m = 4 NEW_LINE def calcProbability ( M , k ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( m ) ] NEW_LINE Sum = [ 0 for i in range ( n ) ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT dp [ 0 ] [ j ] = M [ 0 ] [ j ] NEW_LINE Sum [ 0 ] += dp [ 0 ] [ j ] NEW_LINE DEDENT for i in range ( 1 , m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT dp [ i ] [ j ] += ( dp [ i - 1 ] [ j ] \/ Sum [ i - 1 ] + M [ i ] [ j ] ) NEW_LINE Sum [ i ] += dp [ i ] [ j ] NEW_LINE DEDENT DEDENT return dp [ n - 1 ] [ k - 1 ] \/ Sum [ n - 1 ] NEW_LINE DEDENT M = [ [ 1 , 1 , 0 , 3 ] , [ 2 , 3 , 2 , 3 ] , [ 9 , 3 , 0 , 2 ] , [ 2 , 3 , 2 , 2 ] ] NEW_LINE k = 3 NEW_LINE print ( calcProbability ( M , k ) ) NEW_LINE"],"bleu":0.7158356931218761,"rouge_l":0.7457929802871077}
{"id":1124,"predictions":["def largestSubset ( a , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE dp = [ 0 ] * n NEW_LINE dp [ n - 1 ] = 1 NEW_LINE for i in range ( n - 2 , - 1 , - 1 , - 1 ) : NEW_LINE INDENT mx = 0 NEW_LINE for j in range ( i + 1 , n , 1 ) : NEW_LINE INDENT if ( a [ j ] % a [ i ] == 0 ) : NEW_LINE INDENT mx = max ( mx , dp [ i ] ) NEW_LINE DEDENT DEDENT dp [ i ] = 1 + mx NEW_LINE DEDENT DEDENT return max ( dp ) NEW_LINE DEDENT a = [ 1 , 3 , 6 , 13 , 17 , 18 ] NEW_LINE n = len ( a ) NEW_LINE print ( largestSubset ( a , n ) ) NEW_LINE"],"references":["def largestSubset ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE dp = [ 0 for i in range ( n ) ] NEW_LINE dp [ n - 1 ] = 1 ; NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT mxm = 0 ; NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if a [ j ] % a [ i ] == 0 : NEW_LINE INDENT mxm = max ( mxm , dp [ j ] ) NEW_LINE DEDENT DEDENT dp [ i ] = 1 + mxm NEW_LINE DEDENT return max ( dp ) NEW_LINE DEDENT a = [ 1 , 3 , 6 , 13 , 17 , 18 ] NEW_LINE n = len ( a ) NEW_LINE print ( largestSubset ( a , n ) ) NEW_LINE"],"bleu":0.7743257782039995,"rouge_l":0.9008438818565402}
{"id":1125,"predictions":["def findLargest ( N , c ) : NEW_LINE INDENT smallest = '1' + str ( N - 1 ) ; NEW_LINE return smallest ; NEW_LINE DEDENT def findLargest ( N , c ) : NEW_LINE INDENT temp = \" \" ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT temp += c [ 0 ] ; NEW_LINE DEDENT return temp ; NEW_LINE DEDENT def printLargest ( N , c ) : NEW_LINE INDENT print ( \" Largest : ▁ \" , findLargest ( N , c ) ) ; NEW_LINE print ( \" Smallest : ▁ \" , findLargest ( N , c ) ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 4 ; NEW_LINE findLargest ( N ) ; NEW_LINE printLargest ( N , N ) ; NEW_LINE DEDENT"],"references":["def findLargest ( N ) : NEW_LINE INDENT largest = strings ( N , '7' ) ; NEW_LINE return largest ; NEW_LINE DEDENT def findSmallest ( N ) : NEW_LINE INDENT smallest = \"1\" + strings ( ( N - 1 ) , '0' ) ; NEW_LINE return smallest ; NEW_LINE DEDENT def strings ( N , c ) : NEW_LINE INDENT temp = \" \" ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT temp += c ; NEW_LINE DEDENT return temp ; NEW_LINE DEDENT def printLargestSmallest ( N ) : NEW_LINE INDENT print ( \" Largest : ▁ \" , findLargest ( N ) ) ; NEW_LINE print ( \" Smallest : ▁ \" , findSmallest ( N ) ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 ; NEW_LINE printLargestSmallest ( N ) ; NEW_LINE DEDENT"],"bleu":0.6612663354208066,"rouge_l":0.7948100295631226}
{"id":1126,"predictions":["def findMaxNum ( arr , n ) : NEW_LINE INDENT hash = [ 0 for i in range ( 10 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( 9 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( hash [ i ] , - 1 , - 1 ) : NEW_LINE INDENT print ( i , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 0 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE findMaxNum ( arr , n ) NEW_LINE DEDENT"],"references":["def findMaxNum ( arr , n ) : NEW_LINE INDENT hash = [ 0 ] * 10 NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( 9 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( hash [ i ] ) : NEW_LINE INDENT print ( i , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE findMaxNum ( arr , n ) NEW_LINE DEDENT"],"bleu":0.8259057773473035,"rouge_l":0.9284276729559748}
{"id":1127,"predictions":["n = input ( ) NEW_LINE ans = \" No \" NEW_LINE if ( n != 0 ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def countDigits ( n ) : NEW_LINE INDENT c = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT c += 1 NEW_LINE n = int ( n \/ 10 ) NEW_LINE DEDENT return c NEW_LINE DEDENT def isDeserium ( x ) : NEW_LINE INDENT temp = x NEW_LINE p = countDigits ( x ) NEW_LINE sum = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT digit = int ( x % 10 ) NEW_LINE sum += pow ( digit , p ) NEW_LINE p -= 1 NEW_LINE x = int ( x \/ 10 ) NEW_LINE DEDENT return ( sum == temp ) NEW_LINE DEDENT x = 135 NEW_LINE if ( isDeserium ( x ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.05956022185635147,"rouge_l":0.3321056845476381}
{"id":1128,"predictions":["def polyarea ( r , n ) : NEW_LINE INDENT if ( r < 0 and n < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT A = ( r * r * n ) NEW_LINE return A NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT r = 9 NEW_LINE n = 6 NEW_LINE print ( polyarea ( n , r ) ) NEW_LINE DEDENT"],"references":["from math import sin NEW_LINE def polyarea ( n , r ) : NEW_LINE INDENT if ( r < 0 and n < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT A = ( ( ( r * r * n ) * sin ( ( 360 \/ n ) * 3.14159 \/ 180 ) ) \/ 2 ) ; NEW_LINE return round ( A , 3 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT r , n = 9 , 6 NEW_LINE print ( polyarea ( n , r ) ) NEW_LINE DEDENT"],"bleu":0.5537499793344726,"rouge_l":0.7524132999642474}
{"id":1129,"predictions":["def smallestSumSubarr ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT arr [ i ] = - arr [ i ] NEW_LINE sum_element = arr [ 0 ] NEW_LINE max_element = arr [ 0 ] NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT sum_element = max ( sum_element , arr [ i ] ) NEW_LINE max_element = max ( max_element , sum_element ) NEW_LINE DEDENT return ( - 1 ) * max_element NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , - 4 , 2 , - 3 , - 1 , 7 , - 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Smallest ▁ sum ▁ : ▁ \" , smallestSumSubarr ( arr , n ) ) NEW_LINE DEDENT"],"references":["def smallestSumSubarr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = - arr [ i ] NEW_LINE DEDENT sum_here = arr [ 0 ] NEW_LINE max_sum = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT sum_here = max ( sum_here + arr [ i ] , arr [ i ] ) NEW_LINE max_sum = max ( max_sum , sum_here ) NEW_LINE DEDENT return ( - 1 ) * max_sum NEW_LINE DEDENT arr = [ 3 , - 4 , 2 , - 3 , - 1 , 7 , - 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Smallest ▁ sum : \" , smallestSumSubarr ( arr , n ) ) NEW_LINE"],"bleu":0.7028169660112104,"rouge_l":0.8645669291338582}
{"id":1130,"predictions":["def countSubtoL ( arr , n , x ) : NEW_LINE INDENT st = 0 NEW_LINE end = 0 NEW_LINE sum = 0 NEW_LINE cnt = 0 NEW_LINE while ( end < n ) : NEW_LINE INDENT sum += arr [ end ] NEW_LINE while ( st <= end and sum > x ) : NEW_LINE INDENT sum -= arr [ end ] NEW_LINE cnt += 1 NEW_LINE DEDENT cnt += 1 NEW_LINE end += 1 NEW_LINE DEDENT cnt += 1 NEW_LINE return cnt NEW_LINE DEDENT def findSubLtoR ( arr , n , L , R ) : NEW_LINE INDENT R = countSub ( arr , n , L - 1 ) NEW_LINE Lcnt = countSub ( arr , n , R ) NEW_LINE return R - Lcnt NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 4 , 6 ] NEW_LINE N = len ( arr ) NEW_LINE L , R = len ( arr ) NEW_LINE print ( findSubLToR ( arr , N , L , R ) ) NEW_LINE DEDENT"],"references":["def countSub ( arr , n , x ) : NEW_LINE INDENT st = 0 NEW_LINE end = 0 NEW_LINE sum = 0 NEW_LINE cnt = 0 NEW_LINE while end < n : NEW_LINE INDENT sum += arr [ end ] NEW_LINE while ( st <= end and sum > x ) : NEW_LINE INDENT sum -= arr [ st ] NEW_LINE st += 1 NEW_LINE DEDENT cnt += ( end - st + 1 ) NEW_LINE end += 1 NEW_LINE DEDENT return cnt NEW_LINE DEDENT def findSubSumLtoR ( arr , n , L , R ) : NEW_LINE INDENT Rcnt = countSub ( arr , n , R ) NEW_LINE Lcnt = countSub ( arr , n , L - 1 ) NEW_LINE return Rcnt - Lcnt NEW_LINE DEDENT arr = [ 1 , 4 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE L = 3 NEW_LINE R = 8 NEW_LINE print ( findSubSumLtoR ( arr , n , L , R ) ) NEW_LINE"],"bleu":0.6833845692747073,"rouge_l":0.8335829277424187}
{"id":1131,"predictions":["def minCost ( cost , m , z ) : NEW_LINE INDENT if ( x < y ) : NEW_LINE INDENT return z NEW_LINE DEDENT elif ( x < z ) : NEW_LINE INDENT return y NEW_LINE DEDENT elif ( y < z ) : NEW_LINE INDENT return z NEW_LINE DEDENT else : NEW_LINE INDENT return ( z + cost ) NEW_LINE DEDENT DEDENT def minCost ( cost , m , n ) : NEW_LINE INDENT i , j = 0 , 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT tc = ( cost [ i ] [ j - 1 ] , cost [ i ] [ j ] + cost [ i ] [ j ] , cost [ i ] [ j ] ) NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT tc [ i ] [ j ] = ( tc [ i - 1 ] [ j ] + cost [ i - 1 ] [ j ] ) NEW_LINE DEDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT tc [ i ] [ j ] = ( tc [ i - 1 ] [ j ] + cost [ i ] [ j ] ) NEW_LINE DEDENT DEDENT return tc [ n ] [ n ] NEW_LINE DEDENT cost = [ [ [ 1 , 2 , 3 ] , [ 4 , 8 , 2 ] ] NEW_LINE print ( minCost ( cost , 2 , 3 ) ) NEW_LINE"],"references":["R = 3 NEW_LINE C = 3 NEW_LINE def minCost ( cost , m , n ) : NEW_LINE INDENT tc = [ [ 0 for x in range ( C ) ] for x in range ( R ) ] NEW_LINE tc [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT tc [ i ] [ 0 ] = tc [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] NEW_LINE DEDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT tc [ 0 ] [ j ] = tc [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT tc [ i ] [ j ] = min ( tc [ i - 1 ] [ j - 1 ] , tc [ i - 1 ] [ j ] , tc [ i ] [ j - 1 ] ) + cost [ i ] [ j ] NEW_LINE DEDENT DEDENT return tc [ m ] [ n ] NEW_LINE DEDENT cost = [ [ 1 , 2 , 3 ] , [ 4 , 8 , 2 ] , [ 1 , 5 , 3 ] ] NEW_LINE print ( minCost ( cost , 2 , 2 ) ) NEW_LINE"],"bleu":0.6084441371088809,"rouge_l":0.6487433901728954}
{"id":1132,"predictions":["def msbPos ( n ) : NEW_LINE INDENT msb = - 1 NEW_LINE while n > 0 : NEW_LINE INDENT n = n >> 1 NEW_LINE msb_p += 1 NEW_LINE msb_p += 1 NEW_LINE DEDENT return msb_p \/\/ msb_p NEW_LINE DEDENT def and ( x ) : NEW_LINE INDENT res = 0 NEW_LINE while ( x > 0 and y > 0 ) : NEW_LINE INDENT msb_p = msbPos ( x ) NEW_LINE msb_p = msb_p ( x ) NEW_LINE if ( msb_p > msb_p ) : NEW_LINE INDENT break NEW_LINE DEDENT msb_p += 1 NEW_LINE DEDENT res = res + msb_p NEW_LINE x = x - msb_p NEW_LINE y = y - msb_p NEW_LINE return res NEW_LINE DEDENT x = 10 NEW_LINE y = 15 NEW_LINE print ( msbPos ( x , y ) ) NEW_LINE"],"references":["def msbPos ( n ) : NEW_LINE INDENT msb_p = - 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n = n >> 1 NEW_LINE msb_p += 1 NEW_LINE DEDENT return msb_p NEW_LINE DEDENT def andOperator ( x , y ) : NEW_LINE INDENT res = 0 NEW_LINE while ( x > 0 and y > 0 ) : NEW_LINE INDENT msb_p1 = msbPos ( x ) NEW_LINE msb_p2 = msbPos ( y ) NEW_LINE if ( msb_p1 != msb_p2 ) : NEW_LINE INDENT break NEW_LINE DEDENT msb_val = ( 1 << msb_p1 ) NEW_LINE res = res + msb_val NEW_LINE x = x - msb_val NEW_LINE y = y - msb_val NEW_LINE DEDENT return res NEW_LINE DEDENT x , y = 10 , 15 NEW_LINE print ( andOperator ( x , y ) ) NEW_LINE"],"bleu":0.6207630967991769,"rouge_l":0.810535057539447}
{"id":1133,"predictions":["from collections import defaultdict NEW_LINE class Graph : NEW_LINE INDENT def __init__ ( self , graph ) : NEW_LINE INDENT self . graph = defaultdict ( list ) NEW_LINE DEDENT def __init__ ( self , graph ) : NEW_LINE INDENT self . graph [ 0 ] . graph [ 1 ] . append ( 1 ) NEW_LINE DEDENT def dfs ( self , src , dest ) : NEW_LINE INDENT visited [ src ] = 1 NEW_LINE for i in graph [ src ] : NEW_LINE INDENT if i != src : NEW_LINE INDENT self . graph [ i ] . graph [ src ] . graph [ i ] . graph [ src ] . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT self . graph [ i ] . graph [ src ] . append ( src ) NEW_LINE DEDENT DEDENT DEDENT def findMaxEdges ( self , n ) : NEW_LINE INDENT return self . graph [ n ] NEW_LINE DEDENT def findMaxEdges ( self , n ) : NEW_LINE INDENT dfs ( self . graph , 1 ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT self . graph [ i ] . graph [ i ] . graph [ i ] . append ( i ) NEW_LINE DEDENT DEDENT def findMaxEdges ( self , n ) : NEW_LINE INDENT for i in range ( n + 1 ) : NEW_LINE INDENT graph [ i ] . graph [ j ] . graph [ i ] . graph [ j ] . graph [ i ] . graph [ j ] . graph [ j ] . graph [ i ] . graph [ j ] ] . graph [ i ] . graph [ j ] . graph [ i ] . graph [ j ] . graph [ j ] . graph [ i ] . graph [ j ] . graph [ i ] . graph [ j ] . graph [ i ] . graph [ j ] . graph [ j ] . graph [ i ] . graph [ j ] . graph [ i ] . graph [ i ] . graph [ j ] . graph [ i ] ] . graph [ j ] . graph [ i ] . graph [ j ] . graph [ i ] . graph [ i ] . graph [ j ] . graph ["],"references":["def dfs ( adj , node , parent , color ) : NEW_LINE INDENT count_color [ color ] += 1 NEW_LINE for i in range ( len ( adj [ node ] ) ) : NEW_LINE INDENT if ( adj [ node ] [ i ] != parent ) : NEW_LINE INDENT dfs ( adj , adj [ node ] [ i ] , node , not color ) NEW_LINE DEDENT DEDENT DEDENT def findMaxEdges ( adj , n ) : NEW_LINE INDENT dfs ( adj , 1 , 0 , 0 ) NEW_LINE return ( count_color [ 0 ] * count_color [ 1 ] - ( n - 1 ) ) NEW_LINE DEDENT count_color = [ 0 , 0 ] NEW_LINE n = 5 NEW_LINE adj = [ [ ] for i in range ( n + 1 ) ] NEW_LINE adj [ 1 ] . append ( 2 ) NEW_LINE adj [ 1 ] . append ( 3 ) NEW_LINE adj [ 2 ] . append ( 4 ) NEW_LINE adj [ 3 ] . append ( 5 ) NEW_LINE print ( findMaxEdges ( adj , n ) ) NEW_LINE"],"bleu":0.1518193941032445,"rouge_l":0.31587828009542096}
{"id":1134,"predictions":["def steps ( string , n ) : NEW_LINE INDENT flag = False NEW_LINE x = 0 NEW_LINE for i in range ( 0 , len ( string ) ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT flag = True NEW_LINE DEDENT if ( x == n - 1 ) : NEW_LINE INDENT flag = False NEW_LINE DEDENT if ( flag == True ) : NEW_LINE INDENT x += 1 NEW_LINE DEDENT DEDENT for j in range ( 0 , x ) : NEW_LINE INDENT if ( flag == False ) : NEW_LINE INDENT x += 1 NEW_LINE DEDENT else : NEW_LINE INDENT x -= 1 NEW_LINE DEDENT DEDENT DEDENT return x NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT string = \" GeeksForGeeks \" NEW_LINE string = \" GeeksforGeeks \" NEW_LINE n = 4 NEW_LINE steps ( string , n ) NEW_LINE print ( \" Max ▁ of ▁ heights ▁ = \" , steps ( string , n ) ) NEW_LINE DEDENT"],"references":["import math as mt NEW_LINE def steps ( string , n ) : NEW_LINE INDENT flag = False NEW_LINE x = 0 NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT flag = True NEW_LINE DEDENT if ( x == n - 1 ) : NEW_LINE INDENT flag = False NEW_LINE DEDENT for j in range ( x ) : NEW_LINE INDENT print ( \" * \" , end = \" \" ) NEW_LINE DEDENT print ( string [ i ] ) NEW_LINE if ( flag == True ) : NEW_LINE INDENT x += 1 NEW_LINE DEDENT else : NEW_LINE INDENT x -= 1 NEW_LINE DEDENT DEDENT DEDENT n = 4 NEW_LINE string = \" GeeksForGeeks \" NEW_LINE print ( \" String : ▁ \" , string ) NEW_LINE print ( \" Max ▁ Length ▁ of ▁ Steps : ▁ \" , n ) NEW_LINE steps ( string , n ) NEW_LINE"],"bleu":0.6677279088155288,"rouge_l":0.7264694583173261}
{"id":1135,"predictions":["def max_xor ( arr , n ) : NEW_LINE INDENT maxxor = 0 NEW_LINE vis = { } NEW_LINE se = set ( ) NEW_LINE for i in range ( 30 , n , - 1 ) : NEW_LINE INDENT global ma NEW_LINE se . add ( arr [ i ] ) NEW_LINE DEDENT for i in range ( 30 , n , 1 ) : NEW_LINE INDENT se . add ( arr [ i ] & mask ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 25 , 10 , 2 , 8 , 5 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( max_xor ( arr , n ) ) NEW_LINE DEDENT"],"references":["def max_xor ( arr , n ) : NEW_LINE INDENT maxx = 0 NEW_LINE mask = 0 ; NEW_LINE se = set ( ) NEW_LINE for i in range ( 30 , - 1 , - 1 ) : NEW_LINE INDENT mask |= ( 1 << i ) NEW_LINE newMaxx = maxx | ( 1 << i ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT se . add ( arr [ i ] & mask ) NEW_LINE DEDENT for prefix in se : NEW_LINE INDENT if ( newMaxx ^ prefix ) in se : NEW_LINE INDENT maxx = newMaxx NEW_LINE break NEW_LINE DEDENT DEDENT se . clear ( ) NEW_LINE DEDENT return maxx NEW_LINE DEDENT arr = [ 25 , 10 , 2 , 8 , 5 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( max_xor ( arr , n ) ) NEW_LINE"],"bleu":0.5595440235910171,"rouge_l":0.7013912843509256}
{"id":1136,"predictions":["N = 1000000007 ; NEW_LINE def exponentiation ( base , exp ) : NEW_LINE INDENT if ( exp % 2 != 0 ) : NEW_LINE INDENT t = ( t * base ) % N ; NEW_LINE DEDENT DEDENT return t = 5 ; NEW_LINE def exponentiation ( base , exp ) : NEW_LINE INDENT t = 1 ; NEW_LINE while ( exp & 1 ) : NEW_LINE INDENT if ( exp % 2 != 0 ) : NEW_LINE INDENT t = ( t * base ) % N ; NEW_LINE exp = ( base * base ) % N ; NEW_LINE DEDENT DEDENT return t ; NEW_LINE DEDENT base = 5 ; NEW_LINE exp = exponentiation ( base , exp ) ; NEW_LINE print ( modulo ( base , exp ) ) ; NEW_LINE"],"references":["N = 1000000007 ; NEW_LINE def exponentiation ( bas , exp ) : NEW_LINE INDENT t = 1 ; NEW_LINE while ( exp > 0 ) : NEW_LINE INDENT if ( exp % 2 != 0 ) : NEW_LINE INDENT t = ( t * bas ) % N ; NEW_LINE DEDENT bas = ( bas * bas ) % N ; NEW_LINE exp = int ( exp \/ 2 ) ; NEW_LINE DEDENT return t % N ; NEW_LINE DEDENT bas = 5 ; NEW_LINE exp = 100000 ; NEW_LINE modulo = exponentiation ( bas , exp ) ; NEW_LINE print ( modulo ) ; NEW_LINE"],"bleu":0.5270030533535544,"rouge_l":0.6752456067524562}
{"id":1137,"predictions":["def countMaxIntersect ( n ) : NEW_LINE INDENT return ( n * ( n - 1 ) ) \/\/ 2 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 8 NEW_LINE print ( countMaxIntersect ( n ) ) NEW_LINE DEDENT"],"references":["def countMaxIntersect ( n ) : NEW_LINE INDENT return int ( n * ( n - 1 ) \/ 2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 8 NEW_LINE print ( countMaxIntersect ( n ) ) NEW_LINE DEDENT"],"bleu":0.752148831164244,"rouge_l":0.9055330634278002}
{"id":1138,"predictions":["def printArr ( n , k , s ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( ) ; NEW_LINE DEDENT def findArray ( n , k , s ) : NEW_LINE INDENT v = [ 0 ] * n ; NEW_LINE cnt = 0 ; NEW_LINE arr = [ 0 ] ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ i ] = s [ i ] ; NEW_LINE cnt += 1 ; NEW_LINE DEDENT if ( s % 2 == 0 ) : NEW_LINE INDENT val += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT val += 2 ; NEW_LINE DEDENT if ( s % 2 == 0 ) : NEW_LINE INDENT val += 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT val += 2 ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( v [ i ] == 0 ) : NEW_LINE INDENT arr [ i ] = val ; NEW_LINE val += 2 ; NEW_LINE DEDENT DEDENT DEDENT printArray ( arr , n , k , s ) ; NEW_LINE"],"references":["def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT def findArray ( n , k , s ) : NEW_LINE INDENT vis = [ 0 ] * n ; NEW_LINE cnt = 0 ; NEW_LINE arr = [ 0 ] * n ; NEW_LINE i = 0 ; NEW_LINE while ( i < n and cnt < k ) : NEW_LINE INDENT arr [ i ] = s ; NEW_LINE vis [ i ] = 1 ; NEW_LINE cnt += 1 ; NEW_LINE i += 2 ; NEW_LINE DEDENT val = s ; NEW_LINE if ( s % 2 == 0 ) : NEW_LINE INDENT val += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT val = val + 2 ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( vis [ i ] == 0 ) : NEW_LINE INDENT arr [ i ] = val ; NEW_LINE DEDENT DEDENT printArr ( arr , n ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 8 ; k = 3 ; s = 12 ; NEW_LINE findArray ( n , k , s ) ; NEW_LINE DEDENT"],"bleu":0.6553286177783649,"rouge_l":0.7441237726867004}
{"id":1139,"predictions":["def modInverse ( a , m ) : NEW_LINE INDENT a = a % m NEW_LINE for x in range ( 1 , m ) : NEW_LINE INDENT if ( ( a * x ) % m == 1 ) : NEW_LINE INDENT return x NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 3 NEW_LINE m = 11 NEW_LINE print ( modInverse ( a , m ) ) NEW_LINE DEDENT"],"references":["def modInverse ( a , m ) : NEW_LINE INDENT a = a % m ; NEW_LINE for x in range ( 1 , m ) : NEW_LINE INDENT if ( ( a * x ) % m == 1 ) : NEW_LINE INDENT return x NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT a = 3 NEW_LINE m = 11 NEW_LINE print ( modInverse ( a , m ) ) NEW_LINE"],"bleu":0.7954640146970835,"rouge_l":0.9170962199312716}
{"id":1140,"predictions":["def countDistinct ( string ) : NEW_LINE INDENT counts = set ( ) NEW_LINE for i in range ( len ( string ) - 1 ) : NEW_LINE INDENT counts . add ( string [ i : i + 2 ] ) NEW_LINE DEDENT return len ( counts ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" Ucow \" NEW_LINE print ( countDistinct ( string ) ) NEW_LINE DEDENT"],"references":["def countDistinctCode ( string ) : NEW_LINE INDENT codes = set ( ) NEW_LINE for i in range ( 0 , len ( string ) - 1 ) : NEW_LINE INDENT codes . add ( string [ i : i + 2 ] ) NEW_LINE DEDENT return len ( codes ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" UPUP \" NEW_LINE print ( countDistinctCode ( string ) ) NEW_LINE DEDENT"],"bleu":0.7728360178757583,"rouge_l":0.9104477611940299}
{"id":1141,"predictions":["def OR ( a , n ) : NEW_LINE INDENT ans = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans |= a [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 4 , 6 ] NEW_LINE n = len ( a ) NEW_LINE print ( OR ( a , n ) ) NEW_LINE DEDENT"],"references":["def OR ( a , n ) : NEW_LINE INDENT ans = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans |= a [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 4 , 6 ] NEW_LINE n = len ( a ) NEW_LINE print ( OR ( a , n ) ) NEW_LINE DEDENT"],"bleu":0.9378353695158735,"rouge_l":0.975609756097561}
{"id":1142,"predictions":["def kthSmallest ( arr , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE return arr [ k - 1 ] NEW_LINE DEDENT arr = [ 12 , 3 , 5 , 7 , 19 ] NEW_LINE k = 2 NEW_LINE print ( \" KthSmallest ( arr , k ) ) NEW_LINE"],"references":["def kthSmallest ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE return arr [ k - 1 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 12 , 3 , 5 , 7 , 19 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE print ( \" K ' th ▁ smallest ▁ element ▁ is \" , kthSmallest ( arr , n , k ) ) NEW_LINE DEDENT"],"bleu":0.45006132449272146,"rouge_l":0.7043572984749457}
{"id":1143,"predictions":["def findOddPair ( A , N ) : NEW_LINE INDENT oddPair = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( ( A [ i ] ^ A [ j ] ) % 2 != 0 ) : NEW_LINE INDENT oddPair += 1 NEW_LINE DEDENT DEDENT DEDENT return oddPair NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 5 , 4 , 7 , 2 , 1 ] NEW_LINE N = len ( A ) NEW_LINE print ( findOddPair ( A , N ) ) NEW_LINE DEDENT"],"references":["def findOddPair ( A , N ) : NEW_LINE INDENT oddPair = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( ( A [ i ] ^ A [ j ] ) % 2 != 0 ) : NEW_LINE INDENT oddPair += 1 NEW_LINE DEDENT DEDENT DEDENT return oddPair NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 5 , 4 , 7 , 2 , 1 ] NEW_LINE N = len ( A ) NEW_LINE print ( findOddPair ( A , N ) ) NEW_LINE DEDENT"],"bleu":0.969740778513838,"rouge_l":0.989840553125441}
{"id":1144,"predictions":["def ReplaceElements ( arr , n ) : NEW_LINE INDENT mp = { i : 0 for i in arr } NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = n - mp [ arr [ i ] ] + 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 5 , 2 , 2 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE ReplaceElements ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT"],"references":["def ReplaceElements ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] = mp . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = n - mp [ arr [ i ] ] NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 5 , 2 , 2 , 5 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE ReplaceElements ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT"],"bleu":0.7623559960362806,"rouge_l":0.8388138227908645}
{"id":1145,"predictions":["def combinationUtil ( arr , n , r , index , data ) : NEW_LINE INDENT if ( index == r ) : NEW_LINE INDENT for j in range ( r ) : NEW_LINE INDENT print ( data [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( \" \" ) NEW_LINE return NEW_LINE DEDENT if ( i >= n ) : NEW_LINE INDENT return NEW_LINE DEDENT data = arr [ index ] NEW_LINE combinationUtil ( arr , n , r , data , data , data + 1 , data ) NEW_LINE DEDENT def printCombination ( arr , n , r , index , data ) : NEW_LINE INDENT if ( index == r ) : NEW_LINE INDENT return NEW_LINE DEDENT data = arr [ index ] NEW_LINE combinationUtil ( arr , n , r , data , data , data , data + 1 , i + 1 , data + 1 , 0 ) NEW_LINE combinationUtil ( arr , n , r , data , data + 1 , i + 1 , data ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE r = 3 NEW_LINE combination ( arr , n , r , data ) NEW_LINE"],"references":["def printCombination ( arr , n , r ) : NEW_LINE INDENT data = [ 0 ] * r NEW_LINE combinationUtil ( arr , n , r , 0 , data , 0 ) NEW_LINE DEDENT def combinationUtil ( arr , n , r , index , data , i ) : NEW_LINE INDENT if ( index == r ) : NEW_LINE INDENT for j in range ( r ) : NEW_LINE INDENT print ( data [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE return NEW_LINE DEDENT if ( i >= n ) : NEW_LINE INDENT return NEW_LINE DEDENT data [ index ] = arr [ i ] NEW_LINE combinationUtil ( arr , n , r , index + 1 , data , i + 1 ) NEW_LINE combinationUtil ( arr , n , r , index , data , i + 1 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE r = 3 NEW_LINE n = len ( arr ) NEW_LINE printCombination ( arr , n , r ) NEW_LINE DEDENT"],"bleu":0.6801237057742261,"rouge_l":0.6550270442252625}
{"id":1146,"predictions":["def sieve ( maxm , prime ) : NEW_LINE INDENT prime [ 0 ] = prime [ 1 ] = 1 NEW_LINE for i in range ( 2 , maxm + 1 ) : NEW_LINE INDENT if prime [ i ] == 0 : NEW_LINE INDENT for j in range ( 2 * i , maxm + 1 , i ) : NEW_LINE INDENT prime [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT DEDENT def countPair ( a , n ) : NEW_LINE INDENT maxm = a [ 0 ] NEW_LINE prime = [ ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if prime [ i ] : NEW_LINE INDENT for j in range ( 2 * i , maxm + 1 , i ) : NEW_LINE INDENT prime [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT countPrimes = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if prime [ a [ i ] ] : NEW_LINE INDENT countPrimes += 1 NEW_LINE DEDENT DEDENT DEDENT return countPrimes NEW_LINE DEDENT arr = [ 2 , 3 , 5 , 4 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPair ( arr , n ) ) NEW_LINE"],"references":["def sieve ( maxm , prime ) : NEW_LINE INDENT prime [ 0 ] = prime [ 1 ] = 1 ; NEW_LINE i = 2 ; NEW_LINE while ( i * i <= maxm ) : NEW_LINE INDENT if ( prime [ i ] == 0 ) : NEW_LINE INDENT for j in range ( 2 * i , maxm + 1 , i ) : NEW_LINE INDENT prime [ j ] = 1 ; NEW_LINE DEDENT DEDENT i += 1 ; NEW_LINE DEDENT DEDENT def countPair ( a , n ) : NEW_LINE INDENT maxm = max ( a ) ; NEW_LINE prime = [ 0 ] * ( maxm + 1 ) ; NEW_LINE sieve ( maxm , prime ) ; NEW_LINE countPrimes = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ a [ i ] ] == 0 ) : NEW_LINE INDENT countPrimes += 1 ; NEW_LINE DEDENT DEDENT nonPrimes = n - countPrimes ; NEW_LINE pairswith1Prime = nonPrimes * countPrimes ; NEW_LINE pairsWith2Primes = ( countPrimes * ( countPrimes - 1 ) ) \/\/ 2 ; NEW_LINE return pairswith1Prime + pairsWith2Primes ; NEW_LINE DEDENT arr = [ 2 , 3 , 5 , 4 , 7 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( countPair ( arr , n ) ) ; NEW_LINE"],"bleu":0.5565825707536525,"rouge_l":0.7078528681944241}
{"id":1147,"predictions":["import math NEW_LINE def nextPerfectCube ( N ) : NEW_LINE INDENT nextN = math . floor ( math . floor ( N ) ) + 1 NEW_LINE return nextN * nextN NEW_LINE DEDENT N = 35 NEW_LINE print ( nextPerfectCube ( N ) ) NEW_LINE"],"references":["from math import * NEW_LINE def nextPerfectCube ( N ) : NEW_LINE INDENT nextN = floor ( N ** ( 1 \/ 3 ) ) + 1 NEW_LINE return nextN ** 3 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 35 NEW_LINE print ( nextPerfectCube ( n ) ) NEW_LINE DEDENT"],"bleu":0.4045438570585256,"rouge_l":0.6313546423135464}
{"id":1148,"predictions":["def reverse ( arr , n , k ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT left = i NEW_LINE right = min ( i + k - 1 , n - 1 ) NEW_LINE while ( left < right ) : NEW_LINE INDENT temp = arr [ left ] NEW_LINE arr [ right ] = arr [ right ] NEW_LINE arr [ left ] = arr [ right ] NEW_LINE left += 1 NEW_LINE right -= 1 NEW_LINE DEDENT while ( left < right ) : NEW_LINE INDENT temp = arr [ right ] NEW_LINE arr [ left ] = temp NEW_LINE left += 1 NEW_LINE right -= 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 7 , 8 ] NEW_LINE k = 3 NEW_LINE n = len ( arr ) NEW_LINE reverse ( arr , n , k ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT"],"references":["def reverse ( arr , n , k ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT left = i NEW_LINE right = min ( i + k - 1 , n - 1 ) NEW_LINE while ( left < right ) : NEW_LINE INDENT arr [ left ] , arr [ right ] = arr [ right ] , arr [ left ] NEW_LINE left += 1 ; NEW_LINE right - + 1 NEW_LINE DEDENT i += k NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ] NEW_LINE k = 3 NEW_LINE n = len ( arr ) NEW_LINE reverse ( arr , n , k ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT"],"bleu":0.6295768192804225,"rouge_l":0.8074951058077747}
{"id":1149,"predictions":["def printChar ( string , n ) : NEW_LINE INDENT freq = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( string [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( freq [ ord ( string [ i ] ) - ord ( ' a ' ) ] % 2 == 1 ) : NEW_LINE INDENT print ( string [ i ] , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeksforgeeks \" NEW_LINE n = len ( str ) NEW_LINE printChar ( string , n ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE import math NEW_LINE def printChar ( str_ , n ) : NEW_LINE INDENT freq = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( str_ [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( freq [ ord ( str_ [ i ] ) - ord ( ' a ' ) ] ) % 2 == 1 : NEW_LINE INDENT print ( \" { } \" . format ( str_ [ i ] ) , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str_ = \" geeksforgeeks \" NEW_LINE n = len ( str_ ) NEW_LINE printChar ( str_ , n ) NEW_LINE DEDENT"],"bleu":0.7133156737139396,"rouge_l":0.8734090909090908}
{"id":1150,"predictions":["import sys NEW_LINE def isSafe ( x , y ) : NEW_LINE INDENT if ( x < 4 and y < 3 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( x == 4 and y == 3 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT diag = sys . maxsize NEW_LINE if ( isSafe ( x + 1 , y + 1 ) ) : NEW_LINE INDENT diag = minJump ( height , x + 1 , y ) + abs ( height - 1 ) NEW_LINE DEDENT down = sys . maxsize NEW_LINE if ( isSafe ( x + 1 , y + 1 ) ) : NEW_LINE INDENT down = minJump ( height , x + 1 , y ) + abs ( height [ x ] - height [ x + 1 ] ) NEW_LINE DEDENT right = sys . maxsize NEW_LINE if ( isSafe ( x , y + 1 ) ) : NEW_LINE INDENT down = minJump ( height , x + 1 , y + 1 ) NEW_LINE DEDENT right = sys . maxsize NEW_LINE if ( isSafe ( x + 1 , y + 1 ) ) : NEW_LINE INDENT right = minJump ( height , x + 1 , y + 1 ) NEW_LINE DEDENT right = sys . maxsize NEW_LINE DEDENT return minJump ( height , 0 , 0 , - 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT height = [ [ 5 , 4 , 2 ] NEW_LINE print ( minJump ( height , 0 , 0 ) ) NEW_LINE DEDENT"],"references":["R = 4 NEW_LINE C = 3 NEW_LINE def isSafe ( x , y ) : NEW_LINE INDENT return ( x < R and y < C ) NEW_LINE DEDENT def minJump ( height , x , y ) : NEW_LINE INDENT if ( x == R - 1 and y == C - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT diag = 10 ** 9 NEW_LINE if ( isSafe ( x + 1 , y + 1 ) ) : NEW_LINE INDENT diag = ( minJump ( height , x + 1 , y + 1 ) + abs ( height [ x ] [ y ] - height [ x + 1 ] [ y + 1 ] ) ) NEW_LINE DEDENT down = 10 ** 9 NEW_LINE if ( isSafe ( x + 1 , y ) ) : NEW_LINE INDENT down = ( minJump ( height , x + 1 , y ) + abs ( height [ x ] [ y ] - height [ x + 1 ] [ y ] ) ) NEW_LINE DEDENT right = 10 ** 9 NEW_LINE if ( isSafe ( x , y + 1 ) ) : NEW_LINE INDENT right = ( minJump ( height , x , y + 1 ) + abs ( height [ x ] [ y ] - height [ x ] [ y + 1 ] ) ) NEW_LINE DEDENT return min ( [ down , right , diag ] ) NEW_LINE DEDENT height = [ [ 5 , 4 , 2 ] , [ 9 , 2 , 1 ] , [ 2 , 5 , 9 ] , [ 1 , 3 , 11 ] ] NEW_LINE print ( minJump ( height , 0 , 0 ) ) NEW_LINE"],"bleu":0.5563307273247267,"rouge_l":0.6597021686201234}
{"id":1151,"predictions":["def segregate ( arr , size ) : NEW_LINE INDENT j = 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT if ( arr [ i ] <= size ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE arr [ j ] = arr [ i ] NEW_LINE arr [ j ] = temp NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return j NEW_LINE DEDENT def findMissing ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT x = abs ( arr [ i ] ) NEW_LINE if ( x - 1 < size and arr [ x ] > 0 ) : NEW_LINE INDENT arr [ x - 1 ] = - arr [ x ] NEW_LINE DEDENT DEDENT DEDENT def findMissingPositive ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT x = abs ( arr [ i ] ) NEW_LINE if ( x - 1 < size and arr [ x ] > 0 ) : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT return size + 1 NEW_LINE DEDENT def findMissing ( arr , size ) : NEW_LINE INDENT subset = arr [ 0 ] NEW_LINE for i in range ( size ) : NEW_LINE INDENT arr [ i ] = arr [ i ] NEW_LINE DEDENT for i in range ( size ) : NEW_LINE INDENT if ( arr [ i ] > 0 and arr [ i ] > 0 ) : NEW_LINE INDENT arr [ i ] , arr [ i ] = arr [ i ] , arr [ i ] NEW_LINE DEDENT DEDENT return findMissing ( arr , size ) NEW_LINE DEDENT arr = [ 0 , 10 , - 20 , - 20 ] NEW_LINE arr_size = len ( arr ) NEW_LINE missing = findMissing ( arr , arr_size ) NEW_LINE print ( \" The ▁ smallest ▁ positive \" , arr_size ) NEW_LINE"],"references":["def segregate ( arr , size ) : NEW_LINE INDENT j = 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT if ( arr [ i ] <= 0 ) : NEW_LINE INDENT arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return j NEW_LINE DEDENT def findMissingPositive ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT if ( abs ( arr [ i ] ) - 1 < size and arr [ abs ( arr [ i ] ) - 1 ] > 0 ) : NEW_LINE INDENT arr [ abs ( arr [ i ] ) - 1 ] = - arr [ abs ( arr [ i ] ) - 1 ] NEW_LINE DEDENT DEDENT for i in range ( size ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT return size + 1 NEW_LINE DEDENT def findMissing ( arr , size ) : NEW_LINE INDENT shift = segregate ( arr , size ) NEW_LINE return findMissingPositive ( arr [ shift : ] , size - shift ) NEW_LINE DEDENT arr = [ 0 , 10 , 2 , - 10 , - 20 ] NEW_LINE arr_size = len ( arr ) NEW_LINE missing = findMissing ( arr , arr_size ) NEW_LINE print ( \" The ▁ smallest ▁ positive ▁ missing ▁ number ▁ is ▁ \" , missing ) NEW_LINE"],"bleu":0.6257493842281536,"rouge_l":0.7266733156028369}
{"id":1152,"predictions":["from math import gcd NEW_LINE def minSteps ( k , d1 , d2 , x3 ) : NEW_LINE INDENT if ( d1 == 0 ) : NEW_LINE INDENT return d2 NEW_LINE DEDENT if ( ( k - d1 ) % gcd ( d1 , d2 ) ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT q = [ ] NEW_LINE while ( q [ 0 ] != 0 ) : NEW_LINE INDENT s = gcd ( d1 , d2 ) NEW_LINE if ( s == x1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( s != x + d2 ) : NEW_LINE INDENT q . append ( s ) NEW_LINE DEDENT visited . remove ( s ) NEW_LINE DEDENT if ( not visited [ 0 ] ) : NEW_LINE INDENT return len ( q ) NEW_LINE DEDENT if ( not visited [ 0 ] ) : NEW_LINE INDENT q . append ( s ) NEW_LINE visited [ 1 ] = 0 NEW_LINE DEDENT q . append ( s ) NEW_LINE DEDENT visited = [ 0 ] * ( k + d2 ) NEW_LINE return map ( int , input ( ) . split ( ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT k = 10 NEW_LINE d1 = [ 3 , 4 ] NEW_LINE if ( not __name__ == ' _ _ main _ _ \" ) : NEW_LINE INDENT k , d2 = [ 4 , 4 ] , [ 6 , 8 , 8 ] NEW_LINE if ( not __name__ == \" _ main _ _ \" : NEW_LINE INDENT k = 4 NEW_LINE d1 , k = 6 , 8 NEW_LINE if ( not __name__ == ' _ _ main _ _ \" ) : NEW_LINE INDENT k , d2 = 4 NEW_LINE print ( minSteps ( k , d1 , st2 , d2 , st1 , st2 , d3 ) NEW_LINE DEDENT DEDENT"],"references":["from math import gcd as __gcd NEW_LINE from collections import deque as queue NEW_LINE def minStepsNeeded ( k , d1 , d2 , x ) : NEW_LINE INDENT gcd = __gcd ( d1 , d2 ) NEW_LINE if ( ( k - x ) % gcd != 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT q = queue ( ) NEW_LINE visited = dict ( ) NEW_LINE q . appendleft ( [ k , 0 ] ) NEW_LINE visited [ k ] = 1 NEW_LINE while ( len ( q ) > 0 ) : NEW_LINE INDENT sr = q . pop ( ) NEW_LINE s , stp = sr [ 0 ] , sr [ 1 ] NEW_LINE if ( s == x ) : NEW_LINE INDENT return stp NEW_LINE DEDENT if ( s + d1 not in visited ) : NEW_LINE INDENT q . appendleft ( [ ( s + d1 ) , stp + 1 ] ) NEW_LINE visited [ ( s + d1 ) ] = 1 NEW_LINE DEDENT if ( s + d2 not in visited ) : NEW_LINE INDENT q . appendleft ( [ ( s + d2 ) , stp + 1 ] ) NEW_LINE visited [ ( s + d2 ) ] = 1 NEW_LINE DEDENT if ( s - d1 not in visited ) : NEW_LINE INDENT q . appendleft ( [ ( s - d1 ) , stp + 1 ] ) NEW_LINE visited [ ( s - d1 ) ] = 1 NEW_LINE DEDENT if ( s - d2 not in visited ) : NEW_LINE INDENT q . appendleft ( [ ( s - d2 ) , stp + 1 ] ) NEW_LINE visited [ ( s - d2 ) ] = 1 NEW_LINE DEDENT DEDENT DEDENT k = 10 NEW_LINE d1 = 4 NEW_LINE d2 = 6 NEW_LINE x = 8 NEW_LINE print ( minStepsNeeded ( k , d1 , d2 , x ) ) NEW_LINE"],"bleu":0.33758670530192464,"rouge_l":0.47938323800049737}
{"id":1153,"predictions":["def minAbsSumP ( arr , n , arr_size ) : NEW_LINE INDENT inv_count = 0 NEW_LINE if ( arr_size < 2 ) : NEW_LINE INDENT inv_count = 0 NEW_LINE DEDENT if ( arr_size < 2 ) : NEW_LINE INDENT inv_count = arr [ 0 ] + arr [ 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT inv_count = arr [ 0 ] + arr_size NEW_LINE DEDENT for l in range ( arr_size ) : NEW_LINE INDENT for r in range ( l + 1 , arr_size , 1 ) : NEW_LINE INDENT if ( arr [ l ] < abs ( arr [ r ] ) ) : NEW_LINE INDENT inv_sum = arr [ l ] + arr [ r ] NEW_LINE DEDENT else : NEW_LINE INDENT inv_count = arr [ r ] + arr [ l ] NEW_LINE DEDENT DEDENT DEDENT for l in range ( arr_size - 1 ) : NEW_LINE INDENT r = l + 1 NEW_LINE DEDENT for l in range ( l + 1 ) : NEW_LINE INDENT if ( arr [ l ] > abs ( arr [ r ] ) and abs ( arr [ l ] ) > abs ( arr [ l ] ) ) : NEW_LINE INDENT min_sum = sum_p ( arr [ l ] ) NEW_LINE DEDENT DEDENT print ( \" The ▁ two ▁ array ▁ are \" , arr [ min_r ] ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 60 , - 10 , 70 , - 80 ] NEW_LINE n = len ( arr ) NEW_LINE minAbsSumPair ( arr , n ) NEW_LINE DEDENT"],"references":["def minAbsSumPair ( arr , arr_size ) : NEW_LINE INDENT inv_count = 0 NEW_LINE if arr_size < 2 : NEW_LINE INDENT print ( \" Invalid ▁ Input \" ) NEW_LINE return NEW_LINE DEDENT min_l = 0 NEW_LINE min_r = 1 NEW_LINE min_sum = arr [ 0 ] + arr [ 1 ] NEW_LINE for l in range ( 0 , arr_size - 1 ) : NEW_LINE INDENT for r in range ( l + 1 , arr_size ) : NEW_LINE INDENT sum = arr [ l ] + arr [ r ] NEW_LINE if abs ( min_sum ) > abs ( sum ) : NEW_LINE INDENT min_sum = sum NEW_LINE min_l = l NEW_LINE min_r = r NEW_LINE DEDENT DEDENT DEDENT print ( \" The ▁ two ▁ elements ▁ whose ▁ sum ▁ is ▁ minimum ▁ are \" , arr [ min_l ] , \" and ▁ \" , arr [ min_r ] ) NEW_LINE DEDENT arr = [ 1 , 60 , - 10 , 70 , - 80 , 85 ] NEW_LINE minAbsSumPair ( arr , 6 ) ; NEW_LINE"],"bleu":0.37105182651894464,"rouge_l":0.566549656281995}
{"id":1154,"predictions":["def findSubsequence ( arr , n ) : NEW_LINE INDENT Len = 1 NEW_LINE dp = [ 0 ] * 10 NEW_LINE locMax = [ 0 ] * 10 NEW_LINE dnt = [ 0 ] * 10 NEW_LINE locMax = [ 0 ] * 10 NEW_LINE locMax = 0 NEW_LINE while ( locMax ) : NEW_LINE INDENT dp [ locMax % 10 ] = 1 NEW_LINE locMax [ locMax % 10 ] = 1 NEW_LINE locMax [ locMax [ locMax ] ] = 1 NEW_LINE DEDENT for i in range ( 1 , n , 1 ) : NEW_LINE INDENT locMax [ locMax [ locMax [ locMax [ locMax [ locMax [ locMax [ locMax [ locMax [ locMax [ locMax [ locMax [ locMax ] ] ] ] ] NEW_LINE DEDENT for d in range ( locMax ) : NEW_LINE INDENT if ( cnt [ d ] == 1 ) : NEW_LINE INDENT locMax [ d ] += 1 NEW_LINE locMax = max ( locMax , dp [ locMax [ d ] ] , locMax ) NEW_LINE DEDENT DEDENT for d in range ( 10 ) : NEW_LINE INDENT if ( cnt [ d ] == 1 ) : NEW_LINE INDENT dp [ d ] += 1 NEW_LINE locMax = 0 NEW_LINE DEDENT DEDENT for locMax = max ( locMax , locMax ) : NEW_LINE INDENT if ( cnt [ d ] == 1 ) : NEW_LINE INDENT dp [ d ] = locMax [ d ] NEW_LINE DEDENT Len = max ( Len , locMax ) NEW_LINE DEDENT return Len NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 12 , 44 , 33 , 96 , 96 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findSubsequence ( arr , n ) ) NEW_LINE DEDENT"],"references":["def findSubsequence ( arr , n ) : NEW_LINE INDENT length = 1 ; NEW_LINE dp = [ 0 ] * 10 ; NEW_LINE tmp = arr [ 0 ] ; NEW_LINE while ( tmp > 0 ) : NEW_LINE INDENT dp [ tmp % 10 ] = 1 ; NEW_LINE tmp \/\/= 10 ; NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT tmp = arr [ i ] ; NEW_LINE locMax = 1 ; NEW_LINE cnt = [ 0 ] * 10 NEW_LINE while ( tmp > 0 ) : NEW_LINE INDENT cnt [ tmp % 10 ] = 1 ; NEW_LINE tmp \/\/= 10 ; NEW_LINE DEDENT for d in range ( 10 ) : NEW_LINE INDENT if ( cnt [ d ] ) : NEW_LINE INDENT dp [ d ] += 1 ; NEW_LINE locMax = max ( locMax , dp [ d ] ) ; NEW_LINE DEDENT DEDENT for d in range ( 10 ) : NEW_LINE INDENT if ( cnt [ d ] ) : NEW_LINE INDENT dp [ d ] = locMax ; NEW_LINE DEDENT DEDENT length = max ( length , locMax ) ; NEW_LINE DEDENT return length ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 12 , 44 , 29 , 33 , 96 , 89 ] ; NEW_LINE n = len ( arr ) NEW_LINE print ( findSubsequence ( arr , n ) ) ; NEW_LINE DEDENT"],"bleu":0.5092683063865007,"rouge_l":0.6691831318195222}
{"id":1155,"predictions":["dp = [ [ [ - 1 for col in range ( 5 ) ] for col in range ( 100 ) ] for row in range ( 100 ) ] NEW_LINE def count ( n , p , next1 , next1 ) : NEW_LINE INDENT if ( n <= 0 and n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( dp [ n ] [ p ] != - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ n ] [ p ] != - 1 ) : NEW_LINE INDENT return dp [ n ] [ p ] NEW_LINE DEDENT ans = 0 NEW_LINE if ( dp [ n ] [ p ] != - 1 ) : NEW_LINE INDENT return dp [ n ] [ p ] NEW_LINE DEDENT ans += ( dp [ n ] [ p ] ) NEW_LINE DEDENT return dp [ n ] [ p ] NEW_LINE DEDENT def countWays ( n , 1 , 1 ) : NEW_LINE INDENT for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( 5 ) : NEW_LINE INDENT for k in range ( 0 , 5 ) : NEW_LINE INDENT ans += countWays ( n - i , data , i ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 8 NEW_LINE print ( countWays ( n , 4 ) ) NEW_LINE DEDENT"],"references":["dp = [ [ [ - 1 for i in range ( 5 ) ] for i in range ( 501 ) ] for i in range ( 501 ) ] NEW_LINE def countWaysUtil ( n , parts , nextPart ) : NEW_LINE INDENT if ( parts == 0 and n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n <= 0 or parts <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ n ] [ nextPart ] [ parts ] != - 1 ) : NEW_LINE INDENT return dp [ n ] [ nextPart ] [ parts ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( nextPart , n + 1 ) : NEW_LINE INDENT ans += countWaysUtil ( n - i , parts - 1 , i ) NEW_LINE DEDENT dp [ n ] [ nextPart ] [ parts ] = ans NEW_LINE return ( ans ) NEW_LINE DEDENT def countWays ( n ) : NEW_LINE INDENT return countWaysUtil ( n , 4 , 1 ) NEW_LINE DEDENT n = 8 NEW_LINE print ( countWays ( n ) ) NEW_LINE"],"bleu":0.4681848518319094,"rouge_l":0.634703196347032}
{"id":1156,"predictions":["import math NEW_LINE def nthRoot ( x , N ) : NEW_LINE INDENT xPre = random . randint ( 10 ** ( N - 1 ) ) NEW_LINE eps = 0.000 NEW_LINE delX = sys . maxsize NEW_LINE while ( delX > eps ) : NEW_LINE INDENT xK = ( ( N - 1.0 ) * xPre + pow ( xPre , N - 1 ) ) \/ N NEW_LINE delX = xPre NEW_LINE xPre = xPre NEW_LINE DEDENT return xK NEW_LINE DEDENT def countPowers ( a , b , k ) : NEW_LINE INDENT return ( ( int ( math . floor ( a \/ root ) ) ) + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 7 NEW_LINE b = 28 NEW_LINE k = 2 NEW_LINE n = 2 NEW_LINE print ( \" Count ▁ of ▁ power ▁ is ▁ \" , countPowers ( a , b , k ) ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE from math import pow , ceil , floor NEW_LINE import random NEW_LINE def nthRoot ( A , N ) : NEW_LINE INDENT xPre = ( random . randint ( 0 , 9 ) ) % 10 NEW_LINE eps = 1e-3 NEW_LINE delX = sys . maxsize NEW_LINE while ( delX > eps ) : NEW_LINE INDENT xK = ( ( N - 1.0 ) * xPre + A \/ pow ( xPre , N - 1 ) ) \/ N NEW_LINE delX = abs ( xK - xPre ) NEW_LINE xPre = xK NEW_LINE DEDENT return xK NEW_LINE DEDENT def countPowers ( a , b , k ) : NEW_LINE INDENT return ( floor ( nthRoot ( b , k ) ) - ceil ( nthRoot ( a , k ) ) + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 7 NEW_LINE b = 28 NEW_LINE k = 2 NEW_LINE print ( \" Count ▁ of ▁ Powers ▁ is \" , countPowers ( a , b , k ) ) NEW_LINE DEDENT"],"bleu":0.6664349521715358,"rouge_l":0.811998541210795}
{"id":1157,"predictions":["def minSwaps ( str1 , str2 ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT if str1 [ i ] != str2 [ i ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count % 2 == 0 ) : NEW_LINE INDENT return count NEW_LINE DEDENT else : NEW_LINE INDENT return \" Not ▁ Possible \" NEW_LINE DEDENT DEDENT if ( count % 2 == 0 ) : NEW_LINE INDENT print ( \" Not ▁ possible \" ) NEW_LINE DEDENT elif ( count % 2 == 0 ) : NEW_LINE INDENT print ( \" Possible \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ possible \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT binaryString ( binaryString1 , binary2 , binary2 ) NEW_LINE binaryString ( binaryString1 , binary2 ) NEW_LINE DEDENT"],"references":["def minSwaps ( str1 , str2 ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT if str1 [ i ] != str2 [ i ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if count % 2 == 0 : NEW_LINE INDENT print ( count \/\/ 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ Possible \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT binaryString1 = \"1110000\" NEW_LINE binaryString2 = \"0001101\" NEW_LINE minSwaps ( binaryString1 , binaryString2 ) NEW_LINE DEDENT"],"bleu":0.5168399320296688,"rouge_l":0.7403858438737704}
{"id":1158,"predictions":["def count OrderedPairs ( A , n ) : NEW_LINE INDENT orderedPairs = dict ( ) NEW_LINE m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( m [ A [ i ] ] == 0 ) : NEW_LINE INDENT m [ A [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT a = m [ A [ i ] ] NEW_LINE m [ A [ i ] ] += 1 NEW_LINE DEDENT DEDENT return sortedPairs NEW_LINE DEDENT if __name__ == ' _ _ main _ _ \" : NEW_LINE INDENT A = [ 1 , 1 , 2 , 2 , 3 ] NEW_LINE n = len ( A ) NEW_LINE print ( count OrderedPairs ( A , n ) ) NEW_LINE DEDENT"],"references":["from collections import defaultdict NEW_LINE def countOrderedPairs ( A , n ) : NEW_LINE INDENT orderedPairs = 0 NEW_LINE m = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT m [ A [ i ] ] += 1 NEW_LINE DEDENT for X , Y in m . items ( ) : NEW_LINE INDENT for j in range ( 1 , Y + 1 ) : NEW_LINE INDENT if m [ j ] >= X : NEW_LINE INDENT orderedPairs += 1 NEW_LINE DEDENT DEDENT DEDENT return orderedPairs NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 1 , 1 , 2 , 2 , 3 ] NEW_LINE n = len ( A ) NEW_LINE print ( countOrderedPairs ( A , n ) ) NEW_LINE DEDENT"],"bleu":0.5760563108573835,"rouge_l":0.6913190793316977}
{"id":1159,"predictions":["def makeAP ( arr , n ) : NEW_LINE INDENT final_diff = arr [ 0 ] NEW_LINE common_diff = arr [ 1 ] - arr [ 0 ] NEW_LINE common_difference = arr [ 1 ] - common_difference NEW_LINE if ( n == 3 ) : NEW_LINE INDENT common_difference = arr [ 1 ] - common_difference NEW_LINE common_difference = arr [ 0 ] - common_difference NEW_LINE if ( ( arr [ 1 ] - arr [ 0 ] ) == ( arr [ 1 ] - arr [ 1 ] ) ) : NEW_LINE INDENT common_difference = arr [ 0 ] - common_difference NEW_LINE DEDENT else : NEW_LINE INDENT common_difference = arr [ 0 ] - common_difference NEW_LINE DEDENT if ( ( arr [ 0 ] - arr [ 1 ] == ( arr [ 2 ] - arr [ 1 ] ) ) ) : NEW_LINE INDENT common_difference = arr [ 0 ] - common_difference NEW_LINE DEDENT else : NEW_LINE INDENT common_difference = arr [ 1 ] - common_difference NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( common_difference , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 3 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE makeAP ( arr , n ) NEW_LINE DEDENT"],"references":["def makeAP ( arr , n ) : NEW_LINE INDENT initial_term , common_difference = 0 , 0 NEW_LINE if ( n == 3 ) : NEW_LINE INDENT common_difference = arr [ 2 ] - arr [ 1 ] NEW_LINE initial_term = arr [ 1 ] - common_difference NEW_LINE DEDENT elif ( ( arr [ 1 ] - arr [ 0 ] ) == arr [ 2 ] - arr [ 1 ] ) : NEW_LINE INDENT initial_term = arr [ 0 ] NEW_LINE common_difference = arr [ 1 ] - arr [ 0 ] NEW_LINE DEDENT elif ( ( arr [ 2 ] - arr [ 1 ] ) == ( arr [ 3 ] - arr [ 2 ] ) ) : NEW_LINE INDENT common_difference = arr [ 2 ] - arr [ 1 ] NEW_LINE initial_term = arr [ 1 ] - common_difference NEW_LINE DEDENT else : NEW_LINE INDENT common_difference = ( arr [ 3 ] - arr [ 0 ] ) \/ 3 NEW_LINE initial_term = arr [ 0 ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( int ( initial_term + ( i * common_difference ) ) , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT arr = [ 1 , 3 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE makeAP ( arr , n ) NEW_LINE"],"bleu":0.6815405825612423,"rouge_l":0.7148936170212767}
{"id":1160,"predictions":["def countIncreasing ( arr , length ) : NEW_LINE INDENT cnt = 0 NEW_LINE l = 1 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if arr [ i + 1 ] > arr [ i ] : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += ( ( length - 1 ) * length ) \/\/ 2 NEW_LINE l = 1 NEW_LINE DEDENT DEDENT if ( l > 1 ) : NEW_LINE INDENT cnt += ( ( length - 1 ) * length ) \/\/ 2 NEW_LINE DEDENT return cnt NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 2 , 4 ] NEW_LINE length = len ( arr ) NEW_LINE print ( \" Count ▁ of ▁ increasing \" , countIncreasing ( arr , length ) ) NEW_LINE DEDENT"],"references":["def countIncreasing ( arr , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE len = 1 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if arr [ i + 1 ] > arr [ i ] : NEW_LINE INDENT len += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += ( ( ( len - 1 ) * len ) \/ 2 ) NEW_LINE len = 1 NEW_LINE DEDENT DEDENT if len > 1 : NEW_LINE INDENT cnt += ( ( ( len - 1 ) * len ) \/ 2 ) NEW_LINE DEDENT return cnt NEW_LINE DEDENT arr = [ 1 , 2 , 2 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Count ▁ of ▁ strictly ▁ increasing ▁ subarrays ▁ is \" , int ( countIncreasing ( arr , n ) ) ) NEW_LINE"],"bleu":0.6457239094200325,"rouge_l":0.8222959238258265}
{"id":1161,"predictions":["def harmonicMean ( arr , n ) : NEW_LINE INDENT sm = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sm = sm + ( sm + ( 1 \/ arr [ i ] ) ) NEW_LINE DEDENT return sm NEW_LINE DEDENT arr = [ 13.5 , 14 , 15 , 15 , 16 ] NEW_LINE n = len ( arr ) NEW_LINE print ( harmonicMean ( arr , n ) ) NEW_LINE"],"references":["def harmonicMean ( arr , n ) : NEW_LINE INDENT sm = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sm = sm + ( 1 ) \/ arr [ i ] ; NEW_LINE DEDENT return n \/ sm NEW_LINE DEDENT arr = [ 13.5 , 14.5 , 14.8 , 15.2 , 16.1 ] ; NEW_LINE n = len ( arr ) NEW_LINE print ( harmonicMean ( arr , n ) ) NEW_LINE"],"bleu":0.7683781291775992,"rouge_l":0.8860759493670886}
{"id":1162,"predictions":["def asPowerSum ( w , m ) : NEW_LINE INDENT while ( m ) : NEW_LINE INDENT if ( ( m - 1 ) % w == 0 ) : NEW_LINE INDENT m = ( m - 1 ) \/\/ w NEW_LINE DEDENT elif ( m % w == 0 ) : NEW_LINE INDENT m = ( m + 1 ) \/\/ w NEW_LINE DEDENT elif ( m % w == 0 ) : NEW_LINE INDENT m = ( m \/\/ w ) NEW_LINE DEDENT elif ( m % w == 0 ) : NEW_LINE INDENT m = ( m \/\/ w ) NEW_LINE DEDENT else : NEW_LINE INDENT m = ( m + 1 ) \/\/ w NEW_LINE DEDENT DEDENT return ( m == 0 ) NEW_LINE DEDENT w = 3 NEW_LINE m = 7 NEW_LINE if ( asPowerSum ( w , m ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def asPowerSum ( w , m ) : NEW_LINE INDENT while ( m > 0 ) : NEW_LINE INDENT if ( ( m - 1 ) % w == 0 ) : NEW_LINE INDENT m = ( m - 1 ) \/ w ; NEW_LINE DEDENT elif ( ( m + 1 ) % w == 0 ) : NEW_LINE INDENT m = ( m + 1 ) \/ w ; NEW_LINE DEDENT elif ( m % w == 0 ) : NEW_LINE INDENT m = m \/ w ; NEW_LINE DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT return ( m == 0 ) ; NEW_LINE DEDENT w = 3 ; NEW_LINE m = 7 ; NEW_LINE if ( asPowerSum ( w , m ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT"],"bleu":0.6987300128370022,"rouge_l":0.8492169106356844}
{"id":1163,"predictions":["def result ( n , k , t ) : NEW_LINE INDENT if ( t <= k ) : NEW_LINE INDENT print ( t ) NEW_LINE return NEW_LINE DEDENT elif ( t <= n ) : NEW_LINE INDENT print ( k ) NEW_LINE DEDENT else : NEW_LINE INDENT temp = t - n NEW_LINE k = k - temp NEW_LINE if ( t <= temp ) : NEW_LINE INDENT print ( t ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( t ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = k NEW_LINE t = 10 NEW_LINE k = 12 NEW_LINE result ( n , k , t ) NEW_LINE DEDENT"],"references":["def result ( n , k , t ) : NEW_LINE INDENT if ( t <= k ) : NEW_LINE INDENT print ( t ) NEW_LINE DEDENT elif ( t <= n ) : NEW_LINE INDENT print ( k ) NEW_LINE DEDENT else : NEW_LINE INDENT temp = t - n NEW_LINE temp = k - temp NEW_LINE print ( temp ) NEW_LINE DEDENT DEDENT n = 10 NEW_LINE k = 5 NEW_LINE t = 12 NEW_LINE result ( n , k , t ) NEW_LINE"],"bleu":0.6071741339093754,"rouge_l":0.794012365766352}
{"id":1164,"predictions":["import math NEW_LINE MAX = math . floor ( math . log10 ( MAX ) ) NEW_LINE def calculateSieve ( ) : NEW_LINE INDENT height = math . floor ( log10 ( MAX ) \/ math . log2 ( 2 ) ) NEW_LINE table = [ [ 0 for i in range ( MAX + 1 ) ] for j in range ( MAX + 1 ) ] NEW_LINE def calculateSieve ( ) : NEW_LINE INDENT global table NEW_LINE for i in range ( 0 , high + 1 ) : NEW_LINE INDENT if ( i & ( 1 << i ) ) : NEW_LINE INDENT table [ i ] [ i ] = table [ i - 1 ] [ i ] NEW_LINE DEDENT DEDENT DEDENT def minimumSieve ( v , k ) : NEW_LINE INDENT table [ v ] [ i ] = 1 NEW_LINE for i in range ( 1 , high + 1 ) : NEW_LINE INDENT if ( k & ( 1 << i ) != 0 ) : NEW_LINE INDENT table [ v ] [ i - 1 ] = table [ v ] [ i - 1 ] NEW_LINE break NEW_LINE DEDENT DEDENT return table [ v ] [ i ] NEW_LINE DEDENT def kthTerm ( v , k ) : NEW_LINE INDENT for i in range ( 0 , high + 1 ) : NEW_LINE INDENT if ( k & ( 1 << i ) != 0 ) : NEW_LINE INDENT v = table [ v ] [ i ] NEW_LINE if ( v == - 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT DEDENT return v NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 6 NEW_LINE G = [ [ ] for i in range ( 0 , n + 1 ) ] NEW_LINE calculateSieve ( 0 , 3 ) NEW_LINE print ( kthTerm ( 1 , 2 ) ) NEW_LINE DEDENT"],"references":["import math NEW_LINE class GfG : NEW_LINE INDENT def __init__ ( self , n ) : NEW_LINE INDENT self . height = int ( math . ceil ( math . log10 ( n ) \/ math . log10 ( 2 ) ) ) NEW_LINE self . table = [ 0 ] * ( n + 1 ) NEW_LINE DEDENT def preprocessing ( self ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i < len ( self . table ) ) : NEW_LINE INDENT self . table [ i ] = [ - 1 ] * ( self . height + 1 ) NEW_LINE i = i + 1 NEW_LINE DEDENT DEDENT def calculateSparse ( self , u , v ) : NEW_LINE INDENT self . table [ v ] [ 0 ] = u NEW_LINE i = 1 NEW_LINE while ( i <= self . height ) : NEW_LINE INDENT self . table [ v ] [ i ] = self . table [ self . table [ v ] [ i - 1 ] ] [ i - 1 ] NEW_LINE if ( self . table [ v ] [ i ] == - 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT DEDENT def kthancestor ( self , V , k ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i <= self . height ) : NEW_LINE INDENT if ( ( k & ( 1 << i ) ) != 0 ) : NEW_LINE INDENT V = self . table [ V ] [ i ] NEW_LINE if ( V == - 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT i = i + 1 NEW_LINE DEDENT return V NEW_LINE DEDENT DEDENT n = 6 NEW_LINE obj = GfG ( n ) NEW_LINE obj . preprocessing ( ) NEW_LINE obj . calculateSparse ( 1 , 2 ) NEW_LINE obj . calculateSparse ( 1 , 3 ) NEW_LINE obj . calculateSparse ( 2 , 4 ) NEW_LINE obj . calculateSparse ( 2 , 5 ) NEW_LINE obj . calculateSparse ( 3 , 6 ) NEW_LINE K = 2 NEW_LINE V = 5 NEW_LINE print ( obj . kthancestor ( V , K ) ) NEW_LINE"],"bleu":0.35336576219871124,"rouge_l":0.538268105340161}
{"id":1165,"predictions":["def factors ( n , i ) : NEW_LINE INDENT if ( i <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( i , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 16 ; NEW_LINE factors ( n , 1 ) ; NEW_LINE DEDENT"],"references":["def factors ( n , i ) : NEW_LINE INDENT if ( i <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) ; NEW_LINE DEDENT factors ( n , i + 1 ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 16 ; NEW_LINE factors ( N , 1 ) ; NEW_LINE DEDENT"],"bleu":0.7587066989147643,"rouge_l":0.8719335522503382}
{"id":1166,"predictions":["def sumKRepeating ( arr , n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in mp : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE mp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT DEDENT for x in mp : NEW_LINE INDENT if ( mp [ x ] == k ) : NEW_LINE INDENT sum += x NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 9 , 9 , 10 , 11 , 8 , 8 , 9 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE print ( sumKRepeating ( arr , n , k ) ) NEW_LINE DEDENT"],"references":["import math as mt NEW_LINE def sumKRepeating ( arr , n , k ) : NEW_LINE INDENT Sum = 0 NEW_LINE mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in mp . keys ( ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT for x in mp : NEW_LINE INDENT if ( mp [ x ] == k ) : NEW_LINE INDENT Sum += x NEW_LINE DEDENT DEDENT return Sum NEW_LINE DEDENT arr = [ 9 , 9 , 10 , 11 , 8 , 8 , 9 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE print ( sumKRepeating ( arr , n , k ) ) NEW_LINE"],"bleu":0.7533890444634784,"rouge_l":0.8604210526315789}
{"id":1167,"predictions":["def power ( num , n ) : NEW_LINE INDENT if ( n == 0 ) : return 1 ; NEW_LINE elif ( n % 2 == 0 ) : return ( power ( num , int ( n \/ 2 ) ) * power ( num , int ( n \/ 2 ) ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return num * power ( num , int ( n \/ 2 ) ) ; NEW_LINE DEDENT def check ( x , n , curr_num ) : NEW_LINE INDENT ways = 0 ; NEW_LINE p = power ( x , n ) ; NEW_LINE while ( p + curr_num < x ) : NEW_LINE INDENT res += check ( x , n , curr_num ) ; NEW_LINE p += 1 ; NEW_LINE DEDENT if ( p + curr_num == x ) : NEW_LINE INDENT return res ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = 10 ; NEW_LINE n = 2 ; NEW_LINE print ( check ( x , n , 1 , 0 ) ) ; NEW_LINE DEDENT"],"references":["def power ( num , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( n % 2 == 0 ) : NEW_LINE INDENT return power ( num , n \/\/ 2 ) * power ( num , n \/\/ 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return num * power ( num , n \/\/ 2 ) * power ( num , n \/\/ 2 ) NEW_LINE DEDENT DEDENT def checkRecursive ( x , n , curr_num = 1 , curr_sum = 0 ) : NEW_LINE INDENT results = 0 NEW_LINE p = power ( curr_num , n ) NEW_LINE while ( p + curr_sum < x ) : NEW_LINE INDENT results += checkRecursive ( x , n , curr_num + 1 , p + curr_sum ) NEW_LINE curr_num = curr_num + 1 NEW_LINE p = power ( curr_num , n ) NEW_LINE DEDENT if ( p + curr_sum == x ) : NEW_LINE INDENT results = results + 1 NEW_LINE DEDENT return results NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 10 NEW_LINE n = 2 NEW_LINE print ( checkRecursive ( x , n ) ) NEW_LINE DEDENT"],"bleu":0.48784689369832257,"rouge_l":0.7441412520064206}
{"id":1168,"predictions":["def nCr ( n , r ) : NEW_LINE INDENT fac = [ 0 for i in range ( 100 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fac [ i ] = fac [ i - 1 ] * i NEW_LINE DEDENT ans = fac [ n ] \/ ( fac [ n - r ] * fac [ n - r ] ) NEW_LINE ans = fac [ n - 1 ] \/ ( fac [ n - r ] * fac [ r ] ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE k = 3 NEW_LINE ans = nCr ( n + k - 1 , n - 1 ) NEW_LINE print ( ans ) NEW_LINE DEDENT"],"references":["def nCr ( n , r ) : NEW_LINE INDENT fac = list ( ) NEW_LINE fac . append ( 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fac . append ( fac [ i - 1 ] * i ) NEW_LINE DEDENT ans = fac [ n ] \/ ( fac [ n - r ] * fac [ r ] ) NEW_LINE return ans NEW_LINE DEDENT n = 3 NEW_LINE k = 3 NEW_LINE ans = nCr ( n + k - 1 , k ) + nCr ( k - 1 , n - 1 ) NEW_LINE print ( ans ) NEW_LINE"],"bleu":0.6087155709105133,"rouge_l":0.7363707165109034}
{"id":1169,"predictions":["def pairORSum ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT ans = ans + arr [ i ] ^ arr [ j ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 5 , 9 , 7 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( pairORSum ( arr , n ) ) NEW_LINE"],"references":["def pairORSum ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT ans = ans + ( arr [ i ] ^ arr [ j ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 5 , 9 , 7 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( pairORSum ( arr , n ) ) NEW_LINE"],"bleu":0.9041052612858854,"rouge_l":0.9735828288387451}
{"id":1170,"predictions":["def alphabetPattern ( N , index_index ) : NEW_LINE INDENT Right = 1 NEW_LINE Diagonal = 1 NEW_LINE for index in range ( N - 1 ) : NEW_LINE INDENT for i in range ( 0 , N - index - 1 ) : NEW_LINE INDENT print ( \" ▁ \" , end = \" \" ) NEW_LINE DEDENT print ( \" \\n \" , end = \" \" ) NEW_LINE Diagonal += 1 NEW_LINE DEDENT for index in range ( 1 , N - index - index - 1 ) : NEW_LINE INDENT print ( Diagonal , end = \" \" ) NEW_LINE DEDENT print ( \" \\n \" , end = \" \" ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 5 NEW_LINE alphabetPattern ( N , index_index - 1 ) NEW_LINE DEDENT"],"references":["def alphabetPattern ( N ) : NEW_LINE INDENT Top , Bottom , Diagonal = 1 , 1 , N - 1 NEW_LINE for index in range ( N ) : NEW_LINE INDENT print ( Top , end = ' ▁ ' ) NEW_LINE Top += 1 NEW_LINE DEDENT print ( ) NEW_LINE for index in range ( 1 , N - 1 ) : NEW_LINE INDENT for side_index in range ( 2 * ( N - index - 1 ) ) : NEW_LINE INDENT print ( ' ▁ ' , end = ' ' ) NEW_LINE DEDENT print ( Diagonal , end = ' ' ) NEW_LINE Diagonal -= 1 NEW_LINE print ( ) NEW_LINE DEDENT for index in range ( N ) : NEW_LINE INDENT print ( Bottom , end = ' ▁ ' ) NEW_LINE Bottom += 1 NEW_LINE DEDENT DEDENT N = 5 NEW_LINE alphabetPattern ( N ) NEW_LINE"],"bleu":0.4654713492321358,"rouge_l":0.5833791359788941}
{"id":1171,"predictions":["def areElementsContiguous ( arr , n ) : NEW_LINE INDENT us = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT us . add ( arr [ i ] ) NEW_LINE DEDENT count = 1 NEW_LINE curr_ele = arr [ n - 1 ] NEW_LINE while ( len ( usr ) > 0 ) : NEW_LINE INDENT count += 1 NEW_LINE if ( curr_ele == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT curr_ele -= 1 NEW_LINE DEDENT if ( count == ( curr_ele ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT arr = [ 5 , 2 , 3 , 6 , 4 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE if ( areElementsContiguous ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def areElementsContiguous ( arr ) : NEW_LINE INDENT us = set ( ) NEW_LINE for i in arr : us . add ( i ) NEW_LINE count = 1 NEW_LINE curr_ele = arr [ 0 ] - 1 NEW_LINE while curr_ele in us : NEW_LINE INDENT count += 1 NEW_LINE curr_ele -= 1 NEW_LINE DEDENT curr_ele = arr [ 0 ] + 1 NEW_LINE while curr_ele in us : NEW_LINE INDENT count += 1 NEW_LINE curr_ele += 1 NEW_LINE DEDENT return ( count == len ( us ) ) NEW_LINE DEDENT arr = [ 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 ] NEW_LINE if areElementsContiguous ( arr ) : print ( \" Yes \" ) NEW_LINE else : print ( \" No \" ) NEW_LINE"],"bleu":0.4492944364761511,"rouge_l":0.6913512323943662}
{"id":1172,"predictions":["def pivot ( arr , n , key ) : NEW_LINE INDENT pivot = findP binarySearch ( arr , 0 , n - 1 , key ) NEW_LINE if ( pivot == - 1 ) : NEW_LINE INDENT return pivot NEW_LINE DEDENT if ( arr [ pivot ] == key ) : NEW_LINE INDENT return arr [ pivot ] NEW_LINE DEDENT if ( arr [ pivot ] <= key ) : NEW_LINE INDENT return arr [ pivot ] NEW_LINE DEDENT if ( arr [ pivot ] <= key ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( arr [ pivot ] <= key ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( low + high ) \/\/ 2 NEW_LINE if ( arr [ mid ] > key and arr [ mid + 1 ] > arr [ mid ] ) : NEW_LINE INDENT return ( mid - 1 ) NEW_LINE DEDENT if ( key < low and arr [ mid ] > arr [ mid ] ) : NEW_LINE INDENT return ( mid - 1 ) NEW_LINE DEDENT if ( key > arr [ mid ] ) : NEW_LINE INDENT return ( mid - 1 ) NEW_LINE DEDENT if ( arr [ mid ] >= arr [ mid ] ) : NEW_LINE INDENT return ( mid - 1 ) NEW_LINE DEDENT return ( mid - 1 ) NEW_LINE DEDENT if ( key > arr [ mid ] ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ( mid - 1 ) NEW_LINE DEDENT def binarySearch ( arr , low , high , key ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( low + high ) \/\/ 2 NEW_LINE key = ( low + high ) \/\/ 2 NEW_LINE if ( binarySearch ( arr , mid + 1 , key ) : NEW_LINE INDENT return binarySearch ( arr , mid + 1 , high , key ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr1 = [ 5 , 6 , 7 , 8 , 9 , 1 , 2 , 3 ] NEW_LINE n = len ( arr1 ) NEW_LINE key = 3 NEW_LINE print ( \" Index ▁ of �"],"references":["def pivotedBinarySearch ( arr , n , key ) : NEW_LINE INDENT pivot = findPivot ( arr , 0 , n - 1 ) ; NEW_LINE if pivot == - 1 : NEW_LINE INDENT return binarySearch ( arr , 0 , n - 1 , key ) ; NEW_LINE DEDENT if arr [ pivot ] == key : NEW_LINE INDENT return pivot NEW_LINE DEDENT if arr [ 0 ] <= key : NEW_LINE INDENT return binarySearch ( arr , 0 , pivot - 1 , key ) ; NEW_LINE DEDENT return binarySearch ( arr , pivot + 1 , n - 1 , key ) ; NEW_LINE DEDENT def findPivot ( arr , low , high ) : NEW_LINE INDENT if high < low : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if high == low : NEW_LINE INDENT return low NEW_LINE DEDENT mid = int ( ( low + high ) \/ 2 ) NEW_LINE if mid < high and arr [ mid ] > arr [ mid + 1 ] : NEW_LINE INDENT return mid NEW_LINE DEDENT if mid > low and arr [ mid ] < arr [ mid - 1 ] : NEW_LINE INDENT return ( mid - 1 ) NEW_LINE DEDENT if arr [ low ] >= arr [ mid ] : NEW_LINE INDENT return findPivot ( arr , low , mid - 1 ) NEW_LINE DEDENT return findPivot ( arr , mid + 1 , high ) NEW_LINE DEDENT def binarySearch ( arr , low , high , key ) : NEW_LINE INDENT if high < low : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = int ( ( low + high ) \/ 2 ) NEW_LINE if key == arr [ mid ] : NEW_LINE INDENT return mid NEW_LINE DEDENT if key > arr [ mid ] : NEW_LINE INDENT return binarySearch ( arr , ( mid + 1 ) , high , key ) ; NEW_LINE DEDENT return binarySearch ( arr , low , ( mid - 1 ) , key ) ; NEW_LINE DEDENT arr1 = [ 5 , 6 , 7 , 8 , 9 , 10 , 1 , 2 , 3 ] NEW_LINE n = len ( arr1 ) NEW_LINE key = 3 NEW_LINE print ( \" Index ▁ of ▁ the ▁ element ▁ is ▁ : ▁ \" , pivotedBinarySearch ( arr1 , n , key ) ) NEW_LINE"],"bleu":0.5447980685407141,"rouge_l":0.638117862799033}
{"id":1173,"predictions":["def findDeroes ( a , b , n ) : NEW_LINE INDENT mpp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( b [ i ] ) : NEW_LINE INDENT val = ( - 1.0 ) \/\/ ( a [ i ] ) NEW_LINE if ( a [ val ] not in mpp and a [ i ] not in mpp ) : NEW_LINE INDENT mpp [ val ] = 1 NEW_LINE DEDENT DEDENT elif ( b [ val ] == 0 and a [ val ] == 0 ) : NEW_LINE INDENT mpp [ val ] = 1 NEW_LINE DEDENT elif ( b [ val ] == 0 and a [ val ] == 0 ) : NEW_LINE INDENT mpp [ val ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mpp [ val ] = 1 NEW_LINE DEDENT DEDENT DEDENT print ( \" The ▁ number ▁ of ▁ array ▁ array ▁ is ▁ : \" , findDeroes ( a , b , n ) ) NEW_LINE"],"references":["def findDandZeros ( a , b , n ) : NEW_LINE INDENT mpp = { } ; NEW_LINE count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( b [ i ] != 0 and a [ i ] != 0 ) : NEW_LINE INDENT val = ( - 1.0 * b [ i ] ) \/ a [ i ] ; NEW_LINE if val not in mpp : NEW_LINE INDENT mpp [ val ] = 0 ; NEW_LINE DEDENT mpp [ val ] += 1 ; NEW_LINE DEDENT elif ( b [ i ] == 0 and a [ i ] == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT maxi = 0 ; NEW_LINE for item in mpp : NEW_LINE INDENT maxi = max ( mpp [ item ] , maxi ) ; NEW_LINE DEDENT for keys , values in mpp . items ( ) : NEW_LINE INDENT if ( values == maxi ) : NEW_LINE INDENT print ( \" Value ▁ of ▁ d ▁ is : \" , keys ) ; NEW_LINE break ; NEW_LINE DEDENT DEDENT print ( \" The ▁ number ▁ of ▁ zeros ▁ in ▁ array ▁ C ▁ is : \" , maxi + count ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 13 , 37 , 39 ] ; NEW_LINE b = [ 1 , 2 , 3 ] ; NEW_LINE n = len ( a ) ; NEW_LINE findDandZeros ( a , b , n ) ; NEW_LINE DEDENT"],"bleu":0.33536963937729264,"rouge_l":0.5199105770574263}
{"id":1174,"predictions":["def count_odd_pairs ( odd_sum , n , a ) : NEW_LINE INDENT odd_sum = 0 NEW_LINE even_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] % 2 == 0 ) : NEW_LINE INDENT even_sum += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd_sum += 1 NEW_LINE DEDENT DEDENT ans = odd_pairs * even_sum NEW_LINE return ans NEW_LINE DEDENT def count_even_pairs ( n , a ) : NEW_LINE INDENT total_even_pairs = ( n * ( n - 1 ) ) \/\/ 2 NEW_LINE ans = total_odd_pairs_pairs = count_even_pairs ( n , a ) NEW_LINE even_odd_pairs = count_odd_pairs - odd_even_pairs NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 6 NEW_LINE a = [ 2 , 4 , 9 , 1 , 8 ] NEW_LINE print ( \" Even ▁ pair ▁ = \" , odd_sum_pairs ( n , a ) NEW_LINE DEDENT"],"references":["def count_odd_pair ( n , a ) : NEW_LINE INDENT odd = 0 NEW_LINE even = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( a [ i ] % 2 == 0 ) : NEW_LINE INDENT even = even + 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd = odd + 1 NEW_LINE DEDENT DEDENT ans = odd * even * 2 NEW_LINE return ans NEW_LINE DEDENT def count_even_pair ( odd_sum_pairs , n ) : NEW_LINE INDENT total_pairs = ( n * ( n - 1 ) ) NEW_LINE ans = total_pairs - odd_sum_pairs NEW_LINE return ans NEW_LINE DEDENT n = 6 NEW_LINE a = [ 2 , 4 , 5 , 9 , 1 , 8 ] NEW_LINE odd_sum_pairs = count_odd_pair ( n , a ) NEW_LINE even_sum_pairs = count_even_pair ( odd_sum_pairs , n ) NEW_LINE print ( \" Even ▁ Sum ▁ Pairs ▁ = \" , even_sum_pairs ) NEW_LINE print ( \" Odd ▁ Sum ▁ Pairs = \" , odd_sum_pairs ) NEW_LINE"],"bleu":0.5379487362653427,"rouge_l":0.6784988877067415}
{"id":1175,"predictions":["def printQueries ( n , a , q , q ) : NEW_LINE INDENT occ = [ 0 ] * ( n + 1 ) NEW_LINE suffixCount = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( a [ i ] ) : NEW_LINE INDENT occ [ a [ i ] ] = 1 NEW_LINE suffixCount [ i ] = len ( suffixCount [ i ] ) NEW_LINE DEDENT for i in range ( q ) : NEW_LINE INDENT print ( suffixCount [ q [ i ] ] , end = \" ) NEW_LINE DEDENT DEDENT for i in range ( q ) : NEW_LINE INDENT print ( suffixCount [ q [ i ] ] ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 NEW_LINE q = 3 NEW_LINE a = [ 2 , 4 , 6 , 10 ] NEW_LINE q = [ 1 , 3 , 2 , 10 ] NEW_LINE q = [ 1 , 3 , 2 ] NEW_LINE printQueries ( n , a , q , ) NEW_LINE DEDENT"],"references":["def printQueries ( n , a , q , qry ) : NEW_LINE INDENT occ = dict ( ) NEW_LINE suffixCount = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT occ [ a [ i ] ] = 1 NEW_LINE suffixCount [ i + 1 ] = len ( occ ) NEW_LINE DEDENT for i in range ( q ) : NEW_LINE INDENT print ( suffixCount [ qry [ i ] ] ) NEW_LINE DEDENT DEDENT n = 5 NEW_LINE q = 3 NEW_LINE a = [ 2 , 4 , 6 , 10 , 2 ] NEW_LINE qry = [ 1 , 3 , 2 ] NEW_LINE printQueries ( n , a , q , qry ) NEW_LINE"],"bleu":0.5542708877453622,"rouge_l":0.7668095887741183}
{"id":1176,"predictions":["def countRotations ( n ) : NEW_LINE INDENT l = len ( n ) NEW_LINE if ( len ( l ) == 1 ) : NEW_LINE INDENT oneDigit = n NEW_LINE DEDENT if ( oneDigit % 4 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT def twoDigit ( countDigit ) : NEW_LINE INDENT l = len ( str ) NEW_LINE countDigit = 0 NEW_LINE for i in range ( l - 1 ) : NEW_LINE INDENT twoDigit = ( int ( n [ i ] ) * 10 + int ( n [ i + 1 ] ) ) NEW_LINE if ( twoDigit % 4 == 0 ) : NEW_LINE INDENT countDigit += 1 NEW_LINE DEDENT twoDigit = ( int ( n [ l - 1 ] ) * 10 + ( int ( n [ l - 1 ] ) - int ( n [ l - 1 ] ) * 10 + ( int ( n [ l - 1 ] ) ) ) NEW_LINE if ( twoDigit % 4 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = \" 4834\" NEW_LINE print ( \" Rotations : ▁ \" , countRotations ( n ) ) NEW_LINE DEDENT"],"references":["def countRotations ( n ) : NEW_LINE INDENT l = len ( n ) NEW_LINE if ( l == 1 ) : NEW_LINE INDENT oneDigit = ( int ) ( n [ 0 ] ) NEW_LINE if ( oneDigit % 4 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 0 , l - 1 ) : NEW_LINE INDENT twoDigit = ( int ) ( n [ i ] ) * 10 + ( int ) ( n [ i + 1 ] ) NEW_LINE if ( twoDigit % 4 == 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT twoDigit = ( int ) ( n [ l - 1 ] ) * 10 + ( int ) ( n [ 0 ] ) NEW_LINE if ( twoDigit % 4 == 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT n = \"4834\" NEW_LINE print ( \" Rotations : ▁ \" , countRotations ( n ) ) NEW_LINE"],"bleu":0.6090740063072296,"rouge_l":0.788600699243841}
{"id":1177,"predictions":["def smallestX ( n ) : NEW_LINE INDENT temp = [ 0 for i in range ( 10 ) ] NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( n == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT count = 0 NEW_LINE x = 0 NEW_LINE while ( x > 0 ) : NEW_LINE INDENT y = x * n NEW_LINE count = 0 NEW_LINE while ( y > 0 ) : NEW_LINE INDENT y = x * n NEW_LINE if ( y % 10 == 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT y = y \/\/ 10 NEW_LINE DEDENT x = x \/\/ 10 NEW_LINE DEDENT return x - 1 NEW_LINE DEDENT n = 5 NEW_LINE print ( smallestX ( n ) ) NEW_LINE"],"references":["def smallestX ( n ) : NEW_LINE INDENT temp = [ 0 ] * 10 NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT count = 0 NEW_LINE x = 1 NEW_LINE while ( count < 10 ) : NEW_LINE INDENT y = x * n NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( temp [ y % 10 ] == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE temp [ y % 10 ] = 1 NEW_LINE DEDENT y = int ( y \/ 10 ) NEW_LINE DEDENT x += 1 NEW_LINE DEDENT return x - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( smallestX ( n ) ) NEW_LINE DEDENT"],"bleu":0.6021035106328412,"rouge_l":0.7140830081589216}
{"id":1178,"predictions":["def distinctAdjacentElement ( a , n ) : NEW_LINE INDENT m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT m [ a [ i ] ] = m . get ( a [ i ] , 0 ) + 1 NEW_LINE DEDENT mx = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if mx < m [ a [ i ] ] : NEW_LINE INDENT mx = m [ a [ i ] ] NEW_LINE DEDENT if mx > ( n + 1 ) \/\/ 2 : NEW_LINE INDENT mx = m [ a [ i ] ] NEW_LINE DEDENT else : NEW_LINE INDENT mx = m [ a [ i ] ] NEW_LINE DEDENT DEDENT mx = 0 NEW_LINE for i in m : NEW_LINE INDENT if ( mx > ( n + 1 ) \/\/ 2 ) : NEW_LINE INDENT if ( mx > ( n + 1 ) \/\/ 2 ) : NEW_LINE INDENT mx = m [ a [ i ] ] NEW_LINE DEDENT else : NEW_LINE INDENT mx = m [ a [ i ] ] NEW_LINE DEDENT DEDENT DEDENT return \" YES \" NEW_LINE DEDENT a = 7 NEW_LINE n = 4 NEW_LINE print ( distinctAdjacent ( a , n ) ) NEW_LINE"],"references":["def distantAdjacentElement ( a , n ) : NEW_LINE INDENT m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] in m : NEW_LINE INDENT m [ a [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ a [ i ] ] = 1 NEW_LINE DEDENT DEDENT mx = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if mx < m [ a [ i ] ] : NEW_LINE INDENT mx = m [ a [ i ] ] NEW_LINE DEDENT DEDENT if mx > ( n + 1 ) \/\/ 2 : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 7 , 7 , 7 , 7 ] NEW_LINE n = len ( a ) NEW_LINE distantAdjacentElement ( a , n ) NEW_LINE DEDENT"],"bleu":0.547931027942324,"rouge_l":0.628759716120311}
{"id":1179,"predictions":["def fnMod ( n ) : NEW_LINE INDENT rem = n % 4 ; NEW_LINE if ( rem == 0 or rem == 3 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT elif ( rem == 1 or rem == 2 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT elif ( rem == 3 or rem == 2 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT return 0 ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 6 ; NEW_LINE print ( fnMod ( n ) ) ; NEW_LINE DEDENT"],"references":["def fnMod ( n ) : NEW_LINE INDENT rem = n % 4 NEW_LINE if ( rem == 0 or rem == 3 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( rem == 1 or rem == 2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 6 NEW_LINE print ( fnMod ( n ) ) NEW_LINE DEDENT"],"bleu":0.6464614239303991,"rouge_l":0.8714285714285716}
{"id":1180,"predictions":["def isRectangle ( a , b , c , d ) : NEW_LINE INDENT if ( ( a ^ b ^ c ^ d ) != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a , b , c , d = 2 , 3 , 2 NEW_LINE if ( isRectangle ( a , b , c , d ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def isRectangle ( a , b , c , d ) : NEW_LINE INDENT if a ^ b ^ c ^ d : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT a , b , c , d = 3 , 2 , 3 , 2 NEW_LINE print ( \" Yes \" if isRectangle ( a , b , c , d ) else \" No \" ) NEW_LINE"],"bleu":0.5018119555725145,"rouge_l":0.7427701674277017}
{"id":1181,"predictions":["def merge ( arr , temp , left , right ) : NEW_LINE INDENT inv_count = 0 NEW_LINE i = left NEW_LINE j = left NEW_LINE while ( i <= right ) : NEW_LINE INDENT if ( arr [ i ] <= arr [ j ] ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE arr [ j ] = arr [ i ] NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT temp = arr [ j ] NEW_LINE arr [ j ] = arr [ temp ] NEW_LINE inv_count += 1 NEW_LINE DEDENT while ( i <= right - 1 ) : NEW_LINE INDENT temp [ k ] = arr [ i ] NEW_LINE i += 1 NEW_LINE k += 1 NEW_LINE DEDENT while ( i <= right - 1 ) : NEW_LINE INDENT temp [ k ] = arr [ i ] NEW_LINE i += 1 NEW_LINE DEDENT while ( j <= right - 1 ) : NEW_LINE INDENT temp [ k ] = arr [ j ] NEW_LINE k += 1 NEW_LINE j += 1 NEW_LINE DEDENT while ( j <= right ) : NEW_LINE INDENT temp [ k ] = arr [ j ] NEW_LINE arr [ j ] = temp [ k ] NEW_LINE k += 1 NEW_LINE j += 1 NEW_LINE DEDENT return inv_count NEW_LINE DEDENT def merge ( arr , temp , left , right ) : NEW_LINE INDENT for i in range ( left , right + 1 ) : NEW_LINE INDENT arr [ i ] = arr [ j ] NEW_LINE if ( right > left ) : NEW_LINE INDENT mid = ( right + left ) \/\/ 2 NEW_LINE inv_count += merge ( arr , temp , left , right ) NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT return inv_count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 5 ] NEW_LINE N = len ( arr ) NEW_LINE res = merge ( arr , temp , left , right ) NEW_LINE if ( res == - 1 ) : NEW_LINE INDENT"],"references":["def merge ( arr , temp , left , mid , right ) : NEW_LINE INDENT inv_count = 0 NEW_LINE i = left NEW_LINE j = mid NEW_LINE k = left NEW_LINE while ( i <= mid - 1 ) and ( j <= right ) : NEW_LINE INDENT if arr [ i ] <= arr [ j ] : NEW_LINE INDENT temp [ k ] = arr [ i ] NEW_LINE k , i = k + 1 , i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT temp [ k ] = arr [ j ] NEW_LINE k , j = k + 1 , j + 1 NEW_LINE inv_count = inv_count + ( mid - i ) NEW_LINE DEDENT DEDENT while i <= mid - 1 : NEW_LINE INDENT temp [ k ] = arr [ i ] NEW_LINE k , i = k + 1 , i + 1 NEW_LINE DEDENT while j <= right : NEW_LINE INDENT temp [ k ] = arr [ j ] NEW_LINE k , j = k + 1 , j + 1 NEW_LINE DEDENT for i in range ( left , right + 1 ) : NEW_LINE INDENT arr [ i ] = temp [ i ] NEW_LINE DEDENT return inv_count NEW_LINE DEDENT def _mergeSort ( arr , temp , left , right ) : NEW_LINE INDENT inv_count = 0 NEW_LINE if right > left : NEW_LINE INDENT mid = ( right + left ) \/\/ 2 NEW_LINE inv_count = _mergeSort ( arr , temp , left , mid ) NEW_LINE inv_count += _mergeSort ( arr , temp , mid + 1 , right ) NEW_LINE inv_count += merge ( arr , temp , left , mid + 1 , right ) NEW_LINE DEDENT return inv_count NEW_LINE DEDENT def mergeSort ( arr , array_size ) : NEW_LINE INDENT temp = [ None ] * array_size NEW_LINE return _mergeSort ( arr , temp , 0 , array_size - 1 ) NEW_LINE DEDENT def minSwapToReachArr ( arr , N ) : NEW_LINE INDENT for i in range ( 0 , N ) : NEW_LINE INDENT if ( arr [ i ] - 1 ) - i > 2 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT numOfInversion = mergeSort ( arr , N ) NEW_LINE return numOfInversion NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 5 , 3 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE res = minSwapToReachArr ( arr , N ) NEW_LINE if res == - 1 : NEW_LINE INDENT print ( \" Not ▁ Possible \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res ) NEW_LINE DEDENT DEDENT"],"bleu":0.5265866259855206,"rouge_l":0.5911036737235367}
{"id":1182,"predictions":["from math import sqrt NEW_LINE def Prime ( n ) : NEW_LINE INDENT if ( n < 2 ) : return False NEW_LINE for i in range ( 2 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def primeCount ( n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def primeCount ( n ) : NEW_LINE INDENT if ( primeCount ( n ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( primeCount ( n ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT n = 13 NEW_LINE if primeCount ( n ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["from math import sqrt NEW_LINE def Prime ( n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT for i in range ( 2 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT def primeCountDivisors ( n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT for i in range ( 2 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT a = n ; c = 0 ; NEW_LINE while ( a % i == 0 ) : NEW_LINE INDENT a \/\/= i ; NEW_LINE c += 1 ; NEW_LINE DEDENT if ( a == 1 and Prime ( c + 1 ) ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT DEDENT return True ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 13 ; NEW_LINE if ( primeCountDivisors ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"],"bleu":0.6369491741889238,"rouge_l":0.7821652338627423}
{"id":1183,"predictions":["def countSubSeq ( a , n , k ) : NEW_LINE INDENT a . sort ( ) ; NEW_LINE arr = [ ] ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT count = 1 ; NEW_LINE x = a [ i ] ; NEW_LINE i = 0 ; NEW_LINE while ( i < n and a [ i ] == x ) : NEW_LINE INDENT count += 1 ; NEW_LINE i += 1 ; NEW_LINE DEDENT arr . append ( count ) ; NEW_LINE while ( i < n and a [ i ] == x ) : NEW_LINE INDENT count += 1 ; NEW_LINE i += 1 ; NEW_LINE DEDENT DEDENT m = min ( m , k ) ; NEW_LINE dp = [ [ 0 ] * ( m + 1 ) ] ; NEW_LINE count = 1 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( m + 1 , n + 1 ) : NEW_LINE INDENT if ( j > m - i ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j ] + arr [ i - 1 ] [ j ] ; NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 0 ; NEW_LINE DEDENT DEDENT count = count + dp [ i ] [ 0 ] ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 2 , 2 , 3 , 5 ] ; NEW_LINE n = len ( a ) ; NEW_LINE k = 3 ; NEW_LINE print ( countSubSeq ( a , n , k ) ) ; NEW_LINE DEDENT"],"references":["def countSubSeq ( a , n , k ) : NEW_LINE INDENT a . sort ( reverse = False ) NEW_LINE arr = [ ] NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT count = 1 NEW_LINE x = a [ i ] NEW_LINE i += 1 NEW_LINE while ( i < n and a [ i ] == x ) : NEW_LINE INDENT count += 1 NEW_LINE i += 1 NEW_LINE DEDENT arr . append ( count ) NEW_LINE DEDENT m = len ( arr ) NEW_LINE n = min ( m , k ) NEW_LINE count = 1 NEW_LINE dp = [ [ 0 for i in range ( m + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT j = m NEW_LINE while ( j >= 0 ) : NEW_LINE INDENT if ( j > m - i ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j + 1 ] +   \\ NEW_LINE INDENT arr [ j ] * dp [ i - 1 ] [ j + 1 ] NEW_LINE DEDENT DEDENT j -= 1 NEW_LINE DEDENT count = count + dp [ i ] [ 0 ] NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 2 , 2 , 3 , 3 , 5 ] NEW_LINE n = len ( a ) NEW_LINE k = 3 NEW_LINE print ( countSubSeq ( a , n , k ) ) NEW_LINE DEDENT"],"bleu":0.6731168104946997,"rouge_l":0.7287443111294994}
{"id":1184,"predictions":["def isVowel ( ch ) : NEW_LINE INDENT if ( ch == ' a ' or ch == ' e ' or ch == ' i ' or ch == ' o ' or ch == ' u ' ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def isSuffix ( str , n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( isVowel ( str [ i ] ) and isVowel ( str [ i - 1 ] ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( isVowel ( str [ i - 1 ] ) and isVowel ( str [ i ] ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT str = \" acab \" NEW_LINE n = len ( str ) NEW_LINE if ( isVowel ( str , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def isVowel ( ch ) : NEW_LINE INDENT if ch in [ ' i ' , ' a ' , ' e ' , ' o ' , ' u ' ] : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def isSatisfied ( st , n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( isVowel ( st [ i ] ) == False and isVowel ( st [ i - 1 ] ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( isVowel ( st [ i ] ) and isVowel ( st [ i - 1 ] ) == False and isVowel ( st [ i + 1 ] ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT st = \" acaba \" NEW_LINE n = len ( st ) NEW_LINE if ( isSatisfied ( st , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.6473263600057385,"rouge_l":0.8115409729023833}
{"id":1185,"predictions":["def equal_xor_sum ( arr , n ) : NEW_LINE INDENT Sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum = Sum + arr [ i ] NEW_LINE Xor_sum = Xor_sum ^ arr [ i ] NEW_LINE DEDENT if ( Sum == Xor_sum ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT arr = [ 6 , 3 , 7 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE compare_xor_sum ( arr , n ) NEW_LINE"],"references":["def equal_xor_sum ( arr , n ) : NEW_LINE INDENT Sum = 0 ; NEW_LINE Xor = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum = Sum + arr [ i ] ; NEW_LINE Xor = Xor ^ arr [ i ] ; NEW_LINE DEDENT if ( Sum == Xor ) : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 6 , 3 , 7 , 10 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE equal_xor_sum ( arr , n ) ; NEW_LINE DEDENT"],"bleu":0.5951139314410984,"rouge_l":0.8265582655826557}
{"id":1186,"predictions":["def getMinLength ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE result = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( count != 0 ) : NEW_LINE INDENT result = min ( result , count ) NEW_LINE count = 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( count != 0 ) : NEW_LINE INDENT result = min ( result , count ) NEW_LINE count = 0 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT arr = [ 1 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( getMinLength ( arr , n ) ) NEW_LINE"],"references":["import sys NEW_LINE def getMinLength ( arr , n ) : NEW_LINE INDENT count = 0 ; NEW_LINE result = sys . maxsize ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( count != 0 ) : NEW_LINE INDENT result = min ( result , count ) ; NEW_LINE DEDENT count = 0 ; NEW_LINE DEDENT DEDENT return result ; NEW_LINE DEDENT arr = [ 1 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 1 , 1 , 1 , 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( getMinLength ( arr , n ) ) ; NEW_LINE"],"bleu":0.7071146381468109,"rouge_l":0.8571757659525454}
{"id":1187,"predictions":["def isPowerOfTwo ( n ) : NEW_LINE INDENT return ( n and ( not ( n & ( n - 1 ) ) ) ) NEW_LINE DEDENT def findPosition ( n ) : NEW_LINE INDENT if ( not isPowerOfTwo ( n ) ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT i = 1 NEW_LINE j = 1 NEW_LINE while ( ( i & n ) == 0 ) : NEW_LINE INDENT i = i >> 1 NEW_LINE j += 1 NEW_LINE DEDENT return pos NEW_LINE DEDENT n = 16 NEW_LINE pos = findPosition ( n ) NEW_LINE if ( pos == - 1 ) : NEW_LINE INDENT print ( \" n ▁ = \" , n , \" , ▁ Invalid ▁ number \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" n ▁ = \" , n , \" , ▁ Invalid ▁ number \" ) NEW_LINE DEDENT n = 12 NEW_LINE pos = findPosition ( n ) NEW_LINE if ( pos == - 1 ) : NEW_LINE INDENT print ( \" n ▁ = \" , n , \" , ▁ Invalid ▁ number \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" n ▁ = ▁ \" , n , \" , ▁ Invalid ▁ number \" ) NEW_LINE DEDENT n = 128 NEW_LINE pos = findPosition ( n ) NEW_LINE if ( pos == - 1 ) : NEW_LINE INDENT print ( \" n ▁ = ▁ \" , pos ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" n ▁ = ▁ \" , n , \" , ▁ Invalid ▁ number \" ) NEW_LINE DEDENT"],"references":["def isPowerOfTwo ( n ) : NEW_LINE INDENT return ( True if ( n > 0 and ( ( n & ( n - 1 ) ) > 0 ) ) else False ) ; NEW_LINE DEDENT def findPosition ( n ) : NEW_LINE INDENT if ( isPowerOfTwo ( n ) == True ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT i = 1 ; NEW_LINE pos = 1 ; NEW_LINE while ( ( i & n ) == 0 ) : NEW_LINE INDENT i = i << 1 ; NEW_LINE pos += 1 ; NEW_LINE DEDENT return pos ; NEW_LINE DEDENT n = 16 ; NEW_LINE pos = findPosition ( n ) ; NEW_LINE if ( pos == - 1 ) : NEW_LINE INDENT print ( \" n ▁ = \" , n , \" , ▁ Invalid ▁ number \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" n ▁ = \" , n , \" , ▁ Position ▁ \" , pos ) ; NEW_LINE DEDENT n = 12 ; NEW_LINE pos = findPosition ( n ) ; NEW_LINE if ( pos == - 1 ) : NEW_LINE INDENT print ( \" n ▁ = \" , n , \" , ▁ Invalid ▁ number \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" n ▁ = \" , n , \" , ▁ Position ▁ \" , pos ) ; NEW_LINE DEDENT n = 128 ; NEW_LINE pos = findPosition ( n ) ; NEW_LINE if ( pos == - 1 ) : NEW_LINE INDENT print ( \" n ▁ = \" , n , \" , ▁ Invalid ▁ number \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" n ▁ = \" , n , \" , ▁ Position ▁ \" , pos ) ; NEW_LINE DEDENT"],"bleu":0.688942006079846,"rouge_l":0.8767348730045533}
{"id":1188,"predictions":["def totalNumber ( n ) : NEW_LINE INDENT return 8 * pow ( 9 , n - 1 ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 ; NEW_LINE print ( totalNumber ( n ) ) ; NEW_LINE DEDENT"],"references":["def totalNumber ( n ) : NEW_LINE INDENT return 8 * pow ( 9 , n - 1 ) ; NEW_LINE DEDENT n = 3 NEW_LINE print ( totalNumber ( n ) ) NEW_LINE"],"bleu":0.5965372531286091,"rouge_l":0.8383185125303153}
{"id":1189,"predictions":["def reversDigits ( num ) : NEW_LINE INDENT if ( num > 0 ) : NEW_LINE INDENT reversDigits ( num \/\/ 10 ) ; NEW_LINE rev_num = 1 ; NEW_LINE DEDENT return rev_num ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT num = 4562 ; NEW_LINE print ( reversDigits ( num ) ) ; NEW_LINE DEDENT"],"references":["rev_num = 0 NEW_LINE base_pos = 1 NEW_LINE def reversDigits ( num ) : NEW_LINE INDENT global rev_num NEW_LINE global base_pos NEW_LINE if ( num > 0 ) : NEW_LINE INDENT reversDigits ( ( int ) ( num \/ 10 ) ) NEW_LINE rev_num += ( num % 10 ) * base_pos NEW_LINE base_pos *= 10 NEW_LINE DEDENT return rev_num NEW_LINE DEDENT num = 4562 NEW_LINE print ( \" Reverse ▁ of ▁ no . ▁ is ▁ \" , reversDigits ( num ) ) NEW_LINE"],"bleu":0.31796285599310975,"rouge_l":0.5455706984667803}
{"id":1190,"predictions":["def check ( s ) : NEW_LINE INDENT l = len ( s ) ; NEW_LINE s = sorted ( s ) ; NEW_LINE for i in range ( 1 , l ) : NEW_LINE INDENT if ( s [ i ] - s [ i - 1 ] != 1 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" dtype \" ; NEW_LINE if ( check ( str ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"],"references":["def check ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE s = ' ' . join ( sorted ( s ) ) NEW_LINE for i in range ( 1 , l ) : NEW_LINE INDENT if ord ( s [ i ] ) - ord ( s [ i - 1 ] ) != 1 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" dcef \" NEW_LINE if check ( string ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT string = \" xyza \" NEW_LINE if check ( string ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.5177041917644157,"rouge_l":0.7661697382321868}
{"id":1191,"predictions":["def maxDeps ( n ) : NEW_LINE INDENT num = n * ( n + 1 ) \/\/ 2 NEW_LINE print ( num ) NEW_LINE DEDENT n = 10 NEW_LINE maxDeps ( n ) NEW_LINE"],"references":["def maxRegions ( n ) : NEW_LINE INDENT num = n * ( n + 1 ) \/\/ 2 + 1 NEW_LINE print ( num ) NEW_LINE DEDENT n = 10 NEW_LINE maxRegions ( n ) NEW_LINE"],"bleu":0.7809731740090301,"rouge_l":0.9120978704123243}
{"id":1192,"predictions":["def best1100 ( x , y ) : NEW_LINE INDENT n = len ( x ) NEW_LINE m = 0 NEW_LINE sum_x = 0 NEW_LINE c = 0 NEW_LINE sum_y = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum_x += x [ i ] NEW_LINE sum_x += y [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT sum_x += x [ i ] NEW_LINE sum_x += x [ i ] NEW_LINE DEDENT m = int ( n * sum_x - m ) \/ n NEW_LINE c = int ( ( n * sum_x - m ) \/ n ( sum_x - sum_y ) ) NEW_LINE m = int ( ( n * sum_x ) \/ n ) NEW_LINE print ( \" c ▁ = \" , round ( m , c ) ) NEW_LINE DEDENT x = [ 1 , 2 , 3 , 4 , 56 ] NEW_LINE y = [ 14 , 27 , 55 ] NEW_LINE best1100 ( x , y ) NEW_LINE"],"references":["def bestApproximate ( x , y , n ) : NEW_LINE INDENT sum_x = 0 NEW_LINE sum_y = 0 NEW_LINE sum_xy = 0 NEW_LINE sum_x2 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum_x += x [ i ] NEW_LINE sum_y += y [ i ] NEW_LINE sum_xy += x [ i ] * y [ i ] NEW_LINE sum_x2 += pow ( x [ i ] , 2 ) NEW_LINE DEDENT m = ( float ) ( ( n * sum_xy - sum_x * sum_y ) \/ ( n * sum_x2 - pow ( sum_x , 2 ) ) ) ; NEW_LINE c = ( float ) ( sum_y - m * sum_x ) \/ n ; NEW_LINE print ( \" m ▁ = ▁ \" , m ) ; NEW_LINE print ( \" c ▁ = ▁ \" , c ) ; NEW_LINE DEDENT x = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE y = [ 14 , 27 , 40 , 55 , 68 ] NEW_LINE n = len ( x ) NEW_LINE bestApproximate ( x , y , n ) NEW_LINE"],"bleu":0.486779463452302,"rouge_l":0.6620647738126247}
{"id":1193,"predictions":["def printPrevgreater ( arr , n ) : NEW_LINE INDENT ls = [ ] ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT c = ls [ arr [ i ] ] ; NEW_LINE if ( c == None ) : NEW_LINE INDENT print ( \" - 1\" , end = \" ▁ \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ arr [ i ] ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT print ( ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 10 , 5 , 11 , 10 , 20 , 12 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE printPrevGreater ( arr , n ) ; NEW_LINE DEDENT"],"references":["def printPrevGreater ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT it = [ x for x in s if x >= arr [ i ] ] NEW_LINE if len ( it ) == 0 : NEW_LINE INDENT print ( \" - 1\" , end = \" ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( min ( it ) , end = \" ▁ \" ) NEW_LINE DEDENT s . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 10 , 5 , 11 , 10 , 20 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE printPrevGreater ( arr , n ) NEW_LINE DEDENT"],"bleu":0.5899870977049989,"rouge_l":0.7771600648598563}
{"id":1194,"predictions":["from math import sqrt NEW_LINE MAX = 100000 NEW_LINE prime = [ True ] * MAX ; NEW_LINE def seive ( N ) : NEW_LINE INDENT prime [ 0 ] = False ; NEW_LINE prime [ 1 ] = False ; NEW_LINE for i in range ( 2 , int ( sqrt ( N ) ) + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT for j in range ( 2 , N , i ) : NEW_LINE INDENT prime [ j ] = False ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def countPath ( N ) : NEW_LINE INDENT prime = 0 ; NEW_LINE seive ( N ) ; NEW_LINE seive ( N ) ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT count = count + 1 ; NEW_LINE for j in range ( 2 , N + 1 , i ) : NEW_LINE INDENT if ( prime [ j ] and prime [ j ] ) : NEW_LINE INDENT count = count + 1 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 6 ; NEW_LINE seive ( N ) ; NEW_LINE DEDENT"],"references":["MAX = 1000005 NEW_LINE prime = [ True for i in range ( MAX ) ] NEW_LINE def seive ( N ) : NEW_LINE INDENT prime [ 0 ] , prime [ 1 ] = False , False NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT for j in range ( 2 , N + 1 ) : NEW_LINE INDENT if ( i * j > N ) : NEW_LINE INDENT break NEW_LINE DEDENT prime [ i * j ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def countLogNeeded ( N ) : NEW_LINE INDENT count = 0 NEW_LINE seive ( N ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 6 NEW_LINE print ( countLogNeeded ( N ) ) NEW_LINE DEDENT"],"bleu":0.5658588906584209,"rouge_l":0.7327177643405784}
{"id":1195,"predictions":["import sys NEW_LINE def findMinimum ( n , d , arr ) : NEW_LINE INDENT cnt = 0 NEW_LINE first = - sys . maxsize NEW_LINE second = - sys . maxsize NEW_LINE first = - sys . maxsize NEW_LINE second = - sys . maxsize NEW_LINE while ( n > 0 ) : NEW_LINE INDENT arr [ i ] , arr [ i ] = arr [ i ] , arr [ i ] NEW_LINE cnt += 1 NEW_LINE DEDENT arr = min ( first , arr ) NEW_LINE if ( first > second and d <= first ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE return NEW_LINE DEDENT elif ( first > second and d <= first ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( min ( abs ( first - d ) , abs ( d ) , abs ( d - second ) ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE d = 3 NEW_LINE arr = [ [ 0 , 7 ] , [ 2 , 14 ] , [ 4 , 6 ] ] NEW_LINE findMinimum ( n , d , arr ) NEW_LINE DEDENT"],"references":["def findMinimumOperation ( n , d , arrays ) : NEW_LINE INDENT cnt = 0 NEW_LINE first = - 10 ** 9 NEW_LINE end = 10 ** 9 NEW_LINE while ( n ) : NEW_LINE INDENT arr = [ arrays [ cnt ] [ 0 ] , arrays [ cnt ] [ 1 ] ] NEW_LINE arr = sorted ( arr ) NEW_LINE first = max ( first , arr [ 0 ] ) NEW_LINE end = min ( end , arr [ 1 ] ) NEW_LINE cnt += 1 NEW_LINE n -= 1 NEW_LINE DEDENT if ( first > end ) : NEW_LINE INDENT print ( \" - 1\" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( d >= first and d <= end ) : NEW_LINE INDENT print ( \"0\" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( min ( abs ( first - d ) , abs ( d - end ) ) , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE d = 3 NEW_LINE arrays = [ [ 0 , 7 ] , [ 2 , 14 ] , [ 4 , 6 ] ] NEW_LINE findMinimumOperation ( n , d , arrays ) NEW_LINE DEDENT"],"bleu":0.535288635896596,"rouge_l":0.6779747203254394}
{"id":1196,"predictions":["MAX = 45 NEW_LINE arr1 = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE arr2 = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE index1 = 0 NEW_LINE arr2 . sort ( ) NEW_LINE for i in range ( 0 , MAX ) : NEW_LINE INDENT arr3 = arr1 [ i - 1 ] NEW_LINE arr3 [ i ] = arr2 [ i - 2 ] + arr1 [ i ] NEW_LINE DEDENT c1 = 0 NEW_LINE c2 = 0 NEW_LINE for i in range ( 0 , MAX ) : NEW_LINE INDENT if ( arr1 [ i ] % 2 == 0 ) : NEW_LINE INDENT index1 += 1 NEW_LINE DEDENT if ( arr1 [ i ] % 2 == 0 ) : NEW_LINE INDENT if ( arr2 [ i ] % 2 == 0 ) : NEW_LINE INDENT index2 += 1 NEW_LINE DEDENT DEDENT DEDENT if ( arr1 [ i ] % 2 == 0 ) : NEW_LINE INDENT index3 += 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , c1 ) : NEW_LINE INDENT if ( arr2 [ i ] % 8 == 0 ) : NEW_LINE INDENT index1 += 1 NEW_LINE DEDENT DEDENT if ( arr3 [ i ] % 8 == 0 ) : NEW_LINE INDENT index = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( index1 % 8 == 0 ) : NEW_LINE INDENT for i in range ( 0 , c2 ) : NEW_LINE INDENT print ( index1 , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr1 = [ ] NEW_LINE index1 = 0 NEW_LINE for i in range ( 0 , c1 ) : NEW_LINE INDENT if ( arr2 [ i ] % 2 != 0 ) : NEW_LINE INDENT print ( index1 , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT"],"references":["MAX = 90 ; NEW_LINE arr = [ 0 ] * ( MAX ) ; NEW_LINE index1 = [ 0 ] * ( MAX ) ; NEW_LINE index2 = [ 0 ] * ( MAX ) ; NEW_LINE index3 = [ 0 ] * ( MAX ) ; NEW_LINE index4 = [ 0 ] * ( MAX ) ; NEW_LINE arr [ 0 ] = 0 ; NEW_LINE arr [ 1 ] = 1 ; NEW_LINE for i in range ( 2 , MAX ) : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] + arr [ i - 2 ] ; NEW_LINE DEDENT c1 , c2 , c3 , c4 = 0 , 0 , 0 , 0 ; NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT index1 [ c1 ] = i ; NEW_LINE c1 += 1 ; NEW_LINE DEDENT if ( arr [ i ] % 3 == 0 ) : NEW_LINE INDENT index2 [ c2 ] = i ; NEW_LINE c2 += 1 ; NEW_LINE DEDENT if ( arr [ i ] % 5 == 0 ) : NEW_LINE INDENT index3 [ c3 ] = i ; NEW_LINE c3 += 1 ; NEW_LINE DEDENT if ( arr [ i ] % 8 == 0 ) : NEW_LINE INDENT index4 [ c4 ] = i ; NEW_LINE c4 += 1 ; NEW_LINE DEDENT DEDENT print ( \" Index ▁ of ▁ Fibonacci ▁ numbers \" , \" divisible ▁ by ▁ 2 ▁ are ▁ : \" ) ; NEW_LINE for i in range ( c1 ) : NEW_LINE INDENT print ( index1 [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( \" \" ) ; NEW_LINE print ( \" Index ▁ of ▁ Fibonacci ▁ number \" , \" divisible ▁ by ▁ 3 ▁ are ▁ : \" ) ; NEW_LINE for i in range ( c2 ) : NEW_LINE INDENT print ( index2 [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( \" \" ) ; NEW_LINE print ( \" Index ▁ of ▁ Fibonacci ▁ number \" , \" divisible ▁ by ▁ 5 ▁ are ▁ : \" ) ; NEW_LINE for i in range ( c3 ) : NEW_LINE INDENT print ( index3 [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( \" \" ) ; NEW_LINE print ( \" Index ▁ of ▁ Fibonacci ▁ number \" , \" divisible ▁ by ▁ 8 ▁ are ▁ : \" ) ; NEW_LINE for i in range ( c4 ) : NEW_LINE INDENT print ( index4 [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( \" \" ) ; NEW_LINE"],"bleu":0.25458004784258076,"rouge_l":0.4651441842461777}
{"id":1197,"predictions":["def check ( s ) : NEW_LINE INDENT freq = [ 0 for i in range ( 26 ) ] NEW_LINE n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - 97 ] += 1 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( freq [ i ] % 2 == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT s = \" abaccaba \" NEW_LINE if ( check ( s ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def check ( s ) : NEW_LINE INDENT freq = [ 0 ] * 26 NEW_LINE n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - 97 ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( freq [ i ] % 2 == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT s = \" abaccaba \" NEW_LINE if ( check ( s ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.8939698588250949,"rouge_l":0.9482292511489593}
{"id":1198,"predictions":["def getMinMax ( arr , low , high ) : NEW_LINE INDENT mn = min ( arr ) NEW_LINE mx = 0 NEW_LINE while ( low < high ) : NEW_LINE INDENT if ( arr [ low ] == arr [ high ] ) : NEW_LINE INDENT mx = max ( mn , arr [ low ] ) NEW_LINE mn = min ( arr [ low ] , arr [ high ] ) NEW_LINE mn = min ( mn , arr [ low ] ) NEW_LINE DEDENT if ( mn == low + 1 ) : NEW_LINE INDENT mn = mx NEW_LINE mn = min ( mn , arr [ high ] ) NEW_LINE mx = min ( mn , arr [ 0 ] ) NEW_LINE mn = min ( mn , arr [ 0 ] ) NEW_LINE mn = min ( mn , arr [ 0 ] ) NEW_LINE mn = min ( mn , mx ) NEW_LINE if ( mn < mn ) : NEW_LINE INDENT mn = mx NEW_LINE mr = mn NEW_LINE DEDENT else : NEW_LINE INDENT mn = mx NEW_LINE mn = mx NEW_LINE DEDENT DEDENT return min ( mn , mn ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1000 , 11 , 445 , 3000 ] NEW_LINE arr_size = getMinMax ( arr , 0 , arr_size - 1 ) NEW_LINE print ( \" Minimum ▁ element ▁ is \" , min ( arr_size , arr_size - 1 ) ) NEW_LINE DEDENT"],"references":["def getMinMax ( low , high , arr ) : NEW_LINE INDENT arr_max = arr [ low ] NEW_LINE arr_min = arr [ low ] NEW_LINE if low == high : NEW_LINE INDENT arr_max = arr [ low ] NEW_LINE arr_min = arr [ low ] NEW_LINE return ( arr_max , arr_min ) NEW_LINE DEDENT elif high == low + 1 : NEW_LINE INDENT if arr [ low ] > arr [ high ] : NEW_LINE INDENT arr_max = arr [ low ] NEW_LINE arr_min = arr [ high ] NEW_LINE DEDENT else : NEW_LINE INDENT arr_max = arr [ high ] NEW_LINE arr_min = arr [ low ] NEW_LINE DEDENT return ( arr_max , arr_min ) NEW_LINE DEDENT else : NEW_LINE INDENT mid = int ( ( low + high ) \/ 2 ) NEW_LINE arr_max1 , arr_min1 = getMinMax ( low , mid , arr ) NEW_LINE arr_max2 , arr_min2 = getMinMax ( mid + 1 , high , arr ) NEW_LINE DEDENT return ( max ( arr_max1 , arr_max2 ) , min ( arr_min1 , arr_min2 ) ) NEW_LINE DEDENT arr = [ 1000 , 11 , 445 , 1 , 330 , 3000 ] NEW_LINE high = len ( arr ) - 1 NEW_LINE low = 0 NEW_LINE arr_max , arr_min = getMinMax ( low , high , arr ) NEW_LINE print ( ' Minimum ▁ element ▁ is ▁ ' , arr_min ) NEW_LINE print ( ' nMaximum ▁ element ▁ is ▁ ' , arr_max ) NEW_LINE"],"bleu":0.27009514365475296,"rouge_l":0.4697426682923699}
{"id":1199,"predictions":["def countUncoverable ( n , m ) : NEW_LINE INDENT X = ( m * n - m ) NEW_LINE q = [ ] NEW_LINE count = 0 NEW_LINE while ( not q ) : NEW_LINE INDENT curr = q [ 0 ] - m NEW_LINE if ( curr - m > 0 ) : NEW_LINE INDENT q . append ( curr - m ) NEW_LINE count += 1 NEW_LINE DEDENT if ( curr - m > 0 ) : NEW_LINE INDENT q . append ( curr ) NEW_LINE q . append ( curr ) NEW_LINE DEDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 2 NEW_LINE m = 5 NEW_LINE print ( countUncoverable ( n , m ) ) NEW_LINE DEDENT"],"references":["def countUnvisited ( n , m ) : NEW_LINE INDENT i = 0 NEW_LINE X = ( m * n ) - m - n NEW_LINE queue = [ ] NEW_LINE queue . append ( X ) NEW_LINE count = 0 NEW_LINE while ( len ( queue ) > 0 ) : NEW_LINE INDENT curr = queue [ 0 ] NEW_LINE queue . remove ( queue [ 0 ] ) NEW_LINE count += 1 NEW_LINE if ( curr - m > 0 ) : NEW_LINE INDENT queue . append ( curr - m ) NEW_LINE DEDENT if ( curr - n > 0 ) : NEW_LINE INDENT queue . append ( curr - n ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 2 NEW_LINE m = 5 NEW_LINE print ( countUnvisited ( n , m ) ) NEW_LINE DEDENT"],"bleu":0.6133464026634033,"rouge_l":0.7528352234823216}
{"id":1200,"predictions":["if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT c = 65 NEW_LINE for c in range ( 65 , 90 ) : NEW_LINE INDENT for c in range ( c , 100 ) : NEW_LINE INDENT print ( c , end = \" ▁ \" ) NEW_LINE DEDENT print ( \" ) NEW_LINE print ( ) NEW_LINE DEDENT DEDENT"],"references":["def lowercaseAlphabets ( ) : NEW_LINE INDENT for c in range ( 97 , 123 ) : NEW_LINE INDENT print ( chr ( c ) , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( \" \" ) ; NEW_LINE DEDENT def uppercaseAlphabets ( ) : NEW_LINE INDENT for c in range ( 65 , 91 ) : NEW_LINE INDENT print ( chr ( c ) , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( \" \" ) ; NEW_LINE DEDENT print ( \" Uppercase ▁ Alphabets \" ) ; NEW_LINE uppercaseAlphabets ( ) ; NEW_LINE print ( \" Lowercase ▁ Alphabets ▁ \" ) ; NEW_LINE lowercaseAlphabets ( ) ; NEW_LINE"],"bleu":0.22365419520796848,"rouge_l":0.4618031658637302}
{"id":1201,"predictions":["def countNums ( a , b , c , d ) : NEW_LINE INDENT x = b \/\/ c NEW_LINE y = b \/\/ c NEW_LINE z = ( c \/\/ d ) NEW_LINE return ( ( c * d ) \/\/ ( a - 1 ) \/\/ d ) NEW_LINE DEDENT def countNums ( a , b , c , d ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return ( c \/\/ a ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a , b , c , d = 10 , 4 , 6 NEW_LINE print ( countNums ( a , b , c , d ) ) NEW_LINE DEDENT"],"references":["from math import gcd NEW_LINE def countNums ( a , b , c , d ) : NEW_LINE INDENT x = b \/\/ c - ( a - 1 ) \/\/ c ; NEW_LINE y = b \/\/ d - ( a - 1 ) \/\/ d ; NEW_LINE k = ( c * d ) \/\/ gcd ( c , d ) ; NEW_LINE z = b \/\/ k - ( a - 1 ) \/\/ k ; NEW_LINE return ( b - a + 1 - x - y + z ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 10 ; b = 50 ; c = 4 ; d = 6 ; NEW_LINE print ( countNums ( a , b , c , d ) ) ; NEW_LINE DEDENT"],"bleu":0.4948659419681889,"rouge_l":0.6119670369043354}
{"id":1202,"predictions":["def countSubarray ( array , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if ( sum + array [ j ] < k ) : NEW_LINE INDENT sum = arr [ j ] + sum NEW_LINE count = count + 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT array = [ 1 , 11 , 2 , 3 , 15 ] NEW_LINE k = 10 NEW_LINE size = len ( array ) NEW_LINE count = countSubarray ( array , size , k ) NEW_LINE print ( countSubarray ( array , size , k ) ) NEW_LINE"],"references":["def countSubarray ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if ( sum + arr [ j ] < k ) : NEW_LINE INDENT sum = arr [ j ] + sum NEW_LINE count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT array = [ 1 , 11 , 2 , 3 , 15 ] NEW_LINE k = 10 NEW_LINE size = len ( array ) NEW_LINE count = countSubarray ( array , size , k ) ; NEW_LINE print ( count ) NEW_LINE"],"bleu":0.813243450731423,"rouge_l":0.9185594177437568}
{"id":1203,"predictions":["def printPattern ( n ) : NEW_LINE INDENT if ( n == 0 or n < 0 ) : NEW_LINE INDENT print ( n , end = \" ▁ \" ) ; NEW_LINE return ; NEW_LINE DEDENT return ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 16 ; NEW_LINE printPattern ( n - 5 ) ; NEW_LINE DEDENT"],"references":["def printPattern ( n ) : NEW_LINE INDENT if ( n == 0 or n < 0 ) : NEW_LINE INDENT print ( n , end = \" , ▁ \" ) NEW_LINE return NEW_LINE DEDENT print ( n , end = \" , ▁ \" ) NEW_LINE printPattern ( n - 5 ) NEW_LINE print ( n , end = \" , ▁ \" ) NEW_LINE DEDENT n = 16 NEW_LINE printPattern ( n ) NEW_LINE"],"bleu":0.4984510389853544,"rouge_l":0.6547406082289803}
{"id":1204,"predictions":["MAX = 100 NEW_LINE def countCommon ( mat , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if mat [ i ] [ n - i - 1 ] == mat [ i ] [ n - i - 1 ] : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT mat = [ [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 9 , 9 ] ] NEW_LINE print ( countCommon ( mat , 3 ) ) NEW_LINE"],"references":["Max = 100 NEW_LINE def countCommon ( mat , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] : NEW_LINE INDENT res = res + 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT mat = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE print ( countCommon ( mat , 3 ) ) NEW_LINE"],"bleu":0.8681905869139801,"rouge_l":0.9390635022450291}
{"id":1205,"predictions":["import sys NEW_LINE def getMinimum ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE size = len ( arr ) NEW_LINE small = max ( arr ) NEW_LINE dp = [ [ 0 for i in range ( size + 1 ) ] for j in range ( size + 1 ) ] NEW_LINE dp [ 0 ] [ j ] = abs ( arr [ 0 ] ) NEW_LINE for i in range ( 1 , size + 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = abs ( arr [ i ] - j ) NEW_LINE DEDENT for i in range ( 1 , size + 1 ) : NEW_LINE INDENT minimum = min ( minimum , dp [ i - 1 ] [ j ] ) NEW_LINE dp [ i ] [ j ] = minimum + abs ( arr [ i ] - j ) NEW_LINE DEDENT ans = 10 ** 9 NEW_LINE for j in range ( size + 1 ) : NEW_LINE INDENT ans = min ( ans , dp [ n - 1 ] [ j ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT arr = [ [ 1 , 2 , 1 , 4 ] , [ ] NEW_LINE print ( getMinimum ( arr ) ) NEW_LINE"],"references":["def getMinimumOps ( ar ) : NEW_LINE INDENT n = len ( ar ) NEW_LINE small = min ( ar ) NEW_LINE large = max ( ar ) NEW_LINE dp = [ [ 0 for i in range ( large + 1 ) ] for i in range ( n ) ] NEW_LINE for j in range ( small , large + 1 ) : NEW_LINE INDENT dp [ 0 ] [ j ] = abs ( ar [ 0 ] - j ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT minimum = 10 ** 9 NEW_LINE for j in range ( small , large + 1 ) : NEW_LINE INDENT minimum = min ( minimum , dp [ i - 1 ] [ j ] ) NEW_LINE dp [ i ] [ j ] = minimum + abs ( ar [ i ] - j ) NEW_LINE DEDENT DEDENT ans = 10 ** 9 NEW_LINE for j in range ( small , large + 1 ) : NEW_LINE INDENT ans = min ( ans , dp [ n - 1 ] [ j ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT ar = [ 1 , 2 , 1 , 4 , 3 ] NEW_LINE print ( getMinimumOps ( ar ) ) NEW_LINE"],"bleu":0.6768061631781477,"rouge_l":0.7979454585766018}
{"id":1206,"predictions":["def find ( s1 , len2 ) : NEW_LINE INDENT l = len ( s1 ) NEW_LINE len_1 = len ( s2 ) NEW_LINE d = [ 0 ] * l NEW_LINE for i in range ( 1 , l ) : NEW_LINE INDENT if ( s1 [ i ] > s2 [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT d [ ord ( s1 [ i ] ) - ord ( ' a ' ) ] = s2 [ i ] - ord ( ' a ' ) ] = ord ( s2 [ i ] ) - ord ( '0' ) NEW_LINE DEDENT for i in range ( l - 1 ) : NEW_LINE INDENT if ( d [ i ] > d [ i + 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT d [ i ] = d [ i ] NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT s1 = \" abcd \" NEW_LINE s2 = \" bcdd \" NEW_LINE if ( find ( s1 , s2 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def find ( s1 , s2 ) : NEW_LINE INDENT len__ = len ( s1 ) NEW_LINE len_1 = len ( s2 ) NEW_LINE if ( len__ != len_1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT d = [ 0 for i in range ( len__ ) ] NEW_LINE d [ 0 ] = ord ( s2 [ 0 ] ) - ord ( s1 [ 0 ] ) NEW_LINE for i in range ( 1 , len__ , 1 ) : NEW_LINE INDENT if ( s1 [ i ] > s2 [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT d [ i ] = ord ( s2 [ i ] ) - ord ( s1 [ i ] ) NEW_LINE DEDENT DEDENT for i in range ( len__ - 1 ) : NEW_LINE INDENT if ( d [ i ] < d [ i + 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s1 = \" abcd \" NEW_LINE s2 = \" bcdd \" NEW_LINE if ( find ( s1 , s2 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.6947558714163911,"rouge_l":0.7202376475896819}
{"id":1207,"predictions":["def solveQuery ( start , end , arr ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT if ( mp [ arr [ i ] ] == product ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( mp [ arr [ i ] ] == product ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 1 , 2 , 3 , 3 ] NEW_LINE n = len ( A ) NEW_LINE queries = [ [ 0 , 1 , 3 ] , [ 0 , 2 , 5 ] ] NEW_LINE q = len ( queries ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT start = queries [ i ] [ 0 ] NEW_LINE end = queries [ i ] [ 1 ] NEW_LINE DEDENT for i in range ( q ) : NEW_LINE INDENT start = queries [ i ] [ 1 ] NEW_LINE if ( query [ i ] [ 0 ] == query [ i ] [ 0 ] ) : NEW_LINE INDENT print ( \" Answer ▁ = \" , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT"],"references":["import math as mt NEW_LINE def solveQuery ( start , end , arr ) : NEW_LINE INDENT frequency = dict ( ) NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT if arr [ i ] in frequency . keys ( ) : NEW_LINE INDENT frequency [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT frequency [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for x in frequency : NEW_LINE INDENT if x == frequency [ x ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT A = [ 1 , 2 , 2 , 3 , 3 , 3 ] NEW_LINE n = len ( A ) NEW_LINE queries = [ [ 0 , 1 ] , [ 1 , 1 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 3 , 5 ] , [ 0 , 5 ] ] NEW_LINE q = len ( queries ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT start = queries [ i ] [ 0 ] NEW_LINE end = queries [ i ] [ 1 ] NEW_LINE print ( \" Answer ▁ for ▁ Query ▁ \" , ( i + 1 ) , \" ▁ = ▁ \" , solveQuery ( start , end , A ) ) NEW_LINE DEDENT"],"bleu":0.6048338356651073,"rouge_l":0.6353745107145226}
{"id":1208,"predictions":["def solve ( N , K ) : NEW_LINE INDENT combo = [ 0 for i in range ( 50 ) ] NEW_LINE combo [ 0 ] = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 0 , N + 1 ) : NEW_LINE INDENT if ( j >= N ) : NEW_LINE INDENT combo [ j ] += combo [ j - i ] NEW_LINE DEDENT DEDENT DEDENT return combo NEW_LINE DEDENT N = 29 NEW_LINE K = 5 NEW_LINE print ( solve ( N , K ) ) NEW_LINE"],"references":["def solve ( N , K ) : NEW_LINE INDENT combo = [ 0 ] * ( N + 1 ) NEW_LINE combo [ 0 ] = 1 NEW_LINE for i in range ( 1 , K + 1 ) : NEW_LINE INDENT for j in range ( 0 , N + 1 ) : NEW_LINE INDENT if j >= i : NEW_LINE INDENT combo [ j ] += combo [ j - i ] NEW_LINE DEDENT DEDENT DEDENT return combo [ N ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N , K = 29 , 5 NEW_LINE print ( solve ( N , K ) ) NEW_LINE DEDENT"],"bleu":0.6800155057558981,"rouge_l":0.8106016355140186}
{"id":1209,"predictions":["def find ( vroo ) : NEW_LINE INDENT ans = [ ] NEW_LINE n = len ( vro ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT while ( V >= 0 ) : NEW_LINE INDENT while ( V >= den ) : NEW_LINE INDENT v -= den NEW_LINE ans . append ( v [ i ] ) NEW_LINE ans . append ( v [ i ] ) NEW_LINE n = v [ i ] NEW_LINE DEDENT DEDENT DEDENT DEDENT def findMin ( v ) : NEW_LINE INDENT ans = [ ] NEW_LINE for i in range ( len ( ans ) ) : NEW_LINE INDENT while ( V [ i ] >= sys . maxsize ) : NEW_LINE INDENT ans . append ( v [ i ] ) NEW_LINE v [ i ] = v [ i ] NEW_LINE DEDENT DEDENT print ( \" Following ▁ number ▁ of ▁ \" , ans [ : : - 1 ] , \" : ▁ \" , ans [ : : - 1 ] , \" : \" , end = \" \" ) NEW_LINE findMin ( vo ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 241 NEW_LINE findMin ( n ) NEW_LINE DEDENT"],"references":["def findMin ( V ) : NEW_LINE INDENT deno = [ 1 , 2 , 5 , 10 , 20 , 50 , 100 , 500 , 1000 ] NEW_LINE n = len ( deno ) NEW_LINE ans = [ ] NEW_LINE i = n - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT while ( V >= deno [ i ] ) : NEW_LINE INDENT V -= deno [ i ] NEW_LINE ans . append ( deno [ i ] ) NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT for i in range ( len ( ans ) ) : NEW_LINE INDENT print ( ans [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 93 NEW_LINE print ( \" Following ▁ is ▁ minimal ▁ number \" , \" of ▁ change ▁ for \" , n , \" : ▁ \" , end = \" \" ) NEW_LINE findMin ( n ) NEW_LINE DEDENT"],"bleu":0.4007101111148874,"rouge_l":0.5440526798366259}
{"id":1210,"predictions":["def checkPalindrome ( num ) : NEW_LINE INDENT str1 = str ( num ) NEW_LINE l = len ( num ) - 1 NEW_LINE r = len ( str1 ) NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( str1 [ l ] != str1 [ r ] ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE return NEW_LINE DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT return ( l ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 19 NEW_LINE k = 3 NEW_LINE checkPalindrome ( n ) NEW_LINE DEDENT"],"references":["def checkPalindrome ( num ) : NEW_LINE INDENT string = str ( num ) NEW_LINE l = 0 NEW_LINE r = len ( string ) - 1 ; NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( string [ l ] != string [ r ] ) : NEW_LINE INDENT print ( \" No \" ) NEW_LINE return ; NEW_LINE DEDENT l = l + 1 ; NEW_LINE r = r - 1 ; NEW_LINE DEDENT print ( \" Yes \" ) NEW_LINE return ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 19 NEW_LINE k = 3 NEW_LINE checkPalindrome ( n + k ) ; NEW_LINE DEDENT"],"bleu":0.5741091284815366,"rouge_l":0.7848463187991422}
{"id":1211,"predictions":["def updateArray ( arr , n ) : NEW_LINE INDENT for i in range ( n - 2 ) : NEW_LINE INDENT arr [ i + 1 ] = arr [ i ] NEW_LINE DEDENT arr [ n - 1 ] = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 5 , 1 , 3 , 2 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE updateArray ( arr , N ) NEW_LINE DEDENT"],"references":["def updateArray ( arr , n ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT arr [ i ] = arr [ i + 1 ] NEW_LINE DEDENT arr [ n - 1 ] = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 5 , 1 , 3 , 2 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE updateArray ( arr , N ) NEW_LINE DEDENT"],"bleu":0.9638834692015235,"rouge_l":0.9734513274336283}
{"id":1212,"predictions":["def maxProduct ( arr , n ) : NEW_LINE INDENT if ( n < 3 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT max_product = - 2147483648 NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT max_product = max ( max_product , arr [ i ] * arr [ j ] * arr [ i ] ) NEW_LINE DEDENT DEDENT return max_product NEW_LINE DEDENT arr = [ 10 , 3 , 5 , 20 ] NEW_LINE n = len ( arr ) NEW_LINE maxProduct = maxProduct ( arr , n ) NEW_LINE if ( maxProduct == - 1 ) : NEW_LINE INDENT print ( \" Product ▁ product ▁ product ▁ is \" , maxProduct ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No ▁ Triplet ▁ product ▁ is \" , maxProduct ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE def maxProduct ( arr , n ) : NEW_LINE INDENT if n < 3 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT max_product = - ( sys . maxsize - 1 ) NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT max_product = max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] ) NEW_LINE DEDENT DEDENT DEDENT return max_product NEW_LINE DEDENT arr = [ 10 , 3 , 5 , 6 , 20 ] NEW_LINE n = len ( arr ) NEW_LINE max = maxProduct ( arr , n ) NEW_LINE if max == - 1 : NEW_LINE INDENT print ( \" No ▁ Tripplet ▁ Exits \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Maximum ▁ product ▁ is \" , max ) NEW_LINE DEDENT"],"bleu":0.7064875922284015,"rouge_l":0.8253600077317097}
{"id":1213,"predictions":["def count ( S , X ) : NEW_LINE INDENT count = 0 NEW_LINE N = len ( S ) NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if S [ i ] != '0' : NEW_LINE INDENT for j in range ( 1 , N + 1 ) : NEW_LINE INDENT num = ( S [ i : i + len ( S ) ] ) NEW_LINE if num > X : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = \"222222\" NEW_LINE X = 97 NEW_LINE print ( count ( S , X ) ) NEW_LINE DEDENT"],"references":["def countSubStr ( S , X ) : NEW_LINE INDENT cnt = 0 NEW_LINE N = len ( S ) NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( S [ i ] != '0' ) : NEW_LINE INDENT j = 1 NEW_LINE while ( ( j + i ) <= N ) : NEW_LINE INDENT num = int ( S [ i : i + j ] ) NEW_LINE if ( num > X ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE DEDENT j = j + 1 NEW_LINE DEDENT DEDENT DEDENT return cnt ; NEW_LINE DEDENT S = \"2222\" ; NEW_LINE X = 97 ; NEW_LINE print ( countSubStr ( S , X ) ) NEW_LINE"],"bleu":0.5304181955693076,"rouge_l":0.7349397590361445}
{"id":1214,"predictions":["from math import * NEW_LINE def printPattern ( radius ) : NEW_LINE INDENT for i in range ( 2 * radius ) : NEW_LINE INDENT for j in range ( 2 * radius , 2 * radius ) : NEW_LINE INDENT dist = sqrt ( ( i - radius ) * ( i - radius ) + ( j - radius ) * ( j - radius ) ) ; NEW_LINE if dist > radius : NEW_LINE INDENT print ( \" * \" , end = \" \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" * \" , end = \" \" ) ; NEW_LINE DEDENT DEDENT DEDENT DEDENT radius = 6 ; NEW_LINE printPattern ( radius ) ; NEW_LINE"],"references":["import math NEW_LINE def printPattern ( radius ) : NEW_LINE INDENT for i in range ( ( 2 * radius ) + 1 ) : NEW_LINE INDENT for j in range ( ( 2 * radius ) + 1 ) : NEW_LINE INDENT dist = math . sqrt ( ( i - radius ) * ( i - radius ) + ( j - radius ) * ( j - radius ) ) NEW_LINE if ( dist > radius - 0.5 and dist < radius + 0.5 ) : NEW_LINE INDENT print ( \" * \" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" ▁ \" , end = \" \" ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT radius = 6 NEW_LINE printPattern ( radius ) NEW_LINE"],"bleu":0.6706586146548315,"rouge_l":0.8430029880478087}
{"id":1215,"predictions":["def findSum ( arr , N ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT mp [ arr [ i ] ] = mp . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT sum = 0 NEW_LINE for key , value in mp . get ( key , 0 ) : NEW_LINE INDENT if ( value ) % 2 != 0 : NEW_LINE INDENT sum += ( value ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT arr = [ 10 , 20 , 20 , 40 , 40 , 10 ] NEW_LINE N = len ( arr ) NEW_LINE print ( findSum ( arr , N ) ) NEW_LINE"],"references":["import collections NEW_LINE def findsum ( arr , N ) : NEW_LINE INDENT mp = collections . defaultdict ( int ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT sum = 0 NEW_LINE for i in mp : NEW_LINE INDENT if ( mp [ i ] % 2 != 0 ) : NEW_LINE INDENT sum += ( i * mp [ i ] ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT arr = [ 10 , 20 , 20 , 10 , 40 , 40 , 10 ] NEW_LINE N = len ( arr ) NEW_LINE print ( findsum ( arr , N ) ) NEW_LINE"],"bleu":0.6778093498008573,"rouge_l":0.7727762803234501}
{"id":1216,"predictions":["def findFrequencyUtil ( arr , low , high , data ) : NEW_LINE INDENT if ( arr [ low ] == arr [ high ] ) : NEW_LINE INDENT return high - low NEW_LINE DEDENT if ( arr [ low ] == arr [ high ] ) : NEW_LINE INDENT return freq [ low ] NEW_LINE DEDENT else : NEW_LINE INDENT mid = ( low + high ) \/\/ 2 NEW_LINE findFrequencyUtil ( arr , low , mid + 1 , high , freq ) NEW_LINE findFrequencyUtil ( arr , mid + 1 , freq [ mid ] ) NEW_LINE DEDENT DEDENT def findFrequency ( arr , n ) : NEW_LINE INDENT freq = [ 0 for i in range ( arr [ n - 1 ] + 1 ) ] NEW_LINE findFrequencyUtil ( arr , 0 , n - 1 , freq ) NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT if ( freq [ arr [ i ] ] != 0 ) : NEW_LINE INDENT print ( \" Element ▁ not ▁ exist \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 1 , 1 , 2 , 3 , 3 , 5 , 8 , 9 , 9 , 8 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE findFrequency ( arr , n ) NEW_LINE DEDENT"],"references":["def findFrequencyUtil ( arr , low , high , freq ) : NEW_LINE INDENT if ( arr [ low ] == arr [ high ] ) : NEW_LINE INDENT freq [ arr [ low ] ] += high - low + 1 NEW_LINE DEDENT else : NEW_LINE INDENT mid = int ( ( low + high ) \/ 2 ) NEW_LINE findFrequencyUtil ( arr , low , mid , freq ) NEW_LINE findFrequencyUtil ( arr , mid + 1 , high , freq ) NEW_LINE DEDENT DEDENT def findFrequency ( arr , n ) : NEW_LINE INDENT freq = [ 0 for i in range ( n - 1 + 1 ) ] NEW_LINE findFrequencyUtil ( arr , 0 , n - 1 , freq ) NEW_LINE for i in range ( 0 , arr [ n - 1 ] + 1 , 1 ) : NEW_LINE INDENT if ( freq [ i ] != 0 ) : NEW_LINE INDENT print ( \" Element \" , i , \" occurs \" , freq [ i ] , \" times \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 1 , 1 , 2 , 3 , 3 , 5 , 5 , 8 , 8 , 8 , 9 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE findFrequency ( arr , n ) NEW_LINE DEDENT"],"bleu":0.7616792963852771,"rouge_l":0.8176943699731903}
{"id":1217,"predictions":["def sumOfSeries ( num ) : NEW_LINE INDENT res = 0 NEW_LINE fact = 1 NEW_LINE for i in range ( 1 , num + 1 ) : NEW_LINE INDENT fact = fact * i NEW_LINE res = res + ( i * fact ) NEW_LINE DEDENT return ( res ) NEW_LINE DEDENT n = 5 NEW_LINE print ( \" Sum ▁ : ▁ \" , sumOfSeries ( n ) ) NEW_LINE"],"references":["def sumOfSeries ( num ) : NEW_LINE INDENT res = 0 NEW_LINE fact = 1 NEW_LINE for i in range ( 1 , num + 1 ) : NEW_LINE INDENT fact *= i NEW_LINE res = res + ( i \/ fact ) NEW_LINE DEDENT return res NEW_LINE DEDENT n = 5 NEW_LINE print ( \" Sum : ▁ \" , sumOfSeries ( n ) ) NEW_LINE"],"bleu":0.8035335851683604,"rouge_l":0.9413580246913581}
{"id":1218,"predictions":["def calcSum ( arr , n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE print ( sum , end = \" ▁ \" ) NEW_LINE DEDENT for i in range ( k , n ) : NEW_LINE INDENT sum = ( sum - arr [ i - k ] + arr [ i ] ) NEW_LINE print ( sum , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE calcSum ( arr , n , k ) NEW_LINE"],"references":["def calcSum ( arr , n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT print ( sum , end = \" ▁ \" ) NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT sum = ( sum - arr [ i - k ] ) + arr [ i ] NEW_LINE print ( sum , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE calcSum ( arr , n , k ) NEW_LINE DEDENT"],"bleu":0.8101825773280222,"rouge_l":0.9129458717884759}
{"id":1219,"predictions":["def minChanges ( A , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT if ( ( i - 1 >= 1 and A [ i ] == 1 and A [ i + 1 ] == 0 and A [ i + 1 ] == 0 ) and A [ i ] == 0 ) : NEW_LINE INDENT A [ i + 1 ] = 0 NEW_LINE cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT A = [ 1 , 1 , 0 , 1 , 0 , 0 , 0 ] NEW_LINE n = len ( A ) NEW_LINE print ( minChanges ( A , n ) ) NEW_LINE"],"references":["def minChanges ( A , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT if ( ( i - 1 >= 0 ) and A [ i - 1 ] == 1 and A [ i + 1 ] == 1 and A [ i ] == 0 ) : NEW_LINE INDENT A [ i + 1 ] = 0 NEW_LINE cnt = cnt + 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT A = [ 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 0 ] NEW_LINE n = len ( A ) NEW_LINE print ( minChanges ( A , n ) ) NEW_LINE"],"bleu":0.8602093850778555,"rouge_l":0.8997519906017492}
{"id":1220,"predictions":["def calcNodes ( N , i ) : NEW_LINE INDENT result = 0 NEW_LINE result = i * ( N - 1 ) + 1 NEW_LINE return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 5 NEW_LINE i = 2 NEW_LINE print ( \" Centered ▁ nodes ▁ = \" , calcNodes ( N , i ) ) NEW_LINE DEDENT"],"references":["def calcNodes ( N , I ) : NEW_LINE INDENT result = 0 NEW_LINE result = I * ( N - 1 ) + 1 NEW_LINE return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 NEW_LINE I = 2 NEW_LINE print ( \" Leaf ▁ nodes ▁ = ▁ \" , calcNodes ( N , I ) ) NEW_LINE DEDENT"],"bleu":0.7018474880352287,"rouge_l":0.8924756154203438}
{"id":1221,"predictions":["def countSum ( arr , n ) : NEW_LINE INDENT NumberOfOdd = 0 NEW_LINE NumberOfOdd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 1 ) : NEW_LINE INDENT NumberOfOdd += 1 NEW_LINE DEDENT NumberOfOdd = n - NumberOfOdd ) NEW_LINE NumberOfOdd = ( 1 << NumberOfOdd ) NEW_LINE NumberOfOdd += 1 NEW_LINE DEDENT return ( NumberOfOdd ) NEW_LINE DEDENT def countSum ( arr , n ) : NEW_LINE INDENT NumberOfOdd = 0 NEW_LINE NumberOfOdd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 1 ) : NEW_LINE INDENT NumberOfOdd += 1 NEW_LINE DEDENT DEDENT NumberOfOdd = countSum ( arr , n ) NEW_LINE return NumberOfOdd NEW_LINE DEDENT arr = [ 1 , 2 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE ans = countSum ( arr , n ) NEW_LINE print ( \" EvenSum ▁ = \" , ans ) NEW_LINE"],"references":["def countSum ( arr , n ) : NEW_LINE INDENT NumberOfOdds = 0 ; NumberOfEvens = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT NumberOfOdds += 1 ; NEW_LINE DEDENT DEDENT NumberOfEvens = n - NumberOfOdds ; NEW_LINE NumberOfOddSubsequences = ( 1 << NumberOfEvens ) *   \\ NEW_LINE INDENT ( 1 << ( NumberOfOdds - 1 ) ) ; NEW_LINE DEDENT NumberOfEvenSubsequences = ( 1 << n ) - 1 -   \\ NEW_LINE INDENT NumberOfOddSubsequences ; NEW_LINE DEDENT return ( NumberOfEvenSubsequences , NumberOfOddSubsequences ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 2 , 3 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE ans = countSum ( arr , n ) ; NEW_LINE print ( \" EvenSum ▁ = \" , ans [ 0 ] , end = \" ▁ \" ) ; NEW_LINE print ( \" OddSum ▁ = \" , ans [ 1 ] ) ; NEW_LINE DEDENT"],"bleu":0.4007123782416951,"rouge_l":0.5836266811084032}
{"id":1222,"predictions":["import math NEW_LINE def findMinNumber ( n ) : NEW_LINE INDENT count = 0 NEW_LINE ans = 1 NEW_LINE while n % 2 == 0 : NEW_LINE INDENT count = count + 1 NEW_LINE n \/\/= 2 NEW_LINE DEDENT if count % 3 != 0 : NEW_LINE INDENT ans *= pow ( 2 , ( count % 3 ) ) NEW_LINE DEDENT for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT count = 0 NEW_LINE while n % i == 0 : NEW_LINE INDENT count = count + 1 NEW_LINE n \/\/= i NEW_LINE DEDENT if count % 3 != 0 : NEW_LINE INDENT ans *= n NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT ans *= int ( count % 3 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 128 NEW_LINE print ( findMinNumber ( n ) ) NEW_LINE DEDENT"],"references":["def findMinNumber ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE ans = 1 ; NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE n \/= 2 ; NEW_LINE DEDENT if ( count % 3 != 0 ) : NEW_LINE INDENT ans *= pow ( 2 , ( count % 3 ) ) ; NEW_LINE DEDENT for i in range ( 3 , int ( pow ( n , 1 \/ 2 ) ) , 2 ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE n \/= i ; NEW_LINE DEDENT if ( count % 3 != 0 ) : NEW_LINE INDENT ans *= pow ( i , ( count % 3 ) ) ; NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT ans *= n ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 128 ; NEW_LINE print ( findMinNumber ( n ) ) ; NEW_LINE DEDENT"],"bleu":0.5655174122624198,"rouge_l":0.8070502575031078}
{"id":1223,"predictions":["def is_vowels ( c ) : NEW_LINE INDENT return ( c == ' a ' or c == ' e ' or c == ' i ' or c == ' o ' or c == ' u ' ) NEW_LINE DEDENT def removeVowels ( str ) : NEW_LINE INDENT return ( ( c == ' a ' or c == ' u ' ) or ( c == ' e ' or c == ' i ' or c == ' o ' or c == ' u ' ) ) NEW_LINE DEDENT def removeVowels ( str ) : NEW_LINE INDENT for i in range ( 1 , len ( str ) ) : NEW_LINE INDENT if ( not is_vowels ( str [ i - 1 ] ) or ( not is_vowels ( str [ i ] ) or is_vowels ( str [ i ] ) ) ) : NEW_LINE INDENT print ( str [ i ] , end = ' ' ) NEW_LINE if ( not is_vowels ( str [ i ] ) ) : NEW_LINE INDENT print ( str [ i ] , end = ' ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( str [ i ] , end = ' ' ) NEW_LINE DEDENT DEDENT DEDENT DEDENT str = \" geeks \" NEW_LINE removeVowels ( str ) NEW_LINE"],"references":["def is_vow ( c ) : NEW_LINE INDENT return ( ( c == ' a ' ) or ( c == ' e ' ) or ( c == ' i ' ) or ( c == ' o ' ) or ( c == ' u ' ) ) ; NEW_LINE DEDENT def removeVowels ( str ) : NEW_LINE INDENT print ( str [ 0 ] , end = \" \" ) ; NEW_LINE for i in range ( 1 , len ( str ) ) : NEW_LINE INDENT if ( ( is_vow ( str [ i - 1 ] ) != True ) or ( is_vow ( str [ i ] ) != True ) ) : NEW_LINE INDENT print ( str [ i ] , end = \" \" ) ; NEW_LINE DEDENT DEDENT DEDENT str = \" ▁ geeks ▁ for ▁ geeks \" ; NEW_LINE removeVowels ( str ) ; NEW_LINE"],"bleu":0.45360082384856276,"rouge_l":0.6349079263410728}
{"id":1224,"predictions":["PI = 3.14159265 NEW_LINE def are acacsum circle ( a ) : NEW_LINE INDENT return ( a * a ) NEW_LINE DEDENT a = 6.14159265 NEW_LINE print ( \" Area ▁ of ▁ inscribed ▁ are : ▁ \" , a ) NEW_LINE print ( ' corners ▁ is : ▁ \" , end = ' ' ) NEW_LINE print ( \" \\numference ( a ) ) NEW_LINE"],"references":["PI = 3.14159265 NEW_LINE def areacircumscribed ( a ) : NEW_LINE INDENT return ( a * a * ( PI \/ 2 ) ) NEW_LINE DEDENT a = 6 NEW_LINE print ( \" ▁ Area ▁ of ▁ an ▁ circumscribed ▁ circle ▁ is ▁ : \" , round ( areacircumscribed ( a ) , 2 ) ) NEW_LINE"],"bleu":0.39425185282377273,"rouge_l":0.6637305699481866}
{"id":1225,"predictions":["def breakEvenPoint ( exp , S , M ) : NEW_LINE INDENT if ( S \/ M ) : NEW_LINE INDENT return S NEW_LINE DEDENT res = math . floor ( exp ( P \/ S ) ) NEW_LINE return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT exp = 35 NEW_LINE S = 90 NEW_LINE M = 65 NEW_LINE print ( breakEvenPoint ( exp , S , M ) ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def breakEvenPoint ( exp , S , M ) : NEW_LINE INDENT earn = S - M NEW_LINE res = math . ceil ( exp \/ earn ) NEW_LINE return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT exp = 3550 NEW_LINE S = 90 NEW_LINE M = 65 NEW_LINE print ( int ( breakEvenPoint ( exp , S , M ) ) ) NEW_LINE DEDENT"],"bleu":0.6839289008693366,"rouge_l":0.8265582655826559}
{"id":1226,"predictions":["MAX = 256 NEW_LINE def countPairs ( s ) : NEW_LINE INDENT cnt = [ 0 for i in range ( MAX ) ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT cnt [ ord ( s [ i ] ) ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT ans += cnt [ i ] * cnt [ ord ( s [ i ] ) ] NEW_LINE DEDENT return ans NEW_LINE DEDENT s = \" geeksforgeeks \" NEW_LINE print ( countPairs ( s ) ) NEW_LINE"],"references":["MAX = 256 NEW_LINE def countPairs ( s ) : NEW_LINE INDENT cnt = [ 0 for i in range ( 0 , MAX ) ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT cnt [ ord ( s [ i ] ) - 97 ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 0 , MAX ) : NEW_LINE INDENT ans += cnt [ i ] * cnt [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" geeksforgeeks \" NEW_LINE print ( countPairs ( s ) ) NEW_LINE DEDENT"],"bleu":0.7554927418966603,"rouge_l":0.8718137616030649}
{"id":1227,"predictions":["def sumOfSeries ( n ) : NEW_LINE INDENT return 0.0 * ( pow ( 10 , n ) - 1 - ( 9 * n ) - ( 9 * n ) ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 ; NEW_LINE print ( sumOfSeries ( n ) ) ; NEW_LINE DEDENT"],"references":["import math NEW_LINE def sumOfSeries ( n ) : NEW_LINE INDENT return 0.0246 * ( math . pow ( 10 , n ) - 1 - ( 9 * n ) ) NEW_LINE DEDENT n = 3 NEW_LINE print ( sumOfSeries ( n ) ) NEW_LINE"],"bleu":0.4929671473883792,"rouge_l":0.7493857493857494}
{"id":1228,"predictions":["def maxLenSub ( arr , n ) : NEW_LINE INDENT mls = [ 1 for i in range ( n ) ] NEW_LINE maxls = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT mls [ i ] = 1 NEW_LINE for j in range ( i ) : NEW_LINE INDENT if ( abs ( arr [ i ] - arr [ j ] ) <= mls [ j ] ) : NEW_LINE INDENT mls [ i ] = mls [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( maxls < mls [ i ] ) : NEW_LINE INDENT maxls = mls [ i ] NEW_LINE DEDENT DEDENT return maxls NEW_LINE DEDENT arr = [ 2 , 5 , 6 , 3 , 7 , 6 , 5 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Maximum ▁ length ▁ subsequence ▁ = ▁ \" , maxLenSub ( arr , n ) ) NEW_LINE"],"references":["def maxLenSub ( arr , n ) : NEW_LINE INDENT mls = [ ] NEW_LINE max = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mls . append ( 1 ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( abs ( arr [ i ] - arr [ j ] ) <= 1 and mls [ i ] < mls [ j ] + 1 ) : NEW_LINE INDENT mls [ i ] = mls [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( max < mls [ i ] ) : NEW_LINE INDENT max = mls [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT arr = [ 2 , 5 , 6 , 3 , 7 , 6 , 5 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Maximum ▁ length ▁ subsequence ▁ = ▁ \" , maxLenSub ( arr , n ) ) NEW_LINE"],"bleu":0.8034694116432902,"rouge_l":0.870884268760596}
{"id":1229,"predictions":["mod = 1000000007 NEW_LINE dp = [ [ - 1 for i in range ( 1000 ) ] for j in range ( 1000 ) ] NEW_LINE def calculate ( pos , prev , s , index ) : NEW_LINE INDENT if ( pos == len ( s ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( dp [ pos ] [ prev ] != - 1 ) : NEW_LINE INDENT return dp [ pos ] [ prev ] NEW_LINE DEDENT answer = 0 NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT if ( dp [ pos ] [ prev ] != - 1 ) : NEW_LINE INDENT answer = ( answer + calculate ( pos + 1 , index , s , index ) ) % mod NEW_LINE DEDENT DEDENT dp [ pos ] [ prev ] = answer NEW_LINE return dp [ pos ] [ rem ] NEW_LINE DEDENT def countWays ( a , s , index ) : NEW_LINE INDENT n = len ( s ) NEW_LINE index = [ ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT index . append ( a [ i ] ) NEW_LINE DEDENT for i in range ( 0 , 26 ) : NEW_LINE INDENT dp [ i ] [ index ] = - 1 NEW_LINE for j in range ( 0 , 26 ) : NEW_LINE INDENT index [ j ] [ i ] = - 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , len ( a ) ) : NEW_LINE INDENT index [ i ] [ j ] = index [ j ] [ i ] NEW_LINE DEDENT DEDENT return calculateWays ( 0 , 0 , s , index ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ \" abc \" , \" acc \" ] NEW_LINE A = [ \" a \" , \" bc \" ] NEW_LINE print ( countWays ( A , 0 , A ) ) NEW_LINE DEDENT"],"references":["mod = 1000000007 NEW_LINE dp = [ [ - 1 for i in range ( 1000 ) ] for j in range ( 1000 ) ] ; NEW_LINE def calculate ( pos , prev , s , index ) : NEW_LINE INDENT if ( pos == len ( s ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( dp [ pos ] [ prev ] != - 1 ) : NEW_LINE INDENT return dp [ pos ] [ prev ] NEW_LINE DEDENT c = ord ( s [ pos ] ) - ord ( ' a ' ) ; NEW_LINE answer = 0 NEW_LINE for i in range ( len ( index ) ) : NEW_LINE INDENT if ( index [ i ] > prev ) : NEW_LINE INDENT answer = ( answer % mod + calculate ( pos + 1 , index [ i ] , s , index ) % mod ) % mod NEW_LINE DEDENT DEDENT dp [ pos ] [ prev ] = 4 NEW_LINE return dp [ pos ] [ prev ] NEW_LINE DEDENT def countWays ( a , s ) : NEW_LINE INDENT n = len ( a ) NEW_LINE index = [ [ ] for i in range ( 26 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( len ( a [ i ] ) ) : NEW_LINE INDENT index [ ord ( a [ i ] [ j ] ) - ord ( ' a ' ) ] . append ( j + 1 ) ; NEW_LINE DEDENT DEDENT return calculate ( 0 , 0 , s , index [ 0 ] ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ ] NEW_LINE A . append ( \" adc \" ) NEW_LINE A . append ( \" aec \" ) NEW_LINE A . append ( \" erg \" ) NEW_LINE S = \" ac \" NEW_LINE print ( countWays ( A , S ) ) NEW_LINE DEDENT"],"bleu":0.6432312050087522,"rouge_l":0.7401815487217489}
{"id":1230,"predictions":["def divisibleBy36 ( num ) : NEW_LINE INDENT l = len ( num ) NEW_LINE if ( l == 0 and num [ 0 ] != '0' ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( l == 1 and num [ 0 ] != '0' ) : NEW_LINE INDENT return False NEW_LINE DEDENT two_digit = ( num [ l - 2 ] * 10 + int ( num [ l - 1 ] ) ) * 10 + ( num [ l ] ) ) NEW_LINE if ( two_digit % 4 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT two_digit = 0 NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT sum += int ( num [ i ] ) NEW_LINE DEDENT if ( two_digit % 9 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum_digit = 0 NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT sum_digit += ord ( num [ i ] ) - ord ( '0' ) NEW_LINE DEDENT if ( sum % 9 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT num =001024119121668242824668420 NEW_LINE if ( divisibleBy36137878187824668324661378782498244353 ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def divisibleBy36 ( num ) : NEW_LINE INDENT l = len ( num ) NEW_LINE if ( l == 0 ) : NEW_LINE INDENT return ( \" No \" ) NEW_LINE DEDENT if ( l == 1 and num [ 0 ] != '0' ) : NEW_LINE INDENT return ( \" No \" ) NEW_LINE DEDENT two_digit_num = ( ( ( int ) ( num [ l - 2 ] ) ) * 10 + ( int ) ( num [ l - 1 ] ) ) NEW_LINE if ( two_digit_num % 4 != 0 ) : NEW_LINE INDENT return \" No \" NEW_LINE DEDENT sm = 0 NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT sm = sm + ( int ) ( num [ i ] ) NEW_LINE DEDENT if ( sm % 9 != 0 ) : NEW_LINE INDENT return ( \" No \" ) NEW_LINE DEDENT return ( \" Yes \" ) NEW_LINE DEDENT num = \"92567812197966231384\" NEW_LINE print ( divisibleBy36 ( num ) ) NEW_LINE"],"bleu":0.4818921353587675,"rouge_l":0.654274193548387}
{"id":1231,"predictions":["def toString ( s ) : NEW_LINE INDENT sum = ord ( s [ 0 ] ) - ord ( '0' ) NEW_LINE return ( ord ( s [ 1 ] ) - ord ( '0' ) ) NEW_LINE DEDENT def compute ( s ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT sum = sum + ord ( s [ i ] ) + ord ( '0' ) NEW_LINE DEDENT return sum NEW_LINE DEDENT def query ( l , r ) : NEW_LINE INDENT if ( ( sum + 1 ) % 3 == 0 ) : NEW_LINE INDENT print ( \" Divisible ▁ by ▁ 3\" ) NEW_LINE return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = (004 ) NEW_LINE query ( 1 , 2 ) NEW_LINE query ( 3 , 1 ) NEW_LINE query ( 0 , 2 ) NEW_LINE query ( 0 , 1 ) NEW_LINE DEDENT"],"references":["sum = [ 0 for i in range ( 1000005 ) ] NEW_LINE def toInt ( x ) : NEW_LINE INDENT return int ( x ) NEW_LINE DEDENT def prepareSum ( s ) : NEW_LINE INDENT sum [ 0 ] = 0 NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT sum [ i + 1 ] = sum [ i ] + toInt ( s [ i ] ) NEW_LINE DEDENT DEDENT def query ( l , r ) : NEW_LINE INDENT if ( ( sum [ r + 1 ] - sum [ l ] ) % 3 == 0 ) : NEW_LINE INDENT print ( \" Divisible ▁ by ▁ 3\" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ divisible ▁ by ▁ 3\" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = \"12468236544\" NEW_LINE prepareSum ( n ) NEW_LINE query ( 0 , 1 ) NEW_LINE query ( 1 , 2 ) NEW_LINE query ( 3 , 6 ) NEW_LINE query ( 0 , 10 ) NEW_LINE DEDENT"],"bleu":0.5677462367657817,"rouge_l":0.6881888397118806}
{"id":1232,"predictions":["def distsum ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE res = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res += ( arr [ i ] * i - sum ) NEW_LINE DEDENT return res NEW_LINE DEDENT def totaldumumum ( x , y , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res += ( arr [ i ] * i - sum ) NEW_LINE DEDENT return res NEW_LINE DEDENT x = [ - 1 , 1 , 3 , 2 ] NEW_LINE y = [ 5 , 6 , 3 ] NEW_LINE n = len ( x ) NEW_LINE print ( totaldumum ( x , y , n ) ) NEW_LINE"],"references":["def distancesum ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE res = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res += ( arr [ i ] * i - sum ) NEW_LINE sum += arr [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT def totaldistancesum ( x , y , n ) : NEW_LINE INDENT return distancesum ( x , n ) + distancesum ( y , n ) NEW_LINE DEDENT x = [ - 1 , 1 , 3 , 2 ] NEW_LINE y = [ 5 , 6 , 5 , 3 ] NEW_LINE n = len ( x ) NEW_LINE print ( totaldistancesum ( x , y , n ) ) NEW_LINE"],"bleu":0.7469508269390183,"rouge_l":0.8216997305902523}
{"id":1233,"predictions":["def squareSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( 2 * i ) * ( 2 * i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT print ( squareSum ( 8 ) ) NEW_LINE"],"references":["def squareSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT sum += ( 2 * i ) * ( 2 * i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT ans = squareSum ( 8 ) NEW_LINE print ( ans ) NEW_LINE"],"bleu":0.8080228813157888,"rouge_l":0.9031684927450401}
{"id":1234,"predictions":["def findAndSum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE mul = 1 NEW_LINE for i in range ( 0 , 30 ) : NEW_LINE INDENT count_on = 0 NEW_LINE for j in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( arr [ i ] & ( 1 << i ) ) : NEW_LINE INDENT count_on = count_on + 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( count_on * ( 1 << i ) ) : NEW_LINE INDENT l = count_on + 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_on = count_on NEW_LINE DEDENT DEDENT DEDENT if ( count_on * l * ( l + 1 ) ) \/\/ 2 NEW_LINE DEDENT return ( mul ) NEW_LINE DEDENT arr = [ 7 , 1 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findAndSum ( arr , n ) ) NEW_LINE"],"references":["import math as mt NEW_LINE def findAndSum ( arr , n ) : NEW_LINE INDENT Sum = 0 NEW_LINE mul = 1 NEW_LINE for i in range ( 30 ) : NEW_LINE INDENT count_on = 0 NEW_LINE l = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( ( arr [ j ] & ( 1 << i ) ) > 0 ) : NEW_LINE INDENT if ( count_on ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_on = 1 NEW_LINE l += 1 NEW_LINE DEDENT DEDENT elif ( count_on ) : NEW_LINE INDENT Sum += ( ( mul * l * ( l + 1 ) ) \/\/ 2 ) NEW_LINE count_on = 0 NEW_LINE l = 0 NEW_LINE DEDENT DEDENT if ( count_on ) : NEW_LINE INDENT Sum += ( ( mul * l * ( l + 1 ) ) \/\/ 2 ) NEW_LINE count_on = 0 NEW_LINE l = 0 NEW_LINE DEDENT mul *= 2 NEW_LINE DEDENT return Sum NEW_LINE DEDENT arr = [ 7 , 1 , 1 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findAndSum ( arr , n ) ) NEW_LINE"],"bleu":0.529842557712917,"rouge_l":0.6796505927444514}
{"id":1235,"predictions":["def isAlphabaticOrder ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE c = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT c [ ord ( s [ i ] ) ] = ord ( s [ i ] ) - 48 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( c [ i ] != s [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" aabbbcc \" NEW_LINE if ( isAlphabaticOrder ( s ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def isAlphabaticOrder ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE c = [ s [ i ] for i in range ( len ( s ) ) ] NEW_LINE c . sort ( reverse = False ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( c [ i ] != s [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" aabbbcc \" NEW_LINE if ( isAlphabaticOrder ( s ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.7544599672389068,"rouge_l":0.8565925189511621}
{"id":1236,"predictions":["class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . prev = None NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def push ( head_ref , new_data ) : NEW_LINE INDENT new_node = Node ( new_data ) NEW_LINE new_node . next = head_ref NEW_LINE new_node . next = head_ref NEW_LINE head_ref = new_node NEW_LINE return head_ref NEW_LINE DEDENT def push ( head_ref , new_data ) : NEW_LINE INDENT new_node = Node ( new_data ) NEW_LINE new_node . data = new_data NEW_LINE new_node . next = head_ref NEW_LINE if head_ref != None : NEW_LINE INDENT head_ref . prev = new_node NEW_LINE DEDENT head_ref = new_node NEW_LINE return head_ref NEW_LINE DEDENT def push ( head_ref , new_data ) : NEW_LINE INDENT new_node . prev = Node ( new_data ) NEW_LINE new_node . next = head_ref NEW_LINE new_node . next = head_ref NEW_LINE head_ref = new_node NEW_LINE return head_ref NEW_LINE DEDENT def printOutput ( head_ref ) : NEW_LINE INDENT new_node = head_ref NEW_LINE new_node . prev = head_ref NEW_LINE new_node . next = head_ref NEW_LINE head_ref . prev = head_ref NEW_LINE new_node . prev = head_ref NEW_LINE head_ref . prev = head_ref NEW_LINE return head_ref NEW_LINE DEDENT def printOutput ( head_ref , new_node ) : NEW_LINE INDENT print ( head . data , end = \" ▁ \" ) NEW_LINE head_ref = new_node NEW_LINE while head_ref != None : NEW_LINE INDENT print ( head_ref , end = \" ▁ \" ) NEW_LINE head_ref , end = \" ▁ \" ) NEW_LINE head_ref = new_node NEW_LINE while head_ref != None"],"references":["class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE self . prev = None NEW_LINE DEDENT DEDENT class DoublyLinkedList : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . head = None NEW_LINE DEDENT def push ( self , new_data ) : NEW_LINE INDENT new_node = Node ( new_data ) NEW_LINE new_node . next = self . head NEW_LINE if self . head is not None : NEW_LINE INDENT self . head . prev = new_node NEW_LINE DEDENT self . head = new_node NEW_LINE DEDENT def insertAfter ( self , prev_node , new_data ) : NEW_LINE INDENT if prev_node is None : NEW_LINE INDENT print \" the ▁ given ▁ previous ▁ node ▁ cannot ▁ be ▁ NULL \" NEW_LINE return NEW_LINE DEDENT new_node = Node ( new_data ) NEW_LINE new_node . next = prev_node . next NEW_LINE prev_node . next = new_node NEW_LINE new_node . prev = prev_node NEW_LINE if new_node . next is not None : NEW_LINE INDENT new_node . next . prev = new_node NEW_LINE DEDENT DEDENT def append ( self , new_data ) : NEW_LINE INDENT new_node = Node ( new_data ) NEW_LINE new_node . next = None NEW_LINE if self . head is None : NEW_LINE INDENT new_node . prev = None NEW_LINE self . head = new_node NEW_LINE return NEW_LINE DEDENT last = self . head NEW_LINE while ( last . next is not None ) : NEW_LINE INDENT last = last . next NEW_LINE DEDENT last . next = new_node NEW_LINE new_node . prev = last NEW_LINE return NEW_LINE DEDENT def printList ( self , node ) : NEW_LINE INDENT print \" \\n Traversal ▁ in ▁ forward ▁ direction \" NEW_LINE while ( node is not None ) : NEW_LINE INDENT print \" ▁ % ▁ d \" % ( node . data ) , NEW_LINE last = node NEW_LINE node = node . next NEW_LINE DEDENT print \" \\n Traversal ▁ in ▁ reverse ▁ direction \" NEW_LINE while ( last is not None ) : NEW_LINE INDENT print \" ▁ % ▁ d \" % ( last . data ) , NEW_LINE last = last . prev NEW_LINE DEDENT DEDENT DEDENT llist = DoublyLinkedList ( ) NEW_LINE llist . append ( 6 ) NEW_LINE llist . push ( 7 ) NEW_LINE llist . push ( 1 ) NEW_LINE llist . append ( 4 ) NEW_LINE llist . insertAfter ( llist . head . next , 8 ) NEW_LINE print \" Created ▁ DLL ▁ is : ▁ \" , NEW_LINE llist . printList ( llist . head ) NEW_LINE"],"bleu":0.26741190557139805,"rouge_l":0.4776820673453406}
{"id":1237,"predictions":["from math import sqrt NEW_LINE prime = [ 0 ] * len ( prime ) NEW_LINE def sieve ( ) : NEW_LINE INDENT prime [ 1 ] = 1 NEW_LINE prime [ 0 ] = 1 NEW_LINE for i in range ( 2 , int ( sqrt ( size ) ) ) : NEW_LINE INDENT if prime [ i ] == 0 : NEW_LINE INDENT for j in range ( i * 2 , size , i ) : NEW_LINE INDENT prime [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT p = 1 NEW_LINE while p < size : NEW_LINE INDENT if prime [ p ] == 0 and prime [ p ] == 0 : NEW_LINE INDENT for i in range ( p * 2 , size , i ) : NEW_LINE INDENT prime [ i ] = 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , size ) : NEW_LINE INDENT print ( prime [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT queries = [ ] NEW_LINE sieve ( ) NEW_LINE DEDENT"],"references":["from math import sqrt NEW_LINE size = 1000 NEW_LINE prime = [ 0 for i in range ( size ) ] NEW_LINE freq = [ 0 for i in range ( size ) ] NEW_LINE def sieve ( a , b ) : NEW_LINE INDENT prime [ 1 ] = 1 NEW_LINE for i in range ( 2 , int ( sqrt ( size ) ) + 1 , 1 ) : NEW_LINE INDENT if ( prime [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i * 2 , size , i ) : NEW_LINE INDENT prime [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT for p in range ( 1 , size , 1 ) : NEW_LINE INDENT for q in range ( 1 , size , 1 ) : NEW_LINE INDENT if ( prime [ p ] == 0 and prime [ q ] == 0 and a * p + b * q < size ) : NEW_LINE INDENT freq [ a * p + b * q ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT queries = 2 NEW_LINE a = 1 NEW_LINE b = 2 NEW_LINE sieve ( a , b ) NEW_LINE arr = [ 15 , 25 ] NEW_LINE for i in range ( queries ) : NEW_LINE INDENT print ( freq [ arr [ i ] ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.5139042866072039,"rouge_l":0.6011343495214464}
{"id":1238,"predictions":["def replaceConsonants ( string ) : NEW_LINE INDENT res = \" \" NEW_LINE i = 0 NEW_LINE while i < len ( string ) : NEW_LINE INDENT if string [ i ] != ' a ' and string [ i ] != ' e ' and string [ i ] != ' i ' and string [ i ] != ' a ' : NEW_LINE INDENT res += str [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( count > 0 ) : NEW_LINE INDENT res += string [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( count > 0 ) : NEW_LINE INDENT res += string [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" abcde \" NEW_LINE print ( replaceConsonants ( string ) ) NEW_LINE DEDENT"],"references":["def replaceConsonants ( string ) : NEW_LINE INDENT res = \" \" ; NEW_LINE i = 0 ; count = 0 ; NEW_LINE while ( i < len ( string ) ) : NEW_LINE INDENT if ( string [ i ] != ' a ' and string [ i ] != ' e ' and string [ i ] != ' i ' and string [ i ] != ' o ' and string [ i ] != ' u ' ) : NEW_LINE INDENT i += 1 ; NEW_LINE count += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( count > 0 ) : NEW_LINE INDENT res += str ( count ) ; NEW_LINE DEDENT res += string [ i ] ; NEW_LINE i += 1 NEW_LINE count = 0 ; NEW_LINE DEDENT DEDENT if ( count > 0 ) : NEW_LINE INDENT res += str ( count ) ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" abcdeiop \" ; NEW_LINE print ( replaceConsonants ( string ) ) ; NEW_LINE DEDENT"],"bleu":0.5871279562920382,"rouge_l":0.7833805476864967}
{"id":1239,"predictions":["def count ( S , m , n ) : NEW_LINE INDENT table = [ [ 0 for x in range ( m ) ] for x in range ( n + 1 ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT table [ 0 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT x = table [ i - S [ j ] ] [ j ] if i - S [ j ] >= 0 : NEW_LINE INDENT table [ i ] [ j ] = x NEW_LINE table [ i ] [ j ] = x + table [ i - S [ j ] ] NEW_LINE DEDENT DEDENT DEDENT return table [ n ] NEW_LINE DEDENT S = [ ] NEW_LINE m , n = len ( S ) NEW_LINE print ( count ( S , m , n ) ) NEW_LINE"],"references":["def count ( S , m , n ) : NEW_LINE INDENT table = [ 0 for k in range ( n + 1 ) ] NEW_LINE table [ 0 ] = 1 NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT for j in range ( S [ i ] , n + 1 ) : NEW_LINE INDENT table [ j ] += table [ j - S [ i ] ] NEW_LINE DEDENT DEDENT return table [ n ] NEW_LINE DEDENT arr = [ 1 , 2 , 3 ] NEW_LINE m = len ( arr ) NEW_LINE n = 4 NEW_LINE x = count ( arr , m , n ) NEW_LINE print ( x ) NEW_LINE"],"bleu":0.4502996738613988,"rouge_l":0.6662874047104335}
{"id":1240,"predictions":["def minReplacement ( string ) : NEW_LINE INDENT if ( len ( string ) > 26 ) : NEW_LINE INDENT return \" IMPOSSIBLE \" ; NEW_LINE DEDENT else : NEW_LINE INDENT Hash = [ False ] * 26 ; NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT Hash [ ord ( string [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT count = 0 ; NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( Hash [ ord ( string [ i ] ) - ord ( ' a ' ) ] > 1 ) : NEW_LINE INDENT hash [ ord ( string [ i ] ) - ord ( ' a ' ) ] -= 1 ; NEW_LINE break ; NEW_LINE DEDENT DEDENT DEDENT count = 0 ; NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( Hash [ i ] == 0 ) : NEW_LINE INDENT for j in range ( 26 ) : NEW_LINE INDENT if ( Hash [ ord ( string [ i ] ) - ord ( ' a ' ) ] > j ) : NEW_LINE INDENT count += 1 ; NEW_LINE break ; NEW_LINE DEDENT DEDENT DEDENT print ( count ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" xxxy \" ; NEW_LINE minReplacement ( string ) ; NEW_LINE DEDENT"],"references":["def minReplacement ( string ) : NEW_LINE INDENT if len ( string ) > 26 : NEW_LINE INDENT print ( \" IMPOSSIBLE \" ) NEW_LINE DEDENT else : NEW_LINE INDENT Hash = [ 0 ] * 26 NEW_LINE for i in range ( 0 , len ( string ) ) : NEW_LINE INDENT Hash [ ord ( string [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 0 , len ( string ) ) : NEW_LINE INDENT if Hash [ ord ( string [ i ] ) - ord ( ' a ' ) ] > 1 : NEW_LINE INDENT for j in range ( 0 , 26 ) : NEW_LINE INDENT if Hash [ j ] == 0 : NEW_LINE INDENT Hash [ ord ( string [ i ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE string [ i ] = chr ( j + ord ( ' a ' ) ) NEW_LINE Hash [ j ] += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( ' ' . join ( string ) ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" xxxxyyyy \" NEW_LINE minReplacement ( list ( string ) ) NEW_LINE DEDENT"],"bleu":0.6092438034547697,"rouge_l":0.7575548502828756}
{"id":1241,"predictions":["N = 3 NEW_LINE def findStepsForMoves ( arr ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( N ) : NEW_LINE INDENT sum += abs ( arr [ i ] [ j ] ) NEW_LINE sum -= abs ( arr [ i ] [ j ] ) NEW_LINE DEDENT if ( abs ( arr [ i ] [ i ] ) < abs ( sum ) ) : NEW_LINE INDENT result += abs ( arr [ i ] [ i ] - abs ( sum ) ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ [ 3 , - 2 , 1 ] , [ - 3 , 2 ] , [ - 1 , 4 ] ] NEW_LINE print ( findStepsForMoves ( arr ) ) NEW_LINE DEDENT"],"references":["N = 3 NEW_LINE def findStepsForDDM ( arr ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( N ) : NEW_LINE INDENT sum += abs ( arr [ i ] [ j ] ) NEW_LINE DEDENT sum -= abs ( arr [ i ] [ i ] ) NEW_LINE if ( abs ( arr [ i ] [ i ] ) < abs ( sum ) ) : NEW_LINE INDENT result += abs ( abs ( arr [ i ] [ i ] ) - abs ( sum ) ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT arr = [ [ 3 , - 2 , 1 ] , [ 1 , - 3 , 2 ] , [ - 1 , 2 , 4 ] ] NEW_LINE print ( findStepsForDDM ( arr ) ) NEW_LINE"],"bleu":0.8100826386055008,"rouge_l":0.9115895077855577}
{"id":1242,"predictions":["def isArmstrong ( x , n ) : NEW_LINE INDENT sum1 , temp = 0 , 0 NEW_LINE while ( temp ) : NEW_LINE INDENT digit = temp % 10 NEW_LINE sum1 += pow ( 10 , n ) NEW_LINE DEDENT return sum1 == x NEW_LINE DEDENT def CalculateXOR ( n ) : NEW_LINE INDENT CalculateXOR = 0 NEW_LINE CalculateYOR ( n - 1 ) NEW_LINE start = int ( math . pow ( 10 , n - 1 ) ) NEW_LINE end = int ( math . pow ( 10 , n ) - 1 ) NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT if ( isArmstrong ( i , n ) ) : NEW_LINE INDENT CalculateXOR ( i , n ) NEW_LINE DEDENT DEDENT print ( \" XOR ▁ = \" , end = \" , ▁ \" ) NEW_LINE DEDENT DEDENT n = 4 NEW_LINE CalculateXOR ( n ) NEW_LINE"],"references":["def isArmstrong ( x , n ) : NEW_LINE INDENT sum1 = 0 NEW_LINE temp = x NEW_LINE while temp > 0 : NEW_LINE INDENT digit = temp % 10 NEW_LINE sum1 += digit ** n NEW_LINE temp \/\/= 10 NEW_LINE DEDENT return sum1 == x NEW_LINE DEDENT def CalculateXORandOR ( n ) : NEW_LINE INDENT CalculateXOR = 0 NEW_LINE CalculateOR = 0 NEW_LINE start = 10 ** ( n - 1 ) NEW_LINE end = ( 10 ** n ) - 1 NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT if ( isArmstrong ( i , n ) ) : NEW_LINE INDENT CalculateXOR = CalculateXOR ^ i NEW_LINE CalculateOR = CalculateOR | i NEW_LINE DEDENT DEDENT print ( \" XOR ▁ = ▁ \" , CalculateXOR ) NEW_LINE print ( \" OR ▁ = ▁ \" , CalculateOR ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 ; NEW_LINE CalculateXORandOR ( n ) ; NEW_LINE DEDENT"],"bleu":0.5212280869735468,"rouge_l":0.7012860483242401}
{"id":1243,"predictions":["from math import * NEW_LINE def decToDecimal ( n ) : NEW_LINE INDENT octalNum = [ ] NEW_LINE i = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT octalNum . append ( n % 8 ) NEW_LINE n \/\/= 8 NEW_LINE i += 1 NEW_LINE DEDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT octalNum [ j ] = n % 8 NEW_LINE DEDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT octalNum . append ( octalNum [ j ] ) NEW_LINE DEDENT DEDENT def nDigitPerfectSquare ( n ) : NEW_LINE INDENT decimalToDecimal ( n ) NEW_LINE decimalDigitNum = int ( math . ceil ( math . sqrt ( 8 ) ) ) NEW_LINE print ( int ( nDigitNum ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 2 NEW_LINE n = 2 NEW_LINE print ( nDigitPerfectSquare ( n ) ) NEW_LINE DEDENT"],"references":["from math import sqrt , ceil NEW_LINE def decToOctal ( n ) : NEW_LINE INDENT octalNum = [ 0 ] * 100 ; NEW_LINE i = 0 ; NEW_LINE while ( n != 0 ) : NEW_LINE INDENT octalNum [ i ] = n % 8 ; NEW_LINE n = n \/\/ 8 ; NEW_LINE i += 1 ; NEW_LINE DEDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( octalNum [ j ] , end = \" \" ) ; NEW_LINE DEDENT print ( ) ; NEW_LINE DEDENT def nDigitPerfectSquares ( n ) : NEW_LINE INDENT decimal = pow ( ceil ( sqrt ( pow ( 8 , n ) ) ) - 1 , 2 ) ; NEW_LINE decToOctal ( decimal ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 2 ; NEW_LINE nDigitPerfectSquares ( n ) ; NEW_LINE DEDENT"],"bleu":0.4857105514663979,"rouge_l":0.6831904947409428}
{"id":1244,"predictions":["def getNextElement ( n ) : NEW_LINE INDENT finalNum * 2 NEW_LINE finalNum = 2 NEW_LINE while ( finalNum * 2 <= n ) : NEW_LINE INDENT finalNum *= 2 NEW_LINE finalNum *= 2 NEW_LINE DEDENT return finalNum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 12 NEW_LINE print ( getNextElement ( N ) ) NEW_LINE DEDENT"],"references":["def getFinalElement ( n ) : NEW_LINE INDENT finalNum = 2 NEW_LINE while finalNum * 2 <= n : NEW_LINE INDENT finalNum *= 2 NEW_LINE DEDENT return finalNum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 12 NEW_LINE print ( getFinalElement ( N ) ) NEW_LINE DEDENT"],"bleu":0.6377258986295447,"rouge_l":0.8652482269503546}
{"id":1245,"predictions":["def maxSum ( arr , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT ans = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans = min ( ans , ( arr [ i ] + arr [ i + 1 ] ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 12 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxSum ( arr , n ) ) NEW_LINE"],"references":["def maxSum ( arr , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT ans = arr [ 0 ] + arr [ 1 ] NEW_LINE for i in range ( 1 , n - 1 , 1 ) : NEW_LINE INDENT ans = min ( ans , ( arr [ i ] + arr [ i + 1 ] ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 12 , 2 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxSum ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.7375969765920114,"rouge_l":0.866785079928952}
{"id":1246,"predictions":["def findCount ( str ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT if ( i == ( ord ( str [ i ] ) - ord ( ' a ' ) ) or ( ord ( str [ i ] ) - ord ( ' a ' ) ) > int ( ord ( str [ i ] ) - ord ( ' A ' ) ) ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" abgf \" NEW_LINE print ( findCount ( str ) ) NEW_LINE DEDENT"],"references":["def findCount ( str ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( ( i == ord ( str [ i ] ) - ord ( ' a ' ) ) or ( i == ord ( str [ i ] ) - ord ( ' A ' ) ) ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT str = ' AbgdeF ' NEW_LINE print ( findCount ( str ) ) NEW_LINE"],"bleu":0.6336569601931893,"rouge_l":0.827666874610106}
{"id":1247,"predictions":["def power ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT elif ( y % 2 == 0 ) : NEW_LINE INDENT return power ( x , y \/\/ 2 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return ( x * power ( x , y \/\/ 2 ) * power ( x , y \/\/ 2 ) ) ; NEW_LINE DEDENT DEDENT def sieveOfEratosthenes ( n , isPrime ) : NEW_LINE INDENT isPrime = [ False ] * ( isPrime [ True ] ) ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT isPrime [ i ] = True ; NEW_LINE DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( isPrime [ p ] ) : NEW_LINE INDENT isPrime [ p ] = False ; NEW_LINE DEDENT DEDENT if ( isPrime [ p ] ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT def leftTend ( n , isPrime ) : NEW_LINE INDENT temp = 0 ; NEW_LINE cnt = 0 ; NEW_LINE while ( True ) : NEW_LINE INDENT if ( isPrime [ p ] ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT if ( cnt == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT isPrime [ n ] = True ; NEW_LINE if ( isPrime ( n ) ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT else : NEW_LINE INDENT isPrime ( n + 1 ) ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 125 ; NEW_LINE if ( isPrime ( n ) ) : NEW_LINE INDENT print ( n , end = \" ▁ \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( n , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT"],"references":["def power ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( y % 2 == 0 ) : NEW_LINE INDENT return ( power ( x , y \/\/ 2 ) * power ( x , y \/\/ 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( x * power ( x , y \/\/ 2 ) * power ( x , y \/\/ 2 ) ) NEW_LINE DEDENT DEDENT def sieveOfEratosthenes ( n , isPrime ) : NEW_LINE INDENT isPrime [ 0 ] = isPrime [ 1 ] = False NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT isPrime [ i ] = True NEW_LINE DEDENT p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( isPrime [ p ] == True ) : NEW_LINE INDENT i = p * 2 NEW_LINE while ( i <= n ) : NEW_LINE INDENT isPrime [ i ] = False NEW_LINE i = i + p NEW_LINE DEDENT DEDENT p = p + 1 NEW_LINE DEDENT DEDENT def leftTruPrime ( n ) : NEW_LINE INDENT temp = n NEW_LINE cnt = 0 NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE temp1 = temp % 10 ; NEW_LINE if ( temp1 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT temp = temp \/\/ 10 NEW_LINE DEDENT isPrime = [ None ] * ( n + 1 ) NEW_LINE sieveOfEratosthenes ( n , isPrime ) NEW_LINE for i in range ( cnt , 0 , - 1 ) : NEW_LINE INDENT mod = power ( 10 , i ) NEW_LINE if ( isPrime [ n % mod ] != True ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT n = 113 NEW_LINE if ( leftTruPrime ( n ) ) : NEW_LINE INDENT print ( n , \" is ▁ left ▁ truncatable ▁ prime \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n , \" is ▁ not ▁ left ▁ truncatable ▁ prime \" ) NEW_LINE DEDENT"],"bleu":0.5322657526392889,"rouge_l":0.6648424925270177}
{"id":1248,"predictions":["import sys NEW_LINE def findExtraCharcter ( strA , strB ) : NEW_LINE INDENT m1 = [ 0 ] * 256 NEW_LINE for i in range ( len ( strA ) ) : NEW_LINE INDENT m1 [ ord ( strA [ i ] ) ] += 1 NEW_LINE DEDENT for i in range ( len ( strB ) ) : NEW_LINE INDENT if ( m1 [ i ] == 1 ) : NEW_LINE INDENT if ( m1 [ i ] == 1 ) : NEW_LINE INDENT return ( ord ( strA [ i ] ) + ord ( '0' ) ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT i = i NEW_LINE DEDENT DEDENT return ord ( strA ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT strA = \" abcd \" NEW_LINE strB = \" cbdadad \" NEW_LINE print ( findExtraCharcter ( strA , strB ) ) NEW_LINE DEDENT"],"references":["def findExtraCharacter ( strA , strB ) : NEW_LINE INDENT m1 = { } NEW_LINE for i in strB : NEW_LINE INDENT if i in m1 : NEW_LINE INDENT m1 [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m1 [ i ] = 1 NEW_LINE DEDENT DEDENT for i in strA : NEW_LINE INDENT m1 [ i ] -= 1 NEW_LINE DEDENT for h1 in m1 : NEW_LINE INDENT if m1 [ h1 ] == 1 : NEW_LINE INDENT return h1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT strA = ' abcd ' NEW_LINE strB = ' cbdad ' NEW_LINE print ( findExtraCharacter ( strA , strB ) ) NEW_LINE DEDENT"],"bleu":0.4233333924786384,"rouge_l":0.612625538020086}
{"id":1249,"predictions":["def AvgofSquareN ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( i * i ) NEW_LINE DEDENT return int ( sum \/ n ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 2 NEW_LINE print ( AvgofSquareN ( n ) ) NEW_LINE DEDENT"],"references":["def AvgofSquareN ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( i * i ) NEW_LINE DEDENT return sum \/ n NEW_LINE DEDENT n = 2 NEW_LINE print ( AvgofSquareN ( n ) ) NEW_LINE"],"bleu":0.6917814539946618,"rouge_l":0.8838162930563149}
{"id":1250,"predictions":["def lcm_fun ( b , a ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return lcm_fun ( b , a % b ) NEW_LINE DEDENT def digitLCM ( n ) : NEW_LINE INDENT lcm = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT lcm = ( n % 10 ) \/\/ lcm NEW_LINE if ( lcm == int ( lcm ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT n = int ( n \/ 10 ) NEW_LINE if ( lcm == int ( n \/ 10 ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT n = int ( n \/ 10 ) NEW_LINE DEDENT return lcm NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 39 NEW_LINE print ( digitLCM ( n ) ) NEW_LINE DEDENT"],"references":["def lcm_fun ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a ; NEW_LINE DEDENT return lcm_fun ( b , a % b ) ; NEW_LINE DEDENT def digitLCM ( n ) : NEW_LINE INDENT lcm = 1 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT lcm = int ( ( n % 10 * lcm ) \/ lcm_fun ( n % 10 , lcm ) ) ; NEW_LINE if ( lcm == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT n = int ( n \/ 10 ) ; NEW_LINE DEDENT return lcm ; NEW_LINE DEDENT n = 397 ; NEW_LINE print ( digitLCM ( n ) ) ; NEW_LINE"],"bleu":0.5529911822220832,"rouge_l":0.766219512195122}
{"id":1251,"predictions":["def fact ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT return n * fact ( n - 1 ) ; NEW_LINE DEDENT def nPr ( n , r ) : NEW_LINE INDENT return fact ( n ) \/\/ fact ( n - r ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 ; r = 2 ; NEW_LINE print ( n , r ) ; NEW_LINE DEDENT"],"references":["import math NEW_LINE def fact ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n * fact ( n - 1 ) NEW_LINE DEDENT def nPr ( n , r ) : NEW_LINE INDENT return math . floor ( fact ( n ) \/ fact ( n - r ) ) NEW_LINE DEDENT n = 5 NEW_LINE r = 2 NEW_LINE print ( n , \" P \" , r , \" = \" , nPr ( n , r ) ) NEW_LINE"],"bleu":0.5340699595539616,"rouge_l":0.7319126074498568}
{"id":1252,"predictions":["def isPossible ( a , n ) : NEW_LINE INDENT cur = a [ 0 ] NEW_LINE cur -= 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT nxt = a [ i ] NEW_LINE if ( nxt > cur ) : NEW_LINE INDENT if ( nxt ) : NEW_LINE INDENT nxt -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT nxt -= 1 NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 2 , 1 , 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE if ( isPossible ( a , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def isPossible ( a , n ) : NEW_LINE INDENT cur = a [ 0 ] ; NEW_LINE cur -= 1 ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT nxt = a [ i ] ; NEW_LINE if ( nxt > cur ) : NEW_LINE INDENT nxt -= 1 ; NEW_LINE DEDENT elif ( nxt < cur ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT cur = nxt ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 2 , 1 , 2 , 3 ] ; NEW_LINE n = len ( a ) ; NEW_LINE if ( isPossible ( a , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"],"bleu":0.7423034389505316,"rouge_l":0.8763022261212852}
{"id":1253,"predictions":["def fact ( n ) : NEW_LINE INDENT num = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT num = num * i NEW_LINE if ( fact ( num ) % k == 0 ) : NEW_LINE INDENT return num NEW_LINE DEDENT num = num * i NEW_LINE DEDENT return 0 NEW_LINE DEDENT def Special_Factorial_number ( k ) : NEW_LINE INDENT for i in range ( 1 , k + 1 ) : NEW_LINE INDENT if ( fact ( k ) % k == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT k = 16 NEW_LINE print ( special_Factorial_number ( k ) ) NEW_LINE"],"references":["def fact ( n ) : NEW_LINE INDENT num = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT num = num * i NEW_LINE DEDENT return num NEW_LINE DEDENT def Special_Factorial_Number ( k ) : NEW_LINE INDENT for i in range ( 1 , k + 1 ) : NEW_LINE INDENT if ( fact ( i ) % k == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT k = 16 NEW_LINE print ( Special_Factorial_Number ( k ) ) NEW_LINE DEDENT"],"bleu":0.7298147124366573,"rouge_l":0.8028663351857268}
{"id":1254,"predictions":["mod = 1000000007 NEW_LINE def noOfBinaryStrings ( N , k ) : NEW_LINE INDENT dp = [ 0 ] * ( k + 1 ) NEW_LINE dp [ 0 ] = 1 NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT dp [ i ] = ( dp [ i - 1 ] + dp [ i - k ] ) % mod NEW_LINE DEDENT dp [ k ] = 2 NEW_LINE for i in range ( k + 1 ) : NEW_LINE INDENT dp [ i ] = ( dp [ i - k ] + dp [ i - k ] ) % mod NEW_LINE DEDENT return dp [ N ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 4 NEW_LINE K = 2 NEW_LINE print ( noOfBinaryStrings ( N , K ) ) NEW_LINE DEDENT"],"references":["mod = 1000000007 ; NEW_LINE def noOfBinaryStrings ( N , k ) : NEW_LINE INDENT dp = [ 0 ] * 100002 ; NEW_LINE for i in range ( 1 , K ) : NEW_LINE INDENT dp [ i ] = 1 ; NEW_LINE DEDENT dp [ k ] = 2 ; NEW_LINE for i in range ( k + 1 , N + 1 ) : NEW_LINE INDENT dp [ i ] = ( dp [ i - 1 ] + dp [ i - k ] ) % mod ; NEW_LINE DEDENT return dp [ N ] ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 4 ; NEW_LINE K = 2 ; NEW_LINE print ( noOfBinaryStrings ( N , K ) ) ; NEW_LINE DEDENT"],"bleu":0.6960922323244946,"rouge_l":0.8428685622930228}
{"id":1255,"predictions":["def reverse ( arr , n , k ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT left = i NEW_LINE right = min ( i + k , n - 1 ) NEW_LINE while ( left < right ) : NEW_LINE INDENT if ( arr [ left ] == arr [ right ] ) : NEW_LINE INDENT arr [ left ] , arr [ right ] = arr [ i ] , arr [ right ] NEW_LINE left -= 1 NEW_LINE right -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ left ] , arr [ right ] = arr [ right ] , arr [ right ] NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 4 , 5 , 6 , 7 , 13 , 13 , 13 , 13 ] NEW_LINE k = 3 NEW_LINE reverse ( arr , arr , n , k ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT"],"references":["def reverse ( arr , n , k ) : NEW_LINE INDENT for i in range ( 0 , n , 2 * k ) : NEW_LINE INDENT left = i NEW_LINE right = min ( i + k - 1 , n - 1 ) NEW_LINE while ( left < right ) : NEW_LINE INDENT temp = arr [ left ] NEW_LINE arr [ left ] = arr [ right ] NEW_LINE arr [ right ] = temp NEW_LINE left += 1 NEW_LINE right -= 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 ] NEW_LINE k = 3 NEW_LINE n = len ( arr ) NEW_LINE reverse ( arr , n , k ) NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.6878304989850486,"rouge_l":0.7981597163599528}
{"id":1256,"predictions":["MAX = 100 NEW_LINE mat = [ [ 0 for j in range ( MAX ) ] for k in range ( MAX ) ] NEW_LINE def fillRemaining ( i , j ) : NEW_LINE INDENT x = 2 NEW_LINE for k in range ( i + 1 , n ) : NEW_LINE INDENT mat [ k ] [ i ] = x NEW_LINE DEDENT for k in range ( i + 1 , i ) : NEW_LINE INDENT for k in range ( i , n , i ) : NEW_LINE INDENT mat [ k ] [ j ] = x + 1 NEW_LINE DEDENT DEDENT DEDENT def constructRemaining ( n ) : NEW_LINE INDENT right = n - 1 NEW_LINE left = 0 NEW_LINE left = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT mat [ right ] [ right ] = 1 NEW_LINE left -= 1 NEW_LINE right -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT mat [ left ] [ right ] = 1 NEW_LINE left += 1 NEW_LINE left -= 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT def displayMatrix ( n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT n = 5 NEW_LINE displayMatrix ( n ) NEW_LINE"],"references":["MAX = 100 ; NEW_LINE mat = [ [ 0 for x in range ( MAX ) ] for y in range ( MAX ) ] ; NEW_LINE def fillRemaining ( i , j , n ) : NEW_LINE INDENT x = 2 ; NEW_LINE for k in range ( i + 1 , n ) : NEW_LINE INDENT mat [ k ] [ j ] = x ; NEW_LINE x += 1 ; NEW_LINE DEDENT for k in range ( i ) : NEW_LINE INDENT mat [ k ] [ j ] = x ; NEW_LINE x += 1 ; NEW_LINE DEDENT DEDENT def constructMatrix ( n ) : NEW_LINE INDENT right = n - 1 ; NEW_LINE left = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT mat [ i ] [ right ] = 1 ; NEW_LINE fillRemaining ( i , right , n ) ; NEW_LINE right -= 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT mat [ i ] [ left ] = 1 ; NEW_LINE fillRemaining ( i , left , n ) ; NEW_LINE left += 1 ; NEW_LINE DEDENT DEDENT DEDENT n = 5 ; NEW_LINE constructMatrix ( n ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( \" \" ) ; NEW_LINE DEDENT"],"bleu":0.6484769175416455,"rouge_l":0.7772142503711034}
{"id":1257,"predictions":["def printMaxOfMin ( arr , n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT maxOfMin = - sys . maxsize NEW_LINE for j in range ( 1 , k + 1 ) : NEW_LINE INDENT minOfMin = arr [ i ] NEW_LINE if ( arr [ i + j ] < minOfMin ) : NEW_LINE INDENT minOfMin = arr [ i + j ] NEW_LINE DEDENT DEDENT if ( min > maxOfMin ) : NEW_LINE INDENT maxOfMin = arr [ i ] NEW_LINE DEDENT DEDENT print ( maxOfMin , \" ▁ \" , end = \" ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 10 , 20 , 30 , 50 , 30 , 30 , 30 ] NEW_LINE n = len ( arr ) NEW_LINE printMaxOfMin ( arr , n ) NEW_LINE DEDENT"],"references":["INT_MIN = - 1000000 NEW_LINE def printMaxOfMin ( arr , n ) : NEW_LINE INDENT for k in range ( 1 , n + 1 ) : NEW_LINE INDENT maxOfMin = INT_MIN ; NEW_LINE for i in range ( n - k + 1 ) : NEW_LINE INDENT min = arr [ i ] NEW_LINE for j in range ( k ) : NEW_LINE INDENT if ( arr [ i + j ] < min ) : NEW_LINE INDENT min = arr [ i + j ] NEW_LINE DEDENT DEDENT if ( min > maxOfMin ) : NEW_LINE INDENT maxOfMin = min NEW_LINE DEDENT DEDENT print ( maxOfMin , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 10 , 20 , 30 , 50 , 10 , 70 , 30 ] NEW_LINE n = len ( arr ) NEW_LINE printMaxOfMin ( arr , n ) NEW_LINE"],"bleu":0.6939371653563318,"rouge_l":0.7892183288409703}
{"id":1258,"predictions":["def countSubArrays ( arr , n , K ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT bitwise_or = bitwise_or | arr [ i ] NEW_LINE DEDENT if ( bitwise_or >= K ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE k = 6 NEW_LINE print ( countSubArrays ( arr , n , k ) ) NEW_LINE DEDENT"],"references":["def countSubArrays ( arr , n , K ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT bitwise_or = 0 NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT bitwise_or = bitwise_or | arr [ k ] NEW_LINE DEDENT if ( bitwise_or >= K ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE k = 6 NEW_LINE print ( countSubArrays ( arr , n , k ) ) NEW_LINE DEDENT"],"bleu":0.7841606929332727,"rouge_l":0.8924132573795961}
{"id":1259,"predictions":["MAX = 26 NEW_LINE def getString ( string , n ) : NEW_LINE INDENT umap = [ 0 ] * MAX ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT umap [ ord ( string [ i ] ) % MAX ] += 1 ; NEW_LINE DEDENT for i in range ( MAX ) : NEW_LINE INDENT umap [ ord ( string [ i ] ) % MAX ] += 1 ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT string = input ( ) ; NEW_LINE if umap [ ord ( string [ i ] ) ] > MAX : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT return string ; NEW_LINE DEDENT string = \" geeksforgeeks \" ; NEW_LINE n = len ( string ) ; NEW_LINE print ( getString ( string , n ) ) ; NEW_LINE"],"references":["CHARS = \" qwertyuiopasdfghjklzxcvbnm \" ; NEW_LINE MAX = 26 ; NEW_LINE def getString ( string , n ) : NEW_LINE INDENT string = list ( string ) ; NEW_LINE uMap = { } ; NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT uMap [ CHARS [ i ] ] = CHARS [ ( i + 1 ) % MAX ] ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT string [ i ] = uMap [ string [ i ] ] ; NEW_LINE DEDENT return \" \" . join ( string ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" geeks \" ; NEW_LINE n = len ( string ) ; NEW_LINE print ( getString ( string , n ) ) ; NEW_LINE DEDENT"],"bleu":0.5227495981864039,"rouge_l":0.637872243691748}
{"id":1260,"predictions":["def printOrder ( arr , k ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE arr . sort ( reverse = True ) NEW_LINE arr . sort ( reverse = True ) NEW_LINE for i in arr : NEW_LINE INDENT print ( i , end = \" \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 5 , 4 , 6 , 2 , 1 , 3 , 8 , 9 , - 1 ] NEW_LINE k = 4 NEW_LINE n = len ( arr ) NEW_LINE printOrder ( arr , k ) NEW_LINE DEDENT"],"references":["def printOrder ( arr , n , k ) : NEW_LINE INDENT a = arr [ 0 : k ] ; NEW_LINE a . sort ( ) ; NEW_LINE b = arr [ k : n ] ; NEW_LINE b . sort ( ) ; NEW_LINE b . reverse ( ) ; NEW_LINE return a + b ; NEW_LINE DEDENT arr = [ 5 , 4 , 6 , 2 , 1 , 3 , 8 , 9 , - 1 ] ; NEW_LINE k = 4 ; NEW_LINE n = len ( arr ) ; NEW_LINE arr = printOrder ( arr , n , k ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT"],"bleu":0.40725701543591514,"rouge_l":0.5629531970995385}
{"id":1261,"predictions":["import math NEW_LINE def countSteps ( n ) : NEW_LINE INDENT steps = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT largest = math . sqrt ( n ) NEW_LINE n -= ( largest * largest * largest ) NEW_LINE steps += 1 NEW_LINE DEDENT return steps NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 85 NEW_LINE print ( countSteps ( n ) ) NEW_LINE DEDENT"],"references":["from math import sqrt NEW_LINE def countSteps ( n ) : NEW_LINE INDENT steps = 0 ; NEW_LINE while ( n ) : NEW_LINE INDENT largest = int ( sqrt ( n ) ) ; NEW_LINE n -= ( largest * largest ) ; NEW_LINE steps += 1 ; NEW_LINE DEDENT return steps ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 85 ; NEW_LINE print ( countSteps ( n ) ) ; NEW_LINE DEDENT"],"bleu":0.5960633071951545,"rouge_l":0.8462002412545234}
{"id":1262,"predictions":["def Area ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT h = 1.464 * a NEW_LINE A = round ( h , 2 ) NEW_LINE return A NEW_LINE DEDENT a = 5 NEW_LINE print ( Area ( a ) ) NEW_LINE"],"references":["import math NEW_LINE def Area ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT h = 1.268 * a NEW_LINE A = 0.70477 * math . pow ( h , 2 ) NEW_LINE return A NEW_LINE DEDENT a = 5 NEW_LINE print ( Area ( a ) , end = \" \\n \" ) NEW_LINE"],"bleu":0.6867274851407142,"rouge_l":0.8405836260470142}
{"id":1263,"predictions":["SIZE = 26 NEW_LINE def isVowel ( ch ) : NEW_LINE INDENT if ( ch == ' a ' or ch == ' e ' or ch == ' i ' or ch == ' o ' or ch == ' u ' ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def generateUtil ( str1 , str2 , start , len ( str ) ) : NEW_LINE INDENT finalStr = \" \" NEW_LINE for i in range ( 0 , len ( str1 ) ) : NEW_LINE INDENT finalStr = ( finalStr + str1 [ ord ( str1 [ i ] ) ] + str2 [ i ] ) NEW_LINE DEDENT if ( finalStr != [ 0 ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT def generateUtil ( str1 , str2 , 0 , len ( str1 ) , len ( str2 ) , len ( str1 ) ) : NEW_LINE INDENT finalStr = [ 0 ] * ( ord ( str1 [ 0 ] ) + ord ( '0' ) + ord ( str1 [ 1 ] ) ) NEW_LINE for i in range ( 0 , len ( str1 ) ) : NEW_LINE INDENT ch = ord ( str1 [ i ] ) NEW_LINE if ( isVowel ( ch , str2 [ i ] ) ) : NEW_LINE INDENT if ( isVowel ( ch , ord ( str2 [ i ] ) ) ) : NEW_LINE INDENT finalStr += chr ( ord ( str2 [ i ] ) + ord ( '0' ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( finalStr > len ( str1 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT c = chr ( ord ( str1 [ i ] ) + ord ( ' a ' ) ) NEW_LINE DEDENT else : NEW_LINE INDENT c += chr ( ord ( str1 [ i ] ) + ord ( '0' ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( c ) : NEW_LINE INDENT return ( chr ( ord ( str1 [ 0 ] ) + ord ( '"],"references":["SIZE = 26 NEW_LINE def isVowel ( ch ) : NEW_LINE INDENT if ( ch == ' a ' or ch == ' e ' or ch == ' i ' or ch == ' o ' or ch == ' u ' ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def createAltStr ( str1 , str2 , start , l ) : NEW_LINE INDENT finalStr = \" \" NEW_LINE i = 0 NEW_LINE j = start NEW_LINE while j < l : NEW_LINE INDENT finalStr += str1 [ i ] + str2 [ j ] NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT return finalStr NEW_LINE DEDENT def findAltStr ( string ) : NEW_LINE INDENT char_freq = [ 0 ] * SIZE NEW_LINE nv = 0 NEW_LINE nc = 0 NEW_LINE vstr = \" \" NEW_LINE cstr = \" \" NEW_LINE l = len ( string ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT ch = string [ i ] NEW_LINE if isVowel ( ch ) : NEW_LINE INDENT nv += 1 NEW_LINE DEDENT else : NEW_LINE INDENT nc += 1 NEW_LINE DEDENT char_freq [ ord ( ch ) - 97 ] += 1 NEW_LINE DEDENT if abs ( nv - nc ) >= 2 : NEW_LINE INDENT return \" no ▁ such ▁ string \" NEW_LINE DEDENT for i in range ( SIZE ) : NEW_LINE INDENT ch = chr ( i + 97 ) NEW_LINE for j in range ( 1 , char_freq [ i ] + 1 ) : NEW_LINE INDENT if isVowel ( ch ) : NEW_LINE INDENT vstr += ch NEW_LINE DEDENT else : NEW_LINE INDENT cstr += ch NEW_LINE DEDENT DEDENT DEDENT if nv > nc : NEW_LINE INDENT return vstr [ 0 ] + createAltStr ( cstr , vstr , 1 , nv ) NEW_LINE DEDENT if nc > nv : NEW_LINE INDENT return cstr [ 0 ] + createAltStr ( vstr , cstr , 1 , nc ) NEW_LINE DEDENT if cstr [ 0 ] < vstr [ 0 ] : NEW_LINE INDENT return createAltStr ( cstr , vstr , 0 , nv ) NEW_LINE DEDENT return createAltStr ( vstr , cstr , 0 , nc ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" aeroplane \" NEW_LINE print ( findAltStr ( string ) ) NEW_LINE DEDENT"],"bleu":0.372475101914056,"rouge_l":0.48404481031995245}
{"id":1264,"predictions":["N = 5 NEW_LINE M = 5 NEW_LINE def minOperation ( arr ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( M - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] [ j ] == 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT mat = [ [ False , 0 , True , True , True ] , [ False , False , True ] , [ False , False , True , True ] , [ True , False , True ] ] NEW_LINE ans = minOperation ( mat ) NEW_LINE if ( ans == True ) : NEW_LINE INDENT print ( \" true \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" True \" ) NEW_LINE DEDENT DEDENT"],"references":["def minOperation ( arr ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( M - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] [ j ] == 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE for k in range ( i + 1 ) : NEW_LINE INDENT for h in range ( j + 1 ) : NEW_LINE INDENT if ( arr [ k ] [ h ] == 1 ) : NEW_LINE INDENT arr [ k ] [ h ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ k ] [ h ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT mat = [ [ 0 , 0 , 1 , 1 , 1 ] , [ 0 , 0 , 0 , 1 , 1 ] , [ 0 , 0 , 0 , 1 , 1 ] , [ 1 , 1 , 1 , 1 , 1 ] , [ 1 , 1 , 1 , 1 , 1 ] ] NEW_LINE M = 5 NEW_LINE N = 5 NEW_LINE print ( minOperation ( mat ) ) NEW_LINE"],"bleu":0.45823693583609865,"rouge_l":0.5452624735901187}
{"id":1265,"predictions":["def decToOctal ( n ) : NEW_LINE INDENT octalNum = [ 0 ] * 100 NEW_LINE i = 0 NEW_LINE while ( n ) : NEW_LINE INDENT octal [ num ] = n % 8 NEW_LINE n = int ( n \/ 8 ) NEW_LINE i += 1 NEW_LINE DEDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT octal [ j ] = n % 8 NEW_LINE DEDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT octal [ j ] = octal [ j ] NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 33 NEW_LINE decToOctal ( n ) NEW_LINE print ( decToOctal ( n ) ) NEW_LINE DEDENT"],"references":["def decToOctal ( n ) : NEW_LINE INDENT octalNum = [ 0 ] * 100 ; NEW_LINE i = 0 ; NEW_LINE while ( n != 0 ) : NEW_LINE INDENT octalNum [ i ] = n % 8 ; NEW_LINE n = int ( n \/ 8 ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( octalNum [ j ] , end = \" \" ) ; NEW_LINE DEDENT DEDENT n = 33 ; NEW_LINE decToOctal ( n ) ; NEW_LINE"],"bleu":0.45159326214237727,"rouge_l":0.7084091227088288}
{"id":1266,"predictions":["def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT def isFactorialPrime ( n ) : NEW_LINE INDENT if ( not ( n ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT fact = 1 NEW_LINE i = 1 NEW_LINE while ( fact <= n + 1 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT n = 23 NEW_LINE if ( isFactorialPrime ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["from math import sqrt NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 5 , int ( sqrt ( n ) ) + 1 , 6 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def isFactorialPrime ( n ) : NEW_LINE INDENT if ( not isPrime ( n ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT fact = 1 NEW_LINE i = 1 NEW_LINE while ( fact <= n + 1 ) : NEW_LINE INDENT fact = fact * i NEW_LINE if ( n + 1 == fact or n - 1 == fact ) : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 23 NEW_LINE if ( isFactorialPrime ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.7505382601483938,"rouge_l":0.839991393530804}
{"id":1267,"predictions":["def convertNum ( m , n ) : NEW_LINE INDENT if ( m == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( m > n ) : NEW_LINE INDENT return ( m - n ) NEW_LINE DEDENT if ( m <= 0 ) : NEW_LINE INDENT return ( 1 + convert ( m , n + 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return 1 + convert ( m , n \/ 2 ) NEW_LINE DEDENT DEDENT def convertNum ( m , n ) : NEW_LINE INDENT if ( m == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 + convertNum ( m , n + 1 ) NEW_LINE DEDENT DEDENT m = 3 NEW_LINE n = 11 NEW_LINE print ( \" Minimum ▁ number : ▁ \" , convertNum ( m , n ) ) NEW_LINE"],"references":["def conver ( m , n ) : NEW_LINE INDENT if ( m == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( m > n ) : NEW_LINE INDENT return m - n NEW_LINE DEDENT if ( m <= 0 and n > 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return 1 + conver ( m , n + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return 1 + conver ( m , n \/ 2 ) NEW_LINE DEDENT DEDENT m = 3 NEW_LINE n = 11 NEW_LINE print ( \" Minimum ▁ number ▁ of ▁ operations ▁ : \" , conver ( m , n ) ) NEW_LINE"],"bleu":0.6292962377305716,"rouge_l":0.7613104524180967}
{"id":1268,"predictions":["MAX = 10000 ; NEW_LINE prime = [ True ] * ( MAX ) ; NEW_LINE def sieve ( ) : NEW_LINE INDENT prime [ 1 ] = False ; NEW_LINE p = 2 ; NEW_LINE while ( p * p < MAX ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT p += 1 ; NEW_LINE DEDENT DEDENT def printPrime ( n ) : NEW_LINE INDENT for i in range ( n - 7 ) : NEW_LINE INDENT if ( prime [ i ] and prime [ i + 2 ] and prime [ i + 2 ] ) : NEW_LINE INDENT print ( i , \" ▁ \" , end = \" \" ) ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 20 ; NEW_LINE sieve ( ) ; NEW_LINE printPrime ( n ) ; NEW_LINE DEDENT"],"references":["from math import sqrt NEW_LINE MAX = 100000 NEW_LINE prime = [ True ] * MAX NEW_LINE def sieve ( ) : NEW_LINE INDENT for p in range ( 2 , int ( sqrt ( MAX ) ) + 1 ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def printPrimeQuad ( n ) : NEW_LINE INDENT for i in range ( n - 7 ) : NEW_LINE INDENT if ( prime [ i ] and prime [ i + 2 ] and prime [ i + 6 ] and prime [ i + 8 ] ) : NEW_LINE INDENT print ( i , i + 2 , i + 6 , i + 8 ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT sieve ( ) NEW_LINE n = 20 NEW_LINE printPrimeQuad ( 20 ) NEW_LINE DEDENT"],"bleu":0.6219142432204289,"rouge_l":0.7511771097428468}
{"id":1269,"predictions":["def sum ( mat , r , c ) : NEW_LINE INDENT lower_sum = 0 NEW_LINE upper_sum , upper_sum = 0 , 0 NEW_LINE for i in range ( r ) : NEW_LINE INDENT for j in range ( c ) : NEW_LINE INDENT if ( i <= j ) : NEW_LINE INDENT upper_sum += mat [ i ] [ j ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT upper_sum += mat [ i ] [ j ] NEW_LINE DEDENT DEDENT print ( \" Lower_sum ▁ sum ▁ is \" , upper_sum ) NEW_LINE for i in range ( r ) : NEW_LINE INDENT for j in range ( c ) : NEW_LINE INDENT if ( j <= i ) : NEW_LINE INDENT lower_sum += mat [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT print ( \" lower ▁sum ▁ is \" , lower_sum ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"references":["def Sum ( mat , r , c ) : NEW_LINE INDENT i , j = 0 , 0 ; NEW_LINE upper_sum = 0 ; NEW_LINE lower_sum = 0 ; NEW_LINE for i in range ( r ) : NEW_LINE INDENT for j in range ( c ) : NEW_LINE INDENT if ( i <= j ) : NEW_LINE INDENT upper_sum += mat [ i ] [ j ] ; NEW_LINE DEDENT DEDENT DEDENT print ( \" Upper ▁ sum ▁ is ▁ \" , upper_sum ) ; NEW_LINE for i in range ( r ) : NEW_LINE INDENT for j in range ( c ) : NEW_LINE INDENT if ( j <= i ) : NEW_LINE INDENT lower_sum += mat [ i ] [ j ] ; NEW_LINE DEDENT DEDENT DEDENT print ( \" Lower ▁ sum ▁ is ▁ \" , lower_sum ) ; NEW_LINE DEDENT r = 3 ; NEW_LINE c = 3 ; NEW_LINE mat = [ [ 6 , 5 , 4 ] , [ 1 , 2 , 5 ] , [ 7 , 9 , 7 ] ] ; NEW_LINE Sum ( mat , r , c ) ; NEW_LINE"],"bleu":0.5584629570209311,"rouge_l":0.7038253306115203}
{"id":1270,"predictions":["def printArray ( arr , n , k ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT def remove ( arr , n ) : NEW_LINE INDENT minVal = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT minVal = min ( minVal , arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = arr [ i ] - minVal NEW_LINE DEDENT DEDENT def remove ( arr , n , k ) : NEW_LINE INDENT maxVal = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT arr [ i ] = maxVal - arr [ i - 1 ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT maxVal = max ( maxVal , arr [ i ] ) NEW_LINE DEDENT DEDENT def modifyArray ( arr , n , k ) : NEW_LINE INDENT if ( k % 2 == 0 ) : NEW_LINE INDENT if ( k % 2 == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT else : NEW_LINE INDENT return NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT modifyArray ( arr , n , k ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 8 , 12 , 16 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE modifyArray ( arr , n , k ) NEW_LINE modifyArray ( arr , n , k ) NEW_LINE DEDENT"],"references":["def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT def removeMin ( arr , n ) : NEW_LINE INDENT minVal = arr [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT minVal = min ( minVal , arr [ i ] ) ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = arr [ i ] - minVal ; NEW_LINE DEDENT DEDENT def removeFromMax ( arr , n ) : NEW_LINE INDENT maxVal = arr [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT maxVal = max ( maxVal , arr [ i ] ) ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = maxVal - arr [ i ] ; NEW_LINE DEDENT DEDENT def modifyArray ( arr , n , k ) : NEW_LINE INDENT if ( k % 2 == 0 ) : NEW_LINE INDENT removeMin ( arr , n ) ; NEW_LINE DEDENT else : NEW_LINE INDENT removeFromMax ( arr , n ) ; NEW_LINE DEDENT printArray ( arr , n ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 4 , 8 , 12 , 16 ] ; NEW_LINE n = len ( arr ) NEW_LINE k = 2 ; NEW_LINE modifyArray ( arr , n , k ) ; NEW_LINE DEDENT"],"bleu":0.7553437434492728,"rouge_l":0.8495328729762666}
{"id":1271,"predictions":["def LongestSubarray ( a , n , k ) : NEW_LINE INDENT pre = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] > k ) : NEW_LINE INDENT pre [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT pre [ i ] = - 1 NEW_LINE DEDENT DEDENT l = 1 NEW_LINE hi = n NEW_LINE while ( lo <= hi ) : NEW_LINE INDENT mid = ( lo + hi ) \/\/ 2 NEW_LINE if ( i - mid >= mid ) : NEW_LINE INDENT lo = mid NEW_LINE DEDENT else : NEW_LINE INDENT lo = mid + 1 NEW_LINE DEDENT DEDENT for i in range ( lo - 1 , n , 1 ) : NEW_LINE INDENT x = ( lo + hi ) \/\/ 2 NEW_LINE DEDENT if ( x < hi ) : NEW_LINE INDENT if ( i - mid >= lo ) : NEW_LINE INDENT if ( x - mid ) : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT lo = mid + 1 NEW_LINE DEDENT DEDENT DEDENT return l NEW_LINE DEDENT a = [ 2 , 3 , 4 , 5 , 3 , 7 ] NEW_LINE n = len ( a ) NEW_LINE print ( LongestSubarray ( a , n , k ) ) NEW_LINE"],"references":["def LongestSubarray ( a , n , k ) : NEW_LINE INDENT pre = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] > k ) : NEW_LINE INDENT pre [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT pre [ i ] = - 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT pre [ i ] = pre [ i - 1 ] + pre [ i ] NEW_LINE DEDENT Len = 0 NEW_LINE lo = 1 NEW_LINE hi = n NEW_LINE while ( lo <= hi ) : NEW_LINE INDENT mid = ( lo + hi ) \/\/ 2 NEW_LINE ok = False NEW_LINE for i in range ( mid - 1 , n ) : NEW_LINE INDENT x = pre [ i ] NEW_LINE if ( i - mid >= 0 ) : NEW_LINE INDENT x -= pre [ i - mid ] NEW_LINE DEDENT if ( x > 0 ) : NEW_LINE INDENT ok = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( ok == True ) : NEW_LINE INDENT Len = mid NEW_LINE lo = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT hi = mid - 1 NEW_LINE DEDENT DEDENT return Len NEW_LINE DEDENT a = [ 2 , 3 , 4 , 5 , 3 , 7 ] NEW_LINE k = 3 NEW_LINE n = len ( a ) NEW_LINE print ( LongestSubarray ( a , n , k ) ) NEW_LINE"],"bleu":0.6658863130566293,"rouge_l":0.7262369583306663}
{"id":1272,"predictions":["def findSum ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans += ( i \/\/ j ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 2 NEW_LINE print ( findSum ( N ) ) NEW_LINE DEDENT"],"references":["def findSum ( N ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 1 , N + 1 ) : NEW_LINE INDENT ans += i \/\/ j NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT N = 2 NEW_LINE print ( findSum ( N ) ) NEW_LINE"],"bleu":0.6153784447045773,"rouge_l":0.7297022143038941}
{"id":1273,"predictions":["def permutation ( arr , n ) : NEW_LINE INDENT hash = [ False ] * n NEW_LINE maxEle = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ arr [ i ] ] = True NEW_LINE maxEle = max ( maxEle , arr [ i ] ) NEW_LINE DEDENT if ( maxEle != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 5 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE if ( permutation ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def permutation ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE maxEle = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . add ( arr [ i ] ) ; NEW_LINE maxEle = max ( maxEle , arr [ i ] ) ; NEW_LINE DEDENT if ( maxEle != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( len ( s ) == n ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 5 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE if ( permutation ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.7060853342750009,"rouge_l":0.8388082505729564}
{"id":1274,"predictions":["N = 5 NEW_LINE dp = [ [ [ 0 for i in range ( N ) ] for i in range ( N ) ] for i in range ( N ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE dp [ 1 ] [ 0 ] = 1 NEW_LINE dp [ 1 ] [ 0 ] = 1 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( i > j ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 2 ] [ j - 2 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 2 ] + dp [ i - 2 ] [ j - 2 ] ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( 0 , N + 1 ) : NEW_LINE INDENT for j in range ( 0 , i + 1 ) : NEW_LINE INDENT print ( dp [ i ] [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE printHoor ( n ) NEW_LINE DEDENT"],"references":["N = 5 NEW_LINE def printHosoya ( n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( N ) ] for i in range ( N ) ] NEW_LINE dp [ 0 ] [ 0 ] = dp [ 1 ] [ 0 ] = dp [ 1 ] [ 1 ] = 1 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( i > j ) : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + dp [ i - 2 ] [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 2 ] [ j - 2 ] ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT print ( dp [ i ] [ j ] , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT n = 5 NEW_LINE printHosoya ( n ) NEW_LINE"],"bleu":0.7448463805238816,"rouge_l":0.8706119801052404}
{"id":1275,"predictions":["def pairs_count ( arr , n , sum ) : NEW_LINE INDENT ans = 0 ; NEW_LINE arr . sort ( ) ; NEW_LINE i = 0 ; j = n - 1 ; NEW_LINE while ( i < j ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] < sum ) : NEW_LINE INDENT i += 1 ; NEW_LINE j -= 1 ; NEW_LINE DEDENT elif ( arr [ i ] == sum [ j ] ) : NEW_LINE INDENT j -= 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT x = arr [ j ] ; NEW_LINE DEDENT j += 1 ; NEW_LINE DEDENT while ( i < j ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] == x ) : NEW_LINE INDENT j -= 1 ; NEW_LINE DEDENT if ( x == y ) : NEW_LINE INDENT j -= 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT j += 1 ; NEW_LINE DEDENT DEDENT DEDENT return ans ; NEW_LINE DEDENT arr = [ 1 , 5 , 7 , - 1 , - 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE sum = 6 ; NEW_LINE print ( pairs_count ( arr , n , sum ) ) ; NEW_LINE"],"references":["def pairs_count ( arr , n , sum ) : NEW_LINE INDENT ans = 0 NEW_LINE arr = sorted ( arr ) NEW_LINE i , j = 0 , n - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] < sum ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT elif ( arr [ i ] + arr [ j ] > sum ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT x = arr [ i ] NEW_LINE xx = i NEW_LINE while ( i < j and arr [ i ] == x ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT y = arr [ j ] NEW_LINE yy = j NEW_LINE while ( j >= i and arr [ j ] == y ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT if ( x == y ) : NEW_LINE INDENT temp = i - xx + yy - j - 1 NEW_LINE ans += ( temp * ( temp + 1 ) ) \/\/ 2 NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( i - xx ) * ( yy - j ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 5 , 7 , 5 , - 1 ] NEW_LINE n = len ( arr ) NEW_LINE sum = 6 NEW_LINE print ( pairs_count ( arr , n , sum ) ) NEW_LINE"],"bleu":0.5746462245681818,"rouge_l":0.7361996845642186}
{"id":1276,"predictions":["MAX = 10000 NEW_LINE fibonacci = [ 0 ] * MAX NEW_LINE curr = 1 NEW_LINE fibonacci = [ 0 ] * MAX NEW_LINE def createHash ( arr , n ) : NEW_LINE INDENT prev = 0 NEW_LINE fibonacci [ 0 ] = 1 NEW_LINE fibonacci [ 1 ] = 1 NEW_LINE while ( curr <= MAX ) : NEW_LINE INDENT temp = curr + prev NEW_LINE while ( curr <= MAX ) : NEW_LINE INDENT temp = curr + prev NEW_LINE fibonacci [ curr ] = 1 NEW_LINE prev = curr NEW_LINE curr = temp NEW_LINE DEDENT DEDENT if ( fibonacci [ n ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 8 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE if ( checkArray ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["MAX = 100005 NEW_LINE fibonacci = set ( ) NEW_LINE def createHash ( ) : NEW_LINE INDENT global fibonacci NEW_LINE prev , curr = 0 , 1 NEW_LINE fibonacci . add ( prev ) NEW_LINE fibonacci . add ( curr ) NEW_LINE while ( curr <= MAX ) : NEW_LINE INDENT temp = curr + prev NEW_LINE if temp <= MAX : NEW_LINE INDENT fibonacci . add ( temp ) NEW_LINE DEDENT prev = curr NEW_LINE curr = temp NEW_LINE DEDENT DEDENT def checkArray ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] in fibonacci ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT DEDENT if ( sum in fibonacci ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 8 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE createHash ( ) NEW_LINE if ( checkArray ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.5768039621724652,"rouge_l":0.670437224227838}
{"id":1277,"predictions":["def makearraydefault ( arr , n ) : NEW_LINE INDENT x = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x += ( arr [ i ] & 1 ) NEW_LINE DEDENT print ( minarray ( x , n - x ) ) NEW_LINE"],"references":["def makearrayequal ( arr , n ) : NEW_LINE INDENT x = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT x += arr [ i ] & 1 ; NEW_LINE DEDENT print ( min ( x , n - x ) ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 4 , 3 , 2 , 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE makearrayequal ( arr , n ) ; NEW_LINE DEDENT"],"bleu":0.29749815760676357,"rouge_l":0.5901495162708883}
{"id":1278,"predictions":["def countRotations ( arr , n ) : NEW_LINE INDENT min_index = - 1 NEW_LINE min_index = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( min_index > arr [ i ] ) : NEW_LINE INDENT min_index = arr [ i ] NEW_LINE min_index = i NEW_LINE DEDENT DEDENT return min_index NEW_LINE DEDENT arr = [ 15 , 18 , 2 , 3 , 12 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countRotations ( arr , n ) ) NEW_LINE"],"references":["def countRotations ( arr , n ) : NEW_LINE INDENT min = arr [ 0 ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( min > arr [ i ] ) : NEW_LINE INDENT min = arr [ i ] NEW_LINE min_index = i NEW_LINE DEDENT DEDENT return min_index ; NEW_LINE DEDENT arr = [ 15 , 18 , 2 , 3 , 6 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countRotations ( arr , n ) ) NEW_LINE"],"bleu":0.7681202894263219,"rouge_l":0.8804347826086957}
{"id":1279,"predictions":["def check ( s ) : NEW_LINE INDENT freq = [ 0 for i in range ( 10 ) ] NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT freq [ s [ i ] ] = 0 NEW_LINE DEDENT while ( s != 0 ) : NEW_LINE INDENT r = s % 10 NEW_LINE freq [ r ] += 1 NEW_LINE DEDENT xor = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT xor = xor ( s [ i ] ) NEW_LINE freq [ xor ] += 1 NEW_LINE if ( xor == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT s = 1222 NEW_LINE if ( check ( s ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def check ( s ) : NEW_LINE INDENT freq = [ 0 ] * 10 NEW_LINE while ( s != 0 ) : NEW_LINE INDENT r = s % 10 NEW_LINE s = s \/\/ 10 NEW_LINE freq [ r ] += 1 NEW_LINE DEDENT xor = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT xor = xor ^ freq [ i ] NEW_LINE DEDENT if ( xor == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT s = 122233 NEW_LINE if ( check ( s ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.6839571564439206,"rouge_l":0.8108536585365852}
{"id":1280,"predictions":["def count ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE p = 1 NEW_LINE while ( p <= n ) : NEW_LINE INDENT cnt += 1 NEW_LINE p *= 2 NEW_LINE DEDENT return cnt NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 7 NEW_LINE print ( count ( n ) ) NEW_LINE DEDENT"],"references":["def count ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE p = 1 NEW_LINE while ( p <= n ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE p *= 2 NEW_LINE DEDENT return cnt NEW_LINE DEDENT n = 7 NEW_LINE print ( count ( n ) ) ; NEW_LINE"],"bleu":0.7024374834659229,"rouge_l":0.8520524515393387}
{"id":1281,"predictions":["def powerSet ( string , index , curr ) : NEW_LINE INDENT if index == len ( string ) : NEW_LINE INDENT return NEW_LINE DEDENT for i in range ( index + 1 , n ) : NEW_LINE INDENT curr += string [ i ] NEW_LINE powerSet ( string , i , curr ) NEW_LINE DEDENT print ( curr ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" abc \" NEW_LINE index = - 1 NEW_LINE curr = \" \" NEW_LINE powerSet ( string , index , curr ) NEW_LINE DEDENT"],"references":["def powerSet ( str1 , index , curr ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE if ( index == n ) : NEW_LINE INDENT return NEW_LINE DEDENT print ( curr ) NEW_LINE for i in range ( index + 1 , n ) : NEW_LINE INDENT curr += str1 [ i ] NEW_LINE powerSet ( str1 , i , curr ) NEW_LINE curr = curr . replace ( curr [ len ( curr ) - 1 ] , \" \" ) NEW_LINE DEDENT return NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" abc \" ; NEW_LINE powerSet ( str , - 1 , \" \" ) NEW_LINE DEDENT"],"bleu":0.48941060907358386,"rouge_l":0.6790516119705075}
{"id":1282,"predictions":["def findMinimumX ( a , n ) : NEW_LINE INDENT st = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT st . add ( a [ i ] ) NEW_LINE DEDENT if ( len ( st ) == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( len ( st ) == 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( st [ len ( st ) % 2 ] == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( st [ len ( st ) \/\/ 2 ] ) % 2 == 0 ) : NEW_LINE INDENT return ( l2 - st [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( l2 - st [ 1 ] ) NEW_LINE DEDENT DEDENT if ( len ( st ) == 3 ) : NEW_LINE INDENT return se NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 4 , 4 , 7 , 4 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( findMinimumX ( a , n ) ) NEW_LINE DEDENT"],"references":["def findMinimumX ( a , n ) : NEW_LINE INDENT st = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT st . add ( a [ i ] ) NEW_LINE DEDENT if ( len ( st ) == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( len ( st ) == 2 ) : NEW_LINE INDENT st = list ( st ) NEW_LINE el1 = st [ 0 ] NEW_LINE el2 = st [ 1 ] NEW_LINE if ( ( el2 - el1 ) % 2 == 0 ) : NEW_LINE INDENT return int ( ( el2 - el1 ) \/ 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( el2 - el1 ) NEW_LINE DEDENT DEDENT if ( len ( st ) == 3 ) : NEW_LINE INDENT st = list ( st ) NEW_LINE el1 = st [ 0 ] NEW_LINE el2 = st [ 1 ] NEW_LINE el3 = st [ 2 ] NEW_LINE if ( ( el2 - el1 ) == ( el3 - el2 ) ) : NEW_LINE INDENT return el2 - el1 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 4 , 4 , 7 , 4 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( findMinimumX ( a , n ) ) NEW_LINE DEDENT"],"bleu":0.6356434144800073,"rouge_l":0.7283200670297444}
{"id":1283,"predictions":["def printFirst neg smallestInteger ( arr , n , k ) : NEW_LINE INDENT flag = False NEW_LINE for i in range ( n - k + 1 ) : NEW_LINE INDENT flag = True NEW_LINE for j in range ( k ) : NEW_LINE INDENT if ( arr [ i + j ] < k ) : NEW_LINE INDENT print ( arr [ i + j ] , end = \" ▁ \" ) NEW_LINE flag = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT print ( arr [ 0 ] , end = \" ▁ \" ) NEW_LINE flag = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT print ( \"0\" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \"0\" , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 12 , - 1 , - 7 , 8 , 30 , - 15 , 16 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE printFirstNegativeInteger ( arr , n , k ) NEW_LINE DEDENT"],"references":["def printFirstNegativeInteger ( arr , n , k ) : NEW_LINE INDENT for i in range ( 0 , ( n - k + 1 ) ) : NEW_LINE INDENT flag = False NEW_LINE for j in range ( 0 , k ) : NEW_LINE INDENT if ( arr [ i + j ] < 0 ) : NEW_LINE INDENT print ( arr [ i + j ] , end = \" ▁ \" ) NEW_LINE flag = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( not ( flag ) ) : NEW_LINE INDENT print ( \"0\" , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 12 , - 1 , - 7 , 8 , - 15 , 30 , 16 , 28 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE printFirstNegativeInteger ( arr , n , k ) NEW_LINE"],"bleu":0.6138766511820974,"rouge_l":0.7892683855009038}
{"id":1284,"predictions":["def printArray ( arr , size , index ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def printSequur ( arr , n , k , index ) : NEW_LINE INDENT if ( k == 0 ) : NEW_LINE INDENT for i in range ( arr [ index ] , i + 1 ) : NEW_LINE INDENT printArray ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if ( k > 0 ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT return NEW_LINE DEDENT def printSequur ( arr , n , k , index + 1 ) NEW_LINE printSequur ( arr , n , k ) NEW_LINE"],"references":["def printArray ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( \" \" ) ; NEW_LINE return ; NEW_LINE DEDENT def printSequencesRecur ( arr , n , k , index ) : NEW_LINE INDENT if ( k == 0 ) : NEW_LINE INDENT printArray ( arr , index ) ; NEW_LINE DEDENT if ( k > 0 ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT arr [ index ] = i ; NEW_LINE printSequencesRecur ( arr , n , k - 1 , index + 1 ) ; NEW_LINE DEDENT DEDENT DEDENT def printSequences ( n , k ) : NEW_LINE INDENT arr = [ 0 ] * n ; NEW_LINE printSequencesRecur ( arr , n , k , 0 ) ; NEW_LINE return ; NEW_LINE DEDENT n = 3 ; NEW_LINE k = 2 ; NEW_LINE printSequences ( n , k ) ; NEW_LINE"],"bleu":0.5926724335340123,"rouge_l":0.6747660017018058}
{"id":1285,"predictions":["from collections import defaultdict NEW_LINE no_of_chars = 256 NEW_LINE def findSubString ( str , pat ) : NEW_LINE INDENT len1 = len ( str ) NEW_LINE len2 = len ( pat ) NEW_LINE if ( len1 < len2 ) : NEW_LINE INDENT print ( \" No ▁ such ▁ edge \" ) NEW_LINE return NEW_LINE DEDENT hash_str = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( 0 , len1 ) : NEW_LINE INDENT hash_char [ ord ( pat [ i ] ) ] += 1 NEW_LINE DEDENT hash_char [ ord ( hash_char ) ] += 1 NEW_LINE for i in range ( 0 , len2 ) : NEW_LINE INDENT hash_char [ ord ( str [ i ] ) ] += 1 NEW_LINE DEDENT for j in range ( 0 , len_char ) : NEW_LINE INDENT hash_char [ ord ( pat [ i ] ) ] += 1 NEW_LINE if ( hash_char [ ord ( str [ j ] ) ] > hash_char [ ord ( str [ j ] ) ] ) : NEW_LINE INDENT hash_char [ ord ( str [ j ] ) ] += 1 NEW_LINE DEDENT DEDENT if ( len1 > len2 ) : NEW_LINE INDENT h = 0 NEW_LINE start = 0 NEW_LINE while ( len1 > len2 ) : NEW_LINE INDENT if ( hash_char [ ord ( str [ start ] ) ] > hash_char [ ord ( str [ start ] ) ] ) : NEW_LINE INDENT h += 1 NEW_LINE DEDENT if ( hash_char [ ord ( str [ start ] ) ] > hash_char [ ord ( str [ start ] ) ] ) : NEW_LINE INDENT if ( hash_char [ str [ start ] ] > hash_char [ str [ start ] ] > hash_char [ ord ( str [ start ] ) ] ) ) : NEW_LINE INDENT h += 1 NEW_LINE start += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return str NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" a ▁ is �"],"references":["no_of_chars = 256 NEW_LINE def findSubString ( string , pat ) : NEW_LINE INDENT len1 = len ( string ) NEW_LINE len2 = len ( pat ) NEW_LINE if len1 < len2 : NEW_LINE INDENT print ( \" No ▁ such ▁ window ▁ exists \" ) NEW_LINE return \" \" NEW_LINE DEDENT hash_pat = [ 0 ] * no_of_chars NEW_LINE hash_str = [ 0 ] * no_of_chars NEW_LINE for i in range ( 0 , len2 ) : NEW_LINE INDENT hash_pat [ ord ( pat [ i ] ) ] += 1 NEW_LINE DEDENT start , start_index , min_len = 0 , - 1 , float ( ' inf ' ) NEW_LINE count = 0 NEW_LINE for j in range ( 0 , len1 ) : NEW_LINE INDENT hash_str [ ord ( string [ j ] ) ] += 1 NEW_LINE if ( hash_pat [ ord ( string [ j ] ) ] != 0 and hash_str [ ord ( string [ j ] ) ] <= hash_pat [ ord ( string [ j ] ) ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if count == len2 : NEW_LINE INDENT while ( hash_str [ ord ( string [ start ] ) ] > hash_pat [ ord ( string [ start ] ) ] or hash_pat [ ord ( string [ start ] ) ] == 0 ) : NEW_LINE INDENT if ( hash_str [ ord ( string [ start ] ) ] > hash_pat [ ord ( string [ start ] ) ] ) : NEW_LINE INDENT hash_str [ ord ( string [ start ] ) ] -= 1 NEW_LINE DEDENT start += 1 NEW_LINE DEDENT len_window = j - start + 1 NEW_LINE if min_len > len_window : NEW_LINE INDENT min_len = len_window NEW_LINE start_index = start NEW_LINE DEDENT DEDENT DEDENT if start_index == - 1 : NEW_LINE INDENT print ( \" No ▁ such ▁ window ▁ exists \" ) NEW_LINE return \" \" NEW_LINE DEDENT return string [ start_index : start_index + min_len ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" this ▁ is ▁ a ▁ test ▁ string \" NEW_LINE pat = \" tist \" NEW_LINE print ( \" Smallest ▁ window ▁ is ▁ : ▁ \" ) NEW_LINE print ( findSubString ( string , pat ) ) NEW_LINE DEDENT"],"bleu":0.4271251604233729,"rouge_l":0.5826849930843707}
{"id":1286,"predictions":["def productArray ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT print ( \"0\" ) NEW_LINE return NEW_LINE DEDENT i = 0 NEW_LINE prod = [ 0 ] * n NEW_LINE prod = 1 NEW_LINE for j in range ( n ) : NEW_LINE INDENT prod *= arr [ j ] NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT prod *= arr [ i ] NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT prod *= arr [ i ] NEW_LINE if ( prod % arr [ i ] ) : NEW_LINE INDENT print ( prod , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 10 , 3 , 5 , 6 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" The ▁ product ▁ array ▁ is : \" ) NEW_LINE productArray ( arr , n ) NEW_LINE"],"references":["def productArray ( arr , n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE return NEW_LINE DEDENT i , temp = 1 , 1 NEW_LINE prod = [ 1 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT prod [ i ] = temp NEW_LINE temp *= arr [ i ] NEW_LINE DEDENT temp = 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT prod [ i ] *= temp NEW_LINE temp *= arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( prod [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT return NEW_LINE DEDENT arr = [ 10 , 3 , 5 , 6 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" The ▁ product ▁ array ▁ is : ▁ n \" ) NEW_LINE productArray ( arr , n ) NEW_LINE"],"bleu":0.6915548878914126,"rouge_l":0.7944444444444443}
{"id":1287,"predictions":["def NoofTriplets ( N , K ) : NEW_LINE INDENT cnt = [ 0 for i in range ( K ) ] NEW_LINE cnt [ 0 ] = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT cnt [ i ] = cnt [ i ] + 1 NEW_LINE DEDENT if ( K & 1 ) : NEW_LINE INDENT return cnt [ 0 ] * cnt [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT return ( cnt [ 1 ] * cnt [ 1 ] ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 3 NEW_LINE K = 2 NEW_LINE print ( NoofTriplets ( N , K ) ) NEW_LINE DEDENT"],"references":["def NoofTriplets ( N , K ) : NEW_LINE INDENT cnt = [ 0 ] * K ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT cnt [ i % K ] += 1 ; NEW_LINE DEDENT if ( K & 1 ) : NEW_LINE INDENT rslt = cnt [ 0 ] * cnt [ 0 ] * cnt [ 0 ] ; NEW_LINE return rslt NEW_LINE DEDENT else : NEW_LINE INDENT rslt = ( cnt [ 0 ] * cnt [ 0 ] * cnt [ 0 ] + cnt [ K \/\/ 2 ] * cnt [ K \/\/ 2 ] * cnt [ K \/\/ 2 ] ) ; NEW_LINE return rslt NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 3 ; K = 2 ; NEW_LINE print ( NoofTriplets ( N , K ) ) ; NEW_LINE DEDENT"],"bleu":0.5536206402139772,"rouge_l":0.7089060230193318}
{"id":1288,"predictions":["def answer ( arr , a , b ) : NEW_LINE INDENT a = a ^ ( arr [ 0 ] ^ arr [ 1 ] ) NEW_LINE arr = arr [ 1 ] NEW_LINE for k in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( arr [ k ] == True ) : NEW_LINE INDENT print ( \"1\" , end = \" ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \"0\" , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT def product ( arr , n , m ) : NEW_LINE INDENT for k in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( arr [ k ] == True ) : NEW_LINE INDENT print ( \"1\" , end = \" ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \"0\" , end = \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 NEW_LINE m = 3 NEW_LINE product ( arr , 3 , 5 ) NEW_LINE DEDENT"],"references":["def command ( brr , a , b ) : NEW_LINE INDENT arr [ a ] ^= 1 NEW_LINE arr [ b + 1 ] ^= 1 NEW_LINE DEDENT def process ( arr , n ) : NEW_LINE INDENT for k in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT arr [ k ] ^= arr [ k - 1 ] NEW_LINE DEDENT DEDENT def result ( arr , n ) : NEW_LINE INDENT for k in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT print ( arr [ k ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE m = 3 NEW_LINE arr = [ 0 for i in range ( n + 2 ) ] NEW_LINE command ( arr , 1 , 5 ) NEW_LINE command ( arr , 2 , 5 ) NEW_LINE command ( arr , 3 , 5 ) NEW_LINE process ( arr , n ) NEW_LINE result ( arr , n ) NEW_LINE DEDENT"],"bleu":0.4877888937448576,"rouge_l":0.5686035368934576}
{"id":1289,"predictions":["def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT n &= ( n - 1 ) NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def countSetBits ( n , l , r ) : NEW_LINE INDENT num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) NEW_LINE return countSetBits ( n & num - 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 42 NEW_LINE l = 2 NEW_LINE r = 5 NEW_LINE print ( countSetBits ( n , l , r ) ) NEW_LINE DEDENT"],"references":["def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT n &= ( n - 1 ) NEW_LINE count = count + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def countSetBitsInGivenRange ( n , l , r ) : NEW_LINE INDENT num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) NEW_LINE return countSetBits ( n & num ) NEW_LINE DEDENT n = 42 NEW_LINE l = 2 NEW_LINE r = 5 NEW_LINE ans = countSetBitsInGivenRange ( n , l , r ) NEW_LINE print ( ans ) NEW_LINE"],"bleu":0.766205272712399,"rouge_l":0.8710625787484251}
{"id":1290,"predictions":["def dig ( num ) : NEW_LINE INDENT count = 0 NEW_LINE while ( a > 0 ) : NEW_LINE INDENT a \/\/= 10 NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def digital_number ( num , n , d ) : NEW_LINE INDENT for i in range ( num , - 1 , - 1 ) : NEW_LINE INDENT power = pow ( 10 , i ) NEW_LINE if ( d > a ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT t = 0 NEW_LINE for j in range ( i , i ) : NEW_LINE INDENT t += 9 NEW_LINE DEDENT if ( d > a ) : NEW_LINE INDENT t = 1 NEW_LINE DEDENT flag = 0 NEW_LINE DEDENT if ( flag ) : NEW_LINE INDENT t = 0 NEW_LINE for j in range ( i , i ) : NEW_LINE INDENT t += 9 * pow ( 10 , j ) NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT print ( n , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n - ( n % power ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 1029 NEW_LINE d = 102 NEW_LINE num = digital_number ( num , n , d ) NEW_LINE DEDENT"],"references":["def dig ( a ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( a > 0 ) : NEW_LINE INDENT a \/= 10 NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def required_number ( num , n , d ) : NEW_LINE INDENT flag = 0 NEW_LINE power = 0 NEW_LINE a = 0 NEW_LINE for i in range ( num , 0 , - 1 ) : NEW_LINE INDENT power = pow ( 10 , i ) NEW_LINE a = n % power NEW_LINE if ( d > a ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT t = 0 NEW_LINE for j in range ( 0 , i ) : NEW_LINE INDENT t += 9 * pow ( 10 , j ) NEW_LINE DEDENT if ( n % power == t ) : NEW_LINE INDENT print ( n , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( n - ( n % power ) - 1 ) , end = \" \" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( n , end = \" \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 1029 NEW_LINE d = 102 NEW_LINE num = dig ( n ) NEW_LINE required_number ( num , n , d ) NEW_LINE DEDENT"],"bleu":0.7123631453583662,"rouge_l":0.7540582761665421}
{"id":1291,"predictions":["def CountZeroBit ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT if ( ( n & 1 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def CountORandSum ( N ) : NEW_LINE INDENT count = CountZero ( N ) NEW_LINE return ( 1 << count ) NEW_LINE DEDENT N = 10 NEW_LINE print ( CountORandSum ( N ) ) NEW_LINE"],"references":["def CountZeroBit ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT if ( not ( n & 1 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def CountORandSumEqual ( N ) : NEW_LINE INDENT count = CountZeroBit ( N ) NEW_LINE return ( 1 << count ) NEW_LINE DEDENT N = 10 NEW_LINE print ( CountORandSumEqual ( N ) ) NEW_LINE"],"bleu":0.871463954267373,"rouge_l":0.9548918640576726}
{"id":1292,"predictions":["def checkConcurrent ( a1 , b1 , c1 , a2 , b2 , c2 ) : NEW_LINE INDENT return ( a1 * ( b1 * c2 - a1 ) + b2 * ( c1 - c2 ) + c3 * ( a1 * a2 ) ) ; NEW_LINE DEDENT def check ( a1 , b1 , c1 , a2 , b2 , c3 ) : NEW_LINE INDENT return ( a1 * ( b1 - a2 * c1 ) + b2 * ( c1 - a2 ) ) ; NEW_LINE DEDENT a1 = 2 ; b1 = - 3 ; c2 = 4 ; NEW_LINE a3 = 5 ; b1 = - 7 ; NEW_LINE b2 = - 7 ; NEW_LINE c3 = - 5 ; NEW_LINE if ( check ( a1 , b1 , c1 , b2 , c3 ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def checkConcurrent ( a1 , b1 , c1 , a2 , b2 , c2 , a3 , b3 , c3 ) : NEW_LINE INDENT return ( a3 * ( b1 * c2 - b2 * c1 ) + b3 * ( c1 * a2 - c2 * a1 ) + c3 * ( a1 * b2 - a2 * b1 ) == 0 ) NEW_LINE DEDENT a1 = 2 NEW_LINE b1 = - 3 NEW_LINE c1 = 5 NEW_LINE a2 = 3 NEW_LINE b2 = 4 NEW_LINE c2 = - 7 NEW_LINE a3 = 9 NEW_LINE b3 = - 5 NEW_LINE c3 = 8 NEW_LINE if ( checkConcurrent ( a1 , b1 , c1 , a2 , b2 , c2 , a3 , b3 , c3 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.5266257357493936,"rouge_l":0.6762890910992574}
{"id":1293,"predictions":["def winner ( moves ) : NEW_LINE INDENT x = 0 NEW_LINE y = 0 NEW_LINE data = { ' R ' : ( \" P ' , ' P ' ) , ' Q ' : ( ' R ' , ' S ' ) , ' U ' : ( ' P ' , ' R ' ) ] NEW_LINE if ( moves [ 0 ] == moves [ 1 ] ) : NEW_LINE INDENT return \" Impossible \" NEW_LINE DEDENT if ( ( x < moves ) or ( moves [ 0 ] == moves [ 0 ] ) ) : NEW_LINE INDENT return \" A \" NEW_LINE DEDENT return \" B \" NEW_LINE DEDENT def performQueries ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = ' ' ) NEW_LINE DEDENT DEDENT def performQueries ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ ' R ' , ' SP ' ] NEW_LINE n = len ( arr ) NEW_LINE performQueries ( arr , n ) NEW_LINE DEDENT"],"references":["def winner ( moves ) : NEW_LINE INDENT data = dict ( ) NEW_LINE data [ ' R ' ] = 0 NEW_LINE data [ ' P ' ] = 1 NEW_LINE data [ ' S ' ] = 2 NEW_LINE if ( moves [ 0 ] == moves [ 1 ] ) : NEW_LINE INDENT return \" Draw \" NEW_LINE DEDENT if ( ( ( data [ moves [ 0 ] ] | 1 << ( 2 ) ) - ( data [ moves [ 1 ] ] | 0 << ( 2 ) ) ) % 3 ) : NEW_LINE INDENT return \" A \" NEW_LINE DEDENT return \" B \" NEW_LINE DEDENT def performQueries ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( winner ( arr [ i ] ) ) NEW_LINE DEDENT DEDENT arr = [ \" RS \" , \" SR \" , \" SP \" , \" PP \" ] NEW_LINE n = len ( arr ) NEW_LINE performQueries ( arr , n ) NEW_LINE"],"bleu":0.4352538906211417,"rouge_l":0.6000645057248831}
{"id":1294,"predictions":["MAX = 10000 NEW_LINE catalan = [ ] NEW_LINE def catalanDP ( n ) : NEW_LINE INDENT catalan = [ ] NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT catalan [ i ] = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT catalan . append ( catalan [ j ] ) NEW_LINE DEDENT DEDENT for i in range ( len ( catalan ) ) : NEW_LINE INDENT catalan [ i ] += catalan [ i - j - j - 1 ] NEW_LINE DEDENT DEDENT if ( n >= 2 ) : NEW_LINE INDENT return catalan [ 0 ] NEW_LINE DEDENT s = set ( ) NEW_LINE def catalanDP ( arr , n ) : NEW_LINE INDENT s . add ( arr [ 0 ] ) NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT s . remove ( arr [ i ] ) NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT s . remove ( arr [ i ] ) NEW_LINE DEDENT DEDENT return len ( s ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 1 , 2 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( catalanDP ( arr , n ) ) NEW_LINE DEDENT"],"references":["MAX = 100000 ; NEW_LINE catalan = [ 0 ] * MAX ; NEW_LINE def catalanDP ( n ) : NEW_LINE INDENT catalan [ 0 ] = catalan [ 1 ] = 1 ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT catalan [ i ] = 0 ; NEW_LINE for j in range ( i ) : NEW_LINE INDENT catalan [ i ] += ( catalan [ j ] * catalan [ i - j - 1 ] ) ; NEW_LINE DEDENT DEDENT DEDENT def CatalanSequence ( arr , n ) : NEW_LINE INDENT catalanDP ( n ) ; NEW_LINE s = set ( ) ; NEW_LINE a = 1 ; b = 1 ; NEW_LINE s . add ( a ) ; NEW_LINE if ( n >= 2 ) : NEW_LINE INDENT s . add ( b ) ; NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT s . add ( catalan [ i ] ) ; NEW_LINE DEDENT temp = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in s : NEW_LINE INDENT temp . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT s = s - temp ; NEW_LINE return len ( s ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 1 , 2 , 5 , 41 ] ; NEW_LINE n = len ( arr ) NEW_LINE print ( CatalanSequence ( arr , n ) ) ; NEW_LINE DEDENT"],"bleu":0.6239191103666337,"rouge_l":0.7253892362388132}
{"id":1295,"predictions":["def removeAnagrams ( arr , N ) : NEW_LINE INDENT ans = [ ] NEW_LINE found = [ ] NEW_LINE for i in arr : NEW_LINE INDENT if ( i not in found ) : NEW_LINE INDENT ans . append ( arr [ i ] ) NEW_LINE found . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT ans . sort ( ) NEW_LINE for i in ans : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ \" geeksforgeeks \" ] NEW_LINE N = 4 NEW_LINE findAnagrams ( arr , N ) NEW_LINE DEDENT"],"references":["def removeAnagrams ( arr , N ) : NEW_LINE INDENT ans = [ ] NEW_LINE found = dict ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT word = arr [ i ] NEW_LINE word = \" ▁ \" . join ( sorted ( word ) ) NEW_LINE if ( word not in found ) : NEW_LINE INDENT ans . append ( arr [ i ] ) NEW_LINE found [ word ] = 1 NEW_LINE DEDENT DEDENT ans = sorted ( ans ) NEW_LINE for i in range ( len ( ans ) ) : NEW_LINE INDENT print ( ans [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ \" geeks \" , \" keegs \" , \" code \" , \" doce \" ] NEW_LINE N = 4 NEW_LINE removeAnagrams ( arr , N ) NEW_LINE DEDENT"],"bleu":0.48637312744683153,"rouge_l":0.7084946481439307}
{"id":1296,"predictions":["def findMaximumNum ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( i <= arr [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count >= i ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 8 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMaximumNum ( arr , n ) ) NEW_LINE"],"references":["def findMaximumNum ( arr , n ) : NEW_LINE INDENT i = n NEW_LINE while ( i >= 1 ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( i <= arr [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count >= i ) : NEW_LINE INDENT return i NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 8 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMaximumNum ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.6854232549278039,"rouge_l":0.8379832884860502}
{"id":1297,"predictions":["def printSubArrays ( arr , start , end = \" \" ) : NEW_LINE INDENT if ( end == len ( arr ) ) : NEW_LINE INDENT return NEW_LINE DEDENT elif ( start > end ) : NEW_LINE INDENT return NEW_LINE DEDENT elif ( start > end ) : NEW_LINE INDENT print ( arr [ start ] , end = \" , ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ start ] , end = \" \" ) NEW_LINE DEDENT DEDENT def printSubArrays ( arr , start , end = \" \" ) : NEW_LINE INDENT for i in range ( start , end + 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 ] NEW_LINE printSubArrays ( arr , start , 0 ) NEW_LINE DEDENT"],"references":["def printSubArrays ( arr , start , end ) : NEW_LINE INDENT if end == len ( arr ) : NEW_LINE INDENT return NEW_LINE DEDENT elif start > end : NEW_LINE INDENT return printSubArrays ( arr , 0 , end + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ start : end + 1 ] ) NEW_LINE return printSubArrays ( arr , start + 1 , end ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 ] NEW_LINE printSubArrays ( arr , 0 , 0 ) NEW_LINE"],"bleu":0.38811550572903847,"rouge_l":0.6810599946193167}
{"id":1298,"predictions":["import math NEW_LINE def setBit ( x ) : NEW_LINE INDENT count = 0 NEW_LINE while ( x >= 1 ) : NEW_LINE INDENT if ( x % 2 == 1 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT xor = xor \/ 2 NEW_LINE DEDENT return count NEW_LINE DEDENT def minFlip ( n , k ) : NEW_LINE INDENT size = int ( math . log2 ( n ) ) + 1 NEW_LINE maxValue = ( int ) ( math . log2 ( 2 ) ) NEW_LINE maxValue = ( int ( math . pow ( 2 , k ) - 1 ) ) NEW_LINE xorValue = ( int ) ( math . pow ( 2 , k ) ) NEW_LINE return ( setBitValue ) NEW_LINE DEDENT n = 27 NEW_LINE k = 3 NEW_LINE print ( \" MinFlip ( n , k ) ) NEW_LINE"],"references":["import math NEW_LINE def setBit ( xorValue ) : NEW_LINE INDENT count = 0 NEW_LINE while ( xorValue ) : NEW_LINE INDENT if ( xorValue % 2 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT xorValue = int ( xorValue \/ 2 ) NEW_LINE DEDENT return count NEW_LINE DEDENT def minFlip ( n , k ) : NEW_LINE INDENT size = int ( math . log ( n ) \/ math . log ( 2 ) + 1 ) NEW_LINE max = pow ( 2 , k ) - 1 NEW_LINE max = max << ( size - k ) NEW_LINE xorValue = ( n ^ max ) NEW_LINE return ( setBit ( xorValue ) ) NEW_LINE DEDENT n = 27 NEW_LINE k = 3 NEW_LINE print ( \" Min ▁ Flips ▁ = ▁ \" , minFlip ( n , k ) ) NEW_LINE"],"bleu":0.5575513589934997,"rouge_l":0.7179658005773928}
{"id":1299,"predictions":["def isVowel ( x ) : NEW_LINE INDENT if ( x == ' a ' or x == ' e ' or x == ' i ' or x == ' o ' or x == ' u ' ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT def updateString ( a ) : NEW_LINE INDENT n = len ( a ) NEW_LINE updateString ( a ) NEW_LINE updateString ( a ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( i == 0 or i == n - 1 or i == n - 1 ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT else : NEW_LINE INDENT updateString ( a [ i ] ) NEW_LINE updateString ( a [ i ] ) NEW_LINE DEDENT DEDENT if ( isVowel ( a [ i ] ) == False and isVowel ( a [ i ] ) == False and isVowel ( a [ i + 1 ] ) == False ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT updateString ( a ) ; NEW_LINE return False ; NEW_LINE DEDENT DEDENT str = \" geeksforgeeks \" ; NEW_LINE print ( updateString ( str ) ) ; NEW_LINE"],"references":["def isVowel ( x ) : NEW_LINE INDENT if ( x == ' a ' or x == ' e ' or x == ' i ' or x == ' o ' or x == ' u ' ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def updateSandwichedVowels ( a ) : NEW_LINE INDENT n = len ( a ) NEW_LINE updatedString = \" \" NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( i == 0 or i == n - 1 ) : NEW_LINE INDENT updatedString += a [ i ] NEW_LINE continue NEW_LINE DEDENT if ( isVowel ( a [ i ] ) == True and isVowel ( a [ i - 1 ] ) == False and isVowel ( a [ i + 1 ] ) == False ) : NEW_LINE INDENT continue NEW_LINE DEDENT updatedString += a [ i ] NEW_LINE DEDENT return updatedString NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" geeksforgeeks \" NEW_LINE updatedString = updateSandwichedVowels ( str ) NEW_LINE print ( updatedString ) NEW_LINE DEDENT"],"bleu":0.6692501549647711,"rouge_l":0.7801135001198943}
{"id":1300,"predictions":["def totalWays ( N , M , X ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 22 ) ] for j in range ( N + 1 ) ] NEW_LINE if ( X == 1 ) : NEW_LINE INDENT dp [ 0 ] [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 1 ] [ 0 ] = 0 NEW_LINE DEDENT if ( X == 1 ) : NEW_LINE INDENT dp [ 1 ] [ 0 ] = 0 NEW_LINE dp [ 1 ] [ 1 ] = 1 NEW_LINE dp [ 1 ] [ 0 ] = 0 NEW_LINE dp [ 1 ] [ 1 ] = 0 NEW_LINE DEDENT for i in range ( 2 , N ) : NEW_LINE INDENT dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] NEW_LINE dp [ i ] [ 1 ] = dp [ i - 1 ] [ 1 ] * ( M - 1 ) NEW_LINE DEDENT return dp [ N - 1 ] [ 0 ] NEW_LINE DEDENT N = 4 NEW_LINE M = 3 NEW_LINE X = 2 NEW_LINE print ( totalWays ( N , M , X ) ) NEW_LINE"],"references":["def totalWays ( N , M , X ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 2 ) ] for j in range ( N + 1 ) ] NEW_LINE if ( X == 1 ) : NEW_LINE INDENT dp [ 0 ] [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 0 ] [ 1 ] = 0 NEW_LINE DEDENT if ( X == 1 ) : NEW_LINE INDENT dp [ 1 ] [ 0 ] = 0 NEW_LINE dp [ 1 ] [ 1 ] = M - 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 1 ] [ 0 ] = 1 NEW_LINE dp [ 1 ] [ 1 ] = ( M - 2 ) NEW_LINE DEDENT for i in range ( 2 , N ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] NEW_LINE dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] * ( M - 1 ) + dp [ i - 1 ] [ 1 ] * ( M - 2 ) NEW_LINE DEDENT return dp [ N - 1 ] [ 0 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE M = 3 NEW_LINE X = 2 NEW_LINE print ( totalWays ( N , M , X ) ) NEW_LINE DEDENT"],"bleu":0.7734841375728221,"rouge_l":0.8636868406440865}
{"id":1301,"predictions":["def findMinimal ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n \/\/ 2 ) : NEW_LINE INDENT sum += ( a [ i ] + a [ n - i - 1 ] ) * ( a [ n - i - 1 ] + a [ n - i - 1 ] ) NEW_LINE DEDENT return sum NEW_LINE DEDENT a = [ 8 , 5 , 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE print ( findMinimal ( a , n ) ) NEW_LINE"],"references":["def findMinimal ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n \/\/ 2 ) : NEW_LINE INDENT sum += ( ( a [ i ] + a [ n - i - 1 ] ) * ( a [ i ] + a [ n - i - 1 ] ) ) NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 8 , 5 , 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE print ( findMinimal ( a , n ) ) NEW_LINE DEDENT"],"bleu":0.8101662298565038,"rouge_l":0.9002361275088546}
{"id":1302,"predictions":["def minOperations ( str , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if str [ i ] != str [ i + 1 ] : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT return ( count + 1 ) \/\/ 2 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \"00011111\" NEW_LINE n = len ( str ) NEW_LINE print ( minOperations ( str , n ) ) NEW_LINE DEDENT"],"references":["def minOperations ( str , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( str [ i ] != str [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return ( count + 1 ) \/\/ 2 NEW_LINE DEDENT str = \"000111\" NEW_LINE n = len ( str ) NEW_LINE print ( minOperations ( str , n ) ) NEW_LINE"],"bleu":0.7268132927085511,"rouge_l":0.8864244741873806}
{"id":1303,"predictions":["def toDecimal ( binary , i ) : NEW_LINE INDENT if ( i == n - 1 ) : NEW_LINE INDENT return binary [ i ] ; NEW_LINE DEDENT elif ( binary [ i ] == '0' ) : NEW_LINE INDENT binary [ i ] = ord ( binary [ i ] ) - ord ( '0' ) + ( n - ord ( '0' ) ) ; NEW_LINE DEDENT return ( binaryDecimal ( binary , i + 1 ) ) ; NEW_LINE DEDENT binary = toDecimal ( binary , i ) ; NEW_LINE binary = \" \" ; NEW_LINE i = 0 ; NEW_LINE print ( toDecimal ( binary , binary ) ) ; NEW_LINE"],"references":["def toDecimal ( binary , i = 0 ) : NEW_LINE INDENT n = len ( binary ) NEW_LINE if ( i == n - 1 ) : NEW_LINE INDENT return int ( binary [ i ] ) - 0 NEW_LINE DEDENT return ( ( ( int ( binary [ i ] ) - 0 ) << ( n - i - 1 ) ) + toDecimal ( binary , i + 1 ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT binary = \"1010\" NEW_LINE print ( toDecimal ( binary ) ) NEW_LINE DEDENT"],"bleu":0.44524902102913605,"rouge_l":0.6000302663438256}
{"id":1304,"predictions":["def countPairs ( n ) : NEW_LINE INDENT num = ( n \/\/ 2 ) + 1 NEW_LINE max = n % num NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT val = ( ( n % j ) % j ) NEW_LINE if ( val == max ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 NEW_LINE print ( countPairs ( n ) ) NEW_LINE DEDENT"],"references":["def countPairs ( n ) : NEW_LINE INDENT num = ( ( n \/\/ 2 ) + 1 ) NEW_LINE Max = n % num NEW_LINE count = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT val = ( ( n % i ) % j ) % n NEW_LINE if ( val == Max ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT n = 5 NEW_LINE print ( countPairs ( n ) ) NEW_LINE"],"bleu":0.7607916035369318,"rouge_l":0.8735756082537727}
{"id":1305,"predictions":["from sys import maxsize NEW_LINE def createHash ( hash , maxElement ) : NEW_LINE INDENT prev , curr = 1 , 1 NEW_LINE hash . add ( prev ) NEW_LINE hash . add ( curr ) NEW_LINE while ( curr <= maxElement ) : NEW_LINE INDENT temp = curr + prev NEW_LINE hash . add ( temp ) NEW_LINE prev = curr NEW_LINE curr = temp NEW_LINE DEDENT DEDENT def createonacci ( arr , n ) : NEW_LINE INDENT max_val = max ( arr ) NEW_LINE createHash ( arr , n ) NEW_LINE minimum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( hash [ arr [ i ] ] ) : NEW_LINE INDENT minimum = min ( minimum , arr [ i ] ) NEW_LINE maximum = max ( maximum , arr [ i ] ) NEW_LINE maximum = max ( maximum , arr [ i ] ) NEW_LINE DEDENT DEDENT print ( minimum , maximum ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE createHash ( arr , n ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE def createHash ( hash , maxElement ) : NEW_LINE INDENT prev = 0 NEW_LINE curr = 1 NEW_LINE hash . add ( prev ) NEW_LINE hash . add ( curr ) NEW_LINE while ( curr <= maxElement ) : NEW_LINE INDENT temp = curr + prev NEW_LINE hash . add ( temp ) NEW_LINE prev = curr NEW_LINE curr = temp NEW_LINE DEDENT DEDENT def fibonacci ( arr , n ) : NEW_LINE INDENT max_val = max ( arr ) NEW_LINE hash = set ( ) NEW_LINE createHash ( hash , max_val ) NEW_LINE minimum = sys . maxsize NEW_LINE maximum = - sys . maxsize - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] in hash ) : NEW_LINE INDENT minimum = min ( minimum , arr [ i ] ) NEW_LINE maximum = max ( maximum , arr [ i ] ) NEW_LINE DEDENT DEDENT print ( minimum , end = \" , ▁ \" ) NEW_LINE print ( maximum ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE fibonacci ( arr , n ) NEW_LINE DEDENT"],"bleu":0.7695509383578294,"rouge_l":0.8430223824545592}
{"id":1306,"predictions":["def printInSorted ( arr , n ) : NEW_LINE INDENT index = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT index [ i ] = i NEW_LINE DEDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] [ j ] > 0 ) : NEW_LINE INDENT min = arr [ index ] NEW_LINE DEDENT DEDENT if ( min != i ) : NEW_LINE INDENT index = j NEW_LINE DEDENT if ( min != i ) : NEW_LINE INDENT print ( arr [ index ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT def printInSortedOrder ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ \" geeks \" , \" for \" , \" geeks \" ] NEW_LINE n = 4 NEW_LINE printInSortedOrder ( arr , n ) NEW_LINE DEDENT"],"references":["def printInSortedOrder ( arr , n ) : NEW_LINE INDENT index = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT index [ i ] = i NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT min = i NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ index [ min ] ] > arr [ index [ j ] ] ) : NEW_LINE INDENT min = j NEW_LINE DEDENT DEDENT if ( min != i ) : NEW_LINE INDENT index [ min ] , index [ i ] = index [ i ] , index [ min ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ index [ i ] ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ \" geeks \" , \" quiz \" , \" geeks \" , \" for \" ] NEW_LINE n = 4 NEW_LINE printInSortedOrder ( arr , n ) NEW_LINE DEDENT"],"bleu":0.7281107288569014,"rouge_l":0.7575757575757576}
{"id":1307,"predictions":["def binomialCoeff ( n , k ) : NEW_LINE INDENT if ( k > n - k ) : NEW_LINE INDENT k = n - k ; NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT res = res * ( n - i ) ; NEW_LINE res \/\/= ( i + 1 ) ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT def countPaths ( x1 , y1 , x2 ) : NEW_LINE INDENT m = abs ( x1 - x2 ) ; NEW_LINE n = abs ( y1 - y2 ) ; NEW_LINE return ( binomialCoeff ( m , n , x2 ) ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x1 = 2 ; y1 = 3 ; NEW_LINE x2 = 4 ; NEW_LINE y2 = 5 ; NEW_LINE print ( countPaths ( x1 , y1 , x2 , y2 ) ) ; NEW_LINE DEDENT"],"references":["def binomialCoeff ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT res *= ( n - i ) NEW_LINE res \/\/= ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT def countPaths ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT m = abs ( x1 - x2 ) NEW_LINE n = abs ( y1 - y2 ) NEW_LINE return ( binomialCoeff ( m + n , n ) ) NEW_LINE DEDENT x1 , y1 , x2 , y2 = 2 , 3 , 4 , 5 NEW_LINE print ( countPaths ( x1 , y1 , x2 , y2 ) ) NEW_LINE"],"bleu":0.6125824730790154,"rouge_l":0.8185172760818517}
{"id":1308,"predictions":["def findN ( k ) : NEW_LINE INDENT if ( k == 0 ) : NEW_LINE INDENT ans = 3 NEW_LINE DEDENT elif ( k == 1 ) : NEW_LINE INDENT ans = k - 1 NEW_LINE DEDENT elif ( k % 4 == 3 ) : NEW_LINE INDENT ans = k NEW_LINE DEDENT elif ( k % 4 == 3 ) : NEW_LINE INDENT ans = k - 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT k = 7 NEW_LINE res = findN ( k ) NEW_LINE if ( res == - 1 ) : NEW_LINE INDENT print ( \" Not ▁ possible \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ possible \" ) NEW_LINE DEDENT"],"references":["def findN ( k ) : NEW_LINE INDENT if ( k == 0 ) : NEW_LINE INDENT ans = 3 NEW_LINE DEDENT if ( k == 1 ) : NEW_LINE INDENT ans = 1 NEW_LINE DEDENT elif ( k % 4 == 0 ) : NEW_LINE INDENT ans = k NEW_LINE DEDENT elif ( k % 4 == 3 ) : NEW_LINE INDENT ans = k - 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT k = 7 NEW_LINE res = findN ( k ) NEW_LINE if ( res == - 1 ) : NEW_LINE INDENT print ( \" Not ▁ possible \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res ) NEW_LINE DEDENT"],"bleu":0.8840518902118735,"rouge_l":0.957170418006431}
{"id":1309,"predictions":["def print_asterisk ( asterisk ) : NEW_LINE INDENT if ( asterisk == 0 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT print ( \" * ▁ \" , end = \" \" ) ; NEW_LINE print_asterisk ( asterisk - 1 ) ; NEW_LINE DEDENT def print_space ( space ) : NEW_LINE INDENT if ( space == 0 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT print ( ▁ \" , end = \" \" ) ; NEW_LINE print ( \" ▁ \" , end = \" \" ) ; NEW_LINE print_space ( space - 1 ) ; NEW_LINE DEDENT def pattern ( n , num ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT print_asterisk ( num - n + 1 ) ; NEW_LINE print ( \" ▁ \" ) ; NEW_LINE pattern ( n - 1 , num ) ; NEW_LINE print_asterisk ( num - n + 1 ) ; NEW_LINE print ( ) ; NEW_LINE pattern ( n - 1 , num ) ; NEW_LINE DEDENT def pattern ( n , num ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT return ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 ; NEW_LINE pattern ( n , n ) ; NEW_LINE pattern ( n , n ) ; NEW_LINE DEDENT"],"references":["def print_asterisk ( asterisk ) : NEW_LINE INDENT if ( asterisk == 0 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT print ( \" * \" , end = \" ▁ \" ) ; NEW_LINE print_asterisk ( asterisk - 1 ) ; NEW_LINE DEDENT def print_space ( space ) : NEW_LINE INDENT if ( space == 0 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT print ( \" ▁ \" , end = \" \" ) ; NEW_LINE print ( \" ▁ \" , end = \" \" ) ; NEW_LINE print_space ( space - 1 ) ; NEW_LINE DEDENT def pattern ( n , num ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT print_asterisk ( num - n + 1 ) ; NEW_LINE print_space ( 2 * n - 1 ) ; NEW_LINE print_asterisk ( num - n + 1 ) ; NEW_LINE print ( ) ; NEW_LINE pattern ( n - 1 , num ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 ; NEW_LINE pattern ( n , n ) ; NEW_LINE DEDENT"],"bleu":0.7591646092204564,"rouge_l":0.8864370290635093}
{"id":1310,"predictions":["def isMultipleOf3 ( n ) : NEW_LINE INDENT odd_count = 0 NEW_LINE even_count = 0 NEW_LINE if n < 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT while n != 0 : NEW_LINE INDENT if n & 1 : NEW_LINE INDENT odd_count += 1 NEW_LINE DEDENT if ( n & 2 ) : NEW_LINE INDENT even_count += 1 NEW_LINE n = n >> 2 NEW_LINE DEDENT n = n >> 1 NEW_LINE DEDENT return isMultipleOf3 ( ( abs ( odd_count ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT num = 24 NEW_LINE print ( \" multiple ▁ of ▁ 3\" ) NEW_LINE DEDENT"],"references":["def isMultipleOf3 ( n ) : NEW_LINE INDENT odd_count = 0 NEW_LINE even_count = 0 NEW_LINE if ( n < 0 ) : NEW_LINE INDENT n = - n NEW_LINE DEDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT odd_count += 1 NEW_LINE DEDENT if ( n & 2 ) : NEW_LINE INDENT even_count += 1 NEW_LINE DEDENT n = n >> 2 NEW_LINE DEDENT return isMultipleOf3 ( abs ( odd_count - even_count ) ) NEW_LINE DEDENT num = 24 NEW_LINE if ( isMultipleOf3 ( num ) ) : NEW_LINE INDENT print ( num , ' is ▁ multiple ▁ of ▁ 3' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( num , ' is ▁ not ▁ a ▁ multiple ▁ of ▁ 3' ) NEW_LINE DEDENT"],"bleu":0.49916064191598364,"rouge_l":0.708071165111738}
{"id":1311,"predictions":["def findNumber ( N , S ) : NEW_LINE INDENT i = ( N * ( N + 1 ) ) \/ ( N + 1 ) ; NEW_LINE return i ; NEW_LINE DEDENT def check ( N , S ) : NEW_LINE INDENT i = findNumber ( N ) ; NEW_LINE Input = findNumber ( S ) ; NEW_LINE Input = findNumber ( N ) ; NEW_LINE if ( i - S ) == 0 : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 4 ; NEW_LINE S = 3 ; NEW_LINE check ( N , S ) ; NEW_LINE DEDENT"],"references":["def findNumber ( N , S ) : NEW_LINE INDENT i = ( ( ( N ) * ( N + 1 ) ) \/ 4 ) - ( ( S + 1 ) \/ 2 ) ; NEW_LINE return i ; NEW_LINE DEDENT def check ( N , S ) : NEW_LINE INDENT i = findNumber ( N , S ) ; NEW_LINE integerI = int ( i ) ; NEW_LINE if ( i - integerI == 0 ) : NEW_LINE INDENT print ( \" Yes : \" , integerI , \" , \" , integerI + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 4 ; NEW_LINE S = 3 ; NEW_LINE check ( N , S ) ; NEW_LINE N = 5 ; NEW_LINE S = 3 ; NEW_LINE check ( N , S ) ; NEW_LINE DEDENT"],"bleu":0.644917909219572,"rouge_l":0.7883999145481736}
{"id":1312,"predictions":["def thirdLargest ( arr_size , arr_size ) : NEW_LINE INDENT if ( arr_size < 3 ) : NEW_LINE INDENT print ( \" Invalid ▁ Input \" ) NEW_LINE return NEW_LINE DEDENT first = arr_size NEW_LINE second = arr_size NEW_LINE third = arr_size NEW_LINE third = arr_size NEW_LINE for i in range ( 1 , arr_size ) : NEW_LINE INDENT if ( arr [ i ] > first ) : NEW_LINE INDENT third = arr [ i ] NEW_LINE third = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > second ) : NEW_LINE INDENT third = arr [ i ] NEW_LINE second = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > second ) : NEW_LINE INDENT third = arr [ i ] NEW_LINE second = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > third ) : NEW_LINE INDENT third = arr [ i ] NEW_LINE second = arr [ i ] NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 12 , 13 , 1 , 10 , 25 ] NEW_LINE n = len ( arr ) NEW_LINE thirdLargest ( arr , n ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE def thirdLargest ( arr , arr_size ) : NEW_LINE INDENT if ( arr_size < 3 ) : NEW_LINE INDENT print ( \" ▁ Invalid ▁ Input ▁ \" ) NEW_LINE return NEW_LINE DEDENT first = arr [ 0 ] NEW_LINE second = - sys . maxsize NEW_LINE third = - sys . maxsize NEW_LINE for i in range ( 1 , arr_size ) : NEW_LINE INDENT if ( arr [ i ] > first ) : NEW_LINE INDENT third = second NEW_LINE second = first NEW_LINE first = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > second ) : NEW_LINE INDENT third = second NEW_LINE second = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > third ) : NEW_LINE INDENT third = arr [ i ] NEW_LINE DEDENT DEDENT print ( \" The ▁ third ▁ Largest \" , \" element ▁ is \" , third ) NEW_LINE DEDENT arr = [ 12 , 13 , 1 , 10 , 34 , 16 ] NEW_LINE n = len ( arr ) NEW_LINE thirdLargest ( arr , n ) NEW_LINE"],"bleu":0.6344386693899222,"rouge_l":0.7407893657175679}
{"id":1313,"predictions":["def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return gcd ( a - b , b ) NEW_LINE DEDENT def squarearea ( l , b ) : NEW_LINE INDENT if ( l < 0 or b < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT n = ( l * b ) \/ gcd ( l , b ) NEW_LINE return n * n NEW_LINE DEDENT l = 6 NEW_LINE b = 4 NEW_LINE print ( squarearea ( l , b ) ) NEW_LINE"],"references":["def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return gcd ( a - b , b ) NEW_LINE DEDENT return gcd ( a , b - a ) NEW_LINE DEDENT def squarearea ( l , b ) : NEW_LINE INDENT if ( l < 0 or b < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT n = ( l * b ) \/ gcd ( l , b ) NEW_LINE return n * n NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT l = 6 NEW_LINE b = 4 NEW_LINE print ( int ( squarearea ( l , b ) ) ) NEW_LINE DEDENT"],"bleu":0.8379308546450914,"rouge_l":0.8747419880499728}
{"id":1314,"predictions":["def countUnsetBits ( n ) : NEW_LINE INDENT x = n | n >> 1 ; NEW_LINE n |= n >> 2 ; NEW_LINE n |= n >> 4 ; NEW_LINE n |= n >> 4 ; NEW_LINE n |= n >> 16 ; NEW_LINE n |= n >> 16 ; NEW_LINE n |= n >> 16 ; NEW_LINE n |= n >> 16 ; NEW_LINE return bin ( x ^ n ) ; NEW_LINE DEDENT n = 17 ; NEW_LINE print ( countUnsetBits ( n ) ) ; NEW_LINE"],"references":["import math NEW_LINE def countUnsetBits ( n ) : NEW_LINE INDENT x = n NEW_LINE n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE t = math . log ( x ^ n , 2 ) NEW_LINE return math . floor ( t ) NEW_LINE DEDENT n = 17 NEW_LINE print ( countUnsetBits ( n ) ) NEW_LINE"],"bleu":0.4946450426868208,"rouge_l":0.6945425991362387}
{"id":1315,"predictions":["N = 1000000 NEW_LINE visited = [ False ] * N NEW_LINE def dfs ( i ) : NEW_LINE INDENT visited [ i ] = 1 NEW_LINE dfs ( i ) NEW_LINE DEDENT def dfs ( i ) : NEW_LINE INDENT visited [ i ] = 1 NEW_LINE while i < n : NEW_LINE INDENT if visited [ visited [ i ] ] == True : NEW_LINE INDENT return 0 NEW_LINE DEDENT visited [ i ] = True NEW_LINE DEDENT x = dfs ( i + 1 , 3 ) NEW_LINE return ( x + 1 ) NEW_LINE DEDENT def noOfTransitions ( p , n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if visited [ i ] == 0 : NEW_LINE INDENT ans = dfs ( i ) NEW_LINE DEDENT DEDENT return ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT permutations ( ) NEW_LINE permutations ( permutations ( permutations ( permutations ( permutation ) ) ) NEW_LINE DEDENT"],"references":["N = 1000001 NEW_LINE visited = [ 0 ] * N ; NEW_LINE goesTo = [ 0 ] * N ; NEW_LINE def dfs ( i ) : NEW_LINE INDENT if ( visited [ i ] == 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT visited [ i ] = 1 ; NEW_LINE x = dfs ( goesTo [ i ] ) ; NEW_LINE return ( x + 1 ) ; NEW_LINE DEDENT def noOfTranspositions ( P , n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT visited [ i ] = 0 ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT goesTo [ P [ i ] ] = i + 1 ; NEW_LINE DEDENT transpositions = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( visited [ i ] == 0 ) : NEW_LINE INDENT ans = dfs ( i ) ; NEW_LINE transpositions += ans - 1 ; NEW_LINE DEDENT DEDENT return transpositions ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT permutation = [ 5 , 1 , 4 , 3 , 2 ] ; NEW_LINE n = len ( permutation ) ; NEW_LINE print ( noOfTranspositions ( permutation , n ) ) ; NEW_LINE DEDENT"],"bleu":0.42757075575559456,"rouge_l":0.5785586566119878}
{"id":1316,"predictions":["def getCount ( N ) : NEW_LINE INDENT if ( N % 2 == 1 ) : NEW_LINE INDENT return \"0\" NEW_LINE DEDENT result = \"9\" * ( N \/\/ 2 - 1 ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT result += \"0\" NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 4 NEW_LINE print ( countCount ( N ) ) NEW_LINE DEDENT"],"references":["def getCount ( N ) : NEW_LINE INDENT if ( N % 2 == 1 ) : NEW_LINE INDENT return \"0\" NEW_LINE DEDENT result = \"9\" NEW_LINE for i in range ( 1 , N \/\/ 2 ) : NEW_LINE INDENT result = result + \"0\" NEW_LINE DEDENT return result NEW_LINE DEDENT N = 4 NEW_LINE print ( getCount ( N ) ) NEW_LINE"],"bleu":0.6096033278054374,"rouge_l":0.8033605812897366}
{"id":1317,"predictions":["def isDivisible ( n ) : NEW_LINE INDENT while n \/\/ 100 : NEW_LINE INDENT d = n % 10 NEW_LINE n \/\/= 10 NEW_LINE n += d * 2 NEW_LINE DEDENT return ( n % 19 == 0 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT if ( isDivisible ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def isDivisible ( n ) : NEW_LINE INDENT while ( n \/\/ 100 ) : NEW_LINE INDENT d = n % 10 NEW_LINE n \/\/= 10 NEW_LINE n += d * 2 NEW_LINE DEDENT return ( n % 19 == 0 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 101156 NEW_LINE if ( isDivisible ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.8822523645385892,"rouge_l":0.9604540461369461}
{"id":1318,"predictions":["def printArr ( arr , k ) : NEW_LINE INDENT for i in range ( k ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def printSeqUtil ( n , k , arr , Len , arr ) : NEW_LINE INDENT if ( l == k ) : NEW_LINE INDENT printArr ( arr , k ) NEW_LINE return NEW_LINE DEDENT i = 0 NEW_LINE while ( i <= n ) : NEW_LINE INDENT arr [ Len - 1 ] = i + 1 NEW_LINE i += 1 NEW_LINE DEDENT i += 1 NEW_LINE while ( i <= n ) : NEW_LINE INDENT arr [ Len - 1 ] = i NEW_LINE i = i + 1 NEW_LINE DEDENT while ( i <= n ) : NEW_LINE INDENT arr [ Len - 1 ] = arr [ i ] NEW_LINE i += 1 NEW_LINE DEDENT i -= 1 NEW_LINE while ( i <= n ) : NEW_LINE INDENT arr [ Len - 1 ] = i NEW_LINE i += 1 NEW_LINE DEDENT printSeqUtil ( n , k , arr , Len , arr ) NEW_LINE l -= 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT k = 3 NEW_LINE n = 0 NEW_LINE printSeqUtil ( n , k , arr ) NEW_LINE DEDENT"],"references":["def printArr ( arr , k ) : NEW_LINE INDENT for i in range ( k ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( ) ; NEW_LINE DEDENT def printSeqUtil ( n , k , len1 , arr ) : NEW_LINE INDENT if ( len1 == k ) : NEW_LINE INDENT printArr ( arr , k ) ; NEW_LINE return ; NEW_LINE DEDENT i = 1 if ( len1 == 0 ) else ( arr [ len1 - 1 ] + 1 ) ; NEW_LINE len1 += 1 ; NEW_LINE while ( i <= n ) : NEW_LINE INDENT arr [ len1 - 1 ] = i ; NEW_LINE printSeqUtil ( n , k , len1 , arr ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT len1 -= 1 ; NEW_LINE DEDENT def printSeq ( n , k ) : NEW_LINE INDENT arr = [ 0 ] * k ; NEW_LINE len1 = 0 ; NEW_LINE printSeqUtil ( n , k , len1 , arr ) ; NEW_LINE DEDENT k = 3 ; NEW_LINE n = 7 ; NEW_LINE printSeq ( n , k ) ; NEW_LINE"],"bleu":0.4584118393767197,"rouge_l":0.695976268350194}
{"id":1319,"predictions":["MAXN = 100000001 NEW_LINE spf = [ 0 ] * MAXN NEW_LINE def sieve ( ) : NEW_LINE INDENT spf [ 1 ] = 1 NEW_LINE for i in range ( 2 , MAXN , 2 ) : NEW_LINE INDENT spf [ i ] = i NEW_LINE DEDENT for i in range ( 4 , MAXN , 2 ) : NEW_LINE INDENT spf [ i ] = i NEW_LINE DEDENT for i in range ( 3 , MAXN , 2 ) : NEW_LINE INDENT if ( spf [ i ] == i ) : NEW_LINE INDENT for j in range ( i * i , MAXN , i ) : NEW_LINE INDENT if ( spf [ j ] == j ) : NEW_LINE INDENT spf [ j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def getFactor ( x ) : NEW_LINE INDENT while ( x ) : NEW_LINE INDENT if ( spf [ x ] == i ) : NEW_LINE INDENT spf [ x ] = i NEW_LINE x = x \/\/ spf [ x ] NEW_LINE DEDENT while ( x ) : NEW_LINE INDENT x = spf [ x ] NEW_LINE if ( x % spf [ x ] == j ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT def getFactorization ( x , n ) : NEW_LINE INDENT while ( x ) : NEW_LINE INDENT if ( spf [ x ] == i ) : NEW_LINE INDENT return False NEW_LINE DEDENT x = x \/\/ spf [ x ] NEW_LINE while ( x ) : NEW_LINE INDENT temp = x % spf [ x ] NEW_LINE if ( x % temp == 0 and x != 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 8 , 4 , 10 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE if ( checkFactorization ("],"references":["MAXN = 1000001 NEW_LINE spf = [ i for i in range ( MAXN ) ] NEW_LINE hash1 = [ 0 for i in range ( MAXN ) ] NEW_LINE def sieve ( ) : NEW_LINE INDENT for i in range ( 4 , MAXN , 2 ) : NEW_LINE INDENT spf [ i ] = 2 NEW_LINE DEDENT for i in range ( 3 , MAXN ) : NEW_LINE INDENT if i * i < MAXN : NEW_LINE INDENT break NEW_LINE DEDENT if ( spf [ i ] == i ) : NEW_LINE INDENT for j in range ( i * i , MAXN , i ) : NEW_LINE INDENT if ( spf [ j ] == j ) : NEW_LINE INDENT spf [ j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def getFactorization ( x ) : NEW_LINE INDENT while ( x != 1 ) : NEW_LINE INDENT temp = spf [ x ] NEW_LINE if ( x % temp == 0 ) : NEW_LINE INDENT hash1 [ spf [ x ] ] += 1 NEW_LINE x = x \/\/ spf [ x ] NEW_LINE DEDENT while ( x % temp == 0 ) : NEW_LINE INDENT x = x \/\/ temp NEW_LINE DEDENT DEDENT DEDENT def check ( x ) : NEW_LINE INDENT while ( x != 1 ) : NEW_LINE INDENT temp = spf [ x ] NEW_LINE if ( x % temp == 0 and hash1 [ temp ] > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( x % temp == 0 ) : NEW_LINE INDENT x = x \/\/ temp NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def hasValidNum ( arr , n ) : NEW_LINE INDENT sieve ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT getFactorization ( arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( check ( arr [ i ] ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT arr = [ 2 , 8 , 4 , 10 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE if ( hasValidNum ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.5948913787991145,"rouge_l":0.6401759275387562}
{"id":1320,"predictions":["from math import gcd NEW_LINE def printRatio ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return b NEW_LINE DEDENT return a NEW_LINE DEDENT def printArio ( a , b , c , d ) : NEW_LINE INDENT if ( b * c > a * d ) : NEW_LINE INDENT temp = c NEW_LINE c = d NEW_LINE d = a \/\/ c NEW_LINE d = b \/\/ a NEW_LINE d = b \/\/ c NEW_LINE DEDENT return d NEW_LINE DEDENT def printRatio ( a , b , c , d ) : NEW_LINE INDENT if ( b * c > a * d ) : NEW_LINE INDENT temp = c \/ a NEW_LINE d = b \/\/ c NEW_LINE d = d \/\/ a NEW_LINE DEDENT return NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 4 NEW_LINE b = 3 NEW_LINE d = 2 NEW_LINE printRatio ( a , b , c , d , d ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def printRatio ( a , b , c , d ) : NEW_LINE INDENT if ( b * c > a * d ) : NEW_LINE INDENT swap ( c , d ) NEW_LINE swap ( a , b ) NEW_LINE DEDENT lcm = ( a * c ) \/ math . gcd ( a , c ) NEW_LINE x = lcm \/ a NEW_LINE b = int ( b * x ) NEW_LINE y = lcm \/ c NEW_LINE d = int ( d * y ) NEW_LINE k = math . gcd ( b , d ) NEW_LINE b = int ( b \/ k ) NEW_LINE d = int ( d \/ k ) NEW_LINE print ( b , \" : \" , d ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 4 NEW_LINE b = 3 NEW_LINE c = 2 NEW_LINE d = 2 NEW_LINE printRatio ( a , b , c , d ) NEW_LINE DEDENT"],"bleu":0.40903397877679654,"rouge_l":0.5427324835315254}
{"id":1321,"predictions":["def SieveOfCover ( limit ) : NEW_LINE INDENT if ( limit > 2 ) : NEW_LINE INDENT print ( \"2 ▁ \" , end = \" \" ) ; NEW_LINE DEDENT if ( limit == 3 ) : NEW_LINE INDENT print ( \"3 ▁ \" , end = \" \" ) ; NEW_LINE DEDENT if ( limit > 3 ) : NEW_LINE INDENT for i in range ( limit , limit , 1 ) : NEW_LINE INDENT for j in range ( 1 , limit , 1 ) : NEW_LINE INDENT n = ( 4 * i ) + ( limit * j ) ; NEW_LINE if ( n % 12 == 0 and ( n % 12 == 1 ) ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT DEDENT if ( n <= limit and ( n % 12 == 7 ) ) : NEW_LINE INDENT print ( \" , end = \" \" ) ; NEW_LINE n = ( 3 * x * x ) + ( y * y ) ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT limit = 20 ; NEW_LINE SieveOfCover ( limit ) ; NEW_LINE DEDENT"],"references":["def SieveOfAtkin ( limit ) : NEW_LINE INDENT if ( limit > 2 ) : NEW_LINE INDENT print ( 2 , end = \" ▁ \" ) NEW_LINE DEDENT if ( limit > 3 ) : NEW_LINE INDENT print ( 3 , end = \" ▁ \" ) NEW_LINE DEDENT sieve = [ False ] * limit NEW_LINE for i in range ( 0 , limit ) : NEW_LINE INDENT sieve [ i ] = False NEW_LINE DEDENT x = 1 NEW_LINE while ( x * x < limit ) : NEW_LINE INDENT y = 1 NEW_LINE while ( y * y < limit ) : NEW_LINE INDENT n = ( 4 * x * x ) + ( y * y ) NEW_LINE if ( n <= limit and ( n % 12 == 1 or n % 12 == 5 ) ) : NEW_LINE INDENT sieve [ n ] ^= True NEW_LINE DEDENT n = ( 3 * x * x ) + ( y * y ) NEW_LINE if ( n <= limit and n % 12 == 7 ) : NEW_LINE INDENT sieve [ n ] ^= True NEW_LINE DEDENT n = ( 3 * x * x ) - ( y * y ) NEW_LINE if ( x > y and n <= limit and n % 12 == 11 ) : NEW_LINE INDENT sieve [ n ] ^= True NEW_LINE DEDENT y += 1 NEW_LINE DEDENT x += 1 NEW_LINE DEDENT r = 5 NEW_LINE while ( r * r < limit ) : NEW_LINE INDENT if ( sieve [ r ] ) : NEW_LINE INDENT for i in range ( r * r , limit , r * r ) : NEW_LINE INDENT sieve [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for a in range ( 5 , limit ) : NEW_LINE INDENT if ( sieve [ a ] ) : NEW_LINE INDENT print ( a , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT limit = 20 NEW_LINE SieveOfAtkin ( limit ) NEW_LINE"],"bleu":0.29516177411884026,"rouge_l":0.477824739363201}
{"id":1322,"predictions":["def calculateSide ( n , r ) : NEW_LINE INDENT theta = 180 \/ n NEW_LINE theta = math . pi \/ n NEW_LINE theta = math . pi \/ n NEW_LINE return 2 * theta NEW_LINE DEDENT n = 3 NEW_LINE r = 5 NEW_LINE print ( calculateSide ( n , r ) ) NEW_LINE"],"references":["from math import sin NEW_LINE def calculateSide ( n , r ) : NEW_LINE INDENT theta = 360 \/ n NEW_LINE theta_in_radians = theta * 3.14 \/ 180 NEW_LINE return 2 * r * sin ( theta_in_radians \/ 2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE r = 5 NEW_LINE print ( ' { 0 : . 5 } ' . format ( calculateSide ( n , r ) ) ) NEW_LINE DEDENT"],"bleu":0.3449331213413012,"rouge_l":0.5698398576512456}
{"id":1323,"predictions":["def findSum ( n ) : NEW_LINE INDENT arr = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ i ] [ j ] = abs ( i - j ) NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT sum += arr [ i ] [ j ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE print ( findSum ( n ) ) NEW_LINE DEDENT"],"references":["def findSum ( n ) : NEW_LINE INDENT arr = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT arr [ i ] [ j ] = abs ( i - j ) NEW_LINE DEDENT DEDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT sum += arr [ i ] [ j ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE print ( findSum ( n ) ) NEW_LINE DEDENT"],"bleu":0.9080640032456648,"rouge_l":0.9494769073743302}
{"id":1324,"predictions":["def compute ( arr , N , K ) : NEW_LINE INDENT count_Arr = [ 0 ] * ( N + 2 ) NEW_LINE factor = 1 NEW_LINE size = N NEW_LINE while ( size > 0 ) : NEW_LINE INDENT start = 1 NEW_LINE while ( size > 0 ) : NEW_LINE INDENT current_Arr [ size \/\/= N NEW_LINE count_Arr [ size ] += 1 NEW_LINE factor *= 2 NEW_LINE DEDENT size \/\/= 2 NEW_LINE factor += 1 NEW_LINE DEDENT for i in range ( 2 , N + 1 ) : NEW_LINE INDENT count_Arr [ i ] += count_Arr [ i - 1 ] NEW_LINE DEDENT for i in range ( 2 , N + 1 ) : NEW_LINE INDENT count_Arr [ i ] += count_Arr [ i - 1 ] NEW_LINE count_Arr [ i ] += count_Arr [ i ] NEW_LINE DEDENT return - 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 4 , 5 , 1 ] NEW_LINE N = len ( arr ) NEW_LINE K = 13 NEW_LINE print ( solve ( arr , N , K ) ) NEW_LINE DEDENT"],"references":["def solve ( Array , N , K ) : NEW_LINE INDENT count_Arr = [ 0 ] * ( N + 2 ) ; NEW_LINE factor = 1 ; NEW_LINE size = N ; NEW_LINE while ( size ) : NEW_LINE INDENT start = 1 ; NEW_LINE end = size ; NEW_LINE count_Arr [ 1 ] += factor * N ; NEW_LINE count_Arr [ end + 1 ] -= factor * N ; NEW_LINE factor += 1 ; NEW_LINE size \/\/= 2 ; NEW_LINE DEDENT for i in range ( 2 , N + 1 ) : NEW_LINE INDENT count_Arr [ i ] += count_Arr [ i - 1 ] ; NEW_LINE DEDENT element = [ ] ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT element . append ( ( Array [ i ] , count_Arr [ i + 1 ] ) ) ; NEW_LINE DEDENT element . sort ( ) ; NEW_LINE start = 1 ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT end = start + element [ i ] [ 1 ] - 1 ; NEW_LINE if ( K >= start and K <= end ) : NEW_LINE INDENT return element [ i ] [ 0 ] ; NEW_LINE DEDENT start += element [ i ] [ 1 ] ; NEW_LINE DEDENT return - 1 ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 4 , 5 , 1 ] ; NEW_LINE N = len ( arr ) ; NEW_LINE K = 13 ; NEW_LINE print ( solve ( arr , N , K ) ) ; NEW_LINE DEDENT"],"bleu":0.4278781537276154,"rouge_l":0.6693990877239374}
{"id":1325,"predictions":["def display ( n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( i == 0 or i == n \/\/ 2 ) : NEW_LINE INDENT print ( \"1\" , end = \" ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( end = \" ▁ \" ) NEW_LINE DEDENT if ( i == 0 or i == n \/\/ 2 ) : NEW_LINE INDENT print ( \" ▁ \" , end = \" \" ) NEW_LINE DEDENT elif ( i == 1 or i == n \/\/ 2 ) : NEW_LINE INDENT print ( \" * \" , end = \" ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" * \" , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT n = int ( input ( ) ) NEW_LINE display ( n ) NEW_LINE"],"references":["def display ( n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( ( n \/\/ 2 ) + 1 ) : NEW_LINE INDENT if ( ( j == 0 or j == n \/\/ 2 ) and i != 0 or i == 0 and j != 0 and j != n \/\/ 2 or i == n \/\/ 2 ) : NEW_LINE INDENT print ( \" * \" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" ▁ \" , end = \" \" ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT display ( 7 ) NEW_LINE"],"bleu":0.5097238291073957,"rouge_l":0.6713243477185606}
{"id":1326,"predictions":["import sys NEW_LINE def maxSum ( arr1 , arr2 , n ) : NEW_LINE INDENT minimalParity = 0 NEW_LINE maximumParity = 0 NEW_LINE maximumParity = - ( sys . maxsize - 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT finalParity += arr2 [ i ] NEW_LINE if ( arr1 [ i ] >= 0 ) : NEW_LINE INDENT maximumParity += 1 NEW_LINE DEDENT if ( arr1 [ i ] >= 0 ) : NEW_LINE INDENT maximumParity += 1 NEW_LINE DEDENT else : NEW_LINE INDENT maximumParity = max ( minimumParity , arr1 [ i ] ) NEW_LINE DEDENT DEDENT if ( maximumParity % 2 == 0 ) : NEW_LINE INDENT return sumParity NEW_LINE DEDENT else : NEW_LINE INDENT return sum ( minParity , arr1 [ i ] ) NEW_LINE DEDENT DEDENT arr1 = [ 2 , - 4 , 5 , 3 ] NEW_LINE arr2 = [ 0 , 1 , 1 , 1 ] NEW_LINE n = len ( arr1 ) NEW_LINE print ( maxSum ( arr1 , arr2 , n ) ) NEW_LINE"],"references":["import sys NEW_LINE def maxSum ( arr1 , arr2 , n ) : NEW_LINE INDENT initialParity , finalParity = 0 , 0 NEW_LINE sum = 0 NEW_LINE minPositive = sys . maxsize NEW_LINE maxNegative = - sys . maxsize - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT initialParity += arr2 [ i ] ; NEW_LINE if ( arr1 [ i ] >= 0 ) : NEW_LINE INDENT finalParity += 1 NEW_LINE sum += arr1 [ i ] NEW_LINE minPositive = min ( minPositive , arr1 [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT maxNegative = max ( maxNegative , arr1 [ i ] ) NEW_LINE DEDENT DEDENT if ( initialParity % 2 == finalParity % 2 ) : NEW_LINE INDENT return sum NEW_LINE DEDENT else : NEW_LINE INDENT if ( minPositive + maxNegative >= 0 ) : NEW_LINE INDENT return sum + maxNegative NEW_LINE DEDENT else : NEW_LINE INDENT return sum - minPositive NEW_LINE DEDENT DEDENT DEDENT arr1 = [ 2 , - 4 , 5 , 3 ] NEW_LINE arr2 = [ 0 , 1 , 0 , 1 ] NEW_LINE n = len ( arr1 ) NEW_LINE print ( maxSum ( arr1 , arr2 , n ) ) NEW_LINE"],"bleu":0.6322074203404001,"rouge_l":0.7597592577112765}
{"id":1327,"predictions":["def print10000abc2 ( N ) : NEW_LINE INDENT i = 1 NEW_LINE count = 0 NEW_LINE while ( count < N ) : NEW_LINE INDENT count_count = 0 NEW_LINE for j in range ( 1 , int ( pow ( i , 1 \/ 3 ) + 1 ) ) : NEW_LINE INDENT for k in range ( j + 1 , 2 ) : NEW_LINE INDENT if ( i * j * j + k * j * k == i ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( j * j + k * j == i ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT print ( count , i ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 5 NEW_LINE print10000 ( N ) NEW_LINE DEDENT"],"references":["def printTaxicab2 ( N ) : NEW_LINE INDENT i , count = 1 , 0 NEW_LINE while ( count < N ) : NEW_LINE INDENT int_count = 0 NEW_LINE for j in range ( 1 , int ( pow ( i , 1.0 \/ 3 ) ) + 1 ) : NEW_LINE INDENT for k in range ( j + 1 , int ( pow ( i , 1.0 \/ 3 ) ) + 1 ) : NEW_LINE INDENT if ( j * j * j + k * k * k == i ) : NEW_LINE INDENT int_count += 1 NEW_LINE DEDENT DEDENT DEDENT if ( int_count == 2 ) : NEW_LINE INDENT count += 1 NEW_LINE print ( count , \" ▁ \" , i ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT N = 5 NEW_LINE printTaxicab2 ( N ) NEW_LINE"],"bleu":0.6387288344013319,"rouge_l":0.743320290665176}
{"id":1328,"predictions":["def findIndex ( a , n , key ) : NEW_LINE INDENT start = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == key ) : NEW_LINE INDENT start = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( start == - 1 ) : NEW_LINE INDENT return start NEW_LINE DEDENT end = start NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( a [ i ] == key ) : NEW_LINE INDENT end = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( start == end ) : NEW_LINE INDENT end = i NEW_LINE break NEW_LINE DEDENT DEDENT return end NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 2 , 7 , 8 , 8 , 9 , 0 , 0 , 0 , 0 , 0 ] NEW_LINE key = 8 NEW_LINE findIndex ( a , key ) NEW_LINE if ( start == - 1 ) : NEW_LINE INDENT print ( \" Last ▁ index ▁ is : \" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Last ▁ index : \" , end = \" \" ) NEW_LINE DEDENT DEDENT"],"references":["def findIndex ( a , n , key ) : NEW_LINE INDENT start = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == key : NEW_LINE INDENT start = i NEW_LINE break NEW_LINE DEDENT DEDENT if start == - 1 : NEW_LINE INDENT print ( \" Key ▁ not ▁ present ▁ in ▁ array \" ) NEW_LINE return 0 NEW_LINE DEDENT end = start NEW_LINE for i in range ( n - 1 , start - 1 , - 1 ) : NEW_LINE INDENT if a [ i ] == key : NEW_LINE INDENT end = i NEW_LINE break NEW_LINE DEDENT DEDENT if start == end : NEW_LINE INDENT print ( \" Only ▁ one ▁ key ▁ is ▁ present ▁ at ▁ index ▁ : ▁ \" , start ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Start ▁ index : ▁ \" , start ) NEW_LINE print ( \" Last ▁ index : ▁ \" , end ) NEW_LINE DEDENT DEDENT a = [ 1 , 2 , 7 , 8 , 8 , 9 , 8 , 0 , 0 , 0 , 8 ] NEW_LINE n = len ( a ) NEW_LINE key = 8 NEW_LINE findIndex ( a , n , key ) NEW_LINE"],"bleu":0.6336278508077942,"rouge_l":0.6502242152466369}
{"id":1329,"predictions":["class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . parent = data NEW_LINE self . parent = data NEW_LINE self . parent = data NEW_LINE DEDENT def DFS ( self , v , parent ) : NEW_LINE INDENT self . parent [ v ] = v NEW_LINE self . parent [ v ] = parent [ v ] NEW_LINE return self . parent [ v ] NEW_LINE DEDENT def DFS ( self , src , parent ) : NEW_LINE INDENT if self . parent [ src ] != parent [ parent ] : NEW_LINE INDENT self . parent [ src ] = self . parent [ src ] NEW_LINE self . parent [ src ] = self . parent [ src ] NEW_LINE self . parent [ dest ] = self . parent [ dest ] NEW_LINE self . parent [ dest ] = self . parent [ dest ] NEW_LINE DEDENT def DFS ( self , src , parent , parent ) : NEW_LINE INDENT if self . parent [ src ] != self . parent [ self . parent [ dest ] ] : NEW_LINE INDENT self . parent [ src ] = self . parent [ self . parent [ src ] ] NEW_LINE DEDENT return self . parent [ src ] NEW_LINE DEDENT def DFS ( self , src , dest ) : NEW_LINE INDENT for i in range ( self . children [ i ] ) : NEW_LINE INDENT self . parent [ i ] = self . parent [ i ] NEW_LINE DEDENT self . parent [ i ] = self . parent [ i ] NEW_LINE self . parent [ i ] . parent [ i ] = self . parent [ i ] NEW_LINE self . parent [ i ] . parent [ i ] NEW_LINE self . parent [ i ] . parent [ i ] = self . parent [ i ] NEW_LINE DEDENT def __name__ ( self ) : NEW_LINE INDENT for i in range ( self . children ) : NEW_LINE INDENT self . parent [ i ] . parent [ i ] = self . parent [ i ] . parent [ i ] . parent [ dest ] . parent [ i ] NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW"],"references":["ans = 0 NEW_LINE gr = [ [ ] for i in range ( 100005 ) ] NEW_LINE def Add_Edge ( u , v ) : NEW_LINE INDENT gr [ u ] . append ( v ) NEW_LINE gr [ v ] . append ( u ) NEW_LINE DEDENT def dfs ( child , par , color ) : NEW_LINE INDENT global ans NEW_LINE if ( color [ child ] != color [ par ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT for it in gr [ child ] : NEW_LINE INDENT if ( it == par ) : NEW_LINE INDENT continue NEW_LINE DEDENT dfs ( it , child , color ) NEW_LINE DEDENT DEDENT color = [ 0 , 1 , 2 , 3 , 2 , 2 , 3 ] NEW_LINE Add_Edge ( 1 , 2 ) NEW_LINE Add_Edge ( 1 , 3 ) NEW_LINE Add_Edge ( 2 , 4 ) NEW_LINE Add_Edge ( 2 , 5 ) NEW_LINE Add_Edge ( 3 , 6 ) NEW_LINE dfs ( 1 , 0 , color ) NEW_LINE print ( ans ) NEW_LINE"],"bleu":0.07162621399345556,"rouge_l":0.26013574388852184}
{"id":1330,"predictions":["def longestFibonacci ( n , a ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT lx = 2 NEW_LINE mx = 2 NEW_LINE mx = 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == a [ i - 1 ] + a [ i - 2 ] ) : NEW_LINE INDENT lx = lx + 1 NEW_LINE mx = 2 NEW_LINE DEDENT else : NEW_LINE INDENT mx = 2 NEW_LINE mx = max ( mx , lx ) NEW_LINE DEDENT DEDENT return mx NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 NEW_LINE a = [ 2 , 4 , 6 , 10 , 2 ] NEW_LINE print ( longestFibonacciSubarray ( n , a ) ) NEW_LINE DEDENT"],"references":["def longestFibonacciSubarray ( n , a ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT Len = 2 NEW_LINE mx = - 10 ** 9 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( a [ i ] == a [ i - 1 ] + a [ i - 2 ] ) : NEW_LINE INDENT Len += 1 NEW_LINE DEDENT else : NEW_LINE INDENT Len = 2 NEW_LINE DEDENT mx = max ( mx , Len ) NEW_LINE DEDENT return mx NEW_LINE DEDENT n = 5 NEW_LINE a = [ 2 , 4 , 6 , 10 , 2 ] NEW_LINE print ( longestFibonacciSubarray ( n , a ) ) NEW_LINE"],"bleu":0.6853442289714633,"rouge_l":0.844626883960299}
{"id":1331,"predictions":["class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def alphabetMatrix ( root , matrix , size ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( root != None ) : NEW_LINE INDENT return matrix NEW_LINE DEDENT if ( root != None ) : NEW_LINE INDENT return matrix NEW_LINE DEDENT if ( root . left != None ) : NEW_LINE INDENT matrix = [ [ ] for _ in range ( size ) ] NEW_LINE DEDENT for i in range ( size ) : NEW_LINE INDENT if ( matrix [ root . data ] [ i ] == 1 ) : NEW_LINE INDENT matrix [ root . data ] [ i ] = 1 NEW_LINE DEDENT DEDENT if ( root != None ) : NEW_LINE INDENT matrix [ root . data ] [ i ] = 1 NEW_LINE DEDENT DEDENT d = [ [ 0 for i in range ( size ) ] for j in range ( size ) ] NEW_LINE for i in range ( size ) : NEW_LINE INDENT d [ 0 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( size ) : NEW_LINE INDENT matrix [ i ] [ i ] = 1 NEW_LINE DEDENT DEDENT stack = [ ] NEW_LINE ans_graph = [ ] NEW_LINE for i in range ( size ) : NEW_LINE INDENT for j in range ( size ) : NEW_LINE INDENT if ( matrix [ i ] [ j ] == 1 ) : NEW_LINE INDENT matrix [ i ] [ j ] = 1 NEW_LINE DEDENT DEDENT for i in range ( size ) : NEW_LINE INDENT print ( matrix [ i ] [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT"],"references":["class newnode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = self . right = None NEW_LINE DEDENT DEDENT def ancestorMatrixRec ( root , anc ) : NEW_LINE INDENT global mat , MAX NEW_LINE if root == None : NEW_LINE INDENT return 0 NEW_LINE DEDENT data = root . data NEW_LINE for i in range ( len ( anc ) ) : NEW_LINE INDENT mat [ anc [ i ] ] [ data ] = 1 NEW_LINE DEDENT anc . append ( data ) NEW_LINE l = ancestorMatrixRec ( root . left , anc ) NEW_LINE r = ancestorMatrixRec ( root . right , anc ) NEW_LINE anc . pop ( - 1 ) NEW_LINE return l + r + 1 NEW_LINE DEDENT def ancestorMatrix ( root ) : NEW_LINE INDENT anc = [ ] NEW_LINE n = ancestorMatrixRec ( root , anc ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT MAX = 100 NEW_LINE mat = [ [ 0 ] * MAX for i in range ( MAX ) ] NEW_LINE root = newnode ( 5 ) NEW_LINE root . left = newnode ( 1 ) NEW_LINE root . right = newnode ( 2 ) NEW_LINE root . left . left = newnode ( 0 ) NEW_LINE root . left . right = newnode ( 4 ) NEW_LINE root . right . left = newnode ( 3 ) NEW_LINE ancestorMatrix ( root ) NEW_LINE"],"bleu":0.33556595200626715,"rouge_l":0.4752732388269668}
{"id":1332,"predictions":["def OddDivCount ( a , b ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT divCount = 0 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT divCount = divCount + 1 NEW_LINE DEDENT DEDENT if ( divCount % 2 != 0 ) : NEW_LINE INDENT res = res + 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a , b = 1 , 10 NEW_LINE print ( OddDivCount ( a , b ) ) NEW_LINE DEDENT"],"references":["def OddDivCount ( a , b ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT divCount = 0 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT divCount += 1 NEW_LINE DEDENT DEDENT if ( divCount % 2 ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 1 NEW_LINE b = 10 NEW_LINE print ( OddDivCount ( a , b ) ) NEW_LINE DEDENT"],"bleu":0.8514912514865904,"rouge_l":0.9359515765765767}
{"id":1333,"predictions":["def findNDigitNums ( n , sum , index ) : NEW_LINE INDENT if ( index > n or sum < 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( index == n or sum < 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( index == n ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( index == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT for i in range ( 9 , 10 ) : NEW_LINE INDENT print ( str ( i + ord ( '0' ) , end = \" \" ) , end = \" \" ) NEW_LINE findNDigitNums ( n , sum - i , index + 1 , 1 ) NEW_LINE DEDENT DEDENT def findNDigitNums ( n , sum , sum , index ) : NEW_LINE INDENT for i in range ( 10 ) : NEW_LINE INDENT print ( chr ( i + ord ( '0' ) , end = \" \" ) NEW_LINE findNDigitNums ( n , sum - i , index + 1 ) , 1 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n , sum = 2 , 3 NEW_LINE findNDigitNums ( n , sum - i , 1 ) NEW_LINE DEDENT"],"references":["def findNDigitNumsUtil ( n , sum , out , index ) : NEW_LINE INDENT if ( index > n or sum < 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT f = \" \" NEW_LINE if ( index == n ) : NEW_LINE INDENT if ( sum == 0 ) : NEW_LINE INDENT out [ index ] = \" \" NEW_LINE for i in out : NEW_LINE INDENT f = f + i NEW_LINE DEDENT print ( f , end = \" ▁ \" ) NEW_LINE DEDENT return NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT out [ index ] = chr ( i + ord ( '0' ) ) NEW_LINE findNDigitNumsUtil ( n , sum - i , out , index + 1 ) NEW_LINE DEDENT DEDENT def findNDigitNums ( n , sum ) : NEW_LINE INDENT out = [ False ] * ( n + 1 ) NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT out [ 0 ] = chr ( i + ord ( '0' ) ) NEW_LINE findNDigitNumsUtil ( n , sum - i , out , 1 ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 2 NEW_LINE sum = 3 NEW_LINE findNDigitNums ( n , sum ) NEW_LINE DEDENT"],"bleu":0.5675461294499485,"rouge_l":0.6873880597014925}
{"id":1334,"predictions":["def minimum increase ( a , b , c ) : NEW_LINE INDENT arr . sort ( reverse = True ) NEW_LINE if ( arr [ 1 ] + arr [ 2 ] >= arr [ 1 ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return arr [ 2 ] - ( arr [ 1 ] + arr [ 2 ] ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 3 NEW_LINE b = 5 NEW_LINE c = 10 NEW_LINE print ( minimum increase ( a , b , c ) ) NEW_LINE DEDENT"],"references":["def minimumIncrease ( a , b , c ) : NEW_LINE INDENT arr = [ a , b , c ] NEW_LINE arr . sort ( ) NEW_LINE if arr [ 0 ] + arr [ 1 ] >= arr [ 2 ] : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return arr [ 2 ] - ( arr [ 0 ] + arr [ 1 ] ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a , b , c = 3 , 5 , 10 NEW_LINE print ( minimumIncrease ( a , b , c ) ) NEW_LINE DEDENT"],"bleu":0.6804156655402617,"rouge_l":0.8034630753292881}
{"id":1335,"predictions":["def breakSum ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return max ( ( ( int ( n \/ 2 ) ) , breakSum ( int ( n \/ 2 ) + int ( n \/ 3 ) ) ) NEW_LINE DEDENT n = 12 NEW_LINE print ( breakSum ( n ) ) NEW_LINE"],"references":["def breakSum ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return max ( ( breakSum ( n \/\/ 2 ) + breakSum ( n \/\/ 3 ) + breakSum ( n \/\/ 4 ) ) , n ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 12 NEW_LINE print ( breakSum ( n ) ) NEW_LINE DEDENT"],"bleu":0.5695273243468555,"rouge_l":0.7491919844861021}
{"id":1336,"predictions":["def maxLengthSquare ( row , col , k ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( row + 1 ) : NEW_LINE INDENT sum = sum + ( col [ i ] [ j ] for j in range ( col ) ) NEW_LINE DEDENT cur_max = 1 NEW_LINE max = 0 NEW_LINE for i in range ( 1 , row + 1 ) : NEW_LINE INDENT for j in range ( 1 , col + 1 ) : NEW_LINE INDENT sum = sum + ( sum % i - 1 ) NEW_LINE if ( i >= cur_max and j >= k ) : NEW_LINE INDENT max = cur_max NEW_LINE DEDENT if ( i >= cur_max and j >= k ) : NEW_LINE INDENT max = cur_max + 1 NEW_LINE DEDENT DEDENT DEDENT return max NEW_LINE DEDENT row = [ [ 1 , 1 , 1 ] , [ 1 , 0 , 0 ] , [ 1 , 0 , 0 ] , [ 1 , 0 , 0 , 0 ] ] NEW_LINE k = 6 NEW_LINE ans = maxLengthSquare ( row , column , matrix , k ) NEW_LINE return ans NEW_LINE DEDENT row = [ [ 1 , 1 , 1 ] , [ 1 , 0 , 0 ] , [ 1 , 0 , 0 , 0 ] ] NEW_LINE row = [ [ 1 , 0 , 1 ] , [ 1 , 0 , 0 ] ] NEW_LINE k = 6 NEW_LINE ans = maxLengthSquare ( row , column , matrix , k ) NEW_LINE print ( ans ) NEW_LINE"],"references":["import numpy as np NEW_LINE def maxLengthSquare ( row , column , arr , k ) : NEW_LINE INDENT sum = np . zeros ( ( row + 1 , column + 1 ) ) ; NEW_LINE cur_max = 1 ; NEW_LINE max = 0 ; NEW_LINE for i in range ( 1 , row + 1 ) : NEW_LINE INDENT for j in range ( 1 , column + 1 ) : NEW_LINE INDENT sum [ i ] [ j ] = sum [ i - 1 ] [ j ] + sum [ i ] [ j - 1 ] +   \\ NEW_LINE INDENT arr [ i - 1 ] [ j - 1 ] -   \\ NEW_LINE sum [ i - 1 ] [ j - 1 ] ; NEW_LINE DEDENT if ( i >= cur_max and j >= cur_max and sum [ i ] [ j ] - sum [ i - cur_max ] [ j ] - sum [ i ] [ j - cur_max ] + sum [ i - cur_max ] [ j - cur_max ] <= k ) : NEW_LINE INDENT max = cur_max ; NEW_LINE cur_max += 1 ; NEW_LINE DEDENT DEDENT DEDENT return max ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT row = 4 ; NEW_LINE column = 4 ; NEW_LINE matrix = [ [ 1 , 1 , 1 , 1 ] , [ 1 , 0 , 0 , 0 ] , [ 1 , 0 , 0 , 0 ] , [ 1 , 0 , 0 , 0 ] ] ; NEW_LINE k = 6 ; NEW_LINE ans = maxLengthSquare ( row , column , matrix , k ) ; NEW_LINE print ( ans ) ; NEW_LINE DEDENT"],"bleu":0.4734386168018379,"rouge_l":0.5515866329682673}
{"id":1337,"predictions":["def minimumChanges ( arr , n ) : NEW_LINE INDENT changes = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT j = 1 NEW_LINE continue NEW_LINE DEDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT change += 1 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ j ] == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT changes += 1 NEW_LINE changes += 1 NEW_LINE DEDENT DEDENT return changes NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 1 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Minimum ▁ operations : \" , minimumChanges ( arr , n ) ) NEW_LINE DEDENT"],"references":["def minimumChanges ( arr , n ) : NEW_LINE INDENT changes = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if arr [ i ] == 1 : NEW_LINE INDENT j = i + 1 NEW_LINE while j < n : NEW_LINE INDENT if arr [ j ] == 0 : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT i = j - 1 NEW_LINE changes += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return changes NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 1 , 0 , 0 , 0 , 1 , 0 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Minimum ▁ operations : \" , minimumChanges ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.6219131460466346,"rouge_l":0.7934644670050761}
{"id":1338,"predictions":["MAX = 10000 NEW_LINE prime = [ True ] * ( n + 1 ) NEW_LINE def addPrimes ( n ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , n , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = 0 NEW_LINE v = [ ] NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT ans = 1 NEW_LINE break NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def find_sum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE v = [ ] NEW_LINE for i in range ( len ( prime ) ) : NEW_LINE INDENT if ( prime [ v [ i ] ] ) : NEW_LINE INDENT v . append ( i ) NEW_LINE while ( a != 0 and n > 0 ) : NEW_LINE INDENT d = 1 NEW_LINE a = a % 10 NEW_LINE if ( is_prime ( i ) ) : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == 1 ) : NEW_LINE INDENT n -= 1 NEW_LINE break NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 7 NEW_LINE print ( find_sum ( n ) ) NEW_LINE DEDENT"],"references":["MAX = 100005 NEW_LINE def addPrimes ( ) : NEW_LINE INDENT n = MAX NEW_LINE prime = [ True for i in range ( n + 1 ) ] NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if p * p > n : NEW_LINE INDENT break NEW_LINE DEDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( 2 * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT ans = [ ] NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT ans . append ( p ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def is_prime ( n ) : NEW_LINE INDENT if n in [ 3 , 5 , 7 ] : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def find_Sum ( n ) : NEW_LINE INDENT Sum = 0 NEW_LINE v = addPrimes ( ) NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT flag = 1 NEW_LINE a = v [ i ] NEW_LINE while ( a != 0 ) : NEW_LINE INDENT d = a % 10 ; NEW_LINE a = a \/\/ 10 ; NEW_LINE if ( is_prime ( d ) ) : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == 1 ) : NEW_LINE INDENT n -= 1 NEW_LINE Sum = Sum + v [ i ] NEW_LINE DEDENT if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return Sum NEW_LINE DEDENT n = 7 NEW_LINE print ( find_Sum ( n ) ) NEW_LINE"],"bleu":0.596315624664903,"rouge_l":0.6797142857142858}
{"id":1339,"predictions":["import math NEW_LINE def Squipy_sum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for k in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += k * k * k NEW_LINE DEDENT if ( sum == 3 ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT print ( \" Yes \" ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 NEW_LINE Quipy_sum ( n ) NEW_LINE DEDENT"],"references":["def NicomachuTheorum_sum ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for k in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += k * k * k ; NEW_LINE DEDENT triNo = n * ( n + 1 ) \/ 2 ; NEW_LINE if ( sum == triNo * triNo ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT n = 5 ; NEW_LINE NicomachuTheorum_sum ( n ) ; NEW_LINE"],"bleu":0.5696549484484837,"rouge_l":0.7378194207836456}
{"id":1340,"predictions":["MAX = 10000 NEW_LINE sequence = [ 0 ] * ( MAX - 1 ) NEW_LINE def vanEckSequence ( ) : NEW_LINE INDENT for i in range ( MAX - 1 , - 1 , - 1 ) : NEW_LINE INDENT sequence [ i ] = i - j NEW_LINE DEDENT DEDENT def getNthTerm ( n ) : NEW_LINE INDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( sequence [ i ] == sequence [ i ] ) : NEW_LINE INDENT sequence [ i + 1 ] = i - j NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT return sequence [ n ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT vanEckSequence ( ) NEW_LINE n = 6 NEW_LINE print ( getNthTerm ( n ) ) NEW_LINE DEDENT"],"references":["MAX = 1000 NEW_LINE sequence = [ 0 ] * ( MAX + 1 ) ; NEW_LINE def vanEckSequence ( ) : NEW_LINE INDENT for i in range ( MAX ) : NEW_LINE INDENT sequence [ i ] = 0 ; NEW_LINE DEDENT for i in range ( MAX ) : NEW_LINE INDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( sequence [ j ] == sequence [ i ] ) : NEW_LINE INDENT sequence [ i + 1 ] = i - j ; NEW_LINE break ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def getNthTerm ( n ) : NEW_LINE INDENT return sequence [ n ] ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT vanEckSequence ( ) ; NEW_LINE n = 6 ; NEW_LINE print ( getNthTerm ( n ) ) ; NEW_LINE n = 100 ; NEW_LINE print ( getNthTerm ( n ) ) ; NEW_LINE DEDENT"],"bleu":0.6446129781699877,"rouge_l":0.7925345432047844}
{"id":1341,"predictions":["def maximum fixedPoints ( a , n ) : NEW_LINE INDENT count = 0 ; NEW_LINE carry = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT pos = a [ i ] ; NEW_LINE if ( a [ i ] == i ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT elif ( a [ i ] == i ) : NEW_LINE INDENT count += 2 ; NEW_LINE DEDENT DEDENT if ( swaps == 0 and pos == n - 1 ) : NEW_LINE INDENT count += 2 ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT a = [ 0 , 1 , 3 , 4 , 4 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( maximum fixedPoints ( a , n - 1 ) ) ; NEW_LINE"],"references":["def maximumFixedPoints ( a , n ) : NEW_LINE INDENT pos = [ None ] * n NEW_LINE count , swapped = 0 , 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT pos [ a [ i ] ] = i NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if a [ i ] == i : NEW_LINE INDENT count += 1 NEW_LINE DEDENT elif swapped == 0 and pos [ i ] == a [ i ] : NEW_LINE INDENT count += 2 NEW_LINE swapped = 1 NEW_LINE DEDENT DEDENT if swapped == 0 and count < n - 1 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 0 , 1 , 3 , 4 , 2 ] NEW_LINE n = len ( a ) NEW_LINE print ( maximumFixedPoints ( a , n ) ) NEW_LINE DEDENT"],"bleu":0.415344487963407,"rouge_l":0.6802501302761854}
{"id":1342,"predictions":["def countCoor ( amount ) : NEW_LINE INDENT ways = [ 0 , 100 , 500 , 50 , 50 , 50 , 5 , 1 ] NEW_LINE note = [ 0 ] * 1000 NEW_LINE for i in range ( 9 ) : NEW_LINE INDENT if ( note >= notes [ i ] ) : NEW_LINE INDENT if ( note >= notes [ i ] ) : NEW_LINE INDENT note [ i ] = notes [ i ] NEW_LINE DEDENT note = ( note - note [ i ] ) NEW_LINE DEDENT DEDENT note [ i ] = count [ 0 ] NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT if ( note [ i ] != 0 ) : NEW_LINE INDENT note [ i ] = ( i + note [ i ] * note [ i ] ) NEW_LINE DEDENT DEDENT DEDENT print ( \" Number ▁ = \" , countCoor ( amount ) ) NEW_LINE"],"references":["def countCurrency ( amount ) : NEW_LINE INDENT notes = [ 2000 , 500 , 200 , 100 , 50 , 20 , 10 , 5 , 1 ] NEW_LINE noteCounter = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] NEW_LINE print ( \" Currency ▁ Count ▁ - > ▁ \" ) NEW_LINE for i , j in zip ( notes , noteCounter ) : NEW_LINE INDENT if amount >= i : NEW_LINE INDENT j = amount \/\/ i NEW_LINE amount = amount - j * i NEW_LINE print ( i , \" ▁ : ▁ \" , j ) NEW_LINE DEDENT DEDENT DEDENT amount = 868 NEW_LINE countCurrency ( amount ) NEW_LINE"],"bleu":0.1967397345068998,"rouge_l":0.4352046783625731}
{"id":1343,"predictions":["MAX_CHAR = 256 NEW_LINE def isPalindrome ( str , l , h ) : NEW_LINE INDENT while ( h > l ) : NEW_LINE INDENT if ( str [ l ] != str [ h ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def check ( str , l , h ) : NEW_LINE INDENT freq = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) ] += 1 NEW_LINE if ( freq [ ord ( str [ i ] ) ] > 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT k = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( freq [ str [ i ] ] > 1 ) : NEW_LINE INDENT if ( k & 1 ) : NEW_LINE INDENT if ( k \/\/ 2 >= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( str [ i ] == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( k \/\/ 2 >= 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT str = \" ABD \" NEW_LINE if ( check ( str , 0 , k - 1 ) ) : NEW_LINE INDENT print ( \" Repeated ▁ exists \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Repeating ▁ exists \" ) NEW_LINE DEDENT"],"references":["MAX_CHAR = 256 NEW_LINE def isPalindrome ( Str , l , h ) : NEW_LINE INDENT while ( h > l ) : NEW_LINE INDENT if ( Str [ l ] != Str [ h ] ) : NEW_LINE INDENT l += 1 NEW_LINE h -= 1 NEW_LINE return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def check ( Str ) : NEW_LINE INDENT n = len ( Str ) NEW_LINE freq = [ 0 for i in range ( MAX_CHAR ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( Str [ i ] ) ] += 1 NEW_LINE if ( freq [ ord ( Str [ i ] ) ] > 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT k = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( freq [ ord ( Str [ i ] ) ] > 1 ) : NEW_LINE INDENT Str [ k ] = Str [ i ] NEW_LINE k += 1 NEW_LINE DEDENT DEDENT Str [ k ] = ' \\0' NEW_LINE if ( isPalindrome ( Str , 0 , k - 1 ) ) : NEW_LINE INDENT if ( k & 1 ) : NEW_LINE INDENT return Str [ k \/\/ 2 ] == Str [ k \/\/ 2 - 1 ] NEW_LINE DEDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT S = \" ABCABD \" NEW_LINE Str = [ i for i in S ] NEW_LINE if ( check ( Str ) ) : NEW_LINE INDENT print ( \" Repeated ▁ Subsequence ▁ Exists \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Repeated ▁ Subsequence ▁ Doesn ' t ▁ Exists \" ) NEW_LINE DEDENT"],"bleu":0.6123483315610345,"rouge_l":0.7018683071314652}
{"id":1344,"predictions":["def divisors ( A , B , C ) : NEW_LINE INDENT C = [ 0 for i in range ( N ) ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( 1 , i ) : NEW_LINE INDENT cnt [ i * j ] += 1 NEW_LINE DEDENT DEDENT DEDENT def Sumofdivisors ( A , B , C ) : NEW_LINE INDENT Sum = 0 NEW_LINE Divisors = [ 0 for i in range ( A + 1 ) ] NEW_LINE for i in range ( 1 , A + 1 ) : NEW_LINE INDENT for j in range ( 1 , B + 1 ) : NEW_LINE INDENT x = i * j * j NEW_LINE if ( i >= C [ i ] ) : NEW_LINE INDENT Sum -= mod NEW_LINE DEDENT DEDENT DEDENT return Sum NEW_LINE DEDENT A = 5 NEW_LINE B = 6 NEW_LINE C = 7 NEW_LINE print ( Sumofdivisors ( A , B , C ) ) NEW_LINE"],"references":["N = 100005 NEW_LINE mod = 1000000007 NEW_LINE cnt = [ 0 ] * N ; NEW_LINE def Divisors ( ) : NEW_LINE INDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( 1 , N \/\/ i ) : NEW_LINE INDENT cnt [ i * j ] += 1 ; NEW_LINE DEDENT DEDENT DEDENT def Sumofdivisors ( A , B , C ) : NEW_LINE INDENT sum = 0 ; NEW_LINE Divisors ( ) ; NEW_LINE for i in range ( 1 , A + 1 ) : NEW_LINE INDENT for j in range ( 1 , B + 1 ) : NEW_LINE INDENT for k in range ( 1 , C + 1 ) : NEW_LINE INDENT x = i * j * k ; NEW_LINE sum += cnt [ x ] ; NEW_LINE if ( sum >= mod ) : NEW_LINE INDENT sum -= mod ; NEW_LINE DEDENT DEDENT DEDENT DEDENT return sum ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = 5 ; B = 6 ; C = 7 ; NEW_LINE print ( Sumofdivisors ( A , B , C ) ) ; NEW_LINE DEDENT"],"bleu":0.535220331128859,"rouge_l":0.7117612243172402}
{"id":1345,"predictions":["def factorial ( N ) : NEW_LINE INDENT fact = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT fact = fact * i NEW_LINE DEDENT return fact NEW_LINE DEDENT def nthTerm ( N ) : NEW_LINE INDENT return ( factorial ( N + 1 ) \/\/ 2 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 6 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT"],"references":["def factorial ( N ) : NEW_LINE INDENT fact = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT fact = fact * i NEW_LINE DEDENT return fact NEW_LINE DEDENT def nthTerm ( N ) : NEW_LINE INDENT return ( factorial ( N + 1 ) \/\/ 2 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 6 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT"],"bleu":1.0,"rouge_l":1.0}
{"id":1346,"predictions":["def prefix ( str ) : NEW_LINE INDENT k = 1 NEW_LINE n = len ( str ) NEW_LINE f = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( str [ i ] == str [ 0 ] ) : NEW_LINE INDENT f = 1 NEW_LINE continue NEW_LINE DEDENT if ( f == 0 ) : NEW_LINE INDENT k += 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if ( f == 0 ) : NEW_LINE INDENT k = 0 NEW_LINE while ( k < len ( str ) and ord ( str [ k ] + str [ k ] ) < n and str [ k ] == str [ k ] ) : NEW_LINE INDENT cnt = 0 NEW_LINE while ( k < len ( str ) ) : NEW_LINE INDENT if ( ord ( str [ k ] ) + ord ( str [ k ] ) < n and str [ k ] == str [ i ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE break NEW_LINE DEDENT k += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT k += 1 NEW_LINE DEDENT DEDENT for i in range ( k ) : NEW_LINE INDENT print ( str [ i ] ) NEW_LINE DEDENT DEDENT str = \" abcab \" NEW_LINE prefix ( str ) NEW_LINE"],"references":["def prefix ( string ) : NEW_LINE INDENT k = 1 ; NEW_LINE n = len ( string ) ; NEW_LINE g = [ ] ; NEW_LINE flag = 0 ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( string [ i ] == string [ 0 ] ) : NEW_LINE INDENT g . append ( i ) ; NEW_LINE flag = 1 ; NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT print ( string ) ; NEW_LINE DEDENT else : NEW_LINE INDENT length = len ( g ) ; NEW_LINE while ( k < g [ 0 ] ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for j in range ( length ) : NEW_LINE INDENT if ( string [ g [ j ] + k ] == string [ k ] ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT if ( cnt == len ) : NEW_LINE INDENT k += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT for i in range ( k + 1 ) : NEW_LINE INDENT print ( string [ i ] , end = \" \" ) ; NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" abcab \" ; NEW_LINE prefix ( string ) ; NEW_LINE DEDENT"],"bleu":0.44854983408332183,"rouge_l":0.6093696176369273}
{"id":1347,"predictions":["def findTerm ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT else : NEW_LINE INDENT term = term * 2 + ( i - 1 ) NEW_LINE DEDENT return term NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 NEW_LINE print ( findTerm ( n ) ) NEW_LINE DEDENT"],"references":["def findTerm ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return n NEW_LINE DEDENT else : NEW_LINE INDENT term = 7 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT term = term * 2 + ( i - 1 ) ; NEW_LINE DEDENT DEDENT return term ; NEW_LINE DEDENT print ( findTerm ( 5 ) ) NEW_LINE"],"bleu":0.5932044257378944,"rouge_l":0.6852294455066921}
{"id":1348,"predictions":["INT_MIN = 32 NEW_LINE def Right_most_setbit ( num ) : NEW_LINE INDENT pos = 1 NEW_LINE for i in range ( 0 , INT_MAX ) : NEW_LINE INDENT if ( num & ( 1 << i ) ) : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT else : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT DEDENT return pos NEW_LINE DEDENT num = 18 NEW_LINE pos = Right_bit ( num ) NEW_LINE print ( pos ) NEW_LINE"],"references":["INT_SIZE = 32 NEW_LINE def Right_most_setbit ( num ) : NEW_LINE INDENT pos = 1 NEW_LINE for i in range ( INT_SIZE ) : NEW_LINE INDENT if not ( num & ( 1 << i ) ) : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return pos NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT num = 18 NEW_LINE pos = Right_most_setbit ( num ) NEW_LINE print ( pos ) NEW_LINE DEDENT"],"bleu":0.6833621665624955,"rouge_l":0.8243243243243242}
{"id":1349,"predictions":["def subarrayXor ( arr , n , m ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT xorSum = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT xorSum = xorSum ^ arr [ j ] NEW_LINE if ( xorSum == m ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 4 , 2 , 2 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE m = len ( arr ) NEW_LINE print ( \" Number ▁ of ▁ subarray ▁ with ▁ subarrayXor ( arr , n , m ) ) NEW_LINE"],"references":["def subarrayXor ( arr , n , m ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT xorSum = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT xorSum = xorSum ^ arr [ j ] NEW_LINE if ( xorSum == m ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT arr = [ 4 , 2 , 2 , 6 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE m = 6 NEW_LINE print ( \" Number ▁ of ▁ subarrays ▁ having ▁ given ▁ XOR ▁ is ▁ \" , subarrayXor ( arr , n , m ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"bleu":0.6511725690204943,"rouge_l":0.8077559706786474}
{"id":1350,"predictions":["from math import sqrt NEW_LINE def evaluateDivision ( N ) : NEW_LINE INDENT i = 2 NEW_LINE k = ceil ( sqrt ( N ) ) NEW_LINE while ( i <= k ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 49 NEW_LINE p = slopeDivision ( N ) NEW_LINE if ( p != 0 ) : NEW_LINE INDENT print ( \" Prime \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Composite \" ) NEW_LINE DEDENT DEDENT"],"references":["def TrialDivision ( N ) : NEW_LINE INDENT i = 2 NEW_LINE k = int ( N ** 0.5 ) NEW_LINE while ( i <= k ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 49 NEW_LINE p = TrialDivision ( N ) NEW_LINE if ( p ) : NEW_LINE INDENT print ( \" Prime \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Composite \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.8267671700477403,"rouge_l":0.9242424242424242}
{"id":1351,"predictions":["def count ( arr , N , K ) : NEW_LINE INDENT count = 0 ; NEW_LINE ans = 0 ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] == K ) : NEW_LINE INDENT count = count + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( count * ( count + 1 ) ) \/\/ 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( count * ( count + 1 ) ) \/\/ 2 ; NEW_LINE count = 0 ; NEW_LINE DEDENT DEDENT ans = ans + ( count * ( count + 1 ) ) \/\/ 2 ; NEW_LINE return ans ; NEW_LINE DEDENT arr = [ 1 , 0 , 1 , 1 , 0 , 0 , 0 ] ; NEW_LINE N = len ( arr ) ; NEW_LINE K = 0 ; NEW_LINE print ( count ( arr , N , K ) ) ; NEW_LINE"],"references":["def count ( arr , N , K ) : NEW_LINE INDENT count = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] == K ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( count * ( count + 1 ) ) \/\/ 2 NEW_LINE count = 0 NEW_LINE DEDENT DEDENT ans = ans + ( count * ( count + 1 ) ) \/\/ 2 NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 0 , 0 , 1 , 1 , 0 , 0 ] NEW_LINE N = len ( arr ) NEW_LINE K = 0 NEW_LINE print ( count ( arr , N , K ) ) NEW_LINE DEDENT"],"bleu":0.7146030664557848,"rouge_l":0.8517930815614091}
{"id":1352,"predictions":["def centered_capagonal_num ( n ) : NEW_LINE INDENT return ( 7 * n * n - 7 * n + 2 ) \/\/ 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( n , \" rd ▁ Centered ▁ Centered ▁ Centered_num ( n ) ) NEW_LINE DEDENT"],"references":["def centered_heptagonal_num ( n ) : NEW_LINE INDENT return ( 7 * n * n - 7 * n + 2 ) \/\/ 2 NEW_LINE DEDENT n = 5 NEW_LINE print ( \" % sth ▁ Centered ▁ heptagonal ▁ number ▁ : ▁ \" % n , centered_heptagonal_num ( n ) ) NEW_LINE"],"bleu":0.5641296437141217,"rouge_l":0.7209570481406746}
{"id":1353,"predictions":["def findolution ( d , h , m , n ) : NEW_LINE INDENT k = ( 4 * m ) \/ ( 10 * d ) NEW_LINE if n > k : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if n > k : NEW_LINE INDENT return - 1 NEW_LINE DEDENT ans = ( h \/ ( k - n ) ) NEW_LINE return ans NEW_LINE DEDENT d = 1 NEW_LINE m = 1 NEW_LINE n = 1 NEW_LINE print ( findolution ( d , h , m , n ) ) NEW_LINE"],"references":["pie = 3.1415926535897 NEW_LINE def findsolution ( d , h , m , n ) : NEW_LINE INDENT k = ( 4 * m ) \/ ( pie * d * d ) NEW_LINE if ( n > k ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT ans = ( h \/ ( k - n ) ) NEW_LINE return round ( ans , 5 ) NEW_LINE DEDENT d = 1 NEW_LINE h = 1 NEW_LINE m = 1 NEW_LINE n = 1 NEW_LINE print ( findsolution ( d , h , m , n ) ) NEW_LINE"],"bleu":0.7098109676930241,"rouge_l":0.8148461278322624}
{"id":1354,"predictions":["def countNum ( N , arr ) : NEW_LINE INDENT sum = 0 NEW_LINE count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT if ( ( sum - arr [ i ] ) % arr [ i ] == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 10 , 4 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countNum ( arr ) ) NEW_LINE DEDENT"],"references":["def countNum ( N , arr ) : NEW_LINE INDENT Sum , count = 0 , 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT if ( ( Sum - arr [ i ] ) % arr [ i ] == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 3 , 10 , 4 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countNum ( n , arr ) ) NEW_LINE"],"bleu":0.7450783969536856,"rouge_l":0.8742322316466803}
{"id":1355,"predictions":["import math NEW_LINE def CountTrailingZeros ( n ) : NEW_LINE INDENT bit1 = bin ( n ) [ 2 : ] NEW_LINE bit1 = bin ( n ) NEW_LINE bit2 = bin ( bit1 ) [ : : - 1 ] NEW_LINE bit1 = bin ( bit1 [ : - 1 ] ) NEW_LINE bit1 = bin ( bit1 [ : : - 1 ] ) NEW_LINE bit2 = bin ( bit2 ) NEW_LINE return 0 NEW_LINE DEDENT n = 4 NEW_LINE ans = CountTrailingZeros ( n ) NEW_LINE print ( ans ) NEW_LINE"],"references":["def CountTrailingZeros ( n ) : NEW_LINE INDENT bit = bin ( n ) [ 2 : ] NEW_LINE bit = bit [ : : - 1 ] NEW_LINE zero = 0 ; NEW_LINE for i in range ( len ( bit ) ) : NEW_LINE INDENT if ( bit [ i ] == '0' ) : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return zero NEW_LINE DEDENT n = 4 NEW_LINE ans = CountTrailingZeros ( n ) NEW_LINE print ( ans ) NEW_LINE"],"bleu":0.44496504756348537,"rouge_l":0.5925468032497351}
{"id":1356,"predictions":["def printConsecutive ( last , first ) : NEW_LINE INDENT first = first + last ; NEW_LINE for x in first : NEW_LINE INDENT print ( first , end = \" ▁ \" ) NEW_LINE last , end = \" ▁ \" , end = \" ▁ \" ) NEW_LINE for last in range ( first ) : NEW_LINE INDENT first = first * first NEW_LINE last = first < last NEW_LINE if ( second < ( first - first ) * ( last + first ) * ( last + first ) ) NEW_LINE DEDENT print ( second , end = \" ▁ \" ) NEW_LINE return NEW_LINE DEDENT print ( - 1 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 12 NEW_LINE findConsecutive ( last , first ) NEW_LINE DEDENT"],"references":["def printConsecutive ( last , first ) : NEW_LINE INDENT print ( first , end = \" \" ) NEW_LINE first += 1 NEW_LINE for x in range ( first , last + 1 ) : NEW_LINE INDENT print ( \" ▁ + \" , x , end = \" \" ) NEW_LINE DEDENT DEDENT def findConsecutive ( N ) : NEW_LINE INDENT for last in range ( 1 , N ) : NEW_LINE INDENT for first in range ( 0 , last ) : NEW_LINE INDENT if 2 * N == ( last - first ) * ( last + first + 1 ) : NEW_LINE INDENT print ( N , \" = ▁ \" , end = \" \" ) NEW_LINE printConsecutive ( last , first + 1 ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( \" - 1\" ) NEW_LINE DEDENT n = 12 NEW_LINE findConsecutive ( n ) NEW_LINE"],"bleu":0.41540217655303024,"rouge_l":0.5701561469100506}
{"id":1357,"predictions":["def LCSubStr ( X , Y , m , n ) : NEW_LINE INDENT LCST = [ 0 ] * ( n + 1 ) NEW_LINE result = 0 NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT LSt [ i ] = 0 NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] ) : NEW_LINE INDENT L = L [ i - 1 ] NEW_LINE DEDENT elif ( X [ i ] == Y [ j - 1 ] ) : NEW_LINE INDENT L [ i ] = L [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return L [ i ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return R [ m ] NEW_LINE DEDENT DEDENT def LCString ( X , Y , m , n ) : NEW_LINE INDENT L = len ( X ) NEW_LINE m = len ( Y ) NEW_LINE n = len ( X ) NEW_LINE return ( LCSubStr ( X , Y , m , n ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT X = \" RD scaffold \" NEW_LINE Y = len ( X ) NEW_LINE m = len ( Y ) NEW_LINE n = len ( X ) NEW_LINE m = len ( Y ) NEW_LINE n = len ( Y ) NEW_LINE print ( \" Length ▁ of ▁ LargestString ( X , Y , m , n ) ) NEW_LINE DEDENT"],"references":["def LCSubStr ( X , Y , m , n ) : NEW_LINE INDENT LCSuff = [ [ 0 for k in range ( n + 1 ) ] for l in range ( m + 1 ) ] NEW_LINE result = 0 NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT LCSuff [ i ] [ j ] = 0 NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] ) : NEW_LINE INDENT LCSuff [ i ] [ j ] = LCSuff [ i - 1 ] [ j - 1 ] + 1 NEW_LINE result = max ( result , LCSuff [ i ] [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT LCSuff [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT X = ' OldSite : GeeksforGeeks . org ' NEW_LINE Y = ' NewSite : GeeksQuiz . com ' NEW_LINE m = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE print ( ' Length ▁ of ▁ Longest ▁ Common ▁ Substring ▁ is ' , LCSubStr ( X , Y , m , n ) ) NEW_LINE"],"bleu":0.481326646851221,"rouge_l":0.6314943415637861}
{"id":1358,"predictions":["def getPassingCars ( A , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( A [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT if ( A [ i ] == 1 ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT A = [ 0 , 1 , 0 , 1 , 1 ] NEW_LINE n = len ( A ) NEW_LINE print ( getPassingCars ( A , n ) ) NEW_LINE"],"references":["def getPassingCars ( A , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 0 , n - 1 , 1 ) : NEW_LINE INDENT if ( A [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i + 1 , n , 1 ) : NEW_LINE INDENT if ( A [ j ] ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 0 , 1 , 0 , 1 , 1 ] NEW_LINE n = len ( A ) NEW_LINE print ( getPassingCars ( A , n ) ) NEW_LINE DEDENT"],"bleu":0.7642887660016795,"rouge_l":0.8636426116838488}
{"id":1359,"predictions":["class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT class LinkedList : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . head = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT defck ( self , head ) : NEW_LINE INDENT if head == None : NEW_LINE INDENT return head NEW_LINE DEDENT else : NEW_LINE INDENT return head NEW_LINE DEDENT DEDENT def push ( head , new_data ) : NEW_LINE INDENT new_ = head NEW_LINE while head : NEW_LINE INDENT head = head . next NEW_LINE if head == None : NEW_LINE INDENT new_node . next = head NEW_LINE return head NEW_LINE DEDENT new_node . next = head . next NEW_LINE head . next = head . prev NEW_LINE head = head NEW_LINE return head NEW_LINE DEDENT DEDENT def solve ( head ) : NEW_LINE INDENT head = new_node ( head ) NEW_LINE head = new_node ( head ) NEW_LINE return head NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT head = None NEW_LINE head = push ( head , head ) NEW_LINE head = head NEW_LINE head = push ( head , head ) NEW_LINE head = push ( head , head ) NEW_LINE head = push ( head , head ) NEW_LINE head = push ( head , head ) NEW_LINE head = push ( head , head ) NEW_LINE head = push ( head , head ) NEW_LINE return head NEW_LINE DEDENT"],"references":["class Node : NEW_LINE INDENT def __init__ ( self , next = None , prev = None , data = None ) : NEW_LINE INDENT self . next = next NEW_LINE self . prev = prev NEW_LINE self . data = data NEW_LINE DEDENT DEDENT"],"bleu":0.10092876543355349,"rouge_l":0.2566105769230769}
{"id":1360,"predictions":["def search ( arr , n , x ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == x ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 10 , 30 , 15 ] NEW_LINE x = 30 NEW_LINE n = len ( arr ) NEW_LINE find ( arr , n , x ) NEW_LINE DEDENT"],"references":["def search ( arr , n , x ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == x : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 1 , 10 , 30 , 15 ] NEW_LINE x = 30 NEW_LINE n = len ( arr ) NEW_LINE print ( x , \" is ▁ present ▁ at ▁ index \" , search ( arr , n , x ) ) NEW_LINE"],"bleu":0.7121450545637203,"rouge_l":0.809047965116279}
{"id":1361,"predictions":["def findKHCF ( x , y , k ) : NEW_LINE INDENT small = min ( x , y ) ; NEW_LINE count = 1 ; NEW_LINE for i in range ( 2 , small + 1 ) : NEW_LINE INDENT if ( x % i == 0 and y % i == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT if ( count == k ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT x = 4 ; NEW_LINE y = 24 ; NEW_LINE k = 3 ; NEW_LINE print ( findKHCF ( x , y , k ) ) ; NEW_LINE"],"references":["def findKHCF ( x , y , k ) : NEW_LINE INDENT small = min ( x , y ) NEW_LINE count = 1 NEW_LINE for i in range ( 2 , small + 1 ) : NEW_LINE INDENT if ( x % i == 0 and y % i == 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT if ( count == k ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT x = 4 NEW_LINE y = 24 NEW_LINE k = 3 NEW_LINE print ( findKHCF ( x , y , k ) ) NEW_LINE"],"bleu":0.7853859635180676,"rouge_l":0.9460924559554282}
{"id":1362,"predictions":["defdistance ( x , y , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT sum += ( abs ( x [ i ] - x [ j ] ) + abs ( y [ i ] - y [ j ] ) ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT x = [ - 1 , 3 , 5 ] NEW_LINE y = [ 5 , 6 , 3 ] NEW_LINE n = len ( x ) NEW_LINE print (distance ( x , y , n ) ) NEW_LINE"],"references":["def distancesum ( x , y , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT sum += ( abs ( x [ i ] - x [ j ] ) + abs ( y [ i ] - y [ j ] ) ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT x = [ - 1 , 1 , 3 , 2 ] NEW_LINE y = [ 5 , 6 , 5 , 3 ] NEW_LINE n = len ( x ) NEW_LINE print ( distancesum ( x , y , n ) ) NEW_LINE"],"bleu":0.893475633610283,"rouge_l":0.9443514644351464}
{"id":1363,"predictions":["month = [ 31 , 28 , 31 , 30 , 31 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 ] NEW_LINE def day ( year ) : NEW_LINE INDENT month = ( year ) NEW_LINE month . append ( year ) NEW_LINE if ( year % 4 == 0 and year % 100 == 0 ) : NEW_LINE INDENT month += 1 NEW_LINE DEDENT while ( month > 0 ) : NEW_LINE INDENT day = day % 10 NEW_LINE if ( day % 100 == 0 and year % 4 == 0 ) : NEW_LINE INDENT day = day + 1 NEW_LINE DEDENT if ( day % 4 == 0 and year % 30 == 0 ) : NEW_LINE INDENT day = day + 1 NEW_LINE DEDENT else : NEW_LINE INDENT day = day + day NEW_LINE DEDENT DEDENT return day NEW_LINE DEDENT day = day ( day - day ) NEW_LINE print ( day ( day ) ) NEW_LINE"],"references":["days = [ 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] ; NEW_LINE def dayOfYear ( date ) : NEW_LINE INDENT year = ( int ) ( date [ 0 : 4 ] ) ; NEW_LINE month = ( int ) ( date [ 5 : 7 ] ) ; NEW_LINE day = ( int ) ( date [ 8 : ] ) ; NEW_LINE if ( month > 2 and year % 4 == 0 and ( year % 100 != 0 or year % 400 == 0 ) ) : NEW_LINE INDENT day += 1 ; NEW_LINE DEDENT month -= 1 ; NEW_LINE while ( month > 0 ) : NEW_LINE INDENT day = day + days [ month - 1 ] ; NEW_LINE month -= 1 ; NEW_LINE DEDENT return day ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT date = \"2019-01-09\" ; NEW_LINE print ( dayOfYear ( date ) ) ; NEW_LINE DEDENT"],"bleu":0.3692124547629369,"rouge_l":0.5037249798043265}
{"id":1364,"predictions":["def isUnary ( n ) : NEW_LINE INDENT if ( n == 1 or n == 7 ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( n == 1 or n == 7 ) : NEW_LINE INDENT return False NEW_LINE DEDENT x = 0 NEW_LINE sum = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT x = n % 10 NEW_LINE sum = sum + x * x NEW_LINE n = n \/\/ 10 NEW_LINE DEDENT return isUnary ( sum ) NEW_LINE DEDENT def countUnary ( a , b ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT if ( isUnary ( i ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 1000 NEW_LINE b = 10 NEW_LINE print ( countUnary ( a , b ) ) NEW_LINE DEDENT"],"references":["def isUnary ( n ) : NEW_LINE INDENT if ( n == 1 or n == 7 ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( int ( n \/ 10 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT x = n % 10 NEW_LINE sum = sum + x * x NEW_LINE n = int ( n \/ 10 ) NEW_LINE DEDENT return isUnary ( sum ) NEW_LINE DEDENT def countUnary ( a , b ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( a , b + 1 , 1 ) : NEW_LINE INDENT if ( isUnary ( i ) == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 1000 NEW_LINE b = 1099 NEW_LINE print ( countUnary ( a , b ) ) NEW_LINE DEDENT"],"bleu":0.8524938329836351,"rouge_l":0.9211112186622785}
{"id":1365,"predictions":["def find_count ( arr ) : NEW_LINE INDENT return bin ( arr ) . count ( '1' ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE print ( find_count ( arr ) ) NEW_LINE DEDENT"],"references":["def bitsoncount ( x ) : NEW_LINE INDENT return bin ( x ) . count ( '1' ) NEW_LINE DEDENT def find_count ( arr ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in arr : NEW_LINE INDENT x = bitsoncount ( i ) NEW_LINE if ( i % x == 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE print ( find_count ( arr ) ) NEW_LINE"],"bleu":0.4119595446992207,"rouge_l":0.5937367752856538}
{"id":1366,"predictions":["MOD = 1000000007 NEW_LINE def product ( ar , n ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT result = ( result * ar [ i ] ) % MOD NEW_LINE DEDENT return result NEW_LINE DEDENT ar = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( ar ) NEW_LINE print ( product ( ar , n ) ) NEW_LINE"],"references":["MOD = 1000000007 NEW_LINE def product ( ar , n ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT result = ( result * ar [ i ] ) % MOD NEW_LINE DEDENT return result NEW_LINE DEDENT ar = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( ar ) NEW_LINE print ( product ( ar , n ) ) NEW_LINE"],"bleu":0.9562104553719303,"rouge_l":0.9897309509139454}
{"id":1367,"predictions":["from math import sqrt NEW_LINE MOD = 1000000007 NEW_LINE def SieveOfEratosthenes ( prime , p_size ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( sqrt ( p_size ) ) + 1 , 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( p_size , p_size + 1 , p_size + 1 ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def productPrimeFreq ( arr , n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) NEW_LINE SieveOfEratosthenes ( prime , n + 1 ) NEW_LINE mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if prime [ arr [ i ] ] : NEW_LINE INDENT prime [ arr [ i ] ] ] = False NEW_LINE DEDENT DEDENT product = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if prime [ arr [ i ] ] : NEW_LINE INDENT product *= ( prime [ arr [ i ] ] ) % MOD NEW_LINE product %= MOD NEW_LINE DEDENT DEDENT return product NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 5 , 4 , 6 , 5 , 4 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( productPrimeFreq ( arr , n ) ) NEW_LINE DEDENT"],"references":["MOD = 1000000007 NEW_LINE def SieveOfEratosthenes ( prime , p_size ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , p_size ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( 2 * p , p_size , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def productPrimeFreq ( arr , n ) : NEW_LINE INDENT prime = [ True for i in range ( n + 1 ) ] NEW_LINE SieveOfEratosthenes ( prime , n + 1 ) NEW_LINE i , j = 0 , 0 NEW_LINE m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT m [ arr [ i ] ] = m . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT product = 1 NEW_LINE for it in m : NEW_LINE INDENT if ( prime [ m [ it ] ] ) : NEW_LINE INDENT product *= it % MOD NEW_LINE product %= MOD NEW_LINE DEDENT DEDENT return product NEW_LINE DEDENT arr = [ 5 , 4 , 6 , 5 , 4 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( productPrimeFreq ( arr , n ) ) NEW_LINE"],"bleu":0.6682703510505956,"rouge_l":0.7878380196421364}
{"id":1368,"predictions":["def maxval ( a , n ) : NEW_LINE INDENT if n < 2 : NEW_LINE INDENT print ( \" Invalid ▁ Input \" ) NEW_LINE return - 99999 NEW_LINE DEDENT max1 = 0 NEW_LINE max2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = a [ i ] + i NEW_LINE if x > max1 : NEW_LINE INDENT max2 = max1 NEW_LINE max1 = x NEW_LINE DEDENT elif x > max2 : NEW_LINE INDENT max2 = x NEW_LINE max1 = x NEW_LINE DEDENT DEDENT return ( max1 * max2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 5 , 3 , 1 , 10 ] NEW_LINE len1 = len ( arr ) NEW_LINE n = len ( arr ) NEW_LINE print ( maxval ( arr , n ) ) NEW_LINE DEDENT"],"references":["def maxval ( a , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT print ( \" Invalid ▁ Input \" ) NEW_LINE return - 9999 NEW_LINE DEDENT ( max1 , max2 ) = ( 0 , 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = a [ i ] + i NEW_LINE if ( x > max1 ) : NEW_LINE INDENT max2 = max1 NEW_LINE max1 = x NEW_LINE DEDENT elif ( x > max2 and x != max1 ) : NEW_LINE INDENT max2 = x NEW_LINE DEDENT DEDENT return ( max1 * max2 ) NEW_LINE DEDENT print ( maxval ( [ 4 , 5 , 3 , 1 , 10 ] , 5 ) ) NEW_LINE"],"bleu":0.5972345693159289,"rouge_l":0.7680247060220929}
{"id":1369,"predictions":["class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def minPathSumUtil ( root , data ) : NEW_LINE INDENT if root == None : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( root . left == None and root . right == None ) : NEW_LINE INDENT return root NEW_LINE DEDENT ls = self . root NEW_LINE rs = None NEW_LINE return ls [ 0 ] NEW_LINE def minPathSumUtil ( root , left , right ) : NEW_LINE INDENT if ( root . left == None and root . right == None ) : NEW_LINE INDENT return root NEW_LINE DEDENT ls = minPathSumUtil ( root . left , data , left ) NEW_LINE if ( root . left != None and root . right == None ) : NEW_LINE INDENT return None NEW_LINE DEDENT ls = minPathSumUtil ( root . right , left , right ) NEW_LINE return rs + root . data NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 4 ) NEW_LINE root . left = newNode ( 2 ) NEW_LINE root . left = newNode ( 4 ) NEW_LINE root . left = newNode ( 2 ) NEW_LINE root . right = newNode ( 4 ) NEW_LINE root . left . right = newNode ( 5 ) NEW_LINE root . left . right = newNode ( 8 ) NEW_LINE root . left . left = newNode ( 8 ) NEW_LINE root . left . right = newNode ( 1 ) NEW_LINE root . right . left . right = newNode ( 1 ) NEW_LINE root . right . left = newNode ( 2 ) NEW_LINE root . right . left = newNode ( 3 ) NEW_LINE root . right . left . left = newNode ( 4 ) NEW_LINE root . right . left . right = newNode ( 8 ) NEW_LINE root . right . right = newNode ( 1 ) NEW_LINE return path NEW_LINE DEDENT if __name__ == '"],"references":["class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def newNode ( data ) : NEW_LINE INDENT node = Node ( 0 ) NEW_LINE node . data = data NEW_LINE node . left = node . right = None NEW_LINE return ( node ) NEW_LINE DEDENT result = - 1 NEW_LINE def minPathSumUtil ( root ) : NEW_LINE INDENT global result NEW_LINE if ( root == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( root . left == None and root . right == None ) : NEW_LINE INDENT return root . data NEW_LINE DEDENT ls = minPathSumUtil ( root . left ) NEW_LINE rs = minPathSumUtil ( root . right ) NEW_LINE if ( root . left != None and root . right != None ) : NEW_LINE INDENT result = min ( result , ls + rs + root . data ) NEW_LINE return min ( ls + root . data , rs + root . data ) NEW_LINE DEDENT if ( root . left == None ) : NEW_LINE INDENT return rs + root . data NEW_LINE DEDENT else : NEW_LINE INDENT return ls + root . data NEW_LINE DEDENT DEDENT def minPathSum ( root ) : NEW_LINE INDENT global result NEW_LINE result = 9999999 NEW_LINE minPathSumUtil ( root ) NEW_LINE return result NEW_LINE DEDENT root = newNode ( 4 ) NEW_LINE root . left = newNode ( 5 ) NEW_LINE root . right = newNode ( - 6 ) NEW_LINE root . left . left = newNode ( 2 ) NEW_LINE root . left . right = newNode ( - 3 ) NEW_LINE root . right . left = newNode ( 1 ) NEW_LINE root . right . right = newNode ( 8 ) NEW_LINE print ( minPathSum ( root ) ) NEW_LINE"],"bleu":0.567675314162423,"rouge_l":0.6258369057367179}
{"id":1370,"predictions":["def andOperations ( a , b ) : NEW_LINE INDENT while ( a < b ) : NEW_LINE INDENT b -= ( ( b & - a ) ) NEW_LINE DEDENT return b NEW_LINE DEDENT a = 10 NEW_LINE b = 15 NEW_LINE print ( andOperations ( a , b ) ) NEW_LINE"],"references":["def andOperator ( a , b ) : NEW_LINE INDENT while ( a < b ) : NEW_LINE INDENT b -= ( b & - b ) NEW_LINE DEDENT return b NEW_LINE DEDENT a , b = 10 , 15 NEW_LINE print ( andOperator ( a , b ) ) NEW_LINE"],"bleu":0.7073410619648284,"rouge_l":0.8683960771907625}
{"id":1371,"predictions":["def __gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return b NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT return result NEW_LINE DEDENT def countprimalityRoots ( p - 1 ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 2 , p ) : NEW_LINE INDENT if ( __gcd ( i , p ) == 1 ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT p = 5 NEW_LINE print ( countprimalityRoots ( p - 1 ) ) NEW_LINE"],"references":["from math import gcd NEW_LINE def countPrimitiveRoots ( p ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 2 , p , 1 ) : NEW_LINE INDENT if ( gcd ( i , p ) == 1 ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT p = 5 NEW_LINE print ( countPrimitiveRoots ( p - 1 ) ) NEW_LINE DEDENT"],"bleu":0.34706859525165923,"rouge_l":0.5275295474200058}
{"id":1372,"predictions":["def printPattern ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , 2 * n ) : NEW_LINE INDENT if j == ( n - i + 1 ) or j == ( n - i + 1 ) : NEW_LINE INDENT print ( \" * \" , end = \" ▁ \" ) ; NEW_LINE DEDENT elif ( ( i >= 4 ) and j >= n - 4 ) : NEW_LINE INDENT print ( \" * \" , end = \" ▁ \" ) ; NEW_LINE DEDENT elif ( ( i >= 4 ) and ( j >= n - 4 ) and j <= n - 4 * n - 4 ) : NEW_LINE INDENT print ( \" * \" , end = \" ▁ \" ) ; NEW_LINE DEDENT elif ( i == ( n - 4 * i + 4 ) and j >= n - 4 * n - 4 ) : NEW_LINE INDENT print ( \" * \" , end = \" ▁ \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" ▁ \" , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT print ( ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 9 ; NEW_LINE printPattern ( N ) ; NEW_LINE DEDENT"],"references":["def printPattern ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , 2 * n ) : NEW_LINE INDENT if ( j == ( n - i + 1 ) or j == ( n + i - 1 ) ) : NEW_LINE INDENT print ( \" * ▁ \" , end = \" \" ) NEW_LINE DEDENT elif ( ( i >= 4 and i <= n - 4 ) and ( j == n - i + 4 or j == n + i - 4 ) ) : NEW_LINE INDENT print ( \" * ▁ \" , end = \" \" ) NEW_LINE DEDENT elif ( i == n or ( i == n - 4 and j >= n - ( n - 2 * 4 ) and j <= n + n - 2 * 4 ) ) : NEW_LINE INDENT print ( \" * ▁ \" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" ▁ \" + \" ▁ \" , end = \" \" ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT N = 9 NEW_LINE printPattern ( N ) NEW_LINE"],"bleu":0.5881591515306188,"rouge_l":0.7733265720081135}
{"id":1373,"predictions":["def printOrder ( arr , n , k ) : NEW_LINE INDENT len1 = k NEW_LINE len2 = n - k NEW_LINE arr1 = [ 0 ] * k NEW_LINE arr2 = [ 0 ] * n - k NEW_LINE for i in range ( k ) : NEW_LINE INDENT arr1 [ i ] = arr1 [ i ] NEW_LINE arr2 [ i ] = arr2 [ i ] NEW_LINE DEDENT arr1 . sort ( ) NEW_LINE for i in range ( k , n - k ) : NEW_LINE INDENT if ( i < k ) : NEW_LINE INDENT arr1 [ i ] = arr1 [ i ] NEW_LINE arr2 [ i ] = arr2 [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT arr1 [ i ] = arr1 [ i ] NEW_LINE arr2 [ i ] = arr2 [ i ] NEW_LINE DEDENT DEDENT for i in range ( k ) : NEW_LINE INDENT print ( arr1 [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 5 , 4 , 6 , 2 , 1 , 3 , 8 , 9 , - 1 ] NEW_LINE n = len ( arr ) NEW_LINE k = 4 NEW_LINE printOrder ( arr , n , k ) NEW_LINE DEDENT"],"references":["def printOrder ( arr , n , k ) : NEW_LINE INDENT len1 = k NEW_LINE len2 = n - k NEW_LINE arr1 = [ 0 ] * k NEW_LINE arr2 = [ 0 ] * ( n - k ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT arr1 [ i ] = arr [ i ] NEW_LINE DEDENT for i in range ( k , n ) : NEW_LINE INDENT arr2 [ i - k ] = arr [ i ] NEW_LINE DEDENT arr1 . sort ( ) NEW_LINE arr2 . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i < k ) : NEW_LINE INDENT arr [ i ] = arr1 [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = arr2 [ len2 - 1 ] NEW_LINE len2 -= 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 5 , 4 , 6 , 2 , 1 , 3 , 8 , 9 , - 1 ] NEW_LINE k = 4 NEW_LINE n = len ( arr ) NEW_LINE printOrder ( arr , n , k ) NEW_LINE DEDENT"],"bleu":0.777100862459521,"rouge_l":0.8356164383561644}
{"id":1374,"predictions":["def isMaxPossible ( arr , n ) : NEW_LINE INDENT mp = { i : 0 for i in } NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT m = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( mp [ arr [ i ] ] & 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( mp [ arr [ i ] ] & 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT arr = [ 1 , 1 , 1 , 2 , 2 , 2 , 2 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE if ( isMaxPossible ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def isPlusPossible ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] = mp . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT foundModOne = False NEW_LINE for x in mp : NEW_LINE INDENT element = x NEW_LINE frequency = mp [ x ] NEW_LINE if ( frequency % 4 == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( frequency % 4 == 1 ) : NEW_LINE INDENT if ( foundModOne == True ) : NEW_LINE INDENT return False NEW_LINE DEDENT foundModOne = True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT arr = [ 1 , 1 , 1 , 1 , 2 , 2 , 2 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE if ( isPlusPossible ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.5853371604869452,"rouge_l":0.6927301498650283}
{"id":1375,"predictions":["def sumOfAP ( a , d , n ) : NEW_LINE INDENT sum = ( n \/ 2 ) * ( 2 * a + ( n - 1 ) ) * d NEW_LINE return ( sum ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 20 NEW_LINE a = 1.5 NEW_LINE d = 1.5 NEW_LINE print ( sumOfAP ( a , d , n ) ) NEW_LINE DEDENT"],"references":["def sumOfAP ( a , d , n ) : NEW_LINE INDENT sum = ( n \/ 2 ) * ( 2 * a + ( n - 1 ) * d ) NEW_LINE return sum NEW_LINE DEDENT n = 20 NEW_LINE a = 2.5 NEW_LINE d = 1.5 NEW_LINE print ( sumOfAP ( a , d , n ) ) NEW_LINE"],"bleu":0.6787980323063758,"rouge_l":0.8751793400286944}
{"id":1376,"predictions":["import math NEW_LINE def isPerfectSquare ( num ) : NEW_LINE INDENT n = int ( math . sqrt ( num ) ) NEW_LINE return ( n * n == num ) NEW_LINE DEDENT def checkFib ( array , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( isPerfectSquare ( 5 * array [ i ] + 4 ) or isPerfectSquare ( 5 * array [ i ] ) ) : NEW_LINE INDENT print ( array [ i ] , end = \" ▁ \" ) NEW_LINE count += 1 NEW_LINE DEDENT DEDENT if ( count == 0 ) : NEW_LINE INDENT print ( array [ count ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT array = [ 4 , 2 , 8 , 5 , 20 , 23 ] NEW_LINE n = len ( array ) NEW_LINE checkFib ( array , n ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def isPerfectSquare ( num ) : NEW_LINE INDENT n = int ( math . sqrt ( num ) ) NEW_LINE return ( n * n == num ) NEW_LINE DEDENT def checkFib ( array , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( isPerfectSquare ( 5 * array [ i ] * array [ i ] + 4 ) or isPerfectSquare ( 5 * array [ i ] * array [ i ] - 4 ) ) : NEW_LINE INDENT print ( array [ i ] , \" ▁ \" , end = \" \" ) ; NEW_LINE count = count + 1 NEW_LINE DEDENT DEDENT if ( count == 0 ) : NEW_LINE INDENT print ( \" None ▁ present \" ) ; NEW_LINE DEDENT DEDENT array = [ 4 , 2 , 8 , 5 , 20 , 1 , 40 , 13 , 23 ] NEW_LINE n = len ( array ) NEW_LINE checkFib ( array , n ) NEW_LINE"],"bleu":0.780328212980469,"rouge_l":0.8496610641656607}
{"id":1377,"predictions":["from math import sqrt NEW_LINE def largestCube ( r ) : NEW_LINE INDENT if ( r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = ( ( 2 * r ) \/ ( 2 * sqrt ( 3 ) ) ) NEW_LINE return a NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT r = 5 NEW_LINE print ( largestCube ( r ) ) NEW_LINE DEDENT"],"references":["from math import sqrt NEW_LINE def largestCube ( r ) : NEW_LINE INDENT if ( r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = ( 2 * r ) \/ sqrt ( 3 ) NEW_LINE return a NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT r = 5 NEW_LINE print ( \" { 0 : . 6 } \" . format ( largestCube ( r ) ) ) NEW_LINE DEDENT"],"bleu":0.8144432635385319,"rouge_l":0.8800494641384996}
{"id":1378,"predictions":["def countTwatypes ( a , b ) : NEW_LINE INDENT n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE if ( m == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT dp = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = ( a [ i ] [ j ] + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( a [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j ] + 1 ) NEW_LINE DEDENT DEDENT elif ( b [ i ] == b [ i ] ) : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i ] [ j ] + 1 ) NEW_LINE DEDENT elif ( dp [ i ] [ j ] == b ) : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT return dp [ m - 1 ] [ n - 1 ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = \" abcccdd \" NEW_LINE b = \" abcddcdd \" NEW_LINE print ( countTwc transformations ( a , b ) ) NEW_LINE DEDENT"],"references":["def countTransformation ( a , b ) : NEW_LINE INDENT n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE if m == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT dp = [ [ 0 ] * ( n ) for _ in range ( m ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT if j == 0 : NEW_LINE INDENT if a [ j ] == b [ i ] : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT elif a [ j ] == b [ i ] : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if a [ j ] == b [ i ] : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT return dp [ m - 1 ] [ n - 1 ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = \" abcccdf \" NEW_LINE b = \" abccdf \" NEW_LINE print ( countTransformation ( a , b ) ) NEW_LINE DEDENT"],"bleu":0.6748887532907673,"rouge_l":0.7767720159558146}
{"id":1379,"predictions":["def findOneElements ( arr , n , X ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT mp [ arr [ i ] ] = arr [ j ] + arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] [ j ] != arr [ i ] [ j ] ) : NEW_LINE INDENT mp [ arr [ i ] [ j ] ] = mp [ arr [ i ] [ j ] ] NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in mp : NEW_LINE INDENT print ( arr [ i ] , \" , ▁ \" , end = \" \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 10 , 20 , 30 , 40 , 1 ] NEW_LINE X = 90 NEW_LINE n = len ( arr ) NEW_LINE findTwoElements ( arr , n , X ) NEW_LINE DEDENT"],"references":["def findFourElements ( arr , n , X ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT mp [ arr [ i ] + arr [ j ] ] = [ i , j ] NEW_LINE DEDENT DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT summ = arr [ i ] + arr [ j ] NEW_LINE if ( X - summ ) in mp : NEW_LINE INDENT p = mp [ X - summ ] NEW_LINE if ( p [ 0 ] != i and p [ 0 ] != j and p [ 1 ] != i and p [ 1 ] != j ) : NEW_LINE INDENT print ( arr [ i ] , \" , ▁ \" , arr [ j ] , \" , ▁ \" , arr [ p [ 0 ] ] , \" , ▁ \" , arr [ p [ 1 ] ] , sep = \" \" ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT arr = [ 10 , 20 , 30 , 40 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE X = 91 NEW_LINE findFourElements ( arr , n , X ) NEW_LINE"],"bleu":0.5902963912081857,"rouge_l":0.6760076233500388}
{"id":1380,"predictions":["def countWays ( n ) : NEW_LINE INDENT counter = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT for k in range ( j , n ) : NEW_LINE INDENT if i + k + j + k == n : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return counter NEW_LINE DEDENT n = 8 NEW_LINE print ( countWays ( n ) ) NEW_LINE"],"references":["def countWays ( n ) : NEW_LINE INDENT counter = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT for k in range ( j , n ) : NEW_LINE INDENT for l in range ( k , n ) : NEW_LINE INDENT if ( i + j + k + l == n ) : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return counter NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 8 NEW_LINE print ( countWays ( n ) ) NEW_LINE DEDENT"],"bleu":0.64778004417601,"rouge_l":0.8128110451115749}
{"id":1381,"predictions":["def maxConsecutiveOnes ( x ) : NEW_LINE INDENT count = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT x = ( x & ( x << 1 ) ) NEW_LINE count = count + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT print ( maxConsecutiveOnes ( 14 ) ) NEW_LINE print ( maxConsecutiveOnes ( 14 ) ) NEW_LINE"],"references":["def maxConsecutiveOnes ( x ) : NEW_LINE INDENT count = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT x = ( x & ( x << 1 ) ) NEW_LINE count = count + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT print ( maxConsecutiveOnes ( 14 ) ) NEW_LINE print ( maxConsecutiveOnes ( 222 ) ) NEW_LINE"],"bleu":0.9574144657807024,"rouge_l":0.9833333333333334}
{"id":1382,"predictions":["def isFruits ( num ) : NEW_LINE INDENT freq = [ 0 ] * 10 NEW_LINE val = num + num * 2 + num NEW_LINE for i in range ( len ( num ) ) : NEW_LINE INDENT digit = ord ( num [ i ] ) - ord ( '0' ) NEW_LINE if ( freq [ i ] > 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT freq [ ord ( num [ i ] ) - ord ( '0' ) ] += 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , len ( num ) ) : NEW_LINE INDENT if ( freq [ i ] == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT freq [ ord ( num [ i ] ) ] += 1 NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT num = 97 NEW_LINE if ( isFruits ( num ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def isFascinating ( num ) : NEW_LINE INDENT freq = [ 0 ] * 10 NEW_LINE val = ( str ( num ) + str ( num * 2 ) + str ( num * 3 ) ) NEW_LINE for i in range ( len ( val ) ) : NEW_LINE INDENT digit = int ( val [ i ] ) NEW_LINE if freq [ digit ] > 0 : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT freq [ digit ] += 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , 10 ) : NEW_LINE INDENT if freq [ i ] == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT num = 192 NEW_LINE if num < 100 : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = isFascinating ( num ) NEW_LINE if ans : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT DEDENT"],"bleu":0.6336547760889983,"rouge_l":0.7534071550255538}
{"id":1383,"predictions":["def printDistinct ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT if ( i == j ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 6 , 10 , 5 , 4 , 9 , 120 , 4 , 6 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE printDistinct ( arr , n ) ; NEW_LINE"],"references":["def printDistinct ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT d = 0 NEW_LINE for j in range ( 0 , i ) : NEW_LINE INDENT if ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT d = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( d == 0 ) : NEW_LINE INDENT print ( arr [ i ] ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 6 , 10 , 5 , 4 , 9 , 120 , 4 , 6 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE printDistinct ( arr , n ) NEW_LINE"],"bleu":0.7618981694739225,"rouge_l":0.8786366229321164}
{"id":1384,"predictions":["def closestMultiple ( n , x ) : NEW_LINE INDENT if ( x > n ) : NEW_LINE INDENT return x ; NEW_LINE DEDENT n = int ( n + x \/ 2 ) ; NEW_LINE n = n - ( n % x ) ; NEW_LINE return n ; NEW_LINE DEDENT n = 56 ; x = 27 ; NEW_LINE print ( closestMultiple ( n , x ) ) ; NEW_LINE"],"references":["def closestMultiple ( n , x ) : NEW_LINE INDENT if x > n : NEW_LINE INDENT return x ; NEW_LINE DEDENT z = ( int ) ( x \/ 2 ) ; NEW_LINE n = n + z ; NEW_LINE n = n - ( n % x ) ; NEW_LINE return n ; NEW_LINE DEDENT n = 56287 ; NEW_LINE x = 27 ; NEW_LINE print ( closestMultiple ( n , x ) ) ; NEW_LINE"],"bleu":0.7440475936504387,"rouge_l":0.8736979166666665}
{"id":1385,"predictions":["MAX = 1000 NEW_LINE def maxSubsequence ( x , y , n , m ) : NEW_LINE INDENT dp = [ [ [ 0 for x in range ( MAX ) ] for y in range ( MAX ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( x [ i - 1 ] == y [ i ] ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT ans = max ( ans , dp [ i ] [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def nextSubsequence ( x , y , n , m ) : NEW_LINE INDENT ans = maxSubsequence ( x , y , n , m ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = [ ABCDMAX ] NEW_LINE y = [ print ( main ( ) ) NEW_LINE DEDENT"],"references":["MAX = 1000 NEW_LINE def maxSubsequenceSubstring ( x , y , n , m ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( MAX ) ] for i in range ( MAX ) ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( x [ j - 1 ] == y [ i - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT ans = max ( ans , dp [ i ] [ n ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT x = \" ABCD \" NEW_LINE y = \" BACDBDCD \" NEW_LINE n = len ( x ) NEW_LINE m = len ( y ) NEW_LINE print ( maxSubsequenceSubstring ( x , y , n , m ) ) NEW_LINE"],"bleu":0.7060676211598548,"rouge_l":0.8063243993281239}
{"id":1386,"predictions":["import math NEW_LINE def findMaxGCD ( arr , n , k ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE high = arr [ n - 1 ] NEW_LINE divisors = [ 0 ] * ( high + 1 ) NEW_LINE divisors [ 0 ] = arr [ n - 1 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT j = 1 NEW_LINE while ( j <= math . sqrt ( arr [ j ] ) ) : NEW_LINE INDENT if ( arr [ i ] % j == 0 ) : NEW_LINE INDENT divisors [ arr [ i ] ] += 1 NEW_LINE if ( j != arr [ j ] \/\/ j ) : NEW_LINE INDENT divisors [ arr [ i ] \/\/ j ] += 1 NEW_LINE DEDENT DEDENT DEDENT if ( divisors [ arr [ i ] \/\/ j ] ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT arr = [ 1 , 2 , 4 , 8 , 12 , 12 ] NEW_LINE k = 3 NEW_LINE n = len ( arr ) NEW_LINE print ( findMaxGCD ( arr , n , k ) ) NEW_LINE"],"references":["import math NEW_LINE def findMaxGCD ( arr , n , k ) : NEW_LINE INDENT high = max ( arr ) NEW_LINE divisors = [ 0 ] * ( high + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 1 , int ( math . sqrt ( arr [ i ] ) ) + 1 ) : NEW_LINE INDENT if ( arr [ i ] % j == 0 ) : NEW_LINE INDENT divisors [ j ] += 1 NEW_LINE if ( j != arr [ i ] \/\/ j ) : NEW_LINE INDENT divisors [ arr [ i ] \/\/ j ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( high , 0 , - 1 ) : NEW_LINE INDENT if ( divisors [ i ] >= k ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 8 , 8 , 12 ] NEW_LINE k = 3 NEW_LINE n = len ( arr ) NEW_LINE print ( findMaxGCD ( arr , n , k ) ) NEW_LINE DEDENT"],"bleu":0.7039461187102177,"rouge_l":0.7669902912621359}
{"id":1387,"predictions":["def Max_Sum ( n ) : NEW_LINE INDENT return ( n * ( n - 1 ) \/\/ 2 ) NEW_LINE DEDENT n = 8 NEW_LINE print ( Max_Sum ( n ) ) NEW_LINE"],"references":["def Max_Sum ( n ) : NEW_LINE INDENT return ( n * ( n - 1 ) ) \/\/ 2 ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 8 ; NEW_LINE print ( Max_Sum ( n ) ) ; NEW_LINE DEDENT"],"bleu":0.4786045896808437,"rouge_l":0.7494415487714075}
{"id":1388,"predictions":["dp = [ [ - 1 for col in range ( 1000 ) ] for col in range ( 1000 ) ] NEW_LINE def countRec ( digits , e , isOdd ) : NEW_LINE INDENT if ( digits == n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( e == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( lookup [ d ] [ e ] != - 1 ) : NEW_LINE INDENT return lookup [ d ] [ e ] NEW_LINE DEDENT if ( isOdd == 1 ) : NEW_LINE INDENT return lookup [ d ] [ e ] != - 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 9999 ) : NEW_LINE INDENT ans += countRec ( digits [ i ] + i , e , o ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += countRec ( digits [ i ] , e , osum + i , osum + i , n ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def finalCount ( n ) : NEW_LINE INDENT digits = [ 0 for i in range ( 100 ) ] NEW_LINE for i in range ( 0 , 100 ) : NEW_LINE INDENT for j in range ( i , 2 ) : NEW_LINE INDENT ans += countRec ( digits + i , e , e , o ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE print ( \" Count ▁ of ▁ \" , finalCount ( n ) ) NEW_LINE DEDENT"],"references":["def countRec ( digits , esum , osum , isOdd , n ) : NEW_LINE INDENT if digits == n : NEW_LINE INDENT return ( esum - osum == 1 ) NEW_LINE DEDENT if lookup [ digits ] [ esum ] [ osum ] [ isOdd ] != - 1 : NEW_LINE INDENT return lookup [ digits ] [ esum ] [ osum ] [ isOdd ] NEW_LINE DEDENT ans = 0 NEW_LINE if isOdd : NEW_LINE INDENT for i in range ( 10 ) : NEW_LINE INDENT ans += countRec ( digits + 1 , esum , osum + i , False , n ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( 10 ) : NEW_LINE INDENT ans += countRec ( digits + 1 , esum + i , osum , True , n ) NEW_LINE DEDENT DEDENT lookup [ digits ] [ esum ] [ osum ] [ isOdd ] = ans NEW_LINE return ans NEW_LINE DEDENT def finalCount ( n ) : NEW_LINE INDENT global lookup NEW_LINE digits = 0 NEW_LINE lookup = [ [ [ [ - 1 , - 1 ] for i in range ( 500 ) ] for j in range ( 500 ) ] for k in range ( 50 ) ] NEW_LINE ans = 0 NEW_LINE esum = 0 NEW_LINE osum = 0 NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT ans += countRec ( digits + 1 , esum + i , osum , True , n ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT lookup = [ ] NEW_LINE n = 3 NEW_LINE print ( \" Count ▁ of ▁ % d ▁ digit ▁ numbers ▁ is ▁ % d \" % ( n , finalCount ( n ) ) ) NEW_LINE DEDENT"],"bleu":0.4370683863022484,"rouge_l":0.5970198493429373}
{"id":1389,"predictions":["def lcsOf3 ( X , Y , z , m , n , o ) : NEW_LINE INDENT L = [ [ 0 for x in range ( n + 1 ) ] for y in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT L [ i ] [ j ] = 0 NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j ] and k == 0 ) : NEW_LINE INDENT L [ i ] [ j ] = 0 NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] and ( X [ i ] == Y [ j - 1 ] ) ) : NEW_LINE INDENT L [ i ] [ j ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return L [ m ] [ n ] NEW_LINE DEDENT def lcs ( X , Y , Z , m , n , o ) : NEW_LINE INDENT M = [ [ 0 for i in range ( n + 1 ) ] for j in range ( m + 1 ) ] NEW_LINE return Lcs ( X , Y , z , m , n , o ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT X = \" AGGTA \" NEW_LINE Y = [ [ 12 , 12 ] , [ 0 for j in range ( m + 1 ) ] NEW_LINE m = len ( X ) NEW_LINE z = len ( Y ) NEW_LINE lcs = len ( Y , Z ) NEW_LINE print ( \" Length ▁ of ▁ LCS ▁ is \" , lcs ( X , Y , z , m , n , o ) ) NEW_LINE DEDENT"],"references":["def lcsOf3 ( X , Y , Z , m , n , o ) : NEW_LINE INDENT L = [ [ [ 0 for i in range ( o + 1 ) ] for j in range ( n + 1 ) ] for k in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT for k in range ( o + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 or k == 0 ) : NEW_LINE INDENT L [ i ] [ j ] [ k ] = 0 NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] and X [ i - 1 ] == Z [ k - 1 ] ) : NEW_LINE INDENT L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] [ k ] = max ( max ( L [ i - 1 ] [ j ] [ k ] , L [ i ] [ j - 1 ] [ k ] ) , L [ i ] [ j ] [ k - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return L [ m ] [ n ] [ o ] NEW_LINE DEDENT X = ' AGGT12' NEW_LINE Y = '12TXAYB ' NEW_LINE Z = '12XBA ' NEW_LINE m = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE o = len ( Z ) NEW_LINE print ( ' Length ▁ of ▁ LCS ▁ is ' , lcsOf3 ( X , Y , Z , m , n , o ) ) NEW_LINE"],"bleu":0.6180256951096723,"rouge_l":0.6702977832746645}
{"id":1390,"predictions":["import math NEW_LINE def printGreater ( x , y ) : NEW_LINE INDENT X = y * math . log ( x ) ; NEW_LINE Y = x * math . log ( y ) ; NEW_LINE if ( abs ( X - Y ) < 1e9 ) : NEW_LINE INDENT print ( \" Equal \" ) ; NEW_LINE DEDENT elif ( X > Y ) : NEW_LINE INDENT print ( \" Equal \" ) ; NEW_LINE DEDENT elif ( X > Y ) : NEW_LINE INDENT print ( \" ^ \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Equal \" ) ; NEW_LINE DEDENT DEDENT DEDENT x = 5 ; NEW_LINE y = 8 ; NEW_LINE printGreater ( x , y ) ; NEW_LINE"],"references":["import math NEW_LINE def printGreater ( x , y ) : NEW_LINE INDENT X = y * math . log ( x ) ; NEW_LINE Y = x * math . log ( y ) ; NEW_LINE if ( abs ( X - Y ) < 1e-9 ) : NEW_LINE INDENT print ( \" Equal \" ) ; NEW_LINE DEDENT elif ( X > Y ) : NEW_LINE INDENT print ( x , \" ^ \" , y ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( y , \" ^ \" , x ) ; NEW_LINE DEDENT DEDENT x = 5 ; NEW_LINE y = 8 ; NEW_LINE printGreater ( x , y ) ; NEW_LINE"],"bleu":0.7745924521299042,"rouge_l":0.881573665194701}
{"id":1391,"predictions":["def getElement ( a , n , S ) : NEW_LINE INDENT a . sort ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if sum + ( a [ i ] * ( n - i ) == S ) : NEW_LINE INDENT return a [ i ] NEW_LINE DEDENT sum += a [ i ] NEW_LINE DEDENT return - 1 NEW_LINE DEDENT S = 5 NEW_LINE a = [ 1 , 3 , 2 , 5 , 8 ] NEW_LINE n = len ( a ) NEW_LINE S = [ 1 , 3 , 2 , 5 , 8 ] NEW_LINE print ( getElement ( a , n , S ) ) NEW_LINE"],"references":["def getElement ( a , n , S ) : NEW_LINE INDENT a . sort ( ) ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( sum + ( a [ i ] * ( n - i ) ) == S ) : NEW_LINE INDENT return a [ i ] ; NEW_LINE DEDENT sum += a [ i ] ; NEW_LINE DEDENT return - 1 ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = 5 ; NEW_LINE a = [ 1 , 3 , 2 , 5 , 8 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( getElement ( a , n , S ) ) ; NEW_LINE DEDENT"],"bleu":0.6832345959480187,"rouge_l":0.841752120521585}
{"id":1392,"predictions":["def canMakeEqual ( a , n ) : NEW_LINE INDENT for i in range ( 0 , n , 1 , 1 ) : NEW_LINE INDENT while ( a [ i ] % 5 == 0 ) : NEW_LINE INDENT a [ i ] \/\/= 5 ; NEW_LINE a [ i ] \/\/= 5 ; NEW_LINE DEDENT DEDENT DEDENT def canMakeEqual ( arr , n ) : NEW_LINE INDENT for i in range ( 1 , n , 1 ) : NEW_LINE INDENT if ( a [ i ] != last ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 18 , 30 , 34 , 90 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE if ( canMakeEqual ( arr , n ) ) : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE DEDENT DEDENT"],"references":["def canMakeEqual ( a , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT while ( a [ i ] % 5 == 0 ) : NEW_LINE INDENT a [ i ] \/\/= 5 ; NEW_LINE DEDENT while ( a [ i ] % 3 == 0 ) : NEW_LINE INDENT a [ i ] \/\/= 3 ; NEW_LINE DEDENT DEDENT last = a [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( a [ i ] != last ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 18 , 30 , 54 , 90 , 162 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE if ( canMakeEqual ( arr , n ) ) : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE DEDENT DEDENT"],"bleu":0.814795516502782,"rouge_l":0.8681480121200991}
{"id":1393,"predictions":["x = 10 NEW_LINE y = 5 NEW_LINE x = x ^ y NEW_LINE y = x ^ y ; NEW_LINE x = x ^ y ; NEW_LINE y = x ^ y ; NEW_LINE D = x ^ y ; NEW_LINE x = x ^ y ; NEW_LINE print ( \" After ▁ swap ( \" , x , \" , ▁ \" , y ) ) NEW_LINE"],"references":["x = 10 NEW_LINE y = 5 NEW_LINE x = x ^ y ; NEW_LINE y = x ^ y ; NEW_LINE x = x ^ y ; NEW_LINE print ( \" After ▁ Swapping : ▁ x ▁ = ▁ \" , x , \" ▁ y ▁ = \" , y ) NEW_LINE"],"bleu":0.6043103970687612,"rouge_l":0.7408906882591093}
{"id":1394,"predictions":["def minimumOperations ( a , n ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( mp [ a [ i ] ] != 0 ) : NEW_LINE INDENT mp [ a [ i ] ] += 1 NEW_LINE mp [ a [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ a [ i ] ] += 1 NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for x in mp : NEW_LINE INDENT if ( mp [ x ] > 1 ) : NEW_LINE INDENT count += ( mp [ x ] - 1 ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT a = [ 2 , 1 , 2 , 3 , 3 , 4 , 3 ] NEW_LINE n = len ( a ) NEW_LINE print ( minimumOperations ( a , n ) ) NEW_LINE"],"references":["def minimumOperations ( a , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] in mp . keys ( ) : NEW_LINE INDENT mp [ a [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ a [ i ] ] = 1 NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for it in mp : NEW_LINE INDENT if ( mp [ it ] > 1 ) : NEW_LINE INDENT count += mp [ it ] - 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT a = [ 2 , 1 , 2 , 3 , 3 , 4 , 3 ] NEW_LINE n = len ( a ) NEW_LINE print ( minimumOperations ( a , n ) ) NEW_LINE"],"bleu":0.7596526742111012,"rouge_l":0.8832579185520363}
{"id":1395,"predictions":["def xorRange ( pre , l , r ) : NEW_LINE INDENT cntOnes = pre [ r ] NEW_LINE if ( l - 1 >= 0 ) : NEW_LINE INDENT cntOnes = pre [ l - 1 ] NEW_LINE if ( cntOnes ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT if ( cntOnes % 2 == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT def performQueries ( queries , q , a , n ) : NEW_LINE INDENT pre = [ 0 ] * n NEW_LINE pre [ 0 ] = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT pre [ i ] = pre [ i - 1 ] + a [ i ] NEW_LINE DEDENT for i in range ( q ) : NEW_LINE INDENT print ( xorRange ( queries [ i ] , queries [ i ] , queries [ i ] [ 1 ] ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT queries = [ [ 1 , 3 , 1 ] , [ 0 , 2 , 1 ] ] NEW_LINE q = len ( queries ) NEW_LINE performQueries ( queries , q , a , n ) NEW_LINE DEDENT"],"references":["def xorRange ( pre , l , r ) : NEW_LINE INDENT cntOnes = pre [ r ] NEW_LINE if ( l - 1 >= 0 ) : NEW_LINE INDENT cntOnes -= pre [ l - 1 ] NEW_LINE DEDENT if ( cntOnes % 2 == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT def performQueries ( queries , q , a , n ) : NEW_LINE INDENT pre = [ 0 for i in range ( n ) ] NEW_LINE pre [ 0 ] = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT pre [ i ] = pre [ i - 1 ] + a [ i ] NEW_LINE DEDENT for i in range ( q ) : NEW_LINE INDENT print ( xorRange ( pre , queries [ i ] [ 0 ] , queries [ i ] [ 1 ] ) ) NEW_LINE DEDENT DEDENT a = [ 1 , 0 , 1 , 1 , 0 , 1 , 1 ] NEW_LINE n = len ( a ) NEW_LINE queries = [ [ 0 , 3 ] , [ 0 , 2 ] ] NEW_LINE q = len ( queries ) NEW_LINE performQueries ( queries , q , a , n ) NEW_LINE"],"bleu":0.7741246076509125,"rouge_l":0.8301697586132798}
{"id":1396,"predictions":["def countNums ( n , x , y ) : NEW_LINE INDENT arr = [ False ] * ( n + 1 ) ; NEW_LINE if ( x <= n ) : NEW_LINE INDENT arr [ x ] = True ; NEW_LINE DEDENT result = 0 ; NEW_LINE for i in range ( min ( x , y + 1 ) , 1 ) : NEW_LINE INDENT if ( i + x <= n ) : NEW_LINE INDENT arr [ i + x ] = True ; NEW_LINE DEDENT if ( i + y <= n ) : NEW_LINE INDENT arr [ i + y ] = True ; NEW_LINE DEDENT result += 1 ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 15 ; NEW_LINE x = 5 ; NEW_LINE y = 7 ; NEW_LINE print ( countNums ( n , x , y ) ) ; NEW_LINE DEDENT"],"references":["def countNums ( n , x , y ) : NEW_LINE INDENT arr = [ False for i in range ( n + 2 ) ] NEW_LINE if ( x <= n ) : NEW_LINE INDENT arr [ x ] = True NEW_LINE DEDENT if ( y <= n ) : NEW_LINE INDENT arr [ y ] = True NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( min ( x , y ) , n + 1 ) : NEW_LINE INDENT if ( arr [ i ] ) : NEW_LINE INDENT if ( i + x <= n ) : NEW_LINE INDENT arr [ i + x ] = True NEW_LINE DEDENT if ( i + y <= n ) : NEW_LINE INDENT arr [ i + y ] = True NEW_LINE DEDENT result = result + 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT n = 15 NEW_LINE x = 5 NEW_LINE y = 7 NEW_LINE print ( countNums ( n , x , y ) ) NEW_LINE"],"bleu":0.652500786081696,"rouge_l":0.7882821609016712}
{"id":1397,"predictions":["def get_max_splits ( num_str ) : NEW_LINE INDENT count = 0 NEW_LINE current_sum = 0 NEW_LINE for i in range ( len ( num_str ) ) : NEW_LINE INDENT current_num = num_str [ ord ( num_str [ i ] ) - ord ( '0' ) NEW_LINE current_sum += current_sum NEW_LINE if current_sum % 3 == 0 or current_sum % 3 == 0 and current_sum % 3 == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT current_sum += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str_max_splits ( ) NEW_LINE print ( get_max_splits ( ) ) NEW_LINE DEDENT"],"references":["def get_max_splits ( num_string ) : NEW_LINE INDENT count = 0 NEW_LINE running_sum = 0 NEW_LINE for i in range ( len ( num_string ) ) : NEW_LINE INDENT current_num = int ( num_string [ i ] ) NEW_LINE running_sum += current_num NEW_LINE if current_num % 3 == 0 or ( running_sum != 0 and running_sum % 3 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE running_sum = 0 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT print get_max_splits ( \"12345\" ) NEW_LINE"],"bleu":0.39417778152643274,"rouge_l":0.6972635954277796}
{"id":1398,"predictions":["def term ( n ) : NEW_LINE INDENT return n * ( n + 1 ) \/\/ 2 NEW_LINE DEDENT n = 4 NEW_LINE print ( term ( n ) ) NEW_LINE"],"references":["def term ( n ) : NEW_LINE INDENT return n * ( n + 1 ) \/ 2 NEW_LINE DEDENT n = 4 NEW_LINE print term ( n ) NEW_LINE"],"bleu":0.7848271093555107,"rouge_l":0.9409574468085108}
{"id":1399,"predictions":["def angleequichord ( z ) : NEW_LINE INDENT print ( \" The ▁ angle ▁ angle ▁ is \" , z , \" degrees \" ) ; NEW_LINE DEDENT z = 48 ; NEW_LINE anglechord ( z ) ; NEW_LINE"],"references":["def anglequichord ( z ) : NEW_LINE INDENT print ( \" The ▁ angle ▁ is ▁ \" , z , \" ▁ degrees \" ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT z = 48 NEW_LINE anglequichord ( z ) NEW_LINE DEDENT"],"bleu":0.422540582778686,"rouge_l":0.7098025387870239}
{"id":1400,"predictions":["def findLength ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE maxLen = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT j = i + 1 NEW_LINE while ( j < n ) : NEW_LINE INDENT length = j - i + 1 NEW_LINE leftsum = 0 NEW_LINE for k in range ( 0 , n \/\/ 2 ) : NEW_LINE INDENT leftsum += ( ord ( str [ i + k ] ) - ord ( '0' ) ) NEW_LINE DEDENT leftsum += ( ord ( str [ i + k + length \/\/ 2 ] ) - ord ( '0' ) ) NEW_LINE DEDENT if ( leftsum == ( length and len ( maxLen < length ) ) ) : NEW_LINE INDENT maxlen = len ( str ) NEW_LINE DEDENT DEDENT return maxlen NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \"255\" NEW_LINE print ( \" Length ▁ of ▁ the ▁ substring ▁ is \" , findLength ( str ) ) NEW_LINE DEDENT"],"references":["def findLength ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE maxlen = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n , 2 ) : NEW_LINE INDENT length = j - i + 1 NEW_LINE leftsum = 0 NEW_LINE rightsum = 0 NEW_LINE for k in range ( 0 , int ( length \/ 2 ) ) : NEW_LINE INDENT leftsum += ( int ( str [ i + k ] ) - int ( '0' ) ) NEW_LINE rightsum += ( int ( str [ i + k + int ( length \/ 2 ) ] ) - int ( '0' ) ) NEW_LINE DEDENT if ( leftsum == rightsum and maxlen < length ) : NEW_LINE INDENT maxlen = length NEW_LINE DEDENT DEDENT DEDENT return maxlen NEW_LINE DEDENT str = \"1538023\" NEW_LINE print ( \" Length ▁ of ▁ the ▁ substring ▁ is \" , findLength ( str ) ) NEW_LINE"],"bleu":0.6438341067842832,"rouge_l":0.8010836624116081}
{"id":1401,"predictions":["MOD = 32767 ; NEW_LINE def min_modulo ( l , r ) : NEW_LINE INDENT if ( r - l >= MOD ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT ans = MOD - 1 ; NEW_LINE DEDENT for i in range ( l , r + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , r + 1 ) : NEW_LINE INDENT ans = min ( ans , ( i * j ) ) % MOD ) ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT l = 2040 ; r = 2040 ; NEW_LINE print ( min_modulo ( l , r ) ) ; NEW_LINE DEDENT"],"references":["MOD = 2019 ; NEW_LINE def min_modulo ( l , r ) : NEW_LINE INDENT if ( r - l >= MOD ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT ans = MOD - 1 ; NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , r + 1 ) : NEW_LINE INDENT ans = min ( ans , ( i * j ) % MOD ) ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT l = 2020 ; r = 2040 ; NEW_LINE print ( min_modulo ( l , r ) ) ; NEW_LINE DEDENT"],"bleu":0.9260797528422989,"rouge_l":0.9738529226901319}
{"id":1402,"predictions":["def countPairsWithDP ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] * arr [ j ] == k : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 5 , 4 , 2 ] NEW_LINE N = len ( arr ) NEW_LINE K = 3 NEW_LINE print ( countPairsWithDP ( arr , N , K ) ) NEW_LINE DEDENT"],"references":["def countPairsWithProdK ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] * arr [ j ] == k ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 1 , 5 , 3 , 4 , 2 ] NEW_LINE N = len ( arr ) NEW_LINE K = 3 NEW_LINE print ( countPairsWithProdK ( arr , N , K ) ) NEW_LINE"],"bleu":0.7926314740431557,"rouge_l":0.9074380165289255}
{"id":1403,"predictions":["def Xor_Sum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE left_xor = 0 NEW_LINE right_xor = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT left_xor = left_xor + arr [ i ] NEW_LINE right_xor = 0 NEW_LINE for j in range ( i + 1 , n , 1 ) : NEW_LINE INDENT right_xor = right_xor ^ arr [ j ] NEW_LINE if left_xor + right_xor > right_xor : NEW_LINE INDENT sum = left_xor + right_xor NEW_LINE DEDENT DEDENT if right_xor + right_xor > sum : NEW_LINE INDENT sum = left_xor + right_xor NEW_LINE DEDENT DEDENT return index + 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 4 , 6 , 3 , 8 , 10 , 2 , 13 , 2 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( Xor_Sum ( arr , n ) ) NEW_LINE DEDENT"],"references":["def Xor_Sum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE index , left_xor = 0 , 0 NEW_LINE right_xor = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT left_xor = left_xor ^ arr [ i ] NEW_LINE right_xor = 0 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT right_xor = right_xor ^ arr [ j ] NEW_LINE DEDENT if ( left_xor + right_xor > sum ) : NEW_LINE INDENT sum = left_xor + right_xor NEW_LINE index = i NEW_LINE DEDENT DEDENT return index + 1 NEW_LINE DEDENT arr = [ 1 , 4 , 6 , 3 , 8 , 13 , 34 , 2 , 21 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( Xor_Sum ( arr , n ) ) NEW_LINE"],"bleu":0.6952399486635663,"rouge_l":0.8420144505553757}
{"id":1404,"predictions":["def print ( a , n , ind ) : NEW_LINE INDENT for i in range ( ind + n + ind ) : NEW_LINE INDENT print ( a [ i % n ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT a = [ ' A ' , ' B ' , ' C ' , ' D ' , ' D ' , ' E ' , ' F ' ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( a [ 0 ] , end = \" ▁ \" ) ; NEW_LINE"],"references":["def prints ( a , n , ind ) : NEW_LINE INDENT i = ind NEW_LINE while i < n + ind : NEW_LINE INDENT print ( a [ ( i % n ) ] , end = \" ▁ \" ) NEW_LINE i = i + 1 NEW_LINE DEDENT DEDENT a = [ ' A ' , ' B ' , ' C ' , ' D ' , ' E ' , ' F ' ] NEW_LINE n = len ( a ) ; NEW_LINE prints ( a , n , 3 ) ; NEW_LINE"],"bleu":0.634357014552588,"rouge_l":0.800897457204587}
{"id":1405,"predictions":["def printPattern ( i , j , n ) : NEW_LINE INDENT if ( j >= n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( i >= n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( j == i or j == n - 1 - i ) : NEW_LINE INDENT print ( \" \/ \" , end = \" \" ) NEW_LINE print ( \" \\t \" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" \\t \" , end = \" \" ) NEW_LINE DEDENT if ( j == i or j == n - 1 ) : NEW_LINE INDENT print ( \" \/ \" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT printPattern ( i + 1 , j , n ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 9 NEW_LINE printPattern ( 0 , 0 , N ) NEW_LINE DEDENT"],"references":["def printPattern ( i , j , n ) : NEW_LINE INDENT if ( j >= n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( i >= n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( j == i or j == n - 1 - i ) : NEW_LINE INDENT if ( i == n - 1 - j ) : NEW_LINE INDENT print ( \" \/ \" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" \\\\ \" , end = \" \" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( \" * \" , end = \" \" ) NEW_LINE DEDENT if ( printPattern ( i , j + 1 , n ) == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT print ( ) NEW_LINE return printPattern ( i + 1 , 0 , n ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 9 NEW_LINE printPattern ( 0 , 0 , N ) NEW_LINE DEDENT"],"bleu":0.7775334328420431,"rouge_l":0.8301240511016478}
{"id":1406,"predictions":["import sys NEW_LINE def findMaxValue ( arr , n ) : NEW_LINE INDENT if ( n < 4 ) : NEW_LINE INDENT print ( \" The ▁ array ▁ can ▁ be ▁ present \" ) NEW_LINE return NEW_LINE DEDENT table = [ ] NEW_LINE table = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT table . append ( ( arr [ i ] , arr [ i + 1 ] ) ) NEW_LINE table . append ( table [ i ] ) NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT table [ i ] = max ( table [ i + 1 ] , arr [ i + 1 ] ) NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT table [ i ] = table [ i + 1 ] NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT table [ i ] = table [ i + 1 ] NEW_LINE table [ i ] = table [ i + 1 ] NEW_LINE DEDENT DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT table [ i ] = table [ i + 1 ] NEW_LINE DEDENT return table [ 0 ] NEW_LINE DEDENT arr = [ 4 , 8 , 9 , 2 , 20 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMaxValue ( arr , n ) ) NEW_LINE"],"references":["def findMaxValue ( arr , n ) : NEW_LINE INDENT if n < 4 : NEW_LINE INDENT print ( \" The ▁ array ▁ should ▁ have ▁ atlest ▁ 4 ▁ elements \" ) NEW_LINE return MIN NEW_LINE DEDENT table1 , table2 = [ MIN ] * ( n + 1 ) , [ MIN ] * n NEW_LINE table3 , table4 = [ MIN ] * ( n - 1 ) , [ MIN ] * ( n - 2 ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT table1 [ i ] = max ( table1 [ i + 1 ] , arr [ i ] ) NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT table2 [ i ] = max ( table2 [ i + 1 ] , table1 [ i + 1 ] - arr [ i ] ) NEW_LINE DEDENT for i in range ( n - 3 , - 1 , - 1 ) : NEW_LINE INDENT table3 [ i ] = max ( table3 [ i + 1 ] , table2 [ i + 1 ] + arr [ i ] ) NEW_LINE DEDENT for i in range ( n - 4 , - 1 , - 1 ) : NEW_LINE INDENT table4 [ i ] = max ( table4 [ i + 1 ] , table3 [ i + 1 ] - arr [ i ] ) NEW_LINE DEDENT return table4 [ 0 ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 4 , 8 , 9 , 2 , 20 ] NEW_LINE n = len ( arr ) NEW_LINE MIN = - 100000000 NEW_LINE print ( findMaxValue ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.5969593413438732,"rouge_l":0.7111990587228579}
{"id":1407,"predictions":["def printElements ( a , n ) : NEW_LINE INDENT a = sorted ( a ) NEW_LINE a = sorted ( a ) NEW_LINE cnt = 1 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if a [ i + 1 ] != a [ i ] : NEW_LINE INDENT print ( a [ i ] , end = \" ▁ \" ) NEW_LINE cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt = 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 1 , 1 , 2 , 3 , 4 , 9 ] NEW_LINE n = len ( a ) NEW_LINE printElements ( a , n ) NEW_LINE DEDENT"],"references":["def printElements ( a , n ) : NEW_LINE INDENT a . sort ( reverse = True ) NEW_LINE cnt = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( a [ i ] != a [ i + 1 ] ) : NEW_LINE INDENT print ( a [ i ] , \" ▁ occurs ▁ \" , cnt , \" times \" ) NEW_LINE cnt = 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT print ( a [ n - 1 ] , \" occurs \" , cnt , \" times \" ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 1 , 1 , 2 , 3 , 4 , 9 , 9 , 10 ] NEW_LINE n = len ( a ) NEW_LINE printElements ( a , n ) NEW_LINE DEDENT"],"bleu":0.6579160231890198,"rouge_l":0.7850882059247752}
{"id":1408,"predictions":["def findMin ( arr , n ) : NEW_LINE INDENT m = arr [ 0 ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT m = max ( m , arr [ i ] ) NEW_LINE DEDENT freq = [ 0 ] * ( m + 2 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT j = i NEW_LINE cnt = 0 NEW_LINE while ( j <= m + 1 ) : NEW_LINE INDENT j = i NEW_LINE cnt += freq [ j ] NEW_LINE j += i NEW_LINE DEDENT if ( cnt == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return m NEW_LINE DEDENT arr = [ 2 , 12 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMin ( arr , n ) ) NEW_LINE"],"references":["def findMin ( arr , n ) : NEW_LINE INDENT m = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT m = max ( m , arr [ i ] ) NEW_LINE DEDENT freq = [ 0 ] * ( m + 2 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( 1 , m + 2 ) : NEW_LINE INDENT j = i NEW_LINE cnt = 0 NEW_LINE while ( j <= m ) : NEW_LINE INDENT cnt += freq [ j ] NEW_LINE j += i NEW_LINE DEDENT if ( not cnt ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return m + 1 NEW_LINE DEDENT arr = [ 2 , 12 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMin ( arr , n ) ) NEW_LINE"],"bleu":0.7697131387089439,"rouge_l":0.8608870967741936}
{"id":1409,"predictions":["def swapOperations ( a , b , c ) : NEW_LINE INDENT l = len ( a ) NEW_LINE i = 0 NEW_LINE while ( i < l ) : NEW_LINE INDENT if ( a [ i ] == b [ i ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( b [ i ] == c [ i ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( b [ i ] == c [ b [ i ] ] ) : NEW_LINE INDENT temp = a [ i ] NEW_LINE c [ i ] = c [ i ] NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( i == l ) : NEW_LINE INDENT temp = a [ i ] NEW_LINE c [ i ] = c [ i ] + c [ i ] NEW_LINE c [ i ] = c [ i ] NEW_LINE break NEW_LINE DEDENT DEDENT if ( i == l ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a , b , c = swapOperations ( a , b , c ) NEW_LINE DEDENT"],"references":["def swapOperations ( a , b , c ) : NEW_LINE INDENT l = len ( a ) ; NEW_LINE i = 0 ; NEW_LINE total_swaps = 0 ; NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( a [ i ] == b [ i ] ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT if ( a [ i ] == c [ i ] ) : NEW_LINE INDENT b [ i ] , c [ i ] = c [ i ] , b [ i ] ; NEW_LINE total_swaps += 1 ; NEW_LINE continue ; NEW_LINE DEDENT if ( b [ i ] == c [ i ] ) : NEW_LINE INDENT a [ i ] , c [ i ] = c [ i ] , a [ i ] ; NEW_LINE total_swaps += 1 ; NEW_LINE continue ; NEW_LINE DEDENT break ; NEW_LINE DEDENT i += 1 ; NEW_LINE if ( i == l ) : NEW_LINE INDENT print ( total_swaps ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = \" xyz \" ; NEW_LINE b = \" yzx \" ; NEW_LINE c = \" yzx \" ; NEW_LINE swapOperations ( list ( a ) , list ( b ) , list ( c ) ) ; NEW_LINE DEDENT"],"bleu":0.5392286629688575,"rouge_l":0.6921494929437629}
{"id":1410,"predictions":["def findMinimumZ ( n , a , b ) : NEW_LINE INDENT diff = a NEW_LINE if ( a > b ) : NEW_LINE INDENT diff = b NEW_LINE DEDENT distDiff = ( a - 1 ) + ( n - a + 1 ) NEW_LINE minDist = min ( dist , distDiff ) NEW_LINE if ( minDist == 1 ) : NEW_LINE INDENT return 3 NEW_LINE DEDENT return minDiff NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n , a , b = 1 , 2 , 2 NEW_LINE print ( findMinimumZ ( n , a , b ) ) NEW_LINE DEDENT"],"references":["def findMinimumZ ( n , a , b ) : NEW_LINE INDENT if ( a > b ) : NEW_LINE INDENT temp = a NEW_LINE a = b NEW_LINE b = temp NEW_LINE DEDENT distClock = b - a NEW_LINE distAntiClock = ( a - 1 ) + ( n - b + 1 ) NEW_LINE minDist = min ( distClock , distAntiClock ) NEW_LINE if ( minDist == 1 ) : NEW_LINE INDENT return 3 NEW_LINE DEDENT return minDist NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE a = 1 NEW_LINE b = 2 NEW_LINE print ( findMinimumZ ( n , a , b ) ) NEW_LINE DEDENT"],"bleu":0.6317900989849418,"rouge_l":0.7937765205091939}
{"id":1411,"predictions":["def solve ( ang , n ) : NEW_LINE INDENT if ( ( ang * n ) > ( 180 * ( float - 2 ) ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( ( ang * n ) % 360 != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = 1 NEW_LINE freq = ( ang * n ) \/\/ 360 NEW_LINE ans = ans * ( n - 1 ) NEW_LINE return ans NEW_LINE DEDENT ang = 90 NEW_LINE n = 4 NEW_LINE print ( solve ( ang , n ) ) NEW_LINE"],"references":["def solve ( ang , n ) : NEW_LINE INDENT if ( ( ang * n ) > ( 180 * ( n - 2 ) ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( ( ang * n ) % 180 != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = 1 NEW_LINE freq = ( ang * n ) \/\/ 180 NEW_LINE ans = ans * ( n - 1 - freq ) NEW_LINE ans = ans * n NEW_LINE return ans NEW_LINE DEDENT ang = 90 NEW_LINE n = 4 NEW_LINE print ( solve ( ang , n ) ) NEW_LINE"],"bleu":0.833146382074428,"rouge_l":0.9262680025046964}
{"id":1412,"predictions":["def bitsAreInAltPatrn ( n , l , r ) : NEW_LINE INDENT num = n >> 1 ; NEW_LINE prev = n >> 1 ; NEW_LINE num = num & ( l - 1 ) ; NEW_LINE for i in range ( 1 , r + 1 ) : NEW_LINE INDENT curr = num & 1 ; NEW_LINE if ( curr == prev ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT prev = curr >> 1 ; NEW_LINE if ( curr == prev ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT prev = curr >> 1 ; NEW_LINE num = num >> 1 ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 18 ; NEW_LINE l = 1 ; r = 3 ; NEW_LINE if ( bitsAreInAltPatrnPattern ( n , l , r ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"],"references":["def bitsAreInAltPatrnInGivenTRange ( n , l , r ) : NEW_LINE INDENT num = n >> ( l - 1 ) ; NEW_LINE prev = num & 1 ; NEW_LINE num = num >> 1 ; NEW_LINE for i in range ( 1 , ( r - l ) ) : NEW_LINE INDENT curr = num & 1 ; NEW_LINE if ( curr == prev ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT prev = curr ; NEW_LINE num = num >> 1 ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 18 ; NEW_LINE l = 1 ; NEW_LINE r = 3 ; NEW_LINE if ( bitsAreInAltPatrnInGivenTRange ( n , l , r ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"],"bleu":0.7733941672320188,"rouge_l":0.865634613476233}
{"id":1413,"predictions":["def countFibil ( low , high ) : NEW_LINE INDENT f1 = 0 NEW_LINE f2 = 1 NEW_LINE f3 = 1 NEW_LINE f3 = 1 NEW_LINE while ( f1 <= low ) : NEW_LINE INDENT if ( f1 >= low ) : NEW_LINE INDENT result = result + 1 NEW_LINE DEDENT f1 = f2 NEW_LINE f3 = f3 NEW_LINE DEDENT return result NEW_LINE DEDENT def countFibonacci ( low , high ) : NEW_LINE INDENT if ( f1 >= low ) : NEW_LINE INDENT result = result + ( low ) NEW_LINE DEDENT return result NEW_LINE DEDENT low = 10 NEW_LINE high = 100 NEW_LINE print ( \" Count ▁ of ▁ Fibonacci ▁ numbers ▁ is \" , countFibonacci ( low , high ) ) NEW_LINE"],"references":["def countFibs ( low , high ) : NEW_LINE INDENT f1 , f2 , f3 = 0 , 1 , 1 NEW_LINE result = 0 NEW_LINE while ( f1 <= high ) : NEW_LINE INDENT if ( f1 >= low ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT f1 = f2 NEW_LINE f2 = f3 NEW_LINE f3 = f1 + f2 NEW_LINE DEDENT return result NEW_LINE DEDENT low , high = 10 , 100 NEW_LINE print ( \" Count ▁ of ▁ Fibonacci ▁ Numbers ▁ is \" , countFibs ( low , high ) ) NEW_LINE"],"bleu":0.49315907815272214,"rouge_l":0.7124887690925427}
{"id":1414,"predictions":["def Sum_ upto_term ( n ) : NEW_LINE INDENT r = n * ( n + 1 ) * ( 2 * n + 7 ) \/\/ 3 NEW_LINE print ( r ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 5 NEW_LINE Sum_upto_term ( N ) NEW_LINE DEDENT"],"references":["def Sum_upto_nth_Term ( n ) : NEW_LINE INDENT return n * ( n + 1 ) * ( 2 * n + 7 ) \/\/ 3 NEW_LINE DEDENT N = 5 NEW_LINE print ( Sum_upto_nth_Term ( N ) ) NEW_LINE"],"bleu":0.4857246822556038,"rouge_l":0.7176470588235293}
{"id":1415,"predictions":["class node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def printList ( node ) : NEW_LINE INDENT while node != None : NEW_LINE INDENT print ( node . data , end = \" ▁ \" ) NEW_LINE node = node NEW_LINE node = node . next NEW_LINE DEDENT DEDENT def push ( head , new_data ) : NEW_LINE INDENT new_node = head NEW_LINE new_node . next = head NEW_LINE head_ref = new_node NEW_LINE return head_ref NEW_LINE DEDENT def moveToStart ( head , new_data , new_data ) : NEW_LINE INDENT if head == None : NEW_LINE INDENT return NEW_LINE DEDENT p_ref = new_node NEW_LINE return head_ref NEW_LINE DEDENT def moveToStart ( head , new_data , new_data ) : NEW_LINE INDENT new_node = head NEW_LINE if head == None : NEW_LINE INDENT return head . data NEW_LINE DEDENT new_node . next = head_ref NEW_LINE new_node . next = head_ref NEW_LINE head_ref = new_node NEW_LINE head_ref = new_node NEW_LINE return head_ref NEW_LINE DEDENT def prToStart ( head_ref , new_data ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT return NEW_LINE DEDENT else : NEW_LINE INDENT return start NEW_LINE DEDENT DEDENT def printList ( start , end = \" ▁ \" ) : NEW_LINE INDENT while ( start != None ) : NEW_LINE INDENT print ( start , end = \" ▁ \" ) NEW_LINE start = start . next NEW_LINE start = start . next NEW_LINE end = start . next NEW_LINE DEDENT print ( start , end = \" ▁ \" ) NEW_LINE while ( start != end ) : NEW_LINE INDENT print ( start , end = \" ▁ \" ) NEW_LINE start = start . next NEW_LINE DEDENT DEDENT if"],"references":["class Node : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . data = 0 NEW_LINE self . next = None NEW_LINE DEDENT DEDENT first = None NEW_LINE last = None NEW_LINE length = 0 NEW_LINE def printList ( node ) : NEW_LINE INDENT while ( node != None ) : NEW_LINE INDENT print ( node . data , end = \" ▁ \" ) NEW_LINE node = node . next NEW_LINE DEDENT DEDENT def moveToFront ( head , p , m ) : NEW_LINE INDENT global first NEW_LINE global last NEW_LINE global length NEW_LINE if ( head == None ) : NEW_LINE INDENT return head NEW_LINE DEDENT p = head NEW_LINE head = head . next NEW_LINE m = m + 1 NEW_LINE if ( length == m ) : NEW_LINE INDENT p . next = None NEW_LINE last . next = first NEW_LINE first = head NEW_LINE DEDENT else : NEW_LINE INDENT moveToFront ( head , p , m ) NEW_LINE DEDENT DEDENT def push ( head_ref , new_data ) : NEW_LINE INDENT global first NEW_LINE global last NEW_LINE global length NEW_LINE new_node = Node ( ) NEW_LINE new_node . data = new_data NEW_LINE new_node . next = ( head_ref ) NEW_LINE ( head_ref ) = new_node NEW_LINE if ( length == 0 ) : NEW_LINE INDENT last = head_ref NEW_LINE DEDENT else : NEW_LINE INDENT first = head_ref NEW_LINE DEDENT length = length + 1 NEW_LINE return head_ref NEW_LINE DEDENT start = None NEW_LINE start = push ( start , 5 ) NEW_LINE start = push ( start , 4 ) NEW_LINE start = push ( start , 3 ) NEW_LINE start = push ( start , 2 ) NEW_LINE start = push ( start , 1 ) NEW_LINE start = push ( start , 0 ) NEW_LINE print ( \" \\n ▁ Initial ▁ Linked ▁ list \" ) NEW_LINE printList ( start ) NEW_LINE m = 4 NEW_LINE temp = None NEW_LINE moveToFront ( start , temp , m ) NEW_LINE print ( \" \\n ▁ Final ▁ Linked ▁ list \" ) NEW_LINE start = first NEW_LINE printList ( start ) NEW_LINE"],"bleu":0.3709317286846694,"rouge_l":0.5301514857253835}
{"id":1416,"predictions":["def printRepeating ( arr , size ) : NEW_LINE INDENT s . add ( arr [ size ] ) NEW_LINE print ( s ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 3 , 2 , 2 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE printRepeating ( arr , n ) NEW_LINE DEDENT"],"references":["def printRepeating ( arr , size ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT if arr [ i ] not in s : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT for i in s : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 3 , 2 , 2 , 1 ] NEW_LINE size = len ( arr ) NEW_LINE printRepeating ( arr , size ) NEW_LINE DEDENT"],"bleu":0.3966186680570966,"rouge_l":0.6639747191011237}
{"id":1417,"predictions":["def maxsum_Sushi ( arr , n ) : NEW_LINE INDENT max_sum = 0 NEW_LINE current_sum = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i - 1 ] < arr [ i ] ) : NEW_LINE INDENT current_sum = current_sum + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT current_sum = max_sum NEW_LINE DEDENT DEDENT return current_sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Maximum ▁ sum ▁ = \" , maxsum_Sushi ( arr , n ) ) NEW_LINE DEDENT"],"references":["def maxsum_SIS ( arr , n ) : NEW_LINE INDENT max_sum = 0 NEW_LINE current_sum = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i - 1 ] < arr [ i ] ) : NEW_LINE INDENT current_sum = current_sum + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT max_sum = max ( max_sum , current_sum ) NEW_LINE current_sum = arr [ i ] NEW_LINE DEDENT DEDENT return max ( max_sum , current_sum ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT arr = [ 1 , 2 , 2 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Maximum ▁ sum ▁ : ▁ \" , maxsum_SIS ( arr , n ) ) , NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"bleu":0.6529268946963558,"rouge_l":0.7746253289097359}
{"id":1418,"predictions":["def sumoflength ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE j , ans = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( j < n and len ( arr [ i ] ) == arr [ j ] ) : NEW_LINE INDENT s . add ( arr [ j ] ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT ans += ( j - i + 1 ) * ( j - i + 1 ) \/\/ 2 NEW_LINE return ans NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( sumoflength ( arr , n ) ) NEW_LINE"],"references":["def sumoflength ( arr , n ) : NEW_LINE INDENT s = [ ] NEW_LINE j = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( j < n and ( arr [ j ] not in s ) ) : NEW_LINE INDENT s . append ( arr [ j ] ) NEW_LINE j += 1 NEW_LINE DEDENT ans += ( ( j - i ) * ( j - i + 1 ) ) \/\/ 2 NEW_LINE s . remove ( arr [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( sumoflength ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.6602804186561066,"rouge_l":0.7894547633313361}
{"id":1419,"predictions":["class node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def printIndex ( v , k ) : NEW_LINE INDENT stack = [ ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT stack . append ( v [ i ] ) NEW_LINE DEDENT for j in range ( k , - 1 , - 1 ) : NEW_LINE INDENT print ( v [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def printKPathUtil ( root , k ) : NEW_LINE INDENT path = [ ] NEW_LINE left = [ ] NEW_LINE right = [ ] NEW_LINE for i in range ( len ( path ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT f = path [ - 1 ] NEW_LINE if ( f == k ) : NEW_LINE INDENT print ( path [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT for j in range ( len ( path ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT f . append ( path [ j ] [ i ] ) NEW_LINE DEDENT if ( f [ j ] == k ) : NEW_LINE INDENT path . append ( path [ j ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = Node ( 1 ) NEW_LINE root . left = Node ( 4 ) NEW_LINE root . right = Node ( 5 ) NEW_LINE root . left . left = Node ( 2 ) NEW_LINE root . right = Node ( 4 ) NEW_LINE root . right . left = Node ( 1 ) NEW_LINE root . left . right = Node ( 1 ) NEW_LINE root . right . left = Node ( 1 ) NEW_LINE root . left . right = Node ( 1 ) NEW_LINE root . right . left . right . right . right = Node ( 2 ) NEW_LINE k = 5 NEW_LINE printKPath ( root , k ) NEW_LINE DEDENT"],"references":["def printVector ( v , i ) : NEW_LINE INDENT for j in range ( i , len ( v ) ) : NEW_LINE INDENT print ( v [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT class newNode : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . data = key NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def printKPathUtil ( root , path , k ) : NEW_LINE INDENT if ( not root ) : NEW_LINE INDENT return NEW_LINE DEDENT path . append ( root . data ) NEW_LINE printKPathUtil ( root . left , path , k ) NEW_LINE printKPathUtil ( root . right , path , k ) NEW_LINE f = 0 NEW_LINE for j in range ( len ( path ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT f += path [ j ] NEW_LINE if ( f == k ) : NEW_LINE INDENT printVector ( path , j ) NEW_LINE DEDENT DEDENT path . pop ( - 1 ) NEW_LINE DEDENT def printKPath ( root , k ) : NEW_LINE INDENT path = [ ] NEW_LINE printKPathUtil ( root , path , k ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 1 ) NEW_LINE root . left = newNode ( 3 ) NEW_LINE root . left . left = newNode ( 2 ) NEW_LINE root . left . right = newNode ( 1 ) NEW_LINE root . left . right . left = newNode ( 1 ) NEW_LINE root . right = newNode ( - 1 ) NEW_LINE root . right . left = newNode ( 4 ) NEW_LINE root . right . left . left = newNode ( 1 ) NEW_LINE root . right . left . right = newNode ( 2 ) NEW_LINE root . right . right = newNode ( 5 ) NEW_LINE root . right . right . right = newNode ( 2 ) NEW_LINE k = 5 NEW_LINE printKPath ( root , k ) NEW_LINE DEDENT"],"bleu":0.6225717888690313,"rouge_l":0.6217593618435631}
{"id":1420,"predictions":["def reverseArray ( arr , n ) : NEW_LINE INDENT for i in range ( n \/\/ 2 ) : NEW_LINE INDENT swap ( arr [ i ] , ( arr [ i ] , ( n + i ) \/\/ 2 ) + 1 ) NEW_LINE DEDENT DEDENT def reverse ( arr , i , j ) : NEW_LINE INDENT while ( i < n \/\/ 2 ) : NEW_LINE INDENT swap ( arr [ i ] , arr [ j ] , arr [ i + 1 ] ) NEW_LINE arr [ i ] , arr [ j ] = arr [ j ] , arr [ j ] NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 5 , 3 , 7 , 2 , 1 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE reverse ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT"],"references":["def reverseArray ( arr , n ) : NEW_LINE INDENT for i in range ( n \/\/ 2 ) : NEW_LINE INDENT arr [ i ] , arr [ ( n + ~ i + 1 ) + ~ 1 + 1 ] = arr [ ( n + ~ i + 1 ) + ~ 1 + 1 ] , arr [ i ] NEW_LINE DEDENT DEDENT arr = [ 5 , 3 , 7 , 2 , 1 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE reverseArray ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT"],"bleu":0.5122295215330792,"rouge_l":0.7114295234921694}
{"id":1421,"predictions":["class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . prev = None NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def push ( head_ref , new_data ) : NEW_LINE INDENT new_node = Node ( new_data ) NEW_LINE new_node . next = head_ref NEW_LINE new_node . prev = new_node NEW_LINE head_ref = new_node NEW_LINE return head_ref NEW_LINE DEDENT def push ( head_ref , new_data ) : NEW_LINE INDENT new_node . prev = head_ref NEW_LINE new_node . next = head_ref NEW_LINE head_ref = new_node NEW_LINE return head_ref NEW_LINE DEDENT def reverseList ( head_ref , new_node ) : NEW_LINE INDENT if head_ref != None or ( head_ref != None ) : NEW_LINE INDENT head_ref . prev = head_ref NEW_LINE head_ref = new_node NEW_LINE return head_ref NEW_LINE DEDENT head_ref = new_node NEW_LINE return head_ref NEW_LINE DEDENT def reverse ( head_ref , new_data ) : NEW_LINE INDENT current_ref = head_ref NEW_LINE current_ref = head_ref NEW_LINE if ( head_ref != None or ( head_ref != None ) ) : NEW_LINE INDENT return None NEW_LINE DEDENT new_node . next = head_ref NEW_LINE new_node . next = head_ref NEW_LINE return head_ref NEW_LINE DEDENT def printList ( head_ref ) : NEW_LINE INDENT while head_ref != None : NEW_LINE INDENT print ( head_ref , end = \" ▁ \" ) NEW_LINE head_ref . next = head_ref NEW_LINE head_ref = head_ref NEW_LINE head_ref = head_ref NEW_LINE return head_ref NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = None NEW_LINE head = push ( head , 2 ) NEW_LINE head ="],"references":["import math NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def getNode ( data ) : NEW_LINE INDENT new_node = Node ( data ) NEW_LINE new_node . data = data NEW_LINE new_node . next = None NEW_LINE new_node . prev = None NEW_LINE return new_node NEW_LINE DEDENT def push ( head_ref , new_node ) : NEW_LINE INDENT new_node . prev = None NEW_LINE new_node . next = head_ref NEW_LINE if ( head_ref != None ) : NEW_LINE INDENT head_ref . prev = new_node NEW_LINE DEDENT head_ref = new_node NEW_LINE return head_ref NEW_LINE DEDENT def reverseList ( head_ref ) : NEW_LINE INDENT if ( head_ref == None or ( head_ref ) . next == None ) : NEW_LINE INDENT return None NEW_LINE DEDENT new_head = None NEW_LINE curr = head_ref NEW_LINE while ( curr != None ) : NEW_LINE INDENT next = curr . next NEW_LINE new_head = push ( new_head , curr ) NEW_LINE curr = next NEW_LINE DEDENT head_ref = new_head NEW_LINE return head_ref NEW_LINE DEDENT def prList ( head ) : NEW_LINE INDENT while ( head != None ) : NEW_LINE INDENT print ( head . data , end = \" ▁ \" ) NEW_LINE head = head . next NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = None NEW_LINE head = push ( head , getNode ( 2 ) ) ; NEW_LINE head = push ( head , getNode ( 4 ) ) ; NEW_LINE head = push ( head , getNode ( 8 ) ) ; NEW_LINE head = push ( head , getNode ( 10 ) ) ; NEW_LINE print ( \" Original ▁ list : ▁ \" , end = \" \" ) NEW_LINE prList ( head ) NEW_LINE head = reverseList ( head ) NEW_LINE print ( \" \\n Reversed ▁ list : ▁ \" , end = \" \" ) NEW_LINE prList ( head ) NEW_LINE DEDENT"],"bleu":0.46798288168414115,"rouge_l":0.5912813601492846}
{"id":1422,"predictions":["def decdiagonal ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT d d = 1.9 * a NEW_LINE return d NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 9 NEW_LINE print ( decdiagonal ( a ) ) NEW_LINE DEDENT"],"references":["def decdiagonal ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT d = 1.902 * a NEW_LINE return d NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 9 NEW_LINE print ( decdiagonal ( a ) ) NEW_LINE DEDENT"],"bleu":0.8420984989572815,"rouge_l":0.9416222284591637}
{"id":1423,"predictions":["def findSum ( N , k ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT sum += pow ( i , k ) NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 8 NEW_LINE k = 4 NEW_LINE print ( findSum ( N , k ) ) NEW_LINE DEDENT"],"references":["from math import pow NEW_LINE def findSum ( N , k ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , N + 1 , 1 ) : NEW_LINE INDENT sum += pow ( i , k ) NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 8 NEW_LINE k = 4 NEW_LINE print ( int ( findSum ( N , k ) ) ) NEW_LINE DEDENT"],"bleu":0.7908990223257535,"rouge_l":0.9011079195732459}
{"id":1424,"predictions":["def reverse ( k ) : NEW_LINE INDENT s = [ ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT s . append ( s [ i ] ) NEW_LINE DEDENT print ( \" \" , end = \" \" ) NEW_LINE while ( len ( s ) > 0 ) : NEW_LINE INDENT s . pop ( ) NEW_LINE del s [ - 1 ] NEW_LINE DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT print ( s [ i ] , end = \" \" ) NEW_LINE DEDENT print ( \" \" ) NEW_LINE DEDENT k = 3 NEW_LINE reverse ( k ) NEW_LINE"],"references":["def reverse ( k ) : NEW_LINE INDENT s = [ ] NEW_LINE token = k . split ( ) NEW_LINE for word in token : NEW_LINE INDENT s . append ( word ) ; NEW_LINE DEDENT while ( len ( s ) ) : NEW_LINE INDENT print ( s . pop ( ) , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT k = \" geeks ▁ for ▁ geeks \" ; NEW_LINE reverse ( k ) ; NEW_LINE DEDENT"],"bleu":0.3915180952144589,"rouge_l":0.5640181789688136}
{"id":1425,"predictions":["import sys NEW_LINE def subArray ( arr , n , m ) : NEW_LINE INDENT mp = { } ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 ; NEW_LINE DEDENT sum = 0 ; NEW_LINE p = sys . maxsize ; NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT sum += mp [ i ] ; NEW_LINE p = min ( p , mp [ i ] ) ; NEW_LINE if ( i == sum ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT val = p * i + ( i * ( i + 1 ) ) ; NEW_LINE if ( i == m ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 4 , 5 , 1 , 2 , 3 , 6 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE m = 3 ; NEW_LINE if ( subArray ( arr , n , m ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"],"references":["def subArray ( arr , n , m ) : NEW_LINE INDENT i = 0 NEW_LINE mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] = i + 1 NEW_LINE DEDENT sumcur = 0 NEW_LINE p = 10 ** 9 NEW_LINE ans = [ ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT sumcur += mp [ i ] NEW_LINE p = min ( p , mp [ i ] ) NEW_LINE val = p * i - i + ( i * ( i + 1 ) ) \/ 2 NEW_LINE if ( i == m ) : NEW_LINE INDENT if ( val == sumcur ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT DEDENT arr = [ 4 , 5 , 1 , 3 , 2 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE m = 3 NEW_LINE if ( subArray ( arr , n , m ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.6340886872250233,"rouge_l":0.791482216455503}
{"id":1426,"predictions":["class Graph : NEW_LINE INDENT def __init__ ( self , V ) : NEW_LINE INDENT self . V = V NEW_LINE self . graph = defaultdict ( list ) NEW_LINE DEDENT def addEdge ( self , v ) : NEW_LINE INDENT self . graph [ v ] . graph [ u ] . append ( v ) NEW_LINE self . graph [ v ] . append ( u ) NEW_LINE DEDENT def DFS ( self , v ) : NEW_LINE INDENT visited = [ False ] * ( V + 1 ) NEW_LINE for i in range ( V + 1 ) : NEW_LINE INDENT if visited [ i ] == False : NEW_LINE INDENT self . graph [ i ] . append ( v ) NEW_LINE DEDENT DEDENT def DFS ( self , v ) : NEW_LINE INDENT visited [ v ] = True NEW_LINE for i in range ( self . V + 1 ) : NEW_LINE INDENT if visited [ i ] == False and visited [ i ] == False : NEW_LINE INDENT self . DFS ( v ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def DFS ( self ) : NEW_LINE INDENT visited = [ False ] * ( V + 1 ) NEW_LINE for i in range ( self . V + 1 ) : NEW_LINE INDENT if visited [ i ] : NEW_LINE INDENT self . DFS ( self . graph , i ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT g = Graph ( ) NEW_LINE g . V = Graph ( ) NEW_LINE g . addEdge ( 1 , 0 ) NEW_LINE g . addEdge ( 0 , 1 ) NEW_LINE g . addEdge ( 1 , 2 ) NEW_LINE g . addEdge ( 0 , 3 ) NEW_LINE g . print ( \" Following ▁ is ▁ First ▁ Traversal \" ) NEW_LINE g . DEDENT"],"references":["class Graph : NEW_LINE INDENT def __init__ ( self , V ) : NEW_LINE INDENT self . V = V NEW_LINE self . adj = [ [ ] for i in range ( V ) ] NEW_LINE DEDENT def addEdge ( self , v , w ) : NEW_LINE INDENT self . adj [ v ] . append ( w ) NEW_LINE DEDENT def DFS ( self , s ) : NEW_LINE INDENT visited = [ False for i in range ( self . V ) ] NEW_LINE stack = [ ] NEW_LINE stack . append ( s ) NEW_LINE while ( len ( stack ) ) : NEW_LINE INDENT s = stack [ - 1 ] NEW_LINE stack . pop ( ) NEW_LINE if ( not visited [ s ] ) : NEW_LINE INDENT print ( s , end = ' ▁ ' ) NEW_LINE visited [ s ] = True NEW_LINE DEDENT for node in self . adj [ s ] : NEW_LINE INDENT if ( not visited [ node ] ) : NEW_LINE INDENT stack . append ( node ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT g = Graph ( 5 ) ; NEW_LINE g . addEdge ( 1 , 0 ) ; NEW_LINE g . addEdge ( 0 , 2 ) ; NEW_LINE g . addEdge ( 2 , 1 ) ; NEW_LINE g . addEdge ( 0 , 3 ) ; NEW_LINE g . addEdge ( 1 , 4 ) ; NEW_LINE print ( \" Following ▁ is ▁ Depth ▁ First ▁ Traversal \" ) NEW_LINE g . DFS ( 0 ) NEW_LINE"],"bleu":0.4289084416349432,"rouge_l":0.6190983514634967}
{"id":1427,"predictions":["class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT defagonal ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return NEW_LINE DEDENT q = [ ] NEW_LINE q . append ( root ) NEW_LINE while ( len ( q ) != 0 ) : NEW_LINE INDENT temp = q [ 0 ] NEW_LINE q . pop ( 0 ) NEW_LINE if ( temp == None ) : NEW_LINE INDENT return NEW_LINE DEDENT q . append ( temp ) NEW_LINE while ( len ( q ) > 0 ) : NEW_LINE INDENT temp = q [ 0 ] NEW_LINE q . pop ( 0 ) NEW_LINE if ( temp == None ) : NEW_LINE INDENT if ( temp . data != 0 ) : NEW_LINE INDENT q . append ( temp . data ) NEW_LINE DEDENT temp . data = temp . data NEW_LINE DEDENT if ( temp . left != None ) : NEW_LINE INDENT q . append ( temp . data ) NEW_LINE if ( temp . left != None ) : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT while ( temp . left != None ) : NEW_LINE INDENT print ( temp . data , end = \" ▁ \" ) NEW_LINE DEDENT print ( temp . data , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = Node ( 8 ) NEW_LINE root . left = Node ( 1 ) NEW_LINE root . left = Node ( 10 ) NEW_LINE root . right = Node ( 4 ) NEW_LINE root . left . left = Node ( 13 ) NEW_LINE root . left . right = Node ( 13 ) NEW_LINE root . right . left = Node ( 13 ) NEW_LINE root . right . left = Node ( 13 ) NEW_LINE root . left . right . left = Node ( 13 ) NEW_LINE"],"references":["class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . val = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def diagonalprint ( root ) : NEW_LINE INDENT if root is None : NEW_LINE INDENT return NEW_LINE DEDENT q = [ ] NEW_LINE q . append ( root ) NEW_LINE q . append ( None ) NEW_LINE while len ( q ) > 0 : NEW_LINE INDENT temp = q . pop ( 0 ) NEW_LINE if not temp : NEW_LINE INDENT if len ( q ) == 0 : NEW_LINE INDENT return NEW_LINE DEDENT print ( ' ▁ ' ) NEW_LINE q . append ( None ) NEW_LINE DEDENT else : NEW_LINE INDENT while temp : NEW_LINE INDENT print ( temp . val , end = ' ▁ ' ) NEW_LINE if temp . left : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE DEDENT temp = temp . right NEW_LINE DEDENT DEDENT DEDENT DEDENT root = Node ( 8 ) NEW_LINE root . left = Node ( 3 ) NEW_LINE root . right = Node ( 10 ) NEW_LINE root . left . left = Node ( 1 ) NEW_LINE root . left . right = Node ( 6 ) NEW_LINE root . right . right = Node ( 14 ) NEW_LINE root . right . right . left = Node ( 13 ) NEW_LINE root . left . right . left = Node ( 4 ) NEW_LINE root . left . right . right = Node ( 7 ) NEW_LINE diagonalprint ( root ) NEW_LINE"],"bleu":0.541948196490783,"rouge_l":0.7003809822034341}
{"id":1428,"predictions":["from math import gcd NEW_LINE def getWinner ( arr , n ) : NEW_LINE INDENT gcd = arr [ 0 ] NEW_LINE maxEle = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT gcd = gcd ( gcd , arr [ i ] ) NEW_LINE maxEle = max ( maxEle , arr [ i ] ) NEW_LINE DEDENT totalEle = ( maxEle , arr [ 0 ] ) NEW_LINE if ( totalEle % 2 == 1 ) : NEW_LINE INDENT return ' A ' NEW_LINE DEDENT return ' B ' NEW_LINE DEDENT arr = [ 5 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( getWinner ( arr , n ) ) NEW_LINE"],"references":["from math import gcd NEW_LINE def getWinner ( arr , n ) : NEW_LINE INDENT __gcd = arr [ 0 ] ; NEW_LINE maxEle = arr [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT __gcd = gcd ( __gcd , arr [ i ] ) ; NEW_LINE maxEle = max ( maxEle , arr [ i ] ) ; NEW_LINE DEDENT totalMoves = ( maxEle \/ __gcd ) - n ; NEW_LINE if ( totalMoves % 2 == 1 ) : NEW_LINE INDENT return ' A ' ; NEW_LINE DEDENT return ' B ' ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 5 , 6 , 7 ] ; NEW_LINE n = len ( arr ) NEW_LINE print ( getWinner ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.6304680852562512,"rouge_l":0.8393508173585794}
{"id":1429,"predictions":["def CountingsOdd ( arr , arr_size ) : NEW_LINE INDENT even_count = 0 NEW_LINE odd_count = 0 NEW_LINE for i in range ( 0 , arr_size ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT odd_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even_count += 1 NEW_LINE DEDENT DEDENT print ( \" Number ▁ of ▁ even ▁ element ▁ = ▁ \" , odd_count ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE CountingsOdd ( arr , n ) NEW_LINE DEDENT"],"references":["def CountingEvenOdd ( arr , arr_size ) : NEW_LINE INDENT even_count = 0 NEW_LINE odd_count = 0 NEW_LINE for i in range ( arr_size ) : NEW_LINE INDENT if ( arr [ i ] & 1 == 1 ) : NEW_LINE INDENT odd_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even_count += 1 NEW_LINE DEDENT DEDENT print ( \" Number ▁ of ▁ even ▁ elements ▁ = ▁ \" , even_count ) NEW_LINE print ( \" Number ▁ of ▁ odd ▁ elements ▁ = ▁ \" , odd_count ) NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE CountingEvenOdd ( arr , n ) NEW_LINE"],"bleu":0.7521861784906116,"rouge_l":0.8225279215472625}
{"id":1430,"predictions":["def findSum ( st ) : NEW_LINE INDENT temp = \" \" NEW_LINE sum = 0 NEW_LINE for i in range ( len ( st ) ) : NEW_LINE INDENT ch = st [ i ] NEW_LINE if ( ord ( st [ i ] ) >= ord ( '0' ) and ord ( st [ i ] ) <= ord ( '0' ) ) : NEW_LINE INDENT temp += chr ( ord ( st [ i ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT sum += chr ( ord ( st [ i ] ) ) NEW_LINE temp = \"0\" NEW_LINE DEDENT DEDENT DEDENT return sum + temp NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT st = \"1283676845678945678945678\" NEW_LINE print ( findSum ( st ) ) NEW_LINE DEDENT"],"references":["def findSum ( str1 ) : NEW_LINE INDENT temp = \" \" NEW_LINE Sum = 0 NEW_LINE for ch in str1 : NEW_LINE INDENT if ( ch . isdigit ( ) ) : NEW_LINE INDENT temp += ch NEW_LINE DEDENT else : NEW_LINE INDENT Sum += int ( temp ) NEW_LINE temp = \"0\" NEW_LINE DEDENT DEDENT return Sum + int ( temp ) NEW_LINE DEDENT str1 = \"12abc20yz68\" NEW_LINE print ( findSum ( str1 ) ) NEW_LINE"],"bleu":0.27501347722174874,"rouge_l":0.5848513902205177}
{"id":1431,"predictions":["def fibonacci ( n ) : NEW_LINE INDENT f = [ 0 ] * ( n + 2 ) NEW_LINE f [ 0 ] = 0 NEW_LINE f [ 1 ] = 0 NEW_LINE f [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT f [ i ] = f [ i - 1 ] + f [ i - 2 ] NEW_LINE DEDENT return f [ n ] NEW_LINE DEDENT n = 9 NEW_LINE print ( fibonacci ( n ) ) NEW_LINE"],"references":["def fibonacci ( n ) : NEW_LINE INDENT FibArray = [ 0 , 1 ] NEW_LINE while len ( FibArray ) < n + 1 : NEW_LINE INDENT FibArray . append ( 0 ) NEW_LINE DEDENT if n <= 1 : NEW_LINE INDENT return n NEW_LINE DEDENT else : NEW_LINE INDENT if FibArray [ n - 1 ] == 0 : NEW_LINE INDENT FibArray [ n - 1 ] = fibonacci ( n - 1 ) NEW_LINE DEDENT if FibArray [ n - 2 ] == 0 : NEW_LINE INDENT FibArray [ n - 2 ] = fibonacci ( n - 2 ) NEW_LINE DEDENT DEDENT FibArray [ n ] = FibArray [ n - 2 ] + FibArray [ n - 1 ] NEW_LINE return FibArray [ n ] NEW_LINE DEDENT print ( fibonacci ( 9 ) ) NEW_LINE"],"bleu":0.18052036433349364,"rouge_l":0.47875507442489856}
{"id":1432,"predictions":["def oddNumSum ( n ) : NEW_LINE INDENT j = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT j = ( 2 * i - 1 ) NEW_LINE sum = sum + ( j * j ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 6 NEW_LINE print ( oddNumSum ( n ) ) NEW_LINE"],"references":["def oddNumSum ( n ) : NEW_LINE INDENT j = 0 NEW_LINE sm = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT j = ( 2 * i - 1 ) NEW_LINE sm = sm + ( j * j * j * j ) NEW_LINE DEDENT return sm NEW_LINE DEDENT n = 6 ; NEW_LINE print ( oddNumSum ( n ) ) NEW_LINE"],"bleu":0.7737683843488989,"rouge_l":0.9006327630653855}
{"id":1433,"predictions":["import math NEW_LINE def findAandB ( N ) : NEW_LINE INDENT val = N * N - 4 * N NEW_LINE if ( val < 0 ) : NEW_LINE INDENT print ( \" NO ▁ ) NEW_LINE return NEW_LINE DEDENT a = ( N + math . floor ( val ) ) NEW_LINE b = ( N - math . sqrt ( val ) ) NEW_LINE return NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 89 NEW_LINE findAandB ( N ) NEW_LINE print ( \" a ▁ = \" , findAandB ( N ) ) NEW_LINE DEDENT"],"references":["from math import sqrt NEW_LINE def findAandB ( N ) : NEW_LINE INDENT val = N * N - 4.0 * N NEW_LINE if ( val < 0 ) : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE return NEW_LINE DEDENT a = ( N + sqrt ( val ) ) \/ 2.0 NEW_LINE b = ( N - sqrt ( val ) ) \/ 2.0 NEW_LINE print ( \" a ▁ = \" , ' { 0 : . 6 } ' . format ( a ) ) NEW_LINE print ( \" b ▁ = \" , ' { 0 : . 6 } ' . format ( b ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 69.0 NEW_LINE findAandB ( N ) NEW_LINE DEDENT"],"bleu":0.5213204198889128,"rouge_l":0.6405880808611184}
{"id":1434,"predictions":["def reverse ( string ) : NEW_LINE INDENT r = len ( string ) - 1 NEW_LINE l = 0 NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( string [ l ] == string [ r ] ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT elif ( string [ l ] == string [ r ] ) : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT elif ( string [ l ] == string [ r ] ) : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT string [ l ] , string [ r ] = string [ l ] , string [ l ] NEW_LINE string [ l ] , string [ r ] = string [ l ] , string [ l ] NEW_LINE string [ l ] , string [ r ] = string [ r ] , string [ l ] NEW_LINE print ( \" string : ▁ \" , sep = \" \" ) NEW_LINE DEDENT DEDENT string = \" aabb \" NEW_LINE reverse ( string ) NEW_LINE print ( \" string ▁ string : ▁ \" , string [ : : : - 1 ] , string ) NEW_LINE print ( \" string : \" , sep = \" \" ) NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT print ( string [ i ] , string [ i + 1 : ] , end = \" \" ) NEW_LINE DEDENT print ( \" \" ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" aabb \" NEW_LINE string = list ( string [ : : - 1 ] , string [ : : - 1 ] ) NEW_LINE print ( \" string ▁ : ▁ \" , end = \" \" ) NEW_LINE print ( string ) NEW_LINE DEDENT"],"references":["def reverseSting ( text ) : NEW_LINE INDENT index = - 1 NEW_LINE for i in range ( len ( text ) - 1 , int ( len ( text ) \/ 2 ) , - 1 ) : NEW_LINE INDENT if text [ i ] . isalpha ( ) : NEW_LINE INDENT temp = text [ i ] NEW_LINE while True : NEW_LINE INDENT index += 1 NEW_LINE if text [ index ] . isalpha ( ) : NEW_LINE INDENT text [ i ] = text [ index ] NEW_LINE text [ index ] = temp NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT return text NEW_LINE DEDENT string = \" a ! ! ! b . c . d , e ' f , ghi \" NEW_LINE print ( \" Input ▁ string : ▁ \" , string ) NEW_LINE string = reverseSting ( list ( string ) ) NEW_LINE print ( \" Output ▁ string : ▁ \" , \" \" . join ( string ) ) NEW_LINE"],"bleu":0.17390381298364802,"rouge_l":0.3851720468251153}
{"id":1435,"predictions":["import math NEW_LINE def geometricMean ( n ) : NEW_LINE INDENT return math . sqrt ( n ) NEW_LINE DEDENT def geometricMean ( n ) : NEW_LINE INDENT return math . sqrt ( n ) NEW_LINE DEDENT n = 16 NEW_LINE print ( geometricMean ( n ) ) NEW_LINE"],"references":["from math import sqrt NEW_LINE def geometricMean ( n ) : NEW_LINE INDENT return int ( sqrt ( n ) ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 16 ; NEW_LINE print ( geometricMean ( n ) ) ; NEW_LINE DEDENT"],"bleu":0.43923191851951127,"rouge_l":0.6302873748789151}
{"id":1436,"predictions":["def kPresent ( A , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( A [ i ] == k ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count \/ n NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 4 , 7 , 2 , 8 , 7 , 5 ] NEW_LINE K = 2 NEW_LINE N = len ( A ) NEW_LINE print ( kPresent ( A , N , K ) ) NEW_LINE DEDENT"],"references":["def kPresentProbability ( a , n , k ) : NEW_LINE INDENT count = a . count ( k ) NEW_LINE return round ( count \/ n , 2 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 4 , 7 , 2 , 0 , 8 , 7 , 5 ] NEW_LINE K = 2 NEW_LINE N = len ( A ) NEW_LINE print ( kPresentProbability ( A , N , K ) ) NEW_LINE DEDENT"],"bleu":0.6205096322026789,"rouge_l":0.7909584720518661}
{"id":1437,"predictions":["def checkEvenOdd ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT print ( \" Even \" ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( \" Odd \" ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 12 , 20 , 36 , 38 ] NEW_LINE n = len ( arr ) NEW_LINE checkEvenOdd ( arr , n ) NEW_LINE DEDENT"],"references":["def checkEvenOdd ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT print ( \" Even \" , end = \" \" ) ; NEW_LINE return ; NEW_LINE DEDENT DEDENT print ( \" Odd \" , end = \" \" ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 12 , 20 , 36 , 38 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE checkEvenOdd ( arr , n ) ; NEW_LINE DEDENT"],"bleu":0.7566715035019175,"rouge_l":0.9095903311881964}
{"id":1438,"predictions":["def toggleLastMoves ( n , m ) : NEW_LINE INDENT if ( m == 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT num = ( 1 << ( n + m ) ) - 1 NEW_LINE return ( n ^ num ) NEW_LINE DEDENT def largeNum ( n , m ) : NEW_LINE INDENT num = ( 1 << ( n + m ) ) - 1 NEW_LINE return toggleLastMoves ( num , m ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 2 NEW_LINE m = 2 NEW_LINE print ( largeNum ( n , m ) ) NEW_LINE DEDENT"],"references":["def toggleLastMBits ( n , m ) : NEW_LINE INDENT if ( m == 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT num = ( 1 << m ) - 1 NEW_LINE return ( n ^ num ) NEW_LINE DEDENT def largeNumWithNSetAndMUnsetBits ( n , m ) : NEW_LINE INDENT num = ( 1 << ( n + m ) ) - 1 NEW_LINE return toggleLastMBits ( num , m ) NEW_LINE DEDENT n = 2 NEW_LINE m = 2 NEW_LINE print ( largeNumWithNSetAndMUnsetBits ( n , m ) ) NEW_LINE"],"bleu":0.7159572214876335,"rouge_l":0.885516331243814}
{"id":1439,"predictions":["def series ( A , X , n ) : NEW_LINE INDENT term = pow ( A , n ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT term = term * X * ( n - i + 1 ) \/ ( i * A ) NEW_LINE print ( term , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT A = 3 NEW_LINE X = 4 NEW_LINE series ( A , X , n ) NEW_LINE"],"references":["def series ( A , X , n ) : NEW_LINE INDENT term = pow ( A , n ) NEW_LINE print ( term , end = \" ▁ \" ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT term = int ( term * X * ( n - i + 1 ) \/ ( i * A ) ) NEW_LINE print ( term , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT A = 3 ; X = 4 ; n = 5 NEW_LINE series ( A , X , n ) NEW_LINE"],"bleu":0.7471999661179375,"rouge_l":0.8784501971541232}
{"id":1440,"predictions":["def merge ( arr , l , m , r ) : NEW_LINE INDENT n1 = m - l + 1 NEW_LINE n2 = r - m NEW_LINE Lst = [ 0 ] * n NEW_LINE R = r NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT L [ i ] = arr [ i ] NEW_LINE DEDENT for i in range ( n2 ) : NEW_LINE INDENT L [ i ] = arr [ i ] NEW_LINE DEDENT for j in range ( m ) : NEW_LINE INDENT R [ j ] = arr [ j ] NEW_LINE DEDENT i = 0 NEW_LINE j = 0 NEW_LINE while ( i < n and j < n2 ) : NEW_LINE INDENT if ( L [ i ] <= R [ j ] ) : NEW_LINE INDENT arr [ i ] = L [ j ] NEW_LINE arr [ i ] = L [ j ] NEW_LINE j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = R [ j ] NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT def printArray ( arr , l , r ) : NEW_LINE INDENT for i in range ( n1 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 12 , 11 , 13 , 6 ] NEW_LINE merge ( arr , l , r ) NEW_LINE DEDENT"],"references":["def mergeSort ( a ) : NEW_LINE INDENT if len ( a ) > 1 : NEW_LINE INDENT mid = len ( a ) \/\/ 2 NEW_LINE L = a [ : mid ] NEW_LINE R = a [ mid : ] NEW_LINE mergeSort ( L ) NEW_LINE mergeSort ( R ) NEW_LINE a . clear ( ) NEW_LINE while len ( L ) > 0 and len ( R ) < 0 : NEW_LINE INDENT if L [ 0 ] <= R [ 0 ] : NEW_LINE INDENT a . append ( L [ 0 ] ) NEW_LINE L . pop ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT a . append ( R [ 0 ] ) NEW_LINE R . pop ( 0 ) NEW_LINE DEDENT DEDENT for i in L : NEW_LINE INDENT a . append ( i ) NEW_LINE DEDENT for i in R : NEW_LINE INDENT a . append ( i ) NEW_LINE DEDENT DEDENT DEDENT a = [ 12 , 11 , 13 , 5 , 6 , 7 ] NEW_LINE print ( \" Given ▁ array ▁ is \" ) NEW_LINE print ( * a ) NEW_LINE mergeSort ( a ) NEW_LINE print ( \" Sorted ▁ array ▁ is ▁ : ▁ \" ) NEW_LINE print ( * a ) NEW_LINE"],"bleu":0.17997921376092005,"rouge_l":0.39205252246026256}
{"id":1441,"predictions":["def answer ( arr , ranges , rem , index ) : NEW_LINE INDENT for i in range ( index - 1 , - 1 , - 1 ) : NEW_LINE INDENT left = ranges [ i ] [ 0 ] NEW_LINE right = ranges [ i ] [ 1 ] NEW_LINE if ( left <= index and right >= index ) : NEW_LINE INDENT index = right + left - 1 NEW_LINE DEDENT else : NEW_LINE INDENT left = right + left - left NEW_LINE DEDENT DEDENT return arr [ rem ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ [ 10 , 20 , 30 , 40 , 50 ] , [ 0 , 2 , 2 ] ] NEW_LINE ranges = 2 NEW_LINE print ( answer ( arr , ranges , index ) ) NEW_LINE DEDENT"],"references":["def answer ( arr , ranges , reversals , index ) : NEW_LINE INDENT i = reversals - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT left = ranges [ i ] [ 0 ] NEW_LINE right = ranges [ i ] [ 1 ] NEW_LINE if ( left <= index and right >= index ) : NEW_LINE INDENT index = right + left - index NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT return arr [ index ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 10 , 20 , 30 , 40 , 50 ] NEW_LINE reversals = 2 NEW_LINE ranges = [ [ 1 , 4 ] , [ 0 , 2 ] ] NEW_LINE index = 1 NEW_LINE print ( answer ( arr , ranges , reversals , index ) ) NEW_LINE DEDENT"],"bleu":0.725684810614629,"rouge_l":0.7919463087248322}
{"id":1442,"predictions":["def isDivisibleBy25 ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return ( ( ord ( str [ n - 1 ] ) - ord ( '0' ) ) + ( ord ( str [ n - 2 ] ) - ord ( '0' ) ) ) NEW_LINE DEDENT if ( ( str [ n - 1 ] ) >= ord ( str [ n - 2 ] ) ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE return \" No \" NEW_LINE DEDENT str = \"76960\" NEW_LINE if ( isDivisibleBy25 ( str ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def isDivisibleBy25 ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return ( ( int ) ( st [ n - 1 ] ) == 0 and ( ( int ) ( st [ n - 2 ] ) == 0 ) or ( ( int ) ( st [ n - 2 ] ) * 10 + ( int ) ( st [ n - 1 ] ) % 25 == 0 ) ) NEW_LINE DEDENT st = \"76955\" NEW_LINE if ( isDivisibleBy25 ( st ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.5504612063882792,"rouge_l":0.7115909655001241}
{"id":1443,"predictions":["def squareSum ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return ( squareSum ( int ( n \/ 2 ) ) + squareSum ( int ( n \/ 2 ) ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return squareSum ( int ( n \/ 2 ) + squareSum ( int ( n \/ 2 ) ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return squareSum ( int ( ( n \/ 2 ) ) + squareSum ( int ( n \/ 2 ) ) ) ; NEW_LINE DEDENT DEDENT def oddSum ( a , b ) : NEW_LINE INDENT return ( b - sum ( a ) ) + squareSum ( a - 1 ) ; NEW_LINE DEDENT a = 3 ; NEW_LINE b = 9 ; NEW_LINE print ( oddSum ( a , b ) ) ; NEW_LINE"],"references":["def square ( n ) : NEW_LINE INDENT return n * n ; NEW_LINE DEDENT def sum ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return ( square ( int ( ( n + 1 ) \/ 2 ) ) + sum ( int ( n \/ 2 ) ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return ( square ( int ( n \/ 2 ) ) + sum ( int ( n \/ 2 ) ) ) ; NEW_LINE DEDENT DEDENT def oddDivSum ( a , b ) : NEW_LINE INDENT return sum ( b ) - sum ( a - 1 ) ; NEW_LINE DEDENT a , b = 3 , 9 ; NEW_LINE print ( oddDivSum ( a , b ) ) ; NEW_LINE"],"bleu":0.6653671836101887,"rouge_l":0.7690945087006357}
{"id":1444,"predictions":["def removeOddFrequency ( s ) : NEW_LINE INDENT m = { } NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT p = len ( s [ i ] ) NEW_LINE if p in m : NEW_LINE INDENT m [ p ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT m [ p ] = 1 NEW_LINE DEDENT DEDENT new_string = \" \" NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( m [ i ] & 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT new_string += s [ i ] NEW_LINE DEDENT return new_string NEW_LINE DEDENT str = \" geeksforgeeks \" NEW_LINE str = removeOddFrequency ( str ) NEW_LINE str = \" \" NEW_LINE print ( removeOddFrequency ( str ) ) NEW_LINE"],"references":["def removeOddFrequencyCharacters ( s ) : NEW_LINE INDENT m = dict ( ) NEW_LINE for i in s : NEW_LINE INDENT m [ i ] = m . get ( i , 0 ) + 1 NEW_LINE DEDENT new_s = \" \" NEW_LINE for i in s : NEW_LINE INDENT if ( m [ i ] & 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT new_s += i NEW_LINE DEDENT return new_s NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" geeksforgeeks \" NEW_LINE str = removeOddFrequencyCharacters ( str ) NEW_LINE print ( str ) NEW_LINE DEDENT"],"bleu":0.40765715289573773,"rouge_l":0.6362119315811431}
{"id":1445,"predictions":["def countNonDecreasing ( n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 1 NEW_LINE DEDENT for digit in range ( 2 , n + 1 ) : NEW_LINE INDENT for x in range ( 2 ) : NEW_LINE INDENT dp [ digit ] [ x ] += dp [ digit ] [ x ] NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT count += dp [ i ] [ 0 ] NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE print ( countNonDecreasing ( n ) ) NEW_LINE DEDENT"],"references":["def countNonDecreasing ( n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n + 1 ) ] for i in range ( 10 ) ] NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT dp [ i ] [ 1 ] = 1 NEW_LINE DEDENT for digit in range ( 10 ) : NEW_LINE INDENT for len in range ( 2 , n + 1 ) : NEW_LINE INDENT for x in range ( digit + 1 ) : NEW_LINE INDENT dp [ digit ] [ len ] += dp [ x ] [ len - 1 ] NEW_LINE DEDENT DEDENT DEDENT count = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT count += dp [ i ] [ n ] NEW_LINE DEDENT return count NEW_LINE DEDENT n = 3 NEW_LINE print ( countNonDecreasing ( n ) ) NEW_LINE"],"bleu":0.7567078537451242,"rouge_l":0.840835666594874}
{"id":1446,"predictions":["from collections import defaultdict NEW_LINE def maxCount ( n , a ) : NEW_LINE INDENT freq = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] not in freq : NEW_LINE INDENT freq [ a [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ a [ i ] ] += 1 NEW_LINE freq [ a [ i ] ] += 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( freq ) : NEW_LINE INDENT if freq [ a [ i ] ] + freq [ a [ i ] ] NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 NEW_LINE arr = [ 2 , 2 , 3 , 4 ] NEW_LINE print ( maxCount ( n , arr ) ) NEW_LINE DEDENT"],"references":["def maxCount ( a ) : NEW_LINE INDENT freq = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] in freq ) : NEW_LINE INDENT freq [ a [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ a [ i ] ] = 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for key , value in freq . items ( ) : NEW_LINE INDENT if ( key + 1 in freq ) : NEW_LINE INDENT ans = max ( ans , freq [ key ] + freq [ key + 1 ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT n = 5 NEW_LINE arr = [ 2 , 2 , 3 , 4 , 5 ] NEW_LINE print ( maxCount ( arr ) ) NEW_LINE"],"bleu":0.5477110386911442,"rouge_l":0.716374916906714}
{"id":1447,"predictions":["import math NEW_LINE def dist ( x1 , x2 , y2 ) : NEW_LINE INDENT return ( ( x1 - x2 ) ** 2 + ( math . sqrt ( x2 - x1 ) ** 2 ) ) NEW_LINE DEDENT def distance ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT print ( \" The ▁ distance ▁ distance \" , ( x2 - x1 ) ** 2 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x1 , y1 , x2 , y2 = 4 , 5 , 45 NEW_LINE distance ( x1 , y1 , x2 , y2 ) NEW_LINE DEDENT"],"references":["def dist ( x1 , y1 , x2 , y2 , r ) : NEW_LINE INDENT print ( \" The ▁ shortest ▁ distance ▁ between ▁ a ▁ point ▁ and ▁ a ▁ circle ▁ is ▁ \" , ( ( ( ( x2 - x1 ) ** 2 ) + ( ( y2 - y1 ) ** 2 ) ) ** ( 1 \/ 2 ) ) - r ) ; NEW_LINE DEDENT x1 = 4 ; NEW_LINE y1 = 6 ; NEW_LINE x2 = 35 ; NEW_LINE y2 = 42 ; NEW_LINE r = 5 ; NEW_LINE dist ( x1 , y1 , x2 , y2 , r ) ; NEW_LINE"],"bleu":0.36345192706953666,"rouge_l":0.43790380473797563}
{"id":1448,"predictions":["class Graph : NEW_LINE INDENT def __init__ ( self , x , y ) : NEW_LINE INDENT self . graph = x NEW_LINE self . graph = [ None ] * ( y + 1 ) NEW_LINE DEDENT def add ( self , x ) : NEW_LINE INDENT self . graph [ x ] . parent [ x ] = y NEW_LINE self . graph [ y ] . graph [ x ] . append ( y ) NEW_LINE DEDENT def dfs ( self , x ) : NEW_LINE INDENT self . graph [ x ] . parent [ y ] = self . graph [ y ] NEW_LINE return self . root ( x ) NEW_LINE DEDENT def maxValue ( n , self ) : NEW_LINE INDENT val = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( self . graph [ i ] == 0 ) : NEW_LINE INDENT self . graph [ i ] = self . graph [ i ] . graph [ i ] NEW_LINE DEDENT DEDENT return self . graph [ n ] NEW_LINE DEDENT def maxValue ( n , x ) : NEW_LINE INDENT val = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if ( self . graph [ i ] == x ) : NEW_LINE INDENT val += dfs ( i , x ) NEW_LINE DEDENT DEDENT return self . path [ n ] NEW_LINE DEDENT DEDENT def maxValue ( n , src ) : NEW_LINE INDENT val = 0 NEW_LINE v = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( v [ i ] == 0 ) : NEW_LINE INDENT val += dfs ( i , src , self . graph [ i ] [ src ] ) NEW_LINE DEDENT return val NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE graph = Graph ( n , adj ) NEW_LINE v = [ [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( maxValue ( n , v ) ) NEW_LINE DEDENT DEDENT"],"references":["def dfs ( x , adj , vis ) : NEW_LINE INDENT sz = 1 NEW_LINE vis [ x ] = 1 NEW_LINE for ch in adj : NEW_LINE INDENT if ( not vis [ ch ] ) : NEW_LINE INDENT sz += dfs ( ch , adj , vis ) NEW_LINE DEDENT DEDENT return sz NEW_LINE DEDENT def maxValue ( n , adj ) : NEW_LINE INDENT val = 0 NEW_LINE vis = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( not vis [ i ] ) : NEW_LINE INDENT val += dfs ( i , adj , vis ) - 1 NEW_LINE DEDENT DEDENT return val NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE adj = [ 1 , 2 , 2 , 3 ] NEW_LINE print ( maxValue ( n , adj ) ) NEW_LINE DEDENT"],"bleu":0.2311595211216373,"rouge_l":0.480851343362018}
{"id":1449,"predictions":["from math import tan NEW_LINE def area_of_volume ( n , l ) : NEW_LINE INDENT P = ( l * n ) \/ ( 2 * math . pi \/ 180.14159 \/ 180.14159 ( 2 * l ) ) ; NEW_LINE R = ( ( R * math . sin ( 180 \/ n ) * 3.14159 ) ; NEW_LINE area_triangles = ( R * a ) \/ 2.14159265 ) ; NEW_LINE return area_triangles ; NEW_LINE DEDENT def area_triangles ( n , len ) : NEW_LINE INDENT area = area_of_volume ( n , len ) ; NEW_LINE return area ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 ; NEW_LINE len = 10 ; NEW_LINE print ( area_of_triangles ( n , len ) ) ; NEW_LINE DEDENT"],"references":["import math NEW_LINE def area_of_regular_polygon ( n , len ) : NEW_LINE INDENT P = ( len * n ) ; NEW_LINE A = len \/ ( 2 * math . tan ( ( 180 \/ n ) * 3.14159 \/ 180 ) ) NEW_LINE area = ( P * A ) \/ 2 NEW_LINE return area NEW_LINE DEDENT def area_of_triangle_inscribed ( n , len ) : NEW_LINE INDENT area = area_of_regular_polygon ( n , len ) NEW_LINE triangle = area \/ n NEW_LINE ins_tri = ( triangle * 3 ) ; NEW_LINE return ins_tri NEW_LINE DEDENT n = 6 NEW_LINE len = 10 NEW_LINE print ( round ( area_of_triangle_inscribed ( n , len ) , 3 ) ) NEW_LINE"],"bleu":0.3586426170973941,"rouge_l":0.6143318269851517}
{"id":1450,"predictions":["def centeredHexagonalNumber ( n ) : NEW_LINE INDENT return 3 * n * ( n - 1 ) + 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 10 NEW_LINE print ( n , \" th ▁ centered ▁ centered ▁ Centagonal ▁ \" , centeredHexagonalNumber ( n ) ) NEW_LINE DEDENT"],"references":["def centeredHexagonalNumber ( n ) : NEW_LINE INDENT return 3 * n * ( n - 1 ) + 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE print ( n , \" th ▁ centered ▁ hexagonal ▁ number : ▁ \" , centeredHexagonalNumber ( n ) ) NEW_LINE DEDENT"],"bleu":0.829807462108578,"rouge_l":0.9254724514240086}
{"id":1451,"predictions":["def isOrthogonal ( a , m , n ) : NEW_LINE INDENT if ( m != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT sum = sum + ( a [ k ] * a [ j ] ) NEW_LINE DEDENT if ( i != j and sum != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( i != j and sum != 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( i != j and sum != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ [ 1 , 0 , 0 ] , [ 0 , 1 , 0 ] ] NEW_LINE if ( isOrthogonal ( a , 3 , 3 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def isOrthogonal ( a , m , n ) : NEW_LINE INDENT if ( m != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for k in range ( 0 , n ) : NEW_LINE INDENT sum = sum + ( a [ i ] [ k ] * a [ j ] [ k ] ) NEW_LINE DEDENT DEDENT if ( i == j and sum != 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( i != j and sum != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT a = [ [ 1 , 0 , 0 ] , [ 0 , 1 , 0 ] , [ 0 , 0 , 1 ] ] NEW_LINE if ( isOrthogonal ( a , 3 , 3 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.8009474029612568,"rouge_l":0.8315789473684211}
{"id":1452,"predictions":["def mean ( prev , x , n ) : NEW_LINE INDENT return ( prev_av * n + x ) \/ ( n + 1 ) ; NEW_LINE DEDENT def stream avg ( arr , n ) : NEW_LINE INDENT avg = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT avg = getAvg ( avg , arr [ i ] , i ) ; NEW_LINE DEDENT return avg ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 10 , 20 , 30 , 50 , 60 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE streamAvg ( arr , n ) ; NEW_LINE print ( \" Mean ▁ of ▁ the ▁ numbers ▁ is \" , stream ( arr , n ) ) ; NEW_LINE DEDENT"],"references":["def getAvg ( prev_avg , x , n ) : NEW_LINE INDENT return ( ( prev_avg * n + x ) \/ ( n + 1 ) ) ; NEW_LINE DEDENT def streamAvg ( arr , n ) : NEW_LINE INDENT avg = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT avg = getAvg ( avg , arr [ i ] , i ) ; NEW_LINE print ( \" Average ▁ of ▁ \" , i + 1 , \" ▁ numbers ▁ is ▁ \" , avg ) ; NEW_LINE DEDENT DEDENT arr = [ 10 , 20 , 30 , 40 , 50 , 60 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE streamAvg ( arr , n ) ; NEW_LINE"],"bleu":0.6934686180005174,"rouge_l":0.7335257335257336}
{"id":1453,"predictions":["def minOperation ( n , h , cost ) : NEW_LINE INDENT c_h = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT c_h += abs ( h [ i ] - e [ i ] * cost_h ) ; NEW_LINE DEDENT c = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT c += abs ( h [ i ] - e [ i ] ) * cost_h ; NEW_LINE DEDENT return c ; NEW_LINE DEDENT def binSearch ( n , h , cost ) : NEW_LINE INDENT max_h = max ( hh , cost ) ; NEW_LINE ans = float ( ' inf ' ) ; NEW_LINE return ans ; NEW_LINE DEDENT def costOfOperation ( n , h , cost ) : NEW_LINE INDENT max_h = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( low + h [ i ] ) != float ( ' inf ' ) ) : NEW_LINE INDENT mid = int ( low + h [ i ] ) + costOfOperation ( n , h , cost - 1 ) ; NEW_LINE if ( ans < m ) : NEW_LINE INDENT max_h , cost ) ; NEW_LINE DEDENT elif ( ans < m ) : NEW_LINE INDENT ans = min ( ans , m ) ; NEW_LINE DEDENT DEDENT elif ( ans != - 1 ) : NEW_LINE INDENT return ans ; NEW_LINE DEDENT else : NEW_LINE INDENT return ans ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT h = [ [ 1 , 2 ] , [ 10 , 3 ] ] ; NEW_LINE cost = [ 10 , 2 , 100 ] ; NEW_LINE n = len ( h ) ; NEW_LINE cost = costSearchOperation ( n , h , cost ) ; NEW_LINE print ( cost ) ; NEW_LINE DEDENT"],"references":["import sys NEW_LINE def costOfOperation ( n , h , cost , eq_h ) : NEW_LINE INDENT c = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT c += abs ( h [ i ] - eq_h ) * cost [ i ] NEW_LINE DEDENT return c NEW_LINE DEDENT def Bsearch ( n , h , cost ) : NEW_LINE INDENT max_h = h [ 0 ] NEW_LINE for i in range ( len ( h ) ) : NEW_LINE INDENT if ( h [ i ] > max_h ) : NEW_LINE INDENT max_h = h [ i ] NEW_LINE DEDENT DEDENT ans = sys . maxsize NEW_LINE high = 1 + max_h NEW_LINE low = 0 NEW_LINE while ( high > low ) : NEW_LINE INDENT mid = ( low + high ) >> 1 NEW_LINE if ( mid > 0 ) : NEW_LINE INDENT bm = costOfOperation ( n , h , cost , mid - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT bm = sys . maxsize NEW_LINE DEDENT m = costOfOperation ( n , h , cost , mid ) NEW_LINE am = costOfOperation ( n , h , cost , mid + 1 ) NEW_LINE if ( ans == m ) : NEW_LINE INDENT break NEW_LINE DEDENT ans = min ( ans , m ) NEW_LINE if ( bm <= m ) : NEW_LINE INDENT high = mid NEW_LINE DEDENT elif ( am <= m ) : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return m ; NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT h = [ 1 , 2 , 3 ] NEW_LINE cost = [ 10 , 100 , 1000 ] NEW_LINE n = len ( h ) NEW_LINE print ( Bsearch ( n , h , cost ) ) NEW_LINE DEDENT"],"bleu":0.47974240215129554,"rouge_l":0.5763682967281499}
{"id":1454,"predictions":["def check ( a , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT a = [ 0 , 1 , 0 , 1 ] NEW_LINE n = len ( a ) NEW_LINE if ( check ( a , n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"],"references":["def check ( a , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 0 , 1 , 0 , 1 ] NEW_LINE n = len ( a ) NEW_LINE if ( check ( a , n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.8314574780098036,"rouge_l":0.9083388484447387}
{"id":1455,"predictions":["def findIndex ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT a = 0 NEW_LINE b = 1 NEW_LINE c = 1 NEW_LINE res = 1 NEW_LINE while ( c < n ) : NEW_LINE INDENT c = a + b NEW_LINE res = res + 1 NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT result = findIndex ( 21 ) NEW_LINE print ( result ) NEW_LINE DEDENT"],"references":["def findIndex ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT a = 0 NEW_LINE b = 1 NEW_LINE c = 1 NEW_LINE res = 1 NEW_LINE while ( c < n ) : NEW_LINE INDENT c = a + b NEW_LINE res = res + 1 NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return res NEW_LINE DEDENT result = findIndex ( 21 ) NEW_LINE print ( result ) NEW_LINE"],"bleu":0.8183965998535668,"rouge_l":0.8776136581622866}
{"id":1456,"predictions":["def sumNth ( A , B , m , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return A [ 0 ] NEW_LINE DEDENT elif ( n == 2 ) : NEW_LINE INDENT F = [ 0 ] * m NEW_LINE DEDENT else : NEW_LINE INDENT F = [ 0 ] * n NEW_LINE f [ 0 ] = 0 NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT for i in range ( m ) : NEW_LINE INDENT res = res + ( ( A [ i - 1 ] * f [ n - 2 ] ) * f [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT f = ( res + ( A [ i ] * f [ n - 1 ] ) + ( A [ i ] * f [ n - 2 ] ) ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT A = [ 1 , 2 , 3 ] NEW_LINE B = [ 4 , 5 ] NEW_LINE m = len ( A ) NEW_LINE n = len ( B ) NEW_LINE print ( sumNth ( A , B , m , n ) ) NEW_LINE"],"references":["def sumNth ( A , B , m , n ) : NEW_LINE INDENT res = 0 ; NEW_LINE if ( n == 1 ) : NEW_LINE INDENT for i in range ( m ) : NEW_LINE INDENT res = res + A [ i ] ; NEW_LINE DEDENT DEDENT elif ( n == 2 ) : NEW_LINE INDENT for i in range ( m ) : NEW_LINE INDENT res = res + B [ i ] * m ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT f = [ 0 ] * n ; NEW_LINE f [ 0 ] = 0 ; NEW_LINE f [ 1 ] = 1 ; NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT f [ i ] = f [ i - 1 ] + f [ i - 2 ] ; NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT res = ( res + ( m * ( B [ i ] * f [ n - 1 ] ) ) + ( m * ( A [ i ] * f [ n - 2 ] ) ) ) ; NEW_LINE DEDENT DEDENT return res ; NEW_LINE DEDENT A = [ 1 , 2 , 3 ] ; NEW_LINE B = [ 4 , 5 , 6 ] ; NEW_LINE n = 3 ; NEW_LINE m = len ( A ) ; NEW_LINE print ( sumNth ( A , B , m , n ) ) ; NEW_LINE"],"bleu":0.5606073169247556,"rouge_l":0.7088174982911826}
{"id":1457,"predictions":["def isVowel ( c ) : NEW_LINE INDENT return ( ( c == ' a ' or c == ' e ' or c == ' i ' or c == ' o ' or c == ' u ' or c == ' A ' or c == ' E ' or c == ' O ' or c == ' U ' ) ) NEW_LINE DEDENT def reverseVowel ( str1 , str1 ) : NEW_LINE INDENT j = 0 NEW_LINE vowel = str1 [ 0 ] NEW_LINE vowel = \" \" NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT if ( isVowel ( str [ i ] ) ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( isVowel ( str1 [ i ] ) ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( len ( str1 ) ) : NEW_LINE INDENT if ( isVowel ( str1 [ i ] ) ) : NEW_LINE INDENT str1 [ i ] = str1 [ j ] NEW_LINE str1 [ j ] = str [ i ] NEW_LINE DEDENT DEDENT DEDENT str1 = \" hello \" NEW_LINE str2 = str1 [ : : - 1 ] NEW_LINE print ( reversed ( str1 ) ) NEW_LINE"],"references":["def isVowel ( c ) : NEW_LINE INDENT if ( c == ' a ' or c == ' A ' or c == ' e ' or c == ' E ' or c == ' i ' or c == ' I ' or c == ' o ' or c == ' O ' or c == ' u ' or c == ' U ' ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def reverserVowel ( string ) : NEW_LINE INDENT j = 0 NEW_LINE vowel = [ 0 ] * len ( string ) NEW_LINE string = list ( string ) NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if isVowel ( string [ i ] ) : NEW_LINE INDENT vowel [ j ] = string [ i ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT for i in range ( len ( string ) ) : NEW_LINE INDENT if isVowel ( string [ i ] ) : NEW_LINE INDENT j -= 1 NEW_LINE string [ i ] = vowel [ j ] NEW_LINE DEDENT DEDENT return ' ' . join ( string ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" hello ▁ world \" NEW_LINE print ( reverserVowel ( string ) ) NEW_LINE DEDENT"],"bleu":0.593041831967535,"rouge_l":0.6774844944468484}
{"id":1458,"predictions":["def minimumCost ( cost , n ) : NEW_LINE INDENT dp1 = 0 NEW_LINE d2 = 0 NEW_LINE dp1 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp1 += min ( cost1 , dp2 ) NEW_LINE dp2 = dp1 NEW_LINE if ( dp1 , dp2 ) : NEW_LINE INDENT dp1 = dp2 NEW_LINE dp2 = dp1 NEW_LINE DEDENT DEDENT return min ( dp1 , dp2 ) NEW_LINE DEDENT a = [ 2 , 5 , 3 , 1 , 7 , 4 ] NEW_LINE n = len ( a ) NEW_LINE print ( minimumCost ( a , n ) ) NEW_LINE"],"references":["def minimumCost ( cost , n ) : NEW_LINE INDENT dp1 = 0 NEW_LINE dp2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp0 = cost [ i ] + min ( dp1 , dp2 ) NEW_LINE dp2 = dp1 NEW_LINE dp1 = dp0 NEW_LINE DEDENT return min ( dp1 , dp2 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 2 , 5 , 3 , 1 , 7 , 3 , 4 ] NEW_LINE n = len ( a ) NEW_LINE print ( minimumCost ( a , n ) ) NEW_LINE DEDENT"],"bleu":0.7162206585736337,"rouge_l":0.7701551566778216}
{"id":1459,"predictions":["def isVowel ( ch ) : NEW_LINE INDENT return ( ch == ' a ' or ch == ' e ' or ch == ' i ' or ch == ' o ' or ch == ' u ' ) ; NEW_LINE DEDENT def countVowels ( string , l , r ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if ( isVowel ( string [ i ] ) ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT return cnt ; NEW_LINE DEDENT def performQueries ( string , queries , q ) : NEW_LINE INDENT for i in range ( q ) : NEW_LINE INDENT if ( isVowel ( string [ i ] ) ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT return cnt ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" geeksforgeeks \" ; NEW_LINE queries = [ [ 1 , 3 ] , [ 2 , 4 ] ] ; NEW_LINE q = len ( queries ) ; NEW_LINE for i in range ( q ) : NEW_LINE INDENT print ( countVowels ( string , queries [ i ] [ 0 ] , queries [ i ] [ 1 ] ) ) ; NEW_LINE DEDENT DEDENT"],"references":["N = 2 ; NEW_LINE def isVowel ( ch ) : NEW_LINE INDENT return ( ch == ' a ' or ch == ' e ' or ch == ' i ' or ch == ' o ' or ch == ' u ' ) ; NEW_LINE DEDENT def countVowels ( string , l , r ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if ( isVowel ( string [ i ] ) ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT return cnt ; NEW_LINE DEDENT def performQueries ( string , queries , q ) : NEW_LINE INDENT for i in range ( q ) : NEW_LINE INDENT print ( countVowels ( string , queries [ i ] [ 0 ] , queries [ i ] [ 1 ] ) ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" geeksforgeeks \" ; NEW_LINE queries = [ [ 1 , 3 ] , [ 2 , 4 ] , [ 1 , 9 ] ] ; NEW_LINE q = len ( queries ) NEW_LINE performQueries ( string , queries , q ) ; NEW_LINE DEDENT"],"bleu":0.8532183707440154,"rouge_l":0.8464637421665174}
{"id":1460,"predictions":["def removeAlternate ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return 2 * min ( n \/\/ 2 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return 2 * min ( ( ( n \/\/ 2 ) ) + 1 ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 ; NEW_LINE print ( removeAlternate ( n ) ) ; NEW_LINE DEDENT"],"references":["def removeAlternate ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return 2 * removeAlternate ( n \/ 2 ) - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 * removeAlternate ( ( ( n - 1 ) \/ 2 ) ) + 1 NEW_LINE DEDENT DEDENT n = 5 NEW_LINE print ( removeAlternate ( n ) ) NEW_LINE n = 10 NEW_LINE print ( removeAlternate ( n ) ) NEW_LINE"],"bleu":0.6004693600341435,"rouge_l":0.7640918580375783}
{"id":1461,"predictions":["import math NEW_LINE def lowerWITHonacci ( n ) : NEW_LINE INDENT phi = ( 1 + math . sqrt ( 5 ) ) \/ 2 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = round ( i * phi , 5 ) NEW_LINE DEDENT if ( i != n ) : NEW_LINE INDENT print ( \" , ▁ \" , end = \" \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE lowerWphonacci ( n ) NEW_LINE DEDENT"],"references":["from math import sqrt , floor NEW_LINE def lowerWythoff ( n ) : NEW_LINE INDENT phi = ( 1 + sqrt ( 5 ) ) \/ 2 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = floor ( i * phi ) ; NEW_LINE print ( ans , end = \" \" ) ; NEW_LINE if ( i != n ) : NEW_LINE INDENT print ( \" , ▁ \" , end = \" \" ) ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 ; NEW_LINE lowerWythoff ( n ) ; NEW_LINE DEDENT"],"bleu":0.5964330943791215,"rouge_l":0.8207105064247922}
{"id":1462,"predictions":["def countPairs ( str ) : NEW_LINE INDENT result = 0 NEW_LINE n = len ( str ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( abs ( str [ i ] - str [ j ] ) == abs ( int ( i - j ) ) ) : NEW_LINE INDENT result = result + 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT str = \" geeksforgeeks \" NEW_LINE print ( countPairs ( str ) ) NEW_LINE"],"references":["def countPairs ( str1 ) : NEW_LINE INDENT result = 0 ; NEW_LINE n = len ( str1 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( abs ( ord ( str1 [ i ] ) - ord ( str1 [ j ] ) ) == abs ( i - j ) ) : NEW_LINE INDENT result += 1 ; NEW_LINE DEDENT DEDENT DEDENT return result ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" geeksforgeeks \" ; NEW_LINE print ( countPairs ( str1 ) ) ; NEW_LINE DEDENT"],"bleu":0.5258569334846832,"rouge_l":0.7748892171344166}
{"id":1463,"predictions":["import math NEW_LINE def checkPowerof8 ( n ) : NEW_LINE INDENT i = math . log ( n \/ math . log ( 8 ) ) ; NEW_LINE return ( i - math . log ( n ) ) ; NEW_LINE DEDENT n = 65 ; NEW_LINE if ( checkPowerof8 ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT"],"references":["from math import log , trunc NEW_LINE def checkPowerof8 ( n ) : NEW_LINE INDENT i = log ( n , 8 ) NEW_LINE return ( i - trunc ( i ) < 0.000001 ) ; NEW_LINE DEDENT n = 65 NEW_LINE if checkPowerof8 ( n ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.5644327465576576,"rouge_l":0.814238042269188}
{"id":1464,"predictions":["def digitsNum ( N ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT print ( \"0\" , end = \" \" ) NEW_LINE DEDENT if ( N % 9 != 0 ) : NEW_LINE INDENT print ( \"0\" , end = \" \" ) NEW_LINE DEDENT for i in range ( 1 , ( N \/\/ 9 ) + 1 ) : NEW_LINE INDENT print ( \"9\" , end = \" \" ) NEW_LINE DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( \"0\" , end = \" \" ) NEW_LINE digitsNum ( N ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 NEW_LINE printNum ( N ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def digitsNum ( N ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT print ( \"0\" , end = \" \" ) NEW_LINE DEDENT if ( N % 9 != 0 ) : NEW_LINE INDENT print ( N % 9 , end = \" \" ) NEW_LINE DEDENT for i in range ( 1 , int ( N \/ 9 ) + 1 ) : NEW_LINE INDENT print ( \"9\" , end = \" \" ) NEW_LINE DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( \"0\" , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT N = 5 NEW_LINE print ( \" The ▁ number ▁ is ▁ : ▁ \" , end = \" \" ) NEW_LINE digitsNum ( N ) NEW_LINE"],"bleu":0.7486572150688804,"rouge_l":0.8135253157087218}
{"id":1465,"predictions":["def printFirstNegativeInteger ( arr , n , k ) : NEW_LINE INDENT Diagonal = [ ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT diagonal . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 12 , - 1 , - 7 , 8 , - 15 , 30 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE printFirstNegnegativeInteger ( arr , n , k ) NEW_LINE DEDENT"],"references":["from collections import deque NEW_LINE def printFirstNegativeInteger ( arr , n , k ) : NEW_LINE INDENT Di = deque ( ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT Di . append ( i ) ; NEW_LINE DEDENT DEDENT for i in range ( k , n ) : NEW_LINE INDENT if ( not Di ) : NEW_LINE INDENT print ( 0 , end = ' ▁ ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ Di [ 0 ] ] , end = ' ▁ ' ) ; NEW_LINE DEDENT while Di and Di [ 0 ] <= ( i - k ) : NEW_LINE INDENT Di . popleft ( ) NEW_LINE DEDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT Di . append ( i ) ; NEW_LINE DEDENT DEDENT if not Di : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ Di [ 0 ] ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 12 , - 1 , - 7 , 8 , - 15 , 30 , 16 , 28 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE printFirstNegativeInteger ( arr , n , k ) ; NEW_LINE DEDENT"],"bleu":0.46501355858545534,"rouge_l":0.6674372014177841}
{"id":1466,"predictions":["def findFirstAndLast ( arr , x ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE first = - 1 NEW_LINE last = - 1 NEW_LINE last = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( x != arr [ i ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( first == - 1 ) : NEW_LINE INDENT first = i NEW_LINE last = i NEW_LINE DEDENT if ( first != - 1 ) : NEW_LINE INDENT first = arr [ i ] NEW_LINE last = i NEW_LINE DEDENT DEDENT DEDENT if ( first != - 1 ) : NEW_LINE INDENT print ( \" Last ▁Occurrence ▁ = \" , first ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Last ▁ occur ▁ = \" , first ) NEW_LINE DEDENT"],"references":["def findFirstAndLast ( arr , n , x ) : NEW_LINE INDENT first = - 1 NEW_LINE last = - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( x != arr [ i ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( first == - 1 ) : NEW_LINE INDENT first = i NEW_LINE DEDENT last = i NEW_LINE DEDENT if ( first != - 1 ) : NEW_LINE INDENT print ( \" First ▁ Occurrence ▁ = ▁ \" , first , \" ▁ \\n Last ▁ Occurrence ▁ = ▁ \" , last ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ Found \" ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 2 , 2 , 2 , 3 , 4 , 7 , 8 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE x = 8 NEW_LINE findFirstAndLast ( arr , n , x ) NEW_LINE"],"bleu":0.5728432487269971,"rouge_l":0.6291969266393013}
{"id":1467,"predictions":["NO_OF_CHARS = 256 NEW_LINE def areAllAnagrams ( str1 , str2 ) : NEW_LINE INDENT count = [ 0 ] * NO_OF_CHARS NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT count [ ord ( str1 [ i ] ) ] += 1 NEW_LINE DEDENT for i in range ( len ( str1 ) ) : NEW_LINE INDENT count [ ord ( str1 [ i ] ) ] -= 1 NEW_LINE DEDENT for i in range ( NO_OF_CHARS ) : NEW_LINE INDENT if ( count [ i ] != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def findAllAnagrams ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def printAllAnagrams ( arr , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( checkAllAnagrams ( arr [ i ] , arr [ j ] ) ) : NEW_LINE INDENT print ( arr [ i ] , arr [ j ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ \" geeksforgeeks \" , \" z \" ] NEW_LINE n = len ( arr ) NEW_LINE findAllAnagrams ( arr , n ) NEW_LINE DEDENT"],"references":["NO_OF_CHARS = 256 NEW_LINE def areAnagram ( str1 : str , str2 : str ) -> bool : NEW_LINE INDENT count = [ 0 ] * NO_OF_CHARS NEW_LINE i = 0 NEW_LINE while i < len ( str1 ) and i < len ( str2 ) : NEW_LINE INDENT count [ ord ( str1 [ i ] ) ] += 1 NEW_LINE count [ ord ( str2 [ i ] ) ] -= 1 NEW_LINE i += 1 NEW_LINE DEDENT if len ( str1 ) != len ( str2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( NO_OF_CHARS ) : NEW_LINE INDENT if count [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT DEDENT def findAllAnagrams ( arr : list , n : int ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if areAnagram ( arr [ i ] , arr [ j ] ) : NEW_LINE INDENT print ( arr [ i ] , \" is ▁ anagram ▁ of \" , arr [ j ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ \" geeksquiz \" , \" geeksforgeeks \" , \" abcd \" , \" forgeeksgeeks \" , \" zuiqkeegs \" ] NEW_LINE n = len ( arr ) NEW_LINE findAllAnagrams ( arr , n ) NEW_LINE DEDENT"],"bleu":0.6828127038668627,"rouge_l":0.7428850537284272}
{"id":1468,"predictions":["MAX = 100 NEW_LINE arr = [ 0 ] * MAX NEW_LINE arr [ 0 ] = 0 NEW_LINE arr [ 1 ] = 0 NEW_LINE for i in range ( 2 , MAX ) : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] + arr [ i - 2 ] NEW_LINE DEDENT for i in range ( 1 , MAX ) : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] + arr [ i - 2 ] NEW_LINE DEDENT for i in range ( 1 , MAX , 1 ) : NEW_LINE INDENT if arr [ i ] % i == 0 : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT"],"references":["if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT MAX = 100 NEW_LINE arr = [ 0 for i in range ( MAX ) ] NEW_LINE arr [ 0 ] = 0 NEW_LINE arr [ 1 ] = 1 NEW_LINE for i in range ( 2 , MAX ) : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] + arr [ i - 2 ] NEW_LINE DEDENT print ( \" Fibonacci ▁ numbers ▁ divisible ▁ by ▁ their ▁ indexes ▁ are ▁ : \" ) NEW_LINE for i in range ( 1 , MAX ) : NEW_LINE INDENT if ( arr [ i ] % i == 0 ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT"],"bleu":0.6573038302423988,"rouge_l":0.7104327571411058}
{"id":1469,"predictions":["def isPossible ( Sx , Sy , x , y , y ) : NEW_LINE INDENT if ( abs ( Sx - Dx ) % x == 0 and abs ( Sx - Y ) % y == 0 and ( abs ( Sx - D ) \/\/ y ) % 2 == 0 and ( abs ( Sx - Sy ) \/\/ y ) % 2 == 0 ) ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT Sx , Sy , 0 , 0 ; NEW_LINE DEDENT Sx , Sy , 0 , print ( \" Yes \" ) ; NEW_LINE DEDENT"],"references":["def isPossible ( Sx , Sy , Dx , Dy , x , y ) : NEW_LINE INDENT if ( abs ( Sx - Dx ) % x == 0 and abs ( Sy - Dy ) % y == 0 and ( abs ( Sx - Dx ) \/ x ) % 2 == ( abs ( Sy - Dy ) \/ y ) % 2 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT Sx = 0 ; NEW_LINE Sy = 0 ; NEW_LINE Dx = 0 ; NEW_LINE Dy = 0 ; NEW_LINE x = 3 ; NEW_LINE y = 4 ; NEW_LINE if ( isPossible ( Sx , Sy , Dx , Dy , x , y ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT"],"bleu":0.4777194616946368,"rouge_l":0.6343771909324608}
{"id":1470,"predictions":["import math NEW_LINE def isPerfectSquare ( st ) : NEW_LINE INDENT sum = 0 NEW_LINE l = len ( st ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT sum += ( st [ i ] ) NEW_LINE DEDENT squareRoot = math . sqrt ( sum ) NEW_LINE return ( squareRoot - floor ( squareRoot ) == 0 ) NEW_LINE DEDENT st = \" d \" NEW_LINE if ( isPerfectSquare ( st ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["import math ; NEW_LINE def isPerfectSquareString ( str ) : NEW_LINE INDENT sum = 0 ; NEW_LINE l = len ( str ) ; NEW_LINE for i in range ( l ) : NEW_LINE INDENT sum = sum + ord ( str [ i ] ) ; NEW_LINE DEDENT squareRoot = math . sqrt ( sum ) ; NEW_LINE return ( ( squareRoot - math . floor ( squareRoot ) ) == 0 ) ; NEW_LINE DEDENT str = \" d \" ; NEW_LINE if ( isPerfectSquareString ( str ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT"],"bleu":0.5422601891849009,"rouge_l":0.8346113366411065}
{"id":1471,"predictions":["def arePermutation ( str1 , str2 ) : NEW_LINE INDENT n1 = len ( str1 ) NEW_LINE n2 = len ( str2 ) NEW_LINE if ( n1 != n2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n1 != n2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT st1 . sort ( ) NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT if ( ch1 [ i ] != ch2 [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT st1 . sort ( ) NEW_LINE DEDENT return True NEW_LINE DEDENT str1 = \" tt \" NEW_LINE str2 = \" tt \" NEW_LINE if ( arePermutation ( str1 , str2 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def arePermutation ( str1 , str2 ) : NEW_LINE INDENT n1 = len ( str1 ) NEW_LINE n2 = len ( str2 ) NEW_LINE if ( n1 != n2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT a = sorted ( str1 ) NEW_LINE str1 = \" ▁ \" . join ( a ) NEW_LINE b = sorted ( str2 ) NEW_LINE str2 = \" ▁ \" . join ( b ) NEW_LINE for i in range ( 0 , n1 , 1 ) : NEW_LINE INDENT if ( str1 [ i ] != str2 [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = \" test \" NEW_LINE str2 = \" ttew \" NEW_LINE if ( arePermutation ( str1 , str2 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.6038856630749558,"rouge_l":0.7574081803005008}
{"id":1472,"predictions":["def catalanDP ( n ) : NEW_LINE INDENT catalan = [ 0 for i in range ( n + 2 ) ] NEW_LINE catalan [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT catalan [ i ] = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT catalan [ i ] += ( catalan [ j ] * catalan [ i - j - j - 1 ] ) NEW_LINE DEDENT DEDENT return catalan [ n ] NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT print ( catalanDP ( i ) , end = \" ▁ \" ) NEW_LINE DEDENT"],"references":["def catalan ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT catalan = [ 0 for i in range ( n + 1 ) ] NEW_LINE catalan [ 0 ] = 1 NEW_LINE catalan [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT catalan [ i ] = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT catalan [ i ] = catalan [ i ] + catalan [ j ] * catalan [ i - j - 1 ] NEW_LINE DEDENT DEDENT return catalan [ n ] NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT print ( catalan ( i ) , end = \" ▁ \" ) NEW_LINE DEDENT"],"bleu":0.6854208964972077,"rouge_l":0.8210669301061991}
{"id":1473,"predictions":["def findEleTriplets ( arr , n ) : NEW_LINE INDENT for j in range ( 1 , n - 1 ) : NEW_LINE INDENT i = j - 1 NEW_LINE k = j + 1 NEW_LINE while ( i >= 0 and arr [ i ] % arr [ k ] == 0 and arr [ i ] % arr [ k ] == 0 and arr [ k ] == 0 ) : NEW_LINE INDENT while ( i >= 0 and arr [ arr [ i ] % arr [ j ] == 0 and arr [ i ] \/\/ arr [ k ] == 0 ) : NEW_LINE INDENT i -= 1 NEW_LINE k += 1 NEW_LINE DEDENT DEDENT if ( i >= 0 and arr [ arr [ i ] \/\/ arr [ k ] \/\/ arr [ k ] ] == 0 and arr [ i ] \/\/ arr [ k ] == 0 ) : NEW_LINE INDENT k += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT DEDENT if ( i >= 0 and arr [ i ] % arr [ k ] == 0 and arr [ i ] % arr [ k ] == 0 ) : NEW_LINE INDENT k += 1 NEW_LINE DEDENT elif ( i >= 0 and arr [ i ] % arr [ k ] == 0 ) : NEW_LINE INDENT k += 1 NEW_LINE DEDENT else : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT DEDENT if ( i >= 0 and arr [ i ] % arr [ k ] == 0 ) : NEW_LINE INDENT k += 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT arr = [ 1 , 2 , 4 , 16 ] NEW_LINE n = len ( arr ) NEW_LINE findEleTriplets ( arr , n ) NEW_LINE print ( findEleTriplets ( arr , n ) ) NEW_LINE"],"references":["def findGeometricTriplets ( arr , n ) : NEW_LINE INDENT for j in range ( 1 , n - 1 ) : NEW_LINE INDENT i = j - 1 NEW_LINE k = j + 1 NEW_LINE while ( i >= 0 and k <= n - 1 ) : NEW_LINE INDENT while ( arr [ j ] % arr [ i ] == 0 and arr [ k ] % arr [ j ] == 0 and arr [ j ] \/\/ arr [ i ] == arr [ k ] \/\/ arr [ j ] ) : NEW_LINE INDENT print ( arr [ i ] , \" ▁ \" , arr [ j ] , \" ▁ \" , arr [ k ] ) NEW_LINE k += 1 NEW_LINE i -= 1 NEW_LINE DEDENT if ( arr [ j ] % arr [ i ] == 0 and arr [ k ] % arr [ j ] == 0 ) : NEW_LINE INDENT if ( arr [ j ] \/\/ arr [ i ] < arr [ k ] \/\/ arr [ j ] ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT k += 1 NEW_LINE DEDENT DEDENT elif ( arr [ j ] % arr [ i ] == 0 ) : NEW_LINE INDENT k += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 16 ] NEW_LINE n = len ( arr ) NEW_LINE findGeometricTriplets ( arr , n ) NEW_LINE DEDENT"],"bleu":0.5947126524514776,"rouge_l":0.676908492722913}
{"id":1474,"predictions":["def fibonacci ( n ) : NEW_LINE INDENT F = [ [ 1 , 1 ] , [ 1 , 0 ] ] NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT power ( F , n - 1 ) NEW_LINE return F [ 0 ] [ 0 ] NEW_LINE DEDENT def multiply ( F , M ) : NEW_LINE INDENT x = F [ 0 ] [ 1 ] + F [ 1 ] [ 0 ] * M NEW_LINE y = F [ 0 ] [ 1 ] * M NEW_LINE return F [ 0 ] [ 0 ] + F [ 1 ] [ 0 ] NEW_LINE DEDENT def multiply ( F , M ) : NEW_LINE INDENT x = F [ [ 1 ] [ 0 ] NEW_LINE M = F [ 1 ] [ 0 ] * M NEW_LINE if ( F [ 1 ] [ 0 ] > F [ 1 ] [ 1 ] ) : NEW_LINE INDENT x = F [ 1 ] [ 0 ] + F [ 1 ] [ 1 ] NEW_LINE F [ 1 ] [ 0 ] = F [ 1 ] [ 1 ] + F [ 1 ] [ 1 ] NEW_LINE F [ 1 ] [ 1 ] = F [ 0 ] [ 1 ] NEW_LINE F [ 1 ] [ 1 ] = x NEW_LINE F [ 1 ] [ 1 ] = ( F [ 1 ] [ 0 ] * M [ 1 ] [ 1 ] + F [ 1 ] [ 1 ] ) NEW_LINE F [ 1 ] [ 1 ] = ( F [ 1 ] [ 0 ] * M [ 1 ] [ 1 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 1 ] ) NEW_LINE F [ 1 ] [ 1 ] = ( F [ 1 ] [ 0 ] * M [ 1 ] [ 1 ] + F [ 1 ] [ 0 ] ) NEW_LINE DEDENT DEDENT def fibonacci ( F , n ) : NEW_LINE INDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT multiply ( F , M ) NEW_LINE DEDENT DEDENT def multiply ( F , M ) : NEW_LINE INDENT return fibonacci ( M , n ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE"],"references":["def fib ( n ) : NEW_LINE INDENT F = [ [ 1 , 1 ] , [ 1 , 0 ] ] NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT power ( F , n - 1 ) NEW_LINE return F [ 0 ] [ 0 ] NEW_LINE DEDENT def multiply ( F , M ) : NEW_LINE INDENT x = ( F [ 0 ] [ 0 ] * M [ 0 ] [ 0 ] + F [ 0 ] [ 1 ] * M [ 1 ] [ 0 ] ) NEW_LINE y = ( F [ 0 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 0 ] [ 1 ] * M [ 1 ] [ 1 ] ) NEW_LINE z = ( F [ 1 ] [ 0 ] * M [ 0 ] [ 0 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 0 ] ) NEW_LINE w = ( F [ 1 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 1 ] ) NEW_LINE F [ 0 ] [ 0 ] = x NEW_LINE F [ 0 ] [ 1 ] = y NEW_LINE F [ 1 ] [ 0 ] = z NEW_LINE F [ 1 ] [ 1 ] = w NEW_LINE DEDENT def power ( F , n ) : NEW_LINE INDENT M = [ [ 1 , 1 ] , [ 1 , 0 ] ] NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT multiply ( F , M ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 9 NEW_LINE print ( fib ( n ) ) NEW_LINE DEDENT"],"bleu":0.6145286319560151,"rouge_l":0.7070542425065653}
{"id":1475,"predictions":["def largest_ alphabet ( a , n ) : NEW_LINE INDENT max_val = max ( a ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( a [ i ] > max_val ) : NEW_LINE INDENT max_val = a [ i ] NEW_LINE DEDENT DEDENT return max_val NEW_LINE DEDENT def smallest_ consonant ( a , n ) : NEW_LINE INDENT min = \" \" NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( a [ i ] < max_val ) : NEW_LINE INDENT min = a [ i ] NEW_LINE DEDENT DEDENT return min_val NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = \" GeeksforGeeksforGeeks \" NEW_LINE size = len ( a ) NEW_LINE print ( \" Largest ▁ smallest ▁ vowel ▁ smallest ▁ prefix \" , smallest_val ) NEW_LINE DEDENT"],"references":["def largest_alphabet ( a , n ) : NEW_LINE INDENT max = ' A ' NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] > max ) : NEW_LINE INDENT max = a [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT def smallest_alphabet ( a , n ) : NEW_LINE INDENT min = ' z ' ; NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( a [ i ] < min ) : NEW_LINE INDENT min = a [ i ] NEW_LINE DEDENT DEDENT return min NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = \" GeEksforGeeks \" NEW_LINE size = len ( a ) NEW_LINE print ( \" Largest ▁ and ▁ smallest ▁ alphabet ▁ is ▁ : ▁ \" , end = \" \" ) NEW_LINE print ( largest_alphabet ( a , size ) , end = \" ▁ and ▁ \" ) NEW_LINE print ( smallest_alphabet ( a , size ) ) NEW_LINE DEDENT"],"bleu":0.5556244440310449,"rouge_l":0.7457643434732384}
{"id":1476,"predictions":["def Check_isossible ( l , r , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if ( i % k == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE if ( i % k == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return ( count > 1 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT l , r = 4 , 12 NEW_LINE if ( g ( l , r , k ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"references":["def Check_is_possible ( l , r , k ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if ( i % k == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return ( count > 1 ) ; NEW_LINE DEDENT l = 4 ; NEW_LINE r = 12 ; NEW_LINE k = 5 ; NEW_LINE if ( Check_is_possible ( l , r , k ) ) : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE DEDENT"],"bleu":0.6174962119528301,"rouge_l":0.7905338780109875}
{"id":1477,"predictions":["def pushZerosToEnd ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( arr [ i ] != 0 ) : NEW_LINE INDENT arr [ count ] = arr [ i ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT while ( count < n ) : NEW_LINE INDENT arr [ count ] = arr [ i ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT def pushZerosToEnd ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n , 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 1 , 9 , 8 , 4 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE pushZerosToEnd ( arr , n ) NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT"],"references":["def pushZerosToEnd ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] != 0 : NEW_LINE INDENT arr [ count ] = arr [ i ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT while count < n : NEW_LINE INDENT arr [ count ] = 0 NEW_LINE count += 1 NEW_LINE DEDENT DEDENT arr = [ 1 , 9 , 8 , 4 , 0 , 0 , 2 , 7 , 0 , 6 , 0 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE pushZerosToEnd ( arr , n ) NEW_LINE print ( \" Array ▁ after ▁ pushing ▁ all ▁ zeros ▁ to ▁ end ▁ of ▁ array : \" ) NEW_LINE print ( arr ) NEW_LINE"],"bleu":0.489750366169427,"rouge_l":0.6996808298424096}
{"id":1478,"predictions":["def check ( s , k ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] != s [ k ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def countCommonDivisors ( a , b ) : NEW_LINE INDENT ct = 0 NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE for i in range ( 1 , min ( n , m + 1 ) ) : NEW_LINE INDENT if ( n % i == 0 and m % i == 0 ) : NEW_LINE INDENT if ( check ( a , i ) and check ( b , i ) == True ) : NEW_LINE INDENT ct += 1 NEW_LINE DEDENT DEDENT DEDENT ct += 1 NEW_LINE DEDENT return ct NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = \" xaxaaxa \" NEW_LINE b = \" xaxaxaxa \" NEW_LINE print ( countCommonDivisors ( a , b ) ) NEW_LINE DEDENT"],"references":["def check ( s , k ) : NEW_LINE INDENT for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] != s [ i % k ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def countCommonDivisors ( a , b ) : NEW_LINE INDENT ct = 0 NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE for i in range ( 1 , min ( n , m ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 and m % i == 0 ) : NEW_LINE INDENT if ( a [ 0 : i ] == b [ 0 : i ] ) : NEW_LINE INDENT if ( check ( a , i ) and check ( b , i ) ) : NEW_LINE INDENT ct = ct + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return ct NEW_LINE DEDENT a = \" xaxa \" NEW_LINE b = \" xaxaxaxa \" NEW_LINE print ( countCommonDivisors ( a , b ) ) NEW_LINE"],"bleu":0.7978872736835156,"rouge_l":0.8611890564714134}
{"id":1479,"predictions":["rev_num = 0 NEW_LINE while ( num > 0 ) : NEW_LINE INDENT rev_num = rev_num * 10 + num % 10 NEW_LINE num = num \/\/ 10 NEW_LINE DEDENT return rev_num NEW_LINE DEDENT num = 4562 NEW_LINE print ( \" Reverse ▁ no . ▁ is \" , reversDigits ( num ) ) NEW_LINE"],"references":["n = 4562 ; NEW_LINE rev = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT a = n % 10 NEW_LINE rev = rev * 10 + a NEW_LINE n = n \/\/ 10 NEW_LINE DEDENT print ( rev ) NEW_LINE"],"bleu":0.2794536127654398,"rouge_l":0.5153768164920582}
{"id":1480,"predictions":["def center_nonhedral_num ( n ) : NEW_LINE INDENT return ( 19 * n * n - 19 * n + 2 ) \/\/ 2 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 2 NEW_LINE print ( n , \" octal ▁ centered ▁ dec ▁ \" + \" number ▁ : ▁ \" , end = \" \" ) NEW_LINE print ( n , \" ▁ \" , center_nonagonhedral_num ( n ) ) NEW_LINE DEDENT"],"references":["def center_nonadecagon_num ( n ) : NEW_LINE INDENT return ( 19 * n * n - 19 * n + 2 ) \/\/ 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 2 NEW_LINE print ( n , \" nd ▁ centered ▁ nonadecagonal ▁ \" + \" number ▁ : ▁ \" , center_nonadecagon_num ( n ) ) NEW_LINE n = 7 NEW_LINE print ( n , \" nd ▁ centered ▁ nonadecagonal ▁ \" + \" number ▁ : ▁ \" , center_nonadecagon_num ( n ) ) NEW_LINE DEDENT"],"bleu":0.6096170021031296,"rouge_l":0.7919298245614036}
{"id":1481,"predictions":["def countKdist ( str , k ) : NEW_LINE INDENT res = 0 NEW_LINE n = len ( str ) NEW_LINE cnt = [ 0 for i in range ( 26 ) ] NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT cnt [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( i , n ) : NEW_LINE INDENT if ( cnt [ 0 ] == 0 ) : NEW_LINE INDENT dist_count [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT if ( dist_count [ cnt [ ord ( str [ j ] ) - ord ( ' a ' ) ] > 0 ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" abcbba \" NEW_LINE k = 3 NEW_LINE print ( \" Total ▁ sub ▁ with ▁ k ▁ characters ▁ : ▁ \" , countKdist ( str , k ) ) NEW_LINE DEDENT"],"references":["def countkDist ( str1 , k ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE res = 0 NEW_LINE cnt = [ 0 ] * 27 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT dist_count = 0 NEW_LINE cnt = [ 0 ] * 27 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if ( cnt [ ord ( str1 [ j ] ) - 97 ] == 0 ) : NEW_LINE INDENT dist_count += 1 NEW_LINE DEDENT cnt [ ord ( str1 [ j ] ) - 97 ] += 1 NEW_LINE if ( dist_count == k ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT if ( dist_count > k ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" abcbaa \" NEW_LINE k = 3 NEW_LINE print ( \" Total ▁ substrings ▁ with ▁ exactly \" , k , \" distinct ▁ characters ▁ : ▁ \" , end = \" \" ) NEW_LINE print ( countkDist ( str1 , k ) ) NEW_LINE DEDENT"],"bleu":0.5593379175658778,"rouge_l":0.651334702258727}
{"id":1482,"predictions":["def percent ( price , x , y , n ) : NEW_LINE INDENT p = n * x NEW_LINE p \/= 100 NEW_LINE return p NEW_LINE DEDENT def getLoss ( price , X , n ) : NEW_LINE INDENT loss = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT optimalPrice = price [ i ] NEW_LINE if ( optimalPrice ) : NEW_LINE INDENT loss = loss + decimalPrice NEW_LINE DEDENT else : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT return loss NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT price = [ 20 , 48 , 1 ] NEW_LINE X = [ 20 , 48 , 100 ] NEW_LINE n = len ( X ) NEW_LINE print ( getLoss ( price , X , Y , n ) ) NEW_LINE DEDENT"],"references":["def percent ( n , x ) : NEW_LINE INDENT p = ( int ) ( n ) * x ; NEW_LINE p \/= 100 ; NEW_LINE return p ; NEW_LINE DEDENT def getLoss ( price , quantity , X , n ) : NEW_LINE INDENT loss = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT originalPrice = price [ i ] ; NEW_LINE sellingPrice = originalPrice + percent ( originalPrice , X [ i ] ) ; NEW_LINE afterDiscount = sellingPrice - percent ( sellingPrice , X [ i ] ) ; NEW_LINE loss += ( ( originalPrice - afterDiscount ) * quantity [ i ] ) ; NEW_LINE DEDENT return round ( loss , 2 ) ; NEW_LINE DEDENT price = [ 20 , 48 , 200 , 100 ] ; NEW_LINE quantity = [ 20 , 48 , 1 , 1 ] ; NEW_LINE X = [ 0 , 48 , 200 , 5 ] ; NEW_LINE n = len ( X ) ; NEW_LINE print ( getLoss ( price , quantity , X , n ) ) ; NEW_LINE"],"bleu":0.3595458725982191,"rouge_l":0.6059992283950617}
{"id":1483,"predictions":["def minCost ( s ) : NEW_LINE INDENT alphabets = [ 0 ] * 26 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT alphabets [ ord ( s [ i ] ) - 97 ] = 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT alphabets [ ord ( s [ i ] ) - 97 ] = 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( alphabets [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" geeksforgeeks \" NEW_LINE print ( \" Total ▁ cost ▁ to \" , minCost ( s ) ) NEW_LINE DEDENT"],"references":["def minCost ( s ) : NEW_LINE INDENT alphabets = [ False for i in range ( 26 ) ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT alphabets [ ord ( s [ i ] ) - 97 ] = True NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( alphabets [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" geeksforgeeks \" NEW_LINE print ( \" Total ▁ cost ▁ to ▁ construct \" , s , \" is \" , minCost ( s ) ) NEW_LINE DEDENT"],"bleu":0.7273338015744535,"rouge_l":0.8199321869702106}
{"id":1484,"predictions":["import math NEW_LINE def nextPowerOfFour ( n ) : NEW_LINE INDENT x = math . floor ( math . sqrt ( n ) ) NEW_LINE if ( x ** 2 == n ) : NEW_LINE INDENT return n ; NEW_LINE DEDENT else : NEW_LINE INDENT x = x + 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 122 NEW_LINE print ( nextPowerOfFour ( n ) ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def nextPowerOfFour ( n ) : NEW_LINE INDENT x = math . floor ( ( n ** ( 1 \/ 2 ) ) ** ( 1 \/ 2 ) ) ; NEW_LINE if ( ( x ** 4 ) == n ) : NEW_LINE INDENT return n ; NEW_LINE DEDENT else : NEW_LINE INDENT x = x + 1 ; NEW_LINE return ( x ** 4 ) ; NEW_LINE DEDENT DEDENT n = 122 ; NEW_LINE print ( nextPowerOfFour ( n ) ) ; NEW_LINE"],"bleu":0.5510936069505886,"rouge_l":0.7235076803422128}
{"id":1485,"predictions":["def findCost ( s1 , s2 , a , b , c , d , n ) : NEW_LINE INDENT cost = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s1 [ i ] == s2 [ i ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT elif ( s1 [ i ] == s2 [ i ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT elif ( s1 [ i ] == s1 [ i ] and s2 [ i ] == s2 [ i ] ) : NEW_LINE INDENT cost += d NEW_LINE DEDENT elif ( s1 [ i ] == s2 [ i ] and s1 [ i ] == s2 [ i ] and s1 [ i ] == s2 [ i ] ) : NEW_LINE INDENT cost += min ( d , min ( a , b , c ) ) NEW_LINE DEDENT elif ( s1 [ i ] == s2 [ i ] and s1 [ i ] == s2 [ i ] ) ) : NEW_LINE INDENT cost += min ( d , min ( d , a + c ) ) NEW_LINE DEDENT DEDENT return cost NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s1 = \"111\" NEW_LINE s2 = \"3\" NEW_LINE a , b , c = 3 , 4 , 10 NEW_LINE n = len ( s1 ) NEW_LINE print ( findCost ( s1 , s2 , a , b , c , d , n ) ) NEW_LINE DEDENT"],"references":["def findCost ( s1 , s2 , a , b , c , d , n ) : NEW_LINE INDENT cost = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s1 [ i ] == s2 [ i ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT if ( ( s1 [ i ] == '1' and s2 [ i ] == '2' ) or ( s2 [ i ] == '1' and s1 [ i ] == '2' ) ) : NEW_LINE INDENT cost += min ( d , min ( a , b + c ) ) NEW_LINE DEDENT elif ( ( s1 [ i ] == '2' and s2 [ i ] == '3' ) or ( s2 [ i ] == '2' and s1 [ i ] == '3' ) ) : NEW_LINE INDENT cost += min ( d , min ( b , a + c ) ) NEW_LINE DEDENT elif ( ( s1 [ i ] == '1' and s2 [ i ] == '3' ) or ( s2 [ i ] == '1' and s1 [ i ] == '3' ) ) : NEW_LINE INDENT cost += min ( d , min ( c , a + b ) ) NEW_LINE DEDENT DEDENT DEDENT return cost NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s1 = \"121\" NEW_LINE s2 = \"223\" NEW_LINE a = 2 NEW_LINE b = 3 NEW_LINE c = 4 NEW_LINE d = 10 NEW_LINE n = len ( s1 ) NEW_LINE print ( findCost ( s1 , s2 , a , b , c , d , n ) ) NEW_LINE DEDENT"],"bleu":0.6538969517651526,"rouge_l":0.7855159784984347}
{"id":1486,"predictions":["def SecondOneMatch ( arr , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT print ( 5 - arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 3 , 4 , 2 , 2 ] NEW_LINE N = len ( arr ) NEW_LINE"],"references":["def TwentyoneMatchstick ( arr , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT print ( 5 - arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 3 , 4 , 2 , 2 ] NEW_LINE N = len ( arr ) NEW_LINE TwentyoneMatchstick ( arr , N ) NEW_LINE"],"bleu":0.8568977296223884,"rouge_l":0.9160632877447035}
{"id":1487,"predictions":["def Perimeter ( s , n ) : NEW_LINE INDENT perimeter = 1 NEW_LINE perimeter = n * s NEW_LINE return perimeter NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 NEW_LINE perimeter = Perimeter ( s , n ) NEW_LINE peri = Perimeter ( s , n ) NEW_LINE print ( \" Perimeter ▁ of ▁ Perimeter ▁ of ▁ \" , perimeter , \" ▁ of ▁ Perimeter ▁ = ▁ \" , peri ) NEW_LINE print ( \" Perimeter ▁ of ▁ \" , \" ▁ \" , peri ) NEW_LINE DEDENT"],"references":["def Perimeter ( s , n ) : NEW_LINE INDENT perimeter = 1 NEW_LINE perimeter = n * s NEW_LINE return perimeter NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE s = 2.5 NEW_LINE peri = Perimeter ( s , n ) NEW_LINE print ( \" Perimeter ▁ of ▁ Regular ▁ Polygon ▁ with \" , n , \" sides ▁ of ▁ length \" , s , \" = \" , peri ) NEW_LINE DEDENT"],"bleu":0.587695305003021,"rouge_l":0.80374479889043}
{"id":1488,"predictions":["def checkPalindrome ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE count = 0 NEW_LINE for i in range ( int ( n \/ 2 ) ) : NEW_LINE INDENT if str [ i ] != str [ n - i - 1 ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return ( count <= 1 ) NEW_LINE DEDENT str = \" abccaa \" NEW_LINE if ( checkPalindrome ( str ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def checkPalindrome ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE count = 0 NEW_LINE for i in range ( 0 , int ( n \/ 2 ) ) : NEW_LINE INDENT if ( str [ i ] != str [ n - i - 1 ] ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT if ( count <= 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT str = \" abccaa \" NEW_LINE if ( checkPalindrome ( str ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.725172573347891,"rouge_l":0.8776340648161604}
{"id":1489,"predictions":["def getSum ( n ) : NEW_LINE INDENT sm = 0 NEW_LINE while ( n ) : NEW_LINE INDENT sm = sm + n % 10 NEW_LINE n = n \/\/ 10 NEW_LINE DEDENT return sm NEW_LINE DEDENT def largestDigitSumdivisior ( n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT res = max ( res , getSum ( i ) ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT n = 14 NEW_LINE print ( largestDigitSumdivisior ( n ) ) NEW_LINE"],"references":["def getSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while n != 0 : NEW_LINE INDENT sum = sum + n % 10 NEW_LINE n = int ( n \/ 10 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT def largestDigitSumdivisior ( n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT res = max ( res , getSum ( i ) ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT n = 14 NEW_LINE print ( largestDigitSumdivisior ( n ) ) NEW_LINE"],"bleu":0.777393303769412,"rouge_l":0.9091755938518863}
{"id":1490,"predictions":["def gcd ( a , b ) ; NEW_LINE def lcm ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b ; NEW_LINE DEDENT return gcd ( b % a , a ) ; NEW_LINE DEDENT def lcm ( n , m ) : NEW_LINE INDENT return ( ( n * m ) \/ gcd ( n , a ) ) ; NEW_LINE DEDENT def lcm ( n , m ) : NEW_LINE INDENT return ( n * m ) \/ gcd ( n , m ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n , m = 2 , 3 ; NEW_LINE k = 5 ; NEW_LINE print ( int ( lcm ( n , m ) ) ) ; NEW_LINE DEDENT"],"references":["def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b ; NEW_LINE DEDENT return gcd ( b % a , a ) ; NEW_LINE DEDENT def lcm ( n , m ) : NEW_LINE INDENT return ( n * m ) \/\/ gcd ( n , m ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 2 ; m = 3 ; k = 5 ; NEW_LINE print ( k \/\/ lcm ( n , m ) ) ; NEW_LINE DEDENT"],"bleu":0.6314230190633847,"rouge_l":0.8136723634847852}
{"id":1491,"predictions":["import math NEW_LINE def checkPrime ( number ) : NEW_LINE INDENT num = str ( number ) NEW_LINE for i in range ( 2 , int ( math . sqrt ( num ) ) + 1 ) : NEW_LINE INDENT if ( num % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def splitIntoPrimes ( number ) : NEW_LINE INDENT if ( len ( number ) == 0 and checkPrime ( number ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( number [ 0 ] <= 6 and checkPrime ( number ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT def splitIntoPrimes ( number ) : NEW_LINE INDENT if ( len ( number ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT num = splitIntoPrimes ( number ) NEW_LINE for i in range ( 1 , 6 ) : NEW_LINE INDENT if ( checkPrime ( number [ 0 ] ) ) : NEW_LINE INDENT val = min ( ans , 1 + val ) NEW_LINE DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT if ( ans == 1000000 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT print ( splitIntoPrimes ( ) ) NEW_LINE"],"references":["def checkPrime ( number ) : NEW_LINE INDENT num = int ( number ) NEW_LINE for i in range ( 2 , int ( num ** 0.5 ) ) : NEW_LINE INDENT if ( ( num % i ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def splitIntoPrimes ( number ) : NEW_LINE INDENT if ( number == ' ' ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( len ( number ) <= 6 and checkPrime ( number ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT numLen = len ( number ) NEW_LINE ans = 1000000 NEW_LINE for i in range ( 1 , ( min ( 6 , numLen ) + 1 ) ) : NEW_LINE INDENT if ( checkPrime ( number [ : i ] ) ) : NEW_LINE INDENT val = splitIntoPrimes ( number [ i : ] ) NEW_LINE if ( val != - 1 ) : NEW_LINE INDENT ans = min ( ans , 1 + val ) NEW_LINE DEDENT DEDENT DEDENT if ( ans == 1000000 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT print ( splitIntoPrimes ( \"13499315\" ) ) NEW_LINE print ( splitIntoPrimes ( \"43\" ) ) NEW_LINE"],"bleu":0.7036538139892995,"rouge_l":0.7235023041474654}
{"id":1492,"predictions":["def findKthChar ( s , k ) : NEW_LINE INDENT l = len ( s ) NEW_LINE i = 0 NEW_LINE total_len = 0 NEW_LINE while ( i < l ) : NEW_LINE INDENT if ( s [ i ] == s [ i ] ) : NEW_LINE INDENT total_len += 1 NEW_LINE DEDENT if ( total_len == k ) : NEW_LINE INDENT return s NEW_LINE DEDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT n = 0 NEW_LINE while ( i < l ) : NEW_LINE INDENT if ( isKthChar ( s [ i ] ) ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT n = n * 10 + ( ord ( s [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return ( i ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" abc2\" NEW_LINE k = 5 NEW_LINE print ( findKthChar ( s , k ) ) NEW_LINE DEDENT"],"references":["def findKthChar ( s , k ) : NEW_LINE INDENT len1 = len ( s ) NEW_LINE i = 0 NEW_LINE total_len = 0 NEW_LINE while ( i < len1 ) : NEW_LINE INDENT if ( s [ i ] . isalpha ( ) ) : NEW_LINE INDENT total_len += 1 NEW_LINE if ( total_len == k ) : NEW_LINE INDENT return s [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT n = 0 NEW_LINE while ( i < len1 and s [ i ] . isalpha ( ) == False ) : NEW_LINE INDENT n = n * 10 + ( ord ( s [ i ] ) - ord ( '0' ) ) NEW_LINE i += 1 NEW_LINE DEDENT next_total_len = total_len * n NEW_LINE if ( k <= next_total_len ) : NEW_LINE INDENT pos = k % total_len NEW_LINE if ( pos == 0 ) : NEW_LINE INDENT pos = total_len NEW_LINE DEDENT return findKthChar ( s , pos ) NEW_LINE DEDENT else : NEW_LINE INDENT total_len = next_total_len NEW_LINE DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" ab2c3\" NEW_LINE k = 5 NEW_LINE print ( findKthChar ( s , k ) ) NEW_LINE DEDENT"],"bleu":0.6128107413954003,"rouge_l":0.7199676637025061}
{"id":1493,"predictions":["def Nth_Term ( n ) : NEW_LINE INDENT return ( 2 * pow ( n , 3 ) - 3 * n + 6 ) \/\/ 6 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 8 NEW_LINE print ( Nth_Term ( N ) ) NEW_LINE DEDENT"],"references":["def Nth_Term ( n ) : NEW_LINE INDENT return ( 2 * pow ( n , 3 ) - 3 * pow ( n , 2 ) + n + 6 ) \/\/ 6 NEW_LINE DEDENT N = 8 NEW_LINE print ( Nth_Term ( N ) ) NEW_LINE"],"bleu":0.6854527103864726,"rouge_l":0.8059941991621012}
{"id":1494,"predictions":["def solve ( A , B , C , max_diff , max_diff ) : NEW_LINE INDENT for i in range ( len ( A ) - 1 , 0 , - 1 ) : NEW_LINE INDENT min_diff = abs ( A [ i ] - C [ 0 ] , C [ i ] ) NEW_LINE min_diff = abs ( A [ i ] , max_diff ) NEW_LINE DEDENT while ( i != - 1 and j != - 1 and j != - 1 ) : NEW_LINE INDENT current_diff = abs ( A [ i ] , max_diff ) NEW_LINE if ( current_diff < min_diff ) : NEW_LINE INDENT min_diff = max ( A [ j ] , max_diff ) NEW_LINE DEDENT if ( A [ i ] == max_diff ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT if ( A [ j ] == max_diff ) : NEW_LINE INDENT min_diff = max ( A [ j ] , max_diff ) NEW_LINE DEDENT elif ( B [ j ] == max_diff ) : NEW_LINE INDENT if ( A [ j ] == max_diff ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT DEDENT elif ( A [ j ] == max_diff ) : NEW_LINE INDENT if A [ j ] == max_diff : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return min_diff NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT B = [ 5 , 9 , 10 , 15 , 78 , 90 , 8 , 89 ] NEW_LINE E = [ 2 , 3 , 6 , 8 , 90 , 8 ] NEW_LINE print ( solve ( D , E , F , K ) ) NEW_LINE DEDENT"],"references":["def solve ( A , B , C ) : NEW_LINE INDENT i = len ( A ) - 1 NEW_LINE j = len ( B ) - 1 NEW_LINE k = len ( C ) - 1 NEW_LINE min_diff = abs ( max ( A [ i ] , B [ j ] , C [ k ] ) - min ( A [ i ] , B [ j ] , C [ k ] ) ) NEW_LINE while i != - 1 and j != - 1 and k != - 1 : NEW_LINE INDENT current_diff = abs ( max ( A [ i ] , B [ j ] , C [ k ] ) - min ( A [ i ] , B [ j ] , C [ k ] ) ) NEW_LINE if current_diff < min_diff : NEW_LINE INDENT min_diff = current_diff NEW_LINE DEDENT max_term = max ( A [ i ] , B [ j ] , C [ k ] ) NEW_LINE if A [ i ] == max_term : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT elif B [ j ] == max_term : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT DEDENT return min_diff NEW_LINE DEDENT A = [ 5 , 8 , 10 , 15 ] NEW_LINE B = [ 6 , 9 , 15 , 78 , 89 ] NEW_LINE C = [ 2 , 3 , 6 , 6 , 8 , 8 , 10 ] NEW_LINE print ( solve ( A , B , C ) ) NEW_LINE"],"bleu":0.4375677989867285,"rouge_l":0.6178209706691645}
{"id":1495,"predictions":["class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def CheckPerfectTree ( root ) : NEW_LINE INDENT q = [ ] NEW_LINE q . append ( root ) NEW_LINE while ( len ( q ) != 0 ) : NEW_LINE INDENT temp = q . pop ( ) NEW_LINE if ( temp == None and temp . left != None ) : NEW_LINE INDENT return False NEW_LINE DEDENT elif ( temp . left != None and temp . right != None ) : NEW_LINE INDENT q . append ( temp . data ) NEW_LINE DEDENT elif ( temp . left != None and temp . right != None ) : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE DEDENT elif ( temp . right != None and temp . left != None ) : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE if ( temp . left == None and temp . right == None ) : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE DEDENT elif ( temp . left == None and temp . right == None ) : NEW_LINE INDENT q . append ( temp . right ) NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = Node ( 7 ) NEW_LINE root . left = Node ( 5 ) NEW_LINE root . left = Node ( 8 ) NEW_LINE root . left = Node ( 9 ) NEW_LINE root . right = Node ( 1 ) NEW_LINE root . right . left . left = Node ( 5 ) NEW_LINE root . left . left = Node ( 10 ) NEW_LINE root . right . right = Node ( 10 ) NEW_LINE if ( CheckPerfectTree ( root ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["import sys NEW_LINE import math NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def newNode ( data ) : NEW_LINE INDENT return Node ( data ) NEW_LINE DEDENT def CheckPerfectTree ( root ) : NEW_LINE INDENT q = [ ] NEW_LINE q . append ( root ) NEW_LINE flag = 0 NEW_LINE while ( q ) : NEW_LINE INDENT temp = q [ 0 ] NEW_LINE q . pop ( 0 ) NEW_LINE if ( temp . left and temp . right ) : NEW_LINE INDENT if ( flag == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE q . append ( temp . right ) NEW_LINE DEDENT DEDENT elif ( not temp . left and not temp . right ) : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT elif ( not temp . left or not temp . right ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 7 ) NEW_LINE root . left = newNode ( 5 ) NEW_LINE root . left . left = newNode ( 8 ) NEW_LINE root . left . right = newNode ( 1 ) NEW_LINE root . right = newNode ( 6 ) NEW_LINE root . right . left = newNode ( 3 ) NEW_LINE root . right . right = newNode ( 9 ) NEW_LINE root . right . right . left = newNode ( 10 ) NEW_LINE root . right . right . right = newNode ( 13 ) NEW_LINE if CheckPerfectTree ( root ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.6157832301906315,"rouge_l":0.719643199693075}
{"id":1496,"predictions":["def generateNumber ( count , a , n , num , k ) : NEW_LINE INDENT if ( count == k ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( count == k ) : NEW_LINE INDENT print ( num ) NEW_LINE return NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT generateNumber ( count + 1 , a , n , num , k ) NEW_LINE DEDENT DEDENT def printDistinct ( k , a , n , k ) : NEW_LINE INDENT generateNumber ( 0 , a , n , a , k ) NEW_LINE DEDENT def printDistinct ( k , a , n , k ) : NEW_LINE INDENT generateNumber ( 0 , a , n , 0 , k ) NEW_LINE DEDENT def printDistinct ( k , a , n , k ) : NEW_LINE INDENT generateNumber ( a , a , n , k ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 8 , 17 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE printDistinct ( k , a , n , k ) NEW_LINE DEDENT DEDENT"],"references":["s = set ( ) NEW_LINE def generateNumber ( count , a , n , num , k ) : NEW_LINE INDENT if k == count : NEW_LINE INDENT s . add ( num ) NEW_LINE return NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT generateNumber ( count + 1 , a , n , num + a [ i ] , k ) NEW_LINE DEDENT DEDENT def printDistinctIntegers ( k , a , n ) : NEW_LINE INDENT generateNumber ( 0 , a , n , 0 , k ) NEW_LINE print ( \" The \" , len ( s ) , \" distinct ▁ integers ▁ are : \" ) NEW_LINE for i in sorted ( s ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 3 , 8 , 17 , 5 ] NEW_LINE n , k = len ( a ) , 2 NEW_LINE printDistinctIntegers ( k , a , n ) NEW_LINE DEDENT"],"bleu":0.5435276441700543,"rouge_l":0.693123039090986}
{"id":1497,"predictions":["import math NEW_LINE def findMin ( a , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += math . log ( a [ i ] ) NEW_LINE DEDENT x = int ( math . log ( sum \/ n ) ) NEW_LINE return x + 1 NEW_LINE DEDENT a = [ 3 , 2 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( findMin ( a , n ) ) NEW_LINE"],"references":["import math as m NEW_LINE def findMin ( a , n ) : NEW_LINE INDENT _sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT _sum += m . log ( a [ i ] ) NEW_LINE DEDENT x = m . exp ( _sum \/ n ) NEW_LINE return int ( x + 1 ) NEW_LINE DEDENT a = [ 3 , 2 , 1 , 4 ] NEW_LINE n = len ( a ) NEW_LINE print ( findMin ( a , n ) ) NEW_LINE"],"bleu":0.7092900946475522,"rouge_l":0.8728673637864612}
{"id":1498,"predictions":["def dfs ( i , R , C , R , C ) : NEW_LINE INDENT for i in range ( C ) : NEW_LINE INDENT dfs ( i , i , R , C , C ) NEW_LINE print ( i , end = \" ▁ \" ) NEW_LINE return NEW_LINE DEDENT if ( i == R ) : NEW_LINE INDENT if ( i == R ) : NEW_LINE INDENT print ( res , end = \" ▁ \" ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT for k in range ( C , R ) : NEW_LINE INDENT dfs ( i , i + 1 , C , R , C , C ) NEW_LINE if ( i + 1 == R ) : NEW_LINE INDENT print ( res , end = \" ▁ \" ) NEW_LINE return NEW_LINE DEDENT if ( i + 1 == R ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( i + 1 == R ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( i + 1 == R ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( i + 1 == R ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT dfs ( 0 , R , C , C ) NEW_LINE R = len ( R ) NEW_LINE C = len ( C ) NEW_LINE DEDENT"],"references":["def printPaths ( inputchar , R , C ) : NEW_LINE INDENT for i in range ( C ) : NEW_LINE INDENT dfs ( inputchar , \" \" , 0 , i , R , C ) ; NEW_LINE print ( ) NEW_LINE DEDENT DEDENT def dfs ( inputchar , res , i , j , R , C ) : NEW_LINE INDENT if ( i == R ) : NEW_LINE INDENT print ( res , end = \" ▁ \" ) ; NEW_LINE return ; NEW_LINE DEDENT res = res + inputchar [ i ] [ j ] ; NEW_LINE for k in range ( C ) : NEW_LINE INDENT dfs ( inputchar , res , i + 1 , k , R , C ) ; NEW_LINE if ( i + 1 == R ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT inputchar = [ [ ' a ' , ' b ' ] , [ ' d ' , ' e ' ] ] ; NEW_LINE R = len ( inputchar ) ; NEW_LINE C = len ( inputchar [ 0 ] ) ; NEW_LINE printPaths ( inputchar , R , C ) ; NEW_LINE DEDENT"],"bleu":0.44187132166856,"rouge_l":0.5942998400465318}
{"id":1499,"predictions":["mod = 1000000007 NEW_LINE def power ( a , m ) : NEW_LINE INDENT if ( m == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( m == 1 ) : NEW_LINE INDENT return a NEW_LINE DEDENT elif ( m == 2 ) : NEW_LINE INDENT return a NEW_LINE DEDENT elif ( m == 1 ) : NEW_LINE INDENT return ( power ( a , m ) ) % mod NEW_LINE DEDENT elif ( m == 2 ) : NEW_LINE INDENT return ( power ( a , m ) ) NEW_LINE DEDENT elif ( m % 2 == 0 ) : NEW_LINE INDENT return ( power ( a , m \/\/ 2 ) ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT return ( power ( power ( a , m ) ) % mod ) NEW_LINE DEDENT DEDENT def power ( x , r ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , x + 1 ) : NEW_LINE INDENT ans = ( power ( x , ans * ans ) % mod NEW_LINE ans = ( ans * ans ) % mod NEW_LINE DEDENT return ans NEW_LINE DEDENT def number_of_sets ( n , r ) : NEW_LINE INDENT if ( r > n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = power ( x , 2 , ans ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N , A = 4 , 1 NEW_LINE print ( number_of_sets ( n , A ) ) NEW_LINE print ( number_of_sets ( n , A ) ) NEW_LINE DEDENT"],"references":["mod = 10 ** 9 + 7 NEW_LINE def power ( a , m1 ) : NEW_LINE INDENT if ( m1 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( m1 == 1 ) : NEW_LINE INDENT return a NEW_LINE DEDENT elif ( m1 == 2 ) : NEW_LINE INDENT return ( a * a ) % mod NEW_LINE DEDENT elif ( m1 & 1 ) : NEW_LINE INDENT return ( a * power ( power ( a , m1 \/\/ 2 ) , 2 ) ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT return power ( power ( a , m1 \/\/ 2 ) , 2 ) % mod NEW_LINE DEDENT DEDENT def factorial ( x ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , x + 1 ) : NEW_LINE INDENT ans = ( ans * i ) % mod NEW_LINE DEDENT return ans NEW_LINE DEDENT def inverse ( x ) : NEW_LINE INDENT return power ( x , mod - 2 ) NEW_LINE DEDENT def binomial ( n , r ) : NEW_LINE INDENT if ( r > n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = factorial ( n ) NEW_LINE ans = ( ans * inverse ( factorial ( r ) ) ) % mod NEW_LINE ans = ( ans * inverse ( factorial ( n - r ) ) ) % mod NEW_LINE return ans NEW_LINE DEDENT def number_of_sets ( n , a , b ) : NEW_LINE INDENT ans = power ( 2 , n ) NEW_LINE ans = ans - binomial ( n , a ) NEW_LINE if ( ans < 0 ) : NEW_LINE INDENT ans += mod NEW_LINE DEDENT ans = ans - binomial ( n , b ) NEW_LINE ans -= 1 NEW_LINE if ( ans < 0 ) : NEW_LINE INDENT ans += mod NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE A = 1 NEW_LINE B = 3 NEW_LINE print ( number_of_sets ( N , A , B ) ) NEW_LINE DEDENT"],"bleu":0.48741986819430466,"rouge_l":0.6036887089518669}
{"id":1500,"predictions":["def sumOfSeries ( a , n ) : NEW_LINE INDENT res = 0 NEW_LINE prev = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT prev *= ( a \/ i ) NEW_LINE res = res + prev NEW_LINE res = res + prev NEW_LINE DEDENT return ( res ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( sumOfSeries ( a , n ) ) NEW_LINE DEDENT"],"references":["from __future__ import division NEW_LINE def sumOfSeries ( a , num ) : NEW_LINE INDENT res = 0 NEW_LINE prev = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT prev *= ( a \/ i ) NEW_LINE res = res + prev NEW_LINE DEDENT return res NEW_LINE DEDENT n = 5 NEW_LINE a = 2 NEW_LINE print ( round ( sumOfSeries ( a , n ) , 4 ) ) NEW_LINE"],"bleu":0.6575456803107552,"rouge_l":0.7778441920701334}
{"id":1501,"predictions":["def countNum ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE maxm = - 2147483648 NEW_LINE count = 0 NEW_LINE minm = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE if ( arr [ i ] < minm ) : NEW_LINE INDENT maxm = arr [ i ] NEW_LINE DEDENT if ( arr [ i ] < maxm ) : NEW_LINE INDENT maxm = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( minm ) : NEW_LINE INDENT if ( arr [ i ] > maxm ) : NEW_LINE INDENT countm = arr [ i ] NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 5 , 8 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countNum ( arr , n ) ) NEW_LINE DEDENT"],"references":["def countNum ( arr , n ) : NEW_LINE INDENT s = dict ( ) NEW_LINE count , maxm , minm = 0 , - 10 ** 9 , 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s [ arr [ i ] ] = 1 NEW_LINE if ( arr [ i ] < minm ) : NEW_LINE INDENT minm = arr [ i ] NEW_LINE DEDENT if ( arr [ i ] > maxm ) : NEW_LINE INDENT maxm = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( minm , maxm + 1 ) : NEW_LINE INDENT if i not in s . keys ( ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 3 , 5 , 8 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countNum ( arr , n ) ) NEW_LINE"],"bleu":0.6680461499847814,"rouge_l":0.7786712232385165}
{"id":1502,"predictions":["MAX_CHAR = 256 NEW_LINE def isPresent ( s , q ) : NEW_LINE INDENT freq = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) ] += 1 NEW_LINE DEDENT for i in range ( len ( q ) ) : NEW_LINE INDENT freq [ ord ( q [ i ] ) ] -= 1 NEW_LINE DEDENT for i in range ( len ( q ) ) : NEW_LINE INDENT freq [ ord ( q [ i ] ) ] -= 1 NEW_LINE if ( freq [ i ] < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" abcd \" NEW_LINE q = [ ] NEW_LINE if ( isPresent ( s , q ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["MAX_CHAR = 256 NEW_LINE def isPresent ( s , q ) : NEW_LINE INDENT freq = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) ] += 1 NEW_LINE DEDENT for i in range ( 0 , len ( q ) ) : NEW_LINE INDENT freq [ ord ( q [ i ] ) ] -= 1 NEW_LINE if ( freq [ ord ( q [ i ] ) ] < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT s = \" abctd \" NEW_LINE q = \" cat \" NEW_LINE if ( isPresent ( s , q ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.742235820655665,"rouge_l":0.8687878787878789}
{"id":1503,"predictions":["def area_of_circle ( m , n ) : NEW_LINE INDENT square_of_radius = ( m * n ) \/ 4 NEW_LINE area = ( 3.142 * square_of_circle ( m , n ) ) NEW_LINE return area NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 10 NEW_LINE m = 30 NEW_LINE print ( area_of_circle ( m , n ) ) NEW_LINE DEDENT"],"references":["def area_of_circle ( m , n ) : NEW_LINE INDENT square_of_radius = ( m * n ) \/ 4 NEW_LINE area = ( 3.141 * square_of_radius ) NEW_LINE return area NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE m = 30 NEW_LINE print ( area_of_circle ( m , n ) ) NEW_LINE DEDENT"],"bleu":0.7889652937834166,"rouge_l":0.9084139985107966}
{"id":1504,"predictions":["def printTwoSetBit ( n ) : NEW_LINE INDENT x = 1 NEW_LINE while ( ( n > 0 ) : NEW_LINE INDENT y = 0 NEW_LINE while ( y < x ) : NEW_LINE INDENT y = ( ( 1 << x ) + ( 1 << y ) ) NEW_LINE n -= 1 NEW_LINE x -= 1 NEW_LINE DEDENT x += 1 NEW_LINE DEDENT if ( n == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT x = 4 NEW_LINE printTwoSetBit ( n ) NEW_LINE"],"references":["def printTwoSetBitNums ( n ) : NEW_LINE INDENT x = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT y = 0 NEW_LINE while ( y < x ) : NEW_LINE INDENT print ( ( 1 << x ) + ( 1 << y ) , end = \" ▁ \" ) NEW_LINE n -= 1 NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT y += 1 NEW_LINE DEDENT x += 1 NEW_LINE DEDENT DEDENT printTwoSetBitNums ( 4 ) NEW_LINE"],"bleu":0.7416511750653129,"rouge_l":0.7853085952290798}
{"id":1505,"predictions":["def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ [ 0 for x in range ( k + 1 ) ] for y in range ( n ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; NEW_LINE DEDENT DEDENT DEDENT return C [ n ] [ k ] ; NEW_LINE DEDENT def findMax ( n , k ) : NEW_LINE INDENT return binomialCoeff ( n , n \/\/ 2 ) ; NEW_LINE DEDENT def findMaxCoeff ( n ) : NEW_LINE INDENT return binomialCoeff ( n \/\/ 2 ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 ; NEW_LINE print ( findMaxCoeff ( n , n \/\/ 2 ) ) ; NEW_LINE DEDENT"],"references":["def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ [ 0 for i in range ( k + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return C [ n ] [ k ] NEW_LINE DEDENT def findMax ( n ) : NEW_LINE INDENT return binomialCoeff ( n , n \/\/ 2 ) NEW_LINE DEDENT n = 5 NEW_LINE print ( findMax ( n ) ) NEW_LINE"],"bleu":0.6938211190399393,"rouge_l":0.8794162142920708}
{"id":1506,"predictions":["def solve ( arr , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT s = arr [ 0 ] NEW_LINE s = arr [ 0 ] NEW_LINE value = int ( s [ 0 ] ) NEW_LINE for i in range ( 1 , n , 2 ) : NEW_LINE INDENT s = arr [ i ] NEW_LINE value = int ( s [ i ] ) NEW_LINE value += value NEW_LINE if ( value == ' + ' ) : NEW_LINE INDENT s += value NEW_LINE DEDENT value -= value NEW_LINE DEDENT return s NEW_LINE DEDENT arr = [ 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( solve ( arr , n ) ) NEW_LINE"],"references":["def calculateSum ( arr , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT s = arr [ 0 ] NEW_LINE value = int ( s ) NEW_LINE sum = value NEW_LINE for i in range ( 2 , n , 2 ) : NEW_LINE INDENT s = arr [ i ] NEW_LINE value = int ( s ) NEW_LINE operation = arr [ i - 1 ] [ 0 ] NEW_LINE if ( operation == ' + ' ) : NEW_LINE INDENT sum += value NEW_LINE DEDENT else : NEW_LINE INDENT sum -= value NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT arr = [ \"3\" , \" + \" , \"4\" , \" - \" , \"7\" , \" + \" , \"13\" ] NEW_LINE n = len ( arr ) NEW_LINE print ( calculateSum ( arr , n ) ) NEW_LINE"],"bleu":0.6088495375216011,"rouge_l":0.7510259917920656}
{"id":1507,"predictions":["def checkpass ( x ) : NEW_LINE INDENT temp = x ; NEW_LINE n = 0 ; NEW_LINE while ( x != 0 ) : NEW_LINE INDENT x = x \/\/ 10 ; NEW_LINE n = n + 1 ; NEW_LINE DEDENT x = temp ; NEW_LINE while ( x ) : NEW_LINE INDENT sum += x % 10 ; NEW_LINE x \/= 10 ; NEW_LINE DEDENT return ( sum == temp ) ; NEW_LINE DEDENT x = 9234 ; NEW_LINE if ( checkpass ( x ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT"],"references":["import math NEW_LINE def checkplusperfect ( x ) : NEW_LINE INDENT temp = x NEW_LINE n = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT x = x \/\/ 10 NEW_LINE n = n + 1 NEW_LINE DEDENT x = temp NEW_LINE sm = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT sm = sm + ( int ) ( math . pow ( x % 10 , n ) ) NEW_LINE x = x \/\/ 10 NEW_LINE DEDENT return ( sm == temp ) NEW_LINE DEDENT x = 9474 NEW_LINE if ( checkplusperfect ( x ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.5395879227744146,"rouge_l":0.7834257131269432}
{"id":1508,"predictions":["def isPossible ( arr , p , n , m ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( p ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT if ( sum == ( n * m ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n , m = 3 , 4 NEW_LINE arr = [ 6 , 3 , 2 ] NEW_LINE if ( isPossible ( arr , n , m ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def isPossible ( arr , p , n , m ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( p ) : NEW_LINE INDENT sum += arr [ i ] ; NEW_LINE DEDENT if ( sum == ( n * m ) ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 ; NEW_LINE m = 4 ; NEW_LINE arr = [ 6 , 3 , 2 , 1 ] ; NEW_LINE p = len ( arr ) ; NEW_LINE if ( isPossible ( arr , p , n , m ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"],"bleu":0.6797825934124195,"rouge_l":0.8715340840295437}
{"id":1509,"predictions":["def reverse ( n ) : NEW_LINE INDENT d = 0 NEW_LINE s = str ( n ) NEW_LINE while ( n ) : NEW_LINE INDENT d = n % 10 NEW_LINE n = int ( n \/\/ 10 ) NEW_LINE DEDENT return s NEW_LINE DEDENT def isPalin ( n ) : NEW_LINE INDENT return n NEW_LINE DEDENT def sumOfArray ( arr , n ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > 10 ) : NEW_LINE INDENT s += arr [ i ] NEW_LINE DEDENT DEDENT return s NEW_LINE DEDENT def sumOfArray ( arr , n ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > 10 and isPalin ( arr [ i ] ) ) : NEW_LINE INDENT s += arr [ i ] NEW_LINE DEDENT DEDENT return s NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 6 NEW_LINE arr = [ 12 , 232 , 11 , 44 , 9 ] NEW_LINE print ( sumOfArray ( arr , n ) ) NEW_LINE DEDENT"],"references":["def reverse ( n ) : NEW_LINE INDENT d = 0 ; s = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT d = n % 10 ; NEW_LINE s = s * 10 + d ; NEW_LINE n = n \/\/ 10 ; NEW_LINE DEDENT return s ; NEW_LINE DEDENT def isPalin ( n ) : NEW_LINE INDENT return n == reverse ( n ) ; NEW_LINE DEDENT def sumOfArray ( arr , n ) : NEW_LINE INDENT s = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( arr [ i ] > 10 ) and isPalin ( arr [ i ] ) ) : NEW_LINE INDENT s += arr [ i ] ; NEW_LINE DEDENT DEDENT return s ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 6 ; NEW_LINE arr = [ 12 , 313 , 11 , 44 , 9 , 1 ] ; NEW_LINE print ( sumOfArray ( arr , n ) ) ; NEW_LINE DEDENT"],"bleu":0.6146197069477978,"rouge_l":0.7871304050589643}
{"id":1510,"predictions":["def minCost ( arr , n ) : NEW_LINE INDENT count_even = 0 NEW_LINE count_odd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT count_even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_even += 1 NEW_LINE DEDENT DEDENT return min ( count_even , count_odd ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 4 , 3 , 1 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minCost ( arr , n ) ) NEW_LINE DEDENT"],"references":["def minCost ( arr , n ) : NEW_LINE INDENT count_even = 0 NEW_LINE count_odd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT count_even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_odd += 1 NEW_LINE DEDENT DEDENT return min ( count_even , count_odd ) NEW_LINE DEDENT arr = [ 2 , 4 , 3 , 1 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minCost ( arr , n ) ) NEW_LINE"],"bleu":0.8365961602314098,"rouge_l":0.9344183820009577}
{"id":1511,"predictions":["def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a ; NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a ; NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return gcd ( a - b , b ) ; NEW_LINE DEDENT return gcd ( a - a , b ) ; NEW_LINE DEDENT def num ( arr , n ) : NEW_LINE INDENT return ( gcd ( arr [ n - 1 ] ) ) ; NEW_LINE DEDENT def numOfPairs ( arr , n ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( coprime ( arr [ i ] , arr [ i ] ) ) ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 5 , 4 , 8 , 3 , 9 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( numOfPairs ( arr , n ) ) ; NEW_LINE DEDENT"],"references":["def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return gcd ( a - b , b ) NEW_LINE DEDENT return gcd ( a , b - a ) NEW_LINE DEDENT def coprime ( a , b ) : NEW_LINE INDENT return ( gcd ( a , b ) == 1 ) NEW_LINE DEDENT def numOfPairs ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( coprime ( arr [ i ] , arr [ j ] ) ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 1 , 2 , 5 , 4 , 8 , 3 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE print ( numOfPairs ( arr , n ) ) NEW_LINE"],"bleu":0.6680402386927403,"rouge_l":0.805624611559975}
{"id":1512,"predictions":["def countSubarrays ( a , n , m ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT odd = 0 NEW_LINE for j in range ( i , n , 1 ) : NEW_LINE INDENT if ( a [ i ] % 2 == 0 ) : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT if ( odd == m ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT a = [ 2 , 2 , 5 , 6 , 9 , 2 , 11 ] NEW_LINE n = len ( a ) NEW_LINE m = 2 NEW_LINE print ( countSubarrays ( a , n , m ) ) NEW_LINE"],"references":["def countSubarrays ( a , n , m ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT odd = 0 ; NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if ( a [ j ] % 2 ) : NEW_LINE INDENT odd += 1 ; NEW_LINE DEDENT if ( odd == m ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT a = [ 2 , 2 , 5 , 6 , 9 , 2 , 11 ] ; NEW_LINE n = len ( a ) ; NEW_LINE m = 2 ; NEW_LINE print ( countSubarrays ( a , n , m ) ) ; NEW_LINE"],"bleu":0.7689063640681296,"rouge_l":0.9294938016528924}
{"id":1513,"predictions":["import math NEW_LINE def divide ( n , m ) : NEW_LINE INDENT return ( int ( math . log ( n ) & ( m - 1 ) ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 43 NEW_LINE m = 8 NEW_LINE print ( \" Q ▁ = ▁ \" , divide ( n , m ) ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def divide ( n , m ) : NEW_LINE INDENT print ( \" Remainder ▁ = ▁ \" , ( ( n ) & ( m - 1 ) ) ) NEW_LINE print ( \" Quotient ▁ = ▁ \" , ( n >> ( int ) ( math . log2 ( m ) ) ) ) NEW_LINE DEDENT n = 43 NEW_LINE m = 8 NEW_LINE divide ( n , m ) NEW_LINE"],"bleu":0.5758816049486143,"rouge_l":0.6003937007874016}
{"id":1514,"predictions":["import math as mt NEW_LINE def generateSubStrings ( s , m , q ) : NEW_LINE INDENT l = len ( s ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT temp = \" \" NEW_LINE for j in range ( i , l ) : NEW_LINE INDENT if ( s [ i ] == j ) : NEW_LINE INDENT temp += p NEW_LINE DEDENT else : NEW_LINE INDENT temp += s [ i ] NEW_LINE DEDENT DEDENT DEDENT DEDENT def binomialCoeff ( m , c ) : NEW_LINE INDENT for i in range ( 1 , l ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT x = m [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT m [ i ] = 1 NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE j = 1 NEW_LINE for i in range ( 1 , 100 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT if ( dp [ i ] [ j ] >= m [ i - 1 ] ) : NEW_LINE INDENT ans += C [ i - 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT ans += C [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT def answerQuery ( s , m , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT ans += C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = [ 2 , 3 , 4 ] NEW_LINE m = len ( s ) NEW_LINE queries = [ [ 2 , 3 ] , [ 2 , 4 ] ] NEW_LINE q = len ( queries ) NEW_LINE generateSubStrings ( s , m , queries ) NEW_LINE queries = [ 2 , 3 , 4 ] for i in range ( q ) ] NEW_LINE q ="],"references":["from collections import defaultdict NEW_LINE maxlen = 100 NEW_LINE def generateSubStrings ( s , mpp ) : NEW_LINE INDENT l = len ( s ) NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT temp = \" \" NEW_LINE for j in range ( i , l ) : NEW_LINE INDENT temp += s [ j ] NEW_LINE mpp [ temp ] += 1 NEW_LINE DEDENT DEDENT DEDENT def binomialCoeff ( C ) : NEW_LINE INDENT for i in range ( 0 , 100 ) : NEW_LINE INDENT for j in range ( 0 , 100 ) : NEW_LINE INDENT if j == 0 or j == i : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT def answerQuery ( mpp , C , k ) : NEW_LINE INDENT ans = 0 NEW_LINE for it in mpp : NEW_LINE INDENT if mpp [ it ] >= k : NEW_LINE INDENT ans += C [ mpp [ it ] ] [ k ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" aabaab \" NEW_LINE mpp = defaultdict ( lambda : 0 ) NEW_LINE generateSubStrings ( s , mpp ) NEW_LINE C = [ [ 0 for i in range ( maxlen ) ] for j in range ( maxlen ) ] NEW_LINE binomialCoeff ( C ) NEW_LINE queries = [ 2 , 3 , 4 ] NEW_LINE q = len ( queries ) NEW_LINE for i in range ( 0 , q ) : NEW_LINE INDENT print ( answerQuery ( mpp , C , queries [ i ] ) ) NEW_LINE DEDENT DEDENT"],"bleu":0.5609345117829296,"rouge_l":0.6162211803373774}
{"id":1515,"predictions":["def findProduct ( arr , n ) : NEW_LINE INDENT arr . sort ( reverse = True ) NEW_LINE prod = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( arr [ i ] != arr [ i + 1 ] ) : NEW_LINE INDENT prod = prod * arr [ i + 1 ] NEW_LINE DEDENT DEDENT return prod NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 1 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findProduct ( arr , n ) ) NEW_LINE DEDENT"],"references":["def findProduct ( arr , n ) : NEW_LINE INDENT sorted ( arr ) NEW_LINE prod = 1 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( arr [ i - 1 ] != arr [ i ] ) : NEW_LINE INDENT prod = prod * arr [ i ] NEW_LINE DEDENT DEDENT return prod ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 1 , 1 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findProduct ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.787118190417993,"rouge_l":0.8943032672437867}
{"id":1516,"predictions":["def SieveOfSundaram ( n ) : NEW_LINE INDENT nNew = ( n - 2 ) \/\/ 2 NEW_LINE marked = [ False for i in range ( nNew + 1 ) ] NEW_LINE for i in range ( 1 , nNew + 1 ) : NEW_LINE INDENT for j in range ( i , nNew + 2 ) : NEW_LINE INDENT if ( i + j + 2 * i * j > nNew ) : NEW_LINE INDENT marked [ i + j + 2 * j ] = True NEW_LINE DEDENT DEDENT DEDENT if ( n1 ) : NEW_LINE INDENT print ( 2 * i + 1 , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 20 NEW_LINE SieveOfSundaram ( n ) NEW_LINE DEDENT"],"references":["def SieveOfSundaram ( n ) : NEW_LINE INDENT nNew = int ( ( n - 2 ) \/ 2 ) ; NEW_LINE marked = [ 0 ] * ( nNew + 1 ) ; NEW_LINE for i in range ( 1 , nNew + 1 ) : NEW_LINE INDENT j = i ; NEW_LINE while ( ( i + j + 2 * i * j ) <= nNew ) : NEW_LINE INDENT marked [ i + j + 2 * i * j ] = 1 ; NEW_LINE j += 1 ; NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT print ( 2 , end = \" ▁ \" ) ; NEW_LINE DEDENT for i in range ( 1 , nNew + 1 ) : NEW_LINE INDENT if ( marked [ i ] == 0 ) : NEW_LINE INDENT print ( ( 2 * i + 1 ) , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT DEDENT n = 20 ; NEW_LINE SieveOfSundaram ( n ) ; NEW_LINE"],"bleu":0.5127348298466118,"rouge_l":0.6495284453909339}
{"id":1517,"predictions":["def solve ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT num = 2 NEW_LINE print ( num ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 NEW_LINE solve ( n ) NEW_LINE DEDENT"],"references":["def solve ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT print ( - 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT num = 2 ; NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT num = ( num * 10 ) + 3 ; NEW_LINE DEDENT print ( num ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 ; NEW_LINE solve ( n ) ; NEW_LINE DEDENT"],"bleu":0.5407377642033737,"rouge_l":0.7836717778698716}
{"id":1518,"predictions":["def minimumOperations ( arr , n ) : NEW_LINE INDENT brr = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT brr [ arr [ i ] % 4 ] += 1 NEW_LINE DEDENT if ( brr [ 1 ] + 2 == 0 ) : NEW_LINE INDENT min_cost = min ( brr [ 1 ] , brr [ 3 ] ) NEW_LINE DEDENT if ( ( brr [ 0 ] + 2 ) % 4 == 0 ) : NEW_LINE INDENT min_cost = min ( brr [ 0 ] , brr [ 2 ] ) NEW_LINE DEDENT if ( brr [ 1 ] == 1 ) : NEW_LINE INDENT min_cost = min ( brr [ 1 ] , brr [ 2 ] ) NEW_LINE DEDENT if ( brr [ 2 ] == 1 ) : NEW_LINE INDENT min_cost = min ( brr [ 2 ] , brr [ 3 ] ) NEW_LINE DEDENT if ( brr [ 1 ] == 1 ) : NEW_LINE INDENT min_cost = ( brr [ 0 ] , brr [ 2 ] ) NEW_LINE DEDENT DEDENT return min_cost NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 1 , 2 , 3 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minimumOperations ( arr , n ) ) NEW_LINE DEDENT"],"references":["def minimumOperations ( arr , n ) : NEW_LINE INDENT brr = [ 0 , 0 , 0 , 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT brr [ arr [ i ] % 4 ] += 1 ; NEW_LINE DEDENT if ( ( brr [ 1 ] + 2 * brr [ 2 ] + 3 * brr [ 3 ] ) % 4 == 0 ) : NEW_LINE INDENT min_opr = min ( brr [ 3 ] , brr [ 1 ] ) NEW_LINE brr [ 3 ] -= min_opr NEW_LINE brr [ 1 ] -= min_opr NEW_LINE min_opr += brr [ 2 ] \/\/ 2 NEW_LINE brr [ 2 ] %= 2 NEW_LINE if ( brr [ 2 ] ) : NEW_LINE INDENT min_opr += 2 NEW_LINE brr [ 2 ] = 0 NEW_LINE if ( brr [ 3 ] ) : NEW_LINE INDENT brr [ 3 ] -= 2 NEW_LINE DEDENT if ( brr [ 1 ] ) : NEW_LINE INDENT brr [ 1 ] -= 2 NEW_LINE DEDENT DEDENT if ( brr [ 1 ] ) : NEW_LINE INDENT min_opr += ( brr [ 1 ] \/\/ 4 ) * 3 NEW_LINE DEDENT if ( brr [ 3 ] ) : NEW_LINE INDENT min_opr += ( brr [ 3 ] \/\/ 4 ) * 3 NEW_LINE DEDENT return min_opr NEW_LINE DEDENT return - 1 NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 1 , 2 , 3 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minimumOperations ( arr , n ) ) NEW_LINE"],"bleu":0.5682155906377601,"rouge_l":0.6637985575098063}
{"id":1519,"predictions":["import sys NEW_LINE INT_MAX = sys . maxsize NEW_LINE def minFn ( arr ) : NEW_LINE INDENT min = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT min = sys . maxsize NEW_LINE arr [ i ] [ i ] = arr [ i ] [ i ] NEW_LINE DEDENT return min NEW_LINE DEDENT def minGraph ( arr ) : NEW_LINE INDENT min = sys . maxsize NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT if ( arr [ i ] [ j ] == 0 ) : NEW_LINE INDENT arr [ i ] [ j ] = - sys . maxsize NEW_LINE DEDENT DEDENT for i in range ( arr ) : NEW_LINE INDENT for j in range ( arr [ i ] ) : NEW_LINE INDENT if ( arr [ i ] [ j ] != INT_MAX ) : NEW_LINE INDENT arr [ i ] [ j ] = INT_MAX NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT arr [ i ] [ j ] = INT_MAX NEW_LINE min = 0 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( arr [ i ] [ j ] ) : NEW_LINE INDENT if ( arr [ i ] [ j ] != INT_MAX ) : NEW_LINE INDENT arr [ i ] [ j ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT DEDENT def minimumGraph ( arr ) : NEW_LINE INDENT minimum = sys . maxsize NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT for j in range ( len ( arr [ i ] ) ) : NEW_LINE INDENT if ( arr [ i ] [ j ] [ j ] != INT_MAX ) : NEW_LINE INDENT print ( arr [ i ] [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ [ 1"],"references":["def minFn ( arr ) : NEW_LINE INDENT minimum = float ( ' inf ' ) NEW_LINE for i in range ( 0 , 4 ) : NEW_LINE INDENT if minimum > arr [ i ] : NEW_LINE INDENT minimum = arr [ i ] NEW_LINE DEDENT DEDENT return minimum NEW_LINE DEDENT def minimizeGraph ( arr ) : NEW_LINE INDENT for i in range ( 0 , 4 ) : NEW_LINE INDENT for j in range ( 0 , 4 ) : NEW_LINE INDENT if arr [ i ] [ j ] == 0 : NEW_LINE INDENT arr [ i ] [ j ] = float ( ' inf ' ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( 0 , 4 ) : NEW_LINE INDENT minimum = minFn ( arr [ i ] ) NEW_LINE for j in range ( 0 , 4 ) : NEW_LINE INDENT if ( ( not ( arr [ i ] [ j ] == minimum ) ) or ( arr [ i ] [ j ] == float ( ' inf ' ) ) ) : NEW_LINE INDENT arr [ i ] [ j ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT minimum = 0 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 0 , 4 ) : NEW_LINE INDENT for j in range ( 0 , 4 ) : NEW_LINE INDENT print ( arr [ i ] [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ [ 1 , 2 , 4 , 0 ] , [ 0 , 0 , 0 , 5 ] , [ 0 , 2 , 0 , 3 ] , [ 0 , 0 , 0 , 0 ] ] NEW_LINE minimizeGraph ( arr ) NEW_LINE DEDENT"],"bleu":0.49471151954159537,"rouge_l":0.5798422264687147}
{"id":1520,"predictions":["def getNumToAdd ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE d = arr [ 1 ] - arr [ 0 ] NEW_LINE num1 = arr [ 1 ] - arr [ 2 ] NEW_LINE num2 = arr [ 1 ] - arr [ 0 ] NEW_LINE num1 = 0 NEW_LINE for i in range ( 2 , n , 1 ) : NEW_LINE INDENT diff = arr [ i ] - arr [ i - 1 ] NEW_LINE if diff != d : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( diff == 2 * d ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT num1 = arr [ i ] - d NEW_LINE if ( diff == 2 * d ) : NEW_LINE INDENT return num1 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT return ( arr [ 1 ] + d ) NEW_LINE DEDENT arr = [ 1 , 3 , 5 , 7 , 11 , 15 , 15 ] NEW_LINE n = len ( arr ) NEW_LINE print ( getNumToAdd ( arr , n ) ) NEW_LINE"],"references":["def getNumToAdd ( arr , n ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE d = arr [ 1 ] - arr [ 0 ] NEW_LINE numToAdd = - 1 NEW_LINE numAdded = False NEW_LINE for i in range ( 2 , n , 1 ) : NEW_LINE INDENT diff = arr [ i ] - arr [ i - 1 ] NEW_LINE if ( diff != d ) : NEW_LINE INDENT if ( numAdded ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( diff == 2 * d ) : NEW_LINE INDENT numToAdd = arr [ i ] - d NEW_LINE numAdded = True NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT DEDENT if ( numToAdd == - 1 ) : NEW_LINE INDENT return ( arr [ n - 1 ] + d ) NEW_LINE DEDENT return numToAdd NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 3 , 5 , 7 , 11 , 13 , 15 ] NEW_LINE n = len ( arr ) NEW_LINE print ( getNumToAdd ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.6917682015973513,"rouge_l":0.7602193419740779}
{"id":1521,"predictions":["PI = 3.14159265 NEW_LINE def findAngle ( a , b , c ) : NEW_LINE INDENT A = acos ( ( b * b + c * c ) \/ ( 2 * a ) NEW_LINE return A * 180 \/ A NEW_LINE DEDENT def findAngle ( a , b , c ) : NEW_LINE INDENT B = acos ( a * a + c * b ) \/ ( 2 * b ) NEW_LINE return A * 180 \/ A NEW_LINE DEDENT def printAngle ( a , b , c ) : NEW_LINE INDENT A = acos ( a * c ) NEW_LINE B = findAngle ( b * a + c ) NEW_LINE C = findAngle ( a , b , c ) NEW_LINE return A * A \/\/ B NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 12 NEW_LINE b = 0 NEW_LINE c = findAngle ( x , y , z ) NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT print ( \" Interle ▁ A ▁ = ▁ \" , ( \" , ▁ A ▁ = ▁ \" , abs ( b ) ) NEW_LINE DEDENT elif ( n % 2 != 0 ) : NEW_LINE INDENT b = findAngle ( int , a ) , \" , ▁ B ▁ = ▁ \" , int ( c ) NEW_LINE c = findAngle ( x , b , c ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( n % 2 == 1 ) : NEW_LINE INDENT b = - 1 NEW_LINE c = findAngle ( int ( a \/ 4 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT b = n * n \/\/ 4 - 1 NEW_LINE c = n * n \/\/ 4 + 1 NEW_LINE DEDENT DEDENT print ( \" Side ▁ = ▁ \" , ▁ = ▁ \" , ▁ \" , end = \" ▁ \" ) NEW_LINE print ( \" , ▁ \" , ▁ \" , b , \" , ▁ = ▁ \" , c ) NEW_LINE DEDENT a = 12 NEW_LINE b ="],"references":["import math NEW_LINE PI = 3.1415926535 NEW_LINE def findAnglesA ( a , b , c ) : NEW_LINE INDENT A = math . acos ( ( b * b + c * c - a * a ) \/ ( 2 * b * c ) ) NEW_LINE return A * 180 \/ PI NEW_LINE DEDENT def findAnglesB ( a , b , c ) : NEW_LINE INDENT B = math . acos ( ( a * a + c * c - b * b ) \/ ( 2 * a * c ) ) NEW_LINE return B * 180 \/ PI NEW_LINE DEDENT def printAngles ( a , b , c ) : NEW_LINE INDENT x = a NEW_LINE y = b NEW_LINE z = c NEW_LINE A = findAnglesA ( x , y , z ) NEW_LINE B = findAnglesB ( x , y , z ) NEW_LINE print ( \" Angles ▁ are ▁ A ▁ = ▁ \" , A , \" , ▁ B ▁ = ▁ \" , B , \" , ▁ C ▁ = ▁ \" , \"90 ▁ \" ) NEW_LINE DEDENT def printOtherSides ( n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT else : NEW_LINE INDENT b = ( n * n - 1 ) \/\/ 2 NEW_LINE c = ( n * n + 1 ) \/\/ 2 NEW_LINE print ( \" Side ▁ b ▁ = ▁ \" , b , \" ▁ Side ▁ c ▁ = ▁ \" , c ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( n == 2 ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT else : NEW_LINE INDENT b = n * n \/\/ 4 - 1 ; NEW_LINE c = n * n \/\/ 4 + 1 ; NEW_LINE print ( \" Side ▁ b ▁ = ▁ \" , b , \" , ▁ Side ▁ c ▁ = ▁ \" , c ) NEW_LINE DEDENT DEDENT printAngles ( n , b , c ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 12 NEW_LINE printOtherSides ( a ) NEW_LINE DEDENT"],"bleu":0.5527623565818155,"rouge_l":0.5902120858710206}
{"id":1522,"predictions":["import math NEW_LINE def MaximumHeight ( a , n ) : NEW_LINE INDENT return ( ( - 1 + math . sqrt ( 1 + a * n ) ) \/ 2 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 40 , 100 , 20 , 30 ] NEW_LINE n = len ( arr ) NEW_LINE print ( MaximumHeight ( arr , n ) ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def MaximumHeight ( a , n ) : NEW_LINE INDENT return ( - 1 + int ( math . sqrt ( 1 + ( 8 * n ) ) ) ) \/\/ 2 NEW_LINE DEDENT arr = [ 40 , 100 , 20 , 30 ] NEW_LINE n = len ( arr ) NEW_LINE print ( MaximumHeight ( arr , n ) ) NEW_LINE"],"bleu":0.6746546157649211,"rouge_l":0.8390646492434664}
{"id":1523,"predictions":["def firstElement ( arr , n , k ) : NEW_LINE INDENT count_map = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT a = 0 NEW_LINE if ( count_map [ arr [ i ] ] ) : NEW_LINE INDENT a = count_map . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT count_map [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( count_map [ arr [ i ] ] == k ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 1 , 7 , 4 , 3 , 4 , 7 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE print ( firstElement ( arr , n , k ) ) NEW_LINE"],"references":["def firstElement ( arr , n , k ) : NEW_LINE INDENT count_map = { } ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] in count_map . keys ( ) ) : NEW_LINE INDENT count_map [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_map [ arr [ i ] ] = 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( count_map [ arr [ i ] ] == k ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 7 , 4 , 3 , 4 , 8 , 7 ] ; NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE print ( firstElement ( arr , n , k ) ) NEW_LINE DEDENT"],"bleu":0.6603933585558609,"rouge_l":0.7995466640386322}
{"id":1524,"predictions":["def solve ( a , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT r = i + 1 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( a [ i ] == a [ j ] ) : NEW_LINE INDENT r += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT d = r - 1 NEW_LINE ans += ( d * ( d + 1 ) ) \/\/ 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT a = [ 2 , 4 , 5 , 3 , 3 ] NEW_LINE n = len ( a ) NEW_LINE print ( solve ( a , n ) ) NEW_LINE"],"references":["def calculate ( a , n ) : NEW_LINE INDENT ans = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT r = i + 1 ; NEW_LINE for j in range ( r , n ) : NEW_LINE INDENT if ( a [ i ] == a [ j ] ) : NEW_LINE INDENT r = r + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT d = r - i ; NEW_LINE ans = ans + ( d * ( d + 1 ) \/ 2 ) ; NEW_LINE i = r - 1 ; NEW_LINE i = i + 1 ; NEW_LINE DEDENT return int ( ans ) ; NEW_LINE DEDENT a = [ 2 , 4 , 5 , 3 , 3 , 3 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( calculate ( a , n ) ) ; NEW_LINE"],"bleu":0.5485846684679743,"rouge_l":0.7735994706660785}
{"id":1525,"predictions":["def nth_groups ( n ) : NEW_LINE INDENT return n * ( 2 * pow ( n , 2 ) + 1 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 5 NEW_LINE print ( nth_groups ( N ) ) NEW_LINE DEDENT"],"references":["def nth_group ( n ) : NEW_LINE INDENT return n * ( 2 * pow ( n , 2 ) + 1 ) NEW_LINE DEDENT N = 5 NEW_LINE print ( nth_group ( N ) ) NEW_LINE"],"bleu":0.6046736660745399,"rouge_l":0.8189489835059456}
{"id":1526,"predictions":["class Case ( object ) : NEW_LINE INDENT def __init__ ( self , string , size ) : NEW_LINE INDENT self . string = string . strip ( ) NEW_LINE self . sort ( reverse = True ) NEW_LINE DEDENT def print_parse ( self , string , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( self . string [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT def print_parse ( self , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( self . string [ i ] , end = \" \" ) NEW_LINE DEDENT DEDENT def printAnagramArray ( self , string , size ) : NEW_LINE INDENT return self . string [ 0 ] , string [ size - 1 ] , string [ size - 1 ] NEW_LINE DEDENT def printAnagramArray ( self , stringArr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( string [ i ] , end = \" \" ) NEW_LINE DEDENT DEDENT def printAnagrams ( self , stringArr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( stringArr [ stringArr ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT def printAnagram ( wordArr , size ) : NEW_LINE INDENT print ( wordArr ( wordArr , size ) , end = \" ▁ \" ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT print ( wordArr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT def printAnagrams ( wordArr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( wordArr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT wordArr ( wordArr ( wordArr , size ) NEW_LINE DEDENT DEDENT"],"references":["class Word ( object ) : NEW_LINE INDENT def __init__ ( self , string , index ) : NEW_LINE INDENT self . string = string NEW_LINE self . index = index NEW_LINE DEDENT DEDENT def createDupArray ( string , size ) : NEW_LINE INDENT dupArray = [ ] NEW_LINE for i in xrange ( size ) : NEW_LINE INDENT dupArray . append ( Word ( string [ i ] , i ) ) NEW_LINE DEDENT return dupArray NEW_LINE DEDENT def printAnagramsTogether ( wordArr , size ) : NEW_LINE INDENT dupArray = createDupArray ( wordArr , size ) NEW_LINE for i in xrange ( size ) : NEW_LINE INDENT dupArray [ i ] . string = ' ' . join ( sorted ( dupArray [ i ] . string ) ) NEW_LINE DEDENT dupArray = sorted ( dupArray , key = lambda k : k . string ) NEW_LINE for word in dupArray : NEW_LINE INDENT print wordArr [ word . index ] , NEW_LINE DEDENT DEDENT wordArr = [ \" cat \" , \" dog \" , \" tac \" , \" god \" , \" act \" ] NEW_LINE size = len ( wordArr ) NEW_LINE printAnagramsTogether ( wordArr , size ) NEW_LINE"],"bleu":0.239883080720002,"rouge_l":0.48587142044377013}
{"id":1527,"predictions":["def minAbsSum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE min_sum = 999999 NEW_LINE l = 0 NEW_LINE r = n - 1 NEW_LINE if ( n < 2 ) : NEW_LINE INDENT if ( arr [ r ] <= arr [ r ] ) : NEW_LINE INDENT print ( \" Invalid ▁ Input \" ) NEW_LINE return NEW_LINE DEDENT if ( arr [ r ] < abs ( arr [ r ] ) ) : NEW_LINE INDENT min_sum = arr [ r ] NEW_LINE DEDENT while ( l < r ) : NEW_LINE INDENT sum = arr [ l ] + arr [ r ] NEW_LINE min_sum = sum NEW_LINE if ( sum < 0 ) : NEW_LINE INDENT min_sum = sum NEW_LINE DEDENT else : NEW_LINE INDENT r = r NEW_LINE min_val = int ( arr [ r ] ) NEW_LINE DEDENT DEDENT if ( sum < 0 ) : NEW_LINE INDENT l = arr [ l ] NEW_LINE DEDENT else : NEW_LINE INDENT l = arr [ r ] NEW_LINE DEDENT DEDENT def partition ( arr , n ) : NEW_LINE INDENT pivot = arr [ r ] NEW_LINE i = l - 1 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( arr [ i ] <= pivot ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = arr [ i ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT return i + 1 NEW_LINE DEDENT arr = [ 1 , 60 , - 10 , 70 , - 80 ] NEW_LINE n = len ( arr ) NEW_LINE return int ( arr ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 60 , - 10 , - 80 ] NEW_LINE arr = [ 0 , 60 , 70 , - 80 ] NEW_LINE n = len ( arr ) NEW_LINE minAbsderSum ( arr , n ) NEW_LINE arr . sort ( ) NEW_LINE print ( \" The ▁ minimum ▁ pair ▁ ="],"references":["def partition ( arr , si , ei ) : NEW_LINE INDENT x = arr [ ei ] NEW_LINE i = ( si - 1 ) NEW_LINE for j in range ( si , ei ) : NEW_LINE INDENT if ( arr [ j ] <= x ) : NEW_LINE INDENT i += 1 NEW_LINE arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE DEDENT DEDENT arr [ i + 1 ] , arr [ ei ] = arr [ ei ] , arr [ i + 1 ] NEW_LINE return ( i + 1 ) NEW_LINE DEDENT def quickSort ( arr , si , ei ) : NEW_LINE INDENT pi = 0 NEW_LINE if ( si < ei ) : NEW_LINE INDENT pi = partition ( arr , si , ei ) NEW_LINE quickSort ( arr , si , pi - 1 ) NEW_LINE quickSort ( arr , pi + 1 , ei ) NEW_LINE DEDENT DEDENT def minAbsSumPair ( arr , n ) : NEW_LINE INDENT sum , min_sum = 0 , 10 ** 9 NEW_LINE l = 0 NEW_LINE r = n - 1 NEW_LINE min_l = l NEW_LINE min_r = n - 1 NEW_LINE if ( n < 2 ) : NEW_LINE INDENT print ( \" Invalid ▁ Input \" , end = \" \" ) NEW_LINE return NEW_LINE DEDENT quickSort ( arr , l , r ) NEW_LINE while ( l < r ) : NEW_LINE INDENT sum = arr [ l ] + arr [ r ] NEW_LINE if ( abs ( sum ) < abs ( min_sum ) ) : NEW_LINE INDENT min_sum = sum NEW_LINE min_l = l NEW_LINE min_r = r NEW_LINE DEDENT if ( sum < 0 ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT DEDENT print ( \" The ▁ two ▁ elements ▁ whose ▁ sum ▁ is ▁ minimum ▁ are \" , arr [ min_l ] , \" and \" , arr [ min_r ] ) NEW_LINE DEDENT arr = [ 1 , 60 , - 10 , 70 , - 80 , 85 ] NEW_LINE n = len ( arr ) NEW_LINE minAbsSumPair ( arr , n ) NEW_LINE"],"bleu":0.48255260027208546,"rouge_l":0.4243945398502862}
{"id":1528,"predictions":["def countFreq ( arr , n ) : NEW_LINE INDENT mp = { i : 0 for i in range ( ] } ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] -= 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( mp [ arr [ i ] ] != - 1 ) : NEW_LINE INDENT print ( arr [ i ] , arr [ i ] ) NEW_LINE mp [ arr [ i ] ] -= 1 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 10 , 20 , 20 , 10 , 20 , 20 , 20 ] NEW_LINE n = len ( arr ) NEW_LINE countFreq ( arr , n ) NEW_LINE DEDENT"],"references":["def countFreq ( arr , n ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] not in mp : NEW_LINE INDENT mp [ arr [ i ] ] = 0 NEW_LINE DEDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( mp [ arr [ i ] ] != - 1 ) : NEW_LINE INDENT print ( arr [ i ] , mp [ arr [ i ] ] ) NEW_LINE DEDENT mp [ arr [ i ] ] = - 1 NEW_LINE DEDENT DEDENT arr = [ 10 , 20 , 20 , 10 , 10 , 20 , 5 , 20 ] NEW_LINE n = len ( arr ) NEW_LINE countFreq ( arr , n ) NEW_LINE"],"bleu":0.6985336160637893,"rouge_l":0.8066222363270918}
{"id":1529,"predictions":["import math NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT sr = math . sqrt ( x ) NEW_LINE return ( ( sr - math . floor ( sr ) ) ) NEW_LINE DEDENT def isPerfectSquare ( x ) : NEW_LINE INDENT return ( ( x - math . floor ( sr ) ) == True ) NEW_LINE DEDENT def isPerfectSquare ( x ) : NEW_LINE INDENT return ( isPerfectSquare ( 5 * n * n + 4 ) ) NEW_LINE DEDENT def isPerfectSquare ( x ) : NEW_LINE INDENT return isPerfectSquare ( 5 * n * n + 4 ) NEW_LINE DEDENT def totalPair ( a , b , n , m ) : NEW_LINE INDENT s = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT j = 0 NEW_LINE if isPerfectSquare ( a [ i ] + b [ j ] ) : NEW_LINE INDENT if ( isPerfectSquare ( b [ i ] + a [ j ] ) ) : NEW_LINE INDENT s . append ( ( a [ i ] + b [ j ] ) ) NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT return len ( s ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 99 , 1 ] NEW_LINE b = [ 1 , 11 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE print ( totalPair ( a , b , n , m ) ) NEW_LINE DEDENT"],"references":["from math import sqrt , floor NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT sr = sqrt ( x ) NEW_LINE return ( ( sr - floor ( sr ) ) == 0 ) NEW_LINE DEDENT def isFibonacci ( n ) : NEW_LINE INDENT return ( isPerfectSquare ( 5 * n * n + 4 ) or isPerfectSquare ( 5 * n * n - 4 ) ) NEW_LINE DEDENT def totalPairs ( a , b , n , m ) : NEW_LINE INDENT s = set ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( isFibonacci ( a [ i ] + b [ j ] ) == True ) : NEW_LINE INDENT if ( a [ i ] < b [ j ] ) : NEW_LINE INDENT s . add ( ( a [ i ] , b [ j ] ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT s . add ( ( b [ j ] , a [ i ] ) ) ; NEW_LINE DEDENT DEDENT DEDENT DEDENT return len ( s ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 99 , 1 , 33 , 2 ] ; NEW_LINE b = [ 1 , 11 , 2 ] ; NEW_LINE n = len ( a ) ; NEW_LINE m = len ( b ) ; NEW_LINE print ( totalPairs ( a , b , n , m ) ) ; NEW_LINE DEDENT"],"bleu":0.6062171466531086,"rouge_l":0.7387543252595156}
{"id":1530,"predictions":["def countSolutions ( n ) : NEW_LINE INDENT res = 0 NEW_LINE for x in range ( n ) : NEW_LINE INDENT for y in range ( x * x + y + 1 ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT print ( \" Total ▁ Number ▁ of ▁ distinct ▁ pairs ▁ is \" , countSolutions ( 6 ) ) NEW_LINE"],"references":["def countSolutions ( n ) : NEW_LINE INDENT res = 0 NEW_LINE x = 0 NEW_LINE while ( x * x < n ) : NEW_LINE INDENT y = 0 NEW_LINE while ( x * x + y * y < n ) : NEW_LINE INDENT res = res + 1 NEW_LINE y = y + 1 NEW_LINE DEDENT x = x + 1 NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( \" Total ▁ Number ▁ of ▁ distinct ▁ Non - Negative ▁ pairs ▁ is ▁ \" , countSolutions ( 6 ) ) NEW_LINE DEDENT"],"bleu":0.3752394402594312,"rouge_l":0.6475809258614689}
{"id":1531,"predictions":["def findLength ( st , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT l = i NEW_LINE r = i + 1 NEW_LINE lsum = 0 NEW_LINE lsum = 0 NEW_LINE while ( r < n and l >= 0 ) : NEW_LINE INDENT lsum += st [ ord ( st [ l ] ) - ord ( '0' ) ] NEW_LINE rsum += st [ r ] NEW_LINE if ( lsum == rSum ) : NEW_LINE INDENT ans = max ( ans , r - lsum + 1 ) NEW_LINE lsum -= 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT st = \"123\" NEW_LINE print ( \" Length ▁ of ▁ the ▁ largest ▁ substring ▁ is \" , findLength ( st , len ( st ) ) ) NEW_LINE"],"references":["def findLength ( st , n ) : NEW_LINE INDENT total = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT total [ i ] = ( total [ i - 1 ] + int ( st [ i - 1 ] ) - int ( '0' ) ) NEW_LINE DEDENT ans = 0 NEW_LINE l = 2 NEW_LINE while ( l <= n ) : NEW_LINE INDENT for i in range ( n - l + 1 ) : NEW_LINE INDENT j = i + l - 1 NEW_LINE if ( total [ i + int ( l \/ 2 ) ] - total [ i ] == total [ i + l ] - total [ i + int ( l \/ 2 ) ] ) : NEW_LINE INDENT ans = max ( ans , l ) NEW_LINE DEDENT DEDENT l = l + 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT st = \"123123\" NEW_LINE print ( \" Length ▁ of ▁ the ▁ substring ▁ is \" , findLength ( st , len ( st ) ) ) NEW_LINE"],"bleu":0.36497196972907564,"rouge_l":0.5552150088232563}
{"id":1532,"predictions":["def min ( x , y ) : NEW_LINE INDENT if x < y : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT return y NEW_LINE DEDENT DEDENT def findLength ( arr , n ) : NEW_LINE INDENT max_len = 1 NEW_LINE mn = arr [ 0 ] NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT mn = min ( mn , arr [ i + 1 ] ) NEW_LINE mx = max ( mn , arr [ i ] ) NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT mn = min ( mn , arr [ j ] ) NEW_LINE mx = max ( mx , arr [ j ] ) NEW_LINE DEDENT DEDENT return max_len NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ [ 1 , 56 , 65 , 90 , 90 , 89 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Length ▁ of ▁ the ▁ largest ▁ subset ▁ is \" , findLength ( arr , n ) ) NEW_LINE DEDENT"],"references":["def min ( x , y ) : NEW_LINE INDENT return x if ( x < y ) else y NEW_LINE DEDENT def max ( x , y ) : NEW_LINE INDENT return x if ( x > y ) else y NEW_LINE DEDENT def findLength ( arr , n ) : NEW_LINE INDENT max_len = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT mn = arr [ i ] NEW_LINE mx = arr [ i ] NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT mn = min ( mn , arr [ j ] ) NEW_LINE mx = max ( mx , arr [ j ] ) NEW_LINE if ( ( mx - mn ) == j - i ) : NEW_LINE INDENT max_len = max ( max_len , mx - mn + 1 ) NEW_LINE DEDENT DEDENT DEDENT return max_len NEW_LINE DEDENT arr = [ 1 , 56 , 58 , 57 , 90 , 92 , 94 , 93 , 91 , 45 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Length ▁ of ▁ the ▁ longest ▁ contiguous ▁ subarray ▁ is ▁ \" , findLength ( arr , n ) ) NEW_LINE"],"bleu":0.6055474619761146,"rouge_l":0.7176470588235294}
{"id":1533,"predictions":["def findCombinationsUtil ( arr , index , optimalNum ) : NEW_LINE INDENT if ( optimalNum < 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( optimalNum < 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( optimalNum == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( optimalNum == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT prevNum = 0 NEW_LINE for index in range ( lastNum + 1 ) : NEW_LINE INDENT arr [ index ] = k NEW_LINE findCombinationsUtil ( arr , index + 1 , num , optimalNum - k , optimalNum - k ) NEW_LINE DEDENT else : NEW_LINE INDENT arr [ index ] = k NEW_LINE findCombinationsUtil ( arr , index + 1 , num , optimalNum - k + 1 , optimalNum - k ) NEW_LINE DEDENT DEDENT DEDENT def findCombinations ( n ) : NEW_LINE INDENT arr = [ 0 ] * n NEW_LINE findCombinationsUtil ( arr , 0 , n , optimalNum ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE findCombinations ( n ) NEW_LINE DEDENT"],"references":["def findCombinationsUtil ( arr , index , num , reducedNum ) : NEW_LINE INDENT if ( reducedNum < 0 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT if ( reducedNum == 0 ) : NEW_LINE INDENT for i in range ( index ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( \" \" ) ; NEW_LINE return ; NEW_LINE DEDENT prev = 1 if ( index == 0 ) else arr [ index - 1 ] ; NEW_LINE for k in range ( prev , num + 1 ) : NEW_LINE INDENT arr [ index ] = k ; NEW_LINE findCombinationsUtil ( arr , index + 1 , num , reducedNum - k ) ; NEW_LINE DEDENT DEDENT def findCombinations ( n ) : NEW_LINE INDENT arr = [ 0 ] * n ; NEW_LINE findCombinationsUtil ( arr , 0 , n , n ) ; NEW_LINE DEDENT n = 5 ; NEW_LINE findCombinations ( n ) ; NEW_LINE"],"bleu":0.4545967814921374,"rouge_l":0.652257356973131}
{"id":1534,"predictions":["import math NEW_LINE def fib ( n ) : NEW_LINE INDENT phi = ( 1 + math . sqrt ( 5 ) ) \/ 2 ; NEW_LINE return ( pow ( phi , n ) \/ math . sqrt ( 5 ) ) ; NEW_LINE DEDENT def calculateSum ( l , r ) : NEW_LINE INDENT sum = fib ( r + 2 ) - fib ( l + 1 ) ) ; NEW_LINE return sum ; NEW_LINE DEDENT l = 4 ; r = 8 ; NEW_LINE print ( calculateSum ( l , r ) ) ; NEW_LINE"],"references":["import math NEW_LINE def fib ( n ) : NEW_LINE INDENT phi = ( 1 + math . sqrt ( 5 ) ) \/ 2 ; NEW_LINE return int ( round ( pow ( phi , n ) \/ math . sqrt ( 5 ) ) ) ; NEW_LINE DEDENT def calculateSum ( l , r ) : NEW_LINE INDENT sum = fib ( r + 2 ) - fib ( l + 1 ) ; NEW_LINE return sum ; NEW_LINE DEDENT l = 4 ; NEW_LINE r = 8 ; NEW_LINE print ( calculateSum ( l , r ) ) ; NEW_LINE"],"bleu":0.9153015559307565,"rouge_l":0.9668445738314735}
{"id":1535,"predictions":["def MinimumValue ( x , y ) : NEW_LINE INDENT if ( x > y ) : NEW_LINE INDENT temp = x NEW_LINE x = y NEW_LINE y = y NEW_LINE DEDENT a = 1 NEW_LINE b = x - b NEW_LINE c = y - c NEW_LINE print ( a , \" ▁ \" , b , \" ▁ \" , c ) NEW_LINE DEDENT x = 123 NEW_LINE y = 13 NEW_LINE minValue ( x , y ) NEW_LINE"],"references":["def MinimumValue ( x , y ) : NEW_LINE INDENT if ( x > y ) : NEW_LINE INDENT x , y = y , x NEW_LINE DEDENT a = 1 NEW_LINE b = x - 1 NEW_LINE c = y - b NEW_LINE print ( a , b , c ) NEW_LINE DEDENT x = 123 NEW_LINE y = 13 NEW_LINE MinimumValue ( x , y ) NEW_LINE"],"bleu":0.6681123791150836,"rouge_l":0.8522954091816368}
{"id":1536,"predictions":["def maximumChars ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE res = - 1 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( str [ i ] == str [ j ] ) : NEW_LINE INDENT res = max ( res , abs ( str [ i ] - str [ j - 1 ] ) ) NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT str = \" abaa \" NEW_LINE print ( maximumChars ( str ) ) NEW_LINE"],"references":["def maximumChars ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE res = - 1 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( str [ i ] == str [ j ] ) : NEW_LINE INDENT res = max ( res , abs ( j - i - 1 ) ) NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" abba \" NEW_LINE print ( maximumChars ( str ) ) NEW_LINE DEDENT"],"bleu":0.7957287709755371,"rouge_l":0.8760734379626888}
{"id":1537,"predictions":["def printTribRec ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 or n == 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 3 or n == 2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT def printTrib ( n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT printTribRec ( n - 1 ) NEW_LINE DEDENT DEDENT def printTribRec ( n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT print ( printTribRec ( i ) , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 10 NEW_LINE printTrib ( n ) NEW_LINE DEDENT"],"references":["def printTribRec ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 or n == 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( n == 3 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( printTribRec ( n - 1 ) + printTribRec ( n - 2 ) + printTribRec ( n - 3 ) ) NEW_LINE DEDENT DEDENT def printTrib ( n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT print ( printTribRec ( i ) , \" ▁ \" , end = \" \" ) NEW_LINE DEDENT DEDENT n = 10 NEW_LINE printTrib ( n ) NEW_LINE"],"bleu":0.6554749911684882,"rouge_l":0.7958201393286889}
{"id":1538,"predictions":["def steps ( N , M ) : NEW_LINE INDENT if ( N == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( N == 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( N == 2 ) : NEW_LINE INDENT return ( 2 * M + ( N - 3 ) ) NEW_LINE DEDENT return steps ( 2 * M + ( N - 3 ) ) NEW_LINE DEDENT N = 4 NEW_LINE M = 4 NEW_LINE print ( steps ( N , M ) ) NEW_LINE"],"references":["def steps ( N , M ) : NEW_LINE INDENT if ( N == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( N == 2 ) : NEW_LINE INDENT return M NEW_LINE DEDENT return 2 * M + ( N - 3 ) NEW_LINE DEDENT N = 4 NEW_LINE M = 4 NEW_LINE print ( steps ( N , M ) ) NEW_LINE"],"bleu":0.6649191544102692,"rouge_l":0.8609923011120616}
{"id":1539,"predictions":["def waysToKAdjacentBits ( n , k , current ) : NEW_LINE INDENT if ( current == k ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( current == n ) : NEW_LINE INDENT return k NEW_LINE DEDENT if ( current != 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT noOfWays ( n , k , current ) NEW_LINE noOfWays ( n , k , current ) NEW_LINE noOfBays ( n , k , current ) NEW_LINE noOfWays ( n , k , current ) NEW_LINE noOfWays ( n , k , current ) NEW_LINE noOfWays ( n , k , current ) NEW_LINE noOfWays ( n , k , current ) NEW_LINE DEDENT return noOfWays ( n , k , current ) NEW_LINE DEDENT n = 5 NEW_LINE k = 2 NEW_LINE totalPaint ( n , k , current ) NEW_LINE print ( \" Number ▁ of ▁ ways \" , \" , end = ' ' ) NEW_LINE"],"references":["def waysToKAdjacentSetBits ( n , k , currentIndex , adjacentSetBits , lastBit ) : NEW_LINE INDENT if ( currentIndex == n ) : NEW_LINE INDENT if ( adjacentSetBits == k ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT return 0 NEW_LINE DEDENT noOfWays = 0 NEW_LINE if ( lastBit == 1 ) : NEW_LINE INDENT noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits + 1 , 1 ) ; NEW_LINE noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits , 0 ) ; NEW_LINE DEDENT elif ( lastBit != 1 ) : NEW_LINE INDENT noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits , 1 ) ; NEW_LINE noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits , 0 ) ; NEW_LINE DEDENT return noOfWays ; NEW_LINE DEDENT n = 5 ; k = 2 ; NEW_LINE totalWays = ( waysToKAdjacentSetBits ( n , k , 1 , 0 , 1 ) + waysToKAdjacentSetBits ( n , k , 1 , 0 , 0 ) ) ; NEW_LINE print ( \" Number ▁ of ▁ ways ▁ = \" , totalWays ) ; NEW_LINE"],"bleu":0.3332038716357236,"rouge_l":0.5615650172612199}
{"id":1540,"predictions":["def canPlace ( z , p , pass ) : NEW_LINE INDENT rider = 1 NEW_LINE current_Fail = 1 NEW_LINE last_ threaded = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT current_Glass = a [ i ] NEW_LINE if current_Glass >= segment : NEW_LINE INDENT rider += 1 NEW_LINE DEDENT else : NEW_LINE INDENT rider += 1 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT def maxDistance ( rider , n , p ) : NEW_LINE INDENT arr = [ 0 ] * ( n - 1 ) NEW_LINE start = 0 NEW_LINE end = 0 NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = int ( ( current - start ) \/ 2 ) NEW_LINE if ( canPlace ( cycle , n , p , mid ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( canPlace ( cycle , n , p , mid ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT end = mid + 1 NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT mapping = [ [ 1 , 2 , 8 , 4 , 9 ] ] NEW_LINE n = len ( mapping ) NEW_LINE p = 3 NEW_LINE print ( maxDistance ( mapping , n , p ) ) NEW_LINE DEDENT"],"references":["def canPlace ( a , n , p , sep ) : NEW_LINE INDENT prisoners_placed = 1 NEW_LINE last_prisoner_placed = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT current_cell = a [ i ] NEW_LINE if ( current_cell - last_prisoner_placed >= sep ) : NEW_LINE INDENT prisoners_placed += 1 NEW_LINE last_prisoner_placed = current_cell NEW_LINE if ( prisoners_placed == p ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT def maxDistance ( cell , n , p ) : NEW_LINE INDENT cell = sorted ( cell ) NEW_LINE start = 0 NEW_LINE end = cell [ n - 1 ] - cell [ 0 ] NEW_LINE ans = 0 NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = start + ( ( end - start ) \/\/ 2 ) NEW_LINE if ( canPlace ( cell , n , p , mid ) ) : NEW_LINE INDENT ans = mid NEW_LINE start = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT cell = [ 1 , 2 , 8 , 4 , 9 ] NEW_LINE n = len ( cell ) NEW_LINE p = 3 NEW_LINE print ( maxDistance ( cell , n , p ) ) NEW_LINE"],"bleu":0.5823677303598344,"rouge_l":0.7083927044742091}
{"id":1541,"predictions":["def hasElement ( arr , n ) : NEW_LINE INDENT xorArr = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT xorArr ^= arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT xorArr ^= arr [ i ] NEW_LINE if ( arr [ i ] == xorArr ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 8 , 2 , 4 , 15 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE if ( hasElement ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def containsElement ( arr , n ) : NEW_LINE INDENT xorArr = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT xorArr ^= arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT x = xorArr ^ arr [ i ] NEW_LINE if ( arr [ i ] == x ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT arr = [ 8 , 2 , 4 , 15 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE if ( containsElement ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.8119178413216783,"rouge_l":0.9159621451104102}
{"id":1542,"predictions":["def solve ( s ) : NEW_LINE INDENT m = dict ( ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT m [ s [ i ] ] = m . get ( s [ i ] , 0 ) + 1 NEW_LINE DEDENT new_string = \" \" NEW_LINE for i in m : NEW_LINE INDENT if m [ i ] % 2 == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT new_string += s [ i ] NEW_LINE DEDENT new_string = \" \" NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] % 2 == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT new_string += str [ i ] NEW_LINE DEDENT print ( new_string ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" aabbbddddeeccdd \" NEW_LINE solve ( s ) NEW_LINE DEDENT"],"references":["def solve ( s ) : NEW_LINE INDENT m = dict ( ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] in m : NEW_LINE INDENT m [ s [ i ] ] = m [ s [ i ] ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ s [ i ] ] = 1 NEW_LINE DEDENT DEDENT new_string = \" \" NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if m [ s [ i ] ] % 2 == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT new_string = new_string + s [ i ] NEW_LINE DEDENT print ( new_string ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" aabbbddeeecc \" NEW_LINE solve ( s ) NEW_LINE DEDENT"],"bleu":0.7151373206235804,"rouge_l":0.7990122396392528}
{"id":1543,"predictions":["def getTotalXorSubarrayXors ( arr , N ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT freq = ( i + 1 ) * ( N - i ) NEW_LINE if ( freq % 2 == 1 ) : NEW_LINE INDENT res = res ^ arr [ N - i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT arr = [ 3 , 5 , 4 , 6 ] NEW_LINE N = len ( arr ) NEW_LINE print ( getTotalXorSubarrayXors ( arr , N ) ) NEW_LINE"],"references":["def getTotalXorOfSubarrayXors ( arr , N ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT freq = ( i + 1 ) * ( N - i ) NEW_LINE if ( freq % 2 == 1 ) : NEW_LINE INDENT res = res ^ arr [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT arr = [ 3 , 5 , 2 , 4 , 6 ] NEW_LINE N = len ( arr ) NEW_LINE print ( getTotalXorOfSubarrayXors ( arr , N ) ) NEW_LINE"],"bleu":0.8736922080999784,"rouge_l":0.9461394238963696}
{"id":1544,"predictions":["def sum ( N , S1 , S2 ) : NEW_LINE INDENT S1 = ( ( N \/\/ 3 ) * ( 2 * 3 + ( N \/\/ 4 ) * 3 ) + ( N \/\/ 4 - 1 ) * 3 ) \/\/ 2 NEW_LINE S2 = ( ( N \/\/ 4 ) * ( 2 * 12 + ( N \/\/ 12 - 1 ) ) * 12 NEW_LINE S3 = ( ( N \/\/ 12 ) * 12 + ( N \/\/ 12 ) * 12 + ( N \/\/ 12 - 1 ) * 12 ) \/\/ 2 * 12 NEW_LINE return S1 + S2 - S3 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 20 NEW_LINE S1 = 20 NEW_LINE print ( sum ( 12 , S1 , S2 ) ) NEW_LINE DEDENT"],"references":["def sum ( N ) : NEW_LINE INDENT global S1 , S2 , S3 NEW_LINE S1 = ( ( ( N \/\/ 3 ) ) * ( 2 * 3 + ( N \/\/ 3 - 1 ) * 3 ) \/\/ 2 ) NEW_LINE S2 = ( ( ( N \/\/ 4 ) ) * ( 2 * 4 + ( N \/\/ 4 - 1 ) * 4 ) \/\/ 2 ) NEW_LINE S3 = ( ( ( N \/\/ 12 ) ) * ( 2 * 12 + ( N \/\/ 12 - 1 ) * 12 ) \/\/ 2 ) NEW_LINE return int ( S1 + S2 - S3 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 12 NEW_LINE print ( sum ( N ) ) NEW_LINE DEDENT"],"bleu":0.6500590452868085,"rouge_l":0.7869186375466788}
{"id":1545,"predictions":["def count ( S , m , n ) : NEW_LINE INDENT table = [ [ 0 ] * ( n + 1 ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT table [ 0 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT table [ i ] [ j ] = table [ i - S [ j ] ] + table [ i ] [ j - S [ i ] ] NEW_LINE DEDENT DEDENT return table [ n ] NEW_LINE DEDENT def count ( S , m , n ) : NEW_LINE INDENT table = [ [ 0 ] * m for _ in range ( n + 1 ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if table [ i ] [ j ] == 1 : NEW_LINE INDENT table [ i ] [ j ] = table [ i ] [ j ] + table [ i ] [ j ] NEW_LINE DEDENT table [ i ] [ j ] = 1 NEW_LINE DEDENT DEDENT return table [ n ] NEW_LINE DEDENT S = [ 0 ] * m NEW_LINE n = len ( S ) NEW_LINE print ( count ( S , m , n ) ) NEW_LINE"],"references":["def count ( S , m , n ) : NEW_LINE INDENT table = [ 0 for k in range ( n + 1 ) ] NEW_LINE table [ 0 ] = 1 NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT for j in range ( S [ i ] , n + 1 ) : NEW_LINE INDENT table [ j ] += table [ j - S [ i ] ] NEW_LINE DEDENT DEDENT return table [ n ] NEW_LINE DEDENT arr = [ 1 , 2 , 3 ] NEW_LINE m = len ( arr ) NEW_LINE n = 4 NEW_LINE x = count ( arr , m , n ) NEW_LINE print ( x ) NEW_LINE"],"bleu":0.3245277418907187,"rouge_l":0.5465745753220087}
{"id":1546,"predictions":["def binSolutions ( a ) : NEW_LINE INDENT count = bin ( a ) . count ( '1' ) ; NEW_LINE count = pow ( 2 , count ) ; NEW_LINE return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 3 ; NEW_LINE print ( binSolutions ( a ) ) ; NEW_LINE DEDENT"],"references":["def countSolutions ( a ) : NEW_LINE INDENT count = bin ( a ) . count ( '1' ) NEW_LINE return 2 ** count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 3 NEW_LINE print ( countSolutions ( a ) ) NEW_LINE DEDENT"],"bleu":0.6082603498707162,"rouge_l":0.8433179723502303}
{"id":1547,"predictions":["def countNumbers ( n ) : NEW_LINE INDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return 9 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 2 NEW_LINE print ( countNumbers ( n ) ) NEW_LINE DEDENT"],"references":["def countNumbers ( n ) : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( 9 * pow ( 10 , n \/\/ 2 - 1 ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 2 NEW_LINE print ( countNumbers ( n ) ) NEW_LINE DEDENT"],"bleu":0.7068782793906959,"rouge_l":0.8572609534306971}
{"id":1548,"predictions":["def getMinDiff ( arr , n , k ) : NEW_LINE INDENT if ( n == 1 ) : return 0 NEW_LINE arr . sort ( reverse = False ) NEW_LINE return arr [ n - 1 ] NEW_LINE DEDENT def getMinDiff ( arr , n , k ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE return 0 NEW_LINE arr . sort ( ) NEW_LINE small = arr [ 0 ] NEW_LINE small = arr [ n - 1 ] NEW_LINE small = 0 NEW_LINE small = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT small = arr [ i ] - k NEW_LINE if ( small < small ) : NEW_LINE INDENT small = small + k NEW_LINE DEDENT if ( small < small ) : NEW_LINE INDENT small = small NEW_LINE break NEW_LINE DEDENT if ( small - small > small ) : NEW_LINE INDENT small = small NEW_LINE DEDENT small = small NEW_LINE DEDENT else : NEW_LINE INDENT small = small NEW_LINE DEDENT DEDENT arr = [ 4 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE k = 10 NEW_LINE print ( \" Maximum ▁ difference ▁ is \" , getMinDiff ( arr , n , k ) ) NEW_LINE"],"references":["def getMinDiff ( arr , n , k ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT arr . sort ( ) NEW_LINE ans = arr [ n - 1 ] - arr [ 0 ] NEW_LINE small = arr [ 0 ] + k NEW_LINE big = arr [ n - 1 ] - k NEW_LINE if ( small > big ) : NEW_LINE INDENT small , big = big , small NEW_LINE DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT subtract = arr [ i ] - k NEW_LINE add = arr [ i ] + k NEW_LINE if ( subtract >= small or add <= big ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( big - subtract <= add - small ) : NEW_LINE INDENT small = subtract NEW_LINE DEDENT else : NEW_LINE INDENT big = add NEW_LINE DEDENT DEDENT return min ( ans , big - small ) NEW_LINE DEDENT arr = [ 4 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE k = 10 NEW_LINE print ( \" Maximum ▁ difference ▁ is \" , getMinDiff ( arr , n , k ) ) NEW_LINE"],"bleu":0.6065294897656638,"rouge_l":0.7099583782950515}
{"id":1549,"predictions":["def minimumChanges ( n , a ) : NEW_LINE INDENT sf = [ 0 for i in range ( n + 1 ) ] NEW_LINE sf [ n ] = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT sf [ i ] = sf [ i + 1 ] NEW_LINE if ( a [ i ] <= 0 ) : NEW_LINE INDENT sf [ i ] += 1 NEW_LINE DEDENT DEDENT posn = 0 NEW_LINE mn = n NEW_LINE for i in range ( 0 , n - 1 , - 1 ) : NEW_LINE INDENT if ( a [ i ] >= 0 ) : NEW_LINE INDENT posn += 1 NEW_LINE DEDENT mn = min ( mn , posn ) NEW_LINE DEDENT return mn NEW_LINE DEDENT a = [ - 1 , - 2 , - 3 , - 5 , - 3 ] NEW_LINE n = len ( a ) NEW_LINE print ( minimumChanges ( n , a ) ) NEW_LINE"],"references":["def minimumChanges ( n , a ) : NEW_LINE INDENT sf = [ 0 ] * ( n + 1 ) NEW_LINE sf [ n ] = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT sf [ i ] = sf [ i + 1 ] NEW_LINE if ( a [ i ] <= 0 ) : NEW_LINE INDENT sf [ i ] += 1 NEW_LINE DEDENT DEDENT pos = 0 NEW_LINE mn = n NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( a [ i ] >= 0 ) : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT mn = min ( mn , pos + sf [ i + 1 ] ) NEW_LINE DEDENT return mn NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ - 1 , - 2 , - 3 , 3 , - 5 , 3 , 4 ] NEW_LINE n = len ( a ) NEW_LINE print ( minimumChanges ( n , a ) ) NEW_LINE DEDENT"],"bleu":0.7766048652998483,"rouge_l":0.8729001866500755}
{"id":1550,"predictions":["def printFirstRepeating ( arr , n ) : NEW_LINE INDENT min = - 1 NEW_LINE set = [ ] NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] not in set ) : NEW_LINE INDENT min = i NEW_LINE DEDENT else : NEW_LINE INDENT set . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT if ( min != - 1 ) : NEW_LINE INDENT print ( \" The ▁ possible \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" The ▁ repeated ▁ elements ▁ is ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 10 , 5 , 3 , 4 , 3 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE printFirstRepeating ( arr , n ) NEW_LINE"],"references":["def printFirstRepeating ( arr , n ) : NEW_LINE INDENT Min = - 1 NEW_LINE myset = dict ( ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if arr [ i ] in myset . keys ( ) : NEW_LINE INDENT Min = i NEW_LINE DEDENT else : NEW_LINE INDENT myset [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT if ( Min != - 1 ) : NEW_LINE INDENT print ( \" The ▁ first ▁ repeating ▁ element ▁ is \" , arr [ Min ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" There ▁ are ▁ no ▁ repeating ▁ elements \" ) NEW_LINE DEDENT DEDENT arr = [ 10 , 5 , 3 , 4 , 3 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE printFirstRepeating ( arr , n ) NEW_LINE"],"bleu":0.6725200609488372,"rouge_l":0.8209517657192076}
{"id":1551,"predictions":["def solveOdd ( n , arr , b , n ) : NEW_LINE INDENT left = n - 1 NEW_LINE right = n \/\/ 2 NEW_LINE for i in range ( 0 , ( n \/\/ 2 ) ) : NEW_LINE INDENT b = arr [ left ] NEW_LINE left = left + 2 NEW_LINE right = left - 2 NEW_LINE while ( left < right ) : NEW_LINE INDENT b = arr [ right ] NEW_LINE left = right - 2 NEW_LINE right = right + 2 NEW_LINE DEDENT if ( left > 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT right = left + 2 NEW_LINE DEDENT if ( right > n - 2 ) : NEW_LINE INDENT break NEW_LINE DEDENT for i in range ( 0 , ( ( n \/\/ 2 ) + 1 ) : NEW_LINE INDENT b = arr [ right ] NEW_LINE left = right + 2 NEW_LINE right = left + 2 NEW_LINE while ( right < n - 2 ) : NEW_LINE INDENT b = arr [ right ] NEW_LINE left = right + 2 NEW_LINE DEDENT right = right + 2 NEW_LINE DEDENT if ( right > n - 2 ) : NEW_LINE INDENT break NEW_LINE DEDENT for i in range ( 0 , n - 2 ) : NEW_LINE INDENT b = arr [ right ] NEW_LINE right = right + 2 NEW_LINE DEDENT if ( right > n - 2 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return arr NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE arr = [ 1 , 2 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( solveOdd ( n , arr , arr , n ) ) NEW_LINE DEDENT"],"references":["def solveEven ( n , arr , b ) : NEW_LINE INDENT left = n - 1 NEW_LINE for i in range ( ( n \/\/ 2 ) ) : NEW_LINE INDENT b [ i ] = arr [ left ] NEW_LINE left = left - 2 NEW_LINE if ( left < 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT right = 0 NEW_LINE for i in range ( n \/\/ 2 , n , 1 ) : NEW_LINE INDENT b [ i ] = arr [ right ] NEW_LINE right = right + 2 NEW_LINE if ( right > n - 2 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT def solveOdd ( n , arr , b ) : NEW_LINE INDENT left = n - 1 NEW_LINE for i in range ( n \/\/ 2 + 1 ) : NEW_LINE INDENT b [ i ] = arr [ left ] NEW_LINE left = left - 2 NEW_LINE if ( left < 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT right = 1 NEW_LINE for i in range ( n \/\/ 2 + 1 , n , 1 ) : NEW_LINE INDENT b [ i ] = arr [ right ] NEW_LINE right = right + 2 NEW_LINE if ( right > n - 2 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT def solve ( n , arr ) : NEW_LINE INDENT b = [ 0 for i in range ( n ) ] NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT solveEven ( n , arr , b ) NEW_LINE DEDENT else : NEW_LINE INDENT solveOdd ( n , arr , b ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( b [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE solve ( n , arr ) NEW_LINE DEDENT"],"bleu":0.5322701683380684,"rouge_l":0.6175478065241844}
{"id":1552,"predictions":["def findpair ( l , r ) : NEW_LINE INDENT c = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , r + 1 ) : NEW_LINE INDENT if ( j % i == 0 and j != i ) : NEW_LINE INDENT print ( i , \" , \" , j , \" , \" , \" , j , \" } \" ) NEW_LINE c = 1 NEW_LINE break NEW_LINE DEDENT if ( c == 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( c == 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT l = 1 NEW_LINE r = 10 NEW_LINE findpair ( l , r ) NEW_LINE"],"references":["def findpair ( l , r ) : NEW_LINE INDENT c = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , r + 1 ) : NEW_LINE INDENT if ( j % i == 0 and j != i ) : NEW_LINE INDENT print ( i , \" , ▁ \" , j ) NEW_LINE c = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( c == 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT l = 1 NEW_LINE r = 10 NEW_LINE findpair ( l , r ) NEW_LINE DEDENT"],"bleu":0.8044962341712042,"rouge_l":0.8751793400286944}
{"id":1553,"predictions":["def nthEven ( n ) : NEW_LINE INDENT return ( 2 * n ) ; NEW_LINE DEDENT n = 10 ; NEW_LINE print ( nthEven ( n ) ) ; NEW_LINE"],"references":["def nthEven ( n ) : NEW_LINE INDENT return ( 2 * n ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE print ( nthEven ( n ) ) NEW_LINE DEDENT"],"bleu":0.5074693469825988,"rouge_l":0.7468299081766505}
{"id":1554,"predictions":["def checkUtil ( num , dig , base ) : NEW_LINE INDENT if ( dig == 1 and num < base < base ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( dig == 1 and num >= base >= base ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( dig > 1 and num >= base ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def check ( num , dig , base ) : NEW_LINE INDENT if ( checkUtil ( num , dig , base , base ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT num = 8 NEW_LINE if ( check ( num , dig , base ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def checkUtil ( num , dig , base ) : NEW_LINE INDENT if ( dig == 1 and num < base ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( dig > 1 and num >= base ) : NEW_LINE INDENT return checkUtil ( num \/ base , - - dig , base ) NEW_LINE DEDENT return False NEW_LINE DEDENT def check ( num , dig ) : NEW_LINE INDENT for base in range ( 2 , 33 ) : NEW_LINE INDENT if ( checkUtil ( num , dig , base ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT num = 8 NEW_LINE dig = 3 NEW_LINE if ( check ( num , dig ) == True ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.7888951594599398,"rouge_l":0.8244163967385234}
{"id":1555,"predictions":["def smallestSubArraySum ( arr , n , x ) : NEW_LINE INDENT min_len = n + 1 NEW_LINE for start in range ( 0 , n ) : NEW_LINE INDENT curr_sum = arr [ start ] NEW_LINE if ( curr_sum > x ) : NEW_LINE INDENT if ( curr_sum > x ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( curr_sum > x and ( end - start + 1 ) < min_len ) : NEW_LINE INDENT min_len = int ( ( end - start ) \/ x ) NEW_LINE DEDENT DEDENT DEDENT return min_len NEW_LINE DEDENT def smallest ( arr1 , n1 , x ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT print ( \" Not ▁ possible \" ) NEW_LINE return NEW_LINE DEDENT if ( res == n1 + 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT res1 = smallestSubArraySum ( arr1 , n1 , x ) NEW_LINE res2 = smallestSubArraySum ( arr2 , n1 , x ) NEW_LINE res2 = smallestSubArraySum ( arr3 , n2 , x ) NEW_LINE res3 = smallestSubArraySum ( arr3 , n3 , x ) NEW_LINE print ( \" Not ▁ possible \" ) if ( res3 == n2 + 1 ) else res3 NEW_LINE arr3 = smallestSubArraySum ( arr3 , n3 , x ) NEW_LINE if ( res3 == n ) : NEW_LINE INDENT print ( \" Possible \" ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ possible \" ) NEW_LINE DEDENT arr3 = [ 1 , 10 , 45 , 1 , 2 , 1 , 0 , 0 , 1 , 2 , 0 , 100 ] NEW_LINE n3 = len ( arr3 ) NEW_LINE res3 = smallestSubArraySum ( arr3 , n3 , x ) NEW_LINE if ( res3 == n3 + 1 ) : NEW_LINE INDENT print ( \" Not ▁ possible \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res3"],"references":["def smallestSubWithSum ( arr , n , x ) : NEW_LINE INDENT min_len = n + 1 NEW_LINE for start in range ( 0 , n ) : NEW_LINE INDENT curr_sum = arr [ start ] NEW_LINE if ( curr_sum > x ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT for end in range ( start + 1 , n ) : NEW_LINE INDENT curr_sum += arr [ end ] NEW_LINE if curr_sum > x and ( end - start + 1 ) < min_len : NEW_LINE INDENT min_len = ( end - start + 1 ) NEW_LINE DEDENT DEDENT DEDENT return min_len ; NEW_LINE DEDENT arr1 = [ 1 , 4 , 45 , 6 , 10 , 19 ] NEW_LINE x = 51 NEW_LINE n1 = len ( arr1 ) NEW_LINE res1 = smallestSubWithSum ( arr1 , n1 , x ) ; NEW_LINE if res1 == n1 + 1 : NEW_LINE INDENT print ( \" Not ▁ possible \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res1 ) NEW_LINE DEDENT arr2 = [ 1 , 10 , 5 , 2 , 7 ] NEW_LINE n2 = len ( arr2 ) NEW_LINE x = 9 NEW_LINE res2 = smallestSubWithSum ( arr2 , n2 , x ) ; NEW_LINE if res2 == n2 + 1 : NEW_LINE INDENT print ( \" Not ▁ possible \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res2 ) NEW_LINE DEDENT arr3 = [ 1 , 11 , 100 , 1 , 0 , 200 , 3 , 2 , 1 , 250 ] NEW_LINE n3 = len ( arr3 ) NEW_LINE x = 280 NEW_LINE res3 = smallestSubWithSum ( arr3 , n3 , x ) NEW_LINE if res3 == n3 + 1 : NEW_LINE INDENT print ( \" Not ▁ possible \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res3 ) NEW_LINE DEDENT"],"bleu":0.5743067541321525,"rouge_l":0.6697793740379683}
{"id":1556,"predictions":["import math NEW_LINE def getSum ( arr , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sq = math . sqrt ( arr [ i ] ) ; NEW_LINE for j in range ( n ) : NEW_LINE INDENT x = arr [ i ] ; NEW_LINE if ( x == sq ) : NEW_LINE INDENT sum += ( sqrt ( arr [ i ] ) ) ; NEW_LINE DEDENT DEDENT DEDENT return sum ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 4 , 5 , 6 , 7 , 8 , 9 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( getSum ( arr , n ) ) ; NEW_LINE DEDENT"],"references":["import math NEW_LINE def getSum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sqrtCurrent = math . sqrt ( arr [ i ] ) NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT x = arr [ j ] NEW_LINE if ( x == sqrtCurrent ) : NEW_LINE INDENT sum += ( sqrtCurrent * sqrtCurrent ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT return int ( sum ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( getSum ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.6797211009879913,"rouge_l":0.8617629889083481}
{"id":1557,"predictions":["def findCountofPairs ( a , b , n ) : NEW_LINE INDENT ans = 0 NEW_LINE ans += n * ( a \/\/ n ) * ( b \/\/ n ) NEW_LINE ans += ( a \/\/ n ) * ( b \/\/ n ) + ( a % n ) * ( b \/\/ n ) NEW_LINE ans += ( ( a % n ) * ( b % n ) ) NEW_LINE return ans NEW_LINE DEDENT a = 5 NEW_LINE b = 13 NEW_LINE n = 3 NEW_LINE print ( findCountofPairs ( a , b , n ) ) NEW_LINE"],"references":["def findCountOfPairs ( a , b , n ) : NEW_LINE INDENT ans = 0 NEW_LINE ans += n * int ( a \/ n ) * int ( b \/ n ) NEW_LINE ans += int ( a \/ n ) * ( b % n ) NEW_LINE ans += ( a % n ) * int ( b \/ n ) NEW_LINE ans += int ( ( ( a % n ) + ( b % n ) ) \/ n ) ; NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 5 NEW_LINE b = 13 NEW_LINE n = 3 NEW_LINE print ( findCountOfPairs ( a , b , n ) ) NEW_LINE DEDENT"],"bleu":0.5504738940552104,"rouge_l":0.7925398155909472}
{"id":1558,"predictions":["def bsearch ( prefix , n , k ) : NEW_LINE INDENT ans = - 1 NEW_LINE left = 1 NEW_LINE right = n NEW_LINE while ( left <= right ) : NEW_LINE INDENT mid = ( left + right ) \/\/ 2 NEW_LINE i = mid + 1 NEW_LINE while ( left <= right ) : NEW_LINE INDENT mid = ( left + right ) \/\/ 2 NEW_LINE if ( prefix [ mid ] - prefix [ mid ] > k ) : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT left = mid + 1 NEW_LINE DEDENT DEDENT if ( i == n + 1 ) : NEW_LINE INDENT left = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT right = mid - 1 NEW_LINE ans = mid + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def maxSize ( arr , n , k ) : NEW_LINE INDENT prefix = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT prefix [ i + 1 ] = prefix [ i ] + arr [ i ] NEW_LINE DEDENT return binarysearch ( prefix , n , k ) NEW_LINE DEDENT arr = [ 1 , 2 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE k = 14 NEW_LINE print ( maxSize ( arr , n , k ) ) NEW_LINE"],"references":["def bsearch ( prefixsum , n , k ) : NEW_LINE INDENT ans , left , right = - 1 , 1 , n NEW_LINE while ( left <= right ) : NEW_LINE INDENT mid = ( left + right ) \/\/ 2 NEW_LINE for i in range ( mid , n + 1 ) : NEW_LINE INDENT if ( prefixsum [ i ] - prefixsum [ i - mid ] > k ) : NEW_LINE INDENT i = i - 1 NEW_LINE break NEW_LINE DEDENT DEDENT i = i + 1 NEW_LINE if ( i == n + 1 ) : NEW_LINE INDENT left = mid + 1 NEW_LINE ans = mid NEW_LINE DEDENT else : NEW_LINE INDENT right = mid - 1 NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT def maxSize ( arr , n , k ) : NEW_LINE INDENT prefixsum = [ 0 for x in range ( n + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT prefixsum [ i + 1 ] = prefixsum [ i ] + arr [ i ] NEW_LINE DEDENT return bsearch ( prefixsum , n , k ) ; NEW_LINE DEDENT arr = [ 1 , 2 , 10 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE k = 14 NEW_LINE print ( maxSize ( arr , n , k ) ) NEW_LINE"],"bleu":0.6728059695652049,"rouge_l":0.8105893693197466}
{"id":1559,"predictions":["def isprime ( x ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , x + 1 ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def isprime ( N , K ) : NEW_LINE INDENT if ( N < 2 * K ) : NEW_LINE INDENT return isprime ( N - 2 ) NEW_LINE DEDENT if ( K % 2 == 0 ) : NEW_LINE INDENT return isprime ( N - 2 ) NEW_LINE DEDENT if ( K % 2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( K % 2 == 0 ) : NEW_LINE INDENT return isprime ( N - 2 ) NEW_LINE DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 10 NEW_LINE k = 2 NEW_LINE if ( isSumPrime ( n , k ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def isprime ( x ) : NEW_LINE INDENT i = 2 NEW_LINE while ( i * i <= x ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT def isSumOfKprimes ( N , K ) : NEW_LINE INDENT if ( N < 2 * K ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( K == 1 ) : NEW_LINE INDENT return isprime ( N ) NEW_LINE DEDENT if ( K == 2 ) : NEW_LINE INDENT if ( N % 2 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return isprime ( N - 2 ) ; NEW_LINE DEDENT return 1 NEW_LINE DEDENT n = 10 NEW_LINE k = 2 NEW_LINE if ( isSumOfKprimes ( n , k ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"bleu":0.591909561675357,"rouge_l":0.7940361890694239}
{"id":1560,"predictions":["def CountWords ( str , k ) : NEW_LINE INDENT cnt = 0 NEW_LINE l = len ( str ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( str [ i ] < k ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" GeeksForGeeks \" NEW_LINE k = 90 NEW_LINE count = CountWords ( str , k ) NEW_LINE for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT print ( \" , ▁ \" , end = \" \" ) NEW_LINE DEDENT DEDENT"],"references":["def CountCharacters ( str , k ) : NEW_LINE INDENT cnt = 0 NEW_LINE l = len ( str ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( ord ( str [ i ] ) < k ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" GeeksForGeeks \" NEW_LINE k = 90 NEW_LINE count = CountCharacters ( str , k ) NEW_LINE print ( \" Characters ▁ with ▁ ASCII ▁ values \" , \" less ▁ than ▁ K ▁ are \" , count ) NEW_LINE print ( \" Characters ▁ with ▁ ASCII ▁ values \" , \" greater ▁ than ▁ or ▁ equal ▁ to ▁ K ▁ are \" , len ( str ) - count ) NEW_LINE DEDENT"],"bleu":0.557553805390288,"rouge_l":0.7224169184290029}
{"id":1561,"predictions":["def printWB ( arr1 , arr2 , n1 , n2 ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE k = 0 NEW_LINE while ( i < n1 and j < n2 ) : NEW_LINE INDENT if ( arr1 [ i ] < arr2 [ j ] ) : NEW_LINE INDENT arr1 [ i ] , arr2 [ j ] = arr1 [ i ] , arr2 [ k ] NEW_LINE i += 1 NEW_LINE k += 1 NEW_LINE DEDENT elif ( arr2 [ j ] < arr1 [ i ] ) : NEW_LINE INDENT arr2 [ j ] = arr2 [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT while ( i < n1 ) : NEW_LINE INDENT if ( arr2 [ j ] < arr1 [ i ] ) : NEW_LINE INDENT print ( arr2 [ i ] , end = \" ▁ \" ) NEW_LINE k += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr1 = [ 10 , 20 , 30 , 30 , 50 ] NEW_LINE n1 = len ( arr1 ) NEW_LINE n2 = len ( arr2 ) NEW_LINE printWB ( arr1 , arr2 , n1 , n2 ) NEW_LINE DEDENT"],"references":["def printUncommon ( arr1 , arr2 , n1 , n2 ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE k = 0 NEW_LINE while ( i < n1 and j < n2 ) : NEW_LINE INDENT if ( arr1 [ i ] < arr2 [ j ] ) : NEW_LINE INDENT print ( arr1 [ i ] , end = \" ▁ \" ) NEW_LINE i = i + 1 NEW_LINE k = k + 1 NEW_LINE DEDENT elif ( arr2 [ j ] < arr1 [ i ] ) : NEW_LINE INDENT print ( arr2 [ j ] , end = \" ▁ \" ) NEW_LINE k = k + 1 NEW_LINE j = j + 1 NEW_LINE DEDENT else : NEW_LINE INDENT i = i + 1 NEW_LINE j = j + 1 NEW_LINE DEDENT DEDENT while ( i < n1 ) : NEW_LINE INDENT print ( arr1 [ i ] , end = \" ▁ \" ) NEW_LINE i = i + 1 NEW_LINE k = k + 1 NEW_LINE DEDENT while ( j < n2 ) : NEW_LINE INDENT print ( arr2 [ j ] , end = \" ▁ \" ) NEW_LINE j = j + 1 NEW_LINE k = k + 1 NEW_LINE DEDENT DEDENT arr1 = [ 10 , 20 , 30 ] NEW_LINE arr2 = [ 20 , 25 , 30 , 40 , 50 ] NEW_LINE n1 = len ( arr1 ) NEW_LINE n2 = len ( arr2 ) NEW_LINE printUncommon ( arr1 , arr2 , n1 , n2 ) NEW_LINE"],"bleu":0.5922086820516423,"rouge_l":0.7008747878313096}
{"id":1562,"predictions":["def findExtraCharCharacter ( s1 , s2 ) : NEW_LINE INDENT size1 = len ( s1 ) NEW_LINE size2 = s1 [ size1 ] NEW_LINE sizeStr = s1 [ size2 ] NEW_LINE small = s1 [ size2 ] NEW_LINE smallStr = s1 [ size2 ] NEW_LINE small = 0 NEW_LINE for i in range ( size1 ) : NEW_LINE INDENT small = s1 [ i ] NEW_LINE small = s2 [ i ] NEW_LINE DEDENT smallStr = 0 NEW_LINE for i in range ( size1 ) : NEW_LINE INDENT smallStr += ( smallStr * small ) NEW_LINE smallStr += smallStr NEW_LINE DEDENT smallStr = 0 NEW_LINE for i in range ( size2 ) : NEW_LINE INDENT smallStr += smallNum NEW_LINE if ( smallStr ) : NEW_LINE INDENT smallNum += smallNum NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT smallStr += smallNum NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s1 = \" abcd \" NEW_LINE s2 = findExtraCharCharacter ( s1 , s2 ) NEW_LINE print ( \"copy ▁ Character : \" , finalStr ) NEW_LINE DEDENT"],"references":["def findExtraCharacter ( s1 , s2 ) : NEW_LINE INDENT smallStr = \" \" NEW_LINE largeStr = \" \" NEW_LINE if ( len ( s1 ) > len ( s2 ) ) : NEW_LINE INDENT smallStr = s2 NEW_LINE largeStr = s1 NEW_LINE DEDENT else : NEW_LINE INDENT smallStr = s1 NEW_LINE largeStr = s2 NEW_LINE DEDENT smallStrCodeTotal = 0 NEW_LINE largeStrCodeTotal = 0 NEW_LINE i = 0 NEW_LINE while ( i < len ( smallStr ) ) : NEW_LINE INDENT smallStrCodeTotal += ord ( smallStr [ i ] ) NEW_LINE largeStrCodeTotal += ord ( largeStr [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT largeStrCodeTotal += ord ( largeStr [ i ] ) NEW_LINE intChar = largeStrCodeTotal - smallStrCodeTotal NEW_LINE return chr ( intChar ) NEW_LINE DEDENT s1 = \" abcd \" NEW_LINE s2 = \" cbdae \" NEW_LINE extraChar = findExtraCharacter ( s1 , s2 ) NEW_LINE print ( \" Extra ▁ Character : \" , extraChar ) NEW_LINE"],"bleu":0.3024343170519105,"rouge_l":0.4700443074552109}
{"id":1563,"predictions":["def sortMat ( mat , row , col ) : NEW_LINE INDENT size = row * col NEW_LINE for i in range ( size - 1 ) : NEW_LINE INDENT for j in range ( size - 1 ) : NEW_LINE INDENT if mat [ i ] [ j ] > row [ size - 1 ] [ j ] : NEW_LINE INDENT mat [ i ] [ j ] = ( mat [ i ] [ j ] \/\/ mat [ i ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def printMat ( mat , row , col ) : NEW_LINE INDENT for i in range ( row ) : NEW_LINE INDENT for j in range ( col ) : NEW_LINE INDENT if mat [ i ] [ j ] > row [ j ] : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def printMat ( mat , row , col ) : NEW_LINE INDENT for i in range ( row , col ) : NEW_LINE INDENT for j in range ( col ) : NEW_LINE INDENT print ( mat [ i ] [ j ] [ col ] , mat [ i + 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT mat = [ [ [ 5 , 4 , 7 ] , [ 1 , 9 , 6 ] , [ 2 , 9 , 6 , 8 ] ] NEW_LINE row = [ ] NEW_LINE col = len ( mat ) NEW_LINE sortMat ( mat , row , col ) NEW_LINE printMat ( mat , row , col ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT mat = [ [ 5 , 4 ] , [ 2 , 3 , 8 ] , [ 1 , 9 , 3 ] , [ 2 , 9 , 3 ] ] NEW_LINE row = [ [ 1 , 3 , 8 ] , [ 2 , 9 , 6 , 8 ] NEW_LINE col = [ 2 , 3 , 9 , 4 ] , [ 2 , 9 , 6 ] ] NEW_LINE mat = [ ["],"references":["def sortMat ( data , row , col ) : NEW_LINE INDENT size = row * col NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT for j in range ( 0 , size - 1 ) : NEW_LINE INDENT if ( data [ j \/\/ col ] [ j % col ] > \\ data [ ( j + 1 ) \/\/ col ] [ ( j + 1 ) % col ] ) : NEW_LINE INDENT temp = data [ j \/\/ col ] [ j % col ] NEW_LINE data [ j \/\/ col ] [ j % col ] = \\ NEW_LINE INDENT data [ ( j + 1 ) \/\/ col ] [ ( j + 1 ) % col ] NEW_LINE DEDENT data [ ( j + 1 ) \/\/ col ] [ ( j + 1 ) % col ] = \\ NEW_LINE INDENT temp NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def printMat ( mat , row , col ) : NEW_LINE INDENT for i in range ( row ) : NEW_LINE INDENT for j in range ( col ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT mat = [ [ 5 , 4 , 7 ] , [ 1 , 3 , 8 ] , [ 2 , 9 , 6 ] ] NEW_LINE row = len ( mat ) NEW_LINE col = len ( mat [ 0 ] ) NEW_LINE sortMat ( mat , row , col ) NEW_LINE printMat ( mat , row , col ) NEW_LINE DEDENT"],"bleu":0.4479793587282702,"rouge_l":0.5679922405431621}
{"id":1564,"predictions":["def distinctDigitSum ( n ) : NEW_LINE INDENT matched = False NEW_LINE sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT digit = n % 10 NEW_LINE if ( not ( digit * digit ) ) : NEW_LINE INDENT digit = True NEW_LINE sum += digit NEW_LINE DEDENT n = n \/\/ 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT def checkSum ( m , n ) : NEW_LINE INDENT sum = distinctDigitSum ( m ) NEW_LINE sum = distinctDigitSum ( m ) NEW_LINE if ( sum == sum ) : NEW_LINE INDENT return \" YES \" NEW_LINE DEDENT return \" NO \" NEW_LINE DEDENT m = 2452 NEW_LINE n = 92297 NEW_LINE printSum ( m , n ) NEW_LINE"],"references":["def distinctDigitSum ( n ) : NEW_LINE INDENT used = [ False ] * 10 NEW_LINE sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT digit = n % 10 NEW_LINE if ( not used [ digit ] ) : NEW_LINE INDENT used [ digit ] = True NEW_LINE sum += digit NEW_LINE DEDENT n = n \/\/ 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT def checkSum ( m , n ) : NEW_LINE INDENT sumM = distinctDigitSum ( m ) NEW_LINE sumN = distinctDigitSum ( n ) NEW_LINE if ( sumM == sumN ) : NEW_LINE INDENT return \" YES \" NEW_LINE DEDENT return \" NO \" NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT m = 2452 NEW_LINE n = 9222 NEW_LINE print ( checkSum ( m , n ) ) NEW_LINE DEDENT"],"bleu":0.6236340016050925,"rouge_l":0.8127475693194096}
{"id":1565,"predictions":["def initializeDiff ( A , D , X , m ) : NEW_LINE INDENT n = len ( A ) ; NEW_LINE D = 0 ; NEW_LINE d = 0 ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT DEDENT D = A [ i ] - A [ i ] ; NEW_LINE DEDENT def updateDiff ( A , l , r , x ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT A [ l ] = D ; NEW_LINE DEDENT else : NEW_LINE INDENT A [ r ] -= X ; NEW_LINE DEDENT DEDENT def updateDiff ( A , d , x ) : NEW_LINE INDENT for i in range ( 0 , len ( A ) ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT A [ i ] = d ; NEW_LINE DEDENT else : NEW_LINE INDENT A [ i ] = d ; NEW_LINE DEDENT DEDENT DEDENT A = [ 10 , 5 , 10 , 20 ] ; NEW_LINE updateDiff ( A , d , x ) ; NEW_LINE updateDiff ( A , D , 30 ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 10 , 5 , 20 ] ; NEW_LINE DEDENT"],"references":["def initializeDiffArray ( A ) : NEW_LINE INDENT n = len ( A ) NEW_LINE D = [ 0 for i in range ( 0 , n + 1 ) ] NEW_LINE D [ 0 ] = A [ 0 ] ; D [ n ] = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT D [ i ] = A [ i ] - A [ i - 1 ] NEW_LINE DEDENT return D NEW_LINE DEDENT def update ( D , l , r , x ) : NEW_LINE INDENT D [ l ] += x NEW_LINE D [ r + 1 ] -= x NEW_LINE DEDENT def printArray ( A , D ) : NEW_LINE INDENT for i in range ( 0 , len ( A ) ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT A [ i ] = D [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT A [ i ] = D [ i ] + A [ i - 1 ] NEW_LINE DEDENT print ( A [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( \" \" ) NEW_LINE DEDENT A = [ 10 , 5 , 20 , 40 ] NEW_LINE D = initializeDiffArray ( A ) NEW_LINE update ( D , 0 , 1 , 10 ) NEW_LINE printArray ( A , D ) NEW_LINE update ( D , 1 , 3 , 20 ) NEW_LINE update ( D , 2 , 2 , 30 ) NEW_LINE printArray ( A , D ) NEW_LINE"],"bleu":0.4149856965553135,"rouge_l":0.5906830672598795}
{"id":1566,"predictions":["MAX = 100 NEW_LINE def printPrincipalDiagonalDP ( mat , n ) : NEW_LINE INDENT print ( \" Principal ▁ Diagonal : ▁ \" , end = \" \" ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT print ( mat [ i ] , end = \" , ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( mat [ i ] , end = \" , ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT print ( ) NEW_LINE DEDENT def printSecondaryDiagonal ( mat , n ) : NEW_LINE INDENT print ( \" Principal ▁ Diagonal : ▁ \" , end = \" ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( i + j ) == ( n - 1 ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = \" , ▁ \" , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE a = [ [ 1 , 2 , 3 , 4 ] , [ 5 , 6 , 8 ] , [ 5 , 2 , 3 , 4 ] ] NEW_LINE printSecondipalDiagonalDPagonal ( a , n ) NEW_LINE DEDENT"],"references":["MAX = 100 NEW_LINE def printPrincipalDiagonal ( mat , n ) : NEW_LINE INDENT print ( \" Principal ▁ Diagonal : ▁ \" , end = \" \" ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = \" , ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT print ( ) NEW_LINE DEDENT def printSecondaryDiagonal ( mat , n ) : NEW_LINE INDENT print ( \" Secondary ▁ Diagonal : ▁ \" , end = \" \" ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( ( i + j ) == ( n - 1 ) ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = \" , ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT print ( ) NEW_LINE DEDENT n = 4 NEW_LINE a = [ [ 1 , 2 , 3 , 4 ] , [ 5 , 6 , 7 , 8 ] , [ 1 , 2 , 3 , 4 ] , [ 5 , 6 , 7 , 8 ] ] NEW_LINE printPrincipalDiagonal ( a , n ) NEW_LINE printSecondaryDiagonal ( a , n ) NEW_LINE"],"bleu":0.7847360997374148,"rouge_l":0.8573061663640643}
{"id":1567,"predictions":["def FindMinNumber ( arr , n , k ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE min_num = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT sm = sm + arr [ i ] NEW_LINE if ( sum == k ) : NEW_LINE INDENT min_num = min ( min_num , ( ( n - ( i + 1 ) ) \/\/ 2 ) ) NEW_LINE DEDENT if ( sum == k ) : NEW_LINE INDENT min_num = sm NEW_LINE DEDENT elif ( sum > k ) : NEW_LINE INDENT min_num = min ( min_num , ( n - ( i + 1 ) ) + j ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return min_num NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 3 , 2 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE k = 5 NEW_LINE print ( FindMinNumber ( arr , n , k ) ) NEW_LINE DEDENT"],"references":["def FindMinNumber ( arr , n , k ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE min_num = 10 ** 9 NEW_LINE found = False NEW_LINE Sum = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT Sum = Sum + arr [ i ] NEW_LINE if ( Sum == k ) : NEW_LINE INDENT min_num = min ( min_num , ( ( n - ( i + 1 ) ) + j ) ) NEW_LINE found = True NEW_LINE DEDENT elif ( Sum > k ) : NEW_LINE INDENT while ( Sum > k ) : NEW_LINE INDENT Sum = Sum - arr [ j ] NEW_LINE j += 1 NEW_LINE DEDENT if ( Sum == k ) : NEW_LINE INDENT min_num = min ( min_num , ( ( n - ( i + 1 ) ) + j ) ) NEW_LINE found = True NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT if ( found ) : NEW_LINE INDENT return min_num NEW_LINE DEDENT return - 1 NEW_LINE DEDENT arr = [ 1 , 3 , 2 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE k = 5 NEW_LINE print ( FindMinNumber ( arr , n , k ) ) NEW_LINE"],"bleu":0.6336335167135296,"rouge_l":0.758203513423931}
{"id":1568,"predictions":["def minProduct ( arr , n , k ) : NEW_LINE INDENT pq = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT pq . append ( arr [ i ] ) NEW_LINE DEDENT count = 0 NEW_LINE ans = 0 NEW_LINE while ( pq and count < k ) : NEW_LINE INDENT pq . append ( arr [ pq [ - 1 ] ] ) NEW_LINE count += 1 NEW_LINE DEDENT for i in range ( pq [ 0 ] ) : NEW_LINE INDENT if ( pq [ i ] == 0 and count < k ) : NEW_LINE INDENT ans = ans * pq [ i ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 43 , 65 , 123 , 123 , 6 ] NEW_LINE k = 2 NEW_LINE n = len ( arr ) NEW_LINE print ( \" Minimum ▁ product ▁ product ▁ product ▁ is \" , minProduct ( arr , n , k ) ) NEW_LINE DEDENT"],"references":["import math NEW_LINE import heapq NEW_LINE def minProduct ( arr , n , k ) : NEW_LINE INDENT heapq . heapify ( arr ) NEW_LINE count = 0 NEW_LINE ans = 1 NEW_LINE while ( arr ) and count < k : NEW_LINE INDENT x = heapq . heappop ( arr ) NEW_LINE ans = ans * x NEW_LINE count = count + 1 NEW_LINE DEDENT return ans ; NEW_LINE DEDENT arr = [ 198 , 76 , 544 , 123 , 154 , 675 ] NEW_LINE k = 2 NEW_LINE n = len ( arr ) NEW_LINE print ( \" Minimum ▁ product ▁ is \" , minProduct ( arr , n , k ) ) NEW_LINE"],"bleu":0.35422150566971045,"rouge_l":0.6289364563487615}
{"id":1569,"predictions":["BITSet = [ 0 ] * 256 NEW_LINE def initialize ( ) : NEW_LINE INDENT global BitSet NEW_LINE bitsetBitSet = bin ( 32 ) NEW_LINE for i in range ( 32 ) : NEW_LINE INDENT bitSet [ i ] = ( i & 1 << 32 ) NEW_LINE bitSetSet [ i ] = ( i & 32 ) + BitSet [ i \/\/ 2 ] NEW_LINE DEDENT def countSetBits ( n ) : NEW_LINE INDENT return ( bitsetSet [ n >> 16 ] + bitSetBitSet [ n >> 16 ] ) NEW_LINE DEDENT def countSetBits ( n ) : NEW_LINE INDENT return ( bitsSetBitSetBitSet [ n >> 16 ] + bitSet [ n >> 16 ] ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT initialize ( ) NEW_LINE n = 9 NEW_LINE print ( countSetBits ( n ) ) NEW_LINE DEDENT"],"references":["BitsSetTable256 = [ 0 ] * 256 NEW_LINE def initialize ( ) : NEW_LINE INDENT BitsSetTable256 [ 0 ] = 0 NEW_LINE for i in range ( 256 ) : NEW_LINE INDENT BitsSetTable256 [ i ] = ( i & 1 ) + BitsSetTable256 [ i \/\/ 2 ] NEW_LINE DEDENT DEDENT def countSetBits ( n ) : NEW_LINE INDENT return ( BitsSetTable256 [ n & 0xff ] + BitsSetTable256 [ ( n >> 8 ) & 0xff ] + BitsSetTable256 [ ( n >> 16 ) & 0xff ] + BitsSetTable256 [ n >> 24 ] ) NEW_LINE DEDENT initialize ( ) NEW_LINE n = 9 NEW_LINE print ( countSetBits ( n ) ) NEW_LINE"],"bleu":0.44708848327747713,"rouge_l":0.6871282116187825}
{"id":1570,"predictions":["def numberOfBST ( n ) : NEW_LINE INDENT dp = [ 0 for i in range ( n + 1 ) ] NEW_LINE dp [ 0 ] = 1 NEW_LINE dp [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT dp [ i ] = dp [ i - j ] + ( dp [ i - j ] * dp [ i ] ) NEW_LINE DEDENT DEDENT return dp NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE print ( \" Number ▁ of ▁ kb ▁ BST ▁ are ▁ : \" , numberOfBST ( n ) ) NEW_LINE DEDENT"],"references":["def numberOfBST ( n ) : NEW_LINE INDENT dp = [ 0 ] * ( n + 1 ) NEW_LINE dp [ 0 ] , dp [ 1 ] = 1 , 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT dp [ i ] = dp [ i ] + ( dp [ i - j ] * dp [ j - 1 ] ) NEW_LINE DEDENT DEDENT return dp [ n ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE print ( \" Number ▁ of ▁ structurally ▁ Unique ▁ BST ▁ with \" , n , \" keys ▁ are ▁ : \" , numberOfBST ( n ) ) NEW_LINE DEDENT"],"bleu":0.7397214873481393,"rouge_l":0.8607319031776987}
{"id":1571,"predictions":["def countdigits ( m ) : NEW_LINE INDENT if ( m == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 + countdigits ( m \/\/ 10 ) NEW_LINE DEDENT DEDENT def countSteps ( x ) : NEW_LINE INDENT c = 0 NEW_LINE last = x NEW_LINE while ( last > 0 ) : NEW_LINE INDENT digits = countdigits ( last ) NEW_LINE digit -= 1 NEW_LINE if ( digits > 0 ) : NEW_LINE INDENT digits = countDigits ( last , digits ) NEW_LINE first += 1 NEW_LINE DEDENT last = last - ( last * digit ) \/\/ first NEW_LINE prev += 1 NEW_LINE DEDENT return c NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 14 NEW_LINE print ( countSteps ( n ) ) NEW_LINE DEDENT"],"references":["def countdig ( m ) : NEW_LINE INDENT if ( m == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 + countdig ( m \/\/ 10 ) NEW_LINE DEDENT DEDENT def countSteps ( x ) : NEW_LINE INDENT c = 0 NEW_LINE last = x NEW_LINE while ( last ) : NEW_LINE INDENT digits = countdig ( last ) NEW_LINE digits -= 1 NEW_LINE divisor = pow ( 10 , digits ) NEW_LINE first = last \/\/ divisor NEW_LINE lastnumber = first * divisor NEW_LINE skipped = ( last - lastnumber ) \/\/ first NEW_LINE skipped += 1 NEW_LINE c += skipped NEW_LINE last = last - ( first * skipped ) NEW_LINE DEDENT return c NEW_LINE DEDENT n = 14 NEW_LINE print ( countSteps ( n ) ) NEW_LINE"],"bleu":0.6140520709793588,"rouge_l":0.7457388033384272}
{"id":1572,"predictions":["def Output ( x , y ) : NEW_LINE INDENT while ( y ) : NEW_LINE INDENT carry = x & y ; NEW_LINE x = x ^ y ; NEW_LINE DEDENT return x ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( Input ( 15 , 32 ) ) ; NEW_LINE DEDENT"],"references":["def Add ( x , y ) : NEW_LINE INDENT while ( y != 0 ) : NEW_LINE INDENT carry = x & y NEW_LINE x = x ^ y NEW_LINE y = carry << 1 NEW_LINE DEDENT return x NEW_LINE DEDENT print ( Add ( 15 , 32 ) ) NEW_LINE"],"bleu":0.4993167999759999,"rouge_l":0.7486849795441263}
{"id":1573,"predictions":["a , b = map ( int , input ( ) . split ( ) ) ; NEW_LINE if ( a == 0 or b == 0 ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT"],"references":["def isOverflow ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT result = a * b NEW_LINE if ( result >= 9223372036854775807 or result <= - 9223372036854775808 ) : NEW_LINE INDENT result = 0 NEW_LINE DEDENT if ( a == ( result \/\/ b ) ) : NEW_LINE INDENT print ( result \/\/ b ) NEW_LINE return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 10000000000 NEW_LINE b = - 10000000000 NEW_LINE if ( isOverflow ( a , b ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.12440260005141958,"rouge_l":0.364179104477612}
{"id":1574,"predictions":["def pairWithEqualSum ( A , n ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT mp [ A [ i ] , A [ j ] ] = mp . get ( A [ i ] , 0 ) + A [ j ] NEW_LINE DEDENT DEDENT for i in range ( 0 , n - 1 , 1 ) : NEW_LINE INDENT mp [ A [ i ] ] = mp . get ( A [ i ] , 0 ) + A [ A [ i ] ] NEW_LINE if mp . get ( A [ i ] , 0 ) : NEW_LINE INDENT mp [ A [ i ] ] = mp . get ( A [ i ] , 0 ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( 0 , len ( mp ) ) : NEW_LINE INDENT if mp [ i ] > 1 : NEW_LINE INDENT print ( \" , ▁ \" , mp [ i ] , \" , ▁ \" , mp [ i ] , i ] ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 6 , 4 , 12 , 40 , 21 , 22 , 2 ] NEW_LINE n = len ( A ) NEW_LINE pairWithEqualSum ( A , n ) NEW_LINE DEDENT"],"references":["def pairWithEqualSum ( A , n ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if A [ i ] + A [ j ] in mp : NEW_LINE INDENT mp [ A [ i ] + A [ j ] ] . append ( ( A [ i ] , A [ j ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT mp [ A [ i ] + A [ j ] ] = [ ( A [ i ] , A [ j ] ) ] NEW_LINE DEDENT DEDENT DEDENT for itr in mp : NEW_LINE INDENT if len ( mp [ itr ] ) > 1 : NEW_LINE INDENT print ( \" Pairs ▁ : ▁ \" , end = \" \" ) NEW_LINE for i in range ( 0 , len ( mp [ itr ] ) ) : NEW_LINE INDENT print ( \" ( \" , mp [ itr ] [ i ] [ 0 ] , \" , \" , mp [ itr ] [ i ] [ 1 ] , \" ) \" , end = \" ▁ \" ) NEW_LINE DEDENT print ( \" have ▁ sum ▁ : \" , itr ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 6 , 4 , 12 , 10 , 22 , 54 , 32 , 42 , 21 , 11 , 8 , 2 ] NEW_LINE n = len ( A ) NEW_LINE pairWithEqualSum ( A , n ) NEW_LINE DEDENT"],"bleu":0.5498324582836492,"rouge_l":0.6493630763710304}
{"id":1575,"predictions":["def happinessValues ( m , n , m , n ) : NEW_LINE INDENT d = ( ( abs ( m ) - n ) \/\/ ( n - 1 ) ) NEW_LINE a = m - ( ( n - 1 ) * d ) NEW_LINE res = ( a * ( m - 1 ) * d ) NEW_LINE return int ( res ) NEW_LINE DEDENT def findSum ( m , n , m , n , p ) : NEW_LINE INDENT a = [ ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT a . append ( float ( a [ i ] ) ) NEW_LINE DEDENT return int ( findSum ( m , n , m , n ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT m , n = 6 , 10 NEW_LINE print ( findSumValues ( m , n , m , n ) ) NEW_LINE DEDENT"],"references":["import math as mt NEW_LINE def findingValues ( m , n , mth , nth ) : NEW_LINE INDENT d = ( ( abs ( mth - nth ) ) \/ abs ( ( m - 1 ) - ( n - 1 ) ) ) NEW_LINE a = mth - ( ( m - 1 ) * d ) NEW_LINE return a , d NEW_LINE DEDENT def findSum ( m , n , mth , nth , p ) : NEW_LINE INDENT a , d = findingValues ( m , n , mth , nth ) NEW_LINE Sum = ( p * ( 2 * a + ( p - 1 ) * d ) ) \/ 2 NEW_LINE return Sum NEW_LINE DEDENT m = 6 NEW_LINE n = 10 NEW_LINE mTerm = 12 NEW_LINE nTerm = 20 NEW_LINE p = 5 NEW_LINE print ( findSum ( m , n , mTerm , nTerm , p ) ) NEW_LINE"],"bleu":0.40493787219365834,"rouge_l":0.5553869499241274}
{"id":1576,"predictions":["def sameOccurrence ( arr , n , x , y ) : NEW_LINE INDENT countX = { } ; NEW_LINE m = { } ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == x ) : NEW_LINE INDENT countX [ i ] = countX [ i - 1 ] + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT countY [ i ] = countX [ i - 1 ] + 1 ; NEW_LINE DEDENT if ( i != 0 ) : NEW_LINE INDENT if ( i != 0 ) : NEW_LINE INDENT countY [ i ] = countY [ i - 1 ] + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT countY [ i ] = countY [ i - 1 ] ; NEW_LINE DEDENT else : NEW_LINE INDENT countY [ i ] = countY [ i - 1 ] + 1 ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( i != 0 ) : NEW_LINE INDENT countY [ i ] ] = countY [ i - 1 ] ; NEW_LINE DEDENT else : NEW_LINE INDENT countY [ i ] = countY [ i - 1 ] ; NEW_LINE DEDENT DEDENT if ( m [ 0 ] == y ) : NEW_LINE INDENT m [ m [ 1 ] ] += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT m [ 0 ] = 0 ; NEW_LINE DEDENT DEDENT return ( countX , countY ) ; NEW_LINE DEDENT arr = [ 1 , 2 , 2 , 3 , 4 , 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE x = 2 ; NEW_LINE print ( sameOccurrence ( arr , n , x , y ) ) ; NEW_LINE"],"references":["def sameOccurrence ( arr , n , x , y ) : NEW_LINE INDENT countX = [ 0 for i in range ( n ) ] NEW_LINE countY = [ 0 for i in range ( n ) ] NEW_LINE m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == x ) : NEW_LINE INDENT if ( i != 0 ) : NEW_LINE INDENT countX [ i ] = countX [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT countX [ i ] = 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( i != 0 ) : NEW_LINE INDENT countX [ i ] = countX [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT countX [ i ] = 0 NEW_LINE DEDENT DEDENT if ( arr [ i ] == y ) : NEW_LINE INDENT if ( i != 0 ) : NEW_LINE INDENT countY [ i ] = countY [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT countY [ i ] = 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( i != 0 ) : NEW_LINE INDENT countY [ i ] = countY [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT countY [ i ] = 0 NEW_LINE DEDENT DEDENT m [ countX [ i ] - countY [ i ] ] = m . get ( countX [ i ] - countY [ i ] , 0 ) + 1 NEW_LINE DEDENT result = m [ 0 ] NEW_LINE for j in m : NEW_LINE INDENT result += ( m [ j ] * ( m [ j ] - 1 ) ) \/\/ 2 NEW_LINE DEDENT return result NEW_LINE DEDENT arr = [ 1 , 2 , 2 , 3 , 4 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE x , y = 2 , 3 NEW_LINE print ( sameOccurrence ( arr , n , x , y ) ) NEW_LINE"],"bleu":0.5969281483152906,"rouge_l":0.6813764776597876}
{"id":1577,"predictions":["def findNonPalin ( s ) : NEW_LINE INDENT freq = [ 0 for i in range ( 26 ) ] NEW_LINE flag = 0 NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT if ( s [ 0 ] != s [ 0 ] ) : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT freq [ ord ( s [ 0 ] ) - ord ( ' a ' ) ] += 1 NEW_LINE freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT if ( flag == 0 ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( chr ( ord ( ' a ' ) + i ) ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" abba \" NEW_LINE findNonPalin ( s ) NEW_LINE DEDENT"],"references":["def findNonPalinString ( s ) : NEW_LINE INDENT freq = [ 0 ] * ( 26 ) NEW_LINE flag = 0 NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT if s [ i ] != s [ 0 ] : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT if not flag : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 0 , 26 ) : NEW_LINE INDENT for j in range ( 0 , freq [ i ] ) : NEW_LINE INDENT print ( chr ( ord ( ' a ' ) + i ) , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" abba \" NEW_LINE findNonPalinString ( s ) NEW_LINE DEDENT"],"bleu":0.7300332685823535,"rouge_l":0.7740361151781356}
{"id":1578,"predictions":["def isFrequencyEqual ( str , len1 ) : NEW_LINE INDENT if ( len1 ) % 2 == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 0 NEW_LINE while ( i < len1 ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE i += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( freq [ i ] == len ( freq [ i ] ) ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT str = \" geeksforgeeks \" NEW_LINE l = len ( str ) NEW_LINE if ( isFrequencyEqual ( str , l ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"],"references":["def isFrequencyEqual ( string , length ) : NEW_LINE INDENT if length % 2 == 1 : NEW_LINE INDENT return False NEW_LINE DEDENT freq = [ 0 ] * 26 NEW_LINE for i in range ( 0 , length ) : NEW_LINE INDENT freq [ ord ( string [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 0 , 26 ) : NEW_LINE INDENT if freq [ i ] == length \/\/ 2 : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" geeksforgeeks \" NEW_LINE length = len ( string ) NEW_LINE if isFrequencyEqual ( string , length ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.5793873769917115,"rouge_l":0.7543117474780345}
{"id":1579,"predictions":["from math import sqrt NEW_LINE def summ ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n % 9 == 0 ) : NEW_LINE INDENT return 9 NEW_LINE DEDENT maxi = 1 NEW_LINE dig = 1 NEW_LINE for i in range ( 1 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT d = summ ( n \/\/ i ) NEW_LINE if ( d == maxi ) : NEW_LINE INDENT d1 = int ( n \/ i ) NEW_LINE d2 = d1 NEW_LINE maxi = d2 NEW_LINE DEDENT if ( d1 > maxi ) : NEW_LINE INDENT if ( d1 > maxi ) : NEW_LINE INDENT dig = i NEW_LINE maxi = d1 NEW_LINE DEDENT DEDENT DEDENT if ( d1 == maxi ) : NEW_LINE INDENT print ( int ( d1 \/ i ) , end = \" ▁ \" ) NEW_LINE maxi = d1 NEW_LINE DEDENT DEDENT if ( d2 == maxi ) : NEW_LINE INDENT print ( int ( d2 \/ i ) , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE printDigitalRoot ( n ) NEW_LINE DEDENT"],"references":["def summ ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( n % 9 == 0 ) : NEW_LINE INDENT return 9 ; NEW_LINE DEDENT else : NEW_LINE INDENT return ( n % 9 ) ; NEW_LINE DEDENT DEDENT def printDigitalRoot ( n ) : NEW_LINE INDENT maxi = 1 ; NEW_LINE dig = 1 ; NEW_LINE for i in range ( 1 , int ( pow ( n , 1 \/ 2 ) + 1 ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT d1 = summ ( n \/ i ) ; NEW_LINE d2 = summ ( i ) ; NEW_LINE if ( d1 > maxi ) : NEW_LINE INDENT dig = n \/ i ; NEW_LINE maxi = d1 ; NEW_LINE DEDENT if ( d2 > maxi ) : NEW_LINE INDENT dig = i ; NEW_LINE maxi = d2 ; NEW_LINE DEDENT if ( d1 == maxi ) : NEW_LINE INDENT if ( dig < ( n \/ i ) ) : NEW_LINE INDENT dig = n \/ i ; NEW_LINE maxi = d1 ; NEW_LINE DEDENT DEDENT if ( d2 == maxi ) : NEW_LINE INDENT if ( dig < i ) : NEW_LINE INDENT dig = i ; NEW_LINE maxi = d2 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( int ( dig ) , \" ▁ \" , int ( maxi ) ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 ; NEW_LINE printDigitalRoot ( n ) ; NEW_LINE DEDENT"],"bleu":0.5365649629014326,"rouge_l":0.6950454487261554}
{"id":1580,"predictions":["def countSubarrays ( arr , n ) : NEW_LINE INDENT difference = 0 NEW_LINE Hash = [ False ] * ( n + 1 ) NEW_LINE Hash [ 0 ] = True NEW_LINE hash [ 1 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT difference += 1 NEW_LINE DEDENT else : NEW_LINE INDENT difference += 1 NEW_LINE DEDENT DEDENT if ( difference < 0 ) : NEW_LINE INDENT aux [ 0 ] = True NEW_LINE DEDENT else : NEW_LINE INDENT aux [ 0 ] = 1 NEW_LINE DEDENT if ( difference < 0 ) : NEW_LINE INDENT aux [ 0 ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT aux [ 1 ] = 1 NEW_LINE DEDENT DEDENT return aux [ 0 ] NEW_LINE DEDENT arr = [ 3 , 4 , 6 , 8 , 1 , 10 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Total ▁ Number ▁ of ▁ Array ▁ are ▁ \" , countSubarrays ( arr , n ) ) NEW_LINE"],"references":["def countSubarrays ( arr , n ) : NEW_LINE INDENT difference = 0 NEW_LINE ans = 0 NEW_LINE hash_positive = [ 0 ] * ( n + 1 ) NEW_LINE hash_negative = [ 0 ] * ( n + 1 ) NEW_LINE hash_positive [ 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 == 1 ) : NEW_LINE INDENT difference = difference + 1 NEW_LINE DEDENT else : NEW_LINE INDENT difference = difference - 1 NEW_LINE DEDENT if ( difference < 0 ) : NEW_LINE INDENT ans += hash_negative [ - difference ] NEW_LINE hash_negative [ - difference ] = hash_negative [ - difference ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += hash_positive [ difference ] NEW_LINE hash_positive [ difference ] = hash_positive [ difference ] + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 3 , 4 , 6 , 8 , 1 , 10 , 5 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Total ▁ Number ▁ of ▁ Even - Odd ▁ subarrays ▁ are ▁ \" + str ( countSubarrays ( arr , n ) ) ) NEW_LINE"],"bleu":0.5902533862947433,"rouge_l":0.7290836653386454}
{"id":1581,"predictions":["MAX = 10000 ; NEW_LINE prime = [ True ] * ( MAX + 1 ) ; NEW_LINE def sieve ( ) : NEW_LINE INDENT prime [ 0 ] = False ; NEW_LINE prime [ 1 ] = False ; NEW_LINE p = 2 ; NEW_LINE while ( p * p <= MAX ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , MAX , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT p = p ; NEW_LINE DEDENT DEDENT def distinctSum ( arr1 , arr2 , m , n ) : NEW_LINE INDENT sieve ( ) ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( m ) : NEW_LINE INDENT if ( prime [ arr1 ] ) : NEW_LINE INDENT sum += arr1 [ i ] ; NEW_LINE DEDENT DEDENT DEDENT return sum ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr1 = [ 2 , 3 , 4 ] ; NEW_LINE arr2 = [ 2 , 2 ] ; NEW_LINE m = len ( arr1 ) ; NEW_LINE print ( distinctSum ( arr1 , arr2 , m , n ) ) ; NEW_LINE DEDENT"],"references":["MAX = 1000000 NEW_LINE prime = [ True for i in range ( MAX + 1 ) ] NEW_LINE def sieve ( ) : NEW_LINE INDENT prime [ 0 ] , prime [ 1 ] = False , False NEW_LINE for p in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if p * p > MAX : NEW_LINE INDENT break NEW_LINE DEDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( 2 * p , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def distinctSum ( arr1 , arr2 , m , n ) : NEW_LINE INDENT sieve ( ) NEW_LINE sumSet = dict ( ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( prime [ arr1 [ i ] ] and prime [ arr2 [ j ] ] ) : NEW_LINE INDENT sumSet [ arr1 [ i ] + arr2 [ j ] ] = 1 NEW_LINE DEDENT DEDENT DEDENT return len ( sumSet ) NEW_LINE DEDENT arr1 = [ 2 , 3 ] NEW_LINE arr2 = [ 2 , 2 , 4 , 7 ] NEW_LINE m = len ( arr1 ) NEW_LINE n = len ( arr2 ) NEW_LINE print ( distinctSum ( arr1 , arr2 , m , n ) ) NEW_LINE"],"bleu":0.5415680709765149,"rouge_l":0.7126267925848199}
{"id":1582,"predictions":["def shufleArray ( a , n ) : NEW_LINE INDENT temp = n \/\/ 2 NEW_LINE j = n + 1 NEW_LINE while ( True ) : NEW_LINE INDENT if ( start == j ) : NEW_LINE INDENT if ( start == j ) : NEW_LINE INDENT start -= 1 NEW_LINE end -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT end -= 1 NEW_LINE DEDENT if ( start == j ) : NEW_LINE INDENT start -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT DEDENT DEDENT i = j NEW_LINE j = 0 NEW_LINE while ( True ) : NEW_LINE INDENT if ( start > n ) : NEW_LINE INDENT start -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT mid = 2 * i NEW_LINE DEDENT j += 1 NEW_LINE DEDENT return end NEW_LINE DEDENT a = [ - 1 , 1 , 3 , 5 , 7 , 2 , 8 , 4 , 6 ] NEW_LINE n = len ( a ) NEW_LINE shufleArray ( a , n ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT print ( a [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT"],"references":["def shufleArray ( a , n ) : NEW_LINE INDENT n = n \/\/ 2 NEW_LINE start = n + 1 NEW_LINE j = n + 1 NEW_LINE for done in range ( 2 * n - 2 ) : NEW_LINE INDENT if ( start == j ) : NEW_LINE INDENT start -= 1 NEW_LINE j -= 1 NEW_LINE DEDENT i = j - n if j > n else j NEW_LINE j = 2 * i if j > n else 2 * i - 1 NEW_LINE a [ start ] , a [ j ] = a [ j ] , a [ start ] NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ - 1 , 1 , 3 , 5 , 7 , 2 , 4 , 6 , 8 ] NEW_LINE n = len ( a ) NEW_LINE shufleArray ( a , n ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT print ( a [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.5456809196798357,"rouge_l":0.6438402431816262}
{"id":1583,"predictions":["MAX = 100005 NEW_LINE def Min_Replace ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE freq = [ 0 for i in range ( MAX ) ] NEW_LINE freq [ 0 ] = 1 NEW_LINE p = 0 NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i - 1 ] ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( k , p + 1 ) : NEW_LINE INDENT ans += freq [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 7 , 8 , 2 , 3 , 3 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE print ( Min_Replace ( arr , n , k ) ) NEW_LINE DEDENT"],"references":["MAX = 100005 NEW_LINE def Min_Replace ( arr , n , k ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE freq = [ 0 for i in range ( MAX ) ] NEW_LINE p = 0 NEW_LINE freq [ p ] = 1 NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i - 1 ] ) : NEW_LINE INDENT freq [ p ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT p += 1 NEW_LINE freq [ p ] += 1 NEW_LINE DEDENT DEDENT freq . sort ( reverse = True ) NEW_LINE ans = 0 NEW_LINE for i in range ( k , p + 1 , 1 ) : NEW_LINE INDENT ans += freq [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 7 , 8 , 2 , 3 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE print ( Min_Replace ( arr , n , k ) ) NEW_LINE DEDENT"],"bleu":0.8112465446282443,"rouge_l":0.8848594741613782}
{"id":1584,"predictions":["MAX = 10000 ; NEW_LINE size = 1 ; NEW_LINE def factorial ( val , currentFact ) : NEW_LINE INDENT global size ; NEW_LINE for x in range ( len ( val ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT size = int ( val ** ( x ) ) ; NEW_LINE for i in range ( size - 1 , - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( val , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( \" \" ) ; NEW_LINE DEDENT DEDENT def print_orial ( val , size ) : NEW_LINE INDENT if ( val < 1 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT a = 1 ; NEW_LINE b = 1 ; NEW_LINE c = 0 ; NEW_LINE while ( c < size ) : NEW_LINE INDENT fact = ( val * x + carry ) ; NEW_LINE c = c + 1 ; NEW_LINE DEDENT DEDENT def multiply ( val , size ) : NEW_LINE INDENT global ans NEW_LINE if ( limit < size ) : NEW_LINE INDENT return NEW_LINE DEDENT a = 0 ; NEW_LINE b = 0 ; NEW_LINE c = 0 ; NEW_LINE while ( c < limit ) : NEW_LINE INDENT prod = ( prevFactorial ( val , b , c ) ) ; NEW_LINE ans = ans % 10 ; NEW_LINE DEDENT return size ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT limit = 20 ; NEW_LINE power ( limit ) ; NEW_LINE DEDENT"],"references":["MAX = 500 NEW_LINE size = 1 NEW_LINE def factorial ( prevFact , prev , n ) : NEW_LINE INDENT global size NEW_LINE for x in range ( ( prev + 1 ) , n + 1 ) : NEW_LINE INDENT size = multiply ( x , prevFact , size ) NEW_LINE DEDENT for i in range ( ( size - 1 ) , - 1 , - 1 ) : NEW_LINE INDENT print ( prevFact [ i ] , end = \" \" ) NEW_LINE DEDENT print ( end = \" ▁ \" ) NEW_LINE DEDENT def printfibFactorials ( limit ) : NEW_LINE INDENT if ( limit < 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT a = 1 NEW_LINE b = 1 NEW_LINE c = 2 NEW_LINE print ( a , b , end = \" ▁ \" ) NEW_LINE prevFact = [ 0 ] * MAX NEW_LINE prevFact [ 0 ] = 1 NEW_LINE while ( c < limit ) : NEW_LINE INDENT factorial ( prevFact , b , c ) NEW_LINE a = b NEW_LINE b = c NEW_LINE c = a + b NEW_LINE DEDENT DEDENT def multiply ( x , prevFact , size ) : NEW_LINE INDENT carry = 0 NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT prod = prevFact [ i ] * x + carry NEW_LINE prevFact [ i ] = prod % 10 NEW_LINE carry = prod \/\/ 10 NEW_LINE DEDENT while ( carry != 0 ) : NEW_LINE INDENT prevFact [ size ] = carry % 10 NEW_LINE carry = carry \/\/ 10 NEW_LINE size = size + 1 NEW_LINE DEDENT return size NEW_LINE DEDENT limit = 20 NEW_LINE printfibFactorials ( limit ) NEW_LINE"],"bleu":0.4007774525426154,"rouge_l":0.583663943990665}
{"id":1585,"predictions":["MAX = 10000 ; NEW_LINE primes = [ ] ; NEW_LINE def cr ( n ) : NEW_LINE INDENT primes . append ( 0 ) ; NEW_LINE result = [ ] ; NEW_LINE for i in range ( 2 , MAX ) : NEW_LINE INDENT if ( primes [ i ] == 0 ) : NEW_LINE INDENT primes . append ( 1 ) ; NEW_LINE for j in range ( i , MAX , i ) : NEW_LINE INDENT primes . append ( primes [ j ] ) ; NEW_LINE DEDENT DEDENT DEDENT result = 1 ; NEW_LINE for i in range ( 1 , MAX ) : NEW_LINE INDENT if ( primes [ i ] == 0 ) : NEW_LINE INDENT primes . append ( i ) ; NEW_LINE DEDENT DEDENT return result ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 50 ; NEW_LINE print ( cr ( n ) ) ; NEW_LINE DEDENT"],"references":["MAX = 3000 ; NEW_LINE def smartNumber ( n ) : NEW_LINE INDENT primes = [ 0 ] * MAX ; NEW_LINE result = [ ] ; NEW_LINE for i in range ( 2 , MAX ) : NEW_LINE INDENT if ( primes [ i ] == 0 ) : NEW_LINE INDENT primes [ i ] = 1 ; NEW_LINE j = i * 2 ; NEW_LINE while ( j < MAX ) : NEW_LINE INDENT primes [ j ] -= 1 ; NEW_LINE if ( ( primes [ j ] + 3 ) == 0 ) : NEW_LINE INDENT result . append ( j ) ; NEW_LINE DEDENT j = j + i ; NEW_LINE DEDENT DEDENT DEDENT result . sort ( ) ; NEW_LINE return result [ n - 1 ] ; NEW_LINE DEDENT n = 50 ; NEW_LINE print ( smartNumber ( n ) ) ; NEW_LINE"],"bleu":0.5027115525124791,"rouge_l":0.6404199475065616}
{"id":1586,"predictions":["def countPairs ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for x in range ( 1 , n ) : NEW_LINE INDENT for y in range ( x + 1 , n + 1 ) : NEW_LINE INDENT if ( ( y + x ) % ( y ^ x ) == 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 6 NEW_LINE print ( countPairs ( n ) ) NEW_LINE DEDENT"],"references":["def countPairs ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE for x in range ( 1 , n ) : NEW_LINE INDENT for y in range ( x + 1 , n + 1 ) : NEW_LINE INDENT if ( ( y + x ) % ( y ^ x ) == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 6 ; NEW_LINE print ( countPairs ( n ) ) ; NEW_LINE DEDENT"],"bleu":0.857902029564488,"rouge_l":0.9521853434111073}
{"id":1587,"predictions":["def allIndexes = [ 0 ] * ( len ( x ) ) ; NEW_LINE def allIndexes ( string , x , start , end ) : NEW_LINE INDENT if ( start == len ( x ) ) : NEW_LINE INDENT return ; NEW_LINE DEDENT if ( x == len ( x ) ) : NEW_LINE INDENT return ; NEW_LINE DEDENT myAns = [ ] ; NEW_LINE for i in range ( len ( x ) ) : NEW_LINE INDENT myAns [ x + 1 ] =   \\ NEW_LINE INDENT myAns [ i ] = i ; NEW_LINE DEDENT myAns . append ( myAns [ i + 1 ] ) ; NEW_LINE DEDENT return myAns ; NEW_LINE DEDENT def allIndexes ( string , x , 0 ) : NEW_LINE INDENT return allAns ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 2 , 2 ] ; NEW_LINE x = len ( arr ) ; NEW_LINE print ( allIndexes ( arr , x , len ( arr ) ) ; NEW_LINE DEDENT"],"references":["def AllIndexesRecursive ( input , x , start ) : NEW_LINE INDENT if ( start == len ( input ) ) : NEW_LINE INDENT ans = [ ] NEW_LINE return ans NEW_LINE DEDENT smallIndex = AllIndexesRecursive ( input , x , start + 1 ) NEW_LINE if ( input [ start ] == x ) : NEW_LINE INDENT myAns = [ 0 for i in range ( len ( smallIndex ) + 1 ) ] NEW_LINE myAns [ 0 ] = start NEW_LINE for i in range ( len ( smallIndex ) ) : NEW_LINE INDENT myAns [ i + 1 ] = smallIndex [ i ] NEW_LINE DEDENT return myAns NEW_LINE DEDENT else : NEW_LINE INDENT return smallIndex NEW_LINE DEDENT DEDENT def AllIndexes ( input , x ) : NEW_LINE INDENT return AllIndexesRecursive ( input , x , 0 ) NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 2 , 2 , 5 ] NEW_LINE x = 2 NEW_LINE output = AllIndexes ( arr , x ) NEW_LINE for i in output : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT"],"bleu":0.4081738121916724,"rouge_l":0.5415912421342987}
{"id":1588,"predictions":["from math import pow , sqrt NEW_LINE def fib ( n ) : NEW_LINE INDENT phi = ( 1 + sqrt ( 5 ) ) \/ 2 NEW_LINE return round ( pow ( phi , n ) \/ math . sqrt ( 5 ) ) NEW_LINE DEDENT def calculateSum ( l , r ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT sum += fib ( i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT l = 4 NEW_LINE r = 8 NEW_LINE print ( calculateSum ( l , r ) ) NEW_LINE"],"references":["def fib ( n ) : NEW_LINE INDENT phi = ( ( 1 + ( 5 ** ( 1 \/ 2 ) ) ) \/ 2 ) ; NEW_LINE return round ( ( phi ** n ) \/ ( 5 ** ( 1 \/ 2 ) ) ) ; NEW_LINE DEDENT def calculateSum ( l , r ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT sum += fib ( i ) ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT l , r = 4 , 8 ; NEW_LINE print ( calculateSum ( l , r ) ) ; NEW_LINE DEDENT"],"bleu":0.5125937509966945,"rouge_l":0.7505875846813217}
{"id":1589,"predictions":["def findSum ( N ) : NEW_LINE INDENT return ( N * ( N + 1 ) * ( 2 * N - 5 ) + 4 * N ) \/\/ 2 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 3 NEW_LINE print ( findSum ( N ) ) NEW_LINE DEDENT"],"references":["def findSum ( N ) : NEW_LINE INDENT return ( ( N * ( N + 1 ) * ( 2 * N - 5 ) + 4 * N ) \/ 2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE print ( findSum ( N ) ) NEW_LINE DEDENT"],"bleu":0.8159933766754914,"rouge_l":0.9316720257234726}
{"id":1590,"predictions":["def sumOfPrevKK ( N , K ) : NEW_LINE INDENT arr = [ 0 ] * N ; NEW_LINE arr [ 0 ] = 1 ; NEW_LINE arr [ 0 ] = 1 ; NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT j = i - 1 ; NEW_LINE count = 0 ; NEW_LINE while ( j >= 0 and count < K ) : NEW_LINE INDENT sum += arr [ j ] ; NEW_LINE j -= 1 ; NEW_LINE DEDENT arr [ i ] = sum ; NEW_LINE count += 1 ; NEW_LINE DEDENT for i in range ( 0 , N ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 10 ; NEW_LINE K = 4 ; NEW_LINE sumOfPrevK ( N , K ) ; NEW_LINE DEDENT"],"references":["def sumOfPrevK ( N , K ) : NEW_LINE INDENT arr = [ 0 for i in range ( N ) ] NEW_LINE arr [ 0 ] = 1 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT j = i - 1 NEW_LINE count = 0 NEW_LINE sum = 0 NEW_LINE while ( j >= 0 and count < K ) : NEW_LINE INDENT sum = sum + arr [ j ] NEW_LINE j = j - 1 NEW_LINE count = count + 1 NEW_LINE DEDENT arr [ i ] = sum NEW_LINE DEDENT for i in range ( 0 , N ) : NEW_LINE INDENT print ( arr [ i ] ) NEW_LINE DEDENT DEDENT N = 10 NEW_LINE K = 4 NEW_LINE sumOfPrevK ( N , K ) NEW_LINE"],"bleu":0.5630249290767487,"rouge_l":0.7726712251989688}
{"id":1591,"predictions":["def productDivisible ( n , k ) : NEW_LINE INDENT product = 1 NEW_LINE position = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( position % 2 == 0 ) : NEW_LINE INDENT product *= n %= 10 NEW_LINE DEDENT n = n \/\/ 10 NEW_LINE position += 1 NEW_LINE DEDENT if ( product % k == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 32 NEW_LINE k = 3 NEW_LINE if ( productDivisible ( n , k ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"references":["def productDivisible ( n , k ) : NEW_LINE INDENT product = 1 NEW_LINE position = 1 NEW_LINE while n > 0 : NEW_LINE INDENT if position % 2 == 0 : NEW_LINE INDENT product *= n % 10 NEW_LINE DEDENT n = n \/ 10 NEW_LINE position += 1 NEW_LINE DEDENT if product % k == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT n = 321922 NEW_LINE k = 3 NEW_LINE if productDivisible ( n , k ) == True : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"],"bleu":0.6596479366894402,"rouge_l":0.887396838718702}
{"id":1592,"predictions":["def countPairs ( N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT cb = i * i NEW_LINE diff = N - cb NEW_LINE cb = N - cb NEW_LINE if ( cb * diff == diff ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT for i in range ( 1 , 10 ) : NEW_LINE INDENT print ( \" For ▁ n ▁ = ▁ \" , i , \" , ▁ \" , countPairs ( i ) , end = \" , ▁ \" ) NEW_LINE DEDENT DEDENT"],"references":["import math NEW_LINE def countPairs ( N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , int ( math . pow ( N , 1 \/ 3 ) + 1 ) ) : NEW_LINE INDENT cb = i * i * i NEW_LINE diff = N - cb NEW_LINE cbrtDiff = int ( math . pow ( diff , 1 \/ 3 ) ) NEW_LINE if ( cbrtDiff * cbrtDiff * cbrtDiff == diff ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT for i in range ( 1 , 11 ) : NEW_LINE INDENT print ( ' For ▁ n ▁ = ▁ ' , i , ' , ▁ ' , countPairs ( i ) , ' ▁ pair ▁ exists ' ) NEW_LINE DEDENT"],"bleu":0.5291571548852629,"rouge_l":0.7053338306602014}
{"id":1593,"predictions":["MAX = 100 NEW_LINE def repeated_digit ( n ) : NEW_LINE INDENT a = set ( ) NEW_LINE while n != 0 : NEW_LINE INDENT d = n % 10 NEW_LINE if d == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT a . add ( d ) NEW_LINE n \/\/= 10 NEW_LINE DEDENT return 1 NEW_LINE DEDENT def pre_sum ( ) : NEW_LINE INDENT pre_sum = [ 0 ] NEW_LINE for i in range ( 2 , MAX + 1 ) : NEW_LINE INDENT repeated_digit [ i ] = i NEW_LINE DEDENT for i in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if repeated_digit ( i ) : NEW_LINE INDENT pre_sum . append ( repeated_digit ( i ) NEW_LINE DEDENT DEDENT return pre_sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT L = 1 NEW_LINE R = 100 NEW_LINE pre_sum ( L , R ) NEW_LINE print ( calculate ( L , R ) ) NEW_LINE DEDENT"],"references":["Prefix = [ 0 ] NEW_LINE def repeated_digit ( n ) : NEW_LINE INDENT a = [ ] NEW_LINE while n != 0 : NEW_LINE INDENT d = n % 10 NEW_LINE if d in a : NEW_LINE INDENT return 0 NEW_LINE DEDENT a . append ( d ) NEW_LINE n = n \/\/ 10 NEW_LINE DEDENT return 1 NEW_LINE DEDENT def pre_calculation ( MAX ) : NEW_LINE INDENT global Prefix NEW_LINE Prefix . append ( repeated_digit ( 1 ) ) NEW_LINE for i in range ( 2 , MAX + 1 ) : NEW_LINE INDENT Prefix . append ( repeated_digit ( i ) + Prefix [ i - 1 ] ) NEW_LINE DEDENT DEDENT def calculate ( L , R ) : NEW_LINE INDENT return Prefix [ R ] - Prefix [ L - 1 ] NEW_LINE DEDENT MAX = 1000 NEW_LINE pre_calculation ( MAX ) NEW_LINE L = 1 NEW_LINE R = 100 NEW_LINE print ( calculate ( L , R ) ) NEW_LINE"],"bleu":0.569991462131737,"rouge_l":0.633859425546515}
{"id":1594,"predictions":["from math import sqrt NEW_LINE def satisfies ( n ) : NEW_LINE INDENT if ( n > n ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT n -= int ( sqrt ( n ) ) ; NEW_LINE DEDENT return n ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 17 ; NEW_LINE if satisfies ( n ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"],"references":["def Survives ( n ) : NEW_LINE INDENT i = 2 NEW_LINE while ( True ) : NEW_LINE INDENT if ( i > n ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT n -= n \/\/ i ; NEW_LINE i += 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 17 ; NEW_LINE if ( Survives ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"],"bleu":0.6941373319817584,"rouge_l":0.7971639093563186}
{"id":1595,"predictions":["def maxPerimeter ( arr1 , n ) : NEW_LINE INDENT maxi = 0 NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , n , 1 ) : NEW_LINE INDENT a = arr1 [ j ] NEW_LINE b = arr1 [ j ] NEW_LINE c = arr1 [ j ] NEW_LINE if ( a < b + c and b < c and b < c and c < c ) : NEW_LINE INDENT maxi = max ( maxi , a + b ) NEW_LINE DEDENT DEDENT if ( maxi > 0 ) : NEW_LINE INDENT maxi = max ( maxi , b ) NEW_LINE DEDENT DEDENT if ( maxi > 0 ) : NEW_LINE INDENT print ( \" Triangle ▁ is ▁ not ▁ Possible \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Triangle ▁ permimeter \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr1 [ 6 , 1 , 6 , 8 , 1 , 12 , 4 , 5 ] NEW_LINE arr2 = [ 2 , 20 , 8 , 1 , 12 , 34 , 4 ] NEW_LINE maxPerimeter ( arr1 , arr2 , n ) NEW_LINE DEDENT DEDENT"],"references":["def maxPerimeter ( arr ) : NEW_LINE INDENT maxi = 0 NEW_LINE n = len ( arr ) NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT a = arr [ i ] NEW_LINE b = arr [ j ] NEW_LINE c = arr [ k ] NEW_LINE if ( a < b + c and b < a + c and c < a + b ) : NEW_LINE INDENT maxi = max ( maxi , a + b + c ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( maxi == 0 ) : NEW_LINE INDENT return \" Triangle ▁ formation ▁ is ▁ not ▁ possible \" NEW_LINE DEDENT else : NEW_LINE INDENT return \" Maximum ▁ Perimeter ▁ is : ▁ \" + str ( maxi ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT arr1 = [ 6 , 1 , 6 , 5 , 8 , 4 ] NEW_LINE a = maxPerimeter ( arr1 ) NEW_LINE print ( a ) NEW_LINE arr2 = [ 2 , 20 , 7 , 55 , 1 , 33 , 12 , 4 ] NEW_LINE a = maxPerimeter ( arr2 ) NEW_LINE print ( a ) NEW_LINE arr3 = [ 33 , 6 , 20 , 1 , 8 , 12 , 5 , 55 , 4 , 9 ] NEW_LINE a = maxPerimeter ( arr3 ) NEW_LINE print ( a ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"bleu":0.4545540390223322,"rouge_l":0.6021755533199196}
{"id":1596,"predictions":["import math NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT s = math . sqrt ( x ) ; NEW_LINE return ( s * s == x ) ; NEW_LINE DEDENT def isFibonacci ( N ) : NEW_LINE INDENT return ( isPerfectSquare ( 5 * N * N + 4 ) or isPerfectSquare ( 5 * N - 4 ) ) ; NEW_LINE DEDENT def nextNonFibonacciacci ( N ) : NEW_LINE INDENT return N + 2 ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 3 ; NEW_LINE print ( nextNonFibonacci ( N ) ) ; NEW_LINE N = 5 ; NEW_LINE print ( nextNonFibonacci ( N ) ) ; NEW_LINE N = 5 ; NEW_LINE print ( nextNonFibonacci ( N ) ) ; NEW_LINE DEDENT"],"references":["from math import sqrt NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT s = sqrt ( x ) NEW_LINE return ( s * s == x ) NEW_LINE DEDENT def isFibonacci ( N ) : NEW_LINE INDENT return isPerfectSquare ( 5 * N * N + 4 ) or   \\ NEW_LINE INDENT isPerfectSquare ( 5 * N * N - 4 ) NEW_LINE DEDENT DEDENT def nextNonFibonacci ( N ) : NEW_LINE INDENT if ( N <= 3 ) : NEW_LINE INDENT return 4 NEW_LINE DEDENT if ( isFibonacci ( N + 1 ) ) : NEW_LINE INDENT return N + 2 NEW_LINE DEDENT else : NEW_LINE INDENT return N NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE print ( nextNonFibonacci ( N ) ) NEW_LINE N = 4 NEW_LINE print ( nextNonFibonacci ( N ) ) NEW_LINE N = 7 NEW_LINE print ( nextNonFibonacci ( N ) ) NEW_LINE DEDENT"],"bleu":0.5334865557086993,"rouge_l":0.7546928327645053}
{"id":1597,"predictions":["def bit_check ( n ) : NEW_LINE INDENT if ( n & ( n - 1 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT n = 14 NEW_LINE if ( bit_check ( n ) ) : NEW_LINE INDENT print ( \"1\" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \"0\" ) NEW_LINE DEDENT"],"references":["def bit_check ( n ) : NEW_LINE INDENT if ( ( n & ( n - 1 ) ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 14 NEW_LINE if ( bit_check ( n ) ) : NEW_LINE INDENT print ( '1' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( '0' ) NEW_LINE DEDENT DEDENT"],"bleu":0.6316913367759308,"rouge_l":0.8186955497998588}
{"id":1598,"predictions":["def center_octadecagonal ( n ) : NEW_LINE INDENT return ( 8 * n - 8 * n + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 2 NEW_LINE print ( n , \" th ▁ centered ▁ octadecagonal ▁ \" + \" number ▁ : ▁ \" , center_octadecagonal_num ( n ) ) NEW_LINE n = 12 NEW_LINE print ( n , \" th ▁ Centered ▁ octadecagonal ▁ \" + \" number ▁ : ▁ \" , center_octadecagonal_num ( n ) ) NEW_LINE DEDENT"],"references":["def center_hexadecagonal_num ( n ) : NEW_LINE INDENT return 8 * n * n - 8 * n + 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 2 NEW_LINE print ( n , \" nd ▁ centered ▁ hexadecagonal ▁ \" + \" number ▁ : ▁ \" , center_hexadecagonal_num ( n ) ) NEW_LINE n = 12 NEW_LINE print ( n , \" th ▁ centered ▁ hexadecagonal ▁ \" + \" number ▁ : ▁ \" , center_hexadecagonal_num ( n ) ) NEW_LINE DEDENT"],"bleu":0.7795077487939177,"rouge_l":0.9062500000000001}
{"id":1599,"predictions":["def fib ( n ) : NEW_LINE INDENT a = 0 NEW_LINE b = 1 NEW_LINE if ( n >= 0 ) : NEW_LINE INDENT print ( a + b , end = \" ▁ \" ) NEW_LINE DEDENT if ( n >= 1 ) : NEW_LINE INDENT print ( a , end = \" ▁ \" ) NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT print ( b , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT fib ( 9 ) NEW_LINE"],"references":["def fib ( n ) : NEW_LINE INDENT a = 0 NEW_LINE b = 1 NEW_LINE if ( n >= 0 ) : NEW_LINE INDENT print ( a , end = ' ▁ ' ) NEW_LINE DEDENT if ( n >= 1 ) : NEW_LINE INDENT print ( b , end = ' ▁ ' ) NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT print ( a + b , end = ' ▁ ' ) NEW_LINE b = a + b NEW_LINE a = b - a NEW_LINE DEDENT DEDENT fib ( 9 ) NEW_LINE"],"bleu":0.7485079840884361,"rouge_l":0.8376902713434812}
{"id":1600,"predictions":["from math import sqrt NEW_LINE def prime ( n ) : NEW_LINE INDENT for i in range ( 2 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT def thirdNumber ( a , b ) : NEW_LINE INDENT sum = 0 ; NEW_LINE temp = a + b ; NEW_LINE sum = a + b ; NEW_LINE while ( sum < 0 ) : NEW_LINE INDENT if ( prime ( sum + temp ) ) : NEW_LINE INDENT temp = 2 ; NEW_LINE while ( not ( sum + temp ) ) : NEW_LINE INDENT temp = 2 ; NEW_LINE if ( prime ( temp ) : NEW_LINE INDENT temp += 2 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( temp ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 3 ; b = 5 ; NEW_LINE thirdNumber ( a , b ) ; NEW_LINE DEDENT"],"references":["def prime ( n ) : NEW_LINE INDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if i * i > n + 1 : NEW_LINE INDENT break NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def thirdNumber ( a , b ) : NEW_LINE INDENT summ = 0 NEW_LINE temp = 0 NEW_LINE summ = a + b NEW_LINE temp = 1 NEW_LINE if ( summ & 1 ) : NEW_LINE INDENT temp = 2 NEW_LINE DEDENT while ( prime ( summ + temp ) == False ) : NEW_LINE INDENT temp += 2 NEW_LINE DEDENT print ( temp ) NEW_LINE DEDENT a = 3 NEW_LINE b = 5 NEW_LINE thirdNumber ( a , b ) NEW_LINE"],"bleu":0.445929517223791,"rouge_l":0.6967410667504977}
{"id":1601,"predictions":["def canDistance ( x , y , i , c ) : NEW_LINE INDENT return ( min ( x , y ) <= c and ( x <= c ) or ( y <= c ) ) NEW_LINE DEDENT def canDistance ( x , y , i , j , k ) : NEW_LINE INDENT return ( ( x [ k ] == x [ i ] or ( x [ i ] == x [ k ] and ( y [ k ] == y [ k ] and ( y [ i ] == y [ k ] and x [ k ] == y [ k ] ) or ( y [ i ] == x [ j ] and y [ k ] == y ) ) ) ) NEW_LINE DEDENT def countLine ( x , y , i , j ) : NEW_LINE INDENT if ( ( ( x [ i ] == x [ j ] and y [ i ] == y [ j ] ) or ( x [ i ] == y [ j ] and y [ i ] == y [ j ] ) ) ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = 3 NEW_LINE y = - 1 NEW_LINE x = - 1 NEW_LINE y = - 1 NEW_LINE c = - 1 NEW_LINE if ( canDistance ( x , y , 0 , 1 , 2 ) ) : NEW_LINE INDENT return 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT return 2 ; NEW_LINE DEDENT DEDENT x = - 1 NEW_LINE y = - 1 NEW_LINE x = - 1 NEW_LINE y = - 1 NEW_LINE print ( countLine ( x , y , 0 , 0 ) ) ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def isBetween ( a , b , c ) : NEW_LINE INDENT return min ( a , b ) <= c and c <= max ( a , b ) NEW_LINE DEDENT def canJoin ( x , y , i , j , k ) : NEW_LINE INDENT return ( x [ k ] == x [ i ] or x [ k ] == x [ j ] ) and isBetween ( y [ i ] , y [ j ] , y [ k ] ) or ( y [ k ] == y [ i ] or y [ k ] == y [ j ] ) and isBetween ( x [ i ] , x [ j ] , x [ k ] ) NEW_LINE DEDENT def countLineSegments ( x , y ) : NEW_LINE INDENT if ( ( x [ 0 ] == x [ 1 ] and x [ 1 ] == x [ 2 ] ) or ( y [ 0 ] == y [ 1 ] and y [ 1 ] == y [ 2 ] ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( canJoin ( x , y , 0 , 1 , 2 ) or canJoin ( x , y , 0 , 2 , 1 ) or canJoin ( x , y , 1 , 2 , 0 ) ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT else : NEW_LINE INDENT return 3 NEW_LINE DEDENT DEDENT x = [ - 1 , - 1 , 4 ] NEW_LINE y = [ - 1 , 3 , 3 ] NEW_LINE print ( countLineSegments ( x , y ) ) NEW_LINE"],"bleu":0.5060298676373138,"rouge_l":0.6592434910758147}
{"id":1602,"predictions":["def ReplaceElements ( arr , n ) : NEW_LINE INDENT min_ele = arr [ 0 ] NEW_LINE arr [ 0 ] = - 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( min_ele < arr [ i ] ) : NEW_LINE INDENT arr [ i ] , arr [ min_ele ] = arr [ i ] , arr [ min_ele ] NEW_LINE DEDENT elif ( min_ele >= arr [ i ] ) : NEW_LINE INDENT arr [ min_ele ] = arr [ min_ele ] , arr [ i ] NEW_LINE min_ele = arr [ min_ele ] NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 5 , 2 , 1 , 7 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE ReplaceElements ( arr , n ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT"],"references":["def ReplaceElements ( arr , n ) : NEW_LINE INDENT min_ele = arr [ 0 ] NEW_LINE arr [ 0 ] = - 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( min_ele < arr [ i ] ) : NEW_LINE INDENT arr [ i ] = min_ele NEW_LINE DEDENT elif ( min_ele >= arr [ i ] ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE arr [ i ] = min_ele NEW_LINE min_ele = temp NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 4 , 5 , 2 , 1 , 7 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE ReplaceElements ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.783494842057613,"rouge_l":0.9053469628464713}
{"id":1603,"predictions":["def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT def getMin ( arr , i , j ) : NEW_LINE INDENT minVal = arr [ i ] NEW_LINE while ( i <= j ) : NEW_LINE INDENT minVal = min ( minVal , arr [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT return minVal NEW_LINE DEDENT def getMax ( arr , i , j ) : NEW_LINE INDENT maxVal = arr [ i ] NEW_LINE while ( i <= j ) : NEW_LINE INDENT maxVal = max ( maxVal , arr [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT return maxVal NEW_LINE DEDENT def generateArr ( arr , i , j ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT return NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 5 , 2 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE generateArr ( arr , 0 , n - 1 ) NEW_LINE DEDENT"],"references":["def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT def getMin ( arr , i , j ) : NEW_LINE INDENT minVal = arr [ i ] NEW_LINE i += 1 NEW_LINE while ( i <= j ) : NEW_LINE INDENT minVal = min ( minVal , arr [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT return minVal NEW_LINE DEDENT def getMax ( arr , i , j ) : NEW_LINE INDENT maxVal = arr [ i ] NEW_LINE i += 1 NEW_LINE while ( i <= j ) : NEW_LINE INDENT maxVal = max ( maxVal , arr [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT return maxVal NEW_LINE DEDENT def generateArr ( arr , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT print ( arr [ 0 ] , end = \" \" ) NEW_LINE return NEW_LINE DEDENT tmpArr = [ 0 for i in range ( n ) ] NEW_LINE tmpArr [ 0 ] = getMax ( arr , 1 , n - 1 ) NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT tmpArr [ i ] = abs ( getMax ( arr , i + 1 , n - 1 ) - getMin ( arr , 0 , i - 1 ) ) NEW_LINE DEDENT tmpArr [ n - 1 ] = getMin ( arr , 0 , n - 2 ) NEW_LINE printArray ( tmpArr , n ) NEW_LINE DEDENT arr = [ 1 , 5 , 2 , 4 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE generateArr ( arr , n ) NEW_LINE"],"bleu":0.5187206671892824,"rouge_l":0.6867963152507677}
{"id":1604,"predictions":["def tot ( n ) : NEW_LINE INDENT result = 0 NEW_LINE result = ( n * ( n - 1 ) ) \/ 2 NEW_LINE return result NEW_LINE DEDENT n = 6 NEW_LINE print ( tot ( n ) ) NEW_LINE"],"references":["def totEdge ( n ) : NEW_LINE INDENT result = ( n * ( n - 1 ) ) \/\/ 2 NEW_LINE return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 6 NEW_LINE print ( totEdge ( n ) ) NEW_LINE DEDENT"],"bleu":0.5458126780097663,"rouge_l":0.7306639288158795}
{"id":1605,"predictions":["def countNumbers ( L , R , K ) : NEW_LINE INDENT if ( K == 9 ) : NEW_LINE INDENT if ( K == 9 ) : NEW_LINE INDENT K = 0 NEW_LINE DEDENT else : NEW_LINE INDENT return ( K - L + 1 ) \/\/ 9 NEW_LINE DEDENT DEDENT totalnumbers = R - L + 1 NEW_LINE res = totalnumbers NEW_LINE for i in range ( R - rem , - rem ) : NEW_LINE INDENT rem1 = i % 9 NEW_LINE if ( rem1 == K ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT L = 22 NEW_LINE R = 22 NEW_LINE K = 3 NEW_LINE print ( countNumbers ( L , R , K ) ) NEW_LINE"],"references":["def countNumbers ( L , R , K ) : NEW_LINE INDENT if ( K == 9 ) : NEW_LINE INDENT K = 0 NEW_LINE DEDENT totalnumbers = R - L + 1 NEW_LINE factor9 = totalnumbers \/\/ 9 NEW_LINE rem = totalnumbers % 9 NEW_LINE ans = factor9 NEW_LINE for i in range ( R , R - rem , - 1 ) : NEW_LINE INDENT rem1 = i % 9 NEW_LINE if ( rem1 == K ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT L = 10 NEW_LINE R = 22 NEW_LINE K = 3 NEW_LINE print ( countNumbers ( L , R , K ) ) NEW_LINE"],"bleu":0.6920910844726705,"rouge_l":0.8021963123644251}
{"id":1606,"predictions":["def SieveOfEratosthenes ( n , prime ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE prime [ 0 ] = False NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if p * p > n : NEW_LINE INDENT break NEW_LINE DEDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT prime = [ True ] * ( n + 1 ) NEW_LINE primes = 0 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for j in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def countDivisors ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT prime = [ False ] * ( n + 1 ) NEW_LINE primes = [ False ] * ( n + 1 ) NEW_LINE prime = [ True ] * ( n + 1 ) NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT def countDivisors ( n , prime ) : NEW_LINE INDENT if ( n % a ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 0 NEW_LINE prime = [ True ] * n NEW_LINE primes = [ False ] * ( n + 1 ) NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT for i in"],"references":["def SieveOfEratosthenes ( n , prime , primesquare , a ) : NEW_LINE INDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT prime [ i ] = True NEW_LINE DEDENT for i in range ( ( n * n + 1 ) + 1 ) : NEW_LINE INDENT primesquare [ i ] = False NEW_LINE DEDENT prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT i = p * 2 NEW_LINE while ( i <= n ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE i += p NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT j = 0 NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT a [ j ] = p NEW_LINE primesquare [ p * p ] = True NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT def countDivisors ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT prime = [ False ] * ( n + 2 ) NEW_LINE primesquare = [ False ] * ( n * n + 2 ) NEW_LINE a = [ 0 ] * n NEW_LINE SieveOfEratosthenes ( n , prime , primesquare , a ) NEW_LINE ans = 1 NEW_LINE i = 0 NEW_LINE while ( 1 ) : NEW_LINE INDENT if ( a [ i ] * a [ i ] * a [ i ] > n ) : NEW_LINE INDENT break NEW_LINE DEDENT cnt = 1 NEW_LINE while ( n % a [ i ] == 0 ) : NEW_LINE INDENT n = n \/ a [ i ] NEW_LINE cnt = cnt + 1 NEW_LINE DEDENT ans = ans * cnt NEW_LINE i += 1 NEW_LINE DEDENT n = int ( n ) NEW_LINE if ( prime [ n ] == True ) : NEW_LINE INDENT ans = ans * 2 NEW_LINE DEDENT elif ( primesquare [ n ] == True ) : NEW_LINE INDENT ans = ans * 3 NEW_LINE DEDENT elif ( n != 1 ) : NEW_LINE INDENT ans = ans * 4 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( \" Total ▁ distinct ▁ divisors ▁ of ▁ 100 ▁ are ▁ : \" , countDivisors ( 100 ) ) NEW_LINE DEDENT"],"bleu":0.4617702935934545,"rouge_l":0.5282566270938364}
{"id":1607,"predictions":["def subArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT k = i NEW_LINE for k in range ( i , n ) : NEW_LINE INDENT print ( arr [ k ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE subArray ( arr , n ) NEW_LINE"],"references":["def subArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT for k in range ( i , j + 1 ) : NEW_LINE INDENT print ( arr [ k ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( \" \\n \" , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" All ▁ Non - empty ▁ Subarrays \" ) NEW_LINE subArray ( arr , n ) ; NEW_LINE"],"bleu":0.6717707424711052,"rouge_l":0.8104764813683568}
{"id":1608,"predictions":["def findCull ( n ) : NEW_LINE INDENT return ( 1 << n ) * n + 1 NEW_LINE DEDENT n = 2 NEW_LINE print ( findCull ( n ) ) NEW_LINE"],"references":["def findCullen ( n ) : NEW_LINE INDENT return ( 1 << n ) * n + 1 NEW_LINE DEDENT n = 2 NEW_LINE print ( findCullen ( n ) ) NEW_LINE"],"bleu":0.8617660129625551,"rouge_l":0.9375000000000001}
{"id":1609,"predictions":["def printProbability ( L , N ) : NEW_LINE INDENT p = ( 1 << ( n - 1 ) ) \/ ( float ( L ) ) ; NEW_LINE return 1.0 - ( float ( p ) ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 ; NEW_LINE L = 5 ; NEW_LINE printProbability ( L , n ) ; NEW_LINE DEDENT"],"references":["def printProbability ( L , n ) : NEW_LINE INDENT p = ( 1 << ( n - 1 ) ) NEW_LINE return 1.0 - ( float ( n ) \/ float ( p ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE L = 5 NEW_LINE print ( printProbability ( L , n ) ) NEW_LINE DEDENT"],"bleu":0.6297980695775514,"rouge_l":0.8235697940503433}
{"id":1610,"predictions":["def firstWordWord ( str ) : NEW_LINE INDENT result = \" ▁ \" NEW_LINE v = True NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == ' ▁ ' and v == 1 ) : NEW_LINE INDENT result += str [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT result = result + str [ i ] NEW_LINE v = False NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT str = \" geeksforGeeks \" NEW_LINE print ( firstWord ( str ) , end = \" ▁ \" ) NEW_LINE"],"references":["def firstLetterWord ( str ) : NEW_LINE INDENT result = \" \" NEW_LINE v = True NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == ' ▁ ' ) : NEW_LINE INDENT v = True NEW_LINE DEDENT elif ( str [ i ] != ' ▁ ' and v == True ) : NEW_LINE INDENT result += ( str [ i ] ) NEW_LINE v = False NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeks ▁ for ▁ geeks \" NEW_LINE print ( firstLetterWord ( str ) ) NEW_LINE DEDENT"],"bleu":0.5574493294488544,"rouge_l":0.7050978067575578}
{"id":1611,"predictions":["def findNext ( number , i , j ) : NEW_LINE INDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( number [ i ] < number [ i - 1 ] ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( ( number [ i ] < number [ i - 1 ] ) and ( number [ i ] > number [ j ] ) ) : NEW_LINE INDENT return \" \" NEW_LINE DEDENT x = number [ i - 1 ] NEW_LINE j -= 1 NEW_LINE DEDENT x = number [ i - 1 ] NEW_LINE return x NEW_LINE DEDENT def reverse ( number , i , j ) : NEW_LINE INDENT if ( number [ i ] < number and number [ i ] > number [ j ] ) : NEW_LINE INDENT return \" Found \" NEW_LINE DEDENT number = number [ i - 1 ] NEW_LINE j = i NEW_LINE while ( j <= number [ i ] ) : NEW_LINE INDENT if number [ j ] < number [ j ] ) : NEW_LINE INDENT number [ j ] , number [ j ] = number [ j ] , number [ j + 1 ] NEW_LINE return number [ j ] , number [ i ] NEW_LINE DEDENT j -= 1 NEW_LINE DEDENT DEDENT DEDENT def reverse ( str1 , i , j ) : NEW_LINE INDENT temp = [ ] NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT temp = str [ i ] NEW_LINE str [ i ] = temp [ i ] NEW_LINE str [ i ] = temp [ j ] NEW_LINE return temp [ j ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \"262345\" NEW_LINE n = len ( str1 ) NEW_LINE findNext ( str1 , str2 ) NEW_LINE print ( \" Original ▁ number ▁ of ▁ numbers ▁ is \" , findNext ( str1 , n ) ) NEW_LINE DEDENT"],"references":["def findPrevious ( number , n ) : NEW_LINE INDENT number = list ( number ) NEW_LINE i , j = - 1 , - 1 NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT if number [ i ] < number [ i - 1 ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if i == 0 : NEW_LINE INDENT print ( \" Previous ▁ number ▁ is ▁ not ▁ possible \" ) NEW_LINE return NEW_LINE DEDENT x , greatest = number [ i - 1 ] , i NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if ( number [ j ] < x and number [ j ] > number [ greatest ] ) : NEW_LINE INDENT greatest = j NEW_LINE DEDENT DEDENT ( number [ greatest ] , number [ i - 1 ] ) = ( number [ i - 1 ] , number [ greatest ] ) NEW_LINE l = number [ i : ] NEW_LINE del number [ i : ] NEW_LINE l . sort ( reverse = True ) NEW_LINE number += l NEW_LINE number = ' ' . join ( number ) NEW_LINE print ( \" Greatest ▁ smaller ▁ number ▁ with \" , \" same ▁ set ▁ of ▁ digits ▁ is \" , number ) NEW_LINE return NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT digits = \"262345\" NEW_LINE n = len ( digits ) NEW_LINE findPrevious ( digits , n ) NEW_LINE DEDENT"],"bleu":0.3727443999688999,"rouge_l":0.5122162630695054}
{"id":1612,"predictions":["def countDecreasing ( A , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE len = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( A [ i + 1 ] < A [ i ] ) : NEW_LINE INDENT len += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if ( len > 1 ) : NEW_LINE INDENT cnt += ( ( len - 1 ) * len \/\/ 2 ) \/\/ 2 NEW_LINE len = 1 NEW_LINE DEDENT return int ( cnt ) NEW_LINE DEDENT A = [ 100 , 3 , 1 , 13 ] NEW_LINE n = len ( A ) NEW_LINE print ( countDecreasing ( A , n ) ) NEW_LINE"],"references":["def countDecreasing ( A , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE len = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( A [ i + 1 ] < A [ i ] ) : NEW_LINE INDENT len += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += ( ( ( len - 1 ) * len ) \/\/ 2 ) ; NEW_LINE len = 1 NEW_LINE DEDENT DEDENT if ( len > 1 ) : NEW_LINE INDENT cnt += ( ( ( len - 1 ) * len ) \/\/ 2 ) NEW_LINE DEDENT return cnt NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 100 , 3 , 1 , 13 ] NEW_LINE n = len ( A ) NEW_LINE print ( countDecreasing ( A , n ) ) NEW_LINE DEDENT"],"bleu":0.7504614210532858,"rouge_l":0.8370618081180813}
{"id":1613,"predictions":["def count ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return ( n * count ( n - 1 ) + ( n - 2 ) * count ( n - 2 ) ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 1 , 2 , 3 , 9 ] ; NEW_LINE n = 4 ; NEW_LINE print ( count ( n - 1 ) ) ; NEW_LINE DEDENT"],"references":["def count ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( n * count ( n - 1 ) ) + ( ( n - 1 ) * count ( n - 2 ) ) NEW_LINE DEDENT DEDENT A = [ 1 , 2 , 3 , 9 ] NEW_LINE print ( count ( len ( A ) - 1 ) ) NEW_LINE"],"bleu":0.5584357295627329,"rouge_l":0.8313982836951035}
{"id":1614,"predictions":["def splitArray ( A , length , pivot , size ) : NEW_LINE INDENT if ( A [ 0 ] > pivot ) : NEW_LINE INDENT return NEW_LINE DEDENT for i in range ( pivot , len ( A ) , len ( A [ i ] ) ) : NEW_LINE INDENT A [ i ] = A [ i ] NEW_LINE DEDENT DEDENT def splitAnd ( A , length , element ) : NEW_LINE INDENT for i in range ( rotation , length ) : NEW_LINE INDENT A [ i ] = A [ i - offset ] NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 12 , 10 , 5 , 6 , 36 ] NEW_LINE n = len ( arr ) NEW_LINE split = [ 0 ] * 10 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT"],"references":["def SplitAndAdd ( A , length , rotation ) : NEW_LINE INDENT tmp = [ 0 for i in range ( length * 2 ) ] NEW_LINE for i in range ( length ) : NEW_LINE INDENT tmp [ i ] = A [ i ] NEW_LINE tmp [ i + length ] = A [ i ] NEW_LINE DEDENT for i in range ( rotation , rotation + length , 1 ) : NEW_LINE INDENT A [ i - rotation ] = tmp [ i ] ; NEW_LINE DEDENT DEDENT arr = [ 12 , 10 , 5 , 6 , 52 , 36 ] NEW_LINE n = len ( arr ) NEW_LINE position = 2 NEW_LINE SplitAndAdd ( arr , n , position ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE"],"bleu":0.5216627233212461,"rouge_l":0.6497186495176848}
{"id":1615,"predictions":["def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def invDiv ( a , b ) : NEW_LINE INDENT n = gcd ( a , b ) NEW_LINE a = a \/\/ n NEW_LINE b = b \/\/ n NEW_LINE return ( a , b ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 10 NEW_LINE b = 15 NEW_LINE print ( \" A ▁ = ▁ \" , int ( makeDiv ( a , b ) ) ) NEW_LINE DEDENT"],"references":["def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def commDiv ( a , b ) : NEW_LINE INDENT n = gcd ( a , b ) NEW_LINE a = a \/\/ n NEW_LINE b = b \/\/ n NEW_LINE print ( \" A ▁ = \" , a , \" , ▁ B ▁ = \" , b ) NEW_LINE DEDENT a , b = 10 , 15 NEW_LINE commDiv ( a , b ) NEW_LINE"],"bleu":0.6846283749401287,"rouge_l":0.764014052237666}
{"id":1616,"predictions":["def narrowedSet ( n ) : NEW_LINE INDENT x = ( n & ( n >> 1 ) ) NEW_LINE if ( x & ( n >> 1 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE if ( qualSet ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def adjacentSet ( n ) : NEW_LINE INDENT return ( n & ( n >> 1 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE if ( adjacentSet ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.5886417711176669,"rouge_l":0.8009587328053356}
{"id":1617,"predictions":["def MinimumMoves ( a , n , x ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( a [ i ] <= a [ i - 1 ] ) : NEW_LINE INDENT p = ( a [ i - 1 ] - a [ i ] ) \/\/ x + 1 NEW_LINE ans += p * x NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 3 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE x = 2 NEW_LINE print ( MinimumMoves ( arr , n , x ) ) NEW_LINE"],"references":["def MinimumMoves ( a , n , x ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if a [ i ] <= a [ i - 1 ] : NEW_LINE INDENT p = ( a [ i - 1 ] - a [ i ] ) \/\/ x + 1 NEW_LINE ans += p NEW_LINE a [ i ] += p * x NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 3 , 3 , 2 ] NEW_LINE x = 2 NEW_LINE n = len ( arr ) NEW_LINE print ( MinimumMoves ( arr , n , x ) ) NEW_LINE DEDENT"],"bleu":0.7464508063814568,"rouge_l":0.8497187248861506}
{"id":1618,"predictions":["def avg_of_even_num ( n ) : NEW_LINE INDENT summ = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT summ += 2 * i NEW_LINE DEDENT return ( summ \/ n ) NEW_LINE DEDENT n = 9 NEW_LINE print ( avg_of_even_num ( n ) ) NEW_LINE"],"references":["def avg_of_even_num ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + 2 * i NEW_LINE DEDENT return sum \/ n NEW_LINE DEDENT n = 9 NEW_LINE print ( avg_of_even_num ( n ) ) NEW_LINE"],"bleu":0.7698963565173823,"rouge_l":0.8867924528301887}
{"id":1619,"predictions":["def findX ( A , B ) : NEW_LINE INDENT j , m = 0 , 0 NEW_LINE while ( A != 0 or B != 0 ) : NEW_LINE INDENT if ( ( A % 2 ) == 1 and ( B % 2 == 1 ) ) : NEW_LINE INDENT x += ( 1 << j ) NEW_LINE DEDENT A >>= 1 NEW_LINE B <<= 1 NEW_LINE DEDENT return x NEW_LINE DEDENT A = 2 NEW_LINE B = 3 NEW_LINE X = findX ( A , B ) NEW_LINE print ( \" X ▁ = \" , findX ( A , B ) ) NEW_LINE"],"references":["def findX ( A , B ) : NEW_LINE INDENT j = 0 NEW_LINE x = 0 NEW_LINE while ( A or B ) : NEW_LINE INDENT if ( ( A & 1 ) and ( B & 1 ) ) : NEW_LINE INDENT x += ( 1 << j ) NEW_LINE DEDENT A >>= 1 NEW_LINE B >>= 1 NEW_LINE j += 1 NEW_LINE DEDENT return x NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = 2 NEW_LINE B = 3 NEW_LINE X = findX ( A , B ) NEW_LINE print ( \" X ▁ = \" , X , \" , ▁ Sum ▁ = \" , ( A ^ X ) + ( B ^ X ) ) NEW_LINE DEDENT"],"bleu":0.5500598384624638,"rouge_l":0.7391948296755082}
{"id":1620,"predictions":["MAX = 10000 ; NEW_LINE factor = [ 0 ] * ( MAX ) ; NEW_LINE def cal_factor ( ) : NEW_LINE INDENT factor [ 1 ] = 1 ; NEW_LINE for i in range ( 2 , MAX , 2 ) : NEW_LINE INDENT factor [ i ] = i ; NEW_LINE DEDENT for i in range ( 4 , MAX , 2 ) : NEW_LINE INDENT factor [ i ] = 2 ; NEW_LINE DEDENT i = 3 ; NEW_LINE while ( i * i < MAX ) : NEW_LINE INDENT if ( factor [ i ] == i ) : NEW_LINE INDENT for j in range ( i * i , MAX , i ) : NEW_LINE INDENT if ( factor [ j ] == j ) : NEW_LINE INDENT factor [ j ] = i ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def no_of_factor ( a , n ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( factor [ a [ i ] ] != 1 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT cal_factor ( a , n ) ; NEW_LINE DEDENT cal_factor ( a , 4 ) ; NEW_LINE n = len ( a ) ; NEW_LINE print ( no_factor ( a , n ) ) ; NEW_LINE DEDENT"],"references":["MAX = 1000001 NEW_LINE factor = [ 0 ] * MAX NEW_LINE def cal_factor ( ) : NEW_LINE INDENT factor [ 1 ] = 1 NEW_LINE for i in range ( 2 , MAX ) : NEW_LINE INDENT factor [ i ] = i NEW_LINE DEDENT for i in range ( 4 , MAX , 2 ) : NEW_LINE INDENT factor [ i ] = 2 NEW_LINE DEDENT i = 3 NEW_LINE while i * i < MAX : NEW_LINE INDENT if ( factor [ i ] == i ) : NEW_LINE INDENT for j in range ( i * i , MAX , i ) : NEW_LINE INDENT if ( factor [ j ] == j ) : NEW_LINE INDENT factor [ j ] = i NEW_LINE DEDENT DEDENT DEDENT i += 1 NEW_LINE DEDENT DEDENT def no_of_representations ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp = a [ i ] NEW_LINE flag = 0 NEW_LINE while ( factor [ temp ] != 1 ) : NEW_LINE INDENT flag = - 1 NEW_LINE count += 1 NEW_LINE temp = temp \/\/ factor [ temp ] NEW_LINE DEDENT count += flag NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT cal_factor ( ) NEW_LINE a = [ 4 , 4 , 4 ] NEW_LINE n = len ( a ) NEW_LINE print ( no_of_representations ( a , n ) ) NEW_LINE DEDENT"],"bleu":0.6924325583634612,"rouge_l":0.8404669260700389}
{"id":1621,"predictions":["def maxSumPair ( arr1 , arr2 , n ) : NEW_LINE INDENT max1 = - 2147483647 NEW_LINE max2 = - 2147483648 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr1 [ i ] > max1 ) : NEW_LINE INDENT max1 = arr1 [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( arr2 [ i ] > max2 ) : NEW_LINE INDENT max2 = arr2 [ i ] NEW_LINE DEDENT DEDENT return max1 + max2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr1 = [ 10 , 2 , 3 ] NEW_LINE arr2 = [ 3 , 4 , 7 ] NEW_LINE n = len ( arr1 ) NEW_LINE print ( maxSumPair ( arr1 , arr2 , n ) ) NEW_LINE DEDENT"],"references":["import sys NEW_LINE def maxSumPair ( arr1 , n1 , arr2 , n2 ) : NEW_LINE INDENT max1 = - sys . maxsize - 1 NEW_LINE max2 = - sys . maxsize - 1 NEW_LINE for i in range ( 0 , n1 ) : NEW_LINE INDENT if ( arr1 [ i ] > max1 ) : NEW_LINE INDENT max1 = arr1 [ i ] NEW_LINE DEDENT DEDENT for i in range ( 0 , n2 ) : NEW_LINE INDENT if ( arr2 [ i ] > max2 ) : NEW_LINE INDENT max2 = arr2 [ i ] NEW_LINE DEDENT DEDENT return max1 + max2 NEW_LINE DEDENT arr1 = [ 10 , 2 , 3 ] NEW_LINE arr2 = [ 3 , 4 , 7 ] NEW_LINE n1 = len ( arr1 ) NEW_LINE n2 = len ( arr2 ) NEW_LINE print ( maxSumPair ( arr1 , n1 , arr2 , n2 ) ) NEW_LINE"],"bleu":0.6923178028028366,"rouge_l":0.8128891316220643}
{"id":1622,"predictions":["def remainder ( num ) : NEW_LINE INDENT l = len ( num ) NEW_LINE rem = 0 NEW_LINE rem = 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT rem = num * 10 + ( ord ( num [ i ] ) - ord ( '0' ) ) NEW_LINE rem = num % 10 NEW_LINE if rem == num : NEW_LINE INDENT rem = rem \/\/ 10 NEW_LINE DEDENT else : NEW_LINE INDENT rem = num % 10 NEW_LINE DEDENT DEDENT return rem NEW_LINE DEDENT st = list ( st ) NEW_LINE print ( remainder ( st ) ) NEW_LINE"],"references":["def remainder ( st ) : NEW_LINE INDENT ln = len ( st ) NEW_LINE rem = 0 NEW_LINE for i in range ( 0 , ln ) : NEW_LINE INDENT num = rem * 10 + ( int ) ( st [ i ] ) NEW_LINE rem = num % 11 NEW_LINE DEDENT return rem NEW_LINE DEDENT st = \"3435346456547566345436457867978\" NEW_LINE print ( remainder ( st ) ) NEW_LINE"],"bleu":0.40576356406979297,"rouge_l":0.6758017492711371}
{"id":1623,"predictions":["def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT def random ( m , n ) : NEW_LINE INDENT arr = [ 0 ] * m NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT arr [ i ] = arr [ i ] * m NEW_LINE DEDENT printArr ( arr , m ) NEW_LINE DEDENT m = 4 NEW_LINE n = 8 NEW_LINE random ( m , n ) NEW_LINE"],"references":["from random import randint NEW_LINE def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT def randomList ( m , n ) : NEW_LINE INDENT arr = [ 0 ] * m ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ randint ( 0 , n ) % m ] += 1 ; NEW_LINE DEDENT printArr ( arr , m ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT m = 4 ; n = 8 ; NEW_LINE randomList ( m , n ) ; NEW_LINE DEDENT"],"bleu":0.5660953964906994,"rouge_l":0.7517308224868456}
{"id":1624,"predictions":["from math import sqrt NEW_LINE N = 100005 NEW_LINE def SieveOfEratosthenes ( prime , p_size ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( sqrt ( p_size ) ) + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( 2 * p , p_size , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def longestPrimeSubsequence ( arr , n ) : NEW_LINE INDENT prime = [ True ] * ( N + 1 ) NEW_LINE SieveOfEratosthenes ( prime , N ) NEW_LINE answer = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 4 , 11 , 2 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE print ( longestPrimeSubsequence ( arr , n ) ) NEW_LINE DEDENT"],"references":["N = 100005 NEW_LINE def SieveOfEratosthenes ( prime , p_size ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= p_size : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( p * 2 , p_size + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT def longestPrimeSubsequence ( arr , n ) : NEW_LINE INDENT prime = [ True ] * ( N + 1 ) NEW_LINE SieveOfEratosthenes ( prime , N ) NEW_LINE answer = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 4 , 11 , 2 , 9 , 21 ] NEW_LINE n = len ( arr ) NEW_LINE print ( longestPrimeSubsequence ( arr , n ) ) NEW_LINE DEDENT"],"bleu":0.8281475393211839,"rouge_l":0.8960963934967402}
{"id":1625,"predictions":["def catalanonnumber ( n ) : NEW_LINE INDENT res = 0 NEW_LINE if ( n <= 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT res += ( catalan ( i - 1 ) * catalan ( n - i ) ) NEW_LINE DEDENT return res NEW_LINE DEDENT def catalanalan ( n ) : NEW_LINE INDENT cen = catalan ( n ) NEW_LINE for i in range ( 0 , 10 ) : NEW_LINE INDENT res += catalan ( i ) * catalan ( i - i - 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE print ( catalanonnumber ( n ) ) NEW_LINE DEDENT"],"references":["def catalan ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res += catalan ( i ) * catalan ( n - i - 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT print catalan ( i ) , NEW_LINE DEDENT"],"bleu":0.42002560027154434,"rouge_l":0.6467519353752945}
{"id":1626,"predictions":["def smallestIndex ( a , n ) : NEW_LINE INDENT right0 = 0 NEW_LINE right1 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 1 ) : NEW_LINE INDENT right1 = i NEW_LINE DEDENT else : NEW_LINE INDENT right0 = i NEW_LINE DEDENT else : NEW_LINE INDENT right0 = i NEW_LINE DEDENT DEDENT return min ( right1 , right0 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 0 ] NEW_LINE n = len ( a ) NEW_LINE print ( smallestIndex ( a , n ) ) NEW_LINE DEDENT"],"references":["def smallestIndex ( a , n ) : NEW_LINE INDENT right1 = 0 NEW_LINE right0 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 1 ) : NEW_LINE INDENT right1 = i NEW_LINE DEDENT else : NEW_LINE INDENT right0 = i NEW_LINE DEDENT DEDENT return min ( right1 , right0 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( smallestIndex ( a , n ) ) NEW_LINE DEDENT"],"bleu":0.8837787083481545,"rouge_l":0.9445802770986146}
{"id":1627,"predictions":["def polygonArea ( X , Y , n ) : NEW_LINE INDENT area = 0.0 NEW_LINE j = n - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) NEW_LINE j = i NEW_LINE DEDENT return area NEW_LINE DEDENT X = [ 0.0 , 4 ] NEW_LINE Y = [ 1 , 3 ] NEW_LINE n = len ( X ) NEW_LINE print ( polygonArea ( X , Y , n ) ) NEW_LINE"],"references":["def polygonArea ( X , Y , n ) : NEW_LINE INDENT area = 0.0 NEW_LINE j = n - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT area = area + ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) NEW_LINE j = i NEW_LINE DEDENT return abs ( area \/\/ 2.0 ) NEW_LINE DEDENT X = [ 0 , 2 , 4 ] NEW_LINE Y = [ 1 , 3 , 7 ] NEW_LINE n = len ( X ) NEW_LINE print ( polygonArea ( X , Y , n ) ) NEW_LINE"],"bleu":0.8220136091961852,"rouge_l":0.9231454005934718}
{"id":1628,"predictions":["PI = 3 NEW_LINE def areaIncircle ( a ) : NEW_LINE INDENT return ( PI \/ 4 ) * a * a NEW_LINE DEDENT def areaOfIncribed ( a ) : NEW_LINE INDENT return ( PI \/ 4 ) * a NEW_LINE DEDENT a = 8 NEW_LINE print ( \" Area ▁ of ▁ inscribed ▁ circle ▁ : % ▁ d \" % areaOfIncribed ( a ) ) NEW_LINE"],"references":["PI = 3.14 NEW_LINE def areaOfInscribedCircle ( a ) : NEW_LINE INDENT return ( PI \/ 4 ) * a * a NEW_LINE DEDENT a = 8 NEW_LINE print ( \" Area ▁ of ▁ an ▁ inscribed ▁ circle : \" , round ( areaOfInscribedCircle ( a ) , 2 ) ) NEW_LINE"],"bleu":0.5192956139750385,"rouge_l":0.7149086944671572}
{"id":1629,"predictions":["def divisorSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT if i * j > j : NEW_LINE INDENT break NEW_LINE DEDENT if ( i % j == 0 ) : NEW_LINE INDENT sum += j NEW_LINE DEDENT else : NEW_LINE INDENT sum += j + i \/\/ j NEW_LINE DEDENT DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE print ( divisorSum ( n ) ) NEW_LINE DEDENT"],"references":["def divisorSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT j = 1 NEW_LINE while j * j <= i : NEW_LINE INDENT if i % j == 0 : NEW_LINE INDENT if i \/ j == j : NEW_LINE INDENT sum += j NEW_LINE DEDENT else : NEW_LINE INDENT sum += j + i \/ j NEW_LINE DEDENT DEDENT j = j + 1 NEW_LINE DEDENT DEDENT return int ( sum ) NEW_LINE DEDENT n = 4 NEW_LINE print ( divisorSum ( n ) ) NEW_LINE n = 5 NEW_LINE print ( divisorSum ( n ) ) NEW_LINE"],"bleu":0.6034076391653065,"rouge_l":0.700646087580761}
{"id":1630,"predictions":["MAX = 32 NEW_LINE def countSetBits ( n , k ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT n &= ( n - 1 ) NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def pairs ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE f = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT f [ count ] += 1 NEW_LINE DEDENT for i in range ( 0 , MAX + 1 ) : NEW_LINE INDENT for j in range ( i , MAX + 1 ) : NEW_LINE INDENT if ( i + j == k ) : NEW_LINE INDENT if ( i + j == k ) : NEW_LINE INDENT count += ( f [ i ] * ( f [ j ] - 1 ) \/ 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT count += ( f [ i ] * f [ j ] ) \/\/ 2 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE k = 4 NEW_LINE print ( pairs ( arr , n , k ) ) NEW_LINE DEDENT"],"references":["MAX = 32 NEW_LINE def countSetBits ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( n ) : NEW_LINE INDENT n &= ( n - 1 ) ; NEW_LINE count += 1 ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT def pairs ( arr , n , k ) : NEW_LINE INDENT count = 0 ; NEW_LINE f = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT f [ countSetBits ( arr [ i ] ) ] += 1 ; NEW_LINE DEDENT for i in range ( MAX + 1 ) : NEW_LINE INDENT for j in range ( 1 , MAX + 1 ) : NEW_LINE INDENT if ( i + j == k ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT count += ( ( f [ i ] * ( f [ i ] - 1 ) ) \/ 2 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT count += ( f [ i ] * f [ j ] ) ; NEW_LINE DEDENT DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE k = 4 NEW_LINE print ( pairs ( arr , n , k ) ) NEW_LINE"],"bleu":0.7808898176461759,"rouge_l":0.9031747124853662}
{"id":1631,"predictions":["def isPalindrome ( num ) : NEW_LINE INDENT if ( num >= 0 and int ( num < 10 ) and int ( num \/ 10 ) ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT def isPalindrome ( num ) : NEW_LINE INDENT if ( num == 0 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT def isPalindrome ( num ) : NEW_LINE INDENT if ( num % 10 == dup ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT else : NEW_LINE INDENT return isPalindrome ( num \/ 10 , dup ) ; NEW_LINE DEDENT DEDENT return isPalindrome ( num ) ; NEW_LINE DEDENT def isPalindrome ( n ) : NEW_LINE INDENT if ( isPalindrome ( n ) ) : NEW_LINE INDENT return ; NEW_LINE DEDENT return ( isPalindrome ( num ) ; NEW_LINE DEDENT if ( isPalindrome ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT"],"references":["def oneDigit ( num ) : NEW_LINE INDENT return ( ( num >= 0 ) and ( num < 10 ) ) ; NEW_LINE DEDENT def isPalUtil ( num , dupNum ) : NEW_LINE INDENT if ( oneDigit ( num ) ) : NEW_LINE INDENT return ( num == ( dupNum ) % 10 ) ; NEW_LINE DEDENT if ( isPalUtil ( int ( num \/ 10 ) , dupNum ) == False ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT dupNum = int ( dupNum \/ 10 ) ; NEW_LINE return ( num % 10 == ( dupNum ) % 10 ) ; NEW_LINE DEDENT def isPal ( num ) : NEW_LINE INDENT if ( num < 0 ) : NEW_LINE INDENT num = ( - num ) ; NEW_LINE DEDENT dupNum = ( num ) ; NEW_LINE return isPalUtil ( num , dupNum ) ; NEW_LINE DEDENT n = 12321 ; NEW_LINE if ( isPal ( n ) == 0 ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT n = 12 ; NEW_LINE if ( isPal ( n ) == 0 ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT n = 88 ; NEW_LINE if ( isPal ( n ) == 1 ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT n = 8999 ; NEW_LINE if ( isPal ( n ) == 0 ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT"],"bleu":0.3332667892636828,"rouge_l":0.5211365649917732}
{"id":1632,"predictions":["def isSumDivides ( N ) : NEW_LINE INDENT temp = N NEW_LINE sum = 0 NEW_LINE while ( temp ) : NEW_LINE INDENT sum += temp % 10 NEW_LINE temp \/\/= 10 NEW_LINE DEDENT if ( N % sum == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 12 NEW_LINE if ( isSumDivides ( N ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"references":["def isSumDivides ( N ) : NEW_LINE INDENT temp = N NEW_LINE sum = 0 NEW_LINE while ( temp ) : NEW_LINE INDENT sum += temp % 10 NEW_LINE temp = int ( temp \/ 10 ) NEW_LINE DEDENT if ( N % sum == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 12 NEW_LINE if ( isSumDivides ( N ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.8317337218951744,"rouge_l":0.9270237736984652}
{"id":1633,"predictions":["def nextZero ( i ) : NEW_LINE INDENT while ( i < len ( uniqueness ) ) : NEW_LINE INDENT if ( uniqueness [ i ] == 0 ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT return - 1 ; NEW_LINE DEDENT def getNum ( str ) : NEW_LINE INDENT n = len ( str ) ; NEW_LINE occurrences = [ 0 ] * 26 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT occurrences [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT occurrences [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE frequency [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( occurrences [ i ] - ord ( ' a ' ) ] > frequencyZero [ index ] ) : NEW_LINE INDENT frequency [ ord ( str [ i ] ) ] -= 1 ; NEW_LINE frequency [ ord ( str [ i ] ) ] -= 1 ; NEW_LINE DEDENT DEDENT DEDENT return str ; NEW_LINE DEDENT str = \" geeksforgeeks \" ; NEW_LINE print ( getNum ( str ) ) ; NEW_LINE"],"references":["def nextZero ( i , occurrences ) : NEW_LINE INDENT while i < 26 : NEW_LINE INDENT if occurrences [ i ] == 0 : NEW_LINE INDENT return i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT def getModifiedString ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE if n > 26 : NEW_LINE INDENT return \" - 1\" NEW_LINE DEDENT ch = str NEW_LINE ch = list ( ch ) NEW_LINE occurrences = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT occurrences [ ord ( ch [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT index = nextZero ( 0 , occurrences ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if occurrences [ ord ( ch [ i ] ) - ord ( ' a ' ) ] > 1 : NEW_LINE INDENT occurrences [ ord ( ch [ i ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE ch [ i ] = chr ( ord ( ' a ' ) + index ) NEW_LINE occurrences [ index ] = 1 NEW_LINE index = nextZero ( index + 1 , occurrences ) NEW_LINE DEDENT DEDENT ch = ' ' . join ( ch ) NEW_LINE print ( ch ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeksforgeeks \" NEW_LINE getModifiedString ( str ) NEW_LINE DEDENT"],"bleu":0.4988138503995168,"rouge_l":0.6604642116182573}
{"id":1634,"predictions":["def calculateCycosations ( arr , n ) : NEW_LINE INDENT trace_operations = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT len_operations += 1 NEW_LINE n = int ( n \/ 3 ) NEW_LINE DEDENT return - 1 NEW_LINE DEDENT def minimumOperations ( p , n ) : NEW_LINE INDENT visited = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( visited [ i ] == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT visited [ i ] = 1 NEW_LINE length = 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( visited [ i ] == 0 ) : NEW_LINE INDENT visited [ i ] = 1 NEW_LINE length += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT P = - 1 NEW_LINE n = len ( P ) NEW_LINE print ( minimumCycosations ( P , n ) ) NEW_LINE DEDENT"],"references":["def calculateCycleOperations ( length ) : NEW_LINE INDENT cycle_operations = 0 NEW_LINE while length > 0 : NEW_LINE INDENT length \/\/= 3 NEW_LINE cycle_operations += 1 NEW_LINE DEDENT return cycle_operations - 1 NEW_LINE DEDENT def minimumOperations ( p , n ) : NEW_LINE INDENT visited = [ 0 ] * ( n + 1 ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ele = p [ i ] NEW_LINE if not visited [ ele ] : NEW_LINE INDENT visited [ ele ] = 1 NEW_LINE length = 1 NEW_LINE ele = p [ ele ] NEW_LINE while not visited [ ele ] : NEW_LINE INDENT visited [ ele ] = 1 NEW_LINE length += 1 NEW_LINE ele = p [ ele ] NEW_LINE DEDENT operations = calculateCycleOperations ( length ) NEW_LINE num = pow ( 3 , operations ) NEW_LINE if num != length : NEW_LINE INDENT return - 1 NEW_LINE DEDENT ans = max ( ans , operations ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT P = [ - 1 , 4 , 6 , 5 , 3 , 2 , 7 , 8 , 9 , 1 ] NEW_LINE n = len ( P ) - 1 NEW_LINE print ( minimumOperations ( P , n ) ) NEW_LINE DEDENT"],"bleu":0.48372835412460524,"rouge_l":0.6210975518454742}
{"id":1635,"predictions":["R = 3.14159265 NEW_LINE def Volume ( rr ) : NEW_LINE INDENT R = 3.14159265 NEW_LINE pi = 2.14159265 NEW_LINE R = 2.14159265 NEW_LINE PI = 2.14159265 NEW_LINE R = 2.14 * pi NEW_LINE Area = 2.14 * R NEW_LINE Volume = 2.14 * R * R NEW_LINE print ( \" Volume : ▁ \" , R ) NEW_LINE print ( \" Area ▁ : \" , \" \\n : ▁ \" , R ) NEW_LINE print ( \" Volume : ▁ \" , \" \\n \" , R ) NEW_LINE DEDENT"],"references":["r = 3 NEW_LINE R = 7 NEW_LINE pi = 3.14159 NEW_LINE Volume = ( float ) ( 2 * pi * pi * R * r * r ) ; NEW_LINE print ( \" Volume : ▁ \" , Volume ) ; NEW_LINE Surface = ( float ) ( 4 * pi * pi * R * r ) ; NEW_LINE print ( \" Surface : ▁ \" , Surface ) ; NEW_LINE"],"bleu":0.2192754869962755,"rouge_l":0.47925060435132955}
{"id":1636,"predictions":["def numberOfPaths ( m , n ) : NEW_LINE INDENT dp = [ 0 for i in range ( n ) ] NEW_LINE dp [ 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT dp [ i ] += dp [ j - 1 ] NEW_LINE DEDENT DEDENT return dp [ n - 1 ] NEW_LINE DEDENT m = 3 NEW_LINE print ( numberOfPaths ( m , 3 ) ) NEW_LINE"],"references":["def numberOfPaths ( p , q ) : NEW_LINE INDENT dp = [ 1 for i in range ( q ) ] NEW_LINE for i in range ( p - 1 ) : NEW_LINE INDENT for j in range ( 1 , q ) : NEW_LINE INDENT dp [ j ] += dp [ j - 1 ] NEW_LINE DEDENT DEDENT return dp [ q - 1 ] NEW_LINE DEDENT print ( numberOfPaths ( 3 , 3 ) ) NEW_LINE"],"bleu":0.5820628313081551,"rouge_l":0.8085064292779425}
{"id":1637,"predictions":["def alternate ( a , b , x ) : NEW_LINE INDENT return ( a ^ b ^ x ) NEW_LINE DEDENT a = - 10 NEW_LINE b = 15 NEW_LINE x = awhile ( a , b , x ) NEW_LINE print ( \" x ▁ after ▁ access : \" , x ) NEW_LINE"],"references":["def alternate ( a , b , x ) : NEW_LINE INDENT x = a ^ b ^ x NEW_LINE print ( \" After ▁ exchange \" ) NEW_LINE print ( \" x ▁ is \" , x ) NEW_LINE DEDENT a = - 10 NEW_LINE b = 15 NEW_LINE x = a NEW_LINE print ( \" x ▁ is \" , x ) NEW_LINE alternate ( a , b , x ) NEW_LINE"],"bleu":0.5624757211674162,"rouge_l":0.6454232283464567}
{"id":1638,"predictions":["from math import sqrt NEW_LINE def surface_area ( side ) : NEW_LINE INDENT return ( 2 * ( sqrt ( 3 ) ) * ( side * side ) ) NEW_LINE DEDENT side = 7 NEW_LINE print ( \" surface ▁ of ▁ octecahedron ▁ = \" , surface_area ( side ) ) NEW_LINE"],"references":["import math NEW_LINE def surface_area_octahedron ( side ) : NEW_LINE INDENT return ( 2 * ( math . sqrt ( 3 ) ) * ( side * side ) ) NEW_LINE DEDENT side = 7 NEW_LINE print ( \" Surface ▁ area ▁ of ▁ octahedron ▁ = \" , surface_area_octahedron ( side ) ) NEW_LINE"],"bleu":0.6865914841053347,"rouge_l":0.8517528223410576}
{"id":1639,"predictions":["def CenteredDict_num ( n ) : NEW_LINE INDENT return ( 2 * n + 1 ) * ( 5 * n * n + 5 * n + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE print ( \" Centered ▁ Centered ▁ CenteredDict ▁ pair ▁ \" , Centered_num ( n ) ) NEW_LINE"],"references":["def CenteredDodecahedral_num ( n ) : NEW_LINE INDENT return ( 2 * n + 1 ) * ( 5 * n * n + 5 * n + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE print ( n , \" rd ▁ centered ▁ dodecahedral ▁ number : ▁ \" , CenteredDodecahedral_num ( n ) ) NEW_LINE n = 10 NEW_LINE print ( n , \" th ▁ centered ▁ dodecahedral ▁ number ▁ : ▁ \" , CenteredDodecahedral_num ( n ) ) NEW_LINE DEDENT"],"bleu":0.5119697367192181,"rouge_l":0.7184650455927053}
{"id":1640,"predictions":["def longestSubstring ( s ) : NEW_LINE INDENT cnt = 1 NEW_LINE maxi = 1 NEW_LINE n = len ( s ) NEW_LINE maxi = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] != s [ i - 1 ] ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE DEDENT else : NEW_LINE INDENT maxi = max ( cnt , maxi ) NEW_LINE cnt = 1 NEW_LINE DEDENT DEDENT return maxi NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" ccbbcde \" NEW_LINE print ( longestSubstring ( s ) ) NEW_LINE DEDENT"],"references":["def longestSubstring ( s ) : NEW_LINE INDENT cnt = 1 ; NEW_LINE maxi = 1 ; NEW_LINE n = len ( s ) ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] != s [ i - 1 ] ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT maxi = max ( cnt , maxi ) ; NEW_LINE cnt = 1 ; NEW_LINE DEDENT DEDENT maxi = max ( cnt , maxi ) ; NEW_LINE return maxi ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" ccccdeededff \" ; NEW_LINE print ( longestSubstring ( s ) ) ; NEW_LINE DEDENT"],"bleu":0.705244162788282,"rouge_l":0.8711937483158178}
{"id":1641,"predictions":["def firstDigit ( x ) : NEW_LINE INDENT while ( x >= 10 ) : NEW_LINE INDENT x = int ( x \/ 10 ) ; NEW_LINE DEDENT return x ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = 45 ; NEW_LINE print ( firstDigit ( 45 ) ) ; NEW_LINE print ( firstDigit ( x ) ) ; NEW_LINE DEDENT"],"references":["def firstDigit ( x ) : NEW_LINE INDENT while ( x >= 10 ) : NEW_LINE INDENT x = x \/\/ 10 NEW_LINE DEDENT return x NEW_LINE DEDENT print ( firstDigit ( 12345 ) ) NEW_LINE print ( firstDigit ( 5432 ) ) NEW_LINE"],"bleu":0.4170720099762984,"rouge_l":0.7501499700059989}
{"id":1642,"predictions":["MAX = 1000 NEW_LINE def binomialCoeff ( n , z ) : NEW_LINE INDENT for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT def numberOfWays ( x , y , z ) : NEW_LINE INDENT binomialCoeff ( x , y , z ) ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( 1 , z + 1 ) : NEW_LINE INDENT sum = ( sum + C [ i ] [ i ] * C [ i ] [ z ] ) ; NEW_LINE DEDENT for i in range ( 1 , y + 1 ) : NEW_LINE INDENT sum1 = ( sum1 + ( C [ i ] [ z ] * C [ x ] [ y ] ) ) ; NEW_LINE sum1 = 0 ; NEW_LINE DEDENT return sum1 ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = 3 ; NEW_LINE y = 2 ; NEW_LINE z = 1 ; NEW_LINE print ( numberOfWays ( x , y , z ) ) ; NEW_LINE DEDENT"],"references":["C = [ [ 0 for i in range ( 1000 ) ] for i in range ( 1000 ) ] NEW_LINE def binomialCoeff ( n ) : NEW_LINE INDENT i , j = 0 , 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] +   \\ NEW_LINE INDENT C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def numberOfWays ( x , y , z ) : NEW_LINE INDENT binomialCoeff ( max ( x , max ( y , z ) ) ) NEW_LINE sum = 0 NEW_LINE for i in range ( 1 , z + 1 ) : NEW_LINE INDENT sum = ( sum + C [ z ] [ i ] ) NEW_LINE DEDENT sum1 = 0 NEW_LINE for i in range ( 1 , y + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , x + 1 ) : NEW_LINE INDENT sum1 = ( sum1 + ( C [ y ] [ i ] * C [ x ] [ j ] ) ) NEW_LINE DEDENT DEDENT sum1 = ( sum * sum1 ) NEW_LINE return sum1 NEW_LINE DEDENT x = 3 NEW_LINE y = 2 NEW_LINE z = 1 NEW_LINE print ( numberOfWays ( x , y , z ) ) NEW_LINE"],"bleu":0.6600571474076223,"rouge_l":0.7830364105332613}
{"id":1643,"predictions":["def isDivisible ( n ) : NEW_LINE INDENT while n \/\/ 100 : NEW_LINE INDENT d = n % 10 NEW_LINE n \/\/= 10 NEW_LINE n = abs ( n - ( d * 14 ) ) NEW_LINE DEDENT return ( n % 475 == 0 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 59181 NEW_LINE if ( isDivisible ( N ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"references":["def isDivisible ( n ) : NEW_LINE INDENT while n \/\/ 100 : NEW_LINE INDENT d = n % 10 NEW_LINE n \/\/= 10 NEW_LINE n = abs ( n - ( d * 14 ) ) NEW_LINE DEDENT return ( n % 47 == 0 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 59173 NEW_LINE if ( isDivisible ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"],"bleu":0.9028327178566529,"rouge_l":0.9587628865979381}
{"id":1644,"predictions":["import eulerlib , fractions NEW_LINE def compute ( ) : NEW_LINE INDENT SIZE = 1001 NEW_LINE SIZE = 0 NEW_LINE for n in range ( 3 , SIZE + 1 , 2 ) : NEW_LINE INDENT sum = sum + 4 * n * n - 6 * ( n - 6 * n - 6 * ( n - 1 ) ) NEW_LINE return str ( sum ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["def compute ( ) : NEW_LINE INDENT SIZE = 1001 NEW_LINE ans = 1 NEW_LINE ans += sum ( 4 * i * i - 6 * ( i - 1 ) for i in range ( 3 , SIZE + 1 , 2 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.5706151992141789,"rouge_l":0.6709999999999999}
{"id":1645,"predictions":["import eulerlib , fractions NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 5 NEW_LINE ans = sum ( 1 for d in range ( LIMIT ) if d == eulerlib . sqrt ( LIMIT * 2 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def is_prime ( x ) : NEW_LINE INDENT if is_prime ( x ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT primes = eulerlib . sqrt ( LIMIT ) NEW_LINE sieve ( ) NEW_LINE def find_prime ( x ) : NEW_LINE INDENT if x < 0 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , LIMIT + 1 ) : NEW_LINE INDENT if isprime ( x ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 14 NEW_LINE ans = [ 0 ] NEW_LINE def find_harshad_primes ( n , digitsum , isstrong ) : NEW_LINE INDENT m = n * 10 NEW_LINE s = digitsum NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT if m >= LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT if isstrong and eulerlib . is_prime ( m ) : NEW_LINE INDENT ans [ 0 ] += m NEW_LINE DEDENT if m % s == 0 : NEW_LINE INDENT find_harshad_primes ( m , s , eulerlib . is_prime ( m \/\/ s ) ) NEW_LINE DEDENT m += 1 NEW_LINE s += 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , 10 ) : NEW_LINE INDENT find_harshad_primes ( i , i , False ) NEW_LINE DEDENT return str ( ans [ 0 ] ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.3818702384385736,"rouge_l":0.5109692859992022}
{"id":1646,"predictions":["def compute ( ) : NEW_LINE INDENT LENGTH = 50 NEW_LINE ways = [ 0 ] * ( LENGTH + 1 ) NEW_LINE for n in range ( 1 , 4 ) : NEW_LINE INDENT for k in range ( n + 1 ) : NEW_LINE INDENT ways [ n ] += ways [ k ] + 1 NEW_LINE DEDENT DEDENT return str ( ways [ - 1 ] ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["def compute ( ) : NEW_LINE INDENT LENGTH = 50 NEW_LINE ways = [ 1 ] + [ 0 ] * LENGTH NEW_LINE for n in range ( 1 , len ( ways ) ) : NEW_LINE INDENT ways [ n ] += sum ( ways [ max ( n - 4 , 0 ) : n ] ) NEW_LINE DEDENT return str ( ways [ - 1 ] ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.7070162741142144,"rouge_l":0.7849462365591398}
{"id":1647,"predictions":["def compute ( ) : NEW_LINE INDENT if i == 1 : NEW_LINE INDENT return x % m NEW_LINE DEDENT else : NEW_LINE INDENT return x NEW_LINE DEDENT DEDENT def compute ( ) : NEW_LINE INDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import eulerlib , sys NEW_LINE def compute ( ) : NEW_LINE INDENT x , y , m = 1777 , 1855 , 10 ** 8 NEW_LINE sys . setrecursionlimit ( y + 30 ) NEW_LINE ans = tetration_mod ( x , y , m ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def tetration_mod ( x , y , m ) : NEW_LINE INDENT if y == 1 : NEW_LINE INDENT return x % m NEW_LINE DEDENT else : NEW_LINE INDENT return pow ( x , tetration_mod ( x , y - 1 , totient ( m ) ) , m ) NEW_LINE DEDENT DEDENT def totient ( n ) : NEW_LINE INDENT assert n > 0 NEW_LINE p = 1 NEW_LINE i = 2 NEW_LINE end = eulerlib . sqrt ( n ) NEW_LINE while i <= end : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT p *= i - 1 NEW_LINE n \/\/= i NEW_LINE while n % i == 0 : NEW_LINE INDENT p *= i NEW_LINE n \/\/= i NEW_LINE DEDENT end = eulerlib . sqrt ( n ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if n != 1 : NEW_LINE INDENT p *= n - 1 NEW_LINE DEDENT return p NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.037941748281491425,"rouge_l":0.34064372017463695}
{"id":1648,"predictions":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT def factorial ( n ) : NEW_LINE INDENT return eulerlib . factorial ( n , 2 ) NEW_LINE DEDENT def factorials ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif n == 100000000 : NEW_LINE INDENT return factorial ( n , 5 ) NEW_LINE DEDENT return factorials ( n ) NEW_LINE DEDENT def factorialize ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif n == 2 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return factorial ( n ) * factorial ( n ) % 1000 NEW_LINE DEDENT def factorialorial ( n ) : NEW_LINE INDENT return factorial ( n \/\/ 2 ) * factorial ( n \/\/ 2 ) NEW_LINE DEDENT def factorialize ( n ) : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT return n NEW_LINE DEDENT else : NEW_LINE INDENT return factorial ( n \/\/ 2 ) * factorial ( n \/\/ 2 ) * factorial ( n \/\/ 2 + 1 ) * factorial ( n ) ) % 1000000007 NEW_LINE DEDENT DEDENT def factorial ( n ) : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return factorial ( n ) * factorial ( n \/\/ 2 + factorial ( n ) ) % 1000000007 NEW_LINE DEDENT DEDENT def factorial ( n ) : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT return n NEW_LINE DEDENT return int ( factorial ( n ) ) % 1000000007 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE print ( compute ( ) ) NEW_LINE DEDENT"],"references":["def compute ( ) : NEW_LINE INDENT ans = factorial_suffix ( 10 ** 12 ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def factorial_suffix ( n ) : NEW_LINE INDENT twos = count_factors ( n , 2 ) - count_factors ( n , 5 ) NEW_LINE if twos >= 2505 : NEW_LINE INDENT twos = ( twos - 5 ) % 2500 + 5 NEW_LINE DEDENT return factorialish ( n ) * pow ( 2 , twos , 100000 ) % 100000 NEW_LINE DEDENT def factorialish ( n ) : NEW_LINE INDENT return even_factorialish ( n ) * odd_factorialish ( n ) % 100000 NEW_LINE DEDENT def even_factorialish ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return factorialish ( n \/\/ 2 ) NEW_LINE DEDENT DEDENT def odd_factorialish ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return odd_factorialish ( n \/\/ 5 ) * factorial_coprime ( n ) % 100000 NEW_LINE DEDENT DEDENT def factorial_coprime ( n ) : NEW_LINE INDENT n %= 100000 NEW_LINE product = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if i % 2 != 0 and i % 5 != 0 : NEW_LINE INDENT product = i * product % 100000 NEW_LINE DEDENT DEDENT return product NEW_LINE DEDENT def count_factors ( end , n ) : NEW_LINE INDENT if end == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return end \/\/ n + count_factors ( end \/\/ n , n ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.49010333542452095,"rouge_l":0.5675646435140106}
{"id":1649,"predictions":["def compute ( ) : NEW_LINE INDENT ans = sum ( 1 for i in range ( 1 , 8 ) if e == g else 1 ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def compute ( ) : NEW_LINE INDENT a = 0 NEW_LINE b = num + e - d NEW_LINE c = 0 NEW_LINE if b < 0 : NEW_LINE INDENT continue NEW_LINE DEDENT if a < 0 : NEW_LINE INDENT continue NEW_LINE DEDENT e = a + b - c NEW_LINE d = b + c - d NEW_LINE if e < 0 or b > 9 : NEW_LINE INDENT continue NEW_LINE DEDENT e = a + c + d NEW_LINE if a < 0 : NEW_LINE INDENT continue NEW_LINE DEDENT if a < 0 or b > 9 : NEW_LINE INDENT continue NEW_LINE DEDENT if a < 0 : NEW_LINE INDENT continue NEW_LINE DEDENT if b < 0 : NEW_LINE INDENT continue NEW_LINE DEDENT if a < 0 : NEW_LINE INDENT continue NEW_LINE DEDENT if b < 0 or a > 9 : NEW_LINE INDENT continue NEW_LINE DEDENT if b < 0 : NEW_LINE INDENT continue NEW_LINE DEDENT c += 1 NEW_LINE DEDENT if a < 0 or b < 0 : NEW_LINE INDENT continue NEW_LINE DEDENT if a < 0 : NEW_LINE INDENT continue NEW_LINE DEDENT continue NEW_LINE DEDENT ans += 1 NEW_LINE DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["def compute ( ) : NEW_LINE INDENT ans = 0 NEW_LINE digits = tuple ( range ( 10 ) ) NEW_LINE for b in digits : NEW_LINE INDENT for c in digits : NEW_LINE INDENT for d in digits : NEW_LINE INDENT for e in digits : NEW_LINE INDENT for i in digits : NEW_LINE INDENT m = b + c + d - e - i NEW_LINE if m < 0 or m > 9 : continue NEW_LINE for k in digits : NEW_LINE INDENT f = b + c + d * 2 - e - i - k NEW_LINE if f < 0 or f > 9 : continue NEW_LINE for a in digits : NEW_LINE INDENT for g in digits : NEW_LINE INDENT o = a + b + d - g - k NEW_LINE if o < 0 or o > 9 : continue NEW_LINE j = a + b + c - g - m NEW_LINE if j < 0 or j > 9 : continue NEW_LINE l = a + b + c + d - i - j - k NEW_LINE if l < 0 or l > 9 : continue NEW_LINE h = a + b + c + d - e - f - g NEW_LINE if h < 0 or h > 9 : continue NEW_LINE n = a + c + d - f - j NEW_LINE if n < 0 or n > 9 : continue NEW_LINE p = a + b + c - h - l NEW_LINE if p < 0 or p > 9 : continue NEW_LINE ans += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.2676911621473386,"rouge_l":0.47377307519135525}
{"id":1650,"predictions":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT MOD = 10 ** 9 + 7 NEW_LINE MOD = 1000000007 NEW_LINE return str ( ans ) NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["def compute ( ) : NEW_LINE INDENT MOD = 10 ** 10 NEW_LINE ans = ( 28433 * pow ( 2 , 7830457 , MOD ) + 1 ) % MOD NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.6316170916414933,"rouge_l":0.7146443514644351}
{"id":1651,"predictions":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT start_number = 0 NEW_LINE end_number = 10000 NEW_LINE while start_number < end_number : NEW_LINE INDENT start_number += 1 NEW_LINE start_number = end_number + end_number NEW_LINE end_number = ( start_number , end_number ) NEW_LINE if end_number < end_number : NEW_LINE INDENT start_number += 1 NEW_LINE end_number = start_number NEW_LINE DEDENT else : NEW_LINE INDENT start_number = end_number + start_number NEW_LINE if start_number == end_number : NEW_LINE INDENT end_number += 1 NEW_LINE start_number = end_number NEW_LINE DEDENT else : NEW_LINE INDENT end_number = start_number NEW_LINE start_number += 1 NEW_LINE if start_number == end_number : NEW_LINE INDENT if start_number == end_number : NEW_LINE INDENT start_number = end_number NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT end_number = end_number NEW_LINE start_number += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return str ( start_number ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT compute ( ) NEW_LINE DEDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import eulerlib , fractions NEW_LINE def compute ( ) : NEW_LINE INDENT START_NUM = 1 NEW_LINE END_NUM = 500 NEW_LINE CROAK_SEQ = \" PPPPNNPPPNPPNPN \" NEW_LINE assert 0 <= START_NUM < END_NUM NEW_LINE assert 1 <= len ( CROAK_SEQ ) NEW_LINE NUM_JUMPS = len ( CROAK_SEQ ) - 1 NEW_LINE NUM_TRIALS = 2 ** NUM_JUMPS NEW_LINE globalnumerator = 0 NEW_LINE isprime = eulerlib . list_primality ( END_NUM ) NEW_LINE for i in range ( START_NUM , END_NUM + 1 ) : NEW_LINE INDENT for j in range ( NUM_TRIALS ) : NEW_LINE INDENT pos = i NEW_LINE trialnumerator = 1 NEW_LINE if isprime [ pos ] == ( CROAK_SEQ [ 0 ] == ' P ' ) : NEW_LINE INDENT trialnumerator *= 2 NEW_LINE DEDENT for k in range ( NUM_JUMPS ) : NEW_LINE INDENT if pos <= START_NUM : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT elif pos >= END_NUM : NEW_LINE INDENT pos -= 1 NEW_LINE DEDENT elif ( j >> k ) & 1 == 0 : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT else : NEW_LINE INDENT pos -= 1 NEW_LINE DEDENT if isprime [ pos ] == ( CROAK_SEQ [ k + 1 ] == ' P ' ) : NEW_LINE INDENT trialnumerator *= 2 NEW_LINE DEDENT DEDENT globalnumerator += trialnumerator NEW_LINE DEDENT DEDENT globaldenominator = ( END_NUM + 1 - START_NUM ) * 2 ** NUM_JUMPS * 3 ** len ( CROAK_SEQ ) NEW_LINE ans = fractions . Fraction ( globalnumerator , globaldenominator ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.17956891033930383,"rouge_l":0.3996759194025644}
{"id":1652,"predictions":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 8 NEW_LINE isprime = eulerlib . list_primality ( LIMIT ) NEW_LINE def is_prime ( x ) : NEW_LINE INDENT for i in range ( 1 , x + 1 ) : NEW_LINE INDENT if eulerlib . sqrt ( x ) >= len ( isprime ) : NEW_LINE INDENT break NEW_LINE DEDENT if isprime [ i ] : NEW_LINE INDENT break NEW_LINE DEDENT if isprime [ i ] : NEW_LINE INDENT is_prime [ i ] = True NEW_LINE DEDENT DEDENT DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import eulerlib , fractions , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 8 NEW_LINE ans = 0 NEW_LINE isprime = eulerlib . list_primality ( LIMIT - 1 ) NEW_LINE for x in range ( 1 , LIMIT \/\/ 4 + 1 ) : NEW_LINE INDENT for y in itertools . count ( 1 ) : NEW_LINE INDENT a = x * y * y - 1 NEW_LINE if a >= LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT if not isprime [ a ] : NEW_LINE INDENT continue NEW_LINE DEDENT for z in itertools . count ( y + 1 ) : NEW_LINE INDENT if fractions . gcd ( y , z ) != 1 : NEW_LINE INDENT continue NEW_LINE DEDENT c = x * z * z - 1 NEW_LINE if c >= LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT if isprime [ c ] : NEW_LINE INDENT b = x * y * z - 1 NEW_LINE if isprime [ b ] : NEW_LINE INDENT ans += a + b + c NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.33657873009421846,"rouge_l":0.5678115982500233}
{"id":1653,"predictions":["import eulerlib , fractions , fractions , Fraction NEW_LINE def compute ( ) : NEW_LINE INDENT TARGET = fractions . Fraction ( Fraction ( TARGET , TARGET ) ) NEW_LINE Fraction = reduce ( fractions . Fraction ( G , F , numbers ) ) NEW_LINE return Fraction ( Fraction ( Fraction ( Fraction ( F , numbers ) , numbers [ 0 ] , numbers [ 1 ] ) ) if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import itertools NEW_LINE from fractions import Fraction NEW_LINE DEGREE = 10 NEW_LINE def compute ( ) : NEW_LINE INDENT ans = Fraction ( 0 , 1 ) NEW_LINE for k in range ( 1 , DEGREE + 1 ) : NEW_LINE INDENT for n in itertools . count ( k + 1 ) : NEW_LINE INDENT if n == DEGREE + 2 : NEW_LINE INDENT raise AssertionError ( ) NEW_LINE DEDENT reference = Fraction ( generating_function ( n ) , 1 ) NEW_LINE term = optimum_polynomial ( k , n ) NEW_LINE if term != reference : NEW_LINE INDENT ans += term NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT return str ( ans . numerator ) + ( \" \" if ans . denominator == 1 else \" \/ \" + str ( ans . denominator ) ) NEW_LINE DEDENT def optimum_polynomial ( k , n ) : NEW_LINE INDENT sum = Fraction ( 0 , 1 ) NEW_LINE for i in range ( k + 1 ) : NEW_LINE INDENT product = Fraction ( generating_function ( i ) , 1 ) NEW_LINE for j in range ( 1 , k + 1 ) : NEW_LINE INDENT if j != i : NEW_LINE INDENT product *= Fraction ( n - j , i - j ) NEW_LINE DEDENT DEDENT sum += product NEW_LINE DEDENT return sum NEW_LINE DEDENT def generating_function ( n ) : NEW_LINE INDENT return sum ( ( - n ) ** i for i in range ( DEGREE + 1 ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.05404118104813095,"rouge_l":0.30321056062581486}
{"id":1654,"predictions":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT MODULUS = 500 NEW_LINE MODULUS = 1000000007 NEW_LINE def compute ( ) : NEW_LINE INDENT for i in range ( 1 , 500 ) : NEW_LINE INDENT numerator = pow ( i , i + 1 ) % MODULUS NEW_LINE numSubsets = [ i for i in str ( i ) if i > 500 ] NEW_LINE rem = ( numsubsets - numsubsets ) % MODULUS NEW_LINE if rem == 0 : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT numsubsets . append ( numsubsets ) NEW_LINE DEDENT DEDENT DEDENT return str ( num ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["def compute ( ) : NEW_LINE INDENT MOD = 10 ** 16 NEW_LINE subsets = [ 0 ] * 250 NEW_LINE subsets [ 0 ] = 1 NEW_LINE for i in range ( 1 , 250250 + 1 ) : NEW_LINE INDENT offset = pow ( i , i , 250 ) NEW_LINE subsets = [ ( val + subsets [ ( j - offset ) % 250 ] ) % MOD for ( j , val ) in enumerate ( subsets ) ] NEW_LINE DEDENT ans = ( subsets [ 0 ] - 1 ) % MOD NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.39204823140975026,"rouge_l":0.5632935744517122}
{"id":1655,"predictions":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT ans = sum ( 1 for i in range ( 2 , eulerlib . sqrt ( i ) ) if eulerlib . sqrt ( i ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT totients = eulerlib . list_totients ( 10 ** 6 ) NEW_LINE ans = sum ( itertools . islice ( totients , 2 , None ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.6341124537708652,"rouge_l":0.7208271787296898}
{"id":1656,"predictions":["import itertools NEW_LINE def compute ( ) : NEW_LINE INDENT total = sum ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) NEW_LINE return str ( total ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["def compute ( ) : NEW_LINE INDENT TOTAL = 200 NEW_LINE ways = [ 1 ] + [ 0 ] * TOTAL NEW_LINE for coin in [ 1 , 2 , 5 , 10 , 20 , 50 , 100 , 200 ] : NEW_LINE INDENT for i in range ( len ( ways ) - coin ) : NEW_LINE INDENT ways [ i + coin ] += ways [ i ] NEW_LINE DEDENT DEDENT return str ( ways [ - 1 ] ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.2567434941981002,"rouge_l":0.4587307410124724}
{"id":1657,"predictions":["import math NEW_LINE def compute ( ) : NEW_LINE INDENT x = sum ( x ) NEW_LINE y = - 1 NEW_LINE for i in range ( 1 , 10000000 ) : NEW_LINE INDENT x = i NEW_LINE y = f ( x ) NEW_LINE if x > y and x == y : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return str ( x ) NEW_LINE DEDENT def f ( x ) : NEW_LINE INDENT return int ( math . sqrt ( x ) ) + 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import math NEW_LINE def compute ( ) : NEW_LINE INDENT def f ( x ) : NEW_LINE INDENT return math . floor ( 2.0 ** ( 30.403243784 - x * x ) ) \/ 1.0e9 NEW_LINE DEDENT ITERATIONS = 10 ** 12 NEW_LINE x = - 1.0 NEW_LINE y = - 1.0 NEW_LINE i = 0 NEW_LINE while i < ITERATIONS : NEW_LINE INDENT if i > 0 and x == y : NEW_LINE INDENT break NEW_LINE DEDENT x = f ( x ) NEW_LINE y = f ( f ( y ) ) NEW_LINE i += 1 NEW_LINE DEDENT remain = ( ITERATIONS - i ) % i NEW_LINE for i in range ( remain ) : NEW_LINE INDENT x = f ( x ) NEW_LINE DEDENT ans = x + f ( x ) NEW_LINE ans = math . floor ( ans * 1.0e9 ) \/ 1.0e9 NEW_LINE return f \" { ans : .9f } \" NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.36188874957672346,"rouge_l":0.478714254998925}
{"id":1658,"predictions":["import fractions NEW_LINE def compute ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE ans = sum ( int ( c ) for c in str ( n ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["def compute ( ) : NEW_LINE INDENT ans = max ( sum ( int ( c ) for c in str ( a ** b ) ) for a in range ( 100 ) for b in range ( 100 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.6659594848798652,"rouge_l":0.7485563041385949}
{"id":1659,"predictions":["import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT MOD = 10 ** 9 NEW_LINE MAX = 10 ** 9 NEW_LINE ans = 1 NEW_LINE for i in itertools . count ( range ( 10 ) ) : NEW_LINE INDENT if itertools . count ( str ( ans ) ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["def compute ( ) : NEW_LINE INDENT ans = max ( digit_product ( NUMBER [ i : i + ADJACENT ] ) for i in range ( len ( NUMBER ) - ADJACENT + 1 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def digit_product ( s ) : NEW_LINE INDENT result = 1 NEW_LINE for c in s : NEW_LINE INDENT result *= int ( c ) NEW_LINE DEDENT return result NEW_LINE DEDENT NUMBER = \"7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450\" NEW_LINE ADJACENT = 13 NEW_LINE if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.40179175875833006,"rouge_l":0.5202341137123746}
{"id":1660,"predictions":["import fractions NEW_LINE def compute ( ) : NEW_LINE INDENT BASE = 20 NEW_LINE BASE = 10 NEW_LINE F = 1 NEW_LINE dp = [ 0 ] * ( MAX_SUM + 1 ) NEW_LINE def dp ( ) : NEW_LINE INDENT if d == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT DEDENT def digit_sum ( num ) : NEW_LINE INDENT if ( d == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT for x in range ( 1 , 10000000 ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( digits [ x ] ) : NEW_LINE INDENT sum += digit_sum ( digits [ x ] ) NEW_LINE digits [ x ] += 1 NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT def digit_sum ( digits ) : NEW_LINE INDENT result = 0 NEW_LINE while ( digits ) : NEW_LINE INDENT result += 1 NEW_LINE digits [ - 1 ] -= 1 NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["def compute ( ) : NEW_LINE INDENT BASE = 10 NEW_LINE DIGITS = 20 NEW_LINE CONSECUTIVE = 3 NEW_LINE MAX_SUM = 9 NEW_LINE innerlen = BASE ** CONSECUTIVE NEW_LINE ways = [ [ 1 ] + [ 0 ] * ( innerlen - 1 ) ] NEW_LINE for digits in range ( 1 , DIGITS + CONSECUTIVE + 1 ) : NEW_LINE INDENT newrow = [ ] NEW_LINE for prefix in range ( innerlen ) : NEW_LINE INDENT sum = 0 NEW_LINE if digit_sum ( prefix ) <= MAX_SUM : NEW_LINE INDENT for nextdigit in range ( BASE ) : NEW_LINE INDENT sum += ways [ digits - 1 ] [ prefix % ( BASE ** ( CONSECUTIVE - 1 ) ) * BASE + nextdigit ] NEW_LINE DEDENT DEDENT newrow . append ( sum ) NEW_LINE DEDENT ways . append ( newrow ) NEW_LINE DEDENT ans = ways [ - 1 ] [ 0 ] - ways [ - 2 ] [ 0 ] NEW_LINE return str ( ans ) NEW_LINE DEDENT def digit_sum ( n ) : NEW_LINE INDENT return sum ( int ( c ) for c in str ( n ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.3366657547711275,"rouge_l":0.4644301689269569}
{"id":1661,"predictions":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 9 NEW_LINE MOD = 1000000007 NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 9 + 1 NEW_LINE for i in range ( LIMIT + 1 ) : NEW_LINE INDENT if eulerlib . sqrt ( i ) : NEW_LINE INDENT LIMIT = i * i % MOD NEW_LINE return i NEW_LINE DEDENT DEDENT DEDENT DEDENT def sum_small ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 1 , LIMIT + 1 ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( LIMIT + 1 , LIMIT ) : NEW_LINE INDENT if fractions . is_small ( n ) : NEW_LINE INDENT result = result + j NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT result = result + pow ( i , j , mod ) NEW_LINE DEDENT return result % MOD NEW_LINE DEDENT DEDENT def sum_small ( n ) : NEW_LINE INDENT result = divide_small ( i + 1 ) NEW_LINE return result % MOD NEW_LINE DEDENT return result % MODULUS NEW_LINE DEDENT def sum_small ( n ) : NEW_LINE INDENT x = divide_small ( x , 0 , 1 ) NEW_LINE y = divide_small ( n , 1 ) NEW_LINE return y * ( x + y ) % MODULUS NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 15 NEW_LINE MODULUS = 10 ** 9 NEW_LINE splitcount = eulerlib . sqrt ( LIMIT ) NEW_LINE splitat = LIMIT \/\/ ( splitcount + 1 ) NEW_LINE def sum_squares ( s , e ) : NEW_LINE INDENT return ( e * ( e + 1 ) * ( e * 2 + 1 ) - s * ( s + 1 ) * ( s * 2 + 1 ) ) \/\/ 6 NEW_LINE DEDENT ans = sum ( ( i * i * ( LIMIT \/\/ i ) ) for i in range ( 1 , splitat + 1 ) ) NEW_LINE ans += sum ( ( sum_squares ( LIMIT \/\/ ( i + 1 ) , LIMIT \/\/ i ) * i ) for i in range ( 1 , splitcount + 1 ) ) NEW_LINE return str ( ans % MODULUS ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.2956361478220612,"rouge_l":0.44227021127309585}
{"id":1662,"predictions":["import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT def compute ( ) : NEW_LINE INDENT ans = next ( filter ( eulerlib . is_prime , itertools . count ( 2 ) ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def num_primes ( a , b ) : NEW_LINE INDENT return str ( a ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT ans = max ( ( ( a , b ) for a in range ( - 999 , 1000 ) for b in range ( 2 , 1000 ) ) , key = count_consecutive_primes ) NEW_LINE return str ( ans [ 0 ] * ans [ 1 ] ) NEW_LINE DEDENT def count_consecutive_primes ( ab ) : NEW_LINE INDENT a , b = ab NEW_LINE for i in itertools . count ( ) : NEW_LINE INDENT n = i * i + i * a + b NEW_LINE if not is_prime ( n ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT DEDENT isprimecache = eulerlib . list_primality ( 1000 ) NEW_LINE def is_prime ( n ) : NEW_LINE INDENT if n < 0 : NEW_LINE INDENT return False NEW_LINE DEDENT elif n < len ( isprimecache ) : NEW_LINE INDENT return isprimecache [ n ] NEW_LINE DEDENT else : NEW_LINE INDENT return eulerlib . is_prime ( n ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.18126540888322878,"rouge_l":0.4359538207806487}
{"id":1663,"predictions":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10000 NEW_LINE isprime = eulerlib . list_primality ( LIMIT \/\/ 2 , LIMIT \/\/ 2 ) NEW_LINE numSubset = [ ] NEW_LINE for i in range ( LIMIT ) : NEW_LINE INDENT if isprime [ i ] : NEW_LINE INDENT continue NEW_LINE DEDENT for j in range ( i , LIMIT , - 1 , - 1 ) : NEW_LINE INDENT if isprime [ j ] : NEW_LINE INDENT numSubset . append ( j ) NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT numSubset [ j - 1 ] = numSubset [ j - i ] + numsubset [ j ] NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( LIMIT ) : NEW_LINE INDENT if isprime [ i ] : NEW_LINE INDENT ans += ( sumSubset [ i ] + numSubset [ i - j ] ) % MODULUS NEW_LINE DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 5000 NEW_LINE MODULUS = 10 ** 16 NEW_LINE count = [ 0 ] * ( LIMIT ** 2 \/\/ 2 ) NEW_LINE count [ 0 ] = 1 NEW_LINE s = 0 NEW_LINE for p in eulerlib . list_primes ( LIMIT ) : NEW_LINE INDENT for i in reversed ( range ( s + 1 ) ) : NEW_LINE INDENT count [ i + p ] = ( count [ i + p ] + count [ i ] ) % MODULUS NEW_LINE DEDENT s += p NEW_LINE DEDENT isprime = eulerlib . list_primality ( s + 1 ) NEW_LINE ans = sum ( count [ i ] for i in range ( s + 1 ) if isprime [ i ] ) % MODULUS NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.4138794104848927,"rouge_l":0.5669890151159516}
{"id":1664,"predictions":["import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT N = 5 NEW_LINE for i in itertools . count ( 1 , 2 ) : NEW_LINE INDENT return str ( i ) NEW_LINE DEDENT DEDENT def compute ( ) : NEW_LINE INDENT end = eulerlib . list_primes ( ) NEW_LINE end = eulerlib . sqrt ( end ) + 1 NEW_LINE end = ( end << end ) - 1 NEW_LINE for i in range ( start , end + 1 , 2 ) : NEW_LINE INDENT if check ( i , end , i ) : NEW_LINE INDENT sum = sum + i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["def compute ( ) : NEW_LINE INDENT N = 5 NEW_LINE TWO_POW_N = 2 ** N NEW_LINE MASK = TWO_POW_N - 1 NEW_LINE def check_arrangement ( digits ) : NEW_LINE INDENT seen = set ( ) NEW_LINE digits |= digits << TWO_POW_N NEW_LINE for i in range ( TWO_POW_N ) : NEW_LINE INDENT seen . add ( ( digits >> i ) & MASK ) NEW_LINE DEDENT return len ( seen ) == TWO_POW_N NEW_LINE DEDENT start = 2 ** ( TWO_POW_N - N - 1 ) + 1 NEW_LINE end = 2 ** ( TWO_POW_N - N ) NEW_LINE ans = sum ( i for i in range ( start , end , 2 ) if check_arrangement ( i ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.4172009403353072,"rouge_l":0.5469299738962661}
{"id":1665,"predictions":["import eulerlib , fractions , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 7 NEW_LINE isprime = 1 NEW_LINE for i in range ( 2 , len ( num ) - 1 ) : NEW_LINE INDENT if isprime [ i ] : NEW_LINE INDENT for j in range ( i * 2 , len ( num_prime ) ) : NEW_LINE INDENT if i % j == 0 : NEW_LINE INDENT isprime += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return str ( sum ( num ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["def compute ( ) : NEW_LINE INDENT divisors = [ 2 ] * ( 10 ** 7 + 1 ) NEW_LINE for i in range ( 2 , ( len ( divisors ) + 1 ) \/\/ 2 ) : NEW_LINE INDENT for j in range ( i * 2 , len ( divisors ) , i ) : NEW_LINE INDENT divisors [ j ] += 1 NEW_LINE DEDENT DEDENT ans = sum ( ( 1 if divisors [ i ] == divisors [ i + 1 ] else 0 ) for i in range ( 2 , len ( divisors ) - 1 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.48720069674322114,"rouge_l":0.6072398190045248}
{"id":1666,"predictions":["def compute ( ) : NEW_LINE INDENT triangle = [ [ i for i in range ( 6 ) ] for j in range ( 2 ) ] NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT triangle [ i ] += max ( triangle [ i ] , triangle [ i ] [ i ] ) NEW_LINE DEDENT return str ( triangle ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT triangle = [ [ 75 , 65 , 65 , 65 , 27 , 27 , 96 , 27 , 56 ] , [ 78 , 89 , 78 , 90 , 81 , 78 , 89 , 78 , 77 , 89 , 56 ] NEW_LINE ans = sum ( triangle ) NEW_LINE print ( ans ) NEW_LINE DEDENT"],"references":["def compute ( ) : NEW_LINE INDENT for i in reversed ( range ( len ( triangle ) - 1 ) ) : NEW_LINE INDENT for j in range ( len ( triangle [ i ] ) ) : NEW_LINE INDENT triangle [ i ] [ j ] += max ( triangle [ i + 1 ] [ j ] , triangle [ i + 1 ] [ j + 1 ] ) NEW_LINE DEDENT DEDENT return str ( triangle [ 0 ] [ 0 ] ) NEW_LINE DEDENT triangle = [ [ 75 ] , [ 95 , 64 ] , [ 17 , 47 , 82 ] , [ 18 , 35 , 87 , 10 ] , [ 20 , 4 , 82 , 47 , 65 ] , [ 19 , 1 , 23 , 75 , 3 , 34 ] , [ 88 , 2 , 77 , 73 , 7 , 63 , 67 ] , [ 99 , 65 , 4 , 28 , 6 , 16 , 70 , 92 ] , [ 41 , 41 , 26 , 56 , 83 , 40 , 80 , 70 , 33 ] , [ 41 , 48 , 72 , 33 , 47 , 32 , 37 , 16 , 94 , 29 ] , [ 53 , 71 , 44 , 65 , 25 , 43 , 91 , 52 , 97 , 51 , 14 ] , [ 70 , 11 , 33 , 28 , 77 , 73 , 17 , 78 , 39 , 68 , 17 , 57 ] , [ 91 , 71 , 52 , 38 , 17 , 14 , 91 , 43 , 58 , 50 , 27 , 29 , 48 ] , [ 63 , 66 , 4 , 68 , 89 , 53 , 67 , 30 , 73 , 16 , 69 , 87 , 40 , 31 ] , [ 4 , 62 , 98 , 27 , 23 , 9 , 70 , 98 , 73 , 93 , 38 , 53 , 60 , 4 , 23 ] , ] NEW_LINE if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.08523203721737975,"rouge_l":0.3157894736842105}
{"id":1667,"predictions":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT ans = sum ( 1 for _ in range ( 2 , 20 ) if eulerlib . sqrt ( 40 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT return str ( eulerlib . binomial ( 40 , 20 ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.6034011845009126,"rouge_l":0.7758346581875993}
{"id":1668,"predictions":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 5 NEW_LINE primes = eulerlib . sqrt ( LIMIT ) NEW_LINE for p in range ( 2 , LIMIT ) : NEW_LINE INDENT for q in range ( p , LIMIT , p ) : NEW_LINE INDENT q = q * p NEW_LINE if q > LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT if q > LIMIT : NEW_LINE INDENT primes . append ( q ) NEW_LINE DEDENT DEDENT DEDENT return ways NEW_LINE DEDENT ans = set ( ) NEW_LINE for p in primes : NEW_LINE INDENT if p > LIMIT : NEW_LINE INDENT ans . add ( p ) NEW_LINE DEDENT DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 50000000 NEW_LINE primes = eulerlib . list_primes ( eulerlib . sqrt ( LIMIT ) ) NEW_LINE sums = { 0 } NEW_LINE for i in range ( 2 , 5 ) : NEW_LINE INDENT newsums = set ( ) NEW_LINE for p in primes : NEW_LINE INDENT q = p ** i NEW_LINE if q > LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT for x in sums : NEW_LINE INDENT if x + q <= LIMIT : NEW_LINE INDENT newsums . add ( x + q ) NEW_LINE DEDENT DEDENT DEDENT sums = newsums NEW_LINE DEDENT return str ( len ( sums ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.592175414442978,"rouge_l":0.6806136680613667}
{"id":1669,"predictions":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT MODULUS NEW_LINE MODULUS = 10 ** 9 + 7 NEW_LINE ans = sum ( 1 for i in range ( 1 , 10000000 ) if eulerlib . is_prime ( i ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["def compute ( ) : NEW_LINE INDENT MOD = 10 ** 10 NEW_LINE ans = sum ( pow ( i , i , MOD ) for i in range ( 1 , 1001 ) ) % MOD NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.6475092748244649,"rouge_l":0.778848470248133}
{"id":1670,"predictions":["import fractions NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 6 NEW_LINE ans = sum ( 1 for i in range ( 1 , LIMIT ) if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import eulerlib , fractions NEW_LINE def compute ( ) : NEW_LINE INDENT totients = eulerlib . list_totients ( 10 ** 6 ) NEW_LINE ans = max ( range ( 2 , len ( totients ) ) , key = ( lambda i : fractions . Fraction ( i , totients [ i ] ) ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.33002193300869537,"rouge_l":0.6050749711649365}
{"id":1671,"predictions":["import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT isprime = eulerlib . sqrt ( 8 ) NEW_LINE ans = sum ( isprime ( eulerlib . isprime , 8 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT def s ( p ) : NEW_LINE INDENT return ( p - 3 ) * eulerlib . reciprocal_mod ( 8 % p , p ) % p NEW_LINE DEDENT ans = sum ( s ( p ) for p in eulerlib . prime_generator ( 10 ** 8 ) if p >= 5 ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.42802403589519333,"rouge_l":0.6865152445262942}
{"id":1672,"predictions":["import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 NEW_LINE for n in itertools . count ( 1 ) : NEW_LINE INDENT if n % 2 == 0 or n % 5 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import itertools NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 6 NEW_LINE for n in itertools . count ( LIMIT ) : NEW_LINE INDENT if least_divisible_repunit ( n ) > LIMIT : NEW_LINE INDENT return str ( n ) NEW_LINE DEDENT DEDENT DEDENT def least_divisible_repunit ( n ) : NEW_LINE INDENT if n % 2 == 0 or n % 5 == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT k = 1 NEW_LINE s = 1 NEW_LINE p = 1 NEW_LINE while s % n != 0 : NEW_LINE INDENT k += 1 NEW_LINE p = p * 10 % n NEW_LINE s = ( s + p ) % n NEW_LINE DEDENT return k NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.2920067577029201,"rouge_l":0.5768950967554196}
{"id":1673,"predictions":["import itertools NEW_LINE def compute ( ) : NEW_LINE INDENT ans = sum ( 1 for i in range ( 1 , 1001 ) if i == 2025 ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def isHappy ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if n % i == 0 and isHappy ( i ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return all ( isHappy ( n ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT ans = sum ( i for i in range ( 1 , 10000 ) if has_pandigital_product ( i ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def has_pandigital_product ( n ) : NEW_LINE INDENT for i in range ( 1 , eulerlib . sqrt ( n ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT temp = str ( n ) + str ( i ) + str ( n \/\/ i ) NEW_LINE if \" \" . join ( sorted ( temp ) ) == \"123456789\" : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.565175950789374,"rouge_l":0.7360718870346598}
{"id":1674,"predictions":["import eulerlib , fractions NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 5 NEW_LINE primes = eulerlib . list_primality ( LIMIT \/\/ 2 , 0 ) NEW_LINE def p_prime ( primes , p ) : NEW_LINE INDENT primes = eulerlib . list_primes ( primes ) NEW_LINE for i in range ( 2 , len ( primes ) ) : NEW_LINE INDENT p = primes [ i ] NEW_LINE while p * p <= LIMIT : NEW_LINE INDENT p = primes [ i ] NEW_LINE if p > LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT if p > LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT if p > LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT if p > LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for j in range ( i + 1 , LIMIT + 1 , LIMIT ) : NEW_LINE INDENT p = primes [ j ] NEW_LINE while p * p <= LIMIT : NEW_LINE INDENT p = primes [ j ] NEW_LINE while p % p == 0 : NEW_LINE INDENT p = p \/\/ p NEW_LINE power *= p NEW_LINE DEDENT if p > LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT if power % p == 0 : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return str ( res ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10000000 NEW_LINE possible = set ( ) NEW_LINE primes = eulerlib . list_primes ( LIMIT \/\/ 2 ) NEW_LINE end = eulerlib . sqrt ( LIMIT ) NEW_LINE for i in range ( len ( primes ) ) : NEW_LINE INDENT p = primes [ i ] NEW_LINE if p > end : NEW_LINE INDENT break NEW_LINE DEDENT for j in range ( i + 1 , len ( primes ) ) : NEW_LINE INDENT q = primes [ j ] NEW_LINE lcm = p * q NEW_LINE if lcm > LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT multlimit = LIMIT \/\/ lcm NEW_LINE multiplier = 1 NEW_LINE while multiplier * p <= multlimit : NEW_LINE INDENT multiplier *= p NEW_LINE DEDENT maxmult = multiplier NEW_LINE while multiplier % p == 0 : NEW_LINE INDENT multiplier \/\/= p NEW_LINE while multiplier * q <= multlimit : NEW_LINE INDENT multiplier *= q NEW_LINE DEDENT maxmult = max ( multiplier , maxmult ) NEW_LINE DEDENT possible . add ( maxmult * lcm ) NEW_LINE DEDENT DEDENT ans = sum ( possible ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.4623258030452394,"rouge_l":0.5794697291932511}
{"id":1675,"predictions":["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT primes = eulerlib . list_primes ( 1000000 ) NEW_LINE primes = eulerlib . sqrt ( 1000000 ) NEW_LINE p = primes ( 1000000 ) NEW_LINE primes = primes [ 1 ] NEW_LINE while True : NEW_LINE INDENT p = primes [ 0 ] NEW_LINE q = primes [ 1 ] NEW_LINE while p < p : NEW_LINE INDENT p = primes [ p ] - 1 NEW_LINE while p % p == 0 : NEW_LINE INDENT p = p \/\/ p NEW_LINE DEDENT p = p NEW_LINE DEDENT if p > primes [ p ] : NEW_LINE INDENT primes . append ( p ) NEW_LINE DEDENT DEDENT sum = sum NEW_LINE return str ( sum ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"references":["import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT ans = 0 NEW_LINE primes = eulerlib . list_primes ( 2000000 ) NEW_LINE for i in itertools . count ( 2 ) : NEW_LINE INDENT p = primes [ i ] NEW_LINE q = primes [ i + 1 ] NEW_LINE if p > 1000000 : NEW_LINE INDENT break NEW_LINE DEDENT k = 1 NEW_LINE while k < p : NEW_LINE INDENT k *= 10 NEW_LINE DEDENT m = ( q - p ) * eulerlib . reciprocal_mod ( k % q , q ) % q NEW_LINE ans += m * k + p NEW_LINE DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"],"bleu":0.4180480887831012,"rouge_l":0.5989372761926764}
{"id":1676,"predictions":["class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def add ( self , data ) : NEW_LINE INDENT self . graph = [ [ ] for i in range ( self . size ) ] NEW_LINE for i in range ( self . size ) : NEW_LINE INDENT self . graph [ i ] . append ( data ) NEW_LINE DEDENT def getNode ( self , data ) : NEW_LINE INDENT return self . data NEW_LINE DEDENT def addNode ( self , src , dest ) : NEW_LINE INDENT return self . graph [ src ] [ c ] NEW_LINE while ( len ( self . graph ) != 0 : NEW_LINE INDENT rR = self . graph [ rR ] NEW_LINE if ( rR != 0 ) : NEW_LINE INDENT self . graph [ r ] . append ( self . graph [ r ] . graph [ c ] ) NEW_LINE if ( rR - 1 >= 0 ) : NEW_LINE INDENT self . graph [ r ] . append ( ( rR ) ) NEW_LINE self . graph [ r ] . append ( ( rR ) NEW_LINE DEDENT self . graph [ r ] . append ( r ) NEW_LINE DEDENT DEDENT DEDENT def main ( ) : NEW_LINE INDENT r , c = map ( int , input ( ) . split ( ) ) NEW_LINE d = dict ( ) NEW_LINE for i in range ( r ) : NEW_LINE INDENT r , c = map ( int , input ( ) . split ( ) ) NEW_LINE d . add ( ( r , c ) ) NEW_LINE print ( main ( r , c ) ) NEW_LINE DEDENT"],"references":["class Solution ( object ) : NEW_LINE INDENT def floodFill ( self , image , sr , sc , newColor ) : NEW_LINE INDENT r_ls , c_ls = len ( image ) , len ( image [ 0 ] ) NEW_LINE color = image [ sr ] [ sc ] NEW_LINE if color == newColor : NEW_LINE INDENT return image NEW_LINE DEDENT queue = [ ( sr , sc ) ] NEW_LINE while len ( queue ) > 0 : NEW_LINE INDENT r , c = queue . pop ( 0 ) NEW_LINE if image [ r ] [ c ] == color : NEW_LINE INDENT image [ r ] [ c ] = newColor NEW_LINE if r - 1 >= 0 : queue . append ( ( r - 1 , c ) ) NEW_LINE if r + 1 < r_ls : queue . append ( ( r + 1 , c ) ) NEW_LINE if c - 1 >= 0 : queue . append ( ( r , c - 1 ) ) NEW_LINE if c + 1 < c_ls : queue . append ( ( r , c + 1 ) ) NEW_LINE DEDENT DEDENT return image NEW_LINE DEDENT DEDENT"],"bleu":0.19126196547740876,"rouge_l":0.40712350492301586}
{"id":1677,"predictions":["class Solution ( object ) : NEW_LINE INDENT def thirdMax ( self , nums ) : NEW_LINE INDENT if nums is None or len ( nums ) > 3 : NEW_LINE INDENT return True NEW_LINE DEDENT if nums [ 0 ] < 3 : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT DEDENT"],"references":["class Solution ( object ) : NEW_LINE INDENT def thirdMax ( self , nums ) : NEW_LINE INDENT import Queue NEW_LINE pq = Queue . PriorityQueue ( 4 ) NEW_LINE check = set ( ) NEW_LINE for n in nums : NEW_LINE INDENT if n in check : NEW_LINE INDENT continue NEW_LINE DEDENT pq . put ( n ) NEW_LINE check . add ( n ) NEW_LINE if len ( check ) > 3 : NEW_LINE INDENT check . remove ( pq . get ( ) ) NEW_LINE DEDENT DEDENT total = len ( check ) NEW_LINE while total < 3 and total > 1 : NEW_LINE INDENT total -= 1 NEW_LINE DEDENT return pq . get ( ) NEW_LINE DEDENT DEDENT"],"bleu":0.15753729055580734,"rouge_l":0.4230969308132478}
{"id":1678,"predictions":["class Solution ( object ) : NEW_LINE INDENT def intValueHelper ( self , k ) : NEW_LINE INDENT res = [ ] NEW_LINE for i in range ( 0 , len ( k ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if k <= 0 : NEW_LINE INDENT if num [ i ] != ' a ' : NEW_LINE INDENT res . append ( str ( i + k ) % ( k + 1 ) ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT res . append ( str ( num [ i ] ) % 10 ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT DEDENT"],"references":["class Solution ( object ) : NEW_LINE INDENT def licenseKeyFormatting ( self , S , K ) : NEW_LINE INDENT S = S . upper ( ) . replace ( ' - ' , ' ' ) NEW_LINE ls = len ( S ) NEW_LINE if ls % K == 0 : NEW_LINE INDENT pos = K NEW_LINE DEDENT else : NEW_LINE INDENT pos = ls % K NEW_LINE DEDENT res = S [ : pos ] NEW_LINE while pos < ls : NEW_LINE INDENT res += ' - ' + S [ pos : pos + K ] NEW_LINE pos += K NEW_LINE DEDENT return res NEW_LINE DEDENT DEDENT"],"bleu":0.27132592495284197,"rouge_l":0.4256867112100965}
{"id":1679,"predictions":["class Queue : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = 0 NEW_LINE DEDENT DEDENT def push ( self , data ) : NEW_LINE INDENT q = Queue ( ) NEW_LINE while ( not q . empty ( ) ) : NEW_LINE INDENT q . put ( 0 ) NEW_LINE DEDENT return q . get ( ) NEW_LINE DEDENT def put ( self ) : NEW_LINE INDENT while not q . empty ( ) : NEW_LINE INDENT v = q . get ( ) NEW_LINE if ( not v . empty ( ) ) : NEW_LINE INDENT return NEW_LINE DEDENT for i in range ( T ) : NEW_LINE INDENT q . put ( ptr ) NEW_LINE DEDENT DEDENT return len ( q ) NEW_LINE DEDENT"],"references":["class RecentCounter ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . queue = [ ] NEW_LINE DEDENT def ping ( self , t ) : NEW_LINE INDENT self . queue . append ( t ) NEW_LINE while self . queue and self . queue [ 0 ] < t - 3000 : NEW_LINE INDENT self . queue . pop ( 0 ) NEW_LINE DEDENT return len ( self . queue ) NEW_LINE DEDENT DEDENT"],"bleu":0.22485992298018154,"rouge_l":0.45635910224438897}
{"id":1680,"predictions":["class Solution ( object ) : def NEW_LINE INDENT def singleMoves ( self , words ) : NEW_LINE INDENT return [ words [ len ( words [ 0 ] ) - 1 ] + words [ 0 ] for words in words ] NEW_LINE DEDENT def duplicate ( words ) : NEW_LINE INDENT return sorted ( [ words [ 0 ] , words [ 1 ] , words [ 2 ] , words [ 2 ] , words [ - 1 ] ] ) NEW_LINE DEDENT return sum ( [ 2 ] for words in words ] ) NEW_LINE DEDENT DEDENT class Solution ( ) : NEW_LINE INDENT def main ( ) : NEW_LINE INDENT def iterate_tokens ( ) : NEW_LINE INDENT for line in sys . stdin : NEW_LINE INDENT return iterate_tokens ( ) NEW_LINE DEDENT DEDENT def iterate_tokens ( ) : NEW_LINE INDENT iterate_tokens ( ) NEW_LINE for word in line . split ( ) : NEW_LINE INDENT yield word NEW_LINE DEDENT DEDENT DEDENT tokens = iterate_tokens ( ) NEW_LINE INDENT for word in iterate_tokens ( ) : NEW_LINE INDENT tokens = iterate_tokens ( ) NEW_LINE N = int ( next ( tokens ) ) NEW_LINE tokens = [ int ( next ( tokens ) ) for tokens in next ( tokens ) ] NEW_LINE solve ( N ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"references":["Morse_tab = [ \" . - \" , \" - . . . \" , \" - . - . \" , \" - . . \" , \" . \" , \" . . - . \" , \" - - . \" , \" . . . . \" , \" . . \" , \" . - - - \" , \" - . - \" , \" . - . . \" , \" - - \" , \" - . \" , \" - - - \" , \" . - - . \" , \" - - . - \" , \" . - . \" , \" . . . \" , \" - \" , \" . . - \" , \" . . . - \" , \" . - - \" , \" - . . - \" , \" - . - - \" , \" - - . . \" ] NEW_LINE class Solution ( object ) : NEW_LINE INDENT def uniqueMorseRepresentations ( self , words ) : NEW_LINE INDENT if len ( words ) == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans_set = set ( ) NEW_LINE for word in words : NEW_LINE INDENT morsed = \" \" NEW_LINE for c in word : NEW_LINE INDENT morsed += Morse_tab [ ord ( c ) - ord ( ' a ' ) ] NEW_LINE DEDENT ans_set . add ( morsed ) NEW_LINE DEDENT return len ( ans_set ) NEW_LINE DEDENT DEDENT"],"bleu":0.14575587960590217,"rouge_l":0.24472213087800068}
{"id":1681,"predictions":["class Solution ( object ) : NEW_LINE INDENT def offsetSum ( self , nums ) : NEW_LINE INDENT if nums <= 1 : NEW_LINE INDENT return nums [ len ( nums ) ] NEW_LINE DEDENT DEDENT DEDENT"],"references":["class Solution : NEW_LINE INDENT def runningSum ( self , nums : List [ int ] ) -> List [ int ] : NEW_LINE INDENT if nums is None or len ( nums ) == 0 : NEW_LINE INDENT return nums NEW_LINE DEDENT for i in range ( 1 , len ( nums ) ) : NEW_LINE INDENT nums [ i ] += nums [ i - 1 ] NEW_LINE DEDENT return nums NEW_LINE DEDENT DEDENT"],"bleu":0.17998396315403623,"rouge_l":0.49986342529363553}
{"id":1682,"predictions":["class Node : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . key = key NEW_LINE self . prev = key NEW_LINE self . next = None NEW_LINE DEDENT DEDENT class Node : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . data = key NEW_LINE self . next = key NEW_LINE self . prev = None NEW_LINE DEDENT def get_node ( self , key ) : NEW_LINE INDENT self . next = key NEW_LINE self . prev = None NEW_LINE self . next = None NEW_LINE DEDENT def get_node ( self , key ) : NEW_LINE INDENT return Node ( key ) NEW_LINE DEDENT def get_node ( self ) : NEW_LINE INDENT return self . prev NEW_LINE DEDENT def get_node ( self ) : NEW_LINE INDENT self . nodes = input ( ) NEW_LINE self . nodes [ self . ] . prev NEW_LINE self . nodes [ key ] . prev = self . nodes [ key ] NEW_LINE self . prev = self . nodes [ key ] NEW_LINE DEDENT DEDENT def get_node ( self , key ) : NEW_LINE INDENT node = self . nodes [ key ] NEW_LINE self . nodes [ key ] . prev = self . nodes [ self . next ] NEW_LINE self . nodes [ key ] . prev = self . nodes [ key ] NEW_LINE DEDENT def get_node ( self , key ) : NEW_LINE INDENT node = self . nodes [ key ] NEW_LINE self . nodes [ key ] . prev = self . nodes [ key ] NEW_LINE self . nodes [ key ] . prev = self . nodes [ self . nodes [ key ] ] NEW_LINE self . nodes [ key ] . prev = self . nodes [ key ] . prev NEW_LINE self . get_node = self . nodes [ key ] . prev NEW_LINE self . nodes [ key ] . prev = self . nodes [ key ] NEW_LINE DEDENT def get_node ( self , key ) : NEW_LINE INDENT self . nodes [ key ] . prev = self . nodes [ key ] . prev NEW_LINE self . nodes [ key ] ."],"references":["class MyHashMap ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . size = 10000 NEW_LINE self . nodes = [ None ] * self . size NEW_LINE DEDENT def put ( self , key , value ) : NEW_LINE INDENT index = hash ( key ) % self . size NEW_LINE if self . nodes [ index ] is None : NEW_LINE INDENT self . nodes [ index ] = ListNode ( - 1 , - 1 ) NEW_LINE DEDENT prev = find ( self . nodes [ index ] , key ) NEW_LINE if prev . next is None : NEW_LINE INDENT prev . next = ListNode ( key , value ) NEW_LINE DEDENT else : NEW_LINE INDENT prev . next . val = value NEW_LINE DEDENT DEDENT def get ( self , key ) : NEW_LINE INDENT index = hash ( key ) % self . size NEW_LINE if self . nodes [ index ] is None : NEW_LINE INDENT return - 1 NEW_LINE DEDENT prev = find ( self . nodes [ index ] , key ) NEW_LINE if prev . next is None : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return prev . next . val NEW_LINE DEDENT DEDENT def remove ( self , key ) : NEW_LINE INDENT index = hash ( key ) % self . size NEW_LINE if self . nodes [ index ] is None : NEW_LINE INDENT return NEW_LINE DEDENT prev = find ( self . nodes [ index ] , key ) NEW_LINE if prev . next is None : NEW_LINE INDENT return NEW_LINE DEDENT prev . next = prev . next . next NEW_LINE DEDENT DEDENT def find ( bucket , key ) : NEW_LINE INDENT node = bucket NEW_LINE prev = None NEW_LINE while node is not None and node . key != key : NEW_LINE INDENT prev = node NEW_LINE node = node . next NEW_LINE DEDENT return prev NEW_LINE DEDENT class ListNode ( ) : NEW_LINE INDENT def __init__ ( self , key , val ) : NEW_LINE INDENT self . key = key NEW_LINE self . val = val NEW_LINE self . next = None NEW_LINE NEW_LINE DEDENT DEDENT"],"bleu":0.32555088857942854,"rouge_l":0.4702321327468316}
{"id":1683,"predictions":["class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . prev = None NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def push ( self , x ) : NEW_LINE INDENT if not self . head : NEW_LINE INDENT return Node ( x ) NEW_LINE DEDENT return self . head NEW_LINE DEDENT def push ( self , x , y ) : NEW_LINE INDENT if self . head ( x ) : NEW_LINE INDENT return self . data NEW_LINE DEDENT def push ( self , x ) : NEW_LINE INDENT self . head = self . x NEW_LINE return self . head NEW_LINE DEDENT def push ( self , x ) : NEW_LINE INDENT if self . head is None : NEW_LINE INDENT return self . data NEW_LINE DEDENT DEDENT def push ( self , x ) : NEW_LINE INDENT return x NEW_LINE DEDENT def push ( self , x ) : NEW_LINE INDENT return self . head ( x ) NEW_LINE DEDENT DEDENT def push ( self , new_node = self . new_node NEW_LINE def size ( self , x ) : NEW_LINE INDENT return self . data NEW_LINE DEDENT def flush ( self ) : NEW_LINE INDENT if self . head is None : NEW_LINE INDENT self . head = self . head NEW_LINE DEDENT self . head = self . head NEW_LINE for i in range ( self . head ) : NEW_LINE INDENT self . head [ i ] = self . head NEW_LINE self . head [ i ] = self . head NEW_LINE self . head = self . head NEW_LINE self . head = self . head NEW_LINE DEDENT def flush ( self ) : NEW_LINE INDENT if self . head is None : NEW_LINE INDENT self . head = self . head NEW_LINE self . head = self . head NEW_LINE for i in range ( self . head ) : NEW_LINE INDENT self . head [ i ] = self . head [ i ] NEW_LINE self . head [ i ] = self . head [ i ] NEW_LINE self . head"],"references":["class MaxStack ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . stack = [ ] NEW_LINE self . max_stack = [ ] NEW_LINE DEDENT def push ( self , x ) : NEW_LINE INDENT self . stack . append ( x ) NEW_LINE if len ( self . max_stack ) == 0 : NEW_LINE INDENT self . max_stack . append ( x ) NEW_LINE return NEW_LINE DEDENT if self . max_stack [ - 1 ] > x : NEW_LINE INDENT self . max_stack . append ( self . max_stack [ - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT self . max_stack . append ( x ) NEW_LINE DEDENT DEDENT def pop ( self ) : NEW_LINE INDENT if len ( self . stack ) != 0 : NEW_LINE INDENT self . max_stack . pop ( - 1 ) NEW_LINE return self . stack . pop ( - 1 ) NEW_LINE DEDENT DEDENT def top ( self ) : NEW_LINE INDENT return self . stack [ - 1 ] NEW_LINE DEDENT def peekMax ( self ) : NEW_LINE INDENT if len ( self . max_stack ) != 0 : NEW_LINE INDENT return self . max_stack [ - 1 ] NEW_LINE DEDENT DEDENT def popMax ( self ) : NEW_LINE INDENT val = self . peekMax ( ) NEW_LINE buff = [ ] NEW_LINE while self . top ( ) != val : NEW_LINE INDENT buff . append ( self . pop ( ) ) NEW_LINE DEDENT self . pop ( ) NEW_LINE while len ( buff ) != 0 : NEW_LINE INDENT self . push ( buff . pop ( - 1 ) ) NEW_LINE DEDENT return val NEW_LINE DEDENT DEDENT"],"bleu":0.28278726538157983,"rouge_l":0.4991306126623709}
{"id":1684,"predictions":["class Solution ( object ) : NEW_LINE INDENT def canRevy ( self , A ) : NEW_LINE INDENT return sum ( set ( A ) ) NEW_LINE DEDENT DEDENT"],"references":["class Solution ( object ) : NEW_LINE INDENT def canReorderDoubled ( self , A ) : NEW_LINE INDENT v_map = { } NEW_LINE A . sort ( key = lambda x : abs ( x ) ) NEW_LINE for n in A : NEW_LINE INDENT v_map [ n ] = v_map . get ( n , 0 ) + 1 NEW_LINE DEDENT for n in A : NEW_LINE INDENT if v_map [ n ] <= 0 : NEW_LINE INDENT continue NEW_LINE DEDENT if 2 * n in v_map and v_map [ 2 * n ] > 0 : NEW_LINE INDENT v_map [ n ] -= 1 NEW_LINE v_map [ 2 * n ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = Solution ( ) NEW_LINE print s . canReorderDoubled ( [ 3 , 1 , 3 , 6 ] ) NEW_LINE print s . canReorderDoubled ( [ 2 , 1 , 2 , 6 ] ) NEW_LINE print s . canReorderDoubled ( [ 4 , - 2 , 2 , - 4 ] ) NEW_LINE print s . canReorderDoubled ( [ 1 , 2 , 4 , 16 , 8 , 4 ] ) NEW_LINE DEDENT"],"bleu":0.0008930185564914068,"rouge_l":0.16864416541873054}
{"id":1685,"predictions":["class Solution ( object ) : NEW_LINE INDENT def repeatedNimes__ ( self , A ) : NEW_LINE INDENT ans = dict ( ) NEW_LINE for i , value in enumerate ( A ) : NEW_LINE INDENT ans [ value ] = i NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT"],"references":["import collections NEW_LINE class Solution ( object ) : NEW_LINE INDENT def repeatedNTimes ( self , A ) : NEW_LINE INDENT counter = collections . Counter ( A ) NEW_LINE return counter . most_common ( 1 ) [ 0 ] [ 0 ] NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = Solution ( ) NEW_LINE print s . repeatedNTimes ( [ 1 , 2 , 3 , 3 ] ) NEW_LINE print s . repeatedNTimes ( [ 2 , 1 , 2 , 5 , 3 , 2 ] ) NEW_LINE print s . repeatedNTimes ( [ 5 , 1 , 5 , 2 , 5 , 3 , 5 , 4 ] ) NEW_LINE DEDENT"],"bleu":0.09119169474893284,"rouge_l":0.3282416247179309}
{"id":1686,"predictions":["class Solution ( object ) : NEW_LINE INDENT def smallerNumbers ( self , nums ) : NEW_LINE INDENT count = [ 0 ] * len ( nums ) NEW_LINE for i in range ( len ( nums ) ) : NEW_LINE INDENT if nums [ i ] == 0 : NEW_LINE INDENT count [ nums [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count [ nums [ i ] ] += count [ nums [ i ] ] NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT DEDENT"],"references":["class Solution : NEW_LINE INDENT def smallerNumbersThanCurrent ( self , nums : List [ int ] ) -> List [ int ] : NEW_LINE INDENT count_list = [ 0 ] * 101 NEW_LINE for v in nums : NEW_LINE INDENT count_list [ v ] += 1 NEW_LINE DEDENT for i in range ( 1 , 101 ) : NEW_LINE INDENT count_list [ i ] += count_list [ i - 1 ] NEW_LINE DEDENT res = [ ] NEW_LINE for v in nums : NEW_LINE INDENT if v == 0 : NEW_LINE INDENT res . append ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT res . append ( count_list [ v - 1 ] ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT DEDENT"],"bleu":0.2853381630130325,"rouge_l":0.48594618968886216}
{"id":1687,"predictions":["class Solution ( object ) : NEW_LINE INDENT def isAnyEmpty ( self , word ) : NEW_LINE INDENT return set ( word ) NEW_LINE DEDENT DEDENT"],"references":["class Solution ( object ) : NEW_LINE INDENT def isAlienSorted ( self , words , order ) : NEW_LINE INDENT order_map = { } NEW_LINE for i , v in enumerate ( order ) : NEW_LINE INDENT order_map [ v ] = i NEW_LINE DEDENT def cmp_alien ( x , y ) : NEW_LINE INDENT ls = min ( len ( x ) , len ( y ) ) NEW_LINE index = 0 NEW_LINE while index < ls : NEW_LINE INDENT if x [ index ] != y [ index ] : NEW_LINE INDENT return order_map [ x [ index ] ] - order_map [ y [ index ] ] NEW_LINE DEDENT index += 1 NEW_LINE DEDENT return len ( x ) - len ( y ) NEW_LINE DEDENT pos = 0 NEW_LINE while pos + 1 < len ( words ) : NEW_LINE INDENT if cmp_alien ( words [ pos ] , words [ pos + 1 ] ) > 0 : NEW_LINE INDENT return False NEW_LINE DEDENT pos += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = Solution ( ) NEW_LINE print s . isAlienSorted ( [ \" hello \" , \" leetcode \" ] , \" hlabcdefgijkmnopqrstuvwxyz \" ) NEW_LINE print s . isAlienSorted ( [ \" word \" , \" world \" , \" row \" ] , \" worldabcefghijkmnpqstuvxyz \" ) NEW_LINE print s . isAlienSorted ( [ \" apple \" , \" app \" ] , \" abcdefghijklmnopqrstuvwxyz \" ) NEW_LINE DEDENT"],"bleu":6.592957003513968e-5,"rouge_l":0.1326349080846017}
{"id":1688,"predictions":["class Solution ( object ) : NEW_LINE"],"references":["class Solution ( object ) : NEW_LINE INDENT def findDisappearedNumbers ( self , nums ) : NEW_LINE INDENT res = [ ] NEW_LINE if nums : NEW_LINE INDENT n = len ( nums ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT val = abs ( nums [ i ] ) - 1 NEW_LINE if nums [ val ] > 0 : NEW_LINE INDENT nums [ val ] = - nums [ val ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if nums [ i ] > 0 : NEW_LINE INDENT res . append ( i + 1 ) NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT DEDENT"],"bleu":1.497519296407866e-7,"rouge_l":0.0973330294050604}
{"id":1689,"predictions":["class Solution ( object ) : NEW_LINE INDENT def toHame__ ( self , nums ) : NEW_LINE INDENT hex_map = { } NEW_LINE def to_map ( self , nums ) : NEW_LINE INDENT for k in range ( len ( nums ) ) : NEW_LINE INDENT hex_map [ k ] = 1 NEW_LINE DEDENT if nums [ 2 ] < 8 and len ( nums ) < 8 : NEW_LINE INDENT return \"0\" NEW_LINE DEDENT res = set ( [ : : - 1 ] ) NEW_LINE return res NEW_LINE DEDENT DEDENT DEDENT"],"references":["class Solution ( object ) : NEW_LINE INDENT def toHex ( self , num ) : NEW_LINE INDENT if num == 0 : NEW_LINE INDENT return '0' NEW_LINE DEDENT mp = '0123456789abcdef ' NEW_LINE ans = ' ' NEW_LINE for _ in range ( 8 ) : NEW_LINE INDENT n = num & 15 NEW_LINE c = mp [ n ] NEW_LINE ans = c + ans NEW_LINE num = num >> 4 NEW_LINE DEDENT return ans . lstrip ( '0' ) NEW_LINE DEDENT DEDENT"],"bleu":0.23544647129881785,"rouge_l":0.4417827298050139}
{"id":1690,"predictions":["class pair : NEW_LINE INDENT def __init__ ( self , mat ) : NEW_LINE INDENT self . mat = [ ] NEW_LINE self . col = 0 NEW_LINE DEDENT def getInt ( self , k ) : NEW_LINE INDENT res = [ ] NEW_LINE for i in range ( len ( self . mat ) ) : NEW_LINE INDENT self . mat [ i ] . append ( mat [ i ] ) NEW_LINE DEDENT DEDENT def check ( self , k ) : NEW_LINE INDENT res = [ False ] * len ( self . mat [ k ] ) NEW_LINE if ( len ( self . res ) == k ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT res [ i ] = True NEW_LINE DEDENT DEDENT for i in range ( k ) : NEW_LINE INDENT res [ i ] = res [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT def add ( self , k ) : NEW_LINE INDENT res = [ ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT res . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT res = pair ( ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT res . append ( res [ i ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"],"references":["class Solution ( object ) : NEW_LINE INDENT def kWeakestRows ( self , mat , k ) : NEW_LINE INDENT res = [ ] NEW_LINE num_row = len ( mat ) NEW_LINE num_col = len ( mat [ 0 ] ) NEW_LINE col = 0 NEW_LINE flag = 1 NEW_LINE while col < num_col and flag : NEW_LINE INDENT for i in range ( num_row ) : NEW_LINE INDENT if i in res : NEW_LINE INDENT continue NEW_LINE DEDENT if mat [ i ] [ col ] == 0 : NEW_LINE INDENT res . append ( i ) NEW_LINE DEDENT if len ( res ) == k : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT DEDENT col += 1 NEW_LINE DEDENT if len ( res ) == k : NEW_LINE INDENT return res NEW_LINE DEDENT for i in range ( num_row ) : NEW_LINE INDENT if i in res : NEW_LINE INDENT continue NEW_LINE DEDENT res . append ( i ) NEW_LINE if len ( res ) == k : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT DEDENT"],"bleu":0.2706261065907296,"rouge_l":0.4682420228777844}
{"id":1691,"predictions":["class Solution ( object ) : NEW_LINE INDENT def flipAndInvert ( self , A ) : NEW_LINE INDENT for i in range ( len ( A ) \/\/ 2 ) : NEW_LINE INDENT tmp = A [ i ] [ 0 ] NEW_LINE A [ i ] [ 1 ] = int ( A [ i + 1 ] [ 0 ] ) NEW_LINE row [ A [ i ] [ 1 ] ] = tmp NEW_LINE DEDENT return A NEW_LINE DEDENT DEDENT"],"references":["class Solution ( object ) : NEW_LINE INDENT def flipAndInvertImage ( self , A ) : NEW_LINE INDENT for row in A : NEW_LINE INDENT for i in xrange ( ( len ( row ) + 1 ) \/ 2 ) : NEW_LINE INDENT row [ i ] , row [ ~ i ] = row [ ~ i ] ^ 1 , row [ i ] ^ 1 NEW_LINE DEDENT DEDENT return A NEW_LINE DEDENT DEDENT"],"bleu":0.40472826214069607,"rouge_l":0.6418403135960388}
{"id":1692,"predictions":["class Solution ( object ) : NEW_LINE INDENT def sortSquares ( self , A ) : NEW_LINE INDENT pos , pos = 0 , 0 NEW_LINE while pos < len ( A ) : NEW_LINE INDENT if A [ pos ] * A [ pos ] < 0 : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT if pos < len ( A ) and A [ pos ] < 0 : NEW_LINE INDENT res = A [ pos ] * A [ pos ] NEW_LINE DEDENT pos += 1 NEW_LINE pos += 1 NEW_LINE DEDENT while pos < len ( A ) : NEW_LINE INDENT res = ( res * A [ pos ] * A [ pos ] ) NEW_LINE pos += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT DEDENT DEDENT"],"references":["class Solution ( object ) : NEW_LINE INDENT def sortedSquares ( self , A ) : NEW_LINE INDENT pos = 0 NEW_LINE while pos < len ( A ) and A [ pos ] < 0 : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT npos = pos - 1 NEW_LINE res = [ ] NEW_LINE while pos < len ( A ) and npos >= 0 : NEW_LINE INDENT if A [ npos ] ** 2 < A [ pos ] ** 2 : NEW_LINE INDENT res . append ( A [ npos ] ** 2 ) NEW_LINE npos -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT res . append ( A [ pos ] ** 2 ) NEW_LINE pos += 1 NEW_LINE DEDENT DEDENT while npos >= 0 : NEW_LINE INDENT res . append ( A [ npos ] ** 2 ) NEW_LINE npos -= 1 NEW_LINE DEDENT while pos < len ( A ) : NEW_LINE INDENT res . append ( A [ pos ] ** 2 ) NEW_LINE pos += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT DEDENT"],"bleu":0.4704120133513927,"rouge_l":0.621434392828036}
{"id":1693,"predictions":["class Solution ( object ) : NEW_LINE INDENT def midmap ( self , answers ) : NEW_LINE INDENT return midmap ( int , len ( answers ) ) NEW_LINE DEDENT DEDENT"],"references":["class Solution : NEW_LINE INDENT def defangIPaddr ( self , address : str ) -> str : NEW_LINE INDENT return address . replace ( ' . ' , ' [ . ] ' ) NEW_LINE DEDENT DEDENT"],"bleu":0.26137462856008453,"rouge_l":0.5790223065970574}
{"id":1694,"predictions":["class Solution ( object ) : NEW_LINE INDENT def searchBST ( self , root , val , val ) : NEW_LINE INDENT while root and val != None or val & val == val : NEW_LINE INDENT val = val & val NEW_LINE val &= val NEW_LINE val &= val NEW_LINE DEDENT return val NEW_LINE DEDENT DEDENT"],"references":["class Solution ( object ) : NEW_LINE INDENT def searchBST ( self , root , val ) : NEW_LINE INDENT while root : NEW_LINE INDENT if root . val == val : NEW_LINE INDENT return root NEW_LINE DEDENT elif root . val > val : NEW_LINE INDENT root = root . left NEW_LINE DEDENT else : NEW_LINE INDENT root = root . right NEW_LINE DEDENT DEDENT return root NEW_LINE DEDENT DEDENT"],"bleu":0.401857628448526,"rouge_l":0.5822657623712635}
{"id":1695,"predictions":["import math NEW_LINE def ip ( ip , n ) : NEW_LINE INDENT start = ip . bit_length ( ) NEW_LINE ans = int ( ip [ 0 ] ) NEW_LINE return ans NEW_LINE DEDENT def ip ( ip , n ) : NEW_LINE INDENT while ( n > 0 ) : NEW_LINE INDENT z = max ( x , n - bit_length ( ) ) NEW_LINE ans = [ ] NEW_LINE while ( n > 0 ) : NEW_LINE INDENT z = ans . pop ( ) NEW_LINE if ( z == 1 ) : NEW_LINE INDENT ans . append ( z ) NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( x ) NEW_LINE n -= 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT def bitlen ( x ) : NEW_LINE INDENT return ( x ^ 32 ) NEW_LINE DEDENT def bitlen ( x ) : NEW_LINE INDENT ans = 0 NEW_LINE while ( x > 0 ) : NEW_LINE INDENT ans = ans + ( x % 256 ) % 256 NEW_LINE x = x >> 16 NEW_LINE DEDENT return ans NEW_LINE DEDENT def bitlen ( x ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT compute ( ) NEW_LINE DEDENT"],"references":["class Solution ( object ) : NEW_LINE INDENT def ipToInt ( self , ip ) : NEW_LINE INDENT ans = 0 NEW_LINE for x in ip . split ( ' . ' ) : NEW_LINE INDENT ans = 256 * ans + int ( x ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def intToIP ( self , x ) : NEW_LINE INDENT return \" . \" . join ( str ( ( x >> i ) % 256 ) for i in ( 24 , 16 , 8 , 0 ) ) NEW_LINE DEDENT def ipToCIDR ( self , ip , n ) : NEW_LINE INDENT start = self . ipToInt ( ip ) NEW_LINE ans = [ ] NEW_LINE while n : NEW_LINE INDENT mask = max ( 33 - ( start & - start ) . bit_length ( ) , 33 - n . bit_length ( ) ) NEW_LINE ans . append ( self . intToIP ( start ) + ' \/ ' + str ( mask ) ) NEW_LINE start += 1 << ( 32 - mask ) NEW_LINE n -= 1 << ( 32 - mask ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT"],"bleu":0.33096998825595364,"rouge_l":0.397678486245826}
{"id":1696,"predictions":["class Solution ( object ) : NEW_LINE INDENT def depthOfBinaryTree ( self , root ) : NEW_LINE INDENT ans = 1 NEW_LINE return ans - 1 NEW_LINE DEDENT def depth ( root , current ) : NEW_LINE INDENT if root == None : NEW_LINE INDENT return 0 NEW_LINE DEDENT L = self . root ( root ) NEW_LINE R = edges ( current ) NEW_LINE return max ( L , R ) + 1 NEW_LINE DEDENT def depthOfBinaryTree ( root ) : NEW_LINE INDENT if root == None : NEW_LINE INDENT return 0 NEW_LINE DEDENT L = self . root ( root ) NEW_LINE R = self . root NEW_LINE while L != current : NEW_LINE INDENT R = self . root ( R ) NEW_LINE if R != root : NEW_LINE INDENT R = self . root NEW_LINE DEDENT return max ( L , R ) + 1 NEW_LINE DEDENT return max ( R , R + 1 ) + 1 NEW_LINE DEDENT DEDENT DEDENT"],"references":["class Solution ( object ) : NEW_LINE INDENT def diameterOfBinaryTree ( self , root ) : NEW_LINE INDENT self . ans = 1 NEW_LINE def depth ( node ) : NEW_LINE INDENT if not node : return 0 NEW_LINE L = depth ( node . left ) NEW_LINE R = depth ( node . right ) NEW_LINE self . ans = max ( self . ans , L + R + 1 ) NEW_LINE return max ( L , R ) + 1 NEW_LINE DEDENT depth ( root ) NEW_LINE return self . ans - 1 NEW_LINE DEDENT DEDENT"],"bleu":0.3107252320735744,"rouge_l":0.5456313196785065}
{"id":1697,"predictions":["class Node : NEW_LINE INDENT def __init__ ( self , root ) : NEW_LINE INDENT self . val = root NEW_LINE self . val = None NEW_LINE self . val = root NEW_LINE self . val = None NEW_LINE DEDENT def push ( self , root ) : NEW_LINE INDENT if not root : NEW_LINE INDENT return root . val NEW_LINE DEDENT if not root : NEW_LINE INDENT return self . val NEW_LINE DEDENT if root . val : NEW_LINE INDENT return self . val NEW_LINE DEDENT elif not root . val : NEW_LINE INDENT self . val = node . val NEW_LINE self . val = root . val NEW_LINE self . val += 1 NEW_LINE DEDENT else : NEW_LINE INDENT self . val = root . val NEW_LINE DEDENT DEDENT return self . DEDENT DEDENT def MinimumValue ( root ) : NEW_LINE INDENT if root == None : NEW_LINE INDENT return - 1 NEW_LINE DEDENT node = Node ( 2 ) NEW_LINE ans = Node ( root ) NEW_LINE while node : NEW_LINE INDENT node = node . val * 2 NEW_LINE if node . val > node . val : NEW_LINE INDENT ans = node . val NEW_LINE DEDENT elif node . val > node . val : NEW_LINE INDENT ans = node . val NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT root = Node ( 1 ) NEW_LINE root . left = Node ( 2 ) NEW_LINE root . right = Node ( 3 ) NEW_LINE root . right . left = Node ( 4 ) NEW_LINE root . right = Node ( 5 ) NEW_LINE root . right . right = Node ( 4 ) NEW_LINE result = MinimumValue ( root ) NEW_LINE print ( result ) NEW_LINE DEDENT"],"references":["class Solution ( object ) : NEW_LINE INDENT def findSecondMinimumValue ( self , root ) : NEW_LINE INDENT if not root : NEW_LINE INDENT return - 1 NEW_LINE DEDENT ans = float ( ' inf ' ) NEW_LINE min_val = root . val NEW_LINE stack = [ root ] NEW_LINE while stack : NEW_LINE INDENT curr = stack . pop ( ) NEW_LINE if not curr : NEW_LINE INDENT continue NEW_LINE DEDENT if min_val < curr . val < ans : NEW_LINE INDENT ans = curr . val NEW_LINE DEDENT elif curr . val == min_val : NEW_LINE INDENT stack . append ( curr . left ) NEW_LINE stack . append ( curr . right ) NEW_LINE DEDENT DEDENT return ans if ans < float ( ' inf ' ) else - 1 NEW_LINE DEDENT DEDENT"],"bleu":0.1644101659672702,"rouge_l":0.3930474902553496}
{"id":1698,"predictions":["class node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = head NEW_LINE DEDENT DEDENT def toNthFromEnd ( head , n ) : NEW_LINE INDENT fast . next = head NEW_LINE while ( fast . next != None ) : NEW_LINE INDENT fast = fast . next NEW_LINE DEDENT while ( fast . next == None ) : NEW_LINE INDENT fast = fast . next NEW_LINE DEDENT if ( fast . next == None ) : NEW_LINE INDENT head . next = fast . next NEW_LINE DEDENT return head NEW_LINE DEDENT def remove ( head ) : NEW_LINE INDENT while ( fast . next != None ) : NEW_LINE INDENT fast = fast . next NEW_LINE if ( fast . next == None ) : NEW_LINE INDENT head . next = fast . next NEW_LINE DEDENT fast = fast . next NEW_LINE return head . next NEW_LINE DEDENT DEDENT def remove ( head , n ) : NEW_LINE INDENT return head . next NEW_LINE DEDENT def remove ( head ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT return head NEW_LINE DEDENT st = head NEW_LINE while ( st . next != None ) : NEW_LINE INDENT print ( st . pop ( ) , end = \" \" ) NEW_LINE st . next = st . next NEW_LINE DEDENT return NEW_LINE DEDENT DEDENT def remove ( head , n ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT head = head NEW_LINE print ( head ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( head ) NEW_LINE DEDENT DEDENT"],"references":["class Solution ( object ) : NEW_LINE INDENT def removeNthFromEnd ( self , head , n ) : NEW_LINE INDENT if head is None : NEW_LINE INDENT return None NEW_LINE DEDENT slow = fast = head NEW_LINE for i in range ( n ) : NEW_LINE INDENT fast = fast . next NEW_LINE DEDENT if fast is None : NEW_LINE INDENT head = head . next NEW_LINE return head NEW_LINE DEDENT while fast . next is not None : NEW_LINE INDENT fast = fast . next NEW_LINE slow = slow . next NEW_LINE DEDENT curr = slow . next NEW_LINE slow . next = curr . next NEW_LINE return head NEW_LINE DEDENT DEDENT"],"bleu":0.21008023351530453,"rouge_l":0.46087425796006476}
